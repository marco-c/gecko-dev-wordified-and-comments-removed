use
pipeline
:
:
{
Pipeline
CompositionPipeline
}
;
use
compositor_task
:
:
CompositorProxy
;
use
compositor_task
:
:
Msg
as
CompositorMsg
;
use
devtools_traits
:
:
{
DevtoolsControlChan
DevtoolsControlMsg
}
;
use
geom
:
:
point
:
:
Point2D
;
use
geom
:
:
rect
:
:
{
Rect
TypedRect
}
;
use
geom
:
:
size
:
:
Size2D
;
use
geom
:
:
scale_factor
:
:
ScaleFactor
;
use
gfx
:
:
font_cache_task
:
:
FontCacheTask
;
use
layout_traits
:
:
{
LayoutControlChan
LayoutControlMsg
LayoutTaskFactory
}
;
use
libc
;
use
msg
:
:
compositor_msg
:
:
{
Epoch
LayerId
}
;
use
msg
:
:
constellation_msg
:
:
AnimationState
;
use
msg
:
:
constellation_msg
:
:
Msg
as
ConstellationMsg
;
use
msg
:
:
constellation_msg
:
:
{
FrameId
PipelineExitType
PipelineId
}
;
use
msg
:
:
constellation_msg
:
:
{
IFrameSandboxState
MozBrowserEvent
NavigationDirection
}
;
use
msg
:
:
constellation_msg
:
:
{
Key
KeyState
KeyModifiers
LoadData
}
;
use
msg
:
:
constellation_msg
:
:
{
SubpageId
WindowSizeData
}
;
use
msg
:
:
constellation_msg
:
:
{
self
ConstellationChan
Failure
}
;
use
msg
:
:
constellation_msg
:
:
WebDriverCommandMsg
;
use
msg
:
:
webdriver_msg
;
use
net_traits
:
:
{
self
ResourceTask
}
;
use
net_traits
:
:
image_cache_task
:
:
ImageCacheTask
;
use
net_traits
:
:
storage_task
:
:
{
StorageTask
StorageTaskMsg
}
;
use
profile_traits
:
:
mem
;
use
profile_traits
:
:
time
;
use
script_traits
:
:
{
CompositorEvent
ConstellationControlMsg
}
;
use
script_traits
:
:
{
ScriptControlChan
ScriptState
ScriptTaskFactory
}
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
io
:
:
{
self
Write
}
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
:
:
replace
;
use
std
:
:
sync
:
:
mpsc
:
:
{
Sender
Receiver
channel
}
;
use
style
:
:
viewport
:
:
ViewportConstraints
;
use
url
:
:
Url
;
use
util
:
:
cursor
:
:
Cursor
;
use
util
:
:
geometry
:
:
PagePx
;
use
util
:
:
opts
;
use
util
:
:
task
:
:
spawn_named
;
use
clipboard
:
:
ClipboardContext
;
pub
struct
Constellation
<
LTF
STF
>
{
pub
chan
:
ConstellationChan
pub
request_port
:
Receiver
<
ConstellationMsg
>
pub
compositor_proxy
:
Box
<
CompositorProxy
>
pub
resource_task
:
ResourceTask
pub
image_cache_task
:
ImageCacheTask
devtools_chan
:
Option
<
DevtoolsControlChan
>
storage_task
:
StorageTask
pipelines
:
HashMap
<
PipelineId
Pipeline
>
frames
:
HashMap
<
FrameId
Frame
>
pipeline_to_frame_map
:
HashMap
<
PipelineId
FrameId
>
subpage_map
:
HashMap
<
(
PipelineId
SubpageId
)
PipelineId
>
font_cache_task
:
FontCacheTask
root_frame_id
:
Option
<
FrameId
>
next_pipeline_id
:
PipelineId
next_frame_id
:
FrameId
focus_pipeline_id
:
Option
<
PipelineId
>
pending_frames
:
Vec
<
FrameChange
>
pub
time_profiler_chan
:
time
:
:
ProfilerChan
pub
mem_profiler_chan
:
mem
:
:
ProfilerChan
phantom
:
PhantomData
<
(
LTF
STF
)
>
pub
window_size
:
WindowSizeData
clipboard_ctx
:
Option
<
ClipboardContext
>
webdriver
:
WebDriverData
}
pub
struct
Frame
{
prev
:
Vec
<
PipelineId
>
current
:
PipelineId
next
:
Vec
<
PipelineId
>
}
impl
Frame
{
fn
new
(
pipeline_id
:
PipelineId
)
-
>
Frame
{
Frame
{
prev
:
vec
!
(
)
current
:
pipeline_id
next
:
vec
!
(
)
}
}
fn
load
(
&
mut
self
pipeline_id
:
PipelineId
)
-
>
Vec
<
PipelineId
>
{
self
.
prev
.
push
(
self
.
current
)
;
self
.
current
=
pipeline_id
;
replace
(
&
mut
self
.
next
vec
!
(
)
)
}
}
struct
FrameChange
{
old_pipeline_id
:
Option
<
PipelineId
>
new_pipeline_id
:
PipelineId
painter_ready
:
bool
}
struct
FrameTreeIterator
<
'
a
>
{
stack
:
Vec
<
FrameId
>
frames
:
&
'
a
HashMap
<
FrameId
Frame
>
pipelines
:
&
'
a
HashMap
<
PipelineId
Pipeline
>
}
impl
<
'
a
>
Iterator
for
FrameTreeIterator
<
'
a
>
{
type
Item
=
&
'
a
Frame
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
Frame
>
{
self
.
stack
.
pop
(
)
.
map
(
|
next
|
{
let
frame
=
self
.
frames
.
get
(
&
next
)
.
unwrap
(
)
;
let
pipeline
=
self
.
pipelines
.
get
(
&
frame
.
current
)
.
unwrap
(
)
;
self
.
stack
.
extend
(
pipeline
.
children
.
iter
(
)
.
map
(
|
&
c
|
c
)
)
;
frame
}
)
}
}
pub
struct
SendableFrameTree
{
pub
pipeline
:
CompositionPipeline
pub
rect
:
Option
<
TypedRect
<
PagePx
f32
>
>
pub
children
:
Vec
<
SendableFrameTree
>
}
struct
WebDriverData
{
load_channel
:
Option
<
(
PipelineId
Sender
<
webdriver_msg
:
:
LoadComplete
>
)
>
}
impl
WebDriverData
{
pub
fn
new
(
)
-
>
WebDriverData
{
WebDriverData
{
load_channel
:
None
}
}
}
#
[
derive
(
Clone
Copy
)
]
enum
ExitPipelineMode
{
Normal
Force
}
impl
<
LTF
:
LayoutTaskFactory
STF
:
ScriptTaskFactory
>
Constellation
<
LTF
STF
>
{
pub
fn
start
(
compositor_proxy
:
Box
<
CompositorProxy
+
Send
>
resource_task
:
ResourceTask
image_cache_task
:
ImageCacheTask
font_cache_task
:
FontCacheTask
time_profiler_chan
:
time
:
:
ProfilerChan
mem_profiler_chan
:
mem
:
:
ProfilerChan
devtools_chan
:
Option
<
DevtoolsControlChan
>
storage_task
:
StorageTask
supports_clipboard
:
bool
)
-
>
ConstellationChan
{
let
(
constellation_port
constellation_chan
)
=
ConstellationChan
:
:
new
(
)
;
let
constellation_chan_clone
=
constellation_chan
.
clone
(
)
;
spawn_named
(
"
Constellation
"
.
to_owned
(
)
move
|
|
{
let
mut
constellation
:
Constellation
<
LTF
STF
>
=
Constellation
{
chan
:
constellation_chan_clone
request_port
:
constellation_port
compositor_proxy
:
compositor_proxy
devtools_chan
:
devtools_chan
resource_task
:
resource_task
image_cache_task
:
image_cache_task
font_cache_task
:
font_cache_task
storage_task
:
storage_task
pipelines
:
HashMap
:
:
new
(
)
frames
:
HashMap
:
:
new
(
)
pipeline_to_frame_map
:
HashMap
:
:
new
(
)
subpage_map
:
HashMap
:
:
new
(
)
pending_frames
:
vec
!
(
)
next_pipeline_id
:
PipelineId
(
0
)
root_frame_id
:
None
next_frame_id
:
FrameId
(
0
)
focus_pipeline_id
:
None
time_profiler_chan
:
time_profiler_chan
mem_profiler_chan
:
mem_profiler_chan
window_size
:
WindowSizeData
{
visible_viewport
:
opts
:
:
get
(
)
.
initial_window_size
.
as_f32
(
)
*
ScaleFactor
:
:
new
(
1
.
0
)
initial_viewport
:
opts
:
:
get
(
)
.
initial_window_size
.
as_f32
(
)
*
ScaleFactor
:
:
new
(
1
.
0
)
device_pixel_ratio
:
ScaleFactor
:
:
new
(
1
.
0
)
}
phantom
:
PhantomData
clipboard_ctx
:
if
supports_clipboard
{
ClipboardContext
:
:
new
(
)
.
ok
(
)
}
else
{
None
}
webdriver
:
WebDriverData
:
:
new
(
)
}
;
constellation
.
run
(
)
;
}
)
;
constellation_chan
}
fn
run
(
&
mut
self
)
{
loop
{
let
request
=
self
.
request_port
.
recv
(
)
.
unwrap
(
)
;
if
!
self
.
handle_request
(
request
)
{
break
;
}
}
}
fn
new_pipeline
(
&
mut
self
parent_info
:
Option
<
(
PipelineId
SubpageId
)
>
initial_window_rect
:
Option
<
TypedRect
<
PagePx
f32
>
>
script_channel
:
Option
<
ScriptControlChan
>
load_data
:
LoadData
)
-
>
PipelineId
{
let
pipeline_id
=
self
.
next_pipeline_id
;
let
PipelineId
(
ref
mut
i
)
=
self
.
next_pipeline_id
;
*
i
+
=
1
;
let
pipeline
=
Pipeline
:
:
create
:
:
<
LTF
STF
>
(
pipeline_id
parent_info
self
.
chan
.
clone
(
)
self
.
compositor_proxy
.
clone_compositor_proxy
(
)
self
.
devtools_chan
.
clone
(
)
self
.
image_cache_task
.
clone
(
)
self
.
font_cache_task
.
clone
(
)
self
.
resource_task
.
clone
(
)
self
.
storage_task
.
clone
(
)
self
.
time_profiler_chan
.
clone
(
)
self
.
mem_profiler_chan
.
clone
(
)
initial_window_rect
script_channel
load_data
self
.
window_size
.
device_pixel_ratio
)
;
assert
!
(
!
self
.
pipelines
.
contains_key
(
&
pipeline_id
)
)
;
self
.
pipelines
.
insert
(
pipeline_id
pipeline
)
;
pipeline_id
}
fn
push_pending_frame
(
&
mut
self
new_pipeline_id
:
PipelineId
old_pipeline_id
:
Option
<
PipelineId
>
)
{
self
.
pending_frames
.
push
(
FrameChange
{
old_pipeline_id
:
old_pipeline_id
new_pipeline_id
:
new_pipeline_id
painter_ready
:
false
}
)
;
}
fn
current_frame_tree_iter
(
&
self
frame_id_root
:
Option
<
FrameId
>
)
-
>
FrameTreeIterator
{
let
mut
stack
=
vec
!
(
)
;
if
let
Some
(
frame_id_root
)
=
frame_id_root
{
stack
.
push
(
frame_id_root
)
;
}
FrameTreeIterator
{
stack
:
stack
pipelines
:
&
self
.
pipelines
frames
:
&
self
.
frames
}
}
fn
new_frame
(
&
mut
self
pipeline_id
:
PipelineId
)
-
>
FrameId
{
let
id
=
self
.
next_frame_id
;
let
FrameId
(
ref
mut
i
)
=
self
.
next_frame_id
;
*
i
+
=
1
;
let
frame
=
Frame
:
:
new
(
pipeline_id
)
;
assert
!
(
!
self
.
pipeline_to_frame_map
.
contains_key
(
&
pipeline_id
)
)
;
assert
!
(
!
self
.
frames
.
contains_key
(
&
id
)
)
;
self
.
pipeline_to_frame_map
.
insert
(
pipeline_id
id
)
;
self
.
frames
.
insert
(
id
frame
)
;
id
}
fn
handle_request
(
&
mut
self
request
:
ConstellationMsg
)
-
>
bool
{
match
request
{
ConstellationMsg
:
:
Exit
=
>
{
debug
!
(
"
constellation
exiting
"
)
;
self
.
handle_exit
(
)
;
return
false
;
}
ConstellationMsg
:
:
Failure
(
Failure
{
pipeline_id
parent_info
}
)
=
>
{
self
.
handle_failure_msg
(
pipeline_id
parent_info
)
;
}
ConstellationMsg
:
:
InitLoadUrl
(
url
)
=
>
{
debug
!
(
"
constellation
got
init
load
URL
message
"
)
;
self
.
handle_init_load
(
url
)
;
}
ConstellationMsg
:
:
FrameRect
(
pipeline_id
subpage_id
rect
)
=
>
{
debug
!
(
"
constellation
got
frame
rect
message
"
)
;
self
.
handle_frame_rect_msg
(
pipeline_id
subpage_id
Rect
:
:
from_untyped
(
&
rect
)
)
;
}
ConstellationMsg
:
:
ScriptLoadedURLInIFrame
(
url
source_pipeline_id
new_subpage_id
old_subpage_id
sandbox
)
=
>
{
debug
!
(
"
constellation
got
iframe
URL
load
message
{
:
?
}
{
:
?
}
{
:
?
}
"
source_pipeline_id
old_subpage_id
new_subpage_id
)
;
self
.
handle_script_loaded_url_in_iframe_msg
(
url
source_pipeline_id
new_subpage_id
old_subpage_id
sandbox
)
;
}
ConstellationMsg
:
:
SetCursor
(
cursor
)
=
>
self
.
handle_set_cursor_msg
(
cursor
)
ConstellationMsg
:
:
ChangeRunningAnimationsState
(
pipeline_id
animation_state
)
=
>
{
self
.
handle_change_running_animations_state
(
pipeline_id
animation_state
)
}
ConstellationMsg
:
:
TickAnimation
(
pipeline_id
)
=
>
{
self
.
handle_tick_animation
(
pipeline_id
)
}
ConstellationMsg
:
:
LoadUrl
(
source_id
load_data
)
=
>
{
debug
!
(
"
constellation
got
URL
load
message
"
)
;
self
.
handle_load_url_msg
(
source_id
load_data
)
;
}
ConstellationMsg
:
:
LoadComplete
(
pipeline_id
)
=
>
{
debug
!
(
"
constellation
got
load
complete
message
"
)
;
self
.
handle_load_complete_msg
(
&
pipeline_id
)
}
ConstellationMsg
:
:
Navigate
(
pipeline_info
direction
)
=
>
{
debug
!
(
"
constellation
got
navigation
message
"
)
;
self
.
handle_navigate_msg
(
pipeline_info
direction
)
;
}
ConstellationMsg
:
:
PainterReady
(
pipeline_id
)
=
>
{
debug
!
(
"
constellation
got
painter
ready
message
"
)
;
self
.
handle_painter_ready_msg
(
pipeline_id
)
;
}
ConstellationMsg
:
:
ResizedWindow
(
new_size
)
=
>
{
debug
!
(
"
constellation
got
window
resize
message
"
)
;
self
.
handle_resized_window_msg
(
new_size
)
;
}
ConstellationMsg
:
:
KeyEvent
(
key
state
modifiers
)
=
>
{
debug
!
(
"
constellation
got
key
event
message
"
)
;
self
.
handle_key_msg
(
key
state
modifiers
)
;
}
ConstellationMsg
:
:
GetPipelineTitle
(
pipeline_id
)
=
>
{
debug
!
(
"
constellation
got
get
-
pipeline
-
title
message
"
)
;
self
.
handle_get_pipeline_title_msg
(
pipeline_id
)
;
}
ConstellationMsg
:
:
MozBrowserEvent
(
pipeline_id
subpage_id
event
)
=
>
{
debug
!
(
"
constellation
got
mozbrowser
event
message
"
)
;
self
.
handle_mozbrowser_event_msg
(
pipeline_id
subpage_id
event
)
;
}
ConstellationMsg
:
:
GetPipeline
(
frame_id
resp_chan
)
=
>
{
debug
!
(
"
constellation
got
get
root
pipeline
message
"
)
;
self
.
handle_get_pipeline
(
frame_id
resp_chan
)
;
}
ConstellationMsg
:
:
GetFrame
(
parent_pipeline_id
subpage_id
resp_chan
)
=
>
{
debug
!
(
"
constellation
got
get
root
pipeline
message
"
)
;
self
.
handle_get_frame
(
parent_pipeline_id
subpage_id
resp_chan
)
;
}
ConstellationMsg
:
:
Focus
(
pipeline_id
)
=
>
{
debug
!
(
"
constellation
got
focus
message
"
)
;
self
.
handle_focus_msg
(
pipeline_id
)
;
}
ConstellationMsg
:
:
GetClipboardContents
(
sender
)
=
>
{
let
result
=
self
.
clipboard_ctx
.
as_ref
(
)
.
map_or
(
"
"
.
to_string
(
)
|
ctx
|
ctx
.
get_contents
(
)
.
unwrap_or_else
(
|
e
|
{
debug
!
(
"
Error
getting
clipboard
contents
(
{
}
)
defaulting
to
empty
string
"
e
)
;
"
"
.
to_string
(
)
}
)
)
;
sender
.
send
(
result
)
.
unwrap
(
)
;
}
ConstellationMsg
:
:
WebDriverCommand
(
command
)
=
>
{
debug
!
(
"
constellation
got
webdriver
command
message
"
)
;
self
.
handle_webdriver_msg
(
command
)
;
}
ConstellationMsg
:
:
ViewportConstrained
(
pipeline_id
constraints
)
=
>
{
debug
!
(
"
constellation
got
viewport
-
constrained
event
message
"
)
;
self
.
handle_viewport_constrained_msg
(
pipeline_id
constraints
)
;
}
ConstellationMsg
:
:
IsReadyToSaveImage
(
pipeline_states
)
=
>
{
let
is_ready
=
self
.
handle_is_ready_to_save_image
(
pipeline_states
)
;
self
.
compositor_proxy
.
send
(
CompositorMsg
:
:
IsReadyToSaveImageReply
(
is_ready
)
)
;
}
ConstellationMsg
:
:
RemoveIFrame
(
containing_pipeline_id
subpage_id
)
=
>
{
debug
!
(
"
constellation
got
remove
iframe
message
"
)
;
self
.
handle_remove_iframe_msg
(
containing_pipeline_id
subpage_id
)
;
}
ConstellationMsg
:
:
NewFavicon
(
url
)
=
>
{
debug
!
(
"
constellation
got
new
favicon
message
"
)
;
self
.
compositor_proxy
.
send
(
CompositorMsg
:
:
NewFavicon
(
url
)
)
;
}
ConstellationMsg
:
:
HeadParsed
=
>
{
debug
!
(
"
constellation
got
head
parsed
message
"
)
;
self
.
compositor_proxy
.
send
(
CompositorMsg
:
:
HeadParsed
)
;
}
}
true
}
fn
handle_exit
(
&
mut
self
)
{
for
(
_id
ref
pipeline
)
in
&
self
.
pipelines
{
pipeline
.
exit
(
PipelineExitType
:
:
Complete
)
;
}
self
.
image_cache_task
.
exit
(
)
;
self
.
resource_task
.
send
(
net_traits
:
:
ControlMsg
:
:
Exit
)
.
unwrap
(
)
;
self
.
devtools_chan
.
as_ref
(
)
.
map
(
|
chan
|
{
chan
.
send
(
DevtoolsControlMsg
:
:
ServerExitMsg
)
.
unwrap
(
)
;
}
)
;
self
.
storage_task
.
send
(
StorageTaskMsg
:
:
Exit
)
.
unwrap
(
)
;
self
.
font_cache_task
.
exit
(
)
;
self
.
compositor_proxy
.
send
(
CompositorMsg
:
:
ShutdownComplete
)
;
}
fn
handle_failure_msg
(
&
mut
self
pipeline_id
:
PipelineId
parent_info
:
Option
<
(
PipelineId
SubpageId
)
>
)
{
debug
!
(
"
handling
failure
message
from
pipeline
{
:
?
}
{
:
?
}
"
pipeline_id
parent_info
)
;
if
opts
:
:
get
(
)
.
hard_fail
{
let
mut
stderr
=
io
:
:
stderr
(
)
;
stderr
.
write_all
(
"
Pipeline
failed
in
hard
-
fail
mode
.
Crashing
!
\
n
"
.
as_bytes
(
)
)
.
unwrap
(
)
;
unsafe
{
libc
:
:
exit
(
1
)
;
}
}
self
.
close_pipeline
(
pipeline_id
ExitPipelineMode
:
:
Force
)
;
loop
{
let
pending_pipeline_id
=
self
.
pending_frames
.
iter
(
)
.
find
(
|
pending
|
{
pending
.
old_pipeline_id
=
=
Some
(
pipeline_id
)
}
)
.
map
(
|
frame
|
frame
.
new_pipeline_id
)
;
match
pending_pipeline_id
{
Some
(
pending_pipeline_id
)
=
>
{
debug
!
(
"
removing
pending
frame
change
for
failed
pipeline
"
)
;
self
.
close_pipeline
(
pending_pipeline_id
ExitPipelineMode
:
:
Force
)
;
}
None
=
>
break
}
}
debug
!
(
"
creating
replacement
pipeline
for
about
:
failure
"
)
;
let
window_rect
=
self
.
pipeline
(
pipeline_id
)
.
rect
;
let
new_pipeline_id
=
self
.
new_pipeline
(
parent_info
window_rect
None
LoadData
:
:
new
(
Url
:
:
parse
(
"
about
:
failure
"
)
.
unwrap
(
)
)
)
;
self
.
push_pending_frame
(
new_pipeline_id
Some
(
pipeline_id
)
)
;
}
fn
handle_init_load
(
&
mut
self
url
:
Url
)
{
let
window_rect
=
Rect
:
:
new
(
Point2D
:
:
zero
(
)
self
.
window_size
.
visible_viewport
)
;
let
root_pipeline_id
=
self
.
new_pipeline
(
None
Some
(
window_rect
)
None
LoadData
:
:
new
(
url
.
clone
(
)
)
)
;
self
.
handle_load_start_msg
(
&
root_pipeline_id
)
;
self
.
push_pending_frame
(
root_pipeline_id
None
)
;
self
.
compositor_proxy
.
send
(
CompositorMsg
:
:
ChangePageUrl
(
root_pipeline_id
url
)
)
;
}
fn
handle_frame_rect_msg
(
&
mut
self
containing_pipeline_id
:
PipelineId
subpage_id
:
SubpageId
rect
:
TypedRect
<
PagePx
f32
>
)
{
let
(
pipeline_id
script_chan
)
=
{
let
pipeline_id
=
self
.
subpage_map
.
get
(
&
(
containing_pipeline_id
subpage_id
)
)
.
map
(
|
id
|
*
id
)
;
let
pipeline
=
match
pipeline_id
{
Some
(
pipeline_id
)
=
>
self
.
mut_pipeline
(
pipeline_id
)
None
=
>
return
}
;
pipeline
.
rect
=
Some
(
rect
)
;
(
pipeline
.
id
pipeline
.
script_chan
.
clone
(
)
)
}
;
let
ScriptControlChan
(
ref
script_chan
)
=
script_chan
;
script_chan
.
send
(
ConstellationControlMsg
:
:
Resize
(
pipeline_id
WindowSizeData
{
visible_viewport
:
rect
.
size
initial_viewport
:
rect
.
size
*
ScaleFactor
:
:
new
(
1
.
0
)
device_pixel_ratio
:
self
.
window_size
.
device_pixel_ratio
}
)
)
.
unwrap
(
)
;
if
self
.
pipeline_is_in_current_frame
(
pipeline_id
)
{
self
.
compositor_proxy
.
send
(
CompositorMsg
:
:
SetLayerRect
(
pipeline_id
LayerId
:
:
null
(
)
rect
.
to_untyped
(
)
)
)
;
}
}
fn
handle_script_loaded_url_in_iframe_msg
(
&
mut
self
url
:
Url
containing_pipeline_id
:
PipelineId
new_subpage_id
:
SubpageId
old_subpage_id
:
Option
<
SubpageId
>
sandbox
:
IFrameSandboxState
)
{
let
script_chan
=
{
let
source_pipeline
=
self
.
pipeline
(
containing_pipeline_id
)
;
let
source_url
=
source_pipeline
.
url
.
clone
(
)
;
let
same_script
=
(
source_url
.
host
(
)
=
=
url
.
host
(
)
&
&
source_url
.
port
(
)
=
=
url
.
port
(
)
)
&
&
sandbox
=
=
IFrameSandboxState
:
:
IFrameUnsandboxed
;
if
same_script
{
debug
!
(
"
Constellation
:
loading
same
-
origin
iframe
at
{
:
?
}
"
url
)
;
Some
(
source_pipeline
.
script_chan
.
clone
(
)
)
}
else
{
debug
!
(
"
Constellation
:
loading
cross
-
origin
iframe
at
{
:
?
}
"
url
)
;
None
}
}
;
let
old_pipeline_id
=
old_subpage_id
.
map
(
|
old_subpage_id
|
{
self
.
find_subpage
(
containing_pipeline_id
old_subpage_id
)
.
id
}
)
;
let
window_rect
=
old_pipeline_id
.
and_then
(
|
old_pipeline_id
|
{
self
.
pipeline
(
old_pipeline_id
)
.
rect
}
)
;
let
new_pipeline_id
=
self
.
new_pipeline
(
Some
(
(
containing_pipeline_id
new_subpage_id
)
)
window_rect
script_chan
LoadData
:
:
new
(
url
)
)
;
self
.
subpage_map
.
insert
(
(
containing_pipeline_id
new_subpage_id
)
new_pipeline_id
)
;
self
.
push_pending_frame
(
new_pipeline_id
old_pipeline_id
)
;
}
fn
handle_set_cursor_msg
(
&
mut
self
cursor
:
Cursor
)
{
self
.
compositor_proxy
.
send
(
CompositorMsg
:
:
SetCursor
(
cursor
)
)
}
fn
handle_change_running_animations_state
(
&
mut
self
pipeline_id
:
PipelineId
animation_state
:
AnimationState
)
{
self
.
compositor_proxy
.
send
(
CompositorMsg
:
:
ChangeRunningAnimationsState
(
pipeline_id
animation_state
)
)
}
fn
handle_tick_animation
(
&
mut
self
pipeline_id
:
PipelineId
)
{
self
.
pipeline
(
pipeline_id
)
.
layout_chan
.
0
.
send
(
LayoutControlMsg
:
:
TickAnimations
)
.
unwrap
(
)
;
}
fn
handle_load_url_msg
(
&
mut
self
source_id
:
PipelineId
load_data
:
LoadData
)
{
self
.
load_url
(
source_id
load_data
)
;
}
fn
load_url
(
&
mut
self
source_id
:
PipelineId
load_data
:
LoadData
)
-
>
Option
<
PipelineId
>
{
match
self
.
pipeline
(
source_id
)
.
parent_info
{
Some
(
(
parent_pipeline_id
subpage_id
)
)
=
>
{
self
.
handle_load_start_msg
(
&
source_id
)
;
let
parent_pipeline
=
self
.
pipeline
(
parent_pipeline_id
)
;
let
ScriptControlChan
(
ref
script_channel
)
=
parent_pipeline
.
script_chan
;
script_channel
.
send
(
ConstellationControlMsg
:
:
Navigate
(
parent_pipeline_id
subpage_id
load_data
)
)
.
unwrap
(
)
;
Some
(
source_id
)
}
None
=
>
{
for
frame_change
in
&
self
.
pending_frames
{
if
frame_change
.
old_pipeline_id
=
=
Some
(
source_id
)
{
return
None
;
}
}
self
.
handle_load_start_msg
(
&
source_id
)
;
let
window_rect
=
self
.
pipeline
(
source_id
)
.
rect
;
let
new_pipeline_id
=
self
.
new_pipeline
(
None
window_rect
None
load_data
)
;
self
.
push_pending_frame
(
new_pipeline_id
Some
(
source_id
)
)
;
let
old_pipeline
=
self
.
pipelines
.
get
(
&
source_id
)
.
unwrap
(
)
;
old_pipeline
.
freeze
(
)
;
Some
(
new_pipeline_id
)
}
}
}
fn
handle_load_start_msg
(
&
mut
self
pipeline_id
:
&
PipelineId
)
{
if
let
Some
(
id
)
=
self
.
pipeline_to_frame_map
.
get
(
pipeline_id
)
{
let
forward
=
!
self
.
frame
(
*
id
)
.
next
.
is_empty
(
)
;
let
back
=
!
self
.
frame
(
*
id
)
.
prev
.
is_empty
(
)
;
self
.
compositor_proxy
.
send
(
CompositorMsg
:
:
LoadStart
(
back
forward
)
)
;
}
}
fn
handle_load_complete_msg
(
&
mut
self
pipeline_id
:
&
PipelineId
)
{
let
frame_id
=
match
self
.
pipeline_to_frame_map
.
get
(
pipeline_id
)
{
Some
(
frame
)
=
>
*
frame
None
=
>
return
}
;
let
forward
=
!
self
.
frame
(
frame_id
)
.
next
.
is_empty
(
)
;
let
back
=
!
self
.
frame
(
frame_id
)
.
prev
.
is_empty
(
)
;
self
.
compositor_proxy
.
send
(
CompositorMsg
:
:
LoadComplete
(
back
forward
)
)
;
let
mut
webdriver_reset
=
false
;
if
let
Some
(
(
ref
expected_pipeline_id
ref
reply_chan
)
)
=
self
.
webdriver
.
load_channel
{
if
expected_pipeline_id
=
=
pipeline_id
{
reply_chan
.
send
(
webdriver_msg
:
:
LoadComplete
)
.
unwrap
(
)
;
webdriver_reset
=
true
;
}
}
if
webdriver_reset
{
self
.
webdriver
.
load_channel
=
None
;
}
}
fn
handle_navigate_msg
(
&
mut
self
pipeline_info
:
Option
<
(
PipelineId
SubpageId
)
>
direction
:
constellation_msg
:
:
NavigationDirection
)
{
debug
!
(
"
received
message
to
navigate
{
:
?
}
"
direction
)
;
let
frame_id
=
pipeline_info
.
map_or
(
self
.
root_frame_id
|
(
containing_pipeline_id
subpage_id
)
|
{
let
pipeline_id
=
self
.
find_subpage
(
containing_pipeline_id
subpage_id
)
.
id
;
self
.
pipeline_to_frame_map
.
get
(
&
pipeline_id
)
.
map
(
|
id
|
*
id
)
}
)
.
unwrap
(
)
;
let
update_focus_pipeline
=
self
.
focused_pipeline_in_tree
(
frame_id
)
;
let
(
prev_pipeline_id
next_pipeline_id
)
=
{
let
frame
=
self
.
mut_frame
(
frame_id
)
;
let
next
=
match
direction
{
NavigationDirection
:
:
Forward
=
>
{
if
frame
.
next
.
is_empty
(
)
{
debug
!
(
"
no
next
page
to
navigate
to
"
)
;
return
;
}
frame
.
prev
.
push
(
frame
.
current
)
;
frame
.
next
.
pop
(
)
.
unwrap
(
)
}
NavigationDirection
:
:
Back
=
>
{
if
frame
.
prev
.
is_empty
(
)
{
debug
!
(
"
no
previous
page
to
navigate
to
"
)
;
return
;
}
frame
.
next
.
push
(
frame
.
current
)
;
frame
.
prev
.
pop
(
)
.
unwrap
(
)
}
}
;
let
prev
=
frame
.
current
;
frame
.
current
=
next
;
(
prev
next
)
}
;
if
update_focus_pipeline
{
self
.
focus_pipeline_id
=
Some
(
next_pipeline_id
)
;
}
self
.
pipeline
(
prev_pipeline_id
)
.
freeze
(
)
;
self
.
pipeline
(
next_pipeline_id
)
.
thaw
(
)
;
self
.
revoke_paint_permission
(
prev_pipeline_id
)
;
self
.
send_frame_tree_and_grant_paint_permission
(
)
;
if
let
Some
(
(
parent_pipeline_id
subpage_id
)
)
=
pipeline_info
{
let
ScriptControlChan
(
ref
script_chan
)
=
self
.
pipeline
(
parent_pipeline_id
)
.
script_chan
;
let
(
_
new_subpage_id
)
=
self
.
pipeline
(
next_pipeline_id
)
.
parent_info
.
unwrap
(
)
;
script_chan
.
send
(
ConstellationControlMsg
:
:
UpdateSubpageId
(
parent_pipeline_id
subpage_id
new_subpage_id
)
)
.
unwrap
(
)
;
self
.
trigger_mozbrowserlocationchange
(
next_pipeline_id
)
;
}
}
fn
handle_key_msg
(
&
self
key
:
Key
state
:
KeyState
mods
:
KeyModifiers
)
{
let
target_pipeline_id
=
self
.
focus_pipeline_id
.
or
(
self
.
root_frame_id
.
map
(
|
frame_id
|
{
self
.
frame
(
frame_id
)
.
current
}
)
)
;
match
target_pipeline_id
{
Some
(
target_pipeline_id
)
=
>
{
let
pipeline
=
self
.
pipeline
(
target_pipeline_id
)
;
let
ScriptControlChan
(
ref
chan
)
=
pipeline
.
script_chan
;
let
event
=
CompositorEvent
:
:
KeyEvent
(
key
state
mods
)
;
chan
.
send
(
ConstellationControlMsg
:
:
SendEvent
(
pipeline
.
id
event
)
)
.
unwrap
(
)
;
}
None
=
>
{
let
event
=
CompositorMsg
:
:
KeyEvent
(
key
state
mods
)
;
self
.
compositor_proxy
.
clone_compositor_proxy
(
)
.
send
(
event
)
;
}
}
}
fn
handle_get_pipeline_title_msg
(
&
mut
self
pipeline_id
:
PipelineId
)
{
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
None
=
>
self
.
compositor_proxy
.
send
(
CompositorMsg
:
:
ChangePageTitle
(
pipeline_id
None
)
)
Some
(
pipeline
)
=
>
{
let
ScriptControlChan
(
ref
script_channel
)
=
pipeline
.
script_chan
;
script_channel
.
send
(
ConstellationControlMsg
:
:
GetTitle
(
pipeline_id
)
)
.
unwrap
(
)
;
}
}
}
fn
handle_mozbrowser_event_msg
(
&
mut
self
containing_pipeline_id
:
PipelineId
subpage_id
:
SubpageId
event
:
MozBrowserEvent
)
{
assert
!
(
opts
:
:
experimental_enabled
(
)
)
;
let
pipeline
=
self
.
pipeline
(
containing_pipeline_id
)
;
pipeline
.
trigger_mozbrowser_event
(
subpage_id
event
)
;
}
fn
handle_get_pipeline
(
&
mut
self
frame_id
:
Option
<
FrameId
>
resp_chan
:
Sender
<
Option
<
PipelineId
>
>
)
{
let
current_pipeline_id
=
frame_id
.
or
(
self
.
root_frame_id
)
.
map
(
|
frame_id
|
{
let
frame
=
self
.
frames
.
get
(
&
frame_id
)
.
unwrap
(
)
;
frame
.
current
}
)
;
let
pipeline_id
=
self
.
pending_frames
.
iter
(
)
.
rev
(
)
.
find
(
|
x
|
x
.
old_pipeline_id
=
=
current_pipeline_id
)
.
map
(
|
x
|
x
.
new_pipeline_id
)
.
or
(
current_pipeline_id
)
;
resp_chan
.
send
(
pipeline_id
)
.
unwrap
(
)
;
}
fn
handle_get_frame
(
&
mut
self
containing_pipeline_id
:
PipelineId
subpage_id
:
SubpageId
resp_chan
:
Sender
<
Option
<
FrameId
>
>
)
{
let
frame_id
=
self
.
subpage_map
.
get
(
&
(
containing_pipeline_id
subpage_id
)
)
.
and_then
(
|
x
|
self
.
pipeline_to_frame_map
.
get
(
&
x
)
)
.
map
(
|
x
|
*
x
)
;
resp_chan
.
send
(
frame_id
)
.
unwrap
(
)
;
}
fn
focus_parent_pipeline
(
&
self
pipeline_id
:
PipelineId
)
{
if
let
Some
(
(
containing_pipeline_id
subpage_id
)
)
=
self
.
pipeline
(
pipeline_id
)
.
parent_info
{
let
pipeline
=
self
.
pipeline
(
containing_pipeline_id
)
;
let
ScriptControlChan
(
ref
script_channel
)
=
pipeline
.
script_chan
;
let
event
=
ConstellationControlMsg
:
:
FocusIFrame
(
containing_pipeline_id
subpage_id
)
;
script_channel
.
send
(
event
)
.
unwrap
(
)
;
self
.
focus_parent_pipeline
(
containing_pipeline_id
)
;
}
}
fn
handle_focus_msg
(
&
mut
self
pipeline_id
:
PipelineId
)
{
self
.
focus_pipeline_id
=
Some
(
pipeline_id
)
;
self
.
focus_parent_pipeline
(
pipeline_id
)
;
}
fn
handle_remove_iframe_msg
(
&
mut
self
containing_pipeline_id
:
PipelineId
subpage_id
:
SubpageId
)
{
let
pipeline_id
=
self
.
find_subpage
(
containing_pipeline_id
subpage_id
)
.
id
;
let
frame_id
=
self
.
pipeline_to_frame_map
.
get
(
&
pipeline_id
)
.
map
(
|
id
|
*
id
)
;
match
frame_id
{
Some
(
frame_id
)
=
>
{
self
.
close_frame
(
frame_id
ExitPipelineMode
:
:
Normal
)
;
}
None
=
>
{
self
.
close_pipeline
(
pipeline_id
ExitPipelineMode
:
:
Normal
)
;
}
}
}
fn
handle_webdriver_msg
(
&
mut
self
msg
:
WebDriverCommandMsg
)
{
match
msg
{
WebDriverCommandMsg
:
:
LoadUrl
(
pipeline_id
load_data
reply
)
=
>
{
let
new_pipeline_id
=
self
.
load_url
(
pipeline_id
load_data
)
;
if
let
Some
(
id
)
=
new_pipeline_id
{
self
.
webdriver
.
load_channel
=
Some
(
(
id
reply
)
)
;
}
}
WebDriverCommandMsg
:
:
ScriptCommand
(
pipeline_id
cmd
)
=
>
{
let
pipeline
=
self
.
pipeline
(
pipeline_id
)
;
let
control_msg
=
ConstellationControlMsg
:
:
WebDriverScriptCommand
(
pipeline_id
cmd
)
;
let
ScriptControlChan
(
ref
script_channel
)
=
pipeline
.
script_chan
;
script_channel
.
send
(
control_msg
)
.
unwrap
(
)
;
}
WebDriverCommandMsg
:
:
TakeScreenshot
(
pipeline_id
reply
)
=
>
{
let
current_pipeline_id
=
self
.
root_frame_id
.
map
(
|
frame_id
|
{
let
frame
=
self
.
frames
.
get
(
&
frame_id
)
.
unwrap
(
)
;
frame
.
current
}
)
;
if
Some
(
pipeline_id
)
=
=
current_pipeline_id
{
self
.
compositor_proxy
.
send
(
CompositorMsg
:
:
CreatePng
(
reply
)
)
;
}
else
{
reply
.
send
(
None
)
.
unwrap
(
)
;
}
}
}
}
fn
add_or_replace_pipeline_in_frame_tree
(
&
mut
self
frame_change
:
FrameChange
)
{
if
let
Some
(
old_pipeline_id
)
=
frame_change
.
old_pipeline_id
{
let
old_frame_id
=
*
self
.
pipeline_to_frame_map
.
get
(
&
old_pipeline_id
)
.
unwrap
(
)
;
if
self
.
focused_pipeline_in_tree
(
old_frame_id
)
{
self
.
focus_pipeline_id
=
Some
(
frame_change
.
new_pipeline_id
)
;
}
}
let
evicted_frames
=
match
frame_change
.
old_pipeline_id
{
Some
(
old_pipeline_id
)
=
>
{
self
.
revoke_paint_permission
(
old_pipeline_id
)
;
let
frame_id
=
*
self
.
pipeline_to_frame_map
.
get
(
&
old_pipeline_id
)
.
unwrap
(
)
;
let
evicted_frames
=
self
.
mut_frame
(
frame_id
)
.
load
(
frame_change
.
new_pipeline_id
)
;
self
.
pipeline_to_frame_map
.
insert
(
frame_change
.
new_pipeline_id
frame_id
)
;
Some
(
evicted_frames
)
}
None
=
>
{
let
frame_id
=
self
.
new_frame
(
frame_change
.
new_pipeline_id
)
;
match
self
.
pipeline
(
frame_change
.
new_pipeline_id
)
.
parent_info
{
Some
(
(
parent_id
_
)
)
=
>
{
self
.
mut_pipeline
(
parent_id
)
.
add_child
(
frame_id
)
;
}
None
=
>
{
assert
!
(
self
.
root_frame_id
.
is_none
(
)
)
;
self
.
root_frame_id
=
Some
(
frame_id
)
;
}
}
None
}
}
;
self
.
send_frame_tree_and_grant_paint_permission
(
)
;
self
.
trigger_mozbrowserlocationchange
(
frame_change
.
new_pipeline_id
)
;
if
let
Some
(
evicted_frames
)
=
evicted_frames
{
for
pipeline_id
in
&
evicted_frames
{
self
.
close_pipeline
(
*
pipeline_id
ExitPipelineMode
:
:
Normal
)
;
}
}
}
fn
handle_painter_ready_msg
(
&
mut
self
pipeline_id
:
PipelineId
)
{
debug
!
(
"
Painter
{
:
?
}
ready
to
send
paint
msg
"
pipeline_id
)
;
if
self
.
pipeline_is_in_current_frame
(
pipeline_id
)
{
return
;
}
let
pending_index
=
self
.
pending_frames
.
iter
(
)
.
rposition
(
|
frame_change
|
{
frame_change
.
new_pipeline_id
=
=
pipeline_id
}
)
;
if
let
Some
(
pending_index
)
=
pending_index
{
self
.
pending_frames
[
pending_index
]
.
painter_ready
=
true
;
}
loop
{
let
valid_frame_change
=
self
.
pending_frames
.
iter
(
)
.
rposition
(
|
frame_change
|
{
let
waiting_on_dependency
=
frame_change
.
old_pipeline_id
.
map_or
(
false
|
old_pipeline_id
|
{
self
.
pipeline_to_frame_map
.
get
(
&
old_pipeline_id
)
.
is_none
(
)
}
)
;
frame_change
.
painter_ready
&
&
!
waiting_on_dependency
}
)
;
if
let
Some
(
valid_frame_change
)
=
valid_frame_change
{
let
frame_change
=
self
.
pending_frames
.
swap_remove
(
valid_frame_change
)
;
self
.
add_or_replace_pipeline_in_frame_tree
(
frame_change
)
;
}
else
{
break
;
}
}
}
fn
handle_resized_window_msg
(
&
mut
self
new_size
:
WindowSizeData
)
{
debug
!
(
"
handle_resized_window_msg
:
{
:
?
}
{
:
?
}
"
new_size
.
initial_viewport
.
to_untyped
(
)
new_size
.
visible_viewport
.
to_untyped
(
)
)
;
if
let
Some
(
root_frame_id
)
=
self
.
root_frame_id
{
let
frame
=
self
.
frames
.
get
(
&
root_frame_id
)
.
unwrap
(
)
;
let
pipeline
=
self
.
pipelines
.
get
(
&
frame
.
current
)
.
unwrap
(
)
;
let
ScriptControlChan
(
ref
chan
)
=
pipeline
.
script_chan
;
let
_
=
chan
.
send
(
ConstellationControlMsg
:
:
Resize
(
pipeline
.
id
new_size
)
)
;
for
pipeline_id
in
frame
.
prev
.
iter
(
)
.
chain
(
frame
.
next
.
iter
(
)
)
{
let
pipeline
=
self
.
pipelines
.
get
(
pipeline_id
)
.
unwrap
(
)
;
let
ScriptControlChan
(
ref
chan
)
=
pipeline
.
script_chan
;
let
_
=
chan
.
send
(
ConstellationControlMsg
:
:
ResizeInactive
(
pipeline
.
id
new_size
)
)
;
}
}
for
pending_frame
in
&
self
.
pending_frames
{
let
pipeline
=
self
.
pipelines
.
get
(
&
pending_frame
.
new_pipeline_id
)
.
unwrap
(
)
;
if
pipeline
.
parent_info
.
is_none
(
)
{
let
ScriptControlChan
(
ref
chan
)
=
pipeline
.
script_chan
;
let
_
=
chan
.
send
(
ConstellationControlMsg
:
:
Resize
(
pipeline
.
id
new_size
)
)
;
}
}
self
.
window_size
=
new_size
;
}
fn
handle_viewport_constrained_msg
(
&
mut
self
pipeline_id
:
PipelineId
constraints
:
ViewportConstraints
)
{
self
.
compositor_proxy
.
send
(
CompositorMsg
:
:
ViewportConstrained
(
pipeline_id
constraints
)
)
;
}
fn
handle_is_ready_to_save_image
(
&
mut
self
pipeline_states
:
HashMap
<
PipelineId
Epoch
>
)
-
>
bool
{
if
self
.
root_frame_id
.
is_none
(
)
{
return
false
;
}
if
self
.
pending_frames
.
len
(
)
>
0
{
return
false
;
}
for
frame
in
self
.
current_frame_tree_iter
(
self
.
root_frame_id
)
{
let
pipeline
=
self
.
pipeline
(
frame
.
current
)
;
let
ScriptControlChan
(
ref
script_chan
)
=
pipeline
.
script_chan
;
let
(
sender
receiver
)
=
channel
(
)
;
let
msg
=
ConstellationControlMsg
:
:
GetCurrentState
(
sender
frame
.
current
)
;
script_chan
.
send
(
msg
)
.
unwrap
(
)
;
if
receiver
.
recv
(
)
.
unwrap
(
)
=
=
ScriptState
:
:
DocumentLoading
{
return
false
;
}
match
pipeline
.
rect
{
Some
(
rect
)
=
>
{
if
rect
.
size
=
=
Size2D
:
:
zero
(
)
{
continue
;
}
let
compositor_epoch
=
pipeline_states
.
get
(
&
frame
.
current
)
;
match
compositor_epoch
{
Some
(
compositor_epoch
)
=
>
{
let
(
sender
receiver
)
=
channel
(
)
;
let
LayoutControlChan
(
ref
layout_chan
)
=
pipeline
.
layout_chan
;
layout_chan
.
send
(
LayoutControlMsg
:
:
GetCurrentEpoch
(
sender
)
)
.
unwrap
(
)
;
let
layout_task_epoch
=
receiver
.
recv
(
)
.
unwrap
(
)
;
if
layout_task_epoch
!
=
*
compositor_epoch
{
return
false
;
}
}
None
=
>
{
return
false
;
}
}
}
None
=
>
{
return
false
;
}
}
}
true
}
fn
close_frame
(
&
mut
self
frame_id
:
FrameId
exit_mode
:
ExitPipelineMode
)
{
let
parent_info
=
self
.
pipeline
(
self
.
frame
(
frame_id
)
.
current
)
.
parent_info
;
let
pipelines_to_close
=
{
let
mut
pipelines_to_close
=
vec
!
(
)
;
let
frame
=
self
.
frame
(
frame_id
)
;
pipelines_to_close
.
push_all
(
&
frame
.
next
)
;
pipelines_to_close
.
push
(
frame
.
current
)
;
pipelines_to_close
.
push_all
(
&
frame
.
prev
)
;
pipelines_to_close
}
;
for
pipeline_id
in
&
pipelines_to_close
{
self
.
close_pipeline
(
*
pipeline_id
exit_mode
)
;
}
self
.
frames
.
remove
(
&
frame_id
)
.
unwrap
(
)
;
if
let
Some
(
(
parent_pipeline_id
_
)
)
=
parent_info
{
let
parent_pipeline
=
self
.
mut_pipeline
(
parent_pipeline_id
)
;
parent_pipeline
.
remove_child
(
frame_id
)
;
}
}
fn
close_pipeline
(
&
mut
self
pipeline_id
:
PipelineId
exit_mode
:
ExitPipelineMode
)
{
let
frames_to_close
=
{
let
mut
frames_to_close
=
vec
!
(
)
;
let
pipeline
=
self
.
pipeline
(
pipeline_id
)
;
frames_to_close
.
push_all
(
&
pipeline
.
children
)
;
frames_to_close
}
;
for
child_frame
in
&
frames_to_close
{
self
.
close_frame
(
*
child_frame
exit_mode
)
;
}
let
pipeline
=
self
.
pipelines
.
remove
(
&
pipeline_id
)
.
unwrap
(
)
;
if
let
Some
(
info
)
=
pipeline
.
parent_info
{
self
.
subpage_map
.
remove
(
&
info
)
;
}
self
.
pipeline_to_frame_map
.
remove
(
&
pipeline_id
)
;
let
pending_index
=
self
.
pending_frames
.
iter
(
)
.
position
(
|
frame_change
|
{
frame_change
.
new_pipeline_id
=
=
pipeline_id
}
)
;
if
let
Some
(
pending_index
)
=
pending_index
{
self
.
pending_frames
.
remove
(
pending_index
)
;
}
match
exit_mode
{
ExitPipelineMode
:
:
Normal
=
>
pipeline
.
exit
(
PipelineExitType
:
:
PipelineOnly
)
ExitPipelineMode
:
:
Force
=
>
pipeline
.
force_exit
(
)
}
}
fn
frame_to_sendable
(
&
self
frame_id
:
FrameId
)
-
>
SendableFrameTree
{
let
pipeline
=
self
.
pipeline
(
self
.
frame
(
frame_id
)
.
current
)
;
let
mut
frame_tree
=
SendableFrameTree
{
pipeline
:
pipeline
.
to_sendable
(
)
rect
:
pipeline
.
rect
children
:
vec
!
(
)
}
;
for
child_frame_id
in
&
pipeline
.
children
{
frame_tree
.
children
.
push
(
self
.
frame_to_sendable
(
*
child_frame_id
)
)
;
}
frame_tree
}
fn
revoke_paint_permission
(
&
self
pipeline_id
:
PipelineId
)
{
let
frame_id
=
self
.
pipeline_to_frame_map
.
get
(
&
pipeline_id
)
.
map
(
|
frame_id
|
*
frame_id
)
;
for
frame
in
self
.
current_frame_tree_iter
(
frame_id
)
{
self
.
pipeline
(
frame
.
current
)
.
revoke_paint_permission
(
)
;
}
}
fn
send_frame_tree_and_grant_paint_permission
(
&
mut
self
)
{
if
let
Some
(
root_frame_id
)
=
self
.
root_frame_id
{
let
frame_tree
=
self
.
frame_to_sendable
(
root_frame_id
)
;
let
(
chan
port
)
=
channel
(
)
;
self
.
compositor_proxy
.
send
(
CompositorMsg
:
:
SetFrameTree
(
frame_tree
chan
self
.
chan
.
clone
(
)
)
)
;
if
port
.
recv
(
)
.
is_err
(
)
{
debug
!
(
"
Compositor
has
discarded
SetFrameTree
"
)
;
return
;
}
}
for
frame
in
self
.
current_frame_tree_iter
(
self
.
root_frame_id
)
{
self
.
pipeline
(
frame
.
current
)
.
grant_paint_permission
(
)
;
}
}
fn
trigger_mozbrowserlocationchange
(
&
self
pipeline_id
:
PipelineId
)
{
if
opts
:
:
experimental_enabled
(
)
{
let
event_info
=
{
let
pipeline
=
self
.
pipeline
(
pipeline_id
)
;
pipeline
.
parent_info
.
map
(
|
(
containing_pipeline_id
subpage_id
)
|
{
(
containing_pipeline_id
subpage_id
pipeline
.
url
.
serialize
(
)
)
}
)
}
;
if
let
Some
(
(
containing_pipeline_id
subpage_id
url
)
)
=
event_info
{
let
parent_pipeline
=
self
.
pipeline
(
containing_pipeline_id
)
;
parent_pipeline
.
trigger_mozbrowser_event
(
subpage_id
MozBrowserEvent
:
:
LocationChange
(
url
)
)
;
}
}
}
fn
focused_pipeline_in_tree
(
&
self
frame_id
:
FrameId
)
-
>
bool
{
self
.
focus_pipeline_id
.
map_or
(
false
|
pipeline_id
|
{
self
.
pipeline_exists_in_tree
(
pipeline_id
Some
(
frame_id
)
)
}
)
}
fn
pipeline_is_in_current_frame
(
&
self
pipeline_id
:
PipelineId
)
-
>
bool
{
self
.
pipeline_exists_in_tree
(
pipeline_id
self
.
root_frame_id
)
}
fn
pipeline_exists_in_tree
(
&
self
pipeline_id
:
PipelineId
root_frame_id
:
Option
<
FrameId
>
)
-
>
bool
{
self
.
current_frame_tree_iter
(
root_frame_id
)
.
any
(
|
current_frame
|
current_frame
.
current
=
=
pipeline_id
)
}
#
[
inline
(
always
)
]
fn
frame
(
&
self
frame_id
:
FrameId
)
-
>
&
Frame
{
self
.
frames
.
get
(
&
frame_id
)
.
expect
(
"
unable
to
find
frame
-
this
is
a
bug
"
)
}
#
[
inline
(
always
)
]
fn
mut_frame
(
&
mut
self
frame_id
:
FrameId
)
-
>
&
mut
Frame
{
self
.
frames
.
get_mut
(
&
frame_id
)
.
expect
(
"
unable
to
find
frame
-
this
is
a
bug
"
)
}
#
[
inline
(
always
)
]
fn
pipeline
(
&
self
pipeline_id
:
PipelineId
)
-
>
&
Pipeline
{
self
.
pipelines
.
get
(
&
pipeline_id
)
.
expect
(
"
unable
to
find
pipeline
-
this
is
a
bug
"
)
}
#
[
inline
(
always
)
]
fn
mut_pipeline
(
&
mut
self
pipeline_id
:
PipelineId
)
-
>
&
mut
Pipeline
{
self
.
pipelines
.
get_mut
(
&
pipeline_id
)
.
expect
(
"
unable
to
find
pipeline
-
this
is
a
bug
"
)
}
fn
find_subpage
(
&
mut
self
containing_pipeline_id
:
PipelineId
subpage_id
:
SubpageId
)
-
>
&
mut
Pipeline
{
let
pipeline_id
=
*
self
.
subpage_map
.
get
(
&
(
containing_pipeline_id
subpage_id
)
)
.
expect
(
"
no
subpage
pipeline_id
"
)
;
self
.
mut_pipeline
(
pipeline_id
)
}
}
