use
CompositorMsg
as
FromCompositorMsg
;
use
canvas
:
:
canvas_paint_task
:
:
CanvasPaintTask
;
use
canvas
:
:
webgl_paint_task
:
:
WebGLPaintTask
;
use
canvas_traits
:
:
CanvasMsg
;
use
clipboard
:
:
ClipboardContext
;
use
compositor_task
:
:
CompositorProxy
;
use
compositor_task
:
:
Msg
as
ToCompositorMsg
;
use
devtools_traits
:
:
{
ChromeToDevtoolsControlMsg
DevtoolsControlMsg
}
;
use
euclid
:
:
scale_factor
:
:
ScaleFactor
;
use
euclid
:
:
size
:
:
{
Size2D
TypedSize2D
}
;
use
gaol
;
use
gaol
:
:
sandbox
:
:
{
self
Sandbox
SandboxMethods
}
;
use
gfx
:
:
font_cache_task
:
:
FontCacheTask
;
use
ipc_channel
:
:
ipc
:
:
{
self
IpcOneShotServer
IpcSender
}
;
use
ipc_channel
:
:
router
:
:
ROUTER
;
use
layout_traits
:
:
{
LayoutControlChan
LayoutTaskFactory
}
;
use
msg
:
:
compositor_msg
:
:
Epoch
;
use
msg
:
:
constellation_msg
:
:
AnimationState
;
use
msg
:
:
constellation_msg
:
:
PaintMsg
as
FromPaintMsg
;
use
msg
:
:
constellation_msg
:
:
WebDriverCommandMsg
;
use
msg
:
:
constellation_msg
:
:
{
DocumentState
FrameId
PipelineId
}
;
use
msg
:
:
constellation_msg
:
:
{
IframeLoadInfo
IFrameSandboxState
MozBrowserEvent
NavigationDirection
}
;
use
msg
:
:
constellation_msg
:
:
{
Key
KeyModifiers
KeyState
LoadData
}
;
use
msg
:
:
constellation_msg
:
:
{
PipelineNamespace
PipelineNamespaceId
}
;
use
msg
:
:
constellation_msg
:
:
{
SubpageId
WindowSizeData
}
;
use
msg
:
:
constellation_msg
:
:
{
self
ConstellationChan
Failure
}
;
use
msg
:
:
webdriver_msg
;
use
net_traits
:
:
image_cache_task
:
:
ImageCacheTask
;
use
net_traits
:
:
storage_task
:
:
{
StorageTask
StorageTaskMsg
}
;
use
net_traits
:
:
{
self
ResourceTask
}
;
use
offscreen_gl_context
:
:
GLContextAttributes
;
use
pipeline
:
:
{
CompositionPipeline
InitialPipelineState
Pipeline
UnprivilegedPipelineContent
}
;
use
profile_traits
:
:
mem
;
use
profile_traits
:
:
time
;
use
sandboxing
;
use
script_traits
:
:
{
CompositorEvent
ConstellationControlMsg
LayoutControlMsg
}
;
use
script_traits
:
:
{
ScriptMsg
as
FromScriptMsg
ScriptTaskFactory
}
;
use
script_traits
:
:
{
TimerEventRequest
}
;
use
std
:
:
borrow
:
:
ToOwned
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
env
;
use
std
:
:
io
:
:
{
self
Write
}
;
use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
:
:
replace
;
use
std
:
:
process
;
use
std
:
:
sync
:
:
mpsc
:
:
{
Sender
channel
Receiver
}
;
use
style_traits
:
:
viewport
:
:
ViewportConstraints
;
use
timer_scheduler
:
:
TimerScheduler
;
use
url
:
:
Url
;
use
util
:
:
cursor
:
:
Cursor
;
use
util
:
:
geometry
:
:
PagePx
;
use
util
:
:
task
:
:
spawn_named
;
use
util
:
:
{
opts
prefs
}
;
#
[
derive
(
Debug
PartialEq
)
]
enum
ReadyToSave
{
NoRootFrame
PendingFrames
WebFontNotLoaded
DocumentLoading
EpochMismatch
PipelineUnknown
Ready
}
pub
struct
Constellation
<
LTF
STF
>
{
pub
script_sender
:
ConstellationChan
<
FromScriptMsg
>
pub
compositor_sender
:
Sender
<
FromCompositorMsg
>
pub
painter_sender
:
ConstellationChan
<
FromPaintMsg
>
pub
script_receiver
:
Receiver
<
FromScriptMsg
>
pub
compositor_receiver
:
Receiver
<
FromCompositorMsg
>
pub
painter_receiver
:
Receiver
<
FromPaintMsg
>
pub
compositor_proxy
:
Box
<
CompositorProxy
>
pub
resource_task
:
ResourceTask
pub
image_cache_task
:
ImageCacheTask
devtools_chan
:
Option
<
Sender
<
DevtoolsControlMsg
>
>
storage_task
:
StorageTask
pipelines
:
HashMap
<
PipelineId
Pipeline
>
frames
:
HashMap
<
FrameId
Frame
>
pipeline_to_frame_map
:
HashMap
<
PipelineId
FrameId
>
subpage_map
:
HashMap
<
(
PipelineId
SubpageId
)
PipelineId
>
font_cache_task
:
FontCacheTask
root_frame_id
:
Option
<
FrameId
>
next_pipeline_namespace_id
:
PipelineNamespaceId
next_frame_id
:
FrameId
focus_pipeline_id
:
Option
<
PipelineId
>
pending_frames
:
Vec
<
FrameChange
>
pub
time_profiler_chan
:
time
:
:
ProfilerChan
pub
mem_profiler_chan
:
mem
:
:
ProfilerChan
phantom
:
PhantomData
<
(
LTF
STF
)
>
pub
window_size
:
WindowSizeData
clipboard_ctx
:
Option
<
ClipboardContext
>
webdriver
:
WebDriverData
canvas_paint_tasks
:
Vec
<
Sender
<
CanvasMsg
>
>
webgl_paint_tasks
:
Vec
<
Sender
<
CanvasMsg
>
>
scheduler_chan
:
IpcSender
<
TimerEventRequest
>
child_processes
:
Vec
<
ChildProcess
>
document_states
:
HashMap
<
PipelineId
DocumentState
>
}
pub
struct
InitialConstellationState
{
pub
compositor_proxy
:
Box
<
CompositorProxy
+
Send
>
pub
devtools_chan
:
Option
<
Sender
<
DevtoolsControlMsg
>
>
pub
image_cache_task
:
ImageCacheTask
pub
font_cache_task
:
FontCacheTask
pub
resource_task
:
ResourceTask
pub
storage_task
:
StorageTask
pub
time_profiler_chan
:
time
:
:
ProfilerChan
pub
mem_profiler_chan
:
mem
:
:
ProfilerChan
pub
supports_clipboard
:
bool
}
pub
struct
Frame
{
prev
:
Vec
<
PipelineId
>
current
:
PipelineId
next
:
Vec
<
PipelineId
>
}
impl
Frame
{
fn
new
(
pipeline_id
:
PipelineId
)
-
>
Frame
{
Frame
{
prev
:
vec
!
(
)
current
:
pipeline_id
next
:
vec
!
(
)
}
}
fn
load
(
&
mut
self
pipeline_id
:
PipelineId
)
-
>
Vec
<
PipelineId
>
{
self
.
prev
.
push
(
self
.
current
)
;
self
.
current
=
pipeline_id
;
replace
(
&
mut
self
.
next
vec
!
(
)
)
}
}
struct
FrameChange
{
old_pipeline_id
:
Option
<
PipelineId
>
new_pipeline_id
:
PipelineId
document_ready
:
bool
}
struct
FrameTreeIterator
<
'
a
>
{
stack
:
Vec
<
FrameId
>
frames
:
&
'
a
HashMap
<
FrameId
Frame
>
pipelines
:
&
'
a
HashMap
<
PipelineId
Pipeline
>
}
impl
<
'
a
>
Iterator
for
FrameTreeIterator
<
'
a
>
{
type
Item
=
&
'
a
Frame
;
fn
next
(
&
mut
self
)
-
>
Option
<
&
'
a
Frame
>
{
self
.
stack
.
pop
(
)
.
map
(
|
next
|
{
let
frame
=
self
.
frames
.
get
(
&
next
)
.
unwrap
(
)
;
let
pipeline
=
self
.
pipelines
.
get
(
&
frame
.
current
)
.
unwrap
(
)
;
self
.
stack
.
extend
(
pipeline
.
children
.
iter
(
)
.
map
(
|
&
c
|
c
)
)
;
frame
}
)
}
}
pub
struct
SendableFrameTree
{
pub
pipeline
:
CompositionPipeline
pub
size
:
Option
<
TypedSize2D
<
PagePx
f32
>
>
pub
children
:
Vec
<
SendableFrameTree
>
}
struct
WebDriverData
{
load_channel
:
Option
<
(
PipelineId
IpcSender
<
webdriver_msg
:
:
LoadStatus
>
)
>
}
impl
WebDriverData
{
pub
fn
new
(
)
-
>
WebDriverData
{
WebDriverData
{
load_channel
:
None
}
}
}
#
[
derive
(
Clone
Copy
)
]
enum
ExitPipelineMode
{
Normal
Force
}
enum
ChildProcess
{
Sandboxed
(
gaol
:
:
platform
:
:
process
:
:
Process
)
Unsandboxed
(
process
:
:
Child
)
}
impl
<
LTF
:
LayoutTaskFactory
STF
:
ScriptTaskFactory
>
Constellation
<
LTF
STF
>
{
pub
fn
start
(
state
:
InitialConstellationState
)
-
>
Sender
<
FromCompositorMsg
>
{
let
(
ipc_script_receiver
ipc_script_sender
)
=
ConstellationChan
:
:
<
FromScriptMsg
>
:
:
new
(
)
;
let
script_receiver
=
ROUTER
.
route_ipc_receiver_to_new_mpsc_receiver
(
ipc_script_receiver
)
;
let
(
compositor_sender
compositor_receiver
)
=
channel
(
)
;
let
(
ipc_painter_receiver
ipc_painter_sender
)
=
ConstellationChan
:
:
<
FromPaintMsg
>
:
:
new
(
)
;
let
painter_receiver
=
ROUTER
.
route_ipc_receiver_to_new_mpsc_receiver
(
ipc_painter_receiver
)
;
let
compositor_sender_clone
=
compositor_sender
.
clone
(
)
;
spawn_named
(
"
Constellation
"
.
to_owned
(
)
move
|
|
{
let
mut
constellation
:
Constellation
<
LTF
STF
>
=
Constellation
{
script_sender
:
ipc_script_sender
compositor_sender
:
compositor_sender_clone
painter_sender
:
ipc_painter_sender
script_receiver
:
script_receiver
compositor_receiver
:
compositor_receiver
painter_receiver
:
painter_receiver
compositor_proxy
:
state
.
compositor_proxy
devtools_chan
:
state
.
devtools_chan
resource_task
:
state
.
resource_task
image_cache_task
:
state
.
image_cache_task
font_cache_task
:
state
.
font_cache_task
storage_task
:
state
.
storage_task
pipelines
:
HashMap
:
:
new
(
)
frames
:
HashMap
:
:
new
(
)
pipeline_to_frame_map
:
HashMap
:
:
new
(
)
subpage_map
:
HashMap
:
:
new
(
)
pending_frames
:
vec
!
(
)
next_pipeline_namespace_id
:
PipelineNamespaceId
(
0
)
root_frame_id
:
None
next_frame_id
:
FrameId
(
0
)
focus_pipeline_id
:
None
time_profiler_chan
:
state
.
time_profiler_chan
mem_profiler_chan
:
state
.
mem_profiler_chan
window_size
:
WindowSizeData
{
visible_viewport
:
opts
:
:
get
(
)
.
initial_window_size
.
as_f32
(
)
*
ScaleFactor
:
:
new
(
1
.
0
)
initial_viewport
:
opts
:
:
get
(
)
.
initial_window_size
.
as_f32
(
)
*
ScaleFactor
:
:
new
(
1
.
0
)
device_pixel_ratio
:
ScaleFactor
:
:
new
(
opts
:
:
get
(
)
.
device_pixels_per_px
.
unwrap_or
(
1
.
0
)
)
}
phantom
:
PhantomData
clipboard_ctx
:
if
state
.
supports_clipboard
{
ClipboardContext
:
:
new
(
)
.
ok
(
)
}
else
{
None
}
webdriver
:
WebDriverData
:
:
new
(
)
canvas_paint_tasks
:
Vec
:
:
new
(
)
webgl_paint_tasks
:
Vec
:
:
new
(
)
scheduler_chan
:
TimerScheduler
:
:
start
(
)
child_processes
:
Vec
:
:
new
(
)
document_states
:
HashMap
:
:
new
(
)
}
;
let
namespace_id
=
constellation
.
next_pipeline_namespace_id
(
)
;
PipelineNamespace
:
:
install
(
namespace_id
)
;
constellation
.
run
(
)
;
}
)
;
compositor_sender
}
fn
run
(
&
mut
self
)
{
loop
{
if
!
self
.
handle_request
(
)
{
break
;
}
}
}
fn
next_pipeline_namespace_id
(
&
mut
self
)
-
>
PipelineNamespaceId
{
let
namespace_id
=
self
.
next_pipeline_namespace_id
;
let
PipelineNamespaceId
(
ref
mut
i
)
=
self
.
next_pipeline_namespace_id
;
*
i
+
=
1
;
namespace_id
}
fn
new_pipeline
(
&
mut
self
pipeline_id
:
PipelineId
parent_info
:
Option
<
(
PipelineId
SubpageId
)
>
initial_window_size
:
Option
<
TypedSize2D
<
PagePx
f32
>
>
script_channel
:
Option
<
IpcSender
<
ConstellationControlMsg
>
>
load_data
:
LoadData
)
{
let
spawning_paint_only
=
script_channel
.
is_some
(
)
;
let
(
pipeline
unprivileged_pipeline_content
privileged_pipeline_content
)
=
Pipeline
:
:
create
:
:
<
LTF
STF
>
(
InitialPipelineState
{
id
:
pipeline_id
parent_info
:
parent_info
constellation_chan
:
self
.
script_sender
.
clone
(
)
painter_chan
:
self
.
painter_sender
.
clone
(
)
scheduler_chan
:
self
.
scheduler_chan
.
clone
(
)
compositor_proxy
:
self
.
compositor_proxy
.
clone_compositor_proxy
(
)
devtools_chan
:
self
.
devtools_chan
.
clone
(
)
image_cache_task
:
self
.
image_cache_task
.
clone
(
)
font_cache_task
:
self
.
font_cache_task
.
clone
(
)
resource_task
:
self
.
resource_task
.
clone
(
)
storage_task
:
self
.
storage_task
.
clone
(
)
time_profiler_chan
:
self
.
time_profiler_chan
.
clone
(
)
mem_profiler_chan
:
self
.
mem_profiler_chan
.
clone
(
)
window_size
:
initial_window_size
script_chan
:
script_channel
load_data
:
load_data
device_pixel_ratio
:
self
.
window_size
.
device_pixel_ratio
pipeline_namespace_id
:
self
.
next_pipeline_namespace_id
(
)
}
)
;
if
spawning_paint_only
{
privileged_pipeline_content
.
start_paint_task
(
)
;
}
else
{
privileged_pipeline_content
.
start_all
(
)
;
if
opts
:
:
multiprocess
(
)
{
let
(
server
token
)
=
IpcOneShotServer
:
:
<
IpcSender
<
UnprivilegedPipelineContent
>
>
:
:
new
(
)
.
unwrap
(
)
;
let
child_process
=
if
opts
:
:
get
(
)
.
sandbox
{
let
mut
command
=
sandbox
:
:
Command
:
:
me
(
)
.
unwrap
(
)
;
command
.
arg
(
"
-
-
content
-
process
"
)
.
arg
(
token
)
;
let
profile
=
sandboxing
:
:
content_process_sandbox_profile
(
)
;
ChildProcess
:
:
Sandboxed
(
Sandbox
:
:
new
(
profile
)
.
start
(
&
mut
command
)
.
expect
(
"
Failed
to
start
sandboxed
child
process
!
"
)
)
}
else
{
let
path_to_self
=
env
:
:
current_exe
(
)
.
unwrap
(
)
;
let
mut
child_process
=
process
:
:
Command
:
:
new
(
path_to_self
)
;
child_process
.
arg
(
"
-
-
content
-
process
"
)
;
child_process
.
arg
(
token
)
;
ChildProcess
:
:
Unsandboxed
(
child_process
.
spawn
(
)
.
unwrap
(
)
)
}
;
self
.
child_processes
.
push
(
child_process
)
;
let
(
_receiver
sender
)
=
server
.
accept
(
)
.
unwrap
(
)
;
sender
.
send
(
unprivileged_pipeline_content
)
.
unwrap
(
)
;
}
else
{
unprivileged_pipeline_content
.
start_all
:
:
<
LTF
STF
>
(
false
)
;
}
}
assert
!
(
!
self
.
pipelines
.
contains_key
(
&
pipeline_id
)
)
;
self
.
pipelines
.
insert
(
pipeline_id
pipeline
)
;
}
fn
push_pending_frame
(
&
mut
self
new_pipeline_id
:
PipelineId
old_pipeline_id
:
Option
<
PipelineId
>
)
{
self
.
pending_frames
.
push
(
FrameChange
{
old_pipeline_id
:
old_pipeline_id
new_pipeline_id
:
new_pipeline_id
document_ready
:
false
}
)
;
}
fn
current_frame_tree_iter
(
&
self
frame_id_root
:
Option
<
FrameId
>
)
-
>
FrameTreeIterator
{
let
mut
stack
=
vec
!
(
)
;
if
let
Some
(
frame_id_root
)
=
frame_id_root
{
stack
.
push
(
frame_id_root
)
;
}
FrameTreeIterator
{
stack
:
stack
pipelines
:
&
self
.
pipelines
frames
:
&
self
.
frames
}
}
fn
new_frame
(
&
mut
self
pipeline_id
:
PipelineId
)
-
>
FrameId
{
let
id
=
self
.
next_frame_id
;
let
FrameId
(
ref
mut
i
)
=
self
.
next_frame_id
;
*
i
+
=
1
;
let
frame
=
Frame
:
:
new
(
pipeline_id
)
;
assert
!
(
!
self
.
pipeline_to_frame_map
.
contains_key
(
&
pipeline_id
)
)
;
assert
!
(
!
self
.
frames
.
contains_key
(
&
id
)
)
;
self
.
pipeline_to_frame_map
.
insert
(
pipeline_id
id
)
;
self
.
frames
.
insert
(
id
frame
)
;
id
}
#
[
allow
(
unsafe_code
)
]
fn
handle_request
(
&
mut
self
)
-
>
bool
{
enum
Request
{
Script
(
FromScriptMsg
)
Compositor
(
FromCompositorMsg
)
Paint
(
FromPaintMsg
)
}
let
request
=
{
let
receiver_from_script
=
&
self
.
script_receiver
;
let
receiver_from_compositor
=
&
self
.
compositor_receiver
;
let
receiver_from_paint
=
&
self
.
painter_receiver
;
select
!
{
msg
=
receiver_from_script
.
recv
(
)
=
>
Request
:
:
Script
(
msg
.
unwrap
(
)
)
msg
=
receiver_from_compositor
.
recv
(
)
=
>
Request
:
:
Compositor
(
msg
.
unwrap
(
)
)
msg
=
receiver_from_paint
.
recv
(
)
=
>
Request
:
:
Paint
(
msg
.
unwrap
(
)
)
}
}
;
match
request
{
Request
:
:
Compositor
(
FromCompositorMsg
:
:
Exit
)
=
>
{
debug
!
(
"
constellation
exiting
"
)
;
self
.
handle_exit
(
)
;
return
false
;
}
Request
:
:
Compositor
(
FromCompositorMsg
:
:
FrameSize
(
pipeline_id
size
)
)
=
>
{
debug
!
(
"
constellation
got
frame
size
message
"
)
;
self
.
handle_frame_size_msg
(
pipeline_id
&
Size2D
:
:
from_untyped
(
&
size
)
)
;
}
Request
:
:
Compositor
(
FromCompositorMsg
:
:
GetFrame
(
pipeline_id
resp_chan
)
)
=
>
{
debug
!
(
"
constellation
got
get
root
pipeline
message
"
)
;
self
.
handle_get_frame
(
pipeline_id
resp_chan
)
;
}
Request
:
:
Compositor
(
FromCompositorMsg
:
:
GetPipeline
(
frame_id
resp_chan
)
)
=
>
{
debug
!
(
"
constellation
got
get
root
pipeline
message
"
)
;
self
.
handle_get_pipeline
(
frame_id
resp_chan
)
;
}
Request
:
:
Compositor
(
FromCompositorMsg
:
:
GetPipelineTitle
(
pipeline_id
)
)
=
>
{
debug
!
(
"
constellation
got
get
-
pipeline
-
title
message
"
)
;
self
.
handle_get_pipeline_title_msg
(
pipeline_id
)
;
}
Request
:
:
Compositor
(
FromCompositorMsg
:
:
KeyEvent
(
key
state
modifiers
)
)
=
>
{
debug
!
(
"
constellation
got
key
event
message
"
)
;
self
.
handle_key_msg
(
key
state
modifiers
)
;
}
Request
:
:
Compositor
(
FromCompositorMsg
:
:
LoadUrl
(
source_id
load_data
)
)
=
>
{
debug
!
(
"
constellation
got
URL
load
message
from
compositor
"
)
;
self
.
handle_load_url_msg
(
source_id
load_data
)
;
}
Request
:
:
Compositor
(
FromCompositorMsg
:
:
IsReadyToSaveImage
(
pipeline_states
)
)
=
>
{
let
is_ready
=
self
.
handle_is_ready_to_save_image
(
pipeline_states
)
;
if
opts
:
:
get
(
)
.
is_running_problem_test
{
println
!
(
"
got
ready
to
save
image
query
result
is
{
:
?
}
"
is_ready
)
;
}
let
is_ready
=
is_ready
=
=
ReadyToSave
:
:
Ready
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
IsReadyToSaveImageReply
(
is_ready
)
)
;
if
opts
:
:
get
(
)
.
is_running_problem_test
{
println
!
(
"
sent
response
"
)
;
}
}
Request
:
:
Compositor
(
FromCompositorMsg
:
:
InitLoadUrl
(
url
)
)
=
>
{
debug
!
(
"
constellation
got
init
load
URL
message
"
)
;
self
.
handle_init_load
(
url
)
;
}
Request
:
:
Compositor
(
FromCompositorMsg
:
:
Navigate
(
pipeline_info
direction
)
)
=
>
{
debug
!
(
"
constellation
got
navigation
message
from
compositor
"
)
;
self
.
handle_navigate_msg
(
pipeline_info
direction
)
;
}
Request
:
:
Compositor
(
FromCompositorMsg
:
:
ResizedWindow
(
new_size
)
)
=
>
{
debug
!
(
"
constellation
got
window
resize
message
"
)
;
self
.
handle_resized_window_msg
(
new_size
)
;
}
Request
:
:
Compositor
(
FromCompositorMsg
:
:
TickAnimation
(
pipeline_id
)
)
=
>
{
self
.
handle_tick_animation
(
pipeline_id
)
}
Request
:
:
Compositor
(
FromCompositorMsg
:
:
WebDriverCommand
(
command
)
)
=
>
{
debug
!
(
"
constellation
got
webdriver
command
message
"
)
;
self
.
handle_webdriver_msg
(
command
)
;
}
Request
:
:
Script
(
FromScriptMsg
:
:
Failure
(
Failure
{
pipeline_id
parent_info
}
)
)
=
>
{
debug
!
(
"
handling
script
failure
message
from
pipeline
{
:
?
}
{
:
?
}
"
pipeline_id
parent_info
)
;
self
.
handle_failure_msg
(
pipeline_id
parent_info
)
;
}
Request
:
:
Script
(
FromScriptMsg
:
:
ScriptLoadedURLInIFrame
(
load_info
)
)
=
>
{
debug
!
(
"
constellation
got
iframe
URL
load
message
{
:
?
}
{
:
?
}
{
:
?
}
"
load_info
.
containing_pipeline_id
load_info
.
old_subpage_id
load_info
.
new_subpage_id
)
;
self
.
handle_script_loaded_url_in_iframe_msg
(
load_info
)
;
}
Request
:
:
Script
(
FromScriptMsg
:
:
SetCursor
(
cursor
)
)
=
>
{
self
.
handle_set_cursor_msg
(
cursor
)
}
Request
:
:
Script
(
FromScriptMsg
:
:
ChangeRunningAnimationsState
(
pipeline_id
animation_state
)
)
=
>
{
self
.
handle_change_running_animations_state
(
pipeline_id
animation_state
)
}
Request
:
:
Script
(
FromScriptMsg
:
:
LoadUrl
(
source_id
load_data
)
)
=
>
{
debug
!
(
"
constellation
got
URL
load
message
from
script
"
)
;
self
.
handle_load_url_msg
(
source_id
load_data
)
;
}
Request
:
:
Script
(
FromScriptMsg
:
:
LoadComplete
(
pipeline_id
)
)
=
>
{
debug
!
(
"
constellation
got
load
complete
message
"
)
;
self
.
handle_load_complete_msg
(
&
pipeline_id
)
}
Request
:
:
Script
(
FromScriptMsg
:
:
DOMLoad
(
pipeline_id
)
)
=
>
{
debug
!
(
"
constellation
got
dom
load
message
"
)
;
self
.
handle_dom_load
(
pipeline_id
)
}
Request
:
:
Script
(
FromScriptMsg
:
:
Navigate
(
pipeline_info
direction
)
)
=
>
{
debug
!
(
"
constellation
got
navigation
message
from
script
"
)
;
self
.
handle_navigate_msg
(
pipeline_info
direction
)
;
}
Request
:
:
Script
(
FromScriptMsg
:
:
ActivateDocument
(
pipeline_id
)
)
=
>
{
debug
!
(
"
constellation
got
activate
document
message
"
)
;
self
.
handle_activate_document_msg
(
pipeline_id
)
;
}
Request
:
:
Script
(
FromScriptMsg
:
:
MozBrowserEvent
(
pipeline_id
subpage_id
event
)
)
=
>
{
debug
!
(
"
constellation
got
mozbrowser
event
message
"
)
;
self
.
handle_mozbrowser_event_msg
(
pipeline_id
subpage_id
event
)
;
}
Request
:
:
Script
(
FromScriptMsg
:
:
Focus
(
pipeline_id
)
)
=
>
{
debug
!
(
"
constellation
got
focus
message
"
)
;
self
.
handle_focus_msg
(
pipeline_id
)
;
}
Request
:
:
Script
(
FromScriptMsg
:
:
ForwardMouseButtonEvent
(
pipeline_id
event_type
button
point
)
)
=
>
{
if
let
Some
(
pipeline
)
=
self
.
pipelines
.
get
(
&
pipeline_id
)
{
pipeline
.
script_chan
.
send
(
ConstellationControlMsg
:
:
SendEvent
(
pipeline_id
CompositorEvent
:
:
MouseButtonEvent
(
event_type
button
point
)
)
)
.
unwrap
(
)
;
}
}
Request
:
:
Script
(
FromScriptMsg
:
:
ForwardMouseMoveEvent
(
pipeline_id
point
)
)
=
>
{
if
let
Some
(
pipeline
)
=
self
.
pipelines
.
get
(
&
pipeline_id
)
{
pipeline
.
script_chan
.
send
(
ConstellationControlMsg
:
:
SendEvent
(
pipeline_id
CompositorEvent
:
:
MouseMoveEvent
(
Some
(
point
)
)
)
)
.
unwrap
(
)
;
}
}
Request
:
:
Script
(
FromScriptMsg
:
:
GetClipboardContents
(
sender
)
)
=
>
{
let
result
=
self
.
clipboard_ctx
.
as_ref
(
)
.
map_or
(
"
"
.
to_owned
(
)
|
ctx
|
ctx
.
get_contents
(
)
.
unwrap_or_else
(
|
e
|
{
debug
!
(
"
Error
getting
clipboard
contents
(
{
}
)
defaulting
to
empty
string
"
e
)
;
"
"
.
to_owned
(
)
}
)
)
;
sender
.
send
(
result
)
.
unwrap
(
)
;
}
Request
:
:
Script
(
FromScriptMsg
:
:
SetClipboardContents
(
s
)
)
=
>
{
if
let
Some
(
ref
mut
ctx
)
=
self
.
clipboard_ctx
{
if
let
Err
(
e
)
=
ctx
.
set_contents
(
s
)
{
debug
!
(
"
Error
setting
clipboard
contents
(
{
}
)
"
e
)
;
}
}
}
Request
:
:
Script
(
FromScriptMsg
:
:
ViewportConstrained
(
pipeline_id
constraints
)
)
=
>
{
debug
!
(
"
constellation
got
viewport
-
constrained
event
message
"
)
;
self
.
handle_viewport_constrained_msg
(
pipeline_id
constraints
)
;
}
Request
:
:
Script
(
FromScriptMsg
:
:
RemoveIFrame
(
pipeline_id
)
)
=
>
{
debug
!
(
"
constellation
got
remove
iframe
message
"
)
;
self
.
handle_remove_iframe_msg
(
pipeline_id
)
;
}
Request
:
:
Script
(
FromScriptMsg
:
:
NewFavicon
(
url
)
)
=
>
{
debug
!
(
"
constellation
got
new
favicon
message
"
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
NewFavicon
(
url
)
)
;
}
Request
:
:
Script
(
FromScriptMsg
:
:
HeadParsed
)
=
>
{
debug
!
(
"
constellation
got
head
parsed
message
"
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
HeadParsed
)
;
}
Request
:
:
Script
(
FromScriptMsg
:
:
CreateCanvasPaintTask
(
size
sender
)
)
=
>
{
debug
!
(
"
constellation
got
create
-
canvas
-
paint
-
task
message
"
)
;
self
.
handle_create_canvas_paint_task_msg
(
&
size
sender
)
}
Request
:
:
Script
(
FromScriptMsg
:
:
CreateWebGLPaintTask
(
size
attributes
sender
)
)
=
>
{
debug
!
(
"
constellation
got
create
-
WebGL
-
paint
-
task
message
"
)
;
self
.
handle_create_webgl_paint_task_msg
(
&
size
attributes
sender
)
}
Request
:
:
Script
(
FromScriptMsg
:
:
NodeStatus
(
message
)
)
=
>
{
debug
!
(
"
constellation
got
NodeStatus
message
"
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
Status
(
message
)
)
;
}
Request
:
:
Script
(
FromScriptMsg
:
:
SetDocumentState
(
pipeline_id
state
)
)
=
>
{
debug
!
(
"
constellation
got
SetDocumentState
message
"
)
;
self
.
document_states
.
insert
(
pipeline_id
state
)
;
}
Request
:
:
Paint
(
FromPaintMsg
:
:
Failure
(
Failure
{
pipeline_id
parent_info
}
)
)
=
>
{
debug
!
(
"
handling
paint
failure
message
from
pipeline
{
:
?
}
{
:
?
}
"
pipeline_id
parent_info
)
;
self
.
handle_failure_msg
(
pipeline_id
parent_info
)
;
}
}
true
}
fn
handle_exit
(
&
mut
self
)
{
for
(
_id
ref
pipeline
)
in
&
self
.
pipelines
{
pipeline
.
exit
(
)
;
}
self
.
image_cache_task
.
exit
(
)
;
self
.
resource_task
.
send
(
net_traits
:
:
ControlMsg
:
:
Exit
)
.
unwrap
(
)
;
self
.
devtools_chan
.
as_ref
(
)
.
map
(
|
chan
|
{
chan
.
send
(
DevtoolsControlMsg
:
:
FromChrome
(
ChromeToDevtoolsControlMsg
:
:
ServerExitMsg
)
)
.
unwrap
(
)
;
}
)
;
self
.
storage_task
.
send
(
StorageTaskMsg
:
:
Exit
)
.
unwrap
(
)
;
self
.
font_cache_task
.
exit
(
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
ShutdownComplete
)
;
}
fn
handle_failure_msg
(
&
mut
self
pipeline_id
:
PipelineId
parent_info
:
Option
<
(
PipelineId
SubpageId
)
>
)
{
if
opts
:
:
get
(
)
.
hard_fail
{
let
mut
stderr
=
io
:
:
stderr
(
)
;
stderr
.
write_all
(
"
Pipeline
failed
in
hard
-
fail
mode
.
Crashing
!
\
n
"
.
as_bytes
(
)
)
.
unwrap
(
)
;
process
:
:
exit
(
1
)
;
}
self
.
close_pipeline
(
pipeline_id
ExitPipelineMode
:
:
Force
)
;
while
let
Some
(
pending_pipeline_id
)
=
self
.
pending_frames
.
iter
(
)
.
find
(
|
pending
|
{
pending
.
old_pipeline_id
=
=
Some
(
pipeline_id
)
}
)
.
map
(
|
frame
|
frame
.
new_pipeline_id
)
{
debug
!
(
"
removing
pending
frame
change
for
failed
pipeline
"
)
;
self
.
close_pipeline
(
pending_pipeline_id
ExitPipelineMode
:
:
Force
)
;
}
debug
!
(
"
creating
replacement
pipeline
for
about
:
failure
"
)
;
let
window_size
=
self
.
pipeline
(
pipeline_id
)
.
size
;
let
new_pipeline_id
=
PipelineId
:
:
new
(
)
;
self
.
new_pipeline
(
new_pipeline_id
parent_info
window_size
None
LoadData
:
:
new
(
url
!
(
"
about
:
failure
"
)
)
)
;
self
.
push_pending_frame
(
new_pipeline_id
Some
(
pipeline_id
)
)
;
}
fn
handle_init_load
(
&
mut
self
url
:
Url
)
{
let
window_size
=
self
.
window_size
.
visible_viewport
;
let
root_pipeline_id
=
PipelineId
:
:
new
(
)
;
debug_assert
!
(
PipelineId
:
:
fake_root_pipeline_id
(
)
=
=
root_pipeline_id
)
;
self
.
new_pipeline
(
root_pipeline_id
None
Some
(
window_size
)
None
LoadData
:
:
new
(
url
.
clone
(
)
)
)
;
self
.
handle_load_start_msg
(
&
root_pipeline_id
)
;
self
.
push_pending_frame
(
root_pipeline_id
None
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
ChangePageUrl
(
root_pipeline_id
url
)
)
;
}
fn
handle_frame_size_msg
(
&
mut
self
pipeline_id
:
PipelineId
size
:
&
TypedSize2D
<
PagePx
f32
>
)
{
let
script_chan
=
{
match
self
.
pipelines
.
get_mut
(
&
pipeline_id
)
{
Some
(
pipeline
)
=
>
{
pipeline
.
size
=
Some
(
*
size
)
;
pipeline
.
script_chan
.
clone
(
)
}
None
=
>
return
}
}
;
script_chan
.
send
(
ConstellationControlMsg
:
:
Resize
(
pipeline_id
WindowSizeData
{
visible_viewport
:
*
size
initial_viewport
:
*
size
*
ScaleFactor
:
:
new
(
1
.
0
)
device_pixel_ratio
:
self
.
window_size
.
device_pixel_ratio
}
)
)
.
unwrap
(
)
;
}
fn
handle_subframe_loaded
(
&
mut
self
pipeline_id
:
PipelineId
)
{
let
subframe_pipeline
=
self
.
pipeline
(
pipeline_id
)
;
let
subframe_parent
=
match
subframe_pipeline
.
parent_info
{
Some
(
ref
parent
)
=
>
parent
None
=
>
return
}
;
let
parent_pipeline
=
self
.
pipeline
(
subframe_parent
.
0
)
;
let
msg
=
ConstellationControlMsg
:
:
DispatchFrameLoadEvent
{
target
:
pipeline_id
parent
:
subframe_parent
.
0
}
;
parent_pipeline
.
script_chan
.
send
(
msg
)
.
unwrap
(
)
;
}
fn
handle_script_loaded_url_in_iframe_msg
(
&
mut
self
load_info
:
IframeLoadInfo
)
{
let
old_pipeline_id
=
load_info
.
old_subpage_id
.
map
(
|
old_subpage_id
|
{
self
.
find_subpage
(
load_info
.
containing_pipeline_id
old_subpage_id
)
.
id
}
)
;
let
new_url
=
match
(
old_pipeline_id
load_info
.
url
)
{
(
_
Some
(
ref
url
)
)
=
>
url
.
clone
(
)
(
Some
(
old_pipeline_id
)
None
)
=
>
self
.
pipeline
(
old_pipeline_id
)
.
url
.
clone
(
)
(
None
None
)
=
>
url
!
(
"
about
:
blank
"
)
}
;
let
script_chan
=
{
let
source_pipeline
=
self
.
pipeline
(
load_info
.
containing_pipeline_id
)
;
let
source_url
=
source_pipeline
.
url
.
clone
(
)
;
let
same_script
=
(
source_url
.
host
(
)
=
=
new_url
.
host
(
)
&
&
source_url
.
port
(
)
=
=
new_url
.
port
(
)
)
&
&
load_info
.
sandbox
=
=
IFrameSandboxState
:
:
IFrameUnsandboxed
;
if
same_script
{
debug
!
(
"
Constellation
:
loading
same
-
origin
iframe
\
parent
url
{
:
?
}
iframe
url
{
:
?
}
"
source_url
new_url
)
;
Some
(
source_pipeline
.
script_chan
.
clone
(
)
)
}
else
{
debug
!
(
"
Constellation
:
loading
cross
-
origin
iframe
\
parent
url
{
:
?
}
iframe
url
{
:
?
}
"
source_url
new_url
)
;
None
}
}
;
let
window_size
=
old_pipeline_id
.
and_then
(
|
old_pipeline_id
|
{
self
.
pipeline
(
old_pipeline_id
)
.
size
}
)
;
self
.
new_pipeline
(
load_info
.
new_pipeline_id
Some
(
(
load_info
.
containing_pipeline_id
load_info
.
new_subpage_id
)
)
window_size
script_chan
LoadData
:
:
new
(
new_url
)
)
;
self
.
subpage_map
.
insert
(
(
load_info
.
containing_pipeline_id
load_info
.
new_subpage_id
)
load_info
.
new_pipeline_id
)
;
self
.
push_pending_frame
(
load_info
.
new_pipeline_id
old_pipeline_id
)
;
}
fn
handle_set_cursor_msg
(
&
mut
self
cursor
:
Cursor
)
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
SetCursor
(
cursor
)
)
}
fn
handle_change_running_animations_state
(
&
mut
self
pipeline_id
:
PipelineId
animation_state
:
AnimationState
)
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
ChangeRunningAnimationsState
(
pipeline_id
animation_state
)
)
}
fn
handle_tick_animation
(
&
mut
self
pipeline_id
:
PipelineId
)
{
self
.
pipeline
(
pipeline_id
)
.
layout_chan
.
0
.
send
(
LayoutControlMsg
:
:
TickAnimations
)
.
unwrap
(
)
;
}
fn
handle_load_url_msg
(
&
mut
self
source_id
:
PipelineId
load_data
:
LoadData
)
{
self
.
load_url
(
source_id
load_data
)
;
}
fn
load_url
(
&
mut
self
source_id
:
PipelineId
load_data
:
LoadData
)
-
>
Option
<
PipelineId
>
{
match
self
.
pipeline
(
source_id
)
.
parent_info
{
Some
(
(
parent_pipeline_id
subpage_id
)
)
=
>
{
self
.
handle_load_start_msg
(
&
source_id
)
;
let
parent_pipeline
=
self
.
pipeline
(
parent_pipeline_id
)
;
let
script_channel
=
&
parent_pipeline
.
script_chan
;
script_channel
.
send
(
ConstellationControlMsg
:
:
Navigate
(
parent_pipeline_id
subpage_id
load_data
)
)
.
unwrap
(
)
;
Some
(
source_id
)
}
None
=
>
{
for
frame_change
in
&
self
.
pending_frames
{
if
frame_change
.
old_pipeline_id
=
=
Some
(
source_id
)
{
return
None
;
}
}
self
.
handle_load_start_msg
(
&
source_id
)
;
let
window_size
=
self
.
pipeline
(
source_id
)
.
size
;
let
new_pipeline_id
=
PipelineId
:
:
new
(
)
;
self
.
new_pipeline
(
new_pipeline_id
None
window_size
None
load_data
)
;
self
.
push_pending_frame
(
new_pipeline_id
Some
(
source_id
)
)
;
let
old_pipeline
=
self
.
pipelines
.
get
(
&
source_id
)
.
unwrap
(
)
;
old_pipeline
.
freeze
(
)
;
Some
(
new_pipeline_id
)
}
}
}
fn
handle_load_start_msg
(
&
mut
self
pipeline_id
:
&
PipelineId
)
{
if
let
Some
(
id
)
=
self
.
pipeline_to_frame_map
.
get
(
pipeline_id
)
{
let
forward
=
!
self
.
frame
(
*
id
)
.
next
.
is_empty
(
)
;
let
back
=
!
self
.
frame
(
*
id
)
.
prev
.
is_empty
(
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
LoadStart
(
back
forward
)
)
;
}
}
fn
handle_load_complete_msg
(
&
mut
self
pipeline_id
:
&
PipelineId
)
{
let
frame_id
=
match
self
.
pipeline_to_frame_map
.
get
(
pipeline_id
)
{
Some
(
frame
)
=
>
*
frame
None
=
>
{
debug
!
(
"
frame
not
found
for
pipeline
id
{
:
?
}
"
pipeline_id
)
;
return
}
}
;
let
forward
=
!
self
.
frame
(
frame_id
)
.
next
.
is_empty
(
)
;
let
back
=
!
self
.
frame
(
frame_id
)
.
prev
.
is_empty
(
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
LoadComplete
(
back
forward
)
)
;
}
fn
handle_dom_load
(
&
mut
self
pipeline_id
:
PipelineId
)
{
let
mut
webdriver_reset
=
false
;
if
let
Some
(
(
expected_pipeline_id
ref
reply_chan
)
)
=
self
.
webdriver
.
load_channel
{
debug
!
(
"
Sending
load
to
WebDriver
"
)
;
if
expected_pipeline_id
=
=
pipeline_id
{
let
_
=
reply_chan
.
send
(
webdriver_msg
:
:
LoadStatus
:
:
LoadComplete
)
;
webdriver_reset
=
true
;
}
}
if
webdriver_reset
{
self
.
webdriver
.
load_channel
=
None
;
}
self
.
handle_subframe_loaded
(
pipeline_id
)
;
}
fn
handle_navigate_msg
(
&
mut
self
pipeline_info
:
Option
<
(
PipelineId
SubpageId
)
>
direction
:
constellation_msg
:
:
NavigationDirection
)
{
debug
!
(
"
received
message
to
navigate
{
:
?
}
"
direction
)
;
let
frame_id
=
pipeline_info
.
map_or
(
self
.
root_frame_id
|
(
containing_pipeline_id
subpage_id
)
|
{
let
pipeline_id
=
self
.
find_subpage
(
containing_pipeline_id
subpage_id
)
.
id
;
self
.
pipeline_to_frame_map
.
get
(
&
pipeline_id
)
.
map
(
|
id
|
*
id
)
}
)
.
unwrap
(
)
;
let
update_focus_pipeline
=
self
.
focused_pipeline_in_tree
(
frame_id
)
;
let
(
prev_pipeline_id
next_pipeline_id
)
=
{
let
frame
=
self
.
mut_frame
(
frame_id
)
;
let
next
=
match
direction
{
NavigationDirection
:
:
Forward
=
>
{
match
frame
.
next
.
pop
(
)
{
None
=
>
{
debug
!
(
"
no
next
page
to
navigate
to
"
)
;
return
;
}
Some
(
next
)
=
>
{
frame
.
prev
.
push
(
frame
.
current
)
;
next
}
}
}
NavigationDirection
:
:
Back
=
>
{
match
frame
.
prev
.
pop
(
)
{
None
=
>
{
debug
!
(
"
no
previous
page
to
navigate
to
"
)
;
return
;
}
Some
(
prev
)
=
>
{
frame
.
next
.
push
(
frame
.
current
)
;
prev
}
}
}
}
;
let
prev
=
frame
.
current
;
frame
.
current
=
next
;
(
prev
next
)
}
;
if
update_focus_pipeline
{
self
.
focus_pipeline_id
=
Some
(
next_pipeline_id
)
;
}
self
.
pipeline
(
prev_pipeline_id
)
.
freeze
(
)
;
self
.
pipeline
(
next_pipeline_id
)
.
thaw
(
)
;
self
.
revoke_paint_permission
(
prev_pipeline_id
)
;
self
.
send_frame_tree_and_grant_paint_permission
(
)
;
if
let
Some
(
(
parent_pipeline_id
subpage_id
)
)
=
pipeline_info
{
let
script_chan
=
&
self
.
pipeline
(
parent_pipeline_id
)
.
script_chan
;
let
(
_
new_subpage_id
)
=
self
.
pipeline
(
next_pipeline_id
)
.
parent_info
.
unwrap
(
)
;
script_chan
.
send
(
ConstellationControlMsg
:
:
UpdateSubpageId
(
parent_pipeline_id
subpage_id
new_subpage_id
)
)
.
unwrap
(
)
;
self
.
trigger_mozbrowserlocationchange
(
next_pipeline_id
)
;
}
}
fn
handle_key_msg
(
&
self
key
:
Key
state
:
KeyState
mods
:
KeyModifiers
)
{
let
target_pipeline_id
=
self
.
focus_pipeline_id
.
or
(
self
.
root_frame_id
.
map
(
|
frame_id
|
{
self
.
frame
(
frame_id
)
.
current
}
)
)
;
match
target_pipeline_id
{
Some
(
target_pipeline_id
)
=
>
{
let
pipeline
=
self
.
pipeline
(
target_pipeline_id
)
;
let
event
=
CompositorEvent
:
:
KeyEvent
(
key
state
mods
)
;
pipeline
.
script_chan
.
send
(
ConstellationControlMsg
:
:
SendEvent
(
pipeline
.
id
event
)
)
.
unwrap
(
)
;
}
None
=
>
{
let
event
=
ToCompositorMsg
:
:
KeyEvent
(
key
state
mods
)
;
self
.
compositor_proxy
.
clone_compositor_proxy
(
)
.
send
(
event
)
;
}
}
}
fn
handle_get_pipeline_title_msg
(
&
mut
self
pipeline_id
:
PipelineId
)
{
match
self
.
pipelines
.
get
(
&
pipeline_id
)
{
None
=
>
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
ChangePageTitle
(
pipeline_id
None
)
)
Some
(
pipeline
)
=
>
{
pipeline
.
script_chan
.
send
(
ConstellationControlMsg
:
:
GetTitle
(
pipeline_id
)
)
.
unwrap
(
)
;
}
}
}
fn
handle_mozbrowser_event_msg
(
&
mut
self
containing_pipeline_id
:
PipelineId
subpage_id
:
SubpageId
event
:
MozBrowserEvent
)
{
assert
!
(
prefs
:
:
get_pref
(
"
dom
.
mozbrowser
.
enabled
"
)
.
as_boolean
(
)
.
unwrap_or
(
false
)
)
;
let
pipeline
=
self
.
pipeline
(
containing_pipeline_id
)
;
pipeline
.
trigger_mozbrowser_event
(
subpage_id
event
)
;
}
fn
handle_get_pipeline
(
&
mut
self
frame_id
:
Option
<
FrameId
>
resp_chan
:
IpcSender
<
Option
<
PipelineId
>
>
)
{
let
current_pipeline_id
=
frame_id
.
or
(
self
.
root_frame_id
)
.
map
(
|
frame_id
|
{
let
frame
=
self
.
frames
.
get
(
&
frame_id
)
.
unwrap
(
)
;
frame
.
current
}
)
;
let
pipeline_id
=
self
.
pending_frames
.
iter
(
)
.
rev
(
)
.
find
(
|
x
|
x
.
old_pipeline_id
=
=
current_pipeline_id
)
.
map
(
|
x
|
x
.
new_pipeline_id
)
.
or
(
current_pipeline_id
)
;
resp_chan
.
send
(
pipeline_id
)
.
unwrap
(
)
;
}
fn
handle_get_frame
(
&
mut
self
pipeline_id
:
PipelineId
resp_chan
:
IpcSender
<
Option
<
FrameId
>
>
)
{
let
frame_id
=
self
.
pipeline_to_frame_map
.
get
(
&
pipeline_id
)
.
map
(
|
x
|
*
x
)
;
resp_chan
.
send
(
frame_id
)
.
unwrap
(
)
;
}
fn
focus_parent_pipeline
(
&
self
pipeline_id
:
PipelineId
)
{
if
let
Some
(
(
containing_pipeline_id
subpage_id
)
)
=
self
.
pipeline
(
pipeline_id
)
.
parent_info
{
let
pipeline
=
self
.
pipeline
(
containing_pipeline_id
)
;
let
event
=
ConstellationControlMsg
:
:
FocusIFrame
(
containing_pipeline_id
subpage_id
)
;
pipeline
.
script_chan
.
send
(
event
)
.
unwrap
(
)
;
self
.
focus_parent_pipeline
(
containing_pipeline_id
)
;
}
}
fn
handle_focus_msg
(
&
mut
self
pipeline_id
:
PipelineId
)
{
self
.
focus_pipeline_id
=
Some
(
pipeline_id
)
;
self
.
focus_parent_pipeline
(
pipeline_id
)
;
}
fn
handle_remove_iframe_msg
(
&
mut
self
pipeline_id
:
PipelineId
)
{
let
frame_id
=
self
.
pipeline_to_frame_map
.
get
(
&
pipeline_id
)
.
map
(
|
id
|
*
id
)
;
match
frame_id
{
Some
(
frame_id
)
=
>
{
self
.
close_frame
(
frame_id
ExitPipelineMode
:
:
Normal
)
;
}
None
=
>
{
self
.
close_pipeline
(
pipeline_id
ExitPipelineMode
:
:
Normal
)
;
}
}
}
fn
handle_create_canvas_paint_task_msg
(
&
mut
self
size
:
&
Size2D
<
i32
>
response_sender
:
IpcSender
<
(
IpcSender
<
CanvasMsg
>
usize
)
>
)
{
let
id
=
self
.
canvas_paint_tasks
.
len
(
)
;
let
(
out_of_process_sender
in_process_sender
)
=
CanvasPaintTask
:
:
start
(
*
size
)
;
self
.
canvas_paint_tasks
.
push
(
in_process_sender
)
;
response_sender
.
send
(
(
out_of_process_sender
id
)
)
.
unwrap
(
)
}
fn
handle_create_webgl_paint_task_msg
(
&
mut
self
size
:
&
Size2D
<
i32
>
attributes
:
GLContextAttributes
response_sender
:
IpcSender
<
Result
<
(
IpcSender
<
CanvasMsg
>
usize
)
String
>
>
)
{
let
response
=
match
WebGLPaintTask
:
:
start
(
*
size
attributes
)
{
Ok
(
(
out_of_process_sender
in_process_sender
)
)
=
>
{
let
id
=
self
.
webgl_paint_tasks
.
len
(
)
;
self
.
webgl_paint_tasks
.
push
(
in_process_sender
)
;
Ok
(
(
out_of_process_sender
id
)
)
}
Err
(
msg
)
=
>
Err
(
msg
.
to_owned
(
)
)
}
;
response_sender
.
send
(
response
)
.
unwrap
(
)
}
fn
handle_webdriver_msg
(
&
mut
self
msg
:
WebDriverCommandMsg
)
{
match
msg
{
WebDriverCommandMsg
:
:
LoadUrl
(
pipeline_id
load_data
reply
)
=
>
{
self
.
load_url_for_webdriver
(
pipeline_id
load_data
reply
)
;
}
WebDriverCommandMsg
:
:
Refresh
(
pipeline_id
reply
)
=
>
{
let
load_data
=
{
let
pipeline
=
self
.
pipeline
(
pipeline_id
)
;
LoadData
:
:
new
(
pipeline
.
url
.
clone
(
)
)
}
;
self
.
load_url_for_webdriver
(
pipeline_id
load_data
reply
)
;
}
WebDriverCommandMsg
:
:
ScriptCommand
(
pipeline_id
cmd
)
=
>
{
let
pipeline
=
self
.
pipeline
(
pipeline_id
)
;
let
control_msg
=
ConstellationControlMsg
:
:
WebDriverScriptCommand
(
pipeline_id
cmd
)
;
pipeline
.
script_chan
.
send
(
control_msg
)
.
unwrap
(
)
;
}
WebDriverCommandMsg
:
:
SendKeys
(
pipeline_id
cmd
)
=
>
{
let
pipeline
=
self
.
pipeline
(
pipeline_id
)
;
for
(
key
mods
state
)
in
cmd
{
let
event
=
CompositorEvent
:
:
KeyEvent
(
key
state
mods
)
;
pipeline
.
script_chan
.
send
(
ConstellationControlMsg
:
:
SendEvent
(
pipeline
.
id
event
)
)
.
unwrap
(
)
;
}
}
WebDriverCommandMsg
:
:
TakeScreenshot
(
pipeline_id
reply
)
=
>
{
let
current_pipeline_id
=
self
.
root_frame_id
.
map
(
|
frame_id
|
{
let
frame
=
self
.
frames
.
get
(
&
frame_id
)
.
unwrap
(
)
;
frame
.
current
}
)
;
if
Some
(
pipeline_id
)
=
=
current_pipeline_id
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
CreatePng
(
reply
)
)
;
}
else
{
reply
.
send
(
None
)
.
unwrap
(
)
;
}
}
}
}
fn
load_url_for_webdriver
(
&
mut
self
pipeline_id
:
PipelineId
load_data
:
LoadData
reply
:
IpcSender
<
webdriver_msg
:
:
LoadStatus
>
)
{
let
new_pipeline_id
=
self
.
load_url
(
pipeline_id
load_data
)
;
if
let
Some
(
id
)
=
new_pipeline_id
{
self
.
webdriver
.
load_channel
=
Some
(
(
id
reply
)
)
;
}
}
fn
add_or_replace_pipeline_in_frame_tree
(
&
mut
self
frame_change
:
FrameChange
)
{
if
let
Some
(
old_pipeline_id
)
=
frame_change
.
old_pipeline_id
{
let
old_frame_id
=
*
self
.
pipeline_to_frame_map
.
get
(
&
old_pipeline_id
)
.
unwrap
(
)
;
if
self
.
focused_pipeline_in_tree
(
old_frame_id
)
{
self
.
focus_pipeline_id
=
Some
(
frame_change
.
new_pipeline_id
)
;
}
}
let
evicted_frames
=
match
frame_change
.
old_pipeline_id
{
Some
(
old_pipeline_id
)
=
>
{
self
.
revoke_paint_permission
(
old_pipeline_id
)
;
let
frame_id
=
*
self
.
pipeline_to_frame_map
.
get
(
&
old_pipeline_id
)
.
unwrap
(
)
;
let
evicted_frames
=
self
.
mut_frame
(
frame_id
)
.
load
(
frame_change
.
new_pipeline_id
)
;
self
.
pipeline_to_frame_map
.
insert
(
frame_change
.
new_pipeline_id
frame_id
)
;
Some
(
evicted_frames
)
}
None
=
>
{
let
frame_id
=
self
.
new_frame
(
frame_change
.
new_pipeline_id
)
;
match
self
.
pipeline
(
frame_change
.
new_pipeline_id
)
.
parent_info
{
Some
(
(
parent_id
_
)
)
=
>
{
self
.
mut_pipeline
(
parent_id
)
.
add_child
(
frame_id
)
;
}
None
=
>
{
assert
!
(
self
.
root_frame_id
.
is_none
(
)
)
;
self
.
root_frame_id
=
Some
(
frame_id
)
;
}
}
None
}
}
;
self
.
send_frame_tree_and_grant_paint_permission
(
)
;
self
.
trigger_mozbrowserlocationchange
(
frame_change
.
new_pipeline_id
)
;
if
let
Some
(
evicted_frames
)
=
evicted_frames
{
for
pipeline_id
in
&
evicted_frames
{
self
.
close_pipeline
(
*
pipeline_id
ExitPipelineMode
:
:
Normal
)
;
}
}
}
fn
handle_activate_document_msg
(
&
mut
self
pipeline_id
:
PipelineId
)
{
debug
!
(
"
Document
ready
to
activate
{
:
?
}
"
pipeline_id
)
;
if
self
.
pipeline_is_in_current_frame
(
pipeline_id
)
{
return
;
}
let
pending_index
=
self
.
pending_frames
.
iter
(
)
.
rposition
(
|
frame_change
|
{
frame_change
.
new_pipeline_id
=
=
pipeline_id
}
)
;
if
let
Some
(
pending_index
)
=
pending_index
{
self
.
pending_frames
[
pending_index
]
.
document_ready
=
true
;
}
while
let
Some
(
valid_frame_change
)
=
self
.
pending_frames
.
iter
(
)
.
rposition
(
|
frame_change
|
{
let
waiting_on_dependency
=
frame_change
.
old_pipeline_id
.
map_or
(
false
|
old_pipeline_id
|
{
self
.
pipeline_to_frame_map
.
get
(
&
old_pipeline_id
)
.
is_none
(
)
}
)
;
frame_change
.
document_ready
&
&
!
waiting_on_dependency
}
)
{
let
frame_change
=
self
.
pending_frames
.
swap_remove
(
valid_frame_change
)
;
self
.
add_or_replace_pipeline_in_frame_tree
(
frame_change
)
;
}
}
fn
handle_resized_window_msg
(
&
mut
self
new_size
:
WindowSizeData
)
{
debug
!
(
"
handle_resized_window_msg
:
{
:
?
}
{
:
?
}
"
new_size
.
initial_viewport
.
to_untyped
(
)
new_size
.
visible_viewport
.
to_untyped
(
)
)
;
if
let
Some
(
root_frame_id
)
=
self
.
root_frame_id
{
let
frame
=
self
.
frames
.
get
(
&
root_frame_id
)
.
unwrap
(
)
;
let
pipeline
=
self
.
pipelines
.
get
(
&
frame
.
current
)
.
unwrap
(
)
;
let
_
=
pipeline
.
script_chan
.
send
(
ConstellationControlMsg
:
:
Resize
(
pipeline
.
id
new_size
)
)
;
for
pipeline_id
in
frame
.
prev
.
iter
(
)
.
chain
(
&
frame
.
next
)
{
let
pipeline
=
self
.
pipelines
.
get
(
pipeline_id
)
.
unwrap
(
)
;
let
_
=
pipeline
.
script_chan
.
send
(
ConstellationControlMsg
:
:
ResizeInactive
(
pipeline
.
id
new_size
)
)
;
}
}
for
pending_frame
in
&
self
.
pending_frames
{
let
pipeline
=
self
.
pipelines
.
get
(
&
pending_frame
.
new_pipeline_id
)
.
unwrap
(
)
;
if
pipeline
.
parent_info
.
is_none
(
)
{
let
_
=
pipeline
.
script_chan
.
send
(
ConstellationControlMsg
:
:
Resize
(
pipeline
.
id
new_size
)
)
;
}
}
self
.
window_size
=
new_size
;
}
fn
handle_viewport_constrained_msg
(
&
mut
self
pipeline_id
:
PipelineId
constraints
:
ViewportConstraints
)
{
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
ViewportConstrained
(
pipeline_id
constraints
)
)
;
}
fn
handle_is_ready_to_save_image
(
&
mut
self
pipeline_states
:
HashMap
<
PipelineId
Epoch
>
)
-
>
ReadyToSave
{
if
self
.
root_frame_id
.
is_none
(
)
{
return
ReadyToSave
:
:
NoRootFrame
;
}
if
self
.
pending_frames
.
len
(
)
>
0
{
return
ReadyToSave
:
:
PendingFrames
;
}
for
frame
in
self
.
current_frame_tree_iter
(
self
.
root_frame_id
)
{
let
pipeline
=
self
.
pipeline
(
frame
.
current
)
;
let
(
sender
receiver
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
let
msg
=
LayoutControlMsg
:
:
GetWebFontLoadState
(
sender
)
;
pipeline
.
layout_chan
.
0
.
send
(
msg
)
.
unwrap
(
)
;
if
receiver
.
recv
(
)
.
unwrap
(
)
{
return
ReadyToSave
:
:
WebFontNotLoaded
;
}
match
self
.
document_states
.
get
(
&
frame
.
current
)
{
Some
(
&
DocumentState
:
:
Idle
)
=
>
{
}
Some
(
&
DocumentState
:
:
Pending
)
|
None
=
>
{
return
ReadyToSave
:
:
DocumentLoading
;
}
}
if
let
Some
(
size
)
=
pipeline
.
size
{
if
size
=
=
Size2D
:
:
zero
(
)
{
continue
;
}
let
compositor_epoch
=
pipeline_states
.
get
(
&
frame
.
current
)
;
match
compositor_epoch
{
Some
(
compositor_epoch
)
=
>
{
let
(
sender
receiver
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
let
LayoutControlChan
(
ref
layout_chan
)
=
pipeline
.
layout_chan
;
layout_chan
.
send
(
LayoutControlMsg
:
:
GetCurrentEpoch
(
sender
)
)
.
unwrap
(
)
;
let
layout_task_epoch
=
receiver
.
recv
(
)
.
unwrap
(
)
;
if
layout_task_epoch
!
=
*
compositor_epoch
{
return
ReadyToSave
:
:
EpochMismatch
;
}
}
None
=
>
{
return
ReadyToSave
:
:
PipelineUnknown
;
}
}
}
}
ReadyToSave
:
:
Ready
}
fn
close_frame
(
&
mut
self
frame_id
:
FrameId
exit_mode
:
ExitPipelineMode
)
{
let
parent_info
=
self
.
pipeline
(
self
.
frame
(
frame_id
)
.
current
)
.
parent_info
;
let
pipelines_to_close
=
{
let
mut
pipelines_to_close
=
vec
!
(
)
;
let
frame
=
self
.
frame
(
frame_id
)
;
pipelines_to_close
.
extend_from_slice
(
&
frame
.
next
)
;
pipelines_to_close
.
push
(
frame
.
current
)
;
pipelines_to_close
.
extend_from_slice
(
&
frame
.
prev
)
;
pipelines_to_close
}
;
for
pipeline_id
in
&
pipelines_to_close
{
self
.
close_pipeline
(
*
pipeline_id
exit_mode
)
;
}
self
.
frames
.
remove
(
&
frame_id
)
.
unwrap
(
)
;
if
let
Some
(
(
parent_pipeline_id
_
)
)
=
parent_info
{
let
parent_pipeline
=
self
.
mut_pipeline
(
parent_pipeline_id
)
;
parent_pipeline
.
remove_child
(
frame_id
)
;
}
}
fn
close_pipeline
(
&
mut
self
pipeline_id
:
PipelineId
exit_mode
:
ExitPipelineMode
)
{
let
frames_to_close
=
{
let
mut
frames_to_close
=
vec
!
(
)
;
let
pipeline
=
self
.
pipeline
(
pipeline_id
)
;
frames_to_close
.
extend_from_slice
(
&
pipeline
.
children
)
;
frames_to_close
}
;
for
child_frame
in
&
frames_to_close
{
self
.
close_frame
(
*
child_frame
exit_mode
)
;
}
let
pipeline
=
self
.
pipelines
.
remove
(
&
pipeline_id
)
.
unwrap
(
)
;
if
let
Some
(
info
)
=
pipeline
.
parent_info
{
self
.
subpage_map
.
remove
(
&
info
)
;
}
self
.
pipeline_to_frame_map
.
remove
(
&
pipeline_id
)
;
let
pending_index
=
self
.
pending_frames
.
iter
(
)
.
position
(
|
frame_change
|
{
frame_change
.
new_pipeline_id
=
=
pipeline_id
}
)
;
if
let
Some
(
pending_index
)
=
pending_index
{
self
.
pending_frames
.
remove
(
pending_index
)
;
}
match
exit_mode
{
ExitPipelineMode
:
:
Normal
=
>
pipeline
.
exit
(
)
ExitPipelineMode
:
:
Force
=
>
pipeline
.
force_exit
(
)
}
}
fn
frame_to_sendable
(
&
self
frame_id
:
FrameId
)
-
>
SendableFrameTree
{
let
pipeline
=
self
.
pipeline
(
self
.
frame
(
frame_id
)
.
current
)
;
let
mut
frame_tree
=
SendableFrameTree
{
pipeline
:
pipeline
.
to_sendable
(
)
size
:
pipeline
.
size
children
:
vec
!
(
)
}
;
for
child_frame_id
in
&
pipeline
.
children
{
frame_tree
.
children
.
push
(
self
.
frame_to_sendable
(
*
child_frame_id
)
)
;
}
frame_tree
}
fn
revoke_paint_permission
(
&
self
pipeline_id
:
PipelineId
)
{
let
frame_id
=
self
.
pipeline_to_frame_map
.
get
(
&
pipeline_id
)
.
map
(
|
frame_id
|
*
frame_id
)
;
for
frame
in
self
.
current_frame_tree_iter
(
frame_id
)
{
self
.
pipeline
(
frame
.
current
)
.
revoke_paint_permission
(
)
;
}
}
fn
send_frame_tree_and_grant_paint_permission
(
&
mut
self
)
{
if
let
Some
(
root_frame_id
)
=
self
.
root_frame_id
{
let
frame_tree
=
self
.
frame_to_sendable
(
root_frame_id
)
;
let
(
chan
port
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
self
.
compositor_proxy
.
send
(
ToCompositorMsg
:
:
SetFrameTree
(
frame_tree
chan
self
.
compositor_sender
.
clone
(
)
)
)
;
if
port
.
recv
(
)
.
is_err
(
)
{
debug
!
(
"
Compositor
has
discarded
SetFrameTree
"
)
;
return
;
}
}
for
frame
in
self
.
current_frame_tree_iter
(
self
.
root_frame_id
)
{
self
.
pipeline
(
frame
.
current
)
.
grant_paint_permission
(
)
;
}
}
fn
trigger_mozbrowserlocationchange
(
&
self
pipeline_id
:
PipelineId
)
{
if
prefs
:
:
get_pref
(
"
dom
.
mozbrowser
.
enabled
"
)
.
as_boolean
(
)
.
unwrap_or
(
false
)
{
let
event_info
=
{
let
pipeline
=
self
.
pipeline
(
pipeline_id
)
;
pipeline
.
parent_info
.
map
(
|
(
containing_pipeline_id
subpage_id
)
|
{
(
containing_pipeline_id
subpage_id
pipeline
.
url
.
serialize
(
)
)
}
)
}
;
if
let
Some
(
(
containing_pipeline_id
subpage_id
url
)
)
=
event_info
{
let
parent_pipeline
=
self
.
pipeline
(
containing_pipeline_id
)
;
parent_pipeline
.
trigger_mozbrowser_event
(
subpage_id
MozBrowserEvent
:
:
LocationChange
(
url
)
)
;
}
}
}
fn
focused_pipeline_in_tree
(
&
self
frame_id
:
FrameId
)
-
>
bool
{
self
.
focus_pipeline_id
.
map_or
(
false
|
pipeline_id
|
{
self
.
pipeline_exists_in_tree
(
pipeline_id
Some
(
frame_id
)
)
}
)
}
fn
pipeline_is_in_current_frame
(
&
self
pipeline_id
:
PipelineId
)
-
>
bool
{
self
.
pipeline_exists_in_tree
(
pipeline_id
self
.
root_frame_id
)
}
fn
pipeline_exists_in_tree
(
&
self
pipeline_id
:
PipelineId
root_frame_id
:
Option
<
FrameId
>
)
-
>
bool
{
self
.
current_frame_tree_iter
(
root_frame_id
)
.
any
(
|
current_frame
|
current_frame
.
current
=
=
pipeline_id
)
}
#
[
inline
(
always
)
]
fn
frame
(
&
self
frame_id
:
FrameId
)
-
>
&
Frame
{
self
.
frames
.
get
(
&
frame_id
)
.
expect
(
"
unable
to
find
frame
-
this
is
a
bug
"
)
}
#
[
inline
(
always
)
]
fn
mut_frame
(
&
mut
self
frame_id
:
FrameId
)
-
>
&
mut
Frame
{
self
.
frames
.
get_mut
(
&
frame_id
)
.
expect
(
"
unable
to
find
frame
-
this
is
a
bug
"
)
}
#
[
inline
(
always
)
]
fn
pipeline
(
&
self
pipeline_id
:
PipelineId
)
-
>
&
Pipeline
{
self
.
pipelines
.
get
(
&
pipeline_id
)
.
expect
(
"
unable
to
find
pipeline
-
this
is
a
bug
"
)
}
#
[
inline
(
always
)
]
fn
mut_pipeline
(
&
mut
self
pipeline_id
:
PipelineId
)
-
>
&
mut
Pipeline
{
self
.
pipelines
.
get_mut
(
&
pipeline_id
)
.
expect
(
"
unable
to
find
pipeline
-
this
is
a
bug
"
)
}
fn
find_subpage
(
&
mut
self
containing_pipeline_id
:
PipelineId
subpage_id
:
SubpageId
)
-
>
&
mut
Pipeline
{
let
pipeline_id
=
*
self
.
subpage_map
.
get
(
&
(
containing_pipeline_id
subpage_id
)
)
.
expect
(
"
no
subpage
pipeline_id
"
)
;
self
.
mut_pipeline
(
pipeline_id
)
}
}
