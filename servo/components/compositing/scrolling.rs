use
compositor_task
:
:
{
CompositorProxy
Msg
}
;
use
native
:
:
task
:
:
NativeTaskBuilder
;
use
std
:
:
io
:
:
timer
;
use
std
:
:
task
:
:
TaskBuilder
;
use
std
:
:
time
:
:
duration
:
:
Duration
;
use
time
;
static
TIMEOUT
:
i64
=
12_000_000
;
pub
struct
ScrollingTimerProxy
{
sender
:
Sender
<
ToScrollingTimerMsg
>
}
pub
struct
ScrollingTimer
{
compositor_proxy
:
Box
<
CompositorProxy
>
receiver
:
Receiver
<
ToScrollingTimerMsg
>
}
enum
ToScrollingTimerMsg
{
ExitMsg
ScrollEventProcessedMsg
(
u64
)
}
impl
ScrollingTimerProxy
{
pub
fn
new
(
compositor_proxy
:
Box
<
CompositorProxy
+
Send
>
)
-
>
ScrollingTimerProxy
{
let
(
to_scrolling_timer_sender
to_scrolling_timer_receiver
)
=
channel
(
)
;
TaskBuilder
:
:
new
(
)
.
native
(
)
.
spawn
(
proc
(
)
{
let
mut
scrolling_timer
=
ScrollingTimer
{
compositor_proxy
:
compositor_proxy
receiver
:
to_scrolling_timer_receiver
}
;
scrolling_timer
.
run
(
)
;
}
)
;
ScrollingTimerProxy
{
sender
:
to_scrolling_timer_sender
}
}
pub
fn
scroll_event_processed
(
&
mut
self
timestamp
:
u64
)
{
self
.
sender
.
send
(
ToScrollingTimerMsg
:
:
ScrollEventProcessedMsg
(
timestamp
)
)
}
pub
fn
shutdown
(
&
mut
self
)
{
self
.
sender
.
send
(
ToScrollingTimerMsg
:
:
ExitMsg
)
;
}
}
impl
ScrollingTimer
{
pub
fn
run
(
&
mut
self
)
{
loop
{
match
self
.
receiver
.
recv_opt
(
)
{
Ok
(
ToScrollingTimerMsg
:
:
ScrollEventProcessedMsg
(
timestamp
)
)
=
>
{
let
target
=
timestamp
as
i64
+
TIMEOUT
;
let
delta
=
target
-
(
time
:
:
precise_time_ns
(
)
as
i64
)
;
timer
:
:
sleep
(
Duration
:
:
nanoseconds
(
delta
)
)
;
self
.
compositor_proxy
.
send
(
Msg
:
:
ScrollTimeout
(
timestamp
)
)
;
}
Ok
(
ToScrollingTimerMsg
:
:
ExitMsg
)
|
Err
(
_
)
=
>
break
}
}
}
}
