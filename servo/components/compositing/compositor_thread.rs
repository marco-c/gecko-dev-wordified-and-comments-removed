use
CompositorMsg
as
ConstellationMsg
;
use
compositor
;
use
euclid
:
:
point
:
:
Point2D
;
use
euclid
:
:
size
:
:
Size2D
;
use
gfx_traits
:
:
{
Epoch
LayerId
LayerProperties
PaintListener
}
;
use
headless
;
use
ipc_channel
:
:
ipc
:
:
{
self
IpcReceiver
IpcSender
}
;
use
layers
:
:
layers
:
:
{
BufferRequest
LayerBufferSet
}
;
use
layers
:
:
platform
:
:
surface
:
:
{
NativeDisplay
NativeSurface
}
;
use
msg
:
:
compositor_msg
:
:
FrameTreeId
;
use
msg
:
:
constellation_msg
:
:
{
AnimationState
PipelineId
}
;
use
msg
:
:
constellation_msg
:
:
{
Image
Key
KeyModifiers
KeyState
}
;
use
profile_traits
:
:
mem
;
use
profile_traits
:
:
time
;
use
script_traits
:
:
{
EventResult
ScriptToCompositorMsg
}
;
use
std
:
:
fmt
:
:
{
Debug
Error
Formatter
}
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
sync
:
:
mpsc
:
:
{
Receiver
Sender
channel
}
;
use
style_traits
:
:
viewport
:
:
ViewportConstraints
;
use
url
:
:
Url
;
use
util
:
:
cursor
:
:
Cursor
;
use
windowing
:
:
{
WindowEvent
WindowMethods
}
;
pub
use
constellation
:
:
SendableFrameTree
;
pub
use
windowing
;
pub
trait
CompositorProxy
:
'
static
+
Send
{
fn
send
(
&
self
msg
:
Msg
)
;
fn
clone_compositor_proxy
(
&
self
)
-
>
Box
<
CompositorProxy
+
'
static
+
Send
>
;
}
pub
trait
CompositorReceiver
:
'
static
{
fn
try_recv_compositor_msg
(
&
mut
self
)
-
>
Option
<
Msg
>
;
fn
recv_compositor_msg
(
&
mut
self
)
-
>
Msg
;
}
impl
CompositorReceiver
for
Receiver
<
Msg
>
{
fn
try_recv_compositor_msg
(
&
mut
self
)
-
>
Option
<
Msg
>
{
self
.
try_recv
(
)
.
ok
(
)
}
fn
recv_compositor_msg
(
&
mut
self
)
-
>
Msg
{
self
.
recv
(
)
.
unwrap
(
)
}
}
pub
fn
run_script_listener_thread
(
compositor_proxy
:
Box
<
CompositorProxy
+
'
static
+
Send
>
receiver
:
IpcReceiver
<
ScriptToCompositorMsg
>
)
{
while
let
Ok
(
msg
)
=
receiver
.
recv
(
)
{
match
msg
{
ScriptToCompositorMsg
:
:
ScrollFragmentPoint
(
pipeline_id
layer_id
point
smooth
)
=
>
{
compositor_proxy
.
send
(
Msg
:
:
ScrollFragmentPoint
(
pipeline_id
layer_id
point
smooth
)
)
;
}
ScriptToCompositorMsg
:
:
GetClientWindow
(
send
)
=
>
{
compositor_proxy
.
send
(
Msg
:
:
GetClientWindow
(
send
)
)
;
}
ScriptToCompositorMsg
:
:
MoveTo
(
point
)
=
>
{
compositor_proxy
.
send
(
Msg
:
:
MoveTo
(
point
)
)
;
}
ScriptToCompositorMsg
:
:
ResizeTo
(
size
)
=
>
{
compositor_proxy
.
send
(
Msg
:
:
ResizeTo
(
size
)
)
;
}
ScriptToCompositorMsg
:
:
Exit
=
>
{
let
(
chan
port
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
compositor_proxy
.
send
(
Msg
:
:
Exit
(
chan
)
)
;
port
.
recv
(
)
.
unwrap
(
)
;
}
ScriptToCompositorMsg
:
:
SetTitle
(
pipeline_id
title
)
=
>
{
compositor_proxy
.
send
(
Msg
:
:
ChangePageTitle
(
pipeline_id
title
)
)
}
ScriptToCompositorMsg
:
:
SendKeyEvent
(
key
key_state
key_modifiers
)
=
>
{
compositor_proxy
.
send
(
Msg
:
:
KeyEvent
(
key
key_state
key_modifiers
)
)
}
ScriptToCompositorMsg
:
:
TouchEventProcessed
(
result
)
=
>
{
compositor_proxy
.
send
(
Msg
:
:
TouchEventProcessed
(
result
)
)
}
}
}
}
impl
PaintListener
for
Box
<
CompositorProxy
+
'
static
+
Send
>
{
fn
native_display
(
&
mut
self
)
-
>
Option
<
NativeDisplay
>
{
let
(
chan
port
)
=
channel
(
)
;
self
.
send
(
Msg
:
:
GetNativeDisplay
(
chan
)
)
;
port
.
recv
(
)
.
unwrap_or
(
None
)
}
fn
assign_painted_buffers
(
&
mut
self
pipeline_id
:
PipelineId
epoch
:
Epoch
replies
:
Vec
<
(
LayerId
Box
<
LayerBufferSet
>
)
>
frame_tree_id
:
FrameTreeId
)
{
self
.
send
(
Msg
:
:
AssignPaintedBuffers
(
pipeline_id
epoch
replies
frame_tree_id
)
)
;
}
fn
ignore_buffer_requests
(
&
mut
self
buffer_requests
:
Vec
<
BufferRequest
>
)
{
let
mut
native_surfaces
=
Vec
:
:
new
(
)
;
for
request
in
buffer_requests
.
into_iter
(
)
{
if
let
Some
(
native_surface
)
=
request
.
native_surface
{
native_surfaces
.
push
(
native_surface
)
;
}
}
if
!
native_surfaces
.
is_empty
(
)
{
self
.
send
(
Msg
:
:
ReturnUnusedNativeSurfaces
(
native_surfaces
)
)
;
}
}
fn
initialize_layers_for_pipeline
(
&
mut
self
pipeline_id
:
PipelineId
properties
:
Vec
<
LayerProperties
>
epoch
:
Epoch
)
{
self
.
send
(
Msg
:
:
InitializeLayersForPipeline
(
pipeline_id
epoch
properties
)
)
;
}
fn
notify_paint_thread_exiting
(
&
mut
self
pipeline_id
:
PipelineId
)
{
self
.
send
(
Msg
:
:
PaintThreadExited
(
pipeline_id
)
)
}
}
pub
enum
Msg
{
Exit
(
IpcSender
<
(
)
>
)
ShutdownComplete
GetNativeDisplay
(
Sender
<
Option
<
NativeDisplay
>
>
)
InitializeLayersForPipeline
(
PipelineId
Epoch
Vec
<
LayerProperties
>
)
ScrollFragmentPoint
(
PipelineId
LayerId
Point2D
<
f32
>
bool
)
AssignPaintedBuffers
(
PipelineId
Epoch
Vec
<
(
LayerId
Box
<
LayerBufferSet
>
)
>
FrameTreeId
)
ChangePageTitle
(
PipelineId
Option
<
String
>
)
ChangePageUrl
(
PipelineId
Url
)
ChangeRunningAnimationsState
(
PipelineId
AnimationState
)
SetFrameTree
(
SendableFrameTree
IpcSender
<
(
)
>
Sender
<
ConstellationMsg
>
)
LoadStart
(
bool
bool
)
LoadComplete
(
bool
bool
)
ScrollTimeout
(
u64
)
RecompositeAfterScroll
KeyEvent
(
Key
KeyState
KeyModifiers
)
TouchEventProcessed
(
EventResult
)
SetCursor
(
Cursor
)
CreatePng
(
IpcSender
<
Option
<
Image
>
>
)
PaintThreadExited
(
PipelineId
)
ViewportConstrained
(
PipelineId
ViewportConstraints
)
IsReadyToSaveImageReply
(
bool
)
NewFavicon
(
Url
)
HeadParsed
ReturnUnusedNativeSurfaces
(
Vec
<
NativeSurface
>
)
CollectMemoryReports
(
mem
:
:
ReportsChan
)
Status
(
Option
<
String
>
)
GetClientWindow
(
IpcSender
<
(
Size2D
<
u32
>
Point2D
<
i32
>
)
>
)
MoveTo
(
Point2D
<
i32
>
)
ResizeTo
(
Size2D
<
u32
>
)
PipelineExited
(
PipelineId
)
}
impl
Debug
for
Msg
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
Result
<
(
)
Error
>
{
match
*
self
{
Msg
:
:
Exit
(
.
.
)
=
>
write
!
(
f
"
Exit
"
)
Msg
:
:
ShutdownComplete
=
>
write
!
(
f
"
ShutdownComplete
"
)
Msg
:
:
GetNativeDisplay
(
.
.
)
=
>
write
!
(
f
"
GetNativeDisplay
"
)
Msg
:
:
InitializeLayersForPipeline
(
.
.
)
=
>
write
!
(
f
"
InitializeLayersForPipeline
"
)
Msg
:
:
ScrollFragmentPoint
(
.
.
)
=
>
write
!
(
f
"
ScrollFragmentPoint
"
)
Msg
:
:
AssignPaintedBuffers
(
.
.
)
=
>
write
!
(
f
"
AssignPaintedBuffers
"
)
Msg
:
:
ChangeRunningAnimationsState
(
.
.
)
=
>
write
!
(
f
"
ChangeRunningAnimationsState
"
)
Msg
:
:
ChangePageTitle
(
.
.
)
=
>
write
!
(
f
"
ChangePageTitle
"
)
Msg
:
:
ChangePageUrl
(
.
.
)
=
>
write
!
(
f
"
ChangePageUrl
"
)
Msg
:
:
SetFrameTree
(
.
.
)
=
>
write
!
(
f
"
SetFrameTree
"
)
Msg
:
:
LoadComplete
(
.
.
)
=
>
write
!
(
f
"
LoadComplete
"
)
Msg
:
:
LoadStart
(
.
.
)
=
>
write
!
(
f
"
LoadStart
"
)
Msg
:
:
ScrollTimeout
(
.
.
)
=
>
write
!
(
f
"
ScrollTimeout
"
)
Msg
:
:
RecompositeAfterScroll
=
>
write
!
(
f
"
RecompositeAfterScroll
"
)
Msg
:
:
KeyEvent
(
.
.
)
=
>
write
!
(
f
"
KeyEvent
"
)
Msg
:
:
TouchEventProcessed
(
.
.
)
=
>
write
!
(
f
"
TouchEventProcessed
"
)
Msg
:
:
SetCursor
(
.
.
)
=
>
write
!
(
f
"
SetCursor
"
)
Msg
:
:
CreatePng
(
.
.
)
=
>
write
!
(
f
"
CreatePng
"
)
Msg
:
:
PaintThreadExited
(
.
.
)
=
>
write
!
(
f
"
PaintThreadExited
"
)
Msg
:
:
ViewportConstrained
(
.
.
)
=
>
write
!
(
f
"
ViewportConstrained
"
)
Msg
:
:
IsReadyToSaveImageReply
(
.
.
)
=
>
write
!
(
f
"
IsReadyToSaveImageReply
"
)
Msg
:
:
NewFavicon
(
.
.
)
=
>
write
!
(
f
"
NewFavicon
"
)
Msg
:
:
HeadParsed
=
>
write
!
(
f
"
HeadParsed
"
)
Msg
:
:
ReturnUnusedNativeSurfaces
(
.
.
)
=
>
write
!
(
f
"
ReturnUnusedNativeSurfaces
"
)
Msg
:
:
CollectMemoryReports
(
.
.
)
=
>
write
!
(
f
"
CollectMemoryReports
"
)
Msg
:
:
Status
(
.
.
)
=
>
write
!
(
f
"
Status
"
)
Msg
:
:
GetClientWindow
(
.
.
)
=
>
write
!
(
f
"
GetClientWindow
"
)
Msg
:
:
MoveTo
(
.
.
)
=
>
write
!
(
f
"
MoveTo
"
)
Msg
:
:
ResizeTo
(
.
.
)
=
>
write
!
(
f
"
ResizeTo
"
)
Msg
:
:
PipelineExited
(
.
.
)
=
>
write
!
(
f
"
PipelineExited
"
)
}
}
}
pub
struct
CompositorThread
;
impl
CompositorThread
{
pub
fn
create
<
Window
>
(
window
:
Option
<
Rc
<
Window
>
>
state
:
InitialCompositorState
)
-
>
Box
<
CompositorEventListener
+
'
static
>
where
Window
:
WindowMethods
+
'
static
{
match
window
{
Some
(
window
)
=
>
{
box
compositor
:
:
IOCompositor
:
:
create
(
window
state
)
as
Box
<
CompositorEventListener
>
}
None
=
>
{
box
headless
:
:
NullCompositor
:
:
create
(
state
)
as
Box
<
CompositorEventListener
>
}
}
}
}
pub
trait
CompositorEventListener
{
fn
handle_events
(
&
mut
self
events
:
Vec
<
WindowEvent
>
)
-
>
bool
;
fn
repaint_synchronously
(
&
mut
self
)
;
fn
pinch_zoom_level
(
&
self
)
-
>
f32
;
fn
title_for_main_frame
(
&
self
)
;
}
pub
struct
InitialCompositorState
{
pub
sender
:
Box
<
CompositorProxy
+
Send
>
pub
receiver
:
Box
<
CompositorReceiver
>
pub
constellation_chan
:
Sender
<
ConstellationMsg
>
pub
time_profiler_chan
:
time
:
:
ProfilerChan
pub
mem_profiler_chan
:
mem
:
:
ProfilerChan
}
