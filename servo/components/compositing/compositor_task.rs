pub
use
windowing
;
pub
use
constellation
:
:
SendableFrameTree
;
use
compositor
;
use
headless
;
use
windowing
:
:
{
WindowEvent
WindowMethods
}
;
use
azure
:
:
azure_hl
:
:
{
SourceSurfaceMethods
Color
}
;
use
geom
:
:
point
:
:
Point2D
;
use
geom
:
:
rect
:
:
Rect
;
use
geom
:
:
size
:
:
Size2D
;
use
layers
:
:
platform
:
:
surface
:
:
{
NativeCompositingGraphicsContext
NativeGraphicsMetadata
}
;
use
layers
:
:
layers
:
:
LayerBufferSet
;
use
msg
:
:
compositor_msg
:
:
{
Epoch
LayerId
LayerMetadata
ReadyState
}
;
use
msg
:
:
compositor_msg
:
:
{
PaintListener
PaintState
ScriptListener
ScrollPolicy
}
;
use
msg
:
:
constellation_msg
:
:
{
ConstellationChan
PipelineId
}
;
use
msg
:
:
constellation_msg
:
:
{
Key
KeyState
KeyModifiers
}
;
use
profile
:
:
mem
;
use
profile
:
:
time
;
use
std
:
:
sync
:
:
mpsc
:
:
{
channel
Sender
Receiver
}
;
use
std
:
:
fmt
:
:
{
Error
Formatter
Debug
}
;
use
std
:
:
rc
:
:
Rc
;
use
url
:
:
Url
;
use
util
:
:
cursor
:
:
Cursor
;
pub
trait
CompositorProxy
:
'
static
+
Send
{
fn
send
(
&
mut
self
msg
:
Msg
)
;
fn
clone_compositor_proxy
(
&
self
)
-
>
Box
<
CompositorProxy
+
'
static
+
Send
>
;
}
pub
trait
CompositorReceiver
:
'
static
{
fn
try_recv_compositor_msg
(
&
mut
self
)
-
>
Option
<
Msg
>
;
fn
recv_compositor_msg
(
&
mut
self
)
-
>
Msg
;
}
impl
CompositorReceiver
for
Receiver
<
Msg
>
{
fn
try_recv_compositor_msg
(
&
mut
self
)
-
>
Option
<
Msg
>
{
match
self
.
try_recv
(
)
{
Ok
(
msg
)
=
>
Some
(
msg
)
Err
(
_
)
=
>
None
}
}
fn
recv_compositor_msg
(
&
mut
self
)
-
>
Msg
{
self
.
recv
(
)
.
unwrap
(
)
}
}
impl
ScriptListener
for
Box
<
CompositorProxy
+
'
static
+
Send
>
{
fn
set_ready_state
(
&
mut
self
pipeline_id
:
PipelineId
ready_state
:
ReadyState
)
{
let
msg
=
Msg
:
:
ChangeReadyState
(
pipeline_id
ready_state
)
;
self
.
send
(
msg
)
;
}
fn
scroll_fragment_point
(
&
mut
self
pipeline_id
:
PipelineId
layer_id
:
LayerId
point
:
Point2D
<
f32
>
)
{
self
.
send
(
Msg
:
:
ScrollFragmentPoint
(
pipeline_id
layer_id
point
)
)
;
}
fn
close
(
&
mut
self
)
{
let
(
chan
port
)
=
channel
(
)
;
self
.
send
(
Msg
:
:
Exit
(
chan
)
)
;
port
.
recv
(
)
.
unwrap
(
)
;
}
fn
dup
(
&
mut
self
)
-
>
Box
<
ScriptListener
+
'
static
>
{
box
self
.
clone_compositor_proxy
(
)
as
Box
<
ScriptListener
+
'
static
>
}
fn
set_title
(
&
mut
self
pipeline_id
:
PipelineId
title
:
Option
<
String
>
)
{
self
.
send
(
Msg
:
:
ChangePageTitle
(
pipeline_id
title
)
)
}
fn
send_key_event
(
&
mut
self
key
:
Key
state
:
KeyState
modifiers
:
KeyModifiers
)
{
self
.
send
(
Msg
:
:
KeyEvent
(
key
state
modifiers
)
)
;
}
}
#
[
derive
(
Copy
)
]
pub
struct
LayerProperties
{
pub
pipeline_id
:
PipelineId
pub
epoch
:
Epoch
pub
id
:
LayerId
pub
rect
:
Rect
<
f32
>
pub
background_color
:
Color
pub
scroll_policy
:
ScrollPolicy
}
impl
LayerProperties
{
fn
new
(
pipeline_id
:
PipelineId
epoch
:
Epoch
metadata
:
&
LayerMetadata
)
-
>
LayerProperties
{
LayerProperties
{
pipeline_id
:
pipeline_id
epoch
:
epoch
id
:
metadata
.
id
rect
:
Rect
(
Point2D
(
metadata
.
position
.
origin
.
x
as
f32
metadata
.
position
.
origin
.
y
as
f32
)
Size2D
(
metadata
.
position
.
size
.
width
as
f32
metadata
.
position
.
size
.
height
as
f32
)
)
background_color
:
metadata
.
background_color
scroll_policy
:
metadata
.
scroll_policy
}
}
}
impl
PaintListener
for
Box
<
CompositorProxy
+
'
static
+
Send
>
{
fn
get_graphics_metadata
(
&
mut
self
)
-
>
Option
<
NativeGraphicsMetadata
>
{
let
(
chan
port
)
=
channel
(
)
;
self
.
send
(
Msg
:
:
GetGraphicsMetadata
(
chan
)
)
;
port
.
recv
(
)
.
unwrap
(
)
}
fn
assign_painted_buffers
(
&
mut
self
pipeline_id
:
PipelineId
epoch
:
Epoch
replies
:
Vec
<
(
LayerId
Box
<
LayerBufferSet
>
)
>
)
{
self
.
send
(
Msg
:
:
AssignPaintedBuffers
(
pipeline_id
epoch
replies
)
)
;
}
fn
initialize_layers_for_pipeline
(
&
mut
self
pipeline_id
:
PipelineId
metadata
:
Vec
<
LayerMetadata
>
epoch
:
Epoch
)
{
let
mut
first
=
true
;
for
metadata
in
metadata
.
iter
(
)
{
let
layer_properties
=
LayerProperties
:
:
new
(
pipeline_id
epoch
metadata
)
;
if
first
{
self
.
send
(
Msg
:
:
CreateOrUpdateBaseLayer
(
layer_properties
)
)
;
first
=
false
}
else
{
self
.
send
(
Msg
:
:
CreateOrUpdateDescendantLayer
(
layer_properties
)
)
;
}
}
}
fn
paint_msg_discarded
(
&
mut
self
)
{
self
.
send
(
Msg
:
:
PaintMsgDiscarded
)
;
}
fn
set_paint_state
(
&
mut
self
pipeline_id
:
PipelineId
paint_state
:
PaintState
)
{
self
.
send
(
Msg
:
:
ChangePaintState
(
pipeline_id
paint_state
)
)
}
}
pub
enum
Msg
{
Exit
(
Sender
<
(
)
>
)
ShutdownComplete
GetGraphicsMetadata
(
Sender
<
Option
<
NativeGraphicsMetadata
>
>
)
CreateOrUpdateBaseLayer
(
LayerProperties
)
CreateOrUpdateDescendantLayer
(
LayerProperties
)
SetLayerRect
(
PipelineId
LayerId
Rect
<
f32
>
)
ScrollFragmentPoint
(
PipelineId
LayerId
Point2D
<
f32
>
)
AssignPaintedBuffers
(
PipelineId
Epoch
Vec
<
(
LayerId
Box
<
LayerBufferSet
>
)
>
)
ChangeReadyState
(
PipelineId
ReadyState
)
ChangePaintState
(
PipelineId
PaintState
)
ChangePageTitle
(
PipelineId
Option
<
String
>
)
ChangePageUrl
(
PipelineId
Url
)
ChangeRunningAnimationsState
(
PipelineId
bool
)
PaintMsgDiscarded
SetFrameTree
(
SendableFrameTree
Sender
<
(
)
>
ConstellationChan
)
LoadComplete
ScrollTimeout
(
u64
)
RecompositeAfterScroll
KeyEvent
(
Key
KeyState
KeyModifiers
)
SetCursor
(
Cursor
)
PaintTaskExited
(
PipelineId
)
}
impl
Debug
for
Msg
{
fn
fmt
(
&
self
f
:
&
mut
Formatter
)
-
>
Result
<
(
)
Error
>
{
match
*
self
{
Msg
:
:
Exit
(
.
.
)
=
>
write
!
(
f
"
Exit
"
)
Msg
:
:
ShutdownComplete
(
.
.
)
=
>
write
!
(
f
"
ShutdownComplete
"
)
Msg
:
:
GetGraphicsMetadata
(
.
.
)
=
>
write
!
(
f
"
GetGraphicsMetadata
"
)
Msg
:
:
CreateOrUpdateBaseLayer
(
.
.
)
=
>
write
!
(
f
"
CreateOrUpdateBaseLayer
"
)
Msg
:
:
CreateOrUpdateDescendantLayer
(
.
.
)
=
>
write
!
(
f
"
CreateOrUpdateDescendantLayer
"
)
Msg
:
:
SetLayerRect
(
.
.
)
=
>
write
!
(
f
"
SetLayerRect
"
)
Msg
:
:
ScrollFragmentPoint
(
.
.
)
=
>
write
!
(
f
"
ScrollFragmentPoint
"
)
Msg
:
:
AssignPaintedBuffers
(
.
.
)
=
>
write
!
(
f
"
AssignPaintedBuffers
"
)
Msg
:
:
ChangeReadyState
(
.
.
)
=
>
write
!
(
f
"
ChangeReadyState
"
)
Msg
:
:
ChangePaintState
(
.
.
)
=
>
write
!
(
f
"
ChangePaintState
"
)
Msg
:
:
ChangeRunningAnimationsState
(
.
.
)
=
>
write
!
(
f
"
ChangeRunningAnimationsState
"
)
Msg
:
:
ChangePageTitle
(
.
.
)
=
>
write
!
(
f
"
ChangePageTitle
"
)
Msg
:
:
ChangePageUrl
(
.
.
)
=
>
write
!
(
f
"
ChangePageUrl
"
)
Msg
:
:
PaintMsgDiscarded
(
.
.
)
=
>
write
!
(
f
"
PaintMsgDiscarded
"
)
Msg
:
:
SetFrameTree
(
.
.
)
=
>
write
!
(
f
"
SetFrameTree
"
)
Msg
:
:
LoadComplete
=
>
write
!
(
f
"
LoadComplete
"
)
Msg
:
:
ScrollTimeout
(
.
.
)
=
>
write
!
(
f
"
ScrollTimeout
"
)
Msg
:
:
RecompositeAfterScroll
=
>
write
!
(
f
"
RecompositeAfterScroll
"
)
Msg
:
:
KeyEvent
(
.
.
)
=
>
write
!
(
f
"
KeyEvent
"
)
Msg
:
:
SetCursor
(
.
.
)
=
>
write
!
(
f
"
SetCursor
"
)
Msg
:
:
PaintTaskExited
(
.
.
)
=
>
write
!
(
f
"
PaintTaskExited
"
)
}
}
}
pub
struct
CompositorTask
;
impl
CompositorTask
{
#
[
cfg
(
target_os
=
"
linux
"
)
]
pub
fn
create_graphics_context
(
native_metadata
:
&
NativeGraphicsMetadata
)
-
>
NativeCompositingGraphicsContext
{
NativeCompositingGraphicsContext
:
:
from_display
(
native_metadata
.
display
)
}
#
[
cfg
(
not
(
target_os
=
"
linux
"
)
)
]
pub
fn
create_graphics_context
(
_
:
&
NativeGraphicsMetadata
)
-
>
NativeCompositingGraphicsContext
{
NativeCompositingGraphicsContext
:
:
new
(
)
}
pub
fn
create
<
Window
>
(
window
:
Option
<
Rc
<
Window
>
>
sender
:
Box
<
CompositorProxy
+
Send
>
receiver
:
Box
<
CompositorReceiver
>
constellation_chan
:
ConstellationChan
time_profiler_chan
:
time
:
:
ProfilerChan
mem_profiler_chan
:
mem
:
:
ProfilerChan
)
-
>
Box
<
CompositorEventListener
+
'
static
>
where
Window
:
WindowMethods
+
'
static
{
match
window
{
Some
(
window
)
=
>
{
box
compositor
:
:
IOCompositor
:
:
create
(
window
sender
receiver
constellation_chan
.
clone
(
)
time_profiler_chan
mem_profiler_chan
)
as
Box
<
CompositorEventListener
>
}
None
=
>
{
box
headless
:
:
NullCompositor
:
:
create
(
receiver
constellation_chan
.
clone
(
)
time_profiler_chan
mem_profiler_chan
)
as
Box
<
CompositorEventListener
>
}
}
}
}
pub
trait
CompositorEventListener
{
fn
handle_event
(
&
mut
self
event
:
WindowEvent
)
-
>
bool
;
fn
repaint_synchronously
(
&
mut
self
)
;
fn
shutdown
(
&
mut
self
)
;
fn
pinch_zoom_level
(
&
self
)
-
>
f32
;
fn
get_title_for_main_frame
(
&
self
)
;
}
