use
compositor_task
:
:
LayerProperties
;
use
events
;
use
pipeline
:
:
CompositionPipeline
;
use
azure
:
:
azure_hl
:
:
Color
;
use
geom
:
:
point
:
:
TypedPoint2D
;
use
geom
:
:
size
:
:
Size2D
;
use
geom
:
:
rect
:
:
Rect
;
use
gfx
:
:
render_task
:
:
UnusedBufferMsg
;
use
layers
:
:
geometry
:
:
LayerPixel
;
use
layers
:
:
layers
:
:
{
Layer
LayerBufferSet
}
;
use
layers
:
:
platform
:
:
surface
:
:
NativeSurfaceMethods
;
use
servo_msg
:
:
compositor_msg
:
:
{
Epoch
LayerId
}
;
use
servo_msg
:
:
compositor_msg
:
:
ScrollPolicy
;
use
servo_msg
:
:
constellation_msg
:
:
PipelineId
;
use
std
:
:
rc
:
:
Rc
;
pub
struct
CompositorData
{
pub
pipeline
:
CompositionPipeline
pub
id
:
LayerId
pub
wants_scroll_events
:
WantsScrollEventsFlag
pub
scroll_policy
:
ScrollPolicy
pub
background_color
:
Color
pub
epoch
:
Epoch
pub
scroll_offset
:
TypedPoint2D
<
LayerPixel
f32
>
}
#
[
deriving
(
PartialEq
Clone
)
]
pub
enum
WantsScrollEventsFlag
{
WantsScrollEvents
DoesntWantScrollEvents
}
impl
CompositorData
{
pub
fn
new_layer
(
pipeline
:
CompositionPipeline
layer_properties
:
LayerProperties
wants_scroll_events
:
WantsScrollEventsFlag
tile_size
:
uint
)
-
>
Rc
<
Layer
<
CompositorData
>
>
{
let
new_compositor_data
=
CompositorData
{
pipeline
:
pipeline
id
:
layer_properties
.
id
wants_scroll_events
:
wants_scroll_events
scroll_policy
:
layer_properties
.
scroll_policy
background_color
:
layer_properties
.
background_color
epoch
:
layer_properties
.
epoch
scroll_offset
:
TypedPoint2D
(
0
.
0
.
)
}
;
Rc
:
:
new
(
Layer
:
:
new
(
Rect
:
:
from_untyped
(
&
layer_properties
.
rect
)
tile_size
new_compositor_data
)
)
}
pub
fn
update_layer_except_size
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
layer_properties
:
LayerProperties
)
{
layer
.
extra_data
.
borrow_mut
(
)
.
epoch
=
layer_properties
.
epoch
;
layer
.
extra_data
.
borrow_mut
(
)
.
scroll_policy
=
layer_properties
.
scroll_policy
;
layer
.
extra_data
.
borrow_mut
(
)
.
background_color
=
layer_properties
.
background_color
;
layer
.
contents_changed
(
)
;
}
pub
fn
update_layer
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
layer_properties
:
LayerProperties
)
{
layer
.
resize
(
Size2D
:
:
from_untyped
(
&
layer_properties
.
rect
.
size
)
)
;
events
:
:
handle_scroll_event
(
layer
.
clone
(
)
TypedPoint2D
(
0f32
0f32
)
TypedPoint2D
(
-
1f32
-
1f32
)
)
;
CompositorData
:
:
update_layer_except_size
(
layer
layer_properties
)
;
}
pub
fn
find_layer_with_pipeline_and_layer_id
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
pipeline_id
:
PipelineId
layer_id
:
LayerId
)
-
>
Option
<
Rc
<
Layer
<
CompositorData
>
>
>
{
if
layer
.
extra_data
.
borrow
(
)
.
pipeline
.
id
=
=
pipeline_id
&
&
layer
.
extra_data
.
borrow
(
)
.
id
=
=
layer_id
{
return
Some
(
layer
.
clone
(
)
)
;
}
for
kid
in
layer
.
children
(
)
.
iter
(
)
{
match
CompositorData
:
:
find_layer_with_pipeline_and_layer_id
(
kid
.
clone
(
)
pipeline_id
layer_id
)
{
v
Some
(
_
)
=
>
{
return
v
;
}
None
=
>
{
}
}
}
return
None
;
}
pub
fn
add_buffers
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
new_buffers
:
Box
<
LayerBufferSet
>
epoch
:
Epoch
)
-
>
bool
{
if
layer
.
extra_data
.
borrow
(
)
.
epoch
!
=
epoch
{
debug
!
(
"
add_buffers
:
compositor
epoch
mismatch
:
{
:
?
}
!
=
{
:
?
}
id
:
{
:
?
}
"
layer
.
extra_data
.
borrow
(
)
.
epoch
epoch
layer
.
extra_data
.
borrow
(
)
.
pipeline
.
id
)
;
let
msg
=
UnusedBufferMsg
(
new_buffers
.
buffers
)
;
let
_
=
layer
.
extra_data
.
borrow
(
)
.
pipeline
.
render_chan
.
send_opt
(
msg
)
;
return
false
;
}
{
for
buffer
in
new_buffers
.
buffers
.
into_iter
(
)
.
rev
(
)
{
layer
.
add_buffer
(
buffer
)
;
}
let
unused_buffers
=
layer
.
collect_unused_buffers
(
)
;
if
!
unused_buffers
.
is_empty
(
)
{
let
msg
=
UnusedBufferMsg
(
unused_buffers
)
;
let
_
=
layer
.
extra_data
.
borrow
(
)
.
pipeline
.
render_chan
.
send_opt
(
msg
)
;
}
}
return
true
;
}
fn
clear
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
)
{
let
mut
buffers
=
layer
.
collect_buffers
(
)
;
if
!
buffers
.
is_empty
(
)
{
for
buffer
in
buffers
.
iter_mut
(
)
{
buffer
.
mark_wont_leak
(
)
}
let
_
=
layer
.
extra_data
.
borrow
(
)
.
pipeline
.
render_chan
.
send_opt
(
UnusedBufferMsg
(
buffers
)
)
;
}
}
pub
fn
clear_all_tiles
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
)
{
CompositorData
:
:
clear
(
layer
.
clone
(
)
)
;
for
kid
in
layer
.
children
(
)
.
iter
(
)
{
CompositorData
:
:
clear_all_tiles
(
kid
.
clone
(
)
)
;
}
}
pub
fn
forget_all_tiles
(
layer
:
Rc
<
Layer
<
CompositorData
>
>
)
{
let
tiles
=
layer
.
collect_buffers
(
)
;
for
tile
in
tiles
.
into_iter
(
)
{
let
mut
tile
=
tile
;
tile
.
mark_wont_leak
(
)
}
for
kid
in
layer
.
children
(
)
.
iter
(
)
{
CompositorData
:
:
forget_all_tiles
(
kid
.
clone
(
)
)
;
}
}
}
