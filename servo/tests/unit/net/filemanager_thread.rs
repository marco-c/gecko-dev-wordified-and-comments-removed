use
ipc_channel
:
:
ipc
:
:
{
self
IpcSender
}
;
use
net
:
:
filemanager_thread
:
:
FileManagerThreadFactory
;
use
net_traits
:
:
filemanager_thread
:
:
{
FileManagerThreadMsg
FileManagerThreadError
}
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
Read
;
use
std
:
:
path
:
:
PathBuf
;
#
[
test
]
fn
test_filemanager
(
)
{
let
chan
:
IpcSender
<
FileManagerThreadMsg
>
=
FileManagerThreadFactory
:
:
new
(
)
;
let
mut
handler
=
File
:
:
open
(
"
test
.
txt
"
)
.
expect
(
"
test
.
txt
is
stolen
"
)
;
let
mut
test_file_content
=
vec
!
[
]
;
handler
.
read_to_end
(
&
mut
test_file_content
)
.
expect
(
"
Read
tests
/
unit
/
net
/
test
.
txt
error
"
)
;
{
let
(
tx
rx
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
chan
.
send
(
FileManagerThreadMsg
:
:
SelectFile
(
tx
)
)
.
unwrap
(
)
;
let
selected
=
rx
.
recv
(
)
.
expect
(
"
File
manager
channel
is
broken
"
)
.
expect
(
"
The
file
manager
failed
to
find
test
.
txt
"
)
;
assert
!
(
selected
.
filename
=
=
PathBuf
:
:
from
(
"
test
.
txt
"
)
)
;
assert
!
(
selected
.
type_string
=
=
"
text
/
plain
"
.
to_string
(
)
)
;
{
let
(
tx2
rx2
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
chan
.
send
(
FileManagerThreadMsg
:
:
ReadFile
(
tx2
selected
.
id
.
clone
(
)
)
)
.
unwrap
(
)
;
let
msg
=
rx2
.
recv
(
)
.
expect
(
"
File
manager
channel
is
broken
"
)
;
let
vec
=
msg
.
expect
(
"
File
manager
reading
failure
is
unexpected
"
)
;
assert
!
(
test_file_content
=
=
vec
"
Read
content
differs
"
)
;
}
chan
.
send
(
FileManagerThreadMsg
:
:
DeleteFileID
(
selected
.
id
.
clone
(
)
)
)
.
unwrap
(
)
;
{
let
(
tx2
rx2
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
chan
.
send
(
FileManagerThreadMsg
:
:
ReadFile
(
tx2
selected
.
id
.
clone
(
)
)
)
.
unwrap
(
)
;
let
msg
=
rx2
.
recv
(
)
.
expect
(
"
File
manager
channel
is
broken
"
)
;
match
msg
{
Err
(
FileManagerThreadError
:
:
ReadFileError
)
=
>
{
}
other
=
>
{
assert
!
(
false
"
Get
unexpected
response
after
deleting
the
id
:
{
:
?
}
"
other
)
;
}
}
}
}
let
_
=
chan
.
send
(
FileManagerThreadMsg
:
:
Exit
)
;
{
let
(
tx
rx
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
let
_
=
chan
.
send
(
FileManagerThreadMsg
:
:
SelectFile
(
tx
)
)
;
assert
!
(
rx
.
try_recv
(
)
.
is_err
(
)
"
The
thread
should
not
respond
normally
after
exited
"
)
;
}
}
