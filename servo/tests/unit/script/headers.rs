use
script
:
:
dom
:
:
bindings
:
:
str
:
:
ByteString
;
use
script
:
:
dom
:
:
headers
;
#
[
test
]
fn
test_normalize_empty_bytestring
(
)
{
let
empty_bytestring
=
ByteString
:
:
new
(
vec
!
[
]
)
;
let
actual
=
headers
:
:
normalize_value
(
empty_bytestring
)
;
let
expected
=
ByteString
:
:
new
(
vec
!
[
]
)
;
assert_eq
!
(
actual
expected
)
;
}
#
[
test
]
fn
test_normalize_all_whitespace_bytestring
(
)
{
let
all_whitespace_bytestring
=
ByteString
:
:
new
(
vec
!
[
b
'
\
t
'
b
'
\
n
'
b
'
\
r
'
b
'
'
]
)
;
let
actual
=
headers
:
:
normalize_value
(
all_whitespace_bytestring
)
;
let
expected
=
ByteString
:
:
new
(
vec
!
[
]
)
;
assert_eq
!
(
actual
expected
)
;
}
#
[
test
]
fn
test_normalize_non_empty_no_whitespace_bytestring
(
)
{
let
no_whitespace_bytestring
=
ByteString
:
:
new
(
vec
!
[
b
'
S
'
b
'
!
'
]
)
;
let
actual
=
headers
:
:
normalize_value
(
no_whitespace_bytestring
)
;
let
expected
=
ByteString
:
:
new
(
vec
!
[
b
'
S
'
b
'
!
'
]
)
;
assert_eq
!
(
actual
expected
)
;
}
#
[
test
]
fn
test_normalize_non_empty_leading_whitespace_bytestring
(
)
{
let
leading_whitespace_bytestring
=
ByteString
:
:
new
(
vec
!
[
b
'
\
t
'
b
'
\
n
'
b
'
'
b
'
\
r
'
b
'
S
'
b
'
!
'
]
)
;
let
actual
=
headers
:
:
normalize_value
(
leading_whitespace_bytestring
)
;
let
expected
=
ByteString
:
:
new
(
vec
!
[
b
'
S
'
b
'
!
'
]
)
;
assert_eq
!
(
actual
expected
)
;
}
#
[
test
]
fn
test_normalize_non_empty_no_leading_whitespace_trailing_whitespace_bytestring
(
)
{
let
trailing_whitespace_bytestring
=
ByteString
:
:
new
(
vec
!
[
b
'
S
'
b
'
!
'
b
'
\
t
'
b
'
\
n
'
b
'
'
b
'
\
r
'
]
)
;
let
actual
=
headers
:
:
normalize_value
(
trailing_whitespace_bytestring
)
;
let
expected
=
ByteString
:
:
new
(
vec
!
[
b
'
S
'
b
'
!
'
]
)
;
assert_eq
!
(
actual
expected
)
;
}
#
[
test
]
fn
test_normalize_non_empty_leading_and_trailing_whitespace_bytestring
(
)
{
let
whitespace_sandwich_bytestring
=
ByteString
:
:
new
(
vec
!
[
b
'
\
t
'
b
'
\
n
'
b
'
'
b
'
\
r
'
b
'
S
'
b
'
!
'
b
'
\
t
'
b
'
\
n
'
b
'
'
b
'
\
r
'
]
)
;
let
actual
=
headers
:
:
normalize_value
(
whitespace_sandwich_bytestring
)
;
let
expected
=
ByteString
:
:
new
(
vec
!
[
b
'
S
'
b
'
!
'
]
)
;
assert_eq
!
(
actual
expected
)
;
}
#
[
test
]
fn
test_normalize_non_empty_leading_trailing_and_internal_whitespace_bytestring
(
)
{
let
whitespace_bigmac_bytestring
=
ByteString
:
:
new
(
vec
!
[
b
'
\
t
'
b
'
\
n
'
b
'
'
b
'
\
r
'
b
'
S
'
b
'
\
t
'
b
'
\
n
'
b
'
'
b
'
\
r
'
b
'
!
'
b
'
\
t
'
b
'
\
n
'
b
'
'
b
'
\
r
'
]
)
;
let
actual
=
headers
:
:
normalize_value
(
whitespace_bigmac_bytestring
)
;
let
expected
=
ByteString
:
:
new
(
vec
!
[
b
'
S
'
b
'
\
t
'
b
'
\
n
'
b
'
'
b
'
\
r
'
b
'
!
'
]
)
;
assert_eq
!
(
actual
expected
)
;
}
