use
std
:
:
marker
:
:
PhantomData
;
use
std
:
:
mem
:
:
{
forget
transmute
}
;
use
std
:
:
ptr
;
use
std
:
:
sync
:
:
Arc
;
pub
unsafe
trait
HasArcFFI
where
Self
:
Sized
{
type
FFIType
:
Sized
;
fn
with
<
F
Output
>
(
raw
:
Borrowed
<
Self
:
:
FFIType
>
cb
:
F
)
-
>
Output
where
F
:
FnOnce
(
&
Arc
<
Self
>
)
-
>
Output
{
Self
:
:
maybe_with
(
raw
|
opt
|
cb
(
opt
.
unwrap
(
)
)
)
}
fn
maybe_with
<
F
Output
>
(
maybe_raw
:
Borrowed
<
Self
:
:
FFIType
>
cb
:
F
)
-
>
Output
where
F
:
FnOnce
(
Option
<
&
Arc
<
Self
>
>
)
-
>
Output
{
cb
(
Self
:
:
borrowed_as
(
&
maybe_raw
)
)
}
fn
into
(
ptr
:
Strong
<
Self
:
:
FFIType
>
)
-
>
Arc
<
Self
>
{
assert
!
(
!
ptr
.
is_null
(
)
)
;
unsafe
{
transmute
(
ptr
)
}
}
fn
borrowed_as
<
'
a
>
(
ptr
:
&
'
a
Borrowed
<
'
a
Self
:
:
FFIType
>
)
-
>
Option
<
&
'
a
Arc
<
Self
>
>
{
unsafe
{
if
ptr
.
is_null
(
)
{
None
}
else
{
Some
(
transmute
:
:
<
&
Borrowed
<
_
>
&
Arc
<
_
>
>
(
ptr
)
)
}
}
}
fn
from_arc
(
owned
:
Arc
<
Self
>
)
-
>
Strong
<
Self
:
:
FFIType
>
{
unsafe
{
transmute
(
owned
)
}
}
unsafe
fn
addref
(
ptr
:
Borrowed
<
Self
:
:
FFIType
>
)
{
Self
:
:
with
(
ptr
|
arc
|
forget
(
arc
.
clone
(
)
)
)
;
}
unsafe
fn
release
(
ptr
:
Borrowed
<
Self
:
:
FFIType
>
)
{
if
let
Some
(
arc
)
=
Self
:
:
borrowed_as
(
&
ptr
)
{
let
_
:
Arc
<
_
>
=
ptr
:
:
read
(
arc
as
*
const
Arc
<
_
>
)
;
}
}
fn
to_borrowed
<
'
a
>
(
arc
:
&
'
a
Arc
<
Self
>
)
-
>
Borrowed
<
'
a
Self
:
:
FFIType
>
{
let
borrowedptr
=
arc
as
*
const
Arc
<
Self
>
as
*
const
Borrowed
<
'
a
Self
:
:
FFIType
>
;
unsafe
{
ptr
:
:
read
(
borrowedptr
)
}
}
fn
null_strong
(
)
-
>
Strong
<
Self
:
:
FFIType
>
{
unsafe
{
transmute
(
ptr
:
:
null
:
:
<
Self
:
:
FFIType
>
(
)
)
}
}
}
#
[
repr
(
C
)
]
pub
struct
Borrowed
<
'
a
T
:
'
a
>
{
ptr
:
*
const
T
_marker
:
PhantomData
<
&
'
a
T
>
}
impl
<
'
a
T
>
Copy
for
Borrowed
<
'
a
T
>
{
}
impl
<
'
a
T
>
Clone
for
Borrowed
<
'
a
T
>
{
fn
clone
(
&
self
)
-
>
Self
{
*
self
}
}
impl
<
'
a
T
>
Borrowed
<
'
a
T
>
{
pub
fn
is_null
(
&
self
)
-
>
bool
{
self
.
ptr
=
=
ptr
:
:
null
(
)
}
}
#
[
repr
(
C
)
]
pub
struct
Strong
<
T
>
{
ptr
:
*
const
T
_marker
:
PhantomData
<
T
>
}
impl
<
T
>
Strong
<
T
>
{
pub
fn
is_null
(
&
self
)
-
>
bool
{
self
.
ptr
=
=
ptr
:
:
null
(
)
}
}
