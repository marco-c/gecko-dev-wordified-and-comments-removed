use
bindings
:
:
*
;
use
heapsize
:
:
HeapSizeOf
;
use
std
:
:
fmt
:
:
{
self
Debug
}
;
macro_rules
!
define_holder_arc
{
(
arc_type
:
ident
name
:
ident
holder_type
:
ident
)
=
>
(
#
[
derive
(
PartialEq
)
]
pub
struct
arc_type
{
ptr
:
*
mut
holder_type
}
impl
arc_type
{
pub
fn
new
(
data
:
*
mut
holder_type
)
-
>
arc_type
{
debug_assert
!
(
!
data
.
is_null
(
)
)
;
unsafe
{
concat_idents
!
(
Gecko_AddRef
name
ArbitraryThread
)
(
data
)
;
}
arc_type
{
ptr
:
data
}
}
pub
fn
as_raw
(
&
self
)
-
>
*
mut
holder_type
{
self
.
ptr
}
}
unsafe
impl
Send
for
arc_type
{
}
unsafe
impl
Sync
for
arc_type
{
}
impl
Clone
for
arc_type
{
fn
clone
(
&
self
)
-
>
arc_type
{
arc_type
:
:
new
(
self
.
ptr
)
}
}
impl
Drop
for
arc_type
{
fn
drop
(
&
mut
self
)
{
unsafe
{
concat_idents
!
(
Gecko_Release
name
ArbitraryThread
)
(
self
.
ptr
)
;
}
}
}
impl
HeapSizeOf
for
arc_type
{
fn
heap_size_of_children
(
&
self
)
-
>
usize
{
0
}
}
impl
Debug
for
arc_type
{
fn
fmt
(
&
self
f
:
&
mut
fmt
:
:
Formatter
)
-
>
fmt
:
:
Result
{
write
!
(
f
stringify
!
(
name
)
)
}
}
)
}
define_holder_arc
!
(
GeckoArcPrincipal
Principal
ThreadSafePrincipalHolder
)
;
define_holder_arc
!
(
GeckoArcURI
URI
ThreadSafeURIHolder
)
;
