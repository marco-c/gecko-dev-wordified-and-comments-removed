use
types
:
:
cef_base_t
;
use
libc
:
:
{
self
c_int
c_void
size_t
}
;
use
std
:
:
mem
;
use
std
:
:
slice
;
use
std
:
:
str
;
pub
trait
Downcast
<
Class
>
{
fn
downcast
(
&
self
)
-
>
&
Class
;
}
pub
fn
slice_to_str
<
F
>
(
s
:
*
const
u8
l
:
usize
f
:
F
)
-
>
c_int
where
F
:
FnOnce
(
&
str
)
-
>
c_int
{
unsafe
{
let
s
=
slice
:
:
from_raw_parts
(
s
l
)
;
str
:
:
from_utf8
(
s
)
.
map
(
f
)
.
unwrap_or
(
0
)
}
}
pub
unsafe
fn
create_cef_object
<
Base
Extra
>
(
size
:
size_t
)
-
>
*
mut
Base
{
let
object
=
libc
:
:
calloc
(
1
(
mem
:
:
size_of
:
:
<
Base
>
(
)
+
mem
:
:
size_of
:
:
<
Extra
>
(
)
)
as
u64
)
as
*
mut
cef_base_t
;
(
*
object
)
.
size
=
size
;
(
*
object
)
.
add_ref
=
Some
(
servo_add_ref
as
extern
"
C
"
fn
(
*
mut
cef_base_t
)
-
>
c_int
)
;
(
*
object
)
.
release
=
Some
(
servo_release
as
extern
"
C
"
fn
(
*
mut
cef_base_t
)
-
>
c_int
)
;
*
ref_count
(
object
)
=
1
;
object
as
*
mut
Base
}
unsafe
fn
ref_count
(
object
:
*
mut
cef_base_t
)
-
>
*
mut
usize
{
(
object
as
*
mut
u8
)
.
offset
(
(
*
object
)
.
size
as
isize
)
as
*
mut
usize
}
extern
"
C
"
fn
servo_add_ref
(
object
:
*
mut
cef_base_t
)
-
>
c_int
{
unsafe
{
let
count
=
ref_count
(
object
)
;
*
count
+
=
1
;
*
count
as
c_int
}
}
extern
"
C
"
fn
servo_release
(
object
:
*
mut
cef_base_t
)
-
>
c_int
{
unsafe
{
let
count
=
ref_count
(
object
)
;
*
count
-
=
1
;
let
new_count
=
*
count
;
if
new_count
=
=
0
{
servo_free
(
object
)
;
}
(
new_count
=
=
0
)
as
c_int
}
}
unsafe
fn
servo_free
(
object
:
*
mut
cef_base_t
)
{
libc
:
:
free
(
object
as
*
mut
c_void
)
;
}
pub
unsafe
fn
add_ref
(
c_object
:
*
mut
cef_base_t
)
{
(
(
*
c_object
)
.
add_ref
.
unwrap
(
)
)
(
c_object
)
;
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
servo_test
(
)
-
>
c_int
{
1
}
