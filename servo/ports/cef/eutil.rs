use
types
:
:
cef_base_t
;
use
libc
:
:
{
mod
c_int
c_void
size_t
}
;
use
std
:
:
mem
;
use
std
:
:
slice
;
use
std
:
:
str
;
pub
trait
Downcast
<
Class
>
{
fn
downcast
(
&
self
)
-
>
&
Class
;
}
pub
fn
slice_to_str
(
s
:
*
const
u8
l
:
uint
f
:
|
&
str
|
-
>
c_int
)
-
>
c_int
{
unsafe
{
slice
:
:
raw
:
:
buf_as_slice
(
s
l
|
result
|
{
str
:
:
from_utf8
(
result
)
.
map
(
|
s
|
f
(
s
)
)
.
unwrap_or
(
0
)
}
)
}
}
/
/
/
Creates
a
new
raw
CEF
object
of
the
given
type
and
sets
up
its
reference
counting
machinery
.
/
/
/
All
fields
are
initialized
to
zero
.
It
is
the
caller
'
s
responsibility
to
ensure
that
the
given
/
/
/
type
is
a
CEF
type
with
cef_base_t
as
its
first
member
.
pub
unsafe
fn
create_cef_object
<
Base
Extra
>
(
size
:
size_t
)
-
>
*
mut
Base
{
let
object
=
libc
:
:
calloc
(
1
(
mem
:
:
size_of
:
:
<
Base
>
(
)
+
mem
:
:
size_of
:
:
<
Extra
>
(
)
)
as
u64
)
as
*
mut
cef_base_t
;
(
*
object
)
.
size
=
size
;
(
*
object
)
.
add_ref
=
Some
(
servo_add_ref
)
;
(
*
object
)
.
release
=
Some
(
servo_release
)
;
*
ref_count
(
object
)
=
1
;
object
as
*
mut
Base
}
/
/
/
Returns
a
pointer
to
the
Servo
-
specific
reference
count
for
the
given
object
.
This
only
works
/
/
/
on
objects
that
Servo
created
!
unsafe
fn
ref_count
(
object
:
*
mut
cef_base_t
)
-
>
*
mut
uint
{
/
/
The
reference
count
should
be
the
first
field
of
the
extra
data
.
(
object
as
*
mut
u8
)
.
offset
(
(
*
object
)
.
size
as
int
)
as
*
mut
uint
}
/
/
/
Increments
the
reference
count
on
a
CEF
object
.
This
only
works
on
objects
that
Servo
created
!
extern
"
C
"
fn
servo_add_ref
(
object
:
*
mut
cef_base_t
)
-
>
c_int
{
unsafe
{
let
count
=
ref_count
(
object
)
;
*
count
+
=
1
;
*
count
as
c_int
}
}
/
/
/
Decrements
the
reference
count
on
a
CEF
object
.
If
zero
frees
it
.
This
only
works
on
objects
/
/
/
that
Servo
created
!
extern
"
C
"
fn
servo_release
(
object
:
*
mut
cef_base_t
)
-
>
c_int
{
unsafe
{
let
count
=
ref_count
(
object
)
;
*
count
-
=
1
;
let
new_count
=
*
count
;
if
new_count
=
=
0
{
servo_free
(
object
)
;
}
(
new_count
=
=
0
)
as
c_int
}
}
unsafe
fn
servo_free
(
object
:
*
mut
cef_base_t
)
{
libc
:
:
free
(
object
as
*
mut
c_void
)
;
}
pub
unsafe
fn
add_ref
(
c_object
:
*
mut
cef_base_t
)
{
(
(
*
c_object
)
.
add_ref
.
unwrap
(
)
)
(
c_object
)
;
}
