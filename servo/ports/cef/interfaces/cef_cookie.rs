#
!
[
allow
(
non_snake_case
unused_imports
)
]
use
eutil
;
use
interfaces
;
use
types
;
use
wrappers
:
:
CefWrap
;
use
libc
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
ptr
;
#
[
repr
(
C
)
]
pub
struct
_cef_cookie_manager_t
{
pub
base
:
types
:
:
cef_base_t
pub
set_supported_schemes
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_cookie_manager_t
schemes
:
types
:
:
cef_string_list_t
)
-
>
(
)
>
pub
visit_all_cookies
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_cookie_manager_t
visitor
:
*
mut
interfaces
:
:
cef_cookie_visitor_t
)
-
>
libc
:
:
c_int
>
pub
visit_url_cookies
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_cookie_manager_t
url
:
*
const
types
:
:
cef_string_t
includeHttpOnly
:
libc
:
:
c_int
visitor
:
*
mut
interfaces
:
:
cef_cookie_visitor_t
)
-
>
libc
:
:
c_int
>
pub
set_cookie
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_cookie_manager_t
url
:
*
const
types
:
:
cef_string_t
cookie
:
*
const
interfaces
:
:
cef_cookie_t
)
-
>
libc
:
:
c_int
>
pub
delete_cookies
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_cookie_manager_t
url
:
*
const
types
:
:
cef_string_t
cookie_name
:
*
const
types
:
:
cef_string_t
)
-
>
libc
:
:
c_int
>
pub
set_storage_path
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_cookie_manager_t
path
:
*
const
types
:
:
cef_string_t
persist_session_cookies
:
libc
:
:
c_int
)
-
>
libc
:
:
c_int
>
pub
flush_store
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_cookie_manager_t
callback
:
*
mut
interfaces
:
:
cef_completion_callback_t
)
-
>
libc
:
:
c_int
>
pub
ref_count
:
uint
pub
extra
:
u8
}
pub
type
cef_cookie_manager_t
=
_cef_cookie_manager_t
;
pub
struct
CefCookieManager
{
c_object
:
*
mut
cef_cookie_manager_t
}
impl
Clone
for
CefCookieManager
{
fn
clone
(
&
self
)
-
>
CefCookieManager
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
{
(
(
*
self
.
c_object
)
.
base
.
add_ref
.
unwrap
(
)
)
(
&
mut
(
*
self
.
c_object
)
.
base
)
;
}
CefCookieManager
{
c_object
:
self
.
c_object
}
}
}
}
impl
Drop
for
CefCookieManager
{
fn
drop
(
&
mut
self
)
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
{
(
(
*
self
.
c_object
)
.
base
.
release
.
unwrap
(
)
)
(
&
mut
(
*
self
.
c_object
)
.
base
)
;
}
}
}
}
impl
CefCookieManager
{
pub
unsafe
fn
from_c_object
(
c_object
:
*
mut
cef_cookie_manager_t
)
-
>
CefCookieManager
{
CefCookieManager
{
c_object
:
c_object
}
}
pub
unsafe
fn
from_c_object_addref
(
c_object
:
*
mut
cef_cookie_manager_t
)
-
>
CefCookieManager
{
if
!
c_object
.
is_null
(
)
{
(
(
*
c_object
)
.
base
.
add_ref
.
unwrap
(
)
)
(
&
mut
(
*
c_object
)
.
base
)
;
}
CefCookieManager
{
c_object
:
c_object
}
}
pub
fn
c_object
(
&
self
)
-
>
*
mut
cef_cookie_manager_t
{
self
.
c_object
}
pub
fn
c_object_addrefed
(
&
self
)
-
>
*
mut
cef_cookie_manager_t
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
{
eutil
:
:
add_ref
(
self
.
c_object
as
*
mut
types
:
:
cef_base_t
)
;
}
self
.
c_object
}
}
pub
fn
is_null_cef_object
(
&
self
)
-
>
bool
{
self
.
c_object
.
is_null
(
)
}
pub
fn
is_not_null_cef_object
(
&
self
)
-
>
bool
{
!
self
.
c_object
.
is_null
(
)
}
pub
fn
set_supported_schemes
(
&
self
schemes
:
Vec
<
String
>
)
-
>
(
)
{
if
self
.
c_object
.
is_null
(
)
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
set_supported_schemes
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
schemes
)
)
)
}
}
pub
fn
visit_all_cookies
(
&
self
visitor
:
interfaces
:
:
CefCookieVisitor
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
visit_all_cookies
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
visitor
)
)
)
}
}
pub
fn
visit_url_cookies
(
&
self
url
:
&
[
u16
]
includeHttpOnly
:
libc
:
:
c_int
visitor
:
interfaces
:
:
CefCookieVisitor
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
visit_url_cookies
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
url
)
CefWrap
:
:
to_c
(
includeHttpOnly
)
CefWrap
:
:
to_c
(
visitor
)
)
)
}
}
pub
fn
set_cookie
(
&
self
url
:
&
[
u16
]
cookie
:
&
interfaces
:
:
CefCookie
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
set_cookie
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
url
)
CefWrap
:
:
to_c
(
cookie
)
)
)
}
}
pub
fn
delete_cookies
(
&
self
url
:
&
[
u16
]
cookie_name
:
&
[
u16
]
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
delete_cookies
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
url
)
CefWrap
:
:
to_c
(
cookie_name
)
)
)
}
}
pub
fn
set_storage_path
(
&
self
path
:
&
[
u16
]
persist_session_cookies
:
libc
:
:
c_int
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
set_storage_path
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
path
)
CefWrap
:
:
to_c
(
persist_session_cookies
)
)
)
}
}
pub
fn
flush_store
(
&
self
callback
:
interfaces
:
:
CefCompletionCallback
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
flush_store
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
callback
)
)
)
}
}
pub
fn
get_global_manager
(
)
-
>
interfaces
:
:
CefCookieManager
{
unsafe
{
CefWrap
:
:
to_rust
(
:
:
cookie
:
:
cef_cookie_manager_get_global_manager
(
)
)
}
}
pub
fn
create_manager
(
path
:
&
[
u16
]
persist_session_cookies
:
libc
:
:
c_int
)
-
>
interfaces
:
:
CefCookieManager
{
unsafe
{
CefWrap
:
:
to_rust
(
:
:
cookie
:
:
cef_cookie_manager_create_manager
(
CefWrap
:
:
to_c
(
path
)
CefWrap
:
:
to_c
(
persist_session_cookies
)
)
)
}
}
}
impl
CefWrap
<
*
mut
cef_cookie_manager_t
>
for
CefCookieManager
{
fn
to_c
(
rust_object
:
CefCookieManager
)
-
>
*
mut
cef_cookie_manager_t
{
rust_object
.
c_object_addrefed
(
)
}
unsafe
fn
to_rust
(
c_object
:
*
mut
cef_cookie_manager_t
)
-
>
CefCookieManager
{
CefCookieManager
:
:
from_c_object_addref
(
c_object
)
}
}
impl
CefWrap
<
*
mut
cef_cookie_manager_t
>
for
Option
<
CefCookieManager
>
{
fn
to_c
(
rust_object
:
Option
<
CefCookieManager
>
)
-
>
*
mut
cef_cookie_manager_t
{
match
rust_object
{
None
=
>
ptr
:
:
null_mut
(
)
Some
(
rust_object
)
=
>
rust_object
.
c_object_addrefed
(
)
}
}
unsafe
fn
to_rust
(
c_object
:
*
mut
cef_cookie_manager_t
)
-
>
Option
<
CefCookieManager
>
{
if
c_object
.
is_null
(
)
{
None
}
else
{
Some
(
CefCookieManager
:
:
from_c_object_addref
(
c_object
)
)
}
}
}
#
[
repr
(
C
)
]
pub
struct
_cef_cookie_visitor_t
{
pub
base
:
types
:
:
cef_base_t
pub
visit
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_cookie_visitor_t
cookie
:
*
const
interfaces
:
:
cef_cookie_t
count
:
libc
:
:
c_int
total
:
libc
:
:
c_int
deleteCookie
:
*
mut
libc
:
:
c_int
)
-
>
libc
:
:
c_int
>
pub
ref_count
:
uint
pub
extra
:
u8
}
pub
type
cef_cookie_visitor_t
=
_cef_cookie_visitor_t
;
pub
struct
CefCookieVisitor
{
c_object
:
*
mut
cef_cookie_visitor_t
}
impl
Clone
for
CefCookieVisitor
{
fn
clone
(
&
self
)
-
>
CefCookieVisitor
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
{
(
(
*
self
.
c_object
)
.
base
.
add_ref
.
unwrap
(
)
)
(
&
mut
(
*
self
.
c_object
)
.
base
)
;
}
CefCookieVisitor
{
c_object
:
self
.
c_object
}
}
}
}
impl
Drop
for
CefCookieVisitor
{
fn
drop
(
&
mut
self
)
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
{
(
(
*
self
.
c_object
)
.
base
.
release
.
unwrap
(
)
)
(
&
mut
(
*
self
.
c_object
)
.
base
)
;
}
}
}
}
impl
CefCookieVisitor
{
pub
unsafe
fn
from_c_object
(
c_object
:
*
mut
cef_cookie_visitor_t
)
-
>
CefCookieVisitor
{
CefCookieVisitor
{
c_object
:
c_object
}
}
pub
unsafe
fn
from_c_object_addref
(
c_object
:
*
mut
cef_cookie_visitor_t
)
-
>
CefCookieVisitor
{
if
!
c_object
.
is_null
(
)
{
(
(
*
c_object
)
.
base
.
add_ref
.
unwrap
(
)
)
(
&
mut
(
*
c_object
)
.
base
)
;
}
CefCookieVisitor
{
c_object
:
c_object
}
}
pub
fn
c_object
(
&
self
)
-
>
*
mut
cef_cookie_visitor_t
{
self
.
c_object
}
pub
fn
c_object_addrefed
(
&
self
)
-
>
*
mut
cef_cookie_visitor_t
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
{
eutil
:
:
add_ref
(
self
.
c_object
as
*
mut
types
:
:
cef_base_t
)
;
}
self
.
c_object
}
}
pub
fn
is_null_cef_object
(
&
self
)
-
>
bool
{
self
.
c_object
.
is_null
(
)
}
pub
fn
is_not_null_cef_object
(
&
self
)
-
>
bool
{
!
self
.
c_object
.
is_null
(
)
}
pub
fn
visit
(
&
self
cookie
:
&
interfaces
:
:
CefCookie
count
:
libc
:
:
c_int
total
:
libc
:
:
c_int
deleteCookie
:
&
mut
libc
:
:
c_int
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
visit
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
cookie
)
CefWrap
:
:
to_c
(
count
)
CefWrap
:
:
to_c
(
total
)
CefWrap
:
:
to_c
(
deleteCookie
)
)
)
}
}
}
impl
CefWrap
<
*
mut
cef_cookie_visitor_t
>
for
CefCookieVisitor
{
fn
to_c
(
rust_object
:
CefCookieVisitor
)
-
>
*
mut
cef_cookie_visitor_t
{
rust_object
.
c_object_addrefed
(
)
}
unsafe
fn
to_rust
(
c_object
:
*
mut
cef_cookie_visitor_t
)
-
>
CefCookieVisitor
{
CefCookieVisitor
:
:
from_c_object_addref
(
c_object
)
}
}
impl
CefWrap
<
*
mut
cef_cookie_visitor_t
>
for
Option
<
CefCookieVisitor
>
{
fn
to_c
(
rust_object
:
Option
<
CefCookieVisitor
>
)
-
>
*
mut
cef_cookie_visitor_t
{
match
rust_object
{
None
=
>
ptr
:
:
null_mut
(
)
Some
(
rust_object
)
=
>
rust_object
.
c_object_addrefed
(
)
}
}
unsafe
fn
to_rust
(
c_object
:
*
mut
cef_cookie_visitor_t
)
-
>
Option
<
CefCookieVisitor
>
{
if
c_object
.
is_null
(
)
{
None
}
else
{
Some
(
CefCookieVisitor
:
:
from_c_object_addref
(
c_object
)
)
}
}
}
