#
!
[
allow
(
non_snake_case
unused_imports
)
]
use
eutil
;
use
interfaces
;
use
types
;
use
wrappers
:
:
CefWrap
;
use
libc
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
mem
;
use
std
:
:
ptr
;
#
[
repr
(
C
)
]
pub
struct
_cef_read_handler_t
{
pub
base
:
types
:
:
cef_base_t
pub
read
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_read_handler_t
ptr
:
*
mut
(
)
size
:
libc
:
:
size_t
n
:
libc
:
:
size_t
)
-
>
libc
:
:
size_t
>
pub
seek
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_read_handler_t
offset
:
i64
whence
:
libc
:
:
c_int
)
-
>
libc
:
:
c_int
>
pub
tell
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_read_handler_t
)
-
>
i64
>
pub
eof
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_read_handler_t
)
-
>
libc
:
:
c_int
>
pub
may_block
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_read_handler_t
)
-
>
libc
:
:
c_int
>
pub
ref_count
:
u32
pub
extra
:
u8
}
pub
type
cef_read_handler_t
=
_cef_read_handler_t
;
pub
struct
CefReadHandler
{
c_object
:
*
mut
cef_read_handler_t
}
impl
Clone
for
CefReadHandler
{
fn
clone
(
&
self
)
-
>
CefReadHandler
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
(
(
*
self
.
c_object
)
.
base
.
add_ref
.
unwrap
(
)
)
(
&
mut
(
*
self
.
c_object
)
.
base
)
;
}
CefReadHandler
{
c_object
:
self
.
c_object
}
}
}
}
impl
Drop
for
CefReadHandler
{
fn
drop
(
&
mut
self
)
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
(
(
*
self
.
c_object
)
.
base
.
release
.
unwrap
(
)
)
(
&
mut
(
*
self
.
c_object
)
.
base
)
;
}
}
}
}
impl
CefReadHandler
{
pub
unsafe
fn
from_c_object
(
c_object
:
*
mut
cef_read_handler_t
)
-
>
CefReadHandler
{
CefReadHandler
{
c_object
:
c_object
}
}
pub
unsafe
fn
from_c_object_addref
(
c_object
:
*
mut
cef_read_handler_t
)
-
>
CefReadHandler
{
if
!
c_object
.
is_null
(
)
&
&
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
(
(
*
c_object
)
.
base
.
add_ref
.
unwrap
(
)
)
(
&
mut
(
*
c_object
)
.
base
)
;
}
CefReadHandler
{
c_object
:
c_object
}
}
pub
fn
c_object
(
&
self
)
-
>
*
mut
cef_read_handler_t
{
self
.
c_object
}
pub
fn
c_object_addrefed
(
&
self
)
-
>
*
mut
cef_read_handler_t
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
eutil
:
:
add_ref
(
self
.
c_object
as
*
mut
types
:
:
cef_base_t
)
;
}
self
.
c_object
}
}
pub
fn
is_null_cef_object
(
&
self
)
-
>
bool
{
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
}
pub
fn
is_not_null_cef_object
(
&
self
)
-
>
bool
{
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
}
pub
fn
read
(
&
self
ptr
:
&
mut
(
)
size
:
libc
:
:
size_t
n
:
libc
:
:
size_t
)
-
>
libc
:
:
size_t
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
read
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
ptr
)
CefWrap
:
:
to_c
(
size
)
CefWrap
:
:
to_c
(
n
)
)
)
}
}
pub
fn
seek
(
&
self
offset
:
i64
whence
:
libc
:
:
c_int
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
seek
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
offset
)
CefWrap
:
:
to_c
(
whence
)
)
)
}
}
pub
fn
tell
(
&
self
)
-
>
i64
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
tell
.
unwrap
(
)
)
(
self
.
c_object
)
)
}
}
pub
fn
eof
(
&
self
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
eof
.
unwrap
(
)
)
(
self
.
c_object
)
)
}
}
pub
fn
may_block
(
&
self
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
may_block
.
unwrap
(
)
)
(
self
.
c_object
)
)
}
}
}
impl
CefWrap
<
*
mut
cef_read_handler_t
>
for
CefReadHandler
{
fn
to_c
(
rust_object
:
CefReadHandler
)
-
>
*
mut
cef_read_handler_t
{
rust_object
.
c_object_addrefed
(
)
}
unsafe
fn
to_rust
(
c_object
:
*
mut
cef_read_handler_t
)
-
>
CefReadHandler
{
CefReadHandler
:
:
from_c_object_addref
(
c_object
)
}
}
impl
CefWrap
<
*
mut
cef_read_handler_t
>
for
Option
<
CefReadHandler
>
{
fn
to_c
(
rust_object
:
Option
<
CefReadHandler
>
)
-
>
*
mut
cef_read_handler_t
{
match
rust_object
{
None
=
>
ptr
:
:
null_mut
(
)
Some
(
rust_object
)
=
>
rust_object
.
c_object_addrefed
(
)
}
}
unsafe
fn
to_rust
(
c_object
:
*
mut
cef_read_handler_t
)
-
>
Option
<
CefReadHandler
>
{
if
c_object
.
is_null
(
)
&
&
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
None
}
else
{
Some
(
CefReadHandler
:
:
from_c_object_addref
(
c_object
)
)
}
}
}
#
[
repr
(
C
)
]
pub
struct
_cef_stream_reader_t
{
pub
base
:
types
:
:
cef_base_t
pub
read
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_stream_reader_t
ptr
:
*
mut
(
)
size
:
libc
:
:
size_t
n
:
libc
:
:
size_t
)
-
>
libc
:
:
size_t
>
pub
seek
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_stream_reader_t
offset
:
i64
whence
:
libc
:
:
c_int
)
-
>
libc
:
:
c_int
>
pub
tell
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_stream_reader_t
)
-
>
i64
>
pub
eof
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_stream_reader_t
)
-
>
libc
:
:
c_int
>
pub
may_block
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_stream_reader_t
)
-
>
libc
:
:
c_int
>
pub
ref_count
:
u32
pub
extra
:
u8
}
pub
type
cef_stream_reader_t
=
_cef_stream_reader_t
;
pub
struct
CefStreamReader
{
c_object
:
*
mut
cef_stream_reader_t
}
impl
Clone
for
CefStreamReader
{
fn
clone
(
&
self
)
-
>
CefStreamReader
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
(
(
*
self
.
c_object
)
.
base
.
add_ref
.
unwrap
(
)
)
(
&
mut
(
*
self
.
c_object
)
.
base
)
;
}
CefStreamReader
{
c_object
:
self
.
c_object
}
}
}
}
impl
Drop
for
CefStreamReader
{
fn
drop
(
&
mut
self
)
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
(
(
*
self
.
c_object
)
.
base
.
release
.
unwrap
(
)
)
(
&
mut
(
*
self
.
c_object
)
.
base
)
;
}
}
}
}
impl
CefStreamReader
{
pub
unsafe
fn
from_c_object
(
c_object
:
*
mut
cef_stream_reader_t
)
-
>
CefStreamReader
{
CefStreamReader
{
c_object
:
c_object
}
}
pub
unsafe
fn
from_c_object_addref
(
c_object
:
*
mut
cef_stream_reader_t
)
-
>
CefStreamReader
{
if
!
c_object
.
is_null
(
)
&
&
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
(
(
*
c_object
)
.
base
.
add_ref
.
unwrap
(
)
)
(
&
mut
(
*
c_object
)
.
base
)
;
}
CefStreamReader
{
c_object
:
c_object
}
}
pub
fn
c_object
(
&
self
)
-
>
*
mut
cef_stream_reader_t
{
self
.
c_object
}
pub
fn
c_object_addrefed
(
&
self
)
-
>
*
mut
cef_stream_reader_t
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
eutil
:
:
add_ref
(
self
.
c_object
as
*
mut
types
:
:
cef_base_t
)
;
}
self
.
c_object
}
}
pub
fn
is_null_cef_object
(
&
self
)
-
>
bool
{
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
}
pub
fn
is_not_null_cef_object
(
&
self
)
-
>
bool
{
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
}
pub
fn
read
(
&
self
ptr
:
&
mut
(
)
size
:
libc
:
:
size_t
n
:
libc
:
:
size_t
)
-
>
libc
:
:
size_t
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
read
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
ptr
)
CefWrap
:
:
to_c
(
size
)
CefWrap
:
:
to_c
(
n
)
)
)
}
}
pub
fn
seek
(
&
self
offset
:
i64
whence
:
libc
:
:
c_int
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
seek
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
offset
)
CefWrap
:
:
to_c
(
whence
)
)
)
}
}
pub
fn
tell
(
&
self
)
-
>
i64
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
tell
.
unwrap
(
)
)
(
self
.
c_object
)
)
}
}
pub
fn
eof
(
&
self
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
eof
.
unwrap
(
)
)
(
self
.
c_object
)
)
}
}
pub
fn
may_block
(
&
self
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
may_block
.
unwrap
(
)
)
(
self
.
c_object
)
)
}
}
pub
fn
create_for_file
(
fileName
:
&
[
u16
]
)
-
>
interfaces
:
:
CefStreamReader
{
unsafe
{
CefWrap
:
:
to_rust
(
:
:
stream
:
:
cef_stream_reader_create_for_file
(
CefWrap
:
:
to_c
(
fileName
)
)
)
}
}
pub
fn
create_for_data
(
data
:
&
mut
(
)
size
:
libc
:
:
size_t
)
-
>
interfaces
:
:
CefStreamReader
{
unsafe
{
CefWrap
:
:
to_rust
(
:
:
stream
:
:
cef_stream_reader_create_for_data
(
CefWrap
:
:
to_c
(
data
)
CefWrap
:
:
to_c
(
size
)
)
)
}
}
pub
fn
create_for_handler
(
handler
:
interfaces
:
:
CefReadHandler
)
-
>
interfaces
:
:
CefStreamReader
{
unsafe
{
CefWrap
:
:
to_rust
(
:
:
stream
:
:
cef_stream_reader_create_for_handler
(
CefWrap
:
:
to_c
(
handler
)
)
)
}
}
}
impl
CefWrap
<
*
mut
cef_stream_reader_t
>
for
CefStreamReader
{
fn
to_c
(
rust_object
:
CefStreamReader
)
-
>
*
mut
cef_stream_reader_t
{
rust_object
.
c_object_addrefed
(
)
}
unsafe
fn
to_rust
(
c_object
:
*
mut
cef_stream_reader_t
)
-
>
CefStreamReader
{
CefStreamReader
:
:
from_c_object_addref
(
c_object
)
}
}
impl
CefWrap
<
*
mut
cef_stream_reader_t
>
for
Option
<
CefStreamReader
>
{
fn
to_c
(
rust_object
:
Option
<
CefStreamReader
>
)
-
>
*
mut
cef_stream_reader_t
{
match
rust_object
{
None
=
>
ptr
:
:
null_mut
(
)
Some
(
rust_object
)
=
>
rust_object
.
c_object_addrefed
(
)
}
}
unsafe
fn
to_rust
(
c_object
:
*
mut
cef_stream_reader_t
)
-
>
Option
<
CefStreamReader
>
{
if
c_object
.
is_null
(
)
&
&
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
None
}
else
{
Some
(
CefStreamReader
:
:
from_c_object_addref
(
c_object
)
)
}
}
}
#
[
repr
(
C
)
]
pub
struct
_cef_write_handler_t
{
pub
base
:
types
:
:
cef_base_t
pub
write
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_write_handler_t
ptr
:
*
const
(
)
size
:
libc
:
:
size_t
n
:
libc
:
:
size_t
)
-
>
libc
:
:
size_t
>
pub
seek
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_write_handler_t
offset
:
i64
whence
:
libc
:
:
c_int
)
-
>
libc
:
:
c_int
>
pub
tell
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_write_handler_t
)
-
>
i64
>
pub
flush
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_write_handler_t
)
-
>
libc
:
:
c_int
>
pub
may_block
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_write_handler_t
)
-
>
libc
:
:
c_int
>
pub
ref_count
:
u32
pub
extra
:
u8
}
pub
type
cef_write_handler_t
=
_cef_write_handler_t
;
pub
struct
CefWriteHandler
{
c_object
:
*
mut
cef_write_handler_t
}
impl
Clone
for
CefWriteHandler
{
fn
clone
(
&
self
)
-
>
CefWriteHandler
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
(
(
*
self
.
c_object
)
.
base
.
add_ref
.
unwrap
(
)
)
(
&
mut
(
*
self
.
c_object
)
.
base
)
;
}
CefWriteHandler
{
c_object
:
self
.
c_object
}
}
}
}
impl
Drop
for
CefWriteHandler
{
fn
drop
(
&
mut
self
)
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
(
(
*
self
.
c_object
)
.
base
.
release
.
unwrap
(
)
)
(
&
mut
(
*
self
.
c_object
)
.
base
)
;
}
}
}
}
impl
CefWriteHandler
{
pub
unsafe
fn
from_c_object
(
c_object
:
*
mut
cef_write_handler_t
)
-
>
CefWriteHandler
{
CefWriteHandler
{
c_object
:
c_object
}
}
pub
unsafe
fn
from_c_object_addref
(
c_object
:
*
mut
cef_write_handler_t
)
-
>
CefWriteHandler
{
if
!
c_object
.
is_null
(
)
&
&
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
(
(
*
c_object
)
.
base
.
add_ref
.
unwrap
(
)
)
(
&
mut
(
*
c_object
)
.
base
)
;
}
CefWriteHandler
{
c_object
:
c_object
}
}
pub
fn
c_object
(
&
self
)
-
>
*
mut
cef_write_handler_t
{
self
.
c_object
}
pub
fn
c_object_addrefed
(
&
self
)
-
>
*
mut
cef_write_handler_t
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
eutil
:
:
add_ref
(
self
.
c_object
as
*
mut
types
:
:
cef_base_t
)
;
}
self
.
c_object
}
}
pub
fn
is_null_cef_object
(
&
self
)
-
>
bool
{
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
}
pub
fn
is_not_null_cef_object
(
&
self
)
-
>
bool
{
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
}
pub
fn
write
(
&
self
ptr
:
&
(
)
size
:
libc
:
:
size_t
n
:
libc
:
:
size_t
)
-
>
libc
:
:
size_t
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
write
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
ptr
)
CefWrap
:
:
to_c
(
size
)
CefWrap
:
:
to_c
(
n
)
)
)
}
}
pub
fn
seek
(
&
self
offset
:
i64
whence
:
libc
:
:
c_int
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
seek
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
offset
)
CefWrap
:
:
to_c
(
whence
)
)
)
}
}
pub
fn
tell
(
&
self
)
-
>
i64
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
tell
.
unwrap
(
)
)
(
self
.
c_object
)
)
}
}
pub
fn
flush
(
&
self
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
flush
.
unwrap
(
)
)
(
self
.
c_object
)
)
}
}
pub
fn
may_block
(
&
self
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
may_block
.
unwrap
(
)
)
(
self
.
c_object
)
)
}
}
}
impl
CefWrap
<
*
mut
cef_write_handler_t
>
for
CefWriteHandler
{
fn
to_c
(
rust_object
:
CefWriteHandler
)
-
>
*
mut
cef_write_handler_t
{
rust_object
.
c_object_addrefed
(
)
}
unsafe
fn
to_rust
(
c_object
:
*
mut
cef_write_handler_t
)
-
>
CefWriteHandler
{
CefWriteHandler
:
:
from_c_object_addref
(
c_object
)
}
}
impl
CefWrap
<
*
mut
cef_write_handler_t
>
for
Option
<
CefWriteHandler
>
{
fn
to_c
(
rust_object
:
Option
<
CefWriteHandler
>
)
-
>
*
mut
cef_write_handler_t
{
match
rust_object
{
None
=
>
ptr
:
:
null_mut
(
)
Some
(
rust_object
)
=
>
rust_object
.
c_object_addrefed
(
)
}
}
unsafe
fn
to_rust
(
c_object
:
*
mut
cef_write_handler_t
)
-
>
Option
<
CefWriteHandler
>
{
if
c_object
.
is_null
(
)
&
&
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
None
}
else
{
Some
(
CefWriteHandler
:
:
from_c_object_addref
(
c_object
)
)
}
}
}
#
[
repr
(
C
)
]
pub
struct
_cef_stream_writer_t
{
pub
base
:
types
:
:
cef_base_t
pub
write
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_stream_writer_t
ptr
:
*
const
(
)
size
:
libc
:
:
size_t
n
:
libc
:
:
size_t
)
-
>
libc
:
:
size_t
>
pub
seek
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_stream_writer_t
offset
:
i64
whence
:
libc
:
:
c_int
)
-
>
libc
:
:
c_int
>
pub
tell
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_stream_writer_t
)
-
>
i64
>
pub
flush
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_stream_writer_t
)
-
>
libc
:
:
c_int
>
pub
may_block
:
Option
<
extern
"
C
"
fn
(
this
:
*
mut
cef_stream_writer_t
)
-
>
libc
:
:
c_int
>
pub
ref_count
:
u32
pub
extra
:
u8
}
pub
type
cef_stream_writer_t
=
_cef_stream_writer_t
;
pub
struct
CefStreamWriter
{
c_object
:
*
mut
cef_stream_writer_t
}
impl
Clone
for
CefStreamWriter
{
fn
clone
(
&
self
)
-
>
CefStreamWriter
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
(
(
*
self
.
c_object
)
.
base
.
add_ref
.
unwrap
(
)
)
(
&
mut
(
*
self
.
c_object
)
.
base
)
;
}
CefStreamWriter
{
c_object
:
self
.
c_object
}
}
}
}
impl
Drop
for
CefStreamWriter
{
fn
drop
(
&
mut
self
)
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
(
(
*
self
.
c_object
)
.
base
.
release
.
unwrap
(
)
)
(
&
mut
(
*
self
.
c_object
)
.
base
)
;
}
}
}
}
impl
CefStreamWriter
{
pub
unsafe
fn
from_c_object
(
c_object
:
*
mut
cef_stream_writer_t
)
-
>
CefStreamWriter
{
CefStreamWriter
{
c_object
:
c_object
}
}
pub
unsafe
fn
from_c_object_addref
(
c_object
:
*
mut
cef_stream_writer_t
)
-
>
CefStreamWriter
{
if
!
c_object
.
is_null
(
)
&
&
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
(
(
*
c_object
)
.
base
.
add_ref
.
unwrap
(
)
)
(
&
mut
(
*
c_object
)
.
base
)
;
}
CefStreamWriter
{
c_object
:
c_object
}
}
pub
fn
c_object
(
&
self
)
-
>
*
mut
cef_stream_writer_t
{
self
.
c_object
}
pub
fn
c_object_addrefed
(
&
self
)
-
>
*
mut
cef_stream_writer_t
{
unsafe
{
if
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
eutil
:
:
add_ref
(
self
.
c_object
as
*
mut
types
:
:
cef_base_t
)
;
}
self
.
c_object
}
}
pub
fn
is_null_cef_object
(
&
self
)
-
>
bool
{
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
}
pub
fn
is_not_null_cef_object
(
&
self
)
-
>
bool
{
!
self
.
c_object
.
is_null
(
)
&
&
self
.
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
}
pub
fn
write
(
&
self
ptr
:
&
(
)
size
:
libc
:
:
size_t
n
:
libc
:
:
size_t
)
-
>
libc
:
:
size_t
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
write
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
ptr
)
CefWrap
:
:
to_c
(
size
)
CefWrap
:
:
to_c
(
n
)
)
)
}
}
pub
fn
seek
(
&
self
offset
:
i64
whence
:
libc
:
:
c_int
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
seek
.
unwrap
(
)
)
(
self
.
c_object
CefWrap
:
:
to_c
(
offset
)
CefWrap
:
:
to_c
(
whence
)
)
)
}
}
pub
fn
tell
(
&
self
)
-
>
i64
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
tell
.
unwrap
(
)
)
(
self
.
c_object
)
)
}
}
pub
fn
flush
(
&
self
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
flush
.
unwrap
(
)
)
(
self
.
c_object
)
)
}
}
pub
fn
may_block
(
&
self
)
-
>
libc
:
:
c_int
{
if
self
.
c_object
.
is_null
(
)
|
|
self
.
c_object
as
usize
=
=
mem
:
:
POST_DROP_USIZE
{
panic
!
(
"
called
a
CEF
method
on
a
null
object
"
)
}
unsafe
{
CefWrap
:
:
to_rust
(
(
(
*
self
.
c_object
)
.
may_block
.
unwrap
(
)
)
(
self
.
c_object
)
)
}
}
pub
fn
create_for_file
(
fileName
:
&
[
u16
]
)
-
>
interfaces
:
:
CefStreamWriter
{
unsafe
{
CefWrap
:
:
to_rust
(
:
:
stream
:
:
cef_stream_writer_create_for_file
(
CefWrap
:
:
to_c
(
fileName
)
)
)
}
}
pub
fn
create_for_handler
(
handler
:
interfaces
:
:
CefWriteHandler
)
-
>
interfaces
:
:
CefStreamWriter
{
unsafe
{
CefWrap
:
:
to_rust
(
:
:
stream
:
:
cef_stream_writer_create_for_handler
(
CefWrap
:
:
to_c
(
handler
)
)
)
}
}
}
impl
CefWrap
<
*
mut
cef_stream_writer_t
>
for
CefStreamWriter
{
fn
to_c
(
rust_object
:
CefStreamWriter
)
-
>
*
mut
cef_stream_writer_t
{
rust_object
.
c_object_addrefed
(
)
}
unsafe
fn
to_rust
(
c_object
:
*
mut
cef_stream_writer_t
)
-
>
CefStreamWriter
{
CefStreamWriter
:
:
from_c_object_addref
(
c_object
)
}
}
impl
CefWrap
<
*
mut
cef_stream_writer_t
>
for
Option
<
CefStreamWriter
>
{
fn
to_c
(
rust_object
:
Option
<
CefStreamWriter
>
)
-
>
*
mut
cef_stream_writer_t
{
match
rust_object
{
None
=
>
ptr
:
:
null_mut
(
)
Some
(
rust_object
)
=
>
rust_object
.
c_object_addrefed
(
)
}
}
unsafe
fn
to_rust
(
c_object
:
*
mut
cef_stream_writer_t
)
-
>
Option
<
CefStreamWriter
>
{
if
c_object
.
is_null
(
)
&
&
c_object
as
usize
!
=
mem
:
:
POST_DROP_USIZE
{
None
}
else
{
Some
(
CefStreamWriter
:
:
from_c_object_addref
(
c_object
)
)
}
}
}
