#
!
[
feature
(
start
core_intrinsics
)
]
#
[
cfg
(
target_os
=
"
android
"
)
]
#
[
macro_use
]
extern
crate
android_glue
;
#
[
cfg
(
target_os
=
"
android
"
)
]
extern
crate
android_injected_glue
;
extern
crate
backtrace
;
extern
crate
glutin_app
as
app
;
#
[
cfg
(
target_os
=
"
android
"
)
]
extern
crate
libc
;
#
[
macro_use
]
extern
crate
log
;
extern
crate
servo
;
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
#
[
macro_use
]
extern
crate
sig
;
use
backtrace
:
:
Backtrace
;
use
servo
:
:
Browser
;
use
servo
:
:
compositing
:
:
windowing
:
:
WindowEvent
;
use
servo
:
:
config
:
:
opts
:
:
{
self
ArgumentParsingResult
}
;
use
servo
:
:
config
:
:
servo_version
;
use
std
:
:
env
;
use
std
:
:
panic
;
use
std
:
:
process
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
thread
;
pub
mod
platform
{
#
[
cfg
(
target_os
=
"
macos
"
)
]
pub
use
platform
:
:
macos
:
:
deinit
;
#
[
cfg
(
target_os
=
"
macos
"
)
]
pub
mod
macos
;
#
[
cfg
(
not
(
target_os
=
"
macos
"
)
)
]
pub
fn
deinit
(
)
{
}
}
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
fn
install_crash_handler
(
)
{
use
backtrace
:
:
Backtrace
;
use
sig
:
:
ffi
:
:
Sig
;
use
std
:
:
intrinsics
:
:
abort
;
use
std
:
:
thread
;
fn
handler
(
_sig
:
i32
)
{
let
name
=
thread
:
:
current
(
)
.
name
(
)
.
map
(
|
n
|
format
!
(
"
for
thread
\
"
{
}
\
"
"
n
)
)
.
unwrap_or
(
"
"
.
to_owned
(
)
)
;
println
!
(
"
Stack
trace
{
}
\
n
{
:
?
}
"
name
Backtrace
:
:
new
(
)
)
;
unsafe
{
abort
(
)
;
}
}
signal
!
(
Sig
:
:
SEGV
handler
)
;
signal
!
(
Sig
:
:
ILL
handler
)
;
signal
!
(
Sig
:
:
IOT
handler
)
;
signal
!
(
Sig
:
:
BUS
handler
)
;
}
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
install_crash_handler
(
)
{
}
fn
main
(
)
{
install_crash_handler
(
)
;
let
opts_result
=
opts
:
:
from_cmdline_args
(
&
*
args
(
)
)
;
let
content_process_token
=
if
let
ArgumentParsingResult
:
:
ContentProcess
(
token
)
=
opts_result
{
Some
(
token
)
}
else
{
if
opts
:
:
get
(
)
.
is_running_problem_test
&
&
:
:
std
:
:
env
:
:
var
(
"
RUST_LOG
"
)
.
is_err
(
)
{
:
:
std
:
:
env
:
:
set_var
(
"
RUST_LOG
"
"
compositing
:
:
constellation
"
)
;
}
None
}
;
panic
:
:
set_hook
(
Box
:
:
new
(
|
info
|
{
warn
!
(
"
Panic
hook
called
.
"
)
;
let
msg
=
match
info
.
payload
(
)
.
downcast_ref
:
:
<
&
'
static
str
>
(
)
{
Some
(
s
)
=
>
*
s
None
=
>
match
info
.
payload
(
)
.
downcast_ref
:
:
<
String
>
(
)
{
Some
(
s
)
=
>
&
*
*
s
None
=
>
"
Box
<
Any
>
"
}
}
;
let
current_thread
=
thread
:
:
current
(
)
;
let
name
=
current_thread
.
name
(
)
.
unwrap_or
(
"
<
unnamed
>
"
)
;
if
let
Some
(
location
)
=
info
.
location
(
)
{
println
!
(
"
{
}
(
thread
{
}
at
{
}
:
{
}
)
"
msg
name
location
.
file
(
)
location
.
line
(
)
)
;
}
else
{
println
!
(
"
{
}
(
thread
{
}
)
"
msg
name
)
;
}
if
env
:
:
var
(
"
RUST_BACKTRACE
"
)
.
is_ok
(
)
{
println
!
(
"
{
:
?
}
"
Backtrace
:
:
new
(
)
)
;
}
error
!
(
"
{
}
"
msg
)
;
}
)
)
;
setup_logging
(
)
;
if
let
Some
(
token
)
=
content_process_token
{
return
servo
:
:
run_content_process
(
token
)
}
if
opts
:
:
get
(
)
.
is_printing_version
{
println
!
(
"
{
}
"
servo_version
(
)
)
;
process
:
:
exit
(
0
)
;
}
let
window
=
app
:
:
create_window
(
None
)
;
let
mut
browser
=
BrowserWrapper
{
browser
:
Browser
:
:
new
(
window
.
clone
(
)
)
}
;
browser
.
browser
.
setup_logging
(
)
;
register_glutin_resize_handler
(
&
window
&
mut
browser
)
;
browser
.
browser
.
handle_events
(
vec
!
[
WindowEvent
:
:
InitializeCompositing
]
)
;
loop
{
let
should_continue
=
browser
.
browser
.
handle_events
(
window
.
wait_events
(
)
)
;
if
!
should_continue
{
break
}
}
;
unregister_glutin_resize_handler
(
&
window
)
;
platform
:
:
deinit
(
)
}
fn
register_glutin_resize_handler
(
window
:
&
Rc
<
app
:
:
window
:
:
Window
>
browser
:
&
mut
BrowserWrapper
)
{
unsafe
{
window
.
set_nested_event_loop_listener
(
browser
)
;
}
}
fn
unregister_glutin_resize_handler
(
window
:
&
Rc
<
app
:
:
window
:
:
Window
>
)
{
unsafe
{
window
.
remove_nested_event_loop_listener
(
)
;
}
}
struct
BrowserWrapper
{
browser
:
Browser
<
app
:
:
window
:
:
Window
>
}
impl
app
:
:
NestedEventLoopListener
for
BrowserWrapper
{
fn
handle_event_from_nested_event_loop
(
&
mut
self
event
:
WindowEvent
)
-
>
bool
{
let
is_resize
=
match
event
{
WindowEvent
:
:
Resize
(
.
.
)
=
>
true
_
=
>
false
}
;
if
!
self
.
browser
.
handle_events
(
vec
!
[
event
]
)
{
return
false
}
if
is_resize
{
self
.
browser
.
repaint_synchronously
(
)
}
true
}
}
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
setup_logging
(
)
{
android
:
:
setup_logging
(
)
;
}
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
fn
setup_logging
(
)
{
}
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
args
(
)
-
>
Vec
<
String
>
{
use
std
:
:
error
:
:
Error
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
BufRead
BufReader
}
;
const
PARAMS_FILE
:
&
'
static
str
=
"
/
sdcard
/
servo
/
android_params
"
;
match
File
:
:
open
(
PARAMS_FILE
)
{
Ok
(
f
)
=
>
{
let
mut
vec
=
Vec
:
:
new
(
)
;
let
file
=
BufReader
:
:
new
(
&
f
)
;
for
line
in
file
.
lines
(
)
{
let
l
=
line
.
unwrap
(
)
.
trim
(
)
.
to_owned
(
)
;
match
l
.
is_empty
(
)
|
|
l
.
as_bytes
(
)
[
0
]
=
=
b
'
#
'
{
true
=
>
(
)
false
=
>
vec
.
push
(
l
)
}
}
vec
}
Err
(
e
)
=
>
{
debug
!
(
"
Failed
to
open
params
file
'
{
}
'
:
{
}
"
PARAMS_FILE
Error
:
:
description
(
&
e
)
)
;
vec
!
[
"
servo
"
.
to_owned
(
)
"
http
:
/
/
en
.
wikipedia
.
org
/
wiki
/
Rust
"
.
to_owned
(
)
]
}
}
}
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
fn
args
(
)
-
>
Vec
<
String
>
{
use
std
:
:
env
;
env
:
:
args
(
)
.
collect
(
)
}
#
[
cfg
(
target_os
=
"
android
"
)
]
#
[
no_mangle
]
#
[
inline
(
never
)
]
#
[
allow
(
non_snake_case
)
]
pub
extern
"
C
"
fn
android_main
(
app
:
*
mut
(
)
)
{
android_injected_glue
:
:
android_main2
(
app
as
*
mut
_
move
|
_
_
|
{
main
(
)
}
)
;
}
#
[
cfg
(
target_os
=
"
android
"
)
]
mod
android
{
extern
crate
android_glue
;
extern
crate
android_injected_glue
;
extern
crate
libc
;
use
self
:
:
libc
:
:
c_int
;
use
std
:
:
borrow
:
:
ToOwned
;
pub
fn
setup_logging
(
)
{
use
self
:
:
libc
:
:
{
STDERR_FILENO
STDOUT_FILENO
}
;
redirect_output
(
STDERR_FILENO
)
;
redirect_output
(
STDOUT_FILENO
)
;
unsafe
{
android_injected_glue
:
:
ffi
:
:
app_dummy
(
)
}
;
}
struct
FilePtr
(
*
mut
self
:
:
libc
:
:
FILE
)
;
unsafe
impl
Send
for
FilePtr
{
}
fn
redirect_output
(
file_no
:
c_int
)
{
use
self
:
:
libc
:
:
{
pipe
dup2
}
;
use
self
:
:
libc
:
:
fdopen
;
use
self
:
:
libc
:
:
fgets
;
use
std
:
:
ffi
:
:
CStr
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
str
:
:
from_utf8
;
use
std
:
:
thread
;
unsafe
{
let
mut
pipes
:
[
c_int
;
2
]
=
[
0
0
]
;
pipe
(
pipes
.
as_mut_ptr
(
)
)
;
dup2
(
pipes
[
1
]
file_no
)
;
let
mode
=
CString
:
:
new
(
"
r
"
)
.
unwrap
(
)
;
let
input_file
=
FilePtr
(
fdopen
(
pipes
[
0
]
mode
.
as_ptr
(
)
)
)
;
thread
:
:
Builder
:
:
new
(
)
.
name
(
"
android
-
logger
"
.
to_owned
(
)
)
.
spawn
(
move
|
|
{
static
READ_SIZE
:
usize
=
1024
;
let
mut
read_buffer
=
vec
!
[
0
;
READ_SIZE
]
;
let
FilePtr
(
input_file
)
=
input_file
;
loop
{
fgets
(
read_buffer
.
as_mut_ptr
(
)
(
read_buffer
.
len
(
)
as
i32
)
-
1
input_file
)
;
let
c_str
=
CStr
:
:
from_ptr
(
read_buffer
.
as_ptr
(
)
)
;
let
slice
=
from_utf8
(
c_str
.
to_bytes
(
)
)
.
unwrap
(
)
;
android_glue
:
:
write_log
(
slice
)
;
}
}
)
;
}
}
}
