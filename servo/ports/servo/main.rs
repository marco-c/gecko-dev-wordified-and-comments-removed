#
!
[
cfg_attr
(
feature
=
"
unstable
"
feature
(
core_intrinsics
)
)
]
#
[
cfg
(
target_os
=
"
android
"
)
]
extern
crate
android_injected_glue
;
extern
crate
backtrace
;
#
[
macro_use
]
extern
crate
bitflags
;
extern
crate
compositing
;
extern
crate
euclid
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
extern
crate
gdi32
;
extern
crate
gleam
;
extern
crate
glutin
;
#
[
macro_use
]
extern
crate
log
;
extern
crate
msg
;
extern
crate
net_traits
;
#
[
cfg
(
any
(
target_os
=
"
linux
"
target_os
=
"
macos
"
)
)
]
extern
crate
osmesa_sys
;
extern
crate
script_traits
;
extern
crate
servo
;
extern
crate
servo_config
;
extern
crate
servo_geometry
;
extern
crate
servo_url
;
#
[
cfg
(
all
(
feature
=
"
unstable
"
not
(
target_os
=
"
android
"
)
)
)
]
#
[
macro_use
]
extern
crate
sig
;
extern
crate
style_traits
;
extern
crate
webrender_api
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
extern
crate
winapi
;
#
[
cfg
(
target_os
=
"
windows
"
)
]
extern
crate
user32
;
mod
glutin_app
;
use
backtrace
:
:
Backtrace
;
use
servo
:
:
Servo
;
use
servo
:
:
compositing
:
:
windowing
:
:
WindowEvent
;
#
[
cfg
(
target_os
=
"
android
"
)
]
use
servo
:
:
config
;
use
servo
:
:
config
:
:
opts
:
:
{
self
ArgumentParsingResult
parse_url_or_filename
}
;
use
servo
:
:
config
:
:
servo_version
;
use
servo
:
:
ipc_channel
:
:
ipc
;
use
servo
:
:
servo_config
:
:
prefs
:
:
PREFS
;
use
servo
:
:
servo_url
:
:
ServoUrl
;
use
std
:
:
env
;
use
std
:
:
panic
;
use
std
:
:
process
;
use
std
:
:
rc
:
:
Rc
;
use
std
:
:
thread
;
pub
mod
platform
{
#
[
cfg
(
target_os
=
"
macos
"
)
]
pub
use
platform
:
:
macos
:
:
deinit
;
#
[
cfg
(
target_os
=
"
macos
"
)
]
pub
mod
macos
;
#
[
cfg
(
not
(
target_os
=
"
macos
"
)
)
]
pub
fn
deinit
(
)
{
}
}
#
[
cfg
(
all
(
feature
=
"
unstable
"
not
(
target_os
=
"
android
"
)
)
)
]
fn
install_crash_handler
(
)
{
use
backtrace
:
:
Backtrace
;
use
sig
:
:
ffi
:
:
Sig
;
use
std
:
:
intrinsics
:
:
abort
;
use
std
:
:
thread
;
fn
handler
(
_sig
:
i32
)
{
let
name
=
thread
:
:
current
(
)
.
name
(
)
.
map
(
|
n
|
format
!
(
"
for
thread
\
"
{
}
\
"
"
n
)
)
.
unwrap_or
(
"
"
.
to_owned
(
)
)
;
println
!
(
"
Stack
trace
{
}
\
n
{
:
?
}
"
name
Backtrace
:
:
new
(
)
)
;
unsafe
{
abort
(
)
;
}
}
signal
!
(
Sig
:
:
SEGV
handler
)
;
signal
!
(
Sig
:
:
ILL
handler
)
;
signal
!
(
Sig
:
:
IOT
handler
)
;
signal
!
(
Sig
:
:
BUS
handler
)
;
}
#
[
cfg
(
any
(
not
(
feature
=
"
unstable
"
)
target_os
=
"
android
"
)
)
]
fn
install_crash_handler
(
)
{
}
fn
main
(
)
{
install_crash_handler
(
)
;
let
opts_result
=
opts
:
:
from_cmdline_args
(
&
*
args
(
)
)
;
let
content_process_token
=
if
let
ArgumentParsingResult
:
:
ContentProcess
(
token
)
=
opts_result
{
Some
(
token
)
}
else
{
if
opts
:
:
get
(
)
.
is_running_problem_test
&
&
:
:
std
:
:
env
:
:
var
(
"
RUST_LOG
"
)
.
is_err
(
)
{
:
:
std
:
:
env
:
:
set_var
(
"
RUST_LOG
"
"
compositing
:
:
constellation
"
)
;
}
None
}
;
panic
:
:
set_hook
(
Box
:
:
new
(
|
info
|
{
warn
!
(
"
Panic
hook
called
.
"
)
;
let
msg
=
match
info
.
payload
(
)
.
downcast_ref
:
:
<
&
'
static
str
>
(
)
{
Some
(
s
)
=
>
*
s
None
=
>
{
match
info
.
payload
(
)
.
downcast_ref
:
:
<
String
>
(
)
{
Some
(
s
)
=
>
&
*
*
s
None
=
>
"
Box
<
Any
>
"
}
}
}
;
let
current_thread
=
thread
:
:
current
(
)
;
let
name
=
current_thread
.
name
(
)
.
unwrap_or
(
"
<
unnamed
>
"
)
;
if
let
Some
(
location
)
=
info
.
location
(
)
{
println
!
(
"
{
}
(
thread
{
}
at
{
}
:
{
}
)
"
msg
name
location
.
file
(
)
location
.
line
(
)
)
;
}
else
{
println
!
(
"
{
}
(
thread
{
}
)
"
msg
name
)
;
}
if
env
:
:
var
(
"
RUST_BACKTRACE
"
)
.
is_ok
(
)
{
println
!
(
"
{
:
?
}
"
Backtrace
:
:
new
(
)
)
;
}
error
!
(
"
{
}
"
msg
)
;
}
)
)
;
setup_logging
(
)
;
if
let
Some
(
token
)
=
content_process_token
{
return
servo
:
:
run_content_process
(
token
)
;
}
if
opts
:
:
get
(
)
.
is_printing_version
{
println
!
(
"
{
}
"
servo_version
(
)
)
;
process
:
:
exit
(
0
)
;
}
let
window
=
glutin_app
:
:
create_window
(
)
;
let
cwd
=
env
:
:
current_dir
(
)
.
unwrap
(
)
;
let
cmdline_url
=
opts
:
:
get
(
)
.
url
.
clone
(
)
;
let
pref_url
=
PREFS
.
get
(
"
shell
.
homepage
"
)
.
as_string
(
)
.
and_then
(
|
str
|
parse_url_or_filename
(
&
cwd
str
)
.
ok
(
)
)
;
let
blank_url
=
ServoUrl
:
:
parse
(
"
about
:
blank
"
)
.
ok
(
)
;
let
target_url
=
cmdline_url
.
or
(
pref_url
)
.
or
(
blank_url
)
.
unwrap
(
)
;
let
mut
servo_wrapper
=
ServoWrapper
{
servo
:
Servo
:
:
new
(
window
.
clone
(
)
)
}
;
let
(
sender
receiver
)
=
ipc
:
:
channel
(
)
.
unwrap
(
)
;
servo_wrapper
.
servo
.
handle_events
(
vec
!
[
WindowEvent
:
:
NewBrowser
(
target_url
sender
)
]
)
;
let
browser_id
=
receiver
.
recv
(
)
.
unwrap
(
)
;
window
.
set_browser_id
(
browser_id
)
;
servo_wrapper
.
servo
.
handle_events
(
vec
!
[
WindowEvent
:
:
SelectBrowser
(
browser_id
)
]
)
;
servo_wrapper
.
servo
.
setup_logging
(
)
;
register_glutin_resize_handler
(
&
window
&
mut
servo_wrapper
)
;
loop
{
let
should_continue
=
servo_wrapper
.
servo
.
handle_events
(
window
.
wait_events
(
)
)
;
if
!
should_continue
{
break
;
}
}
unregister_glutin_resize_handler
(
&
window
)
;
servo_wrapper
.
servo
.
deinit
(
)
;
platform
:
:
deinit
(
)
}
fn
register_glutin_resize_handler
(
window
:
&
Rc
<
glutin_app
:
:
window
:
:
Window
>
browser
:
&
mut
ServoWrapper
)
{
unsafe
{
window
.
set_nested_event_loop_listener
(
browser
)
;
}
}
fn
unregister_glutin_resize_handler
(
window
:
&
Rc
<
glutin_app
:
:
window
:
:
Window
>
)
{
unsafe
{
window
.
remove_nested_event_loop_listener
(
)
;
}
}
struct
ServoWrapper
{
servo
:
Servo
<
glutin_app
:
:
window
:
:
Window
>
}
impl
glutin_app
:
:
NestedEventLoopListener
for
ServoWrapper
{
fn
handle_event_from_nested_event_loop
(
&
mut
self
event
:
WindowEvent
)
-
>
bool
{
let
is_resize
=
match
event
{
WindowEvent
:
:
Resize
=
>
true
_
=
>
false
}
;
if
!
self
.
servo
.
handle_events
(
vec
!
[
event
]
)
{
return
false
;
}
if
is_resize
{
self
.
servo
.
repaint_synchronously
(
)
}
true
}
}
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
setup_logging
(
)
{
:
:
std
:
:
env
:
:
set_var
(
"
RUST_LOG
"
"
error
"
)
;
unsafe
{
android_injected_glue
:
:
ffi
:
:
app_dummy
(
)
}
;
}
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
fn
setup_logging
(
)
{
}
#
[
cfg
(
target_os
=
"
android
"
)
]
fn
args
(
)
-
>
Vec
<
String
>
{
use
std
:
:
error
:
:
Error
;
use
std
:
:
fs
:
:
File
;
use
std
:
:
io
:
:
{
BufRead
BufReader
}
;
let
mut
params_file
=
config
:
:
basedir
:
:
default_config_dir
(
)
.
unwrap
(
)
;
params_file
.
push
(
"
android_params
"
)
;
match
File
:
:
open
(
params_file
.
to_str
(
)
.
unwrap
(
)
)
{
Ok
(
f
)
=
>
{
let
mut
vec
=
Vec
:
:
new
(
)
;
let
file
=
BufReader
:
:
new
(
&
f
)
;
for
line
in
file
.
lines
(
)
{
let
l
=
line
.
unwrap
(
)
.
trim
(
)
.
to_owned
(
)
;
match
l
.
is_empty
(
)
|
|
l
.
as_bytes
(
)
[
0
]
=
=
b
'
#
'
{
true
=
>
(
)
false
=
>
vec
.
push
(
l
)
}
}
vec
}
Err
(
e
)
=
>
{
debug
!
(
"
Failed
to
open
params
file
'
{
}
'
:
{
}
"
params_file
.
to_str
(
)
.
unwrap
(
)
Error
:
:
description
(
&
e
)
)
;
vec
!
[
"
servo
"
.
to_owned
(
)
"
http
:
/
/
en
.
wikipedia
.
org
/
wiki
/
Rust
"
.
to_owned
(
)
]
}
}
}
#
[
cfg
(
not
(
target_os
=
"
android
"
)
)
]
fn
args
(
)
-
>
Vec
<
String
>
{
use
std
:
:
env
;
env
:
:
args
(
)
.
collect
(
)
}
#
[
cfg
(
target_os
=
"
android
"
)
]
#
[
no_mangle
]
#
[
inline
(
never
)
]
#
[
allow
(
non_snake_case
)
]
pub
extern
"
C
"
fn
android_main
(
app
:
*
mut
(
)
)
{
android_injected_glue
:
:
android_main2
(
app
as
*
mut
_
move
|
_
_
|
main
(
)
)
;
}
#
[
allow
(
non_snake_case
)
]
#
[
no_mangle
]
pub
extern
"
C
"
fn
glBindVertexArrayOES
(
_array
:
usize
)
{
unimplemented
!
(
)
}
#
[
allow
(
non_snake_case
)
]
#
[
no_mangle
]
pub
extern
"
C
"
fn
glDeleteVertexArraysOES
(
_n
:
isize
_arrays
:
*
const
(
)
)
{
unimplemented
!
(
)
}
#
[
allow
(
non_snake_case
)
]
#
[
no_mangle
]
pub
extern
"
C
"
fn
glGenVertexArraysOES
(
_n
:
isize
_arrays
:
*
const
(
)
)
{
unimplemented
!
(
)
}
#
[
allow
(
non_snake_case
)
]
#
[
no_mangle
]
pub
extern
"
C
"
fn
glRenderbufferStorageMultisampleIMG
(
_
:
isize
_
:
isize
_
:
isize
_
:
isize
_
:
isize
)
{
unimplemented
!
(
)
}
#
[
allow
(
non_snake_case
)
]
#
[
no_mangle
]
pub
extern
"
C
"
fn
glFramebufferTexture2DMultisampleIMG
(
_
:
isize
_
:
isize
_
:
isize
_
:
isize
_
:
isize
_
:
isize
)
{
unimplemented
!
(
)
}
#
[
allow
(
non_snake_case
)
]
#
[
no_mangle
]
pub
extern
"
C
"
fn
glDiscardFramebufferEXT
(
_
:
isize
_
:
isize
_
:
*
const
(
)
)
{
unimplemented
!
(
)
}
