#
include
"
nsDocShellEditorData
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIEditingSession
.
h
"
#
include
"
nsIDocShell
.
h
"
using
namespace
mozilla
;
nsDocShellEditorData
:
:
nsDocShellEditorData
(
nsIDocShell
*
aOwningDocShell
)
:
mDocShell
(
aOwningDocShell
)
mDetachedEditingState
(
nsIHTMLDocument
:
:
eOff
)
mMakeEditable
(
false
)
mIsDetached
(
false
)
mDetachedMakeEditable
(
false
)
{
NS_ASSERTION
(
mDocShell
"
Where
is
my
docShell
?
"
)
;
}
nsDocShellEditorData
:
:
~
nsDocShellEditorData
(
)
{
TearDownEditor
(
)
;
}
void
nsDocShellEditorData
:
:
TearDownEditor
(
)
{
if
(
mHTMLEditor
)
{
RefPtr
<
HTMLEditor
>
htmlEditor
=
mHTMLEditor
.
forget
(
)
;
htmlEditor
-
>
PreDestroy
(
false
)
;
}
mEditingSession
=
nullptr
;
mIsDetached
=
false
;
}
nsresult
nsDocShellEditorData
:
:
MakeEditable
(
bool
aInWaitForUriLoad
)
{
if
(
mMakeEditable
)
{
return
NS_OK
;
}
if
(
mHTMLEditor
)
{
NS_WARNING
(
"
Destroying
existing
editor
on
frame
"
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
mHTMLEditor
.
forget
(
)
;
htmlEditor
-
>
PreDestroy
(
false
)
;
}
if
(
aInWaitForUriLoad
)
{
mMakeEditable
=
true
;
}
return
NS_OK
;
}
bool
nsDocShellEditorData
:
:
GetEditable
(
)
{
return
mMakeEditable
|
|
(
mHTMLEditor
!
=
nullptr
)
;
}
nsresult
nsDocShellEditorData
:
:
CreateEditor
(
)
{
nsCOMPtr
<
nsIEditingSession
>
editingSession
;
nsresult
rv
=
GetEditingSession
(
getter_AddRefs
(
editingSession
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
rv
=
editingSession
-
>
SetupEditorOnWindow
(
domWindow
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
nsDocShellEditorData
:
:
GetEditingSession
(
nsIEditingSession
*
*
aResult
)
{
nsresult
rv
=
EnsureEditingSession
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ADDREF
(
*
aResult
=
mEditingSession
)
;
return
NS_OK
;
}
nsresult
nsDocShellEditorData
:
:
SetHTMLEditor
(
HTMLEditor
*
aHTMLEditor
)
{
if
(
mHTMLEditor
=
=
aHTMLEditor
)
{
return
NS_OK
;
}
if
(
mHTMLEditor
)
{
RefPtr
<
HTMLEditor
>
htmlEditor
=
mHTMLEditor
.
forget
(
)
;
htmlEditor
-
>
PreDestroy
(
false
)
;
MOZ_ASSERT
(
!
mHTMLEditor
"
Nested
call
of
nsDocShellEditorData
:
:
SetHTMLEditor
(
)
detected
"
)
;
}
mHTMLEditor
=
aHTMLEditor
;
if
(
!
mHTMLEditor
)
{
mMakeEditable
=
false
;
}
return
NS_OK
;
}
nsresult
nsDocShellEditorData
:
:
EnsureEditingSession
(
)
{
NS_ASSERTION
(
mDocShell
"
Should
have
docShell
here
"
)
;
NS_ASSERTION
(
!
mIsDetached
"
This
will
stomp
editing
session
!
"
)
;
nsresult
rv
=
NS_OK
;
if
(
!
mEditingSession
)
{
mEditingSession
=
do_CreateInstance
(
"
mozilla
.
org
/
editor
/
editingsession
;
1
"
&
rv
)
;
}
return
rv
;
}
nsresult
nsDocShellEditorData
:
:
DetachFromWindow
(
)
{
NS_ASSERTION
(
mEditingSession
"
Can
'
t
detach
when
we
don
'
t
have
a
session
to
detach
!
"
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
nsresult
rv
=
mEditingSession
-
>
DetachFromWindow
(
domWindow
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mIsDetached
=
true
;
mDetachedMakeEditable
=
mMakeEditable
;
mMakeEditable
=
false
;
nsCOMPtr
<
nsIDocument
>
doc
=
domWindow
-
>
GetDoc
(
)
;
nsCOMPtr
<
nsIHTMLDocument
>
htmlDoc
=
do_QueryInterface
(
doc
)
;
if
(
htmlDoc
)
{
mDetachedEditingState
=
htmlDoc
-
>
GetEditingState
(
)
;
}
mDocShell
=
nullptr
;
return
NS_OK
;
}
nsresult
nsDocShellEditorData
:
:
ReattachToWindow
(
nsIDocShell
*
aDocShell
)
{
mDocShell
=
aDocShell
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
nsresult
rv
=
mEditingSession
-
>
ReattachToWindow
(
domWindow
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mIsDetached
=
false
;
mMakeEditable
=
mDetachedMakeEditable
;
nsCOMPtr
<
nsIDocument
>
doc
=
domWindow
-
>
GetDoc
(
)
;
nsCOMPtr
<
nsIHTMLDocument
>
htmlDoc
=
do_QueryInterface
(
doc
)
;
if
(
htmlDoc
)
{
htmlDoc
-
>
SetEditingState
(
mDetachedEditingState
)
;
}
return
NS_OK
;
}
