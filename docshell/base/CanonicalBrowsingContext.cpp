#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContextBinding
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContextGroup
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
PWindowGlobalParent
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
dom
/
ContentProcessManager
.
h
"
#
include
"
mozilla
/
dom
/
MediaController
.
h
"
#
include
"
mozilla
/
dom
/
MediaControlService
.
h
"
#
include
"
mozilla
/
dom
/
ContentPlaybackController
.
h
"
#
include
"
mozilla
/
dom
/
SessionHistoryEntry
.
h
"
#
include
"
mozilla
/
dom
/
SessionStorageManager
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
net
/
DocumentLoadListener
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
StaticPrefs_fission
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
mozilla
/
MozPromiseInlines
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsFrameLoaderOwner
.
h
"
#
include
"
nsGlobalWindowOuter
.
h
"
#
include
"
nsIWebBrowserChrome
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsSHistory
.
h
"
#
include
"
nsSecureBrowserUI
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsBrowserStatusFilter
.
h
"
#
include
"
nsIBrowser
.
h
"
#
include
"
nsTHashSet
.
h
"
#
ifdef
NS_PRINTING
#
include
"
mozilla
/
embedding
/
printingui
/
PrintingParent
.
h
"
#
include
"
nsIWebBrowserPrint
.
h
"
#
endif
using
namespace
mozilla
:
:
ipc
;
extern
mozilla
:
:
LazyLogModule
gAutoplayPermissionLog
;
extern
mozilla
:
:
LazyLogModule
gSHLog
;
#
define
AUTOPLAY_LOG
(
msg
.
.
.
)
\
MOZ_LOG
(
gAutoplayPermissionLog
LogLevel
:
:
Debug
(
msg
#
#
__VA_ARGS__
)
)
namespace
mozilla
{
namespace
dom
{
extern
mozilla
:
:
LazyLogModule
gUserInteractionPRLog
;
#
define
USER_ACTIVATION_LOG
(
msg
.
.
.
)
\
MOZ_LOG
(
gUserInteractionPRLog
LogLevel
:
:
Debug
(
msg
#
#
__VA_ARGS__
)
)
CanonicalBrowsingContext
:
:
CanonicalBrowsingContext
(
WindowContext
*
aParentWindow
BrowsingContextGroup
*
aGroup
uint64_t
aBrowsingContextId
uint64_t
aOwnerProcessId
uint64_t
aEmbedderProcessId
BrowsingContext
:
:
Type
aType
FieldValues
&
&
aInit
)
:
BrowsingContext
(
aParentWindow
aGroup
aBrowsingContextId
aType
std
:
:
move
(
aInit
)
)
mProcessId
(
aOwnerProcessId
)
mEmbedderProcessId
(
aEmbedderProcessId
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
mCurrentRemoteURI
)
"
about
:
blank
"
)
)
;
}
already_AddRefed
<
CanonicalBrowsingContext
>
CanonicalBrowsingContext
:
:
Get
(
uint64_t
aId
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
BrowsingContext
:
:
Get
(
aId
)
.
downcast
<
CanonicalBrowsingContext
>
(
)
;
}
CanonicalBrowsingContext
*
CanonicalBrowsingContext
:
:
Cast
(
BrowsingContext
*
aContext
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
static_cast
<
CanonicalBrowsingContext
*
>
(
aContext
)
;
}
const
CanonicalBrowsingContext
*
CanonicalBrowsingContext
:
:
Cast
(
const
BrowsingContext
*
aContext
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
static_cast
<
const
CanonicalBrowsingContext
*
>
(
aContext
)
;
}
already_AddRefed
<
CanonicalBrowsingContext
>
CanonicalBrowsingContext
:
:
Cast
(
already_AddRefed
<
BrowsingContext
>
&
&
aContext
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
aContext
.
downcast
<
CanonicalBrowsingContext
>
(
)
;
}
ContentParent
*
CanonicalBrowsingContext
:
:
GetContentParent
(
)
const
{
if
(
mProcessId
=
=
0
)
{
return
nullptr
;
}
ContentProcessManager
*
cpm
=
ContentProcessManager
:
:
GetSingleton
(
)
;
return
cpm
-
>
GetContentProcessById
(
ContentParentId
(
mProcessId
)
)
;
}
void
CanonicalBrowsingContext
:
:
GetCurrentRemoteType
(
nsACString
&
aRemoteType
ErrorResult
&
aRv
)
const
{
if
(
mProcessId
=
=
0
)
{
aRemoteType
=
NOT_REMOTE_TYPE
;
return
;
}
ContentParent
*
cp
=
GetContentParent
(
)
;
if
(
!
cp
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
aRemoteType
=
cp
-
>
GetRemoteType
(
)
;
}
void
CanonicalBrowsingContext
:
:
SetOwnerProcessId
(
uint64_t
aProcessId
)
{
MOZ_LOG
(
GetLog
(
)
LogLevel
:
:
Debug
(
"
SetOwnerProcessId
for
0x
%
08
"
PRIx64
"
(
0x
%
08
"
PRIx64
"
-
>
0x
%
08
"
PRIx64
"
)
"
Id
(
)
mProcessId
aProcessId
)
)
;
mProcessId
=
aProcessId
;
}
nsISecureBrowserUI
*
CanonicalBrowsingContext
:
:
GetSecureBrowserUI
(
)
{
if
(
!
IsTop
(
)
)
{
return
nullptr
;
}
if
(
!
mSecureBrowserUI
)
{
mSecureBrowserUI
=
new
nsSecureBrowserUI
(
this
)
;
}
return
mSecureBrowserUI
;
}
void
CanonicalBrowsingContext
:
:
MaybeAddAsProgressListener
(
nsIWebProgress
*
aWebProgress
)
{
if
(
!
GetWebProgress
(
)
)
{
return
;
}
if
(
!
mStatusFilter
)
{
mStatusFilter
=
new
nsBrowserStatusFilter
(
)
;
mStatusFilter
-
>
AddProgressListener
(
GetWebProgress
(
)
nsIWebProgress
:
:
NOTIFY_ALL
)
;
}
aWebProgress
-
>
AddProgressListener
(
mStatusFilter
nsIWebProgress
:
:
NOTIFY_ALL
)
;
}
void
CanonicalBrowsingContext
:
:
ReplacedBy
(
CanonicalBrowsingContext
*
aNewContext
const
RemotenessChangeOptions
&
aRemotenessOptions
)
{
MOZ_ASSERT
(
!
aNewContext
-
>
mWebProgress
)
;
MOZ_ASSERT
(
!
aNewContext
-
>
mSessionHistory
)
;
MOZ_ASSERT
(
IsTop
(
)
&
&
aNewContext
-
>
IsTop
(
)
)
;
if
(
mStatusFilter
)
{
mStatusFilter
-
>
RemoveProgressListener
(
mWebProgress
)
;
mStatusFilter
=
nullptr
;
}
aNewContext
-
>
mWebProgress
=
std
:
:
move
(
mWebProgress
)
;
bool
hasRestoreData
=
!
!
mRestoreData
&
&
!
mRestoreData
-
>
IsEmpty
(
)
;
aNewContext
-
>
mRestoreData
=
std
:
:
move
(
mRestoreData
)
;
aNewContext
-
>
mRequestedContentRestores
=
mRequestedContentRestores
;
aNewContext
-
>
mCompletedContentRestores
=
mCompletedContentRestores
;
SetRestoreData
(
nullptr
)
;
mRequestedContentRestores
=
0
;
mCompletedContentRestores
=
0
;
Transaction
txn
;
txn
.
SetBrowserId
(
GetBrowserId
(
)
)
;
txn
.
SetHistoryID
(
GetHistoryID
(
)
)
;
txn
.
SetExplicitActive
(
GetExplicitActive
(
)
)
;
txn
.
SetHasRestoreData
(
hasRestoreData
)
;
if
(
aNewContext
-
>
EverAttached
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
txn
.
Commit
(
aNewContext
)
)
;
}
else
{
txn
.
CommitWithoutSyncing
(
aNewContext
)
;
}
if
(
aRemotenessOptions
.
mTryUseBFCache
)
{
MOZ_ASSERT
(
!
aNewContext
-
>
EverAttached
(
)
)
;
aNewContext
-
>
mFields
.
SetWithoutSyncing
<
IDX_Name
>
(
GetName
(
)
)
;
aNewContext
-
>
mFields
.
SetWithoutSyncing
<
IDX_HasLoadedNonInitialDocument
>
(
GetHasLoadedNonInitialDocument
(
)
)
;
}
if
(
mSessionHistory
)
{
mSessionHistory
-
>
SetBrowsingContext
(
aNewContext
)
;
if
(
mozilla
:
:
BFCacheInParent
(
)
)
{
mSessionHistory
-
>
SetEpoch
(
0
Nothing
(
)
)
;
}
mSessionHistory
.
swap
(
aNewContext
-
>
mSessionHistory
)
;
RefPtr
<
ChildSHistory
>
childSHistory
=
ForgetChildSHistory
(
)
;
aNewContext
-
>
SetChildSHistory
(
childSHistory
)
;
}
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
BackgroundSessionStorageManager
:
:
PropagateManager
(
Id
(
)
aNewContext
-
>
Id
(
)
)
;
}
MOZ_ASSERT
(
aNewContext
-
>
mLoadingEntries
.
IsEmpty
(
)
)
;
mLoadingEntries
.
SwapElements
(
aNewContext
-
>
mLoadingEntries
)
;
MOZ_ASSERT
(
!
aNewContext
-
>
mActiveEntry
)
;
mActiveEntry
.
swap
(
aNewContext
-
>
mActiveEntry
)
;
}
void
CanonicalBrowsingContext
:
:
UpdateSecurityState
(
)
{
if
(
mSecureBrowserUI
)
{
mSecureBrowserUI
-
>
RecomputeSecurityFlags
(
)
;
}
}
void
CanonicalBrowsingContext
:
:
GetWindowGlobals
(
nsTArray
<
RefPtr
<
WindowGlobalParent
>
>
&
aWindows
)
{
aWindows
.
SetCapacity
(
GetWindowContexts
(
)
.
Length
(
)
)
;
for
(
auto
&
window
:
GetWindowContexts
(
)
)
{
aWindows
.
AppendElement
(
static_cast
<
WindowGlobalParent
*
>
(
window
.
get
(
)
)
)
;
}
}
WindowGlobalParent
*
CanonicalBrowsingContext
:
:
GetCurrentWindowGlobal
(
)
const
{
return
static_cast
<
WindowGlobalParent
*
>
(
GetCurrentWindowContext
(
)
)
;
}
WindowGlobalParent
*
CanonicalBrowsingContext
:
:
GetParentWindowContext
(
)
{
return
static_cast
<
WindowGlobalParent
*
>
(
BrowsingContext
:
:
GetParentWindowContext
(
)
)
;
}
WindowGlobalParent
*
CanonicalBrowsingContext
:
:
GetTopWindowContext
(
)
{
return
static_cast
<
WindowGlobalParent
*
>
(
BrowsingContext
:
:
GetTopWindowContext
(
)
)
;
}
already_AddRefed
<
nsIWidget
>
CanonicalBrowsingContext
:
:
GetParentProcessWidgetContaining
(
)
{
nsCOMPtr
<
nsIWidget
>
widget
;
if
(
nsGlobalWindowOuter
*
window
=
nsGlobalWindowOuter
:
:
Cast
(
GetDOMWindow
(
)
)
)
{
widget
=
window
-
>
GetNearestWidget
(
)
;
}
else
if
(
Element
*
topEmbedder
=
Top
(
)
-
>
GetEmbedderElement
(
)
)
{
widget
=
nsContentUtils
:
:
WidgetForContent
(
topEmbedder
)
;
if
(
!
widget
)
{
widget
=
nsContentUtils
:
:
WidgetForDocument
(
topEmbedder
-
>
OwnerDoc
(
)
)
;
}
}
if
(
widget
)
{
widget
=
widget
-
>
GetTopLevelWidget
(
)
;
}
return
widget
.
forget
(
)
;
}
already_AddRefed
<
WindowGlobalParent
>
CanonicalBrowsingContext
:
:
GetEmbedderWindowGlobal
(
)
const
{
uint64_t
windowId
=
GetEmbedderInnerWindowId
(
)
;
if
(
windowId
=
=
0
)
{
return
nullptr
;
}
return
WindowGlobalParent
:
:
GetByInnerWindowId
(
windowId
)
;
}
already_AddRefed
<
CanonicalBrowsingContext
>
CanonicalBrowsingContext
:
:
GetParentCrossChromeBoundary
(
)
{
if
(
GetParent
(
)
)
{
return
do_AddRef
(
Cast
(
GetParent
(
)
)
)
;
}
if
(
GetEmbedderElement
(
)
)
{
return
do_AddRef
(
Cast
(
GetEmbedderElement
(
)
-
>
OwnerDoc
(
)
-
>
GetBrowsingContext
(
)
)
)
;
}
return
nullptr
;
}
already_AddRefed
<
CanonicalBrowsingContext
>
CanonicalBrowsingContext
:
:
TopCrossChromeBoundary
(
)
{
RefPtr
<
CanonicalBrowsingContext
>
bc
(
this
)
;
while
(
RefPtr
<
CanonicalBrowsingContext
>
parent
=
bc
-
>
GetParentCrossChromeBoundary
(
)
)
{
bc
=
parent
.
forget
(
)
;
}
return
bc
.
forget
(
)
;
}
Nullable
<
WindowProxyHolder
>
CanonicalBrowsingContext
:
:
GetTopChromeWindow
(
)
{
RefPtr
<
CanonicalBrowsingContext
>
bc
=
TopCrossChromeBoundary
(
)
;
if
(
bc
-
>
IsChrome
(
)
)
{
return
WindowProxyHolder
(
bc
.
forget
(
)
)
;
}
return
nullptr
;
}
nsISHistory
*
CanonicalBrowsingContext
:
:
GetSessionHistory
(
)
{
if
(
!
IsTop
(
)
)
{
return
Cast
(
Top
(
)
)
-
>
GetSessionHistory
(
)
;
}
if
(
!
mSessionHistory
&
&
GetChildSessionHistory
(
)
)
{
mSessionHistory
=
new
nsSHistory
(
this
)
;
}
return
mSessionHistory
;
}
SessionHistoryEntry
*
CanonicalBrowsingContext
:
:
GetActiveSessionHistoryEntry
(
)
{
return
mActiveEntry
;
}
void
CanonicalBrowsingContext
:
:
SetActiveSessionHistoryEntry
(
SessionHistoryEntry
*
aEntry
)
{
mActiveEntry
=
aEntry
;
}
bool
CanonicalBrowsingContext
:
:
HasHistoryEntry
(
nsISHEntry
*
aEntry
)
{
return
aEntry
&
&
mActiveEntry
=
=
aEntry
;
}
void
CanonicalBrowsingContext
:
:
SwapHistoryEntries
(
nsISHEntry
*
aOldEntry
nsISHEntry
*
aNewEntry
)
{
if
(
mActiveEntry
=
=
aOldEntry
)
{
nsCOMPtr
<
SessionHistoryEntry
>
newEntry
=
do_QueryInterface
(
aNewEntry
)
;
mActiveEntry
=
newEntry
.
forget
(
)
;
}
}
void
CanonicalBrowsingContext
:
:
AddLoadingSessionHistoryEntry
(
uint64_t
aLoadId
SessionHistoryEntry
*
aEntry
)
{
Unused
<
<
SetHistoryID
(
aEntry
-
>
DocshellID
(
)
)
;
mLoadingEntries
.
AppendElement
(
LoadingSessionHistoryEntry
{
aLoadId
aEntry
}
)
;
}
void
CanonicalBrowsingContext
:
:
GetLoadingSessionHistoryInfoFromParent
(
Maybe
<
LoadingSessionHistoryInfo
>
&
aLoadingInfo
int32_t
*
aRequestedIndex
int32_t
*
aLength
)
{
*
aRequestedIndex
=
-
1
;
*
aLength
=
0
;
nsISHistory
*
shistory
=
GetSessionHistory
(
)
;
if
(
!
shistory
|
|
!
GetParent
(
)
)
{
return
;
}
SessionHistoryEntry
*
parentSHE
=
GetParent
(
)
-
>
Canonical
(
)
-
>
GetActiveSessionHistoryEntry
(
)
;
if
(
parentSHE
)
{
int32_t
index
=
-
1
;
for
(
BrowsingContext
*
sibling
:
GetParent
(
)
-
>
Children
(
)
)
{
+
+
index
;
if
(
sibling
=
=
this
)
{
nsCOMPtr
<
nsISHEntry
>
shEntry
;
parentSHE
-
>
GetChildSHEntryIfHasNoDynamicallyAddedChild
(
index
getter_AddRefs
(
shEntry
)
)
;
nsCOMPtr
<
SessionHistoryEntry
>
she
=
do_QueryInterface
(
shEntry
)
;
if
(
she
)
{
aLoadingInfo
.
emplace
(
she
)
;
mLoadingEntries
.
AppendElement
(
LoadingSessionHistoryEntry
{
aLoadingInfo
.
value
(
)
.
mLoadId
she
.
get
(
)
}
)
;
*
aRequestedIndex
=
shistory
-
>
GetRequestedIndex
(
)
;
*
aLength
=
shistory
-
>
GetCount
(
)
;
Unused
<
<
SetHistoryID
(
she
-
>
DocshellID
(
)
)
;
}
break
;
}
}
}
}
UniquePtr
<
LoadingSessionHistoryInfo
>
CanonicalBrowsingContext
:
:
CreateLoadingSessionHistoryEntryForLoad
(
nsDocShellLoadState
*
aLoadState
nsIChannel
*
aChannel
)
{
RefPtr
<
SessionHistoryEntry
>
entry
;
const
LoadingSessionHistoryInfo
*
existingLoadingInfo
=
aLoadState
-
>
GetLoadingSessionHistoryInfo
(
)
;
if
(
existingLoadingInfo
)
{
entry
=
SessionHistoryEntry
:
:
GetByLoadId
(
existingLoadingInfo
-
>
mLoadId
)
;
MOZ_LOG
(
gSHLog
LogLevel
:
:
Verbose
(
"
SHEntry
:
:
GetByLoadId
(
%
"
PRIu64
"
)
-
>
%
p
"
existingLoadingInfo
-
>
mLoadId
entry
.
get
(
)
)
)
;
if
(
!
entry
)
{
return
nullptr
;
}
Unused
<
<
SetHistoryEntryCount
(
entry
-
>
BCHistoryLength
(
)
)
;
}
else
{
entry
=
new
SessionHistoryEntry
(
aLoadState
aChannel
)
;
if
(
IsTop
(
)
)
{
entry
-
>
SetPersist
(
nsDocShell
:
:
ShouldAddToSessionHistory
(
aLoadState
-
>
URI
(
)
aChannel
)
)
;
}
else
if
(
mActiveEntry
|
|
!
mLoadingEntries
.
IsEmpty
(
)
)
{
entry
-
>
SetIsSubFrame
(
true
)
;
}
entry
-
>
SetDocshellID
(
GetHistoryID
(
)
)
;
entry
-
>
SetIsDynamicallyAdded
(
CreatedDynamically
(
)
)
;
entry
-
>
SetForInitialLoad
(
true
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
entry
)
;
UniquePtr
<
LoadingSessionHistoryInfo
>
loadingInfo
;
if
(
existingLoadingInfo
)
{
loadingInfo
=
MakeUnique
<
LoadingSessionHistoryInfo
>
(
*
existingLoadingInfo
)
;
}
else
{
loadingInfo
=
MakeUnique
<
LoadingSessionHistoryInfo
>
(
entry
)
;
mLoadingEntries
.
AppendElement
(
LoadingSessionHistoryEntry
{
loadingInfo
-
>
mLoadId
entry
}
)
;
}
MOZ_ASSERT
(
SessionHistoryEntry
:
:
GetByLoadId
(
loadingInfo
-
>
mLoadId
)
=
=
entry
)
;
return
loadingInfo
;
}
UniquePtr
<
LoadingSessionHistoryInfo
>
CanonicalBrowsingContext
:
:
ReplaceLoadingSessionHistoryEntryForLoad
(
LoadingSessionHistoryInfo
*
aInfo
nsIChannel
*
aChannel
)
{
MOZ_ASSERT
(
aInfo
)
;
MOZ_ASSERT
(
aChannel
)
;
UniquePtr
<
SessionHistoryInfo
>
newInfo
=
MakeUnique
<
SessionHistoryInfo
>
(
aChannel
aInfo
-
>
mInfo
.
LoadType
(
)
aInfo
-
>
mInfo
.
GetPartitionedPrincipalToInherit
(
)
aInfo
-
>
mInfo
.
GetCsp
(
)
)
;
RefPtr
<
SessionHistoryEntry
>
newEntry
=
new
SessionHistoryEntry
(
newInfo
.
get
(
)
)
;
if
(
IsTop
(
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
newEntry
-
>
SetPersist
(
nsDocShell
:
:
ShouldAddToSessionHistory
(
uri
aChannel
)
)
;
}
else
{
newEntry
-
>
SetIsSubFrame
(
aInfo
-
>
mInfo
.
IsSubFrame
(
)
)
;
}
newEntry
-
>
SetDocshellID
(
GetHistoryID
(
)
)
;
newEntry
-
>
SetIsDynamicallyAdded
(
CreatedDynamically
(
)
)
;
SessionHistoryEntry
:
:
SetByLoadId
(
aInfo
-
>
mLoadId
newEntry
)
;
bool
forInitialLoad
=
true
;
for
(
size_t
i
=
0
;
i
<
mLoadingEntries
.
Length
(
)
;
+
+
i
)
{
if
(
mLoadingEntries
[
i
]
.
mLoadId
=
=
aInfo
-
>
mLoadId
)
{
forInitialLoad
=
mLoadingEntries
[
i
]
.
mEntry
-
>
ForInitialLoad
(
)
;
mLoadingEntries
[
i
]
.
mEntry
=
newEntry
;
break
;
}
}
newEntry
-
>
SetForInitialLoad
(
forInitialLoad
)
;
return
MakeUnique
<
LoadingSessionHistoryInfo
>
(
newEntry
aInfo
-
>
mLoadId
)
;
}
#
ifdef
NS_PRINTING
class
PrintListenerAdapter
final
:
public
nsIWebProgressListener
{
public
:
explicit
PrintListenerAdapter
(
Promise
*
aPromise
)
:
mPromise
(
aPromise
)
{
}
NS_DECL_ISUPPORTS
NS_IMETHOD
OnStateChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aStateFlags
nsresult
aStatus
)
override
{
if
(
aStateFlags
&
nsIWebProgressListener
:
:
STATE_STOP
&
&
aStateFlags
&
nsIWebProgressListener
:
:
STATE_IS_DOCUMENT
&
&
mPromise
)
{
mPromise
-
>
MaybeResolveWithUndefined
(
)
;
mPromise
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHOD
OnStatusChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsresult
aStatus
const
char16_t
*
aMessage
)
override
{
if
(
aStatus
!
=
NS_OK
&
&
mPromise
)
{
mPromise
-
>
MaybeReject
(
ErrorResult
(
aStatus
)
)
;
mPromise
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHOD
OnProgressChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
int32_t
aCurSelfProgress
int32_t
aMaxSelfProgress
int32_t
aCurTotalProgress
int32_t
aMaxTotalProgress
)
override
{
return
NS_OK
;
}
NS_IMETHOD
OnLocationChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsIURI
*
aLocation
uint32_t
aFlags
)
override
{
return
NS_OK
;
}
NS_IMETHOD
OnSecurityChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aState
)
override
{
return
NS_OK
;
}
NS_IMETHOD
OnContentBlockingEvent
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aEvent
)
override
{
return
NS_OK
;
}
private
:
~
PrintListenerAdapter
(
)
=
default
;
RefPtr
<
Promise
>
mPromise
;
}
;
NS_IMPL_ISUPPORTS
(
PrintListenerAdapter
nsIWebProgressListener
)
#
endif
already_AddRefed
<
Promise
>
CanonicalBrowsingContext
:
:
Print
(
nsIPrintSettings
*
aPrintSettings
ErrorResult
&
aRv
)
{
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
GetIncumbentGlobal
(
)
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
promise
.
forget
(
)
;
}
#
ifndef
NS_PRINTING
promise
-
>
MaybeReject
(
ErrorResult
(
NS_ERROR_NOT_AVAILABLE
)
)
;
return
promise
.
forget
(
)
;
#
else
auto
listener
=
MakeRefPtr
<
PrintListenerAdapter
>
(
promise
)
;
if
(
IsInProcess
(
)
)
{
RefPtr
<
nsGlobalWindowOuter
>
outerWindow
=
nsGlobalWindowOuter
:
:
Cast
(
GetDOMWindow
(
)
)
;
if
(
NS_WARN_IF
(
!
outerWindow
)
)
{
promise
-
>
MaybeReject
(
ErrorResult
(
NS_ERROR_FAILURE
)
)
;
return
promise
.
forget
(
)
;
}
ErrorResult
rv
;
outerWindow
-
>
Print
(
aPrintSettings
listener
nullptr
nsGlobalWindowOuter
:
:
IsPreview
:
:
No
nsGlobalWindowOuter
:
:
IsForWindowDotPrint
:
:
No
nullptr
rv
)
;
if
(
rv
.
Failed
(
)
)
{
promise
-
>
MaybeReject
(
std
:
:
move
(
rv
)
)
;
}
return
promise
.
forget
(
)
;
}
auto
*
browserParent
=
GetBrowserParent
(
)
;
if
(
NS_WARN_IF
(
!
browserParent
)
)
{
promise
-
>
MaybeReject
(
ErrorResult
(
NS_ERROR_FAILURE
)
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
embedding
:
:
PrintingParent
>
printingParent
=
browserParent
-
>
Manager
(
)
-
>
GetPrintingParent
(
)
;
embedding
:
:
PrintData
printData
;
nsresult
rv
=
printingParent
-
>
SerializeAndEnsureRemotePrintJob
(
aPrintSettings
listener
nullptr
&
printData
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
promise
-
>
MaybeReject
(
ErrorResult
(
rv
)
)
;
return
promise
.
forget
(
)
;
}
if
(
NS_WARN_IF
(
!
browserParent
-
>
SendPrint
(
this
printData
)
)
)
{
promise
-
>
MaybeReject
(
ErrorResult
(
NS_ERROR_FAILURE
)
)
;
}
return
promise
.
forget
(
)
;
#
endif
}
void
CanonicalBrowsingContext
:
:
CallOnAllTopDescendants
(
const
std
:
:
function
<
mozilla
:
:
CallState
(
CanonicalBrowsingContext
*
)
>
&
aCallback
)
{
#
ifdef
DEBUG
RefPtr
<
CanonicalBrowsingContext
>
parent
=
GetParentCrossChromeBoundary
(
)
;
MOZ_ASSERT
(
!
parent
"
Should
only
call
on
top
chrome
BC
"
)
;
#
endif
nsTArray
<
RefPtr
<
BrowsingContextGroup
>
>
groups
;
BrowsingContextGroup
:
:
GetAllGroups
(
groups
)
;
for
(
auto
&
browsingContextGroup
:
groups
)
{
for
(
auto
&
bc
:
browsingContextGroup
-
>
Toplevels
(
)
)
{
if
(
bc
=
=
this
)
{
continue
;
}
RefPtr
<
CanonicalBrowsingContext
>
top
=
bc
-
>
Canonical
(
)
-
>
TopCrossChromeBoundary
(
)
;
if
(
top
=
=
this
)
{
if
(
aCallback
(
bc
-
>
Canonical
(
)
)
=
=
CallState
:
:
Stop
)
{
return
;
}
}
}
}
}
void
CanonicalBrowsingContext
:
:
SessionHistoryCommit
(
uint64_t
aLoadId
const
nsID
&
aChangeID
uint32_t
aLoadType
bool
aPersist
bool
aCloneEntryChildren
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Verbose
(
"
CanonicalBrowsingContext
:
:
SessionHistoryCommit
%
p
%
"
PRIu64
this
aLoadId
)
)
;
for
(
size_t
i
=
0
;
i
<
mLoadingEntries
.
Length
(
)
;
+
+
i
)
{
if
(
mLoadingEntries
[
i
]
.
mLoadId
=
=
aLoadId
)
{
nsSHistory
*
shistory
=
static_cast
<
nsSHistory
*
>
(
GetSessionHistory
(
)
)
;
if
(
!
shistory
)
{
SessionHistoryEntry
:
:
RemoveLoadId
(
aLoadId
)
;
mLoadingEntries
.
RemoveElementAt
(
i
)
;
return
;
}
CallerWillNotifyHistoryIndexAndLengthChanges
caller
(
shistory
)
;
RefPtr
<
SessionHistoryEntry
>
newActiveEntry
=
mLoadingEntries
[
i
]
.
mEntry
;
bool
loadFromSessionHistory
=
!
newActiveEntry
-
>
ForInitialLoad
(
)
;
newActiveEntry
-
>
SetForInitialLoad
(
false
)
;
SessionHistoryEntry
:
:
RemoveLoadId
(
aLoadId
)
;
mLoadingEntries
.
RemoveElementAt
(
i
)
;
nsAutoString
nameOfNewEntry
;
newActiveEntry
-
>
GetName
(
nameOfNewEntry
)
;
if
(
!
nameOfNewEntry
.
IsEmpty
(
)
)
{
nsSHistory
:
:
WalkContiguousEntries
(
newActiveEntry
[
]
(
nsISHEntry
*
aEntry
)
{
aEntry
-
>
SetName
(
EmptyString
(
)
)
;
}
)
;
}
bool
addEntry
=
ShouldUpdateSessionHistory
(
aLoadType
)
;
if
(
IsTop
(
)
)
{
if
(
mActiveEntry
&
&
!
mActiveEntry
-
>
GetFrameLoader
(
)
)
{
bool
sharesDocument
=
true
;
mActiveEntry
-
>
SharesDocumentWith
(
newActiveEntry
&
sharesDocument
)
;
if
(
!
sharesDocument
)
{
RemoveDynEntriesFromActiveSessionHistoryEntry
(
)
;
}
}
mActiveEntry
=
newActiveEntry
;
if
(
LOAD_TYPE_HAS_FLAGS
(
aLoadType
nsIWebNavigation
:
:
LOAD_FLAGS_REPLACE_HISTORY
)
)
{
int32_t
index
=
shistory
-
>
GetIndexForReplace
(
)
;
addEntry
=
index
<
0
;
if
(
!
addEntry
)
{
shistory
-
>
ReplaceEntry
(
index
mActiveEntry
)
;
}
}
if
(
loadFromSessionHistory
)
{
shistory
-
>
UpdateIndex
(
)
;
}
else
if
(
addEntry
)
{
shistory
-
>
AddEntry
(
mActiveEntry
aPersist
)
;
}
}
else
{
if
(
loadFromSessionHistory
)
{
if
(
mActiveEntry
)
{
mActiveEntry
-
>
SyncTreesForSubframeNavigation
(
newActiveEntry
Top
(
)
this
)
;
}
mActiveEntry
=
newActiveEntry
;
shistory
-
>
UpdateIndex
(
)
;
}
else
if
(
addEntry
)
{
if
(
mActiveEntry
)
{
if
(
LOAD_TYPE_HAS_FLAGS
(
aLoadType
nsIWebNavigation
:
:
LOAD_FLAGS_REPLACE_HISTORY
)
)
{
mActiveEntry
-
>
ReplaceWith
(
*
newActiveEntry
)
;
}
else
{
shistory
-
>
AddChildSHEntryHelper
(
mActiveEntry
newActiveEntry
Top
(
)
aCloneEntryChildren
)
;
mActiveEntry
=
newActiveEntry
;
}
}
else
{
SessionHistoryEntry
*
parentEntry
=
GetParent
(
)
-
>
mActiveEntry
;
if
(
parentEntry
)
{
mActiveEntry
=
newActiveEntry
;
parentEntry
-
>
AddChild
(
mActiveEntry
CreatedDynamically
(
)
?
-
1
:
GetParent
(
)
-
>
IndexOf
(
this
)
IsInProcess
(
)
)
;
}
}
}
}
ResetSHEntryHasUserInteractionCache
(
)
;
HistoryCommitIndexAndLength
(
aChangeID
caller
)
;
shistory
-
>
LogHistory
(
)
;
return
;
}
}
}
static
already_AddRefed
<
nsDocShellLoadState
>
CreateLoadInfo
(
SessionHistoryEntry
*
aEntry
)
{
const
SessionHistoryInfo
&
info
=
aEntry
-
>
Info
(
)
;
RefPtr
<
nsDocShellLoadState
>
loadState
(
new
nsDocShellLoadState
(
info
.
GetURI
(
)
)
)
;
info
.
FillLoadInfo
(
*
loadState
)
;
UniquePtr
<
LoadingSessionHistoryInfo
>
loadingInfo
;
loadingInfo
=
MakeUnique
<
LoadingSessionHistoryInfo
>
(
aEntry
)
;
loadState
-
>
SetLoadingSessionHistoryInfo
(
std
:
:
move
(
loadingInfo
)
)
;
return
loadState
.
forget
(
)
;
}
void
CanonicalBrowsingContext
:
:
NotifyOnHistoryReload
(
bool
aForceReload
bool
&
aCanReload
Maybe
<
RefPtr
<
nsDocShellLoadState
>
>
&
aLoadState
Maybe
<
bool
>
&
aReloadActiveEntry
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aLoadState
)
;
aCanReload
=
true
;
nsISHistory
*
shistory
=
GetSessionHistory
(
)
;
NS_ENSURE_TRUE_VOID
(
shistory
)
;
shistory
-
>
NotifyOnHistoryReload
(
&
aCanReload
)
;
if
(
!
aCanReload
)
{
return
;
}
if
(
mActiveEntry
)
{
aLoadState
.
emplace
(
CreateLoadInfo
(
mActiveEntry
)
)
;
aReloadActiveEntry
.
emplace
(
true
)
;
if
(
aForceReload
)
{
shistory
-
>
RemoveFrameEntries
(
mActiveEntry
)
;
}
}
else
if
(
!
mLoadingEntries
.
IsEmpty
(
)
)
{
const
LoadingSessionHistoryEntry
&
loadingEntry
=
mLoadingEntries
.
LastElement
(
)
;
aLoadState
.
emplace
(
CreateLoadInfo
(
loadingEntry
.
mEntry
)
)
;
aReloadActiveEntry
.
emplace
(
false
)
;
if
(
aForceReload
)
{
SessionHistoryEntry
*
entry
=
SessionHistoryEntry
:
:
GetByLoadId
(
loadingEntry
.
mLoadId
)
;
if
(
entry
)
{
shistory
-
>
RemoveFrameEntries
(
entry
)
;
}
}
}
if
(
aLoadState
)
{
int32_t
index
=
0
;
int32_t
requestedIndex
=
-
1
;
int32_t
length
=
0
;
shistory
-
>
GetIndex
(
&
index
)
;
shistory
-
>
GetRequestedIndex
(
&
requestedIndex
)
;
shistory
-
>
GetCount
(
&
length
)
;
aLoadState
.
ref
(
)
-
>
SetLoadIsFromSessionHistory
(
requestedIndex
>
=
0
?
requestedIndex
:
index
length
aReloadActiveEntry
.
value
(
)
)
;
}
}
void
CanonicalBrowsingContext
:
:
SetActiveSessionHistoryEntry
(
const
Maybe
<
nsPoint
>
&
aPreviousScrollPos
SessionHistoryInfo
*
aInfo
uint32_t
aLoadType
uint32_t
aUpdatedCacheKey
const
nsID
&
aChangeID
)
{
nsISHistory
*
shistory
=
GetSessionHistory
(
)
;
if
(
!
shistory
)
{
return
;
}
CallerWillNotifyHistoryIndexAndLengthChanges
caller
(
shistory
)
;
RefPtr
<
SessionHistoryEntry
>
oldActiveEntry
=
mActiveEntry
;
if
(
aPreviousScrollPos
.
isSome
(
)
&
&
oldActiveEntry
)
{
oldActiveEntry
-
>
SetScrollPosition
(
aPreviousScrollPos
.
ref
(
)
.
x
aPreviousScrollPos
.
ref
(
)
.
y
)
;
}
mActiveEntry
=
new
SessionHistoryEntry
(
aInfo
)
;
mActiveEntry
-
>
SetDocshellID
(
GetHistoryID
(
)
)
;
mActiveEntry
-
>
AdoptBFCacheEntry
(
oldActiveEntry
)
;
if
(
aUpdatedCacheKey
!
=
0
)
{
mActiveEntry
-
>
SharedInfo
(
)
-
>
mCacheKey
=
aUpdatedCacheKey
;
}
if
(
IsTop
(
)
)
{
Maybe
<
int32_t
>
previousEntryIndex
loadedEntryIndex
;
shistory
-
>
AddToRootSessionHistory
(
true
oldActiveEntry
this
mActiveEntry
aLoadType
nsDocShell
:
:
ShouldAddToSessionHistory
(
aInfo
-
>
GetURI
(
)
nullptr
)
&
previousEntryIndex
&
loadedEntryIndex
)
;
}
else
{
if
(
oldActiveEntry
)
{
shistory
-
>
AddChildSHEntryHelper
(
oldActiveEntry
mActiveEntry
Top
(
)
true
)
;
}
else
if
(
GetParent
(
)
&
&
GetParent
(
)
-
>
mActiveEntry
)
{
GetParent
(
)
-
>
mActiveEntry
-
>
AddChild
(
mActiveEntry
CreatedDynamically
(
)
?
-
1
:
GetParent
(
)
-
>
IndexOf
(
this
)
UseRemoteSubframes
(
)
)
;
}
}
ResetSHEntryHasUserInteractionCache
(
)
;
HistoryCommitIndexAndLength
(
aChangeID
caller
)
;
static_cast
<
nsSHistory
*
>
(
shistory
)
-
>
LogHistory
(
)
;
}
void
CanonicalBrowsingContext
:
:
ReplaceActiveSessionHistoryEntry
(
SessionHistoryInfo
*
aInfo
)
{
if
(
!
mActiveEntry
)
{
return
;
}
mActiveEntry
-
>
SetInfo
(
aInfo
)
;
nsSHistory
*
shistory
=
static_cast
<
nsSHistory
*
>
(
GetSessionHistory
(
)
)
;
if
(
shistory
)
{
shistory
-
>
NotifyOnHistoryReplaceEntry
(
)
;
shistory
-
>
UpdateRootBrowsingContextState
(
)
;
}
ResetSHEntryHasUserInteractionCache
(
)
;
}
void
CanonicalBrowsingContext
:
:
RemoveDynEntriesFromActiveSessionHistoryEntry
(
)
{
nsISHistory
*
shistory
=
GetSessionHistory
(
)
;
NS_ENSURE_TRUE_VOID
(
shistory
)
;
nsCOMPtr
<
nsISHEntry
>
root
=
nsSHistory
:
:
GetRootSHEntry
(
mActiveEntry
)
;
shistory
-
>
RemoveDynEntries
(
shistory
-
>
GetIndexOfEntry
(
root
)
mActiveEntry
)
;
}
void
CanonicalBrowsingContext
:
:
RemoveFromSessionHistory
(
const
nsID
&
aChangeID
)
{
nsSHistory
*
shistory
=
static_cast
<
nsSHistory
*
>
(
GetSessionHistory
(
)
)
;
if
(
shistory
)
{
CallerWillNotifyHistoryIndexAndLengthChanges
caller
(
shistory
)
;
nsCOMPtr
<
nsISHEntry
>
root
=
nsSHistory
:
:
GetRootSHEntry
(
mActiveEntry
)
;
bool
didRemove
;
AutoTArray
<
nsID
16
>
ids
(
{
GetHistoryID
(
)
}
)
;
shistory
-
>
RemoveEntries
(
ids
shistory
-
>
GetIndexOfEntry
(
root
)
&
didRemove
)
;
if
(
didRemove
)
{
BrowsingContext
*
rootBC
=
shistory
-
>
GetBrowsingContext
(
)
;
if
(
rootBC
)
{
if
(
!
rootBC
-
>
IsInProcess
(
)
)
{
Unused
<
<
rootBC
-
>
Canonical
(
)
-
>
GetContentParent
(
)
-
>
SendDispatchLocationChangeEvent
(
rootBC
)
;
}
else
if
(
rootBC
-
>
GetDocShell
(
)
)
{
rootBC
-
>
GetDocShell
(
)
-
>
DispatchLocationChangeEvent
(
)
;
}
}
}
HistoryCommitIndexAndLength
(
aChangeID
caller
)
;
}
}
void
CanonicalBrowsingContext
:
:
HistoryGo
(
int32_t
aOffset
uint64_t
aHistoryEpoch
bool
aRequireUserInteraction
Maybe
<
ContentParentId
>
aContentId
std
:
:
function
<
void
(
int32_t
&
&
)
>
&
&
aResolver
)
{
if
(
aRequireUserInteraction
&
&
aOffset
!
=
-
1
&
&
aOffset
!
=
1
)
{
NS_ERROR
(
"
aRequireUserInteraction
may
only
be
used
with
an
offset
of
-
1
or
1
"
)
;
return
;
}
nsSHistory
*
shistory
=
static_cast
<
nsSHistory
*
>
(
GetSessionHistory
(
)
)
;
if
(
!
shistory
)
{
return
;
}
CheckedInt
<
int32_t
>
index
=
shistory
-
>
GetRequestedIndex
(
)
>
=
0
?
shistory
-
>
GetRequestedIndex
(
)
:
shistory
-
>
Index
(
)
;
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
HistoryGo
(
%
d
-
>
%
d
)
epoch
%
"
PRIu64
"
/
id
%
"
PRIu64
aOffset
(
index
+
aOffset
)
.
value
(
)
aHistoryEpoch
(
uint64_t
)
(
aContentId
.
isSome
(
)
?
aContentId
.
value
(
)
:
0
)
)
)
;
while
(
true
)
{
index
+
=
aOffset
;
if
(
!
index
.
isValid
(
)
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
Invalid
index
"
)
)
;
return
;
}
if
(
!
aRequireUserInteraction
|
|
index
.
value
(
)
>
=
shistory
-
>
Length
(
)
-
1
|
|
index
.
value
(
)
<
=
0
)
{
break
;
}
if
(
shistory
-
>
HasUserInteractionAtIndex
(
index
.
value
(
)
)
)
{
break
;
}
}
uint64_t
epoch
;
bool
sameEpoch
=
false
;
Maybe
<
ContentParentId
>
id
;
shistory
-
>
GetEpoch
(
epoch
id
)
;
if
(
aContentId
=
=
id
&
&
epoch
>
=
aHistoryEpoch
)
{
sameEpoch
=
true
;
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
Same
epoch
/
id
"
)
)
;
}
nsTArray
<
nsSHistory
:
:
LoadEntryResult
>
loadResults
;
nsresult
rv
=
shistory
-
>
GotoIndex
(
index
.
value
(
)
loadResults
sameEpoch
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
Dropping
HistoryGo
-
bad
index
or
same
epoch
(
not
in
same
doc
)
"
)
)
;
return
;
}
if
(
epoch
<
aHistoryEpoch
|
|
aContentId
!
=
id
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
Set
epoch
"
)
)
;
shistory
-
>
SetEpoch
(
aHistoryEpoch
aContentId
)
;
}
aResolver
(
shistory
-
>
GetRequestedIndex
(
)
)
;
nsSHistory
:
:
LoadURIs
(
loadResults
)
;
}
JSObject
*
CanonicalBrowsingContext
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
CanonicalBrowsingContext_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
CanonicalBrowsingContext
:
:
DispatchWheelZoomChange
(
bool
aIncrease
)
{
Element
*
element
=
Top
(
)
-
>
GetEmbedderElement
(
)
;
if
(
!
element
)
{
return
;
}
auto
event
=
aIncrease
?
u
"
DoZoomEnlargeBy10
"
_ns
:
u
"
DoZoomReduceBy10
"
_ns
;
auto
dispatcher
=
MakeRefPtr
<
AsyncEventDispatcher
>
(
element
event
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eYes
)
;
dispatcher
-
>
PostDOMEvent
(
)
;
}
void
CanonicalBrowsingContext
:
:
CanonicalDiscard
(
)
{
if
(
mTabMediaController
)
{
mTabMediaController
-
>
Shutdown
(
)
;
mTabMediaController
=
nullptr
;
}
if
(
mWebProgress
)
{
RefPtr
<
BrowsingContextWebProgress
>
progress
=
mWebProgress
;
progress
-
>
ContextDiscarded
(
)
;
}
if
(
IsTop
(
)
)
{
BackgroundSessionStorageManager
:
:
RemoveManager
(
Id
(
)
)
;
}
}
void
CanonicalBrowsingContext
:
:
NotifyStartDelayedAutoplayMedia
(
)
{
WindowContext
*
windowContext
=
GetCurrentWindowContext
(
)
;
if
(
!
windowContext
)
{
return
;
}
windowContext
-
>
NotifyUserGestureActivation
(
)
;
AUTOPLAY_LOG
(
"
NotifyStartDelayedAutoplayMedia
for
chrome
bc
0x
%
08
"
PRIx64
Id
(
)
)
;
StartDelayedAutoplayMediaComponents
(
)
;
Group
(
)
-
>
EachParent
(
[
&
]
(
ContentParent
*
aParent
)
{
Unused
<
<
aParent
-
>
SendStartDelayedAutoplayMediaComponents
(
this
)
;
}
)
;
}
void
CanonicalBrowsingContext
:
:
NotifyMediaMutedChanged
(
bool
aMuted
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
GetParent
(
)
"
Notify
media
mute
change
on
non
top
-
level
context
!
"
)
;
SetMuted
(
aMuted
aRv
)
;
}
uint32_t
CanonicalBrowsingContext
:
:
CountSiteOrigins
(
GlobalObject
&
aGlobal
const
Sequence
<
OwningNonNull
<
BrowsingContext
>
>
&
aRoots
)
{
nsTHashSet
<
nsCString
>
uniqueSiteOrigins
;
for
(
const
auto
&
root
:
aRoots
)
{
root
-
>
PreOrderWalk
(
[
&
]
(
BrowsingContext
*
aContext
)
{
WindowGlobalParent
*
windowGlobalParent
=
aContext
-
>
Canonical
(
)
-
>
GetCurrentWindowGlobal
(
)
;
if
(
windowGlobalParent
)
{
nsIPrincipal
*
documentPrincipal
=
windowGlobalParent
-
>
DocumentPrincipal
(
)
;
bool
isContentPrincipal
=
documentPrincipal
-
>
GetIsContentPrincipal
(
)
;
if
(
isContentPrincipal
)
{
nsCString
siteOrigin
;
documentPrincipal
-
>
GetSiteOrigin
(
siteOrigin
)
;
uniqueSiteOrigins
.
Insert
(
siteOrigin
)
;
}
}
}
)
;
}
return
uniqueSiteOrigins
.
Count
(
)
;
}
void
CanonicalBrowsingContext
:
:
UpdateMediaControlAction
(
const
MediaControlAction
&
aAction
)
{
if
(
IsDiscarded
(
)
)
{
return
;
}
ContentMediaControlKeyHandler
:
:
HandleMediaControlAction
(
this
aAction
)
;
Group
(
)
-
>
EachParent
(
[
&
]
(
ContentParent
*
aParent
)
{
Unused
<
<
aParent
-
>
SendUpdateMediaControlAction
(
this
aAction
)
;
}
)
;
}
void
CanonicalBrowsingContext
:
:
LoadURI
(
const
nsAString
&
aURI
const
LoadURIOptions
&
aOptions
ErrorResult
&
aError
)
{
RefPtr
<
nsDocShellLoadState
>
loadState
;
nsresult
rv
=
nsDocShellLoadState
:
:
CreateFromLoadURIOptions
(
this
aURI
aOptions
getter_AddRefs
(
loadState
)
)
;
if
(
rv
=
=
NS_ERROR_MALFORMED_URI
)
{
DisplayLoadError
(
aURI
)
;
return
;
}
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
LoadURI
(
loadState
true
)
;
}
void
CanonicalBrowsingContext
:
:
GoBack
(
const
Optional
<
int32_t
>
&
aCancelContentJSEpoch
bool
aRequireUserInteraction
)
{
if
(
IsDiscarded
(
)
)
{
return
;
}
if
(
mCurrentLoad
)
{
mCurrentLoad
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
if
(
nsDocShell
*
docShell
=
nsDocShell
:
:
Cast
(
GetDocShell
(
)
)
)
{
if
(
aCancelContentJSEpoch
.
WasPassed
(
)
)
{
docShell
-
>
SetCancelContentJSEpoch
(
aCancelContentJSEpoch
.
Value
(
)
)
;
}
docShell
-
>
GoBack
(
aRequireUserInteraction
)
;
}
else
if
(
ContentParent
*
cp
=
GetContentParent
(
)
)
{
Maybe
<
int32_t
>
cancelContentJSEpoch
;
if
(
aCancelContentJSEpoch
.
WasPassed
(
)
)
{
cancelContentJSEpoch
=
Some
(
aCancelContentJSEpoch
.
Value
(
)
)
;
}
Unused
<
<
cp
-
>
SendGoBack
(
this
cancelContentJSEpoch
aRequireUserInteraction
)
;
}
}
void
CanonicalBrowsingContext
:
:
GoForward
(
const
Optional
<
int32_t
>
&
aCancelContentJSEpoch
bool
aRequireUserInteraction
)
{
if
(
IsDiscarded
(
)
)
{
return
;
}
if
(
mCurrentLoad
)
{
mCurrentLoad
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
if
(
auto
*
docShell
=
nsDocShell
:
:
Cast
(
GetDocShell
(
)
)
)
{
if
(
aCancelContentJSEpoch
.
WasPassed
(
)
)
{
docShell
-
>
SetCancelContentJSEpoch
(
aCancelContentJSEpoch
.
Value
(
)
)
;
}
docShell
-
>
GoForward
(
aRequireUserInteraction
)
;
}
else
if
(
ContentParent
*
cp
=
GetContentParent
(
)
)
{
Maybe
<
int32_t
>
cancelContentJSEpoch
;
if
(
aCancelContentJSEpoch
.
WasPassed
(
)
)
{
cancelContentJSEpoch
.
emplace
(
aCancelContentJSEpoch
.
Value
(
)
)
;
}
Unused
<
<
cp
-
>
SendGoForward
(
this
cancelContentJSEpoch
aRequireUserInteraction
)
;
}
}
void
CanonicalBrowsingContext
:
:
GoToIndex
(
int32_t
aIndex
const
Optional
<
int32_t
>
&
aCancelContentJSEpoch
)
{
if
(
IsDiscarded
(
)
)
{
return
;
}
if
(
mCurrentLoad
)
{
mCurrentLoad
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
if
(
auto
*
docShell
=
nsDocShell
:
:
Cast
(
GetDocShell
(
)
)
)
{
if
(
aCancelContentJSEpoch
.
WasPassed
(
)
)
{
docShell
-
>
SetCancelContentJSEpoch
(
aCancelContentJSEpoch
.
Value
(
)
)
;
}
docShell
-
>
GotoIndex
(
aIndex
)
;
}
else
if
(
ContentParent
*
cp
=
GetContentParent
(
)
)
{
Maybe
<
int32_t
>
cancelContentJSEpoch
;
if
(
aCancelContentJSEpoch
.
WasPassed
(
)
)
{
cancelContentJSEpoch
.
emplace
(
aCancelContentJSEpoch
.
Value
(
)
)
;
}
Unused
<
<
cp
-
>
SendGoToIndex
(
this
aIndex
cancelContentJSEpoch
)
;
}
}
void
CanonicalBrowsingContext
:
:
Reload
(
uint32_t
aReloadFlags
)
{
if
(
IsDiscarded
(
)
)
{
return
;
}
if
(
mCurrentLoad
)
{
mCurrentLoad
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
if
(
auto
*
docShell
=
nsDocShell
:
:
Cast
(
GetDocShell
(
)
)
)
{
docShell
-
>
Reload
(
aReloadFlags
)
;
}
else
if
(
ContentParent
*
cp
=
GetContentParent
(
)
)
{
Unused
<
<
cp
-
>
SendReload
(
this
aReloadFlags
)
;
}
}
void
CanonicalBrowsingContext
:
:
Stop
(
uint32_t
aStopFlags
)
{
if
(
IsDiscarded
(
)
)
{
return
;
}
if
(
mCurrentLoad
&
&
(
aStopFlags
&
nsIWebNavigation
:
:
STOP_NETWORK
)
)
{
mCurrentLoad
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
if
(
auto
*
docShell
=
nsDocShell
:
:
Cast
(
GetDocShell
(
)
)
)
{
docShell
-
>
Stop
(
aStopFlags
)
;
}
else
if
(
ContentParent
*
cp
=
GetContentParent
(
)
)
{
Unused
<
<
cp
-
>
SendStopLoad
(
this
aStopFlags
)
;
}
}
void
CanonicalBrowsingContext
:
:
PendingRemotenessChange
:
:
ProcessLaunched
(
)
{
if
(
!
mPromise
)
{
return
;
}
if
(
mContentParent
)
{
auto
found
=
mTarget
-
>
FindUnloadingHost
(
mContentParent
-
>
ChildID
(
)
)
;
if
(
found
!
=
mTarget
-
>
mUnloadingHosts
.
end
(
)
)
{
found
-
>
mCallbacks
.
AppendElement
(
[
self
=
RefPtr
{
this
}
]
(
)
{
self
-
>
ProcessReady
(
)
;
}
)
;
return
;
}
}
ProcessReady
(
)
;
}
void
CanonicalBrowsingContext
:
:
PendingRemotenessChange
:
:
ProcessReady
(
)
{
if
(
!
mPromise
)
{
return
;
}
if
(
mPrepareToChangePromise
)
{
mPrepareToChangePromise
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
=
RefPtr
{
this
}
]
(
bool
)
{
self
-
>
Finish
(
)
;
}
[
self
=
RefPtr
{
this
}
]
(
nsresult
aRv
)
{
self
-
>
Cancel
(
aRv
)
;
}
)
;
return
;
}
Finish
(
)
;
}
void
CanonicalBrowsingContext
:
:
PendingRemotenessChange
:
:
Finish
(
)
{
if
(
!
mPromise
)
{
return
;
}
nsresult
rv
=
mTarget
-
>
IsTopContent
(
)
?
FinishTopContent
(
)
:
FinishSubframe
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Error
finishing
PendingRemotenessChange
!
"
)
;
Cancel
(
rv
)
;
}
else
{
Clear
(
)
;
}
}
nsresult
CanonicalBrowsingContext
:
:
PendingRemotenessChange
:
:
FinishTopContent
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mTarget
-
>
IsTop
(
)
"
We
shouldn
'
t
be
trying
to
change
the
remoteness
of
"
"
non
-
remote
iframes
"
)
;
RefPtr
<
CanonicalBrowsingContext
>
target
(
mTarget
)
;
if
(
target
-
>
IsDiscarded
(
)
|
|
!
target
-
>
AncestorsAreCurrent
(
)
)
{
return
NS_ERROR_FAILURE
;
}
Element
*
browserElement
=
target
-
>
GetEmbedderElement
(
)
;
if
(
!
browserElement
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIBrowser
>
browser
=
browserElement
-
>
AsBrowser
(
)
;
if
(
!
browser
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsFrameLoaderOwner
>
frameLoaderOwner
=
do_QueryObject
(
browserElement
)
;
MOZ_RELEASE_ASSERT
(
frameLoaderOwner
"
embedder
browser
must
be
nsFrameLoaderOwner
"
)
;
nsresult
rv
=
browser
-
>
BeforeChangeRemoteness
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
browserElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
remote
mContentParent
?
u
"
true
"
_ns
:
u
"
false
"
_ns
true
)
;
ErrorResult
error
;
frameLoaderOwner
-
>
ChangeRemotenessToProcess
(
mContentParent
mOptions
mSpecificGroup
error
)
;
if
(
error
.
Failed
(
)
)
{
return
error
.
StealNSResult
(
)
;
}
bool
loadResumed
=
false
;
rv
=
browser
-
>
FinishChangeRemoteness
(
mPendingSwitchId
&
loadResumed
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
RefPtr
<
nsFrameLoader
>
frameLoader
=
frameLoaderOwner
-
>
GetFrameLoader
(
)
;
RefPtr
<
BrowserParent
>
newBrowser
=
frameLoader
-
>
GetBrowserParent
(
)
;
if
(
!
newBrowser
)
{
if
(
mContentParent
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
loadResumed
)
{
RefPtr
<
nsDocShell
>
newDocShell
=
frameLoader
-
>
GetDocShell
(
error
)
;
if
(
error
.
Failed
(
)
)
{
return
error
.
StealNSResult
(
)
;
}
rv
=
newDocShell
-
>
ResumeRedirectedLoad
(
mPendingSwitchId
-
1
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
}
else
if
(
!
loadResumed
)
{
newBrowser
-
>
ResumeLoad
(
mPendingSwitchId
)
;
}
mPromise
-
>
Resolve
(
newBrowser
__func__
)
;
return
NS_OK
;
}
nsresult
CanonicalBrowsingContext
:
:
PendingRemotenessChange
:
:
FinishSubframe
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mOptions
.
mReplaceBrowsingContext
"
Cannot
replace
BC
for
subframe
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mTarget
-
>
IsTop
(
)
)
;
RefPtr
<
CanonicalBrowsingContext
>
target
(
mTarget
)
;
if
(
target
-
>
IsDiscarded
(
)
|
|
!
target
-
>
AncestorsAreCurrent
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
mContentParent
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
WindowGlobalParent
>
embedderWindow
=
target
-
>
GetParentWindowContext
(
)
;
if
(
NS_WARN_IF
(
!
embedderWindow
)
|
|
NS_WARN_IF
(
!
embedderWindow
-
>
CanSend
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
BrowserParent
>
embedderBrowser
=
embedderWindow
-
>
GetBrowserParent
(
)
;
if
(
NS_WARN_IF
(
!
embedderBrowser
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
BrowserParent
>
oldBrowser
=
target
-
>
GetBrowserParent
(
)
;
target
-
>
SetCurrentBrowserParent
(
nullptr
)
;
bool
wasRemote
=
oldBrowser
&
&
oldBrowser
-
>
GetBrowsingContext
(
)
=
=
target
;
if
(
wasRemote
)
{
MOZ_DIAGNOSTIC_ASSERT
(
oldBrowser
!
=
embedderBrowser
)
;
MOZ_DIAGNOSTIC_ASSERT
(
oldBrowser
-
>
IsDestroyed
(
)
|
|
oldBrowser
-
>
GetBrowserBridgeParent
(
)
)
;
if
(
oldBrowser
-
>
CanSend
(
)
)
{
target
-
>
StartUnloadingHost
(
oldBrowser
-
>
Manager
(
)
-
>
ChildID
(
)
)
;
Unused
<
<
oldBrowser
-
>
SendWillChangeProcess
(
)
;
oldBrowser
-
>
Destroy
(
)
;
}
}
target
-
>
SetOwnerProcessId
(
mContentParent
-
>
ChildID
(
)
)
;
if
(
mContentParent
=
=
embedderBrowser
-
>
Manager
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPendingSwitchId
"
We
always
have
a
PendingSwitchId
except
for
print
-
preview
loads
"
"
which
will
never
perform
a
process
-
switch
to
being
in
-
process
with
"
"
their
embedder
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
wasRemote
"
Attempt
to
process
-
switch
from
local
to
local
?
"
)
;
target
-
>
SetCurrentBrowserParent
(
embedderBrowser
)
;
Unused
<
<
embedderWindow
-
>
SendMakeFrameLocal
(
target
mPendingSwitchId
)
;
mPromise
-
>
Resolve
(
embedderBrowser
__func__
)
;
return
NS_OK
;
}
target
-
>
SetCurrentBrowserParent
(
nullptr
)
;
MOZ_DIAGNOSTIC_ASSERT
(
target
-
>
UseRemoteTabs
(
)
&
&
target
-
>
UseRemoteSubframes
(
)
"
Not
supported
without
fission
"
)
;
uint32_t
chromeFlags
=
nsIWebBrowserChrome
:
:
CHROME_REMOTE_WINDOW
|
nsIWebBrowserChrome
:
:
CHROME_FISSION_WINDOW
;
if
(
target
-
>
UsePrivateBrowsing
(
)
)
{
chromeFlags
|
=
nsIWebBrowserChrome
:
:
CHROME_PRIVATE_WINDOW
;
}
nsCOMPtr
<
nsIPrincipal
>
initialPrincipal
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
target
-
>
OriginAttributesRef
(
)
false
)
;
WindowGlobalInit
windowInit
=
WindowGlobalActor
:
:
AboutBlankInitializer
(
target
initialPrincipal
)
;
TabId
tabId
(
nsContentUtils
:
:
GenerateTabId
(
)
)
;
RefPtr
<
BrowserBridgeParent
>
bridge
=
new
BrowserBridgeParent
(
)
;
nsresult
rv
=
bridge
-
>
InitWithProcess
(
embedderBrowser
mContentParent
windowInit
chromeFlags
tabId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
if
(
wasRemote
)
{
target
-
>
ShowSubframeCrashedUI
(
oldBrowser
-
>
GetBrowserBridgeParent
(
)
)
;
}
return
rv
;
}
RefPtr
<
BrowserParent
>
newBrowser
=
bridge
-
>
GetBrowserParent
(
)
;
{
Maybe
<
uint64_t
>
clearChildID
;
if
(
!
wasRemote
)
{
clearChildID
=
Some
(
embedderBrowser
-
>
Manager
(
)
-
>
ChildID
(
)
)
;
target
-
>
StartUnloadingHost
(
*
clearChildID
)
;
}
auto
callback
=
[
target
clearChildID
]
(
auto
&
&
)
{
if
(
clearChildID
)
{
target
-
>
ClearUnloadingHost
(
*
clearChildID
)
;
}
}
;
ManagedEndpoint
<
PBrowserBridgeChild
>
endpoint
=
embedderBrowser
-
>
OpenPBrowserBridgeEndpoint
(
bridge
)
;
MOZ_DIAGNOSTIC_ASSERT
(
endpoint
.
IsValid
(
)
)
;
embedderWindow
-
>
SendMakeFrameRemote
(
target
std
:
:
move
(
endpoint
)
tabId
newBrowser
-
>
GetLayersId
(
)
callback
callback
)
;
}
if
(
mPendingSwitchId
)
{
newBrowser
-
>
ResumeLoad
(
mPendingSwitchId
)
;
}
mPromise
-
>
Resolve
(
newBrowser
__func__
)
;
return
NS_OK
;
}
void
CanonicalBrowsingContext
:
:
PendingRemotenessChange
:
:
Cancel
(
nsresult
aRv
)
{
if
(
!
mPromise
)
{
return
;
}
mPromise
-
>
Reject
(
aRv
__func__
)
;
Clear
(
)
;
}
void
CanonicalBrowsingContext
:
:
PendingRemotenessChange
:
:
Clear
(
)
{
RefPtr
<
PendingRemotenessChange
>
kungFuDeathGrip
(
this
)
;
if
(
mTarget
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mTarget
-
>
mPendingRemotenessChange
=
=
this
)
;
mTarget
-
>
mPendingRemotenessChange
=
nullptr
;
}
if
(
mContentParent
)
{
mContentParent
-
>
RemoveKeepAlive
(
)
;
mContentParent
=
nullptr
;
}
if
(
mSpecificGroup
)
{
mSpecificGroup
-
>
RemoveKeepAlive
(
)
;
mSpecificGroup
=
nullptr
;
}
mPromise
=
nullptr
;
mTarget
=
nullptr
;
mPrepareToChangePromise
=
nullptr
;
}
CanonicalBrowsingContext
:
:
PendingRemotenessChange
:
:
PendingRemotenessChange
(
CanonicalBrowsingContext
*
aTarget
RemotenessPromise
:
:
Private
*
aPromise
uint64_t
aPendingSwitchId
const
RemotenessChangeOptions
&
aOptions
)
:
mTarget
(
aTarget
)
mPromise
(
aPromise
)
mPendingSwitchId
(
aPendingSwitchId
)
mOptions
(
aOptions
)
{
}
CanonicalBrowsingContext
:
:
PendingRemotenessChange
:
:
~
PendingRemotenessChange
(
)
{
MOZ_ASSERT
(
!
mPromise
&
&
!
mTarget
&
&
!
mContentParent
&
&
!
mSpecificGroup
&
&
!
mPrepareToChangePromise
"
should
'
ve
already
been
Cancel
(
)
or
Complete
(
)
-
ed
"
)
;
}
BrowserParent
*
CanonicalBrowsingContext
:
:
GetBrowserParent
(
)
const
{
return
mCurrentBrowserParent
;
}
void
CanonicalBrowsingContext
:
:
SetCurrentBrowserParent
(
BrowserParent
*
aBrowserParent
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mCurrentBrowserParent
|
|
!
aBrowserParent
"
BrowsingContext
already
has
a
current
BrowserParent
!
"
)
;
MOZ_DIAGNOSTIC_ASSERT_IF
(
aBrowserParent
aBrowserParent
-
>
CanSend
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT_IF
(
aBrowserParent
aBrowserParent
-
>
Manager
(
)
-
>
ChildID
(
)
=
=
mProcessId
)
;
MOZ_DIAGNOSTIC_ASSERT_IF
(
aBrowserParent
&
&
aBrowserParent
-
>
GetBrowsingContext
(
)
!
=
this
GetParentWindowContext
(
)
&
&
GetParentWindowContext
(
)
-
>
Manager
(
)
=
=
aBrowserParent
)
;
mCurrentBrowserParent
=
aBrowserParent
;
}
RefPtr
<
CanonicalBrowsingContext
:
:
RemotenessPromise
>
CanonicalBrowsingContext
:
:
ChangeRemoteness
(
const
RemotenessChangeOptions
&
aOptions
uint64_t
aPendingSwitchId
)
{
MOZ_DIAGNOSTIC_ASSERT
(
IsContent
(
)
"
cannot
change
the
process
of
chrome
contexts
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsTop
(
)
=
=
IsEmbeddedInProcess
(
0
)
"
toplevel
content
must
be
embedded
in
the
parent
process
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aOptions
.
mReplaceBrowsingContext
|
|
IsTop
(
)
"
Cannot
replace
BrowsingContext
for
subframes
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aOptions
.
mSpecificGroupId
=
=
0
|
|
aOptions
.
mReplaceBrowsingContext
"
Cannot
specify
group
ID
unless
replacing
BC
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aPendingSwitchId
|
|
!
IsTop
(
)
"
Should
always
have
aPendingSwitchId
for
top
-
level
"
"
frames
"
)
;
if
(
!
AncestorsAreCurrent
(
)
)
{
NS_WARNING
(
"
An
ancestor
context
is
no
longer
current
"
)
;
return
RemotenessPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
RefPtr
<
WindowGlobalParent
>
embedderWindowGlobal
=
GetEmbedderWindowGlobal
(
)
;
if
(
!
embedderWindowGlobal
)
{
NS_WARNING
(
"
Non
-
embedded
BrowsingContext
"
)
;
return
RemotenessPromise
:
:
CreateAndReject
(
NS_ERROR_UNEXPECTED
__func__
)
;
}
if
(
!
embedderWindowGlobal
-
>
CanSend
(
)
)
{
NS_WARNING
(
"
Embedder
already
been
destroyed
.
"
)
;
return
RemotenessPromise
:
:
CreateAndReject
(
NS_ERROR_NOT_AVAILABLE
__func__
)
;
}
if
(
aOptions
.
mRemoteType
.
IsEmpty
(
)
&
&
(
!
IsTop
(
)
|
|
!
GetEmbedderElement
(
)
)
)
{
NS_WARNING
(
"
Cannot
load
non
-
remote
subframes
"
)
;
return
RemotenessPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
if
(
mPendingRemotenessChange
)
{
mPendingRemotenessChange
-
>
Cancel
(
NS_ERROR_ABORT
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mPendingRemotenessChange
"
Should
have
cleared
"
)
;
}
auto
promise
=
MakeRefPtr
<
RemotenessPromise
:
:
Private
>
(
__func__
)
;
RefPtr
<
PendingRemotenessChange
>
change
=
new
PendingRemotenessChange
(
this
promise
aPendingSwitchId
aOptions
)
;
mPendingRemotenessChange
=
change
;
if
(
aOptions
.
mSpecificGroupId
)
{
change
-
>
mSpecificGroup
=
BrowsingContextGroup
:
:
GetOrCreate
(
aOptions
.
mSpecificGroupId
)
;
change
-
>
mSpecificGroup
-
>
AddKeepAlive
(
)
;
}
if
(
IsTop
(
)
&
&
GetEmbedderElement
(
)
)
{
nsCOMPtr
<
nsIBrowser
>
browser
=
GetEmbedderElement
(
)
-
>
AsBrowser
(
)
;
if
(
!
browser
)
{
change
-
>
Cancel
(
NS_ERROR_FAILURE
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
Promise
>
blocker
;
nsresult
rv
=
browser
-
>
PrepareToChangeRemoteness
(
getter_AddRefs
(
blocker
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
change
-
>
Cancel
(
rv
)
;
return
promise
.
forget
(
)
;
}
change
-
>
mPrepareToChangePromise
=
GenericPromise
:
:
FromDomPromise
(
blocker
)
;
}
RefPtr
<
BrowserParent
>
embedderBrowser
=
embedderWindowGlobal
-
>
GetBrowserParent
(
)
;
if
(
embedderBrowser
&
&
aOptions
.
mRemoteType
=
=
embedderBrowser
-
>
Manager
(
)
-
>
GetRemoteType
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aPendingSwitchId
"
We
always
have
a
PendingSwitchId
except
for
print
-
preview
loads
"
"
which
will
never
perform
a
process
-
switch
to
being
in
-
process
with
"
"
their
embedder
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aOptions
.
mReplaceBrowsingContext
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aOptions
.
mRemoteType
.
IsEmpty
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
change
-
>
mPrepareToChangePromise
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
change
-
>
mSpecificGroup
)
;
change
-
>
mContentParent
=
embedderBrowser
-
>
Manager
(
)
;
change
-
>
mContentParent
-
>
AddKeepAlive
(
)
;
change
-
>
ProcessLaunched
(
)
;
return
promise
.
forget
(
)
;
}
if
(
aOptions
.
mRemoteType
.
IsEmpty
(
)
)
{
change
-
>
ProcessLaunched
(
)
;
return
promise
.
forget
(
)
;
}
BrowsingContextGroup
*
finalGroup
=
aOptions
.
mReplaceBrowsingContext
?
change
-
>
mSpecificGroup
.
get
(
)
:
Group
(
)
;
change
-
>
mContentParent
=
ContentParent
:
:
GetNewOrUsedLaunchingBrowserProcess
(
aOptions
.
mRemoteType
finalGroup
hal
:
:
PROCESS_PRIORITY_FOREGROUND
false
)
;
if
(
!
change
-
>
mContentParent
)
{
change
-
>
Cancel
(
NS_ERROR_FAILURE
)
;
return
promise
.
forget
(
)
;
}
change
-
>
mContentParent
-
>
AddKeepAlive
(
)
;
change
-
>
mContentParent
-
>
WaitForLaunchAsync
(
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
change
]
(
ContentParent
*
)
{
change
-
>
ProcessLaunched
(
)
;
}
[
change
]
(
LaunchError
)
{
change
-
>
Cancel
(
NS_ERROR_FAILURE
)
;
}
)
;
return
promise
.
forget
(
)
;
}
MediaController
*
CanonicalBrowsingContext
:
:
GetMediaController
(
)
{
if
(
GetParent
(
)
)
{
return
Cast
(
Top
(
)
)
-
>
GetMediaController
(
)
;
}
MOZ_ASSERT
(
!
GetParent
(
)
"
Must
access
the
controller
from
the
top
-
level
browsing
context
!
"
)
;
if
(
!
mTabMediaController
&
&
!
IsDiscarded
(
)
&
&
IsContent
(
)
)
{
mTabMediaController
=
new
MediaController
(
Id
(
)
)
;
}
return
mTabMediaController
;
}
bool
CanonicalBrowsingContext
:
:
HasCreatedMediaController
(
)
const
{
return
!
!
mTabMediaController
;
}
bool
CanonicalBrowsingContext
:
:
SupportsLoadingInParent
(
nsDocShellLoadState
*
aLoadState
uint64_t
*
aOuterWindowId
)
{
if
(
WatchedByDevTools
(
)
)
{
return
false
;
}
if
(
aLoadState
-
>
LoadIsFromSessionHistory
(
)
)
{
return
false
;
}
if
(
!
net
:
:
SchemeIsHTTP
(
aLoadState
-
>
URI
(
)
)
&
&
!
net
:
:
SchemeIsHTTPS
(
aLoadState
-
>
URI
(
)
)
)
{
return
false
;
}
if
(
WindowGlobalParent
*
global
=
GetCurrentWindowGlobal
(
)
)
{
nsCOMPtr
<
nsIURI
>
currentURI
=
global
-
>
GetDocumentURI
(
)
;
if
(
currentURI
)
{
bool
newURIHasRef
=
false
;
aLoadState
-
>
URI
(
)
-
>
GetHasRef
(
&
newURIHasRef
)
;
bool
equalsExceptRef
=
false
;
aLoadState
-
>
URI
(
)
-
>
EqualsExceptRef
(
currentURI
&
equalsExceptRef
)
;
if
(
equalsExceptRef
&
&
newURIHasRef
)
{
return
false
;
}
}
if
(
global
-
>
HasBeforeUnload
(
)
)
{
return
false
;
}
*
aOuterWindowId
=
global
-
>
OuterWindowId
(
)
;
}
return
true
;
}
bool
CanonicalBrowsingContext
:
:
LoadInParent
(
nsDocShellLoadState
*
aLoadState
bool
aSetNavigating
)
{
if
(
!
IsTopContent
(
)
|
|
!
GetContentParent
(
)
|
|
!
StaticPrefs
:
:
browser_tabs_documentchannel_parent_controlled
(
)
)
{
return
false
;
}
uint64_t
outerWindowId
=
0
;
if
(
!
SupportsLoadingInParent
(
aLoadState
&
outerWindowId
)
)
{
return
false
;
}
return
net
:
:
DocumentLoadListener
:
:
LoadInParent
(
this
aLoadState
aSetNavigating
)
;
}
bool
CanonicalBrowsingContext
:
:
AttemptSpeculativeLoadInParent
(
nsDocShellLoadState
*
aLoadState
)
{
if
(
!
IsTopContent
(
)
|
|
!
GetContentParent
(
)
|
|
StaticPrefs
:
:
browser_tabs_documentchannel_parent_controlled
(
)
)
{
return
false
;
}
uint64_t
outerWindowId
=
0
;
if
(
!
SupportsLoadingInParent
(
aLoadState
&
outerWindowId
)
)
{
return
false
;
}
return
net
:
:
DocumentLoadListener
:
:
SpeculativeLoadInParent
(
this
aLoadState
)
;
}
bool
CanonicalBrowsingContext
:
:
StartDocumentLoad
(
net
:
:
DocumentLoadListener
*
aLoad
)
{
if
(
StaticPrefs
:
:
browser_tabs_documentchannel_parent_controlled
(
)
&
&
mCurrentLoad
)
{
mCurrentLoad
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
mCurrentLoad
=
aLoad
;
if
(
NS_FAILED
(
SetCurrentLoadIdentifier
(
Some
(
aLoad
-
>
GetLoadIdentifier
(
)
)
)
)
)
{
mCurrentLoad
=
nullptr
;
return
false
;
}
return
true
;
}
void
CanonicalBrowsingContext
:
:
EndDocumentLoad
(
bool
aForProcessSwitch
)
{
mCurrentLoad
=
nullptr
;
if
(
!
aForProcessSwitch
)
{
Unused
<
<
SetCurrentLoadIdentifier
(
Nothing
(
)
)
;
}
}
already_AddRefed
<
nsIURI
>
CanonicalBrowsingContext
:
:
GetCurrentURI
(
)
const
{
nsCOMPtr
<
nsIURI
>
currentURI
;
if
(
nsIDocShell
*
docShell
=
GetDocShell
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
nsDocShell
:
:
Cast
(
docShell
)
-
>
GetCurrentURI
(
getter_AddRefs
(
currentURI
)
)
)
;
}
else
{
currentURI
=
mCurrentRemoteURI
;
}
return
currentURI
.
forget
(
)
;
}
void
CanonicalBrowsingContext
:
:
SetCurrentRemoteURI
(
nsIURI
*
aCurrentRemoteURI
)
{
MOZ_ASSERT
(
!
GetDocShell
(
)
)
;
mCurrentRemoteURI
=
aCurrentRemoteURI
;
}
void
CanonicalBrowsingContext
:
:
ResetSHEntryHasUserInteractionCache
(
)
{
WindowContext
*
topWc
=
GetTopWindowContext
(
)
;
if
(
topWc
&
&
!
topWc
-
>
IsDiscarded
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
topWc
-
>
SetSHEntryHasUserInteraction
(
false
)
)
;
}
}
void
CanonicalBrowsingContext
:
:
HistoryCommitIndexAndLength
(
)
{
nsID
changeID
=
{
}
;
CallerWillNotifyHistoryIndexAndLengthChanges
caller
(
nullptr
)
;
HistoryCommitIndexAndLength
(
changeID
caller
)
;
}
void
CanonicalBrowsingContext
:
:
HistoryCommitIndexAndLength
(
const
nsID
&
aChangeID
const
CallerWillNotifyHistoryIndexAndLengthChanges
&
aProofOfCaller
)
{
if
(
!
IsTop
(
)
)
{
Cast
(
Top
(
)
)
-
>
HistoryCommitIndexAndLength
(
aChangeID
aProofOfCaller
)
;
return
;
}
nsISHistory
*
shistory
=
GetSessionHistory
(
)
;
if
(
!
shistory
)
{
return
;
}
int32_t
index
=
0
;
shistory
-
>
GetIndex
(
&
index
)
;
int32_t
length
=
shistory
-
>
GetCount
(
)
;
GetChildSessionHistory
(
)
-
>
SetIndexAndLength
(
index
length
aChangeID
)
;
Group
(
)
-
>
EachParent
(
[
&
]
(
ContentParent
*
aParent
)
{
Unused
<
<
aParent
-
>
SendHistoryCommitIndexAndLength
(
this
index
length
aChangeID
)
;
}
)
;
}
void
CanonicalBrowsingContext
:
:
ResetScalingZoom
(
)
{
if
(
WindowGlobalParent
*
topWindow
=
GetTopWindowContext
(
)
)
{
Unused
<
<
topWindow
-
>
SendResetScalingZoom
(
)
;
}
}
void
CanonicalBrowsingContext
:
:
SetRestoreData
(
SessionStoreRestoreData
*
aData
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mRestoreData
|
|
!
aData
"
must
either
be
clearing
or
initializing
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aData
|
|
mCompletedContentRestores
=
=
mRequestedContentRestores
"
must
not
start
restore
in
an
unstable
state
"
)
;
mRestoreData
=
aData
;
MOZ_ALWAYS_SUCCEEDS
(
SetHasRestoreData
(
mRestoreData
)
)
;
}
void
CanonicalBrowsingContext
:
:
RequestRestoreTabContent
(
WindowGlobalParent
*
aWindow
)
{
MOZ_DIAGNOSTIC_ASSERT
(
IsTop
(
)
)
;
if
(
IsDiscarded
(
)
|
|
!
mRestoreData
|
|
mRestoreData
-
>
IsEmpty
(
)
)
{
return
;
}
CanonicalBrowsingContext
*
context
=
aWindow
-
>
GetBrowsingContext
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
context
-
>
IsDiscarded
(
)
)
;
RefPtr
<
SessionStoreRestoreData
>
data
=
mRestoreData
-
>
FindChild
(
context
)
;
if
(
context
-
>
IsTop
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
context
=
=
this
)
;
SetRestoreData
(
nullptr
)
;
}
if
(
data
&
&
!
data
-
>
IsEmpty
(
)
)
{
auto
onTabRestoreComplete
=
[
self
=
RefPtr
{
this
}
]
(
auto
)
{
self
-
>
mCompletedContentRestores
+
+
;
if
(
!
self
-
>
mRestoreData
&
&
self
-
>
mCompletedContentRestores
=
=
self
-
>
mRequestedContentRestores
)
{
if
(
Element
*
browser
=
self
-
>
GetEmbedderElement
(
)
)
{
SessionStoreUtils
:
:
CallRestoreTabContentComplete
(
browser
)
;
}
}
}
;
mRequestedContentRestores
+
+
;
if
(
data
-
>
CanRestoreInto
(
aWindow
-
>
GetDocumentURI
(
)
)
)
{
if
(
!
aWindow
-
>
IsInProcess
(
)
)
{
aWindow
-
>
SendRestoreTabContent
(
data
onTabRestoreComplete
onTabRestoreComplete
)
;
return
;
}
data
-
>
RestoreInto
(
context
)
;
}
onTabRestoreComplete
(
true
)
;
}
}
void
CanonicalBrowsingContext
:
:
SetContainerFeaturePolicy
(
FeaturePolicy
*
aContainerFeaturePolicy
)
{
mContainerFeaturePolicy
=
aContainerFeaturePolicy
;
if
(
WindowGlobalParent
*
current
=
GetCurrentWindowGlobal
(
)
)
{
Unused
<
<
current
-
>
SendSetContainerFeaturePolicy
(
mContainerFeaturePolicy
)
;
}
}
void
CanonicalBrowsingContext
:
:
SetCrossGroupOpenerId
(
uint64_t
aOpenerId
)
{
MOZ_DIAGNOSTIC_ASSERT
(
IsTopContent
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mCrossGroupOpenerId
=
=
0
"
Can
only
set
CrossGroupOpenerId
once
"
)
;
mCrossGroupOpenerId
=
aOpenerId
;
}
auto
CanonicalBrowsingContext
:
:
FindUnloadingHost
(
uint64_t
aChildID
)
-
>
nsTArray
<
UnloadingHost
>
:
:
iterator
{
return
std
:
:
find_if
(
mUnloadingHosts
.
begin
(
)
mUnloadingHosts
.
end
(
)
[
&
]
(
const
auto
&
host
)
{
return
host
.
mChildID
=
=
aChildID
;
}
)
;
}
void
CanonicalBrowsingContext
:
:
ClearUnloadingHost
(
uint64_t
aChildID
)
{
auto
found
=
FindUnloadingHost
(
aChildID
)
;
if
(
found
!
=
mUnloadingHosts
.
end
(
)
)
{
auto
callbacks
=
std
:
:
move
(
found
-
>
mCallbacks
)
;
mUnloadingHosts
.
RemoveElementAt
(
found
)
;
for
(
const
auto
&
callback
:
callbacks
)
{
callback
(
)
;
}
}
}
void
CanonicalBrowsingContext
:
:
StartUnloadingHost
(
uint64_t
aChildID
)
{
MOZ_DIAGNOSTIC_ASSERT
(
FindUnloadingHost
(
aChildID
)
=
=
mUnloadingHosts
.
end
(
)
)
;
mUnloadingHosts
.
AppendElement
(
UnloadingHost
{
aChildID
{
}
}
)
;
}
void
CanonicalBrowsingContext
:
:
BrowserParentDestroyed
(
BrowserParent
*
aBrowserParent
bool
aAbnormalShutdown
)
{
ClearUnloadingHost
(
aBrowserParent
-
>
Manager
(
)
-
>
ChildID
(
)
)
;
if
(
mCurrentBrowserParent
=
=
aBrowserParent
)
{
mCurrentBrowserParent
=
nullptr
;
if
(
aAbnormalShutdown
)
{
ShowSubframeCrashedUI
(
aBrowserParent
-
>
GetBrowserBridgeParent
(
)
)
;
}
}
}
void
CanonicalBrowsingContext
:
:
ShowSubframeCrashedUI
(
BrowserBridgeParent
*
aBridge
)
{
if
(
!
aBridge
|
|
IsDiscarded
(
)
|
|
!
aBridge
-
>
CanSend
(
)
)
{
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
aBridge
-
>
GetBrowsingContext
(
)
|
|
aBridge
-
>
GetBrowsingContext
(
)
=
=
this
)
;
MOZ_ALWAYS_SUCCEEDS
(
SetCurrentInnerWindowId
(
0
)
)
;
SetOwnerProcessId
(
aBridge
-
>
Manager
(
)
-
>
Manager
(
)
-
>
ChildID
(
)
)
;
SetCurrentBrowserParent
(
aBridge
-
>
Manager
(
)
)
;
Unused
<
<
aBridge
-
>
SendSubFrameCrashed
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
CanonicalBrowsingContext
BrowsingContext
mSessionHistory
mContainerFeaturePolicy
mCurrentBrowserParent
)
NS_IMPL_ADDREF_INHERITED
(
CanonicalBrowsingContext
BrowsingContext
)
NS_IMPL_RELEASE_INHERITED
(
CanonicalBrowsingContext
BrowsingContext
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
CanonicalBrowsingContext
)
NS_INTERFACE_MAP_END_INHERITING
(
BrowsingContext
)
}
}
