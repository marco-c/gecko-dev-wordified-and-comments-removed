#
include
"
TimelineConsumers
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsDocShell
.
h
"
namespace
mozilla
{
NS_IMPL_ISUPPORTS
(
TimelineConsumers
nsIObserver
)
;
StaticMutex
TimelineConsumers
:
:
sMutex
;
StaticRefPtr
<
TimelineConsumers
>
TimelineConsumers
:
:
sInstance
;
bool
TimelineConsumers
:
:
sInShutdown
=
false
;
already_AddRefed
<
TimelineConsumers
>
TimelineConsumers
:
:
Get
(
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
|
|
XRE_IsParentProcess
(
)
)
;
if
(
sInShutdown
)
{
return
nullptr
;
}
static
bool
firstTime
=
true
;
if
(
firstTime
)
{
firstTime
=
false
;
StaticMutexAutoLock
lock
(
sMutex
)
;
sInstance
=
new
TimelineConsumers
(
)
;
if
(
sInstance
-
>
Init
(
)
)
{
ClearOnShutdown
(
&
sInstance
)
;
}
else
{
sInstance
-
>
RemoveObservers
(
)
;
sInstance
=
nullptr
;
}
}
RefPtr
<
TimelineConsumers
>
copy
=
sInstance
.
get
(
)
;
return
copy
.
forget
(
)
;
}
bool
TimelineConsumers
:
:
Init
(
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
!
obs
)
{
return
false
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
obs
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
)
)
)
{
return
false
;
}
return
true
;
}
bool
TimelineConsumers
:
:
RemoveObservers
(
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
!
obs
)
{
return
false
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
obs
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
)
)
{
return
false
;
}
return
true
;
}
nsresult
TimelineConsumers
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
{
sInShutdown
=
true
;
RemoveObservers
(
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
false
"
TimelineConsumers
got
unexpected
topic
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
TimelineConsumers
:
:
TimelineConsumers
(
)
:
mActiveConsumers
(
0
)
{
}
void
TimelineConsumers
:
:
AddConsumer
(
nsDocShell
*
aDocShell
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
UniquePtr
<
ObservedDocShell
>
&
observed
=
aDocShell
-
>
mObserved
;
MOZ_ASSERT
(
!
observed
)
;
if
(
mActiveConsumers
=
=
0
)
{
JS
:
:
SetProfileTimelineRecordingEnabled
(
true
)
;
}
mActiveConsumers
+
+
;
ObservedDocShell
*
obsDocShell
=
new
ObservedDocShell
(
aDocShell
)
;
MarkersStorage
*
storage
=
static_cast
<
MarkersStorage
*
>
(
obsDocShell
)
;
observed
.
reset
(
obsDocShell
)
;
mMarkersStores
.
insertFront
(
storage
)
;
}
void
TimelineConsumers
:
:
RemoveConsumer
(
nsDocShell
*
aDocShell
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
UniquePtr
<
ObservedDocShell
>
&
observed
=
aDocShell
-
>
mObserved
;
MOZ_ASSERT
(
observed
)
;
mActiveConsumers
-
-
;
if
(
mActiveConsumers
=
=
0
)
{
JS
:
:
SetProfileTimelineRecordingEnabled
(
false
)
;
}
observed
.
get
(
)
-
>
ClearMarkers
(
)
;
observed
.
get
(
)
-
>
remove
(
)
;
observed
.
reset
(
nullptr
)
;
}
bool
TimelineConsumers
:
:
HasConsumer
(
nsIDocShell
*
aDocShell
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
aDocShell
?
aDocShell
-
>
GetRecordProfileTimelineMarkers
(
)
:
false
;
}
bool
TimelineConsumers
:
:
IsEmpty
(
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
return
mActiveConsumers
=
=
0
;
}
void
TimelineConsumers
:
:
AddMarkerForDocShell
(
nsDocShell
*
aDocShell
const
char
*
aName
MarkerTracingType
aTracingType
MarkerStackRequest
aStackRequest
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
HasConsumer
(
aDocShell
)
)
{
aDocShell
-
>
mObserved
-
>
AddMarker
(
MakeUnique
<
TimelineMarker
>
(
aName
aTracingType
aStackRequest
)
)
;
}
}
void
TimelineConsumers
:
:
AddMarkerForDocShell
(
nsDocShell
*
aDocShell
const
char
*
aName
const
TimeStamp
&
aTime
MarkerTracingType
aTracingType
MarkerStackRequest
aStackRequest
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
HasConsumer
(
aDocShell
)
)
{
aDocShell
-
>
mObserved
-
>
AddMarker
(
MakeUnique
<
TimelineMarker
>
(
aName
aTime
aTracingType
aStackRequest
)
)
;
}
}
void
TimelineConsumers
:
:
AddMarkerForDocShell
(
nsDocShell
*
aDocShell
UniquePtr
<
AbstractTimelineMarker
>
&
&
aMarker
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
HasConsumer
(
aDocShell
)
)
{
aDocShell
-
>
mObserved
-
>
AddMarker
(
std
:
:
move
(
aMarker
)
)
;
}
}
void
TimelineConsumers
:
:
AddMarkerForDocShell
(
nsIDocShell
*
aDocShell
const
char
*
aName
MarkerTracingType
aTracingType
MarkerStackRequest
aStackRequest
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AddMarkerForDocShell
(
static_cast
<
nsDocShell
*
>
(
aDocShell
)
aName
aTracingType
aStackRequest
)
;
}
void
TimelineConsumers
:
:
AddMarkerForDocShell
(
nsIDocShell
*
aDocShell
const
char
*
aName
const
TimeStamp
&
aTime
MarkerTracingType
aTracingType
MarkerStackRequest
aStackRequest
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AddMarkerForDocShell
(
static_cast
<
nsDocShell
*
>
(
aDocShell
)
aName
aTime
aTracingType
aStackRequest
)
;
}
void
TimelineConsumers
:
:
AddMarkerForDocShell
(
nsIDocShell
*
aDocShell
UniquePtr
<
AbstractTimelineMarker
>
&
&
aMarker
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AddMarkerForDocShell
(
static_cast
<
nsDocShell
*
>
(
aDocShell
)
std
:
:
move
(
aMarker
)
)
;
}
void
TimelineConsumers
:
:
AddMarkerForAllObservedDocShells
(
const
char
*
aName
MarkerTracingType
aTracingType
MarkerStackRequest
aStackRequest
)
{
bool
isMainThread
=
NS_IsMainThread
(
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
for
(
MarkersStorage
*
storage
=
mMarkersStores
.
getFirst
(
)
;
storage
!
=
nullptr
;
storage
=
storage
-
>
getNext
(
)
)
{
UniquePtr
<
AbstractTimelineMarker
>
marker
=
MakeUnique
<
TimelineMarker
>
(
aName
aTracingType
aStackRequest
)
;
if
(
isMainThread
)
{
storage
-
>
AddMarker
(
std
:
:
move
(
marker
)
)
;
}
else
{
storage
-
>
AddOTMTMarker
(
std
:
:
move
(
marker
)
)
;
}
}
}
void
TimelineConsumers
:
:
AddMarkerForAllObservedDocShells
(
const
char
*
aName
const
TimeStamp
&
aTime
MarkerTracingType
aTracingType
MarkerStackRequest
aStackRequest
)
{
bool
isMainThread
=
NS_IsMainThread
(
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
for
(
MarkersStorage
*
storage
=
mMarkersStores
.
getFirst
(
)
;
storage
!
=
nullptr
;
storage
=
storage
-
>
getNext
(
)
)
{
UniquePtr
<
AbstractTimelineMarker
>
marker
=
MakeUnique
<
TimelineMarker
>
(
aName
aTime
aTracingType
aStackRequest
)
;
if
(
isMainThread
)
{
storage
-
>
AddMarker
(
std
:
:
move
(
marker
)
)
;
}
else
{
storage
-
>
AddOTMTMarker
(
std
:
:
move
(
marker
)
)
;
}
}
}
void
TimelineConsumers
:
:
AddMarkerForAllObservedDocShells
(
UniquePtr
<
AbstractTimelineMarker
>
&
aMarker
)
{
bool
isMainThread
=
NS_IsMainThread
(
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
for
(
MarkersStorage
*
storage
=
mMarkersStores
.
getFirst
(
)
;
storage
!
=
nullptr
;
storage
=
storage
-
>
getNext
(
)
)
{
UniquePtr
<
AbstractTimelineMarker
>
clone
=
aMarker
-
>
Clone
(
)
;
if
(
isMainThread
)
{
storage
-
>
AddMarker
(
std
:
:
move
(
clone
)
)
;
}
else
{
storage
-
>
AddOTMTMarker
(
std
:
:
move
(
clone
)
)
;
}
}
}
void
TimelineConsumers
:
:
PopMarkers
(
nsDocShell
*
aDocShell
JSContext
*
aCx
nsTArray
<
dom
:
:
ProfileTimelineMarker
>
&
aStore
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
aDocShell
|
|
!
aDocShell
-
>
mObserved
)
{
return
;
}
aDocShell
-
>
mObserved
-
>
PopMarkers
(
aCx
aStore
)
;
}
}
