#
include
"
ObservedDocShell
.
h
"
#
include
"
AbstractTimelineMarker
.
h
"
#
include
"
LayerTimelineMarker
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
namespace
mozilla
{
ObservedDocShell
:
:
ObservedDocShell
(
nsIDocShell
*
aDocShell
)
:
MarkersStorage
(
"
ObservedDocShellMutex
"
)
mDocShell
(
aDocShell
)
mPopping
(
false
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
ObservedDocShell
:
:
AddMarker
(
UniquePtr
<
AbstractTimelineMarker
>
&
&
aMarker
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mPopping
)
{
mTimelineMarkers
.
AppendElement
(
Move
(
aMarker
)
)
;
}
}
void
ObservedDocShell
:
:
AddOTMTMarker
(
UniquePtr
<
AbstractTimelineMarker
>
&
&
aMarker
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
GetLock
(
)
)
;
mOffTheMainThreadTimelineMarkers
.
AppendElement
(
Move
(
aMarker
)
)
;
}
void
ObservedDocShell
:
:
ClearMarkers
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
GetLock
(
)
)
;
mTimelineMarkers
.
Clear
(
)
;
mOffTheMainThreadTimelineMarkers
.
Clear
(
)
;
}
void
ObservedDocShell
:
:
PopMarkers
(
JSContext
*
aCx
nsTArray
<
dom
:
:
ProfileTimelineMarker
>
&
aStore
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
GetLock
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
mPopping
)
;
mPopping
=
true
;
auto
resetPopping
=
MakeScopeExit
(
[
&
]
{
mPopping
=
false
;
}
)
;
mTimelineMarkers
.
AppendElements
(
Move
(
mOffTheMainThreadTimelineMarkers
)
)
;
nsTArray
<
UniquePtr
<
AbstractTimelineMarker
>
>
keptStartMarkers
;
for
(
uint32_t
i
=
0
;
i
<
mTimelineMarkers
.
Length
(
)
;
+
+
i
)
{
UniquePtr
<
AbstractTimelineMarker
>
&
startPayload
=
mTimelineMarkers
.
ElementAt
(
i
)
;
if
(
startPayload
-
>
GetTracingType
(
)
=
=
MarkerTracingType
:
:
TIMESTAMP
)
{
dom
:
:
ProfileTimelineMarker
*
marker
=
aStore
.
AppendElement
(
)
;
marker
-
>
mName
=
NS_ConvertUTF8toUTF16
(
startPayload
-
>
GetName
(
)
)
;
marker
-
>
mStart
=
startPayload
-
>
GetTime
(
)
;
marker
-
>
mEnd
=
startPayload
-
>
GetTime
(
)
;
marker
-
>
mStack
=
startPayload
-
>
GetStack
(
)
;
startPayload
-
>
AddDetails
(
aCx
*
marker
)
;
continue
;
}
if
(
startPayload
-
>
GetTracingType
(
)
=
=
MarkerTracingType
:
:
START
)
{
bool
hasSeenEnd
=
false
;
bool
startIsPaintType
=
strcmp
(
startPayload
-
>
GetName
(
)
"
Paint
"
)
=
=
0
;
bool
hasSeenLayerType
=
false
;
dom
:
:
Sequence
<
dom
:
:
ProfileTimelineLayerRect
>
layerRectangles
;
uint32_t
markerDepth
=
0
;
for
(
uint32_t
j
=
i
+
1
;
j
<
mTimelineMarkers
.
Length
(
)
;
+
+
j
)
{
UniquePtr
<
AbstractTimelineMarker
>
&
endPayload
=
mTimelineMarkers
.
ElementAt
(
j
)
;
bool
endIsLayerType
=
strcmp
(
endPayload
-
>
GetName
(
)
"
Layer
"
)
=
=
0
;
if
(
startIsPaintType
&
&
endIsLayerType
)
{
AbstractTimelineMarker
*
raw
=
endPayload
.
get
(
)
;
LayerTimelineMarker
*
layerPayload
=
static_cast
<
LayerTimelineMarker
*
>
(
raw
)
;
layerPayload
-
>
AddLayerRectangles
(
layerRectangles
)
;
hasSeenLayerType
=
true
;
}
if
(
!
startPayload
-
>
Equals
(
*
endPayload
)
)
{
continue
;
}
if
(
endPayload
-
>
GetTracingType
(
)
=
=
MarkerTracingType
:
:
START
)
{
+
+
markerDepth
;
continue
;
}
if
(
endPayload
-
>
GetTracingType
(
)
=
=
MarkerTracingType
:
:
END
)
{
if
(
markerDepth
>
0
)
{
-
-
markerDepth
;
continue
;
}
if
(
!
startIsPaintType
|
|
(
startIsPaintType
&
&
hasSeenLayerType
)
)
{
dom
:
:
ProfileTimelineMarker
*
marker
=
aStore
.
AppendElement
(
)
;
marker
-
>
mName
=
NS_ConvertUTF8toUTF16
(
startPayload
-
>
GetName
(
)
)
;
marker
-
>
mStart
=
startPayload
-
>
GetTime
(
)
;
marker
-
>
mEnd
=
endPayload
-
>
GetTime
(
)
;
marker
-
>
mStack
=
startPayload
-
>
GetStack
(
)
;
if
(
hasSeenLayerType
)
{
marker
-
>
mRectangles
.
Construct
(
layerRectangles
)
;
}
startPayload
-
>
AddDetails
(
aCx
*
marker
)
;
endPayload
-
>
AddDetails
(
aCx
*
marker
)
;
}
hasSeenEnd
=
true
;
break
;
}
}
if
(
!
hasSeenEnd
)
{
keptStartMarkers
.
AppendElement
(
Move
(
mTimelineMarkers
.
ElementAt
(
i
)
)
)
;
mTimelineMarkers
.
RemoveElementAt
(
i
)
;
-
-
i
;
}
}
}
mTimelineMarkers
.
SwapElements
(
keptStartMarkers
)
;
}
}
