#
include
"
mozilla
/
dom
/
ChildProcessChannelListener
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
namespace
mozilla
{
namespace
dom
{
static
StaticRefPtr
<
ChildProcessChannelListener
>
sCPCLSingleton
;
void
ChildProcessChannelListener
:
:
RegisterCallback
(
uint64_t
aIdentifier
Callback
&
&
aCallback
)
{
if
(
auto
args
=
mChannelArgs
.
Extract
(
aIdentifier
)
)
{
nsresult
rv
=
aCallback
(
args
-
>
mLoadState
std
:
:
move
(
args
-
>
mStreamFilterEndpoints
)
args
-
>
mTiming
)
;
args
-
>
mResolver
(
rv
)
;
}
else
{
mCallbacks
.
InsertOrUpdate
(
aIdentifier
std
:
:
move
(
aCallback
)
)
;
}
}
void
ChildProcessChannelListener
:
:
OnChannelReady
(
nsDocShellLoadState
*
aLoadState
uint64_t
aIdentifier
nsTArray
<
Endpoint
>
&
&
aStreamFilterEndpoints
nsDOMNavigationTiming
*
aTiming
Resolver
&
&
aResolver
)
{
if
(
auto
callback
=
mCallbacks
.
Extract
(
aIdentifier
)
)
{
nsresult
rv
=
(
*
callback
)
(
aLoadState
std
:
:
move
(
aStreamFilterEndpoints
)
aTiming
)
;
aResolver
(
rv
)
;
}
else
{
mChannelArgs
.
InsertOrUpdate
(
aIdentifier
CallbackArgs
{
aLoadState
std
:
:
move
(
aStreamFilterEndpoints
)
aTiming
std
:
:
move
(
aResolver
)
}
)
;
}
}
ChildProcessChannelListener
:
:
~
ChildProcessChannelListener
(
)
{
for
(
const
auto
&
args
:
mChannelArgs
.
Values
(
)
)
{
args
.
mResolver
(
NS_ERROR_FAILURE
)
;
}
}
already_AddRefed
<
ChildProcessChannelListener
>
ChildProcessChannelListener
:
:
GetSingleton
(
)
{
if
(
!
sCPCLSingleton
)
{
sCPCLSingleton
=
new
ChildProcessChannelListener
(
)
;
ClearOnShutdown
(
&
sCPCLSingleton
)
;
}
RefPtr
<
ChildProcessChannelListener
>
cpcl
=
sCPCLSingleton
;
return
cpcl
.
forget
(
)
;
}
}
}
