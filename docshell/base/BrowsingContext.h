#
ifndef
mozilla_dom_BrowsingContext_h
#
define
mozilla_dom_BrowsingContext_h
#
include
"
GVAutoplayRequestUtils
.
h
"
#
include
"
mozilla
/
HalScreenConfiguration
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
FeaturePolicy
.
h
"
#
include
"
mozilla
/
dom
/
LocationBase
.
h
"
#
include
"
mozilla
/
dom
/
MaybeDiscarded
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
mozilla
/
dom
/
ScreenOrientationBinding
.
h
"
#
include
"
mozilla
/
dom
/
SyncedContext
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsILoadInfo
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsThreadUtils
.
h
"
class
nsDocShellLoadState
;
class
nsGlobalWindowInner
;
class
nsGlobalWindowOuter
;
class
nsIPrincipal
;
class
nsOuterWindowProxy
;
struct
nsPoint
;
class
PickleIterator
;
namespace
IPC
{
class
Message
;
}
namespace
mozilla
{
class
ErrorResult
;
class
LogModule
;
namespace
ipc
{
class
IProtocol
;
template
<
typename
T
>
struct
IPDLParamTraits
;
}
namespace
dom
{
class
BrowsingContent
;
class
BrowsingContextGroup
;
class
CanonicalBrowsingContext
;
class
ChildSHistory
;
class
ContentParent
;
class
Element
;
template
<
typename
>
struct
Nullable
;
template
<
typename
T
>
class
Sequence
;
class
SessionHistoryInfo
;
class
SessionStorageManager
;
class
StructuredCloneHolder
;
class
WindowContext
;
struct
WindowPostMessageOptions
;
class
WindowProxyHolder
;
#
define
MOZ_EACH_BC_FIELD
(
FIELD
)
\
FIELD
(
Name
nsString
)
\
FIELD
(
Closed
bool
)
\
FIELD
(
IsActive
bool
)
\
FIELD
(
OpenerPolicy
nsILoadInfo
:
:
CrossOriginOpenerPolicy
)
\
/
*
Current
opener
for
the
BrowsingContext
.
Weak
reference
*
/
\
FIELD
(
OpenerId
uint64_t
)
\
FIELD
(
OnePermittedSandboxedNavigatorId
uint64_t
)
\
/
*
WindowID
of
the
inner
window
which
embeds
this
BC
*
/
\
FIELD
(
EmbedderInnerWindowId
uint64_t
)
\
FIELD
(
CurrentInnerWindowId
uint64_t
)
\
FIELD
(
HadOriginalOpener
bool
)
\
FIELD
(
IsPopupSpam
bool
)
\
/
*
Controls
whether
the
BrowsingContext
is
currently
considered
to
be
\
*
activated
by
a
gesture
*
/
\
FIELD
(
UserActivationState
UserActivation
:
:
State
)
\
/
*
Hold
the
audio
muted
state
and
should
be
used
on
top
level
browsing
\
*
contexts
only
*
/
\
FIELD
(
Muted
bool
)
\
FIELD
(
FeaturePolicy
RefPtr
<
mozilla
:
:
dom
:
:
FeaturePolicy
>
)
\
/
*
See
nsSandboxFlags
.
h
for
the
possible
flags
.
*
/
\
FIELD
(
SandboxFlags
uint32_t
)
\
/
*
A
non
-
zero
unique
identifier
for
the
browser
element
that
is
hosting
\
*
this
\
*
BrowsingContext
tree
.
Every
BrowsingContext
in
the
element
'
s
tree
will
\
*
return
the
same
ID
in
all
processes
and
it
will
remain
stable
\
*
regardless
of
process
changes
.
When
a
browser
element
'
s
frameloader
is
\
*
switched
to
another
browser
element
this
ID
will
remain
the
same
but
\
*
hosted
under
the
under
the
new
browser
element
.
*
/
\
FIELD
(
BrowserId
uint64_t
)
\
FIELD
(
HistoryID
nsID
)
\
FIELD
(
InRDMPane
bool
)
\
FIELD
(
Loading
bool
)
\
FIELD
(
AncestorLoading
bool
)
\
FIELD
(
AllowPlugins
bool
)
\
FIELD
(
AllowContentRetargeting
bool
)
\
FIELD
(
AllowContentRetargetingOnChildren
bool
)
\
FIELD
(
ForceEnableTrackingProtection
bool
)
\
FIELD
(
UseGlobalHistory
bool
)
\
FIELD
(
FullscreenAllowedByOwner
bool
)
\
/
*
These
field
are
used
to
store
the
states
of
autoplay
media
request
on
\
*
GeckoView
only
and
it
would
only
be
modified
on
the
top
level
browsing
\
*
context
.
*
/
\
FIELD
(
GVAudibleAutoplayRequestStatus
GVAutoplayRequestStatus
)
\
FIELD
(
GVInaudibleAutoplayRequestStatus
GVAutoplayRequestStatus
)
\
/
*
ScreenOrientation
-
related
APIs
*
/
\
FIELD
(
CurrentOrientationAngle
float
)
\
FIELD
(
CurrentOrientationType
mozilla
:
:
dom
:
:
OrientationType
)
\
FIELD
(
OrientationLock
mozilla
:
:
hal
:
:
ScreenOrientation
)
\
FIELD
(
UserAgentOverride
nsString
)
\
FIELD
(
EmbedderElementType
Maybe
<
nsString
>
)
\
FIELD
(
MessageManagerGroup
nsString
)
\
FIELD
(
MaxTouchPointsOverride
uint8_t
)
\
FIELD
(
FullZoom
float
)
\
FIELD
(
WatchedByDevToolsInternal
bool
)
\
FIELD
(
TextZoom
float
)
\
/
*
The
current
in
-
progress
load
.
*
/
\
FIELD
(
CurrentLoadIdentifier
Maybe
<
uint64_t
>
)
\
/
*
See
nsIRequest
for
possible
flags
.
*
/
\
FIELD
(
DefaultLoadFlags
uint32_t
)
\
/
*
Signals
that
session
history
is
enabled
for
this
browsing
context
tree
.
\
*
This
is
only
ever
set
to
true
on
the
top
BC
so
consumers
need
to
get
\
*
the
value
from
the
top
BC
!
*
/
\
FIELD
(
HasSessionHistory
bool
)
\
FIELD
(
UseErrorPages
bool
)
\
FIELD
(
PlatformOverride
nsString
)
class
BrowsingContext
:
public
nsILoadContext
public
nsWrapperCache
{
MOZ_DECL_SYNCED_CONTEXT
(
BrowsingContext
MOZ_EACH_BC_FIELD
)
public
:
enum
class
Type
{
Chrome
Content
}
;
static
void
Init
(
)
;
static
LogModule
*
GetLog
(
)
;
static
void
CleanupContexts
(
uint64_t
aProcessId
)
;
static
already_AddRefed
<
BrowsingContext
>
Get
(
uint64_t
aId
)
;
static
already_AddRefed
<
BrowsingContext
>
Get
(
GlobalObject
&
uint64_t
aId
)
{
return
Get
(
aId
)
;
}
static
already_AddRefed
<
BrowsingContext
>
GetCurrentTopByBrowserId
(
uint64_t
aBrowserId
)
;
static
already_AddRefed
<
BrowsingContext
>
GetFromWindow
(
WindowProxyHolder
&
aProxy
)
;
static
already_AddRefed
<
BrowsingContext
>
GetFromWindow
(
GlobalObject
&
WindowProxyHolder
&
aProxy
)
{
return
GetFromWindow
(
aProxy
)
;
}
static
already_AddRefed
<
BrowsingContext
>
CreateIndependent
(
Type
aType
)
;
static
already_AddRefed
<
BrowsingContext
>
CreateDetached
(
nsGlobalWindowInner
*
aParent
BrowsingContext
*
aOpener
BrowsingContextGroup
*
aSpecificGroup
const
nsAString
&
aName
Type
aType
)
;
void
EnsureAttached
(
)
;
bool
EverAttached
(
)
const
{
return
mEverAttached
;
}
CanonicalBrowsingContext
*
Canonical
(
)
;
bool
IsInProcess
(
)
const
{
return
mIsInProcess
;
}
bool
CanHaveRemoteOuterProxies
(
)
const
{
return
!
mIsInProcess
|
|
mDanglingRemoteOuterProxies
;
}
bool
IsDiscarded
(
)
const
{
return
mIsDiscarded
;
}
bool
Windowless
(
)
const
{
return
mWindowless
;
}
nsIDocShell
*
GetDocShell
(
)
const
{
return
mDocShell
;
}
void
SetDocShell
(
nsIDocShell
*
aDocShell
)
;
void
ClearDocShell
(
)
{
mDocShell
=
nullptr
;
}
Document
*
GetDocument
(
)
const
{
return
mDocShell
?
mDocShell
-
>
GetDocument
(
)
:
nullptr
;
}
void
CleanUpDanglingRemoteOuterWindowProxies
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aOuter
)
;
Element
*
GetEmbedderElement
(
)
const
{
return
mEmbedderElement
;
}
void
SetEmbedderElement
(
Element
*
aEmbedder
)
;
void
Embed
(
)
;
nsPIDOMWindowOuter
*
GetDOMWindow
(
)
const
{
return
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
}
uint64_t
GetRequestContextId
(
)
const
{
return
mRequestContextId
;
}
void
Detach
(
bool
aFromIPC
=
false
)
;
void
PrepareForProcessChange
(
)
;
nsresult
LoadURI
(
nsDocShellLoadState
*
aLoadState
bool
aSetNavigating
=
false
)
;
nsresult
InternalLoad
(
nsDocShellLoadState
*
aLoadState
)
;
nsresult
CheckSandboxFlags
(
nsDocShellLoadState
*
aLoadState
)
;
void
DisplayLoadError
(
const
nsAString
&
aURI
)
;
bool
IsCached
(
)
;
bool
IsTargetable
(
)
;
const
nsString
&
Name
(
)
const
{
return
GetName
(
)
;
}
void
GetName
(
nsAString
&
aName
)
{
aName
=
GetName
(
)
;
}
bool
NameEquals
(
const
nsAString
&
aName
)
{
return
GetName
(
)
.
Equals
(
aName
)
;
}
Type
GetType
(
)
const
{
return
mType
;
}
bool
IsContent
(
)
const
{
return
mType
=
=
Type
:
:
Content
;
}
bool
IsChrome
(
)
const
{
return
!
IsContent
(
)
;
}
bool
IsTop
(
)
const
{
return
!
GetParent
(
)
;
}
bool
IsFrame
(
)
const
{
return
!
IsTop
(
)
;
}
bool
IsTopContent
(
)
const
{
return
IsContent
(
)
&
&
IsTop
(
)
;
}
bool
IsInSubtreeOf
(
BrowsingContext
*
aContext
)
;
bool
IsContentSubframe
(
)
const
{
return
IsContent
(
)
&
&
IsFrame
(
)
;
}
uint64_t
Id
(
)
const
{
return
mBrowsingContextId
;
}
BrowsingContext
*
GetParent
(
)
const
;
BrowsingContext
*
Top
(
)
;
WindowContext
*
GetParentWindowContext
(
)
const
{
return
mParentWindow
;
}
WindowContext
*
GetTopWindowContext
(
)
;
already_AddRefed
<
BrowsingContext
>
GetOpener
(
)
const
{
RefPtr
<
BrowsingContext
>
opener
(
Get
(
GetOpenerId
(
)
)
)
;
if
(
!
mIsDiscarded
&
&
opener
&
&
!
opener
-
>
mIsDiscarded
)
{
MOZ_DIAGNOSTIC_ASSERT
(
opener
-
>
mType
=
=
mType
)
;
return
opener
.
forget
(
)
;
}
return
nullptr
;
}
void
SetOpener
(
BrowsingContext
*
aOpener
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aOpener
|
|
aOpener
-
>
Group
(
)
=
=
Group
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aOpener
|
|
aOpener
-
>
mType
=
=
mType
)
;
MOZ_ALWAYS_SUCCEEDS
(
SetOpenerId
(
aOpener
?
aOpener
-
>
Id
(
)
:
0
)
)
;
}
bool
HasOpener
(
)
const
;
bool
HadOriginalOpener
(
)
const
{
return
GetHadOriginalOpener
(
)
;
}
bool
SameOriginWithTop
(
)
;
already_AddRefed
<
BrowsingContext
>
GetOnePermittedSandboxedNavigator
(
)
const
{
return
Get
(
GetOnePermittedSandboxedNavigatorId
(
)
)
;
}
MOZ_MUST_USE
nsresult
SetOnePermittedSandboxedNavigator
(
BrowsingContext
*
aNavigator
)
{
if
(
GetOnePermittedSandboxedNavigatorId
(
)
)
{
MOZ_ASSERT
(
false
"
One
Permitted
Sandboxed
Navigator
should
only
be
set
once
.
"
)
;
return
NS_ERROR_FAILURE
;
}
else
{
return
SetOnePermittedSandboxedNavigatorId
(
aNavigator
?
aNavigator
-
>
Id
(
)
:
0
)
;
}
}
uint32_t
SandboxFlags
(
)
{
return
GetSandboxFlags
(
)
;
}
Span
<
RefPtr
<
BrowsingContext
>
>
Children
(
)
const
;
void
GetChildren
(
nsTArray
<
RefPtr
<
BrowsingContext
>
>
&
aChildren
)
;
const
nsTArray
<
RefPtr
<
WindowContext
>
>
&
GetWindowContexts
(
)
{
return
mWindowContexts
;
}
void
GetWindowContexts
(
nsTArray
<
RefPtr
<
WindowContext
>
>
&
aWindows
)
;
void
RegisterWindowContext
(
WindowContext
*
aWindow
)
;
void
UnregisterWindowContext
(
WindowContext
*
aWindow
)
;
WindowContext
*
GetCurrentWindowContext
(
)
const
{
return
mCurrentWindowContext
;
}
void
PreOrderWalk
(
const
std
:
:
function
<
void
(
BrowsingContext
*
)
>
&
aCallback
)
;
void
PostOrderWalk
(
const
std
:
:
function
<
void
(
BrowsingContext
*
)
>
&
aCallback
)
;
void
GetAllBrowsingContextsInSubtree
(
nsTArray
<
RefPtr
<
BrowsingContext
>
>
&
aBrowsingContexts
)
;
BrowsingContextGroup
*
Group
(
)
{
return
mGroup
;
}
Nullable
<
WindowProxyHolder
>
GetAssociatedWindow
(
)
;
Nullable
<
WindowProxyHolder
>
GetTopWindow
(
)
;
Element
*
GetTopFrameElement
(
)
;
bool
GetIsContent
(
)
{
return
IsContent
(
)
;
}
void
SetUsePrivateBrowsing
(
bool
aUsePrivateBrowsing
ErrorResult
&
aError
)
;
void
SetUseTrackingProtectionWebIDL
(
bool
aUseTrackingProtection
ErrorResult
&
aRv
)
;
bool
UseTrackingProtectionWebIDL
(
)
{
return
UseTrackingProtection
(
)
;
}
void
GetOriginAttributes
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
ErrorResult
&
aError
)
;
bool
InRDMPane
(
)
const
{
return
GetInRDMPane
(
)
;
}
bool
WatchedByDevTools
(
)
;
void
SetWatchedByDevTools
(
bool
aWatchedByDevTools
ErrorResult
&
aRv
)
;
bool
FullscreenAllowed
(
)
const
;
float
FullZoom
(
)
const
{
return
GetFullZoom
(
)
;
}
float
TextZoom
(
)
const
{
return
GetTextZoom
(
)
;
}
bool
UseGlobalHistory
(
)
const
{
return
GetUseGlobalHistory
(
)
;
}
uint64_t
BrowserId
(
)
const
{
return
GetBrowserId
(
)
;
}
bool
IsLoading
(
)
;
void
GetEmbedderElementType
(
nsString
&
aElementType
)
{
if
(
GetEmbedderElementType
(
)
.
isSome
(
)
)
{
aElementType
=
GetEmbedderElementType
(
)
.
value
(
)
;
}
}
bool
IsLoadingIdentifier
(
uint64_t
aLoadIdentifer
)
{
if
(
GetCurrentLoadIdentifier
(
)
&
&
*
GetCurrentLoadIdentifier
(
)
=
=
aLoadIdentifer
)
{
return
true
;
}
return
false
;
}
MOZ_MUST_USE
nsresult
SetCurrentOrientation
(
OrientationType
aType
float
aAngle
)
{
Transaction
txn
;
txn
.
SetCurrentOrientationType
(
aType
)
;
txn
.
SetCurrentOrientationAngle
(
aAngle
)
;
return
txn
.
Commit
(
this
)
;
}
void
SetRDMPaneOrientation
(
OrientationType
aType
float
aAngle
ErrorResult
&
aRv
)
{
if
(
InRDMPane
(
)
)
{
if
(
NS_FAILED
(
SetCurrentOrientation
(
aType
aAngle
)
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Browsing
context
is
discarded
"
)
;
}
}
}
void
SetRDMPaneMaxTouchPoints
(
uint8_t
aMaxTouchPoints
ErrorResult
&
aRv
)
{
if
(
InRDMPane
(
)
)
{
SetMaxTouchPointsOverride
(
aMaxTouchPoints
aRv
)
;
}
}
nsresult
SetAllowContentRetargeting
(
bool
aAllowContentRetargeting
)
;
BrowsingContext
*
FindWithName
(
const
nsAString
&
aName
bool
aUseEntryGlobalForAccessCheck
=
true
)
;
BrowsingContext
*
FindChildWithName
(
const
nsAString
&
aName
BrowsingContext
&
aRequestingContext
)
;
BrowsingContext
*
FindWithNameInSubtree
(
const
nsAString
&
aName
BrowsingContext
&
aRequestingContext
)
;
nsISupports
*
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
inline
JSObject
*
GetWindowProxy
(
)
const
{
return
mWindowProxy
;
}
inline
JSObject
*
GetUnbarrieredWindowProxy
(
)
const
{
return
mWindowProxy
.
unbarrieredGet
(
)
;
}
void
SetWindowProxy
(
JS
:
:
Handle
<
JSObject
*
>
aWindowProxy
)
{
mWindowProxy
=
aWindowProxy
;
}
Nullable
<
WindowProxyHolder
>
GetWindow
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
BrowsingContext
)
NS_DECL_NSILOADCONTEXT
WindowProxyHolder
Window
(
)
;
BrowsingContext
*
GetBrowsingContext
(
)
{
return
this
;
}
;
BrowsingContext
*
Self
(
)
{
return
this
;
}
void
Location
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aLocation
ErrorResult
&
aError
)
;
void
Close
(
CallerType
aCallerType
ErrorResult
&
aError
)
;
bool
GetClosed
(
ErrorResult
&
)
{
return
GetClosed
(
)
;
}
void
Focus
(
CallerType
aCallerType
ErrorResult
&
aError
)
;
void
Blur
(
ErrorResult
&
aError
)
;
WindowProxyHolder
GetFrames
(
ErrorResult
&
aError
)
;
int32_t
Length
(
)
const
{
return
Children
(
)
.
Length
(
)
;
}
Nullable
<
WindowProxyHolder
>
GetTop
(
ErrorResult
&
aError
)
;
void
GetOpener
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aOpener
ErrorResult
&
aError
)
const
;
Nullable
<
WindowProxyHolder
>
GetParent
(
ErrorResult
&
aError
)
;
void
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
const
Sequence
<
JSObject
*
>
&
aTransfer
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
;
void
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
WindowPostMessageOptions
&
aOptions
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
;
void
GetCustomUserAgent
(
nsAString
&
aUserAgent
)
{
aUserAgent
=
Top
(
)
-
>
GetUserAgentOverride
(
)
;
}
nsresult
SetCustomUserAgent
(
const
nsAString
&
aUserAgent
)
;
void
SetCustomUserAgent
(
const
nsAString
&
aUserAgent
ErrorResult
&
aRv
)
;
void
GetCustomPlatform
(
nsAString
&
aPlatform
)
{
aPlatform
=
Top
(
)
-
>
GetPlatformOverride
(
)
;
}
void
SetCustomPlatform
(
const
nsAString
&
aPlatform
ErrorResult
&
aRv
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
)
;
static
JSObject
*
ReadStructuredClone
(
JSContext
*
aCx
JSStructuredCloneReader
*
aReader
StructuredCloneHolder
*
aHolder
)
;
bool
WriteStructuredClone
(
JSContext
*
aCx
JSStructuredCloneWriter
*
aWriter
StructuredCloneHolder
*
aHolder
)
;
void
StartDelayedAutoplayMediaComponents
(
)
;
MOZ_MUST_USE
nsresult
ResetGVAutoplayRequestStatus
(
)
;
struct
IPCInitializer
{
uint64_t
mId
=
0
;
uint64_t
mParentId
=
0
;
already_AddRefed
<
WindowContext
>
GetParent
(
)
;
already_AddRefed
<
BrowsingContext
>
GetOpener
(
)
;
uint64_t
GetOpenerId
(
)
const
{
return
mFields
.
mOpenerId
;
}
bool
mWindowless
=
false
;
bool
mUseRemoteTabs
=
false
;
bool
mUseRemoteSubframes
=
false
;
bool
mHasSessionHistory
=
false
;
OriginAttributes
mOriginAttributes
;
uint64_t
mRequestContextId
=
0
;
FieldValues
mFields
;
}
;
IPCInitializer
GetIPCInitializer
(
)
;
static
void
CreateFromIPC
(
IPCInitializer
&
&
aInitializer
BrowsingContextGroup
*
aGroup
ContentParent
*
aOriginProcess
)
;
bool
CanAccess
(
BrowsingContext
*
aTarget
bool
aConsiderOpener
=
true
)
;
bool
IsSandboxedFrom
(
BrowsingContext
*
aTarget
)
;
void
AddDeprioritizedLoadRunner
(
nsIRunnable
*
aRunner
)
;
RefPtr
<
SessionStorageManager
>
GetSessionStorageManager
(
)
;
bool
PendingInitialization
(
)
const
{
return
mPendingInitialization
;
}
;
void
SetPendingInitialization
(
bool
aVal
)
{
mPendingInitialization
=
aVal
;
}
;
const
OriginAttributes
&
OriginAttributesRef
(
)
{
return
mOriginAttributes
;
}
nsresult
SetOriginAttributes
(
const
OriginAttributes
&
aAttrs
)
;
void
InitSessionHistory
(
)
;
ChildSHistory
*
GetChildSessionHistory
(
)
;
bool
CrossOriginIsolated
(
)
;
void
SessionHistoryChanged
(
int32_t
aIndexDelta
int32_t
aLengthDelta
)
;
bool
IsPopupAllowed
(
)
;
void
SetActiveSessionHistoryEntryForTop
(
const
Maybe
<
nsPoint
>
&
aPreviousScrollPos
SessionHistoryInfo
*
aInfo
uint32_t
aLoadType
)
;
void
SetActiveSessionHistoryEntryForFrame
(
const
Maybe
<
nsPoint
>
&
aPreviousScrollPos
SessionHistoryInfo
*
aInfo
int32_t
aChildOffset
)
;
void
ReplaceActiveSessionHistoryEntry
(
SessionHistoryInfo
*
aInfo
)
;
void
RemoveDynEntriesFromActiveSessionHistoryEntry
(
)
;
protected
:
virtual
~
BrowsingContext
(
)
;
BrowsingContext
(
WindowContext
*
aParentWindow
BrowsingContextGroup
*
aGroup
uint64_t
aBrowsingContextId
Type
aType
FieldValues
&
&
aInit
)
;
private
:
void
Attach
(
bool
aFromIPC
ContentParent
*
aOriginProcess
)
;
BrowsingContext
*
FindWithSpecialName
(
const
nsAString
&
aName
BrowsingContext
&
aRequestingContext
)
;
bool
CanSetOriginAttributes
(
)
;
void
AssertOriginAttributesMatchPrivateBrowsing
(
)
;
void
AssertCoherentLoadContext
(
)
;
friend
class
:
:
nsOuterWindowProxy
;
friend
class
:
:
nsGlobalWindowOuter
;
friend
class
WindowContext
;
void
UpdateWindowProxy
(
JSObject
*
obj
JSObject
*
old
)
{
if
(
mWindowProxy
)
{
MOZ_ASSERT
(
mWindowProxy
=
=
old
)
;
mWindowProxy
=
obj
;
}
}
void
ClearWindowProxy
(
)
{
mWindowProxy
=
nullptr
;
}
friend
class
Location
;
friend
class
RemoteLocationProxy
;
class
LocationProxy
final
:
public
LocationBase
{
public
:
MozExternalRefCountType
AddRef
(
)
{
return
GetBrowsingContext
(
)
-
>
AddRef
(
)
;
}
MozExternalRefCountType
Release
(
)
{
return
GetBrowsingContext
(
)
-
>
Release
(
)
;
}
protected
:
friend
class
RemoteLocationProxy
;
BrowsingContext
*
GetBrowsingContext
(
)
override
{
return
reinterpret_cast
<
BrowsingContext
*
>
(
uintptr_t
(
this
)
-
offsetof
(
BrowsingContext
mLocation
)
)
;
}
already_AddRefed
<
nsIDocShell
>
GetDocShell
(
)
override
{
return
nullptr
;
}
}
;
void
SendCommitTransaction
(
ContentParent
*
aParent
const
BaseTransaction
&
aTxn
uint64_t
aEpoch
)
;
void
SendCommitTransaction
(
ContentChild
*
aChild
const
BaseTransaction
&
aTxn
uint64_t
aEpoch
)
;
bool
CanSet
(
FieldIndex
<
IDX_OpenerId
>
const
uint64_t
&
aValue
ContentParent
*
aSource
)
{
if
(
aValue
!
=
0
)
{
RefPtr
<
BrowsingContext
>
opener
=
Get
(
aValue
)
;
return
opener
&
&
opener
-
>
Group
(
)
=
=
Group
(
)
;
}
return
true
;
}
void
DidSet
(
FieldIndex
<
IDX_IsActive
>
bool
aOldValue
)
;
void
DidSet
(
FieldIndex
<
IDX_Muted
>
)
;
bool
CanSet
(
FieldIndex
<
IDX_EmbedderInnerWindowId
>
const
uint64_t
&
aValue
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_CurrentInnerWindowId
>
const
uint64_t
&
aValue
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_CurrentInnerWindowId
>
)
;
bool
CanSet
(
FieldIndex
<
IDX_IsPopupSpam
>
const
bool
&
aValue
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_IsPopupSpam
>
)
;
void
DidSet
(
FieldIndex
<
IDX_GVAudibleAutoplayRequestStatus
>
)
;
void
DidSet
(
FieldIndex
<
IDX_GVInaudibleAutoplayRequestStatus
>
)
;
void
DidSet
(
FieldIndex
<
IDX_Loading
>
)
;
void
DidSet
(
FieldIndex
<
IDX_AncestorLoading
>
)
;
void
DidSet
(
FieldIndex
<
IDX_PlatformOverride
>
)
;
bool
CanSet
(
FieldIndex
<
IDX_PlatformOverride
>
const
nsString
&
aPlatformOverride
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_UserAgentOverride
>
)
;
bool
CanSet
(
FieldIndex
<
IDX_UserAgentOverride
>
const
nsString
&
aUserAgent
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_OrientationLock
>
const
mozilla
:
:
hal
:
:
ScreenOrientation
&
aOrientationLock
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_EmbedderElementType
>
const
Maybe
<
nsString
>
&
aInitiatorType
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_MessageManagerGroup
>
const
nsString
&
aMessageManagerGroup
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_AllowContentRetargeting
>
const
bool
&
aAllowContentRetargeting
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_AllowContentRetargetingOnChildren
>
const
bool
&
aAllowContentRetargetingOnChildren
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_AllowPlugins
>
const
bool
&
aAllowPlugins
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_FullscreenAllowedByOwner
>
const
bool
&
ContentParent
*
)
;
bool
CanSet
(
FieldIndex
<
IDX_WatchedByDevToolsInternal
>
const
bool
&
aWatchedByDevToolsInternal
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_DefaultLoadFlags
>
const
uint32_t
&
aDefaultLoadFlags
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_DefaultLoadFlags
>
)
;
bool
CanSet
(
FieldIndex
<
IDX_UseGlobalHistory
>
const
bool
&
aUseGlobalHistory
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_HasSessionHistory
>
bool
aOldValue
)
;
bool
CanSet
(
FieldIndex
<
IDX_BrowserId
>
const
uint32_t
&
aValue
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_UseErrorPages
>
const
bool
&
aUseErrorPages
ContentParent
*
aSource
)
;
template
<
size_t
I
typename
T
>
bool
CanSet
(
FieldIndex
<
I
>
const
T
&
ContentParent
*
)
{
return
true
;
}
template
<
size_t
I
>
void
DidSet
(
FieldIndex
<
I
>
)
{
}
template
<
size_t
I
typename
T
>
void
DidSet
(
FieldIndex
<
I
>
T
&
&
aOldValue
)
{
}
void
DidSet
(
FieldIndex
<
IDX_FullZoom
>
float
aOldValue
)
;
void
DidSet
(
FieldIndex
<
IDX_TextZoom
>
float
aOldValue
)
;
bool
CheckOnlyOwningProcessCanSet
(
ContentParent
*
aSource
)
;
bool
CheckOnlyEmbedderCanSet
(
ContentParent
*
aSource
)
;
void
CreateChildSHistory
(
)
;
const
Type
mType
;
const
uint64_t
mBrowsingContextId
;
RefPtr
<
BrowsingContextGroup
>
mGroup
;
RefPtr
<
WindowContext
>
mParentWindow
;
nsCOMPtr
<
nsIDocShell
>
mDocShell
;
RefPtr
<
Element
>
mEmbedderElement
;
nsTArray
<
RefPtr
<
WindowContext
>
>
mWindowContexts
;
RefPtr
<
WindowContext
>
mCurrentWindowContext
;
JS
:
:
Heap
<
JSObject
*
>
mWindowProxy
;
LocationProxy
mLocation
;
OriginAttributes
mOriginAttributes
;
uint64_t
mRequestContextId
=
0
;
uint32_t
mPrivateBrowsingId
;
bool
mEverAttached
:
1
;
bool
mIsInProcess
:
1
;
bool
mIsDiscarded
:
1
;
bool
mWindowless
:
1
;
bool
mDanglingRemoteOuterProxies
:
1
;
bool
mPendingInitialization
:
1
;
bool
mEmbeddedByThisProcess
:
1
;
bool
mUseRemoteTabs
:
1
;
bool
mUseRemoteSubframes
:
1
;
TimeStamp
mUserGestureStart
;
class
DeprioritizedLoadRunner
:
public
mozilla
:
:
Runnable
public
mozilla
:
:
LinkedListElement
<
DeprioritizedLoadRunner
>
{
public
:
explicit
DeprioritizedLoadRunner
(
nsIRunnable
*
aInner
)
:
Runnable
(
"
DeprioritizedLoadRunner
"
)
mInner
(
aInner
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mInner
)
{
RefPtr
<
nsIRunnable
>
inner
=
std
:
:
move
(
mInner
)
;
inner
-
>
Run
(
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
nsIRunnable
>
mInner
;
}
;
mozilla
:
:
LinkedList
<
DeprioritizedLoadRunner
>
mDeprioritizedLoadRunner
;
RefPtr
<
SessionStorageManager
>
mSessionStorageManager
;
RefPtr
<
ChildSHistory
>
mChildSessionHistory
;
}
;
extern
bool
GetRemoteOuterWindowProxy
(
JSContext
*
aCx
BrowsingContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aTransplantTo
JS
:
:
MutableHandle
<
JSObject
*
>
aRetVal
)
;
using
BrowsingContextTransaction
=
BrowsingContext
:
:
BaseTransaction
;
using
BrowsingContextInitializer
=
BrowsingContext
:
:
IPCInitializer
;
using
MaybeDiscardedBrowsingContext
=
MaybeDiscarded
<
BrowsingContext
>
;
extern
template
class
syncedcontext
:
:
Transaction
<
BrowsingContext
>
;
}
namespace
ipc
{
template
<
>
struct
IPDLParamTraits
<
dom
:
:
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
>
{
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
dom
:
:
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
&
aParam
)
;
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
dom
:
:
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
*
aResult
)
;
}
;
template
<
>
struct
IPDLParamTraits
<
dom
:
:
BrowsingContext
:
:
IPCInitializer
>
{
static
void
Write
(
IPC
:
:
Message
*
aMessage
IProtocol
*
aActor
const
dom
:
:
BrowsingContext
:
:
IPCInitializer
&
aInitializer
)
;
static
bool
Read
(
const
IPC
:
:
Message
*
aMessage
PickleIterator
*
aIterator
IProtocol
*
aActor
dom
:
:
BrowsingContext
:
:
IPCInitializer
*
aInitializer
)
;
}
;
}
}
#
endif
