#
ifndef
mozilla_dom_BrowsingContext_h
#
define
mozilla_dom_BrowsingContext_h
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWrapperCache
.
h
"
class
nsGlobalWindowOuter
;
class
nsOuterWindowProxy
;
namespace
mozilla
{
class
LogModule
;
namespace
dom
{
class
BrowsingContext
;
class
ContentParent
;
class
BrowsingContextGroup
:
public
nsTArray
<
WeakPtr
<
BrowsingContext
>
>
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
BrowsingContextGroup
)
private
:
~
BrowsingContextGroup
(
)
{
}
}
;
class
BrowsingContext
:
public
nsWrapperCache
public
SupportsWeakPtr
<
BrowsingContext
>
public
LinkedListElement
<
RefPtr
<
BrowsingContext
>
>
{
public
:
enum
class
Type
{
Chrome
Content
}
;
static
void
Init
(
)
;
static
LogModule
*
GetLog
(
)
;
static
void
CleanupContexts
(
uint64_t
aProcessId
)
;
static
already_AddRefed
<
BrowsingContext
>
Get
(
uint64_t
aId
)
;
static
already_AddRefed
<
BrowsingContext
>
Create
(
BrowsingContext
*
aParent
BrowsingContext
*
aOpener
const
nsAString
&
aName
Type
aType
)
;
static
already_AddRefed
<
BrowsingContext
>
CreateFromIPC
(
BrowsingContext
*
aParent
BrowsingContext
*
aOpener
const
nsAString
&
aName
uint64_t
aId
ContentParent
*
aOriginProcess
)
;
nsIDocShell
*
GetDocShell
(
)
{
return
mDocShell
;
}
void
SetDocShell
(
nsIDocShell
*
aDocShell
)
;
nsPIDOMWindowOuter
*
GetDOMWindow
(
)
const
{
return
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
}
void
Attach
(
)
;
void
Detach
(
)
;
void
CacheChildren
(
)
;
bool
IsCached
(
)
;
void
SetName
(
const
nsAString
&
aName
)
{
mName
=
aName
;
}
void
GetName
(
nsAString
&
aName
)
{
aName
=
mName
;
}
bool
NameEquals
(
const
nsAString
&
aName
)
{
return
mName
.
Equals
(
aName
)
;
}
bool
IsContent
(
)
const
{
return
mType
=
=
Type
:
:
Content
;
}
uint64_t
Id
(
)
const
{
return
mBrowsingContextId
;
}
BrowsingContext
*
GetParent
(
)
{
return
mParent
;
}
void
GetChildren
(
nsTArray
<
RefPtr
<
BrowsingContext
>
>
&
aChildren
)
;
BrowsingContext
*
GetOpener
(
)
{
return
mOpener
;
}
void
SetOpener
(
BrowsingContext
*
aOpener
)
;
static
void
GetRootBrowsingContexts
(
nsTArray
<
RefPtr
<
BrowsingContext
>
>
&
aBrowsingContexts
)
;
nsISupports
*
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
inline
JSObject
*
GetWindowProxy
(
)
const
{
return
mWindowProxy
;
}
void
SetWindowProxy
(
JS
:
:
Handle
<
JSObject
*
>
aWindowProxy
)
{
mWindowProxy
=
aWindowProxy
;
}
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
BrowsingContext
)
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
BrowsingContext
)
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS
(
BrowsingContext
)
using
Children
=
nsTArray
<
RefPtr
<
BrowsingContext
>
>
;
protected
:
virtual
~
BrowsingContext
(
)
;
BrowsingContext
(
BrowsingContext
*
aParent
BrowsingContext
*
aOpener
const
nsAString
&
aName
uint64_t
aBrowsingContextId
Type
aType
)
;
private
:
friend
class
:
:
nsOuterWindowProxy
;
friend
class
:
:
nsGlobalWindowOuter
;
void
UpdateWindowProxy
(
JSObject
*
obj
JSObject
*
old
)
{
if
(
mWindowProxy
)
{
MOZ_ASSERT
(
mWindowProxy
=
=
old
)
;
mWindowProxy
=
obj
;
}
}
void
ClearWindowProxy
(
)
{
mWindowProxy
=
nullptr
;
}
const
Type
mType
;
const
uint64_t
mBrowsingContextId
;
RefPtr
<
BrowsingContextGroup
>
mBrowsingContextGroup
;
RefPtr
<
BrowsingContext
>
mParent
;
Children
mChildren
;
WeakPtr
<
BrowsingContext
>
mOpener
;
nsCOMPtr
<
nsIDocShell
>
mDocShell
;
nsString
mName
;
JS
:
:
Heap
<
JSObject
*
>
mWindowProxy
;
}
;
}
}
#
endif
