#
ifndef
mozilla_dom_BrowsingContext_h
#
define
mozilla_dom_BrowsingContext_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsILoadInfo
.
h
"
class
nsGlobalWindowOuter
;
class
nsIPrincipal
;
class
nsOuterWindowProxy
;
class
PickleIterator
;
namespace
IPC
{
class
Message
;
}
namespace
mozilla
{
class
ErrorResult
;
class
LogModule
;
namespace
ipc
{
class
IProtocol
;
template
<
typename
T
>
struct
IPDLParamTraits
;
}
namespace
dom
{
class
BrowsingContent
;
class
BrowsingContextGroup
;
class
CanonicalBrowsingContext
;
class
ContentParent
;
class
Element
;
template
<
typename
>
struct
Nullable
;
template
<
typename
T
>
class
Sequence
;
class
StructuredCloneHolder
;
struct
WindowPostMessageOptions
;
class
WindowProxyHolder
;
class
BrowsingContextBase
{
protected
:
BrowsingContextBase
(
)
{
#
define
MOZ_BC_FIELD
(
name
type
)
m
#
#
name
=
type
(
)
;
#
include
"
mozilla
/
dom
/
BrowsingContextFieldList
.
h
"
}
~
BrowsingContextBase
(
)
=
default
;
#
define
MOZ_BC_FIELD
(
name
type
)
\
type
m
#
#
name
;
\
\
/
*
shadow
to
validate
fields
.
aSource
is
setter
process
or
null
*
/
\
void
WillSet
#
#
name
(
type
const
&
aValue
ContentParent
*
aSource
)
{
}
\
void
DidSet
#
#
name
(
ContentParent
*
aSource
)
{
}
#
include
"
mozilla
/
dom
/
BrowsingContextFieldList
.
h
"
}
;
class
BrowsingContext
:
public
nsWrapperCache
public
BrowsingContextBase
{
public
:
enum
class
Type
{
Chrome
Content
}
;
using
Children
=
nsTArray
<
RefPtr
<
BrowsingContext
>
>
;
static
void
Init
(
)
;
static
LogModule
*
GetLog
(
)
;
static
void
CleanupContexts
(
uint64_t
aProcessId
)
;
static
already_AddRefed
<
BrowsingContext
>
Get
(
uint64_t
aId
)
;
static
already_AddRefed
<
BrowsingContext
>
Get
(
GlobalObject
&
uint64_t
aId
)
{
return
Get
(
aId
)
;
}
static
already_AddRefed
<
BrowsingContext
>
Create
(
BrowsingContext
*
aParent
BrowsingContext
*
aOpener
const
nsAString
&
aName
Type
aType
)
;
CanonicalBrowsingContext
*
Canonical
(
)
;
bool
IsInProcess
(
)
const
{
return
mIsInProcess
;
}
nsIDocShell
*
GetDocShell
(
)
{
return
mDocShell
;
}
void
SetDocShell
(
nsIDocShell
*
aDocShell
)
;
void
ClearDocShell
(
)
{
mDocShell
=
nullptr
;
}
Element
*
GetEmbedderElement
(
)
const
{
return
mEmbedderElement
;
}
void
SetEmbedderElement
(
Element
*
aEmbedder
)
;
nsPIDOMWindowOuter
*
GetDOMWindow
(
)
const
{
return
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
}
void
Attach
(
bool
aFromIPC
=
false
)
;
void
Detach
(
bool
aFromIPC
=
false
)
;
void
PrepareForProcessChange
(
)
;
void
CacheChildren
(
bool
aFromIPC
=
false
)
;
void
RestoreChildren
(
Children
&
&
aChildren
bool
aFromIPC
=
false
)
;
bool
IsCached
(
)
;
const
nsString
&
Name
(
)
const
{
return
mName
;
}
void
GetName
(
nsAString
&
aName
)
{
aName
=
mName
;
}
bool
NameEquals
(
const
nsAString
&
aName
)
{
return
mName
.
Equals
(
aName
)
;
}
bool
IsContent
(
)
const
{
return
mType
=
=
Type
:
:
Content
;
}
bool
IsChrome
(
)
const
{
return
!
IsContent
(
)
;
}
bool
IsTopContent
(
)
const
{
return
IsContent
(
)
&
&
!
GetParent
(
)
;
}
uint64_t
Id
(
)
const
{
return
mBrowsingContextId
;
}
BrowsingContext
*
GetParent
(
)
const
{
return
mParent
;
}
BrowsingContext
*
Top
(
)
;
already_AddRefed
<
BrowsingContext
>
GetOpener
(
)
const
{
return
Get
(
mOpenerId
)
;
}
void
SetOpener
(
BrowsingContext
*
aOpener
)
{
SetOpenerId
(
aOpener
?
aOpener
-
>
Id
(
)
:
0
)
;
}
bool
HasOpener
(
)
const
;
void
GetChildren
(
Children
&
aChildren
)
;
BrowsingContextGroup
*
Group
(
)
{
return
mGroup
;
}
BrowsingContext
*
FindWithName
(
const
nsAString
&
aName
)
;
BrowsingContext
*
FindChildWithName
(
const
nsAString
&
aName
)
;
nsISupports
*
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
void
NotifyUserGestureActivation
(
)
;
void
NotifyResetUserGestureActivation
(
)
;
bool
GetUserGestureActivation
(
)
;
inline
JSObject
*
GetWindowProxy
(
)
const
{
return
mWindowProxy
;
}
void
SetWindowProxy
(
JS
:
:
Handle
<
JSObject
*
>
aWindowProxy
)
{
mWindowProxy
=
aWindowProxy
;
}
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
BrowsingContext
)
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
BrowsingContext
)
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS
(
BrowsingContext
)
const
Children
&
GetChildren
(
)
{
return
mChildren
;
}
template
<
typename
Func
>
void
PreOrderWalk
(
Func
&
&
aCallback
)
{
aCallback
(
this
)
;
for
(
auto
&
child
:
GetChildren
(
)
)
{
child
-
>
PreOrderWalk
(
aCallback
)
;
}
}
BrowsingContext
*
Window
(
)
{
return
Self
(
)
;
}
BrowsingContext
*
Self
(
)
{
return
this
;
}
void
Location
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aLocation
ErrorResult
&
aError
)
;
void
Close
(
CallerType
aCallerType
ErrorResult
&
aError
)
;
bool
GetClosed
(
ErrorResult
&
)
{
return
mClosed
;
}
void
Focus
(
ErrorResult
&
aError
)
;
void
Blur
(
ErrorResult
&
aError
)
;
BrowsingContext
*
GetFrames
(
ErrorResult
&
aError
)
{
return
Self
(
)
;
}
int32_t
Length
(
)
const
{
return
mChildren
.
Length
(
)
;
}
Nullable
<
WindowProxyHolder
>
GetTop
(
ErrorResult
&
aError
)
;
void
GetOpener
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aOpener
ErrorResult
&
aError
)
const
;
Nullable
<
WindowProxyHolder
>
GetParent
(
ErrorResult
&
aError
)
;
void
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
const
Sequence
<
JSObject
*
>
&
aTransfer
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
;
void
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
WindowPostMessageOptions
&
aOptions
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
)
;
static
JSObject
*
ReadStructuredClone
(
JSContext
*
aCx
JSStructuredCloneReader
*
aReader
StructuredCloneHolder
*
aHolder
)
;
bool
WriteStructuredClone
(
JSContext
*
aCx
JSStructuredCloneWriter
*
aWriter
StructuredCloneHolder
*
aHolder
)
;
void
StartDelayedAutoplayMediaComponents
(
)
;
struct
FieldEpochs
{
#
define
MOZ_BC_FIELD
(
.
.
.
)
#
define
MOZ_BC_FIELD_RACY
(
name
.
.
.
)
uint64_t
m
#
#
name
=
0
;
#
include
"
mozilla
/
dom
/
BrowsingContextFieldList
.
h
"
}
;
class
Transaction
{
public
:
void
Commit
(
BrowsingContext
*
aOwner
)
;
void
Apply
(
BrowsingContext
*
aOwner
ContentParent
*
aSource
const
FieldEpochs
*
aEpochs
=
nullptr
)
;
bool
HasNonRacyField
(
)
const
{
#
define
MOZ_BC_FIELD
(
name
.
.
.
)
\
if
(
m
#
#
name
.
isSome
(
)
)
{
\
return
true
;
\
}
#
define
MOZ_BC_FIELD_RACY
(
.
.
.
)
#
include
"
mozilla
/
dom
/
BrowsingContextFieldList
.
h
"
return
false
;
}
#
define
MOZ_BC_FIELD
(
name
type
)
mozilla
:
:
Maybe
<
type
>
m
#
#
name
;
#
include
"
mozilla
/
dom
/
BrowsingContextFieldList
.
h
"
private
:
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
Transaction
>
;
}
;
#
define
MOZ_BC_FIELD
(
name
type
)
\
template
<
typename
.
.
.
Args
>
\
void
Set
#
#
name
(
Args
&
&
.
.
.
aValue
)
{
\
Transaction
txn
;
\
txn
.
m
#
#
name
.
emplace
(
std
:
:
forward
<
Args
>
(
aValue
)
.
.
.
)
;
\
txn
.
Commit
(
this
)
;
\
}
\
\
type
const
&
Get
#
#
name
(
)
const
{
return
m
#
#
name
;
}
#
include
"
mozilla
/
dom
/
BrowsingContextFieldList
.
h
"
struct
IPCInitializer
{
uint64_t
mId
;
uint64_t
mParentId
;
already_AddRefed
<
BrowsingContext
>
GetParent
(
)
;
already_AddRefed
<
BrowsingContext
>
GetOpener
(
)
;
bool
mCached
;
#
define
MOZ_BC_FIELD
(
name
type
)
type
m
#
#
name
;
#
include
"
mozilla
/
dom
/
BrowsingContextFieldList
.
h
"
}
;
IPCInitializer
GetIPCInitializer
(
)
;
static
already_AddRefed
<
BrowsingContext
>
CreateFromIPC
(
IPCInitializer
&
&
aInitializer
BrowsingContextGroup
*
aGroup
ContentParent
*
aOriginProcess
)
;
protected
:
virtual
~
BrowsingContext
(
)
;
BrowsingContext
(
BrowsingContext
*
aParent
BrowsingContextGroup
*
aGroup
uint64_t
aBrowsingContextId
Type
aType
)
;
private
:
BrowsingContext
*
FindWithSpecialName
(
const
nsAString
&
aName
)
;
BrowsingContext
*
FindWithNameInSubtree
(
const
nsAString
&
aName
BrowsingContext
*
aRequestingContext
)
;
bool
CanAccess
(
BrowsingContext
*
aContext
)
;
bool
IsActive
(
)
const
;
void
Unregister
(
)
;
friend
class
:
:
nsOuterWindowProxy
;
friend
class
:
:
nsGlobalWindowOuter
;
void
UpdateWindowProxy
(
JSObject
*
obj
JSObject
*
old
)
{
if
(
mWindowProxy
)
{
MOZ_ASSERT
(
mWindowProxy
=
=
old
)
;
mWindowProxy
=
obj
;
}
}
void
ClearWindowProxy
(
)
{
mWindowProxy
=
nullptr
;
}
friend
class
Location
;
friend
class
RemoteLocationProxy
;
class
LocationProxy
{
public
:
MozExternalRefCountType
AddRef
(
)
{
return
GetBrowsingContext
(
)
-
>
AddRef
(
)
;
}
MozExternalRefCountType
Release
(
)
{
return
GetBrowsingContext
(
)
-
>
Release
(
)
;
}
void
SetHref
(
const
nsAString
&
aHref
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
;
void
Replace
(
const
nsAString
&
aUrl
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
;
private
:
friend
class
RemoteLocationProxy
;
BrowsingContext
*
GetBrowsingContext
(
)
{
return
reinterpret_cast
<
BrowsingContext
*
>
(
uintptr_t
(
this
)
-
offsetof
(
BrowsingContext
mLocation
)
)
;
}
}
;
void
WillSetOpener
(
const
uint64_t
&
aValue
ContentParent
*
aSource
)
{
if
(
aValue
!
=
0
)
{
RefPtr
<
BrowsingContext
>
opener
=
Get
(
aValue
)
;
MOZ_RELEASE_ASSERT
(
opener
&
&
opener
-
>
Group
(
)
=
=
Group
(
)
)
;
}
}
void
DidSetIsActivatedByUserGesture
(
ContentParent
*
aSource
)
;
const
Type
mType
;
const
uint64_t
mBrowsingContextId
;
RefPtr
<
BrowsingContextGroup
>
mGroup
;
RefPtr
<
BrowsingContext
>
mParent
;
Children
mChildren
;
nsCOMPtr
<
nsIDocShell
>
mDocShell
;
RefPtr
<
Element
>
mEmbedderElement
;
JS
:
:
Heap
<
JSObject
*
>
mWindowProxy
;
LocationProxy
mLocation
;
FieldEpochs
mFieldEpochs
;
bool
mIsInProcess
:
1
;
bool
mIsDiscarded
:
1
;
}
;
extern
bool
GetRemoteOuterWindowProxy
(
JSContext
*
aCx
BrowsingContext
*
aContext
JS
:
:
MutableHandle
<
JSObject
*
>
aRetVal
)
;
typedef
BrowsingContext
:
:
Transaction
BrowsingContextTransaction
;
typedef
BrowsingContext
:
:
FieldEpochs
BrowsingContextFieldEpochs
;
typedef
BrowsingContext
:
:
IPCInitializer
BrowsingContextInitializer
;
typedef
BrowsingContext
:
:
Children
BrowsingContextChildren
;
}
namespace
ipc
{
template
<
>
struct
IPDLParamTraits
<
dom
:
:
BrowsingContext
*
>
{
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
dom
:
:
BrowsingContext
*
aParam
)
;
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
RefPtr
<
dom
:
:
BrowsingContext
>
*
aResult
)
;
}
;
template
<
>
struct
IPDLParamTraits
<
dom
:
:
BrowsingContext
:
:
Transaction
>
{
static
void
Write
(
IPC
:
:
Message
*
aMessage
IProtocol
*
aActor
const
dom
:
:
BrowsingContext
:
:
Transaction
&
aTransaction
)
;
static
bool
Read
(
const
IPC
:
:
Message
*
aMessage
PickleIterator
*
aIterator
IProtocol
*
aActor
dom
:
:
BrowsingContext
:
:
Transaction
*
aTransaction
)
;
}
;
template
<
>
struct
IPDLParamTraits
<
dom
:
:
BrowsingContext
:
:
FieldEpochs
>
{
static
void
Write
(
IPC
:
:
Message
*
aMessage
IProtocol
*
aActor
const
dom
:
:
BrowsingContext
:
:
FieldEpochs
&
aEpochs
)
;
static
bool
Read
(
const
IPC
:
:
Message
*
aMessage
PickleIterator
*
aIterator
IProtocol
*
aActor
dom
:
:
BrowsingContext
:
:
FieldEpochs
*
aEpochs
)
;
}
;
template
<
>
struct
IPDLParamTraits
<
dom
:
:
BrowsingContext
:
:
IPCInitializer
>
{
static
void
Write
(
IPC
:
:
Message
*
aMessage
IProtocol
*
aActor
const
dom
:
:
BrowsingContext
:
:
IPCInitializer
&
aInitializer
)
;
static
bool
Read
(
const
IPC
:
:
Message
*
aMessage
PickleIterator
*
aIterator
IProtocol
*
aActor
dom
:
:
BrowsingContext
:
:
IPCInitializer
*
aInitializer
)
;
}
;
}
}
#
endif
