#
ifndef
mozilla_dom_BrowsingContext_h
#
define
mozilla_dom_BrowsingContext_h
#
include
<
tuple
>
#
include
"
GVAutoplayRequestUtils
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
HalScreenConfiguration
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
LocationBase
.
h
"
#
include
"
mozilla
/
dom
/
MaybeDiscarded
.
h
"
#
include
"
mozilla
/
dom
/
PopupBlocker
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContextBinding
.
h
"
#
include
"
mozilla
/
dom
/
ScreenOrientationBinding
.
h
"
#
include
"
mozilla
/
dom
/
SyncedContext
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsILoadInfo
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsThreadUtils
.
h
"
class
nsDocShellLoadState
;
class
nsGlobalWindowInner
;
class
nsGlobalWindowOuter
;
class
nsIPrincipal
;
class
nsOuterWindowProxy
;
struct
nsPoint
;
class
PickleIterator
;
namespace
IPC
{
class
Message
;
}
namespace
mozilla
{
class
ErrorResult
;
class
LogModule
;
namespace
ipc
{
class
IProtocol
;
template
<
typename
T
>
struct
IPDLParamTraits
;
}
namespace
dom
{
class
BrowsingContent
;
class
BrowsingContextGroup
;
class
CanonicalBrowsingContext
;
class
ChildSHistory
;
class
ContentParent
;
class
Element
;
struct
LoadingSessionHistoryInfo
;
template
<
typename
>
struct
Nullable
;
template
<
typename
T
>
class
Sequence
;
class
SessionHistoryInfo
;
class
SessionStorageManager
;
class
StructuredCloneHolder
;
class
WindowContext
;
struct
WindowPostMessageOptions
;
class
WindowProxyHolder
;
enum
class
ExplicitActiveStatus
:
uint8_t
{
None
Active
Inactive
EndGuard_
}
;
#
define
MOZ_EACH_BC_FIELD
(
FIELD
)
\
FIELD
(
Name
nsString
)
\
FIELD
(
Closed
bool
)
\
FIELD
(
ExplicitActive
ExplicitActiveStatus
)
\
/
*
Top
(
)
-
only
.
If
true
new
-
playing
media
will
be
suspended
when
in
an
\
*
inactive
browsing
context
.
*
/
\
FIELD
(
SuspendMediaWhenInactive
bool
)
\
/
*
If
true
we
'
re
within
the
nested
event
loop
in
window
.
open
and
this
\
*
context
may
not
be
used
as
the
target
of
a
load
*
/
\
FIELD
(
PendingInitialization
bool
)
\
/
*
Indicates
if
the
browser
window
is
active
for
the
purpose
of
the
\
*
:
-
moz
-
window
-
inactive
pseudoclass
.
Only
read
from
or
set
on
the
\
*
top
BrowsingContext
.
*
/
\
FIELD
(
IsActiveBrowserWindowInternal
bool
)
\
FIELD
(
OpenerPolicy
nsILoadInfo
:
:
CrossOriginOpenerPolicy
)
\
/
*
Current
opener
for
the
BrowsingContext
.
Weak
reference
*
/
\
FIELD
(
OpenerId
uint64_t
)
\
FIELD
(
OnePermittedSandboxedNavigatorId
uint64_t
)
\
/
*
WindowID
of
the
inner
window
which
embeds
this
BC
*
/
\
FIELD
(
EmbedderInnerWindowId
uint64_t
)
\
FIELD
(
CurrentInnerWindowId
uint64_t
)
\
FIELD
(
HadOriginalOpener
bool
)
\
FIELD
(
IsPopupSpam
bool
)
\
/
*
Hold
the
audio
muted
state
and
should
be
used
on
top
level
browsing
\
*
contexts
only
*
/
\
FIELD
(
Muted
bool
)
\
/
*
See
nsSandboxFlags
.
h
for
the
possible
flags
.
*
/
\
FIELD
(
SandboxFlags
uint32_t
)
\
FIELD
(
InitialSandboxFlags
uint32_t
)
\
/
*
A
non
-
zero
unique
identifier
for
the
browser
element
that
is
hosting
\
*
this
\
*
BrowsingContext
tree
.
Every
BrowsingContext
in
the
element
'
s
tree
will
\
*
return
the
same
ID
in
all
processes
and
it
will
remain
stable
\
*
regardless
of
process
changes
.
When
a
browser
element
'
s
frameloader
is
\
*
switched
to
another
browser
element
this
ID
will
remain
the
same
but
\
*
hosted
under
the
under
the
new
browser
element
.
*
/
\
FIELD
(
BrowserId
uint64_t
)
\
FIELD
(
HistoryID
nsID
)
\
FIELD
(
InRDMPane
bool
)
\
FIELD
(
Loading
bool
)
\
/
*
A
field
only
set
on
top
browsing
contexts
which
indicates
that
either
:
\
*
\
*
*
This
is
a
browsing
context
created
explicitly
for
printing
or
print
\
*
preview
(
thus
hosting
static
documents
)
.
\
*
\
*
*
This
is
a
browsing
context
where
something
in
this
tree
is
calling
\
*
window
.
print
(
)
(
and
thus
showing
a
modal
dialog
)
.
\
*
\
*
We
use
it
exclusively
to
block
navigation
for
both
of
these
cases
.
*
/
\
FIELD
(
IsPrinting
bool
)
\
FIELD
(
AncestorLoading
bool
)
\
FIELD
(
AllowPlugins
bool
)
\
FIELD
(
AllowContentRetargeting
bool
)
\
FIELD
(
AllowContentRetargetingOnChildren
bool
)
\
FIELD
(
ForceEnableTrackingProtection
bool
)
\
FIELD
(
UseGlobalHistory
bool
)
\
FIELD
(
FullscreenAllowedByOwner
bool
)
\
/
*
These
field
are
used
to
store
the
states
of
autoplay
media
request
on
\
*
GeckoView
only
and
it
would
only
be
modified
on
the
top
level
browsing
\
*
context
.
*
/
\
FIELD
(
GVAudibleAutoplayRequestStatus
GVAutoplayRequestStatus
)
\
FIELD
(
GVInaudibleAutoplayRequestStatus
GVAutoplayRequestStatus
)
\
/
*
ScreenOrientation
-
related
APIs
*
/
\
FIELD
(
CurrentOrientationAngle
float
)
\
FIELD
(
CurrentOrientationType
mozilla
:
:
dom
:
:
OrientationType
)
\
FIELD
(
OrientationLock
mozilla
:
:
hal
:
:
ScreenOrientation
)
\
FIELD
(
UserAgentOverride
nsString
)
\
FIELD
(
TouchEventsOverrideInternal
mozilla
:
:
dom
:
:
TouchEventsOverride
)
\
FIELD
(
EmbedderElementType
Maybe
<
nsString
>
)
\
FIELD
(
MessageManagerGroup
nsString
)
\
FIELD
(
MaxTouchPointsOverride
uint8_t
)
\
FIELD
(
FullZoom
float
)
\
FIELD
(
WatchedByDevToolsInternal
bool
)
\
FIELD
(
TextZoom
float
)
\
FIELD
(
OverrideDPPX
float
)
\
/
*
The
current
in
-
progress
load
.
*
/
\
FIELD
(
CurrentLoadIdentifier
Maybe
<
uint64_t
>
)
\
/
*
See
nsIRequest
for
possible
flags
.
*
/
\
FIELD
(
DefaultLoadFlags
uint32_t
)
\
/
*
Signals
that
session
history
is
enabled
for
this
browsing
context
tree
.
\
*
This
is
only
ever
set
to
true
on
the
top
BC
so
consumers
need
to
get
\
*
the
value
from
the
top
BC
!
*
/
\
FIELD
(
HasSessionHistory
bool
)
\
/
*
Tracks
if
this
context
is
the
only
top
-
level
document
in
the
session
\
*
history
of
the
context
.
*
/
\
FIELD
(
IsSingleToplevelInHistory
bool
)
\
FIELD
(
UseErrorPages
bool
)
\
FIELD
(
PlatformOverride
nsString
)
\
FIELD
(
HasLoadedNonInitialDocument
bool
)
\
FIELD
(
CreatedDynamically
bool
)
\
/
*
Default
value
for
nsIContentViewer
:
:
authorStyleDisabled
in
any
new
\
*
browsing
contexts
created
as
a
descendant
of
this
one
.
Valid
only
for
\
*
top
BCs
.
*
/
\
FIELD
(
AuthorStyleDisabledDefault
bool
)
\
FIELD
(
ServiceWorkersTestingEnabled
bool
)
\
FIELD
(
MediumOverride
nsString
)
\
FIELD
(
PrefersColorSchemeOverride
mozilla
:
:
dom
:
:
PrefersColorSchemeOverride
)
\
FIELD
(
DisplayMode
mozilla
:
:
dom
:
:
DisplayMode
)
\
/
*
True
if
the
top
level
browsing
context
owns
a
main
media
controller
*
/
\
FIELD
(
HasMainMediaController
bool
)
\
/
*
The
number
of
entries
added
to
the
session
history
because
of
this
\
*
browsing
context
.
*
/
\
FIELD
(
HistoryEntryCount
uint32_t
)
\
FIELD
(
IsInBFCache
bool
)
class
BrowsingContext
:
public
nsILoadContext
public
nsWrapperCache
{
MOZ_DECL_SYNCED_CONTEXT
(
BrowsingContext
MOZ_EACH_BC_FIELD
)
public
:
enum
class
Type
{
Chrome
Content
}
;
static
void
Init
(
)
;
static
LogModule
*
GetLog
(
)
;
static
LogModule
*
GetSyncLog
(
)
;
static
already_AddRefed
<
BrowsingContext
>
Get
(
uint64_t
aId
)
;
static
already_AddRefed
<
BrowsingContext
>
Get
(
GlobalObject
&
uint64_t
aId
)
{
return
Get
(
aId
)
;
}
static
already_AddRefed
<
BrowsingContext
>
GetCurrentTopByBrowserId
(
uint64_t
aBrowserId
)
;
static
already_AddRefed
<
BrowsingContext
>
GetCurrentTopByBrowserId
(
GlobalObject
&
uint64_t
aId
)
{
return
GetCurrentTopByBrowserId
(
aId
)
;
}
static
already_AddRefed
<
BrowsingContext
>
GetFromWindow
(
WindowProxyHolder
&
aProxy
)
;
static
already_AddRefed
<
BrowsingContext
>
GetFromWindow
(
GlobalObject
&
WindowProxyHolder
&
aProxy
)
{
return
GetFromWindow
(
aProxy
)
;
}
static
void
DiscardFromContentParent
(
ContentParent
*
aCP
)
;
static
already_AddRefed
<
BrowsingContext
>
CreateIndependent
(
Type
aType
)
;
static
already_AddRefed
<
BrowsingContext
>
CreateDetached
(
nsGlobalWindowInner
*
aParent
BrowsingContext
*
aOpener
BrowsingContextGroup
*
aSpecificGroup
const
nsAString
&
aName
Type
aType
bool
aCreatedDynamically
=
false
)
;
void
EnsureAttached
(
)
;
bool
EverAttached
(
)
const
{
return
mEverAttached
;
}
CanonicalBrowsingContext
*
Canonical
(
)
;
bool
IsInProcess
(
)
const
{
return
mIsInProcess
;
}
bool
IsOwnedByProcess
(
)
const
;
bool
CanHaveRemoteOuterProxies
(
)
const
{
return
!
mIsInProcess
|
|
mDanglingRemoteOuterProxies
;
}
bool
IsDiscarded
(
)
const
{
return
mIsDiscarded
;
}
bool
AncestorsAreCurrent
(
)
const
;
bool
Windowless
(
)
const
{
return
mWindowless
;
}
nsIDocShell
*
GetDocShell
(
)
const
{
return
mDocShell
;
}
void
SetDocShell
(
nsIDocShell
*
aDocShell
)
;
void
ClearDocShell
(
)
{
mDocShell
=
nullptr
;
}
Document
*
GetDocument
(
)
const
{
return
mDocShell
?
mDocShell
-
>
GetDocument
(
)
:
nullptr
;
}
Document
*
GetExtantDocument
(
)
const
{
return
mDocShell
?
mDocShell
-
>
GetExtantDocument
(
)
:
nullptr
;
}
void
CleanUpDanglingRemoteOuterWindowProxies
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aOuter
)
;
Element
*
GetEmbedderElement
(
)
const
{
return
mEmbedderElement
;
}
void
SetEmbedderElement
(
Element
*
aEmbedder
)
;
void
Embed
(
)
;
nsPIDOMWindowOuter
*
GetDOMWindow
(
)
const
{
return
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
}
uint64_t
GetRequestContextId
(
)
const
{
return
mRequestContextId
;
}
void
Detach
(
bool
aFromIPC
=
false
)
;
void
PrepareForProcessChange
(
)
;
nsresult
LoadURI
(
nsDocShellLoadState
*
aLoadState
bool
aSetNavigating
=
false
)
;
nsresult
InternalLoad
(
nsDocShellLoadState
*
aLoadState
)
;
bool
RemoveRootFromBFCacheSync
(
)
;
nsresult
CheckSandboxFlags
(
nsDocShellLoadState
*
aLoadState
)
;
void
DisplayLoadError
(
const
nsAString
&
aURI
)
;
bool
IsCached
(
)
const
;
bool
IsTargetable
(
)
const
;
bool
InactiveForSuspend
(
)
const
;
const
nsString
&
Name
(
)
const
{
return
GetName
(
)
;
}
void
GetName
(
nsAString
&
aName
)
{
aName
=
GetName
(
)
;
}
bool
NameEquals
(
const
nsAString
&
aName
)
{
return
GetName
(
)
.
Equals
(
aName
)
;
}
Type
GetType
(
)
const
{
return
mType
;
}
bool
IsContent
(
)
const
{
return
mType
=
=
Type
:
:
Content
;
}
bool
IsChrome
(
)
const
{
return
!
IsContent
(
)
;
}
bool
IsTop
(
)
const
{
return
!
GetParent
(
)
;
}
bool
IsFrame
(
)
const
{
return
!
IsTop
(
)
;
}
bool
IsTopContent
(
)
const
{
return
IsContent
(
)
&
&
IsTop
(
)
;
}
bool
IsInSubtreeOf
(
BrowsingContext
*
aContext
)
;
bool
IsContentSubframe
(
)
const
{
return
IsContent
(
)
&
&
IsFrame
(
)
;
}
uint64_t
Id
(
)
const
{
return
mBrowsingContextId
;
}
BrowsingContext
*
GetParent
(
)
const
;
BrowsingContext
*
Top
(
)
;
const
BrowsingContext
*
Top
(
)
const
;
int32_t
IndexOf
(
BrowsingContext
*
aChild
)
;
WindowContext
*
GetParentWindowContext
(
)
const
{
return
mParentWindow
;
}
WindowContext
*
GetTopWindowContext
(
)
;
already_AddRefed
<
BrowsingContext
>
GetOpener
(
)
const
{
RefPtr
<
BrowsingContext
>
opener
(
Get
(
GetOpenerId
(
)
)
)
;
if
(
!
mIsDiscarded
&
&
opener
&
&
!
opener
-
>
mIsDiscarded
)
{
MOZ_DIAGNOSTIC_ASSERT
(
opener
-
>
mType
=
=
mType
)
;
return
opener
.
forget
(
)
;
}
return
nullptr
;
}
void
SetOpener
(
BrowsingContext
*
aOpener
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aOpener
|
|
aOpener
-
>
Group
(
)
=
=
Group
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aOpener
|
|
aOpener
-
>
mType
=
=
mType
)
;
MOZ_ALWAYS_SUCCEEDS
(
SetOpenerId
(
aOpener
?
aOpener
-
>
Id
(
)
:
0
)
)
;
}
bool
HasOpener
(
)
const
;
bool
HadOriginalOpener
(
)
const
{
return
GetHadOriginalOpener
(
)
;
}
bool
SameOriginWithTop
(
)
;
already_AddRefed
<
BrowsingContext
>
GetOnePermittedSandboxedNavigator
(
)
const
{
return
Get
(
GetOnePermittedSandboxedNavigatorId
(
)
)
;
}
[
[
nodiscard
]
]
nsresult
SetOnePermittedSandboxedNavigator
(
BrowsingContext
*
aNavigator
)
{
if
(
GetOnePermittedSandboxedNavigatorId
(
)
)
{
MOZ_ASSERT
(
false
"
One
Permitted
Sandboxed
Navigator
should
only
be
set
once
.
"
)
;
return
NS_ERROR_FAILURE
;
}
else
{
return
SetOnePermittedSandboxedNavigatorId
(
aNavigator
?
aNavigator
-
>
Id
(
)
:
0
)
;
}
}
uint32_t
SandboxFlags
(
)
const
{
return
GetSandboxFlags
(
)
;
}
Span
<
RefPtr
<
BrowsingContext
>
>
Children
(
)
const
;
void
GetChildren
(
nsTArray
<
RefPtr
<
BrowsingContext
>
>
&
aChildren
)
;
const
nsTArray
<
RefPtr
<
WindowContext
>
>
&
GetWindowContexts
(
)
{
return
mWindowContexts
;
}
void
GetWindowContexts
(
nsTArray
<
RefPtr
<
WindowContext
>
>
&
aWindows
)
;
void
RegisterWindowContext
(
WindowContext
*
aWindow
)
;
void
UnregisterWindowContext
(
WindowContext
*
aWindow
)
;
WindowContext
*
GetCurrentWindowContext
(
)
const
{
return
mCurrentWindowContext
;
}
void
PreOrderWalk
(
const
std
:
:
function
<
void
(
BrowsingContext
*
)
>
&
aCallback
)
;
void
PostOrderWalk
(
const
std
:
:
function
<
void
(
BrowsingContext
*
)
>
&
aCallback
)
;
void
GetAllBrowsingContextsInSubtree
(
nsTArray
<
RefPtr
<
BrowsingContext
>
>
&
aBrowsingContexts
)
;
BrowsingContextGroup
*
Group
(
)
{
return
mGroup
;
}
Nullable
<
WindowProxyHolder
>
GetAssociatedWindow
(
)
;
Nullable
<
WindowProxyHolder
>
GetTopWindow
(
)
;
Element
*
GetTopFrameElement
(
)
;
bool
GetIsContent
(
)
{
return
IsContent
(
)
;
}
void
SetUsePrivateBrowsing
(
bool
aUsePrivateBrowsing
ErrorResult
&
aError
)
;
void
SetUseTrackingProtectionWebIDL
(
bool
aUseTrackingProtection
ErrorResult
&
aRv
)
;
bool
UseTrackingProtectionWebIDL
(
)
{
return
UseTrackingProtection
(
)
;
}
void
GetOriginAttributes
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
ErrorResult
&
aError
)
;
bool
InRDMPane
(
)
const
{
return
GetInRDMPane
(
)
;
}
bool
WatchedByDevTools
(
)
;
void
SetWatchedByDevTools
(
bool
aWatchedByDevTools
ErrorResult
&
aRv
)
;
dom
:
:
TouchEventsOverride
TouchEventsOverride
(
)
const
;
void
SetTouchEventsOverride
(
dom
:
:
TouchEventsOverride
ErrorResult
&
aRv
)
;
bool
FullscreenAllowed
(
)
const
;
float
FullZoom
(
)
const
{
return
GetFullZoom
(
)
;
}
float
TextZoom
(
)
const
{
return
GetTextZoom
(
)
;
}
float
OverrideDPPX
(
)
const
{
return
Top
(
)
-
>
GetOverrideDPPX
(
)
;
}
bool
SuspendMediaWhenInactive
(
)
const
{
return
GetSuspendMediaWhenInactive
(
)
;
}
bool
IsActive
(
)
const
;
void
SetIsActive
(
bool
aIsActive
mozilla
:
:
ErrorResult
&
aRv
)
{
SetExplicitActive
(
aIsActive
?
ExplicitActiveStatus
:
:
Active
:
ExplicitActiveStatus
:
:
Inactive
aRv
)
;
}
bool
AuthorStyleDisabledDefault
(
)
const
{
return
GetAuthorStyleDisabledDefault
(
)
;
}
bool
UseGlobalHistory
(
)
const
{
return
GetUseGlobalHistory
(
)
;
}
bool
GetIsActiveBrowserWindow
(
)
;
void
SetIsActiveBrowserWindow
(
bool
aActive
)
;
uint64_t
BrowserId
(
)
const
{
return
GetBrowserId
(
)
;
}
bool
IsLoading
(
)
;
void
GetEmbedderElementType
(
nsString
&
aElementType
)
{
if
(
GetEmbedderElementType
(
)
.
isSome
(
)
)
{
aElementType
=
GetEmbedderElementType
(
)
.
value
(
)
;
}
}
bool
IsLoadingIdentifier
(
uint64_t
aLoadIdentifer
)
{
if
(
GetCurrentLoadIdentifier
(
)
&
&
*
GetCurrentLoadIdentifier
(
)
=
=
aLoadIdentifer
)
{
return
true
;
}
return
false
;
}
[
[
nodiscard
]
]
nsresult
SetCurrentOrientation
(
OrientationType
aType
float
aAngle
)
{
Transaction
txn
;
txn
.
SetCurrentOrientationType
(
aType
)
;
txn
.
SetCurrentOrientationAngle
(
aAngle
)
;
return
txn
.
Commit
(
this
)
;
}
void
SetRDMPaneOrientation
(
OrientationType
aType
float
aAngle
ErrorResult
&
aRv
)
{
if
(
InRDMPane
(
)
)
{
if
(
NS_FAILED
(
SetCurrentOrientation
(
aType
aAngle
)
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Browsing
context
is
discarded
"
)
;
}
}
}
void
SetRDMPaneMaxTouchPoints
(
uint8_t
aMaxTouchPoints
ErrorResult
&
aRv
)
{
if
(
InRDMPane
(
)
)
{
SetMaxTouchPointsOverride
(
aMaxTouchPoints
aRv
)
;
}
}
BrowsingContext
*
FindWithName
(
const
nsAString
&
aName
bool
aUseEntryGlobalForAccessCheck
=
true
)
;
BrowsingContext
*
FindChildWithName
(
const
nsAString
&
aName
BrowsingContext
&
aRequestingContext
)
;
BrowsingContext
*
FindWithNameInSubtree
(
const
nsAString
&
aName
BrowsingContext
&
aRequestingContext
)
;
nsISupports
*
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
inline
JSObject
*
GetWindowProxy
(
)
const
{
return
mWindowProxy
;
}
inline
JSObject
*
GetUnbarrieredWindowProxy
(
)
const
{
return
mWindowProxy
.
unbarrieredGet
(
)
;
}
void
SetWindowProxy
(
JS
:
:
Handle
<
JSObject
*
>
aWindowProxy
)
{
mWindowProxy
=
aWindowProxy
;
}
Nullable
<
WindowProxyHolder
>
GetWindow
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
BrowsingContext
)
NS_DECL_NSILOADCONTEXT
WindowProxyHolder
Window
(
)
;
BrowsingContext
*
GetBrowsingContext
(
)
{
return
this
;
}
;
BrowsingContext
*
Self
(
)
{
return
this
;
}
void
Location
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aLocation
ErrorResult
&
aError
)
;
void
Close
(
CallerType
aCallerType
ErrorResult
&
aError
)
;
bool
GetClosed
(
ErrorResult
&
)
{
return
GetClosed
(
)
;
}
void
Focus
(
CallerType
aCallerType
ErrorResult
&
aError
)
;
void
Blur
(
CallerType
aCallerType
ErrorResult
&
aError
)
;
WindowProxyHolder
GetFrames
(
ErrorResult
&
aError
)
;
int32_t
Length
(
)
const
{
return
Children
(
)
.
Length
(
)
;
}
Nullable
<
WindowProxyHolder
>
GetTop
(
ErrorResult
&
aError
)
;
void
GetOpener
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aOpener
ErrorResult
&
aError
)
const
;
Nullable
<
WindowProxyHolder
>
GetParent
(
ErrorResult
&
aError
)
;
void
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
const
Sequence
<
JSObject
*
>
&
aTransfer
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
;
void
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
WindowPostMessageOptions
&
aOptions
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
;
void
GetCustomUserAgent
(
nsAString
&
aUserAgent
)
{
aUserAgent
=
Top
(
)
-
>
GetUserAgentOverride
(
)
;
}
nsresult
SetCustomUserAgent
(
const
nsAString
&
aUserAgent
)
;
void
SetCustomUserAgent
(
const
nsAString
&
aUserAgent
ErrorResult
&
aRv
)
;
void
GetCustomPlatform
(
nsAString
&
aPlatform
)
{
aPlatform
=
Top
(
)
-
>
GetPlatformOverride
(
)
;
}
void
SetCustomPlatform
(
const
nsAString
&
aPlatform
ErrorResult
&
aRv
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
)
;
static
JSObject
*
ReadStructuredClone
(
JSContext
*
aCx
JSStructuredCloneReader
*
aReader
StructuredCloneHolder
*
aHolder
)
;
bool
WriteStructuredClone
(
JSContext
*
aCx
JSStructuredCloneWriter
*
aWriter
StructuredCloneHolder
*
aHolder
)
;
void
StartDelayedAutoplayMediaComponents
(
)
;
[
[
nodiscard
]
]
nsresult
ResetGVAutoplayRequestStatus
(
)
;
struct
IPCInitializer
{
uint64_t
mId
=
0
;
uint64_t
mParentId
=
0
;
already_AddRefed
<
WindowContext
>
GetParent
(
)
;
already_AddRefed
<
BrowsingContext
>
GetOpener
(
)
;
uint64_t
GetOpenerId
(
)
const
{
return
mFields
.
mOpenerId
;
}
bool
mWindowless
=
false
;
bool
mUseRemoteTabs
=
false
;
bool
mUseRemoteSubframes
=
false
;
bool
mCreatedDynamically
=
false
;
int32_t
mSessionHistoryIndex
=
-
1
;
int32_t
mSessionHistoryCount
=
0
;
OriginAttributes
mOriginAttributes
;
uint64_t
mRequestContextId
=
0
;
FieldValues
mFields
;
}
;
IPCInitializer
GetIPCInitializer
(
)
;
static
void
CreateFromIPC
(
IPCInitializer
&
&
aInitializer
BrowsingContextGroup
*
aGroup
ContentParent
*
aOriginProcess
)
;
bool
CanAccess
(
BrowsingContext
*
aTarget
bool
aConsiderOpener
=
true
)
;
bool
IsSandboxedFrom
(
BrowsingContext
*
aTarget
)
;
void
AddDeprioritizedLoadRunner
(
nsIRunnable
*
aRunner
)
;
RefPtr
<
SessionStorageManager
>
GetSessionStorageManager
(
)
;
void
InitPendingInitialization
(
bool
aPendingInitialization
)
{
MOZ_ASSERT
(
!
EverAttached
(
)
)
;
mFields
.
SetWithoutSyncing
<
IDX_PendingInitialization
>
(
aPendingInitialization
)
;
}
bool
CreatedDynamically
(
)
const
{
return
mCreatedDynamically
;
}
const
OriginAttributes
&
OriginAttributesRef
(
)
{
return
mOriginAttributes
;
}
nsresult
SetOriginAttributes
(
const
OriginAttributes
&
aAttrs
)
;
void
GetHistoryID
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
ErrorResult
&
aError
)
;
void
InitSessionHistory
(
)
;
ChildSHistory
*
GetChildSessionHistory
(
)
;
bool
CrossOriginIsolated
(
)
;
void
SessionHistoryChanged
(
int32_t
aIndexDelta
int32_t
aLengthDelta
)
;
bool
IsPopupAllowed
(
)
;
void
SessionHistoryCommit
(
const
LoadingSessionHistoryInfo
&
aInfo
uint32_t
aLoadType
bool
aHadActiveEntry
bool
aPersist
bool
aCloneEntryChildren
)
;
void
SetActiveSessionHistoryEntry
(
const
Maybe
<
nsPoint
>
&
aPreviousScrollPos
SessionHistoryInfo
*
aInfo
uint32_t
aLoadType
uint32_t
aUpdatedCacheKey
)
;
void
ReplaceActiveSessionHistoryEntry
(
SessionHistoryInfo
*
aInfo
)
;
void
RemoveDynEntriesFromActiveSessionHistoryEntry
(
)
;
void
RemoveFromSessionHistory
(
const
nsID
&
aChangeID
)
;
void
SetTriggeringAndInheritPrincipals
(
nsIPrincipal
*
aTriggeringPrincipal
nsIPrincipal
*
aPrincipalToInherit
uint64_t
aLoadIdentifier
)
;
Tuple
<
nsCOMPtr
<
nsIPrincipal
>
nsCOMPtr
<
nsIPrincipal
>
>
GetTriggeringAndInheritPrincipalsForCurrentLoad
(
)
;
void
HistoryGo
(
int32_t
aOffset
uint64_t
aHistoryEpoch
bool
aRequireUserInteraction
std
:
:
function
<
void
(
int32_t
&
&
)
>
&
&
aResolver
)
;
bool
ShouldUpdateSessionHistory
(
uint32_t
aLoadType
)
;
nsresult
CheckLocationChangeRateLimit
(
CallerType
aCallerType
)
;
void
ResetLocationChangeRateLimit
(
)
;
mozilla
:
:
dom
:
:
DisplayMode
DisplayMode
(
)
{
return
Top
(
)
-
>
GetDisplayMode
(
)
;
}
std
:
:
tuple
<
bool
bool
>
CanFocusCheck
(
CallerType
aCallerType
)
;
bool
CanBlurCheck
(
CallerType
aCallerType
)
;
PopupBlocker
:
:
PopupControlState
RevisePopupAbuseLevel
(
PopupBlocker
:
:
PopupControlState
aControl
)
;
void
IncrementHistoryEntryCountForBrowsingContext
(
)
;
bool
ServiceWorkersTestingEnabled
(
)
const
{
return
GetServiceWorkersTestingEnabled
(
)
;
}
void
GetMediumOverride
(
nsAString
&
aOverride
)
const
{
aOverride
=
GetMediumOverride
(
)
;
}
dom
:
:
PrefersColorSchemeOverride
PrefersColorSchemeOverride
(
)
const
{
return
GetPrefersColorSchemeOverride
(
)
;
}
protected
:
virtual
~
BrowsingContext
(
)
;
BrowsingContext
(
WindowContext
*
aParentWindow
BrowsingContextGroup
*
aGroup
uint64_t
aBrowsingContextId
Type
aType
FieldValues
&
&
aInit
)
;
void
SetChildSHistory
(
ChildSHistory
*
aChildSHistory
)
;
already_AddRefed
<
ChildSHistory
>
ForgetChildSHistory
(
)
{
return
mChildSessionHistory
.
forget
(
)
;
}
private
:
void
Attach
(
bool
aFromIPC
ContentParent
*
aOriginProcess
)
;
BrowsingContext
*
FindWithSpecialName
(
const
nsAString
&
aName
BrowsingContext
&
aRequestingContext
)
;
bool
CanSetOriginAttributes
(
)
;
void
AssertOriginAttributesMatchPrivateBrowsing
(
)
;
void
AssertCoherentLoadContext
(
)
;
friend
class
:
:
nsOuterWindowProxy
;
friend
class
:
:
nsGlobalWindowOuter
;
friend
class
WindowContext
;
void
UpdateWindowProxy
(
JSObject
*
obj
JSObject
*
old
)
{
if
(
mWindowProxy
)
{
MOZ_ASSERT
(
mWindowProxy
=
=
old
)
;
mWindowProxy
=
obj
;
}
}
void
ClearWindowProxy
(
)
{
mWindowProxy
=
nullptr
;
}
friend
class
Location
;
friend
class
RemoteLocationProxy
;
class
LocationProxy
final
:
public
LocationBase
{
public
:
MozExternalRefCountType
AddRef
(
)
{
return
GetBrowsingContext
(
)
-
>
AddRef
(
)
;
}
MozExternalRefCountType
Release
(
)
{
return
GetBrowsingContext
(
)
-
>
Release
(
)
;
}
protected
:
friend
class
RemoteLocationProxy
;
BrowsingContext
*
GetBrowsingContext
(
)
override
{
return
reinterpret_cast
<
BrowsingContext
*
>
(
uintptr_t
(
this
)
-
offsetof
(
BrowsingContext
mLocation
)
)
;
}
already_AddRefed
<
nsIDocShell
>
GetDocShell
(
)
override
{
return
nullptr
;
}
}
;
void
SendCommitTransaction
(
ContentParent
*
aParent
const
BaseTransaction
&
aTxn
uint64_t
aEpoch
)
;
void
SendCommitTransaction
(
ContentChild
*
aChild
const
BaseTransaction
&
aTxn
uint64_t
aEpoch
)
;
using
CanSetResult
=
syncedcontext
:
:
CanSetResult
;
bool
CanSet
(
FieldIndex
<
IDX_OpenerId
>
const
uint64_t
&
aValue
ContentParent
*
aSource
)
{
if
(
aValue
!
=
0
)
{
RefPtr
<
BrowsingContext
>
opener
=
Get
(
aValue
)
;
return
opener
&
&
opener
-
>
Group
(
)
=
=
Group
(
)
;
}
return
true
;
}
bool
CanSet
(
FieldIndex
<
IDX_ServiceWorkersTestingEnabled
>
bool
ContentParent
*
)
{
return
IsTop
(
)
;
}
bool
CanSet
(
FieldIndex
<
IDX_MediumOverride
>
const
nsString
&
ContentParent
*
)
{
return
IsTop
(
)
;
}
bool
CanSet
(
FieldIndex
<
IDX_PrefersColorSchemeOverride
>
dom
:
:
PrefersColorSchemeOverride
ContentParent
*
)
{
return
IsTop
(
)
;
}
void
DidSet
(
FieldIndex
<
IDX_PrefersColorSchemeOverride
>
dom
:
:
PrefersColorSchemeOverride
aOldValue
)
;
void
DidSet
(
FieldIndex
<
IDX_MediumOverride
>
nsString
&
&
aOldValue
)
;
bool
CanSet
(
FieldIndex
<
IDX_SuspendMediaWhenInactive
>
bool
ContentParent
*
)
{
return
IsTop
(
)
;
}
bool
CanSet
(
FieldIndex
<
IDX_TouchEventsOverrideInternal
>
dom
:
:
TouchEventsOverride
aTouchEventsOverride
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_DisplayMode
>
const
enum
DisplayMode
&
aDisplayMode
ContentParent
*
aSource
)
{
return
IsTop
(
)
;
}
void
DidSet
(
FieldIndex
<
IDX_DisplayMode
>
enum
DisplayMode
aOldValue
)
;
void
DidSet
(
FieldIndex
<
IDX_ExplicitActive
>
ExplicitActiveStatus
aOldValue
)
;
bool
CanSet
(
FieldIndex
<
IDX_IsActiveBrowserWindowInternal
>
const
bool
&
aValue
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_IsActiveBrowserWindowInternal
>
bool
aOldValue
)
;
void
DidSet
(
FieldIndex
<
IDX_Muted
>
)
;
bool
CanSet
(
FieldIndex
<
IDX_OverrideDPPX
>
const
float
&
aValue
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_OverrideDPPX
>
float
aOldValue
)
;
bool
CanSet
(
FieldIndex
<
IDX_EmbedderInnerWindowId
>
const
uint64_t
&
aValue
ContentParent
*
aSource
)
;
CanSetResult
CanSet
(
FieldIndex
<
IDX_CurrentInnerWindowId
>
const
uint64_t
&
aValue
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_CurrentInnerWindowId
>
)
;
bool
CanSet
(
FieldIndex
<
IDX_IsPopupSpam
>
const
bool
&
aValue
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_IsPopupSpam
>
)
;
void
DidSet
(
FieldIndex
<
IDX_GVAudibleAutoplayRequestStatus
>
)
;
void
DidSet
(
FieldIndex
<
IDX_GVInaudibleAutoplayRequestStatus
>
)
;
void
DidSet
(
FieldIndex
<
IDX_Loading
>
)
;
void
DidSet
(
FieldIndex
<
IDX_AncestorLoading
>
)
;
void
DidSet
(
FieldIndex
<
IDX_PlatformOverride
>
)
;
bool
CanSet
(
FieldIndex
<
IDX_PlatformOverride
>
const
nsString
&
aPlatformOverride
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_UserAgentOverride
>
)
;
bool
CanSet
(
FieldIndex
<
IDX_UserAgentOverride
>
const
nsString
&
aUserAgent
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_OrientationLock
>
const
mozilla
:
:
hal
:
:
ScreenOrientation
&
aOrientationLock
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_EmbedderElementType
>
const
Maybe
<
nsString
>
&
aInitiatorType
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_MessageManagerGroup
>
const
nsString
&
aMessageManagerGroup
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_AllowContentRetargeting
>
const
bool
&
aAllowContentRetargeting
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_AllowContentRetargetingOnChildren
>
const
bool
&
aAllowContentRetargetingOnChildren
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_AllowPlugins
>
const
bool
&
aAllowPlugins
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_FullscreenAllowedByOwner
>
const
bool
&
ContentParent
*
)
;
bool
CanSet
(
FieldIndex
<
IDX_WatchedByDevToolsInternal
>
const
bool
&
aWatchedByDevToolsInternal
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_DefaultLoadFlags
>
const
uint32_t
&
aDefaultLoadFlags
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_DefaultLoadFlags
>
)
;
bool
CanSet
(
FieldIndex
<
IDX_UseGlobalHistory
>
const
bool
&
aUseGlobalHistory
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_HasSessionHistory
>
bool
aOldValue
)
;
bool
CanSet
(
FieldIndex
<
IDX_BrowserId
>
const
uint32_t
&
aValue
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_UseErrorPages
>
const
bool
&
aUseErrorPages
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_PendingInitialization
>
bool
aNewValue
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_HasMainMediaController
>
bool
aNewValue
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_HasMainMediaController
>
bool
aOldValue
)
;
template
<
size_t
I
typename
T
>
bool
CanSet
(
FieldIndex
<
I
>
const
T
&
ContentParent
*
)
{
return
true
;
}
template
<
size_t
I
>
void
DidSet
(
FieldIndex
<
I
>
)
{
}
template
<
size_t
I
typename
T
>
void
DidSet
(
FieldIndex
<
I
>
T
&
&
aOldValue
)
{
}
void
DidSet
(
FieldIndex
<
IDX_FullZoom
>
float
aOldValue
)
;
void
DidSet
(
FieldIndex
<
IDX_TextZoom
>
float
aOldValue
)
;
void
DidSet
(
FieldIndex
<
IDX_AuthorStyleDisabledDefault
>
)
;
bool
CanSet
(
FieldIndex
<
IDX_IsInBFCache
>
bool
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_IsInBFCache
>
)
;
bool
LegacyCheckOnlyOwningProcessCanSet
(
ContentParent
*
aSource
)
;
bool
CheckOnlyEmbedderCanSet
(
ContentParent
*
aSource
)
;
void
CreateChildSHistory
(
)
;
using
PrincipalWithLoadIdentifierTuple
=
Tuple
<
nsCOMPtr
<
nsIPrincipal
>
uint64_t
>
;
nsIPrincipal
*
GetSavedPrincipal
(
Maybe
<
PrincipalWithLoadIdentifierTuple
>
aPrincipalTuple
)
;
const
Type
mType
;
const
uint64_t
mBrowsingContextId
;
RefPtr
<
BrowsingContextGroup
>
mGroup
;
RefPtr
<
WindowContext
>
mParentWindow
;
nsCOMPtr
<
nsIDocShell
>
mDocShell
;
RefPtr
<
Element
>
mEmbedderElement
;
nsTArray
<
RefPtr
<
WindowContext
>
>
mWindowContexts
;
RefPtr
<
WindowContext
>
mCurrentWindowContext
;
JS
:
:
Heap
<
JSObject
*
>
mWindowProxy
;
LocationProxy
mLocation
;
OriginAttributes
mOriginAttributes
;
uint64_t
mRequestContextId
=
0
;
uint32_t
mPrivateBrowsingId
;
bool
mEverAttached
:
1
;
bool
mIsInProcess
:
1
;
bool
mIsDiscarded
:
1
;
bool
mWindowless
:
1
;
bool
mDanglingRemoteOuterProxies
:
1
;
bool
mEmbeddedByThisProcess
:
1
;
bool
mUseRemoteTabs
:
1
;
bool
mUseRemoteSubframes
:
1
;
bool
mCreatedDynamically
:
1
;
TimeStamp
mUserGestureStart
;
Maybe
<
PrincipalWithLoadIdentifierTuple
>
mTriggeringPrincipal
;
Maybe
<
PrincipalWithLoadIdentifierTuple
>
mPrincipalToInherit
;
class
DeprioritizedLoadRunner
:
public
mozilla
:
:
Runnable
public
mozilla
:
:
LinkedListElement
<
DeprioritizedLoadRunner
>
{
public
:
explicit
DeprioritizedLoadRunner
(
nsIRunnable
*
aInner
)
:
Runnable
(
"
DeprioritizedLoadRunner
"
)
mInner
(
aInner
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mInner
)
{
RefPtr
<
nsIRunnable
>
inner
=
std
:
:
move
(
mInner
)
;
inner
-
>
Run
(
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
nsIRunnable
>
mInner
;
}
;
mozilla
:
:
LinkedList
<
DeprioritizedLoadRunner
>
mDeprioritizedLoadRunner
;
RefPtr
<
SessionStorageManager
>
mSessionStorageManager
;
RefPtr
<
ChildSHistory
>
mChildSessionHistory
;
uint32_t
mLocationChangeRateLimitCount
;
mozilla
:
:
TimeStamp
mLocationChangeRateLimitSpanStart
;
}
;
extern
bool
GetRemoteOuterWindowProxy
(
JSContext
*
aCx
BrowsingContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aTransplantTo
JS
:
:
MutableHandle
<
JSObject
*
>
aRetVal
)
;
using
BrowsingContextTransaction
=
BrowsingContext
:
:
BaseTransaction
;
using
BrowsingContextInitializer
=
BrowsingContext
:
:
IPCInitializer
;
using
MaybeDiscardedBrowsingContext
=
MaybeDiscarded
<
BrowsingContext
>
;
extern
template
class
syncedcontext
:
:
Transaction
<
BrowsingContext
>
;
}
namespace
ipc
{
template
<
>
struct
IPDLParamTraits
<
dom
:
:
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
>
{
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
dom
:
:
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
&
aParam
)
;
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
dom
:
:
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
*
aResult
)
;
}
;
template
<
>
struct
IPDLParamTraits
<
dom
:
:
BrowsingContext
:
:
IPCInitializer
>
{
static
void
Write
(
IPC
:
:
Message
*
aMessage
IProtocol
*
aActor
const
dom
:
:
BrowsingContext
:
:
IPCInitializer
&
aInitializer
)
;
static
bool
Read
(
const
IPC
:
:
Message
*
aMessage
PickleIterator
*
aIterator
IProtocol
*
aActor
dom
:
:
BrowsingContext
:
:
IPCInitializer
*
aInitializer
)
;
}
;
}
}
#
endif
