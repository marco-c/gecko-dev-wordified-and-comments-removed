#
ifndef
mozilla_dom_BrowsingContext_h
#
define
mozilla_dom_BrowsingContext_h
#
include
"
GVAutoplayRequestUtils
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
LoadURIOptionsBinding
.
h
"
#
include
"
mozilla
/
dom
/
LocationBase
.
h
"
#
include
"
mozilla
/
dom
/
MaybeDiscarded
.
h
"
#
include
"
mozilla
/
dom
/
FeaturePolicyUtils
.
h
"
#
include
"
mozilla
/
dom
/
SessionStorageManager
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
mozilla
/
dom
/
SyncedContext
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsILoadInfo
.
h
"
class
nsDocShellLoadState
;
class
nsGlobalWindowOuter
;
class
nsIPrincipal
;
class
nsOuterWindowProxy
;
class
PickleIterator
;
namespace
IPC
{
class
Message
;
}
namespace
mozilla
{
class
ErrorResult
;
class
LogModule
;
namespace
ipc
{
class
IProtocol
;
template
<
typename
T
>
struct
IPDLParamTraits
;
}
namespace
dom
{
class
BrowsingContent
;
class
BrowsingContextGroup
;
class
CanonicalBrowsingContext
;
class
ContentParent
;
class
Element
;
template
<
typename
>
struct
Nullable
;
template
<
typename
T
>
class
Sequence
;
class
StructuredCloneHolder
;
class
WindowContext
;
struct
WindowPostMessageOptions
;
class
WindowProxyHolder
;
#
define
MOZ_EACH_BC_FIELD
(
FIELD
)
\
FIELD
(
Name
nsString
)
\
FIELD
(
Closed
bool
)
\
FIELD
(
IsActive
bool
)
\
FIELD
(
EmbedderPolicy
nsILoadInfo
:
:
CrossOriginEmbedderPolicy
)
\
FIELD
(
OpenerPolicy
nsILoadInfo
:
:
CrossOriginOpenerPolicy
)
\
/
*
Current
opener
for
the
BrowsingContext
.
Weak
reference
*
/
\
FIELD
(
OpenerId
uint64_t
)
\
FIELD
(
OnePermittedSandboxedNavigatorId
uint64_t
)
\
/
*
WindowID
of
the
inner
window
which
embeds
this
BC
*
/
\
FIELD
(
EmbedderInnerWindowId
uint64_t
)
\
FIELD
(
CurrentInnerWindowId
uint64_t
)
\
FIELD
(
HadOriginalOpener
bool
)
\
FIELD
(
IsPopupSpam
bool
)
\
/
*
Controls
whether
the
BrowsingContext
is
currently
considered
to
be
\
*
activated
by
a
gesture
*
/
\
FIELD
(
UserActivationState
UserActivation
:
:
State
)
\
/
*
Hold
the
audio
muted
state
and
should
be
used
on
top
level
browsing
\
*
contexts
only
*
/
\
FIELD
(
Muted
bool
)
\
FIELD
(
FeaturePolicy
RefPtr
<
mozilla
:
:
dom
:
:
FeaturePolicy
>
)
\
/
*
See
nsSandboxFlags
.
h
for
the
possible
flags
.
*
/
\
FIELD
(
SandboxFlags
uint32_t
)
\
FIELD
(
HistoryID
nsID
)
\
FIELD
(
InRDMPane
bool
)
\
FIELD
(
Loading
bool
)
\
FIELD
(
AncestorLoading
bool
)
\
/
*
These
field
are
used
to
store
the
states
of
autoplay
media
request
on
\
*
GeckoView
only
and
it
would
only
be
modified
on
the
top
level
browsing
\
*
context
.
*
/
\
FIELD
(
GVAudibleAutoplayRequestStatus
GVAutoplayRequestStatus
)
\
FIELD
(
GVInaudibleAutoplayRequestStatus
GVAutoplayRequestStatus
)
\
/
*
ScreenOrientation
-
related
APIs
*
/
\
FIELD
(
CurrentOrientationAngle
float
)
\
FIELD
(
CurrentOrientationType
mozilla
:
:
dom
:
:
OrientationType
)
class
BrowsingContext
:
public
nsISupports
public
nsWrapperCache
{
MOZ_DECL_SYNCED_CONTEXT
(
BrowsingContext
MOZ_EACH_BC_FIELD
)
public
:
enum
class
Type
{
Chrome
Content
}
;
using
Children
=
nsTArray
<
RefPtr
<
BrowsingContext
>
>
;
static
void
Init
(
)
;
static
LogModule
*
GetLog
(
)
;
static
void
CleanupContexts
(
uint64_t
aProcessId
)
;
static
already_AddRefed
<
BrowsingContext
>
Get
(
uint64_t
aId
)
;
static
already_AddRefed
<
BrowsingContext
>
Get
(
GlobalObject
&
uint64_t
aId
)
{
return
Get
(
aId
)
;
}
static
already_AddRefed
<
BrowsingContext
>
GetFromWindow
(
WindowProxyHolder
&
aProxy
)
;
static
already_AddRefed
<
BrowsingContext
>
GetFromWindow
(
GlobalObject
&
WindowProxyHolder
&
aProxy
)
{
return
GetFromWindow
(
aProxy
)
;
}
static
already_AddRefed
<
BrowsingContext
>
Create
(
BrowsingContext
*
aParent
BrowsingContext
*
aOpener
const
nsAString
&
aName
Type
aType
)
;
static
already_AddRefed
<
BrowsingContext
>
CreateDetached
(
BrowsingContext
*
aParent
BrowsingContext
*
aOpener
const
nsAString
&
aName
Type
aType
)
;
static
already_AddRefed
<
BrowsingContext
>
CreateWindowless
(
BrowsingContext
*
aParent
BrowsingContext
*
aOpener
const
nsAString
&
aName
Type
aType
)
;
void
EnsureAttached
(
)
;
bool
EverAttached
(
)
const
{
return
mEverAttached
;
}
CanonicalBrowsingContext
*
Canonical
(
)
;
bool
IsInProcess
(
)
const
{
return
mIsInProcess
;
}
bool
IsDiscarded
(
)
const
{
return
mIsDiscarded
;
}
bool
Windowless
(
)
const
{
return
mWindowless
;
}
void
SetWindowless
(
)
;
nsIDocShell
*
GetDocShell
(
)
const
{
return
mDocShell
;
}
void
SetDocShell
(
nsIDocShell
*
aDocShell
)
;
void
ClearDocShell
(
)
{
mDocShell
=
nullptr
;
}
void
CleanUpDanglingRemoteOuterWindowProxies
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aOuter
)
;
Element
*
GetEmbedderElement
(
)
const
{
return
mEmbedderElement
;
}
void
SetEmbedderElement
(
Element
*
aEmbedder
)
;
void
Embed
(
)
;
nsPIDOMWindowOuter
*
GetDOMWindow
(
)
const
{
return
mDocShell
?
mDocShell
-
>
GetWindow
(
)
:
nullptr
;
}
void
Attach
(
bool
aFromIPC
=
false
)
;
void
Detach
(
bool
aFromIPC
=
false
)
;
void
PrepareForProcessChange
(
)
;
void
CacheChildren
(
bool
aFromIPC
=
false
)
;
void
RestoreChildren
(
Children
&
&
aChildren
bool
aFromIPC
=
false
)
;
nsresult
LoadURI
(
BrowsingContext
*
aAccessor
nsDocShellLoadState
*
aLoadState
bool
aSetNavigating
=
false
)
;
nsresult
InternalLoad
(
BrowsingContext
*
aAccessor
nsDocShellLoadState
*
aLoadState
nsIDocShell
*
*
aDocShell
nsIRequest
*
*
aRequest
)
;
void
DisplayLoadError
(
const
nsAString
&
aURI
)
;
bool
IsCached
(
)
;
bool
IsTargetable
(
)
;
const
nsString
&
Name
(
)
const
{
return
GetName
(
)
;
}
void
GetName
(
nsAString
&
aName
)
{
aName
=
GetName
(
)
;
}
bool
NameEquals
(
const
nsAString
&
aName
)
{
return
GetName
(
)
.
Equals
(
aName
)
;
}
Type
GetType
(
)
const
{
return
mType
;
}
bool
IsContent
(
)
const
{
return
mType
=
=
Type
:
:
Content
;
}
bool
IsChrome
(
)
const
{
return
!
IsContent
(
)
;
}
bool
IsTop
(
)
const
{
return
!
GetParent
(
)
;
}
bool
IsTopContent
(
)
const
{
return
IsContent
(
)
&
&
!
GetParent
(
)
;
}
bool
IsContentSubframe
(
)
const
{
return
IsContent
(
)
&
&
GetParent
(
)
;
}
uint64_t
Id
(
)
const
{
return
mBrowsingContextId
;
}
BrowsingContext
*
GetParent
(
)
const
{
MOZ_ASSERT_IF
(
mParent
mParent
-
>
mType
=
=
mType
)
;
return
mParent
;
}
BrowsingContext
*
Top
(
)
;
already_AddRefed
<
BrowsingContext
>
GetOpener
(
)
const
{
RefPtr
<
BrowsingContext
>
opener
(
Get
(
GetOpenerId
(
)
)
)
;
if
(
!
mIsDiscarded
&
&
opener
&
&
!
opener
-
>
mIsDiscarded
)
{
MOZ_DIAGNOSTIC_ASSERT
(
opener
-
>
mType
=
=
mType
)
;
return
opener
.
forget
(
)
;
}
return
nullptr
;
}
void
SetOpener
(
BrowsingContext
*
aOpener
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aOpener
|
|
aOpener
-
>
Group
(
)
=
=
Group
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aOpener
|
|
aOpener
-
>
mType
=
=
mType
)
;
SetOpenerId
(
aOpener
?
aOpener
-
>
Id
(
)
:
0
)
;
}
bool
HasOpener
(
)
const
;
bool
HadOriginalOpener
(
)
const
{
return
GetHadOriginalOpener
(
)
;
}
already_AddRefed
<
BrowsingContext
>
GetOnePermittedSandboxedNavigator
(
)
const
{
return
Get
(
GetOnePermittedSandboxedNavigatorId
(
)
)
;
}
void
SetOnePermittedSandboxedNavigator
(
BrowsingContext
*
aNavigator
)
{
if
(
GetOnePermittedSandboxedNavigatorId
(
)
)
{
MOZ_ASSERT
(
false
"
One
Permitted
Sandboxed
Navigator
should
only
be
set
once
.
"
)
;
}
else
{
SetOnePermittedSandboxedNavigatorId
(
aNavigator
?
aNavigator
-
>
Id
(
)
:
0
)
;
}
}
uint32_t
SandboxFlags
(
)
{
return
GetSandboxFlags
(
)
;
}
void
GetChildren
(
Children
&
aChildren
)
;
void
GetWindowContexts
(
nsTArray
<
RefPtr
<
WindowContext
>
>
&
aWindows
)
;
void
RegisterWindowContext
(
WindowContext
*
aWindow
)
;
void
UnregisterWindowContext
(
WindowContext
*
aWindow
)
;
WindowContext
*
GetCurrentWindowContext
(
)
const
{
return
mCurrentWindowContext
;
}
BrowsingContextGroup
*
Group
(
)
{
return
mGroup
;
}
bool
InRDMPane
(
)
const
{
return
GetInRDMPane
(
)
;
}
bool
IsLoading
(
)
;
void
SetCurrentOrientation
(
OrientationType
aType
float
aAngle
)
{
SetCurrentOrientationType
(
aType
)
;
SetCurrentOrientationAngle
(
aAngle
)
;
}
void
SetRDMPaneOrientation
(
OrientationType
aType
float
aAngle
)
{
if
(
InRDMPane
(
)
)
{
SetCurrentOrientation
(
aType
aAngle
)
;
}
}
BrowsingContext
*
FindWithName
(
const
nsAString
&
aName
bool
aUseEntryGlobalForAccessCheck
=
true
)
;
BrowsingContext
*
FindChildWithName
(
const
nsAString
&
aName
BrowsingContext
&
aRequestingContext
)
;
BrowsingContext
*
FindWithNameInSubtree
(
const
nsAString
&
aName
BrowsingContext
&
aRequestingContext
)
;
nsISupports
*
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
void
NotifyUserGestureActivation
(
)
;
void
NotifyResetUserGestureActivation
(
)
;
bool
HasBeenUserGestureActivated
(
)
;
bool
HasValidTransientUserGestureActivation
(
)
;
bool
ConsumeTransientUserGestureActivation
(
)
;
inline
JSObject
*
GetWindowProxy
(
)
const
{
return
mWindowProxy
;
}
inline
JSObject
*
GetUnbarrieredWindowProxy
(
)
const
{
return
mWindowProxy
.
unbarrieredGet
(
)
;
}
void
SetWindowProxy
(
JS
:
:
Handle
<
JSObject
*
>
aWindowProxy
)
{
mWindowProxy
=
aWindowProxy
;
}
Nullable
<
WindowProxyHolder
>
GetWindow
(
)
;
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
BrowsingContext
)
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
BrowsingContext
)
const
Children
&
GetChildren
(
)
{
return
mChildren
;
}
const
nsTArray
<
RefPtr
<
WindowContext
>
>
&
GetWindowContexts
(
)
{
return
mWindowContexts
;
}
void
PreOrderWalk
(
const
std
:
:
function
<
void
(
BrowsingContext
*
)
>
&
aCallback
)
{
aCallback
(
this
)
;
for
(
auto
&
child
:
GetChildren
(
)
)
{
child
-
>
PreOrderWalk
(
aCallback
)
;
}
}
void
PostOrderWalk
(
const
std
:
:
function
<
void
(
BrowsingContext
*
)
>
&
aCallback
)
{
for
(
auto
&
child
:
GetChildren
(
)
)
{
child
-
>
PostOrderWalk
(
aCallback
)
;
}
aCallback
(
this
)
;
}
WindowProxyHolder
Window
(
)
;
BrowsingContext
*
Self
(
)
{
return
this
;
}
void
Location
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aLocation
ErrorResult
&
aError
)
;
void
Close
(
CallerType
aCallerType
ErrorResult
&
aError
)
;
bool
GetClosed
(
ErrorResult
&
)
{
return
GetClosed
(
)
;
}
void
Focus
(
CallerType
aCallerType
ErrorResult
&
aError
)
;
void
Blur
(
ErrorResult
&
aError
)
;
WindowProxyHolder
GetFrames
(
ErrorResult
&
aError
)
;
int32_t
Length
(
)
const
{
return
mChildren
.
Length
(
)
;
}
Nullable
<
WindowProxyHolder
>
GetTop
(
ErrorResult
&
aError
)
;
void
GetOpener
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aOpener
ErrorResult
&
aError
)
const
;
Nullable
<
WindowProxyHolder
>
GetParent
(
ErrorResult
&
aError
)
;
void
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
const
Sequence
<
JSObject
*
>
&
aTransfer
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
;
void
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
WindowPostMessageOptions
&
aOptions
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
)
;
static
JSObject
*
ReadStructuredClone
(
JSContext
*
aCx
JSStructuredCloneReader
*
aReader
StructuredCloneHolder
*
aHolder
)
;
bool
WriteStructuredClone
(
JSContext
*
aCx
JSStructuredCloneWriter
*
aWriter
StructuredCloneHolder
*
aHolder
)
;
void
StartDelayedAutoplayMediaComponents
(
)
;
void
ResetGVAutoplayRequestStatus
(
)
;
struct
IPCInitializer
{
uint64_t
mId
;
uint64_t
mParentId
;
already_AddRefed
<
BrowsingContext
>
GetParent
(
)
;
already_AddRefed
<
BrowsingContext
>
GetOpener
(
)
;
uint64_t
GetOpenerId
(
)
const
{
return
mozilla
:
:
Get
<
IDX_OpenerId
>
(
mFields
)
;
}
bool
mCached
;
bool
mWindowless
;
FieldTuple
mFields
;
}
;
IPCInitializer
GetIPCInitializer
(
)
;
static
already_AddRefed
<
BrowsingContext
>
CreateFromIPC
(
IPCInitializer
&
&
aInitializer
BrowsingContextGroup
*
aGroup
ContentParent
*
aOriginProcess
)
;
bool
CanAccess
(
BrowsingContext
*
aTarget
bool
aConsiderOpener
=
true
)
;
void
AddDeprioritizedLoadRunner
(
nsIRunnable
*
aRunner
)
;
RefPtr
<
SessionStorageManager
>
GetSessionStorageManager
(
)
;
bool
PendingInitialization
(
)
const
{
return
mPendingInitialization
;
}
;
void
SetPendingInitialization
(
bool
aVal
)
{
mPendingInitialization
=
aVal
;
}
;
protected
:
virtual
~
BrowsingContext
(
)
;
BrowsingContext
(
BrowsingContext
*
aParent
BrowsingContextGroup
*
aGroup
uint64_t
aBrowsingContextId
Type
aType
FieldTuple
&
&
aFields
)
;
private
:
BrowsingContext
*
FindWithSpecialName
(
const
nsAString
&
aName
BrowsingContext
&
aRequestingContext
)
;
friend
class
:
:
nsOuterWindowProxy
;
friend
class
:
:
nsGlobalWindowOuter
;
friend
class
WindowContext
;
void
UpdateWindowProxy
(
JSObject
*
obj
JSObject
*
old
)
{
if
(
mWindowProxy
)
{
MOZ_ASSERT
(
mWindowProxy
=
=
old
)
;
mWindowProxy
=
obj
;
}
}
void
ClearWindowProxy
(
)
{
mWindowProxy
=
nullptr
;
}
friend
class
Location
;
friend
class
RemoteLocationProxy
;
class
LocationProxy
final
:
public
LocationBase
{
public
:
MozExternalRefCountType
AddRef
(
)
{
return
GetBrowsingContext
(
)
-
>
AddRef
(
)
;
}
MozExternalRefCountType
Release
(
)
{
return
GetBrowsingContext
(
)
-
>
Release
(
)
;
}
protected
:
friend
class
RemoteLocationProxy
;
BrowsingContext
*
GetBrowsingContext
(
)
override
{
return
reinterpret_cast
<
BrowsingContext
*
>
(
uintptr_t
(
this
)
-
offsetof
(
BrowsingContext
mLocation
)
)
;
}
already_AddRefed
<
nsIDocShell
>
GetDocShell
(
)
override
{
return
nullptr
;
}
}
;
void
SendCommitTransaction
(
ContentParent
*
aParent
const
BaseTransaction
&
aTxn
uint64_t
aEpoch
)
;
void
SendCommitTransaction
(
ContentChild
*
aChild
const
BaseTransaction
&
aTxn
uint64_t
aEpoch
)
;
bool
CanSet
(
FieldIndex
<
IDX_OpenerId
>
const
uint64_t
&
aValue
ContentParent
*
aSource
)
{
if
(
aValue
!
=
0
)
{
RefPtr
<
BrowsingContext
>
opener
=
Get
(
aValue
)
;
return
opener
&
&
opener
-
>
Group
(
)
=
=
Group
(
)
;
}
return
true
;
}
void
DidSet
(
FieldIndex
<
IDX_UserActivationState
>
)
;
void
DidSet
(
FieldIndex
<
IDX_Muted
>
)
;
bool
CanSet
(
FieldIndex
<
IDX_EmbedderInnerWindowId
>
const
uint64_t
&
aValue
ContentParent
*
aSource
)
;
bool
CanSet
(
FieldIndex
<
IDX_CurrentInnerWindowId
>
const
uint64_t
&
aValue
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_CurrentInnerWindowId
>
)
;
bool
CanSet
(
FieldIndex
<
IDX_IsPopupSpam
>
const
bool
&
aValue
ContentParent
*
aSource
)
;
void
DidSet
(
FieldIndex
<
IDX_IsPopupSpam
>
)
;
void
DidSet
(
FieldIndex
<
IDX_GVAudibleAutoplayRequestStatus
>
)
;
void
DidSet
(
FieldIndex
<
IDX_GVInaudibleAutoplayRequestStatus
>
)
;
void
DidSet
(
FieldIndex
<
IDX_Loading
>
)
;
void
DidSet
(
FieldIndex
<
IDX_AncestorLoading
>
)
;
template
<
size_t
I
typename
T
>
bool
CanSet
(
FieldIndex
<
I
>
const
T
&
ContentParent
*
)
{
return
true
;
}
template
<
size_t
I
>
void
DidSet
(
FieldIndex
<
I
>
)
{
}
const
Type
mType
;
const
uint64_t
mBrowsingContextId
;
RefPtr
<
BrowsingContextGroup
>
mGroup
;
RefPtr
<
BrowsingContext
>
mParent
;
Children
mChildren
;
nsCOMPtr
<
nsIDocShell
>
mDocShell
;
RefPtr
<
Element
>
mEmbedderElement
;
nsTArray
<
RefPtr
<
WindowContext
>
>
mWindowContexts
;
RefPtr
<
WindowContext
>
mCurrentWindowContext
;
JS
:
:
Heap
<
JSObject
*
>
mWindowProxy
;
LocationProxy
mLocation
;
bool
mEverAttached
:
1
;
bool
mIsInProcess
:
1
;
bool
mIsDiscarded
:
1
;
bool
mWindowless
:
1
;
bool
mDanglingRemoteOuterProxies
:
1
;
bool
mPendingInitialization
:
1
;
TimeStamp
mUserGestureStart
;
class
DeprioritizedLoadRunner
:
public
mozilla
:
:
Runnable
public
mozilla
:
:
LinkedListElement
<
DeprioritizedLoadRunner
>
{
public
:
explicit
DeprioritizedLoadRunner
(
nsIRunnable
*
aInner
)
:
Runnable
(
"
DeprioritizedLoadRunner
"
)
mInner
(
aInner
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mInner
)
{
RefPtr
<
nsIRunnable
>
inner
=
std
:
:
move
(
mInner
)
;
inner
-
>
Run
(
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
nsIRunnable
>
mInner
;
}
;
mozilla
:
:
LinkedList
<
DeprioritizedLoadRunner
>
mDeprioritizedLoadRunner
;
RefPtr
<
dom
:
:
SessionStorageManager
>
mSessionStorageManager
;
}
;
extern
bool
GetRemoteOuterWindowProxy
(
JSContext
*
aCx
BrowsingContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aTransplantTo
JS
:
:
MutableHandle
<
JSObject
*
>
aRetVal
)
;
using
BrowsingContextTransaction
=
BrowsingContext
:
:
BaseTransaction
;
using
BrowsingContextInitializer
=
BrowsingContext
:
:
IPCInitializer
;
using
BrowsingContextChildren
=
BrowsingContext
:
:
Children
;
using
MaybeDiscardedBrowsingContext
=
MaybeDiscarded
<
BrowsingContext
>
;
extern
template
class
syncedcontext
:
:
Transaction
<
BrowsingContext
>
;
}
namespace
ipc
{
template
<
>
struct
IPDLParamTraits
<
dom
:
:
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
>
{
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
dom
:
:
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
&
aParam
)
;
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
dom
:
:
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
*
aResult
)
;
}
;
template
<
>
struct
IPDLParamTraits
<
dom
:
:
BrowsingContext
*
>
{
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
dom
:
:
BrowsingContext
*
aParam
)
;
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
RefPtr
<
dom
:
:
BrowsingContext
>
*
aResult
)
;
}
;
template
<
>
struct
IPDLParamTraits
<
dom
:
:
BrowsingContext
:
:
IPCInitializer
>
{
static
void
Write
(
IPC
:
:
Message
*
aMessage
IProtocol
*
aActor
const
dom
:
:
BrowsingContext
:
:
IPCInitializer
&
aInitializer
)
;
static
bool
Read
(
const
IPC
:
:
Message
*
aMessage
PickleIterator
*
aIterator
IProtocol
*
aActor
dom
:
:
BrowsingContext
:
:
IPCInitializer
*
aInitializer
)
;
}
;
}
}
#
endif
