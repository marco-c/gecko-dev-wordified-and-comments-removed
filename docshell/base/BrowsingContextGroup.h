#
ifndef
mozilla_dom_BrowsingContextGroup_h
#
define
mozilla_dom_BrowsingContextGroup_h
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
FunctionRef
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsXULAppAPI
.
h
"
namespace
mozilla
{
class
ThrottledEventQueue
;
namespace
dom
{
class
BrowsingContext
;
class
WindowContext
;
class
ContentParent
;
class
DocGroup
;
class
BrowsingContextGroup
final
:
public
nsWrapperCache
{
public
:
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
BrowsingContextGroup
)
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS
(
BrowsingContextGroup
)
void
Register
(
nsISupports
*
aContext
)
;
void
Unregister
(
nsISupports
*
aContext
)
;
void
EnsureHostProcess
(
ContentParent
*
aProcess
)
;
void
RemoveHostProcess
(
ContentParent
*
aProcess
)
;
void
Subscribe
(
ContentParent
*
aProcess
)
;
void
Unsubscribe
(
ContentParent
*
aProcess
)
;
ContentParent
*
GetHostProcess
(
const
nsACString
&
aRemoteType
)
;
void
AddKeepAlive
(
)
;
void
RemoveKeepAlive
(
)
;
void
UpdateToplevelsSuspendedIfNeeded
(
)
;
nsTArray
<
RefPtr
<
BrowsingContext
>
>
&
Toplevels
(
)
{
return
mToplevels
;
}
void
GetToplevels
(
nsTArray
<
RefPtr
<
BrowsingContext
>
>
&
aToplevels
)
{
aToplevels
.
AppendElements
(
mToplevels
)
;
}
uint64_t
Id
(
)
{
return
mId
;
}
nsISupports
*
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
static
already_AddRefed
<
BrowsingContextGroup
>
GetOrCreate
(
uint64_t
aId
)
;
static
already_AddRefed
<
BrowsingContextGroup
>
Create
(
)
;
static
already_AddRefed
<
BrowsingContextGroup
>
Select
(
WindowContext
*
aParent
BrowsingContext
*
aOpener
)
;
template
<
typename
Func
>
void
EachOtherParent
(
ContentParent
*
aExcludedParent
Func
&
&
aCallback
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
for
(
auto
iter
=
mSubscribers
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
Get
(
)
-
>
GetKey
(
)
!
=
aExcludedParent
)
{
aCallback
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
}
}
}
template
<
typename
Func
>
void
EachParent
(
Func
&
&
aCallback
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
for
(
auto
iter
=
mSubscribers
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aCallback
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
}
}
nsresult
QueuePostMessageEvent
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
void
FlushPostMessageEvents
(
)
;
void
UpdateInputTaskManagerIfNeeded
(
)
;
static
BrowsingContextGroup
*
GetChromeGroup
(
)
;
void
GetDocGroups
(
nsTArray
<
DocGroup
*
>
&
aDocGroups
)
;
already_AddRefed
<
DocGroup
>
AddDocument
(
const
nsACString
&
aKey
Document
*
aDocument
)
;
void
RemoveDocument
(
const
nsACString
&
aKey
Document
*
aDocument
)
;
auto
DocGroups
(
)
const
{
return
mDocGroups
.
ConstIter
(
)
;
}
mozilla
:
:
ThrottledEventQueue
*
GetTimerEventQueue
(
)
const
{
return
mTimerEventQueue
;
}
mozilla
:
:
ThrottledEventQueue
*
GetWorkerEventQueue
(
)
const
{
return
mWorkerEventQueue
;
}
static
void
GetAllGroups
(
nsTArray
<
RefPtr
<
BrowsingContextGroup
>
>
&
aGroups
)
;
void
IncInputEventSuspensionLevel
(
)
;
void
DecInputEventSuspensionLevel
(
)
;
private
:
friend
class
CanonicalBrowsingContext
;
explicit
BrowsingContextGroup
(
uint64_t
aId
)
;
~
BrowsingContextGroup
(
)
;
void
MaybeDestroy
(
)
;
void
Destroy
(
)
;
bool
ShouldSuspendAllTopLevelContexts
(
)
const
;
uint64_t
mId
;
uint32_t
mKeepAliveCount
=
0
;
#
ifdef
DEBUG
bool
mDestroyed
=
false
;
#
endif
nsTHashtable
<
nsRefPtrHashKey
<
nsISupports
>
>
mContexts
;
nsTArray
<
RefPtr
<
BrowsingContext
>
>
mToplevels
;
bool
mToplevelsSuspended
=
false
;
nsRefPtrHashtable
<
nsCStringHashKey
DocGroup
>
mDocGroups
;
nsRefPtrHashtable
<
nsCStringHashKey
ContentParent
>
mHosts
;
nsTHashtable
<
nsRefPtrHashKey
<
ContentParent
>
>
mSubscribers
;
RefPtr
<
mozilla
:
:
ThrottledEventQueue
>
mPostMessageEventQueue
;
RefPtr
<
mozilla
:
:
ThrottledEventQueue
>
mTimerEventQueue
;
RefPtr
<
mozilla
:
:
ThrottledEventQueue
>
mWorkerEventQueue
;
uint32_t
mInputEventSuspensionLevel
=
0
;
}
;
}
}
#
endif
