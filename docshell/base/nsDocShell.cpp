#
include
"
nsDocShell
.
h
"
#
include
<
algorithm
>
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
define
getpid
_getpid
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MediaFeatureChange
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
ScrollTypes
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_extensions
.
h
"
#
include
"
mozilla
/
StaticPrefs_privacy
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
StaticPrefs_fission
.
h
"
#
include
"
mozilla
/
StartupTimeline
.
h
"
#
include
"
mozilla
/
StorageAccess
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
WidgetUtils
.
h
"
#
include
"
mozilla
/
dom
/
ClientChannelHelper
.
h
"
#
include
"
mozilla
/
dom
/
ClientHandle
.
h
"
#
include
"
mozilla
/
dom
/
ClientInfo
.
h
"
#
include
"
mozilla
/
dom
/
ClientManager
.
h
"
#
include
"
mozilla
/
dom
/
ClientSource
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentFrameMessageManager
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAnchorElement
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceNavigation
.
h
"
#
include
"
mozilla
/
dom
/
PermissionMessageUtils
.
h
"
#
include
"
mozilla
/
dom
/
PopupBlocker
.
h
"
#
include
"
mozilla
/
dom
/
ProfileTimelineMarkerBinding
.
h
"
#
include
"
mozilla
/
dom
/
ScreenOrientation
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerInterceptController
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerUtils
.
h
"
#
include
"
mozilla
/
dom
/
SessionStorageManager
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
mozilla
/
dom
/
ChildSHistory
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPContext
.
h
"
#
include
"
mozilla
/
dom
/
LoadURIOptionsBinding
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorChild
.
h
"
#
include
"
mozilla
/
net
/
DocumentChannel
.
h
"
#
include
"
nsSHEntry
.
h
"
#
include
"
mozilla
/
net
/
DocumentChannelChild
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierFeatureFactory
.
h
"
#
include
"
ReferrerInfo
.
h
"
#
include
"
nsIApplicationCacheChannel
.
h
"
#
include
"
nsIApplicationCacheContainer
.
h
"
#
include
"
nsIAppShell
.
h
"
#
include
"
nsIAuthPrompt
.
h
"
#
include
"
nsIAuthPrompt2
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsICaptivePortalService
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIConsoleReportCollector
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIDocumentLoaderFactory
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsIEditingSession
.
h
"
#
include
"
nsIExternalProtocolService
.
h
"
#
include
"
nsIFormPOSTActionChannel
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIIDNService
.
h
"
#
include
"
nsIInputStreamChannel
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsILoadInfo
.
h
"
#
include
"
nsIMultiPartChannel
.
h
"
#
include
"
nsINestedURI
.
h
"
#
include
"
nsINetworkPredictor
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsINSSErrorsService
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIPrivacyTransitionObserver
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIPromptFactory
.
h
"
#
include
"
nsIReflowObserver
.
h
"
#
include
"
nsIScriptChannel
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIScrollObserver
.
h
"
#
include
"
nsISecureBrowserUI
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsISelectionDisplay
.
h
"
#
include
"
nsISHEntry
.
h
"
#
include
"
nsISiteSecurityService
.
h
"
#
include
"
nsISocketProvider
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsIStructuredCloneContainer
.
h
"
#
include
"
nsIBrowserChild
.
h
"
#
include
"
nsITextToSubURI
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsITransportSecurityInfo
.
h
"
#
include
"
nsIUploadChannel
.
h
"
#
include
"
nsIURIFixup
.
h
"
#
include
"
nsIURILoader
.
h
"
#
include
"
nsIViewSourceChannel
.
h
"
#
include
"
nsIWebBrowserChrome
.
h
"
#
include
"
nsIWebBrowserChrome3
.
h
"
#
include
"
nsIWebBrowserChromeFocus
.
h
"
#
include
"
nsIWebBrowserFind
.
h
"
#
include
"
nsIWebProgress
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
#
include
"
nsIWritablePropertyBag2
.
h
"
#
include
"
nsCommandManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
IHistory
.
h
"
#
include
"
IUrlClassifierUITelemetry
.
h
"
#
include
"
nsArray
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsCExternalHandlerService
.
h
"
#
include
"
nsContentDLF
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCURILoader
.
h
"
#
include
"
nsDocShellCID
.
h
"
#
include
"
nsDocShellEditorData
.
h
"
#
include
"
nsDocShellEnumerator
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
#
include
"
nsDocShellLoadTypes
.
h
"
#
include
"
nsDOMCID
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsDSURIContentListener
.
h
"
#
include
"
nsEditingSession
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsISearchService
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsObjectLoadingContent
.
h
"
#
include
"
nsPingListener
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsQueryActor
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRefreshTimer
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsSHistory
.
h
"
#
include
"
SHEntryChild
.
h
"
#
include
"
nsStructuredCloneContainer
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsViewSourceHandler
.
h
"
#
include
"
nsWebBrowserFind
.
h
"
#
include
"
nsWhitespaceTokenizer
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
Navigator
.
h
"
#
include
"
prenv
.
h
"
#
include
"
URIUtils
.
h
"
#
include
"
timeline
/
JavascriptTimelineMarker
.
h
"
#
ifdef
MOZ_PLACES
#
include
"
nsIFaviconService
.
h
"
#
include
"
mozIPlacesPendingOperation
.
h
"
#
endif
#
if
NS_PRINT_PREVIEW
#
include
"
nsIDocumentViewerPrint
.
h
"
#
include
"
nsIWebBrowserPrint
.
h
"
#
endif
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
ProfilerMarkerPayload
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
net
;
#
define
REFRESH_REDIRECT_TIMER
15000
#
define
NS_EVENT_STARVATION_DELAY_HINT
2000
static
NS_DEFINE_CID
(
kAppShellCID
NS_APPSHELL_CID
)
;
static
int32_t
gNumberOfDocumentsLoading
=
0
;
static
int32_t
gDocShellCount
=
0
;
static
uint32_t
gNumberOfPrivateDocShells
=
0
;
#
ifdef
DEBUG
static
mozilla
:
:
LazyLogModule
gDocShellLog
(
"
nsDocShell
"
)
;
static
mozilla
:
:
LazyLogModule
gDocShellAndDOMWindowLeakLogging
(
"
DocShellAndDOMWindowLeak
"
)
;
#
endif
static
mozilla
:
:
LazyLogModule
gDocShellLeakLog
(
"
nsDocShellLeak
"
)
;
extern
mozilla
:
:
LazyLogModule
gPageCacheLog
;
const
char
kBrandBundleURL
[
]
=
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
;
const
char
kAppstringsBundleURL
[
]
=
"
chrome
:
/
/
global
/
locale
/
appstrings
.
properties
"
;
nsIURIFixup
*
nsDocShell
:
:
sURIFixup
=
nullptr
;
static
void
FavorPerformanceHint
(
bool
aPerfOverStarvation
)
{
nsCOMPtr
<
nsIAppShell
>
appShell
=
do_GetService
(
kAppShellCID
)
;
if
(
appShell
)
{
appShell
-
>
FavorPerformanceHint
(
aPerfOverStarvation
Preferences
:
:
GetUint
(
"
docshell
.
event_starvation_delay_hint
"
NS_EVENT_STARVATION_DELAY_HINT
)
)
;
}
}
static
void
IncreasePrivateDocShellCount
(
)
{
gNumberOfPrivateDocShells
+
+
;
if
(
gNumberOfPrivateDocShells
>
1
|
|
!
XRE_IsContentProcess
(
)
)
{
return
;
}
mozilla
:
:
dom
:
:
ContentChild
*
cc
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
cc
-
>
SendPrivateDocShellsExist
(
true
)
;
}
static
void
DecreasePrivateDocShellCount
(
)
{
MOZ_ASSERT
(
gNumberOfPrivateDocShells
>
0
)
;
gNumberOfPrivateDocShells
-
-
;
if
(
!
gNumberOfPrivateDocShells
)
{
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
cc
-
>
SendPrivateDocShellsExist
(
false
)
;
return
;
}
nsCOMPtr
<
nsIObserverService
>
obsvc
=
services
:
:
GetObserverService
(
)
;
if
(
obsvc
)
{
obsvc
-
>
NotifyObservers
(
nullptr
"
last
-
pb
-
context
-
exited
"
nullptr
)
;
}
}
}
static
bool
IsTopLevelDoc
(
BrowsingContext
*
aBrowsingContext
nsILoadInfo
*
aLoadInfo
)
{
MOZ_ASSERT
(
aBrowsingContext
)
;
MOZ_ASSERT
(
aLoadInfo
)
;
if
(
aLoadInfo
-
>
GetExternalContentPolicyType
(
)
!
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
)
{
return
false
;
}
return
aBrowsingContext
-
>
IsTopContent
(
)
;
}
static
bool
IsUrgentStart
(
BrowsingContext
*
aBrowsingContext
nsILoadInfo
*
aLoadInfo
uint32_t
aLoadType
)
{
MOZ_ASSERT
(
aBrowsingContext
)
;
MOZ_ASSERT
(
aLoadInfo
)
;
if
(
!
IsTopLevelDoc
(
aBrowsingContext
aLoadInfo
)
)
{
return
false
;
}
if
(
aLoadType
&
(
nsIDocShell
:
:
LOAD_CMD_NORMAL
|
nsIDocShell
:
:
LOAD_CMD_HISTORY
)
)
{
return
true
;
}
return
aBrowsingContext
-
>
GetIsActive
(
)
;
}
nsDocShell
:
:
nsDocShell
(
BrowsingContext
*
aBrowsingContext
uint64_t
aContentWindowID
)
:
nsDocLoader
(
)
mHistoryID
(
aBrowsingContext
-
>
GetHistoryID
(
)
)
mContentWindowID
(
aContentWindowID
)
mBrowsingContext
(
aBrowsingContext
)
mForcedCharset
(
nullptr
)
mParentCharset
(
nullptr
)
mTreeOwner
(
nullptr
)
mScrollbarPref
(
ScrollbarPreference
:
:
Auto
)
mCharsetReloadState
(
eCharsetReloadInit
)
mOrientationLock
(
hal
:
:
eScreenOrientation_None
)
mParentCharsetSource
(
0
)
mFrameMargins
(
-
1
-
1
)
mItemType
(
aBrowsingContext
-
>
IsContent
(
)
?
typeContent
:
typeChrome
)
mPreviousEntryIndex
(
-
1
)
mLoadedEntryIndex
(
-
1
)
mChildOffset
(
0
)
mBusyFlags
(
BUSY_FLAGS_NONE
)
mAppType
(
nsIDocShell
:
:
APP_TYPE_UNKNOWN
)
mLoadType
(
0
)
mDefaultLoadFlags
(
nsIRequest
:
:
LOAD_NORMAL
)
mFailedLoadType
(
0
)
mFrameType
(
FRAME_TYPE_REGULAR
)
mDisplayMode
(
nsIDocShell
:
:
DISPLAY_MODE_BROWSER
)
mJSRunToCompletionDepth
(
0
)
mTouchEventsOverride
(
nsIDocShell
:
:
TOUCHEVENTS_OVERRIDE_NONE
)
mMetaViewportOverride
(
nsIDocShell
:
:
META_VIEWPORT_OVERRIDE_NONE
)
mFullscreenAllowed
(
CHECK_ATTRIBUTES
)
mCreatingDocument
(
false
)
#
ifdef
DEBUG
mInEnsureScriptEnv
(
false
)
#
endif
mCreated
(
false
)
mAllowSubframes
(
true
)
mAllowJavascript
(
true
)
mAllowMetaRedirects
(
true
)
mAllowImages
(
true
)
mAllowMedia
(
true
)
mAllowDNSPrefetch
(
true
)
mAllowWindowControl
(
true
)
mUseErrorPages
(
false
)
mObserveErrorPages
(
true
)
mCSSErrorReportingEnabled
(
false
)
mAllowAuth
(
mItemType
=
=
typeContent
)
mAllowKeywordFixup
(
false
)
mIsOffScreenBrowser
(
false
)
mDisableMetaRefreshWhenInactive
(
false
)
mIsAppTab
(
false
)
mUseGlobalHistory
(
false
)
mDeviceSizeIsPageSize
(
false
)
mWindowDraggingAllowed
(
false
)
mInFrameSwap
(
false
)
mCanExecuteScripts
(
false
)
mFiredUnloadEvent
(
false
)
mEODForCurrentDocument
(
false
)
mURIResultedInDocument
(
false
)
mIsBeingDestroyed
(
false
)
mIsExecutingOnLoadHandler
(
false
)
mIsPrintingOrPP
(
false
)
mSavingOldViewer
(
false
)
mDynamicallyCreated
(
false
)
mAffectPrivateSessionLifetime
(
true
)
mInvisible
(
false
)
mHasLoadedNonBlankURI
(
false
)
mBlankTiming
(
false
)
mTitleValidForCurrentURI
(
false
)
mIsFrame
(
false
)
mWillChangeProcess
(
false
)
mWatchedByDevtools
(
false
)
mIsNavigating
(
false
)
{
if
(
aContentWindowID
=
=
0
)
{
mContentWindowID
=
nsContentUtils
:
:
GenerateWindowId
(
)
;
}
if
(
gDocShellCount
+
+
=
=
0
)
{
NS_ASSERTION
(
sURIFixup
=
=
nullptr
"
Huh
sURIFixup
not
null
in
first
nsDocShell
ctor
!
"
)
;
nsCOMPtr
<
nsIURIFixup
>
uriFixup
=
components
:
:
URIFixup
:
:
Service
(
)
;
uriFixup
.
forget
(
&
sURIFixup
)
;
}
MOZ_LOG
(
gDocShellLeakLog
LogLevel
:
:
Debug
(
"
DOCSHELL
%
p
created
\
n
"
this
)
)
;
#
ifdef
DEBUG
+
+
gNumberOfDocShells
;
MOZ_LOG
(
gDocShellAndDOMWindowLeakLogging
LogLevel
:
:
Info
(
"
+
+
DOCSHELL
%
p
=
=
%
ld
[
pid
=
%
d
]
[
id
=
%
s
]
\
n
"
(
void
*
)
this
gNumberOfDocShells
getpid
(
)
nsIDToCString
(
mHistoryID
)
.
get
(
)
)
)
;
#
endif
}
nsDocShell
:
:
~
nsDocShell
(
)
{
MOZ_ASSERT
(
!
mObserved
)
;
mIsBeingDestroyed
=
true
;
Destroy
(
)
;
if
(
mSessionHistory
)
{
mSessionHistory
-
>
LegacySHistory
(
)
-
>
ClearRootBrowsingContext
(
)
;
}
if
(
mContentViewer
)
{
mContentViewer
-
>
Close
(
nullptr
)
;
mContentViewer
-
>
Destroy
(
)
;
mContentViewer
=
nullptr
;
}
if
(
-
-
gDocShellCount
=
=
0
)
{
NS_IF_RELEASE
(
sURIFixup
)
;
}
MOZ_LOG
(
gDocShellLeakLog
LogLevel
:
:
Debug
(
"
DOCSHELL
%
p
destroyed
\
n
"
this
)
)
;
#
ifdef
DEBUG
if
(
MOZ_LOG_TEST
(
gDocShellAndDOMWindowLeakLogging
LogLevel
:
:
Info
)
)
{
nsAutoCString
url
;
if
(
mLastOpenedURI
)
{
url
=
mLastOpenedURI
-
>
GetSpecOrDefault
(
)
;
const
uint32_t
maxURLLength
=
1000
;
if
(
url
.
Length
(
)
>
maxURLLength
)
{
url
.
Truncate
(
maxURLLength
)
;
}
}
-
-
gNumberOfDocShells
;
MOZ_LOG
(
gDocShellAndDOMWindowLeakLogging
LogLevel
:
:
Info
(
"
-
-
DOCSHELL
%
p
=
=
%
ld
[
pid
=
%
d
]
[
id
=
%
s
]
[
url
=
%
s
]
\
n
"
(
void
*
)
this
gNumberOfDocShells
getpid
(
)
nsIDToCString
(
mHistoryID
)
.
get
(
)
url
.
get
(
)
)
)
;
}
#
endif
}
already_AddRefed
<
nsDocShell
>
nsDocShell
:
:
Create
(
BrowsingContext
*
aBrowsingContext
uint64_t
aContentWindowID
)
{
MOZ_ASSERT
(
aBrowsingContext
"
DocShell
without
a
BrowsingContext
!
"
)
;
nsresult
rv
;
RefPtr
<
nsDocShell
>
ds
=
new
nsDocShell
(
aBrowsingContext
aContentWindowID
)
;
rv
=
ds
-
>
nsDocLoader
:
:
Init
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
ds
-
>
mContentListener
=
new
nsDSURIContentListener
(
ds
)
;
if
(
!
ServiceWorkerParentInterceptEnabled
(
)
|
|
XRE_IsParentProcess
(
)
)
{
ds
-
>
mInterceptController
=
new
ServiceWorkerInterceptController
(
)
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
proxy
=
new
InterfaceRequestorProxy
(
ds
)
;
ds
-
>
mLoadGroup
-
>
SetNotificationCallbacks
(
proxy
)
;
rv
=
nsDocLoader
:
:
AddDocLoaderAsChildOfRoot
(
ds
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
rv
=
ds
-
>
AddProgressListener
(
ds
nsIWebProgress
:
:
NOTIFY_STATE_DOCUMENT
|
nsIWebProgress
:
:
NOTIFY_STATE_NETWORK
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
if
(
aBrowsingContext
-
>
UsePrivateBrowsing
(
)
)
{
ds
-
>
NotifyPrivateBrowsingChanged
(
)
;
}
RefPtr
<
BrowsingContext
>
parent
=
aBrowsingContext
-
>
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
GetDocShell
(
)
)
{
parent
-
>
GetDocShell
(
)
-
>
AddChild
(
ds
)
;
}
aBrowsingContext
-
>
SetDocShell
(
ds
)
;
return
ds
.
forget
(
)
;
}
void
nsDocShell
:
:
DestroyChildren
(
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
shell
;
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
shell
=
do_QueryObject
(
iter
.
GetNext
(
)
)
;
NS_ASSERTION
(
shell
"
docshell
has
null
child
"
)
;
if
(
shell
)
{
shell
-
>
SetTreeOwner
(
nullptr
)
;
}
}
nsDocLoader
:
:
DestroyChildren
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_WEAK_PTR_INHERITED
(
nsDocShell
nsDocLoader
mScriptGlobal
mInitialClientSource
mSessionHistory
mBrowsingContext
mChromeEventHandler
)
NS_IMPL_ADDREF_INHERITED
(
nsDocShell
nsDocLoader
)
NS_IMPL_RELEASE_INHERITED
(
nsDocShell
nsDocLoader
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsDocShell
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocShell
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocShellTreeItem
)
NS_INTERFACE_MAP_ENTRY
(
nsIWebNavigation
)
NS_INTERFACE_MAP_ENTRY
(
nsIBaseWindow
)
NS_INTERFACE_MAP_ENTRY
(
nsIRefreshURI
)
NS_INTERFACE_MAP_ENTRY
(
nsIWebProgressListener
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIWebPageDescriptor
)
NS_INTERFACE_MAP_ENTRY
(
nsIAuthPromptProvider
)
NS_INTERFACE_MAP_ENTRY
(
nsILoadContext
)
NS_INTERFACE_MAP_ENTRY_CONDITIONAL
(
nsINetworkInterceptController
mInterceptController
)
NS_INTERFACE_MAP_ENTRY
(
nsIDeprecationWarner
)
NS_INTERFACE_MAP_END_INHERITING
(
nsDocLoader
)
NS_IMETHODIMP
nsDocShell
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
MOZ_ASSERT
(
aSink
"
null
out
param
"
)
;
*
aSink
=
nullptr
;
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsICommandManager
)
)
)
{
NS_ENSURE_SUCCESS
(
EnsureCommandHandler
(
)
NS_ERROR_FAILURE
)
;
*
aSink
=
static_cast
<
nsICommandManager
*
>
(
mCommandManager
.
get
(
)
)
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIURIContentListener
)
)
)
{
*
aSink
=
mContentListener
;
}
else
if
(
(
aIID
.
Equals
(
NS_GET_IID
(
nsIScriptGlobalObject
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsIGlobalObject
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsPIDOMWindowOuter
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
mozIDOMWindowProxy
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsIDOMWindow
)
)
)
&
&
NS_SUCCEEDED
(
EnsureScriptEnvironment
(
)
)
)
{
return
mScriptGlobal
-
>
QueryInterface
(
aIID
aSink
)
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
Document
)
)
&
&
NS_SUCCEEDED
(
EnsureContentViewer
(
)
)
)
{
RefPtr
<
Document
>
doc
=
mContentViewer
-
>
GetDocument
(
)
;
doc
.
forget
(
aSink
)
;
return
*
aSink
?
NS_OK
:
NS_NOINTERFACE
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIApplicationCacheContainer
)
)
)
{
*
aSink
=
nullptr
;
nsCOMPtr
<
nsIContentViewer
>
contentViewer
;
GetContentViewer
(
getter_AddRefs
(
contentViewer
)
)
;
if
(
!
contentViewer
)
{
return
NS_ERROR_NO_INTERFACE
;
}
RefPtr
<
Document
>
doc
=
contentViewer
-
>
GetDocument
(
)
;
NS_ASSERTION
(
doc
"
Should
have
a
document
.
"
)
;
if
(
!
doc
)
{
return
NS_ERROR_NO_INTERFACE
;
}
#
if
defined
(
DEBUG
)
MOZ_LOG
(
gDocShellLog
LogLevel
:
:
Debug
(
"
nsDocShell
[
%
p
]
:
returning
app
cache
container
%
p
"
this
doc
.
get
(
)
)
)
;
#
endif
return
doc
-
>
QueryInterface
(
aIID
aSink
)
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIPrompt
)
)
&
&
NS_SUCCEEDED
(
EnsureScriptEnvironment
(
)
)
)
{
nsresult
rv
;
nsCOMPtr
<
nsIWindowWatcher
>
wwatch
=
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIPrompt
*
prompt
;
rv
=
wwatch
-
>
GetNewPrompter
(
mScriptGlobal
&
prompt
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aSink
=
prompt
;
return
NS_OK
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPrompt
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPrompt2
)
)
)
{
return
NS_SUCCEEDED
(
GetAuthPrompt
(
PROMPT_NORMAL
aIID
aSink
)
)
?
NS_OK
:
NS_NOINTERFACE
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsISHistory
)
)
)
{
RefPtr
<
ChildSHistory
>
shistory
=
GetSessionHistory
(
)
;
if
(
shistory
)
{
nsCOMPtr
<
nsISHistory
>
legacy
=
shistory
-
>
LegacySHistory
(
)
;
legacy
.
forget
(
aSink
)
;
return
NS_OK
;
}
return
NS_NOINTERFACE
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIWebBrowserFind
)
)
)
{
nsresult
rv
=
EnsureFind
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aSink
=
mFind
;
NS_ADDREF
(
(
nsISupports
*
)
*
aSink
)
;
return
NS_OK
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsISelectionDisplay
)
)
)
{
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
return
presShell
-
>
QueryInterface
(
aIID
aSink
)
;
}
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIDocShellTreeOwner
)
)
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
nsresult
rv
=
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
treeOwner
)
{
return
treeOwner
-
>
QueryInterface
(
aIID
aSink
)
;
}
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIBrowserChild
)
)
)
{
*
aSink
=
GetBrowserChild
(
)
.
take
(
)
;
return
*
aSink
?
NS_OK
:
NS_ERROR_FAILURE
;
}
else
{
return
nsDocLoader
:
:
GetInterface
(
aIID
aSink
)
;
}
NS_IF_ADDREF
(
(
(
nsISupports
*
)
*
aSink
)
)
;
return
*
aSink
?
NS_OK
:
NS_NOINTERFACE
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetCancelContentJSEpoch
(
int32_t
aEpoch
)
{
nsCOMPtr
<
nsIBrowserChild
>
browserChild
=
GetBrowserChild
(
)
;
static_cast
<
BrowserChild
*
>
(
browserChild
.
get
(
)
)
-
>
SetCancelContentJSEpoch
(
aEpoch
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
LoadURI
(
nsDocShellLoadState
*
aLoadState
bool
aSetNavigating
)
{
MOZ_ASSERT
(
aLoadState
"
Must
have
a
valid
load
state
!
"
)
;
MOZ_ASSERT
(
(
aLoadState
-
>
LoadFlags
(
)
&
INTERNAL_LOAD_FLAGS_LOADURI_SETUP_FLAGS
)
=
=
0
"
Should
not
have
these
flags
set
"
)
;
if
(
!
aLoadState
-
>
TriggeringPrincipal
(
)
)
{
MOZ_ASSERT
(
false
"
LoadURI
must
have
a
triggering
principal
"
)
;
return
NS_ERROR_FAILURE
;
}
bool
oldIsNavigating
=
mIsNavigating
;
auto
cleanupIsNavigating
=
MakeScopeExit
(
[
&
]
(
)
{
mIsNavigating
=
oldIsNavigating
;
}
)
;
if
(
aSetNavigating
)
{
mIsNavigating
=
true
;
}
PopupBlocker
:
:
PopupControlState
popupState
;
if
(
aLoadState
-
>
LoadFlags
(
)
&
LOAD_FLAGS_ALLOW_POPUPS
)
{
popupState
=
PopupBlocker
:
:
openAllowed
;
}
else
{
popupState
=
PopupBlocker
:
:
openOverridden
;
}
AutoPopupStatePusher
statePusher
(
popupState
)
;
if
(
aLoadState
-
>
GetOriginalURIString
(
)
.
isSome
(
)
)
{
mOriginalUriString
=
*
aLoadState
-
>
GetOriginalURIString
(
)
;
}
if
(
aLoadState
-
>
GetCancelContentJSEpoch
(
)
.
isSome
(
)
)
{
SetCancelContentJSEpoch
(
*
aLoadState
-
>
GetCancelContentJSEpoch
(
)
)
;
}
if
(
!
IsNavigationAllowed
(
true
false
)
)
{
return
NS_OK
;
}
if
(
aLoadState
-
>
LoadFlags
(
)
&
LOAD_FLAGS_FORCE_TRR
)
{
mDefaultLoadFlags
|
=
nsIRequest
:
:
LOAD_TRR_ONLY_MODE
;
}
else
if
(
aLoadState
-
>
LoadFlags
(
)
&
LOAD_FLAGS_DISABLE_TRR
)
{
mDefaultLoadFlags
|
=
nsIRequest
:
:
LOAD_TRR_DISABLED_MODE
;
}
if
(
!
StartupTimeline
:
:
HasRecord
(
StartupTimeline
:
:
FIRST_LOAD_URI
)
&
&
mItemType
=
=
typeContent
&
&
!
NS_IsAboutBlank
(
aLoadState
-
>
URI
(
)
)
)
{
StartupTimeline
:
:
RecordOnce
(
StartupTimeline
:
:
FIRST_LOAD_URI
)
;
}
MOZ_LOG
(
gDocShellLeakLog
LogLevel
:
:
Debug
(
"
nsDocShell
[
%
p
]
:
loading
%
s
with
flags
0x
%
08x
"
this
aLoadState
-
>
URI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
aLoadState
-
>
LoadFlags
(
)
)
)
;
if
(
!
aLoadState
-
>
SHEntry
(
)
&
&
!
LOAD_TYPE_HAS_FLAGS
(
aLoadState
-
>
LoadType
(
)
LOAD_FLAGS_REPLACE_HISTORY
)
)
{
MaybeHandleSubframeHistory
(
aLoadState
)
;
}
if
(
aLoadState
-
>
SHEntry
(
)
)
{
#
ifdef
DEBUG
MOZ_LOG
(
gDocShellLog
LogLevel
:
:
Debug
(
"
nsDocShell
[
%
p
]
:
loading
from
session
history
"
this
)
)
;
#
endif
return
LoadHistoryEntry
(
aLoadState
-
>
SHEntry
(
)
aLoadState
-
>
LoadType
(
)
)
;
}
if
(
(
aLoadState
-
>
LoadType
(
)
=
=
LOAD_NORMAL
|
|
aLoadState
-
>
LoadType
(
)
=
=
LOAD_STOP_CONTENT
)
&
&
ShouldBlockLoadingForBackButton
(
)
)
{
return
NS_OK
;
}
BrowsingContext
:
:
Type
bcType
=
mBrowsingContext
-
>
GetType
(
)
;
nsresult
rv
=
aLoadState
-
>
SetupInheritingPrincipal
(
bcType
mBrowsingContext
-
>
OriginAttributesRef
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aLoadState
-
>
SetupTriggeringPrincipal
(
mBrowsingContext
-
>
OriginAttributesRef
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aLoadState
-
>
CalculateLoadURIFlags
(
)
;
MOZ_ASSERT
(
aLoadState
-
>
TypeHint
(
)
.
IsVoid
(
)
"
Typehint
should
be
null
when
calling
InternalLoad
from
LoadURI
"
)
;
MOZ_ASSERT
(
aLoadState
-
>
FileName
(
)
.
IsVoid
(
)
"
FileName
should
be
null
when
calling
InternalLoad
from
LoadURI
"
)
;
MOZ_ASSERT
(
aLoadState
-
>
SHEntry
(
)
=
=
nullptr
"
SHEntry
should
be
null
when
calling
InternalLoad
from
LoadURI
"
)
;
return
InternalLoad
(
aLoadState
nullptr
nullptr
)
;
}
void
nsDocShell
:
:
MaybeHandleSubframeHistory
(
nsDocShellLoadState
*
aLoadState
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parentAsItem
;
GetInProcessSameTypeParent
(
getter_AddRefs
(
parentAsItem
)
)
;
nsCOMPtr
<
nsIDocShell
>
parentDS
(
do_QueryInterface
(
parentAsItem
)
)
;
if
(
!
parentDS
|
|
parentDS
=
=
static_cast
<
nsIDocShell
*
>
(
this
)
)
{
bool
inOnLoadHandler
=
false
;
GetIsExecutingOnLoadHandler
(
&
inOnLoadHandler
)
;
if
(
inOnLoadHandler
)
{
aLoadState
-
>
SetLoadType
(
LOAD_NORMAL_REPLACE
)
;
}
return
;
}
uint32_t
parentLoadType
;
parentDS
-
>
GetLoadType
(
&
parentLoadType
)
;
nsCOMPtr
<
nsISHEntry
>
currentSH
;
bool
oshe
=
false
;
parentDS
-
>
GetCurrentSHEntry
(
getter_AddRefs
(
currentSH
)
&
oshe
)
;
bool
dynamicallyAddedChild
=
mDynamicallyCreated
;
if
(
!
dynamicallyAddedChild
&
&
!
oshe
&
&
currentSH
)
{
nsCOMPtr
<
nsISHEntry
>
shEntry
;
currentSH
-
>
GetChildSHEntryIfHasNoDynamicallyAddedChild
(
mChildOffset
getter_AddRefs
(
shEntry
)
)
;
if
(
shEntry
)
{
aLoadState
-
>
SetSHEntry
(
shEntry
)
;
}
}
nsCOMPtr
<
nsISHEntry
>
currentChildEntry
;
GetCurrentSHEntry
(
getter_AddRefs
(
currentChildEntry
)
&
oshe
)
;
if
(
mCurrentURI
&
&
(
!
NS_IsAboutBlank
(
mCurrentURI
)
|
|
currentChildEntry
)
)
{
BusyFlags
parentBusy
=
parentDS
-
>
GetBusyFlags
(
)
;
BusyFlags
selfBusy
=
GetBusyFlags
(
)
;
if
(
parentBusy
&
BUSY_FLAGS_BUSY
|
|
selfBusy
&
BUSY_FLAGS_BUSY
)
{
aLoadState
-
>
SetLoadType
(
LOAD_NORMAL_REPLACE
)
;
aLoadState
-
>
SetSHEntry
(
nullptr
)
;
}
return
;
}
if
(
aLoadState
-
>
SHEntry
(
)
&
&
(
parentLoadType
=
=
LOAD_NORMAL
|
|
parentLoadType
=
=
LOAD_LINK
|
|
parentLoadType
=
=
LOAD_NORMAL_EXTERNAL
)
)
{
bool
inOnLoadHandler
=
false
;
parentDS
-
>
GetIsExecutingOnLoadHandler
(
&
inOnLoadHandler
)
;
if
(
inOnLoadHandler
)
{
aLoadState
-
>
SetLoadType
(
LOAD_NORMAL_REPLACE
)
;
aLoadState
-
>
SetSHEntry
(
nullptr
)
;
}
}
else
if
(
parentLoadType
=
=
LOAD_REFRESH
)
{
aLoadState
-
>
SetSHEntry
(
nullptr
)
;
}
else
if
(
(
parentLoadType
=
=
LOAD_BYPASS_HISTORY
)
|
|
(
aLoadState
-
>
SHEntry
(
)
&
&
(
(
parentLoadType
&
LOAD_CMD_HISTORY
)
|
|
(
parentLoadType
=
=
LOAD_RELOAD_NORMAL
)
|
|
(
parentLoadType
=
=
LOAD_RELOAD_CHARSET_CHANGE
)
|
|
(
parentLoadType
=
=
LOAD_RELOAD_CHARSET_CHANGE_BYPASS_CACHE
)
|
|
(
parentLoadType
=
=
LOAD_RELOAD_CHARSET_CHANGE_BYPASS_PROXY_AND_CACHE
)
)
)
)
{
aLoadState
-
>
SetLoadType
(
parentLoadType
)
;
}
else
if
(
parentLoadType
=
=
LOAD_ERROR_PAGE
)
{
aLoadState
-
>
SetLoadType
(
LOAD_BYPASS_HISTORY
)
;
}
else
if
(
(
parentLoadType
=
=
LOAD_RELOAD_BYPASS_CACHE
)
|
|
(
parentLoadType
=
=
LOAD_RELOAD_BYPASS_PROXY
)
|
|
(
parentLoadType
=
=
LOAD_RELOAD_BYPASS_PROXY_AND_CACHE
)
)
{
aLoadState
-
>
SetLoadType
(
parentLoadType
)
;
}
}
NS_IMETHODIMP
nsDocShell
:
:
PrepareForNewContentModel
(
)
{
SetLayoutHistoryState
(
nullptr
)
;
mEODForCurrentDocument
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
FirePageHideNotification
(
bool
aIsUnload
)
{
FirePageHideNotificationInternal
(
aIsUnload
false
)
;
return
NS_OK
;
}
void
nsDocShell
:
:
FirePageHideNotificationInternal
(
bool
aIsUnload
bool
aSkipCheckingDynEntries
)
{
if
(
mContentViewer
&
&
!
mFiredUnloadEvent
)
{
nsCOMPtr
<
nsIContentViewer
>
contentViewer
(
mContentViewer
)
;
mFiredUnloadEvent
=
true
;
if
(
mTiming
)
{
mTiming
-
>
NotifyUnloadEventStart
(
)
;
}
contentViewer
-
>
PageHide
(
aIsUnload
)
;
if
(
mTiming
)
{
mTiming
-
>
NotifyUnloadEventEnd
(
)
;
}
AutoTArray
<
nsCOMPtr
<
nsIDocShell
>
8
>
kids
;
uint32_t
n
=
mChildList
.
Length
(
)
;
kids
.
SetCapacity
(
n
)
;
for
(
uint32_t
i
=
0
;
i
<
n
;
i
+
+
)
{
kids
.
AppendElement
(
do_QueryInterface
(
ChildAt
(
i
)
)
)
;
}
n
=
kids
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
n
;
+
+
i
)
{
RefPtr
<
nsDocShell
>
child
=
static_cast
<
nsDocShell
*
>
(
kids
[
i
]
.
get
(
)
)
;
if
(
child
)
{
child
-
>
FirePageHideNotificationInternal
(
aIsUnload
true
)
;
}
}
if
(
aIsUnload
&
&
!
aSkipCheckingDynEntries
)
{
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
rootSH
&
&
mOSHE
)
{
int32_t
index
=
rootSH
-
>
Index
(
)
;
rootSH
-
>
LegacySHistory
(
)
-
>
RemoveDynEntries
(
index
mOSHE
)
;
}
}
DetachEditorFromWindow
(
)
;
}
}
nsresult
nsDocShell
:
:
DispatchToTabGroup
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetWindow
(
)
;
if
(
!
win
)
{
MOZ_ASSERT
(
mIsBeingDestroyed
)
;
return
NS_ERROR_FAILURE
;
}
if
(
win
-
>
GetDocGroup
(
)
)
{
return
win
-
>
GetDocGroup
(
)
-
>
Dispatch
(
aCategory
runnable
.
forget
(
)
)
;
}
return
SchedulerGroup
:
:
Dispatch
(
aCategory
runnable
.
forget
(
)
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
DispatchLocationChangeEvent
(
)
{
return
DispatchToTabGroup
(
TaskCategory
:
:
Other
NewRunnableMethod
(
"
nsDocShell
:
:
FireDummyOnLocationChange
"
this
&
nsDocShell
:
:
FireDummyOnLocationChange
)
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
StartDelayedAutoplayMediaComponents
(
)
{
RefPtr
<
nsPIDOMWindowOuter
>
outerWindow
=
GetWindow
(
)
;
if
(
outerWindow
)
{
outerWindow
-
>
SetMediaSuspend
(
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
;
}
return
NS_OK
;
}
bool
nsDocShell
:
:
MaybeInitTiming
(
)
{
if
(
mTiming
&
&
!
mBlankTiming
)
{
return
false
;
}
bool
canBeReset
=
false
;
if
(
mScriptGlobal
&
&
mBlankTiming
)
{
nsPIDOMWindowInner
*
innerWin
=
mScriptGlobal
-
>
GetCurrentInnerWindow
(
)
;
if
(
innerWin
&
&
innerWin
-
>
GetPerformance
(
)
)
{
mTiming
=
innerWin
-
>
GetPerformance
(
)
-
>
GetDOMTiming
(
)
;
mBlankTiming
=
false
;
}
}
if
(
!
mTiming
)
{
mTiming
=
new
nsDOMNavigationTiming
(
this
)
;
canBeReset
=
true
;
}
mTiming
-
>
NotifyNavigationStart
(
mBrowsingContext
-
>
GetIsActive
(
)
?
nsDOMNavigationTiming
:
:
DocShellState
:
:
eActive
:
nsDOMNavigationTiming
:
:
DocShellState
:
:
eInactive
)
;
return
canBeReset
;
}
void
nsDocShell
:
:
MaybeResetInitTiming
(
bool
aReset
)
{
if
(
aReset
)
{
mTiming
=
nullptr
;
}
}
nsDOMNavigationTiming
*
nsDocShell
:
:
GetNavigationTiming
(
)
const
{
return
mTiming
;
}
bool
nsDocShell
:
:
ValidateOrigin
(
BrowsingContext
*
aOrigin
BrowsingContext
*
aTarget
)
{
nsIDocShell
*
originDocShell
=
aOrigin
-
>
GetDocShell
(
)
;
MOZ_ASSERT
(
originDocShell
"
originDocShell
must
not
be
null
"
)
;
Document
*
originDocument
=
originDocShell
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
originDocument
false
)
;
nsIDocShell
*
targetDocShell
=
aTarget
-
>
GetDocShell
(
)
;
MOZ_ASSERT
(
targetDocShell
"
targetDocShell
must
not
be
null
"
)
;
Document
*
targetDocument
=
targetDocShell
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
targetDocument
false
)
;
bool
equal
;
nsresult
rv
=
originDocument
-
>
NodePrincipal
(
)
-
>
Equals
(
targetDocument
-
>
NodePrincipal
(
)
&
equal
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
equal
)
{
return
true
;
}
nsCOMPtr
<
nsIURI
>
originURI
;
nsCOMPtr
<
nsIURI
>
targetURI
;
nsCOMPtr
<
nsIURI
>
innerOriginURI
;
nsCOMPtr
<
nsIURI
>
innerTargetURI
;
rv
=
originDocument
-
>
NodePrincipal
(
)
-
>
GetURI
(
getter_AddRefs
(
originURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
originURI
)
{
innerOriginURI
=
NS_GetInnermostURI
(
originURI
)
;
}
rv
=
targetDocument
-
>
NodePrincipal
(
)
-
>
GetURI
(
getter_AddRefs
(
targetURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
targetURI
)
{
innerTargetURI
=
NS_GetInnermostURI
(
targetURI
)
;
}
return
innerOriginURI
&
&
innerTargetURI
&
&
SchemeIsFile
(
innerOriginURI
)
&
&
SchemeIsFile
(
innerTargetURI
)
;
}
nsPresContext
*
nsDocShell
:
:
GetEldestPresContext
(
)
{
nsIContentViewer
*
viewer
=
mContentViewer
;
while
(
viewer
)
{
nsIContentViewer
*
prevViewer
=
viewer
-
>
GetPreviousViewer
(
)
;
if
(
!
prevViewer
)
{
return
viewer
-
>
GetPresContext
(
)
;
}
viewer
=
prevViewer
;
}
return
nullptr
;
}
nsPresContext
*
nsDocShell
:
:
GetPresContext
(
)
{
if
(
!
mContentViewer
)
{
return
nullptr
;
}
return
mContentViewer
-
>
GetPresContext
(
)
;
}
PresShell
*
nsDocShell
:
:
GetPresShell
(
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
return
presContext
?
presContext
-
>
GetPresShell
(
)
:
nullptr
;
}
PresShell
*
nsDocShell
:
:
GetEldestPresShell
(
)
{
nsPresContext
*
presContext
=
GetEldestPresContext
(
)
;
if
(
presContext
)
{
return
presContext
-
>
GetPresShell
(
)
;
}
return
nullptr
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetContentViewer
(
nsIContentViewer
*
*
aContentViewer
)
{
NS_ENSURE_ARG_POINTER
(
aContentViewer
)
;
*
aContentViewer
=
mContentViewer
;
NS_IF_ADDREF
(
*
aContentViewer
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetOuterWindowID
(
uint64_t
*
aWindowID
)
{
*
aWindowID
=
mContentWindowID
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetChromeEventHandler
(
EventTarget
*
aChromeEventHandler
)
{
mChromeEventHandler
=
aChromeEventHandler
;
if
(
mScriptGlobal
)
{
mScriptGlobal
-
>
SetChromeEventHandler
(
mChromeEventHandler
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetChromeEventHandler
(
EventTarget
*
*
aChromeEventHandler
)
{
NS_ENSURE_ARG_POINTER
(
aChromeEventHandler
)
;
RefPtr
<
EventTarget
>
handler
=
mChromeEventHandler
;
handler
.
forget
(
aChromeEventHandler
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetCurrentURI
(
nsIURI
*
aURI
)
{
SetCurrentURI
(
aURI
nullptr
true
0
)
;
return
NS_OK
;
}
bool
nsDocShell
:
:
SetCurrentURI
(
nsIURI
*
aURI
nsIRequest
*
aRequest
bool
aFireOnLocationChange
uint32_t
aLocationFlags
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
MOZ_LOG
(
gDocShellLeakLog
LogLevel
:
:
Debug
(
"
DOCSHELL
%
p
SetCurrentURI
%
s
\
n
"
this
aURI
?
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
)
)
;
if
(
mLoadType
=
=
LOAD_ERROR_PAGE
)
{
return
false
;
}
bool
uriIsEqual
=
false
;
if
(
!
mCurrentURI
|
|
!
aURI
|
|
NS_FAILED
(
mCurrentURI
-
>
Equals
(
aURI
&
uriIsEqual
)
)
|
|
!
uriIsEqual
)
{
mTitleValidForCurrentURI
=
false
;
}
mCurrentURI
=
aURI
;
#
ifdef
DEBUG
mLastOpenedURI
=
aURI
;
#
endif
if
(
!
NS_IsAboutBlank
(
mCurrentURI
)
)
{
mHasLoadedNonBlankURI
=
true
;
}
bool
isRoot
=
mBrowsingContext
-
>
IsTop
(
)
;
bool
isSubFrame
=
false
;
if
(
mLSHE
)
{
isSubFrame
=
mLSHE
-
>
GetIsSubFrame
(
)
;
}
if
(
!
isSubFrame
&
&
!
isRoot
)
{
return
false
;
}
if
(
aFireOnLocationChange
)
{
FireOnLocationChange
(
this
aRequest
aURI
aLocationFlags
)
;
}
return
!
aFireOnLocationChange
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCharset
(
nsACString
&
aCharset
)
{
aCharset
.
Truncate
(
)
;
PresShell
*
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
Document
*
doc
=
presShell
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
doc
-
>
GetDocumentCharacterSet
(
)
-
>
Name
(
aCharset
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GatherCharsetMenuTelemetry
(
)
{
nsCOMPtr
<
nsIContentViewer
>
viewer
;
GetContentViewer
(
getter_AddRefs
(
viewer
)
)
;
if
(
!
viewer
)
{
return
NS_OK
;
}
Document
*
doc
=
viewer
-
>
GetDocument
(
)
;
if
(
!
doc
|
|
doc
-
>
WillIgnoreCharsetOverride
(
)
)
{
return
NS_OK
;
}
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
ENCODING_OVERRIDE_USED
true
)
;
nsIURI
*
url
=
doc
-
>
GetOriginalURI
(
)
;
bool
isFileURL
=
url
&
&
SchemeIsFile
(
url
)
;
int32_t
charsetSource
=
doc
-
>
GetDocumentCharacterSetSource
(
)
;
switch
(
charsetSource
)
{
case
kCharsetFromTopLevelDomain
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION
:
:
RemoteTld
)
;
break
;
case
kCharsetFromFallback
:
case
kCharsetFromDocTypeDefault
:
case
kCharsetFromCache
:
case
kCharsetFromParentFrame
:
if
(
isFileURL
)
{
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION
:
:
Local
)
;
}
else
{
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION
:
:
RemoteNonTld
)
;
}
break
;
case
kCharsetFromInitialAutoDetection
:
case
kCharsetFromFinalAutoDetection
:
if
(
isFileURL
)
{
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION
:
:
LocalChardet
)
;
}
else
{
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION
:
:
RemoteChardet
)
;
}
break
;
case
kCharsetFromMetaPrescan
:
case
kCharsetFromMetaTag
:
case
kCharsetFromChannel
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION
:
:
Labeled
)
;
break
;
case
kCharsetFromParentForced
:
case
kCharsetFromUserForced
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION
:
:
AlreadyOverridden
)
;
break
;
case
kCharsetFromIrreversibleAutoDetection
:
case
kCharsetFromOtherComponent
:
case
kCharsetFromByteOrderMark
:
case
kCharsetUninitialized
:
default
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION
:
:
Bug
)
;
break
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetCharset
(
const
nsACString
&
aCharset
)
{
return
SetForcedCharset
(
aCharset
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetForcedCharset
(
const
nsACString
&
aCharset
)
{
if
(
aCharset
.
IsEmpty
(
)
)
{
mForcedCharset
=
nullptr
;
return
NS_OK
;
}
const
Encoding
*
encoding
=
Encoding
:
:
ForLabel
(
aCharset
)
;
if
(
!
encoding
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
encoding
-
>
IsAsciiCompatible
(
)
&
&
encoding
!
=
ISO_2022_JP_ENCODING
)
{
return
NS_ERROR_INVALID_ARG
;
}
mForcedCharset
=
encoding
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetForcedCharset
(
nsACString
&
aResult
)
{
if
(
mForcedCharset
)
{
mForcedCharset
-
>
Name
(
aResult
)
;
}
else
{
aResult
.
Truncate
(
)
;
}
return
NS_OK
;
}
void
nsDocShell
:
:
SetParentCharset
(
const
Encoding
*
&
aCharset
int32_t
aCharsetSource
nsIPrincipal
*
aPrincipal
)
{
mParentCharset
=
aCharset
;
mParentCharsetSource
=
aCharsetSource
;
mParentCharsetPrincipal
=
aPrincipal
;
}
void
nsDocShell
:
:
GetParentCharset
(
const
Encoding
*
&
aCharset
int32_t
*
aCharsetSource
nsIPrincipal
*
*
aPrincipal
)
{
aCharset
=
mParentCharset
;
*
aCharsetSource
=
mParentCharsetSource
;
NS_IF_ADDREF
(
*
aPrincipal
=
mParentCharsetPrincipal
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetHasMixedActiveContentLoaded
(
bool
*
aHasMixedActiveContentLoaded
)
{
RefPtr
<
Document
>
doc
(
GetDocument
(
)
)
;
*
aHasMixedActiveContentLoaded
=
doc
&
&
doc
-
>
GetHasMixedActiveContentLoaded
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetHasMixedActiveContentBlocked
(
bool
*
aHasMixedActiveContentBlocked
)
{
RefPtr
<
Document
>
doc
(
GetDocument
(
)
)
;
*
aHasMixedActiveContentBlocked
=
doc
&
&
doc
-
>
GetHasMixedActiveContentBlocked
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetHasMixedDisplayContentLoaded
(
bool
*
aHasMixedDisplayContentLoaded
)
{
RefPtr
<
Document
>
doc
(
GetDocument
(
)
)
;
*
aHasMixedDisplayContentLoaded
=
doc
&
&
doc
-
>
GetHasMixedDisplayContentLoaded
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetHasMixedDisplayContentBlocked
(
bool
*
aHasMixedDisplayContentBlocked
)
{
RefPtr
<
Document
>
doc
(
GetDocument
(
)
)
;
*
aHasMixedDisplayContentBlocked
=
doc
&
&
doc
-
>
GetHasMixedDisplayContentBlocked
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetHasTrackingContentBlocked
(
Promise
*
*
aPromise
)
{
MOZ_ASSERT
(
aPromise
)
;
ErrorResult
rv
;
RefPtr
<
Document
>
doc
(
GetDocument
(
)
)
;
RefPtr
<
Promise
>
retPromise
=
Promise
:
:
Create
(
doc
-
>
GetOwnerGlobal
(
)
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
RefPtr
<
Document
:
:
GetContentBlockingEventsPromise
>
promise
=
doc
-
>
GetContentBlockingEvents
(
)
;
if
(
promise
)
{
promise
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
retPromise
]
(
const
Document
:
:
GetContentBlockingEventsPromise
:
:
ResolveOrRejectValue
&
aValue
)
{
if
(
aValue
.
IsResolve
(
)
)
{
bool
has
=
aValue
.
ResolveValue
(
)
&
nsIWebProgressListener
:
:
STATE_BLOCKED_TRACKING_CONTENT
;
retPromise
-
>
MaybeResolve
(
has
)
;
}
else
{
retPromise
-
>
MaybeResolve
(
false
)
;
}
}
)
;
}
else
{
retPromise
-
>
MaybeResolve
(
false
)
;
}
retPromise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowPlugins
(
bool
*
aAllowPlugins
)
{
NS_ENSURE_ARG_POINTER
(
aAllowPlugins
)
;
*
aAllowPlugins
=
mBrowsingContext
-
>
GetAllowPlugins
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowPlugins
(
bool
aAllowPlugins
)
{
mBrowsingContext
-
>
SetAllowPlugins
(
aAllowPlugins
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowJavascript
(
bool
*
aAllowJavascript
)
{
NS_ENSURE_ARG_POINTER
(
aAllowJavascript
)
;
*
aAllowJavascript
=
mAllowJavascript
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCssErrorReportingEnabled
(
bool
*
aEnabled
)
{
MOZ_ASSERT
(
aEnabled
)
;
*
aEnabled
=
mCSSErrorReportingEnabled
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetCssErrorReportingEnabled
(
bool
aEnabled
)
{
mCSSErrorReportingEnabled
=
aEnabled
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowJavascript
(
bool
aAllowJavascript
)
{
mAllowJavascript
=
aAllowJavascript
;
RecomputeCanExecuteScripts
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetUsePrivateBrowsing
(
bool
*
aUsePrivateBrowsing
)
{
NS_ENSURE_ARG_POINTER
(
aUsePrivateBrowsing
)
;
return
mBrowsingContext
-
>
GetUsePrivateBrowsing
(
aUsePrivateBrowsing
)
;
}
void
nsDocShell
:
:
NotifyPrivateBrowsingChanged
(
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
if
(
mAffectPrivateSessionLifetime
)
{
if
(
UsePrivateBrowsing
(
)
)
{
IncreasePrivateDocShellCount
(
)
;
}
else
{
DecreasePrivateDocShellCount
(
)
;
}
}
nsTObserverArray
<
nsWeakPtr
>
:
:
ForwardIterator
iter
(
mPrivacyObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
nsWeakPtr
ref
=
iter
.
GetNext
(
)
;
nsCOMPtr
<
nsIPrivacyTransitionObserver
>
obs
=
do_QueryReferent
(
ref
)
;
if
(
!
obs
)
{
mPrivacyObservers
.
RemoveElement
(
ref
)
;
}
else
{
obs
-
>
PrivateModeChanged
(
UsePrivateBrowsing
(
)
)
;
}
}
}
NS_IMETHODIMP
nsDocShell
:
:
SetUsePrivateBrowsing
(
bool
aUsePrivateBrowsing
)
{
return
mBrowsingContext
-
>
SetUsePrivateBrowsing
(
aUsePrivateBrowsing
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetPrivateBrowsing
(
bool
aUsePrivateBrowsing
)
{
return
mBrowsingContext
-
>
SetPrivateBrowsing
(
aUsePrivateBrowsing
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetHasLoadedNonBlankURI
(
bool
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
mHasLoadedNonBlankURI
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetUseRemoteTabs
(
bool
*
aUseRemoteTabs
)
{
NS_ENSURE_ARG_POINTER
(
aUseRemoteTabs
)
;
return
mBrowsingContext
-
>
GetUseRemoteTabs
(
aUseRemoteTabs
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetRemoteTabs
(
bool
aUseRemoteTabs
)
{
return
mBrowsingContext
-
>
SetRemoteTabs
(
aUseRemoteTabs
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetUseRemoteSubframes
(
bool
*
aUseRemoteSubframes
)
{
NS_ENSURE_ARG_POINTER
(
aUseRemoteSubframes
)
;
return
mBrowsingContext
-
>
GetUseRemoteSubframes
(
aUseRemoteSubframes
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetRemoteSubframes
(
bool
aUseRemoteSubframes
)
{
return
mBrowsingContext
-
>
SetRemoteSubframes
(
aUseRemoteSubframes
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAffectPrivateSessionLifetime
(
bool
aAffectLifetime
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
bool
change
=
aAffectLifetime
!
=
mAffectPrivateSessionLifetime
;
if
(
change
&
&
UsePrivateBrowsing
(
)
)
{
if
(
aAffectLifetime
)
{
IncreasePrivateDocShellCount
(
)
;
}
else
{
DecreasePrivateDocShellCount
(
)
;
}
}
mAffectPrivateSessionLifetime
=
aAffectLifetime
;
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryObject
(
iter
.
GetNext
(
)
)
;
if
(
shell
)
{
shell
-
>
SetAffectPrivateSessionLifetime
(
aAffectLifetime
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAffectPrivateSessionLifetime
(
bool
*
aAffectLifetime
)
{
*
aAffectLifetime
=
mAffectPrivateSessionLifetime
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
AddWeakPrivacyTransitionObserver
(
nsIPrivacyTransitionObserver
*
aObserver
)
{
nsWeakPtr
weakObs
=
do_GetWeakReference
(
aObserver
)
;
if
(
!
weakObs
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mPrivacyObservers
.
AppendElement
(
weakObs
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
AddWeakReflowObserver
(
nsIReflowObserver
*
aObserver
)
{
nsWeakPtr
weakObs
=
do_GetWeakReference
(
aObserver
)
;
if
(
!
weakObs
)
{
return
NS_ERROR_FAILURE
;
}
mReflowObservers
.
AppendElement
(
weakObs
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
RemoveWeakReflowObserver
(
nsIReflowObserver
*
aObserver
)
{
nsWeakPtr
obs
=
do_GetWeakReference
(
aObserver
)
;
return
mReflowObservers
.
RemoveElement
(
obs
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsDocShell
:
:
NotifyReflowObservers
(
bool
aInterruptible
DOMHighResTimeStamp
aStart
DOMHighResTimeStamp
aEnd
)
{
nsTObserverArray
<
nsWeakPtr
>
:
:
ForwardIterator
iter
(
mReflowObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
nsWeakPtr
ref
=
iter
.
GetNext
(
)
;
nsCOMPtr
<
nsIReflowObserver
>
obs
=
do_QueryReferent
(
ref
)
;
if
(
!
obs
)
{
mReflowObservers
.
RemoveElement
(
ref
)
;
}
else
if
(
aInterruptible
)
{
obs
-
>
ReflowInterruptible
(
aStart
aEnd
)
;
}
else
{
obs
-
>
Reflow
(
aStart
aEnd
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowMetaRedirects
(
bool
*
aReturn
)
{
NS_ENSURE_ARG_POINTER
(
aReturn
)
;
*
aReturn
=
mAllowMetaRedirects
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowMetaRedirects
(
bool
aValue
)
{
mAllowMetaRedirects
=
aValue
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowSubframes
(
bool
*
aAllowSubframes
)
{
NS_ENSURE_ARG_POINTER
(
aAllowSubframes
)
;
*
aAllowSubframes
=
mAllowSubframes
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowSubframes
(
bool
aAllowSubframes
)
{
mAllowSubframes
=
aAllowSubframes
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowImages
(
bool
*
aAllowImages
)
{
NS_ENSURE_ARG_POINTER
(
aAllowImages
)
;
*
aAllowImages
=
mAllowImages
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowImages
(
bool
aAllowImages
)
{
mAllowImages
=
aAllowImages
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowMedia
(
bool
*
aAllowMedia
)
{
*
aAllowMedia
=
mAllowMedia
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowMedia
(
bool
aAllowMedia
)
{
mAllowMedia
=
aAllowMedia
;
if
(
mScriptGlobal
)
{
if
(
nsPIDOMWindowInner
*
innerWin
=
mScriptGlobal
-
>
GetCurrentInnerWindow
(
)
)
{
if
(
aAllowMedia
)
{
innerWin
-
>
UnmuteAudioContexts
(
)
;
}
else
{
innerWin
-
>
MuteAudioContexts
(
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowDNSPrefetch
(
bool
*
aAllowDNSPrefetch
)
{
*
aAllowDNSPrefetch
=
mAllowDNSPrefetch
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowDNSPrefetch
(
bool
aAllowDNSPrefetch
)
{
mAllowDNSPrefetch
=
aAllowDNSPrefetch
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowWindowControl
(
bool
*
aAllowWindowControl
)
{
*
aAllowWindowControl
=
mAllowWindowControl
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowWindowControl
(
bool
aAllowWindowControl
)
{
mAllowWindowControl
=
aAllowWindowControl
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowContentRetargeting
(
bool
*
aAllowContentRetargeting
)
{
*
aAllowContentRetargeting
=
mBrowsingContext
-
>
GetAllowContentRetargeting
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowContentRetargeting
(
bool
aAllowContentRetargeting
)
{
mBrowsingContext
-
>
SetAllowContentRetargeting
(
aAllowContentRetargeting
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowContentRetargetingOnChildren
(
bool
*
aAllowContentRetargetingOnChildren
)
{
*
aAllowContentRetargetingOnChildren
=
mBrowsingContext
-
>
GetAllowContentRetargetingOnChildren
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowContentRetargetingOnChildren
(
bool
aAllowContentRetargetingOnChildren
)
{
mBrowsingContext
-
>
SetAllowContentRetargetingOnChildren
(
aAllowContentRetargetingOnChildren
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetFullscreenAllowed
(
bool
*
aFullscreenAllowed
)
{
NS_ENSURE_ARG_POINTER
(
aFullscreenAllowed
)
;
if
(
mFullscreenAllowed
!
=
CHECK_ATTRIBUTES
)
{
*
aFullscreenAllowed
=
(
mFullscreenAllowed
=
=
PARENT_ALLOWS
)
;
return
NS_OK
;
}
*
aFullscreenAllowed
=
false
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetWindow
(
)
;
if
(
!
win
)
{
return
NS_OK
;
}
if
(
nsCOMPtr
<
Element
>
frameElement
=
win
-
>
GetFrameElementInternal
(
)
)
{
if
(
frameElement
-
>
IsXULElement
(
)
)
{
if
(
frameElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disablefullscreen
)
)
{
return
NS_OK
;
}
}
else
{
if
(
frameElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
iframe
)
)
{
if
(
!
frameElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
allowfullscreen
)
&
&
!
frameElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozallowfullscreen
)
)
{
return
NS_OK
;
}
}
else
if
(
frameElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
embed
)
)
{
nsCOMPtr
<
nsIObjectLoadingContent
>
objectLoadingContent
=
do_QueryInterface
(
frameElement
)
;
if
(
!
objectLoadingContent
)
{
return
NS_OK
;
}
nsObjectLoadingContent
*
olc
=
static_cast
<
nsObjectLoadingContent
*
>
(
objectLoadingContent
.
get
(
)
)
;
if
(
!
olc
-
>
IsRewrittenYoutubeEmbed
(
)
)
{
return
NS_OK
;
}
if
(
!
frameElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
allowfullscreen
)
)
{
return
NS_OK
;
}
}
else
{
return
NS_OK
;
}
}
}
RefPtr
<
nsDocShell
>
parent
=
GetInProcessParentDocshell
(
)
;
if
(
!
parent
)
{
*
aFullscreenAllowed
=
true
;
return
NS_OK
;
}
return
parent
-
>
GetFullscreenAllowed
(
aFullscreenAllowed
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetFullscreenAllowed
(
bool
aFullscreenAllowed
)
{
if
(
!
nsIDocShell
:
:
GetIsMozBrowser
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mFullscreenAllowed
=
(
aFullscreenAllowed
?
PARENT_ALLOWS
:
PARENT_PROHIBITS
)
;
return
NS_OK
;
}
hal
:
:
ScreenOrientation
nsDocShell
:
:
OrientationLock
(
)
{
return
mOrientationLock
;
}
void
nsDocShell
:
:
SetOrientationLock
(
hal
:
:
ScreenOrientation
aOrientationLock
)
{
mOrientationLock
=
aOrientationLock
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetMayEnableCharacterEncodingMenu
(
bool
*
aMayEnableCharacterEncodingMenu
)
{
*
aMayEnableCharacterEncodingMenu
=
false
;
if
(
!
mContentViewer
)
{
return
NS_OK
;
}
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
NS_OK
;
}
if
(
doc
-
>
WillIgnoreCharsetOverride
(
)
)
{
return
NS_OK
;
}
*
aMayEnableCharacterEncodingMenu
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCharsetAutodetected
(
bool
*
aCharsetAutodetected
)
{
*
aCharsetAutodetected
=
false
;
if
(
!
mContentViewer
)
{
return
NS_OK
;
}
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
NS_OK
;
}
int32_t
source
=
doc
-
>
GetDocumentCharacterSetSource
(
)
;
if
(
source
=
=
kCharsetFromInitialAutoDetection
|
|
source
=
=
kCharsetFromFinalAutoDetection
|
|
source
=
=
kCharsetFromUserForcedAutoDetection
)
{
*
aCharsetAutodetected
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllDocShellsInSubtree
(
int32_t
aItemType
DocShellEnumeratorDirection
aDirection
nsTArray
<
RefPtr
<
nsIDocShell
>
>
&
aResult
)
{
aResult
.
Clear
(
)
;
nsDocShellEnumerator
docShellEnum
(
(
aDirection
=
=
ENUMERATE_FORWARDS
)
?
nsDocShellEnumerator
:
:
EnumerationDirection
:
:
Forwards
:
nsDocShellEnumerator
:
:
EnumerationDirection
:
:
Backwards
aItemType
*
this
)
;
nsresult
rv
=
docShellEnum
.
BuildDocShellArray
(
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAppType
(
AppType
*
aAppType
)
{
*
aAppType
=
mAppType
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAppType
(
AppType
aAppType
)
{
mAppType
=
aAppType
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowAuth
(
bool
*
aAllowAuth
)
{
*
aAllowAuth
=
mAllowAuth
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowAuth
(
bool
aAllowAuth
)
{
mAllowAuth
=
aAllowAuth
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetZoom
(
float
*
aZoom
)
{
NS_ENSURE_ARG_POINTER
(
aZoom
)
;
*
aZoom
=
1
.
0f
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetZoom
(
float
aZoom
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetBusyFlags
(
BusyFlags
*
aBusyFlags
)
{
NS_ENSURE_ARG_POINTER
(
aBusyFlags
)
;
*
aBusyFlags
=
mBusyFlags
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
TabToTreeOwner
(
bool
aForward
bool
aForDocumentNavigation
bool
*
aTookFocus
)
{
NS_ENSURE_ARG_POINTER
(
aTookFocus
)
;
nsCOMPtr
<
nsIWebBrowserChromeFocus
>
chromeFocus
=
do_GetInterface
(
mTreeOwner
)
;
if
(
chromeFocus
)
{
if
(
aForward
)
{
*
aTookFocus
=
NS_SUCCEEDED
(
chromeFocus
-
>
FocusNextElement
(
aForDocumentNavigation
)
)
;
}
else
{
*
aTookFocus
=
NS_SUCCEEDED
(
chromeFocus
-
>
FocusPrevElement
(
aForDocumentNavigation
)
)
;
}
}
else
{
*
aTookFocus
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetSecurityUI
(
nsISecureBrowserUI
*
*
aSecurityUI
)
{
NS_IF_ADDREF
(
*
aSecurityUI
=
mSecurityUI
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetSecurityUI
(
nsISecureBrowserUI
*
aSecurityUI
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
mSecurityUI
=
aSecurityUI
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetLoadURIDelegate
(
nsILoadURIDelegate
*
*
aLoadURIDelegate
)
{
nsCOMPtr
<
nsILoadURIDelegate
>
delegate
=
GetLoadURIDelegate
(
)
;
delegate
.
forget
(
aLoadURIDelegate
)
;
return
NS_OK
;
}
already_AddRefed
<
nsILoadURIDelegate
>
nsDocShell
:
:
GetLoadURIDelegate
(
)
{
if
(
nsCOMPtr
<
nsILoadURIDelegate
>
result
=
do_QueryActor
(
u
"
LoadURIDelegate
"
GetWindow
(
)
)
)
{
return
result
.
forget
(
)
;
}
return
nullptr
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetUseErrorPages
(
bool
*
aUseErrorPages
)
{
*
aUseErrorPages
=
UseErrorPages
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetUseErrorPages
(
bool
aUseErrorPages
)
{
if
(
mObserveErrorPages
)
{
mObserveErrorPages
=
false
;
}
mUseErrorPages
=
aUseErrorPages
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetPreviousEntryIndex
(
int32_t
*
aPreviousEntryIndex
)
{
*
aPreviousEntryIndex
=
mPreviousEntryIndex
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetLoadedEntryIndex
(
int32_t
*
aLoadedEntryIndex
)
{
*
aLoadedEntryIndex
=
mLoadedEntryIndex
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
HistoryPurged
(
int32_t
aNumEntries
)
{
mPreviousEntryIndex
=
std
:
:
max
(
-
1
mPreviousEntryIndex
-
aNumEntries
)
;
mLoadedEntryIndex
=
std
:
:
max
(
0
mLoadedEntryIndex
-
aNumEntries
)
;
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryObject
(
iter
.
GetNext
(
)
)
;
if
(
shell
)
{
shell
-
>
HistoryPurged
(
aNumEntries
)
;
}
}
return
NS_OK
;
}
void
nsDocShell
:
:
TriggerParentCheckDocShellIsEmpty
(
)
{
if
(
RefPtr
<
nsDocShell
>
parent
=
GetInProcessParentDocshell
(
)
)
{
parent
-
>
DocLoaderIsEmpty
(
true
)
;
}
if
(
GetBrowsingContext
(
)
-
>
IsContentSubframe
(
)
&
&
!
GetBrowsingContext
(
)
-
>
GetParent
(
)
-
>
IsInProcess
(
)
)
{
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
this
)
)
{
mozilla
:
:
Unused
<
<
browserChild
-
>
SendMaybeFireEmbedderLoadEvents
(
false
)
;
}
}
}
nsresult
nsDocShell
:
:
HistoryEntryRemoved
(
int32_t
aIndex
)
{
if
(
aIndex
=
=
mPreviousEntryIndex
)
{
mPreviousEntryIndex
=
-
1
;
}
else
if
(
aIndex
<
mPreviousEntryIndex
)
{
-
-
mPreviousEntryIndex
;
}
if
(
mLoadedEntryIndex
=
=
aIndex
)
{
mLoadedEntryIndex
=
0
;
}
else
if
(
aIndex
<
mLoadedEntryIndex
)
{
-
-
mLoadedEntryIndex
;
}
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryObject
(
iter
.
GetNext
(
)
)
;
if
(
shell
)
{
static_cast
<
nsDocShell
*
>
(
shell
.
get
(
)
)
-
>
HistoryEntryRemoved
(
aIndex
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetRecordProfileTimelineMarkers
(
bool
aValue
)
{
bool
currentValue
=
nsIDocShell
:
:
GetRecordProfileTimelineMarkers
(
)
;
if
(
currentValue
=
=
aValue
)
{
return
NS_OK
;
}
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
if
(
!
timelines
)
{
return
NS_OK
;
}
if
(
aValue
)
{
MOZ_ASSERT
(
!
timelines
-
>
HasConsumer
(
this
)
)
;
timelines
-
>
AddConsumer
(
this
)
;
MOZ_ASSERT
(
timelines
-
>
HasConsumer
(
this
)
)
;
UseEntryScriptProfiling
(
)
;
}
else
{
MOZ_ASSERT
(
timelines
-
>
HasConsumer
(
this
)
)
;
timelines
-
>
RemoveConsumer
(
this
)
;
MOZ_ASSERT
(
!
timelines
-
>
HasConsumer
(
this
)
)
;
UnuseEntryScriptProfiling
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetRecordProfileTimelineMarkers
(
bool
*
aValue
)
{
*
aValue
=
!
!
mObserved
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
PopProfileTimelineMarkers
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aOut
)
{
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
if
(
!
timelines
)
{
return
NS_OK
;
}
nsTArray
<
dom
:
:
ProfileTimelineMarker
>
store
;
SequenceRooter
<
dom
:
:
ProfileTimelineMarker
>
rooter
(
aCx
&
store
)
;
timelines
-
>
PopMarkers
(
this
aCx
store
)
;
if
(
!
ToJSValue
(
aCx
store
aOut
)
)
{
JS_ClearPendingException
(
aCx
)
;
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
Now
(
DOMHighResTimeStamp
*
aWhen
)
{
*
aWhen
=
(
TimeStamp
:
:
Now
(
)
-
TimeStamp
:
:
ProcessCreation
(
)
)
.
ToMilliseconds
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetWindowDraggingAllowed
(
bool
aValue
)
{
RefPtr
<
nsDocShell
>
parent
=
GetInProcessParentDocshell
(
)
;
if
(
!
aValue
&
&
mItemType
=
=
typeChrome
&
&
!
parent
)
{
return
NS_ERROR_FAILURE
;
}
mWindowDraggingAllowed
=
aValue
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetWindowDraggingAllowed
(
bool
*
aValue
)
{
RefPtr
<
nsDocShell
>
parent
=
GetInProcessParentDocshell
(
)
;
if
(
mItemType
=
=
typeChrome
&
&
!
parent
)
{
*
aValue
=
true
;
}
else
{
*
aValue
=
mWindowDraggingAllowed
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCurrentDocumentChannel
(
nsIChannel
*
*
aResult
)
{
NS_IF_ADDREF
(
*
aResult
=
GetCurrentDocChannel
(
)
)
;
return
NS_OK
;
}
nsIChannel
*
nsDocShell
:
:
GetCurrentDocChannel
(
)
{
if
(
mContentViewer
)
{
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
return
doc
-
>
GetChannel
(
)
;
}
}
return
nullptr
;
}
NS_IMETHODIMP
nsDocShell
:
:
AddWeakScrollObserver
(
nsIScrollObserver
*
aObserver
)
{
nsWeakPtr
weakObs
=
do_GetWeakReference
(
aObserver
)
;
if
(
!
weakObs
)
{
return
NS_ERROR_FAILURE
;
}
mScrollObservers
.
AppendElement
(
weakObs
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
RemoveWeakScrollObserver
(
nsIScrollObserver
*
aObserver
)
{
nsWeakPtr
obs
=
do_GetWeakReference
(
aObserver
)
;
return
mScrollObservers
.
RemoveElement
(
obs
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
void
nsDocShell
:
:
NotifyAsyncPanZoomStarted
(
)
{
nsTObserverArray
<
nsWeakPtr
>
:
:
ForwardIterator
iter
(
mScrollObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
nsWeakPtr
ref
=
iter
.
GetNext
(
)
;
nsCOMPtr
<
nsIScrollObserver
>
obs
=
do_QueryReferent
(
ref
)
;
if
(
obs
)
{
obs
-
>
AsyncPanZoomStarted
(
)
;
}
else
{
mScrollObservers
.
RemoveElement
(
ref
)
;
}
}
}
void
nsDocShell
:
:
NotifyAsyncPanZoomStopped
(
)
{
nsTObserverArray
<
nsWeakPtr
>
:
:
ForwardIterator
iter
(
mScrollObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
nsWeakPtr
ref
=
iter
.
GetNext
(
)
;
nsCOMPtr
<
nsIScrollObserver
>
obs
=
do_QueryReferent
(
ref
)
;
if
(
obs
)
{
obs
-
>
AsyncPanZoomStopped
(
)
;
}
else
{
mScrollObservers
.
RemoveElement
(
ref
)
;
}
}
}
NS_IMETHODIMP
nsDocShell
:
:
NotifyScrollObservers
(
)
{
nsTObserverArray
<
nsWeakPtr
>
:
:
ForwardIterator
iter
(
mScrollObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
nsWeakPtr
ref
=
iter
.
GetNext
(
)
;
nsCOMPtr
<
nsIScrollObserver
>
obs
=
do_QueryReferent
(
ref
)
;
if
(
obs
)
{
obs
-
>
ScrollPositionChanged
(
)
;
}
else
{
mScrollObservers
.
RemoveElement
(
ref
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetName
(
nsAString
&
aName
)
{
aName
=
mBrowsingContext
-
>
Name
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetName
(
const
nsAString
&
aName
)
{
mBrowsingContext
-
>
SetName
(
aName
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
NameEquals
(
const
nsAString
&
aName
bool
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
mBrowsingContext
-
>
NameEquals
(
aName
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
ClearCachedUserAgent
(
)
{
RefPtr
<
nsGlobalWindowInner
>
win
=
mScriptGlobal
?
mScriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
:
nullptr
;
if
(
win
)
{
Navigator
*
navigator
=
win
-
>
Navigator
(
)
;
if
(
navigator
)
{
navigator
-
>
ClearUserAgentCache
(
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetTouchEventsOverride
(
TouchEventsOverride
*
aTouchEventsOverride
)
{
*
aTouchEventsOverride
=
mTouchEventsOverride
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetTouchEventsOverride
(
TouchEventsOverride
aTouchEventsOverride
)
{
if
(
!
(
aTouchEventsOverride
=
=
TOUCHEVENTS_OVERRIDE_NONE
|
|
aTouchEventsOverride
=
=
TOUCHEVENTS_OVERRIDE_ENABLED
|
|
aTouchEventsOverride
=
=
TOUCHEVENTS_OVERRIDE_DISABLED
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mTouchEventsOverride
=
aTouchEventsOverride
;
uint32_t
childCount
=
mChildList
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShell
>
childShell
=
do_QueryInterface
(
ChildAt
(
i
)
)
;
if
(
childShell
)
{
childShell
-
>
SetTouchEventsOverride
(
aTouchEventsOverride
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetMetaViewportOverride
(
MetaViewportOverride
*
aMetaViewportOverride
)
{
NS_ENSURE_ARG_POINTER
(
aMetaViewportOverride
)
;
*
aMetaViewportOverride
=
mMetaViewportOverride
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetMetaViewportOverride
(
MetaViewportOverride
aMetaViewportOverride
)
{
if
(
!
(
aMetaViewportOverride
=
=
META_VIEWPORT_OVERRIDE_NONE
|
|
aMetaViewportOverride
=
=
META_VIEWPORT_OVERRIDE_ENABLED
|
|
aMetaViewportOverride
=
=
META_VIEWPORT_OVERRIDE_DISABLED
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mMetaViewportOverride
=
aMetaViewportOverride
;
if
(
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
UpdateViewportOverridden
(
true
)
;
}
return
NS_OK
;
}
int32_t
nsDocShell
:
:
ItemType
(
)
{
return
mItemType
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetItemType
(
int32_t
*
aItemType
)
{
NS_ENSURE_ARG_POINTER
(
aItemType
)
;
MOZ_DIAGNOSTIC_ASSERT
(
(
mBrowsingContext
-
>
IsContent
(
)
?
typeContent
:
typeChrome
)
=
=
mItemType
)
;
*
aItemType
=
mItemType
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetInProcessParent
(
nsIDocShellTreeItem
*
*
aParent
)
{
if
(
!
mParent
)
{
*
aParent
=
nullptr
;
}
else
{
CallQueryInterface
(
mParent
aParent
)
;
}
return
NS_OK
;
}
already_AddRefed
<
nsDocShell
>
nsDocShell
:
:
GetInProcessParentDocshell
(
)
{
nsCOMPtr
<
nsIDocShell
>
docshell
=
do_QueryInterface
(
GetAsSupports
(
mParent
)
)
;
return
docshell
.
forget
(
)
.
downcast
<
nsDocShell
>
(
)
;
}
void
nsDocShell
:
:
MaybeCreateInitialClientSource
(
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
if
(
mScriptGlobal
&
&
mScriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
&
&
mScriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
-
>
GetExtantDoc
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mScriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
-
>
GetClientInfo
(
)
.
isSome
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mInitialClientSource
)
;
return
;
}
if
(
mInitialClientSource
)
{
return
;
}
if
(
!
aPrincipal
&
&
mBrowsingContext
-
>
GetSandboxFlags
(
)
)
{
return
;
}
nsIPrincipal
*
principal
=
aPrincipal
?
aPrincipal
:
GetInheritedPrincipal
(
false
)
;
if
(
!
principal
)
{
return
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetWindow
(
)
;
if
(
!
win
)
{
return
;
}
mInitialClientSource
=
ClientManager
:
:
CreateSource
(
ClientType
:
:
Window
win
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
principal
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInitialClientSource
)
;
mInitialClientSource
-
>
DocShellExecutionReady
(
this
)
;
nsCOMPtr
<
nsIDocShell
>
parent
=
GetInProcessParentDocshell
(
)
;
nsPIDOMWindowOuter
*
parentOuter
=
parent
?
parent
-
>
GetWindow
(
)
:
nullptr
;
nsPIDOMWindowInner
*
parentInner
=
parentOuter
?
parentOuter
-
>
GetCurrentInnerWindow
(
)
:
nullptr
;
if
(
!
parentInner
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
uri
)
NS_LITERAL_CSTRING
(
"
about
:
blank
"
)
)
)
;
Maybe
<
ServiceWorkerDescriptor
>
controller
(
parentInner
-
>
GetController
(
)
)
;
if
(
controller
.
isNothing
(
)
|
|
!
ServiceWorkerAllowedToControlWindow
(
principal
uri
)
)
{
return
;
}
mInitialClientSource
-
>
InheritController
(
controller
.
ref
(
)
)
;
}
Maybe
<
ClientInfo
>
nsDocShell
:
:
GetInitialClientInfo
(
)
const
{
if
(
mInitialClientSource
)
{
Maybe
<
ClientInfo
>
result
;
result
.
emplace
(
mInitialClientSource
-
>
Info
(
)
)
;
return
result
;
}
nsGlobalWindowInner
*
innerWindow
=
mScriptGlobal
?
mScriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
:
nullptr
;
Document
*
doc
=
innerWindow
?
innerWindow
-
>
GetExtantDoc
(
)
:
nullptr
;
if
(
!
doc
|
|
!
doc
-
>
IsInitialDocument
(
)
)
{
return
Maybe
<
ClientInfo
>
(
)
;
}
return
innerWindow
-
>
GetClientInfo
(
)
;
}
void
nsDocShell
:
:
RecomputeCanExecuteScripts
(
)
{
bool
old
=
mCanExecuteScripts
;
RefPtr
<
nsDocShell
>
parent
=
GetInProcessParentDocshell
(
)
;
if
(
!
mTreeOwner
)
{
mCanExecuteScripts
=
mCanExecuteScripts
&
&
mAllowJavascript
;
}
else
if
(
!
mAllowJavascript
)
{
mCanExecuteScripts
=
false
;
}
else
if
(
parent
)
{
mCanExecuteScripts
=
parent
-
>
mCanExecuteScripts
;
}
else
{
mCanExecuteScripts
=
true
;
}
if
(
mScriptGlobal
&
&
mScriptGlobal
-
>
GetGlobalJSObject
(
)
)
{
xpc
:
:
Scriptability
&
scriptability
=
xpc
:
:
Scriptability
:
:
Get
(
mScriptGlobal
-
>
GetGlobalJSObject
(
)
)
;
scriptability
.
SetDocShellAllowsScript
(
mCanExecuteScripts
)
;
}
if
(
old
!
=
mCanExecuteScripts
)
{
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
static_cast
<
nsDocShell
*
>
(
iter
.
GetNext
(
)
)
-
>
RecomputeCanExecuteScripts
(
)
;
}
}
}
nsresult
nsDocShell
:
:
SetDocLoaderParent
(
nsDocLoader
*
aParent
)
{
bool
wasFrame
=
IsFrame
(
)
;
nsresult
rv
=
nsDocLoader
:
:
SetDocLoaderParent
(
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsISupportsPriority
>
priorityGroup
=
do_QueryInterface
(
mLoadGroup
)
;
if
(
wasFrame
!
=
IsFrame
(
)
&
&
priorityGroup
)
{
priorityGroup
-
>
AdjustPriority
(
wasFrame
?
-
1
:
1
)
;
}
nsISupports
*
parent
=
GetAsSupports
(
aParent
)
;
bool
value
;
nsCOMPtr
<
nsIDocShell
>
parentAsDocShell
(
do_QueryInterface
(
parent
)
)
;
if
(
parentAsDocShell
)
{
if
(
mAllowJavascript
&
&
NS_SUCCEEDED
(
parentAsDocShell
-
>
GetAllowJavascript
(
&
value
)
)
)
{
SetAllowJavascript
(
value
)
;
}
if
(
mAllowMetaRedirects
&
&
NS_SUCCEEDED
(
parentAsDocShell
-
>
GetAllowMetaRedirects
(
&
value
)
)
)
{
SetAllowMetaRedirects
(
value
)
;
}
if
(
mAllowSubframes
&
&
NS_SUCCEEDED
(
parentAsDocShell
-
>
GetAllowSubframes
(
&
value
)
)
)
{
SetAllowSubframes
(
value
)
;
}
if
(
mAllowImages
&
&
NS_SUCCEEDED
(
parentAsDocShell
-
>
GetAllowImages
(
&
value
)
)
)
{
SetAllowImages
(
value
)
;
}
SetAllowMedia
(
parentAsDocShell
-
>
GetAllowMedia
(
)
&
&
mAllowMedia
)
;
if
(
mAllowWindowControl
&
&
NS_SUCCEEDED
(
parentAsDocShell
-
>
GetAllowWindowControl
(
&
value
)
)
)
{
SetAllowWindowControl
(
value
)
;
}
if
(
NS_SUCCEEDED
(
parentAsDocShell
-
>
GetIsActive
(
&
value
)
)
)
{
SetIsActive
(
value
)
;
}
if
(
NS_FAILED
(
parentAsDocShell
-
>
GetAllowDNSPrefetch
(
&
value
)
)
)
{
value
=
false
;
}
SetAllowDNSPrefetch
(
mAllowDNSPrefetch
&
&
value
)
;
SetAffectPrivateSessionLifetime
(
parentAsDocShell
-
>
GetAffectPrivateSessionLifetime
(
)
)
;
uint32_t
flags
;
if
(
NS_SUCCEEDED
(
parentAsDocShell
-
>
GetDefaultLoadFlags
(
&
flags
)
)
)
{
SetDefaultLoadFlags
(
flags
)
;
}
SetTouchEventsOverride
(
parentAsDocShell
-
>
GetTouchEventsOverride
(
)
)
;
}
nsCOMPtr
<
nsIURIContentListener
>
parentURIListener
(
do_GetInterface
(
parent
)
)
;
if
(
parentURIListener
)
{
mContentListener
-
>
SetParentContentListener
(
parentURIListener
)
;
}
RecomputeCanExecuteScripts
(
)
;
if
(
!
aParent
)
{
MaybeClearStorageAccessFlag
(
)
;
}
return
NS_OK
;
}
void
nsDocShell
:
:
MaybeClearStorageAccessFlag
(
)
{
if
(
mScriptGlobal
)
{
mScriptGlobal
-
>
ParentWindowChanged
(
)
;
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
child
=
do_QueryObject
(
iter
.
GetNext
(
)
)
;
if
(
child
)
{
static_cast
<
nsDocShell
*
>
(
child
.
get
(
)
)
-
>
MaybeClearStorageAccessFlag
(
)
;
}
}
}
}
NS_IMETHODIMP
nsDocShell
:
:
GetInProcessSameTypeParent
(
nsIDocShellTreeItem
*
*
aParent
)
{
NS_ENSURE_ARG_POINTER
(
aParent
)
;
*
aParent
=
nullptr
;
if
(
nsIDocShell
:
:
GetIsMozBrowser
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
=
do_QueryInterface
(
GetAsSupports
(
mParent
)
)
;
if
(
!
parent
)
{
return
NS_OK
;
}
if
(
parent
-
>
ItemType
(
)
=
=
mItemType
)
{
parent
.
swap
(
*
aParent
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetSameTypeParentIgnoreBrowserBoundaries
(
nsIDocShell
*
*
aParent
)
{
NS_ENSURE_ARG_POINTER
(
aParent
)
;
*
aParent
=
nullptr
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
=
do_QueryInterface
(
GetAsSupports
(
mParent
)
)
;
if
(
!
parent
)
{
return
NS_OK
;
}
if
(
parent
-
>
ItemType
(
)
=
=
mItemType
)
{
nsCOMPtr
<
nsIDocShell
>
parentDS
=
do_QueryInterface
(
parent
)
;
parentDS
.
forget
(
aParent
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetInProcessRootTreeItem
(
nsIDocShellTreeItem
*
*
aRootTreeItem
)
{
NS_ENSURE_ARG_POINTER
(
aRootTreeItem
)
;
RefPtr
<
nsDocShell
>
root
=
this
;
RefPtr
<
nsDocShell
>
parent
=
root
-
>
GetInProcessParentDocshell
(
)
;
while
(
parent
)
{
root
=
parent
;
parent
=
root
-
>
GetInProcessParentDocshell
(
)
;
}
root
.
forget
(
aRootTreeItem
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetInProcessSameTypeRootTreeItem
(
nsIDocShellTreeItem
*
*
aRootTreeItem
)
{
NS_ENSURE_ARG_POINTER
(
aRootTreeItem
)
;
*
aRootTreeItem
=
static_cast
<
nsIDocShellTreeItem
*
>
(
this
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
NS_ENSURE_SUCCESS
(
GetInProcessSameTypeParent
(
getter_AddRefs
(
parent
)
)
NS_ERROR_FAILURE
)
;
while
(
parent
)
{
*
aRootTreeItem
=
parent
;
NS_ENSURE_SUCCESS
(
(
*
aRootTreeItem
)
-
>
GetInProcessSameTypeParent
(
getter_AddRefs
(
parent
)
)
NS_ERROR_FAILURE
)
;
}
NS_ADDREF
(
*
aRootTreeItem
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetSameTypeRootTreeItemIgnoreBrowserBoundaries
(
nsIDocShell
*
*
aRootTreeItem
)
{
NS_ENSURE_ARG_POINTER
(
aRootTreeItem
)
;
*
aRootTreeItem
=
static_cast
<
nsIDocShell
*
>
(
this
)
;
nsCOMPtr
<
nsIDocShell
>
parent
;
NS_ENSURE_SUCCESS
(
GetSameTypeParentIgnoreBrowserBoundaries
(
getter_AddRefs
(
parent
)
)
NS_ERROR_FAILURE
)
;
while
(
parent
)
{
*
aRootTreeItem
=
parent
;
NS_ENSURE_SUCCESS
(
(
*
aRootTreeItem
)
-
>
GetSameTypeParentIgnoreBrowserBoundaries
(
getter_AddRefs
(
parent
)
)
NS_ERROR_FAILURE
)
;
}
NS_ADDREF
(
*
aRootTreeItem
)
;
return
NS_OK
;
}
bool
nsDocShell
:
:
IsSandboxedFrom
(
BrowsingContext
*
aTargetBC
)
{
if
(
!
aTargetBC
)
{
return
false
;
}
if
(
aTargetBC
=
=
mBrowsingContext
)
{
return
false
;
}
uint32_t
sandboxFlags
=
mBrowsingContext
-
>
GetSandboxFlags
(
)
;
if
(
mContentViewer
)
{
RefPtr
<
Document
>
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
sandboxFlags
=
doc
-
>
GetSandboxFlags
(
)
;
}
}
if
(
!
sandboxFlags
)
{
return
false
;
}
RefPtr
<
BrowsingContext
>
ancestorOfTarget
(
aTargetBC
-
>
GetParent
(
)
)
;
if
(
ancestorOfTarget
)
{
do
{
if
(
ancestorOfTarget
=
=
mBrowsingContext
)
{
return
false
;
}
ancestorOfTarget
=
ancestorOfTarget
-
>
GetParent
(
)
;
}
while
(
ancestorOfTarget
)
;
return
true
;
}
RefPtr
<
BrowsingContext
>
permittedNavigator
(
aTargetBC
-
>
GetOnePermittedSandboxedNavigator
(
)
)
;
if
(
permittedNavigator
=
=
mBrowsingContext
)
{
return
false
;
}
if
(
!
(
sandboxFlags
&
SANDBOXED_TOPLEVEL_NAVIGATION
)
&
&
aTargetBC
=
=
mBrowsingContext
-
>
Top
(
)
)
{
return
false
;
}
return
true
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetTreeOwner
(
nsIDocShellTreeOwner
*
*
aTreeOwner
)
{
NS_ENSURE_ARG_POINTER
(
aTreeOwner
)
;
*
aTreeOwner
=
mTreeOwner
;
NS_IF_ADDREF
(
*
aTreeOwner
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetTreeOwner
(
nsIDocShellTreeOwner
*
aTreeOwner
)
{
if
(
mIsBeingDestroyed
&
&
aTreeOwner
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
IsFrame
(
)
)
{
nsCOMPtr
<
nsIWebProgress
>
webProgress
=
do_QueryInterface
(
GetAsSupports
(
this
)
)
;
if
(
webProgress
)
{
nsCOMPtr
<
nsIWebProgressListener
>
oldListener
=
do_QueryInterface
(
mTreeOwner
)
;
nsCOMPtr
<
nsIWebProgressListener
>
newListener
=
do_QueryInterface
(
aTreeOwner
)
;
if
(
oldListener
)
{
webProgress
-
>
RemoveProgressListener
(
oldListener
)
;
}
if
(
newListener
)
{
webProgress
-
>
AddProgressListener
(
newListener
nsIWebProgress
:
:
NOTIFY_ALL
)
;
}
}
}
mTreeOwner
=
aTreeOwner
;
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
child
=
do_QueryObject
(
iter
.
GetNext
(
)
)
;
NS_ENSURE_TRUE
(
child
NS_ERROR_FAILURE
)
;
if
(
child
-
>
ItemType
(
)
=
=
mItemType
)
{
child
-
>
SetTreeOwner
(
aTreeOwner
)
;
}
}
if
(
mTreeOwner
&
&
XRE_IsContentProcess
(
)
)
{
nsCOMPtr
<
nsIBrowserChild
>
newBrowserChild
=
do_GetInterface
(
mTreeOwner
)
;
MOZ_ASSERT
(
newBrowserChild
"
No
BrowserChild
actor
for
tree
owner
in
Content
!
"
)
;
if
(
mBrowserChild
)
{
nsCOMPtr
<
nsIBrowserChild
>
oldBrowserChild
=
do_QueryReferent
(
mBrowserChild
)
;
MOZ_RELEASE_ASSERT
(
oldBrowserChild
=
=
newBrowserChild
"
Cannot
cahnge
BrowserChild
during
nsDocShell
lifetime
!
"
)
;
}
else
{
mBrowserChild
=
do_GetWeakReference
(
newBrowserChild
)
;
}
}
RecomputeCanExecuteScripts
(
)
;
return
NS_OK
;
}
void
nsDocShell
:
:
SetChildOffset
(
int32_t
aChildOffset
)
{
mChildOffset
=
aChildOffset
;
}
int32_t
nsDocShell
:
:
GetChildOffset
(
)
{
return
mChildOffset
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetHistoryID
(
nsID
*
*
aID
)
{
*
aID
=
mHistoryID
.
Clone
(
)
;
return
NS_OK
;
}
const
nsID
nsDocShell
:
:
HistoryID
(
)
{
return
mHistoryID
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsInUnload
(
bool
*
aIsInUnload
)
{
*
aIsInUnload
=
mFiredUnloadEvent
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetInProcessChildCount
(
int32_t
*
aChildCount
)
{
NS_ENSURE_ARG_POINTER
(
aChildCount
)
;
*
aChildCount
=
mChildList
.
Length
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
AddChild
(
nsIDocShellTreeItem
*
aChild
)
{
NS_ENSURE_ARG_POINTER
(
aChild
)
;
RefPtr
<
nsDocLoader
>
childAsDocLoader
=
GetAsDocLoader
(
aChild
)
;
NS_ENSURE_TRUE
(
childAsDocLoader
NS_ERROR_UNEXPECTED
)
;
nsDocLoader
*
ancestor
=
this
;
do
{
if
(
childAsDocLoader
=
=
ancestor
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
ancestor
=
ancestor
-
>
GetParent
(
)
;
}
while
(
ancestor
)
;
nsDocLoader
*
childsParent
=
childAsDocLoader
-
>
GetParent
(
)
;
if
(
childsParent
)
{
nsresult
rv
=
childsParent
-
>
RemoveChildLoader
(
childAsDocLoader
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
aChild
-
>
SetTreeOwner
(
nullptr
)
;
nsresult
res
=
AddChildLoader
(
childAsDocLoader
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
NS_ASSERTION
(
!
mChildList
.
IsEmpty
(
)
"
child
list
must
not
be
empty
after
a
successful
add
"
)
;
nsCOMPtr
<
nsIDocShell
>
childDocShell
=
do_QueryInterface
(
aChild
)
;
bool
dynamic
=
false
;
childDocShell
-
>
GetCreatedDynamically
(
&
dynamic
)
;
if
(
!
dynamic
)
{
nsCOMPtr
<
nsISHEntry
>
currentSH
;
bool
oshe
=
false
;
GetCurrentSHEntry
(
getter_AddRefs
(
currentSH
)
&
oshe
)
;
if
(
currentSH
)
{
currentSH
-
>
HasDynamicallyAddedChild
(
&
dynamic
)
;
}
}
childDocShell
-
>
SetChildOffset
(
dynamic
?
-
1
:
mChildList
.
Length
(
)
-
1
)
;
if
(
mUseGlobalHistory
)
{
childDocShell
-
>
SetUseGlobalHistory
(
true
)
;
}
if
(
aChild
-
>
ItemType
(
)
!
=
mItemType
)
{
return
NS_OK
;
}
aChild
-
>
SetTreeOwner
(
mTreeOwner
)
;
nsCOMPtr
<
nsIDocShell
>
childAsDocShell
(
do_QueryInterface
(
aChild
)
)
;
if
(
!
childAsDocShell
)
{
return
NS_OK
;
}
if
(
mItemType
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
return
NS_OK
;
}
if
(
!
mContentViewer
)
{
return
NS_OK
;
}
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
NS_OK
;
}
const
Encoding
*
parentCS
=
doc
-
>
GetDocumentCharacterSet
(
)
;
int32_t
charsetSource
=
doc
-
>
GetDocumentCharacterSetSource
(
)
;
childAsDocShell
-
>
SetParentCharset
(
parentCS
charsetSource
doc
-
>
NodePrincipal
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
RemoveChild
(
nsIDocShellTreeItem
*
aChild
)
{
NS_ENSURE_ARG_POINTER
(
aChild
)
;
RefPtr
<
nsDocLoader
>
childAsDocLoader
=
GetAsDocLoader
(
aChild
)
;
NS_ENSURE_TRUE
(
childAsDocLoader
NS_ERROR_UNEXPECTED
)
;
nsresult
rv
=
RemoveChildLoader
(
childAsDocLoader
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aChild
-
>
SetTreeOwner
(
nullptr
)
;
return
nsDocLoader
:
:
AddDocLoaderAsChildOfRoot
(
childAsDocLoader
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetInProcessChildAt
(
int32_t
aIndex
nsIDocShellTreeItem
*
*
aChild
)
{
NS_ENSURE_ARG_POINTER
(
aChild
)
;
RefPtr
<
nsDocShell
>
child
=
GetInProcessChildAt
(
aIndex
)
;
NS_ENSURE_TRUE
(
child
NS_ERROR_UNEXPECTED
)
;
child
.
forget
(
aChild
)
;
return
NS_OK
;
}
nsDocShell
*
nsDocShell
:
:
GetInProcessChildAt
(
int32_t
aIndex
)
{
#
ifdef
DEBUG
if
(
aIndex
<
0
)
{
NS_WARNING
(
"
Negative
index
passed
to
GetChildAt
"
)
;
}
else
if
(
static_cast
<
uint32_t
>
(
aIndex
)
>
=
mChildList
.
Length
(
)
)
{
NS_WARNING
(
"
Too
large
an
index
passed
to
GetChildAt
"
)
;
}
#
endif
nsIDocumentLoader
*
child
=
ChildAt
(
aIndex
)
;
return
static_cast
<
nsDocShell
*
>
(
child
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
AddChildSHEntry
(
nsISHEntry
*
aCloneRef
nsISHEntry
*
aNewEntry
int32_t
aChildOffset
uint32_t
aLoadType
bool
aCloneChildren
)
{
nsresult
rv
=
NS_OK
;
if
(
mLSHE
&
&
aLoadType
!
=
LOAD_PUSHSTATE
)
{
if
(
NS_FAILED
(
mLSHE
-
>
ReplaceChild
(
aNewEntry
)
)
)
{
rv
=
mLSHE
-
>
AddChild
(
aNewEntry
aChildOffset
)
;
}
}
else
if
(
!
aCloneRef
)
{
if
(
mOSHE
)
{
rv
=
mOSHE
-
>
AddChild
(
aNewEntry
aChildOffset
UseRemoteSubframes
(
)
)
;
}
}
else
{
rv
=
AddChildSHEntryInternal
(
aCloneRef
aNewEntry
aChildOffset
aLoadType
aCloneChildren
)
;
}
return
rv
;
}
nsresult
nsDocShell
:
:
AddChildSHEntryInternal
(
nsISHEntry
*
aCloneRef
nsISHEntry
*
aNewEntry
int32_t
aChildOffset
uint32_t
aLoadType
bool
aCloneChildren
)
{
nsresult
rv
=
NS_OK
;
if
(
mSessionHistory
)
{
rv
=
mSessionHistory
-
>
LegacySHistory
(
)
-
>
AddChildSHEntryHelper
(
aCloneRef
aNewEntry
mBrowsingContext
aCloneChildren
)
;
}
else
{
nsCOMPtr
<
nsIDocShell
>
parent
=
do_QueryInterface
(
GetAsSupports
(
mParent
)
&
rv
)
;
if
(
parent
)
{
rv
=
static_cast
<
nsDocShell
*
>
(
parent
.
get
(
)
)
-
>
AddChildSHEntryInternal
(
aCloneRef
aNewEntry
aChildOffset
aLoadType
aCloneChildren
)
;
}
}
return
rv
;
}
nsresult
nsDocShell
:
:
AddChildSHEntryToParent
(
nsISHEntry
*
aNewEntry
int32_t
aChildOffset
bool
aCloneChildren
)
{
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
rootSH
)
{
mPreviousEntryIndex
=
rootSH
-
>
Index
(
)
;
}
nsresult
rv
;
nsCOMPtr
<
nsIDocShell
>
parent
=
do_QueryInterface
(
GetAsSupports
(
mParent
)
&
rv
)
;
if
(
parent
)
{
rv
=
parent
-
>
AddChildSHEntry
(
mOSHE
aNewEntry
aChildOffset
mLoadType
aCloneChildren
)
;
}
if
(
rootSH
)
{
mLoadedEntryIndex
=
rootSH
-
>
Index
(
)
;
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
gPageCacheLog
LogLevel
:
:
Verbose
)
)
)
{
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Verbose
(
"
Previous
index
:
%
d
Loaded
index
:
%
d
"
mPreviousEntryIndex
mLoadedEntryIndex
)
)
;
}
}
return
rv
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetUseGlobalHistory
(
bool
aUseGlobalHistory
)
{
mUseGlobalHistory
=
aUseGlobalHistory
;
if
(
!
aUseGlobalHistory
)
{
return
NS_OK
;
}
nsCOMPtr
<
IHistory
>
history
=
services
:
:
GetHistoryService
(
)
;
return
history
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetUseGlobalHistory
(
bool
*
aUseGlobalHistory
)
{
*
aUseGlobalHistory
=
mUseGlobalHistory
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
RemoveFromSessionHistory
(
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
GetInProcessSameTypeRootTreeItem
(
getter_AddRefs
(
root
)
)
;
nsCOMPtr
<
nsIWebNavigation
>
rootAsWebnav
=
do_QueryInterface
(
root
)
;
if
(
!
rootAsWebnav
)
{
return
NS_OK
;
}
RefPtr
<
ChildSHistory
>
sessionHistory
=
rootAsWebnav
-
>
GetSessionHistory
(
)
;
if
(
!
sessionHistory
)
{
return
NS_OK
;
}
int32_t
index
=
sessionHistory
-
>
Index
(
)
;
AutoTArray
<
nsID
16
>
ids
(
{
mHistoryID
}
)
;
sessionHistory
-
>
LegacySHistory
(
)
-
>
RemoveEntries
(
ids
index
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetCreatedDynamically
(
bool
aDynamic
)
{
mDynamicallyCreated
=
aDynamic
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCreatedDynamically
(
bool
*
aDynamic
)
{
*
aDynamic
=
mDynamicallyCreated
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCurrentSHEntry
(
nsISHEntry
*
*
aEntry
bool
*
aOSHE
)
{
*
aOSHE
=
false
;
*
aEntry
=
nullptr
;
if
(
mLSHE
)
{
NS_ADDREF
(
*
aEntry
=
mLSHE
)
;
}
else
if
(
mOSHE
)
{
NS_ADDREF
(
*
aEntry
=
mOSHE
)
;
*
aOSHE
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SynchronizeLayoutHistoryState
(
)
{
if
(
mOSHE
)
{
mOSHE
-
>
SynchronizeLayoutHistoryState
(
)
;
}
return
NS_OK
;
}
nsIScriptGlobalObject
*
nsDocShell
:
:
GetScriptGlobalObject
(
)
{
NS_ENSURE_SUCCESS
(
EnsureScriptEnvironment
(
)
nullptr
)
;
return
mScriptGlobal
;
}
Document
*
nsDocShell
:
:
GetDocument
(
)
{
NS_ENSURE_SUCCESS
(
EnsureContentViewer
(
)
nullptr
)
;
return
mContentViewer
-
>
GetDocument
(
)
;
}
nsPIDOMWindowOuter
*
nsDocShell
:
:
GetWindow
(
)
{
if
(
NS_FAILED
(
EnsureScriptEnvironment
(
)
)
)
{
return
nullptr
;
}
return
mScriptGlobal
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetDomWindow
(
mozIDOMWindowProxy
*
*
aWindow
)
{
NS_ENSURE_ARG_POINTER
(
aWindow
)
;
nsresult
rv
=
EnsureScriptEnvironment
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
nsGlobalWindowOuter
>
window
=
mScriptGlobal
;
window
.
forget
(
aWindow
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetMessageManager
(
ContentFrameMessageManager
*
*
aMessageManager
)
{
RefPtr
<
ContentFrameMessageManager
>
mm
;
if
(
RefPtr
<
BrowserChild
>
browserChild
=
BrowserChild
:
:
GetFrom
(
this
)
)
{
mm
=
browserChild
-
>
GetMessageManager
(
)
;
}
else
if
(
nsPIDOMWindowOuter
*
win
=
GetWindow
(
)
)
{
mm
=
win
-
>
GetMessageManager
(
)
;
}
mm
.
forget
(
aMessageManager
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsNavigating
(
bool
*
aOut
)
{
*
aOut
=
mIsNavigating
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetDeviceSizeIsPageSize
(
bool
aValue
)
{
if
(
mDeviceSizeIsPageSize
!
=
aValue
)
{
mDeviceSizeIsPageSize
=
aValue
;
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
presContext
-
>
MediaFeatureValuesChanged
(
{
MediaFeatureChangeReason
:
:
DeviceSizeIsPageSizeChange
}
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetDeviceSizeIsPageSize
(
bool
*
aValue
)
{
*
aValue
=
mDeviceSizeIsPageSize
;
return
NS_OK
;
}
void
nsDocShell
:
:
ClearFrameHistory
(
nsISHEntry
*
aEntry
)
{
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
!
rootSH
|
|
!
aEntry
)
{
return
;
}
rootSH
-
>
LegacySHistory
(
)
-
>
RemoveFrameEntries
(
aEntry
)
;
}
bool
nsDocShell
:
:
IsPrintingOrPP
(
bool
aDisplayErrorDialog
)
{
if
(
mIsPrintingOrPP
&
&
aDisplayErrorDialog
)
{
DisplayLoadError
(
NS_ERROR_DOCUMENT_IS_PRINTMODE
nullptr
nullptr
nullptr
)
;
}
return
mIsPrintingOrPP
;
}
bool
nsDocShell
:
:
IsNavigationAllowed
(
bool
aDisplayPrintErrorDialog
bool
aCheckIfUnloadFired
)
{
bool
isAllowed
=
!
IsPrintingOrPP
(
aDisplayPrintErrorDialog
)
&
&
(
!
aCheckIfUnloadFired
|
|
!
mFiredUnloadEvent
)
;
if
(
!
isAllowed
)
{
return
false
;
}
if
(
!
mContentViewer
)
{
return
true
;
}
bool
firingBeforeUnload
;
mContentViewer
-
>
GetBeforeUnloadFiring
(
&
firingBeforeUnload
)
;
return
!
firingBeforeUnload
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCanGoBack
(
bool
*
aCanGoBack
)
{
*
aCanGoBack
=
false
;
if
(
!
IsNavigationAllowed
(
false
)
)
{
return
NS_OK
;
}
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
rootSH
)
{
*
aCanGoBack
=
rootSH
-
>
CanGo
(
-
1
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCanGoForward
(
bool
*
aCanGoForward
)
{
*
aCanGoForward
=
false
;
if
(
!
IsNavigationAllowed
(
false
)
)
{
return
NS_OK
;
}
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
rootSH
)
{
*
aCanGoForward
=
rootSH
-
>
CanGo
(
1
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsDocShell
:
:
GoBack
(
)
{
if
(
!
IsNavigationAllowed
(
)
)
{
return
NS_OK
;
}
auto
cleanupIsNavigating
=
MakeScopeExit
(
[
&
]
(
)
{
mIsNavigating
=
false
;
}
)
;
mIsNavigating
=
true
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
NS_ENSURE_TRUE
(
rootSH
NS_ERROR_FAILURE
)
;
ErrorResult
rv
;
rootSH
-
>
Go
(
-
1
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GoForward
(
)
{
if
(
!
IsNavigationAllowed
(
)
)
{
return
NS_OK
;
}
auto
cleanupIsNavigating
=
MakeScopeExit
(
[
&
]
(
)
{
mIsNavigating
=
false
;
}
)
;
mIsNavigating
=
true
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
NS_ENSURE_TRUE
(
rootSH
NS_ERROR_FAILURE
)
;
ErrorResult
rv
;
rootSH
-
>
Go
(
1
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GotoIndex
(
int32_t
aIndex
)
{
if
(
!
IsNavigationAllowed
(
)
)
{
return
NS_OK
;
}
auto
cleanupIsNavigating
=
MakeScopeExit
(
[
&
]
(
)
{
mIsNavigating
=
false
;
}
)
;
mIsNavigating
=
true
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
NS_ENSURE_TRUE
(
rootSH
NS_ERROR_FAILURE
)
;
return
rootSH
-
>
LegacySHistory
(
)
-
>
GotoIndex
(
aIndex
)
;
}
nsresult
nsDocShell
:
:
LoadURI
(
const
nsAString
&
aURI
const
LoadURIOptions
&
aLoadURIOptions
)
{
if
(
!
IsNavigationAllowed
(
)
)
{
return
NS_OK
;
}
RefPtr
<
nsDocShellLoadState
>
loadState
;
nsresult
rv
=
nsDocShellLoadState
:
:
CreateFromLoadURIOptions
(
GetAsSupports
(
this
)
sURIFixup
aURI
aLoadURIOptions
getter_AddRefs
(
loadState
)
)
;
uint32_t
loadFlags
=
aLoadURIOptions
.
mLoadFlags
;
if
(
NS_ERROR_MALFORMED_URI
=
=
rv
)
{
if
(
DisplayLoadError
(
rv
nullptr
PromiseFlatString
(
aURI
)
.
get
(
)
nullptr
)
&
&
(
loadFlags
&
LOAD_FLAGS_ERROR_LOAD_CHANGES_RV
)
!
=
0
)
{
return
NS_ERROR_LOAD_SHOWED_ERRORPAGE
;
}
}
if
(
NS_FAILED
(
rv
)
|
|
!
loadState
)
{
return
NS_ERROR_FAILURE
;
}
return
LoadURI
(
loadState
true
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
LoadURIFromScript
(
const
nsAString
&
aURI
JS
:
:
Handle
<
JS
:
:
Value
>
aLoadURIOptions
JSContext
*
aCx
)
{
LoadURIOptions
loadURIOptions
;
if
(
!
loadURIOptions
.
Init
(
aCx
aLoadURIOptions
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
LoadURI
(
aURI
loadURIOptions
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
DisplayLoadError
(
nsresult
aError
nsIURI
*
aURI
const
char16_t
*
aURL
nsIChannel
*
aFailedChannel
bool
*
aDisplayedErrorPage
)
{
MOZ_LOG
(
gDocShellLeakLog
LogLevel
:
:
Debug
(
"
DOCSHELL
%
p
DisplayLoadError
%
s
\
n
"
this
aURI
?
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
)
)
;
if
(
GetBrowsingContext
(
)
-
>
IsContentSubframe
(
)
&
&
!
GetBrowsingContext
(
)
-
>
GetParent
(
)
-
>
IsInProcess
(
)
)
{
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
this
)
)
{
mozilla
:
:
Unused
<
<
browserChild
-
>
SendMaybeFireEmbedderLoadEvents
(
false
)
;
}
}
*
aDisplayedErrorPage
=
false
;
nsCOMPtr
<
nsIPrompt
>
prompter
;
nsCOMPtr
<
nsIStringBundle
>
stringBundle
;
GetPromptAndStringBundle
(
getter_AddRefs
(
prompter
)
getter_AddRefs
(
stringBundle
)
)
;
NS_ENSURE_TRUE
(
stringBundle
NS_ERROR_FAILURE
)
;
NS_ENSURE_TRUE
(
prompter
NS_ERROR_FAILURE
)
;
const
char
*
error
=
nullptr
;
const
char
*
errorDescriptionID
=
nullptr
;
AutoTArray
<
nsString
3
>
formatStrs
;
bool
addHostPort
=
false
;
nsresult
rv
=
NS_OK
;
nsAutoString
messageStr
;
nsAutoCString
cssClass
;
nsAutoCString
errorPage
;
errorPage
.
AssignLiteral
(
"
neterror
"
)
;
if
(
NS_ERROR_UNKNOWN_PROTOCOL
=
=
aError
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsAutoCString
scheme
;
aURI
-
>
GetScheme
(
scheme
)
;
CopyASCIItoUTF16
(
scheme
*
formatStrs
.
AppendElement
(
)
)
;
nsCOMPtr
<
nsINestedURI
>
nestedURI
=
do_QueryInterface
(
aURI
)
;
while
(
nestedURI
)
{
nsCOMPtr
<
nsIURI
>
tempURI
;
nsresult
rv2
;
rv2
=
nestedURI
-
>
GetInnerURI
(
getter_AddRefs
(
tempURI
)
)
;
if
(
NS_SUCCEEDED
(
rv2
)
&
&
tempURI
)
{
tempURI
-
>
GetScheme
(
scheme
)
;
formatStrs
[
0
]
.
AppendLiteral
(
"
"
)
;
AppendASCIItoUTF16
(
scheme
formatStrs
[
0
]
)
;
}
nestedURI
=
do_QueryInterface
(
tempURI
)
;
}
error
=
"
unknownProtocolFound
"
;
}
else
if
(
NS_ERROR_FILE_NOT_FOUND
=
=
aError
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
error
=
"
fileNotFound
"
;
}
else
if
(
NS_ERROR_FILE_ACCESS_DENIED
=
=
aError
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
error
=
"
fileAccessDenied
"
;
}
else
if
(
NS_ERROR_UNKNOWN_HOST
=
=
aError
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsAutoCString
host
;
nsCOMPtr
<
nsIURI
>
innermostURI
=
NS_GetInnermostURI
(
aURI
)
;
innermostURI
-
>
GetHost
(
host
)
;
CopyUTF8toUTF16
(
host
*
formatStrs
.
AppendElement
(
)
)
;
errorDescriptionID
=
"
dnsNotFound2
"
;
error
=
"
dnsNotFound
"
;
}
else
if
(
NS_ERROR_CONNECTION_REFUSED
=
=
aError
|
|
NS_ERROR_PROXY_BAD_GATEWAY
=
=
aError
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
addHostPort
=
true
;
error
=
"
connectionFailure
"
;
}
else
if
(
NS_ERROR_NET_INTERRUPT
=
=
aError
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
addHostPort
=
true
;
error
=
"
netInterrupt
"
;
}
else
if
(
NS_ERROR_NET_TIMEOUT
=
=
aError
|
|
NS_ERROR_PROXY_GATEWAY_TIMEOUT
=
=
aError
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsAutoCString
host
;
aURI
-
>
GetHost
(
host
)
;
CopyUTF8toUTF16
(
host
*
formatStrs
.
AppendElement
(
)
)
;
error
=
"
netTimeout
"
;
}
else
if
(
NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION
=
=
aError
|
|
NS_ERROR_CSP_FORM_ACTION_VIOLATION
=
=
aError
|
|
NS_ERROR_CSP_NAVIGATE_TO_VIOLATION
=
=
aError
)
{
cssClass
.
AssignLiteral
(
"
neterror
"
)
;
error
=
"
cspBlocked
"
;
}
else
if
(
NS_ERROR_XFO_VIOLATION
=
=
aError
)
{
cssClass
.
AssignLiteral
(
"
neterror
"
)
;
error
=
"
xfoBlocked
"
;
}
else
if
(
NS_ERROR_GET_MODULE
(
aError
)
=
=
NS_ERROR_MODULE_SECURITY
)
{
nsCOMPtr
<
nsINSSErrorsService
>
nsserr
=
do_GetService
(
NS_NSS_ERRORS_SERVICE_CONTRACTID
)
;
uint32_t
errorClass
;
if
(
!
nsserr
|
|
NS_FAILED
(
nsserr
-
>
GetErrorClass
(
aError
&
errorClass
)
)
)
{
errorClass
=
nsINSSErrorsService
:
:
ERROR_CLASS_SSL_PROTOCOL
;
}
nsCOMPtr
<
nsISupports
>
securityInfo
;
nsCOMPtr
<
nsITransportSecurityInfo
>
tsi
;
if
(
aFailedChannel
)
{
aFailedChannel
-
>
GetSecurityInfo
(
getter_AddRefs
(
securityInfo
)
)
;
}
tsi
=
do_QueryInterface
(
securityInfo
)
;
if
(
tsi
)
{
uint32_t
securityState
;
tsi
-
>
GetSecurityState
(
&
securityState
)
;
if
(
securityState
&
nsIWebProgressListener
:
:
STATE_USES_SSL_3
)
{
error
=
"
sslv3Used
"
;
addHostPort
=
true
;
}
else
if
(
securityState
&
nsIWebProgressListener
:
:
STATE_USES_WEAK_CRYPTO
)
{
error
=
"
weakCryptoUsed
"
;
addHostPort
=
true
;
}
}
else
{
if
(
nsserr
)
{
nsserr
-
>
GetErrorMessage
(
aError
messageStr
)
;
}
}
messageStr
.
Truncate
(
)
;
messageStr
.
AssignLiteral
(
u
"
"
)
;
if
(
errorClass
=
=
nsINSSErrorsService
:
:
ERROR_CLASS_BAD_CERT
)
{
error
=
"
nssBadCert
"
;
uint32_t
flags
=
UsePrivateBrowsing
(
)
?
nsISocketProvider
:
:
NO_PERMANENT_STORAGE
:
0
;
bool
isStsHost
=
false
;
bool
isPinnedHost
=
false
;
if
(
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsISiteSecurityService
>
sss
=
do_GetService
(
NS_SSSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
sss
-
>
IsSecureURI
(
nsISiteSecurityService
:
:
HEADER_HSTS
aURI
flags
GetOriginAttributes
(
)
nullptr
nullptr
&
isStsHost
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
sss
-
>
IsSecureURI
(
nsISiteSecurityService
:
:
HEADER_HPKP
aURI
flags
GetOriginAttributes
(
)
nullptr
nullptr
&
isPinnedHost
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
mozilla
:
:
dom
:
:
ContentChild
*
cc
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
cc
-
>
SendIsSecureURI
(
nsISiteSecurityService
:
:
HEADER_HSTS
aURI
flags
GetOriginAttributes
(
)
&
isStsHost
)
;
cc
-
>
SendIsSecureURI
(
nsISiteSecurityService
:
:
HEADER_HPKP
aURI
flags
GetOriginAttributes
(
)
&
isPinnedHost
)
;
}
if
(
Preferences
:
:
GetBool
(
"
browser
.
xul
.
error_pages
.
expert_bad_cert
"
false
)
)
{
cssClass
.
AssignLiteral
(
"
expertBadCert
"
)
;
}
if
(
isStsHost
|
|
isPinnedHost
)
{
cssClass
.
AssignLiteral
(
"
badStsCert
"
)
;
}
nsAutoCString
alternateErrorPage
;
nsresult
rv
=
Preferences
:
:
GetCString
(
"
security
.
alternate_certificate_error_page
"
alternateErrorPage
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
errorPage
.
Assign
(
alternateErrorPage
)
;
}
}
else
{
error
=
"
nssFailure2
"
;
}
}
else
if
(
NS_ERROR_PHISHING_URI
=
=
aError
|
|
NS_ERROR_MALWARE_URI
=
=
aError
|
|
NS_ERROR_UNWANTED_URI
=
=
aError
|
|
NS_ERROR_HARMFUL_URI
=
=
aError
)
{
nsAutoCString
host
;
aURI
-
>
GetHost
(
host
)
;
CopyUTF8toUTF16
(
host
*
formatStrs
.
AppendElement
(
)
)
;
nsAutoCString
alternateErrorPage
;
nsresult
rv
=
Preferences
:
:
GetCString
(
"
urlclassifier
.
alternate_error_page
"
alternateErrorPage
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
errorPage
.
Assign
(
alternateErrorPage
)
;
}
uint32_t
bucketId
;
bool
sendTelemetry
=
false
;
if
(
NS_ERROR_PHISHING_URI
=
=
aError
)
{
sendTelemetry
=
true
;
error
=
"
deceptiveBlocked
"
;
bucketId
=
IsFrame
(
)
?
IUrlClassifierUITelemetry
:
:
WARNING_PHISHING_PAGE_FRAME
:
IUrlClassifierUITelemetry
:
:
WARNING_PHISHING_PAGE_TOP
;
}
else
if
(
NS_ERROR_MALWARE_URI
=
=
aError
)
{
sendTelemetry
=
true
;
error
=
"
malwareBlocked
"
;
bucketId
=
IsFrame
(
)
?
IUrlClassifierUITelemetry
:
:
WARNING_MALWARE_PAGE_FRAME
:
IUrlClassifierUITelemetry
:
:
WARNING_MALWARE_PAGE_TOP
;
}
else
if
(
NS_ERROR_UNWANTED_URI
=
=
aError
)
{
sendTelemetry
=
true
;
error
=
"
unwantedBlocked
"
;
bucketId
=
IsFrame
(
)
?
IUrlClassifierUITelemetry
:
:
WARNING_UNWANTED_PAGE_FRAME
:
IUrlClassifierUITelemetry
:
:
WARNING_UNWANTED_PAGE_TOP
;
}
else
if
(
NS_ERROR_HARMFUL_URI
=
=
aError
)
{
sendTelemetry
=
true
;
error
=
"
harmfulBlocked
"
;
bucketId
=
IsFrame
(
)
?
IUrlClassifierUITelemetry
:
:
WARNING_HARMFUL_PAGE_FRAME
:
IUrlClassifierUITelemetry
:
:
WARNING_HARMFUL_PAGE_TOP
;
}
if
(
sendTelemetry
&
&
errorPage
.
EqualsIgnoreCase
(
"
blocked
"
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
URLCLASSIFIER_UI_EVENTS
bucketId
)
;
}
cssClass
.
AssignLiteral
(
"
blacklist
"
)
;
}
else
if
(
NS_ERROR_CONTENT_CRASHED
=
=
aError
)
{
errorPage
.
AssignLiteral
(
"
tabcrashed
"
)
;
error
=
"
tabcrashed
"
;
RefPtr
<
EventTarget
>
handler
=
mChromeEventHandler
;
if
(
handler
)
{
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
handler
)
;
element
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
crashedPageTitle
"
)
messageStr
)
;
}
if
(
messageStr
.
IsEmpty
(
)
)
{
messageStr
.
AssignLiteral
(
u
"
"
)
;
}
}
else
if
(
NS_ERROR_FRAME_CRASHED
=
=
aError
)
{
errorPage
.
AssignLiteral
(
"
framecrashed
"
)
;
error
=
"
framecrashed
"
;
messageStr
.
AssignLiteral
(
u
"
"
)
;
}
else
if
(
NS_ERROR_BUILDID_MISMATCH
=
=
aError
)
{
errorPage
.
AssignLiteral
(
"
restartrequired
"
)
;
error
=
"
restartrequired
"
;
if
(
messageStr
.
IsEmpty
(
)
)
{
messageStr
.
AssignLiteral
(
u
"
"
)
;
}
}
else
{
switch
(
aError
)
{
case
NS_ERROR_MALFORMED_URI
:
error
=
"
malformedURI
"
;
errorDescriptionID
=
"
malformedURI2
"
;
break
;
case
NS_ERROR_REDIRECT_LOOP
:
error
=
"
redirectLoop
"
;
break
;
case
NS_ERROR_UNKNOWN_SOCKET_TYPE
:
error
=
"
unknownSocketType
"
;
break
;
case
NS_ERROR_NET_RESET
:
error
=
"
netReset
"
;
break
;
case
NS_ERROR_DOCUMENT_NOT_CACHED
:
error
=
"
notCached
"
;
break
;
case
NS_ERROR_OFFLINE
:
error
=
"
netOffline
"
;
break
;
case
NS_ERROR_DOCUMENT_IS_PRINTMODE
:
error
=
"
isprinting
"
;
break
;
case
NS_ERROR_PORT_ACCESS_NOT_ALLOWED
:
addHostPort
=
true
;
error
=
"
deniedPortAccess
"
;
break
;
case
NS_ERROR_UNKNOWN_PROXY_HOST
:
error
=
"
proxyResolveFailure
"
;
break
;
case
NS_ERROR_PROXY_CONNECTION_REFUSED
:
case
NS_ERROR_PROXY_FORBIDDEN
:
case
NS_ERROR_PROXY_NOT_IMPLEMENTED
:
case
NS_ERROR_PROXY_AUTHENTICATION_FAILED
:
case
NS_ERROR_PROXY_TOO_MANY_REQUESTS
:
error
=
"
proxyConnectFailure
"
;
break
;
case
NS_ERROR_INVALID_CONTENT_ENCODING
:
error
=
"
contentEncodingError
"
;
break
;
case
NS_ERROR_REMOTE_XUL
:
error
=
"
remoteXUL
"
;
break
;
case
NS_ERROR_UNSAFE_CONTENT_TYPE
:
error
=
"
unsafeContentType
"
;
break
;
case
NS_ERROR_CORRUPTED_CONTENT
:
error
=
"
corruptedContentErrorv2
"
;
break
;
case
NS_ERROR_INTERCEPTION_FAILED
:
error
=
"
corruptedContentErrorv2
"
;
break
;
case
NS_ERROR_NET_INADEQUATE_SECURITY
:
error
=
"
inadequateSecurityError
"
;
addHostPort
=
true
;
break
;
case
NS_ERROR_BLOCKED_BY_POLICY
:
error
=
"
blockedByPolicy
"
;
break
;
case
NS_ERROR_NET_HTTP2_SENT_GOAWAY
:
case
NS_ERROR_NET_HTTP3_PROTOCOL_ERROR
:
error
=
"
networkProtocolError
"
;
break
;
default
:
break
;
}
}
if
(
nsCOMPtr
<
nsILoadURIDelegate
>
loadURIDelegate
=
GetLoadURIDelegate
(
)
)
{
nsCOMPtr
<
nsIURI
>
errorPageURI
;
rv
=
loadURIDelegate
-
>
HandleLoadError
(
aURI
aError
NS_ERROR_GET_MODULE
(
aError
)
getter_AddRefs
(
errorPageURI
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
mIsBeingDestroyed
)
{
*
aDisplayedErrorPage
=
false
;
return
NS_OK
;
}
if
(
errorPageURI
)
{
*
aDisplayedErrorPage
=
NS_SUCCEEDED
(
LoadErrorPage
(
errorPageURI
aURI
aFailedChannel
)
)
;
return
NS_OK
;
}
}
if
(
!
error
)
{
return
NS_OK
;
}
if
(
!
errorDescriptionID
)
{
errorDescriptionID
=
error
;
}
if
(
!
messageStr
.
IsEmpty
(
)
)
{
}
else
{
if
(
addHostPort
)
{
nsAutoCString
hostport
;
if
(
aURI
)
{
aURI
-
>
GetHostPort
(
hostport
)
;
}
else
{
hostport
.
Assign
(
'
?
'
)
;
}
CopyUTF8toUTF16
(
hostport
*
formatStrs
.
AppendElement
(
)
)
;
}
nsAutoCString
spec
;
rv
=
NS_ERROR_NOT_AVAILABLE
;
auto
&
nextFormatStr
=
*
formatStrs
.
AppendElement
(
)
;
if
(
aURI
)
{
if
(
SchemeIsFile
(
aURI
)
)
{
aURI
-
>
GetPathQueryRef
(
spec
)
;
}
else
{
aURI
-
>
GetSpec
(
spec
)
;
}
nsCOMPtr
<
nsITextToSubURI
>
textToSubURI
(
do_GetService
(
NS_ITEXTTOSUBURI_CONTRACTID
&
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
textToSubURI
-
>
UnEscapeURIForUI
(
spec
nextFormatStr
)
;
}
}
else
{
spec
.
Assign
(
'
?
'
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
CopyUTF8toUTF16
(
spec
nextFormatStr
)
;
}
rv
=
NS_OK
;
nsAutoString
str
;
rv
=
stringBundle
-
>
FormatStringFromName
(
errorDescriptionID
formatStrs
str
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
messageStr
.
Assign
(
str
)
;
}
NS_ENSURE_FALSE
(
messageStr
.
IsEmpty
(
)
NS_ERROR_FAILURE
)
;
if
(
(
NS_ERROR_NET_INTERRUPT
=
=
aError
|
|
NS_ERROR_NET_RESET
=
=
aError
)
&
&
SchemeIsHTTPS
(
aURI
)
)
{
error
=
"
nssFailure2
"
;
}
if
(
UseErrorPages
(
)
)
{
nsresult
loadedPage
=
LoadErrorPage
(
aURI
aURL
errorPage
.
get
(
)
error
messageStr
.
get
(
)
cssClass
.
get
(
)
aFailedChannel
)
;
*
aDisplayedErrorPage
=
NS_SUCCEEDED
(
loadedPage
)
;
}
else
{
if
(
mScriptGlobal
)
{
Unused
<
<
mScriptGlobal
-
>
GetDoc
(
)
;
}
prompter
-
>
Alert
(
nullptr
messageStr
.
get
(
)
)
;
}
return
NS_OK
;
}
#
define
PREF_SAFEBROWSING_ALLOWOVERRIDE
"
browser
.
safebrowsing
.
allowOverride
"
nsresult
nsDocShell
:
:
LoadErrorPage
(
nsIURI
*
aURI
const
char16_t
*
aURL
const
char
*
aErrorPage
const
char
*
aErrorType
const
char16_t
*
aDescription
const
char
*
aCSSClass
nsIChannel
*
aFailedChannel
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
#
if
defined
(
DEBUG
)
if
(
MOZ_LOG_TEST
(
gDocShellLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
chanName
;
if
(
aFailedChannel
)
{
aFailedChannel
-
>
GetName
(
chanName
)
;
}
else
{
chanName
.
AssignLiteral
(
"
<
no
channel
>
"
)
;
}
MOZ_LOG
(
gDocShellLog
LogLevel
:
:
Debug
(
"
nsDocShell
[
%
p
]
:
:
LoadErrorPage
(
\
"
%
s
\
"
\
"
%
s
\
"
{
.
.
.
}
[
%
s
]
)
\
n
"
this
aURI
?
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
NS_ConvertUTF16toUTF8
(
aURL
)
.
get
(
)
chanName
.
get
(
)
)
)
;
}
#
endif
nsAutoCString
url
;
if
(
aURI
)
{
nsresult
rv
=
aURI
-
>
GetSpec
(
url
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
aURL
)
{
CopyUTF16toUTF8
(
MakeStringSpan
(
aURL
)
url
)
;
}
else
{
return
NS_ERROR_INVALID_POINTER
;
}
#
undef
SAFE_ESCAPE
#
define
SAFE_ESCAPE
(
output
input
params
)
\
if
(
NS_WARN_IF
(
!
NS_Escape
(
input
output
params
)
)
)
{
\
return
NS_ERROR_OUT_OF_MEMORY
;
\
}
nsCString
escapedUrl
escapedError
escapedDescription
escapedCSSClass
;
SAFE_ESCAPE
(
escapedUrl
url
url_Path
)
;
SAFE_ESCAPE
(
escapedError
nsDependentCString
(
aErrorType
)
url_Path
)
;
SAFE_ESCAPE
(
escapedDescription
NS_ConvertUTF16toUTF8
(
aDescription
)
url_Path
)
;
if
(
aCSSClass
)
{
nsCString
cssClass
(
aCSSClass
)
;
SAFE_ESCAPE
(
escapedCSSClass
cssClass
url_Path
)
;
}
nsCString
errorPageUrl
(
"
about
:
"
)
;
errorPageUrl
.
AppendASCII
(
aErrorPage
)
;
errorPageUrl
.
AppendLiteral
(
"
?
e
=
"
)
;
errorPageUrl
.
AppendASCII
(
escapedError
.
get
(
)
)
;
errorPageUrl
.
AppendLiteral
(
"
&
u
=
"
)
;
errorPageUrl
.
AppendASCII
(
escapedUrl
.
get
(
)
)
;
if
(
(
strcmp
(
aErrorPage
"
blocked
"
)
=
=
0
)
&
&
Preferences
:
:
GetBool
(
PREF_SAFEBROWSING_ALLOWOVERRIDE
true
)
)
{
errorPageUrl
.
AppendLiteral
(
"
&
o
=
1
"
)
;
}
if
(
!
escapedCSSClass
.
IsEmpty
(
)
)
{
errorPageUrl
.
AppendLiteral
(
"
&
s
=
"
)
;
errorPageUrl
.
AppendASCII
(
escapedCSSClass
.
get
(
)
)
;
}
errorPageUrl
.
AppendLiteral
(
"
&
c
=
UTF
-
8
"
)
;
nsAutoCString
frameType
(
FrameTypeToString
(
mFrameType
)
)
;
errorPageUrl
.
AppendLiteral
(
"
&
f
=
"
)
;
errorPageUrl
.
AppendASCII
(
frameType
.
get
(
)
)
;
nsCOMPtr
<
nsICaptivePortalService
>
cps
=
do_GetService
(
NS_CAPTIVEPORTAL_CID
)
;
int32_t
cpsState
;
if
(
cps
&
&
NS_SUCCEEDED
(
cps
-
>
GetState
(
&
cpsState
)
)
&
&
cpsState
=
=
nsICaptivePortalService
:
:
LOCKED_PORTAL
)
{
errorPageUrl
.
AppendLiteral
(
"
&
captive
=
true
"
)
;
}
errorPageUrl
.
AppendLiteral
(
"
&
d
=
"
)
;
errorPageUrl
.
AppendASCII
(
escapedDescription
.
get
(
)
)
;
nsCOMPtr
<
nsIURI
>
errorPageURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
errorPageURI
)
errorPageUrl
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
LoadErrorPage
(
errorPageURI
aURI
aFailedChannel
)
;
}
nsresult
nsDocShell
:
:
LoadErrorPage
(
nsIURI
*
aErrorURI
nsIURI
*
aFailedURI
nsIChannel
*
aFailedChannel
)
{
mFailedChannel
=
aFailedChannel
;
mFailedURI
=
aFailedURI
;
mFailedLoadType
=
mLoadType
;
if
(
mLSHE
)
{
mLSHE
-
>
AbandonBFCacheEntry
(
)
;
}
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
aErrorURI
)
;
loadState
-
>
SetTriggeringPrincipal
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
loadState
-
>
SetLoadType
(
LOAD_ERROR_PAGE
)
;
loadState
-
>
SetFirstParty
(
true
)
;
loadState
-
>
SetSourceDocShell
(
this
)
;
return
InternalLoad
(
loadState
nullptr
nullptr
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
Reload
(
uint32_t
aReloadFlags
)
{
if
(
!
IsNavigationAllowed
(
)
)
{
return
NS_OK
;
}
nsresult
rv
;
NS_ASSERTION
(
(
(
aReloadFlags
&
INTERNAL_LOAD_FLAGS_LOADURI_SETUP_FLAGS
)
=
=
0
)
"
Reload
command
not
updated
to
use
load
flags
!
"
)
;
NS_ASSERTION
(
(
aReloadFlags
&
EXTRA_LOAD_FLAGS
)
=
=
0
"
Don
'
t
pass
these
flags
to
Reload
"
)
;
uint32_t
loadType
=
MAKE_LOAD_TYPE
(
LOAD_RELOAD_NORMAL
aReloadFlags
)
;
NS_ENSURE_TRUE
(
IsValidLoadType
(
loadType
)
NS_ERROR_INVALID_ARG
)
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
bool
canReload
=
true
;
if
(
rootSH
)
{
rootSH
-
>
LegacySHistory
(
)
-
>
NotifyOnHistoryReload
(
&
canReload
)
;
}
if
(
!
canReload
)
{
return
NS_OK
;
}
if
(
mOSHE
)
{
rv
=
LoadHistoryEntry
(
mOSHE
loadType
)
;
}
else
if
(
mLSHE
)
{
rv
=
LoadHistoryEntry
(
mLSHE
loadType
)
;
}
else
{
RefPtr
<
Document
>
doc
(
GetDocument
(
)
)
;
if
(
!
doc
)
{
return
NS_OK
;
}
uint32_t
flags
=
INTERNAL_LOAD_FLAGS_NONE
;
nsAutoString
srcdoc
;
nsIURI
*
baseURI
=
nullptr
;
nsCOMPtr
<
nsIURI
>
originalURI
;
nsCOMPtr
<
nsIURI
>
resultPrincipalURI
;
bool
loadReplace
=
false
;
nsIPrincipal
*
triggeringPrincipal
=
doc
-
>
NodePrincipal
(
)
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
doc
-
>
GetCsp
(
)
;
nsAutoString
contentTypeHint
;
doc
-
>
GetContentType
(
contentTypeHint
)
;
if
(
doc
-
>
IsSrcdocDocument
(
)
)
{
doc
-
>
GetSrcdocData
(
srcdoc
)
;
flags
|
=
INTERNAL_LOAD_FLAGS_IS_SRCDOC
;
baseURI
=
doc
-
>
GetBaseURI
(
)
;
}
nsCOMPtr
<
nsIChannel
>
chan
=
doc
-
>
GetChannel
(
)
;
if
(
chan
)
{
uint32_t
loadFlags
;
chan
-
>
GetLoadFlags
(
&
loadFlags
)
;
loadReplace
=
loadFlags
&
nsIChannel
:
:
LOAD_REPLACE
;
nsCOMPtr
<
nsIHttpChannel
>
httpChan
(
do_QueryInterface
(
chan
)
)
;
if
(
httpChan
)
{
httpChan
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
chan
-
>
LoadInfo
(
)
;
loadInfo
-
>
GetResultPrincipalURI
(
getter_AddRefs
(
resultPrincipalURI
)
)
;
}
if
(
!
triggeringPrincipal
)
{
MOZ_ASSERT
(
false
"
Reload
needs
a
valid
triggeringPrincipal
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIURI
>
currentURI
=
mCurrentURI
;
Maybe
<
nsCOMPtr
<
nsIURI
>
>
emplacedResultPrincipalURI
;
emplacedResultPrincipalURI
.
emplace
(
std
:
:
move
(
resultPrincipalURI
)
)
;
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
currentURI
)
;
loadState
-
>
SetReferrerInfo
(
mReferrerInfo
)
;
loadState
-
>
SetOriginalURI
(
originalURI
)
;
loadState
-
>
SetMaybeResultPrincipalURI
(
emplacedResultPrincipalURI
)
;
loadState
-
>
SetLoadReplace
(
loadReplace
)
;
loadState
-
>
SetTriggeringPrincipal
(
triggeringPrincipal
)
;
loadState
-
>
SetPrincipalToInherit
(
triggeringPrincipal
)
;
loadState
-
>
SetCsp
(
csp
)
;
loadState
-
>
SetLoadFlags
(
flags
)
;
loadState
-
>
SetTypeHint
(
NS_ConvertUTF16toUTF8
(
contentTypeHint
)
)
;
loadState
-
>
SetLoadType
(
loadType
)
;
loadState
-
>
SetFirstParty
(
true
)
;
loadState
-
>
SetSrcdocData
(
srcdoc
)
;
loadState
-
>
SetSourceDocShell
(
this
)
;
loadState
-
>
SetBaseURI
(
baseURI
)
;
rv
=
InternalLoad
(
loadState
nullptr
nullptr
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsDocShell
:
:
Stop
(
uint32_t
aStopFlags
)
{
mRestorePresentationEvent
.
Revoke
(
)
;
if
(
mLoadType
=
=
LOAD_ERROR_PAGE
)
{
if
(
mLSHE
)
{
SetHistoryEntryAndUpdateBC
(
Some
(
nullptr
)
Some
<
nsISHEntry
*
>
(
mLSHE
)
)
;
}
mFailedChannel
=
nullptr
;
mFailedURI
=
nullptr
;
}
if
(
nsIWebNavigation
:
:
STOP_CONTENT
&
aStopFlags
)
{
if
(
mContentViewer
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
=
mContentViewer
;
cv
-
>
Stop
(
)
;
}
}
if
(
nsIWebNavigation
:
:
STOP_NETWORK
&
aStopFlags
)
{
if
(
mRefreshURIList
)
{
SuspendRefreshURIs
(
)
;
mSavedRefreshURIList
.
swap
(
mRefreshURIList
)
;
mRefreshURIList
=
nullptr
;
}
Stop
(
)
;
}
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
nsCOMPtr
<
nsIWebNavigation
>
shellAsNav
(
do_QueryObject
(
iter
.
GetNext
(
)
)
)
;
if
(
shellAsNav
)
{
shellAsNav
-
>
Stop
(
aStopFlags
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetDocument
(
Document
*
*
aDocument
)
{
NS_ENSURE_ARG_POINTER
(
aDocument
)
;
NS_ENSURE_SUCCESS
(
EnsureContentViewer
(
)
NS_ERROR_FAILURE
)
;
RefPtr
<
Document
>
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
doc
.
forget
(
aDocument
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCurrentURI
(
nsIURI
*
*
aURI
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsCOMPtr
<
nsIURI
>
uri
=
mCurrentURI
;
uri
.
forget
(
aURI
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
InitSessionHistory
(
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
GetInProcessSameTypeRootTreeItem
(
getter_AddRefs
(
root
)
)
;
if
(
root
!
=
this
)
{
return
NS_ERROR_FAILURE
;
}
mSessionHistory
=
new
ChildSHistory
(
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetSessionHistoryXPCOM
(
nsISupports
*
*
aSessionHistory
)
{
NS_ENSURE_ARG_POINTER
(
aSessionHistory
)
;
RefPtr
<
ChildSHistory
>
shistory
=
mSessionHistory
;
shistory
.
forget
(
aSessionHistory
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
LoadPage
(
nsISupports
*
aPageDescriptor
uint32_t
aDisplayType
)
{
nsCOMPtr
<
nsISHEntry
>
shEntryIn
(
do_QueryInterface
(
aPageDescriptor
)
)
;
if
(
!
shEntryIn
)
{
return
NS_ERROR_INVALID_POINTER
;
}
nsCOMPtr
<
nsISHEntry
>
shEntry
;
nsresult
rv
=
shEntryIn
-
>
Clone
(
getter_AddRefs
(
shEntry
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
shEntry
-
>
AbandonBFCacheEntry
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
nsIWebPageDescriptor
:
:
DISPLAY_AS_SOURCE
=
=
aDisplayType
)
{
nsCString
spec
newSpec
;
nsCOMPtr
<
nsIURI
>
oldUri
=
shEntry
-
>
GetURI
(
)
;
oldUri
-
>
GetSpec
(
spec
)
;
newSpec
.
AppendLiteral
(
"
view
-
source
:
"
)
;
newSpec
.
Append
(
spec
)
;
nsCOMPtr
<
nsIURI
>
newUri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
newUri
)
newSpec
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
shEntry
-
>
SetURI
(
newUri
)
;
shEntry
-
>
SetOriginalURI
(
nullptr
)
;
shEntry
-
>
SetResultPrincipalURI
(
nullptr
)
;
shEntry
-
>
SetTriggeringPrincipal
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
}
rv
=
LoadHistoryEntry
(
shEntry
LOAD_HISTORY
)
;
return
rv
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCurrentDescriptor
(
nsISupports
*
*
aPageDescriptor
)
{
MOZ_ASSERT
(
aPageDescriptor
"
Null
out
param
?
"
)
;
*
aPageDescriptor
=
nullptr
;
nsISHEntry
*
src
=
mOSHE
?
mOSHE
:
mLSHE
;
if
(
src
)
{
nsCOMPtr
<
nsISHEntry
>
dest
;
nsresult
rv
=
src
-
>
Clone
(
getter_AddRefs
(
dest
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
dest
-
>
SetParent
(
nullptr
)
;
dest
-
>
SetIsSubFrame
(
false
)
;
return
CallQueryInterface
(
dest
aPageDescriptor
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
nsDocShell
:
:
InitWindow
(
nativeWindow
aParentNativeWindow
nsIWidget
*
aParentWidget
int32_t
aX
int32_t
aY
int32_t
aWidth
int32_t
aHeight
)
{
SetParentWidget
(
aParentWidget
)
;
SetPositionAndSize
(
aX
aY
aWidth
aHeight
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
Create
(
)
{
if
(
mCreated
)
{
return
NS_OK
;
}
NS_ASSERTION
(
mItemType
=
=
typeContent
|
|
mItemType
=
=
typeChrome
"
Unexpected
item
type
in
docshell
"
)
;
NS_ENSURE_TRUE
(
Preferences
:
:
GetRootBranch
(
)
NS_ERROR_FAILURE
)
;
mCreated
=
true
;
mUseErrorPages
=
StaticPrefs
:
:
browser_xul_error_pages_enabled
(
)
;
mDisableMetaRefreshWhenInactive
=
Preferences
:
:
GetBool
(
"
browser
.
meta_refresh_when_inactive
.
disabled
"
mDisableMetaRefreshWhenInactive
)
;
mDeviceSizeIsPageSize
=
Preferences
:
:
GetBool
(
"
docshell
.
device_size_is_page_size
"
mDeviceSizeIsPageSize
)
;
nsCOMPtr
<
nsIObserverService
>
serv
=
services
:
:
GetObserverService
(
)
;
if
(
serv
)
{
const
char
*
msg
=
mItemType
=
=
typeContent
?
NS_WEBNAVIGATION_CREATE
:
NS_CHROME_WEBNAVIGATION_CREATE
;
serv
-
>
NotifyObservers
(
GetAsSupports
(
this
)
msg
nullptr
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
Destroy
(
)
{
if
(
mIsBeingDestroyed
)
{
return
NS_ERROR_DOCSHELL_DYING
;
}
NS_ASSERTION
(
mItemType
=
=
typeContent
|
|
mItemType
=
=
typeChrome
"
Unexpected
item
type
in
docshell
"
)
;
nsCOMPtr
<
nsIObserverService
>
serv
=
services
:
:
GetObserverService
(
)
;
if
(
serv
)
{
const
char
*
msg
=
mItemType
=
=
typeContent
?
NS_WEBNAVIGATION_DESTROY
:
NS_CHROME_WEBNAVIGATION_DESTROY
;
serv
-
>
NotifyObservers
(
GetAsSupports
(
this
)
msg
nullptr
)
;
}
mIsBeingDestroyed
=
true
;
mInitialClientSource
.
reset
(
)
;
SetRecordProfileTimelineMarkers
(
false
)
;
if
(
mObserveErrorPages
)
{
mObserveErrorPages
=
false
;
}
mLoadingURI
=
nullptr
;
(
void
)
FirePageHideNotification
(
true
)
;
if
(
mOSHE
)
{
mOSHE
-
>
SetEditorData
(
nullptr
)
;
}
if
(
mLSHE
)
{
mLSHE
-
>
SetEditorData
(
nullptr
)
;
}
if
(
mContentListener
)
{
mContentListener
-
>
DropDocShellReference
(
)
;
mContentListener
-
>
SetParentContentListener
(
nullptr
)
;
}
Stop
(
nsIWebNavigation
:
:
STOP_ALL
)
;
mEditorData
=
nullptr
;
PersistLayoutHistoryState
(
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellParentAsItem
=
do_QueryInterface
(
GetAsSupports
(
mParent
)
)
;
if
(
docShellParentAsItem
)
{
docShellParentAsItem
-
>
RemoveChild
(
this
)
;
}
if
(
mContentViewer
)
{
mContentViewer
-
>
Close
(
nullptr
)
;
mContentViewer
-
>
Destroy
(
)
;
mContentViewer
=
nullptr
;
}
nsDocLoader
:
:
Destroy
(
)
;
mParentWidget
=
nullptr
;
mCurrentURI
=
nullptr
;
if
(
mScriptGlobal
)
{
mScriptGlobal
-
>
DetachFromDocShell
(
!
mWillChangeProcess
)
;
mScriptGlobal
=
nullptr
;
}
if
(
mSessionHistory
)
{
mSessionHistory
-
>
EvictLocalContentViewers
(
)
;
mSessionHistory
=
nullptr
;
}
if
(
mWillChangeProcess
)
{
mBrowsingContext
-
>
PrepareForProcessChange
(
)
;
}
SetTreeOwner
(
nullptr
)
;
mBrowserChild
=
nullptr
;
mChromeEventHandler
=
nullptr
;
mSecurityUI
=
nullptr
;
CancelRefreshURITimers
(
)
;
if
(
UsePrivateBrowsing
(
)
&
&
mAffectPrivateSessionLifetime
)
{
DecreasePrivateDocShellCount
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetUnscaledDevicePixelsPerCSSPixel
(
double
*
aScale
)
{
if
(
mParentWidget
)
{
*
aScale
=
mParentWidget
-
>
GetDefaultScale
(
)
.
scale
;
return
NS_OK
;
}
nsCOMPtr
<
nsIBaseWindow
>
ownerWindow
(
do_QueryInterface
(
mTreeOwner
)
)
;
if
(
ownerWindow
)
{
return
ownerWindow
-
>
GetUnscaledDevicePixelsPerCSSPixel
(
aScale
)
;
}
*
aScale
=
1
.
0
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetDevicePixelsPerDesktopPixel
(
double
*
aScale
)
{
if
(
mParentWidget
)
{
*
aScale
=
mParentWidget
-
>
GetDesktopToDeviceScale
(
)
.
scale
;
return
NS_OK
;
}
nsCOMPtr
<
nsIBaseWindow
>
ownerWindow
(
do_QueryInterface
(
mTreeOwner
)
)
;
if
(
ownerWindow
)
{
return
ownerWindow
-
>
GetDevicePixelsPerDesktopPixel
(
aScale
)
;
}
*
aScale
=
1
.
0
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetPosition
(
int32_t
aX
int32_t
aY
)
{
mBounds
.
MoveTo
(
aX
aY
)
;
if
(
mContentViewer
)
{
NS_ENSURE_SUCCESS
(
mContentViewer
-
>
Move
(
aX
aY
)
NS_ERROR_FAILURE
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetPositionDesktopPix
(
int32_t
aX
int32_t
aY
)
{
nsCOMPtr
<
nsIBaseWindow
>
ownerWindow
(
do_QueryInterface
(
mTreeOwner
)
)
;
if
(
ownerWindow
)
{
return
ownerWindow
-
>
SetPositionDesktopPix
(
aX
aY
)
;
}
double
scale
=
1
.
0
;
GetDevicePixelsPerDesktopPixel
(
&
scale
)
;
return
SetPosition
(
NSToIntRound
(
aX
*
scale
)
NSToIntRound
(
aY
*
scale
)
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetPosition
(
int32_t
*
aX
int32_t
*
aY
)
{
return
GetPositionAndSize
(
aX
aY
nullptr
nullptr
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetSize
(
int32_t
aWidth
int32_t
aHeight
bool
aRepaint
)
{
int32_t
x
=
0
y
=
0
;
GetPosition
(
&
x
&
y
)
;
return
SetPositionAndSize
(
x
y
aWidth
aHeight
aRepaint
?
nsIBaseWindow
:
:
eRepaint
:
0
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetSize
(
int32_t
*
aWidth
int32_t
*
aHeight
)
{
return
GetPositionAndSize
(
nullptr
nullptr
aWidth
aHeight
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetPositionAndSize
(
int32_t
aX
int32_t
aY
int32_t
aWidth
int32_t
aHeight
uint32_t
aFlags
)
{
mBounds
.
SetRect
(
aX
aY
aWidth
aHeight
)
;
nsCOMPtr
<
nsIContentViewer
>
viewer
=
mContentViewer
;
if
(
viewer
)
{
uint32_t
cvflags
=
(
aFlags
&
nsIBaseWindow
:
:
eDelayResize
)
?
nsIContentViewer
:
:
eDelayResize
:
0
;
nsresult
rv
=
viewer
-
>
SetBoundsWithFlags
(
mBounds
cvflags
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetPositionAndSize
(
int32_t
*
aX
int32_t
*
aY
int32_t
*
aWidth
int32_t
*
aHeight
)
{
if
(
mParentWidget
)
{
LayoutDeviceIntRect
r
=
mParentWidget
-
>
GetClientBounds
(
)
;
SetPositionAndSize
(
mBounds
.
X
(
)
mBounds
.
Y
(
)
r
.
Width
(
)
r
.
Height
(
)
0
)
;
}
if
(
aWidth
|
|
aHeight
)
{
RefPtr
<
Document
>
doc
(
do_GetInterface
(
GetAsSupports
(
mParent
)
)
)
;
if
(
doc
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
}
DoGetPositionAndSize
(
aX
aY
aWidth
aHeight
)
;
return
NS_OK
;
}
void
nsDocShell
:
:
DoGetPositionAndSize
(
int32_t
*
aX
int32_t
*
aY
int32_t
*
aWidth
int32_t
*
aHeight
)
{
if
(
aX
)
{
*
aX
=
mBounds
.
X
(
)
;
}
if
(
aY
)
{
*
aY
=
mBounds
.
Y
(
)
;
}
if
(
aWidth
)
{
*
aWidth
=
mBounds
.
Width
(
)
;
}
if
(
aHeight
)
{
*
aHeight
=
mBounds
.
Height
(
)
;
}
}
NS_IMETHODIMP
nsDocShell
:
:
Repaint
(
bool
aForce
)
{
PresShell
*
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
RefPtr
<
nsViewManager
>
viewManager
=
presShell
-
>
GetViewManager
(
)
;
NS_ENSURE_TRUE
(
viewManager
NS_ERROR_FAILURE
)
;
viewManager
-
>
InvalidateAllViews
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetParentWidget
(
nsIWidget
*
*
aParentWidget
)
{
NS_ENSURE_ARG_POINTER
(
aParentWidget
)
;
*
aParentWidget
=
mParentWidget
;
NS_IF_ADDREF
(
*
aParentWidget
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetParentWidget
(
nsIWidget
*
aParentWidget
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
mParentWidget
=
aParentWidget
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetParentNativeWindow
(
nativeWindow
*
aParentNativeWindow
)
{
NS_ENSURE_ARG_POINTER
(
aParentNativeWindow
)
;
if
(
mParentWidget
)
{
*
aParentNativeWindow
=
mParentWidget
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
;
}
else
{
*
aParentNativeWindow
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetParentNativeWindow
(
nativeWindow
aParentNativeWindow
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetNativeHandle
(
nsAString
&
aNativeHandle
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetVisibility
(
bool
*
aVisibility
)
{
NS_ENSURE_ARG_POINTER
(
aVisibility
)
;
*
aVisibility
=
false
;
if
(
!
mContentViewer
)
{
return
NS_OK
;
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
NS_OK
;
}
nsViewManager
*
vm
=
presShell
-
>
GetViewManager
(
)
;
NS_ENSURE_TRUE
(
vm
NS_ERROR_FAILURE
)
;
nsView
*
view
=
vm
-
>
GetRootView
(
)
;
NS_ENSURE_TRUE
(
view
NS_ERROR_FAILURE
)
;
if
(
view
-
>
GetVisibility
(
)
=
=
nsViewVisibility_kHide
)
{
return
NS_OK
;
}
RefPtr
<
nsDocShell
>
docShell
=
this
;
RefPtr
<
nsDocShell
>
parentItem
=
docShell
-
>
GetInProcessParentDocshell
(
)
;
while
(
parentItem
)
{
if
(
!
parentItem
-
>
GetPresShell
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
parent
docshell
has
null
pres
shell
"
)
;
return
NS_OK
;
}
vm
=
docShell
-
>
GetPresShell
(
)
-
>
GetViewManager
(
)
;
if
(
vm
)
{
view
=
vm
-
>
GetRootView
(
)
;
}
if
(
view
)
{
view
=
view
-
>
GetParent
(
)
;
if
(
view
)
{
view
=
view
-
>
GetParent
(
)
;
}
}
nsIFrame
*
frame
=
view
?
view
-
>
GetFrame
(
)
:
nullptr
;
bool
isDocShellOffScreen
=
false
;
docShell
-
>
GetIsOffScreenBrowser
(
&
isDocShellOffScreen
)
;
if
(
frame
&
&
!
frame
-
>
IsVisibleConsideringAncestors
(
nsIFrame
:
:
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
)
&
&
!
isDocShellOffScreen
)
{
return
NS_OK
;
}
docShell
=
parentItem
;
parentItem
=
docShell
-
>
GetInProcessParentDocshell
(
)
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
(
do_QueryInterface
(
mTreeOwner
)
)
;
if
(
!
treeOwnerAsWin
)
{
*
aVisibility
=
true
;
return
NS_OK
;
}
return
treeOwnerAsWin
-
>
GetVisibility
(
aVisibility
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetIsOffScreenBrowser
(
bool
aIsOffScreen
)
{
mIsOffScreenBrowser
=
aIsOffScreen
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsOffScreenBrowser
(
bool
*
aIsOffScreen
)
{
*
aIsOffScreen
=
mIsOffScreenBrowser
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetIsActive
(
bool
aIsActive
)
{
mBrowsingContext
-
>
SetIsActive
(
aIsActive
)
;
if
(
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
SetIsActive
(
aIsActive
)
;
}
if
(
mScriptGlobal
)
{
mScriptGlobal
-
>
SetIsBackground
(
!
aIsActive
)
;
if
(
RefPtr
<
Document
>
doc
=
mScriptGlobal
-
>
GetExtantDoc
(
)
)
{
if
(
aIsActive
)
{
if
(
mBrowsingContext
-
>
IsTop
(
)
)
{
uint16_t
orientation
=
OrientationLock
(
)
;
ScreenOrientation
:
:
UpdateActiveOrientationLock
(
orientation
)
;
}
}
doc
-
>
PostVisibilityUpdateEvent
(
)
;
}
}
RefPtr
<
nsDOMNavigationTiming
>
timing
=
mTiming
;
if
(
!
timing
&
&
mContentViewer
)
{
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
timing
=
doc
-
>
GetNavigationTiming
(
)
;
}
}
if
(
timing
)
{
timing
-
>
NotifyDocShellStateChanged
(
aIsActive
?
nsDOMNavigationTiming
:
:
DocShellState
:
:
eActive
:
nsDOMNavigationTiming
:
:
DocShellState
:
:
eInactive
)
;
}
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
docshell
=
do_QueryObject
(
iter
.
GetNext
(
)
)
;
if
(
!
docshell
)
{
continue
;
}
if
(
!
docshell
-
>
GetIsMozBrowser
(
)
)
{
docshell
-
>
SetIsActive
(
aIsActive
)
;
}
}
if
(
mDisableMetaRefreshWhenInactive
)
{
if
(
mBrowsingContext
-
>
GetIsActive
(
)
)
{
ResumeRefreshURIs
(
)
;
}
else
{
SuspendRefreshURIs
(
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsActive
(
bool
*
aIsActive
)
{
*
aIsActive
=
mBrowsingContext
-
>
GetIsActive
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetIsAppTab
(
bool
aIsAppTab
)
{
mIsAppTab
=
aIsAppTab
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsAppTab
(
bool
*
aIsAppTab
)
{
*
aIsAppTab
=
mIsAppTab
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetDefaultLoadFlags
(
uint32_t
aDefaultLoadFlags
)
{
mDefaultLoadFlags
=
aDefaultLoadFlags
;
if
(
mLoadGroup
)
{
mLoadGroup
-
>
SetDefaultLoadFlags
(
aDefaultLoadFlags
)
;
}
else
{
NS_WARNING
(
"
nsDocShell
:
:
SetDefaultLoadFlags
has
no
loadGroup
to
propagate
the
"
"
flags
to
"
)
;
}
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
docshell
=
do_QueryObject
(
iter
.
GetNext
(
)
)
;
if
(
!
docshell
)
{
continue
;
}
docshell
-
>
SetDefaultLoadFlags
(
aDefaultLoadFlags
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetDefaultLoadFlags
(
uint32_t
*
aDefaultLoadFlags
)
{
*
aDefaultLoadFlags
=
mDefaultLoadFlags
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetMixedContentChannel
(
nsIChannel
*
aMixedContentChannel
)
{
#
ifdef
DEBUG
if
(
aMixedContentChannel
)
{
NS_WARNING_ASSERTION
(
mBrowsingContext
-
>
IsTop
(
)
"
Setting
mMixedContentChannel
on
a
docshell
that
is
"
"
not
the
root
docshell
"
)
;
}
#
endif
mMixedContentChannel
=
aMixedContentChannel
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetFailedChannel
(
nsIChannel
*
*
aFailedChannel
)
{
NS_ENSURE_ARG_POINTER
(
aFailedChannel
)
;
Document
*
doc
=
GetDocument
(
)
;
if
(
!
doc
)
{
*
aFailedChannel
=
nullptr
;
return
NS_OK
;
}
NS_IF_ADDREF
(
*
aFailedChannel
=
doc
-
>
GetFailedChannel
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetMixedContentChannel
(
nsIChannel
*
*
aMixedContentChannel
)
{
NS_ENSURE_ARG_POINTER
(
aMixedContentChannel
)
;
NS_IF_ADDREF
(
*
aMixedContentChannel
=
mMixedContentChannel
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowMixedContentAndConnectionData
(
bool
*
aRootHasSecureConnection
bool
*
aAllowMixedContent
bool
*
aIsRootDocShell
)
{
*
aRootHasSecureConnection
=
true
;
*
aAllowMixedContent
=
false
;
*
aIsRootDocShell
=
false
;
nsCOMPtr
<
nsIDocShellTreeItem
>
sameTypeRoot
;
GetInProcessSameTypeRootTreeItem
(
getter_AddRefs
(
sameTypeRoot
)
)
;
NS_ASSERTION
(
sameTypeRoot
"
No
document
shell
root
tree
item
from
document
shell
tree
item
!
"
)
;
*
aIsRootDocShell
=
sameTypeRoot
.
get
(
)
=
=
static_cast
<
nsIDocShellTreeItem
*
>
(
this
)
;
RefPtr
<
Document
>
rootDoc
=
sameTypeRoot
-
>
GetDocument
(
)
;
if
(
rootDoc
)
{
nsCOMPtr
<
nsIPrincipal
>
rootPrincipal
=
rootDoc
-
>
NodePrincipal
(
)
;
nsCOMPtr
<
nsIURI
>
rootUri
=
rootPrincipal
-
>
GetURI
(
)
;
if
(
rootPrincipal
-
>
IsSystemPrincipal
(
)
|
|
!
rootUri
|
|
!
SchemeIsHTTPS
(
rootUri
)
)
{
*
aRootHasSecureConnection
=
false
;
}
nsCOMPtr
<
nsIDocShell
>
rootDocShell
=
do_QueryInterface
(
sameTypeRoot
)
;
nsCOMPtr
<
nsIChannel
>
mixedChannel
;
rootDocShell
-
>
GetMixedContentChannel
(
getter_AddRefs
(
mixedChannel
)
)
;
*
aAllowMixedContent
=
mixedChannel
&
&
(
mixedChannel
=
=
rootDoc
-
>
GetChannel
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetVisibility
(
bool
aVisibility
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
=
mContentViewer
;
if
(
!
cv
)
{
return
NS_OK
;
}
if
(
aVisibility
)
{
cv
-
>
Show
(
)
;
}
else
{
cv
-
>
Hide
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetEnabled
(
bool
*
aEnabled
)
{
NS_ENSURE_ARG_POINTER
(
aEnabled
)
;
*
aEnabled
=
true
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetEnabled
(
bool
aEnabled
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetFocus
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetMainWidget
(
nsIWidget
*
*
aMainWidget
)
{
return
GetParentWidget
(
aMainWidget
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetTitle
(
nsAString
&
aTitle
)
{
aTitle
=
mTitle
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetTitle
(
const
nsAString
&
aTitle
)
{
if
(
mTitleValidForCurrentURI
&
&
mTitle
=
=
aTitle
)
{
return
NS_OK
;
}
mTitle
=
aTitle
;
mTitleValidForCurrentURI
=
true
;
if
(
mBrowsingContext
-
>
IsTop
(
)
)
{
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
(
do_QueryInterface
(
mTreeOwner
)
)
;
if
(
treeOwnerAsWin
)
{
treeOwnerAsWin
-
>
SetTitle
(
aTitle
)
;
}
}
if
(
mCurrentURI
&
&
mLoadType
!
=
LOAD_ERROR_PAGE
)
{
UpdateGlobalHistoryTitle
(
mCurrentURI
)
;
}
if
(
mOSHE
&
&
mLoadType
!
=
LOAD_BYPASS_HISTORY
&
&
mLoadType
!
=
LOAD_ERROR_PAGE
)
{
mOSHE
-
>
SetTitle
(
mTitle
)
;
}
return
NS_OK
;
}
nsPoint
nsDocShell
:
:
GetCurScrollPos
(
)
{
nsPoint
scrollPos
;
if
(
nsIScrollableFrame
*
sf
=
GetRootScrollFrame
(
)
)
{
scrollPos
=
sf
-
>
GetVisualViewportOffset
(
)
;
}
return
scrollPos
;
}
nsresult
nsDocShell
:
:
SetCurScrollPosEx
(
int32_t
aCurHorizontalPos
int32_t
aCurVerticalPos
)
{
nsIScrollableFrame
*
sf
=
GetRootScrollFrame
(
)
;
NS_ENSURE_TRUE
(
sf
NS_ERROR_FAILURE
)
;
ScrollMode
scrollMode
=
sf
-
>
IsSmoothScroll
(
)
?
ScrollMode
:
:
SmoothMsd
:
ScrollMode
:
:
Instant
;
nsPoint
targetPos
(
aCurHorizontalPos
aCurVerticalPos
)
;
sf
-
>
ScrollTo
(
targetPos
scrollMode
)
;
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
NS_ENSURE_TRUE
(
presContext
NS_ERROR_FAILURE
)
;
if
(
!
presContext
-
>
IsRootContentDocument
(
)
)
{
return
NS_OK
;
}
if
(
!
presShell
-
>
IsVisualViewportSizeSet
(
)
)
{
return
NS_OK
;
}
presShell
-
>
ScrollToVisual
(
targetPos
layers
:
:
FrameMetrics
:
:
eMainThread
scrollMode
)
;
return
NS_OK
;
}
void
nsDocShell
:
:
SetScrollbarPreference
(
mozilla
:
:
ScrollbarPreference
aPref
)
{
if
(
mScrollbarPref
=
=
aPref
)
{
return
;
}
mScrollbarPref
=
aPref
;
auto
*
ps
=
GetPresShell
(
)
;
if
(
!
ps
)
{
return
;
}
nsIFrame
*
scrollFrame
=
ps
-
>
GetRootScrollFrame
(
)
;
if
(
!
scrollFrame
)
{
return
;
}
ps
-
>
FrameNeedsReflow
(
scrollFrame
IntrinsicDirty
:
:
StyleChange
NS_FRAME_IS_DIRTY
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
RefreshURI
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
int32_t
aDelay
bool
aRepeat
bool
aMetaRefresh
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
NS_ENSURE_ARG
(
aURI
)
;
bool
allowRedirects
=
true
;
GetAllowMetaRedirects
(
&
allowRedirects
)
;
if
(
!
allowRedirects
)
{
return
NS_OK
;
}
bool
sameURI
;
nsresult
rv
=
aURI
-
>
Equals
(
mCurrentURI
&
sameURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
sameURI
=
false
;
}
if
(
!
RefreshAttempted
(
this
aURI
aDelay
sameURI
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsITimerCallback
>
refreshTimer
=
new
nsRefreshTimer
(
this
aURI
aPrincipal
aDelay
aRepeat
aMetaRefresh
)
;
BusyFlags
busyFlags
=
GetBusyFlags
(
)
;
if
(
!
mRefreshURIList
)
{
mRefreshURIList
=
nsArray
:
:
Create
(
)
;
}
if
(
busyFlags
&
BUSY_FLAGS_BUSY
|
|
(
!
mBrowsingContext
-
>
GetIsActive
(
)
&
&
mDisableMetaRefreshWhenInactive
)
)
{
mRefreshURIList
-
>
AppendElement
(
refreshTimer
)
;
}
else
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetWindow
(
)
;
NS_ENSURE_TRUE
(
win
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsITimer
>
timer
;
MOZ_TRY_VAR
(
timer
NS_NewTimerWithCallback
(
refreshTimer
aDelay
nsITimer
:
:
TYPE_ONE_SHOT
win
-
>
TabGroup
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Network
)
)
)
;
mRefreshURIList
-
>
AppendElement
(
timer
)
;
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
ForceRefreshURIFromTimer
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
int32_t
aDelay
bool
aMetaRefresh
nsITimer
*
aTimer
)
{
MOZ_ASSERT
(
aTimer
"
Must
have
a
timer
here
"
)
;
if
(
mRefreshURIList
)
{
uint32_t
n
=
0
;
mRefreshURIList
-
>
GetLength
(
&
n
)
;
for
(
uint32_t
i
=
0
;
i
<
n
;
+
+
i
)
{
nsCOMPtr
<
nsITimer
>
timer
=
do_QueryElementAt
(
mRefreshURIList
i
)
;
if
(
timer
=
=
aTimer
)
{
mRefreshURIList
-
>
RemoveElementAt
(
i
)
;
break
;
}
}
}
return
ForceRefreshURI
(
aURI
aPrincipal
aDelay
aMetaRefresh
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
ForceRefreshURI
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
int32_t
aDelay
bool
aMetaRefresh
)
{
NS_ENSURE_ARG
(
aURI
)
;
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
aURI
)
;
loadState
-
>
SetOriginalURI
(
mCurrentURI
)
;
loadState
-
>
SetResultPrincipalURI
(
aURI
)
;
loadState
-
>
SetResultPrincipalURIIsSome
(
true
)
;
loadState
-
>
SetKeepResultPrincipalURIIfSet
(
true
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
aPrincipal
;
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
if
(
!
principal
)
{
if
(
!
doc
)
{
return
NS_ERROR_FAILURE
;
}
principal
=
doc
-
>
NodePrincipal
(
)
;
}
loadState
-
>
SetTriggeringPrincipal
(
principal
)
;
if
(
doc
)
{
loadState
-
>
SetCsp
(
doc
-
>
GetCsp
(
)
)
;
}
loadState
-
>
SetPrincipalIsExplicit
(
true
)
;
bool
equalUri
=
false
;
nsresult
rv
=
aURI
-
>
Equals
(
mCurrentURI
&
equalUri
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
!
equalUri
)
&
&
aMetaRefresh
&
&
aDelay
<
=
REFRESH_REDIRECT_TIMER
)
{
loadState
-
>
SetLoadType
(
LOAD_NORMAL_REPLACE
)
;
if
(
mReferrerInfo
)
{
referrerInfo
=
static_cast
<
ReferrerInfo
*
>
(
mReferrerInfo
.
get
(
)
)
-
>
CloneWithNewSendReferrer
(
false
)
;
}
}
else
{
loadState
-
>
SetLoadType
(
LOAD_REFRESH
)
;
referrerInfo
=
new
ReferrerInfo
(
mCurrentURI
ReferrerPolicy
:
:
_empty
false
)
;
}
loadState
-
>
SetReferrerInfo
(
referrerInfo
)
;
loadState
-
>
SetLoadFlags
(
nsIWebNavigation
:
:
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
)
;
loadState
-
>
SetFirstParty
(
true
)
;
LoadURI
(
loadState
false
)
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
SetupRefreshURIFromHeader
(
nsIURI
*
aBaseURI
nsIPrincipal
*
aPrincipal
uint64_t
aInnerWindowID
const
nsACString
&
aHeader
)
{
MOZ_ASSERT
(
aPrincipal
)
;
nsAutoCString
uriAttrib
;
int32_t
seconds
=
0
;
bool
specifiesSeconds
=
false
;
nsACString
:
:
const_iterator
iter
tokenStart
doneIterating
;
aHeader
.
BeginReading
(
iter
)
;
aHeader
.
EndReading
(
doneIterating
)
;
while
(
iter
!
=
doneIterating
&
&
nsCRT
:
:
IsAsciiSpace
(
*
iter
)
)
{
+
+
iter
;
}
tokenStart
=
iter
;
if
(
iter
!
=
doneIterating
&
&
(
*
iter
=
=
'
-
'
|
|
*
iter
=
=
'
+
'
)
)
{
+
+
iter
;
}
while
(
iter
!
=
doneIterating
&
&
(
*
iter
>
=
'
0
'
&
&
*
iter
<
=
'
9
'
)
)
{
seconds
=
seconds
*
10
+
(
*
iter
-
'
0
'
)
;
specifiesSeconds
=
true
;
+
+
iter
;
}
if
(
iter
!
=
doneIterating
)
{
if
(
*
tokenStart
=
=
'
-
'
)
{
seconds
=
-
seconds
;
}
nsACString
:
:
const_iterator
iterAfterDigit
=
iter
;
while
(
iter
!
=
doneIterating
&
&
!
(
*
iter
=
=
'
;
'
|
|
*
iter
=
=
'
'
)
)
{
if
(
specifiesSeconds
)
{
if
(
iter
=
=
iterAfterDigit
&
&
!
nsCRT
:
:
IsAsciiSpace
(
*
iter
)
&
&
*
iter
!
=
'
.
'
)
{
return
NS_ERROR_FAILURE
;
}
else
if
(
nsCRT
:
:
IsAsciiSpace
(
*
iter
)
)
{
+
+
iter
;
break
;
}
}
+
+
iter
;
}
while
(
iter
!
=
doneIterating
&
&
nsCRT
:
:
IsAsciiSpace
(
*
iter
)
)
{
+
+
iter
;
}
if
(
iter
!
=
doneIterating
&
&
(
*
iter
=
=
'
;
'
|
|
*
iter
=
=
'
'
)
)
{
+
+
iter
;
}
while
(
iter
!
=
doneIterating
&
&
nsCRT
:
:
IsAsciiSpace
(
*
iter
)
)
{
+
+
iter
;
}
}
tokenStart
=
iter
;
if
(
iter
!
=
doneIterating
&
&
(
*
iter
=
=
'
u
'
|
|
*
iter
=
=
'
U
'
)
)
{
+
+
iter
;
if
(
iter
!
=
doneIterating
&
&
(
*
iter
=
=
'
r
'
|
|
*
iter
=
=
'
R
'
)
)
{
+
+
iter
;
if
(
iter
!
=
doneIterating
&
&
(
*
iter
=
=
'
l
'
|
|
*
iter
=
=
'
L
'
)
)
{
+
+
iter
;
while
(
iter
!
=
doneIterating
&
&
nsCRT
:
:
IsAsciiSpace
(
*
iter
)
)
{
+
+
iter
;
}
if
(
iter
!
=
doneIterating
&
&
*
iter
=
=
'
=
'
)
{
+
+
iter
;
while
(
iter
!
=
doneIterating
&
&
nsCRT
:
:
IsAsciiSpace
(
*
iter
)
)
{
+
+
iter
;
}
tokenStart
=
iter
;
}
}
}
}
bool
isQuotedURI
=
false
;
if
(
tokenStart
!
=
doneIterating
&
&
(
*
tokenStart
=
=
'
"
'
|
|
*
tokenStart
=
=
'
\
'
'
)
)
{
isQuotedURI
=
true
;
+
+
tokenStart
;
}
iter
=
tokenStart
;
while
(
iter
!
=
doneIterating
)
{
if
(
isQuotedURI
&
&
(
*
iter
=
=
'
"
'
|
|
*
iter
=
=
'
\
'
'
)
)
{
break
;
}
+
+
iter
;
}
if
(
iter
!
=
tokenStart
&
&
isQuotedURI
)
{
-
-
iter
;
if
(
!
(
*
iter
=
=
'
"
'
|
|
*
iter
=
=
'
\
'
'
)
)
{
+
+
iter
;
}
}
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIURI
>
uri
;
bool
specifiesURI
=
false
;
if
(
tokenStart
=
=
iter
)
{
uri
=
aBaseURI
;
}
else
{
uriAttrib
=
Substring
(
tokenStart
iter
)
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
uriAttrib
nullptr
aBaseURI
)
;
specifiesURI
=
true
;
}
if
(
!
specifiesSeconds
&
&
!
specifiesURI
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIScriptSecurityManager
>
securityManager
(
do_GetService
(
NS_SCRIPTSECURITYMANAGER_CONTRACTID
&
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
securityManager
-
>
CheckLoadURIWithPrincipal
(
aPrincipal
uri
nsIScriptSecurityManager
:
:
LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT
aInnerWindowID
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
bool
isjs
=
true
;
rv
=
NS_URIChainHasFlags
(
uri
nsIProtocolHandler
:
:
URI_OPENING_EXECUTES_SCRIPT
&
isjs
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
isjs
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
seconds
<
0
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
RefreshURI
(
uri
aPrincipal
seconds
*
1000
false
true
)
;
}
}
}
return
rv
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetupRefreshURI
(
nsIChannel
*
aChannel
)
{
nsresult
rv
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aChannel
&
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
refreshHeader
;
rv
=
httpChannel
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
refresh
"
)
refreshHeader
)
;
if
(
!
refreshHeader
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIScriptSecurityManager
>
secMan
=
do_GetService
(
NS_SCRIPTSECURITYMANAGER_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
rv
=
secMan
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SetupReferrerInfoFromChannel
(
aChannel
)
;
rv
=
SetupRefreshURIFromHeader
(
mCurrentURI
principal
0
refreshHeader
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
NS_REFRESHURI_HEADER_FOUND
;
}
}
}
return
rv
;
}
static
void
DoCancelRefreshURITimers
(
nsIMutableArray
*
aTimerList
)
{
if
(
!
aTimerList
)
{
return
;
}
uint32_t
n
=
0
;
aTimerList
-
>
GetLength
(
&
n
)
;
while
(
n
)
{
nsCOMPtr
<
nsITimer
>
timer
(
do_QueryElementAt
(
aTimerList
-
-
n
)
)
;
aTimerList
-
>
RemoveElementAt
(
n
)
;
if
(
timer
)
{
timer
-
>
Cancel
(
)
;
}
}
}
NS_IMETHODIMP
nsDocShell
:
:
CancelRefreshURITimers
(
)
{
DoCancelRefreshURITimers
(
mRefreshURIList
)
;
DoCancelRefreshURITimers
(
mSavedRefreshURIList
)
;
mRefreshURIList
=
nullptr
;
mSavedRefreshURIList
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetRefreshPending
(
bool
*
aResult
)
{
if
(
!
mRefreshURIList
)
{
*
aResult
=
false
;
return
NS_OK
;
}
uint32_t
count
;
nsresult
rv
=
mRefreshURIList
-
>
GetLength
(
&
count
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aResult
=
(
count
!
=
0
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsDocShell
:
:
SuspendRefreshURIs
(
)
{
if
(
mRefreshURIList
)
{
uint32_t
n
=
0
;
mRefreshURIList
-
>
GetLength
(
&
n
)
;
for
(
uint32_t
i
=
0
;
i
<
n
;
+
+
i
)
{
nsCOMPtr
<
nsITimer
>
timer
=
do_QueryElementAt
(
mRefreshURIList
i
)
;
if
(
!
timer
)
{
continue
;
}
nsCOMPtr
<
nsITimerCallback
>
callback
;
timer
-
>
GetCallback
(
getter_AddRefs
(
callback
)
)
;
timer
-
>
Cancel
(
)
;
mRefreshURIList
-
>
ReplaceElementAt
(
callback
i
)
;
}
}
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryObject
(
iter
.
GetNext
(
)
)
;
if
(
shell
)
{
shell
-
>
SuspendRefreshURIs
(
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
ResumeRefreshURIs
(
)
{
RefreshURIFromQueue
(
)
;
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryObject
(
iter
.
GetNext
(
)
)
;
if
(
shell
)
{
shell
-
>
ResumeRefreshURIs
(
)
;
}
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
RefreshURIFromQueue
(
)
{
if
(
!
mRefreshURIList
)
{
return
NS_OK
;
}
uint32_t
n
=
0
;
mRefreshURIList
-
>
GetLength
(
&
n
)
;
while
(
n
)
{
nsCOMPtr
<
nsITimerCallback
>
refreshInfo
=
do_QueryElementAt
(
mRefreshURIList
-
-
n
)
;
if
(
refreshInfo
)
{
uint32_t
delay
=
static_cast
<
nsRefreshTimer
*
>
(
static_cast
<
nsITimerCallback
*
>
(
refreshInfo
)
)
-
>
GetDelay
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetWindow
(
)
;
if
(
win
)
{
nsCOMPtr
<
nsITimer
>
timer
;
NS_NewTimerWithCallback
(
getter_AddRefs
(
timer
)
refreshInfo
delay
nsITimer
:
:
TYPE_ONE_SHOT
win
-
>
TabGroup
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Network
)
)
;
if
(
timer
)
{
mRefreshURIList
-
>
ReplaceElementAt
(
timer
n
)
;
}
}
}
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
Embed
(
nsIContentViewer
*
aContentViewer
WindowGlobalChild
*
aWindowActor
)
{
PersistLayoutHistoryState
(
)
;
nsresult
rv
=
SetupNewViewer
(
aContentViewer
aWindowActor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mLSHE
)
{
if
(
mLSHE
-
>
HasDetachedEditor
(
)
)
{
ReattachEditorToWindow
(
mLSHE
)
;
}
SetDocCurrentStateObj
(
mLSHE
)
;
SetHistoryEntryAndUpdateBC
(
Nothing
(
)
Some
<
nsISHEntry
*
>
(
mLSHE
)
)
;
}
bool
updateHistory
=
true
;
switch
(
mLoadType
)
{
case
LOAD_NORMAL_REPLACE
:
case
LOAD_STOP_CONTENT_AND_REPLACE
:
case
LOAD_RELOAD_BYPASS_CACHE
:
case
LOAD_RELOAD_BYPASS_PROXY
:
case
LOAD_RELOAD_BYPASS_PROXY_AND_CACHE
:
case
LOAD_REPLACE_BYPASS_CACHE
:
updateHistory
=
false
;
break
;
default
:
break
;
}
if
(
!
updateHistory
)
{
SetLayoutHistoryState
(
nullptr
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
OnProgressChange
(
nsIWebProgress
*
aProgress
nsIRequest
*
aRequest
int32_t
aCurSelfProgress
int32_t
aMaxSelfProgress
int32_t
aCurTotalProgress
int32_t
aMaxTotalProgress
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
OnStateChange
(
nsIWebProgress
*
aProgress
nsIRequest
*
aRequest
uint32_t
aStateFlags
nsresult
aStatus
)
{
if
(
(
~
aStateFlags
&
(
STATE_START
|
STATE_IS_NETWORK
)
)
=
=
0
)
{
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
aRequest
)
)
;
nsCOMPtr
<
nsIURI
>
uri
;
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
nsAutoCString
aURI
;
uri
-
>
GetAsciiSpec
(
aURI
)
;
if
(
this
=
=
aProgress
)
{
mozilla
:
:
Unused
<
<
MaybeInitTiming
(
)
;
mTiming
-
>
NotifyFetchStart
(
uri
ConvertLoadTypeToNavigationType
(
mLoadType
)
)
;
if
(
RefPtr
<
DocumentChannel
>
docChannel
=
do_QueryObject
(
aRequest
)
)
{
docChannel
-
>
SetNavigationTiming
(
mTiming
)
;
}
}
mBusyFlags
=
(
BusyFlags
)
(
BUSY_FLAGS_BUSY
|
BUSY_FLAGS_BEFORE_PAGE_LOAD
)
;
if
(
(
aStateFlags
&
STATE_RESTORING
)
=
=
0
)
{
if
(
StaticPrefs
:
:
ui_use_activity_cursor
(
)
)
{
nsCOMPtr
<
nsIWidget
>
mainWidget
;
GetMainWidget
(
getter_AddRefs
(
mainWidget
)
)
;
if
(
mainWidget
)
{
mainWidget
-
>
SetCursor
(
eCursor_spinning
nullptr
0
0
)
;
}
}
}
}
else
if
(
(
~
aStateFlags
&
(
STATE_TRANSFERRING
|
STATE_IS_DOCUMENT
)
)
=
=
0
)
{
mBusyFlags
=
(
BusyFlags
)
(
BUSY_FLAGS_BUSY
|
BUSY_FLAGS_PAGE_LOADING
)
;
}
else
if
(
(
aStateFlags
&
STATE_STOP
)
&
&
(
aStateFlags
&
STATE_IS_NETWORK
)
)
{
mBusyFlags
=
BUSY_FLAGS_NONE
;
if
(
StaticPrefs
:
:
ui_use_activity_cursor
(
)
)
{
nsCOMPtr
<
nsIWidget
>
mainWidget
;
GetMainWidget
(
getter_AddRefs
(
mainWidget
)
)
;
if
(
mainWidget
)
{
mainWidget
-
>
SetCursor
(
eCursor_standard
nullptr
0
0
)
;
}
}
}
if
(
(
~
aStateFlags
&
(
STATE_IS_DOCUMENT
|
STATE_STOP
)
)
=
=
0
)
{
nsCOMPtr
<
nsIWebProgress
>
webProgress
=
do_QueryInterface
(
GetAsSupports
(
this
)
)
;
if
(
aProgress
=
=
webProgress
.
get
(
)
)
{
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
aRequest
)
)
;
EndPageLoad
(
aProgress
channel
aStatus
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
OnLocationChange
(
nsIWebProgress
*
aProgress
nsIRequest
*
aRequest
nsIURI
*
aURI
uint32_t
aFlags
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
void
nsDocShell
:
:
OnRedirectStateChange
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aRedirectFlags
uint32_t
aStateFlags
)
{
NS_ASSERTION
(
aStateFlags
&
STATE_REDIRECTING
"
Calling
OnRedirectStateChange
when
there
is
no
redirect
"
)
;
if
(
mMixedContentChannel
&
&
mMixedContentChannel
=
=
aOldChannel
)
{
nsresult
rv
=
nsContentUtils
:
:
CheckSameOrigin
(
mMixedContentChannel
aNewChannel
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
SetMixedContentChannel
(
aNewChannel
)
;
}
else
{
SetMixedContentChannel
(
nullptr
)
;
}
}
if
(
!
(
aStateFlags
&
STATE_IS_DOCUMENT
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
oldURI
newURI
;
aOldChannel
-
>
GetURI
(
getter_AddRefs
(
oldURI
)
)
;
aNewChannel
-
>
GetURI
(
getter_AddRefs
(
newURI
)
)
;
if
(
!
oldURI
|
|
!
newURI
)
{
return
;
}
if
(
RefPtr
<
DocumentChannel
>
docChannel
=
do_QueryObject
(
aOldChannel
)
)
{
nsCOMPtr
<
nsIURI
>
previousURI
;
uint32_t
previousFlags
=
0
;
docChannel
-
>
GetLastVisit
(
getter_AddRefs
(
previousURI
)
&
previousFlags
)
;
SavePreviousRedirectsAndLastVisit
(
aNewChannel
previousURI
previousFlags
docChannel
-
>
GetRedirectChain
(
)
)
;
}
else
{
nsCOMPtr
<
nsIURI
>
previousURI
;
uint32_t
previousFlags
=
0
;
ExtractLastVisit
(
aOldChannel
getter_AddRefs
(
previousURI
)
&
previousFlags
)
;
if
(
aRedirectFlags
&
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
|
|
net
:
:
ChannelIsPost
(
aOldChannel
)
)
{
SaveLastVisit
(
aNewChannel
previousURI
previousFlags
)
;
}
else
{
uint32_t
responseStatus
=
0
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aOldChannel
)
;
if
(
httpChannel
)
{
Unused
<
<
httpChannel
-
>
GetResponseStatus
(
&
responseStatus
)
;
}
AddURIVisit
(
oldURI
previousURI
previousFlags
responseStatus
)
;
SaveLastVisit
(
aNewChannel
oldURI
aRedirectFlags
)
;
}
}
nsCOMPtr
<
nsIApplicationCacheChannel
>
appCacheChannel
=
do_QueryInterface
(
aNewChannel
)
;
if
(
appCacheChannel
)
{
if
(
GeckoProcessType_Default
!
=
XRE_GetProcessType
(
)
)
{
appCacheChannel
-
>
SetChooseApplicationCache
(
true
)
;
}
else
{
nsCOMPtr
<
nsIScriptSecurityManager
>
secMan
=
do_GetService
(
NS_SCRIPTSECURITYMANAGER_CONTRACTID
)
;
if
(
secMan
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
secMan
-
>
GetDocShellContentPrincipal
(
newURI
this
getter_AddRefs
(
principal
)
)
;
appCacheChannel
-
>
SetChooseApplicationCache
(
NS_ShouldCheckAppCache
(
principal
)
)
;
}
}
}
if
(
!
(
aRedirectFlags
&
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
&
&
mLoadType
&
(
LOAD_CMD_RELOAD
|
LOAD_CMD_HISTORY
)
)
{
mLoadType
=
LOAD_NORMAL_REPLACE
;
SetHistoryEntryAndUpdateBC
(
Some
(
nullptr
)
Nothing
(
)
)
;
}
}
NS_IMETHODIMP
nsDocShell
:
:
OnStatusChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsresult
aStatus
const
char16_t
*
aMessage
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
OnSecurityChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aState
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
OnContentBlockingEvent
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aEvent
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
EndPageLoad
(
nsIWebProgress
*
aProgress
nsIChannel
*
aChannel
nsresult
aStatus
)
{
MOZ_LOG
(
gDocShellLeakLog
LogLevel
:
:
Debug
(
"
DOCSHELL
%
p
EndPageLoad
status
:
%
"
PRIx32
"
\
n
"
this
static_cast
<
uint32_t
>
(
aStatus
)
)
)
;
if
(
!
aChannel
)
{
return
NS_ERROR_NULL_POINTER
;
}
mInitialClientSource
.
reset
(
)
;
nsCOMPtr
<
nsIConsoleReportCollector
>
reporter
=
do_QueryInterface
(
aChannel
)
;
if
(
reporter
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
aChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
if
(
loadGroup
)
{
reporter
-
>
FlushConsoleReports
(
loadGroup
)
;
}
else
{
reporter
-
>
FlushConsoleReports
(
GetDocument
(
)
)
;
}
}
nsCOMPtr
<
nsIURI
>
url
;
nsresult
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
url
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsITimedChannel
>
timingChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
timingChannel
)
{
TimeStamp
channelCreationTime
;
rv
=
timingChannel
-
>
GetChannelCreation
(
&
channelCreationTime
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
channelCreationTime
.
IsNull
(
)
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
TOTAL_CONTENT_PAGE_LOAD_TIME
channelCreationTime
)
;
}
}
mTiming
=
nullptr
;
if
(
eCharsetReloadRequested
=
=
mCharsetReloadState
)
{
mCharsetReloadState
=
eCharsetReloadStopOrigional
;
}
else
{
mCharsetReloadState
=
eCharsetReloadInit
;
}
nsCOMPtr
<
nsISHEntry
>
loadingSHE
=
mLSHE
;
mozilla
:
:
Unused
<
<
loadingSHE
;
nsCOMPtr
<
nsIDocShell
>
kungFuDeathGrip
(
this
)
;
if
(
!
mEODForCurrentDocument
&
&
mContentViewer
)
{
mIsExecutingOnLoadHandler
=
true
;
nsCOMPtr
<
nsIContentViewer
>
contentViewer
=
mContentViewer
;
contentViewer
-
>
LoadComplete
(
aStatus
)
;
mIsExecutingOnLoadHandler
=
false
;
mEODForCurrentDocument
=
true
;
if
(
-
-
gNumberOfDocumentsLoading
=
=
0
)
{
FavorPerformanceHint
(
false
)
;
}
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aChannel
)
)
;
if
(
!
httpChannel
)
{
GetHttpChannel
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
}
if
(
httpChannel
)
{
bool
discardLayoutState
=
ShouldDiscardLayoutState
(
httpChannel
)
;
if
(
mLSHE
&
&
discardLayoutState
&
&
(
mLoadType
&
LOAD_CMD_NORMAL
)
&
&
(
mLoadType
!
=
LOAD_BYPASS_HISTORY
)
&
&
(
mLoadType
!
=
LOAD_ERROR_PAGE
)
)
{
mLSHE
-
>
SetSaveLayoutStateFlag
(
false
)
;
}
}
if
(
mLSHE
)
{
mLSHE
-
>
SetLoadType
(
LOAD_HISTORY
)
;
SetHistoryEntryAndUpdateBC
(
Some
(
nullptr
)
Nothing
(
)
)
;
}
if
(
mBrowsingContext
-
>
GetIsActive
(
)
|
|
!
mDisableMetaRefreshWhenInactive
)
RefreshURIFromQueue
(
)
;
bool
isTopFrame
=
mBrowsingContext
-
>
IsTop
(
)
;
if
(
url
&
&
NS_FAILED
(
aStatus
)
)
{
if
(
aStatus
=
=
NS_ERROR_FILE_NOT_FOUND
|
|
aStatus
=
=
NS_ERROR_FILE_ACCESS_DENIED
|
|
aStatus
=
=
NS_ERROR_CORRUPTED_CONTENT
|
|
aStatus
=
=
NS_ERROR_INVALID_CONTENT_ENCODING
)
{
DisplayLoadError
(
aStatus
url
nullptr
aChannel
)
;
return
NS_OK
;
}
if
(
!
isTopFrame
&
&
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
aStatus
)
)
{
RefPtr
<
Element
>
frameElement
;
nsPIDOMWindowOuter
*
thisWindow
=
GetWindow
(
)
;
if
(
!
thisWindow
)
{
return
NS_OK
;
}
frameElement
=
thisWindow
-
>
GetFrameElement
(
)
;
if
(
!
frameElement
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parentItem
;
GetInProcessSameTypeParent
(
getter_AddRefs
(
parentItem
)
)
;
if
(
!
parentItem
)
{
return
NS_OK
;
}
RefPtr
<
Document
>
parentDoc
;
parentDoc
=
parentItem
-
>
GetDocument
(
)
;
if
(
!
parentDoc
)
{
return
NS_OK
;
}
parentDoc
-
>
AddBlockedNodeByClassifier
(
frameElement
)
;
return
NS_OK
;
}
if
(
sURIFixup
)
{
nsCOMPtr
<
nsIURI
>
newURI
;
nsCOMPtr
<
nsIInputStream
>
newPostData
;
nsAutoCString
oldSpec
;
url
-
>
GetSpec
(
oldSpec
)
;
nsAutoString
keywordProviderName
keywordAsSent
;
if
(
aStatus
=
=
NS_ERROR_UNKNOWN_HOST
&
&
mAllowKeywordFixup
)
{
bool
keywordsEnabled
=
Preferences
:
:
GetBool
(
"
keyword
.
enabled
"
false
)
;
nsAutoCString
host
;
url
-
>
GetHost
(
host
)
;
nsAutoCString
scheme
;
url
-
>
GetScheme
(
scheme
)
;
int32_t
dotLoc
=
host
.
FindChar
(
'
.
'
)
;
if
(
keywordsEnabled
&
&
!
scheme
.
IsEmpty
(
)
&
&
(
scheme
.
Find
(
"
http
"
)
!
=
0
)
)
{
keywordsEnabled
=
false
;
}
if
(
keywordsEnabled
&
&
(
kNotFound
=
=
dotLoc
)
)
{
nsCOMPtr
<
nsIURIFixupInfo
>
info
;
if
(
!
mOriginalUriString
.
IsEmpty
(
)
)
{
sURIFixup
-
>
KeywordToURI
(
mOriginalUriString
UsePrivateBrowsing
(
)
getter_AddRefs
(
newPostData
)
getter_AddRefs
(
info
)
)
;
}
else
{
bool
isACE
;
nsAutoCString
utf8Host
;
nsCOMPtr
<
nsIIDNService
>
idnSrv
=
do_GetService
(
NS_IDNSERVICE_CONTRACTID
)
;
if
(
idnSrv
&
&
NS_SUCCEEDED
(
idnSrv
-
>
IsACE
(
host
&
isACE
)
)
&
&
isACE
&
&
NS_SUCCEEDED
(
idnSrv
-
>
ConvertACEtoUTF8
(
host
utf8Host
)
)
)
{
sURIFixup
-
>
KeywordToURI
(
utf8Host
UsePrivateBrowsing
(
)
getter_AddRefs
(
newPostData
)
getter_AddRefs
(
info
)
)
;
}
else
{
sURIFixup
-
>
KeywordToURI
(
host
UsePrivateBrowsing
(
)
getter_AddRefs
(
newPostData
)
getter_AddRefs
(
info
)
)
;
}
}
info
-
>
GetPreferredURI
(
getter_AddRefs
(
newURI
)
)
;
if
(
newURI
)
{
info
-
>
GetKeywordAsSent
(
keywordAsSent
)
;
info
-
>
GetKeywordProviderName
(
keywordProviderName
)
;
}
}
}
if
(
aStatus
=
=
NS_ERROR_UNKNOWN_HOST
|
|
aStatus
=
=
NS_ERROR_NET_RESET
)
{
bool
doCreateAlternate
=
true
;
if
(
mLoadType
!
=
LOAD_NORMAL
|
|
!
isTopFrame
)
{
doCreateAlternate
=
false
;
}
else
{
if
(
newURI
)
{
bool
sameURI
=
false
;
url
-
>
Equals
(
newURI
&
sameURI
)
;
if
(
!
sameURI
)
{
doCreateAlternate
=
false
;
}
}
if
(
doCreateAlternate
)
{
nsCOMPtr
<
nsILoadInfo
>
info
=
aChannel
-
>
LoadInfo
(
)
;
if
(
!
info
-
>
RedirectChain
(
)
.
IsEmpty
(
)
)
{
doCreateAlternate
=
false
;
}
}
}
if
(
doCreateAlternate
)
{
newURI
=
nullptr
;
newPostData
=
nullptr
;
keywordProviderName
.
Truncate
(
)
;
keywordAsSent
.
Truncate
(
)
;
sURIFixup
-
>
CreateFixupURI
(
oldSpec
nsIURIFixup
:
:
FIXUP_FLAGS_MAKE_ALTERNATE_URI
getter_AddRefs
(
newPostData
)
getter_AddRefs
(
newURI
)
)
;
}
}
if
(
newURI
)
{
bool
sameURI
=
false
;
url
-
>
Equals
(
newURI
&
sameURI
)
;
if
(
!
sameURI
)
{
nsAutoCString
newSpec
;
newURI
-
>
GetSpec
(
newSpec
)
;
NS_ConvertUTF8toUTF16
newSpecW
(
newSpec
)
;
MaybeNotifyKeywordSearchLoading
(
keywordProviderName
keywordAsSent
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
MOZ_ASSERT
(
loadInfo
"
loadInfo
is
required
on
all
channels
"
)
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
loadInfo
-
>
TriggeringPrincipal
(
)
;
LoadURIOptions
loadURIOptions
;
loadURIOptions
.
mTriggeringPrincipal
=
triggeringPrincipal
;
loadURIOptions
.
mCsp
=
loadInfo
-
>
GetCspToInherit
(
)
;
loadURIOptions
.
mPostData
=
newPostData
;
return
LoadURI
(
newSpecW
loadURIOptions
)
;
}
}
}
if
(
(
aStatus
=
=
NS_ERROR_UNKNOWN_HOST
|
|
aStatus
=
=
NS_ERROR_CONNECTION_REFUSED
|
|
aStatus
=
=
NS_ERROR_UNKNOWN_PROXY_HOST
|
|
aStatus
=
=
NS_ERROR_PROXY_CONNECTION_REFUSED
|
|
aStatus
=
=
NS_ERROR_PROXY_FORBIDDEN
|
|
aStatus
=
=
NS_ERROR_PROXY_NOT_IMPLEMENTED
|
|
aStatus
=
=
NS_ERROR_PROXY_AUTHENTICATION_FAILED
|
|
aStatus
=
=
NS_ERROR_PROXY_TOO_MANY_REQUESTS
|
|
aStatus
=
=
NS_ERROR_MALFORMED_URI
|
|
aStatus
=
=
NS_ERROR_BLOCKED_BY_POLICY
)
&
&
(
isTopFrame
|
|
UseErrorPages
(
)
)
)
{
DisplayLoadError
(
aStatus
url
nullptr
aChannel
)
;
}
else
if
(
aStatus
=
=
NS_ERROR_NET_TIMEOUT
|
|
aStatus
=
=
NS_ERROR_PROXY_GATEWAY_TIMEOUT
|
|
aStatus
=
=
NS_ERROR_REDIRECT_LOOP
|
|
aStatus
=
=
NS_ERROR_UNKNOWN_SOCKET_TYPE
|
|
aStatus
=
=
NS_ERROR_NET_INTERRUPT
|
|
aStatus
=
=
NS_ERROR_NET_RESET
|
|
aStatus
=
=
NS_ERROR_PROXY_BAD_GATEWAY
|
|
aStatus
=
=
NS_ERROR_OFFLINE
|
|
aStatus
=
=
NS_ERROR_MALWARE_URI
|
|
aStatus
=
=
NS_ERROR_PHISHING_URI
|
|
aStatus
=
=
NS_ERROR_UNWANTED_URI
|
|
aStatus
=
=
NS_ERROR_HARMFUL_URI
|
|
aStatus
=
=
NS_ERROR_UNSAFE_CONTENT_TYPE
|
|
aStatus
=
=
NS_ERROR_REMOTE_XUL
|
|
aStatus
=
=
NS_ERROR_INTERCEPTION_FAILED
|
|
aStatus
=
=
NS_ERROR_NET_INADEQUATE_SECURITY
|
|
aStatus
=
=
NS_ERROR_NET_HTTP2_SENT_GOAWAY
|
|
aStatus
=
=
NS_ERROR_NET_HTTP3_PROTOCOL_ERROR
|
|
NS_ERROR_GET_MODULE
(
aStatus
)
=
=
NS_ERROR_MODULE_SECURITY
)
{
DisplayLoadError
(
aStatus
url
nullptr
aChannel
)
;
}
else
if
(
aStatus
=
=
NS_ERROR_UNKNOWN_PROTOCOL
)
{
nsCOMPtr
<
nsILoadInfo
>
info
=
aChannel
-
>
LoadInfo
(
)
;
Document
*
doc
=
GetDocument
(
)
;
if
(
!
info
-
>
TriggeringPrincipal
(
)
-
>
IsSystemPrincipal
(
)
&
&
StaticPrefs
:
:
dom_no_unknown_protocol_error_enabled
(
)
&
&
doc
&
&
!
doc
-
>
IsInitialDocument
(
)
)
{
nsTArray
<
nsString
>
params
;
if
(
NS_FAILED
(
NS_GetSanitizedURIStringFromURI
(
url
*
params
.
AppendElement
(
)
)
)
)
{
params
.
LastElement
(
)
.
AssignLiteral
(
u
"
(
unknown
uri
)
"
)
;
}
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
DOM
"
)
doc
nsContentUtils
:
:
eDOM_PROPERTIES
"
UnknownProtocolNavigationPrevented
"
params
)
;
}
else
{
DisplayLoadError
(
aStatus
url
nullptr
aChannel
)
;
}
}
else
if
(
aStatus
=
=
NS_ERROR_DOCUMENT_NOT_CACHED
)
{
if
(
!
(
mLoadType
&
LOAD_CMD_HISTORY
)
)
{
aStatus
=
NS_ERROR_OFFLINE
;
}
DisplayLoadError
(
aStatus
url
nullptr
aChannel
)
;
}
}
else
if
(
url
&
&
NS_SUCCEEDED
(
aStatus
)
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
PredictorLearnRedirect
(
url
aChannel
loadInfo
-
>
GetOriginAttributes
(
)
)
;
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
EnsureContentViewer
(
)
{
if
(
mContentViewer
)
{
return
NS_OK
;
}
if
(
mIsBeingDestroyed
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
cspToInheritForAboutBlank
;
nsCOMPtr
<
nsIURI
>
baseURI
;
nsIPrincipal
*
principal
=
GetInheritedPrincipal
(
false
)
;
nsIPrincipal
*
storagePrincipal
=
GetInheritedPrincipal
(
false
true
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parentItem
;
GetInProcessSameTypeParent
(
getter_AddRefs
(
parentItem
)
)
;
if
(
parentItem
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWin
=
GetWindow
(
)
)
{
nsCOMPtr
<
Element
>
parentElement
=
domWin
-
>
GetFrameElementInternal
(
)
;
if
(
parentElement
)
{
baseURI
=
parentElement
-
>
GetBaseURI
(
)
;
cspToInheritForAboutBlank
=
parentElement
-
>
GetCsp
(
)
;
}
}
}
nsresult
rv
=
CreateAboutBlankContentViewer
(
principal
storagePrincipal
cspToInheritForAboutBlank
baseURI
)
;
NS_ENSURE_STATE
(
mContentViewer
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
RefPtr
<
Document
>
doc
(
GetDocument
(
)
)
;
NS_ASSERTION
(
doc
"
Should
have
doc
if
CreateAboutBlankContentViewer
"
"
succeeded
!
"
)
;
doc
-
>
SetIsInitialDocument
(
true
)
;
doc
-
>
IgnoreDocGroupMismatches
(
)
;
}
return
rv
;
}
nsresult
nsDocShell
:
:
CreateAboutBlankContentViewer
(
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aStoragePrincipal
nsIContentSecurityPolicy
*
aCSP
nsIURI
*
aBaseURI
bool
aTryToSaveOldPresentation
bool
aCheckPermitUnload
WindowGlobalChild
*
aActor
)
{
RefPtr
<
Document
>
blankDoc
;
nsCOMPtr
<
nsIContentViewer
>
viewer
;
nsresult
rv
=
NS_ERROR_FAILURE
;
MOZ_ASSERT_IF
(
aActor
aActor
-
>
DocumentPrincipal
(
)
=
=
aPrincipal
)
;
NS_ASSERTION
(
!
mCreatingDocument
"
infinite
(
?
)
loop
creating
document
averted
"
)
;
if
(
mCreatingDocument
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDocShell
>
kungFuDeathGrip
(
this
)
;
AutoRestore
<
bool
>
creatingDocument
(
mCreatingDocument
)
;
mCreatingDocument
=
true
;
if
(
aPrincipal
&
&
!
aPrincipal
-
>
IsSystemPrincipal
(
)
&
&
mItemType
!
=
typeChrome
)
{
MOZ_ASSERT
(
aPrincipal
-
>
OriginAttributesRef
(
)
=
=
mBrowsingContext
-
>
OriginAttributesRef
(
)
)
;
}
bool
hadTiming
=
mTiming
;
bool
toBeReset
=
MaybeInitTiming
(
)
;
if
(
mContentViewer
)
{
if
(
aCheckPermitUnload
)
{
mTiming
-
>
NotifyBeforeUnload
(
)
;
bool
okToUnload
;
rv
=
mContentViewer
-
>
PermitUnload
(
&
okToUnload
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
okToUnload
)
{
MaybeResetInitTiming
(
toBeReset
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mTiming
)
{
mTiming
-
>
NotifyUnloadAccepted
(
mCurrentURI
)
;
}
}
mSavingOldViewer
=
aTryToSaveOldPresentation
&
&
CanSavePresentation
(
LOAD_NORMAL
nullptr
nullptr
)
;
mLoadingURI
=
nullptr
;
Stop
(
)
;
(
void
)
FirePageHideNotification
(
!
mSavingOldViewer
)
;
if
(
mIsBeingDestroyed
)
{
return
NS_ERROR_DOCSHELL_DYING
;
}
}
mFiredUnloadEvent
=
false
;
nsCOMPtr
<
nsIDocumentLoaderFactory
>
docFactory
=
nsContentUtils
:
:
FindInternalContentViewer
(
NS_LITERAL_CSTRING
(
"
text
/
html
"
)
)
;
if
(
docFactory
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
storagePrincipal
;
uint32_t
sandboxFlags
=
mBrowsingContext
-
>
GetSandboxFlags
(
)
;
if
(
sandboxFlags
&
SANDBOXED_ORIGIN
)
{
if
(
aPrincipal
)
{
principal
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
aPrincipal
)
;
}
else
{
principal
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
this
)
;
}
storagePrincipal
=
principal
;
}
else
{
principal
=
aPrincipal
;
storagePrincipal
=
aStoragePrincipal
;
}
MaybeCreateInitialClientSource
(
principal
)
;
blankDoc
=
nsContentDLF
:
:
CreateBlankDocument
(
mLoadGroup
principal
storagePrincipal
this
)
;
if
(
blankDoc
)
{
if
(
aCSP
)
{
RefPtr
<
nsCSPContext
>
cspToInherit
=
new
nsCSPContext
(
)
;
cspToInherit
-
>
InitFromOther
(
static_cast
<
nsCSPContext
*
>
(
aCSP
)
)
;
blankDoc
-
>
SetCsp
(
cspToInherit
)
;
}
blankDoc
-
>
SetBaseURI
(
aBaseURI
)
;
blankDoc
-
>
SetSandboxFlags
(
sandboxFlags
)
;
docFactory
-
>
CreateInstanceForDocument
(
NS_ISUPPORTS_CAST
(
nsIDocShell
*
this
)
blankDoc
"
view
"
getter_AddRefs
(
viewer
)
)
;
if
(
viewer
)
{
viewer
-
>
SetContainer
(
this
)
;
rv
=
Embed
(
viewer
aActor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SetCurrentURI
(
blankDoc
-
>
GetDocumentURI
(
)
nullptr
true
0
)
;
rv
=
mIsBeingDestroyed
?
NS_ERROR_NOT_AVAILABLE
:
NS_OK
;
}
}
}
SetHistoryEntryAndUpdateBC
(
Nothing
(
)
Some
(
nullptr
)
)
;
if
(
!
hadTiming
)
{
mTiming
=
nullptr
;
mBlankTiming
=
true
;
}
return
rv
;
}
NS_IMETHODIMP
nsDocShell
:
:
CreateAboutBlankContentViewer
(
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aStoragePrincipal
nsIContentSecurityPolicy
*
aCSP
)
{
return
CreateAboutBlankContentViewer
(
aPrincipal
aStoragePrincipal
aCSP
nullptr
)
;
}
nsresult
nsDocShell
:
:
CreateContentViewerForActor
(
WindowGlobalChild
*
aWindowActor
)
{
MOZ_ASSERT
(
aWindowActor
)
;
nsresult
rv
=
CreateAboutBlankContentViewer
(
aWindowActor
-
>
DocumentPrincipal
(
)
aWindowActor
-
>
DocumentPrincipal
(
)
nullptr
nullptr
true
true
aWindowActor
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
RefPtr
<
Document
>
doc
(
GetDocument
(
)
)
;
MOZ_ASSERT
(
doc
"
Should
have
a
document
if
CreateAboutBlankContentViewer
succeeded
"
)
;
MOZ_ASSERT
(
doc
-
>
GetOwnerGlobal
(
)
=
=
aWindowActor
-
>
GetWindowGlobal
(
)
"
New
document
should
be
in
the
same
global
as
our
actor
"
)
;
doc
-
>
SetIsInitialDocument
(
true
)
;
}
return
rv
;
}
bool
nsDocShell
:
:
CanSavePresentation
(
uint32_t
aLoadType
nsIRequest
*
aNewRequest
Document
*
aNewDocument
)
{
if
(
!
mOSHE
)
{
return
false
;
}
nsCOMPtr
<
nsIContentViewer
>
viewer
=
mOSHE
-
>
GetContentViewer
(
)
;
if
(
viewer
)
{
NS_WARNING
(
"
mOSHE
already
has
a
content
viewer
!
"
)
;
return
false
;
}
if
(
aLoadType
!
=
LOAD_NORMAL
&
&
aLoadType
!
=
LOAD_HISTORY
&
&
aLoadType
!
=
LOAD_LINK
&
&
aLoadType
!
=
LOAD_STOP_CONTENT
&
&
aLoadType
!
=
LOAD_STOP_CONTENT_AND_REPLACE
&
&
aLoadType
!
=
LOAD_ERROR_PAGE
)
{
return
false
;
}
if
(
!
mOSHE
-
>
GetSaveLayoutStateFlag
(
)
)
{
return
false
;
}
if
(
!
mScriptGlobal
|
|
mScriptGlobal
-
>
IsLoading
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Blocked
due
to
document
still
loading
"
)
)
;
return
false
;
}
if
(
mScriptGlobal
-
>
WouldReuseInnerWindow
(
aNewDocument
)
)
{
return
false
;
}
if
(
nsSHistory
:
:
GetMaxTotalViewers
(
)
=
=
0
)
{
return
false
;
}
if
(
mBrowsingContext
-
>
GetParent
(
)
)
{
return
false
;
}
RefPtr
<
Document
>
doc
=
mScriptGlobal
-
>
GetExtantDoc
(
)
;
uint16_t
bfCacheCombo
=
0
;
bool
canSavePresentation
=
doc
-
>
CanSavePresentation
(
aNewRequest
bfCacheCombo
)
;
MOZ_ASSERT_IF
(
canSavePresentation
bfCacheCombo
=
=
0
)
;
if
(
canSavePresentation
&
&
doc
-
>
IsTopLevelContentDocument
(
)
)
{
auto
*
browsingContextGroup
=
mBrowsingContext
-
>
Group
(
)
;
nsTArray
<
RefPtr
<
BrowsingContext
>
>
&
topLevelContext
=
browsingContextGroup
-
>
Toplevels
(
)
;
for
(
const
auto
&
browsingContext
:
topLevelContext
)
{
if
(
browsingContext
!
=
mBrowsingContext
)
{
bfCacheCombo
|
=
BFCacheStatus
:
:
NOT_ONLY_TOPLEVEL_IN_BCG
;
break
;
}
}
}
ReportBFCacheComboTelemetry
(
bfCacheCombo
)
;
return
doc
&
&
canSavePresentation
;
}
void
nsDocShell
:
:
ReportBFCacheComboTelemetry
(
uint16_t
aCombo
)
{
switch
(
aCombo
)
{
case
BFCACHE_SUCCESS
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
BFCache_Success
)
;
break
;
case
SUCCESS_NOT_ONLY_TOPLEVEL
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
BFCache_Success
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Success_Not_Toplevel
)
;
break
;
case
UNLOAD
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Unload
)
;
break
;
case
UNLOAD_REQUEST
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Unload_Req
)
;
break
;
case
REQUEST
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Req
)
;
break
;
case
UNLOAD_REQUEST_PEER
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Unload_Req_Peer
)
;
break
;
case
UNLOAD_REQUEST_PEER_MSE
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Unload_Req_Peer_MSE
)
;
break
;
case
UNLOAD_REQUEST_MSE
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Unload_Req_MSE
)
;
break
;
case
SUSPENDED_UNLOAD_REQUEST_PEER
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
SPD_Unload_Req_Peer
)
;
break
;
case
REMOTE_SUBFRAMES
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Remote_Subframes
)
;
break
;
default
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Other
)
;
break
;
}
}
;
void
nsDocShell
:
:
ReattachEditorToWindow
(
nsISHEntry
*
aSHEntry
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
NS_ASSERTION
(
!
mEditorData
"
Why
reattach
an
editor
when
we
already
have
one
?
"
)
;
NS_ASSERTION
(
aSHEntry
&
&
aSHEntry
-
>
HasDetachedEditor
(
)
"
Reattaching
when
there
'
s
not
a
detached
editor
.
"
)
;
if
(
mEditorData
|
|
!
aSHEntry
)
{
return
;
}
mEditorData
=
WrapUnique
(
aSHEntry
-
>
ForgetEditorData
(
)
)
;
if
(
mEditorData
)
{
#
ifdef
DEBUG
nsresult
rv
=
#
endif
mEditorData
-
>
ReattachToWindow
(
this
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
reattach
editing
session
"
)
;
}
}
void
nsDocShell
:
:
DetachEditorFromWindow
(
)
{
if
(
!
mEditorData
|
|
mEditorData
-
>
WaitingForLoad
(
)
)
{
return
;
}
NS_ASSERTION
(
!
mOSHE
|
|
!
mOSHE
-
>
HasDetachedEditor
(
)
"
Detaching
editor
when
it
'
s
already
detached
.
"
)
;
nsresult
res
=
mEditorData
-
>
DetachFromWindow
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
res
)
"
Failed
to
detach
editor
"
)
;
if
(
NS_SUCCEEDED
(
res
)
)
{
if
(
mOSHE
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
|
|
!
mOSHE
-
>
HasDetachedEditor
(
)
"
We
should
not
set
the
editor
data
again
once
after
we
"
"
detached
the
editor
data
during
destroying
this
docshell
"
)
;
mOSHE
-
>
SetEditorData
(
mEditorData
.
release
(
)
)
;
}
else
{
mEditorData
=
nullptr
;
}
}
#
ifdef
DEBUG
{
bool
isEditable
;
GetEditable
(
&
isEditable
)
;
NS_ASSERTION
(
!
isEditable
"
Window
is
still
editable
after
detaching
editor
.
"
)
;
}
#
endif
}
nsresult
nsDocShell
:
:
CaptureState
(
)
{
if
(
!
mOSHE
|
|
mOSHE
=
=
mLSHE
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mScriptGlobal
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISupports
>
windowState
=
mScriptGlobal
-
>
SaveWindowState
(
)
;
NS_ENSURE_TRUE
(
windowState
NS_ERROR_FAILURE
)
;
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
gPageCacheLog
LogLevel
:
:
Debug
)
)
)
{
nsCOMPtr
<
nsIURI
>
uri
=
mOSHE
-
>
GetURI
(
)
;
nsAutoCString
spec
;
if
(
uri
)
{
uri
-
>
GetSpec
(
spec
)
;
}
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Debug
(
"
Saving
presentation
into
session
history
URI
:
%
s
"
spec
.
get
(
)
)
)
;
}
mOSHE
-
>
SetWindowState
(
windowState
)
;
mOSHE
-
>
SetRefreshURIList
(
mSavedRefreshURIList
)
;
if
(
mContentViewer
)
{
nsIntRect
bounds
;
mContentViewer
-
>
GetBounds
(
bounds
)
;
mOSHE
-
>
SetViewerBounds
(
bounds
)
;
}
mOSHE
-
>
ClearChildShells
(
)
;
uint32_t
childCount
=
mChildList
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
childShell
=
do_QueryInterface
(
ChildAt
(
i
)
)
;
NS_ASSERTION
(
childShell
"
null
child
shell
"
)
;
mOSHE
-
>
AddChildShell
(
childShell
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
RestorePresentationEvent
:
:
Run
(
)
{
if
(
mDocShell
&
&
NS_FAILED
(
mDocShell
-
>
RestoreFromHistory
(
)
)
)
{
NS_WARNING
(
"
RestoreFromHistory
failed
"
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
BeginRestore
(
nsIContentViewer
*
aContentViewer
bool
aTop
)
{
nsresult
rv
;
if
(
!
aContentViewer
)
{
rv
=
EnsureContentViewer
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aContentViewer
=
mContentViewer
;
}
RefPtr
<
Document
>
doc
=
aContentViewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
nsIChannel
*
channel
=
doc
-
>
GetChannel
(
)
;
if
(
channel
)
{
mEODForCurrentDocument
=
false
;
mIsRestoringDocument
=
true
;
mLoadGroup
-
>
AddRequest
(
channel
nullptr
)
;
mIsRestoringDocument
=
false
;
}
}
if
(
!
aTop
)
{
mFiredUnloadEvent
=
false
;
rv
=
BeginRestoreChildren
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
BeginRestoreChildren
(
)
{
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
child
=
do_QueryObject
(
iter
.
GetNext
(
)
)
;
if
(
child
)
{
nsresult
rv
=
child
-
>
BeginRestore
(
nullptr
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
FinishRestore
(
)
{
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
child
=
do_QueryObject
(
iter
.
GetNext
(
)
)
;
if
(
child
)
{
child
-
>
FinishRestore
(
)
;
}
}
if
(
mOSHE
&
&
mOSHE
-
>
HasDetachedEditor
(
)
)
{
ReattachEditorToWindow
(
mOSHE
)
;
}
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
if
(
doc
)
{
nsIChannel
*
channel
=
doc
-
>
GetChannel
(
)
;
if
(
channel
)
{
mIsRestoringDocument
=
true
;
mLoadGroup
-
>
RemoveRequest
(
channel
nullptr
NS_OK
)
;
mIsRestoringDocument
=
false
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetRestoringDocument
(
bool
*
aRestoring
)
{
*
aRestoring
=
mIsRestoringDocument
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
RestorePresentation
(
nsISHEntry
*
aSHEntry
bool
*
aRestoring
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
NS_ASSERTION
(
mLoadType
&
LOAD_CMD_HISTORY
"
RestorePresentation
should
only
be
called
for
history
loads
"
)
;
nsCOMPtr
<
nsIContentViewer
>
viewer
=
aSHEntry
-
>
GetContentViewer
(
)
;
nsAutoCString
spec
;
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
gPageCacheLog
LogLevel
:
:
Debug
)
)
)
{
nsCOMPtr
<
nsIURI
>
uri
=
aSHEntry
-
>
GetURI
(
)
;
if
(
uri
)
{
uri
-
>
GetSpec
(
spec
)
;
}
}
*
aRestoring
=
false
;
if
(
!
viewer
)
{
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Debug
(
"
no
saved
presentation
for
uri
:
%
s
"
spec
.
get
(
)
)
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShell
>
container
;
viewer
-
>
GetContainer
(
getter_AddRefs
(
container
)
)
;
if
(
!
:
:
SameCOMIdentity
(
container
GetAsSupports
(
this
)
)
)
{
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Debug
(
"
No
valid
container
clearing
presentation
"
)
)
;
aSHEntry
-
>
SetContentViewer
(
nullptr
)
;
return
NS_ERROR_FAILURE
;
}
NS_ASSERTION
(
mContentViewer
!
=
viewer
"
Restoring
existing
presentation
"
)
;
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Debug
(
"
restoring
presentation
from
session
history
:
%
s
"
spec
.
get
(
)
)
)
;
SetHistoryEntryAndUpdateBC
(
Some
(
aSHEntry
)
Nothing
(
)
)
;
NS_ASSERTION
(
!
mRestorePresentationEvent
.
IsPending
(
)
"
should
only
have
one
RestorePresentationEvent
"
)
;
mRestorePresentationEvent
.
Revoke
(
)
;
RefPtr
<
RestorePresentationEvent
>
evt
=
new
RestorePresentationEvent
(
this
)
;
nsresult
rv
=
DispatchToTabGroup
(
TaskCategory
:
:
Other
RefPtr
<
RestorePresentationEvent
>
(
evt
)
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mRestorePresentationEvent
=
evt
.
get
(
)
;
*
aRestoring
=
true
;
}
return
rv
;
}
namespace
{
class
MOZ_STACK_CLASS
PresentationEventForgetter
{
public
:
explicit
PresentationEventForgetter
(
nsRevocableEventPtr
<
nsDocShell
:
:
RestorePresentationEvent
>
&
aRestorePresentationEvent
)
:
mRestorePresentationEvent
(
aRestorePresentationEvent
)
mEvent
(
aRestorePresentationEvent
.
get
(
)
)
{
}
~
PresentationEventForgetter
(
)
{
Forget
(
)
;
}
void
Forget
(
)
{
if
(
mRestorePresentationEvent
.
get
(
)
=
=
mEvent
)
{
mRestorePresentationEvent
.
Forget
(
)
;
mEvent
=
nullptr
;
}
}
private
:
nsRevocableEventPtr
<
nsDocShell
:
:
RestorePresentationEvent
>
&
mRestorePresentationEvent
;
RefPtr
<
nsDocShell
:
:
RestorePresentationEvent
>
mEvent
;
}
;
}
bool
nsDocShell
:
:
SandboxFlagsImplyCookies
(
const
uint32_t
&
aSandboxFlags
)
{
return
(
aSandboxFlags
&
(
SANDBOXED_ORIGIN
|
SANDBOXED_SCRIPTS
)
)
=
=
0
;
}
nsresult
nsDocShell
:
:
RestoreFromHistory
(
)
{
MOZ_ASSERT
(
mRestorePresentationEvent
.
IsPending
(
)
)
;
PresentationEventForgetter
forgetter
(
mRestorePresentationEvent
)
;
if
(
!
mLSHE
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContentViewer
>
viewer
=
mLSHE
-
>
GetContentViewer
(
)
;
if
(
!
viewer
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mSavingOldViewer
)
{
RefPtr
<
Document
>
doc
=
viewer
-
>
GetDocument
(
)
;
nsIRequest
*
request
=
nullptr
;
if
(
doc
)
{
request
=
doc
-
>
GetChannel
(
)
;
}
mSavingOldViewer
=
CanSavePresentation
(
mLoadType
request
doc
)
;
}
nsCOMPtr
<
nsIContentViewer
>
oldCv
(
mContentViewer
)
;
nsCOMPtr
<
nsIContentViewer
>
newCv
(
viewer
)
;
float
textZoom
=
1
.
0f
;
float
pageZoom
=
1
.
0f
;
float
overrideDPPX
=
0
.
0f
;
bool
styleDisabled
=
false
;
if
(
oldCv
&
&
newCv
)
{
oldCv
-
>
GetTextZoom
(
&
textZoom
)
;
oldCv
-
>
GetFullZoom
(
&
pageZoom
)
;
oldCv
-
>
GetOverrideDPPX
(
&
overrideDPPX
)
;
oldCv
-
>
GetAuthorStyleDisabled
(
&
styleDisabled
)
;
}
nsCOMPtr
<
nsISHEntry
>
origLSHE
=
mLSHE
;
mLoadingURI
=
nullptr
;
FirePageHideNotification
(
!
mSavingOldViewer
)
;
if
(
mIsBeingDestroyed
)
{
return
NS_ERROR_DOCSHELL_DYING
;
}
if
(
mLSHE
!
=
origLSHE
)
{
return
NS_OK
;
}
RefPtr
<
RestorePresentationEvent
>
currentPresentationRestoration
=
mRestorePresentationEvent
.
get
(
)
;
Stop
(
)
;
NS_ENSURE_STATE
(
currentPresentationRestoration
=
=
mRestorePresentationEvent
.
get
(
)
)
;
BeginRestore
(
viewer
true
)
;
NS_ENSURE_STATE
(
currentPresentationRestoration
=
=
mRestorePresentationEvent
.
get
(
)
)
;
forgetter
.
Forget
(
)
;
mFiredUnloadEvent
=
false
;
mURIResultedInDocument
=
true
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
rootSH
)
{
mPreviousEntryIndex
=
rootSH
-
>
Index
(
)
;
rootSH
-
>
LegacySHistory
(
)
-
>
UpdateIndex
(
)
;
mLoadedEntryIndex
=
rootSH
-
>
Index
(
)
;
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Verbose
(
"
Previous
index
:
%
d
Loaded
index
:
%
d
"
mPreviousEntryIndex
mLoadedEntryIndex
)
)
;
}
PersistLayoutHistoryState
(
)
;
nsresult
rv
;
if
(
mContentViewer
)
{
if
(
mSavingOldViewer
&
&
NS_FAILED
(
CaptureState
(
)
)
)
{
if
(
mOSHE
)
{
mOSHE
-
>
SyncPresentationState
(
)
;
}
mSavingOldViewer
=
false
;
}
}
mSavedRefreshURIList
=
nullptr
;
if
(
mContentViewer
)
{
nsCOMPtr
<
nsIContentViewer
>
previousViewer
=
mContentViewer
-
>
GetPreviousViewer
(
)
;
if
(
previousViewer
)
{
mContentViewer
-
>
SetPreviousViewer
(
nullptr
)
;
previousViewer
-
>
Destroy
(
)
;
}
}
nsView
*
rootViewSibling
=
nullptr
;
nsView
*
rootViewParent
=
nullptr
;
nsIntRect
newBounds
(
0
0
0
0
)
;
PresShell
*
oldPresShell
=
GetPresShell
(
)
;
if
(
oldPresShell
)
{
nsViewManager
*
vm
=
oldPresShell
-
>
GetViewManager
(
)
;
if
(
vm
)
{
nsView
*
oldRootView
=
vm
-
>
GetRootView
(
)
;
if
(
oldRootView
)
{
rootViewSibling
=
oldRootView
-
>
GetNextSibling
(
)
;
rootViewParent
=
oldRootView
-
>
GetParent
(
)
;
mContentViewer
-
>
GetBounds
(
newBounds
)
;
}
}
}
nsCOMPtr
<
nsIContent
>
container
;
RefPtr
<
Document
>
sibling
;
if
(
rootViewParent
&
&
rootViewParent
-
>
GetParent
(
)
)
{
nsIFrame
*
frame
=
rootViewParent
-
>
GetParent
(
)
-
>
GetFrame
(
)
;
container
=
frame
?
frame
-
>
GetContent
(
)
:
nullptr
;
}
if
(
rootViewSibling
)
{
nsIFrame
*
frame
=
rootViewSibling
-
>
GetFrame
(
)
;
sibling
=
frame
?
frame
-
>
PresShell
(
)
-
>
GetDocument
(
)
:
nullptr
;
}
if
(
mContentViewer
)
{
mContentViewer
-
>
Close
(
mSavingOldViewer
?
mOSHE
.
get
(
)
:
nullptr
)
;
viewer
-
>
SetPreviousViewer
(
mContentViewer
)
;
}
if
(
mOSHE
&
&
(
!
mContentViewer
|
|
!
mSavingOldViewer
)
)
{
mOSHE
-
>
SyncPresentationState
(
)
;
}
mContentViewer
=
nullptr
;
if
(
!
mWillChangeProcess
)
{
mBrowsingContext
-
>
CacheChildren
(
)
;
}
DestroyChildren
(
)
;
mContentViewer
.
swap
(
viewer
)
;
nsCOMPtr
<
nsISupports
>
windowState
=
mLSHE
-
>
GetWindowState
(
)
;
mLSHE
-
>
SetWindowState
(
nullptr
)
;
bool
sticky
=
mLSHE
-
>
GetSticky
(
)
;
RefPtr
<
Document
>
document
=
mContentViewer
-
>
GetDocument
(
)
;
nsCOMArray
<
nsIDocShellTreeItem
>
childShells
;
int32_t
i
=
0
;
nsCOMPtr
<
nsIDocShellTreeItem
>
child
;
while
(
NS_SUCCEEDED
(
mLSHE
-
>
ChildShellAt
(
i
+
+
getter_AddRefs
(
child
)
)
)
&
&
child
)
{
childShells
.
AppendObject
(
child
)
;
}
nsIntRect
oldBounds
(
0
0
0
0
)
;
mLSHE
-
>
GetViewerBounds
(
oldBounds
)
;
nsCOMPtr
<
nsIMutableArray
>
refreshURIList
=
mLSHE
-
>
GetRefreshURIList
(
)
;
mIsRestoringDocument
=
true
;
rv
=
mContentViewer
-
>
Open
(
windowState
mLSHE
)
;
mIsRestoringDocument
=
false
;
UniquePtr
<
nsDocShellEditorData
>
data
(
mLSHE
-
>
ForgetEditorData
(
)
)
;
mLSHE
-
>
SetContentViewer
(
nullptr
)
;
mEODForCurrentDocument
=
false
;
mLSHE
-
>
SetEditorData
(
data
.
release
(
)
)
;
#
ifdef
DEBUG
{
nsCOMPtr
<
nsIMutableArray
>
refreshURIs
=
mLSHE
-
>
GetRefreshURIList
(
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
childShell
;
mLSHE
-
>
ChildShellAt
(
0
getter_AddRefs
(
childShell
)
)
;
NS_ASSERTION
(
!
refreshURIs
&
&
!
childShell
"
SHEntry
should
have
cleared
presentation
state
"
)
;
}
#
endif
mContentViewer
-
>
SetSticky
(
sticky
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SetHistoryEntryAndUpdateBC
(
Nothing
(
)
Some
<
nsISHEntry
*
>
(
mLSHE
)
)
;
SetLayoutHistoryState
(
nullptr
)
;
mSavingOldViewer
=
false
;
mEODForCurrentDocument
=
false
;
if
(
+
+
gNumberOfDocumentsLoading
=
=
1
)
{
FavorPerformanceHint
(
true
)
;
}
if
(
oldCv
&
&
newCv
)
{
newCv
-
>
SetTextZoom
(
textZoom
)
;
newCv
-
>
SetFullZoom
(
pageZoom
)
;
newCv
-
>
SetOverrideDPPX
(
overrideDPPX
)
;
newCv
-
>
SetAuthorStyleDisabled
(
styleDisabled
)
;
}
if
(
document
)
{
RefPtr
<
nsDocShell
>
parent
=
GetInProcessParentDocshell
(
)
;
if
(
parent
)
{
RefPtr
<
Document
>
d
=
parent
-
>
GetDocument
(
)
;
if
(
d
)
{
if
(
d
-
>
EventHandlingSuppressed
(
)
)
{
document
-
>
SuppressEventHandling
(
d
-
>
EventHandlingSuppressed
(
)
)
;
}
}
}
nsCOMPtr
<
nsIURI
>
uri
=
origLSHE
-
>
GetURI
(
)
;
SetCurrentURI
(
uri
document
-
>
GetChannel
(
)
true
0
)
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
privWin
=
GetWindow
(
)
;
NS_ASSERTION
(
privWin
"
could
not
get
nsPIDOMWindow
interface
"
)
;
document
-
>
NotifyPossibleTitleChange
(
false
)
;
BrowsingContext
:
:
Children
contexts
(
childShells
.
Count
(
)
)
;
for
(
i
=
0
;
i
<
childShells
.
Count
(
)
;
+
+
i
)
{
nsIDocShellTreeItem
*
childItem
=
childShells
.
ObjectAt
(
i
)
;
nsCOMPtr
<
nsIDocShell
>
childShell
=
do_QueryInterface
(
childItem
)
;
bool
allowJavascript
;
childShell
-
>
GetAllowJavascript
(
&
allowJavascript
)
;
bool
allowRedirects
;
childShell
-
>
GetAllowMetaRedirects
(
&
allowRedirects
)
;
bool
allowSubframes
;
childShell
-
>
GetAllowSubframes
(
&
allowSubframes
)
;
bool
allowImages
;
childShell
-
>
GetAllowImages
(
&
allowImages
)
;
bool
allowMedia
=
childShell
-
>
GetAllowMedia
(
)
;
bool
allowDNSPrefetch
;
childShell
-
>
GetAllowDNSPrefetch
(
&
allowDNSPrefetch
)
;
bool
allowContentRetargeting
=
childShell
-
>
GetAllowContentRetargeting
(
)
;
bool
allowContentRetargetingOnChildren
=
childShell
-
>
GetAllowContentRetargetingOnChildren
(
)
;
uint32_t
defaultLoadFlags
;
childShell
-
>
GetDefaultLoadFlags
(
&
defaultLoadFlags
)
;
AddChild
(
childItem
)
;
contexts
.
AppendElement
(
childShell
-
>
GetBrowsingContext
(
)
)
;
childShell
-
>
SetAllowJavascript
(
allowJavascript
)
;
childShell
-
>
SetAllowMetaRedirects
(
allowRedirects
)
;
childShell
-
>
SetAllowSubframes
(
allowSubframes
)
;
childShell
-
>
SetAllowImages
(
allowImages
)
;
childShell
-
>
SetAllowMedia
(
allowMedia
)
;
childShell
-
>
SetAllowDNSPrefetch
(
allowDNSPrefetch
)
;
childShell
-
>
SetAllowContentRetargeting
(
allowContentRetargeting
)
;
childShell
-
>
SetAllowContentRetargetingOnChildren
(
allowContentRetargetingOnChildren
)
;
childShell
-
>
SetDefaultLoadFlags
(
defaultLoadFlags
)
;
rv
=
childShell
-
>
BeginRestore
(
nullptr
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
contexts
.
IsEmpty
(
)
)
{
mBrowsingContext
-
>
RestoreChildren
(
std
:
:
move
(
contexts
)
)
;
}
rv
=
privWin
-
>
RestoreWindowState
(
windowState
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
&
&
presShell
-
>
GetPresContext
(
)
-
>
DeviceContext
(
)
-
>
CheckDPIChange
(
)
)
{
presShell
-
>
BackingScaleFactorChanged
(
)
;
}
nsViewManager
*
newVM
=
presShell
?
presShell
-
>
GetViewManager
(
)
:
nullptr
;
nsView
*
newRootView
=
newVM
?
newVM
-
>
GetRootView
(
)
:
nullptr
;
if
(
container
)
{
nsSubDocumentFrame
*
subDocFrame
=
do_QueryFrame
(
container
-
>
GetPrimaryFrame
(
)
)
;
rootViewParent
=
subDocFrame
?
subDocFrame
-
>
EnsureInnerView
(
)
:
nullptr
;
}
else
{
rootViewParent
=
nullptr
;
}
if
(
sibling
&
&
sibling
-
>
GetPresShell
(
)
&
&
sibling
-
>
GetPresShell
(
)
-
>
GetViewManager
(
)
)
{
rootViewSibling
=
sibling
-
>
GetPresShell
(
)
-
>
GetViewManager
(
)
-
>
GetRootView
(
)
;
}
else
{
rootViewSibling
=
nullptr
;
}
if
(
rootViewParent
&
&
newRootView
&
&
newRootView
-
>
GetParent
(
)
!
=
rootViewParent
)
{
nsViewManager
*
parentVM
=
rootViewParent
-
>
GetViewManager
(
)
;
if
(
parentVM
)
{
parentVM
-
>
InsertChild
(
rootViewParent
newRootView
rootViewSibling
rootViewSibling
?
true
:
false
)
;
NS_ASSERTION
(
newRootView
-
>
GetNextSibling
(
)
=
=
rootViewSibling
"
error
in
InsertChild
"
)
;
}
}
nsCOMPtr
<
nsPIDOMWindowInner
>
privWinInner
=
privWin
-
>
GetCurrentInnerWindow
(
)
;
privWinInner
-
>
SyncStateFromParentWindow
(
)
;
privWinInner
-
>
Resume
(
)
;
privWinInner
-
>
GetPerformance
(
)
-
>
GetDOMTiming
(
)
-
>
NotifyRestoreStart
(
)
;
mRefreshURIList
=
refreshURIList
;
nsTObserverArray
<
nsDocLoader
*
>
:
:
ForwardIterator
iter
(
mChildList
)
;
while
(
iter
.
HasMore
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
child
=
do_QueryObject
(
iter
.
GetNext
(
)
)
;
if
(
child
)
{
child
-
>
ResumeRefreshURIs
(
)
;
}
}
if
(
newRootView
)
{
if
(
!
newBounds
.
IsEmpty
(
)
&
&
!
newBounds
.
IsEqualEdges
(
oldBounds
)
)
{
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Debug
(
"
resize
widget
(
%
d
%
d
%
d
%
d
)
"
newBounds
.
x
newBounds
.
y
newBounds
.
width
newBounds
.
height
)
)
;
mContentViewer
-
>
SetBounds
(
newBounds
)
;
}
else
{
nsIScrollableFrame
*
rootScrollFrame
=
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
rootScrollFrame
)
{
rootScrollFrame
-
>
PostScrolledAreaEventForCurrentArea
(
)
;
}
}
}
newRootView
=
rootViewSibling
=
rootViewParent
=
nullptr
;
newVM
=
nullptr
;
if
(
oldPresShell
&
&
presShell
&
&
presShell
-
>
IsUnderHiddenEmbedderElement
(
)
!
=
oldPresShell
-
>
IsUnderHiddenEmbedderElement
(
)
)
{
presShell
-
>
SetIsUnderHiddenEmbedderElement
(
oldPresShell
-
>
IsUnderHiddenEmbedderElement
(
)
)
;
}
nsDocShell
:
:
FinishRestore
(
)
;
if
(
presShell
)
{
presShell
-
>
Thaw
(
)
;
}
return
privWin
-
>
FireDelayedDOMEvents
(
)
;
}
nsresult
nsDocShell
:
:
CreateContentViewer
(
const
nsACString
&
aContentType
nsIRequest
*
aRequest
nsIStreamListener
*
*
aContentHandler
)
{
if
(
DocGroup
:
:
TryToLoadIframesInBackground
(
)
)
{
ResetToFirstLoad
(
)
;
}
*
aContentHandler
=
nullptr
;
if
(
!
mTreeOwner
|
|
mIsBeingDestroyed
)
{
return
NS_ERROR_DOCSHELL_DYING
;
}
NS_ASSERTION
(
mLoadGroup
"
Someone
ignored
return
from
Init
(
)
?
"
)
;
nsCOMPtr
<
nsIContentViewer
>
viewer
;
nsresult
rv
=
NewContentViewerObj
(
aContentType
aRequest
mLoadGroup
aContentHandler
getter_AddRefs
(
viewer
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mSavingOldViewer
)
{
RefPtr
<
Document
>
doc
=
viewer
-
>
GetDocument
(
)
;
mSavingOldViewer
=
CanSavePresentation
(
mLoadType
aRequest
doc
)
;
}
NS_ASSERTION
(
!
mLoadingURI
"
Re
-
entering
unload
?
"
)
;
nsCOMPtr
<
nsIChannel
>
aOpenedChannel
=
do_QueryInterface
(
aRequest
)
;
if
(
aOpenedChannel
)
{
aOpenedChannel
-
>
GetURI
(
getter_AddRefs
(
mLoadingURI
)
)
;
}
FirePageHideNotification
(
!
mSavingOldViewer
)
;
if
(
mIsBeingDestroyed
)
{
viewer
-
>
Stop
(
)
;
return
NS_ERROR_DOCSHELL_DYING
;
}
mLoadingURI
=
nullptr
;
mFiredUnloadEvent
=
false
;
mURIResultedInDocument
=
true
;
bool
errorOnLocationChangeNeeded
=
false
;
nsCOMPtr
<
nsIChannel
>
failedChannel
=
mFailedChannel
;
nsCOMPtr
<
nsIURI
>
failedURI
;
if
(
mLoadType
=
=
LOAD_ERROR_PAGE
)
{
mLoadType
=
mFailedLoadType
;
Document
*
doc
=
viewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
doc
-
>
SetFailedChannel
(
failedChannel
)
;
}
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
;
if
(
failedChannel
)
{
NS_GetFinalChannelURI
(
failedChannel
getter_AddRefs
(
failedURI
)
)
;
}
else
{
triggeringPrincipal
=
nsContentUtils
:
:
GetSystemPrincipal
(
)
;
}
if
(
!
failedURI
)
{
failedURI
=
mFailedURI
;
}
if
(
!
failedURI
)
{
NS_NewURI
(
getter_AddRefs
(
failedURI
)
"
about
:
blank
"
)
;
}
MOZ_ASSERT
(
failedURI
"
We
don
'
t
have
a
URI
for
history
APIs
.
"
)
;
mFailedChannel
=
nullptr
;
mFailedURI
=
nullptr
;
if
(
failedURI
)
{
errorOnLocationChangeNeeded
=
OnNewURI
(
failedURI
failedChannel
triggeringPrincipal
nullptr
nullptr
mLoadType
nullptr
false
false
false
)
;
}
if
(
mSessionHistory
&
&
!
mLSHE
)
{
int32_t
idx
=
mSessionHistory
-
>
LegacySHistory
(
)
-
>
GetRequestedIndex
(
)
;
if
(
idx
=
=
-
1
)
{
idx
=
mSessionHistory
-
>
Index
(
)
;
}
mSessionHistory
-
>
LegacySHistory
(
)
-
>
GetEntryAtIndex
(
idx
getter_AddRefs
(
mLSHE
)
)
;
}
mLoadType
=
LOAD_ERROR_PAGE
;
}
bool
onLocationChangeNeeded
=
OnLoadingSite
(
aOpenedChannel
false
)
;
nsCOMPtr
<
nsILoadGroup
>
currentLoadGroup
;
NS_ENSURE_SUCCESS
(
aOpenedChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
currentLoadGroup
)
)
NS_ERROR_FAILURE
)
;
if
(
currentLoadGroup
!
=
mLoadGroup
)
{
nsLoadFlags
loadFlags
=
0
;
aOpenedChannel
-
>
SetLoadGroup
(
mLoadGroup
)
;
aOpenedChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
loadFlags
|
=
nsIChannel
:
:
LOAD_DOCUMENT_URI
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aOpenedChannel
-
>
LoadInfo
(
)
;
if
(
SandboxFlagsImplyCookies
(
loadInfo
-
>
GetSandboxFlags
(
)
)
)
{
loadFlags
|
=
nsIRequest
:
:
LOAD_DOCUMENT_NEEDS_COOKIE
;
}
aOpenedChannel
-
>
SetLoadFlags
(
loadFlags
)
;
mLoadGroup
-
>
AddRequest
(
aRequest
nullptr
)
;
if
(
currentLoadGroup
)
{
currentLoadGroup
-
>
RemoveRequest
(
aRequest
nullptr
NS_BINDING_RETARGETED
)
;
}
aOpenedChannel
-
>
SetNotificationCallbacks
(
this
)
;
}
if
(
DocGroup
:
:
TryToLoadIframesInBackground
(
)
)
{
if
(
(
!
mContentViewer
|
|
GetDocument
(
)
-
>
IsInitialDocument
(
)
)
&
&
IsFrame
(
)
)
{
RefPtr
<
Document
>
newDoc
=
viewer
-
>
GetDocument
(
)
;
RefPtr
<
nsDocShell
>
parent
=
GetInProcessParentDocshell
(
)
;
nsCOMPtr
<
nsIPrincipal
>
parentPrincipal
=
parent
-
>
GetDocument
(
)
-
>
NodePrincipal
(
)
;
nsCOMPtr
<
nsIPrincipal
>
thisPrincipal
=
newDoc
-
>
NodePrincipal
(
)
;
SiteIdentifier
parentSite
;
SiteIdentifier
thisSite
;
nsresult
rv
=
BasePrincipal
:
:
Cast
(
parentPrincipal
)
-
>
GetSiteIdentifier
(
parentSite
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
BasePrincipal
:
:
Cast
(
thisPrincipal
)
-
>
GetSiteIdentifier
(
thisSite
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
parentSite
.
Equals
(
thisSite
)
)
{
#
ifdef
MOZ_GECKO_PROFILER
nsCOMPtr
<
nsIURI
>
prinURI
;
thisPrincipal
-
>
GetURI
(
getter_AddRefs
(
prinURI
)
)
;
nsPrintfCString
marker
(
"
Iframe
loaded
in
background
:
%
s
"
prinURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
profiler_add_text_marker
(
"
Background
Iframe
"
marker
JS
:
:
ProfilingCategoryPair
:
:
DOM
now
now
Nothing
(
)
)
;
#
endif
SetBackgroundLoadIframe
(
)
;
}
}
}
NS_ENSURE_SUCCESS
(
Embed
(
viewer
)
NS_ERROR_FAILURE
)
;
if
(
TreatAsBackgroundLoad
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
triggerParentCheckDocShell
=
NewRunnableMethod
(
"
nsDocShell
:
:
TriggerParentCheckDocShellIsEmpty
"
this
&
nsDocShell
:
:
TriggerParentCheckDocShellIsEmpty
)
;
nsresult
rv
=
NS_DispatchToCurrentThread
(
triggerParentCheckDocShell
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mSavedRefreshURIList
=
nullptr
;
mSavingOldViewer
=
false
;
mEODForCurrentDocument
=
false
;
nsCOMPtr
<
nsIMultiPartChannel
>
multiPartChannel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
multiPartChannel
)
{
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
if
(
Document
*
doc
=
presShell
-
>
GetDocument
(
)
)
{
uint32_t
partID
;
multiPartChannel
-
>
GetPartID
(
&
partID
)
;
doc
-
>
SetPartID
(
partID
)
;
}
}
}
if
(
+
+
gNumberOfDocumentsLoading
=
=
1
)
{
FavorPerformanceHint
(
true
)
;
}
if
(
errorOnLocationChangeNeeded
)
{
FireOnLocationChange
(
this
failedChannel
failedURI
LOCATION_CHANGE_ERROR_PAGE
)
;
}
else
if
(
onLocationChangeNeeded
)
{
uint32_t
locationFlags
=
(
mLoadType
&
LOAD_CMD_RELOAD
)
?
uint32_t
(
LOCATION_CHANGE_RELOAD
)
:
0
;
FireOnLocationChange
(
this
aRequest
mCurrentURI
locationFlags
)
;
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
NewContentViewerObj
(
const
nsACString
&
aContentType
nsIRequest
*
aRequest
nsILoadGroup
*
aLoadGroup
nsIStreamListener
*
*
aContentHandler
nsIContentViewer
*
*
aViewer
)
{
nsCOMPtr
<
nsIChannel
>
aOpenedChannel
=
do_QueryInterface
(
aRequest
)
;
nsCOMPtr
<
nsIDocumentLoaderFactory
>
docLoaderFactory
=
nsContentUtils
:
:
FindInternalContentViewer
(
aContentType
)
;
if
(
!
docLoaderFactory
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
docLoaderFactory
-
>
CreateInstance
(
"
view
"
aOpenedChannel
aLoadGroup
aContentType
this
nullptr
aContentHandler
aViewer
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
(
*
aViewer
)
-
>
SetContainer
(
this
)
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
SetupNewViewer
(
nsIContentViewer
*
aNewViewer
WindowGlobalChild
*
aWindowActor
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
int32_t
x
=
0
;
int32_t
y
=
0
;
int32_t
cx
=
0
;
int32_t
cy
=
0
;
DoGetPositionAndSize
(
&
x
&
y
&
cx
&
cy
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parentAsItem
;
NS_ENSURE_SUCCESS
(
GetInProcessSameTypeParent
(
getter_AddRefs
(
parentAsItem
)
)
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDocShell
>
parent
(
do_QueryInterface
(
parentAsItem
)
)
;
const
Encoding
*
forceCharset
=
nullptr
;
const
Encoding
*
hintCharset
=
nullptr
;
int32_t
hintCharsetSource
=
kCharsetUninitialized
;
float
textZoom
=
1
.
0
;
float
pageZoom
=
1
.
0
;
float
overrideDPPX
=
1
.
0
;
bool
styleDisabled
=
false
;
nsCOMPtr
<
nsIContentViewer
>
newCv
;
if
(
mContentViewer
|
|
parent
)
{
nsCOMPtr
<
nsIContentViewer
>
oldCv
;
if
(
mContentViewer
)
{
oldCv
=
mContentViewer
;
if
(
mSavingOldViewer
&
&
NS_FAILED
(
CaptureState
(
)
)
)
{
if
(
mOSHE
)
{
mOSHE
-
>
SyncPresentationState
(
)
;
}
mSavingOldViewer
=
false
;
}
}
else
{
parent
-
>
GetContentViewer
(
getter_AddRefs
(
oldCv
)
)
;
}
if
(
oldCv
)
{
newCv
=
aNewViewer
;
if
(
newCv
)
{
forceCharset
=
oldCv
-
>
GetForceCharset
(
)
;
hintCharset
=
oldCv
-
>
GetHintCharset
(
)
;
NS_ENSURE_SUCCESS
(
oldCv
-
>
GetHintCharacterSetSource
(
&
hintCharsetSource
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
oldCv
-
>
GetTextZoom
(
&
textZoom
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
oldCv
-
>
GetFullZoom
(
&
pageZoom
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
oldCv
-
>
GetOverrideDPPX
(
&
overrideDPPX
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
oldCv
-
>
GetAuthorStyleDisabled
(
&
styleDisabled
)
NS_ERROR_FAILURE
)
;
}
}
}
nscolor
bgcolor
=
NS_RGBA
(
0
0
0
0
)
;
bool
isActive
=
false
;
nsCOMPtr
<
nsIContentViewer
>
contentViewer
=
mContentViewer
;
if
(
contentViewer
)
{
contentViewer
-
>
Stop
(
)
;
if
(
PresShell
*
presShell
=
contentViewer
-
>
GetPresShell
(
)
)
{
bgcolor
=
presShell
-
>
GetCanvasBackground
(
)
;
isActive
=
presShell
-
>
IsActive
(
)
;
}
contentViewer
-
>
Close
(
mSavingOldViewer
?
mOSHE
.
get
(
)
:
nullptr
)
;
aNewViewer
-
>
SetPreviousViewer
(
contentViewer
)
;
}
if
(
mOSHE
&
&
(
!
mContentViewer
|
|
!
mSavingOldViewer
)
)
{
mOSHE
-
>
SyncPresentationState
(
)
;
}
mContentViewer
=
nullptr
;
mBrowsingContext
-
>
CacheChildren
(
)
;
DestroyChildren
(
)
;
mContentViewer
=
aNewViewer
;
nsCOMPtr
<
nsIWidget
>
widget
;
NS_ENSURE_SUCCESS
(
GetMainWidget
(
getter_AddRefs
(
widget
)
)
NS_ERROR_FAILURE
)
;
nsIntRect
bounds
(
x
y
cx
cy
)
;
mContentViewer
-
>
SetNavigationTiming
(
mTiming
)
;
if
(
NS_FAILED
(
mContentViewer
-
>
Init
(
widget
bounds
aWindowActor
)
)
)
{
mContentViewer
=
nullptr
;
NS_WARNING
(
"
ContentViewer
Initialization
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
newCv
)
{
newCv
-
>
SetForceCharset
(
forceCharset
)
;
newCv
-
>
SetHintCharset
(
hintCharset
)
;
NS_ENSURE_SUCCESS
(
newCv
-
>
SetHintCharacterSetSource
(
hintCharsetSource
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
newCv
-
>
SetTextZoom
(
textZoom
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
newCv
-
>
SetFullZoom
(
pageZoom
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
newCv
-
>
SetOverrideDPPX
(
overrideDPPX
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
newCv
-
>
SetAuthorStyleDisabled
(
styleDisabled
)
NS_ERROR_FAILURE
)
;
}
if
(
RefPtr
<
PresShell
>
presShell
=
mContentViewer
-
>
GetPresShell
(
)
)
{
presShell
-
>
SetCanvasBackground
(
bgcolor
)
;
if
(
isActive
)
{
presShell
-
>
SetIsActive
(
isActive
)
;
}
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
SetDocCurrentStateObj
(
nsISHEntry
*
aShEntry
)
{
NS_ENSURE_STATE
(
mContentViewer
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
document
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIStructuredCloneContainer
>
scContainer
;
if
(
aShEntry
)
{
scContainer
=
aShEntry
-
>
GetStateData
(
)
;
}
document
-
>
SetStateObject
(
scContainer
)
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
CheckLoadingPermissions
(
)
{
nsresult
rv
=
NS_OK
;
if
(
!
IsFrame
(
)
)
{
return
rv
;
}
if
(
!
nsContentUtils
:
:
GetCurrentJSContext
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
item
(
this
)
;
do
{
nsCOMPtr
<
nsIScriptGlobalObject
>
sgo
=
do_GetInterface
(
item
)
;
nsCOMPtr
<
nsIScriptObjectPrincipal
>
sop
(
do_QueryInterface
(
sgo
)
)
;
nsIPrincipal
*
p
;
if
(
!
sop
|
|
!
(
p
=
sop
-
>
GetPrincipal
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
nsContentUtils
:
:
SubjectPrincipal
(
)
-
>
Subsumes
(
p
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
tmp
;
item
-
>
GetInProcessSameTypeParent
(
getter_AddRefs
(
tmp
)
)
;
item
.
swap
(
tmp
)
;
}
while
(
item
)
;
return
NS_ERROR_DOM_PROP_ACCESS_DENIED
;
}
void
nsDocShell
:
:
CopyFavicon
(
nsIURI
*
aOldURI
nsIURI
*
aNewURI
nsIPrincipal
*
aLoadingPrincipal
bool
aInPrivateBrowsing
)
{
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
contentChild
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
if
(
contentChild
)
{
contentChild
-
>
SendCopyFavicon
(
aOldURI
aNewURI
IPC
:
:
Principal
(
aLoadingPrincipal
)
aInPrivateBrowsing
)
;
}
return
;
}
#
ifdef
MOZ_PLACES
nsCOMPtr
<
nsIFaviconService
>
favSvc
=
do_GetService
(
"
mozilla
.
org
/
browser
/
favicon
-
service
;
1
"
)
;
if
(
favSvc
)
{
favSvc
-
>
CopyFavicons
(
aOldURI
aNewURI
aInPrivateBrowsing
?
nsIFaviconService
:
:
FAVICON_LOAD_PRIVATE
:
nsIFaviconService
:
:
FAVICON_LOAD_NON_PRIVATE
nullptr
)
;
}
#
endif
}
class
InternalLoadEvent
:
public
Runnable
{
public
:
InternalLoadEvent
(
nsDocShell
*
aDocShell
nsDocShellLoadState
*
aLoadState
)
:
mozilla
:
:
Runnable
(
"
InternalLoadEvent
"
)
mDocShell
(
aDocShell
)
mLoadState
(
aLoadState
)
{
mLoadState
-
>
SetTarget
(
EmptyString
(
)
)
;
mLoadState
-
>
SetFileName
(
VoidString
(
)
)
;
}
NS_IMETHOD
Run
(
)
override
{
#
ifndef
ANDROID
MOZ_ASSERT
(
mLoadState
-
>
TriggeringPrincipal
(
)
"
InternalLoadEvent
:
Should
always
have
a
principal
here
"
)
;
#
endif
return
mDocShell
-
>
InternalLoad
(
mLoadState
nullptr
nullptr
)
;
}
private
:
RefPtr
<
nsDocShell
>
mDocShell
;
RefPtr
<
nsDocShellLoadState
>
mLoadState
;
}
;
bool
nsDocShell
:
:
JustStartedNetworkLoad
(
)
{
return
mDocumentRequest
&
&
mDocumentRequest
!
=
GetCurrentDocChannel
(
)
;
}
nsresult
nsDocShell
:
:
MaybeHandleLoadDelegate
(
nsDocShellLoadState
*
aLoadState
uint32_t
aWindowType
bool
*
aDidHandleLoad
)
{
MOZ_ASSERT
(
aLoadState
)
;
MOZ_ASSERT
(
aDidHandleLoad
)
;
MOZ_ASSERT
(
aWindowType
=
=
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
|
|
aWindowType
=
=
nsIBrowserDOMWindow
:
:
OPEN_CURRENTWINDOW
)
;
*
aDidHandleLoad
=
false
;
if
(
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_BYPASS_LOAD_URI_DELEGATE
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsILoadURIDelegate
>
loadURIDelegate
=
GetLoadURIDelegate
(
)
;
if
(
!
loadURIDelegate
|
|
aLoadState
-
>
LoadType
(
)
=
=
LOAD_ERROR_PAGE
)
{
return
NS_OK
;
}
Document
*
doc
=
mContentViewer
?
mContentViewer
-
>
GetDocument
(
)
:
nullptr
;
const
bool
isDocumentAuxSandboxed
=
doc
&
&
(
doc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_AUXILIARY_NAVIGATION
)
;
if
(
aWindowType
=
=
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
&
&
isDocumentAuxSandboxed
)
{
*
aDidHandleLoad
=
true
;
return
NS_ERROR_DOM_INVALID_ACCESS_ERR
;
}
return
loadURIDelegate
-
>
LoadURI
(
aLoadState
-
>
URI
(
)
aWindowType
aLoadState
-
>
LoadFlags
(
)
aLoadState
-
>
TriggeringPrincipal
(
)
aDidHandleLoad
)
;
}
uint32_t
nsDocShell
:
:
DetermineContentType
(
)
{
if
(
!
IsFrame
(
)
)
{
return
nsIContentPolicy
:
:
TYPE_DOCUMENT
;
}
nsCOMPtr
<
Element
>
requestingElement
=
mScriptGlobal
-
>
GetFrameElementInternal
(
)
;
if
(
requestingElement
)
{
return
requestingElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
iframe
)
?
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
:
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME
;
}
return
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
;
}
nsresult
nsDocShell
:
:
PerformRetargeting
(
nsDocShellLoadState
*
aLoadState
nsIDocShell
*
*
aDocShell
nsIRequest
*
*
aRequest
)
{
MOZ_ASSERT
(
aLoadState
"
need
a
load
state
!
"
)
;
MOZ_ASSERT
(
!
aLoadState
-
>
Target
(
)
.
IsEmpty
(
)
"
should
have
a
target
here
!
"
)
;
nsresult
rv
=
NS_OK
;
RefPtr
<
BrowsingContext
>
targetContext
;
bool
allowNamedTarget
=
!
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_NO_OPENER
)
|
|
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER
)
;
if
(
allowNamedTarget
|
|
aLoadState
-
>
Target
(
)
.
LowerCaseEqualsLiteral
(
"
_self
"
)
|
|
aLoadState
-
>
Target
(
)
.
LowerCaseEqualsLiteral
(
"
_parent
"
)
|
|
aLoadState
-
>
Target
(
)
.
LowerCaseEqualsLiteral
(
"
_top
"
)
)
{
targetContext
=
mBrowsingContext
-
>
FindWithName
(
aLoadState
-
>
Target
(
)
false
)
;
}
if
(
!
targetContext
)
{
nsISupports
*
requestingContext
=
nullptr
;
if
(
XRE_IsContentProcess
(
)
)
{
requestingContext
=
ToSupports
(
mScriptGlobal
)
;
}
else
{
nsCOMPtr
<
Element
>
requestingElement
=
mScriptGlobal
-
>
GetFrameElementInternal
(
)
;
requestingContext
=
requestingElement
;
}
nsCOMPtr
<
nsILoadInfo
>
secCheckLoadInfo
=
new
LoadInfo
(
mScriptGlobal
aLoadState
-
>
TriggeringPrincipal
(
)
requestingContext
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
0
)
;
secCheckLoadInfo
-
>
SetSkipContentPolicyCheckForWebRequest
(
true
)
;
int16_t
shouldLoad
=
nsIContentPolicy
:
:
ACCEPT
;
rv
=
NS_CheckContentLoadPolicy
(
aLoadState
-
>
URI
(
)
secCheckLoadInfo
EmptyCString
(
)
&
shouldLoad
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_CP_REJECTED
(
shouldLoad
)
)
{
if
(
NS_SUCCEEDED
(
rv
)
&
&
shouldLoad
=
=
nsIContentPolicy
:
:
REJECT_TYPE
)
{
return
NS_ERROR_CONTENT_BLOCKED_SHOW_ALT
;
}
return
NS_ERROR_CONTENT_BLOCKED
;
}
}
if
(
!
targetContext
|
|
(
targetContext
=
=
mBrowsingContext
)
)
{
bool
handled
;
rv
=
MaybeHandleLoadDelegate
(
aLoadState
targetContext
?
nsIBrowserDOMWindow
:
:
OPEN_CURRENTWINDOW
:
nsIBrowserDOMWindow
:
:
OPEN_NEWWINDOW
&
handled
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
handled
)
{
return
NS_OK
;
}
}
aLoadState
-
>
UnsetLoadFlag
(
INTERNAL_LOAD_FLAGS_INHERIT_PRINCIPAL
)
;
if
(
!
targetContext
)
{
NS_ENSURE_TRUE
(
mContentViewer
NS_ERROR_FAILURE
)
;
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
;
const
bool
isDocumentAuxSandboxed
=
doc
&
&
(
doc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_AUXILIARY_NAVIGATION
)
;
if
(
isDocumentAuxSandboxed
)
{
return
NS_ERROR_DOM_INVALID_ACCESS_ERR
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetWindow
(
)
;
NS_ENSURE_TRUE
(
win
NS_ERROR_NOT_AVAILABLE
)
;
RefPtr
<
BrowsingContext
>
newBC
;
nsAutoCString
spec
;
aLoadState
-
>
URI
(
)
-
>
GetSpec
(
spec
)
;
if
(
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_NO_OPENER
)
)
{
MOZ_ASSERT
(
!
aLoadState
-
>
LoadReplace
(
)
)
;
MOZ_ASSERT
(
aLoadState
-
>
PrincipalToInherit
(
)
=
=
aLoadState
-
>
TriggeringPrincipal
(
)
)
;
MOZ_ASSERT
(
aLoadState
-
>
LoadFlags
(
)
=
=
INTERNAL_LOAD_FLAGS_NO_OPENER
|
|
aLoadState
-
>
LoadFlags
(
)
=
=
(
INTERNAL_LOAD_FLAGS_NO_OPENER
|
INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER
)
)
;
MOZ_ASSERT
(
!
aLoadState
-
>
PostDataStream
(
)
)
;
MOZ_ASSERT
(
!
aLoadState
-
>
HeadersStream
(
)
)
;
MOZ_ASSERT
(
aLoadState
-
>
LoadType
(
)
=
=
LOAD_LINK
|
|
aLoadState
-
>
LoadType
(
)
=
=
LOAD_NORMAL_REPLACE
)
;
MOZ_ASSERT
(
!
aLoadState
-
>
SHEntry
(
)
)
;
MOZ_ASSERT
(
aLoadState
-
>
FirstParty
(
)
)
;
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
aLoadState
-
>
URI
(
)
)
;
loadState
-
>
SetReferrerInfo
(
aLoadState
-
>
GetReferrerInfo
(
)
)
;
loadState
-
>
SetOriginalURI
(
aLoadState
-
>
OriginalURI
(
)
)
;
Maybe
<
nsCOMPtr
<
nsIURI
>
>
resultPrincipalURI
;
aLoadState
-
>
GetMaybeResultPrincipalURI
(
resultPrincipalURI
)
;
loadState
-
>
SetMaybeResultPrincipalURI
(
resultPrincipalURI
)
;
loadState
-
>
SetKeepResultPrincipalURIIfSet
(
aLoadState
-
>
KeepResultPrincipalURIIfSet
(
)
)
;
loadState
-
>
SetTriggeringPrincipal
(
aLoadState
-
>
TriggeringPrincipal
(
)
)
;
loadState
-
>
SetCsp
(
aLoadState
-
>
Csp
(
)
)
;
loadState
-
>
SetInheritPrincipal
(
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_INHERIT_PRINCIPAL
)
)
;
loadState
-
>
SetPrincipalIsExplicit
(
true
)
;
loadState
-
>
SetLoadType
(
LOAD_LINK
)
;
loadState
-
>
SetForceAllowDataURI
(
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_FORCE_ALLOW_DATA_URI
)
)
;
rv
=
win
-
>
Open
(
NS_ConvertUTF8toUTF16
(
spec
)
aLoadState
-
>
Target
(
)
EmptyString
(
)
loadState
true
getter_AddRefs
(
newBC
)
)
;
MOZ_ASSERT
(
!
newBC
)
;
return
rv
;
}
rv
=
win
-
>
OpenNoNavigate
(
NS_ConvertUTF8toUTF16
(
spec
)
aLoadState
-
>
Target
(
)
EmptyString
(
)
getter_AddRefs
(
newBC
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
piNewWin
=
newBC
?
newBC
-
>
GetDOMWindow
(
)
:
nullptr
;
if
(
piNewWin
)
{
RefPtr
<
Document
>
newDoc
=
piNewWin
-
>
GetExtantDoc
(
)
;
if
(
!
newDoc
|
|
newDoc
-
>
IsInitialDocument
(
)
)
{
aLoadState
-
>
SetLoadFlag
(
INTERNAL_LOAD_FLAGS_FIRST_LOAD
)
;
}
}
if
(
newBC
)
{
targetContext
=
newBC
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
targetContext
rv
)
;
aLoadState
-
>
SetTarget
(
EmptyString
(
)
)
;
aLoadState
-
>
SetFileName
(
VoidString
(
)
)
;
return
targetContext
-
>
InternalLoad
(
mBrowsingContext
aLoadState
aDocShell
aRequest
)
;
}
bool
nsDocShell
:
:
IsSameDocumentNavigation
(
nsDocShellLoadState
*
aLoadState
SameDocumentNavigationState
&
aState
)
{
MOZ_ASSERT
(
aLoadState
)
;
if
(
!
(
aLoadState
-
>
LoadType
(
)
=
=
LOAD_NORMAL
|
|
aLoadState
-
>
LoadType
(
)
=
=
LOAD_STOP_CONTENT
|
|
LOAD_TYPE_HAS_FLAGS
(
aLoadState
-
>
LoadType
(
)
LOAD_FLAGS_REPLACE_HISTORY
)
|
|
aLoadState
-
>
LoadType
(
)
=
=
LOAD_HISTORY
|
|
aLoadState
-
>
LoadType
(
)
=
=
LOAD_LINK
)
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
currentURI
=
mCurrentURI
;
nsresult
rvURINew
=
aLoadState
-
>
URI
(
)
-
>
GetRef
(
aState
.
mNewHash
)
;
if
(
NS_SUCCEEDED
(
rvURINew
)
)
{
rvURINew
=
aLoadState
-
>
URI
(
)
-
>
GetHasRef
(
&
aState
.
mNewURIHasRef
)
;
}
if
(
currentURI
&
&
NS_SUCCEEDED
(
rvURINew
)
)
{
nsresult
rvURIOld
=
currentURI
-
>
GetRef
(
aState
.
mCurrentHash
)
;
if
(
NS_SUCCEEDED
(
rvURIOld
)
)
{
rvURIOld
=
currentURI
-
>
GetHasRef
(
&
aState
.
mCurrentURIHasRef
)
;
}
if
(
NS_SUCCEEDED
(
rvURIOld
)
)
{
if
(
NS_FAILED
(
currentURI
-
>
EqualsExceptRef
(
aLoadState
-
>
URI
(
)
&
aState
.
mSameExceptHashes
)
)
)
{
aState
.
mSameExceptHashes
=
false
;
}
}
}
if
(
!
aState
.
mSameExceptHashes
&
&
currentURI
&
&
NS_SUCCEEDED
(
rvURINew
)
)
{
nsCOMPtr
<
nsIURI
>
currentExposableURI
=
nsIOService
:
:
CreateExposableURI
(
currentURI
)
;
nsresult
rvURIOld
=
currentExposableURI
-
>
GetRef
(
aState
.
mCurrentHash
)
;
if
(
NS_SUCCEEDED
(
rvURIOld
)
)
{
rvURIOld
=
currentExposableURI
-
>
GetHasRef
(
&
aState
.
mCurrentURIHasRef
)
;
}
if
(
NS_SUCCEEDED
(
rvURIOld
)
)
{
if
(
NS_FAILED
(
currentExposableURI
-
>
EqualsExceptRef
(
aLoadState
-
>
URI
(
)
&
aState
.
mSameExceptHashes
)
)
)
{
aState
.
mSameExceptHashes
=
false
;
}
}
}
if
(
mOSHE
&
&
aLoadState
-
>
SHEntry
(
)
)
{
mOSHE
-
>
SharesDocumentWith
(
aLoadState
-
>
SHEntry
(
)
&
aState
.
mHistoryNavBetweenSameDoc
)
;
#
ifdef
DEBUG
if
(
aState
.
mHistoryNavBetweenSameDoc
)
{
nsCOMPtr
<
nsIInputStream
>
currentPostData
=
mOSHE
-
>
GetPostData
(
)
;
NS_ASSERTION
(
currentPostData
=
=
aLoadState
-
>
PostDataStream
(
)
"
Different
POST
data
for
entries
for
the
same
page
?
"
)
;
}
#
endif
}
bool
doSameDocumentNavigation
=
(
aState
.
mHistoryNavBetweenSameDoc
&
&
mOSHE
!
=
aLoadState
-
>
SHEntry
(
)
)
|
|
(
!
aLoadState
-
>
SHEntry
(
)
&
&
!
aLoadState
-
>
PostDataStream
(
)
&
&
aState
.
mSameExceptHashes
&
&
aState
.
mNewURIHasRef
)
;
return
doSameDocumentNavigation
;
}
nsresult
nsDocShell
:
:
HandleSameDocumentNavigation
(
nsDocShellLoadState
*
aLoadState
SameDocumentNavigationState
&
aState
)
{
#
ifdef
DEBUG
SameDocumentNavigationState
state
;
MOZ_ASSERT
(
IsSameDocumentNavigation
(
aLoadState
state
)
)
;
#
endif
nsCOMPtr
<
nsIURI
>
currentURI
=
mCurrentURI
;
nsPoint
scrollPos
=
GetCurScrollPos
(
)
;
AutoRestore
<
uint32_t
>
loadTypeResetter
(
mLoadType
)
;
if
(
JustStartedNetworkLoad
(
)
&
&
(
aLoadState
-
>
LoadType
(
)
&
LOAD_CMD_NORMAL
)
)
{
mLoadType
=
LOAD_NORMAL_REPLACE
;
}
else
{
mLoadType
=
aLoadState
-
>
LoadType
(
)
;
}
mURIResultedInDocument
=
true
;
nsCOMPtr
<
nsISHEntry
>
oldLSHE
=
mLSHE
;
SetHistoryEntryAndUpdateBC
(
Some
<
nsISHEntry
*
>
(
aLoadState
-
>
SHEntry
(
)
)
Nothing
(
)
)
;
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
doc
-
>
SetDocumentURI
(
aLoadState
-
>
URI
(
)
)
;
nsCOMPtr
<
nsIPrincipal
>
newURITriggeringPrincipal
newURIPrincipalToInherit
newURIStoragePrincipalToInherit
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
newCsp
;
if
(
mOSHE
)
{
newURITriggeringPrincipal
=
mOSHE
-
>
GetTriggeringPrincipal
(
)
;
newURIPrincipalToInherit
=
mOSHE
-
>
GetPrincipalToInherit
(
)
;
newURIStoragePrincipalToInherit
=
mOSHE
-
>
GetStoragePrincipalToInherit
(
)
;
newCsp
=
mOSHE
-
>
GetCsp
(
)
;
}
else
{
newURITriggeringPrincipal
=
aLoadState
-
>
TriggeringPrincipal
(
)
;
newURIPrincipalToInherit
=
doc
-
>
NodePrincipal
(
)
;
newURIStoragePrincipalToInherit
=
doc
-
>
IntrinsicStoragePrincipal
(
)
;
newCsp
=
doc
-
>
GetCsp
(
)
;
}
OnNewURI
(
aLoadState
-
>
URI
(
)
nullptr
newURITriggeringPrincipal
newURIPrincipalToInherit
newURIStoragePrincipalToInherit
mLoadType
newCsp
true
true
true
)
;
nsCOMPtr
<
nsIInputStream
>
postData
;
uint32_t
cacheKey
=
0
;
bool
scrollRestorationIsManual
=
false
;
if
(
mOSHE
)
{
mOSHE
-
>
SetScrollPosition
(
scrollPos
.
x
scrollPos
.
y
)
;
DebugOnly
<
nsresult
>
rv
=
mOSHE
-
>
GetScrollRestorationIsManual
(
&
scrollRestorationIsManual
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Didn
'
t
expect
this
to
fail
.
"
)
;
if
(
aLoadState
-
>
LoadType
(
)
&
LOAD_CMD_NORMAL
)
{
postData
=
mOSHE
-
>
GetPostData
(
)
;
cacheKey
=
mOSHE
-
>
GetCacheKey
(
)
;
if
(
mLSHE
)
{
if
(
!
aLoadState
-
>
SHEntry
(
)
)
{
mLSHE
-
>
SetScrollRestorationIsManual
(
scrollRestorationIsManual
)
;
}
mLSHE
-
>
AdoptBFCacheEntry
(
mOSHE
)
;
}
}
}
if
(
aLoadState
-
>
SHEntry
(
)
)
{
DebugOnly
<
nsresult
>
rv
=
aLoadState
-
>
SHEntry
(
)
-
>
GetScrollRestorationIsManual
(
&
scrollRestorationIsManual
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Didn
'
t
expect
this
to
fail
.
"
)
;
}
if
(
mLSHE
)
{
SetHistoryEntryAndUpdateBC
(
Nothing
(
)
Some
<
nsISHEntry
*
>
(
mLSHE
)
)
;
if
(
postData
)
{
mOSHE
-
>
SetPostData
(
postData
)
;
}
if
(
cacheKey
!
=
0
)
{
mOSHE
-
>
SetCacheKey
(
cacheKey
)
;
}
}
SetHistoryEntryAndUpdateBC
(
Some
<
nsISHEntry
*
>
(
oldLSHE
)
Nothing
(
)
)
;
if
(
mSessionHistory
)
{
int32_t
index
=
mSessionHistory
-
>
Index
(
)
;
nsCOMPtr
<
nsISHEntry
>
shEntry
;
mSessionHistory
-
>
LegacySHistory
(
)
-
>
GetEntryAtIndex
(
index
getter_AddRefs
(
shEntry
)
)
;
NS_ENSURE_TRUE
(
shEntry
NS_ERROR_FAILURE
)
;
shEntry
-
>
SetTitle
(
mTitle
)
;
}
UpdateGlobalHistoryTitle
(
aLoadState
-
>
URI
(
)
)
;
SetDocCurrentStateObj
(
mOSHE
)
;
CopyFavicon
(
currentURI
aLoadState
-
>
URI
(
)
doc
-
>
NodePrincipal
(
)
UsePrivateBrowsing
(
)
)
;
RefPtr
<
nsGlobalWindowOuter
>
scriptGlobal
=
mScriptGlobal
;
RefPtr
<
nsGlobalWindowInner
>
win
=
scriptGlobal
?
scriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
:
nullptr
;
nsresult
rv
=
ScrollToAnchor
(
aState
.
mCurrentURIHasRef
aState
.
mNewURIHasRef
aState
.
mNewHash
aLoadState
-
>
LoadType
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nscoord
bx
=
0
;
nscoord
by
=
0
;
bool
needsScrollPosUpdate
=
false
;
if
(
mOSHE
&
&
(
aLoadState
-
>
LoadType
(
)
=
=
LOAD_HISTORY
|
|
aLoadState
-
>
LoadType
(
)
=
=
LOAD_RELOAD_NORMAL
)
&
&
!
scrollRestorationIsManual
)
{
needsScrollPosUpdate
=
true
;
mOSHE
-
>
GetScrollPosition
(
&
bx
&
by
)
;
}
if
(
win
)
{
bool
doHashchange
=
aState
.
mSameExceptHashes
&
&
(
aState
.
mCurrentURIHasRef
!
=
aState
.
mNewURIHasRef
|
|
!
aState
.
mCurrentHash
.
Equals
(
aState
.
mNewHash
)
)
;
if
(
aState
.
mHistoryNavBetweenSameDoc
|
|
doHashchange
)
{
win
-
>
DispatchSyncPopState
(
)
;
}
if
(
needsScrollPosUpdate
&
&
win
-
>
HasActiveDocument
(
)
)
{
SetCurScrollPosEx
(
bx
by
)
;
}
if
(
doHashchange
)
{
win
-
>
DispatchAsyncHashchange
(
currentURI
aLoadState
-
>
URI
(
)
)
;
}
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
InternalLoad
(
nsDocShellLoadState
*
aLoadState
nsIDocShell
*
*
aDocShell
nsIRequest
*
*
aRequest
)
{
MOZ_ASSERT
(
aLoadState
"
need
a
load
state
!
"
)
;
MOZ_ASSERT
(
aLoadState
-
>
TriggeringPrincipal
(
)
"
need
a
valid
TriggeringPrincipal
"
)
;
if
(
!
aLoadState
-
>
TriggeringPrincipal
(
)
)
{
MOZ_ASSERT
(
false
"
InternalLoad
needs
a
valid
triggeringPrincipal
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mBrowsingContext
-
>
PendingInitialization
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mOriginalUriString
.
Truncate
(
)
;
MOZ_LOG
(
gDocShellLeakLog
LogLevel
:
:
Debug
(
"
DOCSHELL
%
p
InternalLoad
%
s
\
n
"
this
aLoadState
-
>
URI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
if
(
aDocShell
)
{
*
aDocShell
=
nullptr
;
}
if
(
aRequest
)
{
*
aRequest
=
nullptr
;
}
NS_ENSURE_TRUE
(
IsValidLoadType
(
aLoadState
-
>
LoadType
(
)
)
NS_ERROR_INVALID_ARG
)
;
if
(
mIsBeingDestroyed
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
EnsureScriptEnvironment
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
aLoadState
-
>
Target
(
)
.
IsEmpty
(
)
)
{
return
PerformRetargeting
(
aLoadState
aDocShell
aRequest
)
;
}
SameDocumentNavigationState
sameDocumentNavigationState
;
bool
sameDocument
=
IsSameDocumentNavigation
(
aLoadState
sameDocumentNavigationState
)
&
&
!
aLoadState
-
>
GetPendingRedirectedChannel
(
)
;
if
(
!
sameDocument
&
&
!
(
aLoadState
-
>
LoadType
(
)
&
LOAD_CMD_HISTORY
)
)
{
bool
handled
;
rv
=
MaybeHandleLoadDelegate
(
aLoadState
nsIBrowserDOMWindow
:
:
OPEN_CURRENTWINDOW
&
handled
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
handled
)
{
return
NS_OK
;
}
}
if
(
aLoadState
-
>
SourceDocShell
(
)
&
&
aLoadState
-
>
SourceDocShell
(
)
-
>
IsSandboxedFrom
(
mBrowsingContext
)
)
{
return
NS_ERROR_DOM_INVALID_ACCESS_ERR
;
}
NS_ENSURE_STATE
(
!
HasUnloadedParent
(
)
)
;
rv
=
CheckLoadingPermissions
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mFiredUnloadEvent
)
{
if
(
IsOKToLoadURI
(
aLoadState
-
>
URI
(
)
)
)
{
MOZ_ASSERT
(
aLoadState
-
>
Target
(
)
.
IsEmpty
(
)
"
Shouldn
'
t
have
a
window
target
here
!
"
)
;
if
(
LOAD_TYPE_HAS_FLAGS
(
aLoadState
-
>
LoadType
(
)
LOAD_FLAGS_REPLACE_HISTORY
)
)
{
mLoadType
=
LOAD_NORMAL_REPLACE
;
}
nsCOMPtr
<
nsIRunnable
>
ev
=
new
InternalLoadEvent
(
this
aLoadState
)
;
return
DispatchToTabGroup
(
TaskCategory
:
:
Other
ev
.
forget
(
)
)
;
}
return
NS_OK
;
}
{
bool
inherits
;
if
(
aLoadState
-
>
LoadType
(
)
!
=
LOAD_NORMAL_EXTERNAL
&
&
!
aLoadState
-
>
PrincipalToInherit
(
)
&
&
(
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_INHERIT_PRINCIPAL
)
)
&
&
NS_SUCCEEDED
(
nsContentUtils
:
:
URIInheritsSecurityContext
(
aLoadState
-
>
URI
(
)
&
inherits
)
)
&
&
inherits
)
{
aLoadState
-
>
SetPrincipalToInherit
(
GetInheritedPrincipal
(
true
)
)
;
}
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
=
GetInProcessParentDocshell
(
)
;
if
(
parent
)
{
RefPtr
<
Document
>
doc
=
parent
-
>
GetDocument
(
)
;
if
(
doc
)
{
doc
-
>
TryCancelFrameLoaderInitialization
(
this
)
;
}
}
if
(
aLoadState
-
>
LoadType
(
)
=
=
LOAD_NORMAL_EXTERNAL
)
{
if
(
SchemeIsChrome
(
aLoadState
-
>
URI
(
)
)
)
{
NS_WARNING
(
"
blocked
external
chrome
:
url
-
-
use
'
-
-
chrome
'
option
"
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
CreateAboutBlankContentViewer
(
nullptr
nullptr
nullptr
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
aLoadState
-
>
SetLoadType
(
LOAD_NORMAL
)
;
}
mAllowKeywordFixup
=
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
)
;
mURIResultedInDocument
=
false
;
if
(
sameDocument
)
{
return
HandleSameDocumentNavigation
(
aLoadState
sameDocumentNavigationState
)
;
}
nsCOMPtr
<
nsIDocShell
>
kungFuDeathGrip
(
this
)
;
bool
toBeReset
=
false
;
bool
isJavaScript
=
SchemeIsJavascript
(
aLoadState
-
>
URI
(
)
)
;
if
(
!
isJavaScript
)
{
toBeReset
=
MaybeInitTiming
(
)
;
}
bool
isNotDownload
=
aLoadState
-
>
FileName
(
)
.
IsVoid
(
)
;
if
(
mTiming
&
&
isNotDownload
)
{
mTiming
-
>
NotifyBeforeUnload
(
)
;
}
if
(
!
isJavaScript
&
&
isNotDownload
&
&
mContentViewer
)
{
bool
okToUnload
;
rv
=
mContentViewer
-
>
PermitUnload
(
&
okToUnload
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
okToUnload
)
{
MaybeResetInitTiming
(
toBeReset
)
;
return
NS_OK
;
}
}
if
(
mTiming
&
&
isNotDownload
)
{
mTiming
-
>
NotifyUnloadAccepted
(
mCurrentURI
)
;
}
nsCOMPtr
<
nsIWebBrowserChrome3
>
browserChrome3
=
do_GetInterface
(
mTreeOwner
)
;
if
(
browserChrome3
&
&
!
aLoadState
-
>
GetPendingRedirectedChannel
(
)
)
{
bool
shouldLoad
;
rv
=
browserChrome3
-
>
ShouldLoadURI
(
this
aLoadState
-
>
URI
(
)
aLoadState
-
>
GetReferrerInfo
(
)
!
!
aLoadState
-
>
PostDataStream
(
)
aLoadState
-
>
TriggeringPrincipal
(
)
aLoadState
-
>
Csp
(
)
&
shouldLoad
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
shouldLoad
)
{
return
NS_OK
;
}
}
if
(
XRE_IsE10sParentProcess
(
)
)
{
nsCOMPtr
<
nsIURI
>
uri
=
aLoadState
-
>
URI
(
)
;
do
{
bool
canLoadInParent
=
false
;
if
(
NS_SUCCEEDED
(
NS_URIChainHasFlags
(
uri
nsIProtocolHandler
:
:
URI_IS_UI_RESOURCE
&
canLoadInParent
)
)
&
&
canLoadInParent
)
{
break
;
}
while
(
uri
&
&
uri
-
>
SchemeIs
(
"
view
-
source
"
)
)
{
nsCOMPtr
<
nsINestedURI
>
nested
=
do_QueryInterface
(
uri
)
;
if
(
nested
)
{
nested
-
>
GetInnerURI
(
getter_AddRefs
(
uri
)
)
;
}
else
{
break
;
}
}
if
(
!
uri
|
|
uri
-
>
SchemeIs
(
"
about
"
)
|
|
(
!
StaticPrefs
:
:
extensions_webextensions_remote
(
)
&
&
uri
-
>
SchemeIs
(
"
moz
-
extension
"
)
)
)
{
break
;
}
nsAutoCString
scheme
;
uri
-
>
GetScheme
(
scheme
)
;
if
(
StringBeginsWith
(
scheme
NS_LITERAL_CSTRING
(
"
ext
+
"
)
)
&
&
!
StaticPrefs
:
:
extensions_webextensions_remote
(
)
)
{
break
;
}
if
(
xpc
:
:
IsInAutomation
(
)
&
&
Preferences
:
:
GetBool
(
"
security
.
allow_unsafe_parent_loads
"
false
)
)
{
break
;
}
return
NS_ERROR_FAILURE
;
}
while
(
0
)
;
}
if
(
OrientationLock
(
)
!
=
hal
:
:
eScreenOrientation_None
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
GetInProcessSameTypeParent
(
getter_AddRefs
(
parent
)
)
;
MOZ_ASSERT
(
!
parent
)
;
#
endif
SetOrientationLock
(
hal
:
:
eScreenOrientation_None
)
;
if
(
mBrowsingContext
-
>
GetIsActive
(
)
)
{
ScreenOrientation
:
:
UpdateActiveOrientationLock
(
hal
:
:
eScreenOrientation_None
)
;
}
}
bool
savePresentation
=
CanSavePresentation
(
aLoadState
-
>
LoadType
(
)
nullptr
nullptr
)
;
if
(
!
isJavaScript
&
&
isNotDownload
)
{
if
(
(
mContentViewer
&
&
mContentViewer
-
>
GetPreviousViewer
(
)
)
|
|
LOAD_TYPE_HAS_FLAGS
(
aLoadState
-
>
LoadType
(
)
LOAD_FLAGS_STOP_CONTENT
)
)
{
rv
=
Stop
(
nsIWebNavigation
:
:
STOP_ALL
)
;
}
else
{
rv
=
Stop
(
nsIWebNavigation
:
:
STOP_NETWORK
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
mLoadType
=
aLoadState
-
>
LoadType
(
)
;
if
(
mLoadType
!
=
LOAD_ERROR_PAGE
)
{
SetHistoryEntryAndUpdateBC
(
Some
<
nsISHEntry
*
>
(
aLoadState
-
>
SHEntry
(
)
)
Nothing
(
)
)
;
if
(
aLoadState
-
>
SHEntry
(
)
)
{
aLoadState
-
>
SHEntry
(
)
-
>
GetDocshellID
(
mHistoryID
)
;
mBrowsingContext
-
>
SetHistoryID
(
mHistoryID
)
;
}
}
mSavingOldViewer
=
savePresentation
;
if
(
aLoadState
-
>
SHEntry
(
)
&
&
(
mLoadType
&
LOAD_CMD_HISTORY
)
)
{
RefPtr
<
ChildSHistory
>
shistory
=
GetRootSessionHistory
(
)
;
if
(
shistory
)
{
shistory
-
>
RemovePendingHistoryNavigations
(
)
;
}
if
(
mContentViewer
)
{
nsCOMPtr
<
nsIContentViewer
>
prevViewer
=
mContentViewer
-
>
GetPreviousViewer
(
)
;
if
(
prevViewer
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIContentViewer
>
prevPrevViewer
=
prevViewer
-
>
GetPreviousViewer
(
)
;
NS_ASSERTION
(
!
prevPrevViewer
"
Should
never
have
viewer
chain
here
"
)
;
#
endif
nsCOMPtr
<
nsISHEntry
>
viewerEntry
;
prevViewer
-
>
GetHistoryEntry
(
getter_AddRefs
(
viewerEntry
)
)
;
if
(
viewerEntry
=
=
aLoadState
-
>
SHEntry
(
)
)
{
mContentViewer
-
>
SetPreviousViewer
(
nullptr
)
;
prevViewer
-
>
Destroy
(
)
;
}
}
}
nsCOMPtr
<
nsISHEntry
>
oldEntry
=
mOSHE
;
bool
restoring
;
rv
=
RestorePresentation
(
aLoadState
-
>
SHEntry
(
)
&
restoring
)
;
if
(
restoring
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BFCACHE_PAGE_RESTORED
true
)
;
return
rv
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BFCACHE_PAGE_RESTORED
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
oldEntry
)
{
oldEntry
-
>
SyncPresentationState
(
)
;
}
aLoadState
-
>
SHEntry
(
)
-
>
SyncPresentationState
(
)
;
}
}
bool
isTopLevelDoc
=
mItemType
=
=
typeContent
&
&
(
!
IsFrame
(
)
|
|
GetIsMozBrowser
(
)
)
;
OriginAttributes
attrs
=
GetOriginAttributes
(
)
;
attrs
.
SetFirstPartyDomain
(
isTopLevelDoc
aLoadState
-
>
URI
(
)
)
;
PredictorLearn
(
aLoadState
-
>
URI
(
)
nullptr
nsINetworkPredictor
:
:
LEARN_LOAD_TOPLEVEL
attrs
)
;
PredictorPredict
(
aLoadState
-
>
URI
(
)
nullptr
nsINetworkPredictor
:
:
PREDICT_LOAD
attrs
nullptr
)
;
nsCOMPtr
<
nsIRequest
>
req
;
rv
=
DoURILoad
(
aLoadState
aDocShell
getter_AddRefs
(
req
)
)
;
if
(
req
&
&
aRequest
)
{
NS_ADDREF
(
*
aRequest
=
req
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
nsCOMPtr
<
nsIChannel
>
chan
(
do_QueryInterface
(
req
)
)
;
if
(
DisplayLoadError
(
rv
aLoadState
-
>
URI
(
)
nullptr
chan
)
&
&
aLoadState
-
>
HasLoadFlags
(
LOAD_FLAGS_ERROR_LOAD_CHANGES_RV
)
)
{
return
NS_ERROR_LOAD_SHOWED_ERRORPAGE
;
}
if
(
NS_ERROR_UNKNOWN_PROTOCOL
=
=
rv
)
{
return
NS_OK
;
}
}
return
rv
;
}
nsIPrincipal
*
nsDocShell
:
:
GetInheritedPrincipal
(
bool
aConsiderCurrentDocument
bool
aConsiderStoragePrincipal
)
{
RefPtr
<
Document
>
document
;
bool
inheritedFromCurrent
=
false
;
if
(
aConsiderCurrentDocument
&
&
mContentViewer
)
{
document
=
mContentViewer
-
>
GetDocument
(
)
;
inheritedFromCurrent
=
true
;
}
if
(
!
document
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parentItem
;
GetInProcessSameTypeParent
(
getter_AddRefs
(
parentItem
)
)
;
if
(
parentItem
)
{
document
=
parentItem
-
>
GetDocument
(
)
;
}
}
if
(
!
document
)
{
if
(
!
aConsiderCurrentDocument
)
{
return
nullptr
;
}
EnsureContentViewer
(
)
;
if
(
!
mContentViewer
)
{
return
nullptr
;
}
document
=
mContentViewer
-
>
GetDocument
(
)
;
}
if
(
document
)
{
nsIPrincipal
*
docPrincipal
=
aConsiderStoragePrincipal
?
document
-
>
IntrinsicStoragePrincipal
(
)
:
document
-
>
NodePrincipal
(
)
;
if
(
inheritedFromCurrent
&
&
mItemType
=
=
typeContent
&
&
docPrincipal
-
>
IsSystemPrincipal
(
)
)
{
return
nullptr
;
}
return
docPrincipal
;
}
return
nullptr
;
}
static
bool
IsConsideredSameOriginForUIR
(
nsIPrincipal
*
aTriggeringPrincipal
nsIPrincipal
*
aResultPrincipal
)
{
MOZ_ASSERT
(
aTriggeringPrincipal
)
;
MOZ_ASSERT
(
aResultPrincipal
)
;
if
(
aTriggeringPrincipal
-
>
Equals
(
aResultPrincipal
)
)
{
return
true
;
}
if
(
!
aResultPrincipal
-
>
GetIsContentPrincipal
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
resultURI
=
aResultPrincipal
-
>
GetURI
(
)
;
if
(
!
SchemeIsHTTP
(
resultURI
)
)
{
return
false
;
}
nsresult
rv
;
nsAutoCString
tmpResultSpec
;
rv
=
resultURI
-
>
GetSpec
(
tmpResultSpec
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
tmpResultSpec
.
ReplaceLiteral
(
0
4
"
https
"
)
;
nsCOMPtr
<
nsIURI
>
tmpResultURI
;
rv
=
NS_NewURI
(
getter_AddRefs
(
tmpResultURI
)
tmpResultSpec
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
mozilla
:
:
OriginAttributes
tmpOA
=
BasePrincipal
:
:
Cast
(
aResultPrincipal
)
-
>
OriginAttributesRef
(
)
;
nsCOMPtr
<
nsIPrincipal
>
tmpResultPrincipal
=
BasePrincipal
:
:
CreateContentPrincipal
(
tmpResultURI
tmpOA
)
;
return
aTriggeringPrincipal
-
>
Equals
(
tmpResultPrincipal
)
;
}
nsresult
nsDocShell
:
:
CreateRealChannelForDocument
(
nsIChannel
*
*
aChannel
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
nsIInterfaceRequestor
*
aCallbacks
nsLoadFlags
aLoadFlags
const
nsAString
&
aSrcdoc
nsIURI
*
aBaseURI
)
{
nsCOMPtr
<
nsIChannel
>
channel
;
if
(
aSrcdoc
.
IsVoid
(
)
)
{
MOZ_TRY
(
NS_NewChannelInternal
(
getter_AddRefs
(
channel
)
aURI
aLoadInfo
nullptr
nullptr
aCallbacks
aLoadFlags
)
)
;
if
(
aBaseURI
)
{
nsCOMPtr
<
nsIViewSourceChannel
>
vsc
=
do_QueryInterface
(
channel
)
;
if
(
vsc
)
{
MOZ_ALWAYS_SUCCEEDS
(
vsc
-
>
SetBaseURI
(
aBaseURI
)
)
;
}
}
}
else
if
(
SchemeIsViewSource
(
aURI
)
)
{
nsViewSourceHandler
*
vsh
=
nsViewSourceHandler
:
:
GetInstance
(
)
;
if
(
!
vsh
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_TRY
(
vsh
-
>
NewSrcdocChannel
(
aURI
aBaseURI
aSrcdoc
aLoadInfo
getter_AddRefs
(
channel
)
)
)
;
}
else
{
MOZ_TRY
(
NS_NewInputStreamChannelInternal
(
getter_AddRefs
(
channel
)
aURI
aSrcdoc
NS_LITERAL_CSTRING
(
"
text
/
html
"
)
aLoadInfo
true
)
)
;
nsCOMPtr
<
nsIInputStreamChannel
>
isc
=
do_QueryInterface
(
channel
)
;
MOZ_ASSERT
(
isc
)
;
isc
-
>
SetBaseURI
(
aBaseURI
)
;
}
channel
.
forget
(
aChannel
)
;
return
NS_OK
;
}
static
bool
URIUsesDocChannel
(
nsIURI
*
aURI
)
{
if
(
SchemeIsJavascript
(
aURI
)
|
|
NS_IsAboutBlank
(
aURI
)
)
{
return
false
;
}
nsCString
spec
=
aURI
-
>
GetSpecOrDefault
(
)
;
if
(
spec
.
EqualsLiteral
(
"
about
:
printpreview
"
)
|
|
spec
.
EqualsLiteral
(
"
about
:
crashcontent
"
)
)
{
return
false
;
}
return
true
;
}
bool
nsDocShell
:
:
CreateAndConfigureRealChannelForLoadState
(
BrowsingContext
*
aBrowsingContext
nsDocShellLoadState
*
aLoadState
LoadInfo
*
aLoadInfo
nsIInterfaceRequestor
*
aCallbacks
nsDocShell
*
aDocShell
const
OriginAttributes
&
aOriginAttributes
nsLoadFlags
aLoadFlags
uint32_t
aCacheKey
nsresult
&
aRv
nsIChannel
*
*
aChannel
)
{
MOZ_ASSERT
(
aLoadInfo
)
;
nsString
srcdoc
=
VoidString
(
)
;
bool
isSrcdoc
=
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_IS_SRCDOC
)
;
if
(
isSrcdoc
)
{
srcdoc
=
aLoadState
-
>
SrcdocData
(
)
;
}
if
(
aLoadState
-
>
PrincipalToInherit
(
)
)
{
aLoadInfo
-
>
SetPrincipalToInherit
(
aLoadState
-
>
PrincipalToInherit
(
)
)
;
}
aLoadInfo
-
>
SetLoadTriggeredFromExternal
(
aLoadState
-
>
LoadType
(
)
=
=
LOAD_NORMAL_EXTERNAL
)
;
aLoadInfo
-
>
SetForceAllowDataURI
(
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_FORCE_ALLOW_DATA_URI
)
)
;
aLoadInfo
-
>
SetOriginalFrameSrcLoad
(
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_ORIGINAL_FRAME_SRC
)
)
;
bool
inheritAttrs
=
false
;
if
(
aLoadState
-
>
PrincipalToInherit
(
)
)
{
inheritAttrs
=
nsContentUtils
:
:
ChannelShouldInheritPrincipal
(
aLoadState
-
>
PrincipalToInherit
(
)
aLoadState
-
>
URI
(
)
true
isSrcdoc
)
;
}
OriginAttributes
attrs
;
if
(
inheritAttrs
)
{
MOZ_ASSERT
(
aLoadState
-
>
PrincipalToInherit
(
)
"
We
should
have
PrincipalToInherit
here
.
"
)
;
attrs
=
aLoadState
-
>
PrincipalToInherit
(
)
-
>
OriginAttributesRef
(
)
;
MOZ_ASSERT_IF
(
!
OriginAttributes
:
:
IsFirstPartyEnabled
(
)
attrs
=
=
aOriginAttributes
)
;
}
else
{
attrs
=
aOriginAttributes
;
attrs
.
SetFirstPartyDomain
(
IsTopLevelDoc
(
aBrowsingContext
aLoadInfo
)
aLoadState
-
>
URI
(
)
)
;
}
aRv
=
aLoadInfo
-
>
SetOriginAttributes
(
attrs
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aRv
)
)
)
{
return
false
;
}
if
(
aLoadState
-
>
GetIsFromProcessingFrameAttributes
(
)
)
{
aLoadInfo
-
>
SetIsFromProcessingFrameAttributes
(
)
;
}
if
(
aLoadState
-
>
IsFormSubmission
(
)
)
{
aLoadInfo
-
>
SetIsFormSubmission
(
true
)
;
}
nsCOMPtr
<
nsIChannel
>
channel
;
aRv
=
CreateRealChannelForDocument
(
getter_AddRefs
(
channel
)
aLoadState
-
>
URI
(
)
aLoadInfo
aCallbacks
aLoadFlags
srcdoc
aLoadState
-
>
BaseURI
(
)
)
;
NS_ENSURE_SUCCESS
(
aRv
false
)
;
if
(
!
channel
)
{
return
false
;
}
if
(
nsCOMPtr
<
nsIApplicationCacheChannel
>
appCacheChannel
=
do_QueryInterface
(
channel
)
)
{
appCacheChannel
-
>
SetInheritApplicationCache
(
false
)
;
if
(
GeckoProcessType_Default
!
=
XRE_GetProcessType
(
)
)
{
appCacheChannel
-
>
SetChooseApplicationCache
(
true
)
;
}
else
if
(
aDocShell
)
{
nsCOMPtr
<
nsIScriptSecurityManager
>
secMan
=
do_GetService
(
NS_SCRIPTSECURITYMANAGER_CONTRACTID
)
;
if
(
secMan
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
secMan
-
>
GetDocShellContentPrincipal
(
aLoadState
-
>
URI
(
)
aDocShell
getter_AddRefs
(
principal
)
)
;
appCacheChannel
-
>
SetChooseApplicationCache
(
NS_ShouldCheckAppCache
(
principal
)
)
;
}
}
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
channel
)
)
;
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChannelInternal
(
do_QueryInterface
(
channel
)
)
;
nsCOMPtr
<
nsIURI
>
referrer
;
nsIReferrerInfo
*
referrerInfo
=
aLoadState
-
>
GetReferrerInfo
(
)
;
if
(
referrerInfo
)
{
referrerInfo
-
>
GetOriginalReferrer
(
getter_AddRefs
(
referrer
)
)
;
}
if
(
httpChannelInternal
)
{
if
(
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_FORCE_ALLOW_COOKIES
)
)
{
aRv
=
httpChannelInternal
-
>
SetThirdPartyFlags
(
nsIHttpChannelInternal
:
:
THIRD_PARTY_FORCE_ALLOW
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aRv
)
)
;
}
if
(
aLoadState
-
>
FirstParty
(
)
)
{
aRv
=
httpChannelInternal
-
>
SetDocumentURI
(
aLoadState
-
>
URI
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aRv
)
)
;
}
else
{
aRv
=
httpChannelInternal
-
>
SetDocumentURI
(
referrer
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aRv
)
)
;
}
aRv
=
httpChannelInternal
-
>
SetRedirectMode
(
nsIHttpChannelInternal
:
:
REDIRECT_MODE_MANUAL
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aRv
)
)
;
}
if
(
httpChannel
)
{
if
(
aLoadState
-
>
HeadersStream
(
)
)
{
aRv
=
AddHeadersToChannel
(
aLoadState
-
>
HeadersStream
(
)
httpChannel
)
;
}
if
(
referrerInfo
)
{
aRv
=
httpChannel
-
>
SetReferrerInfo
(
referrerInfo
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aRv
)
)
;
}
if
(
IsUrgentStart
(
aBrowsingContext
aLoadInfo
aLoadState
-
>
LoadType
(
)
)
)
{
nsCOMPtr
<
nsIClassOfService
>
cos
(
do_QueryInterface
(
channel
)
)
;
if
(
cos
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
UrgentStart
)
;
}
}
}
channel
-
>
SetOriginalURI
(
aLoadState
-
>
OriginalURI
(
)
?
aLoadState
-
>
OriginalURI
(
)
:
aLoadState
-
>
URI
(
)
)
;
const
nsACString
&
typeHint
=
aLoadState
-
>
TypeHint
(
)
;
if
(
!
typeHint
.
IsVoid
(
)
)
{
channel
-
>
SetContentType
(
typeHint
)
;
}
const
nsAString
&
fileName
=
aLoadState
-
>
FileName
(
)
;
if
(
!
fileName
.
IsVoid
(
)
)
{
aRv
=
channel
-
>
SetContentDisposition
(
nsIChannel
:
:
DISPOSITION_ATTACHMENT
)
;
NS_ENSURE_SUCCESS
(
aRv
false
)
;
if
(
!
fileName
.
IsEmpty
(
)
)
{
aRv
=
channel
-
>
SetContentDispositionFilename
(
fileName
)
;
NS_ENSURE_SUCCESS
(
aRv
false
)
;
}
}
if
(
nsCOMPtr
<
nsIWritablePropertyBag2
>
props
=
do_QueryInterface
(
channel
)
)
{
nsCOMPtr
<
nsIURI
>
referrer
;
nsIReferrerInfo
*
referrerInfo
=
aLoadState
-
>
GetReferrerInfo
(
)
;
if
(
referrerInfo
)
{
referrerInfo
-
>
GetOriginalReferrer
(
getter_AddRefs
(
referrer
)
)
;
}
props
-
>
SetPropertyAsInterface
(
NS_LITERAL_STRING
(
"
docshell
.
internalReferrer
"
)
referrer
)
;
if
(
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_FIRST_LOAD
)
)
{
props
-
>
SetPropertyAsBool
(
NS_LITERAL_STRING
(
"
docshell
.
newWindowTarget
"
)
true
)
;
}
}
nsCOMPtr
<
nsICacheInfoChannel
>
cacheChannel
(
do_QueryInterface
(
channel
)
)
;
auto
loadType
=
aLoadState
-
>
LoadType
(
)
;
if
(
aLoadState
-
>
PostDataStream
(
)
)
{
if
(
nsCOMPtr
<
nsIFormPOSTActionChannel
>
postChannel
=
do_QueryInterface
(
channel
)
)
{
nsCOMPtr
<
nsISeekableStream
>
postDataSeekable
=
do_QueryInterface
(
aLoadState
-
>
PostDataStream
(
)
)
;
if
(
postDataSeekable
)
{
aRv
=
postDataSeekable
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
0
)
;
NS_ENSURE_SUCCESS
(
aRv
false
)
;
}
postChannel
-
>
SetUploadStream
(
aLoadState
-
>
PostDataStream
(
)
EmptyCString
(
)
-
1
)
;
}
if
(
cacheChannel
&
&
aCacheKey
!
=
0
)
{
if
(
loadType
=
=
LOAD_HISTORY
|
|
loadType
=
=
LOAD_RELOAD_CHARSET_CHANGE
)
{
cacheChannel
-
>
SetCacheKey
(
aCacheKey
)
;
uint32_t
loadFlags
;
if
(
NS_SUCCEEDED
(
channel
-
>
GetLoadFlags
(
&
loadFlags
)
)
)
{
channel
-
>
SetLoadFlags
(
loadFlags
|
nsICachingChannel
:
:
LOAD_ONLY_FROM_CACHE
)
;
}
}
else
if
(
loadType
=
=
LOAD_RELOAD_NORMAL
)
{
cacheChannel
-
>
SetCacheKey
(
aCacheKey
)
;
}
}
}
else
{
if
(
loadType
=
=
LOAD_HISTORY
|
|
loadType
=
=
LOAD_RELOAD_NORMAL
|
|
loadType
=
=
LOAD_RELOAD_CHARSET_CHANGE
|
|
loadType
=
=
LOAD_RELOAD_CHARSET_CHANGE_BYPASS_CACHE
|
|
loadType
=
=
LOAD_RELOAD_CHARSET_CHANGE_BYPASS_PROXY_AND_CACHE
)
{
if
(
cacheChannel
&
&
aCacheKey
!
=
0
)
{
cacheChannel
-
>
SetCacheKey
(
aCacheKey
)
;
}
}
}
if
(
nsCOMPtr
<
nsIScriptChannel
>
scriptChannel
=
do_QueryInterface
(
channel
)
)
{
scriptChannel
-
>
SetExecutionPolicy
(
nsIScriptChannel
:
:
EXECUTE_NORMAL
)
;
}
if
(
nsCOMPtr
<
nsITimedChannel
>
timedChannel
=
do_QueryInterface
(
channel
)
)
{
timedChannel
-
>
SetTimingEnabled
(
true
)
;
auto
&
embedderElementType
=
aBrowsingContext
-
>
GetEmbedderElementType
(
)
;
if
(
embedderElementType
)
{
timedChannel
-
>
SetInitiatorType
(
*
embedderElementType
)
;
}
}
if
(
httpChannelInternal
&
&
aBrowsingContext
-
>
GetSandboxFlags
(
)
!
=
0
)
{
httpChannelInternal
-
>
SetHasNonEmptySandboxingFlag
(
true
)
;
}
nsCOMPtr
<
nsIURI
>
rpURI
;
aLoadInfo
-
>
GetResultPrincipalURI
(
getter_AddRefs
(
rpURI
)
)
;
Maybe
<
nsCOMPtr
<
nsIURI
>
>
originalResultPrincipalURI
;
aLoadState
-
>
GetMaybeResultPrincipalURI
(
originalResultPrincipalURI
)
;
if
(
originalResultPrincipalURI
&
&
(
!
aLoadState
-
>
KeepResultPrincipalURIIfSet
(
)
|
|
!
rpURI
)
)
{
aLoadInfo
-
>
SetResultPrincipalURI
(
originalResultPrincipalURI
.
ref
(
)
)
;
}
if
(
aLoadState
-
>
OriginalURI
(
)
&
&
aLoadState
-
>
LoadReplace
(
)
)
{
uint32_t
loadFlags
;
aRv
=
channel
-
>
GetLoadFlags
(
&
loadFlags
)
;
NS_ENSURE_SUCCESS
(
aRv
false
)
;
channel
-
>
SetLoadFlags
(
loadFlags
|
nsIChannel
:
:
LOAD_REPLACE
)
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aLoadState
-
>
Csp
(
)
;
if
(
csp
)
{
bool
upgradeInsecureRequests
=
false
;
csp
-
>
GetUpgradeInsecureRequests
(
&
upgradeInsecureRequests
)
;
if
(
upgradeInsecureRequests
)
{
nsCOMPtr
<
nsIPrincipal
>
resultPrincipal
;
aRv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
channel
getter_AddRefs
(
resultPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
aRv
false
)
;
if
(
IsConsideredSameOriginForUIR
(
aLoadState
-
>
TriggeringPrincipal
(
)
resultPrincipal
)
)
{
aLoadInfo
-
>
SetUpgradeInsecureRequests
(
)
;
}
}
RefPtr
<
nsCSPContext
>
cspToInherit
=
new
nsCSPContext
(
)
;
cspToInherit
-
>
InitFromOther
(
static_cast
<
nsCSPContext
*
>
(
csp
.
get
(
)
)
)
;
aLoadInfo
-
>
SetCSPToInherit
(
cspToInherit
)
;
}
channel
.
forget
(
aChannel
)
;
return
true
;
}
nsresult
nsDocShell
:
:
DoURILoad
(
nsDocShellLoadState
*
aLoadState
nsIDocShell
*
*
aDocShell
nsIRequest
*
*
aRequest
)
{
if
(
mIsBeingDestroyed
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIURILoader
>
uriLoader
=
components
:
:
URILoader
:
:
Service
(
)
;
if
(
NS_WARN_IF
(
!
uriLoader
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
;
uint32_t
contentPolicyType
=
DetermineContentType
(
)
;
if
(
IsFrame
(
)
)
{
MOZ_ASSERT
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
|
|
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME
"
DoURILoad
thinks
this
is
a
frame
and
InternalLoad
does
not
"
)
;
if
(
StaticPrefs
:
:
dom_block_external_protocol_in_iframes
(
)
)
{
bool
doesNotReturnData
=
false
;
NS_URIChainHasFlags
(
aLoadState
-
>
URI
(
)
nsIProtocolHandler
:
:
URI_DOES_NOT_RETURN_DATA
&
doesNotReturnData
)
;
if
(
doesNotReturnData
)
{
bool
popupBlocked
=
true
;
if
(
PopupBlocker
:
:
GetPopupControlState
(
)
<
=
PopupBlocker
:
:
openBlocked
)
{
nsCOMPtr
<
nsINode
>
loadingNode
=
mScriptGlobal
-
>
GetFrameElementInternal
(
)
;
popupBlocked
=
!
PopupBlocker
:
:
TryUsePopupOpeningToken
(
loadingNode
?
loadingNode
-
>
NodePrincipal
(
)
:
nullptr
)
;
}
else
if
(
mBrowsingContext
-
>
GetIsActive
(
)
&
&
PopupBlocker
:
:
ConsumeTimerTokenForExternalProtocolIframe
(
)
)
{
popupBlocked
=
false
;
}
else
{
nsCOMPtr
<
nsINode
>
loadingNode
=
mScriptGlobal
-
>
GetFrameElementInternal
(
)
;
if
(
loadingNode
)
{
popupBlocked
=
!
PopupBlocker
:
:
CanShowPopupByPermission
(
loadingNode
-
>
NodePrincipal
(
)
)
;
}
}
if
(
popupBlocked
)
{
return
NS_OK
;
}
}
}
nsCOMPtr
<
nsIURI
>
tempURI
=
aLoadState
-
>
URI
(
)
;
nsCOMPtr
<
nsINestedURI
>
nestedURI
=
do_QueryInterface
(
tempURI
)
;
while
(
nestedURI
)
{
if
(
SchemeIsViewSource
(
tempURI
)
)
{
return
NS_ERROR_UNKNOWN_PROTOCOL
;
}
nestedURI
-
>
GetInnerURI
(
getter_AddRefs
(
tempURI
)
)
;
nestedURI
=
do_QueryInterface
(
tempURI
)
;
}
}
else
{
MOZ_ASSERT
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
"
DoURILoad
thinks
this
is
a
document
and
InternalLoad
does
not
"
)
;
}
nsCOMPtr
<
nsIChannel
>
channel
=
aLoadState
-
>
GetPendingRedirectedChannel
(
)
;
if
(
channel
)
{
MOZ_ASSERT
(
!
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_IS_SRCDOC
)
"
pending
channel
for
srcdoc
load
?
"
)
;
if
(
aRequest
)
{
nsCOMPtr
<
nsIRequest
>
outRequest
=
channel
;
outRequest
.
forget
(
aRequest
)
;
}
rv
=
OpenInitializedChannel
(
channel
uriLoader
nsIURILoader
:
:
REDIRECTED_CHANNEL
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
aDocShell
)
{
nsCOMPtr
<
nsIDocShell
>
self
=
this
;
self
.
forget
(
aDocShell
)
;
}
return
rv
;
}
nsCOMPtr
<
nsINode
>
loadingNode
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
loadingWindow
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
;
nsCOMPtr
<
nsISupports
>
topLevelLoadingContext
;
if
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
)
{
loadingNode
=
nullptr
;
loadingPrincipal
=
nullptr
;
loadingWindow
=
mScriptGlobal
;
if
(
XRE_IsContentProcess
(
)
)
{
nsCOMPtr
<
nsIBrowserChild
>
browserChild
=
GetBrowserChild
(
)
;
topLevelLoadingContext
=
ToSupports
(
browserChild
)
;
}
else
{
nsCOMPtr
<
Element
>
requestingElement
=
loadingWindow
-
>
GetFrameElementInternal
(
)
;
topLevelLoadingContext
=
requestingElement
;
}
}
else
{
loadingWindow
=
nullptr
;
loadingNode
=
mScriptGlobal
-
>
GetFrameElementInternal
(
)
;
if
(
loadingNode
)
{
loadingPrincipal
=
loadingNode
-
>
NodePrincipal
(
)
;
#
ifdef
DEBUG
RefPtr
<
Document
>
requestingDoc
=
loadingNode
-
>
OwnerDoc
(
)
;
nsCOMPtr
<
nsIDocShell
>
elementDocShell
=
requestingDoc
-
>
GetDocShell
(
)
;
MOZ_ASSERT
(
mItemType
=
=
elementDocShell
-
>
ItemType
(
)
"
subframes
should
have
the
same
docshell
type
as
their
parent
"
)
;
#
endif
}
else
{
return
NS_OK
;
}
}
if
(
!
aLoadState
-
>
TriggeringPrincipal
(
)
)
{
MOZ_ASSERT
(
false
"
DoURILoad
needs
a
valid
triggeringPrincipal
"
)
;
return
NS_ERROR_FAILURE
;
}
bool
inheritPrincipal
=
false
;
if
(
aLoadState
-
>
PrincipalToInherit
(
)
)
{
bool
isSrcdoc
=
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_IS_SRCDOC
)
;
bool
inheritAttrs
=
nsContentUtils
:
:
ChannelShouldInheritPrincipal
(
aLoadState
-
>
PrincipalToInherit
(
)
aLoadState
-
>
URI
(
)
true
isSrcdoc
)
;
bool
isURIUniqueOrigin
=
StaticPrefs
:
:
security_data_uri_unique_opaque_origin
(
)
&
&
SchemeIsData
(
aLoadState
-
>
URI
(
)
)
;
inheritPrincipal
=
inheritAttrs
&
&
!
isURIUniqueOrigin
;
}
nsLoadFlags
loadFlags
=
mDefaultLoadFlags
;
nsSecurityFlags
securityFlags
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
;
uint32_t
sandboxFlags
=
mBrowsingContext
-
>
GetSandboxFlags
(
)
;
if
(
aLoadState
-
>
FirstParty
(
)
)
{
loadFlags
|
=
nsIChannel
:
:
LOAD_INITIAL_DOCUMENT_URI
;
}
if
(
mLoadType
=
=
LOAD_ERROR_PAGE
)
{
bool
isXFOError
=
false
;
if
(
mFailedChannel
)
{
nsresult
status
;
mFailedChannel
-
>
GetStatus
(
&
status
)
;
isXFOError
=
status
=
=
NS_ERROR_XFO_VIOLATION
;
}
if
(
!
isXFOError
)
{
loadFlags
|
=
nsIChannel
:
:
LOAD_BACKGROUND
;
}
securityFlags
|
=
nsILoadInfo
:
:
SEC_LOAD_ERROR_PAGE
;
}
if
(
inheritPrincipal
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_FORCE_INHERIT_PRINCIPAL
;
}
RefPtr
<
LoadInfo
>
loadInfo
=
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
)
?
new
LoadInfo
(
loadingWindow
aLoadState
-
>
TriggeringPrincipal
(
)
topLevelLoadingContext
securityFlags
sandboxFlags
)
:
new
LoadInfo
(
loadingPrincipal
aLoadState
-
>
TriggeringPrincipal
(
)
loadingNode
securityFlags
contentPolicyType
Maybe
<
mozilla
:
:
dom
:
:
ClientInfo
>
(
)
Maybe
<
mozilla
:
:
dom
:
:
ServiceWorkerDescriptor
>
(
)
sandboxFlags
)
;
uint32_t
cacheKey
=
0
;
if
(
mLSHE
)
{
cacheKey
=
mLSHE
-
>
GetCacheKey
(
)
;
}
else
if
(
mOSHE
)
{
cacheKey
=
mOSHE
-
>
GetCacheKey
(
)
;
}
bool
canUseDocumentChannel
=
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_IS_SRCDOC
)
?
(
sandboxFlags
&
SANDBOXED_ORIGIN
)
:
URIUsesDocChannel
(
aLoadState
-
>
URI
(
)
)
;
if
(
StaticPrefs
:
:
browser_tabs_documentchannel
(
)
&
&
XRE_IsContentProcess
(
)
&
&
canUseDocumentChannel
)
{
channel
=
new
DocumentChannelChild
(
aLoadState
loadInfo
loadFlags
cacheKey
)
;
channel
-
>
SetNotificationCallbacks
(
this
)
;
}
else
if
(
!
CreateAndConfigureRealChannelForLoadState
(
mBrowsingContext
aLoadState
loadInfo
this
this
GetOriginAttributes
(
)
loadFlags
cacheKey
rv
getter_AddRefs
(
channel
)
)
)
{
return
rv
;
}
if
(
aRequest
)
{
NS_ADDREF
(
*
aRequest
=
channel
)
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aLoadState
-
>
Csp
(
)
;
if
(
csp
)
{
bool
allowsNavigateTo
=
false
;
rv
=
csp
-
>
GetAllowsNavigateTo
(
aLoadState
-
>
URI
(
)
aLoadState
-
>
IsFormSubmission
(
)
false
false
&
allowsNavigateTo
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
allowsNavigateTo
)
{
return
NS_ERROR_CSP_NAVIGATE_TO_VIOLATION
;
}
}
const
nsACString
&
typeHint
=
aLoadState
-
>
TypeHint
(
)
;
if
(
!
typeHint
.
IsVoid
(
)
)
{
mContentTypeHint
=
typeHint
;
}
else
{
mContentTypeHint
.
Truncate
(
)
;
}
if
(
mLoadType
=
=
LOAD_NORMAL_ALLOW_MIXED_CONTENT
|
|
mLoadType
=
=
LOAD_RELOAD_ALLOW_MIXED_CONTENT
)
{
rv
=
SetMixedContentChannel
(
channel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
mMixedContentChannel
)
{
rv
=
nsContentUtils
:
:
CheckSameOrigin
(
mMixedContentChannel
channel
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_FAILED
(
SetMixedContentChannel
(
channel
)
)
)
{
SetMixedContentChannel
(
nullptr
)
;
}
}
rv
=
DoChannelLoad
(
channel
uriLoader
aLoadState
-
>
HasLoadFlags
(
INTERNAL_LOAD_FLAGS_BYPASS_CLASSIFIER
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
aDocShell
)
{
*
aDocShell
=
this
;
NS_ADDREF
(
*
aDocShell
)
;
}
}
return
rv
;
}
static
nsresult
AppendSegmentToString
(
nsIInputStream
*
aIn
void
*
aClosure
const
char
*
aFromRawSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
aWriteCount
)
{
nsAutoCString
*
buf
=
static_cast
<
nsAutoCString
*
>
(
aClosure
)
;
buf
-
>
Append
(
aFromRawSegment
aCount
)
;
*
aWriteCount
=
aCount
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
AddHeadersToChannel
(
nsIInputStream
*
aHeadersData
nsIChannel
*
aGenericChannel
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aGenericChannel
)
;
NS_ENSURE_STATE
(
httpChannel
)
;
uint32_t
numRead
;
nsAutoCString
headersString
;
nsresult
rv
=
aHeadersData
-
>
ReadSegments
(
AppendSegmentToString
&
headersString
UINT32_MAX
&
numRead
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
headerName
;
nsAutoCString
headerValue
;
int32_t
crlf
;
int32_t
colon
;
static
const
char
kWhitespace
[
]
=
"
\
b
\
t
\
r
\
n
"
;
while
(
true
)
{
crlf
=
headersString
.
Find
(
"
\
r
\
n
"
)
;
if
(
crlf
=
=
kNotFound
)
{
return
NS_OK
;
}
const
nsACString
&
oneHeader
=
StringHead
(
headersString
crlf
)
;
colon
=
oneHeader
.
FindChar
(
'
:
'
)
;
if
(
colon
=
=
kNotFound
)
{
return
NS_ERROR_UNEXPECTED
;
}
headerName
=
StringHead
(
oneHeader
colon
)
;
headerValue
=
Substring
(
oneHeader
colon
+
1
)
;
headerName
.
Trim
(
kWhitespace
)
;
headerValue
.
Trim
(
kWhitespace
)
;
headersString
.
Cut
(
0
crlf
+
2
)
;
rv
=
httpChannel
-
>
SetRequestHeader
(
headerName
headerValue
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
oops
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsresult
nsDocShell
:
:
DoChannelLoad
(
nsIChannel
*
aChannel
nsIURILoader
*
aURILoader
bool
aBypassClassifier
)
{
nsLoadFlags
loadFlags
=
0
;
(
void
)
aChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
loadFlags
|
=
nsIChannel
:
:
LOAD_DOCUMENT_URI
|
nsIChannel
:
:
LOAD_CALL_CONTENT_SNIFFERS
;
uint32_t
sandboxFlags
=
mBrowsingContext
-
>
GetSandboxFlags
(
)
;
if
(
SandboxFlagsImplyCookies
(
sandboxFlags
)
)
{
loadFlags
|
=
nsIRequest
:
:
LOAD_DOCUMENT_NEEDS_COOKIE
;
}
switch
(
mLoadType
)
{
case
LOAD_HISTORY
:
{
bool
uriModified
=
false
;
if
(
mLSHE
)
{
uriModified
=
mLSHE
-
>
GetURIWasModified
(
)
;
}
if
(
!
uriModified
)
{
loadFlags
|
=
nsIRequest
:
:
VALIDATE_NEVER
;
}
break
;
}
case
LOAD_RELOAD_CHARSET_CHANGE_BYPASS_PROXY_AND_CACHE
:
case
LOAD_RELOAD_CHARSET_CHANGE_BYPASS_CACHE
:
loadFlags
|
=
nsIRequest
:
:
LOAD_BYPASS_CACHE
|
nsIRequest
:
:
LOAD_FRESH_CONNECTION
;
[
[
fallthrough
]
]
;
case
LOAD_RELOAD_CHARSET_CHANGE
:
{
nsCOMPtr
<
nsICacheInfoChannel
>
cachingChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
cachingChannel
)
{
cachingChannel
-
>
SetAllowStaleCacheContent
(
true
)
;
}
break
;
}
case
LOAD_RELOAD_NORMAL
:
case
LOAD_REFRESH
:
loadFlags
|
=
nsIRequest
:
:
VALIDATE_ALWAYS
;
break
;
case
LOAD_NORMAL_BYPASS_CACHE
:
case
LOAD_NORMAL_BYPASS_PROXY
:
case
LOAD_NORMAL_BYPASS_PROXY_AND_CACHE
:
case
LOAD_NORMAL_ALLOW_MIXED_CONTENT
:
case
LOAD_RELOAD_BYPASS_CACHE
:
case
LOAD_RELOAD_BYPASS_PROXY
:
case
LOAD_RELOAD_BYPASS_PROXY_AND_CACHE
:
case
LOAD_RELOAD_ALLOW_MIXED_CONTENT
:
case
LOAD_REPLACE_BYPASS_CACHE
:
loadFlags
|
=
nsIRequest
:
:
LOAD_BYPASS_CACHE
|
nsIRequest
:
:
LOAD_FRESH_CONNECTION
;
break
;
case
LOAD_NORMAL
:
case
LOAD_LINK
:
switch
(
Preferences
:
:
GetInt
(
"
browser
.
cache
.
check_doc_frequency
"
-
1
)
)
{
case
0
:
loadFlags
|
=
nsIRequest
:
:
VALIDATE_ONCE_PER_SESSION
;
break
;
case
1
:
loadFlags
|
=
nsIRequest
:
:
VALIDATE_ALWAYS
;
break
;
case
2
:
loadFlags
|
=
nsIRequest
:
:
VALIDATE_NEVER
;
break
;
}
break
;
}
if
(
aBypassClassifier
)
{
loadFlags
|
=
nsIChannel
:
:
LOAD_BYPASS_URL_CLASSIFIER
;
}
if
(
IsForceReloading
(
)
)
{
loadFlags
|
=
nsIChannel
:
:
LOAD_BYPASS_SERVICE_WORKER
;
}
(
void
)
aChannel
-
>
SetLoadFlags
(
loadFlags
)
;
uint32_t
openFlags
=
ComputeURILoaderFlags
(
mBrowsingContext
mLoadType
)
;
return
OpenInitializedChannel
(
aChannel
aURILoader
openFlags
)
;
}
uint32_t
nsDocShell
:
:
ComputeURILoaderFlags
(
BrowsingContext
*
aBrowsingContext
uint32_t
aLoadType
)
{
MOZ_ASSERT
(
aBrowsingContext
)
;
uint32_t
openFlags
=
0
;
if
(
aLoadType
=
=
LOAD_LINK
)
{
openFlags
|
=
nsIURILoader
:
:
IS_CONTENT_PREFERRED
;
}
if
(
!
aBrowsingContext
-
>
GetAllowContentRetargeting
(
)
)
{
openFlags
|
=
nsIURILoader
:
:
DONT_RETARGET
;
}
return
openFlags
;
}
nsresult
nsDocShell
:
:
OpenInitializedChannel
(
nsIChannel
*
aChannel
nsIURILoader
*
aURILoader
uint32_t
aOpenFlags
)
{
nsresult
rv
=
NS_OK
;
auto
cleanupInitialClient
=
MakeScopeExit
(
[
&
]
{
mInitialClientSource
.
reset
(
)
;
}
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetWindow
(
)
;
NS_ENSURE_TRUE
(
win
NS_ERROR_FAILURE
)
;
MaybeCreateInitialClientSource
(
)
;
if
(
aOpenFlags
&
nsIURILoader
:
:
REDIRECTED_CHANNEL
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
aChannel
-
>
GetLoadInfo
(
getter_AddRefs
(
loadInfo
)
)
;
LoadInfo
*
li
=
static_cast
<
LoadInfo
*
>
(
loadInfo
.
get
(
)
)
;
if
(
loadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
)
{
li
-
>
UpdateBrowsingContextID
(
mBrowsingContext
-
>
Id
(
)
)
;
}
else
if
(
loadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
)
{
li
-
>
UpdateFrameBrowsingContextID
(
mBrowsingContext
-
>
Id
(
)
)
;
}
}
RefPtr
<
net
:
:
DocumentChannel
>
docChannel
=
do_QueryObject
(
aChannel
)
;
if
(
docChannel
&
&
XRE_IsContentProcess
(
)
)
{
aOpenFlags
|
=
nsIURILoader
:
:
DONT_RETARGET
;
}
Maybe
<
ClientInfo
>
noReservedClient
;
if
(
docChannel
)
{
rv
=
AddClientChannelHelperInChild
(
aChannel
win
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
docChannel
-
>
SetInitialClientInfo
(
GetInitialClientInfo
(
)
)
;
}
else
if
(
aOpenFlags
&
nsIURILoader
:
:
REDIRECTED_CHANNEL
)
{
CreateReservedSourceIfNeeded
(
aChannel
win
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
}
else
{
rv
=
AddClientChannelHelper
(
aChannel
std
:
:
move
(
noReservedClient
)
GetInitialClientInfo
(
)
win
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aURILoader
-
>
OpenURI
(
aChannel
aOpenFlags
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsJSContext
:
:
MaybeRunNextCollectorSlice
(
this
JS
:
:
GCReason
:
:
DOCSHELL
)
;
cleanupInitialClient
.
release
(
)
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
ScrollToAnchor
(
bool
aCurHasRef
bool
aNewHasRef
nsACString
&
aNewHash
uint32_t
aLoadType
)
{
if
(
!
mCurrentURI
)
{
return
NS_OK
;
}
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
NS_OK
;
}
nsIScrollableFrame
*
rootScroll
=
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
rootScroll
)
{
rootScroll
-
>
ClearDidHistoryRestore
(
)
;
}
if
(
(
!
aCurHasRef
|
|
aLoadType
!
=
LOAD_HISTORY
)
&
&
!
aNewHasRef
)
{
return
NS_OK
;
}
if
(
!
aNewHash
.
IsEmpty
(
)
)
{
bool
scroll
=
aLoadType
!
=
LOAD_HISTORY
&
&
aLoadType
!
=
LOAD_RELOAD_NORMAL
;
nsresult
rv
=
NS_ERROR_FAILURE
;
NS_ConvertUTF8toUTF16
uStr
(
aNewHash
)
;
if
(
!
uStr
.
IsEmpty
(
)
)
{
rv
=
presShell
-
>
GoToAnchor
(
uStr
scroll
ScrollFlags
:
:
ScrollSmoothAuto
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
char
*
str
=
ToNewCString
(
aNewHash
)
;
if
(
!
str
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsUnescape
(
str
)
;
NS_ConvertUTF8toUTF16
utf16Str
(
str
)
;
if
(
!
utf16Str
.
IsEmpty
(
)
)
{
rv
=
presShell
-
>
GoToAnchor
(
utf16Str
scroll
ScrollFlags
:
:
ScrollSmoothAuto
)
;
}
free
(
str
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_ENSURE_TRUE
(
mContentViewer
NS_ERROR_FAILURE
)
;
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
nsAutoCString
charset
;
doc
-
>
GetDocumentCharacterSet
(
)
-
>
Name
(
charset
)
;
nsCOMPtr
<
nsITextToSubURI
>
textToSubURI
=
do_GetService
(
NS_ITEXTTOSUBURI_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
uStr
;
rv
=
textToSubURI
-
>
UnEscapeAndConvert
(
charset
aNewHash
uStr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
presShell
-
>
GoToAnchor
(
uStr
scroll
&
&
!
uStr
.
IsEmpty
(
)
ScrollFlags
:
:
ScrollSmoothAuto
)
;
}
}
else
{
presShell
-
>
GoToAnchor
(
EmptyString
(
)
false
)
;
if
(
aLoadType
=
=
LOAD_HISTORY
|
|
aLoadType
=
=
LOAD_RELOAD_NORMAL
)
{
return
NS_OK
;
}
SetCurScrollPosEx
(
0
0
)
;
}
return
NS_OK
;
}
void
nsDocShell
:
:
SetupReferrerInfoFromChannel
(
nsIChannel
*
aChannel
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aChannel
)
)
;
if
(
httpChannel
)
{
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
httpChannel
-
>
GetReferrerInfo
(
)
;
SetReferrerInfo
(
referrerInfo
)
;
}
}
bool
nsDocShell
:
:
OnNewURI
(
nsIURI
*
aURI
nsIChannel
*
aChannel
nsIPrincipal
*
aTriggeringPrincipal
nsIPrincipal
*
aPrincipalToInherit
nsIPrincipal
*
aStoragePrincipalToInherit
uint32_t
aLoadType
nsIContentSecurityPolicy
*
aCsp
bool
aFireOnLocationChange
bool
aAddToGlobalHistory
bool
aCloneSHChildren
)
{
MOZ_ASSERT
(
aURI
"
uri
is
null
"
)
;
MOZ_ASSERT
(
!
aChannel
|
|
!
aTriggeringPrincipal
"
Shouldn
'
t
have
both
set
"
)
;
MOZ_ASSERT
(
!
aPrincipalToInherit
|
|
(
aPrincipalToInherit
&
&
aTriggeringPrincipal
)
)
;
#
if
defined
(
DEBUG
)
if
(
MOZ_LOG_TEST
(
gDocShellLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
chanName
;
if
(
aChannel
)
{
aChannel
-
>
GetName
(
chanName
)
;
}
else
{
chanName
.
AssignLiteral
(
"
<
no
channel
>
"
)
;
}
MOZ_LOG
(
gDocShellLog
LogLevel
:
:
Debug
(
"
nsDocShell
[
%
p
]
:
:
OnNewURI
(
\
"
%
s
\
"
[
%
s
]
0x
%
x
)
\
n
"
this
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
chanName
.
get
(
)
aLoadType
)
)
;
}
#
endif
bool
equalUri
=
false
;
uint32_t
responseStatus
=
0
;
nsCOMPtr
<
nsIInputStream
>
inputStream
;
if
(
aChannel
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aChannel
)
)
;
if
(
!
httpChannel
)
{
GetHttpChannel
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
}
if
(
httpChannel
)
{
nsCOMPtr
<
nsIUploadChannel
>
uploadChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
uploadChannel
)
{
uploadChannel
-
>
GetUploadStream
(
getter_AddRefs
(
inputStream
)
)
;
}
nsresult
rv
=
httpChannel
-
>
GetResponseStatus
(
&
responseStatus
)
;
if
(
mLSHE
&
&
NS_SUCCEEDED
(
rv
)
&
&
responseStatus
>
=
400
)
{
mLSHE
-
>
AbandonBFCacheEntry
(
)
;
}
}
}
bool
updateGHistory
=
!
(
aLoadType
=
=
LOAD_BYPASS_HISTORY
|
|
aLoadType
=
=
LOAD_ERROR_PAGE
|
|
aLoadType
&
LOAD_CMD_HISTORY
)
;
bool
updateSHistory
=
updateGHistory
&
&
(
!
(
aLoadType
&
LOAD_CMD_RELOAD
)
|
|
(
IsForceReloadType
(
aLoadType
)
&
&
IsFrame
(
)
)
)
;
RefPtr
<
ChildSHistory
>
rootSH
=
mSessionHistory
;
if
(
!
rootSH
)
{
rootSH
=
GetRootSessionHistory
(
)
;
}
if
(
!
rootSH
)
{
updateSHistory
=
false
;
updateGHistory
=
false
;
}
if
(
mCurrentURI
)
{
aURI
-
>
Equals
(
mCurrentURI
&
equalUri
)
;
}
#
ifdef
DEBUG
bool
shAvailable
=
(
rootSH
!
=
nullptr
)
;
MOZ_LOG
(
gDocShellLog
LogLevel
:
:
Debug
(
"
shAvailable
=
%
i
updateSHistory
=
%
i
updateGHistory
=
%
i
"
"
equalURI
=
%
i
\
n
"
shAvailable
updateSHistory
updateGHistory
equalUri
)
)
;
#
endif
if
(
equalUri
&
&
mOSHE
&
&
(
mLoadType
=
=
LOAD_NORMAL
|
|
mLoadType
=
=
LOAD_LINK
|
|
mLoadType
=
=
LOAD_STOP_CONTENT
)
&
&
!
inputStream
)
{
mLoadType
=
LOAD_NORMAL_REPLACE
;
}
if
(
mLoadType
=
=
LOAD_REFRESH
&
&
!
inputStream
&
&
equalUri
)
{
SetHistoryEntryAndUpdateBC
(
Some
<
nsISHEntry
*
>
(
mOSHE
)
Nothing
(
)
)
;
}
if
(
aChannel
&
&
IsForceReloadType
(
aLoadType
)
)
{
MOZ_ASSERT
(
!
updateSHistory
|
|
IsFrame
(
)
"
We
shouldn
'
t
be
updating
session
history
for
forced
"
"
reloads
unless
we
'
re
in
a
newly
created
iframe
!
"
)
;
nsCOMPtr
<
nsICacheInfoChannel
>
cacheChannel
(
do_QueryInterface
(
aChannel
)
)
;
uint32_t
cacheKey
=
0
;
if
(
cacheChannel
)
{
cacheChannel
-
>
GetCacheKey
(
&
cacheKey
)
;
}
if
(
mLSHE
)
{
mLSHE
-
>
SetCacheKey
(
cacheKey
)
;
}
else
if
(
mOSHE
)
{
mOSHE
-
>
SetCacheKey
(
cacheKey
)
;
}
ClearFrameHistory
(
mLSHE
)
;
ClearFrameHistory
(
mOSHE
)
;
}
if
(
aLoadType
=
=
LOAD_REFRESH
)
{
ClearFrameHistory
(
mLSHE
)
;
ClearFrameHistory
(
mOSHE
)
;
}
if
(
updateSHistory
)
{
if
(
!
mLSHE
&
&
(
mItemType
=
=
typeContent
)
&
&
mURIResultedInDocument
)
{
(
void
)
AddToSessionHistory
(
aURI
aChannel
aTriggeringPrincipal
aPrincipalToInherit
aStoragePrincipalToInherit
aCsp
aCloneSHChildren
getter_AddRefs
(
mLSHE
)
)
;
}
}
else
if
(
mSessionHistory
&
&
mLSHE
&
&
mURIResultedInDocument
)
{
mSessionHistory
-
>
LegacySHistory
(
)
-
>
EnsureCorrectEntryAtCurrIndex
(
mLSHE
)
;
}
if
(
updateGHistory
&
&
aAddToGlobalHistory
&
&
!
net
:
:
ChannelIsPost
(
aChannel
)
)
{
nsCOMPtr
<
nsIURI
>
previousURI
;
uint32_t
previousFlags
=
0
;
if
(
aLoadType
&
LOAD_CMD_RELOAD
)
{
previousURI
=
aURI
;
}
else
{
ExtractLastVisit
(
aChannel
getter_AddRefs
(
previousURI
)
&
previousFlags
)
;
}
AddURIVisit
(
aURI
previousURI
previousFlags
responseStatus
)
;
}
if
(
rootSH
&
&
(
(
mLoadType
&
(
LOAD_CMD_HISTORY
|
LOAD_CMD_RELOAD
)
)
|
|
mLoadType
=
=
LOAD_NORMAL_REPLACE
)
)
{
mPreviousEntryIndex
=
rootSH
-
>
Index
(
)
;
rootSH
-
>
LegacySHistory
(
)
-
>
UpdateIndex
(
)
;
mLoadedEntryIndex
=
rootSH
-
>
Index
(
)
;
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Verbose
(
"
Previous
index
:
%
d
Loaded
index
:
%
d
"
mPreviousEntryIndex
mLoadedEntryIndex
)
)
;
}
uint32_t
locationFlags
=
aCloneSHChildren
?
uint32_t
(
LOCATION_CHANGE_SAME_DOCUMENT
)
:
0
;
bool
onLocationChangeNeeded
=
SetCurrentURI
(
aURI
aChannel
aFireOnLocationChange
locationFlags
)
;
SetupReferrerInfoFromChannel
(
aChannel
)
;
return
onLocationChangeNeeded
;
}
bool
nsDocShell
:
:
OnLoadingSite
(
nsIChannel
*
aChannel
bool
aFireOnLocationChange
bool
aAddToGlobalHistory
)
{
nsCOMPtr
<
nsIURI
>
uri
;
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_TRUE
(
uri
false
)
;
return
OnNewURI
(
uri
aChannel
nullptr
nullptr
nullptr
mLoadType
nullptr
aFireOnLocationChange
aAddToGlobalHistory
false
)
;
}
void
nsDocShell
:
:
SetReferrerInfo
(
nsIReferrerInfo
*
aReferrerInfo
)
{
mReferrerInfo
=
aReferrerInfo
;
}
NS_IMETHODIMP
nsDocShell
:
:
AddState
(
JS
:
:
Handle
<
JS
:
:
Value
>
aData
const
nsAString
&
aTitle
const
nsAString
&
aURL
bool
aReplace
JSContext
*
aCx
)
{
nsresult
rv
;
AutoRestore
<
uint32_t
>
loadTypeResetter
(
mLoadType
)
;
if
(
JustStartedNetworkLoad
(
)
)
{
aReplace
=
true
;
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
document
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIStructuredCloneContainer
>
scContainer
;
{
RefPtr
<
Document
>
origDocument
=
GetDocument
(
)
;
if
(
!
origDocument
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
nsCOMPtr
<
nsIPrincipal
>
origPrincipal
=
origDocument
-
>
NodePrincipal
(
)
;
scContainer
=
new
nsStructuredCloneContainer
(
)
;
rv
=
scContainer
-
>
InitFromJSVal
(
aData
aCx
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
Document
>
newDocument
=
GetDocument
(
)
;
if
(
!
newDocument
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
nsCOMPtr
<
nsIPrincipal
>
newPrincipal
=
newDocument
-
>
NodePrincipal
(
)
;
bool
principalsEqual
=
false
;
origPrincipal
-
>
Equals
(
newPrincipal
&
principalsEqual
)
;
NS_ENSURE_TRUE
(
principalsEqual
NS_ERROR_DOM_SECURITY_ERR
)
;
}
int32_t
maxStateObjSize
=
Preferences
:
:
GetInt
(
"
browser
.
history
.
maxStateObjectSize
"
2097152
)
;
if
(
maxStateObjSize
<
0
)
{
maxStateObjSize
=
0
;
}
uint64_t
scSize
;
rv
=
scContainer
-
>
GetSerializedNBytes
(
&
scSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
scSize
<
=
(
uint32_t
)
maxStateObjSize
NS_ERROR_ILLEGAL_VALUE
)
;
bool
equalURIs
=
true
;
nsCOMPtr
<
nsIURI
>
currentURI
;
if
(
mCurrentURI
)
{
currentURI
=
nsIOService
:
:
CreateExposableURI
(
mCurrentURI
)
;
}
else
{
currentURI
=
mCurrentURI
;
}
nsCOMPtr
<
nsIURI
>
newURI
;
if
(
aURL
.
Length
(
)
=
=
0
)
{
newURI
=
currentURI
;
}
else
{
nsIURI
*
docBaseURI
=
document
-
>
GetDocBaseURI
(
)
;
if
(
!
docBaseURI
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
spec
;
docBaseURI
-
>
GetSpec
(
spec
)
;
rv
=
NS_NewURI
(
getter_AddRefs
(
newURI
)
aURL
document
-
>
GetDocumentCharacterSet
(
)
docBaseURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
if
(
!
nsContentUtils
:
:
URIIsLocalFile
(
newURI
)
)
{
nsCOMPtr
<
nsIScriptSecurityManager
>
secMan
=
do_GetService
(
NS_SCRIPTSECURITYMANAGER_CONTRACTID
)
;
NS_ENSURE_TRUE
(
secMan
NS_ERROR_FAILURE
)
;
nsAutoCString
currentUserPass
newUserPass
;
NS_ENSURE_SUCCESS
(
currentURI
-
>
GetUserPass
(
currentUserPass
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
newURI
-
>
GetUserPass
(
newUserPass
)
NS_ERROR_FAILURE
)
;
bool
isPrivateWin
=
document
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
.
mPrivateBrowsingId
>
0
;
if
(
NS_FAILED
(
secMan
-
>
CheckSameOriginURI
(
currentURI
newURI
true
isPrivateWin
)
)
|
|
!
currentUserPass
.
Equals
(
newUserPass
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
}
else
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
document
-
>
GetPrincipal
(
)
;
if
(
!
principal
|
|
NS_FAILED
(
principal
-
>
CheckMayLoadWithReporting
(
newURI
false
document
-
>
InnerWindowID
(
)
)
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
}
if
(
currentURI
)
{
currentURI
-
>
Equals
(
newURI
&
equalURIs
)
;
}
else
{
equalURIs
=
false
;
}
}
rv
=
UpdateURLAndHistory
(
document
newURI
scContainer
aTitle
aReplace
currentURI
equalURIs
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
UpdateURLAndHistory
(
Document
*
aDocument
nsIURI
*
aNewURI
nsIStructuredCloneContainer
*
aData
const
nsAString
&
aTitle
bool
aReplace
nsIURI
*
aCurrentURI
bool
aEqualURIs
)
{
NS_ENSURE_TRUE
(
mOSHE
|
|
aReplace
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsISHEntry
>
oldOSHE
=
mOSHE
;
mLoadType
=
LOAD_PUSHSTATE
;
nsCOMPtr
<
nsISHEntry
>
newSHEntry
;
if
(
!
aReplace
)
{
RefPtr
<
ChildSHistory
>
shistory
=
GetRootSessionHistory
(
)
;
if
(
shistory
)
{
shistory
-
>
RemovePendingHistoryNavigations
(
)
;
}
nsPoint
scrollPos
=
GetCurScrollPos
(
)
;
mOSHE
-
>
SetScrollPosition
(
scrollPos
.
x
scrollPos
.
y
)
;
bool
scrollRestorationIsManual
;
nsresult
rv
=
mOSHE
-
>
GetScrollRestorationIsManual
(
&
scrollRestorationIsManual
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Didn
'
t
expect
this
to
fail
.
"
)
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aDocument
-
>
GetCsp
(
)
;
rv
=
AddToSessionHistory
(
aNewURI
nullptr
aDocument
-
>
NodePrincipal
(
)
nullptr
nullptr
csp
true
getter_AddRefs
(
newSHEntry
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
newSHEntry
NS_ERROR_FAILURE
)
;
newSHEntry
-
>
SetScrollRestorationIsManual
(
scrollRestorationIsManual
)
;
NS_ENSURE_SUCCESS
(
newSHEntry
-
>
AdoptBFCacheEntry
(
oldOSHE
)
NS_ERROR_FAILURE
)
;
nsString
title
;
mOSHE
-
>
GetTitle
(
title
)
;
newSHEntry
-
>
SetTitle
(
title
)
;
mOSHE
=
newSHEntry
;
}
else
{
newSHEntry
=
mOSHE
;
if
(
!
newSHEntry
)
{
nsresult
rv
=
AddToSessionHistory
(
aNewURI
nullptr
aDocument
-
>
NodePrincipal
(
)
nullptr
nullptr
aDocument
-
>
GetCsp
(
)
true
getter_AddRefs
(
newSHEntry
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mOSHE
=
newSHEntry
;
}
newSHEntry
-
>
SetURI
(
aNewURI
)
;
newSHEntry
-
>
SetOriginalURI
(
aNewURI
)
;
newSHEntry
-
>
SetResultPrincipalURI
(
nullptr
)
;
newSHEntry
-
>
SetLoadReplace
(
false
)
;
}
newSHEntry
-
>
SetStateData
(
aData
)
;
newSHEntry
-
>
SetPostData
(
nullptr
)
;
bool
sameExceptHashes
=
true
;
aNewURI
-
>
EqualsExceptRef
(
aCurrentURI
&
sameExceptHashes
)
;
bool
oldURIWasModified
=
oldOSHE
&
&
oldOSHE
-
>
GetURIWasModified
(
)
;
newSHEntry
-
>
SetURIWasModified
(
!
sameExceptHashes
|
|
oldURIWasModified
)
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
rootSH
)
{
rootSH
-
>
LegacySHistory
(
)
-
>
EvictContentViewersOrReplaceEntry
(
newSHEntry
aReplace
)
;
}
if
(
!
aEqualURIs
&
&
!
mIsBeingDestroyed
)
{
aDocument
-
>
SetDocumentURI
(
aNewURI
)
;
SetCurrentURI
(
aNewURI
nullptr
false
LOCATION_CHANGE_SAME_DOCUMENT
)
;
if
(
mLoadType
!
=
LOAD_ERROR_PAGE
)
{
FireDummyOnLocationChange
(
)
;
}
AddURIVisit
(
aNewURI
aCurrentURI
0
)
;
UpdateGlobalHistoryTitle
(
aNewURI
)
;
CopyFavicon
(
aCurrentURI
aNewURI
aDocument
-
>
NodePrincipal
(
)
UsePrivateBrowsing
(
)
)
;
}
else
{
FireDummyOnLocationChange
(
)
;
}
aDocument
-
>
SetStateObject
(
aData
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCurrentScrollRestorationIsManual
(
bool
*
aIsManual
)
{
*
aIsManual
=
false
;
if
(
mOSHE
)
{
return
mOSHE
-
>
GetScrollRestorationIsManual
(
aIsManual
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetCurrentScrollRestorationIsManual
(
bool
aIsManual
)
{
if
(
mOSHE
)
{
mOSHE
-
>
SetScrollRestorationIsManual
(
aIsManual
)
;
}
return
NS_OK
;
}
bool
nsDocShell
:
:
ShouldAddToSessionHistory
(
nsIURI
*
aURI
nsIChannel
*
aChannel
)
{
nsresult
rv
;
nsAutoCString
buf
;
rv
=
aURI
-
>
GetScheme
(
buf
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
buf
.
EqualsLiteral
(
"
about
"
)
)
{
rv
=
aURI
-
>
GetPathQueryRef
(
buf
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
buf
.
EqualsLiteral
(
"
blank
"
)
)
{
return
false
;
}
if
(
buf
.
EqualsLiteral
(
"
newtab
"
)
)
{
NS_ENSURE_TRUE
(
aChannel
false
)
;
nsCOMPtr
<
nsIPrincipal
>
resultPrincipal
;
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
resultPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
!
resultPrincipal
-
>
IsSystemPrincipal
(
)
;
}
}
return
true
;
}
nsresult
nsDocShell
:
:
AddToSessionHistory
(
nsIURI
*
aURI
nsIChannel
*
aChannel
nsIPrincipal
*
aTriggeringPrincipal
nsIPrincipal
*
aPrincipalToInherit
nsIPrincipal
*
aStoragePrincipalToInherit
nsIContentSecurityPolicy
*
aCsp
bool
aCloneChildren
nsISHEntry
*
*
aNewEntry
)
{
MOZ_ASSERT
(
aURI
"
uri
is
null
"
)
;
MOZ_ASSERT
(
!
aChannel
|
|
!
aTriggeringPrincipal
"
Shouldn
'
t
have
both
set
"
)
;
#
if
defined
(
DEBUG
)
if
(
MOZ_LOG_TEST
(
gDocShellLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
chanName
;
if
(
aChannel
)
{
aChannel
-
>
GetName
(
chanName
)
;
}
else
{
chanName
.
AssignLiteral
(
"
<
no
channel
>
"
)
;
}
MOZ_LOG
(
gDocShellLog
LogLevel
:
:
Debug
(
"
nsDocShell
[
%
p
]
:
:
AddToSessionHistory
(
\
"
%
s
\
"
[
%
s
]
)
\
n
"
this
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
chanName
.
get
(
)
)
)
;
}
#
endif
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsISHEntry
>
entry
;
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
GetInProcessSameTypeRootTreeItem
(
getter_AddRefs
(
root
)
)
;
if
(
LOAD_TYPE_HAS_FLAGS
(
mLoadType
LOAD_FLAGS_REPLACE_HISTORY
)
&
&
root
!
=
static_cast
<
nsIDocShellTreeItem
*
>
(
this
)
)
{
entry
=
mOSHE
;
if
(
entry
)
{
entry
-
>
ClearEntry
(
)
;
}
}
if
(
!
entry
)
{
nsCOMPtr
<
nsIWebNavigation
>
webnav
=
do_QueryInterface
(
root
)
;
NS_ENSURE_TRUE
(
webnav
NS_ERROR_FAILURE
)
;
RefPtr
<
ChildSHistory
>
shistory
=
webnav
-
>
GetSessionHistory
(
)
;
entry
=
CreateSHEntryForDocShell
(
shistory
?
shistory
-
>
LegacySHistory
(
)
:
nullptr
)
;
NS_ENSURE_TRUE
(
entry
NS_ERROR_FAILURE
)
;
}
nsCOMPtr
<
nsIInputStream
>
inputStream
;
nsCOMPtr
<
nsIURI
>
originalURI
;
nsCOMPtr
<
nsIURI
>
resultPrincipalURI
;
bool
loadReplace
=
false
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
;
uint32_t
cacheKey
=
0
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
aTriggeringPrincipal
;
nsCOMPtr
<
nsIPrincipal
>
principalToInherit
=
aPrincipalToInherit
;
nsCOMPtr
<
nsIPrincipal
>
storagePrincipalToInherit
=
aStoragePrincipalToInherit
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aCsp
;
bool
expired
=
false
;
bool
discardLayoutState
=
false
;
nsCOMPtr
<
nsICacheInfoChannel
>
cacheChannel
;
if
(
aChannel
)
{
cacheChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
cacheChannel
)
{
cacheChannel
-
>
GetCacheKey
(
&
cacheKey
)
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aChannel
)
)
;
if
(
!
httpChannel
)
{
GetHttpChannel
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
}
if
(
httpChannel
)
{
nsCOMPtr
<
nsIUploadChannel
>
uploadChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
uploadChannel
)
{
uploadChannel
-
>
GetUploadStream
(
getter_AddRefs
(
inputStream
)
)
;
}
httpChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
uint32_t
loadFlags
;
aChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
loadReplace
=
loadFlags
&
nsIChannel
:
:
LOAD_REPLACE
;
rv
=
httpChannel
-
>
GetReferrerInfo
(
getter_AddRefs
(
referrerInfo
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
discardLayoutState
=
ShouldDiscardLayoutState
(
httpChannel
)
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
if
(
!
triggeringPrincipal
)
{
triggeringPrincipal
=
loadInfo
-
>
TriggeringPrincipal
(
)
;
}
if
(
!
csp
)
{
csp
=
loadInfo
-
>
GetCspToInherit
(
)
;
}
loadInfo
-
>
GetResultPrincipalURI
(
getter_AddRefs
(
resultPrincipalURI
)
)
;
if
(
!
principalToInherit
)
{
if
(
loadInfo
-
>
GetLoadingSandboxed
(
)
)
{
if
(
loadInfo
-
>
LoadingPrincipal
(
)
)
{
principalToInherit
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
loadInfo
-
>
LoadingPrincipal
(
)
)
;
}
else
{
OriginAttributes
attrs
;
loadInfo
-
>
GetOriginAttributes
(
&
attrs
)
;
principalToInherit
=
NullPrincipal
:
:
Create
(
attrs
)
;
}
}
else
{
principalToInherit
=
loadInfo
-
>
PrincipalToInherit
(
)
;
}
}
if
(
!
storagePrincipalToInherit
)
{
storagePrincipalToInherit
=
principalToInherit
;
}
}
nsAutoString
srcdoc
;
bool
srcdocEntry
=
false
;
nsCOMPtr
<
nsIURI
>
baseURI
;
nsCOMPtr
<
nsIInputStreamChannel
>
inStrmChan
=
do_QueryInterface
(
aChannel
)
;
if
(
inStrmChan
)
{
bool
isSrcdocChannel
;
inStrmChan
-
>
GetIsSrcdocChannel
(
&
isSrcdocChannel
)
;
if
(
isSrcdocChannel
)
{
inStrmChan
-
>
GetSrcdocData
(
srcdoc
)
;
srcdocEntry
=
true
;
inStrmChan
-
>
GetBaseURI
(
getter_AddRefs
(
baseURI
)
)
;
}
else
{
srcdoc
.
SetIsVoid
(
true
)
;
}
}
bool
saveLayoutState
=
!
discardLayoutState
;
if
(
cacheChannel
)
{
uint32_t
expTime
=
0
;
cacheChannel
-
>
GetCacheTokenExpirationTime
(
&
expTime
)
;
uint32_t
now
=
PRTimeToSeconds
(
PR_Now
(
)
)
;
if
(
expTime
<
=
now
)
{
expired
=
true
;
}
}
entry
-
>
Create
(
aURI
EmptyString
(
)
inputStream
cacheKey
mContentTypeHint
triggeringPrincipal
principalToInherit
storagePrincipalToInherit
csp
HistoryID
(
)
mDynamicallyCreated
originalURI
resultPrincipalURI
loadReplace
referrerInfo
srcdoc
srcdocEntry
baseURI
saveLayoutState
expired
)
;
if
(
root
=
=
static_cast
<
nsIDocShellTreeItem
*
>
(
this
)
&
&
mSessionHistory
)
{
bool
shouldPersist
=
ShouldAddToSessionHistory
(
aURI
aChannel
)
;
Maybe
<
int32_t
>
previousEntryIndex
;
Maybe
<
int32_t
>
loadedEntryIndex
;
rv
=
mSessionHistory
-
>
LegacySHistory
(
)
-
>
AddToRootSessionHistory
(
aCloneChildren
mOSHE
mBrowsingContext
entry
mLoadType
shouldPersist
&
previousEntryIndex
&
loadedEntryIndex
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Could
not
add
entry
to
root
session
history
"
)
;
if
(
previousEntryIndex
.
isSome
(
)
)
{
mPreviousEntryIndex
=
previousEntryIndex
.
value
(
)
;
}
if
(
loadedEntryIndex
.
isSome
(
)
)
{
mLoadedEntryIndex
=
loadedEntryIndex
.
value
(
)
;
}
}
else
{
if
(
!
mOSHE
|
|
!
LOAD_TYPE_HAS_FLAGS
(
mLoadType
LOAD_FLAGS_REPLACE_HISTORY
)
)
{
rv
=
AddChildSHEntryToParent
(
entry
mChildOffset
aCloneChildren
)
;
}
}
if
(
aNewEntry
)
{
*
aNewEntry
=
nullptr
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
entry
.
forget
(
aNewEntry
)
;
}
}
return
rv
;
}
nsresult
nsDocShell
:
:
LoadHistoryEntry
(
nsISHEntry
*
aEntry
uint32_t
aLoadType
)
{
if
(
!
IsNavigationAllowed
(
)
)
{
return
NS_OK
;
}
NS_ENSURE_TRUE
(
aEntry
NS_ERROR_FAILURE
)
;
nsresult
rv
;
RefPtr
<
nsDocShellLoadState
>
loadState
;
rv
=
aEntry
-
>
CreateLoadInfo
(
getter_AddRefs
(
loadState
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
loadState
-
>
SetLoadType
(
aLoadType
)
;
nsCOMPtr
<
nsISHEntry
>
kungFuDeathGrip
(
aEntry
)
;
if
(
SchemeIsJavascript
(
loadState
-
>
URI
(
)
)
)
{
rv
=
CreateAboutBlankContentViewer
(
loadState
-
>
PrincipalToInherit
(
)
loadState
-
>
StoragePrincipalToInherit
(
)
nullptr
nullptr
aEntry
!
=
mOSHE
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
if
(
!
loadState
-
>
TriggeringPrincipal
(
)
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
this
)
;
loadState
-
>
SetTriggeringPrincipal
(
principal
)
;
}
}
if
(
(
aLoadType
&
LOAD_CMD_RELOAD
)
&
&
loadState
-
>
PostDataStream
(
)
)
{
bool
repost
;
rv
=
ConfirmRepost
(
&
repost
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
repost
)
{
return
NS_BINDING_ABORTED
;
}
}
MOZ_ASSERT
(
loadState
-
>
TriggeringPrincipal
(
)
"
need
a
valid
triggeringPrincipal
to
load
from
history
"
)
;
if
(
!
loadState
-
>
TriggeringPrincipal
(
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
InternalLoad
(
loadState
nullptr
nullptr
)
;
return
rv
;
}
nsresult
nsDocShell
:
:
PersistLayoutHistoryState
(
)
{
nsresult
rv
=
NS_OK
;
if
(
mOSHE
)
{
bool
scrollRestorationIsManual
;
Unused
<
<
mOSHE
-
>
GetScrollRestorationIsManual
(
&
scrollRestorationIsManual
)
;
nsCOMPtr
<
nsILayoutHistoryState
>
layoutState
;
if
(
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
)
{
rv
=
presShell
-
>
CaptureHistoryState
(
getter_AddRefs
(
layoutState
)
)
;
}
else
if
(
scrollRestorationIsManual
)
{
GetLayoutHistoryState
(
getter_AddRefs
(
layoutState
)
)
;
}
if
(
scrollRestorationIsManual
&
&
layoutState
)
{
layoutState
-
>
ResetScrollState
(
)
;
}
}
return
rv
;
}
void
nsDocShell
:
:
SwapHistoryEntries
(
nsISHEntry
*
aOldEntry
nsISHEntry
*
aNewEntry
)
{
if
(
aOldEntry
=
=
mOSHE
)
{
mOSHE
=
aNewEntry
;
}
if
(
aOldEntry
=
=
mLSHE
)
{
mLSHE
=
aNewEntry
;
}
}
void
nsDocShell
:
:
SetHistoryEntryAndUpdateBC
(
const
Maybe
<
nsISHEntry
*
>
&
aLSHE
const
Maybe
<
nsISHEntry
*
>
&
aOSHE
)
{
nsCOMPtr
<
nsISHEntry
>
deathGripOldLSHE
;
if
(
aLSHE
.
isSome
(
)
)
{
deathGripOldLSHE
=
SetHistoryEntry
(
&
mLSHE
aLSHE
.
value
(
)
)
;
MOZ_ASSERT
(
mLSHE
.
get
(
)
=
=
aLSHE
.
value
(
)
)
;
}
nsCOMPtr
<
nsISHEntry
>
deathGripOldOSHE
;
if
(
aOSHE
.
isSome
(
)
)
{
deathGripOldOSHE
=
SetHistoryEntry
(
&
mOSHE
aOSHE
.
value
(
)
)
;
MOZ_ASSERT
(
mOSHE
.
get
(
)
=
=
aOSHE
.
value
(
)
)
;
}
if
(
(
!
StaticPrefs
:
:
fission_sessionHistoryInParent
(
)
&
&
XRE_IsContentProcess
(
)
)
|
|
mBrowsingContext
-
>
IsDiscarded
(
)
)
{
return
;
}
if
(
XRE_IsParentProcess
(
)
)
{
mBrowsingContext
-
>
Canonical
(
)
-
>
UpdateSHEntries
(
mLSHE
mOSHE
)
;
}
else
{
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
cc
-
>
SendUpdateSHEntriesInBC
(
static_cast
<
SHEntryChild
*
>
(
mLSHE
.
get
(
)
)
static_cast
<
SHEntryChild
*
>
(
mOSHE
.
get
(
)
)
mBrowsingContext
)
;
}
}
already_AddRefed
<
nsISHEntry
>
nsDocShell
:
:
SetHistoryEntry
(
nsCOMPtr
<
nsISHEntry
>
*
aPtr
nsISHEntry
*
aEntry
)
{
RefPtr
<
BrowsingContext
>
topBC
=
mBrowsingContext
-
>
Top
(
)
;
if
(
topBC
-
>
IsDiscarded
(
)
)
{
topBC
=
nullptr
;
}
RefPtr
<
BrowsingContext
>
currBC
=
mBrowsingContext
-
>
IsDiscarded
(
)
?
nullptr
:
mBrowsingContext
;
if
(
topBC
&
&
*
aPtr
)
{
(
*
aPtr
)
-
>
SyncTreesForSubframeNavigation
(
aEntry
topBC
currBC
)
;
}
nsCOMPtr
<
nsISHEntry
>
entry
(
aEntry
)
;
entry
.
swap
(
*
aPtr
)
;
return
entry
.
forget
(
)
;
}
already_AddRefed
<
ChildSHistory
>
nsDocShell
:
:
GetRootSessionHistory
(
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
nsresult
rv
=
GetInProcessSameTypeRootTreeItem
(
getter_AddRefs
(
root
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIWebNavigation
>
webnav
=
do_QueryInterface
(
root
)
;
if
(
!
webnav
)
{
return
nullptr
;
}
return
webnav
-
>
GetSessionHistory
(
)
;
}
nsresult
nsDocShell
:
:
GetHttpChannel
(
nsIChannel
*
aChannel
nsIHttpChannel
*
*
aReturn
)
{
NS_ENSURE_ARG_POINTER
(
aReturn
)
;
if
(
!
aChannel
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIMultiPartChannel
>
multiPartChannel
(
do_QueryInterface
(
aChannel
)
)
;
if
(
multiPartChannel
)
{
nsCOMPtr
<
nsIChannel
>
baseChannel
;
multiPartChannel
-
>
GetBaseChannel
(
getter_AddRefs
(
baseChannel
)
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
baseChannel
)
)
;
*
aReturn
=
httpChannel
;
NS_IF_ADDREF
(
*
aReturn
)
;
}
return
NS_OK
;
}
bool
nsDocShell
:
:
ShouldDiscardLayoutState
(
nsIHttpChannel
*
aChannel
)
{
if
(
!
aChannel
)
{
return
false
;
}
bool
noStore
=
false
;
Unused
<
<
aChannel
-
>
IsNoStoreResponse
(
&
noStore
)
;
return
noStore
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetEditor
(
nsIEditor
*
*
aEditor
)
{
NS_ENSURE_ARG_POINTER
(
aEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
GetHTMLEditorInternal
(
)
;
htmlEditor
.
forget
(
aEditor
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetEditor
(
nsIEditor
*
aEditor
)
{
HTMLEditor
*
htmlEditor
=
aEditor
?
aEditor
-
>
AsHTMLEditor
(
)
:
nullptr
;
if
(
aEditor
&
&
!
htmlEditor
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
SetHTMLEditorInternal
(
htmlEditor
)
;
}
HTMLEditor
*
nsDocShell
:
:
GetHTMLEditorInternal
(
)
{
return
mEditorData
?
mEditorData
-
>
GetHTMLEditor
(
)
:
nullptr
;
}
nsresult
nsDocShell
:
:
SetHTMLEditorInternal
(
HTMLEditor
*
aHTMLEditor
)
{
if
(
!
aHTMLEditor
&
&
!
mEditorData
)
{
return
NS_OK
;
}
nsresult
rv
=
EnsureEditorData
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
mEditorData
-
>
SetHTMLEditor
(
aHTMLEditor
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetEditable
(
bool
*
aEditable
)
{
NS_ENSURE_ARG_POINTER
(
aEditable
)
;
*
aEditable
=
mEditorData
&
&
mEditorData
-
>
GetEditable
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetHasEditingSession
(
bool
*
aHasEditingSession
)
{
NS_ENSURE_ARG_POINTER
(
aHasEditingSession
)
;
if
(
mEditorData
)
{
*
aHasEditingSession
=
!
!
mEditorData
-
>
GetEditingSession
(
)
;
}
else
{
*
aHasEditingSession
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
MakeEditable
(
bool
aInWaitForUriLoad
)
{
nsresult
rv
=
EnsureEditorData
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
mEditorData
-
>
MakeEditable
(
aInWaitForUriLoad
)
;
}
void
nsDocShell
:
:
ExtractLastVisit
(
nsIChannel
*
aChannel
nsIURI
*
*
aURI
uint32_t
*
aChannelRedirectFlags
)
{
nsCOMPtr
<
nsIPropertyBag2
>
props
(
do_QueryInterface
(
aChannel
)
)
;
if
(
!
props
)
{
return
;
}
nsresult
rv
=
props
-
>
GetPropertyAsInterface
(
NS_LITERAL_STRING
(
"
docshell
.
previousURI
"
)
NS_GET_IID
(
nsIURI
)
reinterpret_cast
<
void
*
*
>
(
aURI
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
(
void
)
NS_GetReferrerFromChannel
(
aChannel
aURI
)
;
}
else
{
rv
=
props
-
>
GetPropertyAsUint32
(
NS_LITERAL_STRING
(
"
docshell
.
previousFlags
"
)
aChannelRedirectFlags
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Could
not
fetch
previous
flags
URI
will
be
treated
like
referrer
"
)
;
}
}
void
nsDocShell
:
:
SaveLastVisit
(
nsIChannel
*
aChannel
nsIURI
*
aURI
uint32_t
aChannelRedirectFlags
)
{
nsCOMPtr
<
nsIWritablePropertyBag2
>
props
(
do_QueryInterface
(
aChannel
)
)
;
if
(
!
props
|
|
!
aURI
)
{
return
;
}
props
-
>
SetPropertyAsInterface
(
NS_LITERAL_STRING
(
"
docshell
.
previousURI
"
)
aURI
)
;
props
-
>
SetPropertyAsUint32
(
NS_LITERAL_STRING
(
"
docshell
.
previousFlags
"
)
aChannelRedirectFlags
)
;
}
void
nsDocShell
:
:
AddURIVisit
(
nsIURI
*
aURI
nsIURI
*
aPreviousURI
uint32_t
aChannelRedirectFlags
uint32_t
aResponseStatus
)
{
MOZ_ASSERT
(
aURI
"
Visited
URI
is
null
!
"
)
;
MOZ_ASSERT
(
mLoadType
!
=
LOAD_ERROR_PAGE
&
&
mLoadType
!
=
LOAD_BYPASS_HISTORY
"
Do
not
add
error
or
bypass
pages
to
global
history
"
)
;
if
(
mItemType
!
=
typeContent
|
|
!
mUseGlobalHistory
|
|
UsePrivateBrowsing
(
)
)
{
return
;
}
nsCOMPtr
<
IHistory
>
history
=
services
:
:
GetHistoryService
(
)
;
if
(
history
)
{
uint32_t
visitURIFlags
=
0
;
if
(
!
IsFrame
(
)
)
{
visitURIFlags
|
=
IHistory
:
:
TOP_LEVEL
;
}
if
(
aChannelRedirectFlags
&
nsIChannelEventSink
:
:
REDIRECT_TEMPORARY
)
{
visitURIFlags
|
=
IHistory
:
:
REDIRECT_TEMPORARY
;
}
else
if
(
aChannelRedirectFlags
&
nsIChannelEventSink
:
:
REDIRECT_PERMANENT
)
{
visitURIFlags
|
=
IHistory
:
:
REDIRECT_PERMANENT
;
}
else
{
MOZ_ASSERT
(
!
aChannelRedirectFlags
"
One
of
REDIRECT_TEMPORARY
or
REDIRECT_PERMANENT
must
be
set
"
"
if
any
flags
in
aChannelRedirectFlags
is
set
.
"
)
;
}
if
(
aResponseStatus
>
=
300
&
&
aResponseStatus
<
400
)
{
visitURIFlags
|
=
IHistory
:
:
REDIRECT_SOURCE
;
if
(
aResponseStatus
=
=
301
|
|
aResponseStatus
=
=
308
)
{
visitURIFlags
|
=
IHistory
:
:
REDIRECT_SOURCE_PERMANENT
;
}
}
else
if
(
aResponseStatus
!
=
408
&
&
(
(
aResponseStatus
>
=
400
&
&
aResponseStatus
<
=
501
)
|
|
aResponseStatus
=
=
505
)
)
{
visitURIFlags
|
=
IHistory
:
:
UNRECOVERABLE_ERROR
;
}
nsPIDOMWindowOuter
*
outer
=
GetWindow
(
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
widget
:
:
WidgetUtils
:
:
DOMWindowToWidget
(
outer
)
;
(
void
)
history
-
>
VisitURI
(
widget
aURI
aPreviousURI
visitURIFlags
)
;
}
}
void
nsDocShell
:
:
SavePreviousRedirectsAndLastVisit
(
nsIChannel
*
aChannel
nsIURI
*
aPreviousURI
uint32_t
aPreviousFlags
const
nsTArray
<
net
:
:
DocumentChannelRedirect
>
&
aRedirects
)
{
nsCOMPtr
<
nsIURI
>
previousURI
=
aPreviousURI
;
uint32_t
previousFlags
=
aPreviousFlags
;
for
(
auto
&
redirect
:
aRedirects
)
{
if
(
!
redirect
.
isPost
(
)
)
{
AddURIVisit
(
redirect
.
uri
(
)
previousURI
previousFlags
redirect
.
responseStatus
(
)
)
;
previousURI
=
redirect
.
uri
(
)
;
previousFlags
=
redirect
.
redirectFlags
(
)
;
}
}
SaveLastVisit
(
aChannel
previousURI
previousFlags
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetLoadType
(
uint32_t
aLoadType
)
{
mLoadType
=
aLoadType
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetLoadType
(
uint32_t
*
aLoadType
)
{
*
aLoadType
=
mLoadType
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
ConfirmRepost
(
bool
*
aRepost
)
{
if
(
StaticPrefs
:
:
dom_confirm_repost_testing_always_accept
(
)
)
{
*
aRepost
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
nsIPrompt
>
prompter
;
CallGetInterface
(
this
static_cast
<
nsIPrompt
*
*
>
(
getter_AddRefs
(
prompter
)
)
)
;
if
(
!
prompter
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIStringBundleService
>
stringBundleService
=
mozilla
:
:
services
:
:
GetStringBundleService
(
)
;
if
(
!
stringBundleService
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIStringBundle
>
appBundle
;
nsresult
rv
=
stringBundleService
-
>
CreateBundle
(
kAppstringsBundleURL
getter_AddRefs
(
appBundle
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIStringBundle
>
brandBundle
;
rv
=
stringBundleService
-
>
CreateBundle
(
kBrandBundleURL
getter_AddRefs
(
brandBundle
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
prompter
&
&
brandBundle
&
&
appBundle
"
Unable
to
set
up
repost
prompter
.
"
)
;
AutoTArray
<
nsString
1
>
formatStrings
;
rv
=
brandBundle
-
>
GetStringFromName
(
"
brandShortName
"
*
formatStrings
.
AppendElement
(
)
)
;
nsAutoString
msgString
button0Title
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
appBundle
-
>
GetStringFromName
(
"
confirmRepostPrompt
"
msgString
)
;
}
else
{
rv
=
appBundle
-
>
FormatStringFromName
(
"
confirmRepostPrompt
"
formatStrings
msgString
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
appBundle
-
>
GetStringFromName
(
"
resendButton
.
label
"
button0Title
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
nsCOMPtr
<
nsIWritablePropertyBag2
>
promptBag
=
do_QueryInterface
(
prompter
)
)
{
promptBag
-
>
SetPropertyAsBool
(
NS_LITERAL_STRING
(
"
allowTabModal
"
)
true
)
;
}
int32_t
buttonPressed
;
bool
checkState
=
false
;
rv
=
prompter
-
>
ConfirmEx
(
nullptr
msgString
.
get
(
)
(
nsIPrompt
:
:
BUTTON_POS_0
*
nsIPrompt
:
:
BUTTON_TITLE_IS_STRING
)
+
(
nsIPrompt
:
:
BUTTON_POS_1
*
nsIPrompt
:
:
BUTTON_TITLE_CANCEL
)
button0Title
.
get
(
)
nullptr
nullptr
nullptr
&
checkState
&
buttonPressed
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aRepost
=
(
buttonPressed
=
=
0
)
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
GetPromptAndStringBundle
(
nsIPrompt
*
*
aPrompt
nsIStringBundle
*
*
aStringBundle
)
{
NS_ENSURE_SUCCESS
(
GetInterface
(
NS_GET_IID
(
nsIPrompt
)
(
void
*
*
)
aPrompt
)
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIStringBundleService
>
stringBundleService
=
mozilla
:
:
services
:
:
GetStringBundleService
(
)
;
NS_ENSURE_TRUE
(
stringBundleService
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
stringBundleService
-
>
CreateBundle
(
kAppstringsBundleURL
aStringBundle
)
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
nsIScrollableFrame
*
nsDocShell
:
:
GetRootScrollFrame
(
)
{
PresShell
*
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
nullptr
)
;
return
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
}
nsresult
nsDocShell
:
:
EnsureScriptEnvironment
(
)
{
if
(
mScriptGlobal
)
{
return
NS_OK
;
}
if
(
mIsBeingDestroyed
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
#
ifdef
DEBUG
NS_ASSERTION
(
!
mInEnsureScriptEnv
"
Infinite
loop
!
Calling
EnsureScriptEnvironment
(
)
from
"
"
within
EnsureScriptEnvironment
(
)
!
"
)
;
AutoRestore
<
bool
>
boolSetter
(
mInEnsureScriptEnv
)
;
mInEnsureScriptEnv
=
true
;
#
endif
nsCOMPtr
<
nsIWebBrowserChrome
>
browserChrome
(
do_GetInterface
(
mTreeOwner
)
)
;
NS_ENSURE_TRUE
(
browserChrome
NS_ERROR_NOT_AVAILABLE
)
;
uint32_t
chromeFlags
;
browserChrome
-
>
GetChromeFlags
(
&
chromeFlags
)
;
mScriptGlobal
=
nsGlobalWindowOuter
:
:
Create
(
this
mItemType
=
=
typeChrome
)
;
MOZ_ASSERT
(
mScriptGlobal
)
;
return
mScriptGlobal
-
>
EnsureScriptEnvironment
(
)
;
}
nsresult
nsDocShell
:
:
EnsureEditorData
(
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
bool
openDocHasDetachedEditor
=
mOSHE
&
&
mOSHE
-
>
HasDetachedEditor
(
)
;
if
(
!
mEditorData
&
&
!
mIsBeingDestroyed
&
&
!
openDocHasDetachedEditor
)
{
mEditorData
=
MakeUnique
<
nsDocShellEditorData
>
(
this
)
;
}
return
mEditorData
?
NS_OK
:
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
nsDocShell
:
:
EnsureFind
(
)
{
if
(
!
mFind
)
{
mFind
=
new
nsWebBrowserFind
(
)
;
}
nsIScriptGlobalObject
*
scriptGO
=
GetScriptGlobalObject
(
)
;
NS_ENSURE_TRUE
(
scriptGO
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
ourWindow
=
do_QueryInterface
(
scriptGO
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
windowToSearch
;
nsFocusManager
:
:
GetFocusedDescendant
(
ourWindow
nsFocusManager
:
:
eIncludeAllDescendants
getter_AddRefs
(
windowToSearch
)
)
;
nsCOMPtr
<
nsIWebBrowserFindInFrames
>
findInFrames
=
do_QueryInterface
(
mFind
)
;
if
(
!
findInFrames
)
{
return
NS_ERROR_NO_INTERFACE
;
}
nsresult
rv
=
findInFrames
-
>
SetRootSearchFrame
(
ourWindow
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
findInFrames
-
>
SetCurrentSearchFrame
(
windowToSearch
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
bool
nsDocShell
:
:
IsFrame
(
)
{
return
mIsFrame
;
}
NS_IMETHODIMP
nsDocShell
:
:
IsBeingDestroyed
(
bool
*
aDoomed
)
{
NS_ENSURE_ARG
(
aDoomed
)
;
*
aDoomed
=
mIsBeingDestroyed
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsExecutingOnLoadHandler
(
bool
*
aResult
)
{
NS_ENSURE_ARG
(
aResult
)
;
*
aResult
=
mIsExecutingOnLoadHandler
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetLayoutHistoryState
(
nsILayoutHistoryState
*
*
aLayoutHistoryState
)
{
if
(
mOSHE
)
{
nsCOMPtr
<
nsILayoutHistoryState
>
state
=
mOSHE
-
>
GetLayoutHistoryState
(
)
;
state
.
forget
(
aLayoutHistoryState
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetLayoutHistoryState
(
nsILayoutHistoryState
*
aLayoutHistoryState
)
{
if
(
mOSHE
)
{
mOSHE
-
>
SetLayoutHistoryState
(
aLayoutHistoryState
)
;
}
return
NS_OK
;
}
nsDocShell
:
:
InterfaceRequestorProxy
:
:
InterfaceRequestorProxy
(
nsIInterfaceRequestor
*
aRequestor
)
{
if
(
aRequestor
)
{
mWeakPtr
=
do_GetWeakReference
(
aRequestor
)
;
}
}
nsDocShell
:
:
InterfaceRequestorProxy
:
:
~
InterfaceRequestorProxy
(
)
{
mWeakPtr
=
nullptr
;
}
NS_IMPL_ISUPPORTS
(
nsDocShell
:
:
InterfaceRequestorProxy
nsIInterfaceRequestor
)
NS_IMETHODIMP
nsDocShell
:
:
InterfaceRequestorProxy
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
NS_ENSURE_ARG_POINTER
(
aSink
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
ifReq
=
do_QueryReferent
(
mWeakPtr
)
;
if
(
ifReq
)
{
return
ifReq
-
>
GetInterface
(
aIID
aSink
)
;
}
*
aSink
=
nullptr
;
return
NS_NOINTERFACE
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAuthPrompt
(
uint32_t
aPromptReason
const
nsIID
&
aIID
void
*
*
aResult
)
{
bool
priorityPrompt
=
(
aPromptReason
=
=
PROMPT_PROXY
)
;
if
(
!
mAllowAuth
&
&
!
priorityPrompt
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
wwatch
=
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
EnsureScriptEnvironment
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
wwatch
-
>
GetPrompt
(
mScriptGlobal
aIID
reinterpret_cast
<
void
*
*
>
(
aResult
)
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAssociatedWindow
(
mozIDOMWindowProxy
*
*
aWindow
)
{
CallGetInterface
(
this
aWindow
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetTopWindow
(
mozIDOMWindowProxy
*
*
aWindow
)
{
return
mBrowsingContext
-
>
GetTopWindow
(
aWindow
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetTopFrameElement
(
Element
*
*
aElement
)
{
return
mBrowsingContext
-
>
GetTopFrameElement
(
aElement
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetNestedFrameId
(
uint64_t
*
aId
)
{
return
mBrowsingContext
-
>
GetNestedFrameId
(
aId
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetUseTrackingProtection
(
bool
*
aUseTrackingProtection
)
{
return
mBrowsingContext
-
>
GetUseTrackingProtection
(
aUseTrackingProtection
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetUseTrackingProtection
(
bool
aUseTrackingProtection
)
{
return
mBrowsingContext
-
>
SetUseTrackingProtection
(
aUseTrackingProtection
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsContent
(
bool
*
aIsContent
)
{
*
aIsContent
=
(
mItemType
=
=
typeContent
)
;
return
NS_OK
;
}
bool
nsDocShell
:
:
IsOKToLoadURI
(
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aURI
"
Must
have
a
URI
!
"
)
;
if
(
!
mFiredUnloadEvent
)
{
return
true
;
}
if
(
!
mLoadingURI
)
{
return
false
;
}
bool
isPrivateWin
=
false
;
Document
*
doc
=
GetDocument
(
)
;
if
(
doc
)
{
isPrivateWin
=
doc
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
.
mPrivateBrowsingId
>
0
;
}
nsCOMPtr
<
nsIScriptSecurityManager
>
secMan
=
do_GetService
(
NS_SCRIPTSECURITYMANAGER_CONTRACTID
)
;
return
secMan
&
&
NS_SUCCEEDED
(
secMan
-
>
CheckSameOriginURI
(
aURI
mLoadingURI
false
isPrivateWin
)
)
;
}
nsresult
nsDocShell
:
:
GetControllerForCommand
(
const
char
*
aCommand
nsIController
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
nullptr
;
NS_ENSURE_TRUE
(
mScriptGlobal
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsPIWindowRoot
>
root
=
mScriptGlobal
-
>
GetTopWindowRoot
(
)
;
NS_ENSURE_TRUE
(
root
NS_ERROR_FAILURE
)
;
return
root
-
>
GetControllerForCommand
(
aCommand
false
aResult
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
IsCommandEnabled
(
const
char
*
aCommand
bool
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
false
;
nsresult
rv
=
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIController
>
controller
;
rv
=
GetControllerForCommand
(
aCommand
getter_AddRefs
(
controller
)
)
;
if
(
controller
)
{
rv
=
controller
-
>
IsCommandEnabled
(
aCommand
aResult
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsDocShell
:
:
DoCommand
(
const
char
*
aCommand
)
{
nsresult
rv
=
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIController
>
controller
;
rv
=
GetControllerForCommand
(
aCommand
getter_AddRefs
(
controller
)
)
;
if
(
controller
)
{
rv
=
controller
-
>
DoCommand
(
aCommand
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsDocShell
:
:
DoCommandWithParams
(
const
char
*
aCommand
nsICommandParams
*
aParams
)
{
nsCOMPtr
<
nsIController
>
controller
;
nsresult
rv
=
GetControllerForCommand
(
aCommand
getter_AddRefs
(
controller
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsICommandController
>
commandController
=
do_QueryInterface
(
controller
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
commandController
-
>
DoCommandWithParams
(
aCommand
aParams
)
;
}
nsresult
nsDocShell
:
:
EnsureCommandHandler
(
)
{
if
(
!
mCommandManager
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
GetWindow
(
)
)
{
mCommandManager
=
new
nsCommandManager
(
domWindow
)
;
}
}
return
mCommandManager
?
NS_OK
:
NS_ERROR_FAILURE
;
}
class
OnLinkClickEvent
:
public
Runnable
{
public
:
OnLinkClickEvent
(
nsDocShell
*
aHandler
nsIContent
*
aContent
nsIURI
*
aURI
const
nsAString
&
aTargetSpec
const
nsAString
&
aFileName
nsIInputStream
*
aPostDataStream
nsIInputStream
*
aHeadersDataStream
bool
aNoOpenerImplied
bool
aIsUserTriggered
bool
aIsTrusted
nsIPrincipal
*
aTriggeringPrincipal
nsIContentSecurityPolicy
*
aCsp
)
;
NS_IMETHOD
Run
(
)
override
{
AutoPopupStatePusher
popupStatePusher
(
mPopupState
)
;
AutoJSAPI
jsapi
;
if
(
mIsTrusted
|
|
jsapi
.
Init
(
mContent
-
>
OwnerDoc
(
)
-
>
GetScopeObject
(
)
)
)
{
mHandler
-
>
OnLinkClickSync
(
mContent
mURI
mTargetSpec
mFileName
mPostDataStream
mHeadersDataStream
mNoOpenerImplied
nullptr
nullptr
mIsUserTriggered
mTriggeringPrincipal
mCsp
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
nsDocShell
>
mHandler
;
nsCOMPtr
<
nsIURI
>
mURI
;
nsString
mTargetSpec
;
nsString
mFileName
;
nsCOMPtr
<
nsIInputStream
>
mPostDataStream
;
nsCOMPtr
<
nsIInputStream
>
mHeadersDataStream
;
nsCOMPtr
<
nsIContent
>
mContent
;
PopupBlocker
:
:
PopupControlState
mPopupState
;
bool
mNoOpenerImplied
;
bool
mIsUserTriggered
;
bool
mIsTrusted
;
nsCOMPtr
<
nsIPrincipal
>
mTriggeringPrincipal
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
mCsp
;
}
;
OnLinkClickEvent
:
:
OnLinkClickEvent
(
nsDocShell
*
aHandler
nsIContent
*
aContent
nsIURI
*
aURI
const
nsAString
&
aTargetSpec
const
nsAString
&
aFileName
nsIInputStream
*
aPostDataStream
nsIInputStream
*
aHeadersDataStream
bool
aNoOpenerImplied
bool
aIsUserTriggered
bool
aIsTrusted
nsIPrincipal
*
aTriggeringPrincipal
nsIContentSecurityPolicy
*
aCsp
)
:
mozilla
:
:
Runnable
(
"
OnLinkClickEvent
"
)
mHandler
(
aHandler
)
mURI
(
aURI
)
mTargetSpec
(
aTargetSpec
)
mFileName
(
aFileName
)
mPostDataStream
(
aPostDataStream
)
mHeadersDataStream
(
aHeadersDataStream
)
mContent
(
aContent
)
mPopupState
(
PopupBlocker
:
:
GetPopupControlState
(
)
)
mNoOpenerImplied
(
aNoOpenerImplied
)
mIsUserTriggered
(
aIsUserTriggered
)
mIsTrusted
(
aIsTrusted
)
mTriggeringPrincipal
(
aTriggeringPrincipal
)
mCsp
(
aCsp
)
{
}
nsresult
nsDocShell
:
:
OnLinkClick
(
nsIContent
*
aContent
nsIURI
*
aURI
const
nsAString
&
aTargetSpec
const
nsAString
&
aFileName
nsIInputStream
*
aPostDataStream
nsIInputStream
*
aHeadersDataStream
bool
aIsUserTriggered
bool
aIsTrusted
nsIPrincipal
*
aTriggeringPrincipal
nsIContentSecurityPolicy
*
aCsp
)
{
#
ifndef
ANDROID
MOZ_ASSERT
(
aTriggeringPrincipal
"
Need
a
valid
triggeringPrincipal
"
)
;
#
endif
NS_ASSERTION
(
NS_IsMainThread
(
)
"
wrong
thread
"
)
;
if
(
!
IsNavigationAllowed
(
)
|
|
!
IsOKToLoadURI
(
aURI
)
)
{
return
NS_OK
;
}
if
(
ShouldBlockLoadingForBackButton
(
)
)
{
return
NS_OK
;
}
if
(
aContent
-
>
IsEditable
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
NS_ERROR_FAILURE
;
nsAutoString
target
;
nsCOMPtr
<
nsIWebBrowserChrome3
>
browserChrome3
=
do_GetInterface
(
mTreeOwner
)
;
bool
noOpenerImplied
=
false
;
if
(
browserChrome3
)
{
rv
=
browserChrome3
-
>
OnBeforeLinkTraversal
(
aTargetSpec
aURI
aContent
mIsAppTab
target
)
;
if
(
!
aTargetSpec
.
Equals
(
target
)
)
{
noOpenerImplied
=
true
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
target
=
aTargetSpec
;
}
nsCOMPtr
<
nsIRunnable
>
ev
=
new
OnLinkClickEvent
(
this
aContent
aURI
target
aFileName
aPostDataStream
aHeadersDataStream
noOpenerImplied
aIsUserTriggered
aIsTrusted
aTriggeringPrincipal
aCsp
)
;
return
DispatchToTabGroup
(
TaskCategory
:
:
UI
ev
.
forget
(
)
)
;
}
static
bool
IsElementAnchorOrArea
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
a
nsGkAtoms
:
:
area
)
;
}
nsresult
nsDocShell
:
:
OnLinkClickSync
(
nsIContent
*
aContent
nsIURI
*
aURI
const
nsAString
&
aTargetSpec
const
nsAString
&
aFileName
nsIInputStream
*
aPostDataStream
nsIInputStream
*
aHeadersDataStream
bool
aNoOpenerImplied
nsIDocShell
*
*
aDocShell
nsIRequest
*
*
aRequest
bool
aIsUserTriggered
nsIPrincipal
*
aTriggeringPrincipal
nsIContentSecurityPolicy
*
aCsp
)
{
if
(
aDocShell
)
{
*
aDocShell
=
nullptr
;
}
if
(
aRequest
)
{
*
aRequest
=
nullptr
;
}
if
(
!
IsNavigationAllowed
(
)
|
|
!
IsOKToLoadURI
(
aURI
)
)
{
return
NS_OK
;
}
if
(
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
form
)
&
&
ShouldBlockLoadingForBackButton
(
)
)
{
return
NS_OK
;
}
if
(
aContent
-
>
IsEditable
(
)
)
{
return
NS_OK
;
}
{
nsCOMPtr
<
nsIExternalProtocolService
>
extProtService
=
do_GetService
(
NS_EXTERNALPROTOCOLSERVICE_CONTRACTID
)
;
if
(
extProtService
)
{
nsAutoCString
scheme
;
aURI
-
>
GetScheme
(
scheme
)
;
if
(
!
scheme
.
IsEmpty
(
)
)
{
bool
isExposed
;
nsresult
rv
=
extProtService
-
>
IsExposedProtocol
(
scheme
.
get
(
)
&
isExposed
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
isExposed
)
{
return
extProtService
-
>
LoadURI
(
aURI
this
)
;
}
}
}
}
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
aTriggeringPrincipal
?
aTriggeringPrincipal
:
aContent
-
>
NodePrincipal
(
)
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aCsp
;
if
(
!
csp
)
{
csp
=
aContent
-
>
GetCsp
(
)
;
}
uint32_t
flags
=
INTERNAL_LOAD_FLAGS_NONE
;
bool
isElementAnchorOrArea
=
IsElementAnchorOrArea
(
aContent
)
;
if
(
isElementAnchorOrArea
)
{
MOZ_ASSERT
(
aContent
-
>
IsHTMLElement
(
)
)
;
nsAutoString
relString
;
aContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
rel
relString
)
;
nsWhitespaceTokenizerTemplate
<
nsContentUtils
:
:
IsHTMLWhitespace
>
tok
(
relString
)
;
bool
targetBlank
=
aTargetSpec
.
LowerCaseEqualsLiteral
(
"
_blank
"
)
;
bool
explicitOpenerSet
=
false
;
while
(
tok
.
hasMoreTokens
(
)
)
{
const
nsAString
&
token
=
tok
.
nextToken
(
)
;
if
(
token
.
LowerCaseEqualsLiteral
(
"
noreferrer
"
)
)
{
flags
|
=
INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER
|
INTERNAL_LOAD_FLAGS_NO_OPENER
;
explicitOpenerSet
=
true
;
break
;
}
if
(
token
.
LowerCaseEqualsLiteral
(
"
noopener
"
)
)
{
flags
|
=
INTERNAL_LOAD_FLAGS_NO_OPENER
;
explicitOpenerSet
=
true
;
}
if
(
targetBlank
&
&
StaticPrefs
:
:
dom_targetBlankNoOpener_enabled
(
)
&
&
token
.
LowerCaseEqualsLiteral
(
"
opener
"
)
&
&
!
explicitOpenerSet
)
{
explicitOpenerSet
=
true
;
}
}
if
(
targetBlank
&
&
StaticPrefs
:
:
dom_targetBlankNoOpener_enabled
(
)
&
&
!
explicitOpenerSet
&
&
!
triggeringPrincipal
-
>
IsSystemPrincipal
(
)
)
{
flags
|
=
INTERNAL_LOAD_FLAGS_NO_OPENER
;
}
if
(
aNoOpenerImplied
)
{
flags
|
=
INTERNAL_LOAD_FLAGS_NO_OPENER
;
}
}
RefPtr
<
Document
>
referrerDoc
=
aContent
-
>
OwnerDoc
(
)
;
NS_ENSURE_TRUE
(
referrerDoc
NS_ERROR_UNEXPECTED
)
;
nsPIDOMWindowInner
*
referrerInner
=
referrerDoc
-
>
GetInnerWindow
(
)
;
NS_ENSURE_TRUE
(
referrerInner
NS_ERROR_UNEXPECTED
)
;
if
(
!
mScriptGlobal
|
|
mScriptGlobal
-
>
GetCurrentInnerWindow
(
)
!
=
referrerInner
)
{
return
NS_OK
;
}
nsAutoString
typeHint
;
RefPtr
<
HTMLAnchorElement
>
anchor
=
HTMLAnchorElement
:
:
FromNode
(
aContent
)
;
if
(
anchor
)
{
anchor
-
>
GetType
(
typeHint
)
;
NS_ConvertUTF16toUTF8
utf8Hint
(
typeHint
)
;
nsAutoCString
type
dummy
;
NS_ParseRequestContentType
(
utf8Hint
type
dummy
)
;
CopyUTF8toUTF16
(
type
typeHint
)
;
}
bool
inOnLoadHandler
=
false
;
GetIsExecutingOnLoadHandler
(
&
inOnLoadHandler
)
;
uint32_t
loadType
=
inOnLoadHandler
?
LOAD_NORMAL_REPLACE
:
LOAD_LINK
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
new
ReferrerInfo
(
)
;
if
(
isElementAnchorOrArea
)
{
referrerInfo
-
>
InitWithNode
(
aContent
)
;
}
else
{
referrerInfo
-
>
InitWithDocument
(
referrerDoc
)
;
}
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
aURI
)
;
loadState
-
>
SetReferrerInfo
(
referrerInfo
)
;
loadState
-
>
SetTriggeringPrincipal
(
triggeringPrincipal
)
;
loadState
-
>
SetPrincipalToInherit
(
aContent
-
>
NodePrincipal
(
)
)
;
loadState
-
>
SetCsp
(
csp
)
;
loadState
-
>
SetLoadFlags
(
flags
)
;
loadState
-
>
SetTarget
(
aTargetSpec
)
;
loadState
-
>
SetTypeHint
(
NS_ConvertUTF16toUTF8
(
typeHint
)
)
;
loadState
-
>
SetFileName
(
aFileName
)
;
loadState
-
>
SetPostDataStream
(
aPostDataStream
)
;
loadState
-
>
SetHeadersStream
(
aHeadersDataStream
)
;
loadState
-
>
SetLoadType
(
loadType
)
;
loadState
-
>
SetFirstParty
(
true
)
;
loadState
-
>
SetSourceDocShell
(
this
)
;
loadState
-
>
SetIsFormSubmission
(
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
form
)
)
;
nsresult
rv
=
InternalLoad
(
loadState
aDocShell
aRequest
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsPingListener
:
:
DispatchPings
(
this
aContent
aURI
referrerInfo
)
;
}
return
rv
;
}
nsresult
nsDocShell
:
:
OnOverLink
(
nsIContent
*
aContent
nsIURI
*
aURI
const
nsAString
&
aTargetSpec
)
{
if
(
aContent
-
>
IsEditable
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIWebBrowserChrome
>
browserChrome
=
do_GetInterface
(
mTreeOwner
)
;
if
(
!
browserChrome
)
{
return
rv
;
}
nsCOMPtr
<
nsIURI
>
exposableURI
=
nsIOService
:
:
CreateExposableURI
(
aURI
)
;
nsAutoCString
spec
;
rv
=
exposableURI
-
>
GetDisplaySpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ConvertUTF8toUTF16
uStr
(
spec
)
;
PredictorPredict
(
aURI
mCurrentURI
nsINetworkPredictor
:
:
PREDICT_LINK
aContent
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
nullptr
)
;
rv
=
browserChrome
-
>
SetLinkStatus
(
uStr
)
;
return
rv
;
}
nsresult
nsDocShell
:
:
OnLeaveLink
(
)
{
nsCOMPtr
<
nsIWebBrowserChrome
>
browserChrome
(
do_GetInterface
(
mTreeOwner
)
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
if
(
browserChrome
)
{
rv
=
browserChrome
-
>
SetLinkStatus
(
EmptyString
(
)
)
;
}
return
rv
;
}
bool
nsDocShell
:
:
ShouldBlockLoadingForBackButton
(
)
{
if
(
!
(
mLoadType
&
LOAD_CMD_HISTORY
)
|
|
UserActivation
:
:
IsHandlingUserInput
(
)
|
|
!
Preferences
:
:
GetBool
(
"
accessibility
.
blockjsredirection
"
)
)
{
return
false
;
}
bool
canGoForward
=
false
;
GetCanGoForward
(
&
canGoForward
)
;
return
canGoForward
;
}
bool
nsDocShell
:
:
PluginsAllowedInCurrentDoc
(
)
{
if
(
!
mContentViewer
)
{
return
false
;
}
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
false
;
}
return
doc
-
>
GetAllowPlugins
(
)
;
}
nsresult
nsDocShell
:
:
CharsetChangeReloadDocument
(
const
char
*
aCharset
int32_t
aSource
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
;
NS_ENSURE_SUCCESS
(
GetContentViewer
(
getter_AddRefs
(
cv
)
)
NS_ERROR_FAILURE
)
;
if
(
cv
)
{
int32_t
hint
;
cv
-
>
GetHintCharacterSetSource
(
&
hint
)
;
if
(
aSource
>
hint
)
{
nsCString
charset
(
aCharset
)
;
cv
-
>
SetHintCharacterSet
(
charset
)
;
cv
-
>
SetHintCharacterSetSource
(
aSource
)
;
if
(
eCharsetReloadRequested
!
=
mCharsetReloadState
)
{
mCharsetReloadState
=
eCharsetReloadRequested
;
switch
(
mLoadType
)
{
case
LOAD_RELOAD_BYPASS_PROXY_AND_CACHE
:
return
Reload
(
LOAD_FLAGS_CHARSET_CHANGE
|
LOAD_FLAGS_BYPASS_CACHE
|
LOAD_FLAGS_BYPASS_PROXY
)
;
case
LOAD_RELOAD_BYPASS_CACHE
:
return
Reload
(
LOAD_FLAGS_CHARSET_CHANGE
|
LOAD_FLAGS_BYPASS_CACHE
)
;
default
:
return
Reload
(
LOAD_FLAGS_CHARSET_CHANGE
)
;
}
}
}
}
return
NS_ERROR_DOCSHELL_REQUEST_REJECTED
;
}
nsresult
nsDocShell
:
:
CharsetChangeStopDocumentLoad
(
)
{
if
(
eCharsetReloadRequested
!
=
mCharsetReloadState
)
{
Stop
(
nsIWebNavigation
:
:
STOP_ALL
)
;
return
NS_OK
;
}
return
NS_ERROR_DOCSHELL_REQUEST_REJECTED
;
}
void
nsDocShell
:
:
SetIsPrinting
(
bool
aIsPrinting
)
{
mIsPrintingOrPP
=
aIsPrinting
;
}
NS_IMETHODIMP
nsDocShell
:
:
InitOrReusePrintPreviewViewer
(
nsIWebBrowserPrint
*
*
aPrintPreview
)
{
*
aPrintPreview
=
nullptr
;
#
if
NS_PRINT_PREVIEW
nsCOMPtr
<
nsIDocumentViewerPrint
>
print
=
do_QueryInterface
(
mContentViewer
)
;
if
(
!
print
|
|
!
print
-
>
IsInitializedForPrintPreview
(
)
)
{
Stop
(
nsIWebNavigation
:
:
STOP_ALL
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
this
)
;
nsCOMPtr
<
nsIURI
>
uri
;
NS_NewURI
(
getter_AddRefs
(
uri
)
NS_LITERAL_CSTRING
(
"
about
:
printpreview
"
)
)
;
nsresult
rv
=
CreateAboutBlankContentViewer
(
principal
principal
nullptr
uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SetCurrentURI
(
uri
nullptr
true
0
)
;
print
=
do_QueryInterface
(
mContentViewer
)
;
NS_ENSURE_STATE
(
print
)
;
print
-
>
InitializeForPrintPreview
(
)
;
}
nsCOMPtr
<
nsIWebBrowserPrint
>
result
=
do_QueryInterface
(
print
)
;
result
.
forget
(
aPrintPreview
)
;
return
NS_OK
;
#
else
return
NS_ERROR_NOT_IMPLEMENTED
;
#
endif
}
NS_IMETHODIMP
nsDocShell
:
:
ExitPrintPreview
(
)
{
#
if
NS_PRINT_PREVIEW
#
ifdef
DEBUG
nsCOMPtr
<
nsIDocumentViewerPrint
>
vp
=
do_QueryInterface
(
mContentViewer
)
;
MOZ_ASSERT
(
vp
&
&
vp
-
>
IsInitializedForPrintPreview
(
)
)
;
#
endif
nsCOMPtr
<
nsIWebBrowserPrint
>
viewer
=
do_QueryInterface
(
mContentViewer
)
;
return
viewer
-
>
ExitPrintPreview
(
)
;
#
else
return
NS_OK
;
#
endif
}
#
ifdef
DEBUG
unsigned
long
nsDocShell
:
:
gNumberOfDocShells
=
0
;
#
endif
NS_IMETHODIMP
nsDocShell
:
:
GetCanExecuteScripts
(
bool
*
aResult
)
{
*
aResult
=
mCanExecuteScripts
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetFrameType
(
FrameType
aFrameType
)
{
mFrameType
=
aFrameType
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetFrameType
(
FrameType
*
aFrameType
)
{
*
aFrameType
=
mFrameType
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsMozBrowser
(
bool
*
aIsMozBrowser
)
{
*
aIsMozBrowser
=
(
mFrameType
=
=
FRAME_TYPE_BROWSER
)
;
return
NS_OK
;
}
uint32_t
nsDocShell
:
:
GetInheritedFrameType
(
)
{
if
(
mFrameType
!
=
FRAME_TYPE_REGULAR
)
{
return
mFrameType
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parentAsItem
;
GetInProcessSameTypeParent
(
getter_AddRefs
(
parentAsItem
)
)
;
nsCOMPtr
<
nsIDocShell
>
parent
=
do_QueryInterface
(
parentAsItem
)
;
if
(
!
parent
)
{
return
FRAME_TYPE_REGULAR
;
}
return
static_cast
<
nsDocShell
*
>
(
parent
.
get
(
)
)
-
>
GetInheritedFrameType
(
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsInMozBrowser
(
bool
*
aIsInMozBrowser
)
{
*
aIsInMozBrowser
=
(
GetInheritedFrameType
(
)
=
=
FRAME_TYPE_BROWSER
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsTopLevelContentDocShell
(
bool
*
aIsTopLevelContentDocShell
)
{
*
aIsTopLevelContentDocShell
=
false
;
if
(
mItemType
=
=
typeContent
)
{
*
aIsTopLevelContentDocShell
=
mBrowsingContext
-
>
IsTopContent
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetScriptableOriginAttributes
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
)
{
return
mBrowsingContext
-
>
GetScriptableOriginAttributes
(
aCx
aVal
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetOriginAttributes
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
)
{
return
mBrowsingContext
-
>
GetScriptableOriginAttributes
(
aCx
aVal
)
;
}
bool
nsDocShell
:
:
ServiceWorkerAllowedToControlWindow
(
nsIPrincipal
*
aPrincipal
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
aURI
)
;
if
(
UsePrivateBrowsing
(
)
|
|
mBrowsingContext
-
>
GetSandboxFlags
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
GetInProcessSameTypeParent
(
getter_AddRefs
(
parent
)
)
;
nsPIDOMWindowOuter
*
parentOuter
=
parent
?
parent
-
>
GetWindow
(
)
:
nullptr
;
nsPIDOMWindowInner
*
parentInner
=
parentOuter
?
parentOuter
-
>
GetCurrentInnerWindow
(
)
:
nullptr
;
StorageAccess
storage
=
StorageAllowedForNewWindow
(
aPrincipal
aURI
parentInner
)
;
return
storage
=
=
StorageAccess
:
:
eAllow
;
}
nsresult
nsDocShell
:
:
SetOriginAttributes
(
const
OriginAttributes
&
aAttrs
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
return
mBrowsingContext
-
>
SetOriginAttributes
(
aAttrs
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
ResumeRedirectedLoad
(
uint64_t
aIdentifier
int32_t
aHistoryIndex
)
{
RefPtr
<
nsDocShell
>
self
=
this
;
RefPtr
<
ChildProcessChannelListener
>
cpcl
=
ChildProcessChannelListener
:
:
GetSingleton
(
)
;
cpcl
-
>
RegisterCallback
(
aIdentifier
[
self
aHistoryIndex
]
(
nsDocShellLoadState
*
aLoadState
nsTArray
<
net
:
:
DocumentChannelRedirect
>
&
&
aRedirects
nsDOMNavigationTiming
*
aTiming
)
{
MOZ_ASSERT
(
aLoadState
-
>
GetPendingRedirectedChannel
(
)
)
;
if
(
NS_WARN_IF
(
self
-
>
mIsBeingDestroyed
)
)
{
aLoadState
-
>
GetPendingRedirectedChannel
(
)
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
return
NS_BINDING_ABORTED
;
}
self
-
>
mLoadType
=
aLoadState
-
>
LoadType
(
)
;
nsCOMPtr
<
nsIURI
>
previousURI
;
uint32_t
previousFlags
=
0
;
ExtractLastVisit
(
aLoadState
-
>
GetPendingRedirectedChannel
(
)
getter_AddRefs
(
previousURI
)
&
previousFlags
)
;
self
-
>
SavePreviousRedirectsAndLastVisit
(
aLoadState
-
>
GetPendingRedirectedChannel
(
)
previousURI
previousFlags
aRedirects
)
;
MOZ_ASSERT
(
(
self
-
>
mCurrentURI
&
&
NS_IsAboutBlank
(
self
-
>
mCurrentURI
)
)
|
|
!
self
-
>
mTiming
"
timing
object
can
'
t
already
exists
in
non
-
about
:
blank
loads
"
)
;
self
-
>
mTiming
=
new
nsDOMNavigationTiming
(
self
aTiming
)
;
if
(
aHistoryIndex
>
=
0
&
&
self
-
>
mSessionHistory
)
{
nsCOMPtr
<
nsISHistory
>
legacySHistory
=
self
-
>
mSessionHistory
-
>
LegacySHistory
(
)
;
nsCOMPtr
<
nsISHEntry
>
entry
;
nsresult
rv
=
legacySHistory
-
>
GetEntryAtIndex
(
aHistoryIndex
getter_AddRefs
(
entry
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
legacySHistory
-
>
InternalSetRequestedIndex
(
aHistoryIndex
)
;
aLoadState
-
>
SetLoadType
(
LOAD_HISTORY
)
;
aLoadState
-
>
SetSHEntry
(
entry
)
;
}
}
self
-
>
InternalLoad
(
aLoadState
nullptr
nullptr
)
;
bool
pending
=
false
;
aLoadState
-
>
GetPendingRedirectedChannel
(
)
-
>
IsPending
(
&
pending
)
;
NS_ASSERTION
(
pending
"
We
should
have
connected
the
pending
channel
!
"
)
;
if
(
!
pending
)
{
return
NS_BINDING_ABORTED
;
}
return
NS_OK
;
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetOriginAttributes
(
JS
:
:
Handle
<
JS
:
:
Value
>
aOriginAttributes
JSContext
*
aCx
)
{
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
SetOriginAttributes
(
attrs
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetOSHEId
(
uint32_t
*
aSHEntryId
)
{
if
(
mOSHE
)
{
mOSHE
-
>
GetID
(
aSHEntryId
)
;
return
NS_OK
;
}
else
{
return
NS_ERROR_FAILURE
;
}
}
NS_IMETHODIMP
nsDocShell
:
:
GetAsyncPanZoomEnabled
(
bool
*
aOut
)
{
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
*
aOut
=
presShell
-
>
AsyncPanZoomEnabled
(
)
;
return
NS_OK
;
}
*
aOut
=
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
;
return
NS_OK
;
}
bool
nsDocShell
:
:
HasUnloadedParent
(
)
{
RefPtr
<
nsDocShell
>
parent
=
GetInProcessParentDocshell
(
)
;
while
(
parent
)
{
bool
inUnload
=
false
;
parent
-
>
GetIsInUnload
(
&
inUnload
)
;
if
(
inUnload
)
{
return
true
;
}
parent
=
parent
-
>
GetInProcessParentDocshell
(
)
;
}
return
false
;
}
void
nsDocShell
:
:
UpdateGlobalHistoryTitle
(
nsIURI
*
aURI
)
{
if
(
!
mUseGlobalHistory
|
|
UsePrivateBrowsing
(
)
)
{
return
;
}
if
(
IsFrame
(
)
)
{
return
;
}
if
(
nsCOMPtr
<
IHistory
>
history
=
services
:
:
GetHistoryService
(
)
)
{
history
-
>
SetURITitle
(
aURI
mTitle
)
;
}
}
bool
nsDocShell
:
:
IsInvisible
(
)
{
return
mInvisible
;
}
void
nsDocShell
:
:
SetInvisible
(
bool
aInvisible
)
{
mInvisible
=
aInvisible
;
}
void
nsDocShell
:
:
NotifyJSRunToCompletionStart
(
const
char
*
aReason
const
nsAString
&
aFunctionName
const
nsAString
&
aFilename
const
uint32_t
aLineNumber
JS
:
:
Handle
<
JS
:
:
Value
>
aAsyncStack
const
char
*
aAsyncCause
)
{
if
(
mJSRunToCompletionDepth
=
=
0
)
{
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
if
(
timelines
&
&
timelines
-
>
HasConsumer
(
this
)
)
{
timelines
-
>
AddMarkerForDocShell
(
this
mozilla
:
:
MakeUnique
<
JavascriptTimelineMarker
>
(
aReason
aFunctionName
aFilename
aLineNumber
MarkerTracingType
:
:
START
aAsyncStack
aAsyncCause
)
)
;
}
}
mJSRunToCompletionDepth
+
+
;
}
void
nsDocShell
:
:
NotifyJSRunToCompletionStop
(
)
{
mJSRunToCompletionDepth
-
-
;
if
(
mJSRunToCompletionDepth
=
=
0
)
{
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
if
(
timelines
&
&
timelines
-
>
HasConsumer
(
this
)
)
{
timelines
-
>
AddMarkerForDocShell
(
this
"
Javascript
"
MarkerTracingType
:
:
END
)
;
}
}
}
void
nsDocShell
:
:
MaybeNotifyKeywordSearchLoading
(
const
nsString
&
aProvider
const
nsString
&
aKeyword
)
{
if
(
aProvider
.
IsEmpty
(
)
)
{
return
;
}
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
contentChild
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
if
(
contentChild
)
{
contentChild
-
>
SendNotifyKeywordSearchLoading
(
aProvider
aKeyword
)
;
}
return
;
}
nsCOMPtr
<
nsISearchService
>
searchSvc
=
do_GetService
(
"
mozilla
.
org
/
browser
/
search
-
service
;
1
"
)
;
if
(
searchSvc
)
{
nsCOMPtr
<
nsISearchEngine
>
searchEngine
;
searchSvc
-
>
GetEngineByName
(
aProvider
getter_AddRefs
(
searchEngine
)
)
;
if
(
searchEngine
)
{
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
NotifyObservers
(
searchEngine
"
keyword
-
search
"
aKeyword
.
get
(
)
)
;
}
}
}
}
NS_IMETHODIMP
nsDocShell
:
:
ShouldPrepareForIntercept
(
nsIURI
*
aURI
nsIChannel
*
aChannel
bool
*
aShouldIntercept
)
{
return
mInterceptController
-
>
ShouldPrepareForIntercept
(
aURI
aChannel
aShouldIntercept
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
ChannelIntercepted
(
nsIInterceptedChannel
*
aChannel
)
{
return
mInterceptController
-
>
ChannelIntercepted
(
aChannel
)
;
}
bool
nsDocShell
:
:
InFrameSwap
(
)
{
RefPtr
<
nsDocShell
>
shell
=
this
;
do
{
if
(
shell
-
>
mInFrameSwap
)
{
return
true
;
}
shell
=
shell
-
>
GetInProcessParentDocshell
(
)
;
}
while
(
shell
)
;
return
false
;
}
UniquePtr
<
ClientSource
>
nsDocShell
:
:
TakeInitialClientSource
(
)
{
return
std
:
:
move
(
mInitialClientSource
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
IssueWarning
(
uint32_t
aWarning
bool
aAsError
)
{
if
(
mContentViewer
)
{
RefPtr
<
Document
>
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
doc
-
>
WarnOnceAbout
(
Document
:
:
DeprecatedOperations
(
aWarning
)
aAsError
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetEditingSession
(
nsIEditingSession
*
*
aEditSession
)
{
if
(
!
NS_SUCCEEDED
(
EnsureEditorData
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aEditSession
=
do_AddRef
(
mEditorData
-
>
GetEditingSession
(
)
)
.
take
(
)
;
return
*
aEditSession
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetScriptableBrowserChild
(
nsIBrowserChild
*
*
aBrowserChild
)
{
*
aBrowserChild
=
GetBrowserChild
(
)
.
take
(
)
;
return
*
aBrowserChild
?
NS_OK
:
NS_ERROR_FAILURE
;
}
already_AddRefed
<
nsIBrowserChild
>
nsDocShell
:
:
GetBrowserChild
(
)
{
nsCOMPtr
<
nsIBrowserChild
>
tc
=
do_QueryReferent
(
mBrowserChild
)
;
return
tc
.
forget
(
)
;
}
nsCommandManager
*
nsDocShell
:
:
GetCommandManager
(
)
{
NS_ENSURE_SUCCESS
(
EnsureCommandHandler
(
)
nullptr
)
;
return
mCommandManager
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAwaitingLargeAlloc
(
bool
*
aResult
)
{
MOZ_ASSERT
(
aResult
)
;
nsCOMPtr
<
nsIBrowserChild
>
browserChild
=
GetBrowserChild
(
)
;
if
(
!
browserChild
)
{
*
aResult
=
false
;
return
NS_OK
;
}
*
aResult
=
static_cast
<
BrowserChild
*
>
(
browserChild
.
get
(
)
)
-
>
IsAwaitingLargeAlloc
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
nsDocShell
:
:
GetOriginAttributes
(
mozilla
:
:
OriginAttributes
&
aAttrs
)
{
mBrowsingContext
-
>
GetOriginAttributes
(
aAttrs
)
;
}
HTMLEditor
*
nsIDocShell
:
:
GetHTMLEditor
(
)
{
nsDocShell
*
docShell
=
static_cast
<
nsDocShell
*
>
(
this
)
;
return
docShell
-
>
GetHTMLEditorInternal
(
)
;
}
nsresult
nsIDocShell
:
:
SetHTMLEditor
(
HTMLEditor
*
aHTMLEditor
)
{
nsDocShell
*
docShell
=
static_cast
<
nsDocShell
*
>
(
this
)
;
return
docShell
-
>
SetHTMLEditorInternal
(
aHTMLEditor
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetDisplayMode
(
DisplayMode
*
aDisplayMode
)
{
*
aDisplayMode
=
mDisplayMode
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetDisplayMode
(
DisplayMode
aDisplayMode
)
{
if
(
!
(
aDisplayMode
=
=
nsIDocShell
:
:
DISPLAY_MODE_BROWSER
|
|
aDisplayMode
=
=
nsIDocShell
:
:
DISPLAY_MODE_STANDALONE
|
|
aDisplayMode
=
=
nsIDocShell
:
:
DISPLAY_MODE_FULLSCREEN
|
|
aDisplayMode
=
=
nsIDocShell
:
:
DISPLAY_MODE_MINIMAL_UI
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aDisplayMode
!
=
mDisplayMode
)
{
mDisplayMode
=
aDisplayMode
;
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
presContext
-
>
MediaFeatureValuesChangedAllDocuments
(
{
MediaFeatureChangeReason
:
:
DisplayModeChange
}
)
;
}
return
NS_OK
;
}
#
define
MATRIX_LENGTH
20
NS_IMETHODIMP
nsDocShell
:
:
SetColorMatrix
(
const
nsTArray
<
float
>
&
aMatrix
)
{
if
(
aMatrix
.
Length
(
)
=
=
MATRIX_LENGTH
)
{
mColorMatrix
.
reset
(
new
gfx
:
:
Matrix5x4
(
)
)
;
static_assert
(
MATRIX_LENGTH
*
sizeof
(
float
)
=
=
sizeof
(
mColorMatrix
-
>
components
)
"
Size
mismatch
for
our
memcpy
"
)
;
memcpy
(
mColorMatrix
-
>
components
aMatrix
.
Elements
(
)
sizeof
(
mColorMatrix
-
>
components
)
)
;
}
else
if
(
aMatrix
.
Length
(
)
=
=
0
)
{
mColorMatrix
.
reset
(
)
;
}
else
{
return
NS_ERROR_INVALID_ARG
;
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
NS_ERROR_FAILURE
;
}
nsIFrame
*
frame
=
presShell
-
>
GetRootFrame
(
)
;
if
(
!
frame
)
{
return
NS_ERROR_FAILURE
;
}
frame
-
>
SchedulePaint
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetColorMatrix
(
nsTArray
<
float
>
&
aMatrix
)
{
if
(
mColorMatrix
)
{
aMatrix
.
SetLength
(
MATRIX_LENGTH
)
;
static_assert
(
MATRIX_LENGTH
*
sizeof
(
float
)
=
=
sizeof
(
mColorMatrix
-
>
components
)
"
Size
mismatch
for
our
memcpy
"
)
;
memcpy
(
aMatrix
.
Elements
(
)
mColorMatrix
-
>
components
MATRIX_LENGTH
*
sizeof
(
float
)
)
;
}
return
NS_OK
;
}
#
undef
MATRIX_LENGTH
NS_IMETHODIMP
nsDocShell
:
:
GetIsForceReloading
(
bool
*
aForceReload
)
{
*
aForceReload
=
IsForceReloading
(
)
;
return
NS_OK
;
}
bool
nsDocShell
:
:
IsForceReloading
(
)
{
return
IsForceReloadType
(
mLoadType
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetBrowsingContextXPCOM
(
BrowsingContext
*
*
aBrowsingContext
)
{
*
aBrowsingContext
=
do_AddRef
(
mBrowsingContext
)
.
take
(
)
;
return
NS_OK
;
}
BrowsingContext
*
nsDocShell
:
:
GetBrowsingContext
(
)
{
return
mBrowsingContext
;
}
bool
nsDocShell
:
:
GetIsAttemptingToNavigate
(
)
{
if
(
mDocumentRequest
)
{
return
true
;
}
if
(
!
mLoadGroup
)
{
return
false
;
}
nsCOMPtr
<
nsISimpleEnumerator
>
requests
;
mLoadGroup
-
>
GetRequests
(
getter_AddRefs
(
requests
)
)
;
bool
hasMore
=
false
;
while
(
NS_SUCCEEDED
(
requests
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
elem
;
requests
-
>
GetNext
(
getter_AddRefs
(
elem
)
)
;
nsCOMPtr
<
nsIScriptChannel
>
scriptChannel
(
do_QueryInterface
(
elem
)
)
;
if
(
!
scriptChannel
)
{
continue
;
}
if
(
scriptChannel
-
>
GetIsDocumentLoad
(
)
)
{
return
true
;
}
}
return
false
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetWatchedByDevtools
(
bool
*
aWatched
)
{
NS_ENSURE_ARG
(
aWatched
)
;
*
aWatched
=
mWatchedByDevtools
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetWatchedByDevtools
(
bool
aWatched
)
{
mWatchedByDevtools
=
aWatched
;
return
NS_OK
;
}
