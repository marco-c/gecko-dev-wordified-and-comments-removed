#
include
"
nsDocShell
.
h
"
#
include
<
algorithm
>
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
define
getpid
_getpid
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
InputTaskManager
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MediaFeatureChange
.
h
"
#
include
"
mozilla
/
ObservedDocShell
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
ScrollTypes
.
h
"
#
include
"
mozilla
/
SimpleEnumerator
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
StaticPrefs_docshell
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_extensions
.
h
"
#
include
"
mozilla
/
StaticPrefs_privacy
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
StaticPrefs_fission
.
h
"
#
include
"
mozilla
/
StartupTimeline
.
h
"
#
include
"
mozilla
/
StorageAccess
.
h
"
#
include
"
mozilla
/
StoragePrincipalHelper
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
WidgetUtils
.
h
"
#
include
"
mozilla
/
dom
/
AutoEntryScript
.
h
"
#
include
"
mozilla
/
dom
/
ChildProcessChannelListener
.
h
"
#
include
"
mozilla
/
dom
/
ClientChannelHelper
.
h
"
#
include
"
mozilla
/
dom
/
ClientHandle
.
h
"
#
include
"
mozilla
/
dom
/
ClientInfo
.
h
"
#
include
"
mozilla
/
dom
/
ClientManager
.
h
"
#
include
"
mozilla
/
dom
/
ClientSource
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentFrameMessageManager
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAnchorElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLIFrameElement
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceNavigation
.
h
"
#
include
"
mozilla
/
dom
/
PermissionMessageUtils
.
h
"
#
include
"
mozilla
/
dom
/
PopupBlocker
.
h
"
#
include
"
mozilla
/
dom
/
ProfileTimelineMarkerBinding
.
h
"
#
include
"
mozilla
/
dom
/
ScreenOrientation
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerInterceptController
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerUtils
.
h
"
#
include
"
mozilla
/
dom
/
SessionHistoryEntry
.
h
"
#
include
"
mozilla
/
dom
/
SessionStorageManager
.
h
"
#
include
"
mozilla
/
dom
/
SessionStoreChangeListener
.
h
"
#
include
"
mozilla
/
dom
/
SessionStoreChild
.
h
"
#
include
"
mozilla
/
dom
/
SessionStoreUtils
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
mozilla
/
dom
/
ChildSHistory
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPContext
.
h
"
#
include
"
mozilla
/
dom
/
nsHTTPSOnlyUtils
.
h
"
#
include
"
mozilla
/
dom
/
LoadURIOptionsBinding
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorChild
.
h
"
#
include
"
mozilla
/
dom
/
DocumentBinding
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
net
/
DocumentChannel
.
h
"
#
include
"
mozilla
/
net
/
DocumentChannelChild
.
h
"
#
include
"
mozilla
/
net
/
ParentChannelWrapper
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierFeatureFactory
.
h
"
#
include
"
ReferrerInfo
.
h
"
#
include
"
nsIAuthPrompt
.
h
"
#
include
"
nsIAuthPrompt2
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsICaptivePortalService
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIConsoleReportCollector
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIDocumentLoaderFactory
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsIEditingSession
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIExternalProtocolService
.
h
"
#
include
"
nsIFormPOSTActionChannel
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIIDNService
.
h
"
#
include
"
nsIInputStreamChannel
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsILoadInfo
.
h
"
#
include
"
nsILoadURIDelegate
.
h
"
#
include
"
nsIMultiPartChannel
.
h
"
#
include
"
nsINestedURI
.
h
"
#
include
"
nsINetworkPredictor
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsINSSErrorsService
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIPrivacyTransitionObserver
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIPromptCollection
.
h
"
#
include
"
nsIPromptFactory
.
h
"
#
include
"
nsIPublicKeyPinningService
.
h
"
#
include
"
nsIReflowObserver
.
h
"
#
include
"
nsIScriptChannel
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIScrollObserver
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsISecureBrowserUI
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsISelectionDisplay
.
h
"
#
include
"
nsISHEntry
.
h
"
#
include
"
nsISiteSecurityService
.
h
"
#
include
"
nsISocketProvider
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsIStructuredCloneContainer
.
h
"
#
include
"
nsIBrowserChild
.
h
"
#
include
"
nsITextToSubURI
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsITransportSecurityInfo
.
h
"
#
include
"
nsIUploadChannel
.
h
"
#
include
"
nsIURIFixup
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsIURILoader
.
h
"
#
include
"
nsIViewSourceChannel
.
h
"
#
include
"
nsIWebBrowserChrome
.
h
"
#
include
"
nsIWebBrowserChromeFocus
.
h
"
#
include
"
nsIWebBrowserFind
.
h
"
#
include
"
nsIWebProgress
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
#
include
"
nsIWritablePropertyBag2
.
h
"
#
include
"
nsIX509Cert
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsCommandManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
IHistory
.
h
"
#
include
"
IUrlClassifierUITelemetry
.
h
"
#
include
"
nsArray
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsCExternalHandlerService
.
h
"
#
include
"
nsContentDLF
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsContentSecurityUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCURILoader
.
h
"
#
include
"
nsDocShellCID
.
h
"
#
include
"
nsDocShellEditorData
.
h
"
#
include
"
nsDocShellEnumerator
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
#
include
"
nsDocShellLoadTypes
.
h
"
#
include
"
nsDOMCID
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsDSURIContentListener
.
h
"
#
include
"
nsEditingSession
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsObjectLoadingContent
.
h
"
#
include
"
nsPingListener
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsQueryActor
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRefreshTimer
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsSHEntry
.
h
"
#
include
"
nsSHistory
.
h
"
#
include
"
nsSHEntry
.
h
"
#
include
"
nsStructuredCloneContainer
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsURILoader
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsViewSourceHandler
.
h
"
#
include
"
nsWebBrowserFind
.
h
"
#
include
"
nsWhitespaceTokenizer
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
ThirdPartyUtil
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
Navigator
.
h
"
#
include
"
prenv
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
sslerr
.
h
"
#
include
"
mozpkix
/
pkix
.
h
"
#
include
"
NSSErrorsService
.
h
"
#
include
"
timeline
/
JavascriptTimelineMarker
.
h
"
#
include
"
nsDocShellTelemetryUtils
.
h
"
#
ifdef
MOZ_PLACES
#
include
"
nsIFaviconService
.
h
"
#
include
"
mozIPlacesPendingOperation
.
h
"
#
endif
#
if
NS_PRINT_PREVIEW
#
include
"
nsIDocumentViewerPrint
.
h
"
#
include
"
nsIWebBrowserPrint
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
net
;
using
mozilla
:
:
ipc
:
:
Endpoint
;
#
define
REFRESH_REDIRECT_TIMER
15000
static
mozilla
:
:
LazyLogModule
gCharsetMenuLog
(
"
CharsetMenu
"
)
;
#
define
LOGCHARSETMENU
(
args
)
\
MOZ_LOG
(
gCharsetMenuLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
ifdef
DEBUG
unsigned
long
nsDocShell
:
:
gNumberOfDocShells
=
0
;
static
uint64_t
gDocshellIDCounter
=
0
;
static
mozilla
:
:
LazyLogModule
gDocShellLog
(
"
nsDocShell
"
)
;
static
mozilla
:
:
LazyLogModule
gDocShellAndDOMWindowLeakLogging
(
"
DocShellAndDOMWindowLeak
"
)
;
#
endif
static
mozilla
:
:
LazyLogModule
gDocShellLeakLog
(
"
nsDocShellLeak
"
)
;
extern
mozilla
:
:
LazyLogModule
gPageCacheLog
;
mozilla
:
:
LazyLogModule
gSHLog
(
"
SessionHistory
"
)
;
extern
mozilla
:
:
LazyLogModule
gSHIPBFCacheLog
;
const
char
kAppstringsBundleURL
[
]
=
"
chrome
:
/
/
global
/
locale
/
appstrings
.
properties
"
;
static
bool
IsTopLevelDoc
(
BrowsingContext
*
aBrowsingContext
nsILoadInfo
*
aLoadInfo
)
{
MOZ_ASSERT
(
aBrowsingContext
)
;
MOZ_ASSERT
(
aLoadInfo
)
;
if
(
aLoadInfo
-
>
GetExternalContentPolicyType
(
)
!
=
ExtContentPolicy
:
:
TYPE_DOCUMENT
)
{
return
false
;
}
return
aBrowsingContext
-
>
IsTopContent
(
)
;
}
static
bool
IsUrgentStart
(
BrowsingContext
*
aBrowsingContext
nsILoadInfo
*
aLoadInfo
uint32_t
aLoadType
)
{
MOZ_ASSERT
(
aBrowsingContext
)
;
MOZ_ASSERT
(
aLoadInfo
)
;
if
(
!
IsTopLevelDoc
(
aBrowsingContext
aLoadInfo
)
)
{
return
false
;
}
if
(
aLoadType
&
(
nsIDocShell
:
:
LOAD_CMD_NORMAL
|
nsIDocShell
:
:
LOAD_CMD_HISTORY
)
)
{
return
true
;
}
return
aBrowsingContext
-
>
IsActive
(
)
;
}
nsDocShell
:
:
nsDocShell
(
BrowsingContext
*
aBrowsingContext
uint64_t
aContentWindowID
)
:
nsDocLoader
(
true
)
mContentWindowID
(
aContentWindowID
)
mBrowsingContext
(
aBrowsingContext
)
mParentCharset
(
nullptr
)
mTreeOwner
(
nullptr
)
mScrollbarPref
(
ScrollbarPreference
:
:
Auto
)
mCharsetReloadState
(
eCharsetReloadInit
)
mParentCharsetSource
(
0
)
mFrameMargins
(
-
1
-
1
)
mItemType
(
aBrowsingContext
-
>
IsContent
(
)
?
typeContent
:
typeChrome
)
mPreviousEntryIndex
(
-
1
)
mLoadedEntryIndex
(
-
1
)
mBusyFlags
(
BUSY_FLAGS_NONE
)
mAppType
(
nsIDocShell
:
:
APP_TYPE_UNKNOWN
)
mLoadType
(
0
)
mFailedLoadType
(
0
)
mJSRunToCompletionDepth
(
0
)
mMetaViewportOverride
(
nsIDocShell
:
:
META_VIEWPORT_OVERRIDE_NONE
)
mChannelToDisconnectOnPageHide
(
0
)
mCreatingDocument
(
false
)
#
ifdef
DEBUG
mInEnsureScriptEnv
(
false
)
#
endif
mInitialized
(
false
)
mAllowSubframes
(
true
)
mAllowMetaRedirects
(
true
)
mAllowImages
(
true
)
mAllowMedia
(
true
)
mAllowDNSPrefetch
(
true
)
mAllowWindowControl
(
true
)
mCSSErrorReportingEnabled
(
false
)
mAllowAuth
(
mItemType
=
=
typeContent
)
mAllowKeywordFixup
(
false
)
mDisableMetaRefreshWhenInactive
(
false
)
mDeviceSizeIsPageSize
(
false
)
mWindowDraggingAllowed
(
false
)
mInFrameSwap
(
false
)
mFiredUnloadEvent
(
false
)
mEODForCurrentDocument
(
false
)
mURIResultedInDocument
(
false
)
mIsBeingDestroyed
(
false
)
mIsExecutingOnLoadHandler
(
false
)
mSavingOldViewer
(
false
)
mInvisible
(
false
)
mHasLoadedNonBlankURI
(
false
)
mBlankTiming
(
false
)
mTitleValidForCurrentURI
(
false
)
mWillChangeProcess
(
false
)
mIsNavigating
(
false
)
mForcedAutodetection
(
false
)
mCheckingSessionHistory
(
false
)
mNeedToReportActiveAfterLoadingBecomesActive
(
false
)
{
if
(
aContentWindowID
=
=
0
)
{
mContentWindowID
=
nsContentUtils
:
:
GenerateWindowId
(
)
;
}
MOZ_LOG
(
gDocShellLeakLog
LogLevel
:
:
Debug
(
"
DOCSHELL
%
p
created
\
n
"
this
)
)
;
#
ifdef
DEBUG
mDocShellID
=
gDocshellIDCounter
+
+
;
+
+
gNumberOfDocShells
;
MOZ_LOG
(
gDocShellAndDOMWindowLeakLogging
LogLevel
:
:
Info
(
"
+
+
DOCSHELL
%
p
=
=
%
ld
[
pid
=
%
d
]
[
id
=
%
"
PRIu64
"
]
\
n
"
(
void
*
)
this
gNumberOfDocShells
getpid
(
)
mDocShellID
)
)
;
#
endif
}
nsDocShell
:
:
~
nsDocShell
(
)
{
MOZ_ASSERT
(
!
mObserved
)
;
mIsBeingDestroyed
=
true
;
Destroy
(
)
;
if
(
mContentViewer
)
{
mContentViewer
-
>
Close
(
nullptr
)
;
mContentViewer
-
>
Destroy
(
)
;
mContentViewer
=
nullptr
;
}
MOZ_LOG
(
gDocShellLeakLog
LogLevel
:
:
Debug
(
"
DOCSHELL
%
p
destroyed
\
n
"
this
)
)
;
#
ifdef
DEBUG
if
(
MOZ_LOG_TEST
(
gDocShellAndDOMWindowLeakLogging
LogLevel
:
:
Info
)
)
{
nsAutoCString
url
;
if
(
mLastOpenedURI
)
{
url
=
mLastOpenedURI
-
>
GetSpecOrDefault
(
)
;
const
uint32_t
maxURLLength
=
1000
;
if
(
url
.
Length
(
)
>
maxURLLength
)
{
url
.
Truncate
(
maxURLLength
)
;
}
}
-
-
gNumberOfDocShells
;
MOZ_LOG
(
gDocShellAndDOMWindowLeakLogging
LogLevel
:
:
Info
(
"
-
-
DOCSHELL
%
p
=
=
%
ld
[
pid
=
%
d
]
[
id
=
%
"
PRIu64
"
]
[
url
=
%
s
]
\
n
"
(
void
*
)
this
gNumberOfDocShells
getpid
(
)
mDocShellID
url
.
get
(
)
)
)
;
}
#
endif
}
bool
nsDocShell
:
:
Initialize
(
)
{
if
(
mInitialized
)
{
return
true
;
}
NS_ASSERTION
(
mItemType
=
=
typeContent
|
|
mItemType
=
=
typeChrome
"
Unexpected
item
type
in
docshell
"
)
;
NS_ENSURE_TRUE
(
Preferences
:
:
GetRootBranch
(
)
false
)
;
mInitialized
=
true
;
mDisableMetaRefreshWhenInactive
=
Preferences
:
:
GetBool
(
"
browser
.
meta_refresh_when_inactive
.
disabled
"
mDisableMetaRefreshWhenInactive
)
;
mDeviceSizeIsPageSize
=
Preferences
:
:
GetBool
(
"
docshell
.
device_size_is_page_size
"
mDeviceSizeIsPageSize
)
;
if
(
nsCOMPtr
<
nsIObserverService
>
serv
=
services
:
:
GetObserverService
(
)
)
{
const
char
*
msg
=
mItemType
=
=
typeContent
?
NS_WEBNAVIGATION_CREATE
:
NS_CHROME_WEBNAVIGATION_CREATE
;
serv
-
>
NotifyWhenScriptSafe
(
GetAsSupports
(
this
)
msg
nullptr
)
;
}
return
true
;
}
already_AddRefed
<
nsDocShell
>
nsDocShell
:
:
Create
(
BrowsingContext
*
aBrowsingContext
uint64_t
aContentWindowID
)
{
MOZ_ASSERT
(
aBrowsingContext
"
DocShell
without
a
BrowsingContext
!
"
)
;
nsresult
rv
;
RefPtr
<
nsDocShell
>
ds
=
new
nsDocShell
(
aBrowsingContext
aContentWindowID
)
;
rv
=
ds
-
>
nsDocLoader
:
:
InitWithBrowsingContext
(
aBrowsingContext
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
ds
-
>
mContentListener
=
new
nsDSURIContentListener
(
ds
)
;
if
(
XRE_IsParentProcess
(
)
)
{
ds
-
>
mInterceptController
=
new
ServiceWorkerInterceptController
(
)
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
proxy
=
new
InterfaceRequestorProxy
(
ds
)
;
ds
-
>
mLoadGroup
-
>
SetNotificationCallbacks
(
proxy
)
;
rv
=
nsDocLoader
:
:
AddDocLoaderAsChildOfRoot
(
ds
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
rv
=
ds
-
>
AddProgressListener
(
ds
nsIWebProgress
:
:
NOTIFY_STATE_DOCUMENT
|
nsIWebProgress
:
:
NOTIFY_STATE_NETWORK
|
nsIWebProgress
:
:
NOTIFY_LOCATION
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
if
(
aBrowsingContext
-
>
UsePrivateBrowsing
(
)
)
{
ds
-
>
NotifyPrivateBrowsingChanged
(
)
;
}
RefPtr
<
WindowContext
>
parentWC
=
aBrowsingContext
-
>
GetParentWindowContext
(
)
;
if
(
parentWC
&
&
parentWC
-
>
IsInProcess
(
)
)
{
RefPtr
<
Element
>
parentElement
=
aBrowsingContext
-
>
GetEmbedderElement
(
)
;
if
(
!
parentElement
)
{
MOZ_ASSERT_UNREACHABLE
(
"
nsDocShell
:
:
Create
(
)
-
!
parentElement
"
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
parentShell
=
parentElement
-
>
OwnerDoc
(
)
-
>
GetDocShell
(
)
;
if
(
!
parentShell
)
{
MOZ_ASSERT_UNREACHABLE
(
"
nsDocShell
:
:
Create
(
)
-
!
parentShell
"
)
;
return
nullptr
;
}
parentShell
-
>
AddChild
(
ds
)
;
}
aBrowsingContext
-
>
SetDocShell
(
ds
)
;
ds
-
>
SetLoadGroupDefaultLoadFlags
(
aBrowsingContext
-
>
GetDefaultLoadFlags
(
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
aBrowsingContext
-
>
Canonical
(
)
-
>
MaybeAddAsProgressListener
(
ds
)
;
}
return
ds
.
forget
(
)
;
}
void
nsDocShell
:
:
DestroyChildren
(
)
{
for
(
auto
*
child
:
mChildList
.
ForwardRange
(
)
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
shell
=
do_QueryObject
(
child
)
;
NS_ASSERTION
(
shell
"
docshell
has
null
child
"
)
;
if
(
shell
)
{
shell
-
>
SetTreeOwner
(
nullptr
)
;
}
}
nsDocLoader
:
:
DestroyChildren
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_WEAK_PTR_INHERITED
(
nsDocShell
nsDocLoader
mScriptGlobal
mInitialClientSource
mBrowsingContext
mChromeEventHandler
)
NS_IMPL_ADDREF_INHERITED
(
nsDocShell
nsDocLoader
)
NS_IMPL_RELEASE_INHERITED
(
nsDocShell
nsDocLoader
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsDocShell
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocShell
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocShellTreeItem
)
NS_INTERFACE_MAP_ENTRY
(
nsIWebNavigation
)
NS_INTERFACE_MAP_ENTRY
(
nsIBaseWindow
)
NS_INTERFACE_MAP_ENTRY
(
nsIRefreshURI
)
NS_INTERFACE_MAP_ENTRY
(
nsIWebProgressListener
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIWebPageDescriptor
)
NS_INTERFACE_MAP_ENTRY
(
nsIAuthPromptProvider
)
NS_INTERFACE_MAP_ENTRY
(
nsILoadContext
)
NS_INTERFACE_MAP_ENTRY_CONDITIONAL
(
nsINetworkInterceptController
mInterceptController
)
NS_INTERFACE_MAP_END_INHERITING
(
nsDocLoader
)
NS_IMETHODIMP
nsDocShell
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
MOZ_ASSERT
(
aSink
"
null
out
param
"
)
;
*
aSink
=
nullptr
;
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsICommandManager
)
)
)
{
NS_ENSURE_SUCCESS
(
EnsureCommandHandler
(
)
NS_ERROR_FAILURE
)
;
*
aSink
=
static_cast
<
nsICommandManager
*
>
(
mCommandManager
.
get
(
)
)
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIURIContentListener
)
)
)
{
*
aSink
=
mContentListener
;
}
else
if
(
(
aIID
.
Equals
(
NS_GET_IID
(
nsIScriptGlobalObject
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsIGlobalObject
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsPIDOMWindowOuter
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
mozIDOMWindowProxy
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsIDOMWindow
)
)
)
&
&
NS_SUCCEEDED
(
EnsureScriptEnvironment
(
)
)
)
{
return
mScriptGlobal
-
>
QueryInterface
(
aIID
aSink
)
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
Document
)
)
&
&
NS_SUCCEEDED
(
EnsureContentViewer
(
)
)
)
{
RefPtr
<
Document
>
doc
=
mContentViewer
-
>
GetDocument
(
)
;
doc
.
forget
(
aSink
)
;
return
*
aSink
?
NS_OK
:
NS_NOINTERFACE
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIPrompt
)
)
&
&
NS_SUCCEEDED
(
EnsureScriptEnvironment
(
)
)
)
{
nsresult
rv
;
nsCOMPtr
<
nsIWindowWatcher
>
wwatch
=
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIPrompt
*
prompt
;
rv
=
wwatch
-
>
GetNewPrompter
(
mScriptGlobal
&
prompt
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aSink
=
prompt
;
return
NS_OK
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPrompt
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPrompt2
)
)
)
{
return
NS_SUCCEEDED
(
GetAuthPrompt
(
PROMPT_NORMAL
aIID
aSink
)
)
?
NS_OK
:
NS_NOINTERFACE
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsISHistory
)
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
Do
not
try
to
get
a
nsISHistory
interface
from
nsIDocShell
"
)
;
return
NS_NOINTERFACE
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIWebBrowserFind
)
)
)
{
nsresult
rv
=
EnsureFind
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aSink
=
mFind
;
NS_ADDREF
(
(
nsISupports
*
)
*
aSink
)
;
return
NS_OK
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsISelectionDisplay
)
)
)
{
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
return
presShell
-
>
QueryInterface
(
aIID
aSink
)
;
}
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIDocShellTreeOwner
)
)
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
nsresult
rv
=
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
treeOwner
)
{
return
treeOwner
-
>
QueryInterface
(
aIID
aSink
)
;
}
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIBrowserChild
)
)
)
{
*
aSink
=
GetBrowserChild
(
)
.
take
(
)
;
return
*
aSink
?
NS_OK
:
NS_ERROR_FAILURE
;
}
else
{
return
nsDocLoader
:
:
GetInterface
(
aIID
aSink
)
;
}
NS_IF_ADDREF
(
(
(
nsISupports
*
)
*
aSink
)
)
;
return
*
aSink
?
NS_OK
:
NS_NOINTERFACE
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetCancelContentJSEpoch
(
int32_t
aEpoch
)
{
nsCOMPtr
<
nsIBrowserChild
>
browserChild
=
GetBrowserChild
(
)
;
static_cast
<
BrowserChild
*
>
(
browserChild
.
get
(
)
)
-
>
SetCancelContentJSEpoch
(
aEpoch
)
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
CheckDisallowedJavascriptLoad
(
nsDocShellLoadState
*
aLoadState
)
{
if
(
!
net
:
:
SchemeIsJavascript
(
aLoadState
-
>
URI
(
)
)
)
{
return
NS_OK
;
}
if
(
nsCOMPtr
<
nsIPrincipal
>
targetPrincipal
=
GetInheritedPrincipal
(
true
)
)
{
if
(
!
aLoadState
-
>
TriggeringPrincipal
(
)
-
>
Subsumes
(
targetPrincipal
)
)
{
return
NS_ERROR_DOM_BAD_CROSS_ORIGIN_URI
;
}
return
NS_OK
;
}
return
NS_ERROR_DOM_BAD_CROSS_ORIGIN_URI
;
}
NS_IMETHODIMP
nsDocShell
:
:
LoadURI
(
nsDocShellLoadState
*
aLoadState
bool
aSetNavigating
)
{
return
LoadURI
(
aLoadState
aSetNavigating
false
)
;
}
nsresult
nsDocShell
:
:
LoadURI
(
nsDocShellLoadState
*
aLoadState
bool
aSetNavigating
bool
aContinueHandlingSubframeHistory
)
{
MOZ_ASSERT
(
aLoadState
"
Must
have
a
valid
load
state
!
"
)
;
MOZ_ASSERT
(
(
aLoadState
-
>
LoadFlags
(
)
&
INTERNAL_LOAD_FLAGS_LOADURI_SETUP_FLAGS
)
=
=
0
"
Should
not
have
these
flags
set
"
)
;
MOZ_ASSERT
(
aLoadState
-
>
TargetBrowsingContext
(
)
.
IsNull
(
)
"
Targeting
doesn
'
t
occur
until
InternalLoad
"
)
;
if
(
!
aLoadState
-
>
TriggeringPrincipal
(
)
)
{
MOZ_ASSERT
(
false
"
LoadURI
must
have
a
triggering
principal
"
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_TRY
(
CheckDisallowedJavascriptLoad
(
aLoadState
)
)
;
bool
oldIsNavigating
=
mIsNavigating
;
auto
cleanupIsNavigating
=
MakeScopeExit
(
[
&
]
(
)
{
mIsNavigating
=
oldIsNavigating
;
}
)
;
if
(
aSetNavigating
)
{
mIsNavigating
=
true
;
}
PopupBlocker
:
:
PopupControlState
popupState
=
PopupBlocker
:
:
openOverridden
;
if
(
aLoadState
-
>
HasLoadFlags
(
LOAD_FLAGS_ALLOW_POPUPS
)
)
{
popupState
=
PopupBlocker
:
:
openAllowed
;
if
(
WindowContext
*
wc
=
mBrowsingContext
-
>
GetCurrentWindowContext
(
)
)
{
wc
-
>
NotifyUserGestureActivation
(
)
;
}
}
AutoPopupStatePusher
statePusher
(
popupState
)
;
if
(
aLoadState
-
>
GetCancelContentJSEpoch
(
)
.
isSome
(
)
)
{
SetCancelContentJSEpoch
(
*
aLoadState
-
>
GetCancelContentJSEpoch
(
)
)
;
}
if
(
!
IsNavigationAllowed
(
true
false
)
)
{
return
NS_OK
;
}
nsLoadFlags
defaultLoadFlags
=
mBrowsingContext
-
>
GetDefaultLoadFlags
(
)
;
if
(
aLoadState
-
>
HasLoadFlags
(
LOAD_FLAGS_FORCE_TRR
)
)
{
defaultLoadFlags
|
=
nsIRequest
:
:
LOAD_TRR_ONLY_MODE
;
}
else
if
(
aLoadState
-
>
HasLoadFlags
(
LOAD_FLAGS_DISABLE_TRR
)
)
{
defaultLoadFlags
|
=
nsIRequest
:
:
LOAD_TRR_DISABLED_MODE
;
}
MOZ_ALWAYS_SUCCEEDS
(
mBrowsingContext
-
>
SetDefaultLoadFlags
(
defaultLoadFlags
)
)
;
if
(
!
StartupTimeline
:
:
HasRecord
(
StartupTimeline
:
:
FIRST_LOAD_URI
)
&
&
mItemType
=
=
typeContent
&
&
!
NS_IsAboutBlank
(
aLoadState
-
>
URI
(
)
)
)
{
StartupTimeline
:
:
RecordOnce
(
StartupTimeline
:
:
FIRST_LOAD_URI
)
;
}
MOZ_LOG
(
gDocShellLeakLog
LogLevel
:
:
Debug
(
"
nsDocShell
[
%
p
]
:
loading
%
s
with
flags
0x
%
08x
"
this
aLoadState
-
>
URI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
aLoadState
-
>
LoadFlags
(
)
)
)
;
if
(
(
!
aLoadState
-
>
LoadIsFromSessionHistory
(
)
&
&
!
LOAD_TYPE_HAS_FLAGS
(
aLoadState
-
>
LoadType
(
)
LOAD_FLAGS_REPLACE_HISTORY
)
)
|
|
aContinueHandlingSubframeHistory
)
{
if
(
MaybeHandleSubframeHistory
(
aLoadState
aContinueHandlingSubframeHistory
)
)
{
return
NS_OK
;
}
}
if
(
aLoadState
-
>
LoadIsFromSessionHistory
(
)
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
[
%
p
]
:
loading
from
session
history
"
this
)
)
;
if
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
{
return
LoadHistoryEntry
(
aLoadState
-
>
SHEntry
(
)
aLoadState
-
>
LoadType
(
)
aLoadState
-
>
HasValidUserGestureActivation
(
)
)
;
}
return
LoadHistoryEntry
(
*
aLoadState
-
>
GetLoadingSessionHistoryInfo
(
)
aLoadState
-
>
LoadType
(
)
aLoadState
-
>
HasValidUserGestureActivation
(
)
)
;
}
if
(
(
aLoadState
-
>
LoadType
(
)
=
=
LOAD_NORMAL
|
|
aLoadState
-
>
LoadType
(
)
=
=
LOAD_STOP_CONTENT
)
&
&
ShouldBlockLoadingForBackButton
(
)
)
{
return
NS_OK
;
}
BrowsingContext
:
:
Type
bcType
=
mBrowsingContext
-
>
GetType
(
)
;
nsresult
rv
=
aLoadState
-
>
SetupInheritingPrincipal
(
bcType
mBrowsingContext
-
>
OriginAttributesRef
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aLoadState
-
>
SetupTriggeringPrincipal
(
mBrowsingContext
-
>
OriginAttributesRef
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aLoadState
-
>
CalculateLoadURIFlags
(
)
;
MOZ_ASSERT
(
aLoadState
-
>
TypeHint
(
)
.
IsVoid
(
)
"
Typehint
should
be
null
when
calling
InternalLoad
from
LoadURI
"
)
;
MOZ_ASSERT
(
aLoadState
-
>
FileName
(
)
.
IsVoid
(
)
"
FileName
should
be
null
when
calling
InternalLoad
from
LoadURI
"
)
;
MOZ_ASSERT
(
!
aLoadState
-
>
LoadIsFromSessionHistory
(
)
"
Shouldn
'
t
be
loading
from
an
entry
when
calling
InternalLoad
"
"
from
LoadURI
"
)
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
aLoadState
-
>
TriggeringPrincipal
(
)
;
if
(
triggeringPrincipal
&
&
triggeringPrincipal
-
>
IsSystemPrincipal
(
)
)
{
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
WindowContext
*
topWc
=
mBrowsingContext
-
>
GetTopWindowContext
(
)
;
if
(
topWc
&
&
!
topWc
-
>
IsDiscarded
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
topWc
-
>
SetSHEntryHasUserInteraction
(
true
)
)
;
}
}
else
{
bool
oshe
=
false
;
nsCOMPtr
<
nsISHEntry
>
currentSHEntry
;
GetCurrentSHEntry
(
getter_AddRefs
(
currentSHEntry
)
&
oshe
)
;
if
(
currentSHEntry
)
{
currentSHEntry
-
>
SetHasUserInteraction
(
true
)
;
}
}
}
rv
=
InternalLoad
(
aLoadState
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aLoadState
-
>
GetOriginalURIString
(
)
.
isSome
(
)
)
{
mOriginalUriString
=
*
aLoadState
-
>
GetOriginalURIString
(
)
;
}
return
NS_OK
;
}
bool
nsDocShell
:
:
IsLoadingFromSessionHistory
(
)
{
return
mActiveEntryIsLoadingFromSessionHistory
;
}
class
StopDetector
final
:
public
nsIRequest
{
public
:
StopDetector
(
)
=
default
;
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUEST
bool
Canceled
(
)
{
return
mCanceled
;
}
private
:
~
StopDetector
(
)
=
default
;
bool
mCanceled
=
false
;
}
;
NS_IMPL_ISUPPORTS
(
StopDetector
nsIRequest
)
NS_IMETHODIMP
StopDetector
:
:
GetName
(
nsACString
&
aResult
)
{
aResult
.
AssignLiteral
(
"
about
:
stop
-
detector
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
StopDetector
:
:
IsPending
(
bool
*
aRetVal
)
{
*
aRetVal
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
StopDetector
:
:
GetStatus
(
nsresult
*
aStatus
)
{
*
aStatus
=
NS_OK
;
return
NS_OK
;
}
NS_IMETHODIMP
StopDetector
:
:
SetCanceledReason
(
const
nsACString
&
aReason
)
{
return
SetCanceledReasonImpl
(
aReason
)
;
}
NS_IMETHODIMP
StopDetector
:
:
GetCanceledReason
(
nsACString
&
aReason
)
{
return
GetCanceledReasonImpl
(
aReason
)
;
}
NS_IMETHODIMP
StopDetector
:
:
CancelWithReason
(
nsresult
aStatus
const
nsACString
&
aReason
)
{
return
CancelWithReasonImpl
(
aStatus
aReason
)
;
}
NS_IMETHODIMP
StopDetector
:
:
Cancel
(
nsresult
aStatus
)
{
mCanceled
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
StopDetector
:
:
Suspend
(
void
)
{
return
NS_OK
;
}
NS_IMETHODIMP
StopDetector
:
:
Resume
(
void
)
{
return
NS_OK
;
}
NS_IMETHODIMP
StopDetector
:
:
GetLoadGroup
(
nsILoadGroup
*
*
aLoadGroup
)
{
*
aLoadGroup
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
StopDetector
:
:
SetLoadGroup
(
nsILoadGroup
*
aLoadGroup
)
{
return
NS_OK
;
}
NS_IMETHODIMP
StopDetector
:
:
GetLoadFlags
(
nsLoadFlags
*
aLoadFlags
)
{
*
aLoadFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
return
NS_OK
;
}
NS_IMETHODIMP
StopDetector
:
:
GetTRRMode
(
nsIRequest
:
:
TRRMode
*
aTRRMode
)
{
return
GetTRRModeImpl
(
aTRRMode
)
;
}
NS_IMETHODIMP
StopDetector
:
:
SetTRRMode
(
nsIRequest
:
:
TRRMode
aTRRMode
)
{
return
SetTRRModeImpl
(
aTRRMode
)
;
}
NS_IMETHODIMP
StopDetector
:
:
SetLoadFlags
(
nsLoadFlags
aLoadFlags
)
{
return
NS_OK
;
}
bool
nsDocShell
:
:
MaybeHandleSubframeHistory
(
nsDocShellLoadState
*
aLoadState
bool
aContinueHandlingSubframeHistory
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parentAsItem
;
GetInProcessSameTypeParent
(
getter_AddRefs
(
parentAsItem
)
)
;
nsCOMPtr
<
nsIDocShell
>
parentDS
(
do_QueryInterface
(
parentAsItem
)
)
;
if
(
!
parentDS
|
|
parentDS
=
=
static_cast
<
nsIDocShell
*
>
(
this
)
)
{
if
(
mBrowsingContext
&
&
mBrowsingContext
-
>
IsTop
(
)
)
{
bool
inOnLoadHandler
=
false
;
GetIsExecutingOnLoadHandler
(
&
inOnLoadHandler
)
;
if
(
inOnLoadHandler
)
{
aLoadState
-
>
SetLoadType
(
LOAD_NORMAL_REPLACE
)
;
}
}
return
false
;
}
uint32_t
parentLoadType
;
parentDS
-
>
GetLoadType
(
&
parentLoadType
)
;
if
(
!
aContinueHandlingSubframeHistory
)
{
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
if
(
nsDocShell
:
:
Cast
(
parentDS
.
get
(
)
)
-
>
IsLoadingFromSessionHistory
(
)
&
&
!
GetCreatedDynamically
(
)
)
{
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
contentChild
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
if
(
contentChild
&
&
loadGroup
&
&
!
mCheckingSessionHistory
)
{
RefPtr
<
Document
>
parentDoc
=
parentDS
-
>
GetDocument
(
)
;
parentDoc
-
>
BlockOnload
(
)
;
RefPtr
<
BrowsingContext
>
browsingContext
=
mBrowsingContext
;
Maybe
<
uint64_t
>
currentLoadIdentifier
=
mBrowsingContext
-
>
GetCurrentLoadIdentifier
(
)
;
RefPtr
<
nsDocShellLoadState
>
loadState
=
aLoadState
;
bool
isNavigating
=
mIsNavigating
;
RefPtr
<
StopDetector
>
stopDetector
=
new
StopDetector
(
)
;
loadGroup
-
>
AddRequest
(
stopDetector
nullptr
)
;
mCheckingSessionHistory
=
true
;
auto
resolve
=
[
currentLoadIdentifier
browsingContext
parentDoc
loadState
isNavigating
loadGroup
stopDetector
]
(
mozilla
:
:
Maybe
<
LoadingSessionHistoryInfo
>
&
&
aResult
)
{
RefPtr
<
nsDocShell
>
docShell
=
static_cast
<
nsDocShell
*
>
(
browsingContext
-
>
GetDocShell
(
)
)
;
auto
unblockParent
=
MakeScopeExit
(
[
loadGroup
stopDetector
parentDoc
docShell
]
(
)
{
if
(
docShell
)
{
docShell
-
>
mCheckingSessionHistory
=
false
;
}
loadGroup
-
>
RemoveRequest
(
stopDetector
nullptr
NS_OK
)
;
parentDoc
-
>
UnblockOnload
(
false
)
;
}
)
;
if
(
!
docShell
|
|
!
docShell
-
>
mCheckingSessionHistory
)
{
return
;
}
if
(
stopDetector
-
>
Canceled
(
)
)
{
return
;
}
if
(
currentLoadIdentifier
=
=
browsingContext
-
>
GetCurrentLoadIdentifier
(
)
&
&
aResult
.
isSome
(
)
)
{
loadState
-
>
SetLoadingSessionHistoryInfo
(
aResult
.
value
(
)
)
;
loadState
-
>
SetLoadIsFromSessionHistory
(
0
false
)
;
}
docShell
-
>
LoadURI
(
loadState
isNavigating
true
)
;
}
;
auto
reject
=
[
loadGroup
stopDetector
browsingContext
parentDoc
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
)
{
RefPtr
<
nsDocShell
>
docShell
=
static_cast
<
nsDocShell
*
>
(
browsingContext
-
>
GetDocShell
(
)
)
;
if
(
docShell
)
{
docShell
-
>
mCheckingSessionHistory
=
false
;
}
loadGroup
-
>
RemoveRequest
(
stopDetector
nullptr
NS_OK
)
;
parentDoc
-
>
UnblockOnload
(
false
)
;
}
;
contentChild
-
>
SendGetLoadingSessionHistoryInfoFromParent
(
mBrowsingContext
std
:
:
move
(
resolve
)
std
:
:
move
(
reject
)
)
;
return
true
;
}
}
else
{
Maybe
<
LoadingSessionHistoryInfo
>
info
;
mBrowsingContext
-
>
Canonical
(
)
-
>
GetLoadingSessionHistoryInfoFromParent
(
info
)
;
if
(
info
.
isSome
(
)
)
{
aLoadState
-
>
SetLoadingSessionHistoryInfo
(
info
.
value
(
)
)
;
aLoadState
-
>
SetLoadIsFromSessionHistory
(
0
false
)
;
}
}
}
}
else
{
nsCOMPtr
<
nsISHEntry
>
currentSH
;
bool
oshe
=
false
;
parentDS
-
>
GetCurrentSHEntry
(
getter_AddRefs
(
currentSH
)
&
oshe
)
;
bool
dynamicallyAddedChild
=
GetCreatedDynamically
(
)
;
if
(
!
dynamicallyAddedChild
&
&
!
oshe
&
&
currentSH
)
{
nsCOMPtr
<
nsISHEntry
>
shEntry
;
currentSH
-
>
GetChildSHEntryIfHasNoDynamicallyAddedChild
(
mBrowsingContext
-
>
ChildOffset
(
)
getter_AddRefs
(
shEntry
)
)
;
if
(
shEntry
)
{
aLoadState
-
>
SetSHEntry
(
shEntry
)
;
}
}
}
}
bool
oshe
=
false
;
nsCOMPtr
<
nsISHEntry
>
currentChildEntry
;
GetCurrentSHEntry
(
getter_AddRefs
(
currentChildEntry
)
&
oshe
)
;
if
(
mCurrentURI
&
&
(
!
NS_IsAboutBlank
(
mCurrentURI
)
|
|
currentChildEntry
|
|
mLoadingEntry
|
|
mActiveEntry
)
)
{
BusyFlags
parentBusy
=
parentDS
-
>
GetBusyFlags
(
)
;
BusyFlags
selfBusy
=
GetBusyFlags
(
)
;
if
(
parentBusy
&
BUSY_FLAGS_BUSY
|
|
selfBusy
&
BUSY_FLAGS_BUSY
)
{
aLoadState
-
>
SetLoadType
(
LOAD_NORMAL_REPLACE
)
;
aLoadState
-
>
ClearLoadIsFromSessionHistory
(
)
;
}
return
false
;
}
if
(
aLoadState
-
>
LoadIsFromSessionHistory
(
)
&
&
(
parentLoadType
=
=
LOAD_NORMAL
|
|
parentLoadType
=
=
LOAD_LINK
)
)
{
bool
inOnLoadHandler
=
false
;
parentDS
-
>
GetIsExecutingOnLoadHandler
(
&
inOnLoadHandler
)
;
if
(
inOnLoadHandler
)
{
aLoadState
-
>
SetLoadType
(
LOAD_NORMAL_REPLACE
)
;
aLoadState
-
>
ClearLoadIsFromSessionHistory
(
)
;
}
}
else
if
(
parentLoadType
=
=
LOAD_REFRESH
)
{
aLoadState
-
>
ClearLoadIsFromSessionHistory
(
)
;
}
else
if
(
(
parentLoadType
=
=
LOAD_BYPASS_HISTORY
)
|
|
(
aLoadState
-
>
LoadIsFromSessionHistory
(
)
&
&
(
(
parentLoadType
&
LOAD_CMD_HISTORY
)
|
|
(
parentLoadType
=
=
LOAD_RELOAD_NORMAL
)
|
|
(
parentLoadType
=
=
LOAD_RELOAD_CHARSET_CHANGE
)
|
|
(
parentLoadType
=
=
LOAD_RELOAD_CHARSET_CHANGE_BYPASS_CACHE
)
|
|
(
parentLoadType
=
=
LOAD_RELOAD_CHARSET_CHANGE_BYPASS_PROXY_AND_CACHE
)
)
)
)
{
aLoadState
-
>
SetLoadType
(
parentLoadType
)
;
}
else
if
(
parentLoadType
=
=
LOAD_ERROR_PAGE
)
{
aLoadState
-
>
SetLoadType
(
LOAD_BYPASS_HISTORY
)
;
}
else
if
(
(
parentLoadType
=
=
LOAD_RELOAD_BYPASS_CACHE
)
|
|
(
parentLoadType
=
=
LOAD_RELOAD_BYPASS_PROXY
)
|
|
(
parentLoadType
=
=
LOAD_RELOAD_BYPASS_PROXY_AND_CACHE
)
)
{
aLoadState
-
>
SetLoadType
(
parentLoadType
)
;
}
return
false
;
}
NS_IMETHODIMP
nsDocShell
:
:
PrepareForNewContentModel
(
)
{
SetLayoutHistoryState
(
nullptr
)
;
mEODForCurrentDocument
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
FirePageHideNotification
(
bool
aIsUnload
)
{
FirePageHideNotificationInternal
(
aIsUnload
false
)
;
return
NS_OK
;
}
void
nsDocShell
:
:
FirePageHideNotificationInternal
(
bool
aIsUnload
bool
aSkipCheckingDynEntries
)
{
if
(
mContentViewer
&
&
!
mFiredUnloadEvent
)
{
nsCOMPtr
<
nsIContentViewer
>
contentViewer
(
mContentViewer
)
;
mFiredUnloadEvent
=
true
;
if
(
mTiming
)
{
mTiming
-
>
NotifyUnloadEventStart
(
)
;
}
contentViewer
-
>
PageHide
(
aIsUnload
)
;
if
(
mTiming
)
{
mTiming
-
>
NotifyUnloadEventEnd
(
)
;
}
AutoTArray
<
nsCOMPtr
<
nsIDocShell
>
8
>
kids
;
uint32_t
n
=
mChildList
.
Length
(
)
;
kids
.
SetCapacity
(
n
)
;
for
(
uint32_t
i
=
0
;
i
<
n
;
i
+
+
)
{
kids
.
AppendElement
(
do_QueryInterface
(
ChildAt
(
i
)
)
)
;
}
n
=
kids
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
n
;
+
+
i
)
{
RefPtr
<
nsDocShell
>
child
=
static_cast
<
nsDocShell
*
>
(
kids
[
i
]
.
get
(
)
)
;
if
(
child
)
{
child
-
>
FirePageHideNotificationInternal
(
aIsUnload
true
)
;
}
}
if
(
aIsUnload
&
&
!
aSkipCheckingDynEntries
)
{
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
rootSH
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
%
p
unloading
remove
dynamic
subframe
entries
"
this
)
)
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
if
(
mActiveEntry
)
{
mBrowsingContext
-
>
RemoveDynEntriesFromActiveSessionHistoryEntry
(
)
;
}
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
%
p
unloading
no
active
entries
"
this
)
)
;
}
else
if
(
mOSHE
)
{
int32_t
index
=
rootSH
-
>
Index
(
)
;
rootSH
-
>
LegacySHistory
(
)
-
>
RemoveDynEntries
(
index
mOSHE
)
;
}
}
}
DetachEditorFromWindow
(
)
;
}
}
void
nsDocShell
:
:
ThawFreezeNonRecursive
(
bool
aThaw
)
{
MOZ_ASSERT
(
mozilla
:
:
BFCacheInParent
(
)
)
;
if
(
!
mScriptGlobal
)
{
return
;
}
RefPtr
<
nsGlobalWindowInner
>
inner
=
mScriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
inner
)
{
if
(
aThaw
)
{
inner
-
>
Thaw
(
false
)
;
}
else
{
inner
-
>
Freeze
(
false
)
;
}
}
}
void
nsDocShell
:
:
FirePageHideShowNonRecursive
(
bool
aShow
)
{
MOZ_ASSERT
(
mozilla
:
:
BFCacheInParent
(
)
)
;
if
(
!
mContentViewer
)
{
return
;
}
nsCOMPtr
<
nsIContentViewer
>
contentViewer
(
mContentViewer
)
;
if
(
aShow
)
{
contentViewer
-
>
SetIsHidden
(
false
)
;
mRefreshURIList
=
std
:
:
move
(
mBFCachedRefreshURIList
)
;
RefreshURIFromQueue
(
)
;
mFiredUnloadEvent
=
false
;
RefPtr
<
Document
>
doc
=
contentViewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
doc
-
>
NotifyActivityChanged
(
)
;
RefPtr
<
nsGlobalWindowInner
>
inner
=
mScriptGlobal
?
mScriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
:
nullptr
;
if
(
mBrowsingContext
-
>
IsTop
(
)
)
{
doc
-
>
NotifyPossibleTitleChange
(
false
)
;
if
(
inner
)
{
Performance
*
performance
=
inner
-
>
GetPerformance
(
)
;
if
(
performance
)
{
performance
-
>
GetDOMTiming
(
)
-
>
NotifyRestoreStart
(
)
;
}
}
}
nsCOMPtr
<
nsIChannel
>
channel
=
doc
-
>
GetChannel
(
)
;
if
(
channel
)
{
SetLoadType
(
LOAD_HISTORY
)
;
mEODForCurrentDocument
=
false
;
mIsRestoringDocument
=
true
;
mLoadGroup
-
>
AddRequest
(
channel
nullptr
)
;
SetCurrentURI
(
doc
-
>
GetDocumentURI
(
)
channel
true
false
0
)
;
mLoadGroup
-
>
RemoveRequest
(
channel
nullptr
NS_OK
)
;
mIsRestoringDocument
=
false
;
}
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
presShell
-
>
Thaw
(
false
)
;
}
if
(
inner
)
{
inner
-
>
FireDelayedDOMEvents
(
false
)
;
}
}
}
else
if
(
!
mFiredUnloadEvent
)
{
if
(
mRefreshURIList
)
{
RefreshURIToQueue
(
)
;
mBFCachedRefreshURIList
=
std
:
:
move
(
mRefreshURIList
)
;
}
else
{
mBFCachedRefreshURIList
=
std
:
:
move
(
mSavedRefreshURIList
)
;
}
mFiredUnloadEvent
=
true
;
contentViewer
-
>
PageHide
(
false
)
;
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
presShell
-
>
Freeze
(
false
)
;
}
}
}
nsresult
nsDocShell
:
:
Dispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetWindow
(
)
;
if
(
NS_WARN_IF
(
!
win
)
)
{
MOZ_ASSERT
(
mIsBeingDestroyed
)
;
return
NS_ERROR_FAILURE
;
}
if
(
win
-
>
GetDocGroup
(
)
)
{
return
win
-
>
GetDocGroup
(
)
-
>
Dispatch
(
aCategory
runnable
.
forget
(
)
)
;
}
return
SchedulerGroup
:
:
Dispatch
(
aCategory
runnable
.
forget
(
)
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
DispatchLocationChangeEvent
(
)
{
return
Dispatch
(
TaskCategory
:
:
Other
NewRunnableMethod
(
"
nsDocShell
:
:
FireDummyOnLocationChange
"
this
&
nsDocShell
:
:
FireDummyOnLocationChange
)
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
StartDelayedAutoplayMediaComponents
(
)
{
RefPtr
<
nsPIDOMWindowOuter
>
outerWindow
=
GetWindow
(
)
;
if
(
outerWindow
)
{
outerWindow
-
>
ActivateMediaComponents
(
)
;
}
return
NS_OK
;
}
bool
nsDocShell
:
:
MaybeInitTiming
(
)
{
if
(
mTiming
&
&
!
mBlankTiming
)
{
return
false
;
}
bool
canBeReset
=
false
;
if
(
mScriptGlobal
&
&
mBlankTiming
)
{
nsPIDOMWindowInner
*
innerWin
=
mScriptGlobal
-
>
GetCurrentInnerWindow
(
)
;
if
(
innerWin
&
&
innerWin
-
>
GetPerformance
(
)
)
{
mTiming
=
innerWin
-
>
GetPerformance
(
)
-
>
GetDOMTiming
(
)
;
mBlankTiming
=
false
;
}
}
if
(
!
mTiming
)
{
mTiming
=
new
nsDOMNavigationTiming
(
this
)
;
canBeReset
=
true
;
}
mTiming
-
>
NotifyNavigationStart
(
mBrowsingContext
-
>
IsActive
(
)
?
nsDOMNavigationTiming
:
:
DocShellState
:
:
eActive
:
nsDOMNavigationTiming
:
:
DocShellState
:
:
eInactive
)
;
return
canBeReset
;
}
void
nsDocShell
:
:
MaybeResetInitTiming
(
bool
aReset
)
{
if
(
aReset
)
{
mTiming
=
nullptr
;
}
}
nsDOMNavigationTiming
*
nsDocShell
:
:
GetNavigationTiming
(
)
const
{
return
mTiming
;
}
bool
nsDocShell
:
:
ValidateOrigin
(
BrowsingContext
*
aOrigin
BrowsingContext
*
aTarget
)
{
nsIDocShell
*
originDocShell
=
aOrigin
-
>
GetDocShell
(
)
;
MOZ_ASSERT
(
originDocShell
"
originDocShell
must
not
be
null
"
)
;
Document
*
originDocument
=
originDocShell
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
originDocument
false
)
;
nsIDocShell
*
targetDocShell
=
aTarget
-
>
GetDocShell
(
)
;
MOZ_ASSERT
(
targetDocShell
"
targetDocShell
must
not
be
null
"
)
;
Document
*
targetDocument
=
targetDocShell
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
targetDocument
false
)
;
bool
equal
;
nsresult
rv
=
originDocument
-
>
NodePrincipal
(
)
-
>
Equals
(
targetDocument
-
>
NodePrincipal
(
)
&
equal
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
equal
)
{
return
true
;
}
nsCOMPtr
<
nsIURI
>
originURI
;
nsCOMPtr
<
nsIURI
>
targetURI
;
nsCOMPtr
<
nsIURI
>
innerOriginURI
;
nsCOMPtr
<
nsIURI
>
innerTargetURI
;
auto
*
originDocumentBasePrincipal
=
BasePrincipal
:
:
Cast
(
originDocument
-
>
NodePrincipal
(
)
)
;
rv
=
originDocumentBasePrincipal
-
>
GetURI
(
getter_AddRefs
(
originURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
originURI
)
{
innerOriginURI
=
NS_GetInnermostURI
(
originURI
)
;
}
auto
*
targetDocumentBasePrincipal
=
BasePrincipal
:
:
Cast
(
targetDocument
-
>
NodePrincipal
(
)
)
;
rv
=
targetDocumentBasePrincipal
-
>
GetURI
(
getter_AddRefs
(
targetURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
targetURI
)
{
innerTargetURI
=
NS_GetInnermostURI
(
targetURI
)
;
}
return
innerOriginURI
&
&
innerTargetURI
&
&
SchemeIsFile
(
innerOriginURI
)
&
&
SchemeIsFile
(
innerTargetURI
)
;
}
nsPresContext
*
nsDocShell
:
:
GetEldestPresContext
(
)
{
nsIContentViewer
*
viewer
=
mContentViewer
;
while
(
viewer
)
{
nsIContentViewer
*
prevViewer
=
viewer
-
>
GetPreviousViewer
(
)
;
if
(
!
prevViewer
)
{
return
viewer
-
>
GetPresContext
(
)
;
}
viewer
=
prevViewer
;
}
return
nullptr
;
}
nsPresContext
*
nsDocShell
:
:
GetPresContext
(
)
{
if
(
!
mContentViewer
)
{
return
nullptr
;
}
return
mContentViewer
-
>
GetPresContext
(
)
;
}
PresShell
*
nsDocShell
:
:
GetPresShell
(
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
return
presContext
?
presContext
-
>
GetPresShell
(
)
:
nullptr
;
}
PresShell
*
nsDocShell
:
:
GetEldestPresShell
(
)
{
nsPresContext
*
presContext
=
GetEldestPresContext
(
)
;
if
(
presContext
)
{
return
presContext
-
>
GetPresShell
(
)
;
}
return
nullptr
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetContentViewer
(
nsIContentViewer
*
*
aContentViewer
)
{
NS_ENSURE_ARG_POINTER
(
aContentViewer
)
;
*
aContentViewer
=
mContentViewer
;
NS_IF_ADDREF
(
*
aContentViewer
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetOuterWindowID
(
uint64_t
*
aWindowID
)
{
*
aWindowID
=
mContentWindowID
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetChromeEventHandler
(
EventTarget
*
aChromeEventHandler
)
{
mChromeEventHandler
=
aChromeEventHandler
;
if
(
mScriptGlobal
)
{
mScriptGlobal
-
>
SetChromeEventHandler
(
mChromeEventHandler
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetChromeEventHandler
(
EventTarget
*
*
aChromeEventHandler
)
{
NS_ENSURE_ARG_POINTER
(
aChromeEventHandler
)
;
RefPtr
<
EventTarget
>
handler
=
mChromeEventHandler
;
handler
.
forget
(
aChromeEventHandler
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetCurrentURIForSessionStore
(
nsIURI
*
aURI
)
{
SetCurrentURI
(
aURI
nullptr
true
false
nsIWebProgressListener
:
:
LOCATION_CHANGE_SESSION_STORE
)
;
return
NS_OK
;
}
bool
nsDocShell
:
:
SetCurrentURI
(
nsIURI
*
aURI
nsIRequest
*
aRequest
bool
aFireOnLocationChange
bool
aIsInitialAboutBlank
uint32_t
aLocationFlags
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
MOZ_LOG
(
gDocShellLeakLog
LogLevel
:
:
Debug
(
"
DOCSHELL
%
p
SetCurrentURI
%
s
\
n
"
this
aURI
?
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
)
)
;
if
(
mLoadType
=
=
LOAD_ERROR_PAGE
)
{
return
false
;
}
bool
uriIsEqual
=
false
;
if
(
!
mCurrentURI
|
|
!
aURI
|
|
NS_FAILED
(
mCurrentURI
-
>
Equals
(
aURI
&
uriIsEqual
)
)
|
|
!
uriIsEqual
)
{
mTitleValidForCurrentURI
=
false
;
}
mCurrentURI
=
aURI
;
#
ifdef
DEBUG
mLastOpenedURI
=
aURI
;
#
endif
if
(
!
NS_IsAboutBlank
(
mCurrentURI
)
)
{
mHasLoadedNonBlankURI
=
true
;
}
if
(
aIsInitialAboutBlank
&
&
!
mHasLoadedNonBlankURI
&
&
!
mBrowsingContext
-
>
IsTop
(
)
)
{
MOZ_ASSERT
(
!
aRequest
&
&
aLocationFlags
=
=
0
)
;
return
false
;
}
MOZ_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
if
(
aFireOnLocationChange
)
{
FireOnLocationChange
(
this
aRequest
aURI
aLocationFlags
)
;
}
return
!
aFireOnLocationChange
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCharset
(
nsACString
&
aCharset
)
{
aCharset
.
Truncate
(
)
;
PresShell
*
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
Document
*
doc
=
presShell
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
doc
-
>
GetDocumentCharacterSet
(
)
-
>
Name
(
aCharset
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
ForceEncodingDetection
(
)
{
nsCOMPtr
<
nsIContentViewer
>
viewer
;
GetContentViewer
(
getter_AddRefs
(
viewer
)
)
;
if
(
!
viewer
)
{
return
NS_OK
;
}
Document
*
doc
=
viewer
-
>
GetDocument
(
)
;
if
(
!
doc
|
|
doc
-
>
WillIgnoreCharsetOverride
(
)
)
{
return
NS_OK
;
}
mForcedAutodetection
=
true
;
nsIURI
*
url
=
doc
-
>
GetOriginalURI
(
)
;
bool
isFileURL
=
url
&
&
SchemeIsFile
(
url
)
;
int32_t
charsetSource
=
doc
-
>
GetDocumentCharacterSetSource
(
)
;
auto
encoding
=
doc
-
>
GetDocumentCharacterSet
(
)
;
if
(
doc
-
>
AsHTMLDocument
(
)
-
>
IsPlainText
(
)
)
{
switch
(
charsetSource
)
{
case
kCharsetFromInitialAutoDetectionASCII
:
LOGCHARSETMENU
(
(
"
TEXT
:
UnlabeledAscii
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_TEXT
:
:
UnlabeledAscii
)
;
break
;
case
kCharsetFromInitialAutoDetectionWouldNotHaveBeenUTF8Generic
:
case
kCharsetFromFinalAutoDetectionWouldNotHaveBeenUTF8Generic
:
case
kCharsetFromFinalAutoDetectionWouldNotHaveBeenUTF8GenericInitialWasASCII
:
case
kCharsetFromInitialAutoDetectionWouldNotHaveBeenUTF8Content
:
case
kCharsetFromFinalAutoDetectionWouldNotHaveBeenUTF8Content
:
case
kCharsetFromFinalAutoDetectionWouldNotHaveBeenUTF8ContentInitialWasASCII
:
LOGCHARSETMENU
(
(
"
TEXT
:
UnlabeledNonUtf8
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_TEXT
:
:
UnlabeledNonUtf8
)
;
break
;
case
kCharsetFromInitialAutoDetectionWouldNotHaveBeenUTF8DependedOnTLD
:
case
kCharsetFromFinalAutoDetectionWouldNotHaveBeenUTF8DependedOnTLD
:
case
kCharsetFromFinalAutoDetectionWouldNotHaveBeenUTF8DependedOnTLDInitialWasASCII
:
LOGCHARSETMENU
(
(
"
TEXT
:
UnlabeledNonUtf8TLD
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_TEXT
:
:
UnlabeledNonUtf8TLD
)
;
break
;
case
kCharsetFromInitialAutoDetectionWouldHaveBeenUTF8
:
case
kCharsetFromFinalAutoDetectionWouldHaveBeenUTF8InitialWasASCII
:
LOGCHARSETMENU
(
(
"
TEXT
:
UnlabeledUtf8
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_TEXT
:
:
UnlabeledUtf8
)
;
break
;
case
kCharsetFromChannel
:
if
(
encoding
=
=
UTF_8_ENCODING
)
{
LOGCHARSETMENU
(
(
"
TEXT
:
ChannelUtf8
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_TEXT
:
:
ChannelUtf8
)
;
}
else
{
LOGCHARSETMENU
(
(
"
TEXT
:
ChannelNonUtf8
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_TEXT
:
:
ChannelNonUtf8
)
;
}
break
;
default
:
LOGCHARSETMENU
(
(
"
TEXT
:
Bug
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_TEXT
:
:
Bug
)
;
break
;
}
}
else
{
switch
(
charsetSource
)
{
case
kCharsetFromInitialAutoDetectionASCII
:
LOGCHARSETMENU
(
(
"
HTML
:
UnlabeledAscii
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_HTML
:
:
UnlabeledAscii
)
;
break
;
case
kCharsetFromInitialAutoDetectionWouldNotHaveBeenUTF8Generic
:
case
kCharsetFromFinalAutoDetectionWouldNotHaveBeenUTF8Generic
:
case
kCharsetFromFinalAutoDetectionWouldNotHaveBeenUTF8GenericInitialWasASCII
:
case
kCharsetFromInitialAutoDetectionWouldNotHaveBeenUTF8Content
:
case
kCharsetFromFinalAutoDetectionWouldNotHaveBeenUTF8Content
:
case
kCharsetFromFinalAutoDetectionWouldNotHaveBeenUTF8ContentInitialWasASCII
:
LOGCHARSETMENU
(
(
"
HTML
:
UnlabeledNonUtf8
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_HTML
:
:
UnlabeledNonUtf8
)
;
break
;
case
kCharsetFromInitialAutoDetectionWouldNotHaveBeenUTF8DependedOnTLD
:
case
kCharsetFromFinalAutoDetectionWouldNotHaveBeenUTF8DependedOnTLD
:
case
kCharsetFromFinalAutoDetectionWouldNotHaveBeenUTF8DependedOnTLDInitialWasASCII
:
LOGCHARSETMENU
(
(
"
HTML
:
UnlabeledNonUtf8TLD
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_HTML
:
:
UnlabeledNonUtf8TLD
)
;
break
;
case
kCharsetFromInitialAutoDetectionWouldHaveBeenUTF8
:
case
kCharsetFromFinalAutoDetectionWouldHaveBeenUTF8InitialWasASCII
:
LOGCHARSETMENU
(
(
"
HTML
:
UnlabeledUtf8
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_HTML
:
:
UnlabeledUtf8
)
;
break
;
case
kCharsetFromChannel
:
if
(
encoding
=
=
UTF_8_ENCODING
)
{
LOGCHARSETMENU
(
(
"
HTML
:
ChannelUtf8
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_HTML
:
:
ChannelUtf8
)
;
}
else
{
LOGCHARSETMENU
(
(
"
HTML
:
ChannelNonUtf8
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_HTML
:
:
ChannelNonUtf8
)
;
}
break
;
case
kCharsetFromXmlDeclaration
:
case
kCharsetFromMetaTag
:
if
(
isFileURL
)
{
LOGCHARSETMENU
(
(
"
HTML
:
LocalLabeled
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_HTML
:
:
LocalLabeled
)
;
}
else
if
(
encoding
=
=
UTF_8_ENCODING
)
{
LOGCHARSETMENU
(
(
"
HTML
:
MetaUtf8
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_HTML
:
:
InternalUtf8
)
;
}
else
{
LOGCHARSETMENU
(
(
"
HTML
:
MetaNonUtf8
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_HTML
:
:
InternalNonUtf8
)
;
}
break
;
default
:
LOGCHARSETMENU
(
(
"
HTML
:
Bug
"
)
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_ENCODING_OVERRIDE_SITUATION_HTML
:
:
Bug
)
;
break
;
}
}
return
NS_OK
;
}
void
nsDocShell
:
:
SetParentCharset
(
const
Encoding
*
&
aCharset
int32_t
aCharsetSource
nsIPrincipal
*
aPrincipal
)
{
mParentCharset
=
aCharset
;
mParentCharsetSource
=
aCharsetSource
;
mParentCharsetPrincipal
=
aPrincipal
;
}
void
nsDocShell
:
:
GetParentCharset
(
const
Encoding
*
&
aCharset
int32_t
*
aCharsetSource
nsIPrincipal
*
*
aPrincipal
)
{
aCharset
=
mParentCharset
;
*
aCharsetSource
=
mParentCharsetSource
;
NS_IF_ADDREF
(
*
aPrincipal
=
mParentCharsetPrincipal
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetHasTrackingContentBlocked
(
Promise
*
*
aPromise
)
{
MOZ_ASSERT
(
aPromise
)
;
ErrorResult
rv
;
RefPtr
<
Document
>
doc
(
GetDocument
(
)
)
;
RefPtr
<
Promise
>
retPromise
=
Promise
:
:
Create
(
doc
-
>
GetOwnerGlobal
(
)
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
RefPtr
<
Document
:
:
GetContentBlockingEventsPromise
>
promise
=
doc
-
>
GetContentBlockingEvents
(
)
;
if
(
promise
)
{
promise
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
retPromise
]
(
const
Document
:
:
GetContentBlockingEventsPromise
:
:
ResolveOrRejectValue
&
aValue
)
{
if
(
aValue
.
IsResolve
(
)
)
{
bool
has
=
aValue
.
ResolveValue
(
)
&
nsIWebProgressListener
:
:
STATE_BLOCKED_TRACKING_CONTENT
;
retPromise
-
>
MaybeResolve
(
has
)
;
}
else
{
retPromise
-
>
MaybeResolve
(
false
)
;
}
}
)
;
}
else
{
retPromise
-
>
MaybeResolve
(
false
)
;
}
retPromise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowPlugins
(
bool
*
aAllowPlugins
)
{
NS_ENSURE_ARG_POINTER
(
aAllowPlugins
)
;
*
aAllowPlugins
=
mBrowsingContext
-
>
GetAllowPlugins
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowPlugins
(
bool
aAllowPlugins
)
{
return
mBrowsingContext
-
>
SetAllowPlugins
(
aAllowPlugins
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCssErrorReportingEnabled
(
bool
*
aEnabled
)
{
MOZ_ASSERT
(
aEnabled
)
;
*
aEnabled
=
mCSSErrorReportingEnabled
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetCssErrorReportingEnabled
(
bool
aEnabled
)
{
mCSSErrorReportingEnabled
=
aEnabled
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetUsePrivateBrowsing
(
bool
*
aUsePrivateBrowsing
)
{
NS_ENSURE_ARG_POINTER
(
aUsePrivateBrowsing
)
;
return
mBrowsingContext
-
>
GetUsePrivateBrowsing
(
aUsePrivateBrowsing
)
;
}
void
nsDocShell
:
:
NotifyPrivateBrowsingChanged
(
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
nsTObserverArray
<
nsWeakPtr
>
:
:
ForwardIterator
iter
(
mPrivacyObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
nsWeakPtr
ref
=
iter
.
GetNext
(
)
;
nsCOMPtr
<
nsIPrivacyTransitionObserver
>
obs
=
do_QueryReferent
(
ref
)
;
if
(
!
obs
)
{
iter
.
Remove
(
)
;
}
else
{
obs
-
>
PrivateModeChanged
(
UsePrivateBrowsing
(
)
)
;
}
}
}
NS_IMETHODIMP
nsDocShell
:
:
SetUsePrivateBrowsing
(
bool
aUsePrivateBrowsing
)
{
return
mBrowsingContext
-
>
SetUsePrivateBrowsing
(
aUsePrivateBrowsing
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetPrivateBrowsing
(
bool
aUsePrivateBrowsing
)
{
return
mBrowsingContext
-
>
SetPrivateBrowsing
(
aUsePrivateBrowsing
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetHasLoadedNonBlankURI
(
bool
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
mHasLoadedNonBlankURI
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetUseRemoteTabs
(
bool
*
aUseRemoteTabs
)
{
NS_ENSURE_ARG_POINTER
(
aUseRemoteTabs
)
;
return
mBrowsingContext
-
>
GetUseRemoteTabs
(
aUseRemoteTabs
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetRemoteTabs
(
bool
aUseRemoteTabs
)
{
return
mBrowsingContext
-
>
SetRemoteTabs
(
aUseRemoteTabs
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetUseRemoteSubframes
(
bool
*
aUseRemoteSubframes
)
{
NS_ENSURE_ARG_POINTER
(
aUseRemoteSubframes
)
;
return
mBrowsingContext
-
>
GetUseRemoteSubframes
(
aUseRemoteSubframes
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetRemoteSubframes
(
bool
aUseRemoteSubframes
)
{
return
mBrowsingContext
-
>
SetRemoteSubframes
(
aUseRemoteSubframes
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
AddWeakPrivacyTransitionObserver
(
nsIPrivacyTransitionObserver
*
aObserver
)
{
nsWeakPtr
weakObs
=
do_GetWeakReference
(
aObserver
)
;
if
(
!
weakObs
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mPrivacyObservers
.
AppendElement
(
weakObs
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
AddWeakReflowObserver
(
nsIReflowObserver
*
aObserver
)
{
nsWeakPtr
weakObs
=
do_GetWeakReference
(
aObserver
)
;
if
(
!
weakObs
)
{
return
NS_ERROR_FAILURE
;
}
mReflowObservers
.
AppendElement
(
weakObs
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
RemoveWeakReflowObserver
(
nsIReflowObserver
*
aObserver
)
{
nsWeakPtr
obs
=
do_GetWeakReference
(
aObserver
)
;
return
mReflowObservers
.
RemoveElement
(
obs
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsDocShell
:
:
NotifyReflowObservers
(
bool
aInterruptible
DOMHighResTimeStamp
aStart
DOMHighResTimeStamp
aEnd
)
{
nsTObserverArray
<
nsWeakPtr
>
:
:
ForwardIterator
iter
(
mReflowObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
nsWeakPtr
ref
=
iter
.
GetNext
(
)
;
nsCOMPtr
<
nsIReflowObserver
>
obs
=
do_QueryReferent
(
ref
)
;
if
(
!
obs
)
{
iter
.
Remove
(
)
;
}
else
if
(
aInterruptible
)
{
obs
-
>
ReflowInterruptible
(
aStart
aEnd
)
;
}
else
{
obs
-
>
Reflow
(
aStart
aEnd
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowMetaRedirects
(
bool
*
aReturn
)
{
NS_ENSURE_ARG_POINTER
(
aReturn
)
;
*
aReturn
=
mAllowMetaRedirects
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowMetaRedirects
(
bool
aValue
)
{
mAllowMetaRedirects
=
aValue
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowSubframes
(
bool
*
aAllowSubframes
)
{
NS_ENSURE_ARG_POINTER
(
aAllowSubframes
)
;
*
aAllowSubframes
=
mAllowSubframes
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowSubframes
(
bool
aAllowSubframes
)
{
mAllowSubframes
=
aAllowSubframes
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowImages
(
bool
*
aAllowImages
)
{
NS_ENSURE_ARG_POINTER
(
aAllowImages
)
;
*
aAllowImages
=
mAllowImages
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowImages
(
bool
aAllowImages
)
{
mAllowImages
=
aAllowImages
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowMedia
(
bool
*
aAllowMedia
)
{
*
aAllowMedia
=
mAllowMedia
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowMedia
(
bool
aAllowMedia
)
{
mAllowMedia
=
aAllowMedia
;
if
(
mScriptGlobal
)
{
if
(
nsPIDOMWindowInner
*
innerWin
=
mScriptGlobal
-
>
GetCurrentInnerWindow
(
)
)
{
if
(
aAllowMedia
)
{
innerWin
-
>
UnmuteAudioContexts
(
)
;
}
else
{
innerWin
-
>
MuteAudioContexts
(
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowDNSPrefetch
(
bool
*
aAllowDNSPrefetch
)
{
*
aAllowDNSPrefetch
=
mAllowDNSPrefetch
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowDNSPrefetch
(
bool
aAllowDNSPrefetch
)
{
mAllowDNSPrefetch
=
aAllowDNSPrefetch
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowWindowControl
(
bool
*
aAllowWindowControl
)
{
*
aAllowWindowControl
=
mAllowWindowControl
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowWindowControl
(
bool
aAllowWindowControl
)
{
mAllowWindowControl
=
aAllowWindowControl
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowContentRetargeting
(
bool
*
aAllowContentRetargeting
)
{
*
aAllowContentRetargeting
=
mBrowsingContext
-
>
GetAllowContentRetargeting
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowContentRetargeting
(
bool
aAllowContentRetargeting
)
{
BrowsingContext
:
:
Transaction
txn
;
txn
.
SetAllowContentRetargeting
(
aAllowContentRetargeting
)
;
txn
.
SetAllowContentRetargetingOnChildren
(
aAllowContentRetargeting
)
;
return
txn
.
Commit
(
mBrowsingContext
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowContentRetargetingOnChildren
(
bool
*
aAllowContentRetargetingOnChildren
)
{
*
aAllowContentRetargetingOnChildren
=
mBrowsingContext
-
>
GetAllowContentRetargetingOnChildren
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowContentRetargetingOnChildren
(
bool
aAllowContentRetargetingOnChildren
)
{
return
mBrowsingContext
-
>
SetAllowContentRetargetingOnChildren
(
aAllowContentRetargetingOnChildren
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetMayEnableCharacterEncodingMenu
(
bool
*
aMayEnableCharacterEncodingMenu
)
{
*
aMayEnableCharacterEncodingMenu
=
false
;
if
(
!
mContentViewer
)
{
return
NS_OK
;
}
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
NS_OK
;
}
if
(
doc
-
>
WillIgnoreCharsetOverride
(
)
)
{
return
NS_OK
;
}
*
aMayEnableCharacterEncodingMenu
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllDocShellsInSubtree
(
int32_t
aItemType
DocShellEnumeratorDirection
aDirection
nsTArray
<
RefPtr
<
nsIDocShell
>
>
&
aResult
)
{
aResult
.
Clear
(
)
;
nsDocShellEnumerator
docShellEnum
(
(
aDirection
=
=
ENUMERATE_FORWARDS
)
?
nsDocShellEnumerator
:
:
EnumerationDirection
:
:
Forwards
:
nsDocShellEnumerator
:
:
EnumerationDirection
:
:
Backwards
aItemType
*
this
)
;
nsresult
rv
=
docShellEnum
.
BuildDocShellArray
(
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAppType
(
AppType
*
aAppType
)
{
*
aAppType
=
mAppType
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAppType
(
AppType
aAppType
)
{
mAppType
=
aAppType
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAllowAuth
(
bool
*
aAllowAuth
)
{
*
aAllowAuth
=
mAllowAuth
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetAllowAuth
(
bool
aAllowAuth
)
{
mAllowAuth
=
aAllowAuth
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetZoom
(
float
*
aZoom
)
{
NS_ENSURE_ARG_POINTER
(
aZoom
)
;
*
aZoom
=
1
.
0f
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetZoom
(
float
aZoom
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetBusyFlags
(
BusyFlags
*
aBusyFlags
)
{
NS_ENSURE_ARG_POINTER
(
aBusyFlags
)
;
*
aBusyFlags
=
mBusyFlags
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
TabToTreeOwner
(
bool
aForward
bool
aForDocumentNavigation
bool
*
aTookFocus
)
{
NS_ENSURE_ARG_POINTER
(
aTookFocus
)
;
nsCOMPtr
<
nsIWebBrowserChromeFocus
>
chromeFocus
=
do_GetInterface
(
mTreeOwner
)
;
if
(
chromeFocus
)
{
if
(
aForward
)
{
*
aTookFocus
=
NS_SUCCEEDED
(
chromeFocus
-
>
FocusNextElement
(
aForDocumentNavigation
)
)
;
}
else
{
*
aTookFocus
=
NS_SUCCEEDED
(
chromeFocus
-
>
FocusPrevElement
(
aForDocumentNavigation
)
)
;
}
}
else
{
*
aTookFocus
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetLoadURIDelegate
(
nsILoadURIDelegate
*
*
aLoadURIDelegate
)
{
nsCOMPtr
<
nsILoadURIDelegate
>
delegate
=
GetLoadURIDelegate
(
)
;
delegate
.
forget
(
aLoadURIDelegate
)
;
return
NS_OK
;
}
already_AddRefed
<
nsILoadURIDelegate
>
nsDocShell
:
:
GetLoadURIDelegate
(
)
{
if
(
nsCOMPtr
<
nsILoadURIDelegate
>
result
=
do_QueryActor
(
"
LoadURIDelegate
"
GetDocument
(
)
)
)
{
return
result
.
forget
(
)
;
}
return
nullptr
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetUseErrorPages
(
bool
*
aUseErrorPages
)
{
*
aUseErrorPages
=
mBrowsingContext
-
>
GetUseErrorPages
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetUseErrorPages
(
bool
aUseErrorPages
)
{
return
mBrowsingContext
-
>
SetUseErrorPages
(
aUseErrorPages
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetPreviousEntryIndex
(
int32_t
*
aPreviousEntryIndex
)
{
*
aPreviousEntryIndex
=
mPreviousEntryIndex
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetLoadedEntryIndex
(
int32_t
*
aLoadedEntryIndex
)
{
*
aLoadedEntryIndex
=
mLoadedEntryIndex
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
HistoryPurged
(
int32_t
aNumEntries
)
{
mPreviousEntryIndex
=
std
:
:
max
(
-
1
mPreviousEntryIndex
-
aNumEntries
)
;
mLoadedEntryIndex
=
std
:
:
max
(
0
mLoadedEntryIndex
-
aNumEntries
)
;
for
(
auto
*
child
:
mChildList
.
ForwardRange
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryObject
(
child
)
;
if
(
shell
)
{
shell
-
>
HistoryPurged
(
aNumEntries
)
;
}
}
return
NS_OK
;
}
void
nsDocShell
:
:
TriggerParentCheckDocShellIsEmpty
(
)
{
if
(
RefPtr
<
nsDocShell
>
parent
=
GetInProcessParentDocshell
(
)
)
{
parent
-
>
DocLoaderIsEmpty
(
true
)
;
}
if
(
GetBrowsingContext
(
)
-
>
IsContentSubframe
(
)
&
&
!
GetBrowsingContext
(
)
-
>
GetParent
(
)
-
>
IsInProcess
(
)
)
{
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
this
)
)
{
mozilla
:
:
Unused
<
<
browserChild
-
>
SendMaybeFireEmbedderLoadEvents
(
EmbedderElementEventType
:
:
NoEvent
)
;
}
}
}
nsresult
nsDocShell
:
:
HistoryEntryRemoved
(
int32_t
aIndex
)
{
if
(
aIndex
=
=
mPreviousEntryIndex
)
{
mPreviousEntryIndex
=
-
1
;
}
else
if
(
aIndex
<
mPreviousEntryIndex
)
{
-
-
mPreviousEntryIndex
;
}
if
(
mLoadedEntryIndex
=
=
aIndex
)
{
mLoadedEntryIndex
=
0
;
}
else
if
(
aIndex
<
mLoadedEntryIndex
)
{
-
-
mLoadedEntryIndex
;
}
for
(
auto
*
child
:
mChildList
.
ForwardRange
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryObject
(
child
)
;
if
(
shell
)
{
static_cast
<
nsDocShell
*
>
(
shell
.
get
(
)
)
-
>
HistoryEntryRemoved
(
aIndex
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetRecordProfileTimelineMarkers
(
bool
aValue
)
{
bool
currentValue
=
nsIDocShell
:
:
GetRecordProfileTimelineMarkers
(
)
;
if
(
currentValue
=
=
aValue
)
{
return
NS_OK
;
}
if
(
aValue
)
{
MOZ_ASSERT
(
!
TimelineConsumers
:
:
HasConsumer
(
this
)
)
;
TimelineConsumers
:
:
AddConsumer
(
this
)
;
MOZ_ASSERT
(
TimelineConsumers
:
:
HasConsumer
(
this
)
)
;
UseEntryScriptProfiling
(
)
;
}
else
{
MOZ_ASSERT
(
TimelineConsumers
:
:
HasConsumer
(
this
)
)
;
TimelineConsumers
:
:
RemoveConsumer
(
this
)
;
MOZ_ASSERT
(
!
TimelineConsumers
:
:
HasConsumer
(
this
)
)
;
UnuseEntryScriptProfiling
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetRecordProfileTimelineMarkers
(
bool
*
aValue
)
{
*
aValue
=
!
!
mObserved
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
PopProfileTimelineMarkers
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aOut
)
{
nsTArray
<
dom
:
:
ProfileTimelineMarker
>
store
;
SequenceRooter
<
dom
:
:
ProfileTimelineMarker
>
rooter
(
aCx
&
store
)
;
TimelineConsumers
:
:
PopMarkers
(
this
aCx
store
)
;
if
(
!
ToJSValue
(
aCx
store
aOut
)
)
{
JS_ClearPendingException
(
aCx
)
;
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
Now
(
DOMHighResTimeStamp
*
aWhen
)
{
*
aWhen
=
(
TimeStamp
:
:
Now
(
)
-
TimeStamp
:
:
ProcessCreation
(
)
)
.
ToMilliseconds
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetWindowDraggingAllowed
(
bool
aValue
)
{
RefPtr
<
nsDocShell
>
parent
=
GetInProcessParentDocshell
(
)
;
if
(
!
aValue
&
&
mItemType
=
=
typeChrome
&
&
!
parent
)
{
return
NS_ERROR_FAILURE
;
}
mWindowDraggingAllowed
=
aValue
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetWindowDraggingAllowed
(
bool
*
aValue
)
{
RefPtr
<
nsDocShell
>
parent
=
GetInProcessParentDocshell
(
)
;
if
(
mItemType
=
=
typeChrome
&
&
!
parent
)
{
*
aValue
=
true
;
}
else
{
*
aValue
=
mWindowDraggingAllowed
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCurrentDocumentChannel
(
nsIChannel
*
*
aResult
)
{
NS_IF_ADDREF
(
*
aResult
=
GetCurrentDocChannel
(
)
)
;
return
NS_OK
;
}
nsIChannel
*
nsDocShell
:
:
GetCurrentDocChannel
(
)
{
if
(
mContentViewer
)
{
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
return
doc
-
>
GetChannel
(
)
;
}
}
return
nullptr
;
}
NS_IMETHODIMP
nsDocShell
:
:
AddWeakScrollObserver
(
nsIScrollObserver
*
aObserver
)
{
nsWeakPtr
weakObs
=
do_GetWeakReference
(
aObserver
)
;
if
(
!
weakObs
)
{
return
NS_ERROR_FAILURE
;
}
mScrollObservers
.
AppendElement
(
weakObs
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
RemoveWeakScrollObserver
(
nsIScrollObserver
*
aObserver
)
{
nsWeakPtr
obs
=
do_GetWeakReference
(
aObserver
)
;
return
mScrollObservers
.
RemoveElement
(
obs
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
void
nsDocShell
:
:
NotifyAsyncPanZoomStarted
(
)
{
nsTObserverArray
<
nsWeakPtr
>
:
:
ForwardIterator
iter
(
mScrollObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
nsWeakPtr
ref
=
iter
.
GetNext
(
)
;
nsCOMPtr
<
nsIScrollObserver
>
obs
=
do_QueryReferent
(
ref
)
;
if
(
obs
)
{
obs
-
>
AsyncPanZoomStarted
(
)
;
}
else
{
iter
.
Remove
(
)
;
}
}
}
void
nsDocShell
:
:
NotifyAsyncPanZoomStopped
(
)
{
nsTObserverArray
<
nsWeakPtr
>
:
:
ForwardIterator
iter
(
mScrollObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
nsWeakPtr
ref
=
iter
.
GetNext
(
)
;
nsCOMPtr
<
nsIScrollObserver
>
obs
=
do_QueryReferent
(
ref
)
;
if
(
obs
)
{
obs
-
>
AsyncPanZoomStopped
(
)
;
}
else
{
iter
.
Remove
(
)
;
}
}
}
NS_IMETHODIMP
nsDocShell
:
:
NotifyScrollObservers
(
)
{
nsTObserverArray
<
nsWeakPtr
>
:
:
ForwardIterator
iter
(
mScrollObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
nsWeakPtr
ref
=
iter
.
GetNext
(
)
;
nsCOMPtr
<
nsIScrollObserver
>
obs
=
do_QueryReferent
(
ref
)
;
if
(
obs
)
{
obs
-
>
ScrollPositionChanged
(
)
;
}
else
{
iter
.
Remove
(
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetName
(
nsAString
&
aName
)
{
aName
=
mBrowsingContext
-
>
Name
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetName
(
const
nsAString
&
aName
)
{
return
mBrowsingContext
-
>
SetName
(
aName
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
NameEquals
(
const
nsAString
&
aName
bool
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
mBrowsingContext
-
>
NameEquals
(
aName
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCustomUserAgent
(
nsAString
&
aCustomUserAgent
)
{
mBrowsingContext
-
>
GetCustomUserAgent
(
aCustomUserAgent
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetCustomUserAgent
(
const
nsAString
&
aCustomUserAgent
)
{
if
(
mWillChangeProcess
)
{
NS_WARNING
(
"
SetCustomUserAgent
:
Process
is
changing
.
Ignoring
set
"
)
;
return
NS_ERROR_FAILURE
;
}
return
mBrowsingContext
-
>
SetCustomUserAgent
(
aCustomUserAgent
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
ClearCachedPlatform
(
)
{
RefPtr
<
nsGlobalWindowInner
>
win
=
mScriptGlobal
?
mScriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
:
nullptr
;
if
(
win
)
{
Navigator
*
navigator
=
win
-
>
Navigator
(
)
;
if
(
navigator
)
{
navigator
-
>
ClearPlatformCache
(
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
ClearCachedUserAgent
(
)
{
RefPtr
<
nsGlobalWindowInner
>
win
=
mScriptGlobal
?
mScriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
:
nullptr
;
if
(
win
)
{
Navigator
*
navigator
=
win
-
>
Navigator
(
)
;
if
(
navigator
)
{
navigator
-
>
ClearUserAgentCache
(
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetMetaViewportOverride
(
MetaViewportOverride
*
aMetaViewportOverride
)
{
NS_ENSURE_ARG_POINTER
(
aMetaViewportOverride
)
;
*
aMetaViewportOverride
=
mMetaViewportOverride
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetMetaViewportOverride
(
MetaViewportOverride
aMetaViewportOverride
)
{
if
(
!
(
aMetaViewportOverride
=
=
META_VIEWPORT_OVERRIDE_NONE
|
|
aMetaViewportOverride
=
=
META_VIEWPORT_OVERRIDE_ENABLED
|
|
aMetaViewportOverride
=
=
META_VIEWPORT_OVERRIDE_DISABLED
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mMetaViewportOverride
=
aMetaViewportOverride
;
if
(
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
MaybeRecreateMobileViewportManager
(
true
)
;
}
return
NS_OK
;
}
int32_t
nsDocShell
:
:
ItemType
(
)
{
return
mItemType
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetItemType
(
int32_t
*
aItemType
)
{
NS_ENSURE_ARG_POINTER
(
aItemType
)
;
MOZ_DIAGNOSTIC_ASSERT
(
(
mBrowsingContext
-
>
IsContent
(
)
?
typeContent
:
typeChrome
)
=
=
mItemType
)
;
*
aItemType
=
mItemType
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetInProcessParent
(
nsIDocShellTreeItem
*
*
aParent
)
{
if
(
!
mParent
)
{
*
aParent
=
nullptr
;
}
else
{
CallQueryInterface
(
mParent
aParent
)
;
}
return
NS_OK
;
}
already_AddRefed
<
nsDocShell
>
nsDocShell
:
:
GetInProcessParentDocshell
(
)
{
nsCOMPtr
<
nsIDocShell
>
docshell
=
do_QueryInterface
(
GetAsSupports
(
mParent
)
)
;
return
docshell
.
forget
(
)
.
downcast
<
nsDocShell
>
(
)
;
}
void
nsDocShell
:
:
MaybeCreateInitialClientSource
(
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
if
(
mScriptGlobal
&
&
mScriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
&
&
mScriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
-
>
GetExtantDoc
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mScriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
-
>
GetClientInfo
(
)
.
isSome
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mInitialClientSource
)
;
return
;
}
if
(
mInitialClientSource
)
{
return
;
}
if
(
!
aPrincipal
&
&
mBrowsingContext
-
>
GetSandboxFlags
(
)
)
{
return
;
}
nsIPrincipal
*
principal
=
aPrincipal
?
aPrincipal
:
GetInheritedPrincipal
(
false
StoragePrincipalHelper
:
:
ShouldUsePartitionPrincipalForServiceWorker
(
this
)
)
;
if
(
!
principal
)
{
return
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetWindow
(
)
;
if
(
!
win
)
{
return
;
}
mInitialClientSource
=
ClientManager
:
:
CreateSource
(
ClientType
:
:
Window
win
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
principal
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInitialClientSource
)
;
mInitialClientSource
-
>
DocShellExecutionReady
(
this
)
;
nsCOMPtr
<
nsIDocShell
>
parent
=
GetInProcessParentDocshell
(
)
;
nsPIDOMWindowOuter
*
parentOuter
=
parent
?
parent
-
>
GetWindow
(
)
:
nullptr
;
nsPIDOMWindowInner
*
parentInner
=
parentOuter
?
parentOuter
-
>
GetCurrentInnerWindow
(
)
:
nullptr
;
if
(
!
parentInner
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
uri
)
"
about
:
blank
"
_ns
)
)
;
Maybe
<
ServiceWorkerDescriptor
>
controller
(
parentInner
-
>
GetController
(
)
)
;
if
(
controller
.
isNothing
(
)
|
|
!
ServiceWorkerAllowedToControlWindow
(
principal
uri
)
)
{
return
;
}
mInitialClientSource
-
>
InheritController
(
controller
.
ref
(
)
)
;
}
Maybe
<
ClientInfo
>
nsDocShell
:
:
GetInitialClientInfo
(
)
const
{
if
(
mInitialClientSource
)
{
Maybe
<
ClientInfo
>
result
;
result
.
emplace
(
mInitialClientSource
-
>
Info
(
)
)
;
return
result
;
}
nsGlobalWindowInner
*
innerWindow
=
mScriptGlobal
?
mScriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
:
nullptr
;
Document
*
doc
=
innerWindow
?
innerWindow
-
>
GetExtantDoc
(
)
:
nullptr
;
if
(
!
doc
|
|
!
doc
-
>
IsInitialDocument
(
)
)
{
return
Maybe
<
ClientInfo
>
(
)
;
}
return
innerWindow
-
>
GetClientInfo
(
)
;
}
nsresult
nsDocShell
:
:
SetDocLoaderParent
(
nsDocLoader
*
aParent
)
{
bool
wasFrame
=
IsSubframe
(
)
;
nsresult
rv
=
nsDocLoader
:
:
SetDocLoaderParent
(
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsISupportsPriority
>
priorityGroup
=
do_QueryInterface
(
mLoadGroup
)
;
if
(
wasFrame
!
=
IsSubframe
(
)
&
&
priorityGroup
)
{
priorityGroup
-
>
AdjustPriority
(
wasFrame
?
-
1
:
1
)
;
}
nsISupports
*
parent
=
GetAsSupports
(
aParent
)
;
bool
value
;
nsCOMPtr
<
nsIDocShell
>
parentAsDocShell
(
do_QueryInterface
(
parent
)
)
;
if
(
parentAsDocShell
)
{
if
(
mAllowMetaRedirects
&
&
NS_SUCCEEDED
(
parentAsDocShell
-
>
GetAllowMetaRedirects
(
&
value
)
)
)
{
SetAllowMetaRedirects
(
value
)
;
}
if
(
mAllowSubframes
&
&
NS_SUCCEEDED
(
parentAsDocShell
-
>
GetAllowSubframes
(
&
value
)
)
)
{
SetAllowSubframes
(
value
)
;
}
if
(
mAllowImages
&
&
NS_SUCCEEDED
(
parentAsDocShell
-
>
GetAllowImages
(
&
value
)
)
)
{
SetAllowImages
(
value
)
;
}
SetAllowMedia
(
parentAsDocShell
-
>
GetAllowMedia
(
)
&
&
mAllowMedia
)
;
if
(
mAllowWindowControl
&
&
NS_SUCCEEDED
(
parentAsDocShell
-
>
GetAllowWindowControl
(
&
value
)
)
)
{
SetAllowWindowControl
(
value
)
;
}
if
(
NS_FAILED
(
parentAsDocShell
-
>
GetAllowDNSPrefetch
(
&
value
)
)
)
{
value
=
false
;
}
SetAllowDNSPrefetch
(
mAllowDNSPrefetch
&
&
value
)
;
}
nsCOMPtr
<
nsIURIContentListener
>
parentURIListener
(
do_GetInterface
(
parent
)
)
;
if
(
parentURIListener
)
{
mContentListener
-
>
SetParentContentListener
(
parentURIListener
)
;
}
return
NS_OK
;
}
void
nsDocShell
:
:
MaybeRestoreWindowName
(
)
{
if
(
!
StaticPrefs
:
:
privacy_window_name_update_enabled
(
)
)
{
return
;
}
if
(
!
mBrowsingContext
-
>
IsTopContent
(
)
)
{
return
;
}
nsAutoString
name
;
if
(
mLSHE
)
{
mLSHE
-
>
GetName
(
name
)
;
}
if
(
mLoadingEntry
)
{
name
=
mLoadingEntry
-
>
mInfo
.
GetName
(
)
;
}
if
(
name
.
IsEmpty
(
)
)
{
return
;
}
Unused
<
<
mBrowsingContext
-
>
SetName
(
name
)
;
if
(
mLSHE
)
{
nsSHistory
:
:
WalkContiguousEntries
(
mLSHE
[
]
(
nsISHEntry
*
aEntry
)
{
aEntry
-
>
SetName
(
EmptyString
(
)
)
;
}
)
;
}
if
(
mLoadingEntry
)
{
mLoadingEntry
-
>
mInfo
.
SetName
(
EmptyString
(
)
)
;
}
}
void
nsDocShell
:
:
StoreWindowNameToSHEntries
(
)
{
MOZ_ASSERT
(
mBrowsingContext
-
>
IsTopContent
(
)
)
;
nsAutoString
name
;
mBrowsingContext
-
>
GetName
(
name
)
;
if
(
mOSHE
)
{
nsSHistory
:
:
WalkContiguousEntries
(
mOSHE
[
&
]
(
nsISHEntry
*
aEntry
)
{
aEntry
-
>
SetName
(
name
)
;
}
)
;
}
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
if
(
XRE_IsParentProcess
(
)
)
{
SessionHistoryEntry
*
entry
=
mBrowsingContext
-
>
Canonical
(
)
-
>
GetActiveSessionHistoryEntry
(
)
;
if
(
entry
)
{
nsSHistory
:
:
WalkContiguousEntries
(
entry
[
&
]
(
nsISHEntry
*
aEntry
)
{
aEntry
-
>
SetName
(
name
)
;
}
)
;
}
}
else
{
mozilla
:
:
Unused
<
<
ContentChild
:
:
GetSingleton
(
)
-
>
SendSessionHistoryEntryStoreWindowNameInContiguousEntries
(
mBrowsingContext
name
)
;
}
}
}
NS_IMETHODIMP
nsDocShell
:
:
GetInProcessSameTypeParent
(
nsIDocShellTreeItem
*
*
aParent
)
{
if
(
BrowsingContext
*
parentBC
=
mBrowsingContext
-
>
GetParent
(
)
)
{
*
aParent
=
do_AddRef
(
parentBC
-
>
GetDocShell
(
)
)
.
take
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetSameTypeInProcessParentIgnoreBrowserBoundaries
(
nsIDocShell
*
*
aParent
)
{
NS_ENSURE_ARG_POINTER
(
aParent
)
;
*
aParent
=
nullptr
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
=
do_QueryInterface
(
GetAsSupports
(
mParent
)
)
;
if
(
!
parent
)
{
return
NS_OK
;
}
if
(
parent
-
>
ItemType
(
)
=
=
mItemType
)
{
nsCOMPtr
<
nsIDocShell
>
parentDS
=
do_QueryInterface
(
parent
)
;
parentDS
.
forget
(
aParent
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetInProcessRootTreeItem
(
nsIDocShellTreeItem
*
*
aRootTreeItem
)
{
NS_ENSURE_ARG_POINTER
(
aRootTreeItem
)
;
RefPtr
<
nsDocShell
>
root
=
this
;
RefPtr
<
nsDocShell
>
parent
=
root
-
>
GetInProcessParentDocshell
(
)
;
while
(
parent
)
{
root
=
parent
;
parent
=
root
-
>
GetInProcessParentDocshell
(
)
;
}
root
.
forget
(
aRootTreeItem
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetInProcessSameTypeRootTreeItem
(
nsIDocShellTreeItem
*
*
aRootTreeItem
)
{
NS_ENSURE_ARG_POINTER
(
aRootTreeItem
)
;
*
aRootTreeItem
=
static_cast
<
nsIDocShellTreeItem
*
>
(
this
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
NS_ENSURE_SUCCESS
(
GetInProcessSameTypeParent
(
getter_AddRefs
(
parent
)
)
NS_ERROR_FAILURE
)
;
while
(
parent
)
{
*
aRootTreeItem
=
parent
;
NS_ENSURE_SUCCESS
(
(
*
aRootTreeItem
)
-
>
GetInProcessSameTypeParent
(
getter_AddRefs
(
parent
)
)
NS_ERROR_FAILURE
)
;
}
NS_ADDREF
(
*
aRootTreeItem
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetTreeOwner
(
nsIDocShellTreeOwner
*
*
aTreeOwner
)
{
NS_ENSURE_ARG_POINTER
(
aTreeOwner
)
;
*
aTreeOwner
=
mTreeOwner
;
NS_IF_ADDREF
(
*
aTreeOwner
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetTreeOwner
(
nsIDocShellTreeOwner
*
aTreeOwner
)
{
if
(
mIsBeingDestroyed
&
&
aTreeOwner
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
IsSubframe
(
)
)
{
nsCOMPtr
<
nsIWebProgress
>
webProgress
=
do_QueryInterface
(
GetAsSupports
(
this
)
)
;
if
(
webProgress
)
{
nsCOMPtr
<
nsIWebProgressListener
>
oldListener
=
do_QueryInterface
(
mTreeOwner
)
;
nsCOMPtr
<
nsIWebProgressListener
>
newListener
=
do_QueryInterface
(
aTreeOwner
)
;
if
(
oldListener
)
{
webProgress
-
>
RemoveProgressListener
(
oldListener
)
;
}
if
(
newListener
)
{
webProgress
-
>
AddProgressListener
(
newListener
nsIWebProgress
:
:
NOTIFY_ALL
)
;
}
}
}
mTreeOwner
=
aTreeOwner
;
for
(
auto
*
childDocLoader
:
mChildList
.
ForwardRange
(
)
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
child
=
do_QueryObject
(
childDocLoader
)
;
NS_ENSURE_TRUE
(
child
NS_ERROR_FAILURE
)
;
if
(
child
-
>
ItemType
(
)
=
=
mItemType
)
{
child
-
>
SetTreeOwner
(
aTreeOwner
)
;
}
}
if
(
mTreeOwner
&
&
XRE_IsContentProcess
(
)
)
{
nsCOMPtr
<
nsIBrowserChild
>
newBrowserChild
=
do_GetInterface
(
mTreeOwner
)
;
MOZ_ASSERT
(
newBrowserChild
"
No
BrowserChild
actor
for
tree
owner
in
Content
!
"
)
;
if
(
mBrowserChild
)
{
nsCOMPtr
<
nsIBrowserChild
>
oldBrowserChild
=
do_QueryReferent
(
mBrowserChild
)
;
MOZ_RELEASE_ASSERT
(
oldBrowserChild
=
=
newBrowserChild
"
Cannot
change
BrowserChild
during
nsDocShell
lifetime
!
"
)
;
}
else
{
mBrowserChild
=
do_GetWeakReference
(
newBrowserChild
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetHistoryID
(
nsID
&
aID
)
{
aID
=
mBrowsingContext
-
>
GetHistoryID
(
)
;
return
NS_OK
;
}
const
nsID
&
nsDocShell
:
:
HistoryID
(
)
{
return
mBrowsingContext
-
>
GetHistoryID
(
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsInUnload
(
bool
*
aIsInUnload
)
{
*
aIsInUnload
=
mFiredUnloadEvent
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetInProcessChildCount
(
int32_t
*
aChildCount
)
{
NS_ENSURE_ARG_POINTER
(
aChildCount
)
;
*
aChildCount
=
mChildList
.
Length
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
AddChild
(
nsIDocShellTreeItem
*
aChild
)
{
NS_ENSURE_ARG_POINTER
(
aChild
)
;
RefPtr
<
nsDocLoader
>
childAsDocLoader
=
GetAsDocLoader
(
aChild
)
;
NS_ENSURE_TRUE
(
childAsDocLoader
NS_ERROR_UNEXPECTED
)
;
nsDocLoader
*
ancestor
=
this
;
do
{
if
(
childAsDocLoader
=
=
ancestor
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
ancestor
=
ancestor
-
>
GetParent
(
)
;
}
while
(
ancestor
)
;
nsDocLoader
*
childsParent
=
childAsDocLoader
-
>
GetParent
(
)
;
if
(
childsParent
)
{
nsresult
rv
=
childsParent
-
>
RemoveChildLoader
(
childAsDocLoader
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
aChild
-
>
SetTreeOwner
(
nullptr
)
;
nsresult
res
=
AddChildLoader
(
childAsDocLoader
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
NS_ASSERTION
(
!
mChildList
.
IsEmpty
(
)
"
child
list
must
not
be
empty
after
a
successful
add
"
)
;
if
(
mBrowsingContext
-
>
GetUseGlobalHistory
(
)
)
{
MOZ_ASSERT
(
aChild
-
>
GetBrowsingContext
(
)
-
>
GetUseGlobalHistory
(
)
)
;
}
if
(
aChild
-
>
ItemType
(
)
!
=
mItemType
)
{
return
NS_OK
;
}
aChild
-
>
SetTreeOwner
(
mTreeOwner
)
;
nsCOMPtr
<
nsIDocShell
>
childAsDocShell
(
do_QueryInterface
(
aChild
)
)
;
if
(
!
childAsDocShell
)
{
return
NS_OK
;
}
if
(
mItemType
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
return
NS_OK
;
}
if
(
!
mContentViewer
)
{
return
NS_OK
;
}
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
NS_OK
;
}
const
Encoding
*
parentCS
=
doc
-
>
GetDocumentCharacterSet
(
)
;
int32_t
charsetSource
=
doc
-
>
GetDocumentCharacterSetSource
(
)
;
childAsDocShell
-
>
SetParentCharset
(
parentCS
charsetSource
doc
-
>
NodePrincipal
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
RemoveChild
(
nsIDocShellTreeItem
*
aChild
)
{
NS_ENSURE_ARG_POINTER
(
aChild
)
;
RefPtr
<
nsDocLoader
>
childAsDocLoader
=
GetAsDocLoader
(
aChild
)
;
NS_ENSURE_TRUE
(
childAsDocLoader
NS_ERROR_UNEXPECTED
)
;
nsresult
rv
=
RemoveChildLoader
(
childAsDocLoader
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aChild
-
>
SetTreeOwner
(
nullptr
)
;
return
nsDocLoader
:
:
AddDocLoaderAsChildOfRoot
(
childAsDocLoader
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetInProcessChildAt
(
int32_t
aIndex
nsIDocShellTreeItem
*
*
aChild
)
{
NS_ENSURE_ARG_POINTER
(
aChild
)
;
RefPtr
<
nsDocShell
>
child
=
GetInProcessChildAt
(
aIndex
)
;
NS_ENSURE_TRUE
(
child
NS_ERROR_UNEXPECTED
)
;
child
.
forget
(
aChild
)
;
return
NS_OK
;
}
nsDocShell
*
nsDocShell
:
:
GetInProcessChildAt
(
int32_t
aIndex
)
{
#
ifdef
DEBUG
if
(
aIndex
<
0
)
{
NS_WARNING
(
"
Negative
index
passed
to
GetChildAt
"
)
;
}
else
if
(
static_cast
<
uint32_t
>
(
aIndex
)
>
=
mChildList
.
Length
(
)
)
{
NS_WARNING
(
"
Too
large
an
index
passed
to
GetChildAt
"
)
;
}
#
endif
nsIDocumentLoader
*
child
=
ChildAt
(
aIndex
)
;
return
static_cast
<
nsDocShell
*
>
(
child
)
;
}
nsresult
nsDocShell
:
:
AddChildSHEntry
(
nsISHEntry
*
aCloneRef
nsISHEntry
*
aNewEntry
int32_t
aChildOffset
uint32_t
aLoadType
bool
aCloneChildren
)
{
MOZ_ASSERT
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
;
nsresult
rv
=
NS_OK
;
if
(
mLSHE
&
&
aLoadType
!
=
LOAD_PUSHSTATE
)
{
if
(
NS_FAILED
(
mLSHE
-
>
ReplaceChild
(
aNewEntry
)
)
)
{
rv
=
mLSHE
-
>
AddChild
(
aNewEntry
aChildOffset
)
;
}
}
else
if
(
!
aCloneRef
)
{
if
(
mOSHE
)
{
rv
=
mOSHE
-
>
AddChild
(
aNewEntry
aChildOffset
UseRemoteSubframes
(
)
)
;
}
}
else
{
RefPtr
<
ChildSHistory
>
shistory
=
GetRootSessionHistory
(
)
;
if
(
shistory
)
{
rv
=
shistory
-
>
LegacySHistory
(
)
-
>
AddChildSHEntryHelper
(
aCloneRef
aNewEntry
mBrowsingContext
-
>
Top
(
)
aCloneChildren
)
;
}
}
return
rv
;
}
nsresult
nsDocShell
:
:
AddChildSHEntryToParent
(
nsISHEntry
*
aNewEntry
int32_t
aChildOffset
bool
aCloneChildren
)
{
MOZ_ASSERT
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
rootSH
)
{
mPreviousEntryIndex
=
rootSH
-
>
Index
(
)
;
}
nsresult
rv
;
nsCOMPtr
<
nsIDocShell
>
parent
=
do_QueryInterface
(
GetAsSupports
(
mParent
)
&
rv
)
;
NS_WARNING_ASSERTION
(
parent
|
|
!
UseRemoteSubframes
(
)
"
Failed
to
add
child
session
history
entry
!
This
will
be
resolved
once
"
"
session
history
in
the
parent
is
enabled
.
"
)
;
if
(
parent
)
{
rv
=
nsDocShell
:
:
Cast
(
parent
)
-
>
AddChildSHEntry
(
mOSHE
aNewEntry
aChildOffset
mLoadType
aCloneChildren
)
;
}
if
(
rootSH
)
{
mLoadedEntryIndex
=
rootSH
-
>
Index
(
)
;
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
gPageCacheLog
LogLevel
:
:
Verbose
)
)
)
{
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Verbose
(
"
Previous
index
:
%
d
Loaded
index
:
%
d
"
mPreviousEntryIndex
mLoadedEntryIndex
)
)
;
}
}
return
rv
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCurrentSHEntry
(
nsISHEntry
*
*
aEntry
bool
*
aOSHE
)
{
*
aOSHE
=
false
;
*
aEntry
=
nullptr
;
if
(
mLSHE
)
{
NS_ADDREF
(
*
aEntry
=
mLSHE
)
;
}
else
if
(
mOSHE
)
{
NS_ADDREF
(
*
aEntry
=
mOSHE
)
;
*
aOSHE
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SynchronizeLayoutHistoryState
(
)
{
if
(
mActiveEntry
&
&
mActiveEntry
-
>
GetLayoutHistoryState
(
)
&
&
mBrowsingContext
)
{
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
contentChild
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
if
(
contentChild
)
{
contentChild
-
>
SendSynchronizeLayoutHistoryState
(
mBrowsingContext
mActiveEntry
-
>
GetLayoutHistoryState
(
)
)
;
}
}
else
{
SessionHistoryEntry
*
entry
=
mBrowsingContext
-
>
Canonical
(
)
-
>
GetActiveSessionHistoryEntry
(
)
;
if
(
entry
)
{
entry
-
>
SetLayoutHistoryState
(
mActiveEntry
-
>
GetLayoutHistoryState
(
)
)
;
}
}
if
(
mLoadingEntry
&
&
mLoadingEntry
-
>
mInfo
.
SharedId
(
)
=
=
mActiveEntry
-
>
SharedId
(
)
)
{
mLoadingEntry
-
>
mInfo
.
SetLayoutHistoryState
(
mActiveEntry
-
>
GetLayoutHistoryState
(
)
)
;
}
}
return
NS_OK
;
}
void
nsDocShell
:
:
SetLoadGroupDefaultLoadFlags
(
nsLoadFlags
aLoadFlags
)
{
if
(
mLoadGroup
)
{
mLoadGroup
-
>
SetDefaultLoadFlags
(
aLoadFlags
)
;
}
else
{
NS_WARNING
(
"
nsDocShell
:
:
SetLoadGroupDefaultLoadFlags
has
no
loadGroup
to
"
"
propagate
the
mode
to
"
)
;
}
}
nsIScriptGlobalObject
*
nsDocShell
:
:
GetScriptGlobalObject
(
)
{
NS_ENSURE_SUCCESS
(
EnsureScriptEnvironment
(
)
nullptr
)
;
return
mScriptGlobal
;
}
Document
*
nsDocShell
:
:
GetDocument
(
)
{
NS_ENSURE_SUCCESS
(
EnsureContentViewer
(
)
nullptr
)
;
return
mContentViewer
-
>
GetDocument
(
)
;
}
Document
*
nsDocShell
:
:
GetExtantDocument
(
)
{
return
mContentViewer
?
mContentViewer
-
>
GetDocument
(
)
:
nullptr
;
}
nsPIDOMWindowOuter
*
nsDocShell
:
:
GetWindow
(
)
{
if
(
NS_FAILED
(
EnsureScriptEnvironment
(
)
)
)
{
return
nullptr
;
}
return
mScriptGlobal
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetDomWindow
(
mozIDOMWindowProxy
*
*
aWindow
)
{
NS_ENSURE_ARG_POINTER
(
aWindow
)
;
nsresult
rv
=
EnsureScriptEnvironment
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
nsGlobalWindowOuter
>
window
=
mScriptGlobal
;
window
.
forget
(
aWindow
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetMessageManager
(
ContentFrameMessageManager
*
*
aMessageManager
)
{
RefPtr
<
ContentFrameMessageManager
>
mm
;
if
(
RefPtr
<
BrowserChild
>
browserChild
=
BrowserChild
:
:
GetFrom
(
this
)
)
{
mm
=
browserChild
-
>
GetMessageManager
(
)
;
}
else
if
(
nsPIDOMWindowOuter
*
win
=
GetWindow
(
)
)
{
mm
=
win
-
>
GetMessageManager
(
)
;
}
mm
.
forget
(
aMessageManager
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsNavigating
(
bool
*
aOut
)
{
*
aOut
=
mIsNavigating
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetDeviceSizeIsPageSize
(
bool
aValue
)
{
if
(
mDeviceSizeIsPageSize
!
=
aValue
)
{
mDeviceSizeIsPageSize
=
aValue
;
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
presContext
-
>
MediaFeatureValuesChanged
(
{
MediaFeatureChangeReason
:
:
DeviceSizeIsPageSizeChange
}
MediaFeatureChangePropagation
:
:
JustThisDocument
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetDeviceSizeIsPageSize
(
bool
*
aValue
)
{
*
aValue
=
mDeviceSizeIsPageSize
;
return
NS_OK
;
}
void
nsDocShell
:
:
ClearFrameHistory
(
nsISHEntry
*
aEntry
)
{
MOZ_ASSERT
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
!
rootSH
|
|
!
aEntry
)
{
return
;
}
rootSH
-
>
LegacySHistory
(
)
-
>
RemoveFrameEntries
(
aEntry
)
;
}
bool
nsDocShell
:
:
NavigationBlockedByPrinting
(
bool
aDisplayErrorDialog
)
{
if
(
!
mBrowsingContext
-
>
Top
(
)
-
>
GetIsPrinting
(
)
)
{
return
false
;
}
if
(
aDisplayErrorDialog
)
{
DisplayLoadError
(
NS_ERROR_DOCUMENT_IS_PRINTMODE
nullptr
nullptr
nullptr
)
;
}
return
true
;
}
bool
nsDocShell
:
:
IsNavigationAllowed
(
bool
aDisplayPrintErrorDialog
bool
aCheckIfUnloadFired
)
{
bool
isAllowed
=
!
NavigationBlockedByPrinting
(
aDisplayPrintErrorDialog
)
&
&
(
!
aCheckIfUnloadFired
|
|
!
mFiredUnloadEvent
)
;
if
(
!
isAllowed
)
{
return
false
;
}
if
(
!
mContentViewer
)
{
return
true
;
}
bool
firingBeforeUnload
;
mContentViewer
-
>
GetBeforeUnloadFiring
(
&
firingBeforeUnload
)
;
return
!
firingBeforeUnload
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCanGoBack
(
bool
*
aCanGoBack
)
{
*
aCanGoBack
=
false
;
if
(
!
IsNavigationAllowed
(
false
)
)
{
return
NS_OK
;
}
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
rootSH
)
{
*
aCanGoBack
=
rootSH
-
>
CanGo
(
-
1
)
;
MOZ_LOG
(
gSHLog
LogLevel
:
:
Verbose
(
"
nsDocShell
%
p
CanGoBack
(
)
-
>
%
d
"
this
*
aCanGoBack
)
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCanGoForward
(
bool
*
aCanGoForward
)
{
*
aCanGoForward
=
false
;
if
(
!
IsNavigationAllowed
(
false
)
)
{
return
NS_OK
;
}
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
rootSH
)
{
*
aCanGoForward
=
rootSH
-
>
CanGo
(
1
)
;
MOZ_LOG
(
gSHLog
LogLevel
:
:
Verbose
(
"
nsDocShell
%
p
CanGoForward
(
)
-
>
%
d
"
this
*
aCanGoForward
)
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsDocShell
:
:
GoBack
(
bool
aRequireUserInteraction
bool
aUserActivation
)
{
if
(
!
IsNavigationAllowed
(
)
)
{
return
NS_OK
;
}
auto
cleanupIsNavigating
=
MakeScopeExit
(
[
&
]
(
)
{
mIsNavigating
=
false
;
}
)
;
mIsNavigating
=
true
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
NS_ENSURE_TRUE
(
rootSH
NS_ERROR_FAILURE
)
;
ErrorResult
rv
;
rootSH
-
>
Go
(
-
1
aRequireUserInteraction
aUserActivation
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GoForward
(
bool
aRequireUserInteraction
bool
aUserActivation
)
{
if
(
!
IsNavigationAllowed
(
)
)
{
return
NS_OK
;
}
auto
cleanupIsNavigating
=
MakeScopeExit
(
[
&
]
(
)
{
mIsNavigating
=
false
;
}
)
;
mIsNavigating
=
true
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
NS_ENSURE_TRUE
(
rootSH
NS_ERROR_FAILURE
)
;
ErrorResult
rv
;
rootSH
-
>
Go
(
1
aRequireUserInteraction
aUserActivation
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GotoIndex
(
int32_t
aIndex
bool
aUserActivation
)
{
if
(
!
IsNavigationAllowed
(
)
)
{
return
NS_OK
;
}
auto
cleanupIsNavigating
=
MakeScopeExit
(
[
&
]
(
)
{
mIsNavigating
=
false
;
}
)
;
mIsNavigating
=
true
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
NS_ENSURE_TRUE
(
rootSH
NS_ERROR_FAILURE
)
;
ErrorResult
rv
;
rootSH
-
>
GotoIndex
(
aIndex
aIndex
-
rootSH
-
>
Index
(
)
false
aUserActivation
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
nsresult
nsDocShell
:
:
LoadURI
(
nsIURI
*
aURI
const
LoadURIOptions
&
aLoadURIOptions
)
{
if
(
!
IsNavigationAllowed
(
)
)
{
return
NS_OK
;
}
RefPtr
<
nsDocShellLoadState
>
loadState
;
nsresult
rv
=
nsDocShellLoadState
:
:
CreateFromLoadURIOptions
(
mBrowsingContext
aURI
aLoadURIOptions
getter_AddRefs
(
loadState
)
)
;
MOZ_ASSERT
(
rv
!
=
NS_ERROR_MALFORMED_URI
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
loadState
)
{
return
NS_ERROR_FAILURE
;
}
return
LoadURI
(
loadState
true
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
LoadURIFromScript
(
nsIURI
*
aURI
JS
:
:
Handle
<
JS
:
:
Value
>
aLoadURIOptions
JSContext
*
aCx
)
{
LoadURIOptions
loadURIOptions
;
if
(
!
loadURIOptions
.
Init
(
aCx
aLoadURIOptions
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
LoadURI
(
aURI
loadURIOptions
)
;
}
nsresult
nsDocShell
:
:
FixupAndLoadURIString
(
const
nsAString
&
aURIString
const
LoadURIOptions
&
aLoadURIOptions
)
{
if
(
!
IsNavigationAllowed
(
)
)
{
return
NS_OK
;
}
RefPtr
<
nsDocShellLoadState
>
loadState
;
nsresult
rv
=
nsDocShellLoadState
:
:
CreateFromLoadURIOptions
(
mBrowsingContext
aURIString
aLoadURIOptions
getter_AddRefs
(
loadState
)
)
;
uint32_t
loadFlags
=
aLoadURIOptions
.
mLoadFlags
;
if
(
NS_ERROR_MALFORMED_URI
=
=
rv
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
Creating
an
active
entry
on
nsDocShell
%
p
to
%
s
(
because
"
"
we
'
re
showing
an
error
page
)
"
this
NS_ConvertUTF16toUTF8
(
aURIString
)
.
get
(
)
)
)
;
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewURI
(
getter_AddRefs
(
uri
)
"
about
:
blank
"
_ns
)
)
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
;
if
(
aLoadURIOptions
.
mTriggeringPrincipal
)
{
triggeringPrincipal
=
aLoadURIOptions
.
mTriggeringPrincipal
;
}
else
{
triggeringPrincipal
=
nsContentUtils
:
:
GetSystemPrincipal
(
)
;
}
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
mActiveEntry
=
MakeUnique
<
SessionHistoryInfo
>
(
uri
triggeringPrincipal
nullptr
nullptr
nullptr
nsLiteralCString
(
"
text
/
html
"
)
)
;
mBrowsingContext
-
>
SetActiveSessionHistoryEntry
(
Nothing
(
)
mActiveEntry
.
get
(
)
MAKE_LOAD_TYPE
(
LOAD_NORMAL
loadFlags
)
0
)
;
}
if
(
DisplayLoadError
(
rv
nullptr
PromiseFlatString
(
aURIString
)
.
get
(
)
nullptr
)
&
&
(
loadFlags
&
LOAD_FLAGS_ERROR_LOAD_CHANGES_RV
)
!
=
0
)
{
return
NS_ERROR_LOAD_SHOWED_ERRORPAGE
;
}
}
if
(
NS_FAILED
(
rv
)
|
|
!
loadState
)
{
return
NS_ERROR_FAILURE
;
}
return
LoadURI
(
loadState
true
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
FixupAndLoadURIStringFromScript
(
const
nsAString
&
aURIString
JS
:
:
Handle
<
JS
:
:
Value
>
aLoadURIOptions
JSContext
*
aCx
)
{
LoadURIOptions
loadURIOptions
;
if
(
!
loadURIOptions
.
Init
(
aCx
aLoadURIOptions
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
FixupAndLoadURIString
(
aURIString
loadURIOptions
)
;
}
void
nsDocShell
:
:
UnblockEmbedderLoadEventForFailure
(
bool
aFireFrameErrorEvent
)
{
if
(
mBrowsingContext
-
>
IsTopContent
(
)
|
|
mBrowsingContext
-
>
IsChrome
(
)
)
{
return
;
}
RefPtr
<
Element
>
element
=
mBrowsingContext
-
>
GetEmbedderElement
(
)
;
if
(
element
)
{
if
(
aFireFrameErrorEvent
)
{
if
(
RefPtr
<
nsFrameLoaderOwner
>
flo
=
do_QueryObject
(
element
)
)
{
if
(
RefPtr
<
nsFrameLoader
>
fl
=
flo
-
>
GetFrameLoader
(
)
)
{
fl
-
>
FireErrorEvent
(
)
;
}
}
}
return
;
}
RefPtr
<
BrowserChild
>
browserChild
=
BrowserChild
:
:
GetFrom
(
this
)
;
if
(
browserChild
)
{
mozilla
:
:
Unused
<
<
browserChild
-
>
SendMaybeFireEmbedderLoadEvents
(
aFireFrameErrorEvent
?
EmbedderElementEventType
:
:
ErrorEvent
:
EmbedderElementEventType
:
:
NoEvent
)
;
}
}
NS_IMETHODIMP
nsDocShell
:
:
DisplayLoadError
(
nsresult
aError
nsIURI
*
aURI
const
char16_t
*
aURL
nsIChannel
*
aFailedChannel
bool
*
aDisplayedErrorPage
)
{
MOZ_LOG
(
gDocShellLeakLog
LogLevel
:
:
Debug
(
"
DOCSHELL
%
p
DisplayLoadError
%
s
\
n
"
this
aURI
?
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
)
)
;
*
aDisplayedErrorPage
=
false
;
nsCOMPtr
<
nsIPrompt
>
prompter
;
nsCOMPtr
<
nsIStringBundle
>
stringBundle
;
GetPromptAndStringBundle
(
getter_AddRefs
(
prompter
)
getter_AddRefs
(
stringBundle
)
)
;
NS_ENSURE_TRUE
(
stringBundle
NS_ERROR_FAILURE
)
;
NS_ENSURE_TRUE
(
prompter
NS_ERROR_FAILURE
)
;
const
char
*
error
=
nullptr
;
const
char
*
errorDescriptionID
=
nullptr
;
AutoTArray
<
nsString
3
>
formatStrs
;
bool
addHostPort
=
false
;
bool
isBadStsCertError
=
false
;
nsresult
rv
=
NS_OK
;
nsAutoString
messageStr
;
nsAutoCString
cssClass
;
nsAutoCString
errorPage
;
errorPage
.
AssignLiteral
(
"
neterror
"
)
;
if
(
NS_ERROR_UNKNOWN_PROTOCOL
=
=
aError
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsAutoCString
scheme
;
aURI
-
>
GetScheme
(
scheme
)
;
CopyASCIItoUTF16
(
scheme
*
formatStrs
.
AppendElement
(
)
)
;
nsCOMPtr
<
nsINestedURI
>
nestedURI
=
do_QueryInterface
(
aURI
)
;
while
(
nestedURI
)
{
nsCOMPtr
<
nsIURI
>
tempURI
;
nsresult
rv2
;
rv2
=
nestedURI
-
>
GetInnerURI
(
getter_AddRefs
(
tempURI
)
)
;
if
(
NS_SUCCEEDED
(
rv2
)
&
&
tempURI
)
{
tempURI
-
>
GetScheme
(
scheme
)
;
formatStrs
[
0
]
.
AppendLiteral
(
"
"
)
;
AppendASCIItoUTF16
(
scheme
formatStrs
[
0
]
)
;
}
nestedURI
=
do_QueryInterface
(
tempURI
)
;
}
error
=
"
unknownProtocolFound
"
;
}
else
if
(
NS_ERROR_FILE_NOT_FOUND
=
=
aError
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
error
=
"
fileNotFound
"
;
}
else
if
(
NS_ERROR_FILE_ACCESS_DENIED
=
=
aError
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
error
=
"
fileAccessDenied
"
;
}
else
if
(
NS_ERROR_UNKNOWN_HOST
=
=
aError
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsAutoCString
host
;
nsCOMPtr
<
nsIURI
>
innermostURI
=
NS_GetInnermostURI
(
aURI
)
;
innermostURI
-
>
GetHost
(
host
)
;
CopyUTF8toUTF16
(
host
*
formatStrs
.
AppendElement
(
)
)
;
errorDescriptionID
=
"
dnsNotFound2
"
;
error
=
"
dnsNotFound
"
;
}
else
if
(
NS_ERROR_CONNECTION_REFUSED
=
=
aError
|
|
NS_ERROR_PROXY_BAD_GATEWAY
=
=
aError
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
addHostPort
=
true
;
error
=
"
connectionFailure
"
;
}
else
if
(
NS_ERROR_NET_INTERRUPT
=
=
aError
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
addHostPort
=
true
;
error
=
"
netInterrupt
"
;
}
else
if
(
NS_ERROR_NET_TIMEOUT
=
=
aError
|
|
NS_ERROR_PROXY_GATEWAY_TIMEOUT
=
=
aError
|
|
NS_ERROR_NET_TIMEOUT_EXTERNAL
=
=
aError
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsAutoCString
host
;
aURI
-
>
GetHost
(
host
)
;
CopyUTF8toUTF16
(
host
*
formatStrs
.
AppendElement
(
)
)
;
error
=
"
netTimeout
"
;
}
else
if
(
NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION
=
=
aError
|
|
NS_ERROR_CSP_FORM_ACTION_VIOLATION
=
=
aError
|
|
NS_ERROR_CSP_NAVIGATE_TO_VIOLATION
=
=
aError
)
{
cssClass
.
AssignLiteral
(
"
neterror
"
)
;
error
=
"
cspBlocked
"
;
}
else
if
(
NS_ERROR_XFO_VIOLATION
=
=
aError
)
{
cssClass
.
AssignLiteral
(
"
neterror
"
)
;
error
=
"
xfoBlocked
"
;
}
else
if
(
NS_ERROR_GET_MODULE
(
aError
)
=
=
NS_ERROR_MODULE_SECURITY
)
{
nsCOMPtr
<
nsINSSErrorsService
>
nsserr
=
do_GetService
(
NS_NSS_ERRORS_SERVICE_CONTRACTID
)
;
uint32_t
errorClass
;
if
(
!
nsserr
|
|
NS_FAILED
(
nsserr
-
>
GetErrorClass
(
aError
&
errorClass
)
)
)
{
errorClass
=
nsINSSErrorsService
:
:
ERROR_CLASS_SSL_PROTOCOL
;
}
nsCOMPtr
<
nsITransportSecurityInfo
>
tsi
;
if
(
aFailedChannel
)
{
aFailedChannel
-
>
GetSecurityInfo
(
getter_AddRefs
(
tsi
)
)
;
}
if
(
tsi
)
{
uint32_t
securityState
;
tsi
-
>
GetSecurityState
(
&
securityState
)
;
if
(
securityState
&
nsIWebProgressListener
:
:
STATE_USES_SSL_3
)
{
error
=
"
sslv3Used
"
;
addHostPort
=
true
;
}
else
if
(
securityState
&
nsIWebProgressListener
:
:
STATE_USES_WEAK_CRYPTO
)
{
error
=
"
weakCryptoUsed
"
;
addHostPort
=
true
;
}
}
else
{
if
(
nsserr
)
{
nsserr
-
>
GetErrorMessage
(
aError
messageStr
)
;
}
}
messageStr
.
Truncate
(
)
;
messageStr
.
AssignLiteral
(
u
"
"
)
;
if
(
errorClass
=
=
nsINSSErrorsService
:
:
ERROR_CLASS_BAD_CERT
)
{
error
=
"
nssBadCert
"
;
bool
isStsHost
=
false
;
bool
isPinnedHost
=
false
;
OriginAttributes
attrsForHSTS
;
if
(
aFailedChannel
)
{
StoragePrincipalHelper
:
:
GetOriginAttributesForHSTS
(
aFailedChannel
attrsForHSTS
)
;
}
else
{
attrsForHSTS
=
GetOriginAttributes
(
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsISiteSecurityService
>
sss
=
do_GetService
(
NS_SSSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
sss
-
>
IsSecureURI
(
aURI
attrsForHSTS
&
isStsHost
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
mozilla
:
:
dom
:
:
ContentChild
*
cc
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
cc
-
>
SendIsSecureURI
(
aURI
attrsForHSTS
&
isStsHost
)
;
}
nsCOMPtr
<
nsIPublicKeyPinningService
>
pkps
=
do_GetService
(
NS_PKPSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
pkps
-
>
HostHasPins
(
aURI
&
isPinnedHost
)
;
if
(
Preferences
:
:
GetBool
(
"
browser
.
xul
.
error_pages
.
expert_bad_cert
"
false
)
)
{
cssClass
.
AssignLiteral
(
"
expertBadCert
"
)
;
}
if
(
isStsHost
|
|
isPinnedHost
)
{
isBadStsCertError
=
true
;
cssClass
.
AssignLiteral
(
"
badStsCert
"
)
;
}
nsAutoCString
alternateErrorPage
;
nsresult
rv
=
Preferences
:
:
GetCString
(
"
security
.
alternate_certificate_error_page
"
alternateErrorPage
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
errorPage
.
Assign
(
alternateErrorPage
)
;
}
}
else
{
error
=
"
nssFailure2
"
;
}
}
else
if
(
NS_ERROR_PHISHING_URI
=
=
aError
|
|
NS_ERROR_MALWARE_URI
=
=
aError
|
|
NS_ERROR_UNWANTED_URI
=
=
aError
|
|
NS_ERROR_HARMFUL_URI
=
=
aError
)
{
nsAutoCString
host
;
aURI
-
>
GetHost
(
host
)
;
CopyUTF8toUTF16
(
host
*
formatStrs
.
AppendElement
(
)
)
;
nsAutoCString
alternateErrorPage
;
nsresult
rv
=
Preferences
:
:
GetCString
(
"
urlclassifier
.
alternate_error_page
"
alternateErrorPage
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
errorPage
.
Assign
(
alternateErrorPage
)
;
}
if
(
NS_ERROR_PHISHING_URI
=
=
aError
)
{
error
=
"
deceptiveBlocked
"
;
}
else
if
(
NS_ERROR_MALWARE_URI
=
=
aError
)
{
error
=
"
malwareBlocked
"
;
}
else
if
(
NS_ERROR_UNWANTED_URI
=
=
aError
)
{
error
=
"
unwantedBlocked
"
;
}
else
if
(
NS_ERROR_HARMFUL_URI
=
=
aError
)
{
error
=
"
harmfulBlocked
"
;
}
cssClass
.
AssignLiteral
(
"
blacklist
"
)
;
}
else
if
(
NS_ERROR_CONTENT_CRASHED
=
=
aError
)
{
errorPage
.
AssignLiteral
(
"
tabcrashed
"
)
;
error
=
"
tabcrashed
"
;
RefPtr
<
EventTarget
>
handler
=
mChromeEventHandler
;
if
(
handler
)
{
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
handler
)
;
element
-
>
GetAttribute
(
u
"
crashedPageTitle
"
_ns
messageStr
)
;
}
if
(
messageStr
.
IsEmpty
(
)
)
{
messageStr
.
AssignLiteral
(
u
"
"
)
;
}
}
else
if
(
NS_ERROR_FRAME_CRASHED
=
=
aError
)
{
errorPage
.
AssignLiteral
(
"
framecrashed
"
)
;
error
=
"
framecrashed
"
;
messageStr
.
AssignLiteral
(
u
"
"
)
;
}
else
if
(
NS_ERROR_BUILDID_MISMATCH
=
=
aError
)
{
errorPage
.
AssignLiteral
(
"
restartrequired
"
)
;
error
=
"
restartrequired
"
;
if
(
messageStr
.
IsEmpty
(
)
)
{
messageStr
.
AssignLiteral
(
u
"
"
)
;
}
}
else
{
switch
(
aError
)
{
case
NS_ERROR_MALFORMED_URI
:
error
=
"
malformedURI
"
;
errorDescriptionID
=
"
malformedURI2
"
;
break
;
case
NS_ERROR_REDIRECT_LOOP
:
error
=
"
redirectLoop
"
;
break
;
case
NS_ERROR_UNKNOWN_SOCKET_TYPE
:
error
=
"
unknownSocketType
"
;
break
;
case
NS_ERROR_NET_RESET
:
error
=
"
netReset
"
;
break
;
case
NS_ERROR_DOCUMENT_NOT_CACHED
:
error
=
"
notCached
"
;
break
;
case
NS_ERROR_OFFLINE
:
error
=
"
netOffline
"
;
break
;
case
NS_ERROR_DOCUMENT_IS_PRINTMODE
:
error
=
"
isprinting
"
;
break
;
case
NS_ERROR_PORT_ACCESS_NOT_ALLOWED
:
addHostPort
=
true
;
error
=
"
deniedPortAccess
"
;
break
;
case
NS_ERROR_UNKNOWN_PROXY_HOST
:
error
=
"
proxyResolveFailure
"
;
break
;
case
NS_ERROR_PROXY_CONNECTION_REFUSED
:
case
NS_ERROR_PROXY_FORBIDDEN
:
case
NS_ERROR_PROXY_NOT_IMPLEMENTED
:
case
NS_ERROR_PROXY_AUTHENTICATION_FAILED
:
case
NS_ERROR_PROXY_TOO_MANY_REQUESTS
:
error
=
"
proxyConnectFailure
"
;
break
;
case
NS_ERROR_INVALID_CONTENT_ENCODING
:
error
=
"
contentEncodingError
"
;
break
;
case
NS_ERROR_UNSAFE_CONTENT_TYPE
:
error
=
"
unsafeContentType
"
;
break
;
case
NS_ERROR_CORRUPTED_CONTENT
:
error
=
"
corruptedContentErrorv2
"
;
break
;
case
NS_ERROR_INTERCEPTION_FAILED
:
error
=
"
corruptedContentErrorv2
"
;
break
;
case
NS_ERROR_NET_INADEQUATE_SECURITY
:
error
=
"
inadequateSecurityError
"
;
addHostPort
=
true
;
break
;
case
NS_ERROR_BLOCKED_BY_POLICY
:
case
NS_ERROR_DOM_COOP_FAILED
:
case
NS_ERROR_DOM_COEP_FAILED
:
error
=
"
blockedByPolicy
"
;
break
;
case
NS_ERROR_NET_HTTP2_SENT_GOAWAY
:
case
NS_ERROR_NET_HTTP3_PROTOCOL_ERROR
:
error
=
"
networkProtocolError
"
;
break
;
default
:
break
;
}
}
nsresult
delegateErrorCode
=
aError
;
if
(
nsHTTPSOnlyUtils
:
:
CouldBeHttpsOnlyError
(
aFailedChannel
aError
)
)
{
errorPage
.
AssignLiteral
(
"
httpsonlyerror
"
)
;
delegateErrorCode
=
NS_ERROR_HTTPS_ONLY
;
}
else
if
(
isBadStsCertError
)
{
delegateErrorCode
=
NS_ERROR_BAD_HSTS_CERT
;
}
if
(
nsCOMPtr
<
nsILoadURIDelegate
>
loadURIDelegate
=
GetLoadURIDelegate
(
)
)
{
nsCOMPtr
<
nsIURI
>
errorPageURI
;
rv
=
loadURIDelegate
-
>
HandleLoadError
(
aURI
delegateErrorCode
NS_ERROR_GET_MODULE
(
delegateErrorCode
)
getter_AddRefs
(
errorPageURI
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
mIsBeingDestroyed
)
{
*
aDisplayedErrorPage
=
false
;
return
NS_OK
;
}
if
(
errorPageURI
)
{
*
aDisplayedErrorPage
=
NS_SUCCEEDED
(
LoadErrorPage
(
errorPageURI
aURI
aFailedChannel
)
)
;
return
NS_OK
;
}
}
if
(
!
error
)
{
return
NS_OK
;
}
if
(
!
errorDescriptionID
)
{
errorDescriptionID
=
error
;
}
Telemetry
:
:
AccumulateCategoricalKeyed
(
IsSubframe
(
)
?
"
frame
"
_ns
:
"
top
"
_ns
mozilla
:
:
dom
:
:
LoadErrorToTelemetryLabel
(
aError
)
)
;
if
(
!
messageStr
.
IsEmpty
(
)
)
{
}
else
{
if
(
addHostPort
)
{
nsAutoCString
hostport
;
if
(
aURI
)
{
aURI
-
>
GetHostPort
(
hostport
)
;
}
else
{
hostport
.
Assign
(
'
?
'
)
;
}
CopyUTF8toUTF16
(
hostport
*
formatStrs
.
AppendElement
(
)
)
;
}
nsAutoCString
spec
;
rv
=
NS_ERROR_NOT_AVAILABLE
;
auto
&
nextFormatStr
=
*
formatStrs
.
AppendElement
(
)
;
if
(
aURI
)
{
if
(
SchemeIsFile
(
aURI
)
)
{
aURI
-
>
GetPathQueryRef
(
spec
)
;
}
else
{
aURI
-
>
GetSpec
(
spec
)
;
}
nsCOMPtr
<
nsITextToSubURI
>
textToSubURI
(
do_GetService
(
NS_ITEXTTOSUBURI_CONTRACTID
&
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
textToSubURI
-
>
UnEscapeURIForUI
(
spec
nextFormatStr
)
;
}
}
else
{
spec
.
Assign
(
'
?
'
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
CopyUTF8toUTF16
(
spec
nextFormatStr
)
;
}
rv
=
NS_OK
;
nsAutoString
str
;
rv
=
stringBundle
-
>
FormatStringFromName
(
errorDescriptionID
formatStrs
str
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
messageStr
.
Assign
(
str
)
;
}
NS_ENSURE_FALSE
(
messageStr
.
IsEmpty
(
)
NS_ERROR_FAILURE
)
;
if
(
(
NS_ERROR_NET_INTERRUPT
=
=
aError
|
|
NS_ERROR_NET_RESET
=
=
aError
)
&
&
SchemeIsHTTPS
(
aURI
)
)
{
error
=
"
nssFailure2
"
;
}
if
(
mBrowsingContext
-
>
GetUseErrorPages
(
)
)
{
nsresult
loadedPage
=
LoadErrorPage
(
aURI
aURL
errorPage
.
get
(
)
error
messageStr
.
get
(
)
cssClass
.
get
(
)
aFailedChannel
)
;
*
aDisplayedErrorPage
=
NS_SUCCEEDED
(
loadedPage
)
;
}
else
{
if
(
mScriptGlobal
)
{
Unused
<
<
mScriptGlobal
-
>
GetDoc
(
)
;
}
prompter
-
>
Alert
(
nullptr
messageStr
.
get
(
)
)
;
}
return
NS_OK
;
}
#
define
PREF_SAFEBROWSING_ALLOWOVERRIDE
"
browser
.
safebrowsing
.
allowOverride
"
nsresult
nsDocShell
:
:
LoadErrorPage
(
nsIURI
*
aURI
const
char16_t
*
aURL
const
char
*
aErrorPage
const
char
*
aErrorType
const
char16_t
*
aDescription
const
char
*
aCSSClass
nsIChannel
*
aFailedChannel
)
{
if
(
mIsBeingDestroyed
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
#
if
defined
(
DEBUG
)
if
(
MOZ_LOG_TEST
(
gDocShellLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
chanName
;
if
(
aFailedChannel
)
{
aFailedChannel
-
>
GetName
(
chanName
)
;
}
else
{
chanName
.
AssignLiteral
(
"
<
no
channel
>
"
)
;
}
MOZ_LOG
(
gDocShellLog
LogLevel
:
:
Debug
(
"
nsDocShell
[
%
p
]
:
:
LoadErrorPage
(
\
"
%
s
\
"
\
"
%
s
\
"
{
.
.
.
}
[
%
s
]
)
\
n
"
this
aURI
?
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
NS_ConvertUTF16toUTF8
(
aURL
)
.
get
(
)
chanName
.
get
(
)
)
)
;
}
#
endif
nsAutoCString
url
;
if
(
aURI
)
{
nsresult
rv
=
aURI
-
>
GetSpec
(
url
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
aURL
)
{
CopyUTF16toUTF8
(
MakeStringSpan
(
aURL
)
url
)
;
}
else
{
return
NS_ERROR_INVALID_POINTER
;
}
#
undef
SAFE_ESCAPE
#
define
SAFE_ESCAPE
(
output
input
params
)
\
if
(
NS_WARN_IF
(
!
NS_Escape
(
input
output
params
)
)
)
{
\
return
NS_ERROR_OUT_OF_MEMORY
;
\
}
nsCString
escapedUrl
escapedError
escapedDescription
escapedCSSClass
;
SAFE_ESCAPE
(
escapedUrl
url
url_Path
)
;
SAFE_ESCAPE
(
escapedError
nsDependentCString
(
aErrorType
)
url_Path
)
;
SAFE_ESCAPE
(
escapedDescription
NS_ConvertUTF16toUTF8
(
aDescription
)
url_Path
)
;
if
(
aCSSClass
)
{
nsCString
cssClass
(
aCSSClass
)
;
SAFE_ESCAPE
(
escapedCSSClass
cssClass
url_Path
)
;
}
nsCString
errorPageUrl
(
"
about
:
"
)
;
errorPageUrl
.
AppendASCII
(
aErrorPage
)
;
errorPageUrl
.
AppendLiteral
(
"
?
e
=
"
)
;
errorPageUrl
.
AppendASCII
(
escapedError
.
get
(
)
)
;
errorPageUrl
.
AppendLiteral
(
"
&
u
=
"
)
;
errorPageUrl
.
AppendASCII
(
escapedUrl
.
get
(
)
)
;
if
(
(
strcmp
(
aErrorPage
"
blocked
"
)
=
=
0
)
&
&
Preferences
:
:
GetBool
(
PREF_SAFEBROWSING_ALLOWOVERRIDE
true
)
)
{
errorPageUrl
.
AppendLiteral
(
"
&
o
=
1
"
)
;
}
if
(
!
escapedCSSClass
.
IsEmpty
(
)
)
{
errorPageUrl
.
AppendLiteral
(
"
&
s
=
"
)
;
errorPageUrl
.
AppendASCII
(
escapedCSSClass
.
get
(
)
)
;
}
errorPageUrl
.
AppendLiteral
(
"
&
c
=
UTF
-
8
"
)
;
nsCOMPtr
<
nsICaptivePortalService
>
cps
=
do_GetService
(
NS_CAPTIVEPORTAL_CID
)
;
int32_t
cpsState
;
if
(
cps
&
&
NS_SUCCEEDED
(
cps
-
>
GetState
(
&
cpsState
)
)
&
&
cpsState
=
=
nsICaptivePortalService
:
:
LOCKED_PORTAL
)
{
errorPageUrl
.
AppendLiteral
(
"
&
captive
=
true
"
)
;
}
errorPageUrl
.
AppendLiteral
(
"
&
d
=
"
)
;
errorPageUrl
.
AppendASCII
(
escapedDescription
.
get
(
)
)
;
nsCOMPtr
<
nsIURI
>
errorPageURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
errorPageURI
)
errorPageUrl
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
LoadErrorPage
(
errorPageURI
aURI
aFailedChannel
)
;
}
nsresult
nsDocShell
:
:
LoadErrorPage
(
nsIURI
*
aErrorURI
nsIURI
*
aFailedURI
nsIChannel
*
aFailedChannel
)
{
mFailedChannel
=
aFailedChannel
;
mFailedURI
=
aFailedURI
;
mFailedLoadType
=
mLoadType
;
if
(
mLSHE
)
{
mLSHE
-
>
AbandonBFCacheEntry
(
)
;
}
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
aErrorURI
)
;
loadState
-
>
SetTriggeringPrincipal
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
if
(
mBrowsingContext
)
{
loadState
-
>
SetTriggeringSandboxFlags
(
mBrowsingContext
-
>
GetSandboxFlags
(
)
)
;
}
loadState
-
>
SetLoadType
(
LOAD_ERROR_PAGE
)
;
loadState
-
>
SetFirstParty
(
true
)
;
loadState
-
>
SetSourceBrowsingContext
(
mBrowsingContext
)
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
&
&
mLoadingEntry
)
{
loadState
-
>
SetLoadingSessionHistoryInfo
(
MakeUnique
<
LoadingSessionHistoryInfo
>
(
*
mLoadingEntry
)
)
;
}
return
InternalLoad
(
loadState
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
Reload
(
uint32_t
aReloadFlags
)
{
if
(
!
IsNavigationAllowed
(
)
)
{
return
NS_OK
;
}
NS_ASSERTION
(
(
(
aReloadFlags
&
INTERNAL_LOAD_FLAGS_LOADURI_SETUP_FLAGS
)
=
=
0
)
"
Reload
command
not
updated
to
use
load
flags
!
"
)
;
NS_ASSERTION
(
(
aReloadFlags
&
EXTRA_LOAD_FLAGS
)
=
=
0
"
Don
'
t
pass
these
flags
to
Reload
"
)
;
uint32_t
loadType
=
MAKE_LOAD_TYPE
(
LOAD_RELOAD_NORMAL
aReloadFlags
)
;
NS_ENSURE_TRUE
(
IsValidLoadType
(
loadType
)
NS_ERROR_INVALID_ARG
)
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
%
p
Reload
"
this
)
)
;
bool
forceReload
=
IsForceReloadType
(
loadType
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
RefPtr
<
nsDocShell
>
docShell
(
this
)
;
nsCOMPtr
<
nsIContentViewer
>
cv
(
mContentViewer
)
;
NS_ENSURE_STATE
(
cv
)
;
bool
okToUnload
=
true
;
MOZ_TRY
(
cv
-
>
PermitUnload
(
&
okToUnload
)
)
;
if
(
!
okToUnload
)
{
return
NS_OK
;
}
RefPtr
<
Document
>
doc
(
GetDocument
(
)
)
;
RefPtr
<
BrowsingContext
>
browsingContext
(
mBrowsingContext
)
;
nsCOMPtr
<
nsIURI
>
currentURI
(
mCurrentURI
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
(
mReferrerInfo
)
;
RefPtr
<
StopDetector
>
stopDetector
=
new
StopDetector
(
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
if
(
loadGroup
)
{
loadGroup
-
>
AddRequest
(
stopDetector
nullptr
)
;
}
ContentChild
:
:
GetSingleton
(
)
-
>
SendNotifyOnHistoryReload
(
mBrowsingContext
forceReload
[
docShell
doc
loadType
browsingContext
currentURI
referrerInfo
loadGroup
stopDetector
]
(
Tuple
<
bool
Maybe
<
RefPtr
<
nsDocShellLoadState
>
>
Maybe
<
bool
>
>
&
&
aResult
)
{
auto
scopeExit
=
MakeScopeExit
(
[
loadGroup
stopDetector
]
(
)
{
if
(
loadGroup
)
{
loadGroup
-
>
RemoveRequest
(
stopDetector
nullptr
NS_OK
)
;
}
}
)
;
if
(
stopDetector
-
>
Canceled
(
)
)
{
return
;
}
bool
canReload
;
Maybe
<
RefPtr
<
nsDocShellLoadState
>
>
loadState
;
Maybe
<
bool
>
reloadingActiveEntry
;
Tie
(
canReload
loadState
reloadingActiveEntry
)
=
aResult
;
if
(
!
canReload
)
{
return
;
}
if
(
loadState
.
isSome
(
)
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
%
p
Reload
-
LoadHistoryEntry
"
docShell
.
get
(
)
)
)
;
loadState
.
ref
(
)
-
>
SetNotifiedBeforeUnloadListeners
(
true
)
;
docShell
-
>
LoadHistoryEntry
(
loadState
.
ref
(
)
loadType
reloadingActiveEntry
.
ref
(
)
)
;
}
else
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
%
p
ReloadDocument
"
docShell
.
get
(
)
)
)
;
ReloadDocument
(
docShell
doc
loadType
browsingContext
currentURI
referrerInfo
true
)
;
}
}
[
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
)
{
}
)
;
}
else
{
bool
canReload
=
false
;
Maybe
<
RefPtr
<
nsDocShellLoadState
>
>
loadState
;
Maybe
<
bool
>
reloadingActiveEntry
;
if
(
!
mBrowsingContext
-
>
IsDiscarded
(
)
)
{
mBrowsingContext
-
>
Canonical
(
)
-
>
NotifyOnHistoryReload
(
forceReload
canReload
loadState
reloadingActiveEntry
)
;
}
if
(
canReload
)
{
if
(
loadState
.
isSome
(
)
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
%
p
Reload
-
LoadHistoryEntry
"
this
)
)
;
LoadHistoryEntry
(
loadState
.
ref
(
)
loadType
reloadingActiveEntry
.
ref
(
)
)
;
}
else
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
%
p
ReloadDocument
"
this
)
)
;
ReloadDocument
(
this
GetDocument
(
)
loadType
mBrowsingContext
mCurrentURI
mReferrerInfo
)
;
}
}
}
return
NS_OK
;
}
bool
canReload
=
true
;
if
(
rootSH
)
{
rootSH
-
>
LegacySHistory
(
)
-
>
NotifyOnHistoryReload
(
&
canReload
)
;
}
if
(
!
canReload
)
{
return
NS_OK
;
}
if
(
mOSHE
)
{
return
LoadHistoryEntry
(
mOSHE
loadType
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_USER_ACTIVATION
)
;
}
if
(
mLSHE
)
{
return
LoadHistoryEntry
(
mLSHE
loadType
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_USER_ACTIVATION
)
;
}
return
ReloadDocument
(
this
GetDocument
(
)
loadType
mBrowsingContext
mCurrentURI
mReferrerInfo
)
;
}
nsresult
nsDocShell
:
:
ReloadDocument
(
nsDocShell
*
aDocShell
Document
*
aDocument
uint32_t
aLoadType
BrowsingContext
*
aBrowsingContext
nsIURI
*
aCurrentURI
nsIReferrerInfo
*
aReferrerInfo
bool
aNotifiedBeforeUnloadListeners
)
{
if
(
!
aDocument
)
{
return
NS_OK
;
}
uint32_t
flags
=
INTERNAL_LOAD_FLAGS_NONE
;
nsAutoString
srcdoc
;
nsIURI
*
baseURI
=
nullptr
;
nsCOMPtr
<
nsIURI
>
originalURI
;
nsCOMPtr
<
nsIURI
>
resultPrincipalURI
;
bool
loadReplace
=
false
;
nsIPrincipal
*
triggeringPrincipal
=
aDocument
-
>
NodePrincipal
(
)
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aDocument
-
>
GetCsp
(
)
;
uint32_t
triggeringSandboxFlags
=
aDocument
-
>
GetSandboxFlags
(
)
;
nsAutoString
contentTypeHint
;
aDocument
-
>
GetContentType
(
contentTypeHint
)
;
if
(
aDocument
-
>
IsSrcdocDocument
(
)
)
{
aDocument
-
>
GetSrcdocData
(
srcdoc
)
;
flags
|
=
INTERNAL_LOAD_FLAGS_IS_SRCDOC
;
baseURI
=
aDocument
-
>
GetBaseURI
(
)
;
}
else
{
srcdoc
=
VoidString
(
)
;
}
nsCOMPtr
<
nsIChannel
>
chan
=
aDocument
-
>
GetChannel
(
)
;
if
(
chan
)
{
uint32_t
loadFlags
;
chan
-
>
GetLoadFlags
(
&
loadFlags
)
;
loadReplace
=
loadFlags
&
nsIChannel
:
:
LOAD_REPLACE
;
nsCOMPtr
<
nsIHttpChannel
>
httpChan
(
do_QueryInterface
(
chan
)
)
;
if
(
httpChan
)
{
httpChan
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
chan
-
>
LoadInfo
(
)
;
loadInfo
-
>
GetResultPrincipalURI
(
getter_AddRefs
(
resultPrincipalURI
)
)
;
}
if
(
!
triggeringPrincipal
)
{
MOZ_ASSERT
(
false
"
Reload
needs
a
valid
triggeringPrincipal
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIURI
>
currentURI
=
aCurrentURI
;
Maybe
<
nsCOMPtr
<
nsIURI
>
>
emplacedResultPrincipalURI
;
emplacedResultPrincipalURI
.
emplace
(
std
:
:
move
(
resultPrincipalURI
)
)
;
RefPtr
<
WindowContext
>
context
=
aBrowsingContext
-
>
GetCurrentWindowContext
(
)
;
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
currentURI
)
;
loadState
-
>
SetReferrerInfo
(
aReferrerInfo
)
;
loadState
-
>
SetOriginalURI
(
originalURI
)
;
loadState
-
>
SetMaybeResultPrincipalURI
(
emplacedResultPrincipalURI
)
;
loadState
-
>
SetLoadReplace
(
loadReplace
)
;
loadState
-
>
SetTriggeringPrincipal
(
triggeringPrincipal
)
;
loadState
-
>
SetTriggeringSandboxFlags
(
triggeringSandboxFlags
)
;
loadState
-
>
SetPrincipalToInherit
(
triggeringPrincipal
)
;
loadState
-
>
SetCsp
(
csp
)
;
loadState
-
>
SetInternalLoadFlags
(
flags
)
;
loadState
-
>
SetTypeHint
(
NS_ConvertUTF16toUTF8
(
contentTypeHint
)
)
;
loadState
-
>
SetLoadType
(
aLoadType
)
;
loadState
-
>
SetFirstParty
(
true
)
;
loadState
-
>
SetSrcdocData
(
srcdoc
)
;
loadState
-
>
SetSourceBrowsingContext
(
aBrowsingContext
)
;
loadState
-
>
SetBaseURI
(
baseURI
)
;
loadState
-
>
SetHasValidUserGestureActivation
(
context
&
&
context
-
>
HasValidTransientUserGestureActivation
(
)
)
;
loadState
-
>
SetNotifiedBeforeUnloadListeners
(
aNotifiedBeforeUnloadListeners
)
;
return
aDocShell
-
>
InternalLoad
(
loadState
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
Stop
(
uint32_t
aStopFlags
)
{
mRestorePresentationEvent
.
Revoke
(
)
;
if
(
mLoadType
=
=
LOAD_ERROR_PAGE
)
{
if
(
mLSHE
)
{
SetHistoryEntryAndUpdateBC
(
Some
(
nullptr
)
Some
<
nsISHEntry
*
>
(
mLSHE
)
)
;
}
mActiveEntryIsLoadingFromSessionHistory
=
false
;
mFailedChannel
=
nullptr
;
mFailedURI
=
nullptr
;
}
if
(
nsIWebNavigation
:
:
STOP_CONTENT
&
aStopFlags
)
{
if
(
mContentViewer
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
=
mContentViewer
;
cv
-
>
Stop
(
)
;
}
}
else
if
(
nsIWebNavigation
:
:
STOP_NETWORK
&
aStopFlags
)
{
if
(
mContentViewer
)
{
RefPtr
<
Document
>
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
doc
-
>
StopDocumentLoad
(
)
;
}
}
}
if
(
nsIWebNavigation
:
:
STOP_NETWORK
&
aStopFlags
)
{
if
(
mRefreshURIList
)
{
SuspendRefreshURIs
(
)
;
mSavedRefreshURIList
.
swap
(
mRefreshURIList
)
;
mRefreshURIList
=
nullptr
;
}
Stop
(
)
;
mChannelToDisconnectOnPageHide
=
0
;
}
for
(
auto
*
child
:
mChildList
.
ForwardRange
(
)
)
{
nsCOMPtr
<
nsIWebNavigation
>
shellAsNav
(
do_QueryObject
(
child
)
)
;
if
(
shellAsNav
)
{
shellAsNav
-
>
Stop
(
aStopFlags
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetDocument
(
Document
*
*
aDocument
)
{
NS_ENSURE_ARG_POINTER
(
aDocument
)
;
NS_ENSURE_SUCCESS
(
EnsureContentViewer
(
)
NS_ERROR_FAILURE
)
;
RefPtr
<
Document
>
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
doc
.
forget
(
aDocument
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCurrentURI
(
nsIURI
*
*
aURI
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsCOMPtr
<
nsIURI
>
uri
=
mCurrentURI
;
uri
.
forget
(
aURI
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetSessionHistoryXPCOM
(
nsISupports
*
*
aSessionHistory
)
{
NS_ENSURE_ARG_POINTER
(
aSessionHistory
)
;
RefPtr
<
ChildSHistory
>
shistory
=
GetSessionHistory
(
)
;
shistory
.
forget
(
aSessionHistory
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
LoadPageAsViewSource
(
nsIDocShell
*
aOtherDocShell
const
nsAString
&
aURI
)
{
if
(
!
aOtherDocShell
)
{
return
NS_ERROR_INVALID_POINTER
;
}
nsCOMPtr
<
nsIURI
>
newURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
newURI
)
aURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
RefPtr
<
nsDocShellLoadState
>
loadState
;
uint32_t
cacheKey
;
auto
*
otherDocShell
=
nsDocShell
:
:
Cast
(
aOtherDocShell
)
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
loadState
=
new
nsDocShellLoadState
(
newURI
)
;
if
(
!
otherDocShell
-
>
FillLoadStateFromCurrentEntry
(
*
loadState
)
)
{
return
NS_ERROR_INVALID_POINTER
;
}
cacheKey
=
otherDocShell
-
>
GetCacheKeyFromCurrentEntry
(
)
.
valueOr
(
0
)
;
}
else
{
nsCOMPtr
<
nsISHEntry
>
entry
;
bool
isOriginalSHE
;
otherDocShell
-
>
GetCurrentSHEntry
(
getter_AddRefs
(
entry
)
&
isOriginalSHE
)
;
if
(
!
entry
)
{
return
NS_ERROR_INVALID_POINTER
;
}
rv
=
entry
-
>
CreateLoadInfo
(
getter_AddRefs
(
loadState
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
entry
-
>
GetCacheKey
(
&
cacheKey
)
;
loadState
-
>
SetURI
(
newURI
)
;
loadState
-
>
SetSHEntry
(
nullptr
)
;
}
loadState
-
>
SetTriggeringPrincipal
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
loadState
-
>
SetOriginalURI
(
nullptr
)
;
loadState
-
>
SetResultPrincipalURI
(
nullptr
)
;
return
InternalLoad
(
loadState
Some
(
cacheKey
)
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCurrentDescriptor
(
nsISupports
*
*
aPageDescriptor
)
{
MOZ_ASSERT
(
aPageDescriptor
"
Null
out
param
?
"
)
;
*
aPageDescriptor
=
nullptr
;
nsISHEntry
*
src
=
mOSHE
?
mOSHE
:
mLSHE
;
if
(
src
)
{
nsCOMPtr
<
nsISHEntry
>
dest
;
nsresult
rv
=
src
-
>
Clone
(
getter_AddRefs
(
dest
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
dest
-
>
SetParent
(
nullptr
)
;
dest
-
>
SetIsSubFrame
(
false
)
;
return
CallQueryInterface
(
dest
aPageDescriptor
)
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
already_AddRefed
<
nsIInputStream
>
nsDocShell
:
:
GetPostDataFromCurrentEntry
(
)
const
{
nsCOMPtr
<
nsIInputStream
>
postData
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
if
(
mActiveEntry
)
{
postData
=
mActiveEntry
-
>
GetPostData
(
)
;
}
else
if
(
mLoadingEntry
)
{
postData
=
mLoadingEntry
-
>
mInfo
.
GetPostData
(
)
;
}
}
else
{
if
(
mOSHE
)
{
postData
=
mOSHE
-
>
GetPostData
(
)
;
}
else
if
(
mLSHE
)
{
postData
=
mLSHE
-
>
GetPostData
(
)
;
}
}
return
postData
.
forget
(
)
;
}
Maybe
<
uint32_t
>
nsDocShell
:
:
GetCacheKeyFromCurrentEntry
(
)
const
{
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
if
(
mActiveEntry
)
{
return
Some
(
mActiveEntry
-
>
GetCacheKey
(
)
)
;
}
if
(
mLoadingEntry
)
{
return
Some
(
mLoadingEntry
-
>
mInfo
.
GetCacheKey
(
)
)
;
}
}
else
{
if
(
mOSHE
)
{
return
Some
(
mOSHE
-
>
GetCacheKey
(
)
)
;
}
if
(
mLSHE
)
{
return
Some
(
mLSHE
-
>
GetCacheKey
(
)
)
;
}
}
return
Nothing
(
)
;
}
bool
nsDocShell
:
:
FillLoadStateFromCurrentEntry
(
nsDocShellLoadState
&
aLoadState
)
{
if
(
mLoadingEntry
)
{
mLoadingEntry
-
>
mInfo
.
FillLoadInfo
(
aLoadState
)
;
return
true
;
}
if
(
mActiveEntry
)
{
mActiveEntry
-
>
FillLoadInfo
(
aLoadState
)
;
return
true
;
}
return
false
;
}
NS_IMETHODIMP
nsDocShell
:
:
InitWindow
(
nativeWindow
aParentNativeWindow
nsIWidget
*
aParentWidget
int32_t
aX
int32_t
aY
int32_t
aWidth
int32_t
aHeight
)
{
SetParentWidget
(
aParentWidget
)
;
SetPositionAndSize
(
aX
aY
aWidth
aHeight
0
)
;
NS_ENSURE_TRUE
(
Initialize
(
)
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
Destroy
(
)
{
if
(
mIsBeingDestroyed
)
{
return
NS_ERROR_DOCSHELL_DYING
;
}
NS_ASSERTION
(
mItemType
=
=
typeContent
|
|
mItemType
=
=
typeChrome
"
Unexpected
item
type
in
docshell
"
)
;
nsCOMPtr
<
nsIObserverService
>
serv
=
services
:
:
GetObserverService
(
)
;
if
(
serv
)
{
const
char
*
msg
=
mItemType
=
=
typeContent
?
NS_WEBNAVIGATION_DESTROY
:
NS_CHROME_WEBNAVIGATION_DESTROY
;
serv
-
>
NotifyObservers
(
GetAsSupports
(
this
)
msg
nullptr
)
;
}
mIsBeingDestroyed
=
true
;
mInitialClientSource
.
reset
(
)
;
SetRecordProfileTimelineMarkers
(
false
)
;
mLoadingURI
=
nullptr
;
(
void
)
FirePageHideNotification
(
true
)
;
if
(
mOSHE
)
{
mOSHE
-
>
SetEditorData
(
nullptr
)
;
}
if
(
mLSHE
)
{
mLSHE
-
>
SetEditorData
(
nullptr
)
;
}
if
(
mContentListener
)
{
mContentListener
-
>
DropDocShellReference
(
)
;
mContentListener
-
>
SetParentContentListener
(
nullptr
)
;
}
Stop
(
nsIWebNavigation
:
:
STOP_ALL
)
;
mEditorData
=
nullptr
;
PersistLayoutHistoryState
(
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellParentAsItem
=
do_QueryInterface
(
GetAsSupports
(
mParent
)
)
;
if
(
docShellParentAsItem
)
{
docShellParentAsItem
-
>
RemoveChild
(
this
)
;
}
if
(
mContentViewer
)
{
mContentViewer
-
>
Close
(
nullptr
)
;
mContentViewer
-
>
Destroy
(
)
;
mContentViewer
=
nullptr
;
}
nsDocLoader
:
:
Destroy
(
)
;
mParentWidget
=
nullptr
;
mCurrentURI
=
nullptr
;
if
(
mScriptGlobal
)
{
mScriptGlobal
-
>
DetachFromDocShell
(
!
mWillChangeProcess
)
;
mScriptGlobal
=
nullptr
;
}
if
(
GetSessionHistory
(
)
)
{
GetSessionHistory
(
)
-
>
EvictLocalContentViewers
(
)
;
}
if
(
mWillChangeProcess
&
&
!
mBrowsingContext
-
>
IsDiscarded
(
)
)
{
mBrowsingContext
-
>
PrepareForProcessChange
(
)
;
}
SetTreeOwner
(
nullptr
)
;
mBrowserChild
=
nullptr
;
mChromeEventHandler
=
nullptr
;
CancelRefreshURITimers
(
)
;
return
NS_OK
;
}
double
nsDocShell
:
:
GetWidgetCSSToDeviceScale
(
)
{
if
(
mParentWidget
)
{
return
mParentWidget
-
>
GetDefaultScale
(
)
.
scale
;
}
if
(
nsCOMPtr
<
nsIBaseWindow
>
ownerWindow
=
do_QueryInterface
(
mTreeOwner
)
)
{
return
ownerWindow
-
>
GetWidgetCSSToDeviceScale
(
)
;
}
return
1
.
0
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetDevicePixelsPerDesktopPixel
(
double
*
aScale
)
{
if
(
mParentWidget
)
{
*
aScale
=
mParentWidget
-
>
GetDesktopToDeviceScale
(
)
.
scale
;
return
NS_OK
;
}
nsCOMPtr
<
nsIBaseWindow
>
ownerWindow
(
do_QueryInterface
(
mTreeOwner
)
)
;
if
(
ownerWindow
)
{
return
ownerWindow
-
>
GetDevicePixelsPerDesktopPixel
(
aScale
)
;
}
*
aScale
=
1
.
0
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetPosition
(
int32_t
aX
int32_t
aY
)
{
mBounds
.
MoveTo
(
aX
aY
)
;
if
(
mContentViewer
)
{
NS_ENSURE_SUCCESS
(
mContentViewer
-
>
Move
(
aX
aY
)
NS_ERROR_FAILURE
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetPositionDesktopPix
(
int32_t
aX
int32_t
aY
)
{
nsCOMPtr
<
nsIBaseWindow
>
ownerWindow
(
do_QueryInterface
(
mTreeOwner
)
)
;
if
(
ownerWindow
)
{
return
ownerWindow
-
>
SetPositionDesktopPix
(
aX
aY
)
;
}
double
scale
=
1
.
0
;
GetDevicePixelsPerDesktopPixel
(
&
scale
)
;
return
SetPosition
(
NSToIntRound
(
aX
*
scale
)
NSToIntRound
(
aY
*
scale
)
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetPosition
(
int32_t
*
aX
int32_t
*
aY
)
{
return
GetPositionAndSize
(
aX
aY
nullptr
nullptr
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetSize
(
int32_t
aWidth
int32_t
aHeight
bool
aRepaint
)
{
int32_t
x
=
0
y
=
0
;
GetPosition
(
&
x
&
y
)
;
return
SetPositionAndSize
(
x
y
aWidth
aHeight
aRepaint
?
nsIBaseWindow
:
:
eRepaint
:
0
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetSize
(
int32_t
*
aWidth
int32_t
*
aHeight
)
{
return
GetPositionAndSize
(
nullptr
nullptr
aWidth
aHeight
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetPositionAndSize
(
int32_t
aX
int32_t
aY
int32_t
aWidth
int32_t
aHeight
uint32_t
aFlags
)
{
mBounds
.
SetRect
(
aX
aY
aWidth
aHeight
)
;
nsCOMPtr
<
nsIContentViewer
>
viewer
=
mContentViewer
;
if
(
viewer
)
{
uint32_t
cvflags
=
(
aFlags
&
nsIBaseWindow
:
:
eDelayResize
)
?
nsIContentViewer
:
:
eDelayResize
:
0
;
nsresult
rv
=
viewer
-
>
SetBoundsWithFlags
(
mBounds
cvflags
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetPositionAndSize
(
int32_t
*
aX
int32_t
*
aY
int32_t
*
aWidth
int32_t
*
aHeight
)
{
if
(
mParentWidget
)
{
LayoutDeviceIntRect
r
=
mParentWidget
-
>
GetClientBounds
(
)
;
SetPositionAndSize
(
mBounds
.
X
(
)
mBounds
.
Y
(
)
r
.
Width
(
)
r
.
Height
(
)
0
)
;
}
if
(
aWidth
|
|
aHeight
)
{
RefPtr
<
Document
>
doc
(
do_GetInterface
(
GetAsSupports
(
mParent
)
)
)
;
if
(
doc
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
}
DoGetPositionAndSize
(
aX
aY
aWidth
aHeight
)
;
return
NS_OK
;
}
void
nsDocShell
:
:
DoGetPositionAndSize
(
int32_t
*
aX
int32_t
*
aY
int32_t
*
aWidth
int32_t
*
aHeight
)
{
if
(
aX
)
{
*
aX
=
mBounds
.
X
(
)
;
}
if
(
aY
)
{
*
aY
=
mBounds
.
Y
(
)
;
}
if
(
aWidth
)
{
*
aWidth
=
mBounds
.
Width
(
)
;
}
if
(
aHeight
)
{
*
aHeight
=
mBounds
.
Height
(
)
;
}
}
NS_IMETHODIMP
nsDocShell
:
:
SetDimensions
(
DimensionRequest
&
&
aRequest
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetDimensions
(
DimensionKind
aDimensionKind
int32_t
*
aX
int32_t
*
aY
int32_t
*
aCX
int32_t
*
aCY
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsDocShell
:
:
Repaint
(
bool
aForce
)
{
PresShell
*
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
RefPtr
<
nsViewManager
>
viewManager
=
presShell
-
>
GetViewManager
(
)
;
NS_ENSURE_TRUE
(
viewManager
NS_ERROR_FAILURE
)
;
viewManager
-
>
InvalidateAllViews
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetParentWidget
(
nsIWidget
*
*
aParentWidget
)
{
NS_ENSURE_ARG_POINTER
(
aParentWidget
)
;
*
aParentWidget
=
mParentWidget
;
NS_IF_ADDREF
(
*
aParentWidget
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetParentWidget
(
nsIWidget
*
aParentWidget
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
mParentWidget
=
aParentWidget
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetParentNativeWindow
(
nativeWindow
*
aParentNativeWindow
)
{
NS_ENSURE_ARG_POINTER
(
aParentNativeWindow
)
;
if
(
mParentWidget
)
{
*
aParentNativeWindow
=
mParentWidget
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
;
}
else
{
*
aParentNativeWindow
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetParentNativeWindow
(
nativeWindow
aParentNativeWindow
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetNativeHandle
(
nsAString
&
aNativeHandle
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetVisibility
(
bool
*
aVisibility
)
{
NS_ENSURE_ARG_POINTER
(
aVisibility
)
;
*
aVisibility
=
false
;
if
(
!
mContentViewer
)
{
return
NS_OK
;
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
NS_OK
;
}
nsViewManager
*
vm
=
presShell
-
>
GetViewManager
(
)
;
NS_ENSURE_TRUE
(
vm
NS_ERROR_FAILURE
)
;
nsView
*
view
=
vm
-
>
GetRootView
(
)
;
NS_ENSURE_TRUE
(
view
NS_ERROR_FAILURE
)
;
if
(
view
-
>
GetVisibility
(
)
=
=
ViewVisibility
:
:
Hide
)
{
return
NS_OK
;
}
RefPtr
<
nsDocShell
>
docShell
=
this
;
RefPtr
<
nsDocShell
>
parentItem
=
docShell
-
>
GetInProcessParentDocshell
(
)
;
while
(
parentItem
)
{
if
(
!
parentItem
-
>
GetPresShell
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
parent
docshell
has
null
pres
shell
"
)
;
return
NS_OK
;
}
vm
=
docShell
-
>
GetPresShell
(
)
-
>
GetViewManager
(
)
;
if
(
vm
)
{
view
=
vm
-
>
GetRootView
(
)
;
}
if
(
view
)
{
view
=
view
-
>
GetParent
(
)
;
if
(
view
)
{
view
=
view
-
>
GetParent
(
)
;
}
}
nsIFrame
*
frame
=
view
?
view
-
>
GetFrame
(
)
:
nullptr
;
if
(
frame
&
&
!
frame
-
>
IsVisibleConsideringAncestors
(
nsIFrame
:
:
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
)
)
{
return
NS_OK
;
}
docShell
=
parentItem
;
parentItem
=
docShell
-
>
GetInProcessParentDocshell
(
)
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
(
do_QueryInterface
(
mTreeOwner
)
)
;
if
(
!
treeOwnerAsWin
)
{
*
aVisibility
=
true
;
return
NS_OK
;
}
nsresult
rv
=
treeOwnerAsWin
-
>
GetVisibility
(
aVisibility
)
;
if
(
rv
=
=
NS_ERROR_NOT_IMPLEMENTED
)
{
*
aVisibility
=
true
;
return
NS_OK
;
}
return
rv
;
}
void
nsDocShell
:
:
ActivenessMaybeChanged
(
)
{
const
bool
isActive
=
mBrowsingContext
-
>
IsActive
(
)
;
if
(
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
ActivenessMaybeChanged
(
)
;
}
if
(
mScriptGlobal
)
{
mScriptGlobal
-
>
SetIsBackground
(
!
isActive
)
;
if
(
RefPtr
<
Document
>
doc
=
mScriptGlobal
-
>
GetExtantDoc
(
)
)
{
if
(
isActive
&
&
mBrowsingContext
-
>
IsTop
(
)
)
{
auto
orientation
=
mBrowsingContext
-
>
GetOrientationLock
(
)
;
ScreenOrientation
:
:
UpdateActiveOrientationLock
(
orientation
)
;
}
doc
-
>
PostVisibilityUpdateEvent
(
)
;
}
}
RefPtr
<
nsDOMNavigationTiming
>
timing
=
mTiming
;
if
(
!
timing
&
&
mContentViewer
)
{
if
(
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
)
{
timing
=
doc
-
>
GetNavigationTiming
(
)
;
}
}
if
(
timing
)
{
timing
-
>
NotifyDocShellStateChanged
(
isActive
?
nsDOMNavigationTiming
:
:
DocShellState
:
:
eActive
:
nsDOMNavigationTiming
:
:
DocShellState
:
:
eInactive
)
;
}
if
(
mDisableMetaRefreshWhenInactive
)
{
if
(
isActive
)
{
ResumeRefreshURIs
(
)
;
}
else
{
SuspendRefreshURIs
(
)
;
}
}
if
(
InputTaskManager
:
:
CanSuspendInputEvent
(
)
)
{
mBrowsingContext
-
>
Group
(
)
-
>
UpdateInputTaskManagerIfNeeded
(
isActive
)
;
}
}
NS_IMETHODIMP
nsDocShell
:
:
SetDefaultLoadFlags
(
uint32_t
aDefaultLoadFlags
)
{
if
(
!
mWillChangeProcess
)
{
Unused
<
<
mBrowsingContext
-
>
SetDefaultLoadFlags
(
aDefaultLoadFlags
)
;
}
else
{
NS_WARNING
(
"
nsDocShell
:
:
SetDefaultLoadFlags
called
on
Zombie
DocShell
"
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetDefaultLoadFlags
(
uint32_t
*
aDefaultLoadFlags
)
{
*
aDefaultLoadFlags
=
mBrowsingContext
-
>
GetDefaultLoadFlags
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetFailedChannel
(
nsIChannel
*
*
aFailedChannel
)
{
NS_ENSURE_ARG_POINTER
(
aFailedChannel
)
;
Document
*
doc
=
GetDocument
(
)
;
if
(
!
doc
)
{
*
aFailedChannel
=
nullptr
;
return
NS_OK
;
}
NS_IF_ADDREF
(
*
aFailedChannel
=
doc
-
>
GetFailedChannel
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetVisibility
(
bool
aVisibility
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
=
mContentViewer
;
if
(
!
cv
)
{
return
NS_OK
;
}
if
(
aVisibility
)
{
cv
-
>
Show
(
)
;
}
else
{
cv
-
>
Hide
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetEnabled
(
bool
*
aEnabled
)
{
NS_ENSURE_ARG_POINTER
(
aEnabled
)
;
*
aEnabled
=
true
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetEnabled
(
bool
aEnabled
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetMainWidget
(
nsIWidget
*
*
aMainWidget
)
{
return
GetParentWidget
(
aMainWidget
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetTitle
(
nsAString
&
aTitle
)
{
aTitle
=
mTitle
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetTitle
(
const
nsAString
&
aTitle
)
{
if
(
mTitleValidForCurrentURI
&
&
mTitle
=
=
aTitle
)
{
return
NS_OK
;
}
mTitle
=
aTitle
;
mTitleValidForCurrentURI
=
true
;
if
(
mBrowsingContext
-
>
IsTop
(
)
)
{
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
(
do_QueryInterface
(
mTreeOwner
)
)
;
if
(
treeOwnerAsWin
)
{
treeOwnerAsWin
-
>
SetTitle
(
aTitle
)
;
}
}
if
(
mCurrentURI
&
&
mLoadType
!
=
LOAD_ERROR_PAGE
)
{
UpdateGlobalHistoryTitle
(
mCurrentURI
)
;
}
if
(
mLoadType
!
=
LOAD_BYPASS_HISTORY
&
&
mLoadType
!
=
LOAD_ERROR_PAGE
)
{
SetTitleOnHistoryEntry
(
true
)
;
}
return
NS_OK
;
}
void
nsDocShell
:
:
SetTitleOnHistoryEntry
(
bool
aUpdateEntryInSessionHistory
)
{
if
(
mOSHE
)
{
mOSHE
-
>
SetTitle
(
mTitle
)
;
}
if
(
mActiveEntry
&
&
mBrowsingContext
)
{
mActiveEntry
-
>
SetTitle
(
mTitle
)
;
if
(
aUpdateEntryInSessionHistory
)
{
if
(
XRE_IsParentProcess
(
)
)
{
SessionHistoryEntry
*
entry
=
mBrowsingContext
-
>
Canonical
(
)
-
>
GetActiveSessionHistoryEntry
(
)
;
if
(
entry
)
{
entry
-
>
SetTitle
(
mTitle
)
;
}
}
else
{
mozilla
:
:
Unused
<
<
ContentChild
:
:
GetSingleton
(
)
-
>
SendSessionHistoryEntryTitle
(
mBrowsingContext
mTitle
)
;
}
}
}
}
nsPoint
nsDocShell
:
:
GetCurScrollPos
(
)
{
nsPoint
scrollPos
;
if
(
nsIScrollableFrame
*
sf
=
GetRootScrollFrame
(
)
)
{
scrollPos
=
sf
-
>
GetVisualViewportOffset
(
)
;
}
return
scrollPos
;
}
nsresult
nsDocShell
:
:
SetCurScrollPosEx
(
int32_t
aCurHorizontalPos
int32_t
aCurVerticalPos
)
{
nsIScrollableFrame
*
sf
=
GetRootScrollFrame
(
)
;
NS_ENSURE_TRUE
(
sf
NS_ERROR_FAILURE
)
;
ScrollMode
scrollMode
=
sf
-
>
IsSmoothScroll
(
)
?
ScrollMode
:
:
SmoothMsd
:
ScrollMode
:
:
Instant
;
nsPoint
targetPos
(
aCurHorizontalPos
aCurVerticalPos
)
;
sf
-
>
ScrollTo
(
targetPos
scrollMode
)
;
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
NS_ENSURE_TRUE
(
presContext
NS_ERROR_FAILURE
)
;
if
(
!
presContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
return
NS_OK
;
}
if
(
!
presShell
-
>
IsVisualViewportSizeSet
(
)
)
{
return
NS_OK
;
}
presShell
-
>
ScrollToVisual
(
targetPos
layers
:
:
FrameMetrics
:
:
eMainThread
scrollMode
)
;
return
NS_OK
;
}
void
nsDocShell
:
:
SetScrollbarPreference
(
mozilla
:
:
ScrollbarPreference
aPref
)
{
if
(
mScrollbarPref
=
=
aPref
)
{
return
;
}
mScrollbarPref
=
aPref
;
auto
*
ps
=
GetPresShell
(
)
;
if
(
!
ps
)
{
return
;
}
nsIFrame
*
scrollFrame
=
ps
-
>
GetRootScrollFrame
(
)
;
if
(
!
scrollFrame
)
{
return
;
}
ps
-
>
FrameNeedsReflow
(
scrollFrame
IntrinsicDirty
:
:
FrameAncestorsAndDescendants
NS_FRAME_IS_DIRTY
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
RefreshURI
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
uint32_t
aDelay
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
NS_ENSURE_ARG
(
aURI
)
;
bool
allowRedirects
=
true
;
GetAllowMetaRedirects
(
&
allowRedirects
)
;
if
(
!
allowRedirects
)
{
return
NS_OK
;
}
bool
sameURI
;
nsresult
rv
=
aURI
-
>
Equals
(
mCurrentURI
&
sameURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
sameURI
=
false
;
}
if
(
!
RefreshAttempted
(
this
aURI
aDelay
sameURI
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsITimerCallback
>
refreshTimer
=
new
nsRefreshTimer
(
this
aURI
aPrincipal
aDelay
)
;
BusyFlags
busyFlags
=
GetBusyFlags
(
)
;
if
(
!
mRefreshURIList
)
{
mRefreshURIList
=
nsArray
:
:
Create
(
)
;
}
if
(
busyFlags
&
BUSY_FLAGS_BUSY
|
|
(
!
mBrowsingContext
-
>
IsActive
(
)
&
&
mDisableMetaRefreshWhenInactive
)
)
{
mRefreshURIList
-
>
AppendElement
(
refreshTimer
)
;
}
else
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetWindow
(
)
;
NS_ENSURE_TRUE
(
win
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsITimer
>
timer
;
MOZ_TRY_VAR
(
timer
NS_NewTimerWithCallback
(
refreshTimer
aDelay
nsITimer
:
:
TYPE_ONE_SHOT
)
)
;
mRefreshURIList
-
>
AppendElement
(
timer
)
;
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
ForceRefreshURIFromTimer
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
uint32_t
aDelay
nsITimer
*
aTimer
)
{
MOZ_ASSERT
(
aTimer
"
Must
have
a
timer
here
"
)
;
if
(
mRefreshURIList
)
{
uint32_t
n
=
0
;
mRefreshURIList
-
>
GetLength
(
&
n
)
;
for
(
uint32_t
i
=
0
;
i
<
n
;
+
+
i
)
{
nsCOMPtr
<
nsITimer
>
timer
=
do_QueryElementAt
(
mRefreshURIList
i
)
;
if
(
timer
=
=
aTimer
)
{
mRefreshURIList
-
>
RemoveElementAt
(
i
)
;
break
;
}
}
}
return
ForceRefreshURI
(
aURI
aPrincipal
aDelay
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
ForceRefreshURI
(
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
uint32_t
aDelay
)
{
NS_ENSURE_ARG
(
aURI
)
;
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
aURI
)
;
loadState
-
>
SetOriginalURI
(
mCurrentURI
)
;
loadState
-
>
SetResultPrincipalURI
(
aURI
)
;
loadState
-
>
SetResultPrincipalURIIsSome
(
true
)
;
loadState
-
>
SetKeepResultPrincipalURIIfSet
(
true
)
;
loadState
-
>
SetIsMetaRefresh
(
true
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
aPrincipal
;
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
if
(
!
principal
)
{
if
(
!
doc
)
{
return
NS_ERROR_FAILURE
;
}
principal
=
doc
-
>
NodePrincipal
(
)
;
}
loadState
-
>
SetTriggeringPrincipal
(
principal
)
;
if
(
doc
)
{
loadState
-
>
SetCsp
(
doc
-
>
GetCsp
(
)
)
;
loadState
-
>
SetHasValidUserGestureActivation
(
doc
-
>
HasValidTransientUserGestureActivation
(
)
)
;
loadState
-
>
SetTriggeringSandboxFlags
(
doc
-
>
GetSandboxFlags
(
)
)
;
}
loadState
-
>
SetPrincipalIsExplicit
(
true
)
;
bool
equalUri
=
false
;
nsresult
rv
=
aURI
-
>
Equals
(
mCurrentURI
&
equalUri
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
equalUri
&
&
aDelay
<
=
REFRESH_REDIRECT_TIMER
)
{
loadState
-
>
SetLoadType
(
LOAD_REFRESH_REPLACE
)
;
if
(
mReferrerInfo
)
{
referrerInfo
=
static_cast
<
ReferrerInfo
*
>
(
mReferrerInfo
.
get
(
)
)
-
>
CloneWithNewSendReferrer
(
false
)
;
}
}
else
{
loadState
-
>
SetLoadType
(
LOAD_REFRESH
)
;
referrerInfo
=
new
ReferrerInfo
(
mCurrentURI
ReferrerPolicy
:
:
_empty
false
)
;
}
loadState
-
>
SetReferrerInfo
(
referrerInfo
)
;
loadState
-
>
SetLoadFlags
(
nsIWebNavigation
:
:
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
)
;
loadState
-
>
SetFirstParty
(
true
)
;
LoadURI
(
loadState
false
)
;
return
NS_OK
;
}
static
const
char16_t
*
SkipASCIIWhitespace
(
const
char16_t
*
aStart
const
char16_t
*
aEnd
)
{
const
char16_t
*
iter
=
aStart
;
while
(
iter
!
=
aEnd
&
&
mozilla
:
:
IsAsciiWhitespace
(
*
iter
)
)
{
+
+
iter
;
}
return
iter
;
}
static
Tuple
<
const
char16_t
*
const
char16_t
*
>
ExtractURLString
(
const
char16_t
*
aPosition
const
char16_t
*
aEnd
)
{
MOZ_ASSERT
(
aPosition
!
=
aEnd
)
;
const
char16_t
*
urlStart
=
aPosition
;
const
char16_t
*
urlEnd
=
aEnd
;
if
(
*
aPosition
=
=
'
U
'
|
|
*
aPosition
=
=
'
u
'
)
{
+
+
aPosition
;
if
(
aPosition
=
=
aEnd
|
|
(
*
aPosition
!
=
'
R
'
&
&
*
aPosition
!
=
'
r
'
)
)
{
return
MakeTuple
(
urlStart
urlEnd
)
;
}
+
+
aPosition
;
if
(
aPosition
=
=
aEnd
|
|
(
*
aPosition
!
=
'
L
'
&
&
*
aPosition
!
=
'
l
'
)
)
{
return
MakeTuple
(
urlStart
urlEnd
)
;
}
+
+
aPosition
;
aPosition
=
SkipASCIIWhitespace
(
aPosition
aEnd
)
;
if
(
aPosition
=
=
aEnd
|
|
*
aPosition
!
=
'
=
'
)
{
return
MakeTuple
(
urlStart
urlEnd
)
;
}
+
+
aPosition
;
aPosition
=
SkipASCIIWhitespace
(
aPosition
aEnd
)
;
}
Maybe
<
char
>
quote
;
if
(
aPosition
!
=
aEnd
&
&
(
*
aPosition
=
=
'
\
'
'
|
|
*
aPosition
=
=
'
"
'
)
)
{
quote
.
emplace
(
*
aPosition
)
;
+
+
aPosition
;
}
urlStart
=
aPosition
;
urlEnd
=
aEnd
;
const
char16_t
*
quotePos
;
if
(
quote
.
isSome
(
)
&
&
(
quotePos
=
nsCharTraits
<
char16_t
>
:
:
find
(
urlStart
std
:
:
distance
(
urlStart
aEnd
)
quote
.
value
(
)
)
)
)
{
urlEnd
=
quotePos
;
}
return
MakeTuple
(
urlStart
urlEnd
)
;
}
void
nsDocShell
:
:
SetupRefreshURIFromHeader
(
Document
*
aDocument
const
nsAString
&
aHeader
)
{
if
(
mIsBeingDestroyed
)
{
return
;
}
const
char16_t
*
position
=
aHeader
.
BeginReading
(
)
;
const
char16_t
*
end
=
aHeader
.
EndReading
(
)
;
position
=
SkipASCIIWhitespace
(
position
end
)
;
CheckedInt
<
uint32_t
>
milliSeconds
;
const
char16_t
*
digitsStart
=
position
;
while
(
position
!
=
end
&
&
mozilla
:
:
IsAsciiDigit
(
*
position
)
)
{
+
+
position
;
}
if
(
position
=
=
digitsStart
)
{
if
(
position
=
=
end
|
|
*
position
!
=
'
.
'
)
{
return
;
}
}
else
{
nsContentUtils
:
:
ParseHTMLIntegerResultFlags
result
;
uint32_t
seconds
=
nsContentUtils
:
:
ParseHTMLInteger
(
digitsStart
position
&
result
)
;
MOZ_ASSERT
(
!
(
result
&
nsContentUtils
:
:
eParseHTMLInteger_Negative
)
)
;
if
(
result
&
nsContentUtils
:
:
eParseHTMLInteger_Error
)
{
MOZ_ASSERT
(
!
(
result
&
nsContentUtils
:
:
eParseHTMLInteger_ErrorOverflow
)
)
;
return
;
}
MOZ_ASSERT
(
!
(
result
&
nsContentUtils
:
:
eParseHTMLInteger_DidNotConsumeAllInput
)
)
;
milliSeconds
=
seconds
;
milliSeconds
*
=
1000
;
if
(
!
milliSeconds
.
isValid
(
)
)
{
return
;
}
}
while
(
position
!
=
end
&
&
(
mozilla
:
:
IsAsciiDigit
(
*
position
)
|
|
*
position
=
=
'
.
'
)
)
{
+
+
position
;
}
nsCOMPtr
<
nsIURI
>
urlRecord
(
aDocument
-
>
GetDocumentURI
(
)
)
;
if
(
position
!
=
end
)
{
if
(
*
position
!
=
'
;
'
&
&
*
position
!
=
'
'
&
&
!
mozilla
:
:
IsAsciiWhitespace
(
*
position
)
)
{
return
;
}
position
=
SkipASCIIWhitespace
(
position
end
)
;
if
(
position
!
=
end
&
&
(
*
position
=
=
'
;
'
|
|
*
position
=
=
'
'
)
)
{
+
+
position
;
position
=
SkipASCIIWhitespace
(
position
end
)
;
}
if
(
position
!
=
end
)
{
const
char16_t
*
urlStart
;
const
char16_t
*
urlEnd
;
Tie
(
urlStart
urlEnd
)
=
ExtractURLString
(
position
end
)
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
urlRecord
)
Substring
(
urlStart
std
:
:
distance
(
urlStart
urlEnd
)
)
nullptr
aDocument
-
>
GetDocBaseURI
(
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
}
nsIPrincipal
*
principal
=
aDocument
-
>
NodePrincipal
(
)
;
nsCOMPtr
<
nsIScriptSecurityManager
>
securityManager
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
nsresult
rv
=
securityManager
-
>
CheckLoadURIWithPrincipal
(
principal
urlRecord
nsIScriptSecurityManager
:
:
LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT
aDocument
-
>
InnerWindowID
(
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
bool
isjs
=
true
;
rv
=
NS_URIChainHasFlags
(
urlRecord
nsIProtocolHandler
:
:
URI_OPENING_EXECUTES_SCRIPT
&
isjs
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
isjs
)
{
return
;
}
RefreshURI
(
urlRecord
principal
milliSeconds
.
value
(
)
)
;
}
static
void
DoCancelRefreshURITimers
(
nsIMutableArray
*
aTimerList
)
{
if
(
!
aTimerList
)
{
return
;
}
uint32_t
n
=
0
;
aTimerList
-
>
GetLength
(
&
n
)
;
while
(
n
)
{
nsCOMPtr
<
nsITimer
>
timer
(
do_QueryElementAt
(
aTimerList
-
-
n
)
)
;
aTimerList
-
>
RemoveElementAt
(
n
)
;
if
(
timer
)
{
timer
-
>
Cancel
(
)
;
}
}
}
NS_IMETHODIMP
nsDocShell
:
:
CancelRefreshURITimers
(
)
{
DoCancelRefreshURITimers
(
mRefreshURIList
)
;
DoCancelRefreshURITimers
(
mSavedRefreshURIList
)
;
DoCancelRefreshURITimers
(
mBFCachedRefreshURIList
)
;
mRefreshURIList
=
nullptr
;
mSavedRefreshURIList
=
nullptr
;
mBFCachedRefreshURIList
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetRefreshPending
(
bool
*
aResult
)
{
if
(
!
mRefreshURIList
)
{
*
aResult
=
false
;
return
NS_OK
;
}
uint32_t
count
;
nsresult
rv
=
mRefreshURIList
-
>
GetLength
(
&
count
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aResult
=
(
count
!
=
0
)
;
}
return
rv
;
}
void
nsDocShell
:
:
RefreshURIToQueue
(
)
{
if
(
mRefreshURIList
)
{
uint32_t
n
=
0
;
mRefreshURIList
-
>
GetLength
(
&
n
)
;
for
(
uint32_t
i
=
0
;
i
<
n
;
+
+
i
)
{
nsCOMPtr
<
nsITimer
>
timer
=
do_QueryElementAt
(
mRefreshURIList
i
)
;
if
(
!
timer
)
{
continue
;
}
nsCOMPtr
<
nsITimerCallback
>
callback
;
timer
-
>
GetCallback
(
getter_AddRefs
(
callback
)
)
;
timer
-
>
Cancel
(
)
;
mRefreshURIList
-
>
ReplaceElementAt
(
callback
i
)
;
}
}
}
NS_IMETHODIMP
nsDocShell
:
:
SuspendRefreshURIs
(
)
{
RefreshURIToQueue
(
)
;
for
(
auto
*
child
:
mChildList
.
ForwardRange
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryObject
(
child
)
;
if
(
shell
)
{
shell
-
>
SuspendRefreshURIs
(
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
ResumeRefreshURIs
(
)
{
RefreshURIFromQueue
(
)
;
for
(
auto
*
child
:
mChildList
.
ForwardRange
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryObject
(
child
)
;
if
(
shell
)
{
shell
-
>
ResumeRefreshURIs
(
)
;
}
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
RefreshURIFromQueue
(
)
{
if
(
!
mRefreshURIList
)
{
return
NS_OK
;
}
uint32_t
n
=
0
;
mRefreshURIList
-
>
GetLength
(
&
n
)
;
while
(
n
)
{
nsCOMPtr
<
nsITimerCallback
>
refreshInfo
=
do_QueryElementAt
(
mRefreshURIList
-
-
n
)
;
if
(
refreshInfo
)
{
uint32_t
delay
=
static_cast
<
nsRefreshTimer
*
>
(
static_cast
<
nsITimerCallback
*
>
(
refreshInfo
)
)
-
>
GetDelay
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetWindow
(
)
;
if
(
win
)
{
nsCOMPtr
<
nsITimer
>
timer
;
NS_NewTimerWithCallback
(
getter_AddRefs
(
timer
)
refreshInfo
delay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
if
(
timer
)
{
mRefreshURIList
-
>
ReplaceElementAt
(
timer
n
)
;
}
}
}
}
return
NS_OK
;
}
static
bool
IsFollowupPartOfMultipart
(
nsIRequest
*
aRequest
)
{
nsCOMPtr
<
nsIMultiPartChannel
>
multiPartChannel
=
do_QueryInterface
(
aRequest
)
;
bool
firstPart
=
false
;
return
multiPartChannel
&
&
NS_SUCCEEDED
(
multiPartChannel
-
>
GetIsFirstPart
(
&
firstPart
)
)
&
&
!
firstPart
;
}
nsresult
nsDocShell
:
:
Embed
(
nsIContentViewer
*
aContentViewer
WindowGlobalChild
*
aWindowActor
bool
aIsTransientAboutBlank
bool
aPersist
nsIRequest
*
aRequest
nsIURI
*
aPreviousURI
)
{
PersistLayoutHistoryState
(
)
;
nsresult
rv
=
SetupNewViewer
(
aContentViewer
aWindowActor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
?
!
!
mLoadingEntry
:
!
!
mLSHE
)
{
SetDocCurrentStateObj
(
mLSHE
mLoadingEntry
?
&
mLoadingEntry
-
>
mInfo
:
nullptr
)
;
}
if
(
mLSHE
)
{
if
(
mLSHE
-
>
HasDetachedEditor
(
)
)
{
ReattachEditorToWindow
(
mLSHE
)
;
}
SetHistoryEntryAndUpdateBC
(
Nothing
(
)
Some
<
nsISHEntry
*
>
(
mLSHE
)
)
;
}
if
(
!
aIsTransientAboutBlank
&
&
mozilla
:
:
SessionHistoryInParent
(
)
&
&
!
IsFollowupPartOfMultipart
(
aRequest
)
)
{
bool
expired
=
false
;
uint32_t
cacheKey
=
0
;
nsCOMPtr
<
nsICacheInfoChannel
>
cacheChannel
=
do_QueryInterface
(
aRequest
)
;
if
(
cacheChannel
)
{
uint32_t
expTime
=
0
;
cacheChannel
-
>
GetCacheTokenExpirationTime
(
&
expTime
)
;
uint32_t
now
=
PRTimeToSeconds
(
PR_Now
(
)
)
;
if
(
expTime
<
=
now
)
{
expired
=
true
;
}
if
(
(
(
!
mLoadingEntry
|
|
!
mLoadingEntry
-
>
mLoadIsFromSessionHistory
)
&
&
mBrowsingContext
-
>
ShouldUpdateSessionHistory
(
mLoadType
)
)
|
|
IsForceReloadType
(
mLoadType
)
)
{
cacheChannel
-
>
GetCacheKey
(
&
cacheKey
)
;
}
}
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
document
%
p
Embed
"
this
)
)
;
MoveLoadingToActiveEntry
(
aPersist
expired
cacheKey
aPreviousURI
)
;
}
bool
updateHistory
=
true
;
switch
(
mLoadType
)
{
case
LOAD_NORMAL_REPLACE
:
case
LOAD_REFRESH_REPLACE
:
case
LOAD_STOP_CONTENT_AND_REPLACE
:
case
LOAD_RELOAD_BYPASS_CACHE
:
case
LOAD_RELOAD_BYPASS_PROXY
:
case
LOAD_RELOAD_BYPASS_PROXY_AND_CACHE
:
case
LOAD_REPLACE_BYPASS_CACHE
:
updateHistory
=
false
;
break
;
default
:
break
;
}
if
(
!
updateHistory
)
{
SetLayoutHistoryState
(
nullptr
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
OnProgressChange
(
nsIWebProgress
*
aProgress
nsIRequest
*
aRequest
int32_t
aCurSelfProgress
int32_t
aMaxSelfProgress
int32_t
aCurTotalProgress
int32_t
aMaxTotalProgress
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
OnStateChange
(
nsIWebProgress
*
aProgress
nsIRequest
*
aRequest
uint32_t
aStateFlags
nsresult
aStatus
)
{
if
(
(
~
aStateFlags
&
(
STATE_START
|
STATE_IS_NETWORK
)
)
=
=
0
)
{
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
aRequest
)
)
;
nsCOMPtr
<
nsIURI
>
uri
;
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
nsAutoCString
aURI
;
uri
-
>
GetAsciiSpec
(
aURI
)
;
if
(
this
=
=
aProgress
)
{
mozilla
:
:
Unused
<
<
MaybeInitTiming
(
)
;
mTiming
-
>
NotifyFetchStart
(
uri
ConvertLoadTypeToNavigationType
(
mLoadType
)
)
;
if
(
RefPtr
<
DocumentChannel
>
docChannel
=
do_QueryObject
(
aRequest
)
)
{
docChannel
-
>
SetNavigationTiming
(
mTiming
)
;
}
}
mBusyFlags
=
(
BusyFlags
)
(
BUSY_FLAGS_BUSY
|
BUSY_FLAGS_BEFORE_PAGE_LOAD
)
;
if
(
(
aStateFlags
&
STATE_RESTORING
)
=
=
0
)
{
if
(
StaticPrefs
:
:
ui_use_activity_cursor
(
)
)
{
nsCOMPtr
<
nsIWidget
>
mainWidget
;
GetMainWidget
(
getter_AddRefs
(
mainWidget
)
)
;
if
(
mainWidget
)
{
mainWidget
-
>
SetCursor
(
nsIWidget
:
:
Cursor
{
eCursor_spinning
}
)
;
}
}
if
(
StaticPrefs
:
:
browser_sessionstore_platform_collection_AtStartup
(
)
)
{
if
(
IsForceReloadType
(
mLoadType
)
)
{
if
(
WindowContext
*
windowContext
=
mBrowsingContext
-
>
GetCurrentWindowContext
(
)
)
{
SessionStoreChild
:
:
From
(
windowContext
-
>
GetWindowGlobalChild
(
)
)
-
>
ResetSessionStore
(
mBrowsingContext
mBrowsingContext
-
>
GetSessionStoreEpoch
(
)
)
;
}
}
}
}
}
else
if
(
(
~
aStateFlags
&
(
STATE_TRANSFERRING
|
STATE_IS_DOCUMENT
)
)
=
=
0
)
{
mBusyFlags
=
(
BusyFlags
)
(
BUSY_FLAGS_BUSY
|
BUSY_FLAGS_PAGE_LOADING
)
;
}
else
if
(
(
aStateFlags
&
STATE_STOP
)
&
&
(
aStateFlags
&
STATE_IS_NETWORK
)
)
{
mBusyFlags
=
BUSY_FLAGS_NONE
;
if
(
StaticPrefs
:
:
ui_use_activity_cursor
(
)
)
{
nsCOMPtr
<
nsIWidget
>
mainWidget
;
GetMainWidget
(
getter_AddRefs
(
mainWidget
)
)
;
if
(
mainWidget
)
{
mainWidget
-
>
SetCursor
(
nsIWidget
:
:
Cursor
{
eCursor_standard
}
)
;
}
}
}
if
(
(
~
aStateFlags
&
(
STATE_IS_DOCUMENT
|
STATE_STOP
)
)
=
=
0
)
{
nsCOMPtr
<
nsIWebProgress
>
webProgress
=
do_QueryInterface
(
GetAsSupports
(
this
)
)
;
if
(
aProgress
=
=
webProgress
.
get
(
)
)
{
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
aRequest
)
)
;
EndPageLoad
(
aProgress
channel
aStatus
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
OnLocationChange
(
nsIWebProgress
*
aProgress
nsIRequest
*
aRequest
nsIURI
*
aURI
uint32_t
aFlags
)
{
bool
isTopLevel
=
false
;
if
(
XRE_IsParentProcess
(
)
&
&
!
(
aFlags
&
nsIWebProgressListener
:
:
LOCATION_CHANGE_SAME_DOCUMENT
)
&
&
NS_SUCCEEDED
(
aProgress
-
>
GetIsTopLevel
(
&
isTopLevel
)
)
&
&
isTopLevel
)
{
GetBrowsingContext
(
)
-
>
Canonical
(
)
-
>
UpdateSecurityState
(
)
;
}
return
NS_OK
;
}
void
nsDocShell
:
:
OnRedirectStateChange
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aRedirectFlags
uint32_t
aStateFlags
)
{
NS_ASSERTION
(
aStateFlags
&
STATE_REDIRECTING
"
Calling
OnRedirectStateChange
when
there
is
no
redirect
"
)
;
if
(
!
(
aStateFlags
&
STATE_IS_DOCUMENT
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
oldURI
newURI
;
aOldChannel
-
>
GetURI
(
getter_AddRefs
(
oldURI
)
)
;
aNewChannel
-
>
GetURI
(
getter_AddRefs
(
newURI
)
)
;
if
(
!
oldURI
|
|
!
newURI
)
{
return
;
}
RefPtr
<
DocumentChannel
>
docChannel
=
do_QueryObject
(
aOldChannel
)
;
if
(
!
docChannel
)
{
nsCOMPtr
<
nsIURI
>
previousURI
;
uint32_t
previousFlags
=
0
;
ExtractLastVisit
(
aOldChannel
getter_AddRefs
(
previousURI
)
&
previousFlags
)
;
if
(
aRedirectFlags
&
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
|
|
net
:
:
ChannelIsPost
(
aOldChannel
)
)
{
SaveLastVisit
(
aNewChannel
previousURI
previousFlags
)
;
}
else
{
uint32_t
responseStatus
=
0
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aOldChannel
)
;
if
(
httpChannel
)
{
Unused
<
<
httpChannel
-
>
GetResponseStatus
(
&
responseStatus
)
;
}
AddURIVisit
(
oldURI
previousURI
previousFlags
responseStatus
)
;
SaveLastVisit
(
aNewChannel
oldURI
aRedirectFlags
)
;
}
}
if
(
!
(
aRedirectFlags
&
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
&
&
mLoadType
&
(
LOAD_CMD_RELOAD
|
LOAD_CMD_HISTORY
)
)
{
mLoadType
=
LOAD_NORMAL_REPLACE
;
SetHistoryEntryAndUpdateBC
(
Some
(
nullptr
)
Nothing
(
)
)
;
}
}
NS_IMETHODIMP
nsDocShell
:
:
OnStatusChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsresult
aStatus
const
char16_t
*
aMessage
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
OnSecurityChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aState
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
OnContentBlockingEvent
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aEvent
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
already_AddRefed
<
nsIURIFixupInfo
>
nsDocShell
:
:
KeywordToURI
(
const
nsACString
&
aKeyword
bool
aIsPrivateContext
)
{
nsCOMPtr
<
nsIURIFixupInfo
>
info
;
if
(
!
XRE_IsContentProcess
(
)
)
{
nsCOMPtr
<
nsIURIFixup
>
uriFixup
=
components
:
:
URIFixup
:
:
Service
(
)
;
if
(
uriFixup
)
{
uriFixup
-
>
KeywordToURI
(
aKeyword
aIsPrivateContext
getter_AddRefs
(
info
)
)
;
}
}
return
info
.
forget
(
)
;
}
already_AddRefed
<
nsIURI
>
nsDocShell
:
:
MaybeFixBadCertDomainErrorURI
(
nsIChannel
*
aChannel
nsIURI
*
aUrl
)
{
if
(
!
aChannel
)
{
return
nullptr
;
}
nsresult
rv
=
NS_OK
;
nsAutoCString
host
;
rv
=
aUrl
-
>
GetAsciiHost
(
host
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
if
(
StringBeginsWith
(
host
"
www
.
"
_ns
)
)
{
return
nullptr
;
}
if
(
!
mozilla
:
:
StaticPrefs
:
:
security_bad_cert_domain_error_url_fix_enabled
(
)
)
{
return
nullptr
;
}
if
(
!
SchemeIsHTTPS
(
aUrl
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsILoadInfo
>
info
=
aChannel
-
>
LoadInfo
(
)
;
if
(
!
info
)
{
return
nullptr
;
}
if
(
!
info
-
>
RedirectChain
(
)
.
IsEmpty
(
)
)
{
return
nullptr
;
}
int32_t
port
=
0
;
rv
=
aUrl
-
>
GetPort
(
&
port
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
if
(
port
!
=
-
1
)
{
return
nullptr
;
}
if
(
host
=
=
"
localhost
"
)
{
return
nullptr
;
}
if
(
net_IsValidIPv4Addr
(
host
)
|
|
net_IsValidIPv6Addr
(
host
)
)
{
return
nullptr
;
}
nsAutoCString
userPass
;
rv
=
aUrl
-
>
GetUserPass
(
userPass
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
if
(
!
userPass
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsITransportSecurityInfo
>
tsi
;
rv
=
aChannel
-
>
GetSecurityInfo
(
getter_AddRefs
(
tsi
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
tsi
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIX509Cert
>
cert
;
rv
=
tsi
-
>
GetServerCert
(
getter_AddRefs
(
cert
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
|
|
!
cert
)
)
{
return
nullptr
;
}
nsTArray
<
uint8_t
>
certBytes
;
rv
=
cert
-
>
GetRawDER
(
certBytes
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
mozilla
:
:
pkix
:
:
Input
serverCertInput
;
mozilla
:
:
pkix
:
:
Result
rv1
=
serverCertInput
.
Init
(
certBytes
.
Elements
(
)
certBytes
.
Length
(
)
)
;
if
(
rv1
!
=
mozilla
:
:
pkix
:
:
Success
)
{
return
nullptr
;
}
nsAutoCString
newHost
(
"
www
.
"
_ns
)
;
newHost
.
Append
(
host
)
;
mozilla
:
:
pkix
:
:
Input
newHostInput
;
rv1
=
newHostInput
.
Init
(
BitwiseCast
<
const
uint8_t
*
const
char
*
>
(
newHost
.
BeginReading
(
)
)
newHost
.
Length
(
)
)
;
if
(
rv1
!
=
mozilla
:
:
pkix
:
:
Success
)
{
return
nullptr
;
}
rv1
=
mozilla
:
:
pkix
:
:
CheckCertHostname
(
serverCertInput
newHostInput
)
;
if
(
rv1
!
=
mozilla
:
:
pkix
:
:
Success
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
newURI
;
Unused
<
<
NS_MutateURI
(
aUrl
)
.
SetHost
(
newHost
)
.
Finalize
(
getter_AddRefs
(
newURI
)
)
;
return
newURI
.
forget
(
)
;
}
already_AddRefed
<
nsIURI
>
nsDocShell
:
:
AttemptURIFixup
(
nsIChannel
*
aChannel
nsresult
aStatus
const
mozilla
:
:
Maybe
<
nsCString
>
&
aOriginalURIString
uint32_t
aLoadType
bool
aIsTopFrame
bool
aAllowKeywordFixup
bool
aUsePrivateBrowsing
bool
aNotifyKeywordSearchLoading
nsIInputStream
*
*
aNewPostData
)
{
if
(
aStatus
!
=
NS_ERROR_UNKNOWN_HOST
&
&
aStatus
!
=
NS_ERROR_NET_RESET
&
&
aStatus
!
=
NS_ERROR_CONNECTION_REFUSED
&
&
aStatus
!
=
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
SSL_ERROR_BAD_CERT_DOMAIN
)
)
{
return
nullptr
;
}
if
(
!
(
aLoadType
=
=
LOAD_NORMAL
&
&
aIsTopFrame
)
&
&
!
aAllowKeywordFixup
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
url
;
nsresult
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
url
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
newURI
;
nsCOMPtr
<
nsIInputStream
>
newPostData
;
nsAutoCString
oldSpec
;
url
-
>
GetSpec
(
oldSpec
)
;
nsAutoString
keywordProviderName
keywordAsSent
;
if
(
aStatus
=
=
NS_ERROR_UNKNOWN_HOST
&
&
aAllowKeywordFixup
)
{
nsAutoCString
scheme
;
Unused
<
<
url
-
>
GetScheme
(
scheme
)
;
if
(
Preferences
:
:
GetBool
(
"
keyword
.
enabled
"
false
)
&
&
StringBeginsWith
(
scheme
"
http
"
_ns
)
)
{
bool
attemptFixup
=
false
;
nsAutoCString
host
;
Unused
<
<
url
-
>
GetHost
(
host
)
;
if
(
host
.
FindChar
(
'
.
'
)
=
=
kNotFound
)
{
attemptFixup
=
true
;
}
else
{
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
if
(
tldService
)
{
nsAutoCString
suffix
;
attemptFixup
=
NS_SUCCEEDED
(
tldService
-
>
GetKnownPublicSuffix
(
url
suffix
)
)
&
&
suffix
.
IsEmpty
(
)
;
}
}
if
(
attemptFixup
)
{
nsCOMPtr
<
nsIURIFixupInfo
>
info
;
if
(
aOriginalURIString
&
&
!
aOriginalURIString
-
>
IsEmpty
(
)
)
{
info
=
KeywordToURI
(
*
aOriginalURIString
aUsePrivateBrowsing
)
;
}
else
{
bool
isACE
;
nsAutoCString
utf8Host
;
nsCOMPtr
<
nsIIDNService
>
idnSrv
=
do_GetService
(
NS_IDNSERVICE_CONTRACTID
)
;
if
(
idnSrv
&
&
NS_SUCCEEDED
(
idnSrv
-
>
IsACE
(
host
&
isACE
)
)
&
&
isACE
&
&
NS_SUCCEEDED
(
idnSrv
-
>
ConvertACEtoUTF8
(
host
utf8Host
)
)
)
{
info
=
KeywordToURI
(
utf8Host
aUsePrivateBrowsing
)
;
}
else
{
info
=
KeywordToURI
(
host
aUsePrivateBrowsing
)
;
}
}
if
(
info
)
{
info
-
>
GetPreferredURI
(
getter_AddRefs
(
newURI
)
)
;
if
(
newURI
)
{
info
-
>
GetKeywordAsSent
(
keywordAsSent
)
;
info
-
>
GetKeywordProviderName
(
keywordProviderName
)
;
info
-
>
GetPostData
(
getter_AddRefs
(
newPostData
)
)
;
}
}
}
}
}
if
(
aStatus
=
=
NS_ERROR_UNKNOWN_HOST
|
|
aStatus
=
=
NS_ERROR_NET_RESET
)
{
bool
doCreateAlternate
=
aLoadType
=
=
LOAD_NORMAL
&
&
aIsTopFrame
;
if
(
doCreateAlternate
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
nsIPrincipal
*
principal
=
loadInfo
-
>
TriggeringPrincipal
(
)
;
doCreateAlternate
=
principal
&
&
principal
-
>
IsSystemPrincipal
(
)
&
&
loadInfo
-
>
RedirectChain
(
)
.
IsEmpty
(
)
;
}
if
(
doCreateAlternate
&
&
newURI
)
{
bool
sameURI
=
false
;
url
-
>
Equals
(
newURI
&
sameURI
)
;
if
(
!
sameURI
)
{
doCreateAlternate
=
false
;
}
}
if
(
doCreateAlternate
)
{
newURI
=
nullptr
;
newPostData
=
nullptr
;
keywordProviderName
.
Truncate
(
)
;
keywordAsSent
.
Truncate
(
)
;
nsCOMPtr
<
nsIURIFixup
>
uriFixup
=
components
:
:
URIFixup
:
:
Service
(
)
;
if
(
uriFixup
)
{
nsCOMPtr
<
nsIURIFixupInfo
>
fixupInfo
;
uriFixup
-
>
GetFixupURIInfo
(
oldSpec
nsIURIFixup
:
:
FIXUP_FLAGS_MAKE_ALTERNATE_URI
getter_AddRefs
(
fixupInfo
)
)
;
if
(
fixupInfo
)
{
fixupInfo
-
>
GetPreferredURI
(
getter_AddRefs
(
newURI
)
)
;
}
}
}
}
else
if
(
aStatus
=
=
NS_ERROR_CONNECTION_REFUSED
&
&
Preferences
:
:
GetBool
(
"
browser
.
fixup
.
fallback
-
to
-
https
"
false
)
)
{
if
(
SchemeIsHTTP
(
url
)
)
{
int32_t
port
=
0
;
url
-
>
GetPort
(
&
port
)
;
if
(
port
=
=
-
1
)
{
newURI
=
nullptr
;
newPostData
=
nullptr
;
Unused
<
<
NS_MutateURI
(
url
)
.
SetScheme
(
"
https
"
_ns
)
.
Finalize
(
getter_AddRefs
(
newURI
)
)
;
}
}
}
if
(
aStatus
=
=
mozilla
:
:
psm
:
:
GetXPCOMFromNSSError
(
SSL_ERROR_BAD_CERT_DOMAIN
)
)
{
newPostData
=
nullptr
;
newURI
=
MaybeFixBadCertDomainErrorURI
(
aChannel
url
)
;
}
if
(
newURI
)
{
bool
sameURI
=
false
;
url
-
>
Equals
(
newURI
&
sameURI
)
;
if
(
!
sameURI
)
{
if
(
aNewPostData
)
{
newPostData
.
forget
(
aNewPostData
)
;
}
if
(
aNotifyKeywordSearchLoading
)
{
MaybeNotifyKeywordSearchLoading
(
keywordProviderName
keywordAsSent
)
;
}
return
newURI
.
forget
(
)
;
}
}
return
nullptr
;
}
nsresult
nsDocShell
:
:
FilterStatusForErrorPage
(
nsresult
aStatus
nsIChannel
*
aChannel
uint32_t
aLoadType
bool
aIsTopFrame
bool
aUseErrorPages
bool
aIsInitialDocument
bool
*
aSkippedUnknownProtocolNavigation
)
{
if
(
(
aStatus
=
=
NS_ERROR_UNKNOWN_HOST
|
|
aStatus
=
=
NS_ERROR_CONNECTION_REFUSED
|
|
aStatus
=
=
NS_ERROR_UNKNOWN_PROXY_HOST
|
|
aStatus
=
=
NS_ERROR_PROXY_CONNECTION_REFUSED
|
|
aStatus
=
=
NS_ERROR_PROXY_FORBIDDEN
|
|
aStatus
=
=
NS_ERROR_PROXY_NOT_IMPLEMENTED
|
|
aStatus
=
=
NS_ERROR_PROXY_AUTHENTICATION_FAILED
|
|
aStatus
=
=
NS_ERROR_PROXY_TOO_MANY_REQUESTS
|
|
aStatus
=
=
NS_ERROR_MALFORMED_URI
|
|
aStatus
=
=
NS_ERROR_BLOCKED_BY_POLICY
|
|
aStatus
=
=
NS_ERROR_DOM_COOP_FAILED
|
|
aStatus
=
=
NS_ERROR_DOM_COEP_FAILED
)
&
&
(
aIsTopFrame
|
|
aUseErrorPages
)
)
{
return
aStatus
;
}
if
(
aStatus
=
=
NS_ERROR_NET_TIMEOUT
|
|
aStatus
=
=
NS_ERROR_NET_TIMEOUT_EXTERNAL
|
|
aStatus
=
=
NS_ERROR_PROXY_GATEWAY_TIMEOUT
|
|
aStatus
=
=
NS_ERROR_REDIRECT_LOOP
|
|
aStatus
=
=
NS_ERROR_UNKNOWN_SOCKET_TYPE
|
|
aStatus
=
=
NS_ERROR_NET_INTERRUPT
|
|
aStatus
=
=
NS_ERROR_NET_RESET
|
|
aStatus
=
=
NS_ERROR_PROXY_BAD_GATEWAY
|
|
aStatus
=
=
NS_ERROR_OFFLINE
|
|
aStatus
=
=
NS_ERROR_MALWARE_URI
|
|
aStatus
=
=
NS_ERROR_PHISHING_URI
|
|
aStatus
=
=
NS_ERROR_UNWANTED_URI
|
|
aStatus
=
=
NS_ERROR_HARMFUL_URI
|
|
aStatus
=
=
NS_ERROR_UNSAFE_CONTENT_TYPE
|
|
aStatus
=
=
NS_ERROR_INTERCEPTION_FAILED
|
|
aStatus
=
=
NS_ERROR_NET_INADEQUATE_SECURITY
|
|
aStatus
=
=
NS_ERROR_NET_HTTP2_SENT_GOAWAY
|
|
aStatus
=
=
NS_ERROR_NET_HTTP3_PROTOCOL_ERROR
|
|
aStatus
=
=
NS_ERROR_DOM_BAD_URI
|
|
aStatus
=
=
NS_ERROR_FILE_NOT_FOUND
|
|
aStatus
=
=
NS_ERROR_FILE_ACCESS_DENIED
|
|
aStatus
=
=
NS_ERROR_CORRUPTED_CONTENT
|
|
aStatus
=
=
NS_ERROR_INVALID_CONTENT_ENCODING
|
|
NS_ERROR_GET_MODULE
(
aStatus
)
=
=
NS_ERROR_MODULE_SECURITY
)
{
return
aStatus
;
}
if
(
aStatus
=
=
NS_ERROR_UNKNOWN_PROTOCOL
)
{
nsCOMPtr
<
nsILoadInfo
>
info
=
aChannel
-
>
LoadInfo
(
)
;
if
(
!
info
-
>
TriggeringPrincipal
(
)
-
>
IsSystemPrincipal
(
)
&
&
StaticPrefs
:
:
dom_no_unknown_protocol_error_enabled
(
)
&
&
!
aIsInitialDocument
)
{
if
(
aSkippedUnknownProtocolNavigation
)
{
*
aSkippedUnknownProtocolNavigation
=
true
;
}
return
NS_OK
;
}
return
aStatus
;
}
if
(
aStatus
=
=
NS_ERROR_DOCUMENT_NOT_CACHED
)
{
if
(
!
(
aLoadType
&
LOAD_CMD_HISTORY
)
)
{
return
NS_ERROR_OFFLINE
;
}
return
aStatus
;
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
EndPageLoad
(
nsIWebProgress
*
aProgress
nsIChannel
*
aChannel
nsresult
aStatus
)
{
MOZ_LOG
(
gDocShellLeakLog
LogLevel
:
:
Debug
(
"
DOCSHELL
%
p
EndPageLoad
status
:
%
"
PRIx32
"
\
n
"
this
static_cast
<
uint32_t
>
(
aStatus
)
)
)
;
if
(
!
aChannel
)
{
return
NS_ERROR_NULL_POINTER
;
}
mInitialClientSource
.
reset
(
)
;
nsCOMPtr
<
nsIConsoleReportCollector
>
reporter
=
do_QueryInterface
(
aChannel
)
;
if
(
reporter
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
aChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
if
(
loadGroup
)
{
reporter
-
>
FlushConsoleReports
(
loadGroup
)
;
}
else
{
reporter
-
>
FlushConsoleReports
(
GetDocument
(
)
)
;
}
}
nsCOMPtr
<
nsIURI
>
url
;
nsresult
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
url
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsITimedChannel
>
timingChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
timingChannel
)
{
TimeStamp
channelCreationTime
;
rv
=
timingChannel
-
>
GetChannelCreation
(
&
channelCreationTime
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
channelCreationTime
.
IsNull
(
)
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
TOTAL_CONTENT_PAGE_LOAD_TIME
channelCreationTime
)
;
}
}
mTiming
=
nullptr
;
if
(
eCharsetReloadRequested
=
=
mCharsetReloadState
)
{
mCharsetReloadState
=
eCharsetReloadStopOrigional
;
}
else
{
mCharsetReloadState
=
eCharsetReloadInit
;
}
nsCOMPtr
<
nsISHEntry
>
loadingSHE
=
mLSHE
;
mozilla
:
:
Unused
<
<
loadingSHE
;
nsCOMPtr
<
nsIDocShell
>
kungFuDeathGrip
(
this
)
;
if
(
!
mEODForCurrentDocument
&
&
mContentViewer
)
{
mIsExecutingOnLoadHandler
=
true
;
nsCOMPtr
<
nsIContentViewer
>
contentViewer
=
mContentViewer
;
contentViewer
-
>
LoadComplete
(
aStatus
)
;
mIsExecutingOnLoadHandler
=
false
;
mEODForCurrentDocument
=
true
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aChannel
)
)
;
if
(
!
httpChannel
)
{
GetHttpChannel
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
}
if
(
httpChannel
)
{
bool
discardLayoutState
=
ShouldDiscardLayoutState
(
httpChannel
)
;
if
(
mLSHE
&
&
discardLayoutState
&
&
(
mLoadType
&
LOAD_CMD_NORMAL
)
&
&
(
mLoadType
!
=
LOAD_BYPASS_HISTORY
)
&
&
(
mLoadType
!
=
LOAD_ERROR_PAGE
)
)
{
mLSHE
-
>
SetSaveLayoutStateFlag
(
false
)
;
}
}
if
(
mLSHE
)
{
mLSHE
-
>
SetLoadType
(
LOAD_HISTORY
)
;
SetHistoryEntryAndUpdateBC
(
Some
(
nullptr
)
Nothing
(
)
)
;
}
mActiveEntryIsLoadingFromSessionHistory
=
false
;
if
(
mBrowsingContext
-
>
IsActive
(
)
|
|
!
mDisableMetaRefreshWhenInactive
)
RefreshURIFromQueue
(
)
;
bool
isTopFrame
=
mBrowsingContext
-
>
IsTop
(
)
;
bool
hadErrorStatus
=
false
;
if
(
NS_FAILED
(
aStatus
)
)
{
bool
fireFrameErrorEvent
=
(
aStatus
=
=
NS_ERROR_CONTENT_BLOCKED_SHOW_ALT
|
|
aStatus
=
=
NS_ERROR_CONTENT_BLOCKED
)
;
UnblockEmbedderLoadEventForFailure
(
fireFrameErrorEvent
)
;
bool
isInitialDocument
=
!
GetExtantDocument
(
)
|
|
GetExtantDocument
(
)
-
>
IsInitialDocument
(
)
;
bool
skippedUnknownProtocolNavigation
=
false
;
aStatus
=
FilterStatusForErrorPage
(
aStatus
aChannel
mLoadType
isTopFrame
mBrowsingContext
-
>
GetUseErrorPages
(
)
isInitialDocument
&
skippedUnknownProtocolNavigation
)
;
hadErrorStatus
=
true
;
if
(
NS_FAILED
(
aStatus
)
)
{
if
(
!
mIsBeingDestroyed
)
{
DisplayLoadError
(
aStatus
url
nullptr
aChannel
)
;
}
}
else
if
(
skippedUnknownProtocolNavigation
)
{
nsTArray
<
nsString
>
params
;
if
(
NS_FAILED
(
NS_GetSanitizedURIStringFromURI
(
url
*
params
.
AppendElement
(
)
)
)
)
{
params
.
LastElement
(
)
.
AssignLiteral
(
u
"
(
unknown
uri
)
"
)
;
}
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
DOM
"
_ns
GetExtantDocument
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
"
UnknownProtocolNavigationPrevented
"
params
)
;
}
}
else
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
PredictorLearnRedirect
(
url
aChannel
loadInfo
-
>
GetOriginAttributes
(
)
)
;
}
if
(
hadErrorStatus
)
{
return
NS_OK
;
}
if
(
StaticPrefs
:
:
browser_sessionstore_platform_collection_AtStartup
(
)
)
{
if
(
WindowContext
*
windowContext
=
mBrowsingContext
-
>
GetCurrentWindowContext
(
)
)
{
using
Change
=
SessionStoreChangeListener
:
:
Change
;
SessionStoreChangeListener
:
:
CollectSessionStoreData
(
windowContext
EnumSet
<
Change
>
(
Change
:
:
Input
Change
:
:
Scroll
Change
:
:
SessionHistory
Change
:
:
WireFrame
)
)
;
}
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
EnsureContentViewer
(
)
{
if
(
mContentViewer
)
{
return
NS_OK
;
}
if
(
mIsBeingDestroyed
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
cspToInheritForAboutBlank
;
nsCOMPtr
<
nsIURI
>
baseURI
;
nsIPrincipal
*
principal
=
GetInheritedPrincipal
(
false
)
;
nsIPrincipal
*
partitionedPrincipal
=
GetInheritedPrincipal
(
false
true
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parentItem
;
GetInProcessSameTypeParent
(
getter_AddRefs
(
parentItem
)
)
;
if
(
parentItem
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWin
=
GetWindow
(
)
)
{
nsCOMPtr
<
Element
>
parentElement
=
domWin
-
>
GetFrameElementInternal
(
)
;
if
(
parentElement
)
{
baseURI
=
parentElement
-
>
GetBaseURI
(
)
;
cspToInheritForAboutBlank
=
parentElement
-
>
GetCsp
(
)
;
}
}
}
nsresult
rv
=
CreateAboutBlankContentViewer
(
principal
partitionedPrincipal
cspToInheritForAboutBlank
baseURI
true
)
;
NS_ENSURE_STATE
(
mContentViewer
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
RefPtr
<
Document
>
doc
(
GetDocument
(
)
)
;
MOZ_ASSERT
(
doc
"
Should
have
doc
if
CreateAboutBlankContentViewer
"
"
succeeded
!
"
)
;
MOZ_ASSERT
(
doc
-
>
IsInitialDocument
(
)
"
Document
should
be
initial
document
"
)
;
doc
-
>
IgnoreDocGroupMismatches
(
)
;
}
return
rv
;
}
nsresult
nsDocShell
:
:
CreateAboutBlankContentViewer
(
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aPartitionedPrincipal
nsIContentSecurityPolicy
*
aCSP
nsIURI
*
aBaseURI
bool
aIsInitialDocument
const
Maybe
<
nsILoadInfo
:
:
CrossOriginEmbedderPolicy
>
&
aCOEP
bool
aTryToSaveOldPresentation
bool
aCheckPermitUnload
WindowGlobalChild
*
aActor
)
{
RefPtr
<
Document
>
blankDoc
;
nsCOMPtr
<
nsIContentViewer
>
viewer
;
nsresult
rv
=
NS_ERROR_FAILURE
;
MOZ_ASSERT_IF
(
aActor
aActor
-
>
DocumentPrincipal
(
)
=
=
aPrincipal
)
;
NS_ASSERTION
(
!
mCreatingDocument
"
infinite
(
?
)
loop
creating
document
averted
"
)
;
if
(
mCreatingDocument
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mBrowsingContext
-
>
AncestorsAreCurrent
(
)
|
|
mBrowsingContext
-
>
IsInBFCache
(
)
)
{
mBrowsingContext
-
>
RemoveRootFromBFCacheSync
(
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIDocShell
>
kungFuDeathGrip
(
this
)
;
AutoRestore
<
bool
>
creatingDocument
(
mCreatingDocument
)
;
mCreatingDocument
=
true
;
if
(
aPrincipal
&
&
!
aPrincipal
-
>
IsSystemPrincipal
(
)
&
&
mItemType
!
=
typeChrome
)
{
MOZ_ASSERT
(
aPrincipal
-
>
OriginAttributesRef
(
)
=
=
mBrowsingContext
-
>
OriginAttributesRef
(
)
)
;
}
bool
hadTiming
=
mTiming
;
bool
toBeReset
=
MaybeInitTiming
(
)
;
if
(
mContentViewer
)
{
if
(
aCheckPermitUnload
)
{
mTiming
-
>
NotifyBeforeUnload
(
)
;
bool
okToUnload
;
rv
=
mContentViewer
-
>
PermitUnload
(
&
okToUnload
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
okToUnload
)
{
MaybeResetInitTiming
(
toBeReset
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mTiming
)
{
mTiming
-
>
NotifyUnloadAccepted
(
mCurrentURI
)
;
}
}
mSavingOldViewer
=
aTryToSaveOldPresentation
&
&
CanSavePresentation
(
LOAD_NORMAL
nullptr
nullptr
true
)
;
mLoadingURI
=
nullptr
;
Stop
(
)
;
(
void
)
FirePageHideNotification
(
!
mSavingOldViewer
)
;
if
(
mIsBeingDestroyed
)
{
return
NS_ERROR_DOCSHELL_DYING
;
}
}
mFiredUnloadEvent
=
false
;
nsCOMPtr
<
nsIDocumentLoaderFactory
>
docFactory
=
nsContentUtils
:
:
FindInternalContentViewer
(
"
text
/
html
"
_ns
)
;
if
(
docFactory
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
partitionedPrincipal
;
const
uint32_t
sandboxFlags
=
mBrowsingContext
-
>
GetHasLoadedNonInitialDocument
(
)
?
mBrowsingContext
-
>
GetSandboxFlags
(
)
:
mBrowsingContext
-
>
GetInitialSandboxFlags
(
)
;
if
(
(
sandboxFlags
&
SANDBOXED_ORIGIN
)
&
&
!
aActor
)
{
if
(
aPrincipal
)
{
principal
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
aPrincipal
)
;
}
else
{
principal
=
NullPrincipal
:
:
Create
(
GetOriginAttributes
(
)
)
;
}
partitionedPrincipal
=
principal
;
}
else
{
principal
=
aPrincipal
;
partitionedPrincipal
=
aPartitionedPrincipal
;
}
MaybeCreateInitialClientSource
(
StoragePrincipalHelper
:
:
ShouldUsePartitionPrincipalForServiceWorker
(
this
)
?
partitionedPrincipal
:
principal
)
;
blankDoc
=
nsContentDLF
:
:
CreateBlankDocument
(
mLoadGroup
principal
partitionedPrincipal
this
)
;
if
(
blankDoc
)
{
if
(
aCSP
)
{
RefPtr
<
nsCSPContext
>
cspToInherit
=
new
nsCSPContext
(
)
;
cspToInherit
-
>
InitFromOther
(
static_cast
<
nsCSPContext
*
>
(
aCSP
)
)
;
blankDoc
-
>
SetCsp
(
cspToInherit
)
;
}
blankDoc
-
>
SetIsInitialDocument
(
aIsInitialDocument
)
;
blankDoc
-
>
SetEmbedderPolicy
(
aCOEP
)
;
blankDoc
-
>
SetBaseURI
(
aBaseURI
)
;
blankDoc
-
>
SetSandboxFlags
(
sandboxFlags
)
;
blankDoc
-
>
InitFeaturePolicy
(
)
;
docFactory
-
>
CreateInstanceForDocument
(
NS_ISUPPORTS_CAST
(
nsIDocShell
*
this
)
blankDoc
"
view
"
getter_AddRefs
(
viewer
)
)
;
if
(
viewer
)
{
viewer
-
>
SetContainer
(
this
)
;
rv
=
Embed
(
viewer
aActor
true
false
nullptr
mCurrentURI
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SetCurrentURI
(
blankDoc
-
>
GetDocumentURI
(
)
nullptr
true
true
0
)
;
rv
=
mIsBeingDestroyed
?
NS_ERROR_NOT_AVAILABLE
:
NS_OK
;
}
}
}
SetHistoryEntryAndUpdateBC
(
Nothing
(
)
Some
(
nullptr
)
)
;
if
(
!
hadTiming
)
{
mTiming
=
nullptr
;
mBlankTiming
=
true
;
}
return
rv
;
}
NS_IMETHODIMP
nsDocShell
:
:
CreateAboutBlankContentViewer
(
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aPartitionedPrincipal
nsIContentSecurityPolicy
*
aCSP
)
{
return
CreateAboutBlankContentViewer
(
aPrincipal
aPartitionedPrincipal
aCSP
nullptr
false
)
;
}
nsresult
nsDocShell
:
:
CreateContentViewerForActor
(
WindowGlobalChild
*
aWindowActor
)
{
MOZ_ASSERT
(
aWindowActor
)
;
nsresult
rv
=
CreateAboutBlankContentViewer
(
aWindowActor
-
>
DocumentPrincipal
(
)
aWindowActor
-
>
DocumentPrincipal
(
)
nullptr
nullptr
true
Nothing
(
)
true
true
aWindowActor
)
;
#
ifdef
DEBUG
if
(
NS_SUCCEEDED
(
rv
)
)
{
RefPtr
<
Document
>
doc
(
GetDocument
(
)
)
;
MOZ_ASSERT
(
doc
"
Should
have
a
document
if
CreateAboutBlankContentViewer
succeeded
"
)
;
MOZ_ASSERT
(
doc
-
>
GetOwnerGlobal
(
)
=
=
aWindowActor
-
>
GetWindowGlobal
(
)
"
New
document
should
be
in
the
same
global
as
our
actor
"
)
;
MOZ_ASSERT
(
doc
-
>
IsInitialDocument
(
)
"
New
document
should
be
an
initial
document
"
)
;
}
#
endif
return
rv
;
}
bool
nsDocShell
:
:
CanSavePresentation
(
uint32_t
aLoadType
nsIRequest
*
aNewRequest
Document
*
aNewDocument
bool
aReportBFCacheComboTelemetry
)
{
if
(
!
mOSHE
)
{
return
false
;
}
MOZ_ASSERT
(
!
mozilla
:
:
SessionHistoryInParent
(
)
"
mOSHE
cannot
be
non
-
null
with
SHIP
"
)
;
nsCOMPtr
<
nsIContentViewer
>
viewer
=
mOSHE
-
>
GetContentViewer
(
)
;
if
(
viewer
)
{
NS_WARNING
(
"
mOSHE
already
has
a
content
viewer
!
"
)
;
return
false
;
}
if
(
aLoadType
!
=
LOAD_NORMAL
&
&
aLoadType
!
=
LOAD_HISTORY
&
&
aLoadType
!
=
LOAD_LINK
&
&
aLoadType
!
=
LOAD_STOP_CONTENT
&
&
aLoadType
!
=
LOAD_STOP_CONTENT_AND_REPLACE
&
&
aLoadType
!
=
LOAD_ERROR_PAGE
)
{
return
false
;
}
if
(
!
mOSHE
-
>
GetSaveLayoutStateFlag
(
)
)
{
return
false
;
}
if
(
!
mScriptGlobal
|
|
mScriptGlobal
-
>
IsLoading
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Blocked
due
to
document
still
loading
"
)
)
;
return
false
;
}
if
(
mScriptGlobal
-
>
WouldReuseInnerWindow
(
aNewDocument
)
)
{
return
false
;
}
if
(
nsSHistory
:
:
GetMaxTotalViewers
(
)
=
=
0
)
{
return
false
;
}
if
(
mBrowsingContext
-
>
GetParent
(
)
)
{
return
false
;
}
RefPtr
<
Document
>
doc
=
mScriptGlobal
-
>
GetExtantDoc
(
)
;
uint32_t
bfCacheCombo
=
0
;
bool
canSavePresentation
=
doc
-
>
CanSavePresentation
(
aNewRequest
bfCacheCombo
true
)
;
MOZ_ASSERT_IF
(
canSavePresentation
bfCacheCombo
=
=
0
)
;
if
(
canSavePresentation
&
&
doc
-
>
IsTopLevelContentDocument
(
)
)
{
auto
*
browsingContextGroup
=
mBrowsingContext
-
>
Group
(
)
;
nsTArray
<
RefPtr
<
BrowsingContext
>
>
&
topLevelContext
=
browsingContextGroup
-
>
Toplevels
(
)
;
for
(
const
auto
&
browsingContext
:
topLevelContext
)
{
if
(
browsingContext
!
=
mBrowsingContext
)
{
if
(
StaticPrefs
:
:
docshell_shistory_bfcache_require_no_opener
(
)
)
{
canSavePresentation
=
false
;
}
bfCacheCombo
|
=
BFCacheStatus
:
:
NOT_ONLY_TOPLEVEL_IN_BCG
;
break
;
}
}
}
if
(
aReportBFCacheComboTelemetry
)
{
ReportBFCacheComboTelemetry
(
bfCacheCombo
)
;
}
return
doc
&
&
canSavePresentation
;
}
void
nsDocShell
:
:
ReportBFCacheComboTelemetry
(
uint32_t
aCombo
)
{
enum
BFCacheStatusCombo
:
uint32_t
{
BFCACHE_SUCCESS
NOT_ONLY_TOPLEVEL
=
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
NOT_ONLY_TOPLEVEL_IN_BCG
UNLOAD
=
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
UNLOAD_LISTENER
UNLOAD_REQUEST
=
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
UNLOAD_LISTENER
|
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
REQUEST
REQUEST
=
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
REQUEST
UNLOAD_REQUEST_PEER
=
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
UNLOAD_LISTENER
|
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
REQUEST
|
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
ACTIVE_PEER_CONNECTION
UNLOAD_REQUEST_PEER_MSE
=
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
UNLOAD_LISTENER
|
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
REQUEST
|
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
ACTIVE_PEER_CONNECTION
|
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
CONTAINS_MSE_CONTENT
UNLOAD_REQUEST_MSE
=
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
UNLOAD_LISTENER
|
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
REQUEST
|
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
CONTAINS_MSE_CONTENT
SUSPENDED_UNLOAD_REQUEST_PEER
=
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
SUSPENDED
|
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
UNLOAD_LISTENER
|
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
REQUEST
|
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
ACTIVE_PEER_CONNECTION
REMOTE_SUBFRAMES
=
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
CONTAINS_REMOTE_SUBFRAMES
BEFOREUNLOAD
=
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
BEFOREUNLOAD_LISTENER
}
;
if
(
aCombo
!
=
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
BEFOREUNLOAD_LISTENER
)
{
aCombo
&
=
~
mozilla
:
:
dom
:
:
BFCacheStatus
:
:
BEFOREUNLOAD_LISTENER
;
}
switch
(
aCombo
)
{
case
BFCACHE_SUCCESS
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
BFCache_Success
)
;
break
;
case
NOT_ONLY_TOPLEVEL
:
if
(
StaticPrefs
:
:
docshell_shistory_bfcache_require_no_opener
(
)
)
{
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Other
)
;
break
;
}
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
BFCache_Success
)
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Success_Not_Toplevel
)
;
break
;
case
UNLOAD
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Unload
)
;
break
;
case
BEFOREUNLOAD
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Beforeunload
)
;
break
;
case
UNLOAD_REQUEST
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Unload_Req
)
;
break
;
case
REQUEST
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Req
)
;
break
;
case
UNLOAD_REQUEST_PEER
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Unload_Req_Peer
)
;
break
;
case
UNLOAD_REQUEST_PEER_MSE
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Unload_Req_Peer_MSE
)
;
break
;
case
UNLOAD_REQUEST_MSE
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Unload_Req_MSE
)
;
break
;
case
SUSPENDED_UNLOAD_REQUEST_PEER
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
SPD_Unload_Req_Peer
)
;
break
;
case
REMOTE_SUBFRAMES
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Remote_Subframes
)
;
break
;
default
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_BFCACHE_COMBO
:
:
Other
)
;
break
;
}
}
;
void
nsDocShell
:
:
ReattachEditorToWindow
(
nsISHEntry
*
aSHEntry
)
{
MOZ_ASSERT
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
;
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
NS_ASSERTION
(
!
mEditorData
"
Why
reattach
an
editor
when
we
already
have
one
?
"
)
;
NS_ASSERTION
(
aSHEntry
&
&
aSHEntry
-
>
HasDetachedEditor
(
)
"
Reattaching
when
there
'
s
not
a
detached
editor
.
"
)
;
if
(
mEditorData
|
|
!
aSHEntry
)
{
return
;
}
mEditorData
=
WrapUnique
(
aSHEntry
-
>
ForgetEditorData
(
)
)
;
if
(
mEditorData
)
{
#
ifdef
DEBUG
nsresult
rv
=
#
endif
mEditorData
-
>
ReattachToWindow
(
this
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
reattach
editing
session
"
)
;
}
}
void
nsDocShell
:
:
DetachEditorFromWindow
(
)
{
if
(
!
mEditorData
|
|
mEditorData
-
>
WaitingForLoad
(
)
)
{
return
;
}
NS_ASSERTION
(
!
mOSHE
|
|
!
mOSHE
-
>
HasDetachedEditor
(
)
"
Detaching
editor
when
it
'
s
already
detached
.
"
)
;
nsresult
res
=
mEditorData
-
>
DetachFromWindow
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
res
)
"
Failed
to
detach
editor
"
)
;
if
(
NS_SUCCEEDED
(
res
)
)
{
if
(
mOSHE
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
|
|
!
mOSHE
-
>
HasDetachedEditor
(
)
"
We
should
not
set
the
editor
data
again
once
after
we
"
"
detached
the
editor
data
during
destroying
this
docshell
"
)
;
mOSHE
-
>
SetEditorData
(
mEditorData
.
release
(
)
)
;
}
else
{
mEditorData
=
nullptr
;
}
}
#
ifdef
DEBUG
{
bool
isEditable
;
GetEditable
(
&
isEditable
)
;
NS_ASSERTION
(
!
isEditable
"
Window
is
still
editable
after
detaching
editor
.
"
)
;
}
#
endif
}
nsresult
nsDocShell
:
:
CaptureState
(
)
{
MOZ_ASSERT
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
;
if
(
!
mOSHE
|
|
mOSHE
=
=
mLSHE
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mScriptGlobal
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISupports
>
windowState
=
mScriptGlobal
-
>
SaveWindowState
(
)
;
NS_ENSURE_TRUE
(
windowState
NS_ERROR_FAILURE
)
;
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
gPageCacheLog
LogLevel
:
:
Debug
)
)
)
{
nsAutoCString
spec
;
nsCOMPtr
<
nsIURI
>
uri
=
mOSHE
-
>
GetURI
(
)
;
if
(
uri
)
{
uri
-
>
GetSpec
(
spec
)
;
}
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Debug
(
"
Saving
presentation
into
session
history
URI
:
%
s
"
spec
.
get
(
)
)
)
;
}
mOSHE
-
>
SetWindowState
(
windowState
)
;
mOSHE
-
>
SetRefreshURIList
(
mSavedRefreshURIList
)
;
if
(
mContentViewer
)
{
nsIntRect
bounds
;
mContentViewer
-
>
GetBounds
(
bounds
)
;
mOSHE
-
>
SetViewerBounds
(
bounds
)
;
}
mOSHE
-
>
ClearChildShells
(
)
;
uint32_t
childCount
=
mChildList
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
childShell
=
do_QueryInterface
(
ChildAt
(
i
)
)
;
NS_ASSERTION
(
childShell
"
null
child
shell
"
)
;
mOSHE
-
>
AddChildShell
(
childShell
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
RestorePresentationEvent
:
:
Run
(
)
{
MOZ_ASSERT
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
;
if
(
mDocShell
&
&
NS_FAILED
(
mDocShell
-
>
RestoreFromHistory
(
)
)
)
{
NS_WARNING
(
"
RestoreFromHistory
failed
"
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
BeginRestore
(
nsIContentViewer
*
aContentViewer
bool
aTop
)
{
MOZ_ASSERT
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
;
nsresult
rv
;
if
(
!
aContentViewer
)
{
rv
=
EnsureContentViewer
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aContentViewer
=
mContentViewer
;
}
RefPtr
<
Document
>
doc
=
aContentViewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
nsIChannel
*
channel
=
doc
-
>
GetChannel
(
)
;
if
(
channel
)
{
mEODForCurrentDocument
=
false
;
mIsRestoringDocument
=
true
;
mLoadGroup
-
>
AddRequest
(
channel
nullptr
)
;
mIsRestoringDocument
=
false
;
}
}
if
(
!
aTop
)
{
mFiredUnloadEvent
=
false
;
rv
=
BeginRestoreChildren
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
BeginRestoreChildren
(
)
{
MOZ_ASSERT
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
;
for
(
auto
*
childDocLoader
:
mChildList
.
ForwardRange
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
child
=
do_QueryObject
(
childDocLoader
)
;
if
(
child
)
{
nsresult
rv
=
child
-
>
BeginRestore
(
nullptr
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
FinishRestore
(
)
{
MOZ_ASSERT
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
;
for
(
auto
*
childDocLoader
:
mChildList
.
ForwardRange
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
child
=
do_QueryObject
(
childDocLoader
)
;
if
(
child
)
{
child
-
>
FinishRestore
(
)
;
}
}
if
(
mOSHE
&
&
mOSHE
-
>
HasDetachedEditor
(
)
)
{
ReattachEditorToWindow
(
mOSHE
)
;
}
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
if
(
doc
)
{
nsIChannel
*
channel
=
doc
-
>
GetChannel
(
)
;
if
(
channel
)
{
mIsRestoringDocument
=
true
;
mLoadGroup
-
>
RemoveRequest
(
channel
nullptr
NS_OK
)
;
mIsRestoringDocument
=
false
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetRestoringDocument
(
bool
*
aRestoring
)
{
*
aRestoring
=
mIsRestoringDocument
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
RestorePresentation
(
nsISHEntry
*
aSHEntry
bool
*
aRestoring
)
{
MOZ_ASSERT
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
;
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
NS_ASSERTION
(
mLoadType
&
LOAD_CMD_HISTORY
"
RestorePresentation
should
only
be
called
for
history
loads
"
)
;
nsCOMPtr
<
nsIContentViewer
>
viewer
=
aSHEntry
-
>
GetContentViewer
(
)
;
nsAutoCString
spec
;
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
gPageCacheLog
LogLevel
:
:
Debug
)
)
)
{
nsCOMPtr
<
nsIURI
>
uri
=
aSHEntry
-
>
GetURI
(
)
;
if
(
uri
)
{
uri
-
>
GetSpec
(
spec
)
;
}
}
*
aRestoring
=
false
;
if
(
!
viewer
)
{
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Debug
(
"
no
saved
presentation
for
uri
:
%
s
"
spec
.
get
(
)
)
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShell
>
container
;
viewer
-
>
GetContainer
(
getter_AddRefs
(
container
)
)
;
if
(
!
:
:
SameCOMIdentity
(
container
GetAsSupports
(
this
)
)
)
{
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Debug
(
"
No
valid
container
clearing
presentation
"
)
)
;
aSHEntry
-
>
SetContentViewer
(
nullptr
)
;
return
NS_ERROR_FAILURE
;
}
NS_ASSERTION
(
mContentViewer
!
=
viewer
"
Restoring
existing
presentation
"
)
;
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Debug
(
"
restoring
presentation
from
session
history
:
%
s
"
spec
.
get
(
)
)
)
;
SetHistoryEntryAndUpdateBC
(
Some
(
aSHEntry
)
Nothing
(
)
)
;
NS_ASSERTION
(
!
mRestorePresentationEvent
.
IsPending
(
)
"
should
only
have
one
RestorePresentationEvent
"
)
;
mRestorePresentationEvent
.
Revoke
(
)
;
RefPtr
<
RestorePresentationEvent
>
evt
=
new
RestorePresentationEvent
(
this
)
;
nsresult
rv
=
Dispatch
(
TaskCategory
:
:
Other
do_AddRef
(
evt
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mRestorePresentationEvent
=
evt
.
get
(
)
;
*
aRestoring
=
true
;
}
return
rv
;
}
namespace
{
class
MOZ_STACK_CLASS
PresentationEventForgetter
{
public
:
explicit
PresentationEventForgetter
(
nsRevocableEventPtr
<
nsDocShell
:
:
RestorePresentationEvent
>
&
aRestorePresentationEvent
)
:
mRestorePresentationEvent
(
aRestorePresentationEvent
)
mEvent
(
aRestorePresentationEvent
.
get
(
)
)
{
}
~
PresentationEventForgetter
(
)
{
Forget
(
)
;
}
void
Forget
(
)
{
if
(
mRestorePresentationEvent
.
get
(
)
=
=
mEvent
)
{
mRestorePresentationEvent
.
Forget
(
)
;
mEvent
=
nullptr
;
}
}
private
:
nsRevocableEventPtr
<
nsDocShell
:
:
RestorePresentationEvent
>
&
mRestorePresentationEvent
;
RefPtr
<
nsDocShell
:
:
RestorePresentationEvent
>
mEvent
;
}
;
}
bool
nsDocShell
:
:
SandboxFlagsImplyCookies
(
const
uint32_t
&
aSandboxFlags
)
{
return
(
aSandboxFlags
&
(
SANDBOXED_ORIGIN
|
SANDBOXED_SCRIPTS
)
)
=
=
0
;
}
nsresult
nsDocShell
:
:
RestoreFromHistory
(
)
{
MOZ_ASSERT
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
;
MOZ_ASSERT
(
mRestorePresentationEvent
.
IsPending
(
)
)
;
PresentationEventForgetter
forgetter
(
mRestorePresentationEvent
)
;
if
(
!
mLSHE
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContentViewer
>
viewer
=
mLSHE
-
>
GetContentViewer
(
)
;
if
(
!
viewer
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mSavingOldViewer
)
{
RefPtr
<
Document
>
doc
=
viewer
-
>
GetDocument
(
)
;
nsIRequest
*
request
=
nullptr
;
if
(
doc
)
{
request
=
doc
-
>
GetChannel
(
)
;
}
mSavingOldViewer
=
CanSavePresentation
(
mLoadType
request
doc
false
)
;
}
nsCOMPtr
<
nsISHEntry
>
origLSHE
=
mLSHE
;
mLoadingURI
=
nullptr
;
FirePageHideNotification
(
!
mSavingOldViewer
)
;
if
(
mIsBeingDestroyed
)
{
return
NS_ERROR_DOCSHELL_DYING
;
}
if
(
mLSHE
!
=
origLSHE
)
{
return
NS_OK
;
}
RefPtr
<
RestorePresentationEvent
>
currentPresentationRestoration
=
mRestorePresentationEvent
.
get
(
)
;
Stop
(
)
;
NS_ENSURE_STATE
(
currentPresentationRestoration
=
=
mRestorePresentationEvent
.
get
(
)
)
;
BeginRestore
(
viewer
true
)
;
NS_ENSURE_STATE
(
currentPresentationRestoration
=
=
mRestorePresentationEvent
.
get
(
)
)
;
forgetter
.
Forget
(
)
;
mFiredUnloadEvent
=
false
;
mURIResultedInDocument
=
true
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
rootSH
)
{
mPreviousEntryIndex
=
rootSH
-
>
Index
(
)
;
rootSH
-
>
LegacySHistory
(
)
-
>
UpdateIndex
(
)
;
mLoadedEntryIndex
=
rootSH
-
>
Index
(
)
;
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Verbose
(
"
Previous
index
:
%
d
Loaded
index
:
%
d
"
mPreviousEntryIndex
mLoadedEntryIndex
)
)
;
}
PersistLayoutHistoryState
(
)
;
nsresult
rv
;
if
(
mContentViewer
)
{
if
(
mSavingOldViewer
&
&
NS_FAILED
(
CaptureState
(
)
)
)
{
if
(
mOSHE
)
{
mOSHE
-
>
SyncPresentationState
(
)
;
}
mSavingOldViewer
=
false
;
}
}
mSavedRefreshURIList
=
nullptr
;
if
(
mContentViewer
)
{
nsCOMPtr
<
nsIContentViewer
>
previousViewer
=
mContentViewer
-
>
GetPreviousViewer
(
)
;
if
(
previousViewer
)
{
mContentViewer
-
>
SetPreviousViewer
(
nullptr
)
;
previousViewer
-
>
Destroy
(
)
;
}
}
nsView
*
rootViewSibling
=
nullptr
;
nsView
*
rootViewParent
=
nullptr
;
nsIntRect
newBounds
(
0
0
0
0
)
;
PresShell
*
oldPresShell
=
GetPresShell
(
)
;
if
(
oldPresShell
)
{
nsViewManager
*
vm
=
oldPresShell
-
>
GetViewManager
(
)
;
if
(
vm
)
{
nsView
*
oldRootView
=
vm
-
>
GetRootView
(
)
;
if
(
oldRootView
)
{
rootViewSibling
=
oldRootView
-
>
GetNextSibling
(
)
;
rootViewParent
=
oldRootView
-
>
GetParent
(
)
;
mContentViewer
-
>
GetBounds
(
newBounds
)
;
}
}
}
nsCOMPtr
<
nsIContent
>
container
;
RefPtr
<
Document
>
sibling
;
if
(
rootViewParent
&
&
rootViewParent
-
>
GetParent
(
)
)
{
nsIFrame
*
frame
=
rootViewParent
-
>
GetParent
(
)
-
>
GetFrame
(
)
;
container
=
frame
?
frame
-
>
GetContent
(
)
:
nullptr
;
}
if
(
rootViewSibling
)
{
nsIFrame
*
frame
=
rootViewSibling
-
>
GetFrame
(
)
;
sibling
=
frame
?
frame
-
>
PresShell
(
)
-
>
GetDocument
(
)
:
nullptr
;
}
if
(
mContentViewer
)
{
mContentViewer
-
>
Close
(
mSavingOldViewer
?
mOSHE
.
get
(
)
:
nullptr
)
;
viewer
-
>
SetPreviousViewer
(
mContentViewer
)
;
}
if
(
mOSHE
&
&
(
!
mContentViewer
|
|
!
mSavingOldViewer
)
)
{
mOSHE
-
>
SyncPresentationState
(
)
;
}
mContentViewer
=
nullptr
;
DestroyChildren
(
)
;
mContentViewer
.
swap
(
viewer
)
;
nsCOMPtr
<
nsISupports
>
windowState
=
mLSHE
-
>
GetWindowState
(
)
;
mLSHE
-
>
SetWindowState
(
nullptr
)
;
bool
sticky
=
mLSHE
-
>
GetSticky
(
)
;
RefPtr
<
Document
>
document
=
mContentViewer
-
>
GetDocument
(
)
;
nsCOMArray
<
nsIDocShellTreeItem
>
childShells
;
int32_t
i
=
0
;
nsCOMPtr
<
nsIDocShellTreeItem
>
child
;
while
(
NS_SUCCEEDED
(
mLSHE
-
>
ChildShellAt
(
i
+
+
getter_AddRefs
(
child
)
)
)
&
&
child
)
{
childShells
.
AppendObject
(
child
)
;
}
nsIntRect
oldBounds
(
0
0
0
0
)
;
mLSHE
-
>
GetViewerBounds
(
oldBounds
)
;
nsCOMPtr
<
nsIMutableArray
>
refreshURIList
=
mLSHE
-
>
GetRefreshURIList
(
)
;
mIsRestoringDocument
=
true
;
rv
=
mContentViewer
-
>
Open
(
windowState
mLSHE
)
;
mIsRestoringDocument
=
false
;
UniquePtr
<
nsDocShellEditorData
>
data
(
mLSHE
-
>
ForgetEditorData
(
)
)
;
mLSHE
-
>
SetContentViewer
(
nullptr
)
;
mEODForCurrentDocument
=
false
;
mLSHE
-
>
SetEditorData
(
data
.
release
(
)
)
;
#
ifdef
DEBUG
{
nsCOMPtr
<
nsIMutableArray
>
refreshURIs
=
mLSHE
-
>
GetRefreshURIList
(
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
childShell
;
mLSHE
-
>
ChildShellAt
(
0
getter_AddRefs
(
childShell
)
)
;
NS_ASSERTION
(
!
refreshURIs
&
&
!
childShell
"
SHEntry
should
have
cleared
presentation
state
"
)
;
}
#
endif
mContentViewer
-
>
SetSticky
(
sticky
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SetHistoryEntryAndUpdateBC
(
Nothing
(
)
Some
<
nsISHEntry
*
>
(
mLSHE
)
)
;
SetLayoutHistoryState
(
nullptr
)
;
mSavingOldViewer
=
false
;
mEODForCurrentDocument
=
false
;
if
(
document
)
{
RefPtr
<
nsDocShell
>
parent
=
GetInProcessParentDocshell
(
)
;
if
(
parent
)
{
RefPtr
<
Document
>
d
=
parent
-
>
GetDocument
(
)
;
if
(
d
)
{
if
(
d
-
>
EventHandlingSuppressed
(
)
)
{
document
-
>
SuppressEventHandling
(
d
-
>
EventHandlingSuppressed
(
)
)
;
}
}
}
nsCOMPtr
<
nsIURI
>
uri
=
origLSHE
-
>
GetURI
(
)
;
SetCurrentURI
(
uri
document
-
>
GetChannel
(
)
true
false
0
)
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
privWin
=
GetWindow
(
)
;
NS_ASSERTION
(
privWin
"
could
not
get
nsPIDOMWindow
interface
"
)
;
document
-
>
NotifyPossibleTitleChange
(
false
)
;
for
(
i
=
0
;
i
<
childShells
.
Count
(
)
;
+
+
i
)
{
nsIDocShellTreeItem
*
childItem
=
childShells
.
ObjectAt
(
i
)
;
nsCOMPtr
<
nsIDocShell
>
childShell
=
do_QueryInterface
(
childItem
)
;
bool
allowRedirects
;
childShell
-
>
GetAllowMetaRedirects
(
&
allowRedirects
)
;
bool
allowSubframes
;
childShell
-
>
GetAllowSubframes
(
&
allowSubframes
)
;
bool
allowImages
;
childShell
-
>
GetAllowImages
(
&
allowImages
)
;
bool
allowMedia
=
childShell
-
>
GetAllowMedia
(
)
;
bool
allowDNSPrefetch
;
childShell
-
>
GetAllowDNSPrefetch
(
&
allowDNSPrefetch
)
;
bool
allowContentRetargeting
=
childShell
-
>
GetAllowContentRetargeting
(
)
;
bool
allowContentRetargetingOnChildren
=
childShell
-
>
GetAllowContentRetargetingOnChildren
(
)
;
AddChild
(
childItem
)
;
childShell
-
>
SetAllowMetaRedirects
(
allowRedirects
)
;
childShell
-
>
SetAllowSubframes
(
allowSubframes
)
;
childShell
-
>
SetAllowImages
(
allowImages
)
;
childShell
-
>
SetAllowMedia
(
allowMedia
)
;
childShell
-
>
SetAllowDNSPrefetch
(
allowDNSPrefetch
)
;
childShell
-
>
SetAllowContentRetargeting
(
allowContentRetargeting
)
;
childShell
-
>
SetAllowContentRetargetingOnChildren
(
allowContentRetargetingOnChildren
)
;
rv
=
childShell
-
>
BeginRestore
(
nullptr
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
privWin
-
>
RestoreWindowState
(
windowState
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
RefPtr
<
nsPresContext
>
pc
=
presShell
-
>
GetPresContext
(
)
;
if
(
pc
-
>
DeviceContext
(
)
-
>
CheckDPIChange
(
)
)
{
presShell
-
>
BackingScaleFactorChanged
(
)
;
}
pc
-
>
RecomputeBrowsingContextDependentData
(
)
;
}
nsViewManager
*
newVM
=
presShell
?
presShell
-
>
GetViewManager
(
)
:
nullptr
;
nsView
*
newRootView
=
newVM
?
newVM
-
>
GetRootView
(
)
:
nullptr
;
if
(
container
)
{
nsSubDocumentFrame
*
subDocFrame
=
do_QueryFrame
(
container
-
>
GetPrimaryFrame
(
)
)
;
rootViewParent
=
subDocFrame
?
subDocFrame
-
>
EnsureInnerView
(
)
:
nullptr
;
}
else
{
rootViewParent
=
nullptr
;
}
if
(
sibling
&
&
sibling
-
>
GetPresShell
(
)
&
&
sibling
-
>
GetPresShell
(
)
-
>
GetViewManager
(
)
)
{
rootViewSibling
=
sibling
-
>
GetPresShell
(
)
-
>
GetViewManager
(
)
-
>
GetRootView
(
)
;
}
else
{
rootViewSibling
=
nullptr
;
}
if
(
rootViewParent
&
&
newRootView
&
&
newRootView
-
>
GetParent
(
)
!
=
rootViewParent
)
{
nsViewManager
*
parentVM
=
rootViewParent
-
>
GetViewManager
(
)
;
if
(
parentVM
)
{
parentVM
-
>
InsertChild
(
rootViewParent
newRootView
rootViewSibling
rootViewSibling
?
true
:
false
)
;
NS_ASSERTION
(
newRootView
-
>
GetNextSibling
(
)
=
=
rootViewSibling
"
error
in
InsertChild
"
)
;
}
}
nsCOMPtr
<
nsPIDOMWindowInner
>
privWinInner
=
privWin
-
>
GetCurrentInnerWindow
(
)
;
privWinInner
-
>
SyncStateFromParentWindow
(
)
;
privWinInner
-
>
Resume
(
)
;
Performance
*
performance
=
privWinInner
-
>
GetPerformance
(
)
;
if
(
performance
)
{
performance
-
>
GetDOMTiming
(
)
-
>
NotifyRestoreStart
(
)
;
}
mRefreshURIList
=
refreshURIList
;
for
(
auto
*
childDocLoader
:
mChildList
.
ForwardRange
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
child
=
do_QueryObject
(
childDocLoader
)
;
if
(
child
)
{
child
-
>
ResumeRefreshURIs
(
)
;
}
}
if
(
newRootView
)
{
if
(
!
newBounds
.
IsEmpty
(
)
&
&
!
newBounds
.
IsEqualEdges
(
oldBounds
)
)
{
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Debug
(
"
resize
widget
(
%
d
%
d
%
d
%
d
)
"
newBounds
.
x
newBounds
.
y
newBounds
.
width
newBounds
.
height
)
)
;
mContentViewer
-
>
SetBounds
(
newBounds
)
;
}
else
{
nsIScrollableFrame
*
rootScrollFrame
=
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
rootScrollFrame
)
{
rootScrollFrame
-
>
PostScrolledAreaEventForCurrentArea
(
)
;
}
}
}
newRootView
=
rootViewSibling
=
rootViewParent
=
nullptr
;
newVM
=
nullptr
;
if
(
oldPresShell
&
&
presShell
&
&
presShell
-
>
IsUnderHiddenEmbedderElement
(
)
!
=
oldPresShell
-
>
IsUnderHiddenEmbedderElement
(
)
)
{
presShell
-
>
SetIsUnderHiddenEmbedderElement
(
oldPresShell
-
>
IsUnderHiddenEmbedderElement
(
)
)
;
}
nsDocShell
:
:
FinishRestore
(
)
;
if
(
presShell
)
{
presShell
-
>
Thaw
(
)
;
}
return
privWin
-
>
FireDelayedDOMEvents
(
true
)
;
}
nsresult
nsDocShell
:
:
CreateContentViewer
(
const
nsACString
&
aContentType
nsIRequest
*
aRequest
nsIStreamListener
*
*
aContentHandler
)
{
if
(
DocGroup
:
:
TryToLoadIframesInBackground
(
)
)
{
ResetToFirstLoad
(
)
;
}
*
aContentHandler
=
nullptr
;
if
(
!
mTreeOwner
|
|
mIsBeingDestroyed
)
{
return
NS_ERROR_DOCSHELL_DYING
;
}
if
(
!
mBrowsingContext
-
>
AncestorsAreCurrent
(
)
|
|
mBrowsingContext
-
>
IsInBFCache
(
)
)
{
mBrowsingContext
-
>
RemoveRootFromBFCacheSync
(
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_ASSERTION
(
mLoadGroup
"
Someone
ignored
return
from
Init
(
)
?
"
)
;
nsCOMPtr
<
nsIContentViewer
>
viewer
;
nsresult
rv
=
NewContentViewerObj
(
aContentType
aRequest
mLoadGroup
aContentHandler
getter_AddRefs
(
viewer
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mSavingOldViewer
)
{
RefPtr
<
Document
>
doc
=
viewer
-
>
GetDocument
(
)
;
mSavingOldViewer
=
CanSavePresentation
(
mLoadType
aRequest
doc
false
)
;
}
NS_ASSERTION
(
!
mLoadingURI
"
Re
-
entering
unload
?
"
)
;
nsCOMPtr
<
nsIChannel
>
aOpenedChannel
=
do_QueryInterface
(
aRequest
)
;
if
(
aOpenedChannel
)
{
aOpenedChannel
-
>
GetURI
(
getter_AddRefs
(
mLoadingURI
)
)
;
}
nsCOMPtr
<
nsIURI
>
previousURI
=
mCurrentURI
;
FirePageHideNotification
(
!
mSavingOldViewer
)
;
if
(
mIsBeingDestroyed
)
{
viewer
-
>
Stop
(
)
;
return
NS_ERROR_DOCSHELL_DYING
;
}
mLoadingURI
=
nullptr
;
mFiredUnloadEvent
=
false
;
mURIResultedInDocument
=
true
;
bool
errorOnLocationChangeNeeded
=
false
;
nsCOMPtr
<
nsIChannel
>
failedChannel
=
mFailedChannel
;
nsCOMPtr
<
nsIURI
>
failedURI
;
if
(
mLoadType
=
=
LOAD_ERROR_PAGE
)
{
mLoadType
=
mFailedLoadType
;
Document
*
doc
=
viewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
doc
-
>
SetFailedChannel
(
failedChannel
)
;
}
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
;
if
(
failedChannel
)
{
NS_GetFinalChannelURI
(
failedChannel
getter_AddRefs
(
failedURI
)
)
;
}
else
{
triggeringPrincipal
=
nsContentUtils
:
:
GetSystemPrincipal
(
)
;
}
if
(
!
failedURI
)
{
failedURI
=
mFailedURI
;
}
if
(
!
failedURI
)
{
NS_NewURI
(
getter_AddRefs
(
failedURI
)
"
about
:
blank
"
)
;
}
MOZ_ASSERT
(
failedURI
"
We
don
'
t
have
a
URI
for
history
APIs
.
"
)
;
mFailedChannel
=
nullptr
;
mFailedURI
=
nullptr
;
if
(
failedURI
)
{
errorOnLocationChangeNeeded
=
OnNewURI
(
failedURI
failedChannel
triggeringPrincipal
nullptr
nullptr
nullptr
false
false
false
)
;
}
ChildSHistory
*
shistory
=
GetSessionHistory
(
)
;
if
(
!
mozilla
:
:
SessionHistoryInParent
(
)
&
&
shistory
&
&
!
mLSHE
)
{
int32_t
idx
=
shistory
-
>
LegacySHistory
(
)
-
>
GetRequestedIndex
(
)
;
if
(
idx
=
=
-
1
)
{
idx
=
shistory
-
>
Index
(
)
;
}
shistory
-
>
LegacySHistory
(
)
-
>
GetEntryAtIndex
(
idx
getter_AddRefs
(
mLSHE
)
)
;
}
mLoadType
=
LOAD_ERROR_PAGE
;
}
nsCOMPtr
<
nsIURI
>
finalURI
;
NS_GetFinalChannelURI
(
aOpenedChannel
getter_AddRefs
(
finalURI
)
)
;
bool
onLocationChangeNeeded
=
false
;
if
(
finalURI
)
{
onLocationChangeNeeded
=
OnNewURI
(
finalURI
aOpenedChannel
nullptr
nullptr
nullptr
nullptr
false
true
false
)
;
}
nsCOMPtr
<
nsILoadGroup
>
currentLoadGroup
;
NS_ENSURE_SUCCESS
(
aOpenedChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
currentLoadGroup
)
)
NS_ERROR_FAILURE
)
;
if
(
currentLoadGroup
!
=
mLoadGroup
)
{
nsLoadFlags
loadFlags
=
0
;
aOpenedChannel
-
>
SetLoadGroup
(
mLoadGroup
)
;
aOpenedChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
loadFlags
|
=
nsIChannel
:
:
LOAD_DOCUMENT_URI
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aOpenedChannel
-
>
LoadInfo
(
)
;
if
(
SandboxFlagsImplyCookies
(
loadInfo
-
>
GetSandboxFlags
(
)
)
)
{
loadFlags
|
=
nsIRequest
:
:
LOAD_DOCUMENT_NEEDS_COOKIE
;
}
aOpenedChannel
-
>
SetLoadFlags
(
loadFlags
)
;
mLoadGroup
-
>
AddRequest
(
aRequest
nullptr
)
;
if
(
currentLoadGroup
)
{
currentLoadGroup
-
>
RemoveRequest
(
aRequest
nullptr
NS_BINDING_RETARGETED
)
;
}
aOpenedChannel
-
>
SetNotificationCallbacks
(
this
)
;
}
if
(
DocGroup
:
:
TryToLoadIframesInBackground
(
)
)
{
if
(
(
!
mContentViewer
|
|
GetDocument
(
)
-
>
IsInitialDocument
(
)
)
&
&
IsSubframe
(
)
)
{
RefPtr
<
Document
>
newDoc
=
viewer
-
>
GetDocument
(
)
;
RefPtr
<
nsDocShell
>
parent
=
GetInProcessParentDocshell
(
)
;
nsCOMPtr
<
nsIPrincipal
>
parentPrincipal
=
parent
-
>
GetDocument
(
)
-
>
NodePrincipal
(
)
;
nsCOMPtr
<
nsIPrincipal
>
thisPrincipal
=
newDoc
-
>
NodePrincipal
(
)
;
SiteIdentifier
parentSite
;
SiteIdentifier
thisSite
;
nsresult
rv
=
BasePrincipal
:
:
Cast
(
parentPrincipal
)
-
>
GetSiteIdentifier
(
parentSite
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
BasePrincipal
:
:
Cast
(
thisPrincipal
)
-
>
GetSiteIdentifier
(
thisSite
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
parentSite
.
Equals
(
thisSite
)
)
{
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
nsCOMPtr
<
nsIURI
>
prinURI
;
BasePrincipal
:
:
Cast
(
thisPrincipal
)
-
>
GetURI
(
getter_AddRefs
(
prinURI
)
)
;
nsPrintfCString
marker
(
"
Iframe
loaded
in
background
:
%
s
"
nsContentUtils
:
:
TruncatedURLForDisplay
(
prinURI
)
.
get
(
)
)
;
PROFILER_MARKER_TEXT
(
"
Background
Iframe
"
DOM
{
}
marker
)
;
}
SetBackgroundLoadIframe
(
)
;
}
}
}
NS_ENSURE_SUCCESS
(
Embed
(
viewer
nullptr
false
ShouldAddToSessionHistory
(
finalURI
aOpenedChannel
)
aOpenedChannel
previousURI
)
NS_ERROR_FAILURE
)
;
if
(
!
mBrowsingContext
-
>
GetHasLoadedNonInitialDocument
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
mBrowsingContext
-
>
SetHasLoadedNonInitialDocument
(
true
)
)
;
}
if
(
TreatAsBackgroundLoad
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
triggerParentCheckDocShell
=
NewRunnableMethod
(
"
nsDocShell
:
:
TriggerParentCheckDocShellIsEmpty
"
this
&
nsDocShell
:
:
TriggerParentCheckDocShellIsEmpty
)
;
nsresult
rv
=
NS_DispatchToCurrentThread
(
triggerParentCheckDocShell
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mSavedRefreshURIList
=
nullptr
;
mSavingOldViewer
=
false
;
mEODForCurrentDocument
=
false
;
nsCOMPtr
<
nsIMultiPartChannel
>
multiPartChannel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
multiPartChannel
)
{
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
if
(
Document
*
doc
=
presShell
-
>
GetDocument
(
)
)
{
uint32_t
partID
;
multiPartChannel
-
>
GetPartID
(
&
partID
)
;
doc
-
>
SetPartID
(
partID
)
;
}
}
}
if
(
errorOnLocationChangeNeeded
)
{
FireOnLocationChange
(
this
failedChannel
failedURI
LOCATION_CHANGE_ERROR_PAGE
)
;
}
else
if
(
onLocationChangeNeeded
)
{
uint32_t
locationFlags
=
(
mLoadType
&
LOAD_CMD_RELOAD
)
?
uint32_t
(
LOCATION_CHANGE_RELOAD
)
:
0
;
FireOnLocationChange
(
this
aRequest
mCurrentURI
locationFlags
)
;
}
return
NS_OK
;
}
nsresult
nsDocShell
:
:
NewContentViewerObj
(
const
nsACString
&
aContentType
nsIRequest
*
aRequest
nsILoadGroup
*
aLoadGroup
nsIStreamListener
*
*
aContentHandler
nsIContentViewer
*
*
aViewer
)
{
nsCOMPtr
<
nsIChannel
>
aOpenedChannel
=
do_QueryInterface
(
aRequest
)
;
nsCOMPtr
<
nsIDocumentLoaderFactory
>
docLoaderFactory
=
nsContentUtils
:
:
FindInternalContentViewer
(
aContentType
)
;
if
(
!
docLoaderFactory
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
docLoaderFactory
-
>
CreateInstance
(
"
view
"
aOpenedChannel
aLoadGroup
aContentType
this
nullptr
aContentHandler
aViewer
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
(
*
aViewer
)
-
>
SetContainer
(
this
)
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
SetupNewViewer
(
nsIContentViewer
*
aNewViewer
WindowGlobalChild
*
aWindowActor
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
int32_t
x
=
0
;
int32_t
y
=
0
;
int32_t
cx
=
0
;
int32_t
cy
=
0
;
DoGetPositionAndSize
(
&
x
&
y
&
cx
&
cy
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parentAsItem
;
NS_ENSURE_SUCCESS
(
GetInProcessSameTypeParent
(
getter_AddRefs
(
parentAsItem
)
)
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDocShell
>
parent
(
do_QueryInterface
(
parentAsItem
)
)
;
const
Encoding
*
reloadEncoding
=
nullptr
;
int32_t
reloadEncodingSource
=
kCharsetUninitialized
;
nsCOMPtr
<
nsIContentViewer
>
newCv
;
if
(
mContentViewer
|
|
parent
)
{
nsCOMPtr
<
nsIContentViewer
>
oldCv
;
if
(
mContentViewer
)
{
oldCv
=
mContentViewer
;
if
(
mSavingOldViewer
&
&
NS_FAILED
(
CaptureState
(
)
)
)
{
if
(
mOSHE
)
{
mOSHE
-
>
SyncPresentationState
(
)
;
}
mSavingOldViewer
=
false
;
}
}
else
{
parent
-
>
GetContentViewer
(
getter_AddRefs
(
oldCv
)
)
;
}
if
(
oldCv
)
{
newCv
=
aNewViewer
;
if
(
newCv
)
{
reloadEncoding
=
oldCv
-
>
GetReloadEncodingAndSource
(
&
reloadEncodingSource
)
;
}
}
}
nscolor
bgcolor
=
NS_RGBA
(
0
0
0
0
)
;
bool
isUnderHiddenEmbedderElement
=
false
;
nsCOMPtr
<
nsIContentViewer
>
contentViewer
=
mContentViewer
;
if
(
contentViewer
)
{
contentViewer
-
>
Stop
(
)
;
if
(
PresShell
*
presShell
=
contentViewer
-
>
GetPresShell
(
)
)
{
bgcolor
=
presShell
-
>
GetCanvasBackground
(
)
;
isUnderHiddenEmbedderElement
=
presShell
-
>
IsUnderHiddenEmbedderElement
(
)
;
}
contentViewer
-
>
Close
(
mSavingOldViewer
?
mOSHE
.
get
(
)
:
nullptr
)
;
aNewViewer
-
>
SetPreviousViewer
(
contentViewer
)
;
}
if
(
mOSHE
&
&
(
!
mContentViewer
|
|
!
mSavingOldViewer
)
)
{
mOSHE
-
>
SyncPresentationState
(
)
;
}
mContentViewer
=
nullptr
;
DestroyChildren
(
)
;
mContentViewer
=
aNewViewer
;
nsCOMPtr
<
nsIWidget
>
widget
;
NS_ENSURE_SUCCESS
(
GetMainWidget
(
getter_AddRefs
(
widget
)
)
NS_ERROR_FAILURE
)
;
nsIntRect
bounds
(
x
y
cx
cy
)
;
mContentViewer
-
>
SetNavigationTiming
(
mTiming
)
;
if
(
NS_FAILED
(
mContentViewer
-
>
Init
(
widget
bounds
aWindowActor
)
)
)
{
nsCOMPtr
<
nsIContentViewer
>
viewer
=
mContentViewer
;
viewer
-
>
Close
(
nullptr
)
;
viewer
-
>
Destroy
(
)
;
mContentViewer
=
nullptr
;
mCurrentURI
=
nullptr
;
NS_WARNING
(
"
ContentViewer
Initialization
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
newCv
)
{
newCv
-
>
SetReloadEncodingAndSource
(
reloadEncoding
reloadEncodingSource
)
;
}
NS_ENSURE_TRUE
(
mContentViewer
NS_ERROR_FAILURE
)
;
if
(
RefPtr
<
PresShell
>
presShell
=
mContentViewer
-
>
GetPresShell
(
)
)
{
presShell
-
>
SetCanvasBackground
(
bgcolor
)
;
presShell
-
>
ActivenessMaybeChanged
(
)
;
if
(
isUnderHiddenEmbedderElement
)
{
presShell
-
>
SetIsUnderHiddenEmbedderElement
(
isUnderHiddenEmbedderElement
)
;
}
}
return
NS_OK
;
}
void
nsDocShell
:
:
SetDocCurrentStateObj
(
nsISHEntry
*
aShEntry
SessionHistoryInfo
*
aInfo
)
{
NS_ENSURE_TRUE_VOID
(
mContentViewer
)
;
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
NS_ENSURE_TRUE_VOID
(
document
)
;
nsCOMPtr
<
nsIStructuredCloneContainer
>
scContainer
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
if
(
aInfo
)
{
scContainer
=
aInfo
-
>
GetStateData
(
)
;
}
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
%
p
SetCurrentDocState
%
p
"
this
scContainer
.
get
(
)
)
)
;
}
else
{
if
(
aShEntry
)
{
scContainer
=
aShEntry
-
>
GetStateData
(
)
;
}
}
document
-
>
SetStateObject
(
scContainer
)
;
}
nsresult
nsDocShell
:
:
CheckLoadingPermissions
(
)
{
nsresult
rv
=
NS_OK
;
if
(
!
IsSubframe
(
)
)
{
return
rv
;
}
if
(
!
nsContentUtils
:
:
GetCurrentJSContext
(
)
)
{
return
NS_OK
;
}
for
(
RefPtr
<
BrowsingContext
>
bc
=
mBrowsingContext
;
bc
;
bc
=
bc
-
>
GetParent
(
)
)
{
if
(
!
bc
-
>
IsInProcess
(
)
)
{
continue
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
sgo
=
bc
-
>
GetDocShell
(
)
-
>
GetScriptGlobalObject
(
)
;
nsCOMPtr
<
nsIScriptObjectPrincipal
>
sop
(
do_QueryInterface
(
sgo
)
)
;
nsIPrincipal
*
p
;
if
(
!
sop
|
|
!
(
p
=
sop
-
>
GetPrincipal
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
nsContentUtils
:
:
SubjectPrincipal
(
)
-
>
Subsumes
(
p
)
)
{
return
NS_OK
;
}
}
return
NS_ERROR_DOM_PROP_ACCESS_DENIED
;
}
void
nsDocShell
:
:
CopyFavicon
(
nsIURI
*
aOldURI
nsIURI
*
aNewURI
bool
aInPrivateBrowsing
)
{
if
(
XRE_IsContentProcess
(
)
)
{
dom
:
:
ContentChild
*
contentChild
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
if
(
contentChild
)
{
contentChild
-
>
SendCopyFavicon
(
aOldURI
aNewURI
aInPrivateBrowsing
)
;
}
return
;
}
#
ifdef
MOZ_PLACES
nsCOMPtr
<
nsIFaviconService
>
favSvc
=
do_GetService
(
"
mozilla
.
org
/
browser
/
favicon
-
service
;
1
"
)
;
if
(
favSvc
)
{
favSvc
-
>
CopyFavicons
(
aOldURI
aNewURI
aInPrivateBrowsing
?
nsIFaviconService
:
:
FAVICON_LOAD_PRIVATE
:
nsIFaviconService
:
:
FAVICON_LOAD_NON_PRIVATE
nullptr
)
;
}
#
endif
}
class
InternalLoadEvent
:
public
Runnable
{
public
:
InternalLoadEvent
(
nsDocShell
*
aDocShell
nsDocShellLoadState
*
aLoadState
)
:
mozilla
:
:
Runnable
(
"
InternalLoadEvent
"
)
mDocShell
(
aDocShell
)
mLoadState
(
aLoadState
)
{
mLoadState
-
>
SetTarget
(
u
"
"
_ns
)
;
mLoadState
-
>
SetFileName
(
VoidString
(
)
)
;
}
NS_IMETHOD
Run
(
)
override
{
#
ifndef
ANDROID
MOZ_ASSERT
(
mLoadState
-
>
TriggeringPrincipal
(
)
"
InternalLoadEvent
:
Should
always
have
a
principal
here
"
)
;
#
endif
return
mDocShell
-
>
InternalLoad
(
mLoadState
)
;
}
private
:
RefPtr
<
nsDocShell
>
mDocShell
;
RefPtr
<
nsDocShellLoadState
>
mLoadState
;
}
;
bool
nsDocShell
:
:
JustStartedNetworkLoad
(
)
{
return
mDocumentRequest
&
&
mDocumentRequest
!
=
GetCurrentDocChannel
(
)
;
}
nsContentPolicyType
nsDocShell
:
:
DetermineContentType
(
)
{
if
(
!
IsSubframe
(
)
)
{
return
nsIContentPolicy
:
:
TYPE_DOCUMENT
;
}
const
auto
&
maybeEmbedderElementType
=
GetBrowsingContext
(
)
-
>
GetEmbedderElementType
(
)
;
if
(
!
maybeEmbedderElementType
)
{
return
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
;
}
return
maybeEmbedderElementType
-
>
EqualsLiteral
(
"
iframe
"
)
?
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
:
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME
;
}
bool
nsDocShell
:
:
NoopenerForceEnabled
(
)
{
auto
topPolicy
=
mBrowsingContext
-
>
Top
(
)
-
>
GetOpenerPolicy
(
)
;
return
(
topPolicy
=
=
nsILoadInfo
:
:
OPENER_POLICY_SAME_ORIGIN
|
|
topPolicy
=
=
nsILoadInfo
:
:
OPENER_POLICY_SAME_ORIGIN_EMBEDDER_POLICY_REQUIRE_CORP
)
&
&
!
mBrowsingContext
-
>
SameOriginWithTop
(
)
;
}
nsresult
nsDocShell
:
:
PerformRetargeting
(
nsDocShellLoadState
*
aLoadState
)
{
MOZ_ASSERT
(
aLoadState
"
need
a
load
state
!
"
)
;
MOZ_ASSERT
(
!
aLoadState
-
>
Target
(
)
.
IsEmpty
(
)
"
should
have
a
target
here
!
"
)
;
MOZ_ASSERT
(
aLoadState
-
>
TargetBrowsingContext
(
)
.
IsNull
(
)
"
should
not
have
picked
target
yet
"
)
;
nsresult
rv
=
NS_OK
;
RefPtr
<
BrowsingContext
>
targetContext
;
bool
allowNamedTarget
=
!
aLoadState
-
>
HasInternalLoadFlags
(
INTERNAL_LOAD_FLAGS_NO_OPENER
)
|
|
aLoadState
-
>
HasInternalLoadFlags
(
INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER
)
;
if
(
allowNamedTarget
|
|
aLoadState
-
>
Target
(
)
.
LowerCaseEqualsLiteral
(
"
_self
"
)
|
|
aLoadState
-
>
Target
(
)
.
LowerCaseEqualsLiteral
(
"
_parent
"
)
|
|
aLoadState
-
>
Target
(
)
.
LowerCaseEqualsLiteral
(
"
_top
"
)
)
{
targetContext
=
mBrowsingContext
-
>
FindWithName
(
aLoadState
-
>
Target
(
)
false
)
;
}
if
(
!
targetContext
)
{
nsISupports
*
requestingContext
=
nullptr
;
if
(
XRE_IsContentProcess
(
)
)
{
requestingContext
=
ToSupports
(
mScriptGlobal
)
;
}
else
{
nsCOMPtr
<
Element
>
requestingElement
=
mScriptGlobal
-
>
GetFrameElementInternal
(
)
;
requestingContext
=
requestingElement
;
}
nsCOMPtr
<
nsILoadInfo
>
secCheckLoadInfo
=
new
LoadInfo
(
mScriptGlobal
aLoadState
-
>
URI
(
)
aLoadState
-
>
TriggeringPrincipal
(
)
requestingContext
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
0
)
;
secCheckLoadInfo
-
>
SetSkipContentPolicyCheckForWebRequest
(
true
)
;
int16_t
shouldLoad
=
nsIContentPolicy
:
:
ACCEPT
;
rv
=
NS_CheckContentLoadPolicy
(
aLoadState
-
>
URI
(
)
secCheckLoadInfo
"
"
_ns
&
shouldLoad
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_CP_REJECTED
(
shouldLoad
)
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
shouldLoad
=
=
nsIContentPolicy
:
:
REJECT_TYPE
)
{
return
NS_ERROR_CONTENT_BLOCKED_SHOW_ALT
;
}
if
(
shouldLoad
=
=
nsIContentPolicy
:
:
REJECT_POLICY
)
{
return
NS_ERROR_BLOCKED_BY_POLICY
;
}
}
return
NS_ERROR_CONTENT_BLOCKED
;
}
}
aLoadState
-
>
UnsetInternalLoadFlag
(
INTERNAL_LOAD_FLAGS_INHERIT_PRINCIPAL
)
;
if
(
!
targetContext
)
{
NS_ENSURE_TRUE
(
mContentViewer
NS_ERROR_FAILURE
)
;
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
;
const
bool
isDocumentAuxSandboxed
=
doc
&
&
(
doc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_AUXILIARY_NAVIGATION
)
;
if
(
isDocumentAuxSandboxed
)
{
return
NS_ERROR_DOM_INVALID_ACCESS_ERR
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetWindow
(
)
;
NS_ENSURE_TRUE
(
win
NS_ERROR_NOT_AVAILABLE
)
;
RefPtr
<
BrowsingContext
>
newBC
;
nsAutoCString
spec
;
aLoadState
-
>
URI
(
)
-
>
GetSpec
(
spec
)
;
if
(
aLoadState
-
>
HasInternalLoadFlags
(
INTERNAL_LOAD_FLAGS_NO_OPENER
)
|
|
NoopenerForceEnabled
(
)
)
{
MOZ_ASSERT
(
!
aLoadState
-
>
LoadReplace
(
)
)
;
MOZ_ASSERT
(
aLoadState
-
>
PrincipalToInherit
(
)
=
=
aLoadState
-
>
TriggeringPrincipal
(
)
)
;
MOZ_ASSERT
(
!
(
aLoadState
-
>
InternalLoadFlags
(
)
&
~
(
INTERNAL_LOAD_FLAGS_NO_OPENER
|
INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER
)
)
"
Only
INTERNAL_LOAD_FLAGS_NO_OPENER
and
"
"
INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER
can
be
set
"
)
;
MOZ_ASSERT_IF
(
aLoadState
-
>
PostDataStream
(
)
aLoadState
-
>
IsFormSubmission
(
)
)
;
MOZ_ASSERT
(
!
aLoadState
-
>
HeadersStream
(
)
)
;
MOZ_ASSERT
(
aLoadState
-
>
LoadType
(
)
=
=
LOAD_LINK
|
|
aLoadState
-
>
LoadType
(
)
=
=
LOAD_NORMAL_REPLACE
)
;
MOZ_ASSERT
(
!
aLoadState
-
>
LoadIsFromSessionHistory
(
)
)
;
MOZ_ASSERT
(
aLoadState
-
>
FirstParty
(
)
)
;
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
aLoadState
-
>
URI
(
)
)
;
loadState
-
>
SetReferrerInfo
(
aLoadState
-
>
GetReferrerInfo
(
)
)
;
loadState
-
>
SetOriginalURI
(
aLoadState
-
>
OriginalURI
(
)
)
;
Maybe
<
nsCOMPtr
<
nsIURI
>
>
resultPrincipalURI
;
aLoadState
-
>
GetMaybeResultPrincipalURI
(
resultPrincipalURI
)
;
loadState
-
>
SetMaybeResultPrincipalURI
(
resultPrincipalURI
)
;
loadState
-
>
SetKeepResultPrincipalURIIfSet
(
aLoadState
-
>
KeepResultPrincipalURIIfSet
(
)
)
;
loadState
-
>
SetTriggeringPrincipal
(
aLoadState
-
>
TriggeringPrincipal
(
)
)
;
loadState
-
>
SetTriggeringSandboxFlags
(
aLoadState
-
>
TriggeringSandboxFlags
(
)
)
;
loadState
-
>
SetCsp
(
aLoadState
-
>
Csp
(
)
)
;
loadState
-
>
SetInheritPrincipal
(
aLoadState
-
>
HasInternalLoadFlags
(
INTERNAL_LOAD_FLAGS_INHERIT_PRINCIPAL
)
)
;
loadState
-
>
SetPrincipalIsExplicit
(
true
)
;
loadState
-
>
SetLoadType
(
LOAD_LINK
)
;
loadState
-
>
SetForceAllowDataURI
(
aLoadState
-
>
HasInternalLoadFlags
(
INTERNAL_LOAD_FLAGS_FORCE_ALLOW_DATA_URI
)
)
;
loadState
-
>
SetHasValidUserGestureActivation
(
aLoadState
-
>
HasValidUserGestureActivation
(
)
)
;
loadState
-
>
SetPostDataStream
(
aLoadState
-
>
PostDataStream
(
)
)
;
loadState
-
>
SetIsFormSubmission
(
aLoadState
-
>
IsFormSubmission
(
)
)
;
rv
=
win
-
>
Open
(
NS_ConvertUTF8toUTF16
(
spec
)
aLoadState
-
>
Target
(
)
u
"
"
_ns
loadState
true
getter_AddRefs
(
newBC
)
)
;
MOZ_ASSERT
(
!
newBC
)
;
return
rv
;
}
rv
=
win
-
>
OpenNoNavigate
(
NS_ConvertUTF8toUTF16
(
spec
)
aLoadState
-
>
Target
(
)
u
"
"
_ns
getter_AddRefs
(
newBC
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
piNewWin
=
newBC
?
newBC
-
>
GetDOMWindow
(
)
:
nullptr
;
if
(
piNewWin
)
{
RefPtr
<
Document
>
newDoc
=
piNewWin
-
>
GetExtantDoc
(
)
;
if
(
!
newDoc
|
|
newDoc
-
>
IsInitialDocument
(
)
)
{
aLoadState
-
>
SetInternalLoadFlag
(
INTERNAL_LOAD_FLAGS_FIRST_LOAD
)
;
}
}
if
(
newBC
)
{
targetContext
=
newBC
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
targetContext
rv
)
;
if
(
NS_WARN_IF
(
targetContext
-
>
GetPendingInitialization
(
)
)
)
{
return
NS_OK
;
}
aLoadState
-
>
SetTargetBrowsingContext
(
targetContext
)
;
aLoadState
-
>
SetTarget
(
u
"
"
_ns
)
;
aLoadState
-
>
SetFileName
(
VoidString
(
)
)
;
return
targetContext
-
>
InternalLoad
(
aLoadState
)
;
}
static
nsAutoCString
RefMaybeNull
(
nsIURI
*
aURI
)
{
nsAutoCString
result
;
if
(
NS_FAILED
(
aURI
-
>
GetRef
(
result
)
)
)
{
result
.
SetIsVoid
(
true
)
;
}
return
result
;
}
uint32_t
nsDocShell
:
:
GetSameDocumentNavigationFlags
(
nsIURI
*
aNewURI
)
{
uint32_t
flags
=
LOCATION_CHANGE_SAME_DOCUMENT
;
bool
equal
=
false
;
if
(
mCurrentURI
&
&
NS_SUCCEEDED
(
mCurrentURI
-
>
EqualsExceptRef
(
aNewURI
&
equal
)
)
&
&
equal
&
&
RefMaybeNull
(
mCurrentURI
)
!
=
RefMaybeNull
(
aNewURI
)
)
{
flags
|
=
LOCATION_CHANGE_HASHCHANGE
;
}
return
flags
;
}
bool
nsDocShell
:
:
IsSameDocumentNavigation
(
nsDocShellLoadState
*
aLoadState
SameDocumentNavigationState
&
aState
)
{
MOZ_ASSERT
(
aLoadState
)
;
if
(
!
(
aLoadState
-
>
LoadType
(
)
=
=
LOAD_NORMAL
|
|
aLoadState
-
>
LoadType
(
)
=
=
LOAD_STOP_CONTENT
|
|
LOAD_TYPE_HAS_FLAGS
(
aLoadState
-
>
LoadType
(
)
LOAD_FLAGS_REPLACE_HISTORY
)
|
|
aLoadState
-
>
LoadType
(
)
=
=
LOAD_HISTORY
|
|
aLoadState
-
>
LoadType
(
)
=
=
LOAD_LINK
)
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
currentURI
=
mCurrentURI
;
nsresult
rvURINew
=
aLoadState
-
>
URI
(
)
-
>
GetRef
(
aState
.
mNewHash
)
;
if
(
NS_SUCCEEDED
(
rvURINew
)
)
{
rvURINew
=
aLoadState
-
>
URI
(
)
-
>
GetHasRef
(
&
aState
.
mNewURIHasRef
)
;
}
if
(
currentURI
&
&
NS_SUCCEEDED
(
rvURINew
)
)
{
nsresult
rvURIOld
=
currentURI
-
>
GetRef
(
aState
.
mCurrentHash
)
;
if
(
NS_SUCCEEDED
(
rvURIOld
)
)
{
rvURIOld
=
currentURI
-
>
GetHasRef
(
&
aState
.
mCurrentURIHasRef
)
;
}
if
(
NS_SUCCEEDED
(
rvURIOld
)
)
{
if
(
NS_FAILED
(
currentURI
-
>
EqualsExceptRef
(
aLoadState
-
>
URI
(
)
&
aState
.
mSameExceptHashes
)
)
)
{
aState
.
mSameExceptHashes
=
false
;
}
}
}
if
(
!
aState
.
mSameExceptHashes
&
&
currentURI
&
&
NS_SUCCEEDED
(
rvURINew
)
)
{
nsCOMPtr
<
nsIURI
>
currentExposableURI
=
nsIOService
:
:
CreateExposableURI
(
currentURI
)
;
nsresult
rvURIOld
=
currentExposableURI
-
>
GetRef
(
aState
.
mCurrentHash
)
;
if
(
NS_SUCCEEDED
(
rvURIOld
)
)
{
rvURIOld
=
currentExposableURI
-
>
GetHasRef
(
&
aState
.
mCurrentURIHasRef
)
;
}
if
(
NS_SUCCEEDED
(
rvURIOld
)
)
{
if
(
NS_FAILED
(
currentExposableURI
-
>
EqualsExceptRef
(
aLoadState
-
>
URI
(
)
&
aState
.
mSameExceptHashes
)
)
)
{
aState
.
mSameExceptHashes
=
false
;
}
if
(
!
aState
.
mSameExceptHashes
)
{
nsCOMPtr
<
nsIChannel
>
docChannel
=
GetCurrentDocChannel
(
)
;
if
(
docChannel
)
{
nsCOMPtr
<
nsILoadInfo
>
docLoadInfo
=
docChannel
-
>
LoadInfo
(
)
;
if
(
!
docLoadInfo
-
>
GetLoadErrorPage
(
)
)
{
if
(
nsHTTPSOnlyUtils
:
:
IsEqualURIExceptSchemeAndRef
(
currentExposableURI
aLoadState
-
>
URI
(
)
docLoadInfo
)
)
{
aState
.
mSameExceptHashes
=
true
;
}
}
}
}
}
}
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
if
(
mActiveEntry
&
&
aLoadState
-
>
LoadIsFromSessionHistory
(
)
)
{
aState
.
mHistoryNavBetweenSameDoc
=
mActiveEntry
-
>
SharesDocumentWith
(
aLoadState
-
>
GetLoadingSessionHistoryInfo
(
)
-
>
mInfo
)
;
}
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
:
:
IsSameDocumentNavigation
%
p
NavBetweenSameDoc
=
%
d
"
this
aState
.
mHistoryNavBetweenSameDoc
)
)
;
}
else
{
if
(
mOSHE
&
&
aLoadState
-
>
LoadIsFromSessionHistory
(
)
)
{
mOSHE
-
>
SharesDocumentWith
(
aLoadState
-
>
SHEntry
(
)
&
aState
.
mHistoryNavBetweenSameDoc
)
;
}
}
if
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
{
bool
doSameDocumentNavigation
=
(
aState
.
mHistoryNavBetweenSameDoc
&
&
mOSHE
!
=
aLoadState
-
>
SHEntry
(
)
)
|
|
(
!
aLoadState
-
>
SHEntry
(
)
&
&
!
aLoadState
-
>
PostDataStream
(
)
&
&
aState
.
mSameExceptHashes
&
&
aState
.
mNewURIHasRef
)
;
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
%
p
NavBetweenSameDoc
=
%
d
is
same
doc
=
%
d
"
this
aState
.
mHistoryNavBetweenSameDoc
doSameDocumentNavigation
)
)
;
return
doSameDocumentNavigation
;
}
if
(
aState
.
mHistoryNavBetweenSameDoc
&
&
!
aLoadState
-
>
GetLoadingSessionHistoryInfo
(
)
-
>
mLoadingCurrentEntry
)
{
return
true
;
}
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
:
:
IsSameDocumentNavigation
%
p
!
LoadIsFromSessionHistory
=
%
s
"
"
!
PostDataStream
:
%
s
mSameExceptHashes
:
%
s
mNewURIHasRef
:
%
s
"
this
!
aLoadState
-
>
LoadIsFromSessionHistory
(
)
?
"
true
"
:
"
false
"
!
aLoadState
-
>
PostDataStream
(
)
?
"
true
"
:
"
false
"
aState
.
mSameExceptHashes
?
"
true
"
:
"
false
"
aState
.
mNewURIHasRef
?
"
true
"
:
"
false
"
)
)
;
return
!
aLoadState
-
>
LoadIsFromSessionHistory
(
)
&
&
!
aLoadState
-
>
PostDataStream
(
)
&
&
aState
.
mSameExceptHashes
&
&
aState
.
mNewURIHasRef
;
}
nsresult
nsDocShell
:
:
HandleSameDocumentNavigation
(
nsDocShellLoadState
*
aLoadState
SameDocumentNavigationState
&
aState
)
{
#
ifdef
DEBUG
SameDocumentNavigationState
state
;
MOZ_ASSERT
(
IsSameDocumentNavigation
(
aLoadState
state
)
)
;
#
endif
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
:
:
HandleSameDocumentNavigation
%
p
%
s
-
>
%
s
"
this
mCurrentURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
aLoadState
-
>
URI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
RefPtr
<
Document
>
doc
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
doc
-
>
DoNotifyPossibleTitleChange
(
)
;
nsCOMPtr
<
nsIURI
>
currentURI
=
mCurrentURI
;
nsPoint
scrollPos
=
GetCurScrollPos
(
)
;
AutoRestore
<
uint32_t
>
loadTypeResetter
(
mLoadType
)
;
if
(
JustStartedNetworkLoad
(
)
&
&
(
aLoadState
-
>
LoadType
(
)
&
LOAD_CMD_NORMAL
)
)
{
mLoadType
=
LOAD_NORMAL_REPLACE
;
}
else
{
mLoadType
=
aLoadState
-
>
LoadType
(
)
;
}
mURIResultedInDocument
=
true
;
nsCOMPtr
<
nsISHEntry
>
oldLSHE
=
mLSHE
;
SetHistoryEntryAndUpdateBC
(
Some
<
nsISHEntry
*
>
(
aLoadState
-
>
SHEntry
(
)
)
Nothing
(
)
)
;
UniquePtr
<
mozilla
:
:
dom
:
:
LoadingSessionHistoryInfo
>
oldLoadingEntry
;
mLoadingEntry
.
swap
(
oldLoadingEntry
)
;
if
(
aLoadState
-
>
GetLoadingSessionHistoryInfo
(
)
)
{
mLoadingEntry
=
MakeUnique
<
LoadingSessionHistoryInfo
>
(
*
aLoadState
-
>
GetLoadingSessionHistoryInfo
(
)
)
;
mNeedToReportActiveAfterLoadingBecomesActive
=
false
;
}
doc
-
>
SetDocumentURI
(
aLoadState
-
>
URI
(
)
)
;
nsCOMPtr
<
nsIPrincipal
>
newURITriggeringPrincipal
newURIPrincipalToInherit
newURIPartitionedPrincipalToInherit
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
newCsp
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
?
!
!
mActiveEntry
:
!
!
mOSHE
)
{
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
newURITriggeringPrincipal
=
mActiveEntry
-
>
GetTriggeringPrincipal
(
)
;
newURIPrincipalToInherit
=
mActiveEntry
-
>
GetPrincipalToInherit
(
)
;
newURIPartitionedPrincipalToInherit
=
mActiveEntry
-
>
GetPartitionedPrincipalToInherit
(
)
;
newCsp
=
mActiveEntry
-
>
GetCsp
(
)
;
}
else
{
newURITriggeringPrincipal
=
mOSHE
-
>
GetTriggeringPrincipal
(
)
;
newURIPrincipalToInherit
=
mOSHE
-
>
GetPrincipalToInherit
(
)
;
newURIPartitionedPrincipalToInherit
=
mOSHE
-
>
GetPartitionedPrincipalToInherit
(
)
;
newCsp
=
mOSHE
-
>
GetCsp
(
)
;
}
}
else
{
newURITriggeringPrincipal
=
aLoadState
-
>
TriggeringPrincipal
(
)
;
newURIPrincipalToInherit
=
doc
-
>
NodePrincipal
(
)
;
newURIPartitionedPrincipalToInherit
=
doc
-
>
PartitionedPrincipal
(
)
;
newCsp
=
doc
-
>
GetCsp
(
)
;
}
uint32_t
locationChangeFlags
=
GetSameDocumentNavigationFlags
(
aLoadState
-
>
URI
(
)
)
;
bool
locationChangeNeeded
=
OnNewURI
(
aLoadState
-
>
URI
(
)
nullptr
newURITriggeringPrincipal
newURIPrincipalToInherit
newURIPartitionedPrincipalToInherit
newCsp
false
true
true
)
;
nsCOMPtr
<
nsIInputStream
>
postData
;
uint32_t
cacheKey
=
0
;
bool
scrollRestorationIsManual
=
false
;
if
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
{
if
(
mOSHE
)
{
mOSHE
-
>
SetScrollPosition
(
scrollPos
.
x
scrollPos
.
y
)
;
scrollRestorationIsManual
=
mOSHE
-
>
GetScrollRestorationIsManual
(
)
;
if
(
aLoadState
-
>
LoadType
(
)
&
LOAD_CMD_NORMAL
)
{
postData
=
mOSHE
-
>
GetPostData
(
)
;
cacheKey
=
mOSHE
-
>
GetCacheKey
(
)
;
}
if
(
mLSHE
)
{
if
(
!
aLoadState
-
>
LoadIsFromSessionHistory
(
)
)
{
SetScrollRestorationIsManualOnHistoryEntry
(
mLSHE
scrollRestorationIsManual
)
;
}
mLSHE
-
>
AdoptBFCacheEntry
(
mOSHE
)
;
}
}
}
else
{
if
(
mActiveEntry
)
{
mActiveEntry
-
>
SetScrollPosition
(
scrollPos
.
x
scrollPos
.
y
)
;
if
(
mBrowsingContext
)
{
CollectWireframe
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
SessionHistoryEntry
*
entry
=
mBrowsingContext
-
>
Canonical
(
)
-
>
GetActiveSessionHistoryEntry
(
)
;
if
(
entry
)
{
entry
-
>
SetScrollPosition
(
scrollPos
.
x
scrollPos
.
y
)
;
}
}
else
{
mozilla
:
:
Unused
<
<
ContentChild
:
:
GetSingleton
(
)
-
>
SendSessionHistoryEntryScrollPosition
(
mBrowsingContext
scrollPos
.
x
scrollPos
.
y
)
;
}
}
}
if
(
mLoadingEntry
)
{
if
(
!
mLoadingEntry
-
>
mLoadIsFromSessionHistory
)
{
SetScrollRestorationIsManualOnHistoryEntry
(
nullptr
scrollRestorationIsManual
)
;
}
}
}
if
(
aLoadState
-
>
LoadIsFromSessionHistory
(
)
)
{
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
scrollRestorationIsManual
=
aLoadState
-
>
GetLoadingSessionHistoryInfo
(
)
-
>
mInfo
.
GetScrollRestorationIsManual
(
)
;
}
else
{
scrollRestorationIsManual
=
aLoadState
-
>
SHEntry
(
)
-
>
GetScrollRestorationIsManual
(
)
;
}
}
if
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
{
if
(
mLSHE
)
{
SetHistoryEntryAndUpdateBC
(
Nothing
(
)
Some
<
nsISHEntry
*
>
(
mLSHE
)
)
;
if
(
postData
)
{
mOSHE
-
>
SetPostData
(
postData
)
;
}
if
(
cacheKey
!
=
0
)
{
mOSHE
-
>
SetCacheKey
(
cacheKey
)
;
}
}
SetTitleOnHistoryEntry
(
false
)
;
}
else
{
if
(
aLoadState
-
>
LoadIsFromSessionHistory
(
)
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
Moving
the
loading
entry
to
the
active
entry
on
nsDocShell
%
p
to
"
"
%
s
"
this
mLoadingEntry
-
>
mInfo
.
GetURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
bool
hadActiveEntry
=
!
!
mActiveEntry
;
nsCOMPtr
<
nsILayoutHistoryState
>
currentLayoutHistoryState
;
if
(
mActiveEntry
)
{
currentLayoutHistoryState
=
mActiveEntry
-
>
GetLayoutHistoryState
(
)
;
}
mActiveEntry
=
MakeUnique
<
SessionHistoryInfo
>
(
mLoadingEntry
-
>
mInfo
)
;
if
(
currentLayoutHistoryState
)
{
mActiveEntry
-
>
SetLayoutHistoryState
(
currentLayoutHistoryState
)
;
}
if
(
cacheKey
!
=
0
)
{
mActiveEntry
-
>
SetCacheKey
(
cacheKey
)
;
}
mBrowsingContext
-
>
SessionHistoryCommit
(
*
mLoadingEntry
mLoadType
mCurrentURI
hadActiveEntry
true
true
false
cacheKey
)
;
SetTitleOnHistoryEntry
(
false
)
;
}
else
{
Maybe
<
bool
>
scrollRestorationIsManual
;
if
(
mActiveEntry
)
{
scrollRestorationIsManual
.
emplace
(
mActiveEntry
-
>
GetScrollRestorationIsManual
(
)
)
;
if
(
aLoadState
-
>
LoadType
(
)
&
LOAD_CMD_NORMAL
)
{
postData
=
mActiveEntry
-
>
GetPostData
(
)
;
cacheKey
=
mActiveEntry
-
>
GetCacheKey
(
)
;
}
}
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
Creating
an
active
entry
on
nsDocShell
%
p
to
%
s
"
this
aLoadState
-
>
URI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
if
(
mActiveEntry
)
{
mActiveEntry
=
MakeUnique
<
SessionHistoryInfo
>
(
*
mActiveEntry
aLoadState
-
>
URI
(
)
)
;
}
else
{
mActiveEntry
=
MakeUnique
<
SessionHistoryInfo
>
(
aLoadState
-
>
URI
(
)
newURITriggeringPrincipal
newURIPrincipalToInherit
newURIPartitionedPrincipalToInherit
newCsp
mContentTypeHint
)
;
}
if
(
postData
)
{
mActiveEntry
-
>
SetPostData
(
postData
)
;
}
if
(
cacheKey
!
=
0
)
{
mActiveEntry
-
>
SetCacheKey
(
cacheKey
)
;
}
mActiveEntry
-
>
SetTitle
(
mTitle
)
;
if
(
scrollRestorationIsManual
.
isSome
(
)
)
{
mActiveEntry
-
>
SetScrollRestorationIsManual
(
scrollRestorationIsManual
.
value
(
)
)
;
}
if
(
LOAD_TYPE_HAS_FLAGS
(
mLoadType
LOAD_FLAGS_REPLACE_HISTORY
)
)
{
mBrowsingContext
-
>
ReplaceActiveSessionHistoryEntry
(
mActiveEntry
.
get
(
)
)
;
}
else
{
mBrowsingContext
-
>
IncrementHistoryEntryCountForBrowsingContext
(
)
;
mBrowsingContext
-
>
SetActiveSessionHistoryEntry
(
Some
(
scrollPos
)
mActiveEntry
.
get
(
)
mLoadType
cacheKey
)
;
}
}
}
if
(
locationChangeNeeded
)
{
FireOnLocationChange
(
this
nullptr
aLoadState
-
>
URI
(
)
locationChangeFlags
)
;
}
SetHistoryEntryAndUpdateBC
(
Some
<
nsISHEntry
*
>
(
oldLSHE
)
Nothing
(
)
)
;
mLoadingEntry
.
swap
(
oldLoadingEntry
)
;
UpdateGlobalHistoryTitle
(
aLoadState
-
>
URI
(
)
)
;
SetDocCurrentStateObj
(
mOSHE
mActiveEntry
.
get
(
)
)
;
CopyFavicon
(
currentURI
aLoadState
-
>
URI
(
)
UsePrivateBrowsing
(
)
)
;
RefPtr
<
nsGlobalWindowOuter
>
scriptGlobal
=
mScriptGlobal
;
RefPtr
<
nsGlobalWindowInner
>
win
=
scriptGlobal
?
scriptGlobal
-
>
GetCurrentInnerWindowInternal
(
)
:
nullptr
;
nsresult
rv
=
ScrollToAnchor
(
aState
.
mCurrentURIHasRef
aState
.
mNewURIHasRef
aState
.
mNewHash
aLoadState
-
>
LoadType
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nscoord
bx
=
0
;
nscoord
by
=
0
;
bool
needsScrollPosUpdate
=
false
;
if
(
(
mozilla
:
:
SessionHistoryInParent
(
)
?
!
!
mActiveEntry
:
!
!
mOSHE
)
&
&
(
aLoadState
-
>
LoadType
(
)
=
=
LOAD_HISTORY
|
|
aLoadState
-
>
LoadType
(
)
=
=
LOAD_RELOAD_NORMAL
)
&
&
!
scrollRestorationIsManual
)
{
needsScrollPosUpdate
=
true
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
mActiveEntry
-
>
GetScrollPosition
(
&
bx
&
by
)
;
}
else
{
mOSHE
-
>
GetScrollPosition
(
&
bx
&
by
)
;
}
}
if
(
win
)
{
bool
doHashchange
=
aState
.
mSameExceptHashes
&
&
(
aState
.
mCurrentURIHasRef
!
=
aState
.
mNewURIHasRef
|
|
!
aState
.
mCurrentHash
.
Equals
(
aState
.
mNewHash
)
)
;
if
(
aState
.
mHistoryNavBetweenSameDoc
|
|
doHashchange
)
{
win
-
>
DispatchSyncPopState
(
)
;
}
if
(
needsScrollPosUpdate
&
&
win
-
>
HasActiveDocument
(
)
)
{
SetCurScrollPosEx
(
bx
by
)
;
}
if
(
doHashchange
)
{
win
-
>
DispatchAsyncHashchange
(
currentURI
aLoadState
-
>
URI
(
)
)
;
}
}
return
NS_OK
;
}
static
bool
NavigationShouldTakeFocus
(
nsDocShell
*
aDocShell
nsDocShellLoadState
*
aLoadState
)
{
if
(
!
aLoadState
-
>
AllowFocusMove
(
)
)
{
return
false
;
}
if
(
!
aLoadState
-
>
HasValidUserGestureActivation
(
)
)
{
return
false
;
}
const
auto
&
sourceBC
=
aLoadState
-
>
SourceBrowsingContext
(
)
;
if
(
!
sourceBC
|
|
!
sourceBC
-
>
IsActive
(
)
)
{
return
false
;
}
auto
*
bc
=
aDocShell
-
>
GetBrowsingContext
(
)
;
if
(
sourceBC
.
get
(
)
=
=
bc
)
{
return
false
;
}
auto
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
&
&
bc
-
>
IsActive
(
)
&
&
fm
-
>
IsInActiveWindow
(
bc
)
)
{
return
false
;
}
if
(
auto
*
doc
=
aDocShell
-
>
GetExtantDocument
(
)
)
{
if
(
doc
-
>
IsInitialDocument
(
)
)
{
return
false
;
}
}
return
!
Preferences
:
:
GetBool
(
"
browser
.
tabs
.
loadDivertedInBackground
"
false
)
;
}
nsresult
nsDocShell
:
:
InternalLoad
(
nsDocShellLoadState
*
aLoadState
Maybe
<
uint32_t
>
aCacheKey
)
{
MOZ_ASSERT
(
aLoadState
"
need
a
load
state
!
"
)
;
MOZ_ASSERT
(
aLoadState
-
>
TriggeringPrincipal
(
)
"
need
a
valid
TriggeringPrincipal
"
)
;
if
(
!
aLoadState
-
>
TriggeringPrincipal
(
)
)
{
MOZ_ASSERT
(
false
"
InternalLoad
needs
a
valid
triggeringPrincipal
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
mBrowsingContext
-
>
GetPendingInitialization
(
)
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
const
bool
shouldTakeFocus
=
NavigationShouldTakeFocus
(
this
aLoadState
)
;
mOriginalUriString
.
Truncate
(
)
;
MOZ_LOG
(
gDocShellLeakLog
LogLevel
:
:
Debug
(
"
DOCSHELL
%
p
InternalLoad
%
s
\
n
"
this
aLoadState
-
>
URI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
NS_ENSURE_TRUE
(
IsValidLoadType
(
aLoadState
-
>
LoadType
(
)
)
NS_ERROR_INVALID_ARG
)
;
if
(
mIsBeingDestroyed
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
EnsureScriptEnvironment
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
aLoadState
-
>
Target
(
)
.
IsEmpty
(
)
)
{
return
PerformRetargeting
(
aLoadState
)
;
}
if
(
aLoadState
-
>
TargetBrowsingContext
(
)
.
IsNull
(
)
)
{
aLoadState
-
>
SetTargetBrowsingContext
(
GetBrowsingContext
(
)
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aLoadState
-
>
TargetBrowsingContext
(
)
=
=
GetBrowsingContext
(
)
"
Load
must
be
targeting
this
BrowsingContext
"
)
;
MOZ_TRY
(
CheckDisallowedJavascriptLoad
(
aLoadState
)
)
;
SameDocumentNavigationState
sameDocumentNavigationState
;
bool
sameDocument
=
IsSameDocumentNavigation
(
aLoadState
sameDocumentNavigationState
)
&
&
!
aLoadState
-
>
GetPendingRedirectedChannel
(
)
;
MOZ_TRY
(
mBrowsingContext
-
>
CheckSandboxFlags
(
aLoadState
)
)
;
NS_ENSURE_STATE
(
!
HasUnloadedParent
(
)
)
;
rv
=
CheckLoadingPermissions
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mFiredUnloadEvent
)
{
if
(
IsOKToLoadURI
(
aLoadState
-
>
URI
(
)
)
)
{
MOZ_ASSERT
(
aLoadState
-
>
Target
(
)
.
IsEmpty
(
)
"
Shouldn
'
t
have
a
window
target
here
!
"
)
;
if
(
LOAD_TYPE_HAS_FLAGS
(
aLoadState
-
>
LoadType
(
)
LOAD_FLAGS_REPLACE_HISTORY
)
)
{
mLoadType
=
LOAD_NORMAL_REPLACE
;
}
nsCOMPtr
<
nsIRunnable
>
ev
=
new
InternalLoadEvent
(
this
aLoadState
)
;
return
Dispatch
(
TaskCategory
:
:
Other
ev
.
forget
(
)
)
;
}
return
NS_OK
;
}
{
bool
inherits
;
if
(
!
aLoadState
-
>
HasLoadFlags
(
LOAD_FLAGS_FROM_EXTERNAL
)
&
&
!
aLoadState
-
>
PrincipalToInherit
(
)
&
&
(
aLoadState
-
>
HasInternalLoadFlags
(
INTERNAL_LOAD_FLAGS_INHERIT_PRINCIPAL
)
)
&
&
NS_SUCCEEDED
(
nsContentUtils
:
:
URIInheritsSecurityContext
(
aLoadState
-
>
URI
(
)
&
inherits
)
)
&
&
inherits
)
{
aLoadState
-
>
SetPrincipalToInherit
(
GetInheritedPrincipal
(
true
)
)
;
}
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
=
GetInProcessParentDocshell
(
)
;
if
(
parent
)
{
RefPtr
<
Document
>
doc
=
parent
-
>
GetDocument
(
)
;
if
(
doc
)
{
doc
-
>
TryCancelFrameLoaderInitialization
(
this
)
;
}
}
if
(
aLoadState
-
>
HasLoadFlags
(
LOAD_FLAGS_FROM_EXTERNAL
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aLoadState
-
>
LoadType
(
)
=
=
LOAD_NORMAL
)
;
if
(
SchemeIsChrome
(
aLoadState
-
>
URI
(
)
)
)
{
NS_WARNING
(
"
blocked
external
chrome
:
url
-
-
use
'
-
-
chrome
'
option
"
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
CreateAboutBlankContentViewer
(
nullptr
nullptr
nullptr
nullptr
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
}
mAllowKeywordFixup
=
aLoadState
-
>
HasInternalLoadFlags
(
INTERNAL_LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
)
;
mURIResultedInDocument
=
false
;
if
(
sameDocument
)
{
nsresult
rv
=
HandleSameDocumentNavigation
(
aLoadState
sameDocumentNavigationState
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
shouldTakeFocus
)
{
mBrowsingContext
-
>
Focus
(
CallerType
:
:
System
IgnoreErrors
(
)
)
;
}
return
rv
;
}
nsCOMPtr
<
nsIDocShell
>
kungFuDeathGrip
(
this
)
;
bool
toBeReset
=
false
;
bool
isJavaScript
=
SchemeIsJavascript
(
aLoadState
-
>
URI
(
)
)
;
if
(
!
isJavaScript
)
{
toBeReset
=
MaybeInitTiming
(
)
;
}
bool
isNotDownload
=
aLoadState
-
>
FileName
(
)
.
IsVoid
(
)
;
if
(
mTiming
&
&
isNotDownload
)
{
mTiming
-
>
NotifyBeforeUnload
(
)
;
}
if
(
!
isJavaScript
&
&
isNotDownload
&
&
!
aLoadState
-
>
NotifiedBeforeUnloadListeners
(
)
&
&
mContentViewer
)
{
bool
okToUnload
;
bool
isPrivateWin
=
GetOriginAttributes
(
)
.
mPrivateBrowsingId
>
0
;
bool
isHistoryOrReload
=
false
;
uint32_t
loadType
=
aLoadState
-
>
LoadType
(
)
;
if
(
loadType
=
=
LOAD_RELOAD_NORMAL
|
|
loadType
=
=
LOAD_RELOAD_BYPASS_CACHE
|
|
loadType
=
=
LOAD_RELOAD_BYPASS_PROXY
|
|
loadType
=
=
LOAD_RELOAD_BYPASS_PROXY_AND_CACHE
|
|
loadType
=
=
LOAD_HISTORY
)
{
isHistoryOrReload
=
true
;
}
if
(
!
isHistoryOrReload
&
&
aLoadState
-
>
IsExemptFromHTTPSOnlyMode
(
)
&
&
nsHTTPSOnlyUtils
:
:
IsHttpsFirstModeEnabled
(
isPrivateWin
)
)
{
rv
=
mContentViewer
-
>
PermitUnload
(
nsIContentViewer
:
:
PermitUnloadAction
:
:
eDontPromptAndUnload
&
okToUnload
)
;
}
else
{
rv
=
mContentViewer
-
>
PermitUnload
(
&
okToUnload
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
okToUnload
)
{
MaybeResetInitTiming
(
toBeReset
)
;
return
NS_OK
;
}
}
if
(
mTiming
&
&
isNotDownload
)
{
mTiming
-
>
NotifyUnloadAccepted
(
mCurrentURI
)
;
}
if
(
XRE_IsE10sParentProcess
(
)
&
&
!
DocumentChannel
:
:
CanUseDocumentChannel
(
aLoadState
-
>
URI
(
)
)
&
&
!
CanLoadInParentProcess
(
aLoadState
-
>
URI
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mBrowsingContext
-
>
GetOrientationLock
(
)
!
=
hal
:
:
ScreenOrientation
:
:
None
)
{
MOZ_ASSERT
(
mBrowsingContext
-
>
IsTop
(
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
mBrowsingContext
-
>
SetOrientationLock
(
hal
:
:
ScreenOrientation
:
:
None
)
)
;
if
(
mBrowsingContext
-
>
IsActive
(
)
)
{
ScreenOrientation
:
:
UpdateActiveOrientationLock
(
hal
:
:
ScreenOrientation
:
:
None
)
;
}
}
bool
savePresentation
=
CanSavePresentation
(
aLoadState
-
>
LoadType
(
)
nullptr
nullptr
true
)
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
Document
*
document
=
GetDocument
(
)
;
uint32_t
flags
=
0
;
if
(
document
&
&
!
document
-
>
CanSavePresentation
(
nullptr
flags
true
)
)
{
document
-
>
DisallowBFCaching
(
flags
)
;
}
}
if
(
!
isJavaScript
&
&
isNotDownload
)
{
if
(
(
mContentViewer
&
&
mContentViewer
-
>
GetPreviousViewer
(
)
)
|
|
LOAD_TYPE_HAS_FLAGS
(
aLoadState
-
>
LoadType
(
)
LOAD_FLAGS_STOP_CONTENT
)
)
{
rv
=
Stop
(
nsIWebNavigation
:
:
STOP_ALL
)
;
}
else
{
rv
=
Stop
(
nsIWebNavigation
:
:
STOP_NETWORK
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
mLoadType
=
aLoadState
-
>
LoadType
(
)
;
if
(
mLoadType
!
=
LOAD_ERROR_PAGE
)
{
SetHistoryEntryAndUpdateBC
(
Some
<
nsISHEntry
*
>
(
aLoadState
-
>
SHEntry
(
)
)
Nothing
(
)
)
;
if
(
aLoadState
-
>
LoadIsFromSessionHistory
(
)
&
&
!
mozilla
:
:
SessionHistoryInParent
(
)
)
{
nsID
historyID
=
{
}
;
aLoadState
-
>
SHEntry
(
)
-
>
GetDocshellID
(
historyID
)
;
Unused
<
<
mBrowsingContext
-
>
SetHistoryID
(
historyID
)
;
}
}
mSavingOldViewer
=
savePresentation
;
if
(
aLoadState
-
>
LoadIsFromSessionHistory
(
)
&
&
(
mLoadType
&
LOAD_CMD_HISTORY
)
)
{
RefPtr
<
ChildSHistory
>
shistory
=
GetRootSessionHistory
(
)
;
if
(
shistory
)
{
shistory
-
>
RemovePendingHistoryNavigations
(
)
;
}
if
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
{
if
(
mContentViewer
)
{
nsCOMPtr
<
nsIContentViewer
>
prevViewer
=
mContentViewer
-
>
GetPreviousViewer
(
)
;
if
(
prevViewer
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIContentViewer
>
prevPrevViewer
=
prevViewer
-
>
GetPreviousViewer
(
)
;
NS_ASSERTION
(
!
prevPrevViewer
"
Should
never
have
viewer
chain
here
"
)
;
#
endif
nsCOMPtr
<
nsISHEntry
>
viewerEntry
;
prevViewer
-
>
GetHistoryEntry
(
getter_AddRefs
(
viewerEntry
)
)
;
if
(
viewerEntry
=
=
aLoadState
-
>
SHEntry
(
)
)
{
mContentViewer
-
>
SetPreviousViewer
(
nullptr
)
;
prevViewer
-
>
Destroy
(
)
;
}
}
}
nsCOMPtr
<
nsISHEntry
>
oldEntry
=
mOSHE
;
bool
restoring
;
rv
=
RestorePresentation
(
aLoadState
-
>
SHEntry
(
)
&
restoring
)
;
if
(
restoring
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BFCACHE_PAGE_RESTORED
true
)
;
return
rv
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BFCACHE_PAGE_RESTORED
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
oldEntry
)
{
oldEntry
-
>
SyncPresentationState
(
)
;
}
aLoadState
-
>
SHEntry
(
)
-
>
SyncPresentationState
(
)
;
}
}
}
bool
isTopLevelDoc
=
mBrowsingContext
-
>
IsTopContent
(
)
;
OriginAttributes
attrs
=
GetOriginAttributes
(
)
;
attrs
.
SetFirstPartyDomain
(
isTopLevelDoc
aLoadState
-
>
URI
(
)
)
;
PredictorLearn
(
aLoadState
-
>
URI
(
)
nullptr
nsINetworkPredictor
:
:
LEARN_LOAD_TOPLEVEL
attrs
)
;
PredictorPredict
(
aLoadState
-
>
URI
(
)
nullptr
nsINetworkPredictor
:
:
PREDICT_LOAD
attrs
nullptr
)
;
nsCOMPtr
<
nsIRequest
>
req
;
rv
=
DoURILoad
(
aLoadState
aCacheKey
getter_AddRefs
(
req
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
shouldTakeFocus
)
{
mBrowsingContext
-
>
Focus
(
CallerType
:
:
System
IgnoreErrors
(
)
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
nsCOMPtr
<
nsIChannel
>
chan
(
do_QueryInterface
(
req
)
)
;
UnblockEmbedderLoadEventForFailure
(
)
;
if
(
DisplayLoadError
(
rv
aLoadState
-
>
URI
(
)
nullptr
chan
)
&
&
aLoadState
-
>
HasLoadFlags
(
LOAD_FLAGS_ERROR_LOAD_CHANGES_RV
)
)
{
return
NS_ERROR_LOAD_SHOWED_ERRORPAGE
;
}
if
(
NS_ERROR_UNKNOWN_PROTOCOL
=
=
rv
)
{
return
NS_OK
;
}
}
return
rv
;
}
bool
nsDocShell
:
:
CanLoadInParentProcess
(
nsIURI
*
aURI
)
{
nsCOMPtr
<
nsIURI
>
uri
=
aURI
;
bool
canLoadInParent
=
false
;
if
(
NS_SUCCEEDED
(
NS_URIChainHasFlags
(
uri
nsIProtocolHandler
:
:
URI_IS_UI_RESOURCE
&
canLoadInParent
)
)
&
&
canLoadInParent
)
{
return
true
;
}
while
(
uri
&
&
uri
-
>
SchemeIs
(
"
view
-
source
"
)
)
{
nsCOMPtr
<
nsINestedURI
>
nested
=
do_QueryInterface
(
uri
)
;
if
(
nested
)
{
nested
-
>
GetInnerURI
(
getter_AddRefs
(
uri
)
)
;
}
else
{
break
;
}
}
if
(
!
uri
|
|
uri
-
>
SchemeIs
(
"
about
"
)
|
|
(
!
StaticPrefs
:
:
extensions_webextensions_remote
(
)
&
&
uri
-
>
SchemeIs
(
"
moz
-
extension
"
)
)
)
{
return
true
;
}
#
ifdef
MOZ_THUNDERBIRD
if
(
uri
-
>
SchemeIs
(
"
imap
"
)
|
|
uri
-
>
SchemeIs
(
"
mailbox
"
)
|
|
uri
-
>
SchemeIs
(
"
news
"
)
|
|
uri
-
>
SchemeIs
(
"
nntp
"
)
|
|
uri
-
>
SchemeIs
(
"
snews
"
)
)
{
return
true
;
}
#
endif
nsAutoCString
scheme
;
uri
-
>
GetScheme
(
scheme
)
;
if
(
StringBeginsWith
(
scheme
"
ext
+
"
_ns
)
&
&
!
StaticPrefs
:
:
extensions_webextensions_remote
(
)
)
{
return
true
;
}
if
(
xpc
:
:
IsInAutomation
(
)
&
&
StaticPrefs
:
:
security_allow_unsafe_parent_loads
(
)
)
{
return
true
;
}
return
false
;
}
nsIPrincipal
*
nsDocShell
:
:
GetInheritedPrincipal
(
bool
aConsiderCurrentDocument
bool
aConsiderPartitionedPrincipal
)
{
RefPtr
<
Document
>
document
;
bool
inheritedFromCurrent
=
false
;
if
(
aConsiderCurrentDocument
&
&
mContentViewer
)
{
document
=
mContentViewer
-
>
GetDocument
(
)
;
inheritedFromCurrent
=
true
;
}
if
(
!
document
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parentItem
;
GetInProcessSameTypeParent
(
getter_AddRefs
(
parentItem
)
)
;
if
(
parentItem
)
{
document
=
parentItem
-
>
GetDocument
(
)
;
}
}
if
(
!
document
)
{
if
(
!
aConsiderCurrentDocument
)
{
return
nullptr
;
}
EnsureContentViewer
(
)
;
if
(
!
mContentViewer
)
{
return
nullptr
;
}
document
=
mContentViewer
-
>
GetDocument
(
)
;
}
if
(
document
)
{
nsIPrincipal
*
docPrincipal
=
aConsiderPartitionedPrincipal
?
document
-
>
PartitionedPrincipal
(
)
:
document
-
>
NodePrincipal
(
)
;
if
(
inheritedFromCurrent
&
&
mItemType
=
=
typeContent
&
&
docPrincipal
-
>
IsSystemPrincipal
(
)
)
{
return
nullptr
;
}
return
docPrincipal
;
}
return
nullptr
;
}
nsresult
nsDocShell
:
:
CreateRealChannelForDocument
(
nsIChannel
*
*
aChannel
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
nsIInterfaceRequestor
*
aCallbacks
nsLoadFlags
aLoadFlags
const
nsAString
&
aSrcdoc
nsIURI
*
aBaseURI
)
{
nsCOMPtr
<
nsIChannel
>
channel
;
if
(
aSrcdoc
.
IsVoid
(
)
)
{
MOZ_TRY
(
NS_NewChannelInternal
(
getter_AddRefs
(
channel
)
aURI
aLoadInfo
nullptr
nullptr
aCallbacks
aLoadFlags
)
)
;
if
(
aBaseURI
)
{
nsCOMPtr
<
nsIViewSourceChannel
>
vsc
=
do_QueryInterface
(
channel
)
;
if
(
vsc
)
{
MOZ_ALWAYS_SUCCEEDS
(
vsc
-
>
SetBaseURI
(
aBaseURI
)
)
;
}
}
}
else
if
(
SchemeIsViewSource
(
aURI
)
)
{
nsCOMPtr
<
nsIIOService
>
io
(
do_GetIOService
(
)
)
;
MOZ_ASSERT
(
io
)
;
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
nsresult
rv
=
io
-
>
GetProtocolHandler
(
"
view
-
source
"
getter_AddRefs
(
handler
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsViewSourceHandler
*
vsh
=
nsViewSourceHandler
:
:
GetInstance
(
)
;
if
(
!
vsh
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_TRY
(
vsh
-
>
NewSrcdocChannel
(
aURI
aBaseURI
aSrcdoc
aLoadInfo
getter_AddRefs
(
channel
)
)
)
;
}
else
{
MOZ_TRY
(
NS_NewInputStreamChannelInternal
(
getter_AddRefs
(
channel
)
aURI
aSrcdoc
"
text
/
html
"
_ns
aLoadInfo
true
)
)
;
nsCOMPtr
<
nsIInputStreamChannel
>
isc
=
do_QueryInterface
(
channel
)
;
MOZ_ASSERT
(
isc
)
;
isc
-
>
SetBaseURI
(
aBaseURI
)
;
}
if
(
aLoadFlags
!
=
nsIRequest
:
:
LOAD_NORMAL
)
{
nsresult
rv
=
channel
-
>
SetLoadFlags
(
aLoadFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
channel
.
forget
(
aChannel
)
;
return
NS_OK
;
}
bool
nsDocShell
:
:
CreateAndConfigureRealChannelForLoadState
(
BrowsingContext
*
aBrowsingContext
nsDocShellLoadState
*
aLoadState
LoadInfo
*
aLoadInfo
nsIInterfaceRequestor
*
aCallbacks
nsDocShell
*
aDocShell
const
OriginAttributes
&
aOriginAttributes
nsLoadFlags
aLoadFlags
uint32_t
aCacheKey
nsresult
&
aRv
nsIChannel
*
*
aChannel
)
{
MOZ_ASSERT
(
aLoadInfo
)
;
nsString
srcdoc
=
VoidString
(
)
;
bool
isSrcdoc
=
aLoadState
-
>
HasInternalLoadFlags
(
INTERNAL_LOAD_FLAGS_IS_SRCDOC
)
;
if
(
isSrcdoc
)
{
srcdoc
=
aLoadState
-
>
SrcdocData
(
)
;
}
aLoadInfo
-
>
SetTriggeringRemoteType
(
aLoadState
-
>
GetEffectiveTriggeringRemoteType
(
)
)
;
if
(
aLoadState
-
>
PrincipalToInherit
(
)
)
{
aLoadInfo
-
>
SetPrincipalToInherit
(
aLoadState
-
>
PrincipalToInherit
(
)
)
;
}
aLoadInfo
-
>
SetLoadTriggeredFromExternal
(
aLoadState
-
>
HasLoadFlags
(
LOAD_FLAGS_FROM_EXTERNAL
)
)
;
aLoadInfo
-
>
SetForceAllowDataURI
(
aLoadState
-
>
HasInternalLoadFlags
(
INTERNAL_LOAD_FLAGS_FORCE_ALLOW_DATA_URI
)
)
;
aLoadInfo
-
>
SetOriginalFrameSrcLoad
(
aLoadState
-
>
HasInternalLoadFlags
(
INTERNAL_LOAD_FLAGS_ORIGINAL_FRAME_SRC
)
)
;
bool
inheritAttrs
=
false
;
if
(
aLoadState
-
>
PrincipalToInherit
(
)
)
{
inheritAttrs
=
nsContentUtils
:
:
ChannelShouldInheritPrincipal
(
aLoadState
-
>
PrincipalToInherit
(
)
aLoadState
-
>
URI
(
)
true
isSrcdoc
)
;
}
aLoadState
-
>
MaybeStripTrackerQueryStrings
(
aBrowsingContext
)
;
OriginAttributes
attrs
;
if
(
inheritAttrs
)
{
MOZ_ASSERT
(
aLoadState
-
>
PrincipalToInherit
(
)
"
We
should
have
PrincipalToInherit
here
.
"
)
;
attrs
=
aLoadState
-
>
PrincipalToInherit
(
)
-
>
OriginAttributesRef
(
)
;
MOZ_ASSERT_IF
(
!
OriginAttributes
:
:
IsFirstPartyEnabled
(
)
attrs
=
=
aOriginAttributes
)
;
}
else
{
attrs
=
aOriginAttributes
;
attrs
.
SetFirstPartyDomain
(
IsTopLevelDoc
(
aBrowsingContext
aLoadInfo
)
aLoadState
-
>
URI
(
)
)
;
}
aRv
=
aLoadInfo
-
>
SetOriginAttributes
(
attrs
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aRv
)
)
)
{
return
false
;
}
if
(
aLoadState
-
>
GetIsFromProcessingFrameAttributes
(
)
)
{
aLoadInfo
-
>
SetIsFromProcessingFrameAttributes
(
)
;
}
if
(
aLoadState
-
>
IsFormSubmission
(
)
)
{
aLoadInfo
-
>
SetIsFormSubmission
(
true
)
;
}
aLoadInfo
-
>
SetUnstrippedURI
(
aLoadState
-
>
GetUnstrippedURI
(
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
aRv
=
CreateRealChannelForDocument
(
getter_AddRefs
(
channel
)
aLoadState
-
>
URI
(
)
aLoadInfo
aCallbacks
aLoadFlags
srcdoc
aLoadState
-
>
BaseURI
(
)
)
;
NS_ENSURE_SUCCESS
(
aRv
false
)
;
if
(
!
channel
)
{
return
false
;
}
nsHTTPSOnlyUtils
:
:
TestSitePermissionAndPotentiallyAddExemption
(
channel
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
channel
)
)
;
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChannelInternal
(
do_QueryInterface
(
channel
)
)
;
nsCOMPtr
<
nsIURI
>
referrer
;
nsIReferrerInfo
*
referrerInfo
=
aLoadState
-
>
GetReferrerInfo
(
)
;
if
(
referrerInfo
)
{
referrerInfo
-
>
GetOriginalReferrer
(
getter_AddRefs
(
referrer
)
)
;
}
if
(
httpChannelInternal
)
{
if
(
aLoadState
-
>
HasInternalLoadFlags
(
INTERNAL_LOAD_FLAGS_FORCE_ALLOW_COOKIES
)
)
{
aRv
=
httpChannelInternal
-
>
SetThirdPartyFlags
(
nsIHttpChannelInternal
:
:
THIRD_PARTY_FORCE_ALLOW
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aRv
)
)
;
}
if
(
aLoadState
-
>
FirstParty
(
)
)
{
aRv
=
httpChannelInternal
-
>
SetDocumentURI
(
aLoadState
-
>
URI
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aRv
)
)
;
}
else
{
aRv
=
httpChannelInternal
-
>
SetDocumentURI
(
referrer
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aRv
)
)
;
}
aRv
=
httpChannelInternal
-
>
SetRedirectMode
(
nsIHttpChannelInternal
:
:
REDIRECT_MODE_MANUAL
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aRv
)
)
;
}
if
(
httpChannel
)
{
if
(
aLoadState
-
>
HeadersStream
(
)
)
{
aRv
=
AddHeadersToChannel
(
aLoadState
-
>
HeadersStream
(
)
httpChannel
)
;
}
if
(
referrerInfo
)
{
aRv
=
httpChannel
-
>
SetReferrerInfo
(
referrerInfo
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aRv
)
)
;
}
if
(
IsUrgentStart
(
aBrowsingContext
aLoadInfo
aLoadState
-
>
LoadType
(
)
)
)
{
nsCOMPtr
<
nsIClassOfService
>
cos
(
do_QueryInterface
(
channel
)
)
;
if
(
cos
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
UrgentStart
)
;
}
}
}
channel
-
>
SetOriginalURI
(
aLoadState
-
>
OriginalURI
(
)
?
aLoadState
-
>
OriginalURI
(
)
:
aLoadState
-
>
URI
(
)
)
;
const
nsACString
&
typeHint
=
aLoadState
-
>
TypeHint
(
)
;
if
(
!
typeHint
.
IsVoid
(
)
)
{
channel
-
>
SetContentType
(
typeHint
)
;
}
const
nsAString
&
fileName
=
aLoadState
-
>
FileName
(
)
;
if
(
!
fileName
.
IsVoid
(
)
)
{
aRv
=
channel
-
>
SetContentDisposition
(
nsIChannel
:
:
DISPOSITION_ATTACHMENT
)
;
NS_ENSURE_SUCCESS
(
aRv
false
)
;
if
(
!
fileName
.
IsEmpty
(
)
)
{
aRv
=
channel
-
>
SetContentDispositionFilename
(
fileName
)
;
NS_ENSURE_SUCCESS
(
aRv
false
)
;
}
}
if
(
nsCOMPtr
<
nsIWritablePropertyBag2
>
props
=
do_QueryInterface
(
channel
)
)
{
nsCOMPtr
<
nsIURI
>
referrer
;
nsIReferrerInfo
*
referrerInfo
=
aLoadState
-
>
GetReferrerInfo
(
)
;
if
(
referrerInfo
)
{
referrerInfo
-
>
GetOriginalReferrer
(
getter_AddRefs
(
referrer
)
)
;
}
props
-
>
SetPropertyAsInterface
(
u
"
docshell
.
internalReferrer
"
_ns
referrer
)
;
if
(
aLoadState
-
>
HasInternalLoadFlags
(
INTERNAL_LOAD_FLAGS_FIRST_LOAD
)
)
{
props
-
>
SetPropertyAsBool
(
u
"
docshell
.
newWindowTarget
"
_ns
true
)
;
}
}
nsCOMPtr
<
nsICacheInfoChannel
>
cacheChannel
(
do_QueryInterface
(
channel
)
)
;
auto
loadType
=
aLoadState
-
>
LoadType
(
)
;
if
(
loadType
=
=
LOAD_RELOAD_NORMAL
&
&
StaticPrefs
:
:
browser_soft_reload_only_force_validate_top_level_document
(
)
)
{
nsCOMPtr
<
nsICacheInfoChannel
>
cachingChannel
=
do_QueryInterface
(
channel
)
;
if
(
cachingChannel
)
{
cachingChannel
-
>
SetForceValidateCacheContent
(
true
)
;
}
}
if
(
aLoadState
-
>
PostDataStream
(
)
)
{
if
(
nsCOMPtr
<
nsIFormPOSTActionChannel
>
postChannel
=
do_QueryInterface
(
channel
)
)
{
nsCOMPtr
<
nsISeekableStream
>
postDataSeekable
=
do_QueryInterface
(
aLoadState
-
>
PostDataStream
(
)
)
;
if
(
postDataSeekable
)
{
aRv
=
postDataSeekable
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
0
)
;
NS_ENSURE_SUCCESS
(
aRv
false
)
;
}
postChannel
-
>
SetUploadStream
(
aLoadState
-
>
PostDataStream
(
)
"
"
_ns
-
1
)
;
aLoadState
-
>
SetPostDataStream
(
nullptr
)
;
}
if
(
cacheChannel
&
&
aCacheKey
!
=
0
)
{
if
(
loadType
=
=
LOAD_HISTORY
|
|
loadType
=
=
LOAD_RELOAD_CHARSET_CHANGE
)
{
cacheChannel
-
>
SetCacheKey
(
aCacheKey
)
;
uint32_t
loadFlags
;
if
(
NS_SUCCEEDED
(
channel
-
>
GetLoadFlags
(
&
loadFlags
)
)
)
{
channel
-
>
SetLoadFlags
(
loadFlags
|
nsICachingChannel
:
:
LOAD_ONLY_FROM_CACHE
)
;
}
}
else
if
(
loadType
=
=
LOAD_RELOAD_NORMAL
)
{
cacheChannel
-
>
SetCacheKey
(
aCacheKey
)
;
}
}
}
else
{
if
(
loadType
=
=
LOAD_HISTORY
|
|
loadType
=
=
LOAD_RELOAD_NORMAL
|
|
loadType
=
=
LOAD_RELOAD_CHARSET_CHANGE
|
|
loadType
=
=
LOAD_RELOAD_CHARSET_CHANGE_BYPASS_CACHE
|
|
loadType
=
=
LOAD_RELOAD_CHARSET_CHANGE_BYPASS_PROXY_AND_CACHE
)
{
if
(
cacheChannel
&
&
aCacheKey
!
=
0
)
{
cacheChannel
-
>
SetCacheKey
(
aCacheKey
)
;
}
}
}
if
(
nsCOMPtr
<
nsIScriptChannel
>
scriptChannel
=
do_QueryInterface
(
channel
)
)
{
scriptChannel
-
>
SetExecutionPolicy
(
nsIScriptChannel
:
:
EXECUTE_NORMAL
)
;
}
if
(
nsCOMPtr
<
nsITimedChannel
>
timedChannel
=
do_QueryInterface
(
channel
)
)
{
timedChannel
-
>
SetTimingEnabled
(
true
)
;
nsString
initiatorType
;
switch
(
aLoadInfo
-
>
InternalContentPolicyType
(
)
)
{
case
nsIContentPolicy
:
:
TYPE_INTERNAL_EMBED
:
initiatorType
=
u
"
embed
"
_ns
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_OBJECT
:
initiatorType
=
u
"
object
"
_ns
;
break
;
default
:
{
const
auto
&
embedderElementType
=
aBrowsingContext
-
>
GetEmbedderElementType
(
)
;
if
(
embedderElementType
)
{
initiatorType
=
*
embedderElementType
;
}
break
;
}
}
if
(
!
initiatorType
.
IsEmpty
(
)
)
{
timedChannel
-
>
SetInitiatorType
(
initiatorType
)
;
}
}
nsCOMPtr
<
nsIURI
>
rpURI
;
aLoadInfo
-
>
GetResultPrincipalURI
(
getter_AddRefs
(
rpURI
)
)
;
Maybe
<
nsCOMPtr
<
nsIURI
>
>
originalResultPrincipalURI
;
aLoadState
-
>
GetMaybeResultPrincipalURI
(
originalResultPrincipalURI
)
;
if
(
originalResultPrincipalURI
&
&
(
!
aLoadState
-
>
KeepResultPrincipalURIIfSet
(
)
|
|
!
rpURI
)
)
{
aLoadInfo
-
>
SetResultPrincipalURI
(
originalResultPrincipalURI
.
ref
(
)
)
;
}
if
(
aLoadState
-
>
OriginalURI
(
)
&
&
aLoadState
-
>
LoadReplace
(
)
)
{
uint32_t
loadFlags
;
aRv
=
channel
-
>
GetLoadFlags
(
&
loadFlags
)
;
NS_ENSURE_SUCCESS
(
aRv
false
)
;
channel
-
>
SetLoadFlags
(
loadFlags
|
nsIChannel
:
:
LOAD_REPLACE
)
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aLoadState
-
>
Csp
(
)
;
if
(
csp
)
{
bool
upgradeInsecureRequests
=
false
;
csp
-
>
GetUpgradeInsecureRequests
(
&
upgradeInsecureRequests
)
;
if
(
upgradeInsecureRequests
)
{
nsCOMPtr
<
nsIPrincipal
>
resultPrincipal
;
aRv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
channel
getter_AddRefs
(
resultPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
aRv
false
)
;
if
(
nsContentSecurityUtils
:
:
IsConsideredSameOriginForUIR
(
aLoadState
-
>
TriggeringPrincipal
(
)
resultPrincipal
)
)
{
aLoadInfo
-
>
SetUpgradeInsecureRequests
(
true
)
;
}
}
RefPtr
<
nsCSPContext
>
cspToInherit
=
new
nsCSPContext
(
)
;
cspToInherit
-
>
InitFromOther
(
static_cast
<
nsCSPContext
*
>
(
csp
.
get
(
)
)
)
;
aLoadInfo
-
>
SetCSPToInherit
(
cspToInherit
)
;
}
channel
.
forget
(
aChannel
)
;
return
true
;
}
bool
nsDocShell
:
:
IsAboutBlankLoadOntoInitialAboutBlank
(
nsIURI
*
aURI
bool
aInheritPrincipal
nsIPrincipal
*
aPrincipalToInherit
)
{
return
NS_IsAboutBlank
(
aURI
)
&
&
aInheritPrincipal
&
&
(
aPrincipalToInherit
=
=
GetInheritedPrincipal
(
false
)
)
&
&
(
!
mContentViewer
|
|
!
mContentViewer
-
>
GetDocument
(
)
|
|
mContentViewer
-
>
GetDocument
(
)
-
>
IsInitialDocument
(
)
)
;
}
nsresult
nsDocShell
:
:
DoURILoad
(
nsDocShellLoadState
*
aLoadState
Maybe
<
uint32_t
>
aCacheKey
nsIRequest
*
*
aRequest
)
{
if
(
mIsBeingDestroyed
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIURILoader
>
uriLoader
=
components
:
:
URILoader
:
:
Service
(
)
;
if
(
NS_WARN_IF
(
!
uriLoader
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
PersistLayoutHistoryState
(
)
;
SynchronizeLayoutHistoryState
(
)
;
nsresult
rv
;
nsContentPolicyType
contentPolicyType
=
DetermineContentType
(
)
;
if
(
IsSubframe
(
)
)
{
MOZ_ASSERT
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
|
|
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME
"
DoURILoad
thinks
this
is
a
frame
and
InternalLoad
does
not
"
)
;
if
(
StaticPrefs
:
:
dom_block_external_protocol_in_iframes
(
)
)
{
bool
doesNotReturnData
=
false
;
NS_URIChainHasFlags
(
aLoadState
-
>
URI
(
)
nsIProtocolHandler
:
:
URI_DOES_NOT_RETURN_DATA
&
doesNotReturnData
)
;
if
(
doesNotReturnData
)
{
WindowContext
*
sourceWindowContext
=
[
&
]
{
const
MaybeDiscardedBrowsingContext
&
sourceBC
=
aLoadState
-
>
SourceBrowsingContext
(
)
;
if
(
!
sourceBC
.
IsNullOrDiscarded
(
)
)
{
if
(
WindowContext
*
wc
=
sourceBC
.
get
(
)
-
>
GetCurrentWindowContext
(
)
)
{
return
wc
;
}
}
return
mBrowsingContext
-
>
GetParentWindowContext
(
)
;
}
(
)
;
MOZ_ASSERT
(
sourceWindowContext
)
;
WindowContext
*
context
=
sourceWindowContext
-
>
IsInProcess
(
)
?
sourceWindowContext
:
mBrowsingContext
-
>
GetCurrentWindowContext
(
)
;
const
bool
popupBlocked
=
[
&
]
{
const
bool
active
=
mBrowsingContext
-
>
IsActive
(
)
;
const
bool
hasFreePass
=
[
&
]
{
if
(
!
active
|
|
!
(
context
-
>
IsInProcess
(
)
&
&
context
-
>
SameOriginWithTop
(
)
)
)
{
return
false
;
}
nsGlobalWindowInner
*
win
=
context
-
>
TopWindowContext
(
)
-
>
GetInnerWindow
(
)
;
return
win
&
&
win
-
>
TryOpenExternalProtocolIframe
(
)
;
}
(
)
;
if
(
context
-
>
IsInProcess
(
)
&
&
context
-
>
ConsumeTransientUserGestureActivation
(
)
)
{
return
false
;
}
if
(
active
&
&
PopupBlocker
:
:
ConsumeTimerTokenForExternalProtocolIframe
(
)
)
{
return
false
;
}
if
(
sourceWindowContext
-
>
CanShowPopup
(
)
)
{
return
false
;
}
if
(
hasFreePass
)
{
return
false
;
}
return
true
;
}
(
)
;
if
(
popupBlocked
)
{
nsAutoString
message
;
nsresult
rv
=
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
ExternalProtocolFrameBlockedNoUserActivation
"
message
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsContentUtils
:
:
ReportToConsoleByWindowID
(
message
nsIScriptError
:
:
warningFlag
"
DOM
"
_ns
context
-
>
InnerWindowId
(
)
)
;
}
return
NS_OK
;
}
}
}
nsCOMPtr
<
nsIURI
>
tempURI
=
aLoadState
-
>
URI
(
)
;
nsCOMPtr
<
nsINestedURI
>
nestedURI
=
do_QueryInterface
(
tempURI
)
;
while
(
nestedURI
)
{
if
(
SchemeIsViewSource
(
tempURI
)
)
{
return
NS_ERROR_UNKNOWN_PROTOCOL
;
}
nestedURI
-
>
GetInnerURI
(
getter_AddRefs
(
tempURI
)
)
;
nestedURI
=
do_QueryInterface
(
tempURI
)
;
}
}
else
{
MOZ_ASSERT
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
"
DoURILoad
thinks
this
is
a
document
and
InternalLoad
does
not
"
)
;
}
bool
inheritPrincipal
=
false
;
if
(
aLoadState
-
>
PrincipalToInherit
(
)
)
{
bool
isSrcdoc
=
aLoadState
-
>
HasInternalLoadFlags
(
INTERNAL_LOAD_FLAGS_IS_SRCDOC
)
;
bool
inheritAttrs
=
nsContentUtils
:
:
ChannelShouldInheritPrincipal
(
aLoadState
-
>
PrincipalToInherit
(
)
aLoadState
-
>
URI
(
)
true
isSrcdoc
)
;
inheritPrincipal
=
inheritAttrs
&
&
!
SchemeIsData
(
aLoadState
-
>
URI
(
)
)
;
}
const
bool
isAboutBlankLoadOntoInitialAboutBlank
=
IsAboutBlankLoadOntoInitialAboutBlank
(
aLoadState
-
>
URI
(
)
inheritPrincipal
aLoadState
-
>
PrincipalToInherit
(
)
)
;
if
(
aLoadState
-
>
GetLoadingSessionHistoryInfo
(
)
)
{
SetLoadingSessionHistoryInfo
(
*
aLoadState
-
>
GetLoadingSessionHistoryInfo
(
)
)
;
}
else
if
(
isAboutBlankLoadOntoInitialAboutBlank
&
&
mozilla
:
:
SessionHistoryInParent
(
)
)
{
UniquePtr
<
SessionHistoryInfo
>
entry
=
MakeUnique
<
SessionHistoryInfo
>
(
aLoadState
-
>
URI
(
)
aLoadState
-
>
TriggeringPrincipal
(
)
aLoadState
-
>
PrincipalToInherit
(
)
aLoadState
-
>
PartitionedPrincipalToInherit
(
)
aLoadState
-
>
Csp
(
)
mContentTypeHint
)
;
mozilla
:
:
dom
:
:
LoadingSessionHistoryInfo
info
(
*
entry
)
;
SetLoadingSessionHistoryInfo
(
info
true
)
;
}
if
(
nsCOMPtr
<
nsIChannel
>
channel
=
aLoadState
-
>
GetPendingRedirectedChannel
(
)
)
{
if
(
aRequest
)
{
nsCOMPtr
<
nsIRequest
>
outRequest
=
channel
;
outRequest
.
forget
(
aRequest
)
;
}
return
OpenRedirectedChannel
(
aLoadState
)
;
}
nsCOMPtr
<
nsINode
>
loadingNode
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
loadingWindow
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
;
nsCOMPtr
<
nsISupports
>
topLevelLoadingContext
;
if
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
)
{
loadingNode
=
nullptr
;
loadingPrincipal
=
nullptr
;
loadingWindow
=
mScriptGlobal
;
if
(
XRE_IsContentProcess
(
)
)
{
nsCOMPtr
<
nsIBrowserChild
>
browserChild
=
GetBrowserChild
(
)
;
topLevelLoadingContext
=
ToSupports
(
browserChild
)
;
}
else
{
nsCOMPtr
<
Element
>
requestingElement
=
loadingWindow
-
>
GetFrameElementInternal
(
)
;
topLevelLoadingContext
=
requestingElement
;
}
}
else
{
loadingWindow
=
nullptr
;
loadingNode
=
mScriptGlobal
-
>
GetFrameElementInternal
(
)
;
if
(
loadingNode
)
{
loadingPrincipal
=
loadingNode
-
>
NodePrincipal
(
)
;
#
ifdef
DEBUG
RefPtr
<
Document
>
requestingDoc
=
loadingNode
-
>
OwnerDoc
(
)
;
nsCOMPtr
<
nsIDocShell
>
elementDocShell
=
requestingDoc
-
>
GetDocShell
(
)
;
MOZ_ASSERT
(
mItemType
=
=
elementDocShell
-
>
ItemType
(
)
"
subframes
should
have
the
same
docshell
type
as
their
parent
"
)
;
#
endif
}
else
{
if
(
mIsBeingDestroyed
)
{
return
NS_OK
;
}
loadingPrincipal
=
NullPrincipal
:
:
Create
(
GetOriginAttributes
(
)
nullptr
)
;
}
}
if
(
!
aLoadState
-
>
TriggeringPrincipal
(
)
)
{
MOZ_ASSERT
(
false
"
DoURILoad
needs
a
valid
triggeringPrincipal
"
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
sandboxFlags
=
mBrowsingContext
-
>
GetSandboxFlags
(
)
;
nsSecurityFlags
securityFlags
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
;
if
(
mLoadType
=
=
LOAD_ERROR_PAGE
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_LOAD_ERROR_PAGE
;
}
if
(
inheritPrincipal
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_FORCE_INHERIT_PRINCIPAL
;
}
MOZ_ASSERT_IF
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
!
mBrowsingContext
-
>
GetParent
(
)
)
;
MOZ_ASSERT_IF
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
mBrowsingContext
-
>
GetParent
(
)
)
;
mBrowsingContext
-
>
SetTriggeringAndInheritPrincipals
(
aLoadState
-
>
TriggeringPrincipal
(
)
aLoadState
-
>
PrincipalToInherit
(
)
aLoadState
-
>
GetLoadIdentifier
(
)
)
;
RefPtr
<
LoadInfo
>
loadInfo
=
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
)
?
new
LoadInfo
(
loadingWindow
aLoadState
-
>
URI
(
)
aLoadState
-
>
TriggeringPrincipal
(
)
topLevelLoadingContext
securityFlags
sandboxFlags
)
:
new
LoadInfo
(
loadingPrincipal
aLoadState
-
>
TriggeringPrincipal
(
)
loadingNode
securityFlags
contentPolicyType
Maybe
<
mozilla
:
:
dom
:
:
ClientInfo
>
(
)
Maybe
<
mozilla
:
:
dom
:
:
ServiceWorkerDescriptor
>
(
)
sandboxFlags
)
;
RefPtr
<
WindowContext
>
context
=
mBrowsingContext
-
>
GetCurrentWindowContext
(
)
;
if
(
isAboutBlankLoadOntoInitialAboutBlank
)
{
BrowsingContext
*
top
=
mBrowsingContext
-
>
Top
(
)
;
if
(
top
=
=
mBrowsingContext
)
{
loadInfo
-
>
SetIsThirdPartyContextToTopWindow
(
false
)
;
}
else
{
if
(
Document
*
topDoc
=
top
-
>
GetDocument
(
)
)
{
bool
thirdParty
=
false
;
mozilla
:
:
Unused
<
<
topDoc
-
>
GetPrincipal
(
)
-
>
IsThirdPartyPrincipal
(
aLoadState
-
>
PrincipalToInherit
(
)
&
thirdParty
)
;
loadInfo
-
>
SetIsThirdPartyContextToTopWindow
(
thirdParty
)
;
}
else
{
loadInfo
-
>
SetIsThirdPartyContextToTopWindow
(
true
)
;
}
}
}
if
(
mLoadType
!
=
LOAD_ERROR_PAGE
&
&
context
&
&
context
-
>
IsInProcess
(
)
&
&
context
-
>
HasValidTransientUserGestureActivation
(
)
)
{
aLoadState
-
>
SetHasValidUserGestureActivation
(
true
)
;
}
if
(
aLoadState
-
>
HasValidUserGestureActivation
(
)
|
|
aLoadState
-
>
HasLoadFlags
(
LOAD_FLAGS_FROM_EXTERNAL
)
)
{
loadInfo
-
>
SetHasValidUserGestureActivation
(
true
)
;
}
loadInfo
-
>
SetTriggeringSandboxFlags
(
aLoadState
-
>
TriggeringSandboxFlags
(
)
)
;
loadInfo
-
>
SetIsMetaRefresh
(
aLoadState
-
>
IsMetaRefresh
(
)
)
;
uint32_t
cacheKey
=
0
;
if
(
aCacheKey
)
{
cacheKey
=
*
aCacheKey
;
}
else
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
if
(
mLoadingEntry
)
{
cacheKey
=
mLoadingEntry
-
>
mInfo
.
GetCacheKey
(
)
;
}
else
if
(
mActiveEntry
)
{
cacheKey
=
mActiveEntry
-
>
GetCacheKey
(
)
;
}
}
else
{
if
(
mLSHE
)
{
cacheKey
=
mLSHE
-
>
GetCacheKey
(
)
;
}
else
if
(
mOSHE
)
{
cacheKey
=
mOSHE
-
>
GetCacheKey
(
)
;
}
}
bool
uriModified
;
if
(
mLSHE
|
|
mLoadingEntry
)
{
if
(
mLoadingEntry
)
{
uriModified
=
mLoadingEntry
-
>
mInfo
.
GetURIWasModified
(
)
;
}
else
{
uriModified
=
mLSHE
-
>
GetURIWasModified
(
)
;
}
}
else
{
uriModified
=
false
;
}
bool
isXFOError
=
false
;
if
(
mFailedChannel
)
{
nsresult
status
;
mFailedChannel
-
>
GetStatus
(
&
status
)
;
isXFOError
=
status
=
=
NS_ERROR_XFO_VIOLATION
;
}
nsLoadFlags
loadFlags
=
aLoadState
-
>
CalculateChannelLoadFlags
(
mBrowsingContext
Some
(
uriModified
)
Some
(
isXFOError
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
if
(
DocumentChannel
:
:
CanUseDocumentChannel
(
aLoadState
-
>
URI
(
)
)
&
&
!
isAboutBlankLoadOntoInitialAboutBlank
)
{
channel
=
DocumentChannel
:
:
CreateForDocument
(
aLoadState
loadInfo
loadFlags
this
cacheKey
uriModified
isXFOError
)
;
MOZ_ASSERT
(
channel
)
;
mAllowKeywordFixup
=
false
;
}
else
if
(
!
CreateAndConfigureRealChannelForLoadState
(
mBrowsingContext
aLoadState
loadInfo
this
this
GetOriginAttributes
(
)
loadFlags
cacheKey
rv
getter_AddRefs
(
channel
)
)
)
{
return
rv
;
}
if
(
aRequest
)
{
NS_ADDREF
(
*
aRequest
=
channel
)
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aLoadState
-
>
Csp
(
)
;
if
(
csp
)
{
bool
allowsNavigateTo
=
false
;
rv
=
csp
-
>
GetAllowsNavigateTo
(
aLoadState
-
>
URI
(
)
aLoadState
-
>
IsFormSubmission
(
)
false
false
&
allowsNavigateTo
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
allowsNavigateTo
)
{
return
NS_ERROR_CSP_NAVIGATE_TO_VIOLATION
;
}
}
const
nsACString
&
typeHint
=
aLoadState
-
>
TypeHint
(
)
;
if
(
!
typeHint
.
IsVoid
(
)
)
{
mContentTypeHint
=
typeHint
;
}
else
{
mContentTypeHint
.
Truncate
(
)
;
}
if
(
mLoadType
=
=
LOAD_RELOAD_CHARSET_CHANGE
)
{
nsCOMPtr
<
nsICacheInfoChannel
>
cachingChannel
=
do_QueryInterface
(
channel
)
;
if
(
cachingChannel
)
{
cachingChannel
-
>
SetAllowStaleCacheContent
(
true
)
;
}
}
uint32_t
openFlags
=
nsDocShell
:
:
ComputeURILoaderFlags
(
mBrowsingContext
mLoadType
)
;
return
OpenInitializedChannel
(
channel
uriLoader
openFlags
)
;
}
static
nsresult
AppendSegmentToString
(
nsIInputStream
*
aIn
void
*
aClosure
const
char
*
aFromRawSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
aWriteCount
)
{
nsAutoCString
*
buf
=
static_cast
<
nsAutoCString
*
>
(
aClosure
)
;
buf
-
>
Append
(
aFromRawSegment
aCount
)
;
*
aWriteCount
=
aCount
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
AddHeadersToChannel
(
nsIInputStream
*
aHeadersData
nsIChannel
*
aGenericChannel
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aGenericChannel
)
;
NS_ENSURE_STATE
(
httpChannel
)
;
uint32_t
numRead
;
nsAutoCString
headersString
;
nsresult
rv
=
aHeadersData
-
>
ReadSegments
(
AppendSegmentToString
&
headersString
UINT32_MAX
&
numRead
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
headerName
;
nsAutoCString
headerValue
;
int32_t
crlf
;
int32_t
colon
;
static
const
char
kWhitespace
[
]
=
"
\
b
\
t
\
r
\
n
"
;
while
(
true
)
{
crlf
=
headersString
.
Find
(
"
\
r
\
n
"
)
;
if
(
crlf
=
=
kNotFound
)
{
return
NS_OK
;
}
const
nsACString
&
oneHeader
=
StringHead
(
headersString
crlf
)
;
colon
=
oneHeader
.
FindChar
(
'
:
'
)
;
if
(
colon
=
=
kNotFound
)
{
return
NS_ERROR_UNEXPECTED
;
}
headerName
=
StringHead
(
oneHeader
colon
)
;
headerValue
=
Substring
(
oneHeader
colon
+
1
)
;
headerName
.
Trim
(
kWhitespace
)
;
headerValue
.
Trim
(
kWhitespace
)
;
headersString
.
Cut
(
0
crlf
+
2
)
;
rv
=
httpChannel
-
>
SetRequestHeader
(
headerName
headerValue
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
oops
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
uint32_t
nsDocShell
:
:
ComputeURILoaderFlags
(
BrowsingContext
*
aBrowsingContext
uint32_t
aLoadType
)
{
MOZ_ASSERT
(
aBrowsingContext
)
;
uint32_t
openFlags
=
0
;
if
(
aLoadType
=
=
LOAD_LINK
)
{
openFlags
|
=
nsIURILoader
:
:
IS_CONTENT_PREFERRED
;
}
if
(
!
aBrowsingContext
-
>
GetAllowContentRetargeting
(
)
)
{
openFlags
|
=
nsIURILoader
:
:
DONT_RETARGET
;
}
return
openFlags
;
}
nsresult
nsDocShell
:
:
OpenInitializedChannel
(
nsIChannel
*
aChannel
nsIURILoader
*
aURILoader
uint32_t
aOpenFlags
)
{
nsresult
rv
=
NS_OK
;
auto
cleanupInitialClient
=
MakeScopeExit
(
[
&
]
{
mInitialClientSource
.
reset
(
)
;
}
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetWindow
(
)
;
NS_ENSURE_TRUE
(
win
NS_ERROR_FAILURE
)
;
MaybeCreateInitialClientSource
(
)
;
RefPtr
<
net
:
:
DocumentChannel
>
docChannel
=
do_QueryObject
(
aChannel
)
;
if
(
docChannel
&
&
XRE_IsContentProcess
(
)
)
{
aOpenFlags
|
=
nsIURILoader
:
:
DONT_RETARGET
;
}
Maybe
<
ClientInfo
>
noReservedClient
;
if
(
docChannel
)
{
rv
=
AddClientChannelHelperInChild
(
aChannel
win
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
docChannel
-
>
SetInitialClientInfo
(
GetInitialClientInfo
(
)
)
;
}
else
{
rv
=
AddClientChannelHelper
(
aChannel
std
:
:
move
(
noReservedClient
)
GetInitialClientInfo
(
)
win
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aURILoader
-
>
OpenURI
(
aChannel
aOpenFlags
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsJSContext
:
:
MaybeRunNextCollectorSlice
(
this
JS
:
:
GCReason
:
:
DOCSHELL
)
;
cleanupInitialClient
.
release
(
)
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
OpenRedirectedChannel
(
nsDocShellLoadState
*
aLoadState
)
{
nsCOMPtr
<
nsIChannel
>
channel
=
aLoadState
-
>
GetPendingRedirectedChannel
(
)
;
MOZ_ASSERT
(
channel
)
;
auto
cleanupInitialClient
=
MakeScopeExit
(
[
&
]
{
mInitialClientSource
.
reset
(
)
;
}
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetWindow
(
)
;
NS_ENSURE_TRUE
(
win
NS_ERROR_FAILURE
)
;
MaybeCreateInitialClientSource
(
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
LoadInfo
*
li
=
static_cast
<
LoadInfo
*
>
(
loadInfo
.
get
(
)
)
;
if
(
loadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
ExtContentPolicy
:
:
TYPE_DOCUMENT
)
{
li
-
>
UpdateBrowsingContextID
(
mBrowsingContext
-
>
Id
(
)
)
;
}
else
if
(
loadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
ExtContentPolicy
:
:
TYPE_SUBDOCUMENT
)
{
li
-
>
UpdateFrameBrowsingContextID
(
mBrowsingContext
-
>
Id
(
)
)
;
}
CreateReservedSourceIfNeeded
(
channel
win
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
RefPtr
<
nsDocumentOpenInfo
>
loader
=
new
nsDocumentOpenInfo
(
this
nsIURILoader
:
:
DONT_RETARGET
nullptr
)
;
channel
-
>
SetLoadGroup
(
mLoadGroup
)
;
MOZ_ALWAYS_SUCCEEDS
(
loader
-
>
Prepare
(
)
)
;
nsresult
rv
=
NS_OK
;
if
(
XRE_IsParentProcess
(
)
)
{
RefPtr
<
ParentChannelWrapper
>
wrapper
=
new
ParentChannelWrapper
(
channel
loader
)
;
wrapper
-
>
Register
(
aLoadState
-
>
GetPendingRedirectChannelRegistrarId
(
)
)
;
mLoadGroup
-
>
AddRequest
(
channel
nullptr
)
;
}
else
if
(
nsCOMPtr
<
nsIChildChannel
>
childChannel
=
do_QueryInterface
(
channel
)
)
{
rv
=
childChannel
-
>
CompleteRedirectSetup
(
loader
)
;
}
else
{
rv
=
channel
-
>
AsyncOpen
(
loader
)
;
}
if
(
rv
=
=
NS_ERROR_NO_CONTENT
)
{
return
NS_OK
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
cleanupInitialClient
.
release
(
)
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
ScrollToAnchor
(
bool
aCurHasRef
bool
aNewHasRef
nsACString
&
aNewHash
uint32_t
aLoadType
)
{
if
(
!
mCurrentURI
)
{
return
NS_OK
;
}
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
NS_OK
;
}
nsIScrollableFrame
*
rootScroll
=
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
rootScroll
)
{
rootScroll
-
>
ClearDidHistoryRestore
(
)
;
}
if
(
(
!
aCurHasRef
|
|
aLoadType
!
=
LOAD_HISTORY
)
&
&
!
aNewHasRef
)
{
return
NS_OK
;
}
if
(
!
aNewHash
.
IsEmpty
(
)
)
{
bool
scroll
=
aLoadType
!
=
LOAD_HISTORY
&
&
aLoadType
!
=
LOAD_RELOAD_NORMAL
;
nsresult
rv
=
NS_ERROR_FAILURE
;
NS_ConvertUTF8toUTF16
uStr
(
aNewHash
)
;
if
(
!
uStr
.
IsEmpty
(
)
)
{
rv
=
presShell
-
>
GoToAnchor
(
uStr
scroll
ScrollFlags
:
:
ScrollSmoothAuto
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
char
*
str
=
ToNewCString
(
aNewHash
mozilla
:
:
fallible
)
;
if
(
!
str
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsUnescape
(
str
)
;
NS_ConvertUTF8toUTF16
utf16Str
(
str
)
;
if
(
!
utf16Str
.
IsEmpty
(
)
)
{
rv
=
presShell
-
>
GoToAnchor
(
utf16Str
scroll
ScrollFlags
:
:
ScrollSmoothAuto
)
;
}
free
(
str
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_ENSURE_TRUE
(
mContentViewer
NS_ERROR_FAILURE
)
;
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
nsAutoCString
charset
;
doc
-
>
GetDocumentCharacterSet
(
)
-
>
Name
(
charset
)
;
nsCOMPtr
<
nsITextToSubURI
>
textToSubURI
=
do_GetService
(
NS_ITEXTTOSUBURI_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
uStr
;
rv
=
textToSubURI
-
>
UnEscapeAndConvert
(
charset
aNewHash
uStr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
presShell
-
>
GoToAnchor
(
uStr
scroll
&
&
!
uStr
.
IsEmpty
(
)
ScrollFlags
:
:
ScrollSmoothAuto
)
;
}
}
else
{
presShell
-
>
GoToAnchor
(
u
"
"
_ns
false
)
;
if
(
aLoadType
=
=
LOAD_HISTORY
|
|
aLoadType
=
=
LOAD_RELOAD_NORMAL
)
{
return
NS_OK
;
}
SetCurScrollPosEx
(
0
0
)
;
}
return
NS_OK
;
}
bool
nsDocShell
:
:
OnNewURI
(
nsIURI
*
aURI
nsIChannel
*
aChannel
nsIPrincipal
*
aTriggeringPrincipal
nsIPrincipal
*
aPrincipalToInherit
nsIPrincipal
*
aPartitionedPrincipalToInherit
nsIContentSecurityPolicy
*
aCsp
bool
aFireOnLocationChange
bool
aAddToGlobalHistory
bool
aCloneSHChildren
)
{
MOZ_ASSERT
(
aURI
"
uri
is
null
"
)
;
MOZ_ASSERT
(
!
aChannel
|
|
!
aTriggeringPrincipal
"
Shouldn
'
t
have
both
set
"
)
;
MOZ_ASSERT
(
!
aPrincipalToInherit
|
|
(
aPrincipalToInherit
&
&
aTriggeringPrincipal
)
)
;
#
if
defined
(
DEBUG
)
if
(
MOZ_LOG_TEST
(
gDocShellLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
chanName
;
if
(
aChannel
)
{
aChannel
-
>
GetName
(
chanName
)
;
}
else
{
chanName
.
AssignLiteral
(
"
<
no
channel
>
"
)
;
}
MOZ_LOG
(
gDocShellLog
LogLevel
:
:
Debug
(
"
nsDocShell
[
%
p
]
:
:
OnNewURI
(
\
"
%
s
\
"
[
%
s
]
0x
%
x
)
\
n
"
this
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
chanName
.
get
(
)
mLoadType
)
)
;
}
#
endif
bool
equalUri
=
false
;
uint32_t
responseStatus
=
0
;
nsCOMPtr
<
nsIInputStream
>
inputStream
;
if
(
aChannel
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aChannel
)
)
;
if
(
!
httpChannel
)
{
GetHttpChannel
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
}
if
(
httpChannel
)
{
nsCOMPtr
<
nsIUploadChannel
>
uploadChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
uploadChannel
)
{
uploadChannel
-
>
GetUploadStream
(
getter_AddRefs
(
inputStream
)
)
;
}
nsresult
rv
=
httpChannel
-
>
GetResponseStatus
(
&
responseStatus
)
;
if
(
mLSHE
&
&
NS_SUCCEEDED
(
rv
)
&
&
responseStatus
>
=
400
)
{
mLSHE
-
>
AbandonBFCacheEntry
(
)
;
}
}
}
bool
updateGHistory
=
ShouldUpdateGlobalHistory
(
mLoadType
)
;
bool
updateSHistory
=
mBrowsingContext
-
>
ShouldUpdateSessionHistory
(
mLoadType
)
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
!
rootSH
)
{
updateSHistory
=
false
;
updateGHistory
=
false
;
}
if
(
mCurrentURI
)
{
aURI
-
>
Equals
(
mCurrentURI
&
equalUri
)
;
}
#
ifdef
DEBUG
bool
shAvailable
=
(
rootSH
!
=
nullptr
)
;
MOZ_LOG
(
gDocShellLog
LogLevel
:
:
Debug
(
"
shAvailable
=
%
i
updateSHistory
=
%
i
updateGHistory
=
%
i
"
"
equalURI
=
%
i
\
n
"
shAvailable
updateSHistory
updateGHistory
equalUri
)
)
;
#
endif
if
(
equalUri
&
&
(
mozilla
:
:
SessionHistoryInParent
(
)
?
!
!
mActiveEntry
:
!
!
mOSHE
)
&
&
(
mLoadType
=
=
LOAD_NORMAL
|
|
mLoadType
=
=
LOAD_LINK
|
|
mLoadType
=
=
LOAD_STOP_CONTENT
)
&
&
!
inputStream
)
{
mLoadType
=
LOAD_NORMAL_REPLACE
;
}
if
(
mLoadType
=
=
LOAD_REFRESH
&
&
!
inputStream
&
&
equalUri
)
{
SetHistoryEntryAndUpdateBC
(
Some
<
nsISHEntry
*
>
(
mOSHE
)
Nothing
(
)
)
;
}
if
(
aChannel
&
&
IsForceReloadType
(
mLoadType
)
)
{
MOZ_ASSERT
(
!
updateSHistory
|
|
IsSubframe
(
)
"
We
shouldn
'
t
be
updating
session
history
for
forced
"
"
reloads
unless
we
'
re
in
a
newly
created
iframe
!
"
)
;
nsCOMPtr
<
nsICacheInfoChannel
>
cacheChannel
(
do_QueryInterface
(
aChannel
)
)
;
uint32_t
cacheKey
=
0
;
if
(
cacheChannel
)
{
cacheChannel
-
>
GetCacheKey
(
&
cacheKey
)
;
}
SetCacheKeyOnHistoryEntry
(
mLSHE
?
mLSHE
:
mOSHE
cacheKey
)
;
if
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
{
ClearFrameHistory
(
mLSHE
)
;
ClearFrameHistory
(
mOSHE
)
;
}
}
if
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
{
if
(
mLoadType
=
=
LOAD_REFRESH
)
{
ClearFrameHistory
(
mLSHE
)
;
ClearFrameHistory
(
mOSHE
)
;
}
if
(
updateSHistory
)
{
if
(
!
mLSHE
&
&
(
mItemType
=
=
typeContent
)
&
&
mURIResultedInDocument
)
{
(
void
)
AddToSessionHistory
(
aURI
aChannel
aTriggeringPrincipal
aPrincipalToInherit
aPartitionedPrincipalToInherit
aCsp
aCloneSHChildren
getter_AddRefs
(
mLSHE
)
)
;
}
}
else
if
(
GetSessionHistory
(
)
&
&
mLSHE
&
&
mURIResultedInDocument
)
{
GetSessionHistory
(
)
-
>
LegacySHistory
(
)
-
>
EnsureCorrectEntryAtCurrIndex
(
mLSHE
)
;
}
}
if
(
ShouldAddURIVisit
(
aChannel
)
&
&
updateGHistory
&
&
aAddToGlobalHistory
&
&
!
net
:
:
ChannelIsPost
(
aChannel
)
)
{
nsCOMPtr
<
nsIURI
>
previousURI
;
uint32_t
previousFlags
=
0
;
if
(
mLoadType
&
LOAD_CMD_RELOAD
)
{
previousURI
=
aURI
;
}
else
{
ExtractLastVisit
(
aChannel
getter_AddRefs
(
previousURI
)
&
previousFlags
)
;
}
AddURIVisit
(
aURI
previousURI
previousFlags
responseStatus
)
;
}
if
(
!
mozilla
:
:
SessionHistoryInParent
(
)
&
&
rootSH
&
&
(
(
mLoadType
&
(
LOAD_CMD_HISTORY
|
LOAD_CMD_RELOAD
)
)
|
|
mLoadType
=
=
LOAD_NORMAL_REPLACE
|
|
mLoadType
=
=
LOAD_REFRESH_REPLACE
)
)
{
mPreviousEntryIndex
=
rootSH
-
>
Index
(
)
;
if
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
{
rootSH
-
>
LegacySHistory
(
)
-
>
UpdateIndex
(
)
;
}
mLoadedEntryIndex
=
rootSH
-
>
Index
(
)
;
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Verbose
(
"
Previous
index
:
%
d
Loaded
index
:
%
d
"
mPreviousEntryIndex
mLoadedEntryIndex
)
)
;
}
uint32_t
locationFlags
=
aCloneSHChildren
?
uint32_t
(
LOCATION_CHANGE_SAME_DOCUMENT
)
:
0
;
bool
onLocationChangeNeeded
=
SetCurrentURI
(
aURI
aChannel
aFireOnLocationChange
false
locationFlags
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aChannel
)
)
;
if
(
httpChannel
)
{
mReferrerInfo
=
httpChannel
-
>
GetReferrerInfo
(
)
;
}
return
onLocationChangeNeeded
;
}
Maybe
<
Wireframe
>
nsDocShell
:
:
GetWireframe
(
)
{
const
bool
collectWireFrame
=
mozilla
:
:
SessionHistoryInParent
(
)
&
&
StaticPrefs
:
:
browser_history_collectWireframes
(
)
&
&
mBrowsingContext
-
>
IsTopContent
(
)
&
&
mActiveEntry
;
if
(
!
collectWireFrame
)
{
return
Nothing
(
)
;
}
RefPtr
<
Document
>
doc
=
mContentViewer
-
>
GetDocument
(
)
;
Nullable
<
Wireframe
>
wireframe
;
doc
-
>
GetWireframeWithoutFlushing
(
false
wireframe
)
;
if
(
wireframe
.
IsNull
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
wireframe
.
Value
(
)
)
;
}
bool
nsDocShell
:
:
CollectWireframe
(
)
{
Maybe
<
Wireframe
>
wireframe
=
GetWireframe
(
)
;
if
(
wireframe
.
isNothing
(
)
)
{
return
false
;
}
if
(
XRE_IsParentProcess
(
)
)
{
SessionHistoryEntry
*
entry
=
mBrowsingContext
-
>
Canonical
(
)
-
>
GetActiveSessionHistoryEntry
(
)
;
if
(
entry
)
{
entry
-
>
SetWireframe
(
wireframe
)
;
}
}
else
{
mozilla
:
:
Unused
<
<
ContentChild
:
:
GetSingleton
(
)
-
>
SendSessionHistoryEntryWireframe
(
mBrowsingContext
wireframe
.
ref
(
)
)
;
}
return
true
;
}
NS_IMETHODIMP
nsDocShell
:
:
AddState
(
JS
:
:
Handle
<
JS
:
:
Value
>
aData
const
nsAString
&
aTitle
const
nsAString
&
aURL
bool
aReplace
JSContext
*
aCx
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
[
%
p
]
:
AddState
(
.
.
.
%
s
%
s
%
d
)
"
this
NS_ConvertUTF16toUTF8
(
aTitle
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aURL
)
.
get
(
)
aReplace
)
)
;
nsresult
rv
;
AutoRestore
<
uint32_t
>
loadTypeResetter
(
mLoadType
)
;
if
(
JustStartedNetworkLoad
(
)
)
{
aReplace
=
true
;
}
RefPtr
<
Document
>
document
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
document
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIStructuredCloneContainer
>
scContainer
;
{
RefPtr
<
Document
>
origDocument
=
GetDocument
(
)
;
if
(
!
origDocument
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
nsCOMPtr
<
nsIPrincipal
>
origPrincipal
=
origDocument
-
>
NodePrincipal
(
)
;
scContainer
=
new
nsStructuredCloneContainer
(
)
;
rv
=
scContainer
-
>
InitFromJSVal
(
aData
aCx
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
Document
>
newDocument
=
GetDocument
(
)
;
if
(
!
newDocument
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
nsCOMPtr
<
nsIPrincipal
>
newPrincipal
=
newDocument
-
>
NodePrincipal
(
)
;
bool
principalsEqual
=
false
;
origPrincipal
-
>
Equals
(
newPrincipal
&
principalsEqual
)
;
NS_ENSURE_TRUE
(
principalsEqual
NS_ERROR_DOM_SECURITY_ERR
)
;
}
int32_t
maxStateObjSize
=
StaticPrefs
:
:
browser_history_maxStateObjectSize
(
)
;
if
(
maxStateObjSize
<
0
)
{
maxStateObjSize
=
0
;
}
uint64_t
scSize
;
rv
=
scContainer
-
>
GetSerializedNBytes
(
&
scSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
scSize
<
=
(
uint32_t
)
maxStateObjSize
NS_ERROR_ILLEGAL_VALUE
)
;
bool
equalURIs
=
true
;
nsCOMPtr
<
nsIURI
>
currentURI
;
if
(
mCurrentURI
)
{
currentURI
=
nsIOService
:
:
CreateExposableURI
(
mCurrentURI
)
;
}
else
{
currentURI
=
mCurrentURI
;
}
nsCOMPtr
<
nsIURI
>
newURI
;
if
(
aURL
.
Length
(
)
=
=
0
)
{
newURI
=
currentURI
;
}
else
{
nsIURI
*
docBaseURI
=
document
-
>
GetDocBaseURI
(
)
;
if
(
!
docBaseURI
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
spec
;
docBaseURI
-
>
GetSpec
(
spec
)
;
rv
=
NS_NewURI
(
getter_AddRefs
(
newURI
)
aURL
document
-
>
GetDocumentCharacterSet
(
)
docBaseURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
if
(
!
nsContentUtils
:
:
URIIsLocalFile
(
newURI
)
)
{
nsCOMPtr
<
nsIScriptSecurityManager
>
secMan
=
do_GetService
(
NS_SCRIPTSECURITYMANAGER_CONTRACTID
)
;
NS_ENSURE_TRUE
(
secMan
NS_ERROR_FAILURE
)
;
nsAutoCString
currentUserPass
newUserPass
;
NS_ENSURE_SUCCESS
(
currentURI
-
>
GetUserPass
(
currentUserPass
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
newURI
-
>
GetUserPass
(
newUserPass
)
NS_ERROR_FAILURE
)
;
bool
isPrivateWin
=
document
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
.
mPrivateBrowsingId
>
0
;
if
(
NS_FAILED
(
secMan
-
>
CheckSameOriginURI
(
currentURI
newURI
true
isPrivateWin
)
)
|
|
!
currentUserPass
.
Equals
(
newUserPass
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
}
else
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
document
-
>
GetPrincipal
(
)
;
if
(
!
principal
|
|
NS_FAILED
(
principal
-
>
CheckMayLoadWithReporting
(
newURI
false
document
-
>
InnerWindowID
(
)
)
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
}
if
(
currentURI
)
{
currentURI
-
>
Equals
(
newURI
&
equalURIs
)
;
}
else
{
equalURIs
=
false
;
}
}
rv
=
UpdateURLAndHistory
(
document
newURI
scContainer
aTitle
aReplace
currentURI
equalURIs
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
UpdateURLAndHistory
(
Document
*
aDocument
nsIURI
*
aNewURI
nsIStructuredCloneContainer
*
aData
const
nsAString
&
aTitle
bool
aReplace
nsIURI
*
aCurrentURI
bool
aEqualURIs
)
{
aDocument
-
>
DoNotifyPossibleTitleChange
(
)
;
NS_ENSURE_TRUE
(
mOSHE
|
|
mActiveEntry
|
|
aReplace
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsISHEntry
>
oldOSHE
=
mOSHE
;
bool
sameExceptHashes
=
true
;
aNewURI
-
>
EqualsExceptRef
(
aCurrentURI
&
sameExceptHashes
)
;
bool
uriWasModified
;
if
(
sameExceptHashes
)
{
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
uriWasModified
=
mActiveEntry
&
&
mActiveEntry
-
>
GetURIWasModified
(
)
;
}
else
{
uriWasModified
=
oldOSHE
&
&
oldOSHE
-
>
GetURIWasModified
(
)
;
}
}
else
{
uriWasModified
=
true
;
}
mLoadType
=
LOAD_PUSHSTATE
;
nsCOMPtr
<
nsISHEntry
>
newSHEntry
;
if
(
!
aReplace
)
{
RefPtr
<
ChildSHistory
>
shistory
=
GetRootSessionHistory
(
)
;
if
(
shistory
)
{
shistory
-
>
RemovePendingHistoryNavigations
(
)
;
}
nsPoint
scrollPos
=
GetCurScrollPos
(
)
;
bool
scrollRestorationIsManual
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
scrollRestorationIsManual
=
mActiveEntry
-
>
GetScrollRestorationIsManual
(
)
;
}
else
{
mOSHE
-
>
SetScrollPosition
(
scrollPos
.
x
scrollPos
.
y
)
;
scrollRestorationIsManual
=
mOSHE
-
>
GetScrollRestorationIsManual
(
)
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aDocument
-
>
GetCsp
(
)
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
%
p
UpdateActiveEntry
(
not
replacing
)
"
this
)
)
;
nsString
title
(
mActiveEntry
-
>
GetTitle
(
)
)
;
UpdateActiveEntry
(
false
Some
(
scrollPos
)
aNewURI
nullptr
nullptr
aDocument
-
>
NodePrincipal
(
)
csp
title
scrollRestorationIsManual
aData
uriWasModified
)
;
}
else
{
nsresult
rv
=
AddToSessionHistory
(
aNewURI
nullptr
aDocument
-
>
NodePrincipal
(
)
nullptr
nullptr
csp
true
getter_AddRefs
(
newSHEntry
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
newSHEntry
NS_ERROR_FAILURE
)
;
newSHEntry
-
>
SetScrollRestorationIsManual
(
scrollRestorationIsManual
)
;
nsString
title
;
mOSHE
-
>
GetTitle
(
title
)
;
newSHEntry
-
>
SetTitle
(
title
)
;
NS_ENSURE_SUCCESS
(
newSHEntry
-
>
AdoptBFCacheEntry
(
oldOSHE
)
NS_ERROR_FAILURE
)
;
mOSHE
=
newSHEntry
;
}
}
else
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
%
p
UpdateActiveEntry
(
replacing
)
mActiveEntry
%
p
"
this
mActiveEntry
.
get
(
)
)
)
;
nsString
title
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
;
if
(
mActiveEntry
)
{
title
=
mActiveEntry
-
>
GetTitle
(
)
;
referrerInfo
=
mActiveEntry
-
>
GetReferrerInfo
(
)
;
}
else
{
referrerInfo
=
nullptr
;
}
UpdateActiveEntry
(
true
Nothing
(
)
aNewURI
aNewURI
referrerInfo
aDocument
-
>
NodePrincipal
(
)
aDocument
-
>
GetCsp
(
)
title
mActiveEntry
&
&
mActiveEntry
-
>
GetScrollRestorationIsManual
(
)
aData
uriWasModified
)
;
}
else
{
newSHEntry
=
mOSHE
;
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
%
p
step
3
"
this
)
)
;
if
(
!
newSHEntry
)
{
nsresult
rv
=
AddToSessionHistory
(
aNewURI
nullptr
aDocument
-
>
NodePrincipal
(
)
nullptr
nullptr
aDocument
-
>
GetCsp
(
)
true
getter_AddRefs
(
newSHEntry
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mOSHE
=
newSHEntry
;
}
newSHEntry
-
>
SetURI
(
aNewURI
)
;
newSHEntry
-
>
SetOriginalURI
(
aNewURI
)
;
newSHEntry
-
>
SetUnstrippedURI
(
nullptr
)
;
newSHEntry
-
>
SetResultPrincipalURI
(
nullptr
)
;
newSHEntry
-
>
SetLoadReplace
(
false
)
;
}
if
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
{
newSHEntry
-
>
SetStateData
(
aData
)
;
newSHEntry
-
>
SetPostData
(
nullptr
)
;
newSHEntry
-
>
SetURIWasModified
(
uriWasModified
)
;
RefPtr
<
ChildSHistory
>
rootSH
=
GetRootSessionHistory
(
)
;
if
(
rootSH
)
{
rootSH
-
>
LegacySHistory
(
)
-
>
EvictContentViewersOrReplaceEntry
(
newSHEntry
aReplace
)
;
}
}
if
(
!
aEqualURIs
&
&
!
mIsBeingDestroyed
)
{
aDocument
-
>
SetDocumentURI
(
aNewURI
)
;
SetCurrentURI
(
aNewURI
nullptr
true
false
GetSameDocumentNavigationFlags
(
aNewURI
)
)
;
AddURIVisit
(
aNewURI
aCurrentURI
0
)
;
UpdateGlobalHistoryTitle
(
aNewURI
)
;
CopyFavicon
(
aCurrentURI
aNewURI
UsePrivateBrowsing
(
)
)
;
}
else
{
FireDummyOnLocationChange
(
)
;
}
aDocument
-
>
SetStateObject
(
aData
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetCurrentScrollRestorationIsManual
(
bool
*
aIsManual
)
{
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
*
aIsManual
=
mActiveEntry
&
&
mActiveEntry
-
>
GetScrollRestorationIsManual
(
)
;
return
NS_OK
;
}
*
aIsManual
=
false
;
if
(
mOSHE
)
{
return
mOSHE
-
>
GetScrollRestorationIsManual
(
aIsManual
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetCurrentScrollRestorationIsManual
(
bool
aIsManual
)
{
SetScrollRestorationIsManualOnHistoryEntry
(
mOSHE
aIsManual
)
;
return
NS_OK
;
}
void
nsDocShell
:
:
SetScrollRestorationIsManualOnHistoryEntry
(
nsISHEntry
*
aSHEntry
bool
aIsManual
)
{
if
(
aSHEntry
)
{
aSHEntry
-
>
SetScrollRestorationIsManual
(
aIsManual
)
;
}
if
(
mActiveEntry
&
&
mBrowsingContext
)
{
mActiveEntry
-
>
SetScrollRestorationIsManual
(
aIsManual
)
;
if
(
XRE_IsParentProcess
(
)
)
{
SessionHistoryEntry
*
entry
=
mBrowsingContext
-
>
Canonical
(
)
-
>
GetActiveSessionHistoryEntry
(
)
;
if
(
entry
)
{
entry
-
>
SetScrollRestorationIsManual
(
aIsManual
)
;
}
}
else
{
mozilla
:
:
Unused
<
<
ContentChild
:
:
GetSingleton
(
)
-
>
SendSessionHistoryEntryScrollRestorationIsManual
(
mBrowsingContext
aIsManual
)
;
}
}
}
void
nsDocShell
:
:
SetCacheKeyOnHistoryEntry
(
nsISHEntry
*
aSHEntry
uint32_t
aCacheKey
)
{
if
(
aSHEntry
)
{
aSHEntry
-
>
SetCacheKey
(
aCacheKey
)
;
}
if
(
mActiveEntry
&
&
mBrowsingContext
)
{
mActiveEntry
-
>
SetCacheKey
(
aCacheKey
)
;
if
(
XRE_IsParentProcess
(
)
)
{
SessionHistoryEntry
*
entry
=
mBrowsingContext
-
>
Canonical
(
)
-
>
GetActiveSessionHistoryEntry
(
)
;
if
(
entry
)
{
entry
-
>
SetCacheKey
(
aCacheKey
)
;
}
}
else
{
mozilla
:
:
Unused
<
<
ContentChild
:
:
GetSingleton
(
)
-
>
SendSessionHistoryEntryCacheKey
(
mBrowsingContext
aCacheKey
)
;
}
}
}
bool
nsDocShell
:
:
ShouldAddToSessionHistory
(
nsIURI
*
aURI
nsIChannel
*
aChannel
)
{
nsresult
rv
;
nsAutoCString
buf
;
rv
=
aURI
-
>
GetScheme
(
buf
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
buf
.
EqualsLiteral
(
"
about
"
)
)
{
rv
=
aURI
-
>
GetPathQueryRef
(
buf
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
buf
.
EqualsLiteral
(
"
blank
"
)
)
{
return
false
;
}
if
(
buf
.
EqualsLiteral
(
"
newtab
"
)
)
{
if
(
!
StaticPrefs
:
:
browser_newtabpage_enabled
(
)
)
{
return
false
;
}
NS_ENSURE_TRUE
(
aChannel
false
)
;
nsCOMPtr
<
nsIPrincipal
>
resultPrincipal
;
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
resultPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
!
resultPrincipal
-
>
IsSystemPrincipal
(
)
;
}
}
return
true
;
}
nsresult
nsDocShell
:
:
AddToSessionHistory
(
nsIURI
*
aURI
nsIChannel
*
aChannel
nsIPrincipal
*
aTriggeringPrincipal
nsIPrincipal
*
aPrincipalToInherit
nsIPrincipal
*
aPartitionedPrincipalToInherit
nsIContentSecurityPolicy
*
aCsp
bool
aCloneChildren
nsISHEntry
*
*
aNewEntry
)
{
MOZ_ASSERT
(
aURI
"
uri
is
null
"
)
;
MOZ_ASSERT
(
!
aChannel
|
|
!
aTriggeringPrincipal
"
Shouldn
'
t
have
both
set
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mozilla
:
:
SessionHistoryInParent
(
)
)
;
#
if
defined
(
DEBUG
)
if
(
MOZ_LOG_TEST
(
gDocShellLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
chanName
;
if
(
aChannel
)
{
aChannel
-
>
GetName
(
chanName
)
;
}
else
{
chanName
.
AssignLiteral
(
"
<
no
channel
>
"
)
;
}
MOZ_LOG
(
gDocShellLog
LogLevel
:
:
Debug
(
"
nsDocShell
[
%
p
]
:
:
AddToSessionHistory
(
\
"
%
s
\
"
[
%
s
]
)
\
n
"
this
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
chanName
.
get
(
)
)
)
;
}
#
endif
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsISHEntry
>
entry
;
if
(
LOAD_TYPE_HAS_FLAGS
(
mLoadType
LOAD_FLAGS_REPLACE_HISTORY
)
&
&
!
mBrowsingContext
-
>
IsTop
(
)
)
{
entry
=
mOSHE
;
if
(
entry
)
{
entry
-
>
ClearEntry
(
)
;
}
}
if
(
!
entry
)
{
entry
=
new
nsSHEntry
(
)
;
}
nsCOMPtr
<
nsIInputStream
>
inputStream
;
nsCOMPtr
<
nsIURI
>
originalURI
;
nsCOMPtr
<
nsIURI
>
resultPrincipalURI
;
nsCOMPtr
<
nsIURI
>
unstrippedURI
;
bool
loadReplace
=
false
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
;
uint32_t
cacheKey
=
0
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
aTriggeringPrincipal
;
nsCOMPtr
<
nsIPrincipal
>
principalToInherit
=
aPrincipalToInherit
;
nsCOMPtr
<
nsIPrincipal
>
partitionedPrincipalToInherit
=
aPartitionedPrincipalToInherit
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aCsp
;
bool
expired
=
false
;
bool
discardLayoutState
=
false
;
nsCOMPtr
<
nsICacheInfoChannel
>
cacheChannel
;
bool
userActivation
=
false
;
if
(
aChannel
)
{
cacheChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
cacheChannel
)
{
cacheChannel
-
>
GetCacheKey
(
&
cacheKey
)
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aChannel
)
)
;
if
(
!
httpChannel
)
{
GetHttpChannel
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
}
if
(
httpChannel
)
{
nsCOMPtr
<
nsIUploadChannel
>
uploadChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
uploadChannel
)
{
uploadChannel
-
>
GetUploadStream
(
getter_AddRefs
(
inputStream
)
)
;
}
httpChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
uint32_t
loadFlags
;
aChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
loadReplace
=
loadFlags
&
nsIChannel
:
:
LOAD_REPLACE
;
rv
=
httpChannel
-
>
GetReferrerInfo
(
getter_AddRefs
(
referrerInfo
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
discardLayoutState
=
ShouldDiscardLayoutState
(
httpChannel
)
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
if
(
!
triggeringPrincipal
)
{
triggeringPrincipal
=
loadInfo
-
>
TriggeringPrincipal
(
)
;
}
if
(
!
csp
)
{
csp
=
loadInfo
-
>
GetCspToInherit
(
)
;
}
loadInfo
-
>
GetResultPrincipalURI
(
getter_AddRefs
(
resultPrincipalURI
)
)
;
loadInfo
-
>
GetUnstrippedURI
(
getter_AddRefs
(
unstrippedURI
)
)
;
userActivation
=
loadInfo
-
>
GetHasValidUserGestureActivation
(
)
;
if
(
!
principalToInherit
)
{
if
(
loadInfo
-
>
GetLoadingSandboxed
(
)
)
{
if
(
loadInfo
-
>
GetLoadingPrincipal
(
)
)
{
principalToInherit
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
loadInfo
-
>
GetLoadingPrincipal
(
)
)
;
}
else
{
OriginAttributes
attrs
;
loadInfo
-
>
GetOriginAttributes
(
&
attrs
)
;
principalToInherit
=
NullPrincipal
:
:
Create
(
attrs
)
;
}
}
else
{
principalToInherit
=
loadInfo
-
>
PrincipalToInherit
(
)
;
}
}
if
(
!
partitionedPrincipalToInherit
)
{
partitionedPrincipalToInherit
=
principalToInherit
;
}
}
nsAutoString
srcdoc
;
bool
srcdocEntry
=
false
;
nsCOMPtr
<
nsIURI
>
baseURI
;
nsCOMPtr
<
nsIInputStreamChannel
>
inStrmChan
=
do_QueryInterface
(
aChannel
)
;
if
(
inStrmChan
)
{
bool
isSrcdocChannel
;
inStrmChan
-
>
GetIsSrcdocChannel
(
&
isSrcdocChannel
)
;
if
(
isSrcdocChannel
)
{
inStrmChan
-
>
GetSrcdocData
(
srcdoc
)
;
srcdocEntry
=
true
;
inStrmChan
-
>
GetBaseURI
(
getter_AddRefs
(
baseURI
)
)
;
}
else
{
srcdoc
.
SetIsVoid
(
true
)
;
}
}
bool
saveLayoutState
=
!
discardLayoutState
;
if
(
cacheChannel
)
{
uint32_t
expTime
=
0
;
cacheChannel
-
>
GetCacheTokenExpirationTime
(
&
expTime
)
;
uint32_t
now
=
PRTimeToSeconds
(
PR_Now
(
)
)
;
if
(
expTime
<
=
now
)
{
expired
=
true
;
}
}
entry
-
>
Create
(
aURI
u
"
"
_ns
inputStream
cacheKey
mContentTypeHint
triggeringPrincipal
principalToInherit
partitionedPrincipalToInherit
csp
HistoryID
(
)
GetCreatedDynamically
(
)
originalURI
resultPrincipalURI
unstrippedURI
loadReplace
referrerInfo
srcdoc
srcdocEntry
baseURI
saveLayoutState
expired
userActivation
)
;
if
(
mBrowsingContext
-
>
IsTop
(
)
&
&
GetSessionHistory
(
)
)
{
bool
shouldPersist
=
ShouldAddToSessionHistory
(
aURI
aChannel
)
;
Maybe
<
int32_t
>
previousEntryIndex
;
Maybe
<
int32_t
>
loadedEntryIndex
;
rv
=
GetSessionHistory
(
)
-
>
LegacySHistory
(
)
-
>
AddToRootSessionHistory
(
aCloneChildren
mOSHE
mBrowsingContext
entry
mLoadType
shouldPersist
&
previousEntryIndex
&
loadedEntryIndex
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Could
not
add
entry
to
root
session
history
"
)
;
if
(
previousEntryIndex
.
isSome
(
)
)
{
mPreviousEntryIndex
=
previousEntryIndex
.
value
(
)
;
}
if
(
loadedEntryIndex
.
isSome
(
)
)
{
mLoadedEntryIndex
=
loadedEntryIndex
.
value
(
)
;
}
if
(
aCloneChildren
)
{
WindowContext
*
topWc
=
mBrowsingContext
-
>
GetTopWindowContext
(
)
;
if
(
topWc
&
&
!
topWc
-
>
IsDiscarded
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
topWc
-
>
SetSHEntryHasUserInteraction
(
false
)
)
;
}
}
}
else
{
WindowContext
*
topWc
=
mBrowsingContext
-
>
GetTopWindowContext
(
)
;
if
(
topWc
&
&
!
topWc
-
>
IsDiscarded
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
topWc
-
>
SetSHEntryHasUserInteraction
(
false
)
)
;
}
if
(
!
mOSHE
|
|
!
LOAD_TYPE_HAS_FLAGS
(
mLoadType
LOAD_FLAGS_REPLACE_HISTORY
)
)
{
rv
=
AddChildSHEntryToParent
(
entry
mBrowsingContext
-
>
ChildOffset
(
)
aCloneChildren
)
;
}
}
if
(
aNewEntry
)
{
*
aNewEntry
=
nullptr
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
entry
.
forget
(
aNewEntry
)
;
}
}
return
rv
;
}
void
nsDocShell
:
:
UpdateActiveEntry
(
bool
aReplace
const
Maybe
<
nsPoint
>
&
aPreviousScrollPos
nsIURI
*
aURI
nsIURI
*
aOriginalURI
nsIReferrerInfo
*
aReferrerInfo
nsIPrincipal
*
aTriggeringPrincipal
nsIContentSecurityPolicy
*
aCsp
const
nsAString
&
aTitle
bool
aScrollRestorationIsManual
nsIStructuredCloneContainer
*
aData
bool
aURIWasModified
)
{
MOZ_ASSERT
(
mozilla
:
:
SessionHistoryInParent
(
)
)
;
MOZ_ASSERT
(
aURI
"
uri
is
null
"
)
;
MOZ_ASSERT
(
mLoadType
=
=
LOAD_PUSHSTATE
"
This
code
only
deals
with
pushState
"
)
;
MOZ_ASSERT_IF
(
aPreviousScrollPos
.
isSome
(
)
!
aReplace
)
;
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
Creating
an
active
entry
on
nsDocShell
%
p
to
%
s
"
this
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
bool
replace
=
aReplace
&
&
mActiveEntry
;
if
(
!
replace
)
{
CollectWireframe
(
)
;
}
if
(
mActiveEntry
)
{
mActiveEntry
=
MakeUnique
<
SessionHistoryInfo
>
(
*
mActiveEntry
aURI
)
;
}
else
{
mActiveEntry
=
MakeUnique
<
SessionHistoryInfo
>
(
aURI
aTriggeringPrincipal
nullptr
nullptr
aCsp
mContentTypeHint
)
;
}
mActiveEntry
-
>
SetOriginalURI
(
aOriginalURI
)
;
mActiveEntry
-
>
SetUnstrippedURI
(
nullptr
)
;
mActiveEntry
-
>
SetReferrerInfo
(
aReferrerInfo
)
;
mActiveEntry
-
>
SetTitle
(
aTitle
)
;
mActiveEntry
-
>
SetStateData
(
static_cast
<
nsStructuredCloneContainer
*
>
(
aData
)
)
;
mActiveEntry
-
>
SetURIWasModified
(
aURIWasModified
)
;
mActiveEntry
-
>
SetScrollRestorationIsManual
(
aScrollRestorationIsManual
)
;
if
(
replace
)
{
mBrowsingContext
-
>
ReplaceActiveSessionHistoryEntry
(
mActiveEntry
.
get
(
)
)
;
}
else
{
mBrowsingContext
-
>
IncrementHistoryEntryCountForBrowsingContext
(
)
;
mBrowsingContext
-
>
SetActiveSessionHistoryEntry
(
aPreviousScrollPos
mActiveEntry
.
get
(
)
mLoadType
0
)
;
}
}
nsresult
nsDocShell
:
:
LoadHistoryEntry
(
nsISHEntry
*
aEntry
uint32_t
aLoadType
bool
aUserActivation
)
{
NS_ENSURE_TRUE
(
aEntry
NS_ERROR_FAILURE
)
;
nsresult
rv
;
RefPtr
<
nsDocShellLoadState
>
loadState
;
rv
=
aEntry
-
>
CreateLoadInfo
(
getter_AddRefs
(
loadState
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsISHEntry
>
kungFuDeathGrip
(
aEntry
)
;
loadState
-
>
SetHasValidUserGestureActivation
(
loadState
-
>
HasValidUserGestureActivation
(
)
|
|
aUserActivation
)
;
return
LoadHistoryEntry
(
loadState
aLoadType
aEntry
=
=
mOSHE
)
;
}
nsresult
nsDocShell
:
:
LoadHistoryEntry
(
const
LoadingSessionHistoryInfo
&
aEntry
uint32_t
aLoadType
bool
aUserActivation
)
{
RefPtr
<
nsDocShellLoadState
>
loadState
=
aEntry
.
CreateLoadInfo
(
)
;
loadState
-
>
SetHasValidUserGestureActivation
(
loadState
-
>
HasValidUserGestureActivation
(
)
|
|
aUserActivation
)
;
return
LoadHistoryEntry
(
loadState
aLoadType
aEntry
.
mLoadingCurrentEntry
)
;
}
nsresult
nsDocShell
:
:
LoadHistoryEntry
(
nsDocShellLoadState
*
aLoadState
uint32_t
aLoadType
bool
aLoadingCurrentEntry
)
{
if
(
!
IsNavigationAllowed
(
)
)
{
return
NS_OK
;
}
aLoadState
-
>
SetLoadType
(
aLoadType
)
;
nsresult
rv
;
if
(
SchemeIsJavascript
(
aLoadState
-
>
URI
(
)
)
)
{
rv
=
CreateAboutBlankContentViewer
(
aLoadState
-
>
PrincipalToInherit
(
)
aLoadState
-
>
PartitionedPrincipalToInherit
(
)
nullptr
nullptr
false
Nothing
(
)
!
aLoadingCurrentEntry
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
if
(
!
aLoadState
-
>
TriggeringPrincipal
(
)
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
NullPrincipal
:
:
Create
(
GetOriginAttributes
(
)
)
;
aLoadState
-
>
SetTriggeringPrincipal
(
principal
)
;
}
}
if
(
(
aLoadType
&
LOAD_CMD_RELOAD
)
&
&
aLoadState
-
>
PostDataStream
(
)
)
{
bool
repost
;
rv
=
ConfirmRepost
(
&
repost
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
repost
)
{
return
NS_BINDING_ABORTED
;
}
}
MOZ_ASSERT
(
aLoadState
-
>
TriggeringPrincipal
(
)
"
need
a
valid
triggeringPrincipal
to
load
from
history
"
)
;
if
(
!
aLoadState
-
>
TriggeringPrincipal
(
)
)
{
return
NS_ERROR_FAILURE
;
}
return
InternalLoad
(
aLoadState
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
PersistLayoutHistoryState
(
)
{
nsresult
rv
=
NS_OK
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
?
!
!
mActiveEntry
:
!
!
mOSHE
)
{
bool
scrollRestorationIsManual
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
scrollRestorationIsManual
=
mActiveEntry
-
>
GetScrollRestorationIsManual
(
)
;
}
else
{
scrollRestorationIsManual
=
mOSHE
-
>
GetScrollRestorationIsManual
(
)
;
}
nsCOMPtr
<
nsILayoutHistoryState
>
layoutState
;
if
(
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
)
{
rv
=
presShell
-
>
CaptureHistoryState
(
getter_AddRefs
(
layoutState
)
)
;
}
else
if
(
scrollRestorationIsManual
)
{
GetLayoutHistoryState
(
getter_AddRefs
(
layoutState
)
)
;
}
if
(
scrollRestorationIsManual
&
&
layoutState
)
{
layoutState
-
>
ResetScrollState
(
)
;
}
}
return
rv
;
}
void
nsDocShell
:
:
SwapHistoryEntries
(
nsISHEntry
*
aOldEntry
nsISHEntry
*
aNewEntry
)
{
if
(
aOldEntry
=
=
mOSHE
)
{
mOSHE
=
aNewEntry
;
}
if
(
aOldEntry
=
=
mLSHE
)
{
mLSHE
=
aNewEntry
;
}
}
void
nsDocShell
:
:
SetHistoryEntryAndUpdateBC
(
const
Maybe
<
nsISHEntry
*
>
&
aLSHE
const
Maybe
<
nsISHEntry
*
>
&
aOSHE
)
{
nsCOMPtr
<
nsISHEntry
>
deathGripOldLSHE
;
if
(
aLSHE
.
isSome
(
)
)
{
deathGripOldLSHE
=
SetHistoryEntry
(
&
mLSHE
aLSHE
.
value
(
)
)
;
MOZ_ASSERT
(
mLSHE
.
get
(
)
=
=
aLSHE
.
value
(
)
)
;
}
nsCOMPtr
<
nsISHEntry
>
deathGripOldOSHE
;
if
(
aOSHE
.
isSome
(
)
)
{
deathGripOldOSHE
=
SetHistoryEntry
(
&
mOSHE
aOSHE
.
value
(
)
)
;
MOZ_ASSERT
(
mOSHE
.
get
(
)
=
=
aOSHE
.
value
(
)
)
;
}
}
already_AddRefed
<
nsISHEntry
>
nsDocShell
:
:
SetHistoryEntry
(
nsCOMPtr
<
nsISHEntry
>
*
aPtr
nsISHEntry
*
aEntry
)
{
RefPtr
<
BrowsingContext
>
topBC
=
mBrowsingContext
-
>
Top
(
)
;
if
(
topBC
-
>
IsDiscarded
(
)
)
{
topBC
=
nullptr
;
}
RefPtr
<
BrowsingContext
>
currBC
=
mBrowsingContext
-
>
IsDiscarded
(
)
?
nullptr
:
mBrowsingContext
;
if
(
topBC
&
&
*
aPtr
)
{
(
*
aPtr
)
-
>
SyncTreesForSubframeNavigation
(
aEntry
topBC
currBC
)
;
}
nsCOMPtr
<
nsISHEntry
>
entry
(
aEntry
)
;
entry
.
swap
(
*
aPtr
)
;
return
entry
.
forget
(
)
;
}
already_AddRefed
<
ChildSHistory
>
nsDocShell
:
:
GetRootSessionHistory
(
)
{
RefPtr
<
ChildSHistory
>
childSHistory
=
mBrowsingContext
-
>
Top
(
)
-
>
GetChildSessionHistory
(
)
;
return
childSHistory
.
forget
(
)
;
}
nsresult
nsDocShell
:
:
GetHttpChannel
(
nsIChannel
*
aChannel
nsIHttpChannel
*
*
aReturn
)
{
NS_ENSURE_ARG_POINTER
(
aReturn
)
;
if
(
!
aChannel
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIMultiPartChannel
>
multiPartChannel
(
do_QueryInterface
(
aChannel
)
)
;
if
(
multiPartChannel
)
{
nsCOMPtr
<
nsIChannel
>
baseChannel
;
multiPartChannel
-
>
GetBaseChannel
(
getter_AddRefs
(
baseChannel
)
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
baseChannel
)
)
;
*
aReturn
=
httpChannel
;
NS_IF_ADDREF
(
*
aReturn
)
;
}
return
NS_OK
;
}
bool
nsDocShell
:
:
ShouldDiscardLayoutState
(
nsIHttpChannel
*
aChannel
)
{
if
(
!
aChannel
)
{
return
false
;
}
bool
noStore
=
false
;
Unused
<
<
aChannel
-
>
IsNoStoreResponse
(
&
noStore
)
;
return
noStore
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetEditor
(
nsIEditor
*
*
aEditor
)
{
NS_ENSURE_ARG_POINTER
(
aEditor
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
GetHTMLEditorInternal
(
)
;
htmlEditor
.
forget
(
aEditor
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetEditor
(
nsIEditor
*
aEditor
)
{
HTMLEditor
*
htmlEditor
=
aEditor
?
aEditor
-
>
GetAsHTMLEditor
(
)
:
nullptr
;
if
(
aEditor
&
&
!
htmlEditor
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
SetHTMLEditorInternal
(
htmlEditor
)
;
}
HTMLEditor
*
nsDocShell
:
:
GetHTMLEditorInternal
(
)
{
return
mEditorData
?
mEditorData
-
>
GetHTMLEditor
(
)
:
nullptr
;
}
nsresult
nsDocShell
:
:
SetHTMLEditorInternal
(
HTMLEditor
*
aHTMLEditor
)
{
if
(
!
aHTMLEditor
&
&
!
mEditorData
)
{
return
NS_OK
;
}
nsresult
rv
=
EnsureEditorData
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
mEditorData
-
>
SetHTMLEditor
(
aHTMLEditor
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetEditable
(
bool
*
aEditable
)
{
NS_ENSURE_ARG_POINTER
(
aEditable
)
;
*
aEditable
=
mEditorData
&
&
mEditorData
-
>
GetEditable
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetHasEditingSession
(
bool
*
aHasEditingSession
)
{
NS_ENSURE_ARG_POINTER
(
aHasEditingSession
)
;
if
(
mEditorData
)
{
*
aHasEditingSession
=
!
!
mEditorData
-
>
GetEditingSession
(
)
;
}
else
{
*
aHasEditingSession
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
MakeEditable
(
bool
aInWaitForUriLoad
)
{
nsresult
rv
=
EnsureEditorData
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
mEditorData
-
>
MakeEditable
(
aInWaitForUriLoad
)
;
}
bool
nsDocShell
:
:
ShouldAddURIVisit
(
nsIChannel
*
aChannel
)
{
bool
needToAddURIVisit
=
true
;
nsCOMPtr
<
nsIPropertyBag2
>
props
(
do_QueryInterface
(
aChannel
)
)
;
if
(
props
)
{
mozilla
:
:
Unused
<
<
props
-
>
GetPropertyAsBool
(
u
"
docshell
.
needToAddURIVisit
"
_ns
&
needToAddURIVisit
)
;
}
return
needToAddURIVisit
;
}
void
nsDocShell
:
:
ExtractLastVisit
(
nsIChannel
*
aChannel
nsIURI
*
*
aURI
uint32_t
*
aChannelRedirectFlags
)
{
nsCOMPtr
<
nsIPropertyBag2
>
props
(
do_QueryInterface
(
aChannel
)
)
;
if
(
!
props
)
{
return
;
}
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
uri
(
do_GetProperty
(
props
u
"
docshell
.
previousURI
"
_ns
&
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
uri
.
forget
(
aURI
)
;
rv
=
props
-
>
GetPropertyAsUint32
(
u
"
docshell
.
previousFlags
"
_ns
aChannelRedirectFlags
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Could
not
fetch
previous
flags
URI
will
be
treated
like
referrer
"
)
;
}
else
{
NS_GetReferrerFromChannel
(
aChannel
aURI
)
;
}
}
void
nsDocShell
:
:
SaveLastVisit
(
nsIChannel
*
aChannel
nsIURI
*
aURI
uint32_t
aChannelRedirectFlags
)
{
nsCOMPtr
<
nsIWritablePropertyBag2
>
props
(
do_QueryInterface
(
aChannel
)
)
;
if
(
!
props
|
|
!
aURI
)
{
return
;
}
props
-
>
SetPropertyAsInterface
(
u
"
docshell
.
previousURI
"
_ns
aURI
)
;
props
-
>
SetPropertyAsUint32
(
u
"
docshell
.
previousFlags
"
_ns
aChannelRedirectFlags
)
;
}
void
nsDocShell
:
:
InternalAddURIVisit
(
nsIURI
*
aURI
nsIURI
*
aPreviousURI
uint32_t
aChannelRedirectFlags
uint32_t
aResponseStatus
BrowsingContext
*
aBrowsingContext
nsIWidget
*
aWidget
uint32_t
aLoadType
)
{
MOZ_ASSERT
(
aURI
"
Visited
URI
is
null
!
"
)
;
MOZ_ASSERT
(
aLoadType
!
=
LOAD_ERROR_PAGE
&
&
aLoadType
!
=
LOAD_BYPASS_HISTORY
"
Do
not
add
error
or
bypass
pages
to
global
history
"
)
;
bool
usePrivateBrowsing
=
false
;
aBrowsingContext
-
>
GetUsePrivateBrowsing
(
&
usePrivateBrowsing
)
;
if
(
!
aBrowsingContext
-
>
IsContent
(
)
|
|
!
aBrowsingContext
-
>
GetUseGlobalHistory
(
)
|
|
usePrivateBrowsing
)
{
return
;
}
nsCOMPtr
<
IHistory
>
history
=
components
:
:
History
:
:
Service
(
)
;
if
(
history
)
{
uint32_t
visitURIFlags
=
0
;
if
(
aBrowsingContext
-
>
IsTop
(
)
)
{
visitURIFlags
|
=
IHistory
:
:
TOP_LEVEL
;
}
if
(
aChannelRedirectFlags
&
nsIChannelEventSink
:
:
REDIRECT_TEMPORARY
)
{
visitURIFlags
|
=
IHistory
:
:
REDIRECT_TEMPORARY
;
}
else
if
(
aChannelRedirectFlags
&
nsIChannelEventSink
:
:
REDIRECT_PERMANENT
)
{
visitURIFlags
|
=
IHistory
:
:
REDIRECT_PERMANENT
;
}
else
{
MOZ_ASSERT
(
!
aChannelRedirectFlags
"
One
of
REDIRECT_TEMPORARY
or
REDIRECT_PERMANENT
must
be
set
"
"
if
any
flags
in
aChannelRedirectFlags
is
set
.
"
)
;
}
if
(
aResponseStatus
>
=
300
&
&
aResponseStatus
<
400
)
{
visitURIFlags
|
=
IHistory
:
:
REDIRECT_SOURCE
;
if
(
aResponseStatus
=
=
301
|
|
aResponseStatus
=
=
308
)
{
visitURIFlags
|
=
IHistory
:
:
REDIRECT_SOURCE_PERMANENT
;
}
}
else
if
(
aResponseStatus
!
=
408
&
&
(
(
aResponseStatus
>
=
400
&
&
aResponseStatus
<
=
501
)
|
|
aResponseStatus
=
=
505
)
)
{
visitURIFlags
|
=
IHistory
:
:
UNRECOVERABLE_ERROR
;
}
mozilla
:
:
Unused
<
<
history
-
>
VisitURI
(
aWidget
aURI
aPreviousURI
visitURIFlags
aBrowsingContext
-
>
BrowserId
(
)
)
;
}
}
void
nsDocShell
:
:
AddURIVisit
(
nsIURI
*
aURI
nsIURI
*
aPreviousURI
uint32_t
aChannelRedirectFlags
uint32_t
aResponseStatus
)
{
nsPIDOMWindowOuter
*
outer
=
GetWindow
(
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
widget
:
:
WidgetUtils
:
:
DOMWindowToWidget
(
outer
)
;
InternalAddURIVisit
(
aURI
aPreviousURI
aChannelRedirectFlags
aResponseStatus
mBrowsingContext
widget
mLoadType
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetLoadType
(
uint32_t
aLoadType
)
{
mLoadType
=
aLoadType
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetLoadType
(
uint32_t
*
aLoadType
)
{
*
aLoadType
=
mLoadType
;
return
NS_OK
;
}
nsresult
nsDocShell
:
:
ConfirmRepost
(
bool
*
aRepost
)
{
if
(
StaticPrefs
:
:
dom_confirm_repost_testing_always_accept
(
)
)
{
*
aRepost
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
nsIPromptCollection
>
prompter
=
do_GetService
(
"
mozilla
.
org
/
embedcomp
/
prompt
-
collection
;
1
"
)
;
if
(
!
prompter
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
prompter
-
>
ConfirmRepost
(
mBrowsingContext
aRepost
)
;
}
nsresult
nsDocShell
:
:
GetPromptAndStringBundle
(
nsIPrompt
*
*
aPrompt
nsIStringBundle
*
*
aStringBundle
)
{
NS_ENSURE_SUCCESS
(
GetInterface
(
NS_GET_IID
(
nsIPrompt
)
(
void
*
*
)
aPrompt
)
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIStringBundleService
>
stringBundleService
=
mozilla
:
:
components
:
:
StringBundle
:
:
Service
(
)
;
NS_ENSURE_TRUE
(
stringBundleService
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
stringBundleService
-
>
CreateBundle
(
kAppstringsBundleURL
aStringBundle
)
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
nsIScrollableFrame
*
nsDocShell
:
:
GetRootScrollFrame
(
)
{
PresShell
*
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
nullptr
)
;
return
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
}
nsresult
nsDocShell
:
:
EnsureScriptEnvironment
(
)
{
if
(
mScriptGlobal
)
{
return
NS_OK
;
}
if
(
mIsBeingDestroyed
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
#
ifdef
DEBUG
NS_ASSERTION
(
!
mInEnsureScriptEnv
"
Infinite
loop
!
Calling
EnsureScriptEnvironment
(
)
from
"
"
within
EnsureScriptEnvironment
(
)
!
"
)
;
AutoRestore
<
bool
>
boolSetter
(
mInEnsureScriptEnv
)
;
mInEnsureScriptEnv
=
true
;
#
endif
nsCOMPtr
<
nsIWebBrowserChrome
>
browserChrome
(
do_GetInterface
(
mTreeOwner
)
)
;
NS_ENSURE_TRUE
(
browserChrome
NS_ERROR_NOT_AVAILABLE
)
;
uint32_t
chromeFlags
;
browserChrome
-
>
GetChromeFlags
(
&
chromeFlags
)
;
mScriptGlobal
=
nsGlobalWindowOuter
:
:
Create
(
this
mItemType
=
=
typeChrome
)
;
MOZ_ASSERT
(
mScriptGlobal
)
;
return
mScriptGlobal
-
>
EnsureScriptEnvironment
(
)
;
}
nsresult
nsDocShell
:
:
EnsureEditorData
(
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
bool
openDocHasDetachedEditor
=
mOSHE
&
&
mOSHE
-
>
HasDetachedEditor
(
)
;
if
(
!
mEditorData
&
&
!
mIsBeingDestroyed
&
&
!
openDocHasDetachedEditor
)
{
mEditorData
=
MakeUnique
<
nsDocShellEditorData
>
(
this
)
;
}
return
mEditorData
?
NS_OK
:
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
nsDocShell
:
:
EnsureFind
(
)
{
if
(
!
mFind
)
{
mFind
=
new
nsWebBrowserFind
(
)
;
}
nsIScriptGlobalObject
*
scriptGO
=
GetScriptGlobalObject
(
)
;
NS_ENSURE_TRUE
(
scriptGO
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
ourWindow
=
do_QueryInterface
(
scriptGO
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
windowToSearch
;
nsFocusManager
:
:
GetFocusedDescendant
(
ourWindow
nsFocusManager
:
:
eIncludeAllDescendants
getter_AddRefs
(
windowToSearch
)
)
;
nsCOMPtr
<
nsIWebBrowserFindInFrames
>
findInFrames
=
do_QueryInterface
(
mFind
)
;
if
(
!
findInFrames
)
{
return
NS_ERROR_NO_INTERFACE
;
}
nsresult
rv
=
findInFrames
-
>
SetRootSearchFrame
(
ourWindow
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
findInFrames
-
>
SetCurrentSearchFrame
(
windowToSearch
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
IsBeingDestroyed
(
bool
*
aDoomed
)
{
NS_ENSURE_ARG
(
aDoomed
)
;
*
aDoomed
=
mIsBeingDestroyed
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsExecutingOnLoadHandler
(
bool
*
aResult
)
{
NS_ENSURE_ARG
(
aResult
)
;
*
aResult
=
mIsExecutingOnLoadHandler
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetLayoutHistoryState
(
nsILayoutHistoryState
*
*
aLayoutHistoryState
)
{
nsCOMPtr
<
nsILayoutHistoryState
>
state
;
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
if
(
mActiveEntry
)
{
state
=
mActiveEntry
-
>
GetLayoutHistoryState
(
)
;
}
}
else
{
if
(
mOSHE
)
{
state
=
mOSHE
-
>
GetLayoutHistoryState
(
)
;
}
}
state
.
forget
(
aLayoutHistoryState
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetLayoutHistoryState
(
nsILayoutHistoryState
*
aLayoutHistoryState
)
{
if
(
mOSHE
)
{
mOSHE
-
>
SetLayoutHistoryState
(
aLayoutHistoryState
)
;
}
if
(
mActiveEntry
)
{
mActiveEntry
-
>
SetLayoutHistoryState
(
aLayoutHistoryState
)
;
}
return
NS_OK
;
}
nsDocShell
:
:
InterfaceRequestorProxy
:
:
InterfaceRequestorProxy
(
nsIInterfaceRequestor
*
aRequestor
)
{
if
(
aRequestor
)
{
mWeakPtr
=
do_GetWeakReference
(
aRequestor
)
;
}
}
nsDocShell
:
:
InterfaceRequestorProxy
:
:
~
InterfaceRequestorProxy
(
)
{
mWeakPtr
=
nullptr
;
}
NS_IMPL_ISUPPORTS
(
nsDocShell
:
:
InterfaceRequestorProxy
nsIInterfaceRequestor
)
NS_IMETHODIMP
nsDocShell
:
:
InterfaceRequestorProxy
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
NS_ENSURE_ARG_POINTER
(
aSink
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
ifReq
=
do_QueryReferent
(
mWeakPtr
)
;
if
(
ifReq
)
{
return
ifReq
-
>
GetInterface
(
aIID
aSink
)
;
}
*
aSink
=
nullptr
;
return
NS_NOINTERFACE
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAuthPrompt
(
uint32_t
aPromptReason
const
nsIID
&
aIID
void
*
*
aResult
)
{
bool
priorityPrompt
=
(
aPromptReason
=
=
PROMPT_PROXY
)
;
if
(
!
mAllowAuth
&
&
!
priorityPrompt
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
wwatch
=
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
EnsureScriptEnvironment
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
wwatch
-
>
GetPrompt
(
mScriptGlobal
aIID
reinterpret_cast
<
void
*
*
>
(
aResult
)
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAssociatedWindow
(
mozIDOMWindowProxy
*
*
aWindow
)
{
CallGetInterface
(
this
aWindow
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetTopWindow
(
mozIDOMWindowProxy
*
*
aWindow
)
{
return
mBrowsingContext
-
>
GetTopWindow
(
aWindow
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetTopFrameElement
(
Element
*
*
aElement
)
{
return
mBrowsingContext
-
>
GetTopFrameElement
(
aElement
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetUseTrackingProtection
(
bool
*
aUseTrackingProtection
)
{
return
mBrowsingContext
-
>
GetUseTrackingProtection
(
aUseTrackingProtection
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetUseTrackingProtection
(
bool
aUseTrackingProtection
)
{
return
mBrowsingContext
-
>
SetUseTrackingProtection
(
aUseTrackingProtection
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsContent
(
bool
*
aIsContent
)
{
*
aIsContent
=
(
mItemType
=
=
typeContent
)
;
return
NS_OK
;
}
bool
nsDocShell
:
:
IsOKToLoadURI
(
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aURI
"
Must
have
a
URI
!
"
)
;
if
(
!
mFiredUnloadEvent
)
{
return
true
;
}
if
(
!
mLoadingURI
)
{
return
false
;
}
bool
isPrivateWin
=
false
;
Document
*
doc
=
GetDocument
(
)
;
if
(
doc
)
{
isPrivateWin
=
doc
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
.
mPrivateBrowsingId
>
0
;
}
nsCOMPtr
<
nsIScriptSecurityManager
>
secMan
=
do_GetService
(
NS_SCRIPTSECURITYMANAGER_CONTRACTID
)
;
return
secMan
&
&
NS_SUCCEEDED
(
secMan
-
>
CheckSameOriginURI
(
aURI
mLoadingURI
false
isPrivateWin
)
)
;
}
nsresult
nsDocShell
:
:
GetControllerForCommand
(
const
char
*
aCommand
nsIController
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
nullptr
;
NS_ENSURE_TRUE
(
mScriptGlobal
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsPIWindowRoot
>
root
=
mScriptGlobal
-
>
GetTopWindowRoot
(
)
;
NS_ENSURE_TRUE
(
root
NS_ERROR_FAILURE
)
;
return
root
-
>
GetControllerForCommand
(
aCommand
false
aResult
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
IsCommandEnabled
(
const
char
*
aCommand
bool
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
false
;
nsresult
rv
=
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIController
>
controller
;
rv
=
GetControllerForCommand
(
aCommand
getter_AddRefs
(
controller
)
)
;
if
(
controller
)
{
rv
=
controller
-
>
IsCommandEnabled
(
aCommand
aResult
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsDocShell
:
:
DoCommand
(
const
char
*
aCommand
)
{
nsresult
rv
=
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIController
>
controller
;
rv
=
GetControllerForCommand
(
aCommand
getter_AddRefs
(
controller
)
)
;
if
(
controller
)
{
rv
=
controller
-
>
DoCommand
(
aCommand
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsDocShell
:
:
DoCommandWithParams
(
const
char
*
aCommand
nsICommandParams
*
aParams
)
{
nsCOMPtr
<
nsIController
>
controller
;
nsresult
rv
=
GetControllerForCommand
(
aCommand
getter_AddRefs
(
controller
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsICommandController
>
commandController
=
do_QueryInterface
(
controller
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
commandController
-
>
DoCommandWithParams
(
aCommand
aParams
)
;
}
nsresult
nsDocShell
:
:
EnsureCommandHandler
(
)
{
if
(
!
mCommandManager
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
GetWindow
(
)
)
{
mCommandManager
=
new
nsCommandManager
(
domWindow
)
;
}
}
return
mCommandManager
?
NS_OK
:
NS_ERROR_FAILURE
;
}
class
OnLinkClickEvent
:
public
Runnable
{
public
:
OnLinkClickEvent
(
nsDocShell
*
aHandler
nsIContent
*
aContent
nsDocShellLoadState
*
aLoadState
bool
aNoOpenerImplied
bool
aIsTrusted
nsIPrincipal
*
aTriggeringPrincipal
)
;
NS_IMETHOD
Run
(
)
override
{
AutoPopupStatePusher
popupStatePusher
(
mPopupState
)
;
AutoJSAPI
jsapi
;
if
(
mIsTrusted
|
|
jsapi
.
Init
(
mContent
-
>
OwnerDoc
(
)
-
>
GetScopeObject
(
)
)
)
{
mHandler
-
>
OnLinkClickSync
(
mContent
mLoadState
mNoOpenerImplied
mTriggeringPrincipal
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
nsDocShell
>
mHandler
;
nsCOMPtr
<
nsIContent
>
mContent
;
RefPtr
<
nsDocShellLoadState
>
mLoadState
;
nsCOMPtr
<
nsIPrincipal
>
mTriggeringPrincipal
;
PopupBlocker
:
:
PopupControlState
mPopupState
;
bool
mNoOpenerImplied
;
bool
mIsTrusted
;
}
;
OnLinkClickEvent
:
:
OnLinkClickEvent
(
nsDocShell
*
aHandler
nsIContent
*
aContent
nsDocShellLoadState
*
aLoadState
bool
aNoOpenerImplied
bool
aIsTrusted
nsIPrincipal
*
aTriggeringPrincipal
)
:
mozilla
:
:
Runnable
(
"
OnLinkClickEvent
"
)
mHandler
(
aHandler
)
mContent
(
aContent
)
mLoadState
(
aLoadState
)
mTriggeringPrincipal
(
aTriggeringPrincipal
)
mPopupState
(
PopupBlocker
:
:
GetPopupControlState
(
)
)
mNoOpenerImplied
(
aNoOpenerImplied
)
mIsTrusted
(
aIsTrusted
)
{
}
nsresult
nsDocShell
:
:
OnLinkClick
(
nsIContent
*
aContent
nsIURI
*
aURI
const
nsAString
&
aTargetSpec
const
nsAString
&
aFileName
nsIInputStream
*
aPostDataStream
nsIInputStream
*
aHeadersDataStream
bool
aIsUserTriggered
bool
aIsTrusted
nsIPrincipal
*
aTriggeringPrincipal
nsIContentSecurityPolicy
*
aCsp
)
{
#
ifndef
ANDROID
MOZ_ASSERT
(
aTriggeringPrincipal
"
Need
a
valid
triggeringPrincipal
"
)
;
#
endif
NS_ASSERTION
(
NS_IsMainThread
(
)
"
wrong
thread
"
)
;
if
(
!
IsNavigationAllowed
(
)
|
|
!
IsOKToLoadURI
(
aURI
)
)
{
return
NS_OK
;
}
if
(
ShouldBlockLoadingForBackButton
(
)
)
{
return
NS_OK
;
}
if
(
aContent
-
>
IsEditable
(
)
)
{
return
NS_OK
;
}
bool
noOpenerImplied
=
false
;
nsAutoString
target
(
aTargetSpec
)
;
if
(
aFileName
.
IsVoid
(
)
&
&
ShouldOpenInBlankTarget
(
aTargetSpec
aURI
aContent
aIsUserTriggered
)
)
{
target
=
u
"
_blank
"
;
if
(
!
aTargetSpec
.
Equals
(
target
)
)
{
noOpenerImplied
=
true
;
}
}
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
aURI
)
;
loadState
-
>
SetTarget
(
target
)
;
loadState
-
>
SetFileName
(
aFileName
)
;
loadState
-
>
SetPostDataStream
(
aPostDataStream
)
;
loadState
-
>
SetHeadersStream
(
aHeadersDataStream
)
;
loadState
-
>
SetFirstParty
(
true
)
;
loadState
-
>
SetTriggeringPrincipal
(
aTriggeringPrincipal
?
aTriggeringPrincipal
:
aContent
-
>
NodePrincipal
(
)
)
;
loadState
-
>
SetPrincipalToInherit
(
aContent
-
>
NodePrincipal
(
)
)
;
loadState
-
>
SetCsp
(
aCsp
?
aCsp
:
aContent
-
>
GetCsp
(
)
)
;
loadState
-
>
SetAllowFocusMove
(
UserActivation
:
:
IsHandlingUserInput
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
ev
=
new
OnLinkClickEvent
(
this
aContent
loadState
noOpenerImplied
aIsTrusted
aTriggeringPrincipal
)
;
return
Dispatch
(
TaskCategory
:
:
UI
ev
.
forget
(
)
)
;
}
bool
nsDocShell
:
:
ShouldOpenInBlankTarget
(
const
nsAString
&
aOriginalTarget
nsIURI
*
aLinkURI
nsIContent
*
aContent
bool
aIsUserTriggered
)
{
if
(
net
:
:
SchemeIsJavascript
(
aLinkURI
)
)
{
return
false
;
}
nsAutoCString
linkHost
;
if
(
NS_FAILED
(
aLinkURI
-
>
GetHost
(
linkHost
)
)
)
{
return
false
;
}
if
(
mBrowsingContext
-
>
TargetTopLevelLinkClicksToBlank
(
)
&
&
aIsUserTriggered
&
&
(
(
aOriginalTarget
.
IsEmpty
(
)
&
&
mBrowsingContext
-
>
IsTop
(
)
)
|
|
aOriginalTarget
=
=
u
"
_top
"
_ns
)
)
{
return
true
;
}
if
(
!
aOriginalTarget
.
IsEmpty
(
)
)
{
return
false
;
}
nsString
mmGroup
=
mBrowsingContext
-
>
Top
(
)
-
>
GetMessageManagerGroup
(
)
;
if
(
!
mmGroup
.
EqualsLiteral
(
"
webext
-
browsers
"
)
&
&
!
mBrowsingContext
-
>
IsAppTab
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
docURI
=
aContent
-
>
OwnerDoc
(
)
-
>
GetDocumentURIObject
(
)
;
if
(
!
docURI
)
{
return
false
;
}
nsAutoCString
docHost
;
if
(
NS_FAILED
(
docURI
-
>
GetHost
(
docHost
)
)
)
{
return
false
;
}
if
(
linkHost
.
Equals
(
docHost
)
)
{
return
false
;
}
return
linkHost
.
Length
(
)
<
docHost
.
Length
(
)
?
!
docHost
.
Equals
(
"
www
.
"
_ns
+
linkHost
)
:
!
linkHost
.
Equals
(
"
www
.
"
_ns
+
docHost
)
;
}
static
bool
ElementCanHaveNoopener
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
a
nsGkAtoms
:
:
area
nsGkAtoms
:
:
form
)
|
|
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
a
)
;
}
nsresult
nsDocShell
:
:
OnLinkClickSync
(
nsIContent
*
aContent
nsDocShellLoadState
*
aLoadState
bool
aNoOpenerImplied
nsIPrincipal
*
aTriggeringPrincipal
)
{
if
(
!
IsNavigationAllowed
(
)
|
|
!
IsOKToLoadURI
(
aLoadState
-
>
URI
(
)
)
)
{
return
NS_OK
;
}
if
(
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
form
)
&
&
ShouldBlockLoadingForBackButton
(
)
)
{
return
NS_OK
;
}
if
(
aContent
-
>
IsEditable
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
aTriggeringPrincipal
?
aTriggeringPrincipal
:
aContent
-
>
NodePrincipal
(
)
;
{
nsCOMPtr
<
nsIExternalProtocolService
>
extProtService
=
do_GetService
(
NS_EXTERNALPROTOCOLSERVICE_CONTRACTID
)
;
if
(
extProtService
)
{
nsAutoCString
scheme
;
aLoadState
-
>
URI
(
)
-
>
GetScheme
(
scheme
)
;
if
(
!
scheme
.
IsEmpty
(
)
)
{
bool
isExposed
;
nsresult
rv
=
extProtService
-
>
IsExposedProtocol
(
scheme
.
get
(
)
&
isExposed
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
isExposed
)
{
return
extProtService
-
>
LoadURI
(
aLoadState
-
>
URI
(
)
triggeringPrincipal
nullptr
mBrowsingContext
false
aContent
-
>
OwnerDoc
(
)
-
>
HasValidTransientUserGestureActivation
(
)
)
;
}
}
}
}
uint32_t
triggeringSandboxFlags
=
0
;
if
(
mBrowsingContext
)
{
triggeringSandboxFlags
=
aContent
-
>
OwnerDoc
(
)
-
>
GetSandboxFlags
(
)
;
}
uint32_t
flags
=
INTERNAL_LOAD_FLAGS_NONE
;
bool
elementCanHaveNoopener
=
ElementCanHaveNoopener
(
aContent
)
;
bool
triggeringPrincipalIsSystemPrincipal
=
aLoadState
-
>
TriggeringPrincipal
(
)
-
>
IsSystemPrincipal
(
)
;
if
(
elementCanHaveNoopener
)
{
MOZ_ASSERT
(
aContent
-
>
IsHTMLElement
(
)
|
|
aContent
-
>
IsSVGElement
(
)
)
;
nsAutoString
relString
;
aContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
rel
relString
)
;
nsWhitespaceTokenizerTemplate
<
nsContentUtils
:
:
IsHTMLWhitespace
>
tok
(
relString
)
;
bool
targetBlank
=
aLoadState
-
>
Target
(
)
.
LowerCaseEqualsLiteral
(
"
_blank
"
)
;
bool
explicitOpenerSet
=
false
;
while
(
tok
.
hasMoreTokens
(
)
)
{
const
nsAString
&
token
=
tok
.
nextToken
(
)
;
if
(
token
.
LowerCaseEqualsLiteral
(
"
noreferrer
"
)
)
{
flags
|
=
INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER
|
INTERNAL_LOAD_FLAGS_NO_OPENER
;
explicitOpenerSet
=
true
;
break
;
}
if
(
token
.
LowerCaseEqualsLiteral
(
"
noopener
"
)
)
{
flags
|
=
INTERNAL_LOAD_FLAGS_NO_OPENER
;
explicitOpenerSet
=
true
;
}
if
(
targetBlank
&
&
StaticPrefs
:
:
dom_targetBlankNoOpener_enabled
(
)
&
&
token
.
LowerCaseEqualsLiteral
(
"
opener
"
)
&
&
!
explicitOpenerSet
)
{
explicitOpenerSet
=
true
;
}
}
if
(
targetBlank
&
&
StaticPrefs
:
:
dom_targetBlankNoOpener_enabled
(
)
&
&
!
explicitOpenerSet
&
&
!
triggeringPrincipalIsSystemPrincipal
)
{
flags
|
=
INTERNAL_LOAD_FLAGS_NO_OPENER
;
}
if
(
aNoOpenerImplied
)
{
flags
|
=
INTERNAL_LOAD_FLAGS_NO_OPENER
;
}
}
RefPtr
<
Document
>
referrerDoc
=
aContent
-
>
OwnerDoc
(
)
;
nsPIDOMWindowInner
*
referrerInner
=
referrerDoc
-
>
GetInnerWindow
(
)
;
if
(
!
mScriptGlobal
|
|
!
referrerInner
|
|
mScriptGlobal
-
>
GetCurrentInnerWindow
(
)
!
=
referrerInner
)
{
return
NS_OK
;
}
nsAutoString
typeHint
;
RefPtr
<
HTMLAnchorElement
>
anchor
=
HTMLAnchorElement
:
:
FromNode
(
aContent
)
;
if
(
anchor
)
{
anchor
-
>
GetType
(
typeHint
)
;
NS_ConvertUTF16toUTF8
utf8Hint
(
typeHint
)
;
nsAutoCString
type
dummy
;
NS_ParseRequestContentType
(
utf8Hint
type
dummy
)
;
CopyUTF8toUTF16
(
type
typeHint
)
;
}
bool
inOnLoadHandler
=
false
;
GetIsExecutingOnLoadHandler
(
&
inOnLoadHandler
)
;
uint32_t
loadType
=
inOnLoadHandler
?
LOAD_NORMAL_REPLACE
:
LOAD_LINK
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
elementCanHaveNoopener
?
new
ReferrerInfo
(
*
aContent
-
>
AsElement
(
)
)
:
new
ReferrerInfo
(
*
referrerDoc
)
;
RefPtr
<
WindowContext
>
context
=
mBrowsingContext
-
>
GetCurrentWindowContext
(
)
;
aLoadState
-
>
SetTriggeringSandboxFlags
(
triggeringSandboxFlags
)
;
aLoadState
-
>
SetReferrerInfo
(
referrerInfo
)
;
aLoadState
-
>
SetInternalLoadFlags
(
flags
)
;
aLoadState
-
>
SetTypeHint
(
NS_ConvertUTF16toUTF8
(
typeHint
)
)
;
aLoadState
-
>
SetLoadType
(
loadType
)
;
aLoadState
-
>
SetSourceBrowsingContext
(
mBrowsingContext
)
;
aLoadState
-
>
SetHasValidUserGestureActivation
(
context
&
&
context
-
>
HasValidTransientUserGestureActivation
(
)
)
;
nsresult
rv
=
InternalLoad
(
aLoadState
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsPingListener
:
:
DispatchPings
(
this
aContent
aLoadState
-
>
URI
(
)
referrerInfo
)
;
}
return
rv
;
}
nsresult
nsDocShell
:
:
OnOverLink
(
nsIContent
*
aContent
nsIURI
*
aURI
const
nsAString
&
aTargetSpec
)
{
if
(
aContent
-
>
IsEditable
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIWebBrowserChrome
>
browserChrome
=
do_GetInterface
(
mTreeOwner
)
;
if
(
!
browserChrome
)
{
return
rv
;
}
nsCOMPtr
<
nsIURI
>
exposableURI
=
nsIOService
:
:
CreateExposableURI
(
aURI
)
;
nsAutoCString
spec
;
rv
=
exposableURI
-
>
GetDisplaySpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ConvertUTF8toUTF16
uStr
(
spec
)
;
PredictorPredict
(
aURI
mCurrentURI
nsINetworkPredictor
:
:
PREDICT_LINK
aContent
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
nullptr
)
;
rv
=
browserChrome
-
>
SetLinkStatus
(
uStr
)
;
return
rv
;
}
nsresult
nsDocShell
:
:
OnLeaveLink
(
)
{
nsCOMPtr
<
nsIWebBrowserChrome
>
browserChrome
(
do_GetInterface
(
mTreeOwner
)
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
if
(
browserChrome
)
{
rv
=
browserChrome
-
>
SetLinkStatus
(
u
"
"
_ns
)
;
}
return
rv
;
}
bool
nsDocShell
:
:
ShouldBlockLoadingForBackButton
(
)
{
if
(
!
(
mLoadType
&
LOAD_CMD_HISTORY
)
|
|
UserActivation
:
:
IsHandlingUserInput
(
)
|
|
!
Preferences
:
:
GetBool
(
"
accessibility
.
blockjsredirection
"
)
)
{
return
false
;
}
bool
canGoForward
=
false
;
GetCanGoForward
(
&
canGoForward
)
;
return
canGoForward
;
}
bool
nsDocShell
:
:
PluginsAllowedInCurrentDoc
(
)
{
if
(
!
mContentViewer
)
{
return
false
;
}
Document
*
doc
=
mContentViewer
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
false
;
}
return
doc
-
>
GetAllowPlugins
(
)
;
}
nsresult
nsDocShell
:
:
CharsetChangeReloadDocument
(
mozilla
:
:
NotNull
<
const
mozilla
:
:
Encoding
*
>
aEncoding
int32_t
aSource
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
;
NS_ENSURE_SUCCESS
(
GetContentViewer
(
getter_AddRefs
(
cv
)
)
NS_ERROR_FAILURE
)
;
if
(
cv
)
{
int32_t
source
;
Unused
<
<
cv
-
>
GetReloadEncodingAndSource
(
&
source
)
;
if
(
aSource
>
source
)
{
cv
-
>
SetReloadEncodingAndSource
(
aEncoding
aSource
)
;
if
(
eCharsetReloadRequested
!
=
mCharsetReloadState
)
{
mCharsetReloadState
=
eCharsetReloadRequested
;
switch
(
mLoadType
)
{
case
LOAD_RELOAD_BYPASS_PROXY_AND_CACHE
:
return
Reload
(
LOAD_FLAGS_CHARSET_CHANGE
|
LOAD_FLAGS_BYPASS_CACHE
|
LOAD_FLAGS_BYPASS_PROXY
)
;
case
LOAD_RELOAD_BYPASS_CACHE
:
return
Reload
(
LOAD_FLAGS_CHARSET_CHANGE
|
LOAD_FLAGS_BYPASS_CACHE
)
;
default
:
return
Reload
(
LOAD_FLAGS_CHARSET_CHANGE
)
;
}
}
}
}
return
NS_ERROR_DOCSHELL_REQUEST_REJECTED
;
}
nsresult
nsDocShell
:
:
CharsetChangeStopDocumentLoad
(
)
{
if
(
eCharsetReloadRequested
!
=
mCharsetReloadState
)
{
Stop
(
nsIWebNavigation
:
:
STOP_ALL
)
;
return
NS_OK
;
}
return
NS_ERROR_DOCSHELL_REQUEST_REJECTED
;
}
NS_IMETHODIMP
nsDocShell
:
:
ExitPrintPreview
(
)
{
#
if
NS_PRINT_PREVIEW
nsCOMPtr
<
nsIWebBrowserPrint
>
viewer
=
do_QueryInterface
(
mContentViewer
)
;
return
viewer
-
>
ExitPrintPreview
(
)
;
#
else
return
NS_OK
;
#
endif
}
NS_IMETHODIMP
nsDocShell
:
:
GetIsTopLevelContentDocShell
(
bool
*
aIsTopLevelContentDocShell
)
{
*
aIsTopLevelContentDocShell
=
false
;
if
(
mItemType
=
=
typeContent
)
{
*
aIsTopLevelContentDocShell
=
mBrowsingContext
-
>
IsTopContent
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetScriptableOriginAttributes
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
)
{
return
mBrowsingContext
-
>
GetScriptableOriginAttributes
(
aCx
aVal
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetOriginAttributes
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
)
{
return
mBrowsingContext
-
>
GetScriptableOriginAttributes
(
aCx
aVal
)
;
}
bool
nsDocShell
:
:
ServiceWorkerAllowedToControlWindow
(
nsIPrincipal
*
aPrincipal
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
aURI
)
;
if
(
UsePrivateBrowsing
(
)
|
|
mBrowsingContext
-
>
GetSandboxFlags
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
GetInProcessSameTypeParent
(
getter_AddRefs
(
parent
)
)
;
nsPIDOMWindowOuter
*
parentOuter
=
parent
?
parent
-
>
GetWindow
(
)
:
nullptr
;
nsPIDOMWindowInner
*
parentInner
=
parentOuter
?
parentOuter
-
>
GetCurrentInnerWindow
(
)
:
nullptr
;
StorageAccess
storage
=
StorageAllowedForNewWindow
(
aPrincipal
aURI
parentInner
)
;
if
(
StaticPrefs
:
:
privacy_partition_serviceWorkers
(
)
&
&
parentInner
)
{
RefPtr
<
Document
>
doc
=
parentInner
-
>
GetExtantDoc
(
)
;
if
(
doc
&
&
StoragePartitioningEnabled
(
storage
doc
-
>
CookieJarSettings
(
)
)
)
{
return
true
;
}
}
return
storage
=
=
StorageAccess
:
:
eAllow
;
}
nsresult
nsDocShell
:
:
SetOriginAttributes
(
const
OriginAttributes
&
aAttrs
)
{
MOZ_ASSERT
(
!
mIsBeingDestroyed
)
;
return
mBrowsingContext
-
>
SetOriginAttributes
(
aAttrs
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
ResumeRedirectedLoad
(
uint64_t
aIdentifier
int32_t
aHistoryIndex
)
{
RefPtr
<
nsDocShell
>
self
=
this
;
RefPtr
<
ChildProcessChannelListener
>
cpcl
=
ChildProcessChannelListener
:
:
GetSingleton
(
)
;
cpcl
-
>
RegisterCallback
(
aIdentifier
[
self
aHistoryIndex
]
(
nsDocShellLoadState
*
aLoadState
nsTArray
<
Endpoint
<
extensions
:
:
PStreamFilterParent
>
>
&
&
aStreamFilterEndpoints
nsDOMNavigationTiming
*
aTiming
)
{
MOZ_ASSERT
(
aLoadState
-
>
GetPendingRedirectedChannel
(
)
)
;
if
(
NS_WARN_IF
(
self
-
>
mIsBeingDestroyed
)
)
{
aLoadState
-
>
GetPendingRedirectedChannel
(
)
-
>
CancelWithReason
(
NS_BINDING_ABORTED
"
nsDocShell
:
:
mIsBeingDestroyed
"
_ns
)
;
return
NS_BINDING_ABORTED
;
}
self
-
>
mLoadType
=
aLoadState
-
>
LoadType
(
)
;
nsCOMPtr
<
nsIURI
>
previousURI
;
uint32_t
previousFlags
=
0
;
ExtractLastVisit
(
aLoadState
-
>
GetPendingRedirectedChannel
(
)
getter_AddRefs
(
previousURI
)
&
previousFlags
)
;
self
-
>
SaveLastVisit
(
aLoadState
-
>
GetPendingRedirectedChannel
(
)
previousURI
previousFlags
)
;
if
(
aTiming
)
{
self
-
>
mTiming
=
new
nsDOMNavigationTiming
(
self
aTiming
)
;
self
-
>
mBlankTiming
=
false
;
}
if
(
aHistoryIndex
>
=
0
&
&
self
-
>
GetSessionHistory
(
)
&
&
!
mozilla
:
:
SessionHistoryInParent
(
)
)
{
nsCOMPtr
<
nsISHistory
>
legacySHistory
=
self
-
>
GetSessionHistory
(
)
-
>
LegacySHistory
(
)
;
nsCOMPtr
<
nsISHEntry
>
entry
;
nsresult
rv
=
legacySHistory
-
>
GetEntryAtIndex
(
aHistoryIndex
getter_AddRefs
(
entry
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
legacySHistory
-
>
InternalSetRequestedIndex
(
aHistoryIndex
)
;
aLoadState
-
>
SetLoadType
(
LOAD_HISTORY
)
;
aLoadState
-
>
SetSHEntry
(
entry
)
;
}
}
self
-
>
InternalLoad
(
aLoadState
)
;
if
(
aLoadState
-
>
GetOriginalURIString
(
)
.
isSome
(
)
)
{
self
-
>
mOriginalUriString
=
*
aLoadState
-
>
GetOriginalURIString
(
)
;
}
for
(
auto
&
endpoint
:
aStreamFilterEndpoints
)
{
extensions
:
:
StreamFilterParent
:
:
Attach
(
aLoadState
-
>
GetPendingRedirectedChannel
(
)
std
:
:
move
(
endpoint
)
)
;
}
bool
pending
=
false
;
aLoadState
-
>
GetPendingRedirectedChannel
(
)
-
>
IsPending
(
&
pending
)
;
NS_ASSERTION
(
pending
"
We
should
have
connected
the
pending
channel
!
"
)
;
if
(
!
pending
)
{
return
NS_BINDING_ABORTED
;
}
return
NS_OK
;
}
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
SetOriginAttributes
(
JS
:
:
Handle
<
JS
:
:
Value
>
aOriginAttributes
JSContext
*
aCx
)
{
OriginAttributes
attrs
;
if
(
!
aOriginAttributes
.
isObject
(
)
|
|
!
attrs
.
Init
(
aCx
aOriginAttributes
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
SetOriginAttributes
(
attrs
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetAsyncPanZoomEnabled
(
bool
*
aOut
)
{
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
*
aOut
=
presShell
-
>
AsyncPanZoomEnabled
(
)
;
return
NS_OK
;
}
*
aOut
=
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
;
return
NS_OK
;
}
bool
nsDocShell
:
:
HasUnloadedParent
(
)
{
for
(
WindowContext
*
wc
=
GetBrowsingContext
(
)
-
>
GetParentWindowContext
(
)
;
wc
;
wc
=
wc
-
>
GetParentWindowContext
(
)
)
{
if
(
!
wc
-
>
IsCurrent
(
)
|
|
wc
-
>
IsDiscarded
(
)
|
|
wc
-
>
GetBrowsingContext
(
)
-
>
IsDiscarded
(
)
)
{
return
true
;
}
if
(
wc
-
>
GetBrowsingContext
(
)
-
>
IsInProcess
(
)
&
&
(
!
wc
-
>
GetBrowsingContext
(
)
-
>
GetDocShell
(
)
|
|
wc
-
>
GetBrowsingContext
(
)
-
>
GetDocShell
(
)
-
>
GetIsInUnload
(
)
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsDocShell
:
:
ShouldUpdateGlobalHistory
(
uint32_t
aLoadType
)
{
return
!
(
aLoadType
=
=
LOAD_BYPASS_HISTORY
|
|
aLoadType
=
=
LOAD_ERROR_PAGE
|
|
aLoadType
&
LOAD_CMD_HISTORY
)
;
}
void
nsDocShell
:
:
UpdateGlobalHistoryTitle
(
nsIURI
*
aURI
)
{
if
(
!
mBrowsingContext
-
>
GetUseGlobalHistory
(
)
|
|
UsePrivateBrowsing
(
)
)
{
return
;
}
if
(
IsSubframe
(
)
)
{
return
;
}
if
(
nsCOMPtr
<
IHistory
>
history
=
components
:
:
History
:
:
Service
(
)
)
{
history
-
>
SetURITitle
(
aURI
mTitle
)
;
}
}
bool
nsDocShell
:
:
IsInvisible
(
)
{
return
mInvisible
;
}
void
nsDocShell
:
:
SetInvisible
(
bool
aInvisible
)
{
mInvisible
=
aInvisible
;
}
void
nsDocShell
:
:
NotifyJSRunToCompletionStart
(
const
char
*
aReason
const
nsAString
&
aFunctionName
const
nsAString
&
aFilename
const
uint32_t
aLineNumber
JS
:
:
Handle
<
JS
:
:
Value
>
aAsyncStack
const
char
*
aAsyncCause
)
{
if
(
mJSRunToCompletionDepth
=
=
0
&
&
TimelineConsumers
:
:
HasConsumer
(
this
)
)
{
TimelineConsumers
:
:
AddMarkerForDocShell
(
this
mozilla
:
:
MakeUnique
<
JavascriptTimelineMarker
>
(
aReason
aFunctionName
aFilename
aLineNumber
MarkerTracingType
:
:
START
aAsyncStack
aAsyncCause
)
)
;
}
mJSRunToCompletionDepth
+
+
;
}
void
nsDocShell
:
:
NotifyJSRunToCompletionStop
(
)
{
mJSRunToCompletionDepth
-
-
;
if
(
mJSRunToCompletionDepth
=
=
0
&
&
TimelineConsumers
:
:
HasConsumer
(
this
)
)
{
TimelineConsumers
:
:
AddMarkerForDocShell
(
this
"
Javascript
"
MarkerTracingType
:
:
END
)
;
}
}
void
nsDocShell
:
:
MaybeNotifyKeywordSearchLoading
(
const
nsString
&
aProvider
const
nsString
&
aKeyword
)
{
if
(
aProvider
.
IsEmpty
(
)
)
{
return
;
}
nsresult
rv
;
nsCOMPtr
<
nsISupportsString
>
isupportsString
=
do_CreateInstance
(
NS_SUPPORTS_STRING_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
rv
=
isupportsString
-
>
SetData
(
aProvider
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
NotifyObservers
(
isupportsString
"
keyword
-
search
"
aKeyword
.
get
(
)
)
;
}
}
NS_IMETHODIMP
nsDocShell
:
:
ShouldPrepareForIntercept
(
nsIURI
*
aURI
nsIChannel
*
aChannel
bool
*
aShouldIntercept
)
{
return
mInterceptController
-
>
ShouldPrepareForIntercept
(
aURI
aChannel
aShouldIntercept
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
ChannelIntercepted
(
nsIInterceptedChannel
*
aChannel
)
{
return
mInterceptController
-
>
ChannelIntercepted
(
aChannel
)
;
}
bool
nsDocShell
:
:
InFrameSwap
(
)
{
RefPtr
<
nsDocShell
>
shell
=
this
;
do
{
if
(
shell
-
>
mInFrameSwap
)
{
return
true
;
}
shell
=
shell
-
>
GetInProcessParentDocshell
(
)
;
}
while
(
shell
)
;
return
false
;
}
UniquePtr
<
ClientSource
>
nsDocShell
:
:
TakeInitialClientSource
(
)
{
return
std
:
:
move
(
mInitialClientSource
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetEditingSession
(
nsIEditingSession
*
*
aEditSession
)
{
if
(
!
NS_SUCCEEDED
(
EnsureEditorData
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aEditSession
=
do_AddRef
(
mEditorData
-
>
GetEditingSession
(
)
)
.
take
(
)
;
return
*
aEditSession
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetScriptableBrowserChild
(
nsIBrowserChild
*
*
aBrowserChild
)
{
*
aBrowserChild
=
GetBrowserChild
(
)
.
take
(
)
;
return
*
aBrowserChild
?
NS_OK
:
NS_ERROR_FAILURE
;
}
already_AddRefed
<
nsIBrowserChild
>
nsDocShell
:
:
GetBrowserChild
(
)
{
nsCOMPtr
<
nsIBrowserChild
>
tc
=
do_QueryReferent
(
mBrowserChild
)
;
return
tc
.
forget
(
)
;
}
nsCommandManager
*
nsDocShell
:
:
GetCommandManager
(
)
{
NS_ENSURE_SUCCESS
(
EnsureCommandHandler
(
)
nullptr
)
;
return
mCommandManager
;
}
NS_IMETHODIMP_
(
void
)
nsDocShell
:
:
GetOriginAttributes
(
mozilla
:
:
OriginAttributes
&
aAttrs
)
{
mBrowsingContext
-
>
GetOriginAttributes
(
aAttrs
)
;
}
HTMLEditor
*
nsIDocShell
:
:
GetHTMLEditor
(
)
{
nsDocShell
*
docShell
=
static_cast
<
nsDocShell
*
>
(
this
)
;
return
docShell
-
>
GetHTMLEditorInternal
(
)
;
}
nsresult
nsIDocShell
:
:
SetHTMLEditor
(
HTMLEditor
*
aHTMLEditor
)
{
nsDocShell
*
docShell
=
static_cast
<
nsDocShell
*
>
(
this
)
;
return
docShell
-
>
SetHTMLEditorInternal
(
aHTMLEditor
)
;
}
#
define
MATRIX_LENGTH
20
NS_IMETHODIMP
nsDocShell
:
:
SetColorMatrix
(
const
nsTArray
<
float
>
&
aMatrix
)
{
if
(
aMatrix
.
Length
(
)
=
=
MATRIX_LENGTH
)
{
mColorMatrix
.
reset
(
new
gfx
:
:
Matrix5x4
(
)
)
;
static_assert
(
MATRIX_LENGTH
*
sizeof
(
float
)
=
=
sizeof
(
mColorMatrix
-
>
components
)
"
Size
mismatch
for
our
memcpy
"
)
;
memcpy
(
mColorMatrix
-
>
components
aMatrix
.
Elements
(
)
sizeof
(
mColorMatrix
-
>
components
)
)
;
}
else
if
(
aMatrix
.
Length
(
)
=
=
0
)
{
mColorMatrix
.
reset
(
)
;
}
else
{
return
NS_ERROR_INVALID_ARG
;
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
NS_ERROR_FAILURE
;
}
nsIFrame
*
frame
=
presShell
-
>
GetRootFrame
(
)
;
if
(
!
frame
)
{
return
NS_ERROR_FAILURE
;
}
frame
-
>
SchedulePaint
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetColorMatrix
(
nsTArray
<
float
>
&
aMatrix
)
{
if
(
mColorMatrix
)
{
aMatrix
.
SetLength
(
MATRIX_LENGTH
)
;
static_assert
(
MATRIX_LENGTH
*
sizeof
(
float
)
=
=
sizeof
(
mColorMatrix
-
>
components
)
"
Size
mismatch
for
our
memcpy
"
)
;
memcpy
(
aMatrix
.
Elements
(
)
mColorMatrix
-
>
components
MATRIX_LENGTH
*
sizeof
(
float
)
)
;
}
return
NS_OK
;
}
#
undef
MATRIX_LENGTH
NS_IMETHODIMP
nsDocShell
:
:
GetIsForceReloading
(
bool
*
aForceReload
)
{
*
aForceReload
=
IsForceReloading
(
)
;
return
NS_OK
;
}
bool
nsDocShell
:
:
IsForceReloading
(
)
{
return
IsForceReloadType
(
mLoadType
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
GetBrowsingContextXPCOM
(
BrowsingContext
*
*
aBrowsingContext
)
{
*
aBrowsingContext
=
do_AddRef
(
mBrowsingContext
)
.
take
(
)
;
return
NS_OK
;
}
BrowsingContext
*
nsDocShell
:
:
GetBrowsingContext
(
)
{
return
mBrowsingContext
;
}
bool
nsDocShell
:
:
GetIsAttemptingToNavigate
(
)
{
if
(
mDocumentRequest
)
{
return
true
;
}
if
(
!
mLoadGroup
)
{
return
false
;
}
nsCOMPtr
<
nsISimpleEnumerator
>
requests
;
mLoadGroup
-
>
GetRequests
(
getter_AddRefs
(
requests
)
)
;
bool
hasMore
=
false
;
while
(
NS_SUCCEEDED
(
requests
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
elem
;
requests
-
>
GetNext
(
getter_AddRefs
(
elem
)
)
;
nsCOMPtr
<
nsIScriptChannel
>
scriptChannel
(
do_QueryInterface
(
elem
)
)
;
if
(
!
scriptChannel
)
{
continue
;
}
if
(
scriptChannel
-
>
GetIsDocumentLoad
(
)
)
{
return
true
;
}
}
return
mCheckingSessionHistory
;
}
void
nsDocShell
:
:
SetLoadingSessionHistoryInfo
(
const
mozilla
:
:
dom
:
:
LoadingSessionHistoryInfo
&
aLoadingInfo
bool
aNeedToReportActiveAfterLoadingBecomesActive
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
Setting
the
loading
entry
on
nsDocShell
%
p
to
%
s
"
this
aLoadingInfo
.
mInfo
.
GetURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
mLoadingEntry
=
MakeUnique
<
LoadingSessionHistoryInfo
>
(
aLoadingInfo
)
;
mNeedToReportActiveAfterLoadingBecomesActive
=
aNeedToReportActiveAfterLoadingBecomesActive
;
}
void
nsDocShell
:
:
MoveLoadingToActiveEntry
(
bool
aPersist
bool
aExpired
uint32_t
aCacheKey
nsIURI
*
aPreviousURI
)
{
MOZ_ASSERT
(
mozilla
:
:
SessionHistoryInParent
(
)
)
;
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
nsDocShell
%
p
MoveLoadingToActiveEntry
"
this
)
)
;
bool
hadActiveEntry
=
!
!
mActiveEntry
;
mActiveEntry
=
nullptr
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
dom
:
:
LoadingSessionHistoryInfo
>
loadingEntry
;
mActiveEntryIsLoadingFromSessionHistory
=
mLoadingEntry
&
&
mLoadingEntry
-
>
mLoadIsFromSessionHistory
;
if
(
mLoadingEntry
)
{
MOZ_LOG
(
gSHLog
LogLevel
:
:
Debug
(
"
Moving
the
loading
entry
to
the
active
entry
on
nsDocShell
%
p
"
"
to
%
s
"
this
mLoadingEntry
-
>
mInfo
.
GetURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
mActiveEntry
=
MakeUnique
<
SessionHistoryInfo
>
(
mLoadingEntry
-
>
mInfo
)
;
mLoadingEntry
.
swap
(
loadingEntry
)
;
if
(
!
mActiveEntryIsLoadingFromSessionHistory
)
{
if
(
mNeedToReportActiveAfterLoadingBecomesActive
)
{
mBrowsingContext
-
>
SetActiveSessionHistoryEntry
(
mozilla
:
:
Nothing
(
)
mActiveEntry
.
get
(
)
mLoadType
0
false
)
;
}
mBrowsingContext
-
>
IncrementHistoryEntryCountForBrowsingContext
(
)
;
}
}
mNeedToReportActiveAfterLoadingBecomesActive
=
false
;
if
(
mActiveEntry
)
{
if
(
aCacheKey
!
=
0
)
{
mActiveEntry
-
>
SetCacheKey
(
aCacheKey
)
;
}
MOZ_ASSERT
(
loadingEntry
)
;
uint32_t
loadType
=
mLoadType
=
=
LOAD_ERROR_PAGE
?
mFailedLoadType
:
mLoadType
;
if
(
loadingEntry
-
>
mLoadId
!
=
UINT64_MAX
)
{
mBrowsingContext
-
>
SessionHistoryCommit
(
*
loadingEntry
loadType
aPreviousURI
hadActiveEntry
aPersist
false
aExpired
aCacheKey
)
;
}
}
}
static
bool
IsFaviconLoad
(
nsIRequest
*
aRequest
)
{
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
if
(
!
channel
)
{
return
false
;
}
nsCOMPtr
<
nsILoadInfo
>
li
=
channel
-
>
LoadInfo
(
)
;
return
li
&
&
li
-
>
InternalContentPolicyType
(
)
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
;
}
void
nsDocShell
:
:
RecordSingleChannelId
(
bool
aStartRequest
nsIRequest
*
aRequest
)
{
if
(
IsFaviconLoad
(
aRequest
)
)
{
return
;
}
MOZ_ASSERT_IF
(
!
aStartRequest
mRequestForBlockingFromBFCacheCount
>
0
)
;
mRequestForBlockingFromBFCacheCount
+
=
aStartRequest
?
1
:
-
1
;
if
(
mBrowsingContext
-
>
GetCurrentWindowContext
(
)
)
{
Maybe
<
uint64_t
>
singleChannelId
;
if
(
mRequestForBlockingFromBFCacheCount
>
1
)
{
singleChannelId
=
Some
(
0
)
;
}
else
if
(
mRequestForBlockingFromBFCacheCount
=
=
1
)
{
nsCOMPtr
<
nsIIdentChannel
>
identChannel
;
if
(
aStartRequest
)
{
identChannel
=
do_QueryInterface
(
aRequest
)
;
}
else
{
nsCOMPtr
<
nsISimpleEnumerator
>
requests
;
mLoadGroup
-
>
GetRequests
(
getter_AddRefs
(
requests
)
)
;
for
(
const
auto
&
request
:
SimpleEnumerator
<
nsIRequest
>
(
requests
)
)
{
if
(
!
IsFaviconLoad
(
request
)
&
&
!
!
(
identChannel
=
do_QueryInterface
(
request
)
)
)
{
break
;
}
}
}
if
(
identChannel
)
{
singleChannelId
=
Some
(
identChannel
-
>
ChannelId
(
)
)
;
}
else
{
singleChannelId
=
Some
(
0
)
;
}
}
else
{
MOZ_ASSERT
(
mRequestForBlockingFromBFCacheCount
=
=
0
)
;
singleChannelId
=
Nothing
(
)
;
}
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
gSHIPBFCacheLog
LogLevel
:
:
Verbose
)
)
)
{
nsAutoCString
uri
(
"
[
no
uri
]
"
)
;
if
(
mCurrentURI
)
{
uri
=
mCurrentURI
-
>
GetSpecOrDefault
(
)
;
}
if
(
singleChannelId
.
isNothing
(
)
)
{
MOZ_LOG
(
gSHIPBFCacheLog
LogLevel
:
:
Verbose
(
"
Loadgroup
for
%
s
doesn
'
t
have
any
requests
relevant
for
"
"
blocking
BFCache
"
uri
.
get
(
)
)
)
;
}
else
if
(
singleChannelId
.
value
(
)
=
=
0
)
{
MOZ_LOG
(
gSHIPBFCacheLog
LogLevel
:
:
Verbose
(
"
Loadgroup
for
%
s
has
multiple
requests
relevant
for
blocking
"
"
BFCache
"
uri
.
get
(
)
)
)
;
}
else
{
MOZ_LOG
(
gSHIPBFCacheLog
LogLevel
:
:
Verbose
(
"
Loadgroup
for
%
s
has
one
request
with
id
%
"
PRIu64
"
relevant
for
blocking
BFCache
"
uri
.
get
(
)
singleChannelId
.
value
(
)
)
)
;
}
}
if
(
mSingleChannelId
!
=
singleChannelId
)
{
mSingleChannelId
=
singleChannelId
;
WindowGlobalChild
*
wgc
=
mBrowsingContext
-
>
GetCurrentWindowContext
(
)
-
>
GetWindowGlobalChild
(
)
;
if
(
wgc
)
{
wgc
-
>
SendSetSingleChannelId
(
singleChannelId
)
;
}
}
}
}
NS_IMETHODIMP
nsDocShell
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
gSHIPBFCacheLog
LogLevel
:
:
Verbose
)
)
)
{
nsAutoCString
uri
(
"
[
no
uri
]
"
)
;
if
(
mCurrentURI
)
{
uri
=
mCurrentURI
-
>
GetSpecOrDefault
(
)
;
}
nsAutoCString
name
;
aRequest
-
>
GetName
(
name
)
;
MOZ_LOG
(
gSHIPBFCacheLog
LogLevel
:
:
Verbose
(
"
Adding
request
%
s
to
loadgroup
for
%
s
"
name
.
get
(
)
uri
.
get
(
)
)
)
;
}
RecordSingleChannelId
(
true
aRequest
)
;
return
nsDocLoader
:
:
OnStartRequest
(
aRequest
)
;
}
NS_IMETHODIMP
nsDocShell
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
aStatusCode
)
{
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
gSHIPBFCacheLog
LogLevel
:
:
Verbose
)
)
)
{
nsAutoCString
uri
(
"
[
no
uri
]
"
)
;
if
(
mCurrentURI
)
{
uri
=
mCurrentURI
-
>
GetSpecOrDefault
(
)
;
}
nsAutoCString
name
;
aRequest
-
>
GetName
(
name
)
;
MOZ_LOG
(
gSHIPBFCacheLog
LogLevel
:
:
Verbose
(
"
Removing
request
%
s
from
loadgroup
for
%
s
"
name
.
get
(
)
uri
.
get
(
)
)
)
;
}
RecordSingleChannelId
(
false
aRequest
)
;
return
nsDocLoader
:
:
OnStopRequest
(
aRequest
aStatusCode
)
;
}
void
nsDocShell
:
:
MaybeDisconnectChildListenersOnPageHide
(
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsContentProcess
(
)
)
;
if
(
mChannelToDisconnectOnPageHide
!
=
0
&
&
mLoadGroup
)
{
nsCOMPtr
<
nsISimpleEnumerator
>
requests
;
mLoadGroup
-
>
GetRequests
(
getter_AddRefs
(
requests
)
)
;
for
(
const
auto
&
request
:
SimpleEnumerator
<
nsIRequest
>
(
requests
)
)
{
RefPtr
<
DocumentChannel
>
channel
=
do_QueryObject
(
request
)
;
if
(
channel
&
&
channel
-
>
ChannelId
(
)
=
=
mChannelToDisconnectOnPageHide
)
{
static_cast
<
DocumentChannelChild
*
>
(
channel
.
get
(
)
)
-
>
DisconnectChildListeners
(
NS_BINDING_ABORTED
NS_BINDING_ABORTED
)
;
}
}
mChannelToDisconnectOnPageHide
=
0
;
}
}
