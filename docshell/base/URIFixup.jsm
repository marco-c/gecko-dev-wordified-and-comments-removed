var
EXPORTED_SYMBOLS
=
[
"
URIFixup
"
"
URIFixupInfo
"
]
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
externalProtocolService
"
"
mozilla
.
org
/
uriloader
/
external
-
protocol
-
service
;
1
"
"
nsIExternalProtocolService
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
defaultProtocolHandler
"
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
default
"
"
nsIProtocolHandler
"
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
fixupSchemeTypos
"
"
browser
.
fixup
.
typo
.
scheme
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
dnsFirstForSingleWords
"
"
browser
.
fixup
.
dns_first_for_single_words
"
false
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
keywordEnabled
"
"
keyword
.
enabled
"
true
)
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
this
"
alternateEnabled
"
"
browser
.
fixup
.
alternate
.
enabled
"
true
)
;
const
{
FIXUP_FLAG_NONE
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
FIXUP_FLAGS_MAKE_ALTERNATE_URI
FIXUP_FLAG_PRIVATE_CONTEXT
FIXUP_FLAG_FIX_SCHEME_TYPOS
}
=
Ci
.
nsIURIFixup
;
const
COMMON_PROTOCOLS
=
[
"
http
"
"
https
"
"
ftp
"
"
file
"
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
userPasswordRegex
"
(
)
=
>
/
^
(
[
a
-
z
+
.
-
]
+
:
\
/
{
0
3
}
)
*
[
^
\
/
]
+
.
+
/
i
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
asciiAlphaRegex
"
(
)
=
>
/
^
[
a
-
z
]
/
i
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
asciiHexRegex
"
(
)
=
>
/
^
[
a
-
f0
-
9
]
/
i
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
asciiDigitRegex
"
(
)
=
>
/
^
[
0
-
9
]
/
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
maxOneTabRegex
"
(
)
=
>
/
^
[
^
\
t
]
*
\
t
?
[
^
\
t
]
*
/
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
possiblyHostPortRegex
"
(
)
=
>
/
^
[
a
-
z0
-
9
-
]
+
(
\
.
[
a
-
z0
-
9
-
]
+
)
*
:
[
0
-
9
]
{
1
5
}
(
[
/
?
#
]
|
)
/
i
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
newLinesRegex
"
(
)
=
>
/
[
\
r
\
n
]
/
g
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
possibleProtocolRegex
"
(
)
=
>
/
^
(
[
a
-
z
]
[
a
-
z0
-
9
.
+
\
t
-
]
*
)
:
/
i
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
domainsWhitelist
"
(
)
=
>
{
let
domains
=
new
Set
(
Services
.
prefs
.
getChildList
(
"
browser
.
fixup
.
domainwhitelist
.
"
)
.
filter
(
p
=
>
Services
.
prefs
.
getBoolPref
(
p
false
)
)
.
map
(
p
=
>
p
.
substring
(
30
)
)
)
;
domains
.
_observer
=
{
observe
(
subject
topic
data
)
{
let
domain
=
data
.
substring
(
30
)
;
if
(
Services
.
prefs
.
getBoolPref
(
data
false
)
)
{
domains
.
add
(
domain
)
;
}
else
{
domains
.
delete
(
domain
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
Services
.
prefs
.
addObserver
(
"
browser
.
fixup
.
domainwhitelist
.
"
domains
.
_observer
true
)
;
return
domains
;
}
)
;
function
URIFixup
(
)
{
}
URIFixup
.
prototype
=
{
get
FIXUP_FLAG_NONE
(
)
{
return
FIXUP_FLAG_NONE
;
}
get
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
(
)
{
return
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
;
}
get
FIXUP_FLAGS_MAKE_ALTERNATE_URI
(
)
{
return
FIXUP_FLAGS_MAKE_ALTERNATE_URI
;
}
get
FIXUP_FLAG_PRIVATE_CONTEXT
(
)
{
return
FIXUP_FLAG_PRIVATE_CONTEXT
;
}
get
FIXUP_FLAG_FIX_SCHEME_TYPOS
(
)
{
return
FIXUP_FLAG_FIX_SCHEME_TYPOS
;
}
createFixupURI
(
uriString
fixupFlags
=
FIXUP_FLAG_NONE
postData
)
{
return
this
.
getFixupURIInfo
(
uriString
fixupFlags
postData
)
.
preferredURI
;
}
getFixupURIInfo
(
uriString
fixupFlags
=
FIXUP_FLAG_NONE
postData
)
{
let
isPrivateContext
=
fixupFlags
&
FIXUP_FLAG_PRIVATE_CONTEXT
;
uriString
=
uriString
.
trim
(
)
.
replace
(
newLinesRegex
"
"
)
;
if
(
!
uriString
)
{
throw
new
Components
.
Exception
(
"
Should
pass
a
non
-
null
uri
"
Cr
.
NS_ERROR_FAILURE
)
;
}
let
info
=
new
URIFixupInfo
(
uriString
)
;
let
scheme
=
extractScheme
(
uriString
)
;
let
isCommonProtocol
=
COMMON_PROTOCOLS
.
includes
(
scheme
)
;
if
(
scheme
=
=
"
view
-
source
"
)
{
let
newFixupFlags
=
fixupFlags
&
~
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
&
~
FIXUP_FLAGS_MAKE_ALTERNATE_URI
;
let
innerURIString
=
uriString
.
substring
(
12
)
.
trim
(
)
;
let
innerScheme
=
extractScheme
(
innerURIString
)
;
if
(
innerScheme
=
=
"
view
-
source
"
)
{
throw
new
Components
.
Exception
(
"
Prevent
view
-
source
recursion
"
Cr
.
NS_ERROR_FAILURE
)
;
}
let
innerInfo
=
this
.
getFixupURIInfo
(
innerURIString
newFixupFlags
postData
)
;
if
(
!
innerInfo
.
preferredURI
)
{
throw
new
Components
.
Exception
(
"
No
preferredURI
"
Cr
.
NS_ERROR_FAILURE
)
;
}
info
.
fixedURI
=
Services
.
io
.
newURI
(
"
view
-
source
:
"
+
innerInfo
.
preferredURI
.
spec
)
;
info
.
preferredURI
=
info
.
fixedURI
;
return
info
;
}
if
(
scheme
.
length
<
2
)
{
let
fileURI
=
fileURIFixup
(
uriString
)
;
if
(
fileURI
)
{
info
.
fixedURI
=
info
.
preferredURI
=
fileURI
;
info
.
fixupChangedProtocol
=
true
;
return
info
;
}
}
if
(
fixupSchemeTypos
&
&
fixupFlags
&
FIXUP_FLAG_FIX_SCHEME_TYPOS
&
&
scheme
&
&
!
isCommonProtocol
)
{
for
(
let
[
typo
fixed
]
of
[
[
"
ttp
"
"
http
"
]
[
"
htp
"
"
http
"
]
[
"
ttps
"
"
https
"
]
[
"
tps
"
"
https
"
]
[
"
ps
"
"
https
"
]
[
"
htps
"
"
https
"
]
[
"
ile
"
"
file
"
]
[
"
le
"
"
file
"
]
]
)
{
if
(
uriString
.
startsWith
(
typo
)
)
{
scheme
=
fixed
;
uriString
=
scheme
+
uriString
.
substring
(
typo
.
length
)
;
isCommonProtocol
=
true
;
break
;
}
}
}
let
isDefaultProtocolHandler
=
!
isCommonProtocol
&
&
scheme
&
&
Services
.
io
.
getProtocolHandler
(
scheme
)
=
=
defaultProtocolHandler
;
if
(
!
isDefaultProtocolHandler
|
|
!
possiblyHostPortRegex
.
test
(
uriString
)
)
{
try
{
info
.
fixedURI
=
Services
.
io
.
newURI
(
uriString
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_MALFORMED_URI
)
{
throw
ex
;
}
}
}
if
(
info
.
fixedURI
&
&
isDefaultProtocolHandler
&
&
keywordEnabled
&
&
fixupFlags
&
FIXUP_FLAG_FIX_SCHEME_TYPOS
&
&
scheme
&
&
!
externalProtocolService
.
externalProtocolHandlerExists
(
scheme
)
)
{
if
(
!
userPasswordRegex
.
test
(
uriString
)
)
{
tryKeywordFixupForURIInfo
(
uriString
info
isPrivateContext
postData
)
;
}
else
{
info
.
fixedURI
=
null
;
}
}
if
(
info
.
fixedURI
)
{
if
(
!
info
.
preferredURI
)
{
if
(
fixupFlags
&
FIXUP_FLAGS_MAKE_ALTERNATE_URI
)
{
info
.
fixupCreatedAlternateURI
=
makeAlternateFixedURI
(
info
)
;
}
info
.
preferredURI
=
info
.
fixedURI
;
}
return
info
;
}
let
inputHadDuffProtocol
=
false
;
if
(
!
scheme
)
{
if
(
uriString
.
startsWith
(
"
:
/
/
"
)
)
{
uriString
=
uriString
.
substring
(
3
)
;
inputHadDuffProtocol
=
true
;
}
else
if
(
uriString
.
startsWith
(
"
/
/
"
)
)
{
uriString
=
uriString
.
substring
(
2
)
;
inputHadDuffProtocol
=
true
;
}
}
if
(
!
isCommonProtocol
&
&
maxOneTabRegex
.
test
(
uriString
)
)
{
let
uriWithProtocol
=
fixupURIProtocol
(
uriString
info
)
;
if
(
uriWithProtocol
)
{
info
.
fixedURI
=
uriWithProtocol
;
}
}
if
(
keywordEnabled
&
&
fixupFlags
&
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
&
&
!
inputHadDuffProtocol
)
{
keywordURIFixup
(
uriString
info
isPrivateContext
postData
)
;
if
(
info
.
preferredURI
)
{
return
info
;
}
}
if
(
info
.
fixedURI
&
&
fixupFlags
&
FIXUP_FLAGS_MAKE_ALTERNATE_URI
)
{
info
.
fixupCreatedAlternateURI
=
makeAlternateFixedURI
(
info
)
;
}
if
(
info
.
fixedURI
)
{
info
.
preferredURI
=
info
.
fixedURI
;
return
info
;
}
if
(
keywordEnabled
&
&
fixupFlags
&
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
)
{
tryKeywordFixupForURIInfo
(
info
.
originalInput
info
isPrivateContext
postData
)
;
}
if
(
!
info
.
preferredURI
)
{
throw
new
Components
.
Exception
(
"
Couldn
'
t
build
a
valid
uri
"
Cr
.
NS_ERROR_MALFORMED_URI
)
;
}
return
info
;
}
webNavigationFlagsToFixupFlags
(
href
navigationFlags
)
{
try
{
Services
.
io
.
newURI
(
href
)
;
navigationFlags
&
=
~
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
;
}
catch
(
ex
)
{
}
let
fixupFlags
=
FIXUP_FLAG_NONE
;
if
(
navigationFlags
&
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
)
{
fixupFlags
|
=
FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP
;
}
if
(
navigationFlags
&
Ci
.
nsIWebNavigation
.
LOAD_FLAGS_FIXUP_SCHEME_TYPOS
)
{
fixupFlags
|
=
FIXUP_FLAG_FIX_SCHEME_TYPOS
;
}
return
fixupFlags
;
}
keywordToURI
(
keyword
isPrivateContext
postData
)
{
if
(
Services
.
appinfo
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_CONTENT
)
{
throw
new
Components
.
Exception
(
"
Can
'
t
invoke
URIFixup
in
the
content
process
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
let
info
=
new
URIFixupInfo
(
keyword
)
;
if
(
keyword
.
startsWith
(
"
?
"
)
)
{
keyword
=
keyword
.
substring
(
1
)
;
}
keyword
=
keyword
.
trim
(
)
;
let
engine
=
isPrivateContext
?
Services
.
search
.
defaultPrivateEngine
:
Services
.
search
.
defaultEngine
;
let
responseType
=
null
;
if
(
engine
.
supportsResponseType
(
"
application
/
x
-
moz
-
keywordsearch
"
)
)
{
responseType
=
"
application
/
x
-
moz
-
keywordsearch
"
;
}
let
submission
=
engine
.
getSubmission
(
keyword
responseType
"
keyword
"
)
;
if
(
!
submission
)
{
throw
new
Components
.
Exception
(
"
Invalid
search
submission
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
let
submissionPostDataStream
=
submission
.
postData
;
if
(
submissionPostDataStream
)
{
if
(
postData
)
{
postData
.
value
=
submissionPostDataStream
;
}
else
{
throw
new
Components
.
Exception
(
"
Didn
'
t
request
POST
data
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
}
info
.
keywordProviderName
=
engine
.
name
;
info
.
keywordAsSent
=
keyword
;
info
.
preferredURI
=
submission
.
uri
;
return
info
;
}
isDomainWhitelisted
(
asciiHost
dotLoc
)
{
if
(
dnsFirstForSingleWords
)
{
return
true
;
}
if
(
dotLoc
=
=
asciiHost
.
length
-
1
)
{
asciiHost
=
asciiHost
.
substring
(
0
asciiHost
.
length
-
1
)
;
}
return
domainsWhitelist
.
has
(
asciiHost
)
;
}
classID
:
Components
.
ID
(
"
{
c6cf88b7
-
452e
-
47eb
-
bdc9
-
86e3561648ef
}
"
)
_xpcom_factory
:
XPCOMUtils
.
generateSingletonFactory
(
URIFixup
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIURIFixup
]
)
}
;
function
URIFixupInfo
(
originalInput
=
"
"
)
{
this
.
_originalInput
=
originalInput
;
}
URIFixupInfo
.
prototype
=
{
set
consumer
(
consumer
)
{
this
.
_consumer
=
consumer
|
|
null
;
}
get
consumer
(
)
{
return
this
.
_consumer
|
|
null
;
}
set
preferredURI
(
uri
)
{
this
.
_preferredURI
=
uri
;
}
get
preferredURI
(
)
{
return
this
.
_preferredURI
|
|
null
;
}
set
fixedURI
(
uri
)
{
this
.
_fixedURI
=
uri
;
}
get
fixedURI
(
)
{
return
this
.
_fixedURI
|
|
null
;
}
set
keywordProviderName
(
name
)
{
this
.
_keywordProviderName
=
name
;
}
get
keywordProviderName
(
)
{
return
this
.
_keywordProviderName
|
|
"
"
;
}
set
keywordAsSent
(
keyword
)
{
this
.
_keywordAsSent
=
keyword
;
}
get
keywordAsSent
(
)
{
return
this
.
_keywordAsSent
|
|
"
"
;
}
set
fixupChangedProtocol
(
changed
)
{
this
.
_fixupChangedProtocol
=
changed
;
}
get
fixupChangedProtocol
(
)
{
return
!
!
this
.
_fixupChangedProtocol
;
}
set
fixupCreatedAlternateURI
(
changed
)
{
this
.
_fixupCreatedAlternateURI
=
changed
;
}
get
fixupCreatedAlternateURI
(
)
{
return
!
!
this
.
_fixupCreatedAlternateURI
;
}
set
originalInput
(
input
)
{
this
.
_originalInput
=
input
;
}
get
originalInput
(
)
{
return
this
.
_originalInput
|
|
"
"
;
}
classID
:
Components
.
ID
(
"
{
33d75835
-
722f
-
42c0
-
89cc
-
44f328e56a86
}
"
)
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIURIFixupInfo
]
)
}
;
function
tryKeywordFixupForURIInfo
(
uriString
fixupInfo
isPrivateContext
postData
)
{
try
{
let
keywordInfo
=
Services
.
uriFixup
.
keywordToURI
(
uriString
isPrivateContext
postData
)
;
fixupInfo
.
keywordProviderName
=
keywordInfo
.
keywordProviderName
;
fixupInfo
.
keywordAsSent
=
keywordInfo
.
keywordAsSent
;
fixupInfo
.
preferredURI
=
keywordInfo
.
preferredURI
;
}
catch
(
ex
)
{
}
}
function
makeAlternateFixedURI
(
info
)
{
let
uri
=
info
.
fixedURI
;
if
(
!
alternateEnabled
|
|
!
uri
.
schemeIs
(
"
http
"
)
|
|
uri
.
userPass
|
|
uri
.
port
!
=
-
1
)
{
return
false
;
}
let
oldHost
=
uri
.
host
;
if
(
oldHost
=
=
"
localhost
"
)
{
return
false
;
}
let
numDots
=
(
oldHost
.
match
(
/
\
.
/
g
)
|
|
[
]
)
.
length
;
let
prefix
=
Services
.
prefs
.
getCharPref
(
"
browser
.
fixup
.
alternate
.
prefix
"
"
www
.
"
)
;
let
suffix
=
Services
.
prefs
.
getCharPref
(
"
browser
.
fixup
.
alternate
.
suffix
"
"
.
com
"
)
;
let
newHost
=
"
"
;
if
(
numDots
=
=
0
)
{
newHost
=
prefix
+
oldHost
+
suffix
;
}
else
if
(
numDots
=
=
1
)
{
if
(
prefix
&
&
oldHost
.
toLowerCase
(
)
=
=
prefix
)
{
newHost
=
oldHost
+
suffix
;
}
else
if
(
suffix
)
{
newHost
=
prefix
+
oldHost
;
}
}
if
(
!
newHost
)
{
return
false
;
}
try
{
info
.
fixedURI
=
uri
.
mutate
(
)
.
setHost
(
newHost
)
.
finalize
(
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
!
=
Cr
.
NS_ERROR_MALFORMED_URI
)
{
throw
ex
;
}
return
false
;
}
return
true
;
}
function
fileURIFixup
(
uriString
)
{
let
attemptFixup
=
false
;
if
(
AppConstants
.
platform
=
=
"
win
"
)
{
attemptFixup
=
uriString
.
includes
(
"
\
\
"
)
|
|
(
uriString
.
length
=
=
2
&
&
uriString
.
endsWith
(
"
:
"
)
)
;
}
else
{
attemptFixup
=
uriString
.
startsWith
(
"
/
"
)
;
}
if
(
attemptFixup
)
{
try
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
uriString
)
;
return
Services
.
io
.
newFileURI
(
file
)
;
}
catch
(
ex
)
{
}
}
return
null
;
}
function
fixupURIProtocol
(
uriString
fixupInfo
)
{
let
schemePos
=
uriString
.
indexOf
(
"
:
/
/
"
)
;
if
(
schemePos
=
=
-
1
|
|
schemePos
>
uriString
.
search
(
/
[
:
\
/
]
/
)
)
{
uriString
=
"
http
:
/
/
"
+
uriString
;
fixupInfo
.
fixupChangedProtocol
=
true
;
}
try
{
return
Services
.
io
.
newURI
(
uriString
)
;
}
catch
(
ex
)
{
}
return
null
;
}
function
keywordURIFixup
(
uriString
fixupInfo
isPrivateContext
postData
)
{
const
NOT_FOUND
=
Infinity
;
let
firstDotLoc
=
NOT_FOUND
;
let
lastDotLoc
=
NOT_FOUND
;
let
firstColonLoc
=
NOT_FOUND
;
let
firstQuoteLoc
=
NOT_FOUND
;
let
firstSpaceLoc
=
NOT_FOUND
;
let
firstQMarkLoc
=
NOT_FOUND
;
let
lastLSBracketLoc
=
NOT_FOUND
;
let
lastSlashLoc
=
NOT_FOUND
;
let
foundDots
=
0
;
let
foundColons
=
0
;
let
foundDigits
=
0
;
let
foundRSBrackets
=
0
;
let
looksLikeIpv6
=
true
;
let
hasAsciiAlpha
=
false
;
for
(
let
i
=
0
pos
=
0
;
i
<
uriString
.
length
;
+
+
i
+
+
pos
)
{
let
iter
=
uriString
[
i
]
;
if
(
pos
>
=
1
&
&
foundRSBrackets
=
=
0
)
{
if
(
!
(
lastLSBracketLoc
=
=
0
&
&
(
iter
=
=
"
:
"
|
|
iter
=
=
"
.
"
|
|
iter
=
=
"
]
"
|
|
asciiHexRegex
.
test
(
iter
)
)
)
)
{
looksLikeIpv6
=
false
;
}
}
if
(
(
i
=
=
uriString
.
length
-
1
|
|
(
lastSlashLoc
=
=
NOT_FOUND
&
&
iter
=
=
"
/
"
)
)
&
&
(
foundDots
=
=
2
|
|
foundDots
=
=
3
)
&
&
(
foundDots
+
foundDigits
=
=
pos
|
|
(
foundColons
=
=
1
&
&
firstColonLoc
>
lastDotLoc
&
&
foundDots
+
foundDigits
+
foundColons
=
=
pos
)
)
)
{
return
;
}
if
(
iter
=
=
"
.
"
)
{
foundDots
+
+
;
lastDotLoc
=
pos
;
if
(
firstDotLoc
=
=
NOT_FOUND
)
{
firstDotLoc
=
pos
;
}
}
else
if
(
iter
=
=
"
:
"
)
{
foundColons
+
+
;
if
(
firstColonLoc
=
=
NOT_FOUND
)
{
firstColonLoc
=
pos
;
}
}
else
if
(
iter
=
=
"
"
&
&
firstSpaceLoc
=
=
NOT_FOUND
)
{
firstSpaceLoc
=
pos
;
}
else
if
(
iter
=
=
"
?
"
&
&
firstQMarkLoc
=
=
NOT_FOUND
)
{
firstQMarkLoc
=
pos
;
}
else
if
(
(
iter
=
=
"
'
"
|
|
iter
=
=
'
"
'
)
&
&
firstQuoteLoc
=
=
NOT_FOUND
)
{
firstQuoteLoc
=
pos
;
}
else
if
(
iter
=
=
"
[
"
)
{
lastLSBracketLoc
=
pos
;
}
else
if
(
iter
=
=
"
]
"
)
{
foundRSBrackets
+
+
;
}
else
if
(
iter
=
=
"
/
"
)
{
lastSlashLoc
=
pos
;
}
else
if
(
asciiAlphaRegex
.
test
(
iter
)
)
{
hasAsciiAlpha
=
true
;
}
else
if
(
asciiDigitRegex
.
test
(
iter
)
)
{
foundDigits
+
+
;
}
}
if
(
lastLSBracketLoc
>
0
|
|
foundRSBrackets
!
=
1
)
{
looksLikeIpv6
=
false
;
}
if
(
looksLikeIpv6
)
{
return
;
}
let
asciiHost
=
fixupInfo
.
fixedURI
&
&
fixupInfo
.
fixedURI
.
asciiHost
;
let
displayHost
=
fixupInfo
.
fixedURI
&
&
fixupInfo
.
fixedURI
.
displayHost
;
if
(
(
(
firstSpaceLoc
<
firstDotLoc
|
|
firstQuoteLoc
<
firstDotLoc
)
&
&
(
firstSpaceLoc
<
firstColonLoc
|
|
firstQuoteLoc
<
firstColonLoc
)
&
&
(
firstSpaceLoc
<
firstQMarkLoc
|
|
firstQuoteLoc
<
firstQMarkLoc
)
)
|
|
firstQMarkLoc
=
=
0
)
{
tryKeywordFixupForURIInfo
(
fixupInfo
.
originalInput
fixupInfo
isPrivateContext
postData
)
;
}
else
if
(
asciiHost
&
&
displayHost
&
&
!
hasAsciiAlpha
&
&
asciiHost
.
toLowerCase
(
)
=
=
displayHost
.
toLowerCase
(
)
)
{
if
(
!
dnsFirstForSingleWords
)
{
tryKeywordFixupForURIInfo
(
fixupInfo
.
originalInput
fixupInfo
isPrivateContext
postData
)
;
}
}
else
if
(
(
firstDotLoc
=
=
NOT_FOUND
|
|
(
foundDots
=
=
1
&
&
(
firstDotLoc
=
=
0
|
|
firstDotLoc
=
=
uriString
.
length
-
1
)
)
)
&
&
firstColonLoc
=
=
NOT_FOUND
&
&
firstQMarkLoc
=
=
NOT_FOUND
)
{
if
(
asciiHost
&
&
Services
.
uriFixup
.
isDomainWhitelisted
(
asciiHost
firstDotLoc
)
)
{
return
;
}
if
(
firstDotLoc
=
=
NOT_FOUND
&
&
lastSlashLoc
!
=
NOT_FOUND
&
&
hasAsciiAlpha
&
&
asciiHost
)
{
return
;
}
tryKeywordFixupForURIInfo
(
fixupInfo
.
originalInput
fixupInfo
isPrivateContext
postData
)
;
}
}
function
extractScheme
(
uriString
)
{
let
matches
=
uriString
.
match
(
possibleProtocolRegex
)
;
return
matches
?
matches
[
1
]
.
replace
(
"
\
t
"
"
"
)
.
toLowerCase
(
)
:
"
"
;
}
