#
ifndef
mozilla_dom_SyncedContext_h
#
define
mozilla_dom_SyncedContext_h
#
include
"
mozilla
/
dom
/
MaybeDiscarded
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
<
utility
>
namespace
mozilla
{
namespace
ipc
{
class
IProtocol
;
class
IPCResult
;
template
<
typename
T
>
struct
IPDLParamTraits
;
}
namespace
dom
{
class
ContentParent
;
class
ContentChild
;
namespace
syncedcontext
{
template
<
size_t
I
>
using
Index
=
typename
std
:
:
integral_constant
<
size_t
I
>
;
template
<
typename
Context
>
class
Transaction
{
public
:
template
<
size_t
I
typename
U
>
void
Set
(
U
&
&
aValue
)
{
auto
&
field
=
mozilla
:
:
Get
<
I
>
(
mMaybeFields
)
;
field
.
emplace
(
std
:
:
forward
<
U
>
(
aValue
)
)
;
}
nsresult
Commit
(
Context
*
aOwner
)
;
mozilla
:
:
ipc
:
:
IPCResult
CommitFromIPC
(
const
MaybeDiscarded
<
Context
>
&
aOwner
ContentParent
*
aSource
)
;
mozilla
:
:
ipc
:
:
IPCResult
CommitFromIPC
(
const
MaybeDiscarded
<
Context
>
&
aOwner
uint64_t
aEpoch
ContentChild
*
aSource
)
;
void
Write
(
IPC
:
:
Message
*
aMsg
mozilla
:
:
ipc
:
:
IProtocol
*
aActor
)
const
;
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
mozilla
:
:
ipc
:
:
IProtocol
*
aActor
)
;
private
:
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
Transaction
<
Context
>
>
;
void
Apply
(
Context
*
aOwner
)
;
bool
Validate
(
Context
*
aOwner
ContentParent
*
aSource
)
;
using
FieldStorage
=
typename
Context
:
:
FieldStorage
;
static
FieldStorage
&
GetFieldStorage
(
Context
*
aContext
)
{
return
aContext
-
>
mFields
;
}
template
<
typename
F
>
static
void
EachIndexInner
(
Index
<
0
>
F
&
&
)
{
}
template
<
size_t
I
typename
F
>
static
void
EachIndexInner
(
Index
<
I
>
F
&
&
aCallback
)
{
aCallback
(
Index
<
I
-
1
>
(
)
)
;
EachIndexInner
(
Index
<
I
-
1
>
(
)
aCallback
)
;
}
template
<
typename
F
>
static
void
EachIndex
(
F
&
&
aCallback
)
{
EachIndexInner
(
Index
<
FieldStorage
:
:
fieldCount
>
(
)
aCallback
)
;
}
template
<
size_t
I
typename
.
.
.
Ts
>
static
auto
&
GetAt
(
Index
<
I
>
mozilla
:
:
Tuple
<
Ts
.
.
.
>
&
aTarget
)
{
return
mozilla
:
:
Get
<
I
>
(
aTarget
)
;
}
template
<
size_t
I
typename
T
size_t
L
>
static
auto
&
GetAt
(
Index
<
I
>
std
:
:
array
<
T
L
>
&
aTarget
)
{
return
std
:
:
get
<
I
>
(
aTarget
)
;
}
typename
FieldStorage
:
:
MaybeFieldTuple
mMaybeFields
;
}
;
template
<
typename
typename
.
.
.
Ts
>
class
FieldStorage
{
public
:
using
FieldTuple
=
mozilla
:
:
Tuple
<
Ts
.
.
.
>
;
static
constexpr
size_t
fieldCount
=
sizeof
.
.
.
(
Ts
)
;
const
FieldTuple
&
Fields
(
)
const
{
return
mFields
;
}
template
<
size_t
I
>
const
auto
&
Get
(
)
const
{
return
mozilla
:
:
Get
<
I
>
(
mFields
)
;
}
template
<
size_t
I
typename
U
>
void
SetWithoutSyncing
(
U
&
&
aValue
)
{
mozilla
:
:
Get
<
I
>
(
mFields
)
=
std
:
:
move
(
aValue
)
;
}
template
<
size_t
I
>
auto
&
GetNonSyncingReference
(
)
{
return
mozilla
:
:
Get
<
I
>
(
mFields
)
;
}
FieldStorage
(
)
=
default
;
explicit
FieldStorage
(
FieldTuple
&
&
aInit
)
:
mFields
(
std
:
:
move
(
aInit
)
)
{
}
private
:
template
<
typename
Context
>
friend
class
Transaction
;
using
MaybeFieldTuple
=
mozilla
:
:
Tuple
<
mozilla
:
:
Maybe
<
Ts
>
.
.
.
>
;
std
:
:
array
<
uint64_t
sizeof
.
.
.
(
Ts
)
>
mEpochs
{
}
;
FieldTuple
mFields
;
}
;
#
define
MOZ_DECL_SYNCED_CONTEXT_FIELD_TYPE
(
name
type
)
type
#
define
MOZ_DECL_SYNCED_CONTEXT_FIELD_INDEX
(
name
type
)
IDX_
#
#
name
#
define
MOZ_DECL_SYNCED_CONTEXT_FIELD_GETSET
(
name
type
)
\
const
type
&
Get
#
#
name
(
)
const
{
return
mFields
.
template
Get
<
IDX_
#
#
name
>
(
)
;
}
\
\
template
<
typename
U
>
\
void
Set
#
#
name
(
U
&
&
aValue
)
{
\
Transaction
txn
;
\
txn
.
template
Set
<
IDX_
#
#
name
>
(
std
:
:
forward
<
U
>
(
aValue
)
)
;
\
txn
.
Commit
(
this
)
;
\
}
#
define
MOZ_DECL_SYNCED_CONTEXT_TRANSACTION_SET
(
name
type
)
\
template
<
typename
U
>
\
void
Set
#
#
name
(
U
&
&
aValue
)
{
\
this
-
>
template
Set
<
IDX_
#
#
name
>
(
std
:
:
forward
<
U
>
(
aValue
)
)
;
\
}
#
define
MOZ_DECL_SYNCED_CONTEXT
(
clazz
eachfield
)
\
protected
:
\
friend
class
:
:
mozilla
:
:
dom
:
:
syncedcontext
:
:
Transaction
<
clazz
>
;
\
enum
FieldIndexes
{
eachfield
(
MOZ_DECL_SYNCED_CONTEXT_FIELD_INDEX
)
}
;
\
using
FieldStorage
=
\
typename
:
:
mozilla
:
:
dom
:
:
syncedcontext
:
:
FieldStorage
<
void
eachfield
(
\
MOZ_DECL_SYNCED_CONTEXT_FIELD_TYPE
)
>
;
\
FieldStorage
mFields
;
\
\
public
:
\
/
*
Helper
for
overloading
methods
like
CanSet
and
DidSet
*
/
\
template
<
size_t
I
>
\
using
FieldIndex
=
typename
:
:
mozilla
:
:
dom
:
:
syncedcontext
:
:
Index
<
I
>
;
\
\
/
*
Field
tuple
type
for
use
by
initializers
*
/
\
using
FieldTuple
=
typename
FieldStorage
:
:
FieldTuple
;
\
\
/
*
Transaction
types
for
bulk
mutations
*
/
\
using
BaseTransaction
=
:
:
mozilla
:
:
dom
:
:
syncedcontext
:
:
Transaction
<
clazz
>
;
\
class
Transaction
final
:
public
BaseTransaction
{
\
public
:
\
eachfield
(
MOZ_DECL_SYNCED_CONTEXT_TRANSACTION_SET
)
\
}
;
\
eachfield
(
MOZ_DECL_SYNCED_CONTEXT_FIELD_GETSET
)
}
}
namespace
ipc
{
template
<
typename
Context
>
struct
IPDLParamTraits
<
dom
:
:
syncedcontext
:
:
Transaction
<
Context
>
>
{
typedef
dom
:
:
syncedcontext
:
:
Transaction
<
Context
>
paramType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
aParam
.
Write
(
aMsg
aActor
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
{
return
aResult
-
>
Read
(
aMsg
aIter
aActor
)
;
}
}
;
}
}
#
endif
