#
ifndef
mozilla_dom_SyncedContext_h
#
define
mozilla_dom_SyncedContext_h
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
<
utility
>
class
PickleIterator
;
namespace
IPC
{
class
Message
;
}
namespace
mozilla
{
namespace
ipc
{
class
IProtocol
;
class
IPCResult
;
template
<
typename
T
>
struct
IPDLParamTraits
;
}
namespace
dom
{
class
ContentParent
;
class
ContentChild
;
namespace
syncedcontext
{
template
<
size_t
I
>
using
Index
=
typename
std
:
:
integral_constant
<
size_t
I
>
;
using
IndexSet
=
EnumSet
<
size_t
uint64_t
>
;
template
<
typename
Context
>
class
Transaction
{
public
:
template
<
size_t
I
typename
U
>
void
Set
(
U
&
&
aValue
)
{
mValues
.
Get
(
Index
<
I
>
{
}
)
=
std
:
:
forward
<
U
>
(
aValue
)
;
mModified
+
=
I
;
}
[
[
nodiscard
]
]
nsresult
Commit
(
Context
*
aOwner
)
;
mozilla
:
:
ipc
:
:
IPCResult
CommitFromIPC
(
const
MaybeDiscarded
<
Context
>
&
aOwner
ContentParent
*
aSource
)
;
mozilla
:
:
ipc
:
:
IPCResult
CommitFromIPC
(
const
MaybeDiscarded
<
Context
>
&
aOwner
uint64_t
aEpoch
ContentChild
*
aSource
)
;
private
:
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
Transaction
<
Context
>
>
;
void
Write
(
IPC
:
:
Message
*
aMsg
mozilla
:
:
ipc
:
:
IProtocol
*
aActor
)
const
;
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
mozilla
:
:
ipc
:
:
IProtocol
*
aActor
)
;
void
Apply
(
Context
*
aOwner
)
;
IndexSet
Validate
(
Context
*
aOwner
ContentParent
*
aSource
)
;
template
<
typename
F
>
static
void
EachIndex
(
F
&
&
aCallback
)
{
Context
:
:
FieldValues
:
:
EachIndex
(
aCallback
)
;
}
template
<
size_t
I
>
static
uint64_t
&
FieldEpoch
(
Index
<
I
>
Context
*
aContext
)
{
return
std
:
:
get
<
I
>
(
aContext
-
>
mFields
.
mEpochs
)
;
}
typename
Context
:
:
FieldValues
mValues
;
IndexSet
mModified
;
}
;
template
<
typename
Base
size_t
Count
>
class
FieldValues
:
public
Base
{
public
:
static
constexpr
size_t
count
=
Count
;
static_assert
(
count
<
64
"
At
most
64
synced
fields
are
supported
.
Please
file
a
bug
if
"
"
you
need
additional
fields
.
"
)
;
using
Base
:
:
Get
;
template
<
typename
F
>
static
void
EachIndex
(
F
&
&
aCallback
)
{
EachIndexInner
(
std
:
:
make_index_sequence
<
count
>
(
)
std
:
:
forward
<
F
>
(
aCallback
)
)
;
}
private
:
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
FieldValues
<
Base
Count
>
>
;
void
Write
(
IPC
:
:
Message
*
aMsg
mozilla
:
:
ipc
:
:
IProtocol
*
aActor
)
const
;
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
mozilla
:
:
ipc
:
:
IProtocol
*
aActor
)
;
template
<
typename
F
size_t
.
.
.
Indexes
>
static
void
EachIndexInner
(
std
:
:
index_sequence
<
Indexes
.
.
.
>
aIndexes
F
&
&
aCallback
)
{
(
aCallback
(
Index
<
Indexes
>
(
)
)
.
.
.
)
;
}
}
;
template
<
typename
Values
>
class
FieldStorage
{
public
:
Values
&
RawValues
(
)
{
return
mValues
;
}
const
Values
&
RawValues
(
)
const
{
return
mValues
;
}
template
<
size_t
I
>
const
auto
&
Get
(
)
const
{
return
RawValues
(
)
.
Get
(
Index
<
I
>
{
}
)
;
}
template
<
size_t
I
typename
U
>
void
SetWithoutSyncing
(
U
&
&
aValue
)
{
GetNonSyncingReference
<
I
>
(
)
=
std
:
:
move
(
aValue
)
;
}
template
<
size_t
I
>
auto
&
GetNonSyncingReference
(
)
{
return
RawValues
(
)
.
Get
(
Index
<
I
>
{
}
)
;
}
FieldStorage
(
)
=
default
;
explicit
FieldStorage
(
Values
&
&
aInit
)
:
mValues
(
std
:
:
move
(
aInit
)
)
{
}
private
:
template
<
typename
Context
>
friend
class
Transaction
;
std
:
:
array
<
uint64_t
Values
:
:
count
>
mEpochs
{
}
;
Values
mValues
;
}
;
template
<
typename
T
>
struct
GetFieldSetterType
{
using
SetterArg
=
T
;
}
;
template
<
>
struct
GetFieldSetterType
<
nsString
>
{
using
SetterArg
=
const
nsAString
&
;
}
;
template
<
>
struct
GetFieldSetterType
<
nsCString
>
{
using
SetterArg
=
const
nsACString
&
;
}
;
template
<
typename
T
>
using
FieldSetterType
=
typename
GetFieldSetterType
<
T
>
:
:
SetterArg
;
#
define
MOZ_DECL_SYNCED_CONTEXT_FIELD_INDEX
(
name
type
)
IDX_
#
#
name
#
define
MOZ_DECL_SYNCED_CONTEXT_FIELDS_DECL
(
name
type
)
\
type
&
Get
(
FieldIndex
<
IDX_
#
#
name
>
)
{
return
m
#
#
name
;
}
\
const
type
&
Get
(
FieldIndex
<
IDX_
#
#
name
>
)
const
{
return
m
#
#
name
;
}
\
\
/
*
storage
for
the
field
*
/
\
type
m
#
#
name
{
}
;
#
define
MOZ_DECL_SYNCED_CONTEXT_FIELD_GETSET
(
name
type
)
\
const
type
&
Get
#
#
name
(
)
const
{
return
mFields
.
template
Get
<
IDX_
#
#
name
>
(
)
;
}
\
\
[
[
nodiscard
]
]
nsresult
Set
#
#
name
(
\
:
:
mozilla
:
:
dom
:
:
syncedcontext
:
:
FieldSetterType
<
type
>
aValue
)
{
\
Transaction
txn
;
\
txn
.
template
Set
<
IDX_
#
#
name
>
(
std
:
:
move
(
aValue
)
)
;
\
return
txn
.
Commit
(
this
)
;
\
}
\
void
Set
#
#
name
(
:
:
mozilla
:
:
dom
:
:
syncedcontext
:
:
FieldSetterType
<
type
>
aValue
\
ErrorResult
&
aRv
)
{
\
nsresult
rv
=
this
-
>
Set
#
#
name
(
std
:
:
move
(
aValue
)
)
;
\
if
(
NS_FAILED
(
rv
)
)
{
\
aRv
.
ThrowInvalidStateError
(
"
cannot
set
synced
field
'
"
#
name
\
"
'
:
context
is
discarded
"
)
;
\
}
\
}
#
define
MOZ_DECL_SYNCED_CONTEXT_TRANSACTION_SET
(
name
type
)
\
template
<
typename
U
>
\
void
Set
#
#
name
(
U
&
&
aValue
)
{
\
this
-
>
template
Set
<
IDX_
#
#
name
>
(
std
:
:
forward
<
U
>
(
aValue
)
)
;
\
}
#
define
MOZ_DECL_SYNCED_CONTEXT_INDEX_TO_NAME
(
name
type
)
\
case
IDX_
#
#
name
:
\
return
#
name
;
#
define
MOZ_DECL_SYNCED_CONTEXT
(
clazz
eachfield
)
\
public
:
\
/
*
Index
constants
for
referring
to
each
field
in
generic
code
*
/
\
enum
FieldIndexes
{
\
eachfield
(
MOZ_DECL_SYNCED_CONTEXT_FIELD_INDEX
)
SYNCED_FIELD_COUNT
\
}
;
\
\
/
*
Helper
for
overloading
methods
like
CanSet
and
DidSet
*
/
\
template
<
size_t
I
>
\
using
FieldIndex
=
typename
:
:
mozilla
:
:
dom
:
:
syncedcontext
:
:
Index
<
I
>
;
\
\
/
*
Struct
containing
the
data
for
all
synced
fields
as
members
*
/
\
struct
BaseFieldValues
{
\
eachfield
(
MOZ_DECL_SYNCED_CONTEXT_FIELDS_DECL
)
\
}
;
\
using
FieldValues
=
\
typename
:
:
mozilla
:
:
dom
:
:
syncedcontext
:
:
FieldValues
<
BaseFieldValues
\
SYNCED_FIELD_COUNT
>
;
\
\
protected
:
\
friend
class
:
:
mozilla
:
:
dom
:
:
syncedcontext
:
:
Transaction
<
clazz
>
;
\
:
:
mozilla
:
:
dom
:
:
syncedcontext
:
:
FieldStorage
<
FieldValues
>
mFields
;
\
\
public
:
\
/
*
Transaction
types
for
bulk
mutations
*
/
\
using
BaseTransaction
=
:
:
mozilla
:
:
dom
:
:
syncedcontext
:
:
Transaction
<
clazz
>
;
\
class
Transaction
final
:
public
BaseTransaction
{
\
public
:
\
eachfield
(
MOZ_DECL_SYNCED_CONTEXT_TRANSACTION_SET
)
\
}
;
\
\
/
*
Field
name
getter
by
field
index
*
/
\
static
const
char
*
FieldIndexToName
(
size_t
aIndex
)
{
\
switch
(
aIndex
)
{
eachfield
(
MOZ_DECL_SYNCED_CONTEXT_INDEX_TO_NAME
)
}
\
return
"
<
unknown
>
"
;
\
}
\
eachfield
(
MOZ_DECL_SYNCED_CONTEXT_FIELD_GETSET
)
}
}
namespace
ipc
{
template
<
typename
Context
>
struct
IPDLParamTraits
<
dom
:
:
syncedcontext
:
:
Transaction
<
Context
>
>
{
typedef
dom
:
:
syncedcontext
:
:
Transaction
<
Context
>
paramType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
aParam
.
Write
(
aMsg
aActor
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
{
return
aResult
-
>
Read
(
aMsg
aIter
aActor
)
;
}
}
;
template
<
typename
Base
size_t
Count
>
struct
IPDLParamTraits
<
dom
:
:
syncedcontext
:
:
FieldValues
<
Base
Count
>
>
{
typedef
dom
:
:
syncedcontext
:
:
FieldValues
<
Base
Count
>
paramType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
aParam
.
Write
(
aMsg
aActor
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
{
return
aResult
-
>
Read
(
aMsg
aIter
aActor
)
;
}
}
;
}
}
#
endif
