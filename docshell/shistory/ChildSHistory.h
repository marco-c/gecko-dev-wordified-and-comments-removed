#
ifndef
mozilla_dom_ChildSHistory_h
#
define
mozilla_dom_ChildSHistory_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
nsID
.
h
"
class
nsISHEntry
;
class
nsISHistory
;
namespace
mozilla
{
namespace
dom
{
class
BrowsingContext
;
class
ChildSHistory
:
public
nsISupports
public
nsWrapperCache
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
ChildSHistory
)
nsISupports
*
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
explicit
ChildSHistory
(
BrowsingContext
*
aBrowsingContext
)
;
void
SetBrowsingContext
(
BrowsingContext
*
aBrowsingContext
)
;
void
SetIsInProcess
(
bool
aIsInProcess
)
;
bool
IsInProcess
(
)
{
return
!
!
mHistory
;
}
int32_t
Count
(
)
;
int32_t
Index
(
)
;
void
Reload
(
uint32_t
aReloadFlags
ErrorResult
&
aRv
)
;
bool
CanGo
(
int32_t
aOffset
)
;
void
Go
(
int32_t
aOffset
bool
aRequireUserInteraction
bool
aUserActivation
ErrorResult
&
aRv
)
;
void
AsyncGo
(
int32_t
aOffset
bool
aRequireUserInteraction
bool
aUserActivation
CallerType
aCallerType
ErrorResult
&
aRv
)
;
void
GotoIndex
(
int32_t
aIndex
int32_t
aOffset
bool
aRequireUserInteraction
bool
aUserActivation
ErrorResult
&
aRv
)
;
void
RemovePendingHistoryNavigations
(
)
;
void
EvictLocalContentViewers
(
)
;
nsISHistory
*
GetLegacySHistory
(
ErrorResult
&
aError
)
;
nsISHistory
*
LegacySHistory
(
)
;
void
SetIndexAndLength
(
uint32_t
aIndex
uint32_t
aLength
const
nsID
&
aChangeId
)
;
nsID
AddPendingHistoryChange
(
)
;
nsID
AddPendingHistoryChange
(
int32_t
aIndexDelta
int32_t
aLengthDelta
)
;
private
:
virtual
~
ChildSHistory
(
)
=
default
;
class
PendingAsyncHistoryNavigation
:
public
Runnable
public
mozilla
:
:
LinkedListElement
<
PendingAsyncHistoryNavigation
>
{
public
:
PendingAsyncHistoryNavigation
(
ChildSHistory
*
aHistory
int32_t
aOffset
bool
aRequireUserInteraction
bool
aUserActivation
)
:
Runnable
(
"
PendingAsyncHistoryNavigation
"
)
mHistory
(
aHistory
)
mRequireUserInteraction
(
aRequireUserInteraction
)
mUserActivation
(
aUserActivation
)
mOffset
(
aOffset
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
isInList
(
)
)
{
remove
(
)
;
mHistory
-
>
Go
(
mOffset
mRequireUserInteraction
mUserActivation
IgnoreErrors
(
)
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
ChildSHistory
>
mHistory
;
bool
mRequireUserInteraction
;
bool
mUserActivation
;
int32_t
mOffset
;
}
;
RefPtr
<
BrowsingContext
>
mBrowsingContext
;
nsCOMPtr
<
nsISHistory
>
mHistory
;
mozilla
:
:
LinkedList
<
PendingAsyncHistoryNavigation
>
mPendingNavigations
;
int32_t
mIndex
=
-
1
;
int32_t
mLength
=
0
;
struct
PendingSHistoryChange
{
nsID
mChangeID
;
int32_t
mIndexDelta
;
int32_t
mLengthDelta
;
}
;
AutoTArray
<
PendingSHistoryChange
2
>
mPendingSHistoryChanges
;
uint64_t
mHistoryEpoch
=
1
;
bool
mPendingEpoch
=
false
;
}
;
}
}
#
endif
