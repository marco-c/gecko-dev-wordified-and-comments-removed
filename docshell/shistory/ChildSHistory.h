#
ifndef
mozilla_dom_ChildSHistory_h
#
define
mozilla_dom_ChildSHistory_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
class
nsISHEntry
;
class
nsISHistory
;
namespace
mozilla
{
namespace
dom
{
class
BrowsingContext
;
class
ChildSHistory
:
public
nsISupports
public
nsWrapperCache
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
ChildSHistory
)
nsISupports
*
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
explicit
ChildSHistory
(
BrowsingContext
*
aBrowsingContext
)
;
void
SetIsInProcess
(
bool
aIsInProcess
)
;
bool
IsInProcess
(
)
{
return
!
!
mHistory
;
}
int32_t
Count
(
)
;
int32_t
Index
(
)
;
void
Reload
(
uint32_t
aReloadFlags
ErrorResult
&
aRv
)
;
bool
CanGo
(
int32_t
aOffset
)
;
void
Go
(
int32_t
aOffset
ErrorResult
&
aRv
)
;
void
AsyncGo
(
int32_t
aOffset
)
;
void
RemovePendingHistoryNavigations
(
)
;
void
EvictLocalContentViewers
(
)
;
nsISHistory
*
LegacySHistory
(
)
;
private
:
virtual
~
ChildSHistory
(
)
=
default
;
class
PendingAsyncHistoryNavigation
:
public
Runnable
public
mozilla
:
:
LinkedListElement
<
PendingAsyncHistoryNavigation
>
{
public
:
PendingAsyncHistoryNavigation
(
ChildSHistory
*
aHistory
int32_t
aOffset
)
:
Runnable
(
"
PendingAsyncHistoryNavigation
"
)
mHistory
(
aHistory
)
mOffset
(
aOffset
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
isInList
(
)
)
{
remove
(
)
;
mHistory
-
>
Go
(
mOffset
IgnoreErrors
(
)
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
ChildSHistory
>
mHistory
;
int32_t
mOffset
;
}
;
RefPtr
<
BrowsingContext
>
mBrowsingContext
;
nsCOMPtr
<
nsISHistory
>
mHistory
;
mozilla
:
:
LinkedList
<
PendingAsyncHistoryNavigation
>
mPendingNavigations
;
}
;
already_AddRefed
<
nsISHEntry
>
CreateSHEntryForDocShell
(
nsISHistory
*
aSHistory
)
;
}
}
#
endif
