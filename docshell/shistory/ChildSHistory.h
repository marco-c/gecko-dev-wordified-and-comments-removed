#
ifndef
mozilla_dom_ChildSHistory_h
#
define
mozilla_dom_ChildSHistory_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
nsID
.
h
"
class
nsISHEntry
;
class
nsISHistory
;
namespace
mozilla
:
:
dom
{
class
BrowsingContext
;
class
ChildSHistory
:
public
nsISupports
public
nsWrapperCache
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
ChildSHistory
)
nsISupports
*
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
explicit
ChildSHistory
(
BrowsingContext
*
aBrowsingContext
)
;
void
SetBrowsingContext
(
BrowsingContext
*
aBrowsingContext
)
;
void
SetIsInProcess
(
bool
aIsInProcess
)
;
bool
IsInProcess
(
)
{
return
!
!
mHistory
;
}
int32_t
Count
(
)
;
int32_t
Index
(
)
;
MOZ_CAN_RUN_SCRIPT
void
Reload
(
uint32_t
aReloadFlags
ErrorResult
&
aRv
)
;
bool
CanGo
(
int32_t
aOffset
bool
aRequireUserInteraction
)
;
MOZ_CAN_RUN_SCRIPT
void
Go
(
int32_t
aOffset
bool
aRequireUserInteraction
bool
aUserActivation
ErrorResult
&
aRv
)
;
void
AsyncGo
(
int32_t
aOffset
bool
aRequireUserInteraction
bool
aUserActivation
)
;
void
AsyncGo
(
const
nsID
&
aKey
BrowsingContext
*
aNavigable
bool
aRequireUserInteraction
bool
aUserActivation
std
:
:
function
<
void
(
nsresult
)
>
&
&
aResolver
)
;
MOZ_CAN_RUN_SCRIPT
void
GotoIndex
(
int32_t
aIndex
int32_t
aOffset
bool
aRequireUserInteraction
bool
aUserActivation
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
GotoKey
(
const
nsID
&
aKey
BrowsingContext
*
aNavigable
bool
aRequireUserInteraction
bool
aUserActivation
const
std
:
:
function
<
void
(
nsresult
)
>
&
aResolver
ErrorResult
&
aRv
)
;
void
RemovePendingHistoryNavigations
(
)
;
void
EvictLocalDocumentViewers
(
)
;
nsISHistory
*
GetLegacySHistory
(
ErrorResult
&
aError
)
;
nsISHistory
*
LegacySHistory
(
)
;
void
SetIndexAndLength
(
uint32_t
aIndex
uint32_t
aLength
const
nsID
&
aChangeId
)
;
nsID
AddPendingHistoryChange
(
)
;
nsID
AddPendingHistoryChange
(
int32_t
aIndexDelta
int32_t
aLengthDelta
)
;
private
:
virtual
~
ChildSHistory
(
)
;
class
PendingAsyncHistoryNavigation
:
public
Runnable
public
mozilla
:
:
LinkedListElement
<
PendingAsyncHistoryNavigation
>
{
public
:
PendingAsyncHistoryNavigation
(
ChildSHistory
*
aHistory
int32_t
aOffset
bool
aRequireUserInteraction
bool
aUserActivation
)
;
PendingAsyncHistoryNavigation
(
ChildSHistory
*
aHistory
const
nsID
&
aKey
BrowsingContext
*
aBrowsingContext
bool
aRequireUserInteraction
bool
aUserActivation
std
:
:
function
<
void
(
nsresult
)
>
&
&
aResolver
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
;
private
:
const
RefPtr
<
ChildSHistory
>
mHistory
;
bool
mRequireUserInteraction
;
bool
mUserActivation
;
int32_t
mOffset
;
Maybe
<
nsID
>
mKey
;
RefPtr
<
BrowsingContext
>
mBrowsingContext
;
Maybe
<
std
:
:
function
<
void
(
nsresult
)
>
>
mResolver
;
}
;
RefPtr
<
BrowsingContext
>
mBrowsingContext
;
nsCOMPtr
<
nsISHistory
>
mHistory
;
mozilla
:
:
LinkedList
<
PendingAsyncHistoryNavigation
>
mPendingNavigations
;
int32_t
mIndex
=
-
1
;
int32_t
mLength
=
0
;
struct
PendingSHistoryChange
{
nsID
mChangeID
;
int32_t
mIndexDelta
;
int32_t
mLengthDelta
;
}
;
AutoTArray
<
PendingSHistoryChange
2
>
mPendingSHistoryChanges
;
uint64_t
mHistoryEpoch
=
1
;
bool
mPendingEpoch
=
false
;
}
;
}
#
endif
