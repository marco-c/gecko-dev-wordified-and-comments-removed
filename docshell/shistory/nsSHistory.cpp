#
include
"
nsSHistory
.
h
"
#
include
<
algorithm
>
#
include
"
nsCOMArray
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocShellLoadInfo
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsISHContainer
.
h
"
#
include
"
nsISHEntry
.
h
"
#
include
"
nsISHistoryListener
.
h
"
#
include
"
nsISHTransaction
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
using
namespace
mozilla
;
#
define
PREF_SHISTORY_SIZE
"
browser
.
sessionhistory
.
max_entries
"
#
define
PREF_SHISTORY_MAX_TOTAL_VIEWERS
"
browser
.
sessionhistory
.
max_total_viewers
"
#
define
CONTENT_VIEWER_TIMEOUT_SECONDS
"
browser
.
sessionhistory
.
contentViewerTimeout
"
#
define
CONTENT_VIEWER_TIMEOUT_SECONDS_DEFAULT
(
30
*
60
)
static
const
char
*
kObservedPrefs
[
]
=
{
PREF_SHISTORY_SIZE
PREF_SHISTORY_MAX_TOTAL_VIEWERS
nullptr
}
;
static
int32_t
gHistoryMaxSize
=
50
;
static
LinkedList
<
nsSHistory
>
gSHistoryList
;
int32_t
nsSHistory
:
:
sHistoryMaxTotalViewers
=
-
1
;
static
uint32_t
gTouchCounter
=
0
;
static
LazyLogModule
gSHistoryLog
(
"
nsSHistory
"
)
;
#
define
LOG
(
format
)
MOZ_LOG
(
gSHistoryLog
mozilla
:
:
LogLevel
:
:
Debug
format
)
#
define
LOG_SPEC
(
format
uri
)
\
PR_BEGIN_MACRO
\
if
(
MOZ_LOG_TEST
(
gSHistoryLog
LogLevel
:
:
Debug
)
)
{
\
nsAutoCString
_specStr
(
NS_LITERAL_CSTRING
(
"
(
null
)
"
)
)
;
\
if
(
uri
)
{
\
_specStr
=
uri
-
>
GetSpecOrDefault
(
)
;
\
}
\
const
char
*
_spec
=
_specStr
.
get
(
)
;
\
LOG
(
format
)
;
\
}
\
PR_END_MACRO
#
define
LOG_SHENTRY_SPEC
(
format
shentry
)
\
PR_BEGIN_MACRO
\
if
(
MOZ_LOG_TEST
(
gSHistoryLog
LogLevel
:
:
Debug
)
)
{
\
nsCOMPtr
<
nsIURI
>
uri
;
\
shentry
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
\
LOG_SPEC
(
format
uri
)
;
\
}
\
PR_END_MACRO
#
define
ITERATE_LISTENERS
(
body
)
\
PR_BEGIN_MACRO
\
{
\
nsAutoTObserverArray
<
nsWeakPtr
2
>
:
:
EndLimitedIterator
\
iter
(
mListeners
)
;
\
while
(
iter
.
HasMore
(
)
)
{
\
nsCOMPtr
<
nsISHistoryListener
>
listener
=
\
do_QueryReferent
(
iter
.
GetNext
(
)
)
;
\
if
(
listener
)
{
\
body
\
}
\
}
\
}
\
PR_END_MACRO
#
define
NOTIFY_LISTENERS
(
method
args
)
\
ITERATE_LISTENERS
(
\
listener
-
>
method
args
;
\
)
;
#
define
NOTIFY_LISTENERS_CANCELABLE
(
method
retval
args
)
\
PR_BEGIN_MACRO
\
{
\
bool
canceled
=
false
;
\
retval
=
true
;
\
ITERATE_LISTENERS
(
\
listener
-
>
method
args
;
\
if
(
!
retval
)
{
\
canceled
=
true
;
\
}
\
)
;
\
if
(
canceled
)
{
\
retval
=
false
;
\
}
\
}
\
PR_END_MACRO
enum
HistCmd
{
HIST_CMD_BACK
HIST_CMD_FORWARD
HIST_CMD_GOTOINDEX
HIST_CMD_RELOAD
}
;
class
nsSHistoryObserver
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
nsSHistoryObserver
(
)
{
}
protected
:
~
nsSHistoryObserver
(
)
{
}
}
;
StaticRefPtr
<
nsSHistoryObserver
>
gObserver
;
NS_IMPL_ISUPPORTS
(
nsSHistoryObserver
nsIObserver
)
NS_IMETHODIMP
nsSHistoryObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
)
{
nsSHistory
:
:
UpdatePrefs
(
)
;
nsSHistory
:
:
GloballyEvictContentViewers
(
)
;
}
else
if
(
!
strcmp
(
aTopic
"
cacheservice
:
empty
-
cache
"
)
|
|
!
strcmp
(
aTopic
"
memory
-
pressure
"
)
)
{
nsSHistory
:
:
GloballyEvictAllContentViewers
(
)
;
}
return
NS_OK
;
}
namespace
{
already_AddRefed
<
nsIContentViewer
>
GetContentViewerForTransaction
(
nsISHTransaction
*
aTrans
)
{
nsCOMPtr
<
nsISHEntry
>
entry
;
aTrans
-
>
GetSHEntry
(
getter_AddRefs
(
entry
)
)
;
if
(
!
entry
)
{
return
nullptr
;
}
nsCOMPtr
<
nsISHEntry
>
ownerEntry
;
nsCOMPtr
<
nsIContentViewer
>
viewer
;
entry
-
>
GetAnyContentViewer
(
getter_AddRefs
(
ownerEntry
)
getter_AddRefs
(
viewer
)
)
;
return
viewer
.
forget
(
)
;
}
}
void
nsSHistory
:
:
EvictContentViewerForTransaction
(
nsISHTransaction
*
aTrans
)
{
nsCOMPtr
<
nsISHEntry
>
entry
;
aTrans
-
>
GetSHEntry
(
getter_AddRefs
(
entry
)
)
;
nsCOMPtr
<
nsIContentViewer
>
viewer
;
nsCOMPtr
<
nsISHEntry
>
ownerEntry
;
entry
-
>
GetAnyContentViewer
(
getter_AddRefs
(
ownerEntry
)
getter_AddRefs
(
viewer
)
)
;
if
(
viewer
)
{
NS_ASSERTION
(
ownerEntry
"
Content
viewer
exists
but
its
SHEntry
is
null
"
)
;
LOG_SHENTRY_SPEC
(
(
"
Evicting
content
viewer
0x
%
p
for
"
"
owning
SHEntry
0x
%
p
at
%
s
.
"
viewer
.
get
(
)
ownerEntry
.
get
(
)
_spec
)
ownerEntry
)
;
ownerEntry
-
>
SetContentViewer
(
nullptr
)
;
ownerEntry
-
>
SyncPresentationState
(
)
;
viewer
-
>
Destroy
(
)
;
}
int32_t
index
=
-
1
;
GetIndexOfEntry
(
entry
&
index
)
;
if
(
index
!
=
-
1
)
{
nsCOMPtr
<
nsISHContainer
>
container
(
do_QueryInterface
(
entry
)
)
;
RemoveDynEntries
(
index
container
)
;
}
}
nsSHistory
:
:
nsSHistory
(
)
:
mIndex
(
-
1
)
mLength
(
0
)
mRequestedIndex
(
-
1
)
mGlobalIndexOffset
(
0
)
mEntriesInFollowingPartialHistories
(
0
)
mRootDocShell
(
nullptr
)
mIsPartial
(
false
)
{
gSHistoryList
.
insertBack
(
this
)
;
}
nsSHistory
:
:
~
nsSHistory
(
)
{
}
NS_IMPL_ADDREF
(
nsSHistory
)
NS_IMPL_RELEASE
(
nsSHistory
)
NS_INTERFACE_MAP_BEGIN
(
nsSHistory
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsISHistory
)
NS_INTERFACE_MAP_ENTRY
(
nsISHistory
)
NS_INTERFACE_MAP_ENTRY
(
nsIWebNavigation
)
NS_INTERFACE_MAP_ENTRY
(
nsISHistoryInternal
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END
uint32_t
nsSHistory
:
:
CalcMaxTotalViewers
(
)
{
uint64_t
bytes
=
PR_GetPhysicalMemorySize
(
)
;
if
(
bytes
=
=
0
)
{
return
0
;
}
if
(
bytes
>
INT64_MAX
)
{
bytes
=
INT64_MAX
;
}
double
kBytesD
=
(
double
)
(
bytes
>
>
10
)
;
uint32_t
viewers
=
0
;
double
x
=
std
:
:
log
(
kBytesD
)
/
std
:
:
log
(
2
.
0
)
-
14
;
if
(
x
>
0
)
{
viewers
=
(
uint32_t
)
(
x
*
x
-
x
+
2
.
001
)
;
viewers
/
=
4
;
}
if
(
viewers
>
8
)
{
viewers
=
8
;
}
return
viewers
;
}
void
nsSHistory
:
:
UpdatePrefs
(
)
{
Preferences
:
:
GetInt
(
PREF_SHISTORY_SIZE
&
gHistoryMaxSize
)
;
Preferences
:
:
GetInt
(
PREF_SHISTORY_MAX_TOTAL_VIEWERS
&
sHistoryMaxTotalViewers
)
;
if
(
sHistoryMaxTotalViewers
<
0
)
{
sHistoryMaxTotalViewers
=
CalcMaxTotalViewers
(
)
;
}
}
nsresult
nsSHistory
:
:
Startup
(
)
{
UpdatePrefs
(
)
;
int32_t
defaultHistoryMaxSize
=
Preferences
:
:
GetDefaultInt
(
PREF_SHISTORY_SIZE
50
)
;
if
(
gHistoryMaxSize
<
defaultHistoryMaxSize
)
{
gHistoryMaxSize
=
defaultHistoryMaxSize
;
}
if
(
!
gObserver
)
{
gObserver
=
new
nsSHistoryObserver
(
)
;
Preferences
:
:
AddStrongObservers
(
gObserver
kObservedPrefs
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
AddObserver
(
gObserver
"
cacheservice
:
empty
-
cache
"
false
)
;
obsSvc
-
>
AddObserver
(
gObserver
"
memory
-
pressure
"
false
)
;
}
}
return
NS_OK
;
}
void
nsSHistory
:
:
Shutdown
(
)
{
if
(
gObserver
)
{
Preferences
:
:
RemoveObservers
(
gObserver
kObservedPrefs
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
RemoveObserver
(
gObserver
"
cacheservice
:
empty
-
cache
"
)
;
obsSvc
-
>
RemoveObserver
(
gObserver
"
memory
-
pressure
"
)
;
}
gObserver
=
nullptr
;
}
}
NS_IMETHODIMP
nsSHistory
:
:
AddEntry
(
nsISHEntry
*
aSHEntry
bool
aPersist
)
{
NS_ENSURE_ARG
(
aSHEntry
)
;
nsCOMPtr
<
nsISHistory
>
shistoryOfEntry
;
aSHEntry
-
>
GetSHistory
(
getter_AddRefs
(
shistoryOfEntry
)
)
;
if
(
shistoryOfEntry
&
&
shistoryOfEntry
!
=
this
)
{
NS_WARNING
(
"
The
entry
has
been
associated
to
another
nsISHistory
instance
.
"
"
Try
nsISHEntry
.
clone
(
)
and
nsISHEntry
.
abandonBFCacheEntry
(
)
"
"
first
if
you
'
re
copying
an
entry
from
another
nsISHistory
.
"
)
;
return
NS_ERROR_FAILURE
;
}
aSHEntry
-
>
SetSHistory
(
this
)
;
if
(
mRootDocShell
)
{
nsID
docshellID
=
mRootDocShell
-
>
HistoryID
(
)
;
aSHEntry
-
>
SetDocshellID
(
&
docshellID
)
;
}
nsCOMPtr
<
nsISHTransaction
>
currentTxn
;
if
(
mListRoot
)
{
GetTransactionAtIndex
(
mIndex
getter_AddRefs
(
currentTxn
)
)
;
}
bool
currentPersist
=
true
;
if
(
currentTxn
)
{
currentTxn
-
>
GetPersist
(
&
currentPersist
)
;
}
int32_t
currentIndex
=
mIndex
;
if
(
!
currentPersist
)
{
NOTIFY_LISTENERS
(
OnHistoryReplaceEntry
(
currentIndex
)
)
;
NS_ENSURE_SUCCESS
(
currentTxn
-
>
SetSHEntry
(
aSHEntry
)
NS_ERROR_FAILURE
)
;
currentTxn
-
>
SetPersist
(
aPersist
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsISHTransaction
>
txn
(
do_CreateInstance
(
NS_SHTRANSACTION_CONTRACTID
)
)
;
NS_ENSURE_TRUE
(
txn
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIURI
>
uri
;
aSHEntry
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NOTIFY_LISTENERS
(
OnHistoryNewEntry
(
uri
currentIndex
)
)
;
if
(
currentIndex
!
=
mIndex
)
{
GetTransactionAtIndex
(
mIndex
getter_AddRefs
(
currentTxn
)
)
;
}
txn
-
>
SetPersist
(
aPersist
)
;
NS_ENSURE_SUCCESS
(
txn
-
>
Create
(
aSHEntry
currentTxn
)
NS_ERROR_FAILURE
)
;
mLength
=
(
+
+
mIndex
+
1
)
;
NOTIFY_LISTENERS
(
OnLengthChanged
(
mLength
)
)
;
NOTIFY_LISTENERS
(
OnIndexChanged
(
mIndex
)
)
;
mEntriesInFollowingPartialHistories
=
0
;
if
(
!
mListRoot
)
{
mListRoot
=
txn
;
}
if
(
gHistoryMaxSize
>
=
0
&
&
mLength
>
gHistoryMaxSize
)
{
PurgeHistory
(
mLength
-
gHistoryMaxSize
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetIsPartial
(
bool
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
mIsPartial
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetCount
(
int32_t
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
mLength
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetGlobalCount
(
int32_t
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
mGlobalIndexOffset
+
mLength
+
mEntriesInFollowingPartialHistories
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetGlobalIndexOffset
(
int32_t
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
mGlobalIndexOffset
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
OnPartialSHistoryActive
(
int32_t
aGlobalLength
int32_t
aTargetIndex
)
{
NS_ENSURE_TRUE
(
mRootDocShell
&
&
mIsPartial
NS_ERROR_UNEXPECTED
)
;
int32_t
extraLength
=
aGlobalLength
-
mLength
-
mGlobalIndexOffset
;
NS_ENSURE_TRUE
(
extraLength
>
=
0
NS_ERROR_UNEXPECTED
)
;
if
(
extraLength
!
=
mEntriesInFollowingPartialHistories
)
{
mEntriesInFollowingPartialHistories
=
extraLength
;
}
return
RestoreToEntryAtIndex
(
aTargetIndex
)
;
}
NS_IMETHODIMP
nsSHistory
:
:
OnPartialSHistoryDeactive
(
)
{
NS_ENSURE_TRUE
(
mRootDocShell
&
&
mIsPartial
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsIWebNavigation
>
webNav
=
do_QueryInterface
(
mRootDocShell
)
;
nsCOMPtr
<
nsIURI
>
currentURI
;
webNav
-
>
GetCurrentURI
(
getter_AddRefs
(
currentURI
)
)
;
if
(
NS_IsAboutBlank
(
currentURI
)
)
{
return
NS_OK
;
}
if
(
NS_FAILED
(
mRootDocShell
-
>
ForceCreateAboutBlankContentViewer
(
nullptr
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetIndex
(
int32_t
*
aResult
)
{
NS_PRECONDITION
(
aResult
"
null
out
param
?
"
)
;
*
aResult
=
mIndex
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetGlobalIndex
(
int32_t
*
aResult
)
{
NS_PRECONDITION
(
aResult
"
null
out
param
?
"
)
;
*
aResult
=
mIndex
+
mGlobalIndexOffset
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetRequestedIndex
(
int32_t
*
aResult
)
{
NS_PRECONDITION
(
aResult
"
null
out
param
?
"
)
;
*
aResult
=
mRequestedIndex
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetEntryAtIndex
(
int32_t
aIndex
bool
aModifyIndex
nsISHEntry
*
*
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsISHTransaction
>
txn
;
rv
=
GetTransactionAtIndex
(
aIndex
getter_AddRefs
(
txn
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
txn
)
{
rv
=
txn
-
>
GetSHEntry
(
aResult
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
*
aResult
)
)
{
if
(
aModifyIndex
)
{
mIndex
=
aIndex
;
NOTIFY_LISTENERS
(
OnIndexChanged
(
mIndex
)
)
}
}
}
return
rv
;
}
nsresult
nsSHistory
:
:
GetTransactionAtIndex
(
int32_t
aIndex
nsISHTransaction
*
*
aResult
)
{
nsresult
rv
;
NS_ENSURE_ARG_POINTER
(
aResult
)
;
if
(
mLength
<
=
0
|
|
aIndex
<
0
|
|
aIndex
>
=
mLength
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mListRoot
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aIndex
=
=
0
)
{
*
aResult
=
mListRoot
;
NS_ADDREF
(
*
aResult
)
;
return
NS_OK
;
}
int32_t
cnt
=
0
;
nsCOMPtr
<
nsISHTransaction
>
tempPtr
;
rv
=
GetRootTransaction
(
getter_AddRefs
(
tempPtr
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
tempPtr
)
{
return
NS_ERROR_FAILURE
;
}
while
(
true
)
{
nsCOMPtr
<
nsISHTransaction
>
ptr
;
rv
=
tempPtr
-
>
GetNext
(
getter_AddRefs
(
ptr
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
ptr
)
{
cnt
+
+
;
if
(
cnt
=
=
aIndex
)
{
ptr
.
forget
(
aResult
)
;
break
;
}
else
{
tempPtr
=
ptr
;
continue
;
}
}
else
{
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetIndexOfEntry
(
nsISHEntry
*
aSHEntry
int32_t
*
aResult
)
{
NS_ENSURE_ARG
(
aSHEntry
)
;
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
-
1
;
if
(
mLength
<
=
0
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISHTransaction
>
currentTxn
;
int32_t
cnt
=
0
;
nsresult
rv
=
GetRootTransaction
(
getter_AddRefs
(
currentTxn
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
currentTxn
)
{
return
NS_ERROR_FAILURE
;
}
while
(
true
)
{
nsCOMPtr
<
nsISHEntry
>
entry
;
rv
=
currentTxn
-
>
GetSHEntry
(
getter_AddRefs
(
entry
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
entry
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aSHEntry
=
=
entry
)
{
*
aResult
=
cnt
;
break
;
}
rv
=
currentTxn
-
>
GetNext
(
getter_AddRefs
(
currentTxn
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
currentTxn
)
{
return
NS_ERROR_FAILURE
;
}
cnt
+
+
;
}
return
NS_OK
;
}
#
ifdef
DEBUG
nsresult
nsSHistory
:
:
PrintHistory
(
)
{
nsCOMPtr
<
nsISHTransaction
>
txn
;
int32_t
index
=
0
;
nsresult
rv
;
if
(
!
mListRoot
)
{
return
NS_ERROR_FAILURE
;
}
txn
=
mListRoot
;
while
(
1
)
{
if
(
!
txn
)
{
break
;
}
nsCOMPtr
<
nsISHEntry
>
entry
;
rv
=
txn
-
>
GetSHEntry
(
getter_AddRefs
(
entry
)
)
;
if
(
NS_FAILED
(
rv
)
&
&
!
entry
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsILayoutHistoryState
>
layoutHistoryState
;
nsCOMPtr
<
nsIURI
>
uri
;
nsString
title
;
entry
-
>
GetLayoutHistoryState
(
getter_AddRefs
(
layoutHistoryState
)
)
;
entry
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
entry
-
>
GetTitle
(
getter_Copies
(
title
)
)
;
#
if
0
nsAutoCString
url
;
if
(
uri
)
{
uri
-
>
GetSpec
(
url
)
;
}
printf
(
"
*
*
*
*
SH
Transaction
#
%
d
Entry
=
%
x
\
n
"
index
entry
.
get
(
)
)
;
printf
(
"
\
t
\
t
URL
=
%
s
\
n
"
url
.
get
(
)
)
;
printf
(
"
\
t
\
t
Title
=
%
s
\
n
"
NS_LossyConvertUTF16toASCII
(
title
)
.
get
(
)
)
;
printf
(
"
\
t
\
t
layout
History
Data
=
%
x
\
n
"
layoutHistoryState
.
get
(
)
)
;
#
endif
nsCOMPtr
<
nsISHTransaction
>
next
;
rv
=
txn
-
>
GetNext
(
getter_AddRefs
(
next
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
next
)
{
txn
=
next
;
index
+
+
;
continue
;
}
else
{
break
;
}
}
return
NS_OK
;
}
#
endif
NS_IMETHODIMP
nsSHistory
:
:
GetRootTransaction
(
nsISHTransaction
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
mListRoot
;
NS_IF_ADDREF
(
*
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetMaxLength
(
int32_t
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
gHistoryMaxSize
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
SetMaxLength
(
int32_t
aMaxSize
)
{
if
(
aMaxSize
<
0
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
gHistoryMaxSize
=
aMaxSize
;
if
(
mLength
>
aMaxSize
)
{
PurgeHistory
(
mLength
-
aMaxSize
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
PurgeHistory
(
int32_t
aEntries
)
{
if
(
mLength
<
=
0
|
|
aEntries
<
=
0
)
{
return
NS_ERROR_FAILURE
;
}
aEntries
=
std
:
:
min
(
aEntries
mLength
)
;
bool
purgeHistory
=
true
;
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryPurge
purgeHistory
(
aEntries
&
purgeHistory
)
)
;
if
(
!
purgeHistory
)
{
return
NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA
;
}
int32_t
cnt
=
0
;
while
(
cnt
<
aEntries
)
{
nsCOMPtr
<
nsISHTransaction
>
nextTxn
;
if
(
mListRoot
)
{
mListRoot
-
>
GetNext
(
getter_AddRefs
(
nextTxn
)
)
;
mListRoot
-
>
SetNext
(
nullptr
)
;
}
mListRoot
=
nextTxn
;
if
(
mListRoot
)
{
mListRoot
-
>
SetPrev
(
nullptr
)
;
}
cnt
+
+
;
}
mLength
-
=
cnt
;
mIndex
-
=
cnt
;
mEntriesInFollowingPartialHistories
=
0
;
if
(
mIndex
<
-
1
)
{
mIndex
=
-
1
;
}
NOTIFY_LISTENERS
(
OnLengthChanged
(
mLength
)
)
;
NOTIFY_LISTENERS
(
OnIndexChanged
(
mIndex
)
)
if
(
mRootDocShell
)
{
mRootDocShell
-
>
HistoryPurged
(
cnt
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
AddSHistoryListener
(
nsISHistoryListener
*
aListener
)
{
NS_ENSURE_ARG_POINTER
(
aListener
)
;
nsWeakPtr
listener
=
do_GetWeakReference
(
aListener
)
;
if
(
!
listener
)
{
return
NS_ERROR_FAILURE
;
}
return
mListeners
.
AppendElementUnlessExists
(
listener
)
?
NS_OK
:
NS_ERROR_OUT_OF_MEMORY
;
}
NS_IMETHODIMP
nsSHistory
:
:
RemoveSHistoryListener
(
nsISHistoryListener
*
aListener
)
{
nsWeakPtr
listener
=
do_GetWeakReference
(
aListener
)
;
mListeners
.
RemoveElement
(
listener
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
SetPartialSHistoryListener
(
nsIPartialSHistoryListener
*
aListener
)
{
mPartialHistoryListener
=
do_GetWeakReference
(
aListener
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
ReplaceEntry
(
int32_t
aIndex
nsISHEntry
*
aReplaceEntry
)
{
NS_ENSURE_ARG
(
aReplaceEntry
)
;
nsresult
rv
;
nsCOMPtr
<
nsISHTransaction
>
currentTxn
;
if
(
!
mListRoot
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
GetTransactionAtIndex
(
aIndex
getter_AddRefs
(
currentTxn
)
)
;
if
(
currentTxn
)
{
nsCOMPtr
<
nsISHistory
>
shistoryOfEntry
;
aReplaceEntry
-
>
GetSHistory
(
getter_AddRefs
(
shistoryOfEntry
)
)
;
if
(
shistoryOfEntry
&
&
shistoryOfEntry
!
=
this
)
{
NS_WARNING
(
"
The
entry
has
been
associated
to
another
nsISHistory
instance
.
"
"
Try
nsISHEntry
.
clone
(
)
and
nsISHEntry
.
abandonBFCacheEntry
(
)
"
"
first
if
you
'
re
copying
an
entry
from
another
nsISHistory
.
"
)
;
return
NS_ERROR_FAILURE
;
}
aReplaceEntry
-
>
SetSHistory
(
this
)
;
NOTIFY_LISTENERS
(
OnHistoryReplaceEntry
(
aIndex
)
)
;
rv
=
currentTxn
-
>
SetSHEntry
(
aReplaceEntry
)
;
rv
=
currentTxn
-
>
SetPersist
(
true
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsSHistory
:
:
NotifyOnHistoryReload
(
nsIURI
*
aReloadURI
uint32_t
aReloadFlags
bool
*
aCanReload
)
{
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryReload
*
aCanReload
(
aReloadURI
aReloadFlags
aCanReload
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
EvictOutOfRangeContentViewers
(
int32_t
aIndex
)
{
EvictOutOfRangeWindowContentViewers
(
aIndex
)
;
GloballyEvictContentViewers
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
EvictAllContentViewers
(
)
{
nsCOMPtr
<
nsISHTransaction
>
trans
=
mListRoot
;
while
(
trans
)
{
EvictContentViewerForTransaction
(
trans
)
;
nsCOMPtr
<
nsISHTransaction
>
temp
=
trans
;
temp
-
>
GetNext
(
getter_AddRefs
(
trans
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetCanGoBack
(
bool
*
aCanGoBack
)
{
NS_ENSURE_ARG_POINTER
(
aCanGoBack
)
;
if
(
mGlobalIndexOffset
)
{
*
aCanGoBack
=
true
;
return
NS_OK
;
}
int32_t
index
=
-
1
;
NS_ENSURE_SUCCESS
(
GetIndex
(
&
index
)
NS_ERROR_FAILURE
)
;
if
(
index
>
0
)
{
*
aCanGoBack
=
true
;
return
NS_OK
;
}
*
aCanGoBack
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetCanGoForward
(
bool
*
aCanGoForward
)
{
NS_ENSURE_ARG_POINTER
(
aCanGoForward
)
;
if
(
mEntriesInFollowingPartialHistories
)
{
*
aCanGoForward
=
true
;
return
NS_OK
;
}
int32_t
index
=
-
1
;
int32_t
count
=
-
1
;
NS_ENSURE_SUCCESS
(
GetIndex
(
&
index
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
GetCount
(
&
count
)
NS_ERROR_FAILURE
)
;
if
(
index
>
=
0
&
&
index
<
(
count
-
1
)
)
{
*
aCanGoForward
=
true
;
return
NS_OK
;
}
*
aCanGoForward
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GoBack
(
)
{
bool
canGoBack
=
false
;
GetCanGoBack
(
&
canGoBack
)
;
if
(
!
canGoBack
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
LoadEntry
(
mIndex
-
1
nsIDocShellLoadInfo
:
:
loadHistory
HIST_CMD_BACK
)
;
}
NS_IMETHODIMP
nsSHistory
:
:
GoForward
(
)
{
bool
canGoForward
=
false
;
GetCanGoForward
(
&
canGoForward
)
;
if
(
!
canGoForward
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
LoadEntry
(
mIndex
+
1
nsIDocShellLoadInfo
:
:
loadHistory
HIST_CMD_FORWARD
)
;
}
NS_IMETHODIMP
nsSHistory
:
:
Reload
(
uint32_t
aReloadFlags
)
{
nsDocShellInfoLoadType
loadType
;
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_BYPASS_PROXY
&
&
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_BYPASS_CACHE
)
{
loadType
=
nsIDocShellLoadInfo
:
:
loadReloadBypassProxyAndCache
;
}
else
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_BYPASS_PROXY
)
{
loadType
=
nsIDocShellLoadInfo
:
:
loadReloadBypassProxy
;
}
else
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_BYPASS_CACHE
)
{
loadType
=
nsIDocShellLoadInfo
:
:
loadReloadBypassCache
;
}
else
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_CHARSET_CHANGE
)
{
loadType
=
nsIDocShellLoadInfo
:
:
loadReloadCharsetChange
;
}
else
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_ALLOW_MIXED_CONTENT
)
{
loadType
=
nsIDocShellLoadInfo
:
:
loadReloadMixedContent
;
}
else
{
loadType
=
nsIDocShellLoadInfo
:
:
loadReloadNormal
;
}
bool
canNavigate
=
true
;
nsCOMPtr
<
nsIURI
>
currentURI
;
GetCurrentURI
(
getter_AddRefs
(
currentURI
)
)
;
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryReload
canNavigate
(
currentURI
aReloadFlags
&
canNavigate
)
)
;
if
(
!
canNavigate
)
{
return
NS_OK
;
}
return
LoadEntry
(
mIndex
loadType
HIST_CMD_RELOAD
)
;
}
NS_IMETHODIMP
nsSHistory
:
:
ReloadCurrentEntry
(
)
{
bool
canNavigate
=
true
;
nsCOMPtr
<
nsIURI
>
currentURI
;
GetCurrentURI
(
getter_AddRefs
(
currentURI
)
)
;
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryGotoIndex
canNavigate
(
mIndex
currentURI
&
canNavigate
)
)
;
if
(
!
canNavigate
)
{
return
NS_OK
;
}
return
LoadEntry
(
mIndex
nsIDocShellLoadInfo
:
:
loadHistory
HIST_CMD_RELOAD
)
;
}
NS_IMETHODIMP
nsSHistory
:
:
RestoreToEntryAtIndex
(
int32_t
aIndex
)
{
mRequestedIndex
=
aIndex
;
nsCOMPtr
<
nsISHEntry
>
nextEntry
;
GetEntryAtIndex
(
mRequestedIndex
false
getter_AddRefs
(
nextEntry
)
)
;
if
(
!
nextEntry
)
{
mRequestedIndex
=
-
1
;
return
NS_ERROR_FAILURE
;
}
return
InitiateLoad
(
nextEntry
mRootDocShell
nsIDocShellLoadInfo
:
:
loadHistory
)
;
}
void
nsSHistory
:
:
EvictOutOfRangeWindowContentViewers
(
int32_t
aIndex
)
{
if
(
aIndex
<
0
)
{
return
;
}
NS_ENSURE_TRUE_VOID
(
aIndex
<
mLength
)
;
int32_t
startSafeIndex
=
std
:
:
max
(
0
aIndex
-
nsISHistory
:
:
VIEWER_WINDOW
)
;
int32_t
endSafeIndex
=
std
:
:
min
(
mLength
aIndex
+
nsISHistory
:
:
VIEWER_WINDOW
)
;
LOG
(
(
"
EvictOutOfRangeWindowContentViewers
(
index
=
%
d
)
"
"
mLength
=
%
d
.
Safe
range
[
%
d
%
d
]
"
aIndex
mLength
startSafeIndex
endSafeIndex
)
)
;
nsCOMArray
<
nsIContentViewer
>
safeViewers
;
nsCOMPtr
<
nsISHTransaction
>
trans
;
GetTransactionAtIndex
(
startSafeIndex
getter_AddRefs
(
trans
)
)
;
for
(
int32_t
i
=
startSafeIndex
;
trans
&
&
i
<
=
endSafeIndex
;
i
+
+
)
{
nsCOMPtr
<
nsIContentViewer
>
viewer
=
GetContentViewerForTransaction
(
trans
)
;
safeViewers
.
AppendObject
(
viewer
)
;
nsCOMPtr
<
nsISHTransaction
>
temp
=
trans
;
temp
-
>
GetNext
(
getter_AddRefs
(
trans
)
)
;
}
GetTransactionAtIndex
(
0
getter_AddRefs
(
trans
)
)
;
while
(
trans
)
{
nsCOMPtr
<
nsIContentViewer
>
viewer
=
GetContentViewerForTransaction
(
trans
)
;
if
(
safeViewers
.
IndexOf
(
viewer
)
=
=
-
1
)
{
EvictContentViewerForTransaction
(
trans
)
;
}
nsCOMPtr
<
nsISHTransaction
>
temp
=
trans
;
temp
-
>
GetNext
(
getter_AddRefs
(
trans
)
)
;
}
}
namespace
{
class
TransactionAndDistance
{
public
:
TransactionAndDistance
(
nsSHistory
*
aSHistory
nsISHTransaction
*
aTrans
uint32_t
aDist
)
:
mSHistory
(
aSHistory
)
mTransaction
(
aTrans
)
mLastTouched
(
0
)
mDistance
(
aDist
)
{
mViewer
=
GetContentViewerForTransaction
(
aTrans
)
;
NS_ASSERTION
(
mViewer
"
Transaction
should
have
a
content
viewer
"
)
;
nsCOMPtr
<
nsISHEntry
>
shentry
;
mTransaction
-
>
GetSHEntry
(
getter_AddRefs
(
shentry
)
)
;
nsCOMPtr
<
nsISHEntryInternal
>
shentryInternal
=
do_QueryInterface
(
shentry
)
;
if
(
shentryInternal
)
{
shentryInternal
-
>
GetLastTouched
(
&
mLastTouched
)
;
}
else
{
NS_WARNING
(
"
Can
'
t
cast
to
nsISHEntryInternal
?
"
)
;
}
}
bool
operator
<
(
const
TransactionAndDistance
&
aOther
)
const
{
if
(
aOther
.
mDistance
!
=
this
-
>
mDistance
)
{
return
this
-
>
mDistance
<
aOther
.
mDistance
;
}
return
this
-
>
mLastTouched
<
aOther
.
mLastTouched
;
}
bool
operator
=
=
(
const
TransactionAndDistance
&
aOther
)
const
{
return
aOther
.
mDistance
=
=
this
-
>
mDistance
&
&
aOther
.
mLastTouched
=
=
this
-
>
mLastTouched
;
}
RefPtr
<
nsSHistory
>
mSHistory
;
nsCOMPtr
<
nsISHTransaction
>
mTransaction
;
nsCOMPtr
<
nsIContentViewer
>
mViewer
;
uint32_t
mLastTouched
;
int32_t
mDistance
;
}
;
}
void
nsSHistory
:
:
GloballyEvictContentViewers
(
)
{
nsTArray
<
TransactionAndDistance
>
transactions
;
for
(
auto
shist
:
gSHistoryList
)
{
nsTArray
<
TransactionAndDistance
>
shTransactions
;
int32_t
startIndex
=
std
:
:
max
(
0
shist
-
>
mIndex
-
nsISHistory
:
:
VIEWER_WINDOW
)
;
int32_t
endIndex
=
std
:
:
min
(
shist
-
>
mLength
-
1
shist
-
>
mIndex
+
nsISHistory
:
:
VIEWER_WINDOW
)
;
nsCOMPtr
<
nsISHTransaction
>
trans
;
shist
-
>
GetTransactionAtIndex
(
startIndex
getter_AddRefs
(
trans
)
)
;
for
(
int32_t
i
=
startIndex
;
trans
&
&
i
<
=
endIndex
;
i
+
+
)
{
nsCOMPtr
<
nsIContentViewer
>
contentViewer
=
GetContentViewerForTransaction
(
trans
)
;
if
(
contentViewer
)
{
bool
found
=
false
;
for
(
uint32_t
j
=
0
;
j
<
shTransactions
.
Length
(
)
;
j
+
+
)
{
TransactionAndDistance
&
container
=
shTransactions
[
j
]
;
if
(
container
.
mViewer
=
=
contentViewer
)
{
container
.
mDistance
=
std
:
:
min
(
container
.
mDistance
DeprecatedAbs
(
i
-
shist
-
>
mIndex
)
)
;
found
=
true
;
break
;
}
}
if
(
!
found
)
{
TransactionAndDistance
container
(
shist
trans
DeprecatedAbs
(
i
-
shist
-
>
mIndex
)
)
;
shTransactions
.
AppendElement
(
container
)
;
}
}
nsCOMPtr
<
nsISHTransaction
>
temp
=
trans
;
temp
-
>
GetNext
(
getter_AddRefs
(
trans
)
)
;
}
transactions
.
AppendElements
(
shTransactions
)
;
}
if
(
(
int32_t
)
transactions
.
Length
(
)
<
=
sHistoryMaxTotalViewers
)
{
return
;
}
transactions
.
Sort
(
)
;
for
(
int32_t
i
=
transactions
.
Length
(
)
-
1
;
i
>
=
sHistoryMaxTotalViewers
;
-
-
i
)
{
(
transactions
[
i
]
.
mSHistory
)
-
>
EvictContentViewerForTransaction
(
transactions
[
i
]
.
mTransaction
)
;
}
}
nsresult
nsSHistory
:
:
FindTransactionForBFCache
(
nsIBFCacheEntry
*
aEntry
nsISHTransaction
*
*
aResult
int32_t
*
aResultIndex
)
{
*
aResult
=
nullptr
;
*
aResultIndex
=
-
1
;
int32_t
startIndex
=
std
:
:
max
(
0
mIndex
-
nsISHistory
:
:
VIEWER_WINDOW
)
;
int32_t
endIndex
=
std
:
:
min
(
mLength
-
1
mIndex
+
nsISHistory
:
:
VIEWER_WINDOW
)
;
nsCOMPtr
<
nsISHTransaction
>
trans
;
GetTransactionAtIndex
(
startIndex
getter_AddRefs
(
trans
)
)
;
int32_t
i
;
for
(
i
=
startIndex
;
trans
&
&
i
<
=
endIndex
;
+
+
i
)
{
nsCOMPtr
<
nsISHEntry
>
entry
;
trans
-
>
GetSHEntry
(
getter_AddRefs
(
entry
)
)
;
if
(
entry
-
>
HasBFCacheEntry
(
aEntry
)
)
{
break
;
}
nsCOMPtr
<
nsISHTransaction
>
temp
=
trans
;
temp
-
>
GetNext
(
getter_AddRefs
(
trans
)
)
;
}
if
(
i
>
endIndex
)
{
return
NS_ERROR_FAILURE
;
}
trans
.
forget
(
aResult
)
;
*
aResultIndex
=
i
;
return
NS_OK
;
}
nsresult
nsSHistory
:
:
EvictExpiredContentViewerForEntry
(
nsIBFCacheEntry
*
aEntry
)
{
int32_t
index
;
nsCOMPtr
<
nsISHTransaction
>
trans
;
FindTransactionForBFCache
(
aEntry
getter_AddRefs
(
trans
)
&
index
)
;
if
(
index
=
=
mIndex
)
{
NS_WARNING
(
"
How
did
the
current
SHEntry
expire
?
"
)
;
return
NS_OK
;
}
if
(
trans
)
{
EvictContentViewerForTransaction
(
trans
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
AddToExpirationTracker
(
nsIBFCacheEntry
*
aEntry
)
{
RefPtr
<
nsSHEntryShared
>
entry
=
static_cast
<
nsSHEntryShared
*
>
(
aEntry
)
;
if
(
!
mHistoryTracker
|
|
!
entry
)
{
return
NS_ERROR_FAILURE
;
}
mHistoryTracker
-
>
AddObject
(
entry
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
RemoveFromExpirationTracker
(
nsIBFCacheEntry
*
aEntry
)
{
RefPtr
<
nsSHEntryShared
>
entry
=
static_cast
<
nsSHEntryShared
*
>
(
aEntry
)
;
MOZ_ASSERT
(
mHistoryTracker
&
&
!
mHistoryTracker
-
>
IsEmpty
(
)
)
;
if
(
!
mHistoryTracker
|
|
!
entry
)
{
return
NS_ERROR_FAILURE
;
}
mHistoryTracker
-
>
RemoveObject
(
entry
)
;
return
NS_OK
;
}
void
nsSHistory
:
:
GloballyEvictAllContentViewers
(
)
{
int32_t
maxViewers
=
sHistoryMaxTotalViewers
;
sHistoryMaxTotalViewers
=
0
;
GloballyEvictContentViewers
(
)
;
sHistoryMaxTotalViewers
=
maxViewers
;
}
void
GetDynamicChildren
(
nsISHContainer
*
aContainer
nsTArray
<
nsID
>
&
aDocshellIDs
bool
aOnlyTopLevelDynamic
)
{
int32_t
count
=
0
;
aContainer
-
>
GetChildCount
(
&
count
)
;
for
(
int32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
nsCOMPtr
<
nsISHEntry
>
child
;
aContainer
-
>
GetChildAt
(
i
getter_AddRefs
(
child
)
)
;
if
(
child
)
{
bool
dynAdded
=
false
;
child
-
>
IsDynamicallyAdded
(
&
dynAdded
)
;
if
(
dynAdded
)
{
nsID
docshellID
=
child
-
>
DocshellID
(
)
;
aDocshellIDs
.
AppendElement
(
docshellID
)
;
}
if
(
!
dynAdded
|
|
!
aOnlyTopLevelDynamic
)
{
nsCOMPtr
<
nsISHContainer
>
childAsContainer
=
do_QueryInterface
(
child
)
;
if
(
childAsContainer
)
{
GetDynamicChildren
(
childAsContainer
aDocshellIDs
aOnlyTopLevelDynamic
)
;
}
}
}
}
}
bool
RemoveFromSessionHistoryContainer
(
nsISHContainer
*
aContainer
nsTArray
<
nsID
>
&
aDocshellIDs
)
{
nsCOMPtr
<
nsISHEntry
>
root
=
do_QueryInterface
(
aContainer
)
;
NS_ENSURE_TRUE
(
root
false
)
;
bool
didRemove
=
false
;
int32_t
childCount
=
0
;
aContainer
-
>
GetChildCount
(
&
childCount
)
;
for
(
int32_t
i
=
childCount
-
1
;
i
>
=
0
;
-
-
i
)
{
nsCOMPtr
<
nsISHEntry
>
child
;
aContainer
-
>
GetChildAt
(
i
getter_AddRefs
(
child
)
)
;
if
(
child
)
{
nsID
docshelldID
=
child
-
>
DocshellID
(
)
;
if
(
aDocshellIDs
.
Contains
(
docshelldID
)
)
{
didRemove
=
true
;
aContainer
-
>
RemoveChild
(
child
)
;
}
else
{
nsCOMPtr
<
nsISHContainer
>
container
=
do_QueryInterface
(
child
)
;
if
(
container
)
{
bool
childRemoved
=
RemoveFromSessionHistoryContainer
(
container
aDocshellIDs
)
;
if
(
childRemoved
)
{
didRemove
=
true
;
}
}
}
}
}
return
didRemove
;
}
bool
RemoveChildEntries
(
nsISHistory
*
aHistory
int32_t
aIndex
nsTArray
<
nsID
>
&
aEntryIDs
)
{
nsCOMPtr
<
nsISHEntry
>
rootHE
;
aHistory
-
>
GetEntryAtIndex
(
aIndex
false
getter_AddRefs
(
rootHE
)
)
;
nsCOMPtr
<
nsISHContainer
>
root
=
do_QueryInterface
(
rootHE
)
;
return
root
?
RemoveFromSessionHistoryContainer
(
root
aEntryIDs
)
:
false
;
}
bool
IsSameTree
(
nsISHEntry
*
aEntry1
nsISHEntry
*
aEntry2
)
{
if
(
!
aEntry1
&
&
!
aEntry2
)
{
return
true
;
}
if
(
(
!
aEntry1
&
&
aEntry2
)
|
|
(
aEntry1
&
&
!
aEntry2
)
)
{
return
false
;
}
uint32_t
id1
id2
;
aEntry1
-
>
GetID
(
&
id1
)
;
aEntry2
-
>
GetID
(
&
id2
)
;
if
(
id1
!
=
id2
)
{
return
false
;
}
nsCOMPtr
<
nsISHContainer
>
container1
=
do_QueryInterface
(
aEntry1
)
;
nsCOMPtr
<
nsISHContainer
>
container2
=
do_QueryInterface
(
aEntry2
)
;
int32_t
count1
count2
;
container1
-
>
GetChildCount
(
&
count1
)
;
container2
-
>
GetChildCount
(
&
count2
)
;
int32_t
count
=
std
:
:
max
(
count1
count2
)
;
for
(
int32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
nsCOMPtr
<
nsISHEntry
>
child1
child2
;
container1
-
>
GetChildAt
(
i
getter_AddRefs
(
child1
)
)
;
container2
-
>
GetChildAt
(
i
getter_AddRefs
(
child2
)
)
;
if
(
!
IsSameTree
(
child1
child2
)
)
{
return
false
;
}
}
return
true
;
}
bool
nsSHistory
:
:
RemoveDuplicate
(
int32_t
aIndex
bool
aKeepNext
)
{
NS_ASSERTION
(
aIndex
>
=
0
"
aIndex
must
be
>
=
0
!
"
)
;
NS_ASSERTION
(
aIndex
!
=
0
|
|
aKeepNext
"
If
we
'
re
removing
index
0
we
must
be
keeping
the
next
"
)
;
NS_ASSERTION
(
aIndex
!
=
mIndex
"
Shouldn
'
t
remove
mIndex
!
"
)
;
int32_t
compareIndex
=
aKeepNext
?
aIndex
+
1
:
aIndex
-
1
;
nsCOMPtr
<
nsISHEntry
>
root1
root2
;
GetEntryAtIndex
(
aIndex
false
getter_AddRefs
(
root1
)
)
;
GetEntryAtIndex
(
compareIndex
false
getter_AddRefs
(
root2
)
)
;
if
(
IsSameTree
(
root1
root2
)
)
{
nsCOMPtr
<
nsISHTransaction
>
txToRemove
txToKeep
txNext
txPrev
;
GetTransactionAtIndex
(
aIndex
getter_AddRefs
(
txToRemove
)
)
;
GetTransactionAtIndex
(
compareIndex
getter_AddRefs
(
txToKeep
)
)
;
if
(
!
txToRemove
)
{
return
false
;
}
NS_ENSURE_TRUE
(
txToKeep
false
)
;
txToRemove
-
>
GetNext
(
getter_AddRefs
(
txNext
)
)
;
txToRemove
-
>
GetPrev
(
getter_AddRefs
(
txPrev
)
)
;
txToRemove
-
>
SetNext
(
nullptr
)
;
txToRemove
-
>
SetPrev
(
nullptr
)
;
if
(
aKeepNext
)
{
if
(
txPrev
)
{
txPrev
-
>
SetNext
(
txToKeep
)
;
}
else
{
txToKeep
-
>
SetPrev
(
nullptr
)
;
}
}
else
{
txToKeep
-
>
SetNext
(
txNext
)
;
}
if
(
aIndex
=
=
0
&
&
aKeepNext
)
{
NS_ASSERTION
(
txToRemove
=
=
mListRoot
"
Transaction
at
index
0
should
be
mListRoot
!
"
)
;
mListRoot
=
txToKeep
;
}
if
(
mRootDocShell
)
{
static_cast
<
nsDocShell
*
>
(
mRootDocShell
)
-
>
HistoryTransactionRemoved
(
aIndex
)
;
}
if
(
mIndex
>
aIndex
)
{
mIndex
=
mIndex
-
1
;
NOTIFY_LISTENERS
(
OnIndexChanged
(
mIndex
)
)
;
}
if
(
mRequestedIndex
>
aIndex
|
|
(
mRequestedIndex
=
=
aIndex
&
&
!
aKeepNext
)
)
{
mRequestedIndex
=
mRequestedIndex
-
1
;
}
-
-
mLength
;
mEntriesInFollowingPartialHistories
=
0
;
NOTIFY_LISTENERS
(
OnLengthChanged
(
mLength
)
)
;
return
true
;
}
return
false
;
}
NS_IMETHODIMP_
(
void
)
nsSHistory
:
:
RemoveEntries
(
nsTArray
<
nsID
>
&
aIDs
int32_t
aStartIndex
)
{
int32_t
index
=
aStartIndex
;
while
(
index
>
=
0
&
&
RemoveChildEntries
(
this
-
-
index
aIDs
)
)
{
}
int32_t
minIndex
=
index
;
index
=
aStartIndex
;
while
(
index
>
=
0
&
&
RemoveChildEntries
(
this
index
+
+
aIDs
)
)
{
}
bool
didRemove
=
false
;
while
(
index
>
minIndex
)
{
if
(
index
!
=
mIndex
)
{
didRemove
=
RemoveDuplicate
(
index
index
<
mIndex
)
|
|
didRemove
;
}
-
-
index
;
}
if
(
didRemove
&
&
mRootDocShell
)
{
mRootDocShell
-
>
DispatchLocationChangeEvent
(
)
;
}
}
void
nsSHistory
:
:
RemoveDynEntries
(
int32_t
aIndex
nsISHContainer
*
aContainer
)
{
nsCOMPtr
<
nsISHContainer
>
container
(
aContainer
)
;
if
(
!
container
)
{
nsCOMPtr
<
nsISHEntry
>
entry
;
GetEntryAtIndex
(
aIndex
false
getter_AddRefs
(
entry
)
)
;
container
=
do_QueryInterface
(
entry
)
;
}
if
(
container
)
{
AutoTArray
<
nsID
16
>
toBeRemovedEntries
;
GetDynamicChildren
(
container
toBeRemovedEntries
true
)
;
if
(
toBeRemovedEntries
.
Length
(
)
)
{
RemoveEntries
(
toBeRemovedEntries
aIndex
)
;
}
}
}
void
nsSHistory
:
:
RemoveDynEntriesForBFCacheEntry
(
nsIBFCacheEntry
*
aEntry
)
{
int32_t
index
;
nsCOMPtr
<
nsISHTransaction
>
trans
;
FindTransactionForBFCache
(
aEntry
getter_AddRefs
(
trans
)
&
index
)
;
if
(
trans
)
{
nsCOMPtr
<
nsISHEntry
>
entry
;
trans
-
>
GetSHEntry
(
getter_AddRefs
(
entry
)
)
;
nsCOMPtr
<
nsISHContainer
>
container
(
do_QueryInterface
(
entry
)
)
;
RemoveDynEntries
(
index
container
)
;
}
}
NS_IMETHODIMP
nsSHistory
:
:
UpdateIndex
(
)
{
if
(
mIndex
!
=
mRequestedIndex
&
&
mRequestedIndex
!
=
-
1
)
{
mIndex
=
mRequestedIndex
;
NOTIFY_LISTENERS
(
OnIndexChanged
(
mIndex
)
)
}
mRequestedIndex
=
-
1
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
Stop
(
uint32_t
aStopFlags
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetDocument
(
nsIDOMDocument
*
*
aDocument
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetCurrentURI
(
nsIURI
*
*
aResultURI
)
{
NS_ENSURE_ARG_POINTER
(
aResultURI
)
;
nsresult
rv
;
nsCOMPtr
<
nsISHEntry
>
currentEntry
;
rv
=
GetEntryAtIndex
(
mIndex
false
getter_AddRefs
(
currentEntry
)
)
;
if
(
NS_FAILED
(
rv
)
&
&
!
currentEntry
)
{
return
rv
;
}
rv
=
currentEntry
-
>
GetURI
(
aResultURI
)
;
return
rv
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetReferringURI
(
nsIURI
*
*
aURI
)
{
*
aURI
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
SetSessionHistory
(
nsISHistory
*
aSessionHistory
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetSessionHistory
(
nsISHistory
*
*
aSessionHistory
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
LoadURIWithOptions
(
const
char16_t
*
aURI
uint32_t
aLoadFlags
nsIURI
*
aReferringURI
uint32_t
aReferrerPolicy
nsIInputStream
*
aPostStream
nsIInputStream
*
aExtraHeaderStream
nsIURI
*
aBaseURI
nsIPrincipal
*
aTriggeringPrincipal
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
SetOriginAttributesBeforeLoading
(
JS
:
:
HandleValue
aOriginAttributes
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
LoadURI
(
const
char16_t
*
aURI
uint32_t
aLoadFlags
nsIURI
*
aReferringURI
nsIInputStream
*
aPostStream
nsIInputStream
*
aExtraHeaderStream
nsIPrincipal
*
aTriggeringPrincipal
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GotoIndex
(
int32_t
aGlobalIndex
)
{
return
LoadEntry
(
aGlobalIndex
-
mGlobalIndexOffset
nsIDocShellLoadInfo
:
:
loadHistory
HIST_CMD_GOTOINDEX
)
;
}
nsresult
nsSHistory
:
:
LoadNextPossibleEntry
(
int32_t
aNewIndex
long
aLoadType
uint32_t
aHistCmd
)
{
mRequestedIndex
=
-
1
;
if
(
aNewIndex
<
mIndex
)
{
return
LoadEntry
(
aNewIndex
-
1
aLoadType
aHistCmd
)
;
}
if
(
aNewIndex
>
mIndex
)
{
return
LoadEntry
(
aNewIndex
+
1
aLoadType
aHistCmd
)
;
}
return
NS_ERROR_FAILURE
;
}
nsresult
nsSHistory
:
:
LoadEntry
(
int32_t
aIndex
long
aLoadType
uint32_t
aHistCmd
)
{
if
(
!
mRootDocShell
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIURI
>
nextURI
;
nsCOMPtr
<
nsISHEntry
>
prevEntry
;
nsCOMPtr
<
nsISHEntry
>
nextEntry
;
bool
isCrossBrowserNavigation
=
false
;
if
(
aIndex
<
0
|
|
aIndex
>
=
mLength
)
{
if
(
aIndex
+
mGlobalIndexOffset
<
0
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aIndex
-
mLength
>
=
mEntriesInFollowingPartialHistories
)
{
return
NS_ERROR_FAILURE
;
}
isCrossBrowserNavigation
=
true
;
}
else
{
mRequestedIndex
=
aIndex
;
GetEntryAtIndex
(
mIndex
false
getter_AddRefs
(
prevEntry
)
)
;
GetEntryAtIndex
(
mRequestedIndex
false
getter_AddRefs
(
nextEntry
)
)
;
if
(
!
nextEntry
|
|
!
prevEntry
)
{
mRequestedIndex
=
-
1
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISHEntryInternal
>
entryInternal
=
do_QueryInterface
(
nextEntry
)
;
if
(
entryInternal
)
{
entryInternal
-
>
SetLastTouched
(
+
+
gTouchCounter
)
;
}
nextEntry
-
>
GetURI
(
getter_AddRefs
(
nextURI
)
)
;
}
MOZ_ASSERT
(
isCrossBrowserNavigation
|
|
(
prevEntry
&
&
nextEntry
&
&
nextURI
)
"
prevEntry
nextEntry
and
nextURI
can
be
null
only
if
isCrossBrowserNavigation
is
set
"
)
;
bool
canNavigate
=
true
;
if
(
aHistCmd
=
=
HIST_CMD_BACK
)
{
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryGoBack
canNavigate
(
nextURI
&
canNavigate
)
)
;
}
else
if
(
aHistCmd
=
=
HIST_CMD_FORWARD
)
{
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryGoForward
canNavigate
(
nextURI
&
canNavigate
)
)
;
}
else
if
(
aHistCmd
=
=
HIST_CMD_GOTOINDEX
)
{
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryGotoIndex
canNavigate
(
aIndex
nextURI
&
canNavigate
)
)
;
}
if
(
!
canNavigate
)
{
mRequestedIndex
=
-
1
;
return
NS_OK
;
}
if
(
isCrossBrowserNavigation
)
{
nsCOMPtr
<
nsIPartialSHistoryListener
>
listener
=
do_QueryReferent
(
mPartialHistoryListener
)
;
if
(
!
listener
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_FAILED
(
mRootDocShell
-
>
CreateAboutBlankContentViewer
(
nullptr
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
listener
-
>
OnRequestCrossBrowserNavigation
(
aIndex
+
mGlobalIndexOffset
)
;
}
if
(
mRequestedIndex
=
=
mIndex
)
{
return
InitiateLoad
(
nextEntry
mRootDocShell
aLoadType
)
;
}
bool
differenceFound
=
false
;
nsresult
rv
=
LoadDifferingEntries
(
prevEntry
nextEntry
mRootDocShell
aLoadType
differenceFound
)
;
if
(
!
differenceFound
)
{
return
LoadNextPossibleEntry
(
aIndex
aLoadType
aHistCmd
)
;
}
return
rv
;
}
nsresult
nsSHistory
:
:
LoadDifferingEntries
(
nsISHEntry
*
aPrevEntry
nsISHEntry
*
aNextEntry
nsIDocShell
*
aParent
long
aLoadType
bool
&
aDifferenceFound
)
{
if
(
!
aPrevEntry
|
|
!
aNextEntry
|
|
!
aParent
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
result
=
NS_OK
;
uint32_t
prevID
nextID
;
aPrevEntry
-
>
GetID
(
&
prevID
)
;
aNextEntry
-
>
GetID
(
&
nextID
)
;
if
(
prevID
!
=
nextID
)
{
aDifferenceFound
=
true
;
aNextEntry
-
>
SetIsSubFrame
(
aParent
!
=
mRootDocShell
)
;
return
InitiateLoad
(
aNextEntry
aParent
aLoadType
)
;
}
int32_t
pcnt
=
0
;
int32_t
ncnt
=
0
;
int32_t
dsCount
=
0
;
nsCOMPtr
<
nsISHContainer
>
prevContainer
(
do_QueryInterface
(
aPrevEntry
)
)
;
nsCOMPtr
<
nsISHContainer
>
nextContainer
(
do_QueryInterface
(
aNextEntry
)
)
;
if
(
!
prevContainer
|
|
!
nextContainer
)
{
return
NS_ERROR_FAILURE
;
}
prevContainer
-
>
GetChildCount
(
&
pcnt
)
;
nextContainer
-
>
GetChildCount
(
&
ncnt
)
;
aParent
-
>
GetChildCount
(
&
dsCount
)
;
nsCOMArray
<
nsIDocShell
>
docshells
;
for
(
int32_t
i
=
0
;
i
<
dsCount
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
;
aParent
-
>
GetChildAt
(
i
getter_AddRefs
(
treeItem
)
)
;
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryInterface
(
treeItem
)
;
if
(
shell
)
{
docshells
.
AppendElement
(
shell
.
forget
(
)
)
;
}
}
for
(
int32_t
i
=
0
;
i
<
ncnt
;
+
+
i
)
{
nsCOMPtr
<
nsISHEntry
>
nChild
;
nextContainer
-
>
GetChildAt
(
i
getter_AddRefs
(
nChild
)
)
;
if
(
!
nChild
)
{
continue
;
}
nsID
docshellID
=
nChild
-
>
DocshellID
(
)
;
nsIDocShell
*
dsChild
=
nullptr
;
int32_t
count
=
docshells
.
Count
(
)
;
for
(
int32_t
j
=
0
;
j
<
count
;
+
+
j
)
{
nsIDocShell
*
shell
=
docshells
[
j
]
;
nsID
shellID
=
shell
-
>
HistoryID
(
)
;
if
(
shellID
=
=
docshellID
)
{
dsChild
=
shell
;
break
;
}
}
if
(
!
dsChild
)
{
continue
;
}
nsCOMPtr
<
nsISHEntry
>
pChild
;
for
(
int32_t
k
=
0
;
k
<
pcnt
;
+
+
k
)
{
nsCOMPtr
<
nsISHEntry
>
child
;
prevContainer
-
>
GetChildAt
(
k
getter_AddRefs
(
child
)
)
;
if
(
child
)
{
nsID
dID
=
child
-
>
DocshellID
(
)
;
if
(
dID
=
=
docshellID
)
{
pChild
=
child
;
break
;
}
}
}
LoadDifferingEntries
(
pChild
nChild
dsChild
aLoadType
aDifferenceFound
)
;
}
return
result
;
}
nsresult
nsSHistory
:
:
InitiateLoad
(
nsISHEntry
*
aFrameEntry
nsIDocShell
*
aFrameDS
long
aLoadType
)
{
NS_ENSURE_STATE
(
aFrameDS
&
&
aFrameEntry
)
;
nsCOMPtr
<
nsIDocShellLoadInfo
>
loadInfo
;
aFrameEntry
-
>
SetLoadType
(
aLoadType
)
;
aFrameDS
-
>
CreateLoadInfo
(
getter_AddRefs
(
loadInfo
)
)
;
loadInfo
-
>
SetLoadType
(
aLoadType
)
;
loadInfo
-
>
SetSHEntry
(
aFrameEntry
)
;
nsCOMPtr
<
nsIURI
>
originalURI
;
aFrameEntry
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
loadInfo
-
>
SetOriginalURI
(
originalURI
)
;
bool
loadReplace
;
aFrameEntry
-
>
GetLoadReplace
(
&
loadReplace
)
;
loadInfo
-
>
SetLoadReplace
(
loadReplace
)
;
nsCOMPtr
<
nsIURI
>
nextURI
;
aFrameEntry
-
>
GetURI
(
getter_AddRefs
(
nextURI
)
)
;
return
aFrameDS
-
>
LoadURI
(
nextURI
loadInfo
nsIWebNavigation
:
:
LOAD_FLAGS_NONE
false
)
;
}
NS_IMETHODIMP
nsSHistory
:
:
SetRootDocShell
(
nsIDocShell
*
aDocShell
)
{
mRootDocShell
=
aDocShell
;
if
(
mRootDocShell
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
mRootDocShell
-
>
GetWindow
(
)
;
if
(
!
win
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
mHistoryTracker
)
{
NS_WARNING
(
"
Change
the
root
docshell
of
a
shistory
is
unsafe
and
"
"
potentially
problematic
.
"
)
;
mHistoryTracker
-
>
AgeAllGenerations
(
)
;
}
RefPtr
<
mozilla
:
:
dom
:
:
TabGroup
>
tabGroup
=
win
-
>
TabGroup
(
)
;
mHistoryTracker
=
mozilla
:
:
MakeUnique
<
HistoryTracker
>
(
this
mozilla
:
:
Preferences
:
:
GetUint
(
CONTENT_VIEWER_TIMEOUT_SECONDS
CONTENT_VIEWER_TIMEOUT_SECONDS_DEFAULT
)
tabGroup
-
>
EventTargetFor
(
mozilla
:
:
TaskCategory
:
:
Other
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetSHistoryEnumerator
(
nsISimpleEnumerator
*
*
aEnumerator
)
{
NS_ENSURE_ARG_POINTER
(
aEnumerator
)
;
RefPtr
<
nsSHEnumerator
>
iterator
=
new
nsSHEnumerator
(
this
)
;
iterator
.
forget
(
aEnumerator
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
OnAttachGroupedSHistory
(
int32_t
aOffset
)
{
NS_ENSURE_TRUE
(
!
mIsPartial
&
&
mRootDocShell
NS_ERROR_UNEXPECTED
)
;
NS_ENSURE_TRUE
(
aOffset
>
=
0
NS_ERROR_ILLEGAL_VALUE
)
;
mIsPartial
=
true
;
mGlobalIndexOffset
=
aOffset
;
mEntriesInFollowingPartialHistories
=
0
;
mRootDocShell
-
>
DispatchLocationChangeEvent
(
)
;
return
NS_OK
;
}
nsSHEnumerator
:
:
nsSHEnumerator
(
nsSHistory
*
aSHistory
)
:
mIndex
(
-
1
)
{
mSHistory
=
aSHistory
;
}
nsSHEnumerator
:
:
~
nsSHEnumerator
(
)
{
mSHistory
=
nullptr
;
}
NS_IMPL_ISUPPORTS
(
nsSHEnumerator
nsISimpleEnumerator
)
NS_IMETHODIMP
nsSHEnumerator
:
:
HasMoreElements
(
bool
*
aReturn
)
{
int32_t
cnt
;
*
aReturn
=
false
;
mSHistory
-
>
GetCount
(
&
cnt
)
;
if
(
mIndex
>
=
-
1
&
&
mIndex
<
(
cnt
-
1
)
)
{
*
aReturn
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHEnumerator
:
:
GetNext
(
nsISupports
*
*
aItem
)
{
NS_ENSURE_ARG_POINTER
(
aItem
)
;
int32_t
cnt
=
0
;
nsresult
result
=
NS_ERROR_FAILURE
;
mSHistory
-
>
GetCount
(
&
cnt
)
;
if
(
mIndex
<
(
cnt
-
1
)
)
{
mIndex
+
+
;
nsCOMPtr
<
nsISHEntry
>
hEntry
;
result
=
mSHistory
-
>
GetEntryAtIndex
(
mIndex
false
getter_AddRefs
(
hEntry
)
)
;
if
(
hEntry
)
{
result
=
CallQueryInterface
(
hEntry
aItem
)
;
}
}
return
result
;
}
