#
include
"
nsSHistory
.
h
"
#
include
<
algorithm
>
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsISHEntry
.
h
"
#
include
"
nsISHistoryListener
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsSHEntry
.
h
"
#
include
"
SessionHistoryEntry
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs_fission
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsDocShellLoadTypes
.
h
"
#
include
"
base
/
process
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
define
PREF_SHISTORY_SIZE
"
browser
.
sessionhistory
.
max_entries
"
#
define
PREF_SHISTORY_MAX_TOTAL_VIEWERS
\
"
browser
.
sessionhistory
.
max_total_viewers
"
#
define
CONTENT_VIEWER_TIMEOUT_SECONDS
\
"
browser
.
sessionhistory
.
contentViewerTimeout
"
#
define
CONTENT_VIEWER_TIMEOUT_SECONDS_DEFAULT
(
30
*
60
)
static
const
char
*
kObservedPrefs
[
]
=
{
PREF_SHISTORY_SIZE
PREF_SHISTORY_MAX_TOTAL_VIEWERS
nullptr
}
;
static
int32_t
gHistoryMaxSize
=
50
;
static
LinkedList
<
nsSHistory
>
gSHistoryList
;
int32_t
nsSHistory
:
:
sHistoryMaxTotalViewers
=
-
1
;
static
uint32_t
gTouchCounter
=
0
;
LazyLogModule
gSHistoryLog
(
"
nsSHistory
"
)
;
#
define
LOG
(
format
)
MOZ_LOG
(
gSHistoryLog
mozilla
:
:
LogLevel
:
:
Debug
format
)
extern
mozilla
:
:
LazyLogModule
gPageCacheLog
;
#
define
LOG_SPEC
(
format
uri
)
\
PR_BEGIN_MACRO
\
if
(
MOZ_LOG_TEST
(
gSHistoryLog
LogLevel
:
:
Debug
)
)
{
\
nsAutoCString
_specStr
(
"
(
null
)
"
_ns
)
;
\
if
(
uri
)
{
\
_specStr
=
uri
-
>
GetSpecOrDefault
(
)
;
\
}
\
const
char
*
_spec
=
_specStr
.
get
(
)
;
\
LOG
(
format
)
;
\
}
\
PR_END_MACRO
#
define
LOG_SHENTRY_SPEC
(
format
shentry
)
\
PR_BEGIN_MACRO
\
if
(
MOZ_LOG_TEST
(
gSHistoryLog
LogLevel
:
:
Debug
)
)
{
\
nsCOMPtr
<
nsIURI
>
uri
=
shentry
-
>
GetURI
(
)
;
\
LOG_SPEC
(
format
uri
)
;
\
}
\
PR_END_MACRO
#
define
ITERATE_LISTENERS
(
body
)
\
PR_BEGIN_MACRO
{
\
for
(
const
nsWeakPtr
&
weakPtr
:
mListeners
.
EndLimitedRange
(
)
)
{
\
nsCOMPtr
<
nsISHistoryListener
>
listener
=
do_QueryReferent
(
weakPtr
)
;
\
if
(
listener
)
{
\
body
\
}
\
}
\
}
\
PR_END_MACRO
#
define
NOTIFY_LISTENERS
(
method
args
)
\
ITERATE_LISTENERS
(
listener
-
>
method
args
;
)
;
#
define
NOTIFY_LISTENERS_CANCELABLE
(
method
retval
args
)
\
PR_BEGIN_MACRO
{
\
bool
canceled
=
false
;
\
retval
=
true
;
\
ITERATE_LISTENERS
(
listener
-
>
method
args
;
\
if
(
!
retval
)
{
canceled
=
true
;
}
)
;
\
if
(
canceled
)
{
\
retval
=
false
;
\
}
\
}
\
PR_END_MACRO
class
SHistoryChangeNotifier
{
public
:
explicit
SHistoryChangeNotifier
(
nsSHistory
*
aHistory
)
{
if
(
!
aHistory
-
>
HasOngoingUpdate
(
)
)
{
aHistory
-
>
SetHasOngoingUpdate
(
true
)
;
mSHistory
=
aHistory
;
mInitialIndex
=
aHistory
-
>
Index
(
)
;
mInitialLength
=
aHistory
-
>
Length
(
)
;
}
}
~
SHistoryChangeNotifier
(
)
{
if
(
mSHistory
)
{
MOZ_ASSERT
(
mSHistory
-
>
HasOngoingUpdate
(
)
)
;
mSHistory
-
>
SetHasOngoingUpdate
(
false
)
;
if
(
mSHistory
-
>
GetBrowsingContext
(
)
)
{
mSHistory
-
>
GetBrowsingContext
(
)
-
>
SessionHistoryChanged
(
mSHistory
-
>
Index
(
)
-
mInitialIndex
mSHistory
-
>
Length
(
)
-
mInitialLength
)
;
}
}
}
RefPtr
<
nsSHistory
>
mSHistory
;
int32_t
mInitialIndex
;
int32_t
mInitialLength
;
}
;
enum
HistCmd
{
HIST_CMD_GOTOINDEX
HIST_CMD_RELOAD
}
;
class
nsSHistoryObserver
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
nsSHistoryObserver
(
)
{
}
static
void
PrefChanged
(
const
char
*
aPref
void
*
aSelf
)
;
void
PrefChanged
(
const
char
*
aPref
)
;
protected
:
~
nsSHistoryObserver
(
)
{
}
}
;
StaticRefPtr
<
nsSHistoryObserver
>
gObserver
;
NS_IMPL_ISUPPORTS
(
nsSHistoryObserver
nsIObserver
)
void
nsSHistoryObserver
:
:
PrefChanged
(
const
char
*
aPref
void
*
aSelf
)
{
static_cast
<
nsSHistoryObserver
*
>
(
aSelf
)
-
>
PrefChanged
(
aPref
)
;
}
void
nsSHistoryObserver
:
:
PrefChanged
(
const
char
*
aPref
)
{
nsSHistory
:
:
UpdatePrefs
(
)
;
nsSHistory
:
:
GloballyEvictContentViewers
(
)
;
}
NS_IMETHODIMP
nsSHistoryObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
"
cacheservice
:
empty
-
cache
"
)
|
|
!
strcmp
(
aTopic
"
memory
-
pressure
"
)
)
{
nsSHistory
:
:
GloballyEvictAllContentViewers
(
)
;
}
return
NS_OK
;
}
void
nsSHistory
:
:
EvictContentViewerForEntry
(
nsISHEntry
*
aEntry
)
{
nsCOMPtr
<
nsIContentViewer
>
viewer
=
aEntry
-
>
GetContentViewer
(
)
;
if
(
viewer
)
{
LOG_SHENTRY_SPEC
(
(
"
Evicting
content
viewer
0x
%
p
for
"
"
owning
SHEntry
0x
%
p
at
%
s
.
"
viewer
.
get
(
)
aEntry
_spec
)
aEntry
)
;
NotifyListenersContentViewerEvicted
(
1
)
;
aEntry
-
>
SetContentViewer
(
nullptr
)
;
aEntry
-
>
SyncPresentationState
(
)
;
viewer
-
>
Destroy
(
)
;
}
int32_t
index
=
GetIndexOfEntry
(
aEntry
)
;
if
(
index
!
=
-
1
)
{
RemoveDynEntries
(
index
aEntry
)
;
}
}
nsSHistory
:
:
nsSHistory
(
BrowsingContext
*
aRootBC
)
:
mRootBC
(
aRootBC
)
mHasOngoingUpdate
(
false
)
mIsRemote
(
false
)
mIndex
(
-
1
)
mRequestedIndex
(
-
1
)
mRootDocShellID
(
aRootBC
-
>
GetHistoryID
(
)
)
{
gSHistoryList
.
insertBack
(
this
)
;
nsPIDOMWindowOuter
*
win
;
if
(
mRootBC
&
&
(
win
=
mRootBC
-
>
GetDOMWindow
(
)
)
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
win
)
;
mHistoryTracker
=
mozilla
:
:
MakeUnique
<
HistoryTracker
>
(
this
mozilla
:
:
Preferences
:
:
GetUint
(
CONTENT_VIEWER_TIMEOUT_SECONDS
CONTENT_VIEWER_TIMEOUT_SECONDS_DEFAULT
)
global
-
>
EventTargetFor
(
mozilla
:
:
TaskCategory
:
:
Other
)
)
;
}
}
nsSHistory
:
:
~
nsSHistory
(
)
{
}
NS_IMPL_ADDREF
(
nsSHistory
)
NS_IMPL_RELEASE
(
nsSHistory
)
NS_INTERFACE_MAP_BEGIN
(
nsSHistory
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsISHistory
)
NS_INTERFACE_MAP_ENTRY
(
nsISHistory
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END
uint32_t
nsSHistory
:
:
CalcMaxTotalViewers
(
)
{
#
ifdef
ANDROID
#
define
MAX_TOTAL_VIEWERS_BIAS
15
.
9
#
else
#
define
MAX_TOTAL_VIEWERS_BIAS
14
#
endif
uint64_t
bytes
=
PR_GetPhysicalMemorySize
(
)
;
if
(
bytes
=
=
0
)
{
return
0
;
}
if
(
bytes
>
INT64_MAX
)
{
bytes
=
INT64_MAX
;
}
double
kBytesD
=
(
double
)
(
bytes
>
>
10
)
;
uint32_t
viewers
=
0
;
double
x
=
std
:
:
log
(
kBytesD
)
/
std
:
:
log
(
2
.
0
)
-
MAX_TOTAL_VIEWERS_BIAS
;
if
(
x
>
0
)
{
viewers
=
(
uint32_t
)
(
x
*
x
-
x
+
2
.
001
)
;
viewers
/
=
4
;
}
if
(
viewers
>
8
)
{
viewers
=
8
;
}
return
viewers
;
}
void
nsSHistory
:
:
UpdatePrefs
(
)
{
Preferences
:
:
GetInt
(
PREF_SHISTORY_SIZE
&
gHistoryMaxSize
)
;
if
(
StaticPrefs
:
:
fission_sessionHistoryInParent
(
)
)
{
sHistoryMaxTotalViewers
=
0
;
return
;
}
Preferences
:
:
GetInt
(
PREF_SHISTORY_MAX_TOTAL_VIEWERS
&
sHistoryMaxTotalViewers
)
;
if
(
sHistoryMaxTotalViewers
<
0
)
{
sHistoryMaxTotalViewers
=
CalcMaxTotalViewers
(
)
;
}
}
nsresult
nsSHistory
:
:
Startup
(
)
{
UpdatePrefs
(
)
;
int32_t
defaultHistoryMaxSize
=
Preferences
:
:
GetInt
(
PREF_SHISTORY_SIZE
50
PrefValueKind
:
:
Default
)
;
if
(
gHistoryMaxSize
<
defaultHistoryMaxSize
)
{
gHistoryMaxSize
=
defaultHistoryMaxSize
;
}
if
(
!
gObserver
)
{
gObserver
=
new
nsSHistoryObserver
(
)
;
Preferences
:
:
RegisterCallbacks
(
nsSHistoryObserver
:
:
PrefChanged
kObservedPrefs
gObserver
.
get
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
AddObserver
(
gObserver
"
cacheservice
:
empty
-
cache
"
false
)
;
obsSvc
-
>
AddObserver
(
gObserver
"
memory
-
pressure
"
false
)
;
}
}
return
NS_OK
;
}
void
nsSHistory
:
:
Shutdown
(
)
{
if
(
gObserver
)
{
Preferences
:
:
UnregisterCallbacks
(
nsSHistoryObserver
:
:
PrefChanged
kObservedPrefs
gObserver
.
get
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
RemoveObserver
(
gObserver
"
cacheservice
:
empty
-
cache
"
)
;
obsSvc
-
>
RemoveObserver
(
gObserver
"
memory
-
pressure
"
)
;
}
gObserver
=
nullptr
;
}
}
already_AddRefed
<
nsISHEntry
>
nsSHistory
:
:
GetRootSHEntry
(
nsISHEntry
*
aEntry
)
{
nsCOMPtr
<
nsISHEntry
>
rootEntry
=
aEntry
;
nsCOMPtr
<
nsISHEntry
>
result
=
nullptr
;
while
(
rootEntry
)
{
result
=
rootEntry
;
rootEntry
=
result
-
>
GetParent
(
)
;
}
return
result
.
forget
(
)
;
}
nsresult
nsSHistory
:
:
WalkHistoryEntries
(
nsISHEntry
*
aRootEntry
BrowsingContext
*
aBC
WalkHistoryEntriesFunc
aCallback
void
*
aData
)
{
NS_ENSURE_TRUE
(
aRootEntry
NS_ERROR_FAILURE
)
;
int32_t
childCount
=
aRootEntry
-
>
GetChildCount
(
)
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
i
+
+
)
{
nsCOMPtr
<
nsISHEntry
>
childEntry
;
aRootEntry
-
>
GetChildAt
(
i
getter_AddRefs
(
childEntry
)
)
;
if
(
!
childEntry
)
{
aCallback
(
nullptr
nullptr
i
aData
)
;
continue
;
}
BrowsingContext
*
childBC
=
nullptr
;
if
(
aBC
)
{
for
(
BrowsingContext
*
child
:
aBC
-
>
Children
(
)
)
{
nsDocShell
*
docshell
=
static_cast
<
nsDocShell
*
>
(
child
-
>
GetDocShell
(
)
)
;
if
(
docshell
&
&
docshell
-
>
HasHistoryEntry
(
childEntry
)
)
{
childBC
=
docshell
-
>
GetBrowsingContext
(
)
;
break
;
}
}
}
nsresult
rv
=
aCallback
(
childEntry
childBC
i
aData
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
struct
MOZ_STACK_CLASS
CloneAndReplaceData
{
CloneAndReplaceData
(
uint32_t
aCloneID
nsISHEntry
*
aReplaceEntry
bool
aCloneChildren
nsISHEntry
*
aDestTreeParent
)
:
cloneID
(
aCloneID
)
cloneChildren
(
aCloneChildren
)
replaceEntry
(
aReplaceEntry
)
destTreeParent
(
aDestTreeParent
)
{
}
uint32_t
cloneID
;
bool
cloneChildren
;
nsISHEntry
*
replaceEntry
;
nsISHEntry
*
destTreeParent
;
nsCOMPtr
<
nsISHEntry
>
resultEntry
;
}
;
nsresult
nsSHistory
:
:
CloneAndReplaceChild
(
nsISHEntry
*
aEntry
BrowsingContext
*
aOwnerBC
int32_t
aChildIndex
void
*
aData
)
{
nsCOMPtr
<
nsISHEntry
>
dest
;
CloneAndReplaceData
*
data
=
static_cast
<
CloneAndReplaceData
*
>
(
aData
)
;
uint32_t
cloneID
=
data
-
>
cloneID
;
nsISHEntry
*
replaceEntry
=
data
-
>
replaceEntry
;
if
(
!
aEntry
)
{
if
(
data
-
>
destTreeParent
)
{
data
-
>
destTreeParent
-
>
AddChild
(
nullptr
aChildIndex
)
;
}
return
NS_OK
;
}
uint32_t
srcID
=
aEntry
-
>
GetID
(
)
;
nsresult
rv
=
NS_OK
;
if
(
srcID
=
=
cloneID
)
{
dest
=
replaceEntry
;
}
else
{
rv
=
aEntry
-
>
Clone
(
getter_AddRefs
(
dest
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
dest
-
>
SetIsSubFrame
(
true
)
;
if
(
srcID
!
=
cloneID
|
|
data
-
>
cloneChildren
)
{
CloneAndReplaceData
childData
(
cloneID
replaceEntry
data
-
>
cloneChildren
dest
)
;
rv
=
nsSHistory
:
:
WalkHistoryEntries
(
aEntry
aOwnerBC
CloneAndReplaceChild
&
childData
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
srcID
!
=
cloneID
&
&
aOwnerBC
)
{
nsSHistory
:
:
HandleEntriesToSwapInDocShell
(
aOwnerBC
aEntry
dest
)
;
}
if
(
data
-
>
destTreeParent
)
{
data
-
>
destTreeParent
-
>
AddChild
(
dest
aChildIndex
)
;
}
data
-
>
resultEntry
=
dest
;
return
rv
;
}
nsresult
nsSHistory
:
:
CloneAndReplace
(
nsISHEntry
*
aSrcEntry
BrowsingContext
*
aOwnerBC
uint32_t
aCloneID
nsISHEntry
*
aReplaceEntry
bool
aCloneChildren
nsISHEntry
*
*
aDestEntry
)
{
NS_ENSURE_ARG_POINTER
(
aDestEntry
)
;
NS_ENSURE_TRUE
(
aReplaceEntry
NS_ERROR_FAILURE
)
;
CloneAndReplaceData
data
(
aCloneID
aReplaceEntry
aCloneChildren
nullptr
)
;
nsresult
rv
=
CloneAndReplaceChild
(
aSrcEntry
aOwnerBC
0
&
data
)
;
data
.
resultEntry
.
swap
(
*
aDestEntry
)
;
return
rv
;
}
NS_IMETHODIMP
nsSHistory
:
:
AddChildSHEntryHelper
(
nsISHEntry
*
aCloneRef
nsISHEntry
*
aNewEntry
BrowsingContext
*
aRootBC
bool
aCloneChildren
)
{
MOZ_ASSERT
(
aRootBC
-
>
IsTop
(
)
)
;
nsCOMPtr
<
nsISHEntry
>
child
;
nsCOMPtr
<
nsISHEntry
>
currentHE
;
int32_t
index
=
mIndex
;
if
(
index
<
0
)
{
return
NS_ERROR_FAILURE
;
}
GetEntryAtIndex
(
index
getter_AddRefs
(
currentHE
)
)
;
NS_ENSURE_TRUE
(
currentHE
NS_ERROR_FAILURE
)
;
nsresult
rv
=
NS_OK
;
uint32_t
cloneID
=
aCloneRef
-
>
GetID
(
)
;
rv
=
nsSHistory
:
:
CloneAndReplace
(
currentHE
aRootBC
cloneID
aNewEntry
aCloneChildren
getter_AddRefs
(
child
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
AddEntry
(
child
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
child
-
>
SetDocshellID
(
aRootBC
-
>
GetHistoryID
(
)
)
;
}
}
return
rv
;
}
nsresult
nsSHistory
:
:
SetChildHistoryEntry
(
nsISHEntry
*
aEntry
BrowsingContext
*
aBC
int32_t
aEntryIndex
void
*
aData
)
{
SwapEntriesData
*
data
=
static_cast
<
SwapEntriesData
*
>
(
aData
)
;
if
(
!
aBC
|
|
aBC
=
=
data
-
>
ignoreBC
)
{
return
NS_OK
;
}
nsISHEntry
*
destTreeRoot
=
data
-
>
destTreeRoot
;
nsCOMPtr
<
nsISHEntry
>
destEntry
;
if
(
data
-
>
destTreeParent
)
{
uint32_t
targetID
=
aEntry
-
>
GetID
(
)
;
nsCOMPtr
<
nsISHEntry
>
entry
;
data
-
>
destTreeParent
-
>
GetChildAt
(
aEntryIndex
getter_AddRefs
(
entry
)
)
;
if
(
entry
&
&
entry
-
>
GetID
(
)
=
=
targetID
)
{
destEntry
.
swap
(
entry
)
;
}
else
{
int32_t
childCount
;
data
-
>
destTreeParent
-
>
GetChildCount
(
&
childCount
)
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
data
-
>
destTreeParent
-
>
GetChildAt
(
i
getter_AddRefs
(
entry
)
)
;
if
(
!
entry
)
{
continue
;
}
if
(
entry
-
>
GetID
(
)
=
=
targetID
)
{
destEntry
.
swap
(
entry
)
;
break
;
}
}
}
}
else
{
destEntry
=
destTreeRoot
;
}
nsSHistory
:
:
HandleEntriesToSwapInDocShell
(
aBC
aEntry
destEntry
)
;
SwapEntriesData
childData
=
{
data
-
>
ignoreBC
destTreeRoot
destEntry
}
;
return
nsSHistory
:
:
WalkHistoryEntries
(
aEntry
aBC
SetChildHistoryEntry
&
childData
)
;
}
void
nsSHistory
:
:
HandleEntriesToSwapInDocShell
(
mozilla
:
:
dom
:
:
BrowsingContext
*
aBC
nsISHEntry
*
aOldEntry
nsISHEntry
*
aNewEntry
)
{
bool
shPref
=
StaticPrefs
:
:
fission_sessionHistoryInParent
(
)
;
if
(
aBC
-
>
IsInProcess
(
)
|
|
!
shPref
)
{
nsDocShell
*
docshell
=
static_cast
<
nsDocShell
*
>
(
aBC
-
>
GetDocShell
(
)
)
;
if
(
docshell
)
{
docshell
-
>
SwapHistoryEntries
(
aOldEntry
aNewEntry
)
;
}
}
else
{
}
}
NS_IMETHODIMP
nsSHistory
:
:
AddToRootSessionHistory
(
bool
aCloneChildren
nsISHEntry
*
aOSHE
BrowsingContext
*
aRootBC
nsISHEntry
*
aEntry
uint32_t
aLoadType
bool
aShouldPersist
Maybe
<
int32_t
>
*
aPreviousEntryIndex
Maybe
<
int32_t
>
*
aLoadedEntryIndex
)
{
MOZ_ASSERT
(
aRootBC
-
>
IsTop
(
)
)
;
nsresult
rv
=
NS_OK
;
if
(
aCloneChildren
&
&
aOSHE
)
{
uint32_t
cloneID
=
aOSHE
-
>
GetID
(
)
;
nsCOMPtr
<
nsISHEntry
>
newEntry
;
nsSHistory
:
:
CloneAndReplace
(
aOSHE
aRootBC
cloneID
aEntry
true
getter_AddRefs
(
newEntry
)
)
;
NS_ASSERTION
(
aEntry
=
=
newEntry
"
The
new
session
history
should
be
in
the
new
entry
"
)
;
}
bool
addToSHistory
=
!
LOAD_TYPE_HAS_FLAGS
(
aLoadType
nsIWebNavigation
:
:
LOAD_FLAGS_REPLACE_HISTORY
)
;
if
(
!
addToSHistory
)
{
int32_t
index
=
mRequestedIndex
;
if
(
index
=
=
-
1
)
{
index
=
mIndex
;
}
if
(
index
>
=
0
)
{
rv
=
ReplaceEntry
(
index
aEntry
)
;
}
else
{
addToSHistory
=
true
;
}
}
if
(
addToSHistory
)
{
*
aPreviousEntryIndex
=
Some
(
mIndex
)
;
rv
=
AddEntry
(
aEntry
aShouldPersist
)
;
*
aLoadedEntryIndex
=
Some
(
mIndex
)
;
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Verbose
(
"
Previous
index
:
%
d
Loaded
index
:
%
d
"
aPreviousEntryIndex
-
>
value
(
)
aLoadedEntryIndex
-
>
value
(
)
)
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
aEntry
-
>
SetDocshellID
(
aRootBC
-
>
GetHistoryID
(
)
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsSHistory
:
:
AddEntry
(
nsISHEntry
*
aSHEntry
bool
aPersist
)
{
NS_ENSURE_ARG
(
aSHEntry
)
;
nsCOMPtr
<
nsISHistory
>
shistoryOfEntry
=
aSHEntry
-
>
GetShistory
(
)
;
if
(
shistoryOfEntry
&
&
shistoryOfEntry
!
=
this
)
{
NS_WARNING
(
"
The
entry
has
been
associated
to
another
nsISHistory
instance
.
"
"
Try
nsISHEntry
.
clone
(
)
and
nsISHEntry
.
abandonBFCacheEntry
(
)
"
"
first
if
you
'
re
copying
an
entry
from
another
nsISHistory
.
"
)
;
return
NS_ERROR_FAILURE
;
}
aSHEntry
-
>
SetShistory
(
this
)
;
if
(
mRootBC
)
{
aSHEntry
-
>
SetDocshellID
(
mRootDocShellID
)
;
}
if
(
mIndex
>
=
0
)
{
MOZ_ASSERT
(
mIndex
<
Length
(
)
"
Index
out
of
range
!
"
)
;
if
(
mIndex
>
=
Length
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mEntries
[
mIndex
]
&
&
!
mEntries
[
mIndex
]
-
>
GetPersist
(
)
)
{
NOTIFY_LISTENERS
(
OnHistoryReplaceEntry
(
)
)
;
aSHEntry
-
>
SetPersist
(
aPersist
)
;
mEntries
[
mIndex
]
=
aSHEntry
;
return
NS_OK
;
}
}
SHistoryChangeNotifier
change
(
this
)
;
nsCOMPtr
<
nsIURI
>
uri
=
aSHEntry
-
>
GetURI
(
)
;
NOTIFY_LISTENERS
(
OnHistoryNewEntry
(
uri
mIndex
)
)
;
MOZ_ASSERT
(
mIndex
>
=
-
1
)
;
aSHEntry
-
>
SetPersist
(
aPersist
)
;
mEntries
.
TruncateLength
(
mIndex
+
1
)
;
mEntries
.
AppendElement
(
aSHEntry
)
;
mIndex
+
+
;
if
(
gHistoryMaxSize
>
=
0
&
&
Length
(
)
>
gHistoryMaxSize
)
{
PurgeHistory
(
Length
(
)
-
gHistoryMaxSize
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetCount
(
int32_t
*
aResult
)
{
MOZ_ASSERT
(
aResult
"
null
out
param
?
"
)
;
*
aResult
=
Length
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetIndex
(
int32_t
*
aResult
)
{
MOZ_ASSERT
(
aResult
"
null
out
param
?
"
)
;
*
aResult
=
mIndex
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
SetIndex
(
int32_t
aIndex
)
{
if
(
aIndex
<
0
|
|
aIndex
>
=
Length
(
)
)
{
return
NS_ERROR_FAILURE
;
}
mIndex
=
aIndex
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetRequestedIndex
(
int32_t
*
aResult
)
{
MOZ_ASSERT
(
aResult
"
null
out
param
?
"
)
;
*
aResult
=
mRequestedIndex
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
nsSHistory
:
:
InternalSetRequestedIndex
(
int32_t
aRequestedIndex
)
{
MOZ_ASSERT
(
aRequestedIndex
>
=
-
1
&
&
aRequestedIndex
<
Length
(
)
)
;
mRequestedIndex
=
aRequestedIndex
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetEntryAtIndex
(
int32_t
aIndex
nsISHEntry
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
if
(
aIndex
<
0
|
|
aIndex
>
=
Length
(
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aResult
=
mEntries
[
aIndex
]
;
NS_ADDREF
(
*
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
int32_t
)
nsSHistory
:
:
GetIndexOfEntry
(
nsISHEntry
*
aSHEntry
)
{
for
(
int32_t
i
=
0
;
i
<
Length
(
)
;
i
+
+
)
{
if
(
aSHEntry
=
=
mEntries
[
i
]
)
{
return
i
;
}
}
return
-
1
;
}
#
ifdef
DEBUG
nsresult
nsSHistory
:
:
PrintHistory
(
)
{
for
(
int32_t
i
=
0
;
i
<
Length
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsISHEntry
>
entry
=
mEntries
[
i
]
;
nsCOMPtr
<
nsILayoutHistoryState
>
layoutHistoryState
=
entry
-
>
GetLayoutHistoryState
(
)
;
nsCOMPtr
<
nsIURI
>
uri
=
entry
-
>
GetURI
(
)
;
nsString
title
;
entry
-
>
GetTitle
(
title
)
;
#
if
0
nsAutoCString
url
;
if
(
uri
)
{
uri
-
>
GetSpec
(
url
)
;
}
printf
(
"
*
*
*
*
SH
Entry
#
%
d
:
%
x
\
n
"
i
entry
.
get
(
)
)
;
printf
(
"
\
t
\
t
URL
=
%
s
\
n
"
url
.
get
(
)
)
;
printf
(
"
\
t
\
t
Title
=
%
s
\
n
"
NS_LossyConvertUTF16toASCII
(
title
)
.
get
(
)
)
;
printf
(
"
\
t
\
t
layout
History
Data
=
%
x
\
n
"
layoutHistoryState
.
get
(
)
)
;
#
endif
}
return
NS_OK
;
}
#
endif
void
nsSHistory
:
:
WindowIndices
(
int32_t
aIndex
int32_t
*
aOutStartIndex
int32_t
*
aOutEndIndex
)
{
*
aOutStartIndex
=
std
:
:
max
(
0
aIndex
-
nsSHistory
:
:
VIEWER_WINDOW
)
;
*
aOutEndIndex
=
std
:
:
min
(
Length
(
)
-
1
aIndex
+
nsSHistory
:
:
VIEWER_WINDOW
)
;
}
NS_IMETHODIMP
nsSHistory
:
:
PurgeHistory
(
int32_t
aNumEntries
)
{
if
(
Length
(
)
<
=
0
|
|
aNumEntries
<
=
0
)
{
return
NS_ERROR_FAILURE
;
}
SHistoryChangeNotifier
change
(
this
)
;
aNumEntries
=
std
:
:
min
(
aNumEntries
Length
(
)
)
;
NOTIFY_LISTENERS
(
OnHistoryPurge
(
)
)
;
mEntries
.
RemoveElementsAt
(
0
aNumEntries
)
;
mIndex
-
=
aNumEntries
;
mIndex
=
std
:
:
max
(
mIndex
-
1
)
;
mRequestedIndex
-
=
aNumEntries
;
mRequestedIndex
=
std
:
:
max
(
mRequestedIndex
-
1
)
;
if
(
mRootBC
&
&
mRootBC
-
>
GetDocShell
(
)
)
{
mRootBC
-
>
GetDocShell
(
)
-
>
HistoryPurged
(
aNumEntries
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
AddSHistoryListener
(
nsISHistoryListener
*
aListener
)
{
NS_ENSURE_ARG_POINTER
(
aListener
)
;
nsWeakPtr
listener
=
do_GetWeakReference
(
aListener
)
;
if
(
!
listener
)
{
return
NS_ERROR_FAILURE
;
}
mListeners
.
AppendElementUnlessExists
(
listener
)
;
return
NS_OK
;
}
void
nsSHistory
:
:
NotifyListenersContentViewerEvicted
(
uint32_t
aNumEvicted
)
{
NOTIFY_LISTENERS
(
OnContentViewerEvicted
(
aNumEvicted
)
)
;
}
NS_IMETHODIMP
nsSHistory
:
:
RemoveSHistoryListener
(
nsISHistoryListener
*
aListener
)
{
nsWeakPtr
listener
=
do_GetWeakReference
(
aListener
)
;
mListeners
.
RemoveElement
(
listener
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
ReplaceEntry
(
int32_t
aIndex
nsISHEntry
*
aReplaceEntry
)
{
NS_ENSURE_ARG
(
aReplaceEntry
)
;
if
(
aIndex
<
0
|
|
aIndex
>
=
Length
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISHistory
>
shistoryOfEntry
=
aReplaceEntry
-
>
GetShistory
(
)
;
if
(
shistoryOfEntry
&
&
shistoryOfEntry
!
=
this
)
{
NS_WARNING
(
"
The
entry
has
been
associated
to
another
nsISHistory
instance
.
"
"
Try
nsISHEntry
.
clone
(
)
and
nsISHEntry
.
abandonBFCacheEntry
(
)
"
"
first
if
you
'
re
copying
an
entry
from
another
nsISHistory
.
"
)
;
return
NS_ERROR_FAILURE
;
}
aReplaceEntry
-
>
SetShistory
(
this
)
;
NOTIFY_LISTENERS
(
OnHistoryReplaceEntry
(
)
)
;
aReplaceEntry
-
>
SetPersist
(
true
)
;
mEntries
[
aIndex
]
=
aReplaceEntry
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
NotifyOnHistoryReload
(
bool
*
aCanReload
)
{
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryReload
*
aCanReload
(
aCanReload
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
EvictOutOfRangeContentViewers
(
int32_t
aIndex
)
{
EvictOutOfRangeWindowContentViewers
(
aIndex
)
;
GloballyEvictContentViewers
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
nsSHistory
:
:
EvictContentViewersOrReplaceEntry
(
nsISHEntry
*
aNewSHEntry
bool
aReplace
)
{
if
(
!
aReplace
)
{
int32_t
curIndex
;
GetIndex
(
&
curIndex
)
;
if
(
curIndex
>
-
1
)
{
EvictOutOfRangeContentViewers
(
curIndex
)
;
}
}
else
{
nsCOMPtr
<
nsISHEntry
>
rootSHEntry
=
nsSHistory
:
:
GetRootSHEntry
(
aNewSHEntry
)
;
int32_t
index
=
GetIndexOfEntry
(
rootSHEntry
)
;
if
(
index
>
-
1
)
{
ReplaceEntry
(
index
rootSHEntry
)
;
}
}
}
NS_IMETHODIMP
nsSHistory
:
:
EvictAllContentViewers
(
)
{
for
(
int32_t
i
=
0
;
i
<
Length
(
)
;
i
+
+
)
{
EvictContentViewerForEntry
(
mEntries
[
i
]
)
;
}
return
NS_OK
;
}
void
nsSHistory
:
:
LoadURIs
(
nsTArray
<
LoadEntryResult
>
&
aLoadResults
)
{
for
(
LoadEntryResult
&
loadEntry
:
aLoadResults
)
{
loadEntry
.
mBrowsingContext
-
>
LoadURI
(
loadEntry
.
mLoadState
false
)
;
}
}
NS_IMETHODIMP
nsSHistory
:
:
Reload
(
uint32_t
aReloadFlags
)
{
nsTArray
<
LoadEntryResult
>
loadResults
;
nsresult
rv
=
Reload
(
aReloadFlags
loadResults
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
loadResults
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
LoadURIs
(
loadResults
)
;
return
NS_OK
;
}
nsresult
nsSHistory
:
:
Reload
(
uint32_t
aReloadFlags
nsTArray
<
LoadEntryResult
>
&
aLoadResults
)
{
MOZ_ASSERT
(
aLoadResults
.
IsEmpty
(
)
)
;
uint32_t
loadType
;
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_BYPASS_PROXY
&
&
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_BYPASS_CACHE
)
{
loadType
=
LOAD_RELOAD_BYPASS_PROXY_AND_CACHE
;
}
else
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_BYPASS_PROXY
)
{
loadType
=
LOAD_RELOAD_BYPASS_PROXY
;
}
else
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_BYPASS_CACHE
)
{
loadType
=
LOAD_RELOAD_BYPASS_CACHE
;
}
else
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_CHARSET_CHANGE
)
{
loadType
=
LOAD_RELOAD_CHARSET_CHANGE
;
}
else
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_ALLOW_MIXED_CONTENT
)
{
loadType
=
LOAD_RELOAD_ALLOW_MIXED_CONTENT
;
}
else
{
loadType
=
LOAD_RELOAD_NORMAL
;
}
bool
canNavigate
=
true
;
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryReload
canNavigate
(
&
canNavigate
)
)
;
if
(
!
canNavigate
)
{
return
NS_OK
;
}
nsresult
rv
=
LoadEntry
(
mIndex
loadType
HIST_CMD_RELOAD
aLoadResults
)
;
if
(
NS_FAILED
(
rv
)
)
{
aLoadResults
.
Clear
(
)
;
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
ReloadCurrentEntry
(
)
{
nsTArray
<
LoadEntryResult
>
loadResults
;
nsresult
rv
=
ReloadCurrentEntry
(
loadResults
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LoadURIs
(
loadResults
)
;
return
NS_OK
;
}
nsresult
nsSHistory
:
:
ReloadCurrentEntry
(
nsTArray
<
LoadEntryResult
>
&
aLoadResults
)
{
NOTIFY_LISTENERS
(
OnHistoryGotoIndex
(
)
)
;
return
LoadEntry
(
mIndex
LOAD_HISTORY
HIST_CMD_RELOAD
aLoadResults
)
;
}
void
nsSHistory
:
:
EvictOutOfRangeWindowContentViewers
(
int32_t
aIndex
)
{
if
(
aIndex
<
0
)
{
return
;
}
NS_ENSURE_TRUE_VOID
(
aIndex
<
Length
(
)
)
;
int32_t
startSafeIndex
endSafeIndex
;
WindowIndices
(
aIndex
&
startSafeIndex
&
endSafeIndex
)
;
LOG
(
(
"
EvictOutOfRangeWindowContentViewers
(
index
=
%
d
)
"
"
Length
(
)
=
%
d
.
Safe
range
[
%
d
%
d
]
"
aIndex
Length
(
)
startSafeIndex
endSafeIndex
)
)
;
nsCOMArray
<
nsIContentViewer
>
safeViewers
;
for
(
int32_t
i
=
startSafeIndex
;
i
<
=
endSafeIndex
;
i
+
+
)
{
nsCOMPtr
<
nsIContentViewer
>
viewer
=
mEntries
[
i
]
-
>
GetContentViewer
(
)
;
safeViewers
.
AppendObject
(
viewer
)
;
}
for
(
int32_t
i
=
0
;
i
<
Length
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsISHEntry
>
entry
=
mEntries
[
i
]
;
nsCOMPtr
<
nsIContentViewer
>
viewer
=
entry
-
>
GetContentViewer
(
)
;
if
(
safeViewers
.
IndexOf
(
viewer
)
=
=
-
1
)
{
EvictContentViewerForEntry
(
entry
)
;
}
}
}
namespace
{
class
EntryAndDistance
{
public
:
EntryAndDistance
(
nsSHistory
*
aSHistory
nsISHEntry
*
aEntry
uint32_t
aDist
)
:
mSHistory
(
aSHistory
)
mEntry
(
aEntry
)
mViewer
(
aEntry
-
>
GetContentViewer
(
)
)
mLastTouched
(
mEntry
-
>
GetLastTouched
(
)
)
mDistance
(
aDist
)
{
NS_ASSERTION
(
mViewer
"
Entry
should
have
a
content
viewer
"
)
;
}
bool
operator
<
(
const
EntryAndDistance
&
aOther
)
const
{
if
(
aOther
.
mDistance
!
=
this
-
>
mDistance
)
{
return
this
-
>
mDistance
<
aOther
.
mDistance
;
}
return
this
-
>
mLastTouched
<
aOther
.
mLastTouched
;
}
bool
operator
=
=
(
const
EntryAndDistance
&
aOther
)
const
{
return
aOther
.
mDistance
=
=
this
-
>
mDistance
&
&
aOther
.
mLastTouched
=
=
this
-
>
mLastTouched
;
}
RefPtr
<
nsSHistory
>
mSHistory
;
nsCOMPtr
<
nsISHEntry
>
mEntry
;
nsCOMPtr
<
nsIContentViewer
>
mViewer
;
uint32_t
mLastTouched
;
int32_t
mDistance
;
}
;
}
void
nsSHistory
:
:
GloballyEvictContentViewers
(
)
{
nsTArray
<
EntryAndDistance
>
entries
;
for
(
auto
shist
:
gSHistoryList
)
{
if
(
shist
-
>
mIsRemote
)
{
continue
;
}
nsTArray
<
EntryAndDistance
>
shEntries
;
int32_t
startIndex
endIndex
;
shist
-
>
WindowIndices
(
shist
-
>
mIndex
&
startIndex
&
endIndex
)
;
for
(
int32_t
i
=
startIndex
;
i
<
=
endIndex
;
i
+
+
)
{
nsCOMPtr
<
nsISHEntry
>
entry
=
shist
-
>
mEntries
[
i
]
;
nsCOMPtr
<
nsIContentViewer
>
contentViewer
=
entry
-
>
GetContentViewer
(
)
;
if
(
contentViewer
)
{
bool
found
=
false
;
for
(
uint32_t
j
=
0
;
j
<
shEntries
.
Length
(
)
;
j
+
+
)
{
EntryAndDistance
&
container
=
shEntries
[
j
]
;
if
(
container
.
mViewer
=
=
contentViewer
)
{
container
.
mDistance
=
std
:
:
min
(
container
.
mDistance
DeprecatedAbs
(
i
-
shist
-
>
mIndex
)
)
;
found
=
true
;
break
;
}
}
if
(
!
found
)
{
EntryAndDistance
container
(
shist
entry
DeprecatedAbs
(
i
-
shist
-
>
mIndex
)
)
;
shEntries
.
AppendElement
(
container
)
;
}
}
}
entries
.
AppendElements
(
shEntries
)
;
}
if
(
(
int32_t
)
entries
.
Length
(
)
<
=
sHistoryMaxTotalViewers
)
{
return
;
}
entries
.
Sort
(
)
;
for
(
int32_t
i
=
entries
.
Length
(
)
-
1
;
i
>
=
sHistoryMaxTotalViewers
;
-
-
i
)
{
(
entries
[
i
]
.
mSHistory
)
-
>
EvictContentViewerForEntry
(
entries
[
i
]
.
mEntry
)
;
}
}
nsresult
nsSHistory
:
:
FindEntryForBFCache
(
nsIBFCacheEntry
*
aBFEntry
nsISHEntry
*
*
aResult
int32_t
*
aResultIndex
)
{
*
aResult
=
nullptr
;
*
aResultIndex
=
-
1
;
int32_t
startIndex
endIndex
;
WindowIndices
(
mIndex
&
startIndex
&
endIndex
)
;
for
(
int32_t
i
=
startIndex
;
i
<
=
endIndex
;
+
+
i
)
{
nsCOMPtr
<
nsISHEntry
>
shEntry
=
mEntries
[
i
]
;
if
(
shEntry
-
>
HasBFCacheEntry
(
aBFEntry
)
)
{
shEntry
.
forget
(
aResult
)
;
*
aResultIndex
=
i
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
nsresult
nsSHistory
:
:
EvictExpiredContentViewerForEntry
(
nsIBFCacheEntry
*
aBFEntry
)
{
int32_t
index
;
nsCOMPtr
<
nsISHEntry
>
shEntry
;
FindEntryForBFCache
(
aBFEntry
getter_AddRefs
(
shEntry
)
&
index
)
;
if
(
index
=
=
mIndex
)
{
NS_WARNING
(
"
How
did
the
current
SHEntry
expire
?
"
)
;
return
NS_OK
;
}
if
(
shEntry
)
{
EvictContentViewerForEntry
(
shEntry
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
nsSHistory
:
:
AddToExpirationTracker
(
nsIBFCacheEntry
*
aBFEntry
)
{
RefPtr
<
nsSHEntryShared
>
entry
=
static_cast
<
nsSHEntryShared
*
>
(
aBFEntry
)
;
if
(
!
mHistoryTracker
|
|
!
entry
)
{
return
;
}
mHistoryTracker
-
>
AddObject
(
entry
)
;
return
;
}
NS_IMETHODIMP_
(
void
)
nsSHistory
:
:
RemoveFromExpirationTracker
(
nsIBFCacheEntry
*
aBFEntry
)
{
RefPtr
<
nsSHEntryShared
>
entry
=
static_cast
<
nsSHEntryShared
*
>
(
aBFEntry
)
;
MOZ_ASSERT
(
mHistoryTracker
&
&
!
mHistoryTracker
-
>
IsEmpty
(
)
)
;
if
(
!
mHistoryTracker
|
|
!
entry
)
{
return
;
}
mHistoryTracker
-
>
RemoveObject
(
entry
)
;
}
void
nsSHistory
:
:
GloballyEvictAllContentViewers
(
)
{
int32_t
maxViewers
=
sHistoryMaxTotalViewers
;
sHistoryMaxTotalViewers
=
0
;
GloballyEvictContentViewers
(
)
;
sHistoryMaxTotalViewers
=
maxViewers
;
}
void
GetDynamicChildren
(
nsISHEntry
*
aEntry
nsTArray
<
nsID
>
&
aDocshellIDs
)
{
int32_t
count
=
aEntry
-
>
GetChildCount
(
)
;
for
(
int32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
nsCOMPtr
<
nsISHEntry
>
child
;
aEntry
-
>
GetChildAt
(
i
getter_AddRefs
(
child
)
)
;
if
(
child
)
{
if
(
child
-
>
IsDynamicallyAdded
(
)
)
{
child
-
>
GetDocshellID
(
*
aDocshellIDs
.
AppendElement
(
)
)
;
}
else
{
GetDynamicChildren
(
child
aDocshellIDs
)
;
}
}
}
}
bool
RemoveFromSessionHistoryEntry
(
nsISHEntry
*
aRoot
nsTArray
<
nsID
>
&
aDocshellIDs
)
{
bool
didRemove
=
false
;
int32_t
childCount
=
aRoot
-
>
GetChildCount
(
)
;
for
(
int32_t
i
=
childCount
-
1
;
i
>
=
0
;
-
-
i
)
{
nsCOMPtr
<
nsISHEntry
>
child
;
aRoot
-
>
GetChildAt
(
i
getter_AddRefs
(
child
)
)
;
if
(
child
)
{
nsID
docshelldID
;
child
-
>
GetDocshellID
(
docshelldID
)
;
if
(
aDocshellIDs
.
Contains
(
docshelldID
)
)
{
didRemove
=
true
;
aRoot
-
>
RemoveChild
(
child
)
;
}
else
if
(
RemoveFromSessionHistoryEntry
(
child
aDocshellIDs
)
)
{
didRemove
=
true
;
}
}
}
return
didRemove
;
}
bool
RemoveChildEntries
(
nsISHistory
*
aHistory
int32_t
aIndex
nsTArray
<
nsID
>
&
aEntryIDs
)
{
nsCOMPtr
<
nsISHEntry
>
root
;
aHistory
-
>
GetEntryAtIndex
(
aIndex
getter_AddRefs
(
root
)
)
;
return
root
?
RemoveFromSessionHistoryEntry
(
root
aEntryIDs
)
:
false
;
}
bool
IsSameTree
(
nsISHEntry
*
aEntry1
nsISHEntry
*
aEntry2
)
{
if
(
!
aEntry1
&
&
!
aEntry2
)
{
return
true
;
}
if
(
(
!
aEntry1
&
&
aEntry2
)
|
|
(
aEntry1
&
&
!
aEntry2
)
)
{
return
false
;
}
uint32_t
id1
=
aEntry1
-
>
GetID
(
)
;
uint32_t
id2
=
aEntry2
-
>
GetID
(
)
;
if
(
id1
!
=
id2
)
{
return
false
;
}
int32_t
count1
=
aEntry1
-
>
GetChildCount
(
)
;
int32_t
count2
=
aEntry2
-
>
GetChildCount
(
)
;
int32_t
count
=
std
:
:
max
(
count1
count2
)
;
for
(
int32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
nsCOMPtr
<
nsISHEntry
>
child1
child2
;
aEntry1
-
>
GetChildAt
(
i
getter_AddRefs
(
child1
)
)
;
aEntry2
-
>
GetChildAt
(
i
getter_AddRefs
(
child2
)
)
;
if
(
!
IsSameTree
(
child1
child2
)
)
{
return
false
;
}
}
return
true
;
}
bool
nsSHistory
:
:
RemoveDuplicate
(
int32_t
aIndex
bool
aKeepNext
)
{
NS_ASSERTION
(
aIndex
>
=
0
"
aIndex
must
be
>
=
0
!
"
)
;
NS_ASSERTION
(
aIndex
!
=
0
|
|
aKeepNext
"
If
we
'
re
removing
index
0
we
must
be
keeping
the
next
"
)
;
NS_ASSERTION
(
aIndex
!
=
mIndex
"
Shouldn
'
t
remove
mIndex
!
"
)
;
int32_t
compareIndex
=
aKeepNext
?
aIndex
+
1
:
aIndex
-
1
;
nsresult
rv
;
nsCOMPtr
<
nsISHEntry
>
root1
root2
;
rv
=
GetEntryAtIndex
(
aIndex
getter_AddRefs
(
root1
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
rv
=
GetEntryAtIndex
(
compareIndex
getter_AddRefs
(
root2
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
SHistoryChangeNotifier
change
(
this
)
;
if
(
IsSameTree
(
root1
root2
)
)
{
mEntries
.
RemoveElementAt
(
aIndex
)
;
if
(
mIndex
>
aIndex
)
{
mIndex
=
mIndex
-
1
;
}
if
(
mRequestedIndex
>
aIndex
|
|
(
mRequestedIndex
=
=
aIndex
&
&
!
aKeepNext
)
)
{
mRequestedIndex
=
mRequestedIndex
-
1
;
}
return
true
;
}
return
false
;
}
NS_IMETHODIMP_
(
void
)
nsSHistory
:
:
RemoveEntries
(
nsTArray
<
nsID
>
&
aIDs
int32_t
aStartIndex
)
{
bool
didRemove
;
RemoveEntries
(
aIDs
aStartIndex
&
didRemove
)
;
if
(
didRemove
&
&
mRootBC
&
&
mRootBC
-
>
GetDocShell
(
)
)
{
mRootBC
-
>
GetDocShell
(
)
-
>
DispatchLocationChangeEvent
(
)
;
}
}
void
nsSHistory
:
:
RemoveEntries
(
nsTArray
<
nsID
>
&
aIDs
int32_t
aStartIndex
bool
*
aDidRemove
)
{
SHistoryChangeNotifier
change
(
this
)
;
int32_t
index
=
aStartIndex
;
while
(
index
>
=
0
&
&
RemoveChildEntries
(
this
-
-
index
aIDs
)
)
{
}
int32_t
minIndex
=
index
;
index
=
aStartIndex
;
while
(
index
>
=
0
&
&
RemoveChildEntries
(
this
index
+
+
aIDs
)
)
{
}
*
aDidRemove
=
false
;
while
(
index
>
minIndex
)
{
if
(
index
!
=
mIndex
&
&
RemoveDuplicate
(
index
index
<
mIndex
)
)
{
*
aDidRemove
=
true
;
}
-
-
index
;
}
}
void
nsSHistory
:
:
RemoveFrameEntries
(
nsISHEntry
*
aEntry
)
{
int32_t
count
=
aEntry
-
>
GetChildCount
(
)
;
AutoTArray
<
nsID
16
>
ids
;
for
(
int32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
nsCOMPtr
<
nsISHEntry
>
child
;
aEntry
-
>
GetChildAt
(
i
getter_AddRefs
(
child
)
)
;
if
(
child
)
{
child
-
>
GetDocshellID
(
*
ids
.
AppendElement
(
)
)
;
}
}
RemoveEntries
(
ids
mIndex
)
;
}
void
nsSHistory
:
:
RemoveDynEntries
(
int32_t
aIndex
nsISHEntry
*
aEntry
)
{
nsCOMPtr
<
nsISHEntry
>
entry
(
aEntry
)
;
if
(
!
entry
)
{
GetEntryAtIndex
(
aIndex
getter_AddRefs
(
entry
)
)
;
}
if
(
entry
)
{
AutoTArray
<
nsID
16
>
toBeRemovedEntries
;
GetDynamicChildren
(
entry
toBeRemovedEntries
)
;
if
(
toBeRemovedEntries
.
Length
(
)
)
{
RemoveEntries
(
toBeRemovedEntries
aIndex
)
;
}
}
}
void
nsSHistory
:
:
RemoveDynEntriesForBFCacheEntry
(
nsIBFCacheEntry
*
aBFEntry
)
{
int32_t
index
;
nsCOMPtr
<
nsISHEntry
>
shEntry
;
FindEntryForBFCache
(
aBFEntry
getter_AddRefs
(
shEntry
)
&
index
)
;
if
(
shEntry
)
{
RemoveDynEntries
(
index
shEntry
)
;
}
}
NS_IMETHODIMP
nsSHistory
:
:
UpdateIndex
(
)
{
SHistoryChangeNotifier
change
(
this
)
;
if
(
mIndex
!
=
mRequestedIndex
&
&
mRequestedIndex
!
=
-
1
)
{
mIndex
=
mRequestedIndex
;
}
mRequestedIndex
=
-
1
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GotoIndex
(
int32_t
aIndex
)
{
nsTArray
<
LoadEntryResult
>
loadResults
;
nsresult
rv
=
GotoIndex
(
aIndex
loadResults
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LoadURIs
(
loadResults
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
nsSHistory
:
:
EnsureCorrectEntryAtCurrIndex
(
nsISHEntry
*
aEntry
)
{
int
index
=
mRequestedIndex
=
=
-
1
?
mIndex
:
mRequestedIndex
;
if
(
index
>
-
1
&
&
(
mEntries
[
index
]
!
=
aEntry
)
)
{
ReplaceEntry
(
index
aEntry
)
;
}
}
nsresult
nsSHistory
:
:
GotoIndex
(
int32_t
aIndex
nsTArray
<
LoadEntryResult
>
&
aLoadResults
)
{
return
LoadEntry
(
aIndex
LOAD_HISTORY
HIST_CMD_GOTOINDEX
aLoadResults
)
;
}
NS_IMETHODIMP_
(
bool
)
nsSHistory
:
:
HasUserInteractionAtIndex
(
int32_t
aIndex
)
{
nsCOMPtr
<
nsISHEntry
>
entry
;
GetEntryAtIndex
(
aIndex
getter_AddRefs
(
entry
)
)
;
if
(
!
entry
)
{
return
false
;
}
return
entry
-
>
GetHasUserInteraction
(
)
;
}
nsresult
nsSHistory
:
:
LoadNextPossibleEntry
(
int32_t
aNewIndex
long
aLoadType
uint32_t
aHistCmd
nsTArray
<
LoadEntryResult
>
&
aLoadResults
)
{
mRequestedIndex
=
-
1
;
if
(
aNewIndex
<
mIndex
)
{
return
LoadEntry
(
aNewIndex
-
1
aLoadType
aHistCmd
aLoadResults
)
;
}
if
(
aNewIndex
>
mIndex
)
{
return
LoadEntry
(
aNewIndex
+
1
aLoadType
aHistCmd
aLoadResults
)
;
}
return
NS_ERROR_FAILURE
;
}
nsresult
nsSHistory
:
:
LoadEntry
(
int32_t
aIndex
long
aLoadType
uint32_t
aHistCmd
nsTArray
<
LoadEntryResult
>
&
aLoadResults
)
{
if
(
!
mRootBC
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aIndex
<
0
|
|
aIndex
>
=
Length
(
)
)
{
return
NS_ERROR_FAILURE
;
}
mRequestedIndex
=
aIndex
;
nsCOMPtr
<
nsISHEntry
>
prevEntry
;
nsCOMPtr
<
nsISHEntry
>
nextEntry
;
GetEntryAtIndex
(
mIndex
getter_AddRefs
(
prevEntry
)
)
;
GetEntryAtIndex
(
mRequestedIndex
getter_AddRefs
(
nextEntry
)
)
;
if
(
!
nextEntry
|
|
!
prevEntry
)
{
mRequestedIndex
=
-
1
;
return
NS_ERROR_FAILURE
;
}
nextEntry
-
>
SetLastTouched
(
+
+
gTouchCounter
)
;
nsCOMPtr
<
nsIURI
>
nextURI
=
nextEntry
-
>
GetURI
(
)
;
MOZ_ASSERT
(
nextURI
"
nextURI
can
'
t
be
null
"
)
;
if
(
aHistCmd
=
=
HIST_CMD_GOTOINDEX
)
{
NOTIFY_LISTENERS
(
OnHistoryGotoIndex
(
)
)
;
}
if
(
mRequestedIndex
=
=
mIndex
)
{
InitiateLoad
(
nextEntry
mRootBC
aLoadType
aLoadResults
)
;
return
NS_OK
;
}
bool
differenceFound
=
LoadDifferingEntries
(
prevEntry
nextEntry
mRootBC
aLoadType
aLoadResults
)
;
if
(
!
differenceFound
)
{
return
LoadNextPossibleEntry
(
aIndex
aLoadType
aHistCmd
aLoadResults
)
;
}
return
NS_OK
;
}
bool
nsSHistory
:
:
LoadDifferingEntries
(
nsISHEntry
*
aPrevEntry
nsISHEntry
*
aNextEntry
BrowsingContext
*
aParent
long
aLoadType
nsTArray
<
LoadEntryResult
>
&
aLoadResults
)
{
MOZ_ASSERT
(
aPrevEntry
&
&
aNextEntry
&
&
aParent
)
;
uint32_t
prevID
=
aPrevEntry
-
>
GetID
(
)
;
uint32_t
nextID
=
aNextEntry
-
>
GetID
(
)
;
if
(
prevID
!
=
nextID
)
{
aNextEntry
-
>
SetIsSubFrame
(
aParent
!
=
mRootBC
)
;
InitiateLoad
(
aNextEntry
aParent
aLoadType
aLoadResults
)
;
return
true
;
}
int32_t
pcnt
=
aPrevEntry
-
>
GetChildCount
(
)
;
int32_t
ncnt
=
aNextEntry
-
>
GetChildCount
(
)
;
nsTArray
<
RefPtr
<
BrowsingContext
>
>
browsingContexts
;
aParent
-
>
GetChildren
(
browsingContexts
)
;
bool
differenceFound
=
false
;
for
(
int32_t
i
=
0
;
i
<
ncnt
;
+
+
i
)
{
nsCOMPtr
<
nsISHEntry
>
nChild
;
aNextEntry
-
>
GetChildAt
(
i
getter_AddRefs
(
nChild
)
)
;
if
(
!
nChild
)
{
continue
;
}
nsID
docshellID
;
nChild
-
>
GetDocshellID
(
docshellID
)
;
RefPtr
<
BrowsingContext
>
bcChild
;
for
(
const
RefPtr
<
BrowsingContext
>
&
bc
:
browsingContexts
)
{
if
(
bc
-
>
GetHistoryID
(
)
=
=
docshellID
)
{
bcChild
=
bc
;
break
;
}
}
if
(
!
bcChild
)
{
continue
;
}
nsCOMPtr
<
nsISHEntry
>
pChild
;
for
(
int32_t
k
=
0
;
k
<
pcnt
;
+
+
k
)
{
nsCOMPtr
<
nsISHEntry
>
child
;
aPrevEntry
-
>
GetChildAt
(
k
getter_AddRefs
(
child
)
)
;
if
(
child
)
{
nsID
dID
;
child
-
>
GetDocshellID
(
dID
)
;
if
(
dID
=
=
docshellID
)
{
pChild
=
child
;
break
;
}
}
}
if
(
!
pChild
)
{
continue
;
}
if
(
LoadDifferingEntries
(
pChild
nChild
bcChild
aLoadType
aLoadResults
)
)
{
differenceFound
=
true
;
}
}
return
differenceFound
;
}
void
nsSHistory
:
:
InitiateLoad
(
nsISHEntry
*
aFrameEntry
BrowsingContext
*
aFrameBC
long
aLoadType
nsTArray
<
LoadEntryResult
>
&
aLoadResults
)
{
MOZ_ASSERT
(
aFrameBC
&
&
aFrameEntry
)
;
LoadEntryResult
*
loadResult
=
aLoadResults
.
AppendElement
(
)
;
loadResult
-
>
mBrowsingContext
=
aFrameBC
;
nsCOMPtr
<
nsIURI
>
newURI
=
aFrameEntry
-
>
GetURI
(
)
;
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
newURI
)
;
aFrameEntry
-
>
SetLoadType
(
aLoadType
)
;
loadState
-
>
SetLoadType
(
aLoadType
)
;
loadState
-
>
SetSHEntry
(
aFrameEntry
)
;
bool
loadingFromActiveEntry
;
if
(
StaticPrefs
:
:
fission_sessionHistoryInParent
(
)
)
{
loadingFromActiveEntry
=
aFrameBC
-
>
Canonical
(
)
-
>
GetActiveSessionHistoryEntry
(
)
=
=
aFrameEntry
;
}
else
{
loadingFromActiveEntry
=
aFrameBC
-
>
GetDocShell
(
)
&
&
nsDocShell
:
:
Cast
(
aFrameBC
-
>
GetDocShell
(
)
)
-
>
IsOSHE
(
aFrameEntry
)
;
}
loadState
-
>
SetLoadIsFromSessionHistory
(
mRequestedIndex
Length
(
)
loadingFromActiveEntry
)
;
nsCOMPtr
<
nsIURI
>
originalURI
=
aFrameEntry
-
>
GetOriginalURI
(
)
;
loadState
-
>
SetOriginalURI
(
originalURI
)
;
loadState
-
>
SetLoadReplace
(
aFrameEntry
-
>
GetLoadReplace
(
)
)
;
loadState
-
>
SetLoadFlags
(
nsIWebNavigation
:
:
LOAD_FLAGS_NONE
)
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
aFrameEntry
-
>
GetTriggeringPrincipal
(
)
;
loadState
-
>
SetTriggeringPrincipal
(
triggeringPrincipal
)
;
loadState
-
>
SetFirstParty
(
false
)
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aFrameEntry
-
>
GetCsp
(
)
;
loadState
-
>
SetCsp
(
csp
)
;
loadResult
-
>
mLoadState
=
std
:
:
move
(
loadState
)
;
}
NS_IMETHODIMP
nsSHistory
:
:
CreateEntry
(
nsISHEntry
*
*
aEntry
)
{
nsCOMPtr
<
nsISHEntry
>
entry
;
if
(
XRE_IsParentProcess
(
)
&
&
StaticPrefs
:
:
fission_sessionHistoryInParent
(
)
)
{
entry
=
new
SessionHistoryEntry
(
)
;
}
else
{
entry
=
new
nsSHEntry
(
)
;
}
entry
.
forget
(
aEntry
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
bool
)
nsSHistory
:
:
IsEmptyOrHasEntriesForSingleTopLevelPage
(
)
{
if
(
mEntries
.
IsEmpty
(
)
)
{
return
true
;
}
nsISHEntry
*
entry
=
mEntries
[
0
]
;
size_t
length
=
mEntries
.
Length
(
)
;
for
(
size_t
i
=
1
;
i
<
length
;
+
+
i
)
{
bool
sharesDocument
=
false
;
mEntries
[
i
]
-
>
SharesDocumentWith
(
entry
&
sharesDocument
)
;
if
(
!
sharesDocument
)
{
return
false
;
}
}
return
true
;
}
