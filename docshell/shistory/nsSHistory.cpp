#
include
"
nsSHistory
.
h
"
#
include
<
algorithm
>
#
include
"
nsCOMArray
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsDocShellLoadInfo
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsISHEntry
.
h
"
#
include
"
nsISHistoryListener
.
h
"
#
include
"
nsSHTransaction
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
using
namespace
mozilla
;
#
define
PREF_SHISTORY_SIZE
"
browser
.
sessionhistory
.
max_entries
"
#
define
PREF_SHISTORY_MAX_TOTAL_VIEWERS
"
browser
.
sessionhistory
.
max_total_viewers
"
#
define
CONTENT_VIEWER_TIMEOUT_SECONDS
"
browser
.
sessionhistory
.
contentViewerTimeout
"
#
define
CONTENT_VIEWER_TIMEOUT_SECONDS_DEFAULT
(
30
*
60
)
static
const
char
*
kObservedPrefs
[
]
=
{
PREF_SHISTORY_SIZE
PREF_SHISTORY_MAX_TOTAL_VIEWERS
nullptr
}
;
static
int32_t
gHistoryMaxSize
=
50
;
static
LinkedList
<
nsSHistory
>
gSHistoryList
;
int32_t
nsSHistory
:
:
sHistoryMaxTotalViewers
=
-
1
;
static
uint32_t
gTouchCounter
=
0
;
static
LazyLogModule
gSHistoryLog
(
"
nsSHistory
"
)
;
#
define
LOG
(
format
)
MOZ_LOG
(
gSHistoryLog
mozilla
:
:
LogLevel
:
:
Debug
format
)
#
define
LOG_SPEC
(
format
uri
)
\
PR_BEGIN_MACRO
\
if
(
MOZ_LOG_TEST
(
gSHistoryLog
LogLevel
:
:
Debug
)
)
{
\
nsAutoCString
_specStr
(
NS_LITERAL_CSTRING
(
"
(
null
)
"
)
)
;
\
if
(
uri
)
{
\
_specStr
=
uri
-
>
GetSpecOrDefault
(
)
;
\
}
\
const
char
*
_spec
=
_specStr
.
get
(
)
;
\
LOG
(
format
)
;
\
}
\
PR_END_MACRO
#
define
LOG_SHENTRY_SPEC
(
format
shentry
)
\
PR_BEGIN_MACRO
\
if
(
MOZ_LOG_TEST
(
gSHistoryLog
LogLevel
:
:
Debug
)
)
{
\
nsCOMPtr
<
nsIURI
>
uri
;
\
shentry
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
\
LOG_SPEC
(
format
uri
)
;
\
}
\
PR_END_MACRO
#
define
ITERATE_LISTENERS
(
body
)
\
PR_BEGIN_MACRO
\
{
\
nsAutoTObserverArray
<
nsWeakPtr
2
>
:
:
EndLimitedIterator
\
iter
(
mListeners
)
;
\
while
(
iter
.
HasMore
(
)
)
{
\
nsCOMPtr
<
nsISHistoryListener
>
listener
=
\
do_QueryReferent
(
iter
.
GetNext
(
)
)
;
\
if
(
listener
)
{
\
body
\
}
\
}
\
}
\
PR_END_MACRO
#
define
NOTIFY_LISTENERS
(
method
args
)
\
ITERATE_LISTENERS
(
\
listener
-
>
method
args
;
\
)
;
#
define
NOTIFY_LISTENERS_CANCELABLE
(
method
retval
args
)
\
PR_BEGIN_MACRO
\
{
\
bool
canceled
=
false
;
\
retval
=
true
;
\
ITERATE_LISTENERS
(
\
listener
-
>
method
args
;
\
if
(
!
retval
)
{
\
canceled
=
true
;
\
}
\
)
;
\
if
(
canceled
)
{
\
retval
=
false
;
\
}
\
}
\
PR_END_MACRO
enum
HistCmd
{
HIST_CMD_BACK
HIST_CMD_FORWARD
HIST_CMD_GOTOINDEX
HIST_CMD_RELOAD
}
;
class
nsSHistoryObserver
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
nsSHistoryObserver
(
)
{
}
void
PrefChanged
(
const
char
*
aPref
)
;
protected
:
~
nsSHistoryObserver
(
)
{
}
}
;
StaticRefPtr
<
nsSHistoryObserver
>
gObserver
;
NS_IMPL_ISUPPORTS
(
nsSHistoryObserver
nsIObserver
)
void
nsSHistoryObserver
:
:
PrefChanged
(
const
char
*
aPref
)
{
nsSHistory
:
:
UpdatePrefs
(
)
;
nsSHistory
:
:
GloballyEvictContentViewers
(
)
;
}
NS_IMETHODIMP
nsSHistoryObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
"
cacheservice
:
empty
-
cache
"
)
|
|
!
strcmp
(
aTopic
"
memory
-
pressure
"
)
)
{
nsSHistory
:
:
GloballyEvictAllContentViewers
(
)
;
}
return
NS_OK
;
}
namespace
{
already_AddRefed
<
nsIContentViewer
>
GetContentViewerForTransaction
(
nsISHTransaction
*
aTrans
)
{
nsCOMPtr
<
nsISHEntry
>
entry
;
aTrans
-
>
GetSHEntry
(
getter_AddRefs
(
entry
)
)
;
if
(
!
entry
)
{
return
nullptr
;
}
nsCOMPtr
<
nsISHEntry
>
ownerEntry
;
nsCOMPtr
<
nsIContentViewer
>
viewer
;
entry
-
>
GetAnyContentViewer
(
getter_AddRefs
(
ownerEntry
)
getter_AddRefs
(
viewer
)
)
;
return
viewer
.
forget
(
)
;
}
}
void
nsSHistory
:
:
EvictContentViewerForTransaction
(
nsISHTransaction
*
aTrans
)
{
nsCOMPtr
<
nsISHEntry
>
entry
;
aTrans
-
>
GetSHEntry
(
getter_AddRefs
(
entry
)
)
;
nsCOMPtr
<
nsIContentViewer
>
viewer
;
nsCOMPtr
<
nsISHEntry
>
ownerEntry
;
entry
-
>
GetAnyContentViewer
(
getter_AddRefs
(
ownerEntry
)
getter_AddRefs
(
viewer
)
)
;
if
(
viewer
)
{
NS_ASSERTION
(
ownerEntry
"
Content
viewer
exists
but
its
SHEntry
is
null
"
)
;
LOG_SHENTRY_SPEC
(
(
"
Evicting
content
viewer
0x
%
p
for
"
"
owning
SHEntry
0x
%
p
at
%
s
.
"
viewer
.
get
(
)
ownerEntry
.
get
(
)
_spec
)
ownerEntry
)
;
ownerEntry
-
>
SetContentViewer
(
nullptr
)
;
ownerEntry
-
>
SyncPresentationState
(
)
;
viewer
-
>
Destroy
(
)
;
}
int32_t
index
=
-
1
;
GetIndexOfEntry
(
entry
&
index
)
;
if
(
index
!
=
-
1
)
{
RemoveDynEntries
(
index
entry
)
;
}
}
nsSHistory
:
:
nsSHistory
(
)
:
mIndex
(
-
1
)
mRequestedIndex
(
-
1
)
mRootDocShell
(
nullptr
)
{
gSHistoryList
.
insertBack
(
this
)
;
}
nsSHistory
:
:
~
nsSHistory
(
)
{
}
NS_IMPL_ADDREF
(
nsSHistory
)
NS_IMPL_RELEASE
(
nsSHistory
)
NS_INTERFACE_MAP_BEGIN
(
nsSHistory
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsISHistory
)
NS_INTERFACE_MAP_ENTRY
(
nsISHistory
)
NS_INTERFACE_MAP_ENTRY
(
nsIWebNavigation
)
NS_INTERFACE_MAP_ENTRY
(
nsISHistoryInternal
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END
uint32_t
nsSHistory
:
:
CalcMaxTotalViewers
(
)
{
#
ifdef
ANDROID
#
define
MAX_TOTAL_VIEWERS_BIAS
15
.
9
#
else
#
define
MAX_TOTAL_VIEWERS_BIAS
14
#
endif
uint64_t
bytes
=
PR_GetPhysicalMemorySize
(
)
;
if
(
bytes
=
=
0
)
{
return
0
;
}
if
(
bytes
>
INT64_MAX
)
{
bytes
=
INT64_MAX
;
}
double
kBytesD
=
(
double
)
(
bytes
>
>
10
)
;
uint32_t
viewers
=
0
;
double
x
=
std
:
:
log
(
kBytesD
)
/
std
:
:
log
(
2
.
0
)
-
MAX_TOTAL_VIEWERS_BIAS
;
if
(
x
>
0
)
{
viewers
=
(
uint32_t
)
(
x
*
x
-
x
+
2
.
001
)
;
viewers
/
=
4
;
}
if
(
viewers
>
8
)
{
viewers
=
8
;
}
return
viewers
;
}
void
nsSHistory
:
:
UpdatePrefs
(
)
{
Preferences
:
:
GetInt
(
PREF_SHISTORY_SIZE
&
gHistoryMaxSize
)
;
Preferences
:
:
GetInt
(
PREF_SHISTORY_MAX_TOTAL_VIEWERS
&
sHistoryMaxTotalViewers
)
;
if
(
sHistoryMaxTotalViewers
<
0
)
{
sHistoryMaxTotalViewers
=
CalcMaxTotalViewers
(
)
;
}
}
nsresult
nsSHistory
:
:
Startup
(
)
{
UpdatePrefs
(
)
;
int32_t
defaultHistoryMaxSize
=
Preferences
:
:
GetInt
(
PREF_SHISTORY_SIZE
50
PrefValueKind
:
:
Default
)
;
if
(
gHistoryMaxSize
<
defaultHistoryMaxSize
)
{
gHistoryMaxSize
=
defaultHistoryMaxSize
;
}
if
(
!
gObserver
)
{
gObserver
=
new
nsSHistoryObserver
(
)
;
Preferences
:
:
RegisterCallbacks
(
PREF_CHANGE_METHOD
(
nsSHistoryObserver
:
:
PrefChanged
)
kObservedPrefs
gObserver
.
get
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
AddObserver
(
gObserver
"
cacheservice
:
empty
-
cache
"
false
)
;
obsSvc
-
>
AddObserver
(
gObserver
"
memory
-
pressure
"
false
)
;
}
}
return
NS_OK
;
}
void
nsSHistory
:
:
Shutdown
(
)
{
if
(
gObserver
)
{
Preferences
:
:
UnregisterCallbacks
(
PREF_CHANGE_METHOD
(
nsSHistoryObserver
:
:
PrefChanged
)
kObservedPrefs
gObserver
.
get
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
RemoveObserver
(
gObserver
"
cacheservice
:
empty
-
cache
"
)
;
obsSvc
-
>
RemoveObserver
(
gObserver
"
memory
-
pressure
"
)
;
}
gObserver
=
nullptr
;
}
}
nsISHEntry
*
nsSHistory
:
:
GetRootSHEntry
(
nsISHEntry
*
aEntry
)
{
nsCOMPtr
<
nsISHEntry
>
rootEntry
=
aEntry
;
nsISHEntry
*
result
=
nullptr
;
while
(
rootEntry
)
{
result
=
rootEntry
;
result
-
>
GetParent
(
getter_AddRefs
(
rootEntry
)
)
;
}
return
result
;
}
nsresult
nsSHistory
:
:
WalkHistoryEntries
(
nsISHEntry
*
aRootEntry
nsDocShell
*
aRootShell
WalkHistoryEntriesFunc
aCallback
void
*
aData
)
{
NS_ENSURE_TRUE
(
aRootEntry
NS_ERROR_FAILURE
)
;
int32_t
childCount
;
aRootEntry
-
>
GetChildCount
(
&
childCount
)
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
i
+
+
)
{
nsCOMPtr
<
nsISHEntry
>
childEntry
;
aRootEntry
-
>
GetChildAt
(
i
getter_AddRefs
(
childEntry
)
)
;
if
(
!
childEntry
)
{
aCallback
(
nullptr
nullptr
i
aData
)
;
continue
;
}
nsDocShell
*
childShell
=
nullptr
;
if
(
aRootShell
)
{
int32_t
length
;
aRootShell
-
>
GetChildCount
(
&
length
)
;
for
(
int32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
item
;
nsresult
rv
=
aRootShell
-
>
GetChildAt
(
i
getter_AddRefs
(
item
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsDocShell
*
child
=
static_cast
<
nsDocShell
*
>
(
item
.
get
(
)
)
;
if
(
child
-
>
HasHistoryEntry
(
childEntry
)
)
{
childShell
=
child
;
break
;
}
}
}
nsresult
rv
=
aCallback
(
childEntry
childShell
i
aData
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
struct
MOZ_STACK_CLASS
CloneAndReplaceData
{
CloneAndReplaceData
(
uint32_t
aCloneID
nsISHEntry
*
aReplaceEntry
bool
aCloneChildren
nsISHEntry
*
aDestTreeParent
)
:
cloneID
(
aCloneID
)
cloneChildren
(
aCloneChildren
)
replaceEntry
(
aReplaceEntry
)
destTreeParent
(
aDestTreeParent
)
{
}
uint32_t
cloneID
;
bool
cloneChildren
;
nsISHEntry
*
replaceEntry
;
nsISHEntry
*
destTreeParent
;
nsCOMPtr
<
nsISHEntry
>
resultEntry
;
}
;
nsresult
nsSHistory
:
:
CloneAndReplaceChild
(
nsISHEntry
*
aEntry
nsDocShell
*
aShell
int32_t
aEntryIndex
void
*
aData
)
{
nsCOMPtr
<
nsISHEntry
>
dest
;
CloneAndReplaceData
*
data
=
static_cast
<
CloneAndReplaceData
*
>
(
aData
)
;
uint32_t
cloneID
=
data
-
>
cloneID
;
nsISHEntry
*
replaceEntry
=
data
-
>
replaceEntry
;
if
(
!
aEntry
)
{
if
(
data
-
>
destTreeParent
)
{
data
-
>
destTreeParent
-
>
AddChild
(
nullptr
aEntryIndex
)
;
}
return
NS_OK
;
}
uint32_t
srcID
;
aEntry
-
>
GetID
(
&
srcID
)
;
nsresult
rv
=
NS_OK
;
if
(
srcID
=
=
cloneID
)
{
dest
=
replaceEntry
;
}
else
{
rv
=
aEntry
-
>
Clone
(
getter_AddRefs
(
dest
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
dest
-
>
SetIsSubFrame
(
true
)
;
if
(
srcID
!
=
cloneID
|
|
data
-
>
cloneChildren
)
{
CloneAndReplaceData
childData
(
cloneID
replaceEntry
data
-
>
cloneChildren
dest
)
;
rv
=
WalkHistoryEntries
(
aEntry
aShell
CloneAndReplaceChild
&
childData
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
srcID
!
=
cloneID
&
&
aShell
)
{
aShell
-
>
SwapHistoryEntries
(
aEntry
dest
)
;
}
if
(
data
-
>
destTreeParent
)
{
data
-
>
destTreeParent
-
>
AddChild
(
dest
aEntryIndex
)
;
}
data
-
>
resultEntry
=
dest
;
return
rv
;
}
nsresult
nsSHistory
:
:
CloneAndReplace
(
nsISHEntry
*
aSrcEntry
nsDocShell
*
aSrcShell
uint32_t
aCloneID
nsISHEntry
*
aReplaceEntry
bool
aCloneChildren
nsISHEntry
*
*
aResultEntry
)
{
NS_ENSURE_ARG_POINTER
(
aResultEntry
)
;
NS_ENSURE_TRUE
(
aReplaceEntry
NS_ERROR_FAILURE
)
;
CloneAndReplaceData
data
(
aCloneID
aReplaceEntry
aCloneChildren
nullptr
)
;
nsresult
rv
=
CloneAndReplaceChild
(
aSrcEntry
aSrcShell
0
&
data
)
;
data
.
resultEntry
.
swap
(
*
aResultEntry
)
;
return
rv
;
}
nsresult
nsSHistory
:
:
SetChildHistoryEntry
(
nsISHEntry
*
aEntry
nsDocShell
*
aShell
int32_t
aEntryIndex
void
*
aData
)
{
SwapEntriesData
*
data
=
static_cast
<
SwapEntriesData
*
>
(
aData
)
;
nsDocShell
*
ignoreShell
=
data
-
>
ignoreShell
;
if
(
!
aShell
|
|
aShell
=
=
ignoreShell
)
{
return
NS_OK
;
}
nsISHEntry
*
destTreeRoot
=
data
-
>
destTreeRoot
;
nsCOMPtr
<
nsISHEntry
>
destEntry
;
if
(
data
-
>
destTreeParent
)
{
uint32_t
targetID
id
;
aEntry
-
>
GetID
(
&
targetID
)
;
nsCOMPtr
<
nsISHEntry
>
entry
;
data
-
>
destTreeParent
-
>
GetChildAt
(
aEntryIndex
getter_AddRefs
(
entry
)
)
;
if
(
entry
&
&
NS_SUCCEEDED
(
entry
-
>
GetID
(
&
id
)
)
&
&
id
=
=
targetID
)
{
destEntry
.
swap
(
entry
)
;
}
else
{
int32_t
childCount
;
data
-
>
destTreeParent
-
>
GetChildCount
(
&
childCount
)
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
data
-
>
destTreeParent
-
>
GetChildAt
(
i
getter_AddRefs
(
entry
)
)
;
if
(
!
entry
)
{
continue
;
}
entry
-
>
GetID
(
&
id
)
;
if
(
id
=
=
targetID
)
{
destEntry
.
swap
(
entry
)
;
break
;
}
}
}
}
else
{
destEntry
=
destTreeRoot
;
}
aShell
-
>
SwapHistoryEntries
(
aEntry
destEntry
)
;
SwapEntriesData
childData
=
{
ignoreShell
destTreeRoot
destEntry
}
;
return
WalkHistoryEntries
(
aEntry
aShell
SetChildHistoryEntry
&
childData
)
;
}
NS_IMETHODIMP
nsSHistory
:
:
AddEntry
(
nsISHEntry
*
aSHEntry
bool
aPersist
)
{
NS_ENSURE_ARG
(
aSHEntry
)
;
nsCOMPtr
<
nsISHistory
>
shistoryOfEntry
;
aSHEntry
-
>
GetSHistory
(
getter_AddRefs
(
shistoryOfEntry
)
)
;
if
(
shistoryOfEntry
&
&
shistoryOfEntry
!
=
this
)
{
NS_WARNING
(
"
The
entry
has
been
associated
to
another
nsISHistory
instance
.
"
"
Try
nsISHEntry
.
clone
(
)
and
nsISHEntry
.
abandonBFCacheEntry
(
)
"
"
first
if
you
'
re
copying
an
entry
from
another
nsISHistory
.
"
)
;
return
NS_ERROR_FAILURE
;
}
aSHEntry
-
>
SetSHistory
(
this
)
;
if
(
mRootDocShell
)
{
nsID
docshellID
=
mRootDocShell
-
>
HistoryID
(
)
;
aSHEntry
-
>
SetDocshellID
(
&
docshellID
)
;
}
nsCOMPtr
<
nsISHTransaction
>
currentTxn
;
GetTransactionAtIndex
(
mIndex
getter_AddRefs
(
currentTxn
)
)
;
bool
currentPersist
=
true
;
if
(
currentTxn
)
{
currentTxn
-
>
GetPersist
(
&
currentPersist
)
;
}
int32_t
currentIndex
=
mIndex
;
if
(
!
currentPersist
)
{
NOTIFY_LISTENERS
(
OnHistoryReplaceEntry
(
currentIndex
)
)
;
NS_ENSURE_SUCCESS
(
currentTxn
-
>
SetSHEntry
(
aSHEntry
)
NS_ERROR_FAILURE
)
;
currentTxn
-
>
SetPersist
(
aPersist
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
uri
;
aSHEntry
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NOTIFY_LISTENERS
(
OnHistoryNewEntry
(
uri
currentIndex
)
)
;
nsCOMPtr
<
nsISHTransaction
>
txn
=
new
nsSHTransaction
(
)
;
txn
-
>
SetPersist
(
aPersist
)
;
txn
-
>
SetSHEntry
(
aSHEntry
)
;
MOZ_ASSERT
(
mIndex
>
=
-
1
)
;
mTransactions
.
TruncateLength
(
mIndex
+
1
)
;
mTransactions
.
AppendElement
(
txn
)
;
mIndex
+
+
;
NOTIFY_LISTENERS
(
OnLengthChanged
(
Length
(
)
)
)
;
NOTIFY_LISTENERS
(
OnIndexChanged
(
mIndex
)
)
;
if
(
gHistoryMaxSize
>
=
0
&
&
Length
(
)
>
gHistoryMaxSize
)
{
PurgeHistory
(
Length
(
)
-
gHistoryMaxSize
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetCount
(
int32_t
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
Length
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetIndex
(
int32_t
*
aResult
)
{
MOZ_ASSERT
(
aResult
"
null
out
param
?
"
)
;
*
aResult
=
mIndex
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetRequestedIndex
(
int32_t
*
aResult
)
{
MOZ_ASSERT
(
aResult
"
null
out
param
?
"
)
;
*
aResult
=
mRequestedIndex
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetEntryAtIndex
(
int32_t
aIndex
bool
aModifyIndex
nsISHEntry
*
*
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsISHTransaction
>
txn
;
rv
=
GetTransactionAtIndex
(
aIndex
getter_AddRefs
(
txn
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
txn
)
{
rv
=
txn
-
>
GetSHEntry
(
aResult
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
*
aResult
)
)
{
if
(
aModifyIndex
)
{
mIndex
=
aIndex
;
NOTIFY_LISTENERS
(
OnIndexChanged
(
mIndex
)
)
}
}
}
return
rv
;
}
nsresult
nsSHistory
:
:
GetTransactionAtIndex
(
int32_t
aIndex
nsISHTransaction
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
if
(
aIndex
<
0
|
|
aIndex
>
=
Length
(
)
)
{
return
NS_ERROR_FAILURE
;
}
*
aResult
=
mTransactions
[
aIndex
]
;
NS_ADDREF
(
*
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetIndexOfEntry
(
nsISHEntry
*
aSHEntry
int32_t
*
aResult
)
{
NS_ENSURE_ARG
(
aSHEntry
)
;
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
-
1
;
for
(
int32_t
i
=
0
;
i
<
Length
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsISHEntry
>
entry
;
nsresult
rv
=
mTransactions
[
i
]
-
>
GetSHEntry
(
getter_AddRefs
(
entry
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
entry
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aSHEntry
=
=
entry
)
{
*
aResult
=
i
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
#
ifdef
DEBUG
nsresult
nsSHistory
:
:
PrintHistory
(
)
{
for
(
int32_t
i
=
0
;
i
<
Length
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsISHTransaction
>
txn
=
mTransactions
[
i
]
;
nsCOMPtr
<
nsISHEntry
>
entry
;
nsresult
rv
=
txn
-
>
GetSHEntry
(
getter_AddRefs
(
entry
)
)
;
if
(
NS_FAILED
(
rv
)
&
&
!
entry
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsILayoutHistoryState
>
layoutHistoryState
;
nsCOMPtr
<
nsIURI
>
uri
;
nsString
title
;
entry
-
>
GetLayoutHistoryState
(
getter_AddRefs
(
layoutHistoryState
)
)
;
entry
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
entry
-
>
GetTitle
(
getter_Copies
(
title
)
)
;
#
if
0
nsAutoCString
url
;
if
(
uri
)
{
uri
-
>
GetSpec
(
url
)
;
}
printf
(
"
*
*
*
*
SH
Transaction
#
%
d
Entry
=
%
x
\
n
"
i
entry
.
get
(
)
)
;
printf
(
"
\
t
\
t
URL
=
%
s
\
n
"
url
.
get
(
)
)
;
printf
(
"
\
t
\
t
Title
=
%
s
\
n
"
NS_LossyConvertUTF16toASCII
(
title
)
.
get
(
)
)
;
printf
(
"
\
t
\
t
layout
History
Data
=
%
x
\
n
"
layoutHistoryState
.
get
(
)
)
;
#
endif
}
return
NS_OK
;
}
#
endif
NS_IMETHODIMP
nsSHistory
:
:
GetMaxLength
(
int32_t
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
gHistoryMaxSize
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
SetMaxLength
(
int32_t
aMaxSize
)
{
if
(
aMaxSize
<
0
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
gHistoryMaxSize
=
aMaxSize
;
if
(
Length
(
)
>
aMaxSize
)
{
PurgeHistory
(
Length
(
)
-
aMaxSize
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
PurgeHistory
(
int32_t
aNumEntries
)
{
if
(
Length
(
)
<
=
0
|
|
aNumEntries
<
=
0
)
{
return
NS_ERROR_FAILURE
;
}
aNumEntries
=
std
:
:
min
(
aNumEntries
Length
(
)
)
;
bool
purgeHistory
=
true
;
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryPurge
purgeHistory
(
aNumEntries
&
purgeHistory
)
)
;
if
(
!
purgeHistory
)
{
return
NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA
;
}
mTransactions
.
RemoveElementsAt
(
0
aNumEntries
)
;
mIndex
-
=
aNumEntries
;
if
(
mIndex
<
-
1
)
{
mIndex
=
-
1
;
}
NOTIFY_LISTENERS
(
OnLengthChanged
(
Length
(
)
)
)
;
NOTIFY_LISTENERS
(
OnIndexChanged
(
mIndex
)
)
if
(
mRootDocShell
)
{
mRootDocShell
-
>
HistoryPurged
(
aNumEntries
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
AddSHistoryListener
(
nsISHistoryListener
*
aListener
)
{
NS_ENSURE_ARG_POINTER
(
aListener
)
;
nsWeakPtr
listener
=
do_GetWeakReference
(
aListener
)
;
if
(
!
listener
)
{
return
NS_ERROR_FAILURE
;
}
return
mListeners
.
AppendElementUnlessExists
(
listener
)
?
NS_OK
:
NS_ERROR_OUT_OF_MEMORY
;
}
NS_IMETHODIMP
nsSHistory
:
:
RemoveSHistoryListener
(
nsISHistoryListener
*
aListener
)
{
nsWeakPtr
listener
=
do_GetWeakReference
(
aListener
)
;
mListeners
.
RemoveElement
(
listener
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
ReplaceEntry
(
int32_t
aIndex
nsISHEntry
*
aReplaceEntry
)
{
NS_ENSURE_ARG
(
aReplaceEntry
)
;
nsresult
rv
;
nsCOMPtr
<
nsISHTransaction
>
currentTxn
;
rv
=
GetTransactionAtIndex
(
aIndex
getter_AddRefs
(
currentTxn
)
)
;
if
(
currentTxn
)
{
nsCOMPtr
<
nsISHistory
>
shistoryOfEntry
;
aReplaceEntry
-
>
GetSHistory
(
getter_AddRefs
(
shistoryOfEntry
)
)
;
if
(
shistoryOfEntry
&
&
shistoryOfEntry
!
=
this
)
{
NS_WARNING
(
"
The
entry
has
been
associated
to
another
nsISHistory
instance
.
"
"
Try
nsISHEntry
.
clone
(
)
and
nsISHEntry
.
abandonBFCacheEntry
(
)
"
"
first
if
you
'
re
copying
an
entry
from
another
nsISHistory
.
"
)
;
return
NS_ERROR_FAILURE
;
}
aReplaceEntry
-
>
SetSHistory
(
this
)
;
NOTIFY_LISTENERS
(
OnHistoryReplaceEntry
(
aIndex
)
)
;
rv
=
currentTxn
-
>
SetSHEntry
(
aReplaceEntry
)
;
rv
=
currentTxn
-
>
SetPersist
(
true
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsSHistory
:
:
NotifyOnHistoryReload
(
nsIURI
*
aReloadURI
uint32_t
aReloadFlags
bool
*
aCanReload
)
{
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryReload
*
aCanReload
(
aReloadURI
aReloadFlags
aCanReload
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
EvictOutOfRangeContentViewers
(
int32_t
aIndex
)
{
EvictOutOfRangeWindowContentViewers
(
aIndex
)
;
GloballyEvictContentViewers
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
EvictAllContentViewers
(
)
{
for
(
int32_t
i
=
0
;
i
<
Length
(
)
;
i
+
+
)
{
EvictContentViewerForTransaction
(
mTransactions
[
i
]
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetCanGoBack
(
bool
*
aCanGoBack
)
{
NS_ENSURE_ARG_POINTER
(
aCanGoBack
)
;
int32_t
index
=
-
1
;
NS_ENSURE_SUCCESS
(
GetIndex
(
&
index
)
NS_ERROR_FAILURE
)
;
if
(
index
>
0
)
{
*
aCanGoBack
=
true
;
return
NS_OK
;
}
*
aCanGoBack
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetCanGoForward
(
bool
*
aCanGoForward
)
{
NS_ENSURE_ARG_POINTER
(
aCanGoForward
)
;
int32_t
index
=
-
1
;
int32_t
count
=
-
1
;
NS_ENSURE_SUCCESS
(
GetIndex
(
&
index
)
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
GetCount
(
&
count
)
NS_ERROR_FAILURE
)
;
if
(
index
>
=
0
&
&
index
<
(
count
-
1
)
)
{
*
aCanGoForward
=
true
;
return
NS_OK
;
}
*
aCanGoForward
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GoBack
(
)
{
bool
canGoBack
=
false
;
GetCanGoBack
(
&
canGoBack
)
;
if
(
!
canGoBack
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
LoadEntry
(
mIndex
-
1
LOAD_HISTORY
HIST_CMD_BACK
)
;
}
NS_IMETHODIMP
nsSHistory
:
:
GoForward
(
)
{
bool
canGoForward
=
false
;
GetCanGoForward
(
&
canGoForward
)
;
if
(
!
canGoForward
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
LoadEntry
(
mIndex
+
1
LOAD_HISTORY
HIST_CMD_FORWARD
)
;
}
NS_IMETHODIMP
nsSHistory
:
:
Reload
(
uint32_t
aReloadFlags
)
{
uint32_t
loadType
;
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_BYPASS_PROXY
&
&
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_BYPASS_CACHE
)
{
loadType
=
LOAD_RELOAD_BYPASS_PROXY_AND_CACHE
;
}
else
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_BYPASS_PROXY
)
{
loadType
=
LOAD_RELOAD_BYPASS_PROXY
;
}
else
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_BYPASS_CACHE
)
{
loadType
=
LOAD_RELOAD_BYPASS_CACHE
;
}
else
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_CHARSET_CHANGE
)
{
loadType
=
LOAD_RELOAD_CHARSET_CHANGE
;
}
else
if
(
aReloadFlags
&
nsIWebNavigation
:
:
LOAD_FLAGS_ALLOW_MIXED_CONTENT
)
{
loadType
=
LOAD_RELOAD_ALLOW_MIXED_CONTENT
;
}
else
{
loadType
=
LOAD_RELOAD_NORMAL
;
}
bool
canNavigate
=
true
;
nsCOMPtr
<
nsIURI
>
currentURI
;
GetCurrentURI
(
getter_AddRefs
(
currentURI
)
)
;
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryReload
canNavigate
(
currentURI
aReloadFlags
&
canNavigate
)
)
;
if
(
!
canNavigate
)
{
return
NS_OK
;
}
return
LoadEntry
(
mIndex
loadType
HIST_CMD_RELOAD
)
;
}
NS_IMETHODIMP
nsSHistory
:
:
ReloadCurrentEntry
(
)
{
bool
canNavigate
=
true
;
nsCOMPtr
<
nsIURI
>
currentURI
;
GetCurrentURI
(
getter_AddRefs
(
currentURI
)
)
;
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryGotoIndex
canNavigate
(
mIndex
currentURI
&
canNavigate
)
)
;
if
(
!
canNavigate
)
{
return
NS_OK
;
}
return
LoadEntry
(
mIndex
LOAD_HISTORY
HIST_CMD_RELOAD
)
;
}
void
nsSHistory
:
:
EvictOutOfRangeWindowContentViewers
(
int32_t
aIndex
)
{
if
(
aIndex
<
0
)
{
return
;
}
NS_ENSURE_TRUE_VOID
(
aIndex
<
Length
(
)
)
;
int32_t
startSafeIndex
=
std
:
:
max
(
0
aIndex
-
nsISHistory
:
:
VIEWER_WINDOW
)
;
int32_t
endSafeIndex
=
std
:
:
min
(
Length
(
)
-
1
aIndex
+
nsISHistory
:
:
VIEWER_WINDOW
)
;
LOG
(
(
"
EvictOutOfRangeWindowContentViewers
(
index
=
%
d
)
"
"
Length
(
)
=
%
d
.
Safe
range
[
%
d
%
d
]
"
aIndex
Length
(
)
startSafeIndex
endSafeIndex
)
)
;
nsCOMArray
<
nsIContentViewer
>
safeViewers
;
for
(
int32_t
i
=
startSafeIndex
;
i
<
=
endSafeIndex
;
i
+
+
)
{
nsCOMPtr
<
nsIContentViewer
>
viewer
=
GetContentViewerForTransaction
(
mTransactions
[
i
]
)
;
safeViewers
.
AppendObject
(
viewer
)
;
}
for
(
int32_t
i
=
0
;
i
<
Length
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsISHTransaction
>
trans
=
mTransactions
[
i
]
;
nsCOMPtr
<
nsIContentViewer
>
viewer
=
GetContentViewerForTransaction
(
trans
)
;
if
(
safeViewers
.
IndexOf
(
viewer
)
=
=
-
1
)
{
EvictContentViewerForTransaction
(
trans
)
;
}
}
}
namespace
{
class
TransactionAndDistance
{
public
:
TransactionAndDistance
(
nsSHistory
*
aSHistory
nsISHTransaction
*
aTrans
uint32_t
aDist
)
:
mSHistory
(
aSHistory
)
mTransaction
(
aTrans
)
mLastTouched
(
0
)
mDistance
(
aDist
)
{
mViewer
=
GetContentViewerForTransaction
(
aTrans
)
;
NS_ASSERTION
(
mViewer
"
Transaction
should
have
a
content
viewer
"
)
;
nsCOMPtr
<
nsISHEntry
>
shentry
;
mTransaction
-
>
GetSHEntry
(
getter_AddRefs
(
shentry
)
)
;
shentry
-
>
GetLastTouched
(
&
mLastTouched
)
;
}
bool
operator
<
(
const
TransactionAndDistance
&
aOther
)
const
{
if
(
aOther
.
mDistance
!
=
this
-
>
mDistance
)
{
return
this
-
>
mDistance
<
aOther
.
mDistance
;
}
return
this
-
>
mLastTouched
<
aOther
.
mLastTouched
;
}
bool
operator
=
=
(
const
TransactionAndDistance
&
aOther
)
const
{
return
aOther
.
mDistance
=
=
this
-
>
mDistance
&
&
aOther
.
mLastTouched
=
=
this
-
>
mLastTouched
;
}
RefPtr
<
nsSHistory
>
mSHistory
;
nsCOMPtr
<
nsISHTransaction
>
mTransaction
;
nsCOMPtr
<
nsIContentViewer
>
mViewer
;
uint32_t
mLastTouched
;
int32_t
mDistance
;
}
;
}
void
nsSHistory
:
:
GloballyEvictContentViewers
(
)
{
nsTArray
<
TransactionAndDistance
>
transactions
;
for
(
auto
shist
:
gSHistoryList
)
{
nsTArray
<
TransactionAndDistance
>
shTransactions
;
int32_t
startIndex
=
std
:
:
max
(
0
shist
-
>
mIndex
-
nsISHistory
:
:
VIEWER_WINDOW
)
;
int32_t
endIndex
=
std
:
:
min
(
shist
-
>
Length
(
)
-
1
shist
-
>
mIndex
+
nsISHistory
:
:
VIEWER_WINDOW
)
;
for
(
int32_t
i
=
startIndex
;
i
<
=
endIndex
;
i
+
+
)
{
nsCOMPtr
<
nsISHTransaction
>
trans
=
shist
-
>
mTransactions
[
i
]
;
nsCOMPtr
<
nsIContentViewer
>
contentViewer
=
GetContentViewerForTransaction
(
trans
)
;
if
(
contentViewer
)
{
bool
found
=
false
;
for
(
uint32_t
j
=
0
;
j
<
shTransactions
.
Length
(
)
;
j
+
+
)
{
TransactionAndDistance
&
container
=
shTransactions
[
j
]
;
if
(
container
.
mViewer
=
=
contentViewer
)
{
container
.
mDistance
=
std
:
:
min
(
container
.
mDistance
DeprecatedAbs
(
i
-
shist
-
>
mIndex
)
)
;
found
=
true
;
break
;
}
}
if
(
!
found
)
{
TransactionAndDistance
container
(
shist
trans
DeprecatedAbs
(
i
-
shist
-
>
mIndex
)
)
;
shTransactions
.
AppendElement
(
container
)
;
}
}
}
transactions
.
AppendElements
(
shTransactions
)
;
}
if
(
(
int32_t
)
transactions
.
Length
(
)
<
=
sHistoryMaxTotalViewers
)
{
return
;
}
transactions
.
Sort
(
)
;
for
(
int32_t
i
=
transactions
.
Length
(
)
-
1
;
i
>
=
sHistoryMaxTotalViewers
;
-
-
i
)
{
(
transactions
[
i
]
.
mSHistory
)
-
>
EvictContentViewerForTransaction
(
transactions
[
i
]
.
mTransaction
)
;
}
}
nsresult
nsSHistory
:
:
FindTransactionForBFCache
(
nsIBFCacheEntry
*
aEntry
nsISHTransaction
*
*
aResult
int32_t
*
aResultIndex
)
{
*
aResult
=
nullptr
;
*
aResultIndex
=
-
1
;
int32_t
startIndex
=
std
:
:
max
(
0
mIndex
-
nsISHistory
:
:
VIEWER_WINDOW
)
;
int32_t
endIndex
=
std
:
:
min
(
Length
(
)
-
1
mIndex
+
nsISHistory
:
:
VIEWER_WINDOW
)
;
for
(
int32_t
i
=
startIndex
;
i
<
=
endIndex
;
+
+
i
)
{
nsCOMPtr
<
nsISHTransaction
>
trans
=
mTransactions
[
i
]
;
nsCOMPtr
<
nsISHEntry
>
entry
;
trans
-
>
GetSHEntry
(
getter_AddRefs
(
entry
)
)
;
if
(
entry
-
>
HasBFCacheEntry
(
aEntry
)
)
{
trans
.
forget
(
aResult
)
;
*
aResultIndex
=
i
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
nsresult
nsSHistory
:
:
EvictExpiredContentViewerForEntry
(
nsIBFCacheEntry
*
aEntry
)
{
int32_t
index
;
nsCOMPtr
<
nsISHTransaction
>
trans
;
FindTransactionForBFCache
(
aEntry
getter_AddRefs
(
trans
)
&
index
)
;
if
(
index
=
=
mIndex
)
{
NS_WARNING
(
"
How
did
the
current
SHEntry
expire
?
"
)
;
return
NS_OK
;
}
if
(
trans
)
{
EvictContentViewerForTransaction
(
trans
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
AddToExpirationTracker
(
nsIBFCacheEntry
*
aEntry
)
{
RefPtr
<
nsSHEntryShared
>
entry
=
static_cast
<
nsSHEntryShared
*
>
(
aEntry
)
;
if
(
!
mHistoryTracker
|
|
!
entry
)
{
return
NS_ERROR_FAILURE
;
}
mHistoryTracker
-
>
AddObject
(
entry
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
RemoveFromExpirationTracker
(
nsIBFCacheEntry
*
aEntry
)
{
RefPtr
<
nsSHEntryShared
>
entry
=
static_cast
<
nsSHEntryShared
*
>
(
aEntry
)
;
MOZ_ASSERT
(
mHistoryTracker
&
&
!
mHistoryTracker
-
>
IsEmpty
(
)
)
;
if
(
!
mHistoryTracker
|
|
!
entry
)
{
return
NS_ERROR_FAILURE
;
}
mHistoryTracker
-
>
RemoveObject
(
entry
)
;
return
NS_OK
;
}
void
nsSHistory
:
:
GloballyEvictAllContentViewers
(
)
{
int32_t
maxViewers
=
sHistoryMaxTotalViewers
;
sHistoryMaxTotalViewers
=
0
;
GloballyEvictContentViewers
(
)
;
sHistoryMaxTotalViewers
=
maxViewers
;
}
void
GetDynamicChildren
(
nsISHEntry
*
aEntry
nsTArray
<
nsID
>
&
aDocshellIDs
bool
aOnlyTopLevelDynamic
)
{
int32_t
count
=
0
;
aEntry
-
>
GetChildCount
(
&
count
)
;
for
(
int32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
nsCOMPtr
<
nsISHEntry
>
child
;
aEntry
-
>
GetChildAt
(
i
getter_AddRefs
(
child
)
)
;
if
(
child
)
{
bool
dynAdded
=
false
;
child
-
>
IsDynamicallyAdded
(
&
dynAdded
)
;
if
(
dynAdded
)
{
nsID
docshellID
=
child
-
>
DocshellID
(
)
;
aDocshellIDs
.
AppendElement
(
docshellID
)
;
}
if
(
!
dynAdded
|
|
!
aOnlyTopLevelDynamic
)
{
GetDynamicChildren
(
child
aDocshellIDs
aOnlyTopLevelDynamic
)
;
}
}
}
}
bool
RemoveFromSessionHistoryEntry
(
nsISHEntry
*
aRoot
nsTArray
<
nsID
>
&
aDocshellIDs
)
{
bool
didRemove
=
false
;
int32_t
childCount
=
0
;
aRoot
-
>
GetChildCount
(
&
childCount
)
;
for
(
int32_t
i
=
childCount
-
1
;
i
>
=
0
;
-
-
i
)
{
nsCOMPtr
<
nsISHEntry
>
child
;
aRoot
-
>
GetChildAt
(
i
getter_AddRefs
(
child
)
)
;
if
(
child
)
{
nsID
docshelldID
=
child
-
>
DocshellID
(
)
;
if
(
aDocshellIDs
.
Contains
(
docshelldID
)
)
{
didRemove
=
true
;
aRoot
-
>
RemoveChild
(
child
)
;
}
else
{
bool
childRemoved
=
RemoveFromSessionHistoryEntry
(
child
aDocshellIDs
)
;
if
(
childRemoved
)
{
didRemove
=
true
;
}
}
}
}
return
didRemove
;
}
bool
RemoveChildEntries
(
nsISHistory
*
aHistory
int32_t
aIndex
nsTArray
<
nsID
>
&
aEntryIDs
)
{
nsCOMPtr
<
nsISHEntry
>
root
;
aHistory
-
>
GetEntryAtIndex
(
aIndex
false
getter_AddRefs
(
root
)
)
;
return
root
?
RemoveFromSessionHistoryEntry
(
root
aEntryIDs
)
:
false
;
}
bool
IsSameTree
(
nsISHEntry
*
aEntry1
nsISHEntry
*
aEntry2
)
{
if
(
!
aEntry1
&
&
!
aEntry2
)
{
return
true
;
}
if
(
(
!
aEntry1
&
&
aEntry2
)
|
|
(
aEntry1
&
&
!
aEntry2
)
)
{
return
false
;
}
uint32_t
id1
id2
;
aEntry1
-
>
GetID
(
&
id1
)
;
aEntry2
-
>
GetID
(
&
id2
)
;
if
(
id1
!
=
id2
)
{
return
false
;
}
int32_t
count1
count2
;
aEntry1
-
>
GetChildCount
(
&
count1
)
;
aEntry2
-
>
GetChildCount
(
&
count2
)
;
int32_t
count
=
std
:
:
max
(
count1
count2
)
;
for
(
int32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
nsCOMPtr
<
nsISHEntry
>
child1
child2
;
aEntry1
-
>
GetChildAt
(
i
getter_AddRefs
(
child1
)
)
;
aEntry2
-
>
GetChildAt
(
i
getter_AddRefs
(
child2
)
)
;
if
(
!
IsSameTree
(
child1
child2
)
)
{
return
false
;
}
}
return
true
;
}
bool
nsSHistory
:
:
RemoveDuplicate
(
int32_t
aIndex
bool
aKeepNext
)
{
NS_ASSERTION
(
aIndex
>
=
0
"
aIndex
must
be
>
=
0
!
"
)
;
NS_ASSERTION
(
aIndex
!
=
0
|
|
aKeepNext
"
If
we
'
re
removing
index
0
we
must
be
keeping
the
next
"
)
;
NS_ASSERTION
(
aIndex
!
=
mIndex
"
Shouldn
'
t
remove
mIndex
!
"
)
;
int32_t
compareIndex
=
aKeepNext
?
aIndex
+
1
:
aIndex
-
1
;
nsresult
rv
;
nsCOMPtr
<
nsISHEntry
>
root1
root2
;
rv
=
GetEntryAtIndex
(
aIndex
false
getter_AddRefs
(
root1
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
rv
=
GetEntryAtIndex
(
compareIndex
false
getter_AddRefs
(
root2
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
IsSameTree
(
root1
root2
)
)
{
mTransactions
.
RemoveElementAt
(
aIndex
)
;
if
(
mRootDocShell
)
{
static_cast
<
nsDocShell
*
>
(
mRootDocShell
)
-
>
HistoryTransactionRemoved
(
aIndex
)
;
}
if
(
mIndex
>
aIndex
)
{
mIndex
=
mIndex
-
1
;
NOTIFY_LISTENERS
(
OnIndexChanged
(
mIndex
)
)
;
}
if
(
mRequestedIndex
>
aIndex
|
|
(
mRequestedIndex
=
=
aIndex
&
&
!
aKeepNext
)
)
{
mRequestedIndex
=
mRequestedIndex
-
1
;
}
NOTIFY_LISTENERS
(
OnLengthChanged
(
Length
(
)
)
)
;
return
true
;
}
return
false
;
}
NS_IMETHODIMP_
(
void
)
nsSHistory
:
:
RemoveEntries
(
nsTArray
<
nsID
>
&
aIDs
int32_t
aStartIndex
)
{
int32_t
index
=
aStartIndex
;
while
(
index
>
=
0
&
&
RemoveChildEntries
(
this
-
-
index
aIDs
)
)
{
}
int32_t
minIndex
=
index
;
index
=
aStartIndex
;
while
(
index
>
=
0
&
&
RemoveChildEntries
(
this
index
+
+
aIDs
)
)
{
}
bool
didRemove
=
false
;
while
(
index
>
minIndex
)
{
if
(
index
!
=
mIndex
)
{
didRemove
=
RemoveDuplicate
(
index
index
<
mIndex
)
|
|
didRemove
;
}
-
-
index
;
}
if
(
didRemove
&
&
mRootDocShell
)
{
mRootDocShell
-
>
DispatchLocationChangeEvent
(
)
;
}
}
void
nsSHistory
:
:
RemoveDynEntries
(
int32_t
aIndex
nsISHEntry
*
aEntry
)
{
nsCOMPtr
<
nsISHEntry
>
entry
(
aEntry
)
;
if
(
!
entry
)
{
GetEntryAtIndex
(
aIndex
false
getter_AddRefs
(
entry
)
)
;
}
if
(
entry
)
{
AutoTArray
<
nsID
16
>
toBeRemovedEntries
;
GetDynamicChildren
(
entry
toBeRemovedEntries
true
)
;
if
(
toBeRemovedEntries
.
Length
(
)
)
{
RemoveEntries
(
toBeRemovedEntries
aIndex
)
;
}
}
}
void
nsSHistory
:
:
RemoveDynEntriesForBFCacheEntry
(
nsIBFCacheEntry
*
aEntry
)
{
int32_t
index
;
nsCOMPtr
<
nsISHTransaction
>
trans
;
FindTransactionForBFCache
(
aEntry
getter_AddRefs
(
trans
)
&
index
)
;
if
(
trans
)
{
nsCOMPtr
<
nsISHEntry
>
entry
;
trans
-
>
GetSHEntry
(
getter_AddRefs
(
entry
)
)
;
RemoveDynEntries
(
index
entry
)
;
}
}
NS_IMETHODIMP
nsSHistory
:
:
UpdateIndex
(
)
{
if
(
mIndex
!
=
mRequestedIndex
&
&
mRequestedIndex
!
=
-
1
)
{
mIndex
=
mRequestedIndex
;
NOTIFY_LISTENERS
(
OnIndexChanged
(
mIndex
)
)
}
mRequestedIndex
=
-
1
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
Stop
(
uint32_t
aStopFlags
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetDocument
(
nsIDocument
*
*
aDocument
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetCurrentURI
(
nsIURI
*
*
aResultURI
)
{
NS_ENSURE_ARG_POINTER
(
aResultURI
)
;
nsresult
rv
;
nsCOMPtr
<
nsISHEntry
>
currentEntry
;
rv
=
GetEntryAtIndex
(
mIndex
false
getter_AddRefs
(
currentEntry
)
)
;
if
(
NS_FAILED
(
rv
)
&
&
!
currentEntry
)
{
return
rv
;
}
rv
=
currentEntry
-
>
GetURI
(
aResultURI
)
;
return
rv
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetReferringURI
(
nsIURI
*
*
aURI
)
{
*
aURI
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GetSessionHistoryXPCOM
(
nsISupports
*
*
aSessionHistory
)
{
*
aSessionHistory
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
LoadURIWithOptions
(
const
char16_t
*
aURI
uint32_t
aLoadFlags
nsIURI
*
aReferringURI
uint32_t
aReferrerPolicy
nsIInputStream
*
aPostStream
nsIInputStream
*
aExtraHeaderStream
nsIURI
*
aBaseURI
nsIPrincipal
*
aTriggeringPrincipal
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
SetOriginAttributesBeforeLoading
(
JS
:
:
HandleValue
aOriginAttributes
JSContext
*
aCx
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
LoadURI
(
const
char16_t
*
aURI
uint32_t
aLoadFlags
nsIURI
*
aReferringURI
nsIInputStream
*
aPostStream
nsIInputStream
*
aExtraHeaderStream
nsIPrincipal
*
aTriggeringPrincipal
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSHistory
:
:
GotoIndex
(
int32_t
aIndex
)
{
return
LoadEntry
(
aIndex
LOAD_HISTORY
HIST_CMD_GOTOINDEX
)
;
}
nsresult
nsSHistory
:
:
LoadNextPossibleEntry
(
int32_t
aNewIndex
long
aLoadType
uint32_t
aHistCmd
)
{
mRequestedIndex
=
-
1
;
if
(
aNewIndex
<
mIndex
)
{
return
LoadEntry
(
aNewIndex
-
1
aLoadType
aHistCmd
)
;
}
if
(
aNewIndex
>
mIndex
)
{
return
LoadEntry
(
aNewIndex
+
1
aLoadType
aHistCmd
)
;
}
return
NS_ERROR_FAILURE
;
}
nsresult
nsSHistory
:
:
LoadEntry
(
int32_t
aIndex
long
aLoadType
uint32_t
aHistCmd
)
{
if
(
!
mRootDocShell
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIURI
>
nextURI
;
nsCOMPtr
<
nsISHEntry
>
prevEntry
;
nsCOMPtr
<
nsISHEntry
>
nextEntry
;
if
(
aIndex
<
0
|
|
aIndex
>
=
Length
(
)
)
{
return
NS_ERROR_FAILURE
;
}
mRequestedIndex
=
aIndex
;
GetEntryAtIndex
(
mIndex
false
getter_AddRefs
(
prevEntry
)
)
;
GetEntryAtIndex
(
mRequestedIndex
false
getter_AddRefs
(
nextEntry
)
)
;
if
(
!
nextEntry
|
|
!
prevEntry
)
{
mRequestedIndex
=
-
1
;
return
NS_ERROR_FAILURE
;
}
nextEntry
-
>
SetLastTouched
(
+
+
gTouchCounter
)
;
nextEntry
-
>
GetURI
(
getter_AddRefs
(
nextURI
)
)
;
MOZ_ASSERT
(
(
prevEntry
&
&
nextEntry
&
&
nextURI
)
"
prevEntry
nextEntry
and
nextURI
can
'
t
be
null
"
)
;
bool
canNavigate
=
true
;
if
(
aHistCmd
=
=
HIST_CMD_BACK
)
{
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryGoBack
canNavigate
(
nextURI
&
canNavigate
)
)
;
}
else
if
(
aHistCmd
=
=
HIST_CMD_FORWARD
)
{
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryGoForward
canNavigate
(
nextURI
&
canNavigate
)
)
;
}
else
if
(
aHistCmd
=
=
HIST_CMD_GOTOINDEX
)
{
NOTIFY_LISTENERS_CANCELABLE
(
OnHistoryGotoIndex
canNavigate
(
aIndex
nextURI
&
canNavigate
)
)
;
}
if
(
!
canNavigate
)
{
mRequestedIndex
=
-
1
;
return
NS_OK
;
}
if
(
mRequestedIndex
=
=
mIndex
)
{
return
InitiateLoad
(
nextEntry
mRootDocShell
aLoadType
)
;
}
bool
differenceFound
=
false
;
nsresult
rv
=
LoadDifferingEntries
(
prevEntry
nextEntry
mRootDocShell
aLoadType
differenceFound
)
;
if
(
!
differenceFound
)
{
return
LoadNextPossibleEntry
(
aIndex
aLoadType
aHistCmd
)
;
}
return
rv
;
}
nsresult
nsSHistory
:
:
LoadDifferingEntries
(
nsISHEntry
*
aPrevEntry
nsISHEntry
*
aNextEntry
nsIDocShell
*
aParent
long
aLoadType
bool
&
aDifferenceFound
)
{
if
(
!
aPrevEntry
|
|
!
aNextEntry
|
|
!
aParent
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
result
=
NS_OK
;
uint32_t
prevID
nextID
;
aPrevEntry
-
>
GetID
(
&
prevID
)
;
aNextEntry
-
>
GetID
(
&
nextID
)
;
if
(
prevID
!
=
nextID
)
{
aDifferenceFound
=
true
;
aNextEntry
-
>
SetIsSubFrame
(
aParent
!
=
mRootDocShell
)
;
return
InitiateLoad
(
aNextEntry
aParent
aLoadType
)
;
}
int32_t
pcnt
=
0
;
int32_t
ncnt
=
0
;
int32_t
dsCount
=
0
;
aPrevEntry
-
>
GetChildCount
(
&
pcnt
)
;
aNextEntry
-
>
GetChildCount
(
&
ncnt
)
;
aParent
-
>
GetChildCount
(
&
dsCount
)
;
nsCOMArray
<
nsIDocShell
>
docshells
;
for
(
int32_t
i
=
0
;
i
<
dsCount
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
;
aParent
-
>
GetChildAt
(
i
getter_AddRefs
(
treeItem
)
)
;
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryInterface
(
treeItem
)
;
if
(
shell
)
{
docshells
.
AppendElement
(
shell
.
forget
(
)
)
;
}
}
for
(
int32_t
i
=
0
;
i
<
ncnt
;
+
+
i
)
{
nsCOMPtr
<
nsISHEntry
>
nChild
;
aNextEntry
-
>
GetChildAt
(
i
getter_AddRefs
(
nChild
)
)
;
if
(
!
nChild
)
{
continue
;
}
nsID
docshellID
=
nChild
-
>
DocshellID
(
)
;
nsIDocShell
*
dsChild
=
nullptr
;
int32_t
count
=
docshells
.
Count
(
)
;
for
(
int32_t
j
=
0
;
j
<
count
;
+
+
j
)
{
nsIDocShell
*
shell
=
docshells
[
j
]
;
nsID
shellID
=
shell
-
>
HistoryID
(
)
;
if
(
shellID
=
=
docshellID
)
{
dsChild
=
shell
;
break
;
}
}
if
(
!
dsChild
)
{
continue
;
}
nsCOMPtr
<
nsISHEntry
>
pChild
;
for
(
int32_t
k
=
0
;
k
<
pcnt
;
+
+
k
)
{
nsCOMPtr
<
nsISHEntry
>
child
;
aPrevEntry
-
>
GetChildAt
(
k
getter_AddRefs
(
child
)
)
;
if
(
child
)
{
nsID
dID
=
child
-
>
DocshellID
(
)
;
if
(
dID
=
=
docshellID
)
{
pChild
=
child
;
break
;
}
}
}
LoadDifferingEntries
(
pChild
nChild
dsChild
aLoadType
aDifferenceFound
)
;
}
return
result
;
}
nsresult
nsSHistory
:
:
InitiateLoad
(
nsISHEntry
*
aFrameEntry
nsIDocShell
*
aFrameDS
long
aLoadType
)
{
NS_ENSURE_STATE
(
aFrameDS
&
&
aFrameEntry
)
;
RefPtr
<
nsDocShellLoadInfo
>
loadInfo
=
new
nsDocShellLoadInfo
(
)
;
aFrameEntry
-
>
SetLoadType
(
aLoadType
)
;
loadInfo
-
>
SetLoadType
(
aLoadType
)
;
loadInfo
-
>
SetSHEntry
(
aFrameEntry
)
;
nsCOMPtr
<
nsIURI
>
originalURI
;
aFrameEntry
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
loadInfo
-
>
SetOriginalURI
(
originalURI
)
;
bool
loadReplace
;
aFrameEntry
-
>
GetLoadReplace
(
&
loadReplace
)
;
loadInfo
-
>
SetLoadReplace
(
loadReplace
)
;
nsCOMPtr
<
nsIURI
>
nextURI
;
aFrameEntry
-
>
GetURI
(
getter_AddRefs
(
nextURI
)
)
;
return
aFrameDS
-
>
LoadURI
(
nextURI
loadInfo
nsIWebNavigation
:
:
LOAD_FLAGS_NONE
false
)
;
}
NS_IMETHODIMP
nsSHistory
:
:
SetRootDocShell
(
nsIDocShell
*
aDocShell
)
{
mRootDocShell
=
aDocShell
;
if
(
mRootDocShell
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
mRootDocShell
-
>
GetWindow
(
)
;
if
(
!
win
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
mHistoryTracker
)
{
NS_WARNING
(
"
Change
the
root
docshell
of
a
shistory
is
unsafe
and
"
"
potentially
problematic
.
"
)
;
mHistoryTracker
-
>
AgeAllGenerations
(
)
;
}
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
win
)
;
mHistoryTracker
=
mozilla
:
:
MakeUnique
<
HistoryTracker
>
(
this
mozilla
:
:
Preferences
:
:
GetUint
(
CONTENT_VIEWER_TIMEOUT_SECONDS
CONTENT_VIEWER_TIMEOUT_SECONDS_DEFAULT
)
global
-
>
EventTargetFor
(
mozilla
:
:
TaskCategory
:
:
Other
)
)
;
}
return
NS_OK
;
}
