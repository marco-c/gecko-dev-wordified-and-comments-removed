if
(
!
window
.
opener
&
&
window
.
arguments
)
{
window
.
opener
=
window
.
arguments
[
0
]
;
}
var
imports
=
[
"
SimpleTest
"
"
is
"
"
isnot
"
"
ok
"
"
onerror
"
"
todo
"
"
todo_is
"
"
todo_isnot
"
]
;
for
(
var
name
of
imports
)
{
window
[
name
]
=
window
.
opener
.
wrappedJSObject
[
name
]
;
}
const
{
BrowserTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
BrowserTestUtils
.
sys
.
mjs
"
)
;
const
ACTOR_MODULE_URI
=
"
chrome
:
/
/
mochitests
/
content
/
chrome
/
docshell
/
test
/
chrome
/
DocShellHelpers
.
sys
.
mjs
"
;
const
{
DocShellHelpersParent
}
=
ChromeUtils
.
importESModule
(
ACTOR_MODULE_URI
)
;
const
NAV_NONE
=
0
;
const
NAV_BACK
=
1
;
const
NAV_FORWARD
=
2
;
const
NAV_GOTOINDEX
=
3
;
const
NAV_URI
=
4
;
const
NAV_RELOAD
=
5
;
var
gExpectedEvents
;
var
gUnexpectedEvents
;
var
gFinalEvent
;
var
gUrisNotInBFCache
=
[
]
;
var
gNavType
=
NAV_NONE
;
var
gOrigMaxTotalViewers
=
undefined
;
var
gExtractedPath
=
null
;
function
doPageNavigation
(
params
)
{
let
back
=
params
.
back
?
params
.
back
:
false
;
let
forward
=
params
.
forward
?
params
.
forward
:
false
;
let
gotoIndex
=
params
.
gotoIndex
?
params
.
gotoIndex
:
false
;
let
reload
=
params
.
reload
?
params
.
reload
:
false
;
let
uri
=
params
.
uri
?
params
.
uri
:
false
;
let
eventsToListenFor
=
typeof
params
.
eventsToListenFor
!
=
"
undefined
"
?
params
.
eventsToListenFor
:
[
"
pageshow
"
]
;
gExpectedEvents
=
typeof
params
.
eventsToListenFor
=
=
"
undefined
"
|
|
!
eventsToListenFor
.
length
?
undefined
:
params
.
expectedEvents
;
gUnexpectedEvents
=
typeof
params
.
eventsToListenFor
=
=
"
undefined
"
|
|
!
eventsToListenFor
.
length
?
undefined
:
params
.
unexpectedEvents
;
let
preventBFCache
=
typeof
[
params
.
preventBFCache
]
=
=
"
undefined
"
?
false
:
params
.
preventBFCache
;
let
waitOnly
=
typeof
params
.
waitForEventsOnly
=
=
"
boolean
"
&
&
params
.
waitForEventsOnly
;
let
navigation
=
[
"
back
"
"
forward
"
"
gotoIndex
"
"
reload
"
"
uri
"
]
.
filter
(
k
=
>
params
.
hasOwnProperty
(
k
)
)
;
if
(
navigation
.
length
>
1
)
{
throw
new
Error
(
Can
'
t
specify
both
{
navigation
[
0
]
}
and
{
navigation
[
1
]
}
)
;
}
else
if
(
!
navigation
.
length
&
&
!
waitOnly
)
{
throw
new
Error
(
"
Must
specify
back
or
forward
or
gotoIndex
or
reload
or
uri
"
)
;
}
if
(
params
.
onNavComplete
&
&
!
eventsToListenFor
.
length
)
{
throw
new
Error
(
"
Can
'
t
use
onNavComplete
when
eventsToListenFor
=
=
[
]
"
)
;
}
if
(
params
.
preventBFCache
&
&
!
eventsToListenFor
.
length
)
{
throw
new
Error
(
"
Can
'
t
use
preventBFCache
when
eventsToListenFor
=
=
[
]
"
)
;
}
if
(
params
.
preventBFCache
&
&
waitOnly
)
{
throw
new
Error
(
"
Can
'
t
prevent
bfcaching
when
only
waiting
for
events
"
)
;
}
if
(
waitOnly
&
&
typeof
params
.
onNavComplete
=
=
"
undefined
"
)
{
throw
new
Error
(
"
Must
specify
onNavComplete
when
specifying
waitForEventsOnly
"
)
;
}
if
(
waitOnly
&
&
navigation
.
length
)
{
throw
new
Error
(
"
Can
'
t
specify
a
navigation
type
when
using
waitForEventsOnly
"
)
;
}
for
(
let
anEventType
of
eventsToListenFor
)
{
let
eventFound
=
false
;
if
(
anEventType
=
=
"
pageshow
"
&
&
!
gExpectedEvents
)
{
eventFound
=
true
;
}
if
(
gExpectedEvents
)
{
for
(
let
anExpectedEvent
of
gExpectedEvents
)
{
if
(
anExpectedEvent
.
type
=
=
anEventType
)
{
eventFound
=
true
;
}
}
}
if
(
gUnexpectedEvents
)
{
for
(
let
anExpectedEventType
of
gUnexpectedEvents
)
{
if
(
anExpectedEventType
=
=
anEventType
)
{
eventFound
=
true
;
}
}
}
if
(
!
eventFound
)
{
throw
new
Error
(
Event
type
{
anEventType
}
is
specified
in
+
"
eventsToListenFor
but
not
in
expectedEvents
"
)
;
}
}
gFinalEvent
=
!
eventsToListenFor
.
length
;
let
observers
=
new
Map
(
)
;
if
(
params
.
hasOwnProperty
(
"
onGlobalCreation
"
)
)
{
observers
.
set
(
"
content
-
document
-
global
-
created
"
params
.
onGlobalCreation
)
;
}
let
cleanup
;
let
useActor
=
TestWindow
.
getBrowser
(
)
.
isRemoteBrowser
;
if
(
useActor
)
{
ChromeUtils
.
registerWindowActor
(
"
DocShellHelpers
"
{
parent
:
{
esModuleURI
:
ACTOR_MODULE_URI
}
child
:
{
esModuleURI
:
ACTOR_MODULE_URI
events
:
{
pageshow
:
{
createActor
:
true
capture
:
true
}
pagehide
:
{
createActor
:
true
capture
:
true
}
load
:
{
createActor
:
true
capture
:
true
}
unload
:
{
createActor
:
true
capture
:
true
}
visibilitychange
:
{
createActor
:
true
capture
:
true
}
}
observers
:
observers
.
keys
(
)
}
allFrames
:
true
messageManagerGroups
:
[
"
browsers
"
"
"
]
}
)
;
DocShellHelpersParent
.
eventsToListenFor
=
eventsToListenFor
;
DocShellHelpersParent
.
observers
=
observers
;
cleanup
=
(
)
=
>
{
DocShellHelpersParent
.
eventsToListenFor
=
null
;
DocShellHelpersParent
.
observers
=
null
;
ChromeUtils
.
unregisterWindowActor
(
"
DocShellHelpers
"
)
;
}
;
}
else
{
for
(
let
eventType
of
eventsToListenFor
)
{
dump
(
"
TEST
:
registering
a
listener
for
"
+
eventType
+
"
events
\
n
"
)
;
TestWindow
.
getBrowser
(
)
.
addEventListener
(
eventType
pageEventListener
true
)
;
}
if
(
observers
.
size
>
0
)
{
let
observer
=
(
_
topic
)
=
>
{
observers
.
get
(
topic
)
.
call
(
)
;
}
;
for
(
let
topic
of
observers
.
keys
(
)
)
{
Services
.
obs
.
addObserver
(
observer
topic
)
;
}
cleanup
=
(
)
=
>
{
for
(
let
topic
of
observers
.
keys
(
)
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
}
}
;
}
}
if
(
cleanup
)
{
Services
.
ww
.
registerNotification
(
function
windowClosed
(
subject
topic
)
{
if
(
topic
=
=
"
domwindowclosed
"
&
&
subject
=
=
window
)
{
Services
.
ww
.
unregisterNotification
(
windowClosed
)
;
cleanup
(
)
;
}
}
)
;
}
if
(
back
)
{
gNavType
=
NAV_BACK
;
TestWindow
.
getBrowser
(
)
.
goBack
(
)
;
}
else
if
(
forward
)
{
gNavType
=
NAV_FORWARD
;
TestWindow
.
getBrowser
(
)
.
goForward
(
)
;
}
else
if
(
typeof
gotoIndex
=
=
"
number
"
)
{
gNavType
=
NAV_GOTOINDEX
;
TestWindow
.
getBrowser
(
)
.
gotoIndex
(
gotoIndex
)
;
}
else
if
(
uri
)
{
gNavType
=
NAV_URI
;
BrowserTestUtils
.
startLoadingURIString
(
TestWindow
.
getBrowser
(
)
uri
)
;
}
else
if
(
reload
)
{
gNavType
=
NAV_RELOAD
;
TestWindow
.
getBrowser
(
)
.
reload
(
)
;
}
else
if
(
waitOnly
)
{
gNavType
=
NAV_NONE
;
}
else
{
throw
new
Error
(
"
No
valid
navigation
type
passed
to
doPageNavigation
!
"
)
;
}
if
(
eventsToListenFor
.
length
&
&
params
.
onNavComplete
)
{
waitForTrue
(
function
(
)
{
return
gFinalEvent
;
}
function
(
)
{
doPageNavigation_complete
(
eventsToListenFor
params
.
onNavComplete
preventBFCache
useActor
cleanup
)
;
}
)
;
}
else
if
(
cleanup
)
{
cleanup
(
)
;
}
}
function
doPageNavigation_complete
(
eventsToListenFor
onNavComplete
preventBFCache
useActor
cleanup
)
{
if
(
useActor
)
{
if
(
preventBFCache
)
{
let
actor
=
TestWindow
.
getBrowser
(
)
.
browsingContext
.
currentWindowGlobal
.
getActor
(
"
DocShellHelpers
"
)
;
actor
.
sendAsyncMessage
(
"
docshell_helpers
:
preventBFCache
"
)
;
}
}
else
{
dump
(
"
TEST
:
removing
event
listeners
\
n
"
)
;
for
(
let
eventType
of
eventsToListenFor
)
{
TestWindow
.
getBrowser
(
)
.
removeEventListener
(
eventType
pageEventListener
true
)
;
}
if
(
preventBFCache
)
{
let
win
=
TestWindow
.
getWindow
(
)
;
win
.
blockBFCache
=
new
win
.
RTCPeerConnection
(
)
;
}
}
if
(
cleanup
)
{
cleanup
(
)
;
}
let
uri
=
TestWindow
.
getBrowser
(
)
.
currentURI
.
spec
;
if
(
preventBFCache
)
{
if
(
!
(
uri
in
gUrisNotInBFCache
)
)
{
gUrisNotInBFCache
.
push
(
uri
)
;
}
}
else
if
(
gNavType
=
=
NAV_URI
)
{
gUrisNotInBFCache
.
forEach
(
function
(
element
index
array
)
{
if
(
element
=
=
uri
)
{
array
.
splice
(
index
1
)
;
}
}
this
)
;
}
onNavComplete
.
call
(
)
;
}
function
promisePageNavigation
(
params
)
{
if
(
params
.
hasOwnProperty
(
"
onNavComplete
"
)
)
{
throw
new
Error
(
"
Can
'
t
use
a
onNavComplete
completion
callback
with
promisePageNavigation
.
"
)
;
}
return
new
Promise
(
resolve
=
>
{
params
.
onNavComplete
=
resolve
;
doPageNavigation
(
params
)
;
}
)
;
}
function
waitForPageEvents
(
params
)
{
params
.
waitForEventsOnly
=
true
;
doPageNavigation
(
params
)
;
}
function
promisePageEvents
(
params
)
{
if
(
params
.
hasOwnProperty
(
"
onNavComplete
"
)
)
{
throw
new
Error
(
"
Can
'
t
use
a
onNavComplete
completion
callback
with
promisePageEvents
.
"
)
;
}
return
new
Promise
(
resolve
=
>
{
params
.
waitForEventsOnly
=
true
;
params
.
onNavComplete
=
resolve
;
doPageNavigation
(
params
)
;
}
)
;
}
function
pageEventListener
(
event
originalTargetIsHTMLDocument
=
HTMLDocument
.
isInstance
(
event
.
originalTarget
)
)
{
try
{
dump
(
"
TEST
:
eventListener
received
a
"
+
event
.
type
+
"
event
for
page
"
+
event
.
originalTarget
.
title
+
"
persisted
=
"
+
event
.
persisted
+
"
\
n
"
)
;
}
catch
(
e
)
{
}
if
(
event
.
type
=
=
"
pageshow
"
&
&
(
gNavType
=
=
NAV_BACK
|
|
gNavType
=
=
NAV_FORWARD
|
|
gNavType
=
=
NAV_GOTOINDEX
)
)
{
let
uri
=
TestWindow
.
getBrowser
(
)
.
currentURI
.
spec
;
if
(
uri
in
gUrisNotInBFCache
)
{
ok
(
!
event
.
persisted
"
pageshow
event
has
.
persisted
=
false
even
"
+
"
though
it
was
loaded
with
.
preventBFCache
previously
\
n
"
)
;
}
}
if
(
typeof
gUnexpectedEvents
!
=
"
undefined
"
)
{
is
(
gUnexpectedEvents
.
indexOf
(
event
.
type
)
-
1
"
Should
not
get
unexpected
event
"
+
event
.
type
)
;
}
if
(
typeof
gExpectedEvents
=
=
"
undefined
"
&
&
event
.
type
=
=
"
pageshow
"
)
{
waitForNextPaint
(
function
(
)
{
gFinalEvent
=
true
;
}
)
;
return
;
}
if
(
!
gExpectedEvents
.
length
)
{
ok
(
false
"
Unexpected
event
(
"
+
event
.
type
+
"
)
occurred
"
)
;
return
;
}
let
expected
=
gExpectedEvents
.
shift
(
)
;
is
(
event
.
type
expected
.
type
"
A
"
+
expected
.
type
+
"
event
was
expected
but
a
"
+
event
.
type
+
"
event
occurred
"
)
;
if
(
typeof
expected
.
title
!
=
"
undefined
"
)
{
ok
(
originalTargetIsHTMLDocument
"
originalTarget
for
last
"
+
event
.
type
+
"
event
not
an
HTMLDocument
"
)
;
is
(
event
.
originalTarget
.
title
expected
.
title
"
A
"
+
event
.
type
+
"
event
was
expected
for
page
"
+
expected
.
title
+
"
but
was
fired
for
page
"
+
event
.
originalTarget
.
title
)
;
}
if
(
typeof
expected
.
persisted
!
=
"
undefined
"
)
{
is
(
event
.
persisted
expected
.
persisted
"
The
persisted
property
of
the
"
+
event
.
type
+
"
event
on
page
"
+
event
.
originalTarget
.
location
+
"
had
an
unexpected
value
"
)
;
}
if
(
"
visibilityState
"
in
expected
)
{
is
(
event
.
originalTarget
.
visibilityState
expected
.
visibilityState
"
The
visibilityState
property
of
the
document
on
page
"
+
event
.
originalTarget
.
location
+
"
had
an
unexpected
value
"
)
;
}
if
(
"
hidden
"
in
expected
)
{
is
(
event
.
originalTarget
.
hidden
expected
.
hidden
"
The
hidden
property
of
the
document
on
page
"
+
event
.
originalTarget
.
location
+
"
had
an
unexpected
value
"
)
;
}
if
(
!
gExpectedEvents
.
length
)
{
waitForNextPaint
(
function
(
)
{
gFinalEvent
=
true
;
}
)
;
}
}
DocShellHelpersParent
.
eventListener
=
pageEventListener
;
function
finish
(
)
{
let
historyPurged
;
if
(
SpecialPowers
.
Services
.
appinfo
.
sessionHistoryInParent
)
{
let
history
=
TestWindow
.
getBrowser
(
)
.
browsingContext
?
.
sessionHistory
;
history
.
purgeHistory
(
history
.
count
)
;
historyPurged
=
Promise
.
resolve
(
)
;
}
else
{
historyPurged
=
SpecialPowers
.
spawn
(
TestWindow
.
getBrowser
(
)
[
]
(
)
=
>
{
let
history
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
.
legacySHistory
;
history
.
purgeHistory
(
history
.
count
)
;
}
)
;
}
if
(
typeof
gOrigMaxTotalViewers
!
=
"
undefined
"
)
{
Services
.
prefs
.
setIntPref
(
"
browser
.
sessionhistory
.
max_total_viewers
"
gOrigMaxTotalViewers
)
;
}
let
opener
=
window
.
opener
;
let
SimpleTest
=
opener
.
wrappedJSObject
.
SimpleTest
;
Services
.
ww
.
registerNotification
(
function
observer
(
subject
topic
)
{
if
(
topic
=
=
"
domwindowclosed
"
)
{
Services
.
ww
.
unregisterNotification
(
observer
)
;
SimpleTest
.
waitForFocus
(
SimpleTest
.
finish
opener
)
;
}
}
)
;
historyPurged
.
then
(
_
=
>
{
window
.
close
(
)
;
}
)
;
}
function
waitForTrue
(
fn
onWaitComplete
timeout
)
{
promiseTrue
(
fn
timeout
)
.
then
(
(
)
=
>
{
onWaitComplete
.
call
(
)
;
}
)
;
}
function
promiseTrue
(
fn
timeout
)
{
if
(
typeof
timeout
!
=
"
undefined
"
)
{
if
(
timeout
<
500
)
{
timeout
*
=
1000
;
}
}
let
intervalid
timeoutid
;
let
condition
=
new
Promise
(
resolve
=
>
{
intervalid
=
setInterval
(
async
(
)
=
>
{
if
(
await
fn
.
call
(
)
)
{
resolve
(
)
;
}
}
20
)
;
}
)
;
if
(
typeof
timeout
!
=
"
undefined
"
)
{
condition
=
Promise
.
race
(
[
condition
new
Promise
(
(
_
reject
)
=
>
{
timeoutid
=
setTimeout
(
(
)
=
>
{
reject
(
)
;
}
timeout
)
;
}
)
]
)
;
}
return
condition
.
finally
(
(
)
=
>
{
clearInterval
(
intervalid
)
;
}
)
.
then
(
(
)
=
>
{
clearTimeout
(
timeoutid
)
;
}
)
;
}
function
waitForNextPaint
(
cb
)
{
requestAnimationFrame
(
_
=
>
requestAnimationFrame
(
cb
)
)
;
}
function
promiseNextPaint
(
)
{
return
new
Promise
(
resolve
=
>
{
waitForNextPaint
(
resolve
)
;
}
)
;
}
function
enableBFCache
(
enable
)
{
if
(
typeof
gOrigMaxTotalViewers
=
=
"
undefined
"
)
{
gOrigMaxTotalViewers
=
Services
.
prefs
.
getIntPref
(
"
browser
.
sessionhistory
.
max_total_viewers
"
)
;
}
if
(
typeof
enable
=
=
"
boolean
"
)
{
if
(
enable
)
{
Services
.
prefs
.
setIntPref
(
"
browser
.
sessionhistory
.
max_total_viewers
"
-
1
)
;
}
else
{
Services
.
prefs
.
setIntPref
(
"
browser
.
sessionhistory
.
max_total_viewers
"
0
)
;
}
}
else
if
(
typeof
enable
=
=
"
number
"
)
{
Services
.
prefs
.
setIntPref
(
"
browser
.
sessionhistory
.
max_total_viewers
"
enable
)
;
}
}
function
getHttpRoot
(
)
{
var
location
=
window
.
location
.
href
;
location
=
getRootDirectory
(
location
)
;
var
jar
=
getJar
(
location
)
;
if
(
jar
!
=
null
)
{
if
(
gExtractedPath
=
=
null
)
{
var
resolved
=
extractJarToTmp
(
jar
)
;
gExtractedPath
=
resolved
.
path
;
}
}
else
{
return
null
;
}
return
"
file
:
/
/
"
+
gExtractedPath
+
"
/
"
;
}
function
getHttpUrl
(
filename
)
{
var
root
=
getHttpRoot
(
)
;
if
(
root
=
=
null
)
{
root
=
"
http
:
/
/
mochi
.
test
:
8888
/
chrome
/
docshell
/
test
/
chrome
/
"
;
}
return
root
+
filename
;
}
var
TestWindow
=
{
}
;
TestWindow
.
getWindow
=
function
(
)
{
return
document
.
getElementById
(
"
content
"
)
.
contentWindow
;
}
;
TestWindow
.
getBrowser
=
function
(
)
{
return
document
.
getElementById
(
"
content
"
)
;
}
;
TestWindow
.
getDocument
=
function
(
)
{
return
document
.
getElementById
(
"
content
"
)
.
contentDocument
;
}
;
