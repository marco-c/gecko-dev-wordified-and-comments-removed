"
use
strict
"
;
const
fs
=
require
(
"
fs
"
)
;
const
URL
=
"
https
:
/
/
searchfox
.
org
/
mozilla
-
central
/
source
/
"
;
const
HEADER
=
/
*
*
*
NOTE
:
Do
not
modify
this
file
by
hand
.
*
Content
was
generated
from
source
XPCOM
.
idl
files
.
*
/
;
function
ts_interface
(
iface
)
{
let
lines
=
[
]
;
let
base
=
iface
.
base
;
iface
.
class
=
iface
.
id
;
let
partial
=
iface
.
id
=
=
=
"
nsISupports
"
?
"
?
"
:
"
"
;
let
enums
=
iface
.
enums
.
map
(
e
=
>
typeof
{
iface
.
id
}
.
{
e
.
id
}
)
.
join
(
"
&
"
)
;
if
(
enums
)
{
base
+
=
Enums
<
{
enums
}
>
;
iface
.
class
+
=
{
enums
}
;
lines
.
push
(
"
}
/
/
global
\
n
"
)
;
lines
.
push
(
declare
namespace
{
iface
.
id
}
{
\
n
)
;
for
(
let
e
of
iface
.
enums
)
{
lines
.
push
(
enum
{
e
.
id
}
{
)
;
for
(
let
v
of
e
.
variants
)
{
lines
.
push
(
{
v
.
name
}
=
{
v
.
value
}
)
;
}
lines
.
push
(
"
}
\
n
"
)
;
}
lines
.
push
(
"
}
\
n
"
)
;
lines
.
push
(
"
declare
global
{
\
n
"
)
;
}
if
(
iface
.
callable
)
{
lines
.
push
(
type
{
iface
.
id
}
=
Callable
<
{
)
;
}
else
{
lines
.
push
(
interface
{
iface
.
id
}
{
base
?
extends
{
base
}
:
"
"
}
{
)
;
}
for
(
let
c
of
iface
.
consts
)
{
lines
.
push
(
readonly
{
c
.
name
}
:
{
c
.
value
}
;
)
;
}
if
(
iface
.
consts
.
length
&
&
iface
.
members
.
length
)
{
lines
.
push
(
"
"
)
;
}
for
(
let
m
of
iface
.
members
)
{
if
(
!
m
.
args
)
{
lines
.
push
(
{
m
.
readonly
?
"
readonly
"
:
"
"
}
{
m
.
name
}
:
{
m
.
type
}
;
)
;
}
else
{
let
args
=
[
]
;
for
(
let
arg
of
m
.
args
)
{
let
type
=
arg
.
name
=
=
=
m
.
iid_is
?
"
T
"
:
arg
.
type
;
args
.
push
(
{
arg
.
name
}
{
arg
.
optional
?
"
?
"
:
"
"
}
:
{
type
}
)
;
}
let
type
=
(
{
args
.
join
(
"
"
)
}
)
:
{
m
.
type
}
;
let
signature
=
m
.
iid_is
?
<
T
extends
nsIID
>
{
type
}
<
T
>
:
type
;
lines
.
push
(
{
m
.
name
}
{
partial
}
{
signature
}
;
)
;
}
}
lines
.
push
(
iface
.
callable
?
"
}
>
\
n
"
:
"
}
\
n
"
)
;
return
lines
;
}
function
ts_link
(
dir
files
)
{
let
lines
=
[
HEADER
"
declare
global
{
\
n
"
]
;
let
typedefs
=
{
}
;
let
iids
=
[
]
;
for
(
let
djson
of
files
)
{
let
modules
=
JSON
.
parse
(
fs
.
readFileSync
(
{
dir
}
/
{
djson
}
"
utf8
"
)
)
;
for
(
let
mod
of
modules
)
{
lines
.
push
(
/
/
{
URL
}
{
mod
.
path
}
\
n
)
;
Object
.
assign
(
typedefs
Object
.
fromEntries
(
mod
.
typedefs
?
?
[
]
)
)
;
for
(
let
iface
of
mod
.
interfaces
?
?
[
]
)
{
if
(
iface
.
id
!
=
=
"
nsIXPCComponents_Interfaces
"
)
{
lines
=
lines
.
concat
(
ts_interface
(
iface
)
)
;
iids
.
push
(
{
iface
.
id
}
:
nsJSIID
<
{
iface
.
class
}
>
;
)
;
}
}
}
}
lines
.
push
(
"
interface
nsIXPCComponents_Interfaces
{
"
)
;
lines
=
lines
.
concat
(
iids
)
;
lines
.
push
(
"
}
\
n
"
)
;
lines
.
push
(
"
}
/
/
global
\
n
"
)
;
lines
.
push
(
"
/
/
Typedefs
from
xpidl
.
"
)
;
for
(
let
[
id
type
]
of
Object
.
entries
(
typedefs
)
.
sort
(
)
)
{
lines
.
push
(
type
{
id
}
=
{
type
}
;
)
;
}
lines
.
push
(
"
"
)
;
lines
.
push
(
fs
.
readFileSync
(
{
__dirname
}
/
config
/
intrinsics
.
d
.
ts
"
utf8
"
)
)
;
return
lines
;
}
module
.
exports
=
{
ts_link
}
;
function
main
(
lib_dts
djson_dir
.
.
.
djson_files
)
{
let
dts
=
ts_link
(
djson_dir
djson_files
)
.
join
(
"
\
n
"
)
;
console
.
log
(
[
INFO
]
{
lib_dts
}
(
{
dts
.
length
.
toLocaleString
(
)
}
bytes
)
)
;
fs
.
writeFileSync
(
lib_dts
dts
)
;
}
if
(
require
.
main
=
=
=
module
)
{
main
(
.
.
.
process
.
argv
.
slice
(
2
)
)
;
}
