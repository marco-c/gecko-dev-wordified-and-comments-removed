#
ifndef
memory_profiler_CompactTraceTable_h
#
define
memory_profiler_CompactTraceTable_h
#
include
"
UncensoredAllocator
.
h
"
#
include
<
functional
>
#
include
<
utility
>
#
include
"
mozilla
/
HashFunctions
.
h
"
namespace
mozilla
{
struct
TrieNode
final
{
uint32_t
parentIdx
;
uint32_t
nameIdx
;
bool
operator
=
=
(
const
TrieNode
t
)
const
{
return
parentIdx
=
=
t
.
parentIdx
&
&
nameIdx
=
=
t
.
nameIdx
;
}
}
;
}
namespace
std
{
template
<
>
struct
hash
<
mozilla
:
:
TrieNode
>
{
size_t
operator
(
)
(
const
mozilla
:
:
TrieNode
&
v
)
const
{
uint64_t
k
=
static_cast
<
uint64_t
>
(
v
.
parentIdx
)
<
<
32
|
v
.
nameIdx
;
return
std
:
:
hash
<
uint64_t
>
(
)
(
k
)
;
}
}
;
template
<
>
struct
hash
<
mozilla
:
:
u_string
>
{
size_t
operator
(
)
(
const
mozilla
:
:
u_string
&
v
)
const
{
return
mozilla
:
:
HashString
(
v
.
c_str
(
)
)
;
}
}
;
}
namespace
mozilla
{
template
<
typename
T
>
class
NodeIndexMap
final
{
public
:
uint32_t
Insert
(
const
T
&
e
)
{
auto
i
=
mMap
.
insert
(
std
:
:
make_pair
(
e
mMap
.
size
(
)
)
)
;
return
i
.
first
-
>
second
;
}
u_vector
<
T
>
Serialize
(
)
const
{
u_vector
<
T
>
v
(
mMap
.
size
(
)
)
;
for
(
auto
i
:
mMap
)
{
v
[
i
.
second
]
=
i
.
first
;
}
return
v
;
}
uint32_t
Size
(
)
const
{
return
mMap
.
size
(
)
;
}
void
Clear
(
)
{
mMap
.
clear
(
)
;
}
private
:
u_unordered_map
<
T
uint32_t
>
mMap
;
}
;
class
CompactTraceTable
final
{
public
:
CompactTraceTable
(
)
{
mNames
.
Insert
(
"
(
unknown
)
"
)
;
mTraces
.
Insert
(
TrieNode
{
0
0
}
)
;
}
u_vector
<
u_string
>
GetNames
(
)
const
{
return
mNames
.
Serialize
(
)
;
}
u_vector
<
TrieNode
>
GetTraces
(
)
const
{
return
mTraces
.
Serialize
(
)
;
}
uint32_t
Insert
(
const
u_vector
<
u_string
>
&
aRawStacktrace
)
{
uint32_t
parent
=
0
;
for
(
auto
&
frame
:
aRawStacktrace
)
{
parent
=
mTraces
.
Insert
(
TrieNode
{
parent
mNames
.
Insert
(
frame
)
}
)
;
}
return
parent
;
}
void
Reset
(
)
{
mNames
.
Clear
(
)
;
mTraces
.
Clear
(
)
;
}
private
:
NodeIndexMap
<
u_string
>
mNames
;
NodeIndexMap
<
TrieNode
>
mTraces
;
}
;
}
#
endif
