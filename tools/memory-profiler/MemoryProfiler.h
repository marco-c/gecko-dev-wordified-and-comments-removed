#
ifndef
tools_profiler_MemoryProfiler_h
#
define
tools_profiler_MemoryProfiler_h
#
include
"
nsIMemoryProfiler
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
CompactTraceTable
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
prlock
.
h
"
#
define
MEMORY_PROFILER_CID
\
{
0xf976eaa2
0xcc1f
0x47ee
\
{
0x81
0x29
0xb8
0x26
0x2a
0x3d
0xb6
0xb2
}
}
#
define
MEMORY_PROFILER_CONTRACT_ID
"
mozilla
.
org
/
tools
/
memory
-
profiler
;
1
"
struct
PRLock
;
namespace
mozilla
{
class
NativeProfilerImpl
;
class
GCHeapProfilerImpl
;
struct
ProfilerForJSContext
{
ProfilerForJSContext
(
)
:
mProfiler
(
nullptr
)
mEnabled
(
false
)
{
}
GCHeapProfilerImpl
*
mProfiler
;
bool
mEnabled
;
}
;
using
JSContextProfilerMap
=
nsDataHashtable
<
nsClearingPtrHashKey
<
JSContext
>
ProfilerForJSContext
>
;
class
MemoryProfiler
final
:
public
nsIMemoryProfiler
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIMEMORYPROFILER
private
:
static
void
InitOnce
(
)
;
~
MemoryProfiler
(
)
{
}
static
PRLock
*
sLock
;
static
uint32_t
sProfileContextCount
;
static
StaticAutoPtr
<
NativeProfilerImpl
>
sNativeProfiler
;
static
StaticAutoPtr
<
JSContextProfilerMap
>
sJSContextProfilerMap
;
static
TimeStamp
sStartTime
;
}
;
struct
AllocEvent
{
TimeStamp
mTimestamp
;
uint32_t
mTraceIdx
;
int32_t
mSize
;
AllocEvent
(
uint32_t
aTraceIdx
int32_t
aSize
TimeStamp
aTimestamp
)
:
mTimestamp
(
aTimestamp
)
mTraceIdx
(
aTraceIdx
)
mSize
(
aSize
)
{
}
}
;
struct
AllocEntry
{
uint32_t
mEventIdx
:
31
;
bool
mMarked
:
1
;
AllocEntry
(
)
:
mEventIdx
(
0
)
mMarked
(
false
)
{
}
explicit
AllocEntry
(
int
aEventIdx
)
:
mEventIdx
(
aEventIdx
)
mMarked
(
false
)
{
}
}
;
using
AllocMap
=
nsDataHashtable
<
nsClearingVoidPtrHashKey
AllocEntry
>
;
class
ProfilerImpl
{
public
:
static
nsTArray
<
nsCString
>
GetStacktrace
(
)
;
static
double
DRandom
(
)
;
ProfilerImpl
(
)
;
virtual
nsTArray
<
nsCString
>
GetNames
(
)
const
=
0
;
virtual
nsTArray
<
TrieNode
>
GetTraces
(
)
const
=
0
;
virtual
const
nsTArray
<
AllocEvent
>
&
GetEvents
(
)
const
=
0
;
protected
:
size_t
AddBytesSampled
(
uint32_t
aBytes
)
;
uint32_t
mSampleSize
;
private
:
uint32_t
mRemainingBytes
;
double
mLog1minusP
;
}
;
class
AutoMPLock
{
public
:
explicit
AutoMPLock
(
PRLock
*
aLock
)
{
MOZ_ASSERT
(
aLock
)
;
mLock
=
aLock
;
PR_Lock
(
mLock
)
;
}
~
AutoMPLock
(
)
{
PR_Unlock
(
mLock
)
;
}
private
:
PRLock
*
mLock
;
}
;
}
#
endif
