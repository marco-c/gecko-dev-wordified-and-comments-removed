#
include
<
assert
.
h
>
#
include
<
getopt
.
h
>
#
include
<
math
.
h
>
#
include
<
signal
.
h
>
#
include
<
stdarg
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
unistd
.
h
>
#
include
<
algorithm
>
#
include
<
numeric
>
#
include
<
vector
>
static
const
char
*
gArgv0
;
static
void
Abort
(
const
char
*
aFormat
.
.
.
)
{
va_list
vargs
;
va_start
(
vargs
aFormat
)
;
fprintf
(
stderr
"
%
s
:
"
gArgv0
)
;
vfprintf
(
stderr
aFormat
vargs
)
;
fprintf
(
stderr
"
\
n
"
)
;
va_end
(
vargs
)
;
exit
(
1
)
;
}
static
void
CmdLineAbort
(
const
char
*
aMsg
)
{
if
(
aMsg
)
{
fprintf
(
stderr
"
%
s
:
%
s
\
n
"
gArgv0
aMsg
)
;
}
fprintf
(
stderr
"
Use
-
-
help
for
more
information
.
\
n
"
)
;
exit
(
1
)
;
}
static
const
double
kUnsupported_j
=
-
1
.
0
;
static
void
PrintAndFlush
(
const
char
*
aFormat
.
.
.
)
{
va_list
vargs
;
va_start
(
vargs
aFormat
)
;
vfprintf
(
stdout
aFormat
vargs
)
;
va_end
(
vargs
)
;
fflush
(
stdout
)
;
}
#
if
defined
(
__APPLE__
)
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
sysctl
.
h
>
#
define
dgPowerStat
17
#
define
CPU_RTIME_BINS
(
12
)
#
define
CPU_ITIME_BINS
(
CPU_RTIME_BINS
)
typedef
struct
{
uint64_t
caperf
;
uint64_t
cmperf
;
uint64_t
ccres
[
6
]
;
uint64_t
crtimes
[
CPU_RTIME_BINS
]
;
uint64_t
citimes
[
CPU_ITIME_BINS
]
;
uint64_t
crtime_total
;
uint64_t
citime_total
;
uint64_t
cpu_idle_exits
;
uint64_t
cpu_insns
;
uint64_t
cpu_ucc
;
uint64_t
cpu_urc
;
#
if
DIAG_ALL_PMCS
uint64_t
gpmcs
[
4
]
;
#
endif
}
core_energy_stat_t
;
typedef
struct
{
uint64_t
pkes_version
;
uint64_t
pkg_cres
[
2
]
[
7
]
;
uint64_t
pkg_power_unit
;
uint64_t
pkg_energy
;
uint64_t
pp0_energy
;
uint64_t
pp1_energy
;
uint64_t
ddr_energy
;
uint64_t
llc_flushed_cycles
;
uint64_t
ring_ratio_instantaneous
;
uint64_t
IA_frequency_clipping_cause
;
uint64_t
GT_frequency_clipping_cause
;
uint64_t
pkg_idle_exits
;
uint64_t
pkg_rtimes
[
CPU_RTIME_BINS
]
;
uint64_t
pkg_itimes
[
CPU_ITIME_BINS
]
;
uint64_t
mbus_delay_time
;
uint64_t
mint_delay_time
;
uint32_t
ncpus
;
core_energy_stat_t
cest
[
]
;
}
pkg_energy_statistics_t
;
static
int
diagCall64
(
uint64_t
aMode
void
*
aBuf
)
{
#
ifdef
__x86_64__
static
const
uint64_t
diagCallNum
=
0x4000001
;
uint64_t
rv
;
__asm__
__volatile__
(
"
syscall
"
:
"
=
a
"
(
rv
)
:
"
0
"
(
diagCallNum
)
"
D
"
(
aMode
)
"
S
"
(
aBuf
)
:
"
rcx
"
"
r11
"
"
cc
"
"
memory
"
)
;
return
rv
;
#
else
#
error
Sorry
only
x86
-
64
is
supported
#
endif
}
static
void
diagCall64_dgPowerStat
(
pkg_energy_statistics_t
*
aPkes
)
{
static
const
uint64_t
supported_version
=
1
;
aPkes
-
>
pkes_version
=
supported_version
-
1
;
if
(
diagCall64
(
dgPowerStat
aPkes
)
!
=
1
)
{
Abort
(
"
diagCall64
(
)
failed
"
)
;
}
if
(
aPkes
-
>
pkes_version
!
=
1
)
{
Abort
(
"
unexpected
pkes_version
:
%
llu
"
aPkes
-
>
pkes_version
)
;
}
}
class
RAPL
{
bool
mIsGpuSupported
;
bool
mIsRamSupported
;
bool
mHasRamUnitsQuirk
;
static
const
double
kQuirkyRamJoulesPerTick
;
uint64_t
mPrevPkgTicks
;
uint64_t
mPrevPp0Ticks
;
uint64_t
mPrevPp1Ticks
;
uint64_t
mPrevDdrTicks
;
pkg_energy_statistics_t
*
mPkes
;
public
:
RAPL
(
)
:
mHasRamUnitsQuirk
(
false
)
{
int
cpuModel
;
size_t
size
=
sizeof
(
cpuModel
)
;
if
(
sysctlbyname
(
"
machdep
.
cpu
.
model
"
&
cpuModel
&
size
NULL
0
)
!
=
0
)
{
Abort
(
"
sysctlbyname
(
\
"
machdep
.
cpu
.
model
\
"
)
failed
"
)
;
}
switch
(
cpuModel
)
{
case
60
:
case
69
:
case
70
:
case
61
:
mIsGpuSupported
=
true
;
mIsRamSupported
=
true
;
break
;
case
42
:
case
58
:
mIsGpuSupported
=
true
;
mIsRamSupported
=
false
;
break
;
case
63
:
mHasRamUnitsQuirk
=
true
;
case
45
:
case
62
:
mIsGpuSupported
=
false
;
mIsRamSupported
=
true
;
break
;
default
:
Abort
(
"
unknown
CPU
model
:
%
d
"
cpuModel
)
;
break
;
}
int
logicalcpu_max
;
size
=
sizeof
(
logicalcpu_max
)
;
if
(
sysctlbyname
(
"
hw
.
logicalcpu_max
"
&
logicalcpu_max
&
size
NULL
0
)
!
=
0
)
{
Abort
(
"
sysctlbyname
(
\
"
hw
.
logicalcpu_max
\
"
)
failed
"
)
;
}
size_t
pkesSize
=
sizeof
(
pkg_energy_statistics_t
)
+
logicalcpu_max
*
sizeof
(
core_energy_stat_t
)
+
logicalcpu_max
*
1024
;
mPkes
=
(
pkg_energy_statistics_t
*
)
malloc
(
pkesSize
)
;
if
(
!
mPkes
)
{
Abort
(
"
malloc
(
)
failed
"
)
;
}
double
dummy1
dummy2
dummy3
dummy4
;
EnergyEstimates
(
dummy1
dummy2
dummy3
dummy4
)
;
}
~
RAPL
(
)
{
free
(
mPkes
)
;
}
static
double
Joules
(
uint64_t
aTicks
double
aJoulesPerTick
)
{
return
double
(
aTicks
)
*
aJoulesPerTick
;
}
void
EnergyEstimates
(
double
&
aPkg_J
double
&
aCores_J
double
&
aGpu_J
double
&
aRam_J
)
{
diagCall64_dgPowerStat
(
mPkes
)
;
uint32_t
energyStatusUnits
=
(
mPkes
-
>
pkg_power_unit
>
>
8
)
&
0x1f
;
double
joulesPerTick
=
(
(
double
)
1
/
(
1
<
<
energyStatusUnits
)
)
;
aPkg_J
=
Joules
(
mPkes
-
>
pkg_energy
-
mPrevPkgTicks
joulesPerTick
)
;
aCores_J
=
Joules
(
mPkes
-
>
pp0_energy
-
mPrevPp0Ticks
joulesPerTick
)
;
aGpu_J
=
mIsGpuSupported
?
Joules
(
mPkes
-
>
pp1_energy
-
mPrevPp1Ticks
joulesPerTick
)
:
-
kUnsupported_j
;
aRam_J
=
mIsRamSupported
?
Joules
(
mPkes
-
>
ddr_energy
-
mPrevDdrTicks
mHasRamUnitsQuirk
?
kQuirkyRamJoulesPerTick
:
joulesPerTick
)
:
-
kUnsupported_j
;
mPrevPkgTicks
=
mPkes
-
>
pkg_energy
;
mPrevPp0Ticks
=
mPkes
-
>
pp0_energy
;
if
(
mIsGpuSupported
)
{
mPrevPp1Ticks
=
mPkes
-
>
pp1_energy
;
}
if
(
mIsRamSupported
)
{
mPrevDdrTicks
=
mPkes
-
>
ddr_energy
;
}
}
}
;
const
double
RAPL
:
:
kQuirkyRamJoulesPerTick
=
(
double
)
1
/
65536
;
#
elif
defined
(
__linux__
)
#
include
<
linux
/
perf_event
.
h
>
#
include
<
sys
/
syscall
.
h
>
static
int
perf_event_open
(
struct
perf_event_attr
*
aAttr
pid_t
aPid
int
aCpu
int
aGroupFd
unsigned
long
aFlags
)
{
return
syscall
(
__NR_perf_event_open
aAttr
aPid
aCpu
aGroupFd
aFlags
)
;
}
template
<
typename
T
>
static
bool
ReadValueFromPowerFile
(
const
char
*
aStr1
const
char
*
aStr2
const
char
*
aStr3
const
char
*
aScanfString
T
*
aOut
)
{
char
filename
[
256
]
;
sprintf
(
filename
"
/
sys
/
bus
/
event_source
/
devices
/
power
/
%
s
%
s
%
s
"
aStr1
aStr2
aStr3
)
;
FILE
*
fp
=
fopen
(
filename
"
r
"
)
;
if
(
!
fp
)
{
return
false
;
}
if
(
fscanf
(
fp
aScanfString
aOut
)
!
=
1
)
{
Abort
(
"
fscanf
(
)
failed
"
)
;
}
fclose
(
fp
)
;
return
true
;
}
class
Domain
{
bool
mIsSupported
;
double
mJoulesPerTick
;
int
mFd
;
double
mPrevTicks
;
public
:
enum
IsOptional
{
Optional
NonOptional
}
;
Domain
(
const
char
*
aName
uint32_t
aType
IsOptional
aOptional
=
NonOptional
)
{
uint64_t
config
;
if
(
!
ReadValueFromPowerFile
(
"
events
/
energy
-
"
aName
"
"
"
event
=
%
llx
"
&
config
)
)
{
if
(
aOptional
=
=
NonOptional
)
{
Abort
(
"
failed
to
open
file
for
non
-
optional
domain
'
%
s
'
"
aName
)
;
}
mIsSupported
=
false
;
return
;
}
mIsSupported
=
true
;
ReadValueFromPowerFile
(
"
events
/
energy
-
"
aName
"
.
scale
"
"
%
lf
"
&
mJoulesPerTick
)
;
char
unit
[
128
]
;
ReadValueFromPowerFile
(
"
events
/
energy
-
"
aName
"
.
unit
"
"
%
127s
"
unit
)
;
if
(
strcmp
(
unit
"
Joules
"
)
!
=
0
)
{
Abort
(
"
unexpected
unit
'
%
s
'
in
.
unit
file
"
unit
)
;
}
struct
perf_event_attr
attr
;
memset
(
&
attr
0
sizeof
(
attr
)
)
;
attr
.
type
=
aType
;
attr
.
size
=
uint32_t
(
sizeof
(
attr
)
)
;
attr
.
config
=
config
;
mFd
=
perf_event_open
(
&
attr
-
1
0
-
1
0
)
;
if
(
mFd
<
0
)
{
Abort
(
"
perf_event_open
(
)
failed
\
n
"
"
Did
you
run
as
root
or
"
"
set
/
proc
/
sys
/
kernel
/
perf_event_paranoid
to
0
?
"
)
;
}
mPrevTicks
=
0
;
}
~
Domain
(
)
{
if
(
mIsSupported
)
{
close
(
mFd
)
;
}
}
double
EnergyEstimate
(
)
{
if
(
!
mIsSupported
)
{
return
-
kUnsupported_j
;
}
uint64_t
thisTicks
;
if
(
read
(
mFd
&
thisTicks
sizeof
(
uint64_t
)
)
!
=
sizeof
(
uint64_t
)
)
{
Abort
(
"
read
(
)
failed
"
)
;
}
uint64_t
ticks
=
thisTicks
-
mPrevTicks
;
mPrevTicks
=
thisTicks
;
double
joules
=
ticks
*
mJoulesPerTick
;
return
joules
;
}
}
;
class
RAPL
{
Domain
*
mPkg
;
Domain
*
mCores
;
Domain
*
mGpu
;
Domain
*
mRam
;
public
:
RAPL
(
)
{
uint32_t
type
;
ReadValueFromPowerFile
(
"
type
"
"
"
"
"
"
%
u
"
&
type
)
;
mPkg
=
new
Domain
(
"
pkg
"
type
)
;
mCores
=
new
Domain
(
"
cores
"
type
)
;
mGpu
=
new
Domain
(
"
gpu
"
type
Domain
:
:
Optional
)
;
mRam
=
new
Domain
(
"
ram
"
type
Domain
:
:
Optional
)
;
if
(
!
mPkg
|
|
!
mCores
|
|
!
mGpu
|
|
!
mRam
)
{
Abort
(
"
new
Domain
(
)
failed
"
)
;
}
}
~
RAPL
(
)
{
delete
mPkg
;
delete
mCores
;
delete
mGpu
;
delete
mRam
;
}
void
EnergyEstimates
(
double
&
aPkg_J
double
&
aCores_J
double
&
aGpu_J
double
&
aRam_J
)
{
aPkg_J
=
mPkg
-
>
EnergyEstimate
(
)
;
aCores_J
=
mCores
-
>
EnergyEstimate
(
)
;
aGpu_J
=
mGpu
-
>
EnergyEstimate
(
)
;
aRam_J
=
mRam
-
>
EnergyEstimate
(
)
;
}
}
;
#
else
#
error
Sorry
this
platform
is
not
supported
#
endif
static
double
gSampleInterval_sec
;
static
RAPL
*
gRapl
;
static
std
:
:
vector
<
double
>
gTotals_W
;
static
double
JoulesToWatts
(
double
aJoules
)
{
return
aJoules
/
gSampleInterval_sec
;
}
static
void
NormalizeAndPrintAsWatts
(
char
*
aBuf
double
&
aValue_J
)
{
if
(
aValue_J
=
=
kUnsupported_j
)
{
aValue_J
=
0
;
sprintf
(
aBuf
"
%
s
"
"
n
/
a
"
)
;
}
else
{
sprintf
(
aBuf
"
%
5
.
2f
"
JoulesToWatts
(
aValue_J
)
)
;
}
}
static
void
SigAlrmHandler
(
int
aSigNum
siginfo_t
*
aInfo
void
*
aContext
)
{
static
int
sampleNumber
=
1
;
double
pkg_J
cores_J
gpu_J
ram_J
;
gRapl
-
>
EnergyEstimates
(
pkg_J
cores_J
gpu_J
ram_J
)
;
assert
(
pkg_J
!
=
kUnsupported_j
)
;
assert
(
cores_J
!
=
kUnsupported_j
)
;
static
const
size_t
kNumStrLen
=
16
;
static
char
pkgStr
[
kNumStrLen
]
coresStr
[
kNumStrLen
]
gpuStr
[
kNumStrLen
]
ramStr
[
kNumStrLen
]
;
NormalizeAndPrintAsWatts
(
pkgStr
pkg_J
)
;
NormalizeAndPrintAsWatts
(
coresStr
cores_J
)
;
NormalizeAndPrintAsWatts
(
gpuStr
gpu_J
)
;
NormalizeAndPrintAsWatts
(
ramStr
ram_J
)
;
assert
(
pkg_J
>
=
cores_J
+
gpu_J
)
;
char
otherStr
[
kNumStrLen
]
;
double
other_J
=
pkg_J
-
cores_J
-
gpu_J
;
NormalizeAndPrintAsWatts
(
otherStr
other_J
)
;
char
totalStr
[
kNumStrLen
]
;
double
total_J
=
pkg_J
+
ram_J
;
NormalizeAndPrintAsWatts
(
totalStr
total_J
)
;
gTotals_W
.
push_back
(
JoulesToWatts
(
total_J
)
)
;
PrintAndFlush
(
"
#
%
02d
%
s
W
=
%
s
(
%
s
+
%
s
+
%
s
)
+
%
s
W
\
n
"
sampleNumber
+
+
totalStr
pkgStr
coresStr
gpuStr
otherStr
ramStr
)
;
}
static
void
Finish
(
)
{
size_t
n
=
gTotals_W
.
size
(
)
;
double
time
=
n
*
gSampleInterval_sec
;
printf
(
"
\
n
"
)
;
printf
(
"
%
d
sample
%
s
taken
over
a
period
of
%
.
3f
second
%
s
\
n
"
int
(
n
)
n
=
=
1
?
"
"
:
"
s
"
n
*
gSampleInterval_sec
time
=
=
1
.
0
?
"
"
:
"
s
"
)
;
if
(
n
=
=
0
|
|
n
=
=
1
)
{
exit
(
0
)
;
}
double
sum
=
std
:
:
accumulate
(
gTotals_W
.
begin
(
)
gTotals_W
.
end
(
)
0
.
0
)
;
double
mean
=
sum
/
n
;
double
sumOfSquaredDeviations
=
0
;
for
(
auto
iter
=
gTotals_W
.
begin
(
)
;
iter
!
=
gTotals_W
.
end
(
)
;
+
+
iter
)
{
double
deviation
=
(
*
iter
-
mean
)
;
sumOfSquaredDeviations
+
=
deviation
*
deviation
;
}
double
popStdDev
=
sqrt
(
sumOfSquaredDeviations
/
n
)
;
std
:
:
sort
(
gTotals_W
.
begin
(
)
gTotals_W
.
end
(
)
)
;
printf
(
"
\
n
"
)
;
printf
(
"
Distribution
of
'
total
'
values
:
\
n
"
)
;
printf
(
"
mean
=
%
5
.
2f
W
\
n
"
mean
)
;
printf
(
"
std
dev
=
%
5
.
2f
W
\
n
"
popStdDev
)
;
printf
(
"
0th
percentile
=
%
5
.
2f
W
(
min
)
\
n
"
gTotals_W
[
0
]
)
;
printf
(
"
5th
percentile
=
%
5
.
2f
W
\
n
"
gTotals_W
[
ceil
(
0
.
05
*
n
)
-
1
]
)
;
printf
(
"
25th
percentile
=
%
5
.
2f
W
\
n
"
gTotals_W
[
ceil
(
0
.
25
*
n
)
-
1
]
)
;
printf
(
"
50th
percentile
=
%
5
.
2f
W
\
n
"
gTotals_W
[
ceil
(
0
.
50
*
n
)
-
1
]
)
;
printf
(
"
75th
percentile
=
%
5
.
2f
W
\
n
"
gTotals_W
[
ceil
(
0
.
75
*
n
)
-
1
]
)
;
printf
(
"
95th
percentile
=
%
5
.
2f
W
\
n
"
gTotals_W
[
ceil
(
0
.
95
*
n
)
-
1
]
)
;
printf
(
"
100th
percentile
=
%
5
.
2f
W
(
max
)
\
n
"
gTotals_W
[
n
-
1
]
)
;
exit
(
0
)
;
}
static
void
SigIntHandler
(
int
aSigNum
siginfo_t
*
aInfo
void
*
aContext
)
{
Finish
(
)
;
}
static
void
PrintUsage
(
)
{
printf
(
"
usage
:
rapl
[
options
]
\
n
"
"
\
n
"
"
Options
:
\
n
"
"
\
n
"
"
-
h
-
-
help
show
this
message
\
n
"
"
-
i
-
-
sample
-
interval
<
N
>
sample
every
N
ms
[
default
=
1000
]
\
n
"
"
-
n
-
-
sample
-
count
<
N
>
get
N
samples
(
0
means
unlimited
)
[
default
=
0
]
\
n
"
"
\
n
"
#
if
defined
(
__APPLE__
)
"
On
Mac
this
program
can
be
run
by
any
user
.
\
n
"
#
elif
defined
(
__linux__
)
"
On
Linux
this
program
can
only
be
run
by
the
super
-
user
unless
the
contents
\
n
"
"
of
/
proc
/
sys
/
kernel
/
perf_event_paranoid
is
set
to
0
or
lower
.
\
n
"
#
else
#
error
Sorry
this
platform
is
not
supported
#
endif
"
\
n
"
)
;
}
int
main
(
int
argc
char
*
*
argv
)
{
gArgv0
=
argv
[
0
]
;
int
sampleInterval_msec
=
1000
;
int
sampleCount
=
0
;
struct
option
longOptions
[
]
=
{
{
"
help
"
no_argument
NULL
'
h
'
}
{
"
sample
-
interval
"
required_argument
NULL
'
i
'
}
{
"
sample
-
count
"
required_argument
NULL
'
n
'
}
{
NULL
0
NULL
0
}
}
;
const
char
*
shortOptions
=
"
hi
:
n
:
"
;
int
c
;
char
*
endPtr
;
while
(
(
c
=
getopt_long
(
argc
argv
shortOptions
longOptions
NULL
)
)
!
=
-
1
)
{
switch
(
c
)
{
case
'
h
'
:
PrintUsage
(
)
;
exit
(
0
)
;
case
'
i
'
:
sampleInterval_msec
=
strtol
(
optarg
&
endPtr
10
)
;
if
(
*
endPtr
)
{
CmdLineAbort
(
"
sample
interval
is
not
an
integer
"
)
;
}
if
(
sampleInterval_msec
<
1
|
|
sampleInterval_msec
>
3600000
)
{
CmdLineAbort
(
"
sample
interval
must
be
in
the
range
1
.
.
3600000
ms
"
)
;
}
break
;
case
'
n
'
:
sampleCount
=
strtol
(
optarg
&
endPtr
10
)
;
if
(
*
endPtr
)
{
CmdLineAbort
(
"
sample
count
is
not
an
integer
"
)
;
}
if
(
sampleCount
<
0
|
|
sampleCount
>
1000000
)
{
CmdLineAbort
(
"
sample
count
must
be
in
the
range
0
.
.
1000000
"
)
;
}
break
;
default
:
CmdLineAbort
(
NULL
)
;
}
}
if
(
sampleInterval_msec
<
50
)
{
fprintf
(
stderr
"
\
nWARNING
:
sample
intervals
<
50
ms
are
likely
to
produce
"
"
inaccurate
estimates
\
n
\
n
"
)
;
}
gSampleInterval_sec
=
double
(
sampleInterval_msec
)
/
1000
;
gRapl
=
new
RAPL
(
)
;
if
(
!
gRapl
)
{
Abort
(
"
new
RAPL
(
)
failed
"
)
;
}
struct
sigaction
sa
;
memset
(
&
sa
0
sizeof
(
sa
)
)
;
sa
.
sa_flags
=
SA_RESTART
|
SA_SIGINFO
;
if
(
sigemptyset
(
&
sa
.
sa_mask
)
<
0
)
{
Abort
(
"
sigemptyset
(
)
failed
"
)
;
}
sa
.
sa_sigaction
=
SigAlrmHandler
;
if
(
sigaction
(
SIGALRM
&
sa
NULL
)
<
0
)
{
Abort
(
"
sigaction
(
SIGALRM
)
failed
"
)
;
}
sa
.
sa_sigaction
=
SigIntHandler
;
if
(
sigaction
(
SIGINT
&
sa
NULL
)
<
0
)
{
Abort
(
"
sigaction
(
SIGINT
)
failed
"
)
;
}
struct
itimerval
timer
;
timer
.
it_interval
.
tv_sec
=
sampleInterval_msec
/
1000
;
timer
.
it_interval
.
tv_usec
=
(
sampleInterval_msec
%
1000
)
*
1000
;
timer
.
it_value
=
timer
.
it_interval
;
if
(
setitimer
(
ITIMER_REAL
&
timer
NULL
)
<
0
)
{
Abort
(
"
setitimer
(
)
failed
"
)
;
}
PrintAndFlush
(
"
total
W
=
_pkg_
(
cores
+
_gpu_
+
other
)
+
_ram_
W
\
n
"
)
;
if
(
sampleCount
=
=
0
)
{
while
(
true
)
{
pause
(
)
;
}
}
else
{
for
(
int
i
=
0
;
i
<
sampleCount
;
i
+
+
)
{
pause
(
)
;
}
}
Finish
(
)
;
return
0
;
}
