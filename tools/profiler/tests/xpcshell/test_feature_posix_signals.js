ChromeUtils
.
defineESModuleGetters
(
this
{
Downloads
:
"
resource
:
/
/
gre
/
modules
/
Downloads
.
sys
.
mjs
"
FileUtils
:
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
sys
.
mjs
"
BrowserTestUtils
:
"
resource
:
/
/
testing
-
common
/
BrowserTestUtils
.
sys
.
mjs
"
}
)
;
const
{
ctypes
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
sys
.
mjs
"
)
;
function
openLibrary
(
names
)
{
for
(
const
name
of
names
)
{
try
{
return
ctypes
.
open
(
name
)
;
}
catch
(
e
)
{
}
}
return
undefined
;
}
function
raiseSignal
(
pid
sig
)
{
try
{
const
libc
=
openLibrary
(
[
"
libc
.
so
.
6
"
"
libc
.
so
"
"
libc
.
dylib
"
"
libSystem
.
B
.
dylib
"
]
)
;
if
(
!
libc
)
{
info
(
"
Failed
to
open
any
libc
shared
object
"
)
;
return
{
ok
:
false
}
;
}
const
kill
=
libc
.
declare
(
"
kill
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
int32_t
ctypes
.
int
)
;
let
kres
=
kill
(
pid
sig
)
;
if
(
kres
!
=
0
)
{
info
(
Kill
returned
a
non
-
zero
result
{
kres
}
.
)
;
return
{
ok
:
false
}
;
}
libc
.
close
(
)
;
}
catch
(
e
)
{
info
(
Exception
{
e
}
thrown
while
trying
to
call
kill
)
;
return
{
ok
:
false
}
;
}
return
{
ok
:
true
}
;
}
async
function
waitUntilProfilerStopped
(
interval
=
1000
maxTries
=
100
)
{
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
Services
.
profiler
.
IsActive
(
)
"
the
profiler
should
be
inactive
"
interval
maxTries
)
;
}
async
function
cleanupAfterTest
(
)
{
let
profile
=
FileUtils
.
File
(
await
Downloads
.
getSystemDownloadsDirectory
(
)
)
;
let
pid
=
Services
.
appinfo
.
processID
;
profile
.
append
(
profile_0_
{
pid
}
.
json
)
;
await
IOUtils
.
remove
(
profile
.
path
{
ignoreAbsent
:
true
}
)
;
await
Services
.
profiler
.
StopProfiler
(
)
;
}
const
SIGUSR1
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
?
30
:
10
;
const
SIGUSR2
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
?
31
:
12
;
add_task
(
async
(
)
=
>
{
info
(
"
Test
that
starting
the
profiler
with
a
posix
signal
works
.
"
)
;
registerCleanupFunction
(
cleanupAfterTest
)
;
Assert
.
ok
(
!
Services
.
profiler
.
IsActive
(
)
"
The
profiler
should
not
begin
the
test
active
.
"
)
;
let
pid
=
Services
.
appinfo
.
processID
;
let
result
=
raiseSignal
(
pid
SIGUSR1
)
;
Assert
.
ok
(
result
"
Raising
a
signal
should
succeed
"
)
;
await
Services
.
profiler
.
waitOnePeriodicSampling
(
)
;
Assert
.
ok
(
Services
.
profiler
.
IsActive
(
)
"
The
profiler
should
now
be
active
.
"
)
;
await
Services
.
profiler
.
StopProfiler
(
)
;
Assert
.
ok
(
!
Services
.
profiler
.
IsActive
(
)
"
The
profiler
should
now
be
inactive
.
"
)
;
}
)
;
add_task
(
async
(
)
=
>
{
info
(
"
Test
that
stopping
the
profiler
with
a
posix
signal
works
.
"
)
;
registerCleanupFunction
(
cleanupAfterTest
)
;
Assert
.
ok
(
!
Services
.
profiler
.
IsActive
(
)
"
The
profiler
should
not
begin
the
test
active
.
"
)
;
const
entries
=
100
;
const
interval
=
1
;
const
threads
=
[
]
;
const
features
=
[
]
;
await
Services
.
profiler
.
StartProfiler
(
entries
interval
threads
features
)
;
Assert
.
ok
(
Services
.
profiler
.
IsActive
(
)
"
The
profiler
should
now
be
active
.
"
)
;
let
pid
=
Services
.
appinfo
.
processID
;
let
result
=
raiseSignal
(
pid
SIGUSR2
)
;
Assert
.
ok
(
result
"
Raising
a
SIGUSR2
signal
should
succeed
.
"
)
;
await
waitUntilProfilerStopped
(
)
;
do_test_finished
(
)
;
}
)
;
add_task
(
async
(
)
=
>
{
info
(
"
Test
that
stopping
the
profiler
with
a
posix
signal
writes
a
profile
file
to
the
system
download
directory
.
"
)
;
registerCleanupFunction
(
cleanupAfterTest
)
;
Assert
.
ok
(
!
Services
.
profiler
.
IsActive
(
)
"
The
profiler
should
not
begin
the
test
active
.
"
)
;
const
entries
=
100
;
const
interval
=
1
;
const
threads
=
[
]
;
const
features
=
[
]
;
let
profile
=
FileUtils
.
File
(
await
Downloads
.
getSystemDownloadsDirectory
(
)
)
;
let
pid
=
Services
.
appinfo
.
processID
;
profile
.
append
(
profile_0_
{
pid
}
.
json
)
;
await
Services
.
profiler
.
StartProfiler
(
entries
interval
threads
features
)
;
Assert
.
ok
(
Services
.
profiler
.
IsActive
(
)
"
The
profiler
should
now
be
active
.
"
)
;
let
result
=
raiseSignal
(
pid
SIGUSR2
)
;
Assert
.
ok
(
result
"
Raising
a
SIGUSR2
signal
should
succeed
.
"
)
;
await
BrowserTestUtils
.
waitForCondition
(
async
(
)
=
>
await
IOUtils
.
exists
(
profile
.
path
)
"
Waiting
for
a
profile
file
to
be
written
to
disk
.
"
)
;
await
waitUntilProfilerStopped
(
)
;
Assert
.
ok
(
!
Services
.
profiler
.
IsActive
(
)
"
The
profiler
should
now
be
inactive
.
"
)
;
do_test_finished
(
)
;
}
)
;
