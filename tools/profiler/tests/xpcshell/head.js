const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
sharedHead
=
do_get_file
(
"
shared
-
head
.
js
"
false
)
;
if
(
!
sharedHead
)
{
throw
new
Error
(
"
Could
not
load
the
shared
head
.
"
)
;
}
Services
.
scriptloader
.
loadSubScript
(
Services
.
io
.
newFileURI
(
sharedHead
)
.
spec
this
)
;
add_setup
(
ProfilerTestUtils
.
assertProfilerInactive
)
;
function
getInflatedStackLocations
(
thread
sample
)
{
let
stackTable
=
thread
.
stackTable
;
let
frameTable
=
thread
.
frameTable
;
let
stringTable
=
thread
.
stringTable
;
let
SAMPLE_STACK_SLOT
=
thread
.
samples
.
schema
.
stack
;
let
STACK_PREFIX_SLOT
=
stackTable
.
schema
.
prefix
;
let
STACK_FRAME_SLOT
=
stackTable
.
schema
.
frame
;
let
FRAME_LOCATION_SLOT
=
frameTable
.
schema
.
location
;
let
stackIndex
=
sample
[
SAMPLE_STACK_SLOT
]
;
let
locations
=
[
]
;
while
(
stackIndex
!
=
=
null
)
{
let
stackEntry
=
stackTable
.
data
[
stackIndex
]
;
let
frame
=
frameTable
.
data
[
stackEntry
[
STACK_FRAME_SLOT
]
]
;
locations
.
push
(
stringTable
[
frame
[
FRAME_LOCATION_SLOT
]
]
)
;
stackIndex
=
stackEntry
[
STACK_PREFIX_SLOT
]
;
}
return
locations
.
reverse
(
)
;
}
function
expectStackToContain
(
actualStackFrames
expectedStackFrames
message
=
"
The
actual
stack
and
expected
stack
do
not
match
.
"
)
{
console
.
log
(
"
Actual
stack
:
"
actualStackFrames
)
;
console
.
log
(
"
Expected
to
contain
:
"
expectedStackFrames
.
map
(
s
=
>
s
.
toString
(
)
)
)
;
let
actualIndex
=
0
;
for
(
let
expectedIndex
=
0
;
expectedIndex
<
expectedStackFrames
.
length
;
expectedIndex
+
+
)
{
const
expectedStackFrame
=
expectedStackFrames
[
expectedIndex
]
;
while
(
true
)
{
if
(
actualIndex
>
=
actualStackFrames
.
length
)
{
info
(
Could
not
find
a
match
for
:
"
{
expectedStackFrame
.
toString
(
)
}
"
)
;
Assert
.
ok
(
false
message
)
;
}
const
actualStackFrame
=
actualStackFrames
[
actualIndex
]
;
actualIndex
+
+
;
const
itMatches
=
typeof
expectedStackFrame
=
=
=
"
string
"
?
expectedStackFrame
=
=
=
actualStackFrame
:
actualStackFrame
.
match
(
expectedStackFrame
)
;
if
(
itMatches
)
{
break
;
}
}
}
Assert
.
ok
(
true
message
)
;
}
function
getInflatedFileIOMarkers
(
thread
filename
)
{
const
markers
=
ProfilerTestUtils
.
getInflatedMarkerData
(
thread
)
;
return
markers
.
filter
(
marker
=
>
marker
.
data
?
.
type
=
=
=
"
FileIO
"
&
&
marker
.
data
?
.
filename
?
.
endsWith
(
filename
)
)
;
}
function
checkInflatedFileIOMarkers
(
markers
filename
)
{
greater
(
markers
.
length
0
"
Found
some
markers
"
)
;
const
validOperations
=
new
Set
(
[
"
write
"
"
fsync
"
"
close
"
"
stat
"
"
create
/
open
"
"
read
"
]
)
;
const
validSources
=
new
Set
(
[
"
PoisonIOInterposer
"
"
NSPRIOInterposer
"
]
)
;
for
(
const
marker
of
markers
)
{
try
{
ok
(
marker
.
name
.
startsWith
(
"
FileIO
"
)
"
Has
a
marker
.
name
that
starts
with
FileIO
"
)
;
equal
(
marker
.
data
.
type
"
FileIO
"
"
Has
a
marker
.
data
.
type
"
)
;
ok
(
ProfilerTestUtils
.
isIntervalMarker
(
marker
)
"
All
FileIO
markers
are
interval
markers
"
)
;
ok
(
validOperations
.
has
(
marker
.
data
.
operation
)
The
markers
have
a
known
operation
-
"
{
marker
.
data
.
operation
}
"
)
;
ok
(
validSources
.
has
(
marker
.
data
.
source
)
The
FileIO
marker
has
a
known
source
"
{
marker
.
data
.
source
}
"
)
;
ok
(
marker
.
data
.
filename
.
endsWith
(
filename
)
)
;
ok
(
Boolean
(
marker
.
data
.
stack
)
"
A
stack
was
collected
"
)
;
}
catch
(
error
)
{
console
.
error
(
"
Failing
inflated
FileIO
marker
:
"
marker
)
;
throw
error
;
}
}
}
function
checkSchema
(
actual
expected
)
{
const
schemaName
=
expected
.
name
;
info
(
Checking
marker
schema
for
"
{
schemaName
}
"
)
;
try
{
ok
(
actual
Schema
was
found
for
"
{
schemaName
}
"
.
See
the
test
output
for
more
information
.
)
;
deepEqual
(
expected
.
display
actual
.
display
The
"
display
"
property
for
{
schemaName
}
schema
matches
.
See
the
test
output
for
more
information
.
)
;
if
(
expected
.
data
)
{
ok
(
actual
.
data
Schema
was
found
for
"
{
schemaName
}
"
)
;
for
(
const
expectedDatum
of
expected
.
data
)
{
const
actualDatum
=
actual
.
data
.
find
(
d
=
>
d
.
key
=
=
=
expectedDatum
.
key
)
;
deepEqual
(
expectedDatum
actualDatum
The
"
{
schemaName
}
"
field
"
{
expectedDatum
.
key
}
"
matches
expectations
.
See
the
test
output
for
more
information
.
)
;
}
equal
(
expected
.
data
.
length
actual
.
data
.
length
"
The
expected
and
actual
data
have
the
same
number
of
items
"
)
;
}
deepEqual
(
expected
actual
"
The
entire
schema
is
deepEqual
"
)
;
}
catch
(
error
)
{
dump
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
dump
(
"
The
expected
marker
schema
:
\
n
"
)
;
dump
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
dump
(
JSON
.
stringify
(
expected
null
2
)
)
;
dump
(
"
\
n
"
)
;
dump
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
dump
(
"
The
actual
marker
schema
:
\
n
"
)
;
dump
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
dump
(
JSON
.
stringify
(
actual
null
2
)
)
;
dump
(
"
\
n
"
)
;
dump
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
dump
(
"
A
marker
schema
was
not
equal
to
expectations
.
If
you
\
n
"
)
;
dump
(
"
are
modifying
the
schema
then
please
copy
and
paste
\
n
"
)
;
dump
(
"
the
new
schema
into
this
test
.
\
n
"
)
;
dump
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
dump
(
"
Copy
this
:
"
+
JSON
.
stringify
(
actual
)
)
;
dump
(
"
\
n
"
)
;
dump
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
throw
error
;
}
}
