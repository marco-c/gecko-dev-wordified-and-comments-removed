const
{
FileUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
add_task
(
async
(
)
=
>
{
if
(
!
AppConstants
.
MOZ_GECKO_PROFILER
)
{
return
;
}
await
wait
(
10
)
;
{
const
filename
=
"
profiler
-
mainthreadio
-
test
-
firstrun
"
;
const
payloads
=
await
startProfilerAndgetFileIOPayloads
(
[
"
mainthreadio
"
]
filename
)
;
greater
(
payloads
.
length
0
"
FileIO
markers
were
found
when
using
the
mainthreadio
feature
on
the
profiler
.
"
)
;
}
{
const
filename
=
"
profiler
-
mainthreadio
-
test
-
no
-
instrumentation
"
;
const
payloads
=
await
startProfilerAndgetFileIOPayloads
(
[
]
filename
)
;
equal
(
payloads
.
length
0
"
No
FileIO
markers
are
found
when
the
mainthreadio
feature
is
not
turned
on
"
+
"
in
the
profiler
.
"
)
;
}
{
const
filename
=
"
profiler
-
mainthreadio
-
test
-
secondrun
"
;
const
payloads
=
await
startProfilerAndgetFileIOPayloads
(
[
"
mainthreadio
"
]
filename
)
;
greater
(
payloads
.
length
0
"
FileIO
markers
were
found
when
re
-
starting
the
mainthreadio
feature
on
the
"
+
"
profiler
.
"
)
;
}
}
)
;
async
function
startProfilerAndgetFileIOPayloads
(
features
filename
)
{
const
entries
=
10000
;
const
interval
=
10
;
const
threads
=
[
]
;
Services
.
profiler
.
StartProfiler
(
entries
interval
features
threads
)
;
const
file
=
FileUtils
.
getFile
(
"
TmpD
"
[
filename
]
)
;
if
(
file
.
exists
(
)
)
{
console
.
warn
(
"
This
test
is
triggering
FileIO
by
writing
to
a
file
.
However
the
test
found
an
"
+
"
existing
file
at
the
location
it
was
trying
to
write
to
.
This
could
happen
"
+
"
because
a
previous
run
of
the
test
failed
to
clean
up
after
itself
.
This
test
"
+
"
will
now
clean
up
that
file
before
running
the
test
again
.
"
)
;
file
.
remove
(
false
)
;
}
const
outputStream
=
FileUtils
.
openSafeFileOutputStream
(
file
)
;
const
data
=
"
Test
data
.
"
;
outputStream
.
write
(
data
data
.
length
)
;
FileUtils
.
closeSafeFileOutputStream
(
outputStream
)
;
file
.
remove
(
false
)
;
await
wait
(
500
)
;
Services
.
profiler
.
PauseSampling
(
)
;
const
profile
=
await
Services
.
profiler
.
getProfileDataAsync
(
)
;
Services
.
profiler
.
StopProfiler
(
)
;
return
getPayloadsOfTypeFromAllThreads
(
profile
"
FileIO
"
)
;
}
function
hasWritePayload
(
payloads
filename
)
{
return
payloads
.
some
(
payload
=
>
payload
.
filename
.
endsWith
(
filename
)
)
;
}
