var
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
var
{
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
function
getAllPayloadsOfType
(
profile
type
payloadTarget
=
[
]
)
{
for
(
const
{
markers
}
of
profile
.
threads
)
{
for
(
const
markerTuple
of
markers
.
data
)
{
const
payload
=
markerTuple
[
markers
.
schema
.
data
]
;
if
(
payload
&
&
payload
.
type
=
=
=
type
)
{
payloadTarget
.
push
(
payload
)
;
}
}
}
for
(
const
subProcess
of
profile
.
processes
)
{
getAllPayloadsOfType
(
subProcess
type
payloadTarget
)
;
}
return
payloadTarget
;
}
function
wait
(
time
)
{
return
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
time
)
;
}
)
;
}
function
getInflatedStackLocations
(
thread
sample
)
{
let
stackTable
=
thread
.
stackTable
;
let
frameTable
=
thread
.
frameTable
;
let
stringTable
=
thread
.
stringTable
;
let
SAMPLE_STACK_SLOT
=
thread
.
samples
.
schema
.
stack
;
let
STACK_PREFIX_SLOT
=
stackTable
.
schema
.
prefix
;
let
STACK_FRAME_SLOT
=
stackTable
.
schema
.
frame
;
let
FRAME_LOCATION_SLOT
=
frameTable
.
schema
.
location
;
let
stackIndex
=
sample
[
SAMPLE_STACK_SLOT
]
;
let
locations
=
[
]
;
while
(
stackIndex
!
=
=
null
)
{
let
stackEntry
=
stackTable
.
data
[
stackIndex
]
;
let
frame
=
frameTable
.
data
[
stackEntry
[
STACK_FRAME_SLOT
]
]
;
locations
.
push
(
stringTable
[
frame
[
FRAME_LOCATION_SLOT
]
]
)
;
stackIndex
=
stackEntry
[
STACK_PREFIX_SLOT
]
;
}
return
locations
.
reverse
(
)
;
}
function
doAtLeastOnePeriodicSample
(
)
{
function
getProfileSampleCount
(
)
{
const
profile
=
Services
.
profiler
.
getProfileData
(
)
;
return
profile
.
threads
[
0
]
.
samples
.
data
.
length
;
}
const
sampleCount
=
getProfileSampleCount
(
)
;
while
(
true
)
{
if
(
sampleCount
<
getProfileSampleCount
(
)
)
{
return
sampleCount
;
}
}
}
function
expectStackToContain
(
actualStackFrames
expectedStackFrames
message
=
"
The
actual
stack
and
expected
stack
do
not
match
.
"
)
{
console
.
log
(
"
Actual
stack
:
"
actualStackFrames
)
;
console
.
log
(
"
Expected
to
contain
:
"
expectedStackFrames
.
map
(
s
=
>
s
.
toString
(
)
)
)
;
let
actualIndex
=
0
;
for
(
let
expectedIndex
=
0
;
expectedIndex
<
expectedStackFrames
.
length
;
expectedIndex
+
+
)
{
const
expectedStackFrame
=
expectedStackFrames
[
expectedIndex
]
;
while
(
true
)
{
if
(
actualIndex
>
=
actualStackFrames
.
length
)
{
info
(
Could
not
find
a
match
for
:
"
{
expectedStackFrame
.
toString
(
)
}
"
)
;
Assert
.
ok
(
false
message
)
;
}
const
actualStackFrame
=
actualStackFrames
[
actualIndex
]
;
actualIndex
+
+
;
const
itMatches
=
typeof
expectedStackFrame
=
=
=
"
string
"
?
expectedStackFrame
=
=
=
actualStackFrame
:
actualStackFrame
.
match
(
expectedStackFrame
)
;
if
(
itMatches
)
{
break
;
}
}
}
Assert
.
ok
(
true
message
)
;
}
