#
include
"
GeckoProfiler
.
h
"
#
include
"
platform
.
h
"
#
include
"
ProfileBuffer
.
h
"
#
include
"
ProfileJSONWriter
.
h
"
#
include
"
ProfilerMarkerPayload
.
h
"
#
include
"
js
/
Initialization
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
<
string
.
h
>
using
namespace
mozilla
;
typedef
Vector
<
const
char
*
>
StrVec
;
static
void
InactiveFeaturesAndParamsCheck
(
)
{
int
entries
;
Maybe
<
double
>
duration
;
double
interval
;
uint32_t
features
;
StrVec
filters
;
ASSERT_TRUE
(
!
profiler_is_active
(
)
)
;
ASSERT_TRUE
(
!
profiler_feature_active
(
ProfilerFeature
:
:
MainThreadIO
)
)
;
ASSERT_TRUE
(
!
profiler_feature_active
(
ProfilerFeature
:
:
Privacy
)
)
;
profiler_get_start_params
(
&
entries
&
duration
&
interval
&
features
&
filters
)
;
ASSERT_TRUE
(
entries
=
=
0
)
;
ASSERT_TRUE
(
duration
=
=
Nothing
(
)
)
;
ASSERT_TRUE
(
interval
=
=
0
)
;
ASSERT_TRUE
(
features
=
=
0
)
;
ASSERT_TRUE
(
filters
.
empty
(
)
)
;
}
static
void
ActiveParamsCheck
(
int
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
size_t
aFiltersLen
const
Maybe
<
double
>
&
aDuration
=
Nothing
(
)
)
{
int
entries
;
Maybe
<
double
>
duration
;
double
interval
;
uint32_t
features
;
StrVec
filters
;
profiler_get_start_params
(
&
entries
&
duration
&
interval
&
features
&
filters
)
;
ASSERT_TRUE
(
entries
=
=
aEntries
)
;
ASSERT_TRUE
(
duration
=
=
aDuration
)
;
ASSERT_TRUE
(
interval
=
=
aInterval
)
;
ASSERT_TRUE
(
features
=
=
aFeatures
)
;
ASSERT_TRUE
(
filters
.
length
(
)
=
=
aFiltersLen
)
;
for
(
size_t
i
=
0
;
i
<
aFiltersLen
;
i
+
+
)
{
ASSERT_TRUE
(
strcmp
(
filters
[
i
]
aFilters
[
i
]
)
=
=
0
)
;
}
}
TEST
(
GeckoProfiler
FeaturesAndParams
)
{
InactiveFeaturesAndParamsCheck
(
)
;
{
uint32_t
features
=
ProfilerFeature
:
:
JS
|
ProfilerFeature
:
:
Threads
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
"
Compositor
"
}
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
Some
(
PROFILER_DEFAULT_DURATION
)
)
;
ASSERT_TRUE
(
profiler_is_active
(
)
)
;
ASSERT_TRUE
(
!
profiler_feature_active
(
ProfilerFeature
:
:
MainThreadIO
)
)
;
ASSERT_TRUE
(
!
profiler_feature_active
(
ProfilerFeature
:
:
Privacy
)
)
;
ActiveParamsCheck
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
Some
(
PROFILER_DEFAULT_DURATION
)
)
;
profiler_stop
(
)
;
InactiveFeaturesAndParamsCheck
(
)
;
}
{
uint32_t
features
=
ProfilerFeature
:
:
MainThreadIO
|
ProfilerFeature
:
:
Privacy
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
"
Foo
"
"
Bar
"
}
;
profiler_start
(
999999
3
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
Some
(
25
.
0
)
)
;
ASSERT_TRUE
(
profiler_is_active
(
)
)
;
ASSERT_TRUE
(
profiler_feature_active
(
ProfilerFeature
:
:
MainThreadIO
)
)
;
ASSERT_TRUE
(
profiler_feature_active
(
ProfilerFeature
:
:
Privacy
)
)
;
ActiveParamsCheck
(
999999
3
features
|
ProfilerFeature
:
:
Threads
filters
MOZ_ARRAY_LENGTH
(
filters
)
Some
(
25
.
0
)
)
;
profiler_stop
(
)
;
InactiveFeaturesAndParamsCheck
(
)
;
}
{
uint32_t
features
=
ProfilerFeature
:
:
MainThreadIO
|
ProfilerFeature
:
:
Privacy
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
"
Foo
"
"
Bar
"
}
;
profiler_start
(
999999
3
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
Nothing
(
)
)
;
ASSERT_TRUE
(
profiler_is_active
(
)
)
;
ASSERT_TRUE
(
profiler_feature_active
(
ProfilerFeature
:
:
MainThreadIO
)
)
;
ASSERT_TRUE
(
profiler_feature_active
(
ProfilerFeature
:
:
Privacy
)
)
;
ActiveParamsCheck
(
999999
3
features
|
ProfilerFeature
:
:
Threads
filters
MOZ_ARRAY_LENGTH
(
filters
)
Nothing
(
)
)
;
profiler_stop
(
)
;
InactiveFeaturesAndParamsCheck
(
)
;
}
{
uint32_t
availableFeatures
=
profiler_get_available_features
(
)
;
const
char
*
filters
[
]
=
{
"
"
}
;
profiler_start
(
88888
10
availableFeatures
filters
MOZ_ARRAY_LENGTH
(
filters
)
Some
(
15
.
0
)
)
;
ASSERT_TRUE
(
profiler_is_active
(
)
)
;
ASSERT_TRUE
(
profiler_feature_active
(
ProfilerFeature
:
:
MainThreadIO
)
)
;
ASSERT_TRUE
(
profiler_feature_active
(
ProfilerFeature
:
:
Privacy
)
)
;
ActiveParamsCheck
(
88888
10
availableFeatures
filters
MOZ_ARRAY_LENGTH
(
filters
)
Some
(
15
.
0
)
)
;
}
{
uint32_t
features
=
0
;
const
char
*
filters
[
]
=
{
"
NoThreadWillMatchThis
"
}
;
profiler_start
(
0
0
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
Some
(
0
.
0
)
)
;
ASSERT_TRUE
(
profiler_is_active
(
)
)
;
ASSERT_TRUE
(
!
profiler_feature_active
(
ProfilerFeature
:
:
MainThreadIO
)
)
;
ASSERT_TRUE
(
!
profiler_feature_active
(
ProfilerFeature
:
:
Privacy
)
)
;
ActiveParamsCheck
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
|
ProfilerFeature
:
:
Threads
filters
MOZ_ARRAY_LENGTH
(
filters
)
Nothing
(
)
)
;
profiler_stop
(
)
;
InactiveFeaturesAndParamsCheck
(
)
;
profiler_stop
(
)
;
profiler_stop
(
)
;
InactiveFeaturesAndParamsCheck
(
)
;
}
}
TEST
(
GeckoProfiler
EnsureStarted
)
{
InactiveFeaturesAndParamsCheck
(
)
;
uint32_t
features
=
ProfilerFeature
:
:
JS
|
ProfilerFeature
:
:
Threads
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
"
Compositor
"
}
;
{
profiler_ensure_started
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
Some
(
PROFILER_DEFAULT_DURATION
)
)
;
ActiveParamsCheck
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
Some
(
PROFILER_DEFAULT_DURATION
)
)
;
}
{
PR_Sleep
(
PR_MillisecondsToInterval
(
500
)
)
;
Maybe
<
ProfilerBufferInfo
>
info1
=
profiler_get_buffer_info
(
)
;
ASSERT_TRUE
(
info1
-
>
mRangeEnd
>
0
)
;
profiler_ensure_started
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
Some
(
PROFILER_DEFAULT_DURATION
)
)
;
ActiveParamsCheck
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
Some
(
PROFILER_DEFAULT_DURATION
)
)
;
Maybe
<
ProfilerBufferInfo
>
info2
=
profiler_get_buffer_info
(
)
;
ASSERT_TRUE
(
info2
-
>
mRangeEnd
>
=
info1
-
>
mRangeEnd
)
;
}
{
Maybe
<
ProfilerBufferInfo
>
info1
=
profiler_get_buffer_info
(
)
;
uint32_t
differentFeatures
=
features
|
ProfilerFeature
:
:
Leaf
;
profiler_ensure_started
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
differentFeatures
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
ActiveParamsCheck
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
differentFeatures
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
Maybe
<
ProfilerBufferInfo
>
info2
=
profiler_get_buffer_info
(
)
;
ASSERT_TRUE
(
info2
-
>
mRangeEnd
<
info1
-
>
mRangeEnd
)
;
}
{
profiler_stop
(
)
;
InactiveFeaturesAndParamsCheck
(
)
;
}
}
TEST
(
GeckoProfiler
DifferentThreads
)
{
InactiveFeaturesAndParamsCheck
(
)
;
nsCOMPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_NewNamedThread
(
"
GeckoProfGTest
"
getter_AddRefs
(
thread
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
{
uint32_t
features
=
ProfilerFeature
:
:
JS
|
ProfilerFeature
:
:
Threads
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
"
Compositor
"
}
;
thread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
GeckoProfiler_DifferentThreads_Test
:
:
TestBody
"
[
&
]
(
)
{
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
}
)
NS_DISPATCH_SYNC
)
;
ASSERT_TRUE
(
profiler_is_active
(
)
)
;
ASSERT_TRUE
(
!
profiler_feature_active
(
ProfilerFeature
:
:
MainThreadIO
)
)
;
ASSERT_TRUE
(
!
profiler_feature_active
(
ProfilerFeature
:
:
Privacy
)
)
;
ActiveParamsCheck
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
thread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
GeckoProfiler_DifferentThreads_Test
:
:
TestBody
"
[
&
]
(
)
{
profiler_stop
(
)
;
}
)
NS_DISPATCH_SYNC
)
;
InactiveFeaturesAndParamsCheck
(
)
;
}
{
uint32_t
features
=
ProfilerFeature
:
:
JS
|
ProfilerFeature
:
:
Threads
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
"
Compositor
"
}
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
thread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
GeckoProfiler_DifferentThreads_Test
:
:
TestBody
"
[
&
]
(
)
{
ASSERT_TRUE
(
profiler_is_active
(
)
)
;
ASSERT_TRUE
(
!
profiler_feature_active
(
ProfilerFeature
:
:
MainThreadIO
)
)
;
ASSERT_TRUE
(
!
profiler_feature_active
(
ProfilerFeature
:
:
Privacy
)
)
;
ActiveParamsCheck
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
}
)
NS_DISPATCH_SYNC
)
;
profiler_stop
(
)
;
thread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
GeckoProfiler_DifferentThreads_Test
:
:
TestBody
"
[
&
]
(
)
{
InactiveFeaturesAndParamsCheck
(
)
;
}
)
NS_DISPATCH_SYNC
)
;
}
thread
-
>
Shutdown
(
)
;
}
TEST
(
GeckoProfiler
GetBacktrace
)
{
ASSERT_TRUE
(
!
profiler_get_backtrace
(
)
)
;
{
uint32_t
features
=
ProfilerFeature
:
:
StackWalk
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
}
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
static
const
int
N
=
100
;
{
UniqueProfilerBacktrace
u
[
N
]
;
for
(
int
i
=
0
;
i
<
N
;
i
+
+
)
{
u
[
i
]
=
profiler_get_backtrace
(
)
;
ASSERT_TRUE
(
u
[
i
]
)
;
}
}
UniqueProfilerBacktrace
u
[
N
]
;
for
(
int
i
=
0
;
i
<
N
;
i
+
+
)
{
u
[
i
]
=
profiler_get_backtrace
(
)
;
ASSERT_TRUE
(
u
[
i
]
)
;
}
profiler_stop
(
)
;
}
{
uint32_t
features
=
ProfilerFeature
:
:
Privacy
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
}
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
ASSERT_TRUE
(
!
profiler_get_backtrace
(
)
)
;
profiler_stop
(
)
;
}
ASSERT_TRUE
(
!
profiler_get_backtrace
(
)
)
;
}
TEST
(
GeckoProfiler
Pause
)
{
uint32_t
features
=
ProfilerFeature
:
:
StackWalk
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
}
;
ASSERT_TRUE
(
!
profiler_is_paused
(
)
)
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
ASSERT_TRUE
(
!
profiler_is_paused
(
)
)
;
Maybe
<
ProfilerBufferInfo
>
info1
=
profiler_get_buffer_info
(
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
500
)
)
;
Maybe
<
ProfilerBufferInfo
>
info2
=
profiler_get_buffer_info
(
)
;
ASSERT_TRUE
(
info1
-
>
mRangeEnd
!
=
info2
-
>
mRangeEnd
)
;
profiler_pause
(
)
;
ASSERT_TRUE
(
profiler_is_paused
(
)
)
;
info1
=
profiler_get_buffer_info
(
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
500
)
)
;
info2
=
profiler_get_buffer_info
(
)
;
ASSERT_TRUE
(
info1
-
>
mRangeEnd
=
=
info2
-
>
mRangeEnd
)
;
profiler_resume
(
)
;
ASSERT_TRUE
(
!
profiler_is_paused
(
)
)
;
profiler_stop
(
)
;
ASSERT_TRUE
(
!
profiler_is_paused
(
)
)
;
}
class
GTestMarkerPayload
:
public
ProfilerMarkerPayload
{
public
:
explicit
GTestMarkerPayload
(
int
aN
)
:
mN
(
aN
)
{
sNumCreated
+
+
;
}
virtual
~
GTestMarkerPayload
(
)
{
sNumDestroyed
+
+
;
}
virtual
void
StreamPayload
(
SpliceableJSONWriter
&
aWriter
const
mozilla
:
:
TimeStamp
&
aStartTime
UniqueStacks
&
aUniqueStacks
)
override
{
StreamCommonProps
(
"
gtest
"
aWriter
aStartTime
aUniqueStacks
)
;
char
buf
[
64
]
;
SprintfLiteral
(
buf
"
gtest
-
%
d
"
mN
)
;
aWriter
.
IntProperty
(
buf
mN
)
;
sNumStreamed
+
+
;
}
private
:
int
mN
;
public
:
static
int
sNumCreated
;
static
int
sNumStreamed
;
static
int
sNumDestroyed
;
}
;
int
GTestMarkerPayload
:
:
sNumCreated
=
0
;
int
GTestMarkerPayload
:
:
sNumStreamed
=
0
;
int
GTestMarkerPayload
:
:
sNumDestroyed
=
0
;
TEST
(
GeckoProfiler
Markers
)
{
uint32_t
features
=
ProfilerFeature
:
:
StackWalk
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
}
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
profiler_tracing
(
"
A
"
"
B
"
JS
:
:
ProfilingCategoryPair
:
:
OTHER
TRACING_EVENT
)
;
PROFILER_TRACING
(
"
A
"
"
C
"
OTHER
TRACING_INTERVAL_START
)
;
PROFILER_TRACING
(
"
A
"
"
C
"
OTHER
TRACING_INTERVAL_END
)
;
UniqueProfilerBacktrace
bt
=
profiler_get_backtrace
(
)
;
profiler_tracing
(
"
B
"
"
A
"
JS
:
:
ProfilingCategoryPair
:
:
OTHER
TRACING_EVENT
std
:
:
move
(
bt
)
)
;
{
AUTO_PROFILER_TRACING
(
"
C
"
"
A
"
OTHER
)
;
}
profiler_add_marker
(
"
M1
"
JS
:
:
ProfilingCategoryPair
:
:
OTHER
)
;
profiler_add_marker
(
"
M2
"
JS
:
:
ProfilingCategoryPair
:
:
OTHER
MakeUnique
<
TracingMarkerPayload
>
(
"
C
"
TRACING_EVENT
)
)
;
PROFILER_ADD_MARKER
(
"
M3
"
OTHER
)
;
profiler_add_marker
(
"
M4
"
JS
:
:
ProfilingCategoryPair
:
:
OTHER
MakeUnique
<
TracingMarkerPayload
>
(
"
C
"
TRACING_EVENT
mozilla
:
:
Nothing
(
)
mozilla
:
:
Nothing
(
)
profiler_get_backtrace
(
)
)
)
;
for
(
int
i
=
0
;
i
<
10
;
i
+
+
)
{
profiler_add_marker
(
"
M5
"
JS
:
:
ProfilingCategoryPair
:
:
OTHER
MakeUnique
<
GTestMarkerPayload
>
(
i
)
)
;
}
static
const
size_t
kMax
=
ProfileBuffer
:
:
kMaxFrameKeyLength
;
UniquePtr
<
char
[
]
>
okstr1
=
MakeUnique
<
char
[
]
>
(
kMax
)
;
UniquePtr
<
char
[
]
>
okstr2
=
MakeUnique
<
char
[
]
>
(
kMax
)
;
UniquePtr
<
char
[
]
>
longstr
=
MakeUnique
<
char
[
]
>
(
kMax
+
1
)
;
for
(
size_t
i
=
0
;
i
<
kMax
;
i
+
+
)
{
okstr1
[
i
]
=
'
a
'
;
okstr2
[
i
]
=
'
b
'
;
longstr
[
i
]
=
'
c
'
;
}
okstr1
[
kMax
-
1
]
=
'
\
0
'
;
okstr2
[
kMax
-
1
]
=
'
\
0
'
;
longstr
[
kMax
]
=
'
\
0
'
;
AUTO_PROFILER_LABEL_DYNAMIC_CSTR
(
"
"
LAYOUT
okstr1
.
get
(
)
)
;
AUTO_PROFILER_LABEL_DYNAMIC_CSTR
(
"
okstr2
"
LAYOUT
okstr2
.
get
(
)
)
;
AUTO_PROFILER_LABEL_DYNAMIC_CSTR
(
"
"
LAYOUT
longstr
.
get
(
)
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
500
)
)
;
SpliceableChunkedJSONWriter
w
;
ASSERT_TRUE
(
profiler_stream_json_for_this_process
(
w
)
)
;
UniquePtr
<
char
[
]
>
profile
=
w
.
WriteFunc
(
)
-
>
CopyData
(
)
;
ASSERT_TRUE
(
GTestMarkerPayload
:
:
sNumCreated
=
=
10
)
;
ASSERT_TRUE
(
GTestMarkerPayload
:
:
sNumStreamed
=
=
10
)
;
ASSERT_TRUE
(
GTestMarkerPayload
:
:
sNumDestroyed
=
=
0
)
;
for
(
int
i
=
0
;
i
<
10
;
i
+
+
)
{
char
buf
[
64
]
;
SprintfLiteral
(
buf
"
\
"
gtest
-
%
d
\
"
"
i
)
;
ASSERT_TRUE
(
strstr
(
profile
.
get
(
)
buf
)
)
;
}
ASSERT_TRUE
(
strstr
(
profile
.
get
(
)
okstr1
.
get
(
)
)
)
;
ASSERT_TRUE
(
strstr
(
profile
.
get
(
)
"
okstr2
bbbbbbbbb
"
)
)
;
ASSERT_TRUE
(
!
strstr
(
profile
.
get
(
)
longstr
.
get
(
)
)
)
;
ASSERT_TRUE
(
strstr
(
profile
.
get
(
)
"
(
too
long
)
"
)
)
;
profiler_stop
(
)
;
ASSERT_TRUE
(
GTestMarkerPayload
:
:
sNumDestroyed
=
=
10
)
;
for
(
int
i
=
0
;
i
<
10
;
i
+
+
)
{
profiler_add_marker
(
"
M5
"
JS
:
:
ProfilingCategoryPair
:
:
OTHER
MakeUnique
<
GTestMarkerPayload
>
(
i
)
)
;
}
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
ASSERT_TRUE
(
profiler_stream_json_for_this_process
(
w
)
)
;
profiler_stop
(
)
;
ASSERT_TRUE
(
GTestMarkerPayload
:
:
sNumCreated
=
=
20
)
;
ASSERT_TRUE
(
GTestMarkerPayload
:
:
sNumStreamed
=
=
10
)
;
ASSERT_TRUE
(
GTestMarkerPayload
:
:
sNumDestroyed
=
=
20
)
;
}
TEST
(
GeckoProfiler
DurationLimit
)
{
uint32_t
features
=
ProfilerFeature
:
:
StackWalk
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
}
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
Some
(
1
.
5
)
)
;
GTestMarkerPayload
:
:
sNumCreated
=
0
;
GTestMarkerPayload
:
:
sNumStreamed
=
0
;
GTestMarkerPayload
:
:
sNumDestroyed
=
0
;
profiler_add_marker
(
"
M1
"
JS
:
:
ProfilingCategoryPair
:
:
OTHER
MakeUnique
<
GTestMarkerPayload
>
(
1
)
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
1100
)
)
;
profiler_add_marker
(
"
M2
"
JS
:
:
ProfilingCategoryPair
:
:
OTHER
MakeUnique
<
GTestMarkerPayload
>
(
2
)
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
500
)
)
;
SpliceableChunkedJSONWriter
w
;
ASSERT_TRUE
(
profiler_stream_json_for_this_process
(
w
)
)
;
ASSERT_TRUE
(
GTestMarkerPayload
:
:
sNumCreated
=
=
2
)
;
ASSERT_TRUE
(
GTestMarkerPayload
:
:
sNumStreamed
=
=
1
)
;
ASSERT_TRUE
(
GTestMarkerPayload
:
:
sNumDestroyed
=
=
1
)
;
}
#
define
COUNTER_NAME
"
TestCounter
"
#
define
COUNTER_DESCRIPTION
"
Test
of
counters
in
profiles
"
#
define
COUNTER_NAME2
"
Counter2
"
#
define
COUNTER_DESCRIPTION2
"
Second
Test
of
counters
in
profiles
"
PROFILER_DEFINE_COUNT_TOTAL
(
TestCounter
COUNTER_NAME
COUNTER_DESCRIPTION
)
;
PROFILER_DEFINE_COUNT_TOTAL
(
TestCounter2
COUNTER_NAME2
COUNTER_DESCRIPTION2
)
;
TEST
(
GeckoProfiler
Counters
)
{
uint32_t
features
=
ProfilerFeature
:
:
Threads
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
"
Compositor
"
}
;
profiler_ensure_started
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
AUTO_PROFILER_COUNT_TOTAL
(
TestCounter
10
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
200
)
)
;
AUTO_PROFILER_COUNT_TOTAL
(
TestCounter
7
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
200
)
)
;
AUTO_PROFILER_COUNT_TOTAL
(
TestCounter
-
17
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
200
)
)
;
SpliceableChunkedJSONWriter
w
;
ASSERT_TRUE
(
profiler_stream_json_for_this_process
(
w
)
)
;
UniquePtr
<
char
[
]
>
profile
=
w
.
WriteFunc
(
)
-
>
CopyData
(
)
;
ASSERT_TRUE
(
strstr
(
profile
.
get
(
)
COUNTER_NAME
)
)
;
ASSERT_TRUE
(
strstr
(
profile
.
get
(
)
COUNTER_DESCRIPTION
)
)
;
ASSERT_FALSE
(
strstr
(
profile
.
get
(
)
COUNTER_NAME2
)
)
;
ASSERT_FALSE
(
strstr
(
profile
.
get
(
)
COUNTER_DESCRIPTION2
)
)
;
AUTO_PROFILER_COUNT_TOTAL
(
TestCounter2
10
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
200
)
)
;
ASSERT_TRUE
(
profiler_stream_json_for_this_process
(
w
)
)
;
profile
=
w
.
WriteFunc
(
)
-
>
CopyData
(
)
;
ASSERT_TRUE
(
strstr
(
profile
.
get
(
)
COUNTER_NAME
)
)
;
ASSERT_TRUE
(
strstr
(
profile
.
get
(
)
COUNTER_DESCRIPTION
)
)
;
ASSERT_TRUE
(
strstr
(
profile
.
get
(
)
COUNTER_NAME2
)
)
;
ASSERT_TRUE
(
strstr
(
profile
.
get
(
)
COUNTER_DESCRIPTION2
)
)
;
profiler_stop
(
)
;
}
TEST
(
GeckoProfiler
Time
)
{
uint32_t
features
=
ProfilerFeature
:
:
StackWalk
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
}
;
double
t1
=
profiler_time
(
)
;
double
t2
=
profiler_time
(
)
;
ASSERT_TRUE
(
t1
<
=
t2
)
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
double
t3
=
profiler_time
(
)
;
double
t4
=
profiler_time
(
)
;
ASSERT_TRUE
(
t3
<
=
t4
)
;
profiler_stop
(
)
;
double
t5
=
profiler_time
(
)
;
double
t6
=
profiler_time
(
)
;
ASSERT_TRUE
(
t4
<
=
t5
&
&
t1
<
=
t6
)
;
}
TEST
(
GeckoProfiler
GetProfile
)
{
uint32_t
features
=
ProfilerFeature
:
:
StackWalk
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
}
;
ASSERT_TRUE
(
!
profiler_get_profile
(
)
)
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
UniquePtr
<
char
[
]
>
profile
=
profiler_get_profile
(
)
;
ASSERT_TRUE
(
profile
&
&
profile
[
0
]
=
=
'
{
'
)
;
profiler_stop
(
)
;
ASSERT_TRUE
(
!
profiler_get_profile
(
)
)
;
}
static
void
JSONOutputCheck
(
const
char
*
aOutput
)
{
ASSERT_TRUE
(
aOutput
)
;
ASSERT_TRUE
(
aOutput
[
0
]
=
=
'
{
'
)
;
ASSERT_TRUE
(
strstr
(
aOutput
"
\
"
libs
\
"
"
)
)
;
ASSERT_TRUE
(
strstr
(
aOutput
"
\
"
meta
\
"
"
)
)
;
ASSERT_TRUE
(
strstr
(
aOutput
"
\
"
version
\
"
"
)
)
;
ASSERT_TRUE
(
strstr
(
aOutput
"
\
"
startTime
\
"
"
)
)
;
ASSERT_TRUE
(
strstr
(
aOutput
"
\
"
threads
\
"
"
)
)
;
ASSERT_TRUE
(
strstr
(
aOutput
"
\
"
GeckoMain
\
"
"
)
)
;
ASSERT_TRUE
(
strstr
(
aOutput
"
\
"
samples
\
"
"
)
)
;
ASSERT_TRUE
(
strstr
(
aOutput
"
\
"
markers
\
"
"
)
)
;
ASSERT_TRUE
(
strstr
(
aOutput
"
\
"
stackTable
\
"
"
)
)
;
ASSERT_TRUE
(
strstr
(
aOutput
"
\
"
frameTable
\
"
"
)
)
;
ASSERT_TRUE
(
strstr
(
aOutput
"
\
"
stringTable
\
"
"
)
)
;
}
TEST
(
GeckoProfiler
StreamJSONForThisProcess
)
{
uint32_t
features
=
ProfilerFeature
:
:
StackWalk
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
}
;
SpliceableChunkedJSONWriter
w
;
ASSERT_TRUE
(
!
profiler_stream_json_for_this_process
(
w
)
)
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
w
.
Start
(
)
;
ASSERT_TRUE
(
profiler_stream_json_for_this_process
(
w
)
)
;
w
.
End
(
)
;
UniquePtr
<
char
[
]
>
profile
=
w
.
WriteFunc
(
)
-
>
CopyData
(
)
;
JSONOutputCheck
(
profile
.
get
(
)
)
;
profiler_stop
(
)
;
ASSERT_TRUE
(
!
profiler_stream_json_for_this_process
(
w
)
)
;
}
TEST
(
GeckoProfiler
StreamJSONForThisProcessThreaded
)
{
nsCOMPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_NewNamedThread
(
"
GeckoProfGTest
"
getter_AddRefs
(
thread
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
uint32_t
features
=
ProfilerFeature
:
:
StackWalk
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
}
;
SpliceableChunkedJSONWriter
w
;
ASSERT_TRUE
(
!
profiler_stream_json_for_this_process
(
w
)
)
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
thread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
GeckoProfiler_StreamJSONForThisProcessThreaded_Test
:
:
TestBody
"
[
&
]
(
)
{
w
.
Start
(
)
;
ASSERT_TRUE
(
profiler_stream_json_for_this_process
(
w
)
)
;
w
.
End
(
)
;
}
)
NS_DISPATCH_SYNC
)
;
UniquePtr
<
char
[
]
>
profile
=
w
.
WriteFunc
(
)
-
>
CopyData
(
)
;
JSONOutputCheck
(
profile
.
get
(
)
)
;
thread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
GeckoProfiler_StreamJSONForThisProcessThreaded_Test
:
:
TestBody
"
[
&
]
(
)
{
profiler_stop
(
)
;
ASSERT_TRUE
(
!
profiler_stream_json_for_this_process
(
w
)
)
;
}
)
NS_DISPATCH_SYNC
)
;
thread
-
>
Shutdown
(
)
;
ASSERT_TRUE
(
!
profiler_stream_json_for_this_process
(
w
)
)
;
}
TEST
(
GeckoProfiler
ProfilingStack
)
{
uint32_t
features
=
ProfilerFeature
:
:
StackWalk
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
}
;
AUTO_PROFILER_LABEL
(
"
A
:
:
B
"
OTHER
)
;
UniqueFreePtr
<
char
>
dynamic
(
strdup
(
"
dynamic
"
)
)
;
{
AUTO_PROFILER_LABEL_DYNAMIC_CSTR
(
"
A
:
:
C
"
JS
dynamic
.
get
(
)
)
;
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING
(
"
A
:
:
C2
"
JS
nsDependentCString
(
dynamic
.
get
(
)
)
)
;
AUTO_PROFILER_LABEL_DYNAMIC_LOSSY_NSSTRING
(
"
A
:
:
C3
"
JS
NS_ConvertUTF8toUTF16
(
dynamic
.
get
(
)
)
)
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
ASSERT_TRUE
(
profiler_get_backtrace
(
)
)
;
}
AutoProfilerLabel
label1
(
"
A
"
nullptr
JS
:
:
ProfilingCategoryPair
:
:
DOM
)
;
AutoProfilerLabel
label2
(
"
A
"
dynamic
.
get
(
)
JS
:
:
ProfilingCategoryPair
:
:
NETWORK
)
;
ASSERT_TRUE
(
profiler_get_backtrace
(
)
)
;
profiler_stop
(
)
;
ASSERT_TRUE
(
!
profiler_get_profile
(
)
)
;
}
TEST
(
GeckoProfiler
Bug1355807
)
{
uint32_t
features
=
ProfilerFeature
:
:
JS
;
const
char
*
manyThreadsFilter
[
]
=
{
"
"
}
;
const
char
*
fewThreadsFilter
[
]
=
{
"
GeckoMain
"
}
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
manyThreadsFilter
MOZ_ARRAY_LENGTH
(
manyThreadsFilter
)
)
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
fewThreadsFilter
MOZ_ARRAY_LENGTH
(
fewThreadsFilter
)
)
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
fewThreadsFilter
MOZ_ARRAY_LENGTH
(
fewThreadsFilter
)
)
;
profiler_stop
(
)
;
}
class
GTestStackCollector
final
:
public
ProfilerStackCollector
{
public
:
GTestStackCollector
(
)
:
mSetIsMainThread
(
0
)
mFrames
(
0
)
{
}
virtual
void
SetIsMainThread
(
)
{
mSetIsMainThread
+
+
;
}
virtual
void
CollectNativeLeafAddr
(
void
*
aAddr
)
{
mFrames
+
+
;
}
virtual
void
CollectJitReturnAddr
(
void
*
aAddr
)
{
mFrames
+
+
;
}
virtual
void
CollectWasmFrame
(
const
char
*
aLabel
)
{
mFrames
+
+
;
}
virtual
void
CollectProfilingStackFrame
(
const
js
:
:
ProfilingStackFrame
&
aFrame
)
{
mFrames
+
+
;
}
int
mSetIsMainThread
;
int
mFrames
;
}
;
void
DoSuspendAndSample
(
int
aTid
nsIThread
*
aThread
)
{
aThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
GeckoProfiler_SuspendAndSample_Test
:
:
TestBody
"
[
&
]
(
)
{
uint32_t
features
=
ProfilerFeature
:
:
Leaf
;
GTestStackCollector
collector
;
profiler_suspend_and_sample_thread
(
aTid
features
collector
true
)
;
ASSERT_TRUE
(
collector
.
mSetIsMainThread
=
=
1
)
;
ASSERT_TRUE
(
collector
.
mFrames
>
0
)
;
}
)
NS_DISPATCH_SYNC
)
;
}
TEST
(
GeckoProfiler
SuspendAndSample
)
{
nsCOMPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_NewNamedThread
(
"
GeckoProfGTest
"
getter_AddRefs
(
thread
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
int
tid
=
Thread
:
:
GetCurrentId
(
)
;
ASSERT_TRUE
(
!
profiler_is_active
(
)
)
;
DoSuspendAndSample
(
tid
thread
)
;
uint32_t
features
=
ProfilerFeature
:
:
JS
|
ProfilerFeature
:
:
Threads
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
"
Compositor
"
}
;
profiler_start
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
ASSERT_TRUE
(
profiler_is_active
(
)
)
;
DoSuspendAndSample
(
tid
thread
)
;
profiler_stop
(
)
;
ASSERT_TRUE
(
!
profiler_is_active
(
)
)
;
}
