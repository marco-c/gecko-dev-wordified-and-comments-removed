const
INSTANT
=
0
;
const
INTERVAL
=
1
;
const
INTERVAL_START
=
2
;
const
INTERVAL_END
=
3
;
var
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
defaultSettings
=
{
entries
:
8
*
1024
*
1024
interval
:
1
features
:
[
"
threads
"
]
threads
:
[
"
GeckoMain
"
]
}
;
function
startProfiler
(
callersSettings
)
{
if
(
Services
.
profiler
.
IsActive
(
)
)
{
throw
new
Error
(
"
The
profiler
must
not
be
active
before
starting
it
in
a
test
.
"
)
;
}
const
settings
=
Object
.
assign
(
{
}
defaultSettings
callersSettings
)
;
Services
.
profiler
.
StartProfiler
(
settings
.
entries
settings
.
interval
settings
.
features
settings
.
threads
0
settings
.
duration
)
;
}
function
startProfilerForMarkerTests
(
)
{
startProfiler
(
{
features
:
[
"
threads
"
"
nostacksampling
"
]
}
)
;
}
function
wait
(
time
)
{
return
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
time
)
;
}
)
;
}
function
getPayloadsOfTypeFromAllThreads
(
profile
type
payloadTarget
=
[
]
)
{
for
(
const
{
markers
}
of
profile
.
threads
)
{
for
(
const
markerTuple
of
markers
.
data
)
{
const
payload
=
markerTuple
[
markers
.
schema
.
data
]
;
if
(
payload
&
&
payload
.
type
=
=
=
type
)
{
payloadTarget
.
push
(
payload
)
;
}
}
}
for
(
const
subProcess
of
profile
.
processes
)
{
getPayloadsOfTypeFromAllThreads
(
subProcess
type
payloadTarget
)
;
}
return
payloadTarget
;
}
function
getPayloadsOfType
(
thread
type
)
{
const
{
markers
}
=
thread
;
const
results
=
[
]
;
for
(
const
markerTuple
of
markers
.
data
)
{
const
payload
=
markerTuple
[
markers
.
schema
.
data
]
;
if
(
payload
&
&
payload
.
type
=
=
=
type
)
{
results
.
push
(
payload
)
;
}
}
return
results
;
}
function
getInflatedMarkerData
(
thread
)
{
const
{
markers
stringTable
}
=
thread
;
return
markers
.
data
.
map
(
markerTuple
=
>
{
const
marker
=
{
}
;
for
(
const
[
key
tupleIndex
]
of
Object
.
entries
(
markers
.
schema
)
)
{
marker
[
key
]
=
markerTuple
[
tupleIndex
]
;
if
(
key
=
=
=
"
name
"
)
{
marker
[
key
]
=
stringTable
[
marker
[
key
]
]
;
}
}
return
marker
;
}
)
;
}
function
captureAtLeastOneJsSample
(
)
{
function
getProfileSampleCount
(
)
{
const
profile
=
Services
.
profiler
.
getProfileData
(
)
;
return
profile
.
threads
[
0
]
.
samples
.
data
.
length
;
}
const
sampleCount
=
getProfileSampleCount
(
)
;
while
(
true
)
{
if
(
sampleCount
<
getProfileSampleCount
(
)
)
{
return
sampleCount
;
}
}
}
async
function
stopAndGetProfile
(
)
{
Services
.
profiler
.
Pause
(
)
;
const
profile
=
await
Services
.
profiler
.
getProfileDataAsync
(
)
;
Services
.
profiler
.
StopProfiler
(
)
;
return
profile
;
}
function
isIntervalMarker
(
inflatedMarker
)
{
return
(
inflatedMarker
.
phase
=
=
=
1
&
&
typeof
inflatedMarker
.
startTime
=
=
=
"
number
"
&
&
typeof
inflatedMarker
.
endTime
=
=
=
"
number
"
)
;
}
function
getThreads
(
profile
)
{
const
threads
=
[
]
;
function
getThreadsRecursive
(
process
)
{
for
(
const
thread
of
process
.
threads
)
{
threads
.
push
(
thread
)
;
}
for
(
const
subprocess
of
process
.
processes
)
{
getThreadsRecursive
(
subprocess
)
;
}
}
getThreadsRecursive
(
profile
)
;
return
threads
;
}
function
getSchema
(
profile
name
)
{
{
const
schema
=
profile
.
meta
.
markerSchema
.
find
(
s
=
>
s
.
name
=
=
=
name
)
;
if
(
schema
)
{
return
schema
;
}
}
for
(
const
subprocess
of
profile
.
processes
)
{
const
schema
=
subprocess
.
meta
.
markerSchema
.
find
(
s
=
>
s
.
name
=
=
=
name
)
;
if
(
schema
)
{
return
schema
;
}
}
console
.
error
(
"
Parent
process
schema
"
profile
.
meta
.
markerSchema
)
;
for
(
const
subprocess
of
profile
.
processes
)
{
console
.
error
(
"
Child
process
schema
"
subprocess
.
meta
.
markerSchema
)
;
}
throw
new
Error
(
Could
not
find
a
schema
for
"
{
name
}
"
.
)
;
}
