const
INSTANT
=
0
;
const
INTERVAL
=
1
;
const
INTERVAL_START
=
2
;
const
INTERVAL_END
=
3
;
const
defaultSettings
=
{
entries
:
8
*
1024
*
1024
interval
:
1
features
:
[
]
threads
:
[
"
GeckoMain
"
]
}
;
async
function
startProfiler
(
callersSettings
)
{
if
(
Services
.
profiler
.
IsActive
(
)
)
{
Assert
.
ok
(
Services
.
env
.
exists
(
"
MOZ_PROFILER_STARTUP
"
)
"
The
profiler
is
active
at
the
begining
of
the
test
"
+
"
the
MOZ_PROFILER_STARTUP
environment
variable
should
be
set
.
"
)
;
if
(
Services
.
env
.
exists
(
"
MOZ_PROFILER_STARTUP
"
)
)
{
info
(
"
This
test
starts
and
stops
the
profiler
and
is
not
compatible
"
+
"
with
the
use
of
MOZ_PROFILER_STARTUP
.
"
+
"
Stopping
the
profiler
before
starting
the
test
.
"
)
;
await
Services
.
profiler
.
StopProfiler
(
)
;
}
else
{
throw
new
Error
(
"
The
profiler
must
not
be
active
before
starting
it
in
a
test
.
"
)
;
}
}
const
settings
=
Object
.
assign
(
{
}
defaultSettings
callersSettings
)
;
return
Services
.
profiler
.
StartProfiler
(
settings
.
entries
settings
.
interval
settings
.
features
settings
.
threads
0
settings
.
duration
)
;
}
function
startProfilerForMarkerTests
(
)
{
return
startProfiler
(
{
features
:
[
"
nostacksampling
"
"
js
"
]
threads
:
[
"
GeckoMain
"
"
DOM
Worker
"
]
}
)
;
}
function
wait
(
time
)
{
return
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
time
)
;
}
)
;
}
function
getPayloadsOfTypeFromAllThreads
(
profile
type
payloadTarget
=
[
]
)
{
for
(
const
{
markers
}
of
profile
.
threads
)
{
for
(
const
markerTuple
of
markers
.
data
)
{
const
payload
=
markerTuple
[
markers
.
schema
.
data
]
;
if
(
payload
&
&
payload
.
type
=
=
=
type
)
{
payloadTarget
.
push
(
payload
)
;
}
}
}
for
(
const
subProcess
of
profile
.
processes
)
{
getPayloadsOfTypeFromAllThreads
(
subProcess
type
payloadTarget
)
;
}
return
payloadTarget
;
}
function
getPayloadsOfType
(
thread
type
)
{
const
{
markers
}
=
thread
;
const
results
=
[
]
;
for
(
const
markerTuple
of
markers
.
data
)
{
const
payload
=
markerTuple
[
markers
.
schema
.
data
]
;
if
(
payload
&
&
payload
.
type
=
=
=
type
)
{
results
.
push
(
payload
)
;
}
}
return
results
;
}
function
getInflatedMarkerData
(
thread
)
{
const
{
markers
stringTable
}
=
thread
;
return
markers
.
data
.
map
(
markerTuple
=
>
{
const
marker
=
{
}
;
for
(
const
[
key
tupleIndex
]
of
Object
.
entries
(
markers
.
schema
)
)
{
marker
[
key
]
=
markerTuple
[
tupleIndex
]
;
if
(
key
=
=
=
"
name
"
)
{
marker
[
key
]
=
stringTable
[
marker
[
key
]
]
;
}
}
return
marker
;
}
)
;
}
function
getInflatedNetworkMarkers
(
thread
)
{
const
markers
=
getInflatedMarkerData
(
thread
)
;
return
markers
.
filter
(
m
=
>
m
.
data
&
&
m
.
data
.
type
=
=
=
"
Network
"
&
&
m
.
data
.
URI
.
includes
(
"
/
tools
/
profiler
/
"
)
)
;
}
function
getPairsOfNetworkMarkers
(
allNetworkMarkers
)
{
const
result
=
[
]
;
const
mapOfStartMarkers
=
new
Map
(
)
;
for
(
const
marker
of
allNetworkMarkers
)
{
const
{
data
}
=
marker
;
if
(
data
.
status
=
=
=
"
STATUS_START
"
)
{
if
(
mapOfStartMarkers
.
has
(
data
.
id
)
)
{
const
previousMarker
=
result
[
mapOfStartMarkers
.
get
(
data
.
id
)
]
[
0
]
;
Assert
.
ok
(
false
We
found
2
start
markers
with
the
same
id
{
data
.
id
}
without
end
marker
in
-
between
.
+
The
first
marker
has
URI
{
previousMarker
.
data
.
URI
}
the
second
marker
has
URI
{
data
.
URI
}
.
+
This
should
not
happen
.
)
;
continue
;
}
mapOfStartMarkers
.
set
(
data
.
id
result
.
length
)
;
result
.
push
(
[
marker
]
)
;
}
else
{
if
(
!
mapOfStartMarkers
.
has
(
data
.
id
)
)
{
Assert
.
ok
(
false
We
found
an
end
marker
without
a
start
marker
(
id
:
{
data
.
id
}
URI
:
{
data
.
URI
}
)
.
This
should
not
happen
.
)
;
continue
;
}
result
[
mapOfStartMarkers
.
get
(
data
.
id
)
]
.
push
(
marker
)
;
mapOfStartMarkers
.
delete
(
data
.
id
)
;
}
}
return
result
;
}
function
captureAtLeastOneJsSample
(
)
{
function
getProfileSampleCount
(
)
{
const
profile
=
Services
.
profiler
.
getProfileData
(
)
;
return
profile
.
threads
[
0
]
.
samples
.
data
.
length
;
}
const
sampleCount
=
getProfileSampleCount
(
)
;
while
(
true
)
{
if
(
sampleCount
<
getProfileSampleCount
(
)
)
{
return
sampleCount
;
}
}
}
function
isJSONWhitespace
(
c
)
{
return
[
"
\
n
"
"
\
r
"
"
"
"
\
t
"
]
.
includes
(
c
)
;
}
function
verifyJSONStringIsCompact
(
s
)
{
const
stateData
=
0
;
const
stateString
=
1
;
const
stateEscapedChar
=
2
;
let
state
=
stateData
;
for
(
let
i
=
0
;
i
<
s
.
length
;
+
+
i
)
{
let
c
=
s
[
i
]
;
switch
(
state
)
{
case
stateData
:
if
(
isJSONWhitespace
(
c
)
)
{
Assert
.
ok
(
false
"
Unexpected
JSON
whitespace
at
index
{
i
}
in
profile
:
<
<
<
{
s
}
>
>
>
"
)
;
return
;
}
if
(
c
=
=
'
"
'
)
{
state
=
stateString
;
}
break
;
case
stateString
:
if
(
c
=
=
'
"
'
)
{
state
=
stateData
;
}
else
if
(
c
=
=
"
\
\
"
)
{
state
=
stateEscapedChar
;
}
break
;
case
stateEscapedChar
:
state
=
stateString
;
break
;
}
}
}
async
function
stopNowAndGetProfile
(
)
{
Services
.
profiler
.
Pause
(
)
;
const
profileArrayBuffer
=
await
Services
.
profiler
.
getProfileDataAsArrayBuffer
(
)
;
await
Services
.
profiler
.
StopProfiler
(
)
;
const
profileUint8Array
=
new
Uint8Array
(
profileArrayBuffer
)
;
const
textDecoder
=
new
TextDecoder
(
"
utf
-
8
"
{
fatal
:
true
}
)
;
const
profileString
=
textDecoder
.
decode
(
profileUint8Array
)
;
verifyJSONStringIsCompact
(
profileString
)
;
return
JSON
.
parse
(
profileString
)
;
}
async
function
waitSamplingAndStopAndGetProfile
(
)
{
await
Services
.
profiler
.
waitOnePeriodicSampling
(
)
;
return
stopNowAndGetProfile
(
)
;
}
function
isIntervalMarker
(
inflatedMarker
)
{
return
(
inflatedMarker
.
phase
=
=
=
1
&
&
typeof
inflatedMarker
.
startTime
=
=
=
"
number
"
&
&
typeof
inflatedMarker
.
endTime
=
=
=
"
number
"
)
;
}
function
getThreads
(
profile
)
{
const
threads
=
[
]
;
function
getThreadsRecursive
(
process
)
{
for
(
const
thread
of
process
.
threads
)
{
threads
.
push
(
thread
)
;
}
for
(
const
subprocess
of
process
.
processes
)
{
getThreadsRecursive
(
subprocess
)
;
}
}
getThreadsRecursive
(
profile
)
;
return
threads
;
}
function
getSchema
(
profile
name
)
{
{
const
schema
=
profile
.
meta
.
markerSchema
.
find
(
s
=
>
s
.
name
=
=
=
name
)
;
if
(
schema
)
{
return
schema
;
}
}
for
(
const
subprocess
of
profile
.
processes
)
{
const
schema
=
subprocess
.
meta
.
markerSchema
.
find
(
s
=
>
s
.
name
=
=
=
name
)
;
if
(
schema
)
{
return
schema
;
}
}
console
.
error
(
"
Parent
process
schema
"
profile
.
meta
.
markerSchema
)
;
for
(
const
subprocess
of
profile
.
processes
)
{
console
.
error
(
"
Child
process
schema
"
subprocess
.
meta
.
markerSchema
)
;
}
throw
new
Error
(
Could
not
find
a
schema
for
"
{
name
}
"
.
)
;
}
function
escapeStringRegexp
(
string
)
{
if
(
typeof
string
!
=
=
"
string
"
)
{
throw
new
TypeError
(
"
Expected
a
string
"
)
;
}
return
string
.
replace
(
/
[
|
\
\
{
}
(
)
[
\
]
^
+
*
?
.
]
/
g
"
\
\
&
"
)
.
replace
(
/
-
/
g
"
\
\
x2d
"
)
;
}
Object
.
assign
(
Assert
{
objectContains
(
object
expectedProperties
)
{
if
(
typeof
object
!
=
=
"
object
"
)
{
this
.
ok
(
false
The
first
parameter
should
be
an
object
but
found
:
{
object
}
.
)
;
return
;
}
if
(
typeof
expectedProperties
!
=
=
"
object
"
)
{
this
.
ok
(
false
The
second
parameter
should
be
an
object
but
found
:
{
expectedProperties
}
.
)
;
return
;
}
for
(
const
key
of
Object
.
keys
(
expectedProperties
)
)
{
const
expected
=
expectedProperties
[
key
]
;
if
(
!
(
key
in
object
)
)
{
this
.
report
(
true
object
expectedProperties
The
object
should
contain
the
property
"
{
key
}
"
but
it
'
s
missing
.
)
;
continue
;
}
if
(
typeof
expected
=
=
=
"
function
"
)
{
expected
(
object
[
key
]
The
object
should
contain
the
property
"
{
key
}
"
with
an
expected
value
and
type
.
)
;
}
else
{
this
.
equal
(
object
[
key
]
expectedProperties
[
key
]
The
object
should
contain
the
property
"
{
key
}
"
with
an
expected
value
.
)
;
}
}
}
objectContainsOnly
(
object
expectedProperties
)
{
if
(
typeof
object
!
=
=
"
object
"
)
{
this
.
ok
(
false
The
first
parameter
should
be
an
object
but
found
:
{
object
}
.
)
;
return
;
}
if
(
typeof
expectedProperties
!
=
=
"
object
"
)
{
this
.
ok
(
false
The
second
parameter
should
be
an
object
but
found
:
{
expectedProperties
}
.
)
;
return
;
}
const
extraProperties
=
[
]
;
for
(
const
fixtureKey
of
Object
.
keys
(
object
)
)
{
if
(
!
(
fixtureKey
in
expectedProperties
)
)
{
extraProperties
.
push
(
fixtureKey
)
;
}
}
if
(
extraProperties
.
length
)
{
this
.
report
(
true
object
expectedProperties
These
properties
are
present
but
shouldn
'
t
:
"
{
extraProperties
.
join
(
'
"
"
'
)
}
"
.
)
;
}
this
.
objectContains
(
object
expectedProperties
)
;
}
}
)
;
const
Expect
=
{
any
:
(
)
=
>
actual
=
>
{
}
}
;
[
"
stringContains
"
"
stringMatches
"
"
objectContains
"
"
objectContainsOnly
"
]
.
forEach
(
assertChecker
=
>
(
Expect
[
assertChecker
]
=
expected
=
>
(
actual
.
.
.
moreArgs
)
=
>
Assert
[
assertChecker
]
(
actual
expected
.
.
.
moreArgs
)
)
)
;
[
"
number
"
"
string
"
"
boolean
"
"
bigint
"
"
symbol
"
"
object
"
"
function
"
]
.
forEach
(
type
=
>
(
Expect
[
type
]
=
makeTypeChecker
(
type
)
)
)
;
function
makeTypeChecker
(
type
)
{
return
(
.
.
.
unexpectedArgs
)
=
>
{
if
(
unexpectedArgs
.
length
)
{
throw
new
Error
(
"
Type
checkers
expectations
aren
'
t
expecting
any
argument
.
"
)
;
}
return
(
actual
message
)
=
>
{
const
isCorrect
=
typeof
actual
=
=
=
type
;
Assert
.
report
(
!
isCorrect
actual
type
message
"
has
type
"
)
;
}
;
}
;
}
