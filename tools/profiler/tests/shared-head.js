const
{
ProfilerTestUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
ProfilerTestUtils
.
sys
.
mjs
"
)
;
async
function
wait
(
time
)
{
return
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
time
)
;
}
)
;
}
function
escapeStringRegexp
(
string
)
{
if
(
typeof
string
!
=
=
"
string
"
)
{
throw
new
TypeError
(
"
Expected
a
string
"
)
;
}
return
string
.
replace
(
/
[
|
\
\
{
}
(
)
[
\
]
^
+
*
?
.
]
/
g
"
\
\
&
"
)
.
replace
(
/
-
/
g
"
\
\
x2d
"
)
;
}
ChromeUtils
.
defineESModuleGetters
(
this
{
Downloads
:
"
resource
:
/
/
gre
/
modules
/
Downloads
.
sys
.
mjs
"
}
)
;
async
function
getFullProfilePath
(
pid
)
{
let
path
=
Services
.
env
.
get
(
"
MOZ_UPLOAD_DIR
"
)
;
if
(
!
path
)
{
path
=
await
Downloads
.
getSystemDownloadsDirectory
(
)
;
}
return
PathUtils
.
join
(
path
profile_0_
{
pid
}
.
json
)
;
}
const
SIGUSR1
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
?
30
:
10
;
const
SIGUSR2
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
?
31
:
12
;
function
raiseSignal
(
pid
sig
)
{
const
{
ctypes
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
sys
.
mjs
"
)
;
function
openLibrary
(
names
)
{
for
(
const
name
of
names
)
{
try
{
return
ctypes
.
open
(
name
)
;
}
catch
(
e
)
{
}
}
return
undefined
;
}
try
{
const
libc
=
openLibrary
(
[
"
libc
.
so
.
6
"
"
libc
.
so
"
"
libc
.
dylib
"
"
libSystem
.
B
.
dylib
"
]
)
;
if
(
!
libc
)
{
info
(
"
Failed
to
open
any
libc
shared
object
"
)
;
return
{
ok
:
false
}
;
}
const
kill
=
libc
.
declare
(
"
kill
"
ctypes
.
default_abi
ctypes
.
int
ctypes
.
int32_t
ctypes
.
int
)
;
let
kres
=
kill
(
pid
sig
)
;
if
(
kres
!
=
0
)
{
info
(
Kill
returned
a
non
-
zero
result
{
kres
}
.
)
;
return
{
ok
:
false
}
;
}
libc
.
close
(
)
;
}
catch
(
e
)
{
info
(
Exception
{
e
}
thrown
while
trying
to
call
kill
)
;
return
{
ok
:
false
}
;
}
return
{
ok
:
true
}
;
}
Object
.
assign
(
Assert
{
objectContains
(
object
expectedProperties
)
{
if
(
typeof
object
!
=
=
"
object
"
)
{
this
.
ok
(
false
The
first
parameter
should
be
an
object
but
found
:
{
object
}
.
)
;
return
;
}
if
(
typeof
expectedProperties
!
=
=
"
object
"
)
{
this
.
ok
(
false
The
second
parameter
should
be
an
object
but
found
:
{
expectedProperties
}
.
)
;
return
;
}
for
(
const
key
of
Object
.
keys
(
expectedProperties
)
)
{
const
expected
=
expectedProperties
[
key
]
;
if
(
!
(
key
in
object
)
)
{
this
.
report
(
true
object
expectedProperties
The
object
should
contain
the
property
"
{
key
}
"
but
it
'
s
missing
.
)
;
continue
;
}
if
(
typeof
expected
=
=
=
"
function
"
)
{
expected
(
object
[
key
]
The
object
should
contain
the
property
"
{
key
}
"
with
an
expected
value
and
type
.
)
;
}
else
{
this
.
equal
(
object
[
key
]
expectedProperties
[
key
]
The
object
should
contain
the
property
"
{
key
}
"
with
an
expected
value
.
)
;
}
}
}
objectContainsOnly
(
object
expectedProperties
)
{
if
(
typeof
object
!
=
=
"
object
"
)
{
this
.
ok
(
false
The
first
parameter
should
be
an
object
but
found
:
{
object
}
.
)
;
return
;
}
if
(
typeof
expectedProperties
!
=
=
"
object
"
)
{
this
.
ok
(
false
The
second
parameter
should
be
an
object
but
found
:
{
expectedProperties
}
.
)
;
return
;
}
const
extraProperties
=
[
]
;
for
(
const
fixtureKey
of
Object
.
keys
(
object
)
)
{
if
(
!
(
fixtureKey
in
expectedProperties
)
)
{
extraProperties
.
push
(
fixtureKey
)
;
}
}
if
(
extraProperties
.
length
)
{
this
.
report
(
true
object
expectedProperties
These
properties
are
present
but
shouldn
'
t
:
"
{
extraProperties
.
join
(
'
"
"
'
)
}
"
.
)
;
}
this
.
objectContains
(
object
expectedProperties
)
;
}
}
)
;
const
Expect
=
{
any
:
(
)
=
>
(
)
=
>
{
}
}
;
[
"
stringContains
"
"
stringMatches
"
"
objectContains
"
"
objectContainsOnly
"
]
.
forEach
(
assertChecker
=
>
(
Expect
[
assertChecker
]
=
expected
=
>
(
actual
.
.
.
moreArgs
)
=
>
Assert
[
assertChecker
]
(
actual
expected
.
.
.
moreArgs
)
)
)
;
[
"
number
"
"
string
"
"
boolean
"
"
bigint
"
"
symbol
"
"
object
"
"
function
"
]
.
forEach
(
type
=
>
(
Expect
[
type
]
=
makeTypeChecker
(
type
)
)
)
;
function
makeTypeChecker
(
type
)
{
return
(
.
.
.
unexpectedArgs
)
=
>
{
if
(
unexpectedArgs
.
length
)
{
throw
new
Error
(
"
Type
checkers
expectations
aren
'
t
expecting
any
argument
.
"
)
;
}
return
(
actual
message
)
=
>
{
const
isCorrect
=
typeof
actual
=
=
=
type
;
Assert
.
report
(
!
isCorrect
actual
type
message
"
has
type
"
)
;
}
;
}
;
}
