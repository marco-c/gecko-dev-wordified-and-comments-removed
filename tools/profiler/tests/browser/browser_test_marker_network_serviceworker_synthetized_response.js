const
serviceWorkerFileName
=
"
serviceworker_synthetized_response
.
js
"
;
registerCleanupFunction
(
(
)
=
>
SpecialPowers
.
removeAllServiceWorkerData
(
)
)
;
add_task
(
async
function
test_network_markers_service_worker_setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
cache
.
disk
.
enable
"
false
]
[
"
browser
.
cache
.
memory
.
enable
"
false
]
]
}
)
;
}
)
;
add_task
(
async
function
test_network_markers_service_worker_register
(
)
{
Assert
.
ok
(
!
Services
.
profiler
.
IsActive
(
)
"
The
profiler
is
not
currently
active
"
)
;
const
url
=
{
BASE_URL_HTTPS
}
serviceworkers
/
serviceworker_register
.
html
;
await
BrowserTestUtils
.
withNewTab
(
url
async
contentBrowser
=
>
{
await
SpecialPowers
.
spawn
(
contentBrowser
[
serviceWorkerFileName
]
async
function
(
serviceWorkerFileName
)
{
await
content
.
wrappedJSObject
.
registerServiceWorkerAndWait
(
serviceWorkerFileName
)
;
}
)
;
const
workers
=
await
SpecialPowers
.
registeredServiceWorkers
(
)
;
Assert
.
equal
(
workers
.
length
1
"
One
service
worker
should
be
properly
registered
.
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_network_markers_service_worker_use
(
)
{
Assert
.
ok
(
!
Services
.
profiler
.
IsActive
(
)
"
The
profiler
is
not
currently
active
"
)
;
await
ProfilerTestUtils
.
startProfilerForMarkerTests
(
)
;
const
url
=
{
BASE_URL_HTTPS
}
serviceworkers
/
serviceworker_simple
.
html
;
await
BrowserTestUtils
.
withNewTab
(
url
async
contentBrowser
=
>
{
const
contentPid
=
await
SpecialPowers
.
spawn
(
contentBrowser
[
]
(
)
=
>
Services
.
appinfo
.
processID
)
;
await
SpecialPowers
.
spawn
(
contentBrowser
[
]
async
(
)
=
>
{
await
content
.
fetch
(
"
firefox
-
generated
.
svg
"
)
.
then
(
res
=
>
res
.
arrayBuffer
(
)
)
;
await
content
.
fetch
(
"
firefox
-
logo
-
nightly
.
svg
"
)
.
then
(
res
=
>
res
.
arrayBuffer
(
)
)
;
}
)
;
const
{
parentThread
contentThread
profile
}
=
await
stopProfilerNowAndGetThreads
(
contentPid
)
;
const
{
serviceWorkerParentThread
}
=
findServiceWorkerThreads
(
profile
)
;
ok
(
serviceWorkerParentThread
"
We
should
find
a
thread
for
the
service
worker
.
"
)
;
logInformationForThread
(
"
parentThread
information
"
parentThread
)
;
logInformationForThread
(
"
contentThread
information
"
contentThread
)
;
logInformationForThread
(
"
serviceWorkerParentThread
information
"
serviceWorkerParentThread
)
;
const
parentNetworkMarkers
=
ProfilerTestUtils
.
getInflatedNetworkMarkers
(
parentThread
)
.
filter
(
marker
=
>
!
marker
.
data
.
URI
.
includes
(
serviceWorkerFileName
)
)
;
const
contentNetworkMarkers
=
ProfilerTestUtils
.
getInflatedNetworkMarkers
(
contentThread
)
;
const
serviceWorkerNetworkMarkers
=
ProfilerTestUtils
.
getInflatedNetworkMarkers
(
serviceWorkerParentThread
)
;
info
(
"
Parent
network
markers
:
"
+
JSON
.
stringify
(
parentNetworkMarkers
null
2
)
)
;
info
(
"
Content
network
markers
:
"
+
JSON
.
stringify
(
contentNetworkMarkers
null
2
)
)
;
info
(
"
Serviceworker
network
markers
:
"
+
JSON
.
stringify
(
serviceWorkerNetworkMarkers
null
2
)
)
;
const
parentPairs
=
ProfilerTestUtils
.
getPairsOfNetworkMarkers
(
parentNetworkMarkers
)
;
const
contentPairs
=
ProfilerTestUtils
.
getPairsOfNetworkMarkers
(
contentNetworkMarkers
)
;
const
serviceWorkerPairs
=
ProfilerTestUtils
.
getPairsOfNetworkMarkers
(
serviceWorkerNetworkMarkers
)
;
parentPairs
.
forEach
(
pair
=
>
Assert
.
equal
(
pair
.
length
2
For
the
URL
{
pair
[
0
]
.
data
.
URI
}
we
should
get
2
markers
in
the
parent
process
.
)
)
;
contentPairs
.
forEach
(
pair
=
>
Assert
.
equal
(
pair
.
length
2
For
the
URL
{
pair
[
0
]
.
data
.
URI
}
we
should
get
2
markers
in
the
content
process
.
)
)
;
serviceWorkerPairs
.
forEach
(
pair
=
>
Assert
.
equal
(
pair
.
length
2
For
the
URL
{
pair
[
0
]
.
data
.
URI
}
we
should
get
2
markers
in
the
service
worker
process
.
)
)
;
let
parentStopMarkers
=
parentPairs
.
map
(
(
[
_
stopMarker
]
)
=
>
stopMarker
)
;
const
contentStopMarkers
=
contentPairs
.
map
(
(
[
_
stopMarker
]
)
=
>
stopMarker
)
;
const
fullUrl
=
filename
=
>
{
BASE_URL_HTTPS
}
serviceworkers
/
{
filename
}
;
{
Assert
.
equal
(
parentStopMarkers
.
length
8
"
There
should
be
8
stop
markers
in
the
parent
process
.
"
)
;
const
[
htmlFetchIntercept
htmlFetch1
htmlFetch2
generatedSvgIntercept
generatedSvgFetch
firefoxSvgIntercept
firefoxSvgFetch1
firefoxSvgFetch2
]
=
parentStopMarkers
;
Assert
.
objectContains
(
htmlFetchIntercept
{
name
:
Expect
.
stringMatches
(
/
Load
\
d
+
:
.
*
serviceworker_simple
.
html
/
)
data
:
Expect
.
objectContainsOnly
(
{
type
:
"
Network
"
status
:
"
STATUS_REDIRECT
"
URI
:
fullUrl
(
"
serviceworker_simple
.
html
"
)
classOfService
:
"
UrgentStart
"
requestStatus
:
"
NS_OK
"
requestMethod
:
"
GET
"
contentType
:
null
startTime
:
Expect
.
number
(
)
endTime
:
Expect
.
number
(
)
id
:
Expect
.
number
(
)
pri
:
Expect
.
number
(
)
priorityHeader
:
Expect
.
string
(
)
redirectId
:
htmlFetch1
.
data
.
id
redirectType
:
"
Internal
"
isHttpToHttpsRedirect
:
false
RedirectURI
:
fullUrl
(
"
serviceworker_simple
.
html
"
)
cache
:
"
Unresolved
"
}
)
}
)
;
Assert
.
objectContains
(
htmlFetch1
{
name
:
Expect
.
stringMatches
(
/
Load
\
d
+
:
.
*
serviceworker_simple
.
html
/
)
data
:
Expect
.
objectContainsOnly
(
{
type
:
"
Network
"
status
:
"
STATUS_STOP
"
URI
:
fullUrl
(
"
serviceworker_simple
.
html
"
)
httpVersion
:
"
http
/
1
.
1
"
classOfService
:
"
UrgentStart
"
requestStatus
:
"
NS_OK
"
requestMethod
:
"
GET
"
responseStatus
:
200
contentType
:
"
text
/
html
"
startTime
:
Expect
.
number
(
)
endTime
:
Expect
.
number
(
)
id
:
Expect
.
number
(
)
pri
:
Expect
.
number
(
)
priorityHeader
:
Expect
.
string
(
)
}
)
}
)
;
Assert
.
objectContains
(
htmlFetch2
{
name
:
Expect
.
stringMatches
(
/
Load
\
d
+
:
.
*
serviceworker_simple
.
html
/
)
data
:
Expect
.
objectContainsOnly
(
{
type
:
"
Network
"
status
:
"
STATUS_STOP
"
URI
:
fullUrl
(
"
serviceworker_simple
.
html
"
)
httpVersion
:
"
http
/
1
.
1
"
classOfService
:
"
Unset
"
requestStatus
:
"
NS_OK
"
requestMethod
:
"
GET
"
responseStatus
:
200
contentType
:
"
text
/
html
"
cache
:
Expect
.
stringMatches
(
/
^
(
Missed
|
Unresolved
)
/
)
startTime
:
Expect
.
number
(
)
endTime
:
Expect
.
number
(
)
domainLookupStart
:
Expect
.
number
(
)
domainLookupEnd
:
Expect
.
number
(
)
connectStart
:
Expect
.
number
(
)
secureConnectionStart
:
Expect
.
number
(
)
tcpConnectEnd
:
Expect
.
number
(
)
connectEnd
:
Expect
.
number
(
)
requestStart
:
Expect
.
number
(
)
responseStart
:
Expect
.
number
(
)
responseEnd
:
Expect
.
number
(
)
id
:
Expect
.
number
(
)
count
:
Expect
.
number
(
)
pri
:
Expect
.
number
(
)
priorityHeader
:
Expect
.
string
(
)
}
)
}
)
;
Assert
.
objectContains
(
generatedSvgIntercept
{
name
:
Expect
.
stringMatches
(
/
Load
\
d
+
:
.
*
firefox
-
generated
.
svg
/
)
data
:
Expect
.
objectContainsOnly
(
{
type
:
"
Network
"
status
:
"
STATUS_REDIRECT
"
URI
:
fullUrl
(
"
firefox
-
generated
.
svg
"
)
classOfService
:
"
Unset
"
requestStatus
:
"
NS_OK
"
requestMethod
:
"
GET
"
contentType
:
null
startTime
:
Expect
.
number
(
)
endTime
:
Expect
.
number
(
)
id
:
Expect
.
number
(
)
pri
:
Expect
.
number
(
)
priorityHeader
:
Expect
.
string
(
)
redirectId
:
generatedSvgFetch
.
data
.
id
redirectType
:
"
Internal
"
isHttpToHttpsRedirect
:
false
RedirectURI
:
fullUrl
(
"
firefox
-
generated
.
svg
"
)
cache
:
"
Unresolved
"
innerWindowID
:
Expect
.
number
(
)
}
)
}
)
;
Assert
.
objectContains
(
generatedSvgFetch
{
name
:
Expect
.
stringMatches
(
/
Load
\
d
+
:
.
*
firefox
-
generated
.
svg
/
)
data
:
Expect
.
objectContainsOnly
(
{
type
:
"
Network
"
status
:
"
STATUS_STOP
"
URI
:
fullUrl
(
"
firefox
-
generated
.
svg
"
)
httpVersion
:
"
http
/
1
.
1
"
classOfService
:
"
Unset
"
requestStatus
:
"
NS_OK
"
requestMethod
:
"
GET
"
responseStatus
:
200
contentType
:
"
image
/
svg
+
xml
"
startTime
:
Expect
.
number
(
)
endTime
:
Expect
.
number
(
)
id
:
Expect
.
number
(
)
pri
:
Expect
.
number
(
)
priorityHeader
:
Expect
.
string
(
)
innerWindowID
:
Expect
.
number
(
)
}
)
}
)
;
Assert
.
objectContains
(
firefoxSvgIntercept
{
name
:
Expect
.
stringMatches
(
/
Load
\
d
+
:
.
*
firefox
-
logo
-
nightly
.
svg
/
)
data
:
Expect
.
objectContainsOnly
(
{
type
:
"
Network
"
status
:
"
STATUS_REDIRECT
"
URI
:
fullUrl
(
"
firefox
-
logo
-
nightly
.
svg
"
)
classOfService
:
"
Unset
"
requestStatus
:
"
NS_OK
"
requestMethod
:
"
GET
"
contentType
:
null
startTime
:
Expect
.
number
(
)
endTime
:
Expect
.
number
(
)
id
:
Expect
.
number
(
)
pri
:
Expect
.
number
(
)
priorityHeader
:
Expect
.
string
(
)
redirectId
:
firefoxSvgFetch1
.
data
.
id
redirectType
:
"
Internal
"
isHttpToHttpsRedirect
:
false
RedirectURI
:
fullUrl
(
"
firefox
-
logo
-
nightly
.
svg
"
)
cache
:
"
Unresolved
"
innerWindowID
:
Expect
.
number
(
)
}
)
}
)
;
Assert
.
objectContains
(
firefoxSvgFetch1
{
name
:
Expect
.
stringMatches
(
/
Load
\
d
+
:
.
*
firefox
-
logo
-
nightly
.
svg
/
)
data
:
Expect
.
objectContainsOnly
(
{
type
:
"
Network
"
status
:
"
STATUS_STOP
"
URI
:
fullUrl
(
"
firefox
-
logo
-
nightly
.
svg
"
)
httpVersion
:
"
http
/
1
.
1
"
classOfService
:
"
Unset
"
requestStatus
:
"
NS_OK
"
requestMethod
:
"
GET
"
responseStatus
:
200
contentType
:
"
image
/
svg
+
xml
"
startTime
:
Expect
.
number
(
)
endTime
:
Expect
.
number
(
)
id
:
Expect
.
number
(
)
pri
:
Expect
.
number
(
)
priorityHeader
:
Expect
.
string
(
)
innerWindowID
:
Expect
.
number
(
)
}
)
}
)
;
Assert
.
objectContains
(
firefoxSvgFetch2
{
name
:
Expect
.
stringMatches
(
/
Load
\
d
+
:
.
*
firefox
-
logo
-
nightly
.
svg
/
)
data
:
Expect
.
objectContainsOnly
(
{
type
:
"
Network
"
status
:
"
STATUS_STOP
"
URI
:
fullUrl
(
"
firefox
-
logo
-
nightly
.
svg
"
)
httpVersion
:
"
http
/
1
.
1
"
classOfService
:
"
Unset
"
requestStatus
:
"
NS_OK
"
requestMethod
:
"
GET
"
responseStatus
:
200
contentType
:
"
image
/
svg
+
xml
"
cache
:
Expect
.
stringMatches
(
/
^
(
Missed
|
Unresolved
)
/
)
startTime
:
Expect
.
number
(
)
endTime
:
Expect
.
number
(
)
domainLookupStart
:
Expect
.
number
(
)
domainLookupEnd
:
Expect
.
number
(
)
connectStart
:
Expect
.
number
(
)
secureConnectionStart
:
Expect
.
number
(
)
tcpConnectEnd
:
Expect
.
number
(
)
connectEnd
:
Expect
.
number
(
)
requestStart
:
Expect
.
number
(
)
responseStart
:
Expect
.
number
(
)
responseEnd
:
Expect
.
number
(
)
id
:
Expect
.
number
(
)
count
:
Expect
.
number
(
)
pri
:
Expect
.
number
(
)
priorityHeader
:
Expect
.
string
(
)
}
)
}
)
;
}
let
htmlFetch1
generatedSvgFetch1
firefoxSvgFetch1
;
if
(
serviceWorkerParentThread
!
=
=
contentThread
)
{
Assert
.
equal
(
contentStopMarkers
.
length
3
"
There
should
be
3
stop
markers
in
the
content
process
.
"
)
;
[
htmlFetch1
generatedSvgFetch1
firefoxSvgFetch1
]
=
contentStopMarkers
;
}
else
{
Assert
.
equal
(
contentStopMarkers
.
length
5
"
There
should
be
5
stop
markers
in
the
combined
process
(
containing
both
the
content
page
and
the
service
worker
)
"
)
;
[
htmlFetch1
generatedSvgFetch1
firefoxSvgFetch1
]
=
contentStopMarkers
;
}
Assert
.
objectContains
(
htmlFetch1
{
name
:
Expect
.
stringMatches
(
/
Load
\
d
+
:
.
*
serviceworker_simple
.
html
/
)
data
:
Expect
.
objectContainsOnly
(
{
type
:
"
Network
"
status
:
"
STATUS_STOP
"
URI
:
fullUrl
(
"
serviceworker_simple
.
html
"
)
httpVersion
:
"
http
/
1
.
1
"
classOfService
:
"
Unset
"
requestStatus
:
"
NS_OK
"
requestMethod
:
"
GET
"
responseStatus
:
200
contentType
:
"
text
/
html
"
startTime
:
Expect
.
number
(
)
endTime
:
Expect
.
number
(
)
id
:
Expect
.
number
(
)
pri
:
Expect
.
number
(
)
priorityHeader
:
Expect
.
string
(
)
}
)
}
)
;
Assert
.
objectContains
(
generatedSvgFetch1
{
name
:
Expect
.
stringMatches
(
/
Load
\
d
+
:
.
*
firefox
-
generated
.
svg
/
)
data
:
Expect
.
objectContainsOnly
(
{
type
:
"
Network
"
status
:
"
STATUS_STOP
"
URI
:
fullUrl
(
"
firefox
-
generated
.
svg
"
)
httpVersion
:
"
http
/
1
.
1
"
classOfService
:
"
Unset
"
requestStatus
:
"
NS_OK
"
requestMethod
:
"
GET
"
responseStatus
:
200
contentType
:
"
image
/
svg
+
xml
"
startTime
:
Expect
.
number
(
)
endTime
:
Expect
.
number
(
)
id
:
Expect
.
number
(
)
pri
:
Expect
.
number
(
)
priorityHeader
:
Expect
.
string
(
)
innerWindowID
:
Expect
.
number
(
)
}
)
}
)
;
Assert
.
objectContains
(
firefoxSvgFetch1
{
name
:
Expect
.
stringMatches
(
/
Load
\
d
+
:
.
*
firefox
-
logo
-
nightly
.
svg
/
)
data
:
Expect
.
objectContainsOnly
(
{
type
:
"
Network
"
status
:
"
STATUS_STOP
"
URI
:
fullUrl
(
"
firefox
-
logo
-
nightly
.
svg
"
)
httpVersion
:
"
http
/
1
.
1
"
classOfService
:
"
Unset
"
requestStatus
:
"
NS_OK
"
requestMethod
:
"
GET
"
responseStatus
:
200
contentType
:
"
image
/
svg
+
xml
"
startTime
:
Expect
.
number
(
)
endTime
:
Expect
.
number
(
)
id
:
Expect
.
number
(
)
pri
:
Expect
.
number
(
)
priorityHeader
:
Expect
.
string
(
)
innerWindowID
:
Expect
.
number
(
)
}
)
}
)
;
}
)
;
}
)
;
