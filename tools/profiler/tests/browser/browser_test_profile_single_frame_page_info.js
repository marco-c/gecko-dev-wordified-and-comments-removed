if
(
SpecialPowers
.
useRemoteSubframes
)
{
requestLongerTimeout
(
2
)
;
}
add_task
(
async
function
test_profile_single_frame_page_info
(
)
{
SimpleTest
.
requestCompleteLog
(
)
;
Assert
.
ok
(
!
Services
.
profiler
.
IsActive
(
)
)
;
info
(
"
Clear
the
previous
pages
just
in
case
we
still
have
some
open
tabs
.
"
)
;
await
Services
.
profiler
.
ClearAllPages
(
)
;
info
(
"
Start
the
profiler
to
test
the
page
information
with
single
frame
page
.
"
)
;
await
startProfiler
(
)
;
info
(
"
Open
a
tab
with
single_frame
.
html
in
it
.
"
)
;
const
url
=
BASE_URL
+
"
single_frame
.
html
"
;
await
BrowserTestUtils
.
withNewTab
(
url
async
function
(
contentBrowser
)
{
const
contentPid
=
await
SpecialPowers
.
spawn
(
contentBrowser
[
]
(
)
=
>
{
return
Services
.
appinfo
.
processID
;
}
)
;
const
win
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
const
activeTabID
=
win
.
gBrowser
.
selectedBrowser
.
browsingContext
.
browserId
;
info
(
"
Capture
the
profile
data
.
"
)
;
const
profile
=
await
Services
.
profiler
.
getProfileDataAsync
(
)
;
await
Services
.
profiler
.
StopProfiler
(
)
;
let
pageFound
=
false
;
let
contentProcess
=
profile
.
processes
.
find
(
p
=
>
p
.
threads
[
0
]
.
pid
=
=
contentPid
)
;
if
(
!
contentProcess
)
{
throw
new
Error
(
Could
not
find
the
content
process
with
given
pid
:
{
contentPid
}
)
;
}
info
(
"
Check
if
the
captured
page
is
the
one
with
correct
values
we
created
.
"
)
;
for
(
const
page
of
contentProcess
.
pages
)
{
if
(
page
.
url
=
=
url
)
{
Assert
.
equal
(
page
.
url
url
)
;
Assert
.
equal
(
typeof
page
.
tabID
"
number
"
)
;
Assert
.
equal
(
page
.
tabID
activeTabID
)
;
Assert
.
equal
(
typeof
page
.
innerWindowID
"
number
"
)
;
Assert
.
equal
(
page
.
embedderInnerWindowID
0
)
;
Assert
.
equal
(
typeof
page
.
isPrivateBrowsing
"
boolean
"
)
;
Assert
.
equal
(
page
.
isPrivateBrowsing
false
)
;
pageFound
=
true
;
break
;
}
}
Assert
.
equal
(
pageFound
true
)
;
}
)
;
}
)
;
add_task
(
async
function
test_profile_private_browsing
(
)
{
SimpleTest
.
requestCompleteLog
(
)
;
Assert
.
ok
(
!
Services
.
profiler
.
IsActive
(
)
)
;
info
(
"
Clear
the
previous
pages
just
in
case
we
still
have
some
open
tabs
.
"
)
;
await
Services
.
profiler
.
ClearAllPages
(
)
;
info
(
"
Start
the
profiler
to
test
the
page
information
with
single
frame
page
.
"
)
;
await
startProfiler
(
)
;
info
(
"
Open
a
private
window
with
single_frame
.
html
in
it
.
"
)
;
const
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
{
fission
:
false
private
:
true
}
)
;
try
{
const
url
=
BASE_URL_HTTPS
+
"
single_frame
.
html
"
;
const
contentBrowser
=
win
.
gBrowser
.
selectedBrowser
;
BrowserTestUtils
.
loadURI
(
contentBrowser
url
)
;
await
BrowserTestUtils
.
browserLoaded
(
contentBrowser
false
url
)
;
const
contentPid
=
await
SpecialPowers
.
spawn
(
contentBrowser
[
]
(
)
=
>
{
return
Services
.
appinfo
.
processID
;
}
)
;
const
activeTabID
=
contentBrowser
.
browsingContext
.
browserId
;
info
(
"
Capture
the
profile
data
.
"
)
;
const
profile
=
await
Services
.
profiler
.
getProfileDataAsync
(
)
;
await
Services
.
profiler
.
StopProfiler
(
)
;
let
pageFound
=
false
;
let
contentProcess
=
profile
.
processes
.
find
(
p
=
>
p
.
threads
[
0
]
.
pid
=
=
contentPid
)
;
if
(
!
contentProcess
)
{
throw
new
Error
(
Could
not
find
the
content
process
with
given
pid
:
{
contentPid
}
)
;
}
Assert
.
equal
(
contentProcess
.
threads
[
0
]
.
isPrivateBrowsing
undefined
"
The
content
process
has
no
private
browsing
flag
.
"
)
;
Assert
.
equal
(
contentProcess
.
threads
[
0
]
.
userContextId
undefined
"
The
content
process
has
no
information
about
the
container
used
for
this
process
.
"
)
;
info
(
"
Check
if
the
captured
page
is
the
one
with
correct
values
we
created
.
"
)
;
for
(
const
page
of
contentProcess
.
pages
)
{
if
(
page
.
url
=
=
url
)
{
Assert
.
equal
(
page
.
url
url
)
;
Assert
.
equal
(
typeof
page
.
tabID
"
number
"
)
;
Assert
.
equal
(
page
.
tabID
activeTabID
)
;
Assert
.
equal
(
typeof
page
.
innerWindowID
"
number
"
)
;
Assert
.
equal
(
page
.
embedderInnerWindowID
0
)
;
Assert
.
equal
(
typeof
page
.
isPrivateBrowsing
"
boolean
"
)
;
Assert
.
equal
(
page
.
isPrivateBrowsing
true
)
;
pageFound
=
true
;
break
;
}
}
Assert
.
equal
(
pageFound
true
)
;
}
finally
{
await
BrowserTestUtils
.
closeWindow
(
win
)
;
}
}
)
;
