const
{
BrowserTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
BrowserTestUtils
.
jsm
"
)
;
const
BASE_URL
=
"
http
:
/
/
example
.
com
/
browser
/
tools
/
profiler
/
tests
/
browser
/
"
;
const
defaultSettings
=
{
entries
:
1000000
interval
:
1
features
:
[
"
threads
"
]
threads
:
[
"
GeckoMain
"
]
}
;
function
startProfiler
(
callersSettings
)
{
const
settings
=
Object
.
assign
(
{
}
defaultSettings
callersSettings
)
;
Services
.
profiler
.
StartProfiler
(
settings
.
entries
settings
.
interval
settings
.
features
settings
.
threads
settings
.
duration
)
;
}
async
function
doAtLeastOnePeriodicSample
(
)
{
async
function
getProfileSampleCount
(
)
{
const
profile
=
await
Services
.
profiler
.
getProfileDataAsync
(
)
;
return
profile
.
threads
[
0
]
.
samples
.
data
.
length
;
}
const
sampleCount
=
await
getProfileSampleCount
(
)
;
while
(
true
)
{
if
(
sampleCount
<
(
await
getProfileSampleCount
(
)
)
)
{
return
;
}
}
}
async
function
stopProfilerAndGetThreads
(
contentPid
)
{
await
doAtLeastOnePeriodicSample
(
)
;
const
profile
=
await
Services
.
profiler
.
getProfileDataAsync
(
)
;
Services
.
profiler
.
StopProfiler
(
)
;
const
parentThread
=
profile
.
threads
[
0
]
;
const
contentProcess
=
profile
.
processes
.
find
(
p
=
>
p
.
threads
[
0
]
.
pid
=
=
contentPid
)
;
if
(
!
contentProcess
)
{
throw
new
Error
(
"
Could
not
find
the
content
process
.
"
)
;
}
const
contentThread
=
contentProcess
.
threads
[
0
]
;
if
(
!
parentThread
)
{
throw
new
Error
(
"
The
parent
thread
was
not
found
in
the
profile
.
"
)
;
}
if
(
!
contentThread
)
{
throw
new
Error
(
"
The
content
thread
was
not
found
in
the
profile
.
"
)
;
}
return
{
parentThread
contentThread
}
;
}
function
wait
(
time
)
{
return
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
time
)
;
}
)
;
}
function
getPayloadsOfType
(
thread
type
)
{
const
{
markers
}
=
thread
;
const
results
=
[
]
;
for
(
const
markerTuple
of
markers
.
data
)
{
const
payload
=
markerTuple
[
markers
.
schema
.
data
]
;
if
(
payload
&
&
payload
.
type
=
=
=
type
)
{
results
.
push
(
payload
)
;
}
}
return
results
;
}
