requestLongerTimeout
(
10
)
;
async
function
get_profile_path_on_disk
(
pid
)
{
let
profile
=
FileUtils
.
File
(
await
Downloads
.
getSystemDownloadsDirectory
(
)
)
;
profile
.
append
(
profile_0_
{
pid
}
.
json
)
;
return
profile
;
}
function
check_profile_contains_parent_and_content_pids
(
parent_pid
content_pid
profile
)
{
info
(
Checking
that
the
profile
contains
pids
for
the
parent
process
{
parent_pid
}
and
content
process
{
content_pid
}
)
;
Assert
.
equal
(
profile
.
threads
[
0
]
.
pid
parent_pid
"
We
expect
the
pid
of
the
main
profile
thread
to
be
the
parent
pid
"
)
;
const
child_pids
=
[
]
;
let
found
=
false
;
for
(
const
process
of
profile
.
processes
)
{
child_pids
.
push
(
process
.
threads
[
0
]
.
pid
)
;
if
(
process
.
threads
[
0
]
.
pid
=
=
=
content_pid
)
{
found
=
true
;
info
(
Found
content
pid
:
{
process
.
threads
[
0
]
.
pid
}
.
)
;
}
}
Assert
.
ok
(
found
We
expect
the
child
process
ids
to
contain
the
id
of
the
content
process
(
{
content_pid
}
)
.
Actually
found
:
{
child_pids
}
)
;
}
function
check_profile_for_synthetic_marker
(
profile
)
{
const
markers
=
getInflatedMarkerData
(
profile
.
threads
[
0
]
)
;
{
const
domEventStart
=
markers
.
find
(
(
{
phase
data
}
)
=
>
phase
=
=
=
INTERVAL_START
&
&
data
?
.
eventType
=
=
=
"
synthetic
"
)
;
const
domEventEnd
=
markers
.
find
(
(
{
phase
data
}
)
=
>
phase
=
=
=
INTERVAL_END
&
&
data
?
.
eventType
=
=
=
"
synthetic
"
)
;
ok
(
domEventStart
"
A
start
DOMEvent
was
generated
"
)
;
ok
(
domEventEnd
"
An
end
DOMEvent
was
generated
"
)
;
Assert
.
greater
(
domEventEnd
.
data
.
latency
0
"
DOMEvent
had
a
a
latency
value
generated
.
"
)
;
Assert
.
strictEqual
(
domEventEnd
.
data
.
type
"
DOMEvent
"
)
;
Assert
.
strictEqual
(
domEventEnd
.
name
"
DOMEvent
"
)
;
}
}
add_task
(
async
function
test_profile_feature_multiprocess_start_and_capture_with_signal
(
)
{
Assert
.
ok
(
!
Services
.
profiler
.
IsActive
(
)
"
The
profiler
is
not
currently
active
"
)
;
let
ppid
=
await
ChromeUtils
.
requestProcInfo
(
)
;
let
parent_pid
=
ppid
.
pid
;
let
startPromise
=
TestUtils
.
topicObserved
(
"
profiler
-
started
"
)
;
info
(
Raising
signal
SIGUSR1
with
pid
{
parent_pid
}
to
start
the
profiler
)
;
let
result
=
raiseSignal
(
parent_pid
SIGUSR1
)
;
Assert
.
ok
(
result
"
Raising
a
signal
should
succeed
"
)
;
Assert
.
ok
(
await
startPromise
"
The
profiler
should
start
"
)
;
Assert
.
ok
(
Services
.
profiler
.
IsActive
(
)
"
The
profiler
should
now
be
active
.
"
)
;
const
url
=
BASE_URL
+
"
do_work_500ms
.
html
"
;
await
BrowserTestUtils
.
withNewTab
(
url
async
contentBrowser
=
>
{
info
(
"
Finding
the
PId
of
the
content
process
.
"
)
;
const
content_pid
=
await
SpecialPowers
.
spawn
(
contentBrowser
[
]
(
)
=
>
Services
.
appinfo
.
processID
)
;
info
(
"
Dispatching
a
synthetic
DOMEvent
"
)
;
window
.
dispatchEvent
(
new
Event
(
"
synthetic
"
)
)
;
info
(
"
Waiting
for
the
tab
to
do
some
work
"
)
;
await
wait
(
500
)
;
let
stopPromise
=
TestUtils
.
topicObserved
(
"
profiler
-
stopped
"
)
;
info
(
Raising
signal
SIGUSR2
with
pid
{
parent_pid
}
to
stop
the
profiler
)
;
let
result
=
raiseSignal
(
parent_pid
SIGUSR2
)
;
Assert
.
ok
(
result
"
Raising
a
SIGUSR2
signal
should
succeed
.
"
)
;
info
(
Waiting
for
the
profiler
to
stop
.
)
;
Assert
.
ok
(
await
stopPromise
"
The
profiler
should
stop
"
)
;
info
(
Retrieving
profile
file
.
)
;
let
profile_file
=
await
get_profile_path_on_disk
(
parent_pid
)
;
Assert
.
ok
(
await
IOUtils
.
exists
(
profile_file
.
path
)
"
A
profile
file
should
be
written
to
disk
.
"
)
;
let
profile
=
await
IOUtils
.
readJSON
(
profile_file
.
path
)
;
info
(
"
Found
this
many
proceses
:
"
+
profile
.
processes
.
length
)
;
info
(
Checking
that
the
profile
file
contains
the
parent
and
content
processes
.
)
;
check_profile_contains_parent_and_content_pids
(
parent_pid
content_pid
profile
)
;
info
(
Checking
for
the
synthetic
DOM
marker
)
;
check_profile_for_synthetic_marker
(
profile
)
;
}
)
;
}
)
;
