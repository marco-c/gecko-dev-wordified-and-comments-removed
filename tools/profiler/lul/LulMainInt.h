#
ifndef
LulMainInt_h
#
define
LulMainInt_h
#
include
"
PlatformMacros
.
h
"
#
include
"
LulMain
.
h
"
#
include
<
string
>
#
include
<
vector
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
namespace
lul
{
using
std
:
:
vector
;
enum
DW_REG_NUMBER
{
DW_REG_CFA
=
-
1
#
if
defined
(
GP_ARCH_arm
)
DW_REG_ARM_R7
=
7
DW_REG_ARM_R11
=
11
DW_REG_ARM_R12
=
12
DW_REG_ARM_R13
=
13
DW_REG_ARM_R14
=
14
DW_REG_ARM_R15
=
15
#
elif
defined
(
GP_ARCH_arm64
)
DW_REG_AARCH64_X29
=
29
DW_REG_AARCH64_X30
=
30
DW_REG_AARCH64_SP
=
31
#
elif
defined
(
GP_ARCH_amd64
)
DW_REG_INTEL_XBP
=
6
DW_REG_INTEL_XSP
=
7
DW_REG_INTEL_XIP
=
16
#
elif
defined
(
GP_ARCH_x86
)
DW_REG_INTEL_XBP
=
5
DW_REG_INTEL_XSP
=
4
DW_REG_INTEL_XIP
=
8
#
elif
defined
(
GP_ARCH_mips64
)
DW_REG_MIPS_SP
=
29
DW_REG_MIPS_FP
=
30
DW_REG_MIPS_PC
=
34
#
else
#
error
"
Unknown
arch
"
#
endif
}
;
enum
PfxExprOp
{
PX_Start
PX_End
PX_SImm32
PX_DwReg
PX_Deref
PX_Add
PX_Sub
PX_And
PX_Or
PX_CmpGES
PX_Shl
}
;
struct
PfxInstr
{
PfxInstr
(
PfxExprOp
opcode
int32_t
operand
)
:
mOpcode
(
opcode
)
mOperand
(
operand
)
{
}
explicit
PfxInstr
(
PfxExprOp
opcode
)
:
mOpcode
(
opcode
)
mOperand
(
0
)
{
}
bool
operator
=
=
(
const
PfxInstr
&
other
)
const
{
return
mOpcode
=
=
other
.
mOpcode
&
&
mOperand
=
=
other
.
mOperand
;
}
PfxExprOp
mOpcode
;
int32_t
mOperand
;
}
;
static_assert
(
sizeof
(
PfxInstr
)
<
=
8
"
PfxInstr
size
changed
unexpectedly
"
)
;
TaggedUWord
EvaluatePfxExpr
(
int32_t
start
const
UnwindRegs
*
aOldRegs
TaggedUWord
aCFA
const
StackImage
*
aStackImg
const
vector
<
PfxInstr
>
&
aPfxInstrs
)
;
enum
LExprHow
{
UNKNOWN
=
0
NODEREF
DEREF
PFXEXPR
}
;
inline
static
const
char
*
NameOf_LExprHow
(
LExprHow
how
)
{
switch
(
how
)
{
case
UNKNOWN
:
return
"
UNKNOWN
"
;
case
NODEREF
:
return
"
NODEREF
"
;
case
DEREF
:
return
"
DEREF
"
;
case
PFXEXPR
:
return
"
PFXEXPR
"
;
default
:
return
"
LExpr
-
?
?
"
;
}
}
struct
LExpr
{
LExpr
(
)
:
mHow
(
UNKNOWN
)
mReg
(
0
)
mOffset
(
0
)
{
}
LExpr
(
LExprHow
how
int16_t
reg
int32_t
offset
)
:
mHow
(
how
)
mReg
(
reg
)
mOffset
(
offset
)
{
switch
(
how
)
{
case
UNKNOWN
:
MOZ_ASSERT
(
reg
=
=
0
&
&
offset
=
=
0
)
;
break
;
case
NODEREF
:
break
;
case
DEREF
:
break
;
case
PFXEXPR
:
MOZ_ASSERT
(
reg
=
=
0
&
&
offset
>
=
0
)
;
break
;
default
:
MOZ_RELEASE_ASSERT
(
0
"
LExpr
:
:
LExpr
:
invalid
how
"
)
;
}
}
mozilla
:
:
HashNumber
hash
(
)
const
{
mozilla
:
:
HashNumber
h
=
mHow
;
switch
(
mHow
)
{
case
UNKNOWN
:
break
;
case
NODEREF
:
case
DEREF
:
h
=
mozilla
:
:
AddToHash
(
h
mReg
)
;
h
=
mozilla
:
:
AddToHash
(
h
mOffset
)
;
break
;
case
PFXEXPR
:
h
=
mozilla
:
:
AddToHash
(
h
mOffset
)
;
break
;
default
:
MOZ_RELEASE_ASSERT
(
0
"
LExpr
:
:
hash
:
invalid
how
"
)
;
}
return
h
;
}
bool
equals
(
const
LExpr
&
other
)
const
{
if
(
mHow
!
=
other
.
mHow
)
{
return
false
;
}
switch
(
mHow
)
{
case
UNKNOWN
:
return
true
;
case
NODEREF
:
case
DEREF
:
return
mReg
=
=
other
.
mReg
&
&
mOffset
=
=
other
.
mOffset
;
case
PFXEXPR
:
return
mOffset
=
=
other
.
mOffset
;
default
:
MOZ_RELEASE_ASSERT
(
0
"
LExpr
:
:
equals
:
invalid
how
"
)
;
}
}
LExpr
add_delta
(
long
delta
)
{
MOZ_ASSERT
(
mHow
=
=
NODEREF
)
;
return
(
mHow
=
=
NODEREF
)
?
LExpr
(
mHow
mReg
mOffset
+
delta
)
:
LExpr
(
)
;
}
LExpr
deref
(
)
{
MOZ_ASSERT
(
mHow
=
=
NODEREF
)
;
return
(
mHow
=
=
NODEREF
)
?
LExpr
(
DEREF
mReg
mOffset
)
:
LExpr
(
)
;
}
std
:
:
string
ShowRule
(
const
char
*
aNewReg
)
const
;
TaggedUWord
EvaluateExpr
(
const
UnwindRegs
*
aOldRegs
TaggedUWord
aCFA
const
StackImage
*
aStackImg
const
vector
<
PfxInstr
>
*
aPfxInstrs
)
const
;
LExprHow
mHow
:
8
;
int16_t
mReg
;
int32_t
mOffset
;
}
;
static_assert
(
sizeof
(
LExpr
)
<
=
8
"
LExpr
size
changed
unexpectedly
"
)
;
class
RuleSet
{
public
:
RuleSet
(
)
;
void
Print
(
uintptr_t
avma
uintptr_t
len
void
(
*
aLog
)
(
const
char
*
)
)
const
;
LExpr
*
ExprForRegno
(
DW_REG_NUMBER
aRegno
)
;
LExpr
mCfaExpr
;
#
if
defined
(
GP_ARCH_amd64
)
|
|
defined
(
GP_ARCH_x86
)
LExpr
mXipExpr
;
LExpr
mXspExpr
;
LExpr
mXbpExpr
;
#
elif
defined
(
GP_ARCH_arm
)
LExpr
mR15expr
;
LExpr
mR14expr
;
LExpr
mR13expr
;
LExpr
mR12expr
;
LExpr
mR11expr
;
LExpr
mR7expr
;
#
elif
defined
(
GP_ARCH_arm64
)
LExpr
mX29expr
;
LExpr
mX30expr
;
LExpr
mSPexpr
;
#
elif
defined
(
GP_ARCH_mips64
)
LExpr
mPCexpr
;
LExpr
mFPexpr
;
LExpr
mSPexpr
;
#
else
#
error
"
Unknown
arch
"
#
endif
typedef
RuleSet
Lookup
;
static
mozilla
:
:
HashNumber
hash
(
RuleSet
rs
)
{
mozilla
:
:
HashNumber
h
=
rs
.
mCfaExpr
.
hash
(
)
;
#
if
defined
(
GP_ARCH_amd64
)
|
|
defined
(
GP_ARCH_x86
)
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mXipExpr
.
hash
(
)
)
;
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mXspExpr
.
hash
(
)
)
;
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mXbpExpr
.
hash
(
)
)
;
#
elif
defined
(
GP_ARCH_arm
)
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mR15expr
.
hash
(
)
)
;
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mR14expr
.
hash
(
)
)
;
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mR13expr
.
hash
(
)
)
;
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mR12expr
.
hash
(
)
)
;
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mR11expr
.
hash
(
)
)
;
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mR7expr
.
hash
(
)
)
;
#
elif
defined
(
GP_ARCH_arm64
)
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mX29expr
.
hash
(
)
)
;
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mX30expr
.
hash
(
)
)
;
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mSPexpr
.
hash
(
)
)
;
#
elif
defined
(
GP_ARCH_mips64
)
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mPCexpr
.
hash
(
)
)
;
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mFPexpr
.
hash
(
)
)
;
h
=
mozilla
:
:
AddToHash
(
h
rs
.
mSPexpr
.
hash
(
)
)
;
#
else
#
error
"
Unknown
arch
"
#
endif
return
h
;
}
static
bool
match
(
const
RuleSet
&
rs1
const
RuleSet
&
rs2
)
{
return
rs1
.
mCfaExpr
.
equals
(
rs2
.
mCfaExpr
)
&
&
#
if
defined
(
GP_ARCH_amd64
)
|
|
defined
(
GP_ARCH_x86
)
rs1
.
mXipExpr
.
equals
(
rs2
.
mXipExpr
)
&
&
rs1
.
mXspExpr
.
equals
(
rs2
.
mXspExpr
)
&
&
rs1
.
mXbpExpr
.
equals
(
rs2
.
mXbpExpr
)
;
#
elif
defined
(
GP_ARCH_arm
)
rs1
.
mR15expr
.
equals
(
rs2
.
mR15expr
)
&
&
rs1
.
mR14expr
.
equals
(
rs2
.
mR14expr
)
&
&
rs1
.
mR13expr
.
equals
(
rs2
.
mR13expr
)
&
&
rs1
.
mR12expr
.
equals
(
rs2
.
mR12expr
)
&
&
rs1
.
mR11expr
.
equals
(
rs2
.
mR11expr
)
&
&
rs1
.
mR7expr
.
equals
(
rs2
.
mR7expr
)
;
#
elif
defined
(
GP_ARCH_arm64
)
rs1
.
mX29expr
.
equals
(
rs2
.
mX29expr
)
&
&
rs1
.
mX30expr
.
equals
(
rs2
.
mX30expr
)
&
&
rs1
.
mSPexpr
.
equals
(
rs2
.
mSPexpr
)
;
#
elif
defined
(
GP_ARCH_mips64
)
rs1
.
mPCexpr
.
equals
(
rs2
.
mPCexpr
)
&
&
rs1
.
mFPexpr
.
equals
(
rs2
.
mFPexpr
)
&
&
rs1
.
mSPexpr
.
equals
(
rs2
.
mSPexpr
)
;
#
else
#
error
"
Unknown
arch
"
#
endif
}
}
;
static
inline
bool
registerIsTracked
(
DW_REG_NUMBER
reg
)
{
switch
(
reg
)
{
#
if
defined
(
GP_ARCH_amd64
)
|
|
defined
(
GP_ARCH_x86
)
case
DW_REG_INTEL_XBP
:
case
DW_REG_INTEL_XSP
:
case
DW_REG_INTEL_XIP
:
return
true
;
#
elif
defined
(
GP_ARCH_arm
)
case
DW_REG_ARM_R7
:
case
DW_REG_ARM_R11
:
case
DW_REG_ARM_R12
:
case
DW_REG_ARM_R13
:
case
DW_REG_ARM_R14
:
case
DW_REG_ARM_R15
:
return
true
;
#
elif
defined
(
GP_ARCH_arm64
)
case
DW_REG_AARCH64_X29
:
case
DW_REG_AARCH64_X30
:
case
DW_REG_AARCH64_SP
:
return
true
;
#
elif
defined
(
GP_ARCH_mips64
)
case
DW_REG_MIPS_FP
:
case
DW_REG_MIPS_SP
:
case
DW_REG_MIPS_PC
:
return
true
;
#
else
#
error
"
Unknown
arch
"
#
endif
default
:
return
false
;
}
}
struct
Extent
{
uint32_t
mOffset
;
uint16_t
mLen
;
uint16_t
mDictIx
;
Extent
(
uint32_t
offset
uint32_t
len
uint32_t
dictIx
)
{
MOZ_RELEASE_ASSERT
(
len
<
(
1
<
<
16
)
)
;
MOZ_RELEASE_ASSERT
(
dictIx
<
(
1
<
<
16
)
)
;
mOffset
=
offset
;
mLen
=
len
;
mDictIx
=
dictIx
;
}
uint32_t
offset
(
)
const
{
return
mOffset
;
}
uint32_t
len
(
)
const
{
return
mLen
;
}
uint32_t
dictIx
(
)
const
{
return
mDictIx
;
}
void
setLen
(
uint32_t
len
)
{
MOZ_RELEASE_ASSERT
(
len
<
(
1
<
<
16
)
)
;
mLen
=
len
;
}
void
Print
(
void
(
*
aLog
)
(
const
char
*
)
)
const
{
char
buf
[
64
]
;
SprintfLiteral
(
buf
"
Extent
(
offs
=
0x
%
x
len
=
%
u
dictIx
=
%
u
)
"
this
-
>
offset
(
)
this
-
>
len
(
)
this
-
>
dictIx
(
)
)
;
aLog
(
buf
)
;
}
}
;
static_assert
(
sizeof
(
Extent
)
=
=
8
)
;
class
SecMap
{
public
:
SecMap
(
uintptr_t
mapStartAVMA
uint32_t
mapLen
void
(
*
aLog
)
(
const
char
*
)
)
;
~
SecMap
(
)
;
RuleSet
*
FindRuleSet
(
uintptr_t
ia
)
;
void
AddRuleSet
(
const
RuleSet
*
rs
uintptr_t
avma
uintptr_t
len
)
;
uint32_t
AddPfxInstr
(
PfxInstr
pfxi
)
;
const
vector
<
PfxInstr
>
*
GetPfxInstrs
(
)
{
return
&
mPfxInstrs
;
}
void
PrepareRuleSets
(
)
;
bool
IsEmpty
(
)
;
size_t
Size
(
)
{
return
mExtents
.
size
(
)
+
mDictionary
.
size
(
)
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
uintptr_t
mMapMinAVMA
;
uintptr_t
mMapMaxAVMA
;
private
:
bool
mUsable
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
HashMap
<
RuleSet
uint32_t
RuleSet
InfallibleAllocPolicy
>
>
mUniqifier
;
vector
<
RuleSet
>
mDictionary
;
vector
<
Extent
>
mExtents
;
vector
<
PfxInstr
>
mPfxInstrs
;
void
(
*
mLog
)
(
const
char
*
)
;
}
;
}
#
endif
