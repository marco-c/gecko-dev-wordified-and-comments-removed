#
include
"
LulMain
.
h
"
#
include
<
string
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
include
<
unistd
.
h
>
#
include
<
algorithm
>
#
include
<
string
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
MemoryChecking
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
LulCommonExt
.
h
"
#
include
"
LulElfExt
.
h
"
#
include
"
LulMainInt
.
h
"
#
include
"
platform
-
linux
-
lul
.
h
"
#
define
DEBUG_MAIN
0
namespace
lul
{
using
mozilla
:
:
CheckedInt
;
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
MallocSizeOf
;
using
mozilla
:
:
Unused
;
using
std
:
:
pair
;
using
std
:
:
string
;
using
std
:
:
vector
;
static
const
char
*
NameOf_DW_REG
(
int16_t
aReg
)
{
switch
(
aReg
)
{
case
DW_REG_CFA
:
return
"
cfa
"
;
#
if
defined
(
GP_ARCH_amd64
)
|
|
defined
(
GP_ARCH_x86
)
case
DW_REG_INTEL_XBP
:
return
"
xbp
"
;
case
DW_REG_INTEL_XSP
:
return
"
xsp
"
;
case
DW_REG_INTEL_XIP
:
return
"
xip
"
;
#
elif
defined
(
GP_ARCH_arm
)
case
DW_REG_ARM_R7
:
return
"
r7
"
;
case
DW_REG_ARM_R11
:
return
"
r11
"
;
case
DW_REG_ARM_R12
:
return
"
r12
"
;
case
DW_REG_ARM_R13
:
return
"
r13
"
;
case
DW_REG_ARM_R14
:
return
"
r14
"
;
case
DW_REG_ARM_R15
:
return
"
r15
"
;
#
elif
defined
(
GP_ARCH_arm64
)
case
DW_REG_AARCH64_X29
:
return
"
x29
"
;
case
DW_REG_AARCH64_X30
:
return
"
x30
"
;
case
DW_REG_AARCH64_SP
:
return
"
sp
"
;
#
elif
defined
(
GP_ARCH_mips64
)
case
DW_REG_MIPS_SP
:
return
"
sp
"
;
case
DW_REG_MIPS_FP
:
return
"
fp
"
;
case
DW_REG_MIPS_PC
:
return
"
pc
"
;
#
else
#
error
"
Unsupported
arch
"
#
endif
default
:
return
"
?
?
?
"
;
}
}
string
LExpr
:
:
ShowRule
(
const
char
*
aNewReg
)
const
{
char
buf
[
64
]
;
string
res
=
string
(
aNewReg
)
+
"
=
"
;
switch
(
mHow
)
{
case
UNKNOWN
:
res
+
=
"
Unknown
"
;
break
;
case
NODEREF
:
SprintfLiteral
(
buf
"
%
s
+
%
d
"
NameOf_DW_REG
(
mReg
)
(
int
)
mOffset
)
;
res
+
=
buf
;
break
;
case
DEREF
:
SprintfLiteral
(
buf
"
*
(
%
s
+
%
d
)
"
NameOf_DW_REG
(
mReg
)
(
int
)
mOffset
)
;
res
+
=
buf
;
break
;
case
PFXEXPR
:
SprintfLiteral
(
buf
"
PfxExpr
-
at
-
%
d
"
(
int
)
mOffset
)
;
res
+
=
buf
;
break
;
default
:
res
+
=
"
?
?
?
"
;
break
;
}
return
res
;
}
void
RuleSet
:
:
Print
(
void
(
*
aLog
)
(
const
char
*
)
)
const
{
char
buf
[
96
]
;
SprintfLiteral
(
buf
"
[
%
llx
.
.
%
llx
]
:
let
"
(
unsigned
long
long
int
)
mAddr
(
unsigned
long
long
int
)
(
mAddr
+
mLen
-
1
)
)
;
string
res
=
string
(
buf
)
;
res
+
=
mCfaExpr
.
ShowRule
(
"
cfa
"
)
;
res
+
=
"
in
"
;
#
if
defined
(
GP_ARCH_amd64
)
|
|
defined
(
GP_ARCH_x86
)
res
+
=
mXipExpr
.
ShowRule
(
"
RA
"
)
;
res
+
=
mXspExpr
.
ShowRule
(
"
SP
"
)
;
res
+
=
mXbpExpr
.
ShowRule
(
"
BP
"
)
;
#
elif
defined
(
GP_ARCH_arm
)
res
+
=
mR15expr
.
ShowRule
(
"
R15
"
)
;
res
+
=
mR7expr
.
ShowRule
(
"
R7
"
)
;
res
+
=
mR11expr
.
ShowRule
(
"
R11
"
)
;
res
+
=
mR12expr
.
ShowRule
(
"
R12
"
)
;
res
+
=
mR13expr
.
ShowRule
(
"
R13
"
)
;
res
+
=
mR14expr
.
ShowRule
(
"
R14
"
)
;
#
elif
defined
(
GP_ARCH_arm64
)
res
+
=
mX29expr
.
ShowRule
(
"
X29
"
)
;
res
+
=
mX30expr
.
ShowRule
(
"
X30
"
)
;
res
+
=
mSPexpr
.
ShowRule
(
"
SP
"
)
;
#
elif
defined
(
GP_ARCH_mips64
)
res
+
=
mPCexpr
.
ShowRule
(
"
PC
"
)
;
res
+
=
mSPexpr
.
ShowRule
(
"
SP
"
)
;
res
+
=
mFPexpr
.
ShowRule
(
"
FP
"
)
;
#
else
#
error
"
Unsupported
arch
"
#
endif
aLog
(
res
.
c_str
(
)
)
;
}
LExpr
*
RuleSet
:
:
ExprForRegno
(
DW_REG_NUMBER
aRegno
)
{
switch
(
aRegno
)
{
case
DW_REG_CFA
:
return
&
mCfaExpr
;
#
if
defined
(
GP_ARCH_amd64
)
|
|
defined
(
GP_ARCH_x86
)
case
DW_REG_INTEL_XIP
:
return
&
mXipExpr
;
case
DW_REG_INTEL_XSP
:
return
&
mXspExpr
;
case
DW_REG_INTEL_XBP
:
return
&
mXbpExpr
;
#
elif
defined
(
GP_ARCH_arm
)
case
DW_REG_ARM_R15
:
return
&
mR15expr
;
case
DW_REG_ARM_R14
:
return
&
mR14expr
;
case
DW_REG_ARM_R13
:
return
&
mR13expr
;
case
DW_REG_ARM_R12
:
return
&
mR12expr
;
case
DW_REG_ARM_R11
:
return
&
mR11expr
;
case
DW_REG_ARM_R7
:
return
&
mR7expr
;
#
elif
defined
(
GP_ARCH_arm64
)
case
DW_REG_AARCH64_X29
:
return
&
mX29expr
;
case
DW_REG_AARCH64_X30
:
return
&
mX30expr
;
case
DW_REG_AARCH64_SP
:
return
&
mSPexpr
;
#
elif
defined
(
GP_ARCH_mips64
)
case
DW_REG_MIPS_SP
:
return
&
mSPexpr
;
case
DW_REG_MIPS_FP
:
return
&
mFPexpr
;
case
DW_REG_MIPS_PC
:
return
&
mPCexpr
;
#
else
#
error
"
Unknown
arch
"
#
endif
default
:
return
nullptr
;
}
}
RuleSet
:
:
RuleSet
(
)
{
mAddr
=
0
;
mLen
=
0
;
}
SecMap
:
:
SecMap
(
void
(
*
aLog
)
(
const
char
*
)
)
:
mSummaryMinAddr
(
1
)
mSummaryMaxAddr
(
0
)
mUsable
(
true
)
mLog
(
aLog
)
{
}
SecMap
:
:
~
SecMap
(
)
{
mRuleSets
.
clear
(
)
;
}
RuleSet
*
SecMap
:
:
FindRuleSet
(
uintptr_t
ia
)
{
MOZ_ASSERT
(
mUsable
)
;
long
int
lo
=
0
;
long
int
hi
=
(
long
int
)
mRuleSets
.
size
(
)
-
1
;
while
(
true
)
{
if
(
lo
>
hi
)
{
return
nullptr
;
}
long
int
mid
=
lo
+
(
(
hi
-
lo
)
/
2
)
;
RuleSet
*
mid_ruleSet
=
&
mRuleSets
[
mid
]
;
uintptr_t
mid_minAddr
=
mid_ruleSet
-
>
mAddr
;
uintptr_t
mid_maxAddr
=
mid_minAddr
+
mid_ruleSet
-
>
mLen
-
1
;
if
(
ia
<
mid_minAddr
)
{
hi
=
mid
-
1
;
continue
;
}
if
(
ia
>
mid_maxAddr
)
{
lo
=
mid
+
1
;
continue
;
}
MOZ_ASSERT
(
mid_minAddr
<
=
ia
&
&
ia
<
=
mid_maxAddr
)
;
return
mid_ruleSet
;
}
}
void
SecMap
:
:
AddRuleSet
(
const
RuleSet
*
rs
)
{
mUsable
=
false
;
mRuleSets
.
push_back
(
*
rs
)
;
}
uint32_t
SecMap
:
:
AddPfxInstr
(
PfxInstr
pfxi
)
{
mUsable
=
false
;
mPfxInstrs
.
push_back
(
pfxi
)
;
return
mPfxInstrs
.
size
(
)
-
1
;
}
static
bool
CmpRuleSetsByAddrLE
(
const
RuleSet
&
rs1
const
RuleSet
&
rs2
)
{
return
rs1
.
mAddr
<
rs2
.
mAddr
;
}
void
SecMap
:
:
PrepareRuleSets
(
uintptr_t
aStart
size_t
aLen
)
{
if
(
mRuleSets
.
empty
(
)
)
{
return
;
}
MOZ_ASSERT
(
aLen
>
0
)
;
if
(
aLen
=
=
0
)
{
mRuleSets
.
clear
(
)
;
return
;
}
std
:
:
sort
(
mRuleSets
.
begin
(
)
mRuleSets
.
end
(
)
CmpRuleSetsByAddrLE
)
;
for
(
size_t
i
=
0
;
i
<
mRuleSets
.
size
(
)
;
+
+
i
)
{
RuleSet
*
rs
=
&
mRuleSets
[
i
]
;
if
(
rs
-
>
mLen
>
0
&
&
(
rs
-
>
mAddr
<
aStart
|
|
rs
-
>
mAddr
+
rs
-
>
mLen
>
aStart
+
aLen
)
)
{
rs
-
>
mLen
=
0
;
}
}
while
(
true
)
{
size_t
i
;
size_t
n
=
mRuleSets
.
size
(
)
;
size_t
nZeroLen
=
0
;
if
(
n
=
=
0
)
{
break
;
}
for
(
i
=
1
;
i
<
n
;
+
+
i
)
{
RuleSet
*
prev
=
&
mRuleSets
[
i
-
1
]
;
RuleSet
*
here
=
&
mRuleSets
[
i
]
;
MOZ_ASSERT
(
prev
-
>
mAddr
<
=
here
-
>
mAddr
)
;
if
(
prev
-
>
mAddr
+
prev
-
>
mLen
>
here
-
>
mAddr
)
{
prev
-
>
mLen
=
here
-
>
mAddr
-
prev
-
>
mAddr
;
}
if
(
prev
-
>
mLen
=
=
0
)
nZeroLen
+
+
;
}
if
(
mRuleSets
[
n
-
1
]
.
mLen
=
=
0
)
{
nZeroLen
+
+
;
}
if
(
nZeroLen
=
=
0
)
{
break
;
}
size_t
j
=
0
;
for
(
i
=
0
;
i
<
n
;
+
+
i
)
{
if
(
mRuleSets
[
i
]
.
mLen
=
=
0
)
{
continue
;
}
if
(
j
!
=
i
)
mRuleSets
[
j
]
=
mRuleSets
[
i
]
;
+
+
j
;
}
MOZ_ASSERT
(
i
=
=
n
)
;
MOZ_ASSERT
(
nZeroLen
<
=
n
)
;
MOZ_ASSERT
(
j
=
=
n
-
nZeroLen
)
;
while
(
nZeroLen
>
0
)
{
mRuleSets
.
pop_back
(
)
;
nZeroLen
-
-
;
}
MOZ_ASSERT
(
mRuleSets
.
size
(
)
=
=
j
)
;
}
size_t
n
=
mRuleSets
.
size
(
)
;
#
ifdef
DEBUG
if
(
n
>
0
)
{
MOZ_ASSERT
(
mRuleSets
[
0
]
.
mLen
>
0
)
;
for
(
size_t
i
=
1
;
i
<
n
;
+
+
i
)
{
RuleSet
*
prev
=
&
mRuleSets
[
i
-
1
]
;
RuleSet
*
here
=
&
mRuleSets
[
i
]
;
MOZ_ASSERT
(
prev
-
>
mAddr
<
here
-
>
mAddr
)
;
MOZ_ASSERT
(
here
-
>
mLen
>
0
)
;
MOZ_ASSERT
(
prev
-
>
mAddr
+
prev
-
>
mLen
<
=
here
-
>
mAddr
)
;
}
}
#
endif
if
(
n
=
=
0
)
{
mSummaryMinAddr
=
1
;
mSummaryMaxAddr
=
0
;
}
else
{
mSummaryMinAddr
=
mRuleSets
[
0
]
.
mAddr
;
mSummaryMaxAddr
=
mRuleSets
[
n
-
1
]
.
mAddr
+
mRuleSets
[
n
-
1
]
.
mLen
-
1
;
}
char
buf
[
150
]
;
SprintfLiteral
(
buf
"
PrepareRuleSets
:
%
d
entries
smin
/
smax
0x
%
llx
0x
%
llx
\
n
"
(
int
)
n
(
unsigned
long
long
int
)
mSummaryMinAddr
(
unsigned
long
long
int
)
mSummaryMaxAddr
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
mLog
(
buf
)
;
mUsable
=
true
;
#
if
0
mLog
(
"
\
nRulesets
after
preening
\
n
"
)
;
for
(
size_t
i
=
0
;
i
<
mRuleSets
.
size
(
)
;
+
+
i
)
{
mRuleSets
[
i
]
.
Print
(
mLog
)
;
mLog
(
"
\
n
"
)
;
}
mLog
(
"
\
n
"
)
;
#
endif
}
bool
SecMap
:
:
IsEmpty
(
)
{
return
mRuleSets
.
empty
(
)
;
}
size_t
SecMap
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
aMallocSizeOf
(
mRuleSets
.
data
(
)
)
;
n
+
=
aMallocSizeOf
(
mPfxInstrs
.
data
(
)
)
;
return
n
;
}
class
SegArray
{
public
:
void
add
(
uintptr_t
lo
uintptr_t
hi
bool
val
)
{
if
(
lo
>
hi
)
{
return
;
}
split_at
(
lo
)
;
if
(
hi
<
UINTPTR_MAX
)
{
split_at
(
hi
+
1
)
;
}
std
:
:
vector
<
Seg
>
:
:
size_type
iLo
iHi
i
;
iLo
=
find
(
lo
)
;
iHi
=
find
(
hi
)
;
for
(
i
=
iLo
;
i
<
=
iHi
;
+
+
i
)
{
mSegs
[
i
]
.
val
=
val
;
}
preen
(
)
;
}
bool
getBoundingCodeSegment
(
uintptr_t
*
rx_min
uintptr_t
*
rx_max
uintptr_t
addr
)
{
std
:
:
vector
<
Seg
>
:
:
size_type
i
=
find
(
addr
)
;
if
(
!
mSegs
[
i
]
.
val
)
{
return
false
;
}
*
rx_min
=
mSegs
[
i
]
.
lo
;
*
rx_max
=
mSegs
[
i
]
.
hi
;
return
true
;
}
SegArray
(
)
{
Seg
s
(
0
UINTPTR_MAX
false
)
;
mSegs
.
push_back
(
s
)
;
}
private
:
struct
Seg
{
Seg
(
uintptr_t
lo
uintptr_t
hi
bool
val
)
:
lo
(
lo
)
hi
(
hi
)
val
(
val
)
{
}
uintptr_t
lo
;
uintptr_t
hi
;
bool
val
;
}
;
void
preen
(
)
{
for
(
std
:
:
vector
<
Seg
>
:
:
iterator
iter
=
mSegs
.
begin
(
)
;
iter
<
mSegs
.
end
(
)
-
1
;
+
+
iter
)
{
if
(
iter
[
0
]
.
val
!
=
iter
[
1
]
.
val
)
{
continue
;
}
iter
[
0
]
.
hi
=
iter
[
1
]
.
hi
;
mSegs
.
erase
(
iter
+
1
)
;
-
-
iter
;
}
}
std
:
:
vector
<
Seg
>
:
:
size_type
find
(
uintptr_t
a
)
{
long
int
lo
=
0
;
long
int
hi
=
(
long
int
)
mSegs
.
size
(
)
;
while
(
true
)
{
if
(
lo
>
hi
)
{
return
(
std
:
:
vector
<
Seg
>
:
:
size_type
)
(
-
1
)
;
}
long
int
mid
=
lo
+
(
(
hi
-
lo
)
/
2
)
;
uintptr_t
mid_lo
=
mSegs
[
mid
]
.
lo
;
uintptr_t
mid_hi
=
mSegs
[
mid
]
.
hi
;
if
(
a
<
mid_lo
)
{
hi
=
mid
-
1
;
continue
;
}
if
(
a
>
mid_hi
)
{
lo
=
mid
+
1
;
continue
;
}
return
(
std
:
:
vector
<
Seg
>
:
:
size_type
)
mid
;
}
}
void
split_at
(
uintptr_t
a
)
{
std
:
:
vector
<
Seg
>
:
:
size_type
i
=
find
(
a
)
;
if
(
mSegs
[
i
]
.
lo
=
=
a
)
{
return
;
}
mSegs
.
insert
(
mSegs
.
begin
(
)
+
i
+
1
mSegs
[
i
]
)
;
mSegs
[
i
]
.
hi
=
a
-
1
;
mSegs
[
i
+
1
]
.
lo
=
a
;
}
void
show
(
)
{
printf
(
"
<
<
%
d
entries
:
\
n
"
(
int
)
mSegs
.
size
(
)
)
;
for
(
std
:
:
vector
<
Seg
>
:
:
iterator
iter
=
mSegs
.
begin
(
)
;
iter
<
mSegs
.
end
(
)
;
+
+
iter
)
{
printf
(
"
%
016llx
%
016llx
%
s
\
n
"
(
unsigned
long
long
int
)
(
*
iter
)
.
lo
(
unsigned
long
long
int
)
(
*
iter
)
.
hi
(
*
iter
)
.
val
?
"
true
"
:
"
false
"
)
;
}
printf
(
"
>
>
\
n
"
)
;
}
std
:
:
vector
<
Seg
>
mSegs
;
}
;
class
PriMap
{
public
:
explicit
PriMap
(
void
(
*
aLog
)
(
const
char
*
)
)
:
mLog
(
aLog
)
{
}
pair
<
const
RuleSet
*
const
vector
<
PfxInstr
>
*
>
Lookup
(
uintptr_t
ia
)
{
SecMap
*
sm
=
FindSecMap
(
ia
)
;
return
pair
<
const
RuleSet
*
const
vector
<
PfxInstr
>
*
>
(
sm
?
sm
-
>
FindRuleSet
(
ia
)
:
nullptr
sm
?
sm
-
>
GetPfxInstrs
(
)
:
nullptr
)
;
}
void
AddSecMap
(
mozilla
:
:
UniquePtr
<
SecMap
>
&
&
aSecMap
)
{
if
(
aSecMap
-
>
IsEmpty
(
)
)
{
return
;
}
MOZ_ASSERT
(
aSecMap
-
>
mSummaryMinAddr
<
=
aSecMap
-
>
mSummaryMaxAddr
)
;
size_t
num_secMaps
=
mSecMaps
.
size
(
)
;
uintptr_t
i
;
for
(
i
=
0
;
i
<
num_secMaps
;
+
+
i
)
{
mozilla
:
:
UniquePtr
<
SecMap
>
&
sm_i
=
mSecMaps
[
i
]
;
MOZ_ASSERT
(
sm_i
-
>
mSummaryMinAddr
<
=
sm_i
-
>
mSummaryMaxAddr
)
;
if
(
aSecMap
-
>
mSummaryMinAddr
<
sm_i
-
>
mSummaryMaxAddr
)
{
break
;
}
}
MOZ_ASSERT
(
i
<
=
num_secMaps
)
;
if
(
i
=
=
num_secMaps
)
{
mSecMaps
.
push_back
(
std
:
:
move
(
aSecMap
)
)
;
}
else
{
std
:
:
vector
<
mozilla
:
:
UniquePtr
<
SecMap
>
>
:
:
iterator
iter
=
mSecMaps
.
begin
(
)
+
i
;
mSecMaps
.
insert
(
iter
std
:
:
move
(
aSecMap
)
)
;
}
char
buf
[
100
]
;
SprintfLiteral
(
buf
"
AddSecMap
:
now
have
%
d
SecMaps
\
n
"
(
int
)
mSecMaps
.
size
(
)
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
mLog
(
buf
)
;
}
void
RemoveSecMapsInRange
(
uintptr_t
avma_min
uintptr_t
avma_max
)
{
MOZ_ASSERT
(
avma_min
<
=
avma_max
)
;
size_t
num_secMaps
=
mSecMaps
.
size
(
)
;
if
(
num_secMaps
>
0
)
{
intptr_t
i
;
for
(
i
=
(
intptr_t
)
num_secMaps
-
1
;
i
>
=
0
;
i
-
-
)
{
mozilla
:
:
UniquePtr
<
SecMap
>
&
sm_i
=
mSecMaps
[
i
]
;
if
(
sm_i
-
>
mSummaryMaxAddr
<
avma_min
|
|
avma_max
<
sm_i
-
>
mSummaryMinAddr
)
{
continue
;
}
mSecMaps
.
erase
(
mSecMaps
.
begin
(
)
+
i
)
;
}
}
}
size_t
CountSecMaps
(
)
{
return
mSecMaps
.
size
(
)
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
aMallocSizeOf
(
mSecMaps
.
data
(
)
)
;
for
(
size_t
i
=
0
;
i
<
mSecMaps
.
size
(
)
;
i
+
+
)
{
n
+
=
mSecMaps
[
i
]
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
private
:
SecMap
*
FindSecMap
(
uintptr_t
ia
)
{
long
int
lo
=
0
;
long
int
hi
=
(
long
int
)
mSecMaps
.
size
(
)
-
1
;
while
(
true
)
{
if
(
lo
>
hi
)
{
return
nullptr
;
}
long
int
mid
=
lo
+
(
(
hi
-
lo
)
/
2
)
;
mozilla
:
:
UniquePtr
<
SecMap
>
&
mid_secMap
=
mSecMaps
[
mid
]
;
uintptr_t
mid_minAddr
=
mid_secMap
-
>
mSummaryMinAddr
;
uintptr_t
mid_maxAddr
=
mid_secMap
-
>
mSummaryMaxAddr
;
if
(
ia
<
mid_minAddr
)
{
hi
=
mid
-
1
;
continue
;
}
if
(
ia
>
mid_maxAddr
)
{
lo
=
mid
+
1
;
continue
;
}
MOZ_ASSERT
(
mid_minAddr
<
=
ia
&
&
ia
<
=
mid_maxAddr
)
;
return
mid_secMap
.
get
(
)
;
}
}
private
:
std
:
:
vector
<
mozilla
:
:
UniquePtr
<
SecMap
>
>
mSecMaps
;
void
(
*
mLog
)
(
const
char
*
)
;
}
;
#
define
LUL_LOG
(
_str
)
\
do
{
\
char
buf
[
200
]
;
\
SprintfLiteral
(
buf
"
LUL
:
pid
%
d
tid
%
d
lul
-
obj
%
p
:
%
s
"
getpid
(
)
\
gettid
(
)
this
(
_str
)
)
;
\
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
\
mLog
(
buf
)
;
\
}
while
(
0
)
LUL
:
:
LUL
(
void
(
*
aLog
)
(
const
char
*
)
)
:
mLog
(
aLog
)
mAdminMode
(
true
)
mAdminThreadId
(
gettid
(
)
)
mPriMap
(
new
PriMap
(
aLog
)
)
mSegArray
(
new
SegArray
(
)
)
mUSU
(
new
UniqueStringUniverse
(
)
)
{
LUL_LOG
(
"
LUL
:
:
LUL
:
Created
object
"
)
;
}
LUL
:
:
~
LUL
(
)
{
LUL_LOG
(
"
LUL
:
:
~
LUL
:
Destroyed
object
"
)
;
delete
mPriMap
;
delete
mSegArray
;
mLog
=
nullptr
;
delete
mUSU
;
}
void
LUL
:
:
MaybeShowStats
(
)
{
uint32_t
n_new
=
mStats
-
mStatsPrevious
;
if
(
n_new
>
=
5000
)
{
uint32_t
n_new_Context
=
mStats
.
mContext
-
mStatsPrevious
.
mContext
;
uint32_t
n_new_CFI
=
mStats
.
mCFI
-
mStatsPrevious
.
mCFI
;
uint32_t
n_new_FP
=
mStats
.
mFP
-
mStatsPrevious
.
mFP
;
mStatsPrevious
=
mStats
;
char
buf
[
200
]
;
SprintfLiteral
(
buf
"
LUL
frame
stats
:
TOTAL
%
5u
"
"
CTX
%
4u
CFI
%
4u
FP
%
4u
"
n_new
n_new_Context
n_new_CFI
n_new_FP
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
mLog
(
buf
)
;
}
}
size_t
LUL
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mPriMap
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
return
n
;
}
void
LUL
:
:
EnableUnwinding
(
)
{
LUL_LOG
(
"
LUL
:
:
EnableUnwinding
"
)
;
MOZ_RELEASE_ASSERT
(
gettid
(
)
=
=
mAdminThreadId
)
;
mAdminMode
=
false
;
}
void
LUL
:
:
NotifyAfterMap
(
uintptr_t
aRXavma
size_t
aSize
const
char
*
aFileName
const
void
*
aMappedImage
)
{
MOZ_RELEASE_ASSERT
(
mAdminMode
)
;
MOZ_RELEASE_ASSERT
(
gettid
(
)
=
=
mAdminThreadId
)
;
mLog
(
"
:
\
n
"
)
;
char
buf
[
200
]
;
SprintfLiteral
(
buf
"
NotifyMap
%
llx
%
llu
%
s
\
n
"
(
unsigned
long
long
int
)
aRXavma
(
unsigned
long
long
int
)
aSize
aFileName
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
mLog
(
buf
)
;
if
(
aSize
>
0
)
{
mozilla
:
:
UniquePtr
<
SecMap
>
smap
=
mozilla
:
:
MakeUnique
<
SecMap
>
(
mLog
)
;
if
(
!
aMappedImage
)
{
(
void
)
lul
:
:
ReadSymbolData
(
string
(
aFileName
)
std
:
:
vector
<
string
>
(
)
smap
.
get
(
)
(
void
*
)
aRXavma
aSize
mUSU
mLog
)
;
}
else
{
(
void
)
lul
:
:
ReadSymbolDataInternal
(
(
const
uint8_t
*
)
aMappedImage
string
(
aFileName
)
std
:
:
vector
<
string
>
(
)
smap
.
get
(
)
(
void
*
)
aRXavma
aSize
mUSU
mLog
)
;
}
mLog
(
"
NotifyMap
.
.
preparing
entries
\
n
"
)
;
smap
-
>
PrepareRuleSets
(
aRXavma
aSize
)
;
SprintfLiteral
(
buf
"
NotifyMap
got
%
lld
entries
\
n
"
(
long
long
int
)
smap
-
>
Size
(
)
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
mLog
(
buf
)
;
mPriMap
-
>
AddSecMap
(
std
:
:
move
(
smap
)
)
;
mSegArray
-
>
add
(
aRXavma
aRXavma
+
aSize
-
1
true
)
;
}
}
void
LUL
:
:
NotifyExecutableArea
(
uintptr_t
aRXavma
size_t
aSize
)
{
MOZ_RELEASE_ASSERT
(
mAdminMode
)
;
MOZ_RELEASE_ASSERT
(
gettid
(
)
=
=
mAdminThreadId
)
;
mLog
(
"
:
\
n
"
)
;
char
buf
[
200
]
;
SprintfLiteral
(
buf
"
NotifyExecutableArea
%
llx
%
llu
\
n
"
(
unsigned
long
long
int
)
aRXavma
(
unsigned
long
long
int
)
aSize
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
mLog
(
buf
)
;
if
(
aSize
>
0
)
{
mSegArray
-
>
add
(
aRXavma
aRXavma
+
aSize
-
1
true
)
;
}
}
void
LUL
:
:
NotifyBeforeUnmap
(
uintptr_t
aRXavmaMin
uintptr_t
aRXavmaMax
)
{
MOZ_RELEASE_ASSERT
(
mAdminMode
)
;
MOZ_RELEASE_ASSERT
(
gettid
(
)
=
=
mAdminThreadId
)
;
mLog
(
"
:
\
n
"
)
;
char
buf
[
100
]
;
SprintfLiteral
(
buf
"
NotifyUnmap
%
016llx
-
%
016llx
\
n
"
(
unsigned
long
long
int
)
aRXavmaMin
(
unsigned
long
long
int
)
aRXavmaMax
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
mLog
(
buf
)
;
MOZ_ASSERT
(
aRXavmaMin
<
=
aRXavmaMax
)
;
mPriMap
-
>
RemoveSecMapsInRange
(
aRXavmaMin
aRXavmaMax
)
;
mSegArray
-
>
add
(
aRXavmaMin
aRXavmaMax
false
)
;
SprintfLiteral
(
buf
"
NotifyUnmap
:
now
have
%
d
SecMaps
\
n
"
(
int
)
mPriMap
-
>
CountSecMaps
(
)
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
mLog
(
buf
)
;
}
size_t
LUL
:
:
CountMappings
(
)
{
MOZ_RELEASE_ASSERT
(
mAdminMode
)
;
MOZ_RELEASE_ASSERT
(
gettid
(
)
=
=
mAdminThreadId
)
;
return
mPriMap
-
>
CountSecMaps
(
)
;
}
static
TaggedUWord
DerefTUW
(
TaggedUWord
aAddr
const
StackImage
*
aStackImg
)
{
if
(
!
aAddr
.
Valid
(
)
)
{
return
TaggedUWord
(
)
;
}
if
(
aAddr
.
Value
(
)
<
aStackImg
-
>
mStartAvma
)
{
return
TaggedUWord
(
)
;
}
typedef
CheckedInt
<
uintptr_t
>
CheckedUWord
;
CheckedUWord
highest_requested_plus_one
=
CheckedUWord
(
aAddr
.
Value
(
)
)
+
CheckedUWord
(
sizeof
(
uintptr_t
)
)
;
CheckedUWord
highest_available_plus_one
=
CheckedUWord
(
aStackImg
-
>
mStartAvma
)
+
CheckedUWord
(
aStackImg
-
>
mLen
)
;
if
(
!
highest_requested_plus_one
.
isValid
(
)
|
|
!
highest_available_plus_one
.
isValid
(
)
|
|
(
highest_requested_plus_one
.
value
(
)
>
highest_available_plus_one
.
value
(
)
)
)
{
return
TaggedUWord
(
)
;
}
return
TaggedUWord
(
*
(
uintptr_t
*
)
(
&
aStackImg
-
>
mContents
[
aAddr
.
Value
(
)
-
aStackImg
-
>
mStartAvma
]
)
)
;
}
static
TaggedUWord
EvaluateReg
(
int16_t
aReg
const
UnwindRegs
*
aOldRegs
TaggedUWord
aCFA
)
{
switch
(
aReg
)
{
case
DW_REG_CFA
:
return
aCFA
;
#
if
defined
(
GP_ARCH_amd64
)
|
|
defined
(
GP_ARCH_x86
)
case
DW_REG_INTEL_XBP
:
return
aOldRegs
-
>
xbp
;
case
DW_REG_INTEL_XSP
:
return
aOldRegs
-
>
xsp
;
case
DW_REG_INTEL_XIP
:
return
aOldRegs
-
>
xip
;
#
elif
defined
(
GP_ARCH_arm
)
case
DW_REG_ARM_R7
:
return
aOldRegs
-
>
r7
;
case
DW_REG_ARM_R11
:
return
aOldRegs
-
>
r11
;
case
DW_REG_ARM_R12
:
return
aOldRegs
-
>
r12
;
case
DW_REG_ARM_R13
:
return
aOldRegs
-
>
r13
;
case
DW_REG_ARM_R14
:
return
aOldRegs
-
>
r14
;
case
DW_REG_ARM_R15
:
return
aOldRegs
-
>
r15
;
#
elif
defined
(
GP_ARCH_arm64
)
case
DW_REG_AARCH64_X29
:
return
aOldRegs
-
>
x29
;
case
DW_REG_AARCH64_X30
:
return
aOldRegs
-
>
x30
;
case
DW_REG_AARCH64_SP
:
return
aOldRegs
-
>
sp
;
#
elif
defined
(
GP_ARCH_mips64
)
case
DW_REG_MIPS_SP
:
return
aOldRegs
-
>
sp
;
case
DW_REG_MIPS_FP
:
return
aOldRegs
-
>
fp
;
case
DW_REG_MIPS_PC
:
return
aOldRegs
-
>
pc
;
#
else
#
error
"
Unsupported
arch
"
#
endif
default
:
MOZ_ASSERT
(
0
)
;
return
TaggedUWord
(
)
;
}
}
TaggedUWord
EvaluatePfxExpr
(
int32_t
start
const
UnwindRegs
*
aOldRegs
TaggedUWord
aCFA
const
StackImage
*
aStackImg
const
vector
<
PfxInstr
>
&
aPfxInstrs
)
{
const
int
N_STACK
=
10
;
TaggedUWord
stack
[
N_STACK
]
;
int
stackPointer
=
-
1
;
for
(
int
i
=
0
;
i
<
N_STACK
;
i
+
+
)
stack
[
i
]
=
TaggedUWord
(
)
;
#
define
PUSH
(
_tuw
)
\
do
{
\
if
(
stackPointer
>
=
N_STACK
-
1
)
goto
fail
;
/
*
overflow
*
/
\
stack
[
+
+
stackPointer
]
=
(
_tuw
)
;
\
}
while
(
0
)
#
define
POP
(
_lval
)
\
do
{
\
if
(
stackPointer
<
0
)
goto
fail
;
/
*
underflow
*
/
\
_lval
=
stack
[
stackPointer
-
-
]
;
\
}
while
(
0
)
size_t
curr
=
start
+
1
;
size_t
nInstrs
=
aPfxInstrs
.
size
(
)
;
if
(
start
<
0
|
|
(
size_t
)
start
>
=
nInstrs
)
goto
fail
;
{
PfxInstr
first
=
aPfxInstrs
[
start
]
;
if
(
first
.
mOpcode
!
=
PX_Start
)
goto
fail
;
if
(
first
.
mOperand
!
=
0
)
PUSH
(
aCFA
)
;
}
while
(
true
)
{
if
(
curr
>
=
nInstrs
)
goto
fail
;
PfxInstr
pfxi
=
aPfxInstrs
[
curr
+
+
]
;
if
(
pfxi
.
mOpcode
=
=
PX_End
)
break
;
switch
(
pfxi
.
mOpcode
)
{
case
PX_Start
:
goto
fail
;
case
PX_End
:
MOZ_ASSERT
(
0
)
;
goto
fail
;
case
PX_SImm32
:
PUSH
(
TaggedUWord
(
(
intptr_t
)
pfxi
.
mOperand
)
)
;
break
;
case
PX_DwReg
:
{
DW_REG_NUMBER
reg
=
(
DW_REG_NUMBER
)
pfxi
.
mOperand
;
MOZ_ASSERT
(
reg
!
=
DW_REG_CFA
)
;
PUSH
(
EvaluateReg
(
reg
aOldRegs
aCFA
)
)
;
break
;
}
case
PX_Deref
:
{
TaggedUWord
addr
;
POP
(
addr
)
;
PUSH
(
DerefTUW
(
addr
aStackImg
)
)
;
break
;
}
case
PX_Add
:
{
TaggedUWord
x
y
;
POP
(
x
)
;
POP
(
y
)
;
PUSH
(
y
+
x
)
;
break
;
}
case
PX_Sub
:
{
TaggedUWord
x
y
;
POP
(
x
)
;
POP
(
y
)
;
PUSH
(
y
-
x
)
;
break
;
}
case
PX_And
:
{
TaggedUWord
x
y
;
POP
(
x
)
;
POP
(
y
)
;
PUSH
(
y
&
x
)
;
break
;
}
case
PX_Or
:
{
TaggedUWord
x
y
;
POP
(
x
)
;
POP
(
y
)
;
PUSH
(
y
|
x
)
;
break
;
}
case
PX_CmpGES
:
{
TaggedUWord
x
y
;
POP
(
x
)
;
POP
(
y
)
;
PUSH
(
y
.
CmpGEs
(
x
)
)
;
break
;
}
case
PX_Shl
:
{
TaggedUWord
x
y
;
POP
(
x
)
;
POP
(
y
)
;
PUSH
(
y
<
<
x
)
;
break
;
}
default
:
MOZ_ASSERT
(
0
)
;
goto
fail
;
}
}
if
(
stackPointer
>
=
0
)
{
return
stack
[
stackPointer
]
;
}
fail
:
return
TaggedUWord
(
)
;
#
undef
PUSH
#
undef
POP
}
TaggedUWord
LExpr
:
:
EvaluateExpr
(
const
UnwindRegs
*
aOldRegs
TaggedUWord
aCFA
const
StackImage
*
aStackImg
const
vector
<
PfxInstr
>
*
aPfxInstrs
)
const
{
switch
(
mHow
)
{
case
UNKNOWN
:
return
TaggedUWord
(
)
;
case
NODEREF
:
{
TaggedUWord
tuw
=
EvaluateReg
(
mReg
aOldRegs
aCFA
)
;
tuw
=
tuw
+
TaggedUWord
(
(
intptr_t
)
mOffset
)
;
return
tuw
;
}
case
DEREF
:
{
TaggedUWord
tuw
=
EvaluateReg
(
mReg
aOldRegs
aCFA
)
;
tuw
=
tuw
+
TaggedUWord
(
(
intptr_t
)
mOffset
)
;
return
DerefTUW
(
tuw
aStackImg
)
;
}
case
PFXEXPR
:
{
MOZ_ASSERT
(
aPfxInstrs
)
;
if
(
!
aPfxInstrs
)
{
return
TaggedUWord
(
)
;
}
return
EvaluatePfxExpr
(
mOffset
aOldRegs
aCFA
aStackImg
*
aPfxInstrs
)
;
}
default
:
MOZ_ASSERT
(
0
)
;
return
TaggedUWord
(
)
;
}
}
static
void
UseRuleSet
(
UnwindRegs
*
aRegs
const
StackImage
*
aStackImg
const
RuleSet
*
aRS
const
vector
<
PfxInstr
>
*
aPfxInstrs
)
{
UnwindRegs
old_regs
=
*
aRegs
;
#
if
defined
(
GP_ARCH_amd64
)
|
|
defined
(
GP_ARCH_x86
)
aRegs
-
>
xbp
=
TaggedUWord
(
)
;
aRegs
-
>
xsp
=
TaggedUWord
(
)
;
aRegs
-
>
xip
=
TaggedUWord
(
)
;
#
elif
defined
(
GP_ARCH_arm
)
aRegs
-
>
r7
=
TaggedUWord
(
)
;
aRegs
-
>
r11
=
TaggedUWord
(
)
;
aRegs
-
>
r12
=
TaggedUWord
(
)
;
aRegs
-
>
r13
=
TaggedUWord
(
)
;
aRegs
-
>
r14
=
TaggedUWord
(
)
;
aRegs
-
>
r15
=
TaggedUWord
(
)
;
#
elif
defined
(
GP_ARCH_arm64
)
aRegs
-
>
x29
=
TaggedUWord
(
)
;
aRegs
-
>
x30
=
TaggedUWord
(
)
;
aRegs
-
>
sp
=
TaggedUWord
(
)
;
aRegs
-
>
pc
=
TaggedUWord
(
)
;
#
elif
defined
(
GP_ARCH_mips64
)
aRegs
-
>
sp
=
TaggedUWord
(
)
;
aRegs
-
>
fp
=
TaggedUWord
(
)
;
aRegs
-
>
pc
=
TaggedUWord
(
)
;
#
else
#
error
"
Unsupported
arch
"
#
endif
const
TaggedUWord
inval
=
TaggedUWord
(
)
;
TaggedUWord
cfa
=
aRS
-
>
mCfaExpr
.
EvaluateExpr
(
&
old_regs
inval
aStackImg
aPfxInstrs
)
;
#
if
defined
(
GP_ARCH_amd64
)
|
|
defined
(
GP_ARCH_x86
)
aRegs
-
>
xbp
=
aRS
-
>
mXbpExpr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
aRegs
-
>
xsp
=
aRS
-
>
mXspExpr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
aRegs
-
>
xip
=
aRS
-
>
mXipExpr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
#
elif
defined
(
GP_ARCH_arm
)
aRegs
-
>
r7
=
aRS
-
>
mR7expr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
aRegs
-
>
r11
=
aRS
-
>
mR11expr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
aRegs
-
>
r12
=
aRS
-
>
mR12expr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
aRegs
-
>
r13
=
aRS
-
>
mR13expr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
aRegs
-
>
r14
=
aRS
-
>
mR14expr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
aRegs
-
>
r15
=
aRS
-
>
mR15expr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
#
elif
defined
(
GP_ARCH_arm64
)
aRegs
-
>
x29
=
aRS
-
>
mX29expr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
aRegs
-
>
x30
=
aRS
-
>
mX30expr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
aRegs
-
>
sp
=
aRS
-
>
mSPexpr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
#
elif
defined
(
GP_ARCH_mips64
)
aRegs
-
>
sp
=
aRS
-
>
mSPexpr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
aRegs
-
>
fp
=
aRS
-
>
mFPexpr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
aRegs
-
>
pc
=
aRS
-
>
mPCexpr
.
EvaluateExpr
(
&
old_regs
cfa
aStackImg
aPfxInstrs
)
;
#
else
#
error
"
Unsupported
arch
"
#
endif
}
void
LUL
:
:
Unwind
(
uintptr_t
*
aFramePCs
uintptr_t
*
aFrameSPs
size_t
*
aFramesUsed
size_t
*
aFramePointerFramesAcquired
size_t
aFramesAvail
UnwindRegs
*
aStartRegs
StackImage
*
aStackImg
)
{
MOZ_RELEASE_ASSERT
(
!
mAdminMode
)
;
*
aFramesUsed
=
0
;
UnwindRegs
regs
=
*
aStartRegs
;
TaggedUWord
last_valid_sp
=
TaggedUWord
(
)
;
while
(
true
)
{
if
(
DEBUG_MAIN
)
{
char
buf
[
300
]
;
mLog
(
"
\
n
"
)
;
#
if
defined
(
GP_ARCH_amd64
)
|
|
defined
(
GP_ARCH_x86
)
SprintfLiteral
(
buf
"
LoopTop
:
rip
%
d
/
%
llx
rsp
%
d
/
%
llx
rbp
%
d
/
%
llx
\
n
"
(
int
)
regs
.
xip
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
xip
.
Value
(
)
(
int
)
regs
.
xsp
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
xsp
.
Value
(
)
(
int
)
regs
.
xbp
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
xbp
.
Value
(
)
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
mLog
(
buf
)
;
#
elif
defined
(
GP_ARCH_arm
)
SprintfLiteral
(
buf
"
LoopTop
:
r15
%
d
/
%
llx
r7
%
d
/
%
llx
r11
%
d
/
%
llx
"
"
r12
%
d
/
%
llx
r13
%
d
/
%
llx
r14
%
d
/
%
llx
\
n
"
(
int
)
regs
.
r15
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
r15
.
Value
(
)
(
int
)
regs
.
r7
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
r7
.
Value
(
)
(
int
)
regs
.
r11
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
r11
.
Value
(
)
(
int
)
regs
.
r12
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
r12
.
Value
(
)
(
int
)
regs
.
r13
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
r13
.
Value
(
)
(
int
)
regs
.
r14
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
r14
.
Value
(
)
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
mLog
(
buf
)
;
#
elif
defined
(
GP_ARCH_arm64
)
SprintfLiteral
(
buf
"
LoopTop
:
pc
%
d
/
%
llx
x29
%
d
/
%
llx
x30
%
d
/
%
llx
"
"
sp
%
d
/
%
llx
\
n
"
(
int
)
regs
.
pc
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
pc
.
Value
(
)
(
int
)
regs
.
x29
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
x29
.
Value
(
)
(
int
)
regs
.
x30
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
x30
.
Value
(
)
(
int
)
regs
.
sp
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
sp
.
Value
(
)
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
mLog
(
buf
)
;
#
elif
defined
(
GP_ARCH_mips64
)
SprintfLiteral
(
buf
"
LoopTop
:
pc
%
d
/
%
llx
sp
%
d
/
%
llx
fp
%
d
/
%
llx
\
n
"
(
int
)
regs
.
pc
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
pc
.
Value
(
)
(
int
)
regs
.
sp
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
sp
.
Value
(
)
(
int
)
regs
.
fp
.
Valid
(
)
(
unsigned
long
long
int
)
regs
.
fp
.
Value
(
)
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
mLog
(
buf
)
;
#
else
#
error
"
Unsupported
arch
"
#
endif
}
#
if
defined
(
GP_ARCH_amd64
)
|
|
defined
(
GP_ARCH_x86
)
TaggedUWord
ia
=
regs
.
xip
;
TaggedUWord
sp
=
regs
.
xsp
;
#
elif
defined
(
GP_ARCH_arm
)
TaggedUWord
ia
=
(
*
aFramesUsed
=
=
0
?
regs
.
r15
:
regs
.
r14
)
;
TaggedUWord
sp
=
regs
.
r13
;
#
elif
defined
(
GP_ARCH_arm64
)
TaggedUWord
ia
=
(
*
aFramesUsed
=
=
0
?
regs
.
pc
:
regs
.
x30
)
;
TaggedUWord
sp
=
regs
.
sp
;
#
elif
defined
(
GP_ARCH_mips64
)
TaggedUWord
ia
=
regs
.
pc
;
TaggedUWord
sp
=
regs
.
sp
;
#
else
#
error
"
Unsupported
arch
"
#
endif
if
(
*
aFramesUsed
>
=
aFramesAvail
)
{
break
;
}
if
(
!
ia
.
Valid
(
)
)
{
break
;
}
if
(
*
aFramesUsed
=
=
0
)
{
last_valid_sp
=
sp
;
}
else
{
MOZ_ASSERT
(
last_valid_sp
.
Valid
(
)
)
;
if
(
sp
.
Valid
(
)
)
{
if
(
sp
.
Value
(
)
<
last_valid_sp
.
Value
(
)
)
{
break
;
}
last_valid_sp
=
sp
;
}
}
aFramePCs
[
*
aFramesUsed
]
=
ia
.
Value
(
)
-
(
*
aFramesUsed
=
=
0
?
0
:
1
)
;
aFrameSPs
[
*
aFramesUsed
]
=
sp
.
Valid
(
)
?
sp
.
Value
(
)
:
0
;
(
*
aFramesUsed
)
+
+
;
if
(
*
aFramesUsed
>
1
)
{
ia
=
ia
+
TaggedUWord
(
(
uintptr_t
)
(
-
1
)
)
;
}
pair
<
const
RuleSet
*
const
vector
<
PfxInstr
>
*
>
ruleset_and_pfxinstrs
=
mPriMap
-
>
Lookup
(
ia
.
Value
(
)
)
;
const
RuleSet
*
ruleset
=
ruleset_and_pfxinstrs
.
first
;
const
vector
<
PfxInstr
>
*
pfxinstrs
=
ruleset_and_pfxinstrs
.
second
;
if
(
DEBUG_MAIN
)
{
char
buf
[
100
]
;
SprintfLiteral
(
buf
"
ruleset
for
0x
%
llx
=
%
p
\
n
"
(
unsigned
long
long
int
)
ia
.
Value
(
)
ruleset
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
mLog
(
buf
)
;
}
#
if
defined
(
GP_PLAT_x86_android
)
|
|
defined
(
GP_PLAT_x86_linux
)
if
(
!
ruleset
&
&
*
aFramesUsed
=
=
1
&
&
ia
.
Valid
(
)
&
&
sp
.
Valid
(
)
)
{
uintptr_t
insns_min
insns_max
;
uintptr_t
eip
=
ia
.
Value
(
)
;
bool
b
=
mSegArray
-
>
getBoundingCodeSegment
(
&
insns_min
&
insns_max
eip
)
;
if
(
b
&
&
eip
-
2
>
=
insns_min
&
&
eip
+
3
<
=
insns_max
)
{
uint8_t
*
eipC
=
(
uint8_t
*
)
eip
;
if
(
eipC
[
-
2
]
=
=
0xCD
&
&
eipC
[
-
1
]
=
=
0x80
&
&
eipC
[
0
]
=
=
0x5D
&
&
eipC
[
1
]
=
=
0x5A
&
&
eipC
[
2
]
=
=
0x59
&
&
eipC
[
3
]
=
=
0xC3
)
{
TaggedUWord
sp_plus_0
=
sp
;
TaggedUWord
sp_plus_12
=
sp
;
TaggedUWord
sp_plus_16
=
sp
;
sp_plus_12
=
sp_plus_12
+
TaggedUWord
(
12
)
;
sp_plus_16
=
sp_plus_16
+
TaggedUWord
(
16
)
;
TaggedUWord
new_ebp
=
DerefTUW
(
sp_plus_0
aStackImg
)
;
TaggedUWord
new_eip
=
DerefTUW
(
sp_plus_12
aStackImg
)
;
TaggedUWord
new_esp
=
sp_plus_16
;
if
(
new_ebp
.
Valid
(
)
&
&
new_eip
.
Valid
(
)
&
&
new_esp
.
Valid
(
)
)
{
regs
.
xbp
=
new_ebp
;
regs
.
xip
=
new_eip
;
regs
.
xsp
=
new_esp
;
continue
;
}
}
}
}
#
endif
if
(
ruleset
)
{
if
(
DEBUG_MAIN
)
{
ruleset
-
>
Print
(
mLog
)
;
mLog
(
"
\
n
"
)
;
}
UseRuleSet
(
&
regs
aStackImg
ruleset
pfxinstrs
)
;
continue
;
}
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_x86_linux
)
const
size_t
wordSzB
=
sizeof
(
uintptr_t
)
;
TaggedUWord
old_xsp
=
regs
.
xsp
;
TaggedUWord
old_xbp
=
regs
.
xbp
;
TaggedUWord
old_xbp_plus1
=
regs
.
xbp
+
TaggedUWord
(
1
*
wordSzB
)
;
TaggedUWord
old_xbp_plus2
=
regs
.
xbp
+
TaggedUWord
(
2
*
wordSzB
)
;
if
(
old_xbp
.
Valid
(
)
&
&
old_xbp
.
IsAligned
(
)
&
&
old_xsp
.
Valid
(
)
&
&
old_xsp
.
IsAligned
(
)
&
&
old_xsp
.
Value
(
)
<
=
old_xbp
.
Value
(
)
)
{
TaggedUWord
new_xbp
=
DerefTUW
(
old_xbp
aStackImg
)
;
if
(
new_xbp
.
Valid
(
)
&
&
new_xbp
.
IsAligned
(
)
&
&
old_xbp
.
Value
(
)
<
new_xbp
.
Value
(
)
)
{
TaggedUWord
new_xip
=
DerefTUW
(
old_xbp_plus1
aStackImg
)
;
TaggedUWord
new_xsp
=
old_xbp_plus2
;
if
(
new_xbp
.
Valid
(
)
&
&
new_xip
.
Valid
(
)
&
&
new_xsp
.
Valid
(
)
)
{
regs
.
xbp
=
new_xbp
;
regs
.
xip
=
new_xip
;
regs
.
xsp
=
new_xsp
;
(
*
aFramePointerFramesAcquired
)
+
+
;
continue
;
}
}
}
#
endif
break
;
}
}
static
const
int
LUL_UNIT_TEST_STACK_SIZE
=
32768
;
#
if
defined
(
GP_ARCH_mips64
)
static
__attribute__
(
(
noinline
)
)
unsigned
long
__getpc
(
void
)
{
unsigned
long
rtaddr
;
__asm__
volatile
(
"
move
%
0
31
"
:
"
=
r
"
(
rtaddr
)
)
;
return
rtaddr
;
}
#
endif
static
__attribute__
(
(
noinline
)
)
bool
GetAndCheckStackTrace
(
LUL
*
aLUL
const
char
*
dstring
)
{
UnwindRegs
startRegs
;
memset
(
&
startRegs
0
sizeof
(
startRegs
)
)
;
#
if
defined
(
GP_PLAT_amd64_linux
)
volatile
uintptr_t
block
[
3
]
;
MOZ_ASSERT
(
sizeof
(
block
)
=
=
24
)
;
__asm__
__volatile__
(
"
leaq
0
(
%
%
rip
)
%
%
r15
"
"
\
n
\
t
"
"
movq
%
%
r15
0
(
%
0
)
"
"
\
n
\
t
"
"
movq
%
%
rsp
8
(
%
0
)
"
"
\
n
\
t
"
"
movq
%
%
rbp
16
(
%
0
)
"
"
\
n
"
:
:
"
r
"
(
&
block
[
0
]
)
:
"
memory
"
"
r15
"
)
;
startRegs
.
xip
=
TaggedUWord
(
block
[
0
]
)
;
startRegs
.
xsp
=
TaggedUWord
(
block
[
1
]
)
;
startRegs
.
xbp
=
TaggedUWord
(
block
[
2
]
)
;
const
uintptr_t
REDZONE_SIZE
=
128
;
uintptr_t
start
=
block
[
1
]
-
REDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
volatile
uintptr_t
block
[
3
]
;
MOZ_ASSERT
(
sizeof
(
block
)
=
=
12
)
;
__asm__
__volatile__
(
"
.
byte
0xE8
0x00
0x00
0x00
0x00
"
"
\
n
\
t
"
"
popl
%
%
edi
"
"
\
n
\
t
"
"
movl
%
%
edi
0
(
%
0
)
"
"
\
n
\
t
"
"
movl
%
%
esp
4
(
%
0
)
"
"
\
n
\
t
"
"
movl
%
%
ebp
8
(
%
0
)
"
"
\
n
"
:
:
"
r
"
(
&
block
[
0
]
)
:
"
memory
"
"
edi
"
)
;
startRegs
.
xip
=
TaggedUWord
(
block
[
0
]
)
;
startRegs
.
xsp
=
TaggedUWord
(
block
[
1
]
)
;
startRegs
.
xbp
=
TaggedUWord
(
block
[
2
]
)
;
const
uintptr_t
REDZONE_SIZE
=
0
;
uintptr_t
start
=
block
[
1
]
-
REDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
volatile
uintptr_t
block
[
6
]
;
MOZ_ASSERT
(
sizeof
(
block
)
=
=
24
)
;
__asm__
__volatile__
(
"
mov
r0
r15
"
"
\
n
\
t
"
"
str
r0
[
%
0
#
0
]
"
"
\
n
\
t
"
"
str
r14
[
%
0
#
4
]
"
"
\
n
\
t
"
"
str
r13
[
%
0
#
8
]
"
"
\
n
\
t
"
"
str
r12
[
%
0
#
12
]
"
"
\
n
\
t
"
"
str
r11
[
%
0
#
16
]
"
"
\
n
\
t
"
"
str
r7
[
%
0
#
20
]
"
"
\
n
"
:
:
"
r
"
(
&
block
[
0
]
)
:
"
memory
"
"
r0
"
)
;
startRegs
.
r15
=
TaggedUWord
(
block
[
0
]
)
;
startRegs
.
r14
=
TaggedUWord
(
block
[
1
]
)
;
startRegs
.
r13
=
TaggedUWord
(
block
[
2
]
)
;
startRegs
.
r12
=
TaggedUWord
(
block
[
3
]
)
;
startRegs
.
r11
=
TaggedUWord
(
block
[
4
]
)
;
startRegs
.
r7
=
TaggedUWord
(
block
[
5
]
)
;
const
uintptr_t
REDZONE_SIZE
=
0
;
uintptr_t
start
=
block
[
1
]
-
REDZONE_SIZE
;
#
elif
defined
(
GP_ARCH_arm64
)
volatile
uintptr_t
block
[
4
]
;
MOZ_ASSERT
(
sizeof
(
block
)
=
=
32
)
;
__asm__
__volatile__
(
"
adr
x0
.
\
n
\
t
"
"
str
x0
[
%
0
#
0
]
\
n
\
t
"
"
str
x29
[
%
0
#
8
]
\
n
\
t
"
"
str
x30
[
%
0
#
16
]
\
n
\
t
"
"
mov
x0
sp
\
n
\
t
"
"
str
x0
[
%
0
#
24
]
\
n
\
t
"
:
:
"
r
"
(
&
block
[
0
]
)
:
"
memory
"
"
x0
"
)
;
startRegs
.
pc
=
TaggedUWord
(
block
[
0
]
)
;
startRegs
.
x29
=
TaggedUWord
(
block
[
1
]
)
;
startRegs
.
x30
=
TaggedUWord
(
block
[
2
]
)
;
startRegs
.
sp
=
TaggedUWord
(
block
[
3
]
)
;
const
uintptr_t
REDZONE_SIZE
=
0
;
uintptr_t
start
=
block
[
1
]
-
REDZONE_SIZE
;
#
elif
defined
(
GP_ARCH_mips64
)
volatile
uintptr_t
block
[
3
]
;
MOZ_ASSERT
(
sizeof
(
block
)
=
=
24
)
;
__asm__
__volatile__
(
"
sd
29
8
(
%
0
)
\
n
"
"
sd
30
16
(
%
0
)
\
n
"
:
:
"
r
"
(
block
)
:
"
memory
"
)
;
block
[
0
]
=
__getpc
(
)
;
startRegs
.
pc
=
TaggedUWord
(
block
[
0
]
)
;
startRegs
.
sp
=
TaggedUWord
(
block
[
1
]
)
;
startRegs
.
fp
=
TaggedUWord
(
block
[
2
]
)
;
const
uintptr_t
REDZONE_SIZE
=
0
;
uintptr_t
start
=
block
[
1
]
-
REDZONE_SIZE
;
#
else
#
error
"
Unsupported
platform
"
#
endif
uintptr_t
end
=
start
+
LUL_UNIT_TEST_STACK_SIZE
;
uintptr_t
ws
=
sizeof
(
void
*
)
;
start
&
=
~
(
ws
-
1
)
;
end
&
=
~
(
ws
-
1
)
;
uintptr_t
nToCopy
=
end
-
start
;
if
(
nToCopy
>
lul
:
:
N_STACK_BYTES
)
{
nToCopy
=
lul
:
:
N_STACK_BYTES
;
}
MOZ_ASSERT
(
nToCopy
<
=
lul
:
:
N_STACK_BYTES
)
;
StackImage
*
stackImg
=
new
StackImage
(
)
;
stackImg
-
>
mLen
=
nToCopy
;
stackImg
-
>
mStartAvma
=
start
;
if
(
nToCopy
>
0
)
{
MOZ_MAKE_MEM_DEFINED
(
(
void
*
)
start
nToCopy
)
;
memcpy
(
&
stackImg
-
>
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
}
const
int
MAX_TEST_FRAMES
=
64
;
uintptr_t
framePCs
[
MAX_TEST_FRAMES
]
;
uintptr_t
frameSPs
[
MAX_TEST_FRAMES
]
;
size_t
framesAvail
=
mozilla
:
:
ArrayLength
(
framePCs
)
;
size_t
framesUsed
=
0
;
size_t
framePointerFramesAcquired
=
0
;
aLUL
-
>
Unwind
(
&
framePCs
[
0
]
&
frameSPs
[
0
]
&
framesUsed
&
framePointerFramesAcquired
framesAvail
&
startRegs
stackImg
)
;
delete
stackImg
;
uintptr_t
binding
[
8
]
;
memset
(
(
void
*
)
binding
0
sizeof
(
binding
)
)
;
const
char
*
cursor
=
dstring
;
while
(
*
cursor
)
cursor
+
+
;
size_t
nConsistent
=
0
;
size_t
frameIx
;
for
(
cursor
=
cursor
-
2
frameIx
=
2
;
cursor
>
=
dstring
&
&
frameIx
<
framesUsed
;
cursor
-
-
frameIx
+
+
)
{
char
c
=
*
cursor
;
uintptr_t
pc
=
framePCs
[
frameIx
]
;
MOZ_ASSERT
(
c
>
=
'
1
'
&
&
c
<
=
'
8
'
)
;
int
n
=
(
(
int
)
c
)
-
(
(
int
)
'
1
'
)
;
if
(
binding
[
n
]
=
=
0
)
{
binding
[
n
]
=
pc
;
nConsistent
+
+
;
continue
;
}
if
(
binding
[
n
]
!
=
pc
)
{
break
;
}
nConsistent
+
+
;
}
bool
passed
=
nConsistent
+
1
=
=
strlen
(
dstring
)
;
char
buf
[
200
]
;
SprintfLiteral
(
buf
"
LULUnitTest
:
dstring
=
%
s
\
n
"
dstring
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
aLUL
-
>
mLog
(
buf
)
;
SprintfLiteral
(
buf
"
LULUnitTest
:
%
d
consistent
%
d
in
dstring
:
%
s
\
n
"
(
int
)
nConsistent
(
int
)
strlen
(
dstring
)
passed
?
"
PASS
"
:
"
FAIL
"
)
;
buf
[
sizeof
(
buf
)
-
1
]
=
0
;
aLUL
-
>
mLog
(
buf
)
;
return
passed
;
}
#
define
DECL_TEST_FN
(
NAME
)
\
bool
NAME
(
LUL
*
aLUL
const
char
*
strPorig
const
char
*
strP
)
;
#
define
GEN_TEST_FN
(
NAME
FRAMESIZE
)
\
bool
NAME
(
LUL
*
aLUL
const
char
*
strPorig
const
char
*
strP
)
{
\
/
*
Create
a
frame
of
size
(
at
least
)
FRAMESIZE
so
that
the
*
/
\
/
*
8
functions
created
by
this
macro
offer
some
variation
in
frame
*
/
\
/
*
sizes
.
This
isn
'
t
as
simple
as
it
might
seem
since
a
clever
*
/
\
/
*
optimizing
compiler
(
eg
clang
-
5
)
detects
that
the
array
is
unused
*
/
\
/
*
and
removes
it
.
We
try
to
defeat
this
by
passing
it
to
a
function
*
/
\
/
*
in
a
different
compilation
unit
and
hoping
that
clang
does
not
*
/
\
/
*
notice
that
the
call
is
a
no
-
op
.
*
/
\
char
space
[
FRAMESIZE
]
;
\
Unused
<
<
write
(
1
space
0
)
;
/
*
write
zero
bytes
of
|
space
|
to
stdout
*
/
\
\
if
(
*
strP
=
=
'
\
0
'
)
{
\
/
*
We
'
ve
come
to
the
end
of
the
director
string
.
*
/
\
/
*
Take
a
stack
snapshot
.
*
/
\
return
GetAndCheckStackTrace
(
aLUL
strPorig
)
;
\
}
else
{
\
/
*
Recurse
onwards
.
This
is
a
bit
subtle
.
The
obvious
*
/
\
/
*
thing
to
do
here
is
call
onwards
directly
from
within
the
*
/
\
/
*
arms
of
the
case
statement
.
That
gives
a
problem
in
that
*
/
\
/
*
there
will
be
multiple
return
points
inside
each
function
when
*
/
\
/
*
unwinding
so
it
will
be
difficult
to
check
for
consistency
*
/
\
/
*
against
the
director
string
.
Instead
we
make
an
indirect
*
/
\
/
*
call
so
as
to
guarantee
that
there
is
only
one
call
site
*
/
\
/
*
within
each
function
.
This
does
assume
that
the
compiler
*
/
\
/
*
won
'
t
transform
it
back
to
the
simple
direct
-
call
form
.
*
/
\
/
*
To
discourage
it
from
doing
so
the
call
is
bracketed
with
*
/
\
/
*
__asm__
__volatile__
sections
so
as
to
make
it
not
-
movable
.
*
/
\
bool
(
*
nextFn
)
(
LUL
*
const
char
*
const
char
*
)
=
NULL
;
\
switch
(
*
strP
)
{
\
case
'
1
'
:
\
nextFn
=
TestFn1
;
\
break
;
\
case
'
2
'
:
\
nextFn
=
TestFn2
;
\
break
;
\
case
'
3
'
:
\
nextFn
=
TestFn3
;
\
break
;
\
case
'
4
'
:
\
nextFn
=
TestFn4
;
\
break
;
\
case
'
5
'
:
\
nextFn
=
TestFn5
;
\
break
;
\
case
'
6
'
:
\
nextFn
=
TestFn6
;
\
break
;
\
case
'
7
'
:
\
nextFn
=
TestFn7
;
\
break
;
\
case
'
8
'
:
\
nextFn
=
TestFn8
;
\
break
;
\
default
:
\
nextFn
=
TestFn8
;
\
break
;
\
}
\
/
*
"
use
"
|
space
|
immediately
after
the
recursive
call
*
/
\
/
*
so
as
to
dissuade
clang
from
deallocating
the
space
while
*
/
\
/
*
the
call
is
active
or
otherwise
messing
with
the
stack
frame
.
*
/
\
__asm__
__volatile__
(
"
"
:
:
:
"
cc
"
"
memory
"
)
;
\
bool
passed
=
nextFn
(
aLUL
strPorig
strP
+
1
)
;
\
Unused
<
<
write
(
1
space
0
)
;
\
__asm__
__volatile__
(
"
"
:
:
:
"
cc
"
"
memory
"
)
;
\
return
passed
;
\
}
\
}
DECL_TEST_FN
(
TestFn1
)
DECL_TEST_FN
(
TestFn2
)
DECL_TEST_FN
(
TestFn3
)
DECL_TEST_FN
(
TestFn4
)
DECL_TEST_FN
(
TestFn5
)
DECL_TEST_FN
(
TestFn6
)
DECL_TEST_FN
(
TestFn7
)
DECL_TEST_FN
(
TestFn8
)
GEN_TEST_FN
(
TestFn1
123
)
GEN_TEST_FN
(
TestFn2
456
)
GEN_TEST_FN
(
TestFn3
789
)
GEN_TEST_FN
(
TestFn4
23
)
GEN_TEST_FN
(
TestFn5
47
)
GEN_TEST_FN
(
TestFn6
117
)
GEN_TEST_FN
(
TestFn7
1
)
GEN_TEST_FN
(
TestFn8
99
)
__attribute__
(
(
noinline
)
)
void
TestUnw
(
int
*
aNTests
int
*
aNTestsPassed
LUL
*
aLUL
const
char
*
dstring
)
{
int
i
;
volatile
char
space
[
LUL_UNIT_TEST_STACK_SIZE
]
;
for
(
i
=
0
;
i
<
LUL_UNIT_TEST_STACK_SIZE
;
i
+
+
)
{
space
[
i
]
=
(
char
)
(
i
&
0x7F
)
;
}
bool
passed
=
TestFn1
(
aLUL
dstring
dstring
)
;
int
sum
=
0
;
for
(
i
=
0
;
i
<
LUL_UNIT_TEST_STACK_SIZE
;
i
+
+
)
{
sum
+
=
space
[
i
]
-
3
*
i
;
}
__asm__
__volatile__
(
"
"
:
:
"
r
"
(
sum
)
)
;
(
*
aNTests
)
+
+
;
if
(
passed
)
{
(
*
aNTestsPassed
)
+
+
;
}
}
void
RunLulUnitTests
(
int
*
aNTests
int
*
aNTestsPassed
LUL
*
aLUL
)
{
aLUL
-
>
mLog
(
"
:
\
n
"
)
;
aLUL
-
>
mLog
(
"
LULUnitTest
:
BEGIN
\
n
"
)
;
*
aNTests
=
*
aNTestsPassed
=
0
;
TestUnw
(
aNTests
aNTestsPassed
aLUL
"
11111111
"
)
;
TestUnw
(
aNTests
aNTestsPassed
aLUL
"
11222211
"
)
;
TestUnw
(
aNTests
aNTestsPassed
aLUL
"
111222333
"
)
;
TestUnw
(
aNTests
aNTestsPassed
aLUL
"
1212121231212331212121212121212
"
)
;
TestUnw
(
aNTests
aNTestsPassed
aLUL
"
31415827271828325332173258
"
)
;
TestUnw
(
aNTests
aNTestsPassed
aLUL
"
123456781122334455667788777777777777777777777
"
)
;
aLUL
-
>
mLog
(
"
LULUnitTest
:
END
\
n
"
)
;
aLUL
-
>
mLog
(
"
:
\
n
"
)
;
}
}
