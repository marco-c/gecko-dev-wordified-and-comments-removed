#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stack
>
#
include
<
string
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
LulCommonExt
.
h
"
#
include
"
LulDwarfInt
.
h
"
#
define
DEBUG_DWARF
0
namespace
lul
{
using
std
:
:
pair
;
using
std
:
:
string
;
ByteReader
:
:
ByteReader
(
enum
Endianness
endian
)
:
offset_reader_
(
NULL
)
address_reader_
(
NULL
)
endian_
(
endian
)
address_size_
(
0
)
offset_size_
(
0
)
have_section_base_
(
)
have_text_base_
(
)
have_data_base_
(
)
have_function_base_
(
)
{
}
ByteReader
:
:
~
ByteReader
(
)
{
}
void
ByteReader
:
:
SetOffsetSize
(
uint8
size
)
{
offset_size_
=
size
;
MOZ_ASSERT
(
size
=
=
4
|
|
size
=
=
8
)
;
if
(
size
=
=
4
)
{
this
-
>
offset_reader_
=
&
ByteReader
:
:
ReadFourBytes
;
}
else
{
this
-
>
offset_reader_
=
&
ByteReader
:
:
ReadEightBytes
;
}
}
void
ByteReader
:
:
SetAddressSize
(
uint8
size
)
{
address_size_
=
size
;
MOZ_ASSERT
(
size
=
=
4
|
|
size
=
=
8
)
;
if
(
size
=
=
4
)
{
this
-
>
address_reader_
=
&
ByteReader
:
:
ReadFourBytes
;
}
else
{
this
-
>
address_reader_
=
&
ByteReader
:
:
ReadEightBytes
;
}
}
uint64
ByteReader
:
:
ReadInitialLength
(
const
char
*
start
size_t
*
len
)
{
const
uint64
initial_length
=
ReadFourBytes
(
start
)
;
start
+
=
4
;
if
(
initial_length
=
=
0xffffffff
)
{
SetOffsetSize
(
8
)
;
*
len
=
12
;
return
ReadOffset
(
start
)
;
}
else
{
SetOffsetSize
(
4
)
;
*
len
=
4
;
}
return
initial_length
;
}
bool
ByteReader
:
:
ValidEncoding
(
DwarfPointerEncoding
encoding
)
const
{
if
(
encoding
=
=
DW_EH_PE_omit
)
return
true
;
if
(
encoding
=
=
DW_EH_PE_aligned
)
return
true
;
if
(
(
encoding
&
0x7
)
>
DW_EH_PE_udata8
)
return
false
;
if
(
(
encoding
&
0x70
)
>
DW_EH_PE_funcrel
)
return
false
;
return
true
;
}
bool
ByteReader
:
:
UsableEncoding
(
DwarfPointerEncoding
encoding
)
const
{
switch
(
encoding
&
0x70
)
{
case
DW_EH_PE_absptr
:
return
true
;
case
DW_EH_PE_pcrel
:
return
have_section_base_
;
case
DW_EH_PE_textrel
:
return
have_text_base_
;
case
DW_EH_PE_datarel
:
return
have_data_base_
;
case
DW_EH_PE_funcrel
:
return
have_function_base_
;
default
:
return
false
;
}
}
uint64
ByteReader
:
:
ReadEncodedPointer
(
const
char
*
buffer
DwarfPointerEncoding
encoding
size_t
*
len
)
const
{
MOZ_ASSERT
(
encoding
!
=
DW_EH_PE_omit
)
;
if
(
encoding
=
=
DW_EH_PE_aligned
)
{
MOZ_ASSERT
(
have_section_base_
)
;
uint64
skew
=
section_base_
&
(
AddressSize
(
)
-
1
)
;
uint64
offset
=
skew
+
(
buffer
-
buffer_base_
)
;
uint64
aligned
=
(
offset
+
AddressSize
(
)
-
1
)
&
-
AddressSize
(
)
;
const
char
*
aligned_buffer
=
buffer_base_
+
(
aligned
-
skew
)
;
*
len
=
aligned_buffer
-
buffer
+
AddressSize
(
)
;
return
ReadAddress
(
aligned_buffer
)
;
}
uint64
offset
;
switch
(
encoding
&
0x0f
)
{
case
DW_EH_PE_absptr
:
offset
=
ReadAddress
(
buffer
)
;
*
len
=
AddressSize
(
)
;
break
;
case
DW_EH_PE_uleb128
:
offset
=
ReadUnsignedLEB128
(
buffer
len
)
;
break
;
case
DW_EH_PE_udata2
:
offset
=
ReadTwoBytes
(
buffer
)
;
*
len
=
2
;
break
;
case
DW_EH_PE_udata4
:
offset
=
ReadFourBytes
(
buffer
)
;
*
len
=
4
;
break
;
case
DW_EH_PE_udata8
:
offset
=
ReadEightBytes
(
buffer
)
;
*
len
=
8
;
break
;
case
DW_EH_PE_sleb128
:
offset
=
ReadSignedLEB128
(
buffer
len
)
;
break
;
case
DW_EH_PE_sdata2
:
offset
=
ReadTwoBytes
(
buffer
)
;
offset
=
(
offset
^
0x8000
)
-
0x8000
;
*
len
=
2
;
break
;
case
DW_EH_PE_sdata4
:
offset
=
ReadFourBytes
(
buffer
)
;
offset
=
(
offset
^
0x80000000ULL
)
-
0x80000000ULL
;
*
len
=
4
;
break
;
case
DW_EH_PE_sdata8
:
offset
=
ReadEightBytes
(
buffer
)
;
*
len
=
8
;
break
;
default
:
abort
(
)
;
}
uint64
base
;
switch
(
encoding
&
0x70
)
{
case
DW_EH_PE_absptr
:
base
=
0
;
break
;
case
DW_EH_PE_pcrel
:
MOZ_ASSERT
(
have_section_base_
)
;
base
=
section_base_
+
(
buffer
-
buffer_base_
)
;
break
;
case
DW_EH_PE_textrel
:
MOZ_ASSERT
(
have_text_base_
)
;
base
=
text_base_
;
break
;
case
DW_EH_PE_datarel
:
MOZ_ASSERT
(
have_data_base_
)
;
base
=
data_base_
;
break
;
case
DW_EH_PE_funcrel
:
MOZ_ASSERT
(
have_function_base_
)
;
base
=
function_base_
;
break
;
default
:
abort
(
)
;
}
uint64
pointer
=
base
+
offset
;
if
(
AddressSize
(
)
=
=
4
)
pointer
=
pointer
&
0xffffffff
;
else
MOZ_ASSERT
(
AddressSize
(
)
=
=
sizeof
(
uint64
)
)
;
return
pointer
;
}
class
CallFrameInfo
:
:
Rule
final
{
public
:
enum
Tag
{
INVALID
Undefined
SameValue
Offset
ValOffset
Register
Expression
ValExpression
}
;
private
:
Tag
tag_
;
uintptr_t
word1_
;
uintptr_t
word2_
;
static_assert
(
sizeof
(
const
char
*
)
<
=
sizeof
(
word1_
)
)
;
static_assert
(
sizeof
(
size_t
)
<
=
sizeof
(
word2_
)
)
;
bool
isCanonical
(
)
const
{
switch
(
tag_
)
{
case
Tag
:
:
INVALID
:
case
Tag
:
:
Undefined
:
case
Tag
:
:
SameValue
:
return
word1_
=
=
0
&
&
word2_
=
=
0
;
case
Tag
:
:
Offset
:
case
Tag
:
:
ValOffset
:
return
true
;
case
Tag
:
:
Register
:
return
word2_
=
=
0
;
case
Tag
:
:
Expression
:
case
Tag
:
:
ValExpression
:
return
true
;
default
:
MOZ_CRASH
(
)
;
}
}
public
:
Tag
tag
(
)
const
{
return
tag_
;
}
int
dwreg
(
)
const
{
switch
(
tag_
)
{
case
Tag
:
:
Offset
:
case
Tag
:
:
ValOffset
:
case
Tag
:
:
Register
:
return
(
int
)
word1_
;
default
:
MOZ_CRASH
(
)
;
}
}
intptr_t
offset
(
)
const
{
switch
(
tag_
)
{
case
Tag
:
:
Offset
:
case
Tag
:
:
ValOffset
:
return
(
intptr_t
)
word2_
;
default
:
MOZ_CRASH
(
)
;
}
}
ImageSlice
expr
(
)
const
{
switch
(
tag_
)
{
case
Tag
:
:
Expression
:
case
Tag
:
:
ValExpression
:
return
ImageSlice
(
(
const
char
*
)
word1_
(
size_t
)
word2_
)
;
default
:
MOZ_CRASH
(
)
;
}
}
Rule
(
)
{
tag_
=
Tag
:
:
INVALID
;
word1_
=
0
;
word2_
=
0
;
}
static
Rule
mkINVALID
(
)
{
Rule
r
;
return
r
;
}
static
Rule
mkUndefinedRule
(
)
{
Rule
r
;
r
.
tag_
=
Tag
:
:
Undefined
;
r
.
word1_
=
0
;
r
.
word2_
=
0
;
return
r
;
}
static
Rule
mkSameValueRule
(
)
{
Rule
r
;
r
.
tag_
=
Tag
:
:
SameValue
;
r
.
word1_
=
0
;
r
.
word2_
=
0
;
return
r
;
}
static
Rule
mkOffsetRule
(
int
dwreg
intptr_t
offset
)
{
Rule
r
;
r
.
tag_
=
Tag
:
:
Offset
;
r
.
word1_
=
(
uintptr_t
)
dwreg
;
r
.
word2_
=
(
uintptr_t
)
offset
;
return
r
;
}
static
Rule
mkValOffsetRule
(
int
dwreg
intptr_t
offset
)
{
Rule
r
;
r
.
tag_
=
Tag
:
:
ValOffset
;
r
.
word1_
=
(
uintptr_t
)
dwreg
;
r
.
word2_
=
(
uintptr_t
)
offset
;
return
r
;
}
static
Rule
mkRegisterRule
(
int
dwreg
)
{
Rule
r
;
r
.
tag_
=
Tag
:
:
Register
;
r
.
word1_
=
(
uintptr_t
)
dwreg
;
r
.
word2_
=
0
;
return
r
;
}
static
Rule
mkExpressionRule
(
ImageSlice
expr
)
{
Rule
r
;
r
.
tag_
=
Tag
:
:
Expression
;
r
.
word1_
=
(
uintptr_t
)
expr
.
start_
;
r
.
word2_
=
(
uintptr_t
)
expr
.
length_
;
return
r
;
}
static
Rule
mkValExpressionRule
(
ImageSlice
expr
)
{
Rule
r
;
r
.
tag_
=
Tag
:
:
ValExpression
;
r
.
word1_
=
(
uintptr_t
)
expr
.
start_
;
r
.
word2_
=
(
uintptr_t
)
expr
.
length_
;
return
r
;
}
inline
bool
isVALID
(
)
const
{
return
tag_
!
=
Tag
:
:
INVALID
;
}
bool
operator
=
=
(
const
Rule
&
rhs
)
const
{
MOZ_ASSERT
(
isVALID
(
)
&
&
rhs
.
isVALID
(
)
)
;
MOZ_ASSERT
(
isCanonical
(
)
)
;
MOZ_ASSERT
(
rhs
.
isCanonical
(
)
)
;
if
(
tag_
!
=
rhs
.
tag_
)
{
return
false
;
}
switch
(
tag_
)
{
case
Tag
:
:
INVALID
:
MOZ_CRASH
(
)
;
case
Tag
:
:
Undefined
:
case
Tag
:
:
SameValue
:
return
true
;
case
Tag
:
:
Offset
:
case
Tag
:
:
ValOffset
:
return
word1_
=
=
rhs
.
word1_
&
&
word2_
=
=
rhs
.
word2_
;
case
Tag
:
:
Register
:
return
word1_
=
=
rhs
.
word1_
;
case
Tag
:
:
Expression
:
case
Tag
:
:
ValExpression
:
return
expr
(
)
=
=
rhs
.
expr
(
)
;
default
:
MOZ_CRASH
(
)
;
}
}
bool
operator
!
=
(
const
Rule
&
rhs
)
const
{
return
!
(
*
this
=
=
rhs
)
;
}
bool
Handle
(
Handler
*
handler
uint64
address
int
reg
)
const
{
MOZ_ASSERT
(
isVALID
(
)
)
;
MOZ_ASSERT
(
isCanonical
(
)
)
;
switch
(
tag_
)
{
case
Tag
:
:
Undefined
:
return
handler
-
>
UndefinedRule
(
address
reg
)
;
case
Tag
:
:
SameValue
:
return
handler
-
>
SameValueRule
(
address
reg
)
;
case
Tag
:
:
Offset
:
return
handler
-
>
OffsetRule
(
address
reg
word1_
word2_
)
;
case
Tag
:
:
ValOffset
:
return
handler
-
>
ValOffsetRule
(
address
reg
word1_
word2_
)
;
case
Tag
:
:
Register
:
return
handler
-
>
RegisterRule
(
address
reg
word1_
)
;
case
Tag
:
:
Expression
:
return
handler
-
>
ExpressionRule
(
address
reg
ImageSlice
(
(
const
char
*
)
word1_
(
size_t
)
word2_
)
)
;
case
Tag
:
:
ValExpression
:
return
handler
-
>
ValExpressionRule
(
address
reg
ImageSlice
(
(
const
char
*
)
word1_
(
size_t
)
word2_
)
)
;
default
:
MOZ_CRASH
(
)
;
}
}
void
SetBaseRegister
(
unsigned
reg
)
{
MOZ_ASSERT
(
isVALID
(
)
)
;
MOZ_ASSERT
(
isCanonical
(
)
)
;
switch
(
tag_
)
{
case
Tag
:
:
ValOffset
:
word1_
=
reg
;
break
;
case
Tag
:
:
Offset
:
case
Tag
:
:
Undefined
:
case
Tag
:
:
SameValue
:
case
Tag
:
:
Register
:
case
Tag
:
:
Expression
:
case
Tag
:
:
ValExpression
:
break
;
default
:
MOZ_CRASH
(
)
;
}
}
void
SetOffset
(
long
long
offset
)
{
MOZ_ASSERT
(
isVALID
(
)
)
;
MOZ_ASSERT
(
isCanonical
(
)
)
;
switch
(
tag_
)
{
case
Tag
:
:
ValOffset
:
word2_
=
offset
;
break
;
case
Tag
:
:
Offset
:
case
Tag
:
:
Undefined
:
case
Tag
:
:
SameValue
:
case
Tag
:
:
Register
:
case
Tag
:
:
Expression
:
case
Tag
:
:
ValExpression
:
break
;
default
:
MOZ_CRASH
(
)
;
}
}
string
show
(
)
const
{
char
buf
[
100
]
;
string
s
=
"
"
;
switch
(
tag_
)
{
case
Tag
:
:
INVALID
:
s
=
"
INVALID
"
;
break
;
case
Tag
:
:
Undefined
:
s
=
"
Undefined
"
;
break
;
case
Tag
:
:
SameValue
:
s
=
"
SameValue
"
;
break
;
case
Tag
:
:
Offset
:
s
=
"
Offset
{
.
.
}
"
;
break
;
case
Tag
:
:
ValOffset
:
sprintf
(
buf
"
ValOffset
{
reg
=
%
d
offs
=
%
lld
}
"
(
int
)
word1_
(
long
long
int
)
word2_
)
;
s
=
string
(
buf
)
;
break
;
case
Tag
:
:
Register
:
s
=
"
Register
{
.
.
}
"
;
break
;
case
Tag
:
:
Expression
:
s
=
"
Expression
{
.
.
}
"
;
break
;
case
Tag
:
:
ValExpression
:
s
=
"
ValExpression
{
.
.
}
"
;
break
;
default
:
MOZ_CRASH
(
)
;
}
return
s
;
}
}
;
class
CallFrameInfo
:
:
RuleMapLowLevel
{
using
Entry
=
pair
<
int
Rule
>
;
mozilla
:
:
Vector
<
Entry
12
>
entries_
;
public
:
void
clear
(
)
{
entries_
.
clear
(
)
;
}
RuleMapLowLevel
(
)
{
clear
(
)
;
}
RuleMapLowLevel
&
operator
=
(
const
RuleMapLowLevel
&
rhs
)
{
entries_
.
clear
(
)
;
for
(
size_t
i
=
0
;
i
<
rhs
.
entries_
.
length
(
)
;
i
+
+
)
{
bool
ok
=
entries_
.
append
(
rhs
.
entries_
[
i
]
)
;
MOZ_RELEASE_ASSERT
(
ok
)
;
}
return
*
this
;
}
void
set
(
int
reg
Rule
rule
)
{
MOZ_ASSERT
(
rule
.
isVALID
(
)
)
;
size_t
i
=
0
;
size_t
nEnt
=
entries_
.
length
(
)
;
while
(
i
<
nEnt
&
&
entries_
[
i
]
.
first
<
reg
)
{
i
+
+
;
}
if
(
i
=
=
nEnt
)
{
bool
ok
=
entries_
.
append
(
Entry
(
reg
rule
)
)
;
MOZ_RELEASE_ASSERT
(
ok
)
;
}
else
{
MOZ_ASSERT
(
i
<
nEnt
)
;
if
(
entries_
[
i
]
.
first
=
=
reg
)
{
entries_
[
i
]
.
second
=
rule
;
}
else
{
MOZ_ASSERT
(
entries_
[
i
]
.
first
>
reg
)
;
bool
ok
=
entries_
.
append
(
Entry
(
999999
Rule
:
:
mkINVALID
(
)
)
)
;
MOZ_RELEASE_ASSERT
(
ok
)
;
for
(
size_t
j
=
nEnt
;
j
>
=
i
+
1
;
j
-
-
)
{
entries_
[
j
]
=
entries_
[
j
-
1
]
;
}
entries_
[
i
]
=
Entry
(
reg
rule
)
;
}
}
for
(
size_t
i
=
0
;
i
<
entries_
.
length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
entries_
[
i
]
.
second
.
isVALID
(
)
)
;
MOZ_ASSERT_IF
(
i
>
0
entries_
[
i
-
1
]
.
first
<
entries_
[
i
]
.
first
)
;
}
MOZ_ASSERT
(
get
(
reg
)
.
isVALID
(
)
)
;
}
Rule
get
(
int
reg
)
const
{
size_t
nEnt
=
entries_
.
length
(
)
;
for
(
size_t
i
=
0
;
i
<
nEnt
;
i
+
+
)
{
if
(
entries_
[
i
]
.
first
=
=
reg
)
{
CallFrameInfo
:
:
Rule
ret
=
entries_
[
i
]
.
second
;
MOZ_ASSERT
(
ret
.
isVALID
(
)
)
;
return
ret
;
}
}
return
CallFrameInfo
:
:
Rule
:
:
mkINVALID
(
)
;
}
class
Iter
{
const
RuleMapLowLevel
*
rmll_
;
size_t
nextIx_
;
public
:
explicit
Iter
(
const
RuleMapLowLevel
*
rmll
)
:
rmll_
(
rmll
)
nextIx_
(
0
)
{
}
bool
avail
(
)
const
{
return
nextIx_
<
rmll_
-
>
entries_
.
length
(
)
;
}
bool
finished
(
)
const
{
return
!
avail
(
)
;
}
void
step
(
)
{
MOZ_RELEASE_ASSERT
(
nextIx_
<
rmll_
-
>
entries_
.
length
(
)
)
;
nextIx_
+
+
;
}
pair
<
int
Rule
>
peek
(
)
{
MOZ_RELEASE_ASSERT
(
nextIx_
<
rmll_
-
>
entries_
.
length
(
)
)
;
return
rmll_
-
>
entries_
[
nextIx_
]
;
}
}
;
}
;
class
CallFrameInfo
:
:
RuleMap
{
public
:
RuleMap
(
)
:
cfa_rule_
(
Rule
:
:
mkINVALID
(
)
)
{
}
RuleMap
(
const
RuleMap
&
rhs
)
:
cfa_rule_
(
Rule
:
:
mkINVALID
(
)
)
{
*
this
=
rhs
;
}
~
RuleMap
(
)
{
Clear
(
)
;
}
RuleMap
&
operator
=
(
const
RuleMap
&
rhs
)
;
void
SetCFARule
(
Rule
rule
)
{
cfa_rule_
=
rule
;
}
Rule
CFARule
(
)
const
{
return
cfa_rule_
;
}
Rule
*
CFARuleRef
(
)
{
return
&
cfa_rule_
;
}
Rule
RegisterRule
(
int
reg
)
const
;
void
SetRegisterRule
(
int
reg
Rule
rule
)
;
bool
HandleTransitionTo
(
Handler
*
handler
uint64
address
const
RuleMap
&
new_rules
)
const
;
private
:
void
Clear
(
)
;
Rule
cfa_rule_
;
RuleMapLowLevel
registers_
;
}
;
CallFrameInfo
:
:
RuleMap
&
CallFrameInfo
:
:
RuleMap
:
:
operator
=
(
const
RuleMap
&
rhs
)
{
Clear
(
)
;
if
(
rhs
.
cfa_rule_
.
isVALID
(
)
)
cfa_rule_
=
rhs
.
cfa_rule_
;
registers_
=
rhs
.
registers_
;
return
*
this
;
}
CallFrameInfo
:
:
Rule
CallFrameInfo
:
:
RuleMap
:
:
RegisterRule
(
int
reg
)
const
{
MOZ_ASSERT
(
reg
!
=
Handler
:
:
kCFARegister
)
;
return
registers_
.
get
(
reg
)
;
}
void
CallFrameInfo
:
:
RuleMap
:
:
SetRegisterRule
(
int
reg
Rule
rule
)
{
MOZ_ASSERT
(
reg
!
=
Handler
:
:
kCFARegister
)
;
MOZ_ASSERT
(
rule
.
isVALID
(
)
)
;
registers_
.
set
(
reg
rule
)
;
}
bool
CallFrameInfo
:
:
RuleMap
:
:
HandleTransitionTo
(
Handler
*
handler
uint64
address
const
RuleMap
&
new_rules
)
const
{
if
(
cfa_rule_
.
isVALID
(
)
&
&
new_rules
.
cfa_rule_
.
isVALID
(
)
)
{
if
(
cfa_rule_
!
=
new_rules
.
cfa_rule_
&
&
!
new_rules
.
cfa_rule_
.
Handle
(
handler
address
Handler
:
:
kCFARegister
)
)
{
return
false
;
}
}
else
if
(
cfa_rule_
.
isVALID
(
)
)
{
}
else
if
(
new_rules
.
cfa_rule_
.
isVALID
(
)
)
{
MOZ_ASSERT
(
0
)
;
}
else
{
}
RuleMapLowLevel
:
:
Iter
old_it
(
&
registers_
)
;
RuleMapLowLevel
:
:
Iter
new_it
(
&
new_rules
.
registers_
)
;
while
(
!
old_it
.
finished
(
)
&
&
!
new_it
.
finished
(
)
)
{
pair
<
int
Rule
>
old_pair
=
old_it
.
peek
(
)
;
pair
<
int
Rule
>
new_pair
=
new_it
.
peek
(
)
;
if
(
old_pair
.
first
<
new_pair
.
first
)
{
if
(
!
handler
-
>
SameValueRule
(
address
old_pair
.
first
)
)
{
return
false
;
}
old_it
.
step
(
)
;
}
else
if
(
old_pair
.
first
>
new_pair
.
first
)
{
MOZ_ASSERT
(
0
)
;
}
else
{
if
(
old_pair
.
second
!
=
new_pair
.
second
&
&
!
new_pair
.
second
.
Handle
(
handler
address
new_pair
.
first
)
)
{
return
false
;
}
new_it
.
step
(
)
;
old_it
.
step
(
)
;
}
}
while
(
!
old_it
.
finished
(
)
)
{
pair
<
int
Rule
>
old_pair
=
old_it
.
peek
(
)
;
if
(
!
handler
-
>
SameValueRule
(
address
old_pair
.
first
)
)
return
false
;
old_it
.
step
(
)
;
}
MOZ_ASSERT
(
new_it
.
finished
(
)
)
;
return
true
;
}
void
CallFrameInfo
:
:
RuleMap
:
:
Clear
(
)
{
cfa_rule_
=
Rule
:
:
mkINVALID
(
)
;
registers_
.
clear
(
)
;
}
class
CallFrameInfo
:
:
State
{
public
:
State
(
ByteReader
*
reader
Handler
*
handler
Reporter
*
reporter
uint64
address
)
:
reader_
(
reader
)
handler_
(
handler
)
reporter_
(
reporter
)
address_
(
address
)
entry_
(
NULL
)
cursor_
(
NULL
)
saved_rules_
(
NULL
)
{
}
~
State
(
)
{
if
(
saved_rules_
)
delete
saved_rules_
;
}
bool
InterpretCIE
(
const
CIE
&
cie
)
;
bool
InterpretFDE
(
const
FDE
&
fde
)
;
private
:
struct
Operands
{
unsigned
register_number
;
uint64
offset
;
long
signed_offset
;
ImageSlice
expression
;
}
;
bool
ParseOperands
(
const
char
*
format
Operands
*
operands
)
;
bool
DoInstruction
(
)
;
bool
DoDefCFA
(
unsigned
base_register
long
offset
)
;
bool
DoDefCFAOffset
(
long
offset
)
;
bool
DoRule
(
unsigned
reg
Rule
rule
)
;
bool
DoOffset
(
unsigned
reg
long
offset
)
;
bool
DoValOffset
(
unsigned
reg
long
offset
)
;
bool
DoRestore
(
unsigned
reg
)
;
uint64
CursorOffset
(
)
{
return
entry_
-
>
offset
+
(
cursor_
-
entry_
-
>
start
)
;
}
bool
ReportIncomplete
(
)
{
reporter_
-
>
Incomplete
(
entry_
-
>
offset
entry_
-
>
kind
)
;
return
false
;
}
ByteReader
*
reader_
;
Handler
*
handler_
;
Reporter
*
reporter_
;
uint64
address_
;
const
Entry
*
entry_
;
const
char
*
cursor_
;
RuleMap
rules_
;
RuleMap
cie_rules_
;
std
:
:
stack
<
RuleMap
>
*
saved_rules_
;
}
;
bool
CallFrameInfo
:
:
State
:
:
InterpretCIE
(
const
CIE
&
cie
)
{
entry_
=
&
cie
;
cursor_
=
entry_
-
>
instructions
;
while
(
cursor_
<
entry_
-
>
end
)
if
(
!
DoInstruction
(
)
)
return
false
;
cie_rules_
=
rules_
;
return
true
;
}
bool
CallFrameInfo
:
:
State
:
:
InterpretFDE
(
const
FDE
&
fde
)
{
entry_
=
&
fde
;
cursor_
=
entry_
-
>
instructions
;
while
(
cursor_
<
entry_
-
>
end
)
if
(
!
DoInstruction
(
)
)
return
false
;
return
true
;
}
bool
CallFrameInfo
:
:
State
:
:
ParseOperands
(
const
char
*
format
Operands
*
operands
)
{
size_t
len
;
const
char
*
operand
;
for
(
operand
=
format
;
*
operand
;
operand
+
+
)
{
size_t
bytes_left
=
entry_
-
>
end
-
cursor_
;
switch
(
*
operand
)
{
case
'
r
'
:
operands
-
>
register_number
=
reader_
-
>
ReadUnsignedLEB128
(
cursor_
&
len
)
;
if
(
len
>
bytes_left
)
return
ReportIncomplete
(
)
;
cursor_
+
=
len
;
break
;
case
'
o
'
:
operands
-
>
offset
=
reader_
-
>
ReadUnsignedLEB128
(
cursor_
&
len
)
;
if
(
len
>
bytes_left
)
return
ReportIncomplete
(
)
;
cursor_
+
=
len
;
break
;
case
'
s
'
:
operands
-
>
signed_offset
=
reader_
-
>
ReadSignedLEB128
(
cursor_
&
len
)
;
if
(
len
>
bytes_left
)
return
ReportIncomplete
(
)
;
cursor_
+
=
len
;
break
;
case
'
a
'
:
operands
-
>
offset
=
reader_
-
>
ReadEncodedPointer
(
cursor_
entry_
-
>
cie
-
>
pointer_encoding
&
len
)
;
if
(
len
>
bytes_left
)
return
ReportIncomplete
(
)
;
cursor_
+
=
len
;
break
;
case
'
1
'
:
if
(
1
>
bytes_left
)
return
ReportIncomplete
(
)
;
operands
-
>
offset
=
static_cast
<
unsigned
char
>
(
*
cursor_
+
+
)
;
break
;
case
'
2
'
:
if
(
2
>
bytes_left
)
return
ReportIncomplete
(
)
;
operands
-
>
offset
=
reader_
-
>
ReadTwoBytes
(
cursor_
)
;
cursor_
+
=
2
;
break
;
case
'
4
'
:
if
(
4
>
bytes_left
)
return
ReportIncomplete
(
)
;
operands
-
>
offset
=
reader_
-
>
ReadFourBytes
(
cursor_
)
;
cursor_
+
=
4
;
break
;
case
'
8
'
:
if
(
8
>
bytes_left
)
return
ReportIncomplete
(
)
;
operands
-
>
offset
=
reader_
-
>
ReadEightBytes
(
cursor_
)
;
cursor_
+
=
8
;
break
;
case
'
e
'
:
{
size_t
expression_length
=
reader_
-
>
ReadUnsignedLEB128
(
cursor_
&
len
)
;
if
(
len
>
bytes_left
|
|
expression_length
>
bytes_left
-
len
)
return
ReportIncomplete
(
)
;
cursor_
+
=
len
;
operands
-
>
expression
=
ImageSlice
(
cursor_
expression_length
)
;
cursor_
+
=
expression_length
;
break
;
}
default
:
MOZ_ASSERT
(
0
)
;
}
}
return
true
;
}
bool
CallFrameInfo
:
:
State
:
:
DoInstruction
(
)
{
CIE
*
cie
=
entry_
-
>
cie
;
Operands
ops
;
MOZ_ASSERT
(
entry_
-
>
kind
!
=
kUnknown
)
;
MOZ_ASSERT
(
cursor_
<
entry_
-
>
end
)
;
unsigned
opcode
=
*
cursor_
+
+
;
if
(
(
opcode
&
0xc0
)
!
=
0
)
{
switch
(
opcode
&
0xc0
)
{
case
DW_CFA_advance_loc
:
{
size_t
code_offset
=
opcode
&
0x3f
;
address_
+
=
code_offset
*
cie
-
>
code_alignment_factor
;
break
;
}
case
DW_CFA_offset
:
if
(
!
ParseOperands
(
"
o
"
&
ops
)
|
|
!
DoOffset
(
opcode
&
0x3f
ops
.
offset
*
cie
-
>
data_alignment_factor
)
)
return
false
;
break
;
case
DW_CFA_restore
:
if
(
!
DoRestore
(
opcode
&
0x3f
)
)
return
false
;
break
;
default
:
MOZ_ASSERT
(
0
)
;
}
return
true
;
}
switch
(
opcode
)
{
case
DW_CFA_set_loc
:
if
(
!
ParseOperands
(
"
a
"
&
ops
)
)
return
false
;
address_
=
ops
.
offset
;
break
;
case
DW_CFA_advance_loc1
:
if
(
!
ParseOperands
(
"
1
"
&
ops
)
)
return
false
;
address_
+
=
ops
.
offset
*
cie
-
>
code_alignment_factor
;
break
;
case
DW_CFA_advance_loc2
:
if
(
!
ParseOperands
(
"
2
"
&
ops
)
)
return
false
;
address_
+
=
ops
.
offset
*
cie
-
>
code_alignment_factor
;
break
;
case
DW_CFA_advance_loc4
:
if
(
!
ParseOperands
(
"
4
"
&
ops
)
)
return
false
;
address_
+
=
ops
.
offset
*
cie
-
>
code_alignment_factor
;
break
;
case
DW_CFA_MIPS_advance_loc8
:
if
(
!
ParseOperands
(
"
8
"
&
ops
)
)
return
false
;
address_
+
=
ops
.
offset
*
cie
-
>
code_alignment_factor
;
break
;
case
DW_CFA_def_cfa
:
if
(
!
ParseOperands
(
"
ro
"
&
ops
)
|
|
!
DoDefCFA
(
ops
.
register_number
ops
.
offset
)
)
return
false
;
break
;
case
DW_CFA_def_cfa_sf
:
if
(
!
ParseOperands
(
"
rs
"
&
ops
)
|
|
!
DoDefCFA
(
ops
.
register_number
ops
.
signed_offset
*
cie
-
>
data_alignment_factor
)
)
return
false
;
break
;
case
DW_CFA_def_cfa_register
:
{
Rule
*
cfa_rule
=
rules_
.
CFARuleRef
(
)
;
if
(
!
cfa_rule
-
>
isVALID
(
)
)
{
reporter_
-
>
NoCFARule
(
entry_
-
>
offset
entry_
-
>
kind
CursorOffset
(
)
)
;
return
false
;
}
if
(
!
ParseOperands
(
"
r
"
&
ops
)
)
return
false
;
cfa_rule
-
>
SetBaseRegister
(
ops
.
register_number
)
;
if
(
!
cfa_rule
-
>
Handle
(
handler_
address_
Handler
:
:
kCFARegister
)
)
return
false
;
break
;
}
case
DW_CFA_def_cfa_offset
:
if
(
!
ParseOperands
(
"
o
"
&
ops
)
|
|
!
DoDefCFAOffset
(
ops
.
offset
)
)
return
false
;
break
;
case
DW_CFA_def_cfa_offset_sf
:
if
(
!
ParseOperands
(
"
s
"
&
ops
)
|
|
!
DoDefCFAOffset
(
ops
.
signed_offset
*
cie
-
>
data_alignment_factor
)
)
return
false
;
break
;
case
DW_CFA_def_cfa_expression
:
{
if
(
!
ParseOperands
(
"
e
"
&
ops
)
)
return
false
;
Rule
rule
=
Rule
:
:
mkValExpressionRule
(
ops
.
expression
)
;
rules_
.
SetCFARule
(
rule
)
;
if
(
!
rule
.
Handle
(
handler_
address_
Handler
:
:
kCFARegister
)
)
return
false
;
break
;
}
case
DW_CFA_undefined
:
{
if
(
!
ParseOperands
(
"
r
"
&
ops
)
|
|
!
DoRule
(
ops
.
register_number
Rule
:
:
mkUndefinedRule
(
)
)
)
return
false
;
break
;
}
case
DW_CFA_same_value
:
{
if
(
!
ParseOperands
(
"
r
"
&
ops
)
|
|
!
DoRule
(
ops
.
register_number
Rule
:
:
mkSameValueRule
(
)
)
)
return
false
;
break
;
}
case
DW_CFA_offset_extended
:
if
(
!
ParseOperands
(
"
ro
"
&
ops
)
|
|
!
DoOffset
(
ops
.
register_number
ops
.
offset
*
cie
-
>
data_alignment_factor
)
)
return
false
;
break
;
case
DW_CFA_offset_extended_sf
:
if
(
!
ParseOperands
(
"
rs
"
&
ops
)
|
|
!
DoOffset
(
ops
.
register_number
ops
.
signed_offset
*
cie
-
>
data_alignment_factor
)
)
return
false
;
break
;
case
DW_CFA_GNU_negative_offset_extended
:
if
(
!
ParseOperands
(
"
ro
"
&
ops
)
|
|
!
DoOffset
(
ops
.
register_number
-
ops
.
offset
*
cie
-
>
data_alignment_factor
)
)
return
false
;
break
;
case
DW_CFA_val_offset
:
if
(
!
ParseOperands
(
"
ro
"
&
ops
)
|
|
!
DoValOffset
(
ops
.
register_number
ops
.
offset
*
cie
-
>
data_alignment_factor
)
)
return
false
;
break
;
case
DW_CFA_val_offset_sf
:
if
(
!
ParseOperands
(
"
rs
"
&
ops
)
|
|
!
DoValOffset
(
ops
.
register_number
ops
.
signed_offset
*
cie
-
>
data_alignment_factor
)
)
return
false
;
break
;
case
DW_CFA_register
:
{
if
(
!
ParseOperands
(
"
ro
"
&
ops
)
|
|
!
DoRule
(
ops
.
register_number
Rule
:
:
mkRegisterRule
(
ops
.
offset
)
)
)
return
false
;
break
;
}
case
DW_CFA_expression
:
{
if
(
!
ParseOperands
(
"
re
"
&
ops
)
|
|
!
DoRule
(
ops
.
register_number
Rule
:
:
mkExpressionRule
(
ops
.
expression
)
)
)
return
false
;
break
;
}
case
DW_CFA_val_expression
:
{
if
(
!
ParseOperands
(
"
re
"
&
ops
)
|
|
!
DoRule
(
ops
.
register_number
Rule
:
:
mkValExpressionRule
(
ops
.
expression
)
)
)
return
false
;
break
;
}
case
DW_CFA_restore_extended
:
if
(
!
ParseOperands
(
"
r
"
&
ops
)
|
|
!
DoRestore
(
ops
.
register_number
)
)
return
false
;
break
;
case
DW_CFA_remember_state
:
if
(
!
saved_rules_
)
{
saved_rules_
=
new
std
:
:
stack
<
RuleMap
>
(
)
;
}
saved_rules_
-
>
push
(
rules_
)
;
break
;
case
DW_CFA_restore_state
:
{
if
(
!
saved_rules_
|
|
saved_rules_
-
>
empty
(
)
)
{
reporter_
-
>
EmptyStateStack
(
entry_
-
>
offset
entry_
-
>
kind
CursorOffset
(
)
)
;
return
false
;
}
const
RuleMap
&
new_rules
=
saved_rules_
-
>
top
(
)
;
if
(
rules_
.
CFARule
(
)
.
isVALID
(
)
&
&
!
new_rules
.
CFARule
(
)
.
isVALID
(
)
)
{
reporter_
-
>
ClearingCFARule
(
entry_
-
>
offset
entry_
-
>
kind
CursorOffset
(
)
)
;
return
false
;
}
rules_
.
HandleTransitionTo
(
handler_
address_
new_rules
)
;
rules_
=
new_rules
;
saved_rules_
-
>
pop
(
)
;
break
;
}
case
DW_CFA_nop
:
break
;
case
DW_CFA_GNU_window_save
:
{
for
(
int
i
=
8
;
i
<
16
;
i
+
+
)
if
(
!
DoRule
(
i
Rule
:
:
mkRegisterRule
(
i
+
16
)
)
)
return
false
;
for
(
int
i
=
16
;
i
<
32
;
i
+
+
)
if
(
!
DoRule
(
i
Rule
:
:
mkOffsetRule
(
Handler
:
:
kCFARegister
(
i
-
16
)
*
reader_
-
>
AddressSize
(
)
)
)
)
return
false
;
break
;
}
case
DW_CFA_GNU_args_size
:
if
(
!
ParseOperands
(
"
o
"
&
ops
)
)
return
false
;
break
;
default
:
{
reporter_
-
>
BadInstruction
(
entry_
-
>
offset
entry_
-
>
kind
CursorOffset
(
)
)
;
return
false
;
}
}
return
true
;
}
bool
CallFrameInfo
:
:
State
:
:
DoDefCFA
(
unsigned
base_register
long
offset
)
{
Rule
rule
=
Rule
:
:
mkValOffsetRule
(
base_register
offset
)
;
rules_
.
SetCFARule
(
rule
)
;
return
rule
.
Handle
(
handler_
address_
Handler
:
:
kCFARegister
)
;
}
bool
CallFrameInfo
:
:
State
:
:
DoDefCFAOffset
(
long
offset
)
{
Rule
*
cfa_rule
=
rules_
.
CFARuleRef
(
)
;
if
(
!
cfa_rule
-
>
isVALID
(
)
)
{
reporter_
-
>
NoCFARule
(
entry_
-
>
offset
entry_
-
>
kind
CursorOffset
(
)
)
;
return
false
;
}
cfa_rule
-
>
SetOffset
(
offset
)
;
return
cfa_rule
-
>
Handle
(
handler_
address_
Handler
:
:
kCFARegister
)
;
}
bool
CallFrameInfo
:
:
State
:
:
DoRule
(
unsigned
reg
Rule
rule
)
{
rules_
.
SetRegisterRule
(
reg
rule
)
;
return
rule
.
Handle
(
handler_
address_
reg
)
;
}
bool
CallFrameInfo
:
:
State
:
:
DoOffset
(
unsigned
reg
long
offset
)
{
if
(
!
rules_
.
CFARule
(
)
.
isVALID
(
)
)
{
reporter_
-
>
NoCFARule
(
entry_
-
>
offset
entry_
-
>
kind
CursorOffset
(
)
)
;
return
false
;
}
Rule
rule
=
Rule
:
:
mkOffsetRule
(
Handler
:
:
kCFARegister
offset
)
;
return
DoRule
(
reg
rule
)
;
}
bool
CallFrameInfo
:
:
State
:
:
DoValOffset
(
unsigned
reg
long
offset
)
{
if
(
!
rules_
.
CFARule
(
)
.
isVALID
(
)
)
{
reporter_
-
>
NoCFARule
(
entry_
-
>
offset
entry_
-
>
kind
CursorOffset
(
)
)
;
return
false
;
}
return
DoRule
(
reg
Rule
:
:
mkValOffsetRule
(
Handler
:
:
kCFARegister
offset
)
)
;
}
bool
CallFrameInfo
:
:
State
:
:
DoRestore
(
unsigned
reg
)
{
if
(
entry_
-
>
kind
=
=
kCIE
)
{
reporter_
-
>
RestoreInCIE
(
entry_
-
>
offset
CursorOffset
(
)
)
;
return
false
;
}
Rule
rule
=
cie_rules_
.
RegisterRule
(
reg
)
;
if
(
!
rule
.
isVALID
(
)
)
{
rule
=
Rule
:
:
mkSameValueRule
(
)
;
}
return
DoRule
(
reg
rule
)
;
}
bool
CallFrameInfo
:
:
ReadEntryPrologue
(
const
char
*
cursor
Entry
*
entry
)
{
const
char
*
buffer_end
=
buffer_
+
buffer_length_
;
entry
-
>
offset
=
cursor
-
buffer_
;
entry
-
>
start
=
cursor
;
entry
-
>
kind
=
kUnknown
;
entry
-
>
end
=
NULL
;
size_t
length_size
;
uint64
length
=
reader_
-
>
ReadInitialLength
(
cursor
&
length_size
)
;
if
(
length_size
>
size_t
(
buffer_end
-
cursor
)
)
return
ReportIncomplete
(
entry
)
;
cursor
+
=
length_size
;
if
(
length
=
=
0
&
&
eh_frame_
)
{
entry
-
>
kind
=
kTerminator
;
entry
-
>
end
=
cursor
;
return
true
;
}
if
(
length
>
size_t
(
buffer_end
-
cursor
)
)
return
ReportIncomplete
(
entry
)
;
entry
-
>
end
=
cursor
+
length
;
size_t
offset_size
=
reader_
-
>
OffsetSize
(
)
;
if
(
offset_size
>
size_t
(
entry
-
>
end
-
cursor
)
)
return
ReportIncomplete
(
entry
)
;
entry
-
>
id
=
reader_
-
>
ReadOffset
(
cursor
)
;
if
(
eh_frame_
)
{
if
(
entry
-
>
id
=
=
0
)
{
entry
-
>
kind
=
kCIE
;
}
else
{
entry
-
>
kind
=
kFDE
;
entry
-
>
id
=
(
cursor
-
buffer_
)
-
entry
-
>
id
;
}
}
else
{
if
(
offset_size
=
=
4
)
entry
-
>
kind
=
(
entry
-
>
id
=
=
0xffffffff
)
?
kCIE
:
kFDE
;
else
{
MOZ_ASSERT
(
offset_size
=
=
8
)
;
entry
-
>
kind
=
(
entry
-
>
id
=
=
0xffffffffffffffffULL
)
?
kCIE
:
kFDE
;
}
}
cursor
+
=
offset_size
;
entry
-
>
fields
=
cursor
;
entry
-
>
cie
=
NULL
;
return
true
;
}
bool
CallFrameInfo
:
:
ReadCIEFields
(
CIE
*
cie
)
{
const
char
*
cursor
=
cie
-
>
fields
;
size_t
len
;
MOZ_ASSERT
(
cie
-
>
kind
=
=
kCIE
)
;
cie
-
>
version
=
0
;
cie
-
>
augmentation
.
clear
(
)
;
cie
-
>
code_alignment_factor
=
0
;
cie
-
>
data_alignment_factor
=
0
;
cie
-
>
return_address_register
=
0
;
cie
-
>
has_z_augmentation
=
false
;
cie
-
>
pointer_encoding
=
DW_EH_PE_absptr
;
cie
-
>
instructions
=
0
;
if
(
cie
-
>
end
-
cursor
<
1
)
return
ReportIncomplete
(
cie
)
;
cie
-
>
version
=
reader_
-
>
ReadOneByte
(
cursor
)
;
cursor
+
+
;
if
(
cie
-
>
version
<
1
|
|
cie
-
>
version
>
4
)
{
reporter_
-
>
UnrecognizedVersion
(
cie
-
>
offset
cie
-
>
version
)
;
return
false
;
}
const
char
*
augmentation_start
=
cursor
;
const
void
*
augmentation_end
=
memchr
(
augmentation_start
'
\
0
'
cie
-
>
end
-
augmentation_start
)
;
if
(
!
augmentation_end
)
return
ReportIncomplete
(
cie
)
;
cursor
=
static_cast
<
const
char
*
>
(
augmentation_end
)
;
cie
-
>
augmentation
=
string
(
augmentation_start
cursor
-
augmentation_start
)
;
cursor
+
+
;
if
(
!
cie
-
>
augmentation
.
empty
(
)
)
{
if
(
cie
-
>
augmentation
[
0
]
=
=
DW_Z_augmentation_start
)
{
cie
-
>
has_z_augmentation
=
true
;
}
else
{
reporter_
-
>
UnrecognizedAugmentation
(
cie
-
>
offset
cie
-
>
augmentation
)
;
return
false
;
}
}
if
(
cie
-
>
version
>
=
4
)
{
if
(
cie
-
>
end
-
cursor
<
2
)
{
return
ReportIncomplete
(
cie
)
;
}
uint8_t
address_size
=
reader_
-
>
ReadOneByte
(
cursor
)
;
cursor
+
+
;
if
(
address_size
!
=
sizeof
(
void
*
)
)
{
reporter_
-
>
InvalidDwarf4Artefact
(
cie
-
>
offset
"
Invalid
address_size
"
)
;
return
false
;
}
uint8_t
segment_size
=
reader_
-
>
ReadOneByte
(
cursor
)
;
cursor
+
+
;
if
(
segment_size
!
=
0
)
{
reporter_
-
>
InvalidDwarf4Artefact
(
cie
-
>
offset
"
Invalid
segment_size
"
)
;
return
false
;
}
}
cie
-
>
code_alignment_factor
=
reader_
-
>
ReadUnsignedLEB128
(
cursor
&
len
)
;
if
(
size_t
(
cie
-
>
end
-
cursor
)
<
len
)
return
ReportIncomplete
(
cie
)
;
cursor
+
=
len
;
cie
-
>
data_alignment_factor
=
reader_
-
>
ReadSignedLEB128
(
cursor
&
len
)
;
if
(
size_t
(
cie
-
>
end
-
cursor
)
<
len
)
return
ReportIncomplete
(
cie
)
;
cursor
+
=
len
;
if
(
cie
-
>
version
=
=
1
)
{
if
(
cursor
>
=
cie
-
>
end
)
return
ReportIncomplete
(
cie
)
;
cie
-
>
return_address_register
=
uint8
(
*
cursor
+
+
)
;
}
else
{
cie
-
>
return_address_register
=
reader_
-
>
ReadUnsignedLEB128
(
cursor
&
len
)
;
if
(
size_t
(
cie
-
>
end
-
cursor
)
<
len
)
return
ReportIncomplete
(
cie
)
;
cursor
+
=
len
;
}
if
(
cie
-
>
has_z_augmentation
)
{
uint64_t
data_size
=
reader_
-
>
ReadUnsignedLEB128
(
cursor
&
len
)
;
if
(
size_t
(
cie
-
>
end
-
cursor
)
<
len
+
data_size
)
return
ReportIncomplete
(
cie
)
;
cursor
+
=
len
;
const
char
*
data
=
cursor
;
cursor
+
=
data_size
;
const
char
*
data_end
=
cursor
;
cie
-
>
has_z_lsda
=
false
;
cie
-
>
has_z_personality
=
false
;
cie
-
>
has_z_signal_frame
=
false
;
for
(
size_t
i
=
1
;
i
<
cie
-
>
augmentation
.
size
(
)
;
i
+
+
)
{
switch
(
cie
-
>
augmentation
[
i
]
)
{
case
DW_Z_has_LSDA
:
cie
-
>
has_z_lsda
=
true
;
if
(
data
>
=
data_end
)
return
ReportIncomplete
(
cie
)
;
cie
-
>
lsda_encoding
=
DwarfPointerEncoding
(
*
data
+
+
)
;
if
(
!
reader_
-
>
ValidEncoding
(
cie
-
>
lsda_encoding
)
)
{
reporter_
-
>
InvalidPointerEncoding
(
cie
-
>
offset
cie
-
>
lsda_encoding
)
;
return
false
;
}
break
;
case
DW_Z_has_personality_routine
:
cie
-
>
has_z_personality
=
true
;
if
(
data
>
=
data_end
)
return
ReportIncomplete
(
cie
)
;
cie
-
>
personality_encoding
=
DwarfPointerEncoding
(
*
data
+
+
)
;
if
(
!
reader_
-
>
ValidEncoding
(
cie
-
>
personality_encoding
)
)
{
reporter_
-
>
InvalidPointerEncoding
(
cie
-
>
offset
cie
-
>
personality_encoding
)
;
return
false
;
}
if
(
!
reader_
-
>
UsableEncoding
(
cie
-
>
personality_encoding
)
)
{
reporter_
-
>
UnusablePointerEncoding
(
cie
-
>
offset
cie
-
>
personality_encoding
)
;
return
false
;
}
cie
-
>
personality_address
=
reader_
-
>
ReadEncodedPointer
(
data
cie
-
>
personality_encoding
&
len
)
;
if
(
len
>
size_t
(
data_end
-
data
)
)
return
ReportIncomplete
(
cie
)
;
data
+
=
len
;
break
;
case
DW_Z_has_FDE_address_encoding
:
if
(
data
>
=
data_end
)
return
ReportIncomplete
(
cie
)
;
cie
-
>
pointer_encoding
=
DwarfPointerEncoding
(
*
data
+
+
)
;
if
(
!
reader_
-
>
ValidEncoding
(
cie
-
>
pointer_encoding
)
)
{
reporter_
-
>
InvalidPointerEncoding
(
cie
-
>
offset
cie
-
>
pointer_encoding
)
;
return
false
;
}
if
(
!
reader_
-
>
UsableEncoding
(
cie
-
>
pointer_encoding
)
)
{
reporter_
-
>
UnusablePointerEncoding
(
cie
-
>
offset
cie
-
>
pointer_encoding
)
;
return
false
;
}
break
;
case
DW_Z_is_signal_trampoline
:
cie
-
>
has_z_signal_frame
=
true
;
break
;
default
:
reporter_
-
>
UnrecognizedAugmentation
(
cie
-
>
offset
cie
-
>
augmentation
)
;
return
false
;
}
}
}
cie
-
>
instructions
=
cursor
;
return
true
;
}
bool
CallFrameInfo
:
:
ReadFDEFields
(
FDE
*
fde
)
{
const
char
*
cursor
=
fde
-
>
fields
;
size_t
size
;
fde
-
>
address
=
reader_
-
>
ReadEncodedPointer
(
cursor
fde
-
>
cie
-
>
pointer_encoding
&
size
)
;
if
(
size
>
size_t
(
fde
-
>
end
-
cursor
)
)
return
ReportIncomplete
(
fde
)
;
cursor
+
=
size
;
reader_
-
>
SetFunctionBase
(
fde
-
>
address
)
;
DwarfPointerEncoding
length_encoding
=
DwarfPointerEncoding
(
fde
-
>
cie
-
>
pointer_encoding
&
0x0f
)
;
fde
-
>
size
=
reader_
-
>
ReadEncodedPointer
(
cursor
length_encoding
&
size
)
;
if
(
size
>
size_t
(
fde
-
>
end
-
cursor
)
)
return
ReportIncomplete
(
fde
)
;
cursor
+
=
size
;
if
(
fde
-
>
cie
-
>
has_z_augmentation
)
{
uint64_t
data_size
=
reader_
-
>
ReadUnsignedLEB128
(
cursor
&
size
)
;
if
(
size_t
(
fde
-
>
end
-
cursor
)
<
size
+
data_size
)
return
ReportIncomplete
(
fde
)
;
cursor
+
=
size
;
if
(
fde
-
>
cie
-
>
has_z_lsda
)
{
if
(
!
reader_
-
>
UsableEncoding
(
fde
-
>
cie
-
>
lsda_encoding
)
)
{
reporter_
-
>
UnusablePointerEncoding
(
fde
-
>
cie
-
>
offset
fde
-
>
cie
-
>
lsda_encoding
)
;
return
false
;
}
fde
-
>
lsda_address
=
reader_
-
>
ReadEncodedPointer
(
cursor
fde
-
>
cie
-
>
lsda_encoding
&
size
)
;
if
(
size
>
data_size
)
return
ReportIncomplete
(
fde
)
;
}
cursor
+
=
data_size
;
}
fde
-
>
instructions
=
cursor
;
return
true
;
}
bool
CallFrameInfo
:
:
Start
(
)
{
const
char
*
buffer_end
=
buffer_
+
buffer_length_
;
const
char
*
cursor
;
bool
all_ok
=
true
;
const
char
*
entry_end
;
bool
ok
;
for
(
cursor
=
buffer_
;
cursor
<
buffer_end
;
cursor
=
entry_end
all_ok
=
all_ok
&
&
ok
)
{
FDE
fde
;
ok
=
false
;
if
(
!
ReadEntryPrologue
(
cursor
&
fde
)
)
{
if
(
!
fde
.
end
)
{
all_ok
=
false
;
break
;
}
entry_end
=
fde
.
end
;
continue
;
}
entry_end
=
fde
.
end
;
if
(
fde
.
kind
=
=
kTerminator
)
{
if
(
fde
.
end
<
buffer_end
)
reporter_
-
>
EarlyEHTerminator
(
fde
.
offset
)
;
break
;
}
if
(
fde
.
kind
!
=
kFDE
)
{
ok
=
true
;
continue
;
}
if
(
fde
.
id
>
buffer_length_
)
{
reporter_
-
>
CIEPointerOutOfRange
(
fde
.
offset
fde
.
id
)
;
continue
;
}
CIE
cie
;
if
(
!
ReadEntryPrologue
(
buffer_
+
fde
.
id
&
cie
)
)
continue
;
if
(
cie
.
kind
!
=
kCIE
)
{
reporter_
-
>
BadCIEId
(
fde
.
offset
fde
.
id
)
;
continue
;
}
if
(
!
ReadCIEFields
(
&
cie
)
)
continue
;
cie
.
cie
=
&
cie
;
fde
.
cie
=
&
cie
;
if
(
!
ReadFDEFields
(
&
fde
)
)
continue
;
if
(
!
handler_
-
>
Entry
(
fde
.
offset
fde
.
address
fde
.
size
cie
.
version
cie
.
augmentation
cie
.
return_address_register
)
)
{
ok
=
true
;
continue
;
}
if
(
cie
.
has_z_augmentation
)
{
if
(
cie
.
has_z_personality
)
{
if
(
!
handler_
-
>
PersonalityRoutine
(
cie
.
personality_address
IsIndirectEncoding
(
cie
.
personality_encoding
)
)
)
continue
;
}
if
(
cie
.
has_z_lsda
)
{
if
(
!
handler_
-
>
LanguageSpecificDataArea
(
fde
.
lsda_address
IsIndirectEncoding
(
cie
.
lsda_encoding
)
)
)
continue
;
}
if
(
cie
.
has_z_signal_frame
)
{
if
(
!
handler_
-
>
SignalHandler
(
)
)
continue
;
}
}
State
state
(
reader_
handler_
reporter_
fde
.
address
)
;
ok
=
state
.
InterpretCIE
(
cie
)
&
&
state
.
InterpretFDE
(
fde
)
;
reader_
-
>
ClearFunctionBase
(
)
;
handler_
-
>
End
(
)
;
}
return
all_ok
;
}
const
char
*
CallFrameInfo
:
:
KindName
(
EntryKind
kind
)
{
if
(
kind
=
=
CallFrameInfo
:
:
kUnknown
)
return
"
entry
"
;
else
if
(
kind
=
=
CallFrameInfo
:
:
kCIE
)
return
"
common
information
entry
"
;
else
if
(
kind
=
=
CallFrameInfo
:
:
kFDE
)
return
"
frame
description
entry
"
;
else
{
MOZ_ASSERT
(
kind
=
=
CallFrameInfo
:
:
kTerminator
)
;
return
"
.
eh_frame
sequence
terminator
"
;
}
}
bool
CallFrameInfo
:
:
ReportIncomplete
(
Entry
*
entry
)
{
reporter_
-
>
Incomplete
(
entry
-
>
offset
entry
-
>
kind
)
;
return
false
;
}
void
CallFrameInfo
:
:
Reporter
:
:
Incomplete
(
uint64
offset
CallFrameInfo
:
:
EntryKind
kind
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
%
s
:
CFI
%
s
at
offset
0x
%
llx
in
'
%
s
'
:
entry
ends
early
\
n
"
filename_
.
c_str
(
)
CallFrameInfo
:
:
KindName
(
kind
)
offset
section_
.
c_str
(
)
)
;
log_
(
buf
)
;
}
void
CallFrameInfo
:
:
Reporter
:
:
EarlyEHTerminator
(
uint64
offset
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
%
s
:
CFI
at
offset
0x
%
llx
in
'
%
s
'
:
saw
end
-
of
-
data
marker
"
"
before
end
of
section
contents
\
n
"
filename_
.
c_str
(
)
offset
section_
.
c_str
(
)
)
;
log_
(
buf
)
;
}
void
CallFrameInfo
:
:
Reporter
:
:
CIEPointerOutOfRange
(
uint64
offset
uint64
cie_offset
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
%
s
:
CFI
frame
description
entry
at
offset
0x
%
llx
in
'
%
s
'
:
"
"
CIE
pointer
is
out
of
range
:
0x
%
llx
\
n
"
filename_
.
c_str
(
)
offset
section_
.
c_str
(
)
cie_offset
)
;
log_
(
buf
)
;
}
void
CallFrameInfo
:
:
Reporter
:
:
BadCIEId
(
uint64
offset
uint64
cie_offset
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
%
s
:
CFI
frame
description
entry
at
offset
0x
%
llx
in
'
%
s
'
:
"
"
CIE
pointer
does
not
point
to
a
CIE
:
0x
%
llx
\
n
"
filename_
.
c_str
(
)
offset
section_
.
c_str
(
)
cie_offset
)
;
log_
(
buf
)
;
}
void
CallFrameInfo
:
:
Reporter
:
:
UnrecognizedVersion
(
uint64
offset
int
version
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
%
s
:
CFI
frame
description
entry
at
offset
0x
%
llx
in
'
%
s
'
:
"
"
CIE
specifies
unrecognized
version
:
%
d
\
n
"
filename_
.
c_str
(
)
offset
section_
.
c_str
(
)
version
)
;
log_
(
buf
)
;
}
void
CallFrameInfo
:
:
Reporter
:
:
UnrecognizedAugmentation
(
uint64
offset
const
string
&
aug
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
%
s
:
CFI
frame
description
entry
at
offset
0x
%
llx
in
'
%
s
'
:
"
"
CIE
specifies
unrecognized
augmentation
:
'
%
s
'
\
n
"
filename_
.
c_str
(
)
offset
section_
.
c_str
(
)
aug
.
c_str
(
)
)
;
log_
(
buf
)
;
}
void
CallFrameInfo
:
:
Reporter
:
:
InvalidDwarf4Artefact
(
uint64
offset
const
char
*
what
)
{
char
*
what_safe
=
strndup
(
what
100
)
;
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
%
s
:
CFI
frame
description
entry
at
offset
0x
%
llx
in
'
%
s
'
:
"
"
CIE
specifies
invalid
Dwarf4
artefact
:
%
s
\
n
"
filename_
.
c_str
(
)
offset
section_
.
c_str
(
)
what_safe
)
;
log_
(
buf
)
;
free
(
what_safe
)
;
}
void
CallFrameInfo
:
:
Reporter
:
:
InvalidPointerEncoding
(
uint64
offset
uint8
encoding
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
%
s
:
CFI
common
information
entry
at
offset
0x
%
llx
in
'
%
s
'
:
"
"
'
z
'
augmentation
specifies
invalid
pointer
encoding
:
"
"
0x
%
02x
\
n
"
filename_
.
c_str
(
)
offset
section_
.
c_str
(
)
encoding
)
;
log_
(
buf
)
;
}
void
CallFrameInfo
:
:
Reporter
:
:
UnusablePointerEncoding
(
uint64
offset
uint8
encoding
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
%
s
:
CFI
common
information
entry
at
offset
0x
%
llx
in
'
%
s
'
:
"
"
'
z
'
augmentation
specifies
a
pointer
encoding
for
which
"
"
we
have
no
base
address
:
0x
%
02x
\
n
"
filename_
.
c_str
(
)
offset
section_
.
c_str
(
)
encoding
)
;
log_
(
buf
)
;
}
void
CallFrameInfo
:
:
Reporter
:
:
RestoreInCIE
(
uint64
offset
uint64
insn_offset
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
%
s
:
CFI
common
information
entry
at
offset
0x
%
llx
in
'
%
s
'
:
"
"
the
DW_CFA_restore
instruction
at
offset
0x
%
llx
"
"
cannot
be
used
in
a
common
information
entry
\
n
"
filename_
.
c_str
(
)
offset
section_
.
c_str
(
)
insn_offset
)
;
log_
(
buf
)
;
}
void
CallFrameInfo
:
:
Reporter
:
:
BadInstruction
(
uint64
offset
CallFrameInfo
:
:
EntryKind
kind
uint64
insn_offset
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
%
s
:
CFI
%
s
at
offset
0x
%
llx
in
section
'
%
s
'
:
"
"
the
instruction
at
offset
0x
%
llx
is
unrecognized
\
n
"
filename_
.
c_str
(
)
CallFrameInfo
:
:
KindName
(
kind
)
offset
section_
.
c_str
(
)
insn_offset
)
;
log_
(
buf
)
;
}
void
CallFrameInfo
:
:
Reporter
:
:
NoCFARule
(
uint64
offset
CallFrameInfo
:
:
EntryKind
kind
uint64
insn_offset
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
%
s
:
CFI
%
s
at
offset
0x
%
llx
in
section
'
%
s
'
:
"
"
the
instruction
at
offset
0x
%
llx
assumes
that
a
CFA
rule
"
"
has
been
set
but
none
has
been
set
\
n
"
filename_
.
c_str
(
)
CallFrameInfo
:
:
KindName
(
kind
)
offset
section_
.
c_str
(
)
insn_offset
)
;
log_
(
buf
)
;
}
void
CallFrameInfo
:
:
Reporter
:
:
EmptyStateStack
(
uint64
offset
CallFrameInfo
:
:
EntryKind
kind
uint64
insn_offset
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
%
s
:
CFI
%
s
at
offset
0x
%
llx
in
section
'
%
s
'
:
"
"
the
DW_CFA_restore_state
instruction
at
offset
0x
%
llx
"
"
should
pop
a
saved
state
from
the
stack
but
the
stack
"
"
is
empty
\
n
"
filename_
.
c_str
(
)
CallFrameInfo
:
:
KindName
(
kind
)
offset
section_
.
c_str
(
)
insn_offset
)
;
log_
(
buf
)
;
}
void
CallFrameInfo
:
:
Reporter
:
:
ClearingCFARule
(
uint64
offset
CallFrameInfo
:
:
EntryKind
kind
uint64
insn_offset
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
%
s
:
CFI
%
s
at
offset
0x
%
llx
in
section
'
%
s
'
:
"
"
the
DW_CFA_restore_state
instruction
at
offset
0x
%
llx
"
"
would
clear
the
CFA
rule
in
effect
\
n
"
filename_
.
c_str
(
)
CallFrameInfo
:
:
KindName
(
kind
)
offset
section_
.
c_str
(
)
insn_offset
)
;
log_
(
buf
)
;
}
unsigned
int
DwarfCFIToModule
:
:
RegisterNames
:
:
I386
(
)
{
return
8
+
3
+
8
+
2
+
8
+
8
+
3
+
8
+
2
;
}
unsigned
int
DwarfCFIToModule
:
:
RegisterNames
:
:
X86_64
(
)
{
return
8
+
8
+
1
+
8
+
8
+
8
+
8
+
1
+
8
+
4
+
2
+
3
;
}
unsigned
int
DwarfCFIToModule
:
:
RegisterNames
:
:
ARM
(
)
{
return
13
*
8
;
}
unsigned
int
DwarfCFIToModule
:
:
RegisterNames
:
:
ARM64
(
)
{
return
12
*
8
;
}
unsigned
int
DwarfCFIToModule
:
:
RegisterNames
:
:
MIPS
(
)
{
return
8
+
8
+
8
+
8
+
9
+
8
+
7
+
7
+
6
;
}
int32_t
parseDwarfExpr
(
Summariser
*
summ
const
ByteReader
*
reader
ImageSlice
expr
bool
debug
bool
pushCfaAtStart
bool
derefAtEnd
)
{
const
char
*
cursor
=
expr
.
start_
;
const
char
*
end1
=
cursor
+
expr
.
length_
;
char
buf
[
100
]
;
if
(
debug
)
{
SprintfLiteral
(
buf
"
LUL
.
DW
<
<
DwarfExpr
len
is
%
d
\
n
"
(
int
)
(
end1
-
cursor
)
)
;
summ
-
>
Log
(
buf
)
;
}
int32_t
start_ix
=
summ
-
>
AddPfxInstr
(
PfxInstr
(
PX_Start
pushCfaAtStart
?
1
:
0
)
)
;
MOZ_ASSERT
(
start_ix
>
=
0
)
;
while
(
cursor
<
end1
)
{
uint8
opc
=
reader
-
>
ReadOneByte
(
cursor
)
;
cursor
+
+
;
const
char
*
nm
=
nullptr
;
PfxExprOp
pxop
=
PX_End
;
switch
(
opc
)
{
case
DW_OP_lit0
.
.
.
DW_OP_lit31
:
{
int32_t
simm32
=
(
int32_t
)
(
opc
-
DW_OP_lit0
)
;
if
(
debug
)
{
SprintfLiteral
(
buf
"
LUL
.
DW
DW_OP_lit
%
d
\
n
"
(
int
)
simm32
)
;
summ
-
>
Log
(
buf
)
;
}
(
void
)
summ
-
>
AddPfxInstr
(
PfxInstr
(
PX_SImm32
simm32
)
)
;
break
;
}
case
DW_OP_breg0
.
.
.
DW_OP_breg31
:
{
size_t
len
;
int64_t
n
=
reader
-
>
ReadSignedLEB128
(
cursor
&
len
)
;
cursor
+
=
len
;
DW_REG_NUMBER
reg
=
(
DW_REG_NUMBER
)
(
opc
-
DW_OP_breg0
)
;
if
(
debug
)
{
SprintfLiteral
(
buf
"
LUL
.
DW
DW_OP_breg
%
d
%
lld
\
n
"
(
int
)
reg
(
long
long
int
)
n
)
;
summ
-
>
Log
(
buf
)
;
}
if
(
n
<
INT32_MIN
|
|
INT32_MAX
<
n
)
goto
fail
;
(
void
)
summ
-
>
AddPfxInstr
(
PfxInstr
(
PX_DwReg
reg
)
)
;
(
void
)
summ
-
>
AddPfxInstr
(
PfxInstr
(
PX_SImm32
(
int32_t
)
n
)
)
;
(
void
)
summ
-
>
AddPfxInstr
(
PfxInstr
(
PX_Add
)
)
;
break
;
}
case
DW_OP_const4s
:
{
uint64_t
u64
=
reader
-
>
ReadFourBytes
(
cursor
)
;
cursor
+
=
4
;
uint32_t
u32
=
(
uint32_t
)
(
u64
&
0xFFFFFFFF
)
;
int32_t
s32
=
(
int32_t
)
u32
;
if
(
debug
)
{
SprintfLiteral
(
buf
"
LUL
.
DW
DW_OP_const4s
%
d
\
n
"
(
int
)
s32
)
;
summ
-
>
Log
(
buf
)
;
}
(
void
)
summ
-
>
AddPfxInstr
(
PfxInstr
(
PX_SImm32
s32
)
)
;
break
;
}
case
DW_OP_deref
:
nm
=
"
deref
"
;
pxop
=
PX_Deref
;
goto
no_operands
;
case
DW_OP_and
:
nm
=
"
and
"
;
pxop
=
PX_And
;
goto
no_operands
;
case
DW_OP_plus
:
nm
=
"
plus
"
;
pxop
=
PX_Add
;
goto
no_operands
;
case
DW_OP_minus
:
nm
=
"
minus
"
;
pxop
=
PX_Sub
;
goto
no_operands
;
case
DW_OP_shl
:
nm
=
"
shl
"
;
pxop
=
PX_Shl
;
goto
no_operands
;
case
DW_OP_ge
:
nm
=
"
ge
"
;
pxop
=
PX_CmpGES
;
goto
no_operands
;
no_operands
:
MOZ_ASSERT
(
nm
&
&
pxop
!
=
PX_End
)
;
if
(
debug
)
{
SprintfLiteral
(
buf
"
LUL
.
DW
DW_OP_
%
s
\
n
"
nm
)
;
summ
-
>
Log
(
buf
)
;
}
(
void
)
summ
-
>
AddPfxInstr
(
PfxInstr
(
pxop
)
)
;
break
;
default
:
if
(
debug
)
{
SprintfLiteral
(
buf
"
LUL
.
DW
unknown
opc
%
d
\
n
"
(
int
)
opc
)
;
summ
-
>
Log
(
buf
)
;
}
goto
fail
;
}
}
MOZ_ASSERT
(
cursor
>
=
end1
)
;
if
(
cursor
>
end1
)
{
goto
fail
;
}
if
(
derefAtEnd
)
{
(
void
)
summ
-
>
AddPfxInstr
(
PfxInstr
(
PX_Deref
)
)
;
}
(
void
)
summ
-
>
AddPfxInstr
(
PfxInstr
(
PX_End
)
)
;
if
(
debug
)
{
SprintfLiteral
(
buf
"
LUL
.
DW
conversion
of
dwarf
expression
succeeded
"
"
ix
=
%
d
\
n
"
(
int
)
start_ix
)
;
summ
-
>
Log
(
buf
)
;
summ
-
>
Log
(
"
LUL
.
DW
>
>
\
n
"
)
;
}
return
start_ix
;
fail
:
if
(
debug
)
{
summ
-
>
Log
(
"
LUL
.
DW
conversion
of
dwarf
expression
failed
\
n
"
)
;
summ
-
>
Log
(
"
LUL
.
DW
>
>
\
n
"
)
;
}
return
-
1
;
}
bool
DwarfCFIToModule
:
:
Entry
(
size_t
offset
uint64
address
uint64
length
uint8
version
const
string
&
augmentation
unsigned
return_address
)
{
if
(
DEBUG_DWARF
)
{
char
buf
[
100
]
;
SprintfLiteral
(
buf
"
LUL
.
DW
DwarfCFIToModule
:
:
Entry
0x
%
llx
+
%
lld
\
n
"
address
length
)
;
summ_
-
>
Log
(
buf
)
;
}
summ_
-
>
Entry
(
address
length
)
;
return_address_
=
return_address
;
if
(
return_address_
<
num_dw_regs_
)
{
summ_
-
>
Rule
(
address
return_address_
NODEREF
return_address
0
)
;
}
return
true
;
}
const
UniqueString
*
DwarfCFIToModule
:
:
RegisterName
(
int
i
)
{
if
(
i
<
0
)
{
MOZ_ASSERT
(
i
=
=
kCFARegister
)
;
return
usu_
-
>
ToUniqueString
(
"
.
cfa
"
)
;
}
unsigned
reg
=
i
;
if
(
reg
=
=
return_address_
)
return
usu_
-
>
ToUniqueString
(
"
.
ra
"
)
;
char
buf
[
30
]
;
SprintfLiteral
(
buf
"
dwarf_reg_
%
u
"
reg
)
;
return
usu_
-
>
ToUniqueString
(
buf
)
;
}
bool
DwarfCFIToModule
:
:
UndefinedRule
(
uint64
address
int
reg
)
{
reporter_
-
>
UndefinedNotSupported
(
entry_offset_
RegisterName
(
reg
)
)
;
return
true
;
}
bool
DwarfCFIToModule
:
:
SameValueRule
(
uint64
address
int
reg
)
{
if
(
DEBUG_DWARF
)
{
char
buf
[
100
]
;
SprintfLiteral
(
buf
"
LUL
.
DW
0x
%
llx
:
old
r
%
d
=
Same
\
n
"
address
reg
)
;
summ_
-
>
Log
(
buf
)
;
}
summ_
-
>
Rule
(
address
reg
NODEREF
reg
0
)
;
return
true
;
}
bool
DwarfCFIToModule
:
:
OffsetRule
(
uint64
address
int
reg
int
base_register
long
offset
)
{
if
(
DEBUG_DWARF
)
{
char
buf
[
100
]
;
SprintfLiteral
(
buf
"
LUL
.
DW
0x
%
llx
:
old
r
%
d
=
*
(
r
%
d
+
%
ld
)
\
n
"
address
reg
base_register
offset
)
;
summ_
-
>
Log
(
buf
)
;
}
summ_
-
>
Rule
(
address
reg
DEREF
base_register
offset
)
;
return
true
;
}
bool
DwarfCFIToModule
:
:
ValOffsetRule
(
uint64
address
int
reg
int
base_register
long
offset
)
{
if
(
DEBUG_DWARF
)
{
char
buf
[
100
]
;
SprintfLiteral
(
buf
"
LUL
.
DW
0x
%
llx
:
old
r
%
d
=
r
%
d
+
%
ld
\
n
"
address
reg
base_register
offset
)
;
summ_
-
>
Log
(
buf
)
;
}
summ_
-
>
Rule
(
address
reg
NODEREF
base_register
offset
)
;
return
true
;
}
bool
DwarfCFIToModule
:
:
RegisterRule
(
uint64
address
int
reg
int
base_register
)
{
if
(
DEBUG_DWARF
)
{
char
buf
[
100
]
;
SprintfLiteral
(
buf
"
LUL
.
DW
0x
%
llx
:
old
r
%
d
=
r
%
d
\
n
"
address
reg
base_register
)
;
summ_
-
>
Log
(
buf
)
;
}
summ_
-
>
Rule
(
address
reg
NODEREF
base_register
0
)
;
return
true
;
}
bool
DwarfCFIToModule
:
:
ExpressionRule
(
uint64
address
int
reg
const
ImageSlice
&
expression
)
{
bool
debug
=
!
!
DEBUG_DWARF
;
int32_t
start_ix
=
parseDwarfExpr
(
summ_
reader_
expression
debug
true
true
)
;
if
(
start_ix
>
=
0
)
{
summ_
-
>
Rule
(
address
reg
PFXEXPR
0
start_ix
)
;
}
else
{
reporter_
-
>
ExpressionCouldNotBeSummarised
(
entry_offset_
RegisterName
(
reg
)
)
;
}
return
true
;
}
bool
DwarfCFIToModule
:
:
ValExpressionRule
(
uint64
address
int
reg
const
ImageSlice
&
expression
)
{
bool
debug
=
!
!
DEBUG_DWARF
;
int32_t
start_ix
=
parseDwarfExpr
(
summ_
reader_
expression
debug
true
false
)
;
if
(
start_ix
>
=
0
)
{
summ_
-
>
Rule
(
address
reg
PFXEXPR
0
start_ix
)
;
}
else
{
reporter_
-
>
ExpressionCouldNotBeSummarised
(
entry_offset_
RegisterName
(
reg
)
)
;
}
return
true
;
}
bool
DwarfCFIToModule
:
:
End
(
)
{
if
(
DEBUG_DWARF
)
{
summ_
-
>
Log
(
"
LUL
.
DW
DwarfCFIToModule
:
:
End
(
)
\
n
"
)
;
}
summ_
-
>
End
(
)
;
return
true
;
}
void
DwarfCFIToModule
:
:
Reporter
:
:
UndefinedNotSupported
(
size_t
offset
const
UniqueString
*
reg
)
{
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
DwarfCFIToModule
:
:
Reporter
:
:
UndefinedNotSupported
(
)
\
n
"
)
;
log_
(
buf
)
;
}
static
bool
is_power_of_2
(
uint64_t
n
)
{
int
i
nSetBits
=
0
;
for
(
i
=
0
;
i
<
8
*
(
int
)
sizeof
(
n
)
;
i
+
+
)
{
if
(
(
n
&
(
(
uint64_t
)
1
)
<
<
i
)
!
=
0
)
nSetBits
+
+
;
}
return
nSetBits
<
=
1
;
}
void
DwarfCFIToModule
:
:
Reporter
:
:
ExpressionCouldNotBeSummarised
(
size_t
offset
const
UniqueString
*
reg
)
{
static
uint64_t
n_complaints
=
0
;
n_complaints
+
+
;
if
(
!
is_power_of_2
(
n_complaints
)
)
return
;
char
buf
[
300
]
;
SprintfLiteral
(
buf
"
DwarfCFIToModule
:
:
Reporter
:
:
"
"
ExpressionCouldNotBeSummarised
(
shown
%
llu
times
)
\
n
"
(
unsigned
long
long
int
)
n_complaints
)
;
log_
(
buf
)
;
}
}
