#
include
"
ProfileGatherer
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsIObserverService
.
h
"
namespace
mozilla
{
static
const
uint32_t
MAX_SUBPROCESS_EXIT_PROFILES
=
5
;
NS_IMPL_ISUPPORTS0
(
ProfileGatherer
)
ProfileGatherer
:
:
ProfileGatherer
(
)
:
mPendingProfiles
(
0
)
mGathering
(
false
)
{
}
ProfileGatherer
:
:
~
ProfileGatherer
(
)
{
Cancel
(
)
;
}
void
ProfileGatherer
:
:
GatheredOOPProfile
(
const
nsACString
&
aProfile
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mGathering
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
mWriter
.
isSome
(
)
"
Should
always
have
a
writer
if
mGathering
is
true
"
)
;
if
(
!
aProfile
.
IsEmpty
(
)
)
{
mWriter
-
>
Splice
(
PromiseFlatCString
(
aProfile
)
.
get
(
)
)
;
}
mPendingProfiles
-
-
;
if
(
mPendingProfiles
=
=
0
)
{
Finish
(
)
;
}
}
RefPtr
<
ProfileGatherer
:
:
ProfileGatherPromise
>
ProfileGatherer
:
:
Start
(
double
aSinceTime
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mGathering
)
{
return
ProfileGatherPromise
:
:
CreateAndReject
(
NS_ERROR_NOT_AVAILABLE
__func__
)
;
}
mGathering
=
true
;
nsTArray
<
RefPtr
<
ProfilerParent
:
:
SingleProcessProfilePromise
>
>
profiles
=
ProfilerParent
:
:
GatherProfiles
(
)
;
mWriter
.
emplace
(
)
;
mWriter
-
>
Start
(
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
if
(
!
profiler_stream_json_for_this_process
(
*
mWriter
aSinceTime
)
)
{
return
ProfileGatherPromise
:
:
CreateAndReject
(
NS_ERROR_NOT_AVAILABLE
__func__
)
;
}
mWriter
-
>
StartArrayProperty
(
"
processes
"
)
;
for
(
size_t
i
=
0
;
i
<
mExitProfiles
.
Length
(
)
;
+
+
i
)
{
if
(
!
mExitProfiles
[
i
]
.
IsEmpty
(
)
)
{
mWriter
-
>
Splice
(
mExitProfiles
[
i
]
.
get
(
)
)
;
}
}
mExitProfiles
.
Clear
(
)
;
mPromiseHolder
.
emplace
(
)
;
RefPtr
<
ProfileGatherPromise
>
promise
=
mPromiseHolder
-
>
Ensure
(
__func__
)
;
mPendingProfiles
=
profiles
.
Length
(
)
;
RefPtr
<
ProfileGatherer
>
self
=
this
;
for
(
auto
profile
:
profiles
)
{
profile
-
>
Then
(
AbstractThread
:
:
MainThread
(
)
__func__
[
self
]
(
const
nsCString
&
aResult
)
{
self
-
>
GatheredOOPProfile
(
aResult
)
;
}
[
self
]
(
PromiseRejectReason
aReason
)
{
self
-
>
GatheredOOPProfile
(
NS_LITERAL_CSTRING
(
"
"
)
)
;
}
)
;
}
if
(
!
mPendingProfiles
)
{
Finish
(
)
;
}
return
promise
;
}
void
ProfileGatherer
:
:
Finish
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
mWriter
.
isSome
(
)
)
;
MOZ_RELEASE_ASSERT
(
mPromiseHolder
.
isSome
(
)
)
;
mWriter
-
>
EndArray
(
)
;
mWriter
-
>
End
(
)
;
UniquePtr
<
char
[
]
>
buf
=
mWriter
-
>
WriteFunc
(
)
-
>
CopyData
(
)
;
nsCString
result
(
buf
.
get
(
)
)
;
mPromiseHolder
-
>
Resolve
(
result
__func__
)
;
Reset
(
)
;
}
void
ProfileGatherer
:
:
Reset
(
)
{
mPromiseHolder
.
reset
(
)
;
mPendingProfiles
=
0
;
mGathering
=
false
;
mWriter
.
reset
(
)
;
}
void
ProfileGatherer
:
:
Cancel
(
)
{
if
(
mPromiseHolder
.
isSome
(
)
)
{
mPromiseHolder
-
>
RejectIfExists
(
NS_ERROR_DOM_ABORT_ERR
__func__
)
;
}
Reset
(
)
;
}
void
ProfileGatherer
:
:
OOPExitProfile
(
const
nsACString
&
aProfile
)
{
if
(
mExitProfiles
.
Length
(
)
>
=
MAX_SUBPROCESS_EXIT_PROFILES
)
{
mExitProfiles
.
RemoveElementAt
(
0
)
;
}
mExitProfiles
.
AppendElement
(
aProfile
)
;
}
}
