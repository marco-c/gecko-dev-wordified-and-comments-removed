#
include
"
ProfilerChild
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
platform
.
h
"
#
include
"
ProfilerCodeAddressService
.
h
"
#
include
"
ProfilerControl
.
h
"
#
include
"
ProfilerParent
.
h
"
#
include
"
chrome
/
common
/
ipc_channel
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
<
memory
>
namespace
mozilla
{
DataMutexBase
<
ProfilerChild
:
:
ProfilerChildAndUpdate
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
>
ProfilerChild
:
:
sPendingChunkManagerUpdate
{
"
ProfilerChild
:
:
sPendingChunkManagerUpdate
"
}
;
ProfilerChild
:
:
ProfilerChild
(
)
:
mThread
(
NS_GetCurrentThread
(
)
)
mDestroyed
(
false
)
{
MOZ_COUNT_CTOR
(
ProfilerChild
)
;
}
ProfilerChild
:
:
~
ProfilerChild
(
)
{
MOZ_COUNT_DTOR
(
ProfilerChild
)
;
}
void
ProfilerChild
:
:
ResolveChunkUpdate
(
PProfilerChild
:
:
AwaitNextChunkManagerUpdateResolver
&
aResolve
)
{
MOZ_ASSERT
(
!
!
aResolve
"
ResolveChunkUpdate
should
only
be
called
when
there
'
s
a
pending
"
"
resolver
"
)
;
MOZ_ASSERT
(
!
mChunkManagerUpdate
.
IsNotUpdate
(
)
"
ResolveChunkUpdate
should
only
be
called
with
a
real
or
final
update
"
)
;
MOZ_ASSERT
(
!
mDestroyed
"
ResolveChunkUpdate
should
not
be
called
if
the
actor
was
destroyed
"
)
;
if
(
mChunkManagerUpdate
.
IsFinal
(
)
)
{
std
:
:
move
(
aResolve
)
(
ProfilerParent
:
:
MakeFinalUpdate
(
)
)
;
}
else
{
ProfileBufferChunkManagerUpdate
update
{
mChunkManagerUpdate
.
UnreleasedBytes
(
)
mChunkManagerUpdate
.
ReleasedBytes
(
)
mChunkManagerUpdate
.
OldestDoneTimeStamp
(
)
{
}
}
;
update
.
newlyReleasedChunks
(
)
.
SetCapacity
(
mChunkManagerUpdate
.
NewlyReleasedChunksRef
(
)
.
size
(
)
)
;
for
(
const
ProfileBufferControlledChunkManager
:
:
ChunkMetadata
&
chunk
:
mChunkManagerUpdate
.
NewlyReleasedChunksRef
(
)
)
{
update
.
newlyReleasedChunks
(
)
.
EmplaceBack
(
chunk
.
mDoneTimeStamp
chunk
.
mBufferBytes
)
;
}
std
:
:
move
(
aResolve
)
(
update
)
;
mChunkManagerUpdate
.
Clear
(
)
;
}
aResolve
=
nullptr
;
}
void
ProfilerChild
:
:
ProcessChunkManagerUpdate
(
ProfileBufferControlledChunkManager
:
:
Update
&
&
aUpdate
)
{
if
(
mDestroyed
)
{
return
;
}
mChunkManagerUpdate
.
Fold
(
std
:
:
move
(
aUpdate
)
)
;
if
(
mAwaitNextChunkManagerUpdateResolver
)
{
ResolveChunkUpdate
(
mAwaitNextChunkManagerUpdateResolver
)
;
}
}
void
ProfilerChild
:
:
ProcessPendingUpdate
(
)
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
if
(
!
lockedUpdate
-
>
mProfilerChild
|
|
lockedUpdate
-
>
mUpdate
.
IsNotUpdate
(
)
)
{
return
;
}
lockedUpdate
-
>
mProfilerChild
-
>
mThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
ProfilerChild
:
:
ProcessPendingUpdate
"
[
]
(
)
mutable
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
if
(
!
lockedUpdate
-
>
mProfilerChild
|
|
lockedUpdate
-
>
mUpdate
.
IsNotUpdate
(
)
)
{
return
;
}
lockedUpdate
-
>
mProfilerChild
-
>
ProcessChunkManagerUpdate
(
std
:
:
move
(
lockedUpdate
-
>
mUpdate
)
)
;
lockedUpdate
-
>
mUpdate
.
Clear
(
)
;
}
)
)
;
}
bool
ProfilerChild
:
:
IsLockedOnCurrentThread
(
)
{
return
sPendingChunkManagerUpdate
.
Mutex
(
)
.
IsLockedOnCurrentThread
(
)
;
}
void
ProfilerChild
:
:
SetupChunkManager
(
)
{
mChunkManager
=
profiler_get_controlled_chunk_manager
(
)
;
if
(
NS_WARN_IF
(
!
mChunkManager
)
)
{
return
;
}
mChunkManagerUpdate
.
Clear
(
)
;
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
lockedUpdate
-
>
mProfilerChild
=
this
;
lockedUpdate
-
>
mUpdate
.
Clear
(
)
;
}
mChunkManager
-
>
SetUpdateCallback
(
[
]
(
ProfileBufferControlledChunkManager
:
:
Update
&
&
aUpdate
)
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
if
(
!
lockedUpdate
-
>
mProfilerChild
)
{
return
;
}
lockedUpdate
-
>
mUpdate
.
Fold
(
std
:
:
move
(
aUpdate
)
)
;
}
)
;
}
void
ProfilerChild
:
:
ResetChunkManager
(
)
{
if
(
!
mChunkManager
)
{
return
;
}
mChunkManager
-
>
SetUpdateCallback
(
{
}
)
;
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
lockedUpdate
-
>
mProfilerChild
=
nullptr
;
lockedUpdate
-
>
mUpdate
.
Clear
(
)
;
ProcessChunkManagerUpdate
(
ProfileBufferControlledChunkManager
:
:
Update
(
nullptr
)
)
;
mChunkManager
=
nullptr
;
mAwaitNextChunkManagerUpdateResolver
=
nullptr
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvStart
(
const
ProfilerInitParams
&
params
StartResolver
&
&
aResolve
)
{
nsTArray
<
const
char
*
>
filterArray
;
for
(
size_t
i
=
0
;
i
<
params
.
filters
(
)
.
Length
(
)
;
+
+
i
)
{
filterArray
.
AppendElement
(
params
.
filters
(
)
[
i
]
.
get
(
)
)
;
}
profiler_start
(
PowerOfTwo32
(
params
.
entries
(
)
)
params
.
interval
(
)
params
.
features
(
)
filterArray
.
Elements
(
)
filterArray
.
Length
(
)
params
.
activeTabID
(
)
params
.
duration
(
)
)
;
SetupChunkManager
(
)
;
aResolve
(
true
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvEnsureStarted
(
const
ProfilerInitParams
&
params
EnsureStartedResolver
&
&
aResolve
)
{
nsTArray
<
const
char
*
>
filterArray
;
for
(
size_t
i
=
0
;
i
<
params
.
filters
(
)
.
Length
(
)
;
+
+
i
)
{
filterArray
.
AppendElement
(
params
.
filters
(
)
[
i
]
.
get
(
)
)
;
}
profiler_ensure_started
(
PowerOfTwo32
(
params
.
entries
(
)
)
params
.
interval
(
)
params
.
features
(
)
filterArray
.
Elements
(
)
filterArray
.
Length
(
)
params
.
activeTabID
(
)
params
.
duration
(
)
)
;
SetupChunkManager
(
)
;
aResolve
(
true
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvStop
(
StopResolver
&
&
aResolve
)
{
ResetChunkManager
(
)
;
profiler_stop
(
)
;
aResolve
(
true
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvPause
(
PauseResolver
&
&
aResolve
)
{
profiler_pause
(
)
;
aResolve
(
true
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvResume
(
ResumeResolver
&
&
aResolve
)
{
profiler_resume
(
)
;
aResolve
(
true
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvPauseSampling
(
PauseSamplingResolver
&
&
aResolve
)
{
profiler_pause_sampling
(
)
;
aResolve
(
true
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvResumeSampling
(
ResumeSamplingResolver
&
&
aResolve
)
{
profiler_resume_sampling
(
)
;
aResolve
(
true
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvWaitOnePeriodicSampling
(
WaitOnePeriodicSamplingResolver
&
&
aResolve
)
{
std
:
:
shared_ptr
<
WaitOnePeriodicSamplingResolver
>
resolve
=
std
:
:
make_shared
<
WaitOnePeriodicSamplingResolver
>
(
std
:
:
move
(
aResolve
)
)
;
if
(
!
profiler_callback_after_sampling
(
[
self
=
RefPtr
(
this
)
resolve
]
(
SamplingState
aSamplingState
)
mutable
{
if
(
self
-
>
mDestroyed
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
self
-
>
mThread
)
;
self
-
>
mThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
nsProfiler
:
:
WaitOnePeriodicSampling
result
on
main
thread
"
[
resolve
=
std
:
:
move
(
resolve
)
aSamplingState
]
(
)
{
(
*
resolve
)
(
aSamplingState
=
=
SamplingState
:
:
SamplingCompleted
|
|
aSamplingState
=
=
SamplingState
:
:
NoStackSamplingCompleted
)
;
}
)
)
;
}
)
)
{
(
*
resolve
)
(
false
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvClearAllPages
(
)
{
profiler_clear_all_pages
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvAwaitNextChunkManagerUpdate
(
AwaitNextChunkManagerUpdateResolver
&
&
aResolve
)
{
MOZ_ASSERT
(
!
mDestroyed
"
Recv
.
.
.
should
not
be
called
if
the
actor
was
destroyed
"
)
;
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
if
(
lockedUpdate
-
>
mProfilerChild
&
&
!
lockedUpdate
-
>
mUpdate
.
IsNotUpdate
(
)
)
{
mChunkManagerUpdate
.
Fold
(
std
:
:
move
(
lockedUpdate
-
>
mUpdate
)
)
;
lockedUpdate
-
>
mUpdate
.
Clear
(
)
;
}
}
if
(
mChunkManagerUpdate
.
IsNotUpdate
(
)
)
{
mAwaitNextChunkManagerUpdateResolver
=
std
:
:
move
(
aResolve
)
;
}
else
{
ResolveChunkUpdate
(
aResolve
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvDestroyReleasedChunksAtOrBefore
(
const
TimeStamp
&
aTimeStamp
)
{
if
(
mChunkManager
)
{
mChunkManager
-
>
DestroyChunksAtOrBefore
(
aTimeStamp
)
;
}
return
IPC_OK
(
)
;
}
struct
GatherProfileThreadParameters
:
public
external
:
:
AtomicRefCounted
<
GatherProfileThreadParameters
>
{
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
GatherProfileThreadParameters
)
GatherProfileThreadParameters
(
RefPtr
<
ProfilerChild
>
aProfilerChild
RefPtr
<
ProgressLogger
:
:
SharedProgress
>
aProgress
ProfilerChild
:
:
GatherProfileResolver
&
&
aResolver
)
:
profilerChild
(
std
:
:
move
(
aProfilerChild
)
)
progress
(
std
:
:
move
(
aProgress
)
)
resolver
(
std
:
:
move
(
aResolver
)
)
{
}
RefPtr
<
ProfilerChild
>
profilerChild
;
RefPtr
<
ProgressLogger
:
:
SharedProgress
>
progress
;
ProfilerChild
:
:
GatherProfileResolver
resolver
;
}
;
void
ProfilerChild
:
:
GatherProfileThreadFunction
(
void
*
already_AddRefedParameters
)
{
PR_SetCurrentThreadName
(
"
GatherProfileThread
"
)
;
RefPtr
<
GatherProfileThreadParameters
>
parameters
=
already_AddRefed
<
GatherProfileThreadParameters
>
{
static_cast
<
GatherProfileThreadParameters
*
>
(
already_AddRefedParameters
)
}
;
ProgressLogger
progressLogger
(
parameters
-
>
progress
"
Gather
-
profile
thread
started
"
"
Profile
sent
"
)
;
using
namespace
mozilla
:
:
literals
:
:
ProportionValue_literals
;
auto
writer
=
MakeUnique
<
SpliceableChunkedJSONWriter
>
(
)
;
if
(
!
profiler_get_profile_json
(
*
writer
0
false
progressLogger
.
CreateSubLoggerFromTo
(
1_pc
"
profiler_get_profile_json_into_lazily_allocated_buffer
started
"
99_pc
"
profiler_get_profile_json_into_lazily_allocated_buffer
done
"
)
)
)
{
writer
.
reset
(
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
parameters
-
>
profilerChild
-
>
mThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
ProfilerChild
:
:
ProcessPendingUpdate
"
[
parameters
progressLogger
=
std
:
:
move
(
progressLogger
)
writer
=
std
:
:
move
(
writer
)
]
(
)
mutable
{
if
(
parameters
-
>
profilerChild
-
>
mGatherProfileProgress
=
=
parameters
-
>
progress
)
{
parameters
-
>
profilerChild
-
>
mGatherProfileProgress
=
nullptr
;
}
mozilla
:
:
ipc
:
:
Shmem
shmem
;
if
(
writer
)
{
if
(
const
size_t
len
=
writer
-
>
ChunkedWriteFunc
(
)
.
Length
(
)
;
len
<
UINT32_MAX
)
{
bool
success
=
false
;
writer
-
>
ChunkedWriteFunc
(
)
.
CopyDataIntoLazilyAllocatedBuffer
(
[
&
]
(
size_t
allocationSize
)
-
>
char
*
{
MOZ_ASSERT
(
allocationSize
=
=
len
+
1
)
;
if
(
parameters
-
>
profilerChild
-
>
AllocShmem
(
allocationSize
&
shmem
)
)
{
success
=
true
;
return
shmem
.
get
<
char
>
(
)
;
}
return
nullptr
;
}
)
;
if
(
!
success
)
{
const
nsPrintfCString
message
(
"
*
Could
not
create
shmem
for
profile
from
pid
%
u
"
"
(
%
zu
B
)
"
unsigned
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
len
)
;
if
(
parameters
-
>
profilerChild
-
>
AllocShmem
(
message
.
Length
(
)
+
1
&
shmem
)
)
{
strcpy
(
shmem
.
get
<
char
>
(
)
message
.
Data
(
)
)
;
}
}
}
else
{
const
nsPrintfCString
message
(
"
*
Profile
from
pid
%
u
bigger
(
%
zu
)
than
shmem
max
"
"
(
%
zu
)
"
unsigned
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
len
size_t
(
UINT32_MAX
)
)
;
if
(
parameters
-
>
profilerChild
-
>
AllocShmem
(
message
.
Length
(
)
+
1
&
shmem
)
)
{
strcpy
(
shmem
.
get
<
char
>
(
)
message
.
Data
(
)
)
;
}
}
writer
=
nullptr
;
}
else
{
if
(
parameters
-
>
profilerChild
-
>
AllocShmem
(
1
&
shmem
)
)
{
shmem
.
get
<
char
>
(
)
[
0
]
=
'
\
0
'
;
}
}
parameters
-
>
resolver
(
std
:
:
move
(
shmem
)
)
;
}
)
)
)
)
)
{
}
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvGatherProfile
(
GatherProfileResolver
&
&
aResolve
)
{
mGatherProfileProgress
=
MakeRefPtr
<
ProgressLogger
:
:
SharedProgress
>
(
)
;
mGatherProfileProgress
-
>
SetProgress
(
ProportionValue
{
0
.
0
}
"
Received
gather
-
profile
request
"
)
;
auto
parameters
=
MakeRefPtr
<
GatherProfileThreadParameters
>
(
this
mGatherProfileProgress
std
:
:
move
(
aResolve
)
)
;
parameters
.
get
(
)
-
>
AddRef
(
)
;
PRThread
*
gatherProfileThread
=
PR_CreateThread
(
PR_SYSTEM_THREAD
GatherProfileThreadFunction
parameters
.
get
(
)
PR_PRIORITY_NORMAL
PR_GLOBAL_THREAD
PR_UNJOINABLE_THREAD
0
)
;
if
(
!
gatherProfileThread
)
{
mozilla
:
:
ipc
:
:
Shmem
shmem
;
if
(
AllocShmem
(
1
&
shmem
)
)
{
shmem
.
get
<
char
>
(
)
[
0
]
=
'
\
0
'
;
}
parameters
-
>
resolver
(
std
:
:
move
(
shmem
)
)
;
parameters
.
get
(
)
-
>
Release
(
)
;
mGatherProfileProgress
=
nullptr
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvGetGatherProfileProgress
(
GetGatherProfileProgressResolver
&
&
aResolve
)
{
if
(
mGatherProfileProgress
)
{
aResolve
(
GatherProfileProgress
{
mGatherProfileProgress
-
>
Progress
(
)
.
ToUnderlyingType
(
)
nsCString
(
mGatherProfileProgress
-
>
LastLocation
(
)
)
}
)
;
}
else
{
aResolve
(
GatherProfileProgress
{
ProportionValue
:
:
MakeInvalid
(
)
.
ToUnderlyingType
(
)
nsCString
(
"
No
gather
-
profile
in
progress
"
)
}
)
;
}
return
IPC_OK
(
)
;
}
void
ProfilerChild
:
:
ActorDestroy
(
ActorDestroyReason
aActorDestroyReason
)
{
mDestroyed
=
true
;
}
void
ProfilerChild
:
:
Destroy
(
)
{
ResetChunkManager
(
)
;
if
(
!
mDestroyed
)
{
Close
(
)
;
}
}
nsCString
ProfilerChild
:
:
GrabShutdownProfile
(
)
{
LOG
(
"
GrabShutdownProfile
"
)
;
UniquePtr
<
ProfilerCodeAddressService
>
service
=
profiler_code_address_service_for_presymbolication
(
)
;
SpliceableChunkedJSONWriter
writer
;
writer
.
Start
(
)
;
if
(
!
profiler_stream_json_for_this_process
(
writer
0
true
service
.
get
(
)
ProgressLogger
{
}
)
)
{
return
nsPrintfCString
(
"
*
Profile
unavailable
for
pid
%
u
"
unsigned
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
)
;
}
writer
.
StartArrayProperty
(
"
processes
"
)
;
writer
.
EndArray
(
)
;
writer
.
End
(
)
;
const
size_t
len
=
writer
.
ChunkedWriteFunc
(
)
.
Length
(
)
;
if
(
len
>
=
size_t
(
IPC
:
:
Channel
:
:
kMaximumMessageSize
)
)
{
return
nsPrintfCString
(
"
*
Profile
from
pid
%
u
bigger
(
%
zu
)
than
IPC
max
(
%
zu
)
"
unsigned
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
len
size_t
(
IPC
:
:
Channel
:
:
kMaximumMessageSize
)
)
;
}
nsCString
profileCString
;
if
(
!
profileCString
.
SetLength
(
len
fallible
)
)
{
return
nsPrintfCString
(
"
*
Could
not
allocate
%
zu
bytes
for
profile
from
pid
%
u
"
len
unsigned
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
)
;
}
MOZ_ASSERT
(
*
(
profileCString
.
Data
(
)
+
len
)
=
=
'
\
0
'
"
We
expected
a
null
at
the
end
of
the
string
buffer
to
be
"
"
rewritten
by
CopyDataIntoLazilyAllocatedBuffer
"
)
;
char
*
const
profileBeginWriting
=
profileCString
.
BeginWriting
(
)
;
if
(
!
profileBeginWriting
)
{
return
nsPrintfCString
(
"
*
Could
not
write
profile
from
pid
%
u
"
unsigned
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
)
;
}
writer
.
ChunkedWriteFunc
(
)
.
CopyDataIntoLazilyAllocatedBuffer
(
[
&
]
(
size_t
aBufferLen
)
-
>
char
*
{
MOZ_RELEASE_ASSERT
(
aBufferLen
=
=
len
+
1
)
;
return
profileBeginWriting
;
}
)
;
MOZ_ASSERT
(
*
(
profileCString
.
Data
(
)
+
len
)
=
=
'
\
0
'
"
We
still
expected
a
null
at
the
end
of
the
string
buffer
"
)
;
return
profileCString
;
}
}
