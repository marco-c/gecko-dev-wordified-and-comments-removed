#
include
"
ProfilerChild
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
platform
.
h
"
#
include
"
ProfilerParent
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
DataMutexBase
<
ProfilerChild
:
:
ProfilerChildAndUpdate
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
>
ProfilerChild
:
:
sPendingChunkManagerUpdate
{
"
ProfilerChild
:
:
sPendingChunkManagerUpdate
"
}
;
ProfilerChild
:
:
ProfilerChild
(
)
:
mThread
(
NS_GetCurrentThread
(
)
)
mDestroyed
(
false
)
{
MOZ_COUNT_CTOR
(
ProfilerChild
)
;
}
ProfilerChild
:
:
~
ProfilerChild
(
)
{
MOZ_COUNT_DTOR
(
ProfilerChild
)
;
}
void
ProfilerChild
:
:
ResolveChunkUpdate
(
PProfilerChild
:
:
AwaitNextChunkManagerUpdateResolver
&
aResolve
)
{
MOZ_ASSERT
(
!
!
aResolve
"
ResolveChunkUpdate
should
only
be
called
when
there
'
s
a
pending
"
"
resolver
"
)
;
MOZ_ASSERT
(
!
mChunkManagerUpdate
.
IsNotUpdate
(
)
"
ResolveChunkUpdate
should
only
be
called
with
a
real
or
final
update
"
)
;
MOZ_ASSERT
(
!
mDestroyed
"
ResolveChunkUpdate
should
not
be
called
if
the
actor
was
destroyed
"
)
;
if
(
mChunkManagerUpdate
.
IsFinal
(
)
)
{
std
:
:
move
(
aResolve
)
(
ProfilerParent
:
:
MakeFinalUpdate
(
)
)
;
}
else
{
ProfileBufferChunkManagerUpdate
update
{
mChunkManagerUpdate
.
UnreleasedBytes
(
)
mChunkManagerUpdate
.
ReleasedBytes
(
)
mChunkManagerUpdate
.
OldestDoneTimeStamp
(
)
{
}
}
;
update
.
newlyReleasedChunks
(
)
.
SetCapacity
(
mChunkManagerUpdate
.
NewlyReleasedChunksRef
(
)
.
size
(
)
)
;
for
(
const
ProfileBufferControlledChunkManager
:
:
ChunkMetadata
&
chunk
:
mChunkManagerUpdate
.
NewlyReleasedChunksRef
(
)
)
{
update
.
newlyReleasedChunks
(
)
.
EmplaceBack
(
chunk
.
mDoneTimeStamp
chunk
.
mBufferBytes
)
;
}
std
:
:
move
(
aResolve
)
(
update
)
;
mChunkManagerUpdate
.
Clear
(
)
;
}
aResolve
=
nullptr
;
}
void
ProfilerChild
:
:
ProcessChunkManagerUpdate
(
ProfileBufferControlledChunkManager
:
:
Update
&
&
aUpdate
)
{
if
(
mDestroyed
)
{
return
;
}
mChunkManagerUpdate
.
Fold
(
std
:
:
move
(
aUpdate
)
)
;
if
(
mAwaitNextChunkManagerUpdateResolver
)
{
ResolveChunkUpdate
(
mAwaitNextChunkManagerUpdateResolver
)
;
}
}
void
ProfilerChild
:
:
ProcessPendingUpdate
(
)
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
if
(
!
lockedUpdate
-
>
mProfilerChild
|
|
lockedUpdate
-
>
mUpdate
.
IsNotUpdate
(
)
)
{
return
;
}
lockedUpdate
-
>
mProfilerChild
-
>
mThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
ProfilerChild
:
:
ProcessPendingUpdate
"
[
]
(
)
mutable
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
if
(
!
lockedUpdate
-
>
mProfilerChild
|
|
lockedUpdate
-
>
mUpdate
.
IsNotUpdate
(
)
)
{
return
;
}
lockedUpdate
-
>
mProfilerChild
-
>
ProcessChunkManagerUpdate
(
std
:
:
move
(
lockedUpdate
-
>
mUpdate
)
)
;
lockedUpdate
-
>
mUpdate
.
Clear
(
)
;
}
)
)
;
}
bool
ProfilerChild
:
:
IsLockedOnCurrentThread
(
)
{
return
sPendingChunkManagerUpdate
.
Mutex
(
)
.
IsLockedOnCurrentThread
(
)
;
}
void
ProfilerChild
:
:
SetupChunkManager
(
)
{
mChunkManager
=
profiler_get_controlled_chunk_manager
(
)
;
if
(
NS_WARN_IF
(
!
mChunkManager
)
)
{
return
;
}
mChunkManagerUpdate
.
Clear
(
)
;
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
lockedUpdate
-
>
mProfilerChild
=
this
;
lockedUpdate
-
>
mUpdate
.
Clear
(
)
;
}
mChunkManager
-
>
SetUpdateCallback
(
[
]
(
ProfileBufferControlledChunkManager
:
:
Update
&
&
aUpdate
)
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
if
(
!
lockedUpdate
-
>
mProfilerChild
)
{
return
;
}
lockedUpdate
-
>
mUpdate
.
Fold
(
std
:
:
move
(
aUpdate
)
)
;
}
)
;
}
void
ProfilerChild
:
:
ResetChunkManager
(
)
{
if
(
!
mChunkManager
)
{
return
;
}
mChunkManager
-
>
SetUpdateCallback
(
{
}
)
;
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
lockedUpdate
-
>
mProfilerChild
=
nullptr
;
lockedUpdate
-
>
mUpdate
.
Clear
(
)
;
ProcessChunkManagerUpdate
(
ProfileBufferControlledChunkManager
:
:
Update
(
nullptr
)
)
;
mChunkManager
=
nullptr
;
mAwaitNextChunkManagerUpdateResolver
=
nullptr
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvStart
(
const
ProfilerInitParams
&
params
)
{
nsTArray
<
const
char
*
>
filterArray
;
for
(
size_t
i
=
0
;
i
<
params
.
filters
(
)
.
Length
(
)
;
+
+
i
)
{
filterArray
.
AppendElement
(
params
.
filters
(
)
[
i
]
.
get
(
)
)
;
}
profiler_start
(
PowerOfTwo32
(
params
.
entries
(
)
)
params
.
interval
(
)
params
.
features
(
)
filterArray
.
Elements
(
)
filterArray
.
Length
(
)
params
.
activeTabID
(
)
params
.
duration
(
)
)
;
SetupChunkManager
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvEnsureStarted
(
const
ProfilerInitParams
&
params
)
{
nsTArray
<
const
char
*
>
filterArray
;
for
(
size_t
i
=
0
;
i
<
params
.
filters
(
)
.
Length
(
)
;
+
+
i
)
{
filterArray
.
AppendElement
(
params
.
filters
(
)
[
i
]
.
get
(
)
)
;
}
profiler_ensure_started
(
PowerOfTwo32
(
params
.
entries
(
)
)
params
.
interval
(
)
params
.
features
(
)
filterArray
.
Elements
(
)
filterArray
.
Length
(
)
params
.
activeTabID
(
)
params
.
duration
(
)
)
;
SetupChunkManager
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvStop
(
)
{
ResetChunkManager
(
)
;
profiler_stop
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvPause
(
)
{
profiler_pause
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvResume
(
)
{
profiler_resume
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvPauseSampling
(
)
{
profiler_pause_sampling
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvResumeSampling
(
)
{
profiler_resume_sampling
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvClearAllPages
(
)
{
profiler_clear_all_pages
(
)
;
return
IPC_OK
(
)
;
}
static
nsCString
CollectProfileOrEmptyString
(
bool
aIsShuttingDown
)
{
nsCString
profileCString
;
UniquePtr
<
char
[
]
>
profile
=
profiler_get_profile
(
0
aIsShuttingDown
)
;
if
(
profile
)
{
size_t
len
=
strlen
(
profile
.
get
(
)
)
;
profileCString
.
Adopt
(
profile
.
release
(
)
len
)
;
}
return
profileCString
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvAwaitNextChunkManagerUpdate
(
AwaitNextChunkManagerUpdateResolver
&
&
aResolve
)
{
MOZ_ASSERT
(
!
mDestroyed
"
Recv
.
.
.
should
not
be
called
if
the
actor
was
destroyed
"
)
;
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
if
(
lockedUpdate
-
>
mProfilerChild
&
&
!
lockedUpdate
-
>
mUpdate
.
IsNotUpdate
(
)
)
{
mChunkManagerUpdate
.
Fold
(
std
:
:
move
(
lockedUpdate
-
>
mUpdate
)
)
;
lockedUpdate
-
>
mUpdate
.
Clear
(
)
;
}
}
if
(
mChunkManagerUpdate
.
IsNotUpdate
(
)
)
{
mAwaitNextChunkManagerUpdateResolver
=
std
:
:
move
(
aResolve
)
;
}
else
{
ResolveChunkUpdate
(
aResolve
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvDestroyReleasedChunksAtOrBefore
(
const
TimeStamp
&
aTimeStamp
)
{
if
(
mChunkManager
)
{
mChunkManager
-
>
DestroyChunksAtOrBefore
(
aTimeStamp
)
;
}
return
IPC_OK
(
)
;
}
struct
GatherProfileThreadParameters
:
public
external
:
:
AtomicRefCounted
<
GatherProfileThreadParameters
>
{
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
GatherProfileThreadParameters
)
GatherProfileThreadParameters
(
RefPtr
<
ProfilerChild
>
aProfilerChild
RefPtr
<
ProgressLogger
:
:
SharedProgress
>
aProgress
ProfilerChild
:
:
GatherProfileResolver
&
&
aResolver
)
:
profilerChild
(
std
:
:
move
(
aProfilerChild
)
)
progress
(
std
:
:
move
(
aProgress
)
)
resolver
(
std
:
:
move
(
aResolver
)
)
{
}
RefPtr
<
ProfilerChild
>
profilerChild
;
RefPtr
<
ProgressLogger
:
:
SharedProgress
>
progress
;
ProfilerChild
:
:
GatherProfileResolver
resolver
;
}
;
void
ProfilerChild
:
:
GatherProfileThreadFunction
(
void
*
already_AddRefedParameters
)
{
PR_SetCurrentThreadName
(
"
GatherProfileThread
"
)
;
RefPtr
<
GatherProfileThreadParameters
>
parameters
=
already_AddRefed
<
GatherProfileThreadParameters
>
{
static_cast
<
GatherProfileThreadParameters
*
>
(
already_AddRefedParameters
)
}
;
ProgressLogger
progressLogger
(
parameters
-
>
progress
"
Gather
-
profile
thread
started
"
"
Profile
sent
"
)
;
using
namespace
mozilla
:
:
literals
:
:
ProportionValue_literals
;
auto
writer
=
MakeUnique
<
SpliceableChunkedJSONWriter
>
(
)
;
profiler_get_profile_json
(
*
writer
0
false
progressLogger
.
CreateSubLoggerFromTo
(
1_pc
"
profiler_get_profile_json_into_lazily_allocated_buffer
started
"
99_pc
"
profiler_get_profile_json_into_lazily_allocated_buffer
done
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
parameters
-
>
profilerChild
-
>
mThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
ProfilerChild
:
:
ProcessPendingUpdate
"
[
parameters
progressLogger
=
std
:
:
move
(
progressLogger
)
writer
=
std
:
:
move
(
writer
)
]
(
)
mutable
{
if
(
parameters
-
>
profilerChild
-
>
mGatherProfileProgress
=
=
parameters
-
>
progress
)
{
parameters
-
>
profilerChild
-
>
mGatherProfileProgress
=
nullptr
;
}
mozilla
:
:
ipc
:
:
Shmem
shmem
;
writer
-
>
ChunkedWriteFunc
(
)
.
CopyDataIntoLazilyAllocatedBuffer
(
[
&
]
(
size_t
allocationSize
)
-
>
char
*
{
if
(
parameters
-
>
profilerChild
-
>
AllocShmem
(
allocationSize
mozilla
:
:
ipc
:
:
Shmem
:
:
SharedMemory
:
:
TYPE_BASIC
&
shmem
)
)
{
return
shmem
.
get
<
char
>
(
)
;
}
return
nullptr
;
}
)
;
writer
=
nullptr
;
parameters
-
>
resolver
(
std
:
:
move
(
shmem
)
)
;
}
)
)
)
)
)
{
}
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvGatherProfile
(
GatherProfileResolver
&
&
aResolve
)
{
mGatherProfileProgress
=
MakeRefPtr
<
ProgressLogger
:
:
SharedProgress
>
(
)
;
mGatherProfileProgress
-
>
SetProgress
(
ProportionValue
{
0
.
0
}
"
Received
gather
-
profile
request
"
)
;
auto
parameters
=
MakeRefPtr
<
GatherProfileThreadParameters
>
(
this
mGatherProfileProgress
std
:
:
move
(
aResolve
)
)
;
parameters
.
get
(
)
-
>
AddRef
(
)
;
PRThread
*
gatherProfileThread
=
PR_CreateThread
(
PR_SYSTEM_THREAD
GatherProfileThreadFunction
parameters
.
get
(
)
PR_PRIORITY_NORMAL
PR_GLOBAL_THREAD
PR_UNJOINABLE_THREAD
0
)
;
if
(
!
gatherProfileThread
)
{
mozilla
:
:
ipc
:
:
Shmem
shmem
;
if
(
AllocShmem
(
1
mozilla
:
:
ipc
:
:
Shmem
:
:
SharedMemory
:
:
TYPE_BASIC
&
shmem
)
)
{
shmem
.
get
<
char
>
(
)
[
0
]
=
'
\
0
'
;
}
parameters
-
>
resolver
(
std
:
:
move
(
shmem
)
)
;
parameters
.
get
(
)
-
>
Release
(
)
;
mGatherProfileProgress
=
nullptr
;
}
return
IPC_OK
(
)
;
}
void
ProfilerChild
:
:
ActorDestroy
(
ActorDestroyReason
aActorDestroyReason
)
{
mDestroyed
=
true
;
}
void
ProfilerChild
:
:
Destroy
(
)
{
ResetChunkManager
(
)
;
if
(
!
mDestroyed
)
{
Close
(
)
;
}
}
nsCString
ProfilerChild
:
:
GrabShutdownProfile
(
)
{
return
CollectProfileOrEmptyString
(
true
)
;
}
}
