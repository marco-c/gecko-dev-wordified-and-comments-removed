#
include
"
ProfilerChild
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
platform
.
h
"
#
include
"
ProfilerParent
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
StaticDataMutex
<
ProfilerChild
:
:
ProfilerChildAndUpdate
>
ProfilerChild
:
:
sPendingChunkManagerUpdate
{
"
ProfilerChild
:
:
sPendingChunkManagerUpdate
"
}
;
ProfilerChild
:
:
ProfilerChild
(
)
:
mThread
(
NS_GetCurrentThread
(
)
)
mDestroyed
(
false
)
{
MOZ_COUNT_CTOR
(
ProfilerChild
)
;
}
ProfilerChild
:
:
~
ProfilerChild
(
)
{
MOZ_COUNT_DTOR
(
ProfilerChild
)
;
}
void
ProfilerChild
:
:
ResolveChunkUpdate
(
PProfilerChild
:
:
AwaitNextChunkManagerUpdateResolver
&
aResolve
)
{
MOZ_ASSERT
(
!
!
aResolve
"
ResolveChunkUpdate
should
only
be
called
when
there
'
s
a
pending
"
"
resolver
"
)
;
MOZ_ASSERT
(
!
mChunkManagerUpdate
.
IsNotUpdate
(
)
"
ResolveChunkUpdate
should
only
be
called
with
a
real
or
final
update
"
)
;
MOZ_ASSERT
(
!
mDestroyed
"
ResolveChunkUpdate
should
not
be
called
if
the
actor
was
destroyed
"
)
;
if
(
mChunkManagerUpdate
.
IsFinal
(
)
)
{
std
:
:
move
(
aResolve
)
(
ProfilerParent
:
:
MakeFinalUpdate
(
)
)
;
}
else
{
ProfileBufferChunkManagerUpdate
update
{
mChunkManagerUpdate
.
UnreleasedBytes
(
)
mChunkManagerUpdate
.
ReleasedBytes
(
)
mChunkManagerUpdate
.
OldestDoneTimeStamp
(
)
{
}
}
;
update
.
newlyReleasedChunks
(
)
.
SetCapacity
(
mChunkManagerUpdate
.
NewlyReleasedChunksRef
(
)
.
size
(
)
)
;
for
(
const
ProfileBufferControlledChunkManager
:
:
ChunkMetadata
&
chunk
:
mChunkManagerUpdate
.
NewlyReleasedChunksRef
(
)
)
{
update
.
newlyReleasedChunks
(
)
.
EmplaceBack
(
chunk
.
mDoneTimeStamp
chunk
.
mBufferBytes
)
;
}
std
:
:
move
(
aResolve
)
(
update
)
;
mChunkManagerUpdate
.
Clear
(
)
;
}
aResolve
=
nullptr
;
}
void
ProfilerChild
:
:
ProcessChunkManagerUpdate
(
ProfileBufferControlledChunkManager
:
:
Update
&
&
aUpdate
)
{
if
(
mDestroyed
)
{
return
;
}
mChunkManagerUpdate
.
Fold
(
std
:
:
move
(
aUpdate
)
)
;
if
(
mAwaitNextChunkManagerUpdateResolver
)
{
ResolveChunkUpdate
(
mAwaitNextChunkManagerUpdateResolver
)
;
}
}
void
ProfilerChild
:
:
ProcessPendingUpdate
(
)
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
if
(
!
lockedUpdate
-
>
mProfilerChild
|
|
lockedUpdate
-
>
mUpdate
.
IsNotUpdate
(
)
)
{
return
;
}
lockedUpdate
-
>
mProfilerChild
-
>
mThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
ProfilerChild
:
:
ProcessPendingUpdate
"
[
]
(
)
mutable
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
if
(
!
lockedUpdate
-
>
mProfilerChild
|
|
lockedUpdate
-
>
mUpdate
.
IsNotUpdate
(
)
)
{
return
;
}
lockedUpdate
-
>
mProfilerChild
-
>
ProcessChunkManagerUpdate
(
std
:
:
move
(
lockedUpdate
-
>
mUpdate
)
)
;
lockedUpdate
-
>
mUpdate
.
Clear
(
)
;
}
)
)
;
}
void
ProfilerChild
:
:
SetupChunkManager
(
)
{
mChunkManager
=
profiler_get_controlled_chunk_manager
(
)
;
if
(
NS_WARN_IF
(
!
mChunkManager
)
)
{
return
;
}
mChunkManagerUpdate
.
Clear
(
)
;
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
lockedUpdate
-
>
mProfilerChild
=
this
;
lockedUpdate
-
>
mUpdate
.
Clear
(
)
;
}
mChunkManager
-
>
SetUpdateCallback
(
[
]
(
ProfileBufferControlledChunkManager
:
:
Update
&
&
aUpdate
)
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
if
(
!
lockedUpdate
-
>
mProfilerChild
)
{
return
;
}
lockedUpdate
-
>
mUpdate
.
Fold
(
std
:
:
move
(
aUpdate
)
)
;
}
)
;
}
void
ProfilerChild
:
:
ResetChunkManager
(
)
{
if
(
!
mChunkManager
)
{
return
;
}
mChunkManager
-
>
SetUpdateCallback
(
{
}
)
;
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
lockedUpdate
-
>
mProfilerChild
=
nullptr
;
lockedUpdate
-
>
mUpdate
.
Clear
(
)
;
ProcessChunkManagerUpdate
(
ProfileBufferControlledChunkManager
:
:
Update
(
nullptr
)
)
;
mChunkManager
=
nullptr
;
mAwaitNextChunkManagerUpdateResolver
=
nullptr
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvStart
(
const
ProfilerInitParams
&
params
)
{
nsTArray
<
const
char
*
>
filterArray
;
for
(
size_t
i
=
0
;
i
<
params
.
filters
(
)
.
Length
(
)
;
+
+
i
)
{
filterArray
.
AppendElement
(
params
.
filters
(
)
[
i
]
.
get
(
)
)
;
}
profiler_start
(
PowerOfTwo32
(
params
.
entries
(
)
)
params
.
interval
(
)
params
.
features
(
)
filterArray
.
Elements
(
)
filterArray
.
Length
(
)
params
.
activeBrowsingContextID
(
)
params
.
duration
(
)
)
;
SetupChunkManager
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvEnsureStarted
(
const
ProfilerInitParams
&
params
)
{
nsTArray
<
const
char
*
>
filterArray
;
for
(
size_t
i
=
0
;
i
<
params
.
filters
(
)
.
Length
(
)
;
+
+
i
)
{
filterArray
.
AppendElement
(
params
.
filters
(
)
[
i
]
.
get
(
)
)
;
}
profiler_ensure_started
(
PowerOfTwo32
(
params
.
entries
(
)
)
params
.
interval
(
)
params
.
features
(
)
filterArray
.
Elements
(
)
filterArray
.
Length
(
)
params
.
activeBrowsingContextID
(
)
params
.
duration
(
)
)
;
SetupChunkManager
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvStop
(
)
{
ResetChunkManager
(
)
;
profiler_stop
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvPause
(
)
{
profiler_pause
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvResume
(
)
{
profiler_resume
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvPauseSampling
(
)
{
profiler_pause_sampling
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvResumeSampling
(
)
{
profiler_resume_sampling
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvClearAllPages
(
)
{
profiler_clear_all_pages
(
)
;
return
IPC_OK
(
)
;
}
static
nsCString
CollectProfileOrEmptyString
(
bool
aIsShuttingDown
)
{
nsCString
profileCString
;
UniquePtr
<
char
[
]
>
profile
=
profiler_get_profile
(
0
aIsShuttingDown
)
;
if
(
profile
)
{
size_t
len
=
strlen
(
profile
.
get
(
)
)
;
profileCString
.
Adopt
(
profile
.
release
(
)
len
)
;
}
return
profileCString
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvAwaitNextChunkManagerUpdate
(
AwaitNextChunkManagerUpdateResolver
&
&
aResolve
)
{
MOZ_ASSERT
(
!
mDestroyed
"
Recv
.
.
.
should
not
be
called
if
the
actor
was
destroyed
"
)
;
{
auto
lockedUpdate
=
sPendingChunkManagerUpdate
.
Lock
(
)
;
if
(
lockedUpdate
-
>
mProfilerChild
&
&
!
lockedUpdate
-
>
mUpdate
.
IsNotUpdate
(
)
)
{
mChunkManagerUpdate
.
Fold
(
std
:
:
move
(
lockedUpdate
-
>
mUpdate
)
)
;
lockedUpdate
-
>
mUpdate
.
Clear
(
)
;
}
}
if
(
mChunkManagerUpdate
.
IsNotUpdate
(
)
)
{
mAwaitNextChunkManagerUpdateResolver
=
std
:
:
move
(
aResolve
)
;
}
else
{
ResolveChunkUpdate
(
aResolve
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvDestroyReleasedChunksAtOrBefore
(
const
TimeStamp
&
aTimeStamp
)
{
if
(
mChunkManager
)
{
mChunkManager
-
>
DestroyChunksAtOrBefore
(
aTimeStamp
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
ProfilerChild
:
:
RecvGatherProfile
(
GatherProfileResolver
&
&
aResolve
)
{
mozilla
:
:
ipc
:
:
Shmem
shmem
;
profiler_get_profile_json_into_lazily_allocated_buffer
(
[
&
]
(
size_t
allocationSize
)
-
>
char
*
{
if
(
AllocShmem
(
allocationSize
mozilla
:
:
ipc
:
:
Shmem
:
:
SharedMemory
:
:
TYPE_BASIC
&
shmem
)
)
{
return
shmem
.
get
<
char
>
(
)
;
}
return
nullptr
;
}
0
false
)
;
aResolve
(
std
:
:
move
(
shmem
)
)
;
return
IPC_OK
(
)
;
}
void
ProfilerChild
:
:
ActorDestroy
(
ActorDestroyReason
aActorDestroyReason
)
{
mDestroyed
=
true
;
}
void
ProfilerChild
:
:
Destroy
(
)
{
ResetChunkManager
(
)
;
if
(
!
mDestroyed
)
{
Close
(
)
;
}
}
nsCString
ProfilerChild
:
:
GrabShutdownProfile
(
)
{
return
CollectProfileOrEmptyString
(
true
)
;
}
}
