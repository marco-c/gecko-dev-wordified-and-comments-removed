#
include
"
ThreadResponsiveness
.
h
"
#
include
"
platform
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
nsITimer
.
h
"
using
namespace
mozilla
;
class
CheckResponsivenessTask
:
public
CancelableRunnable
public
nsITimerCallback
{
public
:
explicit
CheckResponsivenessTask
(
nsIEventTarget
*
aThread
bool
aIsMainThread
)
:
CancelableRunnable
(
"
CheckResponsivenessTask
"
)
mStartToPrevTracer_us
(
uint64_t
(
profiler_time
(
)
*
1000
.
0
)
)
mStop
(
false
)
mHasEverBeenSuccessfullyDispatched
(
false
)
mThread
(
aThread
)
mIsMainThread
(
aIsMainThread
)
{
}
protected
:
~
CheckResponsivenessTask
(
)
{
}
public
:
bool
DoFirstDispatchIfNeeded
(
)
{
if
(
mHasEverBeenSuccessfullyDispatched
)
{
return
true
;
}
if
(
mIsMainThread
)
{
if
(
!
mThread
)
{
nsCOMPtr
<
nsIThread
>
temp
;
NS_GetMainThread
(
getter_AddRefs
(
temp
)
)
;
mThread
=
temp
.
forget
(
)
;
}
if
(
mThread
)
{
nsresult
rv
=
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
do_AddRef
(
this
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mHasEverBeenSuccessfullyDispatched
=
true
;
}
}
}
else
if
(
mThread
)
{
nsresult
rv
=
mThread
-
>
Dispatch
(
this
nsIThread
:
:
NS_DISPATCH_NORMAL
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mHasEverBeenSuccessfullyDispatched
=
true
;
}
}
return
mHasEverBeenSuccessfullyDispatched
;
}
nsresult
Cancel
(
)
override
{
return
NS_OK
;
}
NS_IMETHOD
Run
(
)
override
{
mStartToPrevTracer_us
=
uint64_t
(
profiler_time
(
)
*
1000
.
0
)
;
if
(
!
mStop
)
{
if
(
!
mTimer
)
{
if
(
mIsMainThread
)
{
mTimer
=
NS_NewTimer
(
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
}
else
{
mTimer
=
NS_NewTimer
(
)
;
}
}
mTimer
-
>
InitWithCallback
(
this
16
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
return
NS_OK
;
}
NS_IMETHOD
Notify
(
nsITimer
*
aTimer
)
final
{
Run
(
)
;
return
NS_OK
;
}
void
Terminate
(
)
{
mStop
=
true
;
}
double
GetStartToPrevTracer_ms
(
)
const
{
return
mStartToPrevTracer_us
/
1000
.
0
;
}
NS_DECL_ISUPPORTS_INHERITED
private
:
nsCOMPtr
<
nsITimer
>
mTimer
;
Atomic
<
uint64_t
>
mStartToPrevTracer_us
;
Atomic
<
bool
>
mStop
;
bool
mHasEverBeenSuccessfullyDispatched
;
nsCOMPtr
<
nsIEventTarget
>
mThread
;
bool
mIsMainThread
;
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
CheckResponsivenessTask
CancelableRunnable
nsITimerCallback
)
ThreadResponsiveness
:
:
ThreadResponsiveness
(
nsIEventTarget
*
aThread
bool
aIsMainThread
)
:
mActiveTracerEvent
(
new
CheckResponsivenessTask
(
aThread
aIsMainThread
)
)
{
MOZ_COUNT_CTOR
(
ThreadResponsiveness
)
;
}
ThreadResponsiveness
:
:
~
ThreadResponsiveness
(
)
{
MOZ_COUNT_DTOR
(
ThreadResponsiveness
)
;
mActiveTracerEvent
-
>
Terminate
(
)
;
}
void
ThreadResponsiveness
:
:
Update
(
)
{
if
(
!
mActiveTracerEvent
-
>
DoFirstDispatchIfNeeded
(
)
)
{
return
;
}
mStartToPrevTracer_ms
=
Some
(
mActiveTracerEvent
-
>
GetStartToPrevTracer_ms
(
)
)
;
}
