#
include
"
ProfilerParent
.
h
"
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
nsProfiler
.
h
"
#
include
"
platform
.
h
"
#
endif
#
include
"
GeckoProfiler
.
h
"
#
include
"
ProfilerControl
.
h
"
#
include
"
mozilla
/
BaseAndGeckoProfilerDetail
.
h
"
#
include
"
mozilla
/
BaseProfilerDetail
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
IOInterposer
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ProfileBufferControlledChunkManager
.
h
"
#
include
"
mozilla
/
ProfilerBufferSize
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
<
utility
>
namespace
mozilla
{
using
namespace
ipc
;
Endpoint
<
PProfilerChild
>
ProfilerParent
:
:
CreateForProcess
(
base
:
:
ProcessId
aOtherPid
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
Endpoint
<
PProfilerChild
>
child
;
#
ifdef
MOZ_GECKO_PROFILER
Endpoint
<
PProfilerParent
>
parent
;
nsresult
rv
=
PProfiler
:
:
CreateEndpoints
(
&
parent
&
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
Failed
to
create
top
level
actor
for
PProfiler
!
"
)
;
}
RefPtr
<
ProfilerParent
>
actor
=
new
ProfilerParent
(
aOtherPid
)
;
if
(
!
parent
.
Bind
(
actor
)
)
{
MOZ_CRASH
(
"
Failed
to
bind
parent
actor
for
PProfiler
!
"
)
;
}
actor
-
>
Init
(
)
;
#
endif
return
child
;
}
#
ifdef
MOZ_GECKO_PROFILER
class
ProfilerParentTracker
;
class
ProfileBufferGlobalController
final
{
public
:
explicit
ProfileBufferGlobalController
(
size_t
aMaximumBytes
)
;
~
ProfileBufferGlobalController
(
)
;
void
HandleChildChunkManagerUpdate
(
base
:
:
ProcessId
aProcessId
ProfileBufferControlledChunkManager
:
:
Update
&
&
aUpdate
)
;
static
bool
IsLockedOnCurrentThread
(
)
;
private
:
template
<
typename
F
>
void
Log
(
F
&
&
aF
)
;
static
void
LogUpdateChunks
(
Json
:
:
Value
&
updates
base
:
:
ProcessId
aProcessId
const
TimeStamp
&
aTimeStamp
int
aChunkDiff
)
;
void
LogUpdate
(
base
:
:
ProcessId
aProcessId
const
ProfileBufferControlledChunkManager
:
:
Update
&
aUpdate
)
;
void
LogDeletion
(
base
:
:
ProcessId
aProcessId
const
TimeStamp
&
aTimeStamp
)
;
void
HandleChunkManagerNonFinalUpdate
(
base
:
:
ProcessId
aProcessId
ProfileBufferControlledChunkManager
:
:
Update
&
&
aUpdate
ProfileBufferControlledChunkManager
&
aParentChunkManager
)
;
const
size_t
mMaximumBytes
;
const
base
:
:
ProcessId
mParentProcessId
=
base
:
:
GetCurrentProcId
(
)
;
struct
ParentChunkManagerAndPendingUpdate
{
ProfileBufferControlledChunkManager
*
mChunkManager
=
nullptr
;
ProfileBufferControlledChunkManager
:
:
Update
mPendingUpdate
;
}
;
static
DataMutexBase
<
ParentChunkManagerAndPendingUpdate
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
>
sParentChunkManagerAndPendingUpdate
;
size_t
mUnreleasedTotalBytes
=
0
;
struct
PidAndBytes
{
base
:
:
ProcessId
mProcessId
;
size_t
mBytes
;
bool
operator
=
=
(
base
:
:
ProcessId
aSearchedProcessId
)
const
{
return
mProcessId
=
=
aSearchedProcessId
;
}
bool
operator
=
=
(
const
PidAndBytes
&
aOther
)
const
{
return
mProcessId
=
=
aOther
.
mProcessId
;
}
bool
operator
<
(
base
:
:
ProcessId
aSearchedProcessId
)
const
{
return
mProcessId
<
aSearchedProcessId
;
}
bool
operator
<
(
const
PidAndBytes
&
aOther
)
const
{
return
mProcessId
<
aOther
.
mProcessId
;
}
}
;
using
PidAndBytesArray
=
nsTArray
<
PidAndBytes
>
;
PidAndBytesArray
mUnreleasedBytesByPid
;
size_t
mReleasedTotalBytes
=
0
;
struct
TimeStampAndBytesAndPid
{
TimeStamp
mTimeStamp
;
size_t
mBytes
;
base
:
:
ProcessId
mProcessId
;
bool
operator
=
=
(
const
TimeStampAndBytesAndPid
&
aOther
)
const
{
return
mTimeStamp
=
=
aOther
.
mTimeStamp
&
&
mProcessId
=
=
aOther
.
mProcessId
;
}
bool
operator
<
(
const
TimeStampAndBytesAndPid
&
aOther
)
const
{
return
mTimeStamp
<
aOther
.
mTimeStamp
|
|
(
MOZ_UNLIKELY
(
mTimeStamp
=
=
aOther
.
mTimeStamp
)
&
&
mProcessId
<
aOther
.
mProcessId
)
;
}
}
;
using
TimeStampAndBytesAndPidArray
=
nsTArray
<
TimeStampAndBytesAndPid
>
;
TimeStampAndBytesAndPidArray
mReleasedChunksByTime
;
}
;
DataMutexBase
<
ProfileBufferGlobalController
:
:
ParentChunkManagerAndPendingUpdate
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
>
ProfileBufferGlobalController
:
:
sParentChunkManagerAndPendingUpdate
{
"
ProfileBufferGlobalController
:
:
sParentChunkManagerAndPendingUpdate
"
}
;
class
ProfilerParentTracker
final
{
public
:
static
void
StartTracking
(
ProfilerParent
*
aParent
)
;
static
void
StopTracking
(
ProfilerParent
*
aParent
)
;
static
void
ProfilerStarted
(
uint32_t
aEntries
)
;
static
void
ProfilerWillStopIfStarted
(
)
;
static
size_t
ProfilerParentCount
(
)
;
template
<
typename
FuncType
>
static
void
Enumerate
(
FuncType
&
&
aIterFunc
)
;
template
<
typename
FuncType
>
static
void
ForChild
(
base
:
:
ProcessId
aChildPid
FuncType
&
&
aIterFunc
)
;
static
void
ForwardChildChunkManagerUpdate
(
base
:
:
ProcessId
aProcessId
ProfileBufferControlledChunkManager
:
:
Update
&
&
aUpdate
)
;
ProfilerParentTracker
(
)
;
~
ProfilerParentTracker
(
)
;
private
:
static
ProfilerParentTracker
*
GetInstance
(
)
;
nsTArray
<
ProfilerParent
*
>
mProfilerParents
;
uint32_t
mEntries
=
0
;
Maybe
<
ProfileBufferGlobalController
>
mMaybeController
;
}
;
static
const
Json
:
:
StaticString
logRoot
{
"
bufferGlobalController
"
}
;
template
<
typename
F
>
void
ProfileBufferGlobalController
:
:
Log
(
F
&
&
aF
)
{
ProfilingLog
:
:
Access
(
[
&
]
(
Json
:
:
Value
&
aLog
)
{
Json
:
:
Value
&
root
=
aLog
[
logRoot
]
;
if
(
!
root
.
isObject
(
)
)
{
root
=
Json
:
:
Value
(
Json
:
:
objectValue
)
;
root
[
Json
:
:
StaticString
{
"
logBegin
"
TIMESTAMP_JSON_SUFFIX
}
]
=
ProfilingLog
:
:
Timestamp
(
)
;
}
std
:
:
forward
<
F
>
(
aF
)
(
root
)
;
}
)
;
}
void
ProfileBufferGlobalController
:
:
LogUpdateChunks
(
Json
:
:
Value
&
updates
base
:
:
ProcessId
aProcessId
const
TimeStamp
&
aTimeStamp
int
aChunkDiff
)
{
MOZ_ASSERT
(
updates
.
isArray
(
)
)
;
Json
:
:
Value
row
{
Json
:
:
arrayValue
}
;
row
.
append
(
Json
:
:
Value
{
Json
:
:
UInt64
(
aProcessId
)
}
)
;
row
.
append
(
ProfilingLog
:
:
Timestamp
(
aTimeStamp
)
)
;
row
.
append
(
Json
:
:
Value
{
Json
:
:
Int
(
aChunkDiff
)
}
)
;
updates
.
append
(
std
:
:
move
(
row
)
)
;
}
void
ProfileBufferGlobalController
:
:
LogUpdate
(
base
:
:
ProcessId
aProcessId
const
ProfileBufferControlledChunkManager
:
:
Update
&
aUpdate
)
{
Log
(
[
&
]
(
Json
:
:
Value
&
aRoot
)
{
Json
:
:
Value
&
updates
=
aRoot
[
Json
:
:
StaticString
{
"
updates
"
}
]
;
if
(
!
updates
.
isArray
(
)
)
{
aRoot
[
Json
:
:
StaticString
{
"
updatesSchema
"
}
]
=
Json
:
:
StaticString
{
"
0
:
pid
1
:
chunkRelease_TSms
3
:
chunkDiff
"
}
;
updates
=
Json
:
:
Value
{
Json
:
:
arrayValue
}
;
}
if
(
aUpdate
.
IsFinal
(
)
)
{
LogUpdateChunks
(
updates
aProcessId
TimeStamp
{
}
0
)
;
}
else
if
(
!
aUpdate
.
IsNotUpdate
(
)
)
{
for
(
const
auto
&
chunk
:
aUpdate
.
NewlyReleasedChunksRef
(
)
)
{
LogUpdateChunks
(
updates
aProcessId
chunk
.
mDoneTimeStamp
1
)
;
}
}
}
)
;
}
void
ProfileBufferGlobalController
:
:
LogDeletion
(
base
:
:
ProcessId
aProcessId
const
TimeStamp
&
aTimeStamp
)
{
Log
(
[
&
]
(
Json
:
:
Value
&
aRoot
)
{
Json
:
:
Value
&
updates
=
aRoot
[
Json
:
:
StaticString
{
"
updates
"
}
]
;
if
(
!
updates
.
isArray
(
)
)
{
updates
=
Json
:
:
Value
{
Json
:
:
arrayValue
}
;
}
LogUpdateChunks
(
updates
aProcessId
aTimeStamp
-
1
)
;
}
)
;
}
ProfileBufferGlobalController
:
:
ProfileBufferGlobalController
(
size_t
aMaximumBytes
)
:
mMaximumBytes
(
aMaximumBytes
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
Log
(
[
]
(
Json
:
:
Value
&
aRoot
)
{
aRoot
[
Json
:
:
StaticString
{
"
controllerCreationTime
"
TIMESTAMP_JSON_SUFFIX
}
]
=
ProfilingLog
:
:
Timestamp
(
)
;
}
)
;
ProfileBufferControlledChunkManager
*
parentChunkManager
=
profiler_get_controlled_chunk_manager
(
)
;
if
(
NS_WARN_IF
(
!
parentChunkManager
)
)
{
Log
(
[
]
(
Json
:
:
Value
&
aRoot
)
{
aRoot
[
Json
:
:
StaticString
{
"
controllerCreationFailureReason
"
}
]
=
"
No
parent
chunk
manager
"
;
}
)
;
return
;
}
{
auto
lockedParentChunkManagerAndPendingUpdate
=
sParentChunkManagerAndPendingUpdate
.
Lock
(
)
;
lockedParentChunkManagerAndPendingUpdate
-
>
mChunkManager
=
parentChunkManager
;
}
parentChunkManager
-
>
SetUpdateCallback
(
[
this
]
(
ProfileBufferControlledChunkManager
:
:
Update
&
&
aUpdate
)
{
MOZ_ASSERT
(
!
aUpdate
.
IsNotUpdate
(
)
"
Update
callback
should
never
be
given
a
non
-
update
"
)
;
auto
lockedParentChunkManagerAndPendingUpdate
=
sParentChunkManagerAndPendingUpdate
.
Lock
(
)
;
if
(
aUpdate
.
IsFinal
(
)
)
{
lockedParentChunkManagerAndPendingUpdate
-
>
mChunkManager
=
nullptr
;
lockedParentChunkManagerAndPendingUpdate
-
>
mPendingUpdate
.
Clear
(
)
;
mUnreleasedTotalBytes
=
0
;
mUnreleasedBytesByPid
.
Clear
(
)
;
mReleasedTotalBytes
=
0
;
mReleasedChunksByTime
.
Clear
(
)
;
return
;
}
if
(
!
lockedParentChunkManagerAndPendingUpdate
-
>
mChunkManager
)
{
return
;
}
lockedParentChunkManagerAndPendingUpdate
-
>
mPendingUpdate
.
Fold
(
std
:
:
move
(
aUpdate
)
)
;
}
)
;
}
ProfileBufferGlobalController
:
:
~
ProfileBufferGlobalController
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
ProfileBufferControlledChunkManager
*
parentChunkManager
=
[
]
(
)
{
auto
lockedParentChunkManagerAndPendingUpdate
=
sParentChunkManagerAndPendingUpdate
.
Lock
(
)
;
lockedParentChunkManagerAndPendingUpdate
-
>
mPendingUpdate
.
Clear
(
)
;
return
std
:
:
exchange
(
lockedParentChunkManagerAndPendingUpdate
-
>
mChunkManager
nullptr
)
;
}
(
)
;
if
(
parentChunkManager
)
{
parentChunkManager
-
>
SetUpdateCallback
(
{
}
)
;
}
}
void
ProfileBufferGlobalController
:
:
HandleChildChunkManagerUpdate
(
base
:
:
ProcessId
aProcessId
ProfileBufferControlledChunkManager
:
:
Update
&
&
aUpdate
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aProcessId
!
=
mParentProcessId
)
;
MOZ_ASSERT
(
!
aUpdate
.
IsNotUpdate
(
)
"
HandleChildChunkManagerUpdate
should
not
be
given
a
non
-
update
"
)
;
auto
lockedParentChunkManagerAndPendingUpdate
=
sParentChunkManagerAndPendingUpdate
.
Lock
(
)
;
if
(
!
lockedParentChunkManagerAndPendingUpdate
-
>
mChunkManager
)
{
return
;
}
if
(
aUpdate
.
IsFinal
(
)
)
{
LogUpdate
(
aProcessId
aUpdate
)
;
size_t
index
=
mUnreleasedBytesByPid
.
BinaryIndexOf
(
aProcessId
)
;
if
(
index
!
=
PidAndBytesArray
:
:
NoIndex
)
{
PidAndBytes
&
pidAndBytes
=
mUnreleasedBytesByPid
[
index
]
;
mUnreleasedTotalBytes
-
=
pidAndBytes
.
mBytes
;
mUnreleasedBytesByPid
.
RemoveElementAt
(
index
)
;
}
size_t
released
=
0
;
mReleasedChunksByTime
.
RemoveElementsBy
(
[
&
released
aProcessId
]
(
const
auto
&
chunk
)
{
const
bool
match
=
chunk
.
mProcessId
=
=
aProcessId
;
if
(
match
)
{
released
+
=
chunk
.
mBytes
;
}
return
match
;
}
)
;
if
(
released
!
=
0
)
{
mReleasedTotalBytes
-
=
released
;
}
return
;
}
if
(
!
lockedParentChunkManagerAndPendingUpdate
-
>
mPendingUpdate
.
IsNotUpdate
(
)
)
{
MOZ_ASSERT
(
!
lockedParentChunkManagerAndPendingUpdate
-
>
mPendingUpdate
.
IsFinal
(
)
)
;
HandleChunkManagerNonFinalUpdate
(
mParentProcessId
std
:
:
move
(
lockedParentChunkManagerAndPendingUpdate
-
>
mPendingUpdate
)
*
lockedParentChunkManagerAndPendingUpdate
-
>
mChunkManager
)
;
lockedParentChunkManagerAndPendingUpdate
-
>
mPendingUpdate
.
Clear
(
)
;
}
HandleChunkManagerNonFinalUpdate
(
aProcessId
std
:
:
move
(
aUpdate
)
*
lockedParentChunkManagerAndPendingUpdate
-
>
mChunkManager
)
;
}
bool
ProfileBufferGlobalController
:
:
IsLockedOnCurrentThread
(
)
{
return
sParentChunkManagerAndPendingUpdate
.
Mutex
(
)
.
IsLockedOnCurrentThread
(
)
;
}
void
ProfileBufferGlobalController
:
:
HandleChunkManagerNonFinalUpdate
(
base
:
:
ProcessId
aProcessId
ProfileBufferControlledChunkManager
:
:
Update
&
&
aUpdate
ProfileBufferControlledChunkManager
&
aParentChunkManager
)
{
MOZ_ASSERT
(
!
aUpdate
.
IsFinal
(
)
)
;
LogUpdate
(
aProcessId
aUpdate
)
;
size_t
index
=
mUnreleasedBytesByPid
.
BinaryIndexOf
(
aProcessId
)
;
if
(
index
!
=
PidAndBytesArray
:
:
NoIndex
)
{
PidAndBytes
&
pidAndBytes
=
mUnreleasedBytesByPid
[
index
]
;
mUnreleasedTotalBytes
=
mUnreleasedTotalBytes
-
pidAndBytes
.
mBytes
+
aUpdate
.
UnreleasedBytes
(
)
;
pidAndBytes
.
mBytes
=
aUpdate
.
UnreleasedBytes
(
)
;
}
else
{
mUnreleasedBytesByPid
.
InsertElementSorted
(
PidAndBytes
{
aProcessId
aUpdate
.
UnreleasedBytes
(
)
}
)
;
mUnreleasedTotalBytes
+
=
aUpdate
.
UnreleasedBytes
(
)
;
}
size_t
destroyedReleased
=
0
;
if
(
!
aUpdate
.
OldestDoneTimeStamp
(
)
.
IsNull
(
)
)
{
size_t
i
=
0
;
for
(
;
i
<
mReleasedChunksByTime
.
Length
(
)
;
+
+
i
)
{
if
(
mReleasedChunksByTime
[
i
]
.
mTimeStamp
>
=
aUpdate
.
OldestDoneTimeStamp
(
)
)
{
break
;
}
}
while
(
i
!
=
0
)
{
-
-
i
;
const
TimeStampAndBytesAndPid
&
item
=
mReleasedChunksByTime
[
i
]
;
if
(
item
.
mProcessId
=
=
aProcessId
)
{
destroyedReleased
+
=
item
.
mBytes
;
mReleasedChunksByTime
.
RemoveElementAt
(
i
)
;
}
}
}
size_t
newlyReleased
=
0
;
for
(
const
ProfileBufferControlledChunkManager
:
:
ChunkMetadata
&
chunk
:
aUpdate
.
NewlyReleasedChunksRef
(
)
)
{
newlyReleased
+
=
chunk
.
mBufferBytes
;
mReleasedChunksByTime
.
InsertElementSorted
(
TimeStampAndBytesAndPid
{
chunk
.
mDoneTimeStamp
chunk
.
mBufferBytes
aProcessId
}
)
;
}
mReleasedTotalBytes
=
mReleasedTotalBytes
-
destroyedReleased
+
newlyReleased
;
#
ifdef
DEBUG
size_t
totalReleased
=
0
;
for
(
const
TimeStampAndBytesAndPid
&
item
:
mReleasedChunksByTime
)
{
totalReleased
+
=
item
.
mBytes
;
}
MOZ_ASSERT
(
mReleasedTotalBytes
=
=
totalReleased
)
;
#
endif
std
:
:
vector
<
ProfileBufferControlledChunkManager
:
:
ChunkMetadata
>
toDestroy
;
while
(
mUnreleasedTotalBytes
+
mReleasedTotalBytes
>
mMaximumBytes
&
&
!
mReleasedChunksByTime
.
IsEmpty
(
)
)
{
const
TimeStampAndBytesAndPid
&
oldest
=
mReleasedChunksByTime
[
0
]
;
LogDeletion
(
oldest
.
mProcessId
oldest
.
mTimeStamp
)
;
mReleasedTotalBytes
-
=
oldest
.
mBytes
;
if
(
oldest
.
mProcessId
=
=
mParentProcessId
)
{
aParentChunkManager
.
DestroyChunksAtOrBefore
(
oldest
.
mTimeStamp
)
;
}
else
{
ProfilerParentTracker
:
:
ForChild
(
oldest
.
mProcessId
[
timestamp
=
oldest
.
mTimeStamp
]
(
ProfilerParent
*
profilerParent
)
{
Unused
<
<
profilerParent
-
>
SendDestroyReleasedChunksAtOrBefore
(
timestamp
)
;
}
)
;
}
mReleasedChunksByTime
.
RemoveElementAt
(
0
)
;
}
}
ProfilerParentTracker
*
ProfilerParentTracker
:
:
GetInstance
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
static
UniquePtr
<
ProfilerParentTracker
>
instance
=
nullptr
;
if
(
MOZ_UNLIKELY
(
!
instance
)
)
{
if
(
PastShutdownPhase
(
ShutdownPhase
:
:
XPCOMShutdownThreads
)
)
{
return
nullptr
;
}
instance
=
MakeUnique
<
ProfilerParentTracker
>
(
)
;
ClearOnShutdown
(
&
instance
ShutdownPhase
:
:
XPCOMShutdownThreads
)
;
}
return
instance
.
get
(
)
;
}
void
ProfilerParentTracker
:
:
StartTracking
(
ProfilerParent
*
aProfilerParent
)
{
ProfilerParentTracker
*
tracker
=
GetInstance
(
)
;
if
(
!
tracker
)
{
return
;
}
if
(
tracker
-
>
mMaybeController
.
isNothing
(
)
&
&
tracker
-
>
mEntries
!
=
0
)
{
tracker
-
>
mMaybeController
.
emplace
(
size_t
(
tracker
-
>
mEntries
)
*
scBytesPerEntry
)
;
}
tracker
-
>
mProfilerParents
.
AppendElement
(
aProfilerParent
)
;
}
void
ProfilerParentTracker
:
:
StopTracking
(
ProfilerParent
*
aParent
)
{
ProfilerParentTracker
*
tracker
=
GetInstance
(
)
;
if
(
!
tracker
)
{
return
;
}
tracker
-
>
mProfilerParents
.
RemoveElement
(
aParent
)
;
}
void
ProfilerParentTracker
:
:
ProfilerStarted
(
uint32_t
aEntries
)
{
ProfilerParentTracker
*
tracker
=
GetInstance
(
)
;
if
(
!
tracker
)
{
return
;
}
tracker
-
>
mEntries
=
ClampToAllowedEntries
(
aEntries
)
;
if
(
tracker
-
>
mMaybeController
.
isNothing
(
)
&
&
!
tracker
-
>
mProfilerParents
.
IsEmpty
(
)
)
{
tracker
-
>
mMaybeController
.
emplace
(
size_t
(
tracker
-
>
mEntries
)
*
scBytesPerEntry
)
;
}
}
void
ProfilerParentTracker
:
:
ProfilerWillStopIfStarted
(
)
{
ProfilerParentTracker
*
tracker
=
GetInstance
(
)
;
if
(
!
tracker
)
{
return
;
}
tracker
-
>
mEntries
=
0
;
tracker
-
>
mMaybeController
=
Nothing
{
}
;
}
size_t
ProfilerParentTracker
:
:
ProfilerParentCount
(
)
{
size_t
count
=
0
;
ProfilerParentTracker
*
tracker
=
GetInstance
(
)
;
if
(
tracker
)
{
for
(
ProfilerParent
*
profilerParent
:
tracker
-
>
mProfilerParents
)
{
if
(
!
profilerParent
-
>
mDestroyed
)
{
+
+
count
;
}
}
}
return
count
;
}
template
<
typename
FuncType
>
void
ProfilerParentTracker
:
:
Enumerate
(
FuncType
&
&
aIterFunc
)
{
ProfilerParentTracker
*
tracker
=
GetInstance
(
)
;
if
(
!
tracker
)
{
return
;
}
for
(
ProfilerParent
*
profilerParent
:
tracker
-
>
mProfilerParents
)
{
if
(
!
profilerParent
-
>
mDestroyed
)
{
aIterFunc
(
profilerParent
)
;
}
}
}
template
<
typename
FuncType
>
void
ProfilerParentTracker
:
:
ForChild
(
base
:
:
ProcessId
aChildPid
FuncType
&
&
aIterFunc
)
{
ProfilerParentTracker
*
tracker
=
GetInstance
(
)
;
if
(
!
tracker
)
{
return
;
}
for
(
ProfilerParent
*
profilerParent
:
tracker
-
>
mProfilerParents
)
{
if
(
profilerParent
-
>
mChildPid
=
=
aChildPid
)
{
if
(
!
profilerParent
-
>
mDestroyed
)
{
std
:
:
forward
<
FuncType
>
(
aIterFunc
)
(
profilerParent
)
;
}
return
;
}
}
}
void
ProfilerParentTracker
:
:
ForwardChildChunkManagerUpdate
(
base
:
:
ProcessId
aProcessId
ProfileBufferControlledChunkManager
:
:
Update
&
&
aUpdate
)
{
ProfilerParentTracker
*
tracker
=
GetInstance
(
)
;
if
(
!
tracker
|
|
tracker
-
>
mMaybeController
.
isNothing
(
)
)
{
return
;
}
MOZ_ASSERT
(
!
aUpdate
.
IsNotUpdate
(
)
"
No
process
should
ever
send
a
non
-
update
"
)
;
tracker
-
>
mMaybeController
-
>
HandleChildChunkManagerUpdate
(
aProcessId
std
:
:
move
(
aUpdate
)
)
;
}
ProfilerParentTracker
:
:
ProfilerParentTracker
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_COUNT_CTOR
(
ProfilerParentTracker
)
;
}
ProfilerParentTracker
:
:
~
ProfilerParentTracker
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
|
|
mProfilerParents
.
IsEmpty
(
)
)
;
MOZ_COUNT_DTOR
(
ProfilerParentTracker
)
;
for
(
ProfilerParent
*
profilerParent
:
mProfilerParents
.
Clone
(
)
)
{
if
(
!
profilerParent
-
>
mDestroyed
)
{
RefPtr
<
ProfilerParent
>
actor
=
profilerParent
;
actor
-
>
Close
(
)
;
}
}
}
ProfilerParent
:
:
ProfilerParent
(
base
:
:
ProcessId
aChildPid
)
:
mChildPid
(
aChildPid
)
mDestroyed
(
false
)
{
MOZ_COUNT_CTOR
(
ProfilerParent
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
ProfilerParent
:
:
Init
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
ProfilerParentTracker
:
:
StartTracking
(
this
)
;
int
entries
=
0
;
Maybe
<
double
>
duration
=
Nothing
(
)
;
double
interval
=
0
;
mozilla
:
:
Vector
<
const
char
*
>
filters
;
uint32_t
features
;
uint64_t
activeTabID
;
profiler_get_start_params
(
&
entries
&
duration
&
interval
&
features
&
filters
&
activeTabID
)
;
if
(
entries
!
=
0
)
{
ProfilerInitParams
ipcParams
;
ipcParams
.
enabled
(
)
=
true
;
ipcParams
.
entries
(
)
=
entries
;
ipcParams
.
duration
(
)
=
duration
;
ipcParams
.
interval
(
)
=
interval
;
ipcParams
.
features
(
)
=
features
;
ipcParams
.
activeTabID
(
)
=
activeTabID
;
if
(
!
profiler
:
:
detail
:
:
FiltersExcludePid
(
filters
ProfilerProcessId
:
:
FromNumber
(
mChildPid
)
)
)
{
ipcParams
.
filters
(
)
.
SetCapacity
(
filters
.
length
(
)
)
;
for
(
const
char
*
filter
:
filters
)
{
ipcParams
.
filters
(
)
.
AppendElement
(
filter
)
;
}
Unused
<
<
SendEnsureStarted
(
ipcParams
)
;
RequestChunkManagerUpdate
(
)
;
return
;
}
}
Unused
<
<
SendStop
(
)
;
}
#
endif
ProfilerParent
:
:
~
ProfilerParent
(
)
{
MOZ_COUNT_DTOR
(
ProfilerParent
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
#
ifdef
MOZ_GECKO_PROFILER
ProfilerParentTracker
:
:
StopTracking
(
this
)
;
#
endif
}
#
ifdef
MOZ_GECKO_PROFILER
nsTArray
<
ProfilerParent
:
:
SingleProcessProfilePromiseAndChildPid
>
ProfilerParent
:
:
GatherProfiles
(
)
{
nsTArray
<
SingleProcessProfilePromiseAndChildPid
>
results
;
if
(
!
NS_IsMainThread
(
)
)
{
return
results
;
}
results
.
SetCapacity
(
ProfilerParentTracker
:
:
ProfilerParentCount
(
)
)
;
ProfilerParentTracker
:
:
Enumerate
(
[
&
]
(
ProfilerParent
*
profilerParent
)
{
results
.
AppendElement
(
SingleProcessProfilePromiseAndChildPid
{
profilerParent
-
>
SendGatherProfile
(
)
profilerParent
-
>
mChildPid
}
)
;
}
)
;
return
results
;
}
RefPtr
<
ProfilerParent
:
:
SingleProcessProgressPromise
>
ProfilerParent
:
:
RequestGatherProfileProgress
(
base
:
:
ProcessId
aChildPid
)
{
RefPtr
<
SingleProcessProgressPromise
>
promise
;
ProfilerParentTracker
:
:
ForChild
(
aChildPid
[
&
promise
]
(
ProfilerParent
*
profilerParent
)
{
promise
=
profilerParent
-
>
SendGetGatherProfileProgress
(
)
;
}
)
;
return
promise
;
}
constexpr
static
uint64_t
scUpdateUnreleasedBytesFINAL
=
uint64_t
(
-
1
)
;
ProfileBufferChunkManagerUpdate
ProfilerParent
:
:
MakeFinalUpdate
(
)
{
return
ProfileBufferChunkManagerUpdate
{
uint64_t
(
scUpdateUnreleasedBytesFINAL
)
0
TimeStamp
{
}
nsTArray
<
ProfileBufferChunkMetadata
>
{
}
}
;
}
bool
ProfilerParent
:
:
IsLockedOnCurrentThread
(
)
{
return
ProfileBufferGlobalController
:
:
IsLockedOnCurrentThread
(
)
;
}
void
ProfilerParent
:
:
RequestChunkManagerUpdate
(
)
{
if
(
mDestroyed
)
{
return
;
}
RefPtr
<
AwaitNextChunkManagerUpdatePromise
>
updatePromise
=
SendAwaitNextChunkManagerUpdate
(
)
;
updatePromise
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
=
RefPtr
<
ProfilerParent
>
(
this
)
]
(
const
ProfileBufferChunkManagerUpdate
&
aUpdate
)
{
if
(
aUpdate
.
unreleasedBytes
(
)
=
=
scUpdateUnreleasedBytesFINAL
)
{
ProfilerParentTracker
:
:
ForwardChildChunkManagerUpdate
(
self
-
>
mChildPid
ProfileBufferControlledChunkManager
:
:
Update
(
nullptr
)
)
;
}
else
{
std
:
:
vector
<
ProfileBufferControlledChunkManager
:
:
ChunkMetadata
>
chunks
;
if
(
!
aUpdate
.
newlyReleasedChunks
(
)
.
IsEmpty
(
)
)
{
chunks
.
reserve
(
aUpdate
.
newlyReleasedChunks
(
)
.
Length
(
)
)
;
for
(
const
ProfileBufferChunkMetadata
&
chunk
:
aUpdate
.
newlyReleasedChunks
(
)
)
{
chunks
.
emplace_back
(
chunk
.
doneTimeStamp
(
)
chunk
.
bufferBytes
(
)
)
;
}
}
ProfilerParentTracker
:
:
ForwardChildChunkManagerUpdate
(
self
-
>
mChildPid
ProfileBufferControlledChunkManager
:
:
Update
(
aUpdate
.
unreleasedBytes
(
)
aUpdate
.
releasedBytes
(
)
aUpdate
.
oldestDoneTimeStamp
(
)
std
:
:
move
(
chunks
)
)
)
;
self
-
>
RequestChunkManagerUpdate
(
)
;
}
}
[
self
=
RefPtr
<
ProfilerParent
>
(
this
)
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
aReason
)
{
ProfilerParentTracker
:
:
ForwardChildChunkManagerUpdate
(
self
-
>
mChildPid
ProfileBufferControlledChunkManager
:
:
Update
(
nullptr
)
)
;
}
)
;
}
class
PromiseResolverOnDestruction
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
PromiseResolverOnDestruction
)
template
<
typename
TaskFunction
>
static
RefPtr
<
GenericPromise
>
RunTask
(
TaskFunction
&
&
aTaskFunction
)
{
RefPtr
<
PromiseResolverOnDestruction
>
promiseResolver
=
new
PromiseResolverOnDestruction
(
)
;
RefPtr
<
GenericPromise
>
promise
=
promiseResolver
-
>
mPromiseHolder
.
Ensure
(
__func__
)
;
std
:
:
forward
<
TaskFunction
>
(
aTaskFunction
)
(
std
:
:
move
(
promiseResolver
)
)
;
return
promise
;
}
private
:
PromiseResolverOnDestruction
(
)
=
default
;
~
PromiseResolverOnDestruction
(
)
{
mPromiseHolder
.
ResolveIfExists
(
true
__func__
)
;
}
MozPromiseHolder
<
GenericPromise
>
mPromiseHolder
;
}
;
template
<
typename
ProfilerParentSendFunction
>
static
RefPtr
<
GenericPromise
>
SendAndConvertPromise
(
ProfilerParentSendFunction
&
&
aProfilerParentSendFunction
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
return
PromiseResolverOnDestruction
:
:
RunTask
(
[
&
]
(
RefPtr
<
PromiseResolverOnDestruction
>
aPromiseResolver
)
{
ProfilerParentTracker
:
:
Enumerate
(
[
&
]
(
ProfilerParent
*
profilerParent
)
{
std
:
:
forward
<
ProfilerParentSendFunction
>
(
aProfilerParentSendFunction
)
(
profilerParent
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
aPromiseResolver
]
(
typename
std
:
:
remove_reference_t
<
decltype
(
*
std
:
:
forward
<
ProfilerParentSendFunction
>
(
aProfilerParentSendFunction
)
(
profilerParent
)
)
>
:
:
ResolveOrRejectValue
&
&
)
{
}
)
;
}
)
;
}
)
;
}
RefPtr
<
GenericPromise
>
ProfilerParent
:
:
ProfilerStarted
(
nsIProfilerStartParams
*
aParams
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
ProfilerInitParams
ipcParams
;
double
duration
;
ipcParams
.
enabled
(
)
=
true
;
aParams
-
>
GetEntries
(
&
ipcParams
.
entries
(
)
)
;
aParams
-
>
GetDuration
(
&
duration
)
;
if
(
duration
>
0
.
0
)
{
ipcParams
.
duration
(
)
=
Some
(
duration
)
;
}
else
{
ipcParams
.
duration
(
)
=
Nothing
(
)
;
}
aParams
-
>
GetInterval
(
&
ipcParams
.
interval
(
)
)
;
aParams
-
>
GetFeatures
(
&
ipcParams
.
features
(
)
)
;
ipcParams
.
filters
(
)
=
aParams
-
>
GetFilters
(
)
.
Clone
(
)
;
auto
filtersCStrings
=
nsTArray
<
const
char
*
>
{
aParams
-
>
GetFilters
(
)
.
Length
(
)
}
;
for
(
const
auto
&
filter
:
aParams
-
>
GetFilters
(
)
)
{
filtersCStrings
.
AppendElement
(
filter
.
Data
(
)
)
;
}
aParams
-
>
GetActiveTabID
(
&
ipcParams
.
activeTabID
(
)
)
;
ProfilerParentTracker
:
:
ProfilerStarted
(
ipcParams
.
entries
(
)
)
;
return
SendAndConvertPromise
(
[
&
]
(
ProfilerParent
*
profilerParent
)
{
if
(
profiler
:
:
detail
:
:
FiltersExcludePid
(
filtersCStrings
ProfilerProcessId
:
:
FromNumber
(
profilerParent
-
>
mChildPid
)
)
)
{
return
PProfilerParent
:
:
StartPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
auto
promise
=
profilerParent
-
>
SendStart
(
ipcParams
)
;
profilerParent
-
>
RequestChunkManagerUpdate
(
)
;
return
promise
;
}
)
;
}
void
ProfilerParent
:
:
ProfilerWillStopIfStarted
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
ProfilerParentTracker
:
:
ProfilerWillStopIfStarted
(
)
;
}
RefPtr
<
GenericPromise
>
ProfilerParent
:
:
ProfilerStopped
(
)
{
return
SendAndConvertPromise
(
[
]
(
ProfilerParent
*
profilerParent
)
{
return
profilerParent
-
>
SendStop
(
)
;
}
)
;
}
RefPtr
<
GenericPromise
>
ProfilerParent
:
:
ProfilerPaused
(
)
{
return
SendAndConvertPromise
(
[
]
(
ProfilerParent
*
profilerParent
)
{
return
profilerParent
-
>
SendPause
(
)
;
}
)
;
}
RefPtr
<
GenericPromise
>
ProfilerParent
:
:
ProfilerResumed
(
)
{
return
SendAndConvertPromise
(
[
]
(
ProfilerParent
*
profilerParent
)
{
return
profilerParent
-
>
SendResume
(
)
;
}
)
;
}
RefPtr
<
GenericPromise
>
ProfilerParent
:
:
ProfilerPausedSampling
(
)
{
return
SendAndConvertPromise
(
[
]
(
ProfilerParent
*
profilerParent
)
{
return
profilerParent
-
>
SendPauseSampling
(
)
;
}
)
;
}
RefPtr
<
GenericPromise
>
ProfilerParent
:
:
ProfilerResumedSampling
(
)
{
return
SendAndConvertPromise
(
[
]
(
ProfilerParent
*
profilerParent
)
{
return
profilerParent
-
>
SendResumeSampling
(
)
;
}
)
;
}
void
ProfilerParent
:
:
ClearAllPages
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
ProfilerParentTracker
:
:
Enumerate
(
[
]
(
ProfilerParent
*
profilerParent
)
{
Unused
<
<
profilerParent
-
>
SendClearAllPages
(
)
;
}
)
;
}
RefPtr
<
GenericPromise
>
ProfilerParent
:
:
WaitOnePeriodicSampling
(
)
{
return
SendAndConvertPromise
(
[
]
(
ProfilerParent
*
profilerParent
)
{
return
profilerParent
-
>
SendWaitOnePeriodicSampling
(
)
;
}
)
;
}
void
ProfilerParent
:
:
ActorDestroy
(
ActorDestroyReason
aActorDestroyReason
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
mDestroyed
=
true
;
}
#
endif
}
