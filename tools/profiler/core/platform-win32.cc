#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
include
<
process
.
h
>
#
include
"
platform
.
h
"
#
include
"
ProfileEntry
.
h
"
#
include
"
ThreadInfo
.
h
"
#
include
"
ThreadResponsiveness
.
h
"
#
include
"
nsMemoryReporterManager
.
h
"
#
include
"
mozilla
/
StackWalk_windows
.
h
"
class
PlatformData
{
public
:
explicit
PlatformData
(
int
aThreadId
)
:
profiled_thread_
(
OpenThread
(
THREAD_GET_CONTEXT
|
THREAD_SUSPEND_RESUME
|
THREAD_QUERY_INFORMATION
false
aThreadId
)
)
{
}
~
PlatformData
(
)
{
if
(
profiled_thread_
!
=
NULL
)
{
CloseHandle
(
profiled_thread_
)
;
profiled_thread_
=
NULL
;
}
}
HANDLE
profiled_thread
(
)
{
return
profiled_thread_
;
}
private
:
HANDLE
profiled_thread_
;
}
;
auto
Sampler
:
:
AllocPlatformData
(
int
aThreadId
)
-
>
UniquePlatformData
{
return
UniquePlatformData
(
new
PlatformData
(
aThreadId
)
)
;
}
void
Sampler
:
:
PlatformDataDestructor
:
:
operator
(
)
(
PlatformData
*
aData
)
{
delete
aData
;
}
uintptr_t
Sampler
:
:
GetThreadHandle
(
PlatformData
*
aData
)
{
return
(
uintptr_t
)
aData
-
>
profiled_thread
(
)
;
}
static
const
HANDLE
kNoThread
=
INVALID_HANDLE_VALUE
;
class
SamplerThread
{
public
:
explicit
SamplerThread
(
double
interval
)
:
mStackSize
(
0
)
mThread
(
kNoThread
)
mInterval
(
interval
)
{
mInterval
=
floor
(
interval
+
0
.
5
)
;
if
(
mInterval
<
=
0
)
{
mInterval
=
1
;
}
}
~
SamplerThread
(
)
{
if
(
mThread
!
=
kNoThread
)
{
CloseHandle
(
mThread
)
;
}
}
static
unsigned
int
__stdcall
ThreadEntry
(
void
*
aArg
)
{
SamplerThread
*
thread
=
reinterpret_cast
<
SamplerThread
*
>
(
aArg
)
;
thread
-
>
Run
(
)
;
return
0
;
}
void
Start
(
)
{
mThread
=
reinterpret_cast
<
HANDLE
>
(
_beginthreadex
(
NULL
static_cast
<
unsigned
>
(
mStackSize
)
ThreadEntry
this
0
(
unsigned
int
*
)
&
mThreadId
)
)
;
}
void
Join
(
)
{
if
(
mThreadId
!
=
Thread
:
:
GetCurrentId
(
)
)
{
WaitForSingleObject
(
mThread
INFINITE
)
;
}
}
static
void
StartSampler
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mInstance
=
=
NULL
)
{
mInstance
=
new
SamplerThread
(
gSampler
-
>
interval
(
)
)
;
mInstance
-
>
Start
(
)
;
}
else
{
MOZ_ASSERT
(
mInstance
-
>
mInterval
=
=
gSampler
-
>
interval
(
)
)
;
}
}
static
void
StopSampler
(
)
{
mInstance
-
>
Join
(
)
;
delete
mInstance
;
mInstance
=
NULL
;
}
void
Run
(
)
{
if
(
mInterval
<
10
)
:
:
timeBeginPeriod
(
mInterval
)
;
while
(
gSampler
-
>
IsActive
(
)
)
{
gSampler
-
>
DeleteExpiredMarkers
(
)
;
if
(
!
gSampler
-
>
IsPaused
(
)
)
{
mozilla
:
:
StaticMutexAutoLock
lock
(
Sampler
:
:
sRegisteredThreadsMutex
)
;
bool
isFirstProfiledThread
=
true
;
for
(
uint32_t
i
=
0
;
i
<
Sampler
:
:
sRegisteredThreads
-
>
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
(
*
Sampler
:
:
sRegisteredThreads
)
[
i
]
;
if
(
!
info
-
>
hasProfile
(
)
|
|
info
-
>
IsPendingDelete
(
)
)
{
continue
;
}
PseudoStack
:
:
SleepState
sleeping
=
info
-
>
Stack
(
)
-
>
observeSleeping
(
)
;
if
(
sleeping
=
=
PseudoStack
:
:
SLEEPING_AGAIN
)
{
info
-
>
DuplicateLastSample
(
)
;
continue
;
}
info
-
>
UpdateThreadResponsiveness
(
)
;
SampleContext
(
info
isFirstProfiledThread
)
;
isFirstProfiledThread
=
false
;
}
}
OS
:
:
Sleep
(
mInterval
)
;
}
if
(
mInterval
<
10
)
:
:
timeEndPeriod
(
mInterval
)
;
}
void
SampleContext
(
ThreadInfo
*
aThreadInfo
bool
isFirstProfiledThread
)
{
uintptr_t
thread
=
Sampler
:
:
GetThreadHandle
(
aThreadInfo
-
>
GetPlatformData
(
)
)
;
HANDLE
profiled_thread
=
reinterpret_cast
<
HANDLE
>
(
thread
)
;
if
(
profiled_thread
=
=
NULL
)
return
;
CONTEXT
context
;
memset
(
&
context
0
sizeof
(
context
)
)
;
TickSample
sample_obj
;
TickSample
*
sample
=
&
sample_obj
;
sample
-
>
timestamp
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
sample
-
>
threadInfo
=
aThreadInfo
;
if
(
isFirstProfiledThread
&
&
gSampler
-
>
ProfileMemory
(
)
)
{
sample
-
>
rssMemory
=
nsMemoryReporterManager
:
:
ResidentFast
(
)
;
}
else
{
sample
-
>
rssMemory
=
0
;
}
sample
-
>
ussMemory
=
0
;
static
const
DWORD
kSuspendFailed
=
static_cast
<
DWORD
>
(
-
1
)
;
if
(
SuspendThread
(
profiled_thread
)
=
=
kSuspendFailed
)
return
;
#
if
V8_HOST_ARCH_X64
context
.
ContextFlags
=
CONTEXT_FULL
;
#
else
context
.
ContextFlags
=
CONTEXT_CONTROL
;
#
endif
if
(
!
GetThreadContext
(
profiled_thread
&
context
)
)
{
ResumeThread
(
profiled_thread
)
;
return
;
}
if
(
aThreadInfo
-
>
CanInvokeJS
(
)
)
{
if
(
!
TryAcquireStackWalkWorkaroundLock
(
)
)
{
ResumeThread
(
profiled_thread
)
;
return
;
}
ReleaseStackWalkWorkaroundLock
(
)
;
}
#
if
V8_HOST_ARCH_X64
sample
-
>
pc
=
reinterpret_cast
<
Address
>
(
context
.
Rip
)
;
sample
-
>
sp
=
reinterpret_cast
<
Address
>
(
context
.
Rsp
)
;
sample
-
>
fp
=
reinterpret_cast
<
Address
>
(
context
.
Rbp
)
;
#
else
sample
-
>
pc
=
reinterpret_cast
<
Address
>
(
context
.
Eip
)
;
sample
-
>
sp
=
reinterpret_cast
<
Address
>
(
context
.
Esp
)
;
sample
-
>
fp
=
reinterpret_cast
<
Address
>
(
context
.
Ebp
)
;
#
endif
sample
-
>
context
=
&
context
;
gSampler
-
>
Tick
(
sample
)
;
ResumeThread
(
profiled_thread
)
;
}
private
:
int
mStackSize
;
HANDLE
mThread
;
Thread
:
:
tid_t
mThreadId
;
int
mInterval
;
static
SamplerThread
*
mInstance
;
DISALLOW_COPY_AND_ASSIGN
(
SamplerThread
)
;
}
;
SamplerThread
*
SamplerThread
:
:
mInstance
=
NULL
;
void
Sampler
:
:
Start
(
)
{
MOZ_ASSERT
(
!
IsActive
(
)
)
;
SetActive
(
true
)
;
SamplerThread
:
:
StartSampler
(
)
;
}
void
Sampler
:
:
Stop
(
)
{
MOZ_ASSERT
(
IsActive
(
)
)
;
SetActive
(
false
)
;
SamplerThread
:
:
StopSampler
(
)
;
}
Thread
:
:
tid_t
Thread
:
:
GetCurrentId
(
)
{
return
GetCurrentThreadId
(
)
;
}
void
OS
:
:
Startup
(
)
{
}
void
OS
:
:
Sleep
(
int
milliseconds
)
{
:
:
Sleep
(
milliseconds
)
;
}
void
TickSample
:
:
PopulateContext
(
void
*
aContext
)
{
MOZ_ASSERT
(
aContext
)
;
CONTEXT
*
pContext
=
reinterpret_cast
<
CONTEXT
*
>
(
aContext
)
;
context
=
pContext
;
RtlCaptureContext
(
pContext
)
;
#
if
defined
(
SPS_PLAT_amd64_windows
)
pc
=
reinterpret_cast
<
Address
>
(
pContext
-
>
Rip
)
;
sp
=
reinterpret_cast
<
Address
>
(
pContext
-
>
Rsp
)
;
fp
=
reinterpret_cast
<
Address
>
(
pContext
-
>
Rbp
)
;
#
elif
defined
(
SPS_PLAT_x86_windows
)
pc
=
reinterpret_cast
<
Address
>
(
pContext
-
>
Eip
)
;
sp
=
reinterpret_cast
<
Address
>
(
pContext
-
>
Esp
)
;
fp
=
reinterpret_cast
<
Address
>
(
pContext
-
>
Ebp
)
;
#
endif
}
