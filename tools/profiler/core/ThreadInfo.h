#
ifndef
ThreadInfo_h
#
define
ThreadInfo_h
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
platform
.
h
"
#
include
"
ProfileBuffer
.
h
"
#
include
"
js
/
ProfilingStack
.
h
"
void
ProfilerJSEventMarker
(
const
char
*
aEvent
)
;
class
RacyThreadInfo
final
:
public
PseudoStack
{
public
:
RacyThreadInfo
(
)
:
PseudoStack
(
)
mSleep
(
AWAKE
)
{
MOZ_COUNT_CTOR
(
RacyThreadInfo
)
;
}
~
RacyThreadInfo
(
)
{
MOZ_COUNT_DTOR
(
RacyThreadInfo
)
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
return
n
;
}
void
AddPendingMarker
(
const
char
*
aMarkerStr
ProfilerMarkerPayload
*
aPayload
double
aTime
)
{
ProfilerMarker
*
marker
=
new
ProfilerMarker
(
aMarkerStr
aPayload
aTime
)
;
mPendingMarkers
.
insert
(
marker
)
;
}
ProfilerMarkerLinkedList
*
GetPendingMarkers
(
)
{
return
mPendingMarkers
.
accessList
(
)
;
}
void
ReinitializeOnResume
(
)
{
(
void
)
mSleep
.
compareExchange
(
SLEEPING_OBSERVED
SLEEPING_NOT_OBSERVED
)
;
}
bool
CanDuplicateLastSampleDueToSleep
(
)
{
if
(
mSleep
=
=
AWAKE
)
{
return
false
;
}
if
(
mSleep
.
compareExchange
(
SLEEPING_NOT_OBSERVED
SLEEPING_OBSERVED
)
)
{
return
false
;
}
return
true
;
}
void
SetSleeping
(
)
{
MOZ_ASSERT
(
mSleep
=
=
AWAKE
)
;
mSleep
=
SLEEPING_NOT_OBSERVED
;
}
void
SetAwake
(
)
{
MOZ_ASSERT
(
mSleep
!
=
AWAKE
)
;
mSleep
=
AWAKE
;
}
bool
IsSleeping
(
)
{
return
mSleep
!
=
AWAKE
;
}
private
:
ProfilerSignalSafeLinkedList
<
ProfilerMarker
>
mPendingMarkers
;
static
const
int
AWAKE
=
0
;
static
const
int
SLEEPING_NOT_OBSERVED
=
1
;
static
const
int
SLEEPING_OBSERVED
=
2
;
mozilla
:
:
Atomic
<
int
>
mSleep
;
}
;
class
ThreadInfo
final
{
public
:
ThreadInfo
(
const
char
*
aName
int
aThreadId
bool
aIsMainThread
void
*
aStackTop
)
;
~
ThreadInfo
(
)
;
const
char
*
Name
(
)
const
{
return
mName
.
get
(
)
;
}
int
ThreadId
(
)
const
{
return
mThreadId
;
}
bool
IsMainThread
(
)
const
{
return
mIsMainThread
;
}
mozilla
:
:
NotNull
<
RacyThreadInfo
*
>
RacyInfo
(
)
const
{
return
mRacyInfo
;
}
void
StartProfiling
(
)
;
void
StopProfiling
(
)
;
bool
IsBeingProfiled
(
)
{
return
mIsBeingProfiled
;
}
PlatformData
*
GetPlatformData
(
)
const
{
return
mPlatformData
.
get
(
)
;
}
void
*
StackTop
(
)
const
{
return
mStackTop
;
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
ProfileBuffer
:
:
LastSample
&
LastSample
(
)
{
return
mLastSample
;
}
private
:
mozilla
:
:
UniqueFreePtr
<
char
>
mName
;
int
mThreadId
;
const
bool
mIsMainThread
;
mozilla
:
:
NotNull
<
RacyThreadInfo
*
>
mRacyInfo
;
UniquePlatformData
mPlatformData
;
void
*
mStackTop
;
public
:
void
StreamJSON
(
ProfileBuffer
*
aBuffer
SpliceableJSONWriter
&
aWriter
const
mozilla
:
:
TimeStamp
&
aStartTime
double
aSinceTime
)
;
void
FlushSamplesAndMarkers
(
ProfileBuffer
*
aBuffer
const
mozilla
:
:
TimeStamp
&
aStartTime
)
;
ThreadResponsiveness
*
GetThreadResponsiveness
(
)
{
ThreadResponsiveness
*
responsiveness
=
mResponsiveness
.
ptrOr
(
nullptr
)
;
MOZ_ASSERT
(
!
!
responsiveness
=
=
(
mIsMainThread
&
&
mIsBeingProfiled
)
)
;
return
responsiveness
;
}
void
SetJSContext
(
JSContext
*
aContext
)
{
MOZ_ASSERT
(
aContext
&
&
!
mContext
)
;
mContext
=
aContext
;
js
:
:
SetContextProfilingStack
(
aContext
RacyInfo
(
)
)
;
PollJSSampling
(
)
;
}
void
StartJSSampling
(
)
{
MOZ_RELEASE_ASSERT
(
mJSSampling
=
=
INACTIVE
|
|
mJSSampling
=
=
INACTIVE_REQUESTED
)
;
mJSSampling
=
ACTIVE_REQUESTED
;
}
void
StopJSSampling
(
)
{
MOZ_RELEASE_ASSERT
(
mJSSampling
=
=
ACTIVE
|
|
mJSSampling
=
=
ACTIVE_REQUESTED
)
;
mJSSampling
=
INACTIVE_REQUESTED
;
}
void
PollJSSampling
(
)
{
if
(
mContext
)
{
if
(
mJSSampling
=
=
ACTIVE_REQUESTED
)
{
mJSSampling
=
ACTIVE
;
js
:
:
EnableContextProfilingStack
(
mContext
true
)
;
js
:
:
RegisterContextProfilingEventMarker
(
mContext
&
ProfilerJSEventMarker
)
;
}
else
if
(
mJSSampling
=
=
INACTIVE_REQUESTED
)
{
mJSSampling
=
INACTIVE
;
js
:
:
EnableContextProfilingStack
(
mContext
false
)
;
}
}
}
private
:
bool
mIsBeingProfiled
;
mozilla
:
:
UniquePtr
<
char
[
]
>
mSavedStreamedSamples
;
mozilla
:
:
UniquePtr
<
char
[
]
>
mSavedStreamedMarkers
;
mozilla
:
:
Maybe
<
UniqueStacks
>
mUniqueStacks
;
mozilla
:
:
Maybe
<
ThreadResponsiveness
>
mResponsiveness
;
public
:
JSContext
*
mContext
;
private
:
enum
{
INACTIVE
=
0
ACTIVE_REQUESTED
=
1
ACTIVE
=
2
INACTIVE_REQUESTED
=
3
}
mJSSampling
;
ProfileBuffer
:
:
LastSample
mLastSample
;
}
;
void
StreamSamplesAndMarkers
(
const
char
*
aName
int
aThreadId
ProfileBuffer
*
aBuffer
SpliceableJSONWriter
&
aWriter
const
mozilla
:
:
TimeStamp
&
aStartTime
double
aSinceTime
JSContext
*
aContext
char
*
aSavedStreamedSamples
char
*
aSavedStreamedMarkers
UniqueStacks
&
aUniqueStacks
)
;
#
endif
