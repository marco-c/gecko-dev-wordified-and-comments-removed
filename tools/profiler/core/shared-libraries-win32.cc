#
include
<
windows
.
h
>
#
include
<
dbghelp
.
h
>
#
include
<
sstream
>
#
include
<
psapi
.
h
>
#
include
"
shared
-
libraries
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
define
CV_SIGNATURE
0x53445352
/
/
'
SDSR
'
struct
CodeViewRecord70
{
uint32_t
signature
;
GUID
pdbSignature
;
uint32_t
pdbAge
;
char
pdbFileName
[
1
]
;
}
;
static
bool
GetPdbInfo
(
uintptr_t
aStart
nsID
&
aSignature
uint32_t
&
aAge
char
*
*
aPdbName
)
{
if
(
!
aStart
)
{
return
false
;
}
PIMAGE_DOS_HEADER
dosHeader
=
reinterpret_cast
<
PIMAGE_DOS_HEADER
>
(
aStart
)
;
if
(
dosHeader
-
>
e_magic
!
=
IMAGE_DOS_SIGNATURE
)
{
return
false
;
}
PIMAGE_NT_HEADERS
ntHeaders
=
reinterpret_cast
<
PIMAGE_NT_HEADERS
>
(
aStart
+
dosHeader
-
>
e_lfanew
)
;
if
(
ntHeaders
-
>
Signature
!
=
IMAGE_NT_SIGNATURE
)
{
return
false
;
}
uint32_t
relativeVirtualAddress
=
ntHeaders
-
>
OptionalHeader
.
DataDirectory
[
IMAGE_DIRECTORY_ENTRY_DEBUG
]
.
VirtualAddress
;
if
(
!
relativeVirtualAddress
)
{
return
false
;
}
PIMAGE_DEBUG_DIRECTORY
debugDirectory
=
reinterpret_cast
<
PIMAGE_DEBUG_DIRECTORY
>
(
aStart
+
relativeVirtualAddress
)
;
if
(
!
debugDirectory
|
|
debugDirectory
-
>
Type
!
=
IMAGE_DEBUG_TYPE_CODEVIEW
)
{
return
false
;
}
CodeViewRecord70
*
debugInfo
=
reinterpret_cast
<
CodeViewRecord70
*
>
(
aStart
+
debugDirectory
-
>
AddressOfRawData
)
;
if
(
!
debugInfo
|
|
debugInfo
-
>
signature
!
=
CV_SIGNATURE
)
{
return
false
;
}
aAge
=
debugInfo
-
>
pdbAge
;
GUID
&
pdbSignature
=
debugInfo
-
>
pdbSignature
;
aSignature
.
m0
=
pdbSignature
.
Data1
;
aSignature
.
m1
=
pdbSignature
.
Data2
;
aSignature
.
m2
=
pdbSignature
.
Data3
;
memcpy
(
aSignature
.
m3
pdbSignature
.
Data4
sizeof
(
pdbSignature
.
Data4
)
)
;
*
aPdbName
=
debugInfo
-
>
pdbFileName
;
return
true
;
}
static
bool
IsDashOrBraces
(
char
c
)
{
return
c
=
=
'
-
'
|
|
c
=
=
'
{
'
|
|
c
=
=
'
}
'
;
}
static
nsCString
GetVersion
(
WCHAR
*
dllPath
)
{
DWORD
infoSize
=
GetFileVersionInfoSizeW
(
dllPath
nullptr
)
;
if
(
infoSize
=
=
0
)
{
return
EmptyCString
(
)
;
}
mozilla
:
:
UniquePtr
<
unsigned
char
[
]
>
infoData
=
mozilla
:
:
MakeUnique
<
unsigned
char
[
]
>
(
infoSize
)
;
if
(
!
GetFileVersionInfoW
(
dllPath
0
infoSize
infoData
.
get
(
)
)
)
{
return
EmptyCString
(
)
;
}
VS_FIXEDFILEINFO
*
vInfo
;
UINT
vInfoLen
;
if
(
!
VerQueryValueW
(
infoData
.
get
(
)
L
"
\
\
"
(
LPVOID
*
)
&
vInfo
&
vInfoLen
)
)
{
return
EmptyCString
(
)
;
}
if
(
!
vInfo
)
{
return
EmptyCString
(
)
;
}
nsPrintfCString
version
(
"
%
d
.
%
d
.
%
d
.
%
d
"
vInfo
-
>
dwFileVersionMS
>
>
16
vInfo
-
>
dwFileVersionMS
&
0xFFFF
vInfo
-
>
dwFileVersionLS
>
>
16
vInfo
-
>
dwFileVersionLS
&
0xFFFF
)
;
return
version
;
}
SharedLibraryInfo
SharedLibraryInfo
:
:
GetInfoForSelf
(
)
{
SharedLibraryInfo
sharedLibraryInfo
;
HANDLE
hProcess
=
GetCurrentProcess
(
)
;
mozilla
:
:
UniquePtr
<
HMODULE
[
]
>
hMods
;
size_t
modulesNum
=
0
;
if
(
hProcess
!
=
NULL
)
{
DWORD
modulesSize
;
if
(
!
EnumProcessModules
(
hProcess
nullptr
0
&
modulesSize
)
)
{
return
sharedLibraryInfo
;
}
modulesNum
=
modulesSize
/
sizeof
(
HMODULE
)
;
hMods
=
mozilla
:
:
MakeUnique
<
HMODULE
[
]
>
(
modulesNum
)
;
if
(
!
EnumProcessModules
(
hProcess
hMods
.
get
(
)
modulesNum
*
sizeof
(
HMODULE
)
&
modulesSize
)
)
{
return
sharedLibraryInfo
;
}
if
(
modulesSize
/
sizeof
(
HMODULE
)
<
modulesNum
)
{
modulesNum
=
modulesSize
/
sizeof
(
HMODULE
)
;
}
}
for
(
unsigned
int
i
=
0
;
i
<
modulesNum
;
i
+
+
)
{
nsAutoString
pdbPathStr
;
nsAutoString
pdbNameStr
;
char
*
pdbName
=
NULL
;
WCHAR
modulePath
[
MAX_PATH
+
1
]
;
if
(
!
GetModuleFileNameEx
(
hProcess
hMods
[
i
]
modulePath
sizeof
(
modulePath
)
/
sizeof
(
WCHAR
)
)
)
{
continue
;
}
MODULEINFO
module
=
{
0
}
;
if
(
!
GetModuleInformation
(
hProcess
hMods
[
i
]
&
module
sizeof
(
MODULEINFO
)
)
)
{
continue
;
}
nsCString
breakpadId
;
HMODULE
handleLock
=
LoadLibraryEx
(
modulePath
NULL
LOAD_LIBRARY_AS_DATAFILE
)
;
MEMORY_BASIC_INFORMATION
vmemInfo
=
{
0
}
;
nsID
pdbSig
;
uint32_t
pdbAge
;
if
(
handleLock
&
&
sizeof
(
vmemInfo
)
=
=
VirtualQuery
(
module
.
lpBaseOfDll
&
vmemInfo
sizeof
(
vmemInfo
)
)
&
&
vmemInfo
.
State
=
=
MEM_COMMIT
&
&
GetPdbInfo
(
(
uintptr_t
)
module
.
lpBaseOfDll
pdbSig
pdbAge
&
pdbName
)
)
{
MOZ_ASSERT
(
breakpadId
.
IsEmpty
(
)
)
;
breakpadId
.
AppendPrintf
(
"
%
08X
"
"
%
04X
%
04X
"
"
%
02X
%
02X
%
02X
%
02X
%
02X
%
02X
%
02X
%
02X
"
"
%
X
"
pdbSig
.
m0
pdbSig
.
m1
pdbSig
.
m2
pdbSig
.
m3
[
0
]
pdbSig
.
m3
[
1
]
pdbSig
.
m3
[
2
]
pdbSig
.
m3
[
3
]
pdbSig
.
m3
[
4
]
pdbSig
.
m3
[
5
]
pdbSig
.
m3
[
6
]
pdbSig
.
m3
[
7
]
pdbAge
)
;
pdbPathStr
=
NS_ConvertUTF8toUTF16
(
pdbName
)
;
pdbNameStr
=
pdbPathStr
;
int32_t
pos
=
pdbNameStr
.
RFindChar
(
'
\
\
'
)
;
if
(
pos
!
=
kNotFound
)
{
pdbNameStr
.
Cut
(
0
pos
+
1
)
;
}
}
nsAutoString
modulePathStr
(
modulePath
)
;
nsAutoString
moduleNameStr
=
modulePathStr
;
int32_t
pos
=
moduleNameStr
.
RFindChar
(
'
\
\
'
)
;
if
(
pos
!
=
kNotFound
)
{
moduleNameStr
.
Cut
(
0
pos
+
1
)
;
}
SharedLibrary
shlib
(
(
uintptr_t
)
module
.
lpBaseOfDll
(
uintptr_t
)
module
.
lpBaseOfDll
+
module
.
SizeOfImage
0
breakpadId
moduleNameStr
modulePathStr
pdbNameStr
pdbPathStr
GetVersion
(
modulePath
)
"
"
)
;
sharedLibraryInfo
.
AddSharedLibrary
(
shlib
)
;
FreeLibrary
(
handleLock
)
;
}
return
sharedLibraryInfo
;
}
void
SharedLibraryInfo
:
:
Initialize
(
)
{
}
