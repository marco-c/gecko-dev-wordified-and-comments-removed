#
include
<
stdio
.
h
>
#
include
<
math
.
h
>
#
include
<
pthread
.
h
>
#
if
defined
(
GP_OS_freebsd
)
#
include
<
sys
/
thr
.
h
>
#
endif
#
include
<
semaphore
.
h
>
#
include
<
signal
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
sys
/
resource
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
sched
.
h
>
#
include
<
ucontext
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
unistd
.
h
>
#
include
<
semaphore
.
h
>
#
ifdef
__GLIBC__
#
include
<
execinfo
.
h
>
#
endif
#
include
<
strings
.
h
>
#
include
<
errno
.
h
>
#
include
<
stdarg
.
h
>
#
include
"
prenv
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
#
include
"
common
/
linux
/
breakpad_getcontext
.
h
"
#
endif
#
include
<
string
.
h
>
#
include
<
list
>
using
namespace
mozilla
;
static
void
PopulateRegsFromContext
(
Registers
&
aRegs
ucontext_t
*
aContext
)
{
aRegs
.
mContext
=
aContext
;
mcontext_t
&
mcontext
=
aContext
-
>
uc_mcontext
;
#
if
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
aRegs
.
mPC
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
REG_EIP
]
)
;
aRegs
.
mSP
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
REG_ESP
]
)
;
aRegs
.
mFP
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
REG_EBP
]
)
;
aRegs
.
mLR
=
0
;
#
elif
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_amd64_android
)
aRegs
.
mPC
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
REG_RIP
]
)
;
aRegs
.
mSP
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
REG_RSP
]
)
;
aRegs
.
mFP
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
REG_RBP
]
)
;
aRegs
.
mLR
=
0
;
#
elif
defined
(
GP_PLAT_amd64_freebsd
)
aRegs
.
mPC
=
reinterpret_cast
<
Address
>
(
mcontext
.
mc_rip
)
;
aRegs
.
mSP
=
reinterpret_cast
<
Address
>
(
mcontext
.
mc_rsp
)
;
aRegs
.
mFP
=
reinterpret_cast
<
Address
>
(
mcontext
.
mc_rbp
)
;
aRegs
.
mLR
=
0
;
#
elif
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
aRegs
.
mPC
=
reinterpret_cast
<
Address
>
(
mcontext
.
arm_pc
)
;
aRegs
.
mSP
=
reinterpret_cast
<
Address
>
(
mcontext
.
arm_sp
)
;
aRegs
.
mFP
=
reinterpret_cast
<
Address
>
(
mcontext
.
arm_fp
)
;
aRegs
.
mLR
=
reinterpret_cast
<
Address
>
(
mcontext
.
arm_lr
)
;
#
elif
defined
(
GP_PLAT_arm64_linux
)
|
|
defined
(
GP_PLAT_arm64_android
)
aRegs
.
mPC
=
reinterpret_cast
<
Address
>
(
mcontext
.
pc
)
;
aRegs
.
mSP
=
reinterpret_cast
<
Address
>
(
mcontext
.
sp
)
;
aRegs
.
mFP
=
reinterpret_cast
<
Address
>
(
mcontext
.
regs
[
29
]
)
;
aRegs
.
mLR
=
reinterpret_cast
<
Address
>
(
mcontext
.
regs
[
30
]
)
;
#
elif
defined
(
GP_PLAT_arm64_freebsd
)
aRegs
.
mPC
=
reinterpret_cast
<
Address
>
(
mcontext
.
mc_gpregs
.
gp_elr
)
;
aRegs
.
mSP
=
reinterpret_cast
<
Address
>
(
mcontext
.
mc_gpregs
.
gp_sp
)
;
aRegs
.
mFP
=
reinterpret_cast
<
Address
>
(
mcontext
.
mc_gpregs
.
gp_x
[
29
]
)
;
aRegs
.
mLR
=
reinterpret_cast
<
Address
>
(
mcontext
.
mc_gpregs
.
gp_lr
)
;
#
elif
defined
(
GP_PLAT_mips64_linux
)
|
|
defined
(
GP_PLAT_mips64_android
)
aRegs
.
mPC
=
reinterpret_cast
<
Address
>
(
mcontext
.
pc
)
;
aRegs
.
mSP
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
29
]
)
;
aRegs
.
mFP
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
30
]
)
;
#
else
#
error
"
bad
platform
"
#
endif
}
#
if
defined
(
GP_OS_android
)
#
define
SYS_tgkill
__NR_tgkill
#
endif
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
int
tgkill
(
pid_t
tgid
pid_t
tid
int
signalno
)
{
return
syscall
(
SYS_tgkill
tgid
tid
signalno
)
;
}
#
endif
#
if
defined
(
GP_OS_freebsd
)
#
define
tgkill
thr_kill2
#
endif
class
PlatformData
{
public
:
explicit
PlatformData
(
ProfilerThreadId
aThreadId
)
{
MOZ_ASSERT
(
aThreadId
=
=
profiler_current_thread_id
(
)
)
;
MOZ_COUNT_CTOR
(
PlatformData
)
;
if
(
clockid_t
clockid
;
pthread_getcpuclockid
(
pthread_self
(
)
&
clockid
)
=
=
0
)
{
mClockId
=
Some
(
clockid
)
;
}
}
MOZ_COUNTED_DTOR
(
PlatformData
)
Maybe
<
clockid_t
>
GetClockId
(
)
const
{
return
mClockId
;
}
RunningTimes
&
PreviousThreadRunningTimesRef
(
)
{
return
mPreviousThreadRunningTimes
;
}
private
:
Maybe
<
clockid_t
>
mClockId
;
RunningTimes
mPreviousThreadRunningTimes
;
}
;
mozilla
:
:
profiler
:
:
PlatformData
:
:
PlatformData
(
ProfilerThreadId
aThreadId
)
{
MOZ_ASSERT
(
aThreadId
=
=
profiler_current_thread_id
(
)
)
;
if
(
clockid_t
clockid
;
pthread_getcpuclockid
(
pthread_self
(
)
&
clockid
)
=
=
0
)
{
mClockId
=
Some
(
clockid
)
;
}
}
mozilla
:
:
profiler
:
:
PlatformData
:
:
~
PlatformData
(
)
=
default
;
struct
SigHandlerCoordinator
{
SigHandlerCoordinator
(
)
{
PodZero
(
&
mUContext
)
;
int
r
=
sem_init
(
&
mMessage2
0
0
)
;
r
|
=
sem_init
(
&
mMessage3
0
0
)
;
r
|
=
sem_init
(
&
mMessage4
0
0
)
;
MOZ_ASSERT
(
r
=
=
0
)
;
}
~
SigHandlerCoordinator
(
)
{
int
r
=
sem_destroy
(
&
mMessage2
)
;
r
|
=
sem_destroy
(
&
mMessage3
)
;
r
|
=
sem_destroy
(
&
mMessage4
)
;
MOZ_ASSERT
(
r
=
=
0
)
;
}
sem_t
mMessage2
;
sem_t
mMessage3
;
sem_t
mMessage4
;
ucontext_t
mUContext
;
}
;
struct
SigHandlerCoordinator
*
Sampler
:
:
sSigHandlerCoordinator
=
nullptr
;
static
void
SigprofHandler
(
int
aSignal
siginfo_t
*
aInfo
void
*
aContext
)
{
int
savedErrno
=
errno
;
MOZ_ASSERT
(
aSignal
=
=
SIGPROF
)
;
MOZ_ASSERT
(
Sampler
:
:
sSigHandlerCoordinator
)
;
Sampler
:
:
sSigHandlerCoordinator
-
>
mUContext
=
*
static_cast
<
ucontext_t
*
>
(
aContext
)
;
int
r
=
sem_post
(
&
Sampler
:
:
sSigHandlerCoordinator
-
>
mMessage2
)
;
MOZ_ASSERT
(
r
=
=
0
)
;
while
(
true
)
{
r
=
sem_wait
(
&
Sampler
:
:
sSigHandlerCoordinator
-
>
mMessage3
)
;
if
(
r
=
=
-
1
&
&
errno
=
=
EINTR
)
{
continue
;
}
MOZ_ASSERT
(
r
=
=
0
)
;
break
;
}
r
=
sem_post
(
&
Sampler
:
:
sSigHandlerCoordinator
-
>
mMessage4
)
;
MOZ_ASSERT
(
r
=
=
0
)
;
errno
=
savedErrno
;
}
Sampler
:
:
Sampler
(
PSLockRef
aLock
)
:
mMyPid
(
profiler_current_process_id
(
)
)
mSamplerTid
{
}
{
#
if
defined
(
USE_EHABI_STACKWALK
)
mozilla
:
:
EHABIStackWalkInit
(
)
;
#
endif
struct
sigaction
sa
;
sa
.
sa_sigaction
=
SigprofHandler
;
sigemptyset
(
&
sa
.
sa_mask
)
;
sa
.
sa_flags
=
SA_RESTART
|
SA_SIGINFO
;
if
(
sigaction
(
SIGPROF
&
sa
&
mOldSigprofHandler
)
!
=
0
)
{
MOZ_CRASH
(
"
Error
installing
SIGPROF
handler
in
the
profiler
"
)
;
}
}
void
Sampler
:
:
Disable
(
PSLockRef
aLock
)
{
sigaction
(
SIGPROF
&
mOldSigprofHandler
0
)
;
}
static
void
StreamMetaPlatformSampleUnits
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
aWriter
.
StringProperty
(
"
threadCPUDelta
"
"
ns
"
)
;
}
static
RunningTimes
GetThreadRunningTimesDiff
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
)
{
AUTO_PROFILER_STATS
(
GetRunningTimes_clock_gettime_thread
)
;
PlatformData
*
platformData
=
aRegisteredThread
.
GetPlatformData
(
)
;
MOZ_RELEASE_ASSERT
(
platformData
)
;
Maybe
<
clockid_t
>
maybeCid
=
platformData
-
>
GetClockId
(
)
;
if
(
MOZ_UNLIKELY
(
!
maybeCid
)
)
{
RunningTimes
emptyRunningTimes
;
emptyRunningTimes
.
SetPostMeasurementTimeStamp
(
TimeStamp
:
:
Now
(
)
)
;
return
emptyRunningTimes
;
}
const
RunningTimes
newRunningTimes
=
GetRunningTimesWithTightTimestamp
(
[
cid
=
*
maybeCid
]
(
RunningTimes
&
aRunningTimes
)
{
AUTO_PROFILER_STATS
(
GetRunningTimes_clock_gettime
)
;
if
(
timespec
ts
;
clock_gettime
(
cid
&
ts
)
=
=
0
)
{
aRunningTimes
.
ResetThreadCPUDelta
(
uint64_t
(
ts
.
tv_sec
)
*
1
'
000
'
000
'
000u
+
uint64_t
(
ts
.
tv_nsec
)
)
;
}
else
{
aRunningTimes
.
ClearThreadCPUDelta
(
)
;
}
}
)
;
const
RunningTimes
diff
=
newRunningTimes
-
platformData
-
>
PreviousThreadRunningTimesRef
(
)
;
platformData
-
>
PreviousThreadRunningTimesRef
(
)
=
newRunningTimes
;
return
diff
;
}
static
void
ClearThreadRunningTimes
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
)
{
PlatformData
*
const
platformData
=
aRegisteredThread
.
GetPlatformData
(
)
;
MOZ_RELEASE_ASSERT
(
platformData
)
;
platformData
-
>
PreviousThreadRunningTimesRef
(
)
.
Clear
(
)
;
}
template
<
typename
Func
>
void
Sampler
:
:
SuspendAndSampleAndResumeThread
(
PSLockRef
aLock
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
TimeStamp
&
aNow
const
Func
&
aProcessRegs
)
{
MOZ_ASSERT
(
!
sSigHandlerCoordinator
)
;
if
(
!
mSamplerTid
.
IsSpecified
(
)
)
{
mSamplerTid
=
profiler_current_thread_id
(
)
;
}
ProfilerThreadId
sampleeTid
=
aThreadData
.
Info
(
)
.
ThreadId
(
)
;
MOZ_RELEASE_ASSERT
(
sampleeTid
!
=
mSamplerTid
)
;
SigHandlerCoordinator
coord
;
sSigHandlerCoordinator
=
&
coord
;
int
r
=
tgkill
(
mMyPid
.
ToNumber
(
)
sampleeTid
.
ToNumber
(
)
SIGPROF
)
;
if
(
r
=
=
0
)
{
while
(
true
)
{
r
=
sem_wait
(
&
sSigHandlerCoordinator
-
>
mMessage2
)
;
if
(
r
=
=
-
1
&
&
errno
=
=
EINTR
)
{
continue
;
}
MOZ_ASSERT
(
r
=
=
0
)
;
break
;
}
Registers
regs
;
PopulateRegsFromContext
(
regs
&
sSigHandlerCoordinator
-
>
mUContext
)
;
aProcessRegs
(
regs
aNow
)
;
r
=
sem_post
(
&
sSigHandlerCoordinator
-
>
mMessage3
)
;
MOZ_ASSERT
(
r
=
=
0
)
;
while
(
true
)
{
r
=
sem_wait
(
&
sSigHandlerCoordinator
-
>
mMessage4
)
;
if
(
r
=
=
-
1
&
&
errno
=
=
EINTR
)
{
continue
;
}
MOZ_ASSERT
(
r
=
=
0
)
;
break
;
}
}
sSigHandlerCoordinator
=
nullptr
;
}
static
void
*
ThreadEntry
(
void
*
aArg
)
{
auto
thread
=
static_cast
<
SamplerThread
*
>
(
aArg
)
;
thread
-
>
Run
(
)
;
return
nullptr
;
}
SamplerThread
:
:
SamplerThread
(
PSLockRef
aLock
uint32_t
aActivityGeneration
double
aIntervalMilliseconds
bool
aStackWalkEnabled
bool
aNoTimerResolutionChange
)
:
mSampler
(
aLock
)
mActivityGeneration
(
aActivityGeneration
)
mIntervalMicroseconds
(
std
:
:
max
(
1
int
(
floor
(
aIntervalMilliseconds
*
1000
+
0
.
5
)
)
)
)
{
#
if
defined
(
USE_LUL_STACKWALK
)
lul
:
:
LUL
*
lul
=
CorePS
:
:
Lul
(
aLock
)
;
if
(
!
lul
&
&
aStackWalkEnabled
)
{
CorePS
:
:
SetLul
(
aLock
MakeUnique
<
lul
:
:
LUL
>
(
logging_sink_for_LUL
)
)
;
lul
=
CorePS
:
:
Lul
(
aLock
)
;
read_procmaps
(
lul
)
;
lul
-
>
EnableUnwinding
(
)
;
if
(
PR_GetEnv
(
"
MOZ_PROFILER_LUL_TEST
"
)
)
{
int
nTests
=
0
nTestsPassed
=
0
;
RunLulUnitTests
(
&
nTests
&
nTestsPassed
lul
)
;
}
}
#
endif
pthread_attr_t
attr
;
if
(
pthread_attr_init
(
&
attr
)
!
=
0
|
|
pthread_attr_setstacksize
(
&
attr
800
*
1024
)
!
=
0
|
|
pthread_create
(
&
mThread
&
attr
ThreadEntry
this
)
!
=
0
)
{
MOZ_CRASH
(
"
pthread_create
failed
"
)
;
}
pthread_attr_destroy
(
&
attr
)
;
}
SamplerThread
:
:
~
SamplerThread
(
)
{
pthread_join
(
mThread
nullptr
)
;
InvokePostSamplingCallbacks
(
std
:
:
move
(
mPostSamplingCallbackList
)
SamplingState
:
:
JustStopped
)
;
}
void
SamplerThread
:
:
SleepMicro
(
uint32_t
aMicroseconds
)
{
if
(
aMicroseconds
>
=
1000000
)
{
MOZ_ALWAYS_TRUE
(
!
:
:
usleep
(
aMicroseconds
)
)
;
return
;
}
struct
timespec
ts
;
ts
.
tv_sec
=
0
;
ts
.
tv_nsec
=
aMicroseconds
*
1000UL
;
int
rv
=
:
:
nanosleep
(
&
ts
&
ts
)
;
while
(
rv
!
=
0
&
&
errno
=
=
EINTR
)
{
rv
=
:
:
nanosleep
(
&
ts
&
ts
)
;
}
MOZ_ASSERT
(
!
rv
"
nanosleep
call
failed
"
)
;
}
void
SamplerThread
:
:
Stop
(
PSLockRef
aLock
)
{
mSampler
.
Disable
(
aLock
)
;
}
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_freebsd
)
static
void
paf_prepare
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
SetWasSamplingPaused
(
lock
ActivePS
:
:
IsSamplingPaused
(
lock
)
)
;
ActivePS
:
:
SetIsSamplingPaused
(
lock
true
)
;
}
}
static
void
paf_parent
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
SetIsSamplingPaused
(
lock
ActivePS
:
:
WasSamplingPaused
(
lock
)
)
;
ActivePS
:
:
SetWasSamplingPaused
(
lock
false
)
;
}
}
static
void
PlatformInit
(
PSLockRef
aLock
)
{
pthread_atfork
(
paf_prepare
paf_parent
nullptr
)
;
}
#
else
static
void
PlatformInit
(
PSLockRef
aLock
)
{
}
#
endif
#
if
defined
(
HAVE_NATIVE_UNWIND
)
ucontext_t
sSyncUContext
;
void
Registers
:
:
SyncPopulate
(
)
{
if
(
!
getcontext
(
&
sSyncUContext
)
)
{
PopulateRegsFromContext
(
*
this
&
sSyncUContext
)
;
}
}
#
endif
