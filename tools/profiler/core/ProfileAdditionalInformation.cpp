#
include
"
ProfileAdditionalInformation
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
JSON
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
mozilla
/
JSONStringWriteFuncs
.
h
"
#
include
"
mozilla
/
ipc
/
IPDLParamTraits
.
h
"
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
platform
.
h
"
void
mozilla
:
:
ProfileGenerationAdditionalInformation
:
:
ToJSValue
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetVal
)
const
{
JS
:
:
Rooted
<
JS
:
:
Value
>
sharedLibrariesVal
(
aCx
)
;
{
JSONStringWriteFunc
<
nsCString
>
buffer
;
JSONWriter
w
(
buffer
JSONWriter
:
:
SingleLineStyle
)
;
w
.
StartArrayElement
(
)
;
AppendSharedLibraries
(
w
mSharedLibraries
)
;
w
.
EndArray
(
)
;
NS_ConvertUTF8toUTF16
buffer16
(
buffer
.
StringCRef
(
)
)
;
MOZ_ALWAYS_TRUE
(
JS_ParseJSON
(
aCx
static_cast
<
const
char16_t
*
>
(
buffer16
.
get
(
)
)
buffer16
.
Length
(
)
&
sharedLibrariesVal
)
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
additionalInfoObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
JS_SetProperty
(
aCx
additionalInfoObj
"
sharedLibraries
"
sharedLibrariesVal
)
;
aRetVal
.
setObject
(
*
additionalInfoObj
)
;
}
#
endif
namespace
IPC
{
template
<
>
struct
ParamTraits
<
SharedLibrary
>
{
typedef
SharedLibrary
paramType
;
static
void
Write
(
MessageWriter
*
aWriter
const
paramType
&
aParam
)
;
static
bool
Read
(
MessageReader
*
aReader
paramType
*
aResult
)
;
}
;
template
<
>
struct
ParamTraits
<
SharedLibraryInfo
>
{
typedef
SharedLibraryInfo
paramType
;
static
void
Write
(
MessageWriter
*
aWriter
const
paramType
&
aParam
)
;
static
bool
Read
(
MessageReader
*
aReader
paramType
*
aResult
)
;
}
;
template
<
>
struct
ParamTraits
<
ProfilerJSSourceData
>
{
typedef
ProfilerJSSourceData
paramType
;
static
void
Write
(
MessageWriter
*
aWriter
const
paramType
&
aParam
)
;
static
bool
Read
(
MessageReader
*
aReader
paramType
*
aResult
)
;
}
;
void
IPC
:
:
ParamTraits
<
SharedLibrary
>
:
:
Write
(
MessageWriter
*
aWriter
const
paramType
&
aParam
)
{
WriteParam
(
aWriter
aParam
.
mStart
)
;
WriteParam
(
aWriter
aParam
.
mEnd
)
;
WriteParam
(
aWriter
aParam
.
mOffset
)
;
WriteParam
(
aWriter
aParam
.
mBreakpadId
)
;
WriteParam
(
aWriter
aParam
.
mCodeId
)
;
WriteParam
(
aWriter
aParam
.
mModuleName
)
;
WriteParam
(
aWriter
aParam
.
mModulePath
)
;
WriteParam
(
aWriter
aParam
.
mDebugName
)
;
WriteParam
(
aWriter
aParam
.
mDebugPath
)
;
WriteParam
(
aWriter
aParam
.
mVersion
)
;
WriteParam
(
aWriter
aParam
.
mArch
)
;
}
bool
IPC
:
:
ParamTraits
<
SharedLibrary
>
:
:
Read
(
MessageReader
*
aReader
paramType
*
aResult
)
{
return
ReadParam
(
aReader
&
aResult
-
>
mStart
)
&
&
ReadParam
(
aReader
&
aResult
-
>
mEnd
)
&
&
ReadParam
(
aReader
&
aResult
-
>
mOffset
)
&
&
ReadParam
(
aReader
&
aResult
-
>
mBreakpadId
)
&
&
ReadParam
(
aReader
&
aResult
-
>
mCodeId
)
&
&
ReadParam
(
aReader
&
aResult
-
>
mModuleName
)
&
&
ReadParam
(
aReader
&
aResult
-
>
mModulePath
)
&
&
ReadParam
(
aReader
&
aResult
-
>
mDebugName
)
&
&
ReadParam
(
aReader
&
aResult
-
>
mDebugPath
)
&
&
ReadParam
(
aReader
&
aResult
-
>
mVersion
)
&
&
ReadParam
(
aReader
&
aResult
-
>
mArch
)
;
}
void
IPC
:
:
ParamTraits
<
SharedLibraryInfo
>
:
:
Write
(
MessageWriter
*
aWriter
const
paramType
&
aParam
)
{
paramType
&
p
=
const_cast
<
paramType
&
>
(
aParam
)
;
WriteParam
(
aWriter
p
.
mEntries
)
;
}
bool
IPC
:
:
ParamTraits
<
SharedLibraryInfo
>
:
:
Read
(
MessageReader
*
aReader
paramType
*
aResult
)
{
return
ReadParam
(
aReader
&
aResult
-
>
mEntries
)
;
}
constexpr
uint8_t
kSourceTextUTF16Tag
=
0
;
constexpr
uint8_t
kSourceTextUTF8Tag
=
1
;
constexpr
uint8_t
kRetrievableFileTag
=
2
;
constexpr
uint8_t
kUnavailableTag
=
3
;
void
IPC
:
:
ParamTraits
<
ProfilerJSSourceData
>
:
:
Write
(
MessageWriter
*
aWriter
const
paramType
&
aParam
)
{
WriteParam
(
aWriter
aParam
.
sourceId
(
)
)
;
WriteParam
(
aWriter
aParam
.
filePathLength
(
)
)
;
if
(
aParam
.
filePathLength
(
)
>
0
)
{
aWriter
-
>
WriteBytes
(
aParam
.
filePath
(
)
aParam
.
filePathLength
(
)
*
sizeof
(
char
)
)
;
}
aParam
.
data
(
)
.
match
(
[
&
]
(
const
ProfilerJSSourceData
:
:
SourceTextUTF16
&
srcText
)
{
WriteParam
(
aWriter
kSourceTextUTF16Tag
)
;
WriteParam
(
aWriter
srcText
.
length
(
)
)
;
if
(
srcText
.
length
(
)
>
0
)
{
aWriter
-
>
WriteBytes
(
srcText
.
chars
(
)
.
get
(
)
srcText
.
length
(
)
*
sizeof
(
char16_t
)
)
;
}
}
[
&
]
(
const
ProfilerJSSourceData
:
:
SourceTextUTF8
&
srcText
)
{
WriteParam
(
aWriter
kSourceTextUTF8Tag
)
;
WriteParam
(
aWriter
srcText
.
length
(
)
)
;
if
(
srcText
.
length
(
)
>
0
)
{
aWriter
-
>
WriteBytes
(
srcText
.
chars
(
)
.
get
(
)
srcText
.
length
(
)
*
sizeof
(
char
)
)
;
}
}
[
&
]
(
const
ProfilerJSSourceData
:
:
RetrievableFile
&
)
{
WriteParam
(
aWriter
kRetrievableFileTag
)
;
}
[
&
]
(
const
ProfilerJSSourceData
:
:
Unavailable
&
)
{
WriteParam
(
aWriter
kUnavailableTag
)
;
}
)
;
}
bool
IPC
:
:
ParamTraits
<
ProfilerJSSourceData
>
:
:
Read
(
MessageReader
*
aReader
paramType
*
aResult
)
{
uint32_t
sourceId
;
size_t
pathLength
;
if
(
!
ReadParam
(
aReader
&
sourceId
)
|
|
!
ReadParam
(
aReader
&
pathLength
)
)
{
return
false
;
}
JS
:
:
UniqueChars
filePath
;
if
(
pathLength
>
0
)
{
char
*
chars
=
static_cast
<
char
*
>
(
js_malloc
(
(
pathLength
+
1
)
*
sizeof
(
char
)
)
)
;
if
(
!
chars
|
|
!
aReader
-
>
ReadBytesInto
(
chars
pathLength
*
sizeof
(
char
)
)
)
{
js_free
(
chars
)
;
return
false
;
}
chars
[
pathLength
]
=
'
\
0
'
;
filePath
.
reset
(
chars
)
;
}
uint8_t
typeTag
;
if
(
!
ReadParam
(
aReader
&
typeTag
)
)
{
return
false
;
}
switch
(
typeTag
)
{
case
kSourceTextUTF16Tag
:
{
size_t
length
;
if
(
!
ReadParam
(
aReader
&
length
)
)
{
return
false
;
}
if
(
length
>
0
)
{
char16_t
*
chars
=
static_cast
<
char16_t
*
>
(
js_malloc
(
(
length
+
1
)
*
sizeof
(
char16_t
)
)
)
;
if
(
!
chars
|
|
!
aReader
-
>
ReadBytesInto
(
chars
length
*
sizeof
(
char16_t
)
)
)
{
js_free
(
chars
)
;
return
false
;
}
chars
[
length
]
=
u
'
\
0
'
;
*
aResult
=
ProfilerJSSourceData
(
sourceId
JS
:
:
UniqueTwoByteChars
(
chars
)
length
std
:
:
move
(
filePath
)
pathLength
)
;
}
else
{
*
aResult
=
ProfilerJSSourceData
(
sourceId
JS
:
:
UniqueTwoByteChars
(
)
0
std
:
:
move
(
filePath
)
pathLength
)
;
}
return
true
;
}
case
kSourceTextUTF8Tag
:
{
size_t
length
;
if
(
!
ReadParam
(
aReader
&
length
)
)
{
return
false
;
}
if
(
length
>
0
)
{
char
*
chars
=
static_cast
<
char
*
>
(
js_malloc
(
(
length
+
1
)
*
sizeof
(
char
)
)
)
;
if
(
!
chars
|
|
!
aReader
-
>
ReadBytesInto
(
chars
length
*
sizeof
(
char
)
)
)
{
js_free
(
chars
)
;
return
false
;
}
chars
[
length
]
=
'
\
0
'
;
*
aResult
=
ProfilerJSSourceData
(
sourceId
JS
:
:
UniqueChars
(
chars
)
length
std
:
:
move
(
filePath
)
pathLength
)
;
}
else
{
*
aResult
=
ProfilerJSSourceData
(
sourceId
JS
:
:
UniqueChars
(
)
0
std
:
:
move
(
filePath
)
pathLength
)
;
}
return
true
;
}
case
kRetrievableFileTag
:
{
*
aResult
=
ProfilerJSSourceData
:
:
CreateRetrievableFile
(
sourceId
std
:
:
move
(
filePath
)
pathLength
)
;
return
true
;
}
case
kUnavailableTag
:
{
*
aResult
=
ProfilerJSSourceData
(
sourceId
std
:
:
move
(
filePath
)
pathLength
)
;
return
true
;
}
default
:
return
false
;
}
}
void
IPC
:
:
ParamTraits
<
mozilla
:
:
ProfileGenerationAdditionalInformation
>
:
:
Write
(
MessageWriter
*
aWriter
const
paramType
&
aParam
)
{
WriteParam
(
aWriter
aParam
.
mSharedLibraries
)
;
}
bool
IPC
:
:
ParamTraits
<
mozilla
:
:
ProfileGenerationAdditionalInformation
>
:
:
Read
(
MessageReader
*
aReader
paramType
*
aResult
)
{
return
ReadParam
(
aReader
&
aResult
-
>
mSharedLibraries
)
;
}
}
