#
include
"
ProfilerCodeAddressService
.
h
"
#
include
"
platform
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
using
namespace
mozilla
;
#
ifdef
XP_LINUX
static
char
*
SearchSymbolTable
(
SymbolTable
&
aTable
uint32_t
aOffset
)
{
size_t
index
;
bool
exact
=
BinarySearch
(
aTable
.
mAddrs
0
aTable
.
mAddrs
.
Length
(
)
aOffset
&
index
)
;
if
(
index
=
=
0
&
&
!
exact
)
{
return
nullptr
;
}
auto
strings
=
reinterpret_cast
<
char
*
>
(
aTable
.
mBuffer
.
Elements
(
)
)
;
nsCString
symbol
;
symbol
.
Append
(
strings
+
aTable
.
mIndex
[
index
-
1
]
aTable
.
mIndex
[
index
]
-
aTable
.
mIndex
[
index
-
1
]
)
;
char
demangled
[
1024
]
;
if
(
!
profiler_demangle_rust
(
symbol
.
get
(
)
demangled
ArrayLength
(
demangled
)
)
)
{
DemangleSymbol
(
symbol
.
get
(
)
demangled
ArrayLength
(
demangled
)
)
;
}
demangled
[
ArrayLength
(
demangled
)
-
1
]
=
'
\
0
'
;
return
strdup
(
demangled
[
0
]
!
=
'
\
0
'
?
demangled
:
symbol
.
get
(
)
)
;
}
#
endif
bool
ProfilerCodeAddressService
:
:
GetFunction
(
const
void
*
aPc
nsACString
&
aResult
)
{
Entry
&
entry
=
GetEntry
(
aPc
)
;
#
ifdef
XP_LINUX
if
(
entry
.
mLOffset
<
=
0xFFFFFFFF
&
&
!
entry
.
mFunction
)
{
auto
p
=
mSymbolTables
.
lookupForAdd
(
entry
.
mLibrary
)
;
if
(
!
p
)
{
if
(
!
mSymbolTables
.
add
(
p
entry
.
mLibrary
SymbolTable
(
)
)
)
{
MOZ_CRASH
(
"
ProfilerCodeAddressService
OOM
"
)
;
}
profiler_get_symbol_table
(
entry
.
mLibrary
nullptr
&
p
-
>
value
(
)
)
;
}
entry
.
mFunction
=
SearchSymbolTable
(
p
-
>
value
(
)
static_cast
<
uint32_t
>
(
entry
.
mLOffset
)
)
;
}
#
endif
if
(
!
entry
.
mFunction
|
|
entry
.
mFunction
[
0
]
=
=
'
\
0
'
)
{
return
false
;
}
aResult
=
nsDependentCString
(
entry
.
mFunction
)
;
return
true
;
}
