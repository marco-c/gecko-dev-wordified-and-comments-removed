#
ifndef
GeckoSampler_h
#
define
GeckoSampler_h
#
include
"
platform
.
h
"
#
include
"
ProfileEntry
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
ThreadProfile
.
h
"
#
include
"
ThreadInfo
.
h
"
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
#
endif
#
include
<
algorithm
>
namespace
mozilla
{
class
ProfileGatherer
;
}
typedef
mozilla
:
:
Vector
<
std
:
:
string
>
ThreadNameFilterList
;
typedef
mozilla
:
:
Vector
<
std
:
:
string
>
FeatureList
;
static
bool
threadSelected
(
ThreadInfo
*
aInfo
const
ThreadNameFilterList
&
aThreadNameFilters
)
{
if
(
aThreadNameFilters
.
empty
(
)
)
{
return
true
;
}
std
:
:
string
name
=
aInfo
-
>
Name
(
)
;
std
:
:
transform
(
name
.
begin
(
)
name
.
end
(
)
name
.
begin
(
)
:
:
tolower
)
;
for
(
uint32_t
i
=
0
;
i
<
aThreadNameFilters
.
length
(
)
;
+
+
i
)
{
std
:
:
string
filter
=
aThreadNameFilters
[
i
]
;
std
:
:
transform
(
filter
.
begin
(
)
filter
.
end
(
)
filter
.
begin
(
)
:
:
tolower
)
;
if
(
name
.
find
(
filter
)
!
=
std
:
:
string
:
:
npos
)
{
return
true
;
}
}
return
false
;
}
extern
mozilla
:
:
TimeStamp
sLastTracerEvent
;
extern
int
sFrameNumber
;
extern
int
sLastFrameNumber
;
class
GeckoSampler
:
public
Sampler
{
public
:
GeckoSampler
(
double
aInterval
int
aEntrySize
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
*
aThreadNameFilters
uint32_t
aFilterCount
)
;
~
GeckoSampler
(
)
;
void
RegisterThread
(
ThreadInfo
*
aInfo
)
{
if
(
!
aInfo
-
>
IsMainThread
(
)
&
&
!
mProfileThreads
)
{
return
;
}
if
(
!
threadSelected
(
aInfo
mThreadNameFilters
)
)
{
return
;
}
aInfo
-
>
SetProfile
(
mozilla
:
:
MakeUnique
<
ThreadProfile
>
(
aInfo
mBuffer
)
)
;
}
virtual
void
Tick
(
TickSample
*
sample
)
override
;
virtual
SyncProfile
*
GetBacktrace
(
)
override
;
virtual
void
RequestSave
(
)
override
{
mSaveRequested
=
true
;
}
virtual
void
HandleSaveRequest
(
)
override
;
virtual
void
DeleteExpiredMarkers
(
)
override
;
void
ToStreamAsJSON
(
std
:
:
ostream
&
stream
double
aSinceTime
=
0
)
;
virtual
JSObject
*
ToJSObject
(
JSContext
*
aCx
double
aSinceTime
=
0
)
;
void
GetGatherer
(
nsISupports
*
*
aRetVal
)
;
mozilla
:
:
UniquePtr
<
char
[
]
>
ToJSON
(
double
aSinceTime
=
0
)
;
virtual
void
ToJSObjectAsync
(
double
aSinceTime
=
0
mozilla
:
:
dom
:
:
Promise
*
aPromise
=
0
)
;
void
ToFileAsync
(
const
nsACString
&
aFileName
double
aSinceTime
=
0
)
;
void
StreamMetaJSCustomObject
(
SpliceableJSONWriter
&
aWriter
)
;
void
StreamTaskTracer
(
SpliceableJSONWriter
&
aWriter
)
;
void
FlushOnJSShutdown
(
JSContext
*
aContext
)
;
bool
ProfileJS
(
)
const
{
return
mProfileJS
;
}
bool
ProfileJava
(
)
const
{
return
mProfileJava
;
}
bool
ProfileGPU
(
)
const
{
return
mProfileGPU
;
}
bool
ProfileThreads
(
)
const
override
{
return
mProfileThreads
;
}
bool
InPrivacyMode
(
)
const
{
return
mPrivacyMode
;
}
bool
AddMainThreadIO
(
)
const
{
return
mAddMainThreadIO
;
}
bool
ProfileMemory
(
)
const
{
return
mProfileMemory
;
}
bool
TaskTracer
(
)
const
{
return
mTaskTracer
;
}
bool
LayersDump
(
)
const
{
return
mLayersDump
;
}
bool
DisplayListDump
(
)
const
{
return
mDisplayListDump
;
}
bool
ProfileRestyle
(
)
const
{
return
mProfileRestyle
;
}
const
ThreadNameFilterList
&
ThreadNameFilters
(
)
{
return
mThreadNameFilters
;
}
const
FeatureList
&
Features
(
)
{
return
mFeatures
;
}
void
GetBufferInfo
(
uint32_t
*
aCurrentPosition
uint32_t
*
aTotalSize
uint32_t
*
aGeneration
)
;
protected
:
virtual
void
InplaceTick
(
TickSample
*
sample
)
;
void
doNativeBacktrace
(
ThreadProfile
&
aProfile
TickSample
*
aSample
)
;
void
StreamJSON
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
)
;
RefPtr
<
ProfileBuffer
>
mBuffer
;
bool
mSaveRequested
;
bool
mAddLeafAddresses
;
bool
mUseStackWalk
;
bool
mProfileJS
;
bool
mProfileGPU
;
bool
mProfileThreads
;
bool
mProfileJava
;
bool
mLayersDump
;
bool
mDisplayListDump
;
bool
mProfileRestyle
;
ThreadNameFilterList
mThreadNameFilters
;
FeatureList
mFeatures
;
bool
mPrivacyMode
;
bool
mAddMainThreadIO
;
bool
mProfileMemory
;
bool
mTaskTracer
;
private
:
RefPtr
<
mozilla
:
:
ProfileGatherer
>
mGatherer
;
}
;
#
endif
