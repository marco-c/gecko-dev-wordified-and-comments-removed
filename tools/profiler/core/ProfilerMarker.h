#
ifndef
ProfilerMarker_h
#
define
ProfilerMarker_h
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
ProfilerMarkerPayload
.
h
"
template
<
typename
T
>
class
ProfilerLinkedList
;
class
SpliceableJSONWriter
;
class
UniqueStacks
;
class
ProfilerMarker
{
friend
class
ProfilerLinkedList
<
ProfilerMarker
>
;
public
:
explicit
ProfilerMarker
(
const
char
*
aMarkerName
mozilla
:
:
UniquePtr
<
ProfilerMarkerPayload
>
aPayload
=
nullptr
double
aTime
=
0
)
:
mMarkerName
(
strdup
(
aMarkerName
)
)
mPayload
(
Move
(
aPayload
)
)
mTime
(
aTime
)
{
}
void
SetGeneration
(
uint32_t
aGenID
)
{
mGenID
=
aGenID
;
}
bool
HasExpired
(
uint32_t
aGenID
)
const
{
return
mGenID
+
2
<
=
aGenID
;
}
double
GetTime
(
)
const
{
return
mTime
;
}
void
StreamJSON
(
SpliceableJSONWriter
&
aWriter
const
mozilla
:
:
TimeStamp
&
aProcessStartTime
UniqueStacks
&
aUniqueStacks
)
const
{
aWriter
.
StartArrayElement
(
)
;
{
aUniqueStacks
.
mUniqueStrings
.
WriteElement
(
aWriter
mMarkerName
.
get
(
)
)
;
aWriter
.
DoubleElement
(
mTime
)
;
if
(
mPayload
)
{
aWriter
.
StartObjectElement
(
)
;
{
mPayload
-
>
StreamPayload
(
aWriter
aProcessStartTime
aUniqueStacks
)
;
}
aWriter
.
EndObject
(
)
;
}
}
aWriter
.
EndArray
(
)
;
}
private
:
mozilla
:
:
UniqueFreePtr
<
char
>
mMarkerName
;
mozilla
:
:
UniquePtr
<
ProfilerMarkerPayload
>
mPayload
;
ProfilerMarker
*
mNext
;
double
mTime
;
uint32_t
mGenID
;
}
;
template
<
typename
T
>
class
ProfilerLinkedList
{
public
:
ProfilerLinkedList
(
)
:
mHead
(
nullptr
)
mTail
(
nullptr
)
{
}
void
insert
(
T
*
aElem
)
{
if
(
!
mTail
)
{
mHead
=
aElem
;
mTail
=
aElem
;
}
else
{
mTail
-
>
mNext
=
aElem
;
mTail
=
aElem
;
}
aElem
-
>
mNext
=
nullptr
;
}
T
*
popHead
(
)
{
if
(
!
mHead
)
{
MOZ_ASSERT
(
false
)
;
return
nullptr
;
}
T
*
head
=
mHead
;
mHead
=
head
-
>
mNext
;
if
(
!
mHead
)
{
mTail
=
nullptr
;
}
return
head
;
}
const
T
*
peek
(
)
{
return
mHead
;
}
private
:
T
*
mHead
;
T
*
mTail
;
}
;
typedef
ProfilerLinkedList
<
ProfilerMarker
>
ProfilerMarkerLinkedList
;
template
<
typename
T
>
class
ProfilerSignalSafeLinkedList
{
public
:
ProfilerSignalSafeLinkedList
(
)
:
mSignalLock
(
false
)
{
}
~
ProfilerSignalSafeLinkedList
(
)
{
if
(
mSignalLock
)
{
abort
(
)
;
}
while
(
mList
.
peek
(
)
)
{
delete
mList
.
popHead
(
)
;
}
}
void
insert
(
T
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
mSignalLock
=
true
;
mList
.
insert
(
aElement
)
;
mSignalLock
=
false
;
}
ProfilerLinkedList
<
T
>
*
accessList
(
)
{
return
mSignalLock
?
nullptr
:
&
mList
;
}
private
:
ProfilerLinkedList
<
T
>
mList
;
mozilla
:
:
Atomic
<
bool
>
mSignalLock
;
}
;
#
endif
