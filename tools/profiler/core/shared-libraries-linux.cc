#
include
"
shared
-
libraries
.
h
"
#
define
PATH_MAX_TOSTRING
(
x
)
#
x
#
define
PATH_MAX_STRING
(
x
)
PATH_MAX_TOSTRING
(
x
)
#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
limits
.
h
>
#
include
<
unistd
.
h
>
#
include
<
fstream
>
#
include
"
platform
.
h
"
#
include
"
shared
-
libraries
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
common
/
linux
/
file_id
.
h
"
#
include
<
algorithm
>
#
include
<
dlfcn
.
h
>
#
include
<
features
.
h
>
#
include
<
sys
/
types
.
h
>
#
if
defined
(
GP_OS_linux
)
#
include
<
link
.
h
>
#
elif
defined
(
GP_OS_android
)
#
include
"
ElfLoader
.
h
"
extern
"
C
"
MOZ_EXPORT
__attribute__
(
(
weak
)
)
int
dl_iterate_phdr
(
int
(
*
callback
)
(
struct
dl_phdr_info
*
info
size_t
size
void
*
data
)
void
*
data
)
;
#
else
#
error
"
Unexpected
configuration
"
#
endif
static
std
:
:
string
getId
(
const
char
*
bin_name
)
{
using
namespace
google_breakpad
;
using
namespace
std
;
PageAllocator
allocator
;
auto_wasteful_vector
<
uint8_t
sizeof
(
MDGUID
)
>
identifier
(
&
allocator
)
;
FileID
file_id
(
bin_name
)
;
if
(
file_id
.
ElfFileIdentifier
(
identifier
)
)
{
return
FileID
:
:
ConvertIdentifierToUUIDString
(
identifier
)
+
"
0
"
;
}
return
"
"
;
}
static
SharedLibrary
SharedLibraryAtPath
(
const
char
*
path
unsigned
long
libStart
unsigned
long
libEnd
unsigned
long
offset
=
0
)
{
nsAutoString
pathStr
;
mozilla
:
:
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
NS_CopyNativeToUnicode
(
nsDependentCString
(
path
)
pathStr
)
)
)
;
nsAutoString
nameStr
=
pathStr
;
int32_t
pos
=
nameStr
.
RFindChar
(
'
/
'
)
;
if
(
pos
!
=
kNotFound
)
{
nameStr
.
Cut
(
0
pos
+
1
)
;
}
return
SharedLibrary
(
libStart
libEnd
offset
getId
(
path
)
nameStr
pathStr
nameStr
pathStr
"
"
"
"
)
;
}
static
int
dl_iterate_callback
(
struct
dl_phdr_info
*
dl_info
size_t
size
void
*
data
)
{
SharedLibraryInfo
&
info
=
*
reinterpret_cast
<
SharedLibraryInfo
*
>
(
data
)
;
if
(
dl_info
-
>
dlpi_phnum
<
=
0
)
return
0
;
unsigned
long
libStart
=
-
1
;
unsigned
long
libEnd
=
0
;
for
(
size_t
i
=
0
;
i
<
dl_info
-
>
dlpi_phnum
;
i
+
+
)
{
if
(
dl_info
-
>
dlpi_phdr
[
i
]
.
p_type
!
=
PT_LOAD
)
{
continue
;
}
unsigned
long
start
=
dl_info
-
>
dlpi_addr
+
dl_info
-
>
dlpi_phdr
[
i
]
.
p_vaddr
;
unsigned
long
end
=
start
+
dl_info
-
>
dlpi_phdr
[
i
]
.
p_memsz
;
if
(
start
<
libStart
)
libStart
=
start
;
if
(
end
>
libEnd
)
libEnd
=
end
;
}
info
.
AddSharedLibrary
(
SharedLibraryAtPath
(
dl_info
-
>
dlpi_name
libStart
libEnd
)
)
;
return
0
;
}
SharedLibraryInfo
SharedLibraryInfo
:
:
GetInfoForSelf
(
)
{
SharedLibraryInfo
info
;
#
if
defined
(
GP_OS_linux
)
char
exeName
[
PATH_MAX
]
;
memset
(
exeName
0
sizeof
(
exeName
)
)
;
ssize_t
exeNameLen
=
readlink
(
"
/
proc
/
self
/
exe
"
exeName
sizeof
(
exeName
)
-
1
)
;
if
(
exeNameLen
=
=
-
1
)
{
exeName
[
0
]
=
'
\
0
'
;
exeNameLen
=
0
;
LOG
(
"
SharedLibraryInfo
:
:
GetInfoForSelf
(
)
:
readlink
failed
"
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
exeNameLen
>
=
0
&
&
exeNameLen
<
static_cast
<
ssize_t
>
(
sizeof
(
exeName
)
)
)
;
}
unsigned
long
exeExeAddr
=
0
;
#
endif
#
if
defined
(
GP_OS_android
)
if
(
!
dl_iterate_phdr
)
{
return
info
;
}
#
endif
pid_t
pid
=
getpid
(
)
;
char
path
[
PATH_MAX
]
;
SprintfLiteral
(
path
"
/
proc
/
%
d
/
maps
"
pid
)
;
std
:
:
ifstream
maps
(
path
)
;
std
:
:
string
line
;
while
(
std
:
:
getline
(
maps
line
)
)
{
int
ret
;
unsigned
long
start
;
unsigned
long
end
;
char
perm
[
6
+
1
]
=
"
"
;
unsigned
long
offset
;
char
modulePath
[
PATH_MAX
+
1
]
=
"
"
;
ret
=
sscanf
(
line
.
c_str
(
)
"
%
lx
-
%
lx
%
6s
%
lx
%
*
s
%
*
x
%
"
PATH_MAX_STRING
(
PATH_MAX
)
"
s
\
n
"
&
start
&
end
perm
&
offset
modulePath
)
;
if
(
!
strchr
(
perm
'
x
'
)
)
{
continue
;
}
if
(
ret
!
=
5
&
&
ret
!
=
4
)
{
LOG
(
"
SharedLibraryInfo
:
:
GetInfoForSelf
(
)
:
"
"
reading
/
proc
/
self
/
maps
failed
"
)
;
continue
;
}
#
if
defined
(
GP_OS_linux
)
if
(
exeNameLen
>
0
&
&
strcmp
(
modulePath
exeName
)
=
=
0
)
{
exeExeAddr
=
start
;
}
#
elif
defined
(
GP_OS_android
)
if
(
0
=
=
strcmp
(
modulePath
"
/
dev
/
ashmem
/
dalvik
-
jit
-
code
-
cache
"
)
)
{
info
.
AddSharedLibrary
(
SharedLibraryAtPath
(
modulePath
start
end
offset
)
)
;
if
(
info
.
GetSize
(
)
>
10000
)
{
LOG
(
"
SharedLibraryInfo
:
:
GetInfoForSelf
(
)
:
"
"
implausibly
large
number
of
mappings
acquired
"
)
;
break
;
}
}
#
endif
}
dl_iterate_phdr
(
dl_iterate_callback
&
info
)
;
#
if
defined
(
GP_OS_linux
)
for
(
size_t
i
=
0
;
i
<
info
.
GetSize
(
)
;
i
+
+
)
{
SharedLibrary
&
lib
=
info
.
GetMutableEntry
(
i
)
;
if
(
lib
.
GetStart
(
)
=
=
exeExeAddr
&
&
lib
.
GetNativeDebugPath
(
)
=
=
"
"
)
{
lib
=
SharedLibraryAtPath
(
exeName
lib
.
GetStart
(
)
lib
.
GetEnd
(
)
lib
.
GetOffset
(
)
)
;
break
;
}
}
#
endif
return
info
;
}
