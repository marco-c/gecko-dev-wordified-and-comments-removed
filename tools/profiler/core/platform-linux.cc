#
include
<
stdio
.
h
>
#
include
<
math
.
h
>
#
include
<
pthread
.
h
>
#
include
<
semaphore
.
h
>
#
include
<
signal
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
sys
/
resource
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
prctl
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
sched
.
h
>
#
ifdef
ANDROID
#
include
<
android
/
log
.
h
>
#
else
#
define
__android_log_print
(
a
.
.
.
)
#
endif
#
include
<
ucontext
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
unistd
.
h
>
#
include
<
semaphore
.
h
>
#
ifdef
__GLIBC__
#
include
<
execinfo
.
h
>
#
endif
#
include
<
strings
.
h
>
#
include
<
errno
.
h
>
#
include
<
stdarg
.
h
>
#
include
"
prenv
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
LinuxSignal
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
ProfileEntry
.
h
"
#
include
"
nsMemoryReporterManager
.
h
"
#
include
<
string
.
h
>
#
include
<
list
>
using
namespace
mozilla
;
static
bool
gIsSigprofSignalHandlerInstalled
;
static
struct
sigaction
gOldSigprofSignalHandler
;
static
bool
gHasSignalSenderLaunched
;
static
pthread_t
gSignalSenderThread
;
#
if
defined
(
USE_LUL_STACKWALK
)
lul
:
:
LUL
*
sLUL
=
nullptr
;
static
void
sLUL_initialization_routine
(
void
)
{
MOZ_ASSERT
(
!
sLUL
)
;
MOZ_ASSERT
(
gettid
(
)
=
=
getpid
(
)
)
;
sLUL
=
new
lul
:
:
LUL
(
logging_sink_for_LUL
)
;
read_procmaps
(
sLUL
)
;
}
#
endif
Thread
:
:
tid_t
Thread
:
:
GetCurrentId
(
)
{
return
gettid
(
)
;
}
#
if
!
defined
(
ANDROID
)
static
bool
gWasPaused
=
false
;
static
void
paf_prepare
(
void
)
{
gWasPaused
=
gIsPaused
;
gIsPaused
=
true
;
}
static
void
paf_parent
(
void
)
{
gIsPaused
=
gWasPaused
;
}
static
void
*
setup_atfork
(
)
{
pthread_atfork
(
paf_prepare
paf_parent
NULL
)
;
return
NULL
;
}
#
endif
static
mozilla
:
:
Atomic
<
ThreadInfo
*
>
sCurrentThreadInfo
;
static
sem_t
sSignalHandlingDone
;
static
void
SetSampleContext
(
TickSample
*
sample
void
*
context
)
{
ucontext_t
*
ucontext
=
reinterpret_cast
<
ucontext_t
*
>
(
context
)
;
mcontext_t
&
mcontext
=
ucontext
-
>
uc_mcontext
;
#
if
V8_HOST_ARCH_IA32
sample
-
>
pc
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
REG_EIP
]
)
;
sample
-
>
sp
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
REG_ESP
]
)
;
sample
-
>
fp
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
REG_EBP
]
)
;
#
elif
V8_HOST_ARCH_X64
sample
-
>
pc
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
REG_RIP
]
)
;
sample
-
>
sp
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
REG_RSP
]
)
;
sample
-
>
fp
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
REG_RBP
]
)
;
#
elif
V8_HOST_ARCH_ARM
#
if
!
defined
(
ANDROID
)
&
&
(
__GLIBC__
<
2
|
|
(
__GLIBC__
=
=
2
&
&
__GLIBC_MINOR__
<
=
3
)
)
sample
-
>
pc
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
R15
]
)
;
sample
-
>
sp
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
R13
]
)
;
sample
-
>
fp
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
R11
]
)
;
sample
-
>
lr
=
reinterpret_cast
<
Address
>
(
mcontext
.
gregs
[
R14
]
)
;
#
else
sample
-
>
pc
=
reinterpret_cast
<
Address
>
(
mcontext
.
arm_pc
)
;
sample
-
>
sp
=
reinterpret_cast
<
Address
>
(
mcontext
.
arm_sp
)
;
sample
-
>
fp
=
reinterpret_cast
<
Address
>
(
mcontext
.
arm_fp
)
;
sample
-
>
lr
=
reinterpret_cast
<
Address
>
(
mcontext
.
arm_lr
)
;
#
endif
#
elif
V8_HOST_ARCH_MIPS
UNIMPLEMENTED
(
)
;
#
endif
}
#
ifdef
ANDROID
#
define
V8_HOST_ARCH_ARM
1
#
define
SYS_gettid
__NR_gettid
#
define
SYS_tgkill
__NR_tgkill
#
else
#
define
V8_HOST_ARCH_X64
1
#
endif
namespace
{
void
ProfilerSignalHandler
(
int
signal
siginfo_t
*
info
void
*
context
)
{
int
savedErrno
=
errno
;
if
(
!
gSampler
)
{
sem_post
(
&
sSignalHandlingDone
)
;
errno
=
savedErrno
;
return
;
}
TickSample
sample_obj
;
TickSample
*
sample
=
&
sample_obj
;
sample
-
>
context
=
context
;
SetSampleContext
(
sample
context
)
;
sample
-
>
threadInfo
=
sCurrentThreadInfo
;
sample
-
>
timestamp
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
sample
-
>
rssMemory
=
sample
-
>
threadInfo
-
>
mRssMemory
;
sample
-
>
ussMemory
=
sample
-
>
threadInfo
-
>
mUssMemory
;
Tick
(
sample
)
;
sCurrentThreadInfo
=
NULL
;
sem_post
(
&
sSignalHandlingDone
)
;
errno
=
savedErrno
;
}
}
static
void
ProfilerSignalThread
(
ThreadInfo
*
aInfo
bool
aIsFirstProfiledThread
)
{
if
(
aIsFirstProfiledThread
&
&
gProfileMemory
)
{
aInfo
-
>
mRssMemory
=
nsMemoryReporterManager
:
:
ResidentFast
(
)
;
aInfo
-
>
mUssMemory
=
nsMemoryReporterManager
:
:
ResidentUnique
(
)
;
}
else
{
aInfo
-
>
mRssMemory
=
0
;
aInfo
-
>
mUssMemory
=
0
;
}
}
int
tgkill
(
pid_t
tgid
pid_t
tid
int
signalno
)
{
return
syscall
(
SYS_tgkill
tgid
tid
signalno
)
;
}
class
PlatformData
{
public
:
PlatformData
(
)
{
MOZ_COUNT_CTOR
(
PlatformData
)
;
}
~
PlatformData
(
)
{
MOZ_COUNT_DTOR
(
PlatformData
)
;
}
}
;
auto
Sampler
:
:
AllocPlatformData
(
int
aThreadId
)
-
>
UniquePlatformData
{
return
UniquePlatformData
(
new
PlatformData
)
;
}
void
Sampler
:
:
PlatformDataDestructor
:
:
operator
(
)
(
PlatformData
*
aData
)
{
delete
aData
;
}
static
void
*
SignalSender
(
void
*
arg
)
{
prctl
(
PR_SET_NAME
"
SamplerThread
"
0
0
0
)
;
int
vm_tgid_
=
getpid
(
)
;
DebugOnly
<
int
>
my_tid
=
gettid
(
)
;
unsigned
int
nSignalsSent
=
0
;
TimeDuration
lastSleepOverhead
=
0
;
TimeStamp
sampleStart
=
TimeStamp
:
:
Now
(
)
;
while
(
gIsActive
)
{
gBuffer
-
>
deleteExpiredStoredMarkers
(
)
;
if
(
!
gIsPaused
)
{
StaticMutexAutoLock
lock
(
sRegisteredThreadsMutex
)
;
bool
isFirstProfiledThread
=
true
;
for
(
uint32_t
i
=
0
;
i
<
sRegisteredThreads
-
>
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
(
*
sRegisteredThreads
)
[
i
]
;
if
(
!
info
-
>
hasProfile
(
)
|
|
info
-
>
IsPendingDelete
(
)
)
{
continue
;
}
PseudoStack
:
:
SleepState
sleeping
=
info
-
>
Stack
(
)
-
>
observeSleeping
(
)
;
if
(
sleeping
=
=
PseudoStack
:
:
SLEEPING_AGAIN
)
{
info
-
>
DuplicateLastSample
(
)
;
continue
;
}
info
-
>
UpdateThreadResponsiveness
(
)
;
sCurrentThreadInfo
=
info
;
int
threadId
=
info
-
>
ThreadId
(
)
;
MOZ_ASSERT
(
threadId
!
=
my_tid
)
;
ProfilerSignalThread
(
sCurrentThreadInfo
isFirstProfiledThread
)
;
if
(
tgkill
(
vm_tgid_
threadId
SIGPROF
)
!
=
0
)
{
printf_stderr
(
"
profiler
failed
to
signal
tid
=
%
d
\
n
"
threadId
)
;
#
ifdef
DEBUG
abort
(
)
;
#
else
continue
;
#
endif
}
sem_wait
(
&
sSignalHandlingDone
)
;
isFirstProfiledThread
=
false
;
if
(
(
+
+
nSignalsSent
&
0xF
)
=
=
0
)
{
#
if
defined
(
USE_LUL_STACKWALK
)
sLUL
-
>
MaybeShowStats
(
)
;
#
endif
}
}
}
TimeStamp
targetSleepEndTime
=
sampleStart
+
TimeDuration
:
:
FromMicroseconds
(
gInterval
*
1000
)
;
TimeStamp
beforeSleep
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
targetSleepDuration
=
targetSleepEndTime
-
beforeSleep
;
double
sleepTime
=
std
:
:
max
(
0
.
0
(
targetSleepDuration
-
lastSleepOverhead
)
.
ToMicroseconds
(
)
)
;
OS
:
:
SleepMicro
(
sleepTime
)
;
sampleStart
=
TimeStamp
:
:
Now
(
)
;
lastSleepOverhead
=
sampleStart
-
(
beforeSleep
+
TimeDuration
:
:
FromMicroseconds
(
sleepTime
)
)
;
}
return
0
;
}
void
Sampler
:
:
Start
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
"
Sampler
started
"
)
;
#
if
defined
(
USE_EHABI_STACKWALK
)
mozilla
:
:
EHABIStackWalkInit
(
)
;
#
elif
defined
(
USE_LUL_STACKWALK
)
if
(
!
sLUL
)
{
sLUL_initialization_routine
(
)
;
}
#
endif
sCurrentThreadInfo
=
nullptr
;
if
(
sem_init
(
&
sSignalHandlingDone
0
0
)
!
=
0
)
{
LOG
(
"
Error
initializing
semaphore
"
)
;
return
;
}
LOG
(
"
Request
signal
"
)
;
struct
sigaction
sa
;
sa
.
sa_sigaction
=
MOZ_SIGNAL_TRAMPOLINE
(
ProfilerSignalHandler
)
;
sigemptyset
(
&
sa
.
sa_mask
)
;
sa
.
sa_flags
=
SA_RESTART
|
SA_SIGINFO
;
if
(
sigaction
(
SIGPROF
&
sa
&
gOldSigprofSignalHandler
)
!
=
0
)
{
LOG
(
"
Error
installing
signal
"
)
;
return
;
}
LOG
(
"
Signal
installed
"
)
;
gIsSigprofSignalHandlerInstalled
=
true
;
#
if
defined
(
USE_LUL_STACKWALK
)
sLUL
-
>
EnableUnwinding
(
)
;
if
(
PR_GetEnv
(
"
MOZ_PROFILER_LUL_TEST
"
)
)
{
int
nTests
=
0
nTestsPassed
=
0
;
RunLulUnitTests
(
&
nTests
&
nTestsPassed
sLUL
)
;
}
#
endif
MOZ_ASSERT
(
!
gIsActive
)
;
gIsActive
=
true
;
if
(
pthread_create
(
&
gSignalSenderThread
NULL
SignalSender
NULL
)
=
=
0
)
{
gHasSignalSenderLaunched
=
true
;
}
LOG
(
"
Profiler
thread
started
"
)
;
}
void
Sampler
:
:
Stop
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
gIsActive
)
;
gIsActive
=
false
;
if
(
gHasSignalSenderLaunched
)
{
pthread_join
(
gSignalSenderThread
NULL
)
;
gHasSignalSenderLaunched
=
false
;
}
if
(
gIsSigprofSignalHandlerInstalled
)
{
sigaction
(
SIGPROF
&
gOldSigprofSignalHandler
0
)
;
gIsSigprofSignalHandlerInstalled
=
false
;
}
}
#
ifdef
ANDROID
static
struct
sigaction
old_sigstart_signal_handler
;
const
int
SIGSTART
=
SIGUSR2
;
static
void
freeArray
(
const
char
*
*
array
int
size
)
{
for
(
int
i
=
0
;
i
<
size
;
i
+
+
)
{
free
(
(
void
*
)
array
[
i
]
)
;
}
}
static
uint32_t
readCSVArray
(
char
*
csvList
const
char
*
*
buffer
)
{
uint32_t
count
;
char
*
savePtr
;
int
newlinePos
=
strlen
(
csvList
)
-
1
;
if
(
csvList
[
newlinePos
]
=
=
'
\
n
'
)
{
csvList
[
newlinePos
]
=
'
\
0
'
;
}
char
*
item
=
strtok_r
(
csvList
"
"
&
savePtr
)
;
for
(
count
=
0
;
item
;
item
=
strtok_r
(
NULL
"
"
&
savePtr
)
)
{
int
length
=
strlen
(
item
)
+
1
;
char
*
newBuf
=
(
char
*
)
malloc
(
sizeof
(
char
)
*
length
)
;
buffer
[
count
]
=
newBuf
;
strncpy
(
newBuf
item
length
)
;
count
+
+
;
}
return
count
;
}
static
void
ReadProfilerVars
(
const
char
*
fileName
const
char
*
*
features
uint32_t
*
featureCount
const
char
*
*
threadNames
uint32_t
*
threadCount
)
{
FILE
*
file
=
fopen
(
fileName
"
r
"
)
;
const
int
bufferSize
=
1024
;
char
line
[
bufferSize
]
;
char
*
feature
;
char
*
value
;
char
*
savePtr
;
if
(
file
)
{
while
(
fgets
(
line
bufferSize
file
)
!
=
NULL
)
{
feature
=
strtok_r
(
line
"
=
"
&
savePtr
)
;
value
=
strtok_r
(
NULL
"
"
&
savePtr
)
;
if
(
strncmp
(
feature
PROFILER_INTERVAL
bufferSize
)
=
=
0
)
{
set_profiler_interval
(
value
)
;
}
else
if
(
strncmp
(
feature
PROFILER_ENTRIES
bufferSize
)
=
=
0
)
{
set_profiler_entries
(
value
)
;
}
else
if
(
strncmp
(
feature
PROFILER_STACK
bufferSize
)
=
=
0
)
{
set_profiler_scan
(
value
)
;
}
else
if
(
strncmp
(
feature
PROFILER_FEATURES
bufferSize
)
=
=
0
)
{
*
featureCount
=
readCSVArray
(
value
features
)
;
}
else
if
(
strncmp
(
feature
"
threads
"
bufferSize
)
=
=
0
)
{
*
threadCount
=
readCSVArray
(
value
threadNames
)
;
}
}
fclose
(
file
)
;
}
}
static
void
DoStartTask
(
)
{
uint32_t
featureCount
=
0
;
uint32_t
threadCount
=
0
;
const
char
*
threadNames
[
10
]
;
const
char
*
features
[
10
]
;
const
char
*
profilerConfigFile
=
"
/
data
/
local
/
tmp
/
profiler
.
options
"
;
ReadProfilerVars
(
profilerConfigFile
features
&
featureCount
threadNames
&
threadCount
)
;
MOZ_ASSERT
(
featureCount
<
10
)
;
MOZ_ASSERT
(
threadCount
<
10
)
;
profiler_start
(
PROFILE_DEFAULT_ENTRY
1
features
featureCount
threadNames
threadCount
)
;
freeArray
(
threadNames
threadCount
)
;
freeArray
(
features
featureCount
)
;
}
static
void
StartSignalHandler
(
int
signal
siginfo_t
*
info
void
*
context
)
{
class
StartTask
:
public
Runnable
{
public
:
NS_IMETHOD
Run
(
)
override
{
DoStartTask
(
)
;
return
NS_OK
;
}
}
;
NS_DispatchToMainThread
(
new
StartTask
(
)
)
;
}
void
OS
:
:
Startup
(
)
{
LOG
(
"
Registering
start
signal
"
)
;
struct
sigaction
sa
;
sa
.
sa_sigaction
=
StartSignalHandler
;
sigemptyset
(
&
sa
.
sa_mask
)
;
sa
.
sa_flags
=
SA_RESTART
|
SA_SIGINFO
;
if
(
sigaction
(
SIGSTART
&
sa
&
old_sigstart_signal_handler
)
!
=
0
)
{
LOG
(
"
Error
installing
signal
"
)
;
}
}
#
else
void
OS
:
:
Startup
(
)
{
setup_atfork
(
)
;
}
#
endif
void
TickSample
:
:
PopulateContext
(
void
*
aContext
)
{
MOZ_ASSERT
(
aContext
)
;
ucontext_t
*
pContext
=
reinterpret_cast
<
ucontext_t
*
>
(
aContext
)
;
if
(
!
getcontext
(
pContext
)
)
{
context
=
pContext
;
SetSampleContext
(
this
aContext
)
;
}
}
void
OS
:
:
SleepMicro
(
int
microseconds
)
{
if
(
MOZ_UNLIKELY
(
microseconds
>
=
1000000
)
)
{
MOZ_ALWAYS_TRUE
(
!
:
:
usleep
(
microseconds
)
)
;
return
;
}
struct
timespec
ts
;
ts
.
tv_sec
=
0
;
ts
.
tv_nsec
=
microseconds
*
1000UL
;
int
rv
=
:
:
nanosleep
(
&
ts
&
ts
)
;
while
(
rv
!
=
0
&
&
errno
=
=
EINTR
)
{
rv
=
:
:
nanosleep
(
&
ts
&
ts
)
;
}
MOZ_ASSERT
(
!
rv
"
nanosleep
call
failed
"
)
;
}
