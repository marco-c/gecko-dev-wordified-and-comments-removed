#
include
"
memory_hooks
.
h
"
#
include
"
nscore
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
FastBernoulliTrial
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
JSONWriter
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ProfilerCounts
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
prenv
.
h
"
#
include
"
replace_malloc
.
h
"
#
include
<
ctype
.
h
>
#
include
<
errno
.
h
>
#
include
<
limits
.
h
>
#
include
<
stdarg
.
h
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
include
<
process
.
h
>
#
else
#
include
<
pthread
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
unistd
.
h
>
#
endif
#
ifdef
ANDROID
#
include
<
android
/
log
.
h
>
#
endif
static
ProfilerCounterTotal
*
sCounter
;
static
mozilla
:
:
FastBernoulliTrial
*
gBernoulli
;
namespace
mozilla
{
namespace
profiler
{
static
malloc_table_t
gMallocTable
;
static
size_t
MallocSizeOf
(
const
void
*
aPtr
)
{
return
gMallocTable
.
malloc_usable_size
(
const_cast
<
void
*
>
(
aPtr
)
)
;
}
static
void
EnsureBernoulliIsInstalled
(
)
{
if
(
!
gBernoulli
)
{
gBernoulli
=
new
FastBernoulliTrial
(
0
.
0003
0x8e26eeee166bc8ca
0x56820f304a9c9ae0
)
;
}
}
#
if
!
defined
(
XP_DARWIN
)
&
&
!
defined
(
XP_LINUX
)
#
define
PROFILER_THREAD_LOCAL
(
T
)
MOZ_THREAD_LOCAL
(
T
)
#
else
#
define
PROFILER_THREAD_LOCAL
(
T
)
\
:
:
mozilla
:
:
detail
:
:
ThreadLocal
<
T
:
:
mozilla
:
:
detail
:
:
ThreadLocalKeyStorage
>
#
endif
class
ThreadIntercept
{
static
PROFILER_THREAD_LOCAL
(
bool
)
tlsIsBlocked
;
static
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
sAllocationsFeatureEnabled
;
ThreadIntercept
(
)
=
default
;
static
bool
IsBlocked_
(
)
{
return
tlsIsBlocked
.
get
(
)
|
|
profiler_is_locked_on_current_thread
(
)
;
}
public
:
static
void
Init
(
)
{
tlsIsBlocked
.
infallibleInit
(
)
;
}
static
Maybe
<
ThreadIntercept
>
MaybeGet
(
)
{
if
(
sAllocationsFeatureEnabled
&
&
!
ThreadIntercept
:
:
IsBlocked_
(
)
)
{
return
Some
(
ThreadIntercept
(
)
)
;
}
return
Nothing
(
)
;
}
void
Block
(
)
{
MOZ_ASSERT
(
!
tlsIsBlocked
.
get
(
)
)
;
tlsIsBlocked
.
set
(
true
)
;
}
void
Unblock
(
)
{
MOZ_ASSERT
(
tlsIsBlocked
.
get
(
)
)
;
tlsIsBlocked
.
set
(
false
)
;
}
bool
IsBlocked
(
)
const
{
return
ThreadIntercept
:
:
IsBlocked_
(
)
;
}
static
void
EnableAllocationFeature
(
)
{
sAllocationsFeatureEnabled
=
true
;
}
static
void
DisableAllocationFeature
(
)
{
sAllocationsFeatureEnabled
=
false
;
}
}
;
PROFILER_THREAD_LOCAL
(
bool
)
ThreadIntercept
:
:
tlsIsBlocked
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
Relaxed
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
>
ThreadIntercept
:
:
sAllocationsFeatureEnabled
(
false
)
;
class
AutoBlockIntercepts
{
ThreadIntercept
&
mThreadIntercept
;
public
:
AutoBlockIntercepts
(
const
AutoBlockIntercepts
&
)
=
delete
;
void
operator
=
(
const
AutoBlockIntercepts
&
)
=
delete
;
explicit
AutoBlockIntercepts
(
ThreadIntercept
&
aThreadIntercept
)
:
mThreadIntercept
(
aThreadIntercept
)
{
mThreadIntercept
.
Block
(
)
;
}
~
AutoBlockIntercepts
(
)
{
MOZ_ASSERT
(
mThreadIntercept
.
IsBlocked
(
)
)
;
mThreadIntercept
.
Unblock
(
)
;
}
}
;
static
void
AllocCallback
(
void
*
aPtr
size_t
aReqSize
)
{
if
(
!
aPtr
)
{
return
;
}
size_t
actualSize
=
gMallocTable
.
malloc_usable_size
(
aPtr
)
;
if
(
actualSize
>
0
)
{
sCounter
-
>
Add
(
actualSize
)
;
}
auto
threadIntercept
=
ThreadIntercept
:
:
MaybeGet
(
)
;
if
(
threadIntercept
.
isNothing
(
)
)
{
return
;
}
AutoBlockIntercepts
block
(
threadIntercept
.
ref
(
)
)
;
MOZ_ASSERT
(
gBernoulli
"
gBernoulli
must
be
properly
installed
for
the
memory
hooks
.
"
)
;
if
(
gBernoulli
-
>
trial
(
actualSize
)
)
{
profiler_add_native_allocation_marker
(
(
int64_t
)
actualSize
)
;
}
}
static
void
FreeCallback
(
void
*
aPtr
)
{
if
(
!
aPtr
)
{
return
;
}
size_t
unsignedSize
=
MallocSizeOf
(
aPtr
)
;
int64_t
signedSize
=
-
(
(
int64_t
)
unsignedSize
)
;
sCounter
-
>
Add
(
signedSize
)
;
auto
threadIntercept
=
ThreadIntercept
:
:
MaybeGet
(
)
;
if
(
threadIntercept
.
isNothing
(
)
)
{
return
;
}
AutoBlockIntercepts
block
(
threadIntercept
.
ref
(
)
)
;
MOZ_ASSERT
(
gBernoulli
"
gBernoulli
must
be
properly
installed
for
the
memory
hooks
.
"
)
;
if
(
gBernoulli
-
>
trial
(
unsignedSize
)
)
{
profiler_add_native_allocation_marker
(
signedSize
)
;
}
}
}
}
using
namespace
mozilla
:
:
profiler
;
static
void
*
replace_malloc
(
size_t
aSize
)
{
void
*
ptr
=
gMallocTable
.
malloc
(
aSize
)
;
AllocCallback
(
ptr
aSize
)
;
return
ptr
;
}
static
void
*
replace_calloc
(
size_t
aCount
size_t
aSize
)
{
void
*
ptr
=
gMallocTable
.
calloc
(
aCount
aSize
)
;
AllocCallback
(
ptr
aCount
*
aSize
)
;
return
ptr
;
}
static
void
*
replace_realloc
(
void
*
aOldPtr
size_t
aSize
)
{
if
(
!
aOldPtr
)
{
return
replace_malloc
(
aSize
)
;
}
FreeCallback
(
aOldPtr
)
;
void
*
ptr
=
gMallocTable
.
realloc
(
aOldPtr
aSize
)
;
if
(
ptr
)
{
AllocCallback
(
ptr
aSize
)
;
}
else
{
AllocCallback
(
aOldPtr
gMallocTable
.
malloc_usable_size
(
aOldPtr
)
)
;
}
return
ptr
;
}
static
void
*
replace_memalign
(
size_t
aAlignment
size_t
aSize
)
{
void
*
ptr
=
gMallocTable
.
memalign
(
aAlignment
aSize
)
;
AllocCallback
(
ptr
aSize
)
;
return
ptr
;
}
static
void
replace_free
(
void
*
aPtr
)
{
FreeCallback
(
aPtr
)
;
gMallocTable
.
free
(
aPtr
)
;
}
static
void
*
replace_moz_arena_malloc
(
arena_id_t
aArena
size_t
aSize
)
{
void
*
ptr
=
gMallocTable
.
moz_arena_malloc
(
aArena
aSize
)
;
AllocCallback
(
ptr
aSize
)
;
return
ptr
;
}
static
void
*
replace_moz_arena_calloc
(
arena_id_t
aArena
size_t
aCount
size_t
aSize
)
{
void
*
ptr
=
gMallocTable
.
moz_arena_calloc
(
aArena
aCount
aSize
)
;
AllocCallback
(
ptr
aCount
*
aSize
)
;
return
ptr
;
}
static
void
*
replace_moz_arena_realloc
(
arena_id_t
aArena
void
*
aPtr
size_t
aSize
)
{
void
*
ptr
=
gMallocTable
.
moz_arena_realloc
(
aArena
aPtr
aSize
)
;
AllocCallback
(
ptr
aSize
)
;
return
ptr
;
}
static
void
replace_moz_arena_free
(
arena_id_t
aArena
void
*
aPtr
)
{
FreeCallback
(
aPtr
)
;
gMallocTable
.
moz_arena_free
(
aArena
aPtr
)
;
}
static
void
*
replace_moz_arena_memalign
(
arena_id_t
aArena
size_t
aAlignment
size_t
aSize
)
{
void
*
ptr
=
gMallocTable
.
moz_arena_memalign
(
aArena
aAlignment
aSize
)
;
AllocCallback
(
ptr
aSize
)
;
return
ptr
;
}
static
arena_id_t
replace_moz_create_arena_with_params
(
arena_params_t
*
aParams
)
{
return
gMallocTable
.
moz_create_arena_with_params
(
aParams
)
;
}
static
void
replace_moz_dispose_arena
(
arena_id_t
aArenaId
)
{
return
gMallocTable
.
moz_dispose_arena
(
aArenaId
)
;
}
void
replace_init
(
malloc_table_t
*
aMallocTable
ReplaceMallocBridge
*
*
aBridge
)
{
gMallocTable
=
*
aMallocTable
;
#
define
MALLOC_FUNCS
(
MALLOC_FUNCS_MALLOC_BASE
|
MALLOC_FUNCS_ARENA
)
#
define
MALLOC_DECL
(
name
.
.
.
)
aMallocTable
-
>
name
=
replace_
#
#
name
;
#
include
"
malloc_decls
.
h
"
}
void
profiler_replace_remove
(
)
{
}
namespace
mozilla
{
namespace
profiler
{
void
install_memory_hooks
(
)
{
if
(
!
sCounter
)
{
sCounter
=
new
ProfilerCounterTotal
(
"
malloc
"
"
Memory
"
"
Amount
of
allocated
memory
"
)
;
ThreadIntercept
:
:
Init
(
)
;
}
jemalloc_replace_dynamic
(
replace_init
)
;
}
void
remove_memory_hooks
(
)
{
jemalloc_replace_dynamic
(
nullptr
)
;
}
void
enable_native_allocations
(
)
{
if
(
!
PR_GetEnv
(
"
XPCOM_MEM_BLOAT_LOG
"
)
)
{
EnsureBernoulliIsInstalled
(
)
;
ThreadIntercept
:
:
EnableAllocationFeature
(
)
;
}
}
void
disable_native_allocations
(
)
{
ThreadIntercept
:
:
DisableAllocationFeature
(
)
;
}
}
}
