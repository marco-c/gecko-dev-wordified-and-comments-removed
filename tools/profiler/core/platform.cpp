#
include
"
platform
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
GeckoProfilerReporter
.
h
"
#
include
"
PageInformation
.
h
"
#
include
"
ProfileBuffer
.
h
"
#
include
"
ProfiledThreadData
.
h
"
#
include
"
ProfilerBacktrace
.
h
"
#
include
"
ProfilerChild
.
h
"
#
include
"
ProfilerCodeAddressService
.
h
"
#
include
"
ProfilerIOInterposeObserver
.
h
"
#
include
"
ProfilerParent
.
h
"
#
include
"
RegisteredThread
.
h
"
#
include
"
shared
-
libraries
.
h
"
#
include
"
VTuneProfiler
.
h
"
#
include
"
js
/
TraceLoggerAPI
.
h
"
#
include
"
js
/
ProfilingFrameIterator
.
h
"
#
include
"
memory_hooks
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
AutoProfilerLabel
.
h
"
#
include
"
mozilla
/
ExtensionPolicyService
.
h
"
#
include
"
mozilla
/
extensions
/
WebExtensionPolicy
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Printf
.
h
"
#
include
"
mozilla
/
ProfileBufferChunkManagerSingle
.
h
"
#
include
"
mozilla
/
ProfileBufferChunkManagerWithLocalLimit
.
h
"
#
include
"
mozilla
/
ProfileChunkedBuffer
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
StackWalkThread
.
h
"
#
endif
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
BaseProfiler
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIHttpProtocolHandler
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPropertyBag2
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsMemoryReporterManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsProfilerStartParams
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
nsSystemInfo
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
Tracing
.
h
"
#
include
"
prdtoa
.
h
"
#
include
"
prtime
.
h
"
#
include
<
algorithm
>
#
include
<
errno
.
h
>
#
include
<
fstream
>
#
include
<
ostream
>
#
include
<
set
>
#
include
<
sstream
>
#
include
<
type_traits
>
#
if
defined
(
GP_OS_android
)
#
include
"
mozilla
/
java
/
GeckoJavaSamplerNatives
.
h
"
#
endif
#
if
defined
(
GP_OS_darwin
)
#
include
"
nsCocoaFeatures
.
h
"
#
endif
#
if
defined
(
GP_PLAT_x86_windows
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
if
defined
(
GP_PLAT_amd64_windows
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_MOZ_STACK_WALK
#
endif
#
if
defined
(
GP_PLAT_arm64_windows
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_MOZ_STACK_WALK
#
endif
#
if
defined
(
GP_OS_darwin
)
&
&
defined
(
MOZ_PROFILING
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
if
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_EHABI_STACKWALK
#
include
"
EHABIStackWalk
.
h
"
#
endif
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_x86_linux
)
|
|
\
defined
(
GP_PLAT_amd64_android
)
|
|
defined
(
GP_PLAT_x86_android
)
|
|
\
defined
(
GP_PLAT_mips64_linux
)
|
|
defined
(
GP_PLAT_arm64_linux
)
|
|
\
defined
(
GP_PLAT_arm64_android
)
|
|
defined
(
GP_PLAT_amd64_freebsd
)
|
|
\
defined
(
GP_PLAT_arm64_freebsd
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_LUL_STACKWALK
#
include
"
lul
/
LulMain
.
h
"
#
include
"
lul
/
platform
-
linux
-
lul
.
h
"
#
if
defined
(
MOZ_PROFILING
)
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
endif
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
|
|
defined
(
USE_MOZ_STACK_WALK
)
#
define
HAVE_FASTINIT_NATIVE_UNWIND
#
endif
#
ifdef
MOZ_VALGRIND
#
include
<
valgrind
/
memcheck
.
h
>
#
else
#
define
VALGRIND_MAKE_MEM_DEFINED
(
_addr
_len
)
(
(
void
)
0
)
#
endif
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
#
include
<
ucontext
.
h
>
#
endif
using
namespace
mozilla
;
using
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
;
using
ThreadRegistration
=
mozilla
:
:
profiler
:
:
ThreadRegistration
;
using
ThreadRegistrationInfo
=
mozilla
:
:
profiler
:
:
ThreadRegistrationInfo
;
using
ThreadRegistry
=
mozilla
:
:
profiler
:
:
ThreadRegistry
;
LazyLogModule
gProfilerLog
(
"
prof
"
)
;
#
if
defined
(
GP_OS_android
)
class
GeckoJavaSampler
:
public
java
:
:
GeckoJavaSampler
:
:
Natives
<
GeckoJavaSampler
>
{
private
:
GeckoJavaSampler
(
)
;
public
:
static
double
GetProfilerTime
(
)
{
if
(
!
profiler_is_active
(
)
)
{
return
0
.
0
;
}
return
profiler_time
(
)
;
}
;
}
;
#
endif
constexpr
static
bool
ValidateFeatures
(
)
{
int
expectedFeatureNumber
=
0
;
#
define
CHECK_FEATURE
(
n_
str_
Name_
desc_
)
\
if
(
(
n_
)
!
=
expectedFeatureNumber
)
{
\
return
false
;
\
}
\
+
+
expectedFeatureNumber
;
PROFILER_FOR_EACH_FEATURE
(
CHECK_FEATURE
)
#
undef
CHECK_FEATURE
return
true
;
}
static_assert
(
ValidateFeatures
(
)
"
Feature
list
is
invalid
"
)
;
static
uint32_t
AvailableFeatures
(
)
{
uint32_t
features
=
0
;
#
define
ADD_FEATURE
(
n_
str_
Name_
desc_
)
\
ProfilerFeature
:
:
Set
#
#
Name_
(
features
)
;
PROFILER_FOR_EACH_FEATURE
(
ADD_FEATURE
)
#
undef
ADD_FEATURE
#
if
!
defined
(
GP_OS_android
)
ProfilerFeature
:
:
ClearJava
(
features
)
;
#
endif
#
if
!
defined
(
HAVE_NATIVE_UNWIND
)
ProfilerFeature
:
:
ClearStackWalk
(
features
)
;
#
endif
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
getenv
(
"
XPCOM_MEM_BLOAT_LOG
"
)
)
{
NS_WARNING
(
"
XPCOM_MEM_BLOAT_LOG
is
set
disabling
native
allocations
.
"
)
;
ProfilerFeature
:
:
ClearNativeAllocations
(
features
)
;
}
#
else
ProfilerFeature
:
:
ClearNativeAllocations
(
features
)
;
#
endif
if
(
!
JS
:
:
TraceLoggerSupported
(
)
)
{
ProfilerFeature
:
:
ClearJSTracer
(
features
)
;
}
#
if
!
defined
(
GP_OS_windows
)
ProfilerFeature
:
:
ClearNoTimerResolutionChange
(
features
)
;
#
endif
return
features
;
}
static
uint32_t
DefaultFeatures
(
)
{
return
ProfilerFeature
:
:
Java
|
ProfilerFeature
:
:
JS
|
ProfilerFeature
:
:
Leaf
|
ProfilerFeature
:
:
StackWalk
|
ProfilerFeature
:
:
Threads
|
ProfilerFeature
:
:
CPUUtilization
|
ProfilerFeature
:
:
Screenshots
;
}
static
uint32_t
StartupExtraDefaultFeatures
(
)
{
return
ProfilerFeature
:
:
FileIOAll
;
}
class
MOZ_RAII
PSAutoLock
{
public
:
PSAutoLock
(
)
:
mLock
(
[
]
(
)
-
>
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
&
{
MOZ_ASSERT
(
!
ThreadRegistry
:
:
IsRegistryMutexLockedOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
!
ThreadRegistration
:
:
IsDataMutexLockedOnCurrentThread
(
)
)
;
return
gPSMutex
;
}
(
)
)
{
}
PSAutoLock
(
const
PSAutoLock
&
)
=
delete
;
void
operator
=
(
const
PSAutoLock
&
)
=
delete
;
static
bool
IsLockedOnCurrentThread
(
)
{
return
gPSMutex
.
IsLockedOnCurrentThread
(
)
;
}
private
:
static
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
gPSMutex
;
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
mLock
;
}
;
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
PSAutoLock
:
:
gPSMutex
{
"
Gecko
Profiler
mutex
"
}
;
typedef
const
PSAutoLock
&
PSLockRef
;
#
define
PS_GET
(
type_
name_
)
\
static
type_
name_
(
PSLockRef
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
return
sInstance
-
>
m
#
#
name_
;
\
}
#
define
PS_GET_LOCKLESS
(
type_
name_
)
\
static
type_
name_
(
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
return
sInstance
-
>
m
#
#
name_
;
\
}
#
define
PS_GET_AND_SET
(
type_
name_
)
\
PS_GET
(
type_
name_
)
\
static
void
Set
#
#
name_
(
PSLockRef
type_
a
#
#
name_
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
sInstance
-
>
m
#
#
name_
=
a
#
#
name_
;
\
}
static
const
size_t
MAX_JS_FRAMES
=
1024
;
using
JsFrameBuffer
=
JS
:
:
ProfilingFrameIterator
:
:
Frame
[
MAX_JS_FRAMES
]
;
class
CorePS
{
private
:
CorePS
(
)
:
mProcessStartTime
(
TimeStamp
:
:
ProcessCreation
(
)
)
mCoreBuffer
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithMutex
)
#
ifdef
USE_LUL_STACKWALK
mLul
(
nullptr
)
#
endif
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
CorePS
must
be
created
from
the
main
thread
"
)
;
}
~
CorePS
(
)
{
}
public
:
static
void
Create
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
!
sInstance
)
;
sInstance
=
new
CorePS
(
)
;
}
static
void
Destroy
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
delete
sInstance
;
sInstance
=
nullptr
;
}
static
bool
Exists
(
)
{
return
!
!
sInstance
;
}
static
void
AddSizeOf
(
PSLockRef
MallocSizeOf
aMallocSizeOf
size_t
&
aProfSize
size_t
&
aLulSize
)
{
MOZ_ASSERT
(
sInstance
)
;
aProfSize
+
=
aMallocSizeOf
(
sInstance
)
;
for
(
auto
&
registeredThread
:
sInstance
-
>
mRegisteredThreads
)
{
aProfSize
+
=
registeredThread
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
for
(
auto
&
registeredPage
:
sInstance
-
>
mRegisteredPages
)
{
aProfSize
+
=
registeredPage
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
if
(
sInstance
-
>
mLul
)
{
aLulSize
+
=
sInstance
-
>
mLul
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
#
endif
}
PS_GET_LOCKLESS
(
TimeStamp
ProcessStartTime
)
PS_GET_LOCKLESS
(
ProfileChunkedBuffer
&
CoreBuffer
)
PS_GET
(
const
Vector
<
UniquePtr
<
RegisteredThread
>
>
&
RegisteredThreads
)
PS_GET
(
JsFrameBuffer
&
JsFrames
)
static
void
AppendRegisteredThread
(
PSLockRef
UniquePtr
<
RegisteredThread
>
&
&
aRegisteredThread
)
{
MOZ_ASSERT
(
sInstance
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mRegisteredThreads
.
append
(
std
:
:
move
(
aRegisteredThread
)
)
)
;
}
static
void
RemoveRegisteredThread
(
PSLockRef
RegisteredThread
*
aRegisteredThread
)
{
MOZ_ASSERT
(
sInstance
)
;
for
(
UniquePtr
<
RegisteredThread
>
&
rt
:
sInstance
-
>
mRegisteredThreads
)
{
if
(
rt
.
get
(
)
=
=
aRegisteredThread
)
{
sInstance
-
>
mRegisteredThreads
.
erase
(
&
rt
)
;
return
;
}
}
}
PS_GET
(
Vector
<
RefPtr
<
PageInformation
>
>
&
RegisteredPages
)
static
void
AppendRegisteredPage
(
PSLockRef
RefPtr
<
PageInformation
>
&
&
aRegisteredPage
)
{
MOZ_ASSERT
(
sInstance
)
;
struct
RegisteredPageComparator
{
PageInformation
*
aA
;
bool
operator
(
)
(
PageInformation
*
aB
)
const
{
return
aA
-
>
Equals
(
aB
)
;
}
}
;
auto
foundPageIter
=
std
:
:
find_if
(
sInstance
-
>
mRegisteredPages
.
begin
(
)
sInstance
-
>
mRegisteredPages
.
end
(
)
RegisteredPageComparator
{
aRegisteredPage
.
get
(
)
}
)
;
if
(
foundPageIter
!
=
sInstance
-
>
mRegisteredPages
.
end
(
)
)
{
if
(
(
*
foundPageIter
)
-
>
Url
(
)
.
EqualsLiteral
(
"
about
:
blank
"
)
)
{
sInstance
-
>
mRegisteredPages
.
erase
(
foundPageIter
)
;
}
else
{
return
;
}
}
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mRegisteredPages
.
append
(
std
:
:
move
(
aRegisteredPage
)
)
)
;
}
static
void
RemoveRegisteredPage
(
PSLockRef
uint64_t
aRegisteredInnerWindowID
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mRegisteredPages
.
eraseIf
(
[
&
]
(
const
RefPtr
<
PageInformation
>
&
rd
)
{
return
rd
-
>
InnerWindowID
(
)
=
=
aRegisteredInnerWindowID
;
}
)
;
}
static
void
ClearRegisteredPages
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mRegisteredPages
.
clear
(
)
;
}
PS_GET
(
const
Vector
<
BaseProfilerCount
*
>
&
Counters
)
static
void
AppendCounter
(
PSLockRef
BaseProfilerCount
*
aCounter
)
{
MOZ_ASSERT
(
sInstance
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mCounters
.
append
(
aCounter
)
)
;
}
static
void
RemoveCounter
(
PSLockRef
BaseProfilerCount
*
aCounter
)
{
if
(
sInstance
)
{
auto
*
counter
=
std
:
:
find
(
sInstance
-
>
mCounters
.
begin
(
)
sInstance
-
>
mCounters
.
end
(
)
aCounter
)
;
MOZ_RELEASE_ASSERT
(
counter
!
=
sInstance
-
>
mCounters
.
end
(
)
)
;
sInstance
-
>
mCounters
.
erase
(
counter
)
;
}
}
#
ifdef
USE_LUL_STACKWALK
static
lul
:
:
LUL
*
Lul
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mLul
.
get
(
)
;
}
static
void
SetLul
(
PSLockRef
UniquePtr
<
lul
:
:
LUL
>
aLul
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mLul
=
std
:
:
move
(
aLul
)
;
}
#
endif
PS_GET_AND_SET
(
const
nsACString
&
ProcessName
)
PS_GET_AND_SET
(
const
nsACString
&
ETLDplus1
)
private
:
static
CorePS
*
sInstance
;
const
TimeStamp
mProcessStartTime
;
ProfileChunkedBuffer
mCoreBuffer
;
Vector
<
UniquePtr
<
RegisteredThread
>
>
mRegisteredThreads
;
Vector
<
RefPtr
<
PageInformation
>
>
mRegisteredPages
;
Vector
<
BaseProfilerCount
*
>
mCounters
;
#
ifdef
USE_LUL_STACKWALK
UniquePtr
<
lul
:
:
LUL
>
mLul
;
#
endif
nsAutoCString
mProcessName
;
nsAutoCString
mETLDplus1
;
JsFrameBuffer
mJsFrames
;
}
;
CorePS
*
CorePS
:
:
sInstance
=
nullptr
;
ProfileChunkedBuffer
&
profiler_get_core_buffer
(
)
{
MOZ_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
return
CorePS
:
:
CoreBuffer
(
)
;
}
class
SamplerThread
;
static
SamplerThread
*
NewSamplerThread
(
PSLockRef
aLock
uint32_t
aGeneration
double
aInterval
bool
aStackWalkEnabled
bool
aNoTimerResolutionChange
)
;
struct
LiveProfiledThreadData
{
RegisteredThread
*
mRegisteredThread
;
UniquePtr
<
ProfiledThreadData
>
mProfiledThreadData
;
}
;
constexpr
static
uint32_t
scBytesPerEntry
=
8
;
class
ActivePS
{
private
:
constexpr
static
uint32_t
scMinimumChunkSize
=
2
*
ProfileBufferChunkManager
:
:
scExpectedMaximumStackSize
;
constexpr
static
uint32_t
scMinimumNumberOfChunks
=
4
;
constexpr
static
uint32_t
scMaximumChunkSize
=
1024
*
1024
;
public
:
constexpr
static
uint32_t
scMinimumBufferSize
=
scMinimumNumberOfChunks
*
scMinimumChunkSize
;
constexpr
static
uint32_t
scMinimumBufferEntries
=
scMinimumBufferSize
/
scBytesPerEntry
;
constexpr
static
uint32_t
scMaximumBufferSize
=
2u
*
1024u
*
1024u
*
1024u
;
constexpr
static
uint32_t
scMaximumBufferEntries
=
scMaximumBufferSize
/
scBytesPerEntry
;
constexpr
static
uint32_t
ClampToAllowedEntries
(
uint32_t
aEntries
)
{
if
(
aEntries
<
=
scMinimumBufferEntries
)
{
return
scMinimumBufferEntries
;
}
if
(
aEntries
>
=
scMaximumBufferEntries
)
{
return
scMaximumBufferEntries
;
}
return
aEntries
;
}
private
:
constexpr
static
uint32_t
ChunkSizeForEntries
(
uint32_t
aEntries
)
{
return
uint32_t
(
std
:
:
min
(
size_t
(
ClampToAllowedEntries
(
aEntries
)
)
*
scBytesPerEntry
/
scMinimumNumberOfChunks
size_t
(
scMaximumChunkSize
)
)
)
;
}
static
uint32_t
AdjustFeatures
(
uint32_t
aFeatures
uint32_t
aFilterCount
)
{
aFeatures
&
=
AvailableFeatures
(
)
;
if
(
aFilterCount
>
0
)
{
aFeatures
|
=
ProfilerFeature
:
:
Threads
;
}
if
(
aFeatures
&
ProfilerFeature
:
:
FileIOAll
)
{
aFeatures
|
=
ProfilerFeature
:
:
MainThreadIO
|
ProfilerFeature
:
:
FileIO
;
}
else
if
(
aFeatures
&
ProfilerFeature
:
:
FileIO
)
{
aFeatures
|
=
ProfilerFeature
:
:
MainThreadIO
;
}
return
aFeatures
;
}
ActivePS
(
PSLockRef
aLock
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
const
Maybe
<
double
>
&
aDuration
)
:
mGeneration
(
sNextGeneration
+
+
)
mCapacity
(
aCapacity
)
mDuration
(
aDuration
)
mInterval
(
aInterval
)
mFeatures
(
AdjustFeatures
(
aFeatures
aFilterCount
)
)
mActiveTabID
(
aActiveTabID
)
mProfileBufferChunkManager
(
size_t
(
ClampToAllowedEntries
(
aCapacity
.
Value
(
)
)
)
*
scBytesPerEntry
ChunkSizeForEntries
(
aCapacity
.
Value
(
)
)
)
mProfileBuffer
(
[
this
]
(
)
-
>
ProfileChunkedBuffer
&
{
CorePS
:
:
CoreBuffer
(
)
.
SetChunkManager
(
mProfileBufferChunkManager
)
;
return
CorePS
:
:
CoreBuffer
(
)
;
}
(
)
)
mSamplerThread
(
NewSamplerThread
(
aLock
mGeneration
aInterval
ProfilerFeature
:
:
HasStackWalk
(
aFeatures
)
ProfilerFeature
:
:
HasNoTimerResolutionChange
(
aFeatures
)
)
)
mInterposeObserver
(
(
ProfilerFeature
:
:
HasMainThreadIO
(
aFeatures
)
|
|
ProfilerFeature
:
:
HasFileIO
(
aFeatures
)
|
|
ProfilerFeature
:
:
HasFileIOAll
(
aFeatures
)
)
?
new
ProfilerIOInterposeObserver
(
)
:
nullptr
)
mIsPaused
(
false
)
mIsSamplingPaused
(
false
)
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_freebsd
)
mWasSamplingPaused
(
false
)
#
endif
{
MOZ_ALWAYS_TRUE
(
mFilters
.
resize
(
aFilterCount
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
mFilters
[
i
]
=
aFilters
[
i
]
;
}
#
if
!
defined
(
RELEASE_OR_BETA
)
if
(
mInterposeObserver
)
{
if
(
NS_IsMainThread
(
)
)
{
IOInterposer
:
:
Init
(
)
;
IOInterposer
:
:
Register
(
IOInterposeObserver
:
:
OpAll
mInterposeObserver
)
;
}
else
{
RefPtr
<
ProfilerIOInterposeObserver
>
observer
=
mInterposeObserver
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ActivePS
:
:
ActivePS
"
[
=
]
(
)
{
IOInterposer
:
:
Init
(
)
;
IOInterposer
:
:
Register
(
IOInterposeObserver
:
:
OpAll
observer
)
;
}
)
)
;
}
}
#
endif
}
~
ActivePS
(
)
{
#
if
!
defined
(
RELEASE_OR_BETA
)
if
(
mInterposeObserver
)
{
if
(
NS_IsMainThread
(
)
)
{
IOInterposer
:
:
Unregister
(
IOInterposeObserver
:
:
OpAll
mInterposeObserver
)
;
}
else
{
RefPtr
<
ProfilerIOInterposeObserver
>
observer
=
mInterposeObserver
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ActivePS
:
:
~
ActivePS
"
[
=
]
(
)
{
IOInterposer
:
:
Unregister
(
IOInterposeObserver
:
:
OpAll
observer
)
;
}
)
)
;
}
}
#
endif
CorePS
:
:
CoreBuffer
(
)
.
ResetChunkManager
(
)
;
}
bool
ThreadSelected
(
const
char
*
aThreadName
)
{
if
(
mFilters
.
empty
(
)
)
{
return
true
;
}
std
:
:
string
name
=
aThreadName
;
std
:
:
transform
(
name
.
begin
(
)
name
.
end
(
)
name
.
begin
(
)
:
:
tolower
)
;
for
(
uint32_t
i
=
0
;
i
<
mFilters
.
length
(
)
;
+
+
i
)
{
std
:
:
string
filter
=
mFilters
[
i
]
;
if
(
filter
=
=
"
*
"
)
{
return
true
;
}
std
:
:
transform
(
filter
.
begin
(
)
filter
.
end
(
)
filter
.
begin
(
)
:
:
tolower
)
;
if
(
name
.
find
(
filter
)
!
=
std
:
:
string
:
:
npos
)
{
return
true
;
}
if
(
filter
.
find
(
"
pid
:
"
)
=
=
0
)
{
std
:
:
string
mypid
=
std
:
:
to_string
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
;
if
(
filter
.
compare
(
4
std
:
:
string
:
:
npos
mypid
)
=
=
0
)
{
return
true
;
}
}
}
return
false
;
}
public
:
static
void
Create
(
PSLockRef
aLock
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
const
Maybe
<
double
>
&
aDuration
)
{
MOZ_ASSERT
(
!
sInstance
)
;
sInstance
=
new
ActivePS
(
aLock
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aActiveTabID
aDuration
)
;
}
[
[
nodiscard
]
]
static
SamplerThread
*
Destroy
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
auto
samplerThread
=
sInstance
-
>
mSamplerThread
;
delete
sInstance
;
sInstance
=
nullptr
;
return
samplerThread
;
}
static
bool
Exists
(
PSLockRef
)
{
return
!
!
sInstance
;
}
static
bool
Equals
(
PSLockRef
PowerOfTwo32
aCapacity
const
Maybe
<
double
>
&
aDuration
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
)
{
MOZ_ASSERT
(
sInstance
)
;
if
(
sInstance
-
>
mCapacity
!
=
aCapacity
|
|
sInstance
-
>
mDuration
!
=
aDuration
|
|
sInstance
-
>
mInterval
!
=
aInterval
|
|
sInstance
-
>
mFeatures
!
=
aFeatures
|
|
sInstance
-
>
mFilters
.
length
(
)
!
=
aFilterCount
|
|
sInstance
-
>
mActiveTabID
!
=
aActiveTabID
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
sInstance
-
>
mFilters
.
length
(
)
;
+
+
i
)
{
if
(
strcmp
(
sInstance
-
>
mFilters
[
i
]
.
c_str
(
)
aFilters
[
i
]
)
!
=
0
)
{
return
false
;
}
}
return
true
;
}
static
size_t
SizeOf
(
PSLockRef
MallocSizeOf
aMallocSizeOf
)
{
MOZ_ASSERT
(
sInstance
)
;
size_t
n
=
aMallocSizeOf
(
sInstance
)
;
n
+
=
sInstance
-
>
mProfileBuffer
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
return
n
;
}
static
bool
ShouldProfileThread
(
PSLockRef
aLock
const
ThreadRegistrationInfo
&
aInfo
)
{
MOZ_ASSERT
(
sInstance
)
;
return
(
(
aInfo
.
IsMainThread
(
)
|
|
FeatureThreads
(
aLock
)
)
&
&
sInstance
-
>
ThreadSelected
(
aInfo
.
Name
(
)
)
)
;
}
[
[
nodiscard
]
]
static
bool
AppendPostSamplingCallback
(
PSLockRef
PostSamplingCallback
&
&
aCallback
)
;
static
void
WriteActiveConfiguration
(
PSLockRef
aLock
JSONWriter
&
aWriter
const
Span
<
const
char
>
&
aPropertyName
=
MakeStringSpan
(
"
"
)
)
{
if
(
!
sInstance
)
{
if
(
!
aPropertyName
.
empty
(
)
)
{
aWriter
.
NullProperty
(
aPropertyName
)
;
}
else
{
aWriter
.
NullElement
(
)
;
}
return
;
}
;
if
(
!
aPropertyName
.
empty
(
)
)
{
aWriter
.
StartObjectProperty
(
aPropertyName
)
;
}
else
{
aWriter
.
StartObjectElement
(
)
;
}
{
aWriter
.
StartArrayProperty
(
"
features
"
aWriter
.
SingleLineStyle
)
;
#
define
WRITE_ACTIVE_FEATURES
(
n_
str_
Name_
desc_
)
\
if
(
profiler_feature_active
(
ProfilerFeature
:
:
Name_
)
)
{
\
aWriter
.
StringElement
(
str_
)
;
\
}
PROFILER_FOR_EACH_FEATURE
(
WRITE_ACTIVE_FEATURES
)
#
undef
WRITE_ACTIVE_FEATURES
aWriter
.
EndArray
(
)
;
}
{
aWriter
.
StartArrayProperty
(
"
threads
"
aWriter
.
SingleLineStyle
)
;
for
(
const
auto
&
filter
:
sInstance
-
>
mFilters
)
{
aWriter
.
StringElement
(
filter
)
;
}
aWriter
.
EndArray
(
)
;
}
{
aWriter
.
DoubleProperty
(
"
interval
"
sInstance
-
>
mInterval
)
;
aWriter
.
IntProperty
(
"
capacity
"
sInstance
-
>
mCapacity
.
Value
(
)
)
;
if
(
sInstance
-
>
mDuration
)
{
aWriter
.
DoubleProperty
(
"
duration
"
sInstance
-
>
mDuration
.
value
(
)
)
;
}
aWriter
.
DoubleProperty
(
"
activeTabID
"
sInstance
-
>
mActiveTabID
)
;
}
aWriter
.
EndObject
(
)
;
}
PS_GET
(
uint32_t
Generation
)
PS_GET
(
PowerOfTwo32
Capacity
)
PS_GET
(
Maybe
<
double
>
Duration
)
PS_GET
(
double
Interval
)
PS_GET
(
uint32_t
Features
)
PS_GET
(
uint64_t
ActiveTabID
)
#
define
PS_GET_FEATURE
(
n_
str_
Name_
desc_
)
\
static
bool
Feature
#
#
Name_
(
PSLockRef
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
return
ProfilerFeature
:
:
Has
#
#
Name_
(
sInstance
-
>
mFeatures
)
;
\
}
PROFILER_FOR_EACH_FEATURE
(
PS_GET_FEATURE
)
#
undef
PS_GET_FEATURE
static
uint32_t
JSFlags
(
PSLockRef
aLock
)
{
uint32_t
Flags
=
0
;
Flags
|
=
FeatureJS
(
aLock
)
?
uint32_t
(
JSInstrumentationFlags
:
:
StackSampling
)
:
0
;
Flags
|
=
FeatureJSTracer
(
aLock
)
?
uint32_t
(
JSInstrumentationFlags
:
:
TraceLogging
)
:
0
;
Flags
|
=
FeatureJSAllocations
(
aLock
)
?
uint32_t
(
JSInstrumentationFlags
:
:
Allocations
)
:
0
;
return
Flags
;
}
PS_GET
(
const
Vector
<
std
:
:
string
>
&
Filters
)
static
ProfileBufferChunkManagerWithLocalLimit
&
ControlledChunkManager
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mProfileBufferChunkManager
;
}
static
void
FulfillChunkRequests
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mProfileBufferChunkManager
.
FulfillChunkRequests
(
)
;
}
static
ProfileBuffer
&
Buffer
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mProfileBuffer
;
}
static
const
Vector
<
LiveProfiledThreadData
>
&
LiveProfiledThreads
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mLiveProfiledThreads
;
}
static
Vector
<
std
:
:
pair
<
RegisteredThread
*
ProfiledThreadData
*
>
>
ProfiledThreads
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
Vector
<
std
:
:
pair
<
RegisteredThread
*
ProfiledThreadData
*
>
>
array
;
MOZ_RELEASE_ASSERT
(
array
.
initCapacity
(
sInstance
-
>
mLiveProfiledThreads
.
length
(
)
+
sInstance
-
>
mDeadProfiledThreads
.
length
(
)
)
)
;
for
(
auto
&
t
:
sInstance
-
>
mLiveProfiledThreads
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
std
:
:
make_pair
(
t
.
mRegisteredThread
t
.
mProfiledThreadData
.
get
(
)
)
)
)
;
}
for
(
auto
&
t
:
sInstance
-
>
mDeadProfiledThreads
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
std
:
:
make_pair
(
(
RegisteredThread
*
)
nullptr
t
.
get
(
)
)
)
)
;
}
std
:
:
sort
(
array
.
begin
(
)
array
.
end
(
)
[
]
(
const
std
:
:
pair
<
RegisteredThread
*
ProfiledThreadData
*
>
&
a
const
std
:
:
pair
<
RegisteredThread
*
ProfiledThreadData
*
>
&
b
)
{
return
a
.
second
-
>
Info
(
)
.
RegisterTime
(
)
<
b
.
second
-
>
Info
(
)
.
RegisterTime
(
)
;
}
)
;
return
array
;
}
static
Vector
<
RefPtr
<
PageInformation
>
>
ProfiledPages
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
Vector
<
RefPtr
<
PageInformation
>
>
array
;
for
(
auto
&
d
:
CorePS
:
:
RegisteredPages
(
aLock
)
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
d
)
)
;
}
for
(
auto
&
d
:
sInstance
-
>
mDeadProfiledPages
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
d
)
)
;
}
return
array
;
}
static
ProfiledThreadData
*
GetProfiledThreadData
(
PSLockRef
RegisteredThread
*
aRegisteredThread
)
{
MOZ_ASSERT
(
sInstance
)
;
for
(
const
LiveProfiledThreadData
&
thread
:
sInstance
-
>
mLiveProfiledThreads
)
{
if
(
thread
.
mRegisteredThread
=
=
aRegisteredThread
)
{
return
thread
.
mProfiledThreadData
.
get
(
)
;
}
}
return
nullptr
;
}
static
ProfiledThreadData
*
AddLiveProfiledThread
(
PSLockRef
RegisteredThread
*
aRegisteredThread
UniquePtr
<
ProfiledThreadData
>
&
&
aProfiledThreadData
)
{
MOZ_ASSERT
(
sInstance
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mLiveProfiledThreads
.
append
(
LiveProfiledThreadData
{
aRegisteredThread
std
:
:
move
(
aProfiledThreadData
)
}
)
)
;
return
sInstance
-
>
mLiveProfiledThreads
.
back
(
)
.
mProfiledThreadData
.
get
(
)
;
}
static
void
UnregisterThread
(
PSLockRef
aLockRef
RegisteredThread
*
aRegisteredThread
)
{
MOZ_ASSERT
(
sInstance
)
;
DiscardExpiredDeadProfiledThreads
(
aLockRef
)
;
for
(
size_t
i
=
0
;
i
<
sInstance
-
>
mLiveProfiledThreads
.
length
(
)
;
i
+
+
)
{
LiveProfiledThreadData
&
thread
=
sInstance
-
>
mLiveProfiledThreads
[
i
]
;
if
(
thread
.
mRegisteredThread
=
=
aRegisteredThread
)
{
thread
.
mProfiledThreadData
-
>
NotifyUnregistered
(
sInstance
-
>
mProfileBuffer
.
BufferRangeEnd
(
)
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mDeadProfiledThreads
.
append
(
std
:
:
move
(
thread
.
mProfiledThreadData
)
)
)
;
sInstance
-
>
mLiveProfiledThreads
.
erase
(
&
sInstance
-
>
mLiveProfiledThreads
[
i
]
)
;
return
;
}
}
}
PS_GET_AND_SET
(
bool
IsPaused
)
static
bool
IsSamplingPaused
(
PSLockRef
lock
)
{
MOZ_ASSERT
(
sInstance
)
;
return
IsPaused
(
lock
)
|
|
sInstance
-
>
mIsSamplingPaused
;
}
static
void
SetIsSamplingPaused
(
PSLockRef
bool
aIsSamplingPaused
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mIsSamplingPaused
=
aIsSamplingPaused
;
}
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_freebsd
)
PS_GET_AND_SET
(
bool
WasSamplingPaused
)
#
endif
static
void
DiscardExpiredDeadProfiledThreads
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
uint64_t
bufferRangeStart
=
sInstance
-
>
mProfileBuffer
.
BufferRangeStart
(
)
;
sInstance
-
>
mDeadProfiledThreads
.
eraseIf
(
[
bufferRangeStart
]
(
const
UniquePtr
<
ProfiledThreadData
>
&
aProfiledThreadData
)
{
Maybe
<
uint64_t
>
bufferPosition
=
aProfiledThreadData
-
>
BufferPositionWhenUnregistered
(
)
;
MOZ_RELEASE_ASSERT
(
bufferPosition
"
should
have
unregistered
this
thread
"
)
;
return
*
bufferPosition
<
bufferRangeStart
;
}
)
;
}
static
void
UnregisterPage
(
PSLockRef
aLock
uint64_t
aRegisteredInnerWindowID
)
{
MOZ_ASSERT
(
sInstance
)
;
auto
&
registeredPages
=
CorePS
:
:
RegisteredPages
(
aLock
)
;
for
(
size_t
i
=
0
;
i
<
registeredPages
.
length
(
)
;
i
+
+
)
{
RefPtr
<
PageInformation
>
&
page
=
registeredPages
[
i
]
;
if
(
page
-
>
InnerWindowID
(
)
=
=
aRegisteredInnerWindowID
)
{
page
-
>
NotifyUnregistered
(
sInstance
-
>
mProfileBuffer
.
BufferRangeEnd
(
)
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mDeadProfiledPages
.
append
(
std
:
:
move
(
page
)
)
)
;
registeredPages
.
erase
(
&
registeredPages
[
i
-
-
]
)
;
}
}
}
static
void
DiscardExpiredPages
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
uint64_t
bufferRangeStart
=
sInstance
-
>
mProfileBuffer
.
BufferRangeStart
(
)
;
sInstance
-
>
mDeadProfiledPages
.
eraseIf
(
[
bufferRangeStart
]
(
const
RefPtr
<
PageInformation
>
&
aProfiledPage
)
{
Maybe
<
uint64_t
>
bufferPosition
=
aProfiledPage
-
>
BufferPositionWhenUnregistered
(
)
;
MOZ_RELEASE_ASSERT
(
bufferPosition
"
should
have
unregistered
this
page
"
)
;
return
*
bufferPosition
<
bufferRangeStart
;
}
)
;
}
static
void
ClearUnregisteredPages
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mDeadProfiledPages
.
clear
(
)
;
}
static
void
ClearExpiredExitProfiles
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
uint64_t
bufferRangeStart
=
sInstance
-
>
mProfileBuffer
.
BufferRangeStart
(
)
;
if
(
sInstance
-
>
mBaseProfileThreads
&
&
sInstance
-
>
mGeckoIndexWhenBaseProfileAdded
.
ConvertToProfileBufferIndex
(
)
<
CorePS
:
:
CoreBuffer
(
)
.
GetState
(
)
.
mRangeStart
)
{
DEBUG_LOG
(
"
ClearExpiredExitProfiles
(
)
-
Discarding
base
profile
%
p
"
sInstance
-
>
mBaseProfileThreads
.
get
(
)
)
;
sInstance
-
>
mBaseProfileThreads
.
reset
(
)
;
}
sInstance
-
>
mExitProfiles
.
eraseIf
(
[
bufferRangeStart
]
(
const
ExitProfile
&
aExitProfile
)
{
return
aExitProfile
.
mBufferPositionAtGatherTime
<
bufferRangeStart
;
}
)
;
}
static
void
AddBaseProfileThreads
(
PSLockRef
aLock
UniquePtr
<
char
[
]
>
aBaseProfileThreads
)
{
MOZ_ASSERT
(
sInstance
)
;
DEBUG_LOG
(
"
AddBaseProfileThreads
(
%
p
)
"
aBaseProfileThreads
.
get
(
)
)
;
sInstance
-
>
mBaseProfileThreads
=
std
:
:
move
(
aBaseProfileThreads
)
;
sInstance
-
>
mGeckoIndexWhenBaseProfileAdded
=
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
CorePS
:
:
CoreBuffer
(
)
.
GetState
(
)
.
mRangeEnd
)
;
}
static
UniquePtr
<
char
[
]
>
MoveBaseProfileThreads
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
ClearExpiredExitProfiles
(
aLock
)
;
DEBUG_LOG
(
"
MoveBaseProfileThreads
(
)
-
Consuming
base
profile
%
p
"
sInstance
-
>
mBaseProfileThreads
.
get
(
)
)
;
return
std
:
:
move
(
sInstance
-
>
mBaseProfileThreads
)
;
}
static
void
AddExitProfile
(
PSLockRef
aLock
const
nsCString
&
aExitProfile
)
{
MOZ_ASSERT
(
sInstance
)
;
ClearExpiredExitProfiles
(
aLock
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mExitProfiles
.
append
(
ExitProfile
{
aExitProfile
sInstance
-
>
mProfileBuffer
.
BufferRangeEnd
(
)
}
)
)
;
}
static
Vector
<
nsCString
>
MoveExitProfiles
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
ClearExpiredExitProfiles
(
aLock
)
;
Vector
<
nsCString
>
profiles
;
MOZ_RELEASE_ASSERT
(
profiles
.
initCapacity
(
sInstance
-
>
mExitProfiles
.
length
(
)
)
)
;
for
(
auto
&
profile
:
sInstance
-
>
mExitProfiles
)
{
MOZ_RELEASE_ASSERT
(
profiles
.
append
(
std
:
:
move
(
profile
.
mJSON
)
)
)
;
}
sInstance
-
>
mExitProfiles
.
clear
(
)
;
return
profiles
;
}
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
static
void
SetMemoryCounter
(
const
BaseProfilerCount
*
aMemoryCounter
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mMemoryCounter
=
aMemoryCounter
;
}
static
bool
IsMemoryCounter
(
const
BaseProfilerCount
*
aMemoryCounter
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mMemoryCounter
=
=
aMemoryCounter
;
}
#
endif
private
:
static
ActivePS
*
sInstance
;
const
uint32_t
mGeneration
;
static
uint32_t
sNextGeneration
;
const
PowerOfTwo32
mCapacity
;
const
Maybe
<
double
>
mDuration
;
const
double
mInterval
;
const
uint32_t
mFeatures
;
Vector
<
std
:
:
string
>
mFilters
;
const
uint64_t
mActiveTabID
;
ProfileBufferChunkManagerWithLocalLimit
mProfileBufferChunkManager
;
ProfileBuffer
mProfileBuffer
;
Vector
<
LiveProfiledThreadData
>
mLiveProfiledThreads
;
Vector
<
UniquePtr
<
ProfiledThreadData
>
>
mDeadProfiledThreads
;
Vector
<
RefPtr
<
PageInformation
>
>
mDeadProfiledPages
;
SamplerThread
*
const
mSamplerThread
;
RefPtr
<
ProfilerIOInterposeObserver
>
mInterposeObserver
;
bool
mIsPaused
;
bool
mIsSamplingPaused
;
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_freebsd
)
bool
mWasSamplingPaused
;
#
endif
UniquePtr
<
char
[
]
>
mBaseProfileThreads
;
ProfileBufferBlockIndex
mGeckoIndexWhenBaseProfileAdded
;
struct
ExitProfile
{
nsCString
mJSON
;
uint64_t
mBufferPositionAtGatherTime
;
}
;
Vector
<
ExitProfile
>
mExitProfiles
;
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
Atomic
<
const
BaseProfilerCount
*
>
mMemoryCounter
;
#
endif
}
;
ActivePS
*
ActivePS
:
:
sInstance
=
nullptr
;
uint32_t
ActivePS
:
:
sNextGeneration
=
0
;
#
undef
PS_GET
#
undef
PS_GET_LOCKLESS
#
undef
PS_GET_AND_SET
using
ProfilerStateChangeMutex
=
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
;
using
ProfilerStateChangeLock
=
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
;
static
ProfilerStateChangeMutex
gProfilerStateChangeMutex
;
struct
IdentifiedProfilingStateChangeCallback
{
ProfilingStateSet
mProfilingStateSet
;
ProfilingStateChangeCallback
mProfilingStateChangeCallback
;
uintptr_t
mUniqueIdentifier
;
explicit
IdentifiedProfilingStateChangeCallback
(
ProfilingStateSet
aProfilingStateSet
ProfilingStateChangeCallback
&
&
aProfilingStateChangeCallback
uintptr_t
aUniqueIdentifier
)
:
mProfilingStateSet
(
aProfilingStateSet
)
mProfilingStateChangeCallback
(
aProfilingStateChangeCallback
)
mUniqueIdentifier
(
aUniqueIdentifier
)
{
}
}
;
using
IdentifiedProfilingStateChangeCallbackUPtr
=
UniquePtr
<
IdentifiedProfilingStateChangeCallback
>
;
static
Vector
<
IdentifiedProfilingStateChangeCallbackUPtr
>
mIdentifiedProfilingStateChangeCallbacks
;
void
profiler_add_state_change_callback
(
ProfilingStateSet
aProfilingStateSet
ProfilingStateChangeCallback
&
&
aCallback
uintptr_t
aUniqueIdentifier
)
{
MOZ_ASSERT
(
!
PSAutoLock
:
:
IsLockedOnCurrentThread
(
)
)
;
ProfilerStateChangeLock
lock
(
gProfilerStateChangeMutex
)
;
#
ifdef
DEBUG
if
(
aUniqueIdentifier
!
=
0
)
{
for
(
const
IdentifiedProfilingStateChangeCallbackUPtr
&
idedCallback
:
mIdentifiedProfilingStateChangeCallbacks
)
{
MOZ_ASSERT
(
idedCallback
-
>
mUniqueIdentifier
!
=
aUniqueIdentifier
)
;
}
}
#
endif
if
(
aProfilingStateSet
.
contains
(
ProfilingState
:
:
AlreadyActive
)
&
&
profiler_is_active
(
)
)
{
aCallback
(
ProfilingState
:
:
AlreadyActive
)
;
}
(
void
)
mIdentifiedProfilingStateChangeCallbacks
.
append
(
MakeUnique
<
IdentifiedProfilingStateChangeCallback
>
(
aProfilingStateSet
std
:
:
move
(
aCallback
)
aUniqueIdentifier
)
)
;
}
void
profiler_remove_state_change_callback
(
uintptr_t
aUniqueIdentifier
)
{
MOZ_ASSERT
(
aUniqueIdentifier
!
=
0
)
;
if
(
aUniqueIdentifier
=
=
0
)
{
return
;
}
MOZ_ASSERT
(
!
PSAutoLock
:
:
IsLockedOnCurrentThread
(
)
)
;
ProfilerStateChangeLock
lock
(
gProfilerStateChangeMutex
)
;
mIdentifiedProfilingStateChangeCallbacks
.
eraseIf
(
[
aUniqueIdentifier
]
(
const
IdentifiedProfilingStateChangeCallbackUPtr
&
aIdedCallback
)
{
if
(
aIdedCallback
-
>
mUniqueIdentifier
!
=
aUniqueIdentifier
)
{
return
false
;
}
if
(
aIdedCallback
-
>
mProfilingStateSet
.
contains
(
ProfilingState
:
:
RemovingCallback
)
)
{
aIdedCallback
-
>
mProfilingStateChangeCallback
(
ProfilingState
:
:
RemovingCallback
)
;
}
return
true
;
}
)
;
}
static
void
invoke_profiler_state_change_callbacks
(
ProfilingState
aProfilingState
)
{
MOZ_ASSERT
(
!
PSAutoLock
:
:
IsLockedOnCurrentThread
(
)
)
;
ProfilerStateChangeLock
lock
(
gProfilerStateChangeMutex
)
;
for
(
const
IdentifiedProfilingStateChangeCallbackUPtr
&
idedCallback
:
mIdentifiedProfilingStateChangeCallbacks
)
{
if
(
idedCallback
-
>
mProfilingStateSet
.
contains
(
aProfilingState
)
)
{
idedCallback
-
>
mProfilingStateChangeCallback
(
aProfilingState
)
;
}
}
}
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
RacyFeatures
:
:
sActiveAndFeatures
(
0
)
;
class
TLSRegisteredThread
{
public
:
static
void
Init
(
)
{
MOZ_ASSERT
(
sState
=
=
State
:
:
Uninitialized
"
Already
initialized
"
)
;
sState
=
sRegisteredThread
.
init
(
)
?
State
:
:
Initialized
:
State
:
:
Unavailable
;
}
static
bool
IsTLSInited
(
)
{
MOZ_ASSERT
(
sState
!
=
State
:
:
Uninitialized
"
TLSRegisteredThread
should
only
be
accessed
after
Init
(
)
"
)
;
return
sState
=
=
State
:
:
Initialized
;
}
static
class
RegisteredThread
*
RegisteredThread
(
PSLockRef
)
{
if
(
!
IsTLSInited
(
)
)
{
return
nullptr
;
}
return
sRegisteredThread
.
get
(
)
;
}
static
class
RacyRegisteredThread
*
RacyRegisteredThread
(
)
{
if
(
!
IsTLSInited
(
)
)
{
return
nullptr
;
}
class
RegisteredThread
*
registeredThread
=
sRegisteredThread
.
get
(
)
;
return
registeredThread
?
&
registeredThread
-
>
RacyRegisteredThread
(
)
:
nullptr
;
}
static
void
SetRegisteredThread
(
PSLockRef
class
RegisteredThread
*
aRegisteredThread
)
{
if
(
!
IsTLSInited
(
)
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
aRegisteredThread
"
Use
ResetRegisteredThread
(
)
instead
of
SetRegisteredThread
(
nullptr
)
"
)
;
sRegisteredThread
.
set
(
aRegisteredThread
)
;
}
static
void
ResetRegisteredThread
(
PSLockRef
)
{
if
(
!
IsTLSInited
(
)
)
{
return
;
}
sRegisteredThread
.
set
(
nullptr
)
;
}
private
:
enum
class
State
{
Uninitialized
=
0
Initialized
Unavailable
}
;
static
State
sState
;
static
MOZ_THREAD_LOCAL
(
class
RegisteredThread
*
)
sRegisteredThread
;
}
;
TLSRegisteredThread
:
:
State
TLSRegisteredThread
:
:
sState
;
MOZ_THREAD_LOCAL
(
RegisteredThread
*
)
TLSRegisteredThread
:
:
sRegisteredThread
;
static
const
char
*
const
kMainThreadName
=
"
GeckoMain
"
;
class
Registers
{
public
:
Registers
(
)
:
mPC
{
nullptr
}
mSP
{
nullptr
}
mFP
{
nullptr
}
mLR
{
nullptr
}
{
}
#
if
defined
(
HAVE_NATIVE_UNWIND
)
void
SyncPopulate
(
)
;
#
endif
void
Clear
(
)
{
memset
(
this
0
sizeof
(
*
this
)
)
;
}
Address
mPC
;
Address
mSP
;
Address
mFP
;
Address
mLR
;
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
ucontext_t
*
mContext
;
#
endif
}
;
static
const
size_t
MAX_NATIVE_FRAMES
=
1024
;
struct
NativeStack
{
void
*
mPCs
[
MAX_NATIVE_FRAMES
]
;
void
*
mSPs
[
MAX_NATIVE_FRAMES
]
;
size_t
mCount
;
NativeStack
(
)
:
mPCs
(
)
mSPs
(
)
mCount
(
0
)
{
}
}
;
Atomic
<
bool
>
WALKING_JS_STACK
(
false
)
;
struct
AutoWalkJSStack
{
bool
walkAllowed
;
AutoWalkJSStack
(
)
:
walkAllowed
(
false
)
{
walkAllowed
=
WALKING_JS_STACK
.
compareExchange
(
false
true
)
;
}
~
AutoWalkJSStack
(
)
{
if
(
walkAllowed
)
{
WALKING_JS_STACK
=
false
;
}
}
}
;
class
StackWalkControl
{
public
:
struct
ResumePoint
{
void
*
resumeSp
;
void
*
resumeBp
;
void
*
resumePc
;
}
;
#
if
(
(
defined
(
USE_MOZ_STACK_WALK
)
|
|
defined
(
USE_FRAME_POINTER_STACK_WALK
)
)
&
&
\
defined
(
GP_ARCH_amd64
)
)
public
:
static
constexpr
bool
scIsSupported
=
true
;
void
Clear
(
)
{
mResumePointCount
=
0
;
}
size_t
ResumePointCount
(
)
const
{
return
mResumePointCount
;
}
static
constexpr
size_t
MaxResumePointCount
(
)
{
return
scMaxResumePointCount
;
}
void
AddResumePoint
(
ResumePoint
&
&
aResumePoint
)
{
MOZ_ASSERT_IF
(
!
aResumePoint
.
resumeSp
!
aResumePoint
.
resumeBp
)
;
MOZ_ASSERT_IF
(
!
aResumePoint
.
resumeSp
!
aResumePoint
.
resumePc
)
;
MOZ_ASSERT_IF
(
aResumePoint
.
resumeBp
aResumePoint
.
resumeSp
)
;
MOZ_ASSERT_IF
(
aResumePoint
.
resumePc
aResumePoint
.
resumeSp
)
;
if
(
mResumePointCount
<
scMaxResumePointCount
)
{
mResumePoint
[
mResumePointCount
]
=
std
:
:
move
(
aResumePoint
)
;
+
+
mResumePointCount
;
}
}
const
ResumePoint
*
begin
(
)
const
{
return
&
mResumePoint
[
0
]
;
}
const
ResumePoint
*
end
(
)
const
{
return
&
mResumePoint
[
mResumePointCount
]
;
}
const
ResumePoint
*
GetResumePointCallingSp
(
void
*
aSp
)
const
{
const
ResumePoint
*
callingResumePoint
=
nullptr
;
for
(
const
ResumePoint
&
resumePoint
:
*
this
)
{
if
(
resumePoint
.
resumeSp
&
&
resumePoint
.
resumeSp
>
aSp
&
&
(
!
callingResumePoint
|
|
resumePoint
.
resumeSp
<
callingResumePoint
-
>
resumeSp
)
)
{
callingResumePoint
=
&
resumePoint
;
}
}
return
callingResumePoint
;
}
private
:
size_t
mResumePointCount
=
0
;
static
constexpr
size_t
scMaxResumePointCount
=
32
;
ResumePoint
mResumePoint
[
scMaxResumePointCount
]
;
#
else
public
:
static
constexpr
bool
scIsSupported
=
false
;
void
Clear
(
)
;
size_t
ResumePointCount
(
)
;
static
constexpr
size_t
MaxResumePointCount
(
)
;
void
AddResumePoint
(
ResumePoint
&
&
aResumePoint
)
;
const
ResumePoint
*
begin
(
)
const
;
const
ResumePoint
*
end
(
)
const
;
const
ResumePoint
*
GetResumePointCallingSp
(
void
*
aSp
)
const
;
#
endif
}
;
static
uint32_t
ExtractJsFrames
(
bool
aIsSynchronous
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
ProfilerStackCollector
&
aCollector
JsFrameBuffer
aJsFrames
StackWalkControl
*
aStackWalkControlIfSupported
)
{
uint32_t
jsFramesCount
=
0
;
JSContext
*
context
=
aThreadData
.
GetJSContext
(
)
;
if
(
context
&
&
JS
:
:
IsProfilingEnabledForContext
(
context
)
)
{
AutoWalkJSStack
autoWalkJSStack
;
if
(
autoWalkJSStack
.
walkAllowed
)
{
JS
:
:
ProfilingFrameIterator
:
:
RegisterState
registerState
;
registerState
.
pc
=
aRegs
.
mPC
;
registerState
.
sp
=
aRegs
.
mSP
;
registerState
.
lr
=
aRegs
.
mLR
;
registerState
.
fp
=
aRegs
.
mFP
;
Maybe
<
uint64_t
>
samplePosInBuffer
;
if
(
!
aIsSynchronous
)
{
samplePosInBuffer
=
aCollector
.
SamplePositionInBuffer
(
)
;
}
for
(
JS
:
:
ProfilingFrameIterator
jsIter
(
context
registerState
samplePosInBuffer
)
;
!
jsIter
.
done
(
)
;
+
+
jsIter
)
{
if
(
aIsSynchronous
|
|
jsIter
.
isWasm
(
)
)
{
jsFramesCount
+
=
jsIter
.
extractStack
(
aJsFrames
jsFramesCount
MAX_JS_FRAMES
)
;
if
(
jsFramesCount
=
=
MAX_JS_FRAMES
)
{
break
;
}
}
else
{
Maybe
<
JS
:
:
ProfilingFrameIterator
:
:
Frame
>
frame
=
jsIter
.
getPhysicalFrameWithoutLabel
(
)
;
if
(
frame
.
isSome
(
)
)
{
aJsFrames
[
jsFramesCount
+
+
]
=
std
:
:
move
(
frame
)
.
ref
(
)
;
if
(
jsFramesCount
=
=
MAX_JS_FRAMES
)
{
break
;
}
}
}
if
constexpr
(
StackWalkControl
:
:
scIsSupported
)
{
if
(
aStackWalkControlIfSupported
)
{
jsIter
.
getCppEntryRegisters
(
)
.
apply
(
[
&
]
(
const
JS
:
:
ProfilingFrameIterator
:
:
RegisterState
&
aCppEntry
)
{
StackWalkControl
:
:
ResumePoint
resumePoint
;
resumePoint
.
resumeSp
=
aCppEntry
.
sp
;
resumePoint
.
resumeBp
=
aCppEntry
.
fp
;
resumePoint
.
resumePc
=
aCppEntry
.
pc
;
aStackWalkControlIfSupported
-
>
AddResumePoint
(
std
:
:
move
(
resumePoint
)
)
;
}
)
;
}
}
else
{
MOZ_ASSERT
(
!
aStackWalkControlIfSupported
"
aStackWalkControlIfSupported
should
be
null
when
"
"
!
StackWalkControl
:
:
scIsSupported
"
)
;
(
void
)
aStackWalkControlIfSupported
;
}
}
}
}
return
jsFramesCount
;
}
static
void
MergeStacks
(
uint32_t
aFeatures
bool
aIsSynchronous
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
const
NativeStack
&
aNativeStack
ProfilerStackCollector
&
aCollector
JsFrameBuffer
aJsFrames
uint32_t
aJsFramesCount
)
{
const
ProfilingStack
&
profilingStack
=
aThreadData
.
ProfilingStackCRef
(
)
;
const
js
:
:
ProfilingStackFrame
*
profilingStackFrames
=
profilingStack
.
frames
;
uint32_t
profilingStackFrameCount
=
profilingStack
.
stackSize
(
)
;
uint32_t
profilingStackIndex
=
0
;
int32_t
jsIndex
=
aJsFramesCount
-
1
;
int32_t
nativeIndex
=
aNativeStack
.
mCount
-
1
;
uint8_t
*
lastLabelFrameStackAddr
=
nullptr
;
uint8_t
*
jitEndStackAddr
=
nullptr
;
while
(
profilingStackIndex
!
=
profilingStackFrameCount
|
|
jsIndex
>
=
0
|
|
nativeIndex
>
=
0
)
{
uint8_t
*
profilingStackAddr
=
nullptr
;
uint8_t
*
jsStackAddr
=
nullptr
;
uint8_t
*
nativeStackAddr
=
nullptr
;
uint8_t
*
jsActivationAddr
=
nullptr
;
if
(
profilingStackIndex
!
=
profilingStackFrameCount
)
{
const
js
:
:
ProfilingStackFrame
&
profilingStackFrame
=
profilingStackFrames
[
profilingStackIndex
]
;
if
(
profilingStackFrame
.
isLabelFrame
(
)
|
|
profilingStackFrame
.
isSpMarkerFrame
(
)
)
{
lastLabelFrameStackAddr
=
(
uint8_t
*
)
profilingStackFrame
.
stackAddress
(
)
;
}
if
(
profilingStackFrame
.
isOSRFrame
(
)
)
{
profilingStackIndex
+
+
;
continue
;
}
MOZ_ASSERT
(
lastLabelFrameStackAddr
)
;
profilingStackAddr
=
lastLabelFrameStackAddr
;
}
if
(
jsIndex
>
=
0
)
{
jsStackAddr
=
(
uint8_t
*
)
aJsFrames
[
jsIndex
]
.
stackAddress
;
jsActivationAddr
=
(
uint8_t
*
)
aJsFrames
[
jsIndex
]
.
activation
;
}
if
(
nativeIndex
>
=
0
)
{
nativeStackAddr
=
(
uint8_t
*
)
aNativeStack
.
mSPs
[
nativeIndex
]
;
}
if
(
nativeStackAddr
&
&
(
profilingStackAddr
=
=
nativeStackAddr
|
|
jsStackAddr
=
=
nativeStackAddr
)
)
{
nativeStackAddr
=
nullptr
;
nativeIndex
-
-
;
MOZ_ASSERT
(
profilingStackAddr
|
|
jsStackAddr
)
;
}
MOZ_ASSERT_IF
(
profilingStackAddr
profilingStackAddr
!
=
jsStackAddr
&
&
profilingStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
jsStackAddr
jsStackAddr
!
=
profilingStackAddr
&
&
jsStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
nativeStackAddr
nativeStackAddr
!
=
profilingStackAddr
&
&
nativeStackAddr
!
=
jsStackAddr
)
;
if
(
profilingStackAddr
>
jsStackAddr
&
&
profilingStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
profilingStackIndex
<
profilingStackFrameCount
)
;
const
js
:
:
ProfilingStackFrame
&
profilingStackFrame
=
profilingStackFrames
[
profilingStackIndex
]
;
if
(
!
profilingStackFrame
.
isSpMarkerFrame
(
)
)
{
MOZ_ASSERT_IF
(
profilingStackFrame
.
isJsFrame
(
)
&
&
profilingStackFrame
.
script
(
)
&
&
!
profilingStackFrame
.
pc
(
)
&
profilingStackFrame
=
=
&
profilingStack
.
frames
[
profilingStack
.
stackSize
(
)
-
1
]
)
;
if
(
aIsSynchronous
&
&
profilingStackFrame
.
categoryPair
(
)
=
=
JS
:
:
ProfilingCategoryPair
:
:
PROFILER
)
{
return
;
}
aCollector
.
CollectProfilingStackFrame
(
profilingStackFrame
)
;
}
profilingStackIndex
+
+
;
continue
;
}
if
(
jsStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
jsIndex
>
=
0
)
;
const
JS
:
:
ProfilingFrameIterator
:
:
Frame
&
jsFrame
=
aJsFrames
[
jsIndex
]
;
jitEndStackAddr
=
(
uint8_t
*
)
jsFrame
.
endStackAddress
;
if
(
aIsSynchronous
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Wasm
)
{
aCollector
.
CollectWasmFrame
(
jsFrame
.
label
)
;
}
else
if
(
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_BaselineInterpreter
)
{
JSScript
*
script
=
jsFrame
.
interpreterScript
;
jsbytecode
*
pc
=
jsFrame
.
interpreterPC
(
)
;
js
:
:
ProfilingStackFrame
stackFrame
;
constexpr
uint32_t
ExtraFlags
=
uint32_t
(
js
:
:
ProfilingStackFrame
:
:
Flags
:
:
IS_BLINTERP_FRAME
)
;
stackFrame
.
initJsFrame
<
JS
:
:
ProfilingCategoryPair
:
:
JS_BaselineInterpret
ExtraFlags
>
(
"
"
jsFrame
.
label
script
pc
jsFrame
.
realmID
)
;
aCollector
.
CollectProfilingStackFrame
(
stackFrame
)
;
}
else
{
MOZ_ASSERT
(
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Ion
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Baseline
)
;
aCollector
.
CollectJitReturnAddr
(
jsFrame
.
returnAddress
(
)
)
;
}
jsIndex
-
-
;
continue
;
}
if
(
nativeStackAddr
&
&
(
!
jitEndStackAddr
|
|
nativeStackAddr
<
jitEndStackAddr
)
&
&
(
!
jsActivationAddr
|
|
nativeStackAddr
>
jsActivationAddr
)
)
{
MOZ_ASSERT
(
nativeIndex
>
=
0
)
;
void
*
addr
=
(
void
*
)
aNativeStack
.
mPCs
[
nativeIndex
]
;
aCollector
.
CollectNativeLeafAddr
(
addr
)
;
}
if
(
nativeIndex
>
=
0
)
{
nativeIndex
-
-
;
}
}
if
(
!
aIsSynchronous
)
{
aCollector
.
BufferRangeStart
(
)
.
apply
(
[
&
aThreadData
]
(
uint64_t
aBufferRangeStart
)
{
JSContext
*
context
=
aThreadData
.
GetJSContext
(
)
;
if
(
context
)
{
JS
:
:
SetJSContextProfilerSampleBufferRangeStart
(
context
aBufferRangeStart
)
;
}
}
)
;
}
}
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
|
|
defined
(
USE_MOZ_STACK_WALK
)
static
void
StackWalkCallback
(
uint32_t
aFrameNumber
void
*
aPC
void
*
aSP
void
*
aClosure
)
{
NativeStack
*
nativeStack
=
static_cast
<
NativeStack
*
>
(
aClosure
)
;
MOZ_ASSERT
(
nativeStack
-
>
mCount
<
MAX_NATIVE_FRAMES
)
;
nativeStack
-
>
mSPs
[
nativeStack
-
>
mCount
]
=
aSP
;
nativeStack
-
>
mPCs
[
nativeStack
-
>
mCount
]
=
aPC
;
nativeStack
-
>
mCount
+
+
;
}
#
endif
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
static
void
DoFramePointerBacktrace
(
PSLockRef
aLock
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
Registers
aRegs
NativeStack
&
aNativeStack
StackWalkControl
*
aStackWalkControlIfSupported
)
{
StackWalkCallback
(
0
aRegs
.
mPC
aRegs
.
mSP
&
aNativeStack
)
;
const
void
*
const
stackEnd
=
aThreadData
.
StackTop
(
)
;
void
*
previousResumeSp
=
nullptr
;
for
(
;
;
)
{
if
(
!
(
aRegs
.
mSP
&
&
aRegs
.
mSP
<
=
aRegs
.
mFP
&
&
aRegs
.
mFP
<
=
stackEnd
)
)
{
break
;
}
FramePointerStackWalk
(
StackWalkCallback
uint32_t
(
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
&
aNativeStack
reinterpret_cast
<
void
*
*
>
(
aRegs
.
mFP
)
const_cast
<
void
*
>
(
stackEnd
)
)
;
if
constexpr
(
!
StackWalkControl
:
:
scIsSupported
)
{
break
;
}
else
{
if
(
aNativeStack
.
mCount
>
=
MAX_NATIVE_FRAMES
)
{
break
;
}
if
(
!
aStackWalkControlIfSupported
|
|
aStackWalkControlIfSupported
-
>
ResumePointCount
(
)
=
=
0
)
{
break
;
}
void
*
lastSP
=
aNativeStack
.
mSPs
[
aNativeStack
.
mCount
-
1
]
;
if
(
previousResumeSp
&
&
(
(
uintptr_t
)
lastSP
<
=
(
uintptr_t
)
previousResumeSp
)
)
{
break
;
}
const
StackWalkControl
:
:
ResumePoint
*
resumePoint
=
aStackWalkControlIfSupported
-
>
GetResumePointCallingSp
(
lastSP
)
;
if
(
!
resumePoint
)
{
break
;
}
void
*
sp
=
resumePoint
-
>
resumeSp
;
if
(
!
sp
)
{
break
;
}
void
*
pc
=
resumePoint
-
>
resumePc
;
StackWalkCallback
(
aNativeStack
.
mCount
pc
sp
&
aNativeStack
)
;
+
+
aNativeStack
.
mCount
;
if
(
aNativeStack
.
mCount
>
=
MAX_NATIVE_FRAMES
)
{
break
;
}
aRegs
.
mPC
=
(
Address
)
pc
;
aRegs
.
mSP
=
(
Address
)
sp
;
aRegs
.
mFP
=
(
Address
)
resumePoint
-
>
resumeBp
;
previousResumeSp
=
sp
;
}
}
}
#
endif
#
if
defined
(
USE_MOZ_STACK_WALK
)
static
void
DoMozStackWalkBacktrace
(
PSLockRef
aLock
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
NativeStack
&
aNativeStack
StackWalkControl
*
aStackWalkControlIfSupported
)
{
StackWalkCallback
(
0
aRegs
.
mPC
aRegs
.
mSP
&
aNativeStack
)
;
HANDLE
thread
=
aThreadData
.
PlatformDataCRef
(
)
.
ProfiledThread
(
)
;
MOZ_ASSERT
(
thread
)
;
CONTEXT
context_buf
;
CONTEXT
*
context
=
nullptr
;
if
constexpr
(
StackWalkControl
:
:
scIsSupported
)
{
context
=
&
context_buf
;
memset
(
&
context_buf
0
sizeof
(
CONTEXT
)
)
;
context_buf
.
ContextFlags
=
CONTEXT_FULL
;
#
if
defined
(
_M_AMD64
)
context_buf
.
Rsp
=
(
DWORD64
)
aRegs
.
mSP
;
context_buf
.
Rbp
=
(
DWORD64
)
aRegs
.
mFP
;
context_buf
.
Rip
=
(
DWORD64
)
aRegs
.
mPC
;
#
else
static_assert
(
!
StackWalkControl
:
:
scIsSupported
"
Mismatched
support
between
StackWalkControl
and
"
"
DoMozStackWalkBacktrace
"
)
;
#
endif
}
else
{
context
=
nullptr
;
}
void
*
previousResumeSp
=
nullptr
;
for
(
;
;
)
{
MozStackWalkThread
(
StackWalkCallback
uint32_t
(
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
&
aNativeStack
thread
context
)
;
if
constexpr
(
!
StackWalkControl
:
:
scIsSupported
)
{
break
;
}
else
{
if
(
aNativeStack
.
mCount
>
=
MAX_NATIVE_FRAMES
)
{
break
;
}
if
(
!
aStackWalkControlIfSupported
|
|
aStackWalkControlIfSupported
-
>
ResumePointCount
(
)
=
=
0
)
{
break
;
}
void
*
lastSP
=
aNativeStack
.
mSPs
[
aNativeStack
.
mCount
-
1
]
;
if
(
previousResumeSp
&
&
(
(
uintptr_t
)
lastSP
<
=
(
uintptr_t
)
previousResumeSp
)
)
{
break
;
}
const
StackWalkControl
:
:
ResumePoint
*
resumePoint
=
aStackWalkControlIfSupported
-
>
GetResumePointCallingSp
(
lastSP
)
;
if
(
!
resumePoint
)
{
break
;
}
void
*
sp
=
resumePoint
-
>
resumeSp
;
if
(
!
sp
)
{
break
;
}
void
*
pc
=
resumePoint
-
>
resumePc
;
StackWalkCallback
(
aNativeStack
.
mCount
pc
sp
&
aNativeStack
)
;
+
+
aNativeStack
.
mCount
;
if
(
aNativeStack
.
mCount
>
=
MAX_NATIVE_FRAMES
)
{
break
;
}
memset
(
&
context_buf
0
sizeof
(
CONTEXT
)
)
;
context_buf
.
ContextFlags
=
CONTEXT_FULL
;
#
if
defined
(
_M_AMD64
)
context_buf
.
Rsp
=
(
DWORD64
)
sp
;
context_buf
.
Rbp
=
(
DWORD64
)
resumePoint
-
>
resumeBp
;
context_buf
.
Rip
=
(
DWORD64
)
pc
;
#
else
static_assert
(
!
StackWalkControl
:
:
scIsSupported
"
Mismatched
support
between
StackWalkControl
and
"
"
DoMozStackWalkBacktrace
"
)
;
#
endif
previousResumeSp
=
sp
;
}
}
}
#
endif
#
ifdef
USE_EHABI_STACKWALK
static
void
DoEHABIBacktrace
(
PSLockRef
aLock
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
NativeStack
&
aNativeStack
StackWalkControl
*
aStackWalkControlIfSupported
)
{
aNativeStack
.
mCount
=
EHABIStackWalk
(
aRegs
.
mContext
-
>
uc_mcontext
const_cast
<
void
*
>
(
aThreadData
.
StackTop
(
)
)
aNativeStack
.
mSPs
aNativeStack
.
mPCs
MAX_NATIVE_FRAMES
)
;
(
void
)
aStackWalkControlIfSupported
;
}
#
endif
#
ifdef
USE_LUL_STACKWALK
#
if
defined
(
MOZ_HAVE_ASAN_BLACKLIST
)
MOZ_ASAN_BLACKLIST
static
void
ASAN_memcpy
(
void
*
aDst
const
void
*
aSrc
size_t
aLen
)
{
char
*
dst
=
static_cast
<
char
*
>
(
aDst
)
;
const
char
*
src
=
static_cast
<
const
char
*
>
(
aSrc
)
;
for
(
size_t
i
=
0
;
i
<
aLen
;
i
+
+
)
{
dst
[
i
]
=
src
[
i
]
;
}
}
#
endif
static
void
DoLULBacktrace
(
PSLockRef
aLock
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
NativeStack
&
aNativeStack
StackWalkControl
*
aStackWalkControlIfSupported
)
{
(
void
)
aStackWalkControlIfSupported
;
const
mcontext_t
*
mc
=
&
aRegs
.
mContext
-
>
uc_mcontext
;
lul
:
:
UnwindRegs
startRegs
;
memset
(
&
startRegs
0
sizeof
(
startRegs
)
)
;
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_amd64_android
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RSP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RBP
]
)
;
#
elif
defined
(
GP_PLAT_amd64_freebsd
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_rip
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_rsp
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_rbp
)
;
#
elif
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
startRegs
.
r15
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_pc
)
;
startRegs
.
r14
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_lr
)
;
startRegs
.
r13
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_sp
)
;
startRegs
.
r12
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_ip
)
;
startRegs
.
r11
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_fp
)
;
startRegs
.
r7
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_r7
)
;
#
elif
defined
(
GP_PLAT_arm64_linux
)
|
|
defined
(
GP_PLAT_arm64_android
)
startRegs
.
pc
=
lul
:
:
TaggedUWord
(
mc
-
>
pc
)
;
startRegs
.
x29
=
lul
:
:
TaggedUWord
(
mc
-
>
regs
[
29
]
)
;
startRegs
.
x30
=
lul
:
:
TaggedUWord
(
mc
-
>
regs
[
30
]
)
;
startRegs
.
sp
=
lul
:
:
TaggedUWord
(
mc
-
>
sp
)
;
#
elif
defined
(
GP_PLAT_arm64_freebsd
)
startRegs
.
pc
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_gpregs
.
gp_elr
)
;
startRegs
.
x29
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_gpregs
.
gp_x
[
29
]
)
;
startRegs
.
x30
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_gpregs
.
gp_lr
)
;
startRegs
.
sp
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_gpregs
.
gp_sp
)
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_ESP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EBP
]
)
;
#
elif
defined
(
GP_PLAT_mips64_linux
)
startRegs
.
pc
=
lul
:
:
TaggedUWord
(
mc
-
>
pc
)
;
startRegs
.
sp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
29
]
)
;
startRegs
.
fp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
30
]
)
;
#
else
#
error
"
Unknown
plat
"
#
endif
lul
:
:
StackImage
stackImg
;
{
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_amd64_android
)
|
|
\
defined
(
GP_PLAT_amd64_freebsd
)
uintptr_t
rEDZONE_SIZE
=
128
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
r13
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_arm64_linux
)
|
|
defined
(
GP_PLAT_arm64_android
)
|
|
\
defined
(
GP_PLAT_arm64_freebsd
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
sp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_mips64_linux
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
sp
.
Value
(
)
-
rEDZONE_SIZE
;
#
else
#
error
"
Unknown
plat
"
#
endif
uintptr_t
end
=
reinterpret_cast
<
uintptr_t
>
(
aThreadData
.
StackTop
(
)
)
;
uintptr_t
ws
=
sizeof
(
void
*
)
;
start
&
=
~
(
ws
-
1
)
;
end
&
=
~
(
ws
-
1
)
;
uintptr_t
nToCopy
=
0
;
if
(
start
<
end
)
{
nToCopy
=
end
-
start
;
if
(
nToCopy
>
lul
:
:
N_STACK_BYTES
)
nToCopy
=
lul
:
:
N_STACK_BYTES
;
}
MOZ_ASSERT
(
nToCopy
<
=
lul
:
:
N_STACK_BYTES
)
;
stackImg
.
mLen
=
nToCopy
;
stackImg
.
mStartAvma
=
start
;
if
(
nToCopy
>
0
)
{
#
if
defined
(
MOZ_HAVE_ASAN_BLACKLIST
)
ASAN_memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
#
else
memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
#
endif
(
void
)
VALGRIND_MAKE_MEM_DEFINED
(
&
stackImg
.
mContents
[
0
]
nToCopy
)
;
}
}
size_t
framePointerFramesAcquired
=
0
;
lul
:
:
LUL
*
lul
=
CorePS
:
:
Lul
(
aLock
)
;
lul
-
>
Unwind
(
reinterpret_cast
<
uintptr_t
*
>
(
aNativeStack
.
mPCs
)
reinterpret_cast
<
uintptr_t
*
>
(
aNativeStack
.
mSPs
)
&
aNativeStack
.
mCount
&
framePointerFramesAcquired
MAX_NATIVE_FRAMES
&
startRegs
&
stackImg
)
;
lul
-
>
mStats
.
mContext
+
=
1
;
lul
-
>
mStats
.
mCFI
+
=
aNativeStack
.
mCount
-
1
-
framePointerFramesAcquired
;
lul
-
>
mStats
.
mFP
+
=
framePointerFramesAcquired
;
}
#
endif
#
ifdef
HAVE_NATIVE_UNWIND
static
void
DoNativeBacktrace
(
PSLockRef
aLock
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
NativeStack
&
aNativeStack
StackWalkControl
*
aStackWalkControlIfSupported
)
{
#
if
defined
(
USE_LUL_STACKWALK
)
DoLULBacktrace
(
aLock
aThreadData
aRegs
aNativeStack
aStackWalkControlIfSupported
)
;
#
elif
defined
(
USE_EHABI_STACKWALK
)
DoEHABIBacktrace
(
aLock
aThreadData
aRegs
aNativeStack
aStackWalkControlIfSupported
)
;
#
elif
defined
(
USE_FRAME_POINTER_STACK_WALK
)
DoFramePointerBacktrace
(
aLock
aThreadData
aRegs
aNativeStack
aStackWalkControlIfSupported
)
;
#
elif
defined
(
USE_MOZ_STACK_WALK
)
DoMozStackWalkBacktrace
(
aLock
aThreadData
aRegs
aNativeStack
aStackWalkControlIfSupported
)
;
#
else
#
error
"
Invalid
configuration
"
#
endif
}
#
endif
static
inline
void
DoSharedSample
(
PSLockRef
aLock
bool
aIsSynchronous
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
uint64_t
aSamplePos
uint64_t
aBufferRangeStart
ProfileBuffer
&
aBuffer
StackCaptureOptions
aCaptureOptions
=
StackCaptureOptions
:
:
Full
)
{
MOZ_ASSERT
(
!
aBuffer
.
IsThreadSafe
(
)
"
Mutexes
cannot
be
used
inside
this
critical
section
"
)
;
MOZ_RELEASE_ASSERT
(
ActivePS
:
:
Exists
(
aLock
)
)
;
ProfileBufferCollector
collector
(
aBuffer
aSamplePos
aBufferRangeStart
)
;
JsFrameBuffer
&
jsFrames
=
CorePS
:
:
JsFrames
(
aLock
)
;
StackWalkControl
*
stackWalkControlIfSupported
=
nullptr
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
const
bool
captureNative
=
ActivePS
:
:
FeatureStackWalk
(
aLock
)
&
&
aCaptureOptions
=
=
StackCaptureOptions
:
:
Full
;
StackWalkControl
stackWalkControl
;
if
constexpr
(
StackWalkControl
:
:
scIsSupported
)
{
if
(
captureNative
)
{
stackWalkControlIfSupported
=
&
stackWalkControl
;
}
}
#
endif
const
uint32_t
jsFramesCount
=
ExtractJsFrames
(
aIsSynchronous
aThreadData
aRegs
collector
jsFrames
stackWalkControlIfSupported
)
;
NativeStack
nativeStack
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
if
(
captureNative
)
{
DoNativeBacktrace
(
aLock
aThreadData
aRegs
nativeStack
stackWalkControlIfSupported
)
;
MergeStacks
(
ActivePS
:
:
Features
(
aLock
)
aIsSynchronous
aThreadData
aRegs
nativeStack
collector
jsFrames
jsFramesCount
)
;
}
else
#
endif
{
MergeStacks
(
ActivePS
:
:
Features
(
aLock
)
aIsSynchronous
aThreadData
aRegs
nativeStack
collector
jsFrames
jsFramesCount
)
;
if
(
ActivePS
:
:
FeatureLeaf
(
aLock
)
&
&
aCaptureOptions
=
=
StackCaptureOptions
:
:
Full
)
{
aBuffer
.
AddEntry
(
ProfileBufferEntry
:
:
NativeLeafAddr
(
(
void
*
)
aRegs
.
mPC
)
)
;
}
}
}
static
void
DoSyncSample
(
PSLockRef
aLock
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
TimeStamp
&
aNow
const
Registers
&
aRegs
ProfileBuffer
&
aBuffer
StackCaptureOptions
aCaptureOptions
)
{
MOZ_ASSERT
(
aCaptureOptions
!
=
StackCaptureOptions
:
:
NoStack
"
DoSyncSample
should
not
be
called
when
no
capture
is
needed
"
)
;
const
uint64_t
bufferRangeStart
=
aBuffer
.
BufferRangeStart
(
)
;
const
uint64_t
samplePos
=
aBuffer
.
AddThreadIdEntry
(
aThreadData
.
Info
(
)
.
ThreadId
(
)
)
;
TimeDuration
delta
=
aNow
-
CorePS
:
:
ProcessStartTime
(
)
;
aBuffer
.
AddEntry
(
ProfileBufferEntry
:
:
Time
(
delta
.
ToMilliseconds
(
)
)
)
;
DoSharedSample
(
aLock
true
aThreadData
aRegs
samplePos
bufferRangeStart
aBuffer
aCaptureOptions
)
;
}
static
inline
void
DoPeriodicSample
(
PSLockRef
aLock
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
uint64_t
aSamplePos
uint64_t
aBufferRangeStart
ProfileBuffer
&
aBuffer
)
{
DoSharedSample
(
aLock
false
aThreadData
aRegs
aSamplePos
aBufferRangeStart
aBuffer
)
;
}
const
static
uint64_t
kJS_MAX_SAFE_UINTEGER
=
+
9007199254740991ULL
;
static
int64_t
SafeJSInteger
(
uint64_t
aValue
)
{
return
aValue
<
=
kJS_MAX_SAFE_UINTEGER
?
int64_t
(
aValue
)
:
-
1
;
}
static
void
AddSharedLibraryInfoToStream
(
JSONWriter
&
aWriter
const
SharedLibrary
&
aLib
)
{
aWriter
.
StartObjectElement
(
)
;
aWriter
.
IntProperty
(
"
start
"
SafeJSInteger
(
aLib
.
GetStart
(
)
)
)
;
aWriter
.
IntProperty
(
"
end
"
SafeJSInteger
(
aLib
.
GetEnd
(
)
)
)
;
aWriter
.
IntProperty
(
"
offset
"
SafeJSInteger
(
aLib
.
GetOffset
(
)
)
)
;
aWriter
.
StringProperty
(
"
name
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetModuleName
(
)
)
)
;
aWriter
.
StringProperty
(
"
path
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetModulePath
(
)
)
)
;
aWriter
.
StringProperty
(
"
debugName
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetDebugName
(
)
)
)
;
aWriter
.
StringProperty
(
"
debugPath
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetDebugPath
(
)
)
)
;
aWriter
.
StringProperty
(
"
breakpadId
"
aLib
.
GetBreakpadId
(
)
)
;
aWriter
.
StringProperty
(
"
arch
"
aLib
.
GetArch
(
)
)
;
aWriter
.
EndObject
(
)
;
}
void
AppendSharedLibraries
(
JSONWriter
&
aWriter
)
{
SharedLibraryInfo
info
=
SharedLibraryInfo
:
:
GetInfoForSelf
(
)
;
info
.
SortByAddress
(
)
;
for
(
size_t
i
=
0
;
i
<
info
.
GetSize
(
)
;
i
+
+
)
{
AddSharedLibraryInfoToStream
(
aWriter
info
.
GetEntry
(
i
)
)
;
}
}
static
void
StreamCategories
(
SpliceableJSONWriter
&
aWriter
)
{
#
define
CATEGORY_JSON_BEGIN_CATEGORY
(
name
labelAsString
color
)
\
aWriter
.
Start
(
)
;
\
aWriter
.
StringProperty
(
"
name
"
labelAsString
)
;
\
aWriter
.
StringProperty
(
"
color
"
color
)
;
\
aWriter
.
StartArrayProperty
(
"
subcategories
"
)
;
#
define
CATEGORY_JSON_SUBCATEGORY
(
supercategory
name
labelAsString
)
\
aWriter
.
StringElement
(
labelAsString
)
;
#
define
CATEGORY_JSON_END_CATEGORY
\
aWriter
.
EndArray
(
)
;
\
aWriter
.
EndObject
(
)
;
MOZ_PROFILING_CATEGORY_LIST
(
CATEGORY_JSON_BEGIN_CATEGORY
CATEGORY_JSON_SUBCATEGORY
CATEGORY_JSON_END_CATEGORY
)
#
undef
CATEGORY_JSON_BEGIN_CATEGORY
#
undef
CATEGORY_JSON_SUBCATEGORY
#
undef
CATEGORY_JSON_END_CATEGORY
}
static
void
StreamMarkerSchema
(
SpliceableJSONWriter
&
aWriter
)
{
Span
<
const
base_profiler_markers_detail
:
:
Streaming
:
:
MarkerTypeFunctions
>
markerTypeFunctionsArray
=
base_profiler_markers_detail
:
:
Streaming
:
:
MarkerTypeFunctionsArray
(
)
;
std
:
:
set
<
std
:
:
string
>
names
;
for
(
const
auto
&
markerTypeFunctions
:
markerTypeFunctionsArray
)
{
auto
name
=
markerTypeFunctions
.
mMarkerTypeNameFunction
(
)
;
const
bool
didInsert
=
names
.
insert
(
std
:
:
string
(
name
.
data
(
)
name
.
size
(
)
)
)
.
second
;
if
(
didInsert
)
{
markerTypeFunctions
.
mMarkerSchemaFunction
(
)
.
Stream
(
aWriter
name
)
;
}
}
}
struct
PreRecordedMetaInformation
{
bool
mAsyncStacks
;
nsAutoCString
mHttpPlatform
;
nsAutoCString
mHttpOscpu
;
nsAutoCString
mHttpMisc
;
nsAutoCString
mRuntimeABI
;
nsAutoCString
mRuntimeToolkit
;
nsAutoCString
mAppInfoProduct
;
nsAutoCString
mAppInfoAppBuildID
;
nsAutoCString
mAppInfoSourceURL
;
int32_t
mProcessInfoCpuCount
;
int32_t
mProcessInfoCpuCores
;
}
;
static
PreRecordedMetaInformation
PreRecordMetaInformation
(
)
{
MOZ_ASSERT
(
!
PSAutoLock
:
:
IsLockedOnCurrentThread
(
)
)
;
PreRecordedMetaInformation
info
=
{
}
;
if
(
!
NS_IsMainThread
(
)
)
{
return
info
;
}
info
.
mAsyncStacks
=
Preferences
:
:
GetBool
(
"
javascript
.
options
.
asyncstack
"
)
;
nsresult
res
;
if
(
nsCOMPtr
<
nsIHttpProtocolHandler
>
http
=
do_GetService
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
"
http
"
&
res
)
;
!
NS_FAILED
(
res
)
&
&
http
)
{
Unused
<
<
http
-
>
GetPlatform
(
info
.
mHttpPlatform
)
;
#
if
defined
(
GP_OS_darwin
)
int
major
=
0
;
int
minor
=
0
;
int
bugfix
=
0
;
nsCocoaFeatures
:
:
GetSystemVersion
(
major
minor
bugfix
)
;
if
(
major
!
=
0
)
{
info
.
mHttpOscpu
.
AppendLiteral
(
"
macOS
"
)
;
info
.
mHttpOscpu
.
AppendInt
(
major
)
;
info
.
mHttpOscpu
.
AppendLiteral
(
"
.
"
)
;
info
.
mHttpOscpu
.
AppendInt
(
minor
)
;
info
.
mHttpOscpu
.
AppendLiteral
(
"
.
"
)
;
info
.
mHttpOscpu
.
AppendInt
(
bugfix
)
;
}
else
#
endif
{
Unused
<
<
http
-
>
GetOscpu
(
info
.
mHttpOscpu
)
;
}
Unused
<
<
http
-
>
GetMisc
(
info
.
mHttpMisc
)
;
}
if
(
nsCOMPtr
<
nsIXULRuntime
>
runtime
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
runtime
)
{
Unused
<
<
runtime
-
>
GetXPCOMABI
(
info
.
mRuntimeABI
)
;
Unused
<
<
runtime
-
>
GetWidgetToolkit
(
info
.
mRuntimeToolkit
)
;
}
if
(
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
)
;
appInfo
)
{
Unused
<
<
appInfo
-
>
GetName
(
info
.
mAppInfoProduct
)
;
Unused
<
<
appInfo
-
>
GetAppBuildID
(
info
.
mAppInfoAppBuildID
)
;
Unused
<
<
appInfo
-
>
GetSourceURL
(
info
.
mAppInfoSourceURL
)
;
}
ProcessInfo
processInfo
=
{
}
;
if
(
NS_SUCCEEDED
(
CollectProcessInfo
(
processInfo
)
)
)
{
info
.
mProcessInfoCpuCount
=
processInfo
.
cpuCount
;
info
.
mProcessInfoCpuCores
=
processInfo
.
cpuCores
;
}
return
info
;
}
static
void
StreamMetaPlatformSampleUnits
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
)
;
static
void
StreamMetaJSCustomObject
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
bool
aIsShuttingDown
const
PreRecordedMetaInformation
&
aPreRecordedMetaInformation
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
aWriter
.
IntProperty
(
"
version
"
23
)
;
TimeDuration
delta
=
TimeStamp
:
:
Now
(
)
-
CorePS
:
:
ProcessStartTime
(
)
;
aWriter
.
DoubleProperty
(
"
startTime
"
static_cast
<
double
>
(
PR_Now
(
)
/
1000
.
0
-
delta
.
ToMilliseconds
(
)
)
)
;
if
(
aIsShuttingDown
)
{
aWriter
.
DoubleProperty
(
"
shutdownTime
"
profiler_time
(
)
)
;
}
else
{
aWriter
.
NullProperty
(
"
shutdownTime
"
)
;
}
aWriter
.
StartArrayProperty
(
"
categories
"
)
;
StreamCategories
(
aWriter
)
;
aWriter
.
EndArray
(
)
;
aWriter
.
StartArrayProperty
(
"
markerSchema
"
)
;
StreamMarkerSchema
(
aWriter
)
;
aWriter
.
EndArray
(
)
;
ActivePS
:
:
WriteActiveConfiguration
(
aLock
aWriter
MakeStringSpan
(
"
configuration
"
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
aWriter
.
DoubleProperty
(
"
interval
"
ActivePS
:
:
Interval
(
aLock
)
)
;
aWriter
.
IntProperty
(
"
stackwalk
"
ActivePS
:
:
FeatureStackWalk
(
aLock
)
)
;
#
ifdef
DEBUG
aWriter
.
IntProperty
(
"
debug
"
1
)
;
#
else
aWriter
.
IntProperty
(
"
debug
"
0
)
;
#
endif
aWriter
.
IntProperty
(
"
gcpoison
"
JS
:
:
IsGCPoisoning
(
)
?
1
:
0
)
;
aWriter
.
IntProperty
(
"
asyncstack
"
aPreRecordedMetaInformation
.
mAsyncStacks
)
;
aWriter
.
IntProperty
(
"
processType
"
XRE_GetProcessType
(
)
)
;
aWriter
.
StringProperty
(
"
updateChannel
"
MOZ_STRINGIFY
(
MOZ_UPDATE_CHANNEL
)
)
;
if
(
!
aPreRecordedMetaInformation
.
mHttpPlatform
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
platform
"
aPreRecordedMetaInformation
.
mHttpPlatform
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mHttpOscpu
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
oscpu
"
aPreRecordedMetaInformation
.
mHttpOscpu
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mHttpMisc
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
misc
"
aPreRecordedMetaInformation
.
mHttpMisc
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mRuntimeABI
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
abi
"
aPreRecordedMetaInformation
.
mRuntimeABI
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mRuntimeToolkit
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
toolkit
"
aPreRecordedMetaInformation
.
mRuntimeToolkit
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mAppInfoProduct
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
product
"
aPreRecordedMetaInformation
.
mAppInfoProduct
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mAppInfoAppBuildID
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
appBuildID
"
aPreRecordedMetaInformation
.
mAppInfoAppBuildID
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mAppInfoSourceURL
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
sourceURL
"
aPreRecordedMetaInformation
.
mAppInfoSourceURL
)
;
}
if
(
aPreRecordedMetaInformation
.
mProcessInfoCpuCores
>
0
)
{
aWriter
.
IntProperty
(
"
physicalCPUs
"
aPreRecordedMetaInformation
.
mProcessInfoCpuCores
)
;
}
if
(
aPreRecordedMetaInformation
.
mProcessInfoCpuCount
>
0
)
{
aWriter
.
IntProperty
(
"
logicalCPUs
"
aPreRecordedMetaInformation
.
mProcessInfoCpuCount
)
;
}
#
if
defined
(
GP_OS_android
)
jni
:
:
String
:
:
LocalRef
deviceInformation
=
java
:
:
GeckoJavaSampler
:
:
GetDeviceInformation
(
)
;
aWriter
.
StringProperty
(
"
device
"
deviceInformation
-
>
ToCString
(
)
)
;
#
endif
aWriter
.
StartObjectProperty
(
"
sampleUnits
"
)
;
{
aWriter
.
StringProperty
(
"
time
"
"
ms
"
)
;
aWriter
.
StringProperty
(
"
eventDelay
"
"
ms
"
)
;
StreamMetaPlatformSampleUnits
(
aLock
aWriter
)
;
}
aWriter
.
EndObject
(
)
;
if
(
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
)
{
aWriter
.
StartObjectProperty
(
"
extensions
"
)
;
{
{
JSONSchemaWriter
schema
(
aWriter
)
;
schema
.
WriteField
(
"
id
"
)
;
schema
.
WriteField
(
"
name
"
)
;
schema
.
WriteField
(
"
baseURL
"
)
;
}
aWriter
.
StartArrayProperty
(
"
data
"
)
;
{
nsTArray
<
RefPtr
<
WebExtensionPolicy
>
>
exts
;
ExtensionPolicyService
:
:
GetSingleton
(
)
.
GetAll
(
exts
)
;
for
(
auto
&
ext
:
exts
)
{
aWriter
.
StartArrayElement
(
JSONWriter
:
:
SingleLineStyle
)
;
nsAutoString
id
;
ext
-
>
GetId
(
id
)
;
aWriter
.
StringElement
(
NS_ConvertUTF16toUTF8
(
id
)
)
;
aWriter
.
StringElement
(
NS_ConvertUTF16toUTF8
(
ext
-
>
Name
(
)
)
)
;
auto
url
=
ext
-
>
GetURL
(
u
"
"
_ns
)
;
if
(
url
.
isOk
(
)
)
{
aWriter
.
StringElement
(
NS_ConvertUTF16toUTF8
(
url
.
unwrap
(
)
)
)
;
}
aWriter
.
EndArray
(
)
;
}
}
aWriter
.
EndArray
(
)
;
}
aWriter
.
EndObject
(
)
;
}
}
static
void
StreamPages
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
ActivePS
:
:
DiscardExpiredPages
(
aLock
)
;
for
(
const
auto
&
page
:
ActivePS
:
:
ProfiledPages
(
aLock
)
)
{
page
-
>
StreamJSON
(
aWriter
)
;
}
}
#
if
defined
(
GP_OS_android
)
template
<
int
N
>
static
bool
StartsWith
(
const
nsACString
&
string
const
char
(
&
prefix
)
[
N
]
)
{
if
(
N
-
1
>
string
.
Length
(
)
)
{
return
false
;
}
return
memcmp
(
string
.
Data
(
)
prefix
N
-
1
)
=
=
0
;
}
static
JS
:
:
ProfilingCategoryPair
InferJavaCategory
(
nsACString
&
aName
)
{
if
(
aName
.
EqualsLiteral
(
"
android
.
os
.
MessageQueue
.
nativePollOnce
(
)
"
)
)
{
return
JS
:
:
ProfilingCategoryPair
:
:
IDLE
;
}
if
(
aName
.
EqualsLiteral
(
"
java
.
lang
.
Object
.
wait
(
)
"
)
)
{
return
JS
:
:
ProfilingCategoryPair
:
:
JAVA_BLOCKED
;
}
if
(
StartsWith
(
aName
"
android
.
"
)
|
|
StartsWith
(
aName
"
com
.
android
.
"
)
)
{
return
JS
:
:
ProfilingCategoryPair
:
:
JAVA_ANDROID
;
}
if
(
StartsWith
(
aName
"
mozilla
.
"
)
|
|
StartsWith
(
aName
"
org
.
mozilla
.
"
)
)
{
return
JS
:
:
ProfilingCategoryPair
:
:
JAVA_MOZILLA
;
}
if
(
StartsWith
(
aName
"
java
.
"
)
|
|
StartsWith
(
aName
"
sun
.
"
)
|
|
StartsWith
(
aName
"
com
.
sun
.
"
)
)
{
return
JS
:
:
ProfilingCategoryPair
:
:
JAVA_LANGUAGE
;
}
if
(
StartsWith
(
aName
"
kotlin
.
"
)
|
|
StartsWith
(
aName
"
kotlinx
.
"
)
)
{
return
JS
:
:
ProfilingCategoryPair
:
:
JAVA_KOTLIN
;
}
if
(
StartsWith
(
aName
"
androidx
.
"
)
)
{
return
JS
:
:
ProfilingCategoryPair
:
:
JAVA_ANDROIDX
;
}
return
JS
:
:
ProfilingCategoryPair
:
:
OTHER
;
}
static
void
CollectJavaThreadProfileData
(
ProfileBuffer
&
aProfileBuffer
)
{
constexpr
ProfilerThreadId
threadId
;
int
sampleId
=
0
;
while
(
true
)
{
double
sampleTime
=
java
:
:
GeckoJavaSampler
:
:
GetSampleTime
(
sampleId
)
;
if
(
sampleTime
=
=
0
.
0
)
{
break
;
}
aProfileBuffer
.
AddThreadIdEntry
(
threadId
)
;
aProfileBuffer
.
AddEntry
(
ProfileBufferEntry
:
:
Time
(
sampleTime
)
)
;
int
frameId
=
0
;
while
(
true
)
{
jni
:
:
String
:
:
LocalRef
frameName
=
java
:
:
GeckoJavaSampler
:
:
GetFrameName
(
sampleId
frameId
+
+
)
;
if
(
!
frameName
)
{
break
;
}
nsCString
frameNameString
=
frameName
-
>
ToCString
(
)
;
auto
categoryPair
=
InferJavaCategory
(
frameNameString
)
;
aProfileBuffer
.
CollectCodeLocation
(
"
"
frameNameString
.
get
(
)
0
0
Nothing
(
)
Nothing
(
)
Some
(
categoryPair
)
)
;
}
sampleId
+
+
;
}
while
(
true
)
{
java
:
:
GeckoJavaSampler
:
:
Marker
:
:
LocalRef
marker
=
java
:
:
GeckoJavaSampler
:
:
PollNextMarker
(
)
;
if
(
!
marker
)
{
break
;
}
nsCString
markerName
=
marker
-
>
GetMarkerName
(
)
-
>
ToCString
(
)
;
jni
:
:
String
:
:
LocalRef
text
=
marker
-
>
GetMarkerText
(
)
;
TimeStamp
startTime
=
CorePS
:
:
ProcessStartTime
(
)
+
TimeDuration
:
:
FromMilliseconds
(
marker
-
>
GetStartTime
(
)
)
;
double
endTimeMs
=
marker
-
>
GetEndTime
(
)
;
TimeStamp
endTime
=
endTimeMs
=
=
0
?
startTime
:
CorePS
:
:
ProcessStartTime
(
)
+
TimeDuration
:
:
FromMilliseconds
(
endTimeMs
)
;
MarkerTiming
timing
=
endTimeMs
=
=
0
?
MarkerTiming
:
:
InstantAt
(
startTime
)
:
MarkerTiming
:
:
Interval
(
startTime
endTime
)
;
if
(
!
text
)
{
AddMarkerToBuffer
(
aProfileBuffer
.
UnderlyingChunkedBuffer
(
)
markerName
geckoprofiler
:
:
category
:
:
JAVA_ANDROID
{
MarkerThreadId
(
threadId
)
std
:
:
move
(
timing
)
}
)
;
}
else
{
AddMarkerToBuffer
(
aProfileBuffer
.
UnderlyingChunkedBuffer
(
)
markerName
geckoprofiler
:
:
category
:
:
JAVA_ANDROID
{
MarkerThreadId
(
threadId
)
std
:
:
move
(
timing
)
}
geckoprofiler
:
:
markers
:
:
TextMarker
{
}
text
-
>
ToCString
(
)
)
;
}
}
}
#
endif
UniquePtr
<
ProfilerCodeAddressService
>
profiler_code_address_service_for_presymbolication
(
)
{
static
const
bool
preSymbolicate
=
[
]
(
)
{
const
char
*
symbolicate
=
getenv
(
"
MOZ_PROFILER_SYMBOLICATE
"
)
;
return
symbolicate
&
&
symbolicate
[
0
]
!
=
'
\
0
'
;
}
(
)
;
return
preSymbolicate
?
MakeUnique
<
ProfilerCodeAddressService
>
(
)
:
nullptr
;
}
static
void
locked_profiler_stream_json_for_this_process
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
double
aSinceTime
const
PreRecordedMetaInformation
&
aPreRecordedMetaInformation
bool
aIsShuttingDown
ProfilerCodeAddressService
*
aService
)
{
LOG
(
"
locked_profiler_stream_json_for_this_process
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
AUTO_PROFILER_STATS
(
locked_profiler_stream_json_for_this_process
)
;
const
double
collectionStartMs
=
profiler_time
(
)
;
ProfileBuffer
&
buffer
=
ActivePS
:
:
Buffer
(
aLock
)
;
Maybe
<
double
>
durationS
=
ActivePS
:
:
Duration
(
aLock
)
;
if
(
durationS
.
isSome
(
)
)
{
const
double
durationStartMs
=
collectionStartMs
-
*
durationS
*
1000
;
buffer
.
DiscardSamplesBeforeTime
(
durationStartMs
)
;
}
aWriter
.
StartArrayProperty
(
"
libs
"
)
;
AppendSharedLibraries
(
aWriter
)
;
aWriter
.
EndArray
(
)
;
aWriter
.
StartObjectProperty
(
"
meta
"
)
;
{
StreamMetaJSCustomObject
(
aLock
aWriter
aIsShuttingDown
aPreRecordedMetaInformation
)
;
}
aWriter
.
EndObject
(
)
;
aWriter
.
StartArrayProperty
(
"
pages
"
)
;
{
StreamPages
(
aLock
aWriter
)
;
}
aWriter
.
EndArray
(
)
;
buffer
.
StreamProfilerOverheadToJSON
(
aWriter
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
)
;
buffer
.
StreamCountersToJSON
(
aWriter
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
)
;
aWriter
.
StartArrayProperty
(
"
threads
"
)
;
{
ActivePS
:
:
DiscardExpiredDeadProfiledThreads
(
aLock
)
;
Vector
<
std
:
:
pair
<
RegisteredThread
*
ProfiledThreadData
*
>
>
threads
=
ActivePS
:
:
ProfiledThreads
(
aLock
)
;
for
(
auto
&
thread
:
threads
)
{
RegisteredThread
*
registeredThread
=
thread
.
first
;
JSContext
*
cx
=
registeredThread
?
registeredThread
-
>
GetJSContext
(
)
:
nullptr
;
ProfiledThreadData
*
profiledThreadData
=
thread
.
second
;
profiledThreadData
-
>
StreamJSON
(
buffer
cx
aWriter
CorePS
:
:
ProcessName
(
aLock
)
CorePS
:
:
ETLDplus1
(
aLock
)
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
ActivePS
:
:
FeatureJSTracer
(
aLock
)
aService
)
;
}
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
mozilla
:
:
ProfileBufferChunkManagerWithLocalLimit
chunkManager
(
64
*
1024
*
1024
1024
*
1024
)
;
ProfileChunkedBuffer
bufferManager
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
chunkManager
)
;
ProfileBuffer
javaBuffer
(
bufferManager
)
;
CollectJavaThreadProfileData
(
javaBuffer
)
;
const
ThreadRegistrationInfo
threadInfo
{
"
AndroidUI
(
JVM
)
"
ProfilerThreadId
{
}
false
CorePS
:
:
ProcessStartTime
(
)
}
;
ProfiledThreadData
profiledThreadData
(
threadInfo
nullptr
)
;
profiledThreadData
.
StreamJSON
(
javaBuffer
nullptr
aWriter
CorePS
:
:
ProcessName
(
aLock
)
CorePS
:
:
ETLDplus1
(
aLock
)
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
ActivePS
:
:
FeatureJSTracer
(
aLock
)
nullptr
)
;
}
#
endif
UniquePtr
<
char
[
]
>
baseProfileThreads
=
ActivePS
:
:
MoveBaseProfileThreads
(
aLock
)
;
if
(
baseProfileThreads
)
{
aWriter
.
Splice
(
MakeStringSpan
(
baseProfileThreads
.
get
(
)
)
)
;
}
}
aWriter
.
EndArray
(
)
;
if
(
ActivePS
:
:
FeatureJSTracer
(
aLock
)
)
{
aWriter
.
StartArrayProperty
(
"
jsTracerDictionary
"
)
;
{
JS
:
:
AutoTraceLoggerLockGuard
lockGuard
;
JS
:
:
TraceLoggerDictionaryBuffer
collectionBuffer
(
lockGuard
)
;
while
(
collectionBuffer
.
NextChunk
(
)
)
{
aWriter
.
StringElement
(
MakeStringSpan
(
collectionBuffer
.
internalBuffer
(
)
)
)
;
}
}
aWriter
.
EndArray
(
)
;
}
aWriter
.
StartArrayProperty
(
"
pausedRanges
"
)
;
{
buffer
.
StreamPausedRangesToJSON
(
aWriter
aSinceTime
)
;
}
aWriter
.
EndArray
(
)
;
const
double
collectionEndMs
=
profiler_time
(
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CollectionStart
(
collectionStartMs
)
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CollectionEnd
(
collectionEndMs
)
)
;
}
bool
profiler_stream_json_for_this_process
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
bool
aIsShuttingDown
ProfilerCodeAddressService
*
aService
)
{
LOG
(
"
profiler_stream_json_for_this_process
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
const
auto
preRecordedMetaInformation
=
PreRecordMetaInformation
(
)
;
if
(
profiler_is_active
(
)
)
{
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
GeneratingProfile
)
;
}
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
locked_profiler_stream_json_for_this_process
(
lock
aWriter
aSinceTime
preRecordedMetaInformation
aIsShuttingDown
aService
)
;
return
true
;
}
static
char
FeatureCategory
(
uint32_t
aFeature
)
{
if
(
aFeature
&
DefaultFeatures
(
)
)
{
if
(
aFeature
&
AvailableFeatures
(
)
)
{
return
'
D
'
;
}
return
'
d
'
;
}
if
(
aFeature
&
StartupExtraDefaultFeatures
(
)
)
{
if
(
aFeature
&
AvailableFeatures
(
)
)
{
return
'
S
'
;
}
return
'
s
'
;
}
if
(
aFeature
&
AvailableFeatures
(
)
)
{
return
'
-
'
;
}
return
'
x
'
;
}
static
void
PrintUsageThenExit
(
int
aExitCode
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
printf
(
"
\
n
"
"
Profiler
environment
variable
usage
:
\
n
"
"
\
n
"
"
MOZ_PROFILER_HELP
\
n
"
"
If
set
to
any
value
prints
this
message
.
\
n
"
"
Use
MOZ_BASE_PROFILER_HELP
for
BaseProfiler
help
.
\
n
"
"
\
n
"
"
MOZ_LOG
\
n
"
"
Enables
logging
.
The
levels
of
logging
available
are
\
n
"
"
'
prof
:
3
'
(
least
verbose
)
'
prof
:
4
'
'
prof
:
5
'
(
most
verbose
)
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP
\
n
"
"
If
set
to
any
value
other
than
'
'
or
'
0
'
/
'
N
'
/
'
n
'
starts
the
\
n
"
"
profiler
immediately
on
start
-
up
.
\
n
"
"
Useful
if
you
want
profile
code
that
runs
very
early
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_ENTRIES
=
<
%
u
.
.
%
u
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
number
of
entries
per
\
n
"
"
process
in
the
profiler
'
s
circular
buffer
when
the
profiler
is
first
\
n
"
"
started
.
\
n
"
"
If
unset
the
platform
default
is
used
:
\
n
"
"
%
u
entries
per
process
or
%
u
when
MOZ_PROFILER_STARTUP
is
set
.
\
n
"
"
(
%
u
bytes
per
entry
-
>
%
u
or
%
u
total
bytes
per
process
)
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_DURATION
=
<
1
.
.
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
maximum
life
time
of
\
n
"
"
entries
in
the
the
profiler
'
s
circular
buffer
when
the
profiler
is
\
n
"
"
first
started
in
seconds
.
\
n
"
"
If
unset
the
life
time
of
the
entries
will
only
be
restricted
by
\
n
"
"
MOZ_PROFILER_STARTUP_ENTRIES
(
or
its
default
value
)
and
no
\
n
"
"
additional
time
duration
restriction
will
be
applied
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_INTERVAL
=
<
1
.
.
%
d
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
sample
interval
\
n
"
"
measured
in
milliseconds
when
the
profiler
is
first
started
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
=
<
Number
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
profiling
features
as
\
n
"
"
the
integer
value
of
the
features
bitfield
.
\
n
"
"
If
unset
the
value
from
MOZ_PROFILER_STARTUP_FEATURES
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FEATURES
=
<
Features
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
profiling
features
as
\
n
"
"
a
comma
-
separated
list
of
strings
.
\
n
"
"
Ignored
if
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
is
set
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
Features
:
(
x
=
unavailable
D
/
d
=
default
/
unavailable
\
n
"
"
S
/
s
=
MOZ_PROFILER_STARTUP
extra
default
/
unavailable
)
\
n
"
unsigned
(
ActivePS
:
:
scMinimumBufferEntries
)
unsigned
(
ActivePS
:
:
scMaximumBufferEntries
)
unsigned
(
PROFILER_DEFAULT_ENTRIES
.
Value
(
)
)
unsigned
(
PROFILER_DEFAULT_STARTUP_ENTRIES
.
Value
(
)
)
unsigned
(
scBytesPerEntry
)
unsigned
(
PROFILER_DEFAULT_ENTRIES
.
Value
(
)
*
scBytesPerEntry
)
unsigned
(
PROFILER_DEFAULT_STARTUP_ENTRIES
.
Value
(
)
*
scBytesPerEntry
)
PROFILER_MAX_INTERVAL
)
;
#
define
PRINT_FEATURE
(
n_
str_
Name_
desc_
)
\
printf
(
"
%
c
%
7u
:
\
"
%
s
\
"
(
%
s
)
\
n
"
FeatureCategory
(
ProfilerFeature
:
:
Name_
)
\
ProfilerFeature
:
:
Name_
str_
desc_
)
;
PROFILER_FOR_EACH_FEATURE
(
PRINT_FEATURE
)
#
undef
PRINT_FEATURE
printf
(
"
-
\
"
default
\
"
(
All
above
D
+
S
defaults
)
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FILTERS
=
<
Filters
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
thread
filters
as
a
\
n
"
"
comma
-
separated
list
of
strings
.
A
given
thread
will
be
sampled
if
\
n
"
"
any
of
the
filters
is
a
case
-
insensitive
substring
of
the
thread
\
n
"
"
name
.
If
unset
a
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_ACTIVE_TAB_ID
=
<
Number
>
\
n
"
"
This
variable
is
used
to
propagate
the
activeTabID
of
\
n
"
"
the
profiler
init
params
to
subprocesses
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_SHUTDOWN
\
n
"
"
If
set
the
profiler
saves
a
profile
to
the
named
file
on
shutdown
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_SYMBOLICATE
\
n
"
"
If
set
the
profiler
will
pre
-
symbolicate
profiles
.
\
n
"
"
*
Note
*
This
will
add
a
significant
pause
when
gathering
data
and
\
n
"
"
is
intended
mainly
for
local
development
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_LUL_TEST
\
n
"
"
If
set
to
any
value
runs
LUL
unit
tests
at
startup
.
\
n
"
"
\
n
"
"
This
platform
%
s
native
unwinding
.
\
n
"
"
\
n
"
#
if
defined
(
HAVE_NATIVE_UNWIND
)
"
supports
"
#
else
"
does
not
support
"
#
endif
)
;
if
(
aExitCode
!
=
0
)
{
exit
(
aExitCode
)
;
}
}
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
struct
SigHandlerCoordinator
;
#
endif
class
Sampler
{
public
:
explicit
Sampler
(
PSLockRef
aLock
)
;
void
Disable
(
PSLockRef
aLock
)
;
template
<
typename
Func
>
void
SuspendAndSampleAndResumeThread
(
PSLockRef
aLock
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
TimeStamp
&
aNow
const
Func
&
aProcessRegs
)
;
private
:
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
struct
sigaction
mOldSigprofHandler
;
ProfilerProcessId
mMyPid
;
ProfilerThreadId
mSamplerTid
;
public
:
static
struct
SigHandlerCoordinator
*
sSigHandlerCoordinator
;
#
endif
}
;
static
RunningTimes
GetThreadRunningTimesDiff
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
)
;
static
void
ClearThreadRunningTimes
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
)
;
template
<
typename
GetCPURunningTimesFunction
>
RunningTimes
GetRunningTimesWithTightTimestamp
(
GetCPURunningTimesFunction
&
&
aGetCPURunningTimesFunction
)
{
static
const
TimeDuration
scMaxRunningTimesReadDuration
=
[
&
]
(
)
{
constexpr
int
loops
=
128
;
TimeDuration
durations
[
loops
]
;
RunningTimes
runningTimes
;
TimeStamp
before
=
TimeStamp
:
:
Now
(
)
;
for
(
int
i
=
0
;
i
<
loops
;
+
+
i
)
{
AUTO_PROFILER_STATS
(
GetRunningTimes_MaxRunningTimesReadDuration
)
;
aGetCPURunningTimesFunction
(
runningTimes
)
;
const
TimeStamp
after
=
TimeStamp
:
:
Now
(
)
;
durations
[
i
]
=
after
-
before
;
before
=
after
;
}
std
:
:
nth_element
(
&
durations
[
0
]
&
durations
[
loops
/
2
]
&
durations
[
loops
]
)
;
return
durations
[
loops
/
2
]
*
8
;
}
(
)
;
RunningTimes
runningTimes
;
TimeStamp
before
=
TimeStamp
:
:
Now
(
)
;
aGetCPURunningTimesFunction
(
runningTimes
)
;
TimeStamp
after
=
TimeStamp
:
:
Now
(
)
;
while
(
MOZ_UNLIKELY
(
after
-
before
>
scMaxRunningTimesReadDuration
)
)
{
AUTO_PROFILER_STATS
(
GetRunningTimes_REDO
)
;
before
=
after
;
aGetCPURunningTimesFunction
(
runningTimes
)
;
after
=
TimeStamp
:
:
Now
(
)
;
}
runningTimes
.
SetPostMeasurementTimeStamp
(
after
)
;
return
runningTimes
;
}
class
SamplerThread
{
public
:
SamplerThread
(
PSLockRef
aLock
uint32_t
aActivityGeneration
double
aIntervalMilliseconds
bool
aStackWalkEnabled
bool
aNoTimerResolutionChange
)
;
~
SamplerThread
(
)
;
void
Run
(
)
;
void
Stop
(
PSLockRef
aLock
)
;
void
AppendPostSamplingCallback
(
PSLockRef
PostSamplingCallback
&
&
aCallback
)
{
mPostSamplingCallbackList
=
MakeUnique
<
PostSamplingCallbackListItem
>
(
std
:
:
move
(
mPostSamplingCallbackList
)
std
:
:
move
(
aCallback
)
)
;
}
private
:
struct
PostSamplingCallbackListItem
{
UniquePtr
<
PostSamplingCallbackListItem
>
mPrev
;
PostSamplingCallback
mCallback
;
PostSamplingCallbackListItem
(
UniquePtr
<
PostSamplingCallbackListItem
>
aPrev
PostSamplingCallback
&
&
aCallback
)
:
mPrev
(
std
:
:
move
(
aPrev
)
)
mCallback
(
std
:
:
move
(
aCallback
)
)
{
}
}
;
[
[
nodiscard
]
]
UniquePtr
<
PostSamplingCallbackListItem
>
TakePostSamplingCallbacks
(
PSLockRef
)
{
return
std
:
:
move
(
mPostSamplingCallbackList
)
;
}
static
void
InvokePostSamplingCallbacks
(
UniquePtr
<
PostSamplingCallbackListItem
>
aCallbacks
SamplingState
aSamplingState
)
{
if
(
!
aCallbacks
)
{
return
;
}
InvokePostSamplingCallbacks
(
std
:
:
move
(
aCallbacks
-
>
mPrev
)
aSamplingState
)
;
std
:
:
move
(
aCallbacks
-
>
mCallback
)
(
aSamplingState
)
;
static_assert
(
std
:
:
is_same_v
<
decltype
(
aCallbacks
)
UniquePtr
<
PostSamplingCallbackListItem
>
>
"
We
need
to
capture
the
list
by
-
value
to
implicitly
destroy
it
"
)
;
}
void
SleepMicro
(
uint32_t
aMicroseconds
)
;
Sampler
mSampler
;
const
uint32_t
mActivityGeneration
;
const
int
mIntervalMicroseconds
;
#
if
defined
(
GP_OS_windows
)
HANDLE
mThread
;
#
elif
defined
(
GP_OS_darwin
)
|
|
defined
(
GP_OS_linux
)
|
|
\
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
pthread_t
mThread
;
#
endif
UniquePtr
<
PostSamplingCallbackListItem
>
mPostSamplingCallbackList
;
#
if
defined
(
GP_OS_windows
)
bool
mNoTimerResolutionChange
=
true
;
#
endif
SamplerThread
(
const
SamplerThread
&
)
=
delete
;
void
operator
=
(
const
SamplerThread
&
)
=
delete
;
}
;
bool
ActivePS
:
:
AppendPostSamplingCallback
(
PSLockRef
aLock
PostSamplingCallback
&
&
aCallback
)
{
if
(
!
sInstance
|
|
!
sInstance
-
>
mSamplerThread
)
{
return
false
;
}
sInstance
-
>
mSamplerThread
-
>
AppendPostSamplingCallback
(
aLock
std
:
:
move
(
aCallback
)
)
;
return
true
;
}
static
SamplerThread
*
NewSamplerThread
(
PSLockRef
aLock
uint32_t
aGeneration
double
aInterval
bool
aStackWalkEnabled
bool
aNoTimerResolutionChange
)
{
return
new
SamplerThread
(
aLock
aGeneration
aInterval
aStackWalkEnabled
aNoTimerResolutionChange
)
;
}
void
SamplerThread
:
:
Run
(
)
{
PR_SetCurrentThreadName
(
"
SamplerThread
"
)
;
const
uint32_t
features
=
[
]
(
)
-
>
uint32_t
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
0
;
}
return
ActivePS
:
:
Features
(
lock
)
;
}
(
)
;
const
bool
stackSampling
=
!
ProfilerFeature
:
:
HasNoStackSampling
(
features
)
;
const
bool
cpuUtilization
=
ProfilerFeature
:
:
HasCPUUtilization
(
features
)
;
mozilla
:
:
ProfileBufferChunkManagerSingle
localChunkManager
(
ProfileBufferChunkManager
:
:
scExpectedMaximumStackSize
)
;
ProfileChunkedBuffer
localBuffer
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
localChunkManager
)
;
ProfileBuffer
localProfileBuffer
(
localBuffer
)
;
auto
previousState
=
localBuffer
.
GetState
(
)
;
UniquePtr
<
PostSamplingCallbackListItem
>
postSamplingCallbacks
;
SamplingState
samplingState
{
}
;
const
TimeDuration
sampleInterval
=
TimeDuration
:
:
FromMicroseconds
(
mIntervalMicroseconds
)
;
const
uint32_t
minimumIntervalSleepUs
=
static_cast
<
uint32_t
>
(
mIntervalMicroseconds
/
4
)
;
TimeStamp
scheduledSampleStart
=
TimeStamp
:
:
Now
(
)
;
while
(
true
)
{
const
TimeStamp
sampleStart
=
TimeStamp
:
:
Now
(
)
;
{
MOZ_ASSERT
(
!
postSamplingCallbacks
)
;
PSAutoLock
lock
;
TimeStamp
lockAcquired
=
TimeStamp
:
:
Now
(
)
;
postSamplingCallbacks
=
TakePostSamplingCallbacks
(
lock
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
samplingState
=
SamplingState
:
:
JustStopped
;
break
;
}
if
(
ActivePS
:
:
Generation
(
lock
)
!
=
mActivityGeneration
)
{
samplingState
=
SamplingState
:
:
JustStopped
;
break
;
}
ActivePS
:
:
ClearExpiredExitProfiles
(
lock
)
;
TimeStamp
expiredMarkersCleaned
=
TimeStamp
:
:
Now
(
)
;
if
(
!
ActivePS
:
:
IsSamplingPaused
(
lock
)
)
{
double
sampleStartDeltaMs
=
(
sampleStart
-
CorePS
:
:
ProcessStartTime
(
)
)
.
ToMilliseconds
(
)
;
ProfileBuffer
&
buffer
=
ActivePS
:
:
Buffer
(
lock
)
;
const
Vector
<
BaseProfilerCount
*
>
&
counters
=
CorePS
:
:
Counters
(
lock
)
;
for
(
auto
&
counter
:
counters
)
{
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CounterId
(
counter
)
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Time
(
sampleStartDeltaMs
)
)
;
int64_t
count
;
uint64_t
number
;
counter
-
>
Sample
(
count
number
)
;
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
ActivePS
:
:
IsMemoryCounter
(
counter
)
)
{
count
-
=
static_cast
<
int64_t
>
(
ActivePS
:
:
ControlledChunkManager
(
lock
)
.
TotalSize
(
)
)
;
}
#
endif
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CounterKey
(
0
)
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Count
(
count
)
)
;
if
(
number
)
{
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Number
(
number
)
)
;
}
}
TimeStamp
countersSampled
=
TimeStamp
:
:
Now
(
)
;
if
(
stackSampling
|
|
cpuUtilization
)
{
samplingState
=
SamplingState
:
:
SamplingCompleted
;
const
Vector
<
LiveProfiledThreadData
>
&
liveThreads
=
ActivePS
:
:
LiveProfiledThreads
(
lock
)
;
ThreadRegistry
:
:
LockedRegistry
lockedRegistry
;
for
(
auto
&
thread
:
liveThreads
)
{
RegisteredThread
*
registeredThread
=
thread
.
mRegisteredThread
;
ProfiledThreadData
*
profiledThreadData
=
thread
.
mProfiledThreadData
.
get
(
)
;
const
ProfilerThreadId
threadId
=
profiledThreadData
-
>
Info
(
)
.
ThreadId
(
)
;
ThreadRegistry
:
:
OffThreadRef
*
offThreadRef
=
[
&
]
(
)
-
>
ThreadRegistry
:
:
OffThreadRef
*
{
for
(
ThreadRegistry
:
:
OffThreadRef
&
otr
:
lockedRegistry
)
{
if
(
otr
.
UnlockedConstReaderCRef
(
)
.
Info
(
)
.
ThreadId
(
)
=
=
threadId
)
{
return
&
otr
;
}
}
return
nullptr
;
}
(
)
;
MOZ_RELEASE_ASSERT
(
offThreadRef
)
;
const
RunningTimes
runningTimesDiff
=
[
&
]
(
)
{
if
(
!
cpuUtilization
)
{
return
RunningTimes
(
TimeStamp
:
:
Now
(
)
)
;
}
return
GetThreadRunningTimesDiff
(
lock
*
registeredThread
)
;
}
(
)
;
const
TimeStamp
&
now
=
runningTimesDiff
.
PostMeasurementTimeStamp
(
)
;
double
threadSampleDeltaMs
=
(
now
-
CorePS
:
:
ProcessStartTime
(
)
)
.
ToMilliseconds
(
)
;
if
(
offThreadRef
-
>
UnlockedConstReaderAndAtomicRWRef
(
)
.
CanDuplicateLastSampleDueToSleep
(
)
|
|
runningTimesDiff
.
GetThreadCPUDelta
(
)
=
=
Some
(
uint64_t
(
0
)
)
)
{
const
bool
dup_ok
=
ActivePS
:
:
Buffer
(
lock
)
.
DuplicateLastSample
(
threadId
threadSampleDeltaMs
profiledThreadData
-
>
LastSample
(
)
runningTimesDiff
)
;
if
(
dup_ok
)
{
continue
;
}
}
AUTO_PROFILER_STATS
(
gecko_SamplerThread_Run_DoPeriodicSample
)
;
const
uint64_t
bufferRangeStart
=
buffer
.
BufferRangeStart
(
)
;
const
uint64_t
samplePos
=
buffer
.
AddThreadIdEntry
(
threadId
)
;
profiledThreadData
-
>
LastSample
(
)
=
Some
(
samplePos
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
TimeBeforeCompactStack
(
threadSampleDeltaMs
)
)
;
Maybe
<
double
>
unresponsiveDuration_ms
;
if
(
!
runningTimesDiff
.
IsEmpty
(
)
)
{
CorePS
:
:
CoreBuffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
RunningTimes
runningTimesDiff
)
;
}
if
(
stackSampling
)
{
ThreadRegistry
:
:
OffThreadRef
:
:
RWFromAnyThreadWithLock
lockedThreadData
=
offThreadRef
-
>
LockedRWFromAnyThread
(
)
;
mSampler
.
SuspendAndSampleAndResumeThread
(
lock
lockedThreadData
.
DataCRef
(
)
now
[
&
]
(
const
Registers
&
aRegs
const
TimeStamp
&
aNow
)
{
DoPeriodicSample
(
lock
lockedThreadData
.
DataCRef
(
)
aRegs
samplePos
bufferRangeStart
localProfileBuffer
)
;
TimeDuration
currentEventDelay
;
TimeDuration
currentEventRunning
;
lockedThreadData
-
>
GetRunningEventDelay
(
aNow
currentEventDelay
currentEventRunning
)
;
unresponsiveDuration_ms
=
Some
(
currentEventDelay
.
ToMilliseconds
(
)
+
currentEventRunning
.
ToMilliseconds
(
)
)
;
}
)
;
if
(
unresponsiveDuration_ms
.
isSome
(
)
)
{
CorePS
:
:
CoreBuffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
UnresponsiveDurationMs
*
unresponsiveDuration_ms
)
;
}
}
auto
state
=
localBuffer
.
GetState
(
)
;
if
(
NS_WARN_IF
(
state
.
mFailedPutBytes
!
=
previousState
.
mFailedPutBytes
)
)
{
LOG
(
"
Stack
sample
too
big
for
local
storage
failed
to
store
%
u
"
"
bytes
"
unsigned
(
state
.
mFailedPutBytes
-
previousState
.
mFailedPutBytes
)
)
;
CorePS
:
:
CoreBuffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
CompactStack
UniquePtr
<
ProfileChunkedBuffer
>
(
nullptr
)
)
;
}
else
if
(
state
.
mRangeEnd
-
previousState
.
mRangeEnd
>
=
*
CorePS
:
:
CoreBuffer
(
)
.
BufferLength
(
)
)
{
LOG
(
"
Stack
sample
too
big
for
profiler
storage
needed
%
u
bytes
"
unsigned
(
state
.
mRangeEnd
-
previousState
.
mRangeEnd
)
)
;
CorePS
:
:
CoreBuffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
CompactStack
UniquePtr
<
ProfileChunkedBuffer
>
(
nullptr
)
)
;
}
else
{
CorePS
:
:
CoreBuffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
CompactStack
localBuffer
)
;
}
localBuffer
.
Clear
(
)
;
previousState
=
localBuffer
.
GetState
(
)
;
}
}
else
{
samplingState
=
SamplingState
:
:
NoStackSamplingCompleted
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
lul
:
:
LUL
*
lul
=
CorePS
:
:
Lul
(
lock
)
;
if
(
lul
)
{
lul
-
>
MaybeShowStats
(
)
;
}
#
endif
TimeStamp
threadsSampled
=
TimeStamp
:
:
Now
(
)
;
{
AUTO_PROFILER_STATS
(
Sampler_FulfillChunkRequests
)
;
ActivePS
:
:
FulfillChunkRequests
(
lock
)
;
}
buffer
.
CollectOverheadStats
(
sampleStartDeltaMs
lockAcquired
-
sampleStart
expiredMarkersCleaned
-
lockAcquired
countersSampled
-
expiredMarkersCleaned
threadsSampled
-
countersSampled
)
;
}
else
{
samplingState
=
SamplingState
:
:
SamplingPaused
;
}
}
InvokePostSamplingCallbacks
(
std
:
:
move
(
postSamplingCallbacks
)
samplingState
)
;
ProfilerChild
:
:
ProcessPendingUpdate
(
)
;
scheduledSampleStart
+
=
sampleInterval
;
const
TimeStamp
beforeSleep
=
TimeStamp
:
:
Now
(
)
;
if
(
scheduledSampleStart
>
=
beforeSleep
)
{
const
uint32_t
sleepTimeUs
=
static_cast
<
uint32_t
>
(
(
scheduledSampleStart
-
beforeSleep
)
.
ToMicroseconds
(
)
)
;
if
(
sleepTimeUs
>
=
minimumIntervalSleepUs
)
{
SleepMicro
(
sleepTimeUs
)
;
}
else
{
SleepMicro
(
minimumIntervalSleepUs
)
;
}
}
else
{
scheduledSampleStart
=
beforeSleep
+
sampleInterval
;
SleepMicro
(
static_cast
<
uint32_t
>
(
sampleInterval
.
ToMicroseconds
(
)
)
)
;
}
}
InvokePostSamplingCallbacks
(
std
:
:
move
(
postSamplingCallbacks
)
samplingState
)
;
}
#
if
defined
(
GP_OS_windows
)
#
include
"
platform
-
win32
.
cpp
"
#
elif
defined
(
GP_OS_darwin
)
#
include
"
platform
-
macos
.
cpp
"
#
elif
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
#
include
"
platform
-
linux
-
android
.
cpp
"
#
else
#
error
"
bad
platform
"
#
endif
UniquePlatformData
AllocPlatformData
(
ProfilerThreadId
aThreadId
)
{
return
UniquePlatformData
(
new
PlatformData
(
aThreadId
)
)
;
}
void
PlatformDataDestructor
:
:
operator
(
)
(
PlatformData
*
aData
)
{
delete
aData
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
GeckoProfilerMallocSizeOf
)
NS_IMETHODIMP
GeckoProfilerReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
size_t
profSize
=
0
;
size_t
lulSize
=
0
;
{
PSAutoLock
lock
;
if
(
CorePS
:
:
Exists
(
)
)
{
CorePS
:
:
AddSizeOf
(
lock
GeckoProfilerMallocSizeOf
profSize
lulSize
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
profSize
+
=
ActivePS
:
:
SizeOf
(
lock
GeckoProfilerMallocSizeOf
)
;
}
}
MOZ_COLLECT_REPORT
(
"
explicit
/
profiler
/
profiler
-
state
"
KIND_HEAP
UNITS_BYTES
profSize
"
Memory
used
by
the
Gecko
Profiler
'
s
global
state
(
excluding
memory
used
"
"
by
LUL
)
.
"
)
;
#
if
defined
(
USE_LUL_STACKWALK
)
MOZ_COLLECT_REPORT
(
"
explicit
/
profiler
/
lul
"
KIND_HEAP
UNITS_BYTES
lulSize
"
Memory
used
by
LUL
a
stack
unwinder
used
by
the
Gecko
Profiler
.
"
)
;
#
endif
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
GeckoProfilerReporter
nsIMemoryReporter
)
static
uint32_t
ParseFeature
(
const
char
*
aFeature
bool
aIsStartup
)
{
if
(
strcmp
(
aFeature
"
default
"
)
=
=
0
)
{
return
(
aIsStartup
?
(
DefaultFeatures
(
)
|
StartupExtraDefaultFeatures
(
)
)
:
DefaultFeatures
(
)
)
&
AvailableFeatures
(
)
;
}
#
define
PARSE_FEATURE_BIT
(
n_
str_
Name_
desc_
)
\
if
(
strcmp
(
aFeature
str_
)
=
=
0
)
{
\
return
ProfilerFeature
:
:
Name_
;
\
}
PROFILER_FOR_EACH_FEATURE
(
PARSE_FEATURE_BIT
)
#
undef
PARSE_FEATURE_BIT
printf
(
"
\
nUnrecognized
feature
\
"
%
s
\
"
.
\
n
\
n
"
aFeature
)
;
PrintUsageThenExit
(
0
)
;
return
0
;
}
uint32_t
ParseFeaturesFromStringArray
(
const
char
*
*
aFeatures
uint32_t
aFeatureCount
bool
aIsStartup
)
{
uint32_t
features
=
0
;
for
(
size_t
i
=
0
;
i
<
aFeatureCount
;
i
+
+
)
{
features
|
=
ParseFeature
(
aFeatures
[
i
]
aIsStartup
)
;
}
return
features
;
}
static
bool
IsRegisteredThreadInRegisteredThreadsList
(
PSLockRef
aLock
RegisteredThread
*
aThread
)
{
const
auto
&
registeredThreads
=
CorePS
:
:
RegisteredThreads
(
aLock
)
;
for
(
const
auto
&
registeredThread
:
registeredThreads
)
{
if
(
registeredThread
.
get
(
)
=
=
aThread
)
{
return
true
;
}
}
return
false
;
}
static
ProfilingStack
*
locked_register_thread
(
PSLockRef
aLock
ThreadRegistry
:
:
OffThreadRef
aOffThreadRef
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
VTUNE_REGISTER_THREAD
(
aOffThreadRef
.
UnlockedConstReaderCRef
(
)
.
Info
(
)
.
Name
(
)
)
;
if
(
!
TLSRegisteredThread
:
:
IsTLSInited
(
)
)
{
return
nullptr
;
}
ThreadRegistration
*
tr
;
static_assert
(
sizeof
(
tr
)
=
=
sizeof
(
aOffThreadRef
)
)
;
memcpy
(
&
tr
&
aOffThreadRef
sizeof
(
tr
)
)
;
UniquePtr
<
RegisteredThread
>
registeredThread
=
MakeUnique
<
RegisteredThread
>
(
*
tr
)
;
TLSRegisteredThread
:
:
SetRegisteredThread
(
aLock
registeredThread
.
get
(
)
)
;
ThreadRegistry
:
:
OffThreadRef
:
:
RWFromAnyThreadWithLock
lockedRWFromAnyThread
=
aOffThreadRef
.
LockedRWFromAnyThread
(
)
;
ThreadRegistration
:
:
LockedRWOnThread
*
lockedRWOnThread
=
lockedRWFromAnyThread
.
GetLockedRWOnThread
(
)
;
MOZ_RELEASE_ASSERT
(
lockedRWOnThread
"
At
the
moment
we
should
only
get
here
when
registering
the
current
"
"
thread
(
either
through
profiler_register_thread
or
from
profiler_init
"
"
on
the
main
thread
registering
that
main
thread
)
.
"
)
;
lockedRWOnThread
-
>
SetRegisteredThread
(
registeredThread
.
get
(
)
)
;
if
(
ActivePS
:
:
Exists
(
aLock
)
&
&
ActivePS
:
:
ShouldProfileThread
(
aLock
aOffThreadRef
.
UnlockedConstReaderCRef
(
)
.
Info
(
)
)
)
{
registeredThread
-
>
RacyRegisteredThread
(
)
.
SetIsBeingProfiled
(
true
)
;
nsCOMPtr
<
nsIEventTarget
>
eventTarget
=
registeredThread
-
>
GetEventTarget
(
)
;
ProfiledThreadData
*
profiledThreadData
=
ActivePS
:
:
AddLiveProfiledThread
(
aLock
registeredThread
.
get
(
)
MakeUnique
<
ProfiledThreadData
>
(
aOffThreadRef
.
UnlockedConstReaderCRef
(
)
.
Info
(
)
eventTarget
)
)
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
registeredThread
-
>
StartJSSampling
(
ActivePS
:
:
JSFlags
(
aLock
)
)
;
registeredThread
-
>
PollJSSampling
(
)
;
if
(
registeredThread
-
>
GetJSContext
(
)
)
{
profiledThreadData
-
>
NotifyReceivedJSContext
(
ActivePS
:
:
Buffer
(
aLock
)
.
BufferRangeEnd
(
)
)
;
}
}
}
MOZ_RELEASE_ASSERT
(
TLSRegisteredThread
:
:
RegisteredThread
(
aLock
)
"
TLS
should
be
set
when
registering
thread
"
)
;
MOZ_RELEASE_ASSERT
(
registeredThread
=
=
TLSRegisteredThread
:
:
RegisteredThread
(
aLock
)
"
TLS
should
be
set
as
expected
when
registering
thread
"
)
;
ProfilingStack
*
profilingStack
=
&
registeredThread
-
>
RacyRegisteredThread
(
)
.
ProfilingStack
(
)
;
CorePS
:
:
AppendRegisteredThread
(
aLock
std
:
:
move
(
registeredThread
)
)
;
return
profilingStack
;
}
static
void
NotifyObservers
(
const
char
*
aTopic
nsISupports
*
aSubject
=
nullptr
)
{
if
(
!
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsISupports
>
subject
=
aSubject
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
NotifyObservers
"
[
=
]
{
NotifyObservers
(
aTopic
subject
)
;
}
)
)
;
return
;
}
if
(
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
)
{
os
-
>
NotifyObservers
(
aSubject
aTopic
nullptr
)
;
}
}
static
void
NotifyProfilerStarted
(
const
PowerOfTwo32
&
aCapacity
const
Maybe
<
double
>
&
aDuration
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
)
{
nsTArray
<
nsCString
>
filtersArray
;
for
(
size_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
filtersArray
.
AppendElement
(
aFilters
[
i
]
)
;
}
nsCOMPtr
<
nsIProfilerStartParams
>
params
=
new
nsProfilerStartParams
(
aCapacity
.
Value
(
)
aDuration
aInterval
aFeatures
std
:
:
move
(
filtersArray
)
aActiveTabID
)
;
ProfilerParent
:
:
ProfilerStarted
(
params
)
;
NotifyObservers
(
"
profiler
-
started
"
params
)
;
}
static
void
locked_profiler_start
(
PSLockRef
aLock
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
const
Maybe
<
double
>
&
aDuration
)
;
static
void
*
MozGlueLabelEnter
(
const
char
*
aLabel
const
char
*
aDynamicString
void
*
aSp
)
{
ThreadRegistration
:
:
OnThreadPtr
onThreadPtr
=
ThreadRegistration
:
:
GetOnThreadPtr
(
)
;
if
(
!
onThreadPtr
)
{
return
nullptr
;
}
ProfilingStack
&
profilingStack
=
onThreadPtr
-
>
UnlockedConstReaderAndAtomicRWRef
(
)
.
ProfilingStackRef
(
)
;
profilingStack
.
pushLabelFrame
(
aLabel
aDynamicString
aSp
JS
:
:
ProfilingCategoryPair
:
:
OTHER
)
;
return
&
profilingStack
;
}
static
void
MozGlueLabelExit
(
void
*
aProfilingStack
)
{
if
(
aProfilingStack
)
{
reinterpret_cast
<
ProfilingStack
*
>
(
aProfilingStack
)
-
>
pop
(
)
;
}
}
static
Vector
<
const
char
*
>
SplitAtCommas
(
const
char
*
aString
UniquePtr
<
char
[
]
>
&
aStorage
)
{
size_t
len
=
strlen
(
aString
)
;
aStorage
=
MakeUnique
<
char
[
]
>
(
len
+
1
)
;
PodCopy
(
aStorage
.
get
(
)
aString
len
+
1
)
;
Vector
<
const
char
*
>
array
;
size_t
currentElementStart
=
0
;
for
(
size_t
i
=
0
;
i
<
=
len
;
i
+
+
)
{
if
(
aStorage
[
i
]
=
=
'
'
)
{
aStorage
[
i
]
=
'
\
0
'
;
}
if
(
aStorage
[
i
]
=
=
'
\
0
'
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
&
aStorage
[
currentElementStart
]
)
)
;
currentElementStart
=
i
+
1
;
}
}
return
array
;
}
void
profiler_init_threadmanager
(
)
{
LOG
(
"
profiler_init_threadmanager
"
)
;
PSAutoLock
lock
;
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
registeredThread
&
&
!
registeredThread
-
>
GetEventTarget
(
)
)
{
registeredThread
-
>
ResetMainThread
(
NS_GetCurrentThreadNoCreate
(
)
)
;
}
}
void
profiler_init
(
void
*
aStackTop
)
{
LOG
(
"
profiler_init
"
)
;
profiler_init_main_thread_id
(
)
;
VTUNE_INIT
(
)
;
MOZ_RELEASE_ASSERT
(
!
CorePS
:
:
Exists
(
)
)
;
if
(
getenv
(
"
MOZ_PROFILER_HELP
"
)
)
{
PrintUsageThenExit
(
1
)
;
}
TLSRegisteredThread
:
:
Init
(
)
;
SharedLibraryInfo
:
:
Initialize
(
)
;
uint32_t
features
=
DefaultFeatures
(
)
&
AvailableFeatures
(
)
;
UniquePtr
<
char
[
]
>
filterStorage
;
Vector
<
const
char
*
>
filters
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
"
GeckoMain
"
)
)
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
"
Compositor
"
)
)
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
"
Renderer
"
)
)
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
"
DOM
Worker
"
)
)
;
PowerOfTwo32
capacity
=
PROFILER_DEFAULT_ENTRIES
;
Maybe
<
double
>
duration
=
Nothing
(
)
;
double
interval
=
PROFILER_DEFAULT_INTERVAL
;
uint64_t
activeTabID
=
PROFILER_DEFAULT_ACTIVE_TAB_ID
;
ThreadRegistration
:
:
RegisterThread
(
kMainThreadName
aStackTop
)
;
{
PSAutoLock
lock
;
CorePS
:
:
Create
(
lock
)
;
{
ThreadRegistry
:
:
LockedRegistry
lockedRegistry
;
for
(
ThreadRegistry
:
:
OffThreadRef
offThreadRef
:
lockedRegistry
)
{
locked_register_thread
(
lock
offThreadRef
)
;
}
}
PlatformInit
(
lock
)
;
#
if
defined
(
GP_OS_android
)
if
(
jni
:
:
IsAvailable
(
)
)
{
GeckoJavaSampler
:
:
Init
(
)
;
}
#
endif
const
char
*
startupEnv
=
getenv
(
"
MOZ_PROFILER_STARTUP
"
)
;
if
(
!
startupEnv
|
|
startupEnv
[
0
]
=
=
'
\
0
'
|
|
(
(
startupEnv
[
0
]
=
=
'
0
'
|
|
startupEnv
[
0
]
=
=
'
N
'
|
|
startupEnv
[
0
]
=
=
'
n
'
)
&
&
startupEnv
[
1
]
=
=
'
\
0
'
)
)
{
return
;
}
LOG
(
"
-
MOZ_PROFILER_STARTUP
is
set
"
)
;
capacity
=
PROFILER_DEFAULT_STARTUP_ENTRIES
;
const
char
*
startupCapacity
=
getenv
(
"
MOZ_PROFILER_STARTUP_ENTRIES
"
)
;
if
(
startupCapacity
&
&
startupCapacity
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
long
capacityLong
=
strtol
(
startupCapacity
nullptr
10
)
;
if
(
errno
=
=
0
&
&
capacityLong
>
0
&
&
static_cast
<
uint64_t
>
(
capacityLong
)
<
=
static_cast
<
uint64_t
>
(
INT32_MAX
)
)
{
capacity
=
PowerOfTwo32
(
ActivePS
:
:
ClampToAllowedEntries
(
static_cast
<
uint32_t
>
(
capacityLong
)
)
)
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_ENTRIES
=
%
u
"
unsigned
(
capacity
.
Value
(
)
)
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_ENTRIES
not
a
valid
integer
:
%
s
"
startupCapacity
)
;
PrintUsageThenExit
(
1
)
;
}
}
const
char
*
startupDuration
=
getenv
(
"
MOZ_PROFILER_STARTUP_DURATION
"
)
;
if
(
startupDuration
&
&
startupDuration
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
double
durationVal
=
PR_strtod
(
startupDuration
nullptr
)
;
if
(
errno
=
=
0
&
&
durationVal
>
=
0
.
0
)
{
if
(
durationVal
>
0
.
0
)
{
duration
=
Some
(
durationVal
)
;
}
LOG
(
"
-
MOZ_PROFILER_STARTUP_DURATION
=
%
f
"
durationVal
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_DURATION
not
a
valid
float
:
%
s
"
startupDuration
)
;
PrintUsageThenExit
(
1
)
;
}
}
const
char
*
startupInterval
=
getenv
(
"
MOZ_PROFILER_STARTUP_INTERVAL
"
)
;
if
(
startupInterval
&
&
startupInterval
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
interval
=
PR_strtod
(
startupInterval
nullptr
)
;
if
(
errno
=
=
0
&
&
interval
>
0
.
0
&
&
interval
<
=
PROFILER_MAX_INTERVAL
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_INTERVAL
=
%
f
"
interval
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_INTERVAL
not
a
valid
float
:
%
s
"
startupInterval
)
;
PrintUsageThenExit
(
1
)
;
}
}
features
|
=
StartupExtraDefaultFeatures
(
)
&
AvailableFeatures
(
)
;
const
char
*
startupFeaturesBitfield
=
getenv
(
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
"
)
;
if
(
startupFeaturesBitfield
&
&
startupFeaturesBitfield
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
features
=
strtol
(
startupFeaturesBitfield
nullptr
10
)
;
if
(
errno
=
=
0
&
&
features
!
=
0
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
=
%
d
"
features
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
not
a
valid
integer
:
%
s
"
startupFeaturesBitfield
)
;
PrintUsageThenExit
(
1
)
;
}
}
else
{
const
char
*
startupFeatures
=
getenv
(
"
MOZ_PROFILER_STARTUP_FEATURES
"
)
;
if
(
startupFeatures
&
&
startupFeatures
[
0
]
!
=
'
\
0
'
)
{
UniquePtr
<
char
[
]
>
featureStringStorage
;
Vector
<
const
char
*
>
featureStringArray
=
SplitAtCommas
(
startupFeatures
featureStringStorage
)
;
features
=
ParseFeaturesFromStringArray
(
featureStringArray
.
begin
(
)
featureStringArray
.
length
(
)
true
)
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_FEATURES
=
%
d
"
features
)
;
}
}
const
char
*
startupFilters
=
getenv
(
"
MOZ_PROFILER_STARTUP_FILTERS
"
)
;
if
(
startupFilters
&
&
startupFilters
[
0
]
!
=
'
\
0
'
)
{
filters
=
SplitAtCommas
(
startupFilters
filterStorage
)
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_FILTERS
=
%
s
"
startupFilters
)
;
}
const
char
*
startupActiveTabID
=
getenv
(
"
MOZ_PROFILER_STARTUP_ACTIVE_TAB_ID
"
)
;
if
(
startupActiveTabID
&
&
startupActiveTabID
[
0
]
!
=
'
\
0
'
)
{
std
:
:
istringstream
iss
(
startupActiveTabID
)
;
iss
>
>
activeTabID
;
if
(
!
iss
.
fail
(
)
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_ACTIVE_TAB_ID
=
%
"
PRIu64
activeTabID
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_ACTIVE_TAB_ID
not
a
valid
"
"
uint64_t
:
%
s
"
startupActiveTabID
)
;
PrintUsageThenExit
(
1
)
;
}
}
locked_profiler_start
(
lock
capacity
interval
features
filters
.
begin
(
)
filters
.
length
(
)
activeTabID
duration
)
;
}
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
ActivePS
:
:
SetMemoryCounter
(
mozilla
:
:
profiler
:
:
install_memory_hooks
(
)
)
;
#
endif
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
Started
)
;
NotifyProfilerStarted
(
capacity
duration
interval
features
filters
.
begin
(
)
filters
.
length
(
)
0
)
;
}
static
void
locked_profiler_save_profile_to_file
(
PSLockRef
aLock
const
char
*
aFilename
const
PreRecordedMetaInformation
&
aPreRecordedMetaInformation
bool
aIsShuttingDown
)
;
static
SamplerThread
*
locked_profiler_stop
(
PSLockRef
aLock
)
;
void
profiler_shutdown
(
IsFastShutdown
aIsFastShutdown
)
{
LOG
(
"
profiler_shutdown
"
)
;
VTUNE_SHUTDOWN
(
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
profiler_is_active
(
)
)
{
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
Stopping
)
;
}
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
ShuttingDown
)
;
const
auto
preRecordedMetaInformation
=
PreRecordMetaInformation
(
)
;
ProfilerParent
:
:
ProfilerWillStopIfStarted
(
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
const
char
*
filename
=
getenv
(
"
MOZ_PROFILER_SHUTDOWN
"
)
;
if
(
filename
)
{
locked_profiler_save_profile_to_file
(
lock
filename
preRecordedMetaInformation
true
)
;
}
if
(
aIsFastShutdown
=
=
IsFastShutdown
:
:
Yes
)
{
return
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
else
if
(
aIsFastShutdown
=
=
IsFastShutdown
:
:
Yes
)
{
return
;
}
CorePS
:
:
Destroy
(
lock
)
;
}
if
(
samplerThread
)
{
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
ThreadRegistration
:
:
UnregisterThread
(
)
;
}
static
bool
WriteProfileToJSONWriter
(
SpliceableChunkedJSONWriter
&
aWriter
double
aSinceTime
bool
aIsShuttingDown
ProfilerCodeAddressService
*
aService
)
{
LOG
(
"
WriteProfileToJSONWriter
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
aWriter
.
Start
(
)
;
{
if
(
!
profiler_stream_json_for_this_process
(
aWriter
aSinceTime
aIsShuttingDown
aService
)
)
{
return
false
;
}
aWriter
.
StartArrayProperty
(
"
processes
"
)
;
aWriter
.
EndArray
(
)
;
}
aWriter
.
End
(
)
;
return
true
;
}
void
profiler_set_process_name
(
const
nsACString
&
aProcessName
const
nsACString
*
aETLDplus1
)
{
LOG
(
"
profiler_set_process_name
(
\
"
%
s
\
"
\
"
%
s
\
"
)
"
aProcessName
.
Data
(
)
aETLDplus1
?
aETLDplus1
-
>
Data
(
)
:
"
<
none
>
"
)
;
PSAutoLock
lock
;
CorePS
:
:
SetProcessName
(
lock
aProcessName
)
;
if
(
aETLDplus1
)
{
CorePS
:
:
SetETLDplus1
(
lock
*
aETLDplus1
)
;
}
}
UniquePtr
<
char
[
]
>
profiler_get_profile
(
double
aSinceTime
bool
aIsShuttingDown
)
{
LOG
(
"
profiler_get_profile
"
)
;
UniquePtr
<
ProfilerCodeAddressService
>
service
=
profiler_code_address_service_for_presymbolication
(
)
;
SpliceableChunkedJSONWriter
b
;
if
(
!
WriteProfileToJSONWriter
(
b
aSinceTime
aIsShuttingDown
service
.
get
(
)
)
)
{
return
nullptr
;
}
return
b
.
ChunkedWriteFunc
(
)
.
CopyData
(
)
;
}
void
profiler_get_profile_json_into_lazily_allocated_buffer
(
const
std
:
:
function
<
char
*
(
size_t
)
>
&
aAllocator
double
aSinceTime
bool
aIsShuttingDown
)
{
LOG
(
"
profiler_get_profile_json_into_lazily_allocated_buffer
"
)
;
UniquePtr
<
ProfilerCodeAddressService
>
service
=
profiler_code_address_service_for_presymbolication
(
)
;
SpliceableChunkedJSONWriter
b
;
if
(
!
WriteProfileToJSONWriter
(
b
aSinceTime
aIsShuttingDown
service
.
get
(
)
)
)
{
return
;
}
b
.
ChunkedWriteFunc
(
)
.
CopyDataIntoLazilyAllocatedBuffer
(
aAllocator
)
;
}
void
profiler_get_start_params
(
int
*
aCapacity
Maybe
<
double
>
*
aDuration
double
*
aInterval
uint32_t
*
aFeatures
Vector
<
const
char
*
>
*
aFilters
uint64_t
*
aActiveTabID
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
NS_WARN_IF
(
!
aCapacity
)
|
|
NS_WARN_IF
(
!
aDuration
)
|
|
NS_WARN_IF
(
!
aInterval
)
|
|
NS_WARN_IF
(
!
aFeatures
)
|
|
NS_WARN_IF
(
!
aFilters
)
)
{
return
;
}
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
*
aCapacity
=
0
;
*
aDuration
=
Nothing
(
)
;
*
aInterval
=
0
;
*
aFeatures
=
0
;
*
aActiveTabID
=
0
;
aFilters
-
>
clear
(
)
;
return
;
}
*
aCapacity
=
ActivePS
:
:
Capacity
(
lock
)
.
Value
(
)
;
*
aDuration
=
ActivePS
:
:
Duration
(
lock
)
;
*
aInterval
=
ActivePS
:
:
Interval
(
lock
)
;
*
aFeatures
=
ActivePS
:
:
Features
(
lock
)
;
*
aActiveTabID
=
ActivePS
:
:
ActiveTabID
(
lock
)
;
const
Vector
<
std
:
:
string
>
&
filters
=
ActivePS
:
:
Filters
(
lock
)
;
MOZ_ALWAYS_TRUE
(
aFilters
-
>
resize
(
filters
.
length
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
filters
.
length
(
)
;
+
+
i
)
{
(
*
aFilters
)
[
i
]
=
filters
[
i
]
.
c_str
(
)
;
}
}
ProfileBufferControlledChunkManager
*
profiler_get_controlled_chunk_manager
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
NS_WARN_IF
(
!
ActivePS
:
:
Exists
(
lock
)
)
)
{
return
nullptr
;
}
return
&
ActivePS
:
:
ControlledChunkManager
(
lock
)
;
}
namespace
mozilla
{
void
GetProfilerEnvVarsForChildProcess
(
std
:
:
function
<
void
(
const
char
*
key
const
char
*
value
)
>
&
&
aSetEnv
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
aSetEnv
(
"
MOZ_PROFILER_STARTUP
"
"
"
)
;
return
;
}
aSetEnv
(
"
MOZ_PROFILER_STARTUP
"
"
1
"
)
;
if
(
getenv
(
"
MOZ_PROFILER_STARTUP_NO_BASE
"
)
)
{
aSetEnv
(
"
MOZ_PROFILER_STARTUP_NO_BASE
"
"
1
"
)
;
}
auto
capacityString
=
Smprintf
(
"
%
u
"
unsigned
(
ActivePS
:
:
Capacity
(
lock
)
.
Value
(
)
)
)
;
aSetEnv
(
"
MOZ_PROFILER_STARTUP_ENTRIES
"
capacityString
.
get
(
)
)
;
nsCString
intervalString
;
intervalString
.
AppendFloat
(
ActivePS
:
:
Interval
(
lock
)
)
;
aSetEnv
(
"
MOZ_PROFILER_STARTUP_INTERVAL
"
intervalString
.
get
(
)
)
;
auto
featuresString
=
Smprintf
(
"
%
d
"
ActivePS
:
:
Features
(
lock
)
)
;
aSetEnv
(
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
"
featuresString
.
get
(
)
)
;
std
:
:
string
filtersString
;
const
Vector
<
std
:
:
string
>
&
filters
=
ActivePS
:
:
Filters
(
lock
)
;
for
(
uint32_t
i
=
0
;
i
<
filters
.
length
(
)
;
+
+
i
)
{
if
(
i
!
=
0
)
{
filtersString
+
=
"
"
;
}
filtersString
+
=
filters
[
i
]
;
}
aSetEnv
(
"
MOZ_PROFILER_STARTUP_FILTERS
"
filtersString
.
c_str
(
)
)
;
auto
activeTabIDString
=
Smprintf
(
"
%
"
PRIu64
ActivePS
:
:
ActiveTabID
(
lock
)
)
;
aSetEnv
(
"
MOZ_PROFILER_STARTUP_ACTIVE_TAB_ID
"
activeTabIDString
.
get
(
)
)
;
}
}
void
profiler_received_exit_profile
(
const
nsCString
&
aExitProfile
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
ActivePS
:
:
AddExitProfile
(
lock
aExitProfile
)
;
}
Vector
<
nsCString
>
profiler_move_exit_profiles
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
Vector
<
nsCString
>
profiles
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
profiles
=
ActivePS
:
:
MoveExitProfiles
(
lock
)
;
}
return
profiles
;
}
static
void
locked_profiler_save_profile_to_file
(
PSLockRef
aLock
const
char
*
aFilename
const
PreRecordedMetaInformation
&
aPreRecordedMetaInformation
bool
aIsShuttingDown
=
false
)
{
LOG
(
"
locked_profiler_save_profile_to_file
(
%
s
)
"
aFilename
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
std
:
:
ofstream
stream
;
stream
.
open
(
aFilename
)
;
if
(
stream
.
is_open
(
)
)
{
SpliceableJSONWriter
w
(
MakeUnique
<
OStreamJSONWriteFunc
>
(
stream
)
)
;
w
.
Start
(
)
;
{
locked_profiler_stream_json_for_this_process
(
aLock
w
0
aPreRecordedMetaInformation
aIsShuttingDown
nullptr
)
;
w
.
StartArrayProperty
(
"
processes
"
)
;
Vector
<
nsCString
>
exitProfiles
=
ActivePS
:
:
MoveExitProfiles
(
aLock
)
;
for
(
auto
&
exitProfile
:
exitProfiles
)
{
if
(
!
exitProfile
.
IsEmpty
(
)
)
{
w
.
Splice
(
exitProfile
)
;
}
}
w
.
EndArray
(
)
;
}
w
.
End
(
)
;
stream
.
close
(
)
;
}
}
void
profiler_save_profile_to_file
(
const
char
*
aFilename
)
{
LOG
(
"
profiler_save_profile_to_file
(
%
s
)
"
aFilename
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
const
auto
preRecordedMetaInformation
=
PreRecordMetaInformation
(
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
locked_profiler_save_profile_to_file
(
lock
aFilename
preRecordedMetaInformation
)
;
}
uint32_t
profiler_get_available_features
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
return
AvailableFeatures
(
)
;
}
Maybe
<
ProfilerBufferInfo
>
profiler_get_buffer_info
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
Nothing
(
)
;
}
return
Some
(
ActivePS
:
:
Buffer
(
lock
)
.
GetProfilerBufferInfo
(
)
)
;
}
static
void
PollJSSamplingForCurrentThread
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
!
registeredThread
)
{
return
;
}
registeredThread
-
>
PollJSSampling
(
)
;
}
static
void
TriggerPollJSSamplingOnMainThread
(
)
{
nsCOMPtr
<
nsIThread
>
mainThread
;
nsresult
rv
=
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mainThread
)
{
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
"
TriggerPollJSSamplingOnMainThread
"
[
]
(
)
{
PollJSSamplingForCurrentThread
(
)
;
}
)
;
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
task
.
forget
(
)
)
;
}
}
static
bool
HasMinimumLength
(
const
char
*
aString
size_t
aMinimumLength
)
{
if
(
!
aString
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
aMinimumLength
;
+
+
i
)
{
if
(
aString
[
i
]
=
=
'
\
0
'
)
{
return
false
;
}
}
return
true
;
}
static
void
locked_profiler_start
(
PSLockRef
aLock
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
const
Maybe
<
double
>
&
aDuration
)
{
if
(
LOG_TEST
)
{
LOG
(
"
locked_profiler_start
"
)
;
LOG
(
"
-
capacity
=
%
u
"
unsigned
(
aCapacity
.
Value
(
)
)
)
;
LOG
(
"
-
duration
=
%
.
2f
"
aDuration
?
*
aDuration
:
-
1
)
;
LOG
(
"
-
interval
=
%
.
2f
"
aInterval
)
;
LOG
(
"
-
tab
ID
=
%
"
PRIu64
aActiveTabID
)
;
#
define
LOG_FEATURE
(
n_
str_
Name_
desc_
)
\
if
(
ProfilerFeature
:
:
Has
#
#
Name_
(
aFeatures
)
)
{
\
LOG
(
"
-
feature
=
%
s
"
str_
)
;
\
}
PROFILER_FOR_EACH_FEATURE
(
LOG_FEATURE
)
#
undef
LOG_FEATURE
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
i
+
+
)
{
LOG
(
"
-
threads
=
%
s
"
aFilters
[
i
]
)
;
}
}
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
!
ActivePS
:
:
Exists
(
aLock
)
)
;
UniquePtr
<
char
[
]
>
baseprofile
;
if
(
baseprofiler
:
:
profiler_is_active
(
)
)
{
baseprofile
=
baseprofiler
:
:
profiler_get_profile
(
0
false
true
)
;
baseprofiler
:
:
profiler_stop
(
)
;
}
#
if
defined
(
GP_PLAT_amd64_windows
)
InitializeWin64ProfilerHooks
(
)
;
#
endif
PowerOfTwo32
capacity
=
(
aCapacity
.
Value
(
)
>
=
ProfileBufferChunkManager
:
:
scExpectedMaximumStackSize
/
scBytesPerEntry
)
?
aCapacity
:
PROFILER_DEFAULT_ENTRIES
;
Maybe
<
double
>
duration
=
aDuration
;
if
(
aDuration
&
&
*
aDuration
<
=
0
)
{
duration
=
Nothing
(
)
;
}
double
interval
=
aInterval
>
0
?
aInterval
:
PROFILER_DEFAULT_INTERVAL
;
ActivePS
:
:
Create
(
aLock
capacity
interval
aFeatures
aFilters
aFilterCount
aActiveTabID
duration
)
;
MOZ_ASSERT
(
ActivePS
:
:
Exists
(
aLock
)
)
;
if
(
HasMinimumLength
(
baseprofile
.
get
(
)
2
)
)
{
ActivePS
:
:
AddBaseProfileThreads
(
aLock
std
:
:
move
(
baseprofile
)
)
;
}
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
bool
isMainThreadBeingProfiled
=
false
;
#
endif
ProfilerThreadId
tid
=
profiler_current_thread_id
(
)
;
const
Vector
<
UniquePtr
<
RegisteredThread
>
>
&
registeredThreads
=
CorePS
:
:
RegisteredThreads
(
aLock
)
;
for
(
auto
&
registeredThread
:
registeredThreads
)
{
const
ThreadRegistrationInfo
&
info
=
registeredThread
-
>
Info
(
)
;
if
(
ActivePS
:
:
ShouldProfileThread
(
aLock
info
)
)
{
registeredThread
-
>
RacyRegisteredThread
(
)
.
SetIsBeingProfiled
(
true
)
;
nsCOMPtr
<
nsIEventTarget
>
eventTarget
=
registeredThread
-
>
GetEventTarget
(
)
;
ProfiledThreadData
*
profiledThreadData
=
ActivePS
:
:
AddLiveProfiledThread
(
aLock
registeredThread
.
get
(
)
MakeUnique
<
ProfiledThreadData
>
(
info
eventTarget
)
)
;
ClearThreadRunningTimes
(
aLock
*
registeredThread
)
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
registeredThread
-
>
StartJSSampling
(
ActivePS
:
:
JSFlags
(
aLock
)
)
;
if
(
info
.
ThreadId
(
)
=
=
tid
)
{
registeredThread
-
>
PollJSSampling
(
)
;
}
else
if
(
info
.
IsMainThread
(
)
)
{
TriggerPollJSSamplingOnMainThread
(
)
;
}
}
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
info
.
IsMainThread
(
)
)
{
isMainThreadBeingProfiled
=
true
;
}
#
endif
registeredThread
-
>
RacyRegisteredThread
(
)
.
ReinitializeOnResume
(
)
;
if
(
registeredThread
-
>
GetJSContext
(
)
)
{
profiledThreadData
-
>
NotifyReceivedJSContext
(
0
)
;
}
}
}
RegisterProfilerLabelEnterExit
(
MozGlueLabelEnter
MozGlueLabelExit
)
;
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
int
javaInterval
=
interval
;
if
(
javaInterval
<
1
)
{
javaInterval
=
1
;
}
java
:
:
GeckoJavaSampler
:
:
Start
(
javaInterval
std
:
:
round
(
(
double
)
(
capacity
.
Value
(
)
)
*
interval
/
(
double
)
(
javaInterval
)
)
)
;
}
#
endif
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
ActivePS
:
:
FeatureNativeAllocations
(
aLock
)
)
{
if
(
isMainThreadBeingProfiled
)
{
mozilla
:
:
profiler
:
:
enable_native_allocations
(
)
;
}
else
{
NS_WARNING
(
"
The
nativeallocations
feature
is
turned
on
but
the
main
thread
is
"
"
not
being
profiled
.
The
allocations
are
only
stored
on
the
main
"
"
thread
.
"
)
;
}
}
#
endif
if
(
ProfilerFeature
:
:
HasAudioCallbackTracing
(
aFeatures
)
)
{
StartAudioCallbackTracing
(
)
;
}
RacyFeatures
:
:
SetActive
(
ActivePS
:
:
Features
(
aLock
)
)
;
}
void
profiler_start
(
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
const
Maybe
<
double
>
&
aDuration
)
{
LOG
(
"
profiler_start
"
)
;
ProfilerParent
:
:
ProfilerWillStopIfStarted
(
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
profiler_init
(
nullptr
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
locked_profiler_start
(
lock
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aActiveTabID
aDuration
)
;
}
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
ActivePS
:
:
SetMemoryCounter
(
mozilla
:
:
profiler
:
:
install_memory_hooks
(
)
)
;
#
endif
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
Started
)
;
if
(
samplerThread
)
{
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
NotifyProfilerStarted
(
aCapacity
aDuration
aInterval
aFeatures
aFilters
aFilterCount
aActiveTabID
)
;
}
void
profiler_ensure_started
(
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
const
Maybe
<
double
>
&
aDuration
)
{
LOG
(
"
profiler_ensure_started
"
)
;
ProfilerParent
:
:
ProfilerWillStopIfStarted
(
)
;
bool
startedProfiler
=
false
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
profiler_init
(
nullptr
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
if
(
!
ActivePS
:
:
Equals
(
lock
aCapacity
aDuration
aInterval
aFeatures
aFilters
aFilterCount
aActiveTabID
)
)
{
samplerThread
=
locked_profiler_stop
(
lock
)
;
locked_profiler_start
(
lock
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aActiveTabID
aDuration
)
;
startedProfiler
=
true
;
}
}
else
{
locked_profiler_start
(
lock
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aActiveTabID
aDuration
)
;
startedProfiler
=
true
;
}
}
if
(
samplerThread
)
{
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
if
(
startedProfiler
)
{
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
Started
)
;
NotifyProfilerStarted
(
aCapacity
aDuration
aInterval
aFeatures
aFilters
aFilterCount
aActiveTabID
)
;
}
}
[
[
nodiscard
]
]
static
SamplerThread
*
locked_profiler_stop
(
PSLockRef
aLock
)
{
LOG
(
"
locked_profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
RacyFeatures
:
:
SetInactive
(
)
;
if
(
ActivePS
:
:
FeatureAudioCallbackTracing
(
aLock
)
)
{
StopAudioCallbackTracing
(
)
;
}
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
java
:
:
GeckoJavaSampler
:
:
Stop
(
)
;
}
#
endif
RegisterProfilerLabelEnterExit
(
nullptr
nullptr
)
;
ProfilerThreadId
tid
=
profiler_current_thread_id
(
)
;
const
Vector
<
LiveProfiledThreadData
>
&
liveProfiledThreads
=
ActivePS
:
:
LiveProfiledThreads
(
aLock
)
;
for
(
auto
&
thread
:
liveProfiledThreads
)
{
RegisteredThread
*
registeredThread
=
thread
.
mRegisteredThread
;
registeredThread
-
>
RacyRegisteredThread
(
)
.
SetIsBeingProfiled
(
false
)
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
registeredThread
-
>
StopJSSampling
(
)
;
const
ThreadRegistrationInfo
&
info
=
registeredThread
-
>
Info
(
)
;
if
(
info
.
ThreadId
(
)
=
=
tid
)
{
registeredThread
-
>
PollJSSampling
(
)
;
}
else
if
(
info
.
IsMainThread
(
)
)
{
TriggerPollJSSamplingOnMainThread
(
)
;
}
}
}
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
ActivePS
:
:
FeatureNativeAllocations
(
aLock
)
)
{
mozilla
:
:
profiler
:
:
disable_native_allocations
(
)
;
}
#
endif
SamplerThread
*
samplerThread
=
ActivePS
:
:
Destroy
(
aLock
)
;
samplerThread
-
>
Stop
(
aLock
)
;
return
samplerThread
;
}
void
profiler_stop
(
)
{
LOG
(
"
profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
profiler_is_active
(
)
)
{
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
Stopping
)
;
}
ProfilerParent
:
:
ProfilerWillStopIfStarted
(
)
;
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
mozilla
:
:
profiler
:
:
remove_memory_hooks
(
)
;
#
endif
SamplerThread
*
samplerThread
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
bool
profiler_is_paused
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
return
ActivePS
:
:
IsPaused
(
lock
)
;
}
bool
profiler_callback_after_sampling
(
PostSamplingCallback
&
&
aCallback
)
{
LOG
(
"
profiler_callback_after_sampling
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
return
ActivePS
:
:
AppendPostSamplingCallback
(
lock
std
:
:
move
(
aCallback
)
)
;
}
void
profiler_pause
(
)
{
LOG
(
"
profiler_pause
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
Pausing
)
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
lock
)
&
&
!
ActivePS
:
:
IsSamplingPaused
(
lock
)
)
{
java
:
:
GeckoJavaSampler
:
:
PauseSampling
(
)
;
}
#
endif
RacyFeatures
:
:
SetPaused
(
)
;
ActivePS
:
:
SetIsPaused
(
lock
true
)
;
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
Pause
(
profiler_time
(
)
)
)
;
}
ProfilerParent
:
:
ProfilerPaused
(
)
;
NotifyObservers
(
"
profiler
-
paused
"
)
;
}
void
profiler_resume
(
)
{
LOG
(
"
profiler_resume
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
Resume
(
profiler_time
(
)
)
)
;
ActivePS
:
:
SetIsPaused
(
lock
false
)
;
RacyFeatures
:
:
SetUnpaused
(
)
;
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
lock
)
&
&
!
ActivePS
:
:
IsSamplingPaused
(
lock
)
)
{
java
:
:
GeckoJavaSampler
:
:
UnpauseSampling
(
)
;
}
#
endif
}
ProfilerParent
:
:
ProfilerResumed
(
)
;
NotifyObservers
(
"
profiler
-
resumed
"
)
;
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
Resumed
)
;
}
bool
profiler_is_sampling_paused
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
return
ActivePS
:
:
IsSamplingPaused
(
lock
)
;
}
void
profiler_pause_sampling
(
)
{
LOG
(
"
profiler_pause_sampling
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
lock
)
&
&
!
ActivePS
:
:
IsSamplingPaused
(
lock
)
)
{
java
:
:
GeckoJavaSampler
:
:
PauseSampling
(
)
;
}
#
endif
RacyFeatures
:
:
SetSamplingPaused
(
)
;
ActivePS
:
:
SetIsSamplingPaused
(
lock
true
)
;
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
PauseSampling
(
profiler_time
(
)
)
)
;
}
ProfilerParent
:
:
ProfilerPausedSampling
(
)
;
NotifyObservers
(
"
profiler
-
paused
-
sampling
"
)
;
}
void
profiler_resume_sampling
(
)
{
LOG
(
"
profiler_resume_sampling
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
ResumeSampling
(
profiler_time
(
)
)
)
;
ActivePS
:
:
SetIsSamplingPaused
(
lock
false
)
;
RacyFeatures
:
:
SetSamplingUnpaused
(
)
;
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
lock
)
&
&
!
ActivePS
:
:
IsSamplingPaused
(
lock
)
)
{
java
:
:
GeckoJavaSampler
:
:
UnpauseSampling
(
)
;
}
#
endif
}
ProfilerParent
:
:
ProfilerResumedSampling
(
)
;
NotifyObservers
(
"
profiler
-
resumed
-
sampling
"
)
;
}
bool
profiler_feature_active
(
uint32_t
aFeature
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
return
RacyFeatures
:
:
IsActiveWithFeature
(
aFeature
)
;
}
void
profiler_write_active_configuration
(
JSONWriter
&
aWriter
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
ActivePS
:
:
WriteActiveConfiguration
(
lock
aWriter
)
;
}
void
profiler_add_sampled_counter
(
BaseProfilerCount
*
aCounter
)
{
DEBUG_LOG
(
"
profiler_add_sampled_counter
(
%
s
)
"
aCounter
-
>
mLabel
)
;
PSAutoLock
lock
;
CorePS
:
:
AppendCounter
(
lock
aCounter
)
;
}
void
profiler_remove_sampled_counter
(
BaseProfilerCount
*
aCounter
)
{
DEBUG_LOG
(
"
profiler_remove_sampled_counter
(
%
s
)
"
aCounter
-
>
mLabel
)
;
PSAutoLock
lock
;
CorePS
:
:
RemoveCounter
(
lock
aCounter
)
;
}
ProfilingStack
*
profiler_register_thread
(
const
char
*
aName
void
*
aGuessStackTop
)
{
DEBUG_LOG
(
"
profiler_register_thread
(
%
s
)
"
aName
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
return
&
ThreadRegistration
:
:
RegisterThread
(
aName
aGuessStackTop
)
;
}
void
ThreadRegistry
:
:
Register
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
(
void
)
NS_GetCurrentThread
(
)
;
NS_SetCurrentThreadName
(
aOnThreadRef
.
UnlockedConstReaderCRef
(
)
.
Info
(
)
.
Name
(
)
)
;
PSAutoLock
lock
;
{
LockedRegistry
lock
;
MOZ_RELEASE_ASSERT
(
sRegistryContainer
.
append
(
OffThreadRef
{
aOnThreadRef
}
)
)
;
}
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
;
}
(
void
)
locked_register_thread
(
lock
OffThreadRef
{
aOnThreadRef
}
)
;
}
void
profiler_unregister_thread
(
)
{
ThreadRegistration
:
:
UnregisterThread
(
)
;
}
static
void
locked_unregister_thread
(
PSLockRef
lock
)
{
if
(
!
TLSRegisteredThread
:
:
IsTLSInited
(
)
)
{
return
;
}
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
;
}
if
(
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
)
{
MOZ_RELEASE_ASSERT
(
IsRegisteredThreadInRegisteredThreadsList
(
lock
registeredThread
)
"
Thread
being
unregistered
is
not
in
registered
thread
list
even
"
"
though
its
TLS
is
non
-
null
"
)
;
MOZ_RELEASE_ASSERT
(
registeredThread
-
>
Info
(
)
.
ThreadId
(
)
=
=
profiler_current_thread_id
(
)
"
Thread
being
unregistered
has
changed
its
TID
"
)
;
const
ThreadRegistrationInfo
&
info
=
registeredThread
-
>
Info
(
)
;
DEBUG_LOG
(
"
profiler_unregister_thread
:
%
s
"
info
.
Name
(
)
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
UnregisterThread
(
lock
registeredThread
)
;
}
ThreadRegistration
:
:
WithOnThreadRef
(
[
]
(
ThreadRegistration
:
:
OnThreadRef
threadRegistration
)
{
threadRegistration
.
WithLockedRWOnThread
(
[
]
(
ThreadRegistration
:
:
LockedRWOnThread
&
aRW
)
{
aRW
.
SetRegisteredThread
(
nullptr
)
;
}
)
;
}
)
;
TLSRegisteredThread
:
:
ResetRegisteredThread
(
lock
)
;
CorePS
:
:
RemoveRegisteredThread
(
lock
registeredThread
)
;
MOZ_RELEASE_ASSERT
(
!
IsRegisteredThreadInRegisteredThreadsList
(
lock
registeredThread
)
"
After
unregistering
thread
should
no
longer
be
in
the
registered
"
"
thread
list
"
)
;
MOZ_RELEASE_ASSERT
(
!
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
"
TLS
should
have
been
reset
after
un
-
registering
thread
"
)
;
}
}
void
ThreadRegistry
:
:
Unregister
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
PSAutoLock
psLock
;
locked_unregister_thread
(
psLock
)
;
LockedRegistry
registryLock
;
for
(
OffThreadRef
&
thread
:
sRegistryContainer
)
{
if
(
thread
.
IsPointingAt
(
*
aOnThreadRef
.
mThreadRegistration
)
)
{
sRegistryContainer
.
erase
(
&
thread
)
;
break
;
}
}
}
void
profiler_register_page
(
uint64_t
aTabID
uint64_t
aInnerWindowID
const
nsCString
&
aUrl
uint64_t
aEmbedderInnerWindowID
)
{
DEBUG_LOG
(
"
profiler_register_page
(
%
"
PRIu64
"
%
"
PRIu64
"
%
s
%
"
PRIu64
"
)
"
aTabID
aInnerWindowID
aUrl
.
get
(
)
aEmbedderInnerWindowID
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
RefPtr
<
PageInformation
>
pageInfo
=
new
PageInformation
(
aTabID
aInnerWindowID
aUrl
aEmbedderInnerWindowID
)
;
CorePS
:
:
AppendRegisteredPage
(
lock
std
:
:
move
(
pageInfo
)
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
DiscardExpiredPages
(
lock
)
;
}
}
void
profiler_unregister_page
(
uint64_t
aRegisteredInnerWindowID
)
{
PSAutoLock
lock
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
UnregisterPage
(
lock
aRegisteredInnerWindowID
)
;
}
else
{
CorePS
:
:
RemoveRegisteredPage
(
lock
aRegisteredInnerWindowID
)
;
}
}
void
profiler_clear_all_pages
(
)
{
{
PSAutoLock
lock
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
;
}
CorePS
:
:
ClearRegisteredPages
(
lock
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
ClearUnregisteredPages
(
lock
)
;
}
}
ProfilerParent
:
:
ClearAllPages
(
)
;
}
namespace
geckoprofiler
:
:
markers
:
:
detail
{
Maybe
<
uint64_t
>
profiler_get_inner_window_id_from_docshell
(
nsIDocShell
*
aDocshell
)
{
Maybe
<
uint64_t
>
innerWindowID
=
Nothing
(
)
;
if
(
aDocshell
)
{
auto
outerWindow
=
aDocshell
-
>
GetWindow
(
)
;
if
(
outerWindow
)
{
auto
innerWindow
=
outerWindow
-
>
GetCurrentInnerWindow
(
)
;
if
(
innerWindow
)
{
innerWindowID
=
Some
(
innerWindow
-
>
WindowID
(
)
)
;
}
}
}
return
innerWindowID
;
}
}
void
profiler_thread_sleep
(
)
{
ThreadRegistration
:
:
WithOnThreadRef
(
[
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
aOnThreadRef
.
UnlockedConstReaderAndAtomicRWRef
(
)
.
SetSleeping
(
)
;
}
)
;
}
void
profiler_thread_wake
(
)
{
ThreadRegistration
:
:
WithOnThreadRef
(
[
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
aOnThreadRef
.
UnlockedConstReaderAndAtomicRWRef
(
)
.
SetAwake
(
)
;
}
)
;
}
void
profiler_js_interrupt_callback
(
)
{
PollJSSamplingForCurrentThread
(
)
;
}
double
profiler_time
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
TimeDuration
delta
=
TimeStamp
:
:
Now
(
)
-
CorePS
:
:
ProcessStartTime
(
)
;
return
delta
.
ToMilliseconds
(
)
;
}
bool
profiler_capture_backtrace_into
(
ProfileChunkedBuffer
&
aChunkedBuffer
StackCaptureOptions
aCaptureOptions
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
|
|
aCaptureOptions
=
=
StackCaptureOptions
:
:
NoStack
)
{
return
false
;
}
return
ThreadRegistration
:
:
WithOnThreadRefOr
(
[
&
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
ProfileBuffer
profileBuffer
(
aChunkedBuffer
)
;
Registers
regs
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
regs
.
SyncPopulate
(
)
;
#
else
regs
.
Clear
(
)
;
#
endif
DoSyncSample
(
lock
aOnThreadRef
.
UnlockedReaderAndAtomicRWOnThreadCRef
(
)
TimeStamp
:
:
Now
(
)
regs
profileBuffer
aCaptureOptions
)
;
return
true
;
}
false
)
;
}
UniquePtr
<
ProfileChunkedBuffer
>
profiler_capture_backtrace
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
AUTO_PROFILER_LABEL
(
"
profiler_capture_backtrace
"
PROFILER
)
;
if
(
!
profiler_is_active
(
)
)
{
return
nullptr
;
}
auto
buffer
=
MakeUnique
<
ProfileChunkedBuffer
>
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
MakeUnique
<
ProfileBufferChunkManagerSingle
>
(
ProfileBufferChunkManager
:
:
scExpectedMaximumStackSize
)
)
;
if
(
!
profiler_capture_backtrace_into
(
*
buffer
StackCaptureOptions
:
:
Full
)
)
{
return
nullptr
;
}
return
buffer
;
}
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
{
UniquePtr
<
ProfileChunkedBuffer
>
buffer
=
profiler_capture_backtrace
(
)
;
if
(
!
buffer
)
{
return
nullptr
;
}
return
UniqueProfilerBacktrace
(
new
ProfilerBacktrace
(
"
SyncProfile
"
std
:
:
move
(
buffer
)
)
)
;
}
void
ProfilerBacktraceDestructor
:
:
operator
(
)
(
ProfilerBacktrace
*
aBacktrace
)
{
delete
aBacktrace
;
}
bool
profiler_is_locked_on_current_thread
(
)
{
return
PSAutoLock
:
:
IsLockedOnCurrentThread
(
)
|
|
CorePS
:
:
CoreBuffer
(
)
.
IsThreadSafeAndLockedOnCurrentThread
(
)
|
|
ProfilerParent
:
:
IsLockedOnCurrentThread
(
)
|
|
ProfilerChild
:
:
IsLockedOnCurrentThread
(
)
;
}
void
profiler_set_js_context
(
JSContext
*
aCx
)
{
MOZ_ASSERT
(
aCx
)
;
PSAutoLock
lock
;
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
!
registeredThread
)
{
return
;
}
registeredThread
-
>
SetJSContext
(
aCx
)
;
registeredThread
-
>
PollJSSampling
(
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ProfiledThreadData
*
profiledThreadData
=
ActivePS
:
:
GetProfiledThreadData
(
lock
registeredThread
)
;
if
(
profiledThreadData
)
{
profiledThreadData
-
>
NotifyReceivedJSContext
(
ActivePS
:
:
Buffer
(
lock
)
.
BufferRangeEnd
(
)
)
;
}
}
}
void
profiler_clear_js_context
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
!
registeredThread
)
{
return
;
}
JSContext
*
cx
=
registeredThread
-
>
GetJSContext
(
)
;
if
(
!
cx
)
{
return
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
&
&
ActivePS
:
:
FeatureJS
(
lock
)
)
{
ProfiledThreadData
*
profiledThreadData
=
ActivePS
:
:
GetProfiledThreadData
(
lock
registeredThread
)
;
if
(
profiledThreadData
)
{
profiledThreadData
-
>
NotifyAboutToLoseJSContext
(
cx
CorePS
:
:
ProcessStartTime
(
)
ActivePS
:
:
Buffer
(
lock
)
)
;
registeredThread
-
>
StopJSSampling
(
)
;
registeredThread
-
>
PollJSSampling
(
)
;
registeredThread
-
>
ClearJSContext
(
)
;
registeredThread
-
>
StartJSSampling
(
ActivePS
:
:
JSFlags
(
lock
)
)
;
return
;
}
}
registeredThread
-
>
ClearJSContext
(
)
;
}
static
void
profiler_suspend_and_sample_thread
(
PSLockRef
aLock
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
bool
aIsSynchronous
uint32_t
aFeatures
ProfilerStackCollector
&
aCollector
bool
aSampleNative
)
{
const
ThreadRegistrationInfo
&
info
=
aThreadData
.
Info
(
)
;
if
(
info
.
IsMainThread
(
)
)
{
aCollector
.
SetIsMainThread
(
)
;
}
NativeStack
nativeStack
;
auto
collectStack
=
[
&
]
(
const
Registers
&
aRegs
const
TimeStamp
&
aNow
)
{
JsFrameBuffer
&
jsFrames
=
CorePS
:
:
JsFrames
(
aLock
)
;
StackWalkControl
*
stackWalkControlIfSupported
=
nullptr
;
#
if
defined
(
HAVE_FASTINIT_NATIVE_UNWIND
)
StackWalkControl
stackWalkControl
;
if
constexpr
(
StackWalkControl
:
:
scIsSupported
)
{
if
(
aSampleNative
)
{
stackWalkControlIfSupported
=
&
stackWalkControl
;
}
}
#
endif
const
uint32_t
jsFramesCount
=
ExtractJsFrames
(
aIsSynchronous
aThreadData
aRegs
aCollector
jsFrames
stackWalkControlIfSupported
)
;
#
if
defined
(
HAVE_FASTINIT_NATIVE_UNWIND
)
if
(
aSampleNative
)
{
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
DoFramePointerBacktrace
(
aLock
aThreadData
aRegs
nativeStack
stackWalkControlIfSupported
)
;
#
elif
defined
(
USE_MOZ_STACK_WALK
)
DoMozStackWalkBacktrace
(
aLock
aThreadData
aRegs
nativeStack
stackWalkControlIfSupported
)
;
#
else
#
error
"
Invalid
configuration
"
#
endif
MergeStacks
(
aFeatures
aIsSynchronous
aThreadData
aRegs
nativeStack
aCollector
jsFrames
jsFramesCount
)
;
}
else
#
endif
{
MergeStacks
(
aFeatures
aIsSynchronous
aThreadData
aRegs
nativeStack
aCollector
jsFrames
jsFramesCount
)
;
if
(
ProfilerFeature
:
:
HasLeaf
(
aFeatures
)
)
{
aCollector
.
CollectNativeLeafAddr
(
(
void
*
)
aRegs
.
mPC
)
;
}
}
}
;
if
(
aIsSynchronous
)
{
Registers
regs
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
regs
.
SyncPopulate
(
)
;
#
else
regs
.
Clear
(
)
;
#
endif
collectStack
(
regs
TimeStamp
:
:
Now
(
)
)
;
}
else
{
Sampler
sampler
(
aLock
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
sampler
.
SuspendAndSampleAndResumeThread
(
aLock
aThreadData
now
collectStack
)
;
sampler
.
Disable
(
aLock
)
;
}
}
void
profiler_suspend_and_sample_thread
(
ProfilerThreadId
aThreadId
uint32_t
aFeatures
ProfilerStackCollector
&
aCollector
bool
aSampleNative
)
{
if
(
!
aThreadId
.
IsSpecified
(
)
|
|
aThreadId
=
=
profiler_current_thread_id
(
)
)
{
ThreadRegistration
:
:
WithOnThreadRef
(
[
&
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
aOnThreadRef
.
WithUnlockedReaderAndAtomicRWOnThread
(
[
&
]
(
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
)
{
PSAutoLock
lock
;
profiler_suspend_and_sample_thread
(
lock
aThreadData
true
aFeatures
aCollector
aSampleNative
)
;
}
)
;
}
)
;
}
else
{
PSAutoLock
lock
;
ThreadRegistry
:
:
WithOffThreadRef
(
aThreadId
[
&
]
(
ThreadRegistry
:
:
OffThreadRef
aOffThreadRef
)
{
aOffThreadRef
.
WithLockedRWFromAnyThread
(
[
&
]
(
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
)
{
profiler_suspend_and_sample_thread
(
lock
aThreadData
false
aFeatures
aCollector
aSampleNative
)
;
}
)
;
}
)
;
}
}
