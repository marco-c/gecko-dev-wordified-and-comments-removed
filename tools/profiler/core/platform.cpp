#
include
<
algorithm
>
#
include
<
ostream
>
#
include
<
fstream
>
#
include
<
sstream
>
#
include
<
errno
.
h
>
#
include
"
platform
.
h
"
#
include
"
PlatformMacros
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
ProfilerIOInterposeObserver
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
PseudoStack
.
h
"
#
include
"
ThreadInfo
.
h
"
#
include
"
nsIHttpProtocolHandler
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIProfileSaveEvent
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsProfilerStartParams
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
ProfileGatherer
.
h
"
#
include
"
ProfilerMarkers
.
h
"
#
include
"
shared
-
libraries
.
h
"
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
#
endif
#
if
defined
(
PROFILE_JAVA
)
#
include
"
FennecJNINatives
.
h
"
#
include
"
FennecJNIWrappers
.
h
"
#
endif
#
if
defined
(
MOZ_PROFILING
)
&
&
\
(
defined
(
GP_OS_windows
)
|
|
defined
(
GP_OS_darwin
)
)
#
define
USE_NS_STACKWALK
#
endif
#
if
defined
(
GP_arm_android
)
#
define
USE_EHABI_STACKWALK
#
include
"
EHABIStackWalk
.
h
"
#
endif
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_x86_linux
)
#
define
USE_LUL_STACKWALK
#
include
"
lul
/
LulMain
.
h
"
#
include
"
lul
/
platform
-
linux
-
lul
.
h
"
#
endif
#
ifdef
MOZ_VALGRIND
#
include
<
valgrind
/
memcheck
.
h
>
#
else
#
define
VALGRIND_MAKE_MEM_DEFINED
(
_addr
_len
)
(
(
void
)
0
)
#
endif
#
if
defined
(
GP_OS_windows
)
typedef
CONTEXT
tickcontext_t
;
#
elif
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
#
include
<
ucontext
.
h
>
typedef
ucontext_t
tickcontext_t
;
#
endif
using
namespace
mozilla
;
#
if
defined
(
PROFILE_JAVA
)
class
GeckoJavaSampler
:
public
mozilla
:
:
java
:
:
GeckoJavaSampler
:
:
Natives
<
GeckoJavaSampler
>
{
private
:
GeckoJavaSampler
(
)
;
public
:
static
double
GetProfilerTime
(
)
{
if
(
!
profiler_is_active
(
)
)
{
return
0
.
0
;
}
return
profiler_time
(
)
;
}
;
}
;
#
endif
class
SamplerThread
;
MOZ_THREAD_LOCAL
(
PseudoStack
*
)
tlsPseudoStack
;
class
ProfilerState
{
public
:
typedef
ProfilerStateMutex
Mutex
;
typedef
mozilla
:
:
BaseAutoLock
<
Mutex
>
AutoLock
;
typedef
const
AutoLock
&
LockRef
;
typedef
std
:
:
vector
<
ThreadInfo
*
>
ThreadVector
;
ProfilerState
(
)
:
mEnvVarEntries
(
0
)
mEntries
(
0
)
mEnvVarInterval
(
0
)
mInterval
(
0
)
mFeatureDisplayListDump
(
false
)
mFeatureGPU
(
false
)
mFeatureJava
(
false
)
mFeatureJS
(
false
)
mFeatureLayersDump
(
false
)
mFeatureLeaf
(
false
)
mFeatureMemory
(
false
)
mFeaturePrivacy
(
false
)
mFeatureRestyle
(
false
)
mFeatureStackWalk
(
false
)
mFeatureTaskTracer
(
false
)
mFeatureThreads
(
false
)
mBuffer
(
nullptr
)
mGatherer
(
nullptr
)
mIsPaused
(
false
)
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
mWasPaused
(
false
)
#
endif
mSamplerThread
(
nullptr
)
#
ifdef
USE_LUL_STACKWALK
mLUL
(
nullptr
)
#
endif
mInterposeObserver
(
nullptr
)
mFrameNumber
(
0
)
mLatestRecordedFrameNumber
(
0
)
{
}
#
define
GET_AND_SET
(
type_
name_
)
\
type_
name_
(
LockRef
)
const
{
return
m
#
#
name_
;
}
\
void
Set
#
#
name_
(
LockRef
type_
a
#
#
name_
)
{
m
#
#
name_
=
a
#
#
name_
;
}
GET_AND_SET
(
TimeStamp
StartTime
)
GET_AND_SET
(
int
EnvVarEntries
)
GET_AND_SET
(
int
Entries
)
GET_AND_SET
(
int
EnvVarInterval
)
GET_AND_SET
(
double
Interval
)
Vector
<
std
:
:
string
>
&
Features
(
LockRef
)
{
return
mFeatures
;
}
Vector
<
std
:
:
string
>
&
ThreadNameFilters
(
LockRef
)
{
return
mThreadNameFilters
;
}
GET_AND_SET
(
bool
FeatureDisplayListDump
)
GET_AND_SET
(
bool
FeatureGPU
)
GET_AND_SET
(
bool
FeatureJava
)
GET_AND_SET
(
bool
FeatureJS
)
GET_AND_SET
(
bool
FeatureLayersDump
)
GET_AND_SET
(
bool
FeatureLeaf
)
GET_AND_SET
(
bool
FeatureMemory
)
GET_AND_SET
(
bool
FeaturePrivacy
)
GET_AND_SET
(
bool
FeatureRestyle
)
GET_AND_SET
(
bool
FeatureStackWalk
)
GET_AND_SET
(
bool
FeatureTaskTracer
)
GET_AND_SET
(
bool
FeatureThreads
)
GET_AND_SET
(
ProfileBuffer
*
Buffer
)
GET_AND_SET
(
ProfileGatherer
*
Gatherer
)
ThreadVector
&
Threads
(
LockRef
)
{
return
mThreads
;
}
static
bool
IsActive
(
LockRef
)
{
return
sActivityGeneration
>
0
;
}
static
uint32_t
ActivityGeneration
(
LockRef
)
{
return
sActivityGeneration
;
}
static
void
SetInactive
(
LockRef
)
{
sActivityGeneration
=
0
;
}
static
void
SetActive
(
LockRef
)
{
sActivityGeneration
=
sNextActivityGeneration
;
sNextActivityGeneration
=
(
sNextActivityGeneration
=
=
0xffffffff
)
?
1
:
sNextActivityGeneration
+
1
;
}
GET_AND_SET
(
bool
IsPaused
)
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
GET_AND_SET
(
bool
WasPaused
)
#
endif
GET_AND_SET
(
class
SamplerThread
*
SamplerThread
)
#
ifdef
USE_LUL_STACKWALK
GET_AND_SET
(
lul
:
:
LUL
*
LUL
)
#
endif
GET_AND_SET
(
mozilla
:
:
ProfilerIOInterposeObserver
*
InterposeObserver
)
GET_AND_SET
(
int
FrameNumber
)
GET_AND_SET
(
int
LatestRecordedFrameNumber
)
#
undef
GET_AND_SET
private
:
mozilla
:
:
TimeStamp
mStartTime
;
int
mEnvVarEntries
;
int
mEntries
;
int
mEnvVarInterval
;
double
mInterval
;
Vector
<
std
:
:
string
>
mFeatures
;
Vector
<
std
:
:
string
>
mThreadNameFilters
;
bool
mFeatureDisplayListDump
;
bool
mFeatureGPU
;
bool
mFeatureJava
;
bool
mFeatureJS
;
bool
mFeatureLayersDump
;
bool
mFeatureLeaf
;
bool
mFeatureMemory
;
bool
mFeaturePrivacy
;
bool
mFeatureRestyle
;
bool
mFeatureStackWalk
;
bool
mFeatureTaskTracer
;
bool
mFeatureThreads
;
ProfileBuffer
*
mBuffer
;
RefPtr
<
mozilla
:
:
ProfileGatherer
>
mGatherer
;
ThreadVector
mThreads
;
static
uint32_t
sActivityGeneration
;
static
uint32_t
sNextActivityGeneration
;
bool
mIsPaused
;
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
bool
mWasPaused
;
#
endif
class
SamplerThread
*
mSamplerThread
;
#
ifdef
USE_LUL_STACKWALK
lul
:
:
LUL
*
mLUL
;
#
endif
mozilla
:
:
ProfilerIOInterposeObserver
*
mInterposeObserver
;
int
mFrameNumber
;
int
mLatestRecordedFrameNumber
;
}
;
typedef
ProfilerState
PS
;
uint32_t
PS
:
:
sActivityGeneration
=
0
;
uint32_t
PS
:
:
sNextActivityGeneration
=
1
;
PS
*
gPS
=
nullptr
;
static
PS
:
:
Mutex
gPSMutex
;
static
const
char
*
const
kGeckoThreadName
=
"
GeckoMain
"
;
static
bool
CanNotifyObservers
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
#
if
defined
(
GP_OS_android
)
return
NS_IsMainThread
(
)
;
#
else
return
true
;
#
endif
}
class
TickSample
{
public
:
TickSample
(
)
:
pc
(
NULL
)
sp
(
NULL
)
fp
(
NULL
)
lr
(
NULL
)
context
(
NULL
)
isSamplingCurrentThread
(
false
)
threadInfo
(
nullptr
)
rssMemory
(
0
)
ussMemory
(
0
)
{
}
void
PopulateContext
(
void
*
aContext
)
;
Address
pc
;
Address
sp
;
Address
fp
;
Address
lr
;
void
*
context
;
bool
isSamplingCurrentThread
;
ThreadInfo
*
threadInfo
;
mozilla
:
:
TimeStamp
timestamp
;
int64_t
rssMemory
;
int64_t
ussMemory
;
}
;
static
void
AddDynamicCodeLocationTag
(
ProfileBuffer
*
aBuffer
const
char
*
aStr
)
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
CodeLocation
(
"
"
)
)
;
size_t
strLen
=
strlen
(
aStr
)
+
1
;
for
(
size_t
j
=
0
;
j
<
strLen
;
)
{
char
text
[
sizeof
(
void
*
)
]
;
size_t
len
=
sizeof
(
void
*
)
/
sizeof
(
char
)
;
if
(
j
+
len
>
=
strLen
)
{
len
=
strLen
-
j
;
}
memcpy
(
text
&
aStr
[
j
]
len
)
;
j
+
=
sizeof
(
void
*
)
/
sizeof
(
char
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
EmbeddedString
(
*
(
(
void
*
*
)
(
&
text
[
0
]
)
)
)
)
;
}
}
static
void
AddPseudoEntry
(
ProfileBuffer
*
aBuffer
volatile
js
:
:
ProfileEntry
&
entry
PseudoStack
*
stack
void
*
lastpc
)
{
if
(
entry
.
hasFlag
(
js
:
:
ProfileEntry
:
:
BEGIN_PSEUDO_JS
)
)
{
return
;
}
int
lineno
=
-
1
;
const
char
*
sampleLabel
=
entry
.
label
(
)
;
if
(
entry
.
isCopyLabel
(
)
)
{
AddDynamicCodeLocationTag
(
aBuffer
sampleLabel
)
;
if
(
entry
.
isJs
(
)
)
{
JSScript
*
script
=
entry
.
script
(
)
;
if
(
script
)
{
if
(
!
entry
.
pc
(
)
)
{
MOZ_ASSERT
(
&
entry
=
=
&
stack
-
>
mStack
[
stack
-
>
stackSize
(
)
-
1
]
)
;
if
(
lastpc
)
{
jsbytecode
*
jspc
=
js
:
:
ProfilingGetPC
(
stack
-
>
mContext
script
lastpc
)
;
if
(
jspc
)
{
lineno
=
JS_PCToLineNumber
(
script
jspc
)
;
}
}
}
else
{
lineno
=
JS_PCToLineNumber
(
script
entry
.
pc
(
)
)
;
}
}
}
else
{
lineno
=
entry
.
line
(
)
;
}
}
else
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
CodeLocation
(
sampleLabel
)
)
;
if
(
entry
.
isCpp
(
)
)
{
lineno
=
entry
.
line
(
)
;
}
}
if
(
lineno
!
=
-
1
)
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
LineNumber
(
lineno
)
)
;
}
uint32_t
category
=
entry
.
category
(
)
;
MOZ_ASSERT
(
!
(
category
&
js
:
:
ProfileEntry
:
:
IS_CPP_ENTRY
)
)
;
MOZ_ASSERT
(
!
(
category
&
js
:
:
ProfileEntry
:
:
FRAME_LABEL_COPY
)
)
;
if
(
category
)
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Category
(
(
int
)
category
)
)
;
}
}
struct
NativeStack
{
void
*
*
pc_array
;
void
*
*
sp_array
;
size_t
size
;
size_t
count
;
}
;
mozilla
:
:
Atomic
<
bool
>
WALKING_JS_STACK
(
false
)
;
struct
AutoWalkJSStack
{
bool
walkAllowed
;
AutoWalkJSStack
(
)
:
walkAllowed
(
false
)
{
walkAllowed
=
WALKING_JS_STACK
.
compareExchange
(
false
true
)
;
}
~
AutoWalkJSStack
(
)
{
if
(
walkAllowed
)
{
WALKING_JS_STACK
=
false
;
}
}
}
;
static
void
MergeStacksIntoProfile
(
ProfileBuffer
*
aBuffer
TickSample
*
aSample
NativeStack
&
aNativeStack
)
{
NotNull
<
PseudoStack
*
>
pseudoStack
=
aSample
-
>
threadInfo
-
>
Stack
(
)
;
volatile
js
:
:
ProfileEntry
*
pseudoFrames
=
pseudoStack
-
>
mStack
;
uint32_t
pseudoCount
=
pseudoStack
-
>
stackSize
(
)
;
uint32_t
startBufferGen
;
startBufferGen
=
aSample
-
>
isSamplingCurrentThread
?
UINT32_MAX
:
aBuffer
-
>
mGeneration
;
uint32_t
jsCount
=
0
;
JS
:
:
ProfilingFrameIterator
:
:
Frame
jsFrames
[
1000
]
;
if
(
pseudoStack
-
>
mContext
&
&
JS
:
:
IsProfilingEnabledForContext
(
pseudoStack
-
>
mContext
)
)
{
AutoWalkJSStack
autoWalkJSStack
;
const
uint32_t
maxFrames
=
mozilla
:
:
ArrayLength
(
jsFrames
)
;
if
(
aSample
&
&
autoWalkJSStack
.
walkAllowed
)
{
JS
:
:
ProfilingFrameIterator
:
:
RegisterState
registerState
;
registerState
.
pc
=
aSample
-
>
pc
;
registerState
.
sp
=
aSample
-
>
sp
;
registerState
.
lr
=
aSample
-
>
lr
;
JS
:
:
ProfilingFrameIterator
jsIter
(
pseudoStack
-
>
mContext
registerState
startBufferGen
)
;
for
(
;
jsCount
<
maxFrames
&
&
!
jsIter
.
done
(
)
;
+
+
jsIter
)
{
if
(
aSample
-
>
isSamplingCurrentThread
|
|
jsIter
.
isWasm
(
)
)
{
uint32_t
extracted
=
jsIter
.
extractStack
(
jsFrames
jsCount
maxFrames
)
;
jsCount
+
=
extracted
;
if
(
jsCount
=
=
maxFrames
)
{
break
;
}
}
else
{
mozilla
:
:
Maybe
<
JS
:
:
ProfilingFrameIterator
:
:
Frame
>
frame
=
jsIter
.
getPhysicalFrameWithoutLabel
(
)
;
if
(
frame
.
isSome
(
)
)
{
jsFrames
[
jsCount
+
+
]
=
frame
.
value
(
)
;
}
}
}
}
}
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Sample
(
"
(
root
)
"
)
)
;
uint32_t
pseudoIndex
=
0
;
int32_t
jsIndex
=
jsCount
-
1
;
int32_t
nativeIndex
=
aNativeStack
.
count
-
1
;
uint8_t
*
lastPseudoCppStackAddr
=
nullptr
;
while
(
pseudoIndex
!
=
pseudoCount
|
|
jsIndex
>
=
0
|
|
nativeIndex
>
=
0
)
{
uint8_t
*
pseudoStackAddr
=
nullptr
;
uint8_t
*
jsStackAddr
=
nullptr
;
uint8_t
*
nativeStackAddr
=
nullptr
;
if
(
pseudoIndex
!
=
pseudoCount
)
{
volatile
js
:
:
ProfileEntry
&
pseudoFrame
=
pseudoFrames
[
pseudoIndex
]
;
if
(
pseudoFrame
.
isCpp
(
)
)
{
lastPseudoCppStackAddr
=
(
uint8_t
*
)
pseudoFrame
.
stackAddress
(
)
;
}
if
(
pseudoFrame
.
isJs
(
)
&
&
pseudoFrame
.
isOSR
(
)
)
{
pseudoIndex
+
+
;
continue
;
}
MOZ_ASSERT
(
lastPseudoCppStackAddr
)
;
pseudoStackAddr
=
lastPseudoCppStackAddr
;
}
if
(
jsIndex
>
=
0
)
{
jsStackAddr
=
(
uint8_t
*
)
jsFrames
[
jsIndex
]
.
stackAddress
;
}
if
(
nativeIndex
>
=
0
)
{
nativeStackAddr
=
(
uint8_t
*
)
aNativeStack
.
sp_array
[
nativeIndex
]
;
}
if
(
nativeStackAddr
&
&
(
pseudoStackAddr
=
=
nativeStackAddr
|
|
jsStackAddr
=
=
nativeStackAddr
)
)
{
nativeStackAddr
=
nullptr
;
nativeIndex
-
-
;
MOZ_ASSERT
(
pseudoStackAddr
|
|
jsStackAddr
)
;
}
MOZ_ASSERT_IF
(
pseudoStackAddr
pseudoStackAddr
!
=
jsStackAddr
&
&
pseudoStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
jsStackAddr
jsStackAddr
!
=
pseudoStackAddr
&
&
jsStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
nativeStackAddr
nativeStackAddr
!
=
pseudoStackAddr
&
&
nativeStackAddr
!
=
jsStackAddr
)
;
if
(
pseudoStackAddr
>
jsStackAddr
&
&
pseudoStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
pseudoIndex
<
pseudoCount
)
;
volatile
js
:
:
ProfileEntry
&
pseudoFrame
=
pseudoFrames
[
pseudoIndex
]
;
AddPseudoEntry
(
aBuffer
pseudoFrame
pseudoStack
nullptr
)
;
pseudoIndex
+
+
;
continue
;
}
if
(
jsStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
jsIndex
>
=
0
)
;
const
JS
:
:
ProfilingFrameIterator
:
:
Frame
&
jsFrame
=
jsFrames
[
jsIndex
]
;
if
(
aSample
-
>
isSamplingCurrentThread
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Wasm
)
{
AddDynamicCodeLocationTag
(
aBuffer
jsFrame
.
label
)
;
}
else
{
MOZ_ASSERT
(
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Ion
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Baseline
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
JitReturnAddr
(
jsFrames
[
jsIndex
]
.
returnAddress
)
)
;
}
jsIndex
-
-
;
continue
;
}
if
(
nativeStackAddr
)
{
MOZ_ASSERT
(
nativeIndex
>
=
0
)
;
void
*
addr
=
(
void
*
)
aNativeStack
.
pc_array
[
nativeIndex
]
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
NativeLeafAddr
(
addr
)
)
;
}
if
(
nativeIndex
>
=
0
)
{
nativeIndex
-
-
;
}
}
if
(
!
aSample
-
>
isSamplingCurrentThread
&
&
pseudoStack
-
>
mContext
)
{
MOZ_ASSERT
(
aBuffer
-
>
mGeneration
>
=
startBufferGen
)
;
uint32_t
lapCount
=
aBuffer
-
>
mGeneration
-
startBufferGen
;
JS
:
:
UpdateJSContextProfilerSampleBufferGen
(
pseudoStack
-
>
mContext
aBuffer
-
>
mGeneration
lapCount
)
;
}
}
#
if
defined
(
GP_OS_windows
)
static
uintptr_t
GetThreadHandle
(
PlatformData
*
aData
)
;
#
endif
#
ifdef
USE_NS_STACKWALK
static
void
StackWalkCallback
(
uint32_t
aFrameNumber
void
*
aPC
void
*
aSP
void
*
aClosure
)
{
NativeStack
*
nativeStack
=
static_cast
<
NativeStack
*
>
(
aClosure
)
;
MOZ_ASSERT
(
nativeStack
-
>
count
<
nativeStack
-
>
size
)
;
nativeStack
-
>
sp_array
[
nativeStack
-
>
count
]
=
aSP
;
nativeStack
-
>
pc_array
[
nativeStack
-
>
count
]
=
aPC
;
nativeStack
-
>
count
+
+
;
}
static
void
DoNativeBacktrace
(
PS
:
:
LockRef
aLock
ProfileBuffer
*
aBuffer
TickSample
*
aSample
)
{
void
*
pc_array
[
1000
]
;
void
*
sp_array
[
1000
]
;
NativeStack
nativeStack
=
{
pc_array
sp_array
mozilla
:
:
ArrayLength
(
pc_array
)
0
}
;
StackWalkCallback
(
0
aSample
-
>
pc
aSample
-
>
sp
&
nativeStack
)
;
uint32_t
maxFrames
=
uint32_t
(
nativeStack
.
size
-
nativeStack
.
count
)
;
#
if
defined
(
GP_OS_darwin
)
|
|
(
defined
(
GP_PLAT_x86_windows
)
)
void
*
stackEnd
=
aSample
-
>
threadInfo
-
>
StackTop
(
)
;
if
(
aSample
-
>
fp
>
=
aSample
-
>
sp
&
&
aSample
-
>
fp
<
=
stackEnd
)
{
FramePointerStackWalk
(
StackWalkCallback
0
maxFrames
&
nativeStack
reinterpret_cast
<
void
*
*
>
(
aSample
-
>
fp
)
stackEnd
)
;
}
#
else
uintptr_t
thread
=
GetThreadHandle
(
aSample
-
>
threadInfo
-
>
GetPlatformData
(
)
)
;
MOZ_ASSERT
(
thread
)
;
MozStackWalk
(
StackWalkCallback
0
maxFrames
&
nativeStack
thread
nullptr
)
;
#
endif
MergeStacksIntoProfile
(
aBuffer
aSample
nativeStack
)
;
}
#
endif
#
ifdef
USE_EHABI_STACKWALK
static
void
DoNativeBacktrace
(
PS
:
:
LockRef
aLock
ProfileBuffer
*
aBuffer
TickSample
*
aSample
)
{
void
*
pc_array
[
1000
]
;
void
*
sp_array
[
1000
]
;
NativeStack
nativeStack
=
{
pc_array
sp_array
mozilla
:
:
ArrayLength
(
pc_array
)
0
}
;
const
mcontext_t
*
mcontext
=
&
reinterpret_cast
<
ucontext_t
*
>
(
aSample
-
>
context
)
-
>
uc_mcontext
;
mcontext_t
savedContext
;
NotNull
<
PseudoStack
*
>
pseudoStack
=
aInfo
.
Stack
(
)
;
nativeStack
.
count
=
0
;
for
(
uint32_t
i
=
pseudoStack
-
>
stackSize
(
)
;
i
>
0
;
-
-
i
)
{
volatile
js
:
:
ProfileEntry
&
entry
=
pseudoStack
-
>
mStack
[
i
-
1
]
;
if
(
!
entry
.
isJs
(
)
&
&
strcmp
(
entry
.
label
(
)
"
EnterJIT
"
)
=
=
0
)
{
uint32_t
*
vSP
=
reinterpret_cast
<
uint32_t
*
>
(
entry
.
stackAddress
(
)
)
;
nativeStack
.
count
+
=
EHABIStackWalk
(
*
mcontext
vSP
sp_array
+
nativeStack
.
count
pc_array
+
nativeStack
.
count
nativeStack
.
size
-
nativeStack
.
count
)
;
memset
(
&
savedContext
0
sizeof
(
savedContext
)
)
;
savedContext
.
arm_r4
=
*
vSP
+
+
;
savedContext
.
arm_r5
=
*
vSP
+
+
;
savedContext
.
arm_r6
=
*
vSP
+
+
;
savedContext
.
arm_r7
=
*
vSP
+
+
;
savedContext
.
arm_r8
=
*
vSP
+
+
;
savedContext
.
arm_r9
=
*
vSP
+
+
;
savedContext
.
arm_r10
=
*
vSP
+
+
;
savedContext
.
arm_fp
=
*
vSP
+
+
;
savedContext
.
arm_lr
=
*
vSP
+
+
;
savedContext
.
arm_sp
=
reinterpret_cast
<
uint32_t
>
(
vSP
)
;
savedContext
.
arm_pc
=
savedContext
.
arm_lr
;
mcontext
=
&
savedContext
;
}
}
nativeStack
.
count
+
=
EHABIStackWalk
(
*
mcontext
aInfo
.
StackTop
(
)
sp_array
+
nativeStack
.
count
pc_array
+
nativeStack
.
count
nativeStack
.
size
-
nativeStack
.
count
)
;
MergeStacksIntoProfile
(
aInfo
aSample
nativeStack
)
;
}
#
endif
#
ifdef
USE_LUL_STACKWALK
static
void
DoNativeBacktrace
(
PS
:
:
LockRef
aLock
ProfileBuffer
*
aBuffer
TickSample
*
aSample
)
{
const
mcontext_t
*
mc
=
&
reinterpret_cast
<
ucontext_t
*
>
(
aSample
-
>
context
)
-
>
uc_mcontext
;
lul
:
:
UnwindRegs
startRegs
;
memset
(
&
startRegs
0
sizeof
(
startRegs
)
)
;
#
if
defined
(
GP_PLAT_amd64_linux
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RSP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RBP
]
)
;
#
elif
defined
(
GP_PLAT_arm_android
)
startRegs
.
r15
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_pc
)
;
startRegs
.
r14
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_lr
)
;
startRegs
.
r13
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_sp
)
;
startRegs
.
r12
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_ip
)
;
startRegs
.
r11
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_fp
)
;
startRegs
.
r7
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_r7
)
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_ESP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EBP
]
)
;
#
else
#
error
"
Unknown
plat
"
#
endif
lul
:
:
StackImage
stackImg
;
{
#
if
defined
(
GP_PLAT_amd64_linux
)
uintptr_t
rEDZONE_SIZE
=
128
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_arm_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
r13
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
else
#
error
"
Unknown
plat
"
#
endif
uintptr_t
end
=
reinterpret_cast
<
uintptr_t
>
(
aSample
-
>
threadInfo
-
>
StackTop
(
)
)
;
uintptr_t
ws
=
sizeof
(
void
*
)
;
start
&
=
~
(
ws
-
1
)
;
end
&
=
~
(
ws
-
1
)
;
uintptr_t
nToCopy
=
0
;
if
(
start
<
end
)
{
nToCopy
=
end
-
start
;
if
(
nToCopy
>
lul
:
:
N_STACK_BYTES
)
nToCopy
=
lul
:
:
N_STACK_BYTES
;
}
MOZ_ASSERT
(
nToCopy
<
=
lul
:
:
N_STACK_BYTES
)
;
stackImg
.
mLen
=
nToCopy
;
stackImg
.
mStartAvma
=
start
;
if
(
nToCopy
>
0
)
{
memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
(
void
)
VALGRIND_MAKE_MEM_DEFINED
(
&
stackImg
.
mContents
[
0
]
nToCopy
)
;
}
}
const
int
MAX_NATIVE_FRAMES
=
256
;
size_t
scannedFramesAllowed
=
0
;
uintptr_t
framePCs
[
MAX_NATIVE_FRAMES
]
;
uintptr_t
frameSPs
[
MAX_NATIVE_FRAMES
]
;
size_t
framesAvail
=
mozilla
:
:
ArrayLength
(
framePCs
)
;
size_t
framesUsed
=
0
;
size_t
scannedFramesAcquired
=
0
;
lul
:
:
LUL
*
lul
=
gPS
-
>
LUL
(
aLock
)
;
lul
-
>
Unwind
(
&
framePCs
[
0
]
&
frameSPs
[
0
]
&
framesUsed
&
scannedFramesAcquired
framesAvail
scannedFramesAllowed
&
startRegs
&
stackImg
)
;
NativeStack
nativeStack
=
{
reinterpret_cast
<
void
*
*
>
(
framePCs
)
reinterpret_cast
<
void
*
*
>
(
frameSPs
)
mozilla
:
:
ArrayLength
(
framePCs
)
0
}
;
nativeStack
.
count
=
framesUsed
;
MergeStacksIntoProfile
(
aBuffer
aSample
nativeStack
)
;
lul
-
>
mStats
.
mContext
+
=
1
;
lul
-
>
mStats
.
mCFI
+
=
framesUsed
-
1
-
scannedFramesAcquired
;
lul
-
>
mStats
.
mScanned
+
=
scannedFramesAcquired
;
}
#
endif
static
void
DoSampleStackTrace
(
PS
:
:
LockRef
aLock
ProfileBuffer
*
aBuffer
TickSample
*
aSample
)
{
NativeStack
nativeStack
=
{
nullptr
nullptr
0
0
}
;
MergeStacksIntoProfile
(
aBuffer
aSample
nativeStack
)
;
if
(
aSample
&
&
gPS
-
>
FeatureLeaf
(
aLock
)
)
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
NativeLeafAddr
(
(
void
*
)
aSample
-
>
pc
)
)
;
}
}
static
void
Tick
(
PS
:
:
LockRef
aLock
ProfileBuffer
*
aBuffer
TickSample
*
aSample
)
{
ThreadInfo
&
threadInfo
=
*
aSample
-
>
threadInfo
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
ThreadId
(
threadInfo
.
ThreadId
(
)
)
)
;
mozilla
:
:
TimeDuration
delta
=
aSample
-
>
timestamp
-
gPS
-
>
StartTime
(
aLock
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Time
(
delta
.
ToMilliseconds
(
)
)
)
;
NotNull
<
PseudoStack
*
>
stack
=
threadInfo
.
Stack
(
)
;
#
if
defined
(
USE_NS_STACKWALK
)
|
|
defined
(
USE_EHABI_STACKWALK
)
|
|
\
defined
(
USE_LUL_STACKWALK
)
if
(
gPS
-
>
FeatureStackWalk
(
aLock
)
)
{
DoNativeBacktrace
(
aLock
aBuffer
aSample
)
;
}
else
{
DoSampleStackTrace
(
aLock
aBuffer
aSample
)
;
}
#
else
DoSampleStackTrace
(
aLock
aBuffer
aSample
)
;
#
endif
if
(
!
aSample
-
>
isSamplingCurrentThread
)
{
ProfilerMarkerLinkedList
*
pendingMarkersList
=
stack
-
>
getPendingMarkers
(
)
;
while
(
pendingMarkersList
&
&
pendingMarkersList
-
>
peek
(
)
)
{
ProfilerMarker
*
marker
=
pendingMarkersList
-
>
popHead
(
)
;
aBuffer
-
>
addStoredMarker
(
marker
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Marker
(
marker
)
)
;
}
}
if
(
threadInfo
.
GetThreadResponsiveness
(
)
-
>
HasData
(
)
)
{
mozilla
:
:
TimeDuration
delta
=
threadInfo
.
GetThreadResponsiveness
(
)
-
>
GetUnresponsiveDuration
(
aSample
-
>
timestamp
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Responsiveness
(
delta
.
ToMilliseconds
(
)
)
)
;
}
if
(
aSample
-
>
rssMemory
!
=
0
)
{
double
rssMemory
=
static_cast
<
double
>
(
aSample
-
>
rssMemory
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
ResidentMemory
(
rssMemory
)
)
;
}
if
(
aSample
-
>
ussMemory
!
=
0
)
{
double
ussMemory
=
static_cast
<
double
>
(
aSample
-
>
ussMemory
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
UnsharedMemory
(
ussMemory
)
)
;
}
int
frameNumber
=
gPS
-
>
FrameNumber
(
aLock
)
;
if
(
frameNumber
!
=
gPS
-
>
LatestRecordedFrameNumber
(
aLock
)
)
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
FrameNumber
(
frameNumber
)
)
;
gPS
-
>
SetLatestRecordedFrameNumber
(
aLock
frameNumber
)
;
}
}
class
ProfileSaveEvent
final
:
public
nsIProfileSaveEvent
{
public
:
typedef
void
(
*
AddSubProfileFunc
)
(
const
char
*
aProfile
void
*
aClosure
)
;
NS_DECL_ISUPPORTS
ProfileSaveEvent
(
AddSubProfileFunc
aFunc
void
*
aClosure
)
:
mFunc
(
aFunc
)
mClosure
(
aClosure
)
{
}
NS_IMETHOD
AddSubProfile
(
const
char
*
aProfile
)
override
{
mFunc
(
aProfile
mClosure
)
;
return
NS_OK
;
}
private
:
~
ProfileSaveEvent
(
)
{
}
AddSubProfileFunc
mFunc
;
void
*
mClosure
;
}
;
NS_IMPL_ISUPPORTS
(
ProfileSaveEvent
nsIProfileSaveEvent
)
static
void
AddSharedLibraryInfoToStream
(
std
:
:
ostream
&
aStream
const
SharedLibrary
&
aLib
)
{
aStream
<
<
"
{
"
;
aStream
<
<
"
\
"
start
\
"
:
"
<
<
aLib
.
GetStart
(
)
;
aStream
<
<
"
\
"
end
\
"
:
"
<
<
aLib
.
GetEnd
(
)
;
aStream
<
<
"
\
"
offset
\
"
:
"
<
<
aLib
.
GetOffset
(
)
;
aStream
<
<
"
\
"
name
\
"
:
\
"
"
<
<
aLib
.
GetNativeDebugName
(
)
<
<
"
\
"
"
;
const
std
:
:
string
&
breakpadId
=
aLib
.
GetBreakpadId
(
)
;
aStream
<
<
"
\
"
breakpadId
\
"
:
\
"
"
<
<
breakpadId
<
<
"
\
"
"
;
aStream
<
<
"
}
"
;
}
static
std
:
:
string
GetSharedLibraryInfoStringInternal
(
)
{
SharedLibraryInfo
info
=
SharedLibraryInfo
:
:
GetInfoForSelf
(
)
;
if
(
info
.
GetSize
(
)
=
=
0
)
{
return
"
[
]
"
;
}
std
:
:
ostringstream
os
;
os
<
<
"
[
"
;
AddSharedLibraryInfoToStream
(
os
info
.
GetEntry
(
0
)
)
;
for
(
size_t
i
=
1
;
i
<
info
.
GetSize
(
)
;
i
+
+
)
{
os
<
<
"
"
;
AddSharedLibraryInfoToStream
(
os
info
.
GetEntry
(
i
)
)
;
}
os
<
<
"
]
"
;
return
os
.
str
(
)
;
}
static
void
StreamTaskTracer
(
PS
:
:
LockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
#
ifdef
MOZ_TASK_TRACER
aWriter
.
StartArrayProperty
(
"
data
"
)
;
{
UniquePtr
<
nsTArray
<
nsCString
>
>
data
=
mozilla
:
:
tasktracer
:
:
GetLoggedData
(
gPS
-
>
StartTime
(
aLock
)
)
;
for
(
uint32_t
i
=
0
;
i
<
data
-
>
Length
(
)
;
+
+
i
)
{
aWriter
.
StringElement
(
(
data
-
>
ElementAt
(
i
)
)
.
get
(
)
)
;
}
}
aWriter
.
EndArray
(
)
;
aWriter
.
StartArrayProperty
(
"
threads
"
)
;
{
const
PS
:
:
ThreadVector
&
threads
=
gPS
-
>
Threads
(
aLock
)
;
for
(
size_t
i
=
0
;
i
<
threads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
threads
.
at
(
i
)
;
aWriter
.
StartObjectElement
(
)
;
{
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Plugin
)
{
aWriter
.
StringProperty
(
"
name
"
"
Plugin
"
)
;
}
else
{
aWriter
.
StringProperty
(
"
name
"
info
-
>
Name
(
)
)
;
}
aWriter
.
IntProperty
(
"
tid
"
static_cast
<
int
>
(
info
-
>
ThreadId
(
)
)
)
;
}
aWriter
.
EndObject
(
)
;
}
}
aWriter
.
EndArray
(
)
;
aWriter
.
DoubleProperty
(
"
start
"
static_cast
<
double
>
(
mozilla
:
:
tasktracer
:
:
GetStartTime
(
)
)
)
;
#
endif
}
static
void
StreamMetaJSCustomObject
(
PS
:
:
LockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
aWriter
.
IntProperty
(
"
version
"
3
)
;
aWriter
.
DoubleProperty
(
"
interval
"
gPS
-
>
Interval
(
aLock
)
)
;
aWriter
.
IntProperty
(
"
stackwalk
"
gPS
-
>
FeatureStackWalk
(
aLock
)
)
;
#
ifdef
DEBUG
aWriter
.
IntProperty
(
"
debug
"
1
)
;
#
else
aWriter
.
IntProperty
(
"
debug
"
0
)
;
#
endif
aWriter
.
IntProperty
(
"
gcpoison
"
JS
:
:
IsGCPoisoning
(
)
?
1
:
0
)
;
bool
asyncStacks
=
Preferences
:
:
GetBool
(
"
javascript
.
options
.
asyncstack
"
)
;
aWriter
.
IntProperty
(
"
asyncstack
"
asyncStacks
)
;
mozilla
:
:
TimeDuration
delta
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
-
gPS
-
>
StartTime
(
aLock
)
;
aWriter
.
DoubleProperty
(
"
startTime
"
static_cast
<
double
>
(
PR_Now
(
)
/
1000
.
0
-
delta
.
ToMilliseconds
(
)
)
)
;
aWriter
.
IntProperty
(
"
processType
"
XRE_GetProcessType
(
)
)
;
nsresult
res
;
nsCOMPtr
<
nsIHttpProtocolHandler
>
http
=
do_GetService
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
"
http
"
&
res
)
;
if
(
!
NS_FAILED
(
res
)
)
{
nsAutoCString
string
;
res
=
http
-
>
GetPlatform
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
platform
"
string
.
Data
(
)
)
;
}
res
=
http
-
>
GetOscpu
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
oscpu
"
string
.
Data
(
)
)
;
}
res
=
http
-
>
GetMisc
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
misc
"
string
.
Data
(
)
)
;
}
}
nsCOMPtr
<
nsIXULRuntime
>
runtime
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
runtime
)
{
nsAutoCString
string
;
res
=
runtime
-
>
GetXPCOMABI
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
abi
"
string
.
Data
(
)
)
;
res
=
runtime
-
>
GetWidgetToolkit
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
toolkit
"
string
.
Data
(
)
)
;
}
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
)
;
if
(
appInfo
)
{
nsAutoCString
string
;
res
=
appInfo
-
>
GetName
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
product
"
string
.
Data
(
)
)
;
}
}
struct
SubprocessClosure
{
explicit
SubprocessClosure
(
SpliceableJSONWriter
*
aWriter
)
:
mWriter
(
aWriter
)
{
}
SpliceableJSONWriter
*
mWriter
;
}
;
static
void
SubProcessCallback
(
const
char
*
aProfile
void
*
aClosure
)
{
SubprocessClosure
*
closure
=
(
SubprocessClosure
*
)
aClosure
;
closure
-
>
mWriter
-
>
StringElement
(
aProfile
)
;
}
#
if
defined
(
PROFILE_JAVA
)
static
void
BuildJavaThreadJSObject
(
SpliceableJSONWriter
&
aWriter
)
{
aWriter
.
StringProperty
(
"
name
"
"
Java
Main
Thread
"
)
;
aWriter
.
StartArrayProperty
(
"
samples
"
)
;
{
for
(
int
sampleId
=
0
;
true
;
sampleId
+
+
)
{
bool
firstRun
=
true
;
for
(
int
frameId
=
0
;
true
;
frameId
+
+
)
{
jni
:
:
String
:
:
LocalRef
frameName
=
java
:
:
GeckoJavaSampler
:
:
GetFrameName
(
0
sampleId
frameId
)
;
if
(
!
frameName
)
{
if
(
!
firstRun
)
{
aWriter
.
EndArray
(
)
;
aWriter
.
EndObject
(
)
;
}
break
;
}
if
(
firstRun
)
{
firstRun
=
false
;
double
sampleTime
=
java
:
:
GeckoJavaSampler
:
:
GetSampleTime
(
0
sampleId
)
;
aWriter
.
StartObjectElement
(
)
;
aWriter
.
DoubleProperty
(
"
time
"
sampleTime
)
;
aWriter
.
StartArrayProperty
(
"
frames
"
)
;
}
aWriter
.
StartObjectElement
(
)
;
{
aWriter
.
StringProperty
(
"
location
"
frameName
-
>
ToCString
(
)
.
BeginReading
(
)
)
;
}
aWriter
.
EndObject
(
)
;
}
if
(
firstRun
)
{
break
;
}
}
}
aWriter
.
EndArray
(
)
;
}
#
endif
static
void
StreamJSON
(
PS
:
:
LockRef
aLock
SpliceableJSONWriter
&
aWriter
double
aSinceTime
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
&
&
gPS
-
>
IsActive
(
aLock
)
)
;
aWriter
.
Start
(
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
{
aWriter
.
StringProperty
(
"
libs
"
GetSharedLibraryInfoStringInternal
(
)
.
c_str
(
)
)
;
aWriter
.
StartObjectProperty
(
"
meta
"
)
;
{
StreamMetaJSCustomObject
(
aLock
aWriter
)
;
}
aWriter
.
EndObject
(
)
;
if
(
gPS
-
>
FeatureTaskTracer
(
aLock
)
)
{
aWriter
.
StartObjectProperty
(
"
tasktracer
"
)
;
StreamTaskTracer
(
aLock
aWriter
)
;
aWriter
.
EndObject
(
)
;
}
aWriter
.
StartArrayProperty
(
"
threads
"
)
;
{
gPS
-
>
SetIsPaused
(
aLock
true
)
;
{
const
PS
:
:
ThreadVector
&
threads
=
gPS
-
>
Threads
(
aLock
)
;
for
(
size_t
i
=
0
;
i
<
threads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
threads
.
at
(
i
)
;
if
(
!
info
-
>
HasProfile
(
)
)
{
continue
;
}
info
-
>
StreamJSON
(
gPS
-
>
Buffer
(
aLock
)
aWriter
gPS
-
>
StartTime
(
aLock
)
aSinceTime
)
;
}
}
if
(
CanNotifyObservers
(
)
)
{
SubprocessClosure
closure
(
&
aWriter
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
RefPtr
<
ProfileSaveEvent
>
pse
=
new
ProfileSaveEvent
(
SubProcessCallback
&
closure
)
;
os
-
>
NotifyObservers
(
pse
"
profiler
-
subprocess
"
nullptr
)
;
}
}
#
if
defined
(
PROFILE_JAVA
)
if
(
gPS
-
>
FeatureJava
(
aLock
)
)
{
java
:
:
GeckoJavaSampler
:
:
Pause
(
)
;
aWriter
.
Start
(
)
;
{
BuildJavaThreadJSObject
(
aWriter
)
;
}
aWriter
.
End
(
)
;
java
:
:
GeckoJavaSampler
:
:
Unpause
(
)
;
}
#
endif
gPS
-
>
SetIsPaused
(
aLock
false
)
;
}
aWriter
.
EndArray
(
)
;
}
aWriter
.
End
(
)
;
}
UniquePtr
<
char
[
]
>
ToJSON
(
PS
:
:
LockRef
aLock
double
aSinceTime
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
&
&
gPS
-
>
IsActive
(
aLock
)
)
;
SpliceableChunkedJSONWriter
b
;
StreamJSON
(
aLock
b
aSinceTime
)
;
return
b
.
WriteFunc
(
)
-
>
CopyData
(
)
;
}
ProfilerMarker
:
:
ProfilerMarker
(
const
char
*
aMarkerName
ProfilerMarkerPayload
*
aPayload
double
aTime
)
:
mMarkerName
(
strdup
(
aMarkerName
)
)
mPayload
(
aPayload
)
mTime
(
aTime
)
{
}
ProfilerMarker
:
:
~
ProfilerMarker
(
)
{
free
(
mMarkerName
)
;
delete
mPayload
;
}
void
ProfilerMarker
:
:
SetGeneration
(
uint32_t
aGenID
)
{
mGenID
=
aGenID
;
}
double
ProfilerMarker
:
:
GetTime
(
)
const
{
return
mTime
;
}
void
ProfilerMarker
:
:
StreamJSON
(
SpliceableJSONWriter
&
aWriter
const
TimeStamp
&
aStartTime
UniqueStacks
&
aUniqueStacks
)
const
{
aWriter
.
StartArrayElement
(
)
;
{
aUniqueStacks
.
mUniqueStrings
.
WriteElement
(
aWriter
GetMarkerName
(
)
)
;
aWriter
.
DoubleElement
(
mTime
)
;
if
(
mPayload
)
{
aWriter
.
StartObjectElement
(
)
;
{
mPayload
-
>
StreamPayload
(
aWriter
aStartTime
aUniqueStacks
)
;
}
aWriter
.
EndObject
(
)
;
}
}
aWriter
.
EndArray
(
)
;
}
enum
class
Verbosity
:
int8_t
{
UNCHECKED
NOTVERBOSE
VERBOSE
}
;
static
Verbosity
gVerbosity
=
Verbosity
:
:
UNCHECKED
;
static
StaticMutex
gVerbosityMutex
;
bool
profiler_verbose
(
)
{
StaticMutexAutoLock
lock
(
gVerbosityMutex
)
;
if
(
gVerbosity
=
=
Verbosity
:
:
UNCHECKED
)
{
gVerbosity
=
getenv
(
"
MOZ_PROFILER_VERBOSE
"
)
?
Verbosity
:
:
VERBOSE
:
Verbosity
:
:
NOTVERBOSE
;
}
return
gVerbosity
=
=
Verbosity
:
:
VERBOSE
;
}
static
bool
set_profiler_interval
(
PS
:
:
LockRef
aLock
const
char
*
aInterval
)
{
if
(
aInterval
)
{
errno
=
0
;
long
int
n
=
strtol
(
aInterval
nullptr
10
)
;
if
(
errno
=
=
0
&
&
1
<
=
n
&
&
n
<
=
1000
)
{
gPS
-
>
SetEnvVarInterval
(
aLock
n
)
;
return
true
;
}
return
false
;
}
return
true
;
}
static
bool
set_profiler_entries
(
PS
:
:
LockRef
aLock
const
char
*
aEntries
)
{
if
(
aEntries
)
{
errno
=
0
;
long
int
n
=
strtol
(
aEntries
nullptr
10
)
;
if
(
errno
=
=
0
&
&
n
>
0
)
{
gPS
-
>
SetEnvVarEntries
(
aLock
n
)
;
return
true
;
}
return
false
;
}
return
true
;
}
static
bool
is_native_unwinding_avail
(
)
{
#
if
defined
(
HAVE_NATIVE_UNWIND
)
return
true
;
#
else
return
false
;
#
endif
}
static
void
profiler_usage
(
int
aExitCode
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
{
StaticMutexAutoLock
lock
(
gVerbosityMutex
)
;
gVerbosity
=
Verbosity
:
:
VERBOSE
;
}
LOG
(
"
"
)
;
LOG
(
"
Environment
variable
usage
:
"
)
;
LOG
(
"
"
)
;
LOG
(
"
MOZ_PROFILER_HELP
"
)
;
LOG
(
"
If
set
to
any
value
prints
this
message
.
"
)
;
LOG
(
"
"
)
;
LOG
(
"
MOZ_PROFILER_ENTRIES
=
<
1
.
.
>
(
count
)
"
)
;
LOG
(
"
If
unset
platform
default
is
used
.
"
)
;
LOG
(
"
"
)
;
LOG
(
"
MOZ_PROFILER_INTERVAL
=
<
1
.
.
1000
>
(
milliseconds
)
"
)
;
LOG
(
"
If
unset
platform
default
is
used
.
"
)
;
LOG
(
"
"
)
;
LOG
(
"
MOZ_PROFILER_VERBOSE
"
)
;
LOG
(
"
If
set
to
any
value
increases
verbosity
(
recommended
)
.
"
)
;
LOG
(
"
"
)
;
LOG
(
"
MOZ_PROFILER_LUL_TEST
"
)
;
LOG
(
"
If
set
to
any
value
runs
LUL
unit
tests
at
startup
of
"
)
;
LOG
(
"
the
unwinder
thread
and
prints
a
short
summary
of
"
)
;
LOG
(
"
results
.
"
)
;
LOG
(
"
"
)
;
LOGF
(
"
This
platform
%
s
native
unwinding
.
"
is_native_unwinding_avail
(
)
?
"
supports
"
:
"
does
not
support
"
)
;
LOG
(
"
"
)
;
exit
(
aExitCode
)
;
}
static
void
ReadProfilerEnvVars
(
PS
:
:
LockRef
aLock
)
{
const
char
*
help
=
getenv
(
"
MOZ_PROFILER_HELP
"
)
;
const
char
*
entries
=
getenv
(
"
MOZ_PROFILER_ENTRIES
"
)
;
const
char
*
interval
=
getenv
(
"
MOZ_PROFILER_INTERVAL
"
)
;
if
(
help
)
{
profiler_usage
(
0
)
;
}
if
(
!
set_profiler_entries
(
aLock
entries
)
|
|
!
set_profiler_interval
(
aLock
interval
)
)
{
profiler_usage
(
1
)
;
}
LOGF
(
"
entries
=
%
d
(
zero
means
\
"
platform
default
\
"
)
"
gPS
-
>
EnvVarEntries
(
aLock
)
)
;
LOGF
(
"
interval
=
%
d
ms
(
zero
means
\
"
platform
default
\
"
)
"
gPS
-
>
EnvVarInterval
(
aLock
)
)
;
}
static
bool
is_main_thread_name
(
const
char
*
aName
)
{
return
aName
&
&
(
strcmp
(
aName
kGeckoThreadName
)
=
=
0
)
;
}
#
ifdef
HAVE_VA_COPY
#
define
VARARGS_ASSIGN
(
foo
bar
)
VA_COPY
(
foo
bar
)
#
elif
defined
(
HAVE_VA_LIST_AS_ARRAY
)
#
define
VARARGS_ASSIGN
(
foo
bar
)
foo
[
0
]
=
bar
[
0
]
#
else
#
define
VARARGS_ASSIGN
(
foo
bar
)
(
foo
)
=
(
bar
)
#
endif
void
profiler_log
(
const
char
*
aStr
)
{
profiler_tracing
(
"
log
"
aStr
TRACING_EVENT
)
;
}
static
void
locked_profiler_add_marker
(
PS
:
:
LockRef
aLock
const
char
*
aMarker
ProfilerMarkerPayload
*
aPayload
)
;
void
profiler_log
(
const
char
*
aFmt
va_list
aArgs
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
|
|
gPS
-
>
FeaturePrivacy
(
lock
)
)
{
return
;
}
char
buf
[
2048
]
;
va_list
argsCpy
;
VARARGS_ASSIGN
(
argsCpy
aArgs
)
;
int
required
=
VsprintfLiteral
(
buf
aFmt
argsCpy
)
;
va_end
(
argsCpy
)
;
if
(
required
<
0
)
{
}
else
if
(
required
<
2048
)
{
auto
marker
=
new
ProfilerMarkerTracing
(
"
log
"
TRACING_EVENT
)
;
locked_profiler_add_marker
(
lock
buf
marker
)
;
}
else
{
char
*
heapBuf
=
new
char
[
required
+
1
]
;
va_list
argsCpy
;
VARARGS_ASSIGN
(
argsCpy
aArgs
)
;
vsnprintf
(
heapBuf
required
+
1
aFmt
argsCpy
)
;
va_end
(
argsCpy
)
;
auto
marker
=
new
ProfilerMarkerTracing
(
"
log
"
TRACING_EVENT
)
;
locked_profiler_add_marker
(
lock
heapBuf
marker
)
;
delete
[
]
heapBuf
;
}
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
GeckoProfilerMallocSizeOf
)
NS_IMETHODIMP
GeckoProfilerReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
size_t
n
=
0
;
if
(
gPS
)
{
n
=
GeckoProfilerMallocSizeOf
(
gPS
)
;
const
PS
:
:
ThreadVector
&
threads
=
gPS
-
>
Threads
(
lock
)
;
for
(
uint32_t
i
=
0
;
i
<
threads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
threads
.
at
(
i
)
;
n
+
=
info
-
>
SizeOfIncludingThis
(
GeckoProfilerMallocSizeOf
)
;
}
if
(
gPS
-
>
IsActive
(
lock
)
)
{
n
+
=
gPS
-
>
Buffer
(
lock
)
-
>
SizeOfIncludingThis
(
GeckoProfilerMallocSizeOf
)
;
}
MOZ_COLLECT_REPORT
(
"
explicit
/
profiler
/
profiler
-
state
"
KIND_HEAP
UNITS_BYTES
n
"
Memory
used
by
the
Gecko
Profiler
'
s
ProfilerState
object
(
excluding
"
"
memory
used
by
LUL
)
.
"
)
;
#
if
defined
(
USE_LUL_STACKWALK
)
lul
:
:
LUL
*
lul
=
gPS
-
>
LUL
(
lock
)
;
n
=
lul
?
lul
-
>
SizeOfIncludingThis
(
GeckoProfilerMallocSizeOf
)
:
0
;
MOZ_COLLECT_REPORT
(
"
explicit
/
profiler
/
lul
"
KIND_HEAP
UNITS_BYTES
n
"
Memory
used
by
LUL
a
stack
unwinder
used
by
the
Gecko
Profiler
.
"
)
;
#
endif
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
GeckoProfilerReporter
nsIMemoryReporter
)
static
bool
ThreadSelected
(
PS
:
:
LockRef
aLock
const
char
*
aThreadName
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
const
Vector
<
std
:
:
string
>
&
threadNameFilters
=
gPS
-
>
ThreadNameFilters
(
aLock
)
;
if
(
threadNameFilters
.
empty
(
)
)
{
return
true
;
}
std
:
:
string
name
=
aThreadName
;
std
:
:
transform
(
name
.
begin
(
)
name
.
end
(
)
name
.
begin
(
)
:
:
tolower
)
;
for
(
uint32_t
i
=
0
;
i
<
threadNameFilters
.
length
(
)
;
+
+
i
)
{
std
:
:
string
filter
=
threadNameFilters
[
i
]
;
std
:
:
transform
(
filter
.
begin
(
)
filter
.
end
(
)
filter
.
begin
(
)
:
:
tolower
)
;
if
(
name
.
find
(
filter
)
!
=
std
:
:
string
:
:
npos
)
{
return
true
;
}
}
return
false
;
}
static
void
MaybeSetProfile
(
PS
:
:
LockRef
aLock
ThreadInfo
*
aInfo
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
if
(
(
aInfo
-
>
IsMainThread
(
)
|
|
gPS
-
>
FeatureThreads
(
aLock
)
)
&
&
ThreadSelected
(
aLock
aInfo
-
>
Name
(
)
)
)
{
aInfo
-
>
SetHasProfile
(
)
;
}
}
static
void
RegisterCurrentThread
(
PS
:
:
LockRef
aLock
const
char
*
aName
NotNull
<
PseudoStack
*
>
aPseudoStack
bool
aIsMainThread
void
*
stackTop
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
ThreadVector
&
threads
=
gPS
-
>
Threads
(
aLock
)
;
Thread
:
:
tid_t
id
=
Thread
:
:
GetCurrentId
(
)
;
for
(
uint32_t
i
=
0
;
i
<
threads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
threads
.
at
(
i
)
;
if
(
info
-
>
ThreadId
(
)
=
=
id
&
&
!
info
-
>
IsPendingDelete
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
}
ThreadInfo
*
info
=
new
ThreadInfo
(
aName
id
aIsMainThread
aPseudoStack
stackTop
)
;
MaybeSetProfile
(
aLock
info
)
;
threads
.
push_back
(
info
)
;
}
#
if
defined
(
GP_OS_windows
)
#
include
"
platform
-
win32
.
cpp
"
#
elif
defined
(
GP_OS_darwin
)
#
include
"
platform
-
macos
.
cpp
"
#
elif
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
#
include
"
platform
-
linux
-
android
.
cpp
"
#
else
#
error
"
bad
platform
"
#
endif
static
void
NotifyProfilerStarted
(
const
int
aEntries
double
aInterval
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
*
aThreadNameFilters
uint32_t
aFilterCount
)
{
if
(
!
CanNotifyObservers
(
)
)
{
return
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
;
}
nsTArray
<
nsCString
>
featuresArray
;
for
(
size_t
i
=
0
;
i
<
aFeatureCount
;
+
+
i
)
{
featuresArray
.
AppendElement
(
aFeatures
[
i
]
)
;
}
nsTArray
<
nsCString
>
threadNameFiltersArray
;
for
(
size_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
threadNameFiltersArray
.
AppendElement
(
aThreadNameFilters
[
i
]
)
;
}
nsCOMPtr
<
nsIProfilerStartParams
>
params
=
new
nsProfilerStartParams
(
aEntries
aInterval
featuresArray
threadNameFiltersArray
)
;
os
-
>
NotifyObservers
(
params
"
profiler
-
started
"
nullptr
)
;
}
static
void
NotifyObservers
(
const
char
*
aTopic
)
{
if
(
!
CanNotifyObservers
(
)
)
{
return
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
;
}
os
-
>
NotifyObservers
(
nullptr
aTopic
nullptr
)
;
}
static
void
locked_profiler_start
(
PS
:
:
LockRef
aLock
const
int
aEntries
double
aInterval
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
*
aThreadNameFilters
uint32_t
aFilterCount
)
;
void
profiler_init
(
void
*
aStackTop
)
{
LOG
(
"
BEGIN
profiler_init
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
gPS
)
;
const
char
*
features
[
]
=
{
"
js
"
#
if
defined
(
PROFILE_JAVA
)
"
java
"
#
endif
"
leaf
"
#
if
defined
(
HAVE_NATIVE_UNWIND
)
"
stackwalk
"
#
endif
"
threads
"
}
;
const
char
*
threadFilters
[
]
=
{
"
GeckoMain
"
"
Compositor
"
}
;
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
tlsPseudoStack
.
init
(
)
)
{
LOG
(
"
END
profiler_init
:
TLS
init
failed
"
)
;
return
;
}
gPS
=
new
PS
(
)
;
set_stderr_callback
(
profiler_log
)
;
bool
ignore
;
gPS
-
>
SetStartTime
(
lock
mozilla
:
:
TimeStamp
:
:
ProcessCreation
(
ignore
)
)
;
ReadProfilerEnvVars
(
lock
)
;
NotNull
<
PseudoStack
*
>
stack
=
WrapNotNull
(
new
PseudoStack
(
)
)
;
tlsPseudoStack
.
set
(
stack
)
;
bool
isMainThread
=
true
;
RegisterCurrentThread
(
lock
kGeckoThreadName
stack
isMainThread
aStackTop
)
;
PlatformInit
(
lock
)
;
#
ifdef
MOZ_TASK_TRACER
mozilla
:
:
tasktracer
:
:
InitTaskTracer
(
)
;
#
endif
#
if
defined
(
PROFILE_JAVA
)
if
(
mozilla
:
:
jni
:
:
IsFennec
(
)
)
{
GeckoJavaSampler
:
:
Init
(
)
;
}
#
endif
const
char
*
val
=
getenv
(
"
MOZ_PROFILER_STARTUP
"
)
;
if
(
!
val
|
|
!
*
val
)
{
LOG
(
"
END
profiler_init
:
MOZ_PROFILER_STARTUP
not
set
"
)
;
return
;
}
locked_profiler_start
(
lock
PROFILE_DEFAULT_ENTRIES
PROFILE_DEFAULT_INTERVAL
features
MOZ_ARRAY_LENGTH
(
features
)
threadFilters
MOZ_ARRAY_LENGTH
(
threadFilters
)
)
;
}
NotifyProfilerStarted
(
PROFILE_DEFAULT_ENTRIES
PROFILE_DEFAULT_INTERVAL
features
MOZ_ARRAY_LENGTH
(
features
)
threadFilters
MOZ_ARRAY_LENGTH
(
threadFilters
)
)
;
LOG
(
"
END
profiler_init
"
)
;
}
static
void
locked_profiler_save_profile_to_file
(
PS
:
:
LockRef
aLock
const
char
*
aFilename
)
;
static
SamplerThread
*
locked_profiler_stop
(
PS
:
:
LockRef
aLock
)
;
void
profiler_shutdown
(
)
{
LOG
(
"
BEGIN
profiler_shutdown
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
gPS
-
>
IsActive
(
lock
)
)
{
const
char
*
filename
=
getenv
(
"
MOZ_PROFILER_SHUTDOWN
"
)
;
if
(
filename
)
{
locked_profiler_save_profile_to_file
(
lock
filename
)
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
set_stderr_callback
(
nullptr
)
;
PS
:
:
ThreadVector
&
threads
=
gPS
-
>
Threads
(
lock
)
;
while
(
threads
.
size
(
)
>
0
)
{
delete
threads
.
back
(
)
;
threads
.
pop_back
(
)
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
lul
:
:
LUL
*
lul
=
gPS
-
>
LUL
(
lock
)
;
if
(
lul
)
{
delete
lul
;
gPS
-
>
SetLUL
(
lock
nullptr
)
;
}
#
endif
delete
gPS
;
gPS
=
nullptr
;
delete
tlsPseudoStack
.
get
(
)
;
tlsPseudoStack
.
set
(
nullptr
)
;
#
ifdef
MOZ_TASK_TRACER
mozilla
:
:
tasktracer
:
:
ShutdownTaskTracer
(
)
;
#
endif
}
if
(
samplerThread
)
{
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
LOG
(
"
END
profiler_shutdown
"
)
;
}
mozilla
:
:
UniquePtr
<
char
[
]
>
profiler_get_profile
(
double
aSinceTime
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
nullptr
;
}
return
ToJSON
(
lock
aSinceTime
)
;
}
JSObject
*
profiler_get_profile_jsobject
(
JSContext
*
aCx
double
aSinceTime
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
JS
:
:
RootedValue
val
(
aCx
)
;
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
nullptr
;
}
UniquePtr
<
char
[
]
>
buf
=
ToJSON
(
lock
aSinceTime
)
;
NS_ConvertUTF8toUTF16
js_string
(
nsDependentCString
(
buf
.
get
(
)
)
)
;
auto
buf16
=
static_cast
<
const
char16_t
*
>
(
js_string
.
get
(
)
)
;
MOZ_ALWAYS_TRUE
(
JS_ParseJSON
(
aCx
buf16
js_string
.
Length
(
)
&
val
)
)
;
}
return
&
val
.
toObject
(
)
;
}
void
profiler_get_profile_jsobject_async
(
double
aSinceTime
mozilla
:
:
dom
:
:
Promise
*
aPromise
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
;
}
gPS
-
>
Gatherer
(
lock
)
-
>
Start
(
lock
aSinceTime
aPromise
)
;
}
void
profiler_save_profile_to_file_async
(
double
aSinceTime
const
char
*
aFileName
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
nsCString
filename
(
aFileName
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
[
=
]
(
)
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
|
|
!
gPS
-
>
IsActive
(
lock
)
)
{
return
;
}
gPS
-
>
Gatherer
(
lock
)
-
>
Start
(
lock
aSinceTime
filename
)
;
}
)
)
;
}
void
profiler_get_start_params
(
int
*
aEntries
double
*
aInterval
mozilla
:
:
Vector
<
const
char
*
>
*
aFilters
mozilla
:
:
Vector
<
const
char
*
>
*
aFeatures
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
if
(
NS_WARN_IF
(
!
aEntries
)
|
|
NS_WARN_IF
(
!
aInterval
)
|
|
NS_WARN_IF
(
!
aFilters
)
|
|
NS_WARN_IF
(
!
aFeatures
)
)
{
return
;
}
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
*
aEntries
=
gPS
-
>
Entries
(
lock
)
;
*
aInterval
=
gPS
-
>
Interval
(
lock
)
;
const
Vector
<
std
:
:
string
>
&
threadNameFilters
=
gPS
-
>
ThreadNameFilters
(
lock
)
;
MOZ_ALWAYS_TRUE
(
aFilters
-
>
resize
(
threadNameFilters
.
length
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
threadNameFilters
.
length
(
)
;
+
+
i
)
{
(
*
aFilters
)
[
i
]
=
threadNameFilters
[
i
]
.
c_str
(
)
;
}
const
Vector
<
std
:
:
string
>
&
features
=
gPS
-
>
Features
(
lock
)
;
MOZ_ALWAYS_TRUE
(
aFeatures
-
>
resize
(
features
.
length
(
)
)
)
;
for
(
size_t
i
=
0
;
i
<
features
.
length
(
)
;
+
+
i
)
{
(
*
aFeatures
)
[
i
]
=
features
[
i
]
.
c_str
(
)
;
}
}
void
profiler_will_gather_OOP_profile
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
gPSMutex
.
AssertCurrentThreadOwns
(
)
;
static
PS
:
:
Mutex
sFakeMutex
;
PS
:
:
AutoLock
fakeLock
(
sFakeMutex
)
;
MOZ_RELEASE_ASSERT
(
gPS
-
>
IsActive
(
fakeLock
)
)
;
gPS
-
>
Gatherer
(
fakeLock
)
-
>
WillGatherOOPProfile
(
)
;
}
void
profiler_gathered_OOP_profile
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
;
}
gPS
-
>
Gatherer
(
lock
)
-
>
GatheredOOPProfile
(
lock
)
;
}
void
profiler_OOP_exit_profile
(
const
nsCString
&
aProfile
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
;
}
gPS
-
>
Gatherer
(
lock
)
-
>
OOPExitProfile
(
aProfile
)
;
}
static
void
locked_profiler_save_profile_to_file
(
PS
:
:
LockRef
aLock
const
char
*
aFilename
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
&
&
gPS
-
>
IsActive
(
aLock
)
)
;
std
:
:
ofstream
stream
;
stream
.
open
(
aFilename
)
;
if
(
stream
.
is_open
(
)
)
{
SpliceableJSONWriter
w
(
mozilla
:
:
MakeUnique
<
OStreamJSONWriteFunc
>
(
stream
)
)
;
StreamJSON
(
aLock
w
0
)
;
stream
.
close
(
)
;
LOGF
(
"
locked_profiler_save_profile_to_file
:
Saved
to
%
s
"
aFilename
)
;
}
else
{
LOG
(
"
locked_profiler_save_profile_to_file
:
Failed
to
open
file
"
)
;
}
}
void
profiler_save_profile_to_file
(
const
char
*
aFilename
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
;
}
locked_profiler_save_profile_to_file
(
lock
aFilename
)
;
}
const
char
*
*
profiler_get_features
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
static
const
char
*
features
[
]
=
{
#
if
defined
(
MOZ_PROFILING
)
&
&
defined
(
HAVE_NATIVE_UNWIND
)
"
stackwalk
"
#
endif
"
leaf
"
"
java
"
"
js
"
"
gpu
"
"
threads
"
"
privacy
"
"
layersdump
"
"
displaylistdump
"
"
mainthreadio
"
"
memory
"
"
restyle
"
#
ifdef
MOZ_TASK_TRACER
"
tasktracer
"
#
endif
nullptr
}
;
return
features
;
}
void
profiler_get_buffer_info_helper
(
uint32_t
*
aCurrentPosition
uint32_t
*
aEntries
uint32_t
*
aGeneration
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
;
}
*
aCurrentPosition
=
gPS
-
>
Buffer
(
lock
)
-
>
mWritePos
;
*
aEntries
=
gPS
-
>
Entries
(
lock
)
;
*
aGeneration
=
gPS
-
>
Buffer
(
lock
)
-
>
mGeneration
;
}
static
bool
hasFeature
(
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
aFeature
)
{
for
(
size_t
i
=
0
;
i
<
aFeatureCount
;
i
+
+
)
{
if
(
strcmp
(
aFeatures
[
i
]
aFeature
)
=
=
0
)
{
return
true
;
}
}
return
false
;
}
static
void
locked_profiler_start
(
PS
:
:
LockRef
aLock
int
aEntries
double
aInterval
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
*
aThreadNameFilters
uint32_t
aFilterCount
)
{
LOG
(
"
BEGIN
locked_profiler_start
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
&
&
!
gPS
-
>
IsActive
(
aLock
)
)
;
bool
ignore
;
gPS
-
>
SetStartTime
(
aLock
mozilla
:
:
TimeStamp
:
:
ProcessCreation
(
ignore
)
)
;
int
entries
=
PROFILE_DEFAULT_ENTRIES
;
if
(
aEntries
>
0
)
{
entries
=
aEntries
;
}
if
(
gPS
-
>
EnvVarEntries
(
aLock
)
>
0
)
{
entries
=
gPS
-
>
EnvVarEntries
(
aLock
)
;
}
gPS
-
>
SetEntries
(
aLock
entries
)
;
double
interval
=
PROFILE_DEFAULT_INTERVAL
;
if
(
aInterval
>
0
)
{
interval
=
aInterval
;
}
if
(
gPS
-
>
EnvVarInterval
(
aLock
)
>
0
)
{
interval
=
gPS
-
>
EnvVarInterval
(
aLock
)
;
}
gPS
-
>
SetInterval
(
aLock
interval
)
;
Vector
<
std
:
:
string
>
&
features
=
gPS
-
>
Features
(
aLock
)
;
MOZ_ALWAYS_TRUE
(
features
.
resize
(
aFeatureCount
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aFeatureCount
;
+
+
i
)
{
features
[
i
]
=
aFeatures
[
i
]
;
}
Vector
<
std
:
:
string
>
&
threadNameFilters
=
gPS
-
>
ThreadNameFilters
(
aLock
)
;
MOZ_ALWAYS_TRUE
(
threadNameFilters
.
resize
(
aFilterCount
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
threadNameFilters
[
i
]
=
aThreadNameFilters
[
i
]
;
}
#
define
HAS_FEATURE
(
feature
)
hasFeature
(
aFeatures
aFeatureCount
feature
)
gPS
-
>
SetFeatureDisplayListDump
(
aLock
HAS_FEATURE
(
"
displaylistdump
"
)
)
;
gPS
-
>
SetFeatureGPU
(
aLock
HAS_FEATURE
(
"
gpu
"
)
)
;
#
if
defined
(
PROFILE_JAVA
)
gPS
-
>
SetFeatureJava
(
aLock
mozilla
:
:
jni
:
:
IsFennec
(
)
&
&
HAS_FEATURE
(
"
java
"
)
)
;
#
endif
bool
featureJS
=
HAS_FEATURE
(
"
js
"
)
;
gPS
-
>
SetFeatureJS
(
aLock
featureJS
)
;
gPS
-
>
SetFeatureLayersDump
(
aLock
HAS_FEATURE
(
"
layersdump
"
)
)
;
gPS
-
>
SetFeatureLeaf
(
aLock
HAS_FEATURE
(
"
leaf
"
)
)
;
bool
featureMainThreadIO
=
HAS_FEATURE
(
"
mainthreadio
"
)
;
gPS
-
>
SetFeatureMemory
(
aLock
HAS_FEATURE
(
"
memory
"
)
)
;
gPS
-
>
SetFeaturePrivacy
(
aLock
HAS_FEATURE
(
"
privacy
"
)
)
;
gPS
-
>
SetFeatureRestyle
(
aLock
HAS_FEATURE
(
"
restyle
"
)
)
;
gPS
-
>
SetFeatureStackWalk
(
aLock
HAS_FEATURE
(
"
stackwalk
"
)
)
;
#
ifdef
MOZ_TASK_TRACER
bool
featureTaskTracer
=
HAS_FEATURE
(
"
tasktracer
"
)
;
gPS
-
>
SetFeatureTaskTracer
(
aLock
featureTaskTracer
)
;
#
endif
gPS
-
>
SetFeatureThreads
(
aLock
HAS_FEATURE
(
"
threads
"
)
|
|
aFilterCount
>
0
)
;
#
undef
HAS_FEATURE
gPS
-
>
SetBuffer
(
aLock
new
ProfileBuffer
(
entries
)
)
;
gPS
-
>
SetGatherer
(
aLock
new
mozilla
:
:
ProfileGatherer
(
)
)
;
const
PS
:
:
ThreadVector
&
threads
=
gPS
-
>
Threads
(
aLock
)
;
for
(
uint32_t
i
=
0
;
i
<
threads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
threads
.
at
(
i
)
;
MaybeSetProfile
(
aLock
info
)
;
if
(
info
-
>
IsPendingDelete
(
)
|
|
!
info
-
>
HasProfile
(
)
)
{
continue
;
}
info
-
>
Stack
(
)
-
>
reinitializeOnResume
(
)
;
if
(
featureJS
)
{
info
-
>
Stack
(
)
-
>
enableJSSampling
(
)
;
}
}
#
ifdef
MOZ_TASK_TRACER
if
(
featureTaskTracer
)
{
mozilla
:
:
tasktracer
:
:
StartLogging
(
)
;
}
#
endif
#
if
defined
(
PROFILE_JAVA
)
if
(
gPS
-
>
FeatureJava
(
aLock
)
)
{
int
javaInterval
=
interval
;
if
(
javaInterval
<
10
)
{
javaInterval
=
10
;
}
mozilla
:
:
java
:
:
GeckoJavaSampler
:
:
Start
(
javaInterval
1000
)
;
}
#
endif
PS
:
:
SetActive
(
aLock
)
;
gPS
-
>
SetIsPaused
(
aLock
false
)
;
gPS
-
>
SetSamplerThread
(
aLock
new
SamplerThread
(
aLock
PS
:
:
ActivityGeneration
(
aLock
)
interval
)
)
;
if
(
featureMainThreadIO
)
{
auto
interposeObserver
=
new
mozilla
:
:
ProfilerIOInterposeObserver
(
)
;
gPS
-
>
SetInterposeObserver
(
aLock
interposeObserver
)
;
mozilla
:
:
IOInterposer
:
:
Register
(
mozilla
:
:
IOInterposeObserver
:
:
OpAll
interposeObserver
)
;
}
LOG
(
"
END
locked_profiler_start
"
)
;
}
void
profiler_start
(
int
aEntries
double
aInterval
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
*
aThreadNameFilters
uint32_t
aFilterCount
)
{
LOG
(
"
BEGIN
profiler_start
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
)
{
profiler_init
(
nullptr
)
;
}
if
(
gPS
-
>
IsActive
(
lock
)
)
{
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
locked_profiler_start
(
lock
aEntries
aInterval
aFeatures
aFeatureCount
aThreadNameFilters
aFilterCount
)
;
}
if
(
samplerThread
)
{
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
NotifyProfilerStarted
(
aEntries
aInterval
aFeatures
aFeatureCount
aThreadNameFilters
aFilterCount
)
;
LOG
(
"
END
profiler_start
"
)
;
}
static
MOZ_MUST_USE
SamplerThread
*
locked_profiler_stop
(
PS
:
:
LockRef
aLock
)
{
LOG
(
"
BEGIN
locked_profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
&
&
gPS
-
>
IsActive
(
aLock
)
)
;
mozilla
:
:
IOInterposer
:
:
Unregister
(
mozilla
:
:
IOInterposeObserver
:
:
OpAll
gPS
-
>
InterposeObserver
(
aLock
)
)
;
gPS
-
>
SetInterposeObserver
(
aLock
nullptr
)
;
SamplerThread
*
samplerThread
=
gPS
-
>
SamplerThread
(
aLock
)
;
samplerThread
-
>
Stop
(
aLock
)
;
gPS
-
>
SetSamplerThread
(
aLock
nullptr
)
;
gPS
-
>
SetIsPaused
(
aLock
false
)
;
gPS
-
>
SetInactive
(
aLock
)
;
#
ifdef
MOZ_TASK_TRACER
if
(
gPS
-
>
FeatureTaskTracer
(
aLock
)
)
{
mozilla
:
:
tasktracer
:
:
StopLogging
(
)
;
}
#
endif
PS
:
:
ThreadVector
&
threads
=
gPS
-
>
Threads
(
aLock
)
;
for
(
uint32_t
i
=
0
;
i
<
threads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
threads
.
at
(
i
)
;
if
(
info
-
>
IsPendingDelete
(
)
)
{
delete
info
;
threads
.
erase
(
threads
.
begin
(
)
+
i
)
;
i
-
-
;
}
}
gPS
-
>
Gatherer
(
aLock
)
-
>
Cancel
(
)
;
gPS
-
>
SetGatherer
(
aLock
nullptr
)
;
delete
gPS
-
>
Buffer
(
aLock
)
;
gPS
-
>
SetBuffer
(
aLock
nullptr
)
;
if
(
gPS
-
>
FeatureJS
(
aLock
)
)
{
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
MOZ_ASSERT
(
stack
!
=
nullptr
)
;
stack
-
>
disableJSSampling
(
)
;
}
gPS
-
>
SetFeatureDisplayListDump
(
aLock
false
)
;
gPS
-
>
SetFeatureGPU
(
aLock
false
)
;
gPS
-
>
SetFeatureJava
(
aLock
false
)
;
gPS
-
>
SetFeatureJS
(
aLock
false
)
;
gPS
-
>
SetFeatureLayersDump
(
aLock
false
)
;
gPS
-
>
SetFeatureLeaf
(
aLock
false
)
;
gPS
-
>
SetFeatureMemory
(
aLock
false
)
;
gPS
-
>
SetFeaturePrivacy
(
aLock
false
)
;
gPS
-
>
SetFeatureRestyle
(
aLock
false
)
;
gPS
-
>
SetFeatureStackWalk
(
aLock
false
)
;
gPS
-
>
SetFeatureTaskTracer
(
aLock
false
)
;
gPS
-
>
SetFeatureThreads
(
aLock
false
)
;
gPS
-
>
ThreadNameFilters
(
aLock
)
.
clear
(
)
;
gPS
-
>
Features
(
aLock
)
.
clear
(
)
;
gPS
-
>
SetInterval
(
aLock
0
.
0
)
;
gPS
-
>
SetEntries
(
aLock
0
)
;
LOG
(
"
END
locked_profiler_stop
"
)
;
return
samplerThread
;
}
void
profiler_stop
(
)
{
LOG
(
"
BEGIN
profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
SamplerThread
*
samplerThread
;
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
LOG
(
"
END
profiler_stop
:
inactive
"
)
;
return
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
LOG
(
"
END
profiler_stop
"
)
;
}
bool
profiler_is_paused
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
false
;
}
return
gPS
-
>
IsPaused
(
lock
)
;
}
void
profiler_pause
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
;
}
gPS
-
>
SetIsPaused
(
lock
true
)
;
}
NotifyObservers
(
"
profiler
-
paused
"
)
;
}
void
profiler_resume
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
{
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
;
}
gPS
-
>
SetIsPaused
(
lock
false
)
;
}
NotifyObservers
(
"
profiler
-
resumed
"
)
;
}
bool
profiler_feature_active
(
const
char
*
aName
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
false
;
}
if
(
strcmp
(
aName
"
displaylistdump
"
)
=
=
0
)
{
return
gPS
-
>
FeatureDisplayListDump
(
lock
)
;
}
if
(
strcmp
(
aName
"
gpu
"
)
=
=
0
)
{
return
gPS
-
>
FeatureGPU
(
lock
)
;
}
if
(
strcmp
(
aName
"
layersdump
"
)
=
=
0
)
{
return
gPS
-
>
FeatureLayersDump
(
lock
)
;
}
if
(
strcmp
(
aName
"
restyle
"
)
=
=
0
)
{
return
gPS
-
>
FeatureRestyle
(
lock
)
;
}
return
false
;
}
bool
profiler_is_active
(
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
return
gPS
-
>
IsActive
(
lock
)
;
}
void
profiler_set_frame_number
(
int
aFrameNumber
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
gPS
-
>
SetFrameNumber
(
lock
aFrameNumber
)
;
}
void
profiler_register_thread
(
const
char
*
aName
void
*
aGuessStackTop
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
MOZ_ASSERT
(
tlsPseudoStack
.
get
(
)
=
=
nullptr
)
;
NotNull
<
PseudoStack
*
>
stack
=
WrapNotNull
(
new
PseudoStack
(
)
)
;
tlsPseudoStack
.
set
(
stack
)
;
bool
isMainThread
=
is_main_thread_name
(
aName
)
;
void
*
stackTop
=
GetStackTop
(
aGuessStackTop
)
;
RegisterCurrentThread
(
lock
aName
stack
isMainThread
stackTop
)
;
}
void
profiler_unregister_thread
(
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
Thread
:
:
tid_t
id
=
Thread
:
:
GetCurrentId
(
)
;
bool
wasPseudoStackTransferred
=
false
;
PS
:
:
ThreadVector
&
threads
=
gPS
-
>
Threads
(
lock
)
;
for
(
uint32_t
i
=
0
;
i
<
threads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
threads
.
at
(
i
)
;
if
(
info
-
>
ThreadId
(
)
=
=
id
&
&
!
info
-
>
IsPendingDelete
(
)
)
{
if
(
gPS
-
>
IsActive
(
lock
)
)
{
info
-
>
SetPendingDelete
(
)
;
wasPseudoStackTransferred
=
true
;
}
else
{
delete
info
;
threads
.
erase
(
threads
.
begin
(
)
+
i
)
;
}
break
;
}
}
if
(
!
wasPseudoStackTransferred
)
{
delete
tlsPseudoStack
.
get
(
)
;
}
tlsPseudoStack
.
set
(
nullptr
)
;
}
void
profiler_thread_sleep
(
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
stack
=
=
nullptr
)
{
return
;
}
stack
-
>
setSleeping
(
)
;
}
void
profiler_thread_wake
(
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
stack
=
=
nullptr
)
{
return
;
}
stack
-
>
setAwake
(
)
;
}
bool
profiler_thread_is_sleeping
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
stack
=
=
nullptr
)
{
return
false
;
}
return
stack
-
>
isSleeping
(
)
;
}
void
profiler_js_operation_callback
(
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
stack
)
{
return
;
}
stack
-
>
jsOperationCallback
(
)
;
}
double
profiler_time
(
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
mozilla
:
:
TimeDuration
delta
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
-
gPS
-
>
StartTime
(
lock
)
;
return
delta
.
ToMilliseconds
(
)
;
}
bool
profiler_is_active_and_not_in_privacy_mode
(
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
return
gPS
-
>
IsActive
(
lock
)
&
&
!
gPS
-
>
FeaturePrivacy
(
lock
)
;
}
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
|
|
gPS
-
>
FeaturePrivacy
(
lock
)
)
{
return
nullptr
;
}
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
stack
)
{
MOZ_ASSERT
(
stack
)
;
return
nullptr
;
}
Thread
:
:
tid_t
tid
=
Thread
:
:
GetCurrentId
(
)
;
ProfileBuffer
*
buffer
=
new
ProfileBuffer
(
GET_BACKTRACE_DEFAULT_ENTRIES
)
;
ThreadInfo
*
threadInfo
=
new
ThreadInfo
(
"
SyncProfile
"
tid
NS_IsMainThread
(
)
WrapNotNull
(
stack
)
nullptr
)
;
threadInfo
-
>
SetHasProfile
(
)
;
TickSample
sample
;
sample
.
threadInfo
=
threadInfo
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
#
if
defined
(
GP_OS_windows
)
|
|
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
tickcontext_t
context
;
sample
.
PopulateContext
(
&
context
)
;
#
elif
defined
(
GP_OS_darwin
)
sample
.
PopulateContext
(
nullptr
)
;
#
else
#
error
"
unknown
platform
"
#
endif
#
endif
sample
.
isSamplingCurrentThread
=
true
;
sample
.
timestamp
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
Tick
(
lock
buffer
&
sample
)
;
return
UniqueProfilerBacktrace
(
new
ProfilerBacktrace
(
buffer
threadInfo
)
)
;
}
void
ProfilerBacktraceDestructor
:
:
operator
(
)
(
ProfilerBacktrace
*
aBacktrace
)
{
delete
aBacktrace
;
}
void
profiler_get_backtrace_noalloc
(
char
*
output
size_t
outputSize
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
MOZ_ASSERT
(
outputSize
>
=
2
)
;
char
*
bound
=
output
+
outputSize
-
2
;
output
[
0
]
=
output
[
1
]
=
'
\
0
'
;
PseudoStack
*
pseudoStack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
pseudoStack
)
{
return
;
}
volatile
js
:
:
ProfileEntry
*
pseudoFrames
=
pseudoStack
-
>
mStack
;
uint32_t
pseudoCount
=
pseudoStack
-
>
stackSize
(
)
;
for
(
uint32_t
i
=
0
;
i
<
pseudoCount
;
i
+
+
)
{
size_t
len
=
strlen
(
pseudoFrames
[
i
]
.
label
(
)
)
;
if
(
output
+
len
>
=
bound
)
break
;
strcpy
(
output
pseudoFrames
[
i
]
.
label
(
)
)
;
output
+
=
len
;
*
output
+
+
=
'
\
0
'
;
*
output
=
'
\
0
'
;
}
}
static
void
locked_profiler_add_marker
(
PS
:
:
LockRef
aLock
const
char
*
aMarker
ProfilerMarkerPayload
*
aPayload
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
MOZ_RELEASE_ASSERT
(
gPS
-
>
IsActive
(
aLock
)
&
&
!
gPS
-
>
FeaturePrivacy
(
aLock
)
)
;
mozilla
:
:
UniquePtr
<
ProfilerMarkerPayload
>
payload
(
aPayload
)
;
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
stack
)
{
return
;
}
mozilla
:
:
TimeStamp
origin
=
(
payload
&
&
!
payload
-
>
GetStartTime
(
)
.
IsNull
(
)
)
?
payload
-
>
GetStartTime
(
)
:
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
mozilla
:
:
TimeDuration
delta
=
origin
-
gPS
-
>
StartTime
(
aLock
)
;
stack
-
>
addMarker
(
aMarker
payload
.
release
(
)
delta
.
ToMilliseconds
(
)
)
;
}
void
profiler_add_marker
(
const
char
*
aMarker
ProfilerMarkerPayload
*
aPayload
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
mozilla
:
:
UniquePtr
<
ProfilerMarkerPayload
>
payload
(
aPayload
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
|
|
gPS
-
>
FeaturePrivacy
(
lock
)
)
{
return
;
}
locked_profiler_add_marker
(
lock
aMarker
payload
.
release
(
)
)
;
}
void
profiler_tracing
(
const
char
*
aCategory
const
char
*
aInfo
TracingMetadata
aMetaData
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
|
|
gPS
-
>
FeaturePrivacy
(
lock
)
)
{
return
;
}
auto
marker
=
new
ProfilerMarkerTracing
(
aCategory
aMetaData
)
;
locked_profiler_add_marker
(
lock
aInfo
marker
)
;
}
void
profiler_tracing
(
const
char
*
aCategory
const
char
*
aInfo
UniqueProfilerBacktrace
aCause
TracingMetadata
aMetaData
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
|
|
gPS
-
>
FeaturePrivacy
(
lock
)
)
{
return
;
}
auto
marker
=
new
ProfilerMarkerTracing
(
aCategory
aMetaData
mozilla
:
:
Move
(
aCause
)
)
;
locked_profiler_add_marker
(
lock
aInfo
marker
)
;
}
void
PseudoStack
:
:
flushSamplerOnJSShutdown
(
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
MOZ_ASSERT
(
mContext
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
;
}
gPS
-
>
SetIsPaused
(
lock
true
)
;
const
PS
:
:
ThreadVector
&
threads
=
gPS
-
>
Threads
(
lock
)
;
for
(
size_t
i
=
0
;
i
<
threads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
threads
.
at
(
i
)
;
if
(
!
info
-
>
HasProfile
(
)
|
|
info
-
>
IsPendingDelete
(
)
)
{
continue
;
}
if
(
info
-
>
Stack
(
)
-
>
mContext
!
=
mContext
)
{
continue
;
}
info
-
>
FlushSamplesAndMarkers
(
gPS
-
>
Buffer
(
lock
)
gPS
-
>
StartTime
(
lock
)
)
;
}
gPS
-
>
SetIsPaused
(
lock
false
)
;
}
