#
include
<
algorithm
>
#
include
<
ostream
>
#
include
<
fstream
>
#
include
<
sstream
>
#
include
<
errno
.
h
>
#
include
"
platform
.
h
"
#
include
"
PlatformMacros
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
GeckoProfilerReporter
.
h
"
#
include
"
ProfilerIOInterposeObserver
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
PseudoStack
.
h
"
#
include
"
ThreadInfo
.
h
"
#
include
"
nsIHttpProtocolHandler
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsMemoryReporterManager
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsProfilerStartParams
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
ProfilerMarkerPayload
.
h
"
#
include
"
shared
-
libraries
.
h
"
#
include
"
prdtoa
.
h
"
#
include
"
prtime
.
h
"
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
#
endif
#
if
defined
(
GP_OS_android
)
#
include
"
FennecJNINatives
.
h
"
#
include
"
FennecJNIWrappers
.
h
"
#
endif
#
if
defined
(
MOZ_PROFILING
)
&
&
\
(
defined
(
GP_OS_windows
)
|
|
defined
(
GP_OS_darwin
)
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_NS_STACKWALK
#
endif
#
if
defined
(
GP_PLAT_arm_android
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_EHABI_STACKWALK
#
include
"
EHABIStackWalk
.
h
"
#
endif
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_x86_linux
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_LUL_STACKWALK
#
include
"
lul
/
LulMain
.
h
"
#
include
"
lul
/
platform
-
linux
-
lul
.
h
"
#
endif
#
ifdef
MOZ_VALGRIND
#
include
<
valgrind
/
memcheck
.
h
>
#
else
#
define
VALGRIND_MAKE_MEM_DEFINED
(
_addr
_len
)
(
(
void
)
0
)
#
endif
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
#
include
<
ucontext
.
h
>
#
endif
using
namespace
mozilla
;
mozilla
:
:
LazyLogModule
gProfilerLog
(
"
prof
"
)
;
#
if
defined
(
GP_OS_android
)
class
GeckoJavaSampler
:
public
mozilla
:
:
java
:
:
GeckoJavaSampler
:
:
Natives
<
GeckoJavaSampler
>
{
private
:
GeckoJavaSampler
(
)
;
public
:
static
double
GetProfilerTime
(
)
{
if
(
!
profiler_is_active
(
)
)
{
return
0
.
0
;
}
return
profiler_time
(
)
;
}
;
}
;
#
endif
class
PSMutex
:
public
mozilla
:
:
StaticMutex
{
}
;
typedef
mozilla
:
:
BaseAutoLock
<
PSMutex
>
PSAutoLock
;
typedef
const
PSAutoLock
&
PSLockRef
;
#
define
PS_GET
(
type_
name_
)
\
static
type_
name_
(
PSLockRef
)
{
return
sInstance
-
>
m
#
#
name_
;
}
\
#
define
PS_GET_AND_SET
(
type_
name_
)
\
PS_GET
(
type_
name_
)
\
static
void
Set
#
#
name_
(
PSLockRef
type_
a
#
#
name_
)
\
{
sInstance
-
>
m
#
#
name_
=
a
#
#
name_
;
}
class
CorePS
{
private
:
CorePS
(
)
:
mProcessStartTime
(
mozilla
:
:
TimeStamp
:
:
ProcessCreation
(
)
)
#
ifdef
USE_LUL_STACKWALK
mLul
(
nullptr
)
#
endif
{
}
~
CorePS
(
)
{
while
(
mLiveThreads
.
size
(
)
>
0
)
{
delete
mLiveThreads
.
back
(
)
;
mLiveThreads
.
pop_back
(
)
;
}
while
(
mDeadThreads
.
size
(
)
>
0
)
{
delete
mDeadThreads
.
back
(
)
;
mDeadThreads
.
pop_back
(
)
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
delete
mLul
;
#
endif
}
public
:
typedef
std
:
:
vector
<
ThreadInfo
*
>
ThreadVector
;
static
void
Create
(
PSLockRef
aLock
)
{
sInstance
=
new
CorePS
(
)
;
}
static
void
Destroy
(
PSLockRef
aLock
)
{
delete
sInstance
;
sInstance
=
nullptr
;
}
static
bool
Exists
(
)
{
return
!
!
sInstance
;
}
static
void
AddSizeOf
(
PSLockRef
MallocSizeOf
aMallocSizeOf
size_t
&
aProfSize
size_t
&
aLulSize
)
{
aProfSize
+
=
aMallocSizeOf
(
sInstance
)
;
for
(
uint32_t
i
=
0
;
i
<
sInstance
-
>
mLiveThreads
.
size
(
)
;
i
+
+
)
{
aProfSize
+
=
sInstance
-
>
mLiveThreads
.
at
(
i
)
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
for
(
uint32_t
i
=
0
;
i
<
sInstance
-
>
mDeadThreads
.
size
(
)
;
i
+
+
)
{
aProfSize
+
=
sInstance
-
>
mDeadThreads
.
at
(
i
)
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
if
(
sInstance
-
>
mLul
)
{
aLulSize
+
=
sInstance
-
>
mLul
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
#
endif
}
PS_GET
(
TimeStamp
ProcessStartTime
)
PS_GET
(
ThreadVector
&
LiveThreads
)
PS_GET
(
ThreadVector
&
DeadThreads
)
#
ifdef
USE_LUL_STACKWALK
PS_GET_AND_SET
(
lul
:
:
LUL
*
Lul
)
#
endif
private
:
static
CorePS
*
sInstance
;
const
mozilla
:
:
TimeStamp
mProcessStartTime
;
ThreadVector
mLiveThreads
;
ThreadVector
mDeadThreads
;
#
ifdef
USE_LUL_STACKWALK
lul
:
:
LUL
*
mLul
;
#
endif
}
;
CorePS
*
CorePS
:
:
sInstance
=
nullptr
;
class
SamplerThread
;
static
SamplerThread
*
NewSamplerThread
(
PSLockRef
aLock
uint32_t
aGeneration
double
aInterval
)
;
class
ActivePS
{
private
:
static
uint32_t
AdjustFeatures
(
uint32_t
aFeatures
uint32_t
aFilterCount
)
{
aFeatures
&
=
profiler_get_available_features
(
)
;
#
if
defined
(
GP_OS_android
)
if
(
!
mozilla
:
:
jni
:
:
IsFennec
(
)
)
{
aFeatures
&
=
~
ProfilerFeature
:
:
Java
;
}
#
endif
if
(
aFilterCount
>
0
)
{
aFeatures
|
=
ProfilerFeature
:
:
Threads
;
}
return
aFeatures
;
}
ActivePS
(
PSLockRef
aLock
int
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
:
mGeneration
(
sNextGeneration
+
+
)
mEntries
(
aEntries
)
mInterval
(
aInterval
)
mFeatures
(
AdjustFeatures
(
aFeatures
aFilterCount
)
)
mBuffer
(
new
ProfileBuffer
(
aEntries
)
)
mSamplerThread
(
NewSamplerThread
(
aLock
mGeneration
aInterval
)
)
mInterposeObserver
(
ProfilerFeature
:
:
HasMainThreadIO
(
aFeatures
)
?
new
mozilla
:
:
ProfilerIOInterposeObserver
(
)
:
nullptr
)
#
undef
HAS_FEATURE
mIsPaused
(
false
)
#
if
defined
(
GP_OS_linux
)
mWasPaused
(
false
)
#
endif
{
MOZ_ALWAYS_TRUE
(
mFilters
.
resize
(
aFilterCount
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
mFilters
[
i
]
=
aFilters
[
i
]
;
}
if
(
mInterposeObserver
)
{
if
(
NS_IsMainThread
(
)
)
{
IOInterposer
:
:
Register
(
IOInterposeObserver
:
:
OpAll
mInterposeObserver
)
;
}
else
{
RefPtr
<
ProfilerIOInterposeObserver
>
observer
=
mInterposeObserver
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
[
=
]
(
)
{
IOInterposer
:
:
Register
(
IOInterposeObserver
:
:
OpAll
observer
)
;
}
)
)
;
}
}
}
~
ActivePS
(
)
{
if
(
mInterposeObserver
)
{
if
(
NS_IsMainThread
(
)
)
{
IOInterposer
:
:
Unregister
(
IOInterposeObserver
:
:
OpAll
mInterposeObserver
)
;
}
else
{
RefPtr
<
ProfilerIOInterposeObserver
>
observer
=
mInterposeObserver
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
[
=
]
(
)
{
IOInterposer
:
:
Unregister
(
IOInterposeObserver
:
:
OpAll
observer
)
;
}
)
)
;
}
}
}
bool
ThreadSelected
(
const
char
*
aThreadName
)
{
MOZ_RELEASE_ASSERT
(
sInstance
)
;
if
(
mFilters
.
empty
(
)
)
{
return
true
;
}
std
:
:
string
name
=
aThreadName
;
std
:
:
transform
(
name
.
begin
(
)
name
.
end
(
)
name
.
begin
(
)
:
:
tolower
)
;
for
(
uint32_t
i
=
0
;
i
<
mFilters
.
length
(
)
;
+
+
i
)
{
std
:
:
string
filter
=
mFilters
[
i
]
;
std
:
:
transform
(
filter
.
begin
(
)
filter
.
end
(
)
filter
.
begin
(
)
:
:
tolower
)
;
if
(
name
.
find
(
filter
)
!
=
std
:
:
string
:
:
npos
)
{
return
true
;
}
}
return
false
;
}
public
:
static
void
Create
(
PSLockRef
aLock
int
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
{
sInstance
=
new
ActivePS
(
aLock
aEntries
aInterval
aFeatures
aFilters
aFilterCount
)
;
}
static
MOZ_MUST_USE
SamplerThread
*
Destroy
(
PSLockRef
aLock
)
{
auto
samplerThread
=
sInstance
-
>
mSamplerThread
;
delete
sInstance
;
sInstance
=
nullptr
;
return
samplerThread
;
}
static
bool
Exists
(
PSLockRef
)
{
return
!
!
sInstance
;
}
static
size_t
SizeOf
(
PSLockRef
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aMallocSizeOf
(
sInstance
)
;
n
+
=
sInstance
-
>
mBuffer
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
return
n
;
}
static
bool
ShouldProfileThread
(
PSLockRef
aLock
ThreadInfo
*
aInfo
)
{
MOZ_RELEASE_ASSERT
(
sInstance
)
;
return
(
(
aInfo
-
>
IsMainThread
(
)
|
|
FeatureThreads
(
aLock
)
)
&
&
sInstance
-
>
ThreadSelected
(
aInfo
-
>
Name
(
)
)
)
;
}
PS_GET
(
uint32_t
Generation
)
PS_GET
(
int
Entries
)
PS_GET
(
double
Interval
)
PS_GET
(
uint32_t
Features
)
#
define
PS_GET_FEATURE
(
n_
str_
Name_
)
\
static
bool
Feature
#
#
Name_
(
PSLockRef
)
\
{
\
return
ProfilerFeature
:
:
Has
#
#
Name_
(
sInstance
-
>
mFeatures
)
;
\
}
PROFILER_FOR_EACH_FEATURE
(
PS_GET_FEATURE
)
#
undef
PS_GET_FEATURE
PS_GET
(
const
Vector
<
std
:
:
string
>
&
Filters
)
static
ProfileBuffer
*
Buffer
(
PSLockRef
)
{
return
sInstance
-
>
mBuffer
.
get
(
)
;
}
PS_GET_AND_SET
(
bool
IsPaused
)
#
if
defined
(
GP_OS_linux
)
PS_GET_AND_SET
(
bool
WasPaused
)
#
endif
private
:
static
ActivePS
*
sInstance
;
const
uint32_t
mGeneration
;
static
uint32_t
sNextGeneration
;
const
int
mEntries
;
const
double
mInterval
;
const
uint32_t
mFeatures
;
Vector
<
std
:
:
string
>
mFilters
;
const
UniquePtr
<
ProfileBuffer
>
mBuffer
;
SamplerThread
*
const
mSamplerThread
;
const
RefPtr
<
mozilla
:
:
ProfilerIOInterposeObserver
>
mInterposeObserver
;
bool
mIsPaused
;
#
if
defined
(
GP_OS_linux
)
bool
mWasPaused
;
#
endif
}
;
ActivePS
*
ActivePS
:
:
sInstance
=
nullptr
;
uint32_t
ActivePS
:
:
sNextGeneration
=
0
;
#
undef
PS_GET
#
undef
PS_GET_AND_SET
static
PSMutex
gPSMutex
;
class
TLSInfo
{
public
:
static
bool
Init
(
PSLockRef
)
{
bool
ok1
=
sThreadInfo
.
init
(
)
;
bool
ok2
=
sPseudoStack
.
init
(
)
;
return
ok1
&
&
ok2
;
}
static
ThreadInfo
*
Info
(
PSLockRef
)
{
return
sThreadInfo
.
get
(
)
;
}
static
RacyThreadInfo
*
RacyInfo
(
)
{
ThreadInfo
*
info
=
sThreadInfo
.
get
(
)
;
return
info
?
info
-
>
RacyInfo
(
)
.
get
(
)
:
nullptr
;
}
static
PseudoStack
*
Stack
(
)
{
return
sPseudoStack
.
get
(
)
;
}
static
void
SetInfo
(
PSLockRef
ThreadInfo
*
aInfo
)
{
sThreadInfo
.
set
(
aInfo
)
;
sPseudoStack
.
set
(
aInfo
?
aInfo
-
>
RacyInfo
(
)
.
get
(
)
:
nullptr
)
;
}
private
:
static
MOZ_THREAD_LOCAL
(
ThreadInfo
*
)
sThreadInfo
;
}
;
MOZ_THREAD_LOCAL
(
ThreadInfo
*
)
TLSInfo
:
:
sThreadInfo
;
MOZ_THREAD_LOCAL
(
PseudoStack
*
)
sPseudoStack
;
static
const
char
*
const
kMainThreadName
=
"
GeckoMain
"
;
class
TickSample
{
public
:
TickSample
(
ThreadInfo
*
aThreadInfo
int64_t
aRSSMemory
int64_t
aUSSMemory
)
:
mIsSynchronous
(
false
)
mTimeStamp
(
mozilla
:
:
TimeStamp
:
:
Now
(
)
)
mThreadId
(
aThreadInfo
-
>
ThreadId
(
)
)
mRacyInfo
(
aThreadInfo
-
>
RacyInfo
(
)
)
mJSContext
(
aThreadInfo
-
>
mContext
)
mStackTop
(
aThreadInfo
-
>
StackTop
(
)
)
mLastSample
(
&
aThreadInfo
-
>
LastSample
(
)
)
mPlatformData
(
aThreadInfo
-
>
GetPlatformData
(
)
)
mResponsiveness
(
aThreadInfo
-
>
GetThreadResponsiveness
(
)
)
mRSSMemory
(
aRSSMemory
)
mUSSMemory
(
aUSSMemory
)
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
mContext
(
nullptr
)
#
endif
mPC
(
nullptr
)
mSP
(
nullptr
)
mFP
(
nullptr
)
mLR
(
nullptr
)
{
}
TickSample
(
NotNull
<
RacyThreadInfo
*
>
aRacyInfo
JSContext
*
aJSContext
PlatformData
*
aPlatformData
)
:
mIsSynchronous
(
true
)
mTimeStamp
(
mozilla
:
:
TimeStamp
:
:
Now
(
)
)
mThreadId
(
Thread
:
:
GetCurrentId
(
)
)
mRacyInfo
(
aRacyInfo
)
mJSContext
(
aJSContext
)
mStackTop
(
nullptr
)
mLastSample
(
nullptr
)
mPlatformData
(
aPlatformData
)
mResponsiveness
(
nullptr
)
mRSSMemory
(
0
)
mUSSMemory
(
0
)
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
mContext
(
nullptr
)
#
endif
mPC
(
nullptr
)
mSP
(
nullptr
)
mFP
(
nullptr
)
mLR
(
nullptr
)
{
}
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
void
PopulateContext
(
ucontext_t
*
aContext
)
;
#
else
void
PopulateContext
(
)
;
#
endif
const
bool
mIsSynchronous
;
const
mozilla
:
:
TimeStamp
mTimeStamp
;
const
int
mThreadId
;
const
NotNull
<
RacyThreadInfo
*
>
mRacyInfo
;
JSContext
*
const
mJSContext
;
void
*
const
mStackTop
;
ProfileBuffer
:
:
LastSample
*
const
mLastSample
;
PlatformData
*
const
mPlatformData
;
ThreadResponsiveness
*
const
mResponsiveness
;
const
int64_t
mRSSMemory
;
const
int64_t
mUSSMemory
;
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
ucontext_t
*
mContext
;
#
endif
Address
mPC
;
Address
mSP
;
Address
mFP
;
Address
mLR
;
}
;
static
void
AddDynamicCodeLocationTag
(
ProfileBuffer
*
aBuffer
const
char
*
aStr
)
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
CodeLocation
(
"
"
)
)
;
size_t
strLen
=
strlen
(
aStr
)
+
1
;
for
(
size_t
j
=
0
;
j
<
strLen
;
)
{
char
text
[
sizeof
(
void
*
)
]
;
size_t
len
=
sizeof
(
void
*
)
/
sizeof
(
char
)
;
if
(
j
+
len
>
=
strLen
)
{
len
=
strLen
-
j
;
}
memcpy
(
text
&
aStr
[
j
]
len
)
;
j
+
=
sizeof
(
void
*
)
/
sizeof
(
char
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
EmbeddedString
(
*
(
(
void
*
*
)
(
&
text
[
0
]
)
)
)
)
;
}
}
static
void
AddPseudoEntry
(
PSLockRef
aLock
ProfileBuffer
*
aBuffer
volatile
js
:
:
ProfileEntry
&
entry
NotNull
<
RacyThreadInfo
*
>
aRacyInfo
)
{
if
(
entry
.
hasFlag
(
js
:
:
ProfileEntry
:
:
BEGIN_PSEUDO_JS
)
)
{
return
;
}
int
lineno
=
-
1
;
const
char
*
label
=
entry
.
label
(
)
;
bool
includeDynamicString
=
!
ActivePS
:
:
FeaturePrivacy
(
aLock
)
;
const
char
*
dynamicString
=
includeDynamicString
?
entry
.
dynamicString
(
)
:
nullptr
;
if
(
dynamicString
)
{
char
combinedStringBuffer
[
512
]
;
const
char
*
locationString
;
size_t
labelLength
=
strlen
(
label
)
;
size_t
spaceLength
=
label
[
0
]
=
=
'
\
0
'
?
0
:
1
;
size_t
dynamicLength
=
strlen
(
dynamicString
)
;
size_t
combinedLength
=
labelLength
+
spaceLength
+
dynamicLength
;
if
(
combinedLength
<
ArrayLength
(
combinedStringBuffer
)
)
{
PodCopy
(
combinedStringBuffer
label
labelLength
)
;
if
(
spaceLength
!
=
0
)
{
combinedStringBuffer
[
labelLength
]
=
'
'
;
}
PodCopy
(
&
combinedStringBuffer
[
labelLength
+
spaceLength
]
dynamicString
dynamicLength
)
;
combinedStringBuffer
[
combinedLength
]
=
'
\
0
'
;
locationString
=
combinedStringBuffer
;
}
else
{
locationString
=
label
;
}
AddDynamicCodeLocationTag
(
aBuffer
locationString
)
;
if
(
entry
.
isJs
(
)
)
{
JSScript
*
script
=
entry
.
script
(
)
;
if
(
script
)
{
if
(
!
entry
.
pc
(
)
)
{
MOZ_ASSERT
(
&
entry
=
=
&
aRacyInfo
-
>
mStack
[
aRacyInfo
-
>
stackSize
(
)
-
1
]
)
;
}
else
{
lineno
=
JS_PCToLineNumber
(
script
entry
.
pc
(
)
)
;
}
}
}
else
{
lineno
=
entry
.
line
(
)
;
}
}
else
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
CodeLocation
(
label
)
)
;
if
(
entry
.
isCpp
(
)
)
{
lineno
=
entry
.
line
(
)
;
}
}
if
(
lineno
!
=
-
1
)
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
LineNumber
(
lineno
)
)
;
}
uint32_t
category
=
entry
.
category
(
)
;
MOZ_ASSERT
(
!
(
category
&
js
:
:
ProfileEntry
:
:
IS_CPP_ENTRY
)
)
;
if
(
category
)
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Category
(
(
int
)
category
)
)
;
}
}
struct
NativeStack
{
void
*
*
pc_array
;
void
*
*
sp_array
;
size_t
size
;
size_t
count
;
}
;
mozilla
:
:
Atomic
<
bool
>
WALKING_JS_STACK
(
false
)
;
struct
AutoWalkJSStack
{
bool
walkAllowed
;
AutoWalkJSStack
(
)
:
walkAllowed
(
false
)
{
walkAllowed
=
WALKING_JS_STACK
.
compareExchange
(
false
true
)
;
}
~
AutoWalkJSStack
(
)
{
if
(
walkAllowed
)
{
WALKING_JS_STACK
=
false
;
}
}
}
;
static
void
MergeStacksIntoProfile
(
PSLockRef
aLock
ProfileBuffer
*
aBuffer
const
TickSample
&
aSample
NativeStack
&
aNativeStack
)
{
NotNull
<
RacyThreadInfo
*
>
racyInfo
=
aSample
.
mRacyInfo
;
volatile
js
:
:
ProfileEntry
*
pseudoFrames
=
racyInfo
-
>
mStack
;
uint32_t
pseudoCount
=
racyInfo
-
>
stackSize
(
)
;
JSContext
*
context
=
aSample
.
mJSContext
;
uint32_t
startBufferGen
;
startBufferGen
=
aSample
.
mIsSynchronous
?
UINT32_MAX
:
aBuffer
-
>
mGeneration
;
uint32_t
jsCount
=
0
;
JS
:
:
ProfilingFrameIterator
:
:
Frame
jsFrames
[
1000
]
;
if
(
context
&
&
JS
:
:
IsProfilingEnabledForContext
(
context
)
)
{
AutoWalkJSStack
autoWalkJSStack
;
const
uint32_t
maxFrames
=
mozilla
:
:
ArrayLength
(
jsFrames
)
;
if
(
autoWalkJSStack
.
walkAllowed
)
{
JS
:
:
ProfilingFrameIterator
:
:
RegisterState
registerState
;
registerState
.
pc
=
aSample
.
mPC
;
registerState
.
sp
=
aSample
.
mSP
;
registerState
.
lr
=
aSample
.
mLR
;
registerState
.
fp
=
aSample
.
mFP
;
JS
:
:
ProfilingFrameIterator
jsIter
(
context
registerState
startBufferGen
)
;
for
(
;
jsCount
<
maxFrames
&
&
!
jsIter
.
done
(
)
;
+
+
jsIter
)
{
if
(
aSample
.
mIsSynchronous
|
|
jsIter
.
isWasm
(
)
)
{
uint32_t
extracted
=
jsIter
.
extractStack
(
jsFrames
jsCount
maxFrames
)
;
jsCount
+
=
extracted
;
if
(
jsCount
=
=
maxFrames
)
{
break
;
}
}
else
{
mozilla
:
:
Maybe
<
JS
:
:
ProfilingFrameIterator
:
:
Frame
>
frame
=
jsIter
.
getPhysicalFrameWithoutLabel
(
)
;
if
(
frame
.
isSome
(
)
)
{
jsFrames
[
jsCount
+
+
]
=
frame
.
value
(
)
;
}
}
}
}
}
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Sample
(
"
(
root
)
"
)
)
;
uint32_t
pseudoIndex
=
0
;
int32_t
jsIndex
=
jsCount
-
1
;
int32_t
nativeIndex
=
aNativeStack
.
count
-
1
;
uint8_t
*
lastPseudoCppStackAddr
=
nullptr
;
while
(
pseudoIndex
!
=
pseudoCount
|
|
jsIndex
>
=
0
|
|
nativeIndex
>
=
0
)
{
uint8_t
*
pseudoStackAddr
=
nullptr
;
uint8_t
*
jsStackAddr
=
nullptr
;
uint8_t
*
nativeStackAddr
=
nullptr
;
if
(
pseudoIndex
!
=
pseudoCount
)
{
volatile
js
:
:
ProfileEntry
&
pseudoFrame
=
pseudoFrames
[
pseudoIndex
]
;
if
(
pseudoFrame
.
isCpp
(
)
)
{
lastPseudoCppStackAddr
=
(
uint8_t
*
)
pseudoFrame
.
stackAddress
(
)
;
}
if
(
pseudoFrame
.
isJs
(
)
&
&
pseudoFrame
.
isOSR
(
)
)
{
pseudoIndex
+
+
;
continue
;
}
MOZ_ASSERT
(
lastPseudoCppStackAddr
)
;
pseudoStackAddr
=
lastPseudoCppStackAddr
;
}
if
(
jsIndex
>
=
0
)
{
jsStackAddr
=
(
uint8_t
*
)
jsFrames
[
jsIndex
]
.
stackAddress
;
}
if
(
nativeIndex
>
=
0
)
{
nativeStackAddr
=
(
uint8_t
*
)
aNativeStack
.
sp_array
[
nativeIndex
]
;
}
if
(
nativeStackAddr
&
&
(
pseudoStackAddr
=
=
nativeStackAddr
|
|
jsStackAddr
=
=
nativeStackAddr
)
)
{
nativeStackAddr
=
nullptr
;
nativeIndex
-
-
;
MOZ_ASSERT
(
pseudoStackAddr
|
|
jsStackAddr
)
;
}
MOZ_ASSERT_IF
(
pseudoStackAddr
pseudoStackAddr
!
=
jsStackAddr
&
&
pseudoStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
jsStackAddr
jsStackAddr
!
=
pseudoStackAddr
&
&
jsStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
nativeStackAddr
nativeStackAddr
!
=
pseudoStackAddr
&
&
nativeStackAddr
!
=
jsStackAddr
)
;
if
(
pseudoStackAddr
>
jsStackAddr
&
&
pseudoStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
pseudoIndex
<
pseudoCount
)
;
volatile
js
:
:
ProfileEntry
&
pseudoFrame
=
pseudoFrames
[
pseudoIndex
]
;
AddPseudoEntry
(
aLock
aBuffer
pseudoFrame
racyInfo
)
;
pseudoIndex
+
+
;
continue
;
}
if
(
jsStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
jsIndex
>
=
0
)
;
const
JS
:
:
ProfilingFrameIterator
:
:
Frame
&
jsFrame
=
jsFrames
[
jsIndex
]
;
if
(
aSample
.
mIsSynchronous
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Wasm
)
{
AddDynamicCodeLocationTag
(
aBuffer
jsFrame
.
label
)
;
}
else
{
MOZ_ASSERT
(
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Ion
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Baseline
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
JitReturnAddr
(
jsFrames
[
jsIndex
]
.
returnAddress
)
)
;
}
jsIndex
-
-
;
continue
;
}
if
(
nativeStackAddr
)
{
MOZ_ASSERT
(
nativeIndex
>
=
0
)
;
void
*
addr
=
(
void
*
)
aNativeStack
.
pc_array
[
nativeIndex
]
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
NativeLeafAddr
(
addr
)
)
;
}
if
(
nativeIndex
>
=
0
)
{
nativeIndex
-
-
;
}
}
if
(
!
aSample
.
mIsSynchronous
&
&
context
)
{
MOZ_ASSERT
(
aBuffer
-
>
mGeneration
>
=
startBufferGen
)
;
uint32_t
lapCount
=
aBuffer
-
>
mGeneration
-
startBufferGen
;
JS
:
:
UpdateJSContextProfilerSampleBufferGen
(
context
aBuffer
-
>
mGeneration
lapCount
)
;
}
}
#
if
defined
(
GP_OS_windows
)
static
uintptr_t
GetThreadHandle
(
PlatformData
*
aData
)
;
#
endif
#
ifdef
USE_NS_STACKWALK
static
void
StackWalkCallback
(
uint32_t
aFrameNumber
void
*
aPC
void
*
aSP
void
*
aClosure
)
{
NativeStack
*
nativeStack
=
static_cast
<
NativeStack
*
>
(
aClosure
)
;
MOZ_ASSERT
(
nativeStack
-
>
count
<
nativeStack
-
>
size
)
;
nativeStack
-
>
sp_array
[
nativeStack
-
>
count
]
=
aSP
;
nativeStack
-
>
pc_array
[
nativeStack
-
>
count
]
=
aPC
;
nativeStack
-
>
count
+
+
;
}
static
void
DoNativeBacktrace
(
PSLockRef
aLock
ProfileBuffer
*
aBuffer
const
TickSample
&
aSample
)
{
void
*
pc_array
[
1000
]
;
void
*
sp_array
[
1000
]
;
NativeStack
nativeStack
=
{
pc_array
sp_array
mozilla
:
:
ArrayLength
(
pc_array
)
0
}
;
StackWalkCallback
(
0
aSample
.
mPC
aSample
.
mSP
&
nativeStack
)
;
uint32_t
maxFrames
=
uint32_t
(
nativeStack
.
size
-
nativeStack
.
count
)
;
#
if
defined
(
GP_OS_darwin
)
|
|
(
defined
(
GP_PLAT_x86_windows
)
)
void
*
stackEnd
=
aSample
.
mStackTop
;
if
(
aSample
.
mFP
>
=
aSample
.
mSP
&
&
aSample
.
mFP
<
=
stackEnd
)
{
FramePointerStackWalk
(
StackWalkCallback
0
maxFrames
&
nativeStack
reinterpret_cast
<
void
*
*
>
(
aSample
.
mFP
)
stackEnd
)
;
}
#
else
uintptr_t
thread
=
GetThreadHandle
(
aSample
.
mPlatformData
)
;
MOZ_ASSERT
(
thread
)
;
MozStackWalk
(
StackWalkCallback
0
maxFrames
&
nativeStack
thread
nullptr
)
;
#
endif
MergeStacksIntoProfile
(
aLock
aBuffer
aSample
nativeStack
)
;
}
#
endif
#
ifdef
USE_EHABI_STACKWALK
static
void
DoNativeBacktrace
(
PSLockRef
aLock
ProfileBuffer
*
aBuffer
const
TickSample
&
aSample
)
{
void
*
pc_array
[
1000
]
;
void
*
sp_array
[
1000
]
;
NativeStack
nativeStack
=
{
pc_array
sp_array
mozilla
:
:
ArrayLength
(
pc_array
)
0
}
;
const
mcontext_t
*
mcontext
=
&
aSample
.
mContext
-
>
uc_mcontext
;
mcontext_t
savedContext
;
NotNull
<
RacyThreadInfo
*
>
racyInfo
=
aSample
.
mRacyInfo
;
for
(
uint32_t
i
=
racyInfo
-
>
stackSize
(
)
;
i
>
0
;
-
-
i
)
{
volatile
js
:
:
ProfileEntry
&
entry
=
racyInfo
-
>
mStack
[
i
-
1
]
;
if
(
!
entry
.
isJs
(
)
&
&
strcmp
(
entry
.
label
(
)
"
EnterJIT
"
)
=
=
0
)
{
uint32_t
*
vSP
=
reinterpret_cast
<
uint32_t
*
>
(
entry
.
stackAddress
(
)
)
;
nativeStack
.
count
+
=
EHABIStackWalk
(
*
mcontext
vSP
sp_array
+
nativeStack
.
count
pc_array
+
nativeStack
.
count
nativeStack
.
size
-
nativeStack
.
count
)
;
memset
(
&
savedContext
0
sizeof
(
savedContext
)
)
;
savedContext
.
arm_r4
=
*
vSP
+
+
;
savedContext
.
arm_r5
=
*
vSP
+
+
;
savedContext
.
arm_r6
=
*
vSP
+
+
;
savedContext
.
arm_r7
=
*
vSP
+
+
;
savedContext
.
arm_r8
=
*
vSP
+
+
;
savedContext
.
arm_r9
=
*
vSP
+
+
;
savedContext
.
arm_r10
=
*
vSP
+
+
;
savedContext
.
arm_fp
=
*
vSP
+
+
;
savedContext
.
arm_lr
=
*
vSP
+
+
;
savedContext
.
arm_sp
=
reinterpret_cast
<
uint32_t
>
(
vSP
)
;
savedContext
.
arm_pc
=
savedContext
.
arm_lr
;
mcontext
=
&
savedContext
;
}
}
nativeStack
.
count
+
=
EHABIStackWalk
(
*
mcontext
aSample
.
mStackTop
sp_array
+
nativeStack
.
count
pc_array
+
nativeStack
.
count
nativeStack
.
size
-
nativeStack
.
count
)
;
MergeStacksIntoProfile
(
aLock
aBuffer
aSample
nativeStack
)
;
}
#
endif
#
ifdef
USE_LUL_STACKWALK
#
if
defined
(
MOZ_HAVE_ASAN_BLACKLIST
)
MOZ_ASAN_BLACKLIST
static
void
ASAN_memcpy
(
void
*
aDst
const
void
*
aSrc
size_t
aLen
)
{
char
*
dst
=
static_cast
<
char
*
>
(
aDst
)
;
const
char
*
src
=
static_cast
<
const
char
*
>
(
aSrc
)
;
for
(
size_t
i
=
0
;
i
<
aLen
;
i
+
+
)
{
dst
[
i
]
=
src
[
i
]
;
}
}
#
endif
static
void
DoNativeBacktrace
(
PSLockRef
aLock
ProfileBuffer
*
aBuffer
const
TickSample
&
aSample
)
{
const
mcontext_t
*
mc
=
&
aSample
.
mContext
-
>
uc_mcontext
;
lul
:
:
UnwindRegs
startRegs
;
memset
(
&
startRegs
0
sizeof
(
startRegs
)
)
;
#
if
defined
(
GP_PLAT_amd64_linux
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RSP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RBP
]
)
;
#
elif
defined
(
GP_PLAT_arm_android
)
startRegs
.
r15
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_pc
)
;
startRegs
.
r14
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_lr
)
;
startRegs
.
r13
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_sp
)
;
startRegs
.
r12
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_ip
)
;
startRegs
.
r11
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_fp
)
;
startRegs
.
r7
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_r7
)
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_ESP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EBP
]
)
;
#
else
#
error
"
Unknown
plat
"
#
endif
lul
:
:
StackImage
stackImg
;
{
#
if
defined
(
GP_PLAT_amd64_linux
)
uintptr_t
rEDZONE_SIZE
=
128
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_arm_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
r13
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
else
#
error
"
Unknown
plat
"
#
endif
uintptr_t
end
=
reinterpret_cast
<
uintptr_t
>
(
aSample
.
mStackTop
)
;
uintptr_t
ws
=
sizeof
(
void
*
)
;
start
&
=
~
(
ws
-
1
)
;
end
&
=
~
(
ws
-
1
)
;
uintptr_t
nToCopy
=
0
;
if
(
start
<
end
)
{
nToCopy
=
end
-
start
;
if
(
nToCopy
>
lul
:
:
N_STACK_BYTES
)
nToCopy
=
lul
:
:
N_STACK_BYTES
;
}
MOZ_ASSERT
(
nToCopy
<
=
lul
:
:
N_STACK_BYTES
)
;
stackImg
.
mLen
=
nToCopy
;
stackImg
.
mStartAvma
=
start
;
if
(
nToCopy
>
0
)
{
#
if
defined
(
MOZ_HAVE_ASAN_BLACKLIST
)
ASAN_memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
#
else
memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
#
endif
(
void
)
VALGRIND_MAKE_MEM_DEFINED
(
&
stackImg
.
mContents
[
0
]
nToCopy
)
;
}
}
const
int
MAX_NATIVE_FRAMES
=
256
;
size_t
scannedFramesAllowed
=
0
;
uintptr_t
framePCs
[
MAX_NATIVE_FRAMES
]
;
uintptr_t
frameSPs
[
MAX_NATIVE_FRAMES
]
;
size_t
framesAvail
=
mozilla
:
:
ArrayLength
(
framePCs
)
;
size_t
framesUsed
=
0
;
size_t
scannedFramesAcquired
=
0
framePointerFramesAcquired
=
0
;
lul
:
:
LUL
*
lul
=
CorePS
:
:
Lul
(
aLock
)
;
lul
-
>
Unwind
(
&
framePCs
[
0
]
&
frameSPs
[
0
]
&
framesUsed
&
framePointerFramesAcquired
&
scannedFramesAcquired
framesAvail
scannedFramesAllowed
&
startRegs
&
stackImg
)
;
NativeStack
nativeStack
=
{
reinterpret_cast
<
void
*
*
>
(
framePCs
)
reinterpret_cast
<
void
*
*
>
(
frameSPs
)
mozilla
:
:
ArrayLength
(
framePCs
)
framesUsed
}
;
MergeStacksIntoProfile
(
aLock
aBuffer
aSample
nativeStack
)
;
lul
-
>
mStats
.
mContext
+
=
1
;
lul
-
>
mStats
.
mCFI
+
=
framesUsed
-
1
-
framePointerFramesAcquired
-
scannedFramesAcquired
;
lul
-
>
mStats
.
mFP
+
=
framePointerFramesAcquired
;
lul
-
>
mStats
.
mScanned
+
=
scannedFramesAcquired
;
}
#
endif
static
void
DoSampleStackTrace
(
PSLockRef
aLock
ProfileBuffer
*
aBuffer
const
TickSample
&
aSample
)
{
NativeStack
nativeStack
=
{
nullptr
nullptr
0
0
}
;
MergeStacksIntoProfile
(
aLock
aBuffer
aSample
nativeStack
)
;
if
(
ActivePS
:
:
FeatureLeaf
(
aLock
)
)
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
NativeLeafAddr
(
(
void
*
)
aSample
.
mPC
)
)
;
}
}
static
void
Tick
(
PSLockRef
aLock
ProfileBuffer
*
aBuffer
const
TickSample
&
aSample
)
{
aBuffer
-
>
addTagThreadId
(
aSample
.
mThreadId
aSample
.
mLastSample
)
;
mozilla
:
:
TimeDuration
delta
=
aSample
.
mTimeStamp
-
CorePS
:
:
ProcessStartTime
(
aLock
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Time
(
delta
.
ToMilliseconds
(
)
)
)
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
if
(
ActivePS
:
:
FeatureStackWalk
(
aLock
)
)
{
DoNativeBacktrace
(
aLock
aBuffer
aSample
)
;
}
else
#
endif
{
DoSampleStackTrace
(
aLock
aBuffer
aSample
)
;
}
if
(
!
aSample
.
mIsSynchronous
)
{
ProfilerMarkerLinkedList
*
pendingMarkersList
=
aSample
.
mRacyInfo
-
>
GetPendingMarkers
(
)
;
while
(
pendingMarkersList
&
&
pendingMarkersList
-
>
peek
(
)
)
{
ProfilerMarker
*
marker
=
pendingMarkersList
-
>
popHead
(
)
;
aBuffer
-
>
addStoredMarker
(
marker
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Marker
(
marker
)
)
;
}
}
if
(
aSample
.
mResponsiveness
&
&
aSample
.
mResponsiveness
-
>
HasData
(
)
)
{
mozilla
:
:
TimeDuration
delta
=
aSample
.
mResponsiveness
-
>
GetUnresponsiveDuration
(
aSample
.
mTimeStamp
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Responsiveness
(
delta
.
ToMilliseconds
(
)
)
)
;
}
if
(
aSample
.
mRSSMemory
!
=
0
)
{
double
rssMemory
=
static_cast
<
double
>
(
aSample
.
mRSSMemory
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
ResidentMemory
(
rssMemory
)
)
;
}
if
(
aSample
.
mUSSMemory
!
=
0
)
{
double
ussMemory
=
static_cast
<
double
>
(
aSample
.
mUSSMemory
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
UnsharedMemory
(
ussMemory
)
)
;
}
}
const
static
uint64_t
kJS_MAX_SAFE_UINTEGER
=
+
9007199254740991ULL
;
static
int64_t
SafeJSInteger
(
uint64_t
aValue
)
{
return
aValue
<
=
kJS_MAX_SAFE_UINTEGER
?
int64_t
(
aValue
)
:
-
1
;
}
static
void
AddSharedLibraryInfoToStream
(
JSONWriter
&
aWriter
const
SharedLibrary
&
aLib
)
{
aWriter
.
StartObjectElement
(
)
;
aWriter
.
IntProperty
(
"
start
"
SafeJSInteger
(
aLib
.
GetStart
(
)
)
)
;
aWriter
.
IntProperty
(
"
end
"
SafeJSInteger
(
aLib
.
GetEnd
(
)
)
)
;
aWriter
.
IntProperty
(
"
offset
"
SafeJSInteger
(
aLib
.
GetOffset
(
)
)
)
;
aWriter
.
StringProperty
(
"
name
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetModuleName
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
path
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetModulePath
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
debugName
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetDebugName
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
debugPath
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetDebugPath
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
breakpadId
"
aLib
.
GetBreakpadId
(
)
.
c_str
(
)
)
;
aWriter
.
StringProperty
(
"
arch
"
aLib
.
GetArch
(
)
.
c_str
(
)
)
;
aWriter
.
EndObject
(
)
;
}
void
AppendSharedLibraries
(
JSONWriter
&
aWriter
)
{
SharedLibraryInfo
info
=
SharedLibraryInfo
:
:
GetInfoForSelf
(
)
;
info
.
SortByAddress
(
)
;
for
(
size_t
i
=
0
;
i
<
info
.
GetSize
(
)
;
i
+
+
)
{
AddSharedLibraryInfoToStream
(
aWriter
info
.
GetEntry
(
i
)
)
;
}
}
#
ifdef
MOZ_TASK_TRACER
static
void
StreamNameAndThreadId
(
JSONWriter
&
aWriter
const
char
*
aName
int
aThreadId
)
{
aWriter
.
StartObjectElement
(
)
;
{
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Plugin
)
{
aWriter
.
StringProperty
(
"
name
"
"
Plugin
"
)
;
}
else
{
aWriter
.
StringProperty
(
"
name
"
aName
)
;
}
aWriter
.
IntProperty
(
"
tid
"
aThreadId
)
;
}
aWriter
.
EndObject
(
)
;
}
#
endif
static
void
StreamTaskTracer
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
#
ifdef
MOZ_TASK_TRACER
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
aWriter
.
StartArrayProperty
(
"
data
"
)
;
{
UniquePtr
<
nsTArray
<
nsCString
>
>
data
=
mozilla
:
:
tasktracer
:
:
GetLoggedData
(
CorePS
:
:
ProcessStartTime
(
aLock
)
)
;
for
(
uint32_t
i
=
0
;
i
<
data
-
>
Length
(
)
;
+
+
i
)
{
aWriter
.
StringElement
(
(
data
-
>
ElementAt
(
i
)
)
.
get
(
)
)
;
}
}
aWriter
.
EndArray
(
)
;
aWriter
.
StartArrayProperty
(
"
threads
"
)
;
{
const
CorePS
:
:
ThreadVector
&
liveThreads
=
CorePS
:
:
LiveThreads
(
aLock
)
;
for
(
size_t
i
=
0
;
i
<
liveThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
liveThreads
.
at
(
i
)
;
StreamNameAndThreadId
(
aWriter
info
-
>
Name
(
)
info
-
>
ThreadId
(
)
)
;
}
const
CorePS
:
:
ThreadVector
&
deadThreads
=
CorePS
:
:
DeadThreads
(
aLock
)
;
for
(
size_t
i
=
0
;
i
<
deadThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
deadThreads
.
at
(
i
)
;
StreamNameAndThreadId
(
aWriter
info
-
>
Name
(
)
info
-
>
ThreadId
(
)
)
;
}
}
aWriter
.
EndArray
(
)
;
aWriter
.
DoubleProperty
(
"
start
"
static_cast
<
double
>
(
mozilla
:
:
tasktracer
:
:
GetStartTime
(
)
)
)
;
#
endif
}
static
void
StreamMetaJSCustomObject
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
aWriter
.
IntProperty
(
"
version
"
6
)
;
mozilla
:
:
TimeDuration
delta
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
-
CorePS
:
:
ProcessStartTime
(
aLock
)
;
aWriter
.
DoubleProperty
(
"
startTime
"
static_cast
<
double
>
(
PR_Now
(
)
/
1000
.
0
-
delta
.
ToMilliseconds
(
)
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
aWriter
.
DoubleProperty
(
"
interval
"
ActivePS
:
:
Interval
(
aLock
)
)
;
aWriter
.
IntProperty
(
"
stackwalk
"
ActivePS
:
:
FeatureStackWalk
(
aLock
)
)
;
#
ifdef
DEBUG
aWriter
.
IntProperty
(
"
debug
"
1
)
;
#
else
aWriter
.
IntProperty
(
"
debug
"
0
)
;
#
endif
aWriter
.
IntProperty
(
"
gcpoison
"
JS
:
:
IsGCPoisoning
(
)
?
1
:
0
)
;
bool
asyncStacks
=
Preferences
:
:
GetBool
(
"
javascript
.
options
.
asyncstack
"
)
;
aWriter
.
IntProperty
(
"
asyncstack
"
asyncStacks
)
;
aWriter
.
IntProperty
(
"
processType
"
XRE_GetProcessType
(
)
)
;
nsresult
res
;
nsCOMPtr
<
nsIHttpProtocolHandler
>
http
=
do_GetService
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
"
http
"
&
res
)
;
if
(
!
NS_FAILED
(
res
)
)
{
nsAutoCString
string
;
res
=
http
-
>
GetPlatform
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
platform
"
string
.
Data
(
)
)
;
}
res
=
http
-
>
GetOscpu
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
oscpu
"
string
.
Data
(
)
)
;
}
res
=
http
-
>
GetMisc
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
misc
"
string
.
Data
(
)
)
;
}
}
nsCOMPtr
<
nsIXULRuntime
>
runtime
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
runtime
)
{
nsAutoCString
string
;
res
=
runtime
-
>
GetXPCOMABI
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
abi
"
string
.
Data
(
)
)
;
res
=
runtime
-
>
GetWidgetToolkit
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
toolkit
"
string
.
Data
(
)
)
;
}
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
)
;
if
(
appInfo
)
{
nsAutoCString
string
;
res
=
appInfo
-
>
GetName
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
product
"
string
.
Data
(
)
)
;
}
}
#
if
defined
(
GP_OS_android
)
static
void
BuildJavaThreadJSObject
(
SpliceableJSONWriter
&
aWriter
)
{
aWriter
.
StringProperty
(
"
name
"
"
Java
Main
Thread
"
)
;
aWriter
.
StartArrayProperty
(
"
samples
"
)
;
{
for
(
int
sampleId
=
0
;
true
;
sampleId
+
+
)
{
bool
firstRun
=
true
;
for
(
int
frameId
=
0
;
true
;
frameId
+
+
)
{
jni
:
:
String
:
:
LocalRef
frameName
=
java
:
:
GeckoJavaSampler
:
:
GetFrameName
(
0
sampleId
frameId
)
;
if
(
!
frameName
)
{
if
(
!
firstRun
)
{
aWriter
.
EndArray
(
)
;
aWriter
.
EndObject
(
)
;
}
break
;
}
if
(
firstRun
)
{
firstRun
=
false
;
double
sampleTime
=
java
:
:
GeckoJavaSampler
:
:
GetSampleTime
(
0
sampleId
)
;
aWriter
.
StartObjectElement
(
)
;
aWriter
.
DoubleProperty
(
"
time
"
sampleTime
)
;
aWriter
.
StartArrayProperty
(
"
frames
"
)
;
}
aWriter
.
StartObjectElement
(
)
;
{
aWriter
.
StringProperty
(
"
location
"
frameName
-
>
ToCString
(
)
.
BeginReading
(
)
)
;
}
aWriter
.
EndObject
(
)
;
}
if
(
firstRun
)
{
break
;
}
}
}
aWriter
.
EndArray
(
)
;
}
#
endif
static
void
locked_profiler_stream_json_for_this_process
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
double
aSinceTime
)
{
LOG
(
"
locked_profiler_stream_json_for_this_process
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
aWriter
.
StartArrayProperty
(
"
libs
"
)
;
AppendSharedLibraries
(
aWriter
)
;
aWriter
.
EndArray
(
)
;
aWriter
.
StartObjectProperty
(
"
meta
"
)
;
{
StreamMetaJSCustomObject
(
aLock
aWriter
)
;
}
aWriter
.
EndObject
(
)
;
if
(
ActivePS
:
:
FeatureTaskTracer
(
aLock
)
)
{
aWriter
.
StartObjectProperty
(
"
tasktracer
"
)
;
StreamTaskTracer
(
aLock
aWriter
)
;
aWriter
.
EndObject
(
)
;
}
aWriter
.
StartArrayProperty
(
"
threads
"
)
;
{
const
CorePS
:
:
ThreadVector
&
liveThreads
=
CorePS
:
:
LiveThreads
(
aLock
)
;
for
(
size_t
i
=
0
;
i
<
liveThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
liveThreads
.
at
(
i
)
;
if
(
!
info
-
>
IsBeingProfiled
(
)
)
{
continue
;
}
info
-
>
StreamJSON
(
ActivePS
:
:
Buffer
(
aLock
)
aWriter
CorePS
:
:
ProcessStartTime
(
aLock
)
aSinceTime
)
;
}
const
CorePS
:
:
ThreadVector
&
deadThreads
=
CorePS
:
:
DeadThreads
(
aLock
)
;
for
(
size_t
i
=
0
;
i
<
deadThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
deadThreads
.
at
(
i
)
;
MOZ_ASSERT
(
info
-
>
IsBeingProfiled
(
)
)
;
info
-
>
StreamJSON
(
ActivePS
:
:
Buffer
(
aLock
)
aWriter
CorePS
:
:
ProcessStartTime
(
aLock
)
aSinceTime
)
;
}
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
java
:
:
GeckoJavaSampler
:
:
Pause
(
)
;
aWriter
.
Start
(
)
;
{
BuildJavaThreadJSObject
(
aWriter
)
;
}
aWriter
.
End
(
)
;
java
:
:
GeckoJavaSampler
:
:
Unpause
(
)
;
}
#
endif
}
aWriter
.
EndArray
(
)
;
}
bool
profiler_stream_json_for_this_process
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
)
{
LOG
(
"
profiler_stream_json_for_this_process
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
locked_profiler_stream_json_for_this_process
(
lock
aWriter
aSinceTime
)
;
return
true
;
}
static
void
PrintUsageThenExit
(
int
aExitCode
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
printf
(
"
\
n
"
"
Profiler
environment
variable
usage
:
\
n
"
"
\
n
"
"
MOZ_PROFILER_HELP
\
n
"
"
If
set
to
any
value
prints
this
message
.
\
n
"
"
\
n
"
"
MOZ_LOG
\
n
"
"
Enables
logging
.
The
levels
of
logging
available
are
\
n
"
"
'
prof
:
3
'
(
least
verbose
)
'
prof
:
4
'
'
prof
:
5
'
(
most
verbose
)
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP
\
n
"
"
If
set
to
any
value
starts
the
profiler
immediately
on
start
-
up
.
\
n
"
"
Useful
if
you
want
profile
code
that
runs
very
early
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_ENTRIES
=
<
1
.
.
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
number
of
entries
in
\
n
"
"
the
profiler
'
s
circular
buffer
when
the
profiler
is
first
started
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_INTERVAL
=
<
1
.
.
1000
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
sample
interval
\
n
"
"
measured
in
milliseconds
when
the
profiler
is
first
started
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_SHUTDOWN
\
n
"
"
If
set
the
profiler
saves
a
profile
to
the
named
file
on
shutdown
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_LUL_TEST
\
n
"
"
If
set
to
any
value
runs
LUL
unit
tests
at
startup
.
\
n
"
"
\
n
"
"
This
platform
%
s
native
unwinding
.
\
n
"
"
\
n
"
#
if
defined
(
HAVE_NATIVE_UNWIND
)
"
supports
"
#
else
"
does
not
support
"
#
endif
)
;
exit
(
aExitCode
)
;
}
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
struct
SigHandlerCoordinator
;
#
endif
class
SamplerThread
{
public
:
SamplerThread
(
PSLockRef
aLock
uint32_t
aActivityGeneration
double
aIntervalMilliseconds
)
;
~
SamplerThread
(
)
;
void
SuspendAndSampleAndResumeThread
(
PSLockRef
aLock
TickSample
&
aSample
)
;
void
Run
(
)
;
void
Stop
(
PSLockRef
aLock
)
;
private
:
void
SleepMicro
(
uint32_t
aMicroseconds
)
;
const
uint32_t
mActivityGeneration
;
const
int
mIntervalMicroseconds
;
#
if
defined
(
GP_OS_windows
)
HANDLE
mThread
;
#
elif
defined
(
GP_OS_darwin
)
|
|
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
pthread_t
mThread
;
#
endif
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
struct
sigaction
mOldSigprofHandler
;
int
mMyPid
;
public
:
int
mSamplerTid
;
static
struct
SigHandlerCoordinator
*
sSigHandlerCoordinator
;
#
endif
private
:
SamplerThread
(
const
SamplerThread
&
)
=
delete
;
void
operator
=
(
const
SamplerThread
&
)
=
delete
;
}
;
static
SamplerThread
*
NewSamplerThread
(
PSLockRef
aLock
uint32_t
aGeneration
double
aInterval
)
{
return
new
SamplerThread
(
aLock
aGeneration
aInterval
)
;
}
void
SamplerThread
:
:
Run
(
)
{
PR_SetCurrentThreadName
(
"
SamplerThread
"
)
;
TimeDuration
lastSleepOvershoot
=
0
;
TimeStamp
sampleStart
=
TimeStamp
:
:
Now
(
)
;
while
(
true
)
{
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
if
(
ActivePS
:
:
Generation
(
lock
)
!
=
mActivityGeneration
)
{
return
;
}
ActivePS
:
:
Buffer
(
lock
)
-
>
deleteExpiredStoredMarkers
(
)
;
if
(
!
ActivePS
:
:
IsPaused
(
lock
)
)
{
const
CorePS
:
:
ThreadVector
&
liveThreads
=
CorePS
:
:
LiveThreads
(
lock
)
;
for
(
uint32_t
i
=
0
;
i
<
liveThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
liveThreads
.
at
(
i
)
;
if
(
!
info
-
>
IsBeingProfiled
(
)
)
{
continue
;
}
if
(
info
-
>
RacyInfo
(
)
-
>
CanDuplicateLastSampleDueToSleep
(
)
)
{
bool
dup_ok
=
ActivePS
:
:
Buffer
(
lock
)
-
>
DuplicateLastSample
(
info
-
>
ThreadId
(
)
CorePS
:
:
ProcessStartTime
(
lock
)
info
-
>
LastSample
(
)
)
;
if
(
dup_ok
)
{
continue
;
}
}
if
(
info
-
>
IsMainThread
(
)
)
{
info
-
>
GetThreadResponsiveness
(
)
-
>
Update
(
)
;
}
int64_t
rssMemory
=
0
;
int64_t
ussMemory
=
0
;
if
(
i
=
=
0
&
&
ActivePS
:
:
FeatureMemory
(
lock
)
)
{
rssMemory
=
nsMemoryReporterManager
:
:
ResidentFast
(
)
;
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
ussMemory
=
nsMemoryReporterManager
:
:
ResidentUnique
(
)
;
#
endif
}
TickSample
sample
(
info
rssMemory
ussMemory
)
;
SuspendAndSampleAndResumeThread
(
lock
sample
)
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
CorePS
:
:
Lul
(
lock
)
-
>
MaybeShowStats
(
)
;
#
endif
}
}
TimeStamp
targetSleepEndTime
=
sampleStart
+
TimeDuration
:
:
FromMicroseconds
(
mIntervalMicroseconds
)
;
TimeStamp
beforeSleep
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
targetSleepDuration
=
targetSleepEndTime
-
beforeSleep
;
double
sleepTime
=
std
:
:
max
(
0
.
0
(
targetSleepDuration
-
lastSleepOvershoot
)
.
ToMicroseconds
(
)
)
;
SleepMicro
(
static_cast
<
uint32_t
>
(
sleepTime
)
)
;
sampleStart
=
TimeStamp
:
:
Now
(
)
;
lastSleepOvershoot
=
sampleStart
-
(
beforeSleep
+
TimeDuration
:
:
FromMicroseconds
(
sleepTime
)
)
;
}
}
#
if
defined
(
GP_OS_windows
)
#
include
"
platform
-
win32
.
cpp
"
#
elif
defined
(
GP_OS_darwin
)
#
include
"
platform
-
macos
.
cpp
"
#
elif
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
#
include
"
platform
-
linux
-
android
.
cpp
"
#
else
#
error
"
bad
platform
"
#
endif
UniquePlatformData
AllocPlatformData
(
int
aThreadId
)
{
return
UniquePlatformData
(
new
PlatformData
(
aThreadId
)
)
;
}
void
PlatformDataDestructor
:
:
operator
(
)
(
PlatformData
*
aData
)
{
delete
aData
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
GeckoProfilerMallocSizeOf
)
NS_IMETHODIMP
GeckoProfilerReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
size_t
profSize
=
0
;
size_t
lulSize
=
0
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
CorePS
:
:
Exists
(
)
)
{
CorePS
:
:
AddSizeOf
(
lock
GeckoProfilerMallocSizeOf
profSize
lulSize
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
profSize
+
=
ActivePS
:
:
SizeOf
(
lock
GeckoProfilerMallocSizeOf
)
;
}
}
MOZ_COLLECT_REPORT
(
"
explicit
/
profiler
/
profiler
-
state
"
KIND_HEAP
UNITS_BYTES
profSize
"
Memory
used
by
the
Gecko
Profiler
'
s
global
state
(
excluding
memory
used
"
"
by
LUL
)
.
"
)
;
#
if
defined
(
USE_LUL_STACKWALK
)
MOZ_COLLECT_REPORT
(
"
explicit
/
profiler
/
lul
"
KIND_HEAP
UNITS_BYTES
lulSize
"
Memory
used
by
LUL
a
stack
unwinder
used
by
the
Gecko
Profiler
.
"
)
;
#
endif
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
GeckoProfilerReporter
nsIMemoryReporter
)
static
ThreadInfo
*
FindLiveThreadInfo
(
PSLockRef
aLock
int
*
aIndexOut
=
nullptr
)
{
ThreadInfo
*
ret
=
nullptr
;
Thread
:
:
tid_t
id
=
Thread
:
:
GetCurrentId
(
)
;
const
CorePS
:
:
ThreadVector
&
liveThreads
=
CorePS
:
:
LiveThreads
(
aLock
)
;
for
(
uint32_t
i
=
0
;
i
<
liveThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
liveThreads
.
at
(
i
)
;
if
(
info
-
>
ThreadId
(
)
=
=
id
)
{
if
(
aIndexOut
)
{
*
aIndexOut
=
i
;
}
ret
=
info
;
break
;
}
}
return
ret
;
}
static
void
locked_register_thread
(
PSLockRef
aLock
const
char
*
aName
void
*
stackTop
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
FindLiveThreadInfo
(
aLock
)
)
;
if
(
!
TLSInfo
:
:
Init
(
aLock
)
)
{
return
;
}
ThreadInfo
*
info
=
new
ThreadInfo
(
aName
Thread
:
:
GetCurrentId
(
)
NS_IsMainThread
(
)
stackTop
)
;
TLSInfo
:
:
SetInfo
(
aLock
info
)
;
if
(
ActivePS
:
:
Exists
(
aLock
)
&
&
ActivePS
:
:
ShouldProfileThread
(
aLock
info
)
)
{
info
-
>
StartProfiling
(
)
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
info
-
>
StartJSSampling
(
)
;
info
-
>
PollJSSampling
(
)
;
}
}
CorePS
:
:
LiveThreads
(
aLock
)
.
push_back
(
info
)
;
}
static
void
NotifyObservers
(
const
char
*
aTopic
nsISupports
*
aSubject
=
nullptr
)
{
if
(
!
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsISupports
>
subject
=
aSubject
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
[
=
]
{
NotifyObservers
(
aTopic
subject
)
;
}
)
)
;
return
;
}
if
(
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
)
{
os
-
>
NotifyObservers
(
aSubject
aTopic
nullptr
)
;
}
}
static
void
NotifyProfilerStarted
(
const
int
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
{
nsTArray
<
nsCString
>
filtersArray
;
for
(
size_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
filtersArray
.
AppendElement
(
aFilters
[
i
]
)
;
}
nsCOMPtr
<
nsIProfilerStartParams
>
params
=
new
nsProfilerStartParams
(
aEntries
aInterval
aFeatures
filtersArray
)
;
NotifyObservers
(
"
profiler
-
started
"
params
)
;
}
static
void
locked_profiler_start
(
PSLockRef
aLock
const
int
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
;
void
profiler_init
(
void
*
aStackTop
)
{
LOG
(
"
profiler_init
"
)
;
MOZ_RELEASE_ASSERT
(
!
CorePS
:
:
Exists
(
)
)
;
uint32_t
features
=
#
if
defined
(
GP_OS_android
)
ProfilerFeature
:
:
Java
|
#
endif
ProfilerFeature
:
:
JS
|
ProfilerFeature
:
:
Leaf
|
#
if
defined
(
HAVE_NATIVE_UNWIND
)
ProfilerFeature
:
:
StackWalk
|
#
endif
ProfilerFeature
:
:
Threads
|
0
;
const
char
*
filters
[
]
=
{
"
GeckoMain
"
"
Compositor
"
}
;
if
(
getenv
(
"
MOZ_PROFILER_HELP
"
)
)
{
PrintUsageThenExit
(
0
)
;
}
{
PSAutoLock
lock
(
gPSMutex
)
;
CorePS
:
:
Create
(
lock
)
;
locked_register_thread
(
lock
kMainThreadName
aStackTop
)
;
PlatformInit
(
lock
)
;
#
ifdef
MOZ_TASK_TRACER
mozilla
:
:
tasktracer
:
:
InitTaskTracer
(
)
;
#
endif
#
if
defined
(
GP_OS_android
)
if
(
mozilla
:
:
jni
:
:
IsFennec
(
)
)
{
GeckoJavaSampler
:
:
Init
(
)
;
}
#
endif
if
(
!
getenv
(
"
MOZ_PROFILER_STARTUP
"
)
)
{
return
;
}
LOG
(
"
-
MOZ_PROFILER_STARTUP
is
set
"
)
;
int
entries
=
PROFILER_DEFAULT_ENTRIES
;
const
char
*
startupEntries
=
getenv
(
"
MOZ_PROFILER_STARTUP_ENTRIES
"
)
;
if
(
startupEntries
)
{
errno
=
0
;
entries
=
strtol
(
startupEntries
nullptr
10
)
;
if
(
errno
=
=
0
&
&
entries
>
0
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_ENTRIES
=
%
d
"
entries
)
;
}
else
{
PrintUsageThenExit
(
1
)
;
}
}
double
interval
=
PROFILER_DEFAULT_INTERVAL
;
const
char
*
startupInterval
=
getenv
(
"
MOZ_PROFILER_STARTUP_INTERVAL
"
)
;
if
(
startupInterval
)
{
errno
=
0
;
interval
=
PR_strtod
(
startupInterval
nullptr
)
;
if
(
errno
=
=
0
&
&
interval
>
0
.
0
&
&
interval
<
=
1000
.
0
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_INTERVAL
=
%
f
"
interval
)
;
}
else
{
PrintUsageThenExit
(
1
)
;
}
}
locked_profiler_start
(
lock
entries
interval
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
}
NotifyProfilerStarted
(
PROFILER_DEFAULT_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
)
;
}
static
void
locked_profiler_save_profile_to_file
(
PSLockRef
aLock
const
char
*
aFilename
)
;
static
SamplerThread
*
locked_profiler_stop
(
PSLockRef
aLock
)
;
void
profiler_shutdown
(
)
{
LOG
(
"
profiler_shutdown
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
const
char
*
filename
=
getenv
(
"
MOZ_PROFILER_SHUTDOWN
"
)
;
if
(
filename
)
{
locked_profiler_save_profile_to_file
(
lock
filename
)
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
CorePS
:
:
Destroy
(
lock
)
;
TLSInfo
:
:
SetInfo
(
lock
nullptr
)
;
#
ifdef
MOZ_TASK_TRACER
mozilla
:
:
tasktracer
:
:
ShutdownTaskTracer
(
)
;
#
endif
}
if
(
samplerThread
)
{
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
}
UniquePtr
<
char
[
]
>
profiler_get_profile
(
double
aSinceTime
)
{
LOG
(
"
profiler_get_profile
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
SpliceableChunkedJSONWriter
b
;
b
.
Start
(
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
{
if
(
!
profiler_stream_json_for_this_process
(
b
aSinceTime
)
)
{
return
nullptr
;
}
b
.
StartArrayProperty
(
"
processes
"
)
;
b
.
EndArray
(
)
;
}
b
.
End
(
)
;
return
b
.
WriteFunc
(
)
-
>
CopyData
(
)
;
}
void
profiler_get_start_params
(
int
*
aEntries
double
*
aInterval
uint32_t
*
aFeatures
mozilla
:
:
Vector
<
const
char
*
>
*
aFilters
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
NS_WARN_IF
(
!
aEntries
)
|
|
NS_WARN_IF
(
!
aInterval
)
|
|
NS_WARN_IF
(
!
aFeatures
)
|
|
NS_WARN_IF
(
!
aFilters
)
)
{
return
;
}
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
*
aEntries
=
0
;
*
aInterval
=
0
;
*
aFeatures
=
0
;
aFilters
-
>
clear
(
)
;
return
;
}
*
aEntries
=
ActivePS
:
:
Entries
(
lock
)
;
*
aInterval
=
ActivePS
:
:
Interval
(
lock
)
;
*
aFeatures
=
ActivePS
:
:
Features
(
lock
)
;
const
Vector
<
std
:
:
string
>
&
filters
=
ActivePS
:
:
Filters
(
lock
)
;
MOZ_ALWAYS_TRUE
(
aFilters
-
>
resize
(
filters
.
length
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
filters
.
length
(
)
;
+
+
i
)
{
(
*
aFilters
)
[
i
]
=
filters
[
i
]
.
c_str
(
)
;
}
}
static
void
locked_profiler_save_profile_to_file
(
PSLockRef
aLock
const
char
*
aFilename
)
{
LOG
(
"
locked_profiler_save_profile_to_file
(
%
s
)
"
aFilename
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
std
:
:
ofstream
stream
;
stream
.
open
(
aFilename
)
;
if
(
stream
.
is_open
(
)
)
{
SpliceableJSONWriter
w
(
mozilla
:
:
MakeUnique
<
OStreamJSONWriteFunc
>
(
stream
)
)
;
w
.
Start
(
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
{
locked_profiler_stream_json_for_this_process
(
aLock
w
0
)
;
w
.
StartArrayProperty
(
"
processes
"
)
;
w
.
EndArray
(
)
;
}
w
.
End
(
)
;
stream
.
close
(
)
;
}
}
void
profiler_save_profile_to_file
(
const
char
*
aFilename
)
{
LOG
(
"
profiler_save_profile_to_file
(
%
s
)
"
aFilename
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
locked_profiler_save_profile_to_file
(
lock
aFilename
)
;
}
uint32_t
profiler_get_available_features
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
uint32_t
features
=
0
;
#
define
ADD_FEATURE
(
n_
str_
Name_
)
ProfilerFeature
:
:
Set
#
#
Name_
(
features
)
;
PROFILER_FOR_EACH_FEATURE
(
ADD_FEATURE
)
#
undef
ADD_FEATURE
#
if
!
defined
(
GP_OS_android
)
ProfilerFeature
:
:
ClearJava
(
features
)
;
#
endif
#
if
!
defined
(
HAVE_NATIVE_UNWIND
)
ProfilerFeature
:
:
ClearStackWalk
(
features
)
;
#
endif
#
if
!
defined
(
MOZ_TASK_TRACER
)
ProfilerFeature
:
:
ClearTaskTracer
(
features
)
;
#
endif
return
features
;
}
void
profiler_get_buffer_info_helper
(
uint32_t
*
aCurrentPosition
uint32_t
*
aEntries
uint32_t
*
aGeneration
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
*
aCurrentPosition
=
ActivePS
:
:
Buffer
(
lock
)
-
>
mWritePos
;
*
aEntries
=
ActivePS
:
:
Entries
(
lock
)
;
*
aGeneration
=
ActivePS
:
:
Buffer
(
lock
)
-
>
mGeneration
;
}
static
void
locked_profiler_start
(
PSLockRef
aLock
int
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
{
if
(
LOG_TEST
)
{
LOG
(
"
locked_profiler_start
"
)
;
LOG
(
"
-
entries
=
%
d
"
aEntries
)
;
LOG
(
"
-
interval
=
%
.
2f
"
aInterval
)
;
#
define
LOG_FEATURE
(
n_
str_
Name_
)
\
if
(
ProfilerFeature
:
:
Has
#
#
Name_
(
aFeatures
)
)
{
\
LOG
(
"
-
feature
=
%
s
"
str_
)
;
\
}
PROFILER_FOR_EACH_FEATURE
(
LOG_FEATURE
)
#
undef
LOG_FEATURE
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
i
+
+
)
{
LOG
(
"
-
threads
=
%
s
"
aFilters
[
i
]
)
;
}
}
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
!
ActivePS
:
:
Exists
(
aLock
)
)
;
int
entries
=
aEntries
>
0
?
aEntries
:
PROFILER_DEFAULT_ENTRIES
;
double
interval
=
aInterval
>
0
?
aInterval
:
PROFILER_DEFAULT_INTERVAL
;
ActivePS
:
:
Create
(
aLock
entries
interval
aFeatures
aFilters
aFilterCount
)
;
Thread
:
:
tid_t
tid
=
Thread
:
:
GetCurrentId
(
)
;
const
CorePS
:
:
ThreadVector
&
liveThreads
=
CorePS
:
:
LiveThreads
(
aLock
)
;
for
(
uint32_t
i
=
0
;
i
<
liveThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
liveThreads
.
at
(
i
)
;
if
(
ActivePS
:
:
ShouldProfileThread
(
aLock
info
)
)
{
info
-
>
StartProfiling
(
)
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
info
-
>
StartJSSampling
(
)
;
if
(
info
-
>
ThreadId
(
)
=
=
tid
)
{
info
-
>
PollJSSampling
(
)
;
}
}
}
}
MOZ_RELEASE_ASSERT
(
CorePS
:
:
DeadThreads
(
aLock
)
.
empty
(
)
)
;
#
ifdef
MOZ_TASK_TRACER
if
(
ActivePS
:
:
FeatureTaskTracer
(
aLock
)
)
{
mozilla
:
:
tasktracer
:
:
StartLogging
(
)
;
}
#
endif
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
int
javaInterval
=
interval
;
if
(
javaInterval
<
10
)
{
javaInterval
=
10
;
}
mozilla
:
:
java
:
:
GeckoJavaSampler
:
:
Start
(
javaInterval
1000
)
;
}
#
endif
}
void
profiler_start
(
int
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
{
LOG
(
"
profiler_start
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
profiler_init
(
nullptr
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
locked_profiler_start
(
lock
aEntries
aInterval
aFeatures
aFilters
aFilterCount
)
;
}
if
(
samplerThread
)
{
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
NotifyProfilerStarted
(
aEntries
aInterval
aFeatures
aFilters
aFilterCount
)
;
}
static
MOZ_MUST_USE
SamplerThread
*
locked_profiler_stop
(
PSLockRef
aLock
)
{
LOG
(
"
locked_profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
#
ifdef
MOZ_TASK_TRACER
if
(
ActivePS
:
:
FeatureTaskTracer
(
aLock
)
)
{
mozilla
:
:
tasktracer
:
:
StopLogging
(
)
;
}
#
endif
Thread
:
:
tid_t
tid
=
Thread
:
:
GetCurrentId
(
)
;
CorePS
:
:
ThreadVector
&
liveThreads
=
CorePS
:
:
LiveThreads
(
aLock
)
;
for
(
uint32_t
i
=
0
;
i
<
liveThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
liveThreads
.
at
(
i
)
;
if
(
info
-
>
IsBeingProfiled
(
)
)
{
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
info
-
>
StopJSSampling
(
)
;
if
(
info
-
>
ThreadId
(
)
=
=
tid
)
{
info
-
>
PollJSSampling
(
)
;
}
}
info
-
>
StopProfiling
(
)
;
}
}
CorePS
:
:
ThreadVector
&
deadThreads
=
CorePS
:
:
DeadThreads
(
aLock
)
;
while
(
deadThreads
.
size
(
)
>
0
)
{
delete
deadThreads
.
back
(
)
;
deadThreads
.
pop_back
(
)
;
}
SamplerThread
*
samplerThread
=
ActivePS
:
:
Destroy
(
aLock
)
;
samplerThread
-
>
Stop
(
aLock
)
;
return
samplerThread
;
}
void
profiler_stop
(
)
{
LOG
(
"
profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
SamplerThread
*
samplerThread
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
bool
profiler_is_paused
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
return
ActivePS
:
:
IsPaused
(
lock
)
;
}
void
profiler_pause
(
)
{
LOG
(
"
profiler_pause
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
ActivePS
:
:
SetIsPaused
(
lock
true
)
;
}
NotifyObservers
(
"
profiler
-
paused
"
)
;
}
void
profiler_resume
(
)
{
LOG
(
"
profiler_resume
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
ActivePS
:
:
SetIsPaused
(
lock
false
)
;
}
NotifyObservers
(
"
profiler
-
resumed
"
)
;
}
bool
profiler_feature_active
(
uint32_t
aFeature
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
return
!
!
(
ActivePS
:
:
Features
(
lock
)
&
aFeature
)
;
}
bool
profiler_is_active
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
return
ActivePS
:
:
Exists
(
lock
)
;
}
void
profiler_register_thread
(
const
char
*
aName
void
*
aGuessStackTop
)
{
DEBUG_LOG
(
"
profiler_register_thread
(
%
s
)
"
aName
)
;
MOZ_RELEASE_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
void
*
stackTop
=
GetStackTop
(
aGuessStackTop
)
;
locked_register_thread
(
lock
aName
stackTop
)
;
}
void
profiler_unregister_thread
(
)
{
MOZ_RELEASE_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
int
i
;
ThreadInfo
*
info
=
FindLiveThreadInfo
(
lock
&
i
)
;
MOZ_RELEASE_ASSERT
(
info
=
=
TLSInfo
:
:
Info
(
lock
)
)
;
if
(
info
)
{
DEBUG_LOG
(
"
profiler_unregister_thread
:
%
s
"
info
-
>
Name
(
)
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
&
&
info
-
>
IsBeingProfiled
(
)
)
{
CorePS
:
:
DeadThreads
(
lock
)
.
push_back
(
info
)
;
}
else
{
delete
info
;
}
CorePS
:
:
ThreadVector
&
liveThreads
=
CorePS
:
:
LiveThreads
(
lock
)
;
liveThreads
.
erase
(
liveThreads
.
begin
(
)
+
i
)
;
TLSInfo
:
:
SetInfo
(
lock
nullptr
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
!
TLSInfo
:
:
Info
(
lock
)
)
;
}
}
void
profiler_thread_sleep
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
RacyThreadInfo
*
racyInfo
=
TLSInfo
:
:
RacyInfo
(
)
;
if
(
!
racyInfo
)
{
return
;
}
racyInfo
-
>
SetSleeping
(
)
;
}
void
profiler_thread_wake
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
RacyThreadInfo
*
racyInfo
=
TLSInfo
:
:
RacyInfo
(
)
;
if
(
!
racyInfo
)
{
return
;
}
racyInfo
-
>
SetAwake
(
)
;
}
bool
profiler_thread_is_sleeping
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
RacyThreadInfo
*
racyInfo
=
TLSInfo
:
:
RacyInfo
(
)
;
if
(
!
racyInfo
)
{
return
false
;
}
return
racyInfo
-
>
IsSleeping
(
)
;
}
void
profiler_js_interrupt_callback
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
ThreadInfo
*
info
=
TLSInfo
:
:
Info
(
lock
)
;
if
(
!
info
)
{
return
;
}
info
-
>
PollJSSampling
(
)
;
}
double
profiler_time
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
mozilla
:
:
TimeDuration
delta
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
-
CorePS
:
:
ProcessStartTime
(
lock
)
;
return
delta
.
ToMilliseconds
(
)
;
}
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
|
|
ActivePS
:
:
FeaturePrivacy
(
lock
)
)
{
return
nullptr
;
}
ThreadInfo
*
info
=
TLSInfo
:
:
Info
(
lock
)
;
if
(
!
info
)
{
MOZ_ASSERT
(
info
)
;
return
nullptr
;
}
Thread
:
:
tid_t
tid
=
Thread
:
:
GetCurrentId
(
)
;
ProfileBuffer
*
buffer
=
new
ProfileBuffer
(
PROFILER_GET_BACKTRACE_ENTRIES
)
;
UniquePlatformData
platformData
=
AllocPlatformData
(
tid
)
;
TickSample
sample
(
info
-
>
RacyInfo
(
)
info
-
>
mContext
platformData
.
get
(
)
)
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
ucontext_t
context
;
sample
.
PopulateContext
(
&
context
)
;
#
else
sample
.
PopulateContext
(
)
;
#
endif
#
endif
Tick
(
lock
buffer
sample
)
;
return
UniqueProfilerBacktrace
(
new
ProfilerBacktrace
(
"
SyncProfile
"
tid
buffer
)
)
;
}
void
ProfilerBacktraceDestructor
:
:
operator
(
)
(
ProfilerBacktrace
*
aBacktrace
)
{
delete
aBacktrace
;
}
void
profiler_get_backtrace_noalloc
(
char
*
output
size_t
outputSize
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
MOZ_ASSERT
(
outputSize
>
=
2
)
;
char
*
bound
=
output
+
outputSize
-
2
;
output
[
0
]
=
output
[
1
]
=
'
\
0
'
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
PseudoStack
*
pseudoStack
=
TLSInfo
:
:
Stack
(
)
;
if
(
!
pseudoStack
)
{
return
;
}
bool
includeDynamicString
=
!
ActivePS
:
:
FeaturePrivacy
(
lock
)
;
volatile
js
:
:
ProfileEntry
*
pseudoFrames
=
pseudoStack
-
>
mStack
;
uint32_t
pseudoCount
=
pseudoStack
-
>
stackSize
(
)
;
for
(
uint32_t
i
=
0
;
i
<
pseudoCount
;
i
+
+
)
{
const
char
*
label
=
pseudoFrames
[
i
]
.
label
(
)
;
const
char
*
dynamicString
=
includeDynamicString
?
pseudoFrames
[
i
]
.
dynamicString
(
)
:
nullptr
;
size_t
labelLength
=
strlen
(
label
)
;
if
(
dynamicString
)
{
size_t
spaceLength
=
label
[
0
]
=
=
'
\
0
'
?
0
:
1
;
size_t
dynamicStringLength
=
strlen
(
dynamicString
)
;
if
(
output
+
labelLength
+
spaceLength
+
dynamicStringLength
>
=
bound
)
{
break
;
}
strcpy
(
output
label
)
;
output
+
=
labelLength
;
if
(
spaceLength
!
=
0
)
{
*
output
+
+
=
'
'
;
}
strcpy
(
output
dynamicString
)
;
output
+
=
dynamicStringLength
;
}
else
{
if
(
output
+
labelLength
>
=
bound
)
{
break
;
}
strcpy
(
output
label
)
;
output
+
=
labelLength
;
}
*
output
+
+
=
'
\
0
'
;
*
output
=
'
\
0
'
;
}
}
static
void
locked_profiler_add_marker
(
PSLockRef
aLock
const
char
*
aMarker
ProfilerMarkerPayload
*
aPayload
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
MOZ_RELEASE_ASSERT
(
ActivePS
:
:
Exists
(
aLock
)
&
&
!
ActivePS
:
:
FeaturePrivacy
(
aLock
)
)
;
mozilla
:
:
UniquePtr
<
ProfilerMarkerPayload
>
payload
(
aPayload
)
;
RacyThreadInfo
*
racyInfo
=
TLSInfo
:
:
RacyInfo
(
)
;
if
(
!
racyInfo
)
{
return
;
}
mozilla
:
:
TimeStamp
origin
=
(
payload
&
&
!
payload
-
>
GetStartTime
(
)
.
IsNull
(
)
)
?
payload
-
>
GetStartTime
(
)
:
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
mozilla
:
:
TimeDuration
delta
=
origin
-
CorePS
:
:
ProcessStartTime
(
aLock
)
;
racyInfo
-
>
AddPendingMarker
(
aMarker
payload
.
release
(
)
delta
.
ToMilliseconds
(
)
)
;
}
void
profiler_add_marker
(
const
char
*
aMarker
ProfilerMarkerPayload
*
aPayload
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
mozilla
:
:
UniquePtr
<
ProfilerMarkerPayload
>
payload
(
aPayload
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
|
|
ActivePS
:
:
FeaturePrivacy
(
lock
)
)
{
return
;
}
locked_profiler_add_marker
(
lock
aMarker
payload
.
release
(
)
)
;
}
void
profiler_tracing
(
const
char
*
aCategory
const
char
*
aInfo
TracingKind
aKind
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
|
|
ActivePS
:
:
FeaturePrivacy
(
lock
)
)
{
return
;
}
auto
marker
=
new
ProfilerMarkerTracing
(
aCategory
aKind
)
;
locked_profiler_add_marker
(
lock
aInfo
marker
)
;
}
void
profiler_tracing
(
const
char
*
aCategory
const
char
*
aInfo
UniqueProfilerBacktrace
aCause
TracingKind
aKind
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
|
|
ActivePS
:
:
FeaturePrivacy
(
lock
)
)
{
return
;
}
auto
marker
=
new
ProfilerMarkerTracing
(
aCategory
aKind
mozilla
:
:
Move
(
aCause
)
)
;
locked_profiler_add_marker
(
lock
aInfo
marker
)
;
}
void
profiler_log
(
const
char
*
aStr
)
{
profiler_tracing
(
"
log
"
aStr
)
;
}
PseudoStack
*
profiler_get_pseudo_stack
(
)
{
return
TLSInfo
:
:
Stack
(
)
;
}
void
profiler_set_js_context
(
JSContext
*
aCx
)
{
MOZ_ASSERT
(
aCx
)
;
PSAutoLock
lock
(
gPSMutex
)
;
ThreadInfo
*
info
=
TLSInfo
:
:
Info
(
lock
)
;
if
(
!
info
)
{
return
;
}
info
-
>
SetJSContext
(
aCx
)
;
}
void
profiler_clear_js_context
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
ThreadInfo
*
info
=
TLSInfo
:
:
Info
(
lock
)
;
if
(
!
info
|
|
!
info
-
>
mContext
)
{
return
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
if
(
info
-
>
IsBeingProfiled
(
)
)
{
info
-
>
FlushSamplesAndMarkers
(
ActivePS
:
:
Buffer
(
lock
)
CorePS
:
:
ProcessStartTime
(
lock
)
)
;
}
}
info
-
>
mContext
=
nullptr
;
}
void
*
profiler_get_stack_top
(
)
{
PSAutoLock
lock
(
gPSMutex
)
;
ThreadInfo
*
threadInfo
=
FindLiveThreadInfo
(
lock
)
;
if
(
threadInfo
)
{
return
threadInfo
-
>
StackTop
(
)
;
}
return
nullptr
;
}
