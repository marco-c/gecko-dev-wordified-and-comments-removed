#
include
<
algorithm
>
#
include
<
ostream
>
#
include
<
fstream
>
#
include
<
sstream
>
#
include
<
errno
.
h
>
#
include
"
platform
.
h
"
#
include
"
PlatformMacros
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
ProfilerIOInterposeObserver
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
PseudoStack
.
h
"
#
include
"
ThreadInfo
.
h
"
#
include
"
nsIHttpProtocolHandler
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsMemoryReporterManager
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsProfilerStartParams
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
ProfilerMarkers
.
h
"
#
include
"
shared
-
libraries
.
h
"
#
include
"
prtime
.
h
"
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
#
endif
#
if
defined
(
PROFILE_JAVA
)
#
include
"
FennecJNINatives
.
h
"
#
include
"
FennecJNIWrappers
.
h
"
#
endif
#
if
defined
(
MOZ_PROFILING
)
&
&
\
(
defined
(
GP_OS_windows
)
|
|
defined
(
GP_OS_darwin
)
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_NS_STACKWALK
#
endif
#
if
defined
(
GP_PLAT_arm_android
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_EHABI_STACKWALK
#
include
"
EHABIStackWalk
.
h
"
#
endif
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_x86_linux
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_LUL_STACKWALK
#
include
"
lul
/
LulMain
.
h
"
#
include
"
lul
/
platform
-
linux
-
lul
.
h
"
#
endif
#
ifdef
MOZ_VALGRIND
#
include
<
valgrind
/
memcheck
.
h
>
#
else
#
define
VALGRIND_MAKE_MEM_DEFINED
(
_addr
_len
)
(
(
void
)
0
)
#
endif
#
if
defined
(
GP_OS_windows
)
typedef
CONTEXT
tick_context_t
;
#
elif
defined
(
GP_OS_darwin
)
typedef
void
tick_context_t
;
#
elif
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
#
include
<
ucontext
.
h
>
typedef
ucontext_t
tick_context_t
;
#
endif
using
namespace
mozilla
;
mozilla
:
:
LazyLogModule
gProfilerLog
(
"
prof
"
)
;
#
if
defined
(
PROFILE_JAVA
)
class
GeckoJavaSampler
:
public
mozilla
:
:
java
:
:
GeckoJavaSampler
:
:
Natives
<
GeckoJavaSampler
>
{
private
:
GeckoJavaSampler
(
)
;
public
:
static
double
GetProfilerTime
(
)
{
if
(
!
profiler_is_active
(
)
)
{
return
0
.
0
;
}
return
profiler_time
(
)
;
}
;
}
;
#
endif
class
SamplerThread
;
MOZ_THREAD_LOCAL
(
PseudoStack
*
)
tlsPseudoStack
;
class
ProfilerState
{
public
:
class
Mutex
:
public
mozilla
:
:
StaticMutex
{
}
;
typedef
mozilla
:
:
BaseAutoLock
<
Mutex
>
AutoLock
;
typedef
const
AutoLock
&
LockRef
;
typedef
std
:
:
vector
<
ThreadInfo
*
>
ThreadVector
;
ProfilerState
(
)
:
mEntries
(
0
)
mInterval
(
0
)
mFeatureDisplayListDump
(
false
)
mFeatureGPU
(
false
)
mFeatureJava
(
false
)
mFeatureJS
(
false
)
mFeatureLayersDump
(
false
)
mFeatureLeaf
(
false
)
mFeatureMemory
(
false
)
mFeaturePrivacy
(
false
)
mFeatureRestyle
(
false
)
mFeatureStackWalk
(
false
)
mFeatureTaskTracer
(
false
)
mFeatureThreads
(
false
)
mBuffer
(
nullptr
)
mIsPaused
(
false
)
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
mWasPaused
(
false
)
#
endif
mSamplerThread
(
nullptr
)
#
ifdef
USE_LUL_STACKWALK
mLUL
(
nullptr
)
#
endif
mInterposeObserver
(
nullptr
)
mFrameNumber
(
0
)
mLatestRecordedFrameNumber
(
0
)
{
}
#
define
GET_AND_SET
(
type_
name_
)
\
type_
name_
(
LockRef
)
const
{
return
m
#
#
name_
;
}
\
void
Set
#
#
name_
(
LockRef
type_
a
#
#
name_
)
{
m
#
#
name_
=
a
#
#
name_
;
}
GET_AND_SET
(
TimeStamp
StartTime
)
GET_AND_SET
(
int
Entries
)
GET_AND_SET
(
double
Interval
)
Vector
<
std
:
:
string
>
&
Features
(
LockRef
)
{
return
mFeatures
;
}
Vector
<
std
:
:
string
>
&
ThreadNameFilters
(
LockRef
)
{
return
mThreadNameFilters
;
}
GET_AND_SET
(
bool
FeatureDisplayListDump
)
GET_AND_SET
(
bool
FeatureGPU
)
GET_AND_SET
(
bool
FeatureJava
)
GET_AND_SET
(
bool
FeatureJS
)
GET_AND_SET
(
bool
FeatureLayersDump
)
GET_AND_SET
(
bool
FeatureLeaf
)
GET_AND_SET
(
bool
FeatureMemory
)
GET_AND_SET
(
bool
FeaturePrivacy
)
GET_AND_SET
(
bool
FeatureRestyle
)
GET_AND_SET
(
bool
FeatureStackWalk
)
GET_AND_SET
(
bool
FeatureTaskTracer
)
GET_AND_SET
(
bool
FeatureThreads
)
GET_AND_SET
(
ProfileBuffer
*
Buffer
)
ThreadVector
&
LiveThreads
(
LockRef
)
{
return
mLiveThreads
;
}
ThreadVector
&
DeadThreads
(
LockRef
)
{
return
mDeadThreads
;
}
static
bool
IsActive
(
LockRef
)
{
return
sActivityGeneration
>
0
;
}
static
uint32_t
ActivityGeneration
(
LockRef
)
{
return
sActivityGeneration
;
}
static
void
SetInactive
(
LockRef
)
{
sActivityGeneration
=
0
;
}
static
void
SetActive
(
LockRef
)
{
sActivityGeneration
=
sNextActivityGeneration
;
sNextActivityGeneration
=
(
sNextActivityGeneration
=
=
0xffffffff
)
?
1
:
sNextActivityGeneration
+
1
;
}
GET_AND_SET
(
bool
IsPaused
)
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
GET_AND_SET
(
bool
WasPaused
)
#
endif
GET_AND_SET
(
class
SamplerThread
*
SamplerThread
)
#
ifdef
USE_LUL_STACKWALK
GET_AND_SET
(
lul
:
:
LUL
*
LUL
)
#
endif
GET_AND_SET
(
mozilla
:
:
ProfilerIOInterposeObserver
*
InterposeObserver
)
GET_AND_SET
(
int
FrameNumber
)
GET_AND_SET
(
int
LatestRecordedFrameNumber
)
#
undef
GET_AND_SET
private
:
mozilla
:
:
TimeStamp
mStartTime
;
int
mEntries
;
double
mInterval
;
Vector
<
std
:
:
string
>
mFeatures
;
Vector
<
std
:
:
string
>
mThreadNameFilters
;
bool
mFeatureDisplayListDump
;
bool
mFeatureGPU
;
bool
mFeatureJava
;
bool
mFeatureJS
;
bool
mFeatureLayersDump
;
bool
mFeatureLeaf
;
bool
mFeatureMemory
;
bool
mFeaturePrivacy
;
bool
mFeatureRestyle
;
bool
mFeatureStackWalk
;
bool
mFeatureTaskTracer
;
bool
mFeatureThreads
;
ProfileBuffer
*
mBuffer
;
ThreadVector
mLiveThreads
;
ThreadVector
mDeadThreads
;
static
uint32_t
sActivityGeneration
;
static
uint32_t
sNextActivityGeneration
;
bool
mIsPaused
;
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
bool
mWasPaused
;
#
endif
class
SamplerThread
*
mSamplerThread
;
#
ifdef
USE_LUL_STACKWALK
lul
:
:
LUL
*
mLUL
;
#
endif
mozilla
:
:
ProfilerIOInterposeObserver
*
mInterposeObserver
;
int
mFrameNumber
;
int
mLatestRecordedFrameNumber
;
}
;
typedef
ProfilerState
PS
;
uint32_t
PS
:
:
sActivityGeneration
=
0
;
uint32_t
PS
:
:
sNextActivityGeneration
=
1
;
PS
*
gPS
=
nullptr
;
static
PS
:
:
Mutex
gPSMutex
;
static
const
char
*
const
kMainThreadName
=
"
GeckoMain
"
;
static
bool
CanNotifyObservers
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
#
if
defined
(
GP_OS_android
)
return
NS_IsMainThread
(
)
;
#
else
return
true
;
#
endif
}
class
TickSample
{
public
:
TickSample
(
ThreadInfo
*
aThreadInfo
int64_t
aRSSMemory
int64_t
aUSSMemory
)
:
mIsSynchronous
(
false
)
mTimeStamp
(
mozilla
:
:
TimeStamp
:
:
Now
(
)
)
mThreadId
(
aThreadInfo
-
>
ThreadId
(
)
)
mPseudoStack
(
aThreadInfo
-
>
Stack
(
)
)
mStackTop
(
aThreadInfo
-
>
StackTop
(
)
)
mLastSample
(
&
aThreadInfo
-
>
LastSample
(
)
)
mPlatformData
(
aThreadInfo
-
>
GetPlatformData
(
)
)
mResponsiveness
(
aThreadInfo
-
>
GetThreadResponsiveness
(
)
)
mRSSMemory
(
aRSSMemory
)
mUSSMemory
(
aUSSMemory
)
#
if
!
defined
(
GP_OS_darwin
)
mContext
(
nullptr
)
#
endif
mPC
(
nullptr
)
mSP
(
nullptr
)
mFP
(
nullptr
)
mLR
(
nullptr
)
{
}
TickSample
(
NotNull
<
PseudoStack
*
>
aPseudoStack
PlatformData
*
aPlatformData
)
:
mIsSynchronous
(
true
)
mTimeStamp
(
mozilla
:
:
TimeStamp
:
:
Now
(
)
)
mThreadId
(
Thread
:
:
GetCurrentId
(
)
)
mPseudoStack
(
aPseudoStack
)
mStackTop
(
nullptr
)
mLastSample
(
nullptr
)
mPlatformData
(
aPlatformData
)
mResponsiveness
(
nullptr
)
mRSSMemory
(
0
)
mUSSMemory
(
0
)
#
if
!
defined
(
GP_OS_darwin
)
mContext
(
nullptr
)
#
endif
mPC
(
nullptr
)
mSP
(
nullptr
)
mFP
(
nullptr
)
mLR
(
nullptr
)
{
}
void
PopulateContext
(
tick_context_t
*
aContext
)
;
const
bool
mIsSynchronous
;
const
mozilla
:
:
TimeStamp
mTimeStamp
;
const
int
mThreadId
;
const
NotNull
<
PseudoStack
*
>
mPseudoStack
;
void
*
const
mStackTop
;
ProfileBuffer
:
:
LastSample
*
const
mLastSample
;
PlatformData
*
const
mPlatformData
;
ThreadResponsiveness
*
const
mResponsiveness
;
const
int64_t
mRSSMemory
;
const
int64_t
mUSSMemory
;
#
if
!
defined
(
GP_OS_darwin
)
void
*
mContext
;
#
endif
Address
mPC
;
Address
mSP
;
Address
mFP
;
Address
mLR
;
}
;
static
void
AddDynamicCodeLocationTag
(
ProfileBuffer
*
aBuffer
const
char
*
aStr
)
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
CodeLocation
(
"
"
)
)
;
size_t
strLen
=
strlen
(
aStr
)
+
1
;
for
(
size_t
j
=
0
;
j
<
strLen
;
)
{
char
text
[
sizeof
(
void
*
)
]
;
size_t
len
=
sizeof
(
void
*
)
/
sizeof
(
char
)
;
if
(
j
+
len
>
=
strLen
)
{
len
=
strLen
-
j
;
}
memcpy
(
text
&
aStr
[
j
]
len
)
;
j
+
=
sizeof
(
void
*
)
/
sizeof
(
char
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
EmbeddedString
(
*
(
(
void
*
*
)
(
&
text
[
0
]
)
)
)
)
;
}
}
static
const
int
SAMPLER_MAX_STRING_LENGTH
=
128
;
static
void
AddPseudoEntry
(
PS
:
:
LockRef
aLock
ProfileBuffer
*
aBuffer
volatile
js
:
:
ProfileEntry
&
entry
PseudoStack
*
stack
void
*
lastpc
)
{
if
(
entry
.
hasFlag
(
js
:
:
ProfileEntry
:
:
BEGIN_PSEUDO_JS
)
)
{
return
;
}
int
lineno
=
-
1
;
const
char
*
sampleLabel
=
entry
.
label
(
)
;
bool
includeDynamicString
=
!
gPS
-
>
FeaturePrivacy
(
aLock
)
;
const
char
*
dynamicString
=
includeDynamicString
?
entry
.
getDynamicString
(
)
:
nullptr
;
char
combinedStringBuffer
[
SAMPLER_MAX_STRING_LENGTH
]
;
if
(
entry
.
isCopyLabel
(
)
|
|
dynamicString
)
{
if
(
dynamicString
)
{
int
bytesWritten
=
SprintfLiteral
(
combinedStringBuffer
"
%
s
%
s
"
sampleLabel
dynamicString
)
;
if
(
bytesWritten
>
0
)
{
sampleLabel
=
combinedStringBuffer
;
}
}
AddDynamicCodeLocationTag
(
aBuffer
sampleLabel
)
;
if
(
entry
.
isJs
(
)
)
{
JSScript
*
script
=
entry
.
script
(
)
;
if
(
script
)
{
if
(
!
entry
.
pc
(
)
)
{
MOZ_ASSERT
(
&
entry
=
=
&
stack
-
>
mStack
[
stack
-
>
stackSize
(
)
-
1
]
)
;
if
(
lastpc
)
{
jsbytecode
*
jspc
=
js
:
:
ProfilingGetPC
(
stack
-
>
mContext
script
lastpc
)
;
if
(
jspc
)
{
lineno
=
JS_PCToLineNumber
(
script
jspc
)
;
}
}
}
else
{
lineno
=
JS_PCToLineNumber
(
script
entry
.
pc
(
)
)
;
}
}
}
else
{
lineno
=
entry
.
line
(
)
;
}
}
else
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
CodeLocation
(
sampleLabel
)
)
;
if
(
entry
.
isCpp
(
)
)
{
lineno
=
entry
.
line
(
)
;
}
}
if
(
lineno
!
=
-
1
)
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
LineNumber
(
lineno
)
)
;
}
uint32_t
category
=
entry
.
category
(
)
;
MOZ_ASSERT
(
!
(
category
&
js
:
:
ProfileEntry
:
:
IS_CPP_ENTRY
)
)
;
MOZ_ASSERT
(
!
(
category
&
js
:
:
ProfileEntry
:
:
FRAME_LABEL_COPY
)
)
;
if
(
category
)
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Category
(
(
int
)
category
)
)
;
}
}
struct
NativeStack
{
void
*
*
pc_array
;
void
*
*
sp_array
;
size_t
size
;
size_t
count
;
}
;
mozilla
:
:
Atomic
<
bool
>
WALKING_JS_STACK
(
false
)
;
struct
AutoWalkJSStack
{
bool
walkAllowed
;
AutoWalkJSStack
(
)
:
walkAllowed
(
false
)
{
walkAllowed
=
WALKING_JS_STACK
.
compareExchange
(
false
true
)
;
}
~
AutoWalkJSStack
(
)
{
if
(
walkAllowed
)
{
WALKING_JS_STACK
=
false
;
}
}
}
;
static
void
MergeStacksIntoProfile
(
PS
:
:
LockRef
aLock
ProfileBuffer
*
aBuffer
const
TickSample
&
aSample
NativeStack
&
aNativeStack
)
{
NotNull
<
PseudoStack
*
>
pseudoStack
=
aSample
.
mPseudoStack
;
volatile
js
:
:
ProfileEntry
*
pseudoFrames
=
pseudoStack
-
>
mStack
;
uint32_t
pseudoCount
=
pseudoStack
-
>
stackSize
(
)
;
uint32_t
startBufferGen
;
startBufferGen
=
aSample
.
mIsSynchronous
?
UINT32_MAX
:
aBuffer
-
>
mGeneration
;
uint32_t
jsCount
=
0
;
JS
:
:
ProfilingFrameIterator
:
:
Frame
jsFrames
[
1000
]
;
if
(
pseudoStack
-
>
mContext
&
&
JS
:
:
IsProfilingEnabledForContext
(
pseudoStack
-
>
mContext
)
)
{
AutoWalkJSStack
autoWalkJSStack
;
const
uint32_t
maxFrames
=
mozilla
:
:
ArrayLength
(
jsFrames
)
;
if
(
autoWalkJSStack
.
walkAllowed
)
{
JS
:
:
ProfilingFrameIterator
:
:
RegisterState
registerState
;
registerState
.
pc
=
aSample
.
mPC
;
registerState
.
sp
=
aSample
.
mSP
;
registerState
.
lr
=
aSample
.
mLR
;
registerState
.
fp
=
aSample
.
mFP
;
JS
:
:
ProfilingFrameIterator
jsIter
(
pseudoStack
-
>
mContext
registerState
startBufferGen
)
;
for
(
;
jsCount
<
maxFrames
&
&
!
jsIter
.
done
(
)
;
+
+
jsIter
)
{
if
(
aSample
.
mIsSynchronous
|
|
jsIter
.
isWasm
(
)
)
{
uint32_t
extracted
=
jsIter
.
extractStack
(
jsFrames
jsCount
maxFrames
)
;
jsCount
+
=
extracted
;
if
(
jsCount
=
=
maxFrames
)
{
break
;
}
}
else
{
mozilla
:
:
Maybe
<
JS
:
:
ProfilingFrameIterator
:
:
Frame
>
frame
=
jsIter
.
getPhysicalFrameWithoutLabel
(
)
;
if
(
frame
.
isSome
(
)
)
{
jsFrames
[
jsCount
+
+
]
=
frame
.
value
(
)
;
}
}
}
}
}
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Sample
(
"
(
root
)
"
)
)
;
uint32_t
pseudoIndex
=
0
;
int32_t
jsIndex
=
jsCount
-
1
;
int32_t
nativeIndex
=
aNativeStack
.
count
-
1
;
uint8_t
*
lastPseudoCppStackAddr
=
nullptr
;
while
(
pseudoIndex
!
=
pseudoCount
|
|
jsIndex
>
=
0
|
|
nativeIndex
>
=
0
)
{
uint8_t
*
pseudoStackAddr
=
nullptr
;
uint8_t
*
jsStackAddr
=
nullptr
;
uint8_t
*
nativeStackAddr
=
nullptr
;
if
(
pseudoIndex
!
=
pseudoCount
)
{
volatile
js
:
:
ProfileEntry
&
pseudoFrame
=
pseudoFrames
[
pseudoIndex
]
;
if
(
pseudoFrame
.
isCpp
(
)
)
{
lastPseudoCppStackAddr
=
(
uint8_t
*
)
pseudoFrame
.
stackAddress
(
)
;
}
if
(
pseudoFrame
.
isJs
(
)
&
&
pseudoFrame
.
isOSR
(
)
)
{
pseudoIndex
+
+
;
continue
;
}
MOZ_ASSERT
(
lastPseudoCppStackAddr
)
;
pseudoStackAddr
=
lastPseudoCppStackAddr
;
}
if
(
jsIndex
>
=
0
)
{
jsStackAddr
=
(
uint8_t
*
)
jsFrames
[
jsIndex
]
.
stackAddress
;
}
if
(
nativeIndex
>
=
0
)
{
nativeStackAddr
=
(
uint8_t
*
)
aNativeStack
.
sp_array
[
nativeIndex
]
;
}
if
(
nativeStackAddr
&
&
(
pseudoStackAddr
=
=
nativeStackAddr
|
|
jsStackAddr
=
=
nativeStackAddr
)
)
{
nativeStackAddr
=
nullptr
;
nativeIndex
-
-
;
MOZ_ASSERT
(
pseudoStackAddr
|
|
jsStackAddr
)
;
}
MOZ_ASSERT_IF
(
pseudoStackAddr
pseudoStackAddr
!
=
jsStackAddr
&
&
pseudoStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
jsStackAddr
jsStackAddr
!
=
pseudoStackAddr
&
&
jsStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
nativeStackAddr
nativeStackAddr
!
=
pseudoStackAddr
&
&
nativeStackAddr
!
=
jsStackAddr
)
;
if
(
pseudoStackAddr
>
jsStackAddr
&
&
pseudoStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
pseudoIndex
<
pseudoCount
)
;
volatile
js
:
:
ProfileEntry
&
pseudoFrame
=
pseudoFrames
[
pseudoIndex
]
;
AddPseudoEntry
(
aLock
aBuffer
pseudoFrame
pseudoStack
nullptr
)
;
pseudoIndex
+
+
;
continue
;
}
if
(
jsStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
jsIndex
>
=
0
)
;
const
JS
:
:
ProfilingFrameIterator
:
:
Frame
&
jsFrame
=
jsFrames
[
jsIndex
]
;
if
(
aSample
.
mIsSynchronous
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Wasm
)
{
AddDynamicCodeLocationTag
(
aBuffer
jsFrame
.
label
)
;
}
else
{
MOZ_ASSERT
(
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Ion
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Baseline
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
JitReturnAddr
(
jsFrames
[
jsIndex
]
.
returnAddress
)
)
;
}
jsIndex
-
-
;
continue
;
}
if
(
nativeStackAddr
)
{
MOZ_ASSERT
(
nativeIndex
>
=
0
)
;
void
*
addr
=
(
void
*
)
aNativeStack
.
pc_array
[
nativeIndex
]
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
NativeLeafAddr
(
addr
)
)
;
}
if
(
nativeIndex
>
=
0
)
{
nativeIndex
-
-
;
}
}
if
(
!
aSample
.
mIsSynchronous
&
&
pseudoStack
-
>
mContext
)
{
MOZ_ASSERT
(
aBuffer
-
>
mGeneration
>
=
startBufferGen
)
;
uint32_t
lapCount
=
aBuffer
-
>
mGeneration
-
startBufferGen
;
JS
:
:
UpdateJSContextProfilerSampleBufferGen
(
pseudoStack
-
>
mContext
aBuffer
-
>
mGeneration
lapCount
)
;
}
}
#
if
defined
(
GP_OS_windows
)
static
uintptr_t
GetThreadHandle
(
PlatformData
*
aData
)
;
#
endif
#
ifdef
USE_NS_STACKWALK
static
void
StackWalkCallback
(
uint32_t
aFrameNumber
void
*
aPC
void
*
aSP
void
*
aClosure
)
{
NativeStack
*
nativeStack
=
static_cast
<
NativeStack
*
>
(
aClosure
)
;
MOZ_ASSERT
(
nativeStack
-
>
count
<
nativeStack
-
>
size
)
;
nativeStack
-
>
sp_array
[
nativeStack
-
>
count
]
=
aSP
;
nativeStack
-
>
pc_array
[
nativeStack
-
>
count
]
=
aPC
;
nativeStack
-
>
count
+
+
;
}
static
void
DoNativeBacktrace
(
PS
:
:
LockRef
aLock
ProfileBuffer
*
aBuffer
const
TickSample
&
aSample
)
{
void
*
pc_array
[
1000
]
;
void
*
sp_array
[
1000
]
;
NativeStack
nativeStack
=
{
pc_array
sp_array
mozilla
:
:
ArrayLength
(
pc_array
)
0
}
;
StackWalkCallback
(
0
aSample
.
mPC
aSample
.
mSP
&
nativeStack
)
;
uint32_t
maxFrames
=
uint32_t
(
nativeStack
.
size
-
nativeStack
.
count
)
;
#
if
defined
(
GP_OS_darwin
)
|
|
(
defined
(
GP_PLAT_x86_windows
)
)
void
*
stackEnd
=
aSample
.
mStackTop
;
if
(
aSample
.
mFP
>
=
aSample
.
mSP
&
&
aSample
.
mFP
<
=
stackEnd
)
{
FramePointerStackWalk
(
StackWalkCallback
0
maxFrames
&
nativeStack
reinterpret_cast
<
void
*
*
>
(
aSample
.
mFP
)
stackEnd
)
;
}
#
else
uintptr_t
thread
=
GetThreadHandle
(
aSample
.
mPlatformData
)
;
MOZ_ASSERT
(
thread
)
;
MozStackWalk
(
StackWalkCallback
0
maxFrames
&
nativeStack
thread
nullptr
)
;
#
endif
MergeStacksIntoProfile
(
aLock
aBuffer
aSample
nativeStack
)
;
}
#
endif
#
ifdef
USE_EHABI_STACKWALK
static
void
DoNativeBacktrace
(
PS
:
:
LockRef
aLock
ProfileBuffer
*
aBuffer
const
TickSample
&
aSample
)
{
void
*
pc_array
[
1000
]
;
void
*
sp_array
[
1000
]
;
NativeStack
nativeStack
=
{
pc_array
sp_array
mozilla
:
:
ArrayLength
(
pc_array
)
0
}
;
const
mcontext_t
*
mcontext
=
&
reinterpret_cast
<
ucontext_t
*
>
(
aSample
.
mContext
)
-
>
uc_mcontext
;
mcontext_t
savedContext
;
NotNull
<
PseudoStack
*
>
pseudoStack
=
aSample
.
mPseudoStack
;
for
(
uint32_t
i
=
pseudoStack
-
>
stackSize
(
)
;
i
>
0
;
-
-
i
)
{
volatile
js
:
:
ProfileEntry
&
entry
=
pseudoStack
-
>
mStack
[
i
-
1
]
;
if
(
!
entry
.
isJs
(
)
&
&
strcmp
(
entry
.
label
(
)
"
EnterJIT
"
)
=
=
0
)
{
uint32_t
*
vSP
=
reinterpret_cast
<
uint32_t
*
>
(
entry
.
stackAddress
(
)
)
;
nativeStack
.
count
+
=
EHABIStackWalk
(
*
mcontext
vSP
sp_array
+
nativeStack
.
count
pc_array
+
nativeStack
.
count
nativeStack
.
size
-
nativeStack
.
count
)
;
memset
(
&
savedContext
0
sizeof
(
savedContext
)
)
;
savedContext
.
arm_r4
=
*
vSP
+
+
;
savedContext
.
arm_r5
=
*
vSP
+
+
;
savedContext
.
arm_r6
=
*
vSP
+
+
;
savedContext
.
arm_r7
=
*
vSP
+
+
;
savedContext
.
arm_r8
=
*
vSP
+
+
;
savedContext
.
arm_r9
=
*
vSP
+
+
;
savedContext
.
arm_r10
=
*
vSP
+
+
;
savedContext
.
arm_fp
=
*
vSP
+
+
;
savedContext
.
arm_lr
=
*
vSP
+
+
;
savedContext
.
arm_sp
=
reinterpret_cast
<
uint32_t
>
(
vSP
)
;
savedContext
.
arm_pc
=
savedContext
.
arm_lr
;
mcontext
=
&
savedContext
;
}
}
nativeStack
.
count
+
=
EHABIStackWalk
(
*
mcontext
aSample
.
mStackTop
sp_array
+
nativeStack
.
count
pc_array
+
nativeStack
.
count
nativeStack
.
size
-
nativeStack
.
count
)
;
MergeStacksIntoProfile
(
aLock
aBuffer
aSample
nativeStack
)
;
}
#
endif
#
ifdef
USE_LUL_STACKWALK
#
if
defined
(
MOZ_HAVE_ASAN_BLACKLIST
)
MOZ_ASAN_BLACKLIST
static
void
ASAN_memcpy
(
void
*
aDst
const
void
*
aSrc
size_t
aLen
)
{
char
*
dst
=
static_cast
<
char
*
>
(
aDst
)
;
const
char
*
src
=
static_cast
<
const
char
*
>
(
aSrc
)
;
for
(
size_t
i
=
0
;
i
<
aLen
;
i
+
+
)
{
dst
[
i
]
=
src
[
i
]
;
}
}
#
endif
static
void
DoNativeBacktrace
(
PS
:
:
LockRef
aLock
ProfileBuffer
*
aBuffer
const
TickSample
&
aSample
)
{
const
mcontext_t
*
mc
=
&
reinterpret_cast
<
ucontext_t
*
>
(
aSample
.
mContext
)
-
>
uc_mcontext
;
lul
:
:
UnwindRegs
startRegs
;
memset
(
&
startRegs
0
sizeof
(
startRegs
)
)
;
#
if
defined
(
GP_PLAT_amd64_linux
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RSP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RBP
]
)
;
#
elif
defined
(
GP_PLAT_arm_android
)
startRegs
.
r15
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_pc
)
;
startRegs
.
r14
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_lr
)
;
startRegs
.
r13
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_sp
)
;
startRegs
.
r12
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_ip
)
;
startRegs
.
r11
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_fp
)
;
startRegs
.
r7
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_r7
)
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_ESP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EBP
]
)
;
#
else
#
error
"
Unknown
plat
"
#
endif
lul
:
:
StackImage
stackImg
;
{
#
if
defined
(
GP_PLAT_amd64_linux
)
uintptr_t
rEDZONE_SIZE
=
128
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_arm_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
r13
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
else
#
error
"
Unknown
plat
"
#
endif
uintptr_t
end
=
reinterpret_cast
<
uintptr_t
>
(
aSample
.
mStackTop
)
;
uintptr_t
ws
=
sizeof
(
void
*
)
;
start
&
=
~
(
ws
-
1
)
;
end
&
=
~
(
ws
-
1
)
;
uintptr_t
nToCopy
=
0
;
if
(
start
<
end
)
{
nToCopy
=
end
-
start
;
if
(
nToCopy
>
lul
:
:
N_STACK_BYTES
)
nToCopy
=
lul
:
:
N_STACK_BYTES
;
}
MOZ_ASSERT
(
nToCopy
<
=
lul
:
:
N_STACK_BYTES
)
;
stackImg
.
mLen
=
nToCopy
;
stackImg
.
mStartAvma
=
start
;
if
(
nToCopy
>
0
)
{
#
if
defined
(
MOZ_HAVE_ASAN_BLACKLIST
)
ASAN_memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
#
else
memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
#
endif
(
void
)
VALGRIND_MAKE_MEM_DEFINED
(
&
stackImg
.
mContents
[
0
]
nToCopy
)
;
}
}
const
int
MAX_NATIVE_FRAMES
=
256
;
size_t
scannedFramesAllowed
=
0
;
uintptr_t
framePCs
[
MAX_NATIVE_FRAMES
]
;
uintptr_t
frameSPs
[
MAX_NATIVE_FRAMES
]
;
size_t
framesAvail
=
mozilla
:
:
ArrayLength
(
framePCs
)
;
size_t
framesUsed
=
0
;
size_t
scannedFramesAcquired
=
0
;
lul
:
:
LUL
*
lul
=
gPS
-
>
LUL
(
aLock
)
;
lul
-
>
Unwind
(
&
framePCs
[
0
]
&
frameSPs
[
0
]
&
framesUsed
&
scannedFramesAcquired
framesAvail
scannedFramesAllowed
&
startRegs
&
stackImg
)
;
NativeStack
nativeStack
=
{
reinterpret_cast
<
void
*
*
>
(
framePCs
)
reinterpret_cast
<
void
*
*
>
(
frameSPs
)
mozilla
:
:
ArrayLength
(
framePCs
)
framesUsed
}
;
MergeStacksIntoProfile
(
aLock
aBuffer
aSample
nativeStack
)
;
lul
-
>
mStats
.
mContext
+
=
1
;
lul
-
>
mStats
.
mCFI
+
=
framesUsed
-
1
-
scannedFramesAcquired
;
lul
-
>
mStats
.
mScanned
+
=
scannedFramesAcquired
;
}
#
endif
static
void
DoSampleStackTrace
(
PS
:
:
LockRef
aLock
ProfileBuffer
*
aBuffer
const
TickSample
&
aSample
)
{
NativeStack
nativeStack
=
{
nullptr
nullptr
0
0
}
;
MergeStacksIntoProfile
(
aLock
aBuffer
aSample
nativeStack
)
;
if
(
gPS
-
>
FeatureLeaf
(
aLock
)
)
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
NativeLeafAddr
(
(
void
*
)
aSample
.
mPC
)
)
;
}
}
static
void
Tick
(
PS
:
:
LockRef
aLock
ProfileBuffer
*
aBuffer
const
TickSample
&
aSample
)
{
aBuffer
-
>
addTagThreadId
(
aSample
.
mThreadId
aSample
.
mLastSample
)
;
mozilla
:
:
TimeDuration
delta
=
aSample
.
mTimeStamp
-
gPS
-
>
StartTime
(
aLock
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Time
(
delta
.
ToMilliseconds
(
)
)
)
;
NotNull
<
PseudoStack
*
>
pseudoStack
=
aSample
.
mPseudoStack
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
if
(
gPS
-
>
FeatureStackWalk
(
aLock
)
)
{
DoNativeBacktrace
(
aLock
aBuffer
aSample
)
;
}
else
#
endif
{
DoSampleStackTrace
(
aLock
aBuffer
aSample
)
;
}
if
(
!
aSample
.
mIsSynchronous
)
{
ProfilerMarkerLinkedList
*
pendingMarkersList
=
pseudoStack
-
>
getPendingMarkers
(
)
;
while
(
pendingMarkersList
&
&
pendingMarkersList
-
>
peek
(
)
)
{
ProfilerMarker
*
marker
=
pendingMarkersList
-
>
popHead
(
)
;
aBuffer
-
>
addStoredMarker
(
marker
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Marker
(
marker
)
)
;
}
}
if
(
aSample
.
mResponsiveness
&
&
aSample
.
mResponsiveness
-
>
HasData
(
)
)
{
mozilla
:
:
TimeDuration
delta
=
aSample
.
mResponsiveness
-
>
GetUnresponsiveDuration
(
aSample
.
mTimeStamp
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
Responsiveness
(
delta
.
ToMilliseconds
(
)
)
)
;
}
if
(
aSample
.
mRSSMemory
!
=
0
)
{
double
rssMemory
=
static_cast
<
double
>
(
aSample
.
mRSSMemory
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
ResidentMemory
(
rssMemory
)
)
;
}
if
(
aSample
.
mUSSMemory
!
=
0
)
{
double
ussMemory
=
static_cast
<
double
>
(
aSample
.
mUSSMemory
)
;
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
UnsharedMemory
(
ussMemory
)
)
;
}
int
frameNumber
=
gPS
-
>
FrameNumber
(
aLock
)
;
if
(
frameNumber
!
=
gPS
-
>
LatestRecordedFrameNumber
(
aLock
)
)
{
aBuffer
-
>
addTag
(
ProfileBufferEntry
:
:
FrameNumber
(
frameNumber
)
)
;
gPS
-
>
SetLatestRecordedFrameNumber
(
aLock
frameNumber
)
;
}
}
const
static
uint64_t
kJS_MAX_SAFE_UINTEGER
=
+
9007199254740991ULL
;
static
int64_t
SafeJSInteger
(
uint64_t
aValue
)
{
return
aValue
<
=
kJS_MAX_SAFE_UINTEGER
?
int64_t
(
aValue
)
:
-
1
;
}
static
void
AddSharedLibraryInfoToStream
(
JSONWriter
&
aWriter
const
SharedLibrary
&
aLib
)
{
aWriter
.
StartObjectElement
(
)
;
aWriter
.
IntProperty
(
"
start
"
SafeJSInteger
(
aLib
.
GetStart
(
)
)
)
;
aWriter
.
IntProperty
(
"
end
"
SafeJSInteger
(
aLib
.
GetEnd
(
)
)
)
;
aWriter
.
IntProperty
(
"
offset
"
SafeJSInteger
(
aLib
.
GetOffset
(
)
)
)
;
aWriter
.
StringProperty
(
"
name
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetModuleName
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
path
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetModulePath
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
debugName
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetDebugName
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
debugPath
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetDebugPath
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
breakpadId
"
aLib
.
GetBreakpadId
(
)
.
c_str
(
)
)
;
aWriter
.
StringProperty
(
"
arch
"
aLib
.
GetArch
(
)
.
c_str
(
)
)
;
aWriter
.
EndObject
(
)
;
}
void
AppendSharedLibraries
(
JSONWriter
&
aWriter
)
{
SharedLibraryInfo
info
=
SharedLibraryInfo
:
:
GetInfoForSelf
(
)
;
info
.
SortByAddress
(
)
;
for
(
size_t
i
=
0
;
i
<
info
.
GetSize
(
)
;
i
+
+
)
{
AddSharedLibraryInfoToStream
(
aWriter
info
.
GetEntry
(
i
)
)
;
}
}
#
ifdef
MOZ_TASK_TRACER
static
void
StreamNameAndThreadId
(
JSONWriter
&
aWriter
const
char
*
aName
int
aThreadId
)
{
aWriter
.
StartObjectElement
(
)
;
{
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Plugin
)
{
aWriter
.
StringProperty
(
"
name
"
"
Plugin
"
)
;
}
else
{
aWriter
.
StringProperty
(
"
name
"
aName
)
;
}
aWriter
.
IntProperty
(
"
tid
"
aThreadId
)
;
}
aWriter
.
EndObject
(
)
;
}
#
endif
static
void
StreamTaskTracer
(
PS
:
:
LockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
#
ifdef
MOZ_TASK_TRACER
aWriter
.
StartArrayProperty
(
"
data
"
)
;
{
UniquePtr
<
nsTArray
<
nsCString
>
>
data
=
mozilla
:
:
tasktracer
:
:
GetLoggedData
(
gPS
-
>
StartTime
(
aLock
)
)
;
for
(
uint32_t
i
=
0
;
i
<
data
-
>
Length
(
)
;
+
+
i
)
{
aWriter
.
StringElement
(
(
data
-
>
ElementAt
(
i
)
)
.
get
(
)
)
;
}
}
aWriter
.
EndArray
(
)
;
aWriter
.
StartArrayProperty
(
"
threads
"
)
;
{
const
PS
:
:
ThreadVector
&
liveThreads
=
gPS
-
>
LiveThreads
(
aLock
)
;
for
(
size_t
i
=
0
;
i
<
liveThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
liveThreads
.
at
(
i
)
;
StreamNameAndThreadId
(
aWriter
info
-
>
Name
(
)
info
-
>
ThreadId
(
)
)
;
}
const
PS
:
:
ThreadVector
&
deadThreads
=
gPS
-
>
DeadThreads
(
aLock
)
;
for
(
size_t
i
=
0
;
i
<
deadThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
deadThreads
.
at
(
i
)
;
StreamNameAndThreadId
(
aWriter
info
-
>
Name
(
)
info
-
>
ThreadId
(
)
)
;
}
}
aWriter
.
EndArray
(
)
;
aWriter
.
DoubleProperty
(
"
start
"
static_cast
<
double
>
(
mozilla
:
:
tasktracer
:
:
GetStartTime
(
)
)
)
;
#
endif
}
static
void
StreamMetaJSCustomObject
(
PS
:
:
LockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
aWriter
.
IntProperty
(
"
version
"
5
)
;
aWriter
.
DoubleProperty
(
"
interval
"
gPS
-
>
Interval
(
aLock
)
)
;
aWriter
.
IntProperty
(
"
stackwalk
"
gPS
-
>
FeatureStackWalk
(
aLock
)
)
;
#
ifdef
DEBUG
aWriter
.
IntProperty
(
"
debug
"
1
)
;
#
else
aWriter
.
IntProperty
(
"
debug
"
0
)
;
#
endif
aWriter
.
IntProperty
(
"
gcpoison
"
JS
:
:
IsGCPoisoning
(
)
?
1
:
0
)
;
bool
asyncStacks
=
Preferences
:
:
GetBool
(
"
javascript
.
options
.
asyncstack
"
)
;
aWriter
.
IntProperty
(
"
asyncstack
"
asyncStacks
)
;
mozilla
:
:
TimeDuration
delta
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
-
gPS
-
>
StartTime
(
aLock
)
;
aWriter
.
DoubleProperty
(
"
startTime
"
static_cast
<
double
>
(
PR_Now
(
)
/
1000
.
0
-
delta
.
ToMilliseconds
(
)
)
)
;
aWriter
.
IntProperty
(
"
processType
"
XRE_GetProcessType
(
)
)
;
nsresult
res
;
nsCOMPtr
<
nsIHttpProtocolHandler
>
http
=
do_GetService
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
"
http
"
&
res
)
;
if
(
!
NS_FAILED
(
res
)
)
{
nsAutoCString
string
;
res
=
http
-
>
GetPlatform
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
platform
"
string
.
Data
(
)
)
;
}
res
=
http
-
>
GetOscpu
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
oscpu
"
string
.
Data
(
)
)
;
}
res
=
http
-
>
GetMisc
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
misc
"
string
.
Data
(
)
)
;
}
}
nsCOMPtr
<
nsIXULRuntime
>
runtime
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
runtime
)
{
nsAutoCString
string
;
res
=
runtime
-
>
GetXPCOMABI
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
abi
"
string
.
Data
(
)
)
;
res
=
runtime
-
>
GetWidgetToolkit
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
toolkit
"
string
.
Data
(
)
)
;
}
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
)
;
if
(
appInfo
)
{
nsAutoCString
string
;
res
=
appInfo
-
>
GetName
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
product
"
string
.
Data
(
)
)
;
}
}
#
if
defined
(
PROFILE_JAVA
)
static
void
BuildJavaThreadJSObject
(
SpliceableJSONWriter
&
aWriter
)
{
aWriter
.
StringProperty
(
"
name
"
"
Java
Main
Thread
"
)
;
aWriter
.
StartArrayProperty
(
"
samples
"
)
;
{
for
(
int
sampleId
=
0
;
true
;
sampleId
+
+
)
{
bool
firstRun
=
true
;
for
(
int
frameId
=
0
;
true
;
frameId
+
+
)
{
jni
:
:
String
:
:
LocalRef
frameName
=
java
:
:
GeckoJavaSampler
:
:
GetFrameName
(
0
sampleId
frameId
)
;
if
(
!
frameName
)
{
if
(
!
firstRun
)
{
aWriter
.
EndArray
(
)
;
aWriter
.
EndObject
(
)
;
}
break
;
}
if
(
firstRun
)
{
firstRun
=
false
;
double
sampleTime
=
java
:
:
GeckoJavaSampler
:
:
GetSampleTime
(
0
sampleId
)
;
aWriter
.
StartObjectElement
(
)
;
aWriter
.
DoubleProperty
(
"
time
"
sampleTime
)
;
aWriter
.
StartArrayProperty
(
"
frames
"
)
;
}
aWriter
.
StartObjectElement
(
)
;
{
aWriter
.
StringProperty
(
"
location
"
frameName
-
>
ToCString
(
)
.
BeginReading
(
)
)
;
}
aWriter
.
EndObject
(
)
;
}
if
(
firstRun
)
{
break
;
}
}
}
aWriter
.
EndArray
(
)
;
}
#
endif
static
void
locked_profiler_stream_json_for_this_process
(
PS
:
:
LockRef
aLock
SpliceableJSONWriter
&
aWriter
double
aSinceTime
)
{
LOG
(
"
locked_profiler_stream_json_for_this_process
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
&
&
gPS
-
>
IsActive
(
aLock
)
)
;
aWriter
.
StartArrayProperty
(
"
libs
"
)
;
AppendSharedLibraries
(
aWriter
)
;
aWriter
.
EndArray
(
)
;
aWriter
.
StartObjectProperty
(
"
meta
"
)
;
{
StreamMetaJSCustomObject
(
aLock
aWriter
)
;
}
aWriter
.
EndObject
(
)
;
if
(
gPS
-
>
FeatureTaskTracer
(
aLock
)
)
{
aWriter
.
StartObjectProperty
(
"
tasktracer
"
)
;
StreamTaskTracer
(
aLock
aWriter
)
;
aWriter
.
EndObject
(
)
;
}
aWriter
.
StartArrayProperty
(
"
threads
"
)
;
{
gPS
-
>
SetIsPaused
(
aLock
true
)
;
const
PS
:
:
ThreadVector
&
liveThreads
=
gPS
-
>
LiveThreads
(
aLock
)
;
for
(
size_t
i
=
0
;
i
<
liveThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
liveThreads
.
at
(
i
)
;
if
(
!
info
-
>
HasProfile
(
)
)
{
continue
;
}
info
-
>
StreamJSON
(
gPS
-
>
Buffer
(
aLock
)
aWriter
gPS
-
>
StartTime
(
aLock
)
aSinceTime
)
;
}
const
PS
:
:
ThreadVector
&
deadThreads
=
gPS
-
>
DeadThreads
(
aLock
)
;
for
(
size_t
i
=
0
;
i
<
deadThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
deadThreads
.
at
(
i
)
;
MOZ_ASSERT
(
info
-
>
HasProfile
(
)
)
;
info
-
>
StreamJSON
(
gPS
-
>
Buffer
(
aLock
)
aWriter
gPS
-
>
StartTime
(
aLock
)
aSinceTime
)
;
}
#
if
defined
(
PROFILE_JAVA
)
if
(
gPS
-
>
FeatureJava
(
aLock
)
)
{
java
:
:
GeckoJavaSampler
:
:
Pause
(
)
;
aWriter
.
Start
(
)
;
{
BuildJavaThreadJSObject
(
aWriter
)
;
}
aWriter
.
End
(
)
;
java
:
:
GeckoJavaSampler
:
:
Unpause
(
)
;
}
#
endif
gPS
-
>
SetIsPaused
(
aLock
false
)
;
}
aWriter
.
EndArray
(
)
;
}
bool
profiler_stream_json_for_this_process
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
)
{
LOG
(
"
profiler_stream_json_for_this_process
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
false
;
}
locked_profiler_stream_json_for_this_process
(
lock
aWriter
aSinceTime
)
;
return
true
;
}
ProfilerMarker
:
:
ProfilerMarker
(
const
char
*
aMarkerName
ProfilerMarkerPayload
*
aPayload
double
aTime
)
:
mMarkerName
(
strdup
(
aMarkerName
)
)
mPayload
(
aPayload
)
mTime
(
aTime
)
{
}
ProfilerMarker
:
:
~
ProfilerMarker
(
)
{
free
(
mMarkerName
)
;
delete
mPayload
;
}
void
ProfilerMarker
:
:
SetGeneration
(
uint32_t
aGenID
)
{
mGenID
=
aGenID
;
}
double
ProfilerMarker
:
:
GetTime
(
)
const
{
return
mTime
;
}
void
ProfilerMarker
:
:
StreamJSON
(
SpliceableJSONWriter
&
aWriter
const
TimeStamp
&
aStartTime
UniqueStacks
&
aUniqueStacks
)
const
{
aWriter
.
StartArrayElement
(
)
;
{
aUniqueStacks
.
mUniqueStrings
.
WriteElement
(
aWriter
GetMarkerName
(
)
)
;
aWriter
.
DoubleElement
(
mTime
)
;
if
(
mPayload
)
{
aWriter
.
StartObjectElement
(
)
;
{
mPayload
-
>
StreamPayload
(
aWriter
aStartTime
aUniqueStacks
)
;
}
aWriter
.
EndObject
(
)
;
}
}
aWriter
.
EndArray
(
)
;
}
static
void
PrintUsageThenExit
(
int
aExitCode
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
printf
(
"
\
n
"
"
Profiler
environment
variable
usage
:
\
n
"
"
\
n
"
"
MOZ_PROFILER_HELP
\
n
"
"
If
set
to
any
value
prints
this
message
.
\
n
"
"
\
n
"
"
MOZ_LOG
\
n
"
"
Enables
logging
.
The
levels
of
logging
available
are
\
n
"
"
'
prof
:
3
'
(
least
verbose
)
'
prof
:
4
'
'
prof
:
5
'
(
most
verbose
)
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP
\
n
"
"
If
set
to
any
value
starts
the
profiler
immediately
on
start
-
up
.
\
n
"
"
Useful
if
you
want
profile
code
that
runs
very
early
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_ENTRIES
=
<
1
.
.
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
number
of
entries
in
\
n
"
"
the
profiler
'
s
circular
buffer
when
the
profiler
is
first
started
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_INTERVAL
=
<
1
.
.
1000
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
sample
interval
\
n
"
"
measured
in
milliseconds
when
the
profiler
is
first
started
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_SHUTDOWN
\
n
"
"
If
set
the
profiler
saves
a
profile
to
the
named
file
on
shutdown
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_LUL_TEST
\
n
"
"
If
set
to
any
value
runs
LUL
unit
tests
at
startup
.
\
n
"
"
\
n
"
"
This
platform
%
s
native
unwinding
.
\
n
"
"
\
n
"
#
if
defined
(
HAVE_NATIVE_UNWIND
)
"
supports
"
#
else
"
does
not
support
"
#
endif
)
;
exit
(
aExitCode
)
;
}
static
void
SleepMicro
(
int
aMicroseconds
)
;
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
struct
SigHandlerCoordinator
;
#
endif
class
SamplerThread
{
public
:
SamplerThread
(
PS
:
:
LockRef
aLock
uint32_t
aActivityGeneration
double
aIntervalMilliseconds
)
;
~
SamplerThread
(
)
;
void
SuspendAndSampleAndResumeThread
(
PS
:
:
LockRef
aLock
TickSample
&
aSample
)
;
void
Run
(
)
;
void
Stop
(
PS
:
:
LockRef
aLock
)
;
private
:
const
uint32_t
mActivityGeneration
;
const
int
mIntervalMicroseconds
;
#
if
defined
(
GP_OS_windows
)
HANDLE
mThread
;
#
elif
defined
(
GP_OS_darwin
)
|
|
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
pthread_t
mThread
;
#
endif
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
struct
sigaction
mOldSigprofHandler
;
int
mMyPid
;
public
:
int
mSamplerTid
;
static
struct
SigHandlerCoordinator
*
sSigHandlerCoordinator
;
#
endif
private
:
SamplerThread
(
const
SamplerThread
&
)
=
delete
;
void
operator
=
(
const
SamplerThread
&
)
=
delete
;
}
;
void
SamplerThread
:
:
Run
(
)
{
TimeDuration
lastSleepOvershoot
=
0
;
TimeStamp
sampleStart
=
TimeStamp
:
:
Now
(
)
;
while
(
true
)
{
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
PS
:
:
ActivityGeneration
(
lock
)
!
=
mActivityGeneration
)
{
return
;
}
gPS
-
>
Buffer
(
lock
)
-
>
deleteExpiredStoredMarkers
(
)
;
if
(
!
gPS
-
>
IsPaused
(
lock
)
)
{
const
PS
:
:
ThreadVector
&
liveThreads
=
gPS
-
>
LiveThreads
(
lock
)
;
for
(
uint32_t
i
=
0
;
i
<
liveThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
liveThreads
[
i
]
;
if
(
!
info
-
>
HasProfile
(
)
)
{
continue
;
}
if
(
info
-
>
Stack
(
)
-
>
CanDuplicateLastSampleDueToSleep
(
)
)
{
bool
dup_ok
=
gPS
-
>
Buffer
(
lock
)
-
>
DuplicateLastSample
(
info
-
>
ThreadId
(
)
gPS
-
>
StartTime
(
lock
)
info
-
>
LastSample
(
)
)
;
if
(
dup_ok
)
{
continue
;
}
}
if
(
info
-
>
IsMainThread
(
)
)
{
info
-
>
GetThreadResponsiveness
(
)
-
>
Update
(
)
;
}
int64_t
rssMemory
=
0
;
int64_t
ussMemory
=
0
;
if
(
i
=
=
0
&
&
gPS
-
>
FeatureMemory
(
lock
)
)
{
rssMemory
=
nsMemoryReporterManager
:
:
ResidentFast
(
)
;
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
ussMemory
=
nsMemoryReporterManager
:
:
ResidentUnique
(
)
;
#
endif
}
TickSample
sample
(
info
rssMemory
ussMemory
)
;
SuspendAndSampleAndResumeThread
(
lock
sample
)
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
gPS
-
>
LUL
(
lock
)
-
>
MaybeShowStats
(
)
;
#
endif
}
}
TimeStamp
targetSleepEndTime
=
sampleStart
+
TimeDuration
:
:
FromMicroseconds
(
mIntervalMicroseconds
)
;
TimeStamp
beforeSleep
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
targetSleepDuration
=
targetSleepEndTime
-
beforeSleep
;
double
sleepTime
=
std
:
:
max
(
0
.
0
(
targetSleepDuration
-
lastSleepOvershoot
)
.
ToMicroseconds
(
)
)
;
SleepMicro
(
static_cast
<
int
>
(
sleepTime
)
)
;
sampleStart
=
TimeStamp
:
:
Now
(
)
;
lastSleepOvershoot
=
sampleStart
-
(
beforeSleep
+
TimeDuration
:
:
FromMicroseconds
(
sleepTime
)
)
;
}
}
#
if
defined
(
GP_OS_windows
)
#
include
"
platform
-
win32
.
cpp
"
#
elif
defined
(
GP_OS_darwin
)
#
include
"
platform
-
macos
.
cpp
"
#
elif
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
#
include
"
platform
-
linux
-
android
.
cpp
"
#
else
#
error
"
bad
platform
"
#
endif
UniquePlatformData
AllocPlatformData
(
int
aThreadId
)
{
return
UniquePlatformData
(
new
PlatformData
(
aThreadId
)
)
;
}
void
PlatformDataDestructor
:
:
operator
(
)
(
PlatformData
*
aData
)
{
delete
aData
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
GeckoProfilerMallocSizeOf
)
NS_IMETHODIMP
GeckoProfilerReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
size_t
profSize
=
0
;
#
if
defined
(
USE_LUL_STACKWALK
)
size_t
lulSize
=
0
;
#
endif
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
gPS
)
{
profSize
=
GeckoProfilerMallocSizeOf
(
gPS
)
;
const
PS
:
:
ThreadVector
&
liveThreads
=
gPS
-
>
LiveThreads
(
lock
)
;
for
(
uint32_t
i
=
0
;
i
<
liveThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
liveThreads
.
at
(
i
)
;
profSize
+
=
info
-
>
SizeOfIncludingThis
(
GeckoProfilerMallocSizeOf
)
;
}
const
PS
:
:
ThreadVector
&
deadThreads
=
gPS
-
>
DeadThreads
(
lock
)
;
for
(
uint32_t
i
=
0
;
i
<
deadThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
deadThreads
.
at
(
i
)
;
profSize
+
=
info
-
>
SizeOfIncludingThis
(
GeckoProfilerMallocSizeOf
)
;
}
if
(
gPS
-
>
IsActive
(
lock
)
)
{
profSize
+
=
gPS
-
>
Buffer
(
lock
)
-
>
SizeOfIncludingThis
(
GeckoProfilerMallocSizeOf
)
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
lul
:
:
LUL
*
lul
=
gPS
-
>
LUL
(
lock
)
;
lulSize
=
lul
?
lul
-
>
SizeOfIncludingThis
(
GeckoProfilerMallocSizeOf
)
:
0
;
#
endif
}
}
MOZ_COLLECT_REPORT
(
"
explicit
/
profiler
/
profiler
-
state
"
KIND_HEAP
UNITS_BYTES
profSize
"
Memory
used
by
the
Gecko
Profiler
'
s
ProfilerState
object
(
excluding
"
"
memory
used
by
LUL
)
.
"
)
;
#
if
defined
(
USE_LUL_STACKWALK
)
MOZ_COLLECT_REPORT
(
"
explicit
/
profiler
/
lul
"
KIND_HEAP
UNITS_BYTES
lulSize
"
Memory
used
by
LUL
a
stack
unwinder
used
by
the
Gecko
Profiler
.
"
)
;
#
endif
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
GeckoProfilerReporter
nsIMemoryReporter
)
static
bool
ThreadSelected
(
PS
:
:
LockRef
aLock
const
char
*
aThreadName
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
const
Vector
<
std
:
:
string
>
&
threadNameFilters
=
gPS
-
>
ThreadNameFilters
(
aLock
)
;
if
(
threadNameFilters
.
empty
(
)
)
{
return
true
;
}
std
:
:
string
name
=
aThreadName
;
std
:
:
transform
(
name
.
begin
(
)
name
.
end
(
)
name
.
begin
(
)
:
:
tolower
)
;
for
(
uint32_t
i
=
0
;
i
<
threadNameFilters
.
length
(
)
;
+
+
i
)
{
std
:
:
string
filter
=
threadNameFilters
[
i
]
;
std
:
:
transform
(
filter
.
begin
(
)
filter
.
end
(
)
filter
.
begin
(
)
:
:
tolower
)
;
if
(
name
.
find
(
filter
)
!
=
std
:
:
string
:
:
npos
)
{
return
true
;
}
}
return
false
;
}
static
bool
ShouldProfileThread
(
PS
:
:
LockRef
aLock
ThreadInfo
*
aInfo
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
return
(
(
aInfo
-
>
IsMainThread
(
)
|
|
gPS
-
>
FeatureThreads
(
aLock
)
)
&
&
ThreadSelected
(
aLock
aInfo
-
>
Name
(
)
)
)
;
}
static
ThreadInfo
*
FindLiveThreadInfo
(
PS
:
:
LockRef
aLock
int
*
aIndexOut
=
nullptr
)
{
Thread
:
:
tid_t
id
=
Thread
:
:
GetCurrentId
(
)
;
const
PS
:
:
ThreadVector
&
liveThreads
=
gPS
-
>
LiveThreads
(
aLock
)
;
for
(
uint32_t
i
=
0
;
i
<
liveThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
liveThreads
.
at
(
i
)
;
if
(
info
-
>
ThreadId
(
)
=
=
id
)
{
if
(
aIndexOut
)
{
*
aIndexOut
=
i
;
}
return
info
;
}
}
return
nullptr
;
}
static
void
locked_register_thread
(
PS
:
:
LockRef
aLock
const
char
*
aName
void
*
stackTop
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
MOZ_RELEASE_ASSERT
(
!
FindLiveThreadInfo
(
aLock
)
)
;
if
(
!
tlsPseudoStack
.
init
(
)
)
{
return
;
}
ThreadInfo
*
info
=
new
ThreadInfo
(
aName
Thread
:
:
GetCurrentId
(
)
NS_IsMainThread
(
)
stackTop
)
;
NotNull
<
PseudoStack
*
>
pseudoStack
=
info
-
>
Stack
(
)
;
tlsPseudoStack
.
set
(
pseudoStack
.
get
(
)
)
;
if
(
ShouldProfileThread
(
aLock
info
)
)
{
info
-
>
SetHasProfile
(
)
;
if
(
gPS
-
>
IsActive
(
aLock
)
&
&
gPS
-
>
FeatureJS
(
aLock
)
)
{
pseudoStack
-
>
startJSSampling
(
)
;
pseudoStack
-
>
pollJSSampling
(
)
;
}
}
gPS
-
>
LiveThreads
(
aLock
)
.
push_back
(
info
)
;
}
static
void
NotifyProfilerStarted
(
const
int
aEntries
double
aInterval
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
*
aThreadNameFilters
uint32_t
aFilterCount
)
{
if
(
!
CanNotifyObservers
(
)
)
{
return
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
;
}
nsTArray
<
nsCString
>
featuresArray
;
for
(
size_t
i
=
0
;
i
<
aFeatureCount
;
+
+
i
)
{
featuresArray
.
AppendElement
(
aFeatures
[
i
]
)
;
}
nsTArray
<
nsCString
>
threadNameFiltersArray
;
for
(
size_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
threadNameFiltersArray
.
AppendElement
(
aThreadNameFilters
[
i
]
)
;
}
nsCOMPtr
<
nsIProfilerStartParams
>
params
=
new
nsProfilerStartParams
(
aEntries
aInterval
featuresArray
threadNameFiltersArray
)
;
os
-
>
NotifyObservers
(
params
"
profiler
-
started
"
nullptr
)
;
}
static
void
NotifyObservers
(
const
char
*
aTopic
)
{
if
(
!
CanNotifyObservers
(
)
)
{
return
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
;
}
os
-
>
NotifyObservers
(
nullptr
aTopic
nullptr
)
;
}
static
void
locked_profiler_start
(
PS
:
:
LockRef
aLock
const
int
aEntries
double
aInterval
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
*
aThreadNameFilters
uint32_t
aFilterCount
)
;
void
profiler_init
(
void
*
aStackTop
)
{
LOG
(
"
profiler_init
"
)
;
MOZ_RELEASE_ASSERT
(
!
gPS
)
;
const
char
*
features
[
]
=
{
"
js
"
#
if
defined
(
PROFILE_JAVA
)
"
java
"
#
endif
"
leaf
"
#
if
defined
(
HAVE_NATIVE_UNWIND
)
"
stackwalk
"
#
endif
"
threads
"
}
;
const
char
*
threadFilters
[
]
=
{
"
GeckoMain
"
"
Compositor
"
}
;
if
(
getenv
(
"
MOZ_PROFILER_HELP
"
)
)
{
PrintUsageThenExit
(
0
)
;
}
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
gPS
=
new
PS
(
)
;
bool
ignore
;
gPS
-
>
SetStartTime
(
lock
mozilla
:
:
TimeStamp
:
:
ProcessCreation
(
ignore
)
)
;
locked_register_thread
(
lock
kMainThreadName
aStackTop
)
;
PlatformInit
(
lock
)
;
#
ifdef
MOZ_TASK_TRACER
mozilla
:
:
tasktracer
:
:
InitTaskTracer
(
)
;
#
endif
#
if
defined
(
PROFILE_JAVA
)
if
(
mozilla
:
:
jni
:
:
IsFennec
(
)
)
{
GeckoJavaSampler
:
:
Init
(
)
;
}
#
endif
if
(
!
getenv
(
"
MOZ_PROFILER_STARTUP
"
)
)
{
return
;
}
LOG
(
"
-
MOZ_PROFILER_STARTUP
is
set
"
)
;
int
entries
=
PROFILE_DEFAULT_ENTRIES
;
const
char
*
startupEntries
=
getenv
(
"
MOZ_PROFILER_STARTUP_ENTRIES
"
)
;
if
(
startupEntries
)
{
errno
=
0
;
entries
=
strtol
(
startupEntries
nullptr
10
)
;
if
(
errno
=
=
0
&
&
entries
>
0
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_ENTRIES
=
%
d
"
entries
)
;
}
else
{
PrintUsageThenExit
(
1
)
;
}
}
int
interval
=
PROFILE_DEFAULT_INTERVAL
;
const
char
*
startupInterval
=
getenv
(
"
MOZ_PROFILER_STARTUP_INTERVAL
"
)
;
if
(
startupInterval
)
{
errno
=
0
;
interval
=
strtol
(
startupInterval
nullptr
10
)
;
if
(
errno
=
=
0
&
&
1
<
=
interval
&
&
interval
<
=
1000
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_INTERVAL
=
%
d
"
interval
)
;
}
else
{
PrintUsageThenExit
(
1
)
;
}
}
locked_profiler_start
(
lock
entries
interval
features
MOZ_ARRAY_LENGTH
(
features
)
threadFilters
MOZ_ARRAY_LENGTH
(
threadFilters
)
)
;
}
NotifyProfilerStarted
(
PROFILE_DEFAULT_ENTRIES
PROFILE_DEFAULT_INTERVAL
features
MOZ_ARRAY_LENGTH
(
features
)
threadFilters
MOZ_ARRAY_LENGTH
(
threadFilters
)
)
;
}
static
void
locked_profiler_save_profile_to_file
(
PS
:
:
LockRef
aLock
const
char
*
aFilename
)
;
static
SamplerThread
*
locked_profiler_stop
(
PS
:
:
LockRef
aLock
)
;
void
profiler_shutdown
(
)
{
LOG
(
"
profiler_shutdown
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
gPS
-
>
IsActive
(
lock
)
)
{
const
char
*
filename
=
getenv
(
"
MOZ_PROFILER_SHUTDOWN
"
)
;
if
(
filename
)
{
locked_profiler_save_profile_to_file
(
lock
filename
)
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
PS
:
:
ThreadVector
&
liveThreads
=
gPS
-
>
LiveThreads
(
lock
)
;
while
(
liveThreads
.
size
(
)
>
0
)
{
delete
liveThreads
.
back
(
)
;
liveThreads
.
pop_back
(
)
;
}
PS
:
:
ThreadVector
&
deadThreads
=
gPS
-
>
DeadThreads
(
lock
)
;
while
(
deadThreads
.
size
(
)
>
0
)
{
delete
deadThreads
.
back
(
)
;
deadThreads
.
pop_back
(
)
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
lul
:
:
LUL
*
lul
=
gPS
-
>
LUL
(
lock
)
;
if
(
lul
)
{
delete
lul
;
gPS
-
>
SetLUL
(
lock
nullptr
)
;
}
#
endif
delete
gPS
;
gPS
=
nullptr
;
tlsPseudoStack
.
set
(
nullptr
)
;
#
ifdef
MOZ_TASK_TRACER
mozilla
:
:
tasktracer
:
:
ShutdownTaskTracer
(
)
;
#
endif
}
if
(
samplerThread
)
{
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
}
UniquePtr
<
char
[
]
>
profiler_get_profile
(
double
aSinceTime
)
{
LOG
(
"
profiler_get_profile
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
SpliceableChunkedJSONWriter
b
;
b
.
Start
(
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
{
if
(
!
profiler_stream_json_for_this_process
(
b
aSinceTime
)
)
{
return
nullptr
;
}
b
.
StartArrayProperty
(
"
processes
"
)
;
b
.
EndArray
(
)
;
}
b
.
End
(
)
;
return
b
.
WriteFunc
(
)
-
>
CopyData
(
)
;
}
void
profiler_get_start_params
(
int
*
aEntries
double
*
aInterval
mozilla
:
:
Vector
<
const
char
*
>
*
aFeatures
mozilla
:
:
Vector
<
const
char
*
>
*
aFilters
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
if
(
NS_WARN_IF
(
!
aEntries
)
|
|
NS_WARN_IF
(
!
aInterval
)
|
|
NS_WARN_IF
(
!
aFeatures
)
|
|
NS_WARN_IF
(
!
aFilters
)
)
{
return
;
}
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
*
aEntries
=
gPS
-
>
Entries
(
lock
)
;
*
aInterval
=
gPS
-
>
Interval
(
lock
)
;
const
Vector
<
std
:
:
string
>
&
features
=
gPS
-
>
Features
(
lock
)
;
MOZ_ALWAYS_TRUE
(
aFeatures
-
>
resize
(
features
.
length
(
)
)
)
;
for
(
size_t
i
=
0
;
i
<
features
.
length
(
)
;
+
+
i
)
{
(
*
aFeatures
)
[
i
]
=
features
[
i
]
.
c_str
(
)
;
}
const
Vector
<
std
:
:
string
>
&
threadNameFilters
=
gPS
-
>
ThreadNameFilters
(
lock
)
;
MOZ_ALWAYS_TRUE
(
aFilters
-
>
resize
(
threadNameFilters
.
length
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
threadNameFilters
.
length
(
)
;
+
+
i
)
{
(
*
aFilters
)
[
i
]
=
threadNameFilters
[
i
]
.
c_str
(
)
;
}
}
static
void
locked_profiler_save_profile_to_file
(
PS
:
:
LockRef
aLock
const
char
*
aFilename
)
{
LOG
(
"
locked_profiler_save_profile_to_file
(
%
s
)
"
aFilename
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
&
&
gPS
-
>
IsActive
(
aLock
)
)
;
std
:
:
ofstream
stream
;
stream
.
open
(
aFilename
)
;
if
(
stream
.
is_open
(
)
)
{
SpliceableJSONWriter
w
(
mozilla
:
:
MakeUnique
<
OStreamJSONWriteFunc
>
(
stream
)
)
;
w
.
Start
(
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
{
locked_profiler_stream_json_for_this_process
(
aLock
w
0
)
;
w
.
StartArrayProperty
(
"
processes
"
)
;
w
.
EndArray
(
)
;
}
w
.
End
(
)
;
stream
.
close
(
)
;
}
}
void
profiler_save_profile_to_file
(
const
char
*
aFilename
)
{
LOG
(
"
profiler_save_profile_to_file
(
%
s
)
"
aFilename
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
;
}
locked_profiler_save_profile_to_file
(
lock
aFilename
)
;
}
const
char
*
*
profiler_get_features
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
static
const
char
*
features
[
]
=
{
#
if
defined
(
HAVE_NATIVE_UNWIND
)
"
stackwalk
"
#
endif
"
leaf
"
"
java
"
"
js
"
"
gpu
"
"
threads
"
"
privacy
"
"
layersdump
"
"
displaylistdump
"
"
mainthreadio
"
"
memory
"
"
restyle
"
#
ifdef
MOZ_TASK_TRACER
"
tasktracer
"
#
endif
nullptr
}
;
return
features
;
}
void
profiler_get_buffer_info_helper
(
uint32_t
*
aCurrentPosition
uint32_t
*
aEntries
uint32_t
*
aGeneration
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
;
}
*
aCurrentPosition
=
gPS
-
>
Buffer
(
lock
)
-
>
mWritePos
;
*
aEntries
=
gPS
-
>
Entries
(
lock
)
;
*
aGeneration
=
gPS
-
>
Buffer
(
lock
)
-
>
mGeneration
;
}
static
bool
hasFeature
(
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
aFeature
)
{
for
(
size_t
i
=
0
;
i
<
aFeatureCount
;
i
+
+
)
{
if
(
strcmp
(
aFeatures
[
i
]
aFeature
)
=
=
0
)
{
return
true
;
}
}
return
false
;
}
static
void
locked_profiler_start
(
PS
:
:
LockRef
aLock
int
aEntries
double
aInterval
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
*
aThreadNameFilters
uint32_t
aFilterCount
)
{
if
(
LOG_TEST
)
{
LOG
(
"
locked_profiler_start
"
)
;
LOG
(
"
-
entries
=
%
d
"
aEntries
)
;
LOG
(
"
-
interval
=
%
.
2f
"
aInterval
)
;
for
(
uint32_t
i
=
0
;
i
<
aFeatureCount
;
i
+
+
)
{
LOG
(
"
-
feature
=
%
s
"
aFeatures
[
i
]
)
;
}
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
i
+
+
)
{
LOG
(
"
-
threads
=
%
s
"
aThreadNameFilters
[
i
]
)
;
}
}
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
&
&
!
gPS
-
>
IsActive
(
aLock
)
)
;
bool
ignore
;
gPS
-
>
SetStartTime
(
aLock
mozilla
:
:
TimeStamp
:
:
ProcessCreation
(
ignore
)
)
;
int
entries
=
aEntries
>
0
?
aEntries
:
PROFILE_DEFAULT_ENTRIES
;
gPS
-
>
SetEntries
(
aLock
entries
)
;
double
interval
=
aInterval
>
0
?
aInterval
:
PROFILE_DEFAULT_INTERVAL
;
gPS
-
>
SetInterval
(
aLock
interval
)
;
Vector
<
std
:
:
string
>
&
features
=
gPS
-
>
Features
(
aLock
)
;
MOZ_ALWAYS_TRUE
(
features
.
resize
(
aFeatureCount
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aFeatureCount
;
+
+
i
)
{
features
[
i
]
=
aFeatures
[
i
]
;
}
Vector
<
std
:
:
string
>
&
threadNameFilters
=
gPS
-
>
ThreadNameFilters
(
aLock
)
;
MOZ_ALWAYS_TRUE
(
threadNameFilters
.
resize
(
aFilterCount
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
threadNameFilters
[
i
]
=
aThreadNameFilters
[
i
]
;
}
#
define
HAS_FEATURE
(
feature
)
hasFeature
(
aFeatures
aFeatureCount
feature
)
gPS
-
>
SetFeatureDisplayListDump
(
aLock
HAS_FEATURE
(
"
displaylistdump
"
)
)
;
gPS
-
>
SetFeatureGPU
(
aLock
HAS_FEATURE
(
"
gpu
"
)
)
;
#
if
defined
(
PROFILE_JAVA
)
gPS
-
>
SetFeatureJava
(
aLock
mozilla
:
:
jni
:
:
IsFennec
(
)
&
&
HAS_FEATURE
(
"
java
"
)
)
;
#
endif
bool
featureJS
=
HAS_FEATURE
(
"
js
"
)
;
gPS
-
>
SetFeatureJS
(
aLock
featureJS
)
;
gPS
-
>
SetFeatureLayersDump
(
aLock
HAS_FEATURE
(
"
layersdump
"
)
)
;
gPS
-
>
SetFeatureLeaf
(
aLock
HAS_FEATURE
(
"
leaf
"
)
)
;
bool
featureMainThreadIO
=
HAS_FEATURE
(
"
mainthreadio
"
)
;
gPS
-
>
SetFeatureMemory
(
aLock
HAS_FEATURE
(
"
memory
"
)
)
;
gPS
-
>
SetFeaturePrivacy
(
aLock
HAS_FEATURE
(
"
privacy
"
)
)
;
gPS
-
>
SetFeatureRestyle
(
aLock
HAS_FEATURE
(
"
restyle
"
)
)
;
gPS
-
>
SetFeatureStackWalk
(
aLock
HAS_FEATURE
(
"
stackwalk
"
)
)
;
#
ifdef
MOZ_TASK_TRACER
bool
featureTaskTracer
=
HAS_FEATURE
(
"
tasktracer
"
)
;
gPS
-
>
SetFeatureTaskTracer
(
aLock
featureTaskTracer
)
;
#
endif
gPS
-
>
SetFeatureThreads
(
aLock
HAS_FEATURE
(
"
threads
"
)
|
|
aFilterCount
>
0
)
;
#
undef
HAS_FEATURE
gPS
-
>
SetBuffer
(
aLock
new
ProfileBuffer
(
entries
)
)
;
const
PS
:
:
ThreadVector
&
liveThreads
=
gPS
-
>
LiveThreads
(
aLock
)
;
for
(
uint32_t
i
=
0
;
i
<
liveThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
liveThreads
.
at
(
i
)
;
if
(
ShouldProfileThread
(
aLock
info
)
)
{
info
-
>
SetHasProfile
(
)
;
info
-
>
Stack
(
)
-
>
reinitializeOnResume
(
)
;
if
(
featureJS
)
{
info
-
>
Stack
(
)
-
>
startJSSampling
(
)
;
}
}
}
MOZ_RELEASE_ASSERT
(
gPS
-
>
DeadThreads
(
aLock
)
.
empty
(
)
)
;
if
(
featureJS
)
{
if
(
PseudoStack
*
pseudoStack
=
tlsPseudoStack
.
get
(
)
)
{
pseudoStack
-
>
pollJSSampling
(
)
;
}
}
#
ifdef
MOZ_TASK_TRACER
if
(
featureTaskTracer
)
{
mozilla
:
:
tasktracer
:
:
StartLogging
(
)
;
}
#
endif
#
if
defined
(
PROFILE_JAVA
)
if
(
gPS
-
>
FeatureJava
(
aLock
)
)
{
int
javaInterval
=
interval
;
if
(
javaInterval
<
10
)
{
javaInterval
=
10
;
}
mozilla
:
:
java
:
:
GeckoJavaSampler
:
:
Start
(
javaInterval
1000
)
;
}
#
endif
PS
:
:
SetActive
(
aLock
)
;
gPS
-
>
SetIsPaused
(
aLock
false
)
;
gPS
-
>
SetSamplerThread
(
aLock
new
SamplerThread
(
aLock
PS
:
:
ActivityGeneration
(
aLock
)
interval
)
)
;
if
(
featureMainThreadIO
)
{
auto
interposeObserver
=
new
mozilla
:
:
ProfilerIOInterposeObserver
(
)
;
gPS
-
>
SetInterposeObserver
(
aLock
interposeObserver
)
;
mozilla
:
:
IOInterposer
:
:
Register
(
mozilla
:
:
IOInterposeObserver
:
:
OpAll
interposeObserver
)
;
}
}
void
profiler_start
(
int
aEntries
double
aInterval
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
*
aThreadNameFilters
uint32_t
aFilterCount
)
{
LOG
(
"
profiler_start
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
)
{
profiler_init
(
nullptr
)
;
}
if
(
gPS
-
>
IsActive
(
lock
)
)
{
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
locked_profiler_start
(
lock
aEntries
aInterval
aFeatures
aFeatureCount
aThreadNameFilters
aFilterCount
)
;
}
if
(
samplerThread
)
{
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
NotifyProfilerStarted
(
aEntries
aInterval
aFeatures
aFeatureCount
aThreadNameFilters
aFilterCount
)
;
}
static
MOZ_MUST_USE
SamplerThread
*
locked_profiler_stop
(
PS
:
:
LockRef
aLock
)
{
LOG
(
"
locked_profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
&
&
gPS
-
>
IsActive
(
aLock
)
)
;
mozilla
:
:
IOInterposer
:
:
Unregister
(
mozilla
:
:
IOInterposeObserver
:
:
OpAll
gPS
-
>
InterposeObserver
(
aLock
)
)
;
gPS
-
>
SetInterposeObserver
(
aLock
nullptr
)
;
SamplerThread
*
samplerThread
=
gPS
-
>
SamplerThread
(
aLock
)
;
samplerThread
-
>
Stop
(
aLock
)
;
gPS
-
>
SetSamplerThread
(
aLock
nullptr
)
;
gPS
-
>
SetIsPaused
(
aLock
false
)
;
gPS
-
>
SetInactive
(
aLock
)
;
#
ifdef
MOZ_TASK_TRACER
if
(
gPS
-
>
FeatureTaskTracer
(
aLock
)
)
{
mozilla
:
:
tasktracer
:
:
StopLogging
(
)
;
}
#
endif
if
(
gPS
-
>
FeatureJS
(
aLock
)
)
{
PS
:
:
ThreadVector
&
liveThreads
=
gPS
-
>
LiveThreads
(
aLock
)
;
for
(
uint32_t
i
=
0
;
i
<
liveThreads
.
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
liveThreads
.
at
(
i
)
;
if
(
ShouldProfileThread
(
aLock
info
)
)
{
MOZ_RELEASE_ASSERT
(
info
-
>
HasProfile
(
)
)
;
info
-
>
Stack
(
)
-
>
stopJSSampling
(
)
;
}
}
}
PS
:
:
ThreadVector
&
deadThreads
=
gPS
-
>
DeadThreads
(
aLock
)
;
while
(
deadThreads
.
size
(
)
>
0
)
{
delete
deadThreads
.
back
(
)
;
deadThreads
.
pop_back
(
)
;
}
if
(
gPS
-
>
FeatureJS
(
aLock
)
)
{
if
(
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
)
{
stack
-
>
pollJSSampling
(
)
;
}
}
delete
gPS
-
>
Buffer
(
aLock
)
;
gPS
-
>
SetBuffer
(
aLock
nullptr
)
;
gPS
-
>
SetFeatureDisplayListDump
(
aLock
false
)
;
gPS
-
>
SetFeatureGPU
(
aLock
false
)
;
gPS
-
>
SetFeatureJava
(
aLock
false
)
;
gPS
-
>
SetFeatureJS
(
aLock
false
)
;
gPS
-
>
SetFeatureLayersDump
(
aLock
false
)
;
gPS
-
>
SetFeatureLeaf
(
aLock
false
)
;
gPS
-
>
SetFeatureMemory
(
aLock
false
)
;
gPS
-
>
SetFeaturePrivacy
(
aLock
false
)
;
gPS
-
>
SetFeatureRestyle
(
aLock
false
)
;
gPS
-
>
SetFeatureStackWalk
(
aLock
false
)
;
gPS
-
>
SetFeatureTaskTracer
(
aLock
false
)
;
gPS
-
>
SetFeatureThreads
(
aLock
false
)
;
gPS
-
>
ThreadNameFilters
(
aLock
)
.
clear
(
)
;
gPS
-
>
Features
(
aLock
)
.
clear
(
)
;
gPS
-
>
SetInterval
(
aLock
0
.
0
)
;
gPS
-
>
SetEntries
(
aLock
0
)
;
return
samplerThread
;
}
void
profiler_stop
(
)
{
LOG
(
"
profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
SamplerThread
*
samplerThread
;
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
bool
profiler_is_paused
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
false
;
}
return
gPS
-
>
IsPaused
(
lock
)
;
}
void
profiler_pause
(
)
{
LOG
(
"
profiler_pause
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
;
}
gPS
-
>
SetIsPaused
(
lock
true
)
;
}
NotifyObservers
(
"
profiler
-
paused
"
)
;
}
void
profiler_resume
(
)
{
LOG
(
"
profiler_resume
"
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
{
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
;
}
gPS
-
>
SetIsPaused
(
lock
false
)
;
}
NotifyObservers
(
"
profiler
-
resumed
"
)
;
}
bool
profiler_feature_active
(
const
char
*
aName
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
)
{
return
false
;
}
if
(
strcmp
(
aName
"
displaylistdump
"
)
=
=
0
)
{
return
gPS
-
>
FeatureDisplayListDump
(
lock
)
;
}
if
(
strcmp
(
aName
"
gpu
"
)
=
=
0
)
{
return
gPS
-
>
FeatureGPU
(
lock
)
;
}
if
(
strcmp
(
aName
"
layersdump
"
)
=
=
0
)
{
return
gPS
-
>
FeatureLayersDump
(
lock
)
;
}
if
(
strcmp
(
aName
"
restyle
"
)
=
=
0
)
{
return
gPS
-
>
FeatureRestyle
(
lock
)
;
}
return
false
;
}
bool
profiler_is_active
(
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
return
gPS
-
>
IsActive
(
lock
)
;
}
void
profiler_set_frame_number
(
int
aFrameNumber
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
gPS
-
>
SetFrameNumber
(
lock
aFrameNumber
)
;
}
void
profiler_register_thread
(
const
char
*
aName
void
*
aGuessStackTop
)
{
DEBUG_LOG
(
"
profiler_register_thread
(
%
s
)
"
aName
)
;
MOZ_RELEASE_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
void
*
stackTop
=
GetStackTop
(
aGuessStackTop
)
;
locked_register_thread
(
lock
aName
stackTop
)
;
}
void
profiler_unregister_thread
(
)
{
MOZ_RELEASE_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
int
i
;
ThreadInfo
*
info
=
FindLiveThreadInfo
(
lock
&
i
)
;
if
(
info
)
{
DEBUG_LOG
(
"
profiler_unregister_thread
:
%
s
"
info
-
>
Name
(
)
)
;
if
(
gPS
-
>
IsActive
(
lock
)
&
&
info
-
>
HasProfile
(
)
)
{
gPS
-
>
DeadThreads
(
lock
)
.
push_back
(
info
)
;
}
else
{
delete
info
;
}
PS
:
:
ThreadVector
&
liveThreads
=
gPS
-
>
LiveThreads
(
lock
)
;
liveThreads
.
erase
(
liveThreads
.
begin
(
)
+
i
)
;
tlsPseudoStack
.
set
(
nullptr
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
!
tlsPseudoStack
.
get
(
)
)
;
}
}
void
profiler_thread_sleep
(
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
stack
)
{
return
;
}
stack
-
>
setSleeping
(
)
;
}
void
profiler_thread_wake
(
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
stack
)
{
return
;
}
stack
-
>
setAwake
(
)
;
}
bool
profiler_thread_is_sleeping
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
stack
)
{
return
false
;
}
return
stack
-
>
isSleeping
(
)
;
}
void
profiler_js_interrupt_callback
(
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
stack
)
{
return
;
}
stack
-
>
pollJSSampling
(
)
;
}
double
profiler_time
(
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
mozilla
:
:
TimeDuration
delta
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
-
gPS
-
>
StartTime
(
lock
)
;
return
delta
.
ToMilliseconds
(
)
;
}
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
|
|
gPS
-
>
FeaturePrivacy
(
lock
)
)
{
return
nullptr
;
}
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
stack
)
{
MOZ_ASSERT
(
stack
)
;
return
nullptr
;
}
Thread
:
:
tid_t
tid
=
Thread
:
:
GetCurrentId
(
)
;
ProfileBuffer
*
buffer
=
new
ProfileBuffer
(
GET_BACKTRACE_DEFAULT_ENTRIES
)
;
UniquePlatformData
platformData
=
AllocPlatformData
(
tid
)
;
TickSample
sample
(
WrapNotNull
(
stack
)
platformData
.
get
(
)
)
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
#
if
defined
(
GP_OS_windows
)
|
|
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
tick_context_t
context
;
sample
.
PopulateContext
(
&
context
)
;
#
elif
defined
(
GP_OS_darwin
)
sample
.
PopulateContext
(
nullptr
)
;
#
else
#
error
"
unknown
platform
"
#
endif
#
endif
Tick
(
lock
buffer
sample
)
;
return
UniqueProfilerBacktrace
(
new
ProfilerBacktrace
(
"
SyncProfile
"
tid
buffer
)
)
;
}
void
ProfilerBacktraceDestructor
:
:
operator
(
)
(
ProfilerBacktrace
*
aBacktrace
)
{
delete
aBacktrace
;
}
void
profiler_get_backtrace_noalloc
(
char
*
output
size_t
outputSize
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
gPS
)
;
MOZ_ASSERT
(
outputSize
>
=
2
)
;
char
*
bound
=
output
+
outputSize
-
2
;
output
[
0
]
=
output
[
1
]
=
'
\
0
'
;
PseudoStack
*
pseudoStack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
pseudoStack
)
{
return
;
}
bool
includeDynamicString
=
true
;
{
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
includeDynamicString
=
!
gPS
-
>
FeaturePrivacy
(
lock
)
;
}
volatile
js
:
:
ProfileEntry
*
pseudoFrames
=
pseudoStack
-
>
mStack
;
uint32_t
pseudoCount
=
pseudoStack
-
>
stackSize
(
)
;
for
(
uint32_t
i
=
0
;
i
<
pseudoCount
;
i
+
+
)
{
const
char
*
label
=
pseudoFrames
[
i
]
.
label
(
)
;
const
char
*
dynamicString
=
includeDynamicString
?
pseudoFrames
[
i
]
.
getDynamicString
(
)
:
nullptr
;
size_t
labelLength
=
strlen
(
label
)
;
if
(
dynamicString
)
{
size_t
dynamicStringLength
=
strlen
(
dynamicString
)
;
if
(
output
+
labelLength
+
1
+
dynamicStringLength
>
=
bound
)
{
break
;
}
strcpy
(
output
label
)
;
output
+
=
labelLength
;
*
output
+
+
=
'
'
;
strcpy
(
output
dynamicString
)
;
output
+
=
dynamicStringLength
;
}
else
{
if
(
output
+
labelLength
>
=
bound
)
{
break
;
}
strcpy
(
output
label
)
;
output
+
=
labelLength
;
}
*
output
+
+
=
'
\
0
'
;
*
output
=
'
\
0
'
;
}
}
static
void
locked_profiler_add_marker
(
PS
:
:
LockRef
aLock
const
char
*
aMarker
ProfilerMarkerPayload
*
aPayload
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
MOZ_RELEASE_ASSERT
(
gPS
-
>
IsActive
(
aLock
)
&
&
!
gPS
-
>
FeaturePrivacy
(
aLock
)
)
;
mozilla
:
:
UniquePtr
<
ProfilerMarkerPayload
>
payload
(
aPayload
)
;
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
stack
)
{
return
;
}
mozilla
:
:
TimeStamp
origin
=
(
payload
&
&
!
payload
-
>
GetStartTime
(
)
.
IsNull
(
)
)
?
payload
-
>
GetStartTime
(
)
:
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
mozilla
:
:
TimeDuration
delta
=
origin
-
gPS
-
>
StartTime
(
aLock
)
;
stack
-
>
addMarker
(
aMarker
payload
.
release
(
)
delta
.
ToMilliseconds
(
)
)
;
}
void
profiler_add_marker
(
const
char
*
aMarker
ProfilerMarkerPayload
*
aPayload
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
mozilla
:
:
UniquePtr
<
ProfilerMarkerPayload
>
payload
(
aPayload
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
|
|
gPS
-
>
FeaturePrivacy
(
lock
)
)
{
return
;
}
locked_profiler_add_marker
(
lock
aMarker
payload
.
release
(
)
)
;
}
void
profiler_tracing
(
const
char
*
aCategory
const
char
*
aInfo
TracingKind
aKind
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
|
|
gPS
-
>
FeaturePrivacy
(
lock
)
)
{
return
;
}
auto
marker
=
new
ProfilerMarkerTracing
(
aCategory
aKind
)
;
locked_profiler_add_marker
(
lock
aInfo
marker
)
;
}
void
profiler_tracing
(
const
char
*
aCategory
const
char
*
aInfo
UniqueProfilerBacktrace
aCause
TracingKind
aKind
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
!
gPS
-
>
IsActive
(
lock
)
|
|
gPS
-
>
FeaturePrivacy
(
lock
)
)
{
return
;
}
auto
marker
=
new
ProfilerMarkerTracing
(
aCategory
aKind
mozilla
:
:
Move
(
aCause
)
)
;
locked_profiler_add_marker
(
lock
aInfo
marker
)
;
}
void
profiler_log
(
const
char
*
aStr
)
{
profiler_tracing
(
"
log
"
aStr
)
;
}
void
profiler_set_js_context
(
JSContext
*
aCx
)
{
MOZ_ASSERT
(
aCx
)
;
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
stack
)
{
return
;
}
stack
-
>
setJSContext
(
aCx
)
;
}
void
profiler_clear_js_context
(
)
{
MOZ_RELEASE_ASSERT
(
gPS
)
;
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
stack
)
{
return
;
}
if
(
!
stack
-
>
mContext
)
{
return
;
}
PS
:
:
AutoLock
lock
(
gPSMutex
)
;
if
(
gPS
-
>
IsActive
(
lock
)
)
{
gPS
-
>
SetIsPaused
(
lock
true
)
;
ThreadInfo
*
info
=
FindLiveThreadInfo
(
lock
)
;
MOZ_RELEASE_ASSERT
(
info
)
;
if
(
info
-
>
HasProfile
(
)
)
{
info
-
>
FlushSamplesAndMarkers
(
gPS
-
>
Buffer
(
lock
)
gPS
-
>
StartTime
(
lock
)
)
;
}
gPS
-
>
SetIsPaused
(
lock
false
)
;
}
stack
-
>
mContext
=
nullptr
;
}
