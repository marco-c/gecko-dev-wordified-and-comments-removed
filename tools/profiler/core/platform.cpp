#
include
"
platform
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
GeckoProfilerReporter
.
h
"
#
include
"
PageInformation
.
h
"
#
include
"
ProfiledThreadData
.
h
"
#
include
"
ProfilerBacktrace
.
h
"
#
include
"
ProfileBuffer
.
h
"
#
include
"
ProfilerIOInterposeObserver
.
h
"
#
include
"
ProfilerMarkerPayload
.
h
"
#
include
"
ProfilerParent
.
h
"
#
include
"
RegisteredThread
.
h
"
#
include
"
shared
-
libraries
.
h
"
#
include
"
ThreadInfo
.
h
"
#
include
"
VTuneProfiler
.
h
"
#
include
"
js
/
TraceLoggerAPI
.
h
"
#
include
"
js
/
ProfilingFrameIterator
.
h
"
#
include
"
memory_hooks
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
AutoProfilerLabel
.
h
"
#
include
"
mozilla
/
ExtensionPolicyService
.
h
"
#
include
"
mozilla
/
extensions
/
WebExtensionPolicy
.
h
"
#
include
"
mozilla
/
Printf
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
BaseProfiler
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIHttpProtocolHandler
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPropertyBag2
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsMemoryReporterManager
.
h
"
#
include
"
nsProfilerStartParams
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
prdtoa
.
h
"
#
include
"
prtime
.
h
"
#
include
<
algorithm
>
#
include
<
errno
.
h
>
#
include
<
fstream
>
#
include
<
ostream
>
#
include
<
sstream
>
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
#
endif
#
if
defined
(
GP_OS_android
)
#
include
"
GeneratedJNINatives
.
h
"
#
include
"
GeneratedJNIWrappers
.
h
"
#
endif
#
if
defined
(
GP_PLAT_x86_windows
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
if
defined
(
GP_PLAT_amd64_windows
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_MOZ_STACK_WALK
#
endif
#
if
defined
(
GP_PLAT_arm64_windows
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_MOZ_STACK_WALK
#
endif
#
if
defined
(
GP_OS_darwin
)
&
&
defined
(
MOZ_PROFILING
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
if
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_EHABI_STACKWALK
#
include
"
EHABIStackWalk
.
h
"
#
endif
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_x86_linux
)
|
|
\
defined
(
GP_PLAT_amd64_android
)
|
|
defined
(
GP_PLAT_x86_android
)
|
|
\
defined
(
GP_PLAT_mips64_linux
)
|
|
defined
(
GP_PLAT_arm64_linux
)
|
|
\
defined
(
GP_PLAT_arm64_android
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_LUL_STACKWALK
#
include
"
lul
/
LulMain
.
h
"
#
include
"
lul
/
platform
-
linux
-
lul
.
h
"
#
if
defined
(
MOZ_PROFILING
)
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
endif
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
|
|
defined
(
USE_MOZ_STACK_WALK
)
#
define
HAVE_FASTINIT_NATIVE_UNWIND
#
endif
#
ifdef
MOZ_VALGRIND
#
include
<
valgrind
/
memcheck
.
h
>
#
else
#
define
VALGRIND_MAKE_MEM_DEFINED
(
_addr
_len
)
(
(
void
)
0
)
#
endif
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
#
include
<
ucontext
.
h
>
#
endif
using
namespace
mozilla
;
using
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
;
LazyLogModule
gProfilerLog
(
"
prof
"
)
;
#
if
defined
(
GP_OS_android
)
class
GeckoJavaSampler
:
public
java
:
:
GeckoJavaSampler
:
:
Natives
<
GeckoJavaSampler
>
{
private
:
GeckoJavaSampler
(
)
;
public
:
static
double
GetProfilerTime
(
)
{
if
(
!
profiler_is_active
(
)
)
{
return
0
.
0
;
}
return
profiler_time
(
)
;
}
;
}
;
#
endif
static
uint32_t
AvailableFeatures
(
)
{
uint32_t
features
=
0
;
#
define
ADD_FEATURE
(
n_
str_
Name_
desc_
)
\
ProfilerFeature
:
:
Set
#
#
Name_
(
features
)
;
PROFILER_FOR_EACH_FEATURE
(
ADD_FEATURE
)
#
undef
ADD_FEATURE
#
if
!
defined
(
GP_OS_android
)
ProfilerFeature
:
:
ClearJava
(
features
)
;
#
endif
#
if
!
defined
(
HAVE_NATIVE_UNWIND
)
ProfilerFeature
:
:
ClearStackWalk
(
features
)
;
#
endif
#
if
!
defined
(
MOZ_TASK_TRACER
)
ProfilerFeature
:
:
ClearTaskTracer
(
features
)
;
#
endif
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
getenv
(
"
XPCOM_MEM_BLOAT_LOG
"
)
)
{
ProfilerFeature
:
:
ClearNativeAllocations
(
features
)
;
}
#
else
ProfilerFeature
:
:
ClearNativeAllocations
(
features
)
;
#
endif
if
(
!
JS
:
:
TraceLoggerSupported
(
)
)
{
ProfilerFeature
:
:
ClearJSTracer
(
features
)
;
}
return
features
;
}
static
uint32_t
DefaultFeatures
(
)
{
return
ProfilerFeature
:
:
Java
|
ProfilerFeature
:
:
JS
|
ProfilerFeature
:
:
Leaf
|
ProfilerFeature
:
:
StackWalk
|
ProfilerFeature
:
:
Threads
;
}
static
uint32_t
StartupExtraDefaultFeatures
(
)
{
return
ProfilerFeature
:
:
MainThreadIO
;
}
class
PSMutex
:
private
:
:
mozilla
:
:
detail
:
:
MutexImpl
{
public
:
PSMutex
(
)
:
:
:
mozilla
:
:
detail
:
:
MutexImpl
(
:
:
mozilla
:
:
recordreplay
:
:
Behavior
:
:
DontPreserve
)
{
}
void
Lock
(
)
{
const
int
tid
=
profiler_current_thread_id
(
)
;
MOZ_ASSERT
(
tid
!
=
0
)
;
MOZ_ASSERT
(
mOwningThreadId
!
=
tid
)
;
:
:
mozilla
:
:
detail
:
:
MutexImpl
:
:
lock
(
)
;
MOZ_ASSERT
(
mOwningThreadId
=
=
0
)
;
mOwningThreadId
=
tid
;
}
void
Unlock
(
)
{
AssertCurrentThreadOwns
(
)
;
mOwningThreadId
=
0
;
:
:
mozilla
:
:
detail
:
:
MutexImpl
:
:
unlock
(
)
;
}
bool
IsLockedOnCurrentThread
(
)
const
{
return
mOwningThreadId
=
=
profiler_current_thread_id
(
)
;
}
void
AssertCurrentThreadOwns
(
)
const
{
MOZ_ASSERT
(
IsLockedOnCurrentThread
(
)
)
;
}
void
AssertCurrentThreadDoesNotOwn
(
)
const
{
MOZ_ASSERT
(
!
IsLockedOnCurrentThread
(
)
)
;
}
private
:
Atomic
<
int
MemoryOrdering
:
:
SequentiallyConsistent
recordreplay
:
:
Behavior
:
:
DontPreserve
>
mOwningThreadId
{
0
}
;
}
;
class
MOZ_RAII
PSAutoLock
{
public
:
explicit
PSAutoLock
(
PSMutex
&
aMutex
)
:
mMutex
(
aMutex
)
{
mMutex
.
Lock
(
)
;
}
~
PSAutoLock
(
)
{
mMutex
.
Unlock
(
)
;
}
private
:
PSMutex
&
mMutex
;
}
;
typedef
const
PSAutoLock
&
PSLockRef
;
#
define
PS_GET
(
type_
name_
)
\
static
type_
name_
(
PSLockRef
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
return
sInstance
-
>
m
#
#
name_
;
\
}
#
define
PS_GET_LOCKLESS
(
type_
name_
)
\
static
type_
name_
(
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
return
sInstance
-
>
m
#
#
name_
;
\
}
#
define
PS_GET_AND_SET
(
type_
name_
)
\
PS_GET
(
type_
name_
)
\
static
void
Set
#
#
name_
(
PSLockRef
type_
a
#
#
name_
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
sInstance
-
>
m
#
#
name_
=
a
#
#
name_
;
\
}
class
CorePS
{
private
:
CorePS
(
)
:
mProcessStartTime
(
TimeStamp
:
:
ProcessCreation
(
)
)
mCoreBlocksRingBuffer
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithMutex
)
#
ifdef
USE_LUL_STACKWALK
mLul
(
nullptr
)
#
endif
{
}
~
CorePS
(
)
{
}
public
:
static
void
Create
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
!
sInstance
)
;
sInstance
=
new
CorePS
(
)
;
}
static
void
Destroy
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
delete
sInstance
;
sInstance
=
nullptr
;
}
static
bool
Exists
(
)
{
return
!
!
sInstance
;
}
static
void
AddSizeOf
(
PSLockRef
MallocSizeOf
aMallocSizeOf
size_t
&
aProfSize
size_t
&
aLulSize
)
{
MOZ_ASSERT
(
sInstance
)
;
aProfSize
+
=
aMallocSizeOf
(
sInstance
)
;
for
(
auto
&
registeredThread
:
sInstance
-
>
mRegisteredThreads
)
{
aProfSize
+
=
registeredThread
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
for
(
auto
&
registeredPage
:
sInstance
-
>
mRegisteredPages
)
{
aProfSize
+
=
registeredPage
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
if
(
sInstance
-
>
mLul
)
{
aLulSize
+
=
sInstance
-
>
mLul
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
#
endif
}
PS_GET_LOCKLESS
(
TimeStamp
ProcessStartTime
)
PS_GET_LOCKLESS
(
BlocksRingBuffer
&
CoreBlocksRingBuffer
)
PS_GET
(
const
Vector
<
UniquePtr
<
RegisteredThread
>
>
&
RegisteredThreads
)
static
void
AppendRegisteredThread
(
PSLockRef
UniquePtr
<
RegisteredThread
>
&
&
aRegisteredThread
)
{
MOZ_ASSERT
(
sInstance
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mRegisteredThreads
.
append
(
std
:
:
move
(
aRegisteredThread
)
)
)
;
}
static
void
RemoveRegisteredThread
(
PSLockRef
RegisteredThread
*
aRegisteredThread
)
{
MOZ_ASSERT
(
sInstance
)
;
for
(
UniquePtr
<
RegisteredThread
>
&
rt
:
sInstance
-
>
mRegisteredThreads
)
{
if
(
rt
.
get
(
)
=
=
aRegisteredThread
)
{
sInstance
-
>
mRegisteredThreads
.
erase
(
&
rt
)
;
return
;
}
}
}
PS_GET
(
Vector
<
RefPtr
<
PageInformation
>
>
&
RegisteredPages
)
static
void
AppendRegisteredPage
(
PSLockRef
RefPtr
<
PageInformation
>
&
&
aRegisteredPage
)
{
MOZ_ASSERT
(
sInstance
)
;
struct
RegisteredPageComparator
{
PageInformation
*
aA
;
bool
operator
(
)
(
PageInformation
*
aB
)
const
{
return
aA
-
>
Equals
(
aB
)
;
}
}
;
auto
foundPageIter
=
std
:
:
find_if
(
sInstance
-
>
mRegisteredPages
.
begin
(
)
sInstance
-
>
mRegisteredPages
.
end
(
)
RegisteredPageComparator
{
aRegisteredPage
.
get
(
)
}
)
;
if
(
foundPageIter
!
=
sInstance
-
>
mRegisteredPages
.
end
(
)
)
{
if
(
(
*
foundPageIter
)
-
>
Url
(
)
.
EqualsLiteral
(
"
about
:
blank
"
)
)
{
sInstance
-
>
mRegisteredPages
.
erase
(
foundPageIter
)
;
}
else
{
return
;
}
}
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mRegisteredPages
.
append
(
std
:
:
move
(
aRegisteredPage
)
)
)
;
}
static
void
RemoveRegisteredPage
(
PSLockRef
uint64_t
aRegisteredInnerWindowID
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mRegisteredPages
.
eraseIf
(
[
&
]
(
const
RefPtr
<
PageInformation
>
&
rd
)
{
return
rd
-
>
InnerWindowID
(
)
=
=
aRegisteredInnerWindowID
;
}
)
;
}
static
void
ClearRegisteredPages
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mRegisteredPages
.
clear
(
)
;
}
PS_GET
(
const
Vector
<
BaseProfilerCount
*
>
&
Counters
)
static
void
AppendCounter
(
PSLockRef
BaseProfilerCount
*
aCounter
)
{
MOZ_ASSERT
(
sInstance
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mCounters
.
append
(
aCounter
)
)
;
}
static
void
RemoveCounter
(
PSLockRef
BaseProfilerCount
*
aCounter
)
{
if
(
sInstance
)
{
auto
*
counter
=
std
:
:
find
(
sInstance
-
>
mCounters
.
begin
(
)
sInstance
-
>
mCounters
.
end
(
)
aCounter
)
;
MOZ_RELEASE_ASSERT
(
counter
!
=
sInstance
-
>
mCounters
.
end
(
)
)
;
sInstance
-
>
mCounters
.
erase
(
counter
)
;
}
}
#
ifdef
USE_LUL_STACKWALK
static
lul
:
:
LUL
*
Lul
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mLul
.
get
(
)
;
}
static
void
SetLul
(
PSLockRef
UniquePtr
<
lul
:
:
LUL
>
aLul
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mLul
=
std
:
:
move
(
aLul
)
;
}
#
endif
PS_GET_AND_SET
(
const
nsACString
&
ProcessName
)
private
:
static
CorePS
*
sInstance
;
const
TimeStamp
mProcessStartTime
;
BlocksRingBuffer
mCoreBlocksRingBuffer
;
Vector
<
UniquePtr
<
RegisteredThread
>
>
mRegisteredThreads
;
Vector
<
RefPtr
<
PageInformation
>
>
mRegisteredPages
;
Vector
<
BaseProfilerCount
*
>
mCounters
;
#
ifdef
USE_LUL_STACKWALK
UniquePtr
<
lul
:
:
LUL
>
mLul
;
#
endif
nsAutoCString
mProcessName
;
}
;
CorePS
*
CorePS
:
:
sInstance
=
nullptr
;
class
SamplerThread
;
static
SamplerThread
*
NewSamplerThread
(
PSLockRef
aLock
uint32_t
aGeneration
double
aInterval
)
;
struct
LiveProfiledThreadData
{
RegisteredThread
*
mRegisteredThread
;
UniquePtr
<
ProfiledThreadData
>
mProfiledThreadData
;
}
;
class
ActivePS
{
private
:
static
uint32_t
AdjustFeatures
(
uint32_t
aFeatures
uint32_t
aFilterCount
)
{
aFeatures
&
=
AvailableFeatures
(
)
;
if
(
aFilterCount
>
0
)
{
aFeatures
|
=
ProfilerFeature
:
:
Threads
;
}
return
aFeatures
;
}
ActivePS
(
PSLockRef
aLock
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
Maybe
<
double
>
&
aDuration
)
:
mGeneration
(
sNextGeneration
+
+
)
mCapacity
(
aCapacity
)
mDuration
(
aDuration
)
mInterval
(
aInterval
)
mFeatures
(
AdjustFeatures
(
aFeatures
aFilterCount
)
)
mProfileBuffer
(
CorePS
:
:
CoreBlocksRingBuffer
(
)
PowerOfTwo32
(
aCapacity
.
Value
(
)
*
8
)
)
mSamplerThread
(
NewSamplerThread
(
aLock
mGeneration
aInterval
)
)
mInterposeObserver
(
ProfilerFeature
:
:
HasMainThreadIO
(
aFeatures
)
?
new
ProfilerIOInterposeObserver
(
)
:
nullptr
)
mIsPaused
(
false
)
#
if
defined
(
GP_OS_linux
)
mWasPaused
(
false
)
#
endif
{
MOZ_ALWAYS_TRUE
(
mFilters
.
resize
(
aFilterCount
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
mFilters
[
i
]
=
aFilters
[
i
]
;
}
#
if
!
defined
(
RELEASE_OR_BETA
)
if
(
mInterposeObserver
)
{
if
(
NS_IsMainThread
(
)
)
{
IOInterposer
:
:
Init
(
)
;
IOInterposer
:
:
Register
(
IOInterposeObserver
:
:
OpAll
mInterposeObserver
)
;
}
else
{
RefPtr
<
ProfilerIOInterposeObserver
>
observer
=
mInterposeObserver
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ActivePS
:
:
ActivePS
"
[
=
]
(
)
{
IOInterposer
:
:
Init
(
)
;
IOInterposer
:
:
Register
(
IOInterposeObserver
:
:
OpAll
observer
)
;
}
)
)
;
}
}
#
endif
}
~
ActivePS
(
)
{
#
if
!
defined
(
RELEASE_OR_BETA
)
if
(
mInterposeObserver
)
{
if
(
NS_IsMainThread
(
)
)
{
IOInterposer
:
:
Unregister
(
IOInterposeObserver
:
:
OpAll
mInterposeObserver
)
;
}
else
{
RefPtr
<
ProfilerIOInterposeObserver
>
observer
=
mInterposeObserver
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ActivePS
:
:
~
ActivePS
"
[
=
]
(
)
{
IOInterposer
:
:
Unregister
(
IOInterposeObserver
:
:
OpAll
observer
)
;
}
)
)
;
}
}
#
endif
}
bool
ThreadSelected
(
const
char
*
aThreadName
)
{
if
(
mFilters
.
empty
(
)
)
{
return
true
;
}
std
:
:
string
name
=
aThreadName
;
std
:
:
transform
(
name
.
begin
(
)
name
.
end
(
)
name
.
begin
(
)
:
:
tolower
)
;
for
(
uint32_t
i
=
0
;
i
<
mFilters
.
length
(
)
;
+
+
i
)
{
std
:
:
string
filter
=
mFilters
[
i
]
;
std
:
:
transform
(
filter
.
begin
(
)
filter
.
end
(
)
filter
.
begin
(
)
:
:
tolower
)
;
if
(
name
.
find
(
filter
)
!
=
std
:
:
string
:
:
npos
)
{
return
true
;
}
if
(
filter
.
find
(
"
pid
:
"
)
=
=
0
)
{
std
:
:
string
mypid
=
std
:
:
to_string
(
profiler_current_process_id
(
)
)
;
if
(
filter
.
compare
(
4
std
:
:
string
:
:
npos
mypid
)
=
=
0
)
{
return
true
;
}
}
}
return
false
;
}
public
:
static
void
Create
(
PSLockRef
aLock
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
Maybe
<
double
>
&
aDuration
)
{
MOZ_ASSERT
(
!
sInstance
)
;
sInstance
=
new
ActivePS
(
aLock
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aDuration
)
;
}
static
MOZ_MUST_USE
SamplerThread
*
Destroy
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
auto
samplerThread
=
sInstance
-
>
mSamplerThread
;
delete
sInstance
;
sInstance
=
nullptr
;
return
samplerThread
;
}
static
bool
Exists
(
PSLockRef
)
{
return
!
!
sInstance
;
}
static
bool
Equals
(
PSLockRef
PowerOfTwo32
aCapacity
const
Maybe
<
double
>
&
aDuration
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
{
MOZ_ASSERT
(
sInstance
)
;
if
(
sInstance
-
>
mCapacity
!
=
aCapacity
|
|
sInstance
-
>
mDuration
!
=
aDuration
|
|
sInstance
-
>
mInterval
!
=
aInterval
|
|
sInstance
-
>
mFeatures
!
=
aFeatures
|
|
sInstance
-
>
mFilters
.
length
(
)
!
=
aFilterCount
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
sInstance
-
>
mFilters
.
length
(
)
;
+
+
i
)
{
if
(
strcmp
(
sInstance
-
>
mFilters
[
i
]
.
c_str
(
)
aFilters
[
i
]
)
!
=
0
)
{
return
false
;
}
}
return
true
;
}
static
size_t
SizeOf
(
PSLockRef
MallocSizeOf
aMallocSizeOf
)
{
MOZ_ASSERT
(
sInstance
)
;
size_t
n
=
aMallocSizeOf
(
sInstance
)
;
n
+
=
sInstance
-
>
mProfileBuffer
.
SizeOfIncludingThis
(
aMallocSizeOf
)
;
return
n
;
}
static
bool
ShouldProfileThread
(
PSLockRef
aLock
ThreadInfo
*
aInfo
)
{
MOZ_ASSERT
(
sInstance
)
;
return
(
(
aInfo
-
>
IsMainThread
(
)
|
|
FeatureThreads
(
aLock
)
)
&
&
sInstance
-
>
ThreadSelected
(
aInfo
-
>
Name
(
)
)
)
;
}
static
MOZ_MUST_USE
bool
AppendPostSamplingCallback
(
PSLockRef
PostSamplingCallback
&
&
aCallback
)
;
static
void
WriteActiveConfiguration
(
PSLockRef
aLock
JSONWriter
&
aWriter
const
char
*
aPropertyName
=
nullptr
)
{
if
(
!
sInstance
)
{
if
(
aPropertyName
)
{
aWriter
.
NullProperty
(
aPropertyName
)
;
}
else
{
aWriter
.
NullElement
(
)
;
}
return
;
}
;
if
(
aPropertyName
)
{
aWriter
.
StartObjectProperty
(
aPropertyName
)
;
}
else
{
aWriter
.
StartObjectElement
(
)
;
}
{
aWriter
.
StartArrayProperty
(
"
features
"
aWriter
.
SingleLineStyle
)
;
#
define
WRITE_ACTIVE_FEATURES
(
n_
str_
Name_
desc_
)
\
if
(
profiler_feature_active
(
ProfilerFeature
:
:
Name_
)
)
{
\
aWriter
.
StringElement
(
str_
)
;
\
}
PROFILER_FOR_EACH_FEATURE
(
WRITE_ACTIVE_FEATURES
)
#
undef
WRITE_ACTIVE_FEATURES
aWriter
.
EndArray
(
)
;
}
{
aWriter
.
StartArrayProperty
(
"
threads
"
aWriter
.
SingleLineStyle
)
;
for
(
const
auto
&
filter
:
sInstance
-
>
mFilters
)
{
aWriter
.
StringElement
(
filter
.
c_str
(
)
)
;
}
aWriter
.
EndArray
(
)
;
}
{
aWriter
.
DoubleProperty
(
"
interval
"
sInstance
-
>
mInterval
)
;
aWriter
.
IntProperty
(
"
capacity
"
sInstance
-
>
mCapacity
.
Value
(
)
)
;
if
(
sInstance
-
>
mDuration
)
{
aWriter
.
DoubleProperty
(
"
duration
"
sInstance
-
>
mDuration
.
value
(
)
)
;
}
}
aWriter
.
EndObject
(
)
;
}
PS_GET
(
uint32_t
Generation
)
PS_GET
(
PowerOfTwo32
Capacity
)
PS_GET
(
Maybe
<
double
>
Duration
)
PS_GET
(
double
Interval
)
PS_GET
(
uint32_t
Features
)
#
define
PS_GET_FEATURE
(
n_
str_
Name_
desc_
)
\
static
bool
Feature
#
#
Name_
(
PSLockRef
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
return
ProfilerFeature
:
:
Has
#
#
Name_
(
sInstance
-
>
mFeatures
)
;
\
}
PROFILER_FOR_EACH_FEATURE
(
PS_GET_FEATURE
)
#
undef
PS_GET_FEATURE
static
uint32_t
JSFlags
(
PSLockRef
aLock
)
{
uint32_t
Flags
=
0
;
Flags
|
=
FeatureJS
(
aLock
)
?
uint32_t
(
JSInstrumentationFlags
:
:
StackSampling
)
:
0
;
Flags
|
=
FeatureTrackOptimizations
(
aLock
)
?
uint32_t
(
JSInstrumentationFlags
:
:
TrackOptimizations
)
:
0
;
Flags
|
=
FeatureJSTracer
(
aLock
)
?
uint32_t
(
JSInstrumentationFlags
:
:
TraceLogging
)
:
0
;
Flags
|
=
FeatureJSAllocations
(
aLock
)
?
uint32_t
(
JSInstrumentationFlags
:
:
Allocations
)
:
0
;
return
Flags
;
}
PS_GET
(
const
Vector
<
std
:
:
string
>
&
Filters
)
static
ProfileBuffer
&
Buffer
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mProfileBuffer
;
}
static
const
Vector
<
LiveProfiledThreadData
>
&
LiveProfiledThreads
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mLiveProfiledThreads
;
}
static
Vector
<
Pair
<
RegisteredThread
*
ProfiledThreadData
*
>
>
ProfiledThreads
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
Vector
<
Pair
<
RegisteredThread
*
ProfiledThreadData
*
>
>
array
;
MOZ_RELEASE_ASSERT
(
array
.
initCapacity
(
sInstance
-
>
mLiveProfiledThreads
.
length
(
)
+
sInstance
-
>
mDeadProfiledThreads
.
length
(
)
)
)
;
for
(
auto
&
t
:
sInstance
-
>
mLiveProfiledThreads
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
MakePair
(
t
.
mRegisteredThread
t
.
mProfiledThreadData
.
get
(
)
)
)
)
;
}
for
(
auto
&
t
:
sInstance
-
>
mDeadProfiledThreads
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
MakePair
(
(
RegisteredThread
*
)
nullptr
t
.
get
(
)
)
)
)
;
}
std
:
:
sort
(
array
.
begin
(
)
array
.
end
(
)
[
]
(
const
Pair
<
RegisteredThread
*
ProfiledThreadData
*
>
&
a
const
Pair
<
RegisteredThread
*
ProfiledThreadData
*
>
&
b
)
{
return
a
.
second
(
)
-
>
Info
(
)
-
>
RegisterTime
(
)
<
b
.
second
(
)
-
>
Info
(
)
-
>
RegisterTime
(
)
;
}
)
;
return
array
;
}
static
Vector
<
RefPtr
<
PageInformation
>
>
ProfiledPages
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
Vector
<
RefPtr
<
PageInformation
>
>
array
;
for
(
auto
&
d
:
CorePS
:
:
RegisteredPages
(
aLock
)
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
d
)
)
;
}
for
(
auto
&
d
:
sInstance
-
>
mDeadProfiledPages
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
d
)
)
;
}
return
array
;
}
static
ProfiledThreadData
*
GetProfiledThreadData
(
PSLockRef
RegisteredThread
*
aRegisteredThread
)
{
MOZ_ASSERT
(
sInstance
)
;
for
(
const
LiveProfiledThreadData
&
thread
:
sInstance
-
>
mLiveProfiledThreads
)
{
if
(
thread
.
mRegisteredThread
=
=
aRegisteredThread
)
{
return
thread
.
mProfiledThreadData
.
get
(
)
;
}
}
return
nullptr
;
}
static
ProfiledThreadData
*
AddLiveProfiledThread
(
PSLockRef
RegisteredThread
*
aRegisteredThread
UniquePtr
<
ProfiledThreadData
>
&
&
aProfiledThreadData
)
{
MOZ_ASSERT
(
sInstance
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mLiveProfiledThreads
.
append
(
LiveProfiledThreadData
{
aRegisteredThread
std
:
:
move
(
aProfiledThreadData
)
}
)
)
;
return
sInstance
-
>
mLiveProfiledThreads
.
back
(
)
.
mProfiledThreadData
.
get
(
)
;
}
static
void
UnregisterThread
(
PSLockRef
aLockRef
RegisteredThread
*
aRegisteredThread
)
{
MOZ_ASSERT
(
sInstance
)
;
DiscardExpiredDeadProfiledThreads
(
aLockRef
)
;
for
(
size_t
i
=
0
;
i
<
sInstance
-
>
mLiveProfiledThreads
.
length
(
)
;
i
+
+
)
{
LiveProfiledThreadData
&
thread
=
sInstance
-
>
mLiveProfiledThreads
[
i
]
;
if
(
thread
.
mRegisteredThread
=
=
aRegisteredThread
)
{
thread
.
mProfiledThreadData
-
>
NotifyUnregistered
(
sInstance
-
>
mProfileBuffer
.
BufferRangeEnd
(
)
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mDeadProfiledThreads
.
append
(
std
:
:
move
(
thread
.
mProfiledThreadData
)
)
)
;
sInstance
-
>
mLiveProfiledThreads
.
erase
(
&
sInstance
-
>
mLiveProfiledThreads
[
i
]
)
;
return
;
}
}
}
PS_GET_AND_SET
(
bool
IsPaused
)
#
if
defined
(
GP_OS_linux
)
PS_GET_AND_SET
(
bool
WasPaused
)
#
endif
static
void
DiscardExpiredDeadProfiledThreads
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
uint64_t
bufferRangeStart
=
sInstance
-
>
mProfileBuffer
.
BufferRangeStart
(
)
;
sInstance
-
>
mDeadProfiledThreads
.
eraseIf
(
[
bufferRangeStart
]
(
const
UniquePtr
<
ProfiledThreadData
>
&
aProfiledThreadData
)
{
Maybe
<
uint64_t
>
bufferPosition
=
aProfiledThreadData
-
>
BufferPositionWhenUnregistered
(
)
;
MOZ_RELEASE_ASSERT
(
bufferPosition
"
should
have
unregistered
this
thread
"
)
;
return
*
bufferPosition
<
bufferRangeStart
;
}
)
;
}
static
void
UnregisterPage
(
PSLockRef
aLock
uint64_t
aRegisteredInnerWindowID
)
{
MOZ_ASSERT
(
sInstance
)
;
auto
&
registeredPages
=
CorePS
:
:
RegisteredPages
(
aLock
)
;
for
(
size_t
i
=
0
;
i
<
registeredPages
.
length
(
)
;
i
+
+
)
{
RefPtr
<
PageInformation
>
&
page
=
registeredPages
[
i
]
;
if
(
page
-
>
InnerWindowID
(
)
=
=
aRegisteredInnerWindowID
)
{
page
-
>
NotifyUnregistered
(
sInstance
-
>
mProfileBuffer
.
BufferRangeEnd
(
)
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mDeadProfiledPages
.
append
(
std
:
:
move
(
page
)
)
)
;
registeredPages
.
erase
(
&
registeredPages
[
i
-
-
]
)
;
}
}
}
static
void
DiscardExpiredPages
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
uint64_t
bufferRangeStart
=
sInstance
-
>
mProfileBuffer
.
BufferRangeStart
(
)
;
sInstance
-
>
mDeadProfiledPages
.
eraseIf
(
[
bufferRangeStart
]
(
const
RefPtr
<
PageInformation
>
&
aProfiledPage
)
{
Maybe
<
uint64_t
>
bufferPosition
=
aProfiledPage
-
>
BufferPositionWhenUnregistered
(
)
;
MOZ_RELEASE_ASSERT
(
bufferPosition
"
should
have
unregistered
this
page
"
)
;
return
*
bufferPosition
<
bufferRangeStart
;
}
)
;
}
static
void
ClearUnregisteredPages
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mDeadProfiledPages
.
clear
(
)
;
}
static
void
ClearExpiredExitProfiles
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
uint64_t
bufferRangeStart
=
sInstance
-
>
mProfileBuffer
.
BufferRangeStart
(
)
;
#
ifdef
MOZ_BASE_PROFILER
if
(
bufferRangeStart
>
1
&
&
sInstance
-
>
mBaseProfileThreads
)
{
sInstance
-
>
mBaseProfileThreads
.
reset
(
)
;
}
#
endif
sInstance
-
>
mExitProfiles
.
eraseIf
(
[
bufferRangeStart
]
(
const
ExitProfile
&
aExitProfile
)
{
return
aExitProfile
.
mBufferPositionAtGatherTime
<
bufferRangeStart
;
}
)
;
}
#
ifdef
MOZ_BASE_PROFILER
static
void
AddBaseProfileThreads
(
PSLockRef
aLock
UniquePtr
<
char
[
]
>
aBaseProfileThreads
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mBaseProfileThreads
=
std
:
:
move
(
aBaseProfileThreads
)
;
}
static
UniquePtr
<
char
[
]
>
MoveBaseProfileThreads
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
ClearExpiredExitProfiles
(
aLock
)
;
return
std
:
:
move
(
sInstance
-
>
mBaseProfileThreads
)
;
}
#
endif
static
void
AddExitProfile
(
PSLockRef
aLock
const
nsCString
&
aExitProfile
)
{
MOZ_ASSERT
(
sInstance
)
;
ClearExpiredExitProfiles
(
aLock
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mExitProfiles
.
append
(
ExitProfile
{
aExitProfile
sInstance
-
>
mProfileBuffer
.
BufferRangeEnd
(
)
}
)
)
;
}
static
Vector
<
nsCString
>
MoveExitProfiles
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
ClearExpiredExitProfiles
(
aLock
)
;
Vector
<
nsCString
>
profiles
;
MOZ_RELEASE_ASSERT
(
profiles
.
initCapacity
(
sInstance
-
>
mExitProfiles
.
length
(
)
)
)
;
for
(
auto
&
profile
:
sInstance
-
>
mExitProfiles
)
{
MOZ_RELEASE_ASSERT
(
profiles
.
append
(
std
:
:
move
(
profile
.
mJSON
)
)
)
;
}
sInstance
-
>
mExitProfiles
.
clear
(
)
;
return
profiles
;
}
private
:
static
ActivePS
*
sInstance
;
const
uint32_t
mGeneration
;
static
uint32_t
sNextGeneration
;
const
PowerOfTwo32
mCapacity
;
const
Maybe
<
double
>
mDuration
;
const
double
mInterval
;
const
uint32_t
mFeatures
;
Vector
<
std
:
:
string
>
mFilters
;
ProfileBuffer
mProfileBuffer
;
Vector
<
LiveProfiledThreadData
>
mLiveProfiledThreads
;
Vector
<
UniquePtr
<
ProfiledThreadData
>
>
mDeadProfiledThreads
;
Vector
<
RefPtr
<
PageInformation
>
>
mDeadProfiledPages
;
SamplerThread
*
const
mSamplerThread
;
RefPtr
<
ProfilerIOInterposeObserver
>
mInterposeObserver
;
bool
mIsPaused
;
#
if
defined
(
GP_OS_linux
)
bool
mWasPaused
;
#
endif
#
ifdef
MOZ_BASE_PROFILER
UniquePtr
<
char
[
]
>
mBaseProfileThreads
;
#
endif
struct
ExitProfile
{
nsCString
mJSON
;
uint64_t
mBufferPositionAtGatherTime
;
}
;
Vector
<
ExitProfile
>
mExitProfiles
;
}
;
ActivePS
*
ActivePS
:
:
sInstance
=
nullptr
;
uint32_t
ActivePS
:
:
sNextGeneration
=
0
;
#
undef
PS_GET
#
undef
PS_GET_LOCKLESS
#
undef
PS_GET_AND_SET
static
PSMutex
gPSMutex
;
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
recordreplay
:
:
Behavior
:
:
DontPreserve
>
RacyFeatures
:
:
sActiveAndFeatures
(
0
)
;
class
TLSRegisteredThread
{
public
:
static
bool
Init
(
PSLockRef
)
{
bool
ok1
=
sRegisteredThread
.
init
(
)
;
bool
ok2
=
AutoProfilerLabel
:
:
sProfilingStackOwnerTLS
.
init
(
)
;
return
ok1
&
&
ok2
;
}
static
class
RegisteredThread
*
RegisteredThread
(
PSLockRef
)
{
return
sRegisteredThread
.
get
(
)
;
}
static
class
RacyRegisteredThread
*
RacyRegisteredThread
(
)
{
class
RegisteredThread
*
registeredThread
=
sRegisteredThread
.
get
(
)
;
return
registeredThread
?
&
registeredThread
-
>
RacyRegisteredThread
(
)
:
nullptr
;
}
static
ProfilingStack
*
Stack
(
)
{
ProfilingStackOwner
*
profilingStackOwner
=
AutoProfilerLabel
:
:
sProfilingStackOwnerTLS
.
get
(
)
;
if
(
!
profilingStackOwner
)
{
return
nullptr
;
}
return
&
profilingStackOwner
-
>
ProfilingStack
(
)
;
}
static
void
SetRegisteredThreadAndAutoProfilerLabelProfilingStack
(
PSLockRef
class
RegisteredThread
*
aRegisteredThread
)
{
MOZ_RELEASE_ASSERT
(
aRegisteredThread
"
Use
ResetRegisteredThread
(
)
instead
of
SetRegisteredThread
(
nullptr
)
"
)
;
sRegisteredThread
.
set
(
aRegisteredThread
)
;
ProfilingStackOwner
&
profilingStackOwner
=
aRegisteredThread
-
>
RacyRegisteredThread
(
)
.
ProfilingStackOwner
(
)
;
profilingStackOwner
.
AddRef
(
)
;
AutoProfilerLabel
:
:
sProfilingStackOwnerTLS
.
set
(
&
profilingStackOwner
)
;
}
static
void
ResetRegisteredThread
(
PSLockRef
)
{
sRegisteredThread
.
set
(
nullptr
)
;
}
static
void
ResetAutoProfilerLabelProfilingStack
(
PSLockRef
)
{
MOZ_RELEASE_ASSERT
(
AutoProfilerLabel
:
:
sProfilingStackOwnerTLS
.
get
(
)
"
ResetAutoProfilerLabelProfilingStack
should
only
be
called
once
"
)
;
AutoProfilerLabel
:
:
sProfilingStackOwnerTLS
.
get
(
)
-
>
Release
(
)
;
AutoProfilerLabel
:
:
sProfilingStackOwnerTLS
.
set
(
nullptr
)
;
}
private
:
static
MOZ_THREAD_LOCAL
(
class
RegisteredThread
*
)
sRegisteredThread
;
}
;
MOZ_THREAD_LOCAL
(
RegisteredThread
*
)
TLSRegisteredThread
:
:
sRegisteredThread
;
MOZ_THREAD_LOCAL
(
ProfilingStackOwner
*
)
AutoProfilerLabel
:
:
sProfilingStackOwnerTLS
;
void
ProfilingStackOwner
:
:
DumpStackAndCrash
(
)
const
{
fprintf
(
stderr
"
ProfilingStackOwner
:
:
DumpStackAndCrash
(
)
thread
id
:
%
d
size
:
%
u
\
n
"
profiler_current_thread_id
(
)
unsigned
(
mProfilingStack
.
stackSize
(
)
)
)
;
js
:
:
ProfilingStackFrame
*
allFrames
=
mProfilingStack
.
frames
;
for
(
uint32_t
i
=
0
;
i
<
mProfilingStack
.
stackSize
(
)
;
i
+
+
)
{
js
:
:
ProfilingStackFrame
&
frame
=
allFrames
[
i
]
;
if
(
frame
.
isLabelFrame
(
)
)
{
fprintf
(
stderr
"
%
u
:
label
frame
sp
=
%
p
label
=
'
%
s
'
(
%
s
)
\
n
"
unsigned
(
i
)
frame
.
stackAddress
(
)
frame
.
label
(
)
frame
.
dynamicString
(
)
?
frame
.
dynamicString
(
)
:
"
-
"
)
;
}
else
{
fprintf
(
stderr
"
%
u
:
non
-
label
frame
\
n
"
unsigned
(
i
)
)
;
}
}
MOZ_CRASH
(
"
Non
-
empty
stack
!
"
)
;
}
static
const
char
*
const
kMainThreadName
=
"
GeckoMain
"
;
class
Registers
{
public
:
Registers
(
)
:
mPC
{
nullptr
}
mSP
{
nullptr
}
mFP
{
nullptr
}
mLR
{
nullptr
}
{
}
#
if
defined
(
HAVE_NATIVE_UNWIND
)
void
SyncPopulate
(
)
;
#
endif
void
Clear
(
)
{
memset
(
this
0
sizeof
(
*
this
)
)
;
}
Address
mPC
;
Address
mSP
;
Address
mFP
;
Address
mLR
;
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
ucontext_t
*
mContext
;
#
endif
}
;
static
const
size_t
MAX_NATIVE_FRAMES
=
1024
;
static
const
size_t
MAX_JS_FRAMES
=
1024
;
struct
NativeStack
{
void
*
mPCs
[
MAX_NATIVE_FRAMES
]
;
void
*
mSPs
[
MAX_NATIVE_FRAMES
]
;
size_t
mCount
;
NativeStack
(
)
:
mPCs
(
)
mSPs
(
)
mCount
(
0
)
{
}
}
;
Atomic
<
bool
>
WALKING_JS_STACK
(
false
)
;
struct
AutoWalkJSStack
{
bool
walkAllowed
;
AutoWalkJSStack
(
)
:
walkAllowed
(
false
)
{
walkAllowed
=
WALKING_JS_STACK
.
compareExchange
(
false
true
)
;
}
~
AutoWalkJSStack
(
)
{
if
(
walkAllowed
)
{
WALKING_JS_STACK
=
false
;
}
}
}
;
static
void
MergeStacks
(
uint32_t
aFeatures
bool
aIsSynchronous
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
const
NativeStack
&
aNativeStack
ProfilerStackCollector
&
aCollector
)
{
const
ProfilingStack
&
profilingStack
=
aRegisteredThread
.
RacyRegisteredThread
(
)
.
ProfilingStack
(
)
;
const
js
:
:
ProfilingStackFrame
*
profilingStackFrames
=
profilingStack
.
frames
;
uint32_t
profilingStackFrameCount
=
profilingStack
.
stackSize
(
)
;
JSContext
*
context
=
aRegisteredThread
.
GetJSContext
(
)
;
Maybe
<
uint64_t
>
samplePosInBuffer
;
if
(
!
aIsSynchronous
)
{
samplePosInBuffer
=
aCollector
.
SamplePositionInBuffer
(
)
;
}
uint32_t
jsCount
=
0
;
JS
:
:
ProfilingFrameIterator
:
:
Frame
jsFrames
[
MAX_JS_FRAMES
]
;
if
(
context
&
&
JS
:
:
IsProfilingEnabledForContext
(
context
)
)
{
AutoWalkJSStack
autoWalkJSStack
;
const
uint32_t
maxFrames
=
ArrayLength
(
jsFrames
)
;
if
(
autoWalkJSStack
.
walkAllowed
)
{
JS
:
:
ProfilingFrameIterator
:
:
RegisterState
registerState
;
registerState
.
pc
=
aRegs
.
mPC
;
registerState
.
sp
=
aRegs
.
mSP
;
registerState
.
lr
=
aRegs
.
mLR
;
registerState
.
fp
=
aRegs
.
mFP
;
JS
:
:
ProfilingFrameIterator
jsIter
(
context
registerState
samplePosInBuffer
)
;
for
(
;
jsCount
<
maxFrames
&
&
!
jsIter
.
done
(
)
;
+
+
jsIter
)
{
if
(
aIsSynchronous
|
|
jsIter
.
isWasm
(
)
)
{
uint32_t
extracted
=
jsIter
.
extractStack
(
jsFrames
jsCount
maxFrames
)
;
jsCount
+
=
extracted
;
if
(
jsCount
=
=
maxFrames
)
{
break
;
}
}
else
{
Maybe
<
JS
:
:
ProfilingFrameIterator
:
:
Frame
>
frame
=
jsIter
.
getPhysicalFrameWithoutLabel
(
)
;
if
(
frame
.
isSome
(
)
)
{
jsFrames
[
jsCount
+
+
]
=
frame
.
value
(
)
;
}
}
}
}
}
uint32_t
profilingStackIndex
=
0
;
int32_t
jsIndex
=
jsCount
-
1
;
int32_t
nativeIndex
=
aNativeStack
.
mCount
-
1
;
uint8_t
*
lastLabelFrameStackAddr
=
nullptr
;
uint8_t
*
jitEndStackAddr
=
nullptr
;
while
(
profilingStackIndex
!
=
profilingStackFrameCount
|
|
jsIndex
>
=
0
|
|
nativeIndex
>
=
0
)
{
uint8_t
*
profilingStackAddr
=
nullptr
;
uint8_t
*
jsStackAddr
=
nullptr
;
uint8_t
*
nativeStackAddr
=
nullptr
;
uint8_t
*
jsActivationAddr
=
nullptr
;
if
(
profilingStackIndex
!
=
profilingStackFrameCount
)
{
const
js
:
:
ProfilingStackFrame
&
profilingStackFrame
=
profilingStackFrames
[
profilingStackIndex
]
;
if
(
profilingStackFrame
.
isLabelFrame
(
)
|
|
profilingStackFrame
.
isSpMarkerFrame
(
)
)
{
lastLabelFrameStackAddr
=
(
uint8_t
*
)
profilingStackFrame
.
stackAddress
(
)
;
}
if
(
profilingStackFrame
.
isOSRFrame
(
)
)
{
profilingStackIndex
+
+
;
continue
;
}
MOZ_ASSERT
(
lastLabelFrameStackAddr
)
;
profilingStackAddr
=
lastLabelFrameStackAddr
;
}
if
(
jsIndex
>
=
0
)
{
jsStackAddr
=
(
uint8_t
*
)
jsFrames
[
jsIndex
]
.
stackAddress
;
jsActivationAddr
=
(
uint8_t
*
)
jsFrames
[
jsIndex
]
.
activation
;
}
if
(
nativeIndex
>
=
0
)
{
nativeStackAddr
=
(
uint8_t
*
)
aNativeStack
.
mSPs
[
nativeIndex
]
;
}
if
(
nativeStackAddr
&
&
(
profilingStackAddr
=
=
nativeStackAddr
|
|
jsStackAddr
=
=
nativeStackAddr
)
)
{
nativeStackAddr
=
nullptr
;
nativeIndex
-
-
;
MOZ_ASSERT
(
profilingStackAddr
|
|
jsStackAddr
)
;
}
MOZ_ASSERT_IF
(
profilingStackAddr
profilingStackAddr
!
=
jsStackAddr
&
&
profilingStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
jsStackAddr
jsStackAddr
!
=
profilingStackAddr
&
&
jsStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
nativeStackAddr
nativeStackAddr
!
=
profilingStackAddr
&
&
nativeStackAddr
!
=
jsStackAddr
)
;
if
(
profilingStackAddr
>
jsStackAddr
&
&
profilingStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
profilingStackIndex
<
profilingStackFrameCount
)
;
const
js
:
:
ProfilingStackFrame
&
profilingStackFrame
=
profilingStackFrames
[
profilingStackIndex
]
;
if
(
!
profilingStackFrame
.
isSpMarkerFrame
(
)
)
{
MOZ_ASSERT_IF
(
profilingStackFrame
.
isJsFrame
(
)
&
&
profilingStackFrame
.
script
(
)
&
&
!
profilingStackFrame
.
pc
(
)
&
profilingStackFrame
=
=
&
profilingStack
.
frames
[
profilingStack
.
stackSize
(
)
-
1
]
)
;
aCollector
.
CollectProfilingStackFrame
(
profilingStackFrame
)
;
}
profilingStackIndex
+
+
;
continue
;
}
if
(
jsStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
jsIndex
>
=
0
)
;
const
JS
:
:
ProfilingFrameIterator
:
:
Frame
&
jsFrame
=
jsFrames
[
jsIndex
]
;
jitEndStackAddr
=
(
uint8_t
*
)
jsFrame
.
endStackAddress
;
if
(
aIsSynchronous
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Wasm
)
{
aCollector
.
CollectWasmFrame
(
jsFrame
.
label
)
;
}
else
if
(
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_BaselineInterpreter
)
{
JSScript
*
script
=
jsFrame
.
interpreterScript
;
jsbytecode
*
pc
=
jsFrame
.
interpreterPC
(
)
;
js
:
:
ProfilingStackFrame
stackFrame
;
stackFrame
.
initJsFrame
(
"
"
jsFrame
.
label
script
pc
jsFrame
.
realmID
)
;
aCollector
.
CollectProfilingStackFrame
(
stackFrame
)
;
}
else
{
MOZ_ASSERT
(
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Ion
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Baseline
)
;
aCollector
.
CollectJitReturnAddr
(
jsFrame
.
returnAddress
(
)
)
;
}
jsIndex
-
-
;
continue
;
}
if
(
nativeStackAddr
&
&
(
!
jitEndStackAddr
|
|
nativeStackAddr
<
jitEndStackAddr
)
&
&
(
!
jsActivationAddr
|
|
nativeStackAddr
>
jsActivationAddr
)
)
{
MOZ_ASSERT
(
nativeIndex
>
=
0
)
;
void
*
addr
=
(
void
*
)
aNativeStack
.
mPCs
[
nativeIndex
]
;
aCollector
.
CollectNativeLeafAddr
(
addr
)
;
}
if
(
nativeIndex
>
=
0
)
{
nativeIndex
-
-
;
}
}
if
(
!
aIsSynchronous
&
&
context
&
&
aCollector
.
BufferRangeStart
(
)
)
{
uint64_t
bufferRangeStart
=
*
aCollector
.
BufferRangeStart
(
)
;
JS
:
:
SetJSContextProfilerSampleBufferRangeStart
(
context
bufferRangeStart
)
;
}
}
#
if
defined
(
GP_OS_windows
)
&
&
defined
(
USE_MOZ_STACK_WALK
)
static
HANDLE
GetThreadHandle
(
PlatformData
*
aData
)
;
#
endif
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
|
|
defined
(
USE_MOZ_STACK_WALK
)
static
void
StackWalkCallback
(
uint32_t
aFrameNumber
void
*
aPC
void
*
aSP
void
*
aClosure
)
{
NativeStack
*
nativeStack
=
static_cast
<
NativeStack
*
>
(
aClosure
)
;
MOZ_ASSERT
(
nativeStack
-
>
mCount
<
MAX_NATIVE_FRAMES
)
;
nativeStack
-
>
mSPs
[
nativeStack
-
>
mCount
]
=
aSP
;
nativeStack
-
>
mPCs
[
nativeStack
-
>
mCount
]
=
aPC
;
nativeStack
-
>
mCount
+
+
;
}
#
endif
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
static
void
DoFramePointerBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
StackWalkCallback
(
0
aRegs
.
mPC
aRegs
.
mSP
&
aNativeStack
)
;
uint32_t
maxFrames
=
uint32_t
(
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
;
const
void
*
stackEnd
=
aRegisteredThread
.
StackTop
(
)
;
if
(
aRegs
.
mFP
>
=
aRegs
.
mSP
&
&
aRegs
.
mFP
<
=
stackEnd
)
{
FramePointerStackWalk
(
StackWalkCallback
0
maxFrames
&
aNativeStack
reinterpret_cast
<
void
*
*
>
(
aRegs
.
mFP
)
const_cast
<
void
*
>
(
stackEnd
)
)
;
}
}
#
endif
#
if
defined
(
USE_MOZ_STACK_WALK
)
static
void
DoMozStackWalkBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
StackWalkCallback
(
0
aRegs
.
mPC
aRegs
.
mSP
&
aNativeStack
)
;
uint32_t
maxFrames
=
uint32_t
(
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
;
HANDLE
thread
=
GetThreadHandle
(
aRegisteredThread
.
GetPlatformData
(
)
)
;
MOZ_ASSERT
(
thread
)
;
MozStackWalkThread
(
StackWalkCallback
0
maxFrames
&
aNativeStack
thread
nullptr
)
;
}
#
endif
#
ifdef
USE_EHABI_STACKWALK
static
void
DoEHABIBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
const
mcontext_t
*
mcontext
=
&
aRegs
.
mContext
-
>
uc_mcontext
;
mcontext_t
savedContext
;
const
ProfilingStack
&
profilingStack
=
aRegisteredThread
.
RacyRegisteredThread
(
)
.
ProfilingStack
(
)
;
for
(
uint32_t
i
=
profilingStack
.
stackSize
(
)
;
i
>
0
;
-
-
i
)
{
const
js
:
:
ProfilingStackFrame
&
frame
=
profilingStack
.
frames
[
i
-
1
]
;
if
(
!
frame
.
isJsFrame
(
)
&
&
strcmp
(
frame
.
label
(
)
"
EnterJIT
"
)
=
=
0
)
{
uint32_t
*
vSP
=
reinterpret_cast
<
uint32_t
*
>
(
frame
.
stackAddress
(
)
)
;
aNativeStack
.
mCount
+
=
EHABIStackWalk
(
*
mcontext
vSP
aNativeStack
.
mSPs
+
aNativeStack
.
mCount
aNativeStack
.
mPCs
+
aNativeStack
.
mCount
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
;
memset
(
&
savedContext
0
sizeof
(
savedContext
)
)
;
savedContext
.
arm_r4
=
*
vSP
+
+
;
savedContext
.
arm_r5
=
*
vSP
+
+
;
savedContext
.
arm_r6
=
*
vSP
+
+
;
savedContext
.
arm_r7
=
*
vSP
+
+
;
savedContext
.
arm_r8
=
*
vSP
+
+
;
savedContext
.
arm_r9
=
*
vSP
+
+
;
savedContext
.
arm_r10
=
*
vSP
+
+
;
savedContext
.
arm_fp
=
*
vSP
+
+
;
savedContext
.
arm_lr
=
*
vSP
+
+
;
savedContext
.
arm_sp
=
reinterpret_cast
<
uint32_t
>
(
vSP
)
;
savedContext
.
arm_pc
=
savedContext
.
arm_lr
;
mcontext
=
&
savedContext
;
}
}
aNativeStack
.
mCount
+
=
EHABIStackWalk
(
*
mcontext
const_cast
<
void
*
>
(
aRegisteredThread
.
StackTop
(
)
)
aNativeStack
.
mSPs
+
aNativeStack
.
mCount
aNativeStack
.
mPCs
+
aNativeStack
.
mCount
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
;
}
#
endif
#
ifdef
USE_LUL_STACKWALK
#
if
defined
(
MOZ_HAVE_ASAN_BLACKLIST
)
MOZ_ASAN_BLACKLIST
static
void
ASAN_memcpy
(
void
*
aDst
const
void
*
aSrc
size_t
aLen
)
{
char
*
dst
=
static_cast
<
char
*
>
(
aDst
)
;
const
char
*
src
=
static_cast
<
const
char
*
>
(
aSrc
)
;
for
(
size_t
i
=
0
;
i
<
aLen
;
i
+
+
)
{
dst
[
i
]
=
src
[
i
]
;
}
}
#
endif
static
void
DoLULBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
const
mcontext_t
*
mc
=
&
aRegs
.
mContext
-
>
uc_mcontext
;
lul
:
:
UnwindRegs
startRegs
;
memset
(
&
startRegs
0
sizeof
(
startRegs
)
)
;
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_amd64_android
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RSP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RBP
]
)
;
#
elif
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
startRegs
.
r15
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_pc
)
;
startRegs
.
r14
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_lr
)
;
startRegs
.
r13
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_sp
)
;
startRegs
.
r12
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_ip
)
;
startRegs
.
r11
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_fp
)
;
startRegs
.
r7
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_r7
)
;
#
elif
defined
(
GP_PLAT_arm64_linux
)
|
|
defined
(
GP_PLAT_arm64_android
)
startRegs
.
pc
=
lul
:
:
TaggedUWord
(
mc
-
>
pc
)
;
startRegs
.
x29
=
lul
:
:
TaggedUWord
(
mc
-
>
regs
[
29
]
)
;
startRegs
.
x30
=
lul
:
:
TaggedUWord
(
mc
-
>
regs
[
30
]
)
;
startRegs
.
sp
=
lul
:
:
TaggedUWord
(
mc
-
>
sp
)
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_ESP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EBP
]
)
;
#
elif
defined
(
GP_PLAT_mips64_linux
)
startRegs
.
pc
=
lul
:
:
TaggedUWord
(
mc
-
>
pc
)
;
startRegs
.
sp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
29
]
)
;
startRegs
.
fp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
30
]
)
;
#
else
#
error
"
Unknown
plat
"
#
endif
lul
:
:
StackImage
stackImg
;
{
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_amd64_android
)
uintptr_t
rEDZONE_SIZE
=
128
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
r13
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_arm64_linux
)
|
|
defined
(
GP_PLAT_arm64_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
sp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_mips64_linux
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
sp
.
Value
(
)
-
rEDZONE_SIZE
;
#
else
#
error
"
Unknown
plat
"
#
endif
uintptr_t
end
=
reinterpret_cast
<
uintptr_t
>
(
aRegisteredThread
.
StackTop
(
)
)
;
uintptr_t
ws
=
sizeof
(
void
*
)
;
start
&
=
~
(
ws
-
1
)
;
end
&
=
~
(
ws
-
1
)
;
uintptr_t
nToCopy
=
0
;
if
(
start
<
end
)
{
nToCopy
=
end
-
start
;
if
(
nToCopy
>
lul
:
:
N_STACK_BYTES
)
nToCopy
=
lul
:
:
N_STACK_BYTES
;
}
MOZ_ASSERT
(
nToCopy
<
=
lul
:
:
N_STACK_BYTES
)
;
stackImg
.
mLen
=
nToCopy
;
stackImg
.
mStartAvma
=
start
;
if
(
nToCopy
>
0
)
{
#
if
defined
(
MOZ_HAVE_ASAN_BLACKLIST
)
ASAN_memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
#
else
memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
#
endif
(
void
)
VALGRIND_MAKE_MEM_DEFINED
(
&
stackImg
.
mContents
[
0
]
nToCopy
)
;
}
}
size_t
framePointerFramesAcquired
=
0
;
lul
:
:
LUL
*
lul
=
CorePS
:
:
Lul
(
aLock
)
;
lul
-
>
Unwind
(
reinterpret_cast
<
uintptr_t
*
>
(
aNativeStack
.
mPCs
)
reinterpret_cast
<
uintptr_t
*
>
(
aNativeStack
.
mSPs
)
&
aNativeStack
.
mCount
&
framePointerFramesAcquired
MAX_NATIVE_FRAMES
&
startRegs
&
stackImg
)
;
lul
-
>
mStats
.
mContext
+
=
1
;
lul
-
>
mStats
.
mCFI
+
=
aNativeStack
.
mCount
-
1
-
framePointerFramesAcquired
;
lul
-
>
mStats
.
mFP
+
=
framePointerFramesAcquired
;
}
#
endif
#
ifdef
HAVE_NATIVE_UNWIND
static
void
DoNativeBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
#
if
defined
(
USE_LUL_STACKWALK
)
DoLULBacktrace
(
aLock
aRegisteredThread
aRegs
aNativeStack
)
;
#
elif
defined
(
USE_EHABI_STACKWALK
)
DoEHABIBacktrace
(
aLock
aRegisteredThread
aRegs
aNativeStack
)
;
#
elif
defined
(
USE_FRAME_POINTER_STACK_WALK
)
DoFramePointerBacktrace
(
aLock
aRegisteredThread
aRegs
aNativeStack
)
;
#
elif
defined
(
USE_MOZ_STACK_WALK
)
DoMozStackWalkBacktrace
(
aLock
aRegisteredThread
aRegs
aNativeStack
)
;
#
else
#
error
"
Invalid
configuration
"
#
endif
}
#
endif
static
inline
void
DoSharedSample
(
PSLockRef
aLock
bool
aIsSynchronous
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
uint64_t
aSamplePos
ProfileBuffer
&
aBuffer
)
{
MOZ_ASSERT
(
!
aBuffer
.
IsThreadSafe
(
)
"
Mutexes
cannot
be
used
inside
this
critical
section
"
)
;
MOZ_RELEASE_ASSERT
(
ActivePS
:
:
Exists
(
aLock
)
)
;
ProfileBufferCollector
collector
(
aBuffer
ActivePS
:
:
Features
(
aLock
)
aSamplePos
)
;
NativeStack
nativeStack
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
if
(
ActivePS
:
:
FeatureStackWalk
(
aLock
)
)
{
DoNativeBacktrace
(
aLock
aRegisteredThread
aRegs
nativeStack
)
;
MergeStacks
(
ActivePS
:
:
Features
(
aLock
)
aIsSynchronous
aRegisteredThread
aRegs
nativeStack
collector
)
;
}
else
#
endif
{
MergeStacks
(
ActivePS
:
:
Features
(
aLock
)
aIsSynchronous
aRegisteredThread
aRegs
nativeStack
collector
)
;
if
(
ActivePS
:
:
FeatureLeaf
(
aLock
)
)
{
aBuffer
.
AddEntry
(
ProfileBufferEntry
:
:
NativeLeafAddr
(
(
void
*
)
aRegs
.
mPC
)
)
;
}
}
}
static
void
DoSyncSample
(
PSLockRef
aLock
RegisteredThread
&
aRegisteredThread
const
TimeStamp
&
aNow
const
Registers
&
aRegs
ProfileBuffer
&
aBuffer
)
{
uint64_t
samplePos
=
aBuffer
.
AddThreadIdEntry
(
aRegisteredThread
.
Info
(
)
-
>
ThreadId
(
)
)
;
TimeDuration
delta
=
aNow
-
CorePS
:
:
ProcessStartTime
(
)
;
aBuffer
.
AddEntry
(
ProfileBufferEntry
:
:
Time
(
delta
.
ToMilliseconds
(
)
)
)
;
DoSharedSample
(
aLock
true
aRegisteredThread
aRegs
samplePos
aBuffer
)
;
}
static
inline
void
DoPeriodicSample
(
PSLockRef
aLock
RegisteredThread
&
aRegisteredThread
ProfiledThreadData
&
aProfiledThreadData
const
TimeStamp
&
aNow
const
Registers
&
aRegs
uint64_t
aSamplePos
ProfileBuffer
&
aBuffer
)
{
DoSharedSample
(
aLock
false
aRegisteredThread
aRegs
aSamplePos
aBuffer
)
;
}
const
static
uint64_t
kJS_MAX_SAFE_UINTEGER
=
+
9007199254740991ULL
;
static
int64_t
SafeJSInteger
(
uint64_t
aValue
)
{
return
aValue
<
=
kJS_MAX_SAFE_UINTEGER
?
int64_t
(
aValue
)
:
-
1
;
}
static
void
AddSharedLibraryInfoToStream
(
JSONWriter
&
aWriter
const
SharedLibrary
&
aLib
)
{
aWriter
.
StartObjectElement
(
)
;
aWriter
.
IntProperty
(
"
start
"
SafeJSInteger
(
aLib
.
GetStart
(
)
)
)
;
aWriter
.
IntProperty
(
"
end
"
SafeJSInteger
(
aLib
.
GetEnd
(
)
)
)
;
aWriter
.
IntProperty
(
"
offset
"
SafeJSInteger
(
aLib
.
GetOffset
(
)
)
)
;
aWriter
.
StringProperty
(
"
name
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetModuleName
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
path
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetModulePath
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
debugName
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetDebugName
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
debugPath
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetDebugPath
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
breakpadId
"
aLib
.
GetBreakpadId
(
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
arch
"
aLib
.
GetArch
(
)
.
c_str
(
)
)
;
aWriter
.
EndObject
(
)
;
}
void
AppendSharedLibraries
(
JSONWriter
&
aWriter
)
{
SharedLibraryInfo
info
=
SharedLibraryInfo
:
:
GetInfoForSelf
(
)
;
info
.
SortByAddress
(
)
;
for
(
size_t
i
=
0
;
i
<
info
.
GetSize
(
)
;
i
+
+
)
{
AddSharedLibraryInfoToStream
(
aWriter
info
.
GetEntry
(
i
)
)
;
}
}
#
ifdef
MOZ_TASK_TRACER
static
void
StreamNameAndThreadId
(
JSONWriter
&
aWriter
const
char
*
aName
int
aThreadId
)
{
aWriter
.
StartObjectElement
(
)
;
{
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Plugin
)
{
aWriter
.
StringProperty
(
"
name
"
"
Plugin
"
)
;
}
else
{
aWriter
.
StringProperty
(
"
name
"
aName
)
;
}
aWriter
.
IntProperty
(
"
tid
"
aThreadId
)
;
}
aWriter
.
EndObject
(
)
;
}
#
endif
static
void
StreamTaskTracer
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
#
ifdef
MOZ_TASK_TRACER
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
aWriter
.
StartArrayProperty
(
"
data
"
)
;
{
UniquePtr
<
Vector
<
nsCString
>
>
data
=
tasktracer
:
:
GetLoggedData
(
CorePS
:
:
ProcessStartTime
(
)
)
;
for
(
const
nsCString
&
dataString
:
*
data
)
{
aWriter
.
StringElement
(
dataString
.
get
(
)
)
;
}
}
aWriter
.
EndArray
(
)
;
aWriter
.
StartArrayProperty
(
"
threads
"
)
;
{
ActivePS
:
:
DiscardExpiredDeadProfiledThreads
(
aLock
)
;
Vector
<
Pair
<
RegisteredThread
*
ProfiledThreadData
*
>
>
threads
=
ActivePS
:
:
ProfiledThreads
(
aLock
)
;
for
(
auto
&
thread
:
threads
)
{
RefPtr
<
ThreadInfo
>
info
=
thread
.
second
(
)
-
>
Info
(
)
;
StreamNameAndThreadId
(
aWriter
info
-
>
Name
(
)
info
-
>
ThreadId
(
)
)
;
}
}
aWriter
.
EndArray
(
)
;
aWriter
.
DoubleProperty
(
"
start
"
static_cast
<
double
>
(
tasktracer
:
:
GetStartTime
(
)
)
)
;
#
endif
}
static
void
StreamCategories
(
SpliceableJSONWriter
&
aWriter
)
{
#
define
CATEGORY_JSON_BEGIN_CATEGORY
(
name
labelAsString
color
)
\
aWriter
.
Start
(
)
;
\
aWriter
.
StringProperty
(
"
name
"
labelAsString
)
;
\
aWriter
.
StringProperty
(
"
color
"
color
)
;
\
aWriter
.
StartArrayProperty
(
"
subcategories
"
)
;
#
define
CATEGORY_JSON_SUBCATEGORY
(
supercategory
name
labelAsString
)
\
aWriter
.
StringElement
(
labelAsString
)
;
#
define
CATEGORY_JSON_END_CATEGORY
\
aWriter
.
EndArray
(
)
;
\
aWriter
.
EndObject
(
)
;
PROFILING_CATEGORY_LIST
(
CATEGORY_JSON_BEGIN_CATEGORY
CATEGORY_JSON_SUBCATEGORY
CATEGORY_JSON_END_CATEGORY
)
#
undef
CATEGORY_JSON_BEGIN_CATEGORY
#
undef
CATEGORY_JSON_SUBCATEGORY
#
undef
CATEGORY_JSON_END_CATEGORY
}
static
void
StreamMetaJSCustomObject
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
bool
aIsShuttingDown
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
aWriter
.
IntProperty
(
"
version
"
19
)
;
TimeDuration
delta
=
TimeStamp
:
:
NowUnfuzzed
(
)
-
CorePS
:
:
ProcessStartTime
(
)
;
aWriter
.
DoubleProperty
(
"
startTime
"
static_cast
<
double
>
(
PR_Now
(
)
/
1000
.
0
-
delta
.
ToMilliseconds
(
)
)
)
;
if
(
aIsShuttingDown
)
{
aWriter
.
DoubleProperty
(
"
shutdownTime
"
profiler_time
(
)
)
;
}
else
{
aWriter
.
NullProperty
(
"
shutdownTime
"
)
;
}
aWriter
.
StartArrayProperty
(
"
categories
"
)
;
StreamCategories
(
aWriter
)
;
aWriter
.
EndArray
(
)
;
ActivePS
:
:
WriteActiveConfiguration
(
aLock
aWriter
"
configuration
"
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
aWriter
.
DoubleProperty
(
"
interval
"
ActivePS
:
:
Interval
(
aLock
)
)
;
aWriter
.
IntProperty
(
"
stackwalk
"
ActivePS
:
:
FeatureStackWalk
(
aLock
)
)
;
#
ifdef
DEBUG
aWriter
.
IntProperty
(
"
debug
"
1
)
;
#
else
aWriter
.
IntProperty
(
"
debug
"
0
)
;
#
endif
aWriter
.
IntProperty
(
"
gcpoison
"
JS
:
:
IsGCPoisoning
(
)
?
1
:
0
)
;
bool
asyncStacks
=
Preferences
:
:
GetBool
(
"
javascript
.
options
.
asyncstack
"
)
;
aWriter
.
IntProperty
(
"
asyncstack
"
asyncStacks
)
;
aWriter
.
IntProperty
(
"
processType
"
XRE_GetProcessType
(
)
)
;
aWriter
.
StringProperty
(
"
updateChannel
"
MOZ_STRINGIFY
(
MOZ_UPDATE_CHANNEL
)
)
;
nsresult
res
;
nsCOMPtr
<
nsIHttpProtocolHandler
>
http
=
do_GetService
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
"
http
"
&
res
)
;
if
(
!
NS_FAILED
(
res
)
)
{
nsAutoCString
string
;
res
=
http
-
>
GetPlatform
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
platform
"
string
.
Data
(
)
)
;
}
res
=
http
-
>
GetOscpu
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
oscpu
"
string
.
Data
(
)
)
;
}
res
=
http
-
>
GetMisc
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
misc
"
string
.
Data
(
)
)
;
}
}
nsCOMPtr
<
nsIXULRuntime
>
runtime
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
runtime
)
{
nsAutoCString
string
;
res
=
runtime
-
>
GetXPCOMABI
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
abi
"
string
.
Data
(
)
)
;
res
=
runtime
-
>
GetWidgetToolkit
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
toolkit
"
string
.
Data
(
)
)
;
}
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
)
;
if
(
appInfo
)
{
nsAutoCString
string
;
res
=
appInfo
-
>
GetName
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
product
"
string
.
Data
(
)
)
;
res
=
appInfo
-
>
GetAppBuildID
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
appBuildID
"
string
.
Data
(
)
)
;
res
=
appInfo
-
>
GetSourceURL
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
sourceURL
"
string
.
Data
(
)
)
;
}
nsCOMPtr
<
nsIPropertyBag2
>
systemInfo
=
do_GetService
(
"
mozilla
.
org
/
system
-
info
;
1
"
)
;
if
(
systemInfo
)
{
int32_t
cpus
;
res
=
systemInfo
-
>
GetPropertyAsInt32
(
NS_LITERAL_STRING
(
"
cpucores
"
)
&
cpus
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
IntProperty
(
"
physicalCPUs
"
cpus
)
;
}
res
=
systemInfo
-
>
GetPropertyAsInt32
(
NS_LITERAL_STRING
(
"
cpucount
"
)
&
cpus
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
IntProperty
(
"
logicalCPUs
"
cpus
)
;
}
}
if
(
!
gXPCOMShuttingDown
)
{
aWriter
.
StartObjectProperty
(
"
extensions
"
)
;
{
{
JSONSchemaWriter
schema
(
aWriter
)
;
schema
.
WriteField
(
"
id
"
)
;
schema
.
WriteField
(
"
name
"
)
;
schema
.
WriteField
(
"
baseURL
"
)
;
}
aWriter
.
StartArrayProperty
(
"
data
"
)
;
{
nsTArray
<
RefPtr
<
WebExtensionPolicy
>
>
exts
;
ExtensionPolicyService
:
:
GetSingleton
(
)
.
GetAll
(
exts
)
;
for
(
auto
&
ext
:
exts
)
{
aWriter
.
StartArrayElement
(
JSONWriter
:
:
SingleLineStyle
)
;
nsAutoString
id
;
ext
-
>
GetId
(
id
)
;
aWriter
.
StringElement
(
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
)
;
aWriter
.
StringElement
(
NS_ConvertUTF16toUTF8
(
ext
-
>
Name
(
)
)
.
get
(
)
)
;
auto
url
=
ext
-
>
GetURL
(
NS_LITERAL_STRING
(
"
"
)
)
;
if
(
url
.
isOk
(
)
)
{
aWriter
.
StringElement
(
NS_ConvertUTF16toUTF8
(
url
.
unwrap
(
)
)
.
get
(
)
)
;
}
aWriter
.
EndArray
(
)
;
}
}
aWriter
.
EndArray
(
)
;
}
aWriter
.
EndObject
(
)
;
}
}
static
void
StreamPages
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
ActivePS
:
:
DiscardExpiredPages
(
aLock
)
;
for
(
const
auto
&
page
:
ActivePS
:
:
ProfiledPages
(
aLock
)
)
{
page
-
>
StreamJSON
(
aWriter
)
;
}
}
#
if
defined
(
GP_OS_android
)
static
UniquePtr
<
ProfileBuffer
>
CollectJavaThreadProfileData
(
BlocksRingBuffer
&
bufferManager
)
{
auto
buffer
=
MakeUnique
<
ProfileBuffer
>
(
bufferManager
MakePowerOfTwo32
<
8
*
1024
*
1024
>
(
)
)
;
int
sampleId
=
0
;
while
(
true
)
{
double
sampleTime
=
java
:
:
GeckoJavaSampler
:
:
GetSampleTime
(
0
sampleId
)
;
if
(
sampleTime
=
=
0
.
0
)
{
break
;
}
buffer
-
>
AddThreadIdEntry
(
0
)
;
buffer
-
>
AddEntry
(
ProfileBufferEntry
:
:
Time
(
sampleTime
)
)
;
bool
parentFrameWasIdleFrame
=
false
;
int
frameId
=
0
;
while
(
true
)
{
jni
:
:
String
:
:
LocalRef
frameName
=
java
:
:
GeckoJavaSampler
:
:
GetFrameName
(
0
sampleId
frameId
+
+
)
;
if
(
!
frameName
)
{
break
;
}
nsCString
frameNameString
=
frameName
-
>
ToCString
(
)
;
Maybe
<
JS
:
:
ProfilingCategoryPair
>
categoryPair
;
if
(
frameNameString
.
EqualsLiteral
(
"
android
.
os
.
MessageQueue
.
nativePollOnce
(
)
"
)
)
{
categoryPair
=
Some
(
JS
:
:
ProfilingCategoryPair
:
:
IDLE
)
;
parentFrameWasIdleFrame
=
true
;
}
else
if
(
parentFrameWasIdleFrame
)
{
categoryPair
=
Some
(
JS
:
:
ProfilingCategoryPair
:
:
OTHER
)
;
parentFrameWasIdleFrame
=
false
;
}
buffer
-
>
CollectCodeLocation
(
"
"
frameNameString
.
get
(
)
0
0
Nothing
(
)
Nothing
(
)
categoryPair
)
;
}
sampleId
+
+
;
}
return
buffer
;
}
#
endif
UniquePtr
<
ProfilerCodeAddressService
>
profiler_code_address_service_for_presymbolication
(
)
{
static
const
bool
preSymbolicate
=
[
]
(
)
{
const
char
*
symbolicate
=
getenv
(
"
MOZ_PROFILER_SYMBOLICATE
"
)
;
return
symbolicate
&
&
symbolicate
[
0
]
!
=
'
\
0
'
;
}
(
)
;
return
preSymbolicate
?
MakeUnique
<
ProfilerCodeAddressService
>
(
)
:
nullptr
;
}
static
void
locked_profiler_stream_json_for_this_process
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
double
aSinceTime
bool
aIsShuttingDown
ProfilerCodeAddressService
*
aService
)
{
LOG
(
"
locked_profiler_stream_json_for_this_process
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
AUTO_PROFILER_STATS
(
locked_profiler_stream_json_for_this_process
)
;
const
double
collectionStartMs
=
profiler_time
(
)
;
ProfileBuffer
&
buffer
=
ActivePS
:
:
Buffer
(
aLock
)
;
Maybe
<
double
>
durationS
=
ActivePS
:
:
Duration
(
aLock
)
;
if
(
durationS
.
isSome
(
)
)
{
const
double
durationStartMs
=
collectionStartMs
-
*
durationS
*
1000
;
buffer
.
DiscardSamplesBeforeTime
(
durationStartMs
)
;
}
aWriter
.
StartArrayProperty
(
"
libs
"
)
;
AppendSharedLibraries
(
aWriter
)
;
aWriter
.
EndArray
(
)
;
aWriter
.
StartObjectProperty
(
"
meta
"
)
;
{
StreamMetaJSCustomObject
(
aLock
aWriter
aIsShuttingDown
)
;
}
aWriter
.
EndObject
(
)
;
aWriter
.
StartArrayProperty
(
"
pages
"
)
;
{
StreamPages
(
aLock
aWriter
)
;
}
aWriter
.
EndArray
(
)
;
buffer
.
StreamProfilerOverheadToJSON
(
aWriter
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
)
;
buffer
.
StreamCountersToJSON
(
aWriter
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
)
;
if
(
ActivePS
:
:
FeatureTaskTracer
(
aLock
)
)
{
aWriter
.
StartObjectProperty
(
"
tasktracer
"
)
;
StreamTaskTracer
(
aLock
aWriter
)
;
aWriter
.
EndObject
(
)
;
}
aWriter
.
StartArrayProperty
(
"
threads
"
)
;
{
ActivePS
:
:
DiscardExpiredDeadProfiledThreads
(
aLock
)
;
Vector
<
Pair
<
RegisteredThread
*
ProfiledThreadData
*
>
>
threads
=
ActivePS
:
:
ProfiledThreads
(
aLock
)
;
for
(
auto
&
thread
:
threads
)
{
RegisteredThread
*
registeredThread
=
thread
.
first
(
)
;
JSContext
*
cx
=
registeredThread
?
registeredThread
-
>
GetJSContext
(
)
:
nullptr
;
ProfiledThreadData
*
profiledThreadData
=
thread
.
second
(
)
;
profiledThreadData
-
>
StreamJSON
(
buffer
cx
aWriter
CorePS
:
:
ProcessName
(
aLock
)
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
ActivePS
:
:
FeatureJSTracer
(
aLock
)
aService
)
;
}
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
java
:
:
GeckoJavaSampler
:
:
Pause
(
)
;
BlocksRingBuffer
bufferManager
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithoutMutex
)
;
UniquePtr
<
ProfileBuffer
>
javaBuffer
=
CollectJavaThreadProfileData
(
bufferManager
)
;
RefPtr
<
ThreadInfo
>
threadInfo
=
new
ThreadInfo
(
"
Java
Main
Thread
"
0
false
CorePS
:
:
ProcessStartTime
(
)
)
;
ProfiledThreadData
profiledThreadData
(
threadInfo
nullptr
)
;
profiledThreadData
.
StreamJSON
(
*
javaBuffer
.
get
(
)
nullptr
aWriter
CorePS
:
:
ProcessName
(
aLock
)
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
ActivePS
:
:
FeatureJSTracer
(
aLock
)
nullptr
)
;
java
:
:
GeckoJavaSampler
:
:
Unpause
(
)
;
}
#
endif
#
ifdef
MOZ_BASE_PROFILER
UniquePtr
<
char
[
]
>
baseProfileThreads
=
ActivePS
:
:
MoveBaseProfileThreads
(
aLock
)
;
if
(
baseProfileThreads
)
{
aWriter
.
Splice
(
baseProfileThreads
.
get
(
)
)
;
}
#
endif
}
aWriter
.
EndArray
(
)
;
if
(
ActivePS
:
:
FeatureJSTracer
(
aLock
)
)
{
aWriter
.
StartArrayProperty
(
"
jsTracerDictionary
"
)
;
{
JS
:
:
AutoTraceLoggerLockGuard
lockGuard
;
JS
:
:
TraceLoggerDictionaryBuffer
collectionBuffer
(
lockGuard
)
;
while
(
collectionBuffer
.
NextChunk
(
)
)
{
aWriter
.
StringElement
(
collectionBuffer
.
internalBuffer
(
)
)
;
}
}
aWriter
.
EndArray
(
)
;
}
aWriter
.
StartArrayProperty
(
"
pausedRanges
"
)
;
{
buffer
.
StreamPausedRangesToJSON
(
aWriter
aSinceTime
)
;
}
aWriter
.
EndArray
(
)
;
const
double
collectionEndMs
=
profiler_time
(
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CollectionStart
(
collectionStartMs
)
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CollectionEnd
(
collectionEndMs
)
)
;
}
bool
profiler_stream_json_for_this_process
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
bool
aIsShuttingDown
ProfilerCodeAddressService
*
aService
)
{
LOG
(
"
profiler_stream_json_for_this_process
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
locked_profiler_stream_json_for_this_process
(
lock
aWriter
aSinceTime
aIsShuttingDown
aService
)
;
return
true
;
}
static
char
FeatureCategory
(
uint32_t
aFeature
)
{
if
(
aFeature
&
DefaultFeatures
(
)
)
{
if
(
aFeature
&
AvailableFeatures
(
)
)
{
return
'
D
'
;
}
return
'
d
'
;
}
if
(
aFeature
&
StartupExtraDefaultFeatures
(
)
)
{
if
(
aFeature
&
AvailableFeatures
(
)
)
{
return
'
S
'
;
}
return
'
s
'
;
}
if
(
aFeature
&
AvailableFeatures
(
)
)
{
return
'
-
'
;
}
return
'
x
'
;
}
static
void
PrintUsageThenExit
(
int
aExitCode
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
printf
(
"
\
n
"
"
Profiler
environment
variable
usage
:
\
n
"
"
\
n
"
"
MOZ_PROFILER_HELP
\
n
"
"
If
set
to
any
value
prints
this
message
.
\
n
"
#
ifdef
MOZ_BASE_PROFILER
"
Use
MOZ_BASE_PROFILER_HELP
for
BaseProfiler
help
.
\
n
"
#
endif
"
\
n
"
"
MOZ_LOG
\
n
"
"
Enables
logging
.
The
levels
of
logging
available
are
\
n
"
"
'
prof
:
3
'
(
least
verbose
)
'
prof
:
4
'
'
prof
:
5
'
(
most
verbose
)
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP
\
n
"
"
If
set
to
any
value
other
than
'
'
or
'
0
'
/
'
N
'
/
'
n
'
starts
the
\
n
"
"
profiler
immediately
on
start
-
up
.
\
n
"
"
Useful
if
you
want
profile
code
that
runs
very
early
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_ENTRIES
=
<
1
.
.
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
number
of
entries
per
\
n
"
"
process
in
the
profiler
'
s
circular
buffer
when
the
profiler
is
first
\
n
"
"
started
.
\
n
"
"
If
unset
the
platform
default
is
used
:
\
n
"
"
%
u
entries
per
process
or
%
u
when
MOZ_PROFILER_STARTUP
is
set
.
\
n
"
"
(
8
bytes
per
entry
-
>
%
u
or
%
u
total
bytes
per
process
)
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_DURATION
=
<
1
.
.
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
maximum
life
time
of
\
n
"
"
entries
in
the
the
profiler
'
s
circular
buffer
when
the
profiler
is
\
n
"
"
first
started
in
seconds
.
\
n
"
"
If
unset
the
life
time
of
the
entries
will
only
be
restricted
by
\
n
"
"
MOZ_PROFILER_STARTUP_ENTRIES
(
or
its
default
value
)
and
no
\
n
"
"
additional
time
duration
restriction
will
be
applied
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_INTERVAL
=
<
1
.
.
%
d
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
sample
interval
\
n
"
"
measured
in
milliseconds
when
the
profiler
is
first
started
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
=
<
Number
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
profiling
features
as
\
n
"
"
the
integer
value
of
the
features
bitfield
.
\
n
"
"
If
unset
the
value
from
MOZ_PROFILER_STARTUP_FEATURES
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FEATURES
=
<
Features
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
profiling
features
as
\
n
"
"
a
comma
-
separated
list
of
strings
.
\
n
"
"
Ignored
if
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
is
set
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
Features
:
(
x
=
unavailable
D
/
d
=
default
/
unavailable
\
n
"
"
S
/
s
=
MOZ_PROFILER_STARTUP
extra
default
/
unavailable
)
\
n
"
unsigned
(
PROFILER_DEFAULT_ENTRIES
.
Value
(
)
)
unsigned
(
PROFILER_DEFAULT_STARTUP_ENTRIES
.
Value
(
)
)
unsigned
(
PROFILER_DEFAULT_ENTRIES
.
Value
(
)
*
8
)
unsigned
(
PROFILER_DEFAULT_STARTUP_ENTRIES
.
Value
(
)
*
8
)
PROFILER_MAX_INTERVAL
)
;
#
define
PRINT_FEATURE
(
n_
str_
Name_
desc_
)
\
printf
(
"
%
c
%
5u
:
\
"
%
s
\
"
(
%
s
)
\
n
"
FeatureCategory
(
ProfilerFeature
:
:
Name_
)
\
ProfilerFeature
:
:
Name_
str_
desc_
)
;
PROFILER_FOR_EACH_FEATURE
(
PRINT_FEATURE
)
#
undef
PRINT_FEATURE
printf
(
"
-
\
"
default
\
"
(
All
above
D
+
S
defaults
)
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FILTERS
=
<
Filters
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
thread
filters
as
a
\
n
"
"
comma
-
separated
list
of
strings
.
A
given
thread
will
be
sampled
if
\
n
"
"
any
of
the
filters
is
a
case
-
insensitive
substring
of
the
thread
\
n
"
"
name
.
If
unset
a
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_SHUTDOWN
\
n
"
"
If
set
the
profiler
saves
a
profile
to
the
named
file
on
shutdown
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_SYMBOLICATE
\
n
"
"
If
set
the
profiler
will
pre
-
symbolicate
profiles
.
\
n
"
"
*
Note
*
This
will
add
a
significant
pause
when
gathering
data
and
\
n
"
"
is
intended
mainly
for
local
development
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_LUL_TEST
\
n
"
"
If
set
to
any
value
runs
LUL
unit
tests
at
startup
.
\
n
"
"
\
n
"
"
This
platform
%
s
native
unwinding
.
\
n
"
"
\
n
"
#
if
defined
(
HAVE_NATIVE_UNWIND
)
"
supports
"
#
else
"
does
not
support
"
#
endif
)
;
if
(
aExitCode
!
=
0
)
{
exit
(
aExitCode
)
;
}
}
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
struct
SigHandlerCoordinator
;
#
endif
class
Sampler
{
public
:
explicit
Sampler
(
PSLockRef
aLock
)
;
void
Disable
(
PSLockRef
aLock
)
;
template
<
typename
Func
>
void
SuspendAndSampleAndResumeThread
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
TimeStamp
&
aNow
const
Func
&
aProcessRegs
)
;
private
:
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
struct
sigaction
mOldSigprofHandler
;
int
mMyPid
;
int
mSamplerTid
;
public
:
static
struct
SigHandlerCoordinator
*
sSigHandlerCoordinator
;
#
endif
}
;
class
SamplerThread
{
public
:
SamplerThread
(
PSLockRef
aLock
uint32_t
aActivityGeneration
double
aIntervalMilliseconds
)
;
~
SamplerThread
(
)
;
void
Run
(
)
;
void
Stop
(
PSLockRef
aLock
)
;
void
AppendPostSamplingCallback
(
PSLockRef
PostSamplingCallback
&
&
aCallback
)
{
mPostSamplingCallbackList
=
MakeUnique
<
PostSamplingCallbackListItem
>
(
std
:
:
move
(
mPostSamplingCallbackList
)
std
:
:
move
(
aCallback
)
)
;
}
private
:
struct
PostSamplingCallbackListItem
{
UniquePtr
<
PostSamplingCallbackListItem
>
mPrev
;
PostSamplingCallback
mCallback
;
PostSamplingCallbackListItem
(
UniquePtr
<
PostSamplingCallbackListItem
>
aPrev
PostSamplingCallback
&
&
aCallback
)
:
mPrev
(
std
:
:
move
(
aPrev
)
)
mCallback
(
std
:
:
move
(
aCallback
)
)
{
}
}
;
MOZ_MUST_USE
UniquePtr
<
PostSamplingCallbackListItem
>
TakePostSamplingCallbacks
(
PSLockRef
)
{
return
std
:
:
move
(
mPostSamplingCallbackList
)
;
}
static
void
InvokePostSamplingCallbacks
(
UniquePtr
<
PostSamplingCallbackListItem
>
aCallbacks
SamplingState
aSamplingState
)
{
if
(
!
aCallbacks
)
{
return
;
}
InvokePostSamplingCallbacks
(
std
:
:
move
(
aCallbacks
-
>
mPrev
)
aSamplingState
)
;
std
:
:
move
(
aCallbacks
-
>
mCallback
)
(
aSamplingState
)
;
static_assert
(
IsSame
<
decltype
(
aCallbacks
)
UniquePtr
<
PostSamplingCallbackListItem
>
>
:
:
value
"
We
need
to
capture
the
list
by
-
value
to
implicitly
destroy
it
"
)
;
}
void
SleepMicro
(
uint32_t
aMicroseconds
)
;
Sampler
mSampler
;
const
uint32_t
mActivityGeneration
;
const
int
mIntervalMicroseconds
;
#
if
defined
(
GP_OS_windows
)
HANDLE
mThread
;
#
elif
defined
(
GP_OS_darwin
)
|
|
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
pthread_t
mThread
;
#
endif
UniquePtr
<
PostSamplingCallbackListItem
>
mPostSamplingCallbackList
;
SamplerThread
(
const
SamplerThread
&
)
=
delete
;
void
operator
=
(
const
SamplerThread
&
)
=
delete
;
}
;
bool
ActivePS
:
:
AppendPostSamplingCallback
(
PSLockRef
aLock
PostSamplingCallback
&
&
aCallback
)
{
if
(
!
sInstance
|
|
!
sInstance
-
>
mSamplerThread
)
{
return
false
;
}
sInstance
-
>
mSamplerThread
-
>
AppendPostSamplingCallback
(
aLock
std
:
:
move
(
aCallback
)
)
;
return
true
;
}
static
SamplerThread
*
NewSamplerThread
(
PSLockRef
aLock
uint32_t
aGeneration
double
aInterval
)
{
return
new
SamplerThread
(
aLock
aGeneration
aInterval
)
;
}
void
SamplerThread
:
:
Run
(
)
{
PR_SetCurrentThreadName
(
"
SamplerThread
"
)
;
const
bool
noStackSampling
=
[
]
(
)
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
return
ActivePS
:
:
FeatureNoStackSampling
(
lock
)
;
}
(
)
;
BlocksRingBuffer
localBlocksRingBuffer
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithoutMutex
)
;
ProfileBuffer
localProfileBuffer
(
localBlocksRingBuffer
MakePowerOfTwo32
<
65536
>
(
)
)
;
auto
previousState
=
localBlocksRingBuffer
.
GetState
(
)
;
TimeDuration
lastSleepOvershoot
=
0
;
TimeStamp
sampleStart
=
TimeStamp
:
:
NowUnfuzzed
(
)
;
UniquePtr
<
PostSamplingCallbackListItem
>
postSamplingCallbacks
;
SamplingState
samplingState
{
}
;
while
(
true
)
{
{
MOZ_ASSERT
(
!
postSamplingCallbacks
)
;
PSAutoLock
lock
(
gPSMutex
)
;
TimeStamp
lockAcquired
=
TimeStamp
:
:
NowUnfuzzed
(
)
;
postSamplingCallbacks
=
TakePostSamplingCallbacks
(
lock
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
samplingState
=
SamplingState
:
:
JustStopped
;
break
;
}
if
(
ActivePS
:
:
Generation
(
lock
)
!
=
mActivityGeneration
)
{
samplingState
=
SamplingState
:
:
JustStopped
;
break
;
}
ActivePS
:
:
ClearExpiredExitProfiles
(
lock
)
;
TimeStamp
expiredMarkersCleaned
=
TimeStamp
:
:
NowUnfuzzed
(
)
;
if
(
!
ActivePS
:
:
IsPaused
(
lock
)
)
{
TimeDuration
delta
=
sampleStart
-
CorePS
:
:
ProcessStartTime
(
)
;
ProfileBuffer
&
buffer
=
ActivePS
:
:
Buffer
(
lock
)
;
const
Vector
<
BaseProfilerCount
*
>
&
counters
=
CorePS
:
:
Counters
(
lock
)
;
for
(
auto
&
counter
:
counters
)
{
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CounterId
(
counter
)
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Time
(
delta
.
ToMilliseconds
(
)
)
)
;
int64_t
count
;
uint64_t
number
;
counter
-
>
Sample
(
count
number
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CounterKey
(
0
)
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Count
(
count
)
)
;
if
(
number
)
{
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Number
(
number
)
)
;
}
}
TimeStamp
countersSampled
=
TimeStamp
:
:
NowUnfuzzed
(
)
;
if
(
!
noStackSampling
)
{
samplingState
=
SamplingState
:
:
SamplingCompleted
;
const
Vector
<
LiveProfiledThreadData
>
&
liveThreads
=
ActivePS
:
:
LiveProfiledThreads
(
lock
)
;
for
(
auto
&
thread
:
liveThreads
)
{
RegisteredThread
*
registeredThread
=
thread
.
mRegisteredThread
;
ProfiledThreadData
*
profiledThreadData
=
thread
.
mProfiledThreadData
.
get
(
)
;
RefPtr
<
ThreadInfo
>
info
=
registeredThread
-
>
Info
(
)
;
if
(
registeredThread
-
>
RacyRegisteredThread
(
)
.
CanDuplicateLastSampleDueToSleep
(
)
)
{
bool
dup_ok
=
ActivePS
:
:
Buffer
(
lock
)
.
DuplicateLastSample
(
info
-
>
ThreadId
(
)
CorePS
:
:
ProcessStartTime
(
)
profiledThreadData
-
>
LastSample
(
)
)
;
if
(
dup_ok
)
{
continue
;
}
}
AUTO_PROFILER_STATS
(
gecko_SamplerThread_Run_DoPeriodicSample
)
;
TimeStamp
now
=
TimeStamp
:
:
NowUnfuzzed
(
)
;
uint64_t
samplePos
=
buffer
.
AddThreadIdEntry
(
registeredThread
-
>
Info
(
)
-
>
ThreadId
(
)
)
;
profiledThreadData
-
>
LastSample
(
)
=
Some
(
samplePos
)
;
TimeDuration
delta
=
now
-
CorePS
:
:
ProcessStartTime
(
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
TimeBeforeCompactStack
(
delta
.
ToMilliseconds
(
)
)
)
;
Maybe
<
double
>
unresponsiveDuration_ms
;
mSampler
.
SuspendAndSampleAndResumeThread
(
lock
*
registeredThread
now
[
&
]
(
const
Registers
&
aRegs
const
TimeStamp
&
aNow
)
{
DoPeriodicSample
(
lock
*
registeredThread
*
profiledThreadData
now
aRegs
samplePos
localProfileBuffer
)
;
TimeDuration
currentEventDelay
;
TimeDuration
currentEventRunning
;
registeredThread
-
>
GetRunningEventDelay
(
aNow
currentEventDelay
currentEventRunning
)
;
unresponsiveDuration_ms
=
Some
(
currentEventDelay
.
ToMilliseconds
(
)
+
currentEventRunning
.
ToMilliseconds
(
)
)
;
}
)
;
if
(
unresponsiveDuration_ms
.
isSome
(
)
)
{
CorePS
:
:
CoreBlocksRingBuffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
UnresponsiveDurationMs
*
unresponsiveDuration_ms
)
;
}
auto
state
=
localBlocksRingBuffer
.
GetState
(
)
;
if
(
NS_WARN_IF
(
state
.
mClearedBlockCount
!
=
previousState
.
mClearedBlockCount
)
)
{
LOG
(
"
Stack
sample
too
big
for
local
storage
needed
%
u
bytes
"
unsigned
(
state
.
mRangeEnd
.
ConvertToU64
(
)
-
previousState
.
mRangeEnd
.
ConvertToU64
(
)
)
)
;
CorePS
:
:
CoreBlocksRingBuffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
CompactStack
UniquePtr
<
BlocksRingBuffer
>
(
nullptr
)
)
;
}
else
if
(
state
.
mRangeEnd
.
ConvertToU64
(
)
-
previousState
.
mRangeEnd
.
ConvertToU64
(
)
>
=
CorePS
:
:
CoreBlocksRingBuffer
(
)
.
BufferLength
(
)
-
>
Value
(
)
)
{
LOG
(
"
Stack
sample
too
big
for
profiler
storage
needed
%
u
bytes
"
unsigned
(
state
.
mRangeEnd
.
ConvertToU64
(
)
-
previousState
.
mRangeEnd
.
ConvertToU64
(
)
)
)
;
CorePS
:
:
CoreBlocksRingBuffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
CompactStack
UniquePtr
<
BlocksRingBuffer
>
(
nullptr
)
)
;
}
else
{
CorePS
:
:
CoreBlocksRingBuffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
CompactStack
localBlocksRingBuffer
)
;
}
localBlocksRingBuffer
.
Clear
(
)
;
previousState
=
localBlocksRingBuffer
.
GetState
(
)
;
}
}
else
{
samplingState
=
SamplingState
:
:
NoStackSamplingCompleted
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
CorePS
:
:
Lul
(
lock
)
-
>
MaybeShowStats
(
)
;
#
endif
TimeStamp
threadsSampled
=
TimeStamp
:
:
NowUnfuzzed
(
)
;
buffer
.
CollectOverheadStats
(
delta
lockAcquired
-
sampleStart
expiredMarkersCleaned
-
lockAcquired
countersSampled
-
expiredMarkersCleaned
threadsSampled
-
countersSampled
)
;
}
else
{
samplingState
=
SamplingState
:
:
SamplingPaused
;
}
}
InvokePostSamplingCallbacks
(
std
:
:
move
(
postSamplingCallbacks
)
samplingState
)
;
TimeStamp
targetSleepEndTime
=
sampleStart
+
TimeDuration
:
:
FromMicroseconds
(
mIntervalMicroseconds
)
;
TimeStamp
beforeSleep
=
TimeStamp
:
:
NowUnfuzzed
(
)
;
TimeDuration
targetSleepDuration
=
targetSleepEndTime
-
beforeSleep
;
double
sleepTime
=
std
:
:
max
(
0
.
0
(
targetSleepDuration
-
lastSleepOvershoot
)
.
ToMicroseconds
(
)
)
;
SleepMicro
(
static_cast
<
uint32_t
>
(
sleepTime
)
)
;
sampleStart
=
TimeStamp
:
:
NowUnfuzzed
(
)
;
lastSleepOvershoot
=
sampleStart
-
(
beforeSleep
+
TimeDuration
:
:
FromMicroseconds
(
sleepTime
)
)
;
}
InvokePostSamplingCallbacks
(
std
:
:
move
(
postSamplingCallbacks
)
samplingState
)
;
}
#
if
defined
(
GP_OS_windows
)
#
include
"
platform
-
win32
.
cpp
"
#
elif
defined
(
GP_OS_darwin
)
#
include
"
platform
-
macos
.
cpp
"
#
elif
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
#
include
"
platform
-
linux
-
android
.
cpp
"
#
else
#
error
"
bad
platform
"
#
endif
UniquePlatformData
AllocPlatformData
(
int
aThreadId
)
{
return
UniquePlatformData
(
new
PlatformData
(
aThreadId
)
)
;
}
void
PlatformDataDestructor
:
:
operator
(
)
(
PlatformData
*
aData
)
{
delete
aData
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
GeckoProfilerMallocSizeOf
)
NS_IMETHODIMP
GeckoProfilerReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
size_t
profSize
=
0
;
size_t
lulSize
=
0
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
CorePS
:
:
Exists
(
)
)
{
CorePS
:
:
AddSizeOf
(
lock
GeckoProfilerMallocSizeOf
profSize
lulSize
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
profSize
+
=
ActivePS
:
:
SizeOf
(
lock
GeckoProfilerMallocSizeOf
)
;
}
}
MOZ_COLLECT_REPORT
(
"
explicit
/
profiler
/
profiler
-
state
"
KIND_HEAP
UNITS_BYTES
profSize
"
Memory
used
by
the
Gecko
Profiler
'
s
global
state
(
excluding
memory
used
"
"
by
LUL
)
.
"
)
;
#
if
defined
(
USE_LUL_STACKWALK
)
MOZ_COLLECT_REPORT
(
"
explicit
/
profiler
/
lul
"
KIND_HEAP
UNITS_BYTES
lulSize
"
Memory
used
by
LUL
a
stack
unwinder
used
by
the
Gecko
Profiler
.
"
)
;
#
endif
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
GeckoProfilerReporter
nsIMemoryReporter
)
static
uint32_t
ParseFeature
(
const
char
*
aFeature
bool
aIsStartup
)
{
if
(
strcmp
(
aFeature
"
default
"
)
=
=
0
)
{
return
(
aIsStartup
?
(
DefaultFeatures
(
)
|
StartupExtraDefaultFeatures
(
)
)
:
DefaultFeatures
(
)
)
&
AvailableFeatures
(
)
;
}
#
define
PARSE_FEATURE_BIT
(
n_
str_
Name_
desc_
)
\
if
(
strcmp
(
aFeature
str_
)
=
=
0
)
{
\
return
ProfilerFeature
:
:
Name_
;
\
}
PROFILER_FOR_EACH_FEATURE
(
PARSE_FEATURE_BIT
)
#
undef
PARSE_FEATURE_BIT
printf
(
"
\
nUnrecognized
feature
\
"
%
s
\
"
.
\
n
\
n
"
aFeature
)
;
PrintUsageThenExit
(
0
)
;
return
0
;
}
uint32_t
ParseFeaturesFromStringArray
(
const
char
*
*
aFeatures
uint32_t
aFeatureCount
bool
aIsStartup
)
{
uint32_t
features
=
0
;
for
(
size_t
i
=
0
;
i
<
aFeatureCount
;
i
+
+
)
{
features
|
=
ParseFeature
(
aFeatures
[
i
]
aIsStartup
)
;
}
return
features
;
}
static
RegisteredThread
*
FindCurrentThreadRegisteredThread
(
PSLockRef
aLock
)
{
int
id
=
profiler_current_thread_id
(
)
;
const
Vector
<
UniquePtr
<
RegisteredThread
>
>
&
registeredThreads
=
CorePS
:
:
RegisteredThreads
(
aLock
)
;
for
(
auto
&
registeredThread
:
registeredThreads
)
{
if
(
registeredThread
-
>
Info
(
)
-
>
ThreadId
(
)
=
=
id
)
{
return
registeredThread
.
get
(
)
;
}
}
return
nullptr
;
}
static
ProfilingStack
*
locked_register_thread
(
PSLockRef
aLock
const
char
*
aName
void
*
aStackTop
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
FindCurrentThreadRegisteredThread
(
aLock
)
)
;
VTUNE_REGISTER_THREAD
(
aName
)
;
if
(
!
TLSRegisteredThread
:
:
Init
(
aLock
)
)
{
return
nullptr
;
}
RefPtr
<
ThreadInfo
>
info
=
new
ThreadInfo
(
aName
profiler_current_thread_id
(
)
NS_IsMainThread
(
)
)
;
UniquePtr
<
RegisteredThread
>
registeredThread
=
MakeUnique
<
RegisteredThread
>
(
info
NS_GetCurrentThreadNoCreate
(
)
aStackTop
)
;
TLSRegisteredThread
:
:
SetRegisteredThreadAndAutoProfilerLabelProfilingStack
(
aLock
registeredThread
.
get
(
)
)
;
if
(
ActivePS
:
:
Exists
(
aLock
)
&
&
ActivePS
:
:
ShouldProfileThread
(
aLock
info
)
)
{
registeredThread
-
>
RacyRegisteredThread
(
)
.
SetIsBeingProfiled
(
true
)
;
nsCOMPtr
<
nsIEventTarget
>
eventTarget
=
registeredThread
-
>
GetEventTarget
(
)
;
ProfiledThreadData
*
profiledThreadData
=
ActivePS
:
:
AddLiveProfiledThread
(
aLock
registeredThread
.
get
(
)
MakeUnique
<
ProfiledThreadData
>
(
info
eventTarget
)
)
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
registeredThread
-
>
StartJSSampling
(
ActivePS
:
:
JSFlags
(
aLock
)
)
;
registeredThread
-
>
PollJSSampling
(
)
;
if
(
registeredThread
-
>
GetJSContext
(
)
)
{
profiledThreadData
-
>
NotifyReceivedJSContext
(
ActivePS
:
:
Buffer
(
aLock
)
.
BufferRangeEnd
(
)
)
;
}
}
}
ProfilingStack
*
profilingStack
=
&
registeredThread
-
>
RacyRegisteredThread
(
)
.
ProfilingStack
(
)
;
CorePS
:
:
AppendRegisteredThread
(
aLock
std
:
:
move
(
registeredThread
)
)
;
return
profilingStack
;
}
static
void
NotifyObservers
(
const
char
*
aTopic
nsISupports
*
aSubject
=
nullptr
)
{
if
(
!
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsISupports
>
subject
=
aSubject
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
NotifyObservers
"
[
=
]
{
NotifyObservers
(
aTopic
subject
)
;
}
)
)
;
return
;
}
if
(
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
)
{
os
-
>
NotifyObservers
(
aSubject
aTopic
nullptr
)
;
}
}
static
void
NotifyProfilerStarted
(
const
PowerOfTwo32
&
aCapacity
const
Maybe
<
double
>
&
aDuration
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
{
nsTArray
<
nsCString
>
filtersArray
;
for
(
size_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
filtersArray
.
AppendElement
(
aFilters
[
i
]
)
;
}
nsCOMPtr
<
nsIProfilerStartParams
>
params
=
new
nsProfilerStartParams
(
aCapacity
.
Value
(
)
aDuration
aInterval
aFeatures
std
:
:
move
(
filtersArray
)
)
;
ProfilerParent
:
:
ProfilerStarted
(
params
)
;
NotifyObservers
(
"
profiler
-
started
"
params
)
;
}
static
void
locked_profiler_start
(
PSLockRef
aLock
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
Maybe
<
double
>
&
aDuration
)
;
static
void
*
MozGlueLabelEnter
(
const
char
*
aLabel
const
char
*
aDynamicString
void
*
aSp
)
{
ProfilingStackOwner
*
profilingStackOwner
=
AutoProfilerLabel
:
:
sProfilingStackOwnerTLS
.
get
(
)
;
if
(
profilingStackOwner
)
{
profilingStackOwner
-
>
ProfilingStack
(
)
.
pushLabelFrame
(
aLabel
aDynamicString
aSp
JS
:
:
ProfilingCategoryPair
:
:
OTHER
)
;
}
return
profilingStackOwner
;
}
static
void
MozGlueLabelExit
(
void
*
aProfilingStackOwner
)
{
if
(
aProfilingStackOwner
)
{
reinterpret_cast
<
ProfilingStackOwner
*
>
(
aProfilingStackOwner
)
-
>
ProfilingStack
(
)
.
pop
(
)
;
}
}
static
Vector
<
const
char
*
>
SplitAtCommas
(
const
char
*
aString
UniquePtr
<
char
[
]
>
&
aStorage
)
{
size_t
len
=
strlen
(
aString
)
;
aStorage
=
MakeUnique
<
char
[
]
>
(
len
+
1
)
;
PodCopy
(
aStorage
.
get
(
)
aString
len
+
1
)
;
Vector
<
const
char
*
>
array
;
size_t
currentElementStart
=
0
;
for
(
size_t
i
=
0
;
i
<
=
len
;
i
+
+
)
{
if
(
aStorage
[
i
]
=
=
'
'
)
{
aStorage
[
i
]
=
'
\
0
'
;
}
if
(
aStorage
[
i
]
=
=
'
\
0
'
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
&
aStorage
[
currentElementStart
]
)
)
;
currentElementStart
=
i
+
1
;
}
}
return
array
;
}
void
profiler_init_threadmanager
(
)
{
LOG
(
"
profiler_init_threadmanager
"
)
;
PSAutoLock
lock
(
gPSMutex
)
;
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
!
registeredThread
-
>
GetEventTarget
(
)
)
{
registeredThread
-
>
ResetMainThread
(
NS_GetCurrentThreadNoCreate
(
)
)
;
}
}
void
profiler_init
(
void
*
aStackTop
)
{
LOG
(
"
profiler_init
"
)
;
VTUNE_INIT
(
)
;
MOZ_RELEASE_ASSERT
(
!
CorePS
:
:
Exists
(
)
)
;
if
(
getenv
(
"
MOZ_PROFILER_HELP
"
)
)
{
PrintUsageThenExit
(
1
)
;
}
SharedLibraryInfo
:
:
Initialize
(
)
;
uint32_t
features
=
DefaultFeatures
(
)
&
AvailableFeatures
(
)
;
UniquePtr
<
char
[
]
>
filterStorage
;
Vector
<
const
char
*
>
filters
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
"
GeckoMain
"
)
)
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
"
Compositor
"
)
)
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
"
DOM
Worker
"
)
)
;
PowerOfTwo32
capacity
=
PROFILER_DEFAULT_ENTRIES
;
Maybe
<
double
>
duration
=
Nothing
(
)
;
double
interval
=
PROFILER_DEFAULT_INTERVAL
;
{
PSAutoLock
lock
(
gPSMutex
)
;
CorePS
:
:
Create
(
lock
)
;
locked_register_thread
(
lock
kMainThreadName
aStackTop
)
;
PlatformInit
(
lock
)
;
#
ifdef
MOZ_TASK_TRACER
tasktracer
:
:
InitTaskTracer
(
)
;
#
endif
#
if
defined
(
GP_OS_android
)
if
(
jni
:
:
IsAvailable
(
)
)
{
GeckoJavaSampler
:
:
Init
(
)
;
}
#
endif
const
char
*
startupEnv
=
getenv
(
"
MOZ_PROFILER_STARTUP
"
)
;
if
(
!
startupEnv
|
|
startupEnv
[
0
]
=
=
'
\
0
'
|
|
(
(
startupEnv
[
0
]
=
=
'
0
'
|
|
startupEnv
[
0
]
=
=
'
N
'
|
|
startupEnv
[
0
]
=
=
'
n
'
)
&
&
startupEnv
[
1
]
=
=
'
\
0
'
)
)
{
return
;
}
LOG
(
"
-
MOZ_PROFILER_STARTUP
is
set
"
)
;
capacity
=
PROFILER_DEFAULT_STARTUP_ENTRIES
;
const
char
*
startupCapacity
=
getenv
(
"
MOZ_PROFILER_STARTUP_ENTRIES
"
)
;
if
(
startupCapacity
&
&
startupCapacity
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
long
capacityLong
=
strtol
(
startupCapacity
nullptr
10
)
;
if
(
errno
=
=
0
&
&
capacityLong
>
0
&
&
static_cast
<
uint64_t
>
(
capacityLong
)
<
=
static_cast
<
uint64_t
>
(
INT32_MAX
)
)
{
capacity
=
PowerOfTwo32
(
static_cast
<
uint32_t
>
(
capacityLong
)
)
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_ENTRIES
=
%
u
"
unsigned
(
capacity
.
Value
(
)
)
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_ENTRIES
not
a
valid
integer
:
%
s
"
startupCapacity
)
;
PrintUsageThenExit
(
1
)
;
}
}
const
char
*
startupDuration
=
getenv
(
"
MOZ_PROFILER_STARTUP_DURATION
"
)
;
if
(
startupDuration
&
&
startupDuration
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
double
durationVal
=
PR_strtod
(
startupDuration
nullptr
)
;
if
(
errno
=
=
0
&
&
durationVal
>
=
0
.
0
)
{
if
(
durationVal
>
0
.
0
)
{
duration
=
Some
(
durationVal
)
;
}
LOG
(
"
-
MOZ_PROFILER_STARTUP_DURATION
=
%
f
"
durationVal
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_DURATION
not
a
valid
float
:
%
s
"
startupDuration
)
;
PrintUsageThenExit
(
1
)
;
}
}
const
char
*
startupInterval
=
getenv
(
"
MOZ_PROFILER_STARTUP_INTERVAL
"
)
;
if
(
startupInterval
&
&
startupInterval
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
interval
=
PR_strtod
(
startupInterval
nullptr
)
;
if
(
errno
=
=
0
&
&
interval
>
0
.
0
&
&
interval
<
=
PROFILER_MAX_INTERVAL
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_INTERVAL
=
%
f
"
interval
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_INTERVAL
not
a
valid
float
:
%
s
"
startupInterval
)
;
PrintUsageThenExit
(
1
)
;
}
}
features
|
=
StartupExtraDefaultFeatures
(
)
&
AvailableFeatures
(
)
;
const
char
*
startupFeaturesBitfield
=
getenv
(
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
"
)
;
if
(
startupFeaturesBitfield
&
&
startupFeaturesBitfield
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
features
=
strtol
(
startupFeaturesBitfield
nullptr
10
)
;
if
(
errno
=
=
0
&
&
features
!
=
0
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
=
%
d
"
features
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
not
a
valid
integer
:
%
s
"
startupFeaturesBitfield
)
;
PrintUsageThenExit
(
1
)
;
}
}
else
{
const
char
*
startupFeatures
=
getenv
(
"
MOZ_PROFILER_STARTUP_FEATURES
"
)
;
if
(
startupFeatures
&
&
startupFeatures
[
0
]
!
=
'
\
0
'
)
{
UniquePtr
<
char
[
]
>
featureStringStorage
;
Vector
<
const
char
*
>
featureStringArray
=
SplitAtCommas
(
startupFeatures
featureStringStorage
)
;
features
=
ParseFeaturesFromStringArray
(
featureStringArray
.
begin
(
)
featureStringArray
.
length
(
)
true
)
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_FEATURES
=
%
d
"
features
)
;
}
}
const
char
*
startupFilters
=
getenv
(
"
MOZ_PROFILER_STARTUP_FILTERS
"
)
;
if
(
startupFilters
&
&
startupFilters
[
0
]
!
=
'
\
0
'
)
{
filters
=
SplitAtCommas
(
startupFilters
filterStorage
)
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_FILTERS
=
%
s
"
startupFilters
)
;
}
locked_profiler_start
(
lock
capacity
interval
features
filters
.
begin
(
)
filters
.
length
(
)
duration
)
;
}
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
mozilla
:
:
profiler
:
:
install_memory_hooks
(
)
;
#
endif
NotifyProfilerStarted
(
capacity
duration
interval
features
filters
.
begin
(
)
filters
.
length
(
)
)
;
}
static
void
locked_profiler_save_profile_to_file
(
PSLockRef
aLock
const
char
*
aFilename
bool
aIsShuttingDown
)
;
static
SamplerThread
*
locked_profiler_stop
(
PSLockRef
aLock
)
;
void
profiler_shutdown
(
)
{
LOG
(
"
profiler_shutdown
"
)
;
VTUNE_SHUTDOWN
(
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
const
char
*
filename
=
getenv
(
"
MOZ_PROFILER_SHUTDOWN
"
)
;
if
(
filename
)
{
locked_profiler_save_profile_to_file
(
lock
filename
true
)
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
CorePS
:
:
Destroy
(
lock
)
;
TLSRegisteredThread
:
:
ResetRegisteredThread
(
lock
)
;
TLSRegisteredThread
:
:
ResetAutoProfilerLabelProfilingStack
(
lock
)
;
#
ifdef
MOZ_TASK_TRACER
tasktracer
:
:
ShutdownTaskTracer
(
)
;
#
endif
}
if
(
samplerThread
)
{
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
}
static
bool
WriteProfileToJSONWriter
(
SpliceableChunkedJSONWriter
&
aWriter
double
aSinceTime
bool
aIsShuttingDown
ProfilerCodeAddressService
*
aService
)
{
LOG
(
"
WriteProfileToJSONWriter
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
aWriter
.
Start
(
)
;
{
if
(
!
profiler_stream_json_for_this_process
(
aWriter
aSinceTime
aIsShuttingDown
aService
)
)
{
return
false
;
}
aWriter
.
StartArrayProperty
(
"
processes
"
)
;
aWriter
.
EndArray
(
)
;
}
aWriter
.
End
(
)
;
return
true
;
}
void
profiler_set_process_name
(
const
nsACString
&
aProcessName
)
{
LOG
(
"
profiler_set_process_name
(
\
"
%
s
\
"
)
"
aProcessName
.
Data
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
CorePS
:
:
SetProcessName
(
lock
aProcessName
)
;
}
UniquePtr
<
char
[
]
>
profiler_get_profile
(
double
aSinceTime
bool
aIsShuttingDown
)
{
LOG
(
"
profiler_get_profile
"
)
;
UniquePtr
<
ProfilerCodeAddressService
>
service
=
profiler_code_address_service_for_presymbolication
(
)
;
SpliceableChunkedJSONWriter
b
;
if
(
!
WriteProfileToJSONWriter
(
b
aSinceTime
aIsShuttingDown
service
.
get
(
)
)
)
{
return
nullptr
;
}
return
b
.
WriteFunc
(
)
-
>
CopyData
(
)
;
}
void
profiler_get_profile_json_into_lazily_allocated_buffer
(
const
std
:
:
function
<
char
*
(
size_t
)
>
&
aAllocator
double
aSinceTime
bool
aIsShuttingDown
)
{
LOG
(
"
profiler_get_profile_json_into_lazily_allocated_buffer
"
)
;
UniquePtr
<
ProfilerCodeAddressService
>
service
=
profiler_code_address_service_for_presymbolication
(
)
;
SpliceableChunkedJSONWriter
b
;
if
(
!
WriteProfileToJSONWriter
(
b
aSinceTime
aIsShuttingDown
service
.
get
(
)
)
)
{
return
;
}
b
.
WriteFunc
(
)
-
>
CopyDataIntoLazilyAllocatedBuffer
(
aAllocator
)
;
}
void
profiler_get_start_params
(
int
*
aCapacity
Maybe
<
double
>
*
aDuration
double
*
aInterval
uint32_t
*
aFeatures
Vector
<
const
char
*
>
*
aFilters
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
NS_WARN_IF
(
!
aCapacity
)
|
|
NS_WARN_IF
(
!
aDuration
)
|
|
NS_WARN_IF
(
!
aInterval
)
|
|
NS_WARN_IF
(
!
aFeatures
)
|
|
NS_WARN_IF
(
!
aFilters
)
)
{
return
;
}
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
*
aCapacity
=
0
;
*
aDuration
=
Nothing
(
)
;
*
aInterval
=
0
;
*
aFeatures
=
0
;
aFilters
-
>
clear
(
)
;
return
;
}
*
aCapacity
=
ActivePS
:
:
Capacity
(
lock
)
.
Value
(
)
;
*
aDuration
=
ActivePS
:
:
Duration
(
lock
)
;
*
aInterval
=
ActivePS
:
:
Interval
(
lock
)
;
*
aFeatures
=
ActivePS
:
:
Features
(
lock
)
;
const
Vector
<
std
:
:
string
>
&
filters
=
ActivePS
:
:
Filters
(
lock
)
;
MOZ_ALWAYS_TRUE
(
aFilters
-
>
resize
(
filters
.
length
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
filters
.
length
(
)
;
+
+
i
)
{
(
*
aFilters
)
[
i
]
=
filters
[
i
]
.
c_str
(
)
;
}
}
namespace
mozilla
{
void
GetProfilerEnvVarsForChildProcess
(
std
:
:
function
<
void
(
const
char
*
key
const
char
*
value
)
>
&
&
aSetEnv
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
aSetEnv
(
"
MOZ_PROFILER_STARTUP
"
"
"
)
;
return
;
}
aSetEnv
(
"
MOZ_PROFILER_STARTUP
"
"
1
"
)
;
auto
capacityString
=
Smprintf
(
"
%
u
"
unsigned
(
ActivePS
:
:
Capacity
(
lock
)
.
Value
(
)
)
)
;
aSetEnv
(
"
MOZ_PROFILER_STARTUP_ENTRIES
"
capacityString
.
get
(
)
)
;
nsCString
intervalString
;
intervalString
.
AppendFloat
(
ActivePS
:
:
Interval
(
lock
)
)
;
aSetEnv
(
"
MOZ_PROFILER_STARTUP_INTERVAL
"
intervalString
.
get
(
)
)
;
auto
featuresString
=
Smprintf
(
"
%
d
"
ActivePS
:
:
Features
(
lock
)
)
;
aSetEnv
(
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
"
featuresString
.
get
(
)
)
;
std
:
:
string
filtersString
;
const
Vector
<
std
:
:
string
>
&
filters
=
ActivePS
:
:
Filters
(
lock
)
;
for
(
uint32_t
i
=
0
;
i
<
filters
.
length
(
)
;
+
+
i
)
{
filtersString
+
=
filters
[
i
]
;
if
(
i
!
=
filters
.
length
(
)
-
1
)
{
filtersString
+
=
"
"
;
}
}
aSetEnv
(
"
MOZ_PROFILER_STARTUP_FILTERS
"
filtersString
.
c_str
(
)
)
;
#
ifdef
MOZ_BASE_PROFILER
auto
copyEnv
=
[
&
]
(
const
char
*
aName
)
{
const
char
*
env
=
getenv
(
aName
)
;
if
(
!
env
)
{
return
;
}
aSetEnv
(
aName
env
)
;
}
;
copyEnv
(
"
MOZ_BASE_PROFILER_STARTUP
"
)
;
copyEnv
(
"
MOZ_BASE_PROFILER_STARTUP_ENTRIES
"
)
;
copyEnv
(
"
MOZ_BASE_PROFILER_STARTUP_DURATION
"
)
;
copyEnv
(
"
MOZ_BASE_PROFILER_STARTUP_INTERVAL
"
)
;
copyEnv
(
"
MOZ_BASE_PROFILER_STARTUP_FEATURES_BITFIELD
"
)
;
copyEnv
(
"
MOZ_BASE_PROFILER_STARTUP_FEATURES
"
)
;
copyEnv
(
"
MOZ_BASE_PROFILER_STARTUP_FILTERS
"
)
;
#
endif
}
}
void
profiler_received_exit_profile
(
const
nsCString
&
aExitProfile
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
ActivePS
:
:
AddExitProfile
(
lock
aExitProfile
)
;
}
Vector
<
nsCString
>
profiler_move_exit_profiles
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
Vector
<
nsCString
>
profiles
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
profiles
=
ActivePS
:
:
MoveExitProfiles
(
lock
)
;
}
return
profiles
;
}
static
void
locked_profiler_save_profile_to_file
(
PSLockRef
aLock
const
char
*
aFilename
bool
aIsShuttingDown
=
false
)
{
LOG
(
"
locked_profiler_save_profile_to_file
(
%
s
)
"
aFilename
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
std
:
:
ofstream
stream
;
stream
.
open
(
aFilename
)
;
if
(
stream
.
is_open
(
)
)
{
SpliceableJSONWriter
w
(
MakeUnique
<
OStreamJSONWriteFunc
>
(
stream
)
)
;
w
.
Start
(
)
;
{
locked_profiler_stream_json_for_this_process
(
aLock
w
0
aIsShuttingDown
nullptr
)
;
w
.
StartArrayProperty
(
"
processes
"
)
;
Vector
<
nsCString
>
exitProfiles
=
ActivePS
:
:
MoveExitProfiles
(
aLock
)
;
for
(
auto
&
exitProfile
:
exitProfiles
)
{
if
(
!
exitProfile
.
IsEmpty
(
)
)
{
w
.
Splice
(
exitProfile
.
get
(
)
)
;
}
}
w
.
EndArray
(
)
;
}
w
.
End
(
)
;
stream
.
close
(
)
;
}
}
void
profiler_save_profile_to_file
(
const
char
*
aFilename
)
{
LOG
(
"
profiler_save_profile_to_file
(
%
s
)
"
aFilename
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
locked_profiler_save_profile_to_file
(
lock
aFilename
)
;
}
uint32_t
profiler_get_available_features
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
return
AvailableFeatures
(
)
;
}
Maybe
<
ProfilerBufferInfo
>
profiler_get_buffer_info
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
Nothing
(
)
;
}
return
Some
(
ActivePS
:
:
Buffer
(
lock
)
.
GetProfilerBufferInfo
(
)
)
;
}
static
void
PollJSSamplingForCurrentThread
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
!
registeredThread
)
{
return
;
}
registeredThread
-
>
PollJSSampling
(
)
;
}
static
void
TriggerPollJSSamplingOnMainThread
(
)
{
nsCOMPtr
<
nsIThread
>
mainThread
;
nsresult
rv
=
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mainThread
)
{
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
"
TriggerPollJSSamplingOnMainThread
"
[
]
(
)
{
PollJSSamplingForCurrentThread
(
)
;
}
)
;
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
task
.
forget
(
)
)
;
}
}
static
void
locked_profiler_start
(
PSLockRef
aLock
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
Maybe
<
double
>
&
aDuration
)
{
if
(
LOG_TEST
)
{
LOG
(
"
locked_profiler_start
"
)
;
LOG
(
"
-
capacity
=
%
u
"
unsigned
(
aCapacity
.
Value
(
)
)
)
;
LOG
(
"
-
duration
=
%
.
2f
"
aDuration
?
*
aDuration
:
-
1
)
;
LOG
(
"
-
interval
=
%
.
2f
"
aInterval
)
;
#
define
LOG_FEATURE
(
n_
str_
Name_
desc_
)
\
if
(
ProfilerFeature
:
:
Has
#
#
Name_
(
aFeatures
)
)
{
\
LOG
(
"
-
feature
=
%
s
"
str_
)
;
\
}
PROFILER_FOR_EACH_FEATURE
(
LOG_FEATURE
)
#
undef
LOG_FEATURE
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
i
+
+
)
{
LOG
(
"
-
threads
=
%
s
"
aFilters
[
i
]
)
;
}
}
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
!
ActivePS
:
:
Exists
(
aLock
)
)
;
#
if
defined
(
GP_PLAT_amd64_windows
)
InitializeWin64ProfilerHooks
(
)
;
#
endif
PowerOfTwo32
capacity
=
(
aCapacity
.
Value
(
)
>
=
8192u
)
?
aCapacity
:
PROFILER_DEFAULT_ENTRIES
;
Maybe
<
double
>
duration
=
aDuration
;
if
(
aDuration
&
&
*
aDuration
<
=
0
)
{
duration
=
Nothing
(
)
;
}
double
interval
=
aInterval
>
0
?
aInterval
:
PROFILER_DEFAULT_INTERVAL
;
ActivePS
:
:
Create
(
aLock
capacity
interval
aFeatures
aFilters
aFilterCount
duration
)
;
MOZ_ASSERT
(
ActivePS
:
:
Exists
(
aLock
)
)
;
#
ifdef
MOZ_BASE_PROFILER
if
(
baseprofiler
:
:
profiler_is_active
(
)
)
{
UniquePtr
<
char
[
]
>
baseprofile
=
baseprofiler
:
:
profiler_get_profile
(
0
false
true
)
;
baseprofiler
:
:
profiler_stop
(
)
;
if
(
baseprofile
&
&
baseprofile
.
get
(
)
[
0
]
!
=
'
\
0
'
)
{
ActivePS
:
:
AddBaseProfileThreads
(
aLock
std
:
:
move
(
baseprofile
)
)
;
}
}
#
endif
Maybe
<
int
>
mainThreadId
;
int
tid
=
profiler_current_thread_id
(
)
;
const
Vector
<
UniquePtr
<
RegisteredThread
>
>
&
registeredThreads
=
CorePS
:
:
RegisteredThreads
(
aLock
)
;
for
(
auto
&
registeredThread
:
registeredThreads
)
{
RefPtr
<
ThreadInfo
>
info
=
registeredThread
-
>
Info
(
)
;
if
(
ActivePS
:
:
ShouldProfileThread
(
aLock
info
)
)
{
registeredThread
-
>
RacyRegisteredThread
(
)
.
SetIsBeingProfiled
(
true
)
;
nsCOMPtr
<
nsIEventTarget
>
eventTarget
=
registeredThread
-
>
GetEventTarget
(
)
;
ProfiledThreadData
*
profiledThreadData
=
ActivePS
:
:
AddLiveProfiledThread
(
aLock
registeredThread
.
get
(
)
MakeUnique
<
ProfiledThreadData
>
(
info
eventTarget
)
)
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
registeredThread
-
>
StartJSSampling
(
ActivePS
:
:
JSFlags
(
aLock
)
)
;
if
(
info
-
>
ThreadId
(
)
=
=
tid
)
{
registeredThread
-
>
PollJSSampling
(
)
;
}
else
if
(
info
-
>
IsMainThread
(
)
)
{
TriggerPollJSSamplingOnMainThread
(
)
;
}
}
if
(
info
-
>
IsMainThread
(
)
)
{
mainThreadId
=
Some
(
info
-
>
ThreadId
(
)
)
;
}
registeredThread
-
>
RacyRegisteredThread
(
)
.
ReinitializeOnResume
(
)
;
if
(
registeredThread
-
>
GetJSContext
(
)
)
{
profiledThreadData
-
>
NotifyReceivedJSContext
(
0
)
;
}
}
}
RegisterProfilerLabelEnterExit
(
MozGlueLabelEnter
MozGlueLabelExit
)
;
#
ifdef
MOZ_TASK_TRACER
if
(
ActivePS
:
:
FeatureTaskTracer
(
aLock
)
)
{
tasktracer
:
:
StartLogging
(
)
;
}
#
endif
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
int
javaInterval
=
interval
;
if
(
javaInterval
<
10
)
{
javaInterval
=
10
;
}
java
:
:
GeckoJavaSampler
:
:
Start
(
javaInterval
1000
)
;
}
#
endif
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
ActivePS
:
:
FeatureNativeAllocations
(
aLock
)
)
{
if
(
mainThreadId
.
isSome
(
)
)
{
mozilla
:
:
profiler
:
:
enable_native_allocations
(
mainThreadId
.
value
(
)
)
;
}
else
{
NS_WARNING
(
"
The
nativeallocations
feature
is
turned
on
but
the
main
thread
is
"
"
not
being
profiled
.
The
allocations
are
only
stored
on
the
main
"
"
thread
.
"
)
;
}
}
#
endif
RacyFeatures
:
:
SetActive
(
ActivePS
:
:
Features
(
aLock
)
)
;
}
void
profiler_start
(
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
Maybe
<
double
>
&
aDuration
)
{
LOG
(
"
profiler_start
"
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
profiler_init
(
nullptr
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
locked_profiler_start
(
lock
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aDuration
)
;
}
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
mozilla
:
:
profiler
:
:
install_memory_hooks
(
)
;
#
endif
if
(
samplerThread
)
{
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
NotifyProfilerStarted
(
aCapacity
aDuration
aInterval
aFeatures
aFilters
aFilterCount
)
;
}
void
profiler_ensure_started
(
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
Maybe
<
double
>
&
aDuration
)
{
LOG
(
"
profiler_ensure_started
"
)
;
bool
startedProfiler
=
false
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
profiler_init
(
nullptr
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
if
(
!
ActivePS
:
:
Equals
(
lock
aCapacity
aDuration
aInterval
aFeatures
aFilters
aFilterCount
)
)
{
samplerThread
=
locked_profiler_stop
(
lock
)
;
locked_profiler_start
(
lock
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aDuration
)
;
startedProfiler
=
true
;
}
}
else
{
locked_profiler_start
(
lock
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aDuration
)
;
startedProfiler
=
true
;
}
}
if
(
samplerThread
)
{
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
if
(
startedProfiler
)
{
NotifyProfilerStarted
(
aCapacity
aDuration
aInterval
aFeatures
aFilters
aFilterCount
)
;
}
}
static
MOZ_MUST_USE
SamplerThread
*
locked_profiler_stop
(
PSLockRef
aLock
)
{
LOG
(
"
locked_profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
RacyFeatures
:
:
SetInactive
(
)
;
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
java
:
:
GeckoJavaSampler
:
:
Stop
(
)
;
}
#
endif
#
ifdef
MOZ_TASK_TRACER
if
(
ActivePS
:
:
FeatureTaskTracer
(
aLock
)
)
{
tasktracer
:
:
StopLogging
(
)
;
}
#
endif
RegisterProfilerLabelEnterExit
(
nullptr
nullptr
)
;
int
tid
=
profiler_current_thread_id
(
)
;
const
Vector
<
LiveProfiledThreadData
>
&
liveProfiledThreads
=
ActivePS
:
:
LiveProfiledThreads
(
aLock
)
;
for
(
auto
&
thread
:
liveProfiledThreads
)
{
RegisteredThread
*
registeredThread
=
thread
.
mRegisteredThread
;
registeredThread
-
>
RacyRegisteredThread
(
)
.
SetIsBeingProfiled
(
false
)
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
registeredThread
-
>
StopJSSampling
(
)
;
RefPtr
<
ThreadInfo
>
info
=
registeredThread
-
>
Info
(
)
;
if
(
info
-
>
ThreadId
(
)
=
=
tid
)
{
registeredThread
-
>
PollJSSampling
(
)
;
}
else
if
(
info
-
>
IsMainThread
(
)
)
{
TriggerPollJSSamplingOnMainThread
(
)
;
}
}
}
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
ActivePS
:
:
FeatureNativeAllocations
(
aLock
)
)
{
mozilla
:
:
profiler
:
:
disable_native_allocations
(
)
;
}
#
endif
SamplerThread
*
samplerThread
=
ActivePS
:
:
Destroy
(
aLock
)
;
samplerThread
-
>
Stop
(
aLock
)
;
return
samplerThread
;
}
void
profiler_stop
(
)
{
LOG
(
"
profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
mozilla
:
:
profiler
:
:
remove_memory_hooks
(
)
;
#
endif
SamplerThread
*
samplerThread
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
bool
profiler_is_paused
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
return
ActivePS
:
:
IsPaused
(
lock
)
;
}
bool
profiler_callback_after_sampling
(
PostSamplingCallback
&
&
aCallback
)
{
LOG
(
"
profiler_callback_after_sampling
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
return
ActivePS
:
:
AppendPostSamplingCallback
(
lock
std
:
:
move
(
aCallback
)
)
;
}
void
profiler_pause
(
)
{
LOG
(
"
profiler_pause
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
RacyFeatures
:
:
SetPaused
(
)
;
ActivePS
:
:
SetIsPaused
(
lock
true
)
;
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
Pause
(
profiler_time
(
)
)
)
;
}
ProfilerParent
:
:
ProfilerPaused
(
)
;
NotifyObservers
(
"
profiler
-
paused
"
)
;
}
void
profiler_resume
(
)
{
LOG
(
"
profiler_resume
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
Resume
(
profiler_time
(
)
)
)
;
ActivePS
:
:
SetIsPaused
(
lock
false
)
;
RacyFeatures
:
:
SetUnpaused
(
)
;
}
ProfilerParent
:
:
ProfilerResumed
(
)
;
NotifyObservers
(
"
profiler
-
resumed
"
)
;
}
bool
profiler_feature_active
(
uint32_t
aFeature
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
return
RacyFeatures
:
:
IsActiveWithFeature
(
aFeature
)
;
}
void
profiler_write_active_configuration
(
JSONWriter
&
aWriter
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
ActivePS
:
:
WriteActiveConfiguration
(
lock
aWriter
)
;
}
void
profiler_add_sampled_counter
(
BaseProfilerCount
*
aCounter
)
{
DEBUG_LOG
(
"
profiler_add_sampled_counter
(
%
s
)
"
aCounter
-
>
mLabel
)
;
PSAutoLock
lock
(
gPSMutex
)
;
CorePS
:
:
AppendCounter
(
lock
aCounter
)
;
}
void
profiler_remove_sampled_counter
(
BaseProfilerCount
*
aCounter
)
{
DEBUG_LOG
(
"
profiler_remove_sampled_counter
(
%
s
)
"
aCounter
-
>
mLabel
)
;
PSAutoLock
lock
(
gPSMutex
)
;
CorePS
:
:
RemoveCounter
(
lock
aCounter
)
;
}
ProfilingStack
*
profiler_register_thread
(
const
char
*
aName
void
*
aGuessStackTop
)
{
DEBUG_LOG
(
"
profiler_register_thread
(
%
s
)
"
aName
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
(
void
)
NS_GetCurrentThread
(
)
;
NS_SetCurrentThreadName
(
aName
)
;
PSAutoLock
lock
(
gPSMutex
)
;
void
*
stackTop
=
GetStackTop
(
aGuessStackTop
)
;
return
locked_register_thread
(
lock
aName
stackTop
)
;
}
void
profiler_unregister_thread
(
)
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
TLSRegisteredThread
:
:
ResetAutoProfilerLabelProfilingStack
(
lock
)
;
return
;
}
RegisteredThread
*
registeredThread
=
FindCurrentThreadRegisteredThread
(
lock
)
;
MOZ_RELEASE_ASSERT
(
registeredThread
=
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
)
;
if
(
registeredThread
)
{
RefPtr
<
ThreadInfo
>
info
=
registeredThread
-
>
Info
(
)
;
DEBUG_LOG
(
"
profiler_unregister_thread
:
%
s
"
info
-
>
Name
(
)
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
UnregisterThread
(
lock
registeredThread
)
;
}
TLSRegisteredThread
:
:
ResetRegisteredThread
(
lock
)
;
TLSRegisteredThread
:
:
ResetAutoProfilerLabelProfilingStack
(
lock
)
;
CorePS
:
:
RemoveRegisteredThread
(
lock
registeredThread
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
!
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
)
;
}
}
void
profiler_register_page
(
uint64_t
aBrowsingContextID
uint64_t
aInnerWindowID
const
nsCString
&
aUrl
uint64_t
aEmbedderInnerWindowID
)
{
DEBUG_LOG
(
"
profiler_register_page
(
%
"
PRIu64
"
%
"
PRIu64
"
%
s
%
"
PRIu64
"
)
"
aBrowsingContextID
aInnerWindowID
aUrl
.
get
(
)
aEmbedderInnerWindowID
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
RefPtr
<
PageInformation
>
pageInfo
=
new
PageInformation
(
aBrowsingContextID
aInnerWindowID
aUrl
aEmbedderInnerWindowID
)
;
CorePS
:
:
AppendRegisteredPage
(
lock
std
:
:
move
(
pageInfo
)
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
DiscardExpiredPages
(
lock
)
;
}
}
void
profiler_unregister_page
(
uint64_t
aRegisteredInnerWindowID
)
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
UnregisterPage
(
lock
aRegisteredInnerWindowID
)
;
}
else
{
CorePS
:
:
RemoveRegisteredPage
(
lock
aRegisteredInnerWindowID
)
;
}
}
void
profiler_clear_all_pages
(
)
{
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
;
}
CorePS
:
:
ClearRegisteredPages
(
lock
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
ClearUnregisteredPages
(
lock
)
;
}
}
ProfilerParent
:
:
ClearAllPages
(
)
;
}
Maybe
<
uint64_t
>
profiler_get_inner_window_id_from_docshell
(
nsIDocShell
*
aDocshell
)
{
Maybe
<
uint64_t
>
innerWindowID
=
Nothing
(
)
;
if
(
aDocshell
)
{
auto
outerWindow
=
aDocshell
-
>
GetWindow
(
)
;
if
(
outerWindow
)
{
auto
innerWindow
=
outerWindow
-
>
GetCurrentInnerWindow
(
)
;
if
(
innerWindow
)
{
innerWindowID
=
Some
(
innerWindow
-
>
WindowID
(
)
)
;
}
}
}
return
innerWindowID
;
}
void
profiler_thread_sleep
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
RacyRegisteredThread
*
racyRegisteredThread
=
TLSRegisteredThread
:
:
RacyRegisteredThread
(
)
;
if
(
!
racyRegisteredThread
)
{
return
;
}
racyRegisteredThread
-
>
SetSleeping
(
)
;
}
void
profiler_thread_wake
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
RacyRegisteredThread
*
racyRegisteredThread
=
TLSRegisteredThread
:
:
RacyRegisteredThread
(
)
;
if
(
!
racyRegisteredThread
)
{
return
;
}
racyRegisteredThread
-
>
SetAwake
(
)
;
}
bool
mozilla
:
:
profiler
:
:
detail
:
:
IsThreadBeingProfiled
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
const
RacyRegisteredThread
*
racyRegisteredThread
=
TLSRegisteredThread
:
:
RacyRegisteredThread
(
)
;
return
racyRegisteredThread
&
&
racyRegisteredThread
-
>
IsBeingProfiled
(
)
;
}
bool
profiler_thread_is_sleeping
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
RacyRegisteredThread
*
racyRegisteredThread
=
TLSRegisteredThread
:
:
RacyRegisteredThread
(
)
;
if
(
!
racyRegisteredThread
)
{
return
false
;
}
return
racyRegisteredThread
-
>
IsSleeping
(
)
;
}
void
profiler_js_interrupt_callback
(
)
{
PollJSSamplingForCurrentThread
(
)
;
}
double
profiler_time
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
TimeDuration
delta
=
TimeStamp
:
:
NowUnfuzzed
(
)
-
CorePS
:
:
ProcessStartTime
(
)
;
return
delta
.
ToMilliseconds
(
)
;
}
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
!
profiler_is_active
(
)
)
{
return
nullptr
;
}
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
|
|
ActivePS
:
:
FeaturePrivacy
(
lock
)
)
{
return
nullptr
;
}
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
!
registeredThread
)
{
return
nullptr
;
}
int
tid
=
profiler_current_thread_id
(
)
;
TimeStamp
now
=
TimeStamp
:
:
NowUnfuzzed
(
)
;
Registers
regs
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
regs
.
SyncPopulate
(
)
;
#
else
regs
.
Clear
(
)
;
#
endif
auto
bufferManager
=
MakeUnique
<
BlocksRingBuffer
>
(
BlocksRingBuffer
:
:
ThreadSafety
:
:
WithoutMutex
)
;
auto
buffer
=
MakeUnique
<
ProfileBuffer
>
(
*
bufferManager
MakePowerOfTwo32
<
65536
>
(
)
)
;
DoSyncSample
(
lock
*
registeredThread
now
regs
*
buffer
.
get
(
)
)
;
return
UniqueProfilerBacktrace
(
new
ProfilerBacktrace
(
"
SyncProfile
"
tid
std
:
:
move
(
bufferManager
)
std
:
:
move
(
buffer
)
)
)
;
}
void
ProfilerBacktraceDestructor
:
:
operator
(
)
(
ProfilerBacktrace
*
aBacktrace
)
{
delete
aBacktrace
;
}
static
void
racy_profiler_add_marker
(
const
char
*
aMarkerName
JS
:
:
ProfilingCategoryPair
aCategoryPair
const
ProfilerMarkerPayload
*
aPayload
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
!
profiler_can_accept_markers
(
)
)
{
return
;
}
RacyRegisteredThread
*
racyRegisteredThread
=
TLSRegisteredThread
:
:
RacyRegisteredThread
(
)
;
if
(
!
racyRegisteredThread
|
|
!
racyRegisteredThread
-
>
IsBeingProfiled
(
)
)
{
return
;
}
TimeStamp
origin
=
(
aPayload
&
&
!
aPayload
-
>
GetStartTime
(
)
.
IsNull
(
)
)
?
aPayload
-
>
GetStartTime
(
)
:
TimeStamp
:
:
NowUnfuzzed
(
)
;
TimeDuration
delta
=
origin
-
CorePS
:
:
ProcessStartTime
(
)
;
CorePS
:
:
CoreBlocksRingBuffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
MarkerData
racyRegisteredThread
-
>
ThreadId
(
)
WrapBlocksRingBufferUnownedCString
(
aMarkerName
)
static_cast
<
uint32_t
>
(
aCategoryPair
)
aPayload
delta
.
ToMilliseconds
(
)
)
;
}
void
profiler_add_marker
(
const
char
*
aMarkerName
JS
:
:
ProfilingCategoryPair
aCategoryPair
const
ProfilerMarkerPayload
&
aPayload
)
{
racy_profiler_add_marker
(
aMarkerName
aCategoryPair
&
aPayload
)
;
}
void
profiler_add_marker
(
const
char
*
aMarkerName
JS
:
:
ProfilingCategoryPair
aCategoryPair
)
{
racy_profiler_add_marker
(
aMarkerName
aCategoryPair
nullptr
)
;
}
void
profiler_add_js_marker
(
const
char
*
aMarkerName
)
{
AUTO_PROFILER_STATS
(
add_marker
)
;
profiler_add_marker
(
aMarkerName
JS
:
:
ProfilingCategoryPair
:
:
JS
)
;
}
void
profiler_add_js_allocation_marker
(
JS
:
:
RecordAllocationInfo
&
&
info
)
{
if
(
!
profiler_can_accept_markers
(
)
)
{
return
;
}
AUTO_PROFILER_STATS
(
add_marker_with_JsAllocationMarkerPayload
)
;
profiler_add_marker
(
"
JS
allocation
"
JS
:
:
ProfilingCategoryPair
:
:
JS
JsAllocationMarkerPayload
(
TimeStamp
:
:
Now
(
)
std
:
:
move
(
info
)
profiler_get_backtrace
(
)
)
)
;
}
bool
profiler_is_locked_on_current_thread
(
)
{
return
gPSMutex
.
IsLockedOnCurrentThread
(
)
;
}
bool
profiler_add_native_allocation_marker
(
int
aMainThreadId
int64_t
aSize
uintptr_t
aMemoryAddress
)
{
if
(
!
profiler_can_accept_markers
(
)
)
{
return
false
;
}
AUTO_PROFILER_STATS
(
add_marker_with_NativeAllocationMarkerPayload
)
;
profiler_add_marker_for_thread
(
aMainThreadId
JS
:
:
ProfilingCategoryPair
:
:
OTHER
"
Native
allocation
"
MakeUnique
<
NativeAllocationMarkerPayload
>
(
TimeStamp
:
:
Now
(
)
aSize
aMemoryAddress
profiler_current_thread_id
(
)
profiler_get_backtrace
(
)
)
)
;
return
true
;
}
void
profiler_add_network_marker
(
nsIURI
*
aURI
int32_t
aPriority
uint64_t
aChannelId
NetworkLoadType
aType
mozilla
:
:
TimeStamp
aStart
mozilla
:
:
TimeStamp
aEnd
int64_t
aCount
mozilla
:
:
net
:
:
CacheDisposition
aCacheDisposition
const
mozilla
:
:
net
:
:
TimingStruct
*
aTimings
nsIURI
*
aRedirectURI
UniqueProfilerBacktrace
aSource
)
{
if
(
!
profiler_can_accept_markers
(
)
)
{
return
;
}
nsAutoCString
spec
;
nsAutoCString
redirect_spec
;
if
(
aURI
)
{
aURI
-
>
GetAsciiSpec
(
spec
)
;
}
if
(
aRedirectURI
)
{
aRedirectURI
-
>
GetAsciiSpec
(
redirect_spec
)
;
}
uint32_t
id
=
static_cast
<
uint32_t
>
(
aChannelId
&
0xFFFFFFFF
)
;
char
name
[
2048
]
;
SprintfLiteral
(
name
"
Load
%
d
:
%
s
"
id
PromiseFlatCString
(
spec
)
.
get
(
)
)
;
AUTO_PROFILER_STATS
(
add_marker_with_NetworkMarkerPayload
)
;
profiler_add_marker
(
name
JS
:
:
ProfilingCategoryPair
:
:
NETWORK
NetworkMarkerPayload
(
static_cast
<
int64_t
>
(
aChannelId
)
PromiseFlatCString
(
spec
)
.
get
(
)
aType
aStart
aEnd
aPriority
aCount
aCacheDisposition
aTimings
PromiseFlatCString
(
redirect_spec
)
.
get
(
)
std
:
:
move
(
aSource
)
)
)
;
}
void
profiler_add_marker_for_thread
(
int
aThreadId
JS
:
:
ProfilingCategoryPair
aCategoryPair
const
char
*
aMarkerName
UniquePtr
<
ProfilerMarkerPayload
>
aPayload
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
!
profiler_can_accept_markers
(
)
)
{
return
;
}
#
ifdef
DEBUG
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
bool
realThread
=
false
;
const
Vector
<
UniquePtr
<
RegisteredThread
>
>
&
registeredThreads
=
CorePS
:
:
RegisteredThreads
(
lock
)
;
for
(
auto
&
thread
:
registeredThreads
)
{
RefPtr
<
ThreadInfo
>
info
=
thread
-
>
Info
(
)
;
if
(
info
-
>
ThreadId
(
)
=
=
aThreadId
)
{
realThread
=
true
;
break
;
}
}
MOZ_ASSERT
(
realThread
"
Invalid
thread
id
"
)
;
}
#
endif
TimeStamp
origin
=
(
aPayload
&
&
!
aPayload
-
>
GetStartTime
(
)
.
IsNull
(
)
)
?
aPayload
-
>
GetStartTime
(
)
:
TimeStamp
:
:
NowUnfuzzed
(
)
;
TimeDuration
delta
=
origin
-
CorePS
:
:
ProcessStartTime
(
)
;
CorePS
:
:
CoreBlocksRingBuffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
MarkerData
aThreadId
WrapBlocksRingBufferUnownedCString
(
aMarkerName
)
static_cast
<
uint32_t
>
(
aCategoryPair
)
aPayload
delta
.
ToMilliseconds
(
)
)
;
}
void
profiler_tracing
(
const
char
*
aCategoryString
const
char
*
aMarkerName
JS
:
:
ProfilingCategoryPair
aCategoryPair
TracingKind
aKind
const
Maybe
<
uint64_t
>
&
aInnerWindowID
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
VTUNE_TRACING
(
aMarkerName
aKind
)
;
if
(
!
profiler_can_accept_markers
(
)
)
{
return
;
}
AUTO_PROFILER_STATS
(
add_marker_with_TracingMarkerPayload
)
;
profiler_add_marker
(
aMarkerName
aCategoryPair
TracingMarkerPayload
(
aCategoryString
aKind
aInnerWindowID
)
)
;
}
void
profiler_tracing
(
const
char
*
aCategoryString
const
char
*
aMarkerName
JS
:
:
ProfilingCategoryPair
aCategoryPair
TracingKind
aKind
UniqueProfilerBacktrace
aCause
const
Maybe
<
uint64_t
>
&
aInnerWindowID
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
VTUNE_TRACING
(
aMarkerName
aKind
)
;
if
(
!
profiler_can_accept_markers
(
)
)
{
return
;
}
profiler_add_marker
(
aMarkerName
aCategoryPair
TracingMarkerPayload
(
aCategoryString
aKind
aInnerWindowID
std
:
:
move
(
aCause
)
)
)
;
}
void
profiler_add_text_marker
(
const
char
*
aMarkerName
const
nsACString
&
aText
JS
:
:
ProfilingCategoryPair
aCategoryPair
const
mozilla
:
:
TimeStamp
&
aStartTime
const
mozilla
:
:
TimeStamp
&
aEndTime
const
mozilla
:
:
Maybe
<
uint64_t
>
&
aInnerWindowID
UniqueProfilerBacktrace
aCause
)
{
AUTO_PROFILER_STATS
(
add_marker_with_TextMarkerPayload
)
;
profiler_add_marker
(
aMarkerName
aCategoryPair
TextMarkerPayload
(
aText
aStartTime
aEndTime
aInnerWindowID
std
:
:
move
(
aCause
)
)
)
;
}
void
profiler_set_js_context
(
JSContext
*
aCx
)
{
MOZ_ASSERT
(
aCx
)
;
PSAutoLock
lock
(
gPSMutex
)
;
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
!
registeredThread
)
{
return
;
}
registeredThread
-
>
SetJSContext
(
aCx
)
;
registeredThread
-
>
PollJSSampling
(
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ProfiledThreadData
*
profiledThreadData
=
ActivePS
:
:
GetProfiledThreadData
(
lock
registeredThread
)
;
if
(
profiledThreadData
)
{
profiledThreadData
-
>
NotifyReceivedJSContext
(
ActivePS
:
:
Buffer
(
lock
)
.
BufferRangeEnd
(
)
)
;
}
}
}
void
profiler_clear_js_context
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
!
registeredThread
)
{
return
;
}
JSContext
*
cx
=
registeredThread
-
>
GetJSContext
(
)
;
if
(
!
cx
)
{
return
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
&
&
ActivePS
:
:
FeatureJS
(
lock
)
)
{
ProfiledThreadData
*
profiledThreadData
=
ActivePS
:
:
GetProfiledThreadData
(
lock
registeredThread
)
;
if
(
profiledThreadData
)
{
profiledThreadData
-
>
NotifyAboutToLoseJSContext
(
cx
CorePS
:
:
ProcessStartTime
(
)
ActivePS
:
:
Buffer
(
lock
)
)
;
registeredThread
-
>
StopJSSampling
(
)
;
registeredThread
-
>
PollJSSampling
(
)
;
registeredThread
-
>
ClearJSContext
(
)
;
registeredThread
-
>
StartJSSampling
(
ActivePS
:
:
JSFlags
(
lock
)
)
;
return
;
}
}
registeredThread
-
>
ClearJSContext
(
)
;
}
void
profiler_suspend_and_sample_thread
(
int
aThreadId
uint32_t
aFeatures
ProfilerStackCollector
&
aCollector
bool
aSampleNative
)
{
PSAutoLock
lock
(
gPSMutex
)
;
const
Vector
<
UniquePtr
<
RegisteredThread
>
>
&
registeredThreads
=
CorePS
:
:
RegisteredThreads
(
lock
)
;
for
(
auto
&
thread
:
registeredThreads
)
{
RefPtr
<
ThreadInfo
>
info
=
thread
-
>
Info
(
)
;
RegisteredThread
&
registeredThread
=
*
thread
.
get
(
)
;
if
(
info
-
>
ThreadId
(
)
=
=
aThreadId
)
{
if
(
info
-
>
IsMainThread
(
)
)
{
aCollector
.
SetIsMainThread
(
)
;
}
NativeStack
nativeStack
;
Sampler
sampler
(
lock
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
sampler
.
SuspendAndSampleAndResumeThread
(
lock
registeredThread
now
[
&
]
(
const
Registers
&
aRegs
const
TimeStamp
&
aNow
)
{
bool
isSynchronous
=
false
;
#
if
defined
(
HAVE_FASTINIT_NATIVE_UNWIND
)
if
(
aSampleNative
)
{
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
DoFramePointerBacktrace
(
lock
registeredThread
aRegs
nativeStack
)
;
#
elif
defined
(
USE_MOZ_STACK_WALK
)
DoMozStackWalkBacktrace
(
lock
registeredThread
aRegs
nativeStack
)
;
#
else
#
error
"
Invalid
configuration
"
#
endif
MergeStacks
(
aFeatures
isSynchronous
registeredThread
aRegs
nativeStack
aCollector
)
;
}
else
#
endif
{
MergeStacks
(
aFeatures
isSynchronous
registeredThread
aRegs
nativeStack
aCollector
)
;
if
(
ProfilerFeature
:
:
HasLeaf
(
aFeatures
)
)
{
aCollector
.
CollectNativeLeafAddr
(
(
void
*
)
aRegs
.
mPC
)
;
}
}
}
)
;
sampler
.
Disable
(
lock
)
;
break
;
}
}
}
