#
include
"
platform
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
GeckoProfilerReporter
.
h
"
#
include
"
PageInformation
.
h
"
#
include
"
PowerCounters
.
h
"
#
include
"
ProfileBuffer
.
h
"
#
include
"
ProfiledThreadData
.
h
"
#
include
"
ProfilerBacktrace
.
h
"
#
include
"
ProfilerChild
.
h
"
#
include
"
ProfilerCodeAddressService
.
h
"
#
include
"
ProfilerControl
.
h
"
#
include
"
ProfilerCPUFreq
.
h
"
#
include
"
ProfilerIOInterposeObserver
.
h
"
#
include
"
ProfilerParent
.
h
"
#
include
"
ProfilerNativeStack
.
h
"
#
include
"
ProfilerStackWalk
.
h
"
#
include
"
ProfilerRustBindings
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Perfetto
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
shared
-
libraries
.
h
"
#
include
"
VTuneProfiler
.
h
"
#
include
"
ETWTools
.
h
"
#
include
"
js
/
ProfilingFrameIterator
.
h
"
#
include
"
memory_hooks
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
AutoProfilerLabel
.
h
"
#
include
"
mozilla
/
BaseAndGeckoProfilerDetail
.
h
"
#
include
"
mozilla
/
ExtensionPolicyService
.
h
"
#
include
"
mozilla
/
extensions
/
WebExtensionPolicy
.
h
"
#
include
"
mozilla
/
glean
/
GleanMetrics
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Printf
.
h
"
#
include
"
mozilla
/
ProcInfo
.
h
"
#
include
"
mozilla
/
ProfilerBufferSize
.
h
"
#
include
"
mozilla
/
ProfileBufferChunkManagerSingle
.
h
"
#
include
"
mozilla
/
ProfileBufferChunkManagerWithLocalLimit
.
h
"
#
include
"
mozilla
/
ProfileChunkedBuffer
.
h
"
#
include
"
mozilla
/
ProfilerBandwidthCounter
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
include
"
mozilla
/
Try
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
NativeNt
.
h
"
#
include
"
mozilla
/
StackWalkThread
.
h
"
#
include
"
mozilla
/
WindowsStackWalkInitialization
.
h
"
#
endif
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
BaseProfiler
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIHttpProtocolHandler
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPropertyBag2
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsMemoryReporterManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsProfilerStartParams
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
nsSystemInfo
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
Tracing
.
h
"
#
include
"
prdtoa
.
h
"
#
include
"
prtime
.
h
"
#
include
<
algorithm
>
#
include
<
errno
.
h
>
#
include
<
fstream
>
#
include
<
ostream
>
#
include
<
set
>
#
include
<
sstream
>
#
include
<
string_view
>
#
include
<
type_traits
>
#
ifndef
MOZ_CODE_COVERAGE
#
ifdef
XP_WIN
#
elif
defined
(
GP_OS_darwin
)
|
|
defined
(
GP_OS_linux
)
|
|
\
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
#
define
GECKO_PROFILER_ASYNC_POSIX_SIGNAL_CONTROL
1
#
else
#
endif
#
endif
#
if
defined
(
GECKO_PROFILER_ASYNC_POSIX_SIGNAL_CONTROL
)
#
include
<
signal
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
unistd
.
h
>
#
include
<
errno
.
h
>
#
include
<
pthread
.
h
>
#
endif
#
if
defined
(
GP_OS_android
)
#
include
"
JavaExceptions
.
h
"
#
include
"
mozilla
/
java
/
GeckoJavaSamplerNatives
.
h
"
#
include
"
mozilla
/
jni
/
Refs
.
h
"
#
endif
#
if
defined
(
XP_MACOSX
)
#
include
"
nsCocoaFeatures
.
h
"
#
endif
#
if
defined
(
GP_PLAT_amd64_darwin
)
#
include
<
cpuid
.
h
>
#
endif
#
if
defined
(
GP_OS_windows
)
#
include
<
processthreadsapi
.
h
>
WINBASEAPI
BOOL
WINAPI
GetThreadInformation
(
_In_
HANDLE
hThread
_In_
THREAD_INFORMATION_CLASS
ThreadInformationClass
_Out_writes_bytes_
(
ThreadInformationSize
)
LPVOID
ThreadInformation
_In_
DWORD
ThreadInformationSize
)
;
#
endif
#
if
defined
(
GP_PLAT_x86_windows
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
if
defined
(
GP_PLAT_amd64_windows
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_MOZ_STACK_WALK
#
endif
#
if
defined
(
GP_PLAT_arm64_windows
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_MOZ_STACK_WALK
#
endif
#
if
defined
(
GP_OS_darwin
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
if
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_EHABI_STACKWALK
#
include
"
EHABIStackWalk
.
h
"
#
endif
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_x86_linux
)
|
|
\
defined
(
GP_PLAT_amd64_android
)
|
|
defined
(
GP_PLAT_x86_android
)
|
|
\
defined
(
GP_PLAT_mips64_linux
)
|
|
defined
(
GP_PLAT_arm64_linux
)
|
|
\
defined
(
GP_PLAT_arm64_android
)
|
|
defined
(
GP_PLAT_amd64_freebsd
)
|
|
\
defined
(
GP_PLAT_arm64_freebsd
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_LUL_STACKWALK
#
include
"
lul
/
LulMain
.
h
"
#
include
"
lul
/
platform
-
linux
-
lul
.
h
"
#
if
defined
(
MOZ_PROFILING
)
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
endif
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
|
|
defined
(
USE_MOZ_STACK_WALK
)
#
define
HAVE_FASTINIT_NATIVE_UNWIND
#
endif
#
ifdef
MOZ_VALGRIND
#
include
<
valgrind
/
memcheck
.
h
>
#
else
#
define
VALGRIND_MAKE_MEM_DEFINED
(
_addr
_len
)
(
(
void
)
0
)
#
endif
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
#
include
<
ucontext
.
h
>
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
literals
:
:
ProportionValue_literals
;
using
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
;
using
ThreadRegistration
=
mozilla
:
:
profiler
:
:
ThreadRegistration
;
using
ThreadRegistrationInfo
=
mozilla
:
:
profiler
:
:
ThreadRegistrationInfo
;
using
ThreadRegistry
=
mozilla
:
:
profiler
:
:
ThreadRegistry
;
LazyLogModule
gProfilerLog
(
"
prof
"
)
;
ProfileChunkedBuffer
&
profiler_get_core_buffer
(
)
{
static
ProfileChunkedBuffer
&
sProfileChunkedBuffer
=
baseprofiler
:
:
profiler_get_core_buffer
(
)
;
return
sProfileChunkedBuffer
;
}
#
if
defined
(
GECKO_PROFILER_ASYNC_POSIX_SIGNAL_CONTROL
)
static
const
char
sAsyncSignalControlCharStart
=
'
g
'
;
static
const
char
sAsyncSignalControlCharStop
=
'
s
'
;
static
mozilla
:
:
Atomic
<
int
mozilla
:
:
MemoryOrdering
:
:
Relaxed
>
sAsyncSignalControlWriteFd
(
-
1
)
;
mozilla
:
:
Atomic
<
bool
mozilla
:
:
MemoryOrdering
:
:
Relaxed
>
gStopAndDumpFromSignal
(
false
)
;
#
endif
void
profiler_dump_and_stop
(
)
;
void
profiler_start_from_signal
(
)
;
mozilla
:
:
Atomic
<
int
mozilla
:
:
MemoryOrdering
:
:
Relaxed
>
gSkipSampling
;
#
if
defined
(
GP_OS_android
)
class
GeckoJavaSampler
:
public
java
:
:
GeckoJavaSampler
:
:
Natives
<
GeckoJavaSampler
>
{
private
:
GeckoJavaSampler
(
)
;
public
:
static
double
GetProfilerTime
(
)
{
if
(
!
profiler_is_active
(
)
)
{
return
0
.
0
;
}
return
profiler_time
(
)
;
}
;
static
void
JavaStringArrayToCharArray
(
jni
:
:
ObjectArray
:
:
Param
&
aJavaArray
Vector
<
const
char
*
>
&
aCharArray
JNIEnv
*
aJni
)
{
int
arraySize
=
aJavaArray
-
>
Length
(
)
;
for
(
int
i
=
0
;
i
<
arraySize
;
i
+
+
)
{
jstring
javaString
=
(
jstring
)
(
aJni
-
>
GetObjectArrayElement
(
aJavaArray
.
Get
(
)
i
)
)
;
const
char
*
filterString
=
aJni
-
>
GetStringUTFChars
(
javaString
0
)
;
MOZ_RELEASE_ASSERT
(
aCharArray
.
append
(
filterString
)
)
;
}
}
static
void
StartProfiler
(
jni
:
:
ObjectArray
:
:
Param
aFiltersArray
jni
:
:
ObjectArray
:
:
Param
aFeaturesArray
)
{
JNIEnv
*
jni
=
jni
:
:
GetEnvForThread
(
)
;
Vector
<
const
char
*
>
filtersTemp
;
Vector
<
const
char
*
>
featureStringArray
;
JavaStringArrayToCharArray
(
aFiltersArray
filtersTemp
jni
)
;
JavaStringArrayToCharArray
(
aFeaturesArray
featureStringArray
jni
)
;
uint32_t
features
=
0
;
features
=
ParseFeaturesFromStringArray
(
featureStringArray
.
begin
(
)
featureStringArray
.
length
(
)
)
;
profiler_start
(
PowerOfTwo32
(
128
*
1024
*
1024
)
5
.
0
features
filtersTemp
.
begin
(
)
filtersTemp
.
length
(
)
0
Nothing
(
)
)
;
}
static
void
StopProfiler
(
jni
:
:
Object
:
:
Param
aGeckoResult
)
{
auto
result
=
java
:
:
GeckoResult
:
:
LocalRef
(
aGeckoResult
)
;
profiler_pause
(
)
;
nsCOMPtr
<
nsIProfiler
>
nsProfiler
(
do_GetService
(
"
mozilla
.
org
/
tools
/
profiler
;
1
"
)
)
;
nsProfiler
-
>
GetProfileDataAsGzippedArrayBufferAndroid
(
0
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
result
]
(
FallibleTArray
<
uint8_t
>
compressedProfile
)
{
result
-
>
Complete
(
jni
:
:
ByteArray
:
:
New
(
reinterpret_cast
<
const
int8_t
*
>
(
compressedProfile
.
Elements
(
)
)
compressedProfile
.
Length
(
)
)
)
;
profiler_stop
(
)
;
}
[
result
]
(
nsresult
aRv
)
{
char
errorString
[
9
]
;
sprintf
(
errorString
"
%
08x
"
uint32_t
(
aRv
)
)
;
result
-
>
CompleteExceptionally
(
mozilla
:
:
java
:
:
sdk
:
:
IllegalStateException
:
:
New
(
errorString
)
.
Cast
<
jni
:
:
Throwable
>
(
)
)
;
profiler_stop
(
)
;
}
)
;
}
}
;
#
endif
constexpr
static
bool
ValidateFeatures
(
)
{
int
expectedFeatureNumber
=
0
;
#
define
CHECK_FEATURE
(
n_
str_
Name_
desc_
)
\
if
(
(
n_
)
!
=
expectedFeatureNumber
)
{
\
return
false
;
\
}
\
+
+
expectedFeatureNumber
;
PROFILER_FOR_EACH_FEATURE
(
CHECK_FEATURE
)
#
undef
CHECK_FEATURE
return
true
;
}
static_assert
(
ValidateFeatures
(
)
"
Feature
list
is
invalid
"
)
;
static
uint32_t
AvailableFeatures
(
)
{
uint32_t
features
=
0
;
#
define
ADD_FEATURE
(
n_
str_
Name_
desc_
)
\
ProfilerFeature
:
:
Set
#
#
Name_
(
features
)
;
PROFILER_FOR_EACH_FEATURE
(
ADD_FEATURE
)
#
undef
ADD_FEATURE
#
if
!
defined
(
GP_OS_android
)
ProfilerFeature
:
:
ClearJava
(
features
)
;
#
endif
#
if
!
defined
(
HAVE_NATIVE_UNWIND
)
ProfilerFeature
:
:
ClearStackWalk
(
features
)
;
#
endif
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
getenv
(
"
XPCOM_MEM_BLOAT_LOG
"
)
)
{
DEBUG_LOG
(
"
XPCOM_MEM_BLOAT_LOG
is
set
disabling
native
allocations
.
"
)
;
ProfilerFeature
:
:
ClearNativeAllocations
(
features
)
;
}
#
else
ProfilerFeature
:
:
ClearMemory
(
features
)
;
ProfilerFeature
:
:
ClearNativeAllocations
(
features
)
;
#
endif
#
if
!
defined
(
GP_OS_windows
)
ProfilerFeature
:
:
ClearNoTimerResolutionChange
(
features
)
;
#
endif
#
if
!
defined
(
HAVE_CPU_FREQ_SUPPORT
)
ProfilerFeature
:
:
ClearCPUFrequency
(
features
)
;
#
endif
return
features
;
}
static
constexpr
uint32_t
DefaultFeatures
(
)
{
return
ProfilerFeature
:
:
Java
|
ProfilerFeature
:
:
JS
|
ProfilerFeature
:
:
StackWalk
|
ProfilerFeature
:
:
CPUUtilization
|
ProfilerFeature
:
:
Screenshots
|
ProfilerFeature
:
:
ProcessCPU
;
}
static
constexpr
uint32_t
StartupExtraDefaultFeatures
(
)
{
return
ProfilerFeature
:
:
FileIOAll
|
ProfilerFeature
:
:
IPCMessages
;
}
Json
:
:
String
ToCompactString
(
const
Json
:
:
Value
&
aJsonValue
)
{
Json
:
:
StreamWriterBuilder
builder
;
builder
[
"
indentation
"
]
=
"
"
;
builder
[
"
enableYAMLCompatibility
"
]
=
false
;
builder
[
"
precision
"
]
=
6
;
builder
[
"
precisionType
"
]
=
"
decimal
"
;
return
Json
:
:
writeString
(
builder
aJsonValue
)
;
}
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
ProfilingLog
:
:
gMutex
;
mozilla
:
:
UniquePtr
<
Json
:
:
Value
>
ProfilingLog
:
:
gLog
;
void
ProfilingLog
:
:
Init
(
)
{
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
{
gMutex
}
;
MOZ_ASSERT
(
!
gLog
)
;
gLog
=
mozilla
:
:
MakeUniqueFallible
<
Json
:
:
Value
>
(
Json
:
:
objectValue
)
;
if
(
gLog
)
{
(
*
gLog
)
[
Json
:
:
StaticString
{
"
profilingLogBegin
"
TIMESTAMP_JSON_SUFFIX
}
]
=
ProfilingLog
:
:
Timestamp
(
)
;
}
}
void
ProfilingLog
:
:
Destroy
(
)
{
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
{
gMutex
}
;
MOZ_ASSERT
(
gLog
)
;
gLog
=
nullptr
;
}
bool
ProfilingLog
:
:
IsLockedOnCurrentThread
(
)
{
return
gMutex
.
IsLockedOnCurrentThread
(
)
;
}
class
MOZ_RAII
PSAutoLock
{
public
:
PSAutoLock
(
)
:
mLock
(
[
]
(
)
-
>
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
&
{
MOZ_ASSERT
(
!
ThreadRegistry
:
:
IsRegistryMutexLockedOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
!
ThreadRegistration
:
:
IsDataMutexLockedOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
!
ProfilingLog
:
:
IsLockedOnCurrentThread
(
)
)
;
return
gPSMutex
;
}
(
)
)
{
}
PSAutoLock
(
const
PSAutoLock
&
)
=
delete
;
void
operator
=
(
const
PSAutoLock
&
)
=
delete
;
static
bool
IsLockedOnCurrentThread
(
)
{
return
gPSMutex
.
IsLockedOnCurrentThread
(
)
;
}
private
:
static
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
gPSMutex
;
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
mLock
;
}
;
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
PSAutoLock
:
:
gPSMutex
{
"
Gecko
Profiler
mutex
"
}
;
typedef
const
PSAutoLock
&
PSLockRef
;
#
define
PS_GET
(
type_
name_
)
\
static
type_
name_
(
PSLockRef
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
return
sInstance
-
>
m
#
#
name_
;
\
}
#
define
PS_GET_LOCKLESS
(
type_
name_
)
\
static
type_
name_
(
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
return
sInstance
-
>
m
#
#
name_
;
\
}
#
define
PS_GET_AND_SET
(
type_
name_
)
\
PS_GET
(
type_
name_
)
\
static
void
Set
#
#
name_
(
PSLockRef
type_
a
#
#
name_
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
sInstance
-
>
m
#
#
name_
=
a
#
#
name_
;
\
}
static
constexpr
size_t
MAX_JS_FRAMES
=
mozilla
:
:
profiler
:
:
ThreadRegistrationData
:
:
MAX_JS_FRAMES
;
using
JsFrame
=
mozilla
:
:
profiler
:
:
ThreadRegistrationData
:
:
JsFrame
;
using
JsFrameBuffer
=
mozilla
:
:
profiler
:
:
ThreadRegistrationData
:
:
JsFrameBuffer
;
#
if
defined
(
GECKO_PROFILER_ASYNC_POSIX_SIGNAL_CONTROL
)
static
void
*
AsyncSignalControlThreadEntry
(
void
*
aArg
)
;
class
AsyncSignalControlThread
{
public
:
AsyncSignalControlThread
(
)
:
mThread
(
)
{
int
pipeFds
[
2
]
;
if
(
pipe
(
pipeFds
)
)
{
LOG
(
"
Profiler
AsyncSignalControlThread
failed
to
create
a
pipe
.
"
)
;
return
;
}
fcntl
(
pipeFds
[
0
]
F_SETFD
FD_CLOEXEC
)
;
fcntl
(
pipeFds
[
1
]
F_SETFD
FD_CLOEXEC
)
;
mFd
=
pipeFds
[
0
]
;
sAsyncSignalControlWriteFd
=
pipeFds
[
1
]
;
pthread_attr_t
*
attr_ptr
=
nullptr
;
if
(
pthread_create
(
&
mThread
attr_ptr
AsyncSignalControlThreadEntry
this
)
!
=
0
)
{
MOZ_CRASH
(
"
pthread_create
failed
"
)
;
}
}
;
~
AsyncSignalControlThread
(
)
{
int
asyncSignalControlWriteFd
=
sAsyncSignalControlWriteFd
.
exchange
(
-
1
)
;
close
(
asyncSignalControlWriteFd
)
;
pthread_join
(
mThread
nullptr
)
;
}
;
void
Watch
(
)
{
char
msg
[
1
]
;
ssize_t
nread
;
while
(
true
)
{
nread
=
read
(
mFd
msg
sizeof
(
msg
)
)
;
if
(
nread
=
=
-
1
&
&
errno
=
=
EINTR
)
{
continue
;
}
if
(
nread
=
=
-
1
&
&
errno
!
=
EINTR
)
{
LOG
(
"
Error
(
%
d
)
when
reading
in
AsyncSignalControlThread
"
errno
)
;
return
;
}
if
(
nread
=
=
0
)
{
close
(
mFd
)
;
return
;
}
MOZ_RELEASE_ASSERT
(
nread
=
=
1
)
;
if
(
msg
[
0
]
=
=
sAsyncSignalControlCharStart
)
{
if
(
!
profiler_is_active
(
)
)
{
profiler_start_from_signal
(
)
;
}
}
else
if
(
msg
[
0
]
=
=
sAsyncSignalControlCharStop
)
{
if
(
profiler_is_active
(
)
)
{
profiler_dump_and_stop
(
)
;
}
}
else
{
LOG
(
"
AsyncSignalControlThread
recieved
unknown
control
signal
:
%
c
"
msg
[
0
]
)
;
}
}
}
;
private
:
int
mFd
;
pthread_t
mThread
;
}
;
static
void
*
AsyncSignalControlThreadEntry
(
void
*
aArg
)
{
NS_SetCurrentThreadName
(
"
AsyncSignalControlThread
"
)
;
auto
*
thread
=
static_cast
<
AsyncSignalControlThread
*
>
(
aArg
)
;
thread
-
>
Watch
(
)
;
return
nullptr
;
}
#
endif
class
CorePS
{
private
:
#
ifdef
MOZ_PERFETTO
class
PerfettoObserver
:
public
perfetto
:
:
TrackEventSessionObserver
{
public
:
PerfettoObserver
(
)
{
perfetto
:
:
TrackEvent
:
:
AddSessionObserver
(
this
)
;
}
~
PerfettoObserver
(
)
{
perfetto
:
:
TrackEvent
:
:
RemoveSessionObserver
(
this
)
;
}
void
OnStart
(
const
perfetto
:
:
DataSourceBase
:
:
StartArgs
&
)
override
{
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
:
:
SetPerfettoTracingActive
(
)
;
}
void
OnStop
(
const
perfetto
:
:
DataSourceBase
:
:
StopArgs
&
)
override
{
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
:
:
SetPerfettoTracingInactive
(
)
;
}
}
perfettoObserver
;
#
endif
CorePS
(
)
:
mProcessStartTime
(
TimeStamp
:
:
ProcessCreation
(
)
)
mMaybeBandwidthCounter
(
nullptr
)
#
if
defined
(
GECKO_PROFILER_ASYNC_POSIX_SIGNAL_CONTROL
)
mAsyncSignalControlThread
(
nullptr
)
#
endif
#
ifdef
USE_LUL_STACKWALK
mLul
(
nullptr
)
#
endif
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
CorePS
must
be
created
from
the
main
thread
"
)
;
}
~
CorePS
(
)
{
#
if
defined
(
GECKO_PROFILER_ASYNC_POSIX_SIGNAL_CONTROL
)
delete
mAsyncSignalControlThread
;
#
endif
#
ifdef
USE_LUL_STACKWALK
delete
sInstance
-
>
mLul
;
delete
mMaybeBandwidthCounter
;
#
endif
}
public
:
static
void
Create
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
!
sInstance
)
;
sInstance
=
new
CorePS
(
)
;
}
static
void
Destroy
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
delete
sInstance
;
sInstance
=
nullptr
;
}
static
bool
Exists
(
)
{
return
!
!
sInstance
;
}
static
void
AddSizeOf
(
PSLockRef
MallocSizeOf
aMallocSizeOf
size_t
&
aProfSize
size_t
&
aLulSize
)
{
MOZ_ASSERT
(
sInstance
)
;
aProfSize
+
=
aMallocSizeOf
(
sInstance
)
;
aProfSize
+
=
ThreadRegistry
:
:
SizeOfIncludingThis
(
aMallocSizeOf
)
;
for
(
auto
&
registeredPage
:
sInstance
-
>
mRegisteredPages
)
{
aProfSize
+
=
registeredPage
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
if
(
lul
:
:
LUL
*
lulPtr
=
sInstance
-
>
mLul
;
lulPtr
)
{
aLulSize
+
=
lulPtr
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
#
endif
}
PS_GET_LOCKLESS
(
TimeStamp
ProcessStartTime
)
PS_GET
(
JsFrameBuffer
&
JsFrames
)
PS_GET
(
Vector
<
RefPtr
<
PageInformation
>
>
&
RegisteredPages
)
static
void
AppendRegisteredPage
(
PSLockRef
RefPtr
<
PageInformation
>
&
&
aRegisteredPage
)
{
MOZ_ASSERT
(
sInstance
)
;
struct
RegisteredPageComparator
{
PageInformation
*
aA
;
bool
operator
(
)
(
PageInformation
*
aB
)
const
{
return
aA
-
>
Equals
(
aB
)
;
}
}
;
auto
foundPageIter
=
std
:
:
find_if
(
sInstance
-
>
mRegisteredPages
.
begin
(
)
sInstance
-
>
mRegisteredPages
.
end
(
)
RegisteredPageComparator
{
aRegisteredPage
.
get
(
)
}
)
;
if
(
foundPageIter
!
=
sInstance
-
>
mRegisteredPages
.
end
(
)
)
{
if
(
(
*
foundPageIter
)
-
>
Url
(
)
.
EqualsLiteral
(
"
about
:
blank
"
)
)
{
sInstance
-
>
mRegisteredPages
.
erase
(
foundPageIter
)
;
}
else
{
return
;
}
}
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mRegisteredPages
.
append
(
std
:
:
move
(
aRegisteredPage
)
)
)
;
}
static
void
RemoveRegisteredPage
(
PSLockRef
uint64_t
aRegisteredInnerWindowID
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mRegisteredPages
.
eraseIf
(
[
&
]
(
const
RefPtr
<
PageInformation
>
&
rd
)
{
return
rd
-
>
InnerWindowID
(
)
=
=
aRegisteredInnerWindowID
;
}
)
;
}
static
void
ClearRegisteredPages
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mRegisteredPages
.
clear
(
)
;
}
PS_GET
(
const
Vector
<
BaseProfilerCount
*
>
&
Counters
)
static
void
AppendCounter
(
PSLockRef
BaseProfilerCount
*
aCounter
)
{
MOZ_ASSERT
(
sInstance
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mCounters
.
append
(
aCounter
)
)
;
}
static
void
RemoveCounter
(
PSLockRef
BaseProfilerCount
*
aCounter
)
{
if
(
sInstance
)
{
auto
*
counter
=
std
:
:
find
(
sInstance
-
>
mCounters
.
begin
(
)
sInstance
-
>
mCounters
.
end
(
)
aCounter
)
;
MOZ_RELEASE_ASSERT
(
counter
!
=
sInstance
-
>
mCounters
.
end
(
)
)
;
sInstance
-
>
mCounters
.
erase
(
counter
)
;
}
}
#
ifdef
USE_LUL_STACKWALK
static
lul
:
:
LUL
*
Lul
(
)
{
MOZ_RELEASE_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mLul
;
}
static
void
SetLul
(
UniquePtr
<
lul
:
:
LUL
>
aLul
)
{
MOZ_RELEASE_ASSERT
(
sInstance
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mLul
.
compareExchange
(
nullptr
aLul
.
release
(
)
)
)
;
}
#
endif
PS_GET_AND_SET
(
const
nsACString
&
ProcessName
)
PS_GET_AND_SET
(
const
nsACString
&
ETLDplus1
)
#
if
!
defined
(
XP_WIN
)
PS_GET_AND_SET
(
const
Maybe
<
nsCOMPtr
<
nsIFile
>
>
&
AsyncSignalDumpDirectory
)
#
endif
static
void
SetBandwidthCounter
(
ProfilerBandwidthCounter
*
aBandwidthCounter
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mMaybeBandwidthCounter
=
aBandwidthCounter
;
}
static
ProfilerBandwidthCounter
*
GetBandwidthCounter
(
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mMaybeBandwidthCounter
;
}
#
if
defined
(
GECKO_PROFILER_ASYNC_POSIX_SIGNAL_CONTROL
)
static
void
SetAsyncSignalControlThread
(
AsyncSignalControlThread
*
aAsyncSignalControlThread
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mAsyncSignalControlThread
=
aAsyncSignalControlThread
;
}
#
endif
private
:
static
CorePS
*
sInstance
;
const
TimeStamp
mProcessStartTime
;
ProfilerBandwidthCounter
*
mMaybeBandwidthCounter
;
Vector
<
RefPtr
<
PageInformation
>
>
mRegisteredPages
;
Vector
<
BaseProfilerCount
*
>
mCounters
;
#
if
defined
(
GECKO_PROFILER_ASYNC_POSIX_SIGNAL_CONTROL
)
AsyncSignalControlThread
*
mAsyncSignalControlThread
;
#
endif
#
ifdef
USE_LUL_STACKWALK
mozilla
:
:
Atomic
<
lul
:
:
LUL
*
>
mLul
;
#
endif
nsAutoCString
mProcessName
;
nsAutoCString
mETLDplus1
;
JsFrameBuffer
mJsFrames
;
#
if
!
defined
(
XP_WIN
)
Maybe
<
nsCOMPtr
<
nsIFile
>
>
mAsyncSignalDumpDirectory
;
#
endif
}
;
CorePS
*
CorePS
:
:
sInstance
=
nullptr
;
void
locked_profiler_add_sampled_counter
(
PSLockRef
aLock
BaseProfilerCount
*
aCounter
)
{
CorePS
:
:
AppendCounter
(
aLock
aCounter
)
;
}
void
locked_profiler_remove_sampled_counter
(
PSLockRef
aLock
BaseProfilerCount
*
aCounter
)
{
CorePS
:
:
RemoveCounter
(
aLock
aCounter
)
;
}
class
SamplerThread
;
static
SamplerThread
*
NewSamplerThread
(
PSLockRef
aLock
uint32_t
aGeneration
double
aInterval
uint32_t
aFeatures
)
;
struct
LiveProfiledThreadData
{
UniquePtr
<
ProfiledThreadData
>
mProfiledThreadData
;
}
;
class
ActivePS
{
private
:
constexpr
static
uint32_t
ChunkSizeForEntries
(
uint32_t
aEntries
)
{
return
uint32_t
(
std
:
:
min
(
size_t
(
ClampToAllowedEntries
(
aEntries
)
)
*
scBytesPerEntry
/
scMinimumNumberOfChunks
size_t
(
scMaximumChunkSize
)
)
)
;
}
static
uint32_t
AdjustFeatures
(
uint32_t
aFeatures
uint32_t
aFilterCount
)
{
aFeatures
&
=
AvailableFeatures
(
)
;
if
(
aFeatures
&
ProfilerFeature
:
:
FileIOAll
)
{
aFeatures
|
=
ProfilerFeature
:
:
MainThreadIO
|
ProfilerFeature
:
:
FileIO
;
}
else
if
(
aFeatures
&
ProfilerFeature
:
:
FileIO
)
{
aFeatures
|
=
ProfilerFeature
:
:
MainThreadIO
;
}
if
(
aFeatures
&
ProfilerFeature
:
:
CPUAllThreads
)
{
aFeatures
|
=
ProfilerFeature
:
:
CPUUtilization
;
}
return
aFeatures
;
}
bool
ShouldInterposeIOs
(
)
{
return
ProfilerFeature
:
:
HasMainThreadIO
(
mFeatures
)
|
|
ProfilerFeature
:
:
HasFileIO
(
mFeatures
)
|
|
ProfilerFeature
:
:
HasFileIOAll
(
mFeatures
)
;
}
ActivePS
(
PSLockRef
aLock
const
TimeStamp
&
aProfilingStartTime
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
const
Maybe
<
double
>
&
aDuration
UniquePtr
<
ProfileBufferChunkManagerWithLocalLimit
>
aChunkManagerOrNull
)
:
mProfilingStartTime
(
aProfilingStartTime
)
mGeneration
(
sNextGeneration
+
+
)
mCapacity
(
aCapacity
)
mDuration
(
aDuration
)
mInterval
(
aInterval
)
mFeatures
(
AdjustFeatures
(
aFeatures
aFilterCount
)
)
mActiveTabID
(
aActiveTabID
)
mProfileBufferChunkManager
(
aChunkManagerOrNull
?
std
:
:
move
(
aChunkManagerOrNull
)
:
MakeUnique
<
ProfileBufferChunkManagerWithLocalLimit
>
(
size_t
(
ClampToAllowedEntries
(
aCapacity
.
Value
(
)
)
)
*
scBytesPerEntry
ChunkSizeForEntries
(
aCapacity
.
Value
(
)
)
)
)
mProfileBuffer
(
[
this
]
(
)
-
>
ProfileChunkedBuffer
&
{
ProfileChunkedBuffer
&
coreBuffer
=
profiler_get_core_buffer
(
)
;
coreBuffer
.
SetChunkManagerIfDifferent
(
*
mProfileBufferChunkManager
)
;
return
coreBuffer
;
}
(
)
)
mMaybeProcessCPUCounter
(
ProfilerFeature
:
:
HasProcessCPU
(
aFeatures
)
?
new
ProcessCPUCounter
(
aLock
)
:
nullptr
)
mMaybePowerCounters
(
nullptr
)
mMaybeCPUFreq
(
nullptr
)
mSamplerThread
(
NewSamplerThread
(
aLock
mGeneration
aInterval
aFeatures
)
)
mIsPaused
(
false
)
mIsSamplingPaused
(
false
)
{
ProfilingLog
:
:
Init
(
)
;
MOZ_ALWAYS_TRUE
(
mFilters
.
resize
(
aFilterCount
)
)
;
MOZ_ALWAYS_TRUE
(
mFiltersLowered
.
resize
(
aFilterCount
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
mFilters
[
i
]
=
aFilters
[
i
]
;
mFiltersLowered
[
i
]
.
reserve
(
mFilters
[
i
]
.
size
(
)
)
;
std
:
:
transform
(
mFilters
[
i
]
.
cbegin
(
)
mFilters
[
i
]
.
cend
(
)
std
:
:
back_inserter
(
mFiltersLowered
[
i
]
)
:
:
tolower
)
;
}
#
if
!
defined
(
RELEASE_OR_BETA
)
if
(
ShouldInterposeIOs
(
)
)
{
if
(
NS_IsMainThread
(
)
)
{
IOInterposer
:
:
Init
(
)
;
IOInterposer
:
:
Register
(
IOInterposeObserver
:
:
OpAll
&
ProfilerIOInterposeObserver
:
:
GetInstance
(
)
)
;
}
else
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ActivePS
:
:
ActivePS
"
[
]
(
)
{
IOInterposer
:
:
Init
(
)
;
IOInterposer
:
:
Register
(
IOInterposeObserver
:
:
OpAll
&
ProfilerIOInterposeObserver
:
:
GetInstance
(
)
)
;
}
)
)
;
}
}
#
endif
if
(
ProfilerFeature
:
:
HasPower
(
aFeatures
)
)
{
mMaybePowerCounters
=
new
PowerCounters
(
)
;
for
(
const
auto
&
powerCounter
:
mMaybePowerCounters
-
>
GetCounters
(
)
)
{
locked_profiler_add_sampled_counter
(
aLock
powerCounter
.
get
(
)
)
;
}
}
if
(
ProfilerFeature
:
:
HasCPUFrequency
(
aFeatures
)
)
{
mMaybeCPUFreq
=
new
ProfilerCPUFreq
(
)
;
}
}
~
ActivePS
(
)
{
MOZ_ASSERT
(
!
mMaybeProcessCPUCounter
"
mMaybeProcessCPUCounter
should
have
been
deleted
before
~
ActivePS
(
)
"
)
;
MOZ_ASSERT
(
!
mMaybePowerCounters
"
mMaybePowerCounters
should
have
been
deleted
before
~
ActivePS
(
)
"
)
;
MOZ_ASSERT
(
!
mMaybeCPUFreq
"
mMaybeCPUFreq
should
have
been
deleted
before
~
ActivePS
(
)
"
)
;
#
if
!
defined
(
RELEASE_OR_BETA
)
if
(
ShouldInterposeIOs
(
)
)
{
if
(
NS_IsMainThread
(
)
)
{
IOInterposer
:
:
Unregister
(
IOInterposeObserver
:
:
OpAll
&
ProfilerIOInterposeObserver
:
:
GetInstance
(
)
)
;
}
else
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ActivePS
:
:
~
ActivePS
"
[
]
(
)
{
IOInterposer
:
:
Unregister
(
IOInterposeObserver
:
:
OpAll
&
ProfilerIOInterposeObserver
:
:
GetInstance
(
)
)
;
}
)
)
;
}
}
#
endif
if
(
mProfileBufferChunkManager
)
{
profiler_get_core_buffer
(
)
.
ResetChunkManager
(
)
;
}
ProfilingLog
:
:
Destroy
(
)
;
}
bool
ThreadSelected
(
const
char
*
aThreadName
)
{
if
(
mFiltersLowered
.
empty
(
)
)
{
return
true
;
}
std
:
:
string
name
=
aThreadName
;
std
:
:
transform
(
name
.
begin
(
)
name
.
end
(
)
name
.
begin
(
)
:
:
tolower
)
;
for
(
const
auto
&
filter
:
mFiltersLowered
)
{
if
(
filter
=
=
"
*
"
)
{
return
true
;
}
if
(
name
.
find
(
filter
)
!
=
std
:
:
string
:
:
npos
)
{
return
true
;
}
if
(
mozilla
:
:
profiler
:
:
detail
:
:
FilterHasPid
(
filter
.
c_str
(
)
)
)
{
return
true
;
}
}
return
false
;
}
public
:
static
void
Create
(
PSLockRef
aLock
const
TimeStamp
&
aProfilingStartTime
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
const
Maybe
<
double
>
&
aDuration
UniquePtr
<
ProfileBufferChunkManagerWithLocalLimit
>
aChunkManagerOrNull
)
{
MOZ_ASSERT
(
!
sInstance
)
;
sInstance
=
new
ActivePS
(
aLock
aProfilingStartTime
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aActiveTabID
aDuration
std
:
:
move
(
aChunkManagerOrNull
)
)
;
}
[
[
nodiscard
]
]
static
SamplerThread
*
Destroy
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
if
(
sInstance
-
>
mMaybeProcessCPUCounter
)
{
locked_profiler_remove_sampled_counter
(
aLock
sInstance
-
>
mMaybeProcessCPUCounter
)
;
delete
sInstance
-
>
mMaybeProcessCPUCounter
;
sInstance
-
>
mMaybeProcessCPUCounter
=
nullptr
;
}
if
(
sInstance
-
>
mMaybePowerCounters
)
{
for
(
const
auto
&
powerCounter
:
sInstance
-
>
mMaybePowerCounters
-
>
GetCounters
(
)
)
{
locked_profiler_remove_sampled_counter
(
aLock
powerCounter
.
get
(
)
)
;
}
delete
sInstance
-
>
mMaybePowerCounters
;
sInstance
-
>
mMaybePowerCounters
=
nullptr
;
}
if
(
sInstance
-
>
mMaybeCPUFreq
)
{
delete
sInstance
-
>
mMaybeCPUFreq
;
sInstance
-
>
mMaybeCPUFreq
=
nullptr
;
}
ProfilerBandwidthCounter
*
counter
=
CorePS
:
:
GetBandwidthCounter
(
)
;
if
(
counter
&
&
counter
-
>
IsRegistered
(
)
)
{
locked_profiler_remove_sampled_counter
(
aLock
counter
)
;
counter
-
>
MarkUnregistered
(
)
;
}
auto
samplerThread
=
sInstance
-
>
mSamplerThread
;
delete
sInstance
;
sInstance
=
nullptr
;
return
samplerThread
;
}
static
bool
Exists
(
PSLockRef
)
{
return
!
!
sInstance
;
}
static
bool
Equals
(
PSLockRef
PowerOfTwo32
aCapacity
const
Maybe
<
double
>
&
aDuration
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
)
{
MOZ_ASSERT
(
sInstance
)
;
if
(
sInstance
-
>
mCapacity
!
=
aCapacity
|
|
sInstance
-
>
mDuration
!
=
aDuration
|
|
sInstance
-
>
mInterval
!
=
aInterval
|
|
sInstance
-
>
mFeatures
!
=
aFeatures
|
|
sInstance
-
>
mFilters
.
length
(
)
!
=
aFilterCount
|
|
sInstance
-
>
mActiveTabID
!
=
aActiveTabID
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
sInstance
-
>
mFilters
.
length
(
)
;
+
+
i
)
{
if
(
strcmp
(
sInstance
-
>
mFilters
[
i
]
.
c_str
(
)
aFilters
[
i
]
)
!
=
0
)
{
return
false
;
}
}
return
true
;
}
static
size_t
SizeOf
(
PSLockRef
MallocSizeOf
aMallocSizeOf
)
{
MOZ_ASSERT
(
sInstance
)
;
size_t
n
=
aMallocSizeOf
(
sInstance
)
;
n
+
=
sInstance
-
>
mProfileBuffer
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
return
n
;
}
static
ThreadProfilingFeatures
ProfilingFeaturesForThread
(
PSLockRef
aLock
const
ThreadRegistrationInfo
&
aInfo
)
{
MOZ_ASSERT
(
sInstance
)
;
if
(
sInstance
-
>
ThreadSelected
(
aInfo
.
Name
(
)
)
)
{
return
ThreadProfilingFeatures
:
:
Any
;
}
ThreadProfilingFeatures
features
=
ThreadProfilingFeatures
:
:
NotProfiled
;
if
(
ActivePS
:
:
FeatureCPUAllThreads
(
aLock
)
)
{
features
=
Combine
(
features
ThreadProfilingFeatures
:
:
CPUUtilization
)
;
}
if
(
ActivePS
:
:
FeatureSamplingAllThreads
(
aLock
)
)
{
features
=
Combine
(
features
ThreadProfilingFeatures
:
:
Sampling
)
;
}
if
(
ActivePS
:
:
FeatureMarkersAllThreads
(
aLock
)
)
{
features
=
Combine
(
features
ThreadProfilingFeatures
:
:
Markers
)
;
}
return
features
;
}
[
[
nodiscard
]
]
static
bool
AppendPostSamplingCallback
(
PSLockRef
PostSamplingCallback
&
&
aCallback
)
;
static
void
WriteActiveConfiguration
(
PSLockRef
aLock
JSONWriter
&
aWriter
const
Span
<
const
char
>
&
aPropertyName
=
MakeStringSpan
(
"
"
)
)
{
if
(
!
sInstance
)
{
if
(
!
aPropertyName
.
empty
(
)
)
{
aWriter
.
NullProperty
(
aPropertyName
)
;
}
else
{
aWriter
.
NullElement
(
)
;
}
return
;
}
;
if
(
!
aPropertyName
.
empty
(
)
)
{
aWriter
.
StartObjectProperty
(
aPropertyName
)
;
}
else
{
aWriter
.
StartObjectElement
(
)
;
}
{
aWriter
.
StartArrayProperty
(
"
features
"
)
;
#
define
WRITE_ACTIVE_FEATURES
(
n_
str_
Name_
desc_
)
\
if
(
profiler_feature_active
(
ProfilerFeature
:
:
Name_
)
)
{
\
aWriter
.
StringElement
(
str_
)
;
\
}
PROFILER_FOR_EACH_FEATURE
(
WRITE_ACTIVE_FEATURES
)
#
undef
WRITE_ACTIVE_FEATURES
aWriter
.
EndArray
(
)
;
}
{
aWriter
.
StartArrayProperty
(
"
threads
"
)
;
for
(
const
auto
&
filter
:
sInstance
-
>
mFilters
)
{
aWriter
.
StringElement
(
filter
)
;
}
aWriter
.
EndArray
(
)
;
}
{
aWriter
.
DoubleProperty
(
"
interval
"
sInstance
-
>
mInterval
)
;
aWriter
.
IntProperty
(
"
capacity
"
sInstance
-
>
mCapacity
.
Value
(
)
)
;
if
(
sInstance
-
>
mDuration
)
{
aWriter
.
DoubleProperty
(
"
duration
"
sInstance
-
>
mDuration
.
value
(
)
)
;
}
aWriter
.
DoubleProperty
(
"
activeTabID
"
sInstance
-
>
mActiveTabID
)
;
}
aWriter
.
EndObject
(
)
;
}
PS_GET_LOCKLESS
(
TimeStamp
ProfilingStartTime
)
PS_GET
(
uint32_t
Generation
)
PS_GET
(
PowerOfTwo32
Capacity
)
PS_GET
(
Maybe
<
double
>
Duration
)
PS_GET
(
double
Interval
)
PS_GET
(
uint32_t
Features
)
PS_GET
(
uint64_t
ActiveTabID
)
#
define
PS_GET_FEATURE
(
n_
str_
Name_
desc_
)
\
static
bool
Feature
#
#
Name_
(
PSLockRef
)
{
\
MOZ_ASSERT
(
sInstance
)
;
\
return
ProfilerFeature
:
:
Has
#
#
Name_
(
sInstance
-
>
mFeatures
)
;
\
}
PROFILER_FOR_EACH_FEATURE
(
PS_GET_FEATURE
)
#
undef
PS_GET_FEATURE
static
bool
ShouldInstallMemoryHooks
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
return
ProfilerFeature
:
:
ShouldInstallMemoryHooks
(
sInstance
-
>
mFeatures
)
;
}
static
uint32_t
JSFlags
(
PSLockRef
aLock
)
{
uint32_t
Flags
=
0
;
Flags
|
=
FeatureJS
(
aLock
)
?
uint32_t
(
JSInstrumentationFlags
:
:
StackSampling
)
:
0
;
Flags
|
=
FeatureJSAllocations
(
aLock
)
?
uint32_t
(
JSInstrumentationFlags
:
:
Allocations
)
:
0
;
return
Flags
;
}
PS_GET
(
const
Vector
<
std
:
:
string
>
&
Filters
)
PS_GET
(
const
Vector
<
std
:
:
string
>
&
FiltersLowered
)
static
ProfileBufferChunkManagerWithLocalLimit
&
ControlledChunkManager
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
MOZ_ASSERT
(
sInstance
-
>
mProfileBufferChunkManager
)
;
return
*
sInstance
-
>
mProfileBufferChunkManager
;
}
static
void
FulfillChunkRequests
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
if
(
sInstance
-
>
mProfileBufferChunkManager
)
{
sInstance
-
>
mProfileBufferChunkManager
-
>
FulfillChunkRequests
(
)
;
}
}
static
ProfileBuffer
&
Buffer
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mProfileBuffer
;
}
static
const
Vector
<
LiveProfiledThreadData
>
&
LiveProfiledThreads
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mLiveProfiledThreads
;
}
struct
ProfiledThreadListElement
{
TimeStamp
mRegisterTime
;
JSContext
*
mJSContext
;
ProfiledThreadData
*
mProfiledThreadData
;
}
;
using
ProfiledThreadList
=
Vector
<
ProfiledThreadListElement
>
;
static
ProfiledThreadList
ProfiledThreads
(
ThreadRegistry
:
:
LockedRegistry
&
aLockedRegistry
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
ProfiledThreadList
array
;
MOZ_RELEASE_ASSERT
(
array
.
initCapacity
(
sInstance
-
>
mLiveProfiledThreads
.
length
(
)
+
sInstance
-
>
mDeadProfiledThreads
.
length
(
)
)
)
;
for
(
ThreadRegistry
:
:
OffThreadRef
offThreadRef
:
aLockedRegistry
)
{
ProfiledThreadData
*
profiledThreadData
=
offThreadRef
.
UnlockedRWForLockedProfilerRef
(
)
.
GetProfiledThreadData
(
aLock
)
;
if
(
!
profiledThreadData
)
{
continue
;
}
ThreadRegistry
:
:
OffThreadRef
:
:
RWFromAnyThreadWithLock
lockedThreadData
=
offThreadRef
.
GetLockedRWFromAnyThread
(
)
;
MOZ_RELEASE_ASSERT
(
array
.
append
(
ProfiledThreadListElement
{
profiledThreadData
-
>
Info
(
)
.
RegisterTime
(
)
lockedThreadData
-
>
GetJSContext
(
)
profiledThreadData
}
)
)
;
}
for
(
auto
&
t
:
sInstance
-
>
mDeadProfiledThreads
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
ProfiledThreadListElement
{
t
-
>
Info
(
)
.
RegisterTime
(
)
(
JSContext
*
)
nullptr
t
.
get
(
)
}
)
)
;
}
std
:
:
sort
(
array
.
begin
(
)
array
.
end
(
)
[
]
(
const
ProfiledThreadListElement
&
a
const
ProfiledThreadListElement
&
b
)
{
return
a
.
mRegisterTime
<
b
.
mRegisterTime
;
}
)
;
return
array
;
}
static
Vector
<
RefPtr
<
PageInformation
>
>
ProfiledPages
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
Vector
<
RefPtr
<
PageInformation
>
>
array
;
for
(
auto
&
d
:
CorePS
:
:
RegisteredPages
(
aLock
)
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
d
)
)
;
}
for
(
auto
&
d
:
sInstance
-
>
mDeadProfiledPages
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
d
)
)
;
}
return
array
;
}
static
ProfiledThreadData
*
AddLiveProfiledThread
(
PSLockRef
UniquePtr
<
ProfiledThreadData
>
&
&
aProfiledThreadData
)
{
MOZ_ASSERT
(
sInstance
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mLiveProfiledThreads
.
append
(
LiveProfiledThreadData
{
std
:
:
move
(
aProfiledThreadData
)
}
)
)
;
return
sInstance
-
>
mLiveProfiledThreads
.
back
(
)
.
mProfiledThreadData
.
get
(
)
;
}
static
void
UnregisterThread
(
PSLockRef
aLockRef
ProfiledThreadData
*
aProfiledThreadData
)
{
MOZ_ASSERT
(
sInstance
)
;
DiscardExpiredDeadProfiledThreads
(
aLockRef
)
;
for
(
size_t
i
=
0
;
i
<
sInstance
-
>
mLiveProfiledThreads
.
length
(
)
;
i
+
+
)
{
LiveProfiledThreadData
&
thread
=
sInstance
-
>
mLiveProfiledThreads
[
i
]
;
if
(
thread
.
mProfiledThreadData
=
=
aProfiledThreadData
)
{
thread
.
mProfiledThreadData
-
>
NotifyUnregistered
(
sInstance
-
>
mProfileBuffer
.
BufferRangeEnd
(
)
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mDeadProfiledThreads
.
append
(
std
:
:
move
(
thread
.
mProfiledThreadData
)
)
)
;
sInstance
-
>
mLiveProfiledThreads
.
erase
(
&
sInstance
-
>
mLiveProfiledThreads
[
i
]
)
;
return
;
}
}
}
class
ProcessCPUCounter
final
:
public
BaseProfilerCount
{
public
:
explicit
ProcessCPUCounter
(
PSLockRef
aLock
)
:
BaseProfilerCount
(
"
processCPU
"
&
mCounter
nullptr
"
CPU
"
"
Process
CPU
utilization
"
)
{
locked_profiler_add_sampled_counter
(
aLock
this
)
;
}
void
Add
(
int64_t
aNumber
)
{
mCounter
+
=
aNumber
;
}
private
:
ProfilerAtomicSigned
mCounter
;
}
;
PS_GET
(
ProcessCPUCounter
*
MaybeProcessCPUCounter
)
;
PS_GET
(
PowerCounters
*
MaybePowerCounters
)
;
PS_GET
(
ProfilerCPUFreq
*
MaybeCPUFreq
)
;
PS_GET_AND_SET
(
bool
IsPaused
)
static
bool
IsSamplingPaused
(
PSLockRef
lock
)
{
MOZ_ASSERT
(
sInstance
)
;
return
IsPaused
(
lock
)
|
|
sInstance
-
>
mIsSamplingPaused
;
}
static
void
SetIsSamplingPaused
(
PSLockRef
bool
aIsSamplingPaused
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mIsSamplingPaused
=
aIsSamplingPaused
;
}
static
void
DiscardExpiredDeadProfiledThreads
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
uint64_t
bufferRangeStart
=
sInstance
-
>
mProfileBuffer
.
BufferRangeStart
(
)
;
sInstance
-
>
mDeadProfiledThreads
.
eraseIf
(
[
bufferRangeStart
]
(
const
UniquePtr
<
ProfiledThreadData
>
&
aProfiledThreadData
)
{
Maybe
<
uint64_t
>
bufferPosition
=
aProfiledThreadData
-
>
BufferPositionWhenUnregistered
(
)
;
MOZ_RELEASE_ASSERT
(
bufferPosition
"
should
have
unregistered
this
thread
"
)
;
return
*
bufferPosition
<
bufferRangeStart
;
}
)
;
}
static
void
UnregisterPage
(
PSLockRef
aLock
uint64_t
aRegisteredInnerWindowID
)
{
MOZ_ASSERT
(
sInstance
)
;
auto
&
registeredPages
=
CorePS
:
:
RegisteredPages
(
aLock
)
;
for
(
size_t
i
=
0
;
i
<
registeredPages
.
length
(
)
;
i
+
+
)
{
RefPtr
<
PageInformation
>
&
page
=
registeredPages
[
i
]
;
if
(
page
-
>
InnerWindowID
(
)
=
=
aRegisteredInnerWindowID
)
{
page
-
>
NotifyUnregistered
(
sInstance
-
>
mProfileBuffer
.
BufferRangeEnd
(
)
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mDeadProfiledPages
.
append
(
std
:
:
move
(
page
)
)
)
;
registeredPages
.
erase
(
&
registeredPages
[
i
-
-
]
)
;
}
}
}
static
void
DiscardExpiredPages
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
uint64_t
bufferRangeStart
=
sInstance
-
>
mProfileBuffer
.
BufferRangeStart
(
)
;
sInstance
-
>
mDeadProfiledPages
.
eraseIf
(
[
bufferRangeStart
]
(
const
RefPtr
<
PageInformation
>
&
aProfiledPage
)
{
Maybe
<
uint64_t
>
bufferPosition
=
aProfiledPage
-
>
BufferPositionWhenUnregistered
(
)
;
MOZ_RELEASE_ASSERT
(
bufferPosition
"
should
have
unregistered
this
page
"
)
;
return
*
bufferPosition
<
bufferRangeStart
;
}
)
;
}
static
void
ClearUnregisteredPages
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mDeadProfiledPages
.
clear
(
)
;
}
static
void
ClearExpiredExitProfiles
(
PSLockRef
)
{
MOZ_ASSERT
(
sInstance
)
;
uint64_t
bufferRangeStart
=
sInstance
-
>
mProfileBuffer
.
BufferRangeStart
(
)
;
if
(
sInstance
-
>
mBaseProfileThreads
&
&
sInstance
-
>
mGeckoIndexWhenBaseProfileAdded
.
ConvertToProfileBufferIndex
(
)
<
profiler_get_core_buffer
(
)
.
GetState
(
)
.
mRangeStart
)
{
DEBUG_LOG
(
"
ClearExpiredExitProfiles
(
)
-
Discarding
base
profile
%
p
"
sInstance
-
>
mBaseProfileThreads
.
get
(
)
)
;
sInstance
-
>
mBaseProfileThreads
.
reset
(
)
;
}
sInstance
-
>
mExitProfiles
.
eraseIf
(
[
bufferRangeStart
]
(
const
ExitProfile
&
aExitProfile
)
{
return
aExitProfile
.
mBufferPositionAtGatherTime
<
bufferRangeStart
;
}
)
;
}
static
void
AddBaseProfileThreads
(
PSLockRef
aLock
UniquePtr
<
char
[
]
>
aBaseProfileThreads
)
{
MOZ_ASSERT
(
sInstance
)
;
DEBUG_LOG
(
"
AddBaseProfileThreads
(
%
p
)
"
aBaseProfileThreads
.
get
(
)
)
;
sInstance
-
>
mBaseProfileThreads
=
std
:
:
move
(
aBaseProfileThreads
)
;
sInstance
-
>
mGeckoIndexWhenBaseProfileAdded
=
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
profiler_get_core_buffer
(
)
.
GetState
(
)
.
mRangeEnd
)
;
}
static
UniquePtr
<
char
[
]
>
MoveBaseProfileThreads
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
ClearExpiredExitProfiles
(
aLock
)
;
DEBUG_LOG
(
"
MoveBaseProfileThreads
(
)
-
Consuming
base
profile
%
p
"
sInstance
-
>
mBaseProfileThreads
.
get
(
)
)
;
return
std
:
:
move
(
sInstance
-
>
mBaseProfileThreads
)
;
}
static
void
AddExitProfile
(
PSLockRef
aLock
const
nsACString
&
aExitProfile
)
{
MOZ_ASSERT
(
sInstance
)
;
ClearExpiredExitProfiles
(
aLock
)
;
MOZ_RELEASE_ASSERT
(
sInstance
-
>
mExitProfiles
.
append
(
ExitProfile
{
nsCString
(
aExitProfile
)
sInstance
-
>
mProfileBuffer
.
BufferRangeEnd
(
)
}
)
)
;
}
static
Vector
<
nsCString
>
MoveExitProfiles
(
PSLockRef
aLock
)
{
MOZ_ASSERT
(
sInstance
)
;
ClearExpiredExitProfiles
(
aLock
)
;
Vector
<
nsCString
>
profiles
;
MOZ_RELEASE_ASSERT
(
profiles
.
initCapacity
(
sInstance
-
>
mExitProfiles
.
length
(
)
)
)
;
for
(
auto
&
profile
:
sInstance
-
>
mExitProfiles
)
{
MOZ_RELEASE_ASSERT
(
profiles
.
append
(
std
:
:
move
(
profile
.
mJSON
)
)
)
;
}
sInstance
-
>
mExitProfiles
.
clear
(
)
;
return
profiles
;
}
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
static
void
SetMemoryCounter
(
const
BaseProfilerCount
*
aMemoryCounter
)
{
MOZ_ASSERT
(
sInstance
)
;
sInstance
-
>
mMemoryCounter
=
aMemoryCounter
;
}
static
bool
IsMemoryCounter
(
const
BaseProfilerCount
*
aMemoryCounter
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
-
>
mMemoryCounter
=
=
aMemoryCounter
;
}
#
endif
private
:
static
ActivePS
*
sInstance
;
const
TimeStamp
mProfilingStartTime
;
const
uint32_t
mGeneration
;
static
uint32_t
sNextGeneration
;
const
PowerOfTwo32
mCapacity
;
const
Maybe
<
double
>
mDuration
;
const
double
mInterval
;
const
uint32_t
mFeatures
;
Vector
<
std
:
:
string
>
mFilters
;
Vector
<
std
:
:
string
>
mFiltersLowered
;
const
uint64_t
mActiveTabID
;
UniquePtr
<
ProfileBufferChunkManagerWithLocalLimit
>
mProfileBufferChunkManager
;
ProfileBuffer
mProfileBuffer
;
Vector
<
LiveProfiledThreadData
>
mLiveProfiledThreads
;
Vector
<
UniquePtr
<
ProfiledThreadData
>
>
mDeadProfiledThreads
;
Vector
<
RefPtr
<
PageInformation
>
>
mDeadProfiledPages
;
ProcessCPUCounter
*
mMaybeProcessCPUCounter
;
PowerCounters
*
mMaybePowerCounters
;
ProfilerCPUFreq
*
mMaybeCPUFreq
;
SamplerThread
*
const
mSamplerThread
;
bool
mIsPaused
;
bool
mIsSamplingPaused
;
UniquePtr
<
char
[
]
>
mBaseProfileThreads
;
ProfileBufferBlockIndex
mGeckoIndexWhenBaseProfileAdded
;
struct
ExitProfile
{
nsCString
mJSON
;
uint64_t
mBufferPositionAtGatherTime
;
}
;
Vector
<
ExitProfile
>
mExitProfiles
;
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
Atomic
<
const
BaseProfilerCount
*
>
mMemoryCounter
;
#
endif
}
;
ActivePS
*
ActivePS
:
:
sInstance
=
nullptr
;
uint32_t
ActivePS
:
:
sNextGeneration
=
0
;
#
undef
PS_GET
#
undef
PS_GET_LOCKLESS
#
undef
PS_GET_AND_SET
using
ProfilerStateChangeMutex
=
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
;
using
ProfilerStateChangeLock
=
mozilla
:
:
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
;
static
ProfilerStateChangeMutex
gProfilerStateChangeMutex
;
struct
IdentifiedProfilingStateChangeCallback
{
ProfilingStateSet
mProfilingStateSet
;
ProfilingStateChangeCallback
mProfilingStateChangeCallback
;
uintptr_t
mUniqueIdentifier
;
explicit
IdentifiedProfilingStateChangeCallback
(
ProfilingStateSet
aProfilingStateSet
ProfilingStateChangeCallback
&
&
aProfilingStateChangeCallback
uintptr_t
aUniqueIdentifier
)
:
mProfilingStateSet
(
aProfilingStateSet
)
mProfilingStateChangeCallback
(
aProfilingStateChangeCallback
)
mUniqueIdentifier
(
aUniqueIdentifier
)
{
}
}
;
using
IdentifiedProfilingStateChangeCallbackUPtr
=
UniquePtr
<
IdentifiedProfilingStateChangeCallback
>
;
static
Vector
<
IdentifiedProfilingStateChangeCallbackUPtr
>
mIdentifiedProfilingStateChangeCallbacks
;
void
profiler_add_state_change_callback
(
ProfilingStateSet
aProfilingStateSet
ProfilingStateChangeCallback
&
&
aCallback
uintptr_t
aUniqueIdentifier
)
{
MOZ_ASSERT
(
!
PSAutoLock
:
:
IsLockedOnCurrentThread
(
)
)
;
ProfilerStateChangeLock
lock
(
gProfilerStateChangeMutex
)
;
#
ifdef
DEBUG
if
(
aUniqueIdentifier
!
=
0
)
{
for
(
const
IdentifiedProfilingStateChangeCallbackUPtr
&
idedCallback
:
mIdentifiedProfilingStateChangeCallbacks
)
{
MOZ_ASSERT
(
idedCallback
-
>
mUniqueIdentifier
!
=
aUniqueIdentifier
)
;
}
}
#
endif
if
(
aProfilingStateSet
.
contains
(
ProfilingState
:
:
AlreadyActive
)
&
&
profiler_is_active
(
)
)
{
aCallback
(
ProfilingState
:
:
AlreadyActive
)
;
}
(
void
)
mIdentifiedProfilingStateChangeCallbacks
.
append
(
MakeUnique
<
IdentifiedProfilingStateChangeCallback
>
(
aProfilingStateSet
std
:
:
move
(
aCallback
)
aUniqueIdentifier
)
)
;
}
void
profiler_remove_state_change_callback
(
uintptr_t
aUniqueIdentifier
)
{
MOZ_ASSERT
(
aUniqueIdentifier
!
=
0
)
;
if
(
aUniqueIdentifier
=
=
0
)
{
return
;
}
MOZ_ASSERT
(
!
PSAutoLock
:
:
IsLockedOnCurrentThread
(
)
)
;
ProfilerStateChangeLock
lock
(
gProfilerStateChangeMutex
)
;
mIdentifiedProfilingStateChangeCallbacks
.
eraseIf
(
[
aUniqueIdentifier
]
(
const
IdentifiedProfilingStateChangeCallbackUPtr
&
aIdedCallback
)
{
if
(
aIdedCallback
-
>
mUniqueIdentifier
!
=
aUniqueIdentifier
)
{
return
false
;
}
if
(
aIdedCallback
-
>
mProfilingStateSet
.
contains
(
ProfilingState
:
:
RemovingCallback
)
)
{
aIdedCallback
-
>
mProfilingStateChangeCallback
(
ProfilingState
:
:
RemovingCallback
)
;
}
return
true
;
}
)
;
}
static
void
invoke_profiler_state_change_callbacks
(
ProfilingState
aProfilingState
)
{
MOZ_ASSERT
(
!
PSAutoLock
:
:
IsLockedOnCurrentThread
(
)
)
;
ProfilerStateChangeLock
lock
(
gProfilerStateChangeMutex
)
;
for
(
const
IdentifiedProfilingStateChangeCallbackUPtr
&
idedCallback
:
mIdentifiedProfilingStateChangeCallbacks
)
{
if
(
idedCallback
-
>
mProfilingStateSet
.
contains
(
aProfilingState
)
)
{
idedCallback
-
>
mProfilingStateChangeCallback
(
aProfilingState
)
;
}
}
}
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
RacyFeatures
:
:
sActiveAndFeatures
(
0
)
;
static
const
char
*
const
kMainThreadName
=
"
GeckoMain
"
;
#
if
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
|
|
\
defined
(
GP_ARCH_x86
)
#
define
UNWINDING_REGS_HAVE_ECX_EDX
#
elif
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_amd64_android
)
|
|
\
defined
(
GP_PLAT_amd64_freebsd
)
|
|
defined
(
GP_ARCH_amd64
)
|
|
\
defined
(
__x86_64__
)
#
define
UNWINDING_REGS_HAVE_R10_R12
#
elif
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
#
define
UNWINDING_REGS_HAVE_LR_R7
#
elif
defined
(
GP_PLAT_arm64_linux
)
|
|
defined
(
GP_PLAT_arm64_android
)
|
|
\
defined
(
GP_PLAT_arm64_freebsd
)
|
|
defined
(
GP_ARCH_arm64
)
|
|
\
defined
(
__aarch64__
)
#
define
UNWINDING_REGS_HAVE_LR_R11
#
endif
class
Registers
{
public
:
Registers
(
)
:
mPC
{
nullptr
}
mSP
{
nullptr
}
mFP
{
nullptr
}
#
if
defined
(
UNWINDING_REGS_HAVE_ECX_EDX
)
mEcx
{
nullptr
}
mEdx
{
nullptr
}
#
elif
defined
(
UNWINDING_REGS_HAVE_R10_R12
)
mR10
{
nullptr
}
mR12
{
nullptr
}
#
elif
defined
(
UNWINDING_REGS_HAVE_LR_R7
)
mLR
{
nullptr
}
mR7
{
nullptr
}
#
elif
defined
(
UNWINDING_REGS_HAVE_LR_R11
)
mLR
{
nullptr
}
mR11
{
nullptr
}
#
endif
{
}
void
Clear
(
)
{
memset
(
this
0
sizeof
(
*
this
)
)
;
}
Address
mPC
;
Address
mSP
;
Address
mFP
;
#
if
defined
(
UNWINDING_REGS_HAVE_ECX_EDX
)
Address
mEcx
;
Address
mEdx
;
#
elif
defined
(
UNWINDING_REGS_HAVE_R10_R12
)
Address
mR10
;
Address
mR12
;
#
elif
defined
(
UNWINDING_REGS_HAVE_LR_R7
)
Address
mLR
;
Address
mR7
;
#
elif
defined
(
UNWINDING_REGS_HAVE_LR_R11
)
Address
mLR
;
Address
mR11
;
#
endif
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
ucontext_t
*
mContext
;
ucontext_t
mContextSyncStorage
;
#
endif
}
;
Atomic
<
bool
>
WALKING_JS_STACK
(
false
)
;
struct
AutoWalkJSStack
{
bool
walkAllowed
;
AutoWalkJSStack
(
)
:
walkAllowed
(
false
)
{
walkAllowed
=
WALKING_JS_STACK
.
compareExchange
(
false
true
)
;
}
~
AutoWalkJSStack
(
)
{
if
(
walkAllowed
)
{
WALKING_JS_STACK
=
false
;
}
}
}
;
class
StackWalkControl
{
public
:
struct
ResumePoint
{
void
*
resumeSp
;
void
*
resumeBp
;
void
*
resumePc
;
}
;
#
if
(
(
defined
(
USE_MOZ_STACK_WALK
)
|
|
defined
(
USE_FRAME_POINTER_STACK_WALK
)
)
&
&
\
defined
(
GP_ARCH_amd64
)
)
public
:
static
constexpr
bool
scIsSupported
=
true
;
void
Clear
(
)
{
mResumePointCount
=
0
;
}
size_t
ResumePointCount
(
)
const
{
return
mResumePointCount
;
}
static
constexpr
size_t
MaxResumePointCount
(
)
{
return
scMaxResumePointCount
;
}
void
AddResumePoint
(
ResumePoint
&
&
aResumePoint
)
{
MOZ_ASSERT_IF
(
!
aResumePoint
.
resumeSp
!
aResumePoint
.
resumeBp
)
;
MOZ_ASSERT_IF
(
!
aResumePoint
.
resumeSp
!
aResumePoint
.
resumePc
)
;
MOZ_ASSERT_IF
(
aResumePoint
.
resumeBp
aResumePoint
.
resumeSp
)
;
MOZ_ASSERT_IF
(
aResumePoint
.
resumePc
aResumePoint
.
resumeSp
)
;
if
(
mResumePointCount
<
scMaxResumePointCount
)
{
mResumePoint
[
mResumePointCount
]
=
std
:
:
move
(
aResumePoint
)
;
+
+
mResumePointCount
;
}
}
const
ResumePoint
*
begin
(
)
const
{
return
&
mResumePoint
[
0
]
;
}
const
ResumePoint
*
end
(
)
const
{
return
&
mResumePoint
[
mResumePointCount
]
;
}
const
ResumePoint
*
GetResumePointCallingSp
(
void
*
aSp
)
const
{
const
ResumePoint
*
callingResumePoint
=
nullptr
;
for
(
const
ResumePoint
&
resumePoint
:
*
this
)
{
if
(
resumePoint
.
resumeSp
&
&
resumePoint
.
resumeSp
>
aSp
&
&
(
!
callingResumePoint
|
|
resumePoint
.
resumeSp
<
callingResumePoint
-
>
resumeSp
)
)
{
callingResumePoint
=
&
resumePoint
;
}
}
return
callingResumePoint
;
}
private
:
size_t
mResumePointCount
=
0
;
static
constexpr
size_t
scMaxResumePointCount
=
32
;
ResumePoint
mResumePoint
[
scMaxResumePointCount
]
;
#
else
public
:
static
constexpr
bool
scIsSupported
=
false
;
void
Clear
(
)
;
size_t
ResumePointCount
(
)
;
static
constexpr
size_t
MaxResumePointCount
(
)
;
void
AddResumePoint
(
ResumePoint
&
&
aResumePoint
)
;
const
ResumePoint
*
begin
(
)
const
;
const
ResumePoint
*
end
(
)
const
;
const
ResumePoint
*
GetResumePointCallingSp
(
void
*
aSp
)
const
;
#
endif
}
;
static
uint32_t
ExtractJsFrames
(
bool
aIsSynchronous
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
ProfilerStackCollector
&
aCollector
JsFrameBuffer
aJsFrames
StackWalkControl
*
aStackWalkControlIfSupported
)
{
MOZ_ASSERT
(
aJsFrames
"
ExtractJsFrames
should
only
be
called
if
there
is
a
"
"
JsFrameBuffer
to
fill
.
"
)
;
uint32_t
jsFramesCount
=
0
;
JSContext
*
context
=
aThreadData
.
GetJSContext
(
)
;
if
(
context
&
&
JS
:
:
IsProfilingEnabledForContext
(
context
)
)
{
AutoWalkJSStack
autoWalkJSStack
;
if
(
autoWalkJSStack
.
walkAllowed
)
{
JS
:
:
ProfilingFrameIterator
:
:
RegisterState
registerState
;
registerState
.
pc
=
aRegs
.
mPC
;
registerState
.
sp
=
aRegs
.
mSP
;
registerState
.
fp
=
aRegs
.
mFP
;
#
if
defined
(
UNWINDING_REGS_HAVE_ECX_EDX
)
registerState
.
tempRA
=
aRegs
.
mEcx
;
registerState
.
tempFP
=
aRegs
.
mEdx
;
#
elif
defined
(
UNWINDING_REGS_HAVE_R10_R12
)
registerState
.
tempRA
=
aRegs
.
mR10
;
registerState
.
tempFP
=
aRegs
.
mR12
;
#
elif
defined
(
UNWINDING_REGS_HAVE_LR_R7
)
registerState
.
lr
=
aRegs
.
mLR
;
registerState
.
tempFP
=
aRegs
.
mR7
;
#
elif
defined
(
UNWINDING_REGS_HAVE_LR_R11
)
registerState
.
lr
=
aRegs
.
mLR
;
registerState
.
tempFP
=
aRegs
.
mR11
;
#
endif
Maybe
<
uint64_t
>
samplePosInBuffer
;
if
(
!
aIsSynchronous
)
{
samplePosInBuffer
=
aCollector
.
SamplePositionInBuffer
(
)
;
}
for
(
JS
:
:
ProfilingFrameIterator
jsIter
(
context
registerState
samplePosInBuffer
)
;
!
jsIter
.
done
(
)
;
+
+
jsIter
)
{
if
(
aIsSynchronous
|
|
jsIter
.
isWasm
(
)
)
{
jsFramesCount
+
=
jsIter
.
extractStack
(
aJsFrames
jsFramesCount
MAX_JS_FRAMES
)
;
if
(
jsFramesCount
=
=
MAX_JS_FRAMES
)
{
break
;
}
}
else
{
Maybe
<
JS
:
:
ProfilingFrameIterator
:
:
Frame
>
frame
=
jsIter
.
getPhysicalFrameWithoutLabel
(
)
;
if
(
frame
.
isSome
(
)
)
{
aJsFrames
[
jsFramesCount
+
+
]
=
std
:
:
move
(
frame
)
.
ref
(
)
;
if
(
jsFramesCount
=
=
MAX_JS_FRAMES
)
{
break
;
}
}
}
if
constexpr
(
StackWalkControl
:
:
scIsSupported
)
{
if
(
aStackWalkControlIfSupported
)
{
jsIter
.
getCppEntryRegisters
(
)
.
apply
(
[
&
]
(
const
JS
:
:
ProfilingFrameIterator
:
:
RegisterState
&
aCppEntry
)
{
StackWalkControl
:
:
ResumePoint
resumePoint
;
resumePoint
.
resumeSp
=
aCppEntry
.
sp
;
resumePoint
.
resumeBp
=
aCppEntry
.
fp
;
resumePoint
.
resumePc
=
aCppEntry
.
pc
;
aStackWalkControlIfSupported
-
>
AddResumePoint
(
std
:
:
move
(
resumePoint
)
)
;
}
)
;
}
}
else
{
MOZ_ASSERT
(
!
aStackWalkControlIfSupported
"
aStackWalkControlIfSupported
should
be
null
when
"
"
!
StackWalkControl
:
:
scIsSupported
"
)
;
(
void
)
aStackWalkControlIfSupported
;
}
}
}
}
return
jsFramesCount
;
}
static
void
MergeStacks
(
bool
aIsSynchronous
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
NativeStack
&
aNativeStack
ProfilerStackCollector
&
aCollector
JsFrame
*
aJsFrames
uint32_t
aJsFramesCount
)
{
MOZ_ASSERT_IF
(
!
aJsFrames
aJsFramesCount
=
=
0
)
;
const
ProfilingStack
&
profilingStack
=
aThreadData
.
ProfilingStackCRef
(
)
;
const
js
:
:
ProfilingStackFrame
*
profilingStackFrames
=
profilingStack
.
frames
;
uint32_t
profilingStackFrameCount
=
profilingStack
.
stackSize
(
)
;
uint32_t
profilingStackIndex
=
0
;
int32_t
jsIndex
=
aJsFramesCount
-
1
;
int32_t
nativeIndex
=
aNativeStack
.
mCount
-
1
;
uint8_t
*
lastLabelFrameStackAddr
=
nullptr
;
uint8_t
*
jitEndStackAddr
=
nullptr
;
while
(
profilingStackIndex
!
=
profilingStackFrameCount
|
|
jsIndex
>
=
0
|
|
nativeIndex
>
=
0
)
{
uint8_t
*
profilingStackAddr
=
nullptr
;
uint8_t
*
jsStackAddr
=
nullptr
;
uint8_t
*
nativeStackAddr
=
nullptr
;
uint8_t
*
jsActivationAddr
=
nullptr
;
if
(
profilingStackIndex
!
=
profilingStackFrameCount
)
{
const
js
:
:
ProfilingStackFrame
&
profilingStackFrame
=
profilingStackFrames
[
profilingStackIndex
]
;
if
(
profilingStackFrame
.
isLabelFrame
(
)
|
|
profilingStackFrame
.
isSpMarkerFrame
(
)
)
{
lastLabelFrameStackAddr
=
(
uint8_t
*
)
profilingStackFrame
.
stackAddress
(
)
;
}
if
(
profilingStackFrame
.
isOSRFrame
(
)
)
{
profilingStackIndex
+
+
;
continue
;
}
MOZ_ASSERT
(
lastLabelFrameStackAddr
)
;
profilingStackAddr
=
lastLabelFrameStackAddr
;
}
if
(
jsIndex
>
=
0
)
{
jsStackAddr
=
(
uint8_t
*
)
aJsFrames
[
jsIndex
]
.
stackAddress
;
jsActivationAddr
=
(
uint8_t
*
)
aJsFrames
[
jsIndex
]
.
activation
;
}
if
(
nativeIndex
>
=
0
)
{
nativeStackAddr
=
(
uint8_t
*
)
aNativeStack
.
mSPs
[
nativeIndex
]
;
}
if
(
nativeStackAddr
&
&
(
profilingStackAddr
=
=
nativeStackAddr
|
|
jsStackAddr
=
=
nativeStackAddr
)
)
{
nativeStackAddr
=
nullptr
;
nativeIndex
-
-
;
MOZ_ASSERT
(
profilingStackAddr
|
|
jsStackAddr
)
;
}
MOZ_ASSERT_IF
(
profilingStackAddr
profilingStackAddr
!
=
jsStackAddr
&
&
profilingStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
jsStackAddr
jsStackAddr
!
=
profilingStackAddr
&
&
jsStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
nativeStackAddr
nativeStackAddr
!
=
profilingStackAddr
&
&
nativeStackAddr
!
=
jsStackAddr
)
;
if
(
profilingStackAddr
>
jsStackAddr
&
&
profilingStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
profilingStackIndex
<
profilingStackFrameCount
)
;
const
js
:
:
ProfilingStackFrame
&
profilingStackFrame
=
profilingStackFrames
[
profilingStackIndex
]
;
if
(
!
profilingStackFrame
.
isSpMarkerFrame
(
)
)
{
MOZ_ASSERT_IF
(
profilingStackFrame
.
isJsFrame
(
)
&
&
profilingStackFrame
.
script
(
)
&
&
!
profilingStackFrame
.
pc
(
)
&
profilingStackFrame
=
=
&
profilingStack
.
frames
[
profilingStack
.
stackSize
(
)
-
1
]
)
;
if
(
aIsSynchronous
&
&
profilingStackFrame
.
categoryPair
(
)
=
=
JS
:
:
ProfilingCategoryPair
:
:
PROFILER
)
{
return
;
}
aCollector
.
CollectProfilingStackFrame
(
profilingStackFrame
)
;
}
profilingStackIndex
+
+
;
continue
;
}
if
(
jsStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
jsIndex
>
=
0
)
;
const
JS
:
:
ProfilingFrameIterator
:
:
Frame
&
jsFrame
=
aJsFrames
[
jsIndex
]
;
jitEndStackAddr
=
(
uint8_t
*
)
jsFrame
.
endStackAddress
;
if
(
aIsSynchronous
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_WasmIon
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_WasmBaseline
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_WasmOther
)
{
aCollector
.
CollectWasmFrame
(
jsFrame
.
profilingCategory
(
)
jsFrame
.
label
)
;
}
else
if
(
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_BaselineInterpreter
)
{
JSScript
*
script
=
jsFrame
.
interpreterScript
;
jsbytecode
*
pc
=
jsFrame
.
interpreterPC
(
)
;
js
:
:
ProfilingStackFrame
stackFrame
;
constexpr
uint32_t
ExtraFlags
=
uint32_t
(
js
:
:
ProfilingStackFrame
:
:
Flags
:
:
IS_BLINTERP_FRAME
)
;
stackFrame
.
initJsFrame
<
JS
:
:
ProfilingCategoryPair
:
:
JS_BaselineInterpret
ExtraFlags
>
(
"
"
jsFrame
.
label
script
pc
jsFrame
.
realmID
)
;
aCollector
.
CollectProfilingStackFrame
(
stackFrame
)
;
}
else
{
MOZ_ASSERT
(
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Ion
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Baseline
)
;
aCollector
.
CollectJitReturnAddr
(
jsFrame
.
returnAddress
(
)
)
;
}
jsIndex
-
-
;
continue
;
}
if
(
nativeStackAddr
&
&
(
!
jitEndStackAddr
|
|
nativeStackAddr
<
jitEndStackAddr
)
&
&
(
!
jsActivationAddr
|
|
nativeStackAddr
>
jsActivationAddr
)
)
{
MOZ_ASSERT
(
nativeIndex
>
=
0
)
;
void
*
addr
=
(
void
*
)
aNativeStack
.
mPCs
[
nativeIndex
]
;
aCollector
.
CollectNativeLeafAddr
(
addr
)
;
}
if
(
nativeIndex
>
=
0
)
{
nativeIndex
-
-
;
}
}
if
(
!
aIsSynchronous
)
{
aCollector
.
BufferRangeStart
(
)
.
apply
(
[
&
aThreadData
]
(
uint64_t
aBufferRangeStart
)
{
JSContext
*
context
=
aThreadData
.
GetJSContext
(
)
;
if
(
context
)
{
JS
:
:
SetJSContextProfilerSampleBufferRangeStart
(
context
aBufferRangeStart
)
;
}
}
)
;
}
}
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
|
|
defined
(
USE_MOZ_STACK_WALK
)
static
void
StackWalkCallback
(
uint32_t
aFrameNumber
void
*
aPC
void
*
aSP
void
*
aClosure
)
{
NativeStack
*
nativeStack
=
static_cast
<
NativeStack
*
>
(
aClosure
)
;
MOZ_ASSERT
(
nativeStack
-
>
mCount
<
MAX_NATIVE_FRAMES
)
;
nativeStack
-
>
mSPs
[
nativeStack
-
>
mCount
]
=
aSP
;
nativeStack
-
>
mPCs
[
nativeStack
-
>
mCount
]
=
aPC
;
nativeStack
-
>
mCount
+
+
;
}
#
endif
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
static
void
DoFramePointerBacktrace
(
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
NativeStack
&
aNativeStack
StackWalkControl
*
aStackWalkControlIfSupported
)
{
Registers
regs
=
aRegs
;
StackWalkCallback
(
0
regs
.
mPC
regs
.
mSP
&
aNativeStack
)
;
const
void
*
const
stackEnd
=
aThreadData
.
StackTop
(
)
;
void
*
previousResumeSp
=
nullptr
;
for
(
;
;
)
{
if
(
!
(
regs
.
mSP
&
&
regs
.
mSP
<
=
regs
.
mFP
&
&
regs
.
mFP
<
=
stackEnd
)
)
{
break
;
}
FramePointerStackWalk
(
StackWalkCallback
uint32_t
(
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
&
aNativeStack
reinterpret_cast
<
void
*
*
>
(
regs
.
mFP
)
const_cast
<
void
*
>
(
stackEnd
)
)
;
if
constexpr
(
!
StackWalkControl
:
:
scIsSupported
)
{
break
;
}
else
{
if
(
aNativeStack
.
mCount
>
=
MAX_NATIVE_FRAMES
)
{
break
;
}
if
(
!
aStackWalkControlIfSupported
|
|
aStackWalkControlIfSupported
-
>
ResumePointCount
(
)
=
=
0
)
{
break
;
}
void
*
lastSP
=
aNativeStack
.
mSPs
[
aNativeStack
.
mCount
-
1
]
;
if
(
previousResumeSp
&
&
(
(
uintptr_t
)
lastSP
<
=
(
uintptr_t
)
previousResumeSp
)
)
{
break
;
}
const
StackWalkControl
:
:
ResumePoint
*
resumePoint
=
aStackWalkControlIfSupported
-
>
GetResumePointCallingSp
(
lastSP
)
;
if
(
!
resumePoint
)
{
break
;
}
void
*
sp
=
resumePoint
-
>
resumeSp
;
if
(
!
sp
)
{
break
;
}
void
*
pc
=
resumePoint
-
>
resumePc
;
StackWalkCallback
(
aNativeStack
.
mCount
pc
sp
&
aNativeStack
)
;
+
+
aNativeStack
.
mCount
;
if
(
aNativeStack
.
mCount
>
=
MAX_NATIVE_FRAMES
)
{
break
;
}
regs
.
mPC
=
(
Address
)
pc
;
regs
.
mSP
=
(
Address
)
sp
;
regs
.
mFP
=
(
Address
)
resumePoint
-
>
resumeBp
;
previousResumeSp
=
sp
;
}
}
}
#
endif
#
if
defined
(
USE_MOZ_STACK_WALK
)
static
void
DoMozStackWalkBacktrace
(
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
NativeStack
&
aNativeStack
StackWalkControl
*
aStackWalkControlIfSupported
)
{
StackWalkCallback
(
0
aRegs
.
mPC
aRegs
.
mSP
&
aNativeStack
)
;
HANDLE
thread
=
aThreadData
.
PlatformDataCRef
(
)
.
ProfiledThread
(
)
;
MOZ_ASSERT
(
thread
)
;
CONTEXT
context_buf
;
CONTEXT
*
context
=
nullptr
;
if
constexpr
(
StackWalkControl
:
:
scIsSupported
)
{
context
=
&
context_buf
;
memset
(
&
context_buf
0
sizeof
(
CONTEXT
)
)
;
context_buf
.
ContextFlags
=
CONTEXT_FULL
;
#
if
defined
(
_M_AMD64
)
context_buf
.
Rsp
=
(
DWORD64
)
aRegs
.
mSP
;
context_buf
.
Rbp
=
(
DWORD64
)
aRegs
.
mFP
;
context_buf
.
Rip
=
(
DWORD64
)
aRegs
.
mPC
;
#
else
static_assert
(
!
StackWalkControl
:
:
scIsSupported
"
Mismatched
support
between
StackWalkControl
and
"
"
DoMozStackWalkBacktrace
"
)
;
#
endif
}
else
{
context
=
nullptr
;
}
void
*
previousResumeSp
=
nullptr
;
for
(
;
;
)
{
MozStackWalkThread
(
StackWalkCallback
uint32_t
(
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
&
aNativeStack
thread
context
)
;
if
constexpr
(
!
StackWalkControl
:
:
scIsSupported
)
{
break
;
}
else
{
if
(
aNativeStack
.
mCount
>
=
MAX_NATIVE_FRAMES
)
{
break
;
}
if
(
!
aStackWalkControlIfSupported
|
|
aStackWalkControlIfSupported
-
>
ResumePointCount
(
)
=
=
0
)
{
break
;
}
void
*
lastSP
=
aNativeStack
.
mSPs
[
aNativeStack
.
mCount
-
1
]
;
if
(
previousResumeSp
&
&
(
(
uintptr_t
)
lastSP
<
=
(
uintptr_t
)
previousResumeSp
)
)
{
break
;
}
const
StackWalkControl
:
:
ResumePoint
*
resumePoint
=
aStackWalkControlIfSupported
-
>
GetResumePointCallingSp
(
lastSP
)
;
if
(
!
resumePoint
)
{
break
;
}
void
*
sp
=
resumePoint
-
>
resumeSp
;
if
(
!
sp
)
{
break
;
}
void
*
pc
=
resumePoint
-
>
resumePc
;
StackWalkCallback
(
aNativeStack
.
mCount
pc
sp
&
aNativeStack
)
;
+
+
aNativeStack
.
mCount
;
if
(
aNativeStack
.
mCount
>
=
MAX_NATIVE_FRAMES
)
{
break
;
}
memset
(
&
context_buf
0
sizeof
(
CONTEXT
)
)
;
context_buf
.
ContextFlags
=
CONTEXT_FULL
;
#
if
defined
(
_M_AMD64
)
context_buf
.
Rsp
=
(
DWORD64
)
sp
;
context_buf
.
Rbp
=
(
DWORD64
)
resumePoint
-
>
resumeBp
;
context_buf
.
Rip
=
(
DWORD64
)
pc
;
#
else
static_assert
(
!
StackWalkControl
:
:
scIsSupported
"
Mismatched
support
between
StackWalkControl
and
"
"
DoMozStackWalkBacktrace
"
)
;
#
endif
previousResumeSp
=
sp
;
}
}
}
#
endif
#
ifdef
USE_EHABI_STACKWALK
static
void
DoEHABIBacktrace
(
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
NativeStack
&
aNativeStack
StackWalkControl
*
aStackWalkControlIfSupported
)
{
aNativeStack
.
mCount
=
EHABIStackWalk
(
aRegs
.
mContext
-
>
uc_mcontext
const_cast
<
void
*
>
(
aThreadData
.
StackTop
(
)
)
aNativeStack
.
mSPs
aNativeStack
.
mPCs
MAX_NATIVE_FRAMES
)
;
(
void
)
aStackWalkControlIfSupported
;
}
#
endif
#
ifdef
USE_LUL_STACKWALK
#
if
defined
(
MOZ_HAVE_ASAN_IGNORE
)
MOZ_ASAN_IGNORE
static
void
ASAN_memcpy
(
void
*
aDst
const
void
*
aSrc
size_t
aLen
)
{
char
*
dst
=
static_cast
<
char
*
>
(
aDst
)
;
const
char
*
src
=
static_cast
<
const
char
*
>
(
aSrc
)
;
for
(
size_t
i
=
0
;
i
<
aLen
;
i
+
+
)
{
dst
[
i
]
=
src
[
i
]
;
}
}
#
endif
static
void
DoLULBacktrace
(
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
NativeStack
&
aNativeStack
StackWalkControl
*
aStackWalkControlIfSupported
)
{
(
void
)
aStackWalkControlIfSupported
;
const
mcontext_t
*
mc
=
&
aRegs
.
mContext
-
>
uc_mcontext
;
lul
:
:
UnwindRegs
startRegs
;
memset
(
&
startRegs
0
sizeof
(
startRegs
)
)
;
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_amd64_android
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RSP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RBP
]
)
;
#
elif
defined
(
GP_PLAT_amd64_freebsd
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_rip
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_rsp
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_rbp
)
;
#
elif
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
startRegs
.
r15
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_pc
)
;
startRegs
.
r14
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_lr
)
;
startRegs
.
r13
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_sp
)
;
startRegs
.
r12
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_ip
)
;
startRegs
.
r11
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_fp
)
;
startRegs
.
r7
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_r7
)
;
#
elif
defined
(
GP_PLAT_arm64_linux
)
|
|
defined
(
GP_PLAT_arm64_android
)
startRegs
.
pc
=
lul
:
:
TaggedUWord
(
mc
-
>
pc
)
;
startRegs
.
x29
=
lul
:
:
TaggedUWord
(
mc
-
>
regs
[
29
]
)
;
startRegs
.
x30
=
lul
:
:
TaggedUWord
(
mc
-
>
regs
[
30
]
)
;
startRegs
.
sp
=
lul
:
:
TaggedUWord
(
mc
-
>
sp
)
;
#
elif
defined
(
GP_PLAT_arm64_freebsd
)
startRegs
.
pc
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_gpregs
.
gp_elr
)
;
startRegs
.
x29
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_gpregs
.
gp_x
[
29
]
)
;
startRegs
.
x30
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_gpregs
.
gp_lr
)
;
startRegs
.
sp
=
lul
:
:
TaggedUWord
(
mc
-
>
mc_gpregs
.
gp_sp
)
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_ESP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EBP
]
)
;
#
elif
defined
(
GP_PLAT_mips64_linux
)
startRegs
.
pc
=
lul
:
:
TaggedUWord
(
mc
-
>
pc
)
;
startRegs
.
sp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
29
]
)
;
startRegs
.
fp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
30
]
)
;
#
else
#
error
"
Unknown
plat
"
#
endif
lul
:
:
StackImage
stackImg
;
{
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
defined
(
GP_PLAT_amd64_android
)
|
|
\
defined
(
GP_PLAT_amd64_freebsd
)
uintptr_t
rEDZONE_SIZE
=
128
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
r13
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_arm64_linux
)
|
|
defined
(
GP_PLAT_arm64_android
)
|
|
\
defined
(
GP_PLAT_arm64_freebsd
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
sp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_mips64_linux
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
sp
.
Value
(
)
-
rEDZONE_SIZE
;
#
else
#
error
"
Unknown
plat
"
#
endif
uintptr_t
end
=
reinterpret_cast
<
uintptr_t
>
(
aThreadData
.
StackTop
(
)
)
;
uintptr_t
ws
=
sizeof
(
void
*
)
;
start
&
=
~
(
ws
-
1
)
;
end
&
=
~
(
ws
-
1
)
;
uintptr_t
nToCopy
=
0
;
if
(
start
<
end
)
{
nToCopy
=
end
-
start
;
if
(
nToCopy
>
=
1024u
*
1024u
)
{
nToCopy
=
0
;
}
else
if
(
nToCopy
>
lul
:
:
N_STACK_BYTES
)
{
nToCopy
=
lul
:
:
N_STACK_BYTES
;
}
}
MOZ_ASSERT
(
nToCopy
<
=
lul
:
:
N_STACK_BYTES
)
;
stackImg
.
mLen
=
nToCopy
;
stackImg
.
mStartAvma
=
start
;
if
(
nToCopy
>
0
)
{
#
if
defined
(
MOZ_HAVE_ASAN_IGNORE
)
ASAN_memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
#
else
memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
#
endif
(
void
)
VALGRIND_MAKE_MEM_DEFINED
(
&
stackImg
.
mContents
[
0
]
nToCopy
)
;
}
}
size_t
framePointerFramesAcquired
=
0
;
lul
:
:
LUL
*
lul
=
CorePS
:
:
Lul
(
)
;
MOZ_RELEASE_ASSERT
(
lul
)
;
lul
-
>
Unwind
(
reinterpret_cast
<
uintptr_t
*
>
(
aNativeStack
.
mPCs
)
reinterpret_cast
<
uintptr_t
*
>
(
aNativeStack
.
mSPs
)
&
aNativeStack
.
mCount
&
framePointerFramesAcquired
MAX_NATIVE_FRAMES
&
startRegs
&
stackImg
)
;
lul
-
>
mStats
.
mContext
+
=
1
;
lul
-
>
mStats
.
mCFI
+
=
aNativeStack
.
mCount
-
1
-
framePointerFramesAcquired
;
lul
-
>
mStats
.
mFP
+
=
framePointerFramesAcquired
;
}
#
endif
#
ifdef
HAVE_NATIVE_UNWIND
static
void
DoNativeBacktrace
(
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
NativeStack
&
aNativeStack
StackWalkControl
*
aStackWalkControlIfSupported
)
{
#
if
defined
(
USE_LUL_STACKWALK
)
DoLULBacktrace
(
aThreadData
aRegs
aNativeStack
aStackWalkControlIfSupported
)
;
#
elif
defined
(
USE_EHABI_STACKWALK
)
DoEHABIBacktrace
(
aThreadData
aRegs
aNativeStack
aStackWalkControlIfSupported
)
;
#
elif
defined
(
USE_FRAME_POINTER_STACK_WALK
)
DoFramePointerBacktrace
(
aThreadData
aRegs
aNativeStack
aStackWalkControlIfSupported
)
;
#
elif
defined
(
USE_MOZ_STACK_WALK
)
DoMozStackWalkBacktrace
(
aThreadData
aRegs
aNativeStack
aStackWalkControlIfSupported
)
;
#
else
#
error
"
Invalid
configuration
"
#
endif
}
void
DoNativeBacktraceDirect
(
const
void
*
stackTop
NativeStack
&
aNativeStack
StackWalkControl
*
aStackWalkControlIfSupported
)
{
#
if
defined
(
MOZ_PROFILING
)
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
|
|
defined
(
USE_MOZ_STACK_WALK
)
void
*
previousResumeSp
=
nullptr
;
for
(
;
;
)
{
MozStackWalk
(
StackWalkCallback
stackTop
uint32_t
(
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
&
aNativeStack
)
;
if
constexpr
(
!
StackWalkControl
:
:
scIsSupported
)
{
break
;
}
else
{
if
(
aNativeStack
.
mCount
>
=
MAX_NATIVE_FRAMES
)
{
break
;
}
if
(
!
aStackWalkControlIfSupported
|
|
aStackWalkControlIfSupported
-
>
ResumePointCount
(
)
=
=
0
)
{
break
;
}
void
*
lastSP
=
aNativeStack
.
mSPs
[
aNativeStack
.
mCount
-
1
]
;
if
(
previousResumeSp
&
&
(
(
uintptr_t
)
lastSP
<
=
(
uintptr_t
)
previousResumeSp
)
)
{
break
;
}
const
StackWalkControl
:
:
ResumePoint
*
resumePoint
=
aStackWalkControlIfSupported
-
>
GetResumePointCallingSp
(
lastSP
)
;
if
(
!
resumePoint
)
{
break
;
}
void
*
sp
=
resumePoint
-
>
resumeSp
;
if
(
!
sp
)
{
break
;
}
void
*
pc
=
resumePoint
-
>
resumePc
;
StackWalkCallback
(
aNativeStack
.
mCount
pc
sp
&
aNativeStack
)
;
+
+
aNativeStack
.
mCount
;
if
(
aNativeStack
.
mCount
>
=
MAX_NATIVE_FRAMES
)
{
break
;
}
previousResumeSp
=
sp
;
}
}
#
else
MOZ_CRASH
(
"
Cannot
call
DoNativeBacktraceDirect
without
either
"
"
USE_FRAME_POINTER_STACK_WALK
USE_MOZ_STACK_WALK
"
)
;
#
endif
#
else
aNativeStack
.
mCount
=
0
;
#
endif
}
#
endif
static
inline
void
DoSharedSample
(
bool
aIsSynchronous
uint32_t
aFeatures
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
JsFrame
*
aJsFrames
const
Registers
&
aRegs
uint64_t
aSamplePos
uint64_t
aBufferRangeStart
ProfileBuffer
&
aBuffer
StackCaptureOptions
aCaptureOptions
=
StackCaptureOptions
:
:
Full
)
{
MOZ_ASSERT
(
!
aBuffer
.
IsThreadSafe
(
)
"
Mutexes
cannot
be
used
inside
this
critical
section
"
)
;
ProfileBufferCollector
collector
(
aBuffer
aSamplePos
aBufferRangeStart
)
;
StackWalkControl
*
stackWalkControlIfSupported
=
nullptr
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
const
bool
captureNative
=
ProfilerFeature
:
:
HasStackWalk
(
aFeatures
)
&
&
aCaptureOptions
=
=
StackCaptureOptions
:
:
Full
;
StackWalkControl
stackWalkControl
;
if
constexpr
(
StackWalkControl
:
:
scIsSupported
)
{
if
(
captureNative
)
{
stackWalkControlIfSupported
=
&
stackWalkControl
;
}
}
#
endif
const
uint32_t
jsFramesCount
=
aJsFrames
?
ExtractJsFrames
(
aIsSynchronous
aThreadData
aRegs
collector
aJsFrames
stackWalkControlIfSupported
)
:
0
;
NativeStack
nativeStack
{
.
mCount
=
0
}
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
if
(
captureNative
)
{
DoNativeBacktrace
(
aThreadData
aRegs
nativeStack
stackWalkControlIfSupported
)
;
MergeStacks
(
aIsSynchronous
aThreadData
nativeStack
collector
aJsFrames
jsFramesCount
)
;
}
else
#
endif
{
MergeStacks
(
aIsSynchronous
aThreadData
nativeStack
collector
aJsFrames
jsFramesCount
)
;
if
(
aCaptureOptions
=
=
StackCaptureOptions
:
:
Full
)
{
aBuffer
.
AddEntry
(
ProfileBufferEntry
:
:
NativeLeafAddr
(
(
void
*
)
aRegs
.
mPC
)
)
;
}
}
}
static
void
DoSyncSample
(
uint32_t
aFeatures
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
TimeStamp
&
aNow
const
Registers
&
aRegs
ProfileBuffer
&
aBuffer
StackCaptureOptions
aCaptureOptions
)
{
MOZ_ASSERT
(
aCaptureOptions
!
=
StackCaptureOptions
:
:
NoStack
"
DoSyncSample
should
not
be
called
when
no
capture
is
needed
"
)
;
const
uint64_t
bufferRangeStart
=
aBuffer
.
BufferRangeStart
(
)
;
const
uint64_t
samplePos
=
aBuffer
.
AddThreadIdEntry
(
aThreadData
.
Info
(
)
.
ThreadId
(
)
)
;
TimeDuration
delta
=
aNow
-
CorePS
:
:
ProcessStartTime
(
)
;
aBuffer
.
AddEntry
(
ProfileBufferEntry
:
:
Time
(
delta
.
ToMilliseconds
(
)
)
)
;
if
(
!
aThreadData
.
GetJSContext
(
)
)
{
DoSharedSample
(
true
aFeatures
aThreadData
nullptr
aRegs
samplePos
bufferRangeStart
aBuffer
aCaptureOptions
)
;
}
else
{
ThreadRegistration
:
:
WithOnThreadRef
(
[
&
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
aOnThreadRef
.
WithConstLockedRWOnThread
(
[
&
]
(
const
ThreadRegistration
:
:
LockedRWOnThread
&
aLockedThreadData
)
{
DoSharedSample
(
true
aFeatures
aThreadData
aLockedThreadData
.
GetJsFrameBuffer
(
)
aRegs
samplePos
bufferRangeStart
aBuffer
aCaptureOptions
)
;
}
)
;
}
)
;
}
}
static
inline
void
DoPeriodicSample
(
PSLockRef
aLock
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
Registers
&
aRegs
uint64_t
aSamplePos
uint64_t
aBufferRangeStart
ProfileBuffer
&
aBuffer
)
{
MOZ_RELEASE_ASSERT
(
ActivePS
:
:
Exists
(
aLock
)
)
;
JsFrameBuffer
&
jsFrames
=
CorePS
:
:
JsFrames
(
aLock
)
;
DoSharedSample
(
false
ActivePS
:
:
Features
(
aLock
)
aThreadData
jsFrames
aRegs
aSamplePos
aBufferRangeStart
aBuffer
)
;
}
#
undef
UNWINDING_REGS_HAVE_ECX_EDX
#
undef
UNWINDING_REGS_HAVE_R10_R12
#
undef
UNWINDING_REGS_HAVE_LR_R7
#
undef
UNWINDING_REGS_HAVE_LR_R11
const
static
uint64_t
kJS_MAX_SAFE_UINTEGER
=
+
9007199254740991ULL
;
static
int64_t
SafeJSInteger
(
uint64_t
aValue
)
{
return
aValue
<
=
kJS_MAX_SAFE_UINTEGER
?
int64_t
(
aValue
)
:
-
1
;
}
static
void
AddSharedLibraryInfoToStream
(
JSONWriter
&
aWriter
const
SharedLibrary
&
aLib
)
{
aWriter
.
StartObjectElement
(
)
;
aWriter
.
IntProperty
(
"
start
"
SafeJSInteger
(
aLib
.
GetStart
(
)
)
)
;
aWriter
.
IntProperty
(
"
end
"
SafeJSInteger
(
aLib
.
GetEnd
(
)
)
)
;
aWriter
.
IntProperty
(
"
offset
"
SafeJSInteger
(
aLib
.
GetOffset
(
)
)
)
;
aWriter
.
StringProperty
(
"
name
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetModuleName
(
)
)
)
;
aWriter
.
StringProperty
(
"
path
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetModulePath
(
)
)
)
;
aWriter
.
StringProperty
(
"
debugName
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetDebugName
(
)
)
)
;
aWriter
.
StringProperty
(
"
debugPath
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetDebugPath
(
)
)
)
;
aWriter
.
StringProperty
(
"
breakpadId
"
aLib
.
GetBreakpadId
(
)
)
;
aWriter
.
StringProperty
(
"
codeId
"
aLib
.
GetCodeId
(
)
)
;
aWriter
.
StringProperty
(
"
arch
"
aLib
.
GetArch
(
)
)
;
aWriter
.
EndObject
(
)
;
}
void
AppendSharedLibraries
(
JSONWriter
&
aWriter
const
SharedLibraryInfo
&
aInfo
)
{
for
(
size_t
i
=
0
;
i
<
aInfo
.
GetSize
(
)
;
i
+
+
)
{
AddSharedLibraryInfoToStream
(
aWriter
aInfo
.
GetEntry
(
i
)
)
;
}
}
static
void
StreamCategories
(
SpliceableJSONWriter
&
aWriter
)
{
#
define
CATEGORY_JSON_BEGIN_CATEGORY
(
name
labelAsString
color
)
\
aWriter
.
Start
(
)
;
\
aWriter
.
StringProperty
(
"
name
"
labelAsString
)
;
\
aWriter
.
StringProperty
(
"
color
"
color
)
;
\
aWriter
.
StartArrayProperty
(
"
subcategories
"
)
;
#
define
CATEGORY_JSON_SUBCATEGORY
(
supercategory
name
labelAsString
)
\
aWriter
.
StringElement
(
labelAsString
)
;
#
define
CATEGORY_JSON_END_CATEGORY
\
aWriter
.
EndArray
(
)
;
\
aWriter
.
EndObject
(
)
;
MOZ_PROFILING_CATEGORY_LIST
(
CATEGORY_JSON_BEGIN_CATEGORY
CATEGORY_JSON_SUBCATEGORY
CATEGORY_JSON_END_CATEGORY
)
#
undef
CATEGORY_JSON_BEGIN_CATEGORY
#
undef
CATEGORY_JSON_SUBCATEGORY
#
undef
CATEGORY_JSON_END_CATEGORY
}
static
void
StreamMarkerSchema
(
SpliceableJSONWriter
&
aWriter
)
{
base_profiler_markers_detail
:
:
Streaming
:
:
LockedMarkerTypeFunctionsList
markerTypeFunctionsArray
;
std
:
:
set
<
std
:
:
string
>
names
;
for
(
const
auto
&
markerTypeFunctions
:
markerTypeFunctionsArray
)
{
auto
name
=
markerTypeFunctions
.
mMarkerTypeNameFunction
(
)
;
const
bool
didInsert
=
names
.
insert
(
std
:
:
string
(
name
.
data
(
)
name
.
size
(
)
)
)
.
second
;
if
(
didInsert
)
{
markerTypeFunctions
.
mMarkerSchemaFunction
(
)
.
Stream
(
aWriter
name
)
;
}
}
profiler
:
:
ffi
:
:
gecko_profiler_stream_marker_schemas
(
&
aWriter
static_cast
<
void
*
>
(
&
names
)
)
;
}
struct
PreRecordedMetaInformation
{
bool
mAsyncStacks
;
nsAutoCString
mHttpPlatform
;
nsAutoCString
mHttpOscpu
;
nsAutoCString
mHttpMisc
;
nsAutoCString
mRuntimeABI
;
nsAutoCString
mRuntimeToolkit
;
nsAutoCString
mAppInfoProduct
;
nsAutoCString
mAppInfoAppBuildID
;
nsAutoCString
mAppInfoSourceURL
;
int32_t
mProcessInfoCpuCount
;
int32_t
mProcessInfoCpuCores
;
nsAutoCString
mProcessInfoCpuName
;
}
;
static
PreRecordedMetaInformation
PreRecordMetaInformation
(
bool
aShutdown
=
false
)
{
MOZ_ASSERT
(
!
PSAutoLock
:
:
IsLockedOnCurrentThread
(
)
)
;
PreRecordedMetaInformation
info
=
{
}
;
if
(
!
NS_IsMainThread
(
)
)
{
return
info
;
}
info
.
mAsyncStacks
=
!
aShutdown
&
&
Preferences
:
:
GetBool
(
"
javascript
.
options
.
asyncstack
"
)
;
nsresult
res
;
if
(
nsCOMPtr
<
nsIHttpProtocolHandler
>
http
=
do_GetService
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
"
http
"
&
res
)
;
!
NS_FAILED
(
res
)
&
&
http
)
{
Unused
<
<
http
-
>
GetPlatform
(
info
.
mHttpPlatform
)
;
#
if
defined
(
XP_MACOSX
)
int
major
=
0
;
int
minor
=
0
;
int
bugfix
=
0
;
nsCocoaFeatures
:
:
GetSystemVersion
(
major
minor
bugfix
)
;
if
(
major
!
=
0
)
{
info
.
mHttpOscpu
.
AppendLiteral
(
"
macOS
"
)
;
info
.
mHttpOscpu
.
AppendInt
(
major
)
;
info
.
mHttpOscpu
.
AppendLiteral
(
"
.
"
)
;
info
.
mHttpOscpu
.
AppendInt
(
minor
)
;
info
.
mHttpOscpu
.
AppendLiteral
(
"
.
"
)
;
info
.
mHttpOscpu
.
AppendInt
(
bugfix
)
;
}
else
#
endif
#
if
defined
(
GP_OS_windows
)
OSVERSIONINFO
ovi
=
{
sizeof
(
OSVERSIONINFO
)
}
;
if
(
GetVersionEx
(
&
ovi
)
)
{
info
.
mHttpOscpu
.
AppendLiteral
(
"
Windows
"
)
;
info
.
mHttpOscpu
.
AppendInt
(
ovi
.
dwBuildNumber
>
=
22000
?
11
:
int32_t
(
ovi
.
dwMajorVersion
)
)
;
info
.
mHttpOscpu
.
AppendLiteral
(
"
.
"
)
;
info
.
mHttpOscpu
.
AppendInt
(
int32_t
(
ovi
.
dwMinorVersion
)
)
;
#
if
defined
(
_ARM64_
)
info
.
mHttpOscpu
.
AppendLiteral
(
"
Arm64
"
)
;
#
endif
info
.
mHttpOscpu
.
AppendLiteral
(
"
;
build
=
"
)
;
info
.
mHttpOscpu
.
AppendInt
(
int32_t
(
ovi
.
dwBuildNumber
)
)
;
}
else
#
endif
{
Unused
<
<
http
-
>
GetOscpu
(
info
.
mHttpOscpu
)
;
}
info
.
mHttpMisc
.
AssignLiteral
(
"
rv
:
"
)
;
info
.
mHttpMisc
.
AppendLiteral
(
MOZILLA_UAVERSION
)
;
}
if
(
nsCOMPtr
<
nsIXULRuntime
>
runtime
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
runtime
)
{
Unused
<
<
runtime
-
>
GetXPCOMABI
(
info
.
mRuntimeABI
)
;
Unused
<
<
runtime
-
>
GetWidgetToolkit
(
info
.
mRuntimeToolkit
)
;
}
if
(
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
)
;
appInfo
)
{
Unused
<
<
appInfo
-
>
GetName
(
info
.
mAppInfoProduct
)
;
Unused
<
<
appInfo
-
>
GetAppBuildID
(
info
.
mAppInfoAppBuildID
)
;
Unused
<
<
appInfo
-
>
GetSourceURL
(
info
.
mAppInfoSourceURL
)
;
}
ProcessInfo
processInfo
=
{
}
;
if
(
NS_SUCCEEDED
(
CollectProcessInfo
(
processInfo
)
)
)
{
info
.
mProcessInfoCpuCount
=
processInfo
.
cpuCount
;
info
.
mProcessInfoCpuCores
=
processInfo
.
cpuCores
;
info
.
mProcessInfoCpuName
=
processInfo
.
cpuName
;
}
return
info
;
}
static
void
StreamMetaPlatformSampleUnits
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
)
;
static
void
StreamMetaJSCustomObject
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
bool
aIsShuttingDown
const
PreRecordedMetaInformation
&
aPreRecordedMetaInformation
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
aWriter
.
IntProperty
(
"
version
"
GECKO_PROFILER_FORMAT_VERSION
)
;
TimeDuration
delta
=
TimeStamp
:
:
Now
(
)
-
CorePS
:
:
ProcessStartTime
(
)
;
aWriter
.
DoubleProperty
(
"
startTime
"
static_cast
<
double
>
(
PR_Now
(
)
/
1000
.
0
-
delta
.
ToMilliseconds
(
)
)
)
;
aWriter
.
DoubleProperty
(
"
profilingStartTime
"
(
ActivePS
:
:
ProfilingStartTime
(
)
-
CorePS
:
:
ProcessStartTime
(
)
)
.
ToMilliseconds
(
)
)
;
if
(
const
TimeStamp
contentEarliestTime
=
ActivePS
:
:
Buffer
(
aLock
)
.
UnderlyingChunkedBuffer
(
)
.
GetEarliestChunkStartTimeStamp
(
)
;
!
contentEarliestTime
.
IsNull
(
)
)
{
aWriter
.
DoubleProperty
(
"
contentEarliestTime
"
(
contentEarliestTime
-
CorePS
:
:
ProcessStartTime
(
)
)
.
ToMilliseconds
(
)
)
;
}
else
{
aWriter
.
NullProperty
(
"
contentEarliestTime
"
)
;
}
const
double
profilingEndTime
=
profiler_time
(
)
;
aWriter
.
DoubleProperty
(
"
profilingEndTime
"
profilingEndTime
)
;
if
(
aIsShuttingDown
)
{
aWriter
.
DoubleProperty
(
"
shutdownTime
"
profilingEndTime
)
;
}
else
{
aWriter
.
NullProperty
(
"
shutdownTime
"
)
;
}
aWriter
.
StartArrayProperty
(
"
categories
"
)
;
StreamCategories
(
aWriter
)
;
aWriter
.
EndArray
(
)
;
aWriter
.
StartArrayProperty
(
"
markerSchema
"
)
;
StreamMarkerSchema
(
aWriter
)
;
aWriter
.
EndArray
(
)
;
ActivePS
:
:
WriteActiveConfiguration
(
aLock
aWriter
MakeStringSpan
(
"
configuration
"
)
)
;
aWriter
.
DoubleProperty
(
"
interval
"
ActivePS
:
:
Interval
(
aLock
)
)
;
aWriter
.
IntProperty
(
"
stackwalk
"
ActivePS
:
:
FeatureStackWalk
(
aLock
)
)
;
#
ifdef
DEBUG
aWriter
.
IntProperty
(
"
debug
"
1
)
;
#
else
aWriter
.
IntProperty
(
"
debug
"
0
)
;
#
endif
aWriter
.
IntProperty
(
"
gcpoison
"
JS
:
:
IsGCPoisoning
(
)
?
1
:
0
)
;
aWriter
.
IntProperty
(
"
asyncstack
"
aPreRecordedMetaInformation
.
mAsyncStacks
)
;
aWriter
.
IntProperty
(
"
processType
"
XRE_GetProcessType
(
)
)
;
aWriter
.
StringProperty
(
"
updateChannel
"
MOZ_STRINGIFY
(
MOZ_UPDATE_CHANNEL
)
)
;
if
(
!
aPreRecordedMetaInformation
.
mHttpPlatform
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
platform
"
aPreRecordedMetaInformation
.
mHttpPlatform
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mHttpOscpu
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
oscpu
"
aPreRecordedMetaInformation
.
mHttpOscpu
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mHttpMisc
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
misc
"
aPreRecordedMetaInformation
.
mHttpMisc
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mRuntimeABI
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
abi
"
aPreRecordedMetaInformation
.
mRuntimeABI
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mRuntimeToolkit
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
toolkit
"
aPreRecordedMetaInformation
.
mRuntimeToolkit
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mAppInfoProduct
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
product
"
aPreRecordedMetaInformation
.
mAppInfoProduct
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mAppInfoAppBuildID
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
appBuildID
"
aPreRecordedMetaInformation
.
mAppInfoAppBuildID
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mAppInfoSourceURL
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
sourceURL
"
aPreRecordedMetaInformation
.
mAppInfoSourceURL
)
;
}
if
(
!
aPreRecordedMetaInformation
.
mProcessInfoCpuName
.
IsEmpty
(
)
)
{
aWriter
.
StringProperty
(
"
CPUName
"
aPreRecordedMetaInformation
.
mProcessInfoCpuName
)
;
}
if
(
aPreRecordedMetaInformation
.
mProcessInfoCpuCores
>
0
)
{
aWriter
.
IntProperty
(
"
physicalCPUs
"
aPreRecordedMetaInformation
.
mProcessInfoCpuCores
)
;
}
if
(
aPreRecordedMetaInformation
.
mProcessInfoCpuCount
>
0
)
{
aWriter
.
IntProperty
(
"
logicalCPUs
"
aPreRecordedMetaInformation
.
mProcessInfoCpuCount
)
;
}
#
if
defined
(
GP_OS_android
)
jni
:
:
String
:
:
LocalRef
deviceInformation
=
java
:
:
GeckoJavaSampler
:
:
GetDeviceInformation
(
)
;
aWriter
.
StringProperty
(
"
device
"
deviceInformation
-
>
ToCString
(
)
)
;
#
endif
aWriter
.
StartObjectProperty
(
"
sampleUnits
"
)
;
{
aWriter
.
StringProperty
(
"
time
"
"
ms
"
)
;
aWriter
.
StringProperty
(
"
eventDelay
"
"
ms
"
)
;
StreamMetaPlatformSampleUnits
(
aLock
aWriter
)
;
}
aWriter
.
EndObject
(
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
if
(
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
)
{
aWriter
.
StartObjectProperty
(
"
extensions
"
)
;
{
{
JSONSchemaWriter
schema
(
aWriter
)
;
schema
.
WriteField
(
"
id
"
)
;
schema
.
WriteField
(
"
name
"
)
;
schema
.
WriteField
(
"
baseURL
"
)
;
}
aWriter
.
StartArrayProperty
(
"
data
"
)
;
{
nsTArray
<
RefPtr
<
WebExtensionPolicy
>
>
exts
;
ExtensionPolicyService
:
:
GetSingleton
(
)
.
GetAll
(
exts
)
;
for
(
auto
&
ext
:
exts
)
{
aWriter
.
StartArrayElement
(
)
;
nsAutoString
id
;
ext
-
>
GetId
(
id
)
;
aWriter
.
StringElement
(
NS_ConvertUTF16toUTF8
(
id
)
)
;
aWriter
.
StringElement
(
NS_ConvertUTF16toUTF8
(
ext
-
>
Name
(
)
)
)
;
auto
url
=
ext
-
>
GetURL
(
u
"
"
_ns
)
;
if
(
url
.
isOk
(
)
)
{
aWriter
.
StringElement
(
NS_ConvertUTF16toUTF8
(
url
.
unwrap
(
)
)
)
;
}
aWriter
.
EndArray
(
)
;
}
}
aWriter
.
EndArray
(
)
;
}
aWriter
.
EndObject
(
)
;
}
}
static
void
StreamPages
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
ActivePS
:
:
DiscardExpiredPages
(
aLock
)
;
for
(
const
auto
&
page
:
ActivePS
:
:
ProfiledPages
(
aLock
)
)
{
page
-
>
StreamJSON
(
aWriter
)
;
}
}
#
if
defined
(
GP_OS_android
)
template
<
int
N
>
static
bool
StartsWith
(
const
nsACString
&
string
const
char
(
&
prefix
)
[
N
]
)
{
if
(
N
-
1
>
string
.
Length
(
)
)
{
return
false
;
}
return
memcmp
(
string
.
Data
(
)
prefix
N
-
1
)
=
=
0
;
}
static
JS
:
:
ProfilingCategoryPair
InferJavaCategory
(
nsACString
&
aName
)
{
if
(
aName
.
EqualsLiteral
(
"
android
.
os
.
MessageQueue
.
nativePollOnce
(
)
"
)
)
{
return
JS
:
:
ProfilingCategoryPair
:
:
IDLE
;
}
if
(
aName
.
EqualsLiteral
(
"
java
.
lang
.
Object
.
wait
(
)
"
)
)
{
return
JS
:
:
ProfilingCategoryPair
:
:
JAVA_BLOCKED
;
}
if
(
StartsWith
(
aName
"
android
.
"
)
|
|
StartsWith
(
aName
"
com
.
android
.
"
)
)
{
return
JS
:
:
ProfilingCategoryPair
:
:
JAVA_ANDROID
;
}
if
(
StartsWith
(
aName
"
mozilla
.
"
)
|
|
StartsWith
(
aName
"
org
.
mozilla
.
"
)
)
{
return
JS
:
:
ProfilingCategoryPair
:
:
JAVA_MOZILLA
;
}
if
(
StartsWith
(
aName
"
java
.
"
)
|
|
StartsWith
(
aName
"
sun
.
"
)
|
|
StartsWith
(
aName
"
com
.
sun
.
"
)
)
{
return
JS
:
:
ProfilingCategoryPair
:
:
JAVA_LANGUAGE
;
}
if
(
StartsWith
(
aName
"
kotlin
.
"
)
|
|
StartsWith
(
aName
"
kotlinx
.
"
)
)
{
return
JS
:
:
ProfilingCategoryPair
:
:
JAVA_KOTLIN
;
}
if
(
StartsWith
(
aName
"
androidx
.
"
)
)
{
return
JS
:
:
ProfilingCategoryPair
:
:
JAVA_ANDROIDX
;
}
return
JS
:
:
ProfilingCategoryPair
:
:
OTHER
;
}
struct
JavaMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
Java
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
)
{
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
TimelineOverview
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
SetAllLabels
(
"
{
marker
.
name
}
"
)
;
return
schema
;
}
}
;
struct
JavaMarkerWithDetails
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
JavaWithDetails
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
ProfilerString8View
&
aText
)
{
aWriter
.
StringProperty
(
"
name
"
aText
)
;
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
TimelineOverview
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
SetTooltipLabel
(
"
{
marker
.
name
}
"
)
;
schema
.
SetChartLabel
(
"
{
marker
.
data
.
name
}
"
)
;
schema
.
SetTableLabel
(
"
{
marker
.
name
}
-
{
marker
.
data
.
name
}
"
)
;
schema
.
AddKeyLabelFormatSearchable
(
"
name
"
"
Details
"
MS
:
:
Format
:
:
String
MS
:
:
Searchable
:
:
Searchable
)
;
return
schema
;
}
}
;
static
void
CollectJavaThreadProfileData
(
nsTArray
<
java
:
:
GeckoJavaSampler
:
:
ThreadInfo
:
:
LocalRef
>
&
javaThreads
ProfileBuffer
&
aProfileBuffer
)
{
const
auto
threadCount
=
java
:
:
GeckoJavaSampler
:
:
GetRegisteredThreadCount
(
)
;
for
(
int
i
=
0
;
i
<
threadCount
;
i
+
+
)
{
javaThreads
.
AppendElement
(
java
:
:
GeckoJavaSampler
:
:
GetRegisteredThreadInfo
(
i
)
)
;
}
int
sampleId
=
0
;
while
(
true
)
{
const
auto
threadId
=
java
:
:
GeckoJavaSampler
:
:
GetThreadId
(
sampleId
)
;
double
sampleTime
=
java
:
:
GeckoJavaSampler
:
:
GetSampleTime
(
sampleId
)
;
if
(
threadId
=
=
0
|
|
sampleTime
=
=
0
.
0
)
{
break
;
}
aProfileBuffer
.
AddThreadIdEntry
(
ProfilerThreadId
:
:
FromNumber
(
threadId
)
)
;
aProfileBuffer
.
AddEntry
(
ProfileBufferEntry
:
:
Time
(
sampleTime
)
)
;
int
frameId
=
0
;
while
(
true
)
{
jni
:
:
String
:
:
LocalRef
frameName
=
java
:
:
GeckoJavaSampler
:
:
GetFrameName
(
sampleId
frameId
+
+
)
;
if
(
!
frameName
)
{
break
;
}
nsCString
frameNameString
=
frameName
-
>
ToCString
(
)
;
auto
categoryPair
=
InferJavaCategory
(
frameNameString
)
;
aProfileBuffer
.
CollectCodeLocation
(
"
"
frameNameString
.
get
(
)
0
0
Nothing
(
)
Nothing
(
)
Some
(
categoryPair
)
)
;
}
sampleId
+
+
;
}
while
(
true
)
{
java
:
:
GeckoJavaSampler
:
:
Marker
:
:
LocalRef
marker
=
java
:
:
GeckoJavaSampler
:
:
PollNextMarker
(
)
;
if
(
!
marker
)
{
break
;
}
const
auto
threadId
=
ProfilerThreadId
:
:
FromNumber
(
marker
-
>
GetThreadId
(
)
)
;
nsCString
markerName
=
marker
-
>
GetMarkerName
(
)
-
>
ToCString
(
)
;
jni
:
:
String
:
:
LocalRef
text
=
marker
-
>
GetMarkerText
(
)
;
TimeStamp
startTime
=
CorePS
:
:
ProcessStartTime
(
)
+
TimeDuration
:
:
FromMilliseconds
(
marker
-
>
GetStartTime
(
)
)
;
double
endTimeMs
=
marker
-
>
GetEndTime
(
)
;
TimeStamp
endTime
=
endTimeMs
=
=
0
?
startTime
:
CorePS
:
:
ProcessStartTime
(
)
+
TimeDuration
:
:
FromMilliseconds
(
endTimeMs
)
;
MarkerTiming
timing
=
endTimeMs
=
=
0
?
MarkerTiming
:
:
InstantAt
(
startTime
)
:
MarkerTiming
:
:
Interval
(
startTime
endTime
)
;
if
(
!
text
)
{
AddMarkerToBuffer
(
aProfileBuffer
.
UnderlyingChunkedBuffer
(
)
markerName
geckoprofiler
:
:
category
:
:
JAVA_ANDROID
{
MarkerThreadId
(
threadId
)
std
:
:
move
(
timing
)
}
JavaMarker
{
}
)
;
}
else
{
AddMarkerToBuffer
(
aProfileBuffer
.
UnderlyingChunkedBuffer
(
)
markerName
geckoprofiler
:
:
category
:
:
JAVA_ANDROID
{
MarkerThreadId
(
threadId
)
std
:
:
move
(
timing
)
}
JavaMarkerWithDetails
{
}
text
-
>
ToCString
(
)
)
;
}
}
}
#
endif
UniquePtr
<
ProfilerCodeAddressService
>
profiler_code_address_service_for_presymbolication
(
)
{
static
const
bool
preSymbolicate
=
[
]
(
)
{
const
char
*
symbolicate
=
getenv
(
"
MOZ_PROFILER_SYMBOLICATE
"
)
;
return
symbolicate
&
&
symbolicate
[
0
]
!
=
'
\
0
'
;
}
(
)
;
return
preSymbolicate
?
MakeUnique
<
ProfilerCodeAddressService
>
(
)
:
nullptr
;
}
static
ProfilerResult
<
ProfileGenerationAdditionalInformation
>
locked_profiler_stream_json_for_this_process
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
double
aSinceTime
const
PreRecordedMetaInformation
&
aPreRecordedMetaInformation
bool
aIsShuttingDown
ProfilerCodeAddressService
*
aService
mozilla
:
:
ProgressLogger
aProgressLogger
)
{
LOG
(
"
locked_profiler_stream_json_for_this_process
"
)
;
#
ifdef
DEBUG
PRIntervalTime
slowWithSleeps
=
0
;
if
(
!
XRE_IsParentProcess
(
)
)
{
for
(
const
auto
&
filter
:
ActivePS
:
:
Filters
(
aLock
)
)
{
if
(
filter
=
=
"
test
-
debug
-
child
-
slow
-
json
"
)
{
LOG
(
"
test
-
debug
-
child
-
slow
-
json
"
)
;
slowWithSleeps
=
PR_MillisecondsToInterval
(
250
)
;
}
else
if
(
filter
=
=
"
test
-
debug
-
child
-
very
-
slow
-
json
"
)
{
LOG
(
"
test
-
debug
-
child
-
very
-
slow
-
json
"
)
;
PR_Sleep
(
PR_SecondsToInterval
(
5
)
)
;
}
}
}
#
define
SLOW_DOWN_FOR_TESTING
(
)
\
if
(
slowWithSleeps
!
=
0
)
{
\
DEBUG_LOG
(
"
progress
=
%
.
0f
%
%
sleep
.
.
.
"
\
aProgressLogger
.
GetGlobalProgress
(
)
.
ToDouble
(
)
*
100
.
0
)
;
\
PR_Sleep
(
slowWithSleeps
)
;
\
}
#
else
#
define
SLOW_DOWN_FOR_TESTING
(
)
#
endif
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
AUTO_PROFILER_STATS
(
locked_profiler_stream_json_for_this_process
)
;
const
double
collectionStartMs
=
profiler_time
(
)
;
ProfileBuffer
&
buffer
=
ActivePS
:
:
Buffer
(
aLock
)
;
aProgressLogger
.
SetLocalProgress
(
1_pc
"
Locked
profile
buffer
"
)
;
SLOW_DOWN_FOR_TESTING
(
)
;
Maybe
<
double
>
durationS
=
ActivePS
:
:
Duration
(
aLock
)
;
if
(
durationS
.
isSome
(
)
)
{
const
double
durationStartMs
=
collectionStartMs
-
*
durationS
*
1000
;
buffer
.
DiscardSamplesBeforeTime
(
durationStartMs
)
;
}
aProgressLogger
.
SetLocalProgress
(
2_pc
"
Discarded
old
data
"
)
;
if
(
aWriter
.
Failed
(
)
)
{
return
Err
(
ProfilerError
:
:
JsonGenerationFailed
)
;
}
SLOW_DOWN_FOR_TESTING
(
)
;
#
if
defined
(
GP_OS_android
)
mozilla
:
:
ProfileBufferChunkManagerWithLocalLimit
javaChunkManager
(
64
*
1024
*
1024
1024
*
1024
)
;
ProfileChunkedBuffer
javaBufferManager
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
javaChunkManager
)
;
ProfileBuffer
javaBuffer
(
javaBufferManager
)
;
nsTArray
<
java
:
:
GeckoJavaSampler
:
:
ThreadInfo
:
:
LocalRef
>
javaThreads
;
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
CollectJavaThreadProfileData
(
javaThreads
javaBuffer
)
;
aProgressLogger
.
SetLocalProgress
(
3_pc
"
Collected
Java
thread
"
)
;
}
#
endif
aWriter
.
StartArrayProperty
(
"
libs
"
)
;
SharedLibraryInfo
sharedLibraryInfo
=
SharedLibraryInfo
:
:
GetInfoForSelf
(
)
;
sharedLibraryInfo
.
SortByAddress
(
)
;
AppendSharedLibraries
(
aWriter
sharedLibraryInfo
)
;
aWriter
.
EndArray
(
)
;
aProgressLogger
.
SetLocalProgress
(
4_pc
"
Wrote
library
information
"
)
;
if
(
aWriter
.
Failed
(
)
)
{
return
Err
(
ProfilerError
:
:
JsonGenerationFailed
)
;
}
SLOW_DOWN_FOR_TESTING
(
)
;
aWriter
.
StartObjectProperty
(
"
meta
"
)
;
{
StreamMetaJSCustomObject
(
aLock
aWriter
aIsShuttingDown
aPreRecordedMetaInformation
)
;
}
aWriter
.
EndObject
(
)
;
aProgressLogger
.
SetLocalProgress
(
5_pc
"
Wrote
profile
metadata
"
)
;
if
(
aWriter
.
Failed
(
)
)
{
return
Err
(
ProfilerError
:
:
JsonGenerationFailed
)
;
}
SLOW_DOWN_FOR_TESTING
(
)
;
aWriter
.
StartArrayProperty
(
"
pages
"
)
;
{
StreamPages
(
aLock
aWriter
)
;
}
aWriter
.
EndArray
(
)
;
aProgressLogger
.
SetLocalProgress
(
6_pc
"
Wrote
pages
"
)
;
buffer
.
StreamProfilerOverheadToJSON
(
aWriter
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
aProgressLogger
.
CreateSubLoggerTo
(
10_pc
"
Wrote
profiler
overheads
"
)
)
;
buffer
.
StreamCountersToJSON
(
aWriter
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
aProgressLogger
.
CreateSubLoggerTo
(
14_pc
"
Wrote
counters
"
)
)
;
if
(
aWriter
.
Failed
(
)
)
{
return
Err
(
ProfilerError
:
:
JsonGenerationFailed
)
;
}
SLOW_DOWN_FOR_TESTING
(
)
;
aWriter
.
StartArrayProperty
(
"
threads
"
)
;
{
ActivePS
:
:
DiscardExpiredDeadProfiledThreads
(
aLock
)
;
aProgressLogger
.
SetLocalProgress
(
15_pc
"
Discarded
expired
profiles
"
)
;
ThreadRegistry
:
:
LockedRegistry
lockedRegistry
;
ActivePS
:
:
ProfiledThreadList
threads
=
ActivePS
:
:
ProfiledThreads
(
lockedRegistry
aLock
)
;
const
uint32_t
threadCount
=
uint32_t
(
threads
.
length
(
)
)
;
if
(
aWriter
.
Failed
(
)
)
{
return
Err
(
ProfilerError
:
:
JsonGenerationFailed
)
;
}
SLOW_DOWN_FOR_TESTING
(
)
;
ProcessStreamingContext
processStreamingContext
(
threadCount
aWriter
.
SourceFailureLatch
(
)
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
)
;
for
(
auto
&
&
[
i
progressLogger
]
:
aProgressLogger
.
CreateLoopSubLoggersTo
(
20_pc
threadCount
"
Preparing
thread
streaming
contexts
.
.
.
"
)
)
{
ActivePS
:
:
ProfiledThreadListElement
&
thread
=
threads
[
i
]
;
MOZ_RELEASE_ASSERT
(
thread
.
mProfiledThreadData
)
;
processStreamingContext
.
AddThreadStreamingContext
(
*
thread
.
mProfiledThreadData
buffer
thread
.
mJSContext
aService
std
:
:
move
(
progressLogger
)
)
;
if
(
aWriter
.
Failed
(
)
)
{
return
Err
(
ProfilerError
:
:
JsonGenerationFailed
)
;
}
}
SLOW_DOWN_FOR_TESTING
(
)
;
buffer
.
StreamSamplesAndMarkersToJSON
(
processStreamingContext
aProgressLogger
.
CreateSubLoggerTo
(
"
Processing
samples
and
markers
.
.
.
"
80_pc
"
Processed
samples
and
markers
"
)
)
;
if
(
aWriter
.
Failed
(
)
)
{
return
Err
(
ProfilerError
:
:
JsonGenerationFailed
)
;
}
SLOW_DOWN_FOR_TESTING
(
)
;
ThreadStreamingContext
*
const
contextListBegin
=
processStreamingContext
.
begin
(
)
;
MOZ_ASSERT
(
uint32_t
(
processStreamingContext
.
end
(
)
-
contextListBegin
)
=
=
threadCount
)
;
for
(
auto
&
&
[
i
progressLogger
]
:
aProgressLogger
.
CreateLoopSubLoggersTo
(
92_pc
threadCount
"
Streaming
threads
.
.
.
"
)
)
{
ThreadStreamingContext
&
threadStreamingContext
=
contextListBegin
[
i
]
;
threadStreamingContext
.
FinalizeWriter
(
)
;
threadStreamingContext
.
mProfiledThreadData
.
StreamJSON
(
std
:
:
move
(
threadStreamingContext
)
aWriter
CorePS
:
:
ProcessName
(
aLock
)
CorePS
:
:
ETLDplus1
(
aLock
)
CorePS
:
:
ProcessStartTime
(
)
aService
std
:
:
move
(
progressLogger
)
)
;
if
(
aWriter
.
Failed
(
)
)
{
return
Err
(
ProfilerError
:
:
JsonGenerationFailed
)
;
}
}
aProgressLogger
.
SetLocalProgress
(
92_pc
"
Wrote
samples
and
markers
"
)
;
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
for
(
java
:
:
GeckoJavaSampler
:
:
ThreadInfo
:
:
LocalRef
&
threadInfo
:
javaThreads
)
{
ProfiledThreadData
threadData
(
ThreadRegistrationInfo
{
threadInfo
-
>
GetName
(
)
-
>
ToCString
(
)
.
BeginReading
(
)
ProfilerThreadId
:
:
FromNumber
(
threadInfo
-
>
GetId
(
)
)
false
CorePS
:
:
ProcessStartTime
(
)
}
)
;
threadData
.
StreamJSON
(
javaBuffer
nullptr
aWriter
CorePS
:
:
ProcessName
(
aLock
)
CorePS
:
:
ETLDplus1
(
aLock
)
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
nullptr
aProgressLogger
.
CreateSubLoggerTo
(
"
Streaming
Java
thread
.
.
.
"
96_pc
"
Streamed
Java
thread
"
)
)
;
}
if
(
aWriter
.
Failed
(
)
)
{
return
Err
(
ProfilerError
:
:
JsonGenerationFailed
)
;
}
}
else
{
aProgressLogger
.
SetLocalProgress
(
96_pc
"
No
Java
thread
"
)
;
}
#
endif
UniquePtr
<
char
[
]
>
baseProfileThreads
=
ActivePS
:
:
MoveBaseProfileThreads
(
aLock
)
;
if
(
baseProfileThreads
)
{
aWriter
.
Splice
(
MakeStringSpan
(
baseProfileThreads
.
get
(
)
)
)
;
if
(
aWriter
.
Failed
(
)
)
{
return
Err
(
ProfilerError
:
:
JsonGenerationFailed
)
;
}
aProgressLogger
.
SetLocalProgress
(
97_pc
"
Wrote
baseprofiler
data
"
)
;
}
else
{
aProgressLogger
.
SetLocalProgress
(
97_pc
"
No
baseprofiler
data
"
)
;
}
}
aWriter
.
EndArray
(
)
;
SLOW_DOWN_FOR_TESTING
(
)
;
aWriter
.
StartArrayProperty
(
"
pausedRanges
"
)
;
{
buffer
.
StreamPausedRangesToJSON
(
aWriter
aSinceTime
aProgressLogger
.
CreateSubLoggerTo
(
"
Streaming
pauses
.
.
.
"
99_pc
"
Streamed
pauses
"
)
)
;
}
aWriter
.
EndArray
(
)
;
if
(
aWriter
.
Failed
(
)
)
{
return
Err
(
ProfilerError
:
:
JsonGenerationFailed
)
;
}
ProfilingLog
:
:
Access
(
[
&
]
(
Json
:
:
Value
&
aProfilingLogObject
)
{
aProfilingLogObject
[
Json
:
:
StaticString
{
"
profilingLogEnd
"
TIMESTAMP_JSON_SUFFIX
}
]
=
ProfilingLog
:
:
Timestamp
(
)
;
aWriter
.
StartObjectProperty
(
"
profilingLog
"
)
;
{
nsAutoCString
pid
;
pid
.
AppendInt
(
int64_t
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
)
;
Json
:
:
String
logString
=
ToCompactString
(
aProfilingLogObject
)
;
aWriter
.
SplicedJSONProperty
(
pid
logString
)
;
}
aWriter
.
EndObject
(
)
;
}
)
;
const
double
collectionEndMs
=
profiler_time
(
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CollectionStart
(
collectionStartMs
)
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CollectionEnd
(
collectionEndMs
)
)
;
#
ifdef
DEBUG
if
(
slowWithSleeps
!
=
0
)
{
LOG
(
"
locked_profiler_stream_json_for_this_process
done
"
)
;
}
#
endif
return
ProfileGenerationAdditionalInformation
{
std
:
:
move
(
sharedLibraryInfo
)
}
;
}
ProfilerResult
<
ProfileGenerationAdditionalInformation
>
do_profiler_stream_json_for_this_process
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
bool
aIsShuttingDown
ProfilerCodeAddressService
*
aService
mozilla
:
:
ProgressLogger
aProgressLogger
)
{
LOG
(
"
profiler_stream_json_for_this_process
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
const
auto
preRecordedMetaInformation
=
PreRecordMetaInformation
(
)
;
aProgressLogger
.
SetLocalProgress
(
2_pc
"
PreRecordMetaInformation
done
"
)
;
if
(
profiler_is_active
(
)
)
{
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
GeneratingProfile
)
;
}
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
Err
(
ProfilerError
:
:
IsInactive
)
;
}
ProfileGenerationAdditionalInformation
additionalInfo
;
MOZ_TRY_VAR
(
additionalInfo
locked_profiler_stream_json_for_this_process
(
lock
aWriter
aSinceTime
preRecordedMetaInformation
aIsShuttingDown
aService
aProgressLogger
.
CreateSubLoggerFromTo
(
3_pc
"
locked_profiler_stream_json_for_this_process
started
"
100_pc
"
locked_profiler_stream_json_for_this_process
done
"
)
)
)
;
if
(
aWriter
.
Failed
(
)
)
{
return
Err
(
ProfilerError
:
:
JsonGenerationFailed
)
;
}
return
additionalInfo
;
}
ProfilerResult
<
ProfileGenerationAdditionalInformation
>
profiler_stream_json_for_this_process
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
bool
aIsShuttingDown
ProfilerCodeAddressService
*
aService
mozilla
:
:
ProgressLogger
aProgressLogger
)
{
MOZ_RELEASE_ASSERT
(
!
XRE_IsParentProcess
(
)
|
|
NS_IsMainThread
(
)
"
In
the
parent
process
profiles
should
only
be
generated
from
the
main
"
"
thread
otherwise
they
will
be
incomplete
.
"
)
;
ProfileGenerationAdditionalInformation
additionalInfo
;
MOZ_TRY_VAR
(
additionalInfo
do_profiler_stream_json_for_this_process
(
aWriter
aSinceTime
aIsShuttingDown
aService
std
:
:
move
(
aProgressLogger
)
)
)
;
return
additionalInfo
;
}
static
char
FeatureCategory
(
uint32_t
aFeature
)
{
if
(
aFeature
&
DefaultFeatures
(
)
)
{
if
(
aFeature
&
AvailableFeatures
(
)
)
{
return
'
D
'
;
}
return
'
d
'
;
}
if
(
aFeature
&
StartupExtraDefaultFeatures
(
)
)
{
if
(
aFeature
&
AvailableFeatures
(
)
)
{
return
'
S
'
;
}
return
'
s
'
;
}
if
(
aFeature
&
AvailableFeatures
(
)
)
{
return
'
-
'
;
}
return
'
x
'
;
}
static
void
PrintUsage
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
printf
(
"
\
n
"
"
Profiler
environment
variable
usage
:
\
n
"
"
\
n
"
"
MOZ_PROFILER_HELP
\
n
"
"
If
set
to
any
value
prints
this
message
.
\
n
"
"
Use
MOZ_BASE_PROFILER_HELP
for
BaseProfiler
help
.
\
n
"
"
\
n
"
"
MOZ_LOG
\
n
"
"
Enables
logging
.
The
levels
of
logging
available
are
\
n
"
"
'
prof
:
3
'
(
least
verbose
)
'
prof
:
4
'
'
prof
:
5
'
(
most
verbose
)
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP
\
n
"
"
If
set
to
any
value
other
than
'
'
or
'
0
'
/
'
N
'
/
'
n
'
starts
the
\
n
"
"
profiler
immediately
on
start
-
up
.
\
n
"
"
Useful
if
you
want
profile
code
that
runs
very
early
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_ENTRIES
=
<
%
u
.
.
%
u
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
number
of
entries
per
\
n
"
"
process
in
the
profiler
'
s
circular
buffer
when
the
profiler
is
first
\
n
"
"
started
.
\
n
"
"
If
unset
the
platform
default
is
used
:
\
n
"
"
%
u
entries
per
process
or
%
u
when
MOZ_PROFILER_STARTUP
is
set
.
\
n
"
"
(
%
u
bytes
per
entry
-
>
%
u
or
%
u
total
bytes
per
process
)
\
n
"
"
Optional
units
in
bytes
:
KB
KiB
MB
MiB
GB
GiB
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_DURATION
=
<
1
.
.
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
maximum
life
time
of
\
n
"
"
entries
in
the
the
profiler
'
s
circular
buffer
when
the
profiler
is
\
n
"
"
first
started
in
seconds
.
\
n
"
"
If
unset
the
life
time
of
the
entries
will
only
be
restricted
by
\
n
"
"
MOZ_PROFILER_STARTUP_ENTRIES
(
or
its
default
value
)
and
no
\
n
"
"
additional
time
duration
restriction
will
be
applied
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_INTERVAL
=
<
1
.
.
%
d
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
sample
interval
\
n
"
"
measured
in
milliseconds
when
the
profiler
is
first
started
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
=
<
Number
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
profiling
features
as
\
n
"
"
the
integer
value
of
the
features
bitfield
.
\
n
"
"
If
unset
the
value
from
MOZ_PROFILER_STARTUP_FEATURES
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FEATURES
=
<
Features
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
profiling
features
as
\
n
"
"
a
comma
-
separated
list
of
strings
.
\
n
"
"
Ignored
if
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
is
set
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
Features
:
(
x
=
unavailable
D
/
d
=
default
/
unavailable
\
n
"
"
S
/
s
=
MOZ_PROFILER_STARTUP
extra
default
/
unavailable
)
\
n
"
unsigned
(
scMinimumBufferEntries
)
unsigned
(
scMaximumBufferEntries
)
unsigned
(
PROFILER_DEFAULT_ENTRIES
.
Value
(
)
)
unsigned
(
PROFILER_DEFAULT_STARTUP_ENTRIES
.
Value
(
)
)
unsigned
(
scBytesPerEntry
)
unsigned
(
PROFILER_DEFAULT_ENTRIES
.
Value
(
)
*
scBytesPerEntry
)
unsigned
(
PROFILER_DEFAULT_STARTUP_ENTRIES
.
Value
(
)
*
scBytesPerEntry
)
PROFILER_MAX_INTERVAL
)
;
#
define
PRINT_FEATURE
(
n_
str_
Name_
desc_
)
\
printf
(
"
%
c
%
7u
:
\
"
%
s
\
"
(
%
s
)
\
n
"
FeatureCategory
(
ProfilerFeature
:
:
Name_
)
\
ProfilerFeature
:
:
Name_
str_
desc_
)
;
PROFILER_FOR_EACH_FEATURE
(
PRINT_FEATURE
)
#
undef
PRINT_FEATURE
printf
(
"
-
\
"
default
\
"
(
All
above
D
+
S
defaults
)
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FILTERS
=
<
Filters
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
thread
filters
as
a
\
n
"
"
comma
-
separated
list
of
strings
.
A
given
thread
will
be
sampled
if
\
n
"
"
any
of
the
filters
is
a
case
-
insensitive
substring
of
the
thread
\
n
"
"
name
.
If
unset
a
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_ACTIVE_TAB_ID
=
<
Number
>
\
n
"
"
This
variable
is
used
to
propagate
the
activeTabID
of
\
n
"
"
the
profiler
init
params
to
subprocesses
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_SHUTDOWN
=
<
Filename
>
\
n
"
"
If
set
the
profiler
saves
a
profile
to
the
named
file
on
shutdown
.
\
n
"
"
If
the
Filename
contains
\
"
%
%
p
\
"
this
will
be
replaced
with
the
'
\
n
"
"
process
id
of
the
parent
process
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_SYMBOLICATE
\
n
"
"
If
set
the
profiler
will
pre
-
symbolicate
profiles
.
\
n
"
"
*
Note
*
This
will
add
a
significant
pause
when
gathering
data
and
\
n
"
"
is
intended
mainly
for
local
development
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_LUL_TEST
\
n
"
"
If
set
to
any
value
runs
LUL
unit
tests
at
startup
.
\
n
"
"
\
n
"
"
This
platform
%
s
native
unwinding
.
\
n
"
"
\
n
"
#
if
defined
(
HAVE_NATIVE_UNWIND
)
"
supports
"
#
else
"
does
not
support
"
#
endif
)
;
}
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
struct
SigHandlerCoordinator
;
#
endif
class
Sampler
{
public
:
explicit
Sampler
(
PSLockRef
aLock
)
;
void
Disable
(
PSLockRef
aLock
)
;
template
<
typename
Func
>
void
SuspendAndSampleAndResumeThread
(
PSLockRef
aLock
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
TimeStamp
&
aNow
const
Func
&
aProcessRegs
)
;
private
:
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
struct
sigaction
mOldSigprofHandler
;
ProfilerProcessId
mMyPid
;
ProfilerThreadId
mSamplerTid
;
public
:
static
struct
SigHandlerCoordinator
*
sSigHandlerCoordinator
;
#
endif
}
;
static
RunningTimes
GetThreadRunningTimesDiff
(
PSLockRef
aLock
ThreadRegistration
:
:
UnlockedRWForLockedProfiler
&
aThreadData
)
;
static
void
DiscardSuspendedThreadRunningTimes
(
PSLockRef
aLock
ThreadRegistration
:
:
UnlockedRWForLockedProfiler
&
aThreadData
)
;
static
RunningTimes
GetProcessRunningTimesDiff
(
PSLockRef
aLock
RunningTimes
&
aPreviousRunningTimesToBeUpdated
)
;
template
<
typename
GetCPURunningTimesFunction
>
RunningTimes
GetRunningTimesWithTightTimestamp
(
GetCPURunningTimesFunction
&
&
aGetCPURunningTimesFunction
)
{
static
const
TimeDuration
scMaxRunningTimesReadDuration
=
[
&
]
(
)
{
constexpr
int
loops
=
128
;
TimeDuration
durations
[
loops
]
;
RunningTimes
runningTimes
;
TimeStamp
before
=
TimeStamp
:
:
Now
(
)
;
for
(
int
i
=
0
;
i
<
loops
;
+
+
i
)
{
AUTO_PROFILER_STATS
(
GetRunningTimes_MaxRunningTimesReadDuration
)
;
aGetCPURunningTimesFunction
(
runningTimes
)
;
const
TimeStamp
after
=
TimeStamp
:
:
Now
(
)
;
durations
[
i
]
=
after
-
before
;
before
=
after
;
}
std
:
:
nth_element
(
&
durations
[
0
]
&
durations
[
loops
/
2
]
&
durations
[
loops
]
)
;
return
durations
[
loops
/
2
]
*
8
;
}
(
)
;
RunningTimes
runningTimes
;
TimeStamp
before
=
TimeStamp
:
:
Now
(
)
;
aGetCPURunningTimesFunction
(
runningTimes
)
;
TimeStamp
after
=
TimeStamp
:
:
Now
(
)
;
const
TimeDuration
duration
=
after
-
before
;
if
(
MOZ_UNLIKELY
(
duration
>
scMaxRunningTimesReadDuration
)
)
{
AUTO_PROFILER_STATS
(
GetRunningTimes_REDO
)
;
RunningTimes
runningTimes2
;
aGetCPURunningTimesFunction
(
runningTimes2
)
;
TimeStamp
after2
=
TimeStamp
:
:
Now
(
)
;
const
TimeDuration
duration2
=
after2
-
after
;
if
(
duration2
<
duration
)
{
runningTimes2
.
SetPostMeasurementTimeStamp
(
after2
)
;
return
runningTimes2
;
}
AUTO_PROFILER_STATS
(
GetRunningTimes_RedoWasWorse
)
;
}
runningTimes
.
SetPostMeasurementTimeStamp
(
after
)
;
return
runningTimes
;
}
class
SamplerThread
{
public
:
SamplerThread
(
PSLockRef
aLock
uint32_t
aActivityGeneration
double
aIntervalMilliseconds
uint32_t
aFeatures
)
;
~
SamplerThread
(
)
;
void
Run
(
)
;
#
if
defined
(
GP_OS_windows
)
void
RunUnregisteredThreadSpy
(
)
;
#
endif
void
Stop
(
PSLockRef
aLock
)
;
void
AppendPostSamplingCallback
(
PSLockRef
PostSamplingCallback
&
&
aCallback
)
{
mPostSamplingCallbackList
=
MakeUnique
<
PostSamplingCallbackListItem
>
(
std
:
:
move
(
mPostSamplingCallbackList
)
std
:
:
move
(
aCallback
)
)
;
}
private
:
void
SpyOnUnregisteredThreads
(
)
;
struct
PostSamplingCallbackListItem
{
UniquePtr
<
PostSamplingCallbackListItem
>
mPrev
;
PostSamplingCallback
mCallback
;
PostSamplingCallbackListItem
(
UniquePtr
<
PostSamplingCallbackListItem
>
aPrev
PostSamplingCallback
&
&
aCallback
)
:
mPrev
(
std
:
:
move
(
aPrev
)
)
mCallback
(
std
:
:
move
(
aCallback
)
)
{
}
}
;
[
[
nodiscard
]
]
UniquePtr
<
PostSamplingCallbackListItem
>
TakePostSamplingCallbacks
(
PSLockRef
)
{
return
std
:
:
move
(
mPostSamplingCallbackList
)
;
}
static
void
InvokePostSamplingCallbacks
(
UniquePtr
<
PostSamplingCallbackListItem
>
aCallbacks
SamplingState
aSamplingState
)
{
if
(
!
aCallbacks
)
{
return
;
}
InvokePostSamplingCallbacks
(
std
:
:
move
(
aCallbacks
-
>
mPrev
)
aSamplingState
)
;
std
:
:
move
(
aCallbacks
-
>
mCallback
)
(
aSamplingState
)
;
static_assert
(
std
:
:
is_same_v
<
decltype
(
aCallbacks
)
UniquePtr
<
PostSamplingCallbackListItem
>
>
"
We
need
to
capture
the
list
by
-
value
to
implicitly
destroy
it
"
)
;
}
void
SleepMicro
(
uint32_t
aMicroseconds
)
;
Sampler
mSampler
;
const
uint32_t
mActivityGeneration
;
const
int
mIntervalMicroseconds
;
#
if
defined
(
GP_OS_windows
)
HANDLE
mThread
;
HANDLE
mUnregisteredThreadSpyThread
=
nullptr
;
enum
class
SpyingState
{
NoSpying
Spy_Initializing
Spy_Waiting
SamplerToSpy_Start
Spy_Working
MainToSpy_Shutdown
SpyToMain_ShuttingDown
}
;
SpyingState
mSpyingState
=
SpyingState
:
:
NoSpying
;
int
mDelaySpyStart
=
0
;
Monitor
mSpyingStateMonitor
MOZ_UNANNOTATED
{
"
SamplerThread
:
:
mSpyingStateMonitor
"
}
;
#
elif
defined
(
GP_OS_darwin
)
|
|
defined
(
GP_OS_linux
)
|
|
\
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
pthread_t
mThread
;
#
endif
UniquePtr
<
PostSamplingCallbackListItem
>
mPostSamplingCallbackList
;
#
if
defined
(
GP_OS_windows
)
bool
mNoTimerResolutionChange
=
true
;
#
endif
struct
SpiedThread
{
base
:
:
ProcessId
mThreadId
;
nsCString
mName
;
uint64_t
mCPUTimeNs
;
SpiedThread
(
base
:
:
ProcessId
aThreadId
const
nsACString
&
aName
uint64_t
aCPUTimeNs
)
:
mThreadId
(
aThreadId
)
mName
(
aName
)
mCPUTimeNs
(
aCPUTimeNs
)
{
}
friend
bool
operator
=
=
(
const
SpiedThread
&
aSpiedThread
base
:
:
ProcessId
aThreadId
)
{
return
aSpiedThread
.
mThreadId
=
=
aThreadId
;
}
friend
bool
operator
=
=
(
base
:
:
ProcessId
aThreadId
const
SpiedThread
&
aSpiedThread
)
{
return
aThreadId
=
=
aSpiedThread
.
mThreadId
;
}
}
;
TimeStamp
mLastSpying
;
using
SpiedThreads
=
AutoTArray
<
SpiedThread
128
>
;
SpiedThreads
mSpiedThreads
;
SamplerThread
(
const
SamplerThread
&
)
=
delete
;
void
operator
=
(
const
SamplerThread
&
)
=
delete
;
}
;
namespace
geckoprofiler
:
:
markers
{
struct
CPUSpeedMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
CPUSpeed
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
uint32_t
aCPUSpeedMHz
)
{
aWriter
.
DoubleProperty
(
"
speed
"
double
(
aCPUSpeedMHz
)
/
1000
)
;
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
SetTableLabel
(
"
{
marker
.
name
}
Speed
=
{
marker
.
data
.
speed
}
GHz
"
)
;
schema
.
AddKeyLabelFormat
(
"
speed
"
"
CPU
Speed
(
GHz
)
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddChartColor
(
"
speed
"
MS
:
:
GraphType
:
:
Bar
MS
:
:
GraphColor
:
:
Ink
)
;
return
schema
;
}
}
;
}
bool
ActivePS
:
:
AppendPostSamplingCallback
(
PSLockRef
aLock
PostSamplingCallback
&
&
aCallback
)
{
if
(
!
sInstance
|
|
!
sInstance
-
>
mSamplerThread
)
{
return
false
;
}
sInstance
-
>
mSamplerThread
-
>
AppendPostSamplingCallback
(
aLock
std
:
:
move
(
aCallback
)
)
;
return
true
;
}
static
SamplerThread
*
NewSamplerThread
(
PSLockRef
aLock
uint32_t
aGeneration
double
aInterval
uint32_t
aFeatures
)
{
return
new
SamplerThread
(
aLock
aGeneration
aInterval
aFeatures
)
;
}
void
SamplerThread
:
:
Run
(
)
{
NS_SetCurrentThreadName
(
"
SamplerThread
"
)
;
const
uint32_t
features
=
[
]
(
)
-
>
uint32_t
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
0
;
}
return
ActivePS
:
:
Features
(
lock
)
;
}
(
)
;
const
bool
stackSampling
=
!
ProfilerFeature
:
:
HasNoStackSampling
(
features
)
;
const
bool
cpuUtilization
=
ProfilerFeature
:
:
HasCPUUtilization
(
features
)
;
mozilla
:
:
ProfileBufferChunkManagerSingle
localChunkManager
(
ProfileBufferChunkManager
:
:
scExpectedMaximumStackSize
)
;
ProfileChunkedBuffer
localBuffer
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
localChunkManager
)
;
ProfileBuffer
localProfileBuffer
(
localBuffer
)
;
auto
previousState
=
localBuffer
.
GetState
(
)
;
RunningTimes
processRunningTimes
;
UniquePtr
<
PostSamplingCallbackListItem
>
postSamplingCallbacks
;
SamplingState
samplingState
{
}
;
const
TimeDuration
sampleInterval
=
TimeDuration
:
:
FromMicroseconds
(
mIntervalMicroseconds
)
;
const
uint32_t
minimumIntervalSleepUs
=
static_cast
<
uint32_t
>
(
mIntervalMicroseconds
/
4
)
;
TimeStamp
scheduledSampleStart
=
TimeStamp
:
:
Now
(
)
;
#
if
defined
(
HAVE_CPU_FREQ_SUPPORT
)
Vector
<
uint32_t
>
CPUSpeeds
;
if
(
XRE_IsParentProcess
(
)
&
&
ProfilerFeature
:
:
HasCPUFrequency
(
features
)
&
&
CPUSpeeds
.
resize
(
GetNumberOfProcessors
(
)
)
)
{
{
PSAutoLock
lock
;
if
(
ProfilerCPUFreq
*
cpuFreq
=
ActivePS
:
:
MaybeCPUFreq
(
lock
)
;
cpuFreq
)
{
cpuFreq
-
>
Sample
(
)
;
for
(
size_t
i
=
0
;
i
<
CPUSpeeds
.
length
(
)
;
+
+
i
)
{
CPUSpeeds
[
i
]
=
cpuFreq
-
>
GetCPUSpeedMHz
(
i
)
;
}
}
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
for
(
size_t
i
=
0
;
i
<
CPUSpeeds
.
length
(
)
;
+
+
i
)
{
nsAutoCString
name
;
name
.
AssignLiteral
(
"
CPU
"
)
;
name
.
AppendInt
(
i
)
;
PROFILER_MARKER
(
name
OTHER
MarkerOptions
(
MarkerThreadId
:
:
MainThread
(
)
MarkerTiming
:
:
IntervalStart
(
now
)
)
CPUSpeedMarker
CPUSpeeds
[
i
]
)
;
}
}
#
endif
while
(
true
)
{
const
TimeStamp
sampleStart
=
TimeStamp
:
:
Now
(
)
;
{
MOZ_ASSERT
(
!
postSamplingCallbacks
)
;
PSAutoLock
lock
;
TimeStamp
lockAcquired
=
TimeStamp
:
:
Now
(
)
;
postSamplingCallbacks
=
TakePostSamplingCallbacks
(
lock
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
samplingState
=
SamplingState
:
:
JustStopped
;
break
;
}
if
(
ActivePS
:
:
Generation
(
lock
)
!
=
mActivityGeneration
)
{
samplingState
=
SamplingState
:
:
JustStopped
;
break
;
}
ActivePS
:
:
ClearExpiredExitProfiles
(
lock
)
;
TimeStamp
expiredMarkersCleaned
=
TimeStamp
:
:
Now
(
)
;
if
(
int
(
gSkipSampling
)
<
=
0
&
&
!
ActivePS
:
:
IsSamplingPaused
(
lock
)
)
{
double
sampleStartDeltaMs
=
(
sampleStart
-
CorePS
:
:
ProcessStartTime
(
)
)
.
ToMilliseconds
(
)
;
ProfileBuffer
&
buffer
=
ActivePS
:
:
Buffer
(
lock
)
;
if
(
ActivePS
:
:
ProcessCPUCounter
*
processCPUCounter
=
ActivePS
:
:
MaybeProcessCPUCounter
(
lock
)
;
processCPUCounter
)
{
RunningTimes
processRunningTimesDiff
=
GetProcessRunningTimesDiff
(
lock
processRunningTimes
)
;
Maybe
<
uint64_t
>
cpu
=
processRunningTimesDiff
.
GetJsonThreadCPUDelta
(
)
;
if
(
cpu
)
{
processCPUCounter
-
>
Add
(
static_cast
<
int64_t
>
(
*
cpu
)
)
;
}
}
#
if
defined
(
HAVE_CPU_FREQ_SUPPORT
)
if
(
XRE_IsParentProcess
(
)
&
&
CPUSpeeds
.
length
(
)
>
0
)
{
unsigned
newSpeed
[
CPUSpeeds
.
length
(
)
]
;
if
(
ProfilerCPUFreq
*
cpuFreq
=
ActivePS
:
:
MaybeCPUFreq
(
lock
)
;
cpuFreq
)
{
cpuFreq
-
>
Sample
(
)
;
for
(
size_t
i
=
0
;
i
<
CPUSpeeds
.
length
(
)
;
+
+
i
)
{
newSpeed
[
i
]
=
cpuFreq
-
>
GetCPUSpeedMHz
(
i
)
;
}
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
for
(
size_t
i
=
0
;
i
<
CPUSpeeds
.
length
(
)
;
+
+
i
)
{
if
(
newSpeed
[
i
]
=
=
CPUSpeeds
[
i
]
)
{
continue
;
}
nsAutoCString
name
;
name
.
AssignLiteral
(
"
CPU
"
)
;
name
.
AppendInt
(
i
)
;
PROFILER_MARKER_UNTYPED
(
name
OTHER
MarkerOptions
(
MarkerThreadId
:
:
MainThread
(
)
MarkerTiming
:
:
IntervalEnd
(
now
)
)
)
;
PROFILER_MARKER
(
name
OTHER
MarkerOptions
(
MarkerThreadId
:
:
MainThread
(
)
MarkerTiming
:
:
IntervalStart
(
now
)
)
CPUSpeedMarker
newSpeed
[
i
]
)
;
CPUSpeeds
[
i
]
=
newSpeed
[
i
]
;
}
}
#
endif
if
(
PowerCounters
*
powerCounters
=
ActivePS
:
:
MaybePowerCounters
(
lock
)
;
powerCounters
)
{
powerCounters
-
>
Sample
(
)
;
}
double
counterSampleStartDeltaMs
=
(
TimeStamp
:
:
Now
(
)
-
CorePS
:
:
ProcessStartTime
(
)
)
.
ToMilliseconds
(
)
;
const
Vector
<
BaseProfilerCount
*
>
&
counters
=
CorePS
:
:
Counters
(
lock
)
;
for
(
auto
&
counter
:
counters
)
{
if
(
auto
sample
=
counter
-
>
Sample
(
)
;
sample
.
isSampleNew
)
{
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CounterId
(
counter
)
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Time
(
counterSampleStartDeltaMs
)
)
;
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
ActivePS
:
:
IsMemoryCounter
(
counter
)
)
{
sample
.
count
-
=
static_cast
<
int64_t
>
(
ActivePS
:
:
ControlledChunkManager
(
lock
)
.
TotalSize
(
)
)
;
}
#
endif
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Count
(
sample
.
count
)
)
;
if
(
sample
.
number
)
{
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Number
(
sample
.
number
)
)
;
}
}
}
TimeStamp
countersSampled
=
TimeStamp
:
:
Now
(
)
;
if
(
stackSampling
|
|
cpuUtilization
)
{
samplingState
=
SamplingState
:
:
SamplingCompleted
;
ThreadRegistry
:
:
LockedRegistry
lockedRegistry
;
for
(
ThreadRegistry
:
:
OffThreadRef
offThreadRef
:
lockedRegistry
)
{
ThreadRegistration
:
:
UnlockedRWForLockedProfiler
&
unlockedThreadData
=
offThreadRef
.
UnlockedRWForLockedProfilerRef
(
)
;
ProfiledThreadData
*
profiledThreadData
=
unlockedThreadData
.
GetProfiledThreadData
(
lock
)
;
if
(
!
profiledThreadData
)
{
continue
;
}
const
ThreadProfilingFeatures
whatToProfile
=
unlockedThreadData
.
ProfilingFeatures
(
)
;
const
bool
threadCPUUtilization
=
cpuUtilization
&
&
DoFeaturesIntersect
(
whatToProfile
ThreadProfilingFeatures
:
:
CPUUtilization
)
;
const
bool
threadStackSampling
=
stackSampling
&
&
DoFeaturesIntersect
(
whatToProfile
ThreadProfilingFeatures
:
:
Sampling
)
;
if
(
!
threadCPUUtilization
&
&
!
threadStackSampling
)
{
continue
;
}
const
ProfilerThreadId
threadId
=
unlockedThreadData
.
Info
(
)
.
ThreadId
(
)
;
const
RunningTimes
runningTimesDiff
=
[
&
]
(
)
{
if
(
!
threadCPUUtilization
)
{
return
RunningTimes
(
TimeStamp
:
:
Now
(
)
)
;
}
return
GetThreadRunningTimesDiff
(
lock
unlockedThreadData
)
;
}
(
)
;
const
TimeStamp
&
now
=
runningTimesDiff
.
PostMeasurementTimeStamp
(
)
;
double
threadSampleDeltaMs
=
(
now
-
CorePS
:
:
ProcessStartTime
(
)
)
.
ToMilliseconds
(
)
;
if
(
threadStackSampling
&
&
(
unlockedThreadData
.
CanDuplicateLastSampleDueToSleep
(
)
|
|
runningTimesDiff
.
GetThreadCPUDelta
(
)
=
=
Some
(
uint64_t
(
0
)
)
)
)
{
const
bool
dup_ok
=
ActivePS
:
:
Buffer
(
lock
)
.
DuplicateLastSample
(
threadId
threadSampleDeltaMs
profiledThreadData
-
>
LastSample
(
)
runningTimesDiff
)
;
if
(
dup_ok
)
{
continue
;
}
}
AUTO_PROFILER_STATS
(
gecko_SamplerThread_Run_DoPeriodicSample
)
;
const
uint64_t
bufferRangeStart
=
buffer
.
BufferRangeStart
(
)
;
const
uint64_t
samplePos
=
buffer
.
AddThreadIdEntry
(
threadId
)
;
profiledThreadData
-
>
LastSample
(
)
=
Some
(
samplePos
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
TimeBeforeCompactStack
(
threadSampleDeltaMs
)
)
;
Maybe
<
double
>
unresponsiveDuration_ms
;
if
(
!
runningTimesDiff
.
IsEmpty
(
)
)
{
profiler_get_core_buffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
RunningTimes
runningTimesDiff
)
;
}
if
(
threadStackSampling
)
{
ThreadRegistry
:
:
OffThreadRef
:
:
RWFromAnyThreadWithLock
lockedThreadData
=
offThreadRef
.
GetLockedRWFromAnyThread
(
)
;
mSampler
.
SuspendAndSampleAndResumeThread
(
lock
lockedThreadData
.
DataCRef
(
)
now
[
&
]
(
const
Registers
&
aRegs
const
TimeStamp
&
aNow
)
{
DoPeriodicSample
(
lock
lockedThreadData
.
DataCRef
(
)
aRegs
samplePos
bufferRangeStart
localProfileBuffer
)
;
TimeDuration
currentEventDelay
;
TimeDuration
currentEventRunning
;
lockedThreadData
-
>
GetRunningEventDelay
(
aNow
currentEventDelay
currentEventRunning
)
;
unresponsiveDuration_ms
=
Some
(
currentEventDelay
.
ToMilliseconds
(
)
+
currentEventRunning
.
ToMilliseconds
(
)
)
;
}
)
;
if
(
cpuUtilization
)
{
DiscardSuspendedThreadRunningTimes
(
lock
unlockedThreadData
)
;
}
if
(
unresponsiveDuration_ms
.
isSome
(
)
)
{
profiler_get_core_buffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
UnresponsiveDurationMs
*
unresponsiveDuration_ms
)
;
}
}
auto
state
=
localBuffer
.
GetState
(
)
;
if
(
NS_WARN_IF
(
state
.
mFailedPutBytes
!
=
previousState
.
mFailedPutBytes
)
)
{
LOG
(
"
Stack
sample
too
big
for
local
storage
failed
to
store
%
u
"
"
bytes
"
unsigned
(
state
.
mFailedPutBytes
-
previousState
.
mFailedPutBytes
)
)
;
profiler_get_core_buffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
CompactStack
UniquePtr
<
ProfileChunkedBuffer
>
(
nullptr
)
)
;
}
else
if
(
state
.
mRangeEnd
-
previousState
.
mRangeEnd
>
=
*
profiler_get_core_buffer
(
)
.
BufferLength
(
)
)
{
LOG
(
"
Stack
sample
too
big
for
profiler
storage
needed
%
u
bytes
"
unsigned
(
state
.
mRangeEnd
-
previousState
.
mRangeEnd
)
)
;
profiler_get_core_buffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
CompactStack
UniquePtr
<
ProfileChunkedBuffer
>
(
nullptr
)
)
;
}
else
{
profiler_get_core_buffer
(
)
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
CompactStack
localBuffer
)
;
}
localBuffer
.
Clear
(
)
;
previousState
=
localBuffer
.
GetState
(
)
;
}
}
else
{
samplingState
=
SamplingState
:
:
NoStackSamplingCompleted
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
lul
:
:
LUL
*
lul
=
CorePS
:
:
Lul
(
)
;
if
(
lul
)
{
lul
-
>
MaybeShowStats
(
)
;
}
#
endif
TimeStamp
threadsSampled
=
TimeStamp
:
:
Now
(
)
;
{
AUTO_PROFILER_STATS
(
Sampler_FulfillChunkRequests
)
;
ActivePS
:
:
FulfillChunkRequests
(
lock
)
;
}
buffer
.
CollectOverheadStats
(
sampleStartDeltaMs
lockAcquired
-
sampleStart
expiredMarkersCleaned
-
lockAcquired
countersSampled
-
expiredMarkersCleaned
threadsSampled
-
countersSampled
)
;
}
else
{
samplingState
=
SamplingState
:
:
SamplingPaused
;
}
}
InvokePostSamplingCallbacks
(
std
:
:
move
(
postSamplingCallbacks
)
samplingState
)
;
ProfilerChild
:
:
ProcessPendingUpdate
(
)
;
if
(
ProfilerFeature
:
:
HasUnregisteredThreads
(
features
)
)
{
#
if
defined
(
GP_OS_windows
)
{
MonitorAutoLock
spyingStateLock
{
mSpyingStateMonitor
}
;
switch
(
mSpyingState
)
{
case
SpyingState
:
:
SamplerToSpy_Start
:
case
SpyingState
:
:
Spy_Working
:
+
+
mDelaySpyStart
;
break
;
case
SpyingState
:
:
Spy_Waiting
:
if
(
-
-
mDelaySpyStart
<
=
0
)
{
mDelaySpyStart
=
0
;
mSpyingState
=
SpyingState
:
:
SamplerToSpy_Start
;
mSpyingStateMonitor
.
NotifyAll
(
)
;
}
break
;
default
:
MOZ_ASSERT
(
mSpyingState
=
=
SpyingState
:
:
Spy_Initializing
|
|
mSpyingState
=
=
SpyingState
:
:
MainToSpy_Shutdown
|
|
mSpyingState
=
=
SpyingState
:
:
SpyToMain_ShuttingDown
)
;
break
;
}
}
#
else
SpyOnUnregisteredThreads
(
)
;
#
endif
}
scheduledSampleStart
+
=
sampleInterval
;
const
TimeStamp
beforeSleep
=
TimeStamp
:
:
Now
(
)
;
if
(
scheduledSampleStart
>
=
beforeSleep
)
{
const
uint32_t
sleepTimeUs
=
static_cast
<
uint32_t
>
(
(
scheduledSampleStart
-
beforeSleep
)
.
ToMicroseconds
(
)
)
;
if
(
sleepTimeUs
>
=
minimumIntervalSleepUs
)
{
SleepMicro
(
sleepTimeUs
)
;
}
else
{
SleepMicro
(
minimumIntervalSleepUs
)
;
}
}
else
{
scheduledSampleStart
=
beforeSleep
+
sampleInterval
;
SleepMicro
(
static_cast
<
uint32_t
>
(
sampleInterval
.
ToMicroseconds
(
)
)
)
;
}
}
InvokePostSamplingCallbacks
(
std
:
:
move
(
postSamplingCallbacks
)
samplingState
)
;
}
namespace
geckoprofiler
:
:
markers
{
struct
UnregisteredThreadLifetimeMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
UnregisteredThreadLifetime
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
base
:
:
ProcessId
aThreadId
const
ProfilerString8View
&
aName
const
ProfilerString8View
&
aEndEvent
)
{
aWriter
.
IntProperty
(
"
Thread
Id
"
aThreadId
)
;
aWriter
.
StringProperty
(
"
Thread
Name
"
aName
.
Length
(
)
!
=
0
?
aName
.
AsSpan
(
)
:
MakeStringSpan
(
"
~
Unnamed
~
"
)
)
;
if
(
aEndEvent
.
Length
(
)
!
=
0
)
{
aWriter
.
StringProperty
(
"
End
Event
"
aEndEvent
)
;
}
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyFormatSearchable
(
"
Thread
Id
"
MS
:
:
Format
:
:
Integer
MS
:
:
Searchable
:
:
Searchable
)
;
schema
.
AddKeyFormatSearchable
(
"
Thread
Name
"
MS
:
:
Format
:
:
String
MS
:
:
Searchable
:
:
Searchable
)
;
schema
.
AddKeyFormat
(
"
End
Event
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddStaticLabelValue
(
"
Note
"
"
Start
and
end
are
approximate
based
on
first
and
last
appearances
.
"
)
;
schema
.
SetChartLabel
(
"
{
marker
.
data
.
Thread
Name
}
(
tid
{
marker
.
data
.
Thread
Id
}
)
"
)
;
schema
.
SetTableLabel
(
"
{
marker
.
name
}
lifetime
"
)
;
return
schema
;
}
}
;
struct
UnregisteredThreadCPUMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
UnregisteredThreadCPU
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
base
:
:
ProcessId
aThreadId
int64_t
aCPUDiffNs
const
TimeStamp
&
aStart
const
TimeStamp
&
aEnd
)
{
aWriter
.
IntProperty
(
"
Thread
Id
"
aThreadId
)
;
aWriter
.
IntProperty
(
"
CPU
Time
"
aCPUDiffNs
)
;
aWriter
.
DoubleProperty
(
"
CPU
Utilization
"
double
(
aCPUDiffNs
)
/
(
(
aEnd
-
aStart
)
.
ToMicroseconds
(
)
*
1000
.
0
)
)
;
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyFormatSearchable
(
"
Thread
Id
"
MS
:
:
Format
:
:
Integer
MS
:
:
Searchable
:
:
Searchable
)
;
schema
.
AddKeyFormat
(
"
CPU
Time
"
MS
:
:
Format
:
:
Nanoseconds
)
;
schema
.
AddKeyFormat
(
"
CPU
Utilization
"
MS
:
:
Format
:
:
Percentage
)
;
schema
.
SetChartLabel
(
"
{
marker
.
data
.
CPU
Utilization
}
"
)
;
schema
.
SetTableLabel
(
"
{
marker
.
name
}
-
Activity
:
{
marker
.
data
.
CPU
Utilization
}
"
)
;
return
schema
;
}
}
;
}
static
bool
IsThreadIdRegistered
(
ProfilerThreadId
aThreadId
)
{
ThreadRegistry
:
:
LockedRegistry
lockedRegistry
;
const
auto
registryEnd
=
lockedRegistry
.
end
(
)
;
return
std
:
:
find_if
(
lockedRegistry
.
begin
(
)
registryEnd
[
aThreadId
]
(
const
ThreadRegistry
:
:
OffThreadRef
&
aOffThreadRef
)
{
return
aOffThreadRef
.
UnlockedConstReaderCRef
(
)
.
Info
(
)
.
ThreadId
(
)
=
=
aThreadId
;
}
)
!
=
registryEnd
;
}
static
nsAutoCString
MakeThreadInfoMarkerName
(
base
:
:
ProcessId
aThreadId
const
nsACString
&
aName
)
{
nsAutoCString
markerName
{
"
tid
"
}
;
markerName
.
AppendInt
(
int64_t
(
aThreadId
)
)
;
if
(
!
aName
.
IsEmpty
(
)
)
{
markerName
.
AppendLiteral
(
"
"
)
;
markerName
.
Append
(
aName
)
;
}
return
markerName
;
}
void
SamplerThread
:
:
SpyOnUnregisteredThreads
(
)
{
const
TimeStamp
unregisteredThreadSearchStart
=
TimeStamp
:
:
Now
(
)
;
const
base
:
:
ProcessId
currentProcessId
=
base
:
:
ProcessId
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
;
nsTArray
<
ProcInfoRequest
>
request
(
1
)
;
request
.
EmplaceBack
(
currentProcessId
ProcType
:
:
Unknown
"
"
_ns
nsTArray
<
WindowInfo
>
{
}
nsTArray
<
UtilityInfo
>
{
}
0
#
ifdef
XP_DARWIN
MACH_PORT_NULL
#
endif
)
;
const
ProcInfoPromise
:
:
ResolveOrRejectValue
procInfoOrError
=
GetProcInfoSync
(
std
:
:
move
(
request
)
)
;
if
(
!
procInfoOrError
.
IsResolve
(
)
)
{
PROFILER_MARKER_TEXT
(
"
Failed
unregistered
thread
search
"
PROFILER
MarkerOptions
(
MarkerThreadId
:
:
MainThread
(
)
MarkerTiming
:
:
IntervalUntilNowFrom
(
unregisteredThreadSearchStart
)
)
"
Could
not
retrieve
any
process
information
"
)
;
return
;
}
const
auto
&
procInfoHashMap
=
procInfoOrError
.
ResolveValue
(
)
;
const
auto
&
procInfoPtr
=
procInfoHashMap
.
readonlyThreadsafeLookup
(
currentProcessId
)
;
if
(
!
procInfoPtr
)
{
PROFILER_MARKER_TEXT
(
"
Failed
unregistered
thread
search
"
PROFILER
MarkerOptions
(
MarkerThreadId
:
:
MainThread
(
)
MarkerTiming
:
:
IntervalUntilNowFrom
(
unregisteredThreadSearchStart
)
)
"
Could
not
retrieve
information
about
this
process
"
)
;
return
;
}
PROFILER_MARKER_TEXT
(
"
Unregistered
thread
search
"
PROFILER
MarkerOptions
(
MarkerThreadId
:
:
MainThread
(
)
MarkerTiming
:
:
IntervalUntilNowFrom
(
unregisteredThreadSearchStart
)
)
"
Work
to
discover
threads
"
)
;
AUTO_PROFILER_MARKER_TEXT
(
"
Unregistered
thread
search
"
PROFILER
MarkerOptions
(
MarkerThreadId
:
:
MainThread
(
)
)
"
Work
to
process
discovered
threads
and
record
unregistered
ones
"
_ns
)
;
const
Span
<
const
mozilla
:
:
ThreadInfo
>
threads
=
procInfoPtr
-
>
value
(
)
.
threads
;
MOZ_ASSERT_IF
(
mLastSpying
.
IsNull
(
)
mSpiedThreads
.
IsEmpty
(
)
)
;
const
TimeStamp
previousSpying
=
std
:
:
exchange
(
mLastSpying
TimeStamp
:
:
Now
(
)
)
;
const
auto
threadsBegin
=
threads
.
begin
(
)
;
const
auto
threadsEnd
=
threads
.
end
(
)
;
for
(
size_t
spiedThreadIndexPlus1
=
mSpiedThreads
.
Length
(
)
;
spiedThreadIndexPlus1
!
=
0
;
-
-
spiedThreadIndexPlus1
)
{
const
SpiedThread
&
spiedThread
=
mSpiedThreads
[
spiedThreadIndexPlus1
-
1
]
;
if
(
std
:
:
find_if
(
threadsBegin
threadsEnd
[
spiedTid
=
spiedThread
.
mThreadId
]
(
const
mozilla
:
:
ThreadInfo
&
aThreadInfo
)
{
return
aThreadInfo
.
tid
=
=
spiedTid
;
}
)
=
=
threadsEnd
)
{
PROFILER_MARKER
(
MakeThreadInfoMarkerName
(
spiedThread
.
mThreadId
spiedThread
.
mName
)
PROFILER
MarkerOptions
(
MarkerThreadId
:
:
MainThread
(
)
MarkerTiming
:
:
IntervalEnd
(
previousSpying
+
(
mLastSpying
-
previousSpying
)
/
int64_t
(
2
)
)
)
UnregisteredThreadLifetimeMarker
spiedThread
.
mThreadId
spiedThread
.
mName
"
Thread
disappeared
"
)
;
mSpiedThreads
.
RemoveElementAt
(
spiedThreadIndexPlus1
-
1
)
;
}
}
for
(
const
mozilla
:
:
ThreadInfo
&
threadInfo
:
threads
)
{
size_t
spiedThreadIndex
=
mSpiedThreads
.
IndexOf
(
threadInfo
.
tid
)
;
if
(
IsThreadIdRegistered
(
ProfilerThreadId
:
:
FromNumber
(
threadInfo
.
tid
)
)
)
{
if
(
spiedThreadIndex
!
=
SpiedThreads
:
:
NoIndex
)
{
SpiedThread
&
spiedThread
=
mSpiedThreads
[
spiedThreadIndex
]
;
PROFILER_MARKER
(
MakeThreadInfoMarkerName
(
spiedThread
.
mThreadId
spiedThread
.
mName
)
PROFILER
MarkerOptions
(
MarkerThreadId
:
:
MainThread
(
)
MarkerTiming
:
:
IntervalEnd
(
previousSpying
+
(
mLastSpying
-
previousSpying
)
/
int64_t
(
2
)
)
)
UnregisteredThreadLifetimeMarker
spiedThread
.
mThreadId
spiedThread
.
mName
"
Thread
registered
itself
"
)
;
mSpiedThreads
.
RemoveElement
(
threadInfo
.
tid
)
;
}
}
else
{
if
(
spiedThreadIndex
=
=
SpiedThreads
:
:
NoIndex
)
{
NS_ConvertUTF16toUTF8
name
(
threadInfo
.
name
)
;
mSpiedThreads
.
EmplaceBack
(
threadInfo
.
tid
name
threadInfo
.
cpuTime
)
;
PROFILER_MARKER
(
MakeThreadInfoMarkerName
(
threadInfo
.
tid
name
)
PROFILER
MarkerOptions
(
MarkerThreadId
:
:
MainThread
(
)
MarkerTiming
:
:
IntervalStart
(
mLastSpying
-
(
mLastSpying
-
(
previousSpying
.
IsNull
(
)
?
unregisteredThreadSearchStart
:
previousSpying
)
)
/
int64_t
(
2
)
)
)
UnregisteredThreadLifetimeMarker
threadInfo
.
tid
name
"
"
)
;
}
else
{
SpiedThread
&
spiedThread
=
mSpiedThreads
[
spiedThreadIndex
]
;
int64_t
diffCPUTimeNs
=
int64_t
(
threadInfo
.
cpuTime
)
-
int64_t
(
spiedThread
.
mCPUTimeNs
)
;
spiedThread
.
mCPUTimeNs
=
threadInfo
.
cpuTime
;
if
(
diffCPUTimeNs
!
=
0
)
{
PROFILER_MARKER
(
MakeThreadInfoMarkerName
(
threadInfo
.
tid
spiedThread
.
mName
)
PROFILER
MarkerOptions
(
MarkerThreadId
:
:
MainThread
(
)
MarkerTiming
:
:
Interval
(
previousSpying
mLastSpying
)
)
UnregisteredThreadCPUMarker
threadInfo
.
tid
diffCPUTimeNs
previousSpying
mLastSpying
)
;
}
}
}
}
PROFILER_MARKER_TEXT
(
"
Unregistered
thread
search
"
PROFILER
MarkerOptions
(
MarkerThreadId
:
:
MainThread
(
)
MarkerTiming
:
:
IntervalUntilNowFrom
(
unregisteredThreadSearchStart
)
)
"
Work
to
discover
and
record
unregistered
threads
"
)
;
}
#
if
defined
(
GP_OS_windows
)
#
include
"
platform
-
win32
.
cpp
"
#
elif
defined
(
GP_OS_darwin
)
#
include
"
platform
-
macos
.
cpp
"
#
elif
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
|
|
defined
(
GP_OS_freebsd
)
#
include
"
platform
-
linux
-
android
.
cpp
"
#
else
#
error
"
bad
platform
"
#
endif
MOZ_DEFINE_MALLOC_SIZE_OF
(
GeckoProfilerMallocSizeOf
)
NS_IMETHODIMP
GeckoProfilerReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
size_t
profSize
=
0
;
size_t
lulSize
=
0
;
{
PSAutoLock
lock
;
if
(
CorePS
:
:
Exists
(
)
)
{
CorePS
:
:
AddSizeOf
(
lock
GeckoProfilerMallocSizeOf
profSize
lulSize
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
profSize
+
=
ActivePS
:
:
SizeOf
(
lock
GeckoProfilerMallocSizeOf
)
;
}
}
MOZ_COLLECT_REPORT
(
"
explicit
/
profiler
/
profiler
-
state
"
KIND_HEAP
UNITS_BYTES
profSize
"
Memory
used
by
the
Gecko
Profiler
'
s
global
state
(
excluding
memory
used
"
"
by
LUL
)
.
"
)
;
#
if
defined
(
USE_LUL_STACKWALK
)
MOZ_COLLECT_REPORT
(
"
explicit
/
profiler
/
lul
"
KIND_HEAP
UNITS_BYTES
lulSize
"
Memory
used
by
LUL
a
stack
unwinder
used
by
the
Gecko
Profiler
.
"
)
;
#
endif
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
GeckoProfilerReporter
nsIMemoryReporter
)
static
uint32_t
ParseFeature
(
const
char
*
aFeature
bool
aIsStartup
)
{
if
(
strcmp
(
aFeature
"
default
"
)
=
=
0
)
{
return
(
aIsStartup
?
(
DefaultFeatures
(
)
|
StartupExtraDefaultFeatures
(
)
)
:
DefaultFeatures
(
)
)
&
AvailableFeatures
(
)
;
}
#
define
PARSE_FEATURE_BIT
(
n_
str_
Name_
desc_
)
\
if
(
strcmp
(
aFeature
str_
)
=
=
0
)
{
\
return
ProfilerFeature
:
:
Name_
;
\
}
PROFILER_FOR_EACH_FEATURE
(
PARSE_FEATURE_BIT
)
#
undef
PARSE_FEATURE_BIT
printf
(
"
\
nUnrecognized
feature
\
"
%
s
\
"
.
\
n
\
n
"
aFeature
)
;
PrintUsage
(
)
;
return
0
;
}
uint32_t
ParseFeaturesFromStringArray
(
const
char
*
*
aFeatures
uint32_t
aFeatureCount
bool
aIsStartup
)
{
uint32_t
features
=
0
;
for
(
size_t
i
=
0
;
i
<
aFeatureCount
;
i
+
+
)
{
features
|
=
ParseFeature
(
aFeatures
[
i
]
aIsStartup
)
;
}
return
features
;
}
static
ProfilingStack
*
locked_register_thread
(
PSLockRef
aLock
ThreadRegistry
:
:
OffThreadRef
aOffThreadRef
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
VTUNE_REGISTER_THREAD
(
aOffThreadRef
.
UnlockedConstReaderCRef
(
)
.
Info
(
)
.
Name
(
)
)
;
if
(
ActivePS
:
:
Exists
(
aLock
)
)
{
ThreadProfilingFeatures
threadProfilingFeatures
=
ActivePS
:
:
ProfilingFeaturesForThread
(
aLock
aOffThreadRef
.
UnlockedConstReaderCRef
(
)
.
Info
(
)
)
;
if
(
threadProfilingFeatures
!
=
ThreadProfilingFeatures
:
:
NotProfiled
)
{
ThreadRegistry
:
:
OffThreadRef
:
:
RWFromAnyThreadWithLock
lockedRWFromAnyThread
=
aOffThreadRef
.
GetLockedRWFromAnyThread
(
)
;
ProfiledThreadData
*
profiledThreadData
=
ActivePS
:
:
AddLiveProfiledThread
(
aLock
MakeUnique
<
ProfiledThreadData
>
(
aOffThreadRef
.
UnlockedConstReaderCRef
(
)
.
Info
(
)
)
)
;
lockedRWFromAnyThread
-
>
SetProfilingFeaturesAndData
(
threadProfilingFeatures
profiledThreadData
aLock
)
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
lockedRWFromAnyThread
-
>
StartJSSampling
(
ActivePS
:
:
JSFlags
(
aLock
)
)
;
if
(
lockedRWFromAnyThread
-
>
GetJSContext
(
)
)
{
profiledThreadData
-
>
NotifyReceivedJSContext
(
ActivePS
:
:
Buffer
(
aLock
)
.
BufferRangeEnd
(
)
)
;
}
}
}
}
return
&
aOffThreadRef
.
UnlockedConstReaderAndAtomicRWRef
(
)
.
ProfilingStackRef
(
)
;
}
static
void
NotifyObservers
(
const
char
*
aTopic
nsISupports
*
aSubject
=
nullptr
)
{
if
(
!
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsISupports
>
subject
=
aSubject
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
NotifyObservers
"
[
=
]
{
NotifyObservers
(
aTopic
subject
)
;
}
)
)
;
return
;
}
if
(
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
)
{
os
-
>
NotifyObservers
(
aSubject
aTopic
nullptr
)
;
}
}
[
[
nodiscard
]
]
static
RefPtr
<
GenericPromise
>
NotifyProfilerStarted
(
const
PowerOfTwo32
&
aCapacity
const
Maybe
<
double
>
&
aDuration
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
)
{
nsTArray
<
nsCString
>
filtersArray
;
for
(
size_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
filtersArray
.
AppendElement
(
aFilters
[
i
]
)
;
}
nsCOMPtr
<
nsIProfilerStartParams
>
params
=
new
nsProfilerStartParams
(
aCapacity
.
Value
(
)
aDuration
aInterval
aFeatures
std
:
:
move
(
filtersArray
)
aActiveTabID
)
;
RefPtr
<
GenericPromise
>
startPromise
=
ProfilerParent
:
:
ProfilerStarted
(
params
)
;
NotifyObservers
(
"
profiler
-
started
"
params
)
;
return
startPromise
;
}
static
void
locked_profiler_start
(
PSLockRef
aLock
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
const
Maybe
<
double
>
&
aDuration
)
;
static
void
*
MozGlueLabelEnter
(
const
char
*
aLabel
const
char
*
aDynamicString
void
*
aSp
)
{
ThreadRegistration
:
:
OnThreadPtr
onThreadPtr
=
ThreadRegistration
:
:
GetOnThreadPtr
(
)
;
if
(
!
onThreadPtr
)
{
return
nullptr
;
}
ProfilingStack
&
profilingStack
=
onThreadPtr
-
>
UnlockedConstReaderAndAtomicRWRef
(
)
.
ProfilingStackRef
(
)
;
profilingStack
.
pushLabelFrame
(
aLabel
aDynamicString
aSp
JS
:
:
ProfilingCategoryPair
:
:
OTHER
)
;
return
&
profilingStack
;
}
static
void
MozGlueLabelExit
(
void
*
aProfilingStack
)
{
if
(
aProfilingStack
)
{
reinterpret_cast
<
ProfilingStack
*
>
(
aProfilingStack
)
-
>
pop
(
)
;
}
}
static
Vector
<
const
char
*
>
SplitAtCommas
(
const
char
*
aString
UniquePtr
<
char
[
]
>
&
aStorage
)
{
size_t
len
=
strlen
(
aString
)
;
aStorage
=
MakeUnique
<
char
[
]
>
(
len
+
1
)
;
PodCopy
(
aStorage
.
get
(
)
aString
len
+
1
)
;
Vector
<
const
char
*
>
array
;
size_t
currentElementStart
=
0
;
for
(
size_t
i
=
0
;
i
<
=
len
;
i
+
+
)
{
if
(
aStorage
[
i
]
=
=
'
'
)
{
aStorage
[
i
]
=
'
\
0
'
;
}
if
(
aStorage
[
i
]
=
=
'
\
0
'
)
{
if
(
currentElementStart
!
=
i
)
{
MOZ_RELEASE_ASSERT
(
array
.
append
(
&
aStorage
[
currentElementStart
]
)
)
;
}
currentElementStart
=
i
+
1
;
}
}
return
array
;
}
void
profiler_init_threadmanager
(
)
{
LOG
(
"
profiler_init_threadmanager
"
)
;
ThreadRegistration
:
:
WithOnThreadRef
(
[
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
aOnThreadRef
.
WithLockedRWOnThread
(
[
]
(
ThreadRegistration
:
:
LockedRWOnThread
&
aThreadData
)
{
if
(
!
aThreadData
.
GetEventTarget
(
)
)
{
aThreadData
.
ResetMainThread
(
NS_GetCurrentThreadNoCreate
(
)
)
;
}
}
)
;
}
)
;
}
static
const
char
*
get_size_suffix
(
const
char
*
str
)
{
const
char
*
ptr
=
str
;
while
(
isdigit
(
*
ptr
)
)
{
ptr
+
+
;
}
return
ptr
;
}
#
if
defined
(
GECKO_PROFILER_ASYNC_POSIX_SIGNAL_CONTROL
)
static
void
profiler_start_signal_handler
(
int
signal
siginfo_t
*
info
void
*
context
)
{
if
(
sAsyncSignalControlWriteFd
!
=
-
1
)
{
char
signalControlCharacter
=
sAsyncSignalControlCharStart
;
Unused
<
<
write
(
sAsyncSignalControlWriteFd
&
signalControlCharacter
sizeof
(
signalControlCharacter
)
)
;
}
}
static
void
profiler_stop_signal_handler
(
int
signal
siginfo_t
*
info
void
*
context
)
{
if
(
sAsyncSignalControlWriteFd
!
=
-
1
)
{
char
signalControlCharacter
=
sAsyncSignalControlCharStop
;
Unused
<
<
write
(
sAsyncSignalControlWriteFd
&
signalControlCharacter
sizeof
(
signalControlCharacter
)
)
;
}
}
#
endif
Maybe
<
nsAutoCString
>
profiler_find_dump_path
(
)
{
#
if
defined
(
XP_WIN
)
return
Nothing
(
)
;
#
else
Maybe
<
nsCOMPtr
<
nsIFile
>
>
directory
=
Nothing
(
)
;
nsAutoCString
path
;
{
PSAutoLock
lock
;
Maybe
<
nsCOMPtr
<
nsIFile
>
>
downloadDir
=
Nothing
(
)
;
downloadDir
=
CorePS
:
:
AsyncSignalDumpDirectory
(
lock
)
;
if
(
downloadDir
)
{
nsCOMPtr
<
nsIFile
>
d
;
downloadDir
.
value
(
)
-
>
Clone
(
getter_AddRefs
(
d
)
)
;
directory
=
Some
(
d
)
;
}
else
{
return
Nothing
(
)
;
}
}
if
(
directory
)
{
path
.
AppendPrintf
(
"
profile_
%
i_
%
i
.
json
"
XRE_GetProcessType
(
)
getpid
(
)
)
;
nsresult
rv
=
directory
.
value
(
)
-
>
AppendNative
(
path
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
"
Failed
to
append
path
to
profile
file
"
)
;
return
Nothing
(
)
;
}
rv
=
directory
.
value
(
)
-
>
GetNativePath
(
path
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
"
Failed
to
get
native
path
for
temp
path
"
)
;
return
Nothing
(
)
;
}
return
Some
(
path
)
;
}
return
Nothing
(
)
;
#
endif
}
void
profiler_start_from_signal
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
uint32_t
features
=
ProfilerFeature
:
:
JS
|
ProfilerFeature
:
:
StackWalk
|
ProfilerFeature
:
:
CPUUtilization
;
const
char
*
filters
[
]
=
{
"
*
"
}
;
if
(
MOZ_UNLIKELY
(
NS_IsMainThread
(
)
)
)
{
profiler_start
(
PROFILER_DEFAULT_SIGHANDLE_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
0
)
;
}
else
{
profiler_start
(
PROFILER_DEFAULT_SIGHANDLE_ENTRIES
PROFILER_DEFAULT_INTERVAL
features
filters
MOZ_ARRAY_LENGTH
(
filters
)
0
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
StartProfilerInChildProcesses
"
[
=
]
{
Unused
<
<
NotifyProfilerStarted
(
PROFILER_DEFAULT_SIGHANDLE_ENTRIES
Nothing
(
)
PROFILER_DEFAULT_INTERVAL
features
const_cast
<
const
char
*
*
>
(
filters
)
MOZ_ARRAY_LENGTH
(
filters
)
0
)
;
}
)
)
;
}
}
}
void
profiler_dump_and_stop
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
profiler_pause
(
)
;
auto
path
=
profiler_find_dump_path
(
)
;
if
(
!
path
)
{
LOG
(
"
Failed
to
find
a
valid
dump
path
to
write
profile
to
disk
"
)
;
profiler_stop
(
)
;
return
;
}
profiler_save_profile_to_file
(
path
.
value
(
)
.
get
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIProfiler
>
nsProfiler
(
do_GetService
(
"
mozilla
.
org
/
tools
/
profiler
;
1
"
)
)
;
nsProfiler
-
>
DumpProfileToFileAsyncNoJs
(
path
.
value
(
)
0
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
]
(
void_t
ok
)
{
LOG
(
"
Stopping
profiler
after
dumping
profile
to
disk
"
)
;
profiler_stop
(
)
;
}
[
]
(
nsresult
aRv
)
{
LOG
(
"
Dumping
to
disk
failed
with
error
\
"
%
s
\
"
stopping
"
"
profiler
.
"
GetStaticErrorName
(
aRv
)
)
;
profiler_stop
(
)
;
}
)
;
}
else
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
WriteProfileDataToFile
"
[
=
]
{
nsCOMPtr
<
nsIProfiler
>
nsProfiler
(
do_GetService
(
"
mozilla
.
org
/
tools
/
profiler
;
1
"
)
)
;
nsProfiler
-
>
DumpProfileToFileAsyncNoJs
(
path
.
value
(
)
0
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
]
(
void_t
ok
)
{
LOG
(
"
Stopping
profiler
after
dumping
profile
to
disk
"
)
;
profiler_stop
(
)
;
}
[
]
(
nsresult
aRv
)
{
LOG
(
"
Dumping
to
disk
failed
with
error
\
"
%
s
\
"
stopping
"
"
profiler
.
"
GetStaticErrorName
(
aRv
)
)
;
profiler_stop
(
)
;
}
)
;
}
)
)
;
}
}
#
if
defined
(
GECKO_PROFILER_ASYNC_POSIX_SIGNAL_CONTROL
)
void
profiler_init_signal_handlers
(
)
{
struct
sigaction
prof_start_sa
{
}
;
memset
(
&
prof_start_sa
0
sizeof
(
struct
sigaction
)
)
;
prof_start_sa
.
sa_sigaction
=
profiler_start_signal_handler
;
prof_start_sa
.
sa_flags
=
SA_RESTART
|
SA_SIGINFO
;
sigemptyset
(
&
prof_start_sa
.
sa_mask
)
;
DebugOnly
<
int
>
rstart
=
sigaction
(
SIGUSR1
&
prof_start_sa
nullptr
)
;
MOZ_ASSERT
(
rstart
=
=
0
"
Failed
to
install
Profiler
SIGUSR1
handler
"
)
;
struct
sigaction
prof_stop_sa
{
}
;
memset
(
&
prof_stop_sa
0
sizeof
(
struct
sigaction
)
)
;
prof_stop_sa
.
sa_sigaction
=
profiler_stop_signal_handler
;
prof_stop_sa
.
sa_flags
=
SA_RESTART
|
SA_SIGINFO
;
sigemptyset
(
&
prof_stop_sa
.
sa_mask
)
;
DebugOnly
<
int
>
rstop
=
sigaction
(
SIGUSR2
&
prof_stop_sa
nullptr
)
;
MOZ_ASSERT
(
rstop
=
=
0
"
Failed
to
install
Profiler
SIGUSR2
handler
"
)
;
}
#
endif
static
void
PollJSSamplingForCurrentThread
(
)
{
MOZ_ASSERT
(
!
PSAutoLock
:
:
IsLockedOnCurrentThread
(
)
)
;
ThreadRegistration
:
:
WithOnThreadRef
(
[
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
aOnThreadRef
.
WithLockedRWOnThread
(
[
]
(
ThreadRegistration
:
:
LockedRWOnThread
&
aThreadData
)
{
aThreadData
.
PollJSSampling
(
)
;
}
)
;
}
)
;
}
void
profiler_init
(
void
*
aStackTop
)
{
LOG
(
"
profiler_init
"
)
;
profiler_init_main_thread_id
(
)
;
VTUNE_INIT
(
)
;
ETW
:
:
Init
(
)
;
InitPerfetto
(
)
;
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
mozilla
:
:
profiler
:
:
memory_hooks_tls_init
(
)
;
#
endif
MOZ_RELEASE_ASSERT
(
!
CorePS
:
:
Exists
(
)
)
;
if
(
getenv
(
"
MOZ_PROFILER_HELP
"
)
)
{
PrintUsage
(
)
;
exit
(
0
)
;
}
SharedLibraryInfo
:
:
Initialize
(
)
;
uint32_t
features
=
DefaultFeatures
(
)
&
AvailableFeatures
(
)
;
UniquePtr
<
char
[
]
>
filterStorage
;
Vector
<
const
char
*
>
filters
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
"
GeckoMain
"
)
)
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
"
Compositor
"
)
)
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
"
Renderer
"
)
)
;
MOZ_RELEASE_ASSERT
(
filters
.
append
(
"
DOM
Worker
"
)
)
;
PowerOfTwo32
capacity
=
PROFILER_DEFAULT_ENTRIES
;
Maybe
<
double
>
duration
=
Nothing
(
)
;
double
interval
=
PROFILER_DEFAULT_INTERVAL
;
uint64_t
activeTabID
=
PROFILER_DEFAULT_ACTIVE_TAB_ID
;
ThreadRegistration
:
:
RegisterThread
(
kMainThreadName
aStackTop
)
;
{
PSAutoLock
lock
;
CorePS
:
:
Create
(
lock
)
;
{
ThreadRegistry
:
:
LockedRegistry
lockedRegistry
;
for
(
ThreadRegistry
:
:
OffThreadRef
offThreadRef
:
lockedRegistry
)
{
locked_register_thread
(
lock
offThreadRef
)
;
}
}
PlatformInit
(
lock
)
;
#
if
defined
(
GECKO_PROFILER_ASYNC_POSIX_SIGNAL_CONTROL
)
CorePS
:
:
SetAsyncSignalControlThread
(
new
AsyncSignalControlThread
)
;
profiler_init_signal_handlers
(
)
;
#
endif
#
if
defined
(
GP_OS_android
)
if
(
jni
:
:
IsAvailable
(
)
)
{
GeckoJavaSampler
:
:
Init
(
)
;
}
#
endif
const
char
*
startupEnv
=
getenv
(
"
MOZ_PROFILER_STARTUP
"
)
;
if
(
!
startupEnv
|
|
startupEnv
[
0
]
=
=
'
\
0
'
|
|
(
(
startupEnv
[
0
]
=
=
'
0
'
|
|
startupEnv
[
0
]
=
=
'
N
'
|
|
startupEnv
[
0
]
=
=
'
n
'
)
&
&
startupEnv
[
1
]
=
=
'
\
0
'
)
)
{
return
;
}
LOG
(
"
-
MOZ_PROFILER_STARTUP
is
set
"
)
;
capacity
=
PROFILER_DEFAULT_STARTUP_ENTRIES
;
const
char
*
startupCapacity
=
getenv
(
"
MOZ_PROFILER_STARTUP_ENTRIES
"
)
;
if
(
startupCapacity
&
&
startupCapacity
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
long
capacityLong
=
strtol
(
startupCapacity
nullptr
10
)
;
std
:
:
string_view
sizeSuffix
=
get_size_suffix
(
startupCapacity
)
;
if
(
sizeSuffix
=
=
"
KB
"
)
{
capacityLong
*
=
1000
/
scBytesPerEntry
;
}
else
if
(
sizeSuffix
=
=
"
KiB
"
)
{
capacityLong
*
=
1024
/
scBytesPerEntry
;
}
else
if
(
sizeSuffix
=
=
"
MB
"
)
{
capacityLong
*
=
(
1000
*
1000
)
/
scBytesPerEntry
;
}
else
if
(
sizeSuffix
=
=
"
MiB
"
)
{
capacityLong
*
=
(
1024
*
1024
)
/
scBytesPerEntry
;
}
else
if
(
sizeSuffix
=
=
"
GB
"
)
{
capacityLong
*
=
(
1000
*
1000
*
1000
)
/
scBytesPerEntry
;
}
else
if
(
sizeSuffix
=
=
"
GiB
"
)
{
capacityLong
*
=
(
1024
*
1024
*
1024
)
/
scBytesPerEntry
;
}
else
if
(
!
sizeSuffix
.
empty
(
)
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_ENTRIES
unit
must
be
one
of
the
"
"
following
:
KB
KiB
MB
MiB
GB
GiB
"
)
;
PrintUsage
(
)
;
exit
(
1
)
;
}
if
(
errno
=
=
0
&
&
capacityLong
>
0
&
&
static_cast
<
uint64_t
>
(
capacityLong
)
<
=
static_cast
<
uint64_t
>
(
INT32_MAX
)
)
{
capacity
=
PowerOfTwo32
(
ClampToAllowedEntries
(
static_cast
<
uint32_t
>
(
capacityLong
)
)
)
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_ENTRIES
=
%
u
"
unsigned
(
capacity
.
Value
(
)
)
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_ENTRIES
not
a
valid
integer
:
%
s
"
startupCapacity
)
;
PrintUsage
(
)
;
exit
(
1
)
;
}
}
const
char
*
startupDuration
=
getenv
(
"
MOZ_PROFILER_STARTUP_DURATION
"
)
;
if
(
startupDuration
&
&
startupDuration
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
double
durationVal
=
PR_strtod
(
startupDuration
nullptr
)
;
if
(
errno
=
=
0
&
&
durationVal
>
=
0
.
0
)
{
if
(
durationVal
>
0
.
0
)
{
duration
=
Some
(
durationVal
)
;
}
LOG
(
"
-
MOZ_PROFILER_STARTUP_DURATION
=
%
f
"
durationVal
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_DURATION
not
a
valid
float
:
%
s
"
startupDuration
)
;
PrintUsage
(
)
;
exit
(
1
)
;
}
}
const
char
*
startupInterval
=
getenv
(
"
MOZ_PROFILER_STARTUP_INTERVAL
"
)
;
if
(
startupInterval
&
&
startupInterval
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
interval
=
PR_strtod
(
startupInterval
nullptr
)
;
if
(
errno
=
=
0
&
&
interval
>
0
.
0
&
&
interval
<
=
PROFILER_MAX_INTERVAL
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_INTERVAL
=
%
f
"
interval
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_INTERVAL
not
a
valid
float
:
%
s
"
startupInterval
)
;
PrintUsage
(
)
;
exit
(
1
)
;
}
}
features
|
=
StartupExtraDefaultFeatures
(
)
&
AvailableFeatures
(
)
;
const
char
*
startupFeaturesBitfield
=
getenv
(
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
"
)
;
if
(
startupFeaturesBitfield
&
&
startupFeaturesBitfield
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
features
=
strtol
(
startupFeaturesBitfield
nullptr
10
)
;
if
(
errno
=
=
0
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
=
%
d
"
features
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
not
a
valid
integer
:
%
s
"
startupFeaturesBitfield
)
;
PrintUsage
(
)
;
exit
(
1
)
;
}
}
else
{
const
char
*
startupFeatures
=
getenv
(
"
MOZ_PROFILER_STARTUP_FEATURES
"
)
;
if
(
startupFeatures
)
{
UniquePtr
<
char
[
]
>
featureStringStorage
;
Vector
<
const
char
*
>
featureStringArray
=
SplitAtCommas
(
startupFeatures
featureStringStorage
)
;
features
=
ParseFeaturesFromStringArray
(
featureStringArray
.
begin
(
)
featureStringArray
.
length
(
)
true
)
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_FEATURES
=
%
d
"
features
)
;
}
}
const
char
*
startupFilters
=
getenv
(
"
MOZ_PROFILER_STARTUP_FILTERS
"
)
;
if
(
startupFilters
&
&
startupFilters
[
0
]
!
=
'
\
0
'
)
{
filters
=
SplitAtCommas
(
startupFilters
filterStorage
)
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_FILTERS
=
%
s
"
startupFilters
)
;
if
(
mozilla
:
:
profiler
:
:
detail
:
:
FiltersExcludePid
(
filters
)
)
{
LOG
(
"
-
>
This
process
is
excluded
and
won
'
t
be
profiled
"
)
;
return
;
}
}
const
char
*
startupActiveTabID
=
getenv
(
"
MOZ_PROFILER_STARTUP_ACTIVE_TAB_ID
"
)
;
if
(
startupActiveTabID
&
&
startupActiveTabID
[
0
]
!
=
'
\
0
'
)
{
std
:
:
istringstream
iss
(
startupActiveTabID
)
;
iss
>
>
activeTabID
;
if
(
!
iss
.
fail
(
)
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_ACTIVE_TAB_ID
=
%
"
PRIu64
activeTabID
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_ACTIVE_TAB_ID
not
a
valid
"
"
uint64_t
:
%
s
"
startupActiveTabID
)
;
PrintUsage
(
)
;
exit
(
1
)
;
}
}
locked_profiler_start
(
lock
capacity
interval
features
filters
.
begin
(
)
filters
.
length
(
)
activeTabID
duration
)
;
}
PollJSSamplingForCurrentThread
(
)
;
profiler_mark_thread_awake
(
)
;
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
ProfilerFeature
:
:
ShouldInstallMemoryHooks
(
features
)
)
{
ActivePS
:
:
SetMemoryCounter
(
mozilla
:
:
profiler
:
:
install_memory_hooks
(
)
)
;
}
else
{
mozilla
:
:
profiler
:
:
unregister_memory_counter
(
)
;
}
#
endif
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
Started
)
;
Unused
<
<
NotifyProfilerStarted
(
capacity
duration
interval
features
filters
.
begin
(
)
filters
.
length
(
)
0
)
;
}
static
void
locked_profiler_save_profile_to_file
(
PSLockRef
aLock
const
char
*
aFilename
const
PreRecordedMetaInformation
&
aPreRecordedMetaInformation
bool
aIsShuttingDown
)
;
static
SamplerThread
*
locked_profiler_stop
(
PSLockRef
aLock
)
;
void
profiler_shutdown
(
IsFastShutdown
aIsFastShutdown
)
{
LOG
(
"
profiler_shutdown
"
)
;
VTUNE_SHUTDOWN
(
)
;
ETW
:
:
Shutdown
(
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
profiler_is_active
(
)
)
{
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
Stopping
)
;
}
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
ShuttingDown
)
;
const
auto
preRecordedMetaInformation
=
PreRecordMetaInformation
(
true
)
;
ProfilerParent
:
:
ProfilerWillStopIfStarted
(
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
const
char
*
filename
=
getenv
(
"
MOZ_PROFILER_SHUTDOWN
"
)
;
if
(
filename
&
&
filename
[
0
]
!
=
'
\
0
'
)
{
locked_profiler_save_profile_to_file
(
lock
filename
preRecordedMetaInformation
true
)
;
}
if
(
aIsFastShutdown
=
=
IsFastShutdown
:
:
Yes
)
{
return
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
else
if
(
aIsFastShutdown
=
=
IsFastShutdown
:
:
Yes
)
{
return
;
}
CorePS
:
:
Destroy
(
lock
)
;
}
PollJSSamplingForCurrentThread
(
)
;
if
(
samplerThread
)
{
Unused
<
<
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
ThreadRegistration
:
:
UnregisterThread
(
)
;
}
static
bool
WriteProfileToJSONWriter
(
SpliceableChunkedJSONWriter
&
aWriter
double
aSinceTime
bool
aIsShuttingDown
ProfilerCodeAddressService
*
aService
mozilla
:
:
ProgressLogger
aProgressLogger
)
{
LOG
(
"
WriteProfileToJSONWriter
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
aWriter
.
Start
(
)
;
{
auto
rv
=
profiler_stream_json_for_this_process
(
aWriter
aSinceTime
aIsShuttingDown
aService
aProgressLogger
.
CreateSubLoggerFromTo
(
0_pc
"
WriteProfileToJSONWriter
:
"
"
profiler_stream_json_for_this_process
started
"
100_pc
"
WriteProfileToJSONWriter
:
"
"
profiler_stream_json_for_this_process
done
"
)
)
;
if
(
rv
.
isErr
(
)
)
{
return
false
;
}
aWriter
.
StartArrayProperty
(
"
processes
"
)
;
aWriter
.
EndArray
(
)
;
}
aWriter
.
End
(
)
;
return
!
aWriter
.
Failed
(
)
;
}
void
profiler_set_process_name
(
const
nsACString
&
aProcessName
const
nsACString
*
aETLDplus1
)
{
LOG
(
"
profiler_set_process_name
(
\
"
%
s
\
"
\
"
%
s
\
"
)
"
aProcessName
.
Data
(
)
aETLDplus1
?
aETLDplus1
-
>
Data
(
)
:
"
<
none
>
"
)
;
PSAutoLock
lock
;
CorePS
:
:
SetProcessName
(
lock
aProcessName
)
;
if
(
aETLDplus1
)
{
CorePS
:
:
SetETLDplus1
(
lock
*
aETLDplus1
)
;
}
}
UniquePtr
<
char
[
]
>
profiler_get_profile
(
double
aSinceTime
bool
aIsShuttingDown
)
{
LOG
(
"
profiler_get_profile
"
)
;
UniquePtr
<
ProfilerCodeAddressService
>
service
=
profiler_code_address_service_for_presymbolication
(
)
;
FailureLatchSource
failureLatch
;
SpliceableChunkedJSONWriter
b
{
failureLatch
}
;
if
(
!
WriteProfileToJSONWriter
(
b
aSinceTime
aIsShuttingDown
service
.
get
(
)
ProgressLogger
{
}
)
)
{
return
nullptr
;
}
return
b
.
ChunkedWriteFunc
(
)
.
CopyData
(
)
;
}
[
[
nodiscard
]
]
bool
profiler_get_profile_json
(
SpliceableChunkedJSONWriter
&
aSpliceableChunkedJSONWriter
double
aSinceTime
bool
aIsShuttingDown
mozilla
:
:
ProgressLogger
aProgressLogger
)
{
LOG
(
"
profiler_get_profile_json
"
)
;
UniquePtr
<
ProfilerCodeAddressService
>
service
=
profiler_code_address_service_for_presymbolication
(
)
;
return
WriteProfileToJSONWriter
(
aSpliceableChunkedJSONWriter
aSinceTime
aIsShuttingDown
service
.
get
(
)
aProgressLogger
.
CreateSubLoggerFromTo
(
0
.
1_pc
"
profiler_get_profile_json
:
WriteProfileToJSONWriter
started
"
99
.
9_pc
"
profiler_get_profile_json
:
WriteProfileToJSONWriter
done
"
)
)
;
}
void
profiler_get_start_params
(
int
*
aCapacity
Maybe
<
double
>
*
aDuration
double
*
aInterval
uint32_t
*
aFeatures
Vector
<
const
char
*
>
*
aFilters
uint64_t
*
aActiveTabID
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
NS_WARN_IF
(
!
aCapacity
)
|
|
NS_WARN_IF
(
!
aDuration
)
|
|
NS_WARN_IF
(
!
aInterval
)
|
|
NS_WARN_IF
(
!
aFeatures
)
|
|
NS_WARN_IF
(
!
aFilters
)
)
{
return
;
}
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
*
aCapacity
=
0
;
*
aDuration
=
Nothing
(
)
;
*
aInterval
=
0
;
*
aFeatures
=
0
;
*
aActiveTabID
=
0
;
aFilters
-
>
clear
(
)
;
return
;
}
*
aCapacity
=
ActivePS
:
:
Capacity
(
lock
)
.
Value
(
)
;
*
aDuration
=
ActivePS
:
:
Duration
(
lock
)
;
*
aInterval
=
ActivePS
:
:
Interval
(
lock
)
;
*
aFeatures
=
ActivePS
:
:
Features
(
lock
)
;
*
aActiveTabID
=
ActivePS
:
:
ActiveTabID
(
lock
)
;
const
Vector
<
std
:
:
string
>
&
filters
=
ActivePS
:
:
Filters
(
lock
)
;
MOZ_ALWAYS_TRUE
(
aFilters
-
>
resize
(
filters
.
length
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
filters
.
length
(
)
;
+
+
i
)
{
(
*
aFilters
)
[
i
]
=
filters
[
i
]
.
c_str
(
)
;
}
}
ProfileBufferControlledChunkManager
*
profiler_get_controlled_chunk_manager
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
NS_WARN_IF
(
!
ActivePS
:
:
Exists
(
lock
)
)
)
{
return
nullptr
;
}
return
&
ActivePS
:
:
ControlledChunkManager
(
lock
)
;
}
namespace
mozilla
{
void
GetProfilerEnvVarsForChildProcess
(
std
:
:
function
<
void
(
const
char
*
key
const
char
*
value
)
>
&
&
aSetEnv
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
aSetEnv
(
"
MOZ_PROFILER_STARTUP
"
"
"
)
;
return
;
}
aSetEnv
(
"
MOZ_PROFILER_STARTUP
"
"
1
"
)
;
if
(
getenv
(
"
MOZ_PROFILER_SHUTDOWN
"
)
)
{
aSetEnv
(
"
MOZ_PROFILER_SHUTDOWN
"
"
"
)
;
}
if
(
getenv
(
"
MOZ_PROFILER_STARTUP_NO_BASE
"
)
)
{
aSetEnv
(
"
MOZ_PROFILER_STARTUP_NO_BASE
"
"
1
"
)
;
}
auto
capacityString
=
Smprintf
(
"
%
u
"
unsigned
(
ActivePS
:
:
Capacity
(
lock
)
.
Value
(
)
)
)
;
aSetEnv
(
"
MOZ_PROFILER_STARTUP_ENTRIES
"
capacityString
.
get
(
)
)
;
nsCString
intervalString
;
intervalString
.
AppendFloat
(
ActivePS
:
:
Interval
(
lock
)
)
;
aSetEnv
(
"
MOZ_PROFILER_STARTUP_INTERVAL
"
intervalString
.
get
(
)
)
;
auto
featuresString
=
Smprintf
(
"
%
d
"
ActivePS
:
:
Features
(
lock
)
)
;
aSetEnv
(
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
"
featuresString
.
get
(
)
)
;
std
:
:
string
filtersString
;
const
Vector
<
std
:
:
string
>
&
filters
=
ActivePS
:
:
Filters
(
lock
)
;
for
(
uint32_t
i
=
0
;
i
<
filters
.
length
(
)
;
+
+
i
)
{
if
(
i
!
=
0
)
{
filtersString
+
=
"
"
;
}
filtersString
+
=
filters
[
i
]
;
}
aSetEnv
(
"
MOZ_PROFILER_STARTUP_FILTERS
"
filtersString
.
c_str
(
)
)
;
auto
activeTabIDString
=
Smprintf
(
"
%
"
PRIu64
ActivePS
:
:
ActiveTabID
(
lock
)
)
;
aSetEnv
(
"
MOZ_PROFILER_STARTUP_ACTIVE_TAB_ID
"
activeTabIDString
.
get
(
)
)
;
}
}
void
profiler_received_exit_profile
(
const
nsACString
&
aExitProfile
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
ActivePS
:
:
AddExitProfile
(
lock
aExitProfile
)
;
}
Vector
<
nsCString
>
profiler_move_exit_profiles
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
Vector
<
nsCString
>
profiles
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
profiles
=
ActivePS
:
:
MoveExitProfiles
(
lock
)
;
}
return
profiles
;
}
static
void
locked_profiler_save_profile_to_file
(
PSLockRef
aLock
const
char
*
aFilename
const
PreRecordedMetaInformation
&
aPreRecordedMetaInformation
bool
aIsShuttingDown
=
false
)
{
nsAutoCString
processedFilename
(
aFilename
)
;
const
auto
processInsertionIndex
=
processedFilename
.
Find
(
"
%
p
"
)
;
if
(
processInsertionIndex
!
=
kNotFound
)
{
nsAutoCString
process
;
process
.
AppendInt
(
profiler_current_process_id
(
)
.
ToNumber
(
)
)
;
processedFilename
.
Replace
(
processInsertionIndex
2
process
)
;
LOG
(
"
locked_profiler_save_profile_to_file
(
\
"
%
s
\
"
-
>
\
"
%
s
\
"
)
"
aFilename
processedFilename
.
get
(
)
)
;
}
else
{
LOG
(
"
locked_profiler_save_profile_to_file
(
\
"
%
s
\
"
)
"
aFilename
)
;
}
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
std
:
:
ofstream
stream
;
stream
.
open
(
processedFilename
.
get
(
)
)
;
if
(
stream
.
is_open
(
)
)
{
OStreamJSONWriteFunc
sw
(
stream
)
;
SpliceableJSONWriter
w
(
sw
FailureLatchInfallibleSource
:
:
Singleton
(
)
)
;
w
.
Start
(
)
;
{
Unused
<
<
locked_profiler_stream_json_for_this_process
(
aLock
w
0
aPreRecordedMetaInformation
aIsShuttingDown
nullptr
ProgressLogger
{
}
)
;
w
.
StartArrayProperty
(
"
processes
"
)
;
Vector
<
nsCString
>
exitProfiles
=
ActivePS
:
:
MoveExitProfiles
(
aLock
)
;
for
(
auto
&
exitProfile
:
exitProfiles
)
{
if
(
!
exitProfile
.
IsEmpty
(
)
&
&
exitProfile
[
0
]
!
=
'
*
'
)
{
w
.
Splice
(
exitProfile
)
;
}
}
w
.
EndArray
(
)
;
}
w
.
End
(
)
;
stream
.
close
(
)
;
}
}
void
profiler_save_profile_to_file
(
const
char
*
aFilename
)
{
LOG
(
"
profiler_save_profile_to_file
(
%
s
)
"
aFilename
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
const
auto
preRecordedMetaInformation
=
PreRecordMetaInformation
(
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
locked_profiler_save_profile_to_file
(
lock
aFilename
preRecordedMetaInformation
)
;
}
uint32_t
profiler_get_available_features
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
return
AvailableFeatures
(
)
;
}
Maybe
<
ProfilerBufferInfo
>
profiler_get_buffer_info
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
Nothing
(
)
;
}
return
Some
(
ActivePS
:
:
Buffer
(
lock
)
.
GetProfilerBufferInfo
(
)
)
;
}
static
void
TriggerPollJSSamplingOnMainThread
(
)
{
nsCOMPtr
<
nsIThread
>
mainThread
;
nsresult
rv
=
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mainThread
)
{
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
"
TriggerPollJSSamplingOnMainThread
"
[
]
(
)
{
PollJSSamplingForCurrentThread
(
)
;
}
)
;
SchedulerGroup
:
:
Dispatch
(
task
.
forget
(
)
)
;
}
}
static
void
locked_profiler_start
(
PSLockRef
aLock
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
const
Maybe
<
double
>
&
aDuration
)
{
TimeStamp
profilingStartTime
=
TimeStamp
:
:
Now
(
)
;
if
(
LOG_TEST
)
{
LOG
(
"
locked_profiler_start
"
)
;
LOG
(
"
-
capacity
=
%
u
"
unsigned
(
aCapacity
.
Value
(
)
)
)
;
LOG
(
"
-
duration
=
%
.
2f
"
aDuration
?
*
aDuration
:
-
1
)
;
LOG
(
"
-
interval
=
%
.
2f
"
aInterval
)
;
LOG
(
"
-
tab
ID
=
%
"
PRIu64
aActiveTabID
)
;
#
define
LOG_FEATURE
(
n_
str_
Name_
desc_
)
\
if
(
ProfilerFeature
:
:
Has
#
#
Name_
(
aFeatures
)
)
{
\
LOG
(
"
-
feature
=
%
s
"
str_
)
;
\
}
PROFILER_FOR_EACH_FEATURE
(
LOG_FEATURE
)
#
undef
LOG_FEATURE
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
i
+
+
)
{
LOG
(
"
-
threads
=
%
s
"
aFilters
[
i
]
)
;
}
}
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
!
ActivePS
:
:
Exists
(
aLock
)
)
;
if
(
NS_IsMainThread
(
)
)
{
mozilla
:
:
base_profiler_markers_detail
:
:
EnsureBufferForMainThreadAddMarker
(
)
;
}
else
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
EnsureBufferForMainThreadAddMarker
"
&
mozilla
:
:
base_profiler_markers_detail
:
:
EnsureBufferForMainThreadAddMarker
)
)
;
}
UniquePtr
<
ProfileBufferChunkManagerWithLocalLimit
>
baseChunkManager
;
bool
profilersHandOver
=
false
;
if
(
baseprofiler
:
:
profiler_is_active
(
)
)
{
baseChunkManager
=
baseprofiler
:
:
detail
:
:
ExtractBaseProfilerChunkManager
(
)
;
if
(
baseChunkManager
)
{
profilersHandOver
=
true
;
if
(
const
TimeStamp
baseProfilingStartTime
=
baseprofiler
:
:
detail
:
:
GetProfilingStartTime
(
)
;
!
baseProfilingStartTime
.
IsNull
(
)
)
{
profilingStartTime
=
baseProfilingStartTime
;
}
BASE_PROFILER_MARKER_TEXT
(
"
Profilers
handover
"
PROFILER
MarkerTiming
:
:
IntervalStart
(
)
"
Transition
from
Base
to
Gecko
Profiler
some
data
may
be
missing
"
)
;
}
baseprofiler
:
:
profiler_stop
(
)
;
}
#
if
defined
(
GP_PLAT_amd64_windows
)
|
|
defined
(
GP_PLAT_arm64_windows
)
mozilla
:
:
WindowsStackWalkInitialization
(
)
;
#
endif
PowerOfTwo32
capacity
=
(
aCapacity
.
Value
(
)
>
=
ProfileBufferChunkManager
:
:
scExpectedMaximumStackSize
/
scBytesPerEntry
)
?
aCapacity
:
PROFILER_DEFAULT_ENTRIES
;
Maybe
<
double
>
duration
=
aDuration
;
if
(
aDuration
&
&
*
aDuration
<
=
0
)
{
duration
=
Nothing
(
)
;
}
double
interval
=
aInterval
>
0
?
aInterval
:
PROFILER_DEFAULT_INTERVAL
;
ActivePS
:
:
Create
(
aLock
profilingStartTime
capacity
interval
aFeatures
aFilters
aFilterCount
aActiveTabID
duration
std
:
:
move
(
baseChunkManager
)
)
;
MOZ_ASSERT
(
ActivePS
:
:
Exists
(
aLock
)
)
;
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
bool
isMainThreadBeingProfiled
=
false
;
#
endif
ThreadRegistry
:
:
LockedRegistry
lockedRegistry
;
for
(
ThreadRegistry
:
:
OffThreadRef
offThreadRef
:
lockedRegistry
)
{
const
ThreadRegistrationInfo
&
info
=
offThreadRef
.
UnlockedConstReaderCRef
(
)
.
Info
(
)
;
ThreadProfilingFeatures
threadProfilingFeatures
=
ActivePS
:
:
ProfilingFeaturesForThread
(
aLock
info
)
;
if
(
threadProfilingFeatures
!
=
ThreadProfilingFeatures
:
:
NotProfiled
)
{
ThreadRegistry
:
:
OffThreadRef
:
:
RWFromAnyThreadWithLock
lockedThreadData
=
offThreadRef
.
GetLockedRWFromAnyThread
(
)
;
ProfiledThreadData
*
profiledThreadData
=
ActivePS
:
:
AddLiveProfiledThread
(
aLock
MakeUnique
<
ProfiledThreadData
>
(
info
)
)
;
lockedThreadData
-
>
SetProfilingFeaturesAndData
(
threadProfilingFeatures
profiledThreadData
aLock
)
;
lockedThreadData
-
>
GetNewCpuTimeInNs
(
)
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
lockedThreadData
-
>
StartJSSampling
(
ActivePS
:
:
JSFlags
(
aLock
)
)
;
if
(
!
lockedThreadData
.
GetLockedRWOnThread
(
)
&
&
info
.
IsMainThread
(
)
)
{
TriggerPollJSSamplingOnMainThread
(
)
;
}
}
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
info
.
IsMainThread
(
)
)
{
isMainThreadBeingProfiled
=
true
;
}
#
endif
lockedThreadData
-
>
ReinitializeOnResume
(
)
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
&
&
lockedThreadData
-
>
GetJSContext
(
)
)
{
profiledThreadData
-
>
NotifyReceivedJSContext
(
0
)
;
}
}
}
RegisterProfilerLabelEnterExit
(
MozGlueLabelEnter
MozGlueLabelExit
)
;
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
int
javaInterval
=
interval
;
if
(
javaInterval
<
1
)
{
javaInterval
=
1
;
}
JNIEnv
*
env
=
jni
:
:
GetEnvForThread
(
)
;
const
auto
&
filters
=
ActivePS
:
:
Filters
(
aLock
)
;
jni
:
:
ObjectArray
:
:
LocalRef
javaFilters
=
jni
:
:
ObjectArray
:
:
New
<
jni
:
:
String
>
(
filters
.
length
(
)
)
;
for
(
size_t
i
=
0
;
i
<
filters
.
length
(
)
;
i
+
+
)
{
javaFilters
-
>
SetElement
(
i
jni
:
:
StringParam
(
filters
[
i
]
.
data
(
)
env
)
)
;
}
java
:
:
GeckoJavaSampler
:
:
Start
(
javaFilters
javaInterval
std
:
:
round
(
(
double
)
(
capacity
.
Value
(
)
)
*
interval
/
(
double
)
(
javaInterval
)
)
)
;
}
#
endif
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
ActivePS
:
:
FeatureNativeAllocations
(
aLock
)
)
{
if
(
isMainThreadBeingProfiled
)
{
mozilla
:
:
profiler
:
:
enable_native_allocations
(
)
;
}
else
{
NS_WARNING
(
"
The
nativeallocations
feature
is
turned
on
but
the
main
thread
is
"
"
not
being
profiled
.
The
allocations
are
only
stored
on
the
main
"
"
thread
.
"
)
;
}
}
#
endif
if
(
ProfilerFeature
:
:
HasAudioCallbackTracing
(
aFeatures
)
)
{
StartAudioCallbackTracing
(
)
;
}
RacyFeatures
:
:
SetActive
(
ActivePS
:
:
Features
(
aLock
)
)
;
if
(
profilersHandOver
)
{
PROFILER_MARKER_UNTYPED
(
"
Profilers
handover
"
PROFILER
MarkerTiming
:
:
IntervalEnd
(
)
)
;
}
}
RefPtr
<
GenericPromise
>
profiler_start
(
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
const
Maybe
<
double
>
&
aDuration
)
{
LOG
(
"
profiler_start
"
)
;
ProfilerParent
:
:
ProfilerWillStopIfStarted
(
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
profiler_init
(
nullptr
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
locked_profiler_start
(
lock
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aActiveTabID
aDuration
)
;
}
PollJSSamplingForCurrentThread
(
)
;
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
ProfilerFeature
:
:
ShouldInstallMemoryHooks
(
aFeatures
)
)
{
ActivePS
:
:
SetMemoryCounter
(
mozilla
:
:
profiler
:
:
install_memory_hooks
(
)
)
;
}
else
{
mozilla
:
:
profiler
:
:
unregister_memory_counter
(
)
;
}
#
endif
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
Started
)
;
if
(
samplerThread
)
{
Unused
<
<
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
return
NotifyProfilerStarted
(
aCapacity
aDuration
aInterval
aFeatures
aFilters
aFilterCount
aActiveTabID
)
;
}
void
profiler_ensure_started
(
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
const
Maybe
<
double
>
&
aDuration
)
{
LOG
(
"
profiler_ensure_started
"
)
;
ProfilerParent
:
:
ProfilerWillStopIfStarted
(
)
;
bool
startedProfiler
=
false
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
profiler_init
(
nullptr
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
if
(
!
ActivePS
:
:
Equals
(
lock
aCapacity
aDuration
aInterval
aFeatures
aFilters
aFilterCount
aActiveTabID
)
)
{
samplerThread
=
locked_profiler_stop
(
lock
)
;
locked_profiler_start
(
lock
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aActiveTabID
aDuration
)
;
startedProfiler
=
true
;
}
}
else
{
locked_profiler_start
(
lock
aCapacity
aInterval
aFeatures
aFilters
aFilterCount
aActiveTabID
aDuration
)
;
startedProfiler
=
true
;
}
}
PollJSSamplingForCurrentThread
(
)
;
if
(
samplerThread
)
{
Unused
<
<
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
if
(
startedProfiler
)
{
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
Started
)
;
Unused
<
<
NotifyProfilerStarted
(
aCapacity
aDuration
aInterval
aFeatures
aFilters
aFilterCount
aActiveTabID
)
;
}
}
[
[
nodiscard
]
]
static
SamplerThread
*
locked_profiler_stop
(
PSLockRef
aLock
)
{
LOG
(
"
locked_profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
RacyFeatures
:
:
SetInactive
(
)
;
if
(
ActivePS
:
:
FeatureAudioCallbackTracing
(
aLock
)
)
{
StopAudioCallbackTracing
(
)
;
}
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
java
:
:
GeckoJavaSampler
:
:
Stop
(
)
;
}
#
endif
RegisterProfilerLabelEnterExit
(
nullptr
nullptr
)
;
ThreadRegistry
:
:
LockedRegistry
lockedRegistry
;
for
(
ThreadRegistry
:
:
OffThreadRef
offThreadRef
:
lockedRegistry
)
{
if
(
offThreadRef
.
UnlockedRWForLockedProfilerRef
(
)
.
ProfilingFeatures
(
)
=
=
ThreadProfilingFeatures
:
:
NotProfiled
)
{
continue
;
}
ThreadRegistry
:
:
OffThreadRef
:
:
RWFromAnyThreadWithLock
lockedThreadData
=
offThreadRef
.
GetLockedRWFromAnyThread
(
)
;
lockedThreadData
-
>
ClearProfilingFeaturesAndData
(
aLock
)
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
lockedThreadData
-
>
StopJSSampling
(
)
;
if
(
!
lockedThreadData
.
GetLockedRWOnThread
(
)
&
&
lockedThreadData
-
>
Info
(
)
.
IsMainThread
(
)
)
{
TriggerPollJSSamplingOnMainThread
(
)
;
}
}
}
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
if
(
ActivePS
:
:
FeatureNativeAllocations
(
aLock
)
&
&
ActivePS
:
:
ShouldInstallMemoryHooks
(
aLock
)
)
{
mozilla
:
:
profiler
:
:
disable_native_allocations
(
)
;
}
#
endif
SamplerThread
*
samplerThread
=
ActivePS
:
:
Destroy
(
aLock
)
;
samplerThread
-
>
Stop
(
aLock
)
;
if
(
NS_IsMainThread
(
)
)
{
mozilla
:
:
base_profiler_markers_detail
:
:
ReleaseBufferForMainThreadAddMarker
(
)
;
}
else
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ReleaseBufferForMainThreadAddMarker
"
&
mozilla
:
:
base_profiler_markers_detail
:
:
ReleaseBufferForMainThreadAddMarker
)
)
;
}
return
samplerThread
;
}
RefPtr
<
GenericPromise
>
profiler_stop
(
)
{
LOG
(
"
profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
profiler_is_active
(
)
)
{
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
Stopping
)
;
}
ProfilerParent
:
:
ProfilerWillStopIfStarted
(
)
;
#
if
defined
(
MOZ_REPLACE_MALLOC
)
&
&
defined
(
MOZ_PROFILER_MEMORY
)
mozilla
:
:
profiler
:
:
remove_memory_hooks
(
)
;
#
endif
SamplerThread
*
samplerThread
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
PollJSSamplingForCurrentThread
(
)
;
RefPtr
<
GenericPromise
>
promise
=
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
return
promise
;
}
bool
profiler_is_paused
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
return
ActivePS
:
:
IsPaused
(
lock
)
;
}
bool
profiler_callback_after_sampling
(
PostSamplingCallback
&
&
aCallback
)
{
LOG
(
"
profiler_callback_after_sampling
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
return
ActivePS
:
:
AppendPostSamplingCallback
(
lock
std
:
:
move
(
aCallback
)
)
;
}
void
profiler_lookup_async_signal_dump_directory
(
)
{
#
if
!
defined
(
XP_WIN
)
LOG
(
"
profiler_lookup_async_signal_dump_directory
"
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
We
can
only
get
access
to
the
directory
service
from
the
main
thread
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
nsresult
rv
;
LOG
(
"
Checking
if
MOZ_UPLOAD_DIR
exists
"
)
;
const
char
*
mozUploadDir
=
getenv
(
"
MOZ_UPLOAD_DIR
"
)
;
if
(
mozUploadDir
&
&
mozUploadDir
[
0
]
!
=
'
\
0
'
)
{
LOG
(
"
Found
MOZ_UPLOAD_DIR
at
:
%
s
"
mozUploadDir
)
;
nsCOMPtr
<
nsIFile
>
mozUploadDirFile
=
do_CreateInstance
(
"
mozilla
.
org
/
file
/
local
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
"
Failed
to
create
nsIFile
for
MOZ_UPLOAD_DIR
:
%
s
Error
:
%
s
"
mozUploadDir
GetStaticErrorName
(
rv
)
)
;
return
;
}
rv
=
mozUploadDirFile
-
>
InitWithNativePath
(
nsDependentCString
(
mozUploadDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
"
Failed
to
assign
a
filepath
while
creating
MOZ_UPLOAD_DIR
file
"
"
%
s
Error
%
s
"
mozUploadDir
GetStaticErrorName
(
rv
)
)
;
return
;
}
CorePS
:
:
SetAsyncSignalDumpDirectory
(
lock
Some
(
mozUploadDirFile
)
)
;
}
else
{
LOG
(
"
Defaulting
to
the
user
'
s
Download
directory
for
profile
dumps
"
)
;
nsCOMPtr
<
nsIFile
>
tDownloadDir
;
rv
=
NS_GetSpecialDirectory
(
NS_OS_DEFAULT_DOWNLOAD_DIR
getter_AddRefs
(
tDownloadDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
"
Failed
to
find
download
directory
.
Profiler
signal
handling
will
"
"
not
be
able
to
save
to
disk
.
Error
:
%
s
"
GetStaticErrorName
(
rv
)
)
;
}
else
{
CorePS
:
:
SetAsyncSignalDumpDirectory
(
lock
Some
(
tDownloadDir
)
)
;
}
}
#
endif
}
RefPtr
<
GenericPromise
>
profiler_pause
(
)
{
LOG
(
"
profiler_pause
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
Pausing
)
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
lock
)
&
&
!
ActivePS
:
:
IsSamplingPaused
(
lock
)
)
{
java
:
:
GeckoJavaSampler
:
:
PauseSampling
(
)
;
}
#
endif
RacyFeatures
:
:
SetPaused
(
)
;
ActivePS
:
:
SetIsPaused
(
lock
true
)
;
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
Pause
(
profiler_time
(
)
)
)
;
}
RefPtr
<
GenericPromise
>
promise
=
ProfilerParent
:
:
ProfilerPaused
(
)
;
NotifyObservers
(
"
profiler
-
paused
"
)
;
return
promise
;
}
RefPtr
<
GenericPromise
>
profiler_resume
(
)
{
LOG
(
"
profiler_resume
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
Resume
(
profiler_time
(
)
)
)
;
ActivePS
:
:
SetIsPaused
(
lock
false
)
;
RacyFeatures
:
:
SetUnpaused
(
)
;
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
lock
)
&
&
!
ActivePS
:
:
IsSamplingPaused
(
lock
)
)
{
java
:
:
GeckoJavaSampler
:
:
UnpauseSampling
(
)
;
}
#
endif
}
RefPtr
<
GenericPromise
>
promise
=
ProfilerParent
:
:
ProfilerResumed
(
)
;
NotifyObservers
(
"
profiler
-
resumed
"
)
;
invoke_profiler_state_change_callbacks
(
ProfilingState
:
:
Resumed
)
;
return
promise
;
}
bool
profiler_is_sampling_paused
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
return
ActivePS
:
:
IsSamplingPaused
(
lock
)
;
}
RefPtr
<
GenericPromise
>
profiler_pause_sampling
(
)
{
LOG
(
"
profiler_pause_sampling
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
lock
)
&
&
!
ActivePS
:
:
IsSamplingPaused
(
lock
)
)
{
java
:
:
GeckoJavaSampler
:
:
PauseSampling
(
)
;
}
#
endif
RacyFeatures
:
:
SetSamplingPaused
(
)
;
ActivePS
:
:
SetIsSamplingPaused
(
lock
true
)
;
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
PauseSampling
(
profiler_time
(
)
)
)
;
}
RefPtr
<
GenericPromise
>
promise
=
ProfilerParent
:
:
ProfilerPausedSampling
(
)
;
NotifyObservers
(
"
profiler
-
paused
-
sampling
"
)
;
return
promise
;
}
RefPtr
<
GenericPromise
>
profiler_resume_sampling
(
)
{
LOG
(
"
profiler_resume_sampling
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
ResumeSampling
(
profiler_time
(
)
)
)
;
ActivePS
:
:
SetIsSamplingPaused
(
lock
false
)
;
RacyFeatures
:
:
SetSamplingUnpaused
(
)
;
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
lock
)
&
&
!
ActivePS
:
:
IsSamplingPaused
(
lock
)
)
{
java
:
:
GeckoJavaSampler
:
:
UnpauseSampling
(
)
;
}
#
endif
}
RefPtr
<
GenericPromise
>
promise
=
ProfilerParent
:
:
ProfilerResumedSampling
(
)
;
NotifyObservers
(
"
profiler
-
resumed
-
sampling
"
)
;
return
promise
;
}
bool
profiler_feature_active
(
uint32_t
aFeature
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
return
RacyFeatures
:
:
IsActiveWithFeature
(
aFeature
)
;
}
bool
profiler_active_without_feature
(
uint32_t
aFeature
)
{
return
RacyFeatures
:
:
IsActiveWithoutFeature
(
aFeature
)
;
}
void
profiler_write_active_configuration
(
JSONWriter
&
aWriter
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
ActivePS
:
:
WriteActiveConfiguration
(
lock
aWriter
)
;
}
void
profiler_add_sampled_counter
(
BaseProfilerCount
*
aCounter
)
{
DEBUG_LOG
(
"
profiler_add_sampled_counter
(
%
s
)
"
aCounter
-
>
mLabel
)
;
PSAutoLock
lock
;
locked_profiler_add_sampled_counter
(
lock
aCounter
)
;
}
void
profiler_remove_sampled_counter
(
BaseProfilerCount
*
aCounter
)
{
DEBUG_LOG
(
"
profiler_remove_sampled_counter
(
%
s
)
"
aCounter
-
>
mLabel
)
;
PSAutoLock
lock
;
locked_profiler_remove_sampled_counter
(
lock
aCounter
)
;
}
void
profiler_count_bandwidth_bytes
(
int64_t
aCount
)
{
NS_ASSERTION
(
profiler_feature_active
(
ProfilerFeature
:
:
Bandwidth
)
"
Should
not
call
profiler_count_bandwidth_bytes
when
the
"
"
Bandwidth
feature
is
not
set
"
)
;
ProfilerBandwidthCounter
*
counter
=
CorePS
:
:
GetBandwidthCounter
(
)
;
if
(
MOZ_UNLIKELY
(
!
counter
)
)
{
counter
=
new
ProfilerBandwidthCounter
(
)
;
CorePS
:
:
SetBandwidthCounter
(
counter
)
;
}
counter
-
>
Add
(
aCount
)
;
}
ProfilingStack
*
profiler_register_thread
(
const
char
*
aName
void
*
aGuessStackTop
)
{
DEBUG_LOG
(
"
profiler_register_thread
(
%
s
)
"
aName
)
;
return
ThreadRegistration
:
:
RegisterThread
(
aName
aGuessStackTop
)
;
}
void
ThreadRegistry
:
:
Register
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
if
(
!
aOnThreadRef
.
UnlockedConstReaderCRef
(
)
.
Info
(
)
.
IsMainThread
(
)
)
{
(
void
)
NS_GetCurrentThread
(
)
;
NS_SetCurrentThreadName
(
aOnThreadRef
.
UnlockedConstReaderCRef
(
)
.
Info
(
)
.
Name
(
)
)
;
}
{
PSAutoLock
lock
;
{
RegistryLockExclusive
lock
{
sRegistryMutex
}
;
MOZ_RELEASE_ASSERT
(
sRegistryContainer
.
append
(
OffThreadRef
{
aOnThreadRef
}
)
)
;
}
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
;
}
(
void
)
locked_register_thread
(
lock
OffThreadRef
{
aOnThreadRef
}
)
;
}
PollJSSamplingForCurrentThread
(
)
;
}
void
profiler_unregister_thread
(
)
{
ThreadRegistration
:
:
UnregisterThread
(
)
;
}
static
void
locked_unregister_thread
(
PSLockRef
lock
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
;
}
ThreadRegistration
:
:
OnThreadRef
:
:
RWOnThreadWithLock
lockedThreadData
=
aOnThreadRef
.
GetLockedRWOnThread
(
)
;
ProfiledThreadData
*
profiledThreadData
=
lockedThreadData
-
>
GetProfiledThreadData
(
lock
)
;
lockedThreadData
-
>
ClearProfilingFeaturesAndData
(
lock
)
;
MOZ_RELEASE_ASSERT
(
lockedThreadData
-
>
Info
(
)
.
ThreadId
(
)
=
=
profiler_current_thread_id
(
)
"
Thread
being
unregistered
has
changed
its
TID
"
)
;
DEBUG_LOG
(
"
profiler_unregister_thread
:
%
s
"
lockedThreadData
-
>
Info
(
)
.
Name
(
)
)
;
if
(
profiledThreadData
&
&
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
UnregisterThread
(
lock
profiledThreadData
)
;
}
}
void
ThreadRegistry
:
:
Unregister
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
PSAutoLock
psLock
;
locked_unregister_thread
(
psLock
aOnThreadRef
)
;
RegistryLockExclusive
lock
{
sRegistryMutex
}
;
for
(
OffThreadRef
&
thread
:
sRegistryContainer
)
{
if
(
thread
.
IsPointingAt
(
*
aOnThreadRef
.
mThreadRegistration
)
)
{
sRegistryContainer
.
erase
(
&
thread
)
;
break
;
}
}
}
void
profiler_register_page
(
uint64_t
aTabID
uint64_t
aInnerWindowID
const
nsCString
&
aUrl
uint64_t
aEmbedderInnerWindowID
bool
aIsPrivateBrowsing
)
{
DEBUG_LOG
(
"
profiler_register_page
(
%
"
PRIu64
"
%
"
PRIu64
"
%
s
%
"
PRIu64
"
%
s
)
"
aTabID
aInnerWindowID
aUrl
.
get
(
)
aEmbedderInnerWindowID
aIsPrivateBrowsing
?
"
true
"
:
"
false
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
;
RefPtr
<
PageInformation
>
pageInfo
=
new
PageInformation
(
aTabID
aInnerWindowID
aUrl
aEmbedderInnerWindowID
aIsPrivateBrowsing
)
;
CorePS
:
:
AppendRegisteredPage
(
lock
std
:
:
move
(
pageInfo
)
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
DiscardExpiredPages
(
lock
)
;
}
}
void
profiler_unregister_page
(
uint64_t
aRegisteredInnerWindowID
)
{
PSAutoLock
lock
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
UnregisterPage
(
lock
aRegisteredInnerWindowID
)
;
}
else
{
CorePS
:
:
RemoveRegisteredPage
(
lock
aRegisteredInnerWindowID
)
;
}
}
void
profiler_clear_all_pages
(
)
{
{
PSAutoLock
lock
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
;
}
CorePS
:
:
ClearRegisteredPages
(
lock
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
ClearUnregisteredPages
(
lock
)
;
}
}
ProfilerParent
:
:
ClearAllPages
(
)
;
}
namespace
geckoprofiler
:
:
markers
:
:
detail
{
Maybe
<
uint64_t
>
profiler_get_inner_window_id_from_docshell
(
nsIDocShell
*
aDocshell
)
{
Maybe
<
uint64_t
>
innerWindowID
=
Nothing
(
)
;
if
(
aDocshell
)
{
auto
outerWindow
=
aDocshell
-
>
GetWindow
(
)
;
if
(
outerWindow
)
{
auto
innerWindow
=
outerWindow
-
>
GetCurrentInnerWindow
(
)
;
if
(
innerWindow
)
{
innerWindowID
=
Some
(
innerWindow
-
>
WindowID
(
)
)
;
}
}
}
return
innerWindowID
;
}
}
namespace
geckoprofiler
:
:
markers
{
struct
CPUAwakeMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
Awake
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
int64_t
aCPUTimeNs
int64_t
aCPUId
#
ifdef
GP_OS_darwin
uint32_t
aQoS
#
endif
#
ifdef
GP_OS_windows
int32_t
aAbsolutePriority
int32_t
aRelativePriority
int32_t
aCurrentPriority
#
endif
)
{
if
(
aCPUTimeNs
)
{
constexpr
double
NS_PER_MS
=
1
'
000
'
000
;
aWriter
.
DoubleProperty
(
"
CPU
Time
"
double
(
aCPUTimeNs
)
/
NS_PER_MS
)
;
return
;
}
#
ifndef
GP_PLAT_arm64_darwin
aWriter
.
IntProperty
(
"
CPU
Id
"
aCPUId
)
;
#
endif
#
ifdef
GP_OS_windows
if
(
aAbsolutePriority
)
{
aWriter
.
IntProperty
(
"
absPriority
"
aAbsolutePriority
)
;
}
if
(
aCurrentPriority
)
{
aWriter
.
IntProperty
(
"
curPriority
"
aCurrentPriority
)
;
}
aWriter
.
IntProperty
(
"
priority
"
aRelativePriority
)
;
#
endif
#
ifdef
GP_OS_darwin
const
char
*
QoS
=
"
"
;
switch
(
aQoS
)
{
case
QOS_CLASS_USER_INTERACTIVE
:
QoS
=
"
User
Interactive
"
;
break
;
case
QOS_CLASS_USER_INITIATED
:
QoS
=
"
User
Initiated
"
;
break
;
case
QOS_CLASS_DEFAULT
:
QoS
=
"
Default
"
;
break
;
case
QOS_CLASS_UTILITY
:
QoS
=
"
Utility
"
;
break
;
case
QOS_CLASS_BACKGROUND
:
QoS
=
"
Background
"
;
break
;
default
:
QoS
=
"
Unspecified
"
;
}
aWriter
.
StringProperty
(
"
QoS
"
ProfilerString8View
:
:
WrapNullTerminatedString
(
QoS
)
)
;
#
endif
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyFormat
(
"
CPU
Time
"
MS
:
:
Format
:
:
Duration
)
;
#
ifndef
GP_PLAT_arm64_darwin
schema
.
AddKeyFormat
(
"
CPU
Id
"
MS
:
:
Format
:
:
Integer
)
;
schema
.
SetTableLabel
(
"
Awake
-
CPU
Id
=
{
marker
.
data
.
CPU
Id
}
"
)
;
#
endif
#
ifdef
GP_OS_windows
schema
.
AddKeyLabelFormat
(
"
priority
"
"
Relative
Thread
Priority
"
MS
:
:
Format
:
:
Integer
)
;
schema
.
AddKeyLabelFormat
(
"
absPriority
"
"
Base
Thread
Priority
"
MS
:
:
Format
:
:
Integer
)
;
schema
.
AddKeyLabelFormat
(
"
curPriority
"
"
Current
Thread
Priority
"
MS
:
:
Format
:
:
Integer
)
;
#
endif
#
ifdef
GP_OS_darwin
schema
.
AddKeyLabelFormat
(
"
QoS
"
"
Quality
of
Service
"
MS
:
:
Format
:
:
String
)
;
#
endif
return
schema
;
}
}
;
}
void
profiler_mark_thread_asleep
(
)
{
if
(
!
profiler_thread_is_being_profiled_for_markers
(
)
)
{
return
;
}
uint64_t
cpuTimeNs
=
ThreadRegistration
:
:
WithOnThreadRefOr
(
[
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
return
aOnThreadRef
.
UnlockedConstReaderAndAtomicRWRef
(
)
.
GetNewCpuTimeInNs
(
)
;
}
0
)
;
PROFILER_MARKER
(
"
Awake
"
OTHER
MarkerTiming
:
:
IntervalEnd
(
)
CPUAwakeMarker
cpuTimeNs
0
#
if
defined
(
GP_OS_darwin
)
0
#
endif
#
if
defined
(
GP_OS_windows
)
0
0
0
#
endif
)
;
}
void
profiler_thread_sleep
(
)
{
profiler_mark_thread_asleep
(
)
;
ThreadRegistration
:
:
WithOnThreadRef
(
[
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
aOnThreadRef
.
UnlockedConstReaderAndAtomicRWRef
(
)
.
SetSleeping
(
)
;
}
)
;
}
#
if
defined
(
GP_OS_windows
)
#
if
!
defined
(
__MINGW32__
)
enum
{
ThreadBasicInformation
}
;
#
endif
struct
THREAD_BASIC_INFORMATION
{
NTSTATUS
ExitStatus
;
PVOID
TebBaseAddress
;
CLIENT_ID
ClientId
;
KAFFINITY
AffMask
;
DWORD
Priority
;
DWORD
BasePriority
;
}
;
#
endif
static
mozilla
:
:
Atomic
<
uint64_t
mozilla
:
:
MemoryOrdering
:
:
Relaxed
>
gWakeCount
(
0
)
;
namespace
geckoprofiler
:
:
markers
{
struct
WakeUpCountMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
WakeUpCount
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
int32_t
aCount
const
ProfilerString8View
&
aType
)
{
aWriter
.
IntProperty
(
"
Count
"
aCount
)
;
aWriter
.
StringProperty
(
"
label
"
aType
)
;
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyFormat
(
"
Count
"
MS
:
:
Format
:
:
Integer
)
;
schema
.
SetTooltipLabel
(
"
{
marker
.
name
}
-
{
marker
.
data
.
label
}
"
)
;
schema
.
SetTableLabel
(
"
{
marker
.
name
}
-
{
marker
.
data
.
label
}
:
{
marker
.
data
.
count
}
"
)
;
return
schema
;
}
}
;
}
void
profiler_record_wakeup_count
(
const
nsACString
&
aProcessType
)
{
static
uint64_t
previousThreadWakeCount
=
0
;
uint64_t
newWakeups
=
gWakeCount
-
previousThreadWakeCount
;
if
(
newWakeups
>
0
)
{
if
(
newWakeups
<
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
{
int32_t
newWakeups32
=
int32_t
(
newWakeups
)
;
mozilla
:
:
glean
:
:
power
:
:
total_thread_wakeups
.
Add
(
newWakeups32
)
;
mozilla
:
:
glean
:
:
power
:
:
wakeups_per_process_type
.
Get
(
aProcessType
)
.
Add
(
newWakeups32
)
;
PROFILER_MARKER
(
"
Thread
Wake
-
ups
"
OTHER
{
}
WakeUpCountMarker
newWakeups32
aProcessType
)
;
}
previousThreadWakeCount
+
=
newWakeups
;
}
#
ifdef
NIGHTLY_BUILD
ThreadRegistry
:
:
LockedRegistry
lockedRegistry
;
for
(
ThreadRegistry
:
:
OffThreadRef
offThreadRef
:
lockedRegistry
)
{
const
ThreadRegistry
:
:
UnlockedConstReaderAndAtomicRW
&
threadData
=
offThreadRef
.
UnlockedConstReaderAndAtomicRWRef
(
)
;
threadData
.
RecordWakeCount
(
)
;
}
#
endif
}
void
profiler_mark_thread_awake
(
)
{
+
+
gWakeCount
;
if
(
!
profiler_thread_is_being_profiled_for_markers
(
)
)
{
return
;
}
int64_t
cpuId
=
0
;
#
if
defined
(
GP_OS_windows
)
cpuId
=
GetCurrentProcessorNumber
(
)
;
#
elif
defined
(
GP_OS_darwin
)
#
ifdef
GP_PLAT_amd64_darwin
unsigned
int
eax
ebx
ecx
edx
;
__cpuid_count
(
1
0
eax
ebx
ecx
edx
)
;
if
(
(
edx
&
(
1
<
<
9
)
)
)
{
cpuId
=
ebx
>
>
24
;
}
#
endif
#
else
cpuId
=
sched_getcpu
(
)
;
#
endif
#
if
defined
(
GP_OS_windows
)
LONG
priority
;
static
const
auto
get_thread_information_fn
=
reinterpret_cast
<
decltype
(
&
:
:
GetThreadInformation
)
>
(
:
:
GetProcAddress
(
:
:
GetModuleHandle
(
L
"
Kernel32
.
dll
"
)
"
GetThreadInformation
"
)
)
;
if
(
!
get_thread_information_fn
|
|
!
get_thread_information_fn
(
GetCurrentThread
(
)
ThreadAbsoluteCpuPriority
&
priority
sizeof
(
priority
)
)
)
{
priority
=
0
;
}
static
const
auto
nt_query_information_thread_fn
=
reinterpret_cast
<
decltype
(
&
:
:
NtQueryInformationThread
)
>
(
:
:
GetProcAddress
(
:
:
GetModuleHandle
(
L
"
ntdll
.
dll
"
)
"
NtQueryInformationThread
"
)
)
;
LONG
currentPriority
=
0
;
if
(
nt_query_information_thread_fn
)
{
THREAD_BASIC_INFORMATION
threadInfo
;
auto
status
=
(
*
nt_query_information_thread_fn
)
(
GetCurrentThread
(
)
(
THREADINFOCLASS
)
ThreadBasicInformation
&
threadInfo
sizeof
(
threadInfo
)
NULL
)
;
if
(
NT_SUCCESS
(
status
)
)
{
currentPriority
=
threadInfo
.
Priority
;
}
}
#
endif
PROFILER_MARKER
(
"
Awake
"
OTHER
MarkerTiming
:
:
IntervalStart
(
)
CPUAwakeMarker
0
cpuId
#
if
defined
(
GP_OS_darwin
)
qos_class_self
(
)
#
endif
#
if
defined
(
GP_OS_windows
)
priority
GetThreadPriority
(
GetCurrentThread
(
)
)
currentPriority
#
endif
)
;
}
void
profiler_thread_wake
(
)
{
profiler_mark_thread_awake
(
)
;
ThreadRegistration
:
:
WithOnThreadRef
(
[
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
aOnThreadRef
.
UnlockedConstReaderAndAtomicRWRef
(
)
.
SetAwake
(
)
;
}
)
;
}
void
profiler_js_interrupt_callback
(
)
{
PollJSSamplingForCurrentThread
(
)
;
}
double
profiler_time
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
TimeDuration
delta
=
TimeStamp
:
:
Now
(
)
-
CorePS
:
:
ProcessStartTime
(
)
;
return
delta
.
ToMilliseconds
(
)
;
}
bool
profiler_capture_backtrace_into
(
ProfileChunkedBuffer
&
aChunkedBuffer
StackCaptureOptions
aCaptureOptions
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
!
profiler_is_active
(
)
|
|
aCaptureOptions
=
=
StackCaptureOptions
:
:
NoStack
)
{
return
false
;
}
return
ThreadRegistration
:
:
WithOnThreadRefOr
(
[
&
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
mozilla
:
:
Maybe
<
uint32_t
>
maybeFeatures
=
RacyFeatures
:
:
FeaturesIfActiveAndUnpaused
(
)
;
if
(
!
maybeFeatures
)
{
return
false
;
}
ProfileBuffer
profileBuffer
(
aChunkedBuffer
)
;
Registers
regs
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
REGISTERS_SYNC_POPULATE
(
regs
)
;
#
else
regs
.
Clear
(
)
;
#
endif
DoSyncSample
(
*
maybeFeatures
aOnThreadRef
.
UnlockedReaderAndAtomicRWOnThreadCRef
(
)
TimeStamp
:
:
Now
(
)
regs
profileBuffer
aCaptureOptions
)
;
return
true
;
}
false
)
;
}
bool
profiler_backtrace_into_buffer
(
ProfileChunkedBuffer
&
aChunkedBuffer
NativeStack
&
aNativeStack
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
return
ThreadRegistration
:
:
WithOnThreadRefOr
(
[
&
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
mozilla
:
:
Maybe
<
uint32_t
>
maybeFeatures
=
RacyFeatures
:
:
FeaturesIfActiveAndUnpaused
(
)
;
if
(
!
maybeFeatures
)
{
return
false
;
}
ProfileBuffer
profileBuffer
(
aChunkedBuffer
)
;
const
uint64_t
bufferRangeStart
=
profileBuffer
.
BufferRangeStart
(
)
;
const
uint64_t
samplePos
=
profileBuffer
.
AddThreadIdEntry
(
aOnThreadRef
.
UnlockedReaderAndAtomicRWOnThreadCRef
(
)
.
Info
(
)
.
ThreadId
(
)
)
;
TimeDuration
delta
=
TimeStamp
:
:
Now
(
)
-
CorePS
:
:
ProcessStartTime
(
)
;
profileBuffer
.
AddEntry
(
ProfileBufferEntry
:
:
Time
(
delta
.
ToMilliseconds
(
)
)
)
;
ProfileBufferCollector
collector
(
profileBuffer
samplePos
bufferRangeStart
)
;
for
(
int
nativeIndex
=
(
int
)
(
aNativeStack
.
mCount
)
;
nativeIndex
>
=
0
;
-
-
nativeIndex
)
{
collector
.
CollectNativeLeafAddr
(
(
void
*
)
aNativeStack
.
mPCs
[
nativeIndex
]
)
;
}
return
true
;
}
false
)
;
}
UniquePtr
<
ProfileChunkedBuffer
>
profiler_capture_backtrace
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
AUTO_PROFILER_LABEL_HOT
(
"
profiler_capture_backtrace
"
PROFILER
)
;
if
(
!
profiler_active_without_feature
(
ProfilerFeature
:
:
NoMarkerStacks
)
)
{
return
nullptr
;
}
auto
buffer
=
MakeUnique
<
ProfileChunkedBuffer
>
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
MakeUnique
<
ProfileBufferChunkManagerSingle
>
(
ProfileBufferChunkManager
:
:
scExpectedMaximumStackSize
)
)
;
if
(
!
profiler_capture_backtrace_into
(
*
buffer
StackCaptureOptions
:
:
Full
)
)
{
return
nullptr
;
}
return
buffer
;
}
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
{
UniquePtr
<
ProfileChunkedBuffer
>
buffer
=
profiler_capture_backtrace
(
)
;
if
(
!
buffer
)
{
return
nullptr
;
}
return
UniqueProfilerBacktrace
(
new
ProfilerBacktrace
(
"
SyncProfile
"
std
:
:
move
(
buffer
)
)
)
;
}
void
ProfilerBacktraceDestructor
:
:
operator
(
)
(
ProfilerBacktrace
*
aBacktrace
)
{
delete
aBacktrace
;
}
bool
profiler_is_locked_on_current_thread
(
)
{
return
PSAutoLock
:
:
IsLockedOnCurrentThread
(
)
|
|
ThreadRegistry
:
:
IsRegistryMutexLockedOnCurrentThread
(
)
|
|
ThreadRegistration
:
:
IsDataMutexLockedOnCurrentThread
(
)
|
|
profiler_get_core_buffer
(
)
.
IsThreadSafeAndLockedOnCurrentThread
(
)
|
|
ProfilerParent
:
:
IsLockedOnCurrentThread
(
)
|
|
ProfilerChild
:
:
IsLockedOnCurrentThread
(
)
;
}
void
profiler_set_js_context
(
JSContext
*
aCx
)
{
MOZ_ASSERT
(
aCx
)
;
ThreadRegistration
:
:
WithOnThreadRef
(
[
&
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
PSAutoLock
lock
;
aOnThreadRef
.
WithLockedRWOnThread
(
[
&
]
(
ThreadRegistration
:
:
LockedRWOnThread
&
aThreadData
)
{
aThreadData
.
SetJSContext
(
aCx
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
|
|
!
ActivePS
:
:
FeatureJS
(
lock
)
)
{
return
;
}
if
(
ProfiledThreadData
*
profiledThreadData
=
aThreadData
.
GetProfiledThreadData
(
lock
)
;
profiledThreadData
)
{
profiledThreadData
-
>
NotifyReceivedJSContext
(
ActivePS
:
:
Buffer
(
lock
)
.
BufferRangeEnd
(
)
)
;
}
}
)
;
}
)
;
PollJSSamplingForCurrentThread
(
)
;
}
void
profiler_clear_js_context
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
ThreadRegistration
:
:
WithOnThreadRef
(
[
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
JSContext
*
cx
=
aOnThreadRef
.
UnlockedReaderAndAtomicRWOnThreadCRef
(
)
.
GetJSContext
(
)
;
if
(
!
cx
)
{
return
;
}
{
PSAutoLock
lock
;
ThreadRegistration
:
:
OnThreadRef
:
:
RWOnThreadWithLock
lockedThreadData
=
aOnThreadRef
.
GetLockedRWOnThread
(
)
;
ProfiledThreadData
*
profiledThreadData
=
lockedThreadData
-
>
GetProfiledThreadData
(
lock
)
;
if
(
!
(
profiledThreadData
&
&
ActivePS
:
:
Exists
(
lock
)
&
&
ActivePS
:
:
FeatureJS
(
lock
)
)
)
{
lockedThreadData
-
>
ClearJSContext
(
)
;
return
;
}
profiledThreadData
-
>
NotifyAboutToLoseJSContext
(
cx
CorePS
:
:
ProcessStartTime
(
)
ActivePS
:
:
Buffer
(
lock
)
)
;
lockedThreadData
-
>
StopJSSampling
(
)
;
}
PollJSSamplingForCurrentThread
(
)
;
{
PSAutoLock
lock
;
ThreadRegistration
:
:
OnThreadRef
:
:
RWOnThreadWithLock
lockedThreadData
=
aOnThreadRef
.
GetLockedRWOnThread
(
)
;
lockedThreadData
-
>
ClearJSContext
(
)
;
lockedThreadData
-
>
StartJSSampling
(
ActivePS
:
:
JSFlags
(
lock
)
)
;
}
}
)
;
}
static
void
profiler_suspend_and_sample_thread
(
const
PSAutoLock
*
aLockIfAsynchronousSampling
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
JsFrame
*
aJsFrames
uint32_t
aFeatures
ProfilerStackCollector
&
aCollector
bool
aSampleNative
)
{
const
ThreadRegistrationInfo
&
info
=
aThreadData
.
Info
(
)
;
if
(
info
.
IsMainThread
(
)
)
{
aCollector
.
SetIsMainThread
(
)
;
}
NativeStack
nativeStack
{
.
mCount
=
0
}
;
auto
collectStack
=
[
&
]
(
const
Registers
&
aRegs
const
TimeStamp
&
aNow
)
{
StackWalkControl
*
stackWalkControlIfSupported
=
nullptr
;
#
if
defined
(
HAVE_FASTINIT_NATIVE_UNWIND
)
StackWalkControl
stackWalkControl
;
if
constexpr
(
StackWalkControl
:
:
scIsSupported
)
{
if
(
aSampleNative
)
{
stackWalkControlIfSupported
=
&
stackWalkControl
;
}
}
#
endif
const
uint32_t
jsFramesCount
=
aJsFrames
?
ExtractJsFrames
(
!
aLockIfAsynchronousSampling
aThreadData
aRegs
aCollector
aJsFrames
stackWalkControlIfSupported
)
:
0
;
#
if
defined
(
HAVE_FASTINIT_NATIVE_UNWIND
)
if
(
aSampleNative
)
{
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
DoFramePointerBacktrace
(
aThreadData
aRegs
nativeStack
stackWalkControlIfSupported
)
;
#
elif
defined
(
USE_MOZ_STACK_WALK
)
DoMozStackWalkBacktrace
(
aThreadData
aRegs
nativeStack
stackWalkControlIfSupported
)
;
#
else
#
error
"
Invalid
configuration
"
#
endif
MergeStacks
(
!
aLockIfAsynchronousSampling
aThreadData
nativeStack
aCollector
aJsFrames
jsFramesCount
)
;
}
else
#
endif
{
MergeStacks
(
!
aLockIfAsynchronousSampling
aThreadData
nativeStack
aCollector
aJsFrames
jsFramesCount
)
;
aCollector
.
CollectNativeLeafAddr
(
(
void
*
)
aRegs
.
mPC
)
;
}
}
;
if
(
!
aLockIfAsynchronousSampling
)
{
Registers
regs
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
REGISTERS_SYNC_POPULATE
(
regs
)
;
#
else
regs
.
Clear
(
)
;
#
endif
collectStack
(
regs
TimeStamp
:
:
Now
(
)
)
;
}
else
{
Sampler
sampler
(
*
aLockIfAsynchronousSampling
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
sampler
.
SuspendAndSampleAndResumeThread
(
*
aLockIfAsynchronousSampling
aThreadData
now
collectStack
)
;
sampler
.
Disable
(
*
aLockIfAsynchronousSampling
)
;
}
}
void
profiler_suspend_and_sample_thread
(
ProfilerThreadId
aThreadId
uint32_t
aFeatures
ProfilerStackCollector
&
aCollector
bool
aSampleNative
)
{
if
(
!
aThreadId
.
IsSpecified
(
)
|
|
aThreadId
=
=
profiler_current_thread_id
(
)
)
{
ThreadRegistration
:
:
WithOnThreadRef
(
[
&
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
aOnThreadRef
.
WithUnlockedReaderAndAtomicRWOnThread
(
[
&
]
(
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
)
{
if
(
!
aThreadData
.
GetJSContext
(
)
)
{
profiler_suspend_and_sample_thread
(
nullptr
aThreadData
nullptr
aFeatures
aCollector
aSampleNative
)
;
}
else
{
aOnThreadRef
.
WithConstLockedRWOnThread
(
[
&
]
(
const
ThreadRegistration
:
:
LockedRWOnThread
&
aLockedThreadData
)
{
profiler_suspend_and_sample_thread
(
nullptr
aThreadData
aLockedThreadData
.
GetJsFrameBuffer
(
)
aFeatures
aCollector
aSampleNative
)
;
}
)
;
}
}
)
;
}
)
;
}
else
{
PSAutoLock
lock
;
ThreadRegistry
:
:
WithOffThreadRef
(
aThreadId
[
&
]
(
ThreadRegistry
:
:
OffThreadRef
aOffThreadRef
)
{
aOffThreadRef
.
WithLockedRWFromAnyThread
(
[
&
]
(
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
)
{
JsFrameBuffer
&
jsFrames
=
CorePS
:
:
JsFrames
(
lock
)
;
profiler_suspend_and_sample_thread
(
&
lock
aThreadData
jsFrames
aFeatures
aCollector
aSampleNative
)
;
}
)
;
}
)
;
}
}
