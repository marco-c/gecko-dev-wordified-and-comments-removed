#
include
<
algorithm
>
#
include
<
ostream
>
#
include
<
fstream
>
#
include
<
sstream
>
#
include
<
errno
.
h
>
#
include
"
platform
.
h
"
#
include
"
PlatformMacros
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
VTuneProfiler
.
h
"
#
include
"
GeckoProfilerReporter
.
h
"
#
include
"
ProfilerIOInterposeObserver
.
h
"
#
include
"
mozilla
/
AutoProfilerLabel
.
h
"
#
include
"
mozilla
/
ExtensionPolicyService
.
h
"
#
include
"
mozilla
/
Scheduler
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
extensions
/
WebExtensionPolicy
.
h
"
#
include
"
ThreadInfo
.
h
"
#
include
"
nsIHttpProtocolHandler
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPropertyBag2
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsMemoryReporterManager
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsProfilerStartParams
.
h
"
#
include
"
ProfilerParent
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
ProfilerMarkerPayload
.
h
"
#
include
"
shared
-
libraries
.
h
"
#
include
"
prdtoa
.
h
"
#
include
"
prtime
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
processthreadsapi
.
h
>
#
else
#
include
<
unistd
.
h
>
#
endif
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
#
endif
#
if
defined
(
GP_OS_android
)
#
include
"
FennecJNINatives
.
h
"
#
include
"
FennecJNIWrappers
.
h
"
#
endif
#
if
defined
(
GP_PLAT_x86_windows
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
if
defined
(
GP_PLAT_amd64_windows
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_MOZ_STACK_WALK
#
endif
#
if
defined
(
GP_OS_darwin
)
&
&
defined
(
MOZ_PROFILING
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
if
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_EHABI_STACKWALK
#
include
"
EHABIStackWalk
.
h
"
#
endif
#
if
defined
(
GP_PLAT_amd64_linux
)
|
|
\
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
|
|
\
defined
(
GP_PLAT_mips64_linux
)
|
|
\
defined
(
GP_PLAT_arm64_linux
)
|
|
defined
(
GP_PLAT_arm64_android
)
#
define
HAVE_NATIVE_UNWIND
#
define
USE_LUL_STACKWALK
#
include
"
lul
/
LulMain
.
h
"
#
include
"
lul
/
platform
-
linux
-
lul
.
h
"
#
if
defined
(
MOZ_PROFILING
)
#
define
USE_FRAME_POINTER_STACK_WALK
#
endif
#
endif
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
|
|
defined
(
USE_MOZ_STACK_WALK
)
#
define
HAVE_FASTINIT_NATIVE_UNWIND
#
endif
#
ifdef
MOZ_VALGRIND
#
include
<
valgrind
/
memcheck
.
h
>
#
else
#
define
VALGRIND_MAKE_MEM_DEFINED
(
_addr
_len
)
(
(
void
)
0
)
#
endif
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
#
include
<
ucontext
.
h
>
#
endif
using
namespace
mozilla
;
using
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
;
LazyLogModule
gProfilerLog
(
"
prof
"
)
;
#
if
defined
(
GP_OS_android
)
class
GeckoJavaSampler
:
public
java
:
:
GeckoJavaSampler
:
:
Natives
<
GeckoJavaSampler
>
{
private
:
GeckoJavaSampler
(
)
;
public
:
static
double
GetProfilerTime
(
)
{
if
(
!
profiler_is_active
(
)
)
{
return
0
.
0
;
}
return
profiler_time
(
)
;
}
;
}
;
#
endif
class
PSMutex
:
public
StaticMutex
{
}
;
typedef
BaseAutoLock
<
PSMutex
&
>
PSAutoLock
;
typedef
const
PSAutoLock
&
PSLockRef
;
#
define
PS_GET
(
type_
name_
)
\
static
type_
name_
(
PSLockRef
)
{
return
sInstance
-
>
m
#
#
name_
;
}
\
#
define
PS_GET_LOCKLESS
(
type_
name_
)
\
static
type_
name_
(
)
{
return
sInstance
-
>
m
#
#
name_
;
}
\
#
define
PS_GET_AND_SET
(
type_
name_
)
\
PS_GET
(
type_
name_
)
\
static
void
Set
#
#
name_
(
PSLockRef
type_
a
#
#
name_
)
\
{
sInstance
-
>
m
#
#
name_
=
a
#
#
name_
;
}
class
CorePS
{
private
:
CorePS
(
)
:
mProcessStartTime
(
TimeStamp
:
:
ProcessCreation
(
)
)
#
ifdef
USE_LUL_STACKWALK
mLul
(
nullptr
)
#
endif
{
}
~
CorePS
(
)
{
}
public
:
static
void
Create
(
PSLockRef
aLock
)
{
sInstance
=
new
CorePS
(
)
;
}
static
void
Destroy
(
PSLockRef
aLock
)
{
delete
sInstance
;
sInstance
=
nullptr
;
}
static
bool
Exists
(
)
{
return
!
!
sInstance
;
}
static
void
AddSizeOf
(
PSLockRef
MallocSizeOf
aMallocSizeOf
size_t
&
aProfSize
size_t
&
aLulSize
)
{
aProfSize
+
=
aMallocSizeOf
(
sInstance
)
;
for
(
auto
&
registeredThread
:
sInstance
-
>
mRegisteredThreads
)
{
aProfSize
+
=
registeredThread
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
if
(
sInstance
-
>
mLul
)
{
aLulSize
+
=
sInstance
-
>
mLul
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
#
endif
}
PS_GET_LOCKLESS
(
TimeStamp
ProcessStartTime
)
PS_GET
(
const
nsTArray
<
UniquePtr
<
RegisteredThread
>
>
&
RegisteredThreads
)
static
void
AppendRegisteredThread
(
PSLockRef
UniquePtr
<
RegisteredThread
>
&
&
aRegisteredThread
)
{
sInstance
-
>
mRegisteredThreads
.
AppendElement
(
std
:
:
move
(
aRegisteredThread
)
)
;
}
static
void
RemoveRegisteredThread
(
PSLockRef
RegisteredThread
*
aRegisteredThread
)
{
sInstance
-
>
mRegisteredThreads
.
RemoveElementsBy
(
[
&
]
(
UniquePtr
<
RegisteredThread
>
&
rt
)
{
return
rt
.
get
(
)
=
=
aRegisteredThread
;
}
)
;
}
#
ifdef
USE_LUL_STACKWALK
static
lul
:
:
LUL
*
Lul
(
PSLockRef
)
{
return
sInstance
-
>
mLul
.
get
(
)
;
}
static
void
SetLul
(
PSLockRef
UniquePtr
<
lul
:
:
LUL
>
aLul
)
{
sInstance
-
>
mLul
=
std
:
:
move
(
aLul
)
;
}
#
endif
private
:
static
CorePS
*
sInstance
;
const
TimeStamp
mProcessStartTime
;
nsTArray
<
UniquePtr
<
RegisteredThread
>
>
mRegisteredThreads
;
#
ifdef
USE_LUL_STACKWALK
UniquePtr
<
lul
:
:
LUL
>
mLul
;
#
endif
}
;
CorePS
*
CorePS
:
:
sInstance
=
nullptr
;
class
SamplerThread
;
static
SamplerThread
*
NewSamplerThread
(
PSLockRef
aLock
uint32_t
aGeneration
double
aInterval
)
;
struct
LiveProfiledThreadData
{
RegisteredThread
*
mRegisteredThread
;
UniquePtr
<
ProfiledThreadData
>
mProfiledThreadData
;
}
;
class
ActivePS
{
private
:
static
uint32_t
AdjustFeatures
(
uint32_t
aFeatures
uint32_t
aFilterCount
)
{
aFeatures
&
=
profiler_get_available_features
(
)
;
#
if
defined
(
GP_OS_android
)
if
(
!
jni
:
:
IsFennec
(
)
)
{
aFeatures
&
=
~
ProfilerFeature
:
:
Java
;
}
#
endif
if
(
aFilterCount
>
0
)
{
aFeatures
|
=
ProfilerFeature
:
:
Threads
;
}
return
aFeatures
;
}
ActivePS
(
PSLockRef
aLock
uint32_t
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
:
mGeneration
(
sNextGeneration
+
+
)
mEntries
(
aEntries
)
mInterval
(
aInterval
)
mFeatures
(
AdjustFeatures
(
aFeatures
aFilterCount
)
)
mBuffer
(
MakeUnique
<
ProfileBuffer
>
(
aEntries
)
)
mSamplerThread
(
NewSamplerThread
(
aLock
mGeneration
aInterval
)
)
mInterposeObserver
(
ProfilerFeature
:
:
HasMainThreadIO
(
aFeatures
)
?
new
ProfilerIOInterposeObserver
(
)
:
nullptr
)
#
undef
HAS_FEATURE
mIsPaused
(
false
)
#
if
defined
(
GP_OS_linux
)
mWasPaused
(
false
)
#
endif
{
MOZ_ALWAYS_TRUE
(
mFilters
.
resize
(
aFilterCount
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
mFilters
[
i
]
=
aFilters
[
i
]
;
}
if
(
mInterposeObserver
)
{
if
(
NS_IsMainThread
(
)
)
{
IOInterposer
:
:
Register
(
IOInterposeObserver
:
:
OpAll
mInterposeObserver
)
;
}
else
{
RefPtr
<
ProfilerIOInterposeObserver
>
observer
=
mInterposeObserver
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ActivePS
:
:
ActivePS
"
[
=
]
(
)
{
IOInterposer
:
:
Register
(
IOInterposeObserver
:
:
OpAll
observer
)
;
}
)
)
;
}
}
}
~
ActivePS
(
)
{
if
(
mInterposeObserver
)
{
if
(
NS_IsMainThread
(
)
)
{
IOInterposer
:
:
Unregister
(
IOInterposeObserver
:
:
OpAll
mInterposeObserver
)
;
}
else
{
RefPtr
<
ProfilerIOInterposeObserver
>
observer
=
mInterposeObserver
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ActivePS
:
:
~
ActivePS
"
[
=
]
(
)
{
IOInterposer
:
:
Unregister
(
IOInterposeObserver
:
:
OpAll
observer
)
;
}
)
)
;
}
}
}
bool
ThreadSelected
(
const
char
*
aThreadName
)
{
MOZ_RELEASE_ASSERT
(
sInstance
)
;
if
(
mFilters
.
empty
(
)
)
{
return
true
;
}
std
:
:
string
name
=
aThreadName
;
std
:
:
transform
(
name
.
begin
(
)
name
.
end
(
)
name
.
begin
(
)
:
:
tolower
)
;
for
(
uint32_t
i
=
0
;
i
<
mFilters
.
length
(
)
;
+
+
i
)
{
std
:
:
string
filter
=
mFilters
[
i
]
;
std
:
:
transform
(
filter
.
begin
(
)
filter
.
end
(
)
filter
.
begin
(
)
:
:
tolower
)
;
if
(
name
.
find
(
filter
)
!
=
std
:
:
string
:
:
npos
)
{
return
true
;
}
if
(
filter
.
find
(
"
pid
:
"
)
=
=
0
)
{
std
:
:
string
mypid
=
std
:
:
to_string
(
#
ifdef
XP_WIN
GetCurrentProcessId
(
)
#
else
getpid
(
)
#
endif
)
;
if
(
filter
.
compare
(
4
std
:
:
string
:
:
npos
mypid
)
=
=
0
)
{
return
true
;
}
}
}
return
false
;
}
public
:
static
void
Create
(
PSLockRef
aLock
uint32_t
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
{
sInstance
=
new
ActivePS
(
aLock
aEntries
aInterval
aFeatures
aFilters
aFilterCount
)
;
}
static
MOZ_MUST_USE
SamplerThread
*
Destroy
(
PSLockRef
aLock
)
{
auto
samplerThread
=
sInstance
-
>
mSamplerThread
;
delete
sInstance
;
sInstance
=
nullptr
;
return
samplerThread
;
}
static
bool
Exists
(
PSLockRef
)
{
return
!
!
sInstance
;
}
static
bool
Equals
(
PSLockRef
uint32_t
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
{
if
(
sInstance
-
>
mEntries
!
=
aEntries
|
|
sInstance
-
>
mInterval
!
=
aInterval
|
|
sInstance
-
>
mFeatures
!
=
aFeatures
|
|
sInstance
-
>
mFilters
.
length
(
)
!
=
aFilterCount
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
sInstance
-
>
mFilters
.
length
(
)
;
+
+
i
)
{
if
(
strcmp
(
sInstance
-
>
mFilters
[
i
]
.
c_str
(
)
aFilters
[
i
]
)
!
=
0
)
{
return
false
;
}
}
return
true
;
}
static
size_t
SizeOf
(
PSLockRef
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aMallocSizeOf
(
sInstance
)
;
n
+
=
sInstance
-
>
mBuffer
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
return
n
;
}
static
bool
ShouldProfileThread
(
PSLockRef
aLock
ThreadInfo
*
aInfo
)
{
MOZ_RELEASE_ASSERT
(
sInstance
)
;
return
(
(
aInfo
-
>
IsMainThread
(
)
|
|
FeatureThreads
(
aLock
)
)
&
&
sInstance
-
>
ThreadSelected
(
aInfo
-
>
Name
(
)
)
)
;
}
PS_GET
(
uint32_t
Generation
)
PS_GET
(
uint32_t
Entries
)
PS_GET
(
double
Interval
)
PS_GET
(
uint32_t
Features
)
#
define
PS_GET_FEATURE
(
n_
str_
Name_
)
\
static
bool
Feature
#
#
Name_
(
PSLockRef
)
\
{
\
return
ProfilerFeature
:
:
Has
#
#
Name_
(
sInstance
-
>
mFeatures
)
;
\
}
PROFILER_FOR_EACH_FEATURE
(
PS_GET_FEATURE
)
#
undef
PS_GET_FEATURE
PS_GET
(
const
Vector
<
std
:
:
string
>
&
Filters
)
static
ProfileBuffer
&
Buffer
(
PSLockRef
)
{
return
*
sInstance
-
>
mBuffer
.
get
(
)
;
}
static
const
nsTArray
<
LiveProfiledThreadData
>
&
LiveProfiledThreads
(
PSLockRef
)
{
return
sInstance
-
>
mLiveProfiledThreads
;
}
static
nsTArray
<
Pair
<
RegisteredThread
*
ProfiledThreadData
*
>
>
ProfiledThreads
(
PSLockRef
)
{
nsTArray
<
Pair
<
RegisteredThread
*
ProfiledThreadData
*
>
>
array
;
for
(
auto
&
t
:
sInstance
-
>
mLiveProfiledThreads
)
{
array
.
AppendElement
(
MakePair
(
t
.
mRegisteredThread
t
.
mProfiledThreadData
.
get
(
)
)
)
;
}
for
(
auto
&
t
:
sInstance
-
>
mDeadProfiledThreads
)
{
array
.
AppendElement
(
MakePair
(
(
RegisteredThread
*
)
nullptr
t
.
get
(
)
)
)
;
}
class
ThreadRegisterTimeComparator
{
public
:
bool
Equals
(
const
Pair
<
RegisteredThread
*
ProfiledThreadData
*
>
&
a
const
Pair
<
RegisteredThread
*
ProfiledThreadData
*
>
&
b
)
const
{
return
a
.
second
(
)
-
>
Info
(
)
-
>
RegisterTime
(
)
=
=
b
.
second
(
)
-
>
Info
(
)
-
>
RegisterTime
(
)
;
}
bool
LessThan
(
const
Pair
<
RegisteredThread
*
ProfiledThreadData
*
>
&
a
const
Pair
<
RegisteredThread
*
ProfiledThreadData
*
>
&
b
)
const
{
return
a
.
second
(
)
-
>
Info
(
)
-
>
RegisterTime
(
)
<
b
.
second
(
)
-
>
Info
(
)
-
>
RegisterTime
(
)
;
}
}
;
array
.
Sort
(
ThreadRegisterTimeComparator
(
)
)
;
return
array
;
}
static
ProfiledThreadData
*
GetProfiledThreadData
(
PSLockRef
RegisteredThread
*
aRegisteredThread
)
{
for
(
size_t
i
=
0
;
i
<
sInstance
-
>
mLiveProfiledThreads
.
Length
(
)
;
i
+
+
)
{
LiveProfiledThreadData
&
thread
=
sInstance
-
>
mLiveProfiledThreads
[
i
]
;
if
(
thread
.
mRegisteredThread
=
=
aRegisteredThread
)
{
return
thread
.
mProfiledThreadData
.
get
(
)
;
}
}
return
nullptr
;
}
static
ProfiledThreadData
*
AddLiveProfiledThread
(
PSLockRef
RegisteredThread
*
aRegisteredThread
UniquePtr
<
ProfiledThreadData
>
&
&
aProfiledThreadData
)
{
sInstance
-
>
mLiveProfiledThreads
.
AppendElement
(
LiveProfiledThreadData
{
aRegisteredThread
std
:
:
move
(
aProfiledThreadData
)
}
)
;
return
sInstance
-
>
mLiveProfiledThreads
.
LastElement
(
)
.
mProfiledThreadData
.
get
(
)
;
}
static
void
UnregisterThread
(
PSLockRef
aLockRef
RegisteredThread
*
aRegisteredThread
)
{
DiscardExpiredDeadProfiledThreads
(
aLockRef
)
;
for
(
size_t
i
=
0
;
i
<
sInstance
-
>
mLiveProfiledThreads
.
Length
(
)
;
i
+
+
)
{
LiveProfiledThreadData
&
thread
=
sInstance
-
>
mLiveProfiledThreads
[
i
]
;
if
(
thread
.
mRegisteredThread
=
=
aRegisteredThread
)
{
thread
.
mProfiledThreadData
-
>
NotifyUnregistered
(
sInstance
-
>
mBuffer
-
>
mRangeEnd
)
;
sInstance
-
>
mDeadProfiledThreads
.
AppendElement
(
std
:
:
move
(
thread
.
mProfiledThreadData
)
)
;
sInstance
-
>
mLiveProfiledThreads
.
RemoveElementAt
(
i
)
;
return
;
}
}
}
PS_GET_AND_SET
(
bool
IsPaused
)
#
if
defined
(
GP_OS_linux
)
PS_GET_AND_SET
(
bool
WasPaused
)
#
endif
static
void
DiscardExpiredDeadProfiledThreads
(
PSLockRef
)
{
uint64_t
bufferRangeStart
=
sInstance
-
>
mBuffer
-
>
mRangeStart
;
sInstance
-
>
mDeadProfiledThreads
.
RemoveElementsBy
(
[
bufferRangeStart
]
(
UniquePtr
<
ProfiledThreadData
>
&
aProfiledThreadData
)
{
Maybe
<
uint64_t
>
bufferPosition
=
aProfiledThreadData
-
>
BufferPositionWhenUnregistered
(
)
;
MOZ_RELEASE_ASSERT
(
bufferPosition
"
should
have
unregistered
this
thread
"
)
;
return
*
bufferPosition
<
bufferRangeStart
;
}
)
;
}
private
:
static
ActivePS
*
sInstance
;
const
uint32_t
mGeneration
;
static
uint32_t
sNextGeneration
;
const
uint32_t
mEntries
;
const
double
mInterval
;
const
uint32_t
mFeatures
;
Vector
<
std
:
:
string
>
mFilters
;
const
UniquePtr
<
ProfileBuffer
>
mBuffer
;
nsTArray
<
LiveProfiledThreadData
>
mLiveProfiledThreads
;
nsTArray
<
UniquePtr
<
ProfiledThreadData
>
>
mDeadProfiledThreads
;
SamplerThread
*
const
mSamplerThread
;
const
RefPtr
<
ProfilerIOInterposeObserver
>
mInterposeObserver
;
bool
mIsPaused
;
#
if
defined
(
GP_OS_linux
)
bool
mWasPaused
;
#
endif
}
;
ActivePS
*
ActivePS
:
:
sInstance
=
nullptr
;
uint32_t
ActivePS
:
:
sNextGeneration
=
0
;
#
undef
PS_GET
#
undef
PS_GET_LOCKLESS
#
undef
PS_GET_AND_SET
static
PSMutex
gPSMutex
;
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
recordreplay
:
:
Behavior
:
:
DontPreserve
>
RacyFeatures
:
:
sActiveAndFeatures
(
0
)
;
class
TLSRegisteredThread
{
public
:
static
bool
Init
(
PSLockRef
)
{
bool
ok1
=
sRegisteredThread
.
init
(
)
;
bool
ok2
=
AutoProfilerLabel
:
:
sProfilingStack
.
init
(
)
;
return
ok1
&
&
ok2
;
}
static
class
RegisteredThread
*
RegisteredThread
(
PSLockRef
)
{
return
sRegisteredThread
.
get
(
)
;
}
static
class
RacyRegisteredThread
*
RacyRegisteredThread
(
)
{
class
RegisteredThread
*
registeredThread
=
sRegisteredThread
.
get
(
)
;
return
registeredThread
?
&
registeredThread
-
>
RacyRegisteredThread
(
)
:
nullptr
;
}
static
ProfilingStack
*
Stack
(
)
{
return
AutoProfilerLabel
:
:
sProfilingStack
.
get
(
)
;
}
static
void
SetRegisteredThread
(
PSLockRef
class
RegisteredThread
*
aRegisteredThread
)
{
sRegisteredThread
.
set
(
aRegisteredThread
)
;
AutoProfilerLabel
:
:
sProfilingStack
.
set
(
aRegisteredThread
?
&
aRegisteredThread
-
>
RacyRegisteredThread
(
)
.
ProfilingStack
(
)
:
nullptr
)
;
}
private
:
static
MOZ_THREAD_LOCAL
(
class
RegisteredThread
*
)
sRegisteredThread
;
}
;
MOZ_THREAD_LOCAL
(
RegisteredThread
*
)
TLSRegisteredThread
:
:
sRegisteredThread
;
MOZ_THREAD_LOCAL
(
ProfilingStack
*
)
AutoProfilerLabel
:
:
sProfilingStack
;
static
const
char
*
const
kMainThreadName
=
"
GeckoMain
"
;
class
Registers
{
public
:
Registers
(
)
:
mPC
{
nullptr
}
mSP
{
nullptr
}
mFP
{
nullptr
}
mLR
{
nullptr
}
{
}
#
if
defined
(
HAVE_NATIVE_UNWIND
)
void
SyncPopulate
(
)
;
#
endif
void
Clear
(
)
{
memset
(
this
0
sizeof
(
*
this
)
)
;
}
Address
mPC
;
Address
mSP
;
Address
mFP
;
Address
mLR
;
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
ucontext_t
*
mContext
;
#
endif
}
;
static
const
size_t
MAX_NATIVE_FRAMES
=
1024
;
static
const
size_t
MAX_JS_FRAMES
=
1024
;
struct
NativeStack
{
void
*
mPCs
[
MAX_NATIVE_FRAMES
]
;
void
*
mSPs
[
MAX_NATIVE_FRAMES
]
;
size_t
mCount
;
NativeStack
(
)
:
mPCs
(
)
mSPs
(
)
mCount
(
0
)
{
}
}
;
Atomic
<
bool
>
WALKING_JS_STACK
(
false
)
;
struct
AutoWalkJSStack
{
bool
walkAllowed
;
AutoWalkJSStack
(
)
:
walkAllowed
(
false
)
{
walkAllowed
=
WALKING_JS_STACK
.
compareExchange
(
false
true
)
;
}
~
AutoWalkJSStack
(
)
{
if
(
walkAllowed
)
{
WALKING_JS_STACK
=
false
;
}
}
}
;
static
void
MergeStacks
(
uint32_t
aFeatures
bool
aIsSynchronous
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
const
NativeStack
&
aNativeStack
ProfilerStackCollector
&
aCollector
)
{
const
ProfilingStack
&
profilingStack
=
aRegisteredThread
.
RacyRegisteredThread
(
)
.
ProfilingStack
(
)
;
const
js
:
:
ProfilingStackFrame
*
profilingStackFrames
=
profilingStack
.
frames
;
uint32_t
profilingStackFrameCount
=
profilingStack
.
stackSize
(
)
;
JSContext
*
context
=
aRegisteredThread
.
GetJSContext
(
)
;
Maybe
<
uint64_t
>
samplePosInBuffer
;
if
(
!
aIsSynchronous
)
{
samplePosInBuffer
=
aCollector
.
SamplePositionInBuffer
(
)
;
}
uint32_t
jsCount
=
0
;
JS
:
:
ProfilingFrameIterator
:
:
Frame
jsFrames
[
MAX_JS_FRAMES
]
;
if
(
context
&
&
JS
:
:
IsProfilingEnabledForContext
(
context
)
)
{
AutoWalkJSStack
autoWalkJSStack
;
const
uint32_t
maxFrames
=
ArrayLength
(
jsFrames
)
;
if
(
autoWalkJSStack
.
walkAllowed
)
{
JS
:
:
ProfilingFrameIterator
:
:
RegisterState
registerState
;
registerState
.
pc
=
aRegs
.
mPC
;
registerState
.
sp
=
aRegs
.
mSP
;
registerState
.
lr
=
aRegs
.
mLR
;
registerState
.
fp
=
aRegs
.
mFP
;
JS
:
:
ProfilingFrameIterator
jsIter
(
context
registerState
samplePosInBuffer
)
;
for
(
;
jsCount
<
maxFrames
&
&
!
jsIter
.
done
(
)
;
+
+
jsIter
)
{
if
(
aIsSynchronous
|
|
jsIter
.
isWasm
(
)
)
{
uint32_t
extracted
=
jsIter
.
extractStack
(
jsFrames
jsCount
maxFrames
)
;
jsCount
+
=
extracted
;
if
(
jsCount
=
=
maxFrames
)
{
break
;
}
}
else
{
Maybe
<
JS
:
:
ProfilingFrameIterator
:
:
Frame
>
frame
=
jsIter
.
getPhysicalFrameWithoutLabel
(
)
;
if
(
frame
.
isSome
(
)
)
{
jsFrames
[
jsCount
+
+
]
=
frame
.
value
(
)
;
}
}
}
}
}
uint32_t
profilingStackIndex
=
0
;
int32_t
jsIndex
=
jsCount
-
1
;
int32_t
nativeIndex
=
aNativeStack
.
mCount
-
1
;
uint8_t
*
lastLabelFrameStackAddr
=
nullptr
;
uint8_t
*
jitEndStackAddr
=
nullptr
;
while
(
profilingStackIndex
!
=
profilingStackFrameCount
|
|
jsIndex
>
=
0
|
|
nativeIndex
>
=
0
)
{
uint8_t
*
profilingStackAddr
=
nullptr
;
uint8_t
*
jsStackAddr
=
nullptr
;
uint8_t
*
nativeStackAddr
=
nullptr
;
uint8_t
*
jsActivationAddr
=
nullptr
;
if
(
profilingStackIndex
!
=
profilingStackFrameCount
)
{
const
js
:
:
ProfilingStackFrame
&
profilingStackFrame
=
profilingStackFrames
[
profilingStackIndex
]
;
if
(
profilingStackFrame
.
isLabelFrame
(
)
|
|
profilingStackFrame
.
isSpMarkerFrame
(
)
)
{
lastLabelFrameStackAddr
=
(
uint8_t
*
)
profilingStackFrame
.
stackAddress
(
)
;
}
if
(
profilingStackFrame
.
kind
(
)
=
=
js
:
:
ProfilingStackFrame
:
:
Kind
:
:
JS_OSR
)
{
profilingStackIndex
+
+
;
continue
;
}
MOZ_ASSERT
(
lastLabelFrameStackAddr
)
;
profilingStackAddr
=
lastLabelFrameStackAddr
;
}
if
(
jsIndex
>
=
0
)
{
jsStackAddr
=
(
uint8_t
*
)
jsFrames
[
jsIndex
]
.
stackAddress
;
jsActivationAddr
=
(
uint8_t
*
)
jsFrames
[
jsIndex
]
.
activation
;
}
if
(
nativeIndex
>
=
0
)
{
nativeStackAddr
=
(
uint8_t
*
)
aNativeStack
.
mSPs
[
nativeIndex
]
;
}
if
(
nativeStackAddr
&
&
(
profilingStackAddr
=
=
nativeStackAddr
|
|
jsStackAddr
=
=
nativeStackAddr
)
)
{
nativeStackAddr
=
nullptr
;
nativeIndex
-
-
;
MOZ_ASSERT
(
profilingStackAddr
|
|
jsStackAddr
)
;
}
MOZ_ASSERT_IF
(
profilingStackAddr
profilingStackAddr
!
=
jsStackAddr
&
&
profilingStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
jsStackAddr
jsStackAddr
!
=
profilingStackAddr
&
&
jsStackAddr
!
=
nativeStackAddr
)
;
MOZ_ASSERT_IF
(
nativeStackAddr
nativeStackAddr
!
=
profilingStackAddr
&
&
nativeStackAddr
!
=
jsStackAddr
)
;
if
(
profilingStackAddr
>
jsStackAddr
&
&
profilingStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
profilingStackIndex
<
profilingStackFrameCount
)
;
const
js
:
:
ProfilingStackFrame
&
profilingStackFrame
=
profilingStackFrames
[
profilingStackIndex
]
;
if
(
!
profilingStackFrame
.
isSpMarkerFrame
(
)
)
{
MOZ_ASSERT_IF
(
profilingStackFrame
.
isJsFrame
(
)
&
&
profilingStackFrame
.
script
(
)
&
&
!
profilingStackFrame
.
pc
(
)
&
profilingStackFrame
=
=
&
profilingStack
.
frames
[
profilingStack
.
stackSize
(
)
-
1
]
)
;
aCollector
.
CollectProfilingStackFrame
(
profilingStackFrame
)
;
}
profilingStackIndex
+
+
;
continue
;
}
if
(
jsStackAddr
>
nativeStackAddr
)
{
MOZ_ASSERT
(
jsIndex
>
=
0
)
;
const
JS
:
:
ProfilingFrameIterator
:
:
Frame
&
jsFrame
=
jsFrames
[
jsIndex
]
;
jitEndStackAddr
=
(
uint8_t
*
)
jsFrame
.
endStackAddress
;
if
(
aIsSynchronous
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Wasm
)
{
aCollector
.
CollectWasmFrame
(
jsFrame
.
label
)
;
}
else
{
MOZ_ASSERT
(
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Ion
|
|
jsFrame
.
kind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Baseline
)
;
aCollector
.
CollectJitReturnAddr
(
jsFrame
.
returnAddress
)
;
}
jsIndex
-
-
;
continue
;
}
if
(
nativeStackAddr
&
&
(
!
jitEndStackAddr
|
|
nativeStackAddr
<
jitEndStackAddr
)
&
&
(
!
jsActivationAddr
|
|
nativeStackAddr
>
jsActivationAddr
)
)
{
MOZ_ASSERT
(
nativeIndex
>
=
0
)
;
void
*
addr
=
(
void
*
)
aNativeStack
.
mPCs
[
nativeIndex
]
;
aCollector
.
CollectNativeLeafAddr
(
addr
)
;
}
if
(
nativeIndex
>
=
0
)
{
nativeIndex
-
-
;
}
}
if
(
!
aIsSynchronous
&
&
context
&
&
aCollector
.
BufferRangeStart
(
)
)
{
uint64_t
bufferRangeStart
=
*
aCollector
.
BufferRangeStart
(
)
;
JS
:
:
SetJSContextProfilerSampleBufferRangeStart
(
context
bufferRangeStart
)
;
}
}
#
if
defined
(
GP_OS_windows
)
static
HANDLE
GetThreadHandle
(
PlatformData
*
aData
)
;
#
endif
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
|
|
defined
(
USE_MOZ_STACK_WALK
)
static
void
StackWalkCallback
(
uint32_t
aFrameNumber
void
*
aPC
void
*
aSP
void
*
aClosure
)
{
NativeStack
*
nativeStack
=
static_cast
<
NativeStack
*
>
(
aClosure
)
;
MOZ_ASSERT
(
nativeStack
-
>
mCount
<
MAX_NATIVE_FRAMES
)
;
nativeStack
-
>
mSPs
[
nativeStack
-
>
mCount
]
=
aSP
;
nativeStack
-
>
mPCs
[
nativeStack
-
>
mCount
]
=
aPC
;
nativeStack
-
>
mCount
+
+
;
}
#
endif
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
static
void
DoFramePointerBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
StackWalkCallback
(
0
aRegs
.
mPC
aRegs
.
mSP
&
aNativeStack
)
;
uint32_t
maxFrames
=
uint32_t
(
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
;
const
void
*
stackEnd
=
aRegisteredThread
.
StackTop
(
)
;
if
(
aRegs
.
mFP
>
=
aRegs
.
mSP
&
&
aRegs
.
mFP
<
=
stackEnd
)
{
FramePointerStackWalk
(
StackWalkCallback
0
maxFrames
&
aNativeStack
reinterpret_cast
<
void
*
*
>
(
aRegs
.
mFP
)
const_cast
<
void
*
>
(
stackEnd
)
)
;
}
}
#
endif
#
if
defined
(
USE_MOZ_STACK_WALK
)
static
void
DoMozStackWalkBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
StackWalkCallback
(
0
aRegs
.
mPC
aRegs
.
mSP
&
aNativeStack
)
;
uint32_t
maxFrames
=
uint32_t
(
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
;
HANDLE
thread
=
GetThreadHandle
(
aRegisteredThread
.
GetPlatformData
(
)
)
;
MOZ_ASSERT
(
thread
)
;
MozStackWalkThread
(
StackWalkCallback
0
maxFrames
&
aNativeStack
thread
nullptr
)
;
}
#
endif
#
ifdef
USE_EHABI_STACKWALK
static
void
DoEHABIBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
const
mcontext_t
*
mcontext
=
&
aRegs
.
mContext
-
>
uc_mcontext
;
mcontext_t
savedContext
;
const
ProfilingStack
&
profilingStack
=
aRegisteredThread
.
RacyRegisteredThread
(
)
.
ProfilingStack
(
)
;
for
(
uint32_t
i
=
profilingStack
.
stackSize
(
)
;
i
>
0
;
-
-
i
)
{
const
js
:
:
ProfilingStackFrame
&
frame
=
profilingStack
.
frames
[
i
-
1
]
;
if
(
!
frame
.
isJsFrame
(
)
&
&
strcmp
(
frame
.
label
(
)
"
EnterJIT
"
)
=
=
0
)
{
uint32_t
*
vSP
=
reinterpret_cast
<
uint32_t
*
>
(
frame
.
stackAddress
(
)
)
;
aNativeStack
.
mCount
+
=
EHABIStackWalk
(
*
mcontext
vSP
aNativeStack
.
mSPs
+
aNativeStack
.
mCount
aNativeStack
.
mPCs
+
aNativeStack
.
mCount
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
;
memset
(
&
savedContext
0
sizeof
(
savedContext
)
)
;
savedContext
.
arm_r4
=
*
vSP
+
+
;
savedContext
.
arm_r5
=
*
vSP
+
+
;
savedContext
.
arm_r6
=
*
vSP
+
+
;
savedContext
.
arm_r7
=
*
vSP
+
+
;
savedContext
.
arm_r8
=
*
vSP
+
+
;
savedContext
.
arm_r9
=
*
vSP
+
+
;
savedContext
.
arm_r10
=
*
vSP
+
+
;
savedContext
.
arm_fp
=
*
vSP
+
+
;
savedContext
.
arm_lr
=
*
vSP
+
+
;
savedContext
.
arm_sp
=
reinterpret_cast
<
uint32_t
>
(
vSP
)
;
savedContext
.
arm_pc
=
savedContext
.
arm_lr
;
mcontext
=
&
savedContext
;
}
}
aNativeStack
.
mCount
+
=
EHABIStackWalk
(
*
mcontext
const_cast
<
void
*
>
(
aRegisteredThread
.
StackTop
(
)
)
aNativeStack
.
mSPs
+
aNativeStack
.
mCount
aNativeStack
.
mPCs
+
aNativeStack
.
mCount
MAX_NATIVE_FRAMES
-
aNativeStack
.
mCount
)
;
}
#
endif
#
ifdef
USE_LUL_STACKWALK
#
if
defined
(
MOZ_HAVE_ASAN_BLACKLIST
)
MOZ_ASAN_BLACKLIST
static
void
ASAN_memcpy
(
void
*
aDst
const
void
*
aSrc
size_t
aLen
)
{
char
*
dst
=
static_cast
<
char
*
>
(
aDst
)
;
const
char
*
src
=
static_cast
<
const
char
*
>
(
aSrc
)
;
for
(
size_t
i
=
0
;
i
<
aLen
;
i
+
+
)
{
dst
[
i
]
=
src
[
i
]
;
}
}
#
endif
static
void
DoLULBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
const
mcontext_t
*
mc
=
&
aRegs
.
mContext
-
>
uc_mcontext
;
lul
:
:
UnwindRegs
startRegs
;
memset
(
&
startRegs
0
sizeof
(
startRegs
)
)
;
#
if
defined
(
GP_PLAT_amd64_linux
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RSP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_RBP
]
)
;
#
elif
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
startRegs
.
r15
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_pc
)
;
startRegs
.
r14
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_lr
)
;
startRegs
.
r13
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_sp
)
;
startRegs
.
r12
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_ip
)
;
startRegs
.
r11
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_fp
)
;
startRegs
.
r7
=
lul
:
:
TaggedUWord
(
mc
-
>
arm_r7
)
;
#
elif
defined
(
GP_PLAT_arm64_linux
)
|
|
defined
(
GP_PLAT_arm64_android
)
startRegs
.
pc
=
lul
:
:
TaggedUWord
(
mc
-
>
pc
)
;
startRegs
.
x29
=
lul
:
:
TaggedUWord
(
mc
-
>
regs
[
29
]
)
;
startRegs
.
x30
=
lul
:
:
TaggedUWord
(
mc
-
>
regs
[
30
]
)
;
startRegs
.
sp
=
lul
:
:
TaggedUWord
(
mc
-
>
sp
)
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
startRegs
.
xip
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EIP
]
)
;
startRegs
.
xsp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_ESP
]
)
;
startRegs
.
xbp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
REG_EBP
]
)
;
#
elif
defined
(
GP_PLAT_mips64_linux
)
startRegs
.
pc
=
lul
:
:
TaggedUWord
(
mc
-
>
pc
)
;
startRegs
.
sp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
29
]
)
;
startRegs
.
fp
=
lul
:
:
TaggedUWord
(
mc
-
>
gregs
[
30
]
)
;
#
else
#
error
"
Unknown
plat
"
#
endif
lul
:
:
StackImage
stackImg
;
{
#
if
defined
(
GP_PLAT_amd64_linux
)
uintptr_t
rEDZONE_SIZE
=
128
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_arm_linux
)
|
|
defined
(
GP_PLAT_arm_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
r13
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_arm64_linux
)
|
|
defined
(
GP_PLAT_arm64_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
sp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_x86_linux
)
|
|
defined
(
GP_PLAT_x86_android
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
xsp
.
Value
(
)
-
rEDZONE_SIZE
;
#
elif
defined
(
GP_PLAT_mips64_linux
)
uintptr_t
rEDZONE_SIZE
=
0
;
uintptr_t
start
=
startRegs
.
sp
.
Value
(
)
-
rEDZONE_SIZE
;
#
else
#
error
"
Unknown
plat
"
#
endif
uintptr_t
end
=
reinterpret_cast
<
uintptr_t
>
(
aRegisteredThread
.
StackTop
(
)
)
;
uintptr_t
ws
=
sizeof
(
void
*
)
;
start
&
=
~
(
ws
-
1
)
;
end
&
=
~
(
ws
-
1
)
;
uintptr_t
nToCopy
=
0
;
if
(
start
<
end
)
{
nToCopy
=
end
-
start
;
if
(
nToCopy
>
lul
:
:
N_STACK_BYTES
)
nToCopy
=
lul
:
:
N_STACK_BYTES
;
}
MOZ_ASSERT
(
nToCopy
<
=
lul
:
:
N_STACK_BYTES
)
;
stackImg
.
mLen
=
nToCopy
;
stackImg
.
mStartAvma
=
start
;
if
(
nToCopy
>
0
)
{
#
if
defined
(
MOZ_HAVE_ASAN_BLACKLIST
)
ASAN_memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
#
else
memcpy
(
&
stackImg
.
mContents
[
0
]
(
void
*
)
start
nToCopy
)
;
#
endif
(
void
)
VALGRIND_MAKE_MEM_DEFINED
(
&
stackImg
.
mContents
[
0
]
nToCopy
)
;
}
}
size_t
framePointerFramesAcquired
=
0
;
lul
:
:
LUL
*
lul
=
CorePS
:
:
Lul
(
aLock
)
;
lul
-
>
Unwind
(
reinterpret_cast
<
uintptr_t
*
>
(
aNativeStack
.
mPCs
)
reinterpret_cast
<
uintptr_t
*
>
(
aNativeStack
.
mSPs
)
&
aNativeStack
.
mCount
&
framePointerFramesAcquired
MAX_NATIVE_FRAMES
&
startRegs
&
stackImg
)
;
lul
-
>
mStats
.
mContext
+
=
1
;
lul
-
>
mStats
.
mCFI
+
=
aNativeStack
.
mCount
-
1
-
framePointerFramesAcquired
;
lul
-
>
mStats
.
mFP
+
=
framePointerFramesAcquired
;
}
#
endif
#
ifdef
HAVE_NATIVE_UNWIND
static
void
DoNativeBacktrace
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Registers
&
aRegs
NativeStack
&
aNativeStack
)
{
#
if
defined
(
USE_LUL_STACKWALK
)
DoLULBacktrace
(
aLock
aRegisteredThread
aRegs
aNativeStack
)
;
#
elif
defined
(
USE_EHABI_STACKWALK
)
DoEHABIBacktrace
(
aLock
aRegisteredThread
aRegs
aNativeStack
)
;
#
elif
defined
(
USE_FRAME_POINTER_STACK_WALK
)
DoFramePointerBacktrace
(
aLock
aRegisteredThread
aRegs
aNativeStack
)
;
#
elif
defined
(
USE_MOZ_STACK_WALK
)
DoMozStackWalkBacktrace
(
aLock
aRegisteredThread
aRegs
aNativeStack
)
;
#
else
#
error
"
Invalid
configuration
"
#
endif
}
#
endif
static
inline
void
DoSharedSample
(
PSLockRef
aLock
bool
aIsSynchronous
RegisteredThread
&
aRegisteredThread
const
TimeStamp
&
aNow
const
Registers
&
aRegs
Maybe
<
uint64_t
>
*
aLastSample
ProfileBuffer
&
aBuffer
)
{
MOZ_RELEASE_ASSERT
(
ActivePS
:
:
Exists
(
aLock
)
)
;
uint64_t
samplePos
=
aBuffer
.
AddThreadIdEntry
(
aRegisteredThread
.
Info
(
)
-
>
ThreadId
(
)
)
;
if
(
aLastSample
)
{
*
aLastSample
=
Some
(
samplePos
)
;
}
TimeDuration
delta
=
aNow
-
CorePS
:
:
ProcessStartTime
(
)
;
aBuffer
.
AddEntry
(
ProfileBufferEntry
:
:
Time
(
delta
.
ToMilliseconds
(
)
)
)
;
ProfileBufferCollector
collector
(
aBuffer
ActivePS
:
:
Features
(
aLock
)
samplePos
)
;
NativeStack
nativeStack
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
if
(
ActivePS
:
:
FeatureStackWalk
(
aLock
)
)
{
DoNativeBacktrace
(
aLock
aRegisteredThread
aRegs
nativeStack
)
;
MergeStacks
(
ActivePS
:
:
Features
(
aLock
)
aIsSynchronous
aRegisteredThread
aRegs
nativeStack
collector
)
;
}
else
#
endif
{
MergeStacks
(
ActivePS
:
:
Features
(
aLock
)
aIsSynchronous
aRegisteredThread
aRegs
nativeStack
collector
)
;
if
(
ActivePS
:
:
FeatureLeaf
(
aLock
)
)
{
aBuffer
.
AddEntry
(
ProfileBufferEntry
:
:
NativeLeafAddr
(
(
void
*
)
aRegs
.
mPC
)
)
;
}
}
}
static
void
DoSyncSample
(
PSLockRef
aLock
RegisteredThread
&
aRegisteredThread
const
TimeStamp
&
aNow
const
Registers
&
aRegs
ProfileBuffer
&
aBuffer
)
{
DoSharedSample
(
aLock
true
aRegisteredThread
aNow
aRegs
nullptr
aBuffer
)
;
}
static
void
DoPeriodicSample
(
PSLockRef
aLock
RegisteredThread
&
aRegisteredThread
ProfiledThreadData
&
aProfiledThreadData
const
TimeStamp
&
aNow
const
Registers
&
aRegs
int64_t
aRSSMemory
int64_t
aUSSMemory
)
{
ProfileBuffer
&
buffer
=
ActivePS
:
:
Buffer
(
aLock
)
;
DoSharedSample
(
aLock
false
aRegisteredThread
aNow
aRegs
&
aProfiledThreadData
.
LastSample
(
)
buffer
)
;
ProfilerMarkerLinkedList
*
pendingMarkersList
=
aRegisteredThread
.
RacyRegisteredThread
(
)
.
GetPendingMarkers
(
)
;
while
(
pendingMarkersList
&
&
pendingMarkersList
-
>
peek
(
)
)
{
ProfilerMarker
*
marker
=
pendingMarkersList
-
>
popHead
(
)
;
buffer
.
AddStoredMarker
(
marker
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Marker
(
marker
)
)
;
}
ThreadResponsiveness
*
resp
=
aProfiledThreadData
.
GetThreadResponsiveness
(
)
;
if
(
resp
&
&
resp
-
>
HasData
(
)
)
{
double
delta
=
resp
-
>
GetUnresponsiveDuration
(
(
aNow
-
CorePS
:
:
ProcessStartTime
(
)
)
.
ToMilliseconds
(
)
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Responsiveness
(
delta
)
)
;
}
if
(
aRSSMemory
!
=
0
)
{
double
rssMemory
=
static_cast
<
double
>
(
aRSSMemory
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
ResidentMemory
(
rssMemory
)
)
;
}
if
(
aUSSMemory
!
=
0
)
{
double
ussMemory
=
static_cast
<
double
>
(
aUSSMemory
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
UnsharedMemory
(
ussMemory
)
)
;
}
}
const
static
uint64_t
kJS_MAX_SAFE_UINTEGER
=
+
9007199254740991ULL
;
static
int64_t
SafeJSInteger
(
uint64_t
aValue
)
{
return
aValue
<
=
kJS_MAX_SAFE_UINTEGER
?
int64_t
(
aValue
)
:
-
1
;
}
static
void
AddSharedLibraryInfoToStream
(
JSONWriter
&
aWriter
const
SharedLibrary
&
aLib
)
{
aWriter
.
StartObjectElement
(
)
;
aWriter
.
IntProperty
(
"
start
"
SafeJSInteger
(
aLib
.
GetStart
(
)
)
)
;
aWriter
.
IntProperty
(
"
end
"
SafeJSInteger
(
aLib
.
GetEnd
(
)
)
)
;
aWriter
.
IntProperty
(
"
offset
"
SafeJSInteger
(
aLib
.
GetOffset
(
)
)
)
;
aWriter
.
StringProperty
(
"
name
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetModuleName
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
path
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetModulePath
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
debugName
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetDebugName
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
debugPath
"
NS_ConvertUTF16toUTF8
(
aLib
.
GetDebugPath
(
)
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
breakpadId
"
aLib
.
GetBreakpadId
(
)
.
get
(
)
)
;
aWriter
.
StringProperty
(
"
arch
"
aLib
.
GetArch
(
)
.
c_str
(
)
)
;
aWriter
.
EndObject
(
)
;
}
void
AppendSharedLibraries
(
JSONWriter
&
aWriter
)
{
SharedLibraryInfo
info
=
SharedLibraryInfo
:
:
GetInfoForSelf
(
)
;
info
.
SortByAddress
(
)
;
for
(
size_t
i
=
0
;
i
<
info
.
GetSize
(
)
;
i
+
+
)
{
AddSharedLibraryInfoToStream
(
aWriter
info
.
GetEntry
(
i
)
)
;
}
}
#
ifdef
MOZ_TASK_TRACER
static
void
StreamNameAndThreadId
(
JSONWriter
&
aWriter
const
char
*
aName
int
aThreadId
)
{
aWriter
.
StartObjectElement
(
)
;
{
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Plugin
)
{
aWriter
.
StringProperty
(
"
name
"
"
Plugin
"
)
;
}
else
{
aWriter
.
StringProperty
(
"
name
"
aName
)
;
}
aWriter
.
IntProperty
(
"
tid
"
aThreadId
)
;
}
aWriter
.
EndObject
(
)
;
}
#
endif
static
void
StreamTaskTracer
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
#
ifdef
MOZ_TASK_TRACER
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
aWriter
.
StartArrayProperty
(
"
data
"
)
;
{
UniquePtr
<
nsTArray
<
nsCString
>
>
data
=
tasktracer
:
:
GetLoggedData
(
CorePS
:
:
ProcessStartTime
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
data
-
>
Length
(
)
;
+
+
i
)
{
aWriter
.
StringElement
(
(
data
-
>
ElementAt
(
i
)
)
.
get
(
)
)
;
}
}
aWriter
.
EndArray
(
)
;
aWriter
.
StartArrayProperty
(
"
threads
"
)
;
{
ActivePS
:
:
DiscardExpiredDeadProfiledThreads
(
aLock
)
;
nsTArray
<
Pair
<
RegisteredThread
*
ProfiledThreadData
*
>
>
threads
=
ActivePS
:
:
ProfiledThreads
(
aLock
)
;
for
(
auto
&
thread
:
threads
)
{
RefPtr
<
ThreadInfo
>
info
=
thread
.
second
(
)
-
>
Info
(
)
;
StreamNameAndThreadId
(
aWriter
info
-
>
Name
(
)
info
-
>
ThreadId
(
)
)
;
}
}
aWriter
.
EndArray
(
)
;
aWriter
.
DoubleProperty
(
"
start
"
static_cast
<
double
>
(
tasktracer
:
:
GetStartTime
(
)
)
)
;
#
endif
}
static
void
StreamCategories
(
SpliceableJSONWriter
&
aWriter
)
{
aWriter
.
Start
(
)
;
aWriter
.
StringProperty
(
"
name
"
"
Idle
"
)
;
aWriter
.
StringProperty
(
"
color
"
"
transparent
"
)
;
aWriter
.
EndObject
(
)
;
aWriter
.
Start
(
)
;
aWriter
.
StringProperty
(
"
name
"
"
Other
"
)
;
aWriter
.
StringProperty
(
"
color
"
"
grey
"
)
;
aWriter
.
EndObject
(
)
;
aWriter
.
Start
(
)
;
aWriter
.
StringProperty
(
"
name
"
"
Layout
"
)
;
aWriter
.
StringProperty
(
"
color
"
"
purple
"
)
;
aWriter
.
EndObject
(
)
;
aWriter
.
Start
(
)
;
aWriter
.
StringProperty
(
"
name
"
"
JavaScript
"
)
;
aWriter
.
StringProperty
(
"
color
"
"
yellow
"
)
;
aWriter
.
EndObject
(
)
;
aWriter
.
Start
(
)
;
aWriter
.
StringProperty
(
"
name
"
"
GC
/
CC
"
)
;
aWriter
.
StringProperty
(
"
color
"
"
orange
"
)
;
aWriter
.
EndObject
(
)
;
aWriter
.
Start
(
)
;
aWriter
.
StringProperty
(
"
name
"
"
Network
"
)
;
aWriter
.
StringProperty
(
"
color
"
"
lightblue
"
)
;
aWriter
.
EndObject
(
)
;
aWriter
.
Start
(
)
;
aWriter
.
StringProperty
(
"
name
"
"
Graphics
"
)
;
aWriter
.
StringProperty
(
"
color
"
"
green
"
)
;
aWriter
.
EndObject
(
)
;
aWriter
.
Start
(
)
;
aWriter
.
StringProperty
(
"
name
"
"
DOM
"
)
;
aWriter
.
StringProperty
(
"
color
"
"
blue
"
)
;
aWriter
.
EndObject
(
)
;
}
static
void
StreamMetaJSCustomObject
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
bool
aIsShuttingDown
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
aWriter
.
IntProperty
(
"
version
"
11
)
;
TimeDuration
delta
=
TimeStamp
:
:
Now
(
)
-
CorePS
:
:
ProcessStartTime
(
)
;
aWriter
.
DoubleProperty
(
"
startTime
"
static_cast
<
double
>
(
PR_Now
(
)
/
1000
.
0
-
delta
.
ToMilliseconds
(
)
)
)
;
if
(
aIsShuttingDown
)
{
aWriter
.
DoubleProperty
(
"
shutdownTime
"
profiler_time
(
)
)
;
}
else
{
aWriter
.
NullProperty
(
"
shutdownTime
"
)
;
}
aWriter
.
StartArrayProperty
(
"
categories
"
)
;
StreamCategories
(
aWriter
)
;
aWriter
.
EndArray
(
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
aWriter
.
DoubleProperty
(
"
interval
"
ActivePS
:
:
Interval
(
aLock
)
)
;
aWriter
.
IntProperty
(
"
stackwalk
"
ActivePS
:
:
FeatureStackWalk
(
aLock
)
)
;
#
ifdef
DEBUG
aWriter
.
IntProperty
(
"
debug
"
1
)
;
#
else
aWriter
.
IntProperty
(
"
debug
"
0
)
;
#
endif
aWriter
.
IntProperty
(
"
gcpoison
"
JS
:
:
IsGCPoisoning
(
)
?
1
:
0
)
;
bool
asyncStacks
=
Preferences
:
:
GetBool
(
"
javascript
.
options
.
asyncstack
"
)
;
aWriter
.
IntProperty
(
"
asyncstack
"
asyncStacks
)
;
aWriter
.
IntProperty
(
"
processType
"
XRE_GetProcessType
(
)
)
;
nsresult
res
;
nsCOMPtr
<
nsIHttpProtocolHandler
>
http
=
do_GetService
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
"
http
"
&
res
)
;
if
(
!
NS_FAILED
(
res
)
)
{
nsAutoCString
string
;
res
=
http
-
>
GetPlatform
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
platform
"
string
.
Data
(
)
)
;
}
res
=
http
-
>
GetOscpu
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
oscpu
"
string
.
Data
(
)
)
;
}
res
=
http
-
>
GetMisc
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
StringProperty
(
"
misc
"
string
.
Data
(
)
)
;
}
}
nsCOMPtr
<
nsIXULRuntime
>
runtime
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
runtime
)
{
nsAutoCString
string
;
res
=
runtime
-
>
GetXPCOMABI
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
abi
"
string
.
Data
(
)
)
;
res
=
runtime
-
>
GetWidgetToolkit
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
toolkit
"
string
.
Data
(
)
)
;
}
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
)
;
if
(
appInfo
)
{
nsAutoCString
string
;
res
=
appInfo
-
>
GetName
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
product
"
string
.
Data
(
)
)
;
res
=
appInfo
-
>
GetAppBuildID
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
appBuildID
"
string
.
Data
(
)
)
;
res
=
appInfo
-
>
GetSourceURL
(
string
)
;
if
(
!
NS_FAILED
(
res
)
)
aWriter
.
StringProperty
(
"
sourceURL
"
string
.
Data
(
)
)
;
}
nsCOMPtr
<
nsIPropertyBag2
>
systemInfo
=
do_GetService
(
"
mozilla
.
org
/
system
-
info
;
1
"
)
;
if
(
systemInfo
)
{
int32_t
cpus
;
res
=
systemInfo
-
>
GetPropertyAsInt32
(
NS_LITERAL_STRING
(
"
cpucores
"
)
&
cpus
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
IntProperty
(
"
physicalCPUs
"
cpus
)
;
}
res
=
systemInfo
-
>
GetPropertyAsInt32
(
NS_LITERAL_STRING
(
"
cpucount
"
)
&
cpus
)
;
if
(
!
NS_FAILED
(
res
)
)
{
aWriter
.
IntProperty
(
"
logicalCPUs
"
cpus
)
;
}
}
if
(
!
gXPCOMShuttingDown
)
{
aWriter
.
StartObjectProperty
(
"
extensions
"
)
;
{
{
JSONSchemaWriter
schema
(
aWriter
)
;
schema
.
WriteField
(
"
id
"
)
;
schema
.
WriteField
(
"
name
"
)
;
schema
.
WriteField
(
"
baseURL
"
)
;
}
aWriter
.
StartArrayProperty
(
"
data
"
)
;
{
nsTArray
<
RefPtr
<
WebExtensionPolicy
>
>
exts
;
ExtensionPolicyService
:
:
GetSingleton
(
)
.
GetAll
(
exts
)
;
for
(
auto
&
ext
:
exts
)
{
aWriter
.
StartArrayElement
(
JSONWriter
:
:
SingleLineStyle
)
;
nsAutoString
id
;
ext
-
>
GetId
(
id
)
;
aWriter
.
StringElement
(
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
)
;
aWriter
.
StringElement
(
NS_ConvertUTF16toUTF8
(
ext
-
>
Name
(
)
)
.
get
(
)
)
;
auto
url
=
ext
-
>
GetURL
(
NS_LITERAL_STRING
(
"
"
)
)
;
if
(
url
.
isOk
(
)
)
{
aWriter
.
StringElement
(
NS_ConvertUTF16toUTF8
(
url
.
unwrap
(
)
)
.
get
(
)
)
;
}
aWriter
.
EndArray
(
)
;
}
}
aWriter
.
EndArray
(
)
;
}
}
aWriter
.
EndObject
(
)
;
}
#
if
defined
(
GP_OS_android
)
static
UniquePtr
<
ProfileBuffer
>
CollectJavaThreadProfileData
(
)
{
auto
buffer
=
MakeUnique
<
ProfileBuffer
>
(
1000
*
1000
)
;
int
sampleId
=
0
;
while
(
true
)
{
double
sampleTime
=
java
:
:
GeckoJavaSampler
:
:
GetSampleTime
(
0
sampleId
)
;
if
(
sampleTime
=
=
0
.
0
)
{
break
;
}
buffer
-
>
AddThreadIdEntry
(
0
)
;
buffer
-
>
AddEntry
(
ProfileBufferEntry
:
:
Time
(
sampleTime
)
)
;
bool
parentFrameWasIdleFrame
=
false
;
int
frameId
=
0
;
while
(
true
)
{
jni
:
:
String
:
:
LocalRef
frameName
=
java
:
:
GeckoJavaSampler
:
:
GetFrameName
(
0
sampleId
frameId
+
+
)
;
if
(
!
frameName
)
{
break
;
}
nsCString
frameNameString
=
frameName
-
>
ToCString
(
)
;
Maybe
<
js
:
:
ProfilingStackFrame
:
:
Category
>
category
;
if
(
frameNameString
.
EqualsLiteral
(
"
android
.
os
.
MessageQueue
.
nativePollOnce
(
)
"
)
)
{
category
=
Some
(
js
:
:
ProfilingStackFrame
:
:
Category
:
:
IDLE
)
;
parentFrameWasIdleFrame
=
true
;
}
else
if
(
parentFrameWasIdleFrame
)
{
category
=
Some
(
js
:
:
ProfilingStackFrame
:
:
Category
:
:
OTHER
)
;
parentFrameWasIdleFrame
=
false
;
}
buffer
-
>
CollectCodeLocation
(
"
"
frameNameString
.
get
(
)
-
1
category
)
;
}
sampleId
+
+
;
}
return
buffer
;
}
#
endif
static
void
locked_profiler_stream_json_for_this_process
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
double
aSinceTime
bool
aIsShuttingDown
)
{
LOG
(
"
locked_profiler_stream_json_for_this_process
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
double
collectionStart
=
profiler_time
(
)
;
ProfileBuffer
&
buffer
=
ActivePS
:
:
Buffer
(
aLock
)
;
aWriter
.
StartArrayProperty
(
"
libs
"
)
;
AppendSharedLibraries
(
aWriter
)
;
aWriter
.
EndArray
(
)
;
aWriter
.
StartObjectProperty
(
"
meta
"
)
;
{
StreamMetaJSCustomObject
(
aLock
aWriter
aIsShuttingDown
)
;
}
aWriter
.
EndObject
(
)
;
if
(
ActivePS
:
:
FeatureTaskTracer
(
aLock
)
)
{
aWriter
.
StartObjectProperty
(
"
tasktracer
"
)
;
StreamTaskTracer
(
aLock
aWriter
)
;
aWriter
.
EndObject
(
)
;
}
aWriter
.
StartArrayProperty
(
"
threads
"
)
;
{
ActivePS
:
:
DiscardExpiredDeadProfiledThreads
(
aLock
)
;
nsTArray
<
Pair
<
RegisteredThread
*
ProfiledThreadData
*
>
>
threads
=
ActivePS
:
:
ProfiledThreads
(
aLock
)
;
for
(
auto
&
thread
:
threads
)
{
RegisteredThread
*
registeredThread
=
thread
.
first
(
)
;
JSContext
*
cx
=
registeredThread
?
registeredThread
-
>
GetJSContext
(
)
:
nullptr
;
ProfiledThreadData
*
profiledThreadData
=
thread
.
second
(
)
;
profiledThreadData
-
>
StreamJSON
(
buffer
cx
aWriter
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
)
;
}
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
java
:
:
GeckoJavaSampler
:
:
Pause
(
)
;
UniquePtr
<
ProfileBuffer
>
javaBuffer
=
CollectJavaThreadProfileData
(
)
;
RefPtr
<
ThreadInfo
>
threadInfo
=
new
ThreadInfo
(
"
Java
Main
Thread
"
0
false
CorePS
:
:
ProcessStartTime
(
)
)
;
ProfiledThreadData
profiledThreadData
(
threadInfo
nullptr
ActivePS
:
:
FeatureResponsiveness
(
aLock
)
)
;
profiledThreadData
.
StreamJSON
(
*
javaBuffer
.
get
(
)
nullptr
aWriter
CorePS
:
:
ProcessStartTime
(
)
aSinceTime
)
;
java
:
:
GeckoJavaSampler
:
:
Unpause
(
)
;
}
#
endif
}
aWriter
.
EndArray
(
)
;
aWriter
.
StartArrayProperty
(
"
pausedRanges
"
)
;
{
buffer
.
StreamPausedRangesToJSON
(
aWriter
aSinceTime
)
;
}
aWriter
.
EndArray
(
)
;
double
collectionEnd
=
profiler_time
(
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CollectionStart
(
collectionStart
)
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
CollectionEnd
(
collectionEnd
)
)
;
}
bool
profiler_stream_json_for_this_process
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
bool
aIsShuttingDown
)
{
LOG
(
"
profiler_stream_json_for_this_process
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
locked_profiler_stream_json_for_this_process
(
lock
aWriter
aSinceTime
aIsShuttingDown
)
;
return
true
;
}
static
void
PrintUsageThenExit
(
int
aExitCode
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
printf
(
"
\
n
"
"
Profiler
environment
variable
usage
:
\
n
"
"
\
n
"
"
MOZ_PROFILER_HELP
\
n
"
"
If
set
to
any
value
prints
this
message
.
\
n
"
"
\
n
"
"
MOZ_LOG
\
n
"
"
Enables
logging
.
The
levels
of
logging
available
are
\
n
"
"
'
prof
:
3
'
(
least
verbose
)
'
prof
:
4
'
'
prof
:
5
'
(
most
verbose
)
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP
\
n
"
"
If
set
to
any
value
starts
the
profiler
immediately
on
start
-
up
.
\
n
"
"
Useful
if
you
want
profile
code
that
runs
very
early
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_ENTRIES
=
<
1
.
.
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
number
of
entries
in
\
n
"
"
the
profiler
'
s
circular
buffer
when
the
profiler
is
first
started
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_INTERVAL
=
<
1
.
.
1000
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
sample
interval
\
n
"
"
measured
in
milliseconds
when
the
profiler
is
first
started
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
=
<
Number
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
profiling
features
as
\
n
"
"
the
integer
value
of
the
features
bitfield
.
\
n
"
"
If
unset
the
value
from
MOZ_PROFILER_STARTUP_FEATURES
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FEATURES
=
<
Features
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
profiling
features
as
\
n
"
"
a
comma
-
separated
list
of
strings
.
\
n
"
"
Ignored
if
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
is
set
.
\
n
"
"
If
unset
the
platform
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_STARTUP_FILTERS
=
<
Filters
>
\
n
"
"
If
MOZ_PROFILER_STARTUP
is
set
specifies
the
thread
filters
as
a
\
n
"
"
comma
-
separated
list
of
strings
.
A
given
thread
will
be
sampled
if
any
\
n
"
"
of
the
filters
is
a
case
-
insensitive
substring
of
the
thread
name
.
\
n
"
"
If
unset
a
default
is
used
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_SHUTDOWN
\
n
"
"
If
set
the
profiler
saves
a
profile
to
the
named
file
on
shutdown
.
\
n
"
"
\
n
"
"
MOZ_PROFILER_LUL_TEST
\
n
"
"
If
set
to
any
value
runs
LUL
unit
tests
at
startup
.
\
n
"
"
\
n
"
"
This
platform
%
s
native
unwinding
.
\
n
"
"
\
n
"
#
if
defined
(
HAVE_NATIVE_UNWIND
)
"
supports
"
#
else
"
does
not
support
"
#
endif
)
;
exit
(
aExitCode
)
;
}
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
struct
SigHandlerCoordinator
;
#
endif
class
Sampler
{
public
:
explicit
Sampler
(
PSLockRef
aLock
)
;
void
Disable
(
PSLockRef
aLock
)
;
template
<
typename
Func
>
void
SuspendAndSampleAndResumeThread
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
Func
&
aProcessRegs
)
;
private
:
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
struct
sigaction
mOldSigprofHandler
;
int
mMyPid
;
int
mSamplerTid
;
public
:
static
struct
SigHandlerCoordinator
*
sSigHandlerCoordinator
;
#
endif
}
;
class
SamplerThread
:
public
Sampler
{
public
:
SamplerThread
(
PSLockRef
aLock
uint32_t
aActivityGeneration
double
aIntervalMilliseconds
)
;
~
SamplerThread
(
)
;
void
Run
(
)
;
void
Stop
(
PSLockRef
aLock
)
;
private
:
void
SleepMicro
(
uint32_t
aMicroseconds
)
;
const
uint32_t
mActivityGeneration
;
const
int
mIntervalMicroseconds
;
#
if
defined
(
GP_OS_windows
)
HANDLE
mThread
;
#
elif
defined
(
GP_OS_darwin
)
|
|
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
pthread_t
mThread
;
#
endif
SamplerThread
(
const
SamplerThread
&
)
=
delete
;
void
operator
=
(
const
SamplerThread
&
)
=
delete
;
}
;
static
SamplerThread
*
NewSamplerThread
(
PSLockRef
aLock
uint32_t
aGeneration
double
aInterval
)
{
return
new
SamplerThread
(
aLock
aGeneration
aInterval
)
;
}
void
SamplerThread
:
:
Run
(
)
{
PR_SetCurrentThreadName
(
"
SamplerThread
"
)
;
TimeDuration
lastSleepOvershoot
=
0
;
TimeStamp
sampleStart
=
TimeStamp
:
:
Now
(
)
;
while
(
true
)
{
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
if
(
ActivePS
:
:
Generation
(
lock
)
!
=
mActivityGeneration
)
{
return
;
}
ActivePS
:
:
Buffer
(
lock
)
.
DeleteExpiredStoredMarkers
(
)
;
if
(
!
ActivePS
:
:
IsPaused
(
lock
)
)
{
const
nsTArray
<
LiveProfiledThreadData
>
&
liveThreads
=
ActivePS
:
:
LiveProfiledThreads
(
lock
)
;
int64_t
rssMemory
=
0
;
int64_t
ussMemory
=
0
;
if
(
!
liveThreads
.
IsEmpty
(
)
&
&
ActivePS
:
:
FeatureMemory
(
lock
)
)
{
rssMemory
=
nsMemoryReporterManager
:
:
ResidentFast
(
)
;
#
if
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
ussMemory
=
nsMemoryReporterManager
:
:
ResidentUnique
(
)
;
#
endif
}
for
(
auto
&
thread
:
liveThreads
)
{
RegisteredThread
*
registeredThread
=
thread
.
mRegisteredThread
;
ProfiledThreadData
*
profiledThreadData
=
thread
.
mProfiledThreadData
.
get
(
)
;
RefPtr
<
ThreadInfo
>
info
=
registeredThread
-
>
Info
(
)
;
if
(
registeredThread
-
>
RacyRegisteredThread
(
)
.
CanDuplicateLastSampleDueToSleep
(
)
)
{
bool
dup_ok
=
ActivePS
:
:
Buffer
(
lock
)
.
DuplicateLastSample
(
info
-
>
ThreadId
(
)
CorePS
:
:
ProcessStartTime
(
)
profiledThreadData
-
>
LastSample
(
)
)
;
if
(
dup_ok
)
{
continue
;
}
}
ThreadResponsiveness
*
resp
=
profiledThreadData
-
>
GetThreadResponsiveness
(
)
;
if
(
resp
)
{
resp
-
>
Update
(
)
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
SuspendAndSampleAndResumeThread
(
lock
*
registeredThread
[
&
]
(
const
Registers
&
aRegs
)
{
DoPeriodicSample
(
lock
*
registeredThread
*
profiledThreadData
now
aRegs
rssMemory
ussMemory
)
;
}
)
;
}
#
if
defined
(
USE_LUL_STACKWALK
)
CorePS
:
:
Lul
(
lock
)
-
>
MaybeShowStats
(
)
;
#
endif
}
}
TimeStamp
targetSleepEndTime
=
sampleStart
+
TimeDuration
:
:
FromMicroseconds
(
mIntervalMicroseconds
)
;
TimeStamp
beforeSleep
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
targetSleepDuration
=
targetSleepEndTime
-
beforeSleep
;
double
sleepTime
=
std
:
:
max
(
0
.
0
(
targetSleepDuration
-
lastSleepOvershoot
)
.
ToMicroseconds
(
)
)
;
SleepMicro
(
static_cast
<
uint32_t
>
(
sleepTime
)
)
;
sampleStart
=
TimeStamp
:
:
Now
(
)
;
lastSleepOvershoot
=
sampleStart
-
(
beforeSleep
+
TimeDuration
:
:
FromMicroseconds
(
sleepTime
)
)
;
}
}
#
if
defined
(
GP_OS_windows
)
#
include
"
platform
-
win32
.
cpp
"
#
elif
defined
(
GP_OS_darwin
)
#
include
"
platform
-
macos
.
cpp
"
#
elif
defined
(
GP_OS_linux
)
|
|
defined
(
GP_OS_android
)
#
include
"
platform
-
linux
-
android
.
cpp
"
#
else
#
error
"
bad
platform
"
#
endif
UniquePlatformData
AllocPlatformData
(
int
aThreadId
)
{
return
UniquePlatformData
(
new
PlatformData
(
aThreadId
)
)
;
}
void
PlatformDataDestructor
:
:
operator
(
)
(
PlatformData
*
aData
)
{
delete
aData
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
GeckoProfilerMallocSizeOf
)
NS_IMETHODIMP
GeckoProfilerReporter
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
size_t
profSize
=
0
;
size_t
lulSize
=
0
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
CorePS
:
:
Exists
(
)
)
{
CorePS
:
:
AddSizeOf
(
lock
GeckoProfilerMallocSizeOf
profSize
lulSize
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
profSize
+
=
ActivePS
:
:
SizeOf
(
lock
GeckoProfilerMallocSizeOf
)
;
}
}
MOZ_COLLECT_REPORT
(
"
explicit
/
profiler
/
profiler
-
state
"
KIND_HEAP
UNITS_BYTES
profSize
"
Memory
used
by
the
Gecko
Profiler
'
s
global
state
(
excluding
memory
used
"
"
by
LUL
)
.
"
)
;
#
if
defined
(
USE_LUL_STACKWALK
)
MOZ_COLLECT_REPORT
(
"
explicit
/
profiler
/
lul
"
KIND_HEAP
UNITS_BYTES
lulSize
"
Memory
used
by
LUL
a
stack
unwinder
used
by
the
Gecko
Profiler
.
"
)
;
#
endif
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
GeckoProfilerReporter
nsIMemoryReporter
)
static
bool
HasFeature
(
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
aFeature
)
{
for
(
size_t
i
=
0
;
i
<
aFeatureCount
;
i
+
+
)
{
if
(
strcmp
(
aFeatures
[
i
]
aFeature
)
=
=
0
)
{
return
true
;
}
}
return
false
;
}
uint32_t
ParseFeaturesFromStringArray
(
const
char
*
*
aFeatures
uint32_t
aFeatureCount
)
{
#
define
ADD_FEATURE_BIT
(
n_
str_
Name_
)
\
if
(
HasFeature
(
aFeatures
aFeatureCount
str_
)
)
{
\
features
|
=
ProfilerFeature
:
:
Name_
;
\
}
uint32_t
features
=
0
;
PROFILER_FOR_EACH_FEATURE
(
ADD_FEATURE_BIT
)
#
undef
ADD_FEATURE_BIT
return
features
;
}
static
RegisteredThread
*
FindCurrentThreadRegisteredThread
(
PSLockRef
aLock
)
{
int
id
=
Thread
:
:
GetCurrentId
(
)
;
const
nsTArray
<
UniquePtr
<
RegisteredThread
>
>
&
registeredThreads
=
CorePS
:
:
RegisteredThreads
(
aLock
)
;
for
(
auto
&
registeredThread
:
registeredThreads
)
{
if
(
registeredThread
-
>
Info
(
)
-
>
ThreadId
(
)
=
=
id
)
{
return
registeredThread
.
get
(
)
;
}
}
return
nullptr
;
}
static
ProfilingStack
*
locked_register_thread
(
PSLockRef
aLock
const
char
*
aName
void
*
aStackTop
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
FindCurrentThreadRegisteredThread
(
aLock
)
)
;
VTUNE_REGISTER_THREAD
(
aName
)
;
if
(
!
TLSRegisteredThread
:
:
Init
(
aLock
)
)
{
return
nullptr
;
}
RefPtr
<
ThreadInfo
>
info
=
new
ThreadInfo
(
aName
Thread
:
:
GetCurrentId
(
)
NS_IsMainThread
(
)
)
;
UniquePtr
<
RegisteredThread
>
registeredThread
=
MakeUnique
<
RegisteredThread
>
(
info
NS_GetCurrentThreadNoCreate
(
)
aStackTop
)
;
TLSRegisteredThread
:
:
SetRegisteredThread
(
aLock
registeredThread
.
get
(
)
)
;
if
(
ActivePS
:
:
Exists
(
aLock
)
&
&
ActivePS
:
:
ShouldProfileThread
(
aLock
info
)
)
{
nsCOMPtr
<
nsIEventTarget
>
eventTarget
=
registeredThread
-
>
GetEventTarget
(
)
;
ProfiledThreadData
*
profiledThreadData
=
ActivePS
:
:
AddLiveProfiledThread
(
aLock
registeredThread
.
get
(
)
MakeUnique
<
ProfiledThreadData
>
(
info
eventTarget
ActivePS
:
:
FeatureResponsiveness
(
aLock
)
)
)
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
registeredThread
-
>
StartJSSampling
(
ActivePS
:
:
FeatureTrackOptimizations
(
aLock
)
)
;
registeredThread
-
>
PollJSSampling
(
)
;
if
(
registeredThread
-
>
GetJSContext
(
)
)
{
profiledThreadData
-
>
NotifyReceivedJSContext
(
ActivePS
:
:
Buffer
(
aLock
)
.
mRangeEnd
)
;
}
}
}
ProfilingStack
*
profilingStack
=
&
registeredThread
-
>
RacyRegisteredThread
(
)
.
ProfilingStack
(
)
;
CorePS
:
:
AppendRegisteredThread
(
aLock
std
:
:
move
(
registeredThread
)
)
;
return
profilingStack
;
}
static
void
NotifyObservers
(
const
char
*
aTopic
nsISupports
*
aSubject
=
nullptr
)
{
if
(
!
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsISupports
>
subject
=
aSubject
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
NotifyObservers
"
[
=
]
{
NotifyObservers
(
aTopic
subject
)
;
}
)
)
;
return
;
}
if
(
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
)
{
os
-
>
NotifyObservers
(
aSubject
aTopic
nullptr
)
;
}
}
static
void
NotifyProfilerStarted
(
const
int
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
{
nsTArray
<
nsCString
>
filtersArray
;
for
(
size_t
i
=
0
;
i
<
aFilterCount
;
+
+
i
)
{
filtersArray
.
AppendElement
(
aFilters
[
i
]
)
;
}
nsCOMPtr
<
nsIProfilerStartParams
>
params
=
new
nsProfilerStartParams
(
aEntries
aInterval
aFeatures
filtersArray
)
;
ProfilerParent
:
:
ProfilerStarted
(
params
)
;
NotifyObservers
(
"
profiler
-
started
"
params
)
;
}
static
void
locked_profiler_start
(
PSLockRef
aLock
uint32_t
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
;
ProfilingStack
*
MozGlueLabelEnter
(
const
char
*
aLabel
const
char
*
aDynamicString
void
*
aSp
uint32_t
aLine
)
{
ProfilingStack
*
profilingStack
=
AutoProfilerLabel
:
:
sProfilingStack
.
get
(
)
;
if
(
profilingStack
)
{
profilingStack
-
>
pushLabelFrame
(
aLabel
aDynamicString
aSp
aLine
js
:
:
ProfilingStackFrame
:
:
Category
:
:
OTHER
)
;
}
return
profilingStack
;
}
void
MozGlueLabelExit
(
ProfilingStack
*
sProfilingStack
)
{
if
(
sProfilingStack
)
{
sProfilingStack
-
>
pop
(
)
;
}
}
static
nsTArray
<
const
char
*
>
SplitAtCommas
(
const
char
*
aString
UniquePtr
<
char
[
]
>
&
aStorage
)
{
size_t
len
=
strlen
(
aString
)
;
aStorage
=
MakeUnique
<
char
[
]
>
(
len
+
1
)
;
PodCopy
(
aStorage
.
get
(
)
aString
len
+
1
)
;
nsTArray
<
const
char
*
>
array
;
size_t
currentElementStart
=
0
;
for
(
size_t
i
=
0
;
i
<
=
len
;
i
+
+
)
{
if
(
aStorage
[
i
]
=
=
'
'
)
{
aStorage
[
i
]
=
'
\
0
'
;
}
if
(
aStorage
[
i
]
=
=
'
\
0
'
)
{
array
.
AppendElement
(
&
aStorage
[
currentElementStart
]
)
;
currentElementStart
=
i
+
1
;
}
}
return
array
;
}
void
profiler_init
(
void
*
aStackTop
)
{
LOG
(
"
profiler_init
"
)
;
VTUNE_INIT
(
)
;
MOZ_RELEASE_ASSERT
(
!
CorePS
:
:
Exists
(
)
)
;
if
(
getenv
(
"
MOZ_PROFILER_HELP
"
)
)
{
PrintUsageThenExit
(
0
)
;
}
SharedLibraryInfo
:
:
Initialize
(
)
;
uint32_t
features
=
#
if
defined
(
GP_OS_android
)
ProfilerFeature
:
:
Java
|
#
endif
ProfilerFeature
:
:
JS
|
ProfilerFeature
:
:
Leaf
|
#
if
defined
(
HAVE_NATIVE_UNWIND
)
ProfilerFeature
:
:
StackWalk
|
#
endif
ProfilerFeature
:
:
Threads
|
ProfilerFeature
:
:
Responsiveness
|
0
;
UniquePtr
<
char
[
]
>
filterStorage
;
nsTArray
<
const
char
*
>
filters
;
filters
.
AppendElement
(
"
GeckoMain
"
)
;
filters
.
AppendElement
(
"
Compositor
"
)
;
filters
.
AppendElement
(
"
DOM
Worker
"
)
;
int
entries
=
PROFILER_DEFAULT_ENTRIES
;
double
interval
=
PROFILER_DEFAULT_INTERVAL
;
{
PSAutoLock
lock
(
gPSMutex
)
;
CorePS
:
:
Create
(
lock
)
;
locked_register_thread
(
lock
kMainThreadName
aStackTop
)
;
PlatformInit
(
lock
)
;
#
ifdef
MOZ_TASK_TRACER
tasktracer
:
:
InitTaskTracer
(
)
;
#
endif
#
if
defined
(
GP_OS_android
)
if
(
jni
:
:
IsFennec
(
)
)
{
GeckoJavaSampler
:
:
Init
(
)
;
}
#
endif
RegisterProfilerLabelEnterExit
(
MozGlueLabelEnter
MozGlueLabelExit
)
;
const
char
*
startupEnv
=
getenv
(
"
MOZ_PROFILER_STARTUP
"
)
;
if
(
!
startupEnv
|
|
startupEnv
[
0
]
=
=
'
\
0
'
)
{
return
;
}
LOG
(
"
-
MOZ_PROFILER_STARTUP
is
set
"
)
;
const
char
*
startupEntries
=
getenv
(
"
MOZ_PROFILER_STARTUP_ENTRIES
"
)
;
if
(
startupEntries
&
&
startupEntries
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
entries
=
strtol
(
startupEntries
nullptr
10
)
;
if
(
errno
=
=
0
&
&
entries
>
0
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_ENTRIES
=
%
d
"
entries
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_ENTRIES
not
a
valid
integer
:
%
s
"
startupEntries
)
;
PrintUsageThenExit
(
1
)
;
}
}
const
char
*
startupInterval
=
getenv
(
"
MOZ_PROFILER_STARTUP_INTERVAL
"
)
;
if
(
startupInterval
&
&
startupInterval
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
interval
=
PR_strtod
(
startupInterval
nullptr
)
;
if
(
errno
=
=
0
&
&
interval
>
0
.
0
&
&
interval
<
=
1000
.
0
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_INTERVAL
=
%
f
"
interval
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_INTERVAL
not
a
valid
float
:
%
s
"
startupInterval
)
;
PrintUsageThenExit
(
1
)
;
}
}
const
char
*
startupFeaturesBitfield
=
getenv
(
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
"
)
;
if
(
startupFeaturesBitfield
&
&
startupFeaturesBitfield
[
0
]
!
=
'
\
0
'
)
{
errno
=
0
;
features
=
strtol
(
startupFeaturesBitfield
nullptr
10
)
;
if
(
errno
=
=
0
&
&
features
!
=
0
)
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
=
%
d
"
features
)
;
}
else
{
LOG
(
"
-
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
not
a
valid
integer
:
%
s
"
startupFeaturesBitfield
)
;
PrintUsageThenExit
(
1
)
;
}
}
else
{
const
char
*
startupFeatures
=
getenv
(
"
MOZ_PROFILER_STARTUP_FEATURES
"
)
;
if
(
startupFeatures
&
&
startupFeatures
[
0
]
!
=
'
\
0
'
)
{
UniquePtr
<
char
[
]
>
featureStringStorage
;
nsTArray
<
const
char
*
>
featureStringArray
=
SplitAtCommas
(
startupFeatures
featureStringStorage
)
;
features
=
ParseFeaturesFromStringArray
(
featureStringArray
.
Elements
(
)
featureStringArray
.
Length
(
)
)
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_FEATURES
=
%
d
"
features
)
;
}
}
const
char
*
startupFilters
=
getenv
(
"
MOZ_PROFILER_STARTUP_FILTERS
"
)
;
if
(
startupFilters
&
&
startupFilters
[
0
]
!
=
'
\
0
'
)
{
filters
=
SplitAtCommas
(
startupFilters
filterStorage
)
;
LOG
(
"
-
MOZ_PROFILER_STARTUP_FILTERS
=
%
s
"
startupFilters
)
;
}
locked_profiler_start
(
lock
entries
interval
features
filters
.
Elements
(
)
filters
.
Length
(
)
)
;
}
NotifyProfilerStarted
(
entries
interval
features
filters
.
Elements
(
)
filters
.
Length
(
)
)
;
}
static
void
locked_profiler_save_profile_to_file
(
PSLockRef
aLock
const
char
*
aFilename
bool
aIsShuttingDown
)
;
static
SamplerThread
*
locked_profiler_stop
(
PSLockRef
aLock
)
;
void
profiler_shutdown
(
)
{
LOG
(
"
profiler_shutdown
"
)
;
VTUNE_SHUTDOWN
(
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
const
char
*
filename
=
getenv
(
"
MOZ_PROFILER_SHUTDOWN
"
)
;
if
(
filename
)
{
locked_profiler_save_profile_to_file
(
lock
filename
true
)
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
CorePS
:
:
Destroy
(
lock
)
;
TLSRegisteredThread
:
:
SetRegisteredThread
(
lock
nullptr
)
;
#
ifdef
MOZ_TASK_TRACER
tasktracer
:
:
ShutdownTaskTracer
(
)
;
#
endif
}
if
(
samplerThread
)
{
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
}
static
bool
WriteProfileToJSONWriter
(
SpliceableChunkedJSONWriter
&
aWriter
double
aSinceTime
bool
aIsShuttingDown
)
{
LOG
(
"
WriteProfileToJSONWriter
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
aWriter
.
Start
(
)
;
{
if
(
!
profiler_stream_json_for_this_process
(
aWriter
aSinceTime
aIsShuttingDown
)
)
{
return
false
;
}
aWriter
.
StartArrayProperty
(
"
processes
"
)
;
aWriter
.
EndArray
(
)
;
}
aWriter
.
End
(
)
;
return
true
;
}
UniquePtr
<
char
[
]
>
profiler_get_profile
(
double
aSinceTime
bool
aIsShuttingDown
)
{
LOG
(
"
profiler_get_profile
"
)
;
SpliceableChunkedJSONWriter
b
;
if
(
!
WriteProfileToJSONWriter
(
b
aSinceTime
aIsShuttingDown
)
)
{
return
nullptr
;
}
return
b
.
WriteFunc
(
)
-
>
CopyData
(
)
;
}
void
profiler_get_profile_json_into_lazily_allocated_buffer
(
const
std
:
:
function
<
char
*
(
size_t
)
>
&
aAllocator
double
aSinceTime
bool
aIsShuttingDown
)
{
LOG
(
"
profiler_get_profile_json_into_lazily_allocated_buffer
"
)
;
SpliceableChunkedJSONWriter
b
;
if
(
!
WriteProfileToJSONWriter
(
b
aSinceTime
aIsShuttingDown
)
)
{
return
;
}
b
.
WriteFunc
(
)
-
>
CopyDataIntoLazilyAllocatedBuffer
(
aAllocator
)
;
}
void
profiler_get_start_params
(
int
*
aEntries
double
*
aInterval
uint32_t
*
aFeatures
Vector
<
const
char
*
>
*
aFilters
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
NS_WARN_IF
(
!
aEntries
)
|
|
NS_WARN_IF
(
!
aInterval
)
|
|
NS_WARN_IF
(
!
aFeatures
)
|
|
NS_WARN_IF
(
!
aFilters
)
)
{
return
;
}
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
*
aEntries
=
0
;
*
aInterval
=
0
;
*
aFeatures
=
0
;
aFilters
-
>
clear
(
)
;
return
;
}
*
aEntries
=
ActivePS
:
:
Entries
(
lock
)
;
*
aInterval
=
ActivePS
:
:
Interval
(
lock
)
;
*
aFeatures
=
ActivePS
:
:
Features
(
lock
)
;
const
Vector
<
std
:
:
string
>
&
filters
=
ActivePS
:
:
Filters
(
lock
)
;
MOZ_ALWAYS_TRUE
(
aFilters
-
>
resize
(
filters
.
length
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
filters
.
length
(
)
;
+
+
i
)
{
(
*
aFilters
)
[
i
]
=
filters
[
i
]
.
c_str
(
)
;
}
}
AutoSetProfilerEnvVarsForChildProcess
:
:
AutoSetProfilerEnvVarsForChildProcess
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM_IN_IMPL
)
:
mSetEntries
(
)
mSetInterval
(
)
mSetFeaturesBitfield
(
)
mSetFilters
(
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
PR_SetEnv
(
"
MOZ_PROFILER_STARTUP
=
"
)
;
return
;
}
PR_SetEnv
(
"
MOZ_PROFILER_STARTUP
=
1
"
)
;
SprintfLiteral
(
mSetEntries
"
MOZ_PROFILER_STARTUP_ENTRIES
=
%
d
"
ActivePS
:
:
Entries
(
lock
)
)
;
PR_SetEnv
(
mSetEntries
)
;
nsCString
setInterval
;
setInterval
.
AppendLiteral
(
"
MOZ_PROFILER_STARTUP_INTERVAL
=
"
)
;
setInterval
.
AppendFloat
(
ActivePS
:
:
Interval
(
lock
)
)
;
strncpy
(
mSetInterval
setInterval
.
get
(
)
MOZ_ARRAY_LENGTH
(
mSetInterval
)
)
;
mSetInterval
[
MOZ_ARRAY_LENGTH
(
mSetInterval
)
-
1
]
=
'
\
0
'
;
PR_SetEnv
(
mSetInterval
)
;
SprintfLiteral
(
mSetFeaturesBitfield
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
=
%
d
"
ActivePS
:
:
Features
(
lock
)
)
;
PR_SetEnv
(
mSetFeaturesBitfield
)
;
std
:
:
string
filtersString
;
const
Vector
<
std
:
:
string
>
&
filters
=
ActivePS
:
:
Filters
(
lock
)
;
for
(
uint32_t
i
=
0
;
i
<
filters
.
length
(
)
;
+
+
i
)
{
filtersString
+
=
filters
[
i
]
;
if
(
i
!
=
filters
.
length
(
)
-
1
)
{
filtersString
+
=
"
"
;
}
}
SprintfLiteral
(
mSetFilters
"
MOZ_PROFILER_STARTUP_FILTERS
=
%
s
"
filtersString
.
c_str
(
)
)
;
PR_SetEnv
(
mSetFilters
)
;
}
AutoSetProfilerEnvVarsForChildProcess
:
:
~
AutoSetProfilerEnvVarsForChildProcess
(
)
{
PR_SetEnv
(
"
MOZ_PROFILER_STARTUP
=
"
)
;
PR_SetEnv
(
"
MOZ_PROFILER_STARTUP_ENTRIES
=
"
)
;
PR_SetEnv
(
"
MOZ_PROFILER_STARTUP_INTERVAL
=
"
)
;
PR_SetEnv
(
"
MOZ_PROFILER_STARTUP_FEATURES_BITFIELD
=
"
)
;
PR_SetEnv
(
"
MOZ_PROFILER_STARTUP_FILTERS
=
"
)
;
}
static
void
locked_profiler_save_profile_to_file
(
PSLockRef
aLock
const
char
*
aFilename
bool
aIsShuttingDown
=
false
)
{
LOG
(
"
locked_profiler_save_profile_to_file
(
%
s
)
"
aFilename
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
std
:
:
ofstream
stream
;
stream
.
open
(
aFilename
)
;
if
(
stream
.
is_open
(
)
)
{
SpliceableJSONWriter
w
(
MakeUnique
<
OStreamJSONWriteFunc
>
(
stream
)
)
;
w
.
Start
(
)
;
{
locked_profiler_stream_json_for_this_process
(
aLock
w
0
aIsShuttingDown
)
;
w
.
StartArrayProperty
(
"
processes
"
)
;
w
.
EndArray
(
)
;
}
w
.
End
(
)
;
stream
.
close
(
)
;
}
}
void
profiler_save_profile_to_file
(
const
char
*
aFilename
)
{
LOG
(
"
profiler_save_profile_to_file
(
%
s
)
"
aFilename
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
locked_profiler_save_profile_to_file
(
lock
aFilename
)
;
}
uint32_t
profiler_get_available_features
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
uint32_t
features
=
0
;
#
define
ADD_FEATURE
(
n_
str_
Name_
)
ProfilerFeature
:
:
Set
#
#
Name_
(
features
)
;
PROFILER_FOR_EACH_FEATURE
(
ADD_FEATURE
)
#
undef
ADD_FEATURE
#
if
!
defined
(
GP_OS_android
)
ProfilerFeature
:
:
ClearJava
(
features
)
;
#
endif
#
if
!
defined
(
HAVE_NATIVE_UNWIND
)
ProfilerFeature
:
:
ClearStackWalk
(
features
)
;
#
endif
#
if
!
defined
(
MOZ_TASK_TRACER
)
ProfilerFeature
:
:
ClearTaskTracer
(
features
)
;
#
endif
return
features
;
}
Maybe
<
ProfilerBufferInfo
>
profiler_get_buffer_info
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
Nothing
(
)
;
}
return
Some
(
ProfilerBufferInfo
{
ActivePS
:
:
Buffer
(
lock
)
.
mRangeStart
ActivePS
:
:
Buffer
(
lock
)
.
mRangeEnd
ActivePS
:
:
Entries
(
lock
)
}
)
;
}
static
void
PollJSSamplingForCurrentThread
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
!
registeredThread
)
{
return
;
}
registeredThread
-
>
PollJSSampling
(
)
;
}
static
void
TriggerPollJSSamplingOnMainThread
(
)
{
nsCOMPtr
<
nsIThread
>
mainThread
;
nsresult
rv
=
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mainThread
)
{
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
"
TriggerPollJSSamplingOnMainThread
"
[
]
(
)
{
PollJSSamplingForCurrentThread
(
)
;
}
)
;
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
task
.
forget
(
)
)
;
}
}
static
void
locked_profiler_start
(
PSLockRef
aLock
uint32_t
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
{
if
(
LOG_TEST
)
{
LOG
(
"
locked_profiler_start
"
)
;
LOG
(
"
-
entries
=
%
d
"
aEntries
)
;
LOG
(
"
-
interval
=
%
.
2f
"
aInterval
)
;
#
define
LOG_FEATURE
(
n_
str_
Name_
)
\
if
(
ProfilerFeature
:
:
Has
#
#
Name_
(
aFeatures
)
)
{
\
LOG
(
"
-
feature
=
%
s
"
str_
)
;
\
}
PROFILER_FOR_EACH_FEATURE
(
LOG_FEATURE
)
#
undef
LOG_FEATURE
for
(
uint32_t
i
=
0
;
i
<
aFilterCount
;
i
+
+
)
{
LOG
(
"
-
threads
=
%
s
"
aFilters
[
i
]
)
;
}
}
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
!
ActivePS
:
:
Exists
(
aLock
)
)
;
#
if
defined
(
GP_PLAT_amd64_windows
)
InitializeWin64ProfilerHooks
(
)
;
#
endif
uint32_t
entries
=
aEntries
>
0
?
aEntries
:
PROFILER_DEFAULT_ENTRIES
;
double
interval
=
aInterval
>
0
?
aInterval
:
PROFILER_DEFAULT_INTERVAL
;
ActivePS
:
:
Create
(
aLock
entries
interval
aFeatures
aFilters
aFilterCount
)
;
int
tid
=
Thread
:
:
GetCurrentId
(
)
;
const
nsTArray
<
UniquePtr
<
RegisteredThread
>
>
&
registeredThreads
=
CorePS
:
:
RegisteredThreads
(
aLock
)
;
for
(
auto
&
registeredThread
:
registeredThreads
)
{
RefPtr
<
ThreadInfo
>
info
=
registeredThread
-
>
Info
(
)
;
if
(
ActivePS
:
:
ShouldProfileThread
(
aLock
info
)
)
{
nsCOMPtr
<
nsIEventTarget
>
eventTarget
=
registeredThread
-
>
GetEventTarget
(
)
;
ProfiledThreadData
*
profiledThreadData
=
ActivePS
:
:
AddLiveProfiledThread
(
aLock
registeredThread
.
get
(
)
MakeUnique
<
ProfiledThreadData
>
(
info
eventTarget
ActivePS
:
:
FeatureResponsiveness
(
aLock
)
)
)
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
registeredThread
-
>
StartJSSampling
(
ActivePS
:
:
FeatureTrackOptimizations
(
aLock
)
)
;
if
(
info
-
>
ThreadId
(
)
=
=
tid
)
{
registeredThread
-
>
PollJSSampling
(
)
;
}
else
if
(
info
-
>
IsMainThread
(
)
)
{
TriggerPollJSSamplingOnMainThread
(
)
;
}
}
registeredThread
-
>
RacyRegisteredThread
(
)
.
ReinitializeOnResume
(
)
;
if
(
registeredThread
-
>
GetJSContext
(
)
)
{
profiledThreadData
-
>
NotifyReceivedJSContext
(
0
)
;
}
}
}
#
ifdef
MOZ_TASK_TRACER
if
(
ActivePS
:
:
FeatureTaskTracer
(
aLock
)
)
{
tasktracer
:
:
StartLogging
(
)
;
}
#
endif
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
int
javaInterval
=
interval
;
if
(
javaInterval
<
10
)
{
javaInterval
=
10
;
}
java
:
:
GeckoJavaSampler
:
:
Start
(
javaInterval
1000
)
;
}
#
endif
RacyFeatures
:
:
SetActive
(
ActivePS
:
:
Features
(
aLock
)
)
;
}
void
profiler_start
(
uint32_t
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
{
LOG
(
"
profiler_start
"
)
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
profiler_init
(
nullptr
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
locked_profiler_start
(
lock
aEntries
aInterval
aFeatures
aFilters
aFilterCount
)
;
}
if
(
samplerThread
)
{
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
NotifyProfilerStarted
(
aEntries
aInterval
aFeatures
aFilters
aFilterCount
)
;
}
void
profiler_ensure_started
(
uint32_t
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
{
LOG
(
"
profiler_ensure_started
"
)
;
bool
startedProfiler
=
false
;
SamplerThread
*
samplerThread
=
nullptr
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
profiler_init
(
nullptr
)
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
if
(
!
ActivePS
:
:
Equals
(
lock
aEntries
aInterval
aFeatures
aFilters
aFilterCount
)
)
{
samplerThread
=
locked_profiler_stop
(
lock
)
;
locked_profiler_start
(
lock
aEntries
aInterval
aFeatures
aFilters
aFilterCount
)
;
startedProfiler
=
true
;
}
}
else
{
locked_profiler_start
(
lock
aEntries
aInterval
aFeatures
aFilters
aFilterCount
)
;
startedProfiler
=
true
;
}
}
if
(
samplerThread
)
{
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
if
(
startedProfiler
)
{
NotifyProfilerStarted
(
aEntries
aInterval
aFeatures
aFilters
aFilterCount
)
;
}
}
static
MOZ_MUST_USE
SamplerThread
*
locked_profiler_stop
(
PSLockRef
aLock
)
{
LOG
(
"
locked_profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
&
&
ActivePS
:
:
Exists
(
aLock
)
)
;
RacyFeatures
:
:
SetInactive
(
)
;
#
if
defined
(
GP_OS_android
)
if
(
ActivePS
:
:
FeatureJava
(
aLock
)
)
{
java
:
:
GeckoJavaSampler
:
:
Stop
(
)
;
}
#
endif
#
ifdef
MOZ_TASK_TRACER
if
(
ActivePS
:
:
FeatureTaskTracer
(
aLock
)
)
{
tasktracer
:
:
StopLogging
(
)
;
}
#
endif
int
tid
=
Thread
:
:
GetCurrentId
(
)
;
const
nsTArray
<
LiveProfiledThreadData
>
&
liveProfiledThreads
=
ActivePS
:
:
LiveProfiledThreads
(
aLock
)
;
for
(
auto
&
thread
:
liveProfiledThreads
)
{
RegisteredThread
*
registeredThread
=
thread
.
mRegisteredThread
;
if
(
ActivePS
:
:
FeatureJS
(
aLock
)
)
{
registeredThread
-
>
StopJSSampling
(
)
;
RefPtr
<
ThreadInfo
>
info
=
registeredThread
-
>
Info
(
)
;
if
(
info
-
>
ThreadId
(
)
=
=
tid
)
{
registeredThread
-
>
PollJSSampling
(
)
;
}
else
if
(
info
-
>
IsMainThread
(
)
)
{
TriggerPollJSSamplingOnMainThread
(
)
;
}
}
}
SamplerThread
*
samplerThread
=
ActivePS
:
:
Destroy
(
aLock
)
;
samplerThread
-
>
Stop
(
aLock
)
;
return
samplerThread
;
}
void
profiler_stop
(
)
{
LOG
(
"
profiler_stop
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
SamplerThread
*
samplerThread
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
samplerThread
=
locked_profiler_stop
(
lock
)
;
}
ProfilerParent
:
:
ProfilerStopped
(
)
;
NotifyObservers
(
"
profiler
-
stopped
"
)
;
delete
samplerThread
;
}
bool
profiler_is_paused
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
false
;
}
return
ActivePS
:
:
IsPaused
(
lock
)
;
}
void
profiler_pause
(
)
{
LOG
(
"
profiler_pause
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
ActivePS
:
:
SetIsPaused
(
lock
true
)
;
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
Pause
(
profiler_time
(
)
)
)
;
}
ProfilerParent
:
:
ProfilerPaused
(
)
;
NotifyObservers
(
"
profiler
-
paused
"
)
;
}
void
profiler_resume
(
)
{
LOG
(
"
profiler_resume
"
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
{
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
ActivePS
:
:
Buffer
(
lock
)
.
AddEntry
(
ProfileBufferEntry
:
:
Resume
(
profiler_time
(
)
)
)
;
ActivePS
:
:
SetIsPaused
(
lock
false
)
;
}
ProfilerParent
:
:
ProfilerResumed
(
)
;
NotifyObservers
(
"
profiler
-
resumed
"
)
;
}
bool
profiler_feature_active
(
uint32_t
aFeature
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
return
RacyFeatures
:
:
IsActiveWithFeature
(
aFeature
)
;
}
ProfilingStack
*
profiler_register_thread
(
const
char
*
aName
void
*
aGuessStackTop
)
{
DEBUG_LOG
(
"
profiler_register_thread
(
%
s
)
"
aName
)
;
MOZ_ASSERT_IF
(
NS_IsMainThread
(
)
Scheduler
:
:
IsCooperativeThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
(
void
)
NS_GetCurrentThread
(
)
;
NS_SetCurrentThreadName
(
aName
)
;
PSAutoLock
lock
(
gPSMutex
)
;
void
*
stackTop
=
GetStackTop
(
aGuessStackTop
)
;
return
locked_register_thread
(
lock
aName
stackTop
)
;
}
void
profiler_unregister_thread
(
)
{
MOZ_ASSERT_IF
(
NS_IsMainThread
(
)
Scheduler
:
:
IsCooperativeThread
(
)
)
;
if
(
!
CorePS
:
:
Exists
(
)
)
{
return
;
}
PSAutoLock
lock
(
gPSMutex
)
;
RegisteredThread
*
registeredThread
=
FindCurrentThreadRegisteredThread
(
lock
)
;
MOZ_RELEASE_ASSERT
(
registeredThread
=
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
)
;
if
(
registeredThread
)
{
RefPtr
<
ThreadInfo
>
info
=
registeredThread
-
>
Info
(
)
;
DEBUG_LOG
(
"
profiler_unregister_thread
:
%
s
"
info
-
>
Name
(
)
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ActivePS
:
:
UnregisterThread
(
lock
registeredThread
)
;
}
TLSRegisteredThread
:
:
SetRegisteredThread
(
lock
nullptr
)
;
CorePS
:
:
RemoveRegisteredThread
(
lock
registeredThread
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
!
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
)
;
}
}
void
profiler_thread_sleep
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
RacyRegisteredThread
*
racyRegisteredThread
=
TLSRegisteredThread
:
:
RacyRegisteredThread
(
)
;
if
(
!
racyRegisteredThread
)
{
return
;
}
racyRegisteredThread
-
>
SetSleeping
(
)
;
}
void
profiler_thread_wake
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
RacyRegisteredThread
*
racyRegisteredThread
=
TLSRegisteredThread
:
:
RacyRegisteredThread
(
)
;
if
(
!
racyRegisteredThread
)
{
return
;
}
racyRegisteredThread
-
>
SetAwake
(
)
;
}
bool
profiler_thread_is_sleeping
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
RacyRegisteredThread
*
racyRegisteredThread
=
TLSRegisteredThread
:
:
RacyRegisteredThread
(
)
;
if
(
!
racyRegisteredThread
)
{
return
false
;
}
return
racyRegisteredThread
-
>
IsSleeping
(
)
;
}
void
profiler_js_interrupt_callback
(
)
{
PollJSSamplingForCurrentThread
(
)
;
}
double
profiler_time
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
TimeDuration
delta
=
TimeStamp
:
:
Now
(
)
-
CorePS
:
:
ProcessStartTime
(
)
;
return
delta
.
ToMilliseconds
(
)
;
}
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
|
|
ActivePS
:
:
FeaturePrivacy
(
lock
)
)
{
return
nullptr
;
}
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
!
registeredThread
)
{
MOZ_ASSERT
(
registeredThread
)
;
return
nullptr
;
}
int
tid
=
Thread
:
:
GetCurrentId
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
Registers
regs
;
#
if
defined
(
HAVE_NATIVE_UNWIND
)
regs
.
SyncPopulate
(
)
;
#
else
regs
.
Clear
(
)
;
#
endif
auto
buffer
=
MakeUnique
<
ProfileBuffer
>
(
1000
)
;
DoSyncSample
(
lock
*
registeredThread
now
regs
*
buffer
.
get
(
)
)
;
return
UniqueProfilerBacktrace
(
new
ProfilerBacktrace
(
"
SyncProfile
"
tid
std
:
:
move
(
buffer
)
)
)
;
}
void
ProfilerBacktraceDestructor
:
:
operator
(
)
(
ProfilerBacktrace
*
aBacktrace
)
{
delete
aBacktrace
;
}
static
void
racy_profiler_add_marker
(
const
char
*
aMarkerName
UniquePtr
<
ProfilerMarkerPayload
>
aPayload
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
RacyRegisteredThread
*
racyRegisteredThread
=
TLSRegisteredThread
:
:
RacyRegisteredThread
(
)
;
if
(
!
racyRegisteredThread
)
{
return
;
}
TimeStamp
origin
=
(
aPayload
&
&
!
aPayload
-
>
GetStartTime
(
)
.
IsNull
(
)
)
?
aPayload
-
>
GetStartTime
(
)
:
TimeStamp
:
:
Now
(
)
;
TimeDuration
delta
=
origin
-
CorePS
:
:
ProcessStartTime
(
)
;
racyRegisteredThread
-
>
AddPendingMarker
(
aMarkerName
std
:
:
move
(
aPayload
)
delta
.
ToMilliseconds
(
)
)
;
}
void
profiler_add_marker
(
const
char
*
aMarkerName
UniquePtr
<
ProfilerMarkerPayload
>
aPayload
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
if
(
!
RacyFeatures
:
:
IsActiveWithoutPrivacy
(
)
)
{
return
;
}
racy_profiler_add_marker
(
aMarkerName
std
:
:
move
(
aPayload
)
)
;
}
void
profiler_add_marker
(
const
char
*
aMarkerName
)
{
profiler_add_marker
(
aMarkerName
nullptr
)
;
}
void
profiler_add_network_marker
(
nsIURI
*
aURI
int32_t
aPriority
uint64_t
aChannelId
NetworkLoadType
aType
mozilla
:
:
TimeStamp
aStart
mozilla
:
:
TimeStamp
aEnd
int64_t
aCount
const
mozilla
:
:
net
:
:
TimingStruct
*
aTimings
nsIURI
*
aRedirectURI
)
{
if
(
!
profiler_is_active
(
)
)
{
return
;
}
nsAutoCString
spec
;
nsAutoCString
redirect_spec
;
if
(
aURI
)
{
aURI
-
>
GetAsciiSpec
(
spec
)
;
}
if
(
aRedirectURI
)
{
aRedirectURI
-
>
GetAsciiSpec
(
redirect_spec
)
;
}
uint32_t
id
=
static_cast
<
uint32_t
>
(
aChannelId
&
0xFFFFFFFF
)
;
char
name
[
2048
]
;
SprintfLiteral
(
name
"
Load
%
d
:
%
s
"
id
PromiseFlatCString
(
spec
)
.
get
(
)
)
;
profiler_add_marker
(
name
MakeUnique
<
NetworkMarkerPayload
>
(
static_cast
<
int64_t
>
(
aChannelId
)
PromiseFlatCString
(
spec
)
.
get
(
)
aType
aStart
aEnd
aPriority
aCount
aTimings
PromiseFlatCString
(
redirect_spec
)
.
get
(
)
)
)
;
}
void
profiler_add_marker_for_thread
(
int
aThreadId
const
char
*
aMarkerName
UniquePtr
<
ProfilerMarkerPayload
>
aPayload
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
if
(
!
ActivePS
:
:
Exists
(
lock
)
)
{
return
;
}
TimeStamp
origin
=
(
aPayload
&
&
!
aPayload
-
>
GetStartTime
(
)
.
IsNull
(
)
)
?
aPayload
-
>
GetStartTime
(
)
:
TimeStamp
:
:
Now
(
)
;
TimeDuration
delta
=
origin
-
CorePS
:
:
ProcessStartTime
(
)
;
ProfilerMarker
*
marker
=
new
ProfilerMarker
(
aMarkerName
aThreadId
std
:
:
move
(
aPayload
)
delta
.
ToMilliseconds
(
)
)
;
#
ifdef
DEBUG
bool
realThread
=
false
;
const
nsTArray
<
UniquePtr
<
RegisteredThread
>
>
&
registeredThreads
=
CorePS
:
:
RegisteredThreads
(
lock
)
;
for
(
auto
&
thread
:
registeredThreads
)
{
RefPtr
<
ThreadInfo
>
info
=
thread
-
>
Info
(
)
;
if
(
info
-
>
ThreadId
(
)
=
=
aThreadId
)
{
realThread
=
true
;
break
;
}
}
MOZ_ASSERT
(
realThread
"
Invalid
thread
id
"
)
;
#
endif
ProfileBuffer
&
buffer
=
ActivePS
:
:
Buffer
(
lock
)
;
buffer
.
AddStoredMarker
(
marker
)
;
buffer
.
AddEntry
(
ProfileBufferEntry
:
:
Marker
(
marker
)
)
;
}
void
profiler_tracing
(
const
char
*
aCategory
const
char
*
aMarkerName
TracingKind
aKind
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
VTUNE_TRACING
(
aMarkerName
aKind
)
;
if
(
!
RacyFeatures
:
:
IsActiveWithoutPrivacy
(
)
)
{
return
;
}
auto
payload
=
MakeUnique
<
TracingMarkerPayload
>
(
aCategory
aKind
)
;
racy_profiler_add_marker
(
aMarkerName
std
:
:
move
(
payload
)
)
;
}
void
profiler_tracing
(
const
char
*
aCategory
const
char
*
aMarkerName
TracingKind
aKind
UniqueProfilerBacktrace
aCause
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
VTUNE_TRACING
(
aMarkerName
aKind
)
;
if
(
!
RacyFeatures
:
:
IsActiveWithoutPrivacy
(
)
)
{
return
;
}
auto
payload
=
MakeUnique
<
TracingMarkerPayload
>
(
aCategory
aKind
std
:
:
move
(
aCause
)
)
;
racy_profiler_add_marker
(
aMarkerName
std
:
:
move
(
payload
)
)
;
}
void
profiler_set_js_context
(
JSContext
*
aCx
)
{
MOZ_ASSERT
(
aCx
)
;
PSAutoLock
lock
(
gPSMutex
)
;
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
!
registeredThread
)
{
return
;
}
registeredThread
-
>
SetJSContext
(
aCx
)
;
registeredThread
-
>
PollJSSampling
(
)
;
if
(
ActivePS
:
:
Exists
(
lock
)
)
{
ProfiledThreadData
*
profiledThreadData
=
ActivePS
:
:
GetProfiledThreadData
(
lock
registeredThread
)
;
if
(
profiledThreadData
)
{
profiledThreadData
-
>
NotifyReceivedJSContext
(
ActivePS
:
:
Buffer
(
lock
)
.
mRangeEnd
)
;
}
}
}
void
profiler_clear_js_context
(
)
{
MOZ_RELEASE_ASSERT
(
CorePS
:
:
Exists
(
)
)
;
PSAutoLock
lock
(
gPSMutex
)
;
RegisteredThread
*
registeredThread
=
TLSRegisteredThread
:
:
RegisteredThread
(
lock
)
;
if
(
!
registeredThread
)
{
return
;
}
JSContext
*
cx
=
registeredThread
-
>
GetJSContext
(
)
;
if
(
!
cx
)
{
return
;
}
if
(
ActivePS
:
:
Exists
(
lock
)
&
&
ActivePS
:
:
FeatureJS
(
lock
)
)
{
ProfiledThreadData
*
profiledThreadData
=
ActivePS
:
:
GetProfiledThreadData
(
lock
registeredThread
)
;
if
(
profiledThreadData
)
{
profiledThreadData
-
>
NotifyAboutToLoseJSContext
(
cx
CorePS
:
:
ProcessStartTime
(
)
ActivePS
:
:
Buffer
(
lock
)
)
;
registeredThread
-
>
StopJSSampling
(
)
;
registeredThread
-
>
PollJSSampling
(
)
;
registeredThread
-
>
ClearJSContext
(
)
;
registeredThread
-
>
StartJSSampling
(
ActivePS
:
:
FeatureTrackOptimizations
(
lock
)
)
;
return
;
}
}
registeredThread
-
>
ClearJSContext
(
)
;
}
int
profiler_current_thread_id
(
)
{
return
Thread
:
:
GetCurrentId
(
)
;
}
void
profiler_suspend_and_sample_thread
(
int
aThreadId
uint32_t
aFeatures
ProfilerStackCollector
&
aCollector
bool
aSampleNative
)
{
PSAutoLock
lock
(
gPSMutex
)
;
const
nsTArray
<
UniquePtr
<
RegisteredThread
>
>
&
registeredThreads
=
CorePS
:
:
RegisteredThreads
(
lock
)
;
for
(
auto
&
thread
:
registeredThreads
)
{
RefPtr
<
ThreadInfo
>
info
=
thread
-
>
Info
(
)
;
RegisteredThread
&
registeredThread
=
*
thread
.
get
(
)
;
if
(
info
-
>
ThreadId
(
)
=
=
aThreadId
)
{
if
(
info
-
>
IsMainThread
(
)
)
{
aCollector
.
SetIsMainThread
(
)
;
}
NativeStack
nativeStack
;
Sampler
sampler
(
lock
)
;
sampler
.
SuspendAndSampleAndResumeThread
(
lock
registeredThread
[
&
]
(
const
Registers
&
aRegs
)
{
bool
isSynchronous
=
false
;
#
if
defined
(
HAVE_FASTINIT_NATIVE_UNWIND
)
if
(
aSampleNative
)
{
#
if
defined
(
USE_FRAME_POINTER_STACK_WALK
)
DoFramePointerBacktrace
(
lock
registeredThread
aRegs
nativeStack
)
;
#
elif
defined
(
USE_MOZ_STACK_WALK
)
DoMozStackWalkBacktrace
(
lock
registeredThread
aRegs
nativeStack
)
;
#
else
#
error
"
Invalid
configuration
"
#
endif
MergeStacks
(
aFeatures
isSynchronous
registeredThread
aRegs
nativeStack
aCollector
)
;
}
else
#
endif
{
MergeStacks
(
aFeatures
isSynchronous
registeredThread
aRegs
nativeStack
aCollector
)
;
if
(
ProfilerFeature
:
:
HasLeaf
(
aFeatures
)
)
{
aCollector
.
CollectNativeLeafAddr
(
(
void
*
)
aRegs
.
mPC
)
;
}
}
}
)
;
sampler
.
Disable
(
lock
)
;
break
;
}
}
}
