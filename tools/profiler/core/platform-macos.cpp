#
include
<
unistd
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
mach
/
mach_init
.
h
>
#
include
<
mach
-
o
/
getsect
.
h
>
#
include
<
AvailabilityMacros
.
h
>
#
include
<
pthread
.
h
>
#
include
<
semaphore
.
h
>
#
include
<
signal
.
h
>
#
include
<
libkern
/
OSAtomic
.
h
>
#
include
<
libproc
.
h
>
#
include
<
mach
/
mach
.
h
>
#
include
<
mach
/
semaphore
.
h
>
#
include
<
mach
/
task
.
h
>
#
include
<
mach
/
thread_act
.
h
>
#
include
<
mach
/
vm_statistics
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
sys
/
resource
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
sysctl
.
h
>
#
include
<
stdarg
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
errno
.
h
>
#
include
<
math
.
h
>
int
profiler_current_process_id
(
)
{
return
getpid
(
)
;
}
int
profiler_current_thread_id
(
)
{
uint64_t
tid
;
pthread_threadid_np
(
nullptr
&
tid
)
;
return
static_cast
<
int
>
(
tid
)
;
}
void
*
GetStackTop
(
void
*
aGuess
)
{
pthread_t
thread
=
pthread_self
(
)
;
return
pthread_get_stackaddr_np
(
thread
)
;
}
class
PlatformData
{
public
:
explicit
PlatformData
(
int
aThreadId
)
:
mProfiledThread
(
mach_thread_self
(
)
)
{
MOZ_COUNT_CTOR
(
PlatformData
)
;
}
~
PlatformData
(
)
{
mach_port_deallocate
(
mach_task_self
(
)
mProfiledThread
)
;
MOZ_COUNT_DTOR
(
PlatformData
)
;
}
thread_act_t
ProfiledThread
(
)
const
{
return
mProfiledThread
;
}
RunningTimes
&
PreviousThreadRunningTimesRef
(
)
{
return
mPreviousThreadRunningTimes
;
}
private
:
thread_act_t
mProfiledThread
;
RunningTimes
mPreviousThreadRunningTimes
;
}
;
Sampler
:
:
Sampler
(
PSLockRef
aLock
)
{
}
void
Sampler
:
:
Disable
(
PSLockRef
aLock
)
{
}
static
void
StreamMetaPlatformSampleUnits
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
aWriter
.
StringProperty
(
"
threadCPUDelta
"
"
\
u00B5s
"
)
;
}
static
RunningTimes
GetThreadRunningTimesDiff
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
)
{
AUTO_PROFILER_STATS
(
GetRunningTimes
)
;
PlatformData
*
platformData
=
aRegisteredThread
.
GetPlatformData
(
)
;
MOZ_RELEASE_ASSERT
(
platformData
)
;
const
RunningTimes
newRunningTimes
=
GetRunningTimesWithTightTimestamp
(
[
platformData
]
(
RunningTimes
&
aRunningTimes
)
{
AUTO_PROFILER_STATS
(
GetRunningTimes_thread_info
)
;
thread_basic_info_data_t
threadBasicInfo
;
mach_msg_type_number_t
basicCount
=
THREAD_BASIC_INFO_COUNT
;
if
(
thread_info
(
platformData
-
>
ProfiledThread
(
)
THREAD_BASIC_INFO
reinterpret_cast
<
thread_info_t
>
(
&
threadBasicInfo
)
&
basicCount
)
=
=
KERN_SUCCESS
&
&
basicCount
=
=
THREAD_BASIC_INFO_COUNT
)
{
uint64_t
userTimeUs
=
uint64_t
(
threadBasicInfo
.
user_time
.
seconds
)
*
uint64_t
(
USEC_PER_SEC
)
+
uint64_t
(
threadBasicInfo
.
user_time
.
microseconds
)
;
uint64_t
systemTimeUs
=
uint64_t
(
threadBasicInfo
.
system_time
.
seconds
)
*
uint64_t
(
USEC_PER_SEC
)
+
uint64_t
(
threadBasicInfo
.
system_time
.
microseconds
)
;
aRunningTimes
.
ResetThreadCPUDelta
(
userTimeUs
+
systemTimeUs
)
;
}
else
{
aRunningTimes
.
ClearThreadCPUDelta
(
)
;
}
}
)
;
const
RunningTimes
diff
=
newRunningTimes
-
platformData
-
>
PreviousThreadRunningTimesRef
(
)
;
platformData
-
>
PreviousThreadRunningTimesRef
(
)
=
newRunningTimes
;
return
diff
;
}
static
void
ClearThreadRunningTimes
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
)
{
PlatformData
*
const
platformData
=
aRegisteredThread
.
GetPlatformData
(
)
;
MOZ_RELEASE_ASSERT
(
platformData
)
;
platformData
-
>
PreviousThreadRunningTimesRef
(
)
.
Clear
(
)
;
}
template
<
typename
Func
>
void
Sampler
:
:
SuspendAndSampleAndResumeThread
(
PSLockRef
aLock
const
RegisteredThread
&
aRegisteredThread
const
TimeStamp
&
aNow
const
Func
&
aProcessRegs
)
{
thread_act_t
samplee_thread
=
aRegisteredThread
.
GetPlatformData
(
)
-
>
ProfiledThread
(
)
;
if
(
KERN_SUCCESS
!
=
thread_suspend
(
samplee_thread
)
)
{
return
;
}
#
if
defined
(
__x86_64__
)
thread_state_flavor_t
flavor
=
x86_THREAD_STATE64
;
x86_thread_state64_t
state
;
mach_msg_type_number_t
count
=
x86_THREAD_STATE64_COUNT
;
#
if
__DARWIN_UNIX03
#
define
REGISTER_FIELD
(
name
)
__r
#
#
name
#
else
#
define
REGISTER_FIELD
(
name
)
r
#
#
name
#
endif
#
elif
defined
(
__aarch64__
)
thread_state_flavor_t
flavor
=
ARM_THREAD_STATE64
;
arm_thread_state64_t
state
;
mach_msg_type_number_t
count
=
ARM_THREAD_STATE64_COUNT
;
#
if
__DARWIN_UNIX03
#
define
REGISTER_FIELD
(
name
)
__
#
#
name
#
else
#
define
REGISTER_FIELD
(
name
)
name
#
endif
#
else
#
error
"
unknown
architecture
"
#
endif
if
(
thread_get_state
(
samplee_thread
flavor
reinterpret_cast
<
natural_t
*
>
(
&
state
)
&
count
)
=
=
KERN_SUCCESS
)
{
Registers
regs
;
#
if
defined
(
__x86_64__
)
regs
.
mPC
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
ip
)
)
;
regs
.
mSP
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
sp
)
)
;
regs
.
mFP
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
bp
)
)
;
#
elif
defined
(
__aarch64__
)
regs
.
mPC
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
pc
)
)
;
regs
.
mSP
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
sp
)
)
;
regs
.
mFP
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
fp
)
)
;
#
else
#
error
"
unknown
architecture
"
#
endif
regs
.
mLR
=
0
;
aProcessRegs
(
regs
aNow
)
;
}
#
undef
REGISTER_FIELD
thread_resume
(
samplee_thread
)
;
}
static
void
*
ThreadEntry
(
void
*
aArg
)
{
auto
thread
=
static_cast
<
SamplerThread
*
>
(
aArg
)
;
thread
-
>
Run
(
)
;
return
nullptr
;
}
SamplerThread
:
:
SamplerThread
(
PSLockRef
aLock
uint32_t
aActivityGeneration
double
aIntervalMilliseconds
bool
aStackWalkEnabled
bool
aNoTimerResolutionChange
)
:
mSampler
(
aLock
)
mActivityGeneration
(
aActivityGeneration
)
mIntervalMicroseconds
(
std
:
:
max
(
1
int
(
floor
(
aIntervalMilliseconds
*
1000
+
0
.
5
)
)
)
)
mThread
{
nullptr
}
{
pthread_attr_t
*
attr_ptr
=
nullptr
;
if
(
pthread_create
(
&
mThread
attr_ptr
ThreadEntry
this
)
!
=
0
)
{
MOZ_CRASH
(
"
pthread_create
failed
"
)
;
}
}
SamplerThread
:
:
~
SamplerThread
(
)
{
pthread_join
(
mThread
nullptr
)
;
InvokePostSamplingCallbacks
(
std
:
:
move
(
mPostSamplingCallbackList
)
SamplingState
:
:
JustStopped
)
;
}
void
SamplerThread
:
:
SleepMicro
(
uint32_t
aMicroseconds
)
{
usleep
(
aMicroseconds
)
;
}
void
SamplerThread
:
:
Stop
(
PSLockRef
aLock
)
{
mSampler
.
Disable
(
aLock
)
;
}
static
void
PlatformInit
(
PSLockRef
aLock
)
{
}
#
if
defined
(
HAVE_NATIVE_UNWIND
)
void
Registers
:
:
SyncPopulate
(
)
{
#
if
defined
(
__x86_64__
)
asm
(
"
leaq
0x10
(
%
%
rbp
)
%
0
\
n
\
t
"
"
movq
(
%
%
rbp
)
%
1
\
n
\
t
"
:
"
=
r
"
(
mSP
)
"
=
r
"
(
mFP
)
)
;
#
elif
defined
(
__aarch64__
)
asm
(
"
add
%
0
x29
#
0x10
\
n
\
t
"
"
ldr
%
1
[
x29
]
\
n
\
t
"
:
"
=
r
"
(
mSP
)
"
=
r
"
(
mFP
)
)
;
#
else
#
error
"
unknown
architecture
"
#
endif
mPC
=
reinterpret_cast
<
Address
>
(
__builtin_extract_return_addr
(
__builtin_return_address
(
0
)
)
)
;
mLR
=
0
;
}
#
endif
