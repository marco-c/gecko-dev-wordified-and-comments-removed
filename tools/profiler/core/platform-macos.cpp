#
include
<
unistd
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
mach
/
mach_init
.
h
>
#
include
<
mach
-
o
/
getsect
.
h
>
#
include
<
AvailabilityMacros
.
h
>
#
include
<
pthread
.
h
>
#
include
<
semaphore
.
h
>
#
include
<
signal
.
h
>
#
include
<
libkern
/
OSAtomic
.
h
>
#
include
<
libproc
.
h
>
#
include
<
mach
/
mach
.
h
>
#
include
<
mach
/
semaphore
.
h
>
#
include
<
mach
/
task
.
h
>
#
include
<
mach
/
thread_act
.
h
>
#
include
<
mach
/
vm_statistics
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
sys
/
resource
.
h
>
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
sysctl
.
h
>
#
include
<
stdarg
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
errno
.
h
>
#
include
<
math
.
h
>
mozilla
:
:
profiler
:
:
PlatformData
:
:
PlatformData
(
ProfilerThreadId
aThreadId
)
:
mProfiledThread
(
mach_thread_self
(
)
)
{
}
mozilla
:
:
profiler
:
:
PlatformData
:
:
~
PlatformData
(
)
{
mach_port_deallocate
(
mach_task_self
(
)
mProfiledThread
)
;
}
Sampler
:
:
Sampler
(
PSLockRef
aLock
)
{
}
void
Sampler
:
:
Disable
(
PSLockRef
aLock
)
{
}
static
void
StreamMetaPlatformSampleUnits
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
aWriter
.
StringProperty
(
"
threadCPUDelta
"
"
\
u00B5s
"
)
;
}
uint64_t
RunningTimes
:
:
ConvertRawToJson
(
uint64_t
aRawValue
)
{
return
aRawValue
;
}
namespace
mozilla
:
:
profiler
{
bool
GetCpuTimeSinceThreadStartInNs
(
uint64_t
*
aResult
const
mozilla
:
:
profiler
:
:
PlatformData
&
aPlatformData
)
{
thread_extended_info_data_t
threadInfoData
;
mach_msg_type_number_t
count
=
THREAD_EXTENDED_INFO_COUNT
;
if
(
thread_info
(
aPlatformData
.
ProfiledThread
(
)
THREAD_EXTENDED_INFO
(
thread_info_t
)
&
threadInfoData
&
count
)
!
=
KERN_SUCCESS
)
{
return
false
;
}
*
aResult
=
threadInfoData
.
pth_user_time
+
threadInfoData
.
pth_system_time
;
return
true
;
}
}
static
RunningTimes
GetProcessRunningTimesDiff
(
PSLockRef
aLock
RunningTimes
&
aPreviousRunningTimesToBeUpdated
)
{
AUTO_PROFILER_STATS
(
GetProcessRunningTimes
)
;
RunningTimes
newRunningTimes
;
{
AUTO_PROFILER_STATS
(
GetProcessRunningTimes_task_info
)
;
static
const
auto
pid
=
getpid
(
)
;
struct
proc_taskinfo
pti
;
if
(
(
unsigned
long
)
proc_pidinfo
(
pid
PROC_PIDTASKINFO
0
&
pti
PROC_PIDTASKINFO_SIZE
)
>
=
PROC_PIDTASKINFO_SIZE
)
{
newRunningTimes
.
SetThreadCPUDelta
(
pti
.
pti_total_user
+
pti
.
pti_total_system
)
;
}
newRunningTimes
.
SetPostMeasurementTimeStamp
(
TimeStamp
:
:
Now
(
)
)
;
}
;
const
RunningTimes
diff
=
newRunningTimes
-
aPreviousRunningTimesToBeUpdated
;
aPreviousRunningTimesToBeUpdated
=
newRunningTimes
;
return
diff
;
}
static
RunningTimes
GetThreadRunningTimesDiff
(
PSLockRef
aLock
ThreadRegistration
:
:
UnlockedRWForLockedProfiler
&
aThreadData
)
{
AUTO_PROFILER_STATS
(
GetRunningTimes
)
;
const
mozilla
:
:
profiler
:
:
PlatformData
&
platformData
=
aThreadData
.
PlatformDataCRef
(
)
;
const
RunningTimes
newRunningTimes
=
GetRunningTimesWithTightTimestamp
(
[
&
platformData
]
(
RunningTimes
&
aRunningTimes
)
{
AUTO_PROFILER_STATS
(
GetRunningTimes_thread_info
)
;
thread_basic_info_data_t
threadBasicInfo
;
mach_msg_type_number_t
basicCount
=
THREAD_BASIC_INFO_COUNT
;
if
(
thread_info
(
platformData
.
ProfiledThread
(
)
THREAD_BASIC_INFO
reinterpret_cast
<
thread_info_t
>
(
&
threadBasicInfo
)
&
basicCount
)
=
=
KERN_SUCCESS
&
&
basicCount
=
=
THREAD_BASIC_INFO_COUNT
)
{
uint64_t
userTimeUs
=
uint64_t
(
threadBasicInfo
.
user_time
.
seconds
)
*
uint64_t
(
USEC_PER_SEC
)
+
uint64_t
(
threadBasicInfo
.
user_time
.
microseconds
)
;
uint64_t
systemTimeUs
=
uint64_t
(
threadBasicInfo
.
system_time
.
seconds
)
*
uint64_t
(
USEC_PER_SEC
)
+
uint64_t
(
threadBasicInfo
.
system_time
.
microseconds
)
;
aRunningTimes
.
ResetThreadCPUDelta
(
userTimeUs
+
systemTimeUs
)
;
}
else
{
aRunningTimes
.
ClearThreadCPUDelta
(
)
;
}
}
)
;
ProfiledThreadData
*
profiledThreadData
=
aThreadData
.
GetProfiledThreadData
(
aLock
)
;
MOZ_ASSERT
(
profiledThreadData
)
;
RunningTimes
&
previousRunningTimes
=
profiledThreadData
-
>
PreviousThreadRunningTimesRef
(
)
;
const
RunningTimes
diff
=
newRunningTimes
-
previousRunningTimes
;
previousRunningTimes
=
newRunningTimes
;
return
diff
;
}
static
void
DiscardSuspendedThreadRunningTimes
(
PSLockRef
aLock
ThreadRegistration
:
:
UnlockedRWForLockedProfiler
&
aThreadData
)
{
}
template
<
typename
Func
>
void
Sampler
:
:
SuspendAndSampleAndResumeThread
(
PSLockRef
aLock
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
TimeStamp
&
aNow
const
Func
&
aProcessRegs
)
{
thread_act_t
samplee_thread
=
aThreadData
.
PlatformDataCRef
(
)
.
ProfiledThread
(
)
;
if
(
KERN_SUCCESS
!
=
thread_suspend
(
samplee_thread
)
)
{
return
;
}
#
if
defined
(
__x86_64__
)
thread_state_flavor_t
flavor
=
x86_THREAD_STATE64
;
x86_thread_state64_t
state
;
mach_msg_type_number_t
count
=
x86_THREAD_STATE64_COUNT
;
#
if
__DARWIN_UNIX03
#
define
REGISTER_FIELD
(
name
)
__r
#
#
name
#
else
#
define
REGISTER_FIELD
(
name
)
r
#
#
name
#
endif
#
elif
defined
(
__aarch64__
)
thread_state_flavor_t
flavor
=
ARM_THREAD_STATE64
;
arm_thread_state64_t
state
;
mach_msg_type_number_t
count
=
ARM_THREAD_STATE64_COUNT
;
#
if
__DARWIN_UNIX03
#
define
REGISTER_FIELD
(
name
)
__
#
#
name
#
else
#
define
REGISTER_FIELD
(
name
)
name
#
endif
#
else
#
error
"
unknown
architecture
"
#
endif
if
(
thread_get_state
(
samplee_thread
flavor
reinterpret_cast
<
natural_t
*
>
(
&
state
)
&
count
)
=
=
KERN_SUCCESS
)
{
Registers
regs
;
#
if
defined
(
__x86_64__
)
regs
.
mPC
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
ip
)
)
;
regs
.
mSP
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
sp
)
)
;
regs
.
mFP
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
bp
)
)
;
regs
.
mLR
=
0
;
#
elif
defined
(
__aarch64__
)
regs
.
mPC
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
pc
)
)
;
regs
.
mSP
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
sp
)
)
;
regs
.
mFP
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
fp
)
)
;
regs
.
mLR
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
lr
)
)
;
#
else
#
error
"
unknown
architecture
"
#
endif
aProcessRegs
(
regs
aNow
)
;
}
#
undef
REGISTER_FIELD
thread_resume
(
samplee_thread
)
;
}
static
void
*
ThreadEntry
(
void
*
aArg
)
{
auto
thread
=
static_cast
<
SamplerThread
*
>
(
aArg
)
;
thread
-
>
Run
(
)
;
return
nullptr
;
}
SamplerThread
:
:
SamplerThread
(
PSLockRef
aLock
uint32_t
aActivityGeneration
double
aIntervalMilliseconds
uint32_t
aFeatures
)
:
mSampler
(
aLock
)
mActivityGeneration
(
aActivityGeneration
)
mIntervalMicroseconds
(
std
:
:
max
(
1
int
(
floor
(
aIntervalMilliseconds
*
1000
+
0
.
5
)
)
)
)
mThread
{
nullptr
}
{
pthread_attr_t
*
attr_ptr
=
nullptr
;
if
(
pthread_create
(
&
mThread
attr_ptr
ThreadEntry
this
)
!
=
0
)
{
MOZ_CRASH
(
"
pthread_create
failed
"
)
;
}
}
SamplerThread
:
:
~
SamplerThread
(
)
{
pthread_join
(
mThread
nullptr
)
;
InvokePostSamplingCallbacks
(
std
:
:
move
(
mPostSamplingCallbackList
)
SamplingState
:
:
JustStopped
)
;
}
void
SamplerThread
:
:
SleepMicro
(
uint32_t
aMicroseconds
)
{
usleep
(
aMicroseconds
)
;
}
void
SamplerThread
:
:
Stop
(
PSLockRef
aLock
)
{
mSampler
.
Disable
(
aLock
)
;
}
static
void
PlatformInit
(
PSLockRef
aLock
)
{
}
#
if
defined
(
HAVE_NATIVE_UNWIND
)
#
define
REGISTERS_SYNC_POPULATE
(
regs
)
\
regs
.
mSP
=
reinterpret_cast
<
Address
>
(
__builtin_frame_address
(
0
)
)
+
0x10
;
\
_Pragma
(
"
GCC
diagnostic
push
"
)
\
_Pragma
(
"
GCC
diagnostic
ignored
\
"
-
Wframe
-
address
\
"
"
)
\
regs
.
mFP
=
reinterpret_cast
<
Address
>
(
__builtin_frame_address
(
1
)
)
;
\
_Pragma
(
"
GCC
diagnostic
pop
"
)
\
regs
.
mPC
=
reinterpret_cast
<
Address
>
(
\
__builtin_extract_return_addr
(
__builtin_return_address
(
0
)
)
)
;
\
regs
.
mLR
=
0
;
#
endif
