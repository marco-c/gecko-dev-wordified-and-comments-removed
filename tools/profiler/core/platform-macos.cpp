#
include
<
dlfcn
.
h
>
#
include
<
unistd
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
mach
/
mach_init
.
h
>
#
include
<
mach
-
o
/
dyld
.
h
>
#
include
<
mach
-
o
/
getsect
.
h
>
#
include
<
AvailabilityMacros
.
h
>
#
include
<
pthread
.
h
>
#
include
<
semaphore
.
h
>
#
include
<
signal
.
h
>
#
include
<
libkern
/
OSAtomic
.
h
>
#
include
<
mach
/
mach
.
h
>
#
include
<
mach
/
semaphore
.
h
>
#
include
<
mach
/
task
.
h
>
#
include
<
mach
/
vm_statistics
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
sys
/
resource
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
sysctl
.
h
>
#
include
<
stdarg
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
errno
.
h
>
#
include
<
math
.
h
>
Thread
:
:
tid_t
Thread
:
:
GetCurrentId
(
)
{
return
gettid
(
)
;
}
static
void
SleepMicro
(
int
aMicroseconds
)
{
aMicroseconds
=
std
:
:
max
(
0
aMicroseconds
)
;
usleep
(
aMicroseconds
)
;
}
class
PlatformData
{
public
:
explicit
PlatformData
(
int
aThreadId
)
:
mProfiledThread
(
mach_thread_self
(
)
)
{
MOZ_COUNT_CTOR
(
PlatformData
)
;
}
~
PlatformData
(
)
{
mach_port_deallocate
(
mach_task_self
(
)
mProfiledThread
)
;
MOZ_COUNT_DTOR
(
PlatformData
)
;
}
thread_act_t
ProfiledThread
(
)
{
return
mProfiledThread
;
}
private
:
thread_act_t
mProfiledThread
;
}
;
static
void
SetThreadName
(
)
{
int
(
*
dynamic_pthread_setname_np
)
(
const
char
*
)
;
*
reinterpret_cast
<
void
*
*
>
(
&
dynamic_pthread_setname_np
)
=
dlsym
(
RTLD_DEFAULT
"
pthread_setname_np
"
)
;
if
(
!
dynamic_pthread_setname_np
)
return
;
dynamic_pthread_setname_np
(
"
SamplerThread
"
)
;
}
static
void
*
ThreadEntry
(
void
*
aArg
)
{
auto
thread
=
static_cast
<
SamplerThread
*
>
(
aArg
)
;
SetThreadName
(
)
;
thread
-
>
Run
(
)
;
return
nullptr
;
}
SamplerThread
:
:
SamplerThread
(
PS
:
:
LockRef
aLock
uint32_t
aActivityGeneration
double
aIntervalMilliseconds
)
:
mActivityGeneration
(
aActivityGeneration
)
mIntervalMicroseconds
(
std
:
:
max
(
1
int
(
floor
(
aIntervalMilliseconds
*
1000
+
0
.
5
)
)
)
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
pthread_attr_t
*
attr_ptr
=
nullptr
;
if
(
pthread_create
(
&
mThread
attr_ptr
ThreadEntry
this
)
!
=
0
)
{
MOZ_CRASH
(
"
pthread_create
failed
"
)
;
}
}
SamplerThread
:
:
~
SamplerThread
(
)
{
pthread_join
(
mThread
nullptr
)
;
}
void
SamplerThread
:
:
Stop
(
PS
:
:
LockRef
aLock
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
SamplerThread
:
:
SuspendAndSampleAndResumeThread
(
PS
:
:
LockRef
aLock
TickSample
*
aSample
)
{
thread_act_t
samplee_thread
=
aSample
-
>
mPlatformData
-
>
ProfiledThread
(
)
;
if
(
KERN_SUCCESS
!
=
thread_suspend
(
samplee_thread
)
)
{
return
;
}
#
if
defined
(
GP_ARCH_amd64
)
thread_state_flavor_t
flavor
=
x86_THREAD_STATE64
;
x86_thread_state64_t
state
;
mach_msg_type_number_t
count
=
x86_THREAD_STATE64_COUNT
;
#
if
__DARWIN_UNIX03
#
define
REGISTER_FIELD
(
name
)
__r
#
#
name
#
else
#
define
REGISTER_FIELD
(
name
)
r
#
#
name
#
endif
#
elif
defined
(
GP_ARCH_x86
)
thread_state_flavor_t
flavor
=
i386_THREAD_STATE
;
i386_thread_state_t
state
;
mach_msg_type_number_t
count
=
i386_THREAD_STATE_COUNT
;
#
if
__DARWIN_UNIX03
#
define
REGISTER_FIELD
(
name
)
__e
#
#
name
#
else
#
define
REGISTER_FIELD
(
name
)
e
#
#
name
#
endif
#
else
#
error
Unsupported
Mac
OS
X
host
architecture
.
#
endif
if
(
thread_get_state
(
samplee_thread
flavor
reinterpret_cast
<
natural_t
*
>
(
&
state
)
&
count
)
=
=
KERN_SUCCESS
)
{
aSample
-
>
mPC
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
ip
)
)
;
aSample
-
>
mSP
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
sp
)
)
;
aSample
-
>
mFP
=
reinterpret_cast
<
Address
>
(
state
.
REGISTER_FIELD
(
bp
)
)
;
Tick
(
aLock
gPS
-
>
Buffer
(
aLock
)
aSample
)
;
}
#
undef
REGISTER_FIELD
thread_resume
(
samplee_thread
)
;
}
static
void
PlatformInit
(
PS
:
:
LockRef
aLock
)
{
}
void
TickSample
:
:
PopulateContext
(
void
*
aContext
)
{
MOZ_ASSERT
(
mIsSynchronous
)
;
MOZ_ASSERT
(
!
aContext
)
;
#
if
defined
(
GP_ARCH_amd64
)
asm
(
"
leaq
0x10
(
%
%
rbp
)
%
0
\
n
\
t
"
"
movq
(
%
%
rbp
)
%
1
\
n
\
t
"
:
"
=
r
"
(
mSP
)
"
=
r
"
(
mFP
)
)
;
#
elif
defined
(
GP_ARCH_x86
)
asm
(
"
leal
0xc
(
%
%
ebp
)
%
0
\
n
\
t
"
"
movl
(
%
%
ebp
)
%
1
\
n
\
t
"
:
"
=
r
"
(
mSP
)
"
=
r
"
(
mFP
)
)
;
#
else
#
error
"
Unsupported
architecture
"
#
endif
mPC
=
reinterpret_cast
<
Address
>
(
__builtin_extract_return_addr
(
__builtin_return_address
(
0
)
)
)
;
}
