#
ifndef
ProfileBufferEntry_h
#
define
ProfileBufferEntry_h
#
include
<
ostream
>
#
include
"
GeckoProfiler
.
h
"
#
include
"
platform
.
h
"
#
include
"
ProfileJSONWriter
.
h
"
#
include
"
ProfilerBacktrace
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
<
string
>
#
include
<
map
>
#
include
"
js
/
ProfilingFrameIterator
.
h
"
#
include
"
js
/
TrackedOptimizationInfo
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
gtest
/
MozGtestFriend
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
nsTArray
.
h
"
class
ProfilerMarker
;
#
define
FOR_EACH_PROFILE_BUFFER_ENTRY_KIND
(
macro
)
\
macro
(
Category
int
)
\
macro
(
CollectionStart
double
)
\
macro
(
CollectionEnd
double
)
\
macro
(
Label
const
char
*
)
\
macro
(
DynamicStringFragment
char
*
)
/
*
char
[
kNumChars
]
really
*
/
\
macro
(
JitReturnAddr
void
*
)
\
macro
(
LineNumber
int
)
\
macro
(
NativeLeafAddr
void
*
)
\
macro
(
Marker
ProfilerMarker
*
)
\
macro
(
Pause
double
)
\
macro
(
ResidentMemory
double
)
\
macro
(
Responsiveness
double
)
\
macro
(
Resume
double
)
\
macro
(
ThreadId
int
)
\
macro
(
Time
double
)
\
macro
(
UnsharedMemory
double
)
#
if
!
defined
(
GP_ARCH_arm
)
#
pragma
pack
(
push
1
)
#
endif
class
ProfileBufferEntry
{
public
:
enum
class
Kind
:
uint8_t
{
INVALID
=
0
#
define
KIND
(
k
t
)
k
FOR_EACH_PROFILE_BUFFER_ENTRY_KIND
(
KIND
)
#
undef
KIND
LIMIT
}
;
ProfileBufferEntry
(
)
;
static
const
size_t
kNumChars
=
8
;
private
:
ProfileBufferEntry
(
Kind
aKind
const
char
*
aString
)
;
ProfileBufferEntry
(
Kind
aKind
char
aChars
[
kNumChars
]
)
;
ProfileBufferEntry
(
Kind
aKind
void
*
aPtr
)
;
ProfileBufferEntry
(
Kind
aKind
ProfilerMarker
*
aMarker
)
;
ProfileBufferEntry
(
Kind
aKind
double
aDouble
)
;
ProfileBufferEntry
(
Kind
aKind
int
aInt
)
;
public
:
#
define
CTOR
(
k
t
)
\
static
ProfileBufferEntry
k
(
t
aVal
)
{
\
return
ProfileBufferEntry
(
Kind
:
:
k
aVal
)
;
\
}
FOR_EACH_PROFILE_BUFFER_ENTRY_KIND
(
CTOR
)
#
undef
CTOR
Kind
GetKind
(
)
const
{
return
mKind
;
}
#
define
IS_KIND
(
k
t
)
bool
Is
#
#
k
(
)
const
{
return
mKind
=
=
Kind
:
:
k
;
}
FOR_EACH_PROFILE_BUFFER_ENTRY_KIND
(
IS_KIND
)
#
undef
IS_KIND
private
:
FRIEND_TEST
(
ThreadProfile
InsertOneEntry
)
;
FRIEND_TEST
(
ThreadProfile
InsertOneEntryWithTinyBuffer
)
;
FRIEND_TEST
(
ThreadProfile
InsertEntriesNoWrap
)
;
FRIEND_TEST
(
ThreadProfile
InsertEntriesWrap
)
;
FRIEND_TEST
(
ThreadProfile
MemoryMeasure
)
;
friend
class
ProfileBuffer
;
Kind
mKind
;
union
{
const
char
*
mString
;
char
mChars
[
kNumChars
]
;
void
*
mPtr
;
ProfilerMarker
*
mMarker
;
double
mDouble
;
int
mInt
;
}
u
;
}
;
#
if
!
defined
(
GP_ARCH_arm
)
static_assert
(
sizeof
(
ProfileBufferEntry
)
=
=
9
"
bad
ProfileBufferEntry
size
"
)
;
#
pragma
pack
(
pop
)
#
endif
class
UniqueJSONStrings
{
public
:
UniqueJSONStrings
(
)
;
explicit
UniqueJSONStrings
(
const
UniqueJSONStrings
&
aOther
)
;
void
SpliceStringTableElements
(
SpliceableJSONWriter
&
aWriter
)
{
aWriter
.
TakeAndSplice
(
mStringTableWriter
.
WriteFunc
(
)
)
;
}
void
WriteProperty
(
mozilla
:
:
JSONWriter
&
aWriter
const
char
*
aName
const
char
*
aStr
)
{
aWriter
.
IntProperty
(
aName
GetOrAddIndex
(
aStr
)
)
;
}
void
WriteElement
(
mozilla
:
:
JSONWriter
&
aWriter
const
char
*
aStr
)
{
aWriter
.
IntElement
(
GetOrAddIndex
(
aStr
)
)
;
}
uint32_t
GetOrAddIndex
(
const
char
*
aStr
)
;
private
:
SpliceableChunkedJSONWriter
mStringTableWriter
;
nsDataHashtable
<
nsCStringHashKey
uint32_t
>
mStringToIndexMap
;
}
;
struct
JITFrameInfoForBufferRange
final
{
JITFrameInfoForBufferRange
Clone
(
)
const
;
uint64_t
mRangeStart
;
uint64_t
mRangeEnd
;
struct
JITFrameKey
{
uint32_t
Hash
(
)
const
;
bool
operator
=
=
(
const
JITFrameKey
&
aOther
)
const
;
bool
operator
!
=
(
const
JITFrameKey
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
void
*
mCanonicalAddress
;
uint32_t
mDepth
;
}
;
nsClassHashtable
<
nsPtrHashKey
<
void
>
nsTArray
<
JITFrameKey
>
>
mJITAddressToJITFramesMap
;
nsClassHashtable
<
nsGenericHashKey
<
JITFrameKey
>
nsCString
>
mJITFrameToFrameJSONMap
;
}
;
struct
JITFrameInfo
final
{
JITFrameInfo
(
)
:
mUniqueStrings
(
mozilla
:
:
MakeUnique
<
UniqueJSONStrings
>
(
)
)
{
}
MOZ_IMPLICIT
JITFrameInfo
(
const
JITFrameInfo
&
aOther
)
;
void
AddInfoForRange
(
uint64_t
aRangeStart
uint64_t
aRangeEnd
JSContext
*
aCx
std
:
:
function
<
void
(
std
:
:
function
<
void
(
void
*
)
>
)
>
aJITAddressProvider
)
;
bool
HasExpired
(
uint64_t
aCurrentBufferRangeStart
)
const
{
if
(
mRanges
.
IsEmpty
(
)
)
{
return
true
;
}
return
mRanges
.
LastElement
(
)
.
mRangeEnd
<
=
aCurrentBufferRangeStart
;
}
nsTArray
<
JITFrameInfoForBufferRange
>
mRanges
;
mozilla
:
:
UniquePtr
<
UniqueJSONStrings
>
mUniqueStrings
;
}
;
class
UniqueStacks
{
public
:
struct
JITAddress
{
void
*
mAddress
;
uint32_t
mStreamingGen
;
uint32_t
Hash
(
)
const
;
bool
operator
=
=
(
const
JITAddress
&
aRhs
)
const
{
return
mAddress
=
=
aRhs
.
mAddress
&
&
mStreamingGen
=
=
aRhs
.
mStreamingGen
;
}
bool
operator
!
=
(
const
JITAddress
&
aRhs
)
const
{
return
!
(
*
this
=
=
aRhs
)
;
}
}
;
struct
FrameKey
{
explicit
FrameKey
(
const
char
*
aLocation
)
:
mData
(
NormalFrameData
{
nsCString
(
aLocation
)
mozilla
:
:
Nothing
(
)
mozilla
:
:
Nothing
(
)
}
)
{
}
FrameKey
(
const
char
*
aLocation
const
mozilla
:
:
Maybe
<
unsigned
>
&
aLine
const
mozilla
:
:
Maybe
<
unsigned
>
&
aCategory
)
:
mData
(
NormalFrameData
{
nsCString
(
aLocation
)
aLine
aCategory
}
)
{
}
FrameKey
(
const
JITAddress
&
aJITAddress
uint32_t
aJITDepth
)
:
mData
(
JITFrameData
{
aJITAddress
aJITDepth
}
)
{
}
FrameKey
(
const
FrameKey
&
aToCopy
)
=
default
;
uint32_t
Hash
(
)
const
;
bool
operator
=
=
(
const
FrameKey
&
aOther
)
const
{
return
mData
=
=
aOther
.
mData
;
}
struct
NormalFrameData
{
bool
operator
=
=
(
const
NormalFrameData
&
aOther
)
const
;
nsCString
mLocation
;
mozilla
:
:
Maybe
<
unsigned
>
mLine
;
mozilla
:
:
Maybe
<
unsigned
>
mCategory
;
}
;
struct
JITFrameData
{
bool
operator
=
=
(
const
JITFrameData
&
aOther
)
const
;
JITAddress
mAddress
;
uint32_t
mDepth
;
}
;
mozilla
:
:
Variant
<
NormalFrameData
JITFrameData
>
mData
;
}
;
struct
StackKey
{
mozilla
:
:
Maybe
<
uint32_t
>
mPrefixStackIndex
;
uint32_t
mFrameIndex
;
explicit
StackKey
(
uint32_t
aFrame
)
:
mFrameIndex
(
aFrame
)
mHash
(
mozilla
:
:
HashGeneric
(
aFrame
)
)
{
}
StackKey
(
const
StackKey
&
aPrefix
uint32_t
aPrefixStackIndex
uint32_t
aFrame
)
:
mPrefixStackIndex
(
mozilla
:
:
Some
(
aPrefixStackIndex
)
)
mFrameIndex
(
aFrame
)
mHash
(
mozilla
:
:
AddToHash
(
aPrefix
.
mHash
aFrame
)
)
{
}
uint32_t
Hash
(
)
const
{
return
mHash
;
}
bool
operator
=
=
(
const
StackKey
&
aOther
)
const
{
return
mPrefixStackIndex
=
=
aOther
.
mPrefixStackIndex
&
&
mFrameIndex
=
=
aOther
.
mFrameIndex
;
}
private
:
uint32_t
mHash
;
}
;
explicit
UniqueStacks
(
)
;
void
AdvanceStreamingGeneration
(
)
{
mStreamingGeneration
+
+
;
}
uint32_t
CurrentGen
(
)
{
return
mStreamingGeneration
;
}
MOZ_MUST_USE
StackKey
BeginStack
(
const
FrameKey
&
aFrame
)
;
MOZ_MUST_USE
StackKey
AppendFrame
(
const
StackKey
&
aStack
const
FrameKey
&
aFrame
)
;
MOZ_MUST_USE
nsTArray
<
FrameKey
>
GetOrAddJITFrameKeysForAddress
(
JSContext
*
aContext
const
JITAddress
&
aJITAddress
)
;
MOZ_MUST_USE
uint32_t
GetOrAddFrameIndex
(
const
FrameKey
&
aFrame
)
;
MOZ_MUST_USE
uint32_t
GetOrAddStackIndex
(
const
StackKey
&
aStack
)
;
void
SpliceFrameTableElements
(
SpliceableJSONWriter
&
aWriter
)
;
void
SpliceStackTableElements
(
SpliceableJSONWriter
&
aWriter
)
;
private
:
void
MaybeAddJITFrameIndex
(
JSContext
*
aContext
const
FrameKey
&
aFrame
const
JS
:
:
ProfiledFrameHandle
&
aJITFrame
)
;
void
StreamNonJITFrame
(
const
FrameKey
&
aFrame
)
;
void
StreamJITFrame
(
JSContext
*
aContext
const
JS
:
:
ProfiledFrameHandle
&
aJITFrame
)
;
void
StreamStack
(
const
StackKey
&
aStack
)
;
public
:
mozilla
:
:
UniquePtr
<
UniqueJSONStrings
>
mUniqueStrings
;
private
:
nsClassHashtable
<
nsGenericHashKey
<
JITAddress
>
nsTArray
<
FrameKey
>
>
mAddressToJITFrameKeysMap
;
SpliceableChunkedJSONWriter
mFrameTableWriter
;
nsDataHashtable
<
nsGenericHashKey
<
FrameKey
>
uint32_t
>
mFrameToIndexMap
;
SpliceableChunkedJSONWriter
mStackTableWriter
;
nsDataHashtable
<
nsGenericHashKey
<
StackKey
>
uint32_t
>
mStackToIndexMap
;
uint32_t
mStreamingGeneration
;
}
;
#
endif
