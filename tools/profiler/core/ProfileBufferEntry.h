#
ifndef
ProfileBufferEntry_h
#
define
ProfileBufferEntry_h
#
include
<
cstdint
>
#
include
<
cstdlib
>
#
include
<
functional
>
#
include
<
utility
>
#
include
"
gtest
/
MozGtestFriend
.
h
"
#
include
"
js
/
ProfilingCategory
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ProfileBufferEntryKinds
.
h
"
#
include
"
mozilla
/
ProfileJSONWriter
.
h
"
#
include
"
mozilla
/
ProfilerUtils
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
nsString
.
h
"
class
ProfilerCodeAddressService
;
struct
JSContext
;
class
ProfileBufferEntry
{
public
:
using
KindUnderlyingType
=
mozilla
:
:
ProfileBufferEntryKindUnderlyingType
;
using
Kind
=
mozilla
:
:
ProfileBufferEntryKind
;
ProfileBufferEntry
(
)
;
static
constexpr
size_t
kNumChars
=
mozilla
:
:
ProfileBufferEntryNumChars
;
private
:
ProfileBufferEntry
(
Kind
aKind
const
char
*
aString
)
;
ProfileBufferEntry
(
Kind
aKind
char
aChars
[
kNumChars
]
)
;
ProfileBufferEntry
(
Kind
aKind
void
*
aPtr
)
;
ProfileBufferEntry
(
Kind
aKind
double
aDouble
)
;
ProfileBufferEntry
(
Kind
aKind
int64_t
aInt64
)
;
ProfileBufferEntry
(
Kind
aKind
uint64_t
aUint64
)
;
ProfileBufferEntry
(
Kind
aKind
int
aInt
)
;
ProfileBufferEntry
(
Kind
aKind
ProfilerThreadId
aThreadId
)
;
public
:
#
define
CTOR
(
KIND
TYPE
SIZE
)
\
static
ProfileBufferEntry
KIND
(
TYPE
aVal
)
{
\
return
ProfileBufferEntry
(
Kind
:
:
KIND
aVal
)
;
\
}
FOR_EACH_PROFILE_BUFFER_ENTRY_KIND
(
CTOR
)
#
undef
CTOR
Kind
GetKind
(
)
const
{
return
mKind
;
}
#
define
IS_KIND
(
KIND
TYPE
SIZE
)
\
bool
Is
#
#
KIND
(
)
const
{
return
mKind
=
=
Kind
:
:
KIND
;
}
FOR_EACH_PROFILE_BUFFER_ENTRY_KIND
(
IS_KIND
)
#
undef
IS_KIND
private
:
FRIEND_TEST
(
ThreadProfile
InsertOneEntry
)
;
FRIEND_TEST
(
ThreadProfile
InsertOneEntryWithTinyBuffer
)
;
FRIEND_TEST
(
ThreadProfile
InsertEntriesNoWrap
)
;
FRIEND_TEST
(
ThreadProfile
InsertEntriesWrap
)
;
FRIEND_TEST
(
ThreadProfile
MemoryMeasure
)
;
friend
class
ProfileBuffer
;
Kind
mKind
;
uint8_t
mStorage
[
kNumChars
]
;
const
char
*
GetString
(
)
const
;
void
*
GetPtr
(
)
const
;
double
GetDouble
(
)
const
;
int
GetInt
(
)
const
;
int64_t
GetInt64
(
)
const
;
uint64_t
GetUint64
(
)
const
;
ProfilerThreadId
GetThreadId
(
)
const
;
void
CopyCharsInto
(
char
(
&
aOutArray
)
[
kNumChars
]
)
const
;
}
;
static_assert
(
sizeof
(
ProfileBufferEntry
)
=
=
9
"
bad
ProfileBufferEntry
size
"
)
;
struct
JITFrameInfoForBufferRange
final
{
JITFrameInfoForBufferRange
Clone
(
)
const
;
uint64_t
mRangeStart
;
uint64_t
mRangeEnd
;
struct
JITFrameKey
{
bool
operator
=
=
(
const
JITFrameKey
&
aOther
)
const
{
return
mCanonicalAddress
=
=
aOther
.
mCanonicalAddress
&
&
mDepth
=
=
aOther
.
mDepth
;
}
bool
operator
!
=
(
const
JITFrameKey
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
void
*
mCanonicalAddress
;
uint32_t
mDepth
;
}
;
struct
JITFrameKeyHasher
{
using
Lookup
=
JITFrameKey
;
static
mozilla
:
:
HashNumber
hash
(
const
JITFrameKey
&
aLookup
)
{
mozilla
:
:
HashNumber
hash
=
0
;
hash
=
mozilla
:
:
AddToHash
(
hash
aLookup
.
mCanonicalAddress
)
;
hash
=
mozilla
:
:
AddToHash
(
hash
aLookup
.
mDepth
)
;
return
hash
;
}
static
bool
match
(
const
JITFrameKey
&
aKey
const
JITFrameKey
&
aLookup
)
{
return
aKey
=
=
aLookup
;
}
static
void
rekey
(
JITFrameKey
&
aKey
const
JITFrameKey
&
aNewKey
)
{
aKey
=
aNewKey
;
}
}
;
using
JITAddressToJITFramesMap
=
mozilla
:
:
HashMap
<
void
*
mozilla
:
:
Vector
<
JITFrameKey
>
>
;
JITAddressToJITFramesMap
mJITAddressToJITFramesMap
;
using
JITFrameToFrameJSONMap
=
mozilla
:
:
HashMap
<
JITFrameKey
nsCString
JITFrameKeyHasher
>
;
JITFrameToFrameJSONMap
mJITFrameToFrameJSONMap
;
}
;
class
JITFrameInfo
final
{
public
:
JITFrameInfo
(
)
:
mUniqueStrings
(
mozilla
:
:
MakeUnique
<
UniqueJSONStrings
>
(
)
)
{
}
MOZ_IMPLICIT
JITFrameInfo
(
const
JITFrameInfo
&
aOther
mozilla
:
:
ProgressLogger
aProgressLogger
)
;
void
AddInfoForRange
(
uint64_t
aRangeStart
uint64_t
aRangeEnd
JSContext
*
aCx
const
std
:
:
function
<
void
(
const
std
:
:
function
<
void
(
void
*
)
>
&
)
>
&
aJITAddressProvider
)
;
bool
HasExpired
(
uint64_t
aCurrentBufferRangeStart
)
const
{
if
(
mRanges
.
empty
(
)
)
{
return
true
;
}
return
mRanges
.
back
(
)
.
mRangeEnd
<
=
aCurrentBufferRangeStart
;
}
mozilla
:
:
Vector
<
JITFrameInfoForBufferRange
>
&
&
MoveRanges
(
)
&
&
{
return
std
:
:
move
(
mRanges
)
;
}
mozilla
:
:
UniquePtr
<
UniqueJSONStrings
>
&
&
MoveUniqueStrings
(
)
&
&
{
return
std
:
:
move
(
mUniqueStrings
)
;
}
private
:
mozilla
:
:
Vector
<
JITFrameInfoForBufferRange
>
mRanges
;
mozilla
:
:
UniquePtr
<
UniqueJSONStrings
>
mUniqueStrings
;
}
;
class
UniqueStacks
{
public
:
struct
FrameKey
{
explicit
FrameKey
(
const
char
*
aLocation
)
:
mData
(
NormalFrameData
{
nsCString
(
aLocation
)
false
false
0
mozilla
:
:
Nothing
(
)
mozilla
:
:
Nothing
(
)
}
)
{
}
FrameKey
(
nsCString
&
&
aLocation
bool
aRelevantForJS
bool
aBaselineInterp
uint64_t
aInnerWindowID
const
mozilla
:
:
Maybe
<
unsigned
>
&
aLine
const
mozilla
:
:
Maybe
<
unsigned
>
&
aColumn
const
mozilla
:
:
Maybe
<
JS
:
:
ProfilingCategoryPair
>
&
aCategoryPair
)
:
mData
(
NormalFrameData
{
aLocation
aRelevantForJS
aBaselineInterp
aInnerWindowID
aLine
aColumn
aCategoryPair
}
)
{
}
FrameKey
(
void
*
aJITAddress
uint32_t
aJITDepth
uint32_t
aRangeIndex
)
:
mData
(
JITFrameData
{
aJITAddress
aJITDepth
aRangeIndex
}
)
{
}
FrameKey
(
const
FrameKey
&
aToCopy
)
=
default
;
uint32_t
Hash
(
)
const
;
bool
operator
=
=
(
const
FrameKey
&
aOther
)
const
{
return
mData
=
=
aOther
.
mData
;
}
struct
NormalFrameData
{
bool
operator
=
=
(
const
NormalFrameData
&
aOther
)
const
;
nsCString
mLocation
;
bool
mRelevantForJS
;
bool
mBaselineInterp
;
uint64_t
mInnerWindowID
;
mozilla
:
:
Maybe
<
unsigned
>
mLine
;
mozilla
:
:
Maybe
<
unsigned
>
mColumn
;
mozilla
:
:
Maybe
<
JS
:
:
ProfilingCategoryPair
>
mCategoryPair
;
}
;
struct
JITFrameData
{
bool
operator
=
=
(
const
JITFrameData
&
aOther
)
const
;
void
*
mCanonicalAddress
;
uint32_t
mDepth
;
uint32_t
mRangeIndex
;
}
;
mozilla
:
:
Variant
<
NormalFrameData
JITFrameData
>
mData
;
}
;
struct
FrameKeyHasher
{
using
Lookup
=
FrameKey
;
static
mozilla
:
:
HashNumber
hash
(
const
FrameKey
&
aLookup
)
{
mozilla
:
:
HashNumber
hash
=
0
;
if
(
aLookup
.
mData
.
is
<
FrameKey
:
:
NormalFrameData
>
(
)
)
{
const
FrameKey
:
:
NormalFrameData
&
data
=
aLookup
.
mData
.
as
<
FrameKey
:
:
NormalFrameData
>
(
)
;
if
(
!
data
.
mLocation
.
IsEmpty
(
)
)
{
hash
=
mozilla
:
:
AddToHash
(
hash
mozilla
:
:
HashString
(
data
.
mLocation
.
get
(
)
)
)
;
}
hash
=
mozilla
:
:
AddToHash
(
hash
data
.
mRelevantForJS
)
;
hash
=
mozilla
:
:
AddToHash
(
hash
data
.
mBaselineInterp
)
;
hash
=
mozilla
:
:
AddToHash
(
hash
data
.
mInnerWindowID
)
;
if
(
data
.
mLine
.
isSome
(
)
)
{
hash
=
mozilla
:
:
AddToHash
(
hash
*
data
.
mLine
)
;
}
if
(
data
.
mColumn
.
isSome
(
)
)
{
hash
=
mozilla
:
:
AddToHash
(
hash
*
data
.
mColumn
)
;
}
if
(
data
.
mCategoryPair
.
isSome
(
)
)
{
hash
=
mozilla
:
:
AddToHash
(
hash
static_cast
<
uint32_t
>
(
*
data
.
mCategoryPair
)
)
;
}
}
else
{
const
FrameKey
:
:
JITFrameData
&
data
=
aLookup
.
mData
.
as
<
FrameKey
:
:
JITFrameData
>
(
)
;
hash
=
mozilla
:
:
AddToHash
(
hash
data
.
mCanonicalAddress
)
;
hash
=
mozilla
:
:
AddToHash
(
hash
data
.
mDepth
)
;
hash
=
mozilla
:
:
AddToHash
(
hash
data
.
mRangeIndex
)
;
}
return
hash
;
}
static
bool
match
(
const
FrameKey
&
aKey
const
FrameKey
&
aLookup
)
{
return
aKey
=
=
aLookup
;
}
static
void
rekey
(
FrameKey
&
aKey
const
FrameKey
&
aNewKey
)
{
aKey
=
aNewKey
;
}
}
;
struct
StackKey
{
mozilla
:
:
Maybe
<
uint32_t
>
mPrefixStackIndex
;
uint32_t
mFrameIndex
;
explicit
StackKey
(
uint32_t
aFrame
)
:
mFrameIndex
(
aFrame
)
mHash
(
mozilla
:
:
HashGeneric
(
aFrame
)
)
{
}
StackKey
(
const
StackKey
&
aPrefix
uint32_t
aPrefixStackIndex
uint32_t
aFrame
)
:
mPrefixStackIndex
(
mozilla
:
:
Some
(
aPrefixStackIndex
)
)
mFrameIndex
(
aFrame
)
mHash
(
mozilla
:
:
AddToHash
(
aPrefix
.
mHash
aFrame
)
)
{
}
mozilla
:
:
HashNumber
Hash
(
)
const
{
return
mHash
;
}
bool
operator
=
=
(
const
StackKey
&
aOther
)
const
{
return
mPrefixStackIndex
=
=
aOther
.
mPrefixStackIndex
&
&
mFrameIndex
=
=
aOther
.
mFrameIndex
;
}
private
:
mozilla
:
:
HashNumber
mHash
;
}
;
struct
StackKeyHasher
{
using
Lookup
=
StackKey
;
static
mozilla
:
:
HashNumber
hash
(
const
StackKey
&
aLookup
)
{
return
aLookup
.
Hash
(
)
;
}
static
bool
match
(
const
StackKey
&
aKey
const
StackKey
&
aLookup
)
{
return
aKey
=
=
aLookup
;
}
static
void
rekey
(
StackKey
&
aKey
const
StackKey
&
aNewKey
)
{
aKey
=
aNewKey
;
}
}
;
explicit
UniqueStacks
(
JITFrameInfo
&
&
aJITFrameInfo
ProfilerCodeAddressService
*
aCodeAddressService
=
nullptr
)
;
[
[
nodiscard
]
]
StackKey
BeginStack
(
const
FrameKey
&
aFrame
)
;
[
[
nodiscard
]
]
StackKey
AppendFrame
(
const
StackKey
&
aStack
const
FrameKey
&
aFrame
)
;
[
[
nodiscard
]
]
mozilla
:
:
Maybe
<
mozilla
:
:
Vector
<
UniqueStacks
:
:
FrameKey
>
>
LookupFramesForJITAddressFromBufferPos
(
void
*
aJITAddress
uint64_t
aBufferPosition
)
;
[
[
nodiscard
]
]
uint32_t
GetOrAddFrameIndex
(
const
FrameKey
&
aFrame
)
;
[
[
nodiscard
]
]
uint32_t
GetOrAddStackIndex
(
const
StackKey
&
aStack
)
;
void
SpliceFrameTableElements
(
SpliceableJSONWriter
&
aWriter
)
;
void
SpliceStackTableElements
(
SpliceableJSONWriter
&
aWriter
)
;
[
[
nodiscard
]
]
UniqueJSONStrings
&
UniqueStrings
(
)
{
MOZ_RELEASE_ASSERT
(
mUniqueStrings
.
get
(
)
)
;
return
*
mUniqueStrings
;
}
[
[
nodiscard
]
]
nsAutoCString
FunctionNameOrAddress
(
void
*
aPC
)
;
private
:
void
StreamNonJITFrame
(
const
FrameKey
&
aFrame
)
;
void
StreamStack
(
const
StackKey
&
aStack
)
;
mozilla
:
:
UniquePtr
<
UniqueJSONStrings
>
mUniqueStrings
;
ProfilerCodeAddressService
*
mCodeAddressService
=
nullptr
;
SpliceableChunkedJSONWriter
mFrameTableWriter
;
mozilla
:
:
HashMap
<
FrameKey
uint32_t
FrameKeyHasher
>
mFrameToIndexMap
;
SpliceableChunkedJSONWriter
mStackTableWriter
;
mozilla
:
:
HashMap
<
StackKey
uint32_t
StackKeyHasher
>
mStackToIndexMap
;
mozilla
:
:
Vector
<
JITFrameInfoForBufferRange
>
mJITInfoRanges
;
}
;
#
endif
