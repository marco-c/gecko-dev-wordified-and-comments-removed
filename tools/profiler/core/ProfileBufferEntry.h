#
ifndef
ProfileBufferEntry_h
#
define
ProfileBufferEntry_h
#
include
<
ostream
>
#
include
"
GeckoProfiler
.
h
"
#
include
"
platform
.
h
"
#
include
"
ProfileJSONWriter
.
h
"
#
include
"
ProfilerBacktrace
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
<
string
>
#
include
<
map
>
#
include
"
js
/
ProfilingFrameIterator
.
h
"
#
include
"
js
/
TrackedOptimizationInfo
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
gtest
/
MozGtestFriend
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
nsTArray
.
h
"
class
ProfilerMarker
;
#
define
FOR_EACH_PROFILE_BUFFER_ENTRY_KIND
(
macro
)
\
macro
(
Category
int
)
\
macro
(
CollectionStart
double
)
\
macro
(
CollectionEnd
double
)
\
macro
(
Label
const
char
*
)
\
macro
(
DynamicStringFragment
char
*
)
/
*
char
[
kNumChars
]
really
*
/
\
macro
(
JitReturnAddr
void
*
)
\
macro
(
LineNumber
int
)
\
macro
(
ColumnNumber
int
)
\
macro
(
NativeLeafAddr
void
*
)
\
macro
(
Marker
ProfilerMarker
*
)
\
macro
(
Pause
double
)
\
macro
(
Responsiveness
double
)
\
macro
(
Resume
double
)
\
macro
(
ThreadId
int
)
\
macro
(
Time
double
)
\
macro
(
ResidentMemory
uint64_t
)
\
macro
(
UnsharedMemory
uint64_t
)
\
macro
(
CounterId
void
*
)
\
macro
(
CounterKey
uint64_t
)
\
macro
(
Number
uint64_t
)
\
macro
(
Count
int64_t
)
#
if
!
defined
(
GP_ARCH_arm
)
#
pragma
pack
(
push
1
)
#
endif
class
ProfileBufferEntry
{
public
:
enum
class
Kind
:
uint8_t
{
INVALID
=
0
#
define
KIND
(
k
t
)
k
FOR_EACH_PROFILE_BUFFER_ENTRY_KIND
(
KIND
)
#
undef
KIND
LIMIT
}
;
ProfileBufferEntry
(
)
;
static
const
size_t
kNumChars
=
8
;
private
:
ProfileBufferEntry
(
Kind
aKind
const
char
*
aString
)
;
ProfileBufferEntry
(
Kind
aKind
char
aChars
[
kNumChars
]
)
;
ProfileBufferEntry
(
Kind
aKind
void
*
aPtr
)
;
ProfileBufferEntry
(
Kind
aKind
ProfilerMarker
*
aMarker
)
;
ProfileBufferEntry
(
Kind
aKind
double
aDouble
)
;
ProfileBufferEntry
(
Kind
aKind
int64_t
aInt64
)
;
ProfileBufferEntry
(
Kind
aKind
uint64_t
aUint64
)
;
ProfileBufferEntry
(
Kind
aKind
int
aInt
)
;
public
:
#
define
CTOR
(
k
t
)
\
static
ProfileBufferEntry
k
(
t
aVal
)
{
\
return
ProfileBufferEntry
(
Kind
:
:
k
aVal
)
;
\
}
FOR_EACH_PROFILE_BUFFER_ENTRY_KIND
(
CTOR
)
#
undef
CTOR
Kind
GetKind
(
)
const
{
return
mKind
;
}
#
define
IS_KIND
(
k
t
)
bool
Is
#
#
k
(
)
const
{
return
mKind
=
=
Kind
:
:
k
;
}
FOR_EACH_PROFILE_BUFFER_ENTRY_KIND
(
IS_KIND
)
#
undef
IS_KIND
private
:
FRIEND_TEST
(
ThreadProfile
InsertOneEntry
)
;
FRIEND_TEST
(
ThreadProfile
InsertOneEntryWithTinyBuffer
)
;
FRIEND_TEST
(
ThreadProfile
InsertEntriesNoWrap
)
;
FRIEND_TEST
(
ThreadProfile
InsertEntriesWrap
)
;
FRIEND_TEST
(
ThreadProfile
MemoryMeasure
)
;
friend
class
ProfileBuffer
;
Kind
mKind
;
union
{
const
char
*
mString
;
char
mChars
[
kNumChars
]
;
void
*
mPtr
;
ProfilerMarker
*
mMarker
;
double
mDouble
;
int
mInt
;
int64_t
mInt64
;
uint64_t
mUint64
;
}
u
;
}
;
#
if
!
defined
(
GP_ARCH_arm
)
static_assert
(
sizeof
(
ProfileBufferEntry
)
=
=
9
"
bad
ProfileBufferEntry
size
"
)
;
#
pragma
pack
(
pop
)
#
endif
class
UniqueJSONStrings
{
public
:
UniqueJSONStrings
(
)
;
explicit
UniqueJSONStrings
(
const
UniqueJSONStrings
&
aOther
)
;
void
SpliceStringTableElements
(
SpliceableJSONWriter
&
aWriter
)
{
aWriter
.
TakeAndSplice
(
mStringTableWriter
.
WriteFunc
(
)
)
;
}
void
WriteProperty
(
ProfilerJSONWriter
&
aWriter
const
char
*
aName
const
char
*
aStr
)
{
aWriter
.
IntProperty
(
aName
GetOrAddIndex
(
aStr
)
)
;
}
void
WriteElement
(
ProfilerJSONWriter
&
aWriter
const
char
*
aStr
)
{
aWriter
.
IntElement
(
GetOrAddIndex
(
aStr
)
)
;
}
uint32_t
GetOrAddIndex
(
const
char
*
aStr
)
;
private
:
SpliceableChunkedJSONWriter
mStringTableWriter
;
nsDataHashtable
<
nsCStringHashKey
uint32_t
>
mStringToIndexMap
;
}
;
struct
JITFrameInfoForBufferRange
final
{
JITFrameInfoForBufferRange
Clone
(
)
const
;
uint64_t
mRangeStart
;
uint64_t
mRangeEnd
;
struct
JITFrameKey
{
uint32_t
Hash
(
)
const
;
bool
operator
=
=
(
const
JITFrameKey
&
aOther
)
const
;
bool
operator
!
=
(
const
JITFrameKey
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
void
*
mCanonicalAddress
;
uint32_t
mDepth
;
}
;
nsClassHashtable
<
nsPtrHashKey
<
void
>
nsTArray
<
JITFrameKey
>
>
mJITAddressToJITFramesMap
;
nsClassHashtable
<
nsGenericHashKey
<
JITFrameKey
>
nsCString
>
mJITFrameToFrameJSONMap
;
}
;
struct
JITFrameInfo
final
{
JITFrameInfo
(
)
:
mUniqueStrings
(
mozilla
:
:
MakeUnique
<
UniqueJSONStrings
>
(
)
)
{
}
MOZ_IMPLICIT
JITFrameInfo
(
const
JITFrameInfo
&
aOther
)
;
void
AddInfoForRange
(
uint64_t
aRangeStart
uint64_t
aRangeEnd
JSContext
*
aCx
const
std
:
:
function
<
void
(
const
std
:
:
function
<
void
(
void
*
)
>
&
)
>
&
aJITAddressProvider
)
;
bool
HasExpired
(
uint64_t
aCurrentBufferRangeStart
)
const
{
if
(
mRanges
.
IsEmpty
(
)
)
{
return
true
;
}
return
mRanges
.
LastElement
(
)
.
mRangeEnd
<
=
aCurrentBufferRangeStart
;
}
nsTArray
<
JITFrameInfoForBufferRange
>
mRanges
;
mozilla
:
:
UniquePtr
<
UniqueJSONStrings
>
mUniqueStrings
;
}
;
class
UniqueStacks
{
public
:
struct
FrameKey
{
explicit
FrameKey
(
const
char
*
aLocation
)
:
mData
(
NormalFrameData
{
nsCString
(
aLocation
)
mozilla
:
:
Nothing
(
)
mozilla
:
:
Nothing
(
)
}
)
{
}
FrameKey
(
const
char
*
aLocation
const
mozilla
:
:
Maybe
<
unsigned
>
&
aLine
const
mozilla
:
:
Maybe
<
unsigned
>
&
aColumn
const
mozilla
:
:
Maybe
<
unsigned
>
&
aCategory
)
:
mData
(
NormalFrameData
{
nsCString
(
aLocation
)
aLine
aColumn
aCategory
}
)
{
}
FrameKey
(
void
*
aJITAddress
uint32_t
aJITDepth
uint32_t
aRangeIndex
)
:
mData
(
JITFrameData
{
aJITAddress
aJITDepth
aRangeIndex
}
)
{
}
FrameKey
(
const
FrameKey
&
aToCopy
)
=
default
;
uint32_t
Hash
(
)
const
;
bool
operator
=
=
(
const
FrameKey
&
aOther
)
const
{
return
mData
=
=
aOther
.
mData
;
}
struct
NormalFrameData
{
bool
operator
=
=
(
const
NormalFrameData
&
aOther
)
const
;
nsCString
mLocation
;
mozilla
:
:
Maybe
<
unsigned
>
mLine
;
mozilla
:
:
Maybe
<
unsigned
>
mColumn
;
mozilla
:
:
Maybe
<
unsigned
>
mCategory
;
}
;
struct
JITFrameData
{
bool
operator
=
=
(
const
JITFrameData
&
aOther
)
const
;
void
*
mCanonicalAddress
;
uint32_t
mDepth
;
uint32_t
mRangeIndex
;
}
;
mozilla
:
:
Variant
<
NormalFrameData
JITFrameData
>
mData
;
}
;
struct
StackKey
{
mozilla
:
:
Maybe
<
uint32_t
>
mPrefixStackIndex
;
uint32_t
mFrameIndex
;
explicit
StackKey
(
uint32_t
aFrame
)
:
mFrameIndex
(
aFrame
)
mHash
(
mozilla
:
:
HashGeneric
(
aFrame
)
)
{
}
StackKey
(
const
StackKey
&
aPrefix
uint32_t
aPrefixStackIndex
uint32_t
aFrame
)
:
mPrefixStackIndex
(
mozilla
:
:
Some
(
aPrefixStackIndex
)
)
mFrameIndex
(
aFrame
)
mHash
(
mozilla
:
:
AddToHash
(
aPrefix
.
mHash
aFrame
)
)
{
}
uint32_t
Hash
(
)
const
{
return
mHash
;
}
bool
operator
=
=
(
const
StackKey
&
aOther
)
const
{
return
mPrefixStackIndex
=
=
aOther
.
mPrefixStackIndex
&
&
mFrameIndex
=
=
aOther
.
mFrameIndex
;
}
private
:
uint32_t
mHash
;
}
;
explicit
UniqueStacks
(
JITFrameInfo
&
&
aJITFrameInfo
)
;
MOZ_MUST_USE
StackKey
BeginStack
(
const
FrameKey
&
aFrame
)
;
MOZ_MUST_USE
StackKey
AppendFrame
(
const
StackKey
&
aStack
const
FrameKey
&
aFrame
)
;
MOZ_MUST_USE
mozilla
:
:
Maybe
<
nsTArray
<
UniqueStacks
:
:
FrameKey
>
>
LookupFramesForJITAddressFromBufferPos
(
void
*
aJITAddress
uint64_t
aBufferPosition
)
;
MOZ_MUST_USE
uint32_t
GetOrAddFrameIndex
(
const
FrameKey
&
aFrame
)
;
MOZ_MUST_USE
uint32_t
GetOrAddStackIndex
(
const
StackKey
&
aStack
)
;
void
SpliceFrameTableElements
(
SpliceableJSONWriter
&
aWriter
)
;
void
SpliceStackTableElements
(
SpliceableJSONWriter
&
aWriter
)
;
private
:
void
StreamNonJITFrame
(
const
FrameKey
&
aFrame
)
;
void
StreamStack
(
const
StackKey
&
aStack
)
;
public
:
mozilla
:
:
UniquePtr
<
UniqueJSONStrings
>
mUniqueStrings
;
private
:
SpliceableChunkedJSONWriter
mFrameTableWriter
;
nsDataHashtable
<
nsGenericHashKey
<
FrameKey
>
uint32_t
>
mFrameToIndexMap
;
SpliceableChunkedJSONWriter
mStackTableWriter
;
nsDataHashtable
<
nsGenericHashKey
<
StackKey
>
uint32_t
>
mStackToIndexMap
;
nsTArray
<
JITFrameInfoForBufferRange
>
mJITInfoRanges
;
}
;
#
endif
