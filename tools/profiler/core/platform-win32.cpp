#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
include
<
process
.
h
>
#
include
"
nsWindowsDllInterceptor
.
h
"
#
include
"
mozilla
/
StackWalk_windows
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
<
type_traits
>
static
void
PopulateRegsFromContext
(
Registers
&
aRegs
CONTEXT
*
aContext
)
{
#
if
defined
(
GP_ARCH_amd64
)
aRegs
.
mPC
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Rip
)
;
aRegs
.
mSP
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Rsp
)
;
aRegs
.
mFP
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Rbp
)
;
aRegs
.
mLR
=
0
;
#
elif
defined
(
GP_ARCH_x86
)
aRegs
.
mPC
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Eip
)
;
aRegs
.
mSP
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Esp
)
;
aRegs
.
mFP
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Ebp
)
;
aRegs
.
mLR
=
0
;
#
elif
defined
(
GP_ARCH_arm64
)
aRegs
.
mPC
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Pc
)
;
aRegs
.
mSP
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Sp
)
;
aRegs
.
mFP
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Fp
)
;
aRegs
.
mLR
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Lr
)
;
#
else
#
error
"
bad
arch
"
#
endif
}
static
HANDLE
GetRealCurrentThreadHandleForProfiling
(
)
{
HANDLE
realCurrentThreadHandle
;
if
(
!
:
:
DuplicateHandle
(
:
:
GetCurrentProcess
(
)
:
:
GetCurrentThread
(
)
:
:
GetCurrentProcess
(
)
&
realCurrentThreadHandle
THREAD_GET_CONTEXT
|
THREAD_SUSPEND_RESUME
|
THREAD_QUERY_INFORMATION
FALSE
0
)
)
{
return
nullptr
;
}
return
realCurrentThreadHandle
;
}
static_assert
(
std
:
:
is_same_v
<
mozilla
:
:
profiler
:
:
PlatformData
:
:
WindowsHandle
HANDLE
>
)
;
mozilla
:
:
profiler
:
:
PlatformData
:
:
PlatformData
(
ProfilerThreadId
aThreadId
)
:
mProfiledThread
(
GetRealCurrentThreadHandleForProfiling
(
)
)
{
MOZ_ASSERT
(
aThreadId
=
=
ProfilerThreadId
:
:
FromNumber
(
:
:
GetCurrentThreadId
(
)
)
)
;
}
mozilla
:
:
profiler
:
:
PlatformData
:
:
~
PlatformData
(
)
{
if
(
mProfiledThread
)
{
CloseHandle
(
mProfiledThread
)
;
mProfiledThread
=
nullptr
;
}
}
static
const
HANDLE
kNoThread
=
INVALID_HANDLE_VALUE
;
Sampler
:
:
Sampler
(
PSLockRef
aLock
)
{
}
void
Sampler
:
:
Disable
(
PSLockRef
aLock
)
{
}
static
void
StreamMetaPlatformSampleUnits
(
PSLockRef
aLock
SpliceableJSONWriter
&
aWriter
)
{
static
const
Span
<
const
char
>
units
=
(
GetCycleTimeFrequencyMHz
(
)
!
=
0
)
?
MakeStringSpan
(
"
ns
"
)
:
MakeStringSpan
(
"
variable
CPU
cycles
"
)
;
aWriter
.
StringProperty
(
"
threadCPUDelta
"
units
)
;
}
uint64_t
RunningTimes
:
:
ConvertRawToJson
(
uint64_t
aRawValue
)
{
static
const
uint64_t
cycleTimeFrequencyMHz
=
GetCycleTimeFrequencyMHz
(
)
;
if
(
cycleTimeFrequencyMHz
=
=
0u
)
{
return
aRawValue
;
}
constexpr
uint64_t
GHZ_PER_MHZ
=
1
'
000u
;
return
(
aRawValue
*
GHZ_PER_MHZ
+
(
GHZ_PER_MHZ
/
2u
)
)
/
cycleTimeFrequencyMHz
;
}
static
inline
uint64_t
ToNanoSeconds
(
const
FILETIME
&
aFileTime
)
{
ULARGE_INTEGER
usec
=
{
{
aFileTime
.
dwLowDateTime
aFileTime
.
dwHighDateTime
}
}
;
return
usec
.
QuadPart
*
100
;
}
namespace
mozilla
:
:
profiler
{
bool
GetCpuTimeSinceThreadStartInNs
(
uint64_t
*
aResult
const
mozilla
:
:
profiler
:
:
PlatformData
&
aPlatformData
)
{
const
HANDLE
profiledThread
=
aPlatformData
.
ProfiledThread
(
)
;
int
frequencyInMHz
=
GetCycleTimeFrequencyMHz
(
)
;
if
(
frequencyInMHz
)
{
uint64_t
cpuCycleCount
;
if
(
!
QueryThreadCycleTime
(
profiledThread
&
cpuCycleCount
)
)
{
return
false
;
}
constexpr
uint64_t
USEC_PER_NSEC
=
1000L
;
*
aResult
=
cpuCycleCount
*
USEC_PER_NSEC
/
frequencyInMHz
;
return
true
;
}
FILETIME
createTime
exitTime
kernelTime
userTime
;
if
(
!
GetThreadTimes
(
profiledThread
&
createTime
&
exitTime
&
kernelTime
&
userTime
)
)
{
return
false
;
}
*
aResult
=
ToNanoSeconds
(
kernelTime
)
+
ToNanoSeconds
(
userTime
)
;
return
true
;
}
}
static
RunningTimes
GetProcessRunningTimesDiff
(
PSLockRef
aLock
RunningTimes
&
aPreviousRunningTimesToBeUpdated
)
{
AUTO_PROFILER_STATS
(
GetProcessRunningTimes
)
;
static
const
HANDLE
processHandle
=
GetCurrentProcess
(
)
;
RunningTimes
newRunningTimes
;
{
AUTO_PROFILER_STATS
(
GetProcessRunningTimes_QueryProcessCycleTime
)
;
if
(
ULONG64
cycles
;
QueryProcessCycleTime
(
processHandle
&
cycles
)
!
=
0
)
{
newRunningTimes
.
SetThreadCPUDelta
(
cycles
)
;
}
newRunningTimes
.
SetPostMeasurementTimeStamp
(
TimeStamp
:
:
Now
(
)
)
;
}
;
const
RunningTimes
diff
=
newRunningTimes
-
aPreviousRunningTimesToBeUpdated
;
aPreviousRunningTimesToBeUpdated
=
newRunningTimes
;
return
diff
;
}
static
RunningTimes
GetThreadRunningTimesDiff
(
PSLockRef
aLock
ThreadRegistration
:
:
UnlockedRWForLockedProfiler
&
aThreadData
)
{
AUTO_PROFILER_STATS
(
GetThreadRunningTimes
)
;
const
mozilla
:
:
profiler
:
:
PlatformData
&
platformData
=
aThreadData
.
PlatformDataCRef
(
)
;
const
HANDLE
profiledThread
=
platformData
.
ProfiledThread
(
)
;
const
RunningTimes
newRunningTimes
=
GetRunningTimesWithTightTimestamp
(
[
profiledThread
]
(
RunningTimes
&
aRunningTimes
)
{
AUTO_PROFILER_STATS
(
GetThreadRunningTimes_QueryThreadCycleTime
)
;
if
(
ULONG64
cycles
;
QueryThreadCycleTime
(
profiledThread
&
cycles
)
!
=
0
)
{
aRunningTimes
.
ResetThreadCPUDelta
(
cycles
)
;
}
else
{
aRunningTimes
.
ClearThreadCPUDelta
(
)
;
}
}
)
;
ProfiledThreadData
*
profiledThreadData
=
aThreadData
.
GetProfiledThreadData
(
aLock
)
;
MOZ_ASSERT
(
profiledThreadData
)
;
RunningTimes
&
previousRunningTimes
=
profiledThreadData
-
>
PreviousThreadRunningTimesRef
(
)
;
const
RunningTimes
diff
=
newRunningTimes
-
previousRunningTimes
;
previousRunningTimes
=
newRunningTimes
;
return
diff
;
}
static
void
DiscardSuspendedThreadRunningTimes
(
PSLockRef
aLock
ThreadRegistration
:
:
UnlockedRWForLockedProfiler
&
aThreadData
)
{
AUTO_PROFILER_STATS
(
DiscardSuspendedThreadRunningTimes
)
;
const
mozilla
:
:
profiler
:
:
PlatformData
&
platformData
=
aThreadData
.
PlatformDataCRef
(
)
;
const
HANDLE
profiledThread
=
platformData
.
ProfiledThread
(
)
;
ProfiledThreadData
*
profiledThreadData
=
aThreadData
.
GetProfiledThreadData
(
aLock
)
;
MOZ_ASSERT
(
profiledThreadData
)
;
RunningTimes
&
previousRunningTimes
=
profiledThreadData
-
>
PreviousThreadRunningTimesRef
(
)
;
if
(
ULONG64
cycles
;
QueryThreadCycleTime
(
profiledThread
&
cycles
)
!
=
0
)
{
previousRunningTimes
.
ResetThreadCPUDelta
(
cycles
)
;
}
else
{
previousRunningTimes
.
ClearThreadCPUDelta
(
)
;
}
}
template
<
typename
Func
>
void
Sampler
:
:
SuspendAndSampleAndResumeThread
(
PSLockRef
aLock
const
ThreadRegistration
:
:
UnlockedReaderAndAtomicRWOnThread
&
aThreadData
const
TimeStamp
&
aNow
const
Func
&
aProcessRegs
)
{
HANDLE
profiled_thread
=
aThreadData
.
PlatformDataCRef
(
)
.
ProfiledThread
(
)
;
if
(
profiled_thread
=
=
nullptr
)
{
return
;
}
CONTEXT
context
;
memset
(
&
context
0
sizeof
(
context
)
)
;
static
const
DWORD
kSuspendFailed
=
static_cast
<
DWORD
>
(
-
1
)
;
if
(
SuspendThread
(
profiled_thread
)
=
=
kSuspendFailed
)
{
return
;
}
#
if
defined
(
GP_ARCH_amd64
)
context
.
ContextFlags
=
CONTEXT_FULL
;
#
else
context
.
ContextFlags
=
CONTEXT_CONTROL
;
#
endif
if
(
!
GetThreadContext
(
profiled_thread
&
context
)
)
{
ResumeThread
(
profiled_thread
)
;
return
;
}
Registers
regs
;
PopulateRegsFromContext
(
regs
&
context
)
;
aProcessRegs
(
regs
aNow
)
;
ResumeThread
(
profiled_thread
)
;
}
static
unsigned
int
__stdcall
ThreadEntry
(
void
*
aArg
)
{
auto
thread
=
static_cast
<
SamplerThread
*
>
(
aArg
)
;
thread
-
>
Run
(
)
;
return
0
;
}
static
unsigned
int
__stdcall
UnregisteredThreadSpyEntry
(
void
*
aArg
)
{
auto
thread
=
static_cast
<
SamplerThread
*
>
(
aArg
)
;
thread
-
>
RunUnregisteredThreadSpy
(
)
;
return
0
;
}
SamplerThread
:
:
SamplerThread
(
PSLockRef
aLock
uint32_t
aActivityGeneration
double
aIntervalMilliseconds
uint32_t
aFeatures
)
:
mSampler
(
aLock
)
mActivityGeneration
(
aActivityGeneration
)
mIntervalMicroseconds
(
std
:
:
max
(
1
int
(
floor
(
aIntervalMilliseconds
*
1000
+
0
.
5
)
)
)
)
mNoTimerResolutionChange
(
ProfilerFeature
:
:
HasNoTimerResolutionChange
(
aFeatures
)
)
{
if
(
(
!
mNoTimerResolutionChange
)
&
&
(
mIntervalMicroseconds
<
10
*
1000
)
)
{
:
:
timeBeginPeriod
(
mIntervalMicroseconds
/
1000
)
;
}
if
(
ProfilerFeature
:
:
HasUnregisteredThreads
(
aFeatures
)
)
{
mSpyingState
=
SpyingState
:
:
Spy_Initializing
;
mUnregisteredThreadSpyThread
=
reinterpret_cast
<
HANDLE
>
(
_beginthreadex
(
nullptr
0
UnregisteredThreadSpyEntry
this
0
nullptr
)
)
;
if
(
mUnregisteredThreadSpyThread
=
=
0
)
{
MOZ_CRASH
(
"
_beginthreadex
failed
"
)
;
}
}
mThread
=
reinterpret_cast
<
HANDLE
>
(
_beginthreadex
(
nullptr
0
ThreadEntry
this
0
nullptr
)
)
;
if
(
mThread
=
=
0
)
{
MOZ_CRASH
(
"
_beginthreadex
failed
"
)
;
}
}
SamplerThread
:
:
~
SamplerThread
(
)
{
if
(
mUnregisteredThreadSpyThread
)
{
{
MonitorAutoLock
spyingStateLock
{
mSpyingStateMonitor
}
;
while
(
mSpyingState
!
=
SpyingState
:
:
Spy_Waiting
&
&
mSpyingState
!
=
SpyingState
:
:
SamplerToSpy_Start
)
{
spyingStateLock
.
Wait
(
)
;
}
mSpyingState
=
SpyingState
:
:
MainToSpy_Shutdown
;
spyingStateLock
.
NotifyAll
(
)
;
do
{
spyingStateLock
.
Wait
(
)
;
}
while
(
mSpyingState
!
=
SpyingState
:
:
SpyToMain_ShuttingDown
)
;
}
WaitForSingleObject
(
mUnregisteredThreadSpyThread
INFINITE
)
;
if
(
mUnregisteredThreadSpyThread
!
=
kNoThread
)
{
CloseHandle
(
mUnregisteredThreadSpyThread
)
;
}
}
WaitForSingleObject
(
mThread
INFINITE
)
;
if
(
mThread
!
=
kNoThread
)
{
CloseHandle
(
mThread
)
;
}
InvokePostSamplingCallbacks
(
std
:
:
move
(
mPostSamplingCallbackList
)
SamplingState
:
:
JustStopped
)
;
}
void
SamplerThread
:
:
RunUnregisteredThreadSpy
(
)
{
PR_SetCurrentThreadName
(
"
UnregisteredThreadSpy
"
)
;
while
(
true
)
{
{
MonitorAutoLock
spyingStateLock
{
mSpyingStateMonitor
}
;
MOZ_ASSERT
(
mSpyingState
=
=
SpyingState
:
:
Spy_Initializing
|
|
mSpyingState
=
=
SpyingState
:
:
Spy_Working
)
;
mSpyingState
=
SpyingState
:
:
Spy_Waiting
;
mSpyingStateMonitor
.
NotifyAll
(
)
;
do
{
spyingStateLock
.
Wait
(
)
;
}
while
(
mSpyingState
=
=
SpyingState
:
:
Spy_Waiting
)
;
if
(
mSpyingState
=
=
SpyingState
:
:
MainToSpy_Shutdown
)
{
mSpyingState
=
SpyingState
:
:
SpyToMain_ShuttingDown
;
mSpyingStateMonitor
.
NotifyAll
(
)
;
break
;
}
MOZ_ASSERT
(
mSpyingState
=
=
SpyingState
:
:
SamplerToSpy_Start
)
;
mSpyingState
=
SpyingState
:
:
Spy_Working
;
}
SpyOnUnregisteredThreads
(
)
;
}
}
void
SamplerThread
:
:
SleepMicro
(
uint32_t
aMicroseconds
)
{
if
(
mIntervalMicroseconds
>
=
1000
)
{
:
:
Sleep
(
std
:
:
max
(
1u
aMicroseconds
/
1000
)
)
;
}
else
{
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
TimeStamp
end
=
start
+
TimeDuration
:
:
FromMicroseconds
(
aMicroseconds
)
;
if
(
aMicroseconds
>
=
1000
)
{
:
:
Sleep
(
aMicroseconds
/
1000
)
;
}
while
(
TimeStamp
:
:
Now
(
)
<
end
)
{
YieldProcessor
(
)
;
}
}
}
void
SamplerThread
:
:
Stop
(
PSLockRef
aLock
)
{
if
(
(
!
mNoTimerResolutionChange
)
&
&
(
mIntervalMicroseconds
<
10
*
1000
)
)
{
:
:
timeEndPeriod
(
mIntervalMicroseconds
/
1000
)
;
}
mSampler
.
Disable
(
aLock
)
;
}
static
void
PlatformInit
(
PSLockRef
aLock
)
{
}
#
if
defined
(
HAVE_NATIVE_UNWIND
)
void
Registers
:
:
SyncPopulate
(
)
{
CONTEXT
context
;
RtlCaptureContext
(
&
context
)
;
PopulateRegsFromContext
(
*
this
&
context
)
;
}
#
endif
#
if
defined
(
GP_PLAT_amd64_windows
)
namespace
mozilla
{
namespace
baseprofiler
{
MFBT_API
void
InitializeWin64ProfilerHooks
(
)
;
}
}
using
mozilla
:
:
baseprofiler
:
:
InitializeWin64ProfilerHooks
;
#
endif
