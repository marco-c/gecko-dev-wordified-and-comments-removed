#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
include
<
process
.
h
>
Thread
:
:
tid_t
Thread
:
:
GetCurrentId
(
)
{
return
GetCurrentThreadId
(
)
;
}
static
void
SleepMicro
(
int
aMicroseconds
)
{
aMicroseconds
=
std
:
:
max
(
0
aMicroseconds
)
;
int
aMilliseconds
=
std
:
:
max
(
1
aMicroseconds
/
1000
)
;
:
:
Sleep
(
aMilliseconds
)
;
}
class
PlatformData
{
public
:
explicit
PlatformData
(
int
aThreadId
)
:
profiled_thread_
(
OpenThread
(
THREAD_GET_CONTEXT
|
THREAD_SUSPEND_RESUME
|
THREAD_QUERY_INFORMATION
false
aThreadId
)
)
{
MOZ_COUNT_CTOR
(
PlatformData
)
;
}
~
PlatformData
(
)
{
if
(
profiled_thread_
!
=
nullptr
)
{
CloseHandle
(
profiled_thread_
)
;
profiled_thread_
=
nullptr
;
}
MOZ_COUNT_DTOR
(
PlatformData
)
;
}
HANDLE
profiled_thread
(
)
{
return
profiled_thread_
;
}
private
:
HANDLE
profiled_thread_
;
}
;
uintptr_t
GetThreadHandle
(
PlatformData
*
aData
)
{
return
(
uintptr_t
)
aData
-
>
profiled_thread
(
)
;
}
static
const
HANDLE
kNoThread
=
INVALID_HANDLE_VALUE
;
static
unsigned
int
__stdcall
ThreadEntry
(
void
*
aArg
)
{
auto
thread
=
static_cast
<
SamplerThread
*
>
(
aArg
)
;
thread
-
>
Run
(
)
;
return
0
;
}
SamplerThread
:
:
SamplerThread
(
PS
:
:
LockRef
aLock
uint32_t
aActivityGeneration
double
aIntervalMilliseconds
)
:
mActivityGeneration
(
aActivityGeneration
)
mIntervalMicroseconds
(
std
:
:
max
(
1
int
(
floor
(
aIntervalMilliseconds
*
1000
+
0
.
5
)
)
)
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mIntervalMicroseconds
<
10
*
1000
)
{
:
:
timeBeginPeriod
(
mIntervalMicroseconds
/
1000
)
;
}
mThread
=
reinterpret_cast
<
HANDLE
>
(
_beginthreadex
(
nullptr
0
ThreadEntry
this
0
nullptr
)
)
;
if
(
mThread
=
=
0
)
{
MOZ_CRASH
(
"
_beginthreadex
failed
"
)
;
}
}
SamplerThread
:
:
~
SamplerThread
(
)
{
WaitForSingleObject
(
mThread
INFINITE
)
;
if
(
mThread
!
=
kNoThread
)
{
CloseHandle
(
mThread
)
;
}
}
void
SamplerThread
:
:
Stop
(
PS
:
:
LockRef
aLock
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mIntervalMicroseconds
<
10
*
1000
)
{
:
:
timeEndPeriod
(
mIntervalMicroseconds
/
1000
)
;
}
}
void
SamplerThread
:
:
SuspendAndSampleAndResumeThread
(
PS
:
:
LockRef
aLock
TickSample
*
aSample
)
{
uintptr_t
thread
=
GetThreadHandle
(
aSample
-
>
mThreadInfo
-
>
GetPlatformData
(
)
)
;
HANDLE
profiled_thread
=
reinterpret_cast
<
HANDLE
>
(
thread
)
;
if
(
profiled_thread
=
=
nullptr
)
return
;
CONTEXT
context
;
memset
(
&
context
0
sizeof
(
context
)
)
;
static
const
DWORD
kSuspendFailed
=
static_cast
<
DWORD
>
(
-
1
)
;
if
(
SuspendThread
(
profiled_thread
)
=
=
kSuspendFailed
)
{
return
;
}
#
if
defined
(
GP_ARCH_amd64
)
context
.
ContextFlags
=
CONTEXT_FULL
;
#
else
context
.
ContextFlags
=
CONTEXT_CONTROL
;
#
endif
if
(
!
GetThreadContext
(
profiled_thread
&
context
)
)
{
ResumeThread
(
profiled_thread
)
;
return
;
}
#
if
defined
(
GP_ARCH_amd64
)
aSample
-
>
mPC
=
reinterpret_cast
<
Address
>
(
context
.
Rip
)
;
aSample
-
>
mSP
=
reinterpret_cast
<
Address
>
(
context
.
Rsp
)
;
aSample
-
>
mFP
=
reinterpret_cast
<
Address
>
(
context
.
Rbp
)
;
#
else
aSample
-
>
mPC
=
reinterpret_cast
<
Address
>
(
context
.
Eip
)
;
aSample
-
>
mSP
=
reinterpret_cast
<
Address
>
(
context
.
Esp
)
;
aSample
-
>
mFP
=
reinterpret_cast
<
Address
>
(
context
.
Ebp
)
;
#
endif
aSample
-
>
mContext
=
&
context
;
Tick
(
aLock
gPS
-
>
Buffer
(
aLock
)
aSample
)
;
ResumeThread
(
profiled_thread
)
;
}
static
void
PlatformInit
(
PS
:
:
LockRef
aLock
)
{
}
void
TickSample
:
:
PopulateContext
(
CONTEXT
*
aContext
)
{
MOZ_ASSERT
(
aContext
)
;
mContext
=
aContext
;
RtlCaptureContext
(
aContext
)
;
#
if
defined
(
GP_ARCH_amd64
)
mPC
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Rip
)
;
mSP
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Rsp
)
;
mFP
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Rbp
)
;
#
elif
defined
(
GP_ARCH_x86
)
mPC
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Eip
)
;
mSP
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Esp
)
;
mFP
=
reinterpret_cast
<
Address
>
(
aContext
-
>
Ebp
)
;
#
endif
}
