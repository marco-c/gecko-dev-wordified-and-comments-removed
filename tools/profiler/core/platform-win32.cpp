#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
include
<
process
.
h
>
#
include
"
nsMemoryReporterManager
.
h
"
class
PlatformData
{
public
:
explicit
PlatformData
(
int
aThreadId
)
:
profiled_thread_
(
OpenThread
(
THREAD_GET_CONTEXT
|
THREAD_SUSPEND_RESUME
|
THREAD_QUERY_INFORMATION
false
aThreadId
)
)
{
}
~
PlatformData
(
)
{
if
(
profiled_thread_
!
=
nullptr
)
{
CloseHandle
(
profiled_thread_
)
;
profiled_thread_
=
nullptr
;
}
}
HANDLE
profiled_thread
(
)
{
return
profiled_thread_
;
}
private
:
HANDLE
profiled_thread_
;
}
;
UniquePlatformData
AllocPlatformData
(
int
aThreadId
)
{
return
UniquePlatformData
(
new
PlatformData
(
aThreadId
)
)
;
}
void
PlatformDataDestructor
:
:
operator
(
)
(
PlatformData
*
aData
)
{
delete
aData
;
}
uintptr_t
GetThreadHandle
(
PlatformData
*
aData
)
{
return
(
uintptr_t
)
aData
-
>
profiled_thread
(
)
;
}
static
const
HANDLE
kNoThread
=
INVALID_HANDLE_VALUE
;
class
SamplerThread
{
private
:
static
unsigned
int
__stdcall
ThreadEntry
(
void
*
aArg
)
{
auto
thread
=
static_cast
<
SamplerThread
*
>
(
aArg
)
;
thread
-
>
Run
(
)
;
return
0
;
}
public
:
explicit
SamplerThread
(
double
aInterval
)
:
mInterval
(
std
:
:
max
(
1
int
(
floor
(
aInterval
+
0
.
5
)
)
)
)
{
mThread
=
reinterpret_cast
<
HANDLE
>
(
_beginthreadex
(
nullptr
0
ThreadEntry
this
0
(
unsigned
int
*
)
&
mThreadId
)
)
;
if
(
mThread
=
=
0
)
{
MOZ_CRASH
(
"
_beginthreadex
failed
"
)
;
}
}
~
SamplerThread
(
)
{
if
(
mThread
!
=
kNoThread
)
{
CloseHandle
(
mThread
)
;
}
}
void
Join
(
)
{
if
(
mThreadId
!
=
Thread
:
:
GetCurrentId
(
)
)
{
WaitForSingleObject
(
mThread
INFINITE
)
;
}
}
static
void
StartSampler
(
double
aInterval
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
sInstance
)
;
sInstance
=
new
SamplerThread
(
aInterval
)
;
}
static
void
StopSampler
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
sInstance
-
>
Join
(
)
;
delete
sInstance
;
sInstance
=
nullptr
;
}
void
Run
(
)
{
if
(
mInterval
<
10
)
:
:
timeBeginPeriod
(
mInterval
)
;
while
(
gIsActive
)
{
gBuffer
-
>
deleteExpiredStoredMarkers
(
)
;
if
(
!
gIsPaused
)
{
mozilla
:
:
StaticMutexAutoLock
lock
(
gRegisteredThreadsMutex
)
;
bool
isFirstProfiledThread
=
true
;
for
(
uint32_t
i
=
0
;
i
<
gRegisteredThreads
-
>
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
(
*
gRegisteredThreads
)
[
i
]
;
if
(
!
info
-
>
HasProfile
(
)
|
|
info
-
>
IsPendingDelete
(
)
)
{
continue
;
}
if
(
info
-
>
Stack
(
)
-
>
CanDuplicateLastSampleDueToSleep
(
)
&
&
gBuffer
-
>
DuplicateLastSample
(
info
-
>
ThreadId
(
)
gStartTime
)
)
{
continue
;
}
info
-
>
UpdateThreadResponsiveness
(
)
;
SampleContext
(
info
isFirstProfiledThread
)
;
isFirstProfiledThread
=
false
;
}
}
:
:
Sleep
(
mInterval
)
;
}
if
(
mInterval
<
10
)
:
:
timeEndPeriod
(
mInterval
)
;
}
void
SampleContext
(
ThreadInfo
*
aThreadInfo
bool
isFirstProfiledThread
)
{
uintptr_t
thread
=
GetThreadHandle
(
aThreadInfo
-
>
GetPlatformData
(
)
)
;
HANDLE
profiled_thread
=
reinterpret_cast
<
HANDLE
>
(
thread
)
;
if
(
profiled_thread
=
=
nullptr
)
return
;
CONTEXT
context
;
memset
(
&
context
0
sizeof
(
context
)
)
;
TickSample
sample
;
sample
.
timestamp
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
sample
.
threadInfo
=
aThreadInfo
;
if
(
isFirstProfiledThread
&
&
gProfileMemory
)
{
sample
.
rssMemory
=
nsMemoryReporterManager
:
:
ResidentFast
(
)
;
}
else
{
sample
.
rssMemory
=
0
;
}
sample
.
ussMemory
=
0
;
static
const
DWORD
kSuspendFailed
=
static_cast
<
DWORD
>
(
-
1
)
;
if
(
SuspendThread
(
profiled_thread
)
=
=
kSuspendFailed
)
return
;
#
if
defined
(
GP_ARCH_amd64
)
context
.
ContextFlags
=
CONTEXT_FULL
;
#
else
context
.
ContextFlags
=
CONTEXT_CONTROL
;
#
endif
if
(
!
GetThreadContext
(
profiled_thread
&
context
)
)
{
ResumeThread
(
profiled_thread
)
;
return
;
}
#
if
defined
(
GP_ARCH_amd64
)
sample
.
pc
=
reinterpret_cast
<
Address
>
(
context
.
Rip
)
;
sample
.
sp
=
reinterpret_cast
<
Address
>
(
context
.
Rsp
)
;
sample
.
fp
=
reinterpret_cast
<
Address
>
(
context
.
Rbp
)
;
#
else
sample
.
pc
=
reinterpret_cast
<
Address
>
(
context
.
Eip
)
;
sample
.
sp
=
reinterpret_cast
<
Address
>
(
context
.
Esp
)
;
sample
.
fp
=
reinterpret_cast
<
Address
>
(
context
.
Ebp
)
;
#
endif
sample
.
context
=
&
context
;
Tick
(
gBuffer
&
sample
)
;
ResumeThread
(
profiled_thread
)
;
}
private
:
HANDLE
mThread
;
Thread
:
:
tid_t
mThreadId
;
const
int
mInterval
;
static
SamplerThread
*
sInstance
;
SamplerThread
(
const
SamplerThread
&
)
=
delete
;
void
operator
=
(
const
SamplerThread
&
)
=
delete
;
}
;
SamplerThread
*
SamplerThread
:
:
sInstance
=
nullptr
;
static
void
PlatformInit
(
)
{
}
static
void
PlatformStart
(
double
aInterval
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
SamplerThread
:
:
StartSampler
(
aInterval
)
;
}
static
void
PlatformStop
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
SamplerThread
:
:
StopSampler
(
)
;
}
Thread
:
:
tid_t
Thread
:
:
GetCurrentId
(
)
{
return
GetCurrentThreadId
(
)
;
}
void
TickSample
:
:
PopulateContext
(
void
*
aContext
)
{
MOZ_ASSERT
(
aContext
)
;
CONTEXT
*
pContext
=
reinterpret_cast
<
CONTEXT
*
>
(
aContext
)
;
context
=
pContext
;
RtlCaptureContext
(
pContext
)
;
#
if
defined
(
GP_ARCH_amd64
)
pc
=
reinterpret_cast
<
Address
>
(
pContext
-
>
Rip
)
;
sp
=
reinterpret_cast
<
Address
>
(
pContext
-
>
Rsp
)
;
fp
=
reinterpret_cast
<
Address
>
(
pContext
-
>
Rbp
)
;
#
elif
defined
(
GP_ARCH_x86
)
pc
=
reinterpret_cast
<
Address
>
(
pContext
-
>
Eip
)
;
sp
=
reinterpret_cast
<
Address
>
(
pContext
-
>
Esp
)
;
fp
=
reinterpret_cast
<
Address
>
(
pContext
-
>
Ebp
)
;
#
endif
}
