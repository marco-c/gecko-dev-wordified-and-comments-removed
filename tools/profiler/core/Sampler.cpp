#
include
<
algorithm
>
#
include
<
string
>
#
include
<
stdio
.
h
>
#
include
<
fstream
>
#
include
<
sstream
>
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
prenv
.
h
"
#
include
"
prtime
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
ProfileEntry
.
h
"
#
include
"
SyncProfile
.
h
"
#
include
"
platform
.
h
"
#
include
"
shared
-
libraries
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
include
"
ProfileJSONWriter
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsXPCOMCID
.
h
"
#
include
"
nsIHttpProtocolHandler
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
PlatformMacros
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
if
defined
(
SPS_OS_android
)
&
&
!
defined
(
MOZ_WIDGET_GONK
)
#
include
"
FennecJNIWrappers
.
h
"
#
endif
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
#
endif
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
ProfilingFrameIterator
.
h
"
using
std
:
:
string
;
using
namespace
mozilla
;
#
ifndef
MAXPATHLEN
#
ifdef
PATH_MAX
#
define
MAXPATHLEN
PATH_MAX
#
elif
defined
(
MAX_PATH
)
#
define
MAXPATHLEN
MAX_PATH
#
elif
defined
(
_MAX_PATH
)
#
define
MAXPATHLEN
_MAX_PATH
#
elif
defined
(
CCHMAXPATH
)
#
define
MAXPATHLEN
CCHMAXPATH
#
else
#
define
MAXPATHLEN
1024
#
endif
#
endif
Sampler
:
:
Sampler
(
)
{
MOZ_COUNT_CTOR
(
Sampler
)
;
bool
ignore
;
sStartTime
=
mozilla
:
:
TimeStamp
:
:
ProcessCreation
(
ignore
)
;
{
StaticMutexAutoLock
lock
(
sRegisteredThreadsMutex
)
;
for
(
uint32_t
i
=
0
;
i
<
sRegisteredThreads
-
>
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
sRegisteredThreads
-
>
at
(
i
)
;
MaybeSetProfile
(
info
)
;
}
}
#
ifdef
MOZ_TASK_TRACER
if
(
mTaskTracer
)
{
mozilla
:
:
tasktracer
:
:
StartLogging
(
)
;
}
#
endif
}
Sampler
:
:
~
Sampler
(
)
{
MOZ_COUNT_DTOR
(
Sampler
)
;
if
(
gIsActive
)
PlatformStop
(
)
;
{
StaticMutexAutoLock
lock
(
sRegisteredThreadsMutex
)
;
for
(
uint32_t
i
=
0
;
i
<
sRegisteredThreads
-
>
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
sRegisteredThreads
-
>
at
(
i
)
;
if
(
info
-
>
IsPendingDelete
(
)
)
{
MOZ_ASSERT
(
!
info
-
>
Stack
(
)
)
;
delete
info
;
sRegisteredThreads
-
>
erase
(
sRegisteredThreads
-
>
begin
(
)
+
i
)
;
i
-
-
;
}
}
}
#
ifdef
MOZ_TASK_TRACER
if
(
mTaskTracer
)
{
mozilla
:
:
tasktracer
:
:
StopLogging
(
)
;
}
#
endif
}
void
PseudoStack
:
:
flushSamplerOnJSShutdown
(
)
{
MOZ_ASSERT
(
mContext
)
;
if
(
!
gIsActive
)
{
return
;
}
gIsPaused
=
true
;
{
StaticMutexAutoLock
lock
(
sRegisteredThreadsMutex
)
;
for
(
size_t
i
=
0
;
i
<
sRegisteredThreads
-
>
size
(
)
;
i
+
+
)
{
ThreadInfo
*
info
=
sRegisteredThreads
-
>
at
(
i
)
;
if
(
!
info
-
>
hasProfile
(
)
|
|
info
-
>
IsPendingDelete
(
)
)
{
continue
;
}
if
(
info
-
>
Stack
(
)
-
>
mContext
!
=
mContext
)
{
continue
;
}
MutexAutoLock
lock
(
info
-
>
GetMutex
(
)
)
;
info
-
>
FlushSamplesAndMarkers
(
)
;
}
}
gIsPaused
=
false
;
}
