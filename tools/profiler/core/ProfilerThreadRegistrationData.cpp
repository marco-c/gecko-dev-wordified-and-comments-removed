#
include
"
mozilla
/
ProfilerThreadRegistrationData
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
FlowMarkers
.
h
"
#
include
"
mozilla
/
FOGIPC
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
js
/
AllocationRecording
.
h
"
#
include
"
js
/
ProfilingStack
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
windows
.
h
>
#
elif
defined
(
XP_DARWIN
)
#
include
<
pthread
.
h
>
#
endif
#
ifdef
NIGHTLY_BUILD
namespace
geckoprofiler
:
:
markers
{
using
namespace
mozilla
;
struct
ThreadCpuUseMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
ThreadCpuUse
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
ProfilerThreadId
aThreadId
int64_t
aCpuTimeMs
int64_t
aWakeUps
const
ProfilerString8View
&
aThreadName
)
{
aWriter
.
IntProperty
(
"
threadId
"
static_cast
<
int64_t
>
(
aThreadId
.
ToNumber
(
)
)
)
;
aWriter
.
IntProperty
(
"
time
"
aCpuTimeMs
)
;
aWriter
.
IntProperty
(
"
wakeups
"
aWakeUps
)
;
aWriter
.
StringProperty
(
"
label
"
aThreadName
)
;
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyLabelFormat
(
"
time
"
"
CPU
Time
"
MS
:
:
Format
:
:
Milliseconds
)
;
schema
.
AddKeyLabelFormat
(
"
wakeups
"
"
Wake
ups
"
MS
:
:
Format
:
:
Integer
)
;
schema
.
SetTooltipLabel
(
"
{
marker
.
name
}
-
{
marker
.
data
.
label
}
"
)
;
schema
.
SetTableLabel
(
"
{
marker
.
data
.
label
}
:
{
marker
.
data
.
time
}
of
CPU
time
"
"
{
marker
.
data
.
wakeups
}
wake
ups
"
)
;
return
schema
;
}
}
;
}
#
endif
namespace
mozilla
:
:
profiler
{
ThreadRegistrationData
:
:
ThreadRegistrationData
(
const
char
*
aName
const
void
*
aStackTop
)
:
mInfo
(
aName
)
mPlatformData
(
mInfo
.
ThreadId
(
)
)
mStackTop
(
#
if
defined
(
XP_WIN
)
reinterpret_cast
<
const
void
*
>
(
reinterpret_cast
<
PNT_TIB
>
(
NtCurrentTeb
(
)
)
-
>
StackBase
)
#
elif
defined
(
XP_DARWIN
)
reinterpret_cast
<
const
void
*
>
(
pthread_get_stackaddr_np
(
pthread_self
(
)
)
)
#
else
aStackTop
#
endif
)
{
}
static
void
profiler_add_js_marker
(
mozilla
:
:
MarkerCategory
aCategory
const
char
*
aMarkerName
const
char
*
aMarkerText
)
{
#
ifdef
MOZ_GECKO_PROFILER
AUTO_PROFILER_STATS
(
js_marker
)
;
profiler_add_marker
(
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
aMarkerName
)
aCategory
{
}
:
:
geckoprofiler
:
:
markers
:
:
TextMarker
{
}
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
aMarkerText
)
)
;
#
endif
}
static
void
profiler_add_js_interval
(
mozilla
:
:
MarkerCategory
aCategory
const
char
*
aMarkerName
mozilla
:
:
TimeStamp
aStartTime
const
char
*
aMarkerText
)
{
#
ifdef
MOZ_GECKO_PROFILER
AUTO_PROFILER_STATS
(
js_interval
)
;
profiler_add_marker
(
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
aMarkerName
)
aCategory
mozilla
:
:
MarkerTiming
:
:
IntervalUntilNowFrom
(
aStartTime
)
:
:
geckoprofiler
:
:
markers
:
:
TextMarker
{
}
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
aMarkerText
)
)
;
#
endif
}
static
void
profiler_add_js_flow
(
mozilla
:
:
MarkerCategory
aCategory
const
char
*
aMarkerName
uint64_t
aFlowId
)
{
#
ifdef
MOZ_GECKO_PROFILER
if
(
!
profiler_feature_active
(
ProfilerFeature
:
:
Flows
)
)
{
return
;
}
AUTO_PROFILER_STATS
(
js_flow
)
;
profiler_add_marker
(
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
aMarkerName
)
aCategory
{
}
:
:
geckoprofiler
:
:
markers
:
:
FlowMarker
{
}
Flow
:
:
ProcessScoped
(
aFlowId
)
)
;
#
endif
}
static
void
profiler_add_js_terminating_flow
(
mozilla
:
:
MarkerCategory
aCategory
const
char
*
aMarkerName
uint64_t
aFlowId
)
{
#
ifdef
MOZ_GECKO_PROFILER
if
(
!
profiler_feature_active
(
ProfilerFeature
:
:
Flows
)
)
{
return
;
}
AUTO_PROFILER_STATS
(
js_terminating_flow
)
;
profiler_add_marker
(
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
aMarkerName
)
aCategory
{
}
:
:
geckoprofiler
:
:
markers
:
:
TerminatingFlowMarker
{
}
Flow
:
:
ProcessScoped
(
aFlowId
)
)
;
#
endif
}
static
void
profiler_add_js_allocation_marker
(
JS
:
:
RecordAllocationInfo
&
&
info
)
{
if
(
!
profiler_thread_is_being_profiled_for_markers
(
)
)
{
return
;
}
struct
JsAllocationMarker
{
static
constexpr
mozilla
:
:
Span
<
const
char
>
MarkerTypeName
(
)
{
return
mozilla
:
:
MakeStringSpan
(
"
JS
allocation
"
)
;
}
static
void
StreamJSONMarkerData
(
mozilla
:
:
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
mozilla
:
:
ProfilerString16View
&
aTypeName
const
mozilla
:
:
ProfilerString8View
&
aClassName
const
mozilla
:
:
ProfilerString16View
&
aDescriptiveTypeName
const
mozilla
:
:
ProfilerString8View
&
aCoarseType
uint64_t
aSize
bool
aInNursery
)
{
if
(
aClassName
.
Length
(
)
!
=
0
)
{
aWriter
.
StringProperty
(
"
className
"
aClassName
)
;
}
if
(
aTypeName
.
Length
(
)
!
=
0
)
{
aWriter
.
StringProperty
(
"
typeName
"
NS_ConvertUTF16toUTF8
(
aTypeName
)
)
;
}
if
(
aDescriptiveTypeName
.
Length
(
)
!
=
0
)
{
aWriter
.
StringProperty
(
"
descriptiveTypeName
"
NS_ConvertUTF16toUTF8
(
aDescriptiveTypeName
)
)
;
}
aWriter
.
StringProperty
(
"
coarseType
"
aCoarseType
)
;
aWriter
.
IntProperty
(
"
size
"
aSize
)
;
aWriter
.
BoolProperty
(
"
inNursery
"
aInNursery
)
;
}
static
mozilla
:
:
MarkerSchema
MarkerTypeDisplay
(
)
{
return
mozilla
:
:
MarkerSchema
:
:
SpecialFrontendLocation
{
}
;
}
}
;
profiler_add_marker
(
"
JS
allocation
"
geckoprofiler
:
:
category
:
:
JS
mozilla
:
:
MarkerStack
:
:
Capture
(
)
JsAllocationMarker
{
}
mozilla
:
:
ProfilerString16View
:
:
WrapNullTerminatedString
(
info
.
typeName
)
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
info
.
className
)
mozilla
:
:
ProfilerString16View
:
:
WrapNullTerminatedString
(
info
.
descriptiveTypeName
)
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
info
.
coarseType
)
info
.
size
info
.
inNursery
)
;
}
JSContext
*
ThreadRegistrationUnlockedReaderAndAtomicRWOnThread
:
:
GetJSContext
(
)
const
{
if
(
!
mCCJSContext
)
{
return
nullptr
;
}
return
mCCJSContext
-
>
Context
(
)
;
}
void
ThreadRegistrationLockedRWFromAnyThread
:
:
SetProfilingFeaturesAndData
(
ThreadProfilingFeatures
aProfilingFeatures
ProfiledThreadData
*
aProfiledThreadData
const
PSAutoLock
&
)
{
MOZ_ASSERT
(
mProfilingFeatures
=
=
ThreadProfilingFeatures
:
:
NotProfiled
)
;
mProfilingFeatures
=
aProfilingFeatures
;
MOZ_ASSERT
(
!
mProfiledThreadData
)
;
MOZ_ASSERT
(
aProfiledThreadData
)
;
mProfiledThreadData
=
aProfiledThreadData
;
if
(
mCCJSContext
)
{
MOZ_ASSERT
(
!
mJsFrameBuffer
)
;
mJsFrameBuffer
=
new
JsFrame
[
MAX_JS_FRAMES
]
;
}
MOZ_ASSERT
(
(
mProfilingFeatures
!
=
ThreadProfilingFeatures
:
:
NotProfiled
)
=
=
!
!
mProfiledThreadData
)
;
MOZ_ASSERT
(
(
mCCJSContext
&
&
(
mProfilingFeatures
!
=
ThreadProfilingFeatures
:
:
NotProfiled
)
)
=
=
!
!
mJsFrameBuffer
)
;
}
void
ThreadRegistrationLockedRWFromAnyThread
:
:
ClearProfilingFeaturesAndData
(
const
PSAutoLock
&
)
{
mProfilingFeatures
=
ThreadProfilingFeatures
:
:
NotProfiled
;
mProfiledThreadData
=
nullptr
;
if
(
mJsFrameBuffer
)
{
delete
[
]
mJsFrameBuffer
;
mJsFrameBuffer
=
nullptr
;
}
MOZ_ASSERT
(
(
mProfilingFeatures
!
=
ThreadProfilingFeatures
:
:
NotProfiled
)
=
=
!
!
mProfiledThreadData
)
;
MOZ_ASSERT
(
(
mCCJSContext
&
&
(
mProfilingFeatures
!
=
ThreadProfilingFeatures
:
:
NotProfiled
)
)
=
=
!
!
mJsFrameBuffer
)
;
}
void
ThreadRegistrationLockedRWOnThread
:
:
SetCycleCollectedJSContext
(
CycleCollectedJSContext
*
aCx
)
{
MOZ_ASSERT
(
aCx
&
&
!
mCCJSContext
)
;
MOZ_ASSERT
(
aCx
-
>
Context
(
)
)
;
mCCJSContext
=
aCx
;
if
(
mProfiledThreadData
)
{
MOZ_ASSERT
(
(
mProfilingFeatures
!
=
ThreadProfilingFeatures
:
:
NotProfiled
)
=
=
!
!
mProfiledThreadData
)
;
MOZ_ASSERT
(
!
mJsFrameBuffer
)
;
mJsFrameBuffer
=
new
JsFrame
[
MAX_JS_FRAMES
]
;
}
js
:
:
SetContextProfilingStack
(
aCx
-
>
Context
(
)
&
ProfilingStackRef
(
)
)
;
MOZ_ASSERT
(
(
mCCJSContext
&
&
(
mProfilingFeatures
!
=
ThreadProfilingFeatures
:
:
NotProfiled
)
)
=
=
!
!
mJsFrameBuffer
)
;
}
void
ThreadRegistrationLockedRWOnThread
:
:
ClearCycleCollectedJSContext
(
)
{
mCCJSContext
=
nullptr
;
if
(
mJsFrameBuffer
)
{
delete
[
]
mJsFrameBuffer
;
mJsFrameBuffer
=
nullptr
;
}
MOZ_ASSERT
(
(
mCCJSContext
&
&
(
mProfilingFeatures
!
=
ThreadProfilingFeatures
:
:
NotProfiled
)
)
=
=
!
!
mJsFrameBuffer
)
;
}
void
ThreadRegistrationLockedRWOnThread
:
:
PollJSSampling
(
)
{
if
(
mCCJSContext
)
{
JSContext
*
cx
=
mCCJSContext
-
>
Context
(
)
;
if
(
mJSSampling
=
=
ACTIVE_REQUESTED
)
{
mJSSampling
=
ACTIVE
;
js
:
:
EnableContextProfilingStack
(
cx
true
)
;
if
(
JSAllocationsEnabled
(
)
)
{
JS
:
:
EnableRecordingAllocations
(
cx
profiler_add_js_allocation_marker
0
.
01
)
;
}
js
:
:
RegisterContextProfilerMarkers
(
cx
profiler_add_js_marker
profiler_add_js_interval
profiler_add_js_flow
profiler_add_js_terminating_flow
)
;
}
else
if
(
mJSSampling
=
=
INACTIVE_REQUESTED
)
{
mJSSampling
=
INACTIVE
;
js
:
:
EnableContextProfilingStack
(
cx
false
)
;
if
(
JSAllocationsEnabled
(
)
)
{
JS
:
:
DisableRecordingAllocations
(
cx
)
;
}
}
}
}
#
ifdef
NIGHTLY_BUILD
void
ThreadRegistrationUnlockedConstReaderAndAtomicRW
:
:
RecordWakeCount
(
)
const
{
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
lock
(
mRecordWakeCountMutex
)
;
uint64_t
newWakeCount
=
mWakeCount
-
mAlreadyRecordedWakeCount
;
if
(
newWakeCount
=
=
0
&
&
mSleep
!
=
AWAKE
)
{
return
;
}
uint64_t
cpuTimeNs
;
if
(
!
GetCpuTimeSinceThreadStartInNs
(
&
cpuTimeNs
PlatformDataCRef
(
)
)
)
{
cpuTimeNs
=
0
;
}
constexpr
uint64_t
NS_PER_MS
=
1
'
000
'
000
;
uint64_t
cpuTimeMs
=
cpuTimeNs
/
NS_PER_MS
;
uint64_t
newCpuTimeMs
=
MOZ_LIKELY
(
cpuTimeMs
>
mAlreadyRecordedCpuTimeInMs
)
?
cpuTimeMs
-
mAlreadyRecordedCpuTimeInMs
:
0
;
if
(
!
newWakeCount
&
&
!
newCpuTimeMs
)
{
return
;
}
nsAutoCString
threadName
(
mInfo
.
Name
(
)
)
;
for
(
size_t
length
=
threadName
.
Length
(
)
;
length
>
0
;
-
-
length
)
{
const
char
c
=
threadName
.
CharAt
(
length
-
1
)
;
if
(
(
c
<
'
0
'
|
|
c
>
'
9
'
)
&
&
c
!
=
'
#
'
&
&
c
!
=
'
'
)
{
if
(
length
!
=
threadName
.
Length
(
)
)
{
threadName
.
SetLength
(
length
)
;
}
break
;
}
}
mozilla
:
:
glean
:
:
RecordThreadCpuUse
(
threadName
newCpuTimeMs
newWakeCount
)
;
PROFILER_MARKER
(
"
Thread
CPU
use
"
OTHER
{
}
ThreadCpuUseMarker
mInfo
.
ThreadId
(
)
newCpuTimeMs
newWakeCount
threadName
)
;
mAlreadyRecordedCpuTimeInMs
=
cpuTimeMs
;
mAlreadyRecordedWakeCount
+
=
newWakeCount
;
}
#
endif
}
