#
include
<
ostream
>
#
include
"
platform
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
TrackedOptimizationInfo
.
h
"
#
include
"
ProfileBufferEntry
.
h
"
using
mozilla
:
:
JSONWriter
;
using
mozilla
:
:
MakeUnique
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Some
;
using
mozilla
:
:
TimeStamp
;
using
mozilla
:
:
UniquePtr
;
ProfileBufferEntry
:
:
ProfileBufferEntry
(
)
:
mKind
(
Kind
:
:
INVALID
)
{
u
.
mString
=
nullptr
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
const
char
*
aString
)
:
mKind
(
aKind
)
{
u
.
mString
=
aString
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
char
aChars
[
kNumChars
]
)
:
mKind
(
aKind
)
{
memcpy
(
u
.
mChars
aChars
kNumChars
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
void
*
aPtr
)
:
mKind
(
aKind
)
{
u
.
mPtr
=
aPtr
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
ProfilerMarker
*
aMarker
)
:
mKind
(
aKind
)
{
u
.
mMarker
=
aMarker
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
double
aDouble
)
:
mKind
(
aKind
)
{
u
.
mDouble
=
aDouble
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
int
aInt
)
:
mKind
(
aKind
)
{
u
.
mInt
=
aInt
;
}
class
JSONSchemaWriter
{
JSONWriter
&
mWriter
;
uint32_t
mIndex
;
public
:
explicit
JSONSchemaWriter
(
JSONWriter
&
aWriter
)
:
mWriter
(
aWriter
)
mIndex
(
0
)
{
aWriter
.
StartObjectProperty
(
"
schema
"
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
}
void
WriteField
(
const
char
*
aName
)
{
mWriter
.
IntProperty
(
aName
mIndex
+
+
)
;
}
~
JSONSchemaWriter
(
)
{
mWriter
.
EndObject
(
)
;
}
}
;
class
StreamOptimizationTypeInfoOp
:
public
JS
:
:
ForEachTrackedOptimizationTypeInfoOp
{
JSONWriter
&
mWriter
;
UniqueJSONStrings
&
mUniqueStrings
;
bool
mStartedTypeList
;
public
:
StreamOptimizationTypeInfoOp
(
JSONWriter
&
aWriter
UniqueJSONStrings
&
aUniqueStrings
)
:
mWriter
(
aWriter
)
mUniqueStrings
(
aUniqueStrings
)
mStartedTypeList
(
false
)
{
}
void
readType
(
const
char
*
keyedBy
const
char
*
name
const
char
*
location
const
Maybe
<
unsigned
>
&
lineno
)
override
{
if
(
!
mStartedTypeList
)
{
mStartedTypeList
=
true
;
mWriter
.
StartObjectElement
(
)
;
mWriter
.
StartArrayProperty
(
"
typeset
"
)
;
}
mWriter
.
StartObjectElement
(
)
;
{
mUniqueStrings
.
WriteProperty
(
mWriter
"
keyedBy
"
keyedBy
)
;
if
(
name
)
{
mUniqueStrings
.
WriteProperty
(
mWriter
"
name
"
name
)
;
}
if
(
location
)
{
mUniqueStrings
.
WriteProperty
(
mWriter
"
location
"
location
)
;
}
if
(
lineno
.
isSome
(
)
)
{
mWriter
.
IntProperty
(
"
line
"
*
lineno
)
;
}
}
mWriter
.
EndObject
(
)
;
}
void
operator
(
)
(
JS
:
:
TrackedTypeSite
site
const
char
*
mirType
)
override
{
if
(
mStartedTypeList
)
{
mWriter
.
EndArray
(
)
;
mStartedTypeList
=
false
;
}
else
{
mWriter
.
StartObjectElement
(
)
;
}
{
mUniqueStrings
.
WriteProperty
(
mWriter
"
site
"
JS
:
:
TrackedTypeSiteString
(
site
)
)
;
mUniqueStrings
.
WriteProperty
(
mWriter
"
mirType
"
mirType
)
;
}
mWriter
.
EndObject
(
)
;
}
}
;
class
MOZ_RAII
AutoArraySchemaWriter
{
friend
class
AutoObjectWriter
;
SpliceableJSONWriter
&
mJSONWriter
;
UniqueJSONStrings
*
mStrings
;
uint32_t
mNextFreeIndex
;
public
:
AutoArraySchemaWriter
(
SpliceableJSONWriter
&
aWriter
UniqueJSONStrings
&
aStrings
)
:
mJSONWriter
(
aWriter
)
mStrings
(
&
aStrings
)
mNextFreeIndex
(
0
)
{
mJSONWriter
.
StartArrayElement
(
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
}
explicit
AutoArraySchemaWriter
(
SpliceableJSONWriter
&
aWriter
)
:
mJSONWriter
(
aWriter
)
mStrings
(
nullptr
)
mNextFreeIndex
(
0
)
{
mJSONWriter
.
StartArrayElement
(
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
}
~
AutoArraySchemaWriter
(
)
{
mJSONWriter
.
EndArray
(
)
;
}
void
FillUpTo
(
uint32_t
aIndex
)
{
MOZ_ASSERT
(
aIndex
>
=
mNextFreeIndex
)
;
mJSONWriter
.
NullElements
(
aIndex
-
mNextFreeIndex
)
;
mNextFreeIndex
=
aIndex
+
1
;
}
void
IntElement
(
uint32_t
aIndex
uint32_t
aValue
)
{
FillUpTo
(
aIndex
)
;
mJSONWriter
.
IntElement
(
aValue
)
;
}
void
DoubleElement
(
uint32_t
aIndex
double
aValue
)
{
FillUpTo
(
aIndex
)
;
mJSONWriter
.
DoubleElement
(
aValue
)
;
}
void
StringElement
(
uint32_t
aIndex
const
char
*
aValue
)
{
MOZ_RELEASE_ASSERT
(
mStrings
)
;
FillUpTo
(
aIndex
)
;
mStrings
-
>
WriteElement
(
mJSONWriter
aValue
)
;
}
}
;
class
StreamOptimizationAttemptsOp
:
public
JS
:
:
ForEachTrackedOptimizationAttemptOp
{
SpliceableJSONWriter
&
mWriter
;
UniqueJSONStrings
&
mUniqueStrings
;
public
:
StreamOptimizationAttemptsOp
(
SpliceableJSONWriter
&
aWriter
UniqueJSONStrings
&
aUniqueStrings
)
:
mWriter
(
aWriter
)
mUniqueStrings
(
aUniqueStrings
)
{
}
void
operator
(
)
(
JS
:
:
TrackedStrategy
strategy
JS
:
:
TrackedOutcome
outcome
)
override
{
enum
Schema
:
uint32_t
{
STRATEGY
=
0
OUTCOME
=
1
}
;
AutoArraySchemaWriter
writer
(
mWriter
mUniqueStrings
)
;
writer
.
StringElement
(
STRATEGY
JS
:
:
TrackedStrategyString
(
strategy
)
)
;
writer
.
StringElement
(
OUTCOME
JS
:
:
TrackedOutcomeString
(
outcome
)
)
;
}
}
;
uint32_t
UniqueJSONStrings
:
:
GetOrAddIndex
(
const
char
*
aStr
)
{
uint32_t
index
;
StringKey
key
(
aStr
)
;
auto
it
=
mStringToIndexMap
.
find
(
key
)
;
if
(
it
!
=
mStringToIndexMap
.
end
(
)
)
{
return
it
-
>
second
;
}
index
=
mStringToIndexMap
.
size
(
)
;
mStringToIndexMap
[
key
]
=
index
;
mStringTableWriter
.
StringElement
(
aStr
)
;
return
index
;
}
bool
UniqueStacks
:
:
FrameKey
:
:
operator
=
=
(
const
FrameKey
&
aOther
)
const
{
return
mLocation
=
=
aOther
.
mLocation
&
&
mLine
=
=
aOther
.
mLine
&
&
mCategory
=
=
aOther
.
mCategory
&
&
mJITAddress
=
=
aOther
.
mJITAddress
&
&
mJITDepth
=
=
aOther
.
mJITDepth
;
}
UniqueStacks
:
:
StackKey
UniqueStacks
:
:
BeginStack
(
const
OnStackFrameKey
&
aFrame
)
{
return
StackKey
(
GetOrAddFrameIndex
(
aFrame
)
)
;
}
UniqueStacks
:
:
StackKey
UniqueStacks
:
:
AppendFrame
(
const
StackKey
&
aStack
const
OnStackFrameKey
&
aFrame
)
{
return
StackKey
(
aStack
GetOrAddStackIndex
(
aStack
)
GetOrAddFrameIndex
(
aFrame
)
)
;
}
uint32_t
UniqueStacks
:
:
FrameKey
:
:
Hash
(
)
const
{
uint32_t
hash
=
0
;
if
(
!
mLocation
.
IsEmpty
(
)
)
{
hash
=
mozilla
:
:
HashString
(
mLocation
.
get
(
)
)
;
}
if
(
mLine
.
isSome
(
)
)
{
hash
=
mozilla
:
:
AddToHash
(
hash
*
mLine
)
;
}
if
(
mCategory
.
isSome
(
)
)
{
hash
=
mozilla
:
:
AddToHash
(
hash
*
mCategory
)
;
}
if
(
mJITAddress
.
isSome
(
)
)
{
hash
=
mozilla
:
:
AddToHash
(
hash
*
mJITAddress
)
;
if
(
mJITDepth
.
isSome
(
)
)
{
hash
=
mozilla
:
:
AddToHash
(
hash
*
mJITDepth
)
;
}
}
return
hash
;
}
UniqueStacks
:
:
UniqueStacks
(
JSContext
*
aContext
)
:
mContext
(
aContext
)
mFrameCount
(
0
)
{
mFrameTableWriter
.
StartBareList
(
)
;
mStackTableWriter
.
StartBareList
(
)
;
}
uint32_t
UniqueStacks
:
:
GetOrAddStackIndex
(
const
StackKey
&
aStack
)
{
uint32_t
index
;
if
(
mStackToIndexMap
.
Get
(
aStack
&
index
)
)
{
MOZ_ASSERT
(
index
<
mStackToIndexMap
.
Count
(
)
)
;
return
index
;
}
index
=
mStackToIndexMap
.
Count
(
)
;
mStackToIndexMap
.
Put
(
aStack
index
)
;
StreamStack
(
aStack
)
;
return
index
;
}
uint32_t
UniqueStacks
:
:
GetOrAddFrameIndex
(
const
OnStackFrameKey
&
aFrame
)
{
uint32_t
index
;
if
(
mFrameToIndexMap
.
Get
(
aFrame
&
index
)
)
{
MOZ_ASSERT
(
index
<
mFrameCount
)
;
return
index
;
}
if
(
aFrame
.
mJITFrameHandle
)
{
void
*
canonicalAddr
=
aFrame
.
mJITFrameHandle
-
>
canonicalAddress
(
)
;
if
(
canonicalAddr
!
=
*
aFrame
.
mJITAddress
)
{
OnStackFrameKey
canonicalKey
(
canonicalAddr
*
aFrame
.
mJITDepth
*
aFrame
.
mJITFrameHandle
)
;
uint32_t
canonicalIndex
=
GetOrAddFrameIndex
(
canonicalKey
)
;
mFrameToIndexMap
.
Put
(
aFrame
canonicalIndex
)
;
return
canonicalIndex
;
}
index
=
mFrameCount
+
+
;
mFrameToIndexMap
.
Put
(
aFrame
index
)
;
StreamJITFrame
(
*
aFrame
.
mJITFrameHandle
)
;
}
else
{
index
=
mFrameCount
+
+
;
mFrameToIndexMap
.
Put
(
aFrame
index
)
;
StreamNonJITFrame
(
aFrame
)
;
}
return
index
;
}
uint32_t
UniqueStacks
:
:
LookupJITFrameDepth
(
void
*
aAddr
)
{
uint32_t
depth
;
auto
it
=
mJITFrameDepthMap
.
find
(
aAddr
)
;
if
(
it
!
=
mJITFrameDepthMap
.
end
(
)
)
{
depth
=
it
-
>
second
;
MOZ_ASSERT
(
depth
>
0
)
;
return
depth
;
}
return
0
;
}
void
UniqueStacks
:
:
AddJITFrameDepth
(
void
*
aAddr
unsigned
depth
)
{
mJITFrameDepthMap
[
aAddr
]
=
depth
;
}
void
UniqueStacks
:
:
SpliceFrameTableElements
(
SpliceableJSONWriter
&
aWriter
)
{
mFrameTableWriter
.
EndBareList
(
)
;
aWriter
.
TakeAndSplice
(
mFrameTableWriter
.
WriteFunc
(
)
)
;
}
void
UniqueStacks
:
:
SpliceStackTableElements
(
SpliceableJSONWriter
&
aWriter
)
{
mStackTableWriter
.
EndBareList
(
)
;
aWriter
.
TakeAndSplice
(
mStackTableWriter
.
WriteFunc
(
)
)
;
}
void
UniqueStacks
:
:
StreamStack
(
const
StackKey
&
aStack
)
{
enum
Schema
:
uint32_t
{
PREFIX
=
0
FRAME
=
1
}
;
AutoArraySchemaWriter
writer
(
mStackTableWriter
mUniqueStrings
)
;
if
(
aStack
.
mPrefixStackIndex
.
isSome
(
)
)
{
writer
.
IntElement
(
PREFIX
*
aStack
.
mPrefixStackIndex
)
;
}
writer
.
IntElement
(
FRAME
aStack
.
mFrameIndex
)
;
}
void
UniqueStacks
:
:
StreamNonJITFrame
(
const
FrameKey
&
aFrame
)
{
enum
Schema
:
uint32_t
{
LOCATION
=
0
IMPLEMENTATION
=
1
OPTIMIZATIONS
=
2
LINE
=
3
CATEGORY
=
4
}
;
AutoArraySchemaWriter
writer
(
mFrameTableWriter
mUniqueStrings
)
;
writer
.
StringElement
(
LOCATION
aFrame
.
mLocation
.
get
(
)
)
;
if
(
aFrame
.
mLine
.
isSome
(
)
)
{
writer
.
IntElement
(
LINE
*
aFrame
.
mLine
)
;
}
if
(
aFrame
.
mCategory
.
isSome
(
)
)
{
writer
.
IntElement
(
CATEGORY
*
aFrame
.
mCategory
)
;
}
}
void
UniqueStacks
:
:
StreamJITFrame
(
const
JS
:
:
ProfiledFrameHandle
&
aJITFrame
)
{
enum
Schema
:
uint32_t
{
LOCATION
=
0
IMPLEMENTATION
=
1
OPTIMIZATIONS
=
2
LINE
=
3
CATEGORY
=
4
}
;
AutoArraySchemaWriter
writer
(
mFrameTableWriter
mUniqueStrings
)
;
writer
.
StringElement
(
LOCATION
aJITFrame
.
label
(
)
)
;
JS
:
:
ProfilingFrameIterator
:
:
FrameKind
frameKind
=
aJITFrame
.
frameKind
(
)
;
MOZ_ASSERT
(
frameKind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Ion
|
|
frameKind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Baseline
)
;
writer
.
StringElement
(
IMPLEMENTATION
frameKind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Ion
?
"
ion
"
:
"
baseline
"
)
;
if
(
aJITFrame
.
hasTrackedOptimizations
(
)
)
{
writer
.
FillUpTo
(
OPTIMIZATIONS
)
;
mFrameTableWriter
.
StartObjectElement
(
)
;
{
mFrameTableWriter
.
StartArrayProperty
(
"
types
"
)
;
{
StreamOptimizationTypeInfoOp
typeInfoOp
(
mFrameTableWriter
mUniqueStrings
)
;
aJITFrame
.
forEachOptimizationTypeInfo
(
typeInfoOp
)
;
}
mFrameTableWriter
.
EndArray
(
)
;
JS
:
:
Rooted
<
JSScript
*
>
script
(
mContext
)
;
jsbytecode
*
pc
;
mFrameTableWriter
.
StartObjectProperty
(
"
attempts
"
)
;
{
{
JSONSchemaWriter
schema
(
mFrameTableWriter
)
;
schema
.
WriteField
(
"
strategy
"
)
;
schema
.
WriteField
(
"
outcome
"
)
;
}
mFrameTableWriter
.
StartArrayProperty
(
"
data
"
)
;
{
StreamOptimizationAttemptsOp
attemptOp
(
mFrameTableWriter
mUniqueStrings
)
;
aJITFrame
.
forEachOptimizationAttempt
(
attemptOp
script
.
address
(
)
&
pc
)
;
}
mFrameTableWriter
.
EndArray
(
)
;
}
mFrameTableWriter
.
EndObject
(
)
;
if
(
JSAtom
*
name
=
js
:
:
GetPropertyNameFromPC
(
script
pc
)
)
{
char
buf
[
512
]
;
JS_PutEscapedFlatString
(
buf
mozilla
:
:
ArrayLength
(
buf
)
js
:
:
AtomToFlatString
(
name
)
0
)
;
mUniqueStrings
.
WriteProperty
(
mFrameTableWriter
"
propertyName
"
buf
)
;
}
unsigned
line
column
;
line
=
JS_PCToLineNumber
(
script
pc
&
column
)
;
mFrameTableWriter
.
IntProperty
(
"
line
"
line
)
;
mFrameTableWriter
.
IntProperty
(
"
column
"
column
)
;
}
mFrameTableWriter
.
EndObject
(
)
;
}
}
struct
ProfileSample
{
uint32_t
mStack
;
double
mTime
;
Maybe
<
double
>
mResponsiveness
;
Maybe
<
double
>
mRSS
;
Maybe
<
double
>
mUSS
;
}
;
static
void
WriteSample
(
SpliceableJSONWriter
&
aWriter
ProfileSample
&
aSample
)
{
enum
Schema
:
uint32_t
{
STACK
=
0
TIME
=
1
RESPONSIVENESS
=
2
RSS
=
3
USS
=
4
}
;
AutoArraySchemaWriter
writer
(
aWriter
)
;
writer
.
IntElement
(
STACK
aSample
.
mStack
)
;
writer
.
DoubleElement
(
TIME
aSample
.
mTime
)
;
if
(
aSample
.
mResponsiveness
.
isSome
(
)
)
{
writer
.
DoubleElement
(
RESPONSIVENESS
*
aSample
.
mResponsiveness
)
;
}
if
(
aSample
.
mRSS
.
isSome
(
)
)
{
writer
.
DoubleElement
(
RSS
*
aSample
.
mRSS
)
;
}
if
(
aSample
.
mUSS
.
isSome
(
)
)
{
writer
.
DoubleElement
(
USS
*
aSample
.
mUSS
)
;
}
}
class
EntryGetter
{
public
:
explicit
EntryGetter
(
const
ProfileBuffer
&
aBuffer
uint64_t
aInitialReadPos
=
0
)
:
mBuffer
(
aBuffer
)
mReadPos
(
aBuffer
.
mRangeStart
)
{
if
(
aInitialReadPos
!
=
0
)
{
MOZ_RELEASE_ASSERT
(
aInitialReadPos
>
=
aBuffer
.
mRangeStart
&
&
aInitialReadPos
<
=
aBuffer
.
mRangeEnd
)
;
mReadPos
=
aInitialReadPos
;
}
}
bool
Has
(
)
const
{
return
mReadPos
!
=
mBuffer
.
mRangeEnd
;
}
const
ProfileBufferEntry
&
Get
(
)
const
{
return
mBuffer
.
GetEntry
(
mReadPos
)
;
}
void
Next
(
)
{
mReadPos
+
+
;
}
private
:
const
ProfileBuffer
&
mBuffer
;
uint64_t
mReadPos
;
}
;
bool
ProfileBuffer
:
:
StreamSamplesToJSON
(
SpliceableJSONWriter
&
aWriter
int
aThreadId
double
aSinceTime
JSContext
*
aContext
UniqueStacks
&
aUniqueStacks
)
const
{
UniquePtr
<
char
[
]
>
strbuf
=
MakeUnique
<
char
[
]
>
(
kMaxFrameKeyLength
)
;
#
define
ERROR_AND_CONTINUE
(
msg
)
\
{
\
fprintf
(
stderr
"
ProfileBuffer
parse
error
:
%
s
"
msg
)
;
\
MOZ_ASSERT
(
false
msg
)
;
\
continue
;
\
}
EntryGetter
e
(
*
this
)
;
bool
haveSamples
=
false
;
for
(
;
;
)
{
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsThreadId
(
)
)
{
break
;
}
else
{
e
.
Next
(
)
;
}
}
if
(
!
e
.
Has
(
)
)
{
break
;
}
if
(
e
.
Get
(
)
.
IsThreadId
(
)
)
{
int
threadId
=
e
.
Get
(
)
.
u
.
mInt
;
e
.
Next
(
)
;
if
(
threadId
!
=
aThreadId
)
{
continue
;
}
}
else
{
MOZ_CRASH
(
)
;
}
ProfileSample
sample
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsTime
(
)
)
{
sample
.
mTime
=
e
.
Get
(
)
.
u
.
mDouble
;
e
.
Next
(
)
;
if
(
sample
.
mTime
<
aSinceTime
)
{
continue
;
}
}
else
{
ERROR_AND_CONTINUE
(
"
expected
a
Time
entry
"
)
;
}
UniqueStacks
:
:
StackKey
stack
=
aUniqueStacks
.
BeginStack
(
UniqueStacks
:
:
OnStackFrameKey
(
"
(
root
)
"
)
)
;
int
numFrames
=
0
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsNativeLeafAddr
(
)
)
{
numFrames
+
+
;
unsigned
long
long
pc
=
(
unsigned
long
long
)
(
uintptr_t
)
e
.
Get
(
)
.
u
.
mPtr
;
char
buf
[
20
]
;
SprintfLiteral
(
buf
"
%
#
llx
"
pc
)
;
stack
=
aUniqueStacks
.
AppendFrame
(
stack
UniqueStacks
:
:
OnStackFrameKey
(
buf
)
)
;
e
.
Next
(
)
;
}
else
if
(
e
.
Get
(
)
.
IsLabel
(
)
)
{
numFrames
+
+
;
const
char
*
label
=
e
.
Get
(
)
.
u
.
mString
;
strncpy
(
strbuf
.
get
(
)
label
kMaxFrameKeyLength
)
;
size_t
i
=
strlen
(
label
)
;
e
.
Next
(
)
;
bool
seenFirstDynamicStringFragment
=
false
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsDynamicStringFragment
(
)
)
{
if
(
!
seenFirstDynamicStringFragment
)
{
if
(
i
>
0
&
&
i
<
kMaxFrameKeyLength
)
{
strbuf
[
i
]
=
'
'
;
i
+
+
;
}
seenFirstDynamicStringFragment
=
true
;
}
for
(
size_t
j
=
0
;
j
<
ProfileBufferEntry
:
:
kNumChars
;
j
+
+
)
{
const
char
*
chars
=
e
.
Get
(
)
.
u
.
mChars
;
if
(
i
<
kMaxFrameKeyLength
)
{
strbuf
[
i
]
=
chars
[
j
]
;
i
+
+
;
}
}
e
.
Next
(
)
;
}
else
{
break
;
}
}
strbuf
[
kMaxFrameKeyLength
-
1
]
=
'
\
0
'
;
UniqueStacks
:
:
OnStackFrameKey
frameKey
(
strbuf
.
get
(
)
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsLineNumber
(
)
)
{
frameKey
.
mLine
=
Some
(
unsigned
(
e
.
Get
(
)
.
u
.
mInt
)
)
;
e
.
Next
(
)
;
}
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsCategory
(
)
)
{
frameKey
.
mCategory
=
Some
(
unsigned
(
e
.
Get
(
)
.
u
.
mInt
)
)
;
e
.
Next
(
)
;
}
stack
=
aUniqueStacks
.
AppendFrame
(
stack
frameKey
)
;
}
else
if
(
e
.
Get
(
)
.
IsJitReturnAddr
(
)
)
{
numFrames
+
+
;
void
*
pc
=
e
.
Get
(
)
.
u
.
mPtr
;
unsigned
depth
=
aUniqueStacks
.
LookupJITFrameDepth
(
pc
)
;
if
(
depth
=
=
0
)
{
MOZ_RELEASE_ASSERT
(
aContext
)
;
for
(
JS
:
:
ProfiledFrameHandle
handle
:
JS
:
:
GetProfiledFrames
(
aContext
pc
)
)
{
UniqueStacks
:
:
OnStackFrameKey
frameKey
(
pc
depth
handle
)
;
stack
=
aUniqueStacks
.
AppendFrame
(
stack
frameKey
)
;
depth
+
+
;
}
MOZ_ASSERT
(
depth
>
0
)
;
aUniqueStacks
.
AddJITFrameDepth
(
pc
depth
)
;
}
else
{
for
(
unsigned
i
=
0
;
i
<
depth
;
i
+
+
)
{
UniqueStacks
:
:
OnStackFrameKey
inlineFrameKey
(
pc
i
)
;
stack
=
aUniqueStacks
.
AppendFrame
(
stack
inlineFrameKey
)
;
}
}
e
.
Next
(
)
;
}
else
{
break
;
}
}
if
(
numFrames
=
=
0
)
{
ERROR_AND_CONTINUE
(
"
expected
one
or
more
frame
entries
"
)
;
}
sample
.
mStack
=
aUniqueStacks
.
GetOrAddStackIndex
(
stack
)
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsMarker
(
)
)
{
e
.
Next
(
)
;
}
else
{
break
;
}
}
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsResponsiveness
(
)
)
{
sample
.
mResponsiveness
=
Some
(
e
.
Get
(
)
.
u
.
mDouble
)
;
e
.
Next
(
)
;
}
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsResidentMemory
(
)
)
{
sample
.
mRSS
=
Some
(
e
.
Get
(
)
.
u
.
mDouble
)
;
e
.
Next
(
)
;
}
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsUnsharedMemory
(
)
)
{
sample
.
mUSS
=
Some
(
e
.
Get
(
)
.
u
.
mDouble
)
;
e
.
Next
(
)
;
}
WriteSample
(
aWriter
sample
)
;
haveSamples
=
true
;
}
return
haveSamples
;
#
undef
ERROR_AND_CONTINUE
}
bool
ProfileBuffer
:
:
StreamMarkersToJSON
(
SpliceableJSONWriter
&
aWriter
int
aThreadId
const
TimeStamp
&
aProcessStartTime
double
aSinceTime
UniqueStacks
&
aUniqueStacks
)
const
{
EntryGetter
e
(
*
this
)
;
bool
haveMarkers
=
false
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsMarker
(
)
)
{
const
ProfilerMarker
*
marker
=
e
.
Get
(
)
.
u
.
mMarker
;
if
(
marker
-
>
GetTime
(
)
>
=
aSinceTime
&
&
marker
-
>
GetThreadId
(
)
=
=
aThreadId
)
{
marker
-
>
StreamJSON
(
aWriter
aProcessStartTime
aUniqueStacks
)
;
haveMarkers
=
true
;
}
}
e
.
Next
(
)
;
}
return
haveMarkers
;
}
static
void
AddPausedRange
(
SpliceableJSONWriter
&
aWriter
const
char
*
aReason
const
Maybe
<
double
>
&
aStartTime
const
Maybe
<
double
>
&
aEndTime
)
{
aWriter
.
Start
(
)
;
if
(
aStartTime
)
{
aWriter
.
DoubleProperty
(
"
startTime
"
*
aStartTime
)
;
}
else
{
aWriter
.
NullProperty
(
"
startTime
"
)
;
}
if
(
aEndTime
)
{
aWriter
.
DoubleProperty
(
"
endTime
"
*
aEndTime
)
;
}
else
{
aWriter
.
NullProperty
(
"
endTime
"
)
;
}
aWriter
.
StringProperty
(
"
reason
"
aReason
)
;
aWriter
.
End
(
)
;
}
void
ProfileBuffer
:
:
StreamPausedRangesToJSON
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
)
const
{
EntryGetter
e
(
*
this
)
;
Maybe
<
double
>
currentPauseStartTime
;
Maybe
<
double
>
currentCollectionStartTime
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsPause
(
)
)
{
currentPauseStartTime
=
Some
(
e
.
Get
(
)
.
u
.
mDouble
)
;
}
else
if
(
e
.
Get
(
)
.
IsResume
(
)
)
{
AddPausedRange
(
aWriter
"
profiler
-
paused
"
currentPauseStartTime
Some
(
e
.
Get
(
)
.
u
.
mDouble
)
)
;
currentPauseStartTime
=
Nothing
(
)
;
}
else
if
(
e
.
Get
(
)
.
IsCollectionStart
(
)
)
{
currentCollectionStartTime
=
Some
(
e
.
Get
(
)
.
u
.
mDouble
)
;
}
else
if
(
e
.
Get
(
)
.
IsCollectionEnd
(
)
)
{
AddPausedRange
(
aWriter
"
collecting
"
currentCollectionStartTime
Some
(
e
.
Get
(
)
.
u
.
mDouble
)
)
;
currentCollectionStartTime
=
Nothing
(
)
;
}
e
.
Next
(
)
;
}
if
(
currentPauseStartTime
)
{
AddPausedRange
(
aWriter
"
profiler
-
paused
"
currentPauseStartTime
Nothing
(
)
)
;
}
if
(
currentCollectionStartTime
)
{
AddPausedRange
(
aWriter
"
collecting
"
currentCollectionStartTime
Nothing
(
)
)
;
}
}
bool
ProfileBuffer
:
:
DuplicateLastSample
(
int
aThreadId
const
TimeStamp
&
aProcessStartTime
Maybe
<
uint64_t
>
&
aLastSample
)
{
if
(
aLastSample
&
&
*
aLastSample
<
mRangeStart
)
{
aLastSample
.
reset
(
)
;
}
if
(
!
aLastSample
)
{
return
false
;
}
uint64_t
lastSampleStartPos
=
*
aLastSample
;
MOZ_RELEASE_ASSERT
(
GetEntry
(
lastSampleStartPos
)
.
IsThreadId
(
)
&
&
GetEntry
(
lastSampleStartPos
)
.
u
.
mInt
=
=
aThreadId
)
;
aLastSample
=
Some
(
AddThreadIdEntry
(
aThreadId
)
)
;
EntryGetter
e
(
*
this
lastSampleStartPos
+
1
)
;
while
(
e
.
Has
(
)
)
{
switch
(
e
.
Get
(
)
.
GetKind
(
)
)
{
case
ProfileBufferEntry
:
:
Kind
:
:
Pause
:
case
ProfileBufferEntry
:
:
Kind
:
:
Resume
:
case
ProfileBufferEntry
:
:
Kind
:
:
CollectionStart
:
case
ProfileBufferEntry
:
:
Kind
:
:
CollectionEnd
:
case
ProfileBufferEntry
:
:
Kind
:
:
ThreadId
:
return
true
;
case
ProfileBufferEntry
:
:
Kind
:
:
Time
:
AddEntry
(
ProfileBufferEntry
:
:
Time
(
(
TimeStamp
:
:
Now
(
)
-
aProcessStartTime
)
.
ToMilliseconds
(
)
)
)
;
break
;
case
ProfileBufferEntry
:
:
Kind
:
:
Marker
:
break
;
default
:
{
ProfileBufferEntry
entry
=
e
.
Get
(
)
;
AddEntry
(
entry
)
;
break
;
}
}
e
.
Next
(
)
;
}
return
true
;
}
