#
include
"
ProfileBufferEntry
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
platform
.
h
"
#
include
"
ProfileBuffer
.
h
"
#
include
"
ProfiledThreadData
.
h
"
#
include
"
ProfilerBacktrace
.
h
"
#
include
"
ProfilerRustBindings
.
h
"
#
include
"
js
/
ProfilingFrameIterator
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
JSONStringWriteFuncs
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
ProfilerCodeAddressService
.
h
"
#
include
<
ostream
>
#
include
<
type_traits
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
literals
:
:
ProportionValue_literals
;
ProfileBufferEntry
:
:
ProfileBufferEntry
(
)
:
mKind
(
Kind
:
:
INVALID
)
mStorage
{
0
0
0
0
0
0
0
0
}
{
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
const
char
*
aString
)
:
mKind
(
aKind
)
{
MOZ_ASSERT
(
aKind
=
=
Kind
:
:
Label
)
;
memcpy
(
mStorage
&
aString
sizeof
(
aString
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
char
aChars
[
kNumChars
]
)
:
mKind
(
aKind
)
{
MOZ_ASSERT
(
aKind
=
=
Kind
:
:
DynamicStringFragment
)
;
memcpy
(
mStorage
aChars
kNumChars
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
void
*
aPtr
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aPtr
sizeof
(
aPtr
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
double
aDouble
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aDouble
sizeof
(
aDouble
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
int
aInt
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aInt
sizeof
(
aInt
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
int64_t
aInt64
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aInt64
sizeof
(
aInt64
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
uint64_t
aUint64
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aUint64
sizeof
(
aUint64
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
ProfilerThreadId
aThreadId
)
:
mKind
(
aKind
)
{
static_assert
(
std
:
:
is_trivially_copyable_v
<
ProfilerThreadId
>
)
;
static_assert
(
sizeof
(
aThreadId
)
<
=
sizeof
(
mStorage
)
)
;
memcpy
(
mStorage
&
aThreadId
sizeof
(
aThreadId
)
)
;
}
const
char
*
ProfileBufferEntry
:
:
GetString
(
)
const
{
const
char
*
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
void
*
ProfileBufferEntry
:
:
GetPtr
(
)
const
{
void
*
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
double
ProfileBufferEntry
:
:
GetDouble
(
)
const
{
double
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
int
ProfileBufferEntry
:
:
GetInt
(
)
const
{
int
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
int64_t
ProfileBufferEntry
:
:
GetInt64
(
)
const
{
int64_t
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
uint64_t
ProfileBufferEntry
:
:
GetUint64
(
)
const
{
uint64_t
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
ProfilerThreadId
ProfileBufferEntry
:
:
GetThreadId
(
)
const
{
ProfilerThreadId
result
;
static_assert
(
std
:
:
is_trivially_copyable_v
<
ProfilerThreadId
>
)
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
void
ProfileBufferEntry
:
:
CopyCharsInto
(
char
(
&
aOutArray
)
[
kNumChars
]
)
const
{
memcpy
(
aOutArray
mStorage
kNumChars
)
;
}
struct
TypeInfo
{
Maybe
<
nsCString
>
mKeyedBy
;
Maybe
<
nsCString
>
mName
;
Maybe
<
nsCString
>
mLocation
;
Maybe
<
unsigned
>
mLineNumber
;
}
;
class
MOZ_RAII
AutoArraySchemaWriter
{
public
:
explicit
AutoArraySchemaWriter
(
SpliceableJSONWriter
&
aWriter
)
:
mJSONWriter
(
aWriter
)
mNextFreeIndex
(
0
)
{
mJSONWriter
.
StartArrayElement
(
)
;
}
~
AutoArraySchemaWriter
(
)
{
mJSONWriter
.
EndArray
(
)
;
}
template
<
typename
T
>
void
IntElement
(
uint32_t
aIndex
T
aValue
)
{
static_assert
(
!
std
:
:
is_same_v
<
T
uint64_t
>
"
Narrowing
uint64
-
>
int64
conversion
not
allowed
"
)
;
FillUpTo
(
aIndex
)
;
mJSONWriter
.
IntElement
(
static_cast
<
int64_t
>
(
aValue
)
)
;
}
void
DoubleElement
(
uint32_t
aIndex
double
aValue
)
{
FillUpTo
(
aIndex
)
;
mJSONWriter
.
DoubleElement
(
aValue
)
;
}
void
TimeMsElement
(
uint32_t
aIndex
double
aTime_ms
)
{
FillUpTo
(
aIndex
)
;
mJSONWriter
.
TimeDoubleMsElement
(
aTime_ms
)
;
}
void
BoolElement
(
uint32_t
aIndex
bool
aValue
)
{
FillUpTo
(
aIndex
)
;
mJSONWriter
.
BoolElement
(
aValue
)
;
}
protected
:
SpliceableJSONWriter
&
Writer
(
)
{
return
mJSONWriter
;
}
void
FillUpTo
(
uint32_t
aIndex
)
{
MOZ_ASSERT
(
aIndex
>
=
mNextFreeIndex
)
;
mJSONWriter
.
NullElements
(
aIndex
-
mNextFreeIndex
)
;
mNextFreeIndex
=
aIndex
+
1
;
}
private
:
SpliceableJSONWriter
&
mJSONWriter
;
uint32_t
mNextFreeIndex
;
}
;
class
MOZ_RAII
AutoArraySchemaWithStringsWriter
:
public
AutoArraySchemaWriter
{
public
:
AutoArraySchemaWithStringsWriter
(
SpliceableJSONWriter
&
aWriter
UniqueJSONStrings
&
aStrings
)
:
AutoArraySchemaWriter
(
aWriter
)
mStrings
(
aStrings
)
{
}
void
StringElement
(
uint32_t
aIndex
const
Span
<
const
char
>
&
aValue
)
{
FillUpTo
(
aIndex
)
;
mStrings
.
WriteElement
(
Writer
(
)
aValue
)
;
}
private
:
UniqueJSONStrings
&
mStrings
;
}
;
UniqueStacks
:
:
StackKey
UniqueStacks
:
:
BeginStack
(
const
FrameKey
&
aFrame
)
{
return
StackKey
(
GetOrAddFrameIndex
(
aFrame
)
)
;
}
UniqueStacks
:
:
StackKey
UniqueStacks
:
:
AppendFrame
(
const
StackKey
&
aStack
const
FrameKey
&
aFrame
)
{
return
StackKey
(
aStack
GetOrAddStackIndex
(
aStack
)
GetOrAddFrameIndex
(
aFrame
)
)
;
}
JITFrameInfoForBufferRange
JITFrameInfoForBufferRange
:
:
Clone
(
)
const
{
JITFrameInfoForBufferRange
:
:
JITAddressToJITFramesMap
jitAddressToJITFramesMap
;
MOZ_RELEASE_ASSERT
(
jitAddressToJITFramesMap
.
reserve
(
mJITAddressToJITFramesMap
.
count
(
)
)
)
;
for
(
auto
iter
=
mJITAddressToJITFramesMap
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
const
mozilla
:
:
Vector
<
JITFrameKey
>
&
srcKeys
=
iter
.
get
(
)
.
value
(
)
;
mozilla
:
:
Vector
<
JITFrameKey
>
destKeys
;
MOZ_RELEASE_ASSERT
(
destKeys
.
appendAll
(
srcKeys
)
)
;
jitAddressToJITFramesMap
.
putNewInfallible
(
iter
.
get
(
)
.
key
(
)
std
:
:
move
(
destKeys
)
)
;
}
JITFrameInfoForBufferRange
:
:
JITFrameToFrameJSONMap
jitFrameToFrameJSONMap
;
MOZ_RELEASE_ASSERT
(
jitFrameToFrameJSONMap
.
reserve
(
mJITFrameToFrameJSONMap
.
count
(
)
)
)
;
for
(
auto
iter
=
mJITFrameToFrameJSONMap
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
jitFrameToFrameJSONMap
.
putNewInfallible
(
iter
.
get
(
)
.
key
(
)
iter
.
get
(
)
.
value
(
)
)
;
}
return
JITFrameInfoForBufferRange
{
mRangeStart
mRangeEnd
std
:
:
move
(
jitAddressToJITFramesMap
)
std
:
:
move
(
jitFrameToFrameJSONMap
)
}
;
}
JITFrameInfo
:
:
JITFrameInfo
(
const
JITFrameInfo
&
aOther
mozilla
:
:
ProgressLogger
aProgressLogger
)
:
mUniqueStrings
(
MakeUnique
<
UniqueJSONStrings
>
(
*
aOther
.
mUniqueStrings
aProgressLogger
.
CreateSubLoggerFromTo
(
0_pc
"
Creating
JIT
frame
info
unique
strings
.
.
.
"
49_pc
"
Created
JIT
frame
info
unique
strings
"
)
)
)
{
MOZ_ALWAYS_TRUE
(
mRanges
.
reserve
(
aOther
.
mRanges
.
length
(
)
)
)
;
for
(
auto
&
&
[
i
progressLogger
]
:
aProgressLogger
.
CreateLoopSubLoggersFromTo
(
50_pc
100_pc
aOther
.
mRanges
.
length
(
)
"
Copying
JIT
frame
info
"
)
)
{
mRanges
.
infallibleAppend
(
aOther
.
mRanges
[
i
]
.
Clone
(
)
)
;
}
}
bool
UniqueStacks
:
:
FrameKey
:
:
NormalFrameData
:
:
operator
=
=
(
const
NormalFrameData
&
aOther
)
const
{
return
mLocation
=
=
aOther
.
mLocation
&
&
mRelevantForJS
=
=
aOther
.
mRelevantForJS
&
&
mBaselineInterp
=
=
aOther
.
mBaselineInterp
&
&
mInnerWindowID
=
=
aOther
.
mInnerWindowID
&
&
mLine
=
=
aOther
.
mLine
&
&
mColumn
=
=
aOther
.
mColumn
&
&
mCategoryPair
=
=
aOther
.
mCategoryPair
;
}
bool
UniqueStacks
:
:
FrameKey
:
:
JITFrameData
:
:
operator
=
=
(
const
JITFrameData
&
aOther
)
const
{
return
mCanonicalAddress
=
=
aOther
.
mCanonicalAddress
&
&
mDepth
=
=
aOther
.
mDepth
&
&
mRangeIndex
=
=
aOther
.
mRangeIndex
;
}
UniqueStacks
:
:
UniqueStacks
(
JITFrameInfo
&
&
aJITFrameInfo
ProfilerCodeAddressService
*
aCodeAddressService
)
:
mUniqueStrings
(
std
:
:
move
(
aJITFrameInfo
)
.
MoveUniqueStrings
(
)
)
mCodeAddressService
(
aCodeAddressService
)
mJITInfoRanges
(
std
:
:
move
(
aJITFrameInfo
)
.
MoveRanges
(
)
)
{
mFrameTableWriter
.
StartBareList
(
)
;
mStackTableWriter
.
StartBareList
(
)
;
}
uint32_t
UniqueStacks
:
:
GetOrAddStackIndex
(
const
StackKey
&
aStack
)
{
uint32_t
count
=
mStackToIndexMap
.
count
(
)
;
auto
entry
=
mStackToIndexMap
.
lookupForAdd
(
aStack
)
;
if
(
entry
)
{
MOZ_ASSERT
(
entry
-
>
value
(
)
<
count
)
;
return
entry
-
>
value
(
)
;
}
MOZ_RELEASE_ASSERT
(
mStackToIndexMap
.
add
(
entry
aStack
count
)
)
;
StreamStack
(
aStack
)
;
return
count
;
}
Maybe
<
Vector
<
UniqueStacks
:
:
FrameKey
>
>
UniqueStacks
:
:
LookupFramesForJITAddressFromBufferPos
(
void
*
aJITAddress
uint64_t
aBufferPos
)
{
JITFrameInfoForBufferRange
*
rangeIter
=
std
:
:
lower_bound
(
mJITInfoRanges
.
begin
(
)
mJITInfoRanges
.
end
(
)
aBufferPos
[
]
(
const
JITFrameInfoForBufferRange
&
aRange
uint64_t
aPos
)
{
return
aRange
.
mRangeEnd
<
aPos
;
}
)
;
MOZ_RELEASE_ASSERT
(
rangeIter
!
=
mJITInfoRanges
.
end
(
)
&
&
rangeIter
-
>
mRangeStart
<
=
aBufferPos
&
&
aBufferPos
<
rangeIter
-
>
mRangeEnd
"
Buffer
position
of
jit
address
needs
to
be
in
one
of
the
ranges
"
)
;
using
JITFrameKey
=
JITFrameInfoForBufferRange
:
:
JITFrameKey
;
const
JITFrameInfoForBufferRange
&
jitFrameInfoRange
=
*
rangeIter
;
auto
jitFrameKeys
=
jitFrameInfoRange
.
mJITAddressToJITFramesMap
.
lookup
(
aJITAddress
)
;
if
(
!
jitFrameKeys
)
{
return
Nothing
(
)
;
}
Vector
<
FrameKey
>
frameKeys
;
MOZ_RELEASE_ASSERT
(
frameKeys
.
initCapacity
(
jitFrameKeys
-
>
value
(
)
.
length
(
)
)
)
;
for
(
const
JITFrameKey
&
jitFrameKey
:
jitFrameKeys
-
>
value
(
)
)
{
FrameKey
frameKey
(
jitFrameKey
.
mCanonicalAddress
jitFrameKey
.
mDepth
rangeIter
-
mJITInfoRanges
.
begin
(
)
)
;
uint32_t
index
=
mFrameToIndexMap
.
count
(
)
;
auto
entry
=
mFrameToIndexMap
.
lookupForAdd
(
frameKey
)
;
if
(
!
entry
)
{
auto
frameJSON
=
jitFrameInfoRange
.
mJITFrameToFrameJSONMap
.
lookup
(
jitFrameKey
)
;
MOZ_RELEASE_ASSERT
(
frameJSON
"
Should
have
cached
JSON
for
this
frame
"
)
;
mFrameTableWriter
.
Splice
(
frameJSON
-
>
value
(
)
)
;
MOZ_RELEASE_ASSERT
(
mFrameToIndexMap
.
add
(
entry
frameKey
index
)
)
;
}
MOZ_RELEASE_ASSERT
(
frameKeys
.
append
(
std
:
:
move
(
frameKey
)
)
)
;
}
return
Some
(
std
:
:
move
(
frameKeys
)
)
;
}
uint32_t
UniqueStacks
:
:
GetOrAddFrameIndex
(
const
FrameKey
&
aFrame
)
{
uint32_t
count
=
mFrameToIndexMap
.
count
(
)
;
auto
entry
=
mFrameToIndexMap
.
lookupForAdd
(
aFrame
)
;
if
(
entry
)
{
MOZ_ASSERT
(
entry
-
>
value
(
)
<
count
)
;
return
entry
-
>
value
(
)
;
}
MOZ_RELEASE_ASSERT
(
mFrameToIndexMap
.
add
(
entry
aFrame
count
)
)
;
StreamNonJITFrame
(
aFrame
)
;
return
count
;
}
void
UniqueStacks
:
:
SpliceFrameTableElements
(
SpliceableJSONWriter
&
aWriter
)
{
mFrameTableWriter
.
EndBareList
(
)
;
aWriter
.
TakeAndSplice
(
mFrameTableWriter
.
TakeChunkedWriteFunc
(
)
)
;
}
void
UniqueStacks
:
:
SpliceStackTableElements
(
SpliceableJSONWriter
&
aWriter
)
{
mStackTableWriter
.
EndBareList
(
)
;
aWriter
.
TakeAndSplice
(
mStackTableWriter
.
TakeChunkedWriteFunc
(
)
)
;
}
[
[
nodiscard
]
]
nsAutoCString
UniqueStacks
:
:
FunctionNameOrAddress
(
void
*
aPC
)
{
nsAutoCString
nameOrAddress
;
if
(
!
mCodeAddressService
|
|
!
mCodeAddressService
-
>
GetFunction
(
aPC
nameOrAddress
)
|
|
nameOrAddress
.
IsEmpty
(
)
)
{
nameOrAddress
.
AppendASCII
(
"
0x
"
)
;
using
uint
=
std
:
:
conditional_t
<
sizeof
(
uintptr_t
)
<
=
sizeof
(
uint32_t
)
uint32_t
uint64_t
>
;
nameOrAddress
.
AppendInt
(
static_cast
<
uint
>
(
reinterpret_cast
<
uintptr_t
>
(
aPC
)
)
16
)
;
}
return
nameOrAddress
;
}
void
UniqueStacks
:
:
StreamStack
(
const
StackKey
&
aStack
)
{
enum
Schema
:
uint32_t
{
PREFIX
=
0
FRAME
=
1
}
;
AutoArraySchemaWriter
writer
(
mStackTableWriter
)
;
if
(
aStack
.
mPrefixStackIndex
.
isSome
(
)
)
{
writer
.
IntElement
(
PREFIX
*
aStack
.
mPrefixStackIndex
)
;
}
writer
.
IntElement
(
FRAME
aStack
.
mFrameIndex
)
;
}
void
UniqueStacks
:
:
StreamNonJITFrame
(
const
FrameKey
&
aFrame
)
{
using
NormalFrameData
=
FrameKey
:
:
NormalFrameData
;
enum
Schema
:
uint32_t
{
LOCATION
=
0
RELEVANT_FOR_JS
=
1
INNER_WINDOW_ID
=
2
IMPLEMENTATION
=
3
OPTIMIZATIONS
=
4
LINE
=
5
COLUMN
=
6
CATEGORY
=
7
SUBCATEGORY
=
8
}
;
AutoArraySchemaWithStringsWriter
writer
(
mFrameTableWriter
*
mUniqueStrings
)
;
const
NormalFrameData
&
data
=
aFrame
.
mData
.
as
<
NormalFrameData
>
(
)
;
writer
.
StringElement
(
LOCATION
data
.
mLocation
)
;
writer
.
BoolElement
(
RELEVANT_FOR_JS
data
.
mRelevantForJS
)
;
writer
.
DoubleElement
(
INNER_WINDOW_ID
data
.
mInnerWindowID
)
;
if
(
data
.
mBaselineInterp
)
{
writer
.
StringElement
(
IMPLEMENTATION
MakeStringSpan
(
"
blinterp
"
)
)
;
}
if
(
data
.
mLine
.
isSome
(
)
)
{
writer
.
IntElement
(
LINE
*
data
.
mLine
)
;
}
if
(
data
.
mColumn
.
isSome
(
)
)
{
writer
.
IntElement
(
COLUMN
*
data
.
mColumn
)
;
}
if
(
data
.
mCategoryPair
.
isSome
(
)
)
{
const
JS
:
:
ProfilingCategoryPairInfo
&
info
=
JS
:
:
GetProfilingCategoryPairInfo
(
*
data
.
mCategoryPair
)
;
writer
.
IntElement
(
CATEGORY
uint32_t
(
info
.
mCategory
)
)
;
writer
.
IntElement
(
SUBCATEGORY
info
.
mSubcategoryIndex
)
;
}
}
static
void
StreamJITFrame
(
JSContext
*
aContext
SpliceableJSONWriter
&
aWriter
UniqueJSONStrings
&
aUniqueStrings
const
JS
:
:
ProfiledFrameHandle
&
aJITFrame
)
{
enum
Schema
:
uint32_t
{
LOCATION
=
0
RELEVANT_FOR_JS
=
1
INNER_WINDOW_ID
=
2
IMPLEMENTATION
=
3
OPTIMIZATIONS
=
4
LINE
=
5
COLUMN
=
6
CATEGORY
=
7
SUBCATEGORY
=
8
}
;
AutoArraySchemaWithStringsWriter
writer
(
aWriter
aUniqueStrings
)
;
writer
.
StringElement
(
LOCATION
MakeStringSpan
(
aJITFrame
.
label
(
)
)
)
;
writer
.
BoolElement
(
RELEVANT_FOR_JS
false
)
;
writer
.
DoubleElement
(
INNER_WINDOW_ID
aJITFrame
.
realmID
(
)
)
;
JS
:
:
ProfilingFrameIterator
:
:
FrameKind
frameKind
=
aJITFrame
.
frameKind
(
)
;
MOZ_ASSERT
(
frameKind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Ion
|
|
frameKind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Baseline
)
;
writer
.
StringElement
(
IMPLEMENTATION
frameKind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Ion
?
MakeStringSpan
(
"
ion
"
)
:
MakeStringSpan
(
"
baseline
"
)
)
;
const
JS
:
:
ProfilingCategoryPairInfo
&
info
=
JS
:
:
GetProfilingCategoryPairInfo
(
frameKind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Ion
?
JS
:
:
ProfilingCategoryPair
:
:
JS_IonMonkey
:
JS
:
:
ProfilingCategoryPair
:
:
JS_Baseline
)
;
writer
.
IntElement
(
CATEGORY
uint32_t
(
info
.
mCategory
)
)
;
writer
.
IntElement
(
SUBCATEGORY
info
.
mSubcategoryIndex
)
;
}
static
nsCString
JSONForJITFrame
(
JSContext
*
aContext
const
JS
:
:
ProfiledFrameHandle
&
aJITFrame
UniqueJSONStrings
&
aUniqueStrings
)
{
nsCString
json
;
JSONStringRefWriteFunc
jw
(
json
)
;
SpliceableJSONWriter
writer
(
jw
)
;
StreamJITFrame
(
aContext
writer
aUniqueStrings
aJITFrame
)
;
return
json
;
}
void
JITFrameInfo
:
:
AddInfoForRange
(
uint64_t
aRangeStart
uint64_t
aRangeEnd
JSContext
*
aCx
const
std
:
:
function
<
void
(
const
std
:
:
function
<
void
(
void
*
)
>
&
)
>
&
aJITAddressProvider
)
{
if
(
aRangeStart
=
=
aRangeEnd
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
aRangeStart
<
aRangeEnd
)
;
if
(
!
mRanges
.
empty
(
)
)
{
const
JITFrameInfoForBufferRange
&
prevRange
=
mRanges
.
back
(
)
;
MOZ_RELEASE_ASSERT
(
prevRange
.
mRangeEnd
<
=
aRangeStart
"
Ranges
must
be
non
-
overlapping
and
added
in
-
order
.
"
)
;
}
using
JITFrameKey
=
JITFrameInfoForBufferRange
:
:
JITFrameKey
;
JITFrameInfoForBufferRange
:
:
JITAddressToJITFramesMap
jitAddressToJITFrameMap
;
JITFrameInfoForBufferRange
:
:
JITFrameToFrameJSONMap
jitFrameToFrameJSONMap
;
aJITAddressProvider
(
[
&
]
(
void
*
aJITAddress
)
{
auto
addressEntry
=
jitAddressToJITFrameMap
.
lookupForAdd
(
aJITAddress
)
;
if
(
!
addressEntry
)
{
Vector
<
JITFrameKey
>
jitFrameKeys
;
for
(
JS
:
:
ProfiledFrameHandle
handle
:
JS
:
:
GetProfiledFrames
(
aCx
aJITAddress
)
)
{
uint32_t
depth
=
jitFrameKeys
.
length
(
)
;
JITFrameKey
jitFrameKey
{
handle
.
canonicalAddress
(
)
depth
}
;
auto
frameEntry
=
jitFrameToFrameJSONMap
.
lookupForAdd
(
jitFrameKey
)
;
if
(
!
frameEntry
)
{
MOZ_RELEASE_ASSERT
(
jitFrameToFrameJSONMap
.
add
(
frameEntry
jitFrameKey
JSONForJITFrame
(
aCx
handle
*
mUniqueStrings
)
)
)
;
}
MOZ_RELEASE_ASSERT
(
jitFrameKeys
.
append
(
jitFrameKey
)
)
;
}
MOZ_RELEASE_ASSERT
(
jitAddressToJITFrameMap
.
add
(
addressEntry
aJITAddress
std
:
:
move
(
jitFrameKeys
)
)
)
;
}
}
)
;
MOZ_RELEASE_ASSERT
(
mRanges
.
append
(
JITFrameInfoForBufferRange
{
aRangeStart
aRangeEnd
std
:
:
move
(
jitAddressToJITFrameMap
)
std
:
:
move
(
jitFrameToFrameJSONMap
)
}
)
)
;
}
struct
ProfileSample
{
uint32_t
mStack
=
0
;
double
mTime
=
0
.
0
;
Maybe
<
double
>
mResponsiveness
;
RunningTimes
mRunningTimes
;
}
;
static
void
WriteDelta
(
AutoArraySchemaWriter
&
aSchemaWriter
uint32_t
aProperty
uint64_t
aDelta
)
{
aSchemaWriter
.
IntElement
(
aProperty
int64_t
(
aDelta
)
)
;
}
static
void
WriteSample
(
SpliceableJSONWriter
&
aWriter
const
ProfileSample
&
aSample
)
{
enum
Schema
:
uint32_t
{
STACK
=
0
TIME
=
1
EVENT_DELAY
=
2
#
define
RUNNING_TIME_SCHEMA
(
index
name
unit
jsonProperty
)
name
PROFILER_FOR_EACH_RUNNING_TIME
(
RUNNING_TIME_SCHEMA
)
#
undef
RUNNING_TIME_SCHEMA
}
;
AutoArraySchemaWriter
writer
(
aWriter
)
;
writer
.
IntElement
(
STACK
aSample
.
mStack
)
;
writer
.
TimeMsElement
(
TIME
aSample
.
mTime
)
;
if
(
aSample
.
mResponsiveness
.
isSome
(
)
)
{
writer
.
DoubleElement
(
EVENT_DELAY
*
aSample
.
mResponsiveness
)
;
}
#
define
RUNNING_TIME_STREAM
(
index
name
unit
jsonProperty
)
\
aSample
.
mRunningTimes
.
GetJson
#
#
name
#
#
unit
(
)
.
apply
(
\
[
&
writer
]
(
const
uint64_t
&
aValue
)
{
\
Write
#
#
unit
(
writer
name
aValue
)
;
\
}
)
;
PROFILER_FOR_EACH_RUNNING_TIME
(
RUNNING_TIME_STREAM
)
#
undef
RUNNING_TIME_STREAM
}
static
void
StreamMarkerAfterKind
(
ProfileBufferEntryReader
&
aER
ProcessStreamingContext
&
aProcessStreamingContext
)
{
ThreadStreamingContext
*
threadData
=
nullptr
;
mozilla
:
:
base_profiler_markers_detail
:
:
DeserializeAfterKindAndStream
(
aER
[
&
]
(
ProfilerThreadId
aThreadId
)
-
>
baseprofiler
:
:
SpliceableJSONWriter
*
{
threadData
=
aProcessStreamingContext
.
GetThreadStreamingContext
(
aThreadId
)
;
return
threadData
?
&
threadData
-
>
mMarkersDataWriter
:
nullptr
;
}
[
&
]
(
ProfileChunkedBuffer
&
aChunkedBuffer
)
{
ProfilerBacktrace
backtrace
(
"
"
&
aChunkedBuffer
)
;
MOZ_ASSERT
(
threadData
"
threadData
should
have
been
set
before
calling
here
"
)
;
backtrace
.
StreamJSON
(
threadData
-
>
mMarkersDataWriter
aProcessStreamingContext
.
ProcessStartTime
(
)
*
threadData
-
>
mUniqueStacks
)
;
}
[
&
]
(
mozilla
:
:
base_profiler_markers_detail
:
:
Streaming
:
:
DeserializerTag
aTag
)
{
MOZ_ASSERT
(
threadData
"
threadData
should
have
been
set
before
calling
here
"
)
;
size_t
payloadSize
=
aER
.
RemainingBytes
(
)
;
ProfileBufferEntryReader
:
:
DoubleSpanOfConstBytes
spans
=
aER
.
ReadSpans
(
payloadSize
)
;
if
(
MOZ_LIKELY
(
spans
.
IsSingleSpan
(
)
)
)
{
profiler
:
:
ffi
:
:
gecko_profiler_serialize_marker_for_tag
(
aTag
spans
.
mFirstOrOnly
.
Elements
(
)
payloadSize
&
threadData
-
>
mMarkersDataWriter
)
;
}
else
{
uint8_t
*
payloadBuffer
=
new
uint8_t
[
payloadSize
]
;
spans
.
CopyBytesTo
(
payloadBuffer
)
;
profiler
:
:
ffi
:
:
gecko_profiler_serialize_marker_for_tag
(
aTag
payloadBuffer
payloadSize
&
threadData
-
>
mMarkersDataWriter
)
;
delete
[
]
payloadBuffer
;
}
}
)
;
}
class
EntryGetter
{
public
:
explicit
EntryGetter
(
ProfileChunkedBuffer
:
:
Reader
&
aReader
mozilla
:
:
ProgressLogger
aProgressLogger
=
{
}
uint64_t
aInitialReadPos
=
0
ProcessStreamingContext
*
aStreamingContextForMarkers
=
nullptr
)
:
mStreamingContextForMarkers
(
aStreamingContextForMarkers
)
mBlockIt
(
aReader
.
At
(
ProfileBufferBlockIndex
:
:
CreateFromProfileBufferIndex
(
aInitialReadPos
)
)
)
mBlockItEnd
(
aReader
.
end
(
)
)
mRangeStart
(
mBlockIt
.
BufferRangeStart
(
)
.
ConvertToProfileBufferIndex
(
)
)
mRangeSize
(
double
(
mBlockIt
.
BufferRangeEnd
(
)
.
ConvertToProfileBufferIndex
(
)
-
mRangeStart
)
)
mProgressLogger
(
std
:
:
move
(
aProgressLogger
)
)
{
SetLocalProgress
(
ProgressLogger
:
:
NO_LOCATION_UPDATE
)
;
if
(
!
ReadLegacyOrEnd
(
)
)
{
Next
(
)
;
}
}
bool
Has
(
)
const
{
return
mBlockIt
!
=
mBlockItEnd
;
}
const
ProfileBufferEntry
&
Get
(
)
const
{
MOZ_ASSERT
(
Has
(
)
"
Caller
should
have
checked
Has
(
)
before
Get
(
)
"
)
;
return
mEntry
;
}
void
Next
(
)
{
MOZ_ASSERT
(
Has
(
)
"
Caller
should
have
checked
Has
(
)
before
Get
(
)
"
)
;
+
+
mBlockIt
;
ReadUntilLegacyOrEnd
(
)
;
}
ProfileChunkedBuffer
:
:
BlockIterator
Iterator
(
)
const
{
return
mBlockIt
;
}
void
RestartAfter
(
const
ProfileChunkedBuffer
:
:
BlockIterator
&
it
)
{
mBlockIt
=
it
;
if
(
!
Has
(
)
)
{
return
;
}
Next
(
)
;
}
ProfileBufferBlockIndex
CurBlockIndex
(
)
const
{
return
mBlockIt
.
CurrentBlockIndex
(
)
;
}
uint64_t
CurPos
(
)
const
{
return
CurBlockIndex
(
)
.
ConvertToProfileBufferIndex
(
)
;
}
void
SetLocalProgress
(
const
char
*
aLocation
)
{
mProgressLogger
.
SetLocalProgress
(
ProportionValue
{
double
(
CurBlockIndex
(
)
.
ConvertToProfileBufferIndex
(
)
-
mRangeStart
)
/
mRangeSize
}
aLocation
)
;
}
private
:
bool
ReadLegacyOrEnd
(
)
{
if
(
!
Has
(
)
)
{
return
true
;
}
ProfileBufferEntryReader
er
=
*
mBlockIt
;
auto
type
=
static_cast
<
ProfileBufferEntry
:
:
Kind
>
(
er
.
ReadObject
<
ProfileBufferEntry
:
:
KindUnderlyingType
>
(
)
)
;
MOZ_ASSERT
(
static_cast
<
ProfileBufferEntry
:
:
KindUnderlyingType
>
(
type
)
<
static_cast
<
ProfileBufferEntry
:
:
KindUnderlyingType
>
(
ProfileBufferEntry
:
:
Kind
:
:
MODERN_LIMIT
)
)
;
if
(
type
>
=
ProfileBufferEntry
:
:
Kind
:
:
LEGACY_LIMIT
)
{
if
(
type
=
=
ProfileBufferEntry
:
:
Kind
:
:
Marker
&
&
mStreamingContextForMarkers
)
{
StreamMarkerAfterKind
(
er
*
mStreamingContextForMarkers
)
;
SetLocalProgress
(
"
Processed
marker
"
)
;
}
er
.
SetRemainingBytes
(
0
)
;
return
false
;
}
er
=
*
mBlockIt
;
er
.
ReadBytes
(
&
mEntry
er
.
RemainingBytes
(
)
)
;
return
true
;
}
void
ReadUntilLegacyOrEnd
(
)
{
for
(
;
;
)
{
if
(
ReadLegacyOrEnd
(
)
)
{
break
;
}
+
+
mBlockIt
;
}
SetLocalProgress
(
ProgressLogger
:
:
NO_LOCATION_UPDATE
)
;
}
ProcessStreamingContext
*
const
mStreamingContextForMarkers
;
ProfileBufferEntry
mEntry
;
ProfileChunkedBuffer
:
:
BlockIterator
mBlockIt
;
const
ProfileChunkedBuffer
:
:
BlockIterator
mBlockItEnd
;
const
mozilla
:
:
ProfileBufferIndex
mRangeStart
;
const
double
mRangeSize
;
mozilla
:
:
ProgressLogger
mProgressLogger
;
}
;
#
define
ERROR_AND_CONTINUE
(
msg
)
\
{
\
fprintf
(
stderr
"
ProfileBuffer
parse
error
:
%
s
"
msg
)
;
\
MOZ_ASSERT
(
false
msg
)
;
\
continue
;
\
}
struct
StreamingParametersForThread
{
SpliceableJSONWriter
&
mWriter
;
UniqueStacks
&
mUniqueStacks
;
ThreadStreamingContext
:
:
PreviousStackState
&
mPreviousStackState
;
uint32_t
&
mPreviousStack
;
StreamingParametersForThread
(
SpliceableJSONWriter
&
aWriter
UniqueStacks
&
aUniqueStacks
ThreadStreamingContext
:
:
PreviousStackState
&
aPreviousStackState
uint32_t
&
aPreviousStack
)
:
mWriter
(
aWriter
)
mUniqueStacks
(
aUniqueStacks
)
mPreviousStackState
(
aPreviousStackState
)
mPreviousStack
(
aPreviousStack
)
{
}
}
;
template
<
typename
GetStreamingParametersForThreadCallback
>
ProfilerThreadId
ProfileBuffer
:
:
DoStreamSamplesAndMarkersToJSON
(
GetStreamingParametersForThreadCallback
&
&
aGetStreamingParametersForThreadCallback
double
aSinceTime
ProcessStreamingContext
*
aStreamingContextForMarkers
mozilla
:
:
ProgressLogger
aProgressLogger
)
const
{
UniquePtr
<
char
[
]
>
dynStrBuf
=
MakeUnique
<
char
[
]
>
(
kMaxFrameKeyLength
)
;
return
mEntries
.
Read
(
[
&
]
(
ProfileChunkedBuffer
:
:
Reader
*
aReader
)
{
MOZ_ASSERT
(
aReader
"
ProfileChunkedBuffer
cannot
be
out
-
of
-
session
when
sampler
is
"
"
running
"
)
;
ProfilerThreadId
processedThreadId
;
EntryGetter
e
(
*
aReader
std
:
:
move
(
aProgressLogger
)
0
aStreamingContextForMarkers
)
;
for
(
;
;
)
{
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsThreadId
(
)
)
{
break
;
}
e
.
Next
(
)
;
}
if
(
!
e
.
Has
(
)
)
{
break
;
}
MOZ_ASSERT
(
e
.
Get
(
)
.
IsThreadId
(
)
)
;
ProfilerThreadId
threadId
=
e
.
Get
(
)
.
GetThreadId
(
)
;
e
.
Next
(
)
;
Maybe
<
StreamingParametersForThread
>
streamingParameters
=
std
:
:
forward
<
GetStreamingParametersForThreadCallback
>
(
aGetStreamingParametersForThreadCallback
)
(
threadId
)
;
if
(
!
streamingParameters
)
{
continue
;
}
SpliceableJSONWriter
&
writer
=
streamingParameters
-
>
mWriter
;
UniqueStacks
&
uniqueStacks
=
streamingParameters
-
>
mUniqueStacks
;
ThreadStreamingContext
:
:
PreviousStackState
&
previousStackState
=
streamingParameters
-
>
mPreviousStackState
;
uint32_t
&
previousStack
=
streamingParameters
-
>
mPreviousStack
;
auto
ReadStack
=
[
&
]
(
EntryGetter
&
e
double
time
uint64_t
entryPosition
const
Maybe
<
double
>
&
unresponsiveDuration
const
RunningTimes
&
runningTimes
)
{
UniqueStacks
:
:
StackKey
stack
=
uniqueStacks
.
BeginStack
(
UniqueStacks
:
:
FrameKey
(
"
(
root
)
"
)
)
;
int
numFrames
=
0
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsNativeLeafAddr
(
)
)
{
numFrames
+
+
;
void
*
pc
=
e
.
Get
(
)
.
GetPtr
(
)
;
e
.
Next
(
)
;
nsAutoCString
functionNameOrAddress
=
uniqueStacks
.
FunctionNameOrAddress
(
pc
)
;
stack
=
uniqueStacks
.
AppendFrame
(
stack
UniqueStacks
:
:
FrameKey
(
functionNameOrAddress
.
get
(
)
)
)
;
}
else
if
(
e
.
Get
(
)
.
IsLabel
(
)
)
{
numFrames
+
+
;
const
char
*
label
=
e
.
Get
(
)
.
GetString
(
)
;
e
.
Next
(
)
;
using
FrameFlags
=
js
:
:
ProfilingStackFrame
:
:
Flags
;
uint32_t
frameFlags
=
0
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsFrameFlags
(
)
)
{
frameFlags
=
uint32_t
(
e
.
Get
(
)
.
GetUint64
(
)
)
;
e
.
Next
(
)
;
}
bool
relevantForJS
=
frameFlags
&
uint32_t
(
FrameFlags
:
:
RELEVANT_FOR_JS
)
;
bool
isBaselineInterp
=
frameFlags
&
uint32_t
(
FrameFlags
:
:
IS_BLINTERP_FRAME
)
;
size_t
i
=
0
;
dynStrBuf
[
0
]
=
'
\
0
'
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsDynamicStringFragment
(
)
)
{
char
chars
[
ProfileBufferEntry
:
:
kNumChars
]
;
e
.
Get
(
)
.
CopyCharsInto
(
chars
)
;
for
(
char
c
:
chars
)
{
if
(
i
<
kMaxFrameKeyLength
)
{
dynStrBuf
[
i
]
=
c
;
i
+
+
;
}
}
e
.
Next
(
)
;
}
else
{
break
;
}
}
dynStrBuf
[
kMaxFrameKeyLength
-
1
]
=
'
\
0
'
;
bool
hasDynamicString
=
(
i
!
=
0
)
;
nsAutoCStringN
<
1024
>
frameLabel
;
if
(
label
[
0
]
!
=
'
\
0
'
&
&
hasDynamicString
)
{
if
(
frameFlags
&
uint32_t
(
FrameFlags
:
:
STRING_TEMPLATE_METHOD
)
)
{
frameLabel
.
AppendPrintf
(
"
%
s
.
%
s
"
label
dynStrBuf
.
get
(
)
)
;
}
else
if
(
frameFlags
&
uint32_t
(
FrameFlags
:
:
STRING_TEMPLATE_GETTER
)
)
{
frameLabel
.
AppendPrintf
(
"
get
%
s
.
%
s
"
label
dynStrBuf
.
get
(
)
)
;
}
else
if
(
frameFlags
&
uint32_t
(
FrameFlags
:
:
STRING_TEMPLATE_SETTER
)
)
{
frameLabel
.
AppendPrintf
(
"
set
%
s
.
%
s
"
label
dynStrBuf
.
get
(
)
)
;
}
else
{
frameLabel
.
AppendPrintf
(
"
%
s
%
s
"
label
dynStrBuf
.
get
(
)
)
;
}
}
else
if
(
hasDynamicString
)
{
frameLabel
.
Append
(
dynStrBuf
.
get
(
)
)
;
}
else
{
frameLabel
.
Append
(
label
)
;
}
uint64_t
innerWindowID
=
0
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsInnerWindowID
(
)
)
{
innerWindowID
=
uint64_t
(
e
.
Get
(
)
.
GetUint64
(
)
)
;
e
.
Next
(
)
;
}
Maybe
<
unsigned
>
line
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsLineNumber
(
)
)
{
line
=
Some
(
unsigned
(
e
.
Get
(
)
.
GetInt
(
)
)
)
;
e
.
Next
(
)
;
}
Maybe
<
unsigned
>
column
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsColumnNumber
(
)
)
{
column
=
Some
(
unsigned
(
e
.
Get
(
)
.
GetInt
(
)
)
)
;
e
.
Next
(
)
;
}
Maybe
<
JS
:
:
ProfilingCategoryPair
>
categoryPair
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsCategoryPair
(
)
)
{
categoryPair
=
Some
(
JS
:
:
ProfilingCategoryPair
(
uint32_t
(
e
.
Get
(
)
.
GetInt
(
)
)
)
)
;
e
.
Next
(
)
;
}
stack
=
uniqueStacks
.
AppendFrame
(
stack
UniqueStacks
:
:
FrameKey
(
std
:
:
move
(
frameLabel
)
relevantForJS
isBaselineInterp
innerWindowID
line
column
categoryPair
)
)
;
}
else
if
(
e
.
Get
(
)
.
IsJitReturnAddr
(
)
)
{
numFrames
+
+
;
void
*
pc
=
e
.
Get
(
)
.
GetPtr
(
)
;
const
Maybe
<
Vector
<
UniqueStacks
:
:
FrameKey
>
>
&
frameKeys
=
uniqueStacks
.
LookupFramesForJITAddressFromBufferPos
(
pc
entryPosition
?
entryPosition
:
e
.
CurPos
(
)
)
;
MOZ_RELEASE_ASSERT
(
frameKeys
"
Attempting
to
stream
samples
for
a
buffer
range
"
"
for
which
we
don
'
t
have
JITFrameInfo
?
"
)
;
for
(
const
UniqueStacks
:
:
FrameKey
&
frameKey
:
*
frameKeys
)
{
stack
=
uniqueStacks
.
AppendFrame
(
stack
frameKey
)
;
}
e
.
Next
(
)
;
}
else
{
break
;
}
}
const
uint32_t
stackIndex
=
uniqueStacks
.
GetOrAddStackIndex
(
stack
)
;
previousStack
=
stackIndex
;
previousStackState
=
(
numFrames
=
=
0
)
?
ThreadStreamingContext
:
:
eStackWasEmpty
:
ThreadStreamingContext
:
:
eStackWasNotEmpty
;
processedThreadId
=
threadId
;
if
(
time
<
aSinceTime
)
{
return
;
}
if
(
numFrames
=
=
0
&
&
runningTimes
.
IsEmpty
(
)
)
{
return
;
}
WriteSample
(
writer
ProfileSample
{
stackIndex
time
unresponsiveDuration
runningTimes
}
)
;
}
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsTime
(
)
)
{
double
time
=
e
.
Get
(
)
.
GetDouble
(
)
;
e
.
Next
(
)
;
ReadStack
(
e
time
0
Nothing
{
}
RunningTimes
{
}
)
;
e
.
SetLocalProgress
(
"
Processed
sample
"
)
;
}
else
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsTimeBeforeCompactStack
(
)
)
{
double
time
=
e
.
Get
(
)
.
GetDouble
(
)
;
RunningTimes
runningTimes
;
Maybe
<
double
>
unresponsiveDuration
;
ProfileChunkedBuffer
:
:
BlockIterator
it
=
e
.
Iterator
(
)
;
for
(
;
;
)
{
+
+
it
;
if
(
it
.
IsAtEnd
(
)
)
{
break
;
}
ProfileBufferEntryReader
er
=
*
it
;
ProfileBufferEntry
:
:
Kind
kind
=
er
.
ReadObject
<
ProfileBufferEntry
:
:
Kind
>
(
)
;
if
(
kind
=
=
ProfileBufferEntry
:
:
Kind
:
:
RunningTimes
)
{
er
.
ReadIntoObject
(
runningTimes
)
;
continue
;
}
if
(
kind
=
=
ProfileBufferEntry
:
:
Kind
:
:
UnresponsiveDurationMs
)
{
unresponsiveDuration
=
Some
(
er
.
ReadObject
<
double
>
(
)
)
;
continue
;
}
if
(
kind
=
=
ProfileBufferEntry
:
:
Kind
:
:
CompactStack
)
{
ProfileChunkedBuffer
tempBuffer
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
WorkerChunkManager
(
)
)
;
er
.
ReadIntoObject
(
tempBuffer
)
;
tempBuffer
.
Read
(
[
&
]
(
ProfileChunkedBuffer
:
:
Reader
*
aReader
)
{
MOZ_ASSERT
(
aReader
"
Local
ProfileChunkedBuffer
cannot
be
out
-
of
-
session
"
)
;
EntryGetter
stackEntryGetter
(
*
aReader
)
;
ReadStack
(
stackEntryGetter
time
it
.
CurrentBlockIndex
(
)
.
ConvertToProfileBufferIndex
(
)
unresponsiveDuration
runningTimes
)
;
}
)
;
WorkerChunkManager
(
)
.
Reset
(
tempBuffer
.
GetAllChunks
(
)
)
;
break
;
}
if
(
kind
=
=
ProfileBufferEntry
:
:
Kind
:
:
Marker
&
&
aStreamingContextForMarkers
)
{
StreamMarkerAfterKind
(
er
*
aStreamingContextForMarkers
)
;
continue
;
}
MOZ_ASSERT
(
kind
>
=
ProfileBufferEntry
:
:
Kind
:
:
LEGACY_LIMIT
"
There
should
be
no
legacy
entries
between
"
"
TimeBeforeCompactStack
and
CompactStack
"
)
;
er
.
SetRemainingBytes
(
0
)
;
}
e
.
RestartAfter
(
it
)
;
e
.
SetLocalProgress
(
"
Processed
compact
sample
"
)
;
}
else
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsTimeBeforeSameSample
(
)
)
{
if
(
previousStackState
=
=
ThreadStreamingContext
:
:
eNoStackYet
)
{
continue
;
}
ProfileSample
sample
;
sample
.
mStack
=
previousStack
;
sample
.
mTime
=
e
.
Get
(
)
.
GetDouble
(
)
;
if
(
sample
.
mTime
<
aSinceTime
)
{
e
.
Next
(
)
;
continue
;
}
sample
.
mResponsiveness
=
Nothing
{
}
;
sample
.
mRunningTimes
.
Clear
(
)
;
ProfileChunkedBuffer
:
:
BlockIterator
it
=
e
.
Iterator
(
)
;
for
(
;
;
)
{
+
+
it
;
if
(
it
.
IsAtEnd
(
)
)
{
break
;
}
ProfileBufferEntryReader
er
=
*
it
;
ProfileBufferEntry
:
:
Kind
kind
=
er
.
ReadObject
<
ProfileBufferEntry
:
:
Kind
>
(
)
;
if
(
kind
=
=
ProfileBufferEntry
:
:
Kind
:
:
RunningTimes
)
{
er
.
ReadIntoObject
(
sample
.
mRunningTimes
)
;
continue
;
}
if
(
kind
=
=
ProfileBufferEntry
:
:
Kind
:
:
SameSample
)
{
if
(
previousStackState
=
=
ThreadStreamingContext
:
:
eStackWasEmpty
&
&
sample
.
mRunningTimes
.
IsEmpty
(
)
)
{
break
;
}
WriteSample
(
writer
sample
)
;
break
;
}
if
(
kind
=
=
ProfileBufferEntry
:
:
Kind
:
:
Marker
&
&
aStreamingContextForMarkers
)
{
StreamMarkerAfterKind
(
er
*
aStreamingContextForMarkers
)
;
continue
;
}
MOZ_ASSERT
(
kind
>
=
ProfileBufferEntry
:
:
Kind
:
:
LEGACY_LIMIT
"
There
should
be
no
legacy
entries
between
"
"
TimeBeforeSameSample
and
SameSample
"
)
;
er
.
SetRemainingBytes
(
0
)
;
}
e
.
RestartAfter
(
it
)
;
e
.
SetLocalProgress
(
"
Processed
repeated
sample
"
)
;
}
else
{
ERROR_AND_CONTINUE
(
"
expected
a
Time
entry
"
)
;
}
}
return
processedThreadId
;
}
)
;
}
ProfilerThreadId
ProfileBuffer
:
:
StreamSamplesToJSON
(
SpliceableJSONWriter
&
aWriter
ProfilerThreadId
aThreadId
double
aSinceTime
UniqueStacks
&
aUniqueStacks
mozilla
:
:
ProgressLogger
aProgressLogger
)
const
{
ThreadStreamingContext
:
:
PreviousStackState
previousStackState
=
ThreadStreamingContext
:
:
eNoStackYet
;
uint32_t
stack
=
0u
;
#
ifdef
DEBUG
int
processedCount
=
0
;
#
endif
return
DoStreamSamplesAndMarkersToJSON
(
[
&
]
(
ProfilerThreadId
aReadThreadId
)
{
Maybe
<
StreamingParametersForThread
>
streamingParameters
;
#
ifdef
DEBUG
+
+
processedCount
;
MOZ_ASSERT
(
aThreadId
.
IsSpecified
(
)
|
|
(
processedCount
=
=
1
&
&
aReadThreadId
.
IsSpecified
(
)
)
"
Unspecified
aThreadId
should
only
be
used
with
1
-
sample
buffer
"
)
;
#
endif
if
(
!
aThreadId
.
IsSpecified
(
)
|
|
aThreadId
=
=
aReadThreadId
)
{
streamingParameters
.
emplace
(
aWriter
aUniqueStacks
previousStackState
stack
)
;
}
return
streamingParameters
;
}
aSinceTime
nullptr
std
:
:
move
(
aProgressLogger
)
)
;
}
void
ProfileBuffer
:
:
StreamSamplesAndMarkersToJSON
(
ProcessStreamingContext
&
aProcessStreamingContext
mozilla
:
:
ProgressLogger
aProgressLogger
)
const
{
(
void
)
DoStreamSamplesAndMarkersToJSON
(
[
&
]
(
ProfilerThreadId
aReadThreadId
)
{
Maybe
<
StreamingParametersForThread
>
streamingParameters
;
ThreadStreamingContext
*
threadData
=
aProcessStreamingContext
.
GetThreadStreamingContext
(
aReadThreadId
)
;
if
(
threadData
)
{
streamingParameters
.
emplace
(
threadData
-
>
mSamplesDataWriter
*
threadData
-
>
mUniqueStacks
threadData
-
>
mPreviousStackState
threadData
-
>
mPreviousStack
)
;
}
return
streamingParameters
;
}
aProcessStreamingContext
.
GetSinceTime
(
)
&
aProcessStreamingContext
std
:
:
move
(
aProgressLogger
)
)
;
}
void
ProfileBuffer
:
:
AddJITInfoForRange
(
uint64_t
aRangeStart
ProfilerThreadId
aThreadId
JSContext
*
aContext
JITFrameInfo
&
aJITFrameInfo
mozilla
:
:
ProgressLogger
aProgressLogger
)
const
{
MOZ_RELEASE_ASSERT
(
aContext
)
;
aRangeStart
=
std
:
:
max
(
aRangeStart
BufferRangeStart
(
)
)
;
aJITFrameInfo
.
AddInfoForRange
(
aRangeStart
BufferRangeEnd
(
)
aContext
[
&
]
(
const
std
:
:
function
<
void
(
void
*
)
>
&
aJITAddressConsumer
)
{
mEntries
.
Read
(
[
&
]
(
ProfileChunkedBuffer
:
:
Reader
*
aReader
)
{
MOZ_ASSERT
(
aReader
"
ProfileChunkedBuffer
cannot
be
out
-
of
-
session
when
"
"
sampler
is
running
"
)
;
EntryGetter
e
(
*
aReader
std
:
:
move
(
aProgressLogger
)
aRangeStart
)
;
while
(
true
)
{
while
(
e
.
Has
(
)
&
&
!
e
.
Get
(
)
.
IsThreadId
(
)
)
{
e
.
Next
(
)
;
}
if
(
!
e
.
Has
(
)
)
{
break
;
}
MOZ_ASSERT
(
e
.
Get
(
)
.
IsThreadId
(
)
)
;
ProfilerThreadId
threadId
=
e
.
Get
(
)
.
GetThreadId
(
)
;
e
.
Next
(
)
;
if
(
threadId
!
=
aThreadId
)
{
continue
;
}
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsTime
(
)
)
{
e
.
Next
(
)
;
while
(
e
.
Has
(
)
&
&
!
e
.
Get
(
)
.
IsThreadId
(
)
)
{
if
(
e
.
Get
(
)
.
IsJitReturnAddr
(
)
)
{
aJITAddressConsumer
(
e
.
Get
(
)
.
GetPtr
(
)
)
;
}
e
.
Next
(
)
;
}
}
else
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsTimeBeforeCompactStack
(
)
)
{
ProfileChunkedBuffer
:
:
BlockIterator
it
=
e
.
Iterator
(
)
;
for
(
;
;
)
{
+
+
it
;
if
(
it
.
IsAtEnd
(
)
)
{
break
;
}
ProfileBufferEntryReader
er
=
*
it
;
ProfileBufferEntry
:
:
Kind
kind
=
er
.
ReadObject
<
ProfileBufferEntry
:
:
Kind
>
(
)
;
if
(
kind
=
=
ProfileBufferEntry
:
:
Kind
:
:
CompactStack
)
{
ProfileChunkedBuffer
tempBuffer
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
WorkerChunkManager
(
)
)
;
er
.
ReadIntoObject
(
tempBuffer
)
;
tempBuffer
.
Read
(
[
&
]
(
ProfileChunkedBuffer
:
:
Reader
*
aReader
)
{
MOZ_ASSERT
(
aReader
"
Local
ProfileChunkedBuffer
cannot
be
out
-
of
-
session
"
)
;
EntryGetter
stackEntryGetter
(
*
aReader
)
;
while
(
stackEntryGetter
.
Has
(
)
)
{
if
(
stackEntryGetter
.
Get
(
)
.
IsJitReturnAddr
(
)
)
{
aJITAddressConsumer
(
stackEntryGetter
.
Get
(
)
.
GetPtr
(
)
)
;
}
stackEntryGetter
.
Next
(
)
;
}
}
)
;
WorkerChunkManager
(
)
.
Reset
(
tempBuffer
.
GetAllChunks
(
)
)
;
break
;
}
MOZ_ASSERT
(
kind
>
=
ProfileBufferEntry
:
:
Kind
:
:
LEGACY_LIMIT
"
There
should
be
no
legacy
entries
between
"
"
TimeBeforeCompactStack
and
CompactStack
"
)
;
er
.
SetRemainingBytes
(
0
)
;
}
e
.
Next
(
)
;
}
else
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsTimeBeforeSameSample
(
)
)
{
}
else
{
ERROR_AND_CONTINUE
(
"
expected
a
Time
entry
"
)
;
}
}
}
)
;
}
)
;
}
void
ProfileBuffer
:
:
StreamMarkersToJSON
(
SpliceableJSONWriter
&
aWriter
ProfilerThreadId
aThreadId
const
TimeStamp
&
aProcessStartTime
double
aSinceTime
UniqueStacks
&
aUniqueStacks
mozilla
:
:
ProgressLogger
aProgressLogger
)
const
{
mEntries
.
ReadEach
(
[
&
]
(
ProfileBufferEntryReader
&
aER
)
{
auto
type
=
static_cast
<
ProfileBufferEntry
:
:
Kind
>
(
aER
.
ReadObject
<
ProfileBufferEntry
:
:
KindUnderlyingType
>
(
)
)
;
MOZ_ASSERT
(
static_cast
<
ProfileBufferEntry
:
:
KindUnderlyingType
>
(
type
)
<
static_cast
<
ProfileBufferEntry
:
:
KindUnderlyingType
>
(
ProfileBufferEntry
:
:
Kind
:
:
MODERN_LIMIT
)
)
;
if
(
type
=
=
ProfileBufferEntry
:
:
Kind
:
:
Marker
)
{
mozilla
:
:
base_profiler_markers_detail
:
:
DeserializeAfterKindAndStream
(
aER
[
&
]
(
const
ProfilerThreadId
&
aMarkerThreadId
)
{
return
(
!
aThreadId
.
IsSpecified
(
)
|
|
aMarkerThreadId
=
=
aThreadId
)
?
&
aWriter
:
nullptr
;
}
[
&
]
(
ProfileChunkedBuffer
&
aChunkedBuffer
)
{
ProfilerBacktrace
backtrace
(
"
"
&
aChunkedBuffer
)
;
backtrace
.
StreamJSON
(
aWriter
aProcessStartTime
aUniqueStacks
)
;
}
[
&
]
(
mozilla
:
:
base_profiler_markers_detail
:
:
Streaming
:
:
DeserializerTag
aTag
)
{
size_t
payloadSize
=
aER
.
RemainingBytes
(
)
;
ProfileBufferEntryReader
:
:
DoubleSpanOfConstBytes
spans
=
aER
.
ReadSpans
(
payloadSize
)
;
if
(
MOZ_LIKELY
(
spans
.
IsSingleSpan
(
)
)
)
{
profiler
:
:
ffi
:
:
gecko_profiler_serialize_marker_for_tag
(
aTag
spans
.
mFirstOrOnly
.
Elements
(
)
payloadSize
&
aWriter
)
;
}
else
{
uint8_t
*
payloadBuffer
=
new
uint8_t
[
payloadSize
]
;
spans
.
CopyBytesTo
(
payloadBuffer
)
;
profiler
:
:
ffi
:
:
gecko_profiler_serialize_marker_for_tag
(
aTag
payloadBuffer
payloadSize
&
aWriter
)
;
delete
[
]
payloadBuffer
;
}
}
)
;
}
else
{
aER
.
SetRemainingBytes
(
0
)
;
}
}
)
;
}
void
ProfileBuffer
:
:
StreamProfilerOverheadToJSON
(
SpliceableJSONWriter
&
aWriter
const
TimeStamp
&
aProcessStartTime
double
aSinceTime
mozilla
:
:
ProgressLogger
aProgressLogger
)
const
{
mEntries
.
Read
(
[
&
]
(
ProfileChunkedBuffer
:
:
Reader
*
aReader
)
{
MOZ_ASSERT
(
aReader
"
ProfileChunkedBuffer
cannot
be
out
-
of
-
session
when
sampler
is
"
"
running
"
)
;
EntryGetter
e
(
*
aReader
std
:
:
move
(
aProgressLogger
)
)
;
enum
Schema
:
uint32_t
{
TIME
=
0
LOCKING
=
1
MARKER_CLEANING
=
2
COUNTERS
=
3
THREADS
=
4
}
;
aWriter
.
StartObjectProperty
(
"
profilerOverhead
"
)
;
aWriter
.
StartObjectProperty
(
"
samples
"
)
;
{
JSONSchemaWriter
schema
(
aWriter
)
;
schema
.
WriteField
(
"
time
"
)
;
schema
.
WriteField
(
"
locking
"
)
;
schema
.
WriteField
(
"
expiredMarkerCleaning
"
)
;
schema
.
WriteField
(
"
counters
"
)
;
schema
.
WriteField
(
"
threads
"
)
;
}
aWriter
.
StartArrayProperty
(
"
data
"
)
;
double
firstTime
=
0
.
0
;
double
lastTime
=
0
.
0
;
ProfilerStats
intervals
overheads
lockings
cleanings
counters
threads
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsProfilerOverheadTime
(
)
)
{
double
time
=
e
.
Get
(
)
.
GetDouble
(
)
;
if
(
time
>
=
aSinceTime
)
{
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsProfilerOverheadDuration
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
ProfilerOverheadDuration
entry
after
"
"
ProfilerOverheadTime
"
)
;
}
double
locking
=
e
.
Get
(
)
.
GetDouble
(
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsProfilerOverheadDuration
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
ProfilerOverheadDuration
entry
after
"
"
ProfilerOverheadTime
ProfilerOverheadDuration
"
)
;
}
double
cleaning
=
e
.
Get
(
)
.
GetDouble
(
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsProfilerOverheadDuration
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
ProfilerOverheadDuration
entry
after
"
"
ProfilerOverheadTime
ProfilerOverheadDuration
*
2
"
)
;
}
double
counter
=
e
.
Get
(
)
.
GetDouble
(
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsProfilerOverheadDuration
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
ProfilerOverheadDuration
entry
after
"
"
ProfilerOverheadTime
ProfilerOverheadDuration
*
3
"
)
;
}
double
thread
=
e
.
Get
(
)
.
GetDouble
(
)
;
if
(
firstTime
=
=
0
.
0
)
{
firstTime
=
time
;
}
else
{
intervals
.
Count
(
time
-
lastTime
)
;
}
lastTime
=
time
;
overheads
.
Count
(
locking
+
cleaning
+
counter
+
thread
)
;
lockings
.
Count
(
locking
)
;
cleanings
.
Count
(
cleaning
)
;
counters
.
Count
(
counter
)
;
threads
.
Count
(
thread
)
;
AutoArraySchemaWriter
writer
(
aWriter
)
;
writer
.
TimeMsElement
(
TIME
time
)
;
writer
.
DoubleElement
(
LOCKING
locking
)
;
writer
.
DoubleElement
(
MARKER_CLEANING
cleaning
)
;
writer
.
DoubleElement
(
COUNTERS
counter
)
;
writer
.
DoubleElement
(
THREADS
thread
)
;
}
}
e
.
Next
(
)
;
}
aWriter
.
EndArray
(
)
;
aWriter
.
EndObject
(
)
;
if
(
intervals
.
n
>
0
)
{
aWriter
.
StartObjectProperty
(
"
statistics
"
)
;
aWriter
.
DoubleProperty
(
"
profiledDuration
"
lastTime
-
firstTime
)
;
aWriter
.
IntProperty
(
"
samplingCount
"
overheads
.
n
)
;
aWriter
.
DoubleProperty
(
"
overheadDurations
"
overheads
.
sum
)
;
aWriter
.
DoubleProperty
(
"
overheadPercentage
"
overheads
.
sum
/
(
lastTime
-
firstTime
)
)
;
#
define
PROFILER_STATS
(
name
var
)
\
aWriter
.
DoubleProperty
(
"
mean
"
name
(
var
)
.
sum
/
(
var
)
.
n
)
;
\
aWriter
.
DoubleProperty
(
"
min
"
name
(
var
)
.
min
)
;
\
aWriter
.
DoubleProperty
(
"
max
"
name
(
var
)
.
max
)
;
PROFILER_STATS
(
"
Interval
"
intervals
)
;
PROFILER_STATS
(
"
Overhead
"
overheads
)
;
PROFILER_STATS
(
"
Lockings
"
lockings
)
;
PROFILER_STATS
(
"
Cleaning
"
cleanings
)
;
PROFILER_STATS
(
"
Counter
"
counters
)
;
PROFILER_STATS
(
"
Thread
"
threads
)
;
#
undef
PROFILER_STATS
aWriter
.
EndObject
(
)
;
}
aWriter
.
EndObject
(
)
;
}
)
;
}
struct
CounterKeyedSample
{
double
mTime
;
uint64_t
mNumber
;
int64_t
mCount
;
}
;
using
CounterKeyedSamples
=
Vector
<
CounterKeyedSample
>
;
static
LazyLogModule
sFuzzyfoxLog
(
"
Fuzzyfox
"
)
;
using
CounterMap
=
HashMap
<
uint64_t
CounterKeyedSamples
>
;
template
<
typename
HashM
typename
Key
>
static
auto
&
LookupOrAdd
(
HashM
&
aMap
Key
&
&
aKey
)
{
auto
addPtr
=
aMap
.
lookupForAdd
(
aKey
)
;
if
(
!
addPtr
)
{
MOZ_RELEASE_ASSERT
(
aMap
.
add
(
addPtr
std
:
:
forward
<
Key
>
(
aKey
)
typename
HashM
:
:
Entry
:
:
ValueType
{
}
)
)
;
MOZ_ASSERT
(
!
!
addPtr
)
;
}
return
addPtr
-
>
value
(
)
;
}
void
ProfileBuffer
:
:
StreamCountersToJSON
(
SpliceableJSONWriter
&
aWriter
const
TimeStamp
&
aProcessStartTime
double
aSinceTime
mozilla
:
:
ProgressLogger
aProgressLogger
)
const
{
mEntries
.
Read
(
[
&
]
(
ProfileChunkedBuffer
:
:
Reader
*
aReader
)
{
MOZ_ASSERT
(
aReader
"
ProfileChunkedBuffer
cannot
be
out
-
of
-
session
when
sampler
is
"
"
running
"
)
;
EntryGetter
e
(
*
aReader
std
:
:
move
(
aProgressLogger
)
)
;
enum
Schema
:
uint32_t
{
TIME
=
0
NUMBER
=
1
COUNT
=
2
}
;
HashMap
<
void
*
CounterMap
>
counters
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsCounterId
(
)
)
{
void
*
id
=
e
.
Get
(
)
.
GetPtr
(
)
;
CounterMap
&
counter
=
LookupOrAdd
(
counters
id
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsTime
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
Time
entry
"
)
;
}
double
time
=
e
.
Get
(
)
.
GetDouble
(
)
;
e
.
Next
(
)
;
if
(
time
>
=
aSinceTime
)
{
while
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsCounterKey
(
)
)
{
uint64_t
key
=
e
.
Get
(
)
.
GetUint64
(
)
;
CounterKeyedSamples
&
data
=
LookupOrAdd
(
counter
key
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsCount
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
Count
entry
"
)
;
}
int64_t
count
=
e
.
Get
(
)
.
GetUint64
(
)
;
e
.
Next
(
)
;
uint64_t
number
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsNumber
(
)
)
{
number
=
0
;
}
else
{
number
=
e
.
Get
(
)
.
GetInt64
(
)
;
e
.
Next
(
)
;
}
CounterKeyedSample
sample
=
{
time
number
count
}
;
MOZ_RELEASE_ASSERT
(
data
.
append
(
sample
)
)
;
}
}
else
{
}
}
else
{
e
.
Next
(
)
;
}
}
if
(
counters
.
count
(
)
=
=
0
)
{
return
;
}
aWriter
.
StartArrayProperty
(
"
counters
"
)
;
for
(
auto
iter
=
counters
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
CounterMap
&
counter
=
iter
.
get
(
)
.
value
(
)
;
const
BaseProfilerCount
*
base_counter
=
static_cast
<
const
BaseProfilerCount
*
>
(
iter
.
get
(
)
.
key
(
)
)
;
aWriter
.
Start
(
)
;
aWriter
.
StringProperty
(
"
name
"
MakeStringSpan
(
base_counter
-
>
mLabel
)
)
;
aWriter
.
StringProperty
(
"
category
"
MakeStringSpan
(
base_counter
-
>
mCategory
)
)
;
aWriter
.
StringProperty
(
"
description
"
MakeStringSpan
(
base_counter
-
>
mDescription
)
)
;
aWriter
.
StartArrayProperty
(
"
sample_groups
"
)
;
for
(
auto
counter_iter
=
counter
.
iter
(
)
;
!
counter_iter
.
done
(
)
;
counter_iter
.
next
(
)
)
{
CounterKeyedSamples
&
samples
=
counter_iter
.
get
(
)
.
value
(
)
;
uint64_t
key
=
counter_iter
.
get
(
)
.
key
(
)
;
size_t
size
=
samples
.
length
(
)
;
if
(
size
=
=
0
)
{
continue
;
}
aWriter
.
StartObjectElement
(
)
;
{
aWriter
.
IntProperty
(
"
id
"
static_cast
<
int64_t
>
(
key
)
)
;
aWriter
.
StartObjectProperty
(
"
samples
"
)
;
{
JSONSchemaWriter
schema
(
aWriter
)
;
schema
.
WriteField
(
"
time
"
)
;
schema
.
WriteField
(
"
number
"
)
;
schema
.
WriteField
(
"
count
"
)
;
}
aWriter
.
StartArrayProperty
(
"
data
"
)
;
double
previousSkippedTime
=
0
.
0
;
uint64_t
previousNumber
=
0
;
int64_t
previousCount
=
0
;
for
(
size_t
i
=
0
;
i
<
size
;
i
+
+
)
{
if
(
i
=
=
0
|
|
i
=
=
size
-
1
|
|
samples
[
i
]
.
mNumber
!
=
previousNumber
|
|
samples
[
i
]
.
mCount
!
=
previousCount
|
|
(
i
>
=
2
&
&
(
samples
[
i
-
2
]
.
mNumber
!
=
previousNumber
|
|
samples
[
i
-
2
]
.
mCount
!
=
previousCount
)
)
)
{
if
(
i
!
=
0
&
&
samples
[
i
]
.
mTime
>
=
samples
[
i
-
1
]
.
mTime
)
{
MOZ_LOG
(
sFuzzyfoxLog
mozilla
:
:
LogLevel
:
:
Error
(
"
Fuzzyfox
Profiler
Assertion
:
%
f
>
=
%
f
"
samples
[
i
]
.
mTime
samples
[
i
-
1
]
.
mTime
)
)
;
}
MOZ_ASSERT
(
i
=
=
0
|
|
samples
[
i
]
.
mTime
>
=
samples
[
i
-
1
]
.
mTime
)
;
MOZ_ASSERT
(
samples
[
i
]
.
mNumber
>
=
previousNumber
)
;
MOZ_ASSERT
(
samples
[
i
]
.
mNumber
-
previousNumber
<
=
uint64_t
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
)
)
;
int64_t
numberDelta
=
static_cast
<
int64_t
>
(
samples
[
i
]
.
mNumber
-
previousNumber
)
;
int64_t
countDelta
=
samples
[
i
]
.
mCount
-
previousCount
;
if
(
previousSkippedTime
!
=
0
.
0
&
&
(
numberDelta
!
=
0
|
|
countDelta
!
=
0
)
)
{
AutoArraySchemaWriter
writer
(
aWriter
)
;
writer
.
TimeMsElement
(
TIME
previousSkippedTime
)
;
writer
.
IntElement
(
NUMBER
0
)
;
writer
.
IntElement
(
COUNT
0
)
;
}
AutoArraySchemaWriter
writer
(
aWriter
)
;
writer
.
TimeMsElement
(
TIME
samples
[
i
]
.
mTime
)
;
writer
.
IntElement
(
NUMBER
numberDelta
)
;
writer
.
IntElement
(
COUNT
countDelta
)
;
previousSkippedTime
=
0
.
0
;
previousNumber
=
samples
[
i
]
.
mNumber
;
previousCount
=
samples
[
i
]
.
mCount
;
}
else
{
previousSkippedTime
=
samples
[
i
]
.
mTime
;
}
}
aWriter
.
EndArray
(
)
;
aWriter
.
EndObject
(
)
;
}
aWriter
.
EndObject
(
)
;
}
aWriter
.
EndArray
(
)
;
aWriter
.
End
(
)
;
}
aWriter
.
EndArray
(
)
;
}
)
;
}
#
undef
ERROR_AND_CONTINUE
static
void
AddPausedRange
(
SpliceableJSONWriter
&
aWriter
const
char
*
aReason
const
Maybe
<
double
>
&
aStartTime
const
Maybe
<
double
>
&
aEndTime
)
{
aWriter
.
Start
(
)
;
if
(
aStartTime
)
{
aWriter
.
TimeDoubleMsProperty
(
"
startTime
"
*
aStartTime
)
;
}
else
{
aWriter
.
NullProperty
(
"
startTime
"
)
;
}
if
(
aEndTime
)
{
aWriter
.
TimeDoubleMsProperty
(
"
endTime
"
*
aEndTime
)
;
}
else
{
aWriter
.
NullProperty
(
"
endTime
"
)
;
}
aWriter
.
StringProperty
(
"
reason
"
MakeStringSpan
(
aReason
)
)
;
aWriter
.
End
(
)
;
}
void
ProfileBuffer
:
:
StreamPausedRangesToJSON
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
mozilla
:
:
ProgressLogger
aProgressLogger
)
const
{
mEntries
.
Read
(
[
&
]
(
ProfileChunkedBuffer
:
:
Reader
*
aReader
)
{
MOZ_ASSERT
(
aReader
"
ProfileChunkedBuffer
cannot
be
out
-
of
-
session
when
sampler
is
"
"
running
"
)
;
EntryGetter
e
(
*
aReader
aProgressLogger
.
CreateSubLoggerFromTo
(
1_pc
"
Streaming
pauses
.
.
.
"
99_pc
"
Streamed
pauses
"
)
)
;
Maybe
<
double
>
currentPauseStartTime
;
Maybe
<
double
>
currentCollectionStartTime
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsPause
(
)
)
{
currentPauseStartTime
=
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
;
}
else
if
(
e
.
Get
(
)
.
IsResume
(
)
)
{
AddPausedRange
(
aWriter
"
profiler
-
paused
"
currentPauseStartTime
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
)
;
currentPauseStartTime
=
Nothing
(
)
;
}
else
if
(
e
.
Get
(
)
.
IsCollectionStart
(
)
)
{
currentCollectionStartTime
=
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
;
}
else
if
(
e
.
Get
(
)
.
IsCollectionEnd
(
)
)
{
AddPausedRange
(
aWriter
"
collecting
"
currentCollectionStartTime
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
)
;
currentCollectionStartTime
=
Nothing
(
)
;
}
e
.
Next
(
)
;
}
if
(
currentPauseStartTime
)
{
AddPausedRange
(
aWriter
"
profiler
-
paused
"
currentPauseStartTime
Nothing
(
)
)
;
}
if
(
currentCollectionStartTime
)
{
AddPausedRange
(
aWriter
"
collecting
"
currentCollectionStartTime
Nothing
(
)
)
;
}
}
)
;
}
bool
ProfileBuffer
:
:
DuplicateLastSample
(
ProfilerThreadId
aThreadId
double
aSampleTimeMs
Maybe
<
uint64_t
>
&
aLastSample
const
RunningTimes
&
aRunningTimes
)
{
if
(
!
aLastSample
)
{
return
false
;
}
if
(
mEntries
.
IsIndexInCurrentChunk
(
ProfileBufferIndex
{
*
aLastSample
}
)
)
{
AUTO_PROFILER_STATS
(
DuplicateLastSample_SameSample
)
;
(
void
)
AddThreadIdEntry
(
aThreadId
)
;
AddEntry
(
ProfileBufferEntry
:
:
TimeBeforeSameSample
(
aSampleTimeMs
)
)
;
if
(
!
aRunningTimes
.
IsEmpty
(
)
)
{
mEntries
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
RunningTimes
aRunningTimes
)
;
}
mEntries
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
SameSample
)
;
return
true
;
}
AUTO_PROFILER_STATS
(
DuplicateLastSample_copy
)
;
ProfileChunkedBuffer
tempBuffer
(
ProfileChunkedBuffer
:
:
ThreadSafety
:
:
WithoutMutex
WorkerChunkManager
(
)
)
;
auto
retrieveWorkerChunk
=
MakeScopeExit
(
[
&
]
(
)
{
WorkerChunkManager
(
)
.
Reset
(
tempBuffer
.
GetAllChunks
(
)
)
;
}
)
;
const
bool
ok
=
mEntries
.
Read
(
[
&
]
(
ProfileChunkedBuffer
:
:
Reader
*
aReader
)
{
MOZ_ASSERT
(
aReader
"
ProfileChunkedBuffer
cannot
be
out
-
of
-
session
when
sampler
is
"
"
running
"
)
;
EntryGetter
e
(
*
aReader
ProgressLogger
{
}
*
aLastSample
)
;
if
(
e
.
CurPos
(
)
!
=
*
aLastSample
)
{
aLastSample
.
reset
(
)
;
return
false
;
}
MOZ_RELEASE_ASSERT
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsThreadId
(
)
&
&
e
.
Get
(
)
.
GetThreadId
(
)
=
=
aThreadId
)
;
e
.
Next
(
)
;
while
(
e
.
Has
(
)
)
{
switch
(
e
.
Get
(
)
.
GetKind
(
)
)
{
case
ProfileBufferEntry
:
:
Kind
:
:
Pause
:
case
ProfileBufferEntry
:
:
Kind
:
:
Resume
:
case
ProfileBufferEntry
:
:
Kind
:
:
PauseSampling
:
case
ProfileBufferEntry
:
:
Kind
:
:
ResumeSampling
:
case
ProfileBufferEntry
:
:
Kind
:
:
CollectionStart
:
case
ProfileBufferEntry
:
:
Kind
:
:
CollectionEnd
:
case
ProfileBufferEntry
:
:
Kind
:
:
ThreadId
:
case
ProfileBufferEntry
:
:
Kind
:
:
TimeBeforeSameSample
:
return
true
;
case
ProfileBufferEntry
:
:
Kind
:
:
Time
:
AddEntry
(
tempBuffer
ProfileBufferEntry
:
:
Time
(
aSampleTimeMs
)
)
;
break
;
case
ProfileBufferEntry
:
:
Kind
:
:
TimeBeforeCompactStack
:
{
AddEntry
(
tempBuffer
ProfileBufferEntry
:
:
TimeBeforeCompactStack
(
aSampleTimeMs
)
)
;
if
(
!
aRunningTimes
.
IsEmpty
(
)
)
{
tempBuffer
.
PutObjects
(
ProfileBufferEntry
:
:
Kind
:
:
RunningTimes
aRunningTimes
)
;
}
ProfileChunkedBuffer
:
:
BlockIterator
it
=
e
.
Iterator
(
)
;
for
(
;
;
)
{
+
+
it
;
if
(
it
.
IsAtEnd
(
)
)
{
break
;
}
ProfileBufferEntryReader
er
=
*
it
;
auto
kind
=
static_cast
<
ProfileBufferEntry
:
:
Kind
>
(
er
.
ReadObject
<
ProfileBufferEntry
:
:
KindUnderlyingType
>
(
)
)
;
MOZ_ASSERT
(
static_cast
<
ProfileBufferEntry
:
:
KindUnderlyingType
>
(
kind
)
<
static_cast
<
ProfileBufferEntry
:
:
KindUnderlyingType
>
(
ProfileBufferEntry
:
:
Kind
:
:
MODERN_LIMIT
)
)
;
if
(
kind
=
=
ProfileBufferEntry
:
:
Kind
:
:
CompactStack
)
{
er
=
*
it
;
auto
bytes
=
er
.
RemainingBytes
(
)
;
MOZ_ASSERT
(
bytes
<
ProfileBufferChunkManager
:
:
scExpectedMaximumStackSize
)
;
tempBuffer
.
Put
(
bytes
[
&
]
(
Maybe
<
ProfileBufferEntryWriter
>
&
aEW
)
{
MOZ_ASSERT
(
aEW
.
isSome
(
)
"
tempBuffer
cannot
be
out
-
of
-
session
"
)
;
aEW
-
>
WriteFromReader
(
er
bytes
)
;
}
)
;
break
;
}
MOZ_ASSERT
(
kind
>
=
ProfileBufferEntry
:
:
Kind
:
:
LEGACY_LIMIT
"
There
should
be
no
legacy
entries
between
"
"
TimeBeforeCompactStack
and
CompactStack
"
)
;
er
.
SetRemainingBytes
(
0
)
;
}
return
true
;
}
case
ProfileBufferEntry
:
:
Kind
:
:
CounterKey
:
case
ProfileBufferEntry
:
:
Kind
:
:
Number
:
case
ProfileBufferEntry
:
:
Kind
:
:
Count
:
break
;
case
ProfileBufferEntry
:
:
Kind
:
:
CounterId
:
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
Time
)
{
continue
;
}
break
;
case
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadTime
:
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadDuration
)
{
continue
;
}
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadDuration
)
{
continue
;
}
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadDuration
)
{
continue
;
}
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadDuration
)
{
continue
;
}
break
;
default
:
{
AddEntry
(
tempBuffer
e
.
Get
(
)
)
;
break
;
}
}
e
.
Next
(
)
;
}
return
true
;
}
)
;
if
(
!
ok
)
{
return
false
;
}
if
(
tempBuffer
.
GetState
(
)
.
mClearedBlockCount
!
=
0
)
{
aLastSample
.
reset
(
)
;
return
false
;
}
aLastSample
=
Some
(
AddThreadIdEntry
(
aThreadId
)
)
;
mEntries
.
AppendContents
(
tempBuffer
)
;
return
true
;
}
void
ProfileBuffer
:
:
DiscardSamplesBeforeTime
(
double
aTime
)
{
Unused
<
<
aTime
;
}
