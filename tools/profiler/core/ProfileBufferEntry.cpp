#
include
"
ProfileBufferEntry
.
h
"
#
include
"
platform
.
h
"
#
include
"
ProfileBuffer
.
h
"
#
include
"
js
/
TrackedOptimizationInfo
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StackWalk
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
<
ostream
>
using
namespace
mozilla
;
ProfileBufferEntry
:
:
ProfileBufferEntry
(
)
:
mKind
(
Kind
:
:
INVALID
)
mStorage
{
0
0
0
0
0
0
0
0
}
{
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
const
char
*
aString
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aString
sizeof
(
aString
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
char
aChars
[
kNumChars
]
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
aChars
kNumChars
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
void
*
aPtr
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aPtr
sizeof
(
aPtr
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
ProfilerMarker
*
aMarker
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aMarker
sizeof
(
aMarker
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
double
aDouble
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aDouble
sizeof
(
aDouble
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
int
aInt
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aInt
sizeof
(
aInt
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
int64_t
aInt64
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aInt64
sizeof
(
aInt64
)
)
;
}
ProfileBufferEntry
:
:
ProfileBufferEntry
(
Kind
aKind
uint64_t
aUint64
)
:
mKind
(
aKind
)
{
memcpy
(
mStorage
&
aUint64
sizeof
(
aUint64
)
)
;
}
const
char
*
ProfileBufferEntry
:
:
GetString
(
)
const
{
const
char
*
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
void
*
ProfileBufferEntry
:
:
GetPtr
(
)
const
{
void
*
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
ProfilerMarker
*
ProfileBufferEntry
:
:
GetMarker
(
)
const
{
ProfilerMarker
*
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
double
ProfileBufferEntry
:
:
GetDouble
(
)
const
{
double
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
int
ProfileBufferEntry
:
:
GetInt
(
)
const
{
int
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
int64_t
ProfileBufferEntry
:
:
GetInt64
(
)
const
{
int64_t
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
uint64_t
ProfileBufferEntry
:
:
GetUint64
(
)
const
{
uint64_t
result
;
memcpy
(
&
result
mStorage
sizeof
(
result
)
)
;
return
result
;
}
void
ProfileBufferEntry
:
:
CopyCharsInto
(
char
(
&
aOutArray
)
[
kNumChars
]
)
const
{
memcpy
(
aOutArray
mStorage
kNumChars
)
;
}
struct
TypeInfo
{
Maybe
<
nsCString
>
mKeyedBy
;
Maybe
<
nsCString
>
mName
;
Maybe
<
nsCString
>
mLocation
;
Maybe
<
unsigned
>
mLineNumber
;
}
;
template
<
typename
LambdaT
>
class
ForEachTrackedOptimizationTypeInfoLambdaOp
:
public
JS
:
:
ForEachTrackedOptimizationTypeInfoOp
{
public
:
explicit
ForEachTrackedOptimizationTypeInfoLambdaOp
(
LambdaT
&
&
aLambda
)
:
mLambda
(
aLambda
)
{
}
void
readType
(
const
char
*
keyedBy
const
char
*
name
const
char
*
location
const
Maybe
<
unsigned
>
&
lineno
)
override
{
TypeInfo
info
=
{
keyedBy
?
Some
(
nsCString
(
keyedBy
)
)
:
Nothing
(
)
name
?
Some
(
nsCString
(
name
)
)
:
Nothing
(
)
location
?
Some
(
nsCString
(
location
)
)
:
Nothing
(
)
lineno
}
;
mTypesetForUpcomingEntry
.
AppendElement
(
std
:
:
move
(
info
)
)
;
}
void
operator
(
)
(
JS
:
:
TrackedTypeSite
site
const
char
*
mirType
)
override
{
nsTArray
<
TypeInfo
>
typeset
(
std
:
:
move
(
mTypesetForUpcomingEntry
)
)
;
mLambda
(
site
mirType
typeset
)
;
}
private
:
nsTArray
<
TypeInfo
>
mTypesetForUpcomingEntry
;
LambdaT
mLambda
;
}
;
template
<
typename
LambdaT
>
ForEachTrackedOptimizationTypeInfoLambdaOp
<
LambdaT
>
MakeForEachTrackedOptimizationTypeInfoLambdaOp
(
LambdaT
&
&
aLambda
)
{
return
ForEachTrackedOptimizationTypeInfoLambdaOp
<
LambdaT
>
(
std
:
:
forward
<
LambdaT
>
(
aLambda
)
)
;
}
class
MOZ_RAII
AutoArraySchemaWriter
{
public
:
AutoArraySchemaWriter
(
SpliceableJSONWriter
&
aWriter
UniqueJSONStrings
&
aStrings
)
:
mJSONWriter
(
aWriter
)
mStrings
(
&
aStrings
)
mNextFreeIndex
(
0
)
{
mJSONWriter
.
StartArrayElement
(
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
}
explicit
AutoArraySchemaWriter
(
SpliceableJSONWriter
&
aWriter
)
:
mJSONWriter
(
aWriter
)
mStrings
(
nullptr
)
mNextFreeIndex
(
0
)
{
mJSONWriter
.
StartArrayElement
(
SpliceableJSONWriter
:
:
SingleLineStyle
)
;
}
~
AutoArraySchemaWriter
(
)
{
mJSONWriter
.
EndArray
(
)
;
}
template
<
typename
T
>
void
IntElement
(
uint32_t
aIndex
T
aValue
)
{
static_assert
(
!
IsSame
<
T
uint64_t
>
:
:
value
"
Narrowing
uint64
-
>
int64
conversion
not
allowed
"
)
;
FillUpTo
(
aIndex
)
;
mJSONWriter
.
IntElement
(
static_cast
<
int64_t
>
(
aValue
)
)
;
}
void
DoubleElement
(
uint32_t
aIndex
double
aValue
)
{
FillUpTo
(
aIndex
)
;
mJSONWriter
.
DoubleElement
(
aValue
)
;
}
void
BoolElement
(
uint32_t
aIndex
bool
aValue
)
{
FillUpTo
(
aIndex
)
;
mJSONWriter
.
BoolElement
(
aValue
)
;
}
void
StringElement
(
uint32_t
aIndex
const
char
*
aValue
)
{
MOZ_RELEASE_ASSERT
(
mStrings
)
;
FillUpTo
(
aIndex
)
;
mStrings
-
>
WriteElement
(
mJSONWriter
aValue
)
;
}
template
<
typename
LambdaT
>
void
FreeFormElement
(
uint32_t
aIndex
LambdaT
aCallback
)
{
MOZ_RELEASE_ASSERT
(
mStrings
)
;
FillUpTo
(
aIndex
)
;
aCallback
(
mJSONWriter
*
mStrings
)
;
}
private
:
void
FillUpTo
(
uint32_t
aIndex
)
{
MOZ_ASSERT
(
aIndex
>
=
mNextFreeIndex
)
;
mJSONWriter
.
NullElements
(
aIndex
-
mNextFreeIndex
)
;
mNextFreeIndex
=
aIndex
+
1
;
}
SpliceableJSONWriter
&
mJSONWriter
;
UniqueJSONStrings
*
mStrings
;
uint32_t
mNextFreeIndex
;
}
;
template
<
typename
LambdaT
>
class
ForEachTrackedOptimizationAttemptsLambdaOp
:
public
JS
:
:
ForEachTrackedOptimizationAttemptOp
{
public
:
explicit
ForEachTrackedOptimizationAttemptsLambdaOp
(
LambdaT
&
&
aLambda
)
:
mLambda
(
std
:
:
move
(
aLambda
)
)
{
}
void
operator
(
)
(
JS
:
:
TrackedStrategy
aStrategy
JS
:
:
TrackedOutcome
aOutcome
)
override
{
mLambda
(
aStrategy
aOutcome
)
;
}
private
:
LambdaT
mLambda
;
}
;
template
<
typename
LambdaT
>
ForEachTrackedOptimizationAttemptsLambdaOp
<
LambdaT
>
MakeForEachTrackedOptimizationAttemptsLambdaOp
(
LambdaT
&
&
aLambda
)
{
return
ForEachTrackedOptimizationAttemptsLambdaOp
<
LambdaT
>
(
std
:
:
move
(
aLambda
)
)
;
}
UniqueJSONStrings
:
:
UniqueJSONStrings
(
)
{
mStringTableWriter
.
StartBareList
(
)
;
}
UniqueJSONStrings
:
:
UniqueJSONStrings
(
const
UniqueJSONStrings
&
aOther
)
{
mStringTableWriter
.
StartBareList
(
)
;
uint32_t
count
=
mStringHashToIndexMap
.
count
(
)
;
if
(
count
!
=
0
)
{
MOZ_RELEASE_ASSERT
(
mStringHashToIndexMap
.
reserve
(
count
)
)
;
for
(
auto
iter
=
aOther
.
mStringHashToIndexMap
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
mStringHashToIndexMap
.
putNewInfallible
(
iter
.
get
(
)
.
key
(
)
iter
.
get
(
)
.
value
(
)
)
;
}
UniquePtr
<
char
[
]
>
stringTableJSON
=
aOther
.
mStringTableWriter
.
WriteFunc
(
)
-
>
CopyData
(
)
;
mStringTableWriter
.
Splice
(
stringTableJSON
.
get
(
)
)
;
}
}
uint32_t
UniqueJSONStrings
:
:
GetOrAddIndex
(
const
char
*
aStr
)
{
uint32_t
count
=
mStringHashToIndexMap
.
count
(
)
;
HashNumber
hash
=
HashString
(
aStr
)
;
auto
entry
=
mStringHashToIndexMap
.
lookupForAdd
(
hash
)
;
if
(
entry
)
{
MOZ_ASSERT
(
entry
-
>
value
(
)
<
count
)
;
return
entry
-
>
value
(
)
;
}
MOZ_RELEASE_ASSERT
(
mStringHashToIndexMap
.
add
(
entry
hash
count
)
)
;
mStringTableWriter
.
StringElement
(
aStr
)
;
return
count
;
}
UniqueStacks
:
:
StackKey
UniqueStacks
:
:
BeginStack
(
const
FrameKey
&
aFrame
)
{
return
StackKey
(
GetOrAddFrameIndex
(
aFrame
)
)
;
}
UniqueStacks
:
:
StackKey
UniqueStacks
:
:
AppendFrame
(
const
StackKey
&
aStack
const
FrameKey
&
aFrame
)
{
return
StackKey
(
aStack
GetOrAddStackIndex
(
aStack
)
GetOrAddFrameIndex
(
aFrame
)
)
;
}
JITFrameInfoForBufferRange
JITFrameInfoForBufferRange
:
:
Clone
(
)
const
{
JITFrameInfoForBufferRange
:
:
JITAddressToJITFramesMap
jitAddressToJITFramesMap
;
MOZ_RELEASE_ASSERT
(
jitAddressToJITFramesMap
.
reserve
(
mJITAddressToJITFramesMap
.
count
(
)
)
)
;
for
(
auto
iter
=
mJITAddressToJITFramesMap
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
const
mozilla
:
:
Vector
<
JITFrameKey
>
&
srcKeys
=
iter
.
get
(
)
.
value
(
)
;
mozilla
:
:
Vector
<
JITFrameKey
>
destKeys
;
MOZ_RELEASE_ASSERT
(
destKeys
.
appendAll
(
srcKeys
)
)
;
jitAddressToJITFramesMap
.
putNewInfallible
(
iter
.
get
(
)
.
key
(
)
std
:
:
move
(
destKeys
)
)
;
}
JITFrameInfoForBufferRange
:
:
JITFrameToFrameJSONMap
jitFrameToFrameJSONMap
;
MOZ_RELEASE_ASSERT
(
jitFrameToFrameJSONMap
.
reserve
(
mJITFrameToFrameJSONMap
.
count
(
)
)
)
;
for
(
auto
iter
=
mJITFrameToFrameJSONMap
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
jitFrameToFrameJSONMap
.
putNewInfallible
(
iter
.
get
(
)
.
key
(
)
iter
.
get
(
)
.
value
(
)
)
;
}
return
JITFrameInfoForBufferRange
{
mRangeStart
mRangeEnd
std
:
:
move
(
jitAddressToJITFramesMap
)
std
:
:
move
(
jitFrameToFrameJSONMap
)
}
;
}
JITFrameInfo
:
:
JITFrameInfo
(
const
JITFrameInfo
&
aOther
)
:
mUniqueStrings
(
MakeUnique
<
UniqueJSONStrings
>
(
*
aOther
.
mUniqueStrings
)
)
{
for
(
const
JITFrameInfoForBufferRange
&
range
:
aOther
.
mRanges
)
{
MOZ_RELEASE_ASSERT
(
mRanges
.
append
(
range
.
Clone
(
)
)
)
;
}
}
bool
UniqueStacks
:
:
FrameKey
:
:
NormalFrameData
:
:
operator
=
=
(
const
NormalFrameData
&
aOther
)
const
{
return
mLocation
=
=
aOther
.
mLocation
&
&
mRelevantForJS
=
=
aOther
.
mRelevantForJS
&
&
mLine
=
=
aOther
.
mLine
&
&
mColumn
=
=
aOther
.
mColumn
&
&
mCategoryPair
=
=
aOther
.
mCategoryPair
;
}
bool
UniqueStacks
:
:
FrameKey
:
:
JITFrameData
:
:
operator
=
=
(
const
JITFrameData
&
aOther
)
const
{
return
mCanonicalAddress
=
=
aOther
.
mCanonicalAddress
&
&
mDepth
=
=
aOther
.
mDepth
&
&
mRangeIndex
=
=
aOther
.
mRangeIndex
;
}
UniqueStacks
:
:
UniqueStacks
(
JITFrameInfo
&
&
aJITFrameInfo
)
:
mUniqueStrings
(
std
:
:
move
(
aJITFrameInfo
.
mUniqueStrings
)
)
mJITInfoRanges
(
std
:
:
move
(
aJITFrameInfo
.
mRanges
)
)
{
mFrameTableWriter
.
StartBareList
(
)
;
mStackTableWriter
.
StartBareList
(
)
;
}
uint32_t
UniqueStacks
:
:
GetOrAddStackIndex
(
const
StackKey
&
aStack
)
{
uint32_t
count
=
mStackToIndexMap
.
count
(
)
;
auto
entry
=
mStackToIndexMap
.
lookupForAdd
(
aStack
)
;
if
(
entry
)
{
MOZ_ASSERT
(
entry
-
>
value
(
)
<
count
)
;
return
entry
-
>
value
(
)
;
}
MOZ_RELEASE_ASSERT
(
mStackToIndexMap
.
add
(
entry
aStack
count
)
)
;
StreamStack
(
aStack
)
;
return
count
;
}
template
<
typename
RangeT
typename
PosT
>
struct
PositionInRangeComparator
final
{
bool
Equals
(
const
RangeT
&
aRange
PosT
aPos
)
const
{
return
aRange
.
mRangeStart
<
=
aPos
&
&
aPos
<
aRange
.
mRangeEnd
;
}
bool
LessThan
(
const
RangeT
&
aRange
PosT
aPos
)
const
{
return
aRange
.
mRangeEnd
<
=
aPos
;
}
}
;
Maybe
<
Vector
<
UniqueStacks
:
:
FrameKey
>
>
UniqueStacks
:
:
LookupFramesForJITAddressFromBufferPos
(
void
*
aJITAddress
uint64_t
aBufferPos
)
{
JITFrameInfoForBufferRange
*
rangeIter
=
std
:
:
lower_bound
(
mJITInfoRanges
.
begin
(
)
mJITInfoRanges
.
end
(
)
aBufferPos
[
]
(
const
JITFrameInfoForBufferRange
&
aRange
uint64_t
aPos
)
{
return
aRange
.
mRangeEnd
<
aPos
;
}
)
;
MOZ_RELEASE_ASSERT
(
rangeIter
!
=
mJITInfoRanges
.
end
(
)
&
&
rangeIter
-
>
mRangeStart
<
=
aBufferPos
&
&
aBufferPos
<
rangeIter
-
>
mRangeEnd
"
Buffer
position
of
jit
address
needs
to
be
in
one
of
the
ranges
"
)
;
using
JITFrameKey
=
JITFrameInfoForBufferRange
:
:
JITFrameKey
;
const
JITFrameInfoForBufferRange
&
jitFrameInfoRange
=
*
rangeIter
;
auto
jitFrameKeys
=
jitFrameInfoRange
.
mJITAddressToJITFramesMap
.
lookup
(
aJITAddress
)
;
if
(
!
jitFrameKeys
)
{
return
Nothing
(
)
;
}
Vector
<
FrameKey
>
frameKeys
;
MOZ_RELEASE_ASSERT
(
frameKeys
.
initCapacity
(
jitFrameKeys
-
>
value
(
)
.
length
(
)
)
)
;
for
(
const
JITFrameKey
&
jitFrameKey
:
jitFrameKeys
-
>
value
(
)
)
{
FrameKey
frameKey
(
jitFrameKey
.
mCanonicalAddress
jitFrameKey
.
mDepth
rangeIter
-
mJITInfoRanges
.
begin
(
)
)
;
uint32_t
index
=
mFrameToIndexMap
.
count
(
)
;
auto
entry
=
mFrameToIndexMap
.
lookupForAdd
(
frameKey
)
;
if
(
!
entry
)
{
auto
frameJSON
=
jitFrameInfoRange
.
mJITFrameToFrameJSONMap
.
lookup
(
jitFrameKey
)
;
MOZ_RELEASE_ASSERT
(
frameJSON
"
Should
have
cached
JSON
for
this
frame
"
)
;
mFrameTableWriter
.
Splice
(
frameJSON
-
>
value
(
)
.
get
(
)
)
;
MOZ_RELEASE_ASSERT
(
mFrameToIndexMap
.
add
(
entry
frameKey
index
)
)
;
}
MOZ_RELEASE_ASSERT
(
frameKeys
.
append
(
std
:
:
move
(
frameKey
)
)
)
;
}
return
Some
(
std
:
:
move
(
frameKeys
)
)
;
}
uint32_t
UniqueStacks
:
:
GetOrAddFrameIndex
(
const
FrameKey
&
aFrame
)
{
uint32_t
count
=
mFrameToIndexMap
.
count
(
)
;
auto
entry
=
mFrameToIndexMap
.
lookupForAdd
(
aFrame
)
;
if
(
entry
)
{
MOZ_ASSERT
(
entry
-
>
value
(
)
<
count
)
;
return
entry
-
>
value
(
)
;
}
MOZ_RELEASE_ASSERT
(
mFrameToIndexMap
.
add
(
entry
aFrame
count
)
)
;
StreamNonJITFrame
(
aFrame
)
;
return
count
;
}
void
UniqueStacks
:
:
SpliceFrameTableElements
(
SpliceableJSONWriter
&
aWriter
)
{
mFrameTableWriter
.
EndBareList
(
)
;
aWriter
.
TakeAndSplice
(
mFrameTableWriter
.
WriteFunc
(
)
)
;
}
void
UniqueStacks
:
:
SpliceStackTableElements
(
SpliceableJSONWriter
&
aWriter
)
{
mStackTableWriter
.
EndBareList
(
)
;
aWriter
.
TakeAndSplice
(
mStackTableWriter
.
WriteFunc
(
)
)
;
}
void
UniqueStacks
:
:
StreamStack
(
const
StackKey
&
aStack
)
{
enum
Schema
:
uint32_t
{
PREFIX
=
0
FRAME
=
1
}
;
AutoArraySchemaWriter
writer
(
mStackTableWriter
*
mUniqueStrings
)
;
if
(
aStack
.
mPrefixStackIndex
.
isSome
(
)
)
{
writer
.
IntElement
(
PREFIX
*
aStack
.
mPrefixStackIndex
)
;
}
writer
.
IntElement
(
FRAME
aStack
.
mFrameIndex
)
;
}
void
UniqueStacks
:
:
StreamNonJITFrame
(
const
FrameKey
&
aFrame
)
{
using
NormalFrameData
=
FrameKey
:
:
NormalFrameData
;
enum
Schema
:
uint32_t
{
LOCATION
=
0
RELEVANT_FOR_JS
=
1
IMPLEMENTATION
=
2
OPTIMIZATIONS
=
3
LINE
=
4
COLUMN
=
5
CATEGORY
=
6
SUBCATEGORY
=
7
}
;
AutoArraySchemaWriter
writer
(
mFrameTableWriter
*
mUniqueStrings
)
;
const
NormalFrameData
&
data
=
aFrame
.
mData
.
as
<
NormalFrameData
>
(
)
;
writer
.
StringElement
(
LOCATION
data
.
mLocation
.
get
(
)
)
;
writer
.
BoolElement
(
RELEVANT_FOR_JS
data
.
mRelevantForJS
)
;
if
(
data
.
mLine
.
isSome
(
)
)
{
writer
.
IntElement
(
LINE
*
data
.
mLine
)
;
}
if
(
data
.
mColumn
.
isSome
(
)
)
{
writer
.
IntElement
(
COLUMN
*
data
.
mColumn
)
;
}
if
(
data
.
mCategoryPair
.
isSome
(
)
)
{
const
JS
:
:
ProfilingCategoryPairInfo
&
info
=
JS
:
:
GetProfilingCategoryPairInfo
(
*
data
.
mCategoryPair
)
;
writer
.
IntElement
(
CATEGORY
uint32_t
(
info
.
mCategory
)
)
;
writer
.
IntElement
(
SUBCATEGORY
info
.
mSubcategoryIndex
)
;
}
}
static
void
StreamJITFrameOptimizations
(
SpliceableJSONWriter
&
aWriter
UniqueJSONStrings
&
aUniqueStrings
JSContext
*
aContext
const
JS
:
:
ProfiledFrameHandle
&
aJITFrame
)
{
aWriter
.
StartObjectElement
(
)
;
{
aWriter
.
StartArrayProperty
(
"
types
"
)
;
{
auto
op
=
MakeForEachTrackedOptimizationTypeInfoLambdaOp
(
[
&
]
(
JS
:
:
TrackedTypeSite
site
const
char
*
mirType
const
nsTArray
<
TypeInfo
>
&
typeset
)
{
aWriter
.
StartObjectElement
(
)
;
{
aUniqueStrings
.
WriteProperty
(
aWriter
"
site
"
JS
:
:
TrackedTypeSiteString
(
site
)
)
;
aUniqueStrings
.
WriteProperty
(
aWriter
"
mirType
"
mirType
)
;
if
(
!
typeset
.
IsEmpty
(
)
)
{
aWriter
.
StartArrayProperty
(
"
typeset
"
)
;
for
(
const
TypeInfo
&
typeInfo
:
typeset
)
{
aWriter
.
StartObjectElement
(
)
;
{
aUniqueStrings
.
WriteProperty
(
aWriter
"
keyedBy
"
typeInfo
.
mKeyedBy
-
>
get
(
)
)
;
if
(
typeInfo
.
mName
)
{
aUniqueStrings
.
WriteProperty
(
aWriter
"
name
"
typeInfo
.
mName
-
>
get
(
)
)
;
}
if
(
typeInfo
.
mLocation
)
{
aUniqueStrings
.
WriteProperty
(
aWriter
"
location
"
typeInfo
.
mLocation
-
>
get
(
)
)
;
}
if
(
typeInfo
.
mLineNumber
.
isSome
(
)
)
{
aWriter
.
IntProperty
(
"
line
"
*
typeInfo
.
mLineNumber
)
;
}
}
aWriter
.
EndObject
(
)
;
}
aWriter
.
EndArray
(
)
;
}
}
aWriter
.
EndObject
(
)
;
}
)
;
aJITFrame
.
forEachOptimizationTypeInfo
(
op
)
;
}
aWriter
.
EndArray
(
)
;
JS
:
:
Rooted
<
JSScript
*
>
script
(
aContext
)
;
jsbytecode
*
pc
;
aWriter
.
StartObjectProperty
(
"
attempts
"
)
;
{
{
JSONSchemaWriter
schema
(
aWriter
)
;
schema
.
WriteField
(
"
strategy
"
)
;
schema
.
WriteField
(
"
outcome
"
)
;
}
aWriter
.
StartArrayProperty
(
"
data
"
)
;
{
auto
op
=
MakeForEachTrackedOptimizationAttemptsLambdaOp
(
[
&
]
(
JS
:
:
TrackedStrategy
strategy
JS
:
:
TrackedOutcome
outcome
)
{
enum
Schema
:
uint32_t
{
STRATEGY
=
0
OUTCOME
=
1
}
;
AutoArraySchemaWriter
writer
(
aWriter
aUniqueStrings
)
;
writer
.
StringElement
(
STRATEGY
JS
:
:
TrackedStrategyString
(
strategy
)
)
;
writer
.
StringElement
(
OUTCOME
JS
:
:
TrackedOutcomeString
(
outcome
)
)
;
}
)
;
aJITFrame
.
forEachOptimizationAttempt
(
op
script
.
address
(
)
&
pc
)
;
}
aWriter
.
EndArray
(
)
;
}
aWriter
.
EndObject
(
)
;
if
(
JSAtom
*
name
=
js
:
:
GetPropertyNameFromPC
(
script
pc
)
)
{
char
buf
[
512
]
;
JS_PutEscapedFlatString
(
buf
ArrayLength
(
buf
)
js
:
:
AtomToFlatString
(
name
)
0
)
;
aUniqueStrings
.
WriteProperty
(
aWriter
"
propertyName
"
buf
)
;
}
unsigned
line
column
;
line
=
JS_PCToLineNumber
(
script
pc
&
column
)
;
aWriter
.
IntProperty
(
"
line
"
line
)
;
aWriter
.
IntProperty
(
"
column
"
column
)
;
}
aWriter
.
EndObject
(
)
;
}
static
void
StreamJITFrame
(
JSContext
*
aContext
SpliceableJSONWriter
&
aWriter
UniqueJSONStrings
&
aUniqueStrings
const
JS
:
:
ProfiledFrameHandle
&
aJITFrame
)
{
enum
Schema
:
uint32_t
{
LOCATION
=
0
RELEVANT_FOR_JS
=
1
IMPLEMENTATION
=
2
OPTIMIZATIONS
=
3
LINE
=
4
COLUMN
=
5
CATEGORY
=
6
SUBCATEGORY
=
7
}
;
AutoArraySchemaWriter
writer
(
aWriter
aUniqueStrings
)
;
writer
.
StringElement
(
LOCATION
aJITFrame
.
label
(
)
)
;
writer
.
BoolElement
(
RELEVANT_FOR_JS
false
)
;
JS
:
:
ProfilingFrameIterator
:
:
FrameKind
frameKind
=
aJITFrame
.
frameKind
(
)
;
MOZ_ASSERT
(
frameKind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Ion
|
|
frameKind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Baseline
)
;
writer
.
StringElement
(
IMPLEMENTATION
frameKind
=
=
JS
:
:
ProfilingFrameIterator
:
:
Frame_Ion
?
"
ion
"
:
"
baseline
"
)
;
if
(
aJITFrame
.
hasTrackedOptimizations
(
)
)
{
writer
.
FreeFormElement
(
OPTIMIZATIONS
[
&
]
(
SpliceableJSONWriter
&
aWriter
UniqueJSONStrings
&
aUniqueStrings
)
{
StreamJITFrameOptimizations
(
aWriter
aUniqueStrings
aContext
aJITFrame
)
;
}
)
;
}
const
JS
:
:
ProfilingCategoryPairInfo
&
info
=
JS
:
:
GetProfilingCategoryPairInfo
(
JS
:
:
ProfilingCategoryPair
:
:
JS
)
;
writer
.
IntElement
(
CATEGORY
uint32_t
(
info
.
mCategory
)
)
;
writer
.
IntElement
(
SUBCATEGORY
info
.
mSubcategoryIndex
)
;
}
struct
CStringWriteFunc
:
public
JSONWriteFunc
{
nsACString
&
mBuffer
;
explicit
CStringWriteFunc
(
nsACString
&
aBuffer
)
:
mBuffer
(
aBuffer
)
{
}
void
Write
(
const
char
*
aStr
)
override
{
mBuffer
.
Append
(
aStr
)
;
}
}
;
static
nsCString
JSONForJITFrame
(
JSContext
*
aContext
const
JS
:
:
ProfiledFrameHandle
&
aJITFrame
UniqueJSONStrings
&
aUniqueStrings
)
{
nsCString
json
;
SpliceableJSONWriter
writer
(
MakeUnique
<
CStringWriteFunc
>
(
json
)
)
;
StreamJITFrame
(
aContext
writer
aUniqueStrings
aJITFrame
)
;
return
json
;
}
void
JITFrameInfo
:
:
AddInfoForRange
(
uint64_t
aRangeStart
uint64_t
aRangeEnd
JSContext
*
aCx
const
std
:
:
function
<
void
(
const
std
:
:
function
<
void
(
void
*
)
>
&
)
>
&
aJITAddressProvider
)
{
if
(
aRangeStart
=
=
aRangeEnd
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
aRangeStart
<
aRangeEnd
)
;
if
(
!
mRanges
.
empty
(
)
)
{
const
JITFrameInfoForBufferRange
&
prevRange
=
mRanges
.
back
(
)
;
MOZ_RELEASE_ASSERT
(
prevRange
.
mRangeEnd
<
=
aRangeStart
"
Ranges
must
be
non
-
overlapping
and
added
in
-
order
.
"
)
;
}
using
JITFrameKey
=
JITFrameInfoForBufferRange
:
:
JITFrameKey
;
JITFrameInfoForBufferRange
:
:
JITAddressToJITFramesMap
jitAddressToJITFrameMap
;
JITFrameInfoForBufferRange
:
:
JITFrameToFrameJSONMap
jitFrameToFrameJSONMap
;
aJITAddressProvider
(
[
&
]
(
void
*
aJITAddress
)
{
auto
addressEntry
=
jitAddressToJITFrameMap
.
lookupForAdd
(
aJITAddress
)
;
if
(
!
addressEntry
)
{
Vector
<
JITFrameKey
>
jitFrameKeys
;
for
(
JS
:
:
ProfiledFrameHandle
handle
:
JS
:
:
GetProfiledFrames
(
aCx
aJITAddress
)
)
{
uint32_t
depth
=
jitFrameKeys
.
length
(
)
;
JITFrameKey
jitFrameKey
{
handle
.
canonicalAddress
(
)
depth
}
;
auto
frameEntry
=
jitFrameToFrameJSONMap
.
lookupForAdd
(
jitFrameKey
)
;
if
(
!
frameEntry
)
{
MOZ_RELEASE_ASSERT
(
jitFrameToFrameJSONMap
.
add
(
frameEntry
jitFrameKey
JSONForJITFrame
(
aCx
handle
*
mUniqueStrings
)
)
)
;
}
MOZ_RELEASE_ASSERT
(
jitFrameKeys
.
append
(
jitFrameKey
)
)
;
}
MOZ_RELEASE_ASSERT
(
jitAddressToJITFrameMap
.
add
(
addressEntry
aJITAddress
std
:
:
move
(
jitFrameKeys
)
)
)
;
}
}
)
;
MOZ_RELEASE_ASSERT
(
mRanges
.
append
(
JITFrameInfoForBufferRange
{
aRangeStart
aRangeEnd
std
:
:
move
(
jitAddressToJITFrameMap
)
std
:
:
move
(
jitFrameToFrameJSONMap
)
}
)
)
;
}
struct
ProfileSample
{
uint32_t
mStack
;
double
mTime
;
Maybe
<
double
>
mResponsiveness
;
Maybe
<
double
>
mRSS
;
Maybe
<
double
>
mUSS
;
}
;
static
void
WriteSample
(
SpliceableJSONWriter
&
aWriter
UniqueJSONStrings
&
aUniqueStrings
const
ProfileSample
&
aSample
)
{
enum
Schema
:
uint32_t
{
STACK
=
0
TIME
=
1
RESPONSIVENESS
=
2
RSS
=
3
USS
=
4
}
;
AutoArraySchemaWriter
writer
(
aWriter
aUniqueStrings
)
;
writer
.
IntElement
(
STACK
aSample
.
mStack
)
;
writer
.
DoubleElement
(
TIME
aSample
.
mTime
)
;
if
(
aSample
.
mResponsiveness
.
isSome
(
)
)
{
writer
.
DoubleElement
(
RESPONSIVENESS
*
aSample
.
mResponsiveness
)
;
}
if
(
aSample
.
mRSS
.
isSome
(
)
)
{
writer
.
DoubleElement
(
RSS
*
aSample
.
mRSS
)
;
}
if
(
aSample
.
mUSS
.
isSome
(
)
)
{
writer
.
DoubleElement
(
USS
*
aSample
.
mUSS
)
;
}
}
class
EntryGetter
{
public
:
explicit
EntryGetter
(
const
ProfileBuffer
&
aBuffer
uint64_t
aInitialReadPos
=
0
)
:
mBuffer
(
aBuffer
)
mReadPos
(
aBuffer
.
mRangeStart
)
{
if
(
aInitialReadPos
!
=
0
)
{
MOZ_RELEASE_ASSERT
(
aInitialReadPos
>
=
aBuffer
.
mRangeStart
&
&
aInitialReadPos
<
=
aBuffer
.
mRangeEnd
)
;
mReadPos
=
aInitialReadPos
;
}
}
bool
Has
(
)
const
{
return
mReadPos
!
=
mBuffer
.
mRangeEnd
;
}
const
ProfileBufferEntry
&
Get
(
)
const
{
return
mBuffer
.
GetEntry
(
mReadPos
)
;
}
void
Next
(
)
{
mReadPos
+
+
;
}
uint64_t
CurPos
(
)
{
return
mReadPos
;
}
private
:
const
ProfileBuffer
&
mBuffer
;
uint64_t
mReadPos
;
}
;
#
define
ERROR_AND_CONTINUE
(
msg
)
\
{
\
fprintf
(
stderr
"
ProfileBuffer
parse
error
:
%
s
"
msg
)
;
\
MOZ_ASSERT
(
false
msg
)
;
\
continue
;
\
}
void
ProfileBuffer
:
:
StreamSamplesToJSON
(
SpliceableJSONWriter
&
aWriter
int
aThreadId
double
aSinceTime
UniqueStacks
&
aUniqueStacks
)
const
{
UniquePtr
<
char
[
]
>
dynStrBuf
=
MakeUnique
<
char
[
]
>
(
kMaxFrameKeyLength
)
;
EntryGetter
e
(
*
this
)
;
for
(
;
;
)
{
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsThreadId
(
)
)
{
break
;
}
else
{
e
.
Next
(
)
;
}
}
if
(
!
e
.
Has
(
)
)
{
break
;
}
if
(
e
.
Get
(
)
.
IsThreadId
(
)
)
{
int
threadId
=
e
.
Get
(
)
.
GetInt
(
)
;
e
.
Next
(
)
;
if
(
threadId
!
=
aThreadId
)
{
continue
;
}
}
else
{
MOZ_CRASH
(
)
;
}
ProfileSample
sample
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsTime
(
)
)
{
sample
.
mTime
=
e
.
Get
(
)
.
GetDouble
(
)
;
e
.
Next
(
)
;
if
(
sample
.
mTime
<
aSinceTime
)
{
continue
;
}
}
else
{
ERROR_AND_CONTINUE
(
"
expected
a
Time
entry
"
)
;
}
UniqueStacks
:
:
StackKey
stack
=
aUniqueStacks
.
BeginStack
(
UniqueStacks
:
:
FrameKey
(
"
(
root
)
"
)
)
;
int
numFrames
=
0
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsNativeLeafAddr
(
)
)
{
numFrames
+
+
;
void
*
pc
=
e
.
Get
(
)
.
GetPtr
(
)
;
e
.
Next
(
)
;
static
const
uint32_t
BUF_SIZE
=
256
;
char
buf
[
BUF_SIZE
]
;
unsigned
long
long
pcULL
=
(
unsigned
long
long
)
(
uintptr_t
)
pc
;
SprintfLiteral
(
buf
"
%
#
llx
"
pcULL
)
;
static
const
bool
preSymbolicate
=
[
]
(
)
{
const
char
*
symbolicate
=
getenv
(
"
MOZ_PROFILER_SYMBOLICATE
"
)
;
return
symbolicate
&
&
symbolicate
[
0
]
!
=
'
\
0
'
;
}
(
)
;
if
(
preSymbolicate
)
{
MozCodeAddressDetails
details
;
if
(
MozDescribeCodeAddress
(
pc
&
details
)
)
{
const
uint32_t
pcLen
=
strlen
(
buf
)
;
buf
[
pcLen
]
=
'
'
;
MozFormatCodeAddressDetails
(
buf
+
pcLen
+
1
BUF_SIZE
-
(
pcLen
+
1
)
0
pc
&
details
)
;
}
}
stack
=
aUniqueStacks
.
AppendFrame
(
stack
UniqueStacks
:
:
FrameKey
(
buf
)
)
;
}
else
if
(
e
.
Get
(
)
.
IsLabel
(
)
)
{
numFrames
+
+
;
const
char
*
label
=
e
.
Get
(
)
.
GetString
(
)
;
e
.
Next
(
)
;
using
FrameFlags
=
js
:
:
ProfilingStackFrame
:
:
Flags
;
uint32_t
frameFlags
=
0
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsFrameFlags
(
)
)
{
frameFlags
=
uint32_t
(
e
.
Get
(
)
.
GetUint64
(
)
)
;
e
.
Next
(
)
;
}
bool
relevantForJS
=
frameFlags
&
uint32_t
(
FrameFlags
:
:
RELEVANT_FOR_JS
)
;
size_t
i
=
0
;
dynStrBuf
[
0
]
=
'
\
0
'
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsDynamicStringFragment
(
)
)
{
char
chars
[
ProfileBufferEntry
:
:
kNumChars
]
;
e
.
Get
(
)
.
CopyCharsInto
(
chars
)
;
for
(
char
c
:
chars
)
{
if
(
i
<
kMaxFrameKeyLength
)
{
dynStrBuf
[
i
]
=
c
;
i
+
+
;
}
}
e
.
Next
(
)
;
}
else
{
break
;
}
}
dynStrBuf
[
kMaxFrameKeyLength
-
1
]
=
'
\
0
'
;
bool
hasDynamicString
=
(
i
!
=
0
)
;
nsCString
frameLabel
;
if
(
label
[
0
]
!
=
'
\
0
'
&
&
hasDynamicString
)
{
if
(
frameFlags
&
uint32_t
(
FrameFlags
:
:
STRING_TEMPLATE_METHOD
)
)
{
frameLabel
.
AppendPrintf
(
"
%
s
.
%
s
"
label
dynStrBuf
.
get
(
)
)
;
}
else
if
(
frameFlags
&
uint32_t
(
FrameFlags
:
:
STRING_TEMPLATE_GETTER
)
)
{
frameLabel
.
AppendPrintf
(
"
get
%
s
.
%
s
"
label
dynStrBuf
.
get
(
)
)
;
}
else
if
(
frameFlags
&
uint32_t
(
FrameFlags
:
:
STRING_TEMPLATE_SETTER
)
)
{
frameLabel
.
AppendPrintf
(
"
set
%
s
.
%
s
"
label
dynStrBuf
.
get
(
)
)
;
}
else
{
frameLabel
.
AppendPrintf
(
"
%
s
%
s
"
label
dynStrBuf
.
get
(
)
)
;
}
}
else
if
(
hasDynamicString
)
{
frameLabel
.
Append
(
dynStrBuf
.
get
(
)
)
;
}
else
{
frameLabel
.
Append
(
label
)
;
}
Maybe
<
unsigned
>
line
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsLineNumber
(
)
)
{
line
=
Some
(
unsigned
(
e
.
Get
(
)
.
GetInt
(
)
)
)
;
e
.
Next
(
)
;
}
Maybe
<
unsigned
>
column
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsColumnNumber
(
)
)
{
column
=
Some
(
unsigned
(
e
.
Get
(
)
.
GetInt
(
)
)
)
;
e
.
Next
(
)
;
}
Maybe
<
JS
:
:
ProfilingCategoryPair
>
categoryPair
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsCategoryPair
(
)
)
{
categoryPair
=
Some
(
JS
:
:
ProfilingCategoryPair
(
uint32_t
(
e
.
Get
(
)
.
GetInt
(
)
)
)
)
;
e
.
Next
(
)
;
}
stack
=
aUniqueStacks
.
AppendFrame
(
stack
UniqueStacks
:
:
FrameKey
(
std
:
:
move
(
frameLabel
)
relevantForJS
line
column
categoryPair
)
)
;
}
else
if
(
e
.
Get
(
)
.
IsJitReturnAddr
(
)
)
{
numFrames
+
+
;
void
*
pc
=
e
.
Get
(
)
.
GetPtr
(
)
;
const
Maybe
<
Vector
<
UniqueStacks
:
:
FrameKey
>
>
&
frameKeys
=
aUniqueStacks
.
LookupFramesForJITAddressFromBufferPos
(
pc
e
.
CurPos
(
)
)
;
MOZ_RELEASE_ASSERT
(
frameKeys
"
Attempting
to
stream
samples
for
a
buffer
range
"
"
for
which
we
don
'
t
have
JITFrameInfo
?
"
)
;
for
(
const
UniqueStacks
:
:
FrameKey
&
frameKey
:
*
frameKeys
)
{
stack
=
aUniqueStacks
.
AppendFrame
(
stack
frameKey
)
;
}
e
.
Next
(
)
;
}
else
{
break
;
}
}
if
(
numFrames
=
=
0
)
{
continue
;
}
sample
.
mStack
=
aUniqueStacks
.
GetOrAddStackIndex
(
stack
)
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsMarker
(
)
)
{
e
.
Next
(
)
;
}
else
{
break
;
}
}
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsResponsiveness
(
)
)
{
sample
.
mResponsiveness
=
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
;
e
.
Next
(
)
;
}
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsResidentMemory
(
)
)
{
sample
.
mRSS
=
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
;
e
.
Next
(
)
;
}
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsUnsharedMemory
(
)
)
{
sample
.
mUSS
=
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
;
e
.
Next
(
)
;
}
WriteSample
(
aWriter
*
aUniqueStacks
.
mUniqueStrings
sample
)
;
}
}
void
ProfileBuffer
:
:
AddJITInfoForRange
(
uint64_t
aRangeStart
int
aThreadId
JSContext
*
aContext
JITFrameInfo
&
aJITFrameInfo
)
const
{
MOZ_RELEASE_ASSERT
(
aContext
)
;
aRangeStart
=
std
:
:
max
(
aRangeStart
mRangeStart
)
;
aJITFrameInfo
.
AddInfoForRange
(
aRangeStart
mRangeEnd
aContext
[
&
]
(
const
std
:
:
function
<
void
(
void
*
)
>
&
aJITAddressConsumer
)
{
EntryGetter
e
(
*
this
aRangeStart
)
;
while
(
true
)
{
while
(
e
.
Has
(
)
&
&
!
e
.
Get
(
)
.
IsThreadId
(
)
)
{
e
.
Next
(
)
;
}
if
(
!
e
.
Has
(
)
)
{
break
;
}
MOZ_ASSERT
(
e
.
Get
(
)
.
IsThreadId
(
)
)
;
int
threadId
=
e
.
Get
(
)
.
GetInt
(
)
;
e
.
Next
(
)
;
if
(
threadId
!
=
aThreadId
)
{
continue
;
}
while
(
e
.
Has
(
)
&
&
!
e
.
Get
(
)
.
IsThreadId
(
)
)
{
if
(
e
.
Get
(
)
.
IsJitReturnAddr
(
)
)
{
aJITAddressConsumer
(
e
.
Get
(
)
.
GetPtr
(
)
)
;
}
e
.
Next
(
)
;
}
}
}
)
;
}
void
ProfileBuffer
:
:
StreamMarkersToJSON
(
SpliceableJSONWriter
&
aWriter
int
aThreadId
const
TimeStamp
&
aProcessStartTime
double
aSinceTime
UniqueStacks
&
aUniqueStacks
)
const
{
EntryGetter
e
(
*
this
)
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsMarker
(
)
)
{
const
ProfilerMarker
*
marker
=
e
.
Get
(
)
.
GetMarker
(
)
;
if
(
marker
-
>
GetTime
(
)
>
=
aSinceTime
&
&
marker
-
>
GetThreadId
(
)
=
=
aThreadId
)
{
marker
-
>
StreamJSON
(
aWriter
aProcessStartTime
aUniqueStacks
)
;
}
}
e
.
Next
(
)
;
}
}
void
ProfileBuffer
:
:
StreamProfilerOverheadToJSON
(
SpliceableJSONWriter
&
aWriter
const
TimeStamp
&
aProcessStartTime
double
aSinceTime
)
const
{
enum
Schema
:
uint32_t
{
TIME
=
0
LOCKING
=
1
MARKER_CLEANING
=
2
COUNTERS
=
3
THREADS
=
4
}
;
EntryGetter
e
(
*
this
)
;
aWriter
.
StartObjectProperty
(
"
profilerOverhead_UNSTABLE
"
)
;
{
JSONSchemaWriter
schema
(
aWriter
)
;
schema
.
WriteField
(
"
time
"
)
;
schema
.
WriteField
(
"
locking
"
)
;
schema
.
WriteField
(
"
expiredMarkerCleaning
"
)
;
schema
.
WriteField
(
"
counters
"
)
;
schema
.
WriteField
(
"
threads
"
)
;
}
aWriter
.
StartArrayProperty
(
"
data
"
)
;
double
firstTime
=
0
.
0
;
double
lastTime
=
0
.
0
;
struct
Stats
{
unsigned
n
=
0
;
double
sum
=
0
;
double
min
=
std
:
:
numeric_limits
<
double
>
:
:
max
(
)
;
double
max
=
0
;
void
Count
(
double
v
)
{
+
+
n
;
sum
+
=
v
;
if
(
v
<
min
)
{
min
=
v
;
}
if
(
v
>
max
)
{
max
=
v
;
}
}
}
;
Stats
intervals
overheads
lockings
cleanings
counters
threads
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsProfilerOverheadTime
(
)
)
{
double
time
=
e
.
Get
(
)
.
GetDouble
(
)
;
if
(
time
>
=
aSinceTime
)
{
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsProfilerOverheadDuration
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
ProfilerOverheadDuration
entry
after
"
"
ProfilerOverheadTime
"
)
;
}
double
locking
=
e
.
Get
(
)
.
GetDouble
(
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsProfilerOverheadDuration
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
ProfilerOverheadDuration
entry
after
"
"
ProfilerOverheadTime
ProfilerOverheadDuration
"
)
;
}
double
cleaning
=
e
.
Get
(
)
.
GetDouble
(
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsProfilerOverheadDuration
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
ProfilerOverheadDuration
entry
after
"
"
ProfilerOverheadTime
ProfilerOverheadDuration
*
2
"
)
;
}
double
counter
=
e
.
Get
(
)
.
GetDouble
(
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsProfilerOverheadDuration
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
ProfilerOverheadDuration
entry
after
"
"
ProfilerOverheadTime
ProfilerOverheadDuration
*
3
"
)
;
}
double
thread
=
e
.
Get
(
)
.
GetDouble
(
)
;
if
(
firstTime
=
=
0
.
0
)
{
firstTime
=
time
;
}
else
{
intervals
.
Count
(
time
-
lastTime
)
;
}
lastTime
=
time
;
overheads
.
Count
(
locking
+
cleaning
+
counter
+
thread
)
;
lockings
.
Count
(
locking
)
;
cleanings
.
Count
(
cleaning
)
;
counters
.
Count
(
counter
)
;
threads
.
Count
(
thread
)
;
AutoArraySchemaWriter
writer
(
aWriter
)
;
writer
.
DoubleElement
(
TIME
time
)
;
writer
.
DoubleElement
(
LOCKING
locking
)
;
writer
.
DoubleElement
(
MARKER_CLEANING
cleaning
)
;
writer
.
DoubleElement
(
COUNTERS
counter
)
;
writer
.
DoubleElement
(
THREADS
thread
)
;
}
}
e
.
Next
(
)
;
}
aWriter
.
EndArray
(
)
;
if
(
intervals
.
n
>
0
)
{
aWriter
.
StartObjectProperty
(
"
statistics
"
)
;
aWriter
.
DoubleProperty
(
"
profiledDuration
"
lastTime
-
firstTime
)
;
aWriter
.
IntProperty
(
"
samplingCount
"
overheads
.
n
)
;
aWriter
.
DoubleProperty
(
"
overheadDurations
"
overheads
.
sum
)
;
aWriter
.
DoubleProperty
(
"
overheadPercentage
"
overheads
.
sum
/
(
lastTime
-
firstTime
)
)
;
#
define
PROFILER_STATS
(
name
var
)
\
aWriter
.
DoubleProperty
(
"
mean
"
name
(
var
)
.
sum
/
(
var
)
.
n
)
;
\
aWriter
.
DoubleProperty
(
"
min
"
name
(
var
)
.
min
)
;
\
aWriter
.
DoubleProperty
(
"
max
"
name
(
var
)
.
max
)
;
PROFILER_STATS
(
"
Interval
"
intervals
)
;
PROFILER_STATS
(
"
Overhead
"
overheads
)
;
PROFILER_STATS
(
"
Lockings
"
lockings
)
;
PROFILER_STATS
(
"
Cleaning
"
cleanings
)
;
PROFILER_STATS
(
"
Counter
"
counters
)
;
PROFILER_STATS
(
"
Thread
"
threads
)
;
#
undef
PROFILER_STATS
aWriter
.
EndObject
(
)
;
}
aWriter
.
EndObject
(
)
;
}
struct
CounterKeyedSample
{
double
mTime
;
uint64_t
mNumber
;
int64_t
mCount
;
}
;
using
CounterKeyedSamples
=
Vector
<
CounterKeyedSample
>
;
static
LazyLogModule
sFuzzyfoxLog
(
"
Fuzzyfox
"
)
;
using
CounterMap
=
HashMap
<
uint64_t
CounterKeyedSamples
>
;
template
<
typename
HashM
typename
Key
>
static
auto
&
LookupOrAdd
(
HashM
&
aMap
Key
&
&
aKey
)
{
auto
addPtr
=
aMap
.
lookupForAdd
(
aKey
)
;
if
(
!
addPtr
)
{
MOZ_RELEASE_ASSERT
(
aMap
.
add
(
addPtr
std
:
:
forward
<
Key
>
(
aKey
)
typename
HashM
:
:
Entry
:
:
ValueType
{
}
)
)
;
MOZ_ASSERT
(
!
!
addPtr
)
;
}
return
addPtr
-
>
value
(
)
;
}
void
ProfileBuffer
:
:
StreamCountersToJSON
(
SpliceableJSONWriter
&
aWriter
const
TimeStamp
&
aProcessStartTime
double
aSinceTime
)
const
{
EntryGetter
e
(
*
this
)
;
enum
Schema
:
uint32_t
{
TIME
=
0
NUMBER
=
1
COUNT
=
2
}
;
HashMap
<
void
*
CounterMap
>
counters
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsCounterId
(
)
)
{
void
*
id
=
e
.
Get
(
)
.
GetPtr
(
)
;
CounterMap
&
counter
=
LookupOrAdd
(
counters
id
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsTime
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
Time
entry
"
)
;
}
double
time
=
e
.
Get
(
)
.
GetDouble
(
)
;
if
(
time
>
=
aSinceTime
)
{
e
.
Next
(
)
;
while
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsCounterKey
(
)
)
{
uint64_t
key
=
e
.
Get
(
)
.
GetUint64
(
)
;
CounterKeyedSamples
&
data
=
LookupOrAdd
(
counter
key
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsCount
(
)
)
{
ERROR_AND_CONTINUE
(
"
expected
a
Count
entry
"
)
;
}
int64_t
count
=
e
.
Get
(
)
.
GetUint64
(
)
;
e
.
Next
(
)
;
uint64_t
number
;
if
(
!
e
.
Has
(
)
|
|
!
e
.
Get
(
)
.
IsNumber
(
)
)
{
number
=
0
;
}
else
{
number
=
e
.
Get
(
)
.
GetInt64
(
)
;
}
CounterKeyedSample
sample
=
{
time
number
count
}
;
MOZ_RELEASE_ASSERT
(
data
.
append
(
sample
)
)
;
}
}
else
{
}
}
e
.
Next
(
)
;
}
if
(
counters
.
count
(
)
=
=
0
)
{
return
;
}
aWriter
.
StartArrayProperty
(
"
counters
"
)
;
for
(
auto
iter
=
counters
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
CounterMap
&
counter
=
iter
.
get
(
)
.
value
(
)
;
const
BaseProfilerCount
*
base_counter
=
static_cast
<
const
BaseProfilerCount
*
>
(
iter
.
get
(
)
.
key
(
)
)
;
aWriter
.
Start
(
)
;
aWriter
.
StringProperty
(
"
name
"
base_counter
-
>
mLabel
)
;
aWriter
.
StringProperty
(
"
category
"
base_counter
-
>
mCategory
)
;
aWriter
.
StringProperty
(
"
description
"
base_counter
-
>
mDescription
)
;
aWriter
.
StartObjectProperty
(
"
sample_groups
"
)
;
for
(
auto
counter_iter
=
counter
.
iter
(
)
;
!
counter_iter
.
done
(
)
;
counter_iter
.
next
(
)
)
{
CounterKeyedSamples
&
samples
=
counter_iter
.
get
(
)
.
value
(
)
;
uint64_t
key
=
counter_iter
.
get
(
)
.
key
(
)
;
size_t
size
=
samples
.
length
(
)
;
if
(
size
=
=
0
)
{
continue
;
}
aWriter
.
IntProperty
(
"
id
"
static_cast
<
int64_t
>
(
key
)
)
;
aWriter
.
StartObjectProperty
(
"
samples
"
)
;
{
JSONSchemaWriter
schema
(
aWriter
)
;
schema
.
WriteField
(
"
time
"
)
;
schema
.
WriteField
(
"
number
"
)
;
schema
.
WriteField
(
"
count
"
)
;
}
aWriter
.
StartArrayProperty
(
"
data
"
)
;
uint64_t
previousNumber
=
0
;
int64_t
previousCount
=
0
;
for
(
size_t
i
=
0
;
i
<
size
;
i
+
+
)
{
if
(
i
=
=
0
|
|
samples
[
i
]
.
mNumber
!
=
previousNumber
|
|
samples
[
i
]
.
mCount
!
=
previousCount
)
{
if
(
i
!
=
0
&
&
samples
[
i
]
.
mTime
>
=
samples
[
i
-
1
]
.
mTime
)
{
MOZ_LOG
(
sFuzzyfoxLog
mozilla
:
:
LogLevel
:
:
Error
(
"
Fuzzyfox
Profiler
Assertion
:
%
f
>
=
%
f
"
samples
[
i
]
.
mTime
samples
[
i
-
1
]
.
mTime
)
)
;
}
MOZ_ASSERT
(
i
=
=
0
|
|
samples
[
i
]
.
mTime
>
=
samples
[
i
-
1
]
.
mTime
)
;
MOZ_ASSERT
(
samples
[
i
]
.
mNumber
>
=
previousNumber
)
;
MOZ_ASSERT
(
samples
[
i
]
.
mNumber
-
previousNumber
<
=
uint64_t
(
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
)
)
;
AutoArraySchemaWriter
writer
(
aWriter
)
;
writer
.
DoubleElement
(
TIME
samples
[
i
]
.
mTime
)
;
writer
.
IntElement
(
NUMBER
static_cast
<
int64_t
>
(
samples
[
i
]
.
mNumber
-
previousNumber
)
)
;
writer
.
IntElement
(
COUNT
samples
[
i
]
.
mCount
-
previousCount
)
;
previousNumber
=
samples
[
i
]
.
mNumber
;
previousCount
=
samples
[
i
]
.
mCount
;
}
}
aWriter
.
EndArray
(
)
;
aWriter
.
EndObject
(
)
;
}
aWriter
.
EndObject
(
)
;
aWriter
.
End
(
)
;
}
aWriter
.
EndArray
(
)
;
}
void
ProfileBuffer
:
:
StreamMemoryToJSON
(
SpliceableJSONWriter
&
aWriter
const
TimeStamp
&
aProcessStartTime
double
aSinceTime
)
const
{
enum
Schema
:
uint32_t
{
TIME
=
0
RSS
=
1
USS
=
2
}
;
EntryGetter
e
(
*
this
)
;
aWriter
.
StartObjectProperty
(
"
memory
"
)
;
aWriter
.
IntProperty
(
"
initial_heap
"
0
)
;
aWriter
.
StartObjectProperty
(
"
samples
"
)
;
{
JSONSchemaWriter
schema
(
aWriter
)
;
schema
.
WriteField
(
"
time
"
)
;
schema
.
WriteField
(
"
rss
"
)
;
schema
.
WriteField
(
"
uss
"
)
;
}
aWriter
.
StartArrayProperty
(
"
data
"
)
;
int64_t
previous_rss
=
0
;
int64_t
previous_uss
=
0
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsResidentMemory
(
)
)
{
int64_t
rss
=
e
.
Get
(
)
.
GetInt64
(
)
;
int64_t
uss
=
0
;
e
.
Next
(
)
;
if
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsUnsharedMemory
(
)
)
{
uss
=
e
.
Get
(
)
.
GetDouble
(
)
;
e
.
Next
(
)
;
if
(
!
e
.
Has
(
)
)
{
break
;
}
}
if
(
e
.
Get
(
)
.
IsTime
(
)
)
{
double
time
=
e
.
Get
(
)
.
GetDouble
(
)
;
if
(
time
>
=
aSinceTime
&
&
(
previous_rss
!
=
rss
|
|
previous_uss
!
=
uss
)
)
{
AutoArraySchemaWriter
writer
(
aWriter
)
;
writer
.
DoubleElement
(
TIME
time
)
;
writer
.
IntElement
(
RSS
rss
)
;
if
(
uss
!
=
0
)
{
writer
.
IntElement
(
USS
uss
)
;
}
previous_rss
=
rss
;
previous_uss
=
uss
;
}
}
else
{
ERROR_AND_CONTINUE
(
"
expected
a
Time
entry
"
)
;
}
}
}
e
.
Next
(
)
;
}
aWriter
.
EndArray
(
)
;
aWriter
.
EndObject
(
)
;
aWriter
.
EndObject
(
)
;
}
#
undef
ERROR_AND_CONTINUE
static
void
AddPausedRange
(
SpliceableJSONWriter
&
aWriter
const
char
*
aReason
const
Maybe
<
double
>
&
aStartTime
const
Maybe
<
double
>
&
aEndTime
)
{
aWriter
.
Start
(
)
;
if
(
aStartTime
)
{
aWriter
.
DoubleProperty
(
"
startTime
"
*
aStartTime
)
;
}
else
{
aWriter
.
NullProperty
(
"
startTime
"
)
;
}
if
(
aEndTime
)
{
aWriter
.
DoubleProperty
(
"
endTime
"
*
aEndTime
)
;
}
else
{
aWriter
.
NullProperty
(
"
endTime
"
)
;
}
aWriter
.
StringProperty
(
"
reason
"
aReason
)
;
aWriter
.
End
(
)
;
}
void
ProfileBuffer
:
:
StreamPausedRangesToJSON
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
)
const
{
EntryGetter
e
(
*
this
)
;
Maybe
<
double
>
currentPauseStartTime
;
Maybe
<
double
>
currentCollectionStartTime
;
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsPause
(
)
)
{
currentPauseStartTime
=
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
;
}
else
if
(
e
.
Get
(
)
.
IsResume
(
)
)
{
AddPausedRange
(
aWriter
"
profiler
-
paused
"
currentPauseStartTime
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
)
;
currentPauseStartTime
=
Nothing
(
)
;
}
else
if
(
e
.
Get
(
)
.
IsCollectionStart
(
)
)
{
currentCollectionStartTime
=
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
;
}
else
if
(
e
.
Get
(
)
.
IsCollectionEnd
(
)
)
{
AddPausedRange
(
aWriter
"
collecting
"
currentCollectionStartTime
Some
(
e
.
Get
(
)
.
GetDouble
(
)
)
)
;
currentCollectionStartTime
=
Nothing
(
)
;
}
e
.
Next
(
)
;
}
if
(
currentPauseStartTime
)
{
AddPausedRange
(
aWriter
"
profiler
-
paused
"
currentPauseStartTime
Nothing
(
)
)
;
}
if
(
currentCollectionStartTime
)
{
AddPausedRange
(
aWriter
"
collecting
"
currentCollectionStartTime
Nothing
(
)
)
;
}
}
bool
ProfileBuffer
:
:
DuplicateLastSample
(
int
aThreadId
const
TimeStamp
&
aProcessStartTime
Maybe
<
uint64_t
>
&
aLastSample
)
{
if
(
aLastSample
&
&
*
aLastSample
<
mRangeStart
)
{
aLastSample
.
reset
(
)
;
}
if
(
!
aLastSample
)
{
return
false
;
}
uint64_t
lastSampleStartPos
=
*
aLastSample
;
MOZ_RELEASE_ASSERT
(
GetEntry
(
lastSampleStartPos
)
.
IsThreadId
(
)
&
&
GetEntry
(
lastSampleStartPos
)
.
GetInt
(
)
=
=
aThreadId
)
;
aLastSample
=
Some
(
AddThreadIdEntry
(
aThreadId
)
)
;
EntryGetter
e
(
*
this
lastSampleStartPos
+
1
)
;
while
(
e
.
Has
(
)
)
{
switch
(
e
.
Get
(
)
.
GetKind
(
)
)
{
case
ProfileBufferEntry
:
:
Kind
:
:
Pause
:
case
ProfileBufferEntry
:
:
Kind
:
:
Resume
:
case
ProfileBufferEntry
:
:
Kind
:
:
CollectionStart
:
case
ProfileBufferEntry
:
:
Kind
:
:
CollectionEnd
:
case
ProfileBufferEntry
:
:
Kind
:
:
ThreadId
:
return
true
;
case
ProfileBufferEntry
:
:
Kind
:
:
Time
:
AddEntry
(
ProfileBufferEntry
:
:
Time
(
(
TimeStamp
:
:
NowUnfuzzed
(
)
-
aProcessStartTime
)
.
ToMilliseconds
(
)
)
)
;
break
;
case
ProfileBufferEntry
:
:
Kind
:
:
Marker
:
case
ProfileBufferEntry
:
:
Kind
:
:
ResidentMemory
:
case
ProfileBufferEntry
:
:
Kind
:
:
UnsharedMemory
:
case
ProfileBufferEntry
:
:
Kind
:
:
CounterKey
:
case
ProfileBufferEntry
:
:
Kind
:
:
Number
:
case
ProfileBufferEntry
:
:
Kind
:
:
Count
:
case
ProfileBufferEntry
:
:
Kind
:
:
Responsiveness
:
break
;
case
ProfileBufferEntry
:
:
Kind
:
:
CounterId
:
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
Time
)
{
continue
;
}
break
;
case
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadTime
:
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadDuration
)
{
continue
;
}
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadDuration
)
{
continue
;
}
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadDuration
)
{
continue
;
}
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
GetKind
(
)
!
=
ProfileBufferEntry
:
:
Kind
:
:
ProfilerOverheadDuration
)
{
continue
;
}
break
;
default
:
{
ProfileBufferEntry
entry
=
e
.
Get
(
)
;
AddEntry
(
entry
)
;
break
;
}
}
e
.
Next
(
)
;
}
return
true
;
}
void
ProfileBuffer
:
:
DiscardSamplesBeforeTime
(
double
aTime
)
{
EntryGetter
e
(
*
this
)
;
for
(
;
;
)
{
while
(
e
.
Has
(
)
)
{
if
(
e
.
Get
(
)
.
IsThreadId
(
)
)
{
break
;
}
else
{
e
.
Next
(
)
;
}
}
if
(
!
e
.
Has
(
)
)
{
break
;
}
MOZ_RELEASE_ASSERT
(
e
.
Get
(
)
.
IsThreadId
(
)
)
;
uint64_t
sampleStartPos
=
e
.
CurPos
(
)
;
e
.
Next
(
)
;
if
(
e
.
Has
(
)
&
&
e
.
Get
(
)
.
IsTime
(
)
)
{
double
sampleTime
=
e
.
Get
(
)
.
GetDouble
(
)
;
if
(
sampleTime
>
=
aTime
)
{
mRangeStart
=
sampleStartPos
;
return
;
}
}
}
}
