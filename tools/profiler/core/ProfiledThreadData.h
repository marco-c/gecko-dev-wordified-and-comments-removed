#
ifndef
ProfiledThreadData_h
#
define
ProfiledThreadData_h
#
include
"
platform
.
h
"
#
include
"
ProfileBuffer
.
h
"
#
include
"
ProfileBufferEntry
.
h
"
#
include
"
mozilla
/
FailureLatch
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
ProfileJSONWriter
.
h
"
#
include
"
mozilla
/
ProfilerThreadRegistrationInfo
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
nsStringFwd
.
h
"
class
nsIEventTarget
;
class
ProfilerCodeAddressService
;
struct
JSContext
;
struct
ThreadStreamingContext
;
class
ProfiledThreadData
final
{
public
:
explicit
ProfiledThreadData
(
const
mozilla
:
:
profiler
:
:
ThreadRegistrationInfo
&
aThreadInfo
)
;
explicit
ProfiledThreadData
(
mozilla
:
:
profiler
:
:
ThreadRegistrationInfo
&
&
aThreadInfo
)
;
~
ProfiledThreadData
(
)
;
void
NotifyUnregistered
(
uint64_t
aBufferPosition
)
{
mLastSample
=
mozilla
:
:
Nothing
(
)
;
MOZ_ASSERT
(
!
mBufferPositionWhenReceivedJSContext
"
JSContext
should
have
been
cleared
before
the
thread
was
"
"
unregistered
"
)
;
mUnregisterTime
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
mBufferPositionWhenUnregistered
=
mozilla
:
:
Some
(
aBufferPosition
)
;
mPreviousThreadRunningTimes
.
Clear
(
)
;
}
mozilla
:
:
Maybe
<
uint64_t
>
BufferPositionWhenUnregistered
(
)
{
return
mBufferPositionWhenUnregistered
;
}
mozilla
:
:
Maybe
<
uint64_t
>
&
LastSample
(
)
{
return
mLastSample
;
}
mozilla
:
:
NotNull
<
mozilla
:
:
UniquePtr
<
UniqueStacks
>
>
PrepareUniqueStacks
(
const
ProfileBuffer
&
aBuffer
JSContext
*
aCx
mozilla
:
:
FailureLatch
&
aFailureLatch
ProfilerCodeAddressService
*
aService
mozilla
:
:
ProgressLogger
aProgressLogger
)
;
void
StreamJSON
(
const
ProfileBuffer
&
aBuffer
JSContext
*
aCx
SpliceableJSONWriter
&
aWriter
const
nsACString
&
aProcessName
const
nsACString
&
aETLDplus1
const
mozilla
:
:
TimeStamp
&
aProcessStartTime
double
aSinceTime
ProfilerCodeAddressService
*
aService
mozilla
:
:
ProgressLogger
aProgressLogger
)
;
void
StreamJSON
(
ThreadStreamingContext
&
&
aThreadStreamingContext
SpliceableJSONWriter
&
aWriter
const
nsACString
&
aProcessName
const
nsACString
&
aETLDplus1
const
mozilla
:
:
TimeStamp
&
aProcessStartTime
ProfilerCodeAddressService
*
aService
mozilla
:
:
ProgressLogger
aProgressLogger
)
;
const
mozilla
:
:
profiler
:
:
ThreadRegistrationInfo
&
Info
(
)
const
{
return
mThreadInfo
;
}
void
NotifyReceivedJSContext
(
uint64_t
aCurrentBufferPosition
)
{
mBufferPositionWhenReceivedJSContext
=
mozilla
:
:
Some
(
aCurrentBufferPosition
)
;
}
void
NotifyAboutToLoseJSContext
(
JSContext
*
aCx
const
mozilla
:
:
TimeStamp
&
aProcessStartTime
ProfileBuffer
&
aBuffer
)
;
RunningTimes
&
PreviousThreadRunningTimesRef
(
)
{
return
mPreviousThreadRunningTimes
;
}
private
:
const
mozilla
:
:
profiler
:
:
ThreadRegistrationInfo
mThreadInfo
;
mozilla
:
:
UniquePtr
<
JITFrameInfo
>
mJITFrameInfoForPreviousJSContexts
;
mozilla
:
:
Maybe
<
uint64_t
>
mLastSample
;
mozilla
:
:
Maybe
<
uint64_t
>
mBufferPositionWhenReceivedJSContext
;
RunningTimes
mPreviousThreadRunningTimes
;
mozilla
:
:
Maybe
<
uint64_t
>
mBufferPositionWhenUnregistered
;
mozilla
:
:
TimeStamp
mUnregisterTime
;
}
;
struct
ThreadStreamingContext
{
ProfiledThreadData
&
mProfiledThreadData
;
JSContext
*
mJSContext
;
SpliceableChunkedJSONWriter
mSamplesDataWriter
;
SpliceableChunkedJSONWriter
mMarkersDataWriter
;
mozilla
:
:
NotNull
<
mozilla
:
:
UniquePtr
<
UniqueStacks
>
>
mUniqueStacks
;
enum
PreviousStackState
{
eNoStackYet
eStackWasNotEmpty
eStackWasEmpty
}
;
PreviousStackState
mPreviousStackState
=
eNoStackYet
;
uint32_t
mPreviousStack
=
0
;
ThreadStreamingContext
(
ProfiledThreadData
&
aProfiledThreadData
const
ProfileBuffer
&
aBuffer
JSContext
*
aCx
mozilla
:
:
FailureLatch
&
aFailureLatch
ProfilerCodeAddressService
*
aService
mozilla
:
:
ProgressLogger
aProgressLogger
)
;
void
FinalizeWriter
(
)
;
}
;
class
ProcessStreamingContext
final
:
public
mozilla
:
:
FailureLatch
{
public
:
ProcessStreamingContext
(
size_t
aThreadCount
mozilla
:
:
FailureLatch
&
aFailureLatch
const
mozilla
:
:
TimeStamp
&
aProcessStartTime
double
aSinceTime
)
;
~
ProcessStreamingContext
(
)
;
void
AddThreadStreamingContext
(
ProfiledThreadData
&
aProfiledThreadData
const
ProfileBuffer
&
aBuffer
JSContext
*
aCx
ProfilerCodeAddressService
*
aService
mozilla
:
:
ProgressLogger
aProgressLogger
)
;
ThreadStreamingContext
*
GetThreadStreamingContext
(
const
ProfilerThreadId
&
aThreadId
)
{
for
(
size_t
i
=
0
;
i
<
mTIDList
.
length
(
)
;
+
+
i
)
{
if
(
mTIDList
[
i
]
=
=
aThreadId
)
{
return
&
mThreadStreamingContextList
[
i
]
;
}
}
return
nullptr
;
}
const
mozilla
:
:
TimeStamp
&
ProcessStartTime
(
)
const
{
return
mProcessStartTime
;
}
double
GetSinceTime
(
)
const
{
return
mSinceTime
;
}
ThreadStreamingContext
*
begin
(
)
{
return
mThreadStreamingContextList
.
begin
(
)
;
}
;
ThreadStreamingContext
*
end
(
)
{
return
mThreadStreamingContextList
.
end
(
)
;
}
;
FAILURELATCH_IMPL_PROXY
(
mFailureLatch
)
private
:
mozilla
:
:
Vector
<
ProfilerThreadId
>
mTIDList
;
mozilla
:
:
Vector
<
ThreadStreamingContext
>
mThreadStreamingContextList
;
mozilla
:
:
FailureLatch
&
mFailureLatch
;
const
mozilla
:
:
TimeStamp
mProcessStartTime
;
const
double
mSinceTime
;
}
;
ProfilerThreadId
StreamSamplesAndMarkers
(
const
char
*
aName
ProfilerThreadId
aThreadId
const
ProfileBuffer
&
aBuffer
SpliceableJSONWriter
&
aWriter
const
nsACString
&
aProcessName
const
nsACString
&
aETLDplus1
const
mozilla
:
:
TimeStamp
&
aProcessStartTime
const
mozilla
:
:
TimeStamp
&
aRegisterTime
const
mozilla
:
:
TimeStamp
&
aUnregisterTime
double
aSinceTime
UniqueStacks
&
aUniqueStacks
mozilla
:
:
ProgressLogger
aProgressLogger
)
;
void
StreamSamplesAndMarkers
(
const
char
*
aName
ThreadStreamingContext
&
aThreadData
SpliceableJSONWriter
&
aWriter
const
nsACString
&
aProcessName
const
nsACString
&
aETLDplus1
const
mozilla
:
:
TimeStamp
&
aProcessStartTime
const
mozilla
:
:
TimeStamp
&
aRegisterTime
const
mozilla
:
:
TimeStamp
&
aUnregisterTime
mozilla
:
:
ProgressLogger
aProgressLogger
)
;
#
endif
