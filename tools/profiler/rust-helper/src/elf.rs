use
compact_symbol_table
:
:
CompactSymbolTable
;
use
object
:
:
{
ElfFile
Object
SymbolKind
Uuid
}
;
use
std
:
:
collections
:
:
HashMap
;
use
std
:
:
cmp
;
use
goblin
:
:
elf
;
const
UUID_SIZE
:
usize
=
16
;
const
PAGE_SIZE
:
usize
=
4096
;
fn
get_symbol_map
<
'
a
'
b
T
>
(
object_file
:
&
'
b
T
)
-
>
HashMap
<
u32
&
'
a
str
>
where
T
:
Object
<
'
a
'
b
>
{
object_file
.
dynamic_symbols
(
)
.
chain
(
object_file
.
symbols
(
)
)
.
filter
(
|
symbol
|
symbol
.
kind
(
)
=
=
SymbolKind
:
:
Text
)
.
filter_map
(
|
symbol
|
symbol
.
name
(
)
.
map
(
|
name
|
(
symbol
.
address
(
)
as
u32
name
)
)
)
.
collect
(
)
}
pub
fn
get_compact_symbol_table
(
buffer
:
&
[
u8
]
breakpad_id
:
&
str
)
-
>
Option
<
CompactSymbolTable
>
{
let
elf_file
=
ElfFile
:
:
parse
(
buffer
)
.
ok
(
)
?
;
let
elf_id
=
get_elf_id
(
&
elf_file
buffer
)
?
;
if
format
!
(
"
{
:
X
}
0
"
elf_id
.
simple
(
)
)
!
=
breakpad_id
{
return
None
;
}
return
Some
(
CompactSymbolTable
:
:
from_map
(
get_symbol_map
(
&
elf_file
)
)
)
;
}
fn
create_elf_id
(
identifier
:
&
[
u8
]
little_endian
:
bool
)
-
>
Option
<
Uuid
>
{
let
mut
data
=
[
0
as
u8
;
UUID_SIZE
]
;
let
len
=
cmp
:
:
min
(
identifier
.
len
(
)
UUID_SIZE
)
;
data
[
0
.
.
len
]
.
copy_from_slice
(
&
identifier
[
0
.
.
len
]
)
;
if
little_endian
{
data
[
0
.
.
4
]
.
reverse
(
)
;
data
[
4
.
.
6
]
.
reverse
(
)
;
data
[
6
.
.
8
]
.
reverse
(
)
;
}
Uuid
:
:
from_bytes
(
&
data
)
.
ok
(
)
}
pub
fn
get_elf_id
(
elf_file
:
&
ElfFile
data
:
&
[
u8
]
)
-
>
Option
<
Uuid
>
{
if
let
Some
(
identifier
)
=
elf_file
.
build_id
(
)
{
return
create_elf_id
(
identifier
elf_file
.
elf
(
)
.
little_endian
)
;
}
if
let
Some
(
section_data
)
=
find_text_section
(
elf_file
.
elf
(
)
data
)
{
let
mut
hash
=
[
0
;
UUID_SIZE
]
;
for
i
in
0
.
.
cmp
:
:
min
(
section_data
.
len
(
)
PAGE_SIZE
)
{
hash
[
i
%
UUID_SIZE
]
^
=
section_data
[
i
]
;
}
return
create_elf_id
(
&
hash
elf_file
.
elf
(
)
.
little_endian
)
;
}
None
}
fn
find_text_section
<
'
elf
'
data
>
(
elf
:
&
'
elf
elf
:
:
Elf
data
:
&
'
data
[
u8
]
)
-
>
Option
<
&
'
data
[
u8
]
>
{
elf
.
section_headers
.
iter
(
)
.
find_map
(
|
header
|
{
match
(
header
.
sh_type
elf
.
shdr_strtab
.
get
(
header
.
sh_name
)
)
{
(
elf
:
:
section_header
:
:
SHT_PROGBITS
Some
(
Ok
(
"
.
text
"
)
)
)
=
>
Some
(
&
data
[
header
.
sh_offset
as
usize
.
.
]
[
.
.
header
.
sh_size
as
usize
]
)
_
=
>
None
}
}
)
}
