#
include
"
GeckoTaskTracer
.
h
"
#
include
"
GeckoTaskTracerImpl
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
prtime
.
h
"
#
include
<
stdarg
.
h
>
#
define
MAX_SIZE_LOG
(
1024
*
128
)
#
define
ENSURE_TRUE_VOID
(
x
)
\
do
{
\
if
(
MOZ_UNLIKELY
(
!
(
x
)
)
)
{
\
return
;
\
}
\
}
while
(
0
)
#
define
ENSURE_TRUE
(
x
ret
)
\
do
{
\
if
(
MOZ_UNLIKELY
(
!
(
x
)
)
)
{
\
return
ret
;
\
}
\
}
while
(
0
)
namespace
mozilla
{
namespace
tasktracer
{
#
define
SOURCE_EVENT_NAME
(
type
)
\
const
char
*
CreateSourceEvent
#
#
type
(
)
{
return
"
SourceEvent
"
#
type
;
}
#
include
"
SourceEventTypeMap
.
h
"
#
undef
SOURCE_EVENT_NAME
static
MOZ_THREAD_LOCAL
(
TraceInfo
*
)
sTraceInfoTLS
;
static
mozilla
:
:
StaticMutex
sMutex
;
static
mozilla
:
:
Atomic
<
bool
>
sStarted
;
static
nsTArray
<
UniquePtr
<
TraceInfo
>
>
*
sTraceInfos
=
nullptr
;
static
PRTime
sStartTime
;
static
const
char
sJSLabelPrefix
[
]
=
"
#
tt
#
"
;
namespace
{
static
PRTime
GetTimestamp
(
)
{
return
PR_Now
(
)
/
1000
;
}
static
TraceInfo
*
AllocTraceInfo
(
int
aTid
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
auto
*
info
=
sTraceInfos
-
>
AppendElement
(
MakeUnique
<
TraceInfo
>
(
aTid
)
)
;
return
info
-
>
get
(
)
;
}
static
void
CreateSourceEvent
(
SourceEventType
aType
)
{
uint64_t
newId
=
GenNewUniqueTaskId
(
)
;
TraceInfo
*
info
=
GetOrCreateTraceInfo
(
)
;
ENSURE_TRUE_VOID
(
info
)
;
info
-
>
mCurTraceSourceId
=
newId
;
info
-
>
mCurTraceSourceType
=
aType
;
info
-
>
mCurTaskId
=
newId
;
uintptr_t
*
namePtr
;
#
define
SOURCE_EVENT_NAME
(
type
)
\
case
SourceEventType
:
:
type
:
\
{
\
namePtr
=
(
uintptr_t
*
)
&
CreateSourceEvent
#
#
type
;
\
break
;
\
}
switch
(
aType
)
{
#
include
"
SourceEventTypeMap
.
h
"
default
:
MOZ_CRASH
(
"
Unknown
SourceEvent
.
"
)
;
}
#
undef
SOURCE_EVENT_NAME
LogDispatch
(
newId
newId
newId
aType
)
;
LogVirtualTablePtr
(
newId
newId
namePtr
)
;
LogBegin
(
newId
newId
)
;
}
static
void
DestroySourceEvent
(
)
{
TraceInfo
*
info
=
GetOrCreateTraceInfo
(
)
;
ENSURE_TRUE_VOID
(
info
)
;
LogEnd
(
info
-
>
mCurTraceSourceId
info
-
>
mCurTraceSourceId
)
;
}
inline
static
bool
IsStartLogging
(
)
{
return
sStarted
;
}
static
void
SetLogStarted
(
bool
aIsStartLogging
)
{
MOZ_ASSERT
(
aIsStartLogging
!
=
sStarted
)
;
MOZ_ASSERT
(
sTraceInfos
!
=
nullptr
)
;
sStarted
=
aIsStartLogging
;
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
!
aIsStartLogging
&
&
sTraceInfos
)
{
for
(
uint32_t
i
=
0
;
i
<
sTraceInfos
-
>
Length
(
)
;
+
+
i
)
{
(
*
sTraceInfos
)
[
i
]
-
>
mObsolete
=
true
;
}
}
}
inline
static
void
ObsoleteCurrentTraceInfos
(
)
{
for
(
uint32_t
i
=
0
;
i
<
sTraceInfos
-
>
Length
(
)
;
+
+
i
)
{
(
*
sTraceInfos
)
[
i
]
-
>
mObsolete
=
true
;
}
}
}
nsCString
*
TraceInfo
:
:
AppendLog
(
)
{
if
(
mLogs
.
Length
(
)
>
=
MAX_SIZE_LOG
)
{
return
nullptr
;
}
return
mLogs
.
AppendElement
(
)
;
}
void
TraceInfo
:
:
MoveLogsInto
(
TraceInfoLogsType
&
aResult
)
{
MutexAutoLock
lock
(
mLogsMutex
)
;
aResult
.
AppendElements
(
Move
(
mLogs
)
)
;
}
void
InitTaskTracer
(
uint32_t
aFlags
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
aFlags
&
FORKED_AFTER_NUWA
)
{
ObsoleteCurrentTraceInfos
(
)
;
return
;
}
MOZ_ASSERT
(
!
sTraceInfos
)
;
sTraceInfoTLS
.
init
(
)
;
sTraceInfos
=
new
nsTArray
<
UniquePtr
<
TraceInfo
>
>
(
)
;
}
void
ShutdownTaskTracer
(
)
{
if
(
IsStartLogging
(
)
)
{
SetLogStarted
(
false
)
;
}
}
static
void
FreeTraceInfo
(
TraceInfo
*
aTraceInfo
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
aTraceInfo
)
{
UniquePtr
<
TraceInfo
>
traceinfo
(
aTraceInfo
)
;
mozilla
:
:
DebugOnly
<
bool
>
removed
=
sTraceInfos
-
>
RemoveElement
(
traceinfo
)
;
MOZ_ASSERT
(
removed
)
;
Unused
<
<
traceinfo
.
release
(
)
;
}
}
void
FreeTraceInfo
(
)
{
FreeTraceInfo
(
sTraceInfoTLS
.
get
(
)
)
;
}
TraceInfo
*
GetOrCreateTraceInfo
(
)
{
ENSURE_TRUE
(
IsStartLogging
(
)
nullptr
)
;
TraceInfo
*
info
=
sTraceInfoTLS
.
get
(
)
;
if
(
info
&
&
info
-
>
mObsolete
)
{
FreeTraceInfo
(
info
)
;
info
=
nullptr
;
}
if
(
!
info
)
{
info
=
AllocTraceInfo
(
gettid
(
)
)
;
sTraceInfoTLS
.
set
(
info
)
;
}
return
info
;
}
uint64_t
GenNewUniqueTaskId
(
)
{
TraceInfo
*
info
=
GetOrCreateTraceInfo
(
)
;
ENSURE_TRUE
(
info
0
)
;
pid_t
tid
=
gettid
(
)
;
uint64_t
taskid
=
(
(
uint64_t
)
tid
<
<
32
)
|
+
+
info
-
>
mLastUniqueTaskId
;
return
taskid
;
}
AutoSaveCurTraceInfo
:
:
AutoSaveCurTraceInfo
(
)
{
GetCurTraceInfo
(
&
mSavedSourceEventId
&
mSavedTaskId
&
mSavedSourceEventType
)
;
}
AutoSaveCurTraceInfo
:
:
~
AutoSaveCurTraceInfo
(
)
{
SetCurTraceInfo
(
mSavedSourceEventId
mSavedTaskId
mSavedSourceEventType
)
;
}
void
SetCurTraceInfo
(
uint64_t
aSourceEventId
uint64_t
aParentTaskId
SourceEventType
aSourceEventType
)
{
TraceInfo
*
info
=
GetOrCreateTraceInfo
(
)
;
ENSURE_TRUE_VOID
(
info
)
;
info
-
>
mCurTraceSourceId
=
aSourceEventId
;
info
-
>
mCurTaskId
=
aParentTaskId
;
info
-
>
mCurTraceSourceType
=
aSourceEventType
;
}
void
GetCurTraceInfo
(
uint64_t
*
aOutSourceEventId
uint64_t
*
aOutParentTaskId
SourceEventType
*
aOutSourceEventType
)
{
TraceInfo
*
info
=
GetOrCreateTraceInfo
(
)
;
ENSURE_TRUE_VOID
(
info
)
;
*
aOutSourceEventId
=
info
-
>
mCurTraceSourceId
;
*
aOutParentTaskId
=
info
-
>
mCurTaskId
;
*
aOutSourceEventType
=
info
-
>
mCurTraceSourceType
;
}
void
LogDispatch
(
uint64_t
aTaskId
uint64_t
aParentTaskId
uint64_t
aSourceEventId
SourceEventType
aSourceEventType
)
{
LogDispatch
(
aTaskId
aParentTaskId
aSourceEventId
aSourceEventType
0
)
;
}
void
LogDispatch
(
uint64_t
aTaskId
uint64_t
aParentTaskId
uint64_t
aSourceEventId
SourceEventType
aSourceEventType
int
aDelayTimeMs
)
{
TraceInfo
*
info
=
GetOrCreateTraceInfo
(
)
;
ENSURE_TRUE_VOID
(
info
)
;
uint64_t
time
=
(
aDelayTimeMs
<
=
0
)
?
GetTimestamp
(
)
:
GetTimestamp
(
)
+
aDelayTimeMs
;
MutexAutoLock
lock
(
info
-
>
mLogsMutex
)
;
nsCString
*
log
=
info
-
>
AppendLog
(
)
;
if
(
log
)
{
log
-
>
AppendPrintf
(
"
%
d
%
lld
%
lld
%
lld
%
d
%
lld
"
ACTION_DISPATCH
aTaskId
time
aSourceEventId
aSourceEventType
aParentTaskId
)
;
}
}
void
LogBegin
(
uint64_t
aTaskId
uint64_t
aSourceEventId
)
{
TraceInfo
*
info
=
GetOrCreateTraceInfo
(
)
;
ENSURE_TRUE_VOID
(
info
)
;
MutexAutoLock
lock
(
info
-
>
mLogsMutex
)
;
nsCString
*
log
=
info
-
>
AppendLog
(
)
;
if
(
log
)
{
log
-
>
AppendPrintf
(
"
%
d
%
lld
%
lld
%
d
%
d
"
ACTION_BEGIN
aTaskId
GetTimestamp
(
)
getpid
(
)
gettid
(
)
)
;
}
}
void
LogEnd
(
uint64_t
aTaskId
uint64_t
aSourceEventId
)
{
TraceInfo
*
info
=
GetOrCreateTraceInfo
(
)
;
ENSURE_TRUE_VOID
(
info
)
;
MutexAutoLock
lock
(
info
-
>
mLogsMutex
)
;
nsCString
*
log
=
info
-
>
AppendLog
(
)
;
if
(
log
)
{
log
-
>
AppendPrintf
(
"
%
d
%
lld
%
lld
"
ACTION_END
aTaskId
GetTimestamp
(
)
)
;
}
}
void
LogVirtualTablePtr
(
uint64_t
aTaskId
uint64_t
aSourceEventId
uintptr_t
*
aVptr
)
{
TraceInfo
*
info
=
GetOrCreateTraceInfo
(
)
;
ENSURE_TRUE_VOID
(
info
)
;
MutexAutoLock
lock
(
info
-
>
mLogsMutex
)
;
nsCString
*
log
=
info
-
>
AppendLog
(
)
;
if
(
log
)
{
log
-
>
AppendPrintf
(
"
%
d
%
lld
%
p
"
ACTION_GET_VTABLE
aTaskId
aVptr
)
;
}
}
AutoSourceEvent
:
:
AutoSourceEvent
(
SourceEventType
aType
)
:
AutoSaveCurTraceInfo
(
)
{
CreateSourceEvent
(
aType
)
;
}
AutoSourceEvent
:
:
~
AutoSourceEvent
(
)
{
DestroySourceEvent
(
)
;
}
void
AddLabel
(
const
char
*
aFormat
.
.
.
)
{
TraceInfo
*
info
=
GetOrCreateTraceInfo
(
)
;
ENSURE_TRUE_VOID
(
info
)
;
va_list
args
;
va_start
(
args
aFormat
)
;
nsAutoCString
buffer
;
buffer
.
AppendPrintf
(
aFormat
args
)
;
va_end
(
args
)
;
MutexAutoLock
lock
(
info
-
>
mLogsMutex
)
;
nsCString
*
log
=
info
-
>
AppendLog
(
)
;
if
(
log
)
{
log
-
>
AppendPrintf
(
"
%
d
%
lld
%
lld
\
"
%
s
\
"
"
ACTION_ADD_LABEL
info
-
>
mCurTaskId
GetTimestamp
(
)
buffer
.
get
(
)
)
;
}
}
void
StartLogging
(
)
{
sStartTime
=
GetTimestamp
(
)
;
SetLogStarted
(
true
)
;
}
void
StopLogging
(
)
{
SetLogStarted
(
false
)
;
}
UniquePtr
<
TraceInfoLogsType
>
GetLoggedData
(
TimeStamp
aTimeStamp
)
{
auto
result
=
MakeUnique
<
TraceInfoLogsType
>
(
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
for
(
uint32_t
i
=
0
;
i
<
sTraceInfos
-
>
Length
(
)
;
+
+
i
)
{
if
(
!
(
*
sTraceInfos
)
[
i
]
-
>
mObsolete
)
{
(
*
sTraceInfos
)
[
i
]
-
>
MoveLogsInto
(
*
result
)
;
}
}
return
result
;
}
const
PRTime
GetStartTime
(
)
{
return
sStartTime
;
}
const
char
*
GetJSLabelPrefix
(
)
{
return
sJSLabelPrefix
;
}
#
undef
ENSURE_TRUE_VOID
#
undef
ENSURE_TRUE
}
}
