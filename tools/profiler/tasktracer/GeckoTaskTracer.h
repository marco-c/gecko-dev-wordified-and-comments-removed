#
ifndef
GECKO_TASK_TRACER_H
#
define
GECKO_TASK_TRACER_H
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
<
stdarg
.
h
>
class
nsIRunnable
;
namespace
mozilla
{
class
TimeStamp
;
class
Runnable
;
namespace
tasktracer
{
extern
bool
gStarted
;
inline
bool
IsStartLogging
(
)
{
return
gStarted
;
}
enum
{
FORKED_AFTER_NUWA
=
1
<
<
0
}
;
enum
SourceEventType
{
#
define
SOURCE_EVENT_NAME
(
x
)
x
#
include
"
SourceEventTypeMap
.
h
"
#
undef
SOURCE_EVENT_NAME
}
;
class
AutoSaveCurTraceInfoImpl
{
uint64_t
mSavedTaskId
;
uint64_t
mSavedSourceEventId
;
SourceEventType
mSavedSourceEventType
;
public
:
AutoSaveCurTraceInfoImpl
(
)
;
~
AutoSaveCurTraceInfoImpl
(
)
;
}
;
class
AutoSaveCurTraceInfo
{
Maybe
<
AutoSaveCurTraceInfoImpl
>
mSaved
;
public
:
AutoSaveCurTraceInfo
(
)
{
if
(
IsStartLogging
(
)
)
{
mSaved
.
emplace
(
)
;
}
}
bool
HasSavedTraceInfo
(
)
{
return
!
!
mSaved
;
}
}
;
class
AutoSourceEvent
:
public
AutoSaveCurTraceInfo
{
void
StartScope
(
SourceEventType
aType
)
;
void
StopScope
(
)
;
public
:
explicit
AutoSourceEvent
(
SourceEventType
aType
)
:
AutoSaveCurTraceInfo
(
)
{
if
(
HasSavedTraceInfo
(
)
)
{
StartScope
(
aType
)
;
}
}
~
AutoSourceEvent
(
)
{
if
(
HasSavedTraceInfo
(
)
)
{
StopScope
(
)
;
}
}
}
;
void
InitTaskTracer
(
uint32_t
aFlags
=
0
)
;
void
ShutdownTaskTracer
(
)
;
void
DoAddLabel
(
const
char
*
aFormat
va_list
&
aArgs
)
;
inline
void
AddLabel
(
const
char
*
aFormat
.
.
.
)
MOZ_FORMAT_PRINTF
(
1
2
)
;
inline
void
AddLabel
(
const
char
*
aFormat
.
.
.
)
{
if
(
IsStartLogging
(
)
)
{
va_list
args
;
va_start
(
args
aFormat
)
;
DoAddLabel
(
aFormat
args
)
;
va_end
(
args
)
;
}
}
void
StartLogging
(
)
;
void
StopLogging
(
)
;
UniquePtr
<
nsTArray
<
nsCString
>
>
GetLoggedData
(
TimeStamp
aStartTime
)
;
PRTime
GetStartTime
(
)
;
already_AddRefed
<
nsIRunnable
>
CreateTracedRunnable
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
void
FreeTraceInfo
(
)
;
const
char
*
GetJSLabelPrefix
(
)
;
void
GetCurTraceInfo
(
uint64_t
*
aOutSourceEventId
uint64_t
*
aOutParentTaskId
SourceEventType
*
aOutSourceEventType
)
;
class
AutoScopedLabel
{
char
*
mLabel
;
void
Init
(
const
char
*
aFormat
va_list
&
aArgs
)
;
public
:
explicit
AutoScopedLabel
(
const
char
*
aFormat
.
.
.
)
:
mLabel
(
nullptr
)
{
if
(
IsStartLogging
(
)
)
{
va_list
args
;
va_start
(
args
aFormat
)
;
Init
(
aFormat
args
)
;
va_end
(
args
)
;
}
}
~
AutoScopedLabel
(
)
{
if
(
mLabel
)
{
AddLabel
(
"
End
%
s
"
mLabel
)
;
free
(
mLabel
)
;
}
}
}
;
}
}
#
endif
