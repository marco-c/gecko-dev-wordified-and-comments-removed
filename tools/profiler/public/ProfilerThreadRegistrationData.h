#
ifndef
ProfilerThreadRegistrationData_h
#
define
ProfilerThreadRegistrationData_h
#
include
"
js
/
ProfilingFrameIterator
.
h
"
#
include
"
js
/
ProfilingStack
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ProfilerThreadPlatformData
.
h
"
#
include
"
mozilla
/
ProfilerThreadRegistrationInfo
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIThread
.
h
"
class
ProfiledThreadData
;
class
PSAutoLock
;
struct
JSContext
;
namespace
mozilla
:
:
profiler
{
class
ThreadRegistrationData
{
public
:
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
static
constexpr
size_t
MAX_JS_FRAMES
=
1024
;
using
JsFrame
=
JS
:
:
ProfilingFrameIterator
:
:
Frame
;
using
JsFrameBuffer
=
JsFrame
[
MAX_JS_FRAMES
]
;
protected
:
ThreadRegistrationData
(
const
char
*
aName
const
void
*
aStackTop
)
;
#
ifdef
DEBUG
~
ThreadRegistrationData
(
)
{
MOZ_ASSERT
(
mIsBeingProfiled
=
=
!
!
mProfiledThreadData
)
;
MOZ_ASSERT
(
!
mProfiledThreadData
"
mProfiledThreadData
pointer
should
have
been
reset
before
"
"
~
ThreadRegistrationData
"
)
;
}
#
endif
ThreadRegistrationInfo
mInfo
;
ProfilingStack
mProfilingStack
;
PlatformData
mPlatformData
;
const
void
*
const
mStackTop
;
nsCOMPtr
<
nsIThread
>
mThread
;
JSContext
*
mJSContext
=
nullptr
;
JsFrame
*
mJsFrameBuffer
=
nullptr
;
enum
{
INACTIVE
=
0
ACTIVE_REQUESTED
=
1
ACTIVE
=
2
INACTIVE_REQUESTED
=
3
}
mJSSampling
=
INACTIVE
;
uint32_t
mJSFlags
=
0
;
enum
class
JSInstrumentationFlags
{
StackSampling
=
0x1
TraceLogging
=
0x2
Allocations
=
0x4
}
;
[
[
nodiscard
]
]
bool
JSTracerEnabled
(
)
const
{
return
mJSFlags
&
uint32_t
(
JSInstrumentationFlags
:
:
TraceLogging
)
;
}
[
[
nodiscard
]
]
bool
JSAllocationsEnabled
(
)
const
{
return
mJSFlags
&
uint32_t
(
JSInstrumentationFlags
:
:
Allocations
)
;
}
Atomic
<
bool
MemoryOrdering
:
:
Relaxed
>
mIsBeingProfiled
{
false
}
;
static
const
int
AWAKE
=
0
;
static
const
int
SLEEPING_NOT_OBSERVED
=
1
;
static
const
int
SLEEPING_OBSERVED
=
2
;
Atomic
<
int
>
mSleep
{
AWAKE
}
;
ProfiledThreadData
*
mProfiledThreadData
=
nullptr
;
}
;
class
ThreadRegistrationUnlockedConstReader
:
public
ThreadRegistrationData
{
public
:
[
[
nodiscard
]
]
const
ThreadRegistrationInfo
&
Info
(
)
const
{
return
mInfo
;
}
[
[
nodiscard
]
]
const
PlatformData
&
PlatformDataCRef
(
)
const
{
return
mPlatformData
;
}
[
[
nodiscard
]
]
const
void
*
StackTop
(
)
const
{
return
mStackTop
;
}
protected
:
ThreadRegistrationUnlockedConstReader
(
const
char
*
aName
const
void
*
aStackTop
)
:
ThreadRegistrationData
(
aName
aStackTop
)
{
}
}
;
class
ThreadRegistrationUnlockedConstReaderAndAtomicRW
:
public
ThreadRegistrationUnlockedConstReader
{
public
:
[
[
nodiscard
]
]
const
ProfilingStack
&
ProfilingStackCRef
(
)
const
{
return
mProfilingStack
;
}
[
[
nodiscard
]
]
ProfilingStack
&
ProfilingStackRef
(
)
{
return
mProfilingStack
;
}
[
[
nodiscard
]
]
bool
IsBeingProfiled
(
)
const
{
return
mIsBeingProfiled
;
}
void
SetSleeping
(
)
{
MOZ_ASSERT
(
mSleep
=
=
AWAKE
)
;
mSleep
=
SLEEPING_NOT_OBSERVED
;
}
void
SetAwake
(
)
{
MOZ_ASSERT
(
mSleep
!
=
AWAKE
)
;
mSleep
=
AWAKE
;
}
void
ReinitializeOnResume
(
)
{
(
void
)
mSleep
.
compareExchange
(
SLEEPING_OBSERVED
SLEEPING_NOT_OBSERVED
)
;
}
[
[
nodiscard
]
]
bool
CanDuplicateLastSampleDueToSleep
(
)
{
if
(
mSleep
=
=
AWAKE
)
{
return
false
;
}
if
(
mSleep
.
compareExchange
(
SLEEPING_NOT_OBSERVED
SLEEPING_OBSERVED
)
)
{
return
false
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
IsSleeping
(
)
const
{
return
mSleep
!
=
AWAKE
;
}
protected
:
ThreadRegistrationUnlockedConstReaderAndAtomicRW
(
const
char
*
aName
const
void
*
aStackTop
)
:
ThreadRegistrationUnlockedConstReader
(
aName
aStackTop
)
{
}
}
;
class
ThreadRegistrationUnlockedRWForLockedProfiler
:
public
ThreadRegistrationUnlockedConstReaderAndAtomicRW
{
public
:
[
[
nodiscard
]
]
bool
IsBeingProfiled
(
const
PSAutoLock
&
)
const
{
return
mProfiledThreadData
;
}
[
[
nodiscard
]
]
const
ProfiledThreadData
*
GetProfiledThreadData
(
const
PSAutoLock
&
)
const
{
return
mProfiledThreadData
;
}
[
[
nodiscard
]
]
ProfiledThreadData
*
GetProfiledThreadData
(
const
PSAutoLock
&
)
{
return
mProfiledThreadData
;
}
protected
:
ThreadRegistrationUnlockedRWForLockedProfiler
(
const
char
*
aName
const
void
*
aStackTop
)
:
ThreadRegistrationUnlockedConstReaderAndAtomicRW
(
aName
aStackTop
)
{
}
}
;
class
ThreadRegistrationUnlockedReaderAndAtomicRWOnThread
:
public
ThreadRegistrationUnlockedRWForLockedProfiler
{
public
:
[
[
nodiscard
]
]
JSContext
*
GetJSContext
(
)
const
{
return
mJSContext
;
}
protected
:
ThreadRegistrationUnlockedReaderAndAtomicRWOnThread
(
const
char
*
aName
const
void
*
aStackTop
)
:
ThreadRegistrationUnlockedRWForLockedProfiler
(
aName
aStackTop
)
{
}
}
;
class
ThreadRegistrationLockedRWFromAnyThread
:
public
ThreadRegistrationUnlockedReaderAndAtomicRWOnThread
{
public
:
void
SetIsBeingProfiledWithProfiledThreadData
(
ProfiledThreadData
*
aProfiledThreadData
const
PSAutoLock
&
)
;
void
ClearIsBeingProfiledAndProfiledThreadData
(
const
PSAutoLock
&
)
;
[
[
nodiscard
]
]
JsFrame
*
GetJsFrameBuffer
(
)
const
{
return
mJsFrameBuffer
;
}
[
[
nodiscard
]
]
const
nsCOMPtr
<
nsIEventTarget
>
GetEventTarget
(
)
const
{
return
mThread
;
}
void
ResetMainThread
(
nsIThread
*
aThread
)
{
mThread
=
aThread
;
}
void
GetRunningEventDelay
(
const
TimeStamp
&
aNow
TimeDuration
&
aDelay
TimeDuration
&
aRunning
)
{
if
(
mThread
)
{
TimeStamp
start
;
mThread
-
>
GetRunningEventDelay
(
&
aDelay
&
start
)
;
if
(
!
start
.
IsNull
(
)
)
{
aRunning
=
aNow
-
start
;
return
;
}
}
aDelay
=
TimeDuration
(
)
;
aRunning
=
TimeDuration
(
)
;
}
void
StartJSSampling
(
uint32_t
aJSFlags
)
{
MOZ_RELEASE_ASSERT
(
mJSSampling
=
=
INACTIVE
|
|
mJSSampling
=
=
INACTIVE_REQUESTED
)
;
mJSSampling
=
ACTIVE_REQUESTED
;
mJSFlags
=
aJSFlags
;
}
void
StopJSSampling
(
)
{
MOZ_RELEASE_ASSERT
(
mJSSampling
=
=
ACTIVE
|
|
mJSSampling
=
=
ACTIVE_REQUESTED
)
;
mJSSampling
=
INACTIVE_REQUESTED
;
}
protected
:
ThreadRegistrationLockedRWFromAnyThread
(
const
char
*
aName
const
void
*
aStackTop
)
:
ThreadRegistrationUnlockedReaderAndAtomicRWOnThread
(
aName
aStackTop
)
{
}
}
;
class
ThreadRegistrationLockedRWOnThread
:
public
ThreadRegistrationLockedRWFromAnyThread
{
public
:
void
SetJSContext
(
JSContext
*
aJSContext
)
;
void
ClearJSContext
(
)
;
void
PollJSSampling
(
)
;
public
:
ThreadRegistrationLockedRWOnThread
(
const
char
*
aName
const
void
*
aStackTop
)
:
ThreadRegistrationLockedRWFromAnyThread
(
aName
aStackTop
)
{
}
}
;
}
#
endif
