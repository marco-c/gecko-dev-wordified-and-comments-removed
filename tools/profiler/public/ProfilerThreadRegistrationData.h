#
ifndef
ProfilerThreadRegistrationData_h
#
define
ProfilerThreadRegistrationData_h
#
include
"
js
/
ProfilingFrameIterator
.
h
"
#
include
"
js
/
ProfilingStack
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ProfilerThreadPlatformData
.
h
"
#
include
"
mozilla
/
ProfilerThreadRegistrationInfo
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIThread
.
h
"
class
ProfiledThreadData
;
class
PSAutoLock
;
struct
JSContext
;
enum
class
ThreadProfilingFeatures
:
uint32_t
{
NotProfiled
=
0u
CPUUtilization
=
1u
<
<
0
Sampling
=
1u
<
<
1
Markers
=
1u
<
<
2
Any
=
CPUUtilization
|
Sampling
|
Markers
}
;
template
<
typename
.
.
.
Ts
>
[
[
nodiscard
]
]
constexpr
ThreadProfilingFeatures
Combine
(
ThreadProfilingFeatures
a1
Ts
.
.
.
as
)
{
static_assert
(
(
true
&
&
.
.
.
&
&
std
:
:
is_same_v
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
Ts
>
>
ThreadProfilingFeatures
>
)
)
;
return
static_cast
<
ThreadProfilingFeatures
>
(
(
static_cast
<
std
:
:
underlying_type_t
<
ThreadProfilingFeatures
>
>
(
a1
)
|
.
.
.
|
static_cast
<
std
:
:
underlying_type_t
<
ThreadProfilingFeatures
>
>
(
as
)
)
)
;
}
template
<
typename
.
.
.
Ts
>
[
[
nodiscard
]
]
constexpr
ThreadProfilingFeatures
Intersect
(
ThreadProfilingFeatures
a1
Ts
.
.
.
as
)
{
static_assert
(
(
true
&
&
.
.
.
&
&
std
:
:
is_same_v
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
Ts
>
>
ThreadProfilingFeatures
>
)
)
;
return
static_cast
<
ThreadProfilingFeatures
>
(
(
static_cast
<
std
:
:
underlying_type_t
<
ThreadProfilingFeatures
>
>
(
a1
)
&
.
.
.
&
static_cast
<
std
:
:
underlying_type_t
<
ThreadProfilingFeatures
>
>
(
as
)
)
)
;
}
template
<
typename
.
.
.
Ts
>
[
[
nodiscard
]
]
constexpr
bool
DoFeaturesIntersect
(
ThreadProfilingFeatures
a1
ThreadProfilingFeatures
a2
)
{
return
Intersect
(
a1
a2
)
!
=
ThreadProfilingFeatures
:
:
NotProfiled
;
}
namespace
mozilla
:
:
profiler
{
class
ThreadRegistrationData
{
public
:
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
static
constexpr
size_t
MAX_JS_FRAMES
=
1024
;
using
JsFrame
=
JS
:
:
ProfilingFrameIterator
:
:
Frame
;
using
JsFrameBuffer
=
JsFrame
[
MAX_JS_FRAMES
]
;
protected
:
ThreadRegistrationData
(
const
char
*
aName
const
void
*
aStackTop
)
;
#
ifdef
DEBUG
~
ThreadRegistrationData
(
)
{
MOZ_ASSERT
(
(
mProfilingFeatures
!
=
ThreadProfilingFeatures
:
:
NotProfiled
)
=
=
!
!
mProfiledThreadData
)
;
MOZ_ASSERT
(
!
mProfiledThreadData
"
mProfiledThreadData
pointer
should
have
been
reset
before
"
"
~
ThreadRegistrationData
"
)
;
}
#
endif
ThreadRegistrationInfo
mInfo
;
ProfilingStack
mProfilingStack
;
PlatformData
mPlatformData
;
const
void
*
const
mStackTop
;
nsCOMPtr
<
nsIThread
>
mThread
;
JSContext
*
mJSContext
=
nullptr
;
JsFrame
*
mJsFrameBuffer
=
nullptr
;
enum
{
INACTIVE
=
0
ACTIVE_REQUESTED
=
1
ACTIVE
=
2
INACTIVE_REQUESTED
=
3
}
mJSSampling
=
INACTIVE
;
uint32_t
mJSFlags
=
0
;
enum
class
JSInstrumentationFlags
{
StackSampling
=
0x1
TraceLogging
=
0x2
Allocations
=
0x4
}
;
[
[
nodiscard
]
]
bool
JSTracerEnabled
(
)
const
{
return
mJSFlags
&
uint32_t
(
JSInstrumentationFlags
:
:
TraceLogging
)
;
}
[
[
nodiscard
]
]
bool
JSAllocationsEnabled
(
)
const
{
return
mJSFlags
&
uint32_t
(
JSInstrumentationFlags
:
:
Allocations
)
;
}
static
const
int
AWAKE
=
0
;
static
const
int
SLEEPING_NOT_OBSERVED
=
1
;
static
const
int
SLEEPING_OBSERVED
=
2
;
Atomic
<
int
>
mSleep
{
AWAKE
}
;
Atomic
<
uint64_t
>
mThreadCpuTimeInNsAtLastSleep
{
0
}
;
#
ifdef
NIGHTLY_BUILD
Atomic
<
uint64_t
MemoryOrdering
:
:
Relaxed
>
mWakeCount
{
1
}
;
mutable
uint64_t
mAlreadyRecordedWakeCount
=
0
;
mutable
uint64_t
mAlreadyRecordedCpuTimeInMs
=
0
;
#
endif
Atomic
<
ThreadProfilingFeatures
MemoryOrdering
:
:
Relaxed
>
mProfilingFeatures
{
ThreadProfilingFeatures
:
:
NotProfiled
}
;
ProfiledThreadData
*
mProfiledThreadData
=
nullptr
;
}
;
class
ThreadRegistrationUnlockedConstReader
:
public
ThreadRegistrationData
{
public
:
[
[
nodiscard
]
]
const
ThreadRegistrationInfo
&
Info
(
)
const
{
return
mInfo
;
}
[
[
nodiscard
]
]
const
PlatformData
&
PlatformDataCRef
(
)
const
{
return
mPlatformData
;
}
[
[
nodiscard
]
]
const
void
*
StackTop
(
)
const
{
return
mStackTop
;
}
protected
:
ThreadRegistrationUnlockedConstReader
(
const
char
*
aName
const
void
*
aStackTop
)
:
ThreadRegistrationData
(
aName
aStackTop
)
{
}
}
;
class
ThreadRegistrationUnlockedConstReaderAndAtomicRW
:
public
ThreadRegistrationUnlockedConstReader
{
public
:
[
[
nodiscard
]
]
const
ProfilingStack
&
ProfilingStackCRef
(
)
const
{
return
mProfilingStack
;
}
[
[
nodiscard
]
]
ProfilingStack
&
ProfilingStackRef
(
)
{
return
mProfilingStack
;
}
[
[
nodiscard
]
]
ThreadProfilingFeatures
ProfilingFeatures
(
)
const
{
return
mProfilingFeatures
;
}
void
SetSleeping
(
)
{
MOZ_ASSERT
(
mSleep
=
=
AWAKE
)
;
mSleep
=
SLEEPING_NOT_OBSERVED
;
}
void
SetAwake
(
)
{
MOZ_ASSERT
(
mSleep
!
=
AWAKE
)
;
mSleep
=
AWAKE
;
#
ifdef
NIGHTLY_BUILD
+
+
mWakeCount
;
#
endif
}
uint64_t
GetNewCpuTimeInNs
(
)
{
uint64_t
newCpuTimeNs
;
if
(
!
GetCpuTimeSinceThreadStartInNs
(
&
newCpuTimeNs
PlatformDataCRef
(
)
)
)
{
newCpuTimeNs
=
0
;
}
uint64_t
before
=
mThreadCpuTimeInNsAtLastSleep
;
uint64_t
result
=
MOZ_LIKELY
(
newCpuTimeNs
>
before
)
?
newCpuTimeNs
-
before
:
0
;
mThreadCpuTimeInNsAtLastSleep
=
newCpuTimeNs
;
return
result
;
}
#
ifdef
NIGHTLY_BUILD
void
RecordWakeCount
(
)
const
;
#
endif
void
ReinitializeOnResume
(
)
{
(
void
)
mSleep
.
compareExchange
(
SLEEPING_OBSERVED
SLEEPING_NOT_OBSERVED
)
;
}
[
[
nodiscard
]
]
bool
CanDuplicateLastSampleDueToSleep
(
)
{
if
(
mSleep
=
=
AWAKE
)
{
return
false
;
}
if
(
mSleep
.
compareExchange
(
SLEEPING_NOT_OBSERVED
SLEEPING_OBSERVED
)
)
{
return
false
;
}
return
true
;
}
[
[
nodiscard
]
]
bool
IsSleeping
(
)
const
{
return
mSleep
!
=
AWAKE
;
}
protected
:
ThreadRegistrationUnlockedConstReaderAndAtomicRW
(
const
char
*
aName
const
void
*
aStackTop
)
:
ThreadRegistrationUnlockedConstReader
(
aName
aStackTop
)
{
}
}
;
class
ThreadRegistrationUnlockedRWForLockedProfiler
:
public
ThreadRegistrationUnlockedConstReaderAndAtomicRW
{
public
:
[
[
nodiscard
]
]
const
ProfiledThreadData
*
GetProfiledThreadData
(
const
PSAutoLock
&
)
const
{
return
mProfiledThreadData
;
}
[
[
nodiscard
]
]
ProfiledThreadData
*
GetProfiledThreadData
(
const
PSAutoLock
&
)
{
return
mProfiledThreadData
;
}
protected
:
ThreadRegistrationUnlockedRWForLockedProfiler
(
const
char
*
aName
const
void
*
aStackTop
)
:
ThreadRegistrationUnlockedConstReaderAndAtomicRW
(
aName
aStackTop
)
{
}
}
;
class
ThreadRegistrationUnlockedReaderAndAtomicRWOnThread
:
public
ThreadRegistrationUnlockedRWForLockedProfiler
{
public
:
[
[
nodiscard
]
]
JSContext
*
GetJSContext
(
)
const
{
return
mJSContext
;
}
protected
:
ThreadRegistrationUnlockedReaderAndAtomicRWOnThread
(
const
char
*
aName
const
void
*
aStackTop
)
:
ThreadRegistrationUnlockedRWForLockedProfiler
(
aName
aStackTop
)
{
}
}
;
class
ThreadRegistrationLockedRWFromAnyThread
:
public
ThreadRegistrationUnlockedReaderAndAtomicRWOnThread
{
public
:
void
SetProfilingFeaturesAndData
(
ThreadProfilingFeatures
aProfilingFeatures
ProfiledThreadData
*
aProfiledThreadData
const
PSAutoLock
&
)
;
void
ClearProfilingFeaturesAndData
(
const
PSAutoLock
&
)
;
[
[
nodiscard
]
]
JsFrame
*
GetJsFrameBuffer
(
)
const
{
return
mJsFrameBuffer
;
}
[
[
nodiscard
]
]
const
nsCOMPtr
<
nsIEventTarget
>
GetEventTarget
(
)
const
{
return
mThread
;
}
void
ResetMainThread
(
nsIThread
*
aThread
)
{
mThread
=
aThread
;
}
void
GetRunningEventDelay
(
const
TimeStamp
&
aNow
TimeDuration
&
aDelay
TimeDuration
&
aRunning
)
{
if
(
mThread
)
{
TimeStamp
start
;
mThread
-
>
GetRunningEventDelay
(
&
aDelay
&
start
)
;
if
(
!
start
.
IsNull
(
)
)
{
aRunning
=
aNow
-
start
;
return
;
}
}
aDelay
=
TimeDuration
(
)
;
aRunning
=
TimeDuration
(
)
;
}
void
StartJSSampling
(
uint32_t
aJSFlags
)
{
MOZ_RELEASE_ASSERT
(
mJSSampling
=
=
INACTIVE
|
|
mJSSampling
=
=
INACTIVE_REQUESTED
)
;
mJSSampling
=
ACTIVE_REQUESTED
;
mJSFlags
=
aJSFlags
;
}
void
StopJSSampling
(
)
{
MOZ_RELEASE_ASSERT
(
mJSSampling
=
=
ACTIVE
|
|
mJSSampling
=
=
ACTIVE_REQUESTED
)
;
mJSSampling
=
INACTIVE_REQUESTED
;
}
protected
:
ThreadRegistrationLockedRWFromAnyThread
(
const
char
*
aName
const
void
*
aStackTop
)
:
ThreadRegistrationUnlockedReaderAndAtomicRWOnThread
(
aName
aStackTop
)
{
}
}
;
class
ThreadRegistrationLockedRWOnThread
:
public
ThreadRegistrationLockedRWFromAnyThread
{
public
:
void
SetJSContext
(
JSContext
*
aJSContext
)
;
void
ClearJSContext
(
)
;
void
PollJSSampling
(
)
;
public
:
ThreadRegistrationLockedRWOnThread
(
const
char
*
aName
const
void
*
aStackTop
)
:
ThreadRegistrationLockedRWFromAnyThread
(
aName
aStackTop
)
{
}
}
;
}
#
endif
