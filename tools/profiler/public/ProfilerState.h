#
ifndef
ProfilerState_h
#
define
ProfilerState_h
#
include
<
mozilla
/
DefineEnum
.
h
>
#
include
<
mozilla
/
EnumSet
.
h
>
#
include
"
mozilla
/
ProfilerUtils
.
h
"
#
include
<
functional
>
#
if
defined
(
__APPLE__
)
&
&
defined
(
__aarch64__
)
#
define
POWER_HELP
"
Sample
per
process
power
use
"
#
elif
defined
(
__APPLE__
)
&
&
defined
(
__x86_64__
)
#
define
POWER_HELP
\
"
Record
the
power
used
by
the
entire
system
with
each
sample
.
"
#
elif
defined
(
__linux__
)
&
&
defined
(
__x86_64__
)
#
define
POWER_HELP
\
"
Record
the
power
used
by
the
entire
system
with
each
sample
.
"
\
"
Only
available
with
Intel
CPUs
and
requires
setting
"
\
"
the
sysctl
kernel
.
perf_event_paranoid
to
0
.
"
#
elif
defined
(
_MSC_VER
)
#
define
POWER_HELP
\
"
Record
the
value
of
every
energy
meter
available
on
the
system
with
"
\
"
each
sample
.
Only
available
on
Windows
11
with
Intel
CPUs
.
"
#
else
#
define
POWER_HELP
"
Not
supported
on
this
platform
.
"
#
endif
#
define
PROFILER_FOR_EACH_FEATURE
(
MACRO
)
\
MACRO
(
0
"
java
"
Java
"
Profile
Java
code
Android
only
"
)
\
\
MACRO
(
1
"
js
"
JS
\
"
Get
the
JS
engine
to
expose
the
JS
stack
to
the
profiler
"
)
\
\
MACRO
(
2
"
mainthreadio
"
MainThreadIO
"
Add
main
thread
file
I
/
O
"
)
\
\
MACRO
(
3
"
fileio
"
FileIO
\
"
Add
file
I
/
O
from
all
profiled
threads
implies
mainthreadio
"
)
\
\
MACRO
(
4
"
fileioall
"
FileIOAll
\
"
Add
file
I
/
O
from
all
threads
implies
fileio
"
)
\
\
MACRO
(
5
"
nomarkerstacks
"
NoMarkerStacks
\
"
Markers
do
not
capture
stacks
to
reduce
overhead
"
)
\
\
MACRO
(
6
"
screenshots
"
Screenshots
\
"
Take
a
snapshot
of
the
window
on
every
composition
"
)
\
\
MACRO
(
7
"
seqstyle
"
SequentialStyle
\
"
Disable
parallel
traversal
in
styling
"
)
\
\
MACRO
(
8
"
stackwalk
"
StackWalk
\
"
Walk
the
C
+
+
stack
not
available
on
all
platforms
"
)
\
\
MACRO
(
9
"
jsallocations
"
JSAllocations
\
"
Have
the
JavaScript
engine
track
allocations
"
)
\
\
MACRO
(
10
"
nostacksampling
"
NoStackSampling
\
"
Disable
all
stack
sampling
:
Cancels
\
"
js
\
"
\
"
stackwalk
\
"
and
"
\
"
labels
"
)
\
\
MACRO
(
11
"
nativeallocations
"
NativeAllocations
\
"
Collect
the
stacks
from
a
smaller
subset
of
all
native
"
\
"
allocations
biasing
towards
collecting
larger
allocations
"
)
\
\
MACRO
(
12
"
ipcmessages
"
IPCMessages
\
"
Have
the
IPC
layer
track
cross
-
process
messages
"
)
\
\
MACRO
(
13
"
audiocallbacktracing
"
AudioCallbackTracing
\
"
Audio
callback
tracing
"
)
\
\
MACRO
(
14
"
cpu
"
CPUUtilization
"
CPU
utilization
"
)
\
\
MACRO
(
15
"
notimerresolutionchange
"
NoTimerResolutionChange
\
"
Do
not
adjust
the
timer
resolution
for
sampling
so
that
other
"
\
"
Firefox
timers
do
not
get
affected
"
)
\
\
MACRO
(
16
"
cpuallthreads
"
CPUAllThreads
\
"
Sample
the
CPU
utilization
of
all
registered
threads
"
)
\
\
MACRO
(
17
"
samplingallthreads
"
SamplingAllThreads
\
"
Sample
the
stacks
of
all
registered
threads
"
)
\
\
MACRO
(
18
"
markersallthreads
"
MarkersAllThreads
\
"
Record
markers
from
all
registered
threads
"
)
\
\
MACRO
(
19
"
unregisteredthreads
"
UnregisteredThreads
\
"
Discover
and
profile
unregistered
threads
-
-
beware
:
expensive
!
"
)
\
\
MACRO
(
20
"
processcpu
"
ProcessCPU
\
"
Sample
the
CPU
utilization
of
each
process
"
)
\
\
MACRO
(
21
"
power
"
Power
POWER_HELP
)
\
\
MACRO
(
22
"
cpufreq
"
CPUFrequency
\
"
Record
the
clock
frequency
of
"
\
"
every
CPU
core
for
every
profiler
sample
.
"
)
\
\
MACRO
(
23
"
bandwidth
"
Bandwidth
\
"
Record
the
network
bandwidth
used
for
every
profiler
sample
.
"
)
struct
ProfilerFeature
{
#
define
DECLARE
(
n_
str_
Name_
desc_
)
\
static
constexpr
uint32_t
Name_
=
(
1u
<
<
n_
)
;
\
[
[
nodiscard
]
]
static
constexpr
bool
Has
#
#
Name_
(
uint32_t
aFeatures
)
{
\
return
aFeatures
&
Name_
;
\
}
\
static
constexpr
void
Set
#
#
Name_
(
uint32_t
&
aFeatures
)
{
\
aFeatures
|
=
Name_
;
\
}
\
static
constexpr
void
Clear
#
#
Name_
(
uint32_t
&
aFeatures
)
{
\
aFeatures
&
=
~
Name_
;
\
}
PROFILER_FOR_EACH_FEATURE
(
DECLARE
)
#
undef
DECLARE
}
;
MOZ_DEFINE_ENUM_CLASS
(
ProfilingState
(
AlreadyActive
RemovingCallback
Started
Pausing
Resumed
GeneratingProfile
Stopping
ShuttingDown
)
)
;
[
[
nodiscard
]
]
inline
static
const
char
*
ProfilingStateToString
(
ProfilingState
aProfilingState
)
{
switch
(
aProfilingState
)
{
case
ProfilingState
:
:
AlreadyActive
:
return
"
Profiler
already
active
"
;
case
ProfilingState
:
:
RemovingCallback
:
return
"
Callback
being
removed
"
;
case
ProfilingState
:
:
Started
:
return
"
Profiler
started
"
;
case
ProfilingState
:
:
Pausing
:
return
"
Profiler
pausing
"
;
case
ProfilingState
:
:
Resumed
:
return
"
Profiler
resumed
"
;
case
ProfilingState
:
:
GeneratingProfile
:
return
"
Generating
profile
"
;
case
ProfilingState
:
:
Stopping
:
return
"
Profiler
stopping
"
;
case
ProfilingState
:
:
ShuttingDown
:
return
"
Profiler
shutting
down
"
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
ProfilingState
enum
value
"
)
;
return
"
?
"
;
}
}
using
ProfilingStateSet
=
mozilla
:
:
EnumSet
<
ProfilingState
>
;
[
[
nodiscard
]
]
constexpr
ProfilingStateSet
AllProfilingStates
(
)
{
ProfilingStateSet
set
;
using
Value
=
std
:
:
underlying_type_t
<
ProfilingState
>
;
for
(
Value
stateValue
=
0
;
stateValue
<
=
static_cast
<
Value
>
(
kHighestProfilingState
)
;
+
+
stateValue
)
{
set
+
=
static_cast
<
ProfilingState
>
(
stateValue
)
;
}
return
set
;
}
using
ProfilingStateChangeCallback
=
std
:
:
function
<
void
(
ProfilingState
)
>
;
#
ifndef
MOZ_GECKO_PROFILER
[
[
nodiscard
]
]
inline
bool
profiler_is_active
(
)
{
return
false
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_active_and_unpaused
(
)
{
return
false
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_collecting_markers
(
)
{
return
false
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_etw_collecting_markers
(
)
{
return
false
;
}
[
[
nodiscard
]
]
inline
bool
profiler_feature_active
(
uint32_t
aFeature
)
{
return
false
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_locked_on_current_thread
(
)
{
return
false
;
}
inline
void
profiler_add_state_change_callback
(
ProfilingStateSet
aProfilingStateSet
ProfilingStateChangeCallback
&
&
aCallback
uintptr_t
aUniqueIdentifier
=
0
)
{
}
inline
void
profiler_remove_state_change_callback
(
uintptr_t
aUniqueIdentifier
)
{
}
#
else
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
stdint
.
h
>
namespace
mozilla
:
:
profiler
:
:
detail
{
class
RacyFeatures
{
public
:
static
void
SetActive
(
uint32_t
aFeatures
)
{
sActiveAndFeatures
=
Active
|
aFeatures
;
}
static
void
SetETWCollectionActive
(
)
{
sActiveAndFeatures
|
=
ETWCollectionEnabled
;
}
static
void
SetETWCollectionInactive
(
)
{
sActiveAndFeatures
&
=
~
ETWCollectionEnabled
;
}
static
void
SetInactive
(
)
{
sActiveAndFeatures
=
0
;
}
static
void
SetPaused
(
)
{
sActiveAndFeatures
|
=
Paused
;
}
static
void
SetUnpaused
(
)
{
sActiveAndFeatures
&
=
~
Paused
;
}
static
void
SetSamplingPaused
(
)
{
sActiveAndFeatures
|
=
SamplingPaused
;
}
static
void
SetSamplingUnpaused
(
)
{
sActiveAndFeatures
&
=
~
SamplingPaused
;
}
[
[
nodiscard
]
]
static
Maybe
<
uint32_t
>
FeaturesIfActive
(
)
{
if
(
uint32_t
af
=
sActiveAndFeatures
;
af
&
Active
)
{
return
Some
(
af
&
~
(
Active
|
Paused
|
SamplingPaused
)
)
;
}
return
Nothing
(
)
;
}
[
[
nodiscard
]
]
static
Maybe
<
uint32_t
>
FeaturesIfActiveAndUnpaused
(
)
{
if
(
uint32_t
af
=
sActiveAndFeatures
;
(
af
&
(
Active
|
Paused
)
)
=
=
Active
)
{
return
Some
(
af
&
~
(
Active
|
SamplingPaused
)
)
;
}
return
Nothing
(
)
;
}
[
[
nodiscard
]
]
static
bool
IsActive
(
)
{
return
uint32_t
(
sActiveAndFeatures
)
&
Active
;
}
[
[
nodiscard
]
]
static
bool
IsActiveWithFeature
(
uint32_t
aFeature
)
{
uint32_t
af
=
sActiveAndFeatures
;
return
(
af
&
Active
)
&
&
(
af
&
aFeature
)
;
}
[
[
nodiscard
]
]
static
bool
IsActiveWithoutFeature
(
uint32_t
aFeature
)
{
uint32_t
af
=
sActiveAndFeatures
;
return
(
af
&
Active
)
&
&
!
(
af
&
aFeature
)
;
}
[
[
nodiscard
]
]
static
bool
IsActiveAndUnpaused
(
)
{
uint32_t
af
=
sActiveAndFeatures
;
return
(
af
&
Active
)
&
&
!
(
af
&
Paused
)
;
}
[
[
nodiscard
]
]
static
bool
IsActiveAndSamplingUnpaused
(
)
{
uint32_t
af
=
sActiveAndFeatures
;
return
(
af
&
Active
)
&
&
!
(
af
&
(
Paused
|
SamplingPaused
)
)
;
}
[
[
nodiscard
]
]
static
bool
IsCollectingMarkers
(
)
{
uint32_t
af
=
sActiveAndFeatures
;
return
(
(
af
&
Active
)
&
&
!
(
af
&
Paused
)
)
|
|
(
af
&
ETWCollectionEnabled
)
;
}
[
[
nodiscard
]
]
static
bool
IsETWCollecting
(
)
{
uint32_t
af
=
sActiveAndFeatures
;
return
(
af
&
ETWCollectionEnabled
)
;
}
private
:
static
constexpr
uint32_t
Active
=
1u
<
<
31
;
static
constexpr
uint32_t
Paused
=
1u
<
<
30
;
static
constexpr
uint32_t
SamplingPaused
=
1u
<
<
29
;
static
constexpr
uint32_t
ETWCollectionEnabled
=
1u
<
<
28
;
#
define
NO_OVERLAP
(
n_
str_
Name_
desc_
)
\
static_assert
(
ProfilerFeature
:
:
Name_
!
=
SamplingPaused
\
"
bad
feature
value
"
)
;
PROFILER_FOR_EACH_FEATURE
(
NO_OVERLAP
)
;
#
undef
NO_OVERLAP
static
Atomic
<
uint32_t
MemoryOrdering
:
:
Relaxed
>
sActiveAndFeatures
;
}
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_active
(
)
{
return
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
:
:
IsActive
(
)
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_active_and_unpaused
(
)
{
return
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
:
:
IsActiveAndUnpaused
(
)
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_collecting_markers
(
)
{
return
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
:
:
IsCollectingMarkers
(
)
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_etw_collecting_markers
(
)
{
return
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
:
:
IsETWCollecting
(
)
;
}
[
[
nodiscard
]
]
bool
profiler_is_paused
(
)
;
[
[
nodiscard
]
]
bool
profiler_is_sampling_paused
(
)
;
[
[
nodiscard
]
]
uint32_t
profiler_get_available_features
(
)
;
[
[
nodiscard
]
]
inline
mozilla
:
:
Maybe
<
uint32_t
>
profiler_features_if_active
(
)
{
return
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
:
:
FeaturesIfActive
(
)
;
}
[
[
nodiscard
]
]
inline
mozilla
:
:
Maybe
<
uint32_t
>
profiler_features_if_active_and_unpaused
(
)
{
return
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
:
:
FeaturesIfActiveAndUnpaused
(
)
;
}
[
[
nodiscard
]
]
bool
profiler_feature_active
(
uint32_t
aFeature
)
;
[
[
nodiscard
]
]
bool
profiler_active_without_feature
(
uint32_t
aFeature
)
;
[
[
nodiscard
]
]
bool
profiler_is_locked_on_current_thread
(
)
;
void
profiler_add_state_change_callback
(
ProfilingStateSet
aProfilingStateSet
ProfilingStateChangeCallback
&
&
aCallback
uintptr_t
aUniqueIdentifier
=
0
)
;
void
profiler_remove_state_change_callback
(
uintptr_t
aUniqueIdentifier
)
;
#
endif
#
endif
