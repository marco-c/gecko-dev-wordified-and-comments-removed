#
ifndef
ProfilerState_h
#
define
ProfilerState_h
#
include
<
mozilla
/
DefineEnum
.
h
>
#
include
<
mozilla
/
EnumSet
.
h
>
#
include
<
functional
>
#
define
PROFILER_FOR_EACH_FEATURE
(
MACRO
)
\
MACRO
(
0
"
java
"
Java
"
Profile
Java
code
Android
only
"
)
\
\
MACRO
(
1
"
js
"
JS
\
"
Get
the
JS
engine
to
expose
the
JS
stack
to
the
profiler
"
)
\
\
/
*
The
DevTools
profiler
doesn
'
t
want
the
native
addresses
.
*
/
\
MACRO
(
2
"
leaf
"
Leaf
"
Include
the
C
+
+
leaf
node
if
not
stackwalking
"
)
\
\
MACRO
(
3
"
mainthreadio
"
MainThreadIO
"
Add
main
thread
file
I
/
O
"
)
\
\
MACRO
(
4
"
fileio
"
FileIO
\
"
Add
file
I
/
O
from
all
profiled
threads
implies
mainthreadio
"
)
\
\
MACRO
(
5
"
fileioall
"
FileIOAll
\
"
Add
file
I
/
O
from
all
threads
implies
fileio
"
)
\
\
MACRO
(
6
"
noiostacks
"
NoIOStacks
\
"
File
I
/
O
markers
do
not
capture
stacks
to
reduce
overhead
"
)
\
\
MACRO
(
7
"
screenshots
"
Screenshots
\
"
Take
a
snapshot
of
the
window
on
every
composition
"
)
\
\
MACRO
(
8
"
seqstyle
"
SequentialStyle
\
"
Disable
parallel
traversal
in
styling
"
)
\
\
MACRO
(
9
"
stackwalk
"
StackWalk
\
"
Walk
the
C
+
+
stack
not
available
on
all
platforms
"
)
\
\
MACRO
(
10
"
threads
"
Threads
"
Profile
the
registered
secondary
threads
"
)
\
\
MACRO
(
11
"
jstracer
"
JSTracer
"
Enable
tracing
of
the
JavaScript
engine
"
)
\
\
MACRO
(
12
"
jsallocations
"
JSAllocations
\
"
Have
the
JavaScript
engine
track
allocations
"
)
\
\
MACRO
(
13
"
nostacksampling
"
NoStackSampling
\
"
Disable
all
stack
sampling
:
Cancels
\
"
js
\
"
\
"
leaf
\
"
"
\
"
\
"
stackwalk
\
"
and
labels
"
)
\
\
MACRO
(
14
"
preferencereads
"
PreferenceReads
\
"
Track
when
preferences
are
read
"
)
\
\
MACRO
(
15
"
nativeallocations
"
NativeAllocations
\
"
Collect
the
stacks
from
a
smaller
subset
of
all
native
"
\
"
allocations
biasing
towards
collecting
larger
allocations
"
)
\
\
MACRO
(
16
"
ipcmessages
"
IPCMessages
\
"
Have
the
IPC
layer
track
cross
-
process
messages
"
)
\
\
MACRO
(
17
"
audiocallbacktracing
"
AudioCallbackTracing
\
"
Audio
callback
tracing
"
)
\
\
MACRO
(
18
"
cpu
"
CPUUtilization
"
CPU
utilization
"
)
\
\
MACRO
(
19
"
notimerresolutionchange
"
NoTimerResolutionChange
\
"
Do
not
adjust
the
timer
resolution
for
sampling
so
that
other
"
\
"
Firefox
timers
do
not
get
affected
"
)
struct
ProfilerFeature
{
#
define
DECLARE
(
n_
str_
Name_
desc_
)
\
static
constexpr
uint32_t
Name_
=
(
1u
<
<
n_
)
;
\
[
[
nodiscard
]
]
static
constexpr
bool
Has
#
#
Name_
(
uint32_t
aFeatures
)
{
\
return
aFeatures
&
Name_
;
\
}
\
static
constexpr
void
Set
#
#
Name_
(
uint32_t
&
aFeatures
)
{
\
aFeatures
|
=
Name_
;
\
}
\
static
constexpr
void
Clear
#
#
Name_
(
uint32_t
&
aFeatures
)
{
\
aFeatures
&
=
~
Name_
;
\
}
PROFILER_FOR_EACH_FEATURE
(
DECLARE
)
#
undef
DECLARE
}
;
MOZ_DEFINE_ENUM_CLASS
(
ProfilingState
(
AlreadyActive
RemovingCallback
Started
Pausing
Resumed
GeneratingProfile
Stopping
ShuttingDown
)
)
;
[
[
nodiscard
]
]
inline
static
const
char
*
ProfilingStateToString
(
ProfilingState
aProfilingState
)
{
switch
(
aProfilingState
)
{
case
ProfilingState
:
:
AlreadyActive
:
return
"
Profiler
already
active
"
;
case
ProfilingState
:
:
RemovingCallback
:
return
"
Callback
being
removed
"
;
case
ProfilingState
:
:
Started
:
return
"
Profiler
started
"
;
case
ProfilingState
:
:
Pausing
:
return
"
Profiler
pausing
"
;
case
ProfilingState
:
:
Resumed
:
return
"
Profiler
resumed
"
;
case
ProfilingState
:
:
GeneratingProfile
:
return
"
Generating
profile
"
;
case
ProfilingState
:
:
Stopping
:
return
"
Profiler
stopping
"
;
case
ProfilingState
:
:
ShuttingDown
:
return
"
Profiler
shutting
down
"
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
ProfilingState
enum
value
"
)
;
return
"
?
"
;
}
}
using
ProfilingStateSet
=
mozilla
:
:
EnumSet
<
ProfilingState
>
;
[
[
nodiscard
]
]
constexpr
ProfilingStateSet
AllProfilingStates
(
)
{
ProfilingStateSet
set
;
using
Value
=
std
:
:
underlying_type_t
<
ProfilingState
>
;
for
(
Value
stateValue
=
0
;
stateValue
<
=
static_cast
<
Value
>
(
kHighestProfilingState
)
;
+
+
stateValue
)
{
set
+
=
static_cast
<
ProfilingState
>
(
stateValue
)
;
}
return
set
;
}
using
ProfilingStateChangeCallback
=
std
:
:
function
<
void
(
ProfilingState
)
>
;
#
ifndef
MOZ_GECKO_PROFILER
[
[
nodiscard
]
]
inline
bool
profiler_is_active
(
)
{
return
false
;
}
[
[
nodiscard
]
]
inline
bool
profiler_can_accept_markers
(
)
{
return
false
;
}
[
[
nodiscard
]
]
inline
bool
profiler_thread_is_being_profiled
(
)
{
return
false
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_active_and_thread_is_registered
(
)
{
return
false
;
}
[
[
nodiscard
]
]
inline
bool
profiler_feature_active
(
uint32_t
aFeature
)
{
return
false
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_locked_on_current_thread
(
)
{
return
false
;
}
[
[
nodiscard
]
]
inline
int
profiler_current_thread_id
(
)
{
return
0
;
}
inline
void
profiler_add_state_change_callback
(
ProfilingStateSet
aProfilingStateSet
ProfilingStateChangeCallback
&
&
aCallback
uintptr_t
aUniqueIdentifier
=
0
)
{
}
inline
void
profiler_remove_state_change_callback
(
uintptr_t
aUniqueIdentifier
)
{
}
#
else
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
stdint
.
h
>
namespace
mozilla
:
:
profiler
:
:
detail
{
class
RacyFeatures
{
public
:
static
void
SetActive
(
uint32_t
aFeatures
)
{
sActiveAndFeatures
=
Active
|
aFeatures
;
}
static
void
SetInactive
(
)
{
sActiveAndFeatures
=
0
;
}
static
void
SetPaused
(
)
{
sActiveAndFeatures
|
=
Paused
;
}
static
void
SetUnpaused
(
)
{
sActiveAndFeatures
&
=
~
Paused
;
}
static
void
SetSamplingPaused
(
)
{
sActiveAndFeatures
|
=
SamplingPaused
;
}
static
void
SetSamplingUnpaused
(
)
{
sActiveAndFeatures
&
=
~
SamplingPaused
;
}
[
[
nodiscard
]
]
static
mozilla
:
:
Maybe
<
uint32_t
>
FeaturesIfActive
(
)
{
if
(
uint32_t
af
=
sActiveAndFeatures
;
af
&
Active
)
{
return
Some
(
af
&
~
(
Active
|
Paused
|
SamplingPaused
)
)
;
}
return
Nothing
(
)
;
}
[
[
nodiscard
]
]
static
mozilla
:
:
Maybe
<
uint32_t
>
FeaturesIfActiveAndUnpaused
(
)
{
if
(
uint32_t
af
=
sActiveAndFeatures
;
(
af
&
(
Active
|
Paused
)
)
=
=
Active
)
{
return
Some
(
af
&
~
(
Active
|
SamplingPaused
)
)
;
}
return
Nothing
(
)
;
}
[
[
nodiscard
]
]
static
bool
IsActive
(
)
{
return
uint32_t
(
sActiveAndFeatures
)
&
Active
;
}
[
[
nodiscard
]
]
static
bool
IsActiveWithFeature
(
uint32_t
aFeature
)
{
uint32_t
af
=
sActiveAndFeatures
;
return
(
af
&
Active
)
&
&
(
af
&
aFeature
)
;
}
[
[
nodiscard
]
]
static
bool
IsActiveAndUnpaused
(
)
{
uint32_t
af
=
sActiveAndFeatures
;
return
(
af
&
Active
)
&
&
!
(
af
&
Paused
)
;
}
[
[
nodiscard
]
]
static
bool
IsActiveAndSamplingUnpaused
(
)
{
uint32_t
af
=
sActiveAndFeatures
;
return
(
af
&
Active
)
&
&
!
(
af
&
(
Paused
|
SamplingPaused
)
)
;
}
private
:
static
constexpr
uint32_t
Active
=
1u
<
<
31
;
static
constexpr
uint32_t
Paused
=
1u
<
<
30
;
static
constexpr
uint32_t
SamplingPaused
=
1u
<
<
29
;
#
define
NO_OVERLAP
(
n_
str_
Name_
desc_
)
\
static_assert
(
ProfilerFeature
:
:
Name_
!
=
SamplingPaused
\
"
bad
feature
value
"
)
;
PROFILER_FOR_EACH_FEATURE
(
NO_OVERLAP
)
;
#
undef
NO_OVERLAP
static
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
MemoryOrdering
:
:
Relaxed
>
sActiveAndFeatures
;
}
;
[
[
nodiscard
]
]
bool
IsThreadBeingProfiled
(
)
;
[
[
nodiscard
]
]
bool
IsThreadRegistered
(
)
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_active
(
)
{
return
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
:
:
IsActive
(
)
;
}
[
[
nodiscard
]
]
inline
bool
profiler_can_accept_markers
(
)
{
return
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
:
:
IsActiveAndUnpaused
(
)
;
}
[
[
nodiscard
]
]
inline
bool
profiler_thread_is_being_profiled
(
)
{
return
profiler_is_active
(
)
&
&
mozilla
:
:
profiler
:
:
detail
:
:
IsThreadBeingProfiled
(
)
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_active_and_thread_is_registered
(
)
{
return
profiler_is_active
(
)
&
&
mozilla
:
:
profiler
:
:
detail
:
:
IsThreadRegistered
(
)
;
}
[
[
nodiscard
]
]
bool
profiler_is_paused
(
)
;
[
[
nodiscard
]
]
bool
profiler_is_sampling_paused
(
)
;
[
[
nodiscard
]
]
bool
profiler_thread_is_sleeping
(
)
;
[
[
nodiscard
]
]
uint32_t
profiler_get_available_features
(
)
;
[
[
nodiscard
]
]
inline
mozilla
:
:
Maybe
<
uint32_t
>
profiler_features_if_active
(
)
{
return
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
:
:
FeaturesIfActive
(
)
;
}
[
[
nodiscard
]
]
inline
mozilla
:
:
Maybe
<
uint32_t
>
profiler_features_if_active_and_unpaused
(
)
{
return
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
:
:
FeaturesIfActiveAndUnpaused
(
)
;
}
[
[
nodiscard
]
]
bool
profiler_feature_active
(
uint32_t
aFeature
)
;
[
[
nodiscard
]
]
int
profiler_current_process_id
(
)
;
[
[
nodiscard
]
]
int
profiler_current_thread_id
(
)
;
namespace
mozilla
:
:
profiler
:
:
detail
{
extern
int
scProfilerMainThreadId
;
}
[
[
nodiscard
]
]
inline
int
profiler_main_thread_id
(
)
{
return
mozilla
:
:
profiler
:
:
detail
:
:
scProfilerMainThreadId
;
}
[
[
nodiscard
]
]
inline
bool
profiler_is_main_thread
(
)
{
return
profiler_current_thread_id
(
)
=
=
profiler_main_thread_id
(
)
;
}
[
[
nodiscard
]
]
bool
profiler_is_locked_on_current_thread
(
)
;
void
profiler_add_state_change_callback
(
ProfilingStateSet
aProfilingStateSet
ProfilingStateChangeCallback
&
&
aCallback
uintptr_t
aUniqueIdentifier
=
0
)
;
void
profiler_remove_state_change_callback
(
uintptr_t
aUniqueIdentifier
)
;
#
endif
#
endif
