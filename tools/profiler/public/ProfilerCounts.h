#
ifndef
ProfilerCounts_h
#
define
ProfilerCounts_h
#
ifndef
MOZ_GECKO_PROFILER
#
define
PROFILER_DEFINE_COUNT_TOTAL
(
label
category
description
)
#
define
PROFILER_DEFINE_COUNT
(
label
category
description
)
#
define
PROFILER_DEFINE_STATIC_COUNT_TOTAL
(
label
category
description
)
#
define
AUTO_PROFILER_TOTAL
(
label
count
)
#
define
AUTO_PROFILER_COUNT
(
label
)
#
define
AUTO_PROFILER_STATIC_COUNT
(
label
count
)
#
else
#
include
"
mozilla
/
Atomics
.
h
"
class
BaseProfilerCount
;
void
profiler_add_sampled_counter
(
BaseProfilerCount
*
aCounter
)
;
void
profiler_remove_sampled_counter
(
BaseProfilerCount
*
aCounter
)
;
typedef
mozilla
:
:
Atomic
<
int64_t
mozilla
:
:
MemoryOrdering
:
:
Relaxed
>
ProfilerAtomicSigned
;
typedef
mozilla
:
:
Atomic
<
uint64_t
mozilla
:
:
MemoryOrdering
:
:
Relaxed
>
ProfilerAtomicUnsigned
;
class
BaseProfilerCount
{
public
:
BaseProfilerCount
(
const
char
*
aLabel
ProfilerAtomicSigned
*
aCounter
ProfilerAtomicUnsigned
*
aNumber
const
char
*
aCategory
const
char
*
aDescription
)
:
mLabel
(
aLabel
)
mCategory
(
aCategory
)
mDescription
(
aDescription
)
mCounter
(
aCounter
)
mNumber
(
aNumber
)
{
#
define
COUNTER_CANARY
0xDEADBEEF
#
ifdef
DEBUG
mCanary
=
COUNTER_CANARY
;
mPrevNumber
=
0
;
#
endif
}
#
ifdef
DEBUG
~
BaseProfilerCount
(
)
{
mCanary
=
0
;
}
#
endif
void
Sample
(
int64_t
&
aCounter
uint64_t
&
aNumber
)
{
MOZ_ASSERT
(
mCanary
=
=
COUNTER_CANARY
)
;
aCounter
=
*
mCounter
;
aNumber
=
mNumber
?
*
mNumber
:
0
;
#
ifdef
DEBUG
MOZ_ASSERT
(
aNumber
>
=
mPrevNumber
)
;
mPrevNumber
=
aNumber
;
#
endif
}
const
char
*
mLabel
;
const
char
*
mCategory
;
const
char
*
mDescription
;
ProfilerAtomicSigned
*
mCounter
;
ProfilerAtomicUnsigned
*
mNumber
;
#
ifdef
DEBUG
uint32_t
mCanary
;
uint64_t
mPrevNumber
;
#
endif
}
;
class
ProfilerCounter
final
:
public
BaseProfilerCount
{
public
:
ProfilerCounter
(
const
char
*
aLabel
const
char
*
aCategory
const
char
*
aDescription
)
:
BaseProfilerCount
(
aLabel
&
mCounter
nullptr
aCategory
aDescription
)
{
profiler_add_sampled_counter
(
this
)
;
}
virtual
~
ProfilerCounter
(
)
{
profiler_remove_sampled_counter
(
this
)
;
}
BaseProfilerCount
&
operator
+
+
(
)
{
Add
(
1
)
;
return
*
this
;
}
void
Add
(
int64_t
aNumber
)
{
mCounter
+
=
aNumber
;
}
ProfilerAtomicSigned
mCounter
;
}
;
class
ProfilerCounterTotal
final
:
public
BaseProfilerCount
{
public
:
ProfilerCounterTotal
(
const
char
*
aLabel
const
char
*
aCategory
const
char
*
aDescription
)
:
BaseProfilerCount
(
aLabel
&
mCounter
&
mNumber
aCategory
aDescription
)
{
profiler_add_sampled_counter
(
this
)
;
}
virtual
~
ProfilerCounterTotal
(
)
{
profiler_remove_sampled_counter
(
this
)
;
}
BaseProfilerCount
&
operator
+
+
(
)
{
Add
(
1
)
;
return
*
this
;
}
void
Add
(
int64_t
aNumber
)
{
mCounter
+
=
aNumber
;
mNumber
+
+
;
}
ProfilerAtomicSigned
mCounter
;
ProfilerAtomicUnsigned
mNumber
;
}
;
#
define
PROFILER_DEFINE_COUNT_TOTAL
(
label
category
description
)
\
ProfilerAtomicSigned
profiler_count_
#
#
label
(
0
)
;
\
ProfilerAtomicUnsigned
profiler_number_
#
#
label
(
0
)
;
\
const
char
profiler_category_
#
#
label
[
]
=
category
;
\
const
char
profiler_description_
#
#
label
[
]
=
description
;
\
mozilla
:
:
UniquePtr
<
BaseProfilerCount
>
AutoCount_
#
#
label
;
#
define
PROFILER_DEFINE_COUNT
(
label
category
description
)
\
ProfilerAtomicSigned
profiler_count_
#
#
label
(
0
)
;
\
const
char
profiler_category_
#
#
label
[
]
=
category
;
\
const
char
profiler_description_
#
#
label
[
]
=
description
;
\
mozilla
:
:
UniquePtr
<
BaseProfilerCount
>
AutoCount_
#
#
label
;
#
define
PROFILER_DEFINE_STATIC_COUNT_TOTAL
(
label
category
description
)
\
ProfilerAtomicSigned
profiler_count_
#
#
label
(
0
)
;
\
ProfilerAtomicUnsigned
profiler_number_
#
#
label
(
0
)
;
\
BaseProfilerCount
AutoCount_
#
#
label
(
#
label
&
profiler_count_
#
#
label
\
&
profiler_number_
#
#
label
category
\
description
)
;
#
define
AUTO_PROFILER_COUNT_TOTAL
(
label
count
)
\
do
{
\
profiler_number_
#
#
label
+
+
;
/
*
do
this
first
*
/
\
profiler_count_
#
#
label
+
=
count
;
\
if
(
!
AutoCount_
#
#
label
)
{
\
/
*
Ignore
that
we
could
call
this
twice
in
theory
and
that
we
leak
\
*
them
\
*
/
\
AutoCount_
#
#
label
.
reset
(
new
BaseProfilerCount
(
\
#
label
&
profiler_count_
#
#
label
&
profiler_number_
#
#
label
\
profiler_category_
#
#
label
profiler_description_
#
#
label
)
)
;
\
profiler_add_sampled_counter
(
AutoCount_
#
#
label
.
get
(
)
)
;
\
}
\
}
while
(
0
)
#
define
AUTO_PROFILER_COUNT
(
label
count
)
\
do
{
\
profiler_count_
#
#
label
+
=
count
;
/
*
do
this
first
*
/
\
if
(
!
AutoCount_
#
#
label
)
{
\
/
*
Ignore
that
we
could
call
this
twice
in
theory
and
that
we
leak
\
*
them
\
*
/
\
AutoCount_
#
#
label
.
reset
(
new
BaseProfilerCount
(
\
#
label
nullptr
&
profiler_number_
#
#
label
\
profiler_category_
#
#
label
profiler_description_
#
#
label
)
)
;
\
profiler_add_sampled_counter
(
AutoCount_
#
#
label
.
get
(
)
)
;
\
}
\
}
while
(
0
)
#
define
AUTO_PROFILER_STATIC_COUNT
(
label
count
)
\
do
{
\
profiler_number_
#
#
label
+
+
;
/
*
do
this
first
*
/
\
profiler_count_
#
#
label
+
=
count
;
\
}
while
(
0
)
#
define
AUTO_PROFILER_FORCE_ALLOCATION
(
label
)
\
do
{
\
if
(
!
AutoCount_
#
#
label
)
{
\
/
*
Ignore
that
we
could
call
this
twice
in
theory
and
that
we
leak
\
*
them
\
*
/
\
AutoCount_
#
#
label
.
reset
(
new
BaseProfilerCount
(
\
#
label
&
profiler_count_
#
#
label
&
profiler_number_
#
#
label
\
profiler_category_
#
#
label
profiler_description_
#
#
label
)
)
;
\
}
\
}
while
(
0
)
#
endif
#
endif
