#
ifndef
ProfilerMarkers_h
#
define
ProfilerMarkers_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BaseProfilerMarkers
.
h
"
#
include
"
mozilla
/
MacroForEach
.
h
"
#
include
"
mozilla
/
ProfilerMarkersDetail
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsFmtString
.
h
"
#
include
"
ETWTools
.
h
"
class
nsIDocShell
;
namespace
geckoprofiler
:
:
markers
:
:
detail
{
#
ifdef
MOZ_GECKO_PROFILER
mozilla
:
:
Maybe
<
uint64_t
>
profiler_get_inner_window_id_from_docshell
(
nsIDocShell
*
aDocshell
)
;
#
else
inline
mozilla
:
:
Maybe
<
uint64_t
>
profiler_get_inner_window_id_from_docshell
(
nsIDocShell
*
aDocshell
)
{
return
mozilla
:
:
Nothing
(
)
;
}
#
endif
}
inline
mozilla
:
:
MarkerInnerWindowId
MarkerInnerWindowIdFromDocShell
(
nsIDocShell
*
aDocshell
)
{
mozilla
:
:
Maybe
<
uint64_t
>
id
=
geckoprofiler
:
:
markers
:
:
detail
:
:
profiler_get_inner_window_id_from_docshell
(
aDocshell
)
;
if
(
!
id
)
{
return
mozilla
:
:
MarkerInnerWindowId
:
:
NoId
(
)
;
}
return
mozilla
:
:
MarkerInnerWindowId
(
*
id
)
;
}
inline
mozilla
:
:
MarkerInnerWindowId
MarkerInnerWindowIdFromJSContext
(
JSContext
*
aContext
)
{
return
mozilla
:
:
MarkerInnerWindowId
(
nsJSUtils
:
:
GetCurrentlyRunningCodeInnerWindowID
(
aContext
)
)
;
}
namespace
geckoprofiler
:
:
category
{
using
namespace
:
:
mozilla
:
:
baseprofiler
:
:
category
;
}
#
ifdef
MOZ_GECKO_PROFILER
bool
profiler_capture_backtrace_into
(
mozilla
:
:
ProfileChunkedBuffer
&
aChunkedBuffer
mozilla
:
:
StackCaptureOptions
aCaptureOptions
)
;
template
<
typename
MarkerType
typename
.
.
.
PayloadArguments
>
mozilla
:
:
ProfileBufferBlockIndex
AddMarkerToBuffer
(
mozilla
:
:
ProfileChunkedBuffer
&
aBuffer
const
mozilla
:
:
ProfilerString8View
&
aName
const
mozilla
:
:
MarkerCategory
&
aCategory
mozilla
:
:
MarkerOptions
&
&
aOptions
MarkerType
aMarkerType
const
PayloadArguments
&
.
.
.
aPayloadArguments
)
{
AUTO_PROFILER_LABEL
(
"
AddMarkerToBuffer
"
PROFILER
)
;
mozilla
:
:
Unused
<
<
aMarkerType
;
return
mozilla
:
:
base_profiler_markers_detail
:
:
AddMarkerToBuffer
<
MarkerType
>
(
aBuffer
aName
aCategory
std
:
:
move
(
aOptions
)
profiler_active_without_feature
(
ProfilerFeature
:
:
NoMarkerStacks
)
?
:
:
profiler_capture_backtrace_into
:
nullptr
aPayloadArguments
.
.
.
)
;
}
inline
mozilla
:
:
ProfileBufferBlockIndex
AddMarkerToBuffer
(
mozilla
:
:
ProfileChunkedBuffer
&
aBuffer
const
mozilla
:
:
ProfilerString8View
&
aName
const
mozilla
:
:
MarkerCategory
&
aCategory
mozilla
:
:
MarkerOptions
&
&
aOptions
=
{
}
)
{
return
AddMarkerToBuffer
(
aBuffer
aName
aCategory
std
:
:
move
(
aOptions
)
mozilla
:
:
baseprofiler
:
:
markers
:
:
NoPayload
{
}
)
;
}
#
endif
[
[
nodiscard
]
]
inline
bool
profiler_thread_is_being_gecko_profiled_for_markers
(
const
ProfilerThreadId
&
aThreadId
)
{
return
profiler_thread_is_being_profiled
(
aThreadId
ThreadProfilingFeatures
:
:
Markers
)
;
}
[
[
nodiscard
]
]
inline
bool
profiler_thread_is_being_profiled_for_markers
(
)
{
return
profiler_thread_is_being_profiled
(
ThreadProfilingFeatures
:
:
Markers
)
|
|
profiler_is_etw_collecting_markers
(
)
|
|
profiler_is_perfetto_tracing
(
)
;
;
}
[
[
nodiscard
]
]
inline
bool
profiler_thread_is_being_profiled_for_markers
(
const
ProfilerThreadId
&
aThreadId
)
{
return
profiler_thread_is_being_profiled
(
aThreadId
ThreadProfilingFeatures
:
:
Markers
)
|
|
profiler_is_etw_collecting_markers
(
)
|
|
profiler_is_perfetto_tracing
(
)
;
}
template
<
typename
MarkerType
typename
.
.
.
PayloadArguments
>
mozilla
:
:
ProfileBufferBlockIndex
profiler_add_marker_impl
(
const
mozilla
:
:
ProfilerString8View
&
aName
const
mozilla
:
:
MarkerCategory
&
aCategory
mozilla
:
:
MarkerOptions
&
&
aOptions
MarkerType
aMarkerType
const
PayloadArguments
&
.
.
.
aPayloadArguments
)
{
#
ifndef
MOZ_GECKO_PROFILER
return
{
}
;
#
else
#
ifndef
RUST_BINDGEN
ETW
:
:
EmitETWMarker
(
aName
aCategory
aOptions
aMarkerType
aPayloadArguments
.
.
.
)
;
#
endif
#
ifdef
MOZ_PERFETTO
if
(
profiler_is_perfetto_tracing
(
)
)
{
EmitPerfettoTrackEvent
(
aName
aCategory
aOptions
aMarkerType
aPayloadArguments
.
.
.
)
;
}
#
endif
if
(
!
profiler_thread_is_being_gecko_profiled_for_markers
(
aOptions
.
ThreadId
(
)
.
ThreadId
(
)
)
)
{
return
{
}
;
}
AUTO_PROFILER_LABEL
(
"
profiler_add_marker
"
PROFILER
)
;
return
:
:
AddMarkerToBuffer
(
profiler_get_core_buffer
(
)
aName
aCategory
std
:
:
move
(
aOptions
)
aMarkerType
aPayloadArguments
.
.
.
)
;
#
endif
}
inline
mozilla
:
:
ProfileBufferBlockIndex
profiler_add_marker_impl
(
const
mozilla
:
:
ProfilerString8View
&
aName
const
mozilla
:
:
MarkerCategory
&
aCategory
mozilla
:
:
MarkerOptions
&
&
aOptions
=
{
}
)
{
return
profiler_add_marker_impl
(
aName
aCategory
std
:
:
move
(
aOptions
)
mozilla
:
:
baseprofiler
:
:
markers
:
:
NoPayload
{
}
)
;
}
#
define
profiler_add_marker
(
.
.
.
)
\
do
{
\
if
(
profiler_is_collecting_markers
(
)
)
{
\
:
:
profiler_add_marker_impl
(
__VA_ARGS__
)
;
\
}
\
}
while
(
false
)
#
define
PROFILER_MARKER_UNTYPED
(
markerName
categoryName
.
.
.
)
\
do
{
\
AUTO_PROFILER_STATS
(
PROFILER_MARKER_UNTYPED
)
;
\
profiler_add_marker
(
markerName
:
:
geckoprofiler
:
:
category
:
:
categoryName
\
#
#
__VA_ARGS__
)
;
\
}
while
(
false
)
#
define
PROFILER_MARKER
(
markerName
categoryName
options
MarkerType
.
.
.
)
\
do
{
\
AUTO_PROFILER_STATS
(
PROFILER_MARKER_with_
#
#
MarkerType
)
;
\
profiler_add_marker
(
markerName
:
:
geckoprofiler
:
:
category
:
:
categoryName
\
options
:
:
geckoprofiler
:
:
markers
:
:
MarkerType
{
}
\
#
#
__VA_ARGS__
)
;
\
}
while
(
false
)
namespace
geckoprofiler
:
:
markers
{
using
TextMarker
=
:
:
mozilla
:
:
baseprofiler
:
:
markers
:
:
TextMarker
;
using
Tracing
=
mozilla
:
:
baseprofiler
:
:
markers
:
:
Tracing
;
}
#
define
PROFILER_MARKER_TEXT
(
markerName
categoryName
options
text
)
\
do
{
\
AUTO_PROFILER_STATS
(
PROFILER_MARKER_TEXT
)
;
\
profiler_add_marker
(
markerName
:
:
geckoprofiler
:
:
category
:
:
categoryName
\
options
:
:
geckoprofiler
:
:
markers
:
:
TextMarker
{
}
\
text
)
;
\
}
while
(
false
)
#
define
PROFILER_MARKER_FMT
(
markerName
categoryName
options
format
.
.
.
)
\
do
{
\
if
(
profiler_is_collecting_markers
(
)
)
{
\
AUTO_PROFILER_STATS
(
PROFILER_MARKER_TEXT
)
;
\
nsFmtCString
fmt
(
FMT_STRING
(
format
)
#
#
__VA_ARGS__
)
;
\
profiler_add_marker
(
\
markerName
:
:
geckoprofiler
:
:
category
:
:
categoryName
options
\
:
:
geckoprofiler
:
:
markers
:
:
TextMarker
{
}
\
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
fmt
.
get
(
)
)
)
;
\
}
\
}
while
(
false
)
namespace
geckoprofiler
:
:
markers
{
template
<
const
char
*
ArgName
typename
ArgType
>
struct
FieldDescription
{
static
constexpr
const
char
*
name
=
ArgName
;
static
constexpr
ArgType
var
=
{
}
;
}
;
template
<
const
char
ArgName
[
]
const
char
ArgTableLabel
[
]
typename
.
.
.
ArgTypes
>
struct
SimplePayloadMarkerTemplate
:
public
mozilla
:
:
BaseMarkerType
<
SimplePayloadMarkerTemplate
<
ArgName
ArgTableLabel
ArgTypes
.
.
.
>
>
{
static
constexpr
const
char
*
Name
=
ArgName
;
using
MS
=
mozilla
:
:
MarkerSchema
;
static
constexpr
MS
:
:
PayloadField
PayloadFields
[
]
=
{
{
ArgTypes
:
:
name
MS
:
:
getDefaultInputTypeForType
<
decltype
(
ArgTypes
:
:
var
)
>
(
)
ArgTypes
:
:
name
MS
:
:
getDefaultFormatForType
<
decltype
(
ArgTypes
:
:
var
)
>
(
)
}
.
.
.
}
;
static
constexpr
const
char
*
TableLabel
=
ArgTableLabel
;
static
constexpr
MS
:
:
Location
Locations
[
]
=
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
static
void
StreamJSONMarkerData
(
mozilla
:
:
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
decltype
(
ArgTypes
:
:
var
)
&
.
.
.
args
)
{
mozilla
:
:
BaseMarkerType
<
SimplePayloadMarkerTemplate
<
ArgName
ArgTableLabel
ArgTypes
.
.
.
>
>
:
:
StreamJSONMarkerDataImpl
(
aWriter
args
.
.
.
)
;
}
}
;
}
#
define
DEFINE_FIELD_STRUCT
(
arg
)
\
static
constexpr
char
defined_name_
#
#
arg
[
]
=
#
arg
;
\
using
FieldDescription
#
#
arg
=
\
geckoprofiler
:
:
markers
:
:
FieldDescription
<
defined_name_
#
#
arg
\
decltype
(
arg
)
>
;
#
define
DEFINE_FIELD_STRUCTS
(
.
.
.
)
\
MOZ_FOR_EACH
(
DEFINE_FIELD_STRUCT
(
)
(
__VA_ARGS__
)
)
#
define
MARKER_GET_ARG_TYPE
(
arg
)
FieldDescription
#
#
arg
#
define
PROFILER_MARKER_SIMPLE_PAYLOAD_WITH_LABEL
(
markerName
categoryName
\
label
.
.
.
)
\
do
{
\
static
constexpr
char
marker_name
[
]
=
markerName
;
\
static
constexpr
char
table_label
[
]
=
label
;
\
DEFINE_FIELD_STRUCTS
(
__VA_ARGS__
)
\
using
SimplePayloadMarkerImpl
=
\
geckoprofiler
:
:
markers
:
:
SimplePayloadMarkerTemplate
<
\
marker_name
table_label
\
MOZ_FOR_EACH_SEPARATED
(
MARKER_GET_ARG_TYPE
(
)
(
)
\
(
__VA_ARGS__
)
)
>
;
\
profiler_add_marker
(
markerName
\
:
:
mozilla
:
:
baseprofiler
:
:
category
:
:
categoryName
{
}
\
SimplePayloadMarkerImpl
{
}
__VA_ARGS__
)
;
\
}
while
(
false
)
#
define
MARKER_LABEL_FOR_ARG
(
arg
)
#
arg
"
:
{
marker
.
data
.
"
#
arg
"
}
"
#
define
PROFILER_MARKER_SIMPLE_PAYLOAD
(
markerName
categoryName
.
.
.
)
\
PROFILER_MARKER_SIMPLE_PAYLOAD_WITH_LABEL
(
\
markerName
categoryName
\
MOZ_FOR_EACH_SEPARATED
(
MARKER_LABEL_FOR_ARG
(
"
"
)
(
)
(
__VA_ARGS__
)
)
\
__VA_ARGS__
)
class
MOZ_RAII
AutoProfilerUntypedMarker
{
public
:
AutoProfilerUntypedMarker
(
const
char
*
aMarkerName
const
mozilla
:
:
MarkerCategory
&
aCategory
mozilla
:
:
MarkerOptions
&
&
aOptions
)
:
mMarkerName
(
aMarkerName
)
mCategory
(
aCategory
)
mOptions
(
std
:
:
move
(
aOptions
)
)
{
MOZ_ASSERT
(
mOptions
.
Timing
(
)
.
EndTime
(
)
.
IsNull
(
)
"
AutoProfilerUntypedMarker
options
shouldn
'
t
have
an
end
time
"
)
;
if
(
profiler_is_active_and_unpaused
(
)
&
&
mOptions
.
Timing
(
)
.
StartTime
(
)
.
IsNull
(
)
)
{
mOptions
.
Set
(
mozilla
:
:
MarkerTiming
:
:
InstantNow
(
)
)
;
}
}
~
AutoProfilerUntypedMarker
(
)
{
if
(
profiler_is_active_and_unpaused
(
)
)
{
AUTO_PROFILER_LABEL
(
"
UntypedMarker
"
PROFILER
)
;
mOptions
.
TimingRef
(
)
.
SetIntervalEnd
(
)
;
AUTO_PROFILER_STATS
(
AUTO_PROFILER_MARKER_UNTYPED
)
;
profiler_add_marker
(
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mMarkerName
)
mCategory
std
:
:
move
(
mOptions
)
)
;
}
}
protected
:
const
char
*
mMarkerName
;
mozilla
:
:
MarkerCategory
mCategory
;
mozilla
:
:
MarkerOptions
mOptions
;
}
;
#
define
AUTO_PROFILER_MARKER_UNTYPED
(
markerName
categoryName
options
)
\
AutoProfilerUntypedMarker
PROFILER_RAII
(
\
markerName
:
:
mozilla
:
:
baseprofiler
:
:
category
:
:
categoryName
options
)
class
MOZ_RAII
AutoProfilerTextMarker
{
public
:
AutoProfilerTextMarker
(
const
char
*
aMarkerName
const
mozilla
:
:
MarkerCategory
&
aCategory
mozilla
:
:
MarkerOptions
&
&
aOptions
const
nsAString
&
aText
)
:
AutoProfilerTextMarker
(
aMarkerName
aCategory
std
:
:
move
(
aOptions
)
profiler_is_active_and_unpaused
(
)
?
NS_ConvertUTF16toUTF8
(
aText
)
:
nsCString
(
)
)
{
}
AutoProfilerTextMarker
(
const
char
*
aMarkerName
const
mozilla
:
:
MarkerCategory
&
aCategory
mozilla
:
:
MarkerOptions
&
&
aOptions
const
nsACString
&
aText
)
:
mMarkerName
(
aMarkerName
)
mCategory
(
aCategory
)
mOptions
(
std
:
:
move
(
aOptions
)
)
mText
(
aText
)
{
MOZ_ASSERT
(
mOptions
.
Timing
(
)
.
EndTime
(
)
.
IsNull
(
)
"
AutoProfilerTextMarker
options
shouldn
'
t
have
an
end
time
"
)
;
if
(
profiler_is_active_and_unpaused
(
)
&
&
mOptions
.
Timing
(
)
.
StartTime
(
)
.
IsNull
(
)
)
{
mOptions
.
Set
(
mozilla
:
:
MarkerTiming
:
:
InstantNow
(
)
)
;
}
}
~
AutoProfilerTextMarker
(
)
{
if
(
profiler_is_active_and_unpaused
(
)
)
{
AUTO_PROFILER_LABEL
(
"
TextMarker
"
PROFILER
)
;
mOptions
.
TimingRef
(
)
.
SetIntervalEnd
(
)
;
AUTO_PROFILER_STATS
(
AUTO_PROFILER_MARKER_TEXT
)
;
profiler_add_marker
(
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mMarkerName
)
mCategory
std
:
:
move
(
mOptions
)
mozilla
:
:
baseprofiler
:
:
markers
:
:
TextStackMarker
{
}
mText
)
;
}
}
protected
:
const
char
*
mMarkerName
;
mozilla
:
:
MarkerCategory
mCategory
;
mozilla
:
:
MarkerOptions
mOptions
;
nsCString
mText
;
}
;
#
define
AUTO_PROFILER_MARKER_FMT
(
markerName
categoryName
options
format
\
.
.
.
)
\
AutoProfilerFmtMarker
PROFILER_RAII
(
\
markerName
:
:
mozilla
:
:
baseprofiler
:
:
category
:
:
categoryName
options
\
FMT_STRING
(
format
)
__VA_ARGS__
)
#
define
AUTO_PROFILER_MARKER_FMT_LONG
(
size
markerName
categoryName
options
\
format
.
.
.
)
\
AutoProfilerFmtMarker
<
size
>
PROFILER_RAII
(
\
markerName
:
:
mozilla
:
:
baseprofiler
:
:
category
:
:
categoryName
options
\
FMT_STRING
(
format
)
__VA_ARGS__
)
template
<
size_t
TextLength
=
512
typename
CharT
=
char
>
class
AutoProfilerFmtMarker
{
public
:
template
<
typename
.
.
.
Args
>
AutoProfilerFmtMarker
(
const
CharT
*
aMarkerName
const
mozilla
:
:
MarkerCategory
&
aCategory
mozilla
:
:
MarkerOptions
&
&
aOptions
fmt
:
:
format_string
<
Args
.
.
.
>
aFormatStr
Args
&
&
.
.
.
aArgs
)
:
mMarkerName
(
aMarkerName
)
mCategory
(
aCategory
)
mOptions
(
std
:
:
move
(
aOptions
)
)
{
if
(
profiler_is_active_and_unpaused
(
)
)
{
if
(
mOptions
.
Timing
(
)
.
StartTime
(
)
.
IsNull
(
)
)
{
mOptions
.
Set
(
mozilla
:
:
MarkerTiming
:
:
InstantNow
(
)
)
;
}
auto
[
out
size
]
=
fmt
:
:
vformat_to_n
(
mFormatted
sizeof
(
mFormatted
)
-
1
aFormatStr
fmt
:
:
make_format_args
<
fmt
:
:
buffered_context
<
CharT
>
>
(
aArgs
.
.
.
)
)
;
#
ifdef
DEBUG
if
(
size
>
sizeof
(
mFormatted
)
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Truncated
marker
consider
increasing
the
buffer
(
needed
:
%
zu
"
"
actual
:
%
zu
)
"
size
sizeof
(
mFormatted
)
)
;
}
#
endif
*
out
=
0
;
}
}
~
AutoProfilerFmtMarker
(
)
{
if
(
profiler_is_active_and_unpaused
(
)
)
{
AUTO_PROFILER_LABEL
(
"
FmtMarker
"
PROFILER
)
;
mOptions
.
TimingRef
(
)
.
SetIntervalEnd
(
)
;
AUTO_PROFILER_STATS
(
AUTO_PROFILER_MARKER_TEXT
)
;
profiler_add_marker
(
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mMarkerName
)
mCategory
std
:
:
move
(
mOptions
)
mozilla
:
:
baseprofiler
:
:
markers
:
:
TextStackMarker
{
}
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mFormatted
)
)
;
}
}
private
:
const
char
*
mMarkerName
;
mozilla
:
:
TimeStamp
startTime
;
mozilla
:
:
MarkerCategory
mCategory
;
mozilla
:
:
MarkerOptions
mOptions
;
char
mFormatted
[
TextLength
]
{
}
;
}
;
#
define
AUTO_PROFILER_MARKER_TEXT
(
markerName
categoryName
options
text
)
\
AutoProfilerTextMarker
PROFILER_RAII
(
\
markerName
:
:
mozilla
:
:
baseprofiler
:
:
category
:
:
categoryName
options
\
text
)
class
MOZ_RAII
AutoProfilerTracing
{
public
:
AutoProfilerTracing
(
const
char
*
aCategoryString
const
char
*
aMarkerName
mozilla
:
:
MarkerCategory
aCategoryPair
const
mozilla
:
:
Maybe
<
uint64_t
>
&
aInnerWindowID
)
:
mCategoryString
(
aCategoryString
)
mMarkerName
(
aMarkerName
)
mCategoryPair
(
aCategoryPair
)
mInnerWindowID
(
aInnerWindowID
)
{
profiler_add_marker
(
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mMarkerName
)
mCategoryPair
{
mozilla
:
:
MarkerTiming
:
:
IntervalStart
(
)
mozilla
:
:
MarkerInnerWindowId
(
mInnerWindowID
)
}
mozilla
:
:
baseprofiler
:
:
markers
:
:
StackMarker
{
}
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mCategoryString
)
)
;
}
AutoProfilerTracing
(
const
char
*
aCategoryString
const
char
*
aMarkerName
mozilla
:
:
MarkerCategory
aCategoryPair
mozilla
:
:
UniquePtr
<
mozilla
:
:
ProfileChunkedBuffer
>
aBacktrace
const
mozilla
:
:
Maybe
<
uint64_t
>
&
aInnerWindowID
)
:
mCategoryString
(
aCategoryString
)
mMarkerName
(
aMarkerName
)
mCategoryPair
(
aCategoryPair
)
mInnerWindowID
(
aInnerWindowID
)
{
profiler_add_marker
(
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mMarkerName
)
mCategoryPair
{
mozilla
:
:
MarkerTiming
:
:
IntervalStart
(
)
mozilla
:
:
MarkerInnerWindowId
(
mInnerWindowID
)
mozilla
:
:
MarkerStack
:
:
TakeBacktrace
(
std
:
:
move
(
aBacktrace
)
)
}
mozilla
:
:
baseprofiler
:
:
markers
:
:
StackMarker
{
}
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mCategoryString
)
)
;
}
~
AutoProfilerTracing
(
)
{
profiler_add_marker
(
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mMarkerName
)
mCategoryPair
{
mozilla
:
:
MarkerTiming
:
:
IntervalEnd
(
)
mozilla
:
:
MarkerInnerWindowId
(
mInnerWindowID
)
}
mozilla
:
:
baseprofiler
:
:
markers
:
:
StackMarker
{
}
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mCategoryString
)
)
;
}
protected
:
const
char
*
mCategoryString
;
const
char
*
mMarkerName
;
const
mozilla
:
:
MarkerCategory
mCategoryPair
;
const
mozilla
:
:
Maybe
<
uint64_t
>
mInnerWindowID
;
}
;
#
define
AUTO_PROFILER_TRACING_MARKER
(
categoryString
markerName
categoryPair
)
\
AutoProfilerTracing
PROFILER_RAII
(
categoryString
markerName
\
geckoprofiler
:
:
category
:
:
categoryPair
\
mozilla
:
:
Nothing
(
)
)
#
define
AUTO_PROFILER_TRACING_MARKER_INNERWINDOWID
(
\
categoryString
markerName
categoryPair
innerWindowId
)
\
AutoProfilerTracing
PROFILER_RAII
(
categoryString
markerName
\
geckoprofiler
:
:
category
:
:
categoryPair
\
mozilla
:
:
Some
(
innerWindowId
)
)
#
define
AUTO_PROFILER_TRACING_MARKER_DOCSHELL
(
categoryString
markerName
\
categoryPair
docShell
)
\
AutoProfilerTracing
PROFILER_RAII
(
\
categoryString
markerName
geckoprofiler
:
:
category
:
:
categoryPair
\
geckoprofiler
:
:
markers
:
:
detail
:
:
\
profiler_get_inner_window_id_from_docshell
(
docShell
)
)
#
ifdef
MOZ_GECKO_PROFILER
extern
template
mozilla
:
:
ProfileBufferBlockIndex
AddMarkerToBuffer
(
mozilla
:
:
ProfileChunkedBuffer
&
const
mozilla
:
:
ProfilerString8View
&
const
mozilla
:
:
MarkerCategory
&
mozilla
:
:
MarkerOptions
&
&
mozilla
:
:
baseprofiler
:
:
markers
:
:
NoPayload
)
;
extern
template
mozilla
:
:
ProfileBufferBlockIndex
AddMarkerToBuffer
(
mozilla
:
:
ProfileChunkedBuffer
&
const
mozilla
:
:
ProfilerString8View
&
const
mozilla
:
:
MarkerCategory
&
mozilla
:
:
MarkerOptions
&
&
mozilla
:
:
baseprofiler
:
:
markers
:
:
TextMarker
const
std
:
:
string
&
)
;
extern
template
mozilla
:
:
ProfileBufferBlockIndex
profiler_add_marker_impl
(
const
mozilla
:
:
ProfilerString8View
&
const
mozilla
:
:
MarkerCategory
&
mozilla
:
:
MarkerOptions
&
&
mozilla
:
:
baseprofiler
:
:
markers
:
:
TextMarker
const
std
:
:
string
&
)
;
extern
template
mozilla
:
:
ProfileBufferBlockIndex
profiler_add_marker_impl
(
const
mozilla
:
:
ProfilerString8View
&
const
mozilla
:
:
MarkerCategory
&
mozilla
:
:
MarkerOptions
&
&
mozilla
:
:
baseprofiler
:
:
markers
:
:
TextMarker
const
nsCString
&
)
;
extern
template
mozilla
:
:
ProfileBufferBlockIndex
profiler_add_marker_impl
(
const
mozilla
:
:
ProfilerString8View
&
const
mozilla
:
:
MarkerCategory
&
mozilla
:
:
MarkerOptions
&
&
mozilla
:
:
baseprofiler
:
:
markers
:
:
Tracing
const
mozilla
:
:
ProfilerString8View
&
)
;
#
endif
namespace
mozilla
{
namespace
detail
{
template
<
>
inline
void
StreamPayload
<
ProfilerString16View
>
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
Span
<
const
char
>
aKey
const
ProfilerString16View
&
aPayload
)
{
aWriter
.
StringProperty
(
aKey
NS_ConvertUTF16toUTF8
(
aPayload
)
)
;
}
}
}
#
endif
