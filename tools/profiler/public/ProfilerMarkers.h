#
ifndef
ProfilerMarkers_h
#
define
ProfilerMarkers_h
#
include
"
mozilla
/
BaseProfilerMarkers
.
h
"
#
include
"
mozilla
/
ProfilerMarkersDetail
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
ETWTools
.
h
"
class
nsIDocShell
;
namespace
geckoprofiler
:
:
markers
:
:
detail
{
#
ifdef
MOZ_GECKO_PROFILER
mozilla
:
:
Maybe
<
uint64_t
>
profiler_get_inner_window_id_from_docshell
(
nsIDocShell
*
aDocshell
)
;
#
else
inline
mozilla
:
:
Maybe
<
uint64_t
>
profiler_get_inner_window_id_from_docshell
(
nsIDocShell
*
aDocshell
)
{
return
mozilla
:
:
Nothing
(
)
;
}
#
endif
}
inline
mozilla
:
:
MarkerInnerWindowId
MarkerInnerWindowIdFromDocShell
(
nsIDocShell
*
aDocshell
)
{
mozilla
:
:
Maybe
<
uint64_t
>
id
=
geckoprofiler
:
:
markers
:
:
detail
:
:
profiler_get_inner_window_id_from_docshell
(
aDocshell
)
;
if
(
!
id
)
{
return
mozilla
:
:
MarkerInnerWindowId
:
:
NoId
(
)
;
}
return
mozilla
:
:
MarkerInnerWindowId
(
*
id
)
;
}
inline
mozilla
:
:
MarkerInnerWindowId
MarkerInnerWindowIdFromJSContext
(
JSContext
*
aContext
)
{
return
mozilla
:
:
MarkerInnerWindowId
(
nsJSUtils
:
:
GetCurrentlyRunningCodeInnerWindowID
(
aContext
)
)
;
}
namespace
geckoprofiler
:
:
category
{
using
namespace
:
:
mozilla
:
:
baseprofiler
:
:
category
;
}
#
ifdef
MOZ_GECKO_PROFILER
bool
profiler_capture_backtrace_into
(
mozilla
:
:
ProfileChunkedBuffer
&
aChunkedBuffer
mozilla
:
:
StackCaptureOptions
aCaptureOptions
)
;
template
<
typename
MarkerType
typename
.
.
.
PayloadArguments
>
mozilla
:
:
ProfileBufferBlockIndex
AddMarkerToBuffer
(
mozilla
:
:
ProfileChunkedBuffer
&
aBuffer
const
mozilla
:
:
ProfilerString8View
&
aName
const
mozilla
:
:
MarkerCategory
&
aCategory
mozilla
:
:
MarkerOptions
&
&
aOptions
MarkerType
aMarkerType
const
PayloadArguments
&
.
.
.
aPayloadArguments
)
{
AUTO_PROFILER_LABEL
(
"
AddMarkerToBuffer
"
PROFILER
)
;
mozilla
:
:
Unused
<
<
aMarkerType
;
return
mozilla
:
:
base_profiler_markers_detail
:
:
AddMarkerToBuffer
<
MarkerType
>
(
aBuffer
aName
aCategory
std
:
:
move
(
aOptions
)
profiler_active_without_feature
(
ProfilerFeature
:
:
NoMarkerStacks
)
?
:
:
profiler_capture_backtrace_into
:
nullptr
aPayloadArguments
.
.
.
)
;
}
inline
mozilla
:
:
ProfileBufferBlockIndex
AddMarkerToBuffer
(
mozilla
:
:
ProfileChunkedBuffer
&
aBuffer
const
mozilla
:
:
ProfilerString8View
&
aName
const
mozilla
:
:
MarkerCategory
&
aCategory
mozilla
:
:
MarkerOptions
&
&
aOptions
=
{
}
)
{
return
AddMarkerToBuffer
(
aBuffer
aName
aCategory
std
:
:
move
(
aOptions
)
mozilla
:
:
baseprofiler
:
:
markers
:
:
NoPayload
{
}
)
;
}
#
endif
[
[
nodiscard
]
]
inline
bool
profiler_thread_is_being_gecko_profiled_for_markers
(
const
ProfilerThreadId
&
aThreadId
)
{
return
profiler_thread_is_being_profiled
(
aThreadId
ThreadProfilingFeatures
:
:
Markers
)
;
}
[
[
nodiscard
]
]
inline
bool
profiler_thread_is_being_profiled_for_markers
(
)
{
return
profiler_thread_is_being_profiled
(
ThreadProfilingFeatures
:
:
Markers
)
|
|
profiler_is_etw_collecting_markers
(
)
;
}
[
[
nodiscard
]
]
inline
bool
profiler_thread_is_being_profiled_for_markers
(
const
ProfilerThreadId
&
aThreadId
)
{
return
profiler_thread_is_being_profiled
(
aThreadId
ThreadProfilingFeatures
:
:
Markers
)
|
|
profiler_is_etw_collecting_markers
(
)
;
}
template
<
typename
MarkerType
typename
.
.
.
PayloadArguments
>
mozilla
:
:
ProfileBufferBlockIndex
profiler_add_marker_impl
(
const
mozilla
:
:
ProfilerString8View
&
aName
const
mozilla
:
:
MarkerCategory
&
aCategory
mozilla
:
:
MarkerOptions
&
&
aOptions
MarkerType
aMarkerType
const
PayloadArguments
&
.
.
.
aPayloadArguments
)
{
#
ifndef
MOZ_GECKO_PROFILER
return
{
}
;
#
else
#
ifndef
RUST_BINDGEN
ETW
:
:
EmitETWMarker
(
aName
aCategory
aOptions
aMarkerType
aPayloadArguments
.
.
.
)
;
#
endif
if
(
!
profiler_thread_is_being_gecko_profiled_for_markers
(
aOptions
.
ThreadId
(
)
.
ThreadId
(
)
)
)
{
return
{
}
;
}
AUTO_PROFILER_LABEL
(
"
profiler_add_marker
"
PROFILER
)
;
return
:
:
AddMarkerToBuffer
(
profiler_get_core_buffer
(
)
aName
aCategory
std
:
:
move
(
aOptions
)
aMarkerType
aPayloadArguments
.
.
.
)
;
#
endif
}
inline
mozilla
:
:
ProfileBufferBlockIndex
profiler_add_marker_impl
(
const
mozilla
:
:
ProfilerString8View
&
aName
const
mozilla
:
:
MarkerCategory
&
aCategory
mozilla
:
:
MarkerOptions
&
&
aOptions
=
{
}
)
{
return
profiler_add_marker_impl
(
aName
aCategory
std
:
:
move
(
aOptions
)
mozilla
:
:
baseprofiler
:
:
markers
:
:
NoPayload
{
}
)
;
}
#
define
profiler_add_marker
(
.
.
.
)
\
do
{
\
if
(
profiler_is_collecting_markers
(
)
)
{
\
:
:
profiler_add_marker_impl
(
__VA_ARGS__
)
;
\
}
\
}
while
(
false
)
#
define
PROFILER_MARKER_UNTYPED
(
markerName
categoryName
.
.
.
)
\
do
{
\
AUTO_PROFILER_STATS
(
PROFILER_MARKER_UNTYPED
)
;
\
profiler_add_marker
(
markerName
:
:
geckoprofiler
:
:
category
:
:
categoryName
\
#
#
__VA_ARGS__
)
;
\
}
while
(
false
)
#
define
PROFILER_MARKER
(
markerName
categoryName
options
MarkerType
.
.
.
)
\
do
{
\
AUTO_PROFILER_STATS
(
PROFILER_MARKER_with_
#
#
MarkerType
)
;
\
profiler_add_marker
(
markerName
:
:
geckoprofiler
:
:
category
:
:
categoryName
\
options
:
:
geckoprofiler
:
:
markers
:
:
MarkerType
{
}
\
#
#
__VA_ARGS__
)
;
\
}
while
(
false
)
namespace
geckoprofiler
:
:
markers
{
using
TextMarker
=
:
:
mozilla
:
:
baseprofiler
:
:
markers
:
:
TextMarker
;
using
Tracing
=
mozilla
:
:
baseprofiler
:
:
markers
:
:
Tracing
;
}
#
define
PROFILER_MARKER_TEXT
(
markerName
categoryName
options
text
)
\
do
{
\
AUTO_PROFILER_STATS
(
PROFILER_MARKER_TEXT
)
;
\
profiler_add_marker
(
markerName
:
:
geckoprofiler
:
:
category
:
:
categoryName
\
options
:
:
geckoprofiler
:
:
markers
:
:
TextMarker
{
}
\
text
)
;
\
}
while
(
false
)
class
MOZ_RAII
AutoProfilerTextMarker
{
public
:
AutoProfilerTextMarker
(
const
char
*
aMarkerName
const
mozilla
:
:
MarkerCategory
&
aCategory
mozilla
:
:
MarkerOptions
&
&
aOptions
const
nsACString
&
aText
)
:
mMarkerName
(
aMarkerName
)
mCategory
(
aCategory
)
mOptions
(
std
:
:
move
(
aOptions
)
)
mText
(
aText
)
{
MOZ_ASSERT
(
mOptions
.
Timing
(
)
.
EndTime
(
)
.
IsNull
(
)
"
AutoProfilerTextMarker
options
shouldn
'
t
have
an
end
time
"
)
;
if
(
profiler_is_active_and_unpaused
(
)
&
&
mOptions
.
Timing
(
)
.
StartTime
(
)
.
IsNull
(
)
)
{
mOptions
.
Set
(
mozilla
:
:
MarkerTiming
:
:
InstantNow
(
)
)
;
}
}
~
AutoProfilerTextMarker
(
)
{
if
(
profiler_is_active_and_unpaused
(
)
)
{
AUTO_PROFILER_LABEL
(
"
TextMarker
"
PROFILER
)
;
mOptions
.
TimingRef
(
)
.
SetIntervalEnd
(
)
;
AUTO_PROFILER_STATS
(
AUTO_PROFILER_MARKER_TEXT
)
;
profiler_add_marker
(
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mMarkerName
)
mCategory
std
:
:
move
(
mOptions
)
geckoprofiler
:
:
markers
:
:
TextMarker
{
}
mText
)
;
}
}
protected
:
const
char
*
mMarkerName
;
mozilla
:
:
MarkerCategory
mCategory
;
mozilla
:
:
MarkerOptions
mOptions
;
nsCString
mText
;
}
;
#
define
AUTO_PROFILER_MARKER_TEXT
(
markerName
categoryName
options
text
)
\
AutoProfilerTextMarker
PROFILER_RAII
(
\
markerName
:
:
mozilla
:
:
baseprofiler
:
:
category
:
:
categoryName
options
\
text
)
class
MOZ_RAII
AutoProfilerTracing
{
public
:
AutoProfilerTracing
(
const
char
*
aCategoryString
const
char
*
aMarkerName
mozilla
:
:
MarkerCategory
aCategoryPair
const
mozilla
:
:
Maybe
<
uint64_t
>
&
aInnerWindowID
)
:
mCategoryString
(
aCategoryString
)
mMarkerName
(
aMarkerName
)
mCategoryPair
(
aCategoryPair
)
mInnerWindowID
(
aInnerWindowID
)
{
profiler_add_marker
(
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mMarkerName
)
mCategoryPair
{
mozilla
:
:
MarkerTiming
:
:
IntervalStart
(
)
mozilla
:
:
MarkerInnerWindowId
(
mInnerWindowID
)
}
geckoprofiler
:
:
markers
:
:
Tracing
{
}
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mCategoryString
)
)
;
}
AutoProfilerTracing
(
const
char
*
aCategoryString
const
char
*
aMarkerName
mozilla
:
:
MarkerCategory
aCategoryPair
mozilla
:
:
UniquePtr
<
mozilla
:
:
ProfileChunkedBuffer
>
aBacktrace
const
mozilla
:
:
Maybe
<
uint64_t
>
&
aInnerWindowID
)
:
mCategoryString
(
aCategoryString
)
mMarkerName
(
aMarkerName
)
mCategoryPair
(
aCategoryPair
)
mInnerWindowID
(
aInnerWindowID
)
{
profiler_add_marker
(
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mMarkerName
)
mCategoryPair
{
mozilla
:
:
MarkerTiming
:
:
IntervalStart
(
)
mozilla
:
:
MarkerInnerWindowId
(
mInnerWindowID
)
mozilla
:
:
MarkerStack
:
:
TakeBacktrace
(
std
:
:
move
(
aBacktrace
)
)
}
geckoprofiler
:
:
markers
:
:
Tracing
{
}
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mCategoryString
)
)
;
}
~
AutoProfilerTracing
(
)
{
profiler_add_marker
(
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mMarkerName
)
mCategoryPair
{
mozilla
:
:
MarkerTiming
:
:
IntervalEnd
(
)
mozilla
:
:
MarkerInnerWindowId
(
mInnerWindowID
)
}
geckoprofiler
:
:
markers
:
:
Tracing
{
}
mozilla
:
:
ProfilerString8View
:
:
WrapNullTerminatedString
(
mCategoryString
)
)
;
}
protected
:
const
char
*
mCategoryString
;
const
char
*
mMarkerName
;
const
mozilla
:
:
MarkerCategory
mCategoryPair
;
const
mozilla
:
:
Maybe
<
uint64_t
>
mInnerWindowID
;
}
;
#
define
AUTO_PROFILER_TRACING_MARKER
(
categoryString
markerName
categoryPair
)
\
AutoProfilerTracing
PROFILER_RAII
(
categoryString
markerName
\
geckoprofiler
:
:
category
:
:
categoryPair
\
mozilla
:
:
Nothing
(
)
)
#
define
AUTO_PROFILER_TRACING_MARKER_INNERWINDOWID
(
\
categoryString
markerName
categoryPair
innerWindowId
)
\
AutoProfilerTracing
PROFILER_RAII
(
categoryString
markerName
\
geckoprofiler
:
:
category
:
:
categoryPair
\
mozilla
:
:
Some
(
innerWindowId
)
)
#
define
AUTO_PROFILER_TRACING_MARKER_DOCSHELL
(
categoryString
markerName
\
categoryPair
docShell
)
\
AutoProfilerTracing
PROFILER_RAII
(
\
categoryString
markerName
geckoprofiler
:
:
category
:
:
categoryPair
\
geckoprofiler
:
:
markers
:
:
detail
:
:
\
profiler_get_inner_window_id_from_docshell
(
docShell
)
)
#
ifdef
MOZ_GECKO_PROFILER
extern
template
mozilla
:
:
ProfileBufferBlockIndex
AddMarkerToBuffer
(
mozilla
:
:
ProfileChunkedBuffer
&
const
mozilla
:
:
ProfilerString8View
&
const
mozilla
:
:
MarkerCategory
&
mozilla
:
:
MarkerOptions
&
&
mozilla
:
:
baseprofiler
:
:
markers
:
:
NoPayload
)
;
extern
template
mozilla
:
:
ProfileBufferBlockIndex
AddMarkerToBuffer
(
mozilla
:
:
ProfileChunkedBuffer
&
const
mozilla
:
:
ProfilerString8View
&
const
mozilla
:
:
MarkerCategory
&
mozilla
:
:
MarkerOptions
&
&
mozilla
:
:
baseprofiler
:
:
markers
:
:
TextMarker
const
std
:
:
string
&
)
;
extern
template
mozilla
:
:
ProfileBufferBlockIndex
profiler_add_marker_impl
(
const
mozilla
:
:
ProfilerString8View
&
const
mozilla
:
:
MarkerCategory
&
mozilla
:
:
MarkerOptions
&
&
mozilla
:
:
baseprofiler
:
:
markers
:
:
TextMarker
const
std
:
:
string
&
)
;
extern
template
mozilla
:
:
ProfileBufferBlockIndex
profiler_add_marker_impl
(
const
mozilla
:
:
ProfilerString8View
&
const
mozilla
:
:
MarkerCategory
&
mozilla
:
:
MarkerOptions
&
&
mozilla
:
:
baseprofiler
:
:
markers
:
:
TextMarker
const
nsCString
&
)
;
extern
template
mozilla
:
:
ProfileBufferBlockIndex
profiler_add_marker_impl
(
const
mozilla
:
:
ProfilerString8View
&
const
mozilla
:
:
MarkerCategory
&
mozilla
:
:
MarkerOptions
&
&
mozilla
:
:
baseprofiler
:
:
markers
:
:
Tracing
const
mozilla
:
:
ProfilerString8View
&
)
;
#
endif
namespace
mozilla
{
namespace
detail
{
template
<
typename
PayloadType
>
static
void
StreamPayload
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
Span
<
const
char
>
aKey
const
PayloadType
&
aPayload
)
{
aWriter
.
StringProperty
(
aKey
aPayload
)
;
}
template
<
typename
PayloadType
>
inline
void
StreamPayload
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
Span
<
const
char
>
aKey
const
Maybe
<
PayloadType
>
&
aPayload
)
{
if
(
aPayload
.
isSome
(
)
)
{
StreamPayload
(
aWriter
aKey
*
aPayload
)
;
}
else
{
aWriter
.
NullProperty
(
aKey
)
;
}
}
template
<
>
inline
void
StreamPayload
<
bool
>
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
Span
<
const
char
>
aKey
const
bool
&
aPayload
)
{
aWriter
.
BoolProperty
(
aKey
aPayload
)
;
}
template
<
>
inline
void
StreamPayload
<
ProfilerString16View
>
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
Span
<
const
char
>
aKey
const
ProfilerString16View
&
aPayload
)
{
aWriter
.
StringProperty
(
aKey
NS_ConvertUTF16toUTF8
(
aPayload
)
)
;
}
template
<
>
inline
void
StreamPayload
<
ProfilerString8View
>
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
Span
<
const
char
>
aKey
const
ProfilerString8View
&
aPayload
)
{
aWriter
.
StringProperty
(
aKey
aPayload
)
;
}
}
template
<
typename
T
>
struct
BaseMarkerType
{
static
constexpr
const
char
*
AllLabels
=
nullptr
;
static
constexpr
const
char
*
ChartLabel
=
nullptr
;
static
constexpr
const
char
*
TableLabel
=
nullptr
;
static
constexpr
const
char
*
TooltipLabel
=
nullptr
;
static
constexpr
MarkerSchema
:
:
ETWMarkerGroup
Group
=
MarkerSchema
:
:
ETWMarkerGroup
:
:
Generic
;
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
T
:
:
Locations
std
:
:
size
(
T
:
:
Locations
)
}
;
if
(
T
:
:
AllLabels
)
{
schema
.
SetAllLabels
(
T
:
:
AllLabels
)
;
}
if
(
T
:
:
ChartLabel
)
{
schema
.
SetChartLabel
(
T
:
:
ChartLabel
)
;
}
if
(
T
:
:
TableLabel
)
{
schema
.
SetTableLabel
(
T
:
:
TableLabel
)
;
}
if
(
T
:
:
TooltipLabel
)
{
schema
.
SetTooltipLabel
(
T
:
:
TooltipLabel
)
;
}
for
(
const
MS
:
:
PayloadField
field
:
T
:
:
PayloadFields
)
{
if
(
field
.
Label
)
{
if
(
uint32_t
(
field
.
Flags
)
&
uint32_t
(
MS
:
:
PayloadFlags
:
:
Searchable
)
)
{
schema
.
AddKeyLabelFormatSearchable
(
field
.
Key
field
.
Label
field
.
Fmt
MS
:
:
Searchable
:
:
Searchable
)
;
}
else
{
schema
.
AddKeyLabelFormat
(
field
.
Key
field
.
Label
field
.
Fmt
)
;
}
}
else
{
if
(
uint32_t
(
field
.
Flags
)
&
uint32_t
(
MS
:
:
PayloadFlags
:
:
Searchable
)
)
{
schema
.
AddKeyFormatSearchable
(
field
.
Key
field
.
Fmt
MS
:
:
Searchable
:
:
Searchable
)
;
}
else
{
schema
.
AddKeyFormat
(
field
.
Key
field
.
Fmt
)
;
}
}
}
if
(
T
:
:
Description
)
{
schema
.
AddStaticLabelValue
(
"
Description
"
T
:
:
Description
)
;
}
return
schema
;
}
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
T
:
:
Name
)
;
}
template
<
typename
.
.
.
PayloadArguments
>
static
void
StreamJSONMarkerDataImpl
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
PayloadArguments
&
.
.
.
aPayloadArguments
)
{
size_t
i
=
0
;
(
detail
:
:
StreamPayload
(
aWriter
MakeStringSpan
(
T
:
:
PayloadFields
[
i
+
+
]
.
Key
)
aPayloadArguments
)
.
.
.
)
;
}
}
;
}
#
endif
