#
ifndef
GeckoProfiler_h
#
define
GeckoProfiler_h
#
include
"
mozilla
/
ProfilerCounts
.
h
"
#
ifndef
MOZ_GECKO_PROFILER
#
define
AUTO_PROFILER_INIT
#
define
PROFILER_REGISTER_THREAD
(
name
)
#
define
PROFILER_UNREGISTER_THREAD
(
)
#
define
AUTO_PROFILER_REGISTER_THREAD
(
name
)
#
define
AUTO_PROFILER_THREAD_SLEEP
#
define
AUTO_PROFILER_THREAD_WAKE
#
define
PROFILER_JS_INTERRUPT_CALLBACK
(
)
#
define
PROFILER_SET_JS_CONTEXT
(
cx
)
#
define
PROFILER_CLEAR_JS_CONTEXT
(
)
#
define
AUTO_PROFILER_LABEL
(
label
category
)
#
define
AUTO_PROFILER_LABEL_DYNAMIC_CSTR
(
label
category
cStr
)
#
define
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING
(
label
category
nsCStr
)
#
define
AUTO_PROFILER_LABEL_DYNAMIC_LOSSY_NSSTRING
(
label
category
nsStr
)
#
define
AUTO_PROFILER_LABEL_FAST
(
label
category
ctx
)
#
define
AUTO_PROFILER_LABEL_DYNAMIC_FAST
(
label
dynamicString
category
\
ctx
flags
)
#
define
PROFILER_ADD_MARKER
(
markerName
category
)
#
define
PROFILER_ADD_NETWORK_MARKER
(
uri
pri
channel
type
start
end
\
count
cache
timings
redirect
)
#
define
DECLARE_DOCSHELL_AND_HISTORY_ID
(
docShell
)
#
define
PROFILER_TRACING
(
categoryString
markerName
category
kind
)
#
define
PROFILER_TRACING_DOCSHELL
(
categoryString
markerName
category
\
kind
docshell
)
#
define
AUTO_PROFILER_TRACING
(
categoryString
markerName
category
)
#
define
AUTO_PROFILER_TRACING_DOCSHELL
(
categoryString
markerName
category
\
docShell
)
#
define
AUTO_PROFILER_TEXT_MARKER_CAUSE
(
markerName
text
category
cause
)
#
define
AUTO_PROFILER_TEXT_MARKER_DOCSHELL
(
markerName
text
category
\
docShell
)
#
define
AUTO_PROFILER_TEXT_MARKER_DOCSHELL_CAUSE
(
markerName
text
category
\
docShell
cause
)
#
else
#
include
"
js
/
ProfilingStack
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsString
.
h
"
#
include
<
stdint
.
h
>
class
ProfilerBacktrace
;
class
ProfilerMarkerPayload
;
class
SpliceableJSONWriter
;
namespace
mozilla
{
namespace
net
{
struct
TimingStruct
;
enum
CacheDisposition
:
uint8_t
;
}
}
class
nsIURI
;
namespace
mozilla
{
class
MallocAllocPolicy
;
template
<
class
T
size_t
MinInlineCapacity
class
AllocPolicy
>
class
Vector
;
}
#
define
PROFILER_RAII_PASTE
(
id
line
)
id
#
#
line
#
define
PROFILER_RAII_EXPAND
(
id
line
)
PROFILER_RAII_PASTE
(
id
line
)
#
define
PROFILER_RAII
PROFILER_RAII_EXPAND
(
raiiObject
__LINE__
)
#
define
PROFILER_FOR_EACH_FEATURE
(
MACRO
)
\
MACRO
(
0
"
java
"
Java
)
\
\
/
*
Get
the
JS
engine
to
expose
the
JS
stack
to
the
profiler
*
/
\
MACRO
(
1
"
js
"
JS
)
\
\
/
*
Include
the
C
+
+
leaf
node
if
not
stackwalking
.
*
/
\
/
*
The
DevTools
profiler
doesn
'
t
want
the
native
addresses
.
*
/
\
MACRO
(
2
"
leaf
"
Leaf
)
\
\
/
*
Add
main
thread
I
/
O
to
the
profile
.
*
/
\
MACRO
(
3
"
mainthreadio
"
MainThreadIO
)
\
\
/
*
Add
memory
measurements
(
e
.
g
.
RSS
)
.
*
/
\
MACRO
(
4
"
memory
"
Memory
)
\
\
/
*
Do
not
include
user
-
identifiable
information
.
*
/
\
MACRO
(
5
"
privacy
"
Privacy
)
\
\
/
*
Collect
thread
responsiveness
information
.
*
/
\
MACRO
(
6
"
responsiveness
"
Responsiveness
)
\
\
/
*
Take
a
snapshot
of
the
window
on
every
composition
.
*
/
\
MACRO
(
7
"
screenshots
"
Screenshots
)
\
\
/
*
Disable
parallel
traversal
in
styling
.
*
/
\
MACRO
(
8
"
seqstyle
"
SequentialStyle
)
\
\
/
*
Walk
the
C
+
+
stack
.
Not
available
on
all
platforms
.
*
/
\
MACRO
(
9
"
stackwalk
"
StackWalk
)
\
\
/
*
Start
profiling
with
feature
TaskTracer
.
*
/
\
MACRO
(
10
"
tasktracer
"
TaskTracer
)
\
\
/
*
Profile
the
registered
secondary
threads
.
*
/
\
MACRO
(
11
"
threads
"
Threads
)
\
\
/
*
Have
the
JavaScript
engine
track
JIT
optimizations
.
*
/
\
MACRO
(
12
"
trackopts
"
TrackOptimizations
)
\
\
/
*
Enable
tracing
of
the
JavaScript
engine
.
*
/
\
MACRO
(
13
"
jstracer
"
JSTracer
)
struct
ProfilerFeature
{
#
define
DECLARE
(
n_
str_
Name_
)
\
static
const
uint32_t
Name_
=
(
1u
<
<
n_
)
;
\
static
bool
Has
#
#
Name_
(
uint32_t
aFeatures
)
{
return
aFeatures
&
Name_
;
}
\
static
void
Set
#
#
Name_
(
uint32_t
&
aFeatures
)
{
aFeatures
|
=
Name_
;
}
\
static
void
Clear
#
#
Name_
(
uint32_t
&
aFeatures
)
{
aFeatures
&
=
~
Name_
;
}
PROFILER_FOR_EACH_FEATURE
(
DECLARE
)
#
undef
DECLARE
}
;
namespace
mozilla
{
namespace
profiler
{
namespace
detail
{
class
RacyFeatures
{
public
:
static
void
SetActive
(
uint32_t
aFeatures
)
{
sActiveAndFeatures
=
Active
|
aFeatures
;
}
static
void
SetInactive
(
)
{
sActiveAndFeatures
=
0
;
}
static
bool
IsActive
(
)
{
return
uint32_t
(
sActiveAndFeatures
)
&
Active
;
}
static
bool
IsActiveWithFeature
(
uint32_t
aFeature
)
{
uint32_t
af
=
sActiveAndFeatures
;
return
(
af
&
Active
)
&
&
(
af
&
aFeature
)
;
}
static
bool
IsActiveWithoutPrivacy
(
)
{
uint32_t
af
=
sActiveAndFeatures
;
return
(
af
&
Active
)
&
&
!
(
af
&
ProfilerFeature
:
:
Privacy
)
;
}
private
:
static
const
uint32_t
Active
=
1u
<
<
31
;
#
define
NO_OVERLAP
(
n_
str_
Name_
)
\
static_assert
(
ProfilerFeature
:
:
Name_
!
=
Active
"
bad
Active
value
"
)
;
PROFILER_FOR_EACH_FEATURE
(
NO_OVERLAP
)
;
#
undef
NO_OVERLAP
static
mozilla
:
:
Atomic
<
uint32_t
mozilla
:
:
MemoryOrdering
:
:
Relaxed
recordreplay
:
:
Behavior
:
:
DontPreserve
>
sActiveAndFeatures
;
}
;
bool
IsThreadBeingProfiled
(
)
;
}
}
}
#
if
!
defined
(
ARCH_ARMV6
)
#
define
PROFILER_DEFAULT_ENTRIES
1000000
#
else
#
define
PROFILER_DEFAULT_ENTRIES
100000
#
endif
#
define
PROFILER_DEFAULT_DURATION
20
#
define
PROFILER_DEFAULT_INTERVAL
1
void
profiler_init
(
void
*
stackTop
)
;
#
define
AUTO_PROFILER_INIT
mozilla
:
:
AutoProfilerInit
PROFILER_RAII
void
profiler_shutdown
(
)
;
void
profiler_start
(
uint32_t
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
mozilla
:
:
Maybe
<
double
>
&
aDuration
=
mozilla
:
:
Nothing
(
)
)
;
void
profiler_stop
(
)
;
void
profiler_ensure_started
(
uint32_t
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
const
mozilla
:
:
Maybe
<
double
>
&
aDuration
=
mozilla
:
:
Nothing
(
)
)
;
#
define
PROFILER_REGISTER_THREAD
(
name
)
\
do
{
\
char
stackTop
;
\
profiler_register_thread
(
name
&
stackTop
)
;
\
}
while
(
0
)
#
define
PROFILER_UNREGISTER_THREAD
(
)
profiler_unregister_thread
(
)
ProfilingStack
*
profiler_register_thread
(
const
char
*
name
void
*
guessStackTop
)
;
void
profiler_unregister_thread
(
)
;
void
profiler_register_page
(
const
nsID
&
aDocShellId
uint32_t
aHistoryId
const
nsCString
&
aUrl
bool
aIsSubFrame
)
;
void
profiler_unregister_pages
(
const
nsID
&
aRegisteredDocShellId
)
;
class
BaseProfilerCount
;
void
profiler_add_sampled_counter
(
BaseProfilerCount
*
aCounter
)
;
void
profiler_remove_sampled_counter
(
BaseProfilerCount
*
aCounter
)
;
#
define
AUTO_PROFILER_REGISTER_THREAD
(
name
)
\
mozilla
:
:
AutoProfilerRegisterThread
PROFILER_RAII
(
name
)
void
profiler_pause
(
)
;
void
profiler_resume
(
)
;
void
profiler_thread_sleep
(
)
;
void
profiler_thread_wake
(
)
;
#
define
AUTO_PROFILER_THREAD_SLEEP
\
mozilla
:
:
AutoProfilerThreadSleep
PROFILER_RAII
#
define
AUTO_PROFILER_THREAD_WAKE
\
mozilla
:
:
AutoProfilerThreadWake
PROFILER_RAII
#
define
PROFILER_JS_INTERRUPT_CALLBACK
(
)
profiler_js_interrupt_callback
(
)
void
profiler_js_interrupt_callback
(
)
;
#
define
PROFILER_SET_JS_CONTEXT
(
cx
)
profiler_set_js_context
(
cx
)
#
define
PROFILER_CLEAR_JS_CONTEXT
(
)
profiler_clear_js_context
(
)
void
profiler_set_js_context
(
JSContext
*
aCx
)
;
void
profiler_clear_js_context
(
)
;
inline
bool
profiler_is_active
(
)
{
return
mozilla
:
:
profiler
:
:
detail
:
:
RacyFeatures
:
:
IsActive
(
)
;
}
inline
bool
profiler_thread_is_being_profiled
(
)
{
return
profiler_is_active
(
)
&
&
mozilla
:
:
profiler
:
:
detail
:
:
IsThreadBeingProfiled
(
)
;
}
bool
profiler_is_paused
(
)
;
bool
profiler_thread_is_sleeping
(
)
;
uint32_t
profiler_get_available_features
(
)
;
bool
profiler_feature_active
(
uint32_t
aFeature
)
;
void
profiler_get_start_params
(
int
*
aEntrySize
mozilla
:
:
Maybe
<
double
>
*
aDuration
double
*
aInterval
uint32_t
*
aFeatures
mozilla
:
:
Vector
<
const
char
*
0
mozilla
:
:
MallocAllocPolicy
>
*
aFilters
)
;
double
profiler_time
(
)
;
int
profiler_current_thread_id
(
)
;
class
ProfilerStackCollector
{
public
:
virtual
mozilla
:
:
Maybe
<
uint64_t
>
SamplePositionInBuffer
(
)
{
return
mozilla
:
:
Nothing
(
)
;
}
virtual
mozilla
:
:
Maybe
<
uint64_t
>
BufferRangeStart
(
)
{
return
mozilla
:
:
Nothing
(
)
;
}
virtual
void
SetIsMainThread
(
)
{
}
virtual
void
CollectNativeLeafAddr
(
void
*
aAddr
)
=
0
;
virtual
void
CollectJitReturnAddr
(
void
*
aAddr
)
=
0
;
virtual
void
CollectWasmFrame
(
const
char
*
aLabel
)
=
0
;
virtual
void
CollectProfilingStackFrame
(
const
js
:
:
ProfilingStackFrame
&
aFrame
)
=
0
;
}
;
void
profiler_suspend_and_sample_thread
(
int
aThreadId
uint32_t
aFeatures
ProfilerStackCollector
&
aCollector
bool
aSampleNative
=
true
)
;
struct
ProfilerBacktraceDestructor
{
void
operator
(
)
(
ProfilerBacktrace
*
)
;
}
;
using
UniqueProfilerBacktrace
=
mozilla
:
:
UniquePtr
<
ProfilerBacktrace
ProfilerBacktraceDestructor
>
;
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
;
struct
ProfilerBufferInfo
{
uint64_t
mRangeStart
;
uint64_t
mRangeEnd
;
uint32_t
mEntryCount
;
}
;
mozilla
:
:
Maybe
<
ProfilerBufferInfo
>
profiler_get_buffer_info
(
)
;
#
define
AUTO_PROFILER_LABEL
(
label
category
)
\
mozilla
:
:
AutoProfilerLabel
PROFILER_RAII
(
\
label
nullptr
js
:
:
ProfilingStackFrame
:
:
Category
:
:
category
)
#
define
AUTO_PROFILER_LABEL_DYNAMIC_CSTR
(
label
category
cStr
)
\
mozilla
:
:
AutoProfilerLabel
PROFILER_RAII
(
\
label
cStr
js
:
:
ProfilingStackFrame
:
:
Category
:
:
category
)
#
define
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING
(
label
category
nsCStr
)
\
mozilla
:
:
Maybe
<
nsAutoCString
>
autoCStr
;
\
mozilla
:
:
Maybe
<
AutoProfilerLabel
>
raiiObjectNsCString
;
\
if
(
profiler_is_active
(
)
)
{
\
autoCStr
.
emplace
(
nsCStr
)
;
\
raiiObjectNsCString
.
emplace
(
\
label
autoCStr
-
>
get
(
)
\
js
:
:
ProfilingStackFrame
:
:
Category
:
:
category
)
;
\
}
#
define
AUTO_PROFILER_LABEL_DYNAMIC_LOSSY_NSSTRING
(
label
category
nsStr
)
\
mozilla
:
:
Maybe
<
NS_LossyConvertUTF16toASCII
>
asciiStr
;
\
mozilla
:
:
Maybe
<
AutoProfilerLabel
>
raiiObjectLossyNsString
;
\
if
(
profiler_is_active
(
)
)
{
\
asciiStr
.
emplace
(
nsStr
)
;
\
raiiObjectLossyNsString
.
emplace
(
\
label
asciiStr
-
>
get
(
)
\
js
:
:
ProfilingStackFrame
:
:
Category
:
:
category
)
;
\
}
#
define
AUTO_PROFILER_LABEL_FAST
(
label
category
ctx
)
\
mozilla
:
:
AutoProfilerLabel
PROFILER_RAII
(
\
ctx
label
nullptr
js
:
:
ProfilingStackFrame
:
:
Category
:
:
category
)
#
define
AUTO_PROFILER_LABEL_DYNAMIC_FAST
(
label
dynamicString
category
\
ctx
flags
)
\
mozilla
:
:
AutoProfilerLabel
PROFILER_RAII
(
\
ctx
label
dynamicString
\
js
:
:
ProfilingStackFrame
:
:
Category
:
:
category
flags
)
#
define
PROFILER_ADD_MARKER
(
markerName
category
)
\
profiler_add_marker
(
markerName
js
:
:
ProfilingStackFrame
:
:
Category
:
:
category
)
void
profiler_add_marker
(
const
char
*
aMarkerName
js
:
:
ProfilingStackFrame
:
:
Category
aCategory
)
;
void
profiler_add_marker
(
const
char
*
aMarkerName
js
:
:
ProfilingStackFrame
:
:
Category
aCategory
mozilla
:
:
UniquePtr
<
ProfilerMarkerPayload
>
aPayload
)
;
void
profiler_add_js_marker
(
const
char
*
aMarkerName
)
;
void
profiler_add_marker_for_thread
(
int
aThreadId
js
:
:
ProfilingStackFrame
:
:
Category
aCategory
const
char
*
aMarkerName
mozilla
:
:
UniquePtr
<
ProfilerMarkerPayload
>
aPayload
)
;
enum
class
NetworkLoadType
{
LOAD_START
LOAD_STOP
LOAD_REDIRECT
}
;
#
define
PROFILER_ADD_NETWORK_MARKER
(
uri
pri
channel
type
start
end
\
count
cache
timings
redirect
)
\
profiler_add_network_marker
(
uri
pri
channel
type
start
end
count
\
cache
timings
redirect
)
void
profiler_add_network_marker
(
nsIURI
*
aURI
int32_t
aPriority
uint64_t
aChannelId
NetworkLoadType
aType
mozilla
:
:
TimeStamp
aStart
mozilla
:
:
TimeStamp
aEnd
int64_t
aCount
mozilla
:
:
net
:
:
CacheDisposition
aCacheDisposition
const
mozilla
:
:
net
:
:
TimingStruct
*
aTimings
=
nullptr
nsIURI
*
aRedirectURI
=
nullptr
)
;
enum
TracingKind
{
TRACING_EVENT
TRACING_INTERVAL_START
TRACING_INTERVAL_END
}
;
#
define
DECLARE_DOCSHELL_AND_HISTORY_ID
(
docShell
)
\
mozilla
:
:
Maybe
<
nsID
>
docShellId
;
\
mozilla
:
:
Maybe
<
uint32_t
>
docShellHistoryId
;
\
if
(
docShell
)
{
\
docShellId
=
Some
(
docShell
-
>
HistoryID
(
)
)
;
\
uint32_t
id
;
\
nsresult
rv
=
docShell
-
>
GetOSHEId
(
&
id
)
;
\
if
(
NS_SUCCEEDED
(
rv
)
)
{
\
docShellHistoryId
=
Some
(
id
)
;
\
}
else
{
\
docShellHistoryId
=
Nothing
(
)
;
\
}
\
}
else
{
\
docShellId
=
Nothing
(
)
;
\
docShellHistoryId
=
Nothing
(
)
;
\
}
#
define
PROFILER_TRACING
(
categoryString
markerName
category
kind
)
\
profiler_tracing
(
categoryString
markerName
\
js
:
:
ProfilingStackFrame
:
:
Category
:
:
category
kind
)
#
define
PROFILER_TRACING_DOCSHELL
(
categoryString
markerName
category
\
kind
docShell
)
\
DECLARE_DOCSHELL_AND_HISTORY_ID
(
docShell
)
;
\
profiler_tracing
(
categoryString
markerName
\
js
:
:
ProfilingStackFrame
:
:
Category
:
:
category
kind
\
docShellId
docShellHistoryId
)
void
profiler_tracing
(
const
char
*
aCategoryString
const
char
*
aMarkerName
js
:
:
ProfilingStackFrame
:
:
Category
aCategory
TracingKind
aKind
const
mozilla
:
:
Maybe
<
nsID
>
&
aDocShellId
=
mozilla
:
:
Nothing
(
)
const
mozilla
:
:
Maybe
<
uint32_t
>
&
aDocShellHistoryId
=
mozilla
:
:
Nothing
(
)
)
;
void
profiler_tracing
(
const
char
*
aCategoryString
const
char
*
aMarkerName
js
:
:
ProfilingStackFrame
:
:
Category
aCategory
TracingKind
aKind
UniqueProfilerBacktrace
aCause
const
mozilla
:
:
Maybe
<
nsID
>
&
aDocShellId
=
mozilla
:
:
Nothing
(
)
const
mozilla
:
:
Maybe
<
uint32_t
>
&
aDocShellHistoryId
=
mozilla
:
:
Nothing
(
)
)
;
#
define
AUTO_PROFILER_TRACING
(
categoryString
markerName
category
)
\
mozilla
:
:
AutoProfilerTracing
PROFILER_RAII
(
\
categoryString
markerName
\
js
:
:
ProfilingStackFrame
:
:
Category
:
:
category
mozilla
:
:
Nothing
(
)
\
mozilla
:
:
Nothing
(
)
)
#
define
AUTO_PROFILER_TRACING_DOCSHELL
(
categoryString
markerName
category
\
docShell
)
\
DECLARE_DOCSHELL_AND_HISTORY_ID
(
docShell
)
;
\
mozilla
:
:
AutoProfilerTracing
PROFILER_RAII
(
\
categoryString
markerName
\
js
:
:
ProfilingStackFrame
:
:
Category
:
:
category
docShellId
\
docShellHistoryId
)
void
profiler_add_text_marker
(
const
char
*
aMarkerName
const
nsACString
&
aText
js
:
:
ProfilingStackFrame
:
:
Category
aCategory
const
mozilla
:
:
TimeStamp
&
aStartTime
const
mozilla
:
:
TimeStamp
&
aEndTime
const
mozilla
:
:
Maybe
<
nsID
>
&
aDocShellId
=
mozilla
:
:
Nothing
(
)
const
mozilla
:
:
Maybe
<
uint32_t
>
&
aDocShellHistoryId
=
mozilla
:
:
Nothing
(
)
UniqueProfilerBacktrace
aCause
=
nullptr
)
;
class
MOZ_RAII
AutoProfilerTextMarker
{
public
:
AutoProfilerTextMarker
(
const
char
*
aMarkerName
const
nsACString
&
aText
js
:
:
ProfilingStackFrame
:
:
Category
aCategory
const
mozilla
:
:
Maybe
<
nsID
>
&
aDocShellId
const
mozilla
:
:
Maybe
<
uint32_t
>
&
aDocShellHistoryId
UniqueProfilerBacktrace
&
&
aCause
=
nullptr
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mMarkerName
(
aMarkerName
)
mText
(
aText
)
mCategory
(
aCategory
)
mStartTime
(
mozilla
:
:
TimeStamp
:
:
Now
(
)
)
mCause
(
std
:
:
move
(
aCause
)
)
mDocShellId
(
aDocShellId
)
mDocShellHistoryId
(
aDocShellHistoryId
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoProfilerTextMarker
(
)
{
profiler_add_text_marker
(
mMarkerName
mText
js
:
:
ProfilingStackFrame
:
:
Category
:
:
LAYOUT
mStartTime
mozilla
:
:
TimeStamp
:
:
Now
(
)
mDocShellId
mDocShellHistoryId
std
:
:
move
(
mCause
)
)
;
}
protected
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
const
char
*
mMarkerName
;
nsCString
mText
;
const
js
:
:
ProfilingStackFrame
:
:
Category
mCategory
;
mozilla
:
:
TimeStamp
mStartTime
;
UniqueProfilerBacktrace
mCause
;
const
mozilla
:
:
Maybe
<
nsID
>
mDocShellId
;
const
mozilla
:
:
Maybe
<
uint32_t
>
mDocShellHistoryId
;
}
;
#
define
AUTO_PROFILER_TEXT_MARKER_CAUSE
(
markerName
text
category
cause
)
\
AutoProfilerTextMarker
PROFILER_RAII
(
\
markerName
text
js
:
:
ProfilingStackFrame
:
:
Category
:
:
category
\
Nothing
(
)
Nothing
(
)
cause
)
#
define
AUTO_PROFILER_TEXT_MARKER_DOCSHELL
(
markerName
text
category
\
docShell
)
\
DECLARE_DOCSHELL_AND_HISTORY_ID
(
docShell
)
;
\
AutoProfilerTextMarker
PROFILER_RAII
(
\
markerName
text
js
:
:
ProfilingStackFrame
:
:
Category
:
:
category
\
docShellId
docShellHistoryId
)
#
define
AUTO_PROFILER_TEXT_MARKER_DOCSHELL_CAUSE
(
markerName
text
category
\
docShell
cause
)
\
DECLARE_DOCSHELL_AND_HISTORY_ID
(
docShell
)
;
\
AutoProfilerTextMarker
PROFILER_RAII
(
\
markerName
text
js
:
:
ProfilingStackFrame
:
:
Category
:
:
category
\
docShellId
docShellHistoryId
cause
)
void
profiler_set_process_name
(
const
nsACString
&
aProcessName
)
;
mozilla
:
:
UniquePtr
<
char
[
]
>
profiler_get_profile
(
double
aSinceTime
=
0
bool
aIsShuttingDown
=
false
)
;
bool
profiler_stream_json_for_this_process
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
=
0
bool
aIsShuttingDown
=
false
)
;
extern
"
C
"
{
void
profiler_save_profile_to_file
(
const
char
*
aFilename
)
;
}
namespace
mozilla
{
class
MOZ_RAII
AutoProfilerInit
{
public
:
explicit
AutoProfilerInit
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_init
(
this
)
;
}
~
AutoProfilerInit
(
)
{
profiler_shutdown
(
)
;
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoProfilerRegisterThread
final
{
public
:
explicit
AutoProfilerRegisterThread
(
const
char
*
aName
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_register_thread
(
aName
this
)
;
}
~
AutoProfilerRegisterThread
(
)
{
profiler_unregister_thread
(
)
;
}
private
:
AutoProfilerRegisterThread
(
const
AutoProfilerRegisterThread
&
)
=
delete
;
AutoProfilerRegisterThread
&
operator
=
(
const
AutoProfilerRegisterThread
&
)
=
delete
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoProfilerThreadSleep
{
public
:
explicit
AutoProfilerThreadSleep
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_thread_sleep
(
)
;
}
~
AutoProfilerThreadSleep
(
)
{
profiler_thread_wake
(
)
;
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoProfilerThreadWake
{
public
:
explicit
AutoProfilerThreadWake
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
:
mIssuedWake
(
profiler_thread_is_sleeping
(
)
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
mIssuedWake
)
{
profiler_thread_wake
(
)
;
}
}
~
AutoProfilerThreadWake
(
)
{
if
(
mIssuedWake
)
{
MOZ_ASSERT
(
!
profiler_thread_is_sleeping
(
)
)
;
profiler_thread_sleep
(
)
;
}
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
bool
mIssuedWake
;
}
;
class
MOZ_RAII
AutoProfilerLabel
{
public
:
AutoProfilerLabel
(
const
char
*
aLabel
const
char
*
aDynamicString
js
:
:
ProfilingStackFrame
:
:
Category
aCategory
uint32_t
aFlags
=
0
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
Push
(
sProfilingStack
.
get
(
)
aLabel
aDynamicString
aCategory
aFlags
)
;
}
AutoProfilerLabel
(
JSContext
*
aJSContext
const
char
*
aLabel
const
char
*
aDynamicString
js
:
:
ProfilingStackFrame
:
:
Category
aCategory
uint32_t
aFlags
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
Push
(
js
:
:
GetContextProfilingStackIfEnabled
(
aJSContext
)
aLabel
aDynamicString
aCategory
aFlags
)
;
}
void
Push
(
ProfilingStack
*
aProfilingStack
const
char
*
aLabel
const
char
*
aDynamicString
js
:
:
ProfilingStackFrame
:
:
Category
aCategory
uint32_t
aFlags
=
0
)
{
mProfilingStack
=
aProfilingStack
;
if
(
mProfilingStack
)
{
mProfilingStack
-
>
pushLabelFrame
(
aLabel
aDynamicString
this
aCategory
aFlags
)
;
}
}
~
AutoProfilerLabel
(
)
{
if
(
mProfilingStack
)
{
mProfilingStack
-
>
pop
(
)
;
}
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
ProfilingStack
*
mProfilingStack
;
public
:
static
MOZ_THREAD_LOCAL
(
ProfilingStack
*
)
sProfilingStack
;
}
;
class
MOZ_RAII
AutoProfilerTracing
{
public
:
AutoProfilerTracing
(
const
char
*
aCategoryString
const
char
*
aMarkerName
js
:
:
ProfilingStackFrame
:
:
Category
aCategory
const
mozilla
:
:
Maybe
<
nsID
>
&
aDocShellId
const
mozilla
:
:
Maybe
<
uint32_t
>
&
aDocShellHistoryId
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mCategoryString
(
aCategoryString
)
mMarkerName
(
aMarkerName
)
mCategory
(
aCategory
)
mDocShellId
(
aDocShellId
)
mDocShellHistoryId
(
aDocShellHistoryId
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_tracing
(
mCategoryString
mMarkerName
aCategory
TRACING_INTERVAL_START
mDocShellId
mDocShellHistoryId
)
;
}
AutoProfilerTracing
(
const
char
*
aCategoryString
const
char
*
aMarkerName
js
:
:
ProfilingStackFrame
:
:
Category
aCategory
UniqueProfilerBacktrace
aBacktrace
const
mozilla
:
:
Maybe
<
nsID
>
&
aDocShellId
const
mozilla
:
:
Maybe
<
uint32_t
>
&
aDocShellHistoryId
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mCategoryString
(
aCategoryString
)
mMarkerName
(
aMarkerName
)
mCategory
(
aCategory
)
mDocShellId
(
aDocShellId
)
mDocShellHistoryId
(
aDocShellHistoryId
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_tracing
(
mCategoryString
mMarkerName
aCategory
TRACING_INTERVAL_START
std
:
:
move
(
aBacktrace
)
mDocShellId
mDocShellHistoryId
)
;
}
~
AutoProfilerTracing
(
)
{
profiler_tracing
(
mCategoryString
mMarkerName
mCategory
TRACING_INTERVAL_END
mDocShellId
mDocShellHistoryId
)
;
}
protected
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
const
char
*
mCategoryString
;
const
char
*
mMarkerName
;
const
js
:
:
ProfilingStackFrame
:
:
Category
mCategory
;
const
mozilla
:
:
Maybe
<
nsID
>
mDocShellId
;
const
mozilla
:
:
Maybe
<
uint32_t
>
mDocShellHistoryId
;
}
;
void
GetProfilerEnvVarsForChildProcess
(
std
:
:
function
<
void
(
const
char
*
key
const
char
*
value
)
>
&
&
aSetEnv
)
;
}
#
endif
#
endif
