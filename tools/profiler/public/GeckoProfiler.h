#
ifndef
GeckoProfiler_h
#
define
GeckoProfiler_h
#
include
"
BaseProfiler
.
h
"
#
include
"
mozilla
/
ProfilerCounts
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
ProfilerState
.
h
"
enum
class
IsFastShutdown
{
No
Yes
}
;
#
ifndef
MOZ_GECKO_PROFILER
#
include
"
mozilla
/
UniquePtr
.
h
"
#
define
AUTO_PROFILER_INIT
:
:
profiler_init_main_thread_id
(
)
#
define
AUTO_PROFILER_INIT2
#
define
PROFILER_REGISTER_THREAD
(
name
)
#
define
PROFILER_UNREGISTER_THREAD
(
)
#
define
AUTO_PROFILER_REGISTER_THREAD
(
name
)
#
define
AUTO_PROFILER_THREAD_SLEEP
#
define
AUTO_PROFILER_THREAD_WAKE
#
define
PROFILER_JS_INTERRUPT_CALLBACK
(
)
#
define
PROFILER_SET_JS_CONTEXT
(
cx
)
#
define
PROFILER_CLEAR_JS_CONTEXT
(
)
#
define
AUTO_PROFILE_FOLLOWING_RUNNABLE
(
runnable
)
struct
ProfilerBacktrace
{
}
;
using
UniqueProfilerBacktrace
=
mozilla
:
:
UniquePtr
<
ProfilerBacktrace
>
;
static
inline
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
{
return
nullptr
;
}
struct
ProfileChunkedBuffer
{
}
;
static
inline
bool
profiler_capture_backtrace_into
(
mozilla
:
:
ProfileChunkedBuffer
&
aChunkedBuffer
mozilla
:
:
StackCaptureOptions
aCaptureOptions
)
{
return
false
;
}
static
inline
mozilla
:
:
UniquePtr
<
mozilla
:
:
ProfileChunkedBuffer
>
profiler_capture_backtrace
(
)
{
return
nullptr
;
}
static
inline
void
profiler_init
(
void
*
stackTop
)
{
}
static
inline
void
profiler_shutdown
(
IsFastShutdown
aIsFastShutdown
=
IsFastShutdown
:
:
No
)
{
}
static
inline
void
profiler_set_process_name
(
const
nsACString
&
aProcessName
const
nsACString
*
aETLDplus1
=
nullptr
)
{
}
static
inline
void
profiler_received_exit_profile
(
const
nsCString
&
aExitProfile
)
{
}
static
inline
void
profiler_register_page
(
uint64_t
aTabID
uint64_t
aInnerWindowID
const
nsCString
&
aUrl
uint64_t
aEmbedderInnerWindowID
)
{
}
static
inline
void
profiler_unregister_page
(
uint64_t
aRegisteredInnerWindowID
)
{
}
static
inline
void
GetProfilerEnvVarsForChildProcess
(
std
:
:
function
<
void
(
const
char
*
key
const
char
*
value
)
>
&
&
aSetEnv
)
{
}
#
else
#
include
"
js
/
ProfilingStack
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PowerOfTwo
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
<
functional
>
#
include
<
stdint
.
h
>
class
ProfilerBacktrace
;
class
ProfilerCodeAddressService
;
struct
JSContext
;
namespace
mozilla
{
class
ProfileBufferControlledChunkManager
;
class
ProfileChunkedBuffer
;
namespace
baseprofiler
{
class
SpliceableJSONWriter
;
}
}
class
nsIURI
;
namespace
mozilla
{
class
MallocAllocPolicy
;
template
<
class
T
size_t
MinInlineCapacity
class
AllocPolicy
>
class
Vector
;
}
#
define
PROFILER_RAII_PASTE
(
id
line
)
id
#
#
line
#
define
PROFILER_RAII_EXPAND
(
id
line
)
PROFILER_RAII_PASTE
(
id
line
)
#
define
PROFILER_RAII
PROFILER_RAII_EXPAND
(
raiiObject
__LINE__
)
static
constexpr
mozilla
:
:
PowerOfTwo32
PROFILER_DEFAULT_ENTRIES
=
#
if
!
defined
(
GP_PLAT_arm_android
)
mozilla
:
:
MakePowerOfTwo32
<
8
*
1024
*
1024
>
(
)
;
#
else
mozilla
:
:
MakePowerOfTwo32
<
2
*
1024
*
1024
>
(
)
;
/
/
2M
entries
=
16MB
#
endif
static
constexpr
mozilla
:
:
PowerOfTwo32
PROFILER_DEFAULT_STARTUP_ENTRIES
=
#
if
!
defined
(
GP_PLAT_arm_android
)
mozilla
:
:
MakePowerOfTwo32
<
64
*
1024
*
1024
>
(
)
;
#
else
mozilla
:
:
MakePowerOfTwo32
<
8
*
1024
*
1024
>
(
)
;
#
endif
#
define
PROFILER_DEFAULT_DURATION
20
/
*
seconds
for
tests
only
*
/
#
define
PROFILER_DEFAULT_INTERVAL
1
/
*
millisecond
*
/
#
define
PROFILER_MAX_INTERVAL
5000
/
*
milliseconds
*
/
#
define
PROFILER_DEFAULT_ACTIVE_TAB_ID
0
void
profiler_init
(
void
*
stackTop
)
;
void
profiler_init_threadmanager
(
)
;
#
define
AUTO_PROFILER_INIT
mozilla
:
:
AutoProfilerInit
PROFILER_RAII
#
define
AUTO_PROFILER_INIT2
mozilla
:
:
AutoProfilerInit2
PROFILER_RAII
void
profiler_shutdown
(
IsFastShutdown
aIsFastShutdown
=
IsFastShutdown
:
:
No
)
;
void
profiler_start
(
mozilla
:
:
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
const
mozilla
:
:
Maybe
<
double
>
&
aDuration
=
mozilla
:
:
Nothing
(
)
)
;
void
profiler_stop
(
)
;
void
profiler_ensure_started
(
mozilla
:
:
PowerOfTwo32
aCapacity
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
uint64_t
aActiveTabID
const
mozilla
:
:
Maybe
<
double
>
&
aDuration
=
mozilla
:
:
Nothing
(
)
)
;
#
define
PROFILER_REGISTER_THREAD
(
name
)
\
do
{
\
char
stackTop
;
\
profiler_register_thread
(
name
&
stackTop
)
;
\
}
while
(
0
)
#
define
PROFILER_UNREGISTER_THREAD
(
)
profiler_unregister_thread
(
)
ProfilingStack
*
profiler_register_thread
(
const
char
*
name
void
*
guessStackTop
)
;
void
profiler_unregister_thread
(
)
;
void
profiler_register_page
(
uint64_t
aTabID
uint64_t
aInnerWindowID
const
nsCString
&
aUrl
uint64_t
aEmbedderInnerWindowID
)
;
void
profiler_unregister_page
(
uint64_t
aRegisteredInnerWindowID
)
;
void
profiler_clear_all_pages
(
)
;
class
BaseProfilerCount
;
void
profiler_add_sampled_counter
(
BaseProfilerCount
*
aCounter
)
;
void
profiler_remove_sampled_counter
(
BaseProfilerCount
*
aCounter
)
;
#
define
AUTO_PROFILER_REGISTER_THREAD
(
name
)
\
mozilla
:
:
AutoProfilerRegisterThread
PROFILER_RAII
(
name
)
enum
class
SamplingState
{
JustStopped
SamplingPaused
NoStackSamplingCompleted
SamplingCompleted
}
;
using
PostSamplingCallback
=
std
:
:
function
<
void
(
SamplingState
)
>
;
[
[
nodiscard
]
]
bool
profiler_callback_after_sampling
(
PostSamplingCallback
&
&
aCallback
)
;
void
profiler_pause
(
)
;
void
profiler_resume
(
)
;
void
profiler_pause_sampling
(
)
;
void
profiler_resume_sampling
(
)
;
void
profiler_thread_sleep
(
)
;
void
profiler_thread_wake
(
)
;
#
define
AUTO_PROFILER_THREAD_SLEEP
\
mozilla
:
:
AutoProfilerThreadSleep
PROFILER_RAII
#
define
AUTO_PROFILER_THREAD_WAKE
\
mozilla
:
:
AutoProfilerThreadWake
PROFILER_RAII
#
define
PROFILER_JS_INTERRUPT_CALLBACK
(
)
profiler_js_interrupt_callback
(
)
void
profiler_js_interrupt_callback
(
)
;
#
define
PROFILER_SET_JS_CONTEXT
(
cx
)
profiler_set_js_context
(
cx
)
#
define
PROFILER_CLEAR_JS_CONTEXT
(
)
profiler_clear_js_context
(
)
void
profiler_set_js_context
(
JSContext
*
aCx
)
;
void
profiler_clear_js_context
(
)
;
void
profiler_get_start_params
(
int
*
aEntrySize
mozilla
:
:
Maybe
<
double
>
*
aDuration
double
*
aInterval
uint32_t
*
aFeatures
mozilla
:
:
Vector
<
const
char
*
0
mozilla
:
:
MallocAllocPolicy
>
*
aFilters
uint64_t
*
aActiveTabID
)
;
mozilla
:
:
ProfileBufferControlledChunkManager
*
profiler_get_controlled_chunk_manager
(
)
;
double
profiler_time
(
)
;
class
ProfilerStackCollector
{
public
:
virtual
mozilla
:
:
Maybe
<
uint64_t
>
SamplePositionInBuffer
(
)
{
return
mozilla
:
:
Nothing
(
)
;
}
virtual
mozilla
:
:
Maybe
<
uint64_t
>
BufferRangeStart
(
)
{
return
mozilla
:
:
Nothing
(
)
;
}
virtual
void
SetIsMainThread
(
)
{
}
virtual
void
CollectNativeLeafAddr
(
void
*
aAddr
)
=
0
;
virtual
void
CollectJitReturnAddr
(
void
*
aAddr
)
=
0
;
virtual
void
CollectWasmFrame
(
const
char
*
aLabel
)
=
0
;
virtual
void
CollectProfilingStackFrame
(
const
js
:
:
ProfilingStackFrame
&
aFrame
)
=
0
;
}
;
void
profiler_suspend_and_sample_thread
(
ProfilerThreadId
aThreadId
uint32_t
aFeatures
ProfilerStackCollector
&
aCollector
bool
aSampleNative
=
true
)
;
struct
ProfilerBacktraceDestructor
{
void
operator
(
)
(
ProfilerBacktrace
*
)
;
}
;
using
UniqueProfilerBacktrace
=
mozilla
:
:
UniquePtr
<
ProfilerBacktrace
ProfilerBacktraceDestructor
>
;
bool
profiler_capture_backtrace_into
(
mozilla
:
:
ProfileChunkedBuffer
&
aChunkedBuffer
mozilla
:
:
StackCaptureOptions
aCaptureOptions
)
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
ProfileChunkedBuffer
>
profiler_capture_backtrace
(
)
;
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
;
struct
ProfilerStats
{
unsigned
n
=
0
;
double
sum
=
0
;
double
min
=
std
:
:
numeric_limits
<
double
>
:
:
max
(
)
;
double
max
=
0
;
void
Count
(
double
v
)
{
+
+
n
;
sum
+
=
v
;
if
(
v
<
min
)
{
min
=
v
;
}
if
(
v
>
max
)
{
max
=
v
;
}
}
}
;
struct
ProfilerBufferInfo
{
uint64_t
mRangeStart
;
uint64_t
mRangeEnd
;
uint32_t
mEntryCount
;
ProfilerStats
mIntervalsUs
;
ProfilerStats
mOverheadsUs
;
ProfilerStats
mLockingsUs
;
ProfilerStats
mCleaningsUs
;
ProfilerStats
mCountersUs
;
ProfilerStats
mThreadsUs
;
}
;
mozilla
:
:
Maybe
<
ProfilerBufferInfo
>
profiler_get_buffer_info
(
)
;
void
profiler_set_process_name
(
const
nsACString
&
aProcessName
const
nsACString
*
aETLDplus1
=
nullptr
)
;
void
profiler_received_exit_profile
(
const
nsCString
&
aExitProfile
)
;
mozilla
:
:
UniquePtr
<
char
[
]
>
profiler_get_profile
(
double
aSinceTime
=
0
bool
aIsShuttingDown
=
false
)
;
bool
profiler_stream_json_for_this_process
(
mozilla
:
:
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
double
aSinceTime
=
0
bool
aIsShuttingDown
=
false
ProfilerCodeAddressService
*
aService
=
nullptr
)
;
extern
"
C
"
{
void
profiler_save_profile_to_file
(
const
char
*
aFilename
)
;
}
namespace
mozilla
{
class
MOZ_RAII
AutoProfilerInit
{
public
:
explicit
AutoProfilerInit
(
)
{
profiler_init
(
this
)
;
}
~
AutoProfilerInit
(
)
{
profiler_shutdown
(
)
;
}
private
:
}
;
class
MOZ_RAII
AutoProfilerInit2
{
public
:
explicit
AutoProfilerInit2
(
)
{
profiler_init_threadmanager
(
)
;
}
private
:
}
;
class
MOZ_RAII
AutoProfilerRegisterThread
final
{
public
:
explicit
AutoProfilerRegisterThread
(
const
char
*
aName
)
{
profiler_register_thread
(
aName
this
)
;
}
~
AutoProfilerRegisterThread
(
)
{
profiler_unregister_thread
(
)
;
}
private
:
AutoProfilerRegisterThread
(
const
AutoProfilerRegisterThread
&
)
=
delete
;
AutoProfilerRegisterThread
&
operator
=
(
const
AutoProfilerRegisterThread
&
)
=
delete
;
}
;
class
MOZ_RAII
AutoProfilerThreadSleep
{
public
:
explicit
AutoProfilerThreadSleep
(
)
{
profiler_thread_sleep
(
)
;
}
~
AutoProfilerThreadSleep
(
)
{
profiler_thread_wake
(
)
;
}
private
:
}
;
class
MOZ_RAII
AutoProfilerThreadWake
{
public
:
explicit
AutoProfilerThreadWake
(
)
:
mIssuedWake
(
profiler_thread_is_sleeping
(
)
)
{
if
(
mIssuedWake
)
{
profiler_thread_wake
(
)
;
}
}
~
AutoProfilerThreadWake
(
)
{
if
(
mIssuedWake
)
{
MOZ_ASSERT
(
!
profiler_thread_is_sleeping
(
)
)
;
profiler_thread_sleep
(
)
;
}
}
private
:
bool
mIssuedWake
;
}
;
void
GetProfilerEnvVarsForChildProcess
(
std
:
:
function
<
void
(
const
char
*
key
const
char
*
value
)
>
&
&
aSetEnv
)
;
#
ifndef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
#
define
AUTO_PROFILE_FOLLOWING_RUNNABLE
(
runnable
)
#
else
#
define
AUTO_PROFILE_FOLLOWING_RUNNABLE
(
runnable
)
\
mozilla
:
:
AutoProfileRunnable
PROFILER_RAII
(
runnable
)
class
MOZ_RAII
AutoProfileRunnable
{
public
:
explicit
AutoProfileRunnable
(
Runnable
*
aRunnable
)
:
mStartTime
(
TimeStamp
:
:
Now
(
)
)
{
if
(
!
profiler_thread_is_being_profiled
(
)
)
{
return
;
}
aRunnable
-
>
GetName
(
mName
)
;
}
explicit
AutoProfileRunnable
(
nsIRunnable
*
aRunnable
)
:
mStartTime
(
TimeStamp
:
:
Now
(
)
)
{
if
(
!
profiler_thread_is_being_profiled
(
)
)
{
return
;
}
nsCOMPtr
<
nsINamed
>
named
=
do_QueryInterface
(
aRunnable
)
;
if
(
named
)
{
named
-
>
GetName
(
mName
)
;
}
}
~
AutoProfileRunnable
(
)
{
if
(
!
profiler_thread_is_being_profiled
(
)
)
{
return
;
}
AUTO_PROFILER_LABEL
(
"
AutoProfileRunnable
"
PROFILER
)
;
AUTO_PROFILER_STATS
(
AUTO_PROFILE_RUNNABLE
)
;
profiler_add_marker
(
"
Runnable
"
:
:
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
MarkerTiming
:
:
IntervalUntilNowFrom
(
mStartTime
)
geckoprofiler
:
:
markers
:
:
TextMarker
{
}
mName
)
;
}
protected
:
TimeStamp
mStartTime
;
nsAutoCString
mName
;
}
;
#
endif
}
#
endif
#
endif
