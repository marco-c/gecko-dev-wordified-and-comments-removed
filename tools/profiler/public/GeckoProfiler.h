#
ifndef
SAMPLER_H
#
define
SAMPLER_H
#
include
<
stdint
.
h
>
#
include
<
stdarg
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
GeckoProfilerTypes
.
h
"
namespace
mozilla
{
class
TimeStamp
;
namespace
dom
{
class
Promise
;
}
}
class
nsIProfilerStartParams
;
enum
TracingMetadata
{
TRACING_DEFAULT
TRACING_INTERVAL_START
TRACING_INTERVAL_END
TRACING_EVENT
TRACING_EVENT_BACKTRACE
TRACING_TIMESTAMP
}
;
#
if
!
defined
(
MOZ_ENABLE_PROFILER_SPS
)
#
define
PROFILER_LABEL
(
name_space
info
category
)
do
{
}
while
(
0
)
#
define
PROFILER_LABEL_FUNC
(
category
)
do
{
}
while
(
0
)
#
define
PROFILER_LABEL_PRINTF
(
name_space
info
category
format
.
.
.
)
do
{
}
while
(
0
)
#
define
PROFILER_MARKER
(
info
)
do
{
}
while
(
0
)
#
define
PROFILER_MARKER_PAYLOAD
(
info
payload
)
do
{
mozilla
:
:
UniquePtr
<
ProfilerMarkerPayload
>
payloadDeletor
(
payload
)
;
}
while
(
0
)
static
inline
void
profiler_tracing
(
const
char
*
aCategory
const
char
*
aInfo
TracingMetadata
metaData
=
TRACING_DEFAULT
)
{
}
static
inline
void
profiler_tracing
(
const
char
*
aCategory
const
char
*
aInfo
UniqueProfilerBacktrace
aCause
TracingMetadata
metaData
=
TRACING_DEFAULT
)
{
}
static
inline
void
profiler_init
(
void
*
stackTop
)
{
}
;
static
inline
void
profiler_shutdown
(
)
{
}
;
static
inline
void
profiler_start
(
int
aProfileEntries
double
aInterval
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
*
aThreadNameFilters
uint32_t
aFilterCount
)
{
}
static
inline
void
profiler_stop
(
)
{
}
static
inline
bool
profiler_is_paused
(
)
{
return
false
;
}
static
inline
void
profiler_pause
(
)
{
}
static
inline
void
profiler_resume
(
)
{
}
static
inline
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
{
return
nullptr
;
}
static
inline
void
profiler_get_backtrace_noalloc
(
char
*
output
size_t
outputSize
)
{
return
;
}
inline
void
ProfilerBacktraceDestructor
:
:
operator
(
)
(
ProfilerBacktrace
*
aBacktrace
)
{
}
static
inline
bool
profiler_is_active
(
)
{
return
false
;
}
static
inline
bool
profiler_feature_active
(
const
char
*
)
{
return
false
;
}
static
inline
void
profiler_responsiveness
(
const
mozilla
:
:
TimeStamp
&
aTime
)
{
}
static
inline
void
profiler_set_frame_number
(
int
frameNumber
)
{
}
static
inline
mozilla
:
:
UniquePtr
<
char
[
]
>
profiler_get_profile
(
double
aSinceTime
=
0
)
{
return
nullptr
;
}
static
inline
JSObject
*
profiler_get_profile_jsobject
(
JSContext
*
aCx
double
aSinceTime
=
0
)
{
return
nullptr
;
}
static
inline
void
profiler_get_profile_jsobject_async
(
double
aSinceTime
=
0
mozilla
:
:
dom
:
:
Promise
*
=
0
)
{
}
static
inline
void
profiler_get_start_params
(
int
*
aEntrySize
double
*
aInterval
mozilla
:
:
Vector
<
const
char
*
>
*
aFilters
mozilla
:
:
Vector
<
const
char
*
>
*
aFeatures
)
{
}
static
inline
void
profiler_save_profile_to_file
(
char
*
aFilename
)
{
}
static
inline
char
*
*
profiler_get_features
(
)
{
return
nullptr
;
}
static
inline
void
profiler_get_buffer_info
(
uint32_t
*
aCurrentPosition
uint32_t
*
aTotalSize
uint32_t
*
aGeneration
)
{
*
aCurrentPosition
=
0
;
*
aTotalSize
=
0
;
*
aGeneration
=
0
;
}
static
inline
void
profiler_lock
(
)
{
}
static
inline
void
profiler_unlock
(
)
{
}
static
inline
void
profiler_register_thread
(
const
char
*
name
void
*
guessStackTop
)
{
}
static
inline
void
profiler_unregister_thread
(
)
{
}
static
inline
void
profiler_sleep_start
(
)
{
}
static
inline
void
profiler_sleep_end
(
)
{
}
static
inline
bool
profiler_is_sleeping
(
)
{
return
false
;
}
static
inline
void
profiler_js_operation_callback
(
)
{
}
static
inline
double
profiler_time
(
)
{
return
0
;
}
static
inline
double
profiler_time
(
const
mozilla
:
:
TimeStamp
&
aTime
)
{
return
0
;
}
static
inline
bool
profiler_in_privacy_mode
(
)
{
return
false
;
}
static
inline
void
profiler_log
(
const
char
*
str
)
{
}
static
inline
void
profiler_log
(
const
char
*
fmt
va_list
args
)
{
}
#
else
#
include
<
stdlib
.
h
>
#
include
<
signal
.
h
>
#
include
"
js
/
ProfilingStack
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
nscore
.
h
"
#
include
"
PseudoStack
.
h
"
#
include
"
ProfilerBacktrace
.
h
"
#
ifdef
min
#
undef
min
#
endif
class
GeckoSampler
;
class
nsISupports
;
class
ProfilerMarkerPayload
;
namespace
mozilla
{
class
TimeStamp
;
namespace
dom
{
class
Promise
;
}
}
extern
MOZ_THREAD_LOCAL
(
PseudoStack
*
)
tlsPseudoStack
;
extern
MOZ_THREAD_LOCAL
(
GeckoSampler
*
)
tlsTicker
;
extern
bool
stack_key_initialized
;
#
ifndef
SAMPLE_FUNCTION_NAME
#
ifdef
__GNUC__
#
define
SAMPLE_FUNCTION_NAME
__FUNCTION__
#
elif
defined
(
_MSC_VER
)
#
define
SAMPLE_FUNCTION_NAME
__FUNCTION__
#
else
#
define
SAMPLE_FUNCTION_NAME
__func__
/
/
defined
in
C99
supported
in
various
C
+
+
compilers
.
Just
raw
function
name
.
#
endif
#
endif
inline
void
*
mozilla_sampler_call_enter
(
const
char
*
aInfo
js
:
:
ProfileEntry
:
:
Category
aCategory
void
*
aFrameAddress
=
nullptr
bool
aCopy
=
false
uint32_t
line
=
0
)
;
inline
void
mozilla_sampler_call_exit
(
void
*
handle
)
;
void
mozilla_sampler_add_marker
(
const
char
*
aInfo
ProfilerMarkerPayload
*
aPayload
=
nullptr
)
;
void
mozilla_sampler_start
(
int
aEntries
double
aInterval
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
*
aThreadNameFilters
uint32_t
aFilterCount
)
;
void
mozilla_sampler_stop
(
)
;
bool
mozilla_sampler_is_paused
(
)
;
void
mozilla_sampler_pause
(
)
;
void
mozilla_sampler_resume
(
)
;
UniqueProfilerBacktrace
mozilla_sampler_get_backtrace
(
)
;
void
mozilla_sampler_get_backtrace_noalloc
(
char
*
output
size_t
outputSize
)
;
bool
mozilla_sampler_is_active
(
)
;
bool
mozilla_sampler_feature_active
(
const
char
*
aName
)
;
void
mozilla_sampler_responsiveness
(
const
mozilla
:
:
TimeStamp
&
time
)
;
void
mozilla_sampler_frame_number
(
int
frameNumber
)
;
mozilla
:
:
UniquePtr
<
char
[
]
>
mozilla_sampler_get_profile
(
double
aSinceTime
)
;
JSObject
*
mozilla_sampler_get_profile_data
(
JSContext
*
aCx
double
aSinceTime
)
;
void
mozilla_sampler_get_profile_data_async
(
double
aSinceTime
mozilla
:
:
dom
:
:
Promise
*
aPromise
)
;
MOZ_EXPORT
void
mozilla_sampler_save_profile_to_file_async
(
double
aSinceTime
const
char
*
aFileName
)
;
void
mozilla_sampler_get_profiler_start_params
(
int
*
aEntrySize
double
*
aInterval
mozilla
:
:
Vector
<
const
char
*
>
*
aFilters
mozilla
:
:
Vector
<
const
char
*
>
*
aFeatures
)
;
void
mozilla_sampler_get_gatherer
(
nsISupports
*
*
aRetVal
)
;
extern
"
C
"
{
void
mozilla_sampler_save_profile_to_file
(
const
char
*
aFilename
)
;
}
const
char
*
*
mozilla_sampler_get_features
(
)
;
void
mozilla_sampler_get_buffer_info
(
uint32_t
*
aCurrentPosition
uint32_t
*
aTotalSize
uint32_t
*
aGeneration
)
;
void
mozilla_sampler_init
(
void
*
stackTop
)
;
void
mozilla_sampler_shutdown
(
)
;
void
mozilla_sampler_lock
(
)
;
void
mozilla_sampler_unlock
(
)
;
bool
mozilla_sampler_register_thread
(
const
char
*
name
void
*
stackTop
)
;
void
mozilla_sampler_unregister_thread
(
)
;
void
mozilla_sampler_sleep_start
(
)
;
void
mozilla_sampler_sleep_end
(
)
;
bool
mozilla_sampler_is_sleeping
(
)
;
double
mozilla_sampler_time
(
)
;
double
mozilla_sampler_time
(
const
mozilla
:
:
TimeStamp
&
aTime
)
;
void
mozilla_sampler_tracing
(
const
char
*
aCategory
const
char
*
aInfo
TracingMetadata
aMetaData
)
;
void
mozilla_sampler_tracing
(
const
char
*
aCategory
const
char
*
aInfo
UniqueProfilerBacktrace
aCause
TracingMetadata
aMetaData
)
;
void
mozilla_sampler_log
(
const
char
*
fmt
va_list
args
)
;
static
inline
void
profiler_init
(
void
*
stackTop
)
{
mozilla_sampler_init
(
stackTop
)
;
}
static
inline
void
profiler_shutdown
(
)
{
mozilla_sampler_shutdown
(
)
;
}
static
inline
void
profiler_start
(
int
aProfileEntries
double
aInterval
const
char
*
*
aFeatures
uint32_t
aFeatureCount
const
char
*
*
aThreadNameFilters
uint32_t
aFilterCount
)
{
mozilla_sampler_start
(
aProfileEntries
aInterval
aFeatures
aFeatureCount
aThreadNameFilters
aFilterCount
)
;
}
static
inline
void
profiler_stop
(
)
{
mozilla_sampler_stop
(
)
;
}
static
inline
bool
profiler_is_paused
(
)
{
return
mozilla_sampler_is_paused
(
)
;
}
static
inline
void
profiler_pause
(
)
{
mozilla_sampler_pause
(
)
;
}
static
inline
void
profiler_resume
(
)
{
mozilla_sampler_resume
(
)
;
}
static
inline
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
{
return
mozilla_sampler_get_backtrace
(
)
;
}
static
inline
void
profiler_get_backtrace_noalloc
(
char
*
output
size_t
outputSize
)
{
return
mozilla_sampler_get_backtrace_noalloc
(
output
outputSize
)
;
}
static
inline
bool
profiler_is_active
(
)
{
return
mozilla_sampler_is_active
(
)
;
}
static
inline
bool
profiler_feature_active
(
const
char
*
aName
)
{
return
mozilla_sampler_feature_active
(
aName
)
;
}
static
inline
void
profiler_responsiveness
(
const
mozilla
:
:
TimeStamp
&
aTime
)
{
mozilla_sampler_responsiveness
(
aTime
)
;
}
static
inline
void
profiler_set_frame_number
(
int
frameNumber
)
{
return
mozilla_sampler_frame_number
(
frameNumber
)
;
}
static
inline
mozilla
:
:
UniquePtr
<
char
[
]
>
profiler_get_profile
(
double
aSinceTime
=
0
)
{
return
mozilla_sampler_get_profile
(
aSinceTime
)
;
}
static
inline
JSObject
*
profiler_get_profile_jsobject
(
JSContext
*
aCx
double
aSinceTime
=
0
)
{
return
mozilla_sampler_get_profile_data
(
aCx
aSinceTime
)
;
}
static
inline
void
profiler_get_profile_jsobject_async
(
double
aSinceTime
=
0
mozilla
:
:
dom
:
:
Promise
*
aPromise
=
0
)
{
mozilla_sampler_get_profile_data_async
(
aSinceTime
aPromise
)
;
}
static
inline
void
profiler_get_start_params
(
int
*
aEntrySize
double
*
aInterval
mozilla
:
:
Vector
<
const
char
*
>
*
aFilters
mozilla
:
:
Vector
<
const
char
*
>
*
aFeatures
)
{
mozilla_sampler_get_profiler_start_params
(
aEntrySize
aInterval
aFilters
aFeatures
)
;
}
static
inline
void
profiler_get_gatherer
(
nsISupports
*
*
aRetVal
)
{
mozilla_sampler_get_gatherer
(
aRetVal
)
;
}
static
inline
void
profiler_save_profile_to_file
(
const
char
*
aFilename
)
{
return
mozilla_sampler_save_profile_to_file
(
aFilename
)
;
}
static
inline
const
char
*
*
profiler_get_features
(
)
{
return
mozilla_sampler_get_features
(
)
;
}
static
inline
void
profiler_get_buffer_info
(
uint32_t
*
aCurrentPosition
uint32_t
*
aTotalSize
uint32_t
*
aGeneration
)
{
return
mozilla_sampler_get_buffer_info
(
aCurrentPosition
aTotalSize
aGeneration
)
;
}
static
inline
void
profiler_lock
(
)
{
return
mozilla_sampler_lock
(
)
;
}
static
inline
void
profiler_unlock
(
)
{
return
mozilla_sampler_unlock
(
)
;
}
static
inline
void
profiler_register_thread
(
const
char
*
name
void
*
guessStackTop
)
{
mozilla_sampler_register_thread
(
name
guessStackTop
)
;
}
static
inline
void
profiler_unregister_thread
(
)
{
mozilla_sampler_unregister_thread
(
)
;
}
static
inline
void
profiler_sleep_start
(
)
{
mozilla_sampler_sleep_start
(
)
;
}
static
inline
void
profiler_sleep_end
(
)
{
mozilla_sampler_sleep_end
(
)
;
}
static
inline
bool
profiler_is_sleeping
(
)
{
return
mozilla_sampler_is_sleeping
(
)
;
}
static
inline
void
profiler_js_operation_callback
(
)
{
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
stack
)
{
return
;
}
stack
-
>
jsOperationCallback
(
)
;
}
static
inline
double
profiler_time
(
)
{
return
mozilla_sampler_time
(
)
;
}
static
inline
double
profiler_time
(
const
mozilla
:
:
TimeStamp
&
aTime
)
{
return
mozilla_sampler_time
(
aTime
)
;
}
static
inline
bool
profiler_in_privacy_mode
(
)
{
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
stack
)
{
return
false
;
}
return
stack
-
>
mPrivacyMode
;
}
static
inline
void
profiler_tracing
(
const
char
*
aCategory
const
char
*
aInfo
UniqueProfilerBacktrace
aCause
TracingMetadata
aMetaData
=
TRACING_DEFAULT
)
{
if
(
!
stack_key_initialized
|
|
!
profiler_is_active
(
)
)
{
return
;
}
mozilla_sampler_tracing
(
aCategory
aInfo
mozilla
:
:
Move
(
aCause
)
aMetaData
)
;
}
static
inline
void
profiler_tracing
(
const
char
*
aCategory
const
char
*
aInfo
TracingMetadata
aMetaData
=
TRACING_DEFAULT
)
{
if
(
!
stack_key_initialized
)
return
;
if
(
!
profiler_is_active
(
)
)
{
return
;
}
mozilla_sampler_tracing
(
aCategory
aInfo
aMetaData
)
;
}
#
define
SAMPLER_APPEND_LINE_NUMBER_PASTE
(
id
line
)
id
#
#
line
#
define
SAMPLER_APPEND_LINE_NUMBER_EXPAND
(
id
line
)
SAMPLER_APPEND_LINE_NUMBER_PASTE
(
id
line
)
#
define
SAMPLER_APPEND_LINE_NUMBER
(
id
)
SAMPLER_APPEND_LINE_NUMBER_EXPAND
(
id
__LINE__
)
#
ifdef
MOZ_USE_SYSTRACE
#
ifndef
ATRACE_TAG
#
define
ATRACE_TAG
ATRACE_TAG_ALWAYS
#
endif
#
ifndef
HAVE_ANDROID_OS
#
define
HAVE_ANDROID_OS
#
define
REMOVE_HAVE_ANDROID_OS
#
endif
#
undef
_LIBS_CUTILS_TRACE_H
#
include
<
utils
/
Trace
.
h
>
#
define
MOZ_PLATFORM_TRACING
(
name
)
android
:
:
ScopedTrace
SAMPLER_APPEND_LINE_NUMBER
(
scopedTrace
)
(
ATRACE_TAG
name
)
;
#
ifdef
REMOVE_HAVE_ANDROID_OS
#
undef
HAVE_ANDROID_OS
#
undef
REMOVE_HAVE_ANDROID_OS
#
endif
#
else
#
define
MOZ_PLATFORM_TRACING
(
name
)
#
endif
#
define
PROFILER_LABEL
(
name_space
info
category
)
MOZ_PLATFORM_TRACING
(
name_space
"
:
:
"
info
)
mozilla
:
:
SamplerStackFrameRAII
SAMPLER_APPEND_LINE_NUMBER
(
sampler_raii
)
(
name_space
"
:
:
"
info
category
__LINE__
)
#
define
PROFILER_LABEL_FUNC
(
category
)
MOZ_PLATFORM_TRACING
(
SAMPLE_FUNCTION_NAME
)
mozilla
:
:
SamplerStackFrameRAII
SAMPLER_APPEND_LINE_NUMBER
(
sampler_raii
)
(
SAMPLE_FUNCTION_NAME
category
__LINE__
)
#
define
PROFILER_LABEL_PRINTF
(
name_space
info
category
.
.
.
)
MOZ_PLATFORM_TRACING
(
name_space
"
:
:
"
info
)
mozilla
:
:
SamplerStackFramePrintfRAII
SAMPLER_APPEND_LINE_NUMBER
(
sampler_raii
)
(
name_space
"
:
:
"
info
category
__LINE__
__VA_ARGS__
)
#
define
PROFILER_MARKER
(
info
)
mozilla_sampler_add_marker
(
info
)
#
define
PROFILER_MARKER_PAYLOAD
(
info
payload
)
mozilla_sampler_add_marker
(
info
payload
)
#
ifdef
MOZ_WIDGET_GONK
#
define
PLATFORM_LIKELY_MEMORY_CONSTRAINED
#
endif
#
if
!
defined
(
PLATFORM_LIKELY_MEMORY_CONSTRAINED
)
&
&
!
defined
(
ARCH_ARMV6
)
#
define
PROFILE_DEFAULT_ENTRY
1000000
#
else
#
define
PROFILE_DEFAULT_ENTRY
100000
#
endif
#
define
GET_BACKTRACE_DEFAULT_ENTRY
1000
#
if
defined
(
PLATFORM_LIKELY_MEMORY_CONSTRAINED
)
#
define
PROFILE_DEFAULT_INTERVAL
10
#
elif
defined
(
ANDROID
)
#
define
PROFILE_DEFAULT_INTERVAL
1
#
else
#
define
PROFILE_DEFAULT_INTERVAL
1
#
endif
#
define
PROFILE_DEFAULT_FEATURES
NULL
#
define
PROFILE_DEFAULT_FEATURE_COUNT
0
namespace
mozilla
{
class
MOZ_RAII
SamplerStackFrameRAII
{
public
:
SamplerStackFrameRAII
(
const
char
*
aInfo
js
:
:
ProfileEntry
:
:
Category
aCategory
uint32_t
line
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
mHandle
=
mozilla_sampler_call_enter
(
aInfo
aCategory
this
false
line
)
;
}
~
SamplerStackFrameRAII
(
)
{
mozilla_sampler_call_exit
(
mHandle
)
;
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
void
*
mHandle
;
}
;
static
const
int
SAMPLER_MAX_STRING
=
128
;
class
MOZ_RAII
SamplerStackFramePrintfRAII
{
public
:
SamplerStackFramePrintfRAII
(
const
char
*
aInfo
js
:
:
ProfileEntry
:
:
Category
aCategory
uint32_t
line
const
char
*
aFormat
.
.
.
)
:
mHandle
(
nullptr
)
{
if
(
profiler_is_active
(
)
&
&
!
profiler_in_privacy_mode
(
)
)
{
va_list
args
;
va_start
(
args
aFormat
)
;
char
buff
[
SAMPLER_MAX_STRING
]
;
VsprintfLiteral
(
buff
aFormat
args
)
;
SprintfLiteral
(
mDest
"
%
s
%
s
"
aInfo
buff
)
;
mHandle
=
mozilla_sampler_call_enter
(
mDest
aCategory
this
true
line
)
;
va_end
(
args
)
;
}
else
{
mHandle
=
mozilla_sampler_call_enter
(
aInfo
aCategory
this
false
line
)
;
}
}
~
SamplerStackFramePrintfRAII
(
)
{
mozilla_sampler_call_exit
(
mHandle
)
;
}
private
:
char
mDest
[
SAMPLER_MAX_STRING
]
;
void
*
mHandle
;
}
;
}
inline
PseudoStack
*
mozilla_get_pseudo_stack
(
void
)
{
if
(
!
stack_key_initialized
)
return
nullptr
;
return
tlsPseudoStack
.
get
(
)
;
}
inline
void
*
mozilla_sampler_call_enter
(
const
char
*
aInfo
js
:
:
ProfileEntry
:
:
Category
aCategory
void
*
aFrameAddress
bool
aCopy
uint32_t
line
)
{
if
(
!
stack_key_initialized
)
return
nullptr
;
PseudoStack
*
stack
=
tlsPseudoStack
.
get
(
)
;
if
(
!
stack
)
{
return
stack
;
}
stack
-
>
push
(
aInfo
aCategory
aFrameAddress
aCopy
line
)
;
return
stack
;
}
inline
void
mozilla_sampler_call_exit
(
void
*
aHandle
)
{
if
(
!
aHandle
)
return
;
PseudoStack
*
stack
=
(
PseudoStack
*
)
aHandle
;
stack
-
>
popAndMaybeDelete
(
)
;
}
void
mozilla_sampler_add_marker
(
const
char
*
aMarker
ProfilerMarkerPayload
*
aPayload
)
;
static
inline
void
profiler_log
(
const
char
*
str
)
{
profiler_tracing
(
"
log
"
str
TRACING_EVENT
)
;
}
static
inline
void
profiler_log
(
const
char
*
fmt
va_list
args
)
{
mozilla_sampler_log
(
fmt
args
)
;
}
#
endif
namespace
mozilla
{
class
MOZ_RAII
GeckoProfilerInitRAII
{
public
:
explicit
GeckoProfilerInitRAII
(
void
*
stackTop
)
{
profiler_init
(
stackTop
)
;
}
~
GeckoProfilerInitRAII
(
)
{
profiler_shutdown
(
)
;
}
}
;
class
MOZ_RAII
GeckoProfilerSleepRAII
{
public
:
GeckoProfilerSleepRAII
(
)
{
profiler_sleep_start
(
)
;
}
~
GeckoProfilerSleepRAII
(
)
{
profiler_sleep_end
(
)
;
}
}
;
class
MOZ_RAII
GeckoProfilerWakeRAII
{
public
:
GeckoProfilerWakeRAII
(
)
:
mIssuedWake
(
profiler_is_sleeping
(
)
)
{
if
(
mIssuedWake
)
{
profiler_sleep_end
(
)
;
}
}
~
GeckoProfilerWakeRAII
(
)
{
if
(
mIssuedWake
)
{
MOZ_ASSERT
(
!
profiler_is_sleeping
(
)
)
;
profiler_sleep_start
(
)
;
}
}
private
:
bool
mIssuedWake
;
}
;
class
MOZ_RAII
GeckoProfilerTracingRAII
{
public
:
GeckoProfilerTracingRAII
(
const
char
*
aCategory
const
char
*
aInfo
UniqueProfilerBacktrace
aBacktrace
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mCategory
(
aCategory
)
mInfo
(
aInfo
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_tracing
(
mCategory
mInfo
Move
(
aBacktrace
)
TRACING_INTERVAL_START
)
;
}
GeckoProfilerTracingRAII
(
const
char
*
aCategory
const
char
*
aInfo
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mCategory
(
aCategory
)
mInfo
(
aInfo
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_tracing
(
mCategory
mInfo
TRACING_INTERVAL_START
)
;
}
~
GeckoProfilerTracingRAII
(
)
{
profiler_tracing
(
mCategory
mInfo
TRACING_INTERVAL_END
)
;
}
protected
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
const
char
*
mCategory
;
const
char
*
mInfo
;
}
;
class
MOZ_STACK_CLASS
AutoProfilerRegister
final
{
public
:
explicit
AutoProfilerRegister
(
const
char
*
aName
)
{
profiler_register_thread
(
aName
this
)
;
}
~
AutoProfilerRegister
(
)
{
profiler_unregister_thread
(
)
;
}
private
:
AutoProfilerRegister
(
const
AutoProfilerRegister
&
)
=
delete
;
AutoProfilerRegister
&
operator
=
(
const
AutoProfilerRegister
&
)
=
delete
;
}
;
}
#
endif
