#
ifndef
GeckoProfiler_h
#
define
GeckoProfiler_h
#
include
<
functional
>
#
include
<
signal
.
h
>
#
include
<
stdarg
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
ProfilingStack
.
h
"
#
include
"
nscore
.
h
"
#
ifdef
min
#
undef
min
#
endif
class
ProfilerBacktrace
;
class
ProfilerMarkerPayload
;
class
SpliceableJSONWriter
;
namespace
mozilla
{
class
MallocAllocPolicy
;
template
<
class
T
size_t
MinInlineCapacity
class
AllocPolicy
>
class
Vector
;
class
TimeStamp
;
}
#
ifdef
MOZ_GECKO_PROFILER
#
define
PROFILER_FUNC
(
decl
rv
)
decl
;
#
define
PROFILER_FUNC_VOID
(
decl
)
void
decl
;
#
else
#
define
PROFILER_FUNC
(
decl
rv
)
static
inline
decl
{
return
rv
;
}
#
define
PROFILER_FUNC_VOID
(
decl
)
static
inline
void
decl
{
}
#
endif
#
define
PROFILER_RAII_PASTE
(
id
line
)
id
#
#
line
#
define
PROFILER_RAII_EXPAND
(
id
line
)
PROFILER_RAII_PASTE
(
id
line
)
#
define
PROFILER_RAII
PROFILER_RAII_EXPAND
(
raiiObject
__LINE__
)
#
define
PROFILER_FOR_EACH_FEATURE
(
macro
)
\
macro
(
0
"
displaylistdump
"
DisplayListDump
)
\
\
/
*
GPU
Profiling
(
may
not
be
supported
by
the
GL
)
.
*
/
\
macro
(
1
"
gpu
"
GPU
)
\
\
/
*
Profile
Java
code
(
Android
only
)
.
*
/
\
macro
(
2
"
java
"
Java
)
\
\
/
*
Get
the
JS
engine
to
emit
pseudostack
entries
in
prologues
/
epilogues
*
/
\
macro
(
3
"
js
"
JS
)
\
\
/
*
Dump
the
layer
tree
with
the
textures
.
*
/
\
macro
(
4
"
layersdump
"
LayersDump
)
\
\
/
*
Include
the
C
+
+
leaf
node
if
not
stackwalking
.
*
/
\
/
*
The
DevTools
profiler
doesn
'
t
want
the
native
addresses
.
*
/
\
macro
(
5
"
leaf
"
Leaf
)
\
\
/
*
Add
main
thread
I
/
O
to
the
profile
.
*
/
\
macro
(
6
"
mainthreadio
"
MainThreadIO
)
\
\
/
*
Add
memory
measurements
(
e
.
g
.
RSS
)
.
*
/
\
macro
(
7
"
memory
"
Memory
)
\
\
/
*
Do
not
include
user
-
identifiable
information
.
*
/
\
macro
(
8
"
privacy
"
Privacy
)
\
\
/
*
Restyle
profiling
.
*
/
\
macro
(
9
"
restyle
"
Restyle
)
\
\
/
*
Walk
the
C
+
+
stack
.
Not
available
on
all
platforms
.
*
/
\
macro
(
10
"
stackwalk
"
StackWalk
)
\
\
/
*
Start
profiling
with
feature
TaskTracer
.
*
/
\
macro
(
11
"
tasktracer
"
TaskTracer
)
\
\
/
*
Profile
the
registered
secondary
threads
.
*
/
\
macro
(
12
"
threads
"
Threads
)
struct
ProfilerFeature
{
#
define
DECLARE
(
n_
str_
Name_
)
\
static
const
uint32_t
Name_
=
(
1u
<
<
n_
)
;
\
static
bool
Has
#
#
Name_
(
uint32_t
aFeatures
)
{
return
aFeatures
&
Name_
;
}
\
static
void
Set
#
#
Name_
(
uint32_t
&
aFeatures
)
{
aFeatures
|
=
Name_
;
}
\
static
void
Clear
#
#
Name_
(
uint32_t
&
aFeatures
)
{
aFeatures
&
=
~
Name_
;
}
PROFILER_FOR_EACH_FEATURE
(
DECLARE
)
#
undef
DECLARE
}
;
#
if
!
defined
(
ARCH_ARMV6
)
#
define
PROFILER_DEFAULT_ENTRIES
1000000
#
else
#
define
PROFILER_DEFAULT_ENTRIES
100000
#
endif
#
define
PROFILER_DEFAULT_INTERVAL
1
PROFILER_FUNC_VOID
(
profiler_init
(
void
*
stackTop
)
)
PROFILER_FUNC_VOID
(
profiler_shutdown
(
)
)
PROFILER_FUNC_VOID
(
profiler_start
(
int
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
)
PROFILER_FUNC_VOID
(
profiler_stop
(
)
)
PROFILER_FUNC_VOID
(
profiler_ensure_started
(
int
aEntries
double
aInterval
uint32_t
aFeatures
const
char
*
*
aFilters
uint32_t
aFilterCount
)
)
PROFILER_FUNC_VOID
(
profiler_register_thread
(
const
char
*
name
void
*
guessStackTop
)
)
PROFILER_FUNC_VOID
(
profiler_unregister_thread
(
)
)
PROFILER_FUNC_VOID
(
profiler_pause
(
)
)
PROFILER_FUNC_VOID
(
profiler_resume
(
)
)
PROFILER_FUNC_VOID
(
profiler_thread_sleep
(
)
)
PROFILER_FUNC_VOID
(
profiler_thread_wake
(
)
)
PROFILER_FUNC_VOID
(
profiler_js_interrupt_callback
(
)
)
PROFILER_FUNC_VOID
(
profiler_set_js_context
(
JSContext
*
aCx
)
)
PROFILER_FUNC_VOID
(
profiler_clear_js_context
(
)
)
PROFILER_FUNC
(
bool
profiler_is_active
(
)
false
)
PROFILER_FUNC
(
bool
profiler_is_paused
(
)
false
)
PROFILER_FUNC
(
bool
profiler_thread_is_sleeping
(
)
false
)
PROFILER_FUNC
(
uint32_t
profiler_get_available_features
(
)
0
)
PROFILER_FUNC
(
bool
profiler_feature_active
(
uint32_t
aFeature
)
false
)
PROFILER_FUNC_VOID
(
profiler_get_start_params
(
int
*
aEntrySize
double
*
aInterval
uint32_t
*
aFeatures
mozilla
:
:
Vector
<
const
char
*
0
mozilla
:
:
MallocAllocPolicy
>
*
aFilters
)
)
PROFILER_FUNC
(
double
profiler_time
(
)
0
)
PROFILER_FUNC
(
int
profiler_current_thread_id
(
)
0
)
class
ProfilerStackCollector
{
public
:
virtual
mozilla
:
:
Maybe
<
uint32_t
>
Generation
(
)
{
return
mozilla
:
:
Nothing
(
)
;
}
virtual
void
SetIsMainThread
(
)
{
}
virtual
void
CollectNativeLeafAddr
(
void
*
aAddr
)
=
0
;
virtual
void
CollectJitReturnAddr
(
void
*
aAddr
)
=
0
;
virtual
void
CollectWasmFrame
(
const
char
*
aLabel
)
=
0
;
virtual
void
CollectPseudoEntry
(
const
js
:
:
ProfileEntry
&
aEntry
)
=
0
;
}
;
PROFILER_FUNC_VOID
(
profiler_suspend_and_sample_thread
(
int
aThreadId
uint32_t
aFeatures
ProfilerStackCollector
&
aCollector
bool
aSampleNative
=
true
)
)
struct
ProfilerBacktraceDestructor
{
#
ifdef
MOZ_GECKO_PROFILER
void
operator
(
)
(
ProfilerBacktrace
*
)
;
#
else
void
operator
(
)
(
ProfilerBacktrace
*
)
{
}
#
endif
}
;
using
UniqueProfilerBacktrace
=
mozilla
:
:
UniquePtr
<
ProfilerBacktrace
ProfilerBacktraceDestructor
>
;
PROFILER_FUNC
(
UniqueProfilerBacktrace
profiler_get_backtrace
(
)
nullptr
)
PROFILER_FUNC_VOID
(
profiler_get_buffer_info_helper
(
uint32_t
*
aCurrentPosition
uint32_t
*
aEntries
uint32_t
*
aGeneration
)
)
static
inline
void
profiler_get_buffer_info
(
uint32_t
*
aCurrentPosition
uint32_t
*
aEntries
uint32_t
*
aGeneration
)
{
*
aCurrentPosition
=
0
;
*
aEntries
=
0
;
*
aGeneration
=
0
;
profiler_get_buffer_info_helper
(
aCurrentPosition
aEntries
aGeneration
)
;
}
PROFILER_FUNC
(
PseudoStack
*
profiler_get_pseudo_stack
(
)
nullptr
)
#
define
AUTO_PROFILER_LABEL
(
label
category
)
\
mozilla
:
:
AutoProfilerLabel
PROFILER_RAII
(
label
nullptr
__LINE__
\
js
:
:
ProfileEntry
:
:
Category
:
:
category
)
#
define
AUTO_PROFILER_LABEL_DYNAMIC
(
label
category
dynamicStr
)
\
mozilla
:
:
AutoProfilerLabel
PROFILER_RAII
(
label
dynamicStr
__LINE__
\
js
:
:
ProfileEntry
:
:
Category
:
:
category
)
PROFILER_FUNC_VOID
(
profiler_add_marker
(
const
char
*
aMarkerName
)
)
PROFILER_FUNC_VOID
(
profiler_add_marker
(
const
char
*
aMarkerName
mozilla
:
:
UniquePtr
<
ProfilerMarkerPayload
>
aPayload
)
)
enum
TracingKind
{
TRACING_EVENT
TRACING_INTERVAL_START
TRACING_INTERVAL_END
}
;
PROFILER_FUNC_VOID
(
profiler_tracing
(
const
char
*
aCategory
const
char
*
aMarkerName
TracingKind
aKind
)
)
PROFILER_FUNC_VOID
(
profiler_tracing
(
const
char
*
aCategory
const
char
*
aMarkerName
TracingKind
aKind
UniqueProfilerBacktrace
aCause
)
)
PROFILER_FUNC
(
mozilla
:
:
UniquePtr
<
char
[
]
>
profiler_get_profile
(
double
aSinceTime
=
0
bool
aIsShuttingDown
=
false
)
nullptr
)
PROFILER_FUNC
(
bool
profiler_stream_json_for_this_process
(
SpliceableJSONWriter
&
aWriter
double
aSinceTime
=
0
bool
aIsShuttingDown
=
false
mozilla
:
:
TimeStamp
*
aOutFirstSampleTime
=
nullptr
)
false
)
extern
"
C
"
{
PROFILER_FUNC_VOID
(
profiler_save_profile_to_file
(
const
char
*
aFilename
)
)
}
namespace
mozilla
{
class
MOZ_RAII
AutoProfilerInit
{
public
:
explicit
AutoProfilerInit
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_init
(
this
)
;
}
~
AutoProfilerInit
(
)
{
profiler_shutdown
(
)
;
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoProfilerRegisterThread
final
{
public
:
explicit
AutoProfilerRegisterThread
(
const
char
*
aName
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_register_thread
(
aName
this
)
;
}
~
AutoProfilerRegisterThread
(
)
{
profiler_unregister_thread
(
)
;
}
private
:
AutoProfilerRegisterThread
(
const
AutoProfilerRegisterThread
&
)
=
delete
;
AutoProfilerRegisterThread
&
operator
=
(
const
AutoProfilerRegisterThread
&
)
=
delete
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoProfilerThreadSleep
{
public
:
explicit
AutoProfilerThreadSleep
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_thread_sleep
(
)
;
}
~
AutoProfilerThreadSleep
(
)
{
profiler_thread_wake
(
)
;
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoProfilerThreadWake
{
public
:
explicit
AutoProfilerThreadWake
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
:
mIssuedWake
(
profiler_thread_is_sleeping
(
)
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
mIssuedWake
)
{
profiler_thread_wake
(
)
;
}
}
~
AutoProfilerThreadWake
(
)
{
if
(
mIssuedWake
)
{
MOZ_ASSERT
(
!
profiler_thread_is_sleeping
(
)
)
;
profiler_thread_sleep
(
)
;
}
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
bool
mIssuedWake
;
}
;
class
MOZ_RAII
AutoProfilerLabel
{
public
:
AutoProfilerLabel
(
const
char
*
aLabel
const
char
*
aDynamicString
uint32_t
aLine
js
:
:
ProfileEntry
:
:
Category
aCategory
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
#
ifdef
MOZ_GECKO_PROFILER
mPseudoStack
=
sPseudoStack
.
get
(
)
;
if
(
mPseudoStack
)
{
mPseudoStack
-
>
pushCppFrame
(
aLabel
aDynamicString
this
aLine
js
:
:
ProfileEntry
:
:
Kind
:
:
CPP_NORMAL
aCategory
)
;
}
#
endif
}
~
AutoProfilerLabel
(
)
{
#
ifdef
MOZ_GECKO_PROFILER
if
(
mPseudoStack
)
{
mPseudoStack
-
>
pop
(
)
;
}
#
endif
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
#
ifdef
MOZ_GECKO_PROFILER
PseudoStack
*
mPseudoStack
;
public
:
static
MOZ_THREAD_LOCAL
(
PseudoStack
*
)
sPseudoStack
;
#
endif
}
;
class
MOZ_RAII
AutoProfilerTracing
{
public
:
AutoProfilerTracing
(
const
char
*
aCategory
const
char
*
aMarkerName
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mCategory
(
aCategory
)
mMarkerName
(
aMarkerName
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_tracing
(
mCategory
mMarkerName
TRACING_INTERVAL_START
)
;
}
AutoProfilerTracing
(
const
char
*
aCategory
const
char
*
aMarkerName
UniqueProfilerBacktrace
aBacktrace
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mCategory
(
aCategory
)
mMarkerName
(
aMarkerName
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
profiler_tracing
(
mCategory
mMarkerName
TRACING_INTERVAL_START
Move
(
aBacktrace
)
)
;
}
~
AutoProfilerTracing
(
)
{
profiler_tracing
(
mCategory
mMarkerName
TRACING_INTERVAL_END
)
;
}
protected
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
const
char
*
mCategory
;
const
char
*
mMarkerName
;
}
;
#
ifdef
MOZ_GECKO_PROFILER
class
MOZ_RAII
AutoSetProfilerEnvVarsForChildProcess
{
public
:
explicit
AutoSetProfilerEnvVarsForChildProcess
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM
)
;
~
AutoSetProfilerEnvVarsForChildProcess
(
)
;
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
char
mSetEntries
[
64
]
;
char
mSetInterval
[
64
]
;
char
mSetFeaturesBitfield
[
64
]
;
char
mSetFilters
[
1024
]
;
}
;
#
else
class
AutoSetProfilerEnvVarsForChildProcess
{
}
;
#
endif
}
#
endif
