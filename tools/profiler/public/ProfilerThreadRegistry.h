#
ifndef
ProfilerThreadRegistry_h
#
define
ProfilerThreadRegistry_h
#
include
"
mozilla
/
BaseProfilerDetail
.
h
"
#
include
"
mozilla
/
ProfilerThreadRegistration
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
namespace
mozilla
:
:
profiler
{
class
ThreadRegistry
{
private
:
using
RegistryMutex
=
baseprofiler
:
:
detail
:
:
BaseProfilerSharedMutex
;
using
RegistryLockExclusive
=
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLockExclusive
;
using
RegistryLockShared
=
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLockShared
;
public
:
using
UnlockedConstReader
=
ThreadRegistrationUnlockedConstReader
;
using
UnlockedConstReaderAndAtomicRW
=
ThreadRegistrationUnlockedConstReaderAndAtomicRW
;
using
UnlockedRWForLockedProfiler
=
ThreadRegistrationUnlockedRWForLockedProfiler
;
using
UnlockedReaderAndAtomicRWOnThread
=
ThreadRegistrationUnlockedReaderAndAtomicRWOnThread
;
using
LockedRWFromAnyThread
=
ThreadRegistrationLockedRWFromAnyThread
;
using
LockedRWOnThread
=
ThreadRegistrationLockedRWOnThread
;
class
OffThreadRef
{
public
:
[
[
nodiscard
]
]
const
UnlockedConstReader
&
UnlockedConstReaderCRef
(
)
const
{
return
mThreadRegistration
-
>
mData
;
}
template
<
typename
F
>
auto
WithUnlockedConstReader
(
F
&
&
aF
)
const
{
return
std
:
:
forward
<
F
>
(
aF
)
(
UnlockedConstReaderCRef
(
)
)
;
}
[
[
nodiscard
]
]
const
UnlockedConstReaderAndAtomicRW
&
UnlockedConstReaderAndAtomicRWCRef
(
)
const
{
return
mThreadRegistration
-
>
mData
;
}
template
<
typename
F
>
auto
WithUnlockedConstReaderAndAtomicRW
(
F
&
&
aF
)
const
{
return
std
:
:
forward
<
F
>
(
aF
)
(
UnlockedConstReaderAndAtomicRWCRef
(
)
)
;
}
[
[
nodiscard
]
]
UnlockedConstReaderAndAtomicRW
&
UnlockedConstReaderAndAtomicRWRef
(
)
{
return
mThreadRegistration
-
>
mData
;
}
template
<
typename
F
>
auto
WithUnlockedConstReaderAndAtomicRW
(
F
&
&
aF
)
{
return
std
:
:
forward
<
F
>
(
aF
)
(
UnlockedConstReaderAndAtomicRWRef
(
)
)
;
}
[
[
nodiscard
]
]
const
UnlockedRWForLockedProfiler
&
UnlockedRWForLockedProfilerCRef
(
)
const
{
return
mThreadRegistration
-
>
mData
;
}
template
<
typename
F
>
auto
WithUnlockedRWForLockedProfiler
(
F
&
&
aF
)
const
{
return
std
:
:
forward
<
F
>
(
aF
)
(
UnlockedRWForLockedProfilerCRef
(
)
)
;
}
[
[
nodiscard
]
]
UnlockedRWForLockedProfiler
&
UnlockedRWForLockedProfilerRef
(
)
{
return
mThreadRegistration
-
>
mData
;
}
template
<
typename
F
>
auto
WithUnlockedRWForLockedProfiler
(
F
&
&
aF
)
{
return
std
:
:
forward
<
F
>
(
aF
)
(
UnlockedRWForLockedProfilerRef
(
)
)
;
}
class
ConstRWFromAnyThreadWithLock
{
public
:
[
[
nodiscard
]
]
const
LockedRWFromAnyThread
&
DataCRef
(
)
const
{
return
mLockedRWFromAnyThread
;
}
[
[
nodiscard
]
]
const
LockedRWFromAnyThread
*
operator
-
>
(
)
const
{
return
&
mLockedRWFromAnyThread
;
}
ConstRWFromAnyThreadWithLock
(
const
LockedRWFromAnyThread
&
aLockedRWFromAnyThread
ThreadRegistration
:
:
DataMutex
&
aDataMutex
)
:
mLockedRWFromAnyThread
(
aLockedRWFromAnyThread
)
mDataLock
(
aDataMutex
)
{
}
private
:
const
LockedRWFromAnyThread
&
mLockedRWFromAnyThread
;
ThreadRegistration
:
:
DataLock
mDataLock
;
}
;
[
[
nodiscard
]
]
ConstRWFromAnyThreadWithLock
ConstLockedRWFromAnyThread
(
)
const
{
return
ConstRWFromAnyThreadWithLock
{
mThreadRegistration
-
>
mData
mThreadRegistration
-
>
mDataMutex
}
;
}
template
<
typename
F
>
auto
WithConstLockedRWFromAnyThread
(
F
&
&
aF
)
const
{
ConstRWFromAnyThreadWithLock
lockedData
=
ConstLockedRWFromAnyThread
(
)
;
return
std
:
:
forward
<
F
>
(
aF
)
(
lockedData
.
DataCRef
(
)
)
;
}
class
RWFromAnyThreadWithLock
{
public
:
[
[
nodiscard
]
]
const
LockedRWFromAnyThread
&
DataCRef
(
)
const
{
return
mLockedRWFromAnyThread
;
}
[
[
nodiscard
]
]
LockedRWFromAnyThread
&
DataRef
(
)
{
return
mLockedRWFromAnyThread
;
}
[
[
nodiscard
]
]
const
LockedRWFromAnyThread
*
operator
-
>
(
)
const
{
return
&
mLockedRWFromAnyThread
;
}
[
[
nodiscard
]
]
LockedRWFromAnyThread
*
operator
-
>
(
)
{
return
&
mLockedRWFromAnyThread
;
}
[
[
nodiscard
]
]
LockedRWOnThread
*
GetLockedRWOnThread
(
)
{
if
(
mLockedRWFromAnyThread
.
Info
(
)
.
ThreadId
(
)
=
=
profiler_current_thread_id
(
)
)
{
return
&
static_cast
<
LockedRWOnThread
&
>
(
mLockedRWFromAnyThread
)
;
}
return
nullptr
;
}
private
:
friend
class
OffThreadRef
;
RWFromAnyThreadWithLock
(
LockedRWFromAnyThread
&
aLockedRWFromAnyThread
ThreadRegistration
:
:
DataMutex
&
aDataMutex
)
:
mLockedRWFromAnyThread
(
aLockedRWFromAnyThread
)
mDataLock
(
aDataMutex
)
{
}
LockedRWFromAnyThread
&
mLockedRWFromAnyThread
;
ThreadRegistration
:
:
DataLock
mDataLock
;
}
;
[
[
nodiscard
]
]
RWFromAnyThreadWithLock
LockedRWFromAnyThread
(
)
{
return
RWFromAnyThreadWithLock
{
mThreadRegistration
-
>
mData
mThreadRegistration
-
>
mDataMutex
}
;
}
template
<
typename
F
>
auto
WithLockedRWFromAnyThread
(
F
&
&
aF
)
{
RWFromAnyThreadWithLock
lockedData
=
LockedRWFromAnyThread
(
)
;
return
std
:
:
forward
<
F
>
(
aF
)
(
lockedData
.
DataRef
(
)
)
;
}
private
:
friend
class
ThreadRegistry
;
explicit
OffThreadRef
(
ThreadRegistration
&
aThreadRegistration
)
:
mThreadRegistration
(
&
aThreadRegistration
)
{
}
explicit
OffThreadRef
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
:
mThreadRegistration
(
aOnThreadRef
.
mThreadRegistration
)
{
}
[
[
nodiscard
]
]
bool
IsPointingAt
(
ThreadRegistration
&
aThreadRegistration
)
const
{
return
mThreadRegistration
=
=
&
aThreadRegistration
;
}
ThreadRegistration
*
mThreadRegistration
;
}
;
class
LockedRegistry
{
public
:
LockedRegistry
(
)
:
mRegistryLock
(
[
]
(
)
-
>
RegistryMutex
&
{
MOZ_ASSERT
(
!
IsRegistryMutexLockedOnCurrentThread
(
)
"
Recursive
locking
detected
"
)
;
MOZ_ASSERT
(
!
ThreadRegistration
:
:
IsDataMutexLockedOnCurrentThread
(
)
)
;
return
sRegistryMutex
;
}
(
)
)
{
ThreadRegistration
:
:
WithOnThreadRef
(
[
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
aOnThreadRef
.
mThreadRegistration
-
>
mIsRegistryLockedSharedOnThisThread
=
true
;
}
)
;
}
~
LockedRegistry
(
)
{
ThreadRegistration
:
:
WithOnThreadRef
(
[
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
aOnThreadRef
.
mThreadRegistration
-
>
mIsRegistryLockedSharedOnThisThread
=
false
;
}
)
;
}
[
[
nodiscard
]
]
const
OffThreadRef
*
begin
(
)
const
{
return
sRegistryContainer
.
begin
(
)
;
}
[
[
nodiscard
]
]
OffThreadRef
*
begin
(
)
{
return
sRegistryContainer
.
begin
(
)
;
}
[
[
nodiscard
]
]
const
OffThreadRef
*
end
(
)
const
{
return
sRegistryContainer
.
end
(
)
;
}
[
[
nodiscard
]
]
OffThreadRef
*
end
(
)
{
return
sRegistryContainer
.
end
(
)
;
}
private
:
RegistryLockShared
mRegistryLock
;
}
;
template
<
typename
F
>
static
void
WithOffThreadRef
(
ProfilerThreadId
aThreadId
F
&
&
aF
)
{
for
(
OffThreadRef
thread
:
LockedRegistry
{
}
)
{
if
(
thread
.
UnlockedConstReaderCRef
(
)
.
Info
(
)
.
ThreadId
(
)
=
=
aThreadId
)
{
std
:
:
forward
<
F
>
(
aF
)
(
thread
)
;
break
;
}
}
}
template
<
typename
F
typename
FallbackReturn
>
[
[
nodiscard
]
]
static
auto
WithOffThreadRefOr
(
ProfilerThreadId
aThreadId
F
&
&
aF
FallbackReturn
&
&
aFallbackReturn
)
-
>
decltype
(
std
:
:
forward
<
F
>
(
aF
)
(
std
:
:
declval
<
OffThreadRef
>
(
)
)
)
{
for
(
OffThreadRef
thread
:
LockedRegistry
{
}
)
{
if
(
thread
.
UnlockedConstReaderCRef
(
)
.
Info
(
)
.
ThreadId
(
)
=
=
aThreadId
)
{
return
std
:
:
forward
<
F
>
(
aF
)
(
thread
)
;
}
}
return
std
:
:
forward
<
FallbackReturn
>
(
aFallbackReturn
)
;
}
static
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
{
LockedRegistry
lockedRegistry
;
size_t
bytes
=
sRegistryContainer
.
sizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
OffThreadRef
&
offThreadRef
:
lockedRegistry
)
{
bytes
+
=
offThreadRef
.
mThreadRegistration
-
>
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
return
bytes
;
}
static
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
{
return
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
[
[
nodiscard
]
]
static
bool
IsRegistryMutexLockedOnCurrentThread
(
)
{
return
sRegistryMutex
.
IsLockedExclusiveOnCurrentThread
(
)
|
|
ThreadRegistration
:
:
WithOnThreadRefOr
(
[
]
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
{
return
aOnThreadRef
.
mThreadRegistration
-
>
mIsRegistryLockedSharedOnThisThread
;
}
false
)
;
}
private
:
using
RegistryContainer
=
Vector
<
OffThreadRef
>
;
static
RegistryContainer
sRegistryContainer
;
static
RegistryMutex
sRegistryMutex
;
friend
class
ThreadRegistration
;
static
void
Register
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
;
static
void
Unregister
(
ThreadRegistration
:
:
OnThreadRef
aOnThreadRef
)
;
}
;
}
#
endif
