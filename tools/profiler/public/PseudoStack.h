#
ifndef
PseudoStack_h
#
define
PseudoStack_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
js
/
ProfilingStack
.
h
"
#
include
"
StoreSequencer
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
class
PseudoStack
{
public
:
PseudoStack
(
)
:
mStackPointer
(
0
)
{
MOZ_COUNT_CTOR
(
PseudoStack
)
;
}
~
PseudoStack
(
)
{
MOZ_COUNT_DTOR
(
PseudoStack
)
;
MOZ_RELEASE_ASSERT
(
mStackPointer
=
=
0
)
;
}
void
push
(
const
char
*
aName
js
:
:
ProfileEntry
:
:
Category
aCategory
void
*
aStackAddress
bool
aCopy
uint32_t
line
const
char
*
aDynamicString
)
{
if
(
size_t
(
mStackPointer
)
>
=
mozilla
:
:
ArrayLength
(
mStack
)
)
{
mStackPointer
+
+
;
return
;
}
volatile
js
:
:
ProfileEntry
&
entry
=
mStack
[
int
(
mStackPointer
)
]
;
entry
.
initCppFrame
(
aStackAddress
line
)
;
entry
.
setLabel
(
aName
)
;
entry
.
setDynamicString
(
aDynamicString
)
;
MOZ_ASSERT
(
entry
.
flags
(
)
=
=
js
:
:
ProfileEntry
:
:
IS_CPP_ENTRY
)
;
entry
.
setCategory
(
aCategory
)
;
if
(
aCopy
)
{
entry
.
setFlag
(
js
:
:
ProfileEntry
:
:
FRAME_LABEL_COPY
)
;
}
else
{
entry
.
unsetFlag
(
js
:
:
ProfileEntry
:
:
FRAME_LABEL_COPY
)
;
}
STORE_SEQUENCER
(
)
;
mStackPointer
+
+
;
}
void
pop
(
)
{
mStackPointer
-
-
;
}
uint32_t
stackSize
(
)
const
{
return
std
:
:
min
(
uint32_t
(
mStackPointer
)
uint32_t
(
mozilla
:
:
ArrayLength
(
mStack
)
)
)
;
}
mozilla
:
:
Atomic
<
uint32_t
>
*
AddressOfStackPointer
(
)
{
return
&
mStackPointer
;
}
private
:
PseudoStack
(
const
PseudoStack
&
)
=
delete
;
void
operator
=
(
const
PseudoStack
&
)
=
delete
;
public
:
js
:
:
ProfileEntry
volatile
mStack
[
1024
]
;
protected
:
mozilla
:
:
Atomic
<
uint32_t
>
mStackPointer
;
}
;
#
endif
