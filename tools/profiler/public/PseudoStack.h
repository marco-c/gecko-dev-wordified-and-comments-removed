#
ifndef
PseudoStack_h
#
define
PseudoStack_h
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
js
/
ProfilingStack
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
if
defined
(
__arm__
)
typedef
void
(
*
LinuxKernelMemoryBarrierFunc
)
(
void
)
;
LinuxKernelMemoryBarrierFunc
pLinuxKernelMemoryBarrier
__attribute__
(
(
weak
)
)
=
(
LinuxKernelMemoryBarrierFunc
)
0xffff0fa0
;
#
define
STORE_SEQUENCER
(
)
pLinuxKernelMemoryBarrier
(
)
#
elif
defined
(
__i386__
)
|
|
defined
(
__x86_64__
)
|
|
\
defined
(
_M_IX86
)
|
|
defined
(
_M_X64
)
#
if
defined
(
_MSC_VER
)
#
include
<
intrin
.
h
>
#
define
STORE_SEQUENCER
(
)
_ReadWriteBarrier
(
)
;
#
elif
defined
(
__INTEL_COMPILER
)
#
define
STORE_SEQUENCER
(
)
__memory_barrier
(
)
;
#
elif
__GNUC__
#
define
STORE_SEQUENCER
(
)
asm
volatile
(
"
"
:
:
:
"
memory
"
)
;
#
else
#
error
"
Memory
clobber
not
supported
for
your
compiler
.
"
#
endif
#
else
#
error
"
Memory
clobber
not
supported
for
your
platform
.
"
#
endif
class
ProfilerMarkerPayload
;
template
<
typename
T
>
class
ProfilerLinkedList
;
class
SpliceableJSONWriter
;
class
UniqueStacks
;
class
ProfilerMarker
{
friend
class
ProfilerLinkedList
<
ProfilerMarker
>
;
public
:
explicit
ProfilerMarker
(
const
char
*
aMarkerName
ProfilerMarkerPayload
*
aPayload
=
nullptr
double
aTime
=
0
)
;
~
ProfilerMarker
(
)
;
const
char
*
GetMarkerName
(
)
const
{
return
mMarkerName
;
}
void
StreamJSON
(
SpliceableJSONWriter
&
aWriter
const
mozilla
:
:
TimeStamp
&
aStartTime
UniqueStacks
&
aUniqueStacks
)
const
;
void
SetGeneration
(
uint32_t
aGenID
)
;
bool
HasExpired
(
uint32_t
aGenID
)
const
{
return
mGenID
+
2
<
=
aGenID
;
}
double
GetTime
(
)
const
;
private
:
char
*
mMarkerName
;
ProfilerMarkerPayload
*
mPayload
;
ProfilerMarker
*
mNext
;
double
mTime
;
uint32_t
mGenID
;
}
;
template
<
typename
T
>
class
ProfilerLinkedList
{
public
:
ProfilerLinkedList
(
)
:
mHead
(
nullptr
)
mTail
(
nullptr
)
{
}
void
insert
(
T
*
aElem
)
{
if
(
!
mTail
)
{
mHead
=
aElem
;
mTail
=
aElem
;
}
else
{
mTail
-
>
mNext
=
aElem
;
mTail
=
aElem
;
}
aElem
-
>
mNext
=
nullptr
;
}
T
*
popHead
(
)
{
if
(
!
mHead
)
{
MOZ_ASSERT
(
false
)
;
return
nullptr
;
}
T
*
head
=
mHead
;
mHead
=
head
-
>
mNext
;
if
(
!
mHead
)
{
mTail
=
nullptr
;
}
return
head
;
}
const
T
*
peek
(
)
{
return
mHead
;
}
private
:
T
*
mHead
;
T
*
mTail
;
}
;
typedef
ProfilerLinkedList
<
ProfilerMarker
>
ProfilerMarkerLinkedList
;
template
<
typename
T
>
class
ProfilerSignalSafeLinkedList
{
public
:
ProfilerSignalSafeLinkedList
(
)
:
mSignalLock
(
false
)
{
}
~
ProfilerSignalSafeLinkedList
(
)
{
if
(
mSignalLock
)
{
abort
(
)
;
}
while
(
mList
.
peek
(
)
)
{
delete
mList
.
popHead
(
)
;
}
}
void
insert
(
T
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
mSignalLock
=
true
;
STORE_SEQUENCER
(
)
;
mList
.
insert
(
aElement
)
;
STORE_SEQUENCER
(
)
;
mSignalLock
=
false
;
}
ProfilerLinkedList
<
T
>
*
accessList
(
)
{
return
mSignalLock
?
nullptr
:
&
mList
;
}
private
:
ProfilerLinkedList
<
T
>
mList
;
volatile
bool
mSignalLock
;
}
;
class
PseudoStack
{
public
:
PseudoStack
(
)
:
mStackPointer
(
0
)
{
MOZ_COUNT_CTOR
(
PseudoStack
)
;
}
~
PseudoStack
(
)
{
MOZ_COUNT_DTOR
(
PseudoStack
)
;
MOZ_RELEASE_ASSERT
(
mStackPointer
=
=
0
)
;
}
void
push
(
const
char
*
aName
js
:
:
ProfileEntry
:
:
Category
aCategory
void
*
aStackAddress
bool
aCopy
uint32_t
line
const
char
*
aDynamicString
)
{
if
(
size_t
(
mStackPointer
)
>
=
mozilla
:
:
ArrayLength
(
mStack
)
)
{
mStackPointer
+
+
;
return
;
}
volatile
js
:
:
ProfileEntry
&
entry
=
mStack
[
int
(
mStackPointer
)
]
;
entry
.
initCppFrame
(
aStackAddress
line
)
;
entry
.
setLabel
(
aName
)
;
entry
.
setDynamicString
(
aDynamicString
)
;
MOZ_ASSERT
(
entry
.
flags
(
)
=
=
js
:
:
ProfileEntry
:
:
IS_CPP_ENTRY
)
;
entry
.
setCategory
(
aCategory
)
;
if
(
aCopy
)
{
entry
.
setFlag
(
js
:
:
ProfileEntry
:
:
FRAME_LABEL_COPY
)
;
}
else
{
entry
.
unsetFlag
(
js
:
:
ProfileEntry
:
:
FRAME_LABEL_COPY
)
;
}
STORE_SEQUENCER
(
)
;
mStackPointer
+
+
;
}
void
pop
(
)
{
mStackPointer
-
-
;
}
uint32_t
stackSize
(
)
const
{
return
std
:
:
min
(
uint32_t
(
mStackPointer
)
uint32_t
(
mozilla
:
:
ArrayLength
(
mStack
)
)
)
;
}
mozilla
:
:
Atomic
<
uint32_t
>
*
AddressOfStackPointer
(
)
{
return
&
mStackPointer
;
}
private
:
PseudoStack
(
const
PseudoStack
&
)
=
delete
;
void
operator
=
(
const
PseudoStack
&
)
=
delete
;
public
:
js
:
:
ProfileEntry
volatile
mStack
[
1024
]
;
protected
:
mozilla
:
:
Atomic
<
uint32_t
>
mStackPointer
;
}
;
#
endif
