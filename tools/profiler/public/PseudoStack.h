#
ifndef
PROFILER_PSEUDO_STACK_H_
#
define
PROFILER_PSEUDO_STACK_H_
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
js
/
ProfilingStack
.
h
"
#
include
<
stdlib
.
h
>
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
if
defined
(
__arm__
)
typedef
void
(
*
LinuxKernelMemoryBarrierFunc
)
(
void
)
;
LinuxKernelMemoryBarrierFunc
pLinuxKernelMemoryBarrier
__attribute__
(
(
weak
)
)
=
(
LinuxKernelMemoryBarrierFunc
)
0xffff0fa0
;
#
define
STORE_SEQUENCER
(
)
pLinuxKernelMemoryBarrier
(
)
#
elif
defined
(
__i386__
)
|
|
defined
(
__x86_64__
)
|
|
\
defined
(
_M_IX86
)
|
|
defined
(
_M_X64
)
#
if
defined
(
_MSC_VER
)
#
include
<
intrin
.
h
>
#
define
STORE_SEQUENCER
(
)
_ReadWriteBarrier
(
)
;
#
elif
defined
(
__INTEL_COMPILER
)
#
define
STORE_SEQUENCER
(
)
__memory_barrier
(
)
;
#
elif
__GNUC__
#
define
STORE_SEQUENCER
(
)
asm
volatile
(
"
"
:
:
:
"
memory
"
)
;
#
else
#
error
"
Memory
clobber
not
supported
for
your
compiler
.
"
#
endif
#
else
#
error
"
Memory
clobber
not
supported
for
your
platform
.
"
#
endif
class
ProfilerMarkerPayload
;
template
<
typename
T
>
class
ProfilerLinkedList
;
class
SpliceableJSONWriter
;
class
UniqueStacks
;
class
ProfilerMarker
{
friend
class
ProfilerLinkedList
<
ProfilerMarker
>
;
public
:
explicit
ProfilerMarker
(
const
char
*
aMarkerName
ProfilerMarkerPayload
*
aPayload
=
nullptr
double
aTime
=
0
)
;
~
ProfilerMarker
(
)
;
const
char
*
GetMarkerName
(
)
const
{
return
mMarkerName
;
}
void
StreamJSON
(
SpliceableJSONWriter
&
aWriter
UniqueStacks
&
aUniqueStacks
)
const
;
void
SetGeneration
(
uint32_t
aGenID
)
;
bool
HasExpired
(
uint32_t
aGenID
)
const
{
return
mGenID
+
2
<
=
aGenID
;
}
double
GetTime
(
)
const
;
private
:
char
*
mMarkerName
;
ProfilerMarkerPayload
*
mPayload
;
ProfilerMarker
*
mNext
;
double
mTime
;
uint32_t
mGenID
;
}
;
template
<
typename
T
>
class
ProfilerLinkedList
{
public
:
ProfilerLinkedList
(
)
:
mHead
(
nullptr
)
mTail
(
nullptr
)
{
}
void
insert
(
T
*
aElem
)
{
if
(
!
mTail
)
{
mHead
=
aElem
;
mTail
=
aElem
;
}
else
{
mTail
-
>
mNext
=
aElem
;
mTail
=
aElem
;
}
aElem
-
>
mNext
=
nullptr
;
}
T
*
popHead
(
)
{
if
(
!
mHead
)
{
MOZ_ASSERT
(
false
)
;
return
nullptr
;
}
T
*
head
=
mHead
;
mHead
=
head
-
>
mNext
;
if
(
!
mHead
)
{
mTail
=
nullptr
;
}
return
head
;
}
const
T
*
peek
(
)
{
return
mHead
;
}
private
:
T
*
mHead
;
T
*
mTail
;
}
;
typedef
ProfilerLinkedList
<
ProfilerMarker
>
ProfilerMarkerLinkedList
;
template
<
typename
T
>
class
ProfilerSignalSafeLinkedList
{
public
:
ProfilerSignalSafeLinkedList
(
)
:
mSignalLock
(
false
)
{
}
~
ProfilerSignalSafeLinkedList
(
)
{
if
(
mSignalLock
)
{
abort
(
)
;
}
while
(
mList
.
peek
(
)
)
{
delete
mList
.
popHead
(
)
;
}
}
void
insert
(
T
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
mSignalLock
=
true
;
STORE_SEQUENCER
(
)
;
mList
.
insert
(
aElement
)
;
STORE_SEQUENCER
(
)
;
mSignalLock
=
false
;
}
ProfilerLinkedList
<
T
>
*
accessList
(
)
{
return
mSignalLock
?
nullptr
:
&
mList
;
}
private
:
ProfilerLinkedList
<
T
>
mList
;
volatile
bool
mSignalLock
;
}
;
void
ProfilerJSEventMarker
(
const
char
*
aEvent
)
;
struct
PseudoStack
{
public
:
PseudoStack
(
)
:
mStackPointer
(
0
)
mSleep
(
AWAKE
)
mContext
(
nullptr
)
mStartJSSampling
(
false
)
mPrivacyMode
(
false
)
{
MOZ_COUNT_CTOR
(
PseudoStack
)
;
}
~
PseudoStack
(
)
{
MOZ_COUNT_DTOR
(
PseudoStack
)
;
MOZ_RELEASE_ASSERT
(
mStackPointer
=
=
0
)
;
}
void
reinitializeOnResume
(
)
{
(
void
)
mSleep
.
compareExchange
(
SLEEPING_OBSERVED
SLEEPING_NOT_OBSERVED
)
;
}
void
addMarker
(
const
char
*
aMarkerStr
ProfilerMarkerPayload
*
aPayload
double
aTime
)
{
ProfilerMarker
*
marker
=
new
ProfilerMarker
(
aMarkerStr
aPayload
aTime
)
;
mPendingMarkers
.
insert
(
marker
)
;
}
ProfilerMarkerLinkedList
*
getPendingMarkers
(
)
{
return
mPendingMarkers
.
accessList
(
)
;
}
void
push
(
const
char
*
aName
js
:
:
ProfileEntry
:
:
Category
aCategory
uint32_t
line
)
{
push
(
aName
aCategory
nullptr
false
line
)
;
}
void
push
(
const
char
*
aName
js
:
:
ProfileEntry
:
:
Category
aCategory
void
*
aStackAddress
bool
aCopy
uint32_t
line
)
{
if
(
size_t
(
mStackPointer
)
>
=
mozilla
:
:
ArrayLength
(
mStack
)
)
{
mStackPointer
+
+
;
return
;
}
volatile
js
:
:
ProfileEntry
&
entry
=
mStack
[
mStackPointer
]
;
entry
.
initCppFrame
(
aStackAddress
line
)
;
entry
.
setLabel
(
aName
)
;
MOZ_ASSERT
(
entry
.
flags
(
)
=
=
js
:
:
ProfileEntry
:
:
IS_CPP_ENTRY
)
;
entry
.
setCategory
(
aCategory
)
;
if
(
aCopy
)
{
entry
.
setFlag
(
js
:
:
ProfileEntry
:
:
FRAME_LABEL_COPY
)
;
}
else
{
entry
.
unsetFlag
(
js
:
:
ProfileEntry
:
:
FRAME_LABEL_COPY
)
;
}
STORE_SEQUENCER
(
)
;
mStackPointer
+
+
;
}
void
pop
(
)
{
mStackPointer
-
-
;
}
uint32_t
stackSize
(
)
const
{
return
std
:
:
min
(
mStackPointer
mozilla
:
:
sig_safe_t
(
mozilla
:
:
ArrayLength
(
mStack
)
)
)
;
}
void
sampleContext
(
JSContext
*
context
)
{
if
(
mContext
&
&
!
context
)
{
flushSamplerOnJSShutdown
(
)
;
}
mContext
=
context
;
if
(
!
context
)
{
return
;
}
static_assert
(
sizeof
(
mStack
[
0
]
)
=
=
sizeof
(
js
:
:
ProfileEntry
)
"
mStack
must
be
binary
compatible
with
js
:
:
ProfileEntry
.
"
)
;
js
:
:
SetContextProfilingStack
(
context
(
js
:
:
ProfileEntry
*
)
mStack
(
uint32_t
*
)
&
mStackPointer
(
uint32_t
)
mozilla
:
:
ArrayLength
(
mStack
)
)
;
if
(
mStartJSSampling
)
{
enableJSSampling
(
)
;
}
}
void
enableJSSampling
(
)
{
if
(
mContext
)
{
js
:
:
EnableContextProfilingStack
(
mContext
true
)
;
js
:
:
RegisterContextProfilingEventMarker
(
mContext
&
ProfilerJSEventMarker
)
;
mStartJSSampling
=
false
;
}
else
{
mStartJSSampling
=
true
;
}
}
void
jsOperationCallback
(
)
{
if
(
mStartJSSampling
)
{
enableJSSampling
(
)
;
}
}
void
disableJSSampling
(
)
{
mStartJSSampling
=
false
;
if
(
mContext
)
{
js
:
:
EnableContextProfilingStack
(
mContext
false
)
;
}
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
return
n
;
}
bool
CanDuplicateLastSampleDueToSleep
(
)
{
if
(
mSleep
=
=
AWAKE
)
{
return
false
;
}
if
(
mSleep
.
compareExchange
(
SLEEPING_NOT_OBSERVED
SLEEPING_OBSERVED
)
)
{
return
false
;
}
return
true
;
}
void
setSleeping
(
)
{
MOZ_ASSERT
(
mSleep
=
=
AWAKE
)
;
mSleep
=
SLEEPING_NOT_OBSERVED
;
}
void
setAwake
(
)
{
MOZ_ASSERT
(
mSleep
!
=
AWAKE
)
;
mSleep
=
AWAKE
;
}
bool
isSleeping
(
)
{
return
mSleep
!
=
AWAKE
;
}
private
:
PseudoStack
(
const
PseudoStack
&
)
=
delete
;
void
operator
=
(
const
PseudoStack
&
)
=
delete
;
void
flushSamplerOnJSShutdown
(
)
;
public
:
js
:
:
ProfileEntry
volatile
mStack
[
1024
]
;
private
:
ProfilerSignalSafeLinkedList
<
ProfilerMarker
>
mPendingMarkers
;
mozilla
:
:
sig_safe_t
mStackPointer
;
static
const
int
AWAKE
=
0
;
static
const
int
SLEEPING_NOT_OBSERVED
=
1
;
static
const
int
SLEEPING_OBSERVED
=
2
;
mozilla
:
:
Atomic
<
int
>
mSleep
;
public
:
JSContext
*
mContext
;
private
:
bool
mStartJSSampling
;
public
:
bool
mPrivacyMode
;
}
;
#
endif
