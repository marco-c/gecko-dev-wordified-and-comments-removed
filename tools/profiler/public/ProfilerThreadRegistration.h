#
ifndef
ProfilerThreadRegistration_h
#
define
ProfilerThreadRegistration_h
#
include
"
mozilla
/
BaseProfilerDetail
.
h
"
#
include
"
mozilla
/
ProfilerThreadRegistrationData
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
namespace
mozilla
:
:
profiler
{
class
ThreadRegistry
;
class
ThreadRegistration
{
private
:
using
DataMutex
=
baseprofiler
:
:
detail
:
:
BaseProfilerMutex
;
using
DataLock
=
baseprofiler
:
:
detail
:
:
BaseProfilerAutoLock
;
public
:
ThreadRegistration
(
const
char
*
aName
const
void
*
aStackTop
)
;
~
ThreadRegistration
(
)
;
static
ProfilingStack
*
RegisterThread
(
const
char
*
aName
const
void
*
aStackTop
)
;
static
void
UnregisterThread
(
)
;
[
[
nodiscard
]
]
static
bool
IsRegistered
(
)
{
return
GetFromTLS
(
)
;
}
ThreadRegistration
(
const
ThreadRegistration
&
)
=
delete
;
ThreadRegistration
&
operator
=
(
const
ThreadRegistration
&
)
=
delete
;
using
UnlockedConstReader
=
ThreadRegistrationUnlockedConstReader
;
using
UnlockedConstReaderAndAtomicRW
=
ThreadRegistrationUnlockedConstReaderAndAtomicRW
;
using
UnlockedRWForLockedProfiler
=
ThreadRegistrationUnlockedRWForLockedProfiler
;
using
UnlockedReaderAndAtomicRWOnThread
=
ThreadRegistrationUnlockedReaderAndAtomicRWOnThread
;
using
LockedRWFromAnyThread
=
ThreadRegistrationLockedRWFromAnyThread
;
using
LockedRWOnThread
=
ThreadRegistrationLockedRWOnThread
;
class
OnThreadRef
{
public
:
[
[
nodiscard
]
]
const
UnlockedConstReader
&
UnlockedConstReaderCRef
(
)
const
{
return
mThreadRegistration
-
>
mData
;
}
template
<
typename
F
>
auto
WithUnlockedConstReader
(
F
&
&
aF
)
const
{
return
std
:
:
forward
<
F
>
(
aF
)
(
UnlockedConstReaderCRef
(
)
)
;
}
[
[
nodiscard
]
]
const
UnlockedConstReaderAndAtomicRW
&
UnlockedConstReaderAndAtomicRWCRef
(
)
const
{
return
mThreadRegistration
-
>
mData
;
}
template
<
typename
F
>
auto
WithUnlockedConstReaderAndAtomicRW
(
F
&
&
aF
)
const
{
return
std
:
:
forward
<
F
>
(
aF
)
(
UnlockedConstReaderAndAtomicRWCRef
(
)
)
;
}
[
[
nodiscard
]
]
UnlockedConstReaderAndAtomicRW
&
UnlockedConstReaderAndAtomicRWRef
(
)
{
return
mThreadRegistration
-
>
mData
;
}
template
<
typename
F
>
auto
WithUnlockedConstReaderAndAtomicRW
(
F
&
&
aF
)
{
return
std
:
:
forward
<
F
>
(
aF
)
(
UnlockedConstReaderAndAtomicRWRef
(
)
)
;
}
[
[
nodiscard
]
]
const
UnlockedRWForLockedProfiler
&
UnlockedRWForLockedProfilerCRef
(
)
const
{
return
mThreadRegistration
-
>
mData
;
}
template
<
typename
F
>
auto
WithUnlockedRWForLockedProfiler
(
F
&
&
aF
)
const
{
return
std
:
:
forward
<
F
>
(
aF
)
(
UnlockedRWForLockedProfilerCRef
(
)
)
;
}
[
[
nodiscard
]
]
UnlockedRWForLockedProfiler
&
UnlockedRWForLockedProfilerRef
(
)
{
return
mThreadRegistration
-
>
mData
;
}
template
<
typename
F
>
auto
WithUnlockedRWForLockedProfiler
(
F
&
&
aF
)
{
return
std
:
:
forward
<
F
>
(
aF
)
(
UnlockedRWForLockedProfilerRef
(
)
)
;
}
[
[
nodiscard
]
]
const
UnlockedReaderAndAtomicRWOnThread
&
UnlockedReaderAndAtomicRWOnThreadCRef
(
)
const
{
return
mThreadRegistration
-
>
mData
;
}
template
<
typename
F
>
auto
WithUnlockedReaderAndAtomicRWOnThread
(
F
&
&
aF
)
const
{
return
std
:
:
forward
<
F
>
(
aF
)
(
UnlockedReaderAndAtomicRWOnThreadCRef
(
)
)
;
}
[
[
nodiscard
]
]
UnlockedReaderAndAtomicRWOnThread
&
UnlockedReaderAndAtomicRWOnThreadRef
(
)
{
return
mThreadRegistration
-
>
mData
;
}
template
<
typename
F
>
auto
WithUnlockedReaderAndAtomicRWOnThread
(
F
&
&
aF
)
{
return
std
:
:
forward
<
F
>
(
aF
)
(
UnlockedReaderAndAtomicRWOnThreadRef
(
)
)
;
}
class
ConstRWOnThreadWithLock
{
public
:
[
[
nodiscard
]
]
const
LockedRWOnThread
&
DataCRef
(
)
const
{
return
mLockedRWOnThread
;
}
[
[
nodiscard
]
]
const
LockedRWOnThread
*
operator
-
>
(
)
const
{
return
&
mLockedRWOnThread
;
}
private
:
friend
class
OnThreadRef
;
ConstRWOnThreadWithLock
(
const
LockedRWOnThread
&
aLockedRWOnThread
DataMutex
&
aDataMutex
)
:
mLockedRWOnThread
(
aLockedRWOnThread
)
mDataLock
(
aDataMutex
)
{
}
const
LockedRWOnThread
&
mLockedRWOnThread
;
DataLock
mDataLock
;
}
;
[
[
nodiscard
]
]
ConstRWOnThreadWithLock
ConstLockedRWOnThread
(
)
const
{
return
ConstRWOnThreadWithLock
{
mThreadRegistration
-
>
mData
mThreadRegistration
-
>
mDataMutex
}
;
}
template
<
typename
F
>
auto
WithConstLockedRWOnThread
(
F
&
&
aF
)
const
{
ConstRWOnThreadWithLock
lockedData
=
ConstLockedRWOnThread
(
)
;
return
std
:
:
forward
<
F
>
(
aF
)
(
lockedData
.
DataCRef
(
)
)
;
}
class
RWOnThreadWithLock
{
public
:
[
[
nodiscard
]
]
const
LockedRWOnThread
&
DataCRef
(
)
const
{
return
mLockedRWOnThread
;
}
[
[
nodiscard
]
]
LockedRWOnThread
&
DataRef
(
)
{
return
mLockedRWOnThread
;
}
[
[
nodiscard
]
]
const
LockedRWOnThread
*
operator
-
>
(
)
const
{
return
&
mLockedRWOnThread
;
}
[
[
nodiscard
]
]
LockedRWOnThread
*
operator
-
>
(
)
{
return
&
mLockedRWOnThread
;
}
private
:
friend
class
OnThreadRef
;
RWOnThreadWithLock
(
LockedRWOnThread
&
aLockedRWOnThread
DataMutex
&
aDataMutex
)
:
mLockedRWOnThread
(
aLockedRWOnThread
)
mDataLock
(
aDataMutex
)
{
}
LockedRWOnThread
&
mLockedRWOnThread
;
DataLock
mDataLock
;
}
;
[
[
nodiscard
]
]
RWOnThreadWithLock
LockedRWOnThread
(
)
{
return
RWOnThreadWithLock
{
mThreadRegistration
-
>
mData
mThreadRegistration
-
>
mDataMutex
}
;
}
template
<
typename
F
>
auto
WithLockedRWOnThread
(
F
&
&
aF
)
{
RWOnThreadWithLock
lockedData
=
LockedRWOnThread
(
)
;
return
std
:
:
forward
<
F
>
(
aF
)
(
lockedData
.
DataRef
(
)
)
;
}
OnThreadRef
*
operator
-
>
(
)
&
&
{
return
this
;
}
private
:
friend
class
ThreadRegistration
;
explicit
OnThreadRef
(
ThreadRegistration
&
aThreadRegistration
)
:
mThreadRegistration
(
&
aThreadRegistration
)
{
}
friend
class
ThreadRegistry
;
ThreadRegistration
*
mThreadRegistration
;
}
;
class
OnThreadPtr
{
public
:
[
[
nodiscard
]
]
explicit
operator
bool
(
)
const
{
return
mThreadRegistration
;
}
[
[
nodiscard
]
]
OnThreadRef
operator
*
(
)
const
{
MOZ_ASSERT
(
mThreadRegistration
)
;
return
OnThreadRef
(
*
mThreadRegistration
)
;
}
[
[
nodiscard
]
]
OnThreadRef
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mThreadRegistration
)
;
return
OnThreadRef
(
*
mThreadRegistration
)
;
}
private
:
friend
class
ThreadRegistration
;
explicit
OnThreadPtr
(
ThreadRegistration
*
aThreadRegistration
)
:
mThreadRegistration
(
aThreadRegistration
)
{
}
ThreadRegistration
*
mThreadRegistration
;
}
;
[
[
nodiscard
]
]
static
OnThreadPtr
GetOnThreadPtr
(
)
{
return
OnThreadPtr
{
GetFromTLS
(
)
}
;
}
template
<
typename
F
>
static
void
WithOnThreadRef
(
F
&
&
aF
)
{
const
auto
*
tls
=
GetTLS
(
)
;
if
(
tls
)
{
ThreadRegistration
*
tr
=
tls
-
>
get
(
)
;
if
(
tr
)
{
std
:
:
forward
<
F
>
(
aF
)
(
OnThreadRef
{
*
tr
}
)
;
}
}
}
template
<
typename
F
typename
FallbackReturn
>
[
[
nodiscard
]
]
static
auto
WithOnThreadRefOr
(
F
&
&
aF
FallbackReturn
&
&
aFallbackReturn
)
-
>
decltype
(
std
:
:
forward
<
F
>
(
aF
)
(
std
:
:
declval
<
OnThreadRef
>
(
)
)
)
{
const
auto
*
tls
=
GetTLS
(
)
;
if
(
tls
)
{
ThreadRegistration
*
tr
=
tls
-
>
get
(
)
;
if
(
tr
)
{
return
std
:
:
forward
<
F
>
(
aF
)
(
OnThreadRef
{
*
tr
}
)
;
}
}
return
std
:
:
forward
<
FallbackReturn
>
(
aFallbackReturn
)
;
}
[
[
nodiscard
]
]
static
bool
IsDataMutexLockedOnCurrentThread
(
)
{
if
(
const
ThreadRegistration
*
tr
=
GetFromTLS
(
)
;
tr
)
{
return
tr
-
>
mDataMutex
.
IsLockedOnCurrentThread
(
)
;
}
return
false
;
}
private
:
friend
class
ThreadRegistry
;
class
EmbeddedData
final
:
public
LockedRWOnThread
{
private
:
friend
class
ThreadRegistration
;
EmbeddedData
(
const
char
*
aName
const
void
*
aStackTop
)
:
LockedRWOnThread
(
aName
aStackTop
)
{
}
}
;
EmbeddedData
mData
;
DataMutex
mDataMutex
;
int
mOtherRegistrations
=
0
;
bool
mIsOnHeap
=
false
;
static
MOZ_THREAD_LOCAL
(
ThreadRegistration
*
)
tlsThreadRegistration
;
[
[
nodiscard
]
]
static
decltype
(
tlsThreadRegistration
)
*
GetTLS
(
)
{
static
const
bool
initialized
=
tlsThreadRegistration
.
init
(
)
;
return
initialized
?
&
tlsThreadRegistration
:
nullptr
;
}
[
[
nodiscard
]
]
static
ThreadRegistration
*
GetFromTLS
(
)
{
const
auto
tls
=
GetTLS
(
)
;
return
tls
?
tls
-
>
get
(
)
:
nullptr
;
}
}
;
}
#
endif
