pub
(
crate
)
mod
deserializer_tags_state
;
pub
mod
options
;
pub
mod
schema
;
pub
use
options
:
:
*
;
pub
use
schema
:
:
MarkerSchema
;
use
crate
:
:
gecko_bindings
:
:
{
bindings
profiling_categories
:
:
ProfilingCategoryPair
}
;
use
crate
:
:
json_writer
:
:
JSONWriter
;
use
crate
:
:
marker
:
:
deserializer_tags_state
:
:
get_or_insert_deserializer_tag
;
use
serde
:
:
{
de
:
:
DeserializeOwned
Deserialize
Serialize
}
;
use
std
:
:
os
:
:
raw
:
:
c_char
;
pub
fn
add_untyped_marker
(
name
:
&
str
category
:
ProfilingCategoryPair
mut
options
:
MarkerOptions
)
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
;
}
unsafe
{
bindings
:
:
gecko_profiler_add_marker_untyped
(
name
.
as_ptr
(
)
as
*
const
c_char
name
.
len
(
)
category
.
to_cpp_enum_value
(
)
options
.
timing
.
0
.
as_mut_ptr
(
)
options
.
stack
)
}
}
pub
fn
add_text_marker
(
name
:
&
str
category
:
ProfilingCategoryPair
mut
options
:
MarkerOptions
text
:
&
str
)
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
;
}
unsafe
{
bindings
:
:
gecko_profiler_add_marker_text
(
name
.
as_ptr
(
)
as
*
const
c_char
name
.
len
(
)
category
.
to_cpp_enum_value
(
)
options
.
timing
.
0
.
as_mut_ptr
(
)
options
.
stack
text
.
as_ptr
(
)
as
*
const
c_char
text
.
len
(
)
)
}
}
pub
trait
ProfilerMarker
:
Serialize
+
DeserializeOwned
{
fn
marker_type_name
(
)
-
>
&
'
static
str
;
fn
marker_type_display
(
)
-
>
MarkerSchema
;
fn
stream_json_marker_data
(
&
self
json_writer
:
&
mut
JSONWriter
)
;
}
unsafe
fn
transmute_and_stream
<
T
>
(
payload
:
*
const
u8
payload_size
:
usize
json_writer
:
&
mut
JSONWriter
)
where
T
:
ProfilerMarker
{
let
payload_slice
=
std
:
:
slice
:
:
from_raw_parts
(
payload
payload_size
)
;
let
payload
:
T
=
bincode
:
:
deserialize
(
&
payload_slice
)
.
unwrap
(
)
;
payload
.
stream_json_marker_data
(
json_writer
)
;
}
pub
fn
add_marker
<
T
>
(
name
:
&
str
category
:
ProfilingCategoryPair
mut
options
:
MarkerOptions
payload
:
T
)
where
T
:
ProfilerMarker
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
;
}
let
encoded_payload
:
Vec
<
u8
>
=
bincode
:
:
serialize
(
&
payload
)
.
unwrap
(
)
;
let
payload_size
=
encoded_payload
.
len
(
)
;
let
maker_tag
=
get_or_insert_deserializer_tag
:
:
<
T
>
(
)
;
unsafe
{
bindings
:
:
gecko_profiler_add_marker
(
name
.
as_ptr
(
)
as
*
const
c_char
name
.
len
(
)
category
.
to_cpp_enum_value
(
)
options
.
timing
.
0
.
as_mut_ptr
(
)
options
.
stack
maker_tag
encoded_payload
.
as_ptr
(
)
payload_size
)
}
}
#
[
derive
(
Serialize
Deserialize
Debug
)
]
pub
struct
Tracing
(
pub
String
)
;
impl
ProfilerMarker
for
Tracing
{
fn
marker_type_name
(
)
-
>
&
'
static
str
{
"
tracing
"
}
fn
stream_json_marker_data
(
&
self
json_writer
:
&
mut
JSONWriter
)
{
if
self
.
0
.
len
(
)
!
=
0
{
json_writer
.
string_property
(
"
category
"
&
self
.
0
)
;
}
}
fn
marker_type_display
(
)
-
>
MarkerSchema
{
use
crate
:
:
marker
:
:
schema
:
:
*
;
let
mut
schema
=
MarkerSchema
:
:
new
(
&
[
Location
:
:
MarkerChart
Location
:
:
MarkerTable
Location
:
:
TimelineOverview
]
)
;
schema
.
add_key_label_format
(
"
category
"
"
Type
"
Format
:
:
String
)
;
schema
}
}
