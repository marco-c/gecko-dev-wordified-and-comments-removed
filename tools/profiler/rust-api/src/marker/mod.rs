pub
(
crate
)
mod
deserializer_tags_state
;
pub
mod
options
;
pub
mod
schema
;
pub
use
options
:
:
*
;
pub
use
schema
:
:
MarkerSchema
;
use
crate
:
:
gecko_bindings
:
:
{
bindings
profiling_categories
:
:
ProfilingCategoryPair
}
;
use
crate
:
:
json_writer
:
:
JSONWriter
;
use
crate
:
:
marker
:
:
deserializer_tags_state
:
:
get_or_insert_deserializer_tag
;
use
crate
:
:
ProfilerTime
;
use
serde
:
:
{
de
:
:
DeserializeOwned
Deserialize
Serialize
}
;
use
smallvec
:
:
SmallVec
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
ffi
:
:
c_char
;
pub
type
CowString
=
Cow
<
'
static
str
>
;
pub
fn
add_untyped_marker
(
name
:
&
str
category
:
ProfilingCategoryPair
mut
options
:
MarkerOptions
)
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
;
}
unsafe
{
bindings
:
:
gecko_profiler_add_marker_untyped
(
name
.
as_ptr
(
)
as
*
const
c_char
name
.
len
(
)
category
.
to_cpp_enum_value
(
)
options
.
timing
.
0
.
as_mut_ptr
(
)
options
.
stack
)
}
}
pub
fn
add_text_marker
(
name
:
&
str
category
:
ProfilingCategoryPair
mut
options
:
MarkerOptions
text
:
&
str
)
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
;
}
unsafe
{
bindings
:
:
gecko_profiler_add_marker_text
(
name
.
as_ptr
(
)
as
*
const
c_char
name
.
len
(
)
category
.
to_cpp_enum_value
(
)
options
.
timing
.
0
.
as_mut_ptr
(
)
options
.
stack
text
.
as_ptr
(
)
as
*
const
c_char
text
.
len
(
)
)
}
}
pub
struct
AutoProfilerTextMarker
<
'
a
>
{
name
:
&
'
a
str
category
:
ProfilingCategoryPair
options
:
MarkerOptions
text
:
&
'
a
str
start
:
ProfilerTime
}
impl
<
'
a
>
AutoProfilerTextMarker
<
'
a
>
{
pub
fn
new
(
name
:
&
'
a
str
category
:
ProfilingCategoryPair
options
:
MarkerOptions
text
:
&
'
a
str
)
-
>
Option
<
AutoProfilerTextMarker
<
'
a
>
>
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
None
;
}
let
start
=
ProfilerTime
:
:
now
(
)
;
Some
(
AutoProfilerTextMarker
{
name
category
options
text
start
}
)
}
}
impl
<
'
a
>
Drop
for
AutoProfilerTextMarker
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
add_text_marker
(
self
.
name
self
.
category
self
.
options
.
with_timing
(
MarkerTiming
:
:
interval_until_now_from
(
self
.
start
.
clone
(
)
)
)
self
.
text
)
;
}
}
#
[
cfg
(
feature
=
"
enabled
"
)
]
#
[
macro_export
]
macro_rules
!
auto_profiler_marker_text
{
(
name
:
expr
category
:
expr
options
:
expr
text
:
expr
)
=
>
{
let
_macro_created_rust_text_marker
=
crate
:
:
AutoProfilerTextMarker
:
:
new
(
name
category
options
text
)
;
}
;
}
#
[
cfg
(
not
(
feature
=
"
enabled
"
)
)
]
#
[
macro_export
]
macro_rules
!
auto_profiler_marker_text
{
(
name
:
expr
category
:
expr
options
:
expr
text
:
expr
)
=
>
{
/
/
Do
nothing
if
the
profiler
is
not
enabled
}
;
}
pub
trait
ProfilerMarker
:
Serialize
+
DeserializeOwned
{
fn
marker_type_name
(
)
-
>
&
'
static
str
;
fn
marker_type_display
(
)
-
>
MarkerSchema
;
fn
stream_json_marker_data
(
&
self
json_writer
:
&
mut
JSONWriter
)
;
}
unsafe
fn
transmute_and_stream
<
T
>
(
payload
:
*
const
u8
payload_size
:
usize
json_writer
:
&
mut
JSONWriter
)
where
T
:
ProfilerMarker
{
let
payload_slice
=
std
:
:
slice
:
:
from_raw_parts
(
payload
payload_size
)
;
let
payload
:
T
=
bincode
:
:
deserialize
(
&
payload_slice
)
.
unwrap
(
)
;
payload
.
stream_json_marker_data
(
json_writer
)
;
}
pub
fn
add_marker
<
T
>
(
name
:
&
str
category
:
ProfilingCategoryPair
mut
options
:
MarkerOptions
payload
:
T
)
where
T
:
ProfilerMarker
+
'
static
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
;
}
let
marker_tag
=
get_or_insert_deserializer_tag
:
:
<
T
>
(
)
;
let
mut
encoded_payload
=
SmallVec
:
:
<
[
u8
;
64
]
>
:
:
new
(
)
;
bincode
:
:
serialize_into
(
&
mut
encoded_payload
&
payload
)
.
expect
(
"
Failed
to
serialize
marker
payload
"
)
;
unsafe
{
bindings
:
:
gecko_profiler_add_marker
(
name
.
as_ptr
(
)
as
*
const
c_char
name
.
len
(
)
category
.
to_cpp_enum_value
(
)
options
.
timing
.
0
.
as_mut_ptr
(
)
options
.
stack
marker_tag
encoded_payload
.
as_ptr
(
)
encoded_payload
.
len
(
)
)
;
}
}
#
[
cfg
(
feature
=
"
enabled
"
)
]
#
[
macro_export
]
macro_rules
!
lazy_add_marker
{
(
name
:
expr
category
:
expr
options
:
expr
payload
:
expr
)
=
>
{
if
gecko_profiler
:
:
can_accept_markers
(
)
{
gecko_profiler
:
:
add_marker
(
name
category
options
payload
)
;
}
}
;
(
name
:
expr
category
:
expr
payload
:
expr
)
=
>
{
if
gecko_profiler
:
:
can_accept_markers
(
)
{
gecko_profiler
:
:
add_marker
(
name
category
Default
:
:
default
(
)
payload
)
;
}
}
;
(
name
:
expr
payload
:
expr
)
=
>
{
if
gecko_profiler
:
:
can_accept_markers
(
)
{
gecko_profiler
:
:
add_marker
(
name
gecko_profiler
:
:
ProfilingCategoryPair
:
:
Other
(
None
)
Default
:
:
default
(
)
payload
)
;
}
}
;
}
#
[
cfg
(
not
(
feature
=
"
enabled
"
)
)
]
#
[
macro_export
]
macro_rules
!
lazy_add_marker
{
(
name
:
expr
category
:
expr
options
:
expr
text
:
expr
)
=
>
{
/
/
Do
nothing
if
the
profiler
is
not
enabled
}
;
(
name
:
expr
category
:
expr
payload
:
expr
)
=
>
{
/
/
Do
nothing
if
the
profiler
is
not
enabled
}
;
(
name
:
expr
payload
:
expr
)
=
>
{
/
/
Do
nothing
if
the
profiler
is
not
enabled
}
;
}
#
[
derive
(
Serialize
Deserialize
Debug
)
]
pub
struct
Tracing
(
pub
CowString
)
;
impl
Tracing
{
pub
fn
from_str
(
s
:
&
'
static
str
)
-
>
Self
{
Tracing
(
Cow
:
:
Borrowed
(
s
)
)
}
}
impl
ProfilerMarker
for
Tracing
{
fn
marker_type_name
(
)
-
>
&
'
static
str
{
"
tracing
"
}
fn
stream_json_marker_data
(
&
self
json_writer
:
&
mut
JSONWriter
)
{
if
self
.
0
.
len
(
)
!
=
0
{
json_writer
.
string_property
(
"
category
"
&
self
.
0
)
;
}
}
fn
marker_type_display
(
)
-
>
MarkerSchema
{
use
crate
:
:
marker
:
:
schema
:
:
*
;
let
mut
schema
=
MarkerSchema
:
:
new
(
&
[
Location
:
:
MarkerChart
Location
:
:
MarkerTable
Location
:
:
TimelineOverview
]
)
;
schema
.
add_key_label_format
(
"
category
"
"
Type
"
Format
:
:
String
)
;
schema
}
}
#
[
derive
(
Serialize
Deserialize
Debug
)
]
pub
struct
StackMarker
(
)
;
impl
ProfilerMarker
for
StackMarker
{
fn
marker_type_name
(
)
-
>
&
'
static
str
{
"
StackMarker
"
}
fn
stream_json_marker_data
(
&
self
_json_writer
:
&
mut
JSONWriter
)
{
}
fn
marker_type_display
(
)
-
>
MarkerSchema
{
use
crate
:
:
marker
:
:
schema
:
:
*
;
let
mut
schema
=
MarkerSchema
:
:
new
(
&
[
Location
:
:
MarkerChart
Location
:
:
MarkerTable
Location
:
:
TimelineOverview
]
)
;
schema
.
set_stack_based
(
)
;
schema
}
}
pub
struct
AutoProfilerMarker
<
'
a
>
{
name
:
&
'
a
str
category
:
ProfilingCategoryPair
options
:
MarkerOptions
}
impl
<
'
a
>
AutoProfilerMarker
<
'
a
>
{
pub
fn
new
(
name
:
&
'
a
str
category
:
ProfilingCategoryPair
options
:
MarkerOptions
)
-
>
Option
<
AutoProfilerMarker
<
'
a
>
>
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
None
;
}
add_marker
(
name
category
options
.
with_timing
(
MarkerTiming
:
:
interval_start
(
ProfilerTime
:
:
now
(
)
)
)
StackMarker
(
)
)
;
Some
(
AutoProfilerMarker
{
name
category
options
}
)
}
}
impl
<
'
a
>
Drop
for
AutoProfilerMarker
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
;
}
add_marker
(
self
.
name
self
.
category
self
.
options
.
with_timing
(
MarkerTiming
:
:
interval_end
(
ProfilerTime
:
:
now
(
)
)
)
StackMarker
(
)
)
;
}
}
#
[
cfg
(
feature
=
"
enabled
"
)
]
#
[
macro_export
]
macro_rules
!
auto_profiler_marker
{
(
name
:
expr
category
:
expr
options
:
expr
)
=
>
{
let
_macro_created_rust_tracing_marker
=
crate
:
:
AutoProfilerMarker
:
:
new
(
name
category
options
)
;
}
;
}
#
[
cfg
(
not
(
feature
=
"
enabled
"
)
)
]
#
[
macro_export
]
macro_rules
!
auto_profiler_marker
{
(
name
:
expr
category
:
expr
options
:
expr
)
=
>
{
/
/
Do
nothing
if
the
profiler
is
not
enabled
}
;
}
#
[
derive
(
Serialize
Deserialize
Debug
Clone
Copy
)
]
pub
struct
FlowStackMarker
(
pub
u64
)
;
impl
FlowStackMarker
{
pub
fn
from_pointer
<
T
>
(
s
:
*
const
T
)
-
>
Self
{
FlowStackMarker
(
s
as
usize
as
u64
)
}
}
impl
ProfilerMarker
for
FlowStackMarker
{
fn
marker_type_name
(
)
-
>
&
'
static
str
{
"
FlowStackRust
"
}
fn
stream_json_marker_data
(
&
self
json_writer
:
&
mut
JSONWriter
)
{
fn
hex_string
(
id
:
u64
)
-
>
[
u8
;
16
]
{
let
mut
buf
=
[
0
;
16
]
;
let
hex_digits
=
b
"
0123456789abcdef
"
;
for
i
in
0
.
.
16
{
buf
[
i
]
=
hex_digits
[
(
id
>
>
(
60
-
i
*
4
)
)
as
usize
&
0xf
]
;
}
buf
}
json_writer
.
unique_string_property
(
"
flow
"
unsafe
{
std
:
:
str
:
:
from_utf8_unchecked
(
&
hex_string
(
self
.
0
)
)
}
)
;
}
fn
marker_type_display
(
)
-
>
MarkerSchema
{
use
crate
:
:
marker
:
:
schema
:
:
*
;
let
mut
schema
=
MarkerSchema
:
:
new
(
&
[
Location
:
:
MarkerChart
Location
:
:
MarkerTable
]
)
;
schema
.
add_key_label_format
(
"
flow
"
"
Flow
"
Format
:
:
Flow
)
;
schema
.
set_stack_based
(
)
;
schema
}
}
pub
struct
AutoProfilerFlowMarker
<
'
a
>
{
name
:
&
'
a
str
category
:
ProfilingCategoryPair
options
:
MarkerOptions
flow
:
FlowStackMarker
start
:
ProfilerTime
}
impl
<
'
a
>
AutoProfilerFlowMarker
<
'
a
>
{
pub
fn
new
(
name
:
&
'
a
str
category
:
ProfilingCategoryPair
options
:
MarkerOptions
flow
:
FlowStackMarker
)
-
>
Option
<
AutoProfilerFlowMarker
<
'
a
>
>
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
None
;
}
Some
(
AutoProfilerFlowMarker
{
name
category
options
flow
start
:
ProfilerTime
:
:
now
(
)
}
)
}
}
impl
<
'
a
>
Drop
for
AutoProfilerFlowMarker
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
;
}
add_marker
(
self
.
name
self
.
category
self
.
options
.
with_timing
(
MarkerTiming
:
:
interval_until_now_from
(
self
.
start
.
clone
(
)
)
)
self
.
flow
)
;
}
}
#
[
cfg
(
feature
=
"
enabled
"
)
]
#
[
macro_export
]
macro_rules
!
auto_profiler_flow_marker
{
(
name
:
expr
category
:
expr
options
:
expr
payload
:
expr
)
=
>
{
let
_macro_created_rust_tracing_marker
=
crate
:
:
AutoProfilerFlowMarker
:
:
new
(
name
category
options
payload
)
;
}
;
}
#
[
cfg
(
not
(
feature
=
"
enabled
"
)
)
]
#
[
macro_export
]
macro_rules
!
auto_profiler_flow_marker
{
(
name
:
expr
category
:
expr
options
:
expr
payload
:
expr
)
=
>
{
/
/
Do
nothing
if
the
profiler
is
not
enabled
}
;
}
