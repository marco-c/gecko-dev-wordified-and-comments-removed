pub
(
crate
)
mod
deserializer_tags_state
;
pub
mod
options
;
pub
mod
schema
;
pub
use
options
:
:
*
;
pub
use
schema
:
:
MarkerSchema
;
use
crate
:
:
gecko_bindings
:
:
{
bindings
profiling_categories
:
:
ProfilingCategoryPair
}
;
use
crate
:
:
json_writer
:
:
JSONWriter
;
use
crate
:
:
marker
:
:
deserializer_tags_state
:
:
get_or_insert_deserializer_tag
;
use
crate
:
:
ProfilerTime
;
use
serde
:
:
{
de
:
:
DeserializeOwned
Deserialize
Serialize
}
;
use
std
:
:
borrow
:
:
Cow
;
use
std
:
:
os
:
:
raw
:
:
c_char
;
pub
type
CowString
=
Cow
<
'
static
str
>
;
pub
fn
add_untyped_marker
(
name
:
&
str
category
:
ProfilingCategoryPair
mut
options
:
MarkerOptions
)
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
;
}
unsafe
{
bindings
:
:
gecko_profiler_add_marker_untyped
(
name
.
as_ptr
(
)
as
*
const
c_char
name
.
len
(
)
category
.
to_cpp_enum_value
(
)
options
.
timing
.
0
.
as_mut_ptr
(
)
options
.
stack
)
}
}
pub
fn
add_text_marker
(
name
:
&
str
category
:
ProfilingCategoryPair
mut
options
:
MarkerOptions
text
:
&
str
)
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
;
}
unsafe
{
bindings
:
:
gecko_profiler_add_marker_text
(
name
.
as_ptr
(
)
as
*
const
c_char
name
.
len
(
)
category
.
to_cpp_enum_value
(
)
options
.
timing
.
0
.
as_mut_ptr
(
)
options
.
stack
text
.
as_ptr
(
)
as
*
const
c_char
text
.
len
(
)
)
}
}
pub
struct
AutoProfilerTextMarker
<
'
a
>
{
name
:
&
'
a
str
category
:
ProfilingCategoryPair
options
:
MarkerOptions
text
:
&
'
a
str
start
:
ProfilerTime
}
impl
<
'
a
>
AutoProfilerTextMarker
<
'
a
>
{
pub
fn
new
(
name
:
&
'
a
str
category
:
ProfilingCategoryPair
options
:
MarkerOptions
text
:
&
'
a
str
)
-
>
Option
<
AutoProfilerTextMarker
<
'
a
>
>
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
None
;
}
let
start
=
ProfilerTime
:
:
now
(
)
;
Some
(
AutoProfilerTextMarker
{
name
category
options
text
start
}
)
}
}
impl
<
'
a
>
Drop
for
AutoProfilerTextMarker
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
add_text_marker
(
self
.
name
self
.
category
self
.
options
.
with_timing
(
MarkerTiming
:
:
interval_until_now_from
(
self
.
start
.
clone
(
)
)
)
self
.
text
)
;
}
}
#
[
cfg
(
feature
=
"
enabled
"
)
]
#
[
macro_export
]
macro_rules
!
auto_profiler_marker_text
{
(
name
:
expr
category
:
expr
options
:
expr
text
:
expr
)
=
>
{
let
_macro_created_rust_text_marker
=
crate
:
:
AutoProfilerTextMarker
:
:
new
(
name
category
options
text
)
;
}
;
}
#
[
cfg
(
not
(
feature
=
"
enabled
"
)
)
]
#
[
macro_export
]
macro_rules
!
auto_profiler_marker_text
{
(
name
:
expr
category
:
expr
options
:
expr
text
:
expr
)
=
>
{
/
/
Do
nothing
if
the
profiler
is
not
enabled
}
;
}
pub
trait
ProfilerMarker
:
Serialize
+
DeserializeOwned
{
fn
marker_type_name
(
)
-
>
&
'
static
str
;
fn
marker_type_display
(
)
-
>
MarkerSchema
;
fn
stream_json_marker_data
(
&
self
json_writer
:
&
mut
JSONWriter
)
;
}
unsafe
fn
transmute_and_stream
<
T
>
(
payload
:
*
const
u8
payload_size
:
usize
json_writer
:
&
mut
JSONWriter
)
where
T
:
ProfilerMarker
{
let
payload_slice
=
std
:
:
slice
:
:
from_raw_parts
(
payload
payload_size
)
;
let
payload
:
T
=
bincode
:
:
deserialize
(
&
payload_slice
)
.
unwrap
(
)
;
payload
.
stream_json_marker_data
(
json_writer
)
;
}
pub
fn
add_marker
<
T
>
(
name
:
&
str
category
:
ProfilingCategoryPair
mut
options
:
MarkerOptions
payload
:
T
)
where
T
:
ProfilerMarker
+
'
static
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
;
}
let
encoded_payload
:
Vec
<
u8
>
=
bincode
:
:
serialize
(
&
payload
)
.
unwrap
(
)
;
let
payload_size
=
encoded_payload
.
len
(
)
;
let
maker_tag
=
get_or_insert_deserializer_tag
:
:
<
T
>
(
)
;
unsafe
{
bindings
:
:
gecko_profiler_add_marker
(
name
.
as_ptr
(
)
as
*
const
c_char
name
.
len
(
)
category
.
to_cpp_enum_value
(
)
options
.
timing
.
0
.
as_mut_ptr
(
)
options
.
stack
maker_tag
encoded_payload
.
as_ptr
(
)
payload_size
)
}
}
#
[
derive
(
Serialize
Deserialize
Debug
)
]
pub
struct
Tracing
(
pub
CowString
)
;
impl
Tracing
{
pub
fn
from_str
(
s
:
&
'
static
str
)
-
>
Self
{
Tracing
(
Cow
:
:
Borrowed
(
s
)
)
}
}
impl
ProfilerMarker
for
Tracing
{
fn
marker_type_name
(
)
-
>
&
'
static
str
{
"
tracing
"
}
fn
stream_json_marker_data
(
&
self
json_writer
:
&
mut
JSONWriter
)
{
if
self
.
0
.
len
(
)
!
=
0
{
json_writer
.
string_property
(
"
category
"
&
self
.
0
)
;
}
}
fn
marker_type_display
(
)
-
>
MarkerSchema
{
use
crate
:
:
marker
:
:
schema
:
:
*
;
let
mut
schema
=
MarkerSchema
:
:
new
(
&
[
Location
:
:
MarkerChart
Location
:
:
MarkerTable
Location
:
:
TimelineOverview
]
)
;
schema
.
add_key_label_format
(
"
category
"
"
Type
"
Format
:
:
String
)
;
schema
}
}
pub
struct
AutoProfilerTracingMarker
<
'
a
>
{
name
:
&
'
a
str
category
:
ProfilingCategoryPair
options
:
MarkerOptions
payload
:
CowString
}
impl
<
'
a
>
AutoProfilerTracingMarker
<
'
a
>
{
pub
fn
new
(
name
:
&
'
a
str
category
:
ProfilingCategoryPair
options
:
MarkerOptions
payload
:
CowString
)
-
>
Option
<
AutoProfilerTracingMarker
<
'
a
>
>
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
None
;
}
add_marker
(
name
category
options
.
with_timing
(
MarkerTiming
:
:
interval_start
(
ProfilerTime
:
:
now
(
)
)
)
Tracing
(
payload
.
clone
(
)
)
)
;
Some
(
AutoProfilerTracingMarker
{
name
category
options
payload
}
)
}
}
impl
<
'
a
>
Drop
for
AutoProfilerTracingMarker
<
'
a
>
{
fn
drop
(
&
mut
self
)
{
if
!
crate
:
:
profiler_state
:
:
can_accept_markers
(
)
{
return
;
}
add_marker
(
self
.
name
self
.
category
self
.
options
.
with_timing
(
MarkerTiming
:
:
interval_end
(
ProfilerTime
:
:
now
(
)
)
)
Tracing
(
self
.
payload
.
clone
(
)
)
)
;
}
}
#
[
cfg
(
feature
=
"
enabled
"
)
]
#
[
macro_export
]
macro_rules
!
auto_profiler_marker_tracing
{
(
name
:
expr
category
:
expr
options
:
expr
payload
:
expr
)
=
>
{
let
_macro_created_rust_tracing_marker
=
crate
:
:
AutoProfilerTracingMarker
:
:
new
(
name
category
options
payload
)
;
}
;
}
#
[
cfg
(
not
(
feature
=
"
enabled
"
)
)
]
#
[
macro_export
]
macro_rules
!
auto_profiler_marker_tracing
{
(
name
:
expr
category
:
expr
options
:
expr
payload
:
expr
)
=
>
{
/
/
Do
nothing
if
the
profiler
is
not
enabled
}
;
}
