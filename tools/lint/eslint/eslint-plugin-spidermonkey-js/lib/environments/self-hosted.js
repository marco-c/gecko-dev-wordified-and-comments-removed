"
use
strict
"
;
const
path
=
require
(
"
path
"
)
;
const
fs
=
require
(
"
fs
"
)
;
let
gRootDir
=
null
;
function
getRootDir
(
)
{
if
(
!
gRootDir
)
{
function
searchUpForIgnore
(
dirName
filename
)
{
let
parsed
=
path
.
parse
(
dirName
)
;
while
(
parsed
.
root
!
=
=
dirName
)
{
if
(
fs
.
existsSync
(
path
.
join
(
dirName
filename
)
)
)
{
return
dirName
;
}
dirName
=
parsed
.
dir
;
parsed
=
path
.
parse
(
dirName
)
;
}
return
null
;
}
let
possibleRoot
=
searchUpForIgnore
(
path
.
dirname
(
module
.
filename
)
"
.
eslintignore
"
)
;
if
(
!
possibleRoot
)
{
possibleRoot
=
searchUpForIgnore
(
path
.
resolve
(
)
"
.
eslintignore
"
)
;
}
if
(
!
possibleRoot
)
{
possibleRoot
=
searchUpForIgnore
(
path
.
resolve
(
)
"
package
.
json
"
)
;
}
if
(
!
possibleRoot
)
{
possibleRoot
=
process
.
cwd
(
)
;
}
gRootDir
=
possibleRoot
;
}
return
gRootDir
;
}
function
tryReadFile
(
filePath
)
{
let
absPath
=
path
.
join
(
getRootDir
(
)
filePath
)
;
if
(
!
fs
.
existsSync
(
absPath
)
)
{
return
"
"
;
}
return
fs
.
readFileSync
(
absPath
"
utf
-
8
"
)
;
}
function
addGlobalsFrom
(
dirName
fileName
globals
)
{
let
filePath
=
path
.
join
(
dirName
fileName
)
;
let
lines
=
tryReadFile
(
filePath
)
.
split
(
"
\
n
"
)
;
for
(
let
line
of
lines
)
{
if
(
line
.
startsWith
(
"
function
"
)
|
|
line
.
startsWith
(
"
function
*
"
)
|
|
line
.
startsWith
(
"
async
function
"
)
|
|
line
.
startsWith
(
"
async
function
*
"
)
)
{
let
m
=
line
.
match
(
/
^
(
?
:
async
)
?
function
(
?
:
\
*
)
?
\
s
+
(
[
\
w
\
]
+
)
\
s
*
\
(
/
)
;
if
(
m
)
{
globals
[
m
[
1
]
]
=
"
readonly
"
;
}
}
else
if
(
line
.
startsWith
(
"
var
"
)
|
|
line
.
startsWith
(
"
let
"
)
|
|
line
.
startsWith
(
"
const
"
)
)
{
let
m
=
line
.
match
(
/
^
(
?
:
var
|
let
|
const
)
\
s
+
(
[
\
w
\
]
+
)
\
s
*
[
;
=
]
/
)
;
if
(
m
)
{
globals
[
m
[
1
]
]
=
"
readonly
"
;
}
}
else
if
(
line
.
startsWith
(
"
#
define
"
)
)
{
let
m
=
line
.
match
(
/
^
#
define
(
\
w
+
)
/
)
;
if
(
m
)
{
globals
[
m
[
1
]
]
=
"
readonly
"
;
}
}
else
if
(
line
.
startsWith
(
"
#
include
"
)
)
{
let
m
=
line
.
match
(
/
^
#
include
\
"
(
[
\
w
\
.
]
+
)
\
"
/
)
;
if
(
m
)
{
addGlobalsFrom
(
dirName
m
[
1
]
globals
)
;
}
}
}
}
function
selfHostingDefines
(
dirName
=
"
js
/
src
/
builtin
/
"
)
{
let
absDir
=
path
.
join
(
getRootDir
(
)
dirName
)
;
if
(
!
fs
.
existsSync
(
absDir
)
)
{
return
{
}
;
}
let
dirs
=
[
]
;
let
jsFiles
=
[
]
;
for
(
let
name
of
fs
.
readdirSync
(
absDir
)
)
{
let
stat
=
fs
.
statSync
(
path
.
join
(
absDir
name
)
)
;
if
(
stat
.
isDirectory
(
)
)
{
dirs
.
push
(
name
)
;
}
else
if
(
stat
.
isFile
(
)
&
&
name
.
endsWith
(
"
.
js
"
)
)
{
jsFiles
.
push
(
name
)
;
}
}
let
globals
=
Object
.
create
(
null
)
;
for
(
let
jsFile
of
jsFiles
)
{
addGlobalsFrom
(
dirName
jsFile
globals
)
;
}
for
(
let
dir
of
dirs
)
{
globals
=
{
.
.
.
globals
.
.
.
selfHostingDefines
(
path
.
join
(
dirName
dir
)
)
}
;
}
return
globals
;
}
function
selfHostingFunctions
(
)
{
let
content
=
tryReadFile
(
"
js
/
src
/
vm
/
SelfHosting
.
cpp
"
)
.
replace
(
/
\
s
+
/
g
"
"
)
;
let
globals
=
Object
.
create
(
null
)
;
let
re
=
/
(
?
:
JS_FN
|
JS_INLINABLE_FN
|
JS_TRAMPOLINE_FN
)
\
(
"
(
\
w
+
)
"
/
g
;
for
(
let
m
of
content
.
matchAll
(
re
)
)
{
globals
[
m
[
1
]
]
=
"
readonly
"
;
}
return
globals
;
}
function
errorNumbers
(
)
{
let
lines
=
tryReadFile
(
"
js
/
public
/
friend
/
ErrorNumbers
.
msg
"
)
.
split
(
"
\
n
"
)
;
let
globals
=
Object
.
create
(
null
)
;
for
(
let
line
of
lines
)
{
let
m
=
line
.
match
(
/
^
MSG_DEF
\
(
(
\
w
+
)
/
)
;
if
(
m
)
{
globals
[
m
[
1
]
]
=
"
readonly
"
;
}
}
return
globals
;
}
const
globals
=
{
.
.
.
selfHostingDefines
(
)
.
.
.
selfHostingFunctions
(
)
.
.
.
errorNumbers
(
)
}
;
module
.
exports
=
{
globals
}
;
