"
use
strict
"
;
var
escope
=
require
(
"
escope
"
)
;
var
espree
=
require
(
"
espree
"
)
;
var
estraverse
=
require
(
"
estraverse
"
)
;
var
path
=
require
(
"
path
"
)
;
var
fs
=
require
(
"
fs
"
)
;
var
ini
=
require
(
"
ini
-
parser
"
)
;
var
modules
=
null
;
var
directoryManifests
=
new
Map
(
)
;
var
definitions
=
[
/
^
loader
\
.
lazyGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyImporter
\
(
this
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyServiceGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyRequireGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyModuleGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyPreferenceGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyServiceGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineConstant
\
(
this
"
(
\
w
+
)
"
/
/
^
DevToolsUtils
\
.
defineLazyModuleGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
DevToolsUtils
\
.
defineLazyGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
Object
\
.
defineProperty
\
(
this
"
(
\
w
+
)
"
/
/
^
Reflect
\
.
defineProperty
\
(
this
"
(
\
w
+
)
"
/
/
^
this
\
.
__defineGetter__
\
(
"
(
\
w
+
)
"
/
/
^
this
\
.
(
\
w
+
)
=
/
]
;
var
imports
=
[
/
^
(
?
:
Cu
|
Components
\
.
utils
)
\
.
import
\
(
"
.
*
\
/
(
(
.
*
?
)
\
.
jsm
?
)
"
(
?
:
this
)
?
\
)
/
]
;
var
workerImportFilenameMatch
=
/
(
.
*
\
/
)
*
(
.
*
?
\
.
jsm
?
)
/
;
module
.
exports
=
{
getAST
:
function
(
sourceText
)
{
var
config
=
this
.
getPermissiveConfig
(
)
;
return
espree
.
parse
(
sourceText
config
)
;
}
getASTSource
:
function
(
node
)
{
switch
(
node
.
type
)
{
case
"
MemberExpression
"
:
if
(
node
.
computed
)
throw
new
Error
(
"
getASTSource
unsupported
computed
MemberExpression
"
)
;
return
this
.
getASTSource
(
node
.
object
)
+
"
.
"
+
this
.
getASTSource
(
node
.
property
)
;
case
"
ThisExpression
"
:
return
"
this
"
;
case
"
Identifier
"
:
return
node
.
name
;
case
"
Literal
"
:
return
JSON
.
stringify
(
node
.
value
)
;
case
"
CallExpression
"
:
var
args
=
node
.
arguments
.
map
(
a
=
>
this
.
getASTSource
(
a
)
)
.
join
(
"
"
)
;
return
this
.
getASTSource
(
node
.
callee
)
+
"
(
"
+
args
+
"
)
"
;
case
"
ObjectExpression
"
:
return
"
{
}
"
;
case
"
ExpressionStatement
"
:
return
this
.
getASTSource
(
node
.
expression
)
+
"
;
"
;
case
"
FunctionExpression
"
:
return
"
function
(
)
{
}
"
;
case
"
ArrowFunctionExpression
"
:
return
"
(
)
=
>
{
}
"
;
case
"
AssignmentExpression
"
:
return
this
.
getASTSource
(
node
.
left
)
+
"
=
"
+
this
.
getASTSource
(
node
.
right
)
;
default
:
throw
new
Error
(
"
getASTSource
unsupported
node
type
:
"
+
node
.
type
)
;
}
}
walkAST
(
ast
listener
)
{
let
parents
=
[
]
;
let
seenComments
=
new
Set
(
)
;
function
sendCommentEvents
(
comments
)
{
if
(
!
comments
)
{
return
;
}
for
(
let
comment
of
comments
)
{
if
(
seenComments
.
has
(
comment
)
)
{
return
;
}
seenComments
.
add
(
comment
)
;
listener
(
comment
.
type
+
"
Comment
"
comment
parents
)
;
}
}
estraverse
.
traverse
(
ast
{
enter
(
node
parent
)
{
let
leadingComments
=
node
.
leadingComments
;
if
(
node
.
type
=
=
=
"
Program
"
&
&
node
.
body
.
length
=
=
0
)
{
leadingComments
=
node
.
comments
;
}
sendCommentEvents
(
leadingComments
)
;
listener
(
node
.
type
node
parents
)
;
sendCommentEvents
(
node
.
trailingComments
)
;
parents
.
push
(
node
)
;
}
leave
(
node
parent
)
{
listener
(
node
.
type
+
"
:
exit
"
node
parents
)
;
if
(
parents
.
length
=
=
0
)
{
throw
new
Error
(
"
Left
more
nodes
than
entered
.
"
)
;
}
parents
.
pop
(
)
;
}
}
)
;
if
(
parents
.
length
)
{
throw
new
Error
(
"
Entered
more
nodes
than
left
.
"
)
;
}
}
convertWorkerExpressionToGlobals
:
function
(
node
isGlobal
repository
dirname
)
{
var
getGlobalsForFile
=
require
(
"
.
/
globals
"
)
.
getGlobalsForFile
;
if
(
!
modules
)
{
modules
=
require
(
path
.
join
(
repository
"
tools
"
"
lint
"
"
eslint
"
"
modules
.
json
"
)
)
;
}
let
results
=
[
]
;
let
expr
=
node
.
expression
;
if
(
node
.
expression
.
type
=
=
=
"
CallExpression
"
&
&
expr
.
callee
&
&
expr
.
callee
.
type
=
=
=
"
Identifier
"
&
&
expr
.
callee
.
name
=
=
=
"
importScripts
"
)
{
for
(
var
arg
of
expr
.
arguments
)
{
var
match
=
arg
.
value
.
match
(
workerImportFilenameMatch
)
;
if
(
match
)
{
if
(
!
match
[
1
]
)
{
let
filePath
=
path
.
resolve
(
dirname
match
[
2
]
)
;
if
(
fs
.
existsSync
(
filePath
)
)
{
let
additionalGlobals
=
getGlobalsForFile
(
filePath
)
;
results
=
results
.
concat
(
additionalGlobals
)
;
}
}
else
if
(
match
[
2
]
in
modules
)
{
results
.
push
(
modules
[
match
[
2
]
]
)
;
}
}
}
}
return
results
;
}
convertExpressionToGlobals
:
function
(
node
isGlobal
repository
)
{
if
(
!
modules
)
{
modules
=
require
(
path
.
join
(
repository
"
tools
"
"
lint
"
"
eslint
"
"
modules
.
json
"
)
)
;
}
try
{
var
source
=
this
.
getASTSource
(
node
)
;
}
catch
(
e
)
{
return
[
]
;
}
for
(
var
reg
of
definitions
)
{
var
match
=
source
.
match
(
reg
)
;
if
(
match
)
{
if
(
!
isGlobal
)
{
return
[
]
;
}
return
[
match
[
1
]
]
;
}
}
for
(
reg
of
imports
)
{
var
match
=
source
.
match
(
reg
)
;
if
(
match
)
{
if
(
node
.
expression
.
arguments
.
length
>
1
&
&
!
isGlobal
)
{
return
[
]
;
}
if
(
match
[
1
]
in
modules
)
{
return
modules
[
match
[
1
]
]
;
}
return
[
match
[
2
]
]
;
}
}
return
[
]
;
}
addVarToScope
:
function
(
name
scope
writable
)
{
scope
.
__defineGeneric
(
name
scope
.
set
scope
.
variables
null
null
)
;
let
variable
=
scope
.
set
.
get
(
name
)
;
variable
.
eslintExplicitGlobal
=
false
;
variable
.
writeable
=
writable
;
while
(
scope
.
type
!
=
"
global
"
)
{
scope
=
scope
.
upper
;
}
scope
.
through
=
scope
.
through
.
filter
(
function
(
reference
)
{
if
(
reference
.
identifier
.
name
!
=
name
)
{
return
true
;
}
reference
.
resolved
=
variable
;
variable
.
references
.
push
(
reference
)
;
return
false
;
}
)
;
}
addGlobals
:
function
(
globalVars
scope
)
{
globalVars
.
forEach
(
v
=
>
this
.
addVarToScope
(
v
.
name
scope
v
.
writable
)
)
;
}
getPermissiveConfig
:
function
(
)
{
return
{
range
:
true
loc
:
true
comment
:
true
attachComment
:
true
ecmaVersion
:
8
sourceType
:
"
script
"
ecmaFeatures
:
{
experimentalObjectRestSpread
:
true
globalReturn
:
true
}
}
;
}
getIsGlobalScope
:
function
(
ancestors
)
{
for
(
let
parent
of
ancestors
)
{
if
(
parent
.
type
=
=
"
FunctionExpression
"
|
|
parent
.
type
=
=
"
FunctionDeclaration
"
)
{
return
false
;
}
}
return
true
;
}
getIsHeadFile
:
function
(
scope
)
{
var
pathAndFilename
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
return
/
.
*
[
\
\
/
]
head
(
_
.
+
)
?
\
.
js
/
.
test
(
pathAndFilename
)
;
}
getTestHeadFiles
:
function
(
scope
)
{
if
(
!
this
.
getIsTest
(
scope
)
)
{
return
[
]
;
}
let
filepath
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
let
dir
=
path
.
dirname
(
filepath
)
;
let
names
=
fs
.
readdirSync
(
dir
)
.
filter
(
name
=
>
name
.
startsWith
(
"
head
"
)
&
&
name
.
endsWith
(
"
.
js
"
)
)
.
map
(
name
=
>
path
.
join
(
dir
name
)
)
;
return
names
;
}
getManifestsForDirectory
:
function
(
dir
)
{
if
(
directoryManifests
.
has
(
dir
)
)
{
return
directoryManifests
.
get
(
dir
)
;
}
let
manifests
=
[
]
;
let
names
=
fs
.
readdirSync
(
dir
)
;
for
(
let
name
of
names
)
{
if
(
!
name
.
endsWith
(
"
.
ini
"
)
)
{
continue
;
}
try
{
let
manifest
=
ini
.
parse
(
fs
.
readFileSync
(
path
.
join
(
dir
name
)
'
utf8
'
)
)
;
manifests
.
push
(
{
file
:
path
.
join
(
dir
name
)
manifest
}
)
}
catch
(
e
)
{
}
}
directoryManifests
.
set
(
dir
manifests
)
;
return
manifests
;
}
getTestManifest
:
function
(
scope
)
{
let
filepath
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
let
dir
=
path
.
dirname
(
filepath
)
;
let
filename
=
path
.
basename
(
filepath
)
;
for
(
let
manifest
of
this
.
getManifestsForDirectory
(
dir
)
)
{
if
(
filename
in
manifest
.
manifest
)
{
return
manifest
.
file
;
}
}
return
null
;
}
getIsTest
:
function
(
scope
)
{
let
manifest
=
this
.
getTestManifest
(
scope
)
;
if
(
manifest
)
{
return
true
;
}
return
!
!
this
.
getTestType
(
scope
)
;
}
getTestType
:
function
(
scope
)
{
let
manifest
=
this
.
getTestManifest
(
scope
)
;
if
(
manifest
)
{
let
name
=
path
.
basename
(
manifest
)
;
for
(
let
testType
of
[
"
browser
"
"
xpcshell
"
"
chrome
"
"
mochitest
"
]
)
{
if
(
name
.
startsWith
(
testType
)
)
{
return
testType
;
}
}
}
let
filepath
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
let
filename
=
path
.
basename
(
filepath
)
;
if
(
filename
.
startsWith
(
"
browser_
"
)
)
{
return
"
browser
"
;
}
if
(
filename
.
startsWith
(
"
test_
"
)
)
{
return
"
xpcshell
"
;
}
return
null
;
}
getIsWorker
:
function
(
filePath
)
{
let
filename
=
path
.
basename
(
this
.
cleanUpPath
(
filePath
)
)
.
toLowerCase
(
)
;
return
filename
.
includes
(
"
worker
"
)
;
}
getRootDir
:
function
(
fileName
)
{
var
dirName
=
path
.
dirname
(
fileName
)
;
while
(
dirName
&
&
!
fs
.
existsSync
(
path
.
join
(
dirName
"
.
eslintignore
"
)
)
)
{
dirName
=
path
.
dirname
(
dirName
)
;
}
if
(
!
dirName
)
{
throw
new
Error
(
"
Unable
to
find
root
of
repository
"
)
;
}
return
dirName
;
}
getAbsoluteFilePath
:
function
(
context
)
{
var
fileName
=
this
.
cleanUpPath
(
context
.
getFilename
(
)
)
;
var
cwd
=
process
.
cwd
(
)
;
if
(
path
.
isAbsolute
(
fileName
)
)
{
return
fileName
;
}
else
if
(
path
.
basename
(
fileName
)
=
=
fileName
)
{
return
path
.
join
(
cwd
fileName
)
;
}
else
{
var
dirName
=
path
.
dirname
(
fileName
)
;
return
cwd
.
slice
(
0
cwd
.
length
-
dirName
.
length
)
+
fileName
;
}
}
cleanUpPath
:
function
(
path
)
{
return
path
.
replace
(
/
^
"
/
"
"
)
.
replace
(
/
"
/
"
"
)
;
}
}
;
