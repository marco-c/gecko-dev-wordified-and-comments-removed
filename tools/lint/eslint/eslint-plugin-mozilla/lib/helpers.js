"
use
strict
"
;
const
espree
=
require
(
"
espree
"
)
;
const
estraverse
=
require
(
"
estraverse
"
)
;
const
path
=
require
(
"
path
"
)
;
const
fs
=
require
(
"
fs
"
)
;
const
ini
=
require
(
"
ini
-
parser
"
)
;
var
gModules
=
null
;
var
gRootDir
=
null
;
var
directoryManifests
=
new
Map
(
)
;
const
callExpressionDefinitions
=
[
/
^
loader
\
.
lazyGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyImporter
\
(
this
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyServiceGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyRequireGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyModuleGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
ChromeUtils
\
.
defineModuleGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyPreferenceGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyProxy
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyScriptGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyServiceGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineConstant
\
(
this
"
(
\
w
+
)
"
/
/
^
DevToolsUtils
\
.
defineLazyModuleGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
DevToolsUtils
\
.
defineLazyGetter
\
(
this
"
(
\
w
+
)
"
/
/
^
Object
\
.
defineProperty
\
(
this
"
(
\
w
+
)
"
/
/
^
Reflect
\
.
defineProperty
\
(
this
"
(
\
w
+
)
"
/
/
^
this
\
.
__defineGetter__
\
(
"
(
\
w
+
)
"
/
]
;
const
callExpressionMultiDefinitions
=
[
"
XPCOMUtils
.
defineLazyGlobalGetters
(
this
"
"
XPCOMUtils
.
defineLazyModuleGetters
(
this
"
"
XPCOMUtils
.
defineLazyServiceGetters
(
this
"
]
;
const
imports
=
[
/
^
(
?
:
Cu
|
Components
\
.
utils
|
ChromeUtils
)
\
.
import
\
(
"
.
*
\
/
(
(
.
*
?
)
\
.
jsm
?
)
"
(
?
:
this
)
?
\
)
/
]
;
const
workerImportFilenameMatch
=
/
(
.
*
\
/
)
*
(
.
*
?
\
.
jsm
?
)
/
;
module
.
exports
=
{
get
modulesGlobalData
(
)
{
if
(
!
gModules
)
{
if
(
this
.
isMozillaCentralBased
(
)
)
{
gModules
=
require
(
path
.
join
(
this
.
rootDir
"
tools
"
"
lint
"
"
eslint
"
"
modules
.
json
"
)
)
;
}
else
{
gModules
=
require
(
"
.
/
modules
.
json
"
)
;
}
}
return
gModules
;
}
getAST
(
sourceText
)
{
var
config
=
this
.
getPermissiveConfig
(
)
;
return
espree
.
parse
(
sourceText
config
)
;
}
getASTSource
(
node
context
)
{
switch
(
node
.
type
)
{
case
"
MemberExpression
"
:
if
(
node
.
computed
)
{
let
filename
=
context
&
&
context
.
getFilename
(
)
;
throw
new
Error
(
getASTSource
unsupported
computed
MemberExpression
in
{
filename
}
)
;
}
return
this
.
getASTSource
(
node
.
object
)
+
"
.
"
+
this
.
getASTSource
(
node
.
property
)
;
case
"
ThisExpression
"
:
return
"
this
"
;
case
"
Identifier
"
:
return
node
.
name
;
case
"
Literal
"
:
return
JSON
.
stringify
(
node
.
value
)
;
case
"
CallExpression
"
:
var
args
=
node
.
arguments
.
map
(
a
=
>
this
.
getASTSource
(
a
)
)
.
join
(
"
"
)
;
return
this
.
getASTSource
(
node
.
callee
)
+
"
(
"
+
args
+
"
)
"
;
case
"
ObjectExpression
"
:
return
"
{
}
"
;
case
"
ExpressionStatement
"
:
return
this
.
getASTSource
(
node
.
expression
)
+
"
;
"
;
case
"
FunctionExpression
"
:
return
"
function
(
)
{
}
"
;
case
"
ArrayExpression
"
:
return
"
[
"
+
node
.
elements
.
map
(
this
.
getASTSource
this
)
.
join
(
"
"
)
+
"
]
"
;
case
"
ArrowFunctionExpression
"
:
return
"
(
)
=
>
{
}
"
;
case
"
AssignmentExpression
"
:
return
this
.
getASTSource
(
node
.
left
)
+
"
=
"
+
this
.
getASTSource
(
node
.
right
)
;
case
"
BinaryExpression
"
:
return
this
.
getASTSource
(
node
.
left
)
+
"
"
+
node
.
operator
+
"
"
+
this
.
getASTSource
(
node
.
right
)
;
default
:
throw
new
Error
(
"
getASTSource
unsupported
node
type
:
"
+
node
.
type
)
;
}
}
walkAST
(
ast
listener
)
{
let
parents
=
[
]
;
estraverse
.
traverse
(
ast
{
enter
(
node
parent
)
{
listener
(
node
.
type
node
parents
)
;
parents
.
push
(
node
)
;
}
leave
(
node
parent
)
{
if
(
parents
.
length
=
=
0
)
{
throw
new
Error
(
"
Left
more
nodes
than
entered
.
"
)
;
}
parents
.
pop
(
)
;
}
}
)
;
if
(
parents
.
length
)
{
throw
new
Error
(
"
Entered
more
nodes
than
left
.
"
)
;
}
}
convertWorkerExpressionToGlobals
(
node
isGlobal
dirname
)
{
var
getGlobalsForFile
=
require
(
"
.
/
globals
"
)
.
getGlobalsForFile
;
let
globalModules
=
this
.
modulesGlobalData
;
let
results
=
[
]
;
let
expr
=
node
.
expression
;
if
(
node
.
expression
.
type
=
=
=
"
CallExpression
"
&
&
expr
.
callee
&
&
expr
.
callee
.
type
=
=
=
"
Identifier
"
&
&
expr
.
callee
.
name
=
=
=
"
importScripts
"
)
{
for
(
var
arg
of
expr
.
arguments
)
{
var
match
=
arg
.
value
&
&
arg
.
value
.
match
(
workerImportFilenameMatch
)
;
if
(
match
)
{
if
(
!
match
[
1
]
)
{
let
filePath
=
path
.
resolve
(
dirname
match
[
2
]
)
;
if
(
fs
.
existsSync
(
filePath
)
)
{
let
additionalGlobals
=
getGlobalsForFile
(
filePath
)
;
results
=
results
.
concat
(
additionalGlobals
)
;
}
}
else
if
(
match
[
2
]
in
globalModules
)
{
results
=
results
.
concat
(
globalModules
[
match
[
2
]
]
.
map
(
name
=
>
{
return
{
name
writable
:
true
}
;
}
)
)
;
}
}
}
}
return
results
;
}
convertThisAssignmentExpressionToGlobals
(
node
isGlobal
)
{
if
(
isGlobal
&
&
node
.
expression
.
left
&
&
node
.
expression
.
left
.
object
&
&
node
.
expression
.
left
.
object
.
type
=
=
=
"
ThisExpression
"
&
&
node
.
expression
.
left
.
property
&
&
node
.
expression
.
left
.
property
.
type
=
=
=
"
Identifier
"
)
{
return
[
{
name
:
node
.
expression
.
left
.
property
.
name
writable
:
true
}
]
;
}
return
[
]
;
}
convertCallExpressionToGlobals
(
node
isGlobal
)
{
let
express
=
node
.
expression
;
if
(
express
.
type
=
=
=
"
CallExpression
"
&
&
express
.
callee
.
type
=
=
=
"
MemberExpression
"
&
&
express
.
callee
.
object
&
&
express
.
callee
.
object
.
type
=
=
=
"
Identifier
"
&
&
express
.
arguments
.
length
=
=
=
1
&
&
express
.
arguments
[
0
]
.
type
=
=
=
"
ArrayExpression
"
&
&
express
.
callee
.
property
.
type
=
=
=
"
Identifier
"
&
&
express
.
callee
.
property
.
name
=
=
=
"
importGlobalProperties
"
)
{
return
express
.
arguments
[
0
]
.
elements
.
map
(
literal
=
>
{
return
{
name
:
literal
.
value
writable
:
false
}
;
}
)
;
}
let
source
;
try
{
source
=
this
.
getASTSource
(
node
)
;
}
catch
(
e
)
{
return
[
]
;
}
for
(
let
reg
of
imports
)
{
let
match
=
source
.
match
(
reg
)
;
if
(
match
)
{
if
(
node
.
expression
.
arguments
.
length
>
1
&
&
!
isGlobal
)
{
return
[
]
;
}
let
globalModules
=
this
.
modulesGlobalData
;
if
(
match
[
1
]
in
globalModules
)
{
let
explicit
=
globalModules
[
match
[
1
]
]
.
length
=
=
1
;
return
globalModules
[
match
[
1
]
]
.
map
(
name
=
>
(
{
name
writable
:
true
explicit
}
)
)
;
}
return
[
{
name
:
match
[
2
]
writable
:
true
explicit
:
true
}
]
;
}
}
if
(
!
isGlobal
)
{
return
[
]
;
}
for
(
let
reg
of
callExpressionDefinitions
)
{
let
match
=
source
.
match
(
reg
)
;
if
(
match
)
{
return
[
{
name
:
match
[
1
]
writable
:
true
explicit
:
true
}
]
;
}
}
if
(
callExpressionMultiDefinitions
.
some
(
expr
=
>
source
.
startsWith
(
expr
)
)
&
&
node
.
expression
.
arguments
[
1
]
)
{
let
arg
=
node
.
expression
.
arguments
[
1
]
;
if
(
arg
.
type
=
=
=
"
ObjectExpression
"
)
{
return
arg
.
properties
.
map
(
p
=
>
(
{
name
:
p
.
type
=
=
=
"
Property
"
&
&
p
.
key
.
name
writable
:
true
explicit
:
true
}
)
)
.
filter
(
g
=
>
g
.
name
)
;
}
if
(
arg
.
type
=
=
=
"
ArrayExpression
"
)
{
return
arg
.
elements
.
map
(
p
=
>
(
{
name
:
p
.
type
=
=
=
"
Literal
"
&
&
p
.
value
writable
:
true
explicit
:
true
}
)
)
.
filter
(
g
=
>
typeof
g
.
name
=
=
"
string
"
)
;
}
}
if
(
node
.
expression
.
callee
.
type
=
=
"
MemberExpression
"
&
&
node
.
expression
.
callee
.
property
.
type
=
=
"
Identifier
"
&
&
node
.
expression
.
callee
.
property
.
name
=
=
"
defineLazyScriptGetter
"
)
{
return
node
.
expression
.
arguments
[
1
]
.
elements
.
map
(
n
=
>
(
{
name
:
n
.
value
writable
:
true
explicit
:
true
}
)
)
;
}
return
[
]
;
}
addVarToScope
(
name
scope
writable
node
)
{
scope
.
__defineGeneric
(
name
scope
.
set
scope
.
variables
null
null
)
;
let
variable
=
scope
.
set
.
get
(
name
)
;
variable
.
eslintExplicitGlobal
=
false
;
variable
.
writeable
=
writable
;
if
(
node
)
{
variable
.
defs
.
push
(
{
node
name
:
{
name
}
}
)
;
variable
.
identifiers
.
push
(
node
)
;
}
while
(
scope
.
type
!
=
"
global
"
)
{
scope
=
scope
.
upper
;
}
scope
.
through
=
scope
.
through
.
filter
(
function
(
reference
)
{
if
(
reference
.
identifier
.
name
!
=
name
)
{
return
true
;
}
reference
.
resolved
=
variable
;
variable
.
references
.
push
(
reference
)
;
return
false
;
}
)
;
}
addGlobals
(
globalVars
scope
node
)
{
globalVars
.
forEach
(
v
=
>
this
.
addVarToScope
(
v
.
name
scope
v
.
writable
v
.
explicit
&
&
node
)
)
;
}
getPermissiveConfig
(
)
{
return
{
range
:
true
loc
:
true
comment
:
true
attachComment
:
true
ecmaVersion
:
9
sourceType
:
"
script
"
}
;
}
getIsFunctionNode
(
node
)
{
switch
(
node
.
type
)
{
case
"
ArrowFunctionExpression
"
:
case
"
FunctionDeclaration
"
:
case
"
FunctionExpression
"
:
return
true
;
}
return
false
;
}
getIsGlobalScope
(
ancestors
)
{
for
(
let
parent
of
ancestors
)
{
if
(
this
.
getIsFunctionNode
(
parent
)
)
{
return
false
;
}
}
return
true
;
}
getIsHeadFile
(
scope
)
{
var
pathAndFilename
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
return
/
.
*
[
\
\
/
]
head
(
_
.
+
)
?
\
.
js
/
.
test
(
pathAndFilename
)
;
}
getTestHeadFiles
(
scope
)
{
if
(
!
this
.
getIsTest
(
scope
)
)
{
return
[
]
;
}
let
filepath
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
let
dir
=
path
.
dirname
(
filepath
)
;
let
names
=
fs
.
readdirSync
(
dir
)
.
filter
(
name
=
>
(
name
.
startsWith
(
"
head
"
)
|
|
name
.
startsWith
(
"
xpcshell
-
head
"
)
)
&
&
name
.
endsWith
(
"
.
js
"
)
)
.
map
(
name
=
>
path
.
join
(
dir
name
)
)
;
return
names
;
}
getManifestsForDirectory
(
dir
)
{
if
(
directoryManifests
.
has
(
dir
)
)
{
return
directoryManifests
.
get
(
dir
)
;
}
let
manifests
=
[
]
;
let
names
=
[
]
;
try
{
names
=
fs
.
readdirSync
(
dir
)
;
}
catch
(
err
)
{
if
(
err
.
code
!
=
=
"
ENOENT
"
)
{
throw
err
;
}
}
for
(
let
name
of
names
)
{
if
(
!
name
.
endsWith
(
"
.
ini
"
)
)
{
continue
;
}
try
{
let
manifest
=
ini
.
parse
(
fs
.
readFileSync
(
path
.
join
(
dir
name
)
"
utf8
"
)
)
;
manifests
.
push
(
{
file
:
path
.
join
(
dir
name
)
manifest
}
)
;
}
catch
(
e
)
{
}
}
directoryManifests
.
set
(
dir
manifests
)
;
return
manifests
;
}
getTestManifest
(
scope
)
{
let
filepath
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
let
dir
=
path
.
dirname
(
filepath
)
;
let
filename
=
path
.
basename
(
filepath
)
;
for
(
let
manifest
of
this
.
getManifestsForDirectory
(
dir
)
)
{
if
(
filename
in
manifest
.
manifest
)
{
return
manifest
.
file
;
}
}
return
null
;
}
getIsTest
(
scope
)
{
let
manifest
=
this
.
getTestManifest
(
scope
)
;
if
(
manifest
)
{
return
true
;
}
return
!
!
this
.
getTestType
(
scope
)
;
}
getTestType
(
scope
)
{
let
testTypes
=
[
"
browser
"
"
xpcshell
"
"
chrome
"
"
mochitest
"
"
a11y
"
]
;
let
manifest
=
this
.
getTestManifest
(
scope
)
;
if
(
manifest
)
{
let
name
=
path
.
basename
(
manifest
)
;
for
(
let
testType
of
testTypes
)
{
if
(
name
.
startsWith
(
testType
)
)
{
return
testType
;
}
}
}
let
filepath
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
let
filename
=
path
.
basename
(
filepath
)
;
if
(
filename
.
startsWith
(
"
browser_
"
)
)
{
return
"
browser
"
;
}
if
(
filename
.
startsWith
(
"
test_
"
)
)
{
let
parent
=
path
.
basename
(
path
.
dirname
(
filepath
)
)
;
for
(
let
testType
of
testTypes
)
{
if
(
parent
.
startsWith
(
testType
)
)
{
return
testType
;
}
}
return
"
unknown
"
;
}
return
null
;
}
getIsWorker
(
filePath
)
{
let
filename
=
path
.
basename
(
this
.
cleanUpPath
(
filePath
)
)
.
toLowerCase
(
)
;
return
filename
.
includes
(
"
worker
"
)
;
}
get
rootDir
(
)
{
if
(
!
gRootDir
)
{
function
searchUpForIgnore
(
dirName
filename
)
{
let
parsed
=
path
.
parse
(
dirName
)
;
while
(
parsed
.
root
!
=
=
dirName
)
{
if
(
fs
.
existsSync
(
path
.
join
(
dirName
filename
)
)
)
{
return
dirName
;
}
dirName
=
parsed
.
dir
;
parsed
=
path
.
parse
(
dirName
)
;
}
return
null
;
}
let
possibleRoot
=
searchUpForIgnore
(
path
.
dirname
(
module
.
filename
)
"
.
eslintignore
"
)
;
if
(
!
possibleRoot
)
{
possibleRoot
=
searchUpForIgnore
(
path
.
resolve
(
)
"
.
eslintignore
"
)
;
}
if
(
!
possibleRoot
)
{
possibleRoot
=
searchUpForIgnore
(
path
.
resolve
(
)
"
package
.
json
"
)
;
}
if
(
!
possibleRoot
)
{
possibleRoot
=
process
.
cwd
(
)
;
}
gRootDir
=
possibleRoot
;
}
return
gRootDir
;
}
getAbsoluteFilePath
(
context
)
{
var
fileName
=
this
.
cleanUpPath
(
context
.
getFilename
(
)
)
;
var
cwd
=
process
.
cwd
(
)
;
if
(
path
.
isAbsolute
(
fileName
)
)
{
return
fileName
;
}
else
if
(
path
.
basename
(
fileName
)
=
=
fileName
)
{
return
path
.
join
(
cwd
fileName
)
;
}
var
dirName
=
path
.
dirname
(
fileName
)
;
return
cwd
.
slice
(
0
cwd
.
length
-
dirName
.
length
)
+
fileName
;
}
cleanUpPath
(
pathName
)
{
return
pathName
.
replace
(
/
^
"
/
"
"
)
.
replace
(
/
"
/
"
"
)
;
}
get
globalScriptsPath
(
)
{
return
path
.
join
(
this
.
rootDir
"
browser
"
"
base
"
"
content
"
"
global
-
scripts
.
inc
"
)
;
}
isMozillaCentralBased
(
)
{
return
fs
.
existsSync
(
this
.
globalScriptsPath
)
;
}
getSavedEnvironmentItems
(
environment
)
{
return
require
(
"
.
/
environments
/
saved
-
globals
.
json
"
)
.
environments
[
environment
]
;
}
getSavedRuleData
(
rule
)
{
return
require
(
"
.
/
rules
/
saved
-
rules
-
data
.
json
"
)
.
rulesData
[
rule
]
;
}
}
;
