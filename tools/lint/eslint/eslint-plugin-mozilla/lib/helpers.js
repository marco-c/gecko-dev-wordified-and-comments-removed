"
use
strict
"
;
const
parser
=
require
(
"
babel
/
eslint
-
parser
"
)
;
const
{
analyze
}
=
require
(
"
eslint
-
scope
"
)
;
const
{
KEYS
:
defaultVisitorKeys
}
=
require
(
"
eslint
-
visitor
-
keys
"
)
;
const
estraverse
=
require
(
"
estraverse
"
)
;
const
path
=
require
(
"
path
"
)
;
const
fs
=
require
(
"
fs
"
)
;
const
ini
=
require
(
"
multi
-
ini
"
)
;
const
recommendedConfig
=
require
(
"
.
/
configs
/
recommended
"
)
;
var
gRootDir
=
null
;
var
directoryManifests
=
new
Map
(
)
;
const
callExpressionDefinitions
=
[
/
^
loader
\
.
lazyGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyImporter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyServiceGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyRequireGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyModuleGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
ChromeUtils
\
.
defineModuleGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyPreferenceGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyProxy
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyScriptGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyServiceGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineConstant
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
DevToolsUtils
\
.
defineLazyModuleGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
DevToolsUtils
\
.
defineLazyGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
Object
\
.
defineProperty
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
Reflect
\
.
defineProperty
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
this
\
.
__defineGetter__
\
(
"
(
\
w
+
)
"
/
]
;
const
callExpressionMultiDefinitions
=
[
"
XPCOMUtils
.
defineLazyGlobalGetters
(
this
"
"
XPCOMUtils
.
defineLazyGlobalGetters
(
globalThis
"
"
XPCOMUtils
.
defineLazyModuleGetters
(
this
"
"
XPCOMUtils
.
defineLazyModuleGetters
(
globalThis
"
"
XPCOMUtils
.
defineLazyServiceGetters
(
this
"
"
XPCOMUtils
.
defineLazyServiceGetters
(
globalThis
"
"
ChromeUtils
.
defineESModuleGetters
(
this
"
"
ChromeUtils
.
defineESModuleGetters
(
globalThis
"
"
loader
.
lazyRequireGetter
(
this
"
"
loader
.
lazyRequireGetter
(
globalThis
"
]
;
const
workerImportFilenameMatch
=
/
(
.
*
\
/
)
*
(
(
.
*
?
)
\
.
jsm
?
)
/
;
module
.
exports
=
{
get
iniParser
(
)
{
if
(
!
this
.
_iniParser
)
{
this
.
_iniParser
=
new
ini
.
Parser
(
)
;
}
return
this
.
_iniParser
;
}
get
servicesData
(
)
{
return
require
(
"
.
/
services
.
json
"
)
;
}
parseCode
(
sourceText
astOptions
=
{
}
configOptions
=
{
}
)
{
let
config
=
{
.
.
.
this
.
getPermissiveConfig
(
configOptions
)
.
.
.
astOptions
}
;
let
parseResult
=
"
parseForESLint
"
in
parser
?
parser
.
parseForESLint
(
sourceText
config
)
:
{
ast
:
parser
.
parse
(
sourceText
config
)
}
;
let
visitorKeys
=
parseResult
.
visitorKeys
|
|
defaultVisitorKeys
;
visitorKeys
.
ExperimentalRestProperty
=
visitorKeys
.
RestElement
;
visitorKeys
.
ExperimentalSpreadProperty
=
visitorKeys
.
SpreadElement
;
return
{
ast
:
parseResult
.
ast
scopeManager
:
parseResult
.
scopeManager
|
|
analyze
(
parseResult
.
ast
)
visitorKeys
}
;
}
getASTSource
(
node
context
)
{
switch
(
node
.
type
)
{
case
"
MemberExpression
"
:
if
(
node
.
computed
)
{
let
filename
=
context
&
&
context
.
getFilename
(
)
;
throw
new
Error
(
getASTSource
unsupported
computed
MemberExpression
in
{
filename
}
)
;
}
return
(
this
.
getASTSource
(
node
.
object
)
+
"
.
"
+
this
.
getASTSource
(
node
.
property
)
)
;
case
"
ThisExpression
"
:
return
"
this
"
;
case
"
Identifier
"
:
return
node
.
name
;
case
"
Literal
"
:
return
JSON
.
stringify
(
node
.
value
)
;
case
"
CallExpression
"
:
var
args
=
node
.
arguments
.
map
(
a
=
>
this
.
getASTSource
(
a
)
)
.
join
(
"
"
)
;
return
this
.
getASTSource
(
node
.
callee
)
+
"
(
"
+
args
+
"
)
"
;
case
"
ObjectExpression
"
:
return
"
{
}
"
;
case
"
ExpressionStatement
"
:
return
this
.
getASTSource
(
node
.
expression
)
+
"
;
"
;
case
"
FunctionExpression
"
:
return
"
function
(
)
{
}
"
;
case
"
ArrayExpression
"
:
return
"
[
"
+
node
.
elements
.
map
(
this
.
getASTSource
this
)
.
join
(
"
"
)
+
"
]
"
;
case
"
ArrowFunctionExpression
"
:
return
"
(
)
=
>
{
}
"
;
case
"
AssignmentExpression
"
:
return
(
this
.
getASTSource
(
node
.
left
)
+
"
=
"
+
this
.
getASTSource
(
node
.
right
)
)
;
case
"
BinaryExpression
"
:
return
(
this
.
getASTSource
(
node
.
left
)
+
"
"
+
node
.
operator
+
"
"
+
this
.
getASTSource
(
node
.
right
)
)
;
case
"
UnaryExpression
"
:
return
node
.
operator
+
"
"
+
this
.
getASTSource
(
node
.
argument
)
;
default
:
throw
new
Error
(
"
getASTSource
unsupported
node
type
:
"
+
node
.
type
)
;
}
}
walkAST
(
ast
visitorKeys
listener
)
{
let
parents
=
[
]
;
estraverse
.
traverse
(
ast
{
enter
(
node
parent
)
{
listener
(
node
.
type
node
parents
)
;
parents
.
push
(
node
)
;
}
leave
(
node
parent
)
{
if
(
!
parents
.
length
)
{
throw
new
Error
(
"
Left
more
nodes
than
entered
.
"
)
;
}
parents
.
pop
(
)
;
}
keys
:
visitorKeys
}
)
;
if
(
parents
.
length
)
{
throw
new
Error
(
"
Entered
more
nodes
than
left
.
"
)
;
}
}
convertWorkerExpressionToGlobals
(
node
isGlobal
dirname
)
{
var
getGlobalsForFile
=
require
(
"
.
/
globals
"
)
.
getGlobalsForFile
;
let
results
=
[
]
;
let
expr
=
node
.
expression
;
if
(
node
.
expression
.
type
=
=
=
"
CallExpression
"
&
&
expr
.
callee
&
&
expr
.
callee
.
type
=
=
=
"
Identifier
"
&
&
expr
.
callee
.
name
=
=
=
"
importScripts
"
)
{
for
(
var
arg
of
expr
.
arguments
)
{
var
match
=
arg
.
value
&
&
arg
.
value
.
match
(
workerImportFilenameMatch
)
;
if
(
match
)
{
if
(
!
match
[
1
]
)
{
let
filePath
=
path
.
resolve
(
dirname
match
[
2
]
)
;
if
(
fs
.
existsSync
(
filePath
)
)
{
let
additionalGlobals
=
getGlobalsForFile
(
filePath
)
;
results
=
results
.
concat
(
additionalGlobals
)
;
}
}
}
}
}
return
results
;
}
convertThisAssignmentExpressionToGlobals
(
node
isGlobal
)
{
if
(
isGlobal
&
&
node
.
expression
.
left
&
&
node
.
expression
.
left
.
object
&
&
node
.
expression
.
left
.
object
.
type
=
=
=
"
ThisExpression
"
&
&
node
.
expression
.
left
.
property
&
&
node
.
expression
.
left
.
property
.
type
=
=
=
"
Identifier
"
)
{
return
[
{
name
:
node
.
expression
.
left
.
property
.
name
writable
:
true
}
]
;
}
return
[
]
;
}
convertCallExpressionToGlobals
(
node
isGlobal
)
{
let
express
=
node
.
expression
;
if
(
express
.
type
=
=
=
"
CallExpression
"
&
&
express
.
callee
.
type
=
=
=
"
MemberExpression
"
&
&
express
.
callee
.
object
&
&
express
.
callee
.
object
.
type
=
=
=
"
Identifier
"
&
&
express
.
arguments
.
length
=
=
=
1
&
&
express
.
arguments
[
0
]
.
type
=
=
=
"
ArrayExpression
"
&
&
express
.
callee
.
property
.
type
=
=
=
"
Identifier
"
&
&
express
.
callee
.
property
.
name
=
=
=
"
importGlobalProperties
"
)
{
return
express
.
arguments
[
0
]
.
elements
.
map
(
literal
=
>
{
return
{
explicit
:
true
name
:
literal
.
value
writable
:
false
}
;
}
)
;
}
let
source
;
try
{
source
=
this
.
getASTSource
(
node
)
;
}
catch
(
e
)
{
return
[
]
;
}
if
(
!
isGlobal
)
{
return
[
]
;
}
for
(
let
reg
of
callExpressionDefinitions
)
{
let
match
=
source
.
match
(
reg
)
;
if
(
match
)
{
return
[
{
name
:
match
[
1
]
writable
:
true
explicit
:
true
}
]
;
}
}
if
(
callExpressionMultiDefinitions
.
some
(
expr
=
>
source
.
startsWith
(
expr
)
)
&
&
node
.
expression
.
arguments
[
1
]
)
{
let
arg
=
node
.
expression
.
arguments
[
1
]
;
if
(
arg
.
type
=
=
=
"
ObjectExpression
"
)
{
return
arg
.
properties
.
map
(
p
=
>
(
{
name
:
p
.
type
=
=
=
"
Property
"
&
&
p
.
key
.
name
writable
:
true
explicit
:
true
}
)
)
.
filter
(
g
=
>
g
.
name
)
;
}
if
(
arg
.
type
=
=
=
"
ArrayExpression
"
)
{
return
arg
.
elements
.
map
(
p
=
>
(
{
name
:
p
.
type
=
=
=
"
Literal
"
&
&
p
.
value
writable
:
true
explicit
:
true
}
)
)
.
filter
(
g
=
>
typeof
g
.
name
=
=
"
string
"
)
;
}
}
if
(
node
.
expression
.
callee
.
type
=
=
"
MemberExpression
"
&
&
node
.
expression
.
callee
.
property
.
type
=
=
"
Identifier
"
&
&
node
.
expression
.
callee
.
property
.
name
=
=
"
defineLazyScriptGetter
"
)
{
return
node
.
expression
.
arguments
[
1
]
.
elements
.
map
(
n
=
>
(
{
name
:
n
.
value
writable
:
true
explicit
:
true
}
)
)
;
}
return
[
]
;
}
addVarToScope
(
name
scope
writable
node
)
{
scope
.
__defineGeneric
(
name
scope
.
set
scope
.
variables
null
null
)
;
let
variable
=
scope
.
set
.
get
(
name
)
;
variable
.
eslintExplicitGlobal
=
false
;
variable
.
writeable
=
writable
;
if
(
node
)
{
variable
.
defs
.
push
(
{
type
:
"
Variable
"
node
name
:
{
name
parent
:
node
.
parent
}
}
)
;
variable
.
identifiers
.
push
(
node
)
;
}
while
(
scope
.
type
!
=
"
global
"
)
{
scope
=
scope
.
upper
;
}
scope
.
through
=
scope
.
through
.
filter
(
function
(
reference
)
{
if
(
reference
.
identifier
.
name
!
=
name
)
{
return
true
;
}
reference
.
resolved
=
variable
;
variable
.
references
.
push
(
reference
)
;
return
false
;
}
)
;
}
addGlobals
(
globalVars
scope
node
)
{
globalVars
.
forEach
(
v
=
>
this
.
addVarToScope
(
v
.
name
scope
v
.
writable
v
.
explicit
&
&
node
)
)
;
}
getPermissiveConfig
(
{
useBabel
=
true
}
=
{
}
)
{
const
config
=
{
range
:
true
requireConfigFile
:
false
babelOptions
:
{
}
loc
:
true
comment
:
true
attachComment
:
true
ecmaVersion
:
this
.
getECMAVersion
(
)
sourceType
:
"
script
"
}
;
if
(
useBabel
&
&
this
.
isMozillaCentralBased
(
)
)
{
config
.
babelOptions
.
configFile
=
path
.
join
(
gRootDir
"
.
babel
-
eslint
.
rc
.
js
"
)
;
}
return
config
;
}
getECMAVersion
(
)
{
return
recommendedConfig
.
parserOptions
.
ecmaVersion
;
}
getIsTopLevelScript
(
ancestors
)
{
for
(
let
parent
of
ancestors
)
{
switch
(
parent
.
type
)
{
case
"
ArrowFunctionExpression
"
:
case
"
FunctionDeclaration
"
:
case
"
FunctionExpression
"
:
case
"
PropertyDefinition
"
:
case
"
StaticBlock
"
:
return
false
;
}
}
return
true
;
}
getIsGlobalThis
(
ancestors
)
{
for
(
let
parent
of
ancestors
)
{
switch
(
parent
.
type
)
{
case
"
FunctionDeclaration
"
:
case
"
FunctionExpression
"
:
case
"
PropertyDefinition
"
:
case
"
StaticBlock
"
:
return
false
;
}
}
return
true
;
}
getIsTopLevelAndUnconditionallyExecuted
(
ancestors
)
{
for
(
let
parent
of
ancestors
)
{
switch
(
parent
.
type
)
{
case
"
IfStatement
"
:
case
"
SwitchStatement
"
:
case
"
TryStatement
"
:
case
"
WhileStatement
"
:
case
"
DoWhileStatement
"
:
case
"
ForStatement
"
:
case
"
ForInStatement
"
:
case
"
ForOfStatement
"
:
return
false
;
case
"
FunctionDeclaration
"
:
case
"
FunctionExpression
"
:
case
"
ArrowFunctionExpression
"
:
case
"
ClassBody
"
:
return
false
;
case
"
LogicalExpression
"
:
case
"
ConditionalExpression
"
:
case
"
ChainExpression
"
:
return
false
;
case
"
AssignmentExpression
"
:
switch
(
parent
.
operator
)
{
case
"
|
|
=
"
:
case
"
&
&
=
"
:
case
"
?
?
=
"
:
return
false
;
}
break
;
case
"
ObjectPattern
"
:
case
"
ArrayPattern
"
:
return
false
;
}
}
return
true
;
}
getIsHeadFile
(
scope
)
{
var
pathAndFilename
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
return
/
.
*
[
\
\
/
]
head
(
_
.
+
)
?
\
.
js
/
.
test
(
pathAndFilename
)
;
}
getTestHeadFiles
(
scope
)
{
if
(
!
this
.
getIsTest
(
scope
)
)
{
return
[
]
;
}
let
filepath
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
let
dir
=
path
.
dirname
(
filepath
)
;
let
names
=
fs
.
readdirSync
(
dir
)
.
filter
(
name
=
>
(
name
.
startsWith
(
"
head
"
)
|
|
name
.
startsWith
(
"
xpcshell
-
head
"
)
)
&
&
name
.
endsWith
(
"
.
js
"
)
)
.
map
(
name
=
>
path
.
join
(
dir
name
)
)
;
return
names
;
}
getManifestsForDirectory
(
dir
)
{
if
(
directoryManifests
.
has
(
dir
)
)
{
return
directoryManifests
.
get
(
dir
)
;
}
let
manifests
=
[
]
;
let
names
=
[
]
;
try
{
names
=
fs
.
readdirSync
(
dir
)
;
}
catch
(
err
)
{
if
(
err
.
code
!
=
=
"
ENOENT
"
)
{
throw
err
;
}
}
for
(
let
name
of
names
)
{
if
(
!
name
.
endsWith
(
"
.
ini
"
)
)
{
continue
;
}
try
{
let
manifest
=
this
.
iniParser
.
parse
(
fs
.
readFileSync
(
path
.
join
(
dir
name
)
"
utf8
"
)
.
split
(
"
\
n
"
)
)
;
manifests
.
push
(
{
file
:
path
.
join
(
dir
name
)
manifest
}
)
;
}
catch
(
e
)
{
}
}
directoryManifests
.
set
(
dir
manifests
)
;
return
manifests
;
}
getTestManifest
(
scope
)
{
let
filepath
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
let
dir
=
path
.
dirname
(
filepath
)
;
let
filename
=
path
.
basename
(
filepath
)
;
for
(
let
manifest
of
this
.
getManifestsForDirectory
(
dir
)
)
{
if
(
filename
in
manifest
.
manifest
)
{
return
manifest
.
file
;
}
}
return
null
;
}
getIsTest
(
scope
)
{
let
manifest
=
this
.
getTestManifest
(
scope
)
;
if
(
manifest
)
{
return
true
;
}
return
!
!
this
.
getTestType
(
scope
)
;
}
getIsSjs
(
scope
)
{
let
filepath
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
return
path
.
extname
(
filepath
)
=
=
"
.
sjs
"
;
}
getTestType
(
scope
)
{
let
testTypes
=
[
"
browser
"
"
xpcshell
"
"
chrome
"
"
mochitest
"
"
a11y
"
]
;
let
manifest
=
this
.
getTestManifest
(
scope
)
;
if
(
manifest
)
{
let
name
=
path
.
basename
(
manifest
)
;
for
(
let
testType
of
testTypes
)
{
if
(
name
.
startsWith
(
testType
)
)
{
return
testType
;
}
}
}
let
filepath
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
let
filename
=
path
.
basename
(
filepath
)
;
if
(
filename
.
startsWith
(
"
browser_
"
)
)
{
return
"
browser
"
;
}
if
(
filename
.
startsWith
(
"
test_
"
)
)
{
let
parent
=
path
.
basename
(
path
.
dirname
(
filepath
)
)
;
for
(
let
testType
of
testTypes
)
{
if
(
parent
.
startsWith
(
testType
)
)
{
return
testType
;
}
}
return
"
unknown
"
;
}
return
null
;
}
getIsWorker
(
filePath
)
{
let
filename
=
path
.
basename
(
this
.
cleanUpPath
(
filePath
)
)
.
toLowerCase
(
)
;
return
filename
.
includes
(
"
worker
"
)
;
}
get
rootDir
(
)
{
if
(
!
gRootDir
)
{
function
searchUpForIgnore
(
dirName
filename
)
{
let
parsed
=
path
.
parse
(
dirName
)
;
while
(
parsed
.
root
!
=
=
dirName
)
{
if
(
fs
.
existsSync
(
path
.
join
(
dirName
filename
)
)
)
{
return
dirName
;
}
dirName
=
parsed
.
dir
;
parsed
=
path
.
parse
(
dirName
)
;
}
return
null
;
}
let
possibleRoot
=
searchUpForIgnore
(
path
.
dirname
(
module
.
filename
)
"
.
eslintignore
"
)
;
if
(
!
possibleRoot
)
{
possibleRoot
=
searchUpForIgnore
(
path
.
resolve
(
)
"
.
eslintignore
"
)
;
}
if
(
!
possibleRoot
)
{
possibleRoot
=
searchUpForIgnore
(
path
.
resolve
(
)
"
package
.
json
"
)
;
}
if
(
!
possibleRoot
)
{
possibleRoot
=
process
.
cwd
(
)
;
}
gRootDir
=
possibleRoot
;
}
return
gRootDir
;
}
getAbsoluteFilePath
(
context
)
{
var
fileName
=
this
.
cleanUpPath
(
context
.
getFilename
(
)
)
;
var
cwd
=
process
.
cwd
(
)
;
if
(
path
.
isAbsolute
(
fileName
)
)
{
return
fileName
;
}
else
if
(
path
.
basename
(
fileName
)
=
=
fileName
)
{
return
path
.
join
(
cwd
fileName
)
;
}
var
dirName
=
path
.
dirname
(
fileName
)
;
return
cwd
.
slice
(
0
cwd
.
length
-
dirName
.
length
)
+
fileName
;
}
cleanUpPath
(
pathName
)
{
return
pathName
.
replace
(
/
^
"
/
"
"
)
.
replace
(
/
"
/
"
"
)
;
}
get
globalScriptPaths
(
)
{
return
[
path
.
join
(
this
.
rootDir
"
browser
"
"
base
"
"
content
"
"
browser
.
xhtml
"
)
path
.
join
(
this
.
rootDir
"
browser
"
"
base
"
"
content
"
"
global
-
scripts
.
inc
"
)
]
;
}
isMozillaCentralBased
(
)
{
return
fs
.
existsSync
(
this
.
globalScriptPaths
[
0
]
)
;
}
getSavedEnvironmentItems
(
environment
)
{
return
require
(
"
.
/
environments
/
saved
-
globals
.
json
"
)
.
environments
[
environment
]
;
}
getSavedRuleData
(
rule
)
{
return
require
(
"
.
/
rules
/
saved
-
rules
-
data
.
json
"
)
.
rulesData
[
rule
]
;
}
getBuildEnvironment
(
)
{
var
{
execFileSync
}
=
require
(
"
child_process
"
)
;
var
output
=
execFileSync
(
path
.
join
(
this
.
rootDir
"
mach
"
)
[
"
environment
"
"
-
-
format
=
json
"
]
{
silent
:
true
}
)
;
return
JSON
.
parse
(
output
)
;
}
getDevToolsRequirePath
(
node
)
{
if
(
node
.
callee
.
type
=
=
"
Identifier
"
&
&
node
.
callee
.
name
=
=
"
require
"
&
&
node
.
arguments
.
length
=
=
1
&
&
node
.
arguments
[
0
]
.
type
=
=
"
Literal
"
)
{
return
node
.
arguments
[
0
]
.
value
;
}
else
if
(
node
.
callee
.
type
=
=
"
MemberExpression
"
&
&
node
.
callee
.
property
.
type
=
=
"
Identifier
"
&
&
(
node
.
callee
.
property
.
name
=
=
"
lazyRequireGetter
"
|
|
node
.
callee
.
property
.
name
=
=
"
lazyImporter
"
)
&
&
node
.
arguments
.
length
>
=
3
&
&
node
.
arguments
[
2
]
.
type
=
=
"
Literal
"
)
{
return
node
.
arguments
[
2
]
.
value
;
}
return
null
;
}
maybeGetMemberPropertyName
(
node
)
{
if
(
node
.
type
=
=
=
"
MemberExpression
"
)
{
return
node
.
property
.
name
;
}
if
(
node
.
type
=
=
=
"
Identifier
"
)
{
return
node
.
name
;
}
return
null
;
}
}
;
