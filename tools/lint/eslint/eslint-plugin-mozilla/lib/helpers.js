"
use
strict
"
;
const
parser
=
require
(
"
espree
"
)
;
const
{
analyze
}
=
require
(
"
eslint
-
scope
"
)
;
const
{
KEYS
:
defaultVisitorKeys
}
=
require
(
"
eslint
-
visitor
-
keys
"
)
;
const
estraverse
=
require
(
"
estraverse
"
)
;
const
path
=
require
(
"
path
"
)
;
const
fs
=
require
(
"
fs
"
)
;
const
toml
=
require
(
"
toml
-
eslint
-
parser
"
)
;
var
gRootDir
=
null
;
var
directoryManifests
=
new
Map
(
)
;
let
xpidlData
;
module
.
exports
=
{
allFileExtensions
:
[
"
mjs
"
"
js
"
"
json
"
"
jsx
"
"
html
"
"
sjs
"
"
xhtml
"
]
turnOff
(
items
)
{
let
result
=
{
}
;
for
(
let
key
of
Object
.
keys
(
items
)
)
{
result
[
key
]
=
"
off
"
;
}
return
result
;
}
get
servicesData
(
)
{
return
require
(
"
.
/
services
.
json
"
)
;
}
get
xpidlData
(
)
{
let
xpidlDir
;
if
(
process
.
env
.
TASK_ID
&
&
!
process
.
env
.
MOZ_XPT_ARTIFACTS_DIR
)
{
throw
new
Error
(
"
MOZ_XPT_ARTIFACTS_DIR
must
be
set
for
this
rule
in
automation
"
)
;
}
xpidlDir
=
process
.
env
.
MOZ_XPT_ARTIFACTS_DIR
;
if
(
!
xpidlDir
&
&
process
.
env
.
MOZ_OBJDIR
)
{
xpidlDir
=
{
process
.
env
.
MOZ_OBJDIR
}
/
dist
/
xpt_artifacts
/
;
if
(
!
fs
.
existsSync
(
xpidlDir
)
)
{
xpidlDir
=
{
process
.
env
.
MOZ_OBJDIR
}
/
config
/
makefiles
/
xpidl
/
;
}
}
if
(
!
xpidlDir
)
{
throw
new
Error
(
"
MOZ_OBJDIR
must
be
defined
in
the
environment
for
this
rule
i
.
e
.
MOZ_OBJDIR
=
objdir
-
ff
.
/
mach
.
.
.
"
)
;
}
if
(
xpidlData
)
{
return
xpidlData
;
}
let
files
=
fs
.
readdirSync
(
{
xpidlDir
}
)
;
if
(
files
.
length
<
=
1
)
{
throw
new
Error
(
"
Missing
xpidl
data
files
maybe
you
need
to
build
?
"
)
;
}
xpidlData
=
new
Map
(
)
;
for
(
let
file
of
files
)
{
if
(
!
file
.
endsWith
(
"
.
xpt
"
)
)
{
continue
;
}
let
data
=
JSON
.
parse
(
fs
.
readFileSync
(
path
.
join
(
{
xpidlDir
}
file
)
)
)
;
for
(
let
details
of
data
)
{
xpidlData
.
set
(
details
.
name
details
)
;
}
}
return
xpidlData
;
}
parseCode
(
sourceText
astOptions
=
{
}
configOptions
=
{
}
)
{
let
config
=
{
.
.
.
this
.
getPermissiveConfig
(
configOptions
)
.
.
.
astOptions
}
;
let
parseResult
=
parser
.
parse
(
sourceText
config
)
;
let
visitorKeys
=
parseResult
.
visitorKeys
|
|
defaultVisitorKeys
;
config
.
ecmaVersion
=
config
.
ecmaVersion
=
=
"
latest
"
?
1e8
:
config
.
ecmaVersion
;
return
{
ast
:
parseResult
scopeManager
:
parseResult
.
scopeManager
|
|
analyze
(
parseResult
config
)
visitorKeys
}
;
}
getASTSource
(
node
context
)
{
switch
(
node
.
type
)
{
case
"
MemberExpression
"
:
if
(
node
.
computed
)
{
let
filename
=
context
&
&
context
.
getFilename
(
)
;
throw
new
Error
(
getASTSource
unsupported
computed
MemberExpression
in
{
filename
}
)
;
}
return
(
this
.
getASTSource
(
node
.
object
)
+
"
.
"
+
this
.
getASTSource
(
node
.
property
)
)
;
case
"
ThisExpression
"
:
return
"
this
"
;
case
"
Identifier
"
:
return
node
.
name
;
case
"
Literal
"
:
return
JSON
.
stringify
(
node
.
value
)
;
case
"
CallExpression
"
:
var
args
=
node
.
arguments
.
map
(
a
=
>
this
.
getASTSource
(
a
)
)
.
join
(
"
"
)
;
return
this
.
getASTSource
(
node
.
callee
)
+
"
(
"
+
args
+
"
)
"
;
case
"
ObjectExpression
"
:
return
"
{
}
"
;
case
"
ExpressionStatement
"
:
return
this
.
getASTSource
(
node
.
expression
)
+
"
;
"
;
case
"
FunctionExpression
"
:
return
"
function
(
)
{
}
"
;
case
"
ArrayExpression
"
:
return
"
[
"
+
node
.
elements
.
map
(
this
.
getASTSource
this
)
.
join
(
"
"
)
+
"
]
"
;
case
"
ArrowFunctionExpression
"
:
return
"
(
)
=
>
{
}
"
;
case
"
AssignmentExpression
"
:
return
(
this
.
getASTSource
(
node
.
left
)
+
"
=
"
+
this
.
getASTSource
(
node
.
right
)
)
;
case
"
BinaryExpression
"
:
return
(
this
.
getASTSource
(
node
.
left
)
+
"
"
+
node
.
operator
+
"
"
+
this
.
getASTSource
(
node
.
right
)
)
;
case
"
UnaryExpression
"
:
return
node
.
operator
+
"
"
+
this
.
getASTSource
(
node
.
argument
)
;
default
:
throw
new
Error
(
"
getASTSource
unsupported
node
type
:
"
+
node
.
type
)
;
}
}
walkAST
(
ast
visitorKeys
listener
)
{
let
parents
=
[
]
;
estraverse
.
traverse
(
ast
{
enter
(
node
)
{
listener
(
node
.
type
node
parents
)
;
parents
.
push
(
node
)
;
}
leave
(
)
{
if
(
!
parents
.
length
)
{
throw
new
Error
(
"
Left
more
nodes
than
entered
.
"
)
;
}
parents
.
pop
(
)
;
}
keys
:
visitorKeys
}
)
;
if
(
parents
.
length
)
{
throw
new
Error
(
"
Entered
more
nodes
than
left
.
"
)
;
}
}
addVarToScope
(
name
scope
writable
node
)
{
scope
.
__defineGeneric
(
name
scope
.
set
scope
.
variables
null
null
)
;
let
variable
=
scope
.
set
.
get
(
name
)
;
variable
.
eslintExplicitGlobal
=
false
;
variable
.
writeable
=
writable
;
if
(
node
)
{
variable
.
defs
.
push
(
{
type
:
"
Variable
"
node
name
:
{
name
parent
:
node
.
parent
}
}
)
;
variable
.
identifiers
.
push
(
node
)
;
}
while
(
scope
.
type
!
=
"
global
"
)
{
scope
=
scope
.
upper
;
}
scope
.
through
=
scope
.
through
.
filter
(
function
(
reference
)
{
if
(
reference
.
identifier
.
name
!
=
name
)
{
return
true
;
}
reference
.
resolved
=
variable
;
variable
.
references
.
push
(
reference
)
;
return
false
;
}
)
;
}
addGlobals
(
globalVars
scope
node
)
{
globalVars
.
forEach
(
v
=
>
this
.
addVarToScope
(
v
.
name
scope
v
.
writable
v
.
explicit
&
&
node
)
)
;
}
getPermissiveConfig
(
)
{
return
{
range
:
true
loc
:
true
comment
:
true
attachComment
:
true
ecmaVersion
:
this
.
getECMAVersion
(
)
sourceType
:
"
script
"
}
;
}
getECMAVersion
(
)
{
return
"
latest
"
;
}
getIsTopLevelScript
(
ancestors
)
{
for
(
let
parent
of
ancestors
)
{
switch
(
parent
.
type
)
{
case
"
ArrowFunctionExpression
"
:
case
"
FunctionDeclaration
"
:
case
"
FunctionExpression
"
:
case
"
PropertyDefinition
"
:
case
"
StaticBlock
"
:
return
false
;
}
}
return
true
;
}
isTopLevel
(
ancestors
)
{
for
(
let
parent
of
ancestors
)
{
switch
(
parent
.
type
)
{
case
"
ArrowFunctionExpression
"
:
case
"
FunctionDeclaration
"
:
case
"
FunctionExpression
"
:
case
"
PropertyDefinition
"
:
case
"
StaticBlock
"
:
case
"
BlockStatement
"
:
return
false
;
}
}
return
true
;
}
getIsGlobalThis
(
ancestors
)
{
for
(
let
parent
of
ancestors
)
{
switch
(
parent
.
type
)
{
case
"
FunctionDeclaration
"
:
case
"
FunctionExpression
"
:
case
"
PropertyDefinition
"
:
case
"
StaticBlock
"
:
return
false
;
}
}
return
true
;
}
getIsTopLevelAndUnconditionallyExecuted
(
ancestors
)
{
for
(
let
parent
of
ancestors
)
{
switch
(
parent
.
type
)
{
case
"
IfStatement
"
:
case
"
SwitchStatement
"
:
case
"
TryStatement
"
:
case
"
WhileStatement
"
:
case
"
DoWhileStatement
"
:
case
"
ForStatement
"
:
case
"
ForInStatement
"
:
case
"
ForOfStatement
"
:
return
false
;
case
"
FunctionDeclaration
"
:
case
"
FunctionExpression
"
:
case
"
ArrowFunctionExpression
"
:
case
"
ClassBody
"
:
return
false
;
case
"
LogicalExpression
"
:
case
"
ConditionalExpression
"
:
case
"
ChainExpression
"
:
return
false
;
case
"
AssignmentExpression
"
:
switch
(
parent
.
operator
)
{
case
"
|
|
=
"
:
case
"
&
&
=
"
:
case
"
?
?
=
"
:
return
false
;
}
break
;
case
"
ObjectPattern
"
:
case
"
ArrayPattern
"
:
return
false
;
}
}
return
true
;
}
getIsHeadFile
(
scope
)
{
var
pathAndFilename
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
return
/
.
*
[
\
\
/
]
head
(
_
.
+
)
?
\
.
js
/
.
test
(
pathAndFilename
)
;
}
getTestHeadFiles
(
scope
)
{
if
(
!
this
.
getIsTest
(
scope
)
)
{
return
[
]
;
}
let
filepath
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
let
dir
=
path
.
dirname
(
filepath
)
;
let
names
=
fs
.
readdirSync
(
dir
)
.
filter
(
name
=
>
(
name
.
startsWith
(
"
head
"
)
|
|
name
.
startsWith
(
"
xpcshell
-
head
"
)
)
&
&
name
.
endsWith
(
"
.
js
"
)
)
.
map
(
name
=
>
path
.
join
(
dir
name
)
)
;
return
names
;
}
getManifestsForDirectory
(
dir
)
{
if
(
directoryManifests
.
has
(
dir
)
)
{
return
directoryManifests
.
get
(
dir
)
;
}
let
manifests
=
[
]
;
let
names
=
[
]
;
try
{
names
=
fs
.
readdirSync
(
dir
)
;
}
catch
(
err
)
{
if
(
err
.
code
!
=
=
"
ENOENT
"
)
{
throw
err
;
}
}
for
(
let
name
of
names
)
{
if
(
name
.
endsWith
(
"
.
toml
"
)
)
{
try
{
const
ast
=
toml
.
parseTOML
(
fs
.
readFileSync
(
path
.
join
(
dir
name
)
"
utf8
"
)
)
;
var
manifest
=
{
}
;
ast
.
body
.
forEach
(
top
=
>
{
if
(
top
.
type
=
=
"
TOMLTopLevelTable
"
)
{
top
.
body
.
forEach
(
obj
=
>
{
if
(
obj
.
type
=
=
"
TOMLTable
"
)
{
manifest
[
obj
.
resolvedKey
]
=
{
}
;
}
}
)
;
}
}
)
;
manifests
.
push
(
{
file
:
path
.
join
(
dir
name
)
manifest
}
)
;
}
catch
(
e
)
{
console
.
error
(
"
TOML
ERROR
:
"
+
e
.
message
+
"
line
:
"
+
e
.
lineNumber
+
"
column
:
"
+
e
.
column
)
;
}
}
}
directoryManifests
.
set
(
dir
manifests
)
;
return
manifests
;
}
getTestManifest
(
scope
)
{
let
filepath
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
let
dir
=
path
.
dirname
(
filepath
)
;
let
filename
=
path
.
basename
(
filepath
)
;
for
(
let
manifest
of
this
.
getManifestsForDirectory
(
dir
)
)
{
if
(
filename
in
manifest
.
manifest
)
{
return
manifest
.
file
;
}
}
return
null
;
}
getIsTest
(
scope
)
{
let
manifest
=
this
.
getTestManifest
(
scope
)
;
if
(
manifest
)
{
return
true
;
}
return
!
!
this
.
getTestType
(
scope
)
;
}
getIsSjs
(
scope
)
{
let
filepath
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
return
path
.
extname
(
filepath
)
=
=
"
.
sjs
"
;
}
getTestType
(
scope
)
{
let
testTypes
=
[
"
browser
"
"
xpcshell
"
"
chrome
"
"
mochitest
"
"
a11y
"
]
;
let
manifest
=
this
.
getTestManifest
(
scope
)
;
if
(
manifest
)
{
let
name
=
path
.
basename
(
manifest
)
;
for
(
let
testType
of
testTypes
)
{
if
(
name
.
startsWith
(
testType
)
)
{
return
testType
;
}
}
}
let
filepath
=
this
.
cleanUpPath
(
scope
.
getFilename
(
)
)
;
let
filename
=
path
.
basename
(
filepath
)
;
if
(
filename
.
startsWith
(
"
browser_
"
)
)
{
return
"
browser
"
;
}
if
(
filename
.
startsWith
(
"
test_
"
)
)
{
let
parent
=
path
.
basename
(
path
.
dirname
(
filepath
)
)
;
for
(
let
testType
of
testTypes
)
{
if
(
parent
.
startsWith
(
testType
)
)
{
return
testType
;
}
}
return
"
unknown
"
;
}
return
null
;
}
getIsWorker
(
filePath
)
{
let
filename
=
path
.
basename
(
this
.
cleanUpPath
(
filePath
)
)
.
toLowerCase
(
)
;
return
filename
.
includes
(
"
worker
"
)
;
}
get
rootDir
(
)
{
if
(
!
gRootDir
)
{
function
searchUpForPackage
(
dirName
)
{
let
parsed
=
path
.
parse
(
dirName
)
;
while
(
parsed
.
root
!
=
=
dirName
)
{
let
possibleFile
=
path
.
join
(
dirName
"
package
.
json
"
)
;
if
(
fs
.
existsSync
(
possibleFile
)
)
{
let
packageData
=
require
(
possibleFile
)
;
if
(
packageData
.
nonPublishedName
=
=
"
mozilla
-
central
"
)
{
return
dirName
;
}
}
dirName
=
parsed
.
dir
;
parsed
=
path
.
parse
(
dirName
)
;
}
return
null
;
}
let
possibleRoot
=
searchUpForPackage
(
path
.
dirname
(
module
.
filename
)
)
;
if
(
!
possibleRoot
)
{
possibleRoot
=
searchUpForPackage
(
path
.
resolve
(
)
)
;
}
if
(
!
possibleRoot
)
{
possibleRoot
=
process
.
cwd
(
)
;
}
gRootDir
=
possibleRoot
;
}
return
gRootDir
;
}
getAbsoluteFilePath
(
context
)
{
var
fileName
=
this
.
cleanUpPath
(
context
.
getFilename
(
)
)
;
var
cwd
=
process
.
cwd
(
)
;
if
(
path
.
isAbsolute
(
fileName
)
)
{
return
fileName
;
}
else
if
(
path
.
basename
(
fileName
)
=
=
fileName
)
{
return
path
.
join
(
cwd
fileName
)
;
}
var
dirName
=
path
.
dirname
(
fileName
)
;
return
cwd
.
slice
(
0
cwd
.
length
-
dirName
.
length
)
+
fileName
;
}
cleanUpPath
(
pathName
)
{
return
pathName
.
replace
(
/
^
"
/
"
"
)
.
replace
(
/
"
/
"
"
)
;
}
get
globalScriptPaths
(
)
{
return
[
path
.
join
(
this
.
rootDir
"
browser
"
"
base
"
"
content
"
"
browser
-
main
.
js
"
)
path
.
join
(
this
.
rootDir
"
browser
"
"
base
"
"
content
"
"
global
-
scripts
.
js
"
)
]
;
}
isMozillaCentralBased
(
)
{
return
fs
.
existsSync
(
this
.
globalScriptPaths
[
0
]
)
;
}
getSavedEnvironmentItems
(
environment
)
{
return
require
(
"
.
/
environments
/
saved
-
globals
.
json
"
)
.
environments
[
environment
]
;
}
getSavedRuleData
(
rule
)
{
return
require
(
"
.
/
rules
/
saved
-
rules
-
data
.
json
"
)
.
rulesData
[
rule
]
;
}
getBuildEnvironment
(
)
{
var
{
execFileSync
}
=
require
(
"
child_process
"
)
;
var
output
=
execFileSync
(
path
.
join
(
this
.
rootDir
"
mach
"
)
[
"
environment
"
"
-
-
format
=
json
"
]
{
silent
:
true
}
)
;
return
JSON
.
parse
(
output
)
;
}
getDevToolsRequirePath
(
node
)
{
if
(
node
.
callee
.
type
=
=
"
Identifier
"
&
&
node
.
callee
.
name
=
=
"
require
"
&
&
node
.
arguments
.
length
=
=
1
&
&
node
.
arguments
[
0
]
.
type
=
=
"
Literal
"
)
{
return
node
.
arguments
[
0
]
.
value
;
}
else
if
(
node
.
callee
.
type
=
=
"
MemberExpression
"
&
&
node
.
callee
.
property
.
type
=
=
"
Identifier
"
&
&
node
.
callee
.
property
.
name
=
=
"
lazyRequireGetter
"
&
&
node
.
arguments
.
length
>
=
3
&
&
node
.
arguments
[
2
]
.
type
=
=
"
Literal
"
)
{
return
node
.
arguments
[
2
]
.
value
;
}
return
null
;
}
maybeGetMemberPropertyName
(
node
)
{
if
(
node
.
type
=
=
=
"
MemberExpression
"
)
{
return
node
.
property
.
name
;
}
if
(
node
.
type
=
=
=
"
Identifier
"
)
{
return
node
.
name
;
}
return
null
;
}
}
;
