"
use
strict
"
;
const
path
=
require
(
"
path
"
)
;
const
fs
=
require
(
"
fs
"
)
;
const
helpers
=
require
(
"
.
/
helpers
"
)
;
const
htmlparser
=
require
(
"
htmlparser2
"
)
;
const
testharnessEnvironment
=
require
(
"
.
/
environments
/
testharness
.
js
"
)
;
const
callExpressionDefinitions
=
[
/
^
loader
\
.
lazyGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyServiceGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
loader
\
.
lazyRequireGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
ChromeUtils
\
.
defineLazyGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyPreferenceGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyScriptGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineLazyServiceGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
XPCOMUtils
\
.
defineConstant
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
DevToolsUtils
\
.
defineLazyGetter
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
Object
\
.
defineProperty
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
Reflect
\
.
defineProperty
\
(
(
?
:
globalThis
|
this
)
"
(
\
w
+
)
"
/
/
^
this
\
.
__defineGetter__
\
(
"
(
\
w
+
)
"
/
]
;
const
callExpressionMultiDefinitions
=
[
"
XPCOMUtils
.
defineLazyGlobalGetters
(
this
"
"
XPCOMUtils
.
defineLazyGlobalGetters
(
globalThis
"
"
XPCOMUtils
.
defineLazyServiceGetters
(
this
"
"
XPCOMUtils
.
defineLazyServiceGetters
(
globalThis
"
"
ChromeUtils
.
defineESModuleGetters
(
this
"
"
ChromeUtils
.
defineESModuleGetters
(
globalThis
"
"
loader
.
lazyRequireGetter
(
this
"
"
loader
.
lazyRequireGetter
(
globalThis
"
]
;
const
subScriptMatches
=
[
/
Services
\
.
scriptloader
\
.
loadSubScript
\
(
"
(
.
*
?
)
"
this
\
)
/
]
;
const
workerImportFilenameMatch
=
/
(
.
*
\
/
)
*
(
(
.
*
?
)
\
.
js
)
/
;
function
parseBooleanConfig
(
string
comment
)
{
let
items
=
{
}
;
string
=
string
.
replace
(
/
\
s
*
:
\
s
*
/
g
"
:
"
)
;
string
=
string
.
replace
(
/
\
s
*
\
s
*
/
g
"
"
)
;
string
.
split
(
/
\
s
|
+
/
)
.
forEach
(
function
(
name
)
{
if
(
!
name
)
{
return
;
}
let
pos
=
name
.
indexOf
(
"
:
"
)
;
let
value
;
if
(
pos
!
=
=
-
1
)
{
value
=
name
.
substring
(
pos
+
1
name
.
length
)
;
name
=
name
.
substring
(
0
pos
)
;
}
items
[
name
]
=
{
value
:
value
=
=
=
"
true
"
comment
}
;
}
)
;
return
items
;
}
const
globalCache
=
new
Map
(
)
;
var
globalDiscoveryInProgressForFiles
=
new
Set
(
)
;
var
lastHTMLGlobals
=
{
}
;
function
convertCallExpressionToGlobals
(
node
isGlobal
)
{
let
express
=
node
.
expression
;
if
(
express
.
type
=
=
=
"
CallExpression
"
&
&
express
.
callee
.
type
=
=
=
"
MemberExpression
"
&
&
express
.
callee
.
object
&
&
express
.
callee
.
object
.
type
=
=
=
"
Identifier
"
&
&
express
.
arguments
.
length
=
=
=
1
&
&
express
.
arguments
[
0
]
.
type
=
=
=
"
ArrayExpression
"
&
&
express
.
callee
.
property
.
type
=
=
=
"
Identifier
"
&
&
express
.
callee
.
property
.
name
=
=
=
"
importGlobalProperties
"
)
{
return
express
.
arguments
[
0
]
.
elements
.
map
(
literal
=
>
{
return
{
explicit
:
true
name
:
literal
.
value
writable
:
false
}
;
}
)
;
}
if
(
!
isGlobal
)
{
return
[
]
;
}
let
source
;
try
{
source
=
helpers
.
getASTSource
(
node
)
;
}
catch
(
e
)
{
return
[
]
;
}
for
(
let
reg
of
subScriptMatches
)
{
let
match
=
source
.
match
(
reg
)
;
if
(
match
)
{
return
getGlobalsForScript
(
match
[
1
]
"
script
"
)
.
map
(
g
=
>
{
g
.
explicit
=
false
;
return
g
;
}
)
;
}
}
for
(
let
reg
of
callExpressionDefinitions
)
{
let
match
=
source
.
match
(
reg
)
;
if
(
match
)
{
return
[
{
name
:
match
[
1
]
writable
:
true
explicit
:
true
}
]
;
}
}
if
(
callExpressionMultiDefinitions
.
some
(
expr
=
>
source
.
startsWith
(
expr
)
)
&
&
node
.
expression
.
arguments
[
1
]
)
{
let
arg
=
node
.
expression
.
arguments
[
1
]
;
if
(
arg
.
type
=
=
=
"
ObjectExpression
"
)
{
return
arg
.
properties
.
map
(
p
=
>
(
{
name
:
p
.
type
=
=
=
"
Property
"
&
&
p
.
key
.
name
writable
:
true
explicit
:
true
}
)
)
.
filter
(
g
=
>
g
.
name
)
;
}
if
(
arg
.
type
=
=
=
"
ArrayExpression
"
)
{
return
arg
.
elements
.
map
(
p
=
>
(
{
name
:
p
.
type
=
=
=
"
Literal
"
&
&
p
.
value
writable
:
true
explicit
:
true
}
)
)
.
filter
(
g
=
>
typeof
g
.
name
=
=
"
string
"
)
;
}
}
if
(
node
.
expression
.
callee
.
type
=
=
"
MemberExpression
"
&
&
node
.
expression
.
callee
.
property
.
type
=
=
"
Identifier
"
&
&
node
.
expression
.
callee
.
property
.
name
=
=
"
defineLazyScriptGetter
"
)
{
return
node
.
expression
.
arguments
[
1
]
.
elements
.
map
(
n
=
>
(
{
name
:
n
.
value
writable
:
true
explicit
:
true
}
)
)
;
}
return
[
]
;
}
function
convertThisAssignmentExpressionToGlobals
(
node
isGlobal
)
{
if
(
isGlobal
&
&
node
.
expression
.
left
&
&
node
.
expression
.
left
.
object
&
&
node
.
expression
.
left
.
object
.
type
=
=
=
"
ThisExpression
"
&
&
node
.
expression
.
left
.
property
&
&
node
.
expression
.
left
.
property
.
type
=
=
=
"
Identifier
"
)
{
return
[
{
name
:
node
.
expression
.
left
.
property
.
name
writable
:
true
}
]
;
}
return
[
]
;
}
function
convertWorkerExpressionToGlobals
(
node
isGlobal
dirname
)
{
let
results
=
[
]
;
let
expr
=
node
.
expression
;
if
(
node
.
expression
.
type
=
=
=
"
CallExpression
"
&
&
expr
.
callee
&
&
expr
.
callee
.
type
=
=
=
"
Identifier
"
&
&
expr
.
callee
.
name
=
=
=
"
importScripts
"
)
{
for
(
var
arg
of
expr
.
arguments
)
{
var
match
=
arg
.
value
&
&
arg
.
value
.
match
(
workerImportFilenameMatch
)
;
if
(
match
)
{
if
(
!
match
[
1
]
)
{
let
filePath
=
path
.
resolve
(
dirname
match
[
2
]
)
;
if
(
fs
.
existsSync
(
filePath
)
)
{
let
additionalGlobals
=
module
.
exports
.
getGlobalsForFile
(
filePath
)
;
results
=
results
.
concat
(
additionalGlobals
)
;
}
}
}
}
}
return
results
;
}
function
getGlobalsForScript
(
src
type
dir
)
{
let
scriptName
;
if
(
src
.
includes
(
"
http
:
"
)
)
{
}
else
if
(
src
.
startsWith
(
"
chrome
:
/
/
mochikit
/
content
/
"
)
)
{
src
=
src
.
replace
(
"
chrome
:
/
/
mochikit
/
content
/
"
"
/
"
)
;
scriptName
=
path
.
join
(
helpers
.
rootDir
"
testing
"
"
mochitest
"
src
)
;
}
else
if
(
src
.
startsWith
(
"
chrome
:
/
/
mochitests
/
content
/
browser
"
)
)
{
src
=
src
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
browser
"
"
"
)
;
scriptName
=
path
.
join
(
helpers
.
rootDir
src
)
;
}
else
if
(
src
.
includes
(
"
SimpleTest
"
)
)
{
scriptName
=
path
.
join
(
helpers
.
rootDir
"
testing
"
"
mochitest
"
src
)
;
}
else
if
(
src
.
startsWith
(
"
/
tests
/
"
)
)
{
scriptName
=
path
.
join
(
helpers
.
rootDir
src
.
substring
(
7
)
)
;
}
else
if
(
src
.
startsWith
(
"
/
resources
/
testharness
.
js
"
)
)
{
return
Object
.
keys
(
testharnessEnvironment
.
globals
)
.
map
(
name
=
>
(
{
name
writable
:
true
}
)
)
;
}
else
if
(
dir
)
{
scriptName
=
path
.
join
(
dir
src
)
;
}
if
(
scriptName
&
&
fs
.
existsSync
(
scriptName
)
)
{
return
module
.
exports
.
getGlobalsForFile
(
scriptName
{
ecmaVersion
:
helpers
.
getECMAVersion
(
)
sourceType
:
type
}
)
;
}
return
[
]
;
}
function
GlobalsForNode
(
filePath
context
)
{
this
.
path
=
filePath
;
this
.
context
=
context
;
if
(
this
.
path
)
{
this
.
dirname
=
path
.
dirname
(
this
.
path
)
;
}
else
{
this
.
dirname
=
null
;
}
}
GlobalsForNode
.
prototype
=
{
Program
(
node
)
{
let
globals
=
[
]
;
for
(
let
comment
of
node
.
comments
)
{
if
(
comment
.
type
!
=
=
"
Block
"
)
{
continue
;
}
let
value
=
comment
.
value
.
trim
(
)
;
value
=
value
.
replace
(
/
\
n
/
g
"
"
)
;
let
match
=
/
^
globals
?
\
s
+
(
.
+
)
/
.
exec
(
value
)
;
if
(
match
)
{
let
values
=
parseBooleanConfig
(
match
[
1
]
.
trim
(
)
node
)
;
for
(
let
name
of
Object
.
keys
(
values
)
)
{
globals
.
push
(
{
name
writable
:
values
[
name
]
.
value
}
)
;
}
continue
;
}
match
=
/
^
import
-
globals
-
from
\
s
+
(
.
+
)
/
.
exec
(
value
)
;
if
(
!
match
)
{
continue
;
}
if
(
!
this
.
dirname
)
{
return
globals
;
}
let
filePath
=
match
[
1
]
.
trim
(
)
;
if
(
filePath
.
endsWith
(
"
.
mjs
"
)
)
{
if
(
this
.
context
)
{
this
.
context
.
report
(
comment
"
import
-
globals
-
from
does
not
support
module
files
-
use
a
direct
import
instead
"
)
;
}
else
{
throw
new
Error
(
"
import
-
globals
-
from
does
not
support
module
files
-
use
a
direct
import
instead
"
)
;
}
continue
;
}
if
(
!
path
.
isAbsolute
(
filePath
)
)
{
filePath
=
path
.
resolve
(
this
.
dirname
filePath
)
;
}
else
{
filePath
=
path
.
join
(
helpers
.
rootDir
filePath
)
;
}
globals
=
globals
.
concat
(
module
.
exports
.
getGlobalsForFile
(
filePath
)
)
;
}
return
globals
;
}
ExpressionStatement
(
node
parents
globalScope
)
{
let
isGlobal
=
helpers
.
getIsGlobalThis
(
parents
)
;
let
globals
=
[
]
;
if
(
node
.
expression
.
type
=
=
=
"
AssignmentExpression
"
)
{
globals
=
convertThisAssignmentExpressionToGlobals
(
node
isGlobal
)
;
}
else
if
(
node
.
expression
.
type
=
=
=
"
CallExpression
"
)
{
globals
=
convertCallExpressionToGlobals
(
node
isGlobal
)
;
}
if
(
globalScope
&
&
globalScope
.
set
.
get
(
"
importScripts
"
)
&
&
this
.
dirname
)
{
let
workerDetails
=
convertWorkerExpressionToGlobals
(
node
isGlobal
this
.
dirname
)
;
globals
=
globals
.
concat
(
workerDetails
)
;
}
return
globals
;
}
}
;
module
.
exports
=
{
getGlobalsForFile
(
filePath
astOptions
=
{
}
)
{
if
(
globalCache
.
has
(
filePath
)
)
{
return
globalCache
.
get
(
filePath
)
;
}
if
(
globalDiscoveryInProgressForFiles
.
has
(
filePath
)
)
{
return
[
]
;
}
globalDiscoveryInProgressForFiles
.
add
(
filePath
)
;
let
content
=
fs
.
readFileSync
(
filePath
"
utf8
"
)
;
let
{
ast
scopeManager
visitorKeys
}
=
helpers
.
parseCode
(
content
astOptions
)
;
let
globalScope
=
scopeManager
.
acquire
(
ast
)
;
let
globals
=
Object
.
keys
(
globalScope
.
variables
)
.
map
(
v
=
>
(
{
name
:
globalScope
.
variables
[
v
]
.
name
writable
:
true
}
)
)
;
let
handler
=
new
GlobalsForNode
(
filePath
)
;
helpers
.
walkAST
(
ast
visitorKeys
(
type
node
parents
)
=
>
{
if
(
type
in
handler
)
{
let
newGlobals
=
handler
[
type
]
(
node
parents
globalScope
)
;
globals
.
push
.
apply
(
globals
newGlobals
)
;
}
}
)
;
globalCache
.
set
(
filePath
globals
)
;
globalDiscoveryInProgressForFiles
.
delete
(
filePath
)
;
return
globals
;
}
getGlobalsForCode
(
code
astOptions
=
{
}
)
{
let
{
ast
scopeManager
visitorKeys
}
=
helpers
.
parseCode
(
code
astOptions
{
useBabel
:
false
}
)
;
let
globalScope
=
scopeManager
.
acquire
(
ast
)
;
let
globals
=
Object
.
keys
(
globalScope
.
variables
)
.
map
(
v
=
>
(
{
name
:
globalScope
.
variables
[
v
]
.
name
writable
:
true
}
)
)
;
let
handler
=
new
GlobalsForNode
(
null
)
;
helpers
.
walkAST
(
ast
visitorKeys
(
type
node
parents
)
=
>
{
if
(
type
in
handler
)
{
let
newGlobals
=
handler
[
type
]
(
node
parents
globalScope
)
;
globals
.
push
.
apply
(
globals
newGlobals
)
;
}
}
)
;
return
globals
;
}
getImportedGlobalsForHTMLFile
(
filePath
)
{
if
(
lastHTMLGlobals
.
filename
=
=
=
filePath
)
{
return
lastHTMLGlobals
.
globals
;
}
let
dir
=
path
.
dirname
(
filePath
)
;
let
globals
=
[
]
;
let
content
=
fs
.
readFileSync
(
filePath
"
utf8
"
)
;
let
scriptSrcs
=
[
]
;
let
parser
=
new
htmlparser
.
Parser
(
{
onopentag
(
name
attribs
)
{
if
(
name
=
=
=
"
script
"
&
&
"
src
"
in
attribs
)
{
scriptSrcs
.
push
(
{
src
:
attribs
.
src
type
:
"
type
"
in
attribs
&
&
attribs
.
type
=
=
"
module
"
?
"
module
"
:
"
script
"
}
)
;
}
}
}
{
xmlMode
:
filePath
.
endsWith
(
"
xhtml
"
)
}
)
;
parser
.
parseComplete
(
content
)
;
for
(
let
script
of
scriptSrcs
)
{
if
(
!
script
.
src
)
{
continue
;
}
globals
.
push
(
.
.
.
getGlobalsForScript
(
script
.
src
script
.
type
dir
)
)
;
}
lastHTMLGlobals
.
filePath
=
filePath
;
return
(
lastHTMLGlobals
.
globals
=
globals
)
;
}
getESLintGlobalParser
(
context
)
{
let
globalScope
;
let
parser
=
{
Program
(
node
)
{
globalScope
=
context
.
sourceCode
.
getScope
(
node
)
;
}
}
;
let
filename
=
context
.
getFilename
(
)
;
let
extraHTMLGlobals
=
[
]
;
if
(
filename
.
endsWith
(
"
.
html
"
)
|
|
filename
.
endsWith
(
"
.
xhtml
"
)
)
{
extraHTMLGlobals
=
module
.
exports
.
getImportedGlobalsForHTMLFile
(
filename
)
;
}
let
handler
=
new
GlobalsForNode
(
helpers
.
getAbsoluteFilePath
(
context
)
)
;
for
(
let
type
of
Object
.
keys
(
GlobalsForNode
.
prototype
)
)
{
parser
[
type
]
=
function
(
node
)
{
if
(
type
=
=
=
"
Program
"
)
{
globalScope
=
context
.
sourceCode
.
getScope
(
node
)
;
helpers
.
addGlobals
(
extraHTMLGlobals
globalScope
)
;
}
let
globals
=
handler
[
type
]
(
node
context
.
sourceCode
.
getAncestors
(
node
)
globalScope
)
;
helpers
.
addGlobals
(
globals
globalScope
node
.
type
!
=
=
"
Program
"
&
&
node
)
;
}
;
}
return
parser
;
}
}
;
