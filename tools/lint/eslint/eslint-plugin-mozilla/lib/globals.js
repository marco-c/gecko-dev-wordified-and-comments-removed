"
use
strict
"
;
const
path
=
require
(
"
path
"
)
;
const
fs
=
require
(
"
fs
"
)
;
const
helpers
=
require
(
"
.
/
helpers
"
)
;
const
eslintScope
=
require
(
"
eslint
-
scope
"
)
;
const
htmlparser
=
require
(
"
htmlparser2
"
)
;
function
parseBooleanConfig
(
string
comment
)
{
let
items
=
{
}
;
string
=
string
.
replace
(
/
\
s
*
:
\
s
*
/
g
"
:
"
)
;
string
=
string
.
replace
(
/
\
s
*
\
s
*
/
g
"
"
)
;
string
.
split
(
/
\
s
|
+
/
)
.
forEach
(
function
(
name
)
{
if
(
!
name
)
{
return
;
}
let
pos
=
name
.
indexOf
(
"
:
"
)
;
let
value
;
if
(
pos
!
=
=
-
1
)
{
value
=
name
.
substring
(
pos
+
1
name
.
length
)
;
name
=
name
.
substring
(
0
pos
)
;
}
items
[
name
]
=
{
value
:
value
=
=
=
"
true
"
comment
}
;
}
)
;
return
items
;
}
const
globalCache
=
new
Map
(
)
;
var
globalDiscoveryInProgressForFiles
=
new
Set
(
)
;
var
lastHTMLGlobals
=
{
}
;
function
GlobalsForNode
(
filePath
)
{
this
.
path
=
filePath
;
this
.
dirname
=
path
.
dirname
(
this
.
path
)
;
}
GlobalsForNode
.
prototype
=
{
Program
(
node
)
{
let
globals
=
[
]
;
for
(
let
comment
of
node
.
comments
)
{
if
(
comment
.
type
!
=
=
"
Block
"
)
{
continue
;
}
let
value
=
comment
.
value
.
trim
(
)
;
value
=
value
.
replace
(
/
\
n
/
g
"
"
)
;
let
match
=
/
^
globals
?
\
s
+
(
.
+
)
/
.
exec
(
value
)
;
if
(
match
)
{
let
values
=
parseBooleanConfig
(
match
[
1
]
.
trim
(
)
node
)
;
for
(
let
name
of
Object
.
keys
(
values
)
)
{
globals
.
push
(
{
name
writable
:
values
[
name
]
.
value
}
)
;
}
continue
;
}
match
=
/
^
import
-
globals
-
from
\
s
+
(
.
+
)
/
.
exec
(
value
)
;
if
(
!
match
)
{
continue
;
}
let
filePath
=
match
[
1
]
.
trim
(
)
;
if
(
!
path
.
isAbsolute
(
filePath
)
)
{
filePath
=
path
.
resolve
(
this
.
dirname
filePath
)
;
}
globals
=
globals
.
concat
(
module
.
exports
.
getGlobalsForFile
(
filePath
)
)
;
}
return
globals
;
}
ExpressionStatement
(
node
parents
globalScope
)
{
let
isGlobal
=
helpers
.
getIsGlobalScope
(
parents
)
;
let
globals
=
[
]
;
if
(
node
.
expression
.
type
=
=
=
"
AssignmentExpression
"
)
{
globals
=
helpers
.
convertThisAssignmentExpressionToGlobals
(
node
isGlobal
)
;
}
else
if
(
node
.
expression
.
type
=
=
=
"
CallExpression
"
)
{
globals
=
helpers
.
convertCallExpressionToGlobals
(
node
isGlobal
)
;
}
if
(
globalScope
&
&
globalScope
.
set
.
get
(
"
importScripts
"
)
)
{
let
workerDetails
=
helpers
.
convertWorkerExpressionToGlobals
(
node
isGlobal
this
.
dirname
)
;
globals
=
globals
.
concat
(
workerDetails
)
;
}
return
globals
;
}
}
;
module
.
exports
=
{
getGlobalsForFile
(
filePath
astOptions
=
{
}
)
{
if
(
globalCache
.
has
(
filePath
)
)
{
return
globalCache
.
get
(
filePath
)
;
}
if
(
globalDiscoveryInProgressForFiles
.
has
(
filePath
)
)
{
return
[
]
;
}
globalDiscoveryInProgressForFiles
.
add
(
filePath
)
;
let
content
=
fs
.
readFileSync
(
filePath
"
utf8
"
)
;
let
ast
=
helpers
.
getAST
(
content
astOptions
)
;
let
scopeManager
=
eslintScope
.
analyze
(
ast
astOptions
)
;
let
globalScope
=
scopeManager
.
acquire
(
ast
)
;
let
globals
=
Object
.
keys
(
globalScope
.
variables
)
.
map
(
v
=
>
(
{
name
:
globalScope
.
variables
[
v
]
.
name
writable
:
true
}
)
)
;
let
handler
=
new
GlobalsForNode
(
filePath
)
;
helpers
.
walkAST
(
ast
(
type
node
parents
)
=
>
{
if
(
type
in
handler
)
{
let
newGlobals
=
handler
[
type
]
(
node
parents
globalScope
)
;
globals
.
push
.
apply
(
globals
newGlobals
)
;
}
}
)
;
globalCache
.
set
(
filePath
globals
)
;
globalDiscoveryInProgressForFiles
.
delete
(
filePath
)
;
return
globals
;
}
getImportedGlobalsForHTMLFile
(
filePath
)
{
if
(
lastHTMLGlobals
.
filename
=
=
=
filePath
)
{
return
lastHTMLGlobals
.
globals
;
}
let
dir
=
path
.
dirname
(
filePath
)
;
let
globals
=
[
]
;
let
content
=
fs
.
readFileSync
(
filePath
"
utf8
"
)
;
let
scriptSrcs
=
[
]
;
let
parser
=
new
htmlparser
.
Parser
(
{
onopentag
(
name
attribs
)
{
if
(
name
=
=
=
"
script
"
&
&
"
src
"
in
attribs
)
{
scriptSrcs
.
push
(
{
src
:
attribs
.
src
type
:
"
type
"
in
attribs
&
&
attribs
.
type
=
=
"
module
"
?
"
module
"
:
"
script
"
}
)
;
}
}
}
{
xmlMode
:
filePath
.
endsWith
(
"
xhtml
"
)
}
)
;
parser
.
parseComplete
(
content
)
;
for
(
let
script
of
scriptSrcs
)
{
if
(
!
script
.
src
)
{
continue
;
}
let
scriptName
;
if
(
script
.
src
.
includes
(
"
http
:
"
)
)
{
}
else
if
(
script
.
src
.
includes
(
"
chrome
"
)
)
{
script
.
src
=
script
.
src
.
replace
(
"
chrome
:
/
/
mochikit
/
content
/
"
"
/
"
)
;
scriptName
=
path
.
join
(
helpers
.
rootDir
"
testing
"
"
mochitest
"
script
.
src
)
;
}
else
if
(
script
.
src
.
includes
(
"
SimpleTest
"
)
)
{
scriptName
=
path
.
join
(
helpers
.
rootDir
"
testing
"
"
mochitest
"
script
.
src
)
;
}
else
{
scriptName
=
path
.
join
(
dir
script
.
src
)
;
}
if
(
scriptName
&
&
fs
.
existsSync
(
scriptName
)
)
{
globals
.
push
(
.
.
.
module
.
exports
.
getGlobalsForFile
(
scriptName
{
ecmaVersion
:
helpers
.
getECMAVersion
(
)
sourceType
:
script
.
type
}
)
)
;
}
}
lastHTMLGlobals
.
filePath
=
filePath
;
return
(
lastHTMLGlobals
.
globals
=
globals
)
;
}
getESLintGlobalParser
(
context
)
{
let
globalScope
;
let
parser
=
{
Program
(
node
)
{
globalScope
=
context
.
getScope
(
)
;
}
}
;
let
filename
=
context
.
getFilename
(
)
;
let
extraHTMLGlobals
=
[
]
;
if
(
filename
.
endsWith
(
"
.
html
"
)
|
|
filename
.
endsWith
(
"
.
xhtml
"
)
)
{
extraHTMLGlobals
=
module
.
exports
.
getImportedGlobalsForHTMLFile
(
filename
)
;
}
let
handler
=
new
GlobalsForNode
(
helpers
.
getAbsoluteFilePath
(
context
)
)
;
for
(
let
type
of
Object
.
keys
(
GlobalsForNode
.
prototype
)
)
{
parser
[
type
]
=
function
(
node
)
{
if
(
type
=
=
=
"
Program
"
)
{
globalScope
=
context
.
getScope
(
)
;
helpers
.
addGlobals
(
extraHTMLGlobals
globalScope
)
;
}
let
globals
=
handler
[
type
]
(
node
context
.
getAncestors
(
)
globalScope
)
;
helpers
.
addGlobals
(
globals
globalScope
node
.
type
!
=
=
"
Program
"
&
&
node
)
;
}
;
}
return
parser
;
}
}
;
