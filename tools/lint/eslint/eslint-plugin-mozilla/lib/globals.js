"
use
strict
"
;
const
path
=
require
(
"
path
"
)
;
const
fs
=
require
(
"
fs
"
)
;
const
helpers
=
require
(
"
.
/
helpers
"
)
;
const
escope
=
require
(
"
escope
"
)
;
const
estraverse
=
require
(
"
estraverse
"
)
;
function
parseBooleanConfig
(
string
comment
)
{
let
items
=
{
}
;
string
=
string
.
replace
(
/
\
s
*
:
\
s
*
/
g
"
:
"
)
;
string
=
string
.
replace
(
/
\
s
*
\
s
*
/
g
"
"
)
;
string
.
split
(
/
\
s
|
+
/
)
.
forEach
(
function
(
name
)
{
if
(
!
name
)
{
return
;
}
let
pos
=
name
.
indexOf
(
"
:
"
)
;
let
value
=
undefined
;
if
(
pos
!
=
=
-
1
)
{
value
=
name
.
substring
(
pos
+
1
name
.
length
)
;
name
=
name
.
substring
(
0
pos
)
;
}
items
[
name
]
=
{
value
:
(
value
=
=
=
"
true
"
)
comment
:
comment
}
;
}
)
;
return
items
;
}
const
globalCache
=
new
Map
(
)
;
function
GlobalsForNode
(
filePath
)
{
this
.
path
=
filePath
;
this
.
dirname
=
path
.
dirname
(
this
.
path
)
this
.
root
=
helpers
.
getRootDir
(
this
.
path
)
;
this
.
isWorker
=
helpers
.
getIsWorker
(
this
.
path
)
;
}
GlobalsForNode
.
prototype
=
{
Program
(
node
)
{
if
(
!
this
.
isWorker
)
{
return
[
]
;
}
return
[
{
name
:
"
importScripts
"
writable
:
false
}
{
name
:
"
FileReaderSync
"
writable
:
false
}
{
name
:
"
onmessage
"
writable
:
true
}
{
name
:
"
ctypes
"
writable
:
false
}
]
;
}
BlockComment
(
node
parents
)
{
let
value
=
node
.
value
.
trim
(
)
;
let
match
=
/
^
import
-
globals
-
from
\
s
+
(
.
+
)
/
.
exec
(
value
)
;
if
(
!
match
)
{
return
[
]
;
}
let
filePath
=
match
[
1
]
.
trim
(
)
;
if
(
!
path
.
isAbsolute
(
filePath
)
)
{
filePath
=
path
.
resolve
(
this
.
dirname
filePath
)
;
}
return
module
.
exports
.
getGlobalsForFile
(
filePath
)
;
}
ExpressionStatement
(
node
parents
)
{
let
isGlobal
=
helpers
.
getIsGlobalScope
(
parents
)
;
let
globals
=
helpers
.
convertExpressionToGlobals
(
node
isGlobal
this
.
root
)
;
globals
=
globals
.
map
(
name
=
>
{
return
{
name
writable
:
true
}
}
)
;
if
(
this
.
isWorker
)
{
let
workerDetails
=
helpers
.
convertWorkerExpressionToGlobals
(
node
isGlobal
this
.
root
this
.
dirname
)
;
globals
=
globals
.
concat
(
workerDetails
.
map
(
name
=
>
{
return
{
name
writable
:
true
}
;
}
)
)
;
}
return
globals
;
}
}
;
module
.
exports
=
{
getGlobalsForFile
(
path
)
{
if
(
globalCache
.
has
(
path
)
)
{
return
globalCache
.
get
(
path
)
;
}
let
content
=
fs
.
readFileSync
(
path
"
utf8
"
)
;
let
ast
=
helpers
.
getAST
(
content
)
;
let
scopeManager
=
escope
.
analyze
(
ast
)
;
let
globalScope
=
scopeManager
.
acquire
(
ast
)
;
let
globals
=
Object
.
keys
(
globalScope
.
variables
)
.
map
(
v
=
>
(
{
name
:
globalScope
.
variables
[
v
]
.
name
writable
:
true
}
)
)
;
let
handler
=
new
GlobalsForNode
(
path
)
;
helpers
.
walkAST
(
ast
(
type
node
parents
)
=
>
{
if
(
type
=
=
"
BlockComment
"
)
{
let
value
=
node
.
value
.
trim
(
)
;
value
=
value
.
replace
(
/
\
n
/
g
'
'
)
;
let
match
=
/
^
globals
?
\
s
+
(
.
+
)
/
.
exec
(
value
)
;
if
(
match
)
{
let
values
=
parseBooleanConfig
(
match
[
1
]
.
trim
(
)
node
)
;
for
(
let
name
of
Object
.
keys
(
values
)
)
{
globals
.
push
(
{
name
writable
:
values
[
name
]
.
value
}
)
}
}
}
if
(
type
in
handler
)
{
let
newGlobals
=
handler
[
type
]
(
node
parents
)
;
globals
.
push
.
apply
(
globals
newGlobals
)
;
}
}
)
;
globalCache
.
set
(
path
globals
)
;
return
globals
;
}
getESLintGlobalParser
(
context
)
{
let
globalScope
;
let
parser
=
{
Program
(
node
)
{
globalScope
=
context
.
getScope
(
)
;
}
}
;
let
handler
=
new
GlobalsForNode
(
helpers
.
getAbsoluteFilePath
(
context
)
)
;
for
(
let
type
of
Object
.
keys
(
GlobalsForNode
.
prototype
)
)
{
parser
[
type
]
=
function
(
node
)
{
if
(
type
=
=
=
"
Program
"
)
{
globalScope
=
context
.
getScope
(
)
;
}
let
globals
=
handler
[
type
]
(
node
context
.
getAncestors
(
)
)
;
helpers
.
addGlobals
(
globals
globalScope
)
;
}
}
return
parser
;
}
}
;
