"
use
strict
"
;
const
fs
=
require
(
"
fs
"
)
;
const
{
maybeGetMemberPropertyName
}
=
require
(
"
.
.
/
helpers
"
)
;
const
privilegedGlobals
=
Object
.
keys
(
require
(
"
.
.
/
environments
/
privileged
.
js
"
)
.
globals
)
;
function
refersToEnvironmentGlobals
(
currentScope
id
)
{
const
reference
=
currentScope
.
references
.
find
(
ref
=
>
ref
.
identifier
=
=
=
id
)
;
const
{
resolved
}
=
reference
|
|
{
}
;
if
(
!
resolved
)
{
return
false
;
}
return
resolved
.
scope
.
type
=
=
=
"
global
"
&
&
resolved
.
defs
.
length
=
=
=
0
;
}
function
pointsToDOMInterface
(
currentScope
node
)
{
if
(
node
.
type
=
=
=
"
MemberExpression
"
)
{
const
objectName
=
maybeGetMemberPropertyName
(
node
.
object
)
;
if
(
objectName
=
=
=
"
lazy
"
)
{
return
false
;
}
if
(
objectName
=
=
=
"
OS
"
&
&
node
.
property
.
name
=
=
=
"
File
"
)
{
return
false
;
}
return
privilegedGlobals
.
includes
(
node
.
property
.
name
)
;
}
if
(
node
.
type
=
=
=
"
Identifier
"
&
&
refersToEnvironmentGlobals
(
currentScope
node
)
)
{
return
privilegedGlobals
.
includes
(
node
.
name
)
;
}
return
false
;
}
function
isChromeContext
(
context
)
{
const
filename
=
context
.
getFilename
(
)
;
const
isChromeFileName
=
filename
.
endsWith
(
"
.
sys
.
mjs
"
)
|
|
filename
.
endsWith
(
"
.
jsm
"
)
|
|
filename
.
endsWith
(
"
.
jsm
.
js
"
)
;
if
(
isChromeFileName
)
{
return
true
;
}
if
(
filename
.
endsWith
(
"
.
xhtml
"
)
)
{
return
fs
.
readFileSync
(
filename
)
.
includes
(
"
there
.
is
.
only
.
xul
"
)
;
}
const
source
=
context
.
getSourceCode
(
)
.
text
;
return
!
!
source
.
match
(
/
(
^
|
\
s
)
ChromeUtils
|
BrowserTestUtils
|
PlacesUtils
|
createXULElement
|
lazyRequireGetter
|
(
^
|
\
s
)
Services
\
.
|
evalInSandbox
/
)
;
}
module
.
exports
=
{
meta
:
{
docs
:
{
url
:
"
https
:
/
/
firefox
-
source
-
docs
.
mozilla
.
org
/
code
-
quality
/
lint
/
linters
/
eslint
-
plugin
-
mozilla
/
use
-
isInstance
.
html
"
}
fixable
:
"
code
"
schema
:
[
]
type
:
"
problem
"
}
create
(
context
)
{
if
(
!
isChromeContext
(
context
)
)
{
return
{
}
;
}
return
{
BinaryExpression
(
node
)
{
const
{
operator
right
}
=
node
;
if
(
operator
=
=
=
"
instanceof
"
&
&
pointsToDOMInterface
(
context
.
getScope
(
)
right
)
)
{
context
.
report
(
{
node
message
:
"
Please
prefer
.
isInstance
(
)
in
chrome
scripts
over
the
standard
instanceof
operator
for
DOM
interfaces
"
+
"
since
the
latter
will
return
false
when
the
object
is
created
from
a
different
context
.
"
fix
(
fixer
)
{
const
sourceCode
=
context
.
getSourceCode
(
)
;
return
fixer
.
replaceText
(
node
{
sourceCode
.
getText
(
right
)
}
.
isInstance
(
{
sourceCode
.
getText
(
node
.
left
)
}
)
)
;
}
}
)
;
}
}
}
;
}
}
;
