"
use
strict
"
;
function
markArrayElementsAsUsed
(
context
node
expression
)
{
if
(
expression
.
type
!
=
"
ArrayExpression
"
)
{
context
.
report
(
{
node
messageId
:
"
nonArrayAssignedToImported
"
}
)
;
return
;
}
for
(
let
element
of
expression
.
elements
)
{
context
.
markVariableAsUsed
?
context
.
markVariableAsUsed
(
element
.
value
)
:
context
.
sourceCode
.
markVariableAsUsed
(
element
.
value
)
;
}
context
.
markVariableAsUsed
?
context
.
markVariableAsUsed
(
"
EXPORTED_SYMBOLS
"
)
:
context
.
sourceCode
.
markVariableAsUsed
(
"
EXPORTED_SYMBOLS
"
)
;
}
function
isGlobalScope
(
context
node
)
{
if
(
context
.
sourceCode
?
.
getScope
)
{
let
upper
=
context
.
sourceCode
.
getScope
(
node
)
.
upper
;
return
!
upper
|
|
upper
.
type
=
=
"
global
"
;
}
return
!
context
.
getScope
(
)
.
upper
;
}
module
.
exports
=
{
meta
:
{
docs
:
{
url
:
"
https
:
/
/
firefox
-
source
-
docs
.
mozilla
.
org
/
code
-
quality
/
lint
/
linters
/
eslint
-
plugin
-
mozilla
/
rules
/
mark
-
exported
-
symbols
-
as
-
used
.
html
"
}
messages
:
{
useLetForExported
:
"
EXPORTED_SYMBOLS
cannot
be
declared
via
let
.
Use
var
or
this
.
EXPORTED_SYMBOLS
=
"
nonArrayAssignedToImported
:
"
Unexpected
assignment
of
non
-
Array
to
EXPORTED_SYMBOLS
"
}
schema
:
[
]
type
:
"
problem
"
}
create
(
context
)
{
return
{
AssignmentExpression
(
node
)
{
if
(
node
.
operator
=
=
=
"
=
"
&
&
node
.
left
.
type
=
=
=
"
MemberExpression
"
&
&
node
.
left
.
object
.
type
=
=
=
"
ThisExpression
"
&
&
node
.
left
.
property
.
name
=
=
=
"
EXPORTED_SYMBOLS
"
&
&
isGlobalScope
(
context
node
)
)
{
markArrayElementsAsUsed
(
context
node
node
.
right
)
;
}
}
VariableDeclaration
(
node
)
{
if
(
!
isGlobalScope
(
context
node
)
)
{
return
;
}
for
(
let
item
of
node
.
declarations
)
{
if
(
item
.
id
&
&
item
.
id
.
type
=
=
"
Identifier
"
&
&
item
.
id
.
name
=
=
=
"
EXPORTED_SYMBOLS
"
)
{
if
(
node
.
kind
=
=
=
"
let
"
)
{
context
.
report
(
{
node
messageId
:
"
useLetForExported
"
}
)
;
}
markArrayElementsAsUsed
(
context
node
item
.
init
)
;
}
}
}
}
;
}
}
;
