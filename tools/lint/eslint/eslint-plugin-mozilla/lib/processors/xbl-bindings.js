"
use
strict
"
;
const
NS_XBL
=
"
http
:
/
/
www
.
mozilla
.
org
/
xbl
"
;
let
XMLParser
=
require
(
"
.
/
processor
-
helpers
"
)
.
XMLParser
;
let
xmlParseError
=
null
;
let
scriptLines
=
[
]
;
let
lineMap
=
[
]
;
function
addSyntheticLine
(
line
linePos
addDisableLine
)
{
lineMap
[
scriptLines
.
length
]
=
{
line
:
linePos
offset
:
null
}
;
scriptLines
.
push
(
line
+
(
addDisableLine
?
"
"
:
"
/
/
eslint
-
disable
-
line
"
)
)
;
}
function
addNodeLines
(
node
reindent
)
{
let
lines
=
node
.
textContent
.
split
(
"
\
n
"
)
;
let
startLine
=
node
.
textLine
;
let
startColumn
=
node
.
textColumn
;
let
indentFirst
=
false
;
while
(
lines
.
length
&
&
lines
[
0
]
.
trim
(
)
=
=
"
"
)
{
indentFirst
=
true
;
startLine
+
+
;
lines
.
shift
(
)
;
}
let
lastIndent
=
0
;
if
(
lines
.
length
&
&
lines
[
lines
.
length
-
1
]
.
trim
(
)
=
=
"
"
)
{
lastIndent
=
lines
[
lines
.
length
-
1
]
.
length
;
}
if
(
lines
.
length
>
2
&
&
lines
[
lines
.
length
-
2
]
.
trim
(
)
=
=
"
"
&
&
lines
[
lines
.
length
-
2
]
.
length
>
lastIndent
)
{
lastIndent
=
lines
[
lines
.
length
-
2
]
.
length
;
}
while
(
lines
.
length
&
&
lines
[
lines
.
length
-
1
]
.
trim
(
)
=
=
"
"
)
{
lines
.
pop
(
)
;
}
if
(
!
indentFirst
)
{
let
firstLine
=
lines
.
shift
(
)
;
lineMap
[
scriptLines
.
length
]
=
{
line
:
startLine
offset
:
startColumn
-
1
}
;
scriptLines
.
push
(
firstLine
)
;
startLine
+
+
;
}
let
indents
=
lines
.
filter
(
s
=
>
s
.
trim
(
)
.
length
>
0
)
.
map
(
s
=
>
s
.
length
-
s
.
trimLeft
(
)
.
length
)
;
let
minIndent
=
Math
.
min
.
apply
(
null
indents
)
;
let
indent
=
Math
.
max
(
2
minIndent
-
lastIndent
)
;
for
(
let
line
of
lines
)
{
if
(
line
.
trim
(
)
.
length
=
=
0
)
{
lineMap
[
scriptLines
.
length
]
=
{
line
:
startLine
offset
:
0
}
;
}
else
{
line
=
"
"
.
repeat
(
indent
)
+
line
.
substring
(
minIndent
)
;
lineMap
[
scriptLines
.
length
]
=
{
line
:
startLine
offset
:
1
+
indent
-
minIndent
}
;
}
scriptLines
.
push
(
line
)
;
startLine
+
+
;
}
}
module
.
exports
=
{
preprocess
(
text
filename
)
{
xmlParseError
=
null
;
scriptLines
=
[
]
;
lineMap
=
[
]
;
let
xp
=
new
XMLParser
(
text
)
;
if
(
xp
.
lastError
)
{
xmlParseError
=
xp
.
lastError
;
}
let
document
=
xp
.
document
;
if
(
document
.
children
.
length
!
=
1
)
{
return
[
]
;
}
let
bindings
=
document
.
children
[
0
]
;
if
(
bindings
.
local
!
=
"
bindings
"
|
|
bindings
.
namespace
!
=
NS_XBL
)
{
return
[
]
;
}
for
(
let
comment
of
document
.
comments
)
{
addSyntheticLine
(
/
*
0
true
)
;
for
(
let
line
of
comment
.
split
(
"
\
n
"
)
)
{
addSyntheticLine
(
{
line
.
trim
(
)
}
0
true
)
;
}
addSyntheticLine
(
*
/
0
true
)
;
}
addSyntheticLine
(
this
.
bindings
=
{
bindings
.
textLine
)
;
for
(
let
binding
of
bindings
.
children
)
{
if
(
binding
.
local
!
=
"
binding
"
|
|
binding
.
namespace
!
=
NS_XBL
)
{
continue
;
}
addSyntheticLine
(
"
{
binding
.
attributes
.
id
}
"
:
{
binding
.
textLine
)
;
for
(
let
part
of
binding
.
children
)
{
if
(
part
.
namespace
!
=
NS_XBL
)
{
continue
;
}
if
(
part
.
local
=
=
"
implementation
"
)
{
addSyntheticLine
(
implementation
:
{
part
.
textLine
)
;
}
else
if
(
part
.
local
=
=
"
handlers
"
)
{
addSyntheticLine
(
handlers
:
[
part
.
textLine
)
;
}
else
{
continue
;
}
for
(
let
item
of
part
.
children
)
{
if
(
item
.
namespace
!
=
NS_XBL
)
{
continue
;
}
switch
(
item
.
local
)
{
case
"
field
"
:
{
if
(
item
.
textContent
.
trim
(
)
.
length
=
=
0
)
{
continue
;
}
addSyntheticLine
(
get
{
item
.
attributes
.
name
}
(
)
{
item
.
textLine
)
;
addSyntheticLine
(
return
(
item
.
textLine
)
;
item
.
textContent
=
item
.
textContent
.
replace
(
/
;
(
?
=
\
s
*
)
/
"
"
)
;
addNodeLines
(
item
5
)
;
addSyntheticLine
(
)
;
item
.
textLine
)
;
addSyntheticLine
(
}
item
.
textEndLine
)
;
break
;
}
case
"
constructor
"
:
case
"
destructor
"
:
{
addSyntheticLine
(
{
item
.
local
}
(
)
{
item
.
textLine
)
;
addNodeLines
(
item
4
)
;
addSyntheticLine
(
}
item
.
textEndLine
)
;
break
;
}
case
"
method
"
:
{
let
params
=
item
.
children
.
filter
(
n
=
>
{
return
n
.
local
=
=
"
parameter
"
&
&
n
.
namespace
=
=
NS_XBL
;
}
)
.
map
(
n
=
>
n
.
attributes
.
name
)
.
join
(
"
"
)
;
let
body
=
item
.
children
.
filter
(
n
=
>
{
return
n
.
local
=
=
"
body
"
&
&
n
.
namespace
=
=
NS_XBL
;
}
)
[
0
]
;
addSyntheticLine
(
{
item
.
attributes
.
name
}
(
{
params
}
)
{
item
.
textLine
)
;
addNodeLines
(
body
4
)
;
addSyntheticLine
(
}
item
.
textEndLine
)
;
break
;
}
case
"
property
"
:
{
for
(
let
propdef
of
item
.
children
)
{
if
(
propdef
.
namespace
!
=
NS_XBL
)
{
continue
;
}
if
(
propdef
.
local
=
=
"
setter
"
)
{
addSyntheticLine
(
set
{
item
.
attributes
.
name
}
(
val
)
{
propdef
.
textLine
)
;
}
else
if
(
propdef
.
local
=
=
"
getter
"
)
{
addSyntheticLine
(
get
{
item
.
attributes
.
name
}
(
)
{
propdef
.
textLine
)
;
}
else
{
continue
;
}
addNodeLines
(
propdef
4
)
;
addSyntheticLine
(
}
propdef
.
textEndLine
)
;
}
break
;
}
case
"
handler
"
:
{
addSyntheticLine
(
function
(
event
)
{
item
.
textLine
)
;
addNodeLines
(
item
4
)
;
addSyntheticLine
(
}
item
.
textEndLine
)
;
break
;
}
default
:
continue
;
}
}
addSyntheticLine
(
(
part
.
local
=
=
"
implementation
"
?
}
:
]
)
part
.
textEndLine
)
;
}
addSyntheticLine
(
}
binding
.
textEndLine
)
;
}
addSyntheticLine
(
}
;
bindings
.
textEndLine
)
;
let
script
=
scriptLines
.
join
(
"
\
n
"
)
+
"
\
n
"
;
return
[
script
]
;
}
postprocess
(
messages
filename
)
{
if
(
xmlParseError
)
{
return
[
xmlParseError
]
;
}
let
errors
=
[
]
;
for
(
let
i
=
0
;
i
<
messages
.
length
;
i
+
+
)
{
for
(
let
message
of
messages
[
i
]
)
{
let
mapped
=
lineMap
[
message
.
line
-
1
]
;
message
.
line
=
mapped
.
line
+
1
;
if
(
mapped
.
offset
)
{
message
.
column
-
=
mapped
.
offset
;
}
else
{
message
.
column
=
NaN
;
}
errors
.
push
(
message
)
;
}
}
return
errors
;
}
}
;
