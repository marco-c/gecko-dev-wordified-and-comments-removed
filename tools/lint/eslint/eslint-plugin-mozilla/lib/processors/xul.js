"
use
strict
"
;
let
path
=
require
(
"
path
"
)
;
let
fs
=
require
(
"
fs
"
)
;
let
XMLParser
=
require
(
"
.
/
processor
-
helpers
"
)
.
XMLParser
;
let
xmlParseError
=
null
;
let
scriptLines
=
[
]
;
let
lineMap
=
[
]
;
let
includedRanges
=
[
]
;
const
kIfdefStateForLinting
=
{
MOZ_UPDATER
:
true
XP_WIN
:
true
MOZ_BUILD_APP_IS_BROWSER
:
true
MOZ_SERVICES_SYNC
:
true
MOZ_DATA_REPORTING
:
true
MOZ_TELEMETRY_REPORTING
:
true
MOZ_CRASHREPORTER
:
true
MOZ_MAINTENANCE_SERVICE
:
true
HAVE_SHELL_SERVICE
:
true
MENUBAR_CAN_AUTOHIDE
:
true
MOZILLA_OFFICIAL
:
true
}
;
function
dealWithIfdefs
(
text
filename
)
{
function
stripIfdefsFromLines
(
input
innerFile
)
{
let
outputLines
=
[
]
;
let
inSkippingIfdef
=
[
false
]
;
for
(
let
i
=
0
;
i
<
input
.
length
;
i
+
+
)
{
let
line
=
input
[
i
]
;
let
shouldSkip
=
inSkippingIfdef
.
some
(
x
=
>
x
)
;
if
(
!
line
.
startsWith
(
"
#
"
)
)
{
outputLines
.
push
(
shouldSkip
?
"
"
:
line
)
;
}
else
{
if
(
line
.
startsWith
(
"
#
"
)
|
|
line
.
startsWith
(
"
#
filter
"
)
|
|
line
=
=
"
#
"
|
|
line
.
startsWith
(
"
#
define
"
)
)
{
outputLines
.
push
(
"
"
)
;
continue
;
}
let
term
=
"
"
;
let
negate
=
false
;
if
(
line
.
startsWith
(
"
#
ifdef
"
)
)
{
term
=
line
.
match
(
/
^
#
ifdef
*
(
[
A
-
Z_
]
+
)
/
)
;
}
else
if
(
line
.
startsWith
(
"
#
ifndef
"
)
)
{
term
=
line
.
match
(
/
^
#
ifndef
*
(
[
A
-
Z_
]
+
)
/
)
;
negate
=
true
;
}
else
if
(
line
.
startsWith
(
"
#
if
"
)
)
{
term
=
line
.
match
(
/
^
defined
\
(
(
[
A
-
Z_
]
+
)
\
)
/
)
;
}
else
if
(
line
.
startsWith
(
"
#
elifdef
"
)
)
{
inSkippingIfdef
.
pop
(
)
;
term
=
line
.
match
(
/
^
#
elifdef
*
(
[
A
-
Z_
]
+
)
/
)
;
}
else
if
(
line
.
startsWith
(
"
#
else
"
)
)
{
let
old
=
inSkippingIfdef
.
pop
(
)
;
inSkippingIfdef
.
push
(
!
old
)
;
outputLines
.
push
(
"
"
)
;
}
else
if
(
line
.
startsWith
(
"
#
endif
"
)
)
{
inSkippingIfdef
.
pop
(
)
;
outputLines
.
push
(
"
"
)
;
}
else
if
(
line
.
startsWith
(
"
#
expand
"
)
)
{
outputLines
.
push
(
line
.
substring
(
"
#
expand
"
.
length
)
)
;
}
else
if
(
line
.
startsWith
(
"
#
include
"
)
)
{
if
(
!
shouldSkip
)
{
let
fileToInclude
=
line
.
substr
(
"
#
include
"
.
length
)
.
trim
(
)
;
let
subpath
=
path
.
join
(
path
.
dirname
(
innerFile
)
fileToInclude
)
;
let
contents
=
fs
.
readFileSync
(
subpath
{
encoding
:
"
utf
-
8
"
}
)
;
contents
=
contents
.
split
(
/
\
n
/
)
;
contents
=
stripIfdefsFromLines
(
contents
subpath
)
;
if
(
innerFile
=
=
filename
)
{
includedRanges
.
push
(
{
start
:
i
end
:
i
+
contents
.
length
filename
:
subpath
}
)
;
}
input
=
input
.
slice
(
0
i
)
.
concat
(
contents
input
.
slice
(
i
+
1
)
)
;
i
-
-
;
}
else
{
outputLines
.
push
(
"
"
)
;
}
}
else
{
throw
new
Error
(
"
Unknown
preprocessor
directive
:
"
+
line
)
;
}
if
(
term
)
{
term
=
term
&
&
term
[
1
]
;
if
(
!
negate
)
{
inSkippingIfdef
.
push
(
!
kIfdefStateForLinting
[
term
]
)
;
}
else
{
inSkippingIfdef
.
push
(
kIfdefStateForLinting
[
term
]
)
;
}
outputLines
.
push
(
"
"
)
;
}
}
}
return
outputLines
;
}
let
lines
=
text
.
split
(
/
\
n
/
)
;
return
stripIfdefsFromLines
(
lines
filename
)
.
join
(
"
\
n
"
)
;
}
function
addSyntheticLine
(
line
linePos
addDisableLine
)
{
lineMap
[
scriptLines
.
length
]
=
{
line
:
linePos
}
;
scriptLines
.
push
(
line
+
(
addDisableLine
?
"
"
:
"
/
/
eslint
-
disable
-
line
"
)
)
;
}
function
recursiveExpand
(
node
)
{
for
(
let
[
attr
value
]
of
Object
.
entries
(
node
.
attributes
)
)
{
if
(
attr
.
startsWith
(
"
on
"
)
)
{
if
(
attr
=
=
"
oncommand
"
&
&
value
=
=
"
;
"
)
{
continue
;
}
let
nodeDesc
=
node
.
local
.
replace
(
/
-
/
g
"
"
)
;
if
(
node
.
attributes
.
id
)
{
nodeDesc
+
=
"
_
"
+
node
.
attributes
.
id
.
replace
(
/
[
^
a
-
z
]
/
gi
"
_
"
)
;
}
if
(
node
.
attributes
.
class
)
{
nodeDesc
+
=
"
_
"
+
node
.
attributes
.
class
.
replace
(
/
[
^
a
-
z
]
/
gi
"
_
"
)
;
}
addSyntheticLine
(
"
function
"
+
nodeDesc
+
"
(
event
)
{
"
node
.
textLine
)
;
let
processedLines
=
value
.
split
(
/
\
r
?
\
n
/
)
;
let
addlLine
=
0
;
for
(
let
line
of
processedLines
)
{
line
=
line
.
replace
(
/
^
\
s
*
/
"
"
)
;
lineMap
[
scriptLines
.
length
]
=
{
line
:
node
.
textLine
+
addlLine
}
;
scriptLines
.
push
(
line
)
;
addlLine
+
+
;
}
addSyntheticLine
(
"
}
"
node
.
textLine
+
processedLines
.
length
-
1
)
;
}
}
for
(
let
kid
of
node
.
children
)
{
recursiveExpand
(
kid
)
;
}
}
module
.
exports
=
{
preprocess
(
text
filename
)
{
if
(
filename
.
includes
(
"
.
inc
"
)
)
{
return
[
]
;
}
xmlParseError
=
null
;
scriptLines
=
[
"
/
*
eslint
-
disable
indent
*
/
"
"
/
*
eslint
-
disable
indent
-
legacy
*
/
"
"
/
*
eslint
-
disable
semi
*
/
"
"
/
*
eslint
-
disable
quotes
*
/
"
"
/
*
eslint
-
disable
no
-
undef
*
/
"
]
;
lineMap
=
scriptLines
.
map
(
(
)
=
>
(
{
line
:
0
}
)
)
;
includedRanges
=
[
]
;
text
=
dealWithIfdefs
(
text
filename
)
;
let
xp
=
new
XMLParser
(
text
)
;
if
(
xp
.
lastError
)
{
xmlParseError
=
xp
.
lastError
;
}
let
doc
=
xp
.
document
;
if
(
!
doc
)
{
return
[
]
;
}
let
node
=
doc
;
for
(
let
kid
of
node
.
children
)
{
recursiveExpand
(
kid
)
;
}
let
scriptText
=
scriptLines
.
join
(
"
\
n
"
)
+
"
\
n
"
;
return
[
scriptText
]
;
}
postprocess
(
messages
filename
)
{
if
(
xmlParseError
)
{
return
[
xmlParseError
]
;
}
let
errors
=
[
]
;
for
(
let
i
=
0
;
i
<
messages
.
length
;
i
+
+
)
{
for
(
let
message
of
messages
[
i
]
)
{
let
mapped
=
lineMap
[
message
.
line
-
1
]
;
let
target
=
mapped
.
line
;
let
includedRange
=
includedRanges
.
find
(
r
=
>
target
>
=
r
.
start
&
&
target
<
=
r
.
end
)
;
if
(
includedRange
)
{
target
=
includedRange
.
start
;
message
.
message
+
=
"
(
from
included
file
"
+
path
.
basename
(
includedRange
.
filename
)
+
"
)
"
;
}
let
includeBallooning
=
includedRanges
.
filter
(
r
=
>
target
>
=
r
.
end
)
.
map
(
r
=
>
r
.
end
-
r
.
start
)
.
reduce
(
(
acc
next
)
=
>
acc
+
next
0
)
;
target
-
=
includeBallooning
;
message
.
line
=
target
+
1
;
message
.
column
=
NaN
;
errors
.
push
(
message
)
;
}
}
return
errors
;
}
}
;
