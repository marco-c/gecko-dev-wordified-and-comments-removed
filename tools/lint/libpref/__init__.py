from
__future__
import
absolute_import
print_function
import
os
import
re
import
sys
import
yaml
from
mozlint
import
result
from
mozlint
.
pathutils
import
expand_exclusions
IGNORE_PREFS
=
{
    
'
devtools
.
console
.
stdout
.
chrome
'
    
'
devtools
.
console
.
stdout
.
content
'
    
'
fission
.
autostart
'
    
'
browser
.
dom
.
window
.
dump
.
enabled
'
    
'
apz
.
fling_curve_function_y2
'
    
'
dom
.
postMessage
.
sharedArrayBuffer
.
bypassCOOP_COEP
.
insecure
.
enabled
'
}
PATTERN
=
re
.
compile
(
r
'
\
s
*
pref
\
(
\
s
*
\
"
(
?
P
<
pref
>
.
+
)
\
"
\
s
*
\
s
*
(
?
P
<
val
>
.
+
)
\
)
\
s
*
;
.
*
'
)
def
get_names
(
pref_list_filename
)
:
    
pref_names
=
set
(
)
    
file
=
open
(
pref_list_filename
)
.
read
(
)
.
replace
(
'
'
'
'
)
    
try
:
        
pref_list
=
yaml
.
safe_load
(
file
)
    
except
(
IOError
ValueError
)
as
e
:
        
print
(
'
{
}
:
error
:
\
n
{
}
'
              
.
format
(
pref_list_filename
e
)
file
=
sys
.
stderr
)
        
sys
.
exit
(
1
)
    
for
pref
in
pref_list
:
        
if
pref
[
'
name
'
]
not
in
IGNORE_PREFS
:
            
pref_names
.
add
(
pref
[
'
name
'
]
)
    
return
pref_names
def
check_against
(
path
pref_names
)
:
    
errors
=
[
]
    
prefs
=
read_prefs
(
path
)
    
for
pref
in
prefs
:
        
if
pref
[
'
name
'
]
in
pref_names
:
            
errors
.
append
(
{
                
'
path
'
:
path
                
'
message
'
:
pref
[
'
raw
'
]
                
'
lineno
'
:
pref
[
'
line
'
]
                
'
hint
'
:
'
Remove
the
duplicate
pref
or
add
it
to
IGNORE_PREFS
.
'
                
'
level
'
:
'
error
'
            
}
)
    
return
errors
def
read_prefs
(
path
)
:
    
prefs
=
[
]
    
with
open
(
path
)
as
source
:
        
for
lineno
line
in
enumerate
(
source
start
=
1
)
:
            
match
=
PATTERN
.
match
(
line
)
            
if
match
:
                
prefs
.
append
(
{
                    
'
name
'
:
match
.
group
(
'
pref
'
)
                    
'
value
'
:
match
.
group
(
'
val
'
)
                    
'
line
'
:
lineno
                    
'
raw
'
:
line
                
}
)
    
return
prefs
def
checkdupes
(
paths
config
*
*
kwargs
)
:
    
results
=
[
]
    
errors
=
[
]
    
topdir
=
os
.
path
.
join
(
kwargs
[
'
root
'
]
"
modules
"
"
libpref
"
"
init
"
)
    
pref_names
=
get_names
(
os
.
path
.
join
(
topdir
"
StaticPrefList
.
yaml
"
)
)
    
files
=
list
(
expand_exclusions
(
paths
config
kwargs
[
'
root
'
]
)
)
    
for
file
in
files
:
        
errors
.
extend
(
check_against
(
file
pref_names
)
)
    
for
error
in
errors
:
        
results
.
append
(
result
.
from_config
(
config
*
*
error
)
)
    
return
results
