#
ifndef
PerfStats_h
#
define
PerfStats_h
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
<
memory
>
#
include
<
string
>
#
include
<
limits
>
#
define
FOR_EACH_PERFSTATS_METRIC
(
MACRO
)
\
MACRO
(
DisplayListBuilding
)
\
MACRO
(
Rasterizing
)
\
MACRO
(
WrDisplayListBuilding
)
\
MACRO
(
LayerTransactions
)
\
MACRO
(
Compositing
)
\
MACRO
(
Reflowing
)
\
MACRO
(
Styling
)
\
MACRO
(
HttpChannelCompletion
)
\
MACRO
(
HttpChannelCompletion_Network
)
\
MACRO
(
HttpChannelCompletion_Cache
)
\
MACRO
(
HttpChannelAsyncOpenToTransactionPending
)
\
MACRO
(
HttpChannelResponseStartParentToContent
)
\
MACRO
(
HttpChannelResponseEndParentToContent
)
\
MACRO
(
JSBC_Compression
)
\
MACRO
(
JSBC_Decompression
)
\
MACRO
(
JSBC_IO_Read
)
\
MACRO
(
JSBC_IO_Write
)
\
MACRO
(
MinorGC
)
\
MACRO
(
MajorGC
)
\
MACRO
(
NonIdleMajorGC
)
namespace
mozilla
{
namespace
dom
{
class
ContentParent
;
}
class
PerfStats
{
public
:
typedef
MozPromise
<
nsCString
bool
true
>
PerfStatsPromise
;
enum
class
Metric
:
uint32_t
{
#
define
DECLARE_ENUM
(
metric
)
metric
FOR_EACH_PERFSTATS_METRIC
(
DECLARE_ENUM
)
#
undef
DECLARE_ENUM
Max
}
;
using
MetricMask
=
uint64_t
;
static
void
RecordMeasurementStart
(
Metric
aMetric
)
{
if
(
!
(
sCollectionMask
&
(
1
<
<
static_cast
<
uint64_t
>
(
aMetric
)
)
)
)
{
return
;
}
RecordMeasurementStartInternal
(
aMetric
)
;
}
static
void
RecordMeasurementEnd
(
Metric
aMetric
)
{
if
(
!
(
sCollectionMask
&
(
1
<
<
static_cast
<
uint64_t
>
(
aMetric
)
)
)
)
{
return
;
}
RecordMeasurementEndInternal
(
aMetric
)
;
}
static
void
RecordMeasurement
(
Metric
aMetric
TimeDuration
aDuration
)
{
if
(
!
(
sCollectionMask
&
(
1
<
<
static_cast
<
uint64_t
>
(
aMetric
)
)
)
)
{
return
;
}
RecordMeasurementInternal
(
aMetric
aDuration
)
;
}
static
void
RecordMeasurementCounter
(
Metric
aMetric
uint64_t
aIncrementAmount
)
{
if
(
!
(
sCollectionMask
&
(
1
<
<
static_cast
<
uint64_t
>
(
aMetric
)
)
)
)
{
return
;
}
RecordMeasurementCounterInternal
(
aMetric
aIncrementAmount
)
;
}
template
<
Metric
N
>
class
AutoMetricRecording
{
public
:
AutoMetricRecording
(
)
{
PerfStats
:
:
RecordMeasurementStart
(
N
)
;
}
~
AutoMetricRecording
(
)
{
PerfStats
:
:
RecordMeasurementEnd
(
N
)
;
}
}
;
static
void
SetCollectionMask
(
MetricMask
aMask
)
;
static
MetricMask
GetCollectionMask
(
)
;
static
RefPtr
<
PerfStatsPromise
>
CollectPerfStatsJSON
(
)
{
return
GetSingleton
(
)
-
>
CollectPerfStatsJSONInternal
(
)
;
}
static
nsCString
CollectLocalPerfStatsJSON
(
)
{
return
GetSingleton
(
)
-
>
CollectLocalPerfStatsJSONInternal
(
)
;
}
static
void
StorePerfStats
(
dom
:
:
ContentParent
*
aParent
const
nsACString
&
aPerfStats
)
{
GetSingleton
(
)
-
>
StorePerfStatsInternal
(
aParent
aPerfStats
)
;
}
private
:
static
PerfStats
*
GetSingleton
(
)
;
static
void
RecordMeasurementStartInternal
(
Metric
aMetric
)
;
static
void
RecordMeasurementEndInternal
(
Metric
aMetric
)
;
static
void
RecordMeasurementInternal
(
Metric
aMetric
TimeDuration
aDuration
)
;
static
void
RecordMeasurementCounterInternal
(
Metric
aMetric
uint64_t
aIncrementAmount
)
;
void
ResetCollection
(
)
;
void
StorePerfStatsInternal
(
dom
:
:
ContentParent
*
aParent
const
nsACString
&
aPerfStats
)
;
RefPtr
<
PerfStatsPromise
>
CollectPerfStatsJSONInternal
(
)
;
nsCString
CollectLocalPerfStatsJSONInternal
(
)
;
static
MetricMask
sCollectionMask
;
static
StaticMutex
sMutex
MOZ_UNANNOTATED
;
static
StaticAutoPtr
<
PerfStats
>
sSingleton
;
TimeStamp
mRecordedStarts
[
static_cast
<
size_t
>
(
Metric
:
:
Max
)
]
;
double
mRecordedTimes
[
static_cast
<
size_t
>
(
Metric
:
:
Max
)
]
;
uint32_t
mRecordedCounts
[
static_cast
<
size_t
>
(
Metric
:
:
Max
)
]
;
nsTArray
<
nsCString
>
mStoredPerfStats
;
}
;
static_assert
(
1
<
<
(
static_cast
<
uint64_t
>
(
PerfStats
:
:
Metric
:
:
Max
)
-
1
)
<
=
std
:
:
numeric_limits
<
PerfStats
:
:
MetricMask
>
:
:
max
(
)
"
More
metrics
than
can
fit
into
sCollectionMask
bitmask
"
)
;
}
#
endif
