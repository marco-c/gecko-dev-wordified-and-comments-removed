#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
limits
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
common
/
scoped_ptr
.
h
"
#
include
"
common
/
using_std_string
.
h
"
#
include
"
google_breakpad
/
processor
/
basic_source_line_resolver
.
h
"
#
include
"
google_breakpad
/
processor
/
minidump
.
h
"
#
include
"
google_breakpad
/
processor
/
minidump_processor
.
h
"
#
include
"
google_breakpad
/
processor
/
process_state
.
h
"
#
include
"
processor
/
logging
.
h
"
#
include
"
processor
/
simple_symbol_supplier
.
h
"
#
include
"
processor
/
stackwalk_common
.
h
"
#
include
"
http_symbol_supplier
.
h
"
#
ifdef
ERROR
#
undef
ERROR
#
endif
#
ifdef
SEVERITY_ERROR
#
undef
SEVERITY_ERROR
#
endif
namespace
{
using
breakpad_extra
:
:
HTTPSymbolSupplier
;
using
google_breakpad
:
:
BasicSourceLineResolver
;
using
google_breakpad
:
:
Minidump
;
using
google_breakpad
:
:
MinidumpMemoryList
;
using
google_breakpad
:
:
MinidumpProcessor
;
using
google_breakpad
:
:
MinidumpThreadList
;
using
google_breakpad
:
:
ProcessState
;
using
google_breakpad
:
:
scoped_ptr
;
using
google_breakpad
:
:
SimpleSymbolSupplier
;
bool
PrintMinidumpProcess
(
const
string
&
minidump_file
const
std
:
:
vector
<
string
>
&
symbol_args
bool
machine_readable
bool
output_stack_contents
)
{
std
:
:
vector
<
string
>
server_paths
;
std
:
:
vector
<
string
>
symbol_paths
;
for
(
std
:
:
vector
<
string
>
:
:
const_iterator
arg
=
symbol_args
.
begin
(
)
;
arg
<
symbol_args
.
end
(
)
;
+
+
arg
)
{
if
(
arg
-
>
substr
(
0
4
)
=
=
"
http
"
)
{
server_paths
.
push_back
(
*
arg
)
;
}
else
{
symbol_paths
.
push_back
(
*
arg
)
;
}
}
string
temp_path
;
#
ifdef
_WIN32
temp_path
.
resize
(
MAX_PATH
+
1
)
;
DWORD
length
=
GetTempPath
(
temp_path
.
length
(
)
&
temp_path
[
0
]
)
;
temp_path
.
resize
(
length
+
1
)
;
#
else
temp_path
=
"
/
tmp
"
;
#
endif
if
(
server_paths
.
empty
(
)
)
{
server_paths
.
push_back
(
"
http
:
/
/
s3
-
us
-
west
-
2
.
amazonaws
.
com
/
"
"
org
.
mozilla
.
crash
-
stats
.
symbols
-
public
/
v1
/
"
)
;
}
scoped_ptr
<
HTTPSymbolSupplier
>
symbol_supplier
;
string
symbols_cache
=
temp_path
;
if
(
!
symbol_paths
.
empty
(
)
)
{
symbols_cache
=
symbol_paths
[
0
]
;
symbol_paths
.
erase
(
symbol_paths
.
begin
(
)
)
;
}
symbol_supplier
.
reset
(
new
HTTPSymbolSupplier
(
server_paths
symbols_cache
symbol_paths
temp_path
)
)
;
BasicSourceLineResolver
resolver
;
MinidumpProcessor
minidump_processor
(
symbol_supplier
.
get
(
)
&
resolver
)
;
MinidumpThreadList
:
:
set_max_threads
(
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
;
MinidumpMemoryList
:
:
set_max_regions
(
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
)
;
Minidump
dump
(
minidump_file
)
;
if
(
!
dump
.
Read
(
)
)
{
BPLOG
(
ERROR
)
<
<
"
Minidump
"
<
<
dump
.
path
(
)
<
<
"
could
not
be
read
"
;
return
false
;
}
ProcessState
process_state
;
if
(
minidump_processor
.
Process
(
&
dump
&
process_state
)
!
=
google_breakpad
:
:
PROCESS_OK
)
{
BPLOG
(
ERROR
)
<
<
"
MinidumpProcessor
:
:
Process
failed
"
;
return
false
;
}
if
(
machine_readable
)
{
PrintProcessStateMachineReadable
(
process_state
)
;
}
else
{
PrintProcessState
(
process_state
output_stack_contents
&
resolver
)
;
}
return
true
;
}
void
usage
(
const
char
*
program_name
)
{
fprintf
(
stderr
"
usage
:
%
s
[
-
m
|
-
s
]
<
minidump
-
file
>
[
<
symbol
server
URL
>
|
"
"
<
symbol
-
path
>
]
+
\
n
"
"
-
m
:
Output
in
machine
-
readable
format
\
n
"
"
-
s
:
Output
stack
contents
\
n
"
program_name
)
;
}
}
int
main
(
int
argc
char
*
*
argv
)
{
BPLOG_INIT
(
&
argc
&
argv
)
;
if
(
argc
<
2
)
{
usage
(
argv
[
0
]
)
;
return
1
;
}
const
char
*
minidump_file
;
bool
machine_readable
=
false
;
bool
output_stack_contents
=
false
;
int
symbol_path_arg
;
if
(
strcmp
(
argv
[
1
]
"
-
m
"
)
=
=
0
)
{
if
(
argc
<
3
)
{
usage
(
argv
[
0
]
)
;
return
1
;
}
machine_readable
=
true
;
minidump_file
=
argv
[
2
]
;
symbol_path_arg
=
3
;
}
else
if
(
strcmp
(
argv
[
1
]
"
-
s
"
)
=
=
0
)
{
if
(
argc
<
3
)
{
usage
(
argv
[
0
]
)
;
return
1
;
}
output_stack_contents
=
true
;
minidump_file
=
argv
[
2
]
;
symbol_path_arg
=
3
;
}
else
{
minidump_file
=
argv
[
1
]
;
symbol_path_arg
=
2
;
}
std
:
:
vector
<
string
>
symbol_paths
;
if
(
argc
>
symbol_path_arg
)
{
for
(
int
argi
=
symbol_path_arg
;
argi
<
argc
;
+
+
argi
)
symbol_paths
.
push_back
(
argv
[
argi
]
)
;
}
return
PrintMinidumpProcess
(
minidump_file
symbol_paths
machine_readable
output_stack_contents
)
?
0
:
1
;
}
