r
'
'
'
Make
it
easy
to
install
and
run
[
browsertime
]
(
https
:
/
/
github
.
com
/
sitespeedio
/
browsertime
)
.
Browsertime
is
a
harness
for
running
performance
tests
similar
to
Mozilla
'
s
Raptor
testing
framework
.
Browsertime
is
written
in
Node
.
js
and
uses
Selenium
WebDriver
to
drive
multiple
browsers
including
Chrome
Chrome
for
Android
Firefox
and
(
pending
the
resolution
of
[
Bug
1525126
]
(
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
1525126
)
and
similar
tickets
)
Firefox
for
Android
and
GeckoView
-
based
vehicles
.
Right
now
a
custom
version
of
browsertime
and
the
underlying
geckodriver
binary
are
needed
to
support
GeckoView
-
based
vehicles
;
this
module
accommodates
those
in
-
progress
custom
versions
.
To
get
started
run
.
/
mach
browsertime
-
-
setup
[
-
-
clobber
]
This
will
populate
tools
/
browsertime
/
node_modules
.
To
invoke
browsertime
run
.
/
mach
browsertime
[
ARGS
]
All
arguments
are
passed
through
to
browsertime
.
'
'
'
from
__future__
import
absolute_import
print_function
unicode_literals
import
argparse
import
logging
import
os
import
stat
import
sys
import
re
import
contextlib
from
six
import
StringIO
from
mach
.
decorators
import
CommandArgument
CommandProvider
Command
from
mozbuild
.
base
import
MachCommandBase
from
mozbuild
.
util
import
mkdir
import
mozpack
.
path
as
mozpath
BROWSERTIME_ROOT
=
os
.
path
.
dirname
(
__file__
)
PILLOW_VERSION
=
"
6
.
0
.
0
"
PYSSIM_VERSION
=
"
0
.
4
"
contextlib
.
contextmanager
def
silence
(
)
:
    
oldout
olderr
=
sys
.
stdout
sys
.
stderr
    
try
:
        
sys
.
stdout
sys
.
stderr
=
StringIO
(
)
StringIO
(
)
        
yield
    
finally
:
        
sys
.
stdout
sys
.
stderr
=
oldout
olderr
def
node_path
(
)
:
    
from
mozbuild
.
nodeutil
import
find_node_executable
    
node
_
=
find_node_executable
(
)
    
return
os
.
path
.
abspath
(
node
)
def
package_path
(
)
:
    
'
'
'
The
path
to
the
browsertime
directory
.
    
Override
the
default
with
the
BROWSERTIME
environment
variable
.
'
'
'
    
override
=
os
.
environ
.
get
(
'
BROWSERTIME
'
None
)
    
if
override
:
        
return
override
    
return
mozpath
.
join
(
BROWSERTIME_ROOT
'
node_modules
'
'
browsertime
'
)
def
browsertime_path
(
)
:
    
'
'
'
The
path
to
the
browsertime
.
js
script
.
'
'
'
    
return
mozpath
.
join
(
        
package_path
(
)
        
'
bin
'
        
'
browsertime
.
js
'
)
def
visualmetrics_path
(
)
:
    
'
'
'
The
path
to
the
visualmetrics
.
py
script
.
'
'
'
    
return
mozpath
.
join
(
        
package_path
(
)
        
'
vendor
'
        
'
visualmetrics
.
py
'
)
def
host_platform
(
)
:
    
is_64bits
=
sys
.
maxsize
>
2
*
*
32
    
if
sys
.
platform
.
startswith
(
'
win
'
)
:
        
if
is_64bits
:
            
return
'
win64
'
    
elif
sys
.
platform
.
startswith
(
'
linux
'
)
:
        
if
is_64bits
:
            
return
'
linux64
'
    
elif
sys
.
platform
.
startswith
(
'
darwin
'
)
:
        
return
'
darwin
'
    
raise
ValueError
(
'
sys
.
platform
is
not
yet
supported
:
{
}
'
.
format
(
sys
.
platform
)
)
host_fetches
=
{
    
'
darwin
'
:
{
        
'
ffmpeg
'
:
{
            
'
type
'
:
'
static
-
url
'
            
'
url
'
:
'
https
:
/
/
github
.
com
/
ncalexan
/
geckodriver
/
releases
/
download
/
v0
.
24
.
0
-
android
/
ffmpeg
-
4
.
1
.
1
-
macos64
-
static
.
zip
'
            
'
path
'
:
'
ffmpeg
-
4
.
1
.
1
-
macos64
-
static
'
        
}
    
}
    
'
linux64
'
:
{
        
'
ffmpeg
'
:
{
            
'
type
'
:
'
static
-
url
'
            
'
url
'
:
'
https
:
/
/
github
.
com
/
ncalexan
/
geckodriver
/
releases
/
download
/
v0
.
24
.
0
-
android
/
ffmpeg
-
4
.
1
.
4
-
i686
-
static
.
tar
.
xz
'
            
'
path
'
:
'
ffmpeg
-
4
.
1
.
4
-
i686
-
static
'
        
}
    
}
    
'
win64
'
:
{
        
'
ffmpeg
'
:
{
            
'
type
'
:
'
static
-
url
'
            
'
url
'
:
'
https
:
/
/
github
.
com
/
ncalexan
/
geckodriver
/
releases
/
download
/
v0
.
24
.
0
-
android
/
ffmpeg
-
4
.
1
.
1
-
win64
-
static
.
zip
'
            
'
path
'
:
'
ffmpeg
-
4
.
1
.
1
-
win64
-
static
'
        
}
        
'
ImageMagick
'
:
{
            
'
type
'
:
'
static
-
url
'
            
'
url
'
:
'
https
:
/
/
ftp
.
icm
.
edu
.
pl
/
packages
/
ImageMagick
/
binaries
/
ImageMagick
-
7
.
0
.
8
-
39
-
portable
-
Q16
-
x64
.
zip
'
            
'
path
'
:
'
ImageMagick
-
7
.
0
.
8
'
        
}
    
}
}
CommandProvider
class
MachBrowsertime
(
MachCommandBase
)
:
    
property
    
def
artifact_cache_path
(
self
)
:
        
r
'
'
'
Downloaded
artifacts
will
be
kept
here
.
'
'
'
        
return
mozpath
.
join
(
self
.
_mach_context
.
state_dir
'
cache
'
'
browsertime
'
)
    
property
    
def
state_path
(
self
)
:
        
r
'
'
'
Unpacked
artifacts
will
be
kept
here
.
'
'
'
        
return
mozpath
.
join
(
self
.
_mach_context
.
state_dir
'
browsertime
'
)
    
def
setup
(
self
should_clobber
=
False
)
:
        
r
'
'
'
Install
browsertime
and
visualmetrics
.
py
requirements
.
'
'
'
        
automation
=
bool
(
os
.
environ
.
get
(
'
MOZ_AUTOMATION
'
)
)
        
from
mozbuild
.
action
.
tooltool
import
unpack_file
        
from
mozbuild
.
artifact_cache
import
ArtifactCache
        
sys
.
path
.
append
(
mozpath
.
join
(
self
.
topsrcdir
'
tools
'
'
lint
'
'
eslint
'
)
)
        
import
setup_helper
        
if
not
os
.
environ
.
get
(
'
MOZ_AUTOMATION
'
)
and
host_platform
(
)
.
startswith
(
'
linux
'
)
:
            
try
:
                
from
shutil
import
which
            
except
ImportError
:
                
from
shutil_which
import
which
            
im_programs
=
(
'
compare
'
'
convert
'
'
mogrify
'
)
            
for
im_program
in
im_programs
:
                
prog
=
which
(
im_program
)
                
if
not
prog
:
                    
print
(
'
Error
:
On
Linux
ImageMagick
must
be
on
the
PATH
.
'
                          
'
Install
ImageMagick
manually
and
try
again
(
or
update
PATH
)
.
'
                          
'
On
Ubuntu
and
Debian
try
sudo
apt
-
get
install
imagemagick
.
'
                          
'
On
Fedora
try
sudo
dnf
install
imagemagick
.
'
                          
'
On
CentOS
try
sudo
yum
install
imagemagick
.
'
)
                    
return
1
        
artifact_cache
=
ArtifactCache
(
self
.
artifact_cache_path
                                       
log
=
self
.
log
skip_cache
=
False
)
        
fetches
=
host_fetches
[
host_platform
(
)
]
        
for
tool
fetch
in
sorted
(
fetches
.
items
(
)
)
:
            
archive
=
artifact_cache
.
fetch
(
fetch
[
'
url
'
]
)
            
if
fetch
.
get
(
'
unpack
'
True
)
:
                
cwd
=
os
.
getcwd
(
)
                
try
:
                    
mkdir
(
self
.
state_path
)
                    
os
.
chdir
(
self
.
state_path
)
                    
self
.
log
(
                        
logging
.
INFO
                        
'
browsertime
'
                        
{
'
path
'
:
archive
}
                        
'
Unpacking
temporary
location
{
path
}
'
)
                    
if
'
win64
'
in
host_platform
(
)
and
'
imagemagick
'
in
tool
.
lower
(
)
:
                        
mkdir
(
fetch
.
get
(
'
path
'
)
)
                        
os
.
chdir
(
os
.
path
.
join
(
self
.
state_path
fetch
.
get
(
'
path
'
)
)
)
                        
unpack_file
(
archive
)
                        
os
.
chdir
(
self
.
state_path
)
                    
else
:
                        
unpack_file
(
archive
)
                    
path
=
os
.
path
.
join
(
self
.
state_path
fetch
.
get
(
'
path
'
)
)
                    
if
not
os
.
path
.
exists
(
path
)
:
                        
raise
Exception
(
"
Cannot
find
an
extracted
directory
:
%
s
"
%
path
)
                    
try
:
                        
for
root
dirs
files
in
os
.
walk
(
path
)
:
                            
for
edir
in
dirs
:
                                
loc_to_change
=
os
.
path
.
join
(
root
edir
)
                                
st
=
os
.
stat
(
loc_to_change
)
                                
os
.
chmod
(
loc_to_change
st
.
st_mode
|
stat
.
S_IEXEC
)
                            
for
efile
in
files
:
                                
loc_to_change
=
os
.
path
.
join
(
root
efile
)
                                
st
=
os
.
stat
(
loc_to_change
)
                                
os
.
chmod
(
loc_to_change
st
.
st_mode
|
stat
.
S_IEXEC
)
                    
except
Exception
as
e
:
                        
raise
Exception
(
                            
"
Could
not
set
executable
bit
in
%
s
error
:
%
s
"
%
(
path
str
(
e
)
)
                        
)
                
finally
:
                    
os
.
chdir
(
cwd
)
        
if
not
setup_helper
.
check_node_executables_valid
(
)
:
            
return
1
        
if
'
GECKODRIVER_BASE_URL
'
not
in
os
.
environ
:
            
url
=
'
https
:
/
/
github
.
com
/
ncalexan
/
geckodriver
/
releases
/
download
/
v0
.
24
.
0
-
android
/
'
            
os
.
environ
[
str
(
'
GECKODRIVER_BASE_URL
'
)
]
=
str
(
url
)
        
self
.
log
(
            
logging
.
INFO
            
'
browsertime
'
            
{
'
package_json
'
:
mozpath
.
join
(
BROWSERTIME_ROOT
'
package
.
json
'
)
}
            
'
Installing
browsertime
node
module
from
{
package_json
}
'
)
        
status
=
setup_helper
.
package_setup
(
            
BROWSERTIME_ROOT
            
'
browsertime
'
            
should_clobber
=
should_clobber
            
no_optional
=
automation
)
        
if
status
:
            
return
status
        
if
automation
:
            
return
0
        
return
self
.
check
(
)
    
def
node
(
self
args
)
:
        
r
'
'
'
Invoke
node
(
interactively
)
with
the
given
arguments
.
'
'
'
        
return
self
.
run_process
(
            
[
node_path
(
)
]
+
args
            
append_env
=
self
.
append_env
(
)
            
pass_thru
=
True
            
ensure_exit_code
=
False
            
cwd
=
mozpath
.
join
(
self
.
topsrcdir
)
)
    
def
append_env
(
self
append_path
=
True
)
:
        
fetches
=
host_fetches
[
host_platform
(
)
]
        
path
=
os
.
environ
.
get
(
'
PATH
'
'
'
)
.
split
(
os
.
pathsep
)
if
append_path
else
[
]
        
path_to_ffmpeg
=
mozpath
.
join
(
            
self
.
state_path
            
fetches
[
'
ffmpeg
'
]
[
'
path
'
]
)
        
path_to_imagemagick
=
None
        
if
'
ImageMagick
'
in
fetches
:
            
path_to_imagemagick
=
mozpath
.
join
(
                
self
.
state_path
                
fetches
[
'
ImageMagick
'
]
[
'
path
'
]
)
        
if
path_to_imagemagick
:
            
path
.
insert
(
0
self
.
state_path
if
host_platform
(
)
.
startswith
(
'
win
'
)
else
mozpath
.
join
(
path_to_imagemagick
'
bin
'
)
)
        
path
.
insert
(
0
path_to_ffmpeg
if
host_platform
(
)
.
startswith
(
'
linux
'
)
else
mozpath
.
join
(
path_to_ffmpeg
'
bin
'
)
)
        
node_dir
=
os
.
path
.
dirname
(
node_path
(
)
)
        
path
=
[
node_dir
]
+
path
        
if
'
win64
'
in
host_platform
(
)
and
path_to_imagemagick
:
            
path
.
insert
(
2
path_to_imagemagick
)
        
if
host_platform
(
)
=
=
"
darwin
"
:
            
for
p
in
os
.
environ
[
"
PATH
"
]
.
split
(
os
.
pathsep
)
:
                
p
=
p
.
strip
(
)
                
if
not
p
or
p
in
path
:
                    
continue
                
path
.
append
(
p
)
        
append_env
=
{
            
'
PATH
'
:
os
.
pathsep
.
join
(
path
)
            
'
PYTHON
'
:
self
.
virtualenv_manager
.
python_path
        
}
        
if
path_to_imagemagick
:
            
append_env
.
update
(
{
                
'
LD_LIBRARY_PATH
'
:
mozpath
.
join
(
path_to_imagemagick
'
lib
'
)
                
'
DYLD_LIBRARY_PATH
'
:
mozpath
.
join
(
path_to_imagemagick
'
lib
'
)
                
'
MAGICK_HOME
'
:
path_to_imagemagick
            
}
)
        
return
append_env
    
def
_activate_virtualenv
(
self
*
args
*
*
kwargs
)
:
        
r
'
'
'
Activates
virtualenv
.
        
This
function
will
also
install
Pillow
and
pyssim
if
needed
.
        
It
will
raise
an
error
in
case
the
install
failed
.
        
'
'
'
        
MachCommandBase
.
_activate_virtualenv
(
self
*
args
*
*
kwargs
)
        
try
:
            
import
PIL
            
if
PIL
.
__version__
!
=
PILLOW_VERSION
:
                
raise
ImportError
(
"
Wrong
version
%
s
"
%
PIL
.
__version__
)
        
except
ImportError
:
            
self
.
virtualenv_manager
.
install_pip_package
(
'
Pillow
=
=
%
s
'
%
PILLOW_VERSION
)
        
try
:
            
import
ssim
        
except
ImportError
:
            
self
.
virtualenv_manager
.
install_pip_package
(
'
pyssim
=
=
%
s
'
%
PYSSIM_VERSION
)
    
def
check
(
self
)
:
        
r
'
'
'
Run
visualmetrics
.
py
-
-
check
.
'
'
'
        
self
.
_activate_virtualenv
(
)
        
args
=
[
'
-
-
check
'
]
        
status
=
self
.
run_process
(
            
[
self
.
virtualenv_manager
.
python_path
visualmetrics_path
(
)
]
+
args
            
append_env
=
self
.
append_env
(
append_path
=
host_platform
(
)
.
startswith
(
'
linux
'
)
)
            
pass_thru
=
True
            
ensure_exit_code
=
False
            
cwd
=
mozpath
.
join
(
self
.
topsrcdir
)
)
        
sys
.
stdout
.
flush
(
)
        
sys
.
stderr
.
flush
(
)
        
if
status
:
            
return
status
        
self
.
log_manager
.
terminal_handler
.
setLevel
(
logging
.
CRITICAL
)
        
print
(
'
browsertime
version
:
'
end
=
'
'
)
        
sys
.
stdout
.
flush
(
)
        
sys
.
stderr
.
flush
(
)
        
return
self
.
node
(
[
browsertime_path
(
)
]
+
[
'
-
-
version
'
]
)
    
def
extra_default_args
(
self
args
=
[
]
)
:
        
def
extract_browser_name
(
args
)
:
            
'
Extracts
the
browser
name
if
any
'
            
res
=
re
.
findall
(
"
(
-
-
browser
|
-
b
)
[
=
]
(
[
\
w
]
+
)
"
'
'
.
join
(
args
)
)
            
if
res
=
=
[
]
:
                
return
None
            
return
res
[
0
]
[
-
1
]
        
def
matches
(
args
*
flags
)
:
            
'
Return
True
if
any
argument
matches
any
of
the
given
flags
(
maybe
with
an
argument
)
.
'
            
for
flag
in
flags
:
                
if
flag
in
args
or
any
(
arg
.
startswith
(
flag
+
'
=
'
)
for
arg
in
args
)
:
                    
return
True
            
return
False
        
extra_args
=
[
]
        
specifies_browser
=
matches
(
args
'
-
b
'
'
-
-
browser
'
)
        
if
not
specifies_browser
:
            
extra_args
.
extend
(
(
'
-
b
'
'
firefox
'
)
)
        
specifies_har
=
matches
(
args
'
-
-
har
'
'
-
-
skipHar
'
'
-
-
gzipHar
'
)
        
if
not
specifies_har
:
            
extra_args
.
append
(
'
-
-
skipHar
'
)
        
if
not
matches
(
args
"
-
-
android
"
)
:
            
specifies_binaryPath
=
matches
(
args
'
-
-
firefox
.
binaryPath
'
                                           
'
-
-
firefox
.
release
'
'
-
-
firefox
.
nightly
'
                                           
'
-
-
firefox
.
beta
'
'
-
-
firefox
.
developer
'
)
            
if
not
specifies_binaryPath
:
                
specifies_binaryPath
=
extract_browser_name
(
args
)
=
=
'
chrome
'
            
if
not
specifies_binaryPath
:
                
try
:
                    
extra_args
.
extend
(
(
'
-
-
firefox
.
binaryPath
'
self
.
get_binary_path
(
)
)
)
                
except
Exception
:
                    
print
(
'
Please
run
|
.
/
mach
build
|
'
                          
'
or
specify
a
Firefox
binary
with
-
-
firefox
.
binaryPath
.
'
)
                    
return
1
        
if
extra_args
:
            
self
.
log
(
                
logging
.
DEBUG
                
'
browsertime
'
                
{
'
extra_args
'
:
extra_args
}
                
'
Running
browsertime
with
extra
default
arguments
:
{
extra_args
}
'
)
        
return
extra_args
    
def
_verify_node_install
(
self
)
:
        
sys
.
path
.
append
(
mozpath
.
join
(
self
.
topsrcdir
'
tools
'
'
lint
'
'
eslint
'
)
)
        
import
setup_helper
        
with
silence
(
)
:
            
node_valid
=
setup_helper
.
check_node_executables_valid
(
)
        
if
not
node_valid
:
            
print
(
"
Can
'
t
find
Node
.
did
you
run
.
/
mach
bootstrap
?
"
)
            
return
False
        
if
not
os
.
path
.
exists
(
browsertime_path
(
)
)
:
            
print
(
"
Could
not
find
browsertime
.
js
try
.
/
mach
browsertime
-
-
setup
"
)
            
print
(
"
If
that
still
fails
try
.
/
mach
browsertime
-
-
setup
-
-
clobber
"
)
            
return
False
        
return
True
    
Command
(
'
browsertime
'
category
=
'
testing
'
             
description
=
'
Run
[
browsertime
]
(
https
:
/
/
github
.
com
/
sitespeedio
/
browsertime
)
'
                         
'
performance
tests
.
'
)
    
CommandArgument
(
'
-
-
verbose
'
action
=
'
store_true
'
                     
help
=
'
Verbose
output
for
what
commands
the
build
is
running
.
'
)
    
CommandArgument
(
'
-
-
setup
'
default
=
False
action
=
'
store_true
'
)
    
CommandArgument
(
'
-
-
clobber
'
default
=
False
action
=
'
store_true
'
)
    
CommandArgument
(
'
-
-
skip
-
cache
'
action
=
'
store_true
'
                     
help
=
'
Skip
all
local
caches
to
force
re
-
fetching
remote
artifacts
.
'
                     
default
=
False
)
    
CommandArgument
(
'
-
-
check
'
default
=
False
action
=
'
store_true
'
)
    
CommandArgument
(
'
args
'
nargs
=
argparse
.
REMAINDER
)
    
def
browsertime
(
self
args
verbose
=
False
                    
setup
=
False
clobber
=
False
skip_cache
=
False
                    
check
=
False
)
:
        
self
.
_set_log_level
(
verbose
)
        
if
setup
:
            
return
self
.
setup
(
should_clobber
=
clobber
)
        
else
:
            
if
not
self
.
_verify_node_install
(
)
:
                
return
1
        
if
check
:
            
return
self
.
check
(
)
        
self
.
_activate_virtualenv
(
)
        
default_args
=
self
.
extra_default_args
(
args
)
        
if
default_args
=
=
1
:
            
return
1
        
return
self
.
node
(
[
browsertime_path
(
)
]
+
default_args
+
args
)
    
Command
(
'
visualmetrics
'
category
=
'
testing
'
             
description
=
'
Run
visualmetrics
.
py
'
)
    
CommandArgument
(
'
video
'
)
    
CommandArgument
(
'
args
'
nargs
=
argparse
.
REMAINDER
)
    
def
visualmetrics
(
self
video
args
)
:
        
self
.
_set_log_level
(
True
)
        
self
.
_activate_virtualenv
(
)
        
d
base
=
os
.
path
.
split
(
video
)
        
index
_
=
os
.
path
.
splitext
(
base
)
        
args
=
[
'
-
-
dir
'
                
mozpath
.
join
(
d
'
images
'
index
)
                
'
-
-
video
'
                
video
                
'
-
-
orange
'
                
'
-
-
perceptual
'
                
'
-
-
contentful
'
                
'
-
-
force
'
                
'
-
-
renderignore
'
                
'
5
'
                
'
-
-
json
'
                
'
-
-
viewport
'
                
'
-
q
'
                
'
75
'
                
'
-
vvvv
'
]
        
return
self
.
run_process
(
            
[
visualmetrics_path
(
)
]
+
args
            
append_env
=
self
.
append_env
(
)
            
pass_thru
=
True
            
ensure_exit_code
=
False
            
cwd
=
mozpath
.
join
(
self
.
topsrcdir
)
)
