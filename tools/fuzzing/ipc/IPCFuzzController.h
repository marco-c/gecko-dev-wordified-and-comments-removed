#
ifndef
mozilla_ipc_IPCFuzzController_h
#
define
mozilla_ipc_IPCFuzzController_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
fuzzing
/
Nyx
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
chrome
/
common
/
ipc_message
.
h
"
#
include
"
mojo
/
core
/
ports
/
name
.
h
"
#
include
"
mojo
/
core
/
ports
/
event
.
h
"
#
include
"
IPCMessageStart
.
h
"
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
define
MOZ_FUZZING_IPC_DROP_PEER
(
aReason
)
\
mozilla
:
:
fuzzing
:
:
IPCFuzzController
:
:
instance
(
)
.
OnDropPeer
(
\
aReason
__FILE__
__LINE__
)
;
#
define
MOZ_FUZZING_IPC_MT_CTOR
(
)
\
mozilla
:
:
fuzzing
:
:
IPCFuzzController
:
:
instance
(
)
.
OnMessageTaskStart
(
)
;
#
define
MOZ_FUZZING_IPC_MT_STOP
(
)
\
mozilla
:
:
fuzzing
:
:
IPCFuzzController
:
:
instance
(
)
.
OnMessageTaskStop
(
)
;
#
define
MOZ_FUZZING_IPC_PRE_FUZZ_MT_RUN
(
)
\
mozilla
:
:
fuzzing
:
:
IPCFuzzController
:
:
instance
(
)
.
OnPreFuzzMessageTaskRun
(
)
;
#
define
MOZ_FUZZING_IPC_PRE_FUZZ_MT_STOP
(
)
\
mozilla
:
:
fuzzing
:
:
IPCFuzzController
:
:
instance
(
)
.
OnPreFuzzMessageTaskStop
(
)
;
namespace
mozilla
{
namespace
ipc
{
class
IProtocol
;
typedef
IPCMessageStart
ProtocolId
;
class
NodeChannel
;
}
namespace
fuzzing
{
class
IPCFuzzController
{
typedef
std
:
:
pair
<
int32_t
uint64_t
>
SeqNoPair
;
typedef
std
:
:
pair
<
int32_t
mozilla
:
:
ipc
:
:
ProtocolId
>
ActorIdPair
;
class
IPCFuzzLoop
final
:
public
Runnable
{
friend
class
IPCFuzzController
;
public
:
NS_DECL_NSIRUNNABLE
IPCFuzzLoop
(
)
;
private
:
~
IPCFuzzLoop
(
)
=
default
;
}
;
public
:
static
IPCFuzzController
&
instance
(
)
;
void
InitializeIPCTypes
(
)
;
bool
GetRandomIPCMessageType
(
mozilla
:
:
ipc
:
:
ProtocolId
pId
uint16_t
typeOffset
uint32_t
*
type
)
;
bool
ObserveIPCMessage
(
mozilla
:
:
ipc
:
:
NodeChannel
*
channel
IPC
:
:
Message
&
aMessage
)
;
bool
MakeTargetDecision
(
uint8_t
portIndex
uint8_t
portInstanceIndex
uint8_t
actorIndex
uint16_t
typeOffset
mojo
:
:
core
:
:
ports
:
:
PortName
*
name
int32_t
*
seqno
uint64_t
*
fseqno
int32_t
*
actorId
uint32_t
*
type
bool
*
is_cons
bool
update
=
true
)
;
void
OnActorConnected
(
mozilla
:
:
ipc
:
:
IProtocol
*
protocol
)
;
void
OnActorDestroyed
(
mozilla
:
:
ipc
:
:
IProtocol
*
protocol
)
;
void
OnDropPeer
(
const
char
*
reason
const
char
*
file
int
line
)
;
void
OnMessageTaskStart
(
)
;
void
OnMessageTaskStop
(
)
;
void
OnPreFuzzMessageTaskRun
(
)
;
void
OnPreFuzzMessageTaskStop
(
)
;
void
OnChildReady
(
)
{
childReady
=
true
;
}
void
OnRunnableDone
(
)
{
runnableDone
=
true
;
}
uint32_t
getPreFuzzMessageTaskCount
(
)
{
return
messageTaskCount
;
}
;
uint32_t
getMessageStartCount
(
)
{
return
messageStartCount
;
}
;
uint32_t
getMessageStopCount
(
)
{
return
messageStopCount
;
}
;
void
StartFuzzing
(
mozilla
:
:
ipc
:
:
NodeChannel
*
channel
IPC
:
:
Message
&
aMessage
)
;
void
SynchronizeOnMessageExecution
(
uint32_t
expected_messages
)
;
void
AddToplevelActor
(
mojo
:
:
core
:
:
ports
:
:
PortName
name
mozilla
:
:
ipc
:
:
ProtocolId
protocolId
)
;
private
:
std
:
:
unordered_map
<
mojo
:
:
core
:
:
ports
:
:
PortName
SeqNoPair
>
portSeqNos
;
std
:
:
unordered_map
<
mojo
:
:
core
:
:
ports
:
:
PortName
mojo
:
:
core
:
:
ports
:
:
NodeName
>
portNodeName
;
std
:
:
unordered_map
<
mozilla
:
:
ipc
:
:
ProtocolId
uint32_t
>
validMsgTypes
;
std
:
:
unordered_map
<
mojo
:
:
core
:
:
ports
:
:
PortName
std
:
:
vector
<
ActorIdPair
>
>
actorIds
;
Atomic
<
bool
>
useLastPortName
;
mojo
:
:
core
:
:
ports
:
:
PortName
lastActorPortName
;
Atomic
<
uint32_t
>
useLastActor
;
std
:
:
vector
<
std
:
:
vector
<
mojo
:
:
core
:
:
ports
:
:
PortName
>
>
portNames
;
std
:
:
unordered_map
<
std
:
:
string
uint8_t
>
portNameToIndex
;
std
:
:
unordered_set
<
uint32_t
>
constructorTypes
;
mojo
:
:
core
:
:
ports
:
:
NodeName
targetNodeName
;
bool
haveTargetNodeName
=
false
;
bool
fuzzingStartPending
=
false
;
Atomic
<
bool
>
runnableDone
;
Atomic
<
bool
>
childReady
;
Atomic
<
uint32_t
>
messageStartCount
;
Atomic
<
uint32_t
>
messageStopCount
;
Atomic
<
uint32_t
>
messageTaskCount
;
Vector
<
char
256
InfallibleAllocPolicy
>
sampleHeader
;
mozilla
:
:
ipc
:
:
NodeChannel
*
nodeChannel
=
nullptr
;
Mutex
mMutex
;
IPCFuzzController
(
)
;
NYX_DISALLOW_COPY_AND_ASSIGN
(
IPCFuzzController
)
;
}
;
}
}
#
endif
