#
include
"
IPCFuzzController
.
h
"
#
include
"
mozilla
/
Fuzzing
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
MessageLink
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
ipc
/
NodeChannel
.
h
"
#
include
"
mozilla
/
ipc
/
NodeController
.
h
"
#
include
"
mozilla
/
ipc
/
PIdleScheduler
.
h
"
#
include
"
mozilla
/
ipc
/
PBackground
.
h
"
#
include
"
mozilla
/
dom
/
PContent
.
h
"
using
namespace
mojo
:
:
core
:
:
ports
;
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
{
namespace
fuzzing
{
IPCFuzzController
:
:
IPCFuzzController
(
)
:
mMutex
(
"
IPCFuzzController
"
)
{
InitializeIPCTypes
(
)
;
portNames
.
resize
(
64
)
;
portNameToIndex
[
"
PContent
"
]
=
0
;
portNameToIndex
[
"
PBackground
"
]
=
1
;
portNameToIndex
[
"
PBackgroundStarter
"
]
=
2
;
portNameToIndex
[
"
PCompositorManager
"
]
=
3
;
portNameToIndex
[
"
PImageBridge
"
]
=
4
;
portNameToIndex
[
"
PProcessHangMonitor
"
]
=
5
;
portNameToIndex
[
"
PProfiler
"
]
=
6
;
portNameToIndex
[
"
PVRManager
"
]
=
7
;
portNameToIndex
[
"
PCanvasManager
"
]
=
8
;
}
IPCFuzzController
&
IPCFuzzController
:
:
instance
(
)
{
static
IPCFuzzController
ifc
;
return
ifc
;
}
void
IPCFuzzController
:
:
InitializeIPCTypes
(
)
{
const
char
*
cons
=
"
Constructor
"
;
size_t
cons_len
=
strlen
(
cons
)
;
for
(
uint32_t
start
=
0
;
start
<
LastMsgIndex
;
+
+
start
)
{
uint32_t
i
;
for
(
i
=
(
start
<
<
16
)
+
1
;
i
<
(
(
start
+
1
)
<
<
16
)
;
+
+
i
)
{
const
char
*
name
=
IPC
:
:
StringFromIPCMessageType
(
i
)
;
if
(
name
[
0
]
=
=
'
<
'
)
break
;
size_t
len
=
strlen
(
name
)
;
if
(
len
>
cons_len
&
&
!
memcmp
(
cons
name
+
len
-
cons_len
cons_len
)
)
{
constructorTypes
.
insert
(
i
)
;
}
}
validMsgTypes
[
(
ProtocolId
)
start
]
=
i
-
(
(
start
<
<
16
)
+
1
)
;
}
}
bool
IPCFuzzController
:
:
GetRandomIPCMessageType
(
ProtocolId
pId
uint16_t
typeOffset
uint32_t
*
type
)
{
auto
pIdEntry
=
validMsgTypes
.
find
(
pId
)
;
if
(
pIdEntry
=
=
validMsgTypes
.
end
(
)
)
{
return
false
;
}
*
type
=
(
(
uint32_t
)
pIdEntry
-
>
first
<
<
16
)
+
1
+
(
typeOffset
%
pIdEntry
-
>
second
)
;
return
true
;
}
void
IPCFuzzController
:
:
OnActorConnected
(
IProtocol
*
protocol
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
#
ifdef
FUZZ_DEBUG
MOZ_FUZZING_NYX_PRINTF
(
"
INFO
:
[
OnActorConnected
]
ActorID
%
d
Protocol
:
%
s
\
n
"
protocol
-
>
Id
(
)
protocol
-
>
GetProtocolName
(
)
)
;
#
endif
MessageChannel
*
channel
=
protocol
-
>
ToplevelProtocol
(
)
-
>
GetIPCChannel
(
)
;
Maybe
<
PortName
>
portName
=
channel
-
>
GetPortName
(
)
;
if
(
portName
)
{
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
IPCFuzzController
:
:
OnActorConnected
(
)
Mutex
try
\
n
"
)
;
MutexAutoLock
lock
(
mMutex
)
;
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
IPCFuzzController
:
:
OnActorConnected
(
)
Mutex
locked
\
n
"
)
;
actorIds
[
*
portName
]
.
emplace_back
(
protocol
-
>
Id
(
)
protocol
-
>
GetProtocolId
(
)
)
;
useLastPortName
=
true
;
lastActorPortName
=
*
portName
;
useLastActor
=
5
;
}
else
{
MOZ_FUZZING_NYX_PRINT
(
"
WARNING
:
No
port
name
on
actor
?
!
\
n
"
)
;
}
}
void
IPCFuzzController
:
:
OnActorDestroyed
(
IProtocol
*
protocol
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
MOZ_FUZZING_NYX_PRINTF
(
"
INFO
:
[
OnActorDestroyed
]
ActorID
%
d
Protocol
:
%
s
\
n
"
protocol
-
>
Id
(
)
protocol
-
>
GetProtocolName
(
)
)
;
MessageChannel
*
channel
=
protocol
-
>
ToplevelProtocol
(
)
-
>
GetIPCChannel
(
)
;
Maybe
<
PortName
>
portName
=
channel
-
>
GetPortName
(
)
;
if
(
portName
)
{
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
IPCFuzzController
:
:
OnActorDestroyed
(
)
Mutex
try
\
n
"
)
;
MutexAutoLock
lock
(
mMutex
)
;
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
IPCFuzzController
:
:
OnActorDestroyed
(
)
Mutex
locked
\
n
"
)
;
for
(
auto
iter
=
actorIds
[
*
portName
]
.
begin
(
)
;
iter
!
=
actorIds
[
*
portName
]
.
end
(
)
;
)
{
if
(
iter
-
>
first
=
=
protocol
-
>
Id
(
)
&
&
iter
-
>
second
=
=
protocol
-
>
GetProtocolId
(
)
)
{
iter
=
actorIds
[
*
portName
]
.
erase
(
iter
)
;
}
else
{
+
+
iter
;
}
}
}
else
{
MOZ_FUZZING_NYX_PRINT
(
"
WARNING
:
No
port
name
on
destroyed
actor
?
!
\
n
"
)
;
}
}
void
IPCFuzzController
:
:
AddToplevelActor
(
PortName
name
ProtocolId
protocolId
)
{
const
char
*
protocolName
=
ProtocolIdToName
(
protocolId
)
;
auto
result
=
portNameToIndex
.
find
(
protocolName
)
;
if
(
result
=
=
portNameToIndex
.
end
(
)
)
{
MOZ_FUZZING_NYX_PRINTF
(
"
ERROR
:
[
OnActorConnected
]
Unknown
Top
-
Level
Protocol
:
%
s
\
n
"
protocolName
)
;
MOZ_REALLY_CRASH
(
__LINE__
)
;
}
uint8_t
portIndex
=
result
-
>
second
;
portNames
[
portIndex
]
.
push_back
(
name
)
;
}
bool
IPCFuzzController
:
:
ObserveIPCMessage
(
mozilla
:
:
ipc
:
:
NodeChannel
*
channel
IPC
:
:
Message
&
aMessage
)
{
if
(
!
mozilla
:
:
fuzzing
:
:
Nyx
:
:
instance
(
)
.
is_enabled
(
"
IPC_Generic
"
)
)
{
return
true
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
return
true
;
}
if
(
aMessage
.
IsFuzzMsg
(
)
)
{
if
(
!
channel
-
>
mBlockSendRecv
)
{
MOZ_FUZZING_NYX_PRINTF
(
"
INFO
:
[
NodeChannel
:
:
OnMessageReceived
]
Blocking
further
"
"
communication
on
Port
%
lu
%
lu
(
seen
fuzz
msg
)
\
n
"
channel
-
>
GetName
(
)
.
v1
channel
-
>
GetName
(
)
.
v2
)
;
channel
-
>
mBlockSendRecv
=
true
;
}
return
true
;
}
else
if
(
aMessage
.
type
(
)
=
=
dom
:
:
PContent
:
:
Msg_SignalFuzzingReady__ID
)
{
MOZ_FUZZING_NYX_PRINT
(
"
DEBUG
:
Ready
message
detected
.
\
n
"
)
;
OnChildReady
(
)
;
if
(
haveTargetNodeName
)
{
MOZ_FUZZING_NYX_PRINT
(
"
ERROR
:
Received
ready
signal
twice
?
!
\
n
"
)
;
MOZ_REALLY_CRASH
(
__LINE__
)
;
}
targetNodeName
=
channel
-
>
GetName
(
)
;
haveTargetNodeName
=
true
;
if
(
!
this
-
>
sampleHeader
.
initLengthUninitialized
(
sizeof
(
IPC
:
:
Message
:
:
Header
)
)
)
{
MOZ_REALLY_CRASH
(
__LINE__
)
;
}
memcpy
(
sampleHeader
.
begin
(
)
aMessage
.
header
(
)
sizeof
(
IPC
:
:
Message
:
:
Header
)
)
;
}
else
if
(
haveTargetNodeName
&
&
targetNodeName
!
=
channel
-
>
GetName
(
)
)
{
return
true
;
}
else
if
(
Nyx
:
:
instance
(
)
.
started
(
)
)
{
if
(
!
channel
-
>
mBlockSendRecv
)
{
MOZ_FUZZING_NYX_PRINTF
(
"
INFO
:
[
NodeChannel
:
:
OnMessageReceived
]
Blocking
further
"
"
communication
on
Port
%
lu
%
lu
(
fuzzing
started
)
\
n
"
channel
-
>
GetName
(
)
.
v1
channel
-
>
GetName
(
)
.
v2
)
;
channel
-
>
mBlockSendRecv
=
true
;
}
return
false
;
}
Vector
<
char
256
InfallibleAllocPolicy
>
footer
;
if
(
!
footer
.
initLengthUninitialized
(
aMessage
.
event_footer_size
(
)
)
)
{
MOZ_REALLY_CRASH
(
__LINE__
)
;
}
if
(
!
aMessage
.
ReadFooter
(
footer
.
begin
(
)
footer
.
length
(
)
false
)
)
{
MOZ_FUZZING_NYX_PRINT
(
"
ERROR
:
ReadFooter
(
)
failed
?
!
\
n
"
)
;
MOZ_REALLY_CRASH
(
__LINE__
)
;
}
UniquePtr
<
Event
>
event
=
Event
:
:
Deserialize
(
footer
.
begin
(
)
footer
.
length
(
)
)
;
if
(
!
event
)
{
MOZ_FUZZING_NYX_PRINT
(
"
ERROR
:
Failed
to
deserialize
observed
message
?
!
\
n
"
)
;
MOZ_REALLY_CRASH
(
__LINE__
)
;
}
if
(
event
-
>
type
(
)
=
=
Event
:
:
kUserMessage
)
{
if
(
haveTargetNodeName
&
&
!
fuzzingStartPending
)
{
bool
missingActor
=
false
;
{
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
IPCFuzzController
:
:
ObserveIPCMessage
(
)
Mutex
try
\
n
"
)
;
MutexAutoLock
lock
(
mMutex
)
;
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
IPCFuzzController
:
:
ObserveIPCMessage
(
)
Mutex
locked
\
n
"
)
;
for
(
auto
iter
=
portSeqNos
.
begin
(
)
;
iter
!
=
portSeqNos
.
end
(
)
;
+
+
iter
)
{
auto
result
=
actorIds
.
find
(
iter
-
>
first
)
;
if
(
result
=
=
actorIds
.
end
(
)
)
{
auto
result
=
portNodeName
.
find
(
iter
-
>
first
)
;
if
(
result
-
>
second
=
=
targetNodeName
)
{
missingActor
=
true
;
break
;
}
}
}
}
if
(
missingActor
)
{
MOZ_FUZZING_NYX_PRINT
(
"
INFO
:
Delaying
fuzzing
start
missing
actors
.
.
.
\
n
"
)
;
}
else
if
(
!
childReady
)
{
MOZ_FUZZING_NYX_PRINT
(
"
INFO
:
Delaying
fuzzing
start
waiting
for
child
.
.
.
\
n
"
)
;
}
else
{
fuzzingStartPending
=
true
;
StartFuzzing
(
channel
aMessage
)
;
if
(
targetNodeName
=
=
channel
-
>
GetName
(
)
)
{
if
(
!
channel
-
>
mBlockSendRecv
)
{
MOZ_FUZZING_NYX_PRINTF
(
"
INFO
:
[
NodeChannel
:
:
OnMessageReceived
]
Blocking
further
"
"
communication
on
Port
%
lu
%
lu
(
fuzzing
start
pending
)
\
n
"
channel
-
>
GetName
(
)
.
v1
channel
-
>
GetName
(
)
.
v2
)
;
channel
-
>
mBlockSendRecv
=
true
;
}
return
false
;
}
return
true
;
}
}
{
UserMessageEvent
*
userMsgEv
=
static_cast
<
UserMessageEvent
*
>
(
event
.
get
(
)
)
;
PortName
name
=
event
-
>
port_name
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
portSeqNos
.
insert_or_assign
(
name
std
:
:
pair
<
int32_t
uint64_t
>
(
aMessage
.
seqno
(
)
userMsgEv
-
>
sequence_num
(
)
)
)
;
portNodeName
.
insert_or_assign
(
name
channel
-
>
GetName
(
)
)
;
}
}
return
true
;
}
bool
IPCFuzzController
:
:
MakeTargetDecision
(
uint8_t
portIndex
uint8_t
portInstanceIndex
uint8_t
actorIndex
uint16_t
typeOffset
PortName
*
name
int32_t
*
seqno
uint64_t
*
fseqno
int32_t
*
actorId
uint32_t
*
type
bool
*
is_cons
bool
update
)
{
auto
portInstances
=
portNames
[
portIndex
&
0x3f
]
;
if
(
!
portInstances
.
size
(
)
)
{
return
false
;
}
if
(
useLastActor
)
{
useLastActor
-
-
;
*
name
=
lastActorPortName
;
MOZ_FUZZING_NYX_PRINT
(
"
DEBUG
:
MakeTargetDecision
:
Pinned
to
last
actor
.
\
n
"
)
;
if
(
!
useLastActor
&
&
(
portIndex
&
(
1
<
<
7
)
)
)
{
MOZ_FUZZING_NYX_PRINT
(
"
DEBUG
:
MakeTargetDecision
:
Released
pinning
on
last
port
.
\
n
"
)
;
useLastPortName
=
false
;
}
}
else
if
(
useLastPortName
)
{
*
name
=
lastActorPortName
;
MOZ_FUZZING_NYX_PRINT
(
"
DEBUG
:
MakeTargetDecision
:
Pinned
to
last
port
.
\
n
"
)
;
}
else
{
*
name
=
portInstances
[
portInstanceIndex
%
portInstances
.
size
(
)
]
;
}
auto
result
=
actorIds
.
find
(
*
name
)
;
if
(
result
=
=
actorIds
.
end
(
)
)
{
MOZ_FUZZING_NYX_PRINT
(
"
ERROR
:
Couldn
'
t
find
port
in
actors
map
?
!
\
n
"
)
;
return
false
;
}
auto
actors
=
result
-
>
second
;
if
(
actors
.
empty
(
)
)
{
MOZ_FUZZING_NYX_PRINT
(
"
ERROR
:
Couldn
'
t
find
an
actor
for
selected
port
?
!
\
n
"
)
;
return
false
;
}
auto
seqNos
=
portSeqNos
[
*
name
]
;
*
seqno
=
seqNos
.
first
-
1
;
*
fseqno
=
seqNos
.
second
+
1
;
if
(
update
)
{
portSeqNos
.
insert_or_assign
(
*
name
std
:
:
pair
<
int32_t
uint64_t
>
(
*
seqno
*
fseqno
)
)
;
}
if
(
useLastActor
)
{
actorIndex
=
actors
.
size
(
)
-
1
;
}
else
{
actorIndex
%
=
actors
.
size
(
)
;
}
ActorIdPair
ids
=
actors
[
actorIndex
]
;
*
actorId
=
ids
.
first
;
if
(
!
*
actorId
)
{
*
actorId
=
MSG_ROUTING_CONTROL
;
}
if
(
!
this
-
>
GetRandomIPCMessageType
(
ids
.
second
typeOffset
type
)
)
{
MOZ_FUZZING_NYX_PRINT
(
"
ERROR
:
GetRandomIPCMessageType
failed
?
!
\
n
"
)
;
return
false
;
}
*
is_cons
=
false
;
if
(
constructorTypes
.
find
(
*
type
)
!
=
constructorTypes
.
end
(
)
)
{
*
is_cons
=
true
;
}
#
ifdef
FUZZ_DEBUG
MOZ_FUZZING_NYX_PRINTF
(
"
DEBUG
:
MakeTargetDecision
:
Protocol
:
%
s
msgType
:
%
s
\
n
"
ProtocolIdToName
(
ids
.
second
)
IPC
:
:
StringFromIPCMessageType
(
*
type
)
)
;
#
endif
return
true
;
}
void
IPCFuzzController
:
:
OnMessageTaskStart
(
)
{
messageStartCount
+
+
;
}
void
IPCFuzzController
:
:
OnMessageTaskStop
(
)
{
messageStopCount
+
+
;
}
void
IPCFuzzController
:
:
OnPreFuzzMessageTaskRun
(
)
{
messageTaskCount
+
+
;
}
void
IPCFuzzController
:
:
OnPreFuzzMessageTaskStop
(
)
{
messageTaskCount
-
-
;
}
void
IPCFuzzController
:
:
OnDropPeer
(
const
char
*
reason
=
nullptr
const
char
*
file
=
nullptr
int
line
=
0
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
if
(
!
Nyx
:
:
instance
(
)
.
started
(
)
)
{
return
;
}
MOZ_FUZZING_NYX_PRINT
(
"
ERROR
:
=
=
=
=
=
=
=
=
END
OF
ITERATION
(
DROP_PEER
)
=
=
=
=
=
=
=
=
\
n
"
)
;
#
ifdef
FUZZ_DEBUG
MOZ_FUZZING_NYX_PRINTF
(
"
DEBUG
:
=
=
=
=
=
=
=
=
%
s
:
%
d
=
=
=
=
=
=
=
=
\
n
"
file
line
)
;
#
endif
Nyx
:
:
instance
(
)
.
handle_event
(
"
MOZ_IPC_DROP_PEER
"
file
line
reason
)
;
if
(
Nyx
:
:
instance
(
)
.
is_replay
(
)
)
{
return
;
}
Nyx
:
:
instance
(
)
.
release
(
IPCFuzzController
:
:
instance
(
)
.
getMessageStopCount
(
)
)
;
}
void
IPCFuzzController
:
:
StartFuzzing
(
mozilla
:
:
ipc
:
:
NodeChannel
*
channel
IPC
:
:
Message
&
aMessage
)
{
nodeChannel
=
channel
;
RefPtr
<
IPCFuzzLoop
>
runnable
=
new
IPCFuzzLoop
(
)
;
#
if
MOZ_FUZZ_IPC_SYNC_INJECT
runnable
-
>
Run
(
)
;
#
else
nsCOMPtr
<
nsIThread
>
newThread
;
nsresult
rv
=
NS_NewNamedThread
(
"
IPCFuzzLoop
"
getter_AddRefs
(
newThread
)
runnable
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_FUZZING_NYX_PRINT
(
"
ERROR
:
[
StartFuzzing
]
NS_NewNamedThread
failed
?
!
\
n
"
)
;
MOZ_REALLY_CRASH
(
__LINE__
)
;
}
#
endif
}
IPCFuzzController
:
:
IPCFuzzLoop
:
:
IPCFuzzLoop
(
)
:
mozilla
:
:
Runnable
(
"
IPCFuzzLoop
"
)
{
}
NS_IMETHODIMP
IPCFuzzController
:
:
IPCFuzzLoop
:
:
Run
(
)
{
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
BEGIN
IPCFuzzLoop
:
:
Run
(
)
\
n
"
)
;
const
size_t
maxMsgSize
=
2048
;
const
size_t
controlLen
=
16
;
Vector
<
char
256
InfallibleAllocPolicy
>
buffer
;
RefPtr
<
NodeController
>
controller
=
NodeController
:
:
GetSingleton
(
)
;
if
(
!
IPCFuzzController
:
:
instance
(
)
.
haveTargetNodeName
)
{
MOZ_FUZZING_NYX_PRINT
(
"
ERROR
:
I
don
'
t
have
the
target
NodeName
?
!
\
n
"
)
;
MOZ_REALLY_CRASH
(
__LINE__
)
;
}
{
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
IPCFuzzLoop
:
:
Run
(
)
Mutex
try
\
n
"
)
;
MutexAutoLock
lock
(
IPCFuzzController
:
:
instance
(
)
.
mMutex
)
;
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
IPCFuzzLoop
:
:
Run
(
)
Mutex
locked
\
n
"
)
;
for
(
auto
iter
=
IPCFuzzController
:
:
instance
(
)
.
portSeqNos
.
begin
(
)
;
iter
!
=
IPCFuzzController
:
:
instance
(
)
.
portSeqNos
.
end
(
)
;
)
{
auto
result
=
IPCFuzzController
:
:
instance
(
)
.
actorIds
.
find
(
iter
-
>
first
)
;
if
(
result
=
=
IPCFuzzController
:
:
instance
(
)
.
actorIds
.
end
(
)
)
{
auto
portNameResult
=
IPCFuzzController
:
:
instance
(
)
.
portNodeName
.
find
(
iter
-
>
first
)
;
if
(
portNameResult
-
>
second
=
=
IPCFuzzController
:
:
instance
(
)
.
targetNodeName
)
{
MOZ_FUZZING_NYX_PRINT
(
"
ERROR
:
We
should
not
have
port
map
entries
without
a
"
"
corresponding
"
"
entry
in
our
actors
map
\
n
"
)
;
MOZ_REALLY_CRASH
(
__LINE__
)
;
}
else
{
iter
=
IPCFuzzController
:
:
instance
(
)
.
portSeqNos
.
erase
(
iter
)
;
}
}
else
{
+
+
iter
;
}
}
for
(
auto
iter
=
IPCFuzzController
:
:
instance
(
)
.
actorIds
.
begin
(
)
;
iter
!
=
IPCFuzzController
:
:
instance
(
)
.
actorIds
.
end
(
)
;
+
+
iter
)
{
bool
isValidTarget
=
false
;
Maybe
<
PortStatus
>
status
;
PortRef
ref
=
controller
-
>
GetPort
(
iter
-
>
first
)
;
if
(
ref
.
is_valid
(
)
)
{
status
=
controller
-
>
GetStatus
(
ref
)
;
if
(
status
)
{
isValidTarget
=
status
-
>
peer_node_name
=
=
IPCFuzzController
:
:
instance
(
)
.
targetNodeName
;
}
}
auto
result
=
IPCFuzzController
:
:
instance
(
)
.
portSeqNos
.
find
(
iter
-
>
first
)
;
if
(
result
=
=
IPCFuzzController
:
:
instance
(
)
.
portSeqNos
.
end
(
)
)
{
if
(
isValidTarget
)
{
MOZ_FUZZING_NYX_PRINTF
(
"
INFO
:
Using
Port
%
lu
%
lu
for
protocol
%
s
(
*
)
\
n
"
iter
-
>
first
.
v1
iter
-
>
first
.
v2
ProtocolIdToName
(
iter
-
>
second
[
0
]
.
second
)
)
;
IPCFuzzController
:
:
instance
(
)
.
portSeqNos
.
insert_or_assign
(
iter
-
>
first
std
:
:
pair
<
int32_t
uint64_t
>
(
0
0
)
)
;
IPCFuzzController
:
:
instance
(
)
.
AddToplevelActor
(
iter
-
>
first
iter
-
>
second
[
0
]
.
second
)
;
}
else
{
MOZ_FUZZING_NYX_PRINTF
(
"
INFO
:
Removing
Port
%
lu
%
lu
for
protocol
%
s
(
*
)
\
n
"
iter
-
>
first
.
v1
iter
-
>
first
.
v2
ProtocolIdToName
(
iter
-
>
second
[
0
]
.
second
)
)
;
}
}
else
{
if
(
isValidTarget
)
{
MOZ_FUZZING_NYX_PRINTF
(
"
INFO
:
Using
Port
%
lu
%
lu
for
protocol
%
s
\
n
"
iter
-
>
first
.
v1
iter
-
>
first
.
v2
ProtocolIdToName
(
iter
-
>
second
[
0
]
.
second
)
)
;
IPCFuzzController
:
:
instance
(
)
.
AddToplevelActor
(
iter
-
>
first
iter
-
>
second
[
0
]
.
second
)
;
}
else
{
MOZ_FUZZING_NYX_PRINTF
(
"
INFO
:
Removing
Port
%
lu
%
lu
for
protocol
%
s
\
n
"
iter
-
>
first
.
v1
iter
-
>
first
.
v2
ProtocolIdToName
(
iter
-
>
second
[
0
]
.
second
)
)
;
IPCFuzzController
:
:
instance
(
)
.
portSeqNos
.
erase
(
result
)
;
}
}
}
}
IPCFuzzController
:
:
instance
(
)
.
runnableDone
=
false
;
SyncRunnable
:
:
DispatchToThread
(
GetMainThreadEventTarget
(
)
new
SyncRunnable
(
NS_NewRunnableFunction
(
"
IPCFuzzController
:
:
StartFuzzing
"
[
&
]
(
)
-
>
void
{
MOZ_FUZZING_NYX_PRINT
(
"
INFO
:
Main
thread
runnable
start
.
\
n
"
)
;
NS_ProcessPendingEvents
(
NS_GetCurrentThread
(
)
)
;
MOZ_FUZZING_NYX_PRINT
(
"
INFO
:
Main
thread
runnable
done
.
\
n
"
)
;
}
)
)
)
;
MOZ_FUZZING_NYX_PRINT
(
"
INFO
:
Performing
snapshot
.
.
.
\
n
"
)
;
Nyx
:
:
instance
(
)
.
start
(
)
;
uint32_t
expected_messages
=
0
;
IPCFuzzController
:
:
instance
(
)
.
useLastActor
=
0
;
IPCFuzzController
:
:
instance
(
)
.
useLastPortName
=
false
;
for
(
int
i
=
0
;
i
<
16
;
+
+
i
)
{
if
(
!
buffer
.
initLengthUninitialized
(
maxMsgSize
)
)
{
MOZ_REALLY_CRASH
(
__LINE__
)
;
}
uint32_t
bufsize
=
Nyx
:
:
instance
(
)
.
get_data
(
(
uint8_t
*
)
buffer
.
begin
(
)
buffer
.
length
(
)
)
;
if
(
bufsize
=
=
0xFFFFFFFF
)
{
MOZ_FUZZING_NYX_DEBUG
(
"
Iteration
complete
:
Out
of
data
.
\
n
"
)
;
break
;
}
bufsize
-
=
bufsize
%
4
;
if
(
bufsize
<
sizeof
(
IPC
:
:
Message
:
:
Header
)
+
controlLen
)
{
MOZ_FUZZING_NYX_DEBUG
(
"
INFO
:
Not
enough
data
to
craft
IPC
message
.
\
n
"
)
;
continue
;
}
buffer
.
shrinkTo
(
bufsize
)
;
const
uint8_t
*
controlData
=
(
uint8_t
*
)
buffer
.
begin
(
)
;
char
*
ipcMsgData
=
buffer
.
begin
(
)
+
controlLen
;
size_t
ipcMsgLen
=
buffer
.
length
(
)
-
controlLen
;
memcpy
(
ipcMsgData
IPCFuzzController
:
:
instance
(
)
.
sampleHeader
.
begin
(
)
sizeof
(
IPC
:
:
Message
:
:
Header
)
)
;
IPC
:
:
Message
:
:
Header
*
ipchdr
=
(
IPC
:
:
Message
:
:
Header
*
)
ipcMsgData
;
ipchdr
-
>
payload_size
=
ipcMsgLen
-
sizeof
(
IPC
:
:
Message
:
:
Header
)
;
PortName
new_port_name
;
int32_t
new_seqno
;
uint64_t
new_fseqno
;
int32_t
actorId
;
uint32_t
msgType
;
bool
isConstructor
;
uint8_t
portIndex
=
controlData
[
0
]
;
uint8_t
actorIndex
=
controlData
[
1
]
;
uint16_t
typeOffset
=
*
(
uint16_t
*
)
(
&
controlData
[
2
]
)
;
bool
isSync
=
controlData
[
4
]
>
127
;
uint8_t
portInstanceIndex
=
controlData
[
5
]
;
if
(
!
IPCFuzzController
:
:
instance
(
)
.
MakeTargetDecision
(
portIndex
portInstanceIndex
actorIndex
typeOffset
&
new_port_name
&
new_seqno
&
new_fseqno
&
actorId
&
msgType
&
isConstructor
)
)
{
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
MakeTargetDecision
returned
false
.
\
n
"
)
;
continue
;
}
if
(
Nyx
:
:
instance
(
)
.
is_replay
(
)
)
{
MOZ_FUZZING_NYX_PRINT
(
"
INFO
:
Replaying
IPC
packet
with
payload
:
\
n
"
)
;
for
(
uint32_t
i
=
0
;
i
<
ipcMsgLen
-
sizeof
(
IPC
:
:
Message
:
:
Header
)
;
+
+
i
)
{
if
(
i
%
16
=
=
0
)
{
MOZ_FUZZING_NYX_PRINT
(
"
\
n
"
)
;
}
MOZ_FUZZING_NYX_PRINTF
(
"
0x
%
02X
"
(
unsigned
char
)
(
ipcMsgData
[
sizeof
(
IPC
:
:
Message
:
:
Header
)
+
i
]
)
)
;
}
MOZ_FUZZING_NYX_PRINT
(
"
\
n
"
)
;
}
UniquePtr
<
IPC
:
:
Message
>
msg
(
new
IPC
:
:
Message
(
ipcMsgData
ipcMsgLen
)
)
;
if
(
isConstructor
)
{
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
Sending
constructor
message
.
.
.
\
n
"
)
;
msg
-
>
header
(
)
-
>
flags
.
SetConstructor
(
)
;
}
if
(
!
isConstructor
&
&
isSync
)
{
MOZ_FUZZING_NYX_DEBUG
(
"
INFO
:
Sending
sync
message
.
.
.
\
n
"
)
;
msg
-
>
header
(
)
-
>
flags
.
SetSync
(
)
;
}
msg
-
>
set_seqno
(
new_seqno
)
;
msg
-
>
set_routing_id
(
actorId
)
;
msg
-
>
header
(
)
-
>
type
=
msgType
;
auto
messageEvent
=
MakeUnique
<
UserMessageEvent
>
(
0
)
;
messageEvent
-
>
set_port_name
(
new_port_name
)
;
messageEvent
-
>
set_sequence_num
(
new_fseqno
)
;
Vector
<
char
256
InfallibleAllocPolicy
>
footerBuffer
;
(
void
)
footerBuffer
.
initLengthUninitialized
(
messageEvent
-
>
GetSerializedSize
(
)
)
;
messageEvent
-
>
Serialize
(
footerBuffer
.
begin
(
)
)
;
msg
-
>
WriteFooter
(
footerBuffer
.
begin
(
)
footerBuffer
.
length
(
)
)
;
msg
-
>
set_event_footer_size
(
footerBuffer
.
length
(
)
)
;
msg
-
>
SetFuzzMsg
(
)
;
#
ifdef
FUZZ_DEBUG
MOZ_FUZZING_NYX_PRINTF
(
"
DEBUG
:
OnEventMessage
iteration
%
d
EVS
:
%
u
Payload
:
%
u
.
\
n
"
i
ipchdr
-
>
event_footer_size
ipchdr
-
>
payload_size
)
;
#
endif
#
ifdef
FUZZ_DEBUG
MOZ_FUZZING_NYX_PRINTF
(
"
DEBUG
:
OnEventMessage
:
Port
%
lu
%
lu
.
Actor
%
d
\
n
"
new_port_name
.
v1
new_port_name
.
v2
actorId
)
;
MOZ_FUZZING_NYX_PRINTF
(
"
DEBUG
:
OnEventMessage
:
Flags
:
%
u
TxID
:
%
d
Handles
:
%
u
\
n
"
msg
-
>
header
(
)
-
>
flags
msg
-
>
header
(
)
-
>
txid
msg
-
>
header
(
)
-
>
num_handles
)
;
#
endif
expected_messages
+
+
;
#
if
MOZ_FUZZ_IPC_SYNC_INJECT
IPCFuzzController
:
:
instance
(
)
.
nodeChannel
-
>
OnMessageReceived
(
std
:
:
move
(
msg
)
)
;
#
else
XRE_GetIOMessageLoop
(
)
-
>
PostTask
(
NS_NewRunnableFunction
(
"
NodeChannel
:
:
OnMessageReceived
"
[
msg
=
std
:
:
move
(
msg
)
nodeChannel
=
RefPtr
{
IPCFuzzController
:
:
instance
(
)
.
nodeChannel
}
]
(
)
mutable
{
nodeChannel
-
>
OnMessageReceived
(
std
:
:
move
(
msg
)
)
;
}
)
)
;
#
endif
#
ifdef
MOZ_FUZZ_IPC_SYNC_AFTER_EACH_MSG
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
Synchronizing
after
message
.
.
.
\
n
"
)
;
IPCFuzzController
:
:
instance
(
)
.
SynchronizeOnMessageExecution
(
expected_messages
)
;
#
else
if
(
isConstructor
)
{
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
Synchronizing
due
to
constructor
message
.
.
.
\
n
"
)
;
IPCFuzzController
:
:
instance
(
)
.
SynchronizeOnMessageExecution
(
expected_messages
)
;
}
#
endif
}
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
Synchronizing
due
to
end
of
iteration
.
.
.
\
n
"
)
;
IPCFuzzController
:
:
instance
(
)
.
SynchronizeOnMessageExecution
(
expected_messages
)
;
MOZ_FUZZING_NYX_DEBUG
(
"
DEBUG
:
=
=
=
=
=
=
=
=
END
OF
ITERATION
(
RELEASE
)
=
=
=
=
=
=
=
=
\
n
"
)
;
Nyx
:
:
instance
(
)
.
release
(
IPCFuzzController
:
:
instance
(
)
.
getMessageStopCount
(
)
)
;
return
NS_OK
;
}
void
IPCFuzzController
:
:
SynchronizeOnMessageExecution
(
uint32_t
expected_messages
)
{
int
hang_timeout
=
10
*
1000
;
while
(
IPCFuzzController
:
:
instance
(
)
.
getMessageStopCount
(
)
!
=
expected_messages
)
{
#
ifdef
FUZZ_DEBUG
uint32_t
count_stopped
=
IPCFuzzController
:
:
instance
(
)
.
getMessageStopCount
(
)
;
uint32_t
count_live
=
IPCFuzzController
:
:
instance
(
)
.
getMessageStartCount
(
)
;
MOZ_FUZZING_NYX_PRINTF
(
"
DEBUG
:
Post
Constructor
:
%
d
stopped
messages
(
%
d
live
%
d
"
"
expected
)
!
\
n
"
count_stopped
count_live
expected_messages
)
;
#
endif
PR_Sleep
(
PR_MillisecondsToInterval
(
50
)
)
;
hang_timeout
-
=
50
;
if
(
hang_timeout
<
=
0
)
{
Nyx
:
:
instance
(
)
.
handle_event
(
"
MOZ_TIMEOUT
"
nullptr
0
nullptr
)
;
MOZ_FUZZING_NYX_PRINT
(
"
ERROR
:
=
=
=
=
=
=
=
=
END
OF
ITERATION
(
TIMEOUT
)
=
=
=
=
=
=
=
=
\
n
"
)
;
Nyx
:
:
instance
(
)
.
release
(
IPCFuzzController
:
:
instance
(
)
.
getMessageStopCount
(
)
)
;
}
}
}
}
}
