#
include
"
Performance
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsRFPService
.
h
"
#
include
"
PerformanceEntry
.
h
"
#
include
"
PerformanceMainThread
.
h
"
#
include
"
PerformanceMark
.
h
"
#
include
"
PerformanceMeasure
.
h
"
#
include
"
PerformanceObserver
.
h
"
#
include
"
PerformanceResourceTiming
.
h
"
#
include
"
PerformanceService
.
h
"
#
include
"
PerformanceWorker
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceBinding
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceEntryEvent
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceNavigationBinding
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceObserverBinding
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceNavigationTiming
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRunnable
.
h
"
#
include
"
mozilla
/
dom
/
WorkerScope
.
h
"
#
define
PERFLOG
(
msg
.
.
.
)
printf_stderr
(
msg
#
#
__VA_ARGS__
)
namespace
mozilla
:
:
dom
{
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Performance
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
Performance
DOMEventTargetHelper
mUserEntries
mResourceEntries
mSecondaryResourceEntries
mObservers
)
;
NS_IMPL_ADDREF_INHERITED
(
Performance
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
Performance
DOMEventTargetHelper
)
already_AddRefed
<
Performance
>
Performance
:
:
CreateForMainThread
(
nsPIDOMWindowInner
*
aWindow
nsIPrincipal
*
aPrincipal
nsDOMNavigationTiming
*
aDOMTiming
nsITimedChannel
*
aChannel
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aWindow
-
>
AsGlobal
(
)
)
;
RefPtr
<
Performance
>
performance
=
new
PerformanceMainThread
(
aWindow
aDOMTiming
aChannel
aPrincipal
-
>
IsSystemPrincipal
(
)
)
;
return
performance
.
forget
(
)
;
}
already_AddRefed
<
Performance
>
Performance
:
:
CreateForWorker
(
WorkerPrivate
*
aWorkerPrivate
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
RefPtr
<
Performance
>
performance
=
new
PerformanceWorker
(
aWorkerPrivate
)
;
return
performance
.
forget
(
)
;
}
already_AddRefed
<
Performance
>
Performance
:
:
Get
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
)
{
RefPtr
<
Performance
>
performance
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aGlobal
)
;
if
(
window
)
{
performance
=
window
-
>
GetPerformance
(
)
;
}
else
{
const
WorkerPrivate
*
workerPrivate
=
GetWorkerPrivateFromContext
(
aCx
)
;
if
(
!
workerPrivate
)
{
return
nullptr
;
}
WorkerGlobalScope
*
scope
=
workerPrivate
-
>
GlobalScope
(
)
;
MOZ_ASSERT
(
scope
)
;
performance
=
scope
-
>
GetPerformance
(
)
;
}
return
performance
.
forget
(
)
;
}
Performance
:
:
Performance
(
nsIGlobalObject
*
aGlobal
bool
aSystemPrincipal
)
:
DOMEventTargetHelper
(
aGlobal
)
mResourceTimingBufferSize
(
kDefaultResourceTimingBufferSize
)
mPendingNotificationObserversTask
(
false
)
mPendingResourceTimingBufferFullEvent
(
false
)
mSystemPrincipal
(
aSystemPrincipal
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
}
Performance
:
:
Performance
(
nsPIDOMWindowInner
*
aWindow
bool
aSystemPrincipal
)
:
DOMEventTargetHelper
(
aWindow
)
mResourceTimingBufferSize
(
kDefaultResourceTimingBufferSize
)
mPendingNotificationObserversTask
(
false
)
mPendingResourceTimingBufferFullEvent
(
false
)
mSystemPrincipal
(
aSystemPrincipal
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
Performance
:
:
~
Performance
(
)
=
default
;
DOMHighResTimeStamp
Performance
:
:
TimeStampToDOMHighResForRendering
(
TimeStamp
aTimeStamp
)
const
{
DOMHighResTimeStamp
stamp
=
GetDOMTiming
(
)
-
>
TimeStampToDOMHighRes
(
aTimeStamp
)
;
if
(
!
IsSystemPrincipal
(
)
)
{
return
nsRFPService
:
:
ReduceTimePrecisionAsMSecsRFPOnly
(
stamp
0
)
;
}
return
stamp
;
}
DOMHighResTimeStamp
Performance
:
:
Now
(
)
{
DOMHighResTimeStamp
rawTime
=
NowUnclamped
(
)
;
if
(
mSystemPrincipal
)
{
return
rawTime
;
}
return
nsRFPService
:
:
ReduceTimePrecisionAsMSecs
(
rawTime
GetRandomTimelineSeed
(
)
mSystemPrincipal
CrossOriginIsolated
(
)
)
;
}
DOMHighResTimeStamp
Performance
:
:
NowUnclamped
(
)
const
{
TimeDuration
duration
=
TimeStamp
:
:
Now
(
)
-
CreationTimeStamp
(
)
;
return
duration
.
ToMilliseconds
(
)
;
}
DOMHighResTimeStamp
Performance
:
:
TimeOrigin
(
)
{
if
(
!
mPerformanceService
)
{
mPerformanceService
=
PerformanceService
:
:
GetOrCreate
(
)
;
}
MOZ_ASSERT
(
mPerformanceService
)
;
DOMHighResTimeStamp
rawTimeOrigin
=
mPerformanceService
-
>
TimeOrigin
(
CreationTimeStamp
(
)
)
;
return
nsRFPService
:
:
ReduceTimePrecisionAsMSecs
(
rawTimeOrigin
0
mSystemPrincipal
CrossOriginIsolated
(
)
)
;
}
JSObject
*
Performance
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
Performance_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
Performance
:
:
GetEntries
(
nsTArray
<
RefPtr
<
PerformanceEntry
>
>
&
aRetval
)
{
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
)
{
aRetval
.
Clear
(
)
;
return
;
}
aRetval
=
mResourceEntries
.
Clone
(
)
;
aRetval
.
AppendElements
(
mUserEntries
)
;
aRetval
.
Sort
(
PerformanceEntryComparator
(
)
)
;
}
void
Performance
:
:
GetEntriesByType
(
const
nsAString
&
aEntryType
nsTArray
<
RefPtr
<
PerformanceEntry
>
>
&
aRetval
)
{
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
)
{
aRetval
.
Clear
(
)
;
return
;
}
if
(
aEntryType
.
EqualsLiteral
(
"
resource
"
)
)
{
aRetval
=
mResourceEntries
.
Clone
(
)
;
return
;
}
aRetval
.
Clear
(
)
;
if
(
aEntryType
.
EqualsLiteral
(
"
mark
"
)
|
|
aEntryType
.
EqualsLiteral
(
"
measure
"
)
)
{
RefPtr
<
nsAtom
>
entryType
=
NS_Atomize
(
aEntryType
)
;
for
(
PerformanceEntry
*
entry
:
mUserEntries
)
{
if
(
entry
-
>
GetEntryType
(
)
=
=
entryType
)
{
aRetval
.
AppendElement
(
entry
)
;
}
}
}
}
void
Performance
:
:
GetEntriesByName
(
const
nsAString
&
aName
const
Optional
<
nsAString
>
&
aEntryType
nsTArray
<
RefPtr
<
PerformanceEntry
>
>
&
aRetval
)
{
aRetval
.
Clear
(
)
;
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
)
{
return
;
}
RefPtr
<
nsAtom
>
name
=
NS_Atomize
(
aName
)
;
RefPtr
<
nsAtom
>
entryType
=
aEntryType
.
WasPassed
(
)
?
NS_Atomize
(
aEntryType
.
Value
(
)
)
:
nullptr
;
if
(
entryType
)
{
if
(
entryType
=
=
nsGkAtoms
:
:
mark
|
|
entryType
=
=
nsGkAtoms
:
:
measure
)
{
for
(
PerformanceEntry
*
entry
:
mUserEntries
)
{
if
(
entry
-
>
GetName
(
)
=
=
name
&
&
entry
-
>
GetEntryType
(
)
=
=
entryType
)
{
aRetval
.
AppendElement
(
entry
)
;
}
}
return
;
}
if
(
entryType
=
=
nsGkAtoms
:
:
resource
)
{
for
(
PerformanceEntry
*
entry
:
mResourceEntries
)
{
MOZ_ASSERT
(
entry
-
>
GetEntryType
(
)
=
=
entryType
)
;
if
(
entry
-
>
GetName
(
)
=
=
name
)
{
aRetval
.
AppendElement
(
entry
)
;
}
}
return
;
}
return
;
}
nsTArray
<
PerformanceEntry
*
>
qualifiedResourceEntries
;
nsTArray
<
PerformanceEntry
*
>
qualifiedUserEntries
;
for
(
PerformanceEntry
*
entry
:
mResourceEntries
)
{
if
(
entry
-
>
GetName
(
)
=
=
name
)
{
qualifiedResourceEntries
.
AppendElement
(
entry
)
;
}
}
for
(
PerformanceEntry
*
entry
:
mUserEntries
)
{
if
(
entry
-
>
GetName
(
)
=
=
name
)
{
qualifiedUserEntries
.
AppendElement
(
entry
)
;
}
}
size_t
resourceEntriesIdx
=
0
userEntriesIdx
=
0
;
aRetval
.
SetCapacity
(
qualifiedResourceEntries
.
Length
(
)
+
qualifiedUserEntries
.
Length
(
)
)
;
PerformanceEntryComparator
comparator
;
while
(
resourceEntriesIdx
<
qualifiedResourceEntries
.
Length
(
)
&
&
userEntriesIdx
<
qualifiedUserEntries
.
Length
(
)
)
{
if
(
comparator
.
LessThan
(
qualifiedResourceEntries
[
resourceEntriesIdx
]
qualifiedUserEntries
[
userEntriesIdx
]
)
)
{
aRetval
.
AppendElement
(
qualifiedResourceEntries
[
resourceEntriesIdx
]
)
;
+
+
resourceEntriesIdx
;
}
else
{
aRetval
.
AppendElement
(
qualifiedUserEntries
[
userEntriesIdx
]
)
;
+
+
userEntriesIdx
;
}
}
while
(
resourceEntriesIdx
<
qualifiedResourceEntries
.
Length
(
)
)
{
aRetval
.
AppendElement
(
qualifiedResourceEntries
[
resourceEntriesIdx
]
)
;
+
+
resourceEntriesIdx
;
}
while
(
userEntriesIdx
<
qualifiedUserEntries
.
Length
(
)
)
{
aRetval
.
AppendElement
(
qualifiedUserEntries
[
userEntriesIdx
]
)
;
+
+
userEntriesIdx
;
}
}
void
Performance
:
:
GetEntriesByTypeForObserver
(
const
nsAString
&
aEntryType
nsTArray
<
RefPtr
<
PerformanceEntry
>
>
&
aRetval
)
{
GetEntriesByType
(
aEntryType
aRetval
)
;
}
void
Performance
:
:
ClearUserEntries
(
const
Optional
<
nsAString
>
&
aEntryName
const
nsAString
&
aEntryType
)
{
MOZ_ASSERT
(
!
aEntryType
.
IsEmpty
(
)
)
;
RefPtr
<
nsAtom
>
name
=
aEntryName
.
WasPassed
(
)
?
NS_Atomize
(
aEntryName
.
Value
(
)
)
:
nullptr
;
RefPtr
<
nsAtom
>
entryType
=
NS_Atomize
(
aEntryType
)
;
mUserEntries
.
RemoveElementsBy
(
[
name
entryType
]
(
const
auto
&
entry
)
{
return
(
!
name
|
|
entry
-
>
GetName
(
)
=
=
name
)
&
&
(
entry
-
>
GetEntryType
(
)
=
=
entryType
)
;
}
)
;
}
void
Performance
:
:
ClearResourceTimings
(
)
{
mResourceEntries
.
Clear
(
)
;
}
struct
UserTimingMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
UserTiming
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
ProfilerString16View
&
aName
bool
aIsMeasure
const
Maybe
<
ProfilerString16View
>
&
aStartMark
const
Maybe
<
ProfilerString16View
>
&
aEndMark
)
{
aWriter
.
StringProperty
(
"
name
"
NS_ConvertUTF16toUTF8
(
aName
)
)
;
if
(
aIsMeasure
)
{
aWriter
.
StringProperty
(
"
entryType
"
"
measure
"
)
;
}
else
{
aWriter
.
StringProperty
(
"
entryType
"
"
mark
"
)
;
}
if
(
aStartMark
.
isSome
(
)
)
{
aWriter
.
StringProperty
(
"
startMark
"
NS_ConvertUTF16toUTF8
(
*
aStartMark
)
)
;
}
else
{
aWriter
.
NullProperty
(
"
startMark
"
)
;
}
if
(
aEndMark
.
isSome
(
)
)
{
aWriter
.
StringProperty
(
"
endMark
"
NS_ConvertUTF16toUTF8
(
*
aEndMark
)
)
;
}
else
{
aWriter
.
NullProperty
(
"
endMark
"
)
;
}
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
SetAllLabels
(
"
{
marker
.
data
.
name
}
"
)
;
schema
.
AddStaticLabelValue
(
"
Marker
"
"
UserTiming
"
)
;
schema
.
AddKeyLabelFormat
(
"
entryType
"
"
Entry
Type
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddKeyLabelFormat
(
"
name
"
"
Name
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddKeyLabelFormat
(
"
startMark
"
"
Start
Mark
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddKeyLabelFormat
(
"
endMark
"
"
End
Mark
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddStaticLabelValue
(
"
Description
"
"
UserTimingMeasure
is
created
using
the
DOM
API
"
"
performance
.
measure
(
)
.
"
)
;
return
schema
;
}
}
;
already_AddRefed
<
PerformanceMark
>
Performance
:
:
Mark
(
JSContext
*
aCx
const
nsAString
&
aName
const
PerformanceMarkOptions
&
aMarkOptions
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
parent
=
GetParentObject
(
)
;
if
(
!
parent
|
|
parent
-
>
IsDying
(
)
|
|
!
parent
-
>
HasJSGlobal
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Global
object
is
unavailable
"
)
;
return
nullptr
;
}
GlobalObject
global
(
aCx
parent
-
>
GetGlobalJSObject
(
)
)
;
if
(
global
.
Failed
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Global
object
is
unavailable
"
)
;
return
nullptr
;
}
RefPtr
<
PerformanceMark
>
performanceMark
=
PerformanceMark
:
:
Constructor
(
global
aName
aMarkOptions
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
!
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
)
{
InsertUserEntry
(
performanceMark
)
;
}
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
Maybe
<
uint64_t
>
innerWindowId
;
if
(
GetOwner
(
)
)
{
innerWindowId
=
Some
(
GetOwner
(
)
-
>
WindowID
(
)
)
;
}
profiler_add_marker
(
"
UserTiming
"
geckoprofiler
:
:
category
:
:
DOM
MarkerInnerWindowId
(
innerWindowId
)
UserTimingMarker
{
}
aName
false
Nothing
{
}
Nothing
{
}
)
;
}
return
performanceMark
.
forget
(
)
;
}
void
Performance
:
:
ClearMarks
(
const
Optional
<
nsAString
>
&
aName
)
{
ClearUserEntries
(
aName
u
"
mark
"
_ns
)
;
}
DOMHighResTimeStamp
Performance
:
:
ResolveTimestampFromName
(
const
nsAString
&
aName
ErrorResult
&
aRv
)
{
AutoTArray
<
RefPtr
<
PerformanceEntry
>
1
>
arr
;
Optional
<
nsAString
>
typeParam
;
nsAutoString
str
;
str
.
AssignLiteral
(
"
mark
"
)
;
typeParam
=
&
str
;
GetEntriesByName
(
aName
typeParam
arr
)
;
if
(
!
arr
.
IsEmpty
(
)
)
{
return
arr
.
LastElement
(
)
-
>
StartTime
(
)
;
}
if
(
!
IsPerformanceTimingAttribute
(
aName
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
0
;
}
DOMHighResTimeStamp
ts
=
GetPerformanceTimingFromString
(
aName
)
;
if
(
!
ts
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_ACCESS_ERR
)
;
return
0
;
}
return
ts
-
CreationTime
(
)
;
}
void
Performance
:
:
Measure
(
const
nsAString
&
aName
const
Optional
<
nsAString
>
&
aStartMark
const
Optional
<
nsAString
>
&
aEndMark
ErrorResult
&
aRv
)
{
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
)
{
return
;
}
DOMHighResTimeStamp
startTime
;
DOMHighResTimeStamp
endTime
;
if
(
aStartMark
.
WasPassed
(
)
)
{
startTime
=
ResolveTimestampFromName
(
aStartMark
.
Value
(
)
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
}
else
{
startTime
=
0
;
}
if
(
aEndMark
.
WasPassed
(
)
)
{
endTime
=
ResolveTimestampFromName
(
aEndMark
.
Value
(
)
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
}
else
{
endTime
=
Now
(
)
;
}
RefPtr
<
PerformanceMeasure
>
performanceMeasure
=
new
PerformanceMeasure
(
GetParentObject
(
)
aName
startTime
endTime
)
;
InsertUserEntry
(
performanceMeasure
)
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
TimeStamp
startTimeStamp
=
CreationTimeStamp
(
)
+
TimeDuration
:
:
FromMilliseconds
(
startTime
)
;
TimeStamp
endTimeStamp
=
CreationTimeStamp
(
)
+
TimeDuration
:
:
FromMilliseconds
(
endTime
)
;
Maybe
<
nsString
>
startMark
;
if
(
aStartMark
.
WasPassed
(
)
)
{
startMark
.
emplace
(
aStartMark
.
Value
(
)
)
;
}
Maybe
<
nsString
>
endMark
;
if
(
aEndMark
.
WasPassed
(
)
)
{
endMark
.
emplace
(
aEndMark
.
Value
(
)
)
;
}
Maybe
<
uint64_t
>
innerWindowId
;
if
(
GetOwner
(
)
)
{
innerWindowId
=
Some
(
GetOwner
(
)
-
>
WindowID
(
)
)
;
}
profiler_add_marker
(
"
UserTiming
"
geckoprofiler
:
:
category
:
:
DOM
{
MarkerTiming
:
:
Interval
(
startTimeStamp
endTimeStamp
)
MarkerInnerWindowId
(
innerWindowId
)
}
UserTimingMarker
{
}
aName
true
startMark
endMark
)
;
}
}
void
Performance
:
:
ClearMeasures
(
const
Optional
<
nsAString
>
&
aName
)
{
ClearUserEntries
(
aName
u
"
measure
"
_ns
)
;
}
void
Performance
:
:
LogEntry
(
PerformanceEntry
*
aEntry
const
nsACString
&
aOwner
)
const
{
PERFLOG
(
"
Performance
Entry
:
%
s
|
%
s
|
%
s
|
%
f
|
%
f
|
%
"
PRIu64
"
\
n
"
aOwner
.
BeginReading
(
)
NS_ConvertUTF16toUTF8
(
aEntry
-
>
GetEntryType
(
)
-
>
GetUTF16String
(
)
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aEntry
-
>
GetName
(
)
-
>
GetUTF16String
(
)
)
.
get
(
)
aEntry
-
>
StartTime
(
)
aEntry
-
>
Duration
(
)
static_cast
<
uint64_t
>
(
PR_Now
(
)
/
PR_USEC_PER_MSEC
)
)
;
}
void
Performance
:
:
TimingNotification
(
PerformanceEntry
*
aEntry
const
nsACString
&
aOwner
uint64_t
aEpoch
)
{
PerformanceEntryEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
aEntry
-
>
GetName
(
init
.
mName
)
;
aEntry
-
>
GetEntryType
(
init
.
mEntryType
)
;
init
.
mStartTime
=
aEntry
-
>
StartTime
(
)
;
init
.
mDuration
=
aEntry
-
>
Duration
(
)
;
init
.
mEpoch
=
aEpoch
;
CopyUTF8toUTF16
(
aOwner
init
.
mOrigin
)
;
RefPtr
<
PerformanceEntryEvent
>
perfEntryEvent
=
PerformanceEntryEvent
:
:
Constructor
(
this
u
"
performanceentry
"
_ns
init
)
;
nsCOMPtr
<
EventTarget
>
et
=
do_QueryInterface
(
GetOwner
(
)
)
;
if
(
et
)
{
et
-
>
DispatchEvent
(
*
perfEntryEvent
)
;
}
}
void
Performance
:
:
InsertUserEntry
(
PerformanceEntry
*
aEntry
)
{
mUserEntries
.
InsertElementSorted
(
aEntry
PerformanceEntryComparator
(
)
)
;
QueueEntry
(
aEntry
)
;
}
void
Performance
:
:
BufferEvent
(
)
{
while
(
!
mSecondaryResourceEntries
.
IsEmpty
(
)
)
{
uint32_t
secondaryResourceEntriesBeforeCount
=
0
;
uint32_t
secondaryResourceEntriesAfterCount
=
0
;
secondaryResourceEntriesBeforeCount
=
mSecondaryResourceEntries
.
Length
(
)
;
if
(
!
CanAddResourceTimingEntry
(
)
)
{
DispatchBufferFullEvent
(
)
;
}
while
(
!
mSecondaryResourceEntries
.
IsEmpty
(
)
&
&
CanAddResourceTimingEntry
(
)
)
{
mResourceEntries
.
InsertElementSorted
(
mSecondaryResourceEntries
.
ElementAt
(
0
)
PerformanceEntryComparator
(
)
)
;
mSecondaryResourceEntries
.
RemoveElementAt
(
0
)
;
}
secondaryResourceEntriesAfterCount
=
mSecondaryResourceEntries
.
Length
(
)
;
if
(
secondaryResourceEntriesBeforeCount
<
=
secondaryResourceEntriesAfterCount
)
{
mSecondaryResourceEntries
.
Clear
(
)
;
break
;
}
}
mPendingResourceTimingBufferFullEvent
=
false
;
}
void
Performance
:
:
SetResourceTimingBufferSize
(
uint64_t
aMaxSize
)
{
mResourceTimingBufferSize
=
aMaxSize
;
}
MOZ_ALWAYS_INLINE
bool
Performance
:
:
CanAddResourceTimingEntry
(
)
{
return
mResourceEntries
.
Length
(
)
<
mResourceTimingBufferSize
;
}
void
Performance
:
:
InsertResourceEntry
(
PerformanceEntry
*
aEntry
)
{
MOZ_ASSERT
(
aEntry
)
;
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
)
{
return
;
}
if
(
CanAddResourceTimingEntry
(
)
&
&
!
mPendingResourceTimingBufferFullEvent
)
{
mResourceEntries
.
InsertElementSorted
(
aEntry
PerformanceEntryComparator
(
)
)
;
QueueEntry
(
aEntry
)
;
return
;
}
if
(
!
mPendingResourceTimingBufferFullEvent
)
{
mPendingResourceTimingBufferFullEvent
=
true
;
NS_DispatchToCurrentThread
(
NewCancelableRunnableMethod
(
"
Performance
:
:
BufferEvent
"
this
&
Performance
:
:
BufferEvent
)
)
;
}
mSecondaryResourceEntries
.
InsertElementSorted
(
aEntry
PerformanceEntryComparator
(
)
)
;
}
void
Performance
:
:
AddObserver
(
PerformanceObserver
*
aObserver
)
{
mObservers
.
AppendElementUnlessExists
(
aObserver
)
;
}
void
Performance
:
:
RemoveObserver
(
PerformanceObserver
*
aObserver
)
{
mObservers
.
RemoveElement
(
aObserver
)
;
}
void
Performance
:
:
NotifyObservers
(
)
{
mPendingNotificationObserversTask
=
false
;
NS_OBSERVER_ARRAY_NOTIFY_XPCOM_OBSERVERS
(
mObservers
Notify
(
)
)
;
}
void
Performance
:
:
CancelNotificationObservers
(
)
{
mPendingNotificationObserversTask
=
false
;
}
class
NotifyObserversTask
final
:
public
CancelableRunnable
{
public
:
explicit
NotifyObserversTask
(
Performance
*
aPerformance
)
:
CancelableRunnable
(
"
dom
:
:
NotifyObserversTask
"
)
mPerformance
(
aPerformance
)
{
MOZ_ASSERT
(
mPerformance
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
mPerformance
)
;
RefPtr
<
Performance
>
performance
(
mPerformance
)
;
performance
-
>
NotifyObservers
(
)
;
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
mPerformance
-
>
CancelNotificationObservers
(
)
;
mPerformance
=
nullptr
;
return
NS_OK
;
}
private
:
~
NotifyObserversTask
(
)
=
default
;
RefPtr
<
Performance
>
mPerformance
;
}
;
void
Performance
:
:
QueueNotificationObserversTask
(
)
{
if
(
!
mPendingNotificationObserversTask
)
{
RunNotificationObserversTask
(
)
;
}
}
void
Performance
:
:
RunNotificationObserversTask
(
)
{
mPendingNotificationObserversTask
=
true
;
nsCOMPtr
<
nsIRunnable
>
task
=
new
NotifyObserversTask
(
this
)
;
nsresult
rv
;
if
(
GetOwnerGlobal
(
)
)
{
rv
=
GetOwnerGlobal
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
task
.
forget
(
)
)
;
}
else
{
rv
=
NS_DispatchToCurrentThread
(
task
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mPendingNotificationObserversTask
=
false
;
}
}
void
Performance
:
:
QueueEntry
(
PerformanceEntry
*
aEntry
)
{
nsTObserverArray
<
PerformanceObserver
*
>
interestedObservers
;
if
(
!
mObservers
.
IsEmpty
(
)
)
{
const
auto
[
begin
end
]
=
mObservers
.
NonObservingRange
(
)
;
std
:
:
copy_if
(
begin
end
MakeBackInserter
(
interestedObservers
)
[
aEntry
]
(
PerformanceObserver
*
observer
)
{
return
observer
-
>
ObservesTypeOfEntry
(
aEntry
)
;
}
)
;
}
NS_OBSERVER_ARRAY_NOTIFY_XPCOM_OBSERVERS
(
interestedObservers
QueueEntry
(
aEntry
)
)
;
aEntry
-
>
BufferEntryIfNeeded
(
)
;
if
(
!
interestedObservers
.
IsEmpty
(
)
)
{
QueueNotificationObserversTask
(
)
;
}
}
void
Performance
:
:
MemoryPressure
(
)
{
mUserEntries
.
Clear
(
)
;
}
size_t
Performance
:
:
SizeOfUserEntries
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
userEntries
=
0
;
for
(
const
PerformanceEntry
*
entry
:
mUserEntries
)
{
userEntries
+
=
entry
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
userEntries
;
}
size_t
Performance
:
:
SizeOfResourceEntries
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
resourceEntries
=
0
;
for
(
const
PerformanceEntry
*
entry
:
mResourceEntries
)
{
resourceEntries
+
=
entry
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
resourceEntries
;
}
}
