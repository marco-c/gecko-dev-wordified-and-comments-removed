#
ifndef
mozilla_dom_PerformanceMainThread_h
#
define
mozilla_dom_PerformanceMainThread_h
#
include
"
Performance
.
h
"
#
include
"
PerformanceStorage
.
h
"
#
include
"
LargestContentfulPaint
.
h
"
#
include
"
nsTextFrame
.
h
"
namespace
mozilla
:
:
dom
{
class
PerformanceNavigationTiming
;
class
PerformanceEventTiming
;
using
ImageLCPEntryMap
=
nsTHashMap
<
LCPEntryHashEntry
RefPtr
<
LargestContentfulPaint
>
>
;
using
TextFrameUnions
=
nsTHashMap
<
nsRefPtrHashKey
<
Element
>
nsRect
>
;
class
PerformanceMainThread
final
:
public
Performance
public
PerformanceStorage
{
public
:
PerformanceMainThread
(
nsPIDOMWindowInner
*
aWindow
nsDOMNavigationTiming
*
aDOMTiming
nsITimedChannel
*
aChannel
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED
(
PerformanceMainThread
Performance
)
PerformanceStorage
*
AsPerformanceStorage
(
)
override
{
return
this
;
}
virtual
PerformanceTiming
*
Timing
(
)
override
;
virtual
PerformanceNavigation
*
Navigation
(
)
override
;
virtual
void
AddEntry
(
nsIHttpChannel
*
channel
nsITimedChannel
*
timedChannel
)
override
;
virtual
void
AddEntry
(
const
nsString
&
entryName
const
nsString
&
initiatorType
UniquePtr
<
PerformanceTimingData
>
&
&
aData
)
override
;
void
AddRawEntry
(
UniquePtr
<
PerformanceTimingData
>
aPerformanceTimingData
const
nsAString
&
aInitiatorType
const
nsAString
&
aEntryName
)
;
virtual
void
SetFCPTimingEntry
(
PerformancePaintTiming
*
aEntry
)
override
;
bool
HadFCPTimingEntry
(
)
const
{
return
mFCPTiming
;
}
void
InsertEventTimingEntry
(
PerformanceEventTiming
*
)
override
;
void
BufferEventTimingEntryIfNeeded
(
PerformanceEventTiming
*
)
override
;
void
DispatchPendingEventTimingEntries
(
)
override
;
void
BufferLargestContentfulPaintEntryIfNeeded
(
LargestContentfulPaint
*
)
;
TimeStamp
CreationTimeStamp
(
)
const
override
;
DOMHighResTimeStamp
CreationTime
(
)
const
override
;
virtual
void
GetMozMemory
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aObj
)
override
;
virtual
nsDOMNavigationTiming
*
GetDOMTiming
(
)
const
override
{
return
mDOMTiming
;
}
virtual
uint64_t
GetRandomTimelineSeed
(
)
override
{
return
GetDOMTiming
(
)
-
>
GetRandomTimelineSeed
(
)
;
}
virtual
nsITimedChannel
*
GetChannel
(
)
const
override
{
return
mChannel
;
}
virtual
void
GetEntries
(
nsTArray
<
RefPtr
<
PerformanceEntry
>
>
&
aRetval
)
override
;
virtual
void
GetEntriesByType
(
const
nsAString
&
aEntryType
nsTArray
<
RefPtr
<
PerformanceEntry
>
>
&
aRetval
)
override
;
void
GetEntriesByTypeForObserver
(
const
nsAString
&
aEntryType
nsTArray
<
RefPtr
<
PerformanceEntry
>
>
&
aRetval
)
override
;
virtual
void
GetEntriesByName
(
const
nsAString
&
aName
const
Optional
<
nsAString
>
&
aEntryType
nsTArray
<
RefPtr
<
PerformanceEntry
>
>
&
aRetval
)
override
;
void
UpdateNavigationTimingEntry
(
)
override
;
void
QueueNavigationTimingEntry
(
)
override
;
void
QueueLargestContentfulPaintEntry
(
LargestContentfulPaint
*
aEntry
)
;
size_t
SizeOfEventEntries
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
;
static
constexpr
uint32_t
kDefaultEventTimingBufferSize
=
150
;
static
constexpr
uint32_t
kDefaultEventTimingDurationThreshold
=
104
;
static
constexpr
double
kDefaultEventTimingMinDuration
=
16
.
0
;
static
constexpr
uint32_t
kMaxLargestContentfulPaintBufferSize
=
150
;
class
EventCounts
*
EventCounts
(
)
override
;
bool
IsGlobalObjectWindow
(
)
const
override
{
return
true
;
}
;
bool
HasDispatchedInputEvent
(
)
const
{
return
mHasDispatchedInputEvent
;
}
void
SetHasDispatchedScrollEvent
(
)
;
bool
HasDispatchedScrollEvent
(
)
const
{
return
mHasDispatchedScrollEvent
;
}
void
ProcessElementTiming
(
)
;
void
AddImagesPendingRendering
(
ImagePendingRendering
aImagePendingRendering
)
{
mImagesPendingRendering
.
AppendElement
(
aImagePendingRendering
)
;
}
void
StoreImageLCPEntry
(
Element
*
aElement
imgRequestProxy
*
aImgRequestProxy
LargestContentfulPaint
*
aEntry
)
;
already_AddRefed
<
LargestContentfulPaint
>
GetImageLCPEntry
(
Element
*
aElement
imgRequestProxy
*
aImgRequestProxy
)
;
bool
UpdateLargestContentfulPaintSize
(
double
aSize
)
;
double
GetLargestContentfulPaintSize
(
)
const
{
return
mLargestContentfulPaintSize
;
}
nsTHashMap
<
nsRefPtrHashKey
<
Element
>
nsRect
>
&
GetTextFrameUnions
(
)
{
return
mTextFrameUnions
;
}
void
FinalizeLCPEntriesForText
(
)
;
protected
:
~
PerformanceMainThread
(
)
;
void
CreateNavigationTimingEntry
(
)
;
void
InsertUserEntry
(
PerformanceEntry
*
aEntry
)
override
;
DOMHighResTimeStamp
GetPerformanceTimingFromString
(
const
nsAString
&
aTimingName
)
override
;
void
DispatchBufferFullEvent
(
)
override
;
RefPtr
<
PerformanceNavigationTiming
>
mDocEntry
;
RefPtr
<
nsDOMNavigationTiming
>
mDOMTiming
;
nsCOMPtr
<
nsITimedChannel
>
mChannel
;
RefPtr
<
PerformanceTiming
>
mTiming
;
RefPtr
<
PerformanceNavigation
>
mNavigation
;
RefPtr
<
PerformancePaintTiming
>
mFCPTiming
;
JS
:
:
Heap
<
JSObject
*
>
mMozMemory
;
nsTArray
<
RefPtr
<
PerformanceEventTiming
>
>
mEventTimingEntries
;
nsTArray
<
RefPtr
<
LargestContentfulPaint
>
>
mLargestContentfulPaintEntries
;
AutoCleanLinkedList
<
RefPtr
<
PerformanceEventTiming
>
>
mPendingEventTimingEntries
;
bool
mHasDispatchedInputEvent
=
false
;
bool
mHasDispatchedScrollEvent
=
false
;
RefPtr
<
PerformanceEventTiming
>
mFirstInputEvent
;
RefPtr
<
PerformanceEventTiming
>
mPendingPointerDown
;
private
:
void
ClearGeneratedTempDataForLCP
(
)
;
void
SetHasDispatchedInputEvent
(
)
;
bool
mHasQueuedRefreshdriverObserver
=
false
;
RefPtr
<
class
EventCounts
>
mEventCounts
;
void
IncEventCount
(
const
nsAtom
*
aType
)
;
PresShell
*
GetPresShell
(
)
;
nsTArray
<
ImagePendingRendering
>
mImagesPendingRendering
;
ImageLCPEntryMap
mImageLCPEntryMap
;
double
mLargestContentfulPaintSize
=
0
.
0
;
TextFrameUnions
mTextFrameUnions
;
}
;
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
ImageLCPEntryMap
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
for
(
auto
&
entry
:
aField
)
{
ImplCycleCollectionTraverse
(
aCallback
entry
.
mKey
"
ImageLCPEntryMap
.
mKey
"
aCallback
.
Flags
(
)
)
;
RefPtr
<
LargestContentfulPaint
>
*
lcpEntry
=
entry
.
GetModifiableData
(
)
;
ImplCycleCollectionTraverse
(
aCallback
*
lcpEntry
"
ImageLCPEntryMap
.
mData
"
aCallback
.
Flags
(
)
)
;
}
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
TextFrameUnions
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
for
(
auto
&
entry
:
aField
)
{
ImplCycleCollectionTraverse
(
aCallback
entry
"
TextFrameUnions
'
s
key
(
nsRefPtrHashKey
<
Element
>
)
"
aFlags
)
;
}
}
}
#
endif
