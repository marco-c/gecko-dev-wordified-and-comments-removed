#
include
"
mozilla
/
dom
/
WebGPUBinding
.
h
"
#
include
"
Buffer
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
HoldDropJSObjects
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
ipc
/
WebGPUChild
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
Device
.
h
"
#
include
"
mozilla
/
webgpu
/
ffi
/
wgpu
.
h
"
namespace
mozilla
:
:
webgpu
{
GPU_IMPL_JS_WRAP
(
Buffer
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
Buffer
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
Buffer
)
tmp
-
>
Cleanup
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mParent
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
Buffer
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mParent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
Buffer
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
if
(
tmp
-
>
mMapped
)
{
for
(
uint32_t
i
=
0
;
i
<
tmp
-
>
mMapped
-
>
mViews
.
Length
(
)
;
+
+
i
)
{
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mMapped
-
>
mViews
[
i
]
.
mArrayBuffer
)
}
}
NS_IMPL_CYCLE_COLLECTION_TRACE_END
Buffer
:
:
Buffer
(
Device
*
const
aParent
RawId
aId
BufferAddress
aSize
uint32_t
aUsage
ipc
:
:
SharedMemoryMapping
&
&
aShmem
)
:
ChildOf
(
aParent
)
mId
(
aId
)
mSize
(
aSize
)
mUsage
(
aUsage
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
mShmem
=
std
:
:
make_shared
<
ipc
:
:
SharedMemoryMapping
>
(
std
:
:
move
(
aShmem
)
)
;
MOZ_ASSERT
(
mParent
)
;
}
Buffer
:
:
~
Buffer
(
)
{
Cleanup
(
)
;
mozilla
:
:
DropJSObjects
(
this
)
;
}
already_AddRefed
<
Buffer
>
Buffer
:
:
Create
(
Device
*
aDevice
RawId
aDeviceId
const
dom
:
:
GPUBufferDescriptor
&
aDesc
ErrorResult
&
aRv
)
{
RefPtr
<
WebGPUChild
>
actor
=
aDevice
-
>
GetBridge
(
)
;
RawId
bufferId
=
ffi
:
:
wgpu_client_make_buffer_id
(
actor
-
>
GetClient
(
)
)
;
if
(
!
aDevice
-
>
IsBridgeAlive
(
)
)
{
RefPtr
<
Buffer
>
buffer
=
new
Buffer
(
aDevice
bufferId
aDesc
.
mSize
0
nullptr
)
;
buffer
-
>
mValid
=
false
;
buffer
-
>
SetLabel
(
aDesc
.
mLabel
)
;
return
buffer
.
forget
(
)
;
}
ipc
:
:
MutableSharedMemoryHandle
handle
;
ipc
:
:
SharedMemoryMapping
mapping
;
bool
hasMapFlags
=
aDesc
.
mUsage
&
(
dom
:
:
GPUBufferUsage_Binding
:
:
MAP_WRITE
|
dom
:
:
GPUBufferUsage_Binding
:
:
MAP_READ
)
;
bool
allocSucceeded
=
false
;
if
(
hasMapFlags
|
|
aDesc
.
mMappedAtCreation
)
{
const
auto
checked
=
CheckedInt
<
size_t
>
(
aDesc
.
mSize
)
;
const
size_t
maxSize
=
WGPUMAX_BUFFER_SIZE
;
if
(
checked
.
isValid
(
)
)
{
size_t
size
=
checked
.
value
(
)
;
if
(
size
>
0
&
&
size
<
maxSize
)
{
handle
=
ipc
:
:
shared_memory
:
:
Create
(
size
)
;
mapping
=
handle
.
Map
(
)
;
if
(
handle
&
&
mapping
)
{
allocSucceeded
=
true
;
MOZ_RELEASE_ASSERT
(
mapping
.
Size
(
)
>
=
size
)
;
memset
(
mapping
.
Address
(
)
0
size
)
;
}
else
{
handle
=
nullptr
;
mapping
=
nullptr
;
}
}
if
(
size
=
=
0
)
{
allocSucceeded
=
true
;
}
}
}
if
(
aDesc
.
mMappedAtCreation
&
&
!
allocSucceeded
)
{
aRv
.
ThrowRangeError
(
"
Allocation
failed
"
)
;
return
nullptr
;
}
ffi
:
:
WGPUBufferDescriptor
desc
=
{
}
;
webgpu
:
:
StringHelper
label
(
aDesc
.
mLabel
)
;
desc
.
label
=
label
.
Get
(
)
;
desc
.
size
=
aDesc
.
mSize
;
desc
.
usage
=
aDesc
.
mUsage
;
desc
.
mapped_at_creation
=
aDesc
.
mMappedAtCreation
;
ipc
:
:
ByteBuf
bb
;
ffi
:
:
wgpu_client_create_buffer
(
aDeviceId
bufferId
&
desc
ToFFI
(
&
bb
)
)
;
actor
-
>
SendMessage
(
std
:
:
move
(
bb
)
Some
(
std
:
:
move
(
handle
)
)
)
;
RefPtr
<
Buffer
>
buffer
=
new
Buffer
(
aDevice
bufferId
aDesc
.
mSize
aDesc
.
mUsage
std
:
:
move
(
mapping
)
)
;
buffer
-
>
SetLabel
(
aDesc
.
mLabel
)
;
if
(
aDesc
.
mMappedAtCreation
)
{
bool
writable
=
true
;
buffer
-
>
SetMapped
(
0
aDesc
.
mSize
writable
)
;
}
aDevice
-
>
TrackBuffer
(
buffer
.
get
(
)
)
;
return
buffer
.
forget
(
)
;
}
void
Buffer
:
:
Cleanup
(
)
{
if
(
!
mValid
)
{
return
;
}
mValid
=
false
;
AbortMapRequest
(
)
;
if
(
mMapped
&
&
!
mMapped
-
>
mViews
.
IsEmpty
(
)
)
{
dom
:
:
AutoJSAPI
jsapi
;
if
(
jsapi
.
Init
(
GetDevice
(
)
.
GetOwnerGlobal
(
)
)
)
{
IgnoredErrorResult
rv
;
UnmapArrayBuffers
(
jsapi
.
cx
(
)
rv
)
;
}
}
mMapped
.
reset
(
)
;
GetDevice
(
)
.
UntrackBuffer
(
this
)
;
auto
bridge
=
GetDevice
(
)
.
GetBridge
(
)
;
if
(
!
bridge
)
{
return
;
}
if
(
bridge
-
>
CanSend
(
)
)
{
ipc
:
:
ByteBuf
bb
;
ffi
:
:
wgpu_client_drop_buffer
(
mId
ToFFI
(
&
bb
)
)
;
bridge
-
>
SendMessage
(
std
:
:
move
(
bb
)
Nothing
(
)
)
;
}
wgpu_client_free_buffer_id
(
bridge
-
>
GetClient
(
)
mId
)
;
}
void
Buffer
:
:
SetMapped
(
BufferAddress
aOffset
BufferAddress
aSize
bool
aWritable
)
{
MOZ_ASSERT
(
!
mMapped
)
;
MOZ_RELEASE_ASSERT
(
aOffset
<
=
mSize
)
;
MOZ_RELEASE_ASSERT
(
aSize
<
=
mSize
-
aOffset
)
;
mMapped
.
emplace
(
)
;
mMapped
-
>
mWritable
=
aWritable
;
mMapped
-
>
mOffset
=
aOffset
;
mMapped
-
>
mSize
=
aSize
;
}
already_AddRefed
<
dom
:
:
Promise
>
Buffer
:
:
MapAsync
(
uint32_t
aMode
uint64_t
aOffset
const
dom
:
:
Optional
<
uint64_t
>
&
aSize
ErrorResult
&
aRv
)
{
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
GetDevice
(
)
.
IsLost
(
)
)
{
promise
-
>
MaybeRejectWithOperationError
(
"
Device
Lost
"
)
;
return
promise
.
forget
(
)
;
}
if
(
mMapRequest
)
{
promise
-
>
MaybeRejectWithOperationError
(
"
Buffer
mapping
is
already
pending
"
)
;
return
promise
.
forget
(
)
;
}
BufferAddress
size
=
0
;
if
(
aSize
.
WasPassed
(
)
)
{
size
=
aSize
.
Value
(
)
;
}
else
if
(
aOffset
<
=
mSize
)
{
size
=
mSize
-
aOffset
;
}
else
{
}
const
auto
&
bridge
=
GetDevice
(
)
.
GetBridge
(
)
;
ipc
:
:
ByteBuf
bb
;
ffi
:
:
wgpu_client_buffer_map
(
GetDevice
(
)
.
mId
mId
aMode
aOffset
size
ToFFI
(
&
bb
)
)
;
bool
sent
=
bridge
-
>
SendMessage
(
std
:
:
move
(
bb
)
Nothing
(
)
)
;
if
(
sent
)
{
mMapRequest
=
promise
;
auto
pending_promise
=
WebGPUChild
:
:
PendingBufferMapPromise
{
RefPtr
(
promise
)
RefPtr
(
this
)
}
;
auto
&
pending_promises
=
bridge
-
>
mPendingBufferMapPromises
;
if
(
auto
search
=
pending_promises
.
find
(
mId
)
;
search
!
=
pending_promises
.
end
(
)
)
{
search
-
>
second
.
push_back
(
std
:
:
move
(
pending_promise
)
)
;
}
else
{
pending_promises
.
insert
(
{
mId
{
std
:
:
move
(
pending_promise
)
}
}
)
;
}
}
else
{
promise
-
>
MaybeRejectWithAbortError
(
"
Internal
communication
error
!
"
)
;
}
return
promise
.
forget
(
)
;
}
static
void
ExternalBufferFreeCallback
(
void
*
aContents
void
*
aUserData
)
{
Unused
<
<
aContents
;
auto
shm
=
static_cast
<
std
:
:
shared_ptr
<
ipc
:
:
SharedMemoryMapping
>
*
>
(
aUserData
)
;
delete
shm
;
}
void
Buffer
:
:
GetMappedRange
(
JSContext
*
aCx
uint64_t
aOffset
const
dom
:
:
Optional
<
uint64_t
>
&
aSize
JS
:
:
Rooted
<
JSObject
*
>
*
aObject
ErrorResult
&
aRv
)
{
const
auto
offset
=
CheckedInt
<
uint64_t
>
(
aOffset
)
;
CheckedInt
<
uint64_t
>
rangeSize
;
if
(
aSize
.
WasPassed
(
)
)
{
rangeSize
=
aSize
.
Value
(
)
;
}
else
{
const
auto
bufferSize
=
CheckedInt
<
uint64_t
>
(
mSize
)
;
rangeSize
=
bufferSize
-
offset
;
if
(
!
rangeSize
.
isValid
(
)
)
{
rangeSize
=
0
;
}
}
if
(
!
mMapped
)
{
aRv
.
ThrowOperationError
(
"
Buffer
is
not
mapped
"
)
;
return
;
}
if
(
offset
.
value
(
)
%
8
!
=
0
)
{
aRv
.
ThrowOperationError
(
"
GetMappedRange
offset
is
not
a
multiple
of
8
"
)
;
return
;
}
if
(
rangeSize
.
value
(
)
%
4
!
=
0
)
{
aRv
.
ThrowOperationError
(
"
GetMappedRange
size
is
not
a
multiple
of
4
"
)
;
return
;
}
if
(
offset
.
value
(
)
<
mMapped
-
>
mOffset
)
{
aRv
.
ThrowOperationError
(
"
GetMappedRange
offset
starts
before
buffer
'
s
mapped
range
"
)
;
return
;
}
const
auto
rangeEndChecked
=
offset
+
rangeSize
;
if
(
!
rangeEndChecked
.
isValid
(
)
|
|
rangeEndChecked
.
value
(
)
>
mMapped
-
>
mOffset
+
mMapped
-
>
mSize
)
{
aRv
.
ThrowOperationError
(
"
GetMappedRange
range
extends
beyond
buffer
'
s
mapped
range
"
)
;
return
;
}
const
uint64_t
rangeEnd
=
rangeEndChecked
.
value
(
)
;
for
(
const
auto
&
view
:
mMapped
-
>
mViews
)
{
if
(
view
.
mOffset
<
rangeEnd
&
&
offset
.
value
(
)
<
view
.
mRangeEnd
)
{
aRv
.
ThrowOperationError
(
"
GetMappedRange
range
overlaps
with
existing
buffer
view
"
)
;
return
;
}
}
std
:
:
shared_ptr
<
ipc
:
:
SharedMemoryMapping
>
*
data
=
new
std
:
:
shared_ptr
<
ipc
:
:
SharedMemoryMapping
>
(
mShmem
)
;
const
auto
checkedSize
=
CheckedInt
<
size_t
>
(
rangeSize
.
value
(
)
)
.
value
(
)
;
const
auto
checkedOffset
=
CheckedInt
<
size_t
>
(
offset
.
value
(
)
)
.
value
(
)
;
const
auto
span
=
(
*
data
)
-
>
DataAsSpan
<
uint8_t
>
(
)
.
Subspan
(
checkedOffset
checkedSize
)
;
UniquePtr
<
void
JS
:
:
BufferContentsDeleter
>
contents
{
span
.
data
(
)
{
&
ExternalBufferFreeCallback
data
}
}
;
JS
:
:
Rooted
<
JSObject
*
>
view
(
aCx
JS
:
:
NewExternalArrayBuffer
(
aCx
checkedSize
std
:
:
move
(
contents
)
)
)
;
if
(
!
view
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
aObject
-
>
set
(
view
)
;
mMapped
-
>
mViews
.
AppendElement
(
MappedView
(
{
checkedOffset
rangeEnd
*
aObject
}
)
)
;
}
void
Buffer
:
:
UnmapArrayBuffers
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mMapped
)
;
bool
detachedArrayBuffers
=
true
;
for
(
const
auto
&
view
:
mMapped
-
>
mViews
)
{
JS
:
:
Rooted
<
JSObject
*
>
rooted
(
aCx
view
.
mArrayBuffer
)
;
if
(
!
JS
:
:
DetachArrayBuffer
(
aCx
rooted
)
)
{
detachedArrayBuffers
=
false
;
}
}
;
mMapped
-
>
mViews
.
Clear
(
)
;
AbortMapRequest
(
)
;
if
(
NS_WARN_IF
(
!
detachedArrayBuffers
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
}
void
Buffer
:
:
ResolveMapRequest
(
dom
:
:
Promise
*
aPromise
BufferAddress
aOffset
BufferAddress
aSize
bool
aWritable
)
{
MOZ_RELEASE_ASSERT
(
mMapRequest
=
=
aPromise
)
;
mMapRequest
=
nullptr
;
SetMapped
(
aOffset
aSize
aWritable
)
;
aPromise
-
>
MaybeResolveWithUndefined
(
)
;
}
void
Buffer
:
:
RejectMapRequest
(
dom
:
:
Promise
*
aPromise
const
nsACString
&
message
)
{
MOZ_RELEASE_ASSERT
(
mMapRequest
=
=
aPromise
)
;
mMapRequest
=
nullptr
;
aPromise
-
>
MaybeRejectWithOperationError
(
message
)
;
}
void
Buffer
:
:
AbortMapRequest
(
)
{
if
(
mMapRequest
)
{
mMapRequest
-
>
MaybeRejectWithAbortError
(
"
Buffer
unmapped
"
)
;
}
mMapRequest
=
nullptr
;
}
void
Buffer
:
:
Unmap
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
if
(
!
mMapped
)
{
return
;
}
UnmapArrayBuffers
(
aCx
aRv
)
;
bool
hasMapFlags
=
mUsage
&
(
dom
:
:
GPUBufferUsage_Binding
:
:
MAP_WRITE
|
dom
:
:
GPUBufferUsage_Binding
:
:
MAP_READ
)
;
if
(
!
hasMapFlags
)
{
mShmem
=
std
:
:
make_shared
<
ipc
:
:
SharedMemoryMapping
>
(
)
;
}
if
(
!
GetDevice
(
)
.
IsLost
(
)
)
{
ipc
:
:
ByteBuf
bb
;
ffi
:
:
wgpu_client_buffer_unmap
(
GetDevice
(
)
.
mId
mId
mMapped
-
>
mWritable
ToFFI
(
&
bb
)
)
;
GetDevice
(
)
.
GetBridge
(
)
-
>
SendMessage
(
std
:
:
move
(
bb
)
Nothing
(
)
)
;
}
mMapped
.
reset
(
)
;
}
void
Buffer
:
:
Destroy
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
if
(
mMapped
)
{
Unmap
(
aCx
aRv
)
;
}
if
(
!
GetDevice
(
)
.
IsLost
(
)
)
{
auto
bridge
=
mParent
-
>
GetBridge
(
)
;
if
(
bridge
-
>
CanSend
(
)
)
{
ipc
:
:
ByteBuf
bb
;
ffi
:
:
wgpu_client_destroy_buffer
(
mId
ToFFI
(
&
bb
)
)
;
bridge
-
>
SendMessage
(
std
:
:
move
(
bb
)
Nothing
(
)
)
;
}
}
}
dom
:
:
GPUBufferMapState
Buffer
:
:
MapState
(
)
const
{
if
(
mMapped
)
{
return
dom
:
:
GPUBufferMapState
:
:
Mapped
;
}
if
(
mMapRequest
)
{
return
dom
:
:
GPUBufferMapState
:
:
Pending
;
}
return
dom
:
:
GPUBufferMapState
:
:
Unmapped
;
}
}
