import
{
unreachable
}
from
'
.
.
/
.
.
/
util
/
util
.
js
'
;
let
windowURL
:
URL
|
undefined
=
undefined
;
function
getWindowURL
(
)
{
if
(
windowURL
=
=
=
undefined
)
{
windowURL
=
new
URL
(
window
.
location
.
toString
(
)
)
;
}
return
windowURL
;
}
export
function
optionEnabled
(
opt
:
string
searchParams
:
URLSearchParams
=
getWindowURL
(
)
.
searchParams
)
:
boolean
{
const
val
=
searchParams
.
get
(
opt
)
;
return
val
!
=
=
null
&
&
val
!
=
=
'
0
'
;
}
export
function
optionString
(
opt
:
string
searchParams
:
URLSearchParams
=
getWindowURL
(
)
.
searchParams
)
:
string
|
null
{
return
searchParams
.
get
(
opt
)
;
}
export
type
WorkerMode
=
'
dedicated
'
|
'
service
'
|
'
shared
'
;
export
function
optionWorkerMode
(
opt
:
string
searchParams
:
URLSearchParams
=
getWindowURL
(
)
.
searchParams
)
:
WorkerMode
|
null
{
const
value
=
searchParams
.
get
(
opt
)
;
if
(
value
=
=
=
null
|
|
value
=
=
=
'
0
'
)
{
return
null
;
}
else
if
(
value
=
=
=
'
service
'
)
{
return
'
service
'
;
}
else
if
(
value
=
=
=
'
shared
'
)
{
return
'
shared
'
;
}
else
if
(
value
=
=
=
'
'
|
|
value
=
=
=
'
1
'
|
|
value
=
=
=
'
dedicated
'
)
{
return
'
dedicated
'
;
}
unreachable
(
'
invalid
worker
=
option
value
'
)
;
}
export
interface
CTSOptions
{
worker
:
WorkerMode
|
null
;
debug
:
boolean
;
compatibility
:
boolean
;
forceFallbackAdapter
:
boolean
;
enforceDefaultLimits
:
boolean
;
unrollConstEvalLoops
:
boolean
;
powerPreference
:
GPUPowerPreference
|
null
;
logToWebSocket
:
boolean
;
}
export
const
kDefaultCTSOptions
:
CTSOptions
=
{
worker
:
null
debug
:
false
compatibility
:
false
forceFallbackAdapter
:
false
enforceDefaultLimits
:
false
unrollConstEvalLoops
:
false
powerPreference
:
null
logToWebSocket
:
false
}
;
export
interface
OptionInfo
{
description
:
string
;
parser
?
:
(
key
:
string
searchParams
?
:
URLSearchParams
)
=
>
boolean
|
string
|
null
;
selectValueDescriptions
?
:
{
value
:
string
|
null
;
description
:
string
}
[
]
;
}
export
type
OptionsInfos
<
Type
>
=
Record
<
keyof
Type
OptionInfo
>
;
export
const
kCTSOptionsInfo
:
OptionsInfos
<
CTSOptions
>
=
{
worker
:
{
description
:
'
run
in
a
worker
'
parser
:
optionWorkerMode
selectValueDescriptions
:
[
{
value
:
null
description
:
'
no
worker
'
}
{
value
:
'
dedicated
'
description
:
'
dedicated
worker
'
}
{
value
:
'
shared
'
description
:
'
shared
worker
'
}
{
value
:
'
service
'
description
:
'
service
worker
'
}
]
}
debug
:
{
description
:
'
show
more
info
'
}
compatibility
:
{
description
:
'
request
adapters
with
featureLevel
:
"
compatibility
"
'
}
forceFallbackAdapter
:
{
description
:
'
pass
forceFallbackAdapter
:
true
to
requestAdapter
'
}
enforceDefaultLimits
:
{
description
:
force
the
adapter
limits
to
the
default
limits
.
Note
:
May
fail
on
tests
for
low
-
power
/
high
-
performance
}
unrollConstEvalLoops
:
{
description
:
'
unroll
const
eval
loops
in
WGSL
'
}
powerPreference
:
{
description
:
'
set
default
powerPreference
for
some
tests
'
parser
:
optionString
selectValueDescriptions
:
[
{
value
:
null
description
:
'
default
'
}
{
value
:
'
low
-
power
'
description
:
'
low
-
power
'
}
{
value
:
'
high
-
performance
'
description
:
'
high
-
performance
'
}
]
}
logToWebSocket
:
{
description
:
'
send
some
logs
to
ws
:
/
/
localhost
:
59497
/
'
}
}
;
export
function
camelCaseToSnakeCase
(
id
:
string
)
{
return
id
.
replace
(
/
(
.
)
(
[
A
-
Z
]
[
a
-
z
]
+
)
/
g
'
1_
2
'
)
.
replace
(
/
(
[
a
-
z0
-
9
]
)
(
[
A
-
Z
]
)
/
g
'
1_
2
'
)
.
toLowerCase
(
)
;
}
function
getOptionsInfoFromSearchString
<
Type
extends
CTSOptions
>
(
optionsInfos
:
OptionsInfos
<
Type
>
searchString
:
string
)
:
Type
{
const
searchParams
=
new
URLSearchParams
(
searchString
)
;
const
optionValues
:
Record
<
string
boolean
|
string
|
null
>
=
{
}
;
for
(
const
[
optionName
info
]
of
Object
.
entries
(
optionsInfos
)
)
{
const
parser
=
info
.
parser
|
|
optionEnabled
;
optionValues
[
optionName
]
=
parser
(
camelCaseToSnakeCase
(
optionName
)
searchParams
)
;
}
return
optionValues
as
unknown
as
Type
;
}
export
function
parseSearchParamLikeWithOptions
<
Type
extends
CTSOptions
>
(
optionsInfos
:
OptionsInfos
<
Type
>
query
:
string
)
:
{
queries
:
string
[
]
;
options
:
Type
;
}
{
const
searchString
=
query
.
includes
(
'
q
=
'
)
|
|
query
.
startsWith
(
'
?
'
)
?
query
:
q
=
{
query
}
;
const
queries
=
new
URLSearchParams
(
searchString
)
.
getAll
(
'
q
'
)
;
const
options
=
getOptionsInfoFromSearchString
(
optionsInfos
searchString
)
;
return
{
queries
options
}
;
}
export
function
parseSearchParamLikeWithCTSOptions
(
query
:
string
)
{
return
parseSearchParamLikeWithOptions
(
kCTSOptionsInfo
query
)
;
}
