import
{
loadMetadataForSuite
TestMetadataListing
}
from
'
.
.
/
framework
/
metadata
.
js
'
;
import
{
globalTestConfig
}
from
'
.
.
/
framework
/
test_config
.
js
'
;
import
{
RunCase
RunFn
}
from
'
.
.
/
internal
/
test_group
.
js
'
;
import
{
assert
now
}
from
'
.
.
/
util
/
util
.
js
'
;
import
{
TestFileLoader
}
from
'
.
/
file_loader
.
js
'
;
import
{
TestParamsRW
}
from
'
.
/
params_utils
.
js
'
;
import
{
comparePublicParamsPaths
compareQueries
Ordering
}
from
'
.
/
query
/
compare
.
js
'
;
import
{
TestQuery
TestQueryMultiCase
TestQuerySingleCase
TestQueryMultiFile
TestQueryMultiTest
}
from
'
.
/
query
/
query
.
js
'
;
import
{
kBigSeparator
kWildcard
kPathSeparator
kParamSeparator
}
from
'
.
/
query
/
separators
.
js
'
;
import
{
stringifySingleParam
}
from
'
.
/
query
/
stringify_params
.
js
'
;
import
{
StacklessError
}
from
'
.
/
util
.
js
'
;
interface
TestTreeNodeBase
<
T
extends
TestQuery
>
{
readonly
query
:
T
;
readonly
readableRelativeName
:
string
;
subtreeCounts
?
:
{
tests
:
number
;
nodesWithTODO
:
number
;
totalTimeMS
:
number
}
;
subcaseCount
?
:
number
;
}
export
interface
TestSubtree
<
T
extends
TestQuery
=
TestQuery
>
extends
TestTreeNodeBase
<
T
>
{
readonly
children
:
Map
<
string
TestTreeNode
>
;
collapsible
:
boolean
;
description
?
:
string
;
readonly
testCreationStack
?
:
Error
;
}
export
interface
TestTreeLeaf
extends
TestTreeNodeBase
<
TestQuerySingleCase
>
{
readonly
run
:
RunFn
;
readonly
isUnimplemented
?
:
boolean
;
subtreeCounts
?
:
undefined
;
subcaseCount
:
number
;
}
export
type
TestTreeNode
=
TestSubtree
|
TestTreeLeaf
;
export
type
ExpandThroughLevel
=
1
|
2
|
3
;
export
class
TestTree
{
readonly
forQuery
:
TestQuery
;
readonly
root
:
TestSubtree
;
private
constructor
(
forQuery
:
TestQuery
root
:
TestSubtree
)
{
this
.
forQuery
=
forQuery
;
this
.
root
=
root
;
assert
(
root
.
query
.
level
=
=
=
1
&
&
root
.
query
.
depthInLevel
=
=
=
0
'
TestTree
root
must
be
the
root
(
suite
:
*
)
'
)
;
}
static
async
create
(
forQuery
:
TestQuery
root
:
TestSubtree
maxChunkTime
:
number
)
:
Promise
<
TestTree
>
{
const
suite
=
forQuery
.
suite
;
let
chunking
=
undefined
;
if
(
Number
.
isFinite
(
maxChunkTime
)
)
{
const
metadata
=
loadMetadataForSuite
(
.
/
src
/
{
suite
}
)
;
assert
(
metadata
!
=
=
null
metadata
for
{
suite
}
is
missing
but
maxChunkTime
was
requested
)
;
chunking
=
{
metadata
maxChunkTime
}
;
}
await
TestTree
.
propagateCounts
(
root
chunking
)
;
return
new
TestTree
(
forQuery
root
)
;
}
iterateCollapsedNodes
(
{
includeIntermediateNodes
=
false
includeEmptySubtrees
=
false
alwaysExpandThroughLevel
}
:
{
includeIntermediateNodes
?
:
boolean
;
includeEmptySubtrees
?
:
boolean
;
alwaysExpandThroughLevel
:
ExpandThroughLevel
;
}
)
:
IterableIterator
<
Readonly
<
TestTreeNode
>
>
{
const
expandThroughLevel
=
Math
.
max
(
this
.
forQuery
.
level
alwaysExpandThroughLevel
)
;
return
TestTree
.
iterateSubtreeNodes
(
this
.
root
{
includeIntermediateNodes
includeEmptySubtrees
expandThroughLevel
}
)
;
}
iterateLeaves
(
)
:
IterableIterator
<
Readonly
<
TestTreeLeaf
>
>
{
return
TestTree
.
iterateSubtreeLeaves
(
this
.
root
)
;
}
dissolveSingleChildTrees
(
)
:
void
{
const
newRoot
=
dissolveSingleChildTrees
(
this
.
root
)
;
assert
(
newRoot
=
=
=
this
.
root
)
;
}
toString
(
)
:
string
{
return
TestTree
.
subtreeToString
(
'
(
root
)
'
this
.
root
'
'
)
;
}
static
*
iterateSubtreeNodes
(
subtree
:
TestSubtree
opts
:
{
includeIntermediateNodes
:
boolean
;
includeEmptySubtrees
:
boolean
;
expandThroughLevel
:
number
;
}
)
:
IterableIterator
<
TestTreeNode
>
{
if
(
opts
.
includeIntermediateNodes
)
{
yield
subtree
;
}
for
(
const
[
child
]
of
subtree
.
children
)
{
if
(
'
children
'
in
child
)
{
const
collapsible
=
child
.
collapsible
&
&
child
.
query
.
level
>
opts
.
expandThroughLevel
;
if
(
child
.
children
.
size
>
0
&
&
!
collapsible
)
{
yield
*
TestTree
.
iterateSubtreeNodes
(
child
opts
)
;
}
else
if
(
child
.
children
.
size
>
0
|
|
opts
.
includeEmptySubtrees
)
{
yield
child
;
}
}
else
{
yield
child
;
}
}
}
static
*
iterateSubtreeLeaves
(
subtree
:
TestSubtree
)
:
IterableIterator
<
TestTreeLeaf
>
{
for
(
const
[
child
]
of
subtree
.
children
)
{
if
(
'
children
'
in
child
)
{
yield
*
TestTree
.
iterateSubtreeLeaves
(
child
)
;
}
else
{
yield
child
;
}
}
}
static
async
propagateCounts
(
subtree
:
TestSubtree
chunking
:
{
metadata
:
TestMetadataListing
;
maxChunkTime
:
number
}
|
undefined
)
:
Promise
<
{
tests
:
number
;
nodesWithTODO
:
number
;
totalTimeMS
:
number
;
subcaseCount
:
number
}
>
{
subtree
.
subtreeCounts
?
?
=
{
tests
:
0
nodesWithTODO
:
0
totalTimeMS
:
0
}
;
subtree
.
subcaseCount
=
0
;
for
(
const
[
child
]
of
subtree
.
children
)
{
if
(
'
children
'
in
child
)
{
const
counts
=
await
TestTree
.
propagateCounts
(
child
chunking
)
;
subtree
.
subtreeCounts
.
tests
+
=
counts
.
tests
;
subtree
.
subtreeCounts
.
nodesWithTODO
+
=
counts
.
nodesWithTODO
;
subtree
.
subtreeCounts
.
totalTimeMS
+
=
counts
.
totalTimeMS
;
subtree
.
subcaseCount
+
=
counts
.
subcaseCount
;
}
else
{
subtree
.
subcaseCount
=
child
.
subcaseCount
;
}
}
if
(
chunking
&
&
subtree
.
query
instanceof
TestQueryMultiCase
)
{
const
testLevelQuery
=
new
TestQueryMultiCase
(
subtree
.
query
.
suite
subtree
.
query
.
filePathParts
subtree
.
query
.
testPathParts
{
}
)
.
toString
(
)
;
const
metadata
=
chunking
.
metadata
;
const
subcaseTiming
:
number
|
undefined
=
metadata
[
testLevelQuery
]
?
.
subcaseMS
;
if
(
subcaseTiming
!
=
=
undefined
)
{
const
totalTiming
=
subcaseTiming
*
subtree
.
subcaseCount
;
subtree
.
subtreeCounts
.
totalTimeMS
=
totalTiming
;
if
(
totalTiming
>
chunking
.
maxChunkTime
)
{
subtree
.
collapsible
=
false
;
}
}
}
return
{
.
.
.
subtree
.
subtreeCounts
subcaseCount
:
subtree
.
subcaseCount
?
?
0
}
;
}
static
countsToString
(
tree
:
TestTreeNode
)
:
string
{
if
(
tree
.
subtreeCounts
)
{
return
{
tree
.
subtreeCounts
.
nodesWithTODO
}
/
{
tree
.
subtreeCounts
.
tests
}
;
}
else
{
return
'
'
;
}
}
static
subtreeToString
(
name
:
string
tree
:
TestTreeNode
indent
:
string
)
:
string
{
const
collapsible
=
'
run
'
in
tree
?
'
>
'
:
tree
.
collapsible
?
'
+
'
:
'
-
'
;
let
s
=
indent
+
{
collapsible
}
{
TestTree
.
countsToString
(
tree
)
}
{
JSON
.
stringify
(
name
)
}
=
>
{
tree
.
query
}
;
if
(
'
children
'
in
tree
)
{
if
(
tree
.
description
!
=
=
undefined
)
{
s
+
=
\
n
{
indent
}
|
{
JSON
.
stringify
(
tree
.
description
)
}
;
}
for
(
const
[
name
child
]
of
tree
.
children
)
{
s
+
=
'
\
n
'
+
TestTree
.
subtreeToString
(
name
child
indent
+
'
'
)
;
}
}
return
s
;
}
}
export
async
function
loadTreeForQuery
(
loader
:
TestFileLoader
queryToLoad
:
TestQuery
{
subqueriesToExpand
fullyExpandSubtrees
=
[
]
maxChunkTime
=
Infinity
}
:
{
subqueriesToExpand
:
TestQuery
[
]
;
fullyExpandSubtrees
?
:
TestQuery
[
]
;
maxChunkTime
?
:
number
}
)
:
Promise
<
TestTree
>
{
const
suite
=
queryToLoad
.
suite
;
const
specs
=
await
loader
.
listing
(
suite
)
;
const
subqueriesToExpandEntries
=
Array
.
from
(
subqueriesToExpand
.
entries
(
)
)
;
const
seenSubqueriesToExpand
:
boolean
[
]
=
new
Array
(
subqueriesToExpand
.
length
)
;
seenSubqueriesToExpand
.
fill
(
false
)
;
const
isCollapsible
=
(
subquery
:
TestQuery
)
=
>
subqueriesToExpandEntries
.
every
(
(
[
i
toExpand
]
)
=
>
{
const
ordering
=
compareQueries
(
toExpand
subquery
)
;
if
(
ordering
=
=
=
Ordering
.
Equal
)
seenSubqueriesToExpand
[
i
]
=
true
;
return
ordering
!
=
=
Ordering
.
StrictSubset
;
}
)
&
&
fullyExpandSubtrees
.
every
(
toExpand
=
>
{
const
ordering
=
compareQueries
(
toExpand
subquery
)
;
return
ordering
=
=
=
Ordering
.
Unordered
;
}
)
;
let
foundCase
=
false
;
const
subtreeL0
=
makeTreeForSuite
(
suite
isCollapsible
)
;
const
imports_start
=
now
(
)
;
const
pEntriesWithImports
=
[
]
;
for
(
const
entry
of
specs
)
{
if
(
entry
.
file
.
length
=
=
=
0
&
&
'
readme
'
in
entry
)
{
setSubtreeDescriptionAndCountTODOs
(
subtreeL0
entry
.
readme
)
;
continue
;
}
{
const
queryL1
=
new
TestQueryMultiFile
(
suite
entry
.
file
)
;
const
orderingL1
=
compareQueries
(
queryL1
queryToLoad
)
;
if
(
orderingL1
=
=
=
Ordering
.
Unordered
)
{
continue
;
}
}
const
pEntryWithImport
=
(
async
(
)
=
>
{
if
(
'
readme
'
in
entry
)
{
return
entry
;
}
else
{
return
{
.
.
.
entry
importedSpec
:
await
loader
.
importSpecFile
(
queryToLoad
.
suite
entry
.
file
)
}
;
}
}
)
(
)
;
const
kForceSerialImporting
=
false
;
if
(
kForceSerialImporting
)
{
await
pEntryWithImport
;
}
pEntriesWithImports
.
push
(
pEntryWithImport
)
;
}
const
entriesWithImports
=
await
Promise
.
all
(
pEntriesWithImports
)
;
if
(
globalTestConfig
.
frameworkDebugLog
)
{
const
imported_time
=
performance
.
now
(
)
-
imports_start
;
globalTestConfig
.
frameworkDebugLog
(
Imported
importedSpecFiles
[
{
entriesWithImports
.
length
}
]
in
{
imported_time
}
ms
.
)
;
}
for
(
const
entry
of
entriesWithImports
)
{
if
(
'
readme
'
in
entry
)
{
const
readmeSubtree
:
TestSubtree
<
TestQueryMultiFile
>
=
addSubtreeForDirPath
(
subtreeL0
entry
.
file
isCollapsible
)
;
setSubtreeDescriptionAndCountTODOs
(
readmeSubtree
entry
.
readme
)
;
continue
;
}
const
spec
=
entry
.
importedSpec
;
const
subtreeL1
:
TestSubtree
<
TestQueryMultiTest
>
=
addSubtreeForFilePath
(
subtreeL0
entry
.
file
isCollapsible
)
;
setSubtreeDescriptionAndCountTODOs
(
subtreeL1
spec
.
description
)
;
let
groupHasTests
=
false
;
for
(
const
t
of
spec
.
g
.
iterate
(
)
)
{
groupHasTests
=
true
;
{
const
queryL2
=
new
TestQueryMultiCase
(
suite
entry
.
file
t
.
testPath
{
}
)
;
const
orderingL2
=
compareQueries
(
queryL2
queryToLoad
)
;
if
(
orderingL2
=
=
=
Ordering
.
Unordered
)
{
continue
;
}
}
const
subtreeL2
:
TestSubtree
<
TestQueryMultiCase
>
=
addSubtreeForTestPath
(
subtreeL1
t
.
testPath
t
.
testCreationStack
isCollapsible
)
;
subtreeL2
.
subtreeCounts
?
?
=
{
tests
:
1
nodesWithTODO
:
0
totalTimeMS
:
0
}
;
if
(
t
.
description
)
setSubtreeDescriptionAndCountTODOs
(
subtreeL2
t
.
description
)
;
let
caseFilter
=
null
;
if
(
'
params
'
in
queryToLoad
)
{
caseFilter
=
queryToLoad
.
params
;
}
for
(
const
c
of
t
.
iterate
(
caseFilter
)
)
{
if
(
queryToLoad
instanceof
TestQuerySingleCase
)
{
const
ordering
=
comparePublicParamsPaths
(
c
.
id
.
params
queryToLoad
.
params
)
;
if
(
ordering
!
=
=
Ordering
.
Equal
)
{
continue
;
}
}
addLeafForCase
(
subtreeL2
c
isCollapsible
)
;
foundCase
=
true
;
}
}
if
(
!
groupHasTests
&
&
!
subtreeL1
.
subtreeCounts
)
{
throw
new
StacklessError
(
{
subtreeL1
.
query
}
has
no
tests
-
it
must
have
"
TODO
"
in
its
description
)
;
}
}
for
(
const
[
i
sq
]
of
subqueriesToExpandEntries
)
{
const
subquerySeen
=
seenSubqueriesToExpand
[
i
]
;
if
(
!
subquerySeen
)
{
throw
new
StacklessError
(
subqueriesToExpand
entry
did
not
match
anything
\
(
could
be
wrong
or
could
be
redundant
with
a
previous
subquery
)
:
\
n
{
sq
.
toString
(
)
}
)
;
}
}
assert
(
foundCase
Query
\
{
queryToLoad
.
toString
(
)
}
\
does
not
match
any
cases
)
;
return
TestTree
.
create
(
queryToLoad
subtreeL0
maxChunkTime
)
;
}
function
setSubtreeDescriptionAndCountTODOs
(
subtree
:
TestSubtree
<
TestQueryMultiFile
>
description
:
string
)
{
assert
(
subtree
.
description
=
=
=
undefined
)
;
subtree
.
description
=
description
.
trim
(
)
;
subtree
.
subtreeCounts
?
?
=
{
tests
:
0
nodesWithTODO
:
0
totalTimeMS
:
0
}
;
if
(
subtree
.
description
.
indexOf
(
'
TODO
'
)
!
=
=
-
1
)
{
subtree
.
subtreeCounts
.
nodesWithTODO
+
+
;
}
}
function
makeTreeForSuite
(
suite
:
string
isCollapsible
:
(
sq
:
TestQuery
)
=
>
boolean
)
:
TestSubtree
<
TestQueryMultiFile
>
{
const
query
=
new
TestQueryMultiFile
(
suite
[
]
)
;
return
{
readableRelativeName
:
suite
+
kBigSeparator
query
children
:
new
Map
(
)
collapsible
:
isCollapsible
(
query
)
}
;
}
function
addSubtreeForDirPath
(
tree
:
TestSubtree
<
TestQueryMultiFile
>
file
:
string
[
]
isCollapsible
:
(
sq
:
TestQuery
)
=
>
boolean
)
:
TestSubtree
<
TestQueryMultiFile
>
{
const
subqueryFile
:
string
[
]
=
[
]
;
for
(
const
part
of
file
)
{
subqueryFile
.
push
(
part
)
;
tree
=
getOrInsertSubtree
(
part
tree
(
)
=
>
{
const
query
=
new
TestQueryMultiFile
(
tree
.
query
.
suite
subqueryFile
)
;
return
{
readableRelativeName
:
part
+
kPathSeparator
+
kWildcard
query
collapsible
:
isCollapsible
(
query
)
}
;
}
)
;
}
return
tree
;
}
function
addSubtreeForFilePath
(
tree
:
TestSubtree
<
TestQueryMultiFile
>
file
:
string
[
]
isCollapsible
:
(
sq
:
TestQuery
)
=
>
boolean
)
:
TestSubtree
<
TestQueryMultiTest
>
{
tree
=
addSubtreeForDirPath
(
tree
file
isCollapsible
)
;
const
subtree
=
getOrInsertSubtree
(
'
'
tree
(
)
=
>
{
const
query
=
new
TestQueryMultiTest
(
tree
.
query
.
suite
tree
.
query
.
filePathParts
[
]
)
;
assert
(
file
.
length
>
0
'
file
path
is
empty
'
)
;
return
{
readableRelativeName
:
file
[
file
.
length
-
1
]
+
kBigSeparator
+
kWildcard
query
collapsible
:
isCollapsible
(
query
)
}
;
}
)
;
return
subtree
;
}
function
addSubtreeForTestPath
(
tree
:
TestSubtree
<
TestQueryMultiTest
>
test
:
readonly
string
[
]
testCreationStack
:
Error
isCollapsible
:
(
sq
:
TestQuery
)
=
>
boolean
)
:
TestSubtree
<
TestQueryMultiCase
>
{
const
subqueryTest
:
string
[
]
=
[
]
;
for
(
const
part
of
test
)
{
subqueryTest
.
push
(
part
)
;
tree
=
getOrInsertSubtree
(
part
tree
(
)
=
>
{
const
query
=
new
TestQueryMultiTest
(
tree
.
query
.
suite
tree
.
query
.
filePathParts
subqueryTest
)
;
return
{
readableRelativeName
:
part
+
kPathSeparator
+
kWildcard
query
collapsible
:
isCollapsible
(
query
)
}
;
}
)
;
}
return
getOrInsertSubtree
(
'
'
tree
(
)
=
>
{
const
query
=
new
TestQueryMultiCase
(
tree
.
query
.
suite
tree
.
query
.
filePathParts
subqueryTest
{
}
)
;
assert
(
subqueryTest
.
length
>
0
'
subqueryTest
is
empty
'
)
;
return
{
readableRelativeName
:
subqueryTest
[
subqueryTest
.
length
-
1
]
+
kBigSeparator
+
kWildcard
kWildcard
query
testCreationStack
collapsible
:
isCollapsible
(
query
)
}
;
}
)
;
}
function
addLeafForCase
(
tree
:
TestSubtree
<
TestQueryMultiTest
>
t
:
RunCase
checkCollapsible
:
(
sq
:
TestQuery
)
=
>
boolean
)
:
void
{
const
query
=
tree
.
query
;
let
name
:
string
=
'
'
;
const
subqueryParams
:
TestParamsRW
=
{
}
;
for
(
const
[
k
v
]
of
Object
.
entries
(
t
.
id
.
params
)
)
{
name
=
stringifySingleParam
(
k
v
)
;
subqueryParams
[
k
]
=
v
;
tree
=
getOrInsertSubtree
(
name
tree
(
)
=
>
{
const
subquery
=
new
TestQueryMultiCase
(
query
.
suite
query
.
filePathParts
query
.
testPathParts
subqueryParams
)
;
return
{
readableRelativeName
:
name
+
kParamSeparator
+
kWildcard
query
:
subquery
collapsible
:
checkCollapsible
(
subquery
)
}
;
}
)
;
}
const
subquery
=
new
TestQuerySingleCase
(
query
.
suite
query
.
filePathParts
query
.
testPathParts
subqueryParams
)
;
checkCollapsible
(
subquery
)
;
insertLeaf
(
tree
subquery
t
)
;
}
function
getOrInsertSubtree
<
T
extends
TestQuery
>
(
key
:
string
parent
:
TestSubtree
createSubtree
:
(
)
=
>
Omit
<
TestSubtree
<
T
>
'
children
'
>
)
:
TestSubtree
<
T
>
{
let
v
:
TestSubtree
<
T
>
;
const
child
=
parent
.
children
.
get
(
key
)
;
if
(
child
!
=
=
undefined
)
{
assert
(
'
children
'
in
child
)
;
v
=
child
as
TestSubtree
<
T
>
;
}
else
{
v
=
{
.
.
.
createSubtree
(
)
children
:
new
Map
(
)
}
;
parent
.
children
.
set
(
key
v
)
;
}
return
v
;
}
function
insertLeaf
(
parent
:
TestSubtree
query
:
TestQuerySingleCase
t
:
RunCase
)
{
const
leaf
:
TestTreeLeaf
=
{
readableRelativeName
:
readableNameForCase
(
query
)
query
run
:
(
rec
expectations
)
=
>
t
.
run
(
rec
query
expectations
|
|
[
]
)
isUnimplemented
:
t
.
isUnimplemented
subcaseCount
:
t
.
computeSubcaseCount
(
)
}
;
const
key
=
'
'
;
assert
(
!
parent
.
children
.
has
(
key
)
Duplicate
testcase
:
{
query
}
)
;
parent
.
children
.
set
(
key
leaf
)
;
}
function
dissolveSingleChildTrees
(
tree
:
TestTreeNode
)
:
TestTreeNode
{
if
(
'
children
'
in
tree
)
{
const
shouldDissolveThisTree
=
tree
.
children
.
size
=
=
=
1
&
&
tree
.
query
.
depthInLevel
!
=
=
0
&
&
tree
.
description
=
=
=
undefined
;
if
(
shouldDissolveThisTree
)
{
for
(
const
[
child
]
of
tree
.
children
)
{
return
dissolveSingleChildTrees
(
child
)
;
}
}
for
(
const
[
k
child
]
of
tree
.
children
)
{
const
newChild
=
dissolveSingleChildTrees
(
child
)
;
if
(
newChild
!
=
=
child
)
{
tree
.
children
.
set
(
k
newChild
)
;
}
}
}
return
tree
;
}
function
readableNameForCase
(
query
:
TestQuerySingleCase
)
:
string
{
const
paramsKeys
=
Object
.
keys
(
query
.
params
)
;
if
(
paramsKeys
.
length
=
=
=
0
)
{
return
query
.
testPathParts
[
query
.
testPathParts
.
length
-
1
]
+
kBigSeparator
;
}
else
{
const
lastKey
=
paramsKeys
[
paramsKeys
.
length
-
1
]
;
return
stringifySingleParam
(
lastKey
query
.
params
[
lastKey
]
)
;
}
}
