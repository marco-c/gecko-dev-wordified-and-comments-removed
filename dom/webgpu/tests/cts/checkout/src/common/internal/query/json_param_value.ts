import
{
assert
sortObjectByKey
isPlainObject
}
from
'
.
.
/
.
.
/
util
/
util
.
js
'
;
import
{
JSONWithUndefined
}
from
'
.
.
/
params_utils
.
js
'
;
const
jsUndefinedMagicValue
=
'
_undef_
'
;
const
jsNaNMagicValue
=
'
_nan_
'
;
const
jsPositiveInfinityMagicValue
=
'
_posinfinity_
'
;
const
jsNegativeInfinityMagicValue
=
'
_neginfinity_
'
;
const
jsNegativeZeroMagicValue
=
'
_negzero_
'
;
const
jsBigIntMagicPattern
=
/
^
(
\
d
+
)
n
/
;
const
toStringMagicValue
=
new
Map
<
unknown
string
>
(
[
[
undefined
jsUndefinedMagicValue
]
[
NaN
jsNaNMagicValue
]
[
Number
.
POSITIVE_INFINITY
jsPositiveInfinityMagicValue
]
[
Number
.
NEGATIVE_INFINITY
jsNegativeInfinityMagicValue
]
]
)
;
const
fromStringMagicValue
=
new
Map
<
string
unknown
>
(
[
[
jsUndefinedMagicValue
undefined
]
[
jsNaNMagicValue
NaN
]
[
jsPositiveInfinityMagicValue
Number
.
POSITIVE_INFINITY
]
[
jsNegativeInfinityMagicValue
Number
.
NEGATIVE_INFINITY
]
[
jsNegativeZeroMagicValue
-
0
]
]
)
;
function
stringifyFilter
(
k
:
string
v
:
unknown
)
:
unknown
{
if
(
typeof
v
=
=
=
'
string
'
)
{
assert
(
!
fromStringMagicValue
.
has
(
v
)
{
v
}
is
a
magic
value
for
stringification
so
cannot
be
used
)
;
assert
(
v
!
=
=
jsNegativeZeroMagicValue
{
v
}
is
a
magic
value
for
stringification
so
cannot
be
used
)
;
assert
(
v
.
match
(
jsBigIntMagicPattern
)
=
=
=
null
{
v
}
matches
bigint
magic
pattern
for
stringification
so
cannot
be
used
)
;
}
const
isObject
=
v
!
=
=
null
&
&
typeof
v
=
=
=
'
object
'
&
&
!
Array
.
isArray
(
v
)
;
if
(
isObject
)
{
assert
(
isPlainObject
(
v
)
value
must
be
a
plain
object
but
it
appears
to
be
a
'
{
Object
.
getPrototypeOf
(
v
)
.
constructor
.
name
}
)
;
}
assert
(
typeof
v
!
=
=
'
function
'
{
v
}
can
not
be
a
function
)
;
if
(
Object
.
is
(
v
-
0
)
)
{
return
jsNegativeZeroMagicValue
;
}
if
(
typeof
v
=
=
=
'
bigint
'
)
{
return
{
v
}
n
;
}
return
toStringMagicValue
.
has
(
v
)
?
toStringMagicValue
.
get
(
v
)
:
v
;
}
export
function
stringifyParamValue
(
value
:
JSONWithUndefined
)
:
string
{
return
JSON
.
stringify
(
value
stringifyFilter
)
;
}
export
function
stringifyParamValueUniquely
(
value
:
JSONWithUndefined
)
:
string
{
return
JSON
.
stringify
(
value
(
k
v
)
=
>
{
if
(
typeof
v
=
=
=
'
object
'
&
&
v
!
=
=
null
)
{
return
sortObjectByKey
(
v
)
;
}
return
stringifyFilter
(
k
v
)
;
}
)
;
}
function
parseParamValueReviver
(
k
:
string
v
:
any
)
:
any
{
if
(
fromStringMagicValue
.
has
(
v
)
)
{
return
fromStringMagicValue
.
get
(
v
)
;
}
if
(
typeof
v
=
=
=
'
string
'
)
{
const
match
:
RegExpMatchArray
|
null
=
v
.
match
(
jsBigIntMagicPattern
)
;
if
(
match
!
=
=
null
)
{
return
BigInt
(
match
[
1
]
)
;
}
}
return
v
;
}
export
function
parseParamValue
(
s
:
string
)
:
JSONWithUndefined
{
return
JSON
.
parse
(
s
parseParamValueReviver
)
;
}
