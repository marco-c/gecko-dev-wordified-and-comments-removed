import
{
assert
sortObjectByKey
}
from
'
.
.
/
.
.
/
util
/
util
.
js
'
;
import
{
JSONWithUndefined
}
from
'
.
.
/
params_utils
.
js
'
;
const
jsUndefinedMagicValue
=
'
_undef_
'
;
const
jsNaNMagicValue
=
'
_nan_
'
;
const
jsPositiveInfinityMagicValue
=
'
_posinfinity_
'
;
const
jsNegativeInfinityMagicValue
=
'
_neginfinity_
'
;
const
jsNegativeZeroMagicValue
=
'
_negzero_
'
;
const
toStringMagicValue
=
new
Map
<
unknown
string
>
(
[
[
undefined
jsUndefinedMagicValue
]
[
NaN
jsNaNMagicValue
]
[
Number
.
POSITIVE_INFINITY
jsPositiveInfinityMagicValue
]
[
Number
.
NEGATIVE_INFINITY
jsNegativeInfinityMagicValue
]
]
)
;
const
fromStringMagicValue
=
new
Map
<
string
unknown
>
(
[
[
jsUndefinedMagicValue
undefined
]
[
jsNaNMagicValue
NaN
]
[
jsPositiveInfinityMagicValue
Number
.
POSITIVE_INFINITY
]
[
jsNegativeInfinityMagicValue
Number
.
NEGATIVE_INFINITY
]
[
jsNegativeZeroMagicValue
-
0
]
]
)
;
function
stringifyFilter
(
k
:
string
v
:
unknown
)
:
unknown
{
if
(
typeof
v
=
=
=
'
string
'
)
{
assert
(
!
fromStringMagicValue
.
has
(
v
)
{
v
}
is
a
magic
value
for
stringification
so
cannot
be
used
)
;
assert
(
v
!
=
=
jsNegativeZeroMagicValue
{
v
}
is
a
magic
value
for
stringification
so
cannot
be
used
)
;
}
if
(
Object
.
is
(
v
-
0
)
)
{
return
jsNegativeZeroMagicValue
;
}
return
toStringMagicValue
.
has
(
v
)
?
toStringMagicValue
.
get
(
v
)
:
v
;
}
export
function
stringifyParamValue
(
value
:
JSONWithUndefined
)
:
string
{
return
JSON
.
stringify
(
value
stringifyFilter
)
;
}
export
function
stringifyParamValueUniquely
(
value
:
JSONWithUndefined
)
:
string
{
return
JSON
.
stringify
(
value
(
k
v
)
=
>
{
if
(
typeof
v
=
=
=
'
object
'
&
&
v
!
=
=
null
)
{
return
sortObjectByKey
(
v
)
;
}
return
stringifyFilter
(
k
v
)
;
}
)
;
}
function
parseParamValueReviver
(
k
:
string
v
:
any
)
:
any
{
if
(
fromStringMagicValue
.
has
(
v
)
)
{
return
fromStringMagicValue
.
get
(
v
)
;
}
return
v
;
}
export
function
parseParamValue
(
s
:
string
)
:
JSONWithUndefined
{
return
JSON
.
parse
(
s
parseParamValueReviver
)
;
}
