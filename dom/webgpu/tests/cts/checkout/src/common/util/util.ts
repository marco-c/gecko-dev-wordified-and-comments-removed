import
{
Float16Array
}
from
'
.
.
/
.
.
/
external
/
petamoriken
/
float16
/
float16
.
js
'
;
import
{
globalTestConfig
}
from
'
.
.
/
framework
/
test_config
.
js
'
;
import
{
Logger
}
from
'
.
.
/
internal
/
logging
/
logger
.
js
'
;
import
{
keysOf
}
from
'
.
/
data_tables
.
js
'
;
import
{
timeout
}
from
'
.
/
timeout
.
js
'
;
export
class
ErrorWithExtra
extends
Error
{
readonly
extra
:
{
[
k
:
string
]
:
unknown
}
;
constructor
(
message
:
string
extra
:
(
)
=
>
{
}
)
;
constructor
(
base
:
ErrorWithExtra
newExtra
:
(
)
=
>
{
}
)
;
constructor
(
baseOrMessage
:
string
|
ErrorWithExtra
newExtra
:
(
)
=
>
{
}
)
{
const
message
=
typeof
baseOrMessage
=
=
=
'
string
'
?
baseOrMessage
:
baseOrMessage
.
message
;
super
(
message
)
;
const
oldExtras
=
baseOrMessage
instanceof
ErrorWithExtra
?
baseOrMessage
.
extra
:
{
}
;
this
.
extra
=
Logger
.
globalDebugMode
?
{
.
.
.
oldExtras
.
.
.
newExtra
(
)
}
:
{
omitted
:
'
pass
?
debug
=
1
'
}
;
}
}
export
function
assert
(
condition
:
boolean
msg
?
:
string
|
(
(
)
=
>
string
)
)
:
asserts
condition
{
if
(
!
condition
)
{
throw
new
Error
(
msg
&
&
(
typeof
msg
=
=
=
'
string
'
?
msg
:
msg
(
)
)
)
;
}
}
export
function
assertOK
<
T
>
(
value
:
Error
|
T
)
:
T
{
if
(
value
instanceof
Error
)
{
throw
value
;
}
return
value
;
}
export
async
function
assertReject
(
p
:
Promise
<
unknown
>
msg
?
:
string
)
:
Promise
<
void
>
{
try
{
await
p
;
unreachable
(
msg
)
;
}
catch
(
ex
)
{
}
}
export
function
unreachable
(
msg
?
:
string
)
:
never
{
throw
new
Error
(
msg
)
;
}
const
perf
=
typeof
performance
!
=
=
'
undefined
'
?
performance
:
require
(
'
perf_hooks
'
)
.
performance
;
export
function
now
(
)
:
number
{
return
perf
.
now
(
)
;
}
export
function
resolveOnTimeout
(
ms
:
number
)
:
Promise
<
void
>
{
return
new
Promise
(
resolve
=
>
{
timeout
(
(
)
=
>
{
resolve
(
)
;
}
ms
)
;
}
)
;
}
export
class
PromiseTimeoutError
extends
Error
{
}
export
function
rejectOnTimeout
(
ms
:
number
msg
:
string
)
:
Promise
<
never
>
{
return
new
Promise
(
(
_resolve
reject
)
=
>
{
timeout
(
(
)
=
>
{
reject
(
new
PromiseTimeoutError
(
msg
)
)
;
}
ms
)
;
}
)
;
}
export
function
raceWithRejectOnTimeout
<
T
>
(
p
:
Promise
<
T
>
ms
:
number
msg
:
string
)
:
Promise
<
T
>
{
if
(
globalTestConfig
.
noRaceWithRejectOnTimeout
)
{
return
p
;
}
const
timeoutPromise
=
new
Promise
(
(
_resolve
reject
)
=
>
{
const
handle
=
timeout
(
(
)
=
>
{
reject
(
new
PromiseTimeoutError
(
msg
)
)
;
}
ms
)
;
p
=
p
.
finally
(
(
)
=
>
clearTimeout
(
handle
)
)
;
}
)
;
return
Promise
.
race
(
[
p
timeoutPromise
]
)
as
Promise
<
T
>
;
}
export
function
assertNotSettledWithinTime
(
p
:
Promise
<
unknown
>
ms
:
number
msg
:
string
)
:
Promise
<
undefined
>
{
const
rejectWhenSettled
=
p
.
then
(
(
)
=
>
Promise
.
reject
(
new
Error
(
msg
)
)
)
;
const
timeoutPromise
=
new
Promise
<
undefined
>
(
resolve
=
>
{
const
handle
=
timeout
(
(
)
=
>
{
resolve
(
undefined
)
;
}
ms
)
;
p
.
finally
(
(
)
=
>
clearTimeout
(
handle
)
)
;
}
)
;
return
Promise
.
race
(
[
rejectWhenSettled
timeoutPromise
]
)
;
}
export
function
rejectWithoutUncaught
<
T
>
(
err
:
unknown
)
:
Promise
<
T
>
{
const
p
=
Promise
.
reject
(
err
)
;
p
.
catch
(
(
)
=
>
{
}
)
;
return
p
;
}
export
function
sortObjectByKey
(
v
:
{
[
k
:
string
]
:
unknown
}
)
:
{
[
k
:
string
]
:
unknown
}
{
const
sortedObject
:
{
[
k
:
string
]
:
unknown
}
=
{
}
;
for
(
const
k
of
Object
.
keys
(
v
)
.
sort
(
)
)
{
sortedObject
[
k
]
=
v
[
k
]
;
}
return
sortedObject
;
}
export
function
objectEquals
(
x
:
unknown
y
:
unknown
)
:
boolean
{
if
(
typeof
x
!
=
=
'
object
'
|
|
typeof
y
!
=
=
'
object
'
)
{
if
(
typeof
x
=
=
=
'
number
'
&
&
typeof
y
=
=
=
'
number
'
&
&
Number
.
isNaN
(
x
)
&
&
Number
.
isNaN
(
y
)
)
{
return
true
;
}
return
x
=
=
=
y
;
}
if
(
x
=
=
=
null
|
|
y
=
=
=
null
)
return
x
=
=
=
y
;
if
(
x
.
constructor
!
=
=
y
.
constructor
)
return
false
;
if
(
x
instanceof
Function
)
return
x
=
=
=
y
;
if
(
x
instanceof
RegExp
)
return
x
=
=
=
y
;
if
(
x
=
=
=
y
|
|
x
.
valueOf
(
)
=
=
=
y
.
valueOf
(
)
)
return
true
;
if
(
Array
.
isArray
(
x
)
&
&
Array
.
isArray
(
y
)
&
&
x
.
length
!
=
=
y
.
length
)
return
false
;
if
(
x
instanceof
Date
)
return
false
;
if
(
!
(
x
instanceof
Object
)
)
return
false
;
if
(
!
(
y
instanceof
Object
)
)
return
false
;
const
x1
=
x
as
{
[
k
:
string
]
:
unknown
}
;
const
y1
=
y
as
{
[
k
:
string
]
:
unknown
}
;
const
p
=
Object
.
keys
(
x
)
;
return
Object
.
keys
(
y
)
.
every
(
i
=
>
p
.
indexOf
(
i
)
!
=
=
-
1
)
&
&
p
.
every
(
i
=
>
objectEquals
(
x1
[
i
]
y1
[
i
]
)
)
;
}
export
function
range
<
T
>
(
n
:
number
fn
:
(
i
:
number
)
=
>
T
)
:
T
[
]
{
return
[
.
.
.
new
Array
(
n
)
]
.
map
(
(
_
i
)
=
>
fn
(
i
)
)
;
}
export
function
*
iterRange
<
T
>
(
n
:
number
fn
:
(
i
:
number
)
=
>
T
)
:
Iterable
<
T
>
{
for
(
let
i
=
0
;
i
<
n
;
+
+
i
)
{
yield
fn
(
i
)
;
}
}
export
function
mapLazy
<
T
R
>
(
xs
:
Iterable
<
T
>
f
:
(
x
:
T
)
=
>
R
)
:
Iterable
<
R
>
{
return
{
*
[
Symbol
.
iterator
]
(
)
{
for
(
const
x
of
xs
)
{
yield
f
(
x
)
;
}
}
}
;
}
const
TypedArrayBufferViewInstances
=
[
new
Uint8Array
(
)
new
Uint8ClampedArray
(
)
new
Uint16Array
(
)
new
Uint32Array
(
)
new
Int8Array
(
)
new
Int16Array
(
)
new
Int32Array
(
)
new
Float16Array
(
)
new
Float32Array
(
)
new
Float64Array
(
)
]
as
const
;
export
type
TypedArrayBufferView
=
typeof
TypedArrayBufferViewInstances
[
number
]
;
export
type
TypedArrayBufferViewConstructor
<
A
extends
TypedArrayBufferView
=
TypedArrayBufferView
>
=
{
readonly
prototype
:
A
;
readonly
BYTES_PER_ELEMENT
:
number
;
new
(
)
:
A
;
new
(
elements
:
Iterable
<
number
>
)
:
A
;
new
(
array
:
ArrayLike
<
number
>
|
ArrayBufferLike
)
:
A
;
new
(
buffer
:
ArrayBufferLike
byteOffset
?
:
number
length
?
:
number
)
:
A
;
new
(
length
:
number
)
:
A
;
from
(
arrayLike
:
ArrayLike
<
number
>
)
:
A
;
from
(
arrayLike
:
Iterable
<
number
>
mapfn
?
:
(
v
:
number
k
:
number
)
=
>
number
thisArg
?
:
any
)
:
A
;
from
<
T
>
(
arrayLike
:
ArrayLike
<
T
>
mapfn
:
(
v
:
T
k
:
number
)
=
>
number
thisArg
?
:
any
)
:
A
;
of
(
.
.
.
items
:
number
[
]
)
:
A
;
}
;
export
const
kTypedArrayBufferViews
:
{
readonly
[
k
:
string
]
:
TypedArrayBufferViewConstructor
;
}
=
{
.
.
.
(
(
)
=
>
{
const
result
:
{
[
k
:
string
]
:
any
}
=
{
}
;
for
(
const
v
of
TypedArrayBufferViewInstances
)
{
result
[
v
.
constructor
.
name
]
=
v
.
constructor
;
}
return
result
;
}
)
(
)
}
;
export
const
kTypedArrayBufferViewKeys
=
keysOf
(
kTypedArrayBufferViews
)
;
export
const
kTypedArrayBufferViewConstructors
=
Object
.
values
(
kTypedArrayBufferViews
)
;
function
subarrayAsU8
(
buf
:
ArrayBuffer
|
TypedArrayBufferView
{
start
=
0
length
}
:
{
start
?
:
number
;
length
?
:
number
}
)
:
Uint8Array
|
Uint8ClampedArray
{
if
(
buf
instanceof
ArrayBuffer
)
{
return
new
Uint8Array
(
buf
start
length
)
;
}
else
if
(
buf
instanceof
Uint8Array
|
|
buf
instanceof
Uint8ClampedArray
)
{
if
(
start
=
=
=
0
&
&
(
length
=
=
=
undefined
|
|
length
=
=
=
buf
.
byteLength
)
)
{
return
buf
;
}
}
const
byteOffset
=
buf
.
byteOffset
+
start
*
buf
.
BYTES_PER_ELEMENT
;
const
byteLength
=
length
!
=
=
undefined
?
length
*
buf
.
BYTES_PER_ELEMENT
:
buf
.
byteLength
-
(
byteOffset
-
buf
.
byteOffset
)
;
return
new
Uint8Array
(
buf
.
buffer
byteOffset
byteLength
)
;
}
export
function
memcpy
(
src
:
{
src
:
ArrayBuffer
|
TypedArrayBufferView
;
start
?
:
number
;
length
?
:
number
}
dst
:
{
dst
:
ArrayBuffer
|
TypedArrayBufferView
;
start
?
:
number
}
)
:
void
{
subarrayAsU8
(
dst
.
dst
dst
)
.
set
(
subarrayAsU8
(
src
.
src
src
)
)
;
}
