import
{
Float16Array
}
from
'
.
.
/
.
.
/
external
/
petamoriken
/
float16
/
float16
.
js
'
;
import
{
SkipTestCase
}
from
'
.
.
/
framework
/
fixture
.
js
'
;
import
{
globalTestConfig
}
from
'
.
.
/
framework
/
test_config
.
js
'
;
import
{
keysOf
}
from
'
.
/
data_tables
.
js
'
;
import
{
timeout
}
from
'
.
/
timeout
.
js
'
;
export
class
ErrorWithExtra
extends
Error
{
readonly
extra
:
{
[
k
:
string
]
:
unknown
}
;
constructor
(
message
:
string
extra
:
(
)
=
>
{
}
)
;
constructor
(
base
:
ErrorWithExtra
newExtra
:
(
)
=
>
{
}
)
;
constructor
(
baseOrMessage
:
string
|
ErrorWithExtra
newExtra
:
(
)
=
>
{
}
)
{
const
message
=
typeof
baseOrMessage
=
=
=
'
string
'
?
baseOrMessage
:
baseOrMessage
.
message
;
super
(
message
)
;
const
oldExtras
=
baseOrMessage
instanceof
ErrorWithExtra
?
baseOrMessage
.
extra
:
{
}
;
this
.
extra
=
globalTestConfig
.
enableDebugLogs
?
{
.
.
.
oldExtras
.
.
.
newExtra
(
)
}
:
{
omitted
:
'
pass
?
debug
=
1
'
}
;
}
}
export
function
assert
(
condition
:
boolean
msg
?
:
string
|
(
(
)
=
>
string
)
)
:
asserts
condition
{
if
(
!
condition
)
{
throw
new
Error
(
msg
&
&
(
typeof
msg
=
=
=
'
string
'
?
msg
:
msg
(
)
)
)
;
}
}
export
function
assertOK
<
T
>
(
value
:
Error
|
T
)
:
T
{
if
(
value
instanceof
Error
)
{
throw
value
;
}
return
value
;
}
export
type
ExceptionCheckOptions
=
{
allowMissingStack
?
:
boolean
;
message
?
:
string
}
;
export
async
function
assertReject
(
expectedName
:
string
p
:
Promise
<
unknown
>
{
allowMissingStack
=
false
message
}
:
ExceptionCheckOptions
=
{
}
)
:
Promise
<
void
>
{
await
p
.
then
(
(
)
=
>
{
unreachable
(
message
)
;
}
ex
=
>
{
assert
(
ex
instanceof
Error
'
rejected
with
a
non
-
Error
object
'
)
;
assert
(
ex
.
name
=
=
=
expectedName
rejected
with
name
{
ex
.
name
}
instead
of
{
expectedName
}
)
;
if
(
!
allowMissingStack
)
{
const
m
=
message
?
(
{
message
}
)
:
'
'
;
assert
(
typeof
ex
.
stack
=
=
=
'
string
'
'
threw
as
expected
but
missing
stack
'
+
m
)
;
}
}
)
;
}
export
function
unreachable
(
msg
?
:
string
)
:
never
{
throw
new
Error
(
msg
)
;
}
export
function
skipTestCase
(
msg
:
string
)
:
never
{
throw
new
SkipTestCase
(
msg
)
;
}
const
perf
=
typeof
performance
!
=
=
'
undefined
'
?
performance
:
require
(
'
perf_hooks
'
)
.
performance
;
export
function
now
(
)
:
number
{
return
perf
.
now
(
)
;
}
export
function
resolveOnTimeout
(
ms
:
number
)
:
Promise
<
void
>
{
return
new
Promise
(
resolve
=
>
{
timeout
(
(
)
=
>
{
resolve
(
)
;
}
ms
)
;
}
)
;
}
export
class
PromiseTimeoutError
extends
Error
{
}
export
function
rejectOnTimeout
(
ms
:
number
msg
:
string
)
:
Promise
<
never
>
{
return
new
Promise
(
(
_resolve
reject
)
=
>
{
timeout
(
(
)
=
>
{
reject
(
new
PromiseTimeoutError
(
msg
)
)
;
}
ms
)
;
}
)
;
}
export
function
raceWithRejectOnTimeout
<
T
>
(
p
:
Promise
<
T
>
ms
:
number
msg
:
string
)
:
Promise
<
T
>
{
if
(
globalTestConfig
.
noRaceWithRejectOnTimeout
)
{
return
p
;
}
const
timeoutPromise
=
new
Promise
(
(
_resolve
reject
)
=
>
{
const
handle
=
timeout
(
(
)
=
>
{
reject
(
new
PromiseTimeoutError
(
msg
)
)
;
}
ms
)
;
p
=
p
.
finally
(
(
)
=
>
clearTimeout
(
handle
)
)
;
}
)
;
return
Promise
.
race
(
[
p
timeoutPromise
]
)
as
Promise
<
T
>
;
}
export
function
assertNotSettledWithinTime
(
p
:
Promise
<
unknown
>
ms
:
number
msg
:
string
)
:
Promise
<
undefined
>
{
const
rejectWhenSettled
=
p
.
then
(
(
)
=
>
Promise
.
reject
(
new
Error
(
msg
)
)
)
;
const
timeoutPromise
=
new
Promise
<
undefined
>
(
resolve
=
>
{
const
handle
=
timeout
(
(
)
=
>
{
resolve
(
undefined
)
;
}
ms
)
;
void
p
.
finally
(
(
)
=
>
clearTimeout
(
handle
)
)
;
}
)
;
return
Promise
.
race
(
[
rejectWhenSettled
timeoutPromise
]
)
;
}
export
function
rejectWithoutUncaught
<
T
>
(
err
:
unknown
)
:
Promise
<
T
>
{
const
p
=
Promise
.
reject
(
err
)
;
p
.
catch
(
(
)
=
>
{
}
)
;
return
p
;
}
export
function
isPlainObject
(
v
:
unknown
)
{
return
!
!
v
&
&
Object
.
getPrototypeOf
(
v
)
.
constructor
=
=
=
Object
.
prototype
.
constructor
;
}
export
function
sortObjectByKey
(
v
:
{
[
k
:
string
]
:
unknown
}
)
:
{
[
k
:
string
]
:
unknown
}
{
const
sortedObject
:
{
[
k
:
string
]
:
unknown
}
=
{
}
;
for
(
const
k
of
Object
.
keys
(
v
)
.
sort
(
)
)
{
sortedObject
[
k
]
=
v
[
k
]
;
}
return
sortedObject
;
}
export
function
objectEquals
(
x
:
unknown
y
:
unknown
distinguishSignedZero
:
boolean
=
false
)
:
boolean
{
if
(
typeof
x
!
=
=
'
object
'
|
|
typeof
y
!
=
=
'
object
'
)
{
if
(
typeof
x
=
=
=
'
number
'
&
&
typeof
y
=
=
=
'
number
'
&
&
Number
.
isNaN
(
x
)
&
&
Number
.
isNaN
(
y
)
)
{
return
true
;
}
return
distinguishSignedZero
?
Object
.
is
(
x
y
)
:
x
=
=
=
y
;
}
if
(
x
=
=
=
null
|
|
y
=
=
=
null
)
return
x
=
=
=
y
;
if
(
x
.
constructor
!
=
=
y
.
constructor
)
return
false
;
if
(
x
instanceof
Function
)
return
x
=
=
=
y
;
if
(
x
instanceof
RegExp
)
return
x
=
=
=
y
;
if
(
x
=
=
=
y
|
|
x
.
valueOf
(
)
=
=
=
y
.
valueOf
(
)
)
return
true
;
if
(
Array
.
isArray
(
x
)
&
&
Array
.
isArray
(
y
)
&
&
x
.
length
!
=
=
y
.
length
)
return
false
;
if
(
x
instanceof
Date
)
return
false
;
if
(
!
(
x
instanceof
Object
)
)
return
false
;
if
(
!
(
y
instanceof
Object
)
)
return
false
;
const
x1
=
x
as
{
[
k
:
string
]
:
unknown
}
;
const
y1
=
y
as
{
[
k
:
string
]
:
unknown
}
;
const
p
=
Object
.
keys
(
x
)
;
return
Object
.
keys
(
y
)
.
every
(
i
=
>
p
.
indexOf
(
i
)
!
=
=
-
1
)
&
&
p
.
every
(
i
=
>
objectEquals
(
x1
[
i
]
y1
[
i
]
)
)
;
}
export
function
range
<
T
>
(
n
:
number
fn
:
(
i
:
number
)
=
>
T
)
:
T
[
]
{
return
[
.
.
.
new
Array
(
n
)
]
.
map
(
(
_
i
)
=
>
fn
(
i
)
)
;
}
export
function
*
iterRange
<
T
>
(
n
:
number
fn
:
(
i
:
number
)
=
>
T
)
:
Iterable
<
T
>
{
for
(
let
i
=
0
;
i
<
n
;
+
+
i
)
{
yield
fn
(
i
)
;
}
}
export
function
mapLazy
<
T
R
>
(
xs
:
Iterable
<
T
>
f
:
(
x
:
T
)
=
>
R
)
:
Iterable
<
R
>
{
return
{
*
[
Symbol
.
iterator
]
(
)
{
for
(
const
x
of
xs
)
{
yield
f
(
x
)
;
}
}
}
;
}
export
function
count
<
T
>
(
xs
:
Iterable
<
T
>
predicate
:
(
x
:
T
)
=
>
boolean
)
:
number
{
let
count
=
0
;
for
(
const
x
of
xs
)
{
if
(
predicate
(
x
)
)
count
+
+
;
}
return
count
;
}
const
ReorderOrders
=
{
forward
:
true
backward
:
true
shiftByHalf
:
true
}
;
export
type
ReorderOrder
=
keyof
typeof
ReorderOrders
;
export
const
kReorderOrderKeys
=
keysOf
(
ReorderOrders
)
;
export
function
shiftByHalf
<
R
>
(
arr
:
R
[
]
)
:
R
[
]
{
const
len
=
arr
.
length
;
const
half
=
(
len
/
2
)
|
0
;
const
firstHalf
=
arr
.
splice
(
0
half
)
;
return
[
.
.
.
arr
.
.
.
firstHalf
]
;
}
export
function
reorder
<
R
>
(
order
:
ReorderOrder
arr
:
R
[
]
)
:
R
[
]
{
switch
(
order
)
{
case
'
forward
'
:
return
arr
.
slice
(
)
;
case
'
backward
'
:
return
arr
.
slice
(
)
.
reverse
(
)
;
case
'
shiftByHalf
'
:
{
return
shiftByHalf
(
arr
)
;
}
}
}
export
function
typedEntries
<
T
extends
Record
<
string
any
>
>
(
obj
:
T
)
:
Array
<
[
keyof
T
T
[
keyof
T
]
]
>
{
return
Object
.
entries
(
obj
)
as
Array
<
[
keyof
T
T
[
keyof
T
]
]
>
;
}
const
TypedArrayBufferViewInstances
=
[
new
Uint8Array
(
)
new
Uint8ClampedArray
(
)
new
Uint16Array
(
)
new
Uint32Array
(
)
new
Int8Array
(
)
new
Int16Array
(
)
new
Int32Array
(
)
new
Float16Array
(
)
new
Float32Array
(
)
new
Float64Array
(
)
new
BigInt64Array
(
)
new
BigUint64Array
(
)
]
as
const
;
export
type
TypedArrayBufferView
=
(
typeof
TypedArrayBufferViewInstances
)
[
number
]
;
export
type
TypedArrayBufferViewConstructor
<
A
extends
TypedArrayBufferView
=
TypedArrayBufferView
>
=
{
readonly
prototype
:
A
;
readonly
BYTES_PER_ELEMENT
:
number
;
new
(
)
:
A
;
new
(
elements
:
Iterable
<
number
>
)
:
A
;
new
(
array
:
ArrayLike
<
number
>
|
ArrayBufferLike
)
:
A
;
new
(
buffer
:
ArrayBufferLike
byteOffset
?
:
number
length
?
:
number
)
:
A
;
new
(
length
:
number
)
:
A
;
from
(
arrayLike
:
ArrayLike
<
number
>
)
:
A
;
from
(
arrayLike
:
Iterable
<
number
>
mapfn
?
:
(
v
:
number
k
:
number
)
=
>
number
thisArg
?
:
any
)
:
A
;
from
<
T
>
(
arrayLike
:
ArrayLike
<
T
>
mapfn
:
(
v
:
T
k
:
number
)
=
>
number
thisArg
?
:
any
)
:
A
;
of
(
.
.
.
items
:
number
[
]
)
:
A
;
}
;
export
const
kTypedArrayBufferViews
:
{
readonly
[
k
:
string
]
:
TypedArrayBufferViewConstructor
;
}
=
{
.
.
.
(
(
)
=
>
{
const
result
:
{
[
k
:
string
]
:
any
}
=
{
}
;
for
(
const
v
of
TypedArrayBufferViewInstances
)
{
result
[
v
.
constructor
.
name
]
=
v
.
constructor
;
}
return
result
;
}
)
(
)
}
;
export
const
kTypedArrayBufferViewKeys
=
keysOf
(
kTypedArrayBufferViews
)
;
export
const
kTypedArrayBufferViewConstructors
=
Object
.
values
(
kTypedArrayBufferViews
)
;
interface
TypedArrayMap
{
Int8Array
:
Int8Array
;
Uint8Array
:
Uint8Array
;
Int16Array
:
Int16Array
;
Uint16Array
:
Uint16Array
;
Uint8ClampedArray
:
Uint8ClampedArray
;
Int32Array
:
Int32Array
;
Uint32Array
:
Uint32Array
;
Float32Array
:
Float32Array
;
Float64Array
:
Float64Array
;
BigInt64Array
:
BigInt64Array
;
BigUint64Array
:
BigUint64Array
;
}
type
TypedArrayParam
<
K
extends
keyof
TypedArrayMap
>
=
{
type
:
K
;
data
:
readonly
number
[
]
;
}
;
export
function
typedArrayParam
<
K
extends
keyof
TypedArrayMap
>
(
type
:
K
data
:
number
[
]
)
:
TypedArrayParam
<
K
>
{
return
{
type
data
}
;
}
export
function
createTypedArray
<
K
extends
keyof
TypedArrayMap
>
(
type
:
K
data
:
readonly
number
[
]
)
:
TypedArrayMap
[
K
]
{
return
new
kTypedArrayBufferViews
[
type
]
(
data
)
as
TypedArrayMap
[
K
]
;
}
export
function
typedArrayFromParam
<
K
extends
keyof
TypedArrayMap
>
(
param
:
TypedArrayParam
<
K
>
)
:
TypedArrayMap
[
K
]
{
const
{
type
data
}
=
param
;
return
createTypedArray
(
type
data
)
;
}
function
subarrayAsU8
(
buf
:
ArrayBuffer
|
TypedArrayBufferView
{
start
=
0
length
}
:
{
start
?
:
number
;
length
?
:
number
}
)
:
Uint8Array
|
Uint8ClampedArray
{
if
(
buf
instanceof
ArrayBuffer
)
{
return
new
Uint8Array
(
buf
start
length
)
;
}
else
if
(
buf
instanceof
Uint8Array
|
|
buf
instanceof
Uint8ClampedArray
)
{
if
(
start
=
=
=
0
&
&
(
length
=
=
=
undefined
|
|
length
=
=
=
buf
.
byteLength
)
)
{
return
buf
;
}
}
const
byteOffset
=
buf
.
byteOffset
+
start
*
buf
.
BYTES_PER_ELEMENT
;
const
byteLength
=
length
!
=
=
undefined
?
length
*
buf
.
BYTES_PER_ELEMENT
:
buf
.
byteLength
-
(
byteOffset
-
buf
.
byteOffset
)
;
return
new
Uint8Array
(
buf
.
buffer
byteOffset
byteLength
)
;
}
export
function
memcpy
(
src
:
{
src
:
ArrayBuffer
|
TypedArrayBufferView
;
start
?
:
number
;
length
?
:
number
}
dst
:
{
dst
:
ArrayBuffer
|
TypedArrayBufferView
;
start
?
:
number
}
)
:
void
{
subarrayAsU8
(
dst
.
dst
dst
)
.
set
(
subarrayAsU8
(
src
.
src
src
)
)
;
}
export
interface
ValueTestVariant
{
mult
:
number
;
add
:
number
;
}
export
function
filterUniqueValueTestVariants
(
valueTestVariants
:
ValueTestVariant
[
]
)
{
return
new
Map
<
string
ValueTestVariant
>
(
valueTestVariants
.
map
(
v
=
>
[
m
:
{
v
.
mult
}
a
:
{
v
.
add
}
v
]
)
)
.
values
(
)
;
}
export
function
makeValueTestVariant
(
base
:
number
variant
:
ValueTestVariant
)
{
return
base
*
variant
.
mult
+
variant
.
add
;
}
export
function
hasFeature
(
features
:
GPUSupportedFeatures
feature
:
GPUFeatureName
)
{
return
features
.
has
(
feature
)
;
}
export
function
combinationsOfOneOrTwoUsages
(
usages
:
readonly
number
[
]
)
{
const
combinations
=
[
]
;
for
(
const
usage0
of
usages
)
{
for
(
const
usage1
of
usages
)
{
if
(
usage0
<
=
usage1
)
{
combinations
.
push
(
usage0
|
usage1
)
;
}
}
}
return
combinations
;
}
