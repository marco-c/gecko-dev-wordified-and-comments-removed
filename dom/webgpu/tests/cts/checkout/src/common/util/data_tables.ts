import
{
ResolveType
ZipKeysWithValues
}
from
'
.
/
types
.
js
'
;
export
type
valueof
<
K
>
=
K
[
keyof
K
]
;
export
function
keysOf
<
T
extends
string
>
(
obj
:
{
[
k
in
T
]
?
:
unknown
}
)
:
readonly
T
[
]
{
return
Object
.
keys
(
obj
)
as
unknown
[
]
as
T
[
]
;
}
export
function
numericKeysOf
<
T
extends
number
>
(
obj
:
{
[
k
in
T
]
?
:
unknown
}
)
:
readonly
T
[
]
{
return
Object
.
keys
(
obj
)
.
map
(
n
=
>
Number
(
n
)
as
T
)
;
}
export
function
objectsToRecord
<
T
extends
Object
>
(
objects
:
readonly
T
[
]
)
:
Record
<
string
T
>
{
const
record
=
{
}
;
return
objects
.
reduce
(
(
obj
type
)
=
>
{
return
{
.
.
.
obj
[
type
.
toString
(
)
]
:
type
}
;
}
record
)
;
}
export
function
makeTable
<
Members
extends
readonly
string
[
]
Defaults
extends
readonly
unknown
[
]
Table
extends
{
readonly
[
k
:
string
]
:
readonly
unknown
[
]
}
>
(
members
:
Members
defaults
:
Defaults
table
:
Table
)
:
{
readonly
[
k
in
keyof
Table
]
:
ResolveType
<
ZipKeysWithValues
<
Members
Table
[
k
]
Defaults
>
>
;
}
{
const
result
:
{
[
k
:
string
]
:
{
[
m
:
string
]
:
unknown
}
}
=
{
}
;
for
(
const
[
k
v
]
of
Object
.
entries
<
readonly
unknown
[
]
>
(
table
)
)
{
const
item
:
{
[
m
:
string
]
:
unknown
}
=
{
}
;
for
(
let
i
=
0
;
i
<
members
.
length
;
+
+
i
)
{
item
[
members
[
i
]
]
=
v
[
i
]
?
?
defaults
[
i
]
;
}
result
[
k
]
=
item
;
}
return
result
as
any
;
}
export
function
makeTableRenameAndFilter
<
Members
extends
readonly
string
[
]
DataMembers
extends
readonly
string
[
]
Defaults
extends
readonly
unknown
[
]
Table
extends
{
readonly
[
k
:
string
]
:
readonly
unknown
[
]
}
>
(
columnRenames
:
{
[
key
:
string
]
:
string
}
columnsKept
:
Members
columns
:
DataMembers
defaults
:
Defaults
table
:
Table
)
:
{
readonly
[
k
in
keyof
Table
]
:
ResolveType
<
ZipKeysWithValues
<
Members
Table
[
k
]
Defaults
>
>
;
}
{
const
result
:
{
[
k
:
string
]
:
{
[
m
:
string
]
:
unknown
}
}
=
{
}
;
const
keyToIndex
=
new
Map
<
string
number
>
(
columnsKept
.
map
(
name
=
>
{
const
remappedName
=
columnRenames
[
name
]
=
=
=
undefined
?
name
:
columnRenames
[
name
]
;
return
[
name
columns
.
indexOf
(
remappedName
)
]
;
}
)
)
;
for
(
const
[
k
v
]
of
Object
.
entries
<
readonly
unknown
[
]
>
(
table
)
)
{
const
item
:
{
[
m
:
string
]
:
unknown
}
=
{
}
;
for
(
const
member
of
columnsKept
)
{
const
ndx
=
keyToIndex
.
get
(
member
)
!
;
item
[
member
]
=
v
[
ndx
]
?
?
defaults
[
ndx
]
;
}
result
[
k
]
=
item
;
}
return
result
as
any
;
}
