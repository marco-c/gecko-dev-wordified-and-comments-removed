export
type
ResolveType
<
T
>
=
T
extends
object
?
T
extends
infer
O
?
{
[
K
in
keyof
O
]
:
ResolveType
<
O
[
K
]
>
}
:
never
:
T
;
export
type
TypeEqual
<
X
Y
>
=
(
<
T
>
(
)
=
>
T
extends
X
?
1
:
2
)
extends
<
T
>
(
)
=
>
T
extends
Y
?
1
:
2
?
true
:
false
;
export
function
assertTypeTrue
<
T
extends
true
>
(
)
{
}
export
type
UnionToIntersection
<
U
>
=
(
U
extends
any
?
(
k
:
U
)
=
>
void
:
never
)
extends
(
k
:
infer
I
)
=
>
void
?
I
:
never
;
type
EnsureSubtype
<
X
Y
>
=
X
extends
Y
?
X
:
never
;
type
TupleHeadOr
<
T
Default
>
=
T
extends
readonly
[
infer
H
.
.
.
(
readonly
unknown
[
]
)
]
?
H
:
Default
;
type
TupleTailOr
<
T
Default
>
=
T
extends
readonly
[
unknown
.
.
.
infer
Tail
]
?
Tail
:
Default
;
type
TypeOr
<
T
Default
>
=
T
extends
undefined
?
Default
:
T
;
export
type
ZipKeysWithValues
<
Keys
extends
readonly
string
[
]
Values
extends
readonly
unknown
[
]
Defaults
extends
readonly
unknown
[
]
>
=
Keys
extends
readonly
[
infer
KHead
.
.
.
infer
KTail
]
?
{
readonly
[
k
in
EnsureSubtype
<
KHead
string
>
]
:
TypeOr
<
TupleHeadOr
<
Values
undefined
>
TupleHeadOr
<
Defaults
undefined
>
>
;
}
&
ZipKeysWithValues
<
EnsureSubtype
<
KTail
readonly
string
[
]
>
TupleTailOr
<
Values
[
]
>
TupleTailOr
<
Defaults
[
]
>
>
:
{
}
;
