import
{
TestCaseRecorder
}
from
'
.
.
/
internal
/
logging
/
test_case_recorder
.
js
'
;
import
{
JSONWithUndefined
}
from
'
.
.
/
internal
/
params_utils
.
js
'
;
import
{
assert
ExceptionCheckOptions
unreachable
}
from
'
.
.
/
util
/
util
.
js
'
;
export
class
SkipTestCase
extends
Error
{
}
export
class
UnexpectedPassError
extends
Error
{
}
export
{
TestCaseRecorder
}
from
'
.
.
/
internal
/
logging
/
test_case_recorder
.
js
'
;
export
type
TestParams
=
{
readonly
[
k
:
string
]
:
JSONWithUndefined
;
}
;
type
DestroyableObject
=
|
{
destroy
(
)
:
void
}
|
{
destroyAsync
(
)
:
Promise
<
void
>
}
|
{
close
(
)
:
void
}
|
{
getExtension
(
extensionName
:
'
WEBGL_lose_context
'
)
:
WEBGL_lose_context
}
|
HTMLVideoElement
;
export
class
SubcaseBatchState
{
constructor
(
protected
readonly
recorder
:
TestCaseRecorder
public
readonly
params
:
TestParams
)
{
}
async
init
(
)
{
}
async
postInit
(
)
{
}
async
finalize
(
)
{
}
}
export
class
Fixture
<
S
extends
SubcaseBatchState
=
SubcaseBatchState
>
{
private
_params
:
unknown
;
private
_sharedState
:
S
;
readonly
rec
:
TestCaseRecorder
;
private
eventualExpectations
:
Array
<
Promise
<
unknown
>
>
=
[
]
;
private
numOutstandingAsyncExpectations
=
0
;
private
objectsToCleanUp
:
DestroyableObject
[
]
=
[
]
;
public
static
MakeSharedState
(
recorder
:
TestCaseRecorder
params
:
TestParams
)
:
SubcaseBatchState
{
return
new
SubcaseBatchState
(
recorder
params
)
;
}
constructor
(
sharedState
:
S
rec
:
TestCaseRecorder
params
:
TestParams
)
{
this
.
_sharedState
=
sharedState
;
this
.
rec
=
rec
;
this
.
_params
=
params
;
}
get
params
(
)
:
unknown
{
return
this
.
_params
;
}
get
sharedState
(
)
:
S
{
return
this
.
_sharedState
;
}
async
init
(
)
:
Promise
<
void
>
{
}
async
finalize
(
)
:
Promise
<
void
>
{
assert
(
this
.
numOutstandingAsyncExpectations
=
=
=
0
'
there
were
outstanding
immediateAsyncExpectations
(
e
.
g
.
expectUncapturedError
)
at
the
end
of
the
test
'
)
;
while
(
this
.
eventualExpectations
.
length
)
{
const
p
=
this
.
eventualExpectations
.
shift
(
)
!
;
try
{
await
p
;
}
catch
(
ex
)
{
this
.
rec
.
threw
(
ex
)
;
}
}
for
(
const
o
of
this
.
objectsToCleanUp
)
{
if
(
'
getExtension
'
in
o
)
{
const
WEBGL_lose_context
=
o
.
getExtension
(
'
WEBGL_lose_context
'
)
;
if
(
WEBGL_lose_context
)
WEBGL_lose_context
.
loseContext
(
)
;
}
else
if
(
'
destroy
'
in
o
)
{
o
.
destroy
(
)
;
}
else
if
(
'
destroyAsync
'
in
o
)
{
await
o
.
destroyAsync
(
)
;
}
else
if
(
'
close
'
in
o
)
{
o
.
close
(
)
;
}
else
{
o
.
src
=
'
'
;
o
.
srcObject
=
null
;
}
}
}
trackForCleanup
<
T
extends
DestroyableObject
|
Promise
<
DestroyableObject
>
>
(
o
:
T
)
:
T
{
if
(
o
instanceof
Promise
)
{
this
.
eventualAsyncExpectation
(
(
)
=
>
o
.
then
(
o
=
>
this
.
trackForCleanup
(
o
)
(
)
=
>
{
}
)
)
;
return
o
;
}
if
(
o
instanceof
GPUDevice
)
{
this
.
objectsToCleanUp
.
push
(
{
async
destroyAsync
(
)
{
o
.
destroy
(
)
;
await
o
.
lost
;
}
}
)
;
}
else
{
this
.
objectsToCleanUp
.
push
(
o
)
;
}
return
o
;
}
tryTrackForCleanup
<
T
>
(
o
:
T
)
:
T
{
if
(
typeof
o
=
=
=
'
object
'
&
&
o
!
=
=
null
)
{
if
(
'
destroy
'
in
o
|
|
'
close
'
in
o
|
|
o
instanceof
WebGLRenderingContext
|
|
o
instanceof
WebGL2RenderingContext
)
{
this
.
objectsToCleanUp
.
push
(
o
as
unknown
as
DestroyableObject
)
;
}
}
return
o
;
}
requestDeviceTracked
(
adapter
:
GPUAdapter
desc
:
GPUDeviceDescriptor
|
undefined
=
undefined
)
{
return
this
.
trackForCleanup
(
adapter
.
requestDevice
(
desc
)
)
;
}
debug
(
msg
:
string
)
:
void
{
this
.
rec
.
debug
(
new
Error
(
msg
)
)
;
}
info
(
msg
:
string
)
:
void
{
this
.
rec
.
info
(
new
Error
(
msg
)
)
;
}
skip
(
msg
:
string
)
:
never
{
throw
new
SkipTestCase
(
msg
)
;
}
skipIf
(
cond
:
boolean
msg
:
string
|
(
(
)
=
>
string
)
=
'
'
)
{
if
(
cond
)
{
this
.
skip
(
typeof
msg
=
=
=
'
function
'
?
msg
(
)
:
msg
)
;
}
}
warn
(
msg
?
:
string
)
:
void
{
this
.
rec
.
warn
(
new
Error
(
msg
)
)
;
}
fail
(
msg
?
:
string
)
:
void
{
this
.
rec
.
expectationFailed
(
new
Error
(
msg
)
)
;
}
protected
async
immediateAsyncExpectation
<
T
>
(
fn
:
(
)
=
>
Promise
<
T
>
)
:
Promise
<
T
>
{
this
.
numOutstandingAsyncExpectations
+
+
;
const
ret
=
await
fn
(
)
;
this
.
numOutstandingAsyncExpectations
-
-
;
return
ret
;
}
protected
eventualAsyncExpectation
<
T
>
(
fn
:
(
niceStack
:
Error
)
=
>
Promise
<
T
>
)
:
void
{
const
promise
=
fn
(
new
Error
(
)
)
;
this
.
eventualExpectations
.
push
(
promise
)
;
}
private
expectErrorValue
(
expectedError
:
string
|
true
ex
:
unknown
niceStack
:
Error
)
:
void
{
if
(
!
(
ex
instanceof
Error
)
)
{
niceStack
.
message
=
THREW
non
-
error
value
of
type
{
typeof
ex
}
:
{
ex
}
;
this
.
rec
.
expectationFailed
(
niceStack
)
;
return
;
}
const
actualName
=
ex
.
name
;
if
(
expectedError
!
=
=
true
&
&
actualName
!
=
=
expectedError
)
{
niceStack
.
message
=
THREW
{
actualName
}
instead
of
{
expectedError
}
:
{
ex
}
;
this
.
rec
.
expectationFailed
(
niceStack
)
;
}
else
{
niceStack
.
message
=
OK
:
threw
{
actualName
}
:
{
ex
.
message
}
;
this
.
rec
.
debug
(
niceStack
)
;
}
}
shouldResolve
(
p
:
Promise
<
unknown
>
msg
?
:
string
)
:
void
{
this
.
eventualAsyncExpectation
(
async
niceStack
=
>
{
const
m
=
msg
?
'
:
'
+
msg
:
'
'
;
try
{
await
p
;
niceStack
.
message
=
'
resolved
as
expected
'
+
m
;
}
catch
(
ex
)
{
niceStack
.
message
=
REJECTED
{
m
}
;
if
(
ex
instanceof
Error
)
{
niceStack
.
message
+
=
'
\
n
'
+
ex
.
message
;
}
this
.
rec
.
expectationFailed
(
niceStack
)
;
}
}
)
;
}
shouldReject
(
expectedName
:
string
p
:
Promise
<
unknown
>
{
allowMissingStack
=
false
message
}
:
ExceptionCheckOptions
=
{
}
)
:
void
{
this
.
eventualAsyncExpectation
(
async
niceStack
=
>
{
const
m
=
message
?
'
:
'
+
message
:
'
'
;
try
{
await
p
;
niceStack
.
message
=
'
DID
NOT
REJECT
'
+
m
;
this
.
rec
.
expectationFailed
(
niceStack
)
;
}
catch
(
ex
)
{
this
.
expectErrorValue
(
expectedName
ex
niceStack
)
;
if
(
!
allowMissingStack
)
{
if
(
!
(
ex
instanceof
Error
&
&
typeof
ex
.
stack
=
=
=
'
string
'
)
)
{
const
exMessage
=
ex
instanceof
Error
?
ex
.
message
:
'
?
'
;
niceStack
.
message
=
rejected
as
expected
but
missing
stack
(
{
exMessage
}
)
{
m
}
;
this
.
rec
.
expectationFailed
(
niceStack
)
;
}
}
}
}
)
;
}
shouldThrow
(
expectedError
:
string
|
boolean
fn
:
(
)
=
>
void
{
allowMissingStack
=
false
message
}
:
ExceptionCheckOptions
=
{
}
)
{
const
m
=
message
?
'
:
'
+
message
:
'
'
;
try
{
fn
(
)
;
if
(
expectedError
=
=
=
false
)
{
this
.
rec
.
debug
(
new
Error
(
'
did
not
throw
as
expected
'
+
m
)
)
;
}
else
{
this
.
rec
.
expectationFailed
(
new
Error
(
'
unexpectedly
did
not
throw
'
+
m
)
)
;
}
}
catch
(
ex
)
{
if
(
expectedError
=
=
=
false
)
{
this
.
rec
.
expectationFailed
(
new
Error
(
'
threw
unexpectedly
'
+
m
)
)
;
}
else
{
this
.
expectErrorValue
(
expectedError
ex
new
Error
(
m
)
)
;
if
(
!
allowMissingStack
)
{
if
(
!
(
ex
instanceof
Error
&
&
typeof
ex
.
stack
=
=
=
'
string
'
)
)
{
this
.
rec
.
expectationFailed
(
new
Error
(
'
threw
as
expected
but
missing
stack
'
+
m
)
)
;
}
}
}
}
}
expect
(
cond
:
boolean
msg
?
:
string
)
:
boolean
{
if
(
cond
)
{
const
m
=
msg
?
'
:
'
+
msg
:
'
'
;
this
.
rec
.
debug
(
new
Error
(
'
expect
OK
'
+
m
)
)
;
}
else
{
this
.
rec
.
expectationFailed
(
new
Error
(
msg
)
)
;
}
return
cond
;
}
expectOK
(
error
:
Error
|
undefined
|
(
Error
|
undefined
)
[
]
{
mode
=
'
fail
'
niceStack
}
:
{
mode
?
:
'
fail
'
|
'
warn
'
;
niceStack
?
:
Error
}
=
{
}
)
:
void
{
const
handleError
=
(
error
:
Error
|
undefined
)
=
>
{
if
(
error
instanceof
Error
)
{
if
(
niceStack
)
{
error
.
stack
=
niceStack
.
stack
;
}
if
(
mode
=
=
=
'
fail
'
)
{
this
.
rec
.
expectationFailed
(
error
)
;
}
else
if
(
mode
=
=
=
'
warn
'
)
{
this
.
rec
.
warn
(
error
)
;
}
else
{
unreachable
(
)
;
}
}
}
;
if
(
Array
.
isArray
(
error
)
)
{
for
(
const
e
of
error
)
{
handleError
(
e
)
;
}
}
else
{
handleError
(
error
)
;
}
}
eventualExpectOK
(
error
:
Promise
<
Error
|
undefined
|
(
Error
|
undefined
)
[
]
>
{
mode
=
'
fail
'
}
:
{
mode
?
:
'
fail
'
|
'
warn
'
}
=
{
}
)
{
this
.
eventualAsyncExpectation
(
async
niceStack
=
>
{
this
.
expectOK
(
await
error
{
mode
niceStack
}
)
;
}
)
;
}
}
export
type
SubcaseBatchStateFromFixture
<
F
>
=
F
extends
Fixture
<
infer
S
>
?
S
:
never
;
export
type
FixtureClass
<
F
extends
Fixture
=
Fixture
>
=
{
new
(
sharedState
:
SubcaseBatchStateFromFixture
<
F
>
log
:
TestCaseRecorder
params
:
TestParams
)
:
F
;
MakeSharedState
(
recorder
:
TestCaseRecorder
params
:
TestParams
)
:
SubcaseBatchStateFromFixture
<
F
>
;
}
;
export
type
FixtureClassInterface
<
F
extends
Fixture
=
Fixture
>
=
{
new
(
.
.
.
args
:
any
[
]
)
:
F
;
MakeSharedState
(
recorder
:
TestCaseRecorder
params
:
TestParams
)
:
SubcaseBatchStateFromFixture
<
F
>
;
}
;
export
type
FixtureClassWithMixin
<
FC
M
>
=
FC
extends
FixtureClass
<
infer
F
>
?
FixtureClass
<
F
&
M
>
:
never
;
