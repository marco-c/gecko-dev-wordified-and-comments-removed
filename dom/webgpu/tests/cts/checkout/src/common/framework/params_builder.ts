import
{
Merged
mergeParams
mergeParamsChecked
}
from
'
.
.
/
internal
/
params_utils
.
js
'
;
import
{
comparePublicParamsPaths
Ordering
}
from
'
.
.
/
internal
/
query
/
compare
.
js
'
;
import
{
stringifyPublicParams
}
from
'
.
.
/
internal
/
query
/
stringify_params
.
js
'
;
import
{
DeepReadonly
}
from
'
.
.
/
util
/
types
.
js
'
;
import
{
assert
mapLazy
objectEquals
}
from
'
.
.
/
util
/
util
.
js
'
;
import
{
TestParams
}
from
'
.
/
fixture
.
js
'
;
export
interface
ParamsBuilder
{
expandWithParams
(
expander
:
(
_
:
any
)
=
>
any
)
:
any
;
expand
(
key
:
string
expander
:
(
_
:
any
)
=
>
any
)
:
any
;
combineWithParams
(
newParams
:
Iterable
<
any
>
)
:
any
;
combine
(
key
:
string
newParams
:
Iterable
<
any
>
)
:
any
;
filter
(
pred
:
(
_
:
any
)
=
>
boolean
)
:
any
;
unless
(
pred
:
(
_
:
any
)
=
>
boolean
)
:
any
;
}
export
type
ParamTypeOf
<
T
extends
ParamsBuilder
>
=
T
extends
SubcaseParamsBuilder
<
infer
CaseP
infer
SubcaseP
>
?
Merged
<
CaseP
SubcaseP
>
:
T
extends
CaseParamsBuilder
<
infer
CaseP
>
?
CaseP
:
never
;
export
type
CaseSubcaseIterable
<
CaseP
SubcaseP
>
=
Iterable
<
readonly
[
DeepReadonly
<
CaseP
>
Iterable
<
DeepReadonly
<
SubcaseP
>
>
|
undefined
]
>
;
export
abstract
class
ParamsBuilderBase
<
CaseP
extends
{
}
SubcaseP
extends
{
}
>
{
protected
readonly
cases
:
(
caseFilter
:
TestParams
|
null
)
=
>
Generator
<
CaseP
>
;
constructor
(
cases
:
(
caseFilter
:
TestParams
|
null
)
=
>
Generator
<
CaseP
>
)
{
this
.
cases
=
cases
;
}
protected
abstract
iterateCasesWithSubcases
(
caseFilter
:
TestParams
|
null
)
:
CaseSubcaseIterable
<
CaseP
SubcaseP
>
;
}
export
function
builderIterateCasesWithSubcases
(
builder
:
ParamsBuilderBase
<
{
}
{
}
>
caseFilter
:
TestParams
|
null
)
{
interface
IterableParamsBuilder
{
iterateCasesWithSubcases
(
caseFilter
:
TestParams
|
null
)
:
CaseSubcaseIterable
<
{
}
{
}
>
;
}
return
(
builder
as
unknown
as
IterableParamsBuilder
)
.
iterateCasesWithSubcases
(
caseFilter
)
;
}
export
class
CaseParamsBuilder
<
CaseP
extends
{
}
>
extends
ParamsBuilderBase
<
CaseP
{
}
>
implements
Iterable
<
DeepReadonly
<
CaseP
>
>
ParamsBuilder
{
*
iterateCasesWithSubcases
(
caseFilter
:
TestParams
|
null
)
:
CaseSubcaseIterable
<
CaseP
{
}
>
{
for
(
const
caseP
of
this
.
cases
(
caseFilter
)
)
{
if
(
caseFilter
)
{
const
ordering
=
comparePublicParamsPaths
(
caseP
caseFilter
)
;
if
(
ordering
=
=
=
Ordering
.
StrictSuperset
|
|
ordering
=
=
=
Ordering
.
Unordered
)
{
continue
;
}
}
yield
[
caseP
as
DeepReadonly
<
typeof
caseP
>
undefined
]
;
}
}
[
Symbol
.
iterator
]
(
)
:
Iterator
<
DeepReadonly
<
CaseP
>
>
{
return
this
.
cases
(
null
)
as
Iterator
<
DeepReadonly
<
CaseP
>
>
;
}
expandWithParams
<
NewP
extends
{
}
>
(
expander
:
(
_
:
CaseP
)
=
>
Iterable
<
NewP
>
)
:
CaseParamsBuilder
<
Merged
<
CaseP
NewP
>
>
{
const
baseGenerator
=
this
.
cases
;
return
new
CaseParamsBuilder
(
function
*
(
caseFilter
)
{
for
(
const
a
of
baseGenerator
(
caseFilter
)
)
{
for
(
const
b
of
expander
(
a
)
)
{
if
(
caseFilter
)
{
const
kvPairs
=
Object
.
entries
(
b
)
;
if
(
kvPairs
.
some
(
(
[
k
v
]
)
=
>
k
in
caseFilter
&
&
!
objectEquals
(
caseFilter
[
k
]
v
)
)
)
{
continue
;
}
}
yield
mergeParamsChecked
(
a
b
)
;
}
}
}
)
;
}
expand
<
NewPKey
extends
string
NewPValue
>
(
key
:
NewPKey
expander
:
(
_
:
CaseP
)
=
>
Iterable
<
NewPValue
>
)
:
CaseParamsBuilder
<
Merged
<
CaseP
{
[
name
in
NewPKey
]
:
NewPValue
}
>
>
{
const
baseGenerator
=
this
.
cases
;
return
new
CaseParamsBuilder
(
function
*
(
caseFilter
)
{
for
(
const
a
of
baseGenerator
(
caseFilter
)
)
{
assert
(
!
(
key
in
a
)
New
key
'
{
key
}
'
already
exists
in
{
JSON
.
stringify
(
a
)
}
)
;
for
(
const
v
of
expander
(
a
)
)
{
if
(
caseFilter
&
&
key
in
caseFilter
)
{
if
(
!
objectEquals
(
caseFilter
[
key
]
v
)
)
{
continue
;
}
}
yield
{
.
.
.
a
[
key
]
:
v
}
as
Merged
<
CaseP
{
[
name
in
NewPKey
]
:
NewPValue
}
>
;
}
}
}
)
;
}
combineWithParams
<
NewP
extends
{
}
>
(
newParams
:
Iterable
<
NewP
>
)
:
CaseParamsBuilder
<
Merged
<
CaseP
NewP
>
>
{
assertNotGenerator
(
newParams
)
;
const
seenValues
=
new
Set
<
string
>
(
)
;
for
(
const
params
of
newParams
)
{
const
paramsStr
=
stringifyPublicParams
(
params
)
;
assert
(
!
seenValues
.
has
(
paramsStr
)
Duplicate
entry
in
combine
[
WithParams
]
:
{
paramsStr
}
)
;
seenValues
.
add
(
paramsStr
)
;
}
return
this
.
expandWithParams
(
(
)
=
>
newParams
)
;
}
combine
<
NewPKey
extends
string
NewPValue
>
(
key
:
NewPKey
values
:
Iterable
<
NewPValue
>
)
:
CaseParamsBuilder
<
Merged
<
CaseP
{
[
name
in
NewPKey
]
:
NewPValue
}
>
>
{
assertNotGenerator
(
values
)
;
const
mapped
=
mapLazy
(
values
v
=
>
(
{
[
key
]
:
v
}
)
as
{
[
name
in
NewPKey
]
:
NewPValue
}
)
;
return
this
.
combineWithParams
(
mapped
)
;
}
filter
(
pred
:
(
_
:
CaseP
)
=
>
boolean
)
:
CaseParamsBuilder
<
CaseP
>
{
const
baseGenerator
=
this
.
cases
;
return
new
CaseParamsBuilder
(
function
*
(
caseFilter
)
{
for
(
const
a
of
baseGenerator
(
caseFilter
)
)
{
if
(
pred
(
a
)
)
yield
a
;
}
}
)
;
}
unless
(
pred
:
(
_
:
CaseP
)
=
>
boolean
)
:
CaseParamsBuilder
<
CaseP
>
{
return
this
.
filter
(
x
=
>
!
pred
(
x
)
)
;
}
beginSubcases
(
)
:
SubcaseParamsBuilder
<
CaseP
{
}
>
{
return
new
SubcaseParamsBuilder
(
this
.
cases
function
*
(
)
{
yield
{
}
;
}
)
;
}
}
export
const
kUnitCaseParamsBuilder
=
new
CaseParamsBuilder
(
function
*
(
)
{
yield
{
}
;
}
)
;
export
class
SubcaseParamsBuilder
<
CaseP
extends
{
}
SubcaseP
extends
{
}
>
extends
ParamsBuilderBase
<
CaseP
SubcaseP
>
implements
ParamsBuilder
{
protected
readonly
subcases
:
(
_
:
CaseP
)
=
>
Generator
<
SubcaseP
>
;
constructor
(
cases
:
(
caseFilter
:
TestParams
|
null
)
=
>
Generator
<
CaseP
>
generator
:
(
_
:
CaseP
)
=
>
Generator
<
SubcaseP
>
)
{
super
(
cases
)
;
this
.
subcases
=
generator
;
}
*
iterateCasesWithSubcases
(
caseFilter
:
TestParams
|
null
)
:
CaseSubcaseIterable
<
CaseP
SubcaseP
>
{
for
(
const
caseP
of
this
.
cases
(
caseFilter
)
)
{
if
(
caseFilter
)
{
const
ordering
=
comparePublicParamsPaths
(
caseP
caseFilter
)
;
if
(
ordering
=
=
=
Ordering
.
StrictSuperset
|
|
ordering
=
=
=
Ordering
.
Unordered
)
{
continue
;
}
}
const
subcases
=
Array
.
from
(
this
.
subcases
(
caseP
)
)
;
if
(
subcases
.
length
)
{
yield
[
caseP
as
DeepReadonly
<
typeof
caseP
>
subcases
as
DeepReadonly
<
(
typeof
subcases
)
[
number
]
>
[
]
]
;
}
}
}
expandWithParams
<
NewP
extends
{
}
>
(
expander
:
(
_
:
Merged
<
CaseP
SubcaseP
>
)
=
>
Iterable
<
NewP
>
)
:
SubcaseParamsBuilder
<
CaseP
Merged
<
SubcaseP
NewP
>
>
{
const
baseGenerator
=
this
.
subcases
;
return
new
SubcaseParamsBuilder
(
this
.
cases
function
*
(
base
)
{
for
(
const
a
of
baseGenerator
(
base
)
)
{
for
(
const
b
of
expander
(
mergeParams
(
base
a
)
)
)
{
yield
mergeParamsChecked
(
a
b
)
;
}
}
}
)
;
}
expand
<
NewPKey
extends
string
NewPValue
>
(
key
:
NewPKey
expander
:
(
_
:
Merged
<
CaseP
SubcaseP
>
)
=
>
Iterable
<
NewPValue
>
)
:
SubcaseParamsBuilder
<
CaseP
Merged
<
SubcaseP
{
[
name
in
NewPKey
]
:
NewPValue
}
>
>
{
const
baseGenerator
=
this
.
subcases
;
return
new
SubcaseParamsBuilder
(
this
.
cases
function
*
(
base
)
{
for
(
const
a
of
baseGenerator
(
base
)
)
{
const
before
=
mergeParams
(
base
a
)
;
assert
(
!
(
key
in
before
)
(
)
=
>
Key
'
{
key
}
'
already
exists
in
{
JSON
.
stringify
(
before
)
}
)
;
for
(
const
v
of
expander
(
before
)
)
{
yield
{
.
.
.
a
[
key
]
:
v
}
as
Merged
<
SubcaseP
{
[
k
in
NewPKey
]
:
NewPValue
}
>
;
}
}
}
)
;
}
combineWithParams
<
NewP
extends
{
}
>
(
newParams
:
Iterable
<
NewP
>
)
:
SubcaseParamsBuilder
<
CaseP
Merged
<
SubcaseP
NewP
>
>
{
assertNotGenerator
(
newParams
)
;
return
this
.
expandWithParams
(
(
)
=
>
newParams
)
;
}
combine
<
NewPKey
extends
string
NewPValue
>
(
key
:
NewPKey
values
:
Iterable
<
NewPValue
>
)
:
SubcaseParamsBuilder
<
CaseP
Merged
<
SubcaseP
{
[
name
in
NewPKey
]
:
NewPValue
}
>
>
{
assertNotGenerator
(
values
)
;
return
this
.
expand
(
key
(
)
=
>
values
)
;
}
filter
(
pred
:
(
_
:
Merged
<
CaseP
SubcaseP
>
)
=
>
boolean
)
:
SubcaseParamsBuilder
<
CaseP
SubcaseP
>
{
const
baseGenerator
=
this
.
subcases
;
return
new
SubcaseParamsBuilder
(
this
.
cases
function
*
(
base
)
{
for
(
const
a
of
baseGenerator
(
base
)
)
{
if
(
pred
(
mergeParams
(
base
a
)
)
)
yield
a
;
}
}
)
;
}
unless
(
pred
:
(
_
:
Merged
<
CaseP
SubcaseP
>
)
=
>
boolean
)
:
SubcaseParamsBuilder
<
CaseP
SubcaseP
>
{
return
this
.
filter
(
x
=
>
!
pred
(
x
)
)
;
}
}
function
assertNotGenerator
(
x
:
object
)
{
if
(
'
constructor
'
in
x
)
{
assert
(
x
.
constructor
!
=
=
(
function
*
(
)
{
}
)
(
)
.
constructor
'
Argument
must
not
be
a
generator
as
generators
are
not
reusable
'
)
;
}
}
