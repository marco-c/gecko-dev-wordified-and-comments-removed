import
{
Merged
mergeParams
}
from
'
.
.
/
internal
/
params_utils
.
js
'
;
import
{
stringifyPublicParams
}
from
'
.
.
/
internal
/
query
/
stringify_params
.
js
'
;
import
{
assert
mapLazy
}
from
'
.
.
/
util
/
util
.
js
'
;
export
interface
ParamsBuilder
{
expandWithParams
(
expander
:
(
_
:
any
)
=
>
any
)
:
any
;
expand
(
key
:
string
expander
:
(
_
:
any
)
=
>
any
)
:
any
;
combineWithParams
(
newParams
:
Iterable
<
any
>
)
:
any
;
combine
(
key
:
string
newParams
:
Iterable
<
any
>
)
:
any
;
filter
(
pred
:
(
_
:
any
)
=
>
boolean
)
:
any
;
unless
(
pred
:
(
_
:
any
)
=
>
boolean
)
:
any
;
}
export
type
ParamTypeOf
<
T
extends
ParamsBuilder
>
=
T
extends
SubcaseParamsBuilder
<
infer
CaseP
infer
SubcaseP
>
?
Merged
<
CaseP
SubcaseP
>
:
T
extends
CaseParamsBuilder
<
infer
CaseP
>
?
CaseP
:
never
;
export
type
CaseSubcaseIterable
<
CaseP
SubcaseP
>
=
Iterable
<
readonly
[
CaseP
Iterable
<
SubcaseP
>
|
undefined
]
>
;
export
abstract
class
ParamsBuilderBase
<
CaseP
extends
{
}
SubcaseP
extends
{
}
>
{
protected
readonly
cases
:
(
)
=
>
Generator
<
CaseP
>
;
constructor
(
cases
:
(
)
=
>
Generator
<
CaseP
>
)
{
this
.
cases
=
cases
;
}
protected
abstract
iterateCasesWithSubcases
(
)
:
CaseSubcaseIterable
<
CaseP
SubcaseP
>
;
}
export
function
builderIterateCasesWithSubcases
(
builder
:
ParamsBuilderBase
<
{
}
{
}
>
)
{
interface
IterableParamsBuilder
{
iterateCasesWithSubcases
(
)
:
CaseSubcaseIterable
<
{
}
{
}
>
;
}
return
(
(
builder
as
unknown
)
as
IterableParamsBuilder
)
.
iterateCasesWithSubcases
(
)
;
}
export
class
CaseParamsBuilder
<
CaseP
extends
{
}
>
extends
ParamsBuilderBase
<
CaseP
{
}
>
implements
Iterable
<
CaseP
>
ParamsBuilder
{
*
iterateCasesWithSubcases
(
)
:
CaseSubcaseIterable
<
CaseP
{
}
>
{
for
(
const
a
of
this
.
cases
(
)
)
{
yield
[
a
undefined
]
;
}
}
[
Symbol
.
iterator
]
(
)
:
Iterator
<
CaseP
>
{
return
this
.
cases
(
)
;
}
expandWithParams
<
NewP
extends
{
}
>
(
expander
:
(
_
:
Merged
<
{
}
CaseP
>
)
=
>
Iterable
<
NewP
>
)
:
CaseParamsBuilder
<
Merged
<
CaseP
NewP
>
>
{
const
newGenerator
=
expanderGenerator
(
this
.
cases
expander
)
;
return
new
CaseParamsBuilder
(
(
)
=
>
newGenerator
(
{
}
)
)
;
}
expand
<
NewPKey
extends
string
NewPValue
>
(
key
:
NewPKey
expander
:
(
_
:
Merged
<
{
}
CaseP
>
)
=
>
Iterable
<
NewPValue
>
)
:
CaseParamsBuilder
<
Merged
<
CaseP
{
[
name
in
NewPKey
]
:
NewPValue
}
>
>
{
return
this
.
expandWithParams
(
function
*
(
p
)
{
for
(
const
value
of
expander
(
p
)
)
{
yield
{
[
key
]
:
value
}
as
{
readonly
[
name
in
NewPKey
]
:
NewPValue
}
;
}
}
)
;
}
combineWithParams
<
NewP
extends
{
}
>
(
newParams
:
Iterable
<
NewP
>
)
:
CaseParamsBuilder
<
Merged
<
CaseP
NewP
>
>
{
assertNotGenerator
(
newParams
)
;
const
seenValues
=
new
Set
<
string
>
(
)
;
for
(
const
params
of
newParams
)
{
const
paramsStr
=
stringifyPublicParams
(
params
)
;
assert
(
!
seenValues
.
has
(
paramsStr
)
Duplicate
entry
in
combine
[
WithParams
]
:
{
paramsStr
}
)
;
seenValues
.
add
(
paramsStr
)
;
}
return
this
.
expandWithParams
(
(
)
=
>
newParams
)
;
}
combine
<
NewPKey
extends
string
NewPValue
>
(
key
:
NewPKey
values
:
Iterable
<
NewPValue
>
)
:
CaseParamsBuilder
<
Merged
<
CaseP
{
[
name
in
NewPKey
]
:
NewPValue
}
>
>
{
assertNotGenerator
(
values
)
;
const
mapped
=
mapLazy
(
values
v
=
>
(
{
[
key
]
:
v
}
as
{
[
name
in
NewPKey
]
:
NewPValue
}
)
)
;
return
this
.
combineWithParams
(
mapped
)
;
}
filter
(
pred
:
(
_
:
Merged
<
{
}
CaseP
>
)
=
>
boolean
)
:
CaseParamsBuilder
<
CaseP
>
{
const
newGenerator
=
filterGenerator
(
this
.
cases
pred
)
;
return
new
CaseParamsBuilder
(
(
)
=
>
newGenerator
(
{
}
)
)
;
}
unless
(
pred
:
(
_
:
Merged
<
{
}
CaseP
>
)
=
>
boolean
)
:
CaseParamsBuilder
<
CaseP
>
{
return
this
.
filter
(
x
=
>
!
pred
(
x
)
)
;
}
beginSubcases
(
)
:
SubcaseParamsBuilder
<
CaseP
{
}
>
{
return
new
SubcaseParamsBuilder
(
(
)
=
>
this
.
cases
(
)
function
*
(
)
{
yield
{
}
;
}
)
;
}
}
export
const
kUnitCaseParamsBuilder
=
new
CaseParamsBuilder
(
function
*
(
)
{
yield
{
}
;
}
)
;
export
class
SubcaseParamsBuilder
<
CaseP
extends
{
}
SubcaseP
extends
{
}
>
extends
ParamsBuilderBase
<
CaseP
SubcaseP
>
implements
ParamsBuilder
{
protected
readonly
subcases
:
(
_
:
CaseP
)
=
>
Generator
<
SubcaseP
>
;
constructor
(
cases
:
(
)
=
>
Generator
<
CaseP
>
generator
:
(
_
:
CaseP
)
=
>
Generator
<
SubcaseP
>
)
{
super
(
cases
)
;
this
.
subcases
=
generator
;
}
*
iterateCasesWithSubcases
(
)
:
CaseSubcaseIterable
<
CaseP
SubcaseP
>
{
for
(
const
caseP
of
this
.
cases
(
)
)
{
const
subcases
=
Array
.
from
(
this
.
subcases
(
caseP
)
)
;
if
(
subcases
.
length
)
{
yield
[
caseP
subcases
]
;
}
}
}
expandWithParams
<
NewP
extends
{
}
>
(
expander
:
(
_
:
Merged
<
CaseP
SubcaseP
>
)
=
>
Iterable
<
NewP
>
)
:
SubcaseParamsBuilder
<
CaseP
Merged
<
SubcaseP
NewP
>
>
{
return
new
SubcaseParamsBuilder
(
this
.
cases
expanderGenerator
(
this
.
subcases
expander
)
)
;
}
expand
<
NewPKey
extends
string
NewPValue
>
(
key
:
NewPKey
expander
:
(
_
:
Merged
<
CaseP
SubcaseP
>
)
=
>
Iterable
<
NewPValue
>
)
:
SubcaseParamsBuilder
<
CaseP
Merged
<
SubcaseP
{
[
name
in
NewPKey
]
:
NewPValue
}
>
>
{
return
this
.
expandWithParams
(
function
*
(
p
)
{
for
(
const
value
of
expander
(
p
)
)
{
yield
{
[
key
]
:
value
}
as
{
[
name
in
NewPKey
]
:
NewPValue
}
;
}
}
)
;
}
combineWithParams
<
NewP
extends
{
}
>
(
newParams
:
Iterable
<
NewP
>
)
:
SubcaseParamsBuilder
<
CaseP
Merged
<
SubcaseP
NewP
>
>
{
assertNotGenerator
(
newParams
)
;
return
this
.
expandWithParams
(
(
)
=
>
newParams
)
;
}
combine
<
NewPKey
extends
string
NewPValue
>
(
key
:
NewPKey
values
:
Iterable
<
NewPValue
>
)
:
SubcaseParamsBuilder
<
CaseP
Merged
<
SubcaseP
{
[
name
in
NewPKey
]
:
NewPValue
}
>
>
{
assertNotGenerator
(
values
)
;
return
this
.
expand
(
key
(
)
=
>
values
)
;
}
filter
(
pred
:
(
_
:
Merged
<
CaseP
SubcaseP
>
)
=
>
boolean
)
:
SubcaseParamsBuilder
<
CaseP
SubcaseP
>
{
return
new
SubcaseParamsBuilder
(
this
.
cases
filterGenerator
(
this
.
subcases
pred
)
)
;
}
unless
(
pred
:
(
_
:
Merged
<
CaseP
SubcaseP
>
)
=
>
boolean
)
:
SubcaseParamsBuilder
<
CaseP
SubcaseP
>
{
return
this
.
filter
(
x
=
>
!
pred
(
x
)
)
;
}
}
function
expanderGenerator
<
Base
A
B
>
(
baseGenerator
:
(
_
:
Base
)
=
>
Generator
<
A
>
expander
:
(
_
:
Merged
<
Base
A
>
)
=
>
Iterable
<
B
>
)
:
(
_
:
Base
)
=
>
Generator
<
Merged
<
A
B
>
>
{
return
function
*
(
base
:
Base
)
{
for
(
const
a
of
baseGenerator
(
base
)
)
{
for
(
const
b
of
expander
(
mergeParams
(
base
a
)
)
)
{
yield
mergeParams
(
a
b
)
;
}
}
}
;
}
function
filterGenerator
<
Base
A
>
(
baseGenerator
:
(
_
:
Base
)
=
>
Generator
<
A
>
pred
:
(
_
:
Merged
<
Base
A
>
)
=
>
boolean
)
:
(
_
:
Base
)
=
>
Generator
<
A
>
{
return
function
*
(
base
:
Base
)
{
for
(
const
a
of
baseGenerator
(
base
)
)
{
if
(
pred
(
mergeParams
(
base
a
)
)
)
{
yield
a
;
}
}
}
;
}
function
assertNotGenerator
(
x
:
object
)
{
if
(
'
constructor
'
in
x
)
{
assert
(
x
.
constructor
!
=
=
(
function
*
(
)
{
}
)
(
)
.
constructor
'
Argument
must
not
be
a
generator
as
generators
are
not
reusable
'
)
;
}
}
