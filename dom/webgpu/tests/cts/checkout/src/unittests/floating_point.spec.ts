export
const
description
=
Floating
Point
unit
tests
.
;
import
{
makeTestGroup
}
from
'
.
.
/
common
/
framework
/
test_group
.
js
'
;
import
{
objectEquals
unreachable
}
from
'
.
.
/
common
/
util
/
util
.
js
'
;
import
{
kValue
}
from
'
.
.
/
webgpu
/
util
/
constants
.
js
'
;
import
{
FP
FPInterval
FPIntervalParam
IntervalBounds
}
from
'
.
.
/
webgpu
/
util
/
floating_point
.
js
'
;
import
{
reinterpretU16AsF16
reinterpretU32AsF32
reinterpretU64AsF64
map2DArray
oneULPF32
oneULPF16
oneULPF64
}
from
'
.
.
/
webgpu
/
util
/
math
.
js
'
;
import
{
UnitTest
}
from
'
.
/
unit_test
.
js
'
;
export
const
g
=
makeTestGroup
(
UnitTest
)
;
const
kUnboundedBounds
:
IntervalBounds
=
[
Number
.
NEGATIVE_INFINITY
Number
.
POSITIVE_INFINITY
]
;
const
kUnboundedInterval
=
{
f32
:
FP
.
f32
.
toParam
(
kUnboundedBounds
)
f16
:
FP
.
f16
.
toParam
(
kUnboundedBounds
)
abstract
:
FP
.
abstract
.
toParam
(
kUnboundedBounds
)
}
;
const
kPlusNULPFunctions
=
{
f32
:
(
x
:
number
n
:
number
)
=
>
{
return
x
+
n
*
oneULPF32
(
x
)
;
}
f16
:
(
x
:
number
n
:
number
)
=
>
{
return
x
+
n
*
oneULPF16
(
x
)
;
}
abstract
:
(
x
:
number
n
:
number
)
=
>
{
return
x
+
n
*
oneULPF64
(
x
)
;
}
}
;
const
kPlusOneULPFunctions
=
{
f32
:
(
x
:
number
)
:
number
=
>
{
return
kPlusNULPFunctions
[
'
f32
'
]
(
x
1
)
;
}
f16
:
(
x
:
number
)
:
number
=
>
{
return
kPlusNULPFunctions
[
'
f16
'
]
(
x
1
)
;
}
abstract
:
(
x
:
number
)
:
number
=
>
{
return
kPlusNULPFunctions
[
'
abstract
'
]
(
x
1
)
;
}
}
;
const
kMinusNULPFunctions
=
{
f32
:
(
x
:
number
n
:
number
)
=
>
{
return
x
-
n
*
oneULPF32
(
x
)
;
}
f16
:
(
x
:
number
n
:
number
)
=
>
{
return
x
-
n
*
oneULPF16
(
x
)
;
}
abstract
:
(
x
:
number
n
:
number
)
=
>
{
return
x
-
n
*
oneULPF64
(
x
)
;
}
}
;
const
kMinusOneULPFunctions
=
{
f32
:
(
x
:
number
)
:
number
=
>
{
return
kMinusNULPFunctions
[
'
f32
'
]
(
x
1
)
;
}
f16
:
(
x
:
number
)
:
number
=
>
{
return
kMinusNULPFunctions
[
'
f16
'
]
(
x
1
)
;
}
abstract
:
(
x
:
number
)
:
number
=
>
{
return
kMinusNULPFunctions
[
'
abstract
'
]
(
x
1
)
;
}
}
;
function
applyError
(
expected
:
number
|
IntervalBounds
error
:
(
n
:
number
)
=
>
number
)
:
IntervalBounds
{
const
unpack
=
(
n
:
number
|
IntervalBounds
)
:
[
number
number
]
=
>
{
if
(
expected
instanceof
Array
)
{
switch
(
expected
.
length
)
{
case
1
:
return
[
expected
[
0
]
expected
[
0
]
]
;
case
2
:
return
[
expected
[
0
]
expected
[
1
]
]
;
}
unreachable
(
Tried
to
unpack
an
IntervalBounds
with
length
other
than
1
or
2
)
;
}
else
{
return
[
n
as
number
n
as
number
]
;
}
}
;
let
[
begin
end
]
=
unpack
(
expected
)
;
begin
-
=
error
(
begin
)
;
end
+
=
error
(
end
)
;
if
(
begin
=
=
=
end
)
{
return
[
begin
]
;
}
return
[
begin
end
]
;
}
interface
ConstructorCase
{
input
:
IntervalBounds
;
expected
:
IntervalBounds
;
}
g
.
test
(
'
constructor
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ConstructorCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
const
cases
:
ConstructorCase
[
]
=
[
{
input
:
[
0
10
]
expected
:
[
0
10
]
}
{
input
:
[
-
5
0
]
expected
:
[
-
5
0
]
}
{
input
:
[
-
5
10
]
expected
:
[
-
5
10
]
}
{
input
:
[
0
]
expected
:
[
0
]
}
{
input
:
[
10
]
expected
:
[
10
]
}
{
input
:
[
-
5
]
expected
:
[
-
5
]
}
{
input
:
[
2
.
5
]
expected
:
[
2
.
5
]
}
{
input
:
[
-
1
.
375
]
expected
:
[
-
1
.
375
]
}
{
input
:
[
-
1
.
375
2
.
5
]
expected
:
[
-
1
.
375
2
.
5
]
}
{
input
:
[
0
constants
.
positive
.
max
]
expected
:
[
0
constants
.
positive
.
max
]
}
{
input
:
[
constants
.
negative
.
min
0
]
expected
:
[
constants
.
negative
.
min
0
]
}
{
input
:
[
constants
.
negative
.
min
constants
.
positive
.
max
]
expected
:
[
constants
.
negative
.
min
constants
.
positive
.
max
]
}
{
input
:
[
0
constants
.
positive
.
infinity
]
expected
:
[
0
Number
.
POSITIVE_INFINITY
]
}
{
input
:
[
constants
.
negative
.
infinity
0
]
expected
:
[
Number
.
NEGATIVE_INFINITY
0
]
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
]
;
if
(
p
.
trait
!
=
=
'
abstract
'
)
{
cases
.
push
(
.
.
.
[
{
input
:
[
0
2
*
constants
.
positive
.
max
]
expected
:
[
0
2
*
constants
.
positive
.
max
]
}
{
input
:
[
2
*
constants
.
negative
.
min
0
]
expected
:
[
2
*
constants
.
negative
.
min
0
]
}
{
input
:
[
2
*
constants
.
negative
.
min
2
*
constants
.
positive
.
max
]
expected
:
[
2
*
constants
.
negative
.
min
2
*
constants
.
positive
.
max
]
}
]
as
ConstructorCase
[
]
)
;
}
return
cases
;
}
)
)
.
fn
(
t
=
>
{
const
i
=
new
FPInterval
(
t
.
params
.
trait
.
.
.
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
i
.
bounds
(
)
t
.
params
.
expected
)
new
FPInterval
(
'
{
t
.
params
.
trait
}
'
[
{
t
.
params
.
input
}
]
)
returned
{
i
}
.
Expected
[
{
t
.
params
.
expected
}
]
)
;
}
)
;
interface
ContainsNumberCase
{
bounds
:
number
|
IntervalBounds
;
value
:
number
;
expected
:
boolean
;
}
g
.
test
(
'
contains_number
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ContainsNumberCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
const
cases
:
ContainsNumberCase
[
]
=
[
{
bounds
:
[
0
10
]
value
:
0
expected
:
true
}
{
bounds
:
[
0
10
]
value
:
10
expected
:
true
}
{
bounds
:
[
0
10
]
value
:
5
expected
:
true
}
{
bounds
:
[
0
10
]
value
:
-
5
expected
:
false
}
{
bounds
:
[
0
10
]
value
:
50
expected
:
false
}
{
bounds
:
[
0
10
]
value
:
Number
.
NaN
expected
:
false
}
{
bounds
:
[
-
5
10
]
value
:
0
expected
:
true
}
{
bounds
:
[
-
5
10
]
value
:
10
expected
:
true
}
{
bounds
:
[
-
5
10
]
value
:
5
expected
:
true
}
{
bounds
:
[
-
5
10
]
value
:
-
5
expected
:
true
}
{
bounds
:
[
-
5
10
]
value
:
-
6
expected
:
false
}
{
bounds
:
[
-
5
10
]
value
:
50
expected
:
false
}
{
bounds
:
[
-
5
10
]
value
:
-
10
expected
:
false
}
{
bounds
:
[
-
1
.
375
2
.
5
]
value
:
-
10
expected
:
false
}
{
bounds
:
[
-
1
.
375
2
.
5
]
value
:
0
.
5
expected
:
true
}
{
bounds
:
[
-
1
.
375
2
.
5
]
value
:
10
expected
:
false
}
{
bounds
:
0
value
:
0
expected
:
true
}
{
bounds
:
0
value
:
10
expected
:
false
}
{
bounds
:
0
value
:
-
1000
expected
:
false
}
{
bounds
:
10
value
:
10
expected
:
true
}
{
bounds
:
10
value
:
0
expected
:
false
}
{
bounds
:
10
value
:
-
10
expected
:
false
}
{
bounds
:
10
value
:
11
expected
:
false
}
{
bounds
:
[
0
constants
.
positive
.
infinity
]
value
:
constants
.
positive
.
min
expected
:
true
}
{
bounds
:
[
0
constants
.
positive
.
infinity
]
value
:
constants
.
positive
.
max
expected
:
true
}
{
bounds
:
[
0
constants
.
positive
.
infinity
]
value
:
constants
.
positive
.
infinity
expected
:
true
}
{
bounds
:
[
0
constants
.
positive
.
infinity
]
value
:
constants
.
negative
.
min
expected
:
false
}
{
bounds
:
[
0
constants
.
positive
.
infinity
]
value
:
constants
.
negative
.
max
expected
:
false
}
{
bounds
:
[
0
constants
.
positive
.
infinity
]
value
:
constants
.
negative
.
infinity
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
infinity
0
]
value
:
constants
.
positive
.
min
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
infinity
0
]
value
:
constants
.
positive
.
max
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
infinity
0
]
value
:
constants
.
positive
.
infinity
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
infinity
0
]
value
:
constants
.
negative
.
min
expected
:
true
}
{
bounds
:
[
constants
.
negative
.
infinity
0
]
value
:
constants
.
negative
.
max
expected
:
true
}
{
bounds
:
[
constants
.
negative
.
infinity
0
]
value
:
constants
.
negative
.
infinity
expected
:
true
}
{
bounds
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
value
:
constants
.
positive
.
min
expected
:
true
}
{
bounds
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
value
:
constants
.
positive
.
max
expected
:
true
}
{
bounds
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
value
:
constants
.
positive
.
infinity
expected
:
true
}
{
bounds
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
value
:
constants
.
negative
.
min
expected
:
true
}
{
bounds
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
value
:
constants
.
negative
.
max
expected
:
true
}
{
bounds
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
value
:
constants
.
negative
.
infinity
expected
:
true
}
{
bounds
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
value
:
Number
.
NaN
expected
:
true
}
{
bounds
:
[
0
constants
.
positive
.
max
]
value
:
constants
.
positive
.
min
expected
:
true
}
{
bounds
:
[
0
constants
.
positive
.
max
]
value
:
constants
.
positive
.
max
expected
:
true
}
{
bounds
:
[
0
constants
.
positive
.
max
]
value
:
constants
.
positive
.
infinity
expected
:
false
}
{
bounds
:
[
0
constants
.
positive
.
max
]
value
:
constants
.
negative
.
min
expected
:
false
}
{
bounds
:
[
0
constants
.
positive
.
max
]
value
:
constants
.
negative
.
max
expected
:
false
}
{
bounds
:
[
0
constants
.
positive
.
max
]
value
:
constants
.
negative
.
infinity
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
min
0
]
value
:
constants
.
positive
.
min
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
min
0
]
value
:
constants
.
positive
.
max
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
min
0
]
value
:
constants
.
positive
.
infinity
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
min
0
]
value
:
constants
.
negative
.
min
expected
:
true
}
{
bounds
:
[
constants
.
negative
.
min
0
]
value
:
constants
.
negative
.
max
expected
:
true
}
{
bounds
:
[
constants
.
negative
.
min
0
]
value
:
constants
.
negative
.
infinity
expected
:
false
}
{
bounds
:
[
0
constants
.
positive
.
min
]
value
:
constants
.
positive
.
subnormal
.
min
expected
:
true
}
{
bounds
:
[
0
constants
.
positive
.
min
]
value
:
constants
.
positive
.
subnormal
.
max
expected
:
true
}
{
bounds
:
[
0
constants
.
positive
.
min
]
value
:
constants
.
negative
.
subnormal
.
min
expected
:
false
}
{
bounds
:
[
0
constants
.
positive
.
min
]
value
:
constants
.
negative
.
subnormal
.
max
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
max
0
]
value
:
constants
.
positive
.
subnormal
.
min
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
max
0
]
value
:
constants
.
positive
.
subnormal
.
max
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
max
0
]
value
:
constants
.
negative
.
subnormal
.
min
expected
:
true
}
{
bounds
:
[
constants
.
negative
.
max
0
]
value
:
constants
.
negative
.
subnormal
.
max
expected
:
true
}
{
bounds
:
[
0
constants
.
positive
.
subnormal
.
min
]
value
:
constants
.
positive
.
subnormal
.
min
expected
:
true
}
{
bounds
:
[
0
constants
.
positive
.
subnormal
.
min
]
value
:
constants
.
positive
.
subnormal
.
max
expected
:
false
}
{
bounds
:
[
0
constants
.
positive
.
subnormal
.
min
]
value
:
constants
.
negative
.
subnormal
.
min
expected
:
false
}
{
bounds
:
[
0
constants
.
positive
.
subnormal
.
min
]
value
:
constants
.
negative
.
subnormal
.
max
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
subnormal
.
max
0
]
value
:
constants
.
positive
.
subnormal
.
min
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
subnormal
.
max
0
]
value
:
constants
.
positive
.
subnormal
.
max
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
subnormal
.
max
0
]
value
:
constants
.
negative
.
subnormal
.
min
expected
:
false
}
{
bounds
:
[
constants
.
negative
.
subnormal
.
max
0
]
value
:
constants
.
negative
.
subnormal
.
max
expected
:
true
}
]
;
if
(
p
.
trait
!
=
=
'
abstract
'
)
{
cases
.
push
(
.
.
.
[
{
bounds
:
[
0
2
*
constants
.
positive
.
max
]
value
:
constants
.
positive
.
min
expected
:
true
}
{
bounds
:
[
0
2
*
constants
.
positive
.
max
]
value
:
constants
.
positive
.
max
expected
:
true
}
{
bounds
:
[
0
2
*
constants
.
positive
.
max
]
value
:
constants
.
positive
.
infinity
expected
:
false
}
{
bounds
:
[
0
2
*
constants
.
positive
.
max
]
value
:
constants
.
negative
.
min
expected
:
false
}
{
bounds
:
[
0
2
*
constants
.
positive
.
max
]
value
:
constants
.
negative
.
max
expected
:
false
}
{
bounds
:
[
0
2
*
constants
.
positive
.
max
]
value
:
constants
.
negative
.
infinity
expected
:
false
}
{
bounds
:
[
2
*
constants
.
negative
.
min
0
]
value
:
constants
.
positive
.
min
expected
:
false
}
{
bounds
:
[
2
*
constants
.
negative
.
min
0
]
value
:
constants
.
positive
.
max
expected
:
false
}
{
bounds
:
[
2
*
constants
.
negative
.
min
0
]
value
:
constants
.
positive
.
infinity
expected
:
false
}
{
bounds
:
[
2
*
constants
.
negative
.
min
0
]
value
:
constants
.
negative
.
min
expected
:
true
}
{
bounds
:
[
2
*
constants
.
negative
.
min
0
]
value
:
constants
.
negative
.
max
expected
:
true
}
{
bounds
:
[
2
*
constants
.
negative
.
min
0
]
value
:
constants
.
negative
.
infinity
expected
:
false
}
]
as
ContainsNumberCase
[
]
)
;
}
return
cases
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
i
=
trait
.
toInterval
(
t
.
params
.
bounds
)
;
const
value
=
t
.
params
.
value
;
const
expected
=
t
.
params
.
expected
;
const
got
=
i
.
contains
(
value
)
;
t
.
expect
(
expected
=
=
=
got
{
i
}
.
contains
(
{
value
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
interface
ContainsIntervalCase
{
lhs
:
number
|
IntervalBounds
;
rhs
:
number
|
IntervalBounds
;
expected
:
boolean
;
}
g
.
test
(
'
contains_interval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ContainsIntervalCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
const
cases
:
ContainsIntervalCase
[
]
=
[
{
lhs
:
[
-
10
10
]
rhs
:
0
expected
:
true
}
{
lhs
:
[
-
10
10
]
rhs
:
[
-
1
0
]
expected
:
true
}
{
lhs
:
[
-
10
10
]
rhs
:
[
0
2
]
expected
:
true
}
{
lhs
:
[
-
10
10
]
rhs
:
[
-
1
2
]
expected
:
true
}
{
lhs
:
[
-
10
10
]
rhs
:
[
0
10
]
expected
:
true
}
{
lhs
:
[
-
10
10
]
rhs
:
[
-
10
2
]
expected
:
true
}
{
lhs
:
[
-
10
10
]
rhs
:
[
-
10
10
]
expected
:
true
}
{
lhs
:
[
-
10
10
]
rhs
:
[
-
100
10
]
expected
:
false
}
{
lhs
:
[
0
constants
.
positive
.
infinity
]
rhs
:
0
expected
:
true
}
{
lhs
:
[
0
constants
.
positive
.
infinity
]
rhs
:
[
-
1
0
]
expected
:
false
}
{
lhs
:
[
0
constants
.
positive
.
infinity
]
rhs
:
[
0
1
]
expected
:
true
}
{
lhs
:
[
0
constants
.
positive
.
infinity
]
rhs
:
[
0
constants
.
positive
.
max
]
expected
:
true
}
{
lhs
:
[
0
constants
.
positive
.
infinity
]
rhs
:
[
0
constants
.
positive
.
infinity
]
expected
:
true
}
{
lhs
:
[
0
constants
.
positive
.
infinity
]
rhs
:
[
100
constants
.
positive
.
infinity
]
expected
:
true
}
{
lhs
:
[
0
constants
.
positive
.
infinity
]
rhs
:
[
Number
.
NEGATIVE_INFINITY
constants
.
positive
.
infinity
]
expected
:
false
}
{
lhs
:
[
constants
.
negative
.
infinity
0
]
rhs
:
0
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
infinity
0
]
rhs
:
[
-
1
0
]
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
infinity
0
]
rhs
:
[
constants
.
negative
.
min
0
]
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
infinity
0
]
rhs
:
[
0
1
]
expected
:
false
}
{
lhs
:
[
constants
.
negative
.
infinity
0
]
rhs
:
[
constants
.
negative
.
infinity
0
]
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
infinity
0
]
rhs
:
[
constants
.
negative
.
infinity
-
100
]
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
infinity
0
]
rhs
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
false
}
{
lhs
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
rhs
:
0
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
rhs
:
[
-
1
0
]
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
rhs
:
[
0
1
]
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
rhs
:
[
0
constants
.
positive
.
infinity
]
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
rhs
:
[
100
constants
.
positive
.
infinity
]
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
rhs
:
[
constants
.
negative
.
infinity
0
]
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
rhs
:
[
constants
.
negative
.
infinity
-
100
]
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
rhs
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
true
}
{
lhs
:
[
0
constants
.
positive
.
max
]
rhs
:
0
expected
:
true
}
{
lhs
:
[
0
constants
.
positive
.
max
]
rhs
:
[
-
1
0
]
expected
:
false
}
{
lhs
:
[
0
constants
.
positive
.
max
]
rhs
:
[
0
1
]
expected
:
true
}
{
lhs
:
[
0
constants
.
positive
.
max
]
rhs
:
[
0
constants
.
positive
.
max
]
expected
:
true
}
{
lhs
:
[
0
constants
.
positive
.
max
]
rhs
:
[
0
constants
.
positive
.
infinity
]
expected
:
false
}
{
lhs
:
[
0
constants
.
positive
.
max
]
rhs
:
[
100
constants
.
positive
.
infinity
]
expected
:
false
}
{
lhs
:
[
0
constants
.
positive
.
max
]
rhs
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
false
}
{
lhs
:
[
constants
.
negative
.
min
0
]
rhs
:
[
0
0
]
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
min
0
]
rhs
:
[
-
1
0
]
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
min
0
]
rhs
:
[
constants
.
negative
.
min
0
]
expected
:
true
}
{
lhs
:
[
constants
.
negative
.
min
0
]
rhs
:
[
0
1
]
expected
:
false
}
{
lhs
:
[
constants
.
negative
.
min
0
]
rhs
:
[
constants
.
negative
.
infinity
0
]
expected
:
false
}
{
lhs
:
[
constants
.
negative
.
min
0
]
rhs
:
[
constants
.
negative
.
infinity
-
100
]
expected
:
false
}
{
lhs
:
[
constants
.
negative
.
min
0
]
rhs
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
false
}
]
;
if
(
p
.
trait
!
=
=
'
abstract
'
)
{
cases
.
push
(
.
.
.
[
{
lhs
:
[
0
2
*
constants
.
positive
.
max
]
rhs
:
0
expected
:
true
}
{
lhs
:
[
0
2
*
constants
.
positive
.
max
]
rhs
:
[
-
1
0
]
expected
:
false
}
{
lhs
:
[
0
2
*
constants
.
positive
.
max
]
rhs
:
[
0
1
]
expected
:
true
}
{
lhs
:
[
0
2
*
constants
.
positive
.
max
]
rhs
:
[
0
constants
.
positive
.
max
]
expected
:
true
}
{
lhs
:
[
0
2
*
constants
.
positive
.
max
]
rhs
:
[
0
constants
.
positive
.
infinity
]
expected
:
false
}
{
lhs
:
[
0
2
*
constants
.
positive
.
max
]
rhs
:
[
100
constants
.
positive
.
infinity
]
expected
:
false
}
{
lhs
:
[
0
2
*
constants
.
positive
.
max
]
rhs
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
false
}
{
lhs
:
[
2
*
constants
.
negative
.
min
0
]
rhs
:
0
expected
:
true
}
{
lhs
:
[
2
*
constants
.
negative
.
min
0
]
rhs
:
[
-
1
0
]
expected
:
true
}
{
lhs
:
[
2
*
constants
.
negative
.
min
0
]
rhs
:
[
constants
.
negative
.
min
0
]
expected
:
true
}
{
lhs
:
[
2
*
constants
.
negative
.
min
0
]
rhs
:
[
0
1
]
expected
:
false
}
{
lhs
:
[
2
*
constants
.
negative
.
min
0
]
rhs
:
[
constants
.
negative
.
infinity
0
]
expected
:
false
}
{
lhs
:
[
2
*
constants
.
negative
.
min
0
]
rhs
:
[
constants
.
negative
.
infinity
-
100
]
expected
:
false
}
{
lhs
:
[
2
*
constants
.
negative
.
min
0
]
rhs
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
false
}
]
as
ContainsIntervalCase
[
]
)
;
}
return
cases
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
lhs
=
trait
.
toInterval
(
t
.
params
.
lhs
)
;
const
rhs
=
trait
.
toInterval
(
t
.
params
.
rhs
)
;
const
expected
=
t
.
params
.
expected
;
const
got
=
lhs
.
contains
(
rhs
)
;
t
.
expect
(
expected
=
=
=
got
{
lhs
}
.
contains
(
{
rhs
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
interface
SpanIntervalsCase
{
intervals
:
(
number
|
IntervalBounds
)
[
]
;
expected
:
number
|
IntervalBounds
;
}
g
.
test
(
'
spanIntervals
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
SpanIntervalsCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
return
[
{
intervals
:
[
[
0
10
]
]
expected
:
[
0
10
]
}
{
intervals
:
[
[
0
constants
.
positive
.
max
]
]
expected
:
[
0
constants
.
positive
.
max
]
}
{
intervals
:
[
[
0
constants
.
positive
.
nearest_max
]
]
expected
:
[
0
constants
.
positive
.
nearest_max
]
}
{
intervals
:
[
[
0
constants
.
positive
.
infinity
]
]
expected
:
[
0
Number
.
POSITIVE_INFINITY
]
}
{
intervals
:
[
[
constants
.
negative
.
min
0
]
]
expected
:
[
constants
.
negative
.
min
0
]
}
{
intervals
:
[
[
constants
.
negative
.
nearest_min
0
]
]
expected
:
[
constants
.
negative
.
nearest_min
0
]
}
{
intervals
:
[
[
constants
.
negative
.
infinity
0
]
]
expected
:
[
Number
.
NEGATIVE_INFINITY
0
]
}
{
intervals
:
[
[
0
1
]
[
2
5
]
]
expected
:
[
0
5
]
}
{
intervals
:
[
[
2
5
]
[
0
1
]
]
expected
:
[
0
5
]
}
{
intervals
:
[
[
0
2
]
[
1
5
]
]
expected
:
[
0
5
]
}
{
intervals
:
[
[
0
5
]
[
1
2
]
]
expected
:
[
0
5
]
}
{
intervals
:
[
[
constants
.
negative
.
infinity
0
]
[
0
constants
.
positive
.
infinity
]
]
expected
:
kUnboundedBounds
}
{
intervals
:
[
[
0
1
]
[
2
3
]
[
4
5
]
]
expected
:
[
0
5
]
}
{
intervals
:
[
[
0
1
]
[
4
5
]
[
2
3
]
]
expected
:
[
0
5
]
}
{
intervals
:
[
[
0
1
]
[
0
1
]
[
0
1
]
]
expected
:
[
0
1
]
}
{
intervals
:
[
1
]
expected
:
1
}
{
intervals
:
[
1
2
]
expected
:
[
1
2
]
}
{
intervals
:
[
-
10
2
]
expected
:
[
-
10
2
]
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
intervals
=
t
.
params
.
intervals
.
map
(
i
=
>
trait
.
toInterval
(
i
)
)
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
spanIntervals
(
.
.
.
intervals
)
;
t
.
expect
(
objectEquals
(
got
expected
)
{
t
.
params
.
trait
}
.
span
(
{
{
intervals
}
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
interface
isVectorCase
{
input
:
(
number
|
IntervalBounds
|
FPIntervalParam
)
[
]
;
expected
:
boolean
;
}
g
.
test
(
'
isVector
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
isVectorCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
return
[
{
input
:
[
1
2
]
expected
:
false
}
{
input
:
[
1
2
3
]
expected
:
false
}
{
input
:
[
1
2
3
4
]
expected
:
false
}
{
input
:
[
[
1
]
[
2
]
]
expected
:
false
}
{
input
:
[
[
1
]
[
2
]
[
3
]
]
expected
:
false
}
{
input
:
[
[
1
]
[
2
]
[
3
]
[
4
]
]
expected
:
false
}
{
input
:
[
[
1
2
]
[
2
3
]
]
expected
:
false
}
{
input
:
[
[
1
2
]
[
2
3
]
[
3
4
]
]
expected
:
false
}
{
input
:
[
[
1
2
]
[
2
3
]
[
3
4
]
[
4
5
]
]
expected
:
false
}
{
input
:
[
trait
.
toParam
(
[
1
]
)
trait
.
toParam
(
[
2
]
)
]
expected
:
true
}
{
input
:
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
]
expected
:
true
}
{
input
:
[
trait
.
toParam
(
[
1
]
)
trait
.
toParam
(
[
2
]
)
trait
.
toParam
(
[
3
]
)
]
expected
:
true
}
{
input
:
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
]
expected
:
true
}
{
input
:
[
trait
.
toParam
(
[
1
]
)
trait
.
toParam
(
[
2
]
)
trait
.
toParam
(
[
3
]
)
trait
.
toParam
(
[
4
]
)
]
expected
:
true
}
{
input
:
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
trait
.
toParam
(
[
4
5
]
)
]
expected
:
true
}
{
input
:
[
trait
.
toParam
(
[
1
]
)
]
expected
:
false
}
{
input
:
[
trait
.
toParam
(
[
1
]
)
trait
.
toParam
(
[
2
]
)
trait
.
toParam
(
[
3
]
)
trait
.
toParam
(
[
4
]
)
trait
.
toParam
(
[
5
]
)
]
expected
:
false
}
{
input
:
[
1
[
2
]
]
expected
:
false
}
{
input
:
[
1
[
2
]
trait
.
toParam
(
[
3
]
)
]
expected
:
false
}
{
input
:
[
1
trait
.
toParam
(
[
2
]
)
[
3
]
4
]
expected
:
false
}
{
input
:
[
trait
.
toParam
(
1
)
2
]
expected
:
false
}
{
input
:
[
trait
.
toParam
(
1
)
[
2
]
]
expected
:
false
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
input
=
t
.
params
.
input
.
map
(
e
=
>
trait
.
fromParam
(
e
)
)
;
const
expected
=
t
.
params
.
expected
;
const
got
=
trait
.
isVector
(
input
)
;
t
.
expect
(
got
=
=
=
expected
{
t
.
params
.
trait
}
.
isVector
(
[
{
input
}
]
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
interface
toVectorCase
{
input
:
(
number
|
IntervalBounds
|
FPIntervalParam
)
[
]
;
expected
:
(
number
|
IntervalBounds
)
[
]
;
}
g
.
test
(
'
toVector
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
toVectorCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
return
[
{
input
:
[
1
2
]
expected
:
[
1
2
]
}
{
input
:
[
1
2
3
]
expected
:
[
1
2
3
]
}
{
input
:
[
1
2
3
4
]
expected
:
[
1
2
3
4
]
}
{
input
:
[
[
1
]
[
2
]
]
expected
:
[
1
2
]
}
{
input
:
[
[
1
]
[
2
]
[
3
]
]
expected
:
[
1
2
3
]
}
{
input
:
[
[
1
]
[
2
]
[
3
]
[
4
]
]
expected
:
[
1
2
3
4
]
}
{
input
:
[
[
1
2
]
[
2
3
]
]
expected
:
[
[
1
2
]
[
2
3
]
]
}
{
input
:
[
[
1
2
]
[
2
3
]
[
3
4
]
]
expected
:
[
[
1
2
]
[
2
3
]
[
3
4
]
]
}
{
input
:
[
[
1
2
]
[
2
3
]
[
3
4
]
[
4
5
]
]
expected
:
[
[
1
2
]
[
2
3
]
[
3
4
]
[
4
5
]
]
}
{
input
:
[
trait
.
toParam
(
[
1
]
)
trait
.
toParam
(
[
2
]
)
]
expected
:
[
1
2
]
}
{
input
:
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
]
expected
:
[
[
1
2
]
[
2
3
]
]
}
{
input
:
[
trait
.
toParam
(
[
1
]
)
trait
.
toParam
(
[
2
]
)
trait
.
toParam
(
[
3
]
)
]
expected
:
[
1
2
3
]
}
{
input
:
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
]
expected
:
[
[
1
2
]
[
2
3
]
[
3
4
]
]
}
{
input
:
[
trait
.
toParam
(
[
1
]
)
trait
.
toParam
(
[
2
]
)
trait
.
toParam
(
[
3
]
)
trait
.
toParam
(
[
4
]
)
]
expected
:
[
1
2
3
4
]
}
{
input
:
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
trait
.
toParam
(
[
4
5
]
)
]
expected
:
[
[
1
2
]
[
2
3
]
[
3
4
]
[
4
5
]
]
}
{
input
:
[
1
[
2
]
]
expected
:
[
1
2
]
}
{
input
:
[
1
[
2
]
trait
.
toParam
(
[
3
]
)
]
expected
:
[
1
2
3
]
}
{
input
:
[
1
trait
.
toParam
(
[
2
]
)
[
3
]
4
]
expected
:
[
1
2
3
4
]
}
{
input
:
[
1
[
2
]
[
2
3
]
kUnboundedInterval
[
p
.
trait
]
]
expected
:
[
1
2
[
2
3
]
kUnboundedBounds
]
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
input
=
t
.
params
.
input
.
map
(
e
=
>
trait
.
fromParam
(
e
)
)
;
const
expected
=
t
.
params
.
expected
.
map
(
e
=
>
trait
.
toInterval
(
e
)
)
;
const
got
=
trait
.
toVector
(
input
)
;
t
.
expect
(
objectEquals
(
got
expected
)
{
t
.
params
.
trait
}
.
toVector
(
[
{
input
}
]
)
returned
[
{
got
}
]
.
Expected
[
{
expected
}
]
)
;
}
)
;
interface
isMatrixCase
{
input
:
(
number
|
IntervalBounds
|
FPIntervalParam
)
[
]
[
]
;
expected
:
boolean
;
}
g
.
test
(
'
isMatrix
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
isMatrixCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
return
[
{
input
:
[
[
1
2
]
[
3
4
]
]
expected
:
false
}
{
input
:
[
[
1
2
]
[
3
4
]
[
5
6
]
]
expected
:
false
}
{
input
:
[
[
1
2
]
[
3
4
]
[
5
6
]
[
7
8
]
]
expected
:
false
}
{
input
:
[
[
1
2
3
]
[
4
5
6
]
]
expected
:
false
}
{
input
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
]
expected
:
false
}
{
input
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
[
10
11
12
]
]
expected
:
false
}
{
input
:
[
[
1
2
3
4
]
[
5
6
7
8
]
]
expected
:
false
}
{
input
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
]
expected
:
false
}
{
input
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
[
13
14
15
16
]
]
expected
:
false
}
{
input
:
[
[
[
1
]
[
2
]
]
[
[
3
]
[
4
]
]
]
expected
:
false
}
{
input
:
[
[
[
1
]
[
2
]
]
[
[
3
]
[
4
]
]
[
[
5
]
[
6
]
]
]
expected
:
false
}
{
input
:
[
[
[
1
]
[
2
]
]
[
[
3
]
[
4
]
]
[
[
5
]
[
6
]
]
[
[
7
]
[
8
]
]
]
expected
:
false
}
{
input
:
[
[
[
1
]
[
2
]
[
3
]
]
[
[
4
]
[
5
]
[
6
]
]
]
expected
:
false
}
{
input
:
[
[
[
1
]
[
2
]
[
3
]
]
[
[
4
]
[
5
]
[
6
]
]
[
[
7
]
[
8
]
[
9
]
]
]
expected
:
false
}
{
input
:
[
[
[
1
]
[
2
]
[
3
]
]
[
[
4
]
[
5
]
[
6
]
]
[
[
7
]
[
8
]
[
9
]
]
[
[
10
]
[
11
]
[
12
]
]
]
expected
:
false
}
{
input
:
[
[
[
1
]
[
2
]
[
3
]
[
4
]
]
[
[
5
]
[
6
]
[
7
]
[
8
]
]
]
expected
:
false
}
{
input
:
[
[
[
1
]
[
2
]
[
3
]
[
4
]
]
[
[
5
]
[
6
]
[
7
]
[
8
]
]
[
[
9
]
[
10
]
[
11
]
[
12
]
]
]
expected
:
false
}
{
input
:
[
[
[
1
]
[
2
]
[
3
]
[
4
]
]
[
[
5
]
[
6
]
[
7
]
[
8
]
]
[
[
9
]
[
10
]
[
11
]
[
12
]
]
[
[
13
]
[
14
]
[
15
]
[
16
]
]
]
expected
:
false
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
]
[
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
]
[
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
[
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
]
[
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
[
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
]
[
trait
.
toParam
(
7
)
trait
.
toParam
(
8
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
trait
.
toParam
(
3
)
]
[
trait
.
toParam
(
4
)
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
trait
.
toParam
(
3
)
]
[
trait
.
toParam
(
4
)
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
]
[
trait
.
toParam
(
7
)
trait
.
toParam
(
8
)
trait
.
toParam
(
9
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
trait
.
toParam
(
3
)
]
[
trait
.
toParam
(
4
)
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
]
[
trait
.
toParam
(
7
)
trait
.
toParam
(
8
)
trait
.
toParam
(
9
)
]
[
trait
.
toParam
(
10
)
trait
.
toParam
(
11
)
trait
.
toParam
(
12
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
[
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
trait
.
toParam
(
7
)
trait
.
toParam
(
8
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
[
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
trait
.
toParam
(
7
)
trait
.
toParam
(
8
)
]
[
trait
.
toParam
(
9
)
trait
.
toParam
(
10
)
trait
.
toParam
(
11
)
trait
.
toParam
(
12
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
[
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
trait
.
toParam
(
7
)
trait
.
toParam
(
8
)
]
[
trait
.
toParam
(
9
)
trait
.
toParam
(
10
)
trait
.
toParam
(
11
)
trait
.
toParam
(
12
)
]
[
trait
.
toParam
(
13
)
trait
.
toParam
(
14
)
trait
.
toParam
(
15
)
trait
.
toParam
(
16
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
]
[
trait
.
toParam
(
[
3
4
]
)
trait
.
toParam
(
[
4
5
]
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
]
[
trait
.
toParam
(
[
3
4
]
)
trait
.
toParam
(
[
4
5
]
)
]
[
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
]
[
trait
.
toParam
(
[
3
4
]
)
trait
.
toParam
(
[
4
5
]
)
]
[
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
]
[
trait
.
toParam
(
[
7
8
]
)
trait
.
toParam
(
[
8
9
]
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
]
[
trait
.
toParam
(
[
4
5
]
)
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
]
[
trait
.
toParam
(
[
4
5
]
)
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
]
[
trait
.
toParam
(
[
7
8
]
)
trait
.
toParam
(
[
8
9
]
)
trait
.
toParam
(
[
9
10
]
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
]
[
trait
.
toParam
(
[
4
5
]
)
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
]
[
trait
.
toParam
(
[
7
8
]
)
trait
.
toParam
(
[
8
9
]
)
trait
.
toParam
(
[
9
10
]
)
]
[
trait
.
toParam
(
[
10
11
]
)
trait
.
toParam
(
[
11
12
]
)
trait
.
toParam
(
[
12
13
]
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
trait
.
toParam
(
[
4
5
]
)
]
[
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
trait
.
toParam
(
[
7
8
]
)
trait
.
toParam
(
[
8
9
]
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
trait
.
toParam
(
[
4
5
]
)
]
[
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
trait
.
toParam
(
[
7
8
]
)
trait
.
toParam
(
[
8
9
]
)
]
[
trait
.
toParam
(
[
9
10
]
)
trait
.
toParam
(
[
10
11
]
)
trait
.
toParam
(
[
11
12
]
)
trait
.
toParam
(
[
12
13
]
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
trait
.
toParam
(
[
4
5
]
)
]
[
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
trait
.
toParam
(
[
7
8
]
)
trait
.
toParam
(
[
8
9
]
)
]
[
trait
.
toParam
(
[
9
10
]
)
trait
.
toParam
(
[
10
11
]
)
trait
.
toParam
(
[
11
12
]
)
trait
.
toParam
(
[
12
13
]
)
]
[
trait
.
toParam
(
[
13
14
]
)
trait
.
toParam
(
[
14
15
]
)
trait
.
toParam
(
[
15
16
]
)
trait
.
toParam
(
[
16
17
]
)
]
]
expected
:
true
}
{
input
:
[
[
trait
.
toParam
(
1
)
]
]
expected
:
false
}
{
input
:
[
[
trait
.
toParam
(
1
)
]
[
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
]
expected
:
false
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
]
[
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
trait
.
toParam
(
5
)
]
]
expected
:
false
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
]
[
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
[
trait
.
toParam
(
5
)
]
]
expected
:
false
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
]
[
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
[
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
]
[
trait
.
toParam
(
7
)
trait
.
toParam
(
8
)
]
[
trait
.
toParam
(
9
)
trait
.
toParam
(
10
)
]
]
expected
:
false
}
{
input
:
[
[
1
[
2
]
]
[
3
4
]
]
expected
:
false
}
{
input
:
[
[
[
1
]
[
2
]
]
[
[
3
]
4
]
]
expected
:
false
}
{
input
:
[
[
1
2
]
[
trait
.
toParam
(
[
3
]
)
4
]
]
expected
:
false
}
{
input
:
[
[
[
1
]
trait
.
toParam
(
[
2
]
)
]
[
trait
.
toParam
(
[
3
]
)
trait
.
toParam
(
[
4
]
)
]
]
expected
:
false
}
{
input
:
[
[
trait
.
toParam
(
1
)
[
2
]
]
[
3
4
]
]
expected
:
false
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
input
=
t
.
params
.
input
.
map
(
a
=
>
a
.
map
(
e
=
>
trait
.
fromParam
(
e
)
)
)
;
const
expected
=
t
.
params
.
expected
;
const
got
=
trait
.
isMatrix
(
input
)
;
t
.
expect
(
got
=
=
=
expected
{
t
.
params
.
trait
}
.
isMatrix
(
[
{
input
}
]
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
interface
toMatrixCase
{
input
:
(
number
|
IntervalBounds
|
FPIntervalParam
)
[
]
[
]
;
expected
:
(
number
|
IntervalBounds
)
[
]
[
]
;
}
g
.
test
(
'
toMatrix
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
toMatrixCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
return
[
{
input
:
[
[
1
2
]
[
3
4
]
]
expected
:
[
[
1
2
]
[
3
4
]
]
}
{
input
:
[
[
1
2
]
[
3
4
]
[
5
6
]
]
expected
:
[
[
1
2
]
[
3
4
]
[
5
6
]
]
}
{
input
:
[
[
1
2
]
[
3
4
]
[
5
6
]
[
7
8
]
]
expected
:
[
[
1
2
]
[
3
4
]
[
5
6
]
[
7
8
]
]
}
{
input
:
[
[
1
2
3
]
[
4
5
6
]
]
expected
:
[
[
1
2
3
]
[
4
5
6
]
]
}
{
input
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
]
expected
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
]
}
{
input
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
[
10
11
12
]
]
expected
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
[
10
11
12
]
]
}
{
input
:
[
[
1
2
3
4
]
[
5
6
7
8
]
]
expected
:
[
[
1
2
3
4
]
[
5
6
7
8
]
]
}
{
input
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
]
expected
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
]
}
{
input
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
[
13
14
15
16
]
]
expected
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
[
13
14
15
16
]
]
}
{
input
:
[
[
[
1
]
[
2
]
]
[
[
3
]
[
4
]
]
]
expected
:
[
[
1
2
]
[
3
4
]
]
}
{
input
:
[
[
[
1
]
[
2
]
]
[
[
3
]
[
4
]
]
[
[
5
]
[
6
]
]
]
expected
:
[
[
1
2
]
[
3
4
]
[
5
6
]
]
}
{
input
:
[
[
[
1
]
[
2
]
]
[
[
3
]
[
4
]
]
[
[
5
]
[
6
]
]
[
[
7
]
[
8
]
]
]
expected
:
[
[
1
2
]
[
3
4
]
[
5
6
]
[
7
8
]
]
}
{
input
:
[
[
[
1
]
[
2
]
[
3
]
]
[
[
4
]
[
5
]
[
6
]
]
]
expected
:
[
[
1
2
3
]
[
4
5
6
]
]
}
{
input
:
[
[
[
1
]
[
2
]
[
3
]
]
[
[
4
]
[
5
]
[
6
]
]
[
[
7
]
[
8
]
[
9
]
]
]
expected
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
]
}
{
input
:
[
[
[
1
]
[
2
]
[
3
]
]
[
[
4
]
[
5
]
[
6
]
]
[
[
7
]
[
8
]
[
9
]
]
[
[
10
]
[
11
]
[
12
]
]
]
expected
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
[
10
11
12
]
]
}
{
input
:
[
[
[
1
]
[
2
]
[
3
]
[
4
]
]
[
[
5
]
[
6
]
[
7
]
[
8
]
]
]
expected
:
[
[
1
2
3
4
]
[
5
6
7
8
]
]
}
{
input
:
[
[
[
1
]
[
2
]
[
3
]
[
4
]
]
[
[
5
]
[
6
]
[
7
]
[
8
]
]
[
[
9
]
[
10
]
[
11
]
[
12
]
]
]
expected
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
]
}
{
input
:
[
[
[
1
]
[
2
]
[
3
]
[
4
]
]
[
[
5
]
[
6
]
[
7
]
[
8
]
]
[
[
9
]
[
10
]
[
11
]
[
12
]
]
[
[
13
]
[
14
]
[
15
]
[
16
]
]
]
expected
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
[
13
14
15
16
]
]
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
]
[
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
]
expected
:
[
[
1
2
]
[
3
4
]
]
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
]
[
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
[
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
]
]
expected
:
[
[
1
2
]
[
3
4
]
[
5
6
]
]
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
]
[
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
[
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
]
[
trait
.
toParam
(
7
)
trait
.
toParam
(
8
)
]
]
expected
:
[
[
1
2
]
[
3
4
]
[
5
6
]
[
7
8
]
]
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
trait
.
toParam
(
3
)
]
[
trait
.
toParam
(
4
)
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
]
]
expected
:
[
[
1
2
3
]
[
4
5
6
]
]
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
trait
.
toParam
(
3
)
]
[
trait
.
toParam
(
4
)
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
]
[
trait
.
toParam
(
7
)
trait
.
toParam
(
8
)
trait
.
toParam
(
9
)
]
]
expected
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
]
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
trait
.
toParam
(
3
)
]
[
trait
.
toParam
(
4
)
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
]
[
trait
.
toParam
(
7
)
trait
.
toParam
(
8
)
trait
.
toParam
(
9
)
]
[
trait
.
toParam
(
10
)
trait
.
toParam
(
11
)
trait
.
toParam
(
12
)
]
]
expected
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
[
10
11
12
]
]
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
[
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
trait
.
toParam
(
7
)
trait
.
toParam
(
8
)
]
]
expected
:
[
[
1
2
3
4
]
[
5
6
7
8
]
]
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
[
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
trait
.
toParam
(
7
)
trait
.
toParam
(
8
)
]
[
trait
.
toParam
(
9
)
trait
.
toParam
(
10
)
trait
.
toParam
(
11
)
trait
.
toParam
(
12
)
]
]
expected
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
]
}
{
input
:
[
[
trait
.
toParam
(
1
)
trait
.
toParam
(
2
)
trait
.
toParam
(
3
)
trait
.
toParam
(
4
)
]
[
trait
.
toParam
(
5
)
trait
.
toParam
(
6
)
trait
.
toParam
(
7
)
trait
.
toParam
(
8
)
]
[
trait
.
toParam
(
9
)
trait
.
toParam
(
10
)
trait
.
toParam
(
11
)
trait
.
toParam
(
12
)
]
[
trait
.
toParam
(
13
)
trait
.
toParam
(
14
)
trait
.
toParam
(
15
)
trait
.
toParam
(
16
)
]
]
expected
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
[
13
14
15
16
]
]
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
]
[
trait
.
toParam
(
[
3
4
]
)
trait
.
toParam
(
[
4
5
]
)
]
]
expected
:
[
[
[
1
2
]
[
2
3
]
]
[
[
3
4
]
[
4
5
]
]
]
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
]
[
trait
.
toParam
(
[
3
4
]
)
trait
.
toParam
(
[
4
5
]
)
]
[
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
]
]
expected
:
[
[
[
1
2
]
[
2
3
]
]
[
[
3
4
]
[
4
5
]
]
[
[
5
6
]
[
6
7
]
]
]
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
]
[
trait
.
toParam
(
[
3
4
]
)
trait
.
toParam
(
[
4
5
]
)
]
[
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
]
[
trait
.
toParam
(
[
7
8
]
)
trait
.
toParam
(
[
8
9
]
)
]
]
expected
:
[
[
[
1
2
]
[
2
3
]
]
[
[
3
4
]
[
4
5
]
]
[
[
5
6
]
[
6
7
]
]
[
[
7
8
]
[
8
9
]
]
]
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
]
[
trait
.
toParam
(
[
4
5
]
)
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
]
]
expected
:
[
[
[
1
2
]
[
2
3
]
[
3
4
]
]
[
[
4
5
]
[
5
6
]
[
6
7
]
]
]
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
]
[
trait
.
toParam
(
[
4
5
]
)
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
]
[
trait
.
toParam
(
[
7
8
]
)
trait
.
toParam
(
[
8
9
]
)
trait
.
toParam
(
[
9
10
]
)
]
]
expected
:
[
[
[
1
2
]
[
2
3
]
[
3
4
]
]
[
[
4
5
]
[
5
6
]
[
6
7
]
]
[
[
7
8
]
[
8
9
]
[
9
10
]
]
]
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
]
[
trait
.
toParam
(
[
4
5
]
)
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
]
[
trait
.
toParam
(
[
7
8
]
)
trait
.
toParam
(
[
8
9
]
)
trait
.
toParam
(
[
9
10
]
)
]
[
trait
.
toParam
(
[
10
11
]
)
trait
.
toParam
(
[
11
12
]
)
trait
.
toParam
(
[
12
13
]
)
]
]
expected
:
[
[
[
1
2
]
[
2
3
]
[
3
4
]
]
[
[
4
5
]
[
5
6
]
[
6
7
]
]
[
[
7
8
]
[
8
9
]
[
9
10
]
]
[
[
10
11
]
[
11
12
]
[
12
13
]
]
]
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
trait
.
toParam
(
[
4
5
]
)
]
[
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
trait
.
toParam
(
[
7
8
]
)
trait
.
toParam
(
[
8
9
]
)
]
]
expected
:
[
[
[
1
2
]
[
2
3
]
[
3
4
]
[
4
5
]
]
[
[
5
6
]
[
6
7
]
[
7
8
]
[
8
9
]
]
]
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
trait
.
toParam
(
[
4
5
]
)
]
[
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
trait
.
toParam
(
[
7
8
]
)
trait
.
toParam
(
[
8
9
]
)
]
[
trait
.
toParam
(
[
9
10
]
)
trait
.
toParam
(
[
10
11
]
)
trait
.
toParam
(
[
11
12
]
)
trait
.
toParam
(
[
12
13
]
)
]
]
expected
:
[
[
[
1
2
]
[
2
3
]
[
3
4
]
[
4
5
]
]
[
[
5
6
]
[
6
7
]
[
7
8
]
[
8
9
]
]
[
[
9
10
]
[
10
11
]
[
11
12
]
[
12
13
]
]
]
}
{
input
:
[
[
trait
.
toParam
(
[
1
2
]
)
trait
.
toParam
(
[
2
3
]
)
trait
.
toParam
(
[
3
4
]
)
trait
.
toParam
(
[
4
5
]
)
]
[
trait
.
toParam
(
[
5
6
]
)
trait
.
toParam
(
[
6
7
]
)
trait
.
toParam
(
[
7
8
]
)
trait
.
toParam
(
[
8
9
]
)
]
[
trait
.
toParam
(
[
9
10
]
)
trait
.
toParam
(
[
10
11
]
)
trait
.
toParam
(
[
11
12
]
)
trait
.
toParam
(
[
12
13
]
)
]
[
trait
.
toParam
(
[
13
14
]
)
trait
.
toParam
(
[
14
15
]
)
trait
.
toParam
(
[
15
16
]
)
trait
.
toParam
(
[
16
17
]
)
]
]
expected
:
[
[
[
1
2
]
[
2
3
]
[
3
4
]
[
4
5
]
]
[
[
5
6
]
[
6
7
]
[
7
8
]
[
8
9
]
]
[
[
9
10
]
[
10
11
]
[
11
12
]
[
12
13
]
]
[
[
13
14
]
[
14
15
]
[
15
16
]
[
16
17
]
]
]
}
{
input
:
[
[
1
[
2
]
]
[
3
4
]
]
expected
:
[
[
1
2
]
[
3
4
]
]
}
{
input
:
[
[
[
1
]
[
2
]
]
[
[
3
]
4
]
]
expected
:
[
[
1
2
]
[
3
4
]
]
}
{
input
:
[
[
1
2
]
[
trait
.
toParam
(
[
3
]
)
4
]
]
expected
:
[
[
1
2
]
[
3
4
]
]
}
{
input
:
[
[
[
1
]
trait
.
toParam
(
[
2
]
)
]
[
trait
.
toParam
(
[
3
]
)
trait
.
toParam
(
[
4
]
)
]
]
expected
:
[
[
1
2
]
[
3
4
]
]
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
input
=
map2DArray
(
t
.
params
.
input
e
=
>
trait
.
fromParam
(
e
)
)
;
const
expected
=
map2DArray
(
t
.
params
.
expected
e
=
>
trait
.
toInterval
(
e
)
)
;
const
got
=
trait
.
toMatrix
(
input
)
;
t
.
expect
(
objectEquals
(
got
expected
)
{
t
.
params
.
trait
}
.
toMatrix
(
[
{
input
}
]
)
returned
[
{
got
}
]
.
Expected
[
{
expected
}
]
)
;
}
)
;
interface
AbsoluteErrorCase
{
value
:
number
;
error
:
number
;
expected
:
number
|
IntervalBounds
;
}
const
kSmallAbsoluteErrorValue
=
{
f32
:
2
*
*
-
11
f16
:
2
*
*
-
7
}
as
const
;
const
kLargeAbsoluteErrorValue
=
{
f32
:
2
*
*
110
f16
:
2
*
*
10
}
as
const
;
const
kSubnormalAbsoluteErrorValue
=
{
f32
:
2
*
*
-
140
f16
:
2
*
*
-
20
}
as
const
;
g
.
test
(
'
absoluteErrorInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
AbsoluteErrorCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
const
smallErr
=
kSmallAbsoluteErrorValue
[
p
.
trait
]
;
const
largeErr
=
kLargeAbsoluteErrorValue
[
p
.
trait
]
;
const
subnormalErr
=
kSubnormalAbsoluteErrorValue
[
p
.
trait
]
;
return
[
{
value
:
constants
.
positive
.
infinity
error
:
0
expected
:
kUnboundedBounds
}
{
value
:
constants
.
positive
.
infinity
error
:
largeErr
expected
:
kUnboundedBounds
}
{
value
:
constants
.
positive
.
infinity
error
:
1
expected
:
kUnboundedBounds
}
{
value
:
constants
.
negative
.
infinity
error
:
0
expected
:
kUnboundedBounds
}
{
value
:
constants
.
negative
.
infinity
error
:
largeErr
expected
:
kUnboundedBounds
}
{
value
:
constants
.
negative
.
infinity
error
:
1
expected
:
kUnboundedBounds
}
{
value
:
constants
.
positive
.
max
error
:
0
expected
:
constants
.
positive
.
max
}
{
value
:
constants
.
positive
.
max
error
:
largeErr
expected
:
kUnboundedBounds
}
{
value
:
constants
.
positive
.
max
error
:
constants
.
positive
.
max
expected
:
kUnboundedBounds
}
{
value
:
constants
.
negative
.
min
error
:
0
expected
:
constants
.
negative
.
min
}
{
value
:
constants
.
negative
.
min
error
:
largeErr
expected
:
kUnboundedBounds
}
{
value
:
constants
.
negative
.
min
error
:
constants
.
positive
.
max
expected
:
kUnboundedBounds
}
{
value
:
constants
.
positive
.
min
error
:
0
expected
:
constants
.
positive
.
min
}
{
value
:
constants
.
positive
.
min
error
:
smallErr
expected
:
[
constants
.
positive
.
min
-
smallErr
constants
.
positive
.
min
+
smallErr
]
}
{
value
:
constants
.
positive
.
min
error
:
1
expected
:
[
constants
.
positive
.
min
-
1
constants
.
positive
.
min
+
1
]
}
{
value
:
constants
.
negative
.
max
error
:
0
expected
:
constants
.
negative
.
max
}
{
value
:
constants
.
negative
.
max
error
:
smallErr
expected
:
[
constants
.
negative
.
max
-
smallErr
constants
.
negative
.
max
+
smallErr
]
}
{
value
:
constants
.
negative
.
max
error
:
1
expected
:
[
constants
.
negative
.
max
-
1
constants
.
negative
.
max
+
1
]
}
{
value
:
constants
.
positive
.
subnormal
.
max
error
:
0
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
value
:
constants
.
positive
.
subnormal
.
max
error
:
subnormalErr
expected
:
[
-
subnormalErr
constants
.
positive
.
subnormal
.
max
+
subnormalErr
]
}
{
value
:
constants
.
positive
.
subnormal
.
max
error
:
smallErr
expected
:
[
-
smallErr
constants
.
positive
.
subnormal
.
max
+
smallErr
]
}
{
value
:
constants
.
positive
.
subnormal
.
max
error
:
1
expected
:
[
-
1
constants
.
positive
.
subnormal
.
max
+
1
]
}
{
value
:
constants
.
positive
.
subnormal
.
min
error
:
0
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
value
:
constants
.
positive
.
subnormal
.
min
error
:
subnormalErr
expected
:
[
-
subnormalErr
constants
.
positive
.
subnormal
.
min
+
subnormalErr
]
}
{
value
:
constants
.
positive
.
subnormal
.
min
error
:
smallErr
expected
:
[
-
smallErr
constants
.
positive
.
subnormal
.
min
+
smallErr
]
}
{
value
:
constants
.
positive
.
subnormal
.
min
error
:
1
expected
:
[
-
1
constants
.
positive
.
subnormal
.
min
+
1
]
}
{
value
:
constants
.
negative
.
subnormal
.
min
error
:
0
expected
:
[
constants
.
negative
.
subnormal
.
min
0
]
}
{
value
:
constants
.
negative
.
subnormal
.
min
error
:
subnormalErr
expected
:
[
constants
.
negative
.
subnormal
.
min
-
subnormalErr
subnormalErr
]
}
{
value
:
constants
.
negative
.
subnormal
.
min
error
:
smallErr
expected
:
[
constants
.
negative
.
subnormal
.
min
-
smallErr
smallErr
]
}
{
value
:
constants
.
negative
.
subnormal
.
min
error
:
1
expected
:
[
constants
.
negative
.
subnormal
.
min
-
1
1
]
}
{
value
:
constants
.
negative
.
subnormal
.
max
error
:
0
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
value
:
constants
.
negative
.
subnormal
.
max
error
:
subnormalErr
expected
:
[
constants
.
negative
.
subnormal
.
max
-
subnormalErr
subnormalErr
]
}
{
value
:
constants
.
negative
.
subnormal
.
max
error
:
smallErr
expected
:
[
constants
.
negative
.
subnormal
.
max
-
smallErr
smallErr
]
}
{
value
:
constants
.
negative
.
subnormal
.
max
error
:
1
expected
:
[
constants
.
negative
.
subnormal
.
max
-
1
1
]
}
{
value
:
reinterpretU64AsF64
(
0x0000_0000_0000_0001n
)
error
:
0
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
value
:
reinterpretU64AsF64
(
0x0000_0000_0000_0001n
)
error
:
subnormalErr
expected
:
[
-
subnormalErr
constants
.
positive
.
subnormal
.
min
+
subnormalErr
]
}
{
value
:
reinterpretU64AsF64
(
0x0000_0000_0000_0001n
)
error
:
1
expected
:
[
-
1
constants
.
positive
.
subnormal
.
min
+
1
]
}
{
value
:
reinterpretU64AsF64
(
0x0000_0000_0000_0002n
)
error
:
0
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
value
:
reinterpretU64AsF64
(
0x0000_0000_0000_0002n
)
error
:
subnormalErr
expected
:
[
-
subnormalErr
constants
.
positive
.
subnormal
.
min
+
subnormalErr
]
}
{
value
:
reinterpretU64AsF64
(
0x0000_0000_0000_0002n
)
error
:
1
expected
:
[
-
1
constants
.
positive
.
subnormal
.
min
+
1
]
}
{
value
:
reinterpretU64AsF64
(
0x800f_ffff_ffff_ffffn
)
error
:
0
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
value
:
reinterpretU64AsF64
(
0x800f_ffff_ffff_ffffn
)
error
:
subnormalErr
expected
:
[
constants
.
negative
.
subnormal
.
max
-
subnormalErr
subnormalErr
]
}
{
value
:
reinterpretU64AsF64
(
0x800f_ffff_ffff_ffffn
)
error
:
1
expected
:
[
constants
.
negative
.
subnormal
.
max
-
1
1
]
}
{
value
:
reinterpretU64AsF64
(
0x800f_ffff_ffff_fffen
)
error
:
0
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
value
:
reinterpretU64AsF64
(
0x800f_ffff_ffff_fffen
)
error
:
subnormalErr
expected
:
[
constants
.
negative
.
subnormal
.
max
-
subnormalErr
subnormalErr
]
}
{
value
:
reinterpretU64AsF64
(
0x800f_ffff_ffff_fffen
)
error
:
1
expected
:
[
constants
.
negative
.
subnormal
.
max
-
1
1
]
}
{
value
:
0
error
:
0
expected
:
0
}
{
value
:
0
error
:
smallErr
expected
:
[
-
smallErr
smallErr
]
}
{
value
:
0
error
:
1
expected
:
[
-
1
1
]
}
{
value
:
2
error
:
0
expected
:
2
}
{
value
:
2
error
:
smallErr
expected
:
[
2
-
smallErr
2
+
smallErr
]
}
{
value
:
2
error
:
1
expected
:
[
1
3
]
}
{
value
:
-
2
error
:
0
expected
:
-
2
}
{
value
:
-
2
error
:
smallErr
expected
:
[
-
2
-
smallErr
-
2
+
smallErr
]
}
{
value
:
-
2
error
:
1
expected
:
[
-
3
-
1
]
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
absoluteErrorInterval
(
t
.
params
.
value
t
.
params
.
error
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
absoluteErrorInterval
(
{
t
.
params
.
value
}
{
t
.
params
.
error
}
)
returned
{
got
}
(
{
got
.
begin
.
toExponential
(
)
}
{
got
.
end
.
toExponential
(
)
}
)
.
Expected
{
expected
}
)
;
}
)
;
interface
CorrectlyRoundedCase
{
value
:
number
;
expected
:
number
|
IntervalBounds
;
}
const
kCorrectlyRoundedNormalCases
=
{
f32
:
[
{
value
:
0
expected
:
[
0
0
]
}
{
value
:
reinterpretU32AsF32
(
0x03800000
)
expected
:
reinterpretU32AsF32
(
0x03800000
)
}
{
value
:
reinterpretU32AsF32
(
0x03800001
)
expected
:
reinterpretU32AsF32
(
0x03800001
)
}
{
value
:
reinterpretU32AsF32
(
0x83800000
)
expected
:
reinterpretU32AsF32
(
0x83800000
)
}
{
value
:
reinterpretU32AsF32
(
0x83800001
)
expected
:
reinterpretU32AsF32
(
0x83800001
)
}
]
as
CorrectlyRoundedCase
[
]
f16
:
[
{
value
:
0
expected
:
[
0
0
]
}
{
value
:
reinterpretU16AsF16
(
0x0c00
)
expected
:
reinterpretU16AsF16
(
0x0c00
)
}
{
value
:
reinterpretU16AsF16
(
0x0c01
)
expected
:
reinterpretU16AsF16
(
0x0c01
)
}
{
value
:
reinterpretU16AsF16
(
0x8c00
)
expected
:
reinterpretU16AsF16
(
0x8c00
)
}
{
value
:
reinterpretU16AsF16
(
0x8c01
)
expected
:
reinterpretU16AsF16
(
0x8c01
)
}
]
as
CorrectlyRoundedCase
[
]
}
as
const
;
const
kCorrectlyRoundedF64NormalCases
=
[
{
value
:
reinterpretU64AsF64
(
0x3ff0_0000_0000_0001n
)
expected
:
{
f32
:
[
reinterpretU32AsF32
(
0x3f800000
)
reinterpretU32AsF32
(
0x3f800001
)
]
f16
:
[
reinterpretU16AsF16
(
0x3c00
)
reinterpretU16AsF16
(
0x3c01
)
]
}
}
{
value
:
reinterpretU64AsF64
(
0x3ff0_0000_0000_0002n
)
expected
:
{
f32
:
[
reinterpretU32AsF32
(
0x3f800000
)
reinterpretU32AsF32
(
0x3f800001
)
]
f16
:
[
reinterpretU16AsF16
(
0x3c00
)
reinterpretU16AsF16
(
0x3c01
)
]
}
}
{
value
:
reinterpretU64AsF64
(
0x3ff0_0800_0000_0010n
)
expected
:
{
f32
:
[
reinterpretU32AsF32
(
0x3f804000
)
reinterpretU32AsF32
(
0x3f804001
)
]
f16
:
[
reinterpretU16AsF16
(
0x3c02
)
reinterpretU16AsF16
(
0x3c03
)
]
}
}
{
value
:
reinterpretU64AsF64
(
0x3ff0_1000_0000_0020n
)
expected
:
{
f32
:
[
reinterpretU32AsF32
(
0x3f808000
)
reinterpretU32AsF32
(
0x3f808001
)
]
f16
:
[
reinterpretU16AsF16
(
0x3c04
)
reinterpretU16AsF16
(
0x3c05
)
]
}
}
{
value
:
reinterpretU64AsF64
(
0xbff0_0000_0000_0001n
)
expected
:
{
f32
:
[
reinterpretU32AsF32
(
0xbf800001
)
reinterpretU32AsF32
(
0xbf800000
)
]
f16
:
[
reinterpretU16AsF16
(
0xbc01
)
reinterpretU16AsF16
(
0xbc00
)
]
}
}
{
value
:
reinterpretU64AsF64
(
0xbff0_0000_0000_0002n
)
expected
:
{
f32
:
[
reinterpretU32AsF32
(
0xbf800001
)
reinterpretU32AsF32
(
0xbf800000
)
]
f16
:
[
reinterpretU16AsF16
(
0xbc01
)
reinterpretU16AsF16
(
0xbc00
)
]
}
}
{
value
:
reinterpretU64AsF64
(
0xbff0_0800_0000_0010n
)
expected
:
{
f32
:
[
reinterpretU32AsF32
(
0xbf804001
)
reinterpretU32AsF32
(
0xbf804000
)
]
f16
:
[
reinterpretU16AsF16
(
0xbc03
)
reinterpretU16AsF16
(
0xbc02
)
]
}
}
{
value
:
reinterpretU64AsF64
(
0xbff0_1000_0000_0020n
)
expected
:
{
f32
:
[
reinterpretU32AsF32
(
0xbf808001
)
reinterpretU32AsF32
(
0xbf808000
)
]
f16
:
[
reinterpretU16AsF16
(
0xbc05
)
reinterpretU16AsF16
(
0xbc04
)
]
}
}
]
as
const
;
g
.
test
(
'
correctlyRoundedInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
CorrectlyRoundedCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
return
[
{
value
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
{
value
:
constants
.
negative
.
infinity
expected
:
kUnboundedBounds
}
{
value
:
constants
.
positive
.
max
expected
:
constants
.
positive
.
max
}
{
value
:
constants
.
negative
.
min
expected
:
constants
.
negative
.
min
}
{
value
:
constants
.
positive
.
min
expected
:
constants
.
positive
.
min
}
{
value
:
constants
.
negative
.
max
expected
:
constants
.
negative
.
max
}
{
value
:
constants
.
positive
.
subnormal
.
min
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
value
:
constants
.
positive
.
subnormal
.
max
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
value
:
constants
.
negative
.
subnormal
.
min
expected
:
[
constants
.
negative
.
subnormal
.
min
0
]
}
{
value
:
constants
.
negative
.
subnormal
.
max
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
value
:
reinterpretU64AsF64
(
0x0000_0000_0000_0001n
)
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
value
:
reinterpretU64AsF64
(
0x0000_0000_0000_0002n
)
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
value
:
reinterpretU64AsF64
(
0x800f_ffff_ffff_ffffn
)
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
value
:
reinterpretU64AsF64
(
0x800f_ffff_ffff_fffen
)
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
.
.
.
kCorrectlyRoundedNormalCases
[
p
.
trait
]
.
.
.
kCorrectlyRoundedF64NormalCases
.
map
(
t
=
>
{
return
{
value
:
t
.
value
expected
:
t
.
expected
[
p
.
trait
]
}
as
CorrectlyRoundedCase
;
}
)
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
correctlyRoundedInterval
(
t
.
params
.
value
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
correctlyRoundedInterval
(
{
t
.
params
.
value
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
interface
ULPCase
{
value
:
number
;
num_ulp
:
number
;
expected
:
number
|
IntervalBounds
;
}
const
kULPErrorValue
=
{
f32
:
4096
f16
:
5
}
;
g
.
test
(
'
ulpInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ULPCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
const
ULPValue
=
kULPErrorValue
[
p
.
trait
]
;
const
plusOneULP
=
kPlusOneULPFunctions
[
p
.
trait
]
;
const
plusNULP
=
kPlusNULPFunctions
[
p
.
trait
]
;
const
minusOneULP
=
kMinusOneULPFunctions
[
p
.
trait
]
;
const
minusNULP
=
kMinusNULPFunctions
[
p
.
trait
]
;
return
[
{
value
:
constants
.
positive
.
infinity
num_ulp
:
0
expected
:
kUnboundedBounds
}
{
value
:
constants
.
positive
.
infinity
num_ulp
:
1
expected
:
kUnboundedBounds
}
{
value
:
constants
.
positive
.
infinity
num_ulp
:
ULPValue
expected
:
kUnboundedBounds
}
{
value
:
constants
.
negative
.
infinity
num_ulp
:
0
expected
:
kUnboundedBounds
}
{
value
:
constants
.
negative
.
infinity
num_ulp
:
1
expected
:
kUnboundedBounds
}
{
value
:
constants
.
negative
.
infinity
num_ulp
:
ULPValue
expected
:
kUnboundedBounds
}
{
value
:
constants
.
positive
.
max
num_ulp
:
0
expected
:
constants
.
positive
.
max
}
{
value
:
constants
.
positive
.
max
num_ulp
:
1
expected
:
kUnboundedBounds
}
{
value
:
constants
.
positive
.
max
num_ulp
:
ULPValue
expected
:
kUnboundedBounds
}
{
value
:
constants
.
positive
.
min
num_ulp
:
0
expected
:
constants
.
positive
.
min
}
{
value
:
constants
.
positive
.
min
num_ulp
:
1
expected
:
[
0
plusOneULP
(
constants
.
positive
.
min
)
]
}
{
value
:
constants
.
positive
.
min
num_ulp
:
ULPValue
expected
:
[
0
plusNULP
(
constants
.
positive
.
min
ULPValue
)
]
}
{
value
:
constants
.
negative
.
min
num_ulp
:
0
expected
:
constants
.
negative
.
min
}
{
value
:
constants
.
negative
.
min
num_ulp
:
1
expected
:
kUnboundedBounds
}
{
value
:
constants
.
negative
.
min
num_ulp
:
ULPValue
expected
:
kUnboundedBounds
}
{
value
:
constants
.
negative
.
max
num_ulp
:
0
expected
:
constants
.
negative
.
max
}
{
value
:
constants
.
negative
.
max
num_ulp
:
1
expected
:
[
minusOneULP
(
constants
.
negative
.
max
)
0
]
}
{
value
:
constants
.
negative
.
max
num_ulp
:
ULPValue
expected
:
[
minusNULP
(
constants
.
negative
.
max
ULPValue
)
0
]
}
{
value
:
constants
.
positive
.
subnormal
.
max
num_ulp
:
0
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
value
:
constants
.
positive
.
subnormal
.
max
num_ulp
:
1
expected
:
[
minusOneULP
(
0
)
plusOneULP
(
constants
.
positive
.
subnormal
.
max
)
]
}
{
value
:
constants
.
positive
.
subnormal
.
max
num_ulp
:
ULPValue
expected
:
[
minusNULP
(
0
ULPValue
)
plusNULP
(
constants
.
positive
.
subnormal
.
max
ULPValue
)
]
}
{
value
:
constants
.
positive
.
subnormal
.
min
num_ulp
:
0
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
value
:
constants
.
positive
.
subnormal
.
min
num_ulp
:
1
expected
:
[
minusOneULP
(
0
)
plusOneULP
(
constants
.
positive
.
subnormal
.
min
)
]
}
{
value
:
constants
.
positive
.
subnormal
.
min
num_ulp
:
ULPValue
expected
:
[
minusNULP
(
0
ULPValue
)
plusNULP
(
constants
.
positive
.
subnormal
.
min
ULPValue
)
]
}
{
value
:
constants
.
negative
.
subnormal
.
min
num_ulp
:
0
expected
:
[
constants
.
negative
.
subnormal
.
min
0
]
}
{
value
:
constants
.
negative
.
subnormal
.
min
num_ulp
:
1
expected
:
[
minusOneULP
(
constants
.
negative
.
subnormal
.
min
)
plusOneULP
(
0
)
]
}
{
value
:
constants
.
negative
.
subnormal
.
min
num_ulp
:
ULPValue
expected
:
[
minusNULP
(
constants
.
negative
.
subnormal
.
min
ULPValue
)
plusNULP
(
0
ULPValue
)
]
}
{
value
:
constants
.
negative
.
subnormal
.
max
num_ulp
:
0
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
value
:
constants
.
negative
.
subnormal
.
max
num_ulp
:
1
expected
:
[
minusOneULP
(
constants
.
negative
.
subnormal
.
max
)
plusOneULP
(
0
)
]
}
{
value
:
constants
.
negative
.
subnormal
.
max
num_ulp
:
ULPValue
expected
:
[
minusNULP
(
constants
.
negative
.
subnormal
.
max
ULPValue
)
plusNULP
(
0
ULPValue
)
]
}
{
value
:
reinterpretU64AsF64
(
0x0000_0000_0000_0001n
)
num_ulp
:
0
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
value
:
reinterpretU64AsF64
(
0x0000_0000_0000_0001n
)
num_ulp
:
1
expected
:
[
minusOneULP
(
0
)
plusOneULP
(
constants
.
positive
.
subnormal
.
min
)
]
}
{
value
:
reinterpretU64AsF64
(
0x0000_0000_0000_0001n
)
num_ulp
:
ULPValue
expected
:
[
minusNULP
(
0
ULPValue
)
plusNULP
(
constants
.
positive
.
subnormal
.
min
ULPValue
)
]
}
{
value
:
reinterpretU64AsF64
(
0x0000_0000_0000_0002n
)
num_ulp
:
0
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
value
:
reinterpretU64AsF64
(
0x0000_0000_0000_0002n
)
num_ulp
:
1
expected
:
[
minusOneULP
(
0
)
plusOneULP
(
constants
.
positive
.
subnormal
.
min
)
]
}
{
value
:
reinterpretU64AsF64
(
0x0000_0000_0000_0002n
)
num_ulp
:
ULPValue
expected
:
[
minusNULP
(
0
ULPValue
)
plusNULP
(
constants
.
positive
.
subnormal
.
min
ULPValue
)
]
}
{
value
:
reinterpretU64AsF64
(
0x800f_ffff_ffff_ffffn
)
num_ulp
:
0
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
value
:
reinterpretU64AsF64
(
0x800f_ffff_ffff_ffffn
)
num_ulp
:
1
expected
:
[
minusOneULP
(
constants
.
negative
.
subnormal
.
max
)
plusOneULP
(
0
)
]
}
{
value
:
reinterpretU64AsF64
(
0x800f_ffff_ffff_ffffn
)
num_ulp
:
ULPValue
expected
:
[
minusNULP
(
constants
.
negative
.
subnormal
.
max
ULPValue
)
plusNULP
(
0
ULPValue
)
]
}
{
value
:
reinterpretU64AsF64
(
0x800f_ffff_ffff_fffen
)
num_ulp
:
0
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
value
:
reinterpretU64AsF64
(
0x800f_ffff_ffff_fffen
)
num_ulp
:
1
expected
:
[
minusOneULP
(
constants
.
negative
.
subnormal
.
max
)
plusOneULP
(
0
)
]
}
{
value
:
reinterpretU64AsF64
(
0x800f_ffff_ffff_fffen
)
num_ulp
:
ULPValue
expected
:
[
minusNULP
(
constants
.
negative
.
subnormal
.
max
ULPValue
)
plusNULP
(
0
ULPValue
)
]
}
{
value
:
0
num_ulp
:
0
expected
:
0
}
{
value
:
0
num_ulp
:
1
expected
:
[
minusOneULP
(
0
)
plusOneULP
(
0
)
]
}
{
value
:
0
num_ulp
:
ULPValue
expected
:
[
minusNULP
(
0
ULPValue
)
plusNULP
(
0
ULPValue
)
]
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
ulpInterval
(
t
.
params
.
value
t
.
params
.
num_ulp
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
ulpInterval
(
{
t
.
params
.
value
}
{
t
.
params
.
num_ulp
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
interface
ScalarToIntervalCase
{
input
:
number
;
expected
:
number
|
IntervalBounds
;
}
const
kAbsIntervalCases
=
[
{
input
:
0
.
1
expected
:
{
f32
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
f16
:
[
reinterpretU16AsF16
(
0x2e66
)
reinterpretU16AsF16
(
0x2e67
)
]
abstract
:
0
.
1
}
}
{
input
:
-
0
.
1
expected
:
{
f32
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
f16
:
[
reinterpretU16AsF16
(
0x2e66
)
reinterpretU16AsF16
(
0x2e67
)
]
abstract
:
0
.
1
}
}
]
as
const
;
g
.
test
(
'
absInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
return
[
{
input
:
1
expected
:
1
}
{
input
:
-
1
expected
:
1
}
.
.
.
kAbsIntervalCases
.
map
(
t
=
>
{
return
{
input
:
t
.
input
expected
:
t
.
expected
[
p
.
trait
]
}
as
ScalarToIntervalCase
}
)
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
max
expected
:
constants
.
positive
.
max
}
{
input
:
constants
.
positive
.
min
expected
:
constants
.
positive
.
min
}
{
input
:
constants
.
negative
.
min
expected
:
constants
.
positive
.
max
}
{
input
:
constants
.
negative
.
max
expected
:
constants
.
positive
.
min
}
{
input
:
constants
.
positive
.
subnormal
.
max
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
constants
.
positive
.
subnormal
.
min
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
input
:
constants
.
negative
.
subnormal
.
min
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
constants
.
negative
.
subnormal
.
max
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
input
:
0
expected
:
0
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
absInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
absInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kAcosIntervalCases
=
{
f32
:
[
{
input
:
kPlusOneULPFunctions
[
'
f32
'
]
(
-
1
)
expected
:
[
reinterpretU32AsF32
(
0x4048fa32
)
reinterpretU32AsF32
(
0x40491bdb
)
]
}
{
input
:
-
1
/
2
expected
:
[
reinterpretU32AsF32
(
0x4005fa90
)
reinterpretU32AsF32
(
0x40061a93
)
]
}
{
input
:
1
/
2
expected
:
[
reinterpretU32AsF32
(
0x3f85fa8f
)
reinterpretU32AsF32
(
0x3f861a94
)
]
}
{
input
:
kMinusOneULPFunctions
[
'
f32
'
]
(
1
)
expected
:
[
reinterpretU64AsF64
(
0x3f2f_fdff_6000_0000n
)
reinterpretU64AsF64
(
0x3f3b_106f_c933_4fb9n
)
]
}
]
as
ScalarToIntervalCase
[
]
f16
:
[
{
input
:
kPlusOneULPFunctions
[
'
f16
'
]
(
-
1
)
expected
:
[
reinterpretU16AsF16
(
0x4233
)
reinterpretU16AsF16
(
0x4243
)
]
}
{
input
:
-
1
/
2
expected
:
[
reinterpretU16AsF16
(
0x402a
)
reinterpretU16AsF16
(
0x4037
)
]
}
{
input
:
1
/
2
expected
:
[
reinterpretU16AsF16
(
0x3c29
)
reinterpretU16AsF16
(
0x3c38
)
]
}
{
input
:
kMinusOneULPFunctions
[
'
f16
'
]
(
1
)
expected
:
[
reinterpretU16AsF16
(
0x259d
)
reinterpretU64AsF64
(
0x3fa2_047d_d441_3554n
)
]
}
]
as
ScalarToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
acosInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
{
input
:
constants
.
negative
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
-
1
expected
:
kUnboundedBounds
}
{
input
:
0
expected
:
kUnboundedBounds
}
{
input
:
1
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
.
.
.
kAcosIntervalCases
[
p
.
trait
]
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
acosInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
acosInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
acoshAlternativeInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarToIntervalCase
>
(
[
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
-
1
expected
:
kUnboundedBounds
}
{
input
:
0
expected
:
kUnboundedBounds
}
{
input
:
1
expected
:
kUnboundedBounds
}
{
input
:
1
.
1
expected
:
[
reinterpretU64AsF64
(
0x3fdc_6368_8000_0000n
)
reinterpretU64AsF64
(
0x3fdc_636f_2000_0000n
)
]
}
{
input
:
10
expected
:
[
reinterpretU64AsF64
(
0x4007_f21e_4000_0000n
)
reinterpretU64AsF64
(
0x4007_f21f_6000_0000n
)
]
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
infinity
.
positive
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
acoshAlternativeInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
acoshInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
acoshPrimaryInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarToIntervalCase
>
(
[
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
-
1
expected
:
kUnboundedBounds
}
{
input
:
0
expected
:
kUnboundedBounds
}
{
input
:
1
expected
:
kUnboundedBounds
}
{
input
:
1
.
1
expected
:
[
reinterpretU64AsF64
(
0x3fdc_6368_2000_0000n
)
reinterpretU64AsF64
(
0x3fdc_636f_8000_0000n
)
]
}
{
input
:
10
expected
:
[
reinterpretU64AsF64
(
0x4007_f21e_4000_0000n
)
reinterpretU64AsF64
(
0x4007_f21f_6000_0000n
)
]
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
infinity
.
positive
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
acoshPrimaryInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
acoshInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kAsinIntervalInheritedCases
=
{
f32
:
[
{
input
:
-
1
/
2
expected
:
[
reinterpretU32AsF32
(
0xbf061a96
)
reinterpretU32AsF32
(
0xbf05fa8e
)
]
}
{
input
:
1
/
2
expected
:
[
reinterpretU32AsF32
(
0x3f05fa8e
)
reinterpretU32AsF32
(
0x3f061a96
)
]
}
]
as
ScalarToIntervalCase
[
]
f16
:
[
{
input
:
-
1
/
2
expected
:
[
reinterpretU16AsF16
(
0xb83a
)
reinterpretU16AsF16
(
0xb827
)
]
}
{
input
:
1
/
2
expected
:
[
reinterpretU16AsF16
(
0x3827
)
reinterpretU16AsF16
(
0x383a
)
]
}
]
as
ScalarToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
asinInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
const
abs_error
=
p
.
trait
=
=
=
'
f32
'
?
6
.
77e
-
5
:
3
.
91e
-
3
;
return
[
{
input
:
constants
.
negative
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
-
1
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
subnormal
.
min
expected
:
kUnboundedBounds
}
{
input
:
0
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
subnormal
.
max
expected
:
kUnboundedBounds
}
{
input
:
1
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
max
expected
:
trait
.
absoluteErrorInterval
(
Math
.
asin
(
constants
.
negative
.
max
)
abs_error
)
.
bounds
(
)
}
{
input
:
constants
.
positive
.
min
expected
:
trait
.
absoluteErrorInterval
(
Math
.
asin
(
constants
.
positive
.
min
)
abs_error
)
.
bounds
(
)
}
.
.
.
kAsinIntervalInheritedCases
[
p
.
trait
]
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
asinInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
asinInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
asinhInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarToIntervalCase
>
(
[
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
-
1
expected
:
[
reinterpretU64AsF64
(
0xbfec_343a_8000_0000n
)
reinterpretU64AsF64
(
0xbfec_3432_8000_0000n
)
]
}
{
input
:
0
expected
:
[
reinterpretU64AsF64
(
0xbeaa_0000_2000_0000n
)
reinterpretU64AsF64
(
0x3eb1_ffff_d000_0000n
)
]
}
{
input
:
1
expected
:
[
reinterpretU64AsF64
(
0x3fec_3435_4000_0000n
)
reinterpretU64AsF64
(
0x3fec_3437_8000_0000n
)
]
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
infinity
.
positive
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
asinhInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
asinhInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kAtanIntervalCases
=
{
f32
:
[
{
input
:
reinterpretU32AsF32
(
0xbfddb3d7
)
expected
:
[
kValue
.
f32
.
negative
.
pi
.
third
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
third
)
]
}
{
input
:
-
1
expected
:
[
kValue
.
f32
.
negative
.
pi
.
quarter
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
quarter
)
]
}
{
input
:
reinterpretU32AsF32
(
0xbf13cd3a
)
expected
:
[
kValue
.
f32
.
negative
.
pi
.
sixth
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
sixth
)
]
}
{
input
:
reinterpretU32AsF32
(
0x3f13cd3a
)
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
sixth
)
kValue
.
f32
.
positive
.
pi
.
sixth
]
}
{
input
:
1
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
quarter
)
kValue
.
f32
.
positive
.
pi
.
quarter
]
}
{
input
:
reinterpretU32AsF32
(
0x3fddb3d7
)
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
third
)
kValue
.
f32
.
positive
.
pi
.
third
]
}
]
as
ScalarToIntervalCase
[
]
f16
:
[
{
input
:
reinterpretU16AsF16
(
0xbeed
)
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
third
)
kValue
.
f16
.
negative
.
pi
.
third
]
}
{
input
:
-
1
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
quarter
)
kValue
.
f16
.
negative
.
pi
.
quarter
]
}
{
input
:
reinterpretU16AsF16
(
0xb89e
)
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
sixth
)
kValue
.
f16
.
negative
.
pi
.
sixth
]
}
{
input
:
reinterpretU16AsF16
(
0x389e
)
expected
:
[
kValue
.
f16
.
positive
.
pi
.
sixth
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
sixth
)
]
}
{
input
:
1
expected
:
[
kValue
.
f16
.
positive
.
pi
.
quarter
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
quarter
)
]
}
{
input
:
reinterpretU16AsF16
(
0x3eed
)
expected
:
[
kValue
.
f16
.
positive
.
pi
.
third
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
third
)
]
}
]
as
ScalarToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
atanInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
return
[
{
input
:
0
expected
:
0
}
.
.
.
kAtanIntervalCases
[
p
.
trait
]
{
input
:
constants
.
negative
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
ulp_error
=
t
.
params
.
trait
=
=
=
'
f32
'
?
4096
:
5
;
const
error
=
(
n
:
number
)
:
number
=
>
{
return
ulp_error
*
trait
.
oneULP
(
n
)
;
}
;
t
.
params
.
expected
=
applyError
(
t
.
params
.
expected
error
)
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
atanInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
atanInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
atanhInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarToIntervalCase
>
(
[
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
-
1
expected
:
kUnboundedBounds
}
{
input
:
-
0
.
1
expected
:
[
reinterpretU64AsF64
(
0xbfb9_af9a_6000_0000n
)
reinterpretU64AsF64
(
0xbfb9_af8c_c000_0000n
)
]
}
{
input
:
0
expected
:
[
reinterpretU64AsF64
(
0xbe96_0000_2000_0000n
)
reinterpretU64AsF64
(
0x3e98_0000_0000_0000n
)
]
}
{
input
:
0
.
1
expected
:
[
reinterpretU64AsF64
(
0x3fb9_af8b_8000_0000n
)
reinterpretU64AsF64
(
0x3fb9_af9b_0000_0000n
)
]
}
{
input
:
1
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
infinity
.
positive
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
atanhInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
atanhInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kCeilIntervalCases
=
{
f32
:
[
{
input
:
2
*
*
30
expected
:
2
*
*
30
}
{
input
:
-
(
2
*
*
30
)
expected
:
-
(
2
*
*
30
)
}
{
input
:
0x80000000
expected
:
0x80000000
}
]
f16
:
[
{
input
:
2
*
*
14
expected
:
2
*
*
14
}
{
input
:
-
(
2
*
*
14
)
expected
:
-
(
2
*
*
14
)
}
{
input
:
0x8000
expected
:
0x8000
}
]
}
as
const
;
g
.
test
(
'
ceilInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
return
[
{
input
:
0
expected
:
0
}
{
input
:
0
.
1
expected
:
1
}
{
input
:
0
.
9
expected
:
1
}
{
input
:
1
.
0
expected
:
1
}
{
input
:
1
.
1
expected
:
2
}
{
input
:
1
.
9
expected
:
2
}
{
input
:
-
0
.
1
expected
:
0
}
{
input
:
-
0
.
9
expected
:
0
}
{
input
:
-
1
.
0
expected
:
-
1
}
{
input
:
-
1
.
1
expected
:
-
1
}
{
input
:
-
1
.
9
expected
:
-
1
}
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
max
expected
:
constants
.
positive
.
max
}
{
input
:
constants
.
positive
.
min
expected
:
1
}
{
input
:
constants
.
negative
.
min
expected
:
constants
.
negative
.
min
}
{
input
:
constants
.
negative
.
max
expected
:
0
}
.
.
.
kCeilIntervalCases
[
p
.
trait
]
{
input
:
constants
.
positive
.
subnormal
.
max
expected
:
[
0
1
]
}
{
input
:
constants
.
positive
.
subnormal
.
min
expected
:
[
0
1
]
}
{
input
:
constants
.
negative
.
subnormal
.
min
expected
:
0
}
{
input
:
constants
.
negative
.
subnormal
.
max
expected
:
0
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
ceilInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
ceilInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kCosIntervalThirdPiCases
=
{
f32
:
[
{
input
:
kValue
.
f32
.
negative
.
pi
.
third
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
1
/
2
)
1
/
2
]
}
{
input
:
kValue
.
f32
.
positive
.
pi
.
third
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
1
/
2
)
1
/
2
]
}
]
f16
:
[
{
input
:
kValue
.
f16
.
negative
.
pi
.
third
expected
:
FP
[
'
f16
'
]
.
correctlyRoundedInterval
(
0
.
50027931
)
.
bounds
(
)
}
{
input
:
kValue
.
f16
.
positive
.
pi
.
third
expected
:
FP
[
'
f16
'
]
.
correctlyRoundedInterval
(
0
.
50027931
)
.
bounds
(
)
}
]
}
;
g
.
test
(
'
cosInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
{
input
:
constants
.
negative
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
pi
.
whole
expected
:
[
-
1
kPlusOneULPFunctions
[
p
.
trait
]
(
-
1
)
]
}
{
input
:
0
expected
:
[
1
1
]
}
{
input
:
constants
.
positive
.
pi
.
whole
expected
:
[
-
1
kPlusOneULPFunctions
[
p
.
trait
]
(
-
1
)
]
}
{
input
:
constants
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
.
.
.
(
kCosIntervalThirdPiCases
[
p
.
trait
]
as
ScalarToIntervalCase
[
]
)
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
error
=
(
_
:
number
)
:
number
=
>
{
return
t
.
params
.
trait
=
=
=
'
f32
'
?
2
*
*
-
11
:
2
*
*
-
7
;
}
;
t
.
params
.
expected
=
applyError
(
t
.
params
.
expected
error
)
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
cosInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
cosInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
=
=
=
{
t
.
params
.
expected
}
=
=
=
)
;
}
)
;
g
.
test
(
'
coshInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarToIntervalCase
>
(
[
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
-
1
expected
:
[
reinterpretU32AsF32
(
0x3fc583a4
)
reinterpretU32AsF32
(
0x3fc583b1
)
]
}
{
input
:
0
expected
:
[
reinterpretU32AsF32
(
0x3f7ffffd
)
reinterpretU32AsF32
(
0x3f800002
)
]
}
{
input
:
1
expected
:
[
reinterpretU32AsF32
(
0x3fc583a4
)
reinterpretU32AsF32
(
0x3fc583b1
)
]
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
infinity
.
positive
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
coshInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
coshInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kDegreesIntervalCases
=
{
f32
:
[
{
input
:
kValue
.
f32
.
negative
.
pi
.
whole
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
-
180
)
kPlusOneULPFunctions
[
'
f32
'
]
(
-
180
)
]
}
{
input
:
kValue
.
f32
.
negative
.
pi
.
three_quarters
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
-
135
)
kPlusOneULPFunctions
[
'
f32
'
]
(
-
135
)
]
}
{
input
:
kValue
.
f32
.
negative
.
pi
.
half
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
-
90
)
kPlusOneULPFunctions
[
'
f32
'
]
(
-
90
)
]
}
{
input
:
kValue
.
f32
.
negative
.
pi
.
third
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
-
60
)
kPlusOneULPFunctions
[
'
f32
'
]
(
-
60
)
]
}
{
input
:
kValue
.
f32
.
negative
.
pi
.
quarter
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
-
45
)
kPlusOneULPFunctions
[
'
f32
'
]
(
-
45
)
]
}
{
input
:
kValue
.
f32
.
negative
.
pi
.
sixth
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
-
30
)
kPlusOneULPFunctions
[
'
f32
'
]
(
-
30
)
]
}
{
input
:
kValue
.
f32
.
positive
.
pi
.
sixth
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
30
)
kPlusOneULPFunctions
[
'
f32
'
]
(
30
)
]
}
{
input
:
kValue
.
f32
.
positive
.
pi
.
quarter
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
45
)
kPlusOneULPFunctions
[
'
f32
'
]
(
45
)
]
}
{
input
:
kValue
.
f32
.
positive
.
pi
.
third
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
60
)
kPlusOneULPFunctions
[
'
f32
'
]
(
60
)
]
}
{
input
:
kValue
.
f32
.
positive
.
pi
.
half
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
90
)
kPlusOneULPFunctions
[
'
f32
'
]
(
90
)
]
}
{
input
:
kValue
.
f32
.
positive
.
pi
.
three_quarters
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
135
)
kPlusOneULPFunctions
[
'
f32
'
]
(
135
)
]
}
{
input
:
kValue
.
f32
.
positive
.
pi
.
whole
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
180
)
kPlusOneULPFunctions
[
'
f32
'
]
(
180
)
]
}
]
as
ScalarToIntervalCase
[
]
f16
:
[
{
input
:
kValue
.
f16
.
negative
.
pi
.
whole
expected
:
[
-
180
kPlusOneULPFunctions
[
'
f16
'
]
(
-
180
)
]
}
{
input
:
kValue
.
f16
.
negative
.
pi
.
three_quarters
expected
:
[
-
135
kPlusOneULPFunctions
[
'
f16
'
]
(
-
135
)
]
}
{
input
:
kValue
.
f16
.
negative
.
pi
.
half
expected
:
[
-
90
kPlusOneULPFunctions
[
'
f16
'
]
(
-
90
)
]
}
{
input
:
kValue
.
f16
.
negative
.
pi
.
third
expected
:
[
-
60
kPlusNULPFunctions
[
'
f16
'
]
(
-
60
2
)
]
}
{
input
:
kValue
.
f16
.
negative
.
pi
.
quarter
expected
:
[
-
45
kPlusOneULPFunctions
[
'
f16
'
]
(
-
45
)
]
}
{
input
:
kValue
.
f16
.
negative
.
pi
.
sixth
expected
:
[
-
30
kPlusNULPFunctions
[
'
f16
'
]
(
-
30
2
)
]
}
{
input
:
kValue
.
f16
.
positive
.
pi
.
sixth
expected
:
[
kMinusNULPFunctions
[
'
f16
'
]
(
30
2
)
30
]
}
{
input
:
kValue
.
f16
.
positive
.
pi
.
quarter
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
45
)
45
]
}
{
input
:
kValue
.
f16
.
positive
.
pi
.
third
expected
:
[
kMinusNULPFunctions
[
'
f16
'
]
(
60
2
)
60
]
}
{
input
:
kValue
.
f16
.
positive
.
pi
.
half
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
90
)
90
]
}
{
input
:
kValue
.
f16
.
positive
.
pi
.
three_quarters
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
135
)
135
]
}
{
input
:
kValue
.
f16
.
positive
.
pi
.
whole
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
180
)
180
]
}
]
as
ScalarToIntervalCase
[
]
abstract
:
[
{
input
:
kValue
.
f64
.
negative
.
pi
.
whole
expected
:
-
180
}
{
input
:
kValue
.
f64
.
negative
.
pi
.
three_quarters
expected
:
-
135
}
{
input
:
kValue
.
f64
.
negative
.
pi
.
half
expected
:
-
90
}
{
input
:
kValue
.
f64
.
negative
.
pi
.
third
expected
:
kPlusOneULPFunctions
[
'
abstract
'
]
(
-
60
)
}
{
input
:
kValue
.
f64
.
negative
.
pi
.
quarter
expected
:
-
45
}
{
input
:
kValue
.
f64
.
negative
.
pi
.
sixth
expected
:
kPlusOneULPFunctions
[
'
abstract
'
]
(
-
30
)
}
{
input
:
kValue
.
f64
.
positive
.
pi
.
sixth
expected
:
kMinusOneULPFunctions
[
'
abstract
'
]
(
30
)
}
{
input
:
kValue
.
f64
.
positive
.
pi
.
quarter
expected
:
45
}
{
input
:
kValue
.
f64
.
positive
.
pi
.
third
expected
:
kMinusOneULPFunctions
[
'
abstract
'
]
(
60
)
}
{
input
:
kValue
.
f64
.
positive
.
pi
.
half
expected
:
90
}
{
input
:
kValue
.
f64
.
positive
.
pi
.
three_quarters
expected
:
135
}
{
input
:
kValue
.
f64
.
positive
.
pi
.
whole
expected
:
180
}
]
as
ScalarToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
degreesInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
trait
=
p
.
trait
;
const
constants
=
FP
[
trait
]
.
constants
(
)
;
return
[
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
0
expected
:
0
}
{
input
:
constants
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
infinity
expected
:
kUnboundedBounds
}
.
.
.
kDegreesIntervalCases
[
trait
]
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
degreesInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
degreesInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
expInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarToIntervalCase
>
(
[
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
0
expected
:
1
}
{
input
:
1
expected
:
[
kValue
.
f32
.
positive
.
e
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
e
)
]
}
{
input
:
89
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
error
=
(
x
:
number
)
:
number
=
>
{
const
n
=
3
+
2
*
Math
.
abs
(
t
.
params
.
input
)
;
return
n
*
oneULPF32
(
x
)
;
}
;
t
.
params
.
expected
=
applyError
(
t
.
params
.
expected
error
)
;
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
expInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
expInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
exp2Interval_f32
'
)
.
paramsSubcasesOnly
<
ScalarToIntervalCase
>
(
[
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
0
expected
:
1
}
{
input
:
1
expected
:
2
}
{
input
:
128
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
error
=
(
x
:
number
)
:
number
=
>
{
const
n
=
3
+
2
*
Math
.
abs
(
t
.
params
.
input
)
;
return
n
*
oneULPF32
(
x
)
;
}
;
t
.
params
.
expected
=
applyError
(
t
.
params
.
expected
error
)
;
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
exp2Interval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
exp2Interval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kFloorIntervalCases
=
{
f32
:
[
{
input
:
2
*
*
30
expected
:
2
*
*
30
}
{
input
:
-
(
2
*
*
30
)
expected
:
-
(
2
*
*
30
)
}
{
input
:
0x80000000
expected
:
0x80000000
}
]
f16
:
[
{
input
:
2
*
*
14
expected
:
2
*
*
14
}
{
input
:
-
(
2
*
*
14
)
expected
:
-
(
2
*
*
14
)
}
{
input
:
0x8000
expected
:
0x8000
}
]
}
as
const
;
g
.
test
(
'
floorInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
return
[
{
input
:
0
expected
:
0
}
{
input
:
0
.
1
expected
:
0
}
{
input
:
0
.
9
expected
:
0
}
{
input
:
1
.
0
expected
:
1
}
{
input
:
1
.
1
expected
:
1
}
{
input
:
1
.
9
expected
:
1
}
{
input
:
-
0
.
1
expected
:
-
1
}
{
input
:
-
0
.
9
expected
:
-
1
}
{
input
:
-
1
.
0
expected
:
-
1
}
{
input
:
-
1
.
1
expected
:
-
2
}
{
input
:
-
1
.
9
expected
:
-
2
}
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
max
expected
:
constants
.
positive
.
max
}
{
input
:
constants
.
positive
.
min
expected
:
0
}
{
input
:
constants
.
negative
.
min
expected
:
constants
.
negative
.
min
}
{
input
:
constants
.
negative
.
max
expected
:
-
1
}
.
.
.
kFloorIntervalCases
[
p
.
trait
]
{
input
:
constants
.
positive
.
subnormal
.
max
expected
:
0
}
{
input
:
constants
.
positive
.
subnormal
.
min
expected
:
0
}
{
input
:
constants
.
negative
.
subnormal
.
min
expected
:
[
-
1
0
]
}
{
input
:
constants
.
negative
.
subnormal
.
max
expected
:
[
-
1
0
]
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
floorInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
floorInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
fractInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarToIntervalCase
>
(
[
{
input
:
0
expected
:
0
}
{
input
:
0
.
1
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0x3dcccccd
)
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
0
.
9
expected
:
[
reinterpretU32AsF32
(
0x3f666666
)
kPlusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0x3f666666
)
)
]
}
{
input
:
1
.
0
expected
:
0
}
{
input
:
1
.
1
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_0000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_0000_0000n
)
]
}
{
input
:
-
0
.
1
expected
:
[
reinterpretU32AsF32
(
0x3f666666
)
kPlusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0x3f666666
)
)
]
}
{
input
:
-
0
.
9
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9999_0000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_0000_0000n
)
]
}
{
input
:
-
1
.
0
expected
:
0
}
{
input
:
-
1
.
1
expected
:
[
reinterpretU64AsF64
(
0x3fec_cccc_c000_0000n
)
reinterpretU64AsF64
(
0x3fec_cccd_0000_0000n
)
]
}
{
input
:
kValue
.
f32
.
infinity
.
positive
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
0
}
{
input
:
kValue
.
f32
.
positive
.
min
expected
:
[
kValue
.
f32
.
positive
.
min
kValue
.
f32
.
positive
.
min
]
}
{
input
:
kValue
.
f32
.
negative
.
min
expected
:
0
}
{
input
:
kValue
.
f32
.
negative
.
max
expected
:
[
kValue
.
f32
.
positive
.
less_than_one
1
.
0
]
}
{
input
:
0x80000000
expected
:
0
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
fractInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
fractInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kInverseSqrtIntervalCases
=
{
f32
:
[
{
input
:
0
.
04
expected
:
[
reinterpretU32AsF32
(
0x409FFFFF
)
reinterpretU32AsF32
(
0x40A00001
)
]
}
{
input
:
100
expected
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
[
reinterpretU32AsF32
(
0x1f800000
)
reinterpretU32AsF32
(
0x1f800001
)
]
}
]
as
ScalarToIntervalCase
[
]
f16
:
[
{
input
:
0
.
04
expected
:
[
reinterpretU16AsF16
(
0x44FF
)
reinterpretU16AsF16
(
0x4501
)
]
}
{
input
:
100
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
reinterpretU16AsF16
(
0x2e67
)
]
}
{
input
:
kValue
.
f16
.
positive
.
max
expected
:
[
reinterpretU16AsF16
(
0x1c00
)
reinterpretU16AsF16
(
0x1c01
)
]
}
]
as
ScalarToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
inverseSqrtInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
{
input
:
1
expected
:
1
}
{
input
:
0
.
25
expected
:
2
}
{
input
:
64
expected
:
0
.
125
}
.
.
.
kInverseSqrtIntervalCases
[
p
.
trait
]
{
input
:
-
1
expected
:
kUnboundedBounds
}
{
input
:
0
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
error
=
(
n
:
number
)
:
number
=
>
{
return
2
*
trait
.
oneULP
(
n
)
;
}
;
t
.
params
.
expected
=
applyError
(
t
.
params
.
expected
error
)
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
inverseSqrtInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
inverseSqrtInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
lengthIntervalScalar_f32
'
)
.
paramsSubcasesOnly
<
ScalarToIntervalCase
>
(
[
{
input
:
0
expected
:
kUnboundedBounds
}
{
input
:
1
.
0
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
-
1
.
0
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
0
.
1
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_9000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_7000_0000n
)
]
}
{
input
:
-
0
.
1
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_9000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_7000_0000n
)
]
}
{
input
:
10
.
0
expected
:
[
reinterpretU64AsF64
(
0x4023_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x4024_0000_b000_0000n
)
]
}
{
input
:
-
10
.
0
expected
:
[
reinterpretU64AsF64
(
0x4023_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x4024_0000_b000_0000n
)
]
}
{
input
:
kValue
.
f32
.
subnormal
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
subnormal
.
negative
.
max
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
subnormal
.
positive
.
min
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
subnormal
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
infinity
.
positive
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
negative
.
max
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
positive
.
min
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
lengthInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
lengthInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kLogIntervalCases
=
{
f32
:
[
{
input
:
kValue
.
f32
.
positive
.
e
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
1
.
0
)
1
.
0
]
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0x42b17218
)
)
reinterpretU32AsF32
(
0x42b17218
)
]
}
]
as
ScalarToIntervalCase
[
]
f16
:
[
{
input
:
kValue
.
f16
.
positive
.
e
expected
:
[
reinterpretU16AsF16
(
0x3bfe
)
reinterpretU16AsF16
(
0x3bff
)
]
}
{
input
:
kValue
.
f16
.
positive
.
max
expected
:
[
reinterpretU16AsF16
(
0x498b
)
reinterpretU16AsF16
(
0x498c
)
]
}
]
as
ScalarToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
logInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
return
[
{
input
:
-
1
expected
:
kUnboundedBounds
}
{
input
:
0
expected
:
kUnboundedBounds
}
{
input
:
1
expected
:
0
}
.
.
.
kLogIntervalCases
[
p
.
trait
]
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
abs_error
=
t
.
params
.
trait
=
=
=
'
f32
'
?
2
*
*
-
21
:
2
*
*
-
7
;
const
error
=
(
n
:
number
)
:
number
=
>
{
if
(
t
.
params
.
input
>
=
0
.
5
&
&
t
.
params
.
input
<
=
2
.
0
)
{
return
abs_error
;
}
return
3
*
trait
.
oneULP
(
n
)
;
}
;
t
.
params
.
expected
=
applyError
(
t
.
params
.
expected
error
)
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
logInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
logInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kLog2IntervalCases
=
{
f32
:
[
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
128
.
0
)
128
.
0
]
}
]
as
ScalarToIntervalCase
[
]
f16
:
[
{
input
:
kValue
.
f16
.
positive
.
max
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
16
.
0
)
16
.
0
]
}
]
as
ScalarToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
log2Interval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
return
[
{
input
:
-
1
expected
:
kUnboundedBounds
}
{
input
:
0
expected
:
kUnboundedBounds
}
{
input
:
1
expected
:
0
}
{
input
:
2
expected
:
1
}
{
input
:
16
expected
:
4
}
.
.
.
kLog2IntervalCases
[
p
.
trait
]
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
abs_error
=
t
.
params
.
trait
=
=
=
'
f32
'
?
2
*
*
-
21
:
2
*
*
-
7
;
const
error
=
(
n
:
number
)
:
number
=
>
{
if
(
t
.
params
.
input
>
=
0
.
5
&
&
t
.
params
.
input
<
=
2
.
0
)
{
return
abs_error
;
}
return
3
*
trait
.
oneULP
(
n
)
;
}
;
t
.
params
.
expected
=
applyError
(
t
.
params
.
expected
error
)
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
log2Interval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
log2Interval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kNegationIntervalCases
=
{
f32
:
[
{
input
:
kValue
.
f32
.
infinity
.
positive
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
kValue
.
f32
.
negative
.
min
}
{
input
:
kValue
.
f32
.
positive
.
min
expected
:
kValue
.
f32
.
negative
.
max
}
{
input
:
kValue
.
f32
.
negative
.
min
expected
:
kValue
.
f32
.
positive
.
max
}
{
input
:
kValue
.
f32
.
negative
.
max
expected
:
kValue
.
f32
.
positive
.
min
}
{
input
:
0
.
1
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
kPlusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0xbdcccccd
)
)
]
}
{
input
:
1
.
9
expected
:
[
reinterpretU32AsF32
(
0xbff33334
)
kPlusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0xbff33334
)
)
]
}
{
input
:
-
0
.
1
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0x3dcccccd
)
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
-
1
.
9
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0x3ff33334
)
)
reinterpretU32AsF32
(
0x3ff33334
)
]
}
{
input
:
kValue
.
f32
.
subnormal
.
positive
.
max
expected
:
[
kValue
.
f32
.
subnormal
.
negative
.
min
0
]
}
{
input
:
kValue
.
f32
.
subnormal
.
positive
.
min
expected
:
[
kValue
.
f32
.
subnormal
.
negative
.
max
0
]
}
{
input
:
kValue
.
f32
.
subnormal
.
negative
.
min
expected
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
max
]
}
{
input
:
kValue
.
f32
.
subnormal
.
negative
.
max
expected
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
min
]
}
]
as
ScalarToIntervalCase
[
]
f16
:
[
{
input
:
kValue
.
f16
.
infinity
.
positive
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f16
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f16
.
positive
.
max
expected
:
kValue
.
f16
.
negative
.
min
}
{
input
:
kValue
.
f16
.
positive
.
min
expected
:
kValue
.
f16
.
negative
.
max
}
{
input
:
kValue
.
f16
.
negative
.
min
expected
:
kValue
.
f16
.
positive
.
max
}
{
input
:
kValue
.
f16
.
negative
.
max
expected
:
kValue
.
f16
.
positive
.
min
}
{
input
:
0
.
1
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0xae66
)
)
reinterpretU16AsF16
(
0xae66
)
]
}
{
input
:
1
.
9
expected
:
[
reinterpretU16AsF16
(
0xbf9a
)
kPlusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0xbf9a
)
)
]
}
{
input
:
-
0
.
1
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
kPlusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0x2e66
)
)
]
}
{
input
:
-
1
.
9
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0x3f9a
)
)
reinterpretU16AsF16
(
0x3f9a
)
]
}
{
input
:
kValue
.
f16
.
subnormal
.
positive
.
max
expected
:
[
kValue
.
f16
.
subnormal
.
negative
.
min
0
]
}
{
input
:
kValue
.
f16
.
subnormal
.
positive
.
min
expected
:
[
kValue
.
f16
.
subnormal
.
negative
.
max
0
]
}
{
input
:
kValue
.
f16
.
subnormal
.
negative
.
min
expected
:
[
0
kValue
.
f16
.
subnormal
.
positive
.
max
]
}
{
input
:
kValue
.
f16
.
subnormal
.
negative
.
max
expected
:
[
0
kValue
.
f16
.
subnormal
.
positive
.
min
]
}
]
as
ScalarToIntervalCase
[
]
abstract
:
[
{
input
:
kValue
.
f64
.
infinity
.
positive
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f64
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f64
.
positive
.
max
expected
:
kValue
.
f64
.
negative
.
min
}
{
input
:
kValue
.
f64
.
positive
.
min
expected
:
kValue
.
f64
.
negative
.
max
}
{
input
:
kValue
.
f64
.
negative
.
min
expected
:
kValue
.
f64
.
positive
.
max
}
{
input
:
kValue
.
f64
.
negative
.
max
expected
:
kValue
.
f64
.
positive
.
min
}
{
input
:
0
.
1
expected
:
-
0
.
1
}
{
input
:
1
.
9
expected
:
-
1
.
9
}
{
input
:
-
0
.
1
expected
:
0
.
1
}
{
input
:
-
1
.
9
expected
:
1
.
9
}
{
input
:
kValue
.
f64
.
subnormal
.
positive
.
max
expected
:
[
kValue
.
f64
.
subnormal
.
negative
.
min
0
]
}
{
input
:
kValue
.
f64
.
subnormal
.
positive
.
min
expected
:
[
kValue
.
f64
.
subnormal
.
negative
.
max
0
]
}
{
input
:
kValue
.
f64
.
subnormal
.
negative
.
min
expected
:
[
0
kValue
.
f64
.
subnormal
.
positive
.
max
]
}
{
input
:
kValue
.
f64
.
subnormal
.
negative
.
max
expected
:
[
0
kValue
.
f64
.
subnormal
.
positive
.
min
]
}
]
as
ScalarToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
negationInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
return
[
{
input
:
0
expected
:
0
}
{
input
:
1
.
0
expected
:
-
1
.
0
}
{
input
:
-
1
.
0
expected
:
1
}
.
.
.
kNegationIntervalCases
[
p
.
trait
]
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
negationInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
negationInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
quantizeToF16Interval_f32
'
)
.
paramsSubcasesOnly
<
ScalarToIntervalCase
>
(
[
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f16
.
negative
.
min
expected
:
kValue
.
f16
.
negative
.
min
}
{
input
:
-
1
expected
:
-
1
}
{
input
:
-
0
.
1
expected
:
[
reinterpretU32AsF32
(
0xbdcce000
)
reinterpretU32AsF32
(
0xbdccc000
)
]
}
{
input
:
kValue
.
f16
.
negative
.
max
expected
:
kValue
.
f16
.
negative
.
max
}
{
input
:
kValue
.
f16
.
subnormal
.
negative
.
min
expected
:
[
kValue
.
f16
.
subnormal
.
negative
.
min
0
]
}
{
input
:
kValue
.
f16
.
subnormal
.
negative
.
max
expected
:
[
kValue
.
f16
.
subnormal
.
negative
.
max
0
]
}
{
input
:
kValue
.
f32
.
subnormal
.
negative
.
max
expected
:
[
kValue
.
f16
.
subnormal
.
negative
.
max
0
]
}
{
input
:
0
expected
:
0
}
{
input
:
kValue
.
f32
.
subnormal
.
positive
.
min
expected
:
[
0
kValue
.
f16
.
subnormal
.
positive
.
min
]
}
{
input
:
kValue
.
f16
.
subnormal
.
positive
.
min
expected
:
[
0
kValue
.
f16
.
subnormal
.
positive
.
min
]
}
{
input
:
kValue
.
f16
.
subnormal
.
positive
.
max
expected
:
[
0
kValue
.
f16
.
subnormal
.
positive
.
max
]
}
{
input
:
kValue
.
f16
.
positive
.
min
expected
:
kValue
.
f16
.
positive
.
min
}
{
input
:
0
.
1
expected
:
[
reinterpretU32AsF32
(
0x3dccc000
)
reinterpretU32AsF32
(
0x3dcce000
)
]
}
{
input
:
1
expected
:
1
}
{
input
:
kValue
.
f16
.
positive
.
max
expected
:
kValue
.
f16
.
positive
.
max
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
infinity
.
positive
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
quantizeToF16Interval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
quantizeToF16Interval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kRadiansIntervalCases
=
{
f32
:
[
{
input
:
-
180
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
whole
)
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
whole
)
]
}
{
input
:
-
135
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
three_quarters
)
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
three_quarters
)
]
}
{
input
:
-
90
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
half
)
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
half
)
]
}
{
input
:
-
60
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
third
)
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
third
)
]
}
{
input
:
-
45
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
quarter
)
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
quarter
)
]
}
{
input
:
-
30
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
sixth
)
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
sixth
)
]
}
{
input
:
30
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
sixth
)
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
sixth
)
]
}
{
input
:
45
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
quarter
)
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
quarter
)
]
}
{
input
:
60
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
third
)
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
third
)
]
}
{
input
:
90
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
half
)
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
half
)
]
}
{
input
:
135
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
three_quarters
)
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
three_quarters
)
]
}
{
input
:
180
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
whole
)
kPlusOneULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
whole
)
]
}
]
as
ScalarToIntervalCase
[
]
f16
:
[
{
input
:
-
180
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
whole
)
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
whole
)
]
}
{
input
:
-
135
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
three_quarters
)
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
three_quarters
)
]
}
{
input
:
-
90
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
half
)
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
half
)
]
}
{
input
:
-
60
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
third
)
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
third
)
]
}
{
input
:
-
45
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
quarter
)
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
quarter
)
]
}
{
input
:
-
30
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
sixth
)
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
sixth
)
]
}
{
input
:
30
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
sixth
)
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
sixth
)
]
}
{
input
:
45
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
quarter
)
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
quarter
)
]
}
{
input
:
60
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
third
)
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
third
)
]
}
{
input
:
90
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
half
)
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
half
)
]
}
{
input
:
135
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
three_quarters
)
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
three_quarters
)
]
}
{
input
:
180
expected
:
[
kMinusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
whole
)
kPlusOneULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
whole
)
]
}
]
as
ScalarToIntervalCase
[
]
abstract
:
[
{
input
:
-
180
expected
:
kValue
.
f64
.
negative
.
pi
.
whole
}
{
input
:
-
135
expected
:
kValue
.
f64
.
negative
.
pi
.
three_quarters
}
{
input
:
-
90
expected
:
kValue
.
f64
.
negative
.
pi
.
half
}
{
input
:
-
60
expected
:
kValue
.
f64
.
negative
.
pi
.
third
}
{
input
:
-
45
expected
:
kValue
.
f64
.
negative
.
pi
.
quarter
}
{
input
:
-
30
expected
:
kValue
.
f64
.
negative
.
pi
.
sixth
}
{
input
:
30
expected
:
kValue
.
f64
.
positive
.
pi
.
sixth
}
{
input
:
45
expected
:
kValue
.
f64
.
positive
.
pi
.
quarter
}
{
input
:
60
expected
:
kValue
.
f64
.
positive
.
pi
.
third
}
{
input
:
90
expected
:
kValue
.
f64
.
positive
.
pi
.
half
}
{
input
:
135
expected
:
kValue
.
f64
.
positive
.
pi
.
three_quarters
}
{
input
:
180
expected
:
kValue
.
f64
.
positive
.
pi
.
whole
}
]
as
ScalarToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
radiansInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
trait
=
p
.
trait
;
const
constants
=
FP
[
trait
]
.
constants
(
)
;
return
[
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
0
expected
:
0
}
{
input
:
constants
.
negative
.
infinity
expected
:
kUnboundedBounds
}
.
.
.
kRadiansIntervalCases
[
trait
]
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
radiansInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
radiansInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kRoundIntervalCases
=
{
f32
:
[
{
input
:
2
*
*
30
expected
:
2
*
*
30
}
{
input
:
-
(
2
*
*
30
)
expected
:
-
(
2
*
*
30
)
}
{
input
:
0x80000000
expected
:
0x80000000
}
]
f16
:
[
{
input
:
2
*
*
14
expected
:
2
*
*
14
}
{
input
:
-
(
2
*
*
14
)
expected
:
-
(
2
*
*
14
)
}
{
input
:
0x8000
expected
:
0x8000
}
]
}
as
const
;
g
.
test
(
'
roundInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
return
[
{
input
:
0
expected
:
0
}
{
input
:
0
.
1
expected
:
0
}
{
input
:
0
.
5
expected
:
0
}
{
input
:
0
.
9
expected
:
1
}
{
input
:
1
.
0
expected
:
1
}
{
input
:
1
.
1
expected
:
1
}
{
input
:
1
.
5
expected
:
2
}
{
input
:
1
.
9
expected
:
2
}
{
input
:
-
0
.
1
expected
:
0
}
{
input
:
-
0
.
5
expected
:
0
}
{
input
:
-
0
.
9
expected
:
-
1
}
{
input
:
-
1
.
0
expected
:
-
1
}
{
input
:
-
1
.
1
expected
:
-
1
}
{
input
:
-
1
.
5
expected
:
-
2
}
{
input
:
-
1
.
9
expected
:
-
2
}
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
max
expected
:
constants
.
positive
.
max
}
{
input
:
constants
.
positive
.
min
expected
:
0
}
{
input
:
constants
.
negative
.
min
expected
:
constants
.
negative
.
min
}
{
input
:
constants
.
negative
.
max
expected
:
0
}
.
.
.
kRoundIntervalCases
[
p
.
trait
]
{
input
:
constants
.
positive
.
subnormal
.
max
expected
:
0
}
{
input
:
constants
.
positive
.
subnormal
.
min
expected
:
0
}
{
input
:
constants
.
negative
.
subnormal
.
min
expected
:
0
}
{
input
:
constants
.
negative
.
subnormal
.
max
expected
:
0
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
roundInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
roundInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
saturateInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarToIntervalCase
>
(
[
{
input
:
0
expected
:
0
}
{
input
:
1
expected
:
1
.
0
}
{
input
:
-
0
.
1
expected
:
0
}
{
input
:
-
1
expected
:
0
}
{
input
:
-
10
expected
:
0
}
{
input
:
0
.
1
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0x3dcccccd
)
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
10
expected
:
1
.
0
}
{
input
:
11
.
1
expected
:
1
.
0
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
1
.
0
}
{
input
:
kValue
.
f32
.
positive
.
min
expected
:
kValue
.
f32
.
positive
.
min
}
{
input
:
kValue
.
f32
.
negative
.
max
expected
:
0
.
0
}
{
input
:
kValue
.
f32
.
negative
.
min
expected
:
0
.
0
}
{
input
:
kValue
.
f32
.
subnormal
.
positive
.
max
expected
:
[
0
.
0
kValue
.
f32
.
subnormal
.
positive
.
max
]
}
{
input
:
kValue
.
f32
.
subnormal
.
positive
.
min
expected
:
[
0
.
0
kValue
.
f32
.
subnormal
.
positive
.
min
]
}
{
input
:
kValue
.
f32
.
subnormal
.
negative
.
min
expected
:
[
kValue
.
f32
.
subnormal
.
negative
.
min
0
.
0
]
}
{
input
:
kValue
.
f32
.
subnormal
.
negative
.
max
expected
:
[
kValue
.
f32
.
subnormal
.
negative
.
max
0
.
0
]
}
{
input
:
kValue
.
f32
.
infinity
.
positive
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
saturateInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
saturationInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
signInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
return
[
{
input
:
constants
.
negative
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
min
expected
:
-
1
}
{
input
:
-
10
expected
:
-
1
}
{
input
:
-
1
expected
:
-
1
}
{
input
:
-
0
.
1
expected
:
-
1
}
{
input
:
constants
.
negative
.
max
expected
:
-
1
}
{
input
:
constants
.
negative
.
subnormal
.
min
expected
:
[
-
1
0
]
}
{
input
:
constants
.
negative
.
subnormal
.
max
expected
:
[
-
1
0
]
}
{
input
:
0
expected
:
0
}
{
input
:
constants
.
positive
.
subnormal
.
max
expected
:
[
0
1
]
}
{
input
:
constants
.
positive
.
subnormal
.
min
expected
:
[
0
1
]
}
{
input
:
constants
.
positive
.
min
expected
:
1
}
{
input
:
0
.
1
expected
:
1
}
{
input
:
1
expected
:
1
}
{
input
:
10
expected
:
1
}
{
input
:
constants
.
positive
.
max
expected
:
1
}
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
signInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
signInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
sinInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
return
[
{
input
:
constants
.
negative
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
pi
.
half
expected
:
[
-
1
kPlusOneULPFunctions
[
p
.
trait
]
(
-
1
)
]
}
{
input
:
0
expected
:
0
}
{
input
:
constants
.
positive
.
pi
.
half
expected
:
[
kMinusOneULPFunctions
[
p
.
trait
]
(
1
)
1
]
}
{
input
:
constants
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
error
=
(
_
:
number
)
:
number
=
>
{
return
t
.
params
.
trait
=
=
=
'
f32
'
?
2
*
*
-
11
:
2
*
*
-
7
;
}
;
t
.
params
.
expected
=
applyError
(
t
.
params
.
expected
error
)
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
sinInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
sinInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
sinhInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarToIntervalCase
>
(
[
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
-
1
expected
:
[
reinterpretU32AsF32
(
0xbf966d05
)
reinterpretU32AsF32
(
0xbf966cf8
)
]
}
{
input
:
0
expected
:
[
reinterpretU32AsF32
(
0xb4600000
)
reinterpretU32AsF32
(
0x34600000
)
]
}
{
input
:
1
expected
:
[
reinterpretU32AsF32
(
0x3f966cf8
)
reinterpretU32AsF32
(
0x3f966d05
)
]
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
infinity
.
positive
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
sinhInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
sinhInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kSqrtIntervalCases
=
{
f32
:
[
{
input
:
0
.
01
expected
:
[
reinterpretU32AsF32
(
0x3DCCCCC8
)
reinterpretU32AsF32
(
0x3DCCCCD1
)
]
}
{
input
:
1
expected
:
[
reinterpretU32AsF32
(
0x3F7FFFFE
)
reinterpretU32AsF32
(
0x3F800002
)
]
}
{
input
:
4
expected
:
[
reinterpretU32AsF32
(
0x3FFFFFFE
)
reinterpretU32AsF32
(
0x40000002
)
]
}
{
input
:
100
expected
:
[
reinterpretU32AsF32
(
0x411FFFFE
)
reinterpretU32AsF32
(
0x41200003
)
]
}
]
as
ScalarToIntervalCase
[
]
f16
:
[
{
input
:
0
.
01
expected
:
[
reinterpretU16AsF16
(
0x2E62
)
reinterpretU16AsF16
(
0x2E6B
)
]
}
{
input
:
1
expected
:
[
reinterpretU16AsF16
(
0x3BFE
)
reinterpretU16AsF16
(
0x3C02
)
]
}
{
input
:
4
expected
:
[
reinterpretU16AsF16
(
0x3FFE
)
reinterpretU16AsF16
(
0x4002
)
]
}
{
input
:
100
expected
:
[
reinterpretU16AsF16
(
0x48FD
)
reinterpretU16AsF16
(
0x4902
)
]
}
]
as
ScalarToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
sqrtInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
.
.
.
kSqrtIntervalCases
[
p
.
trait
]
{
input
:
-
1
expected
:
kUnboundedBounds
}
{
input
:
0
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
error
=
(
n
:
number
)
:
number
=
>
{
return
2
.
5
*
trait
.
oneULP
(
n
)
;
}
;
t
.
params
.
expected
=
applyError
(
t
.
params
.
expected
error
)
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
sqrtInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
FP
.
{
t
.
params
.
trait
}
.
sqrtInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
tanInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarToIntervalCase
>
(
[
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
negative
.
pi
.
whole
expected
:
[
reinterpretU64AsF64
(
0xbf40_02bc_9000_0000n
)
reinterpretU64AsF64
(
0x3f40_0144_f000_0000n
)
]
}
{
input
:
kValue
.
f32
.
negative
.
pi
.
half
expected
:
kUnboundedBounds
}
{
input
:
0
expected
:
[
reinterpretU64AsF64
(
0xbf40_0200_b000_0000n
)
reinterpretU64AsF64
(
0x3f40_0200_b000_0000n
)
]
}
{
input
:
kValue
.
f32
.
positive
.
pi
.
half
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
positive
.
pi
.
whole
expected
:
[
reinterpretU64AsF64
(
0xbf40_0144_f000_0000n
)
reinterpretU64AsF64
(
0x3f40_02bc_9000_0000n
)
]
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
infinity
.
positive
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
tanInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
tanInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
tanhInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarToIntervalCase
>
(
[
{
input
:
kValue
.
f32
.
infinity
.
negative
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
negative
.
min
expected
:
kUnboundedBounds
}
{
input
:
-
1
expected
:
[
reinterpretU64AsF64
(
0xbfe8_5efd_1000_0000n
)
reinterpretU64AsF64
(
0xbfe8_5ef8_9000_0000n
)
]
}
{
input
:
0
expected
:
[
reinterpretU64AsF64
(
0xbe8c_0000_b000_0000n
)
reinterpretU64AsF64
(
0x3e8c_0000_b000_0000n
)
]
}
{
input
:
1
expected
:
[
reinterpretU64AsF64
(
0x3fe8_5ef8_9000_0000n
)
reinterpretU64AsF64
(
0x3fe8_5efd_1000_0000n
)
]
}
{
input
:
kValue
.
f32
.
positive
.
max
expected
:
kUnboundedBounds
}
{
input
:
kValue
.
f32
.
infinity
.
positive
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
tanhInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
tanhInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
truncInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
{
input
:
0
expected
:
0
}
{
input
:
0
.
1
expected
:
0
}
{
input
:
0
.
9
expected
:
0
}
{
input
:
1
.
0
expected
:
1
}
{
input
:
1
.
1
expected
:
1
}
{
input
:
1
.
9
expected
:
1
}
{
input
:
-
0
.
1
expected
:
0
}
{
input
:
-
0
.
9
expected
:
0
}
{
input
:
-
1
.
0
expected
:
-
1
}
{
input
:
-
1
.
1
expected
:
-
1
}
{
input
:
-
1
.
9
expected
:
-
1
}
{
input
:
constants
.
positive
.
subnormal
.
max
expected
:
0
}
{
input
:
constants
.
positive
.
subnormal
.
min
expected
:
0
}
{
input
:
constants
.
negative
.
subnormal
.
min
expected
:
0
}
{
input
:
constants
.
negative
.
subnormal
.
max
expected
:
0
}
{
input
:
constants
.
positive
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
negative
.
infinity
expected
:
kUnboundedBounds
}
{
input
:
constants
.
positive
.
max
expected
:
constants
.
positive
.
max
}
{
input
:
constants
.
positive
.
min
expected
:
0
}
{
input
:
constants
.
negative
.
min
expected
:
constants
.
negative
.
min
}
{
input
:
constants
.
negative
.
max
expected
:
0
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
truncInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
FP
.
{
t
.
params
.
trait
}
.
truncInterval
(
{
t
.
params
.
input
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
interface
ScalarPairToIntervalCase
{
input
:
[
number
number
]
;
expected
:
number
|
IntervalBounds
;
}
const
kAdditionInterval64BitsNormalCases
=
{
f32
:
[
{
input
:
[
0
.
1
0
]
expected
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
0
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
-
0
.
1
0
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
reinterpretU32AsF32
(
0xbdcccccc
)
]
}
{
input
:
[
0
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
reinterpretU32AsF32
(
0xbdcccccc
)
]
}
{
input
:
[
0
.
1
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0x3e4ccccc
)
reinterpretU32AsF32
(
0x3e4ccccd
)
]
}
{
input
:
[
-
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbe4ccccd
)
reinterpretU32AsF32
(
0xbe4ccccc
)
]
}
{
input
:
[
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
+
reinterpretU32AsF32
(
0xbdcccccd
)
reinterpretU32AsF32
(
0x3dcccccd
)
+
reinterpretU32AsF32
(
0xbdcccccc
)
]
}
{
input
:
[
-
0
.
1
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
+
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0xbdcccccc
)
+
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
]
as
ScalarPairToIntervalCase
[
]
f16
:
[
{
input
:
[
0
.
1
0
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
reinterpretU16AsF16
(
0x2e67
)
]
}
{
input
:
[
0
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
reinterpretU16AsF16
(
0x2e67
)
]
}
{
input
:
[
-
0
.
1
0
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
reinterpretU16AsF16
(
0xae66
)
]
}
{
input
:
[
0
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
reinterpretU16AsF16
(
0xae66
)
]
}
{
input
:
[
0
.
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x3266
)
reinterpretU16AsF16
(
0x3267
)
]
}
{
input
:
[
-
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xb267
)
reinterpretU16AsF16
(
0xb266
)
]
}
{
input
:
[
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
+
reinterpretU16AsF16
(
0xae67
)
reinterpretU16AsF16
(
0x2e67
)
+
reinterpretU16AsF16
(
0xae66
)
]
}
{
input
:
[
-
0
.
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
+
reinterpretU16AsF16
(
0x2e66
)
reinterpretU16AsF16
(
0xae66
)
+
reinterpretU16AsF16
(
0x2e67
)
]
}
]
as
ScalarPairToIntervalCase
[
]
abstract
:
[
{
input
:
[
0
.
1
0
]
expected
:
0
.
1
}
{
input
:
[
0
0
.
1
]
expected
:
0
.
1
}
{
input
:
[
-
0
.
1
0
]
expected
:
-
0
.
1
}
{
input
:
[
0
-
0
.
1
]
expected
:
-
0
.
1
}
{
input
:
[
0
.
1
0
.
1
]
expected
:
reinterpretU64AsF64
(
0x3FC999999999999An
)
}
{
input
:
[
-
0
.
1
-
0
.
1
]
expected
:
reinterpretU64AsF64
(
0xBFC999999999999An
)
}
{
input
:
[
0
.
1
-
0
.
1
]
expected
:
0
}
{
input
:
[
-
0
.
1
0
.
1
]
expected
:
0
}
]
as
ScalarPairToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
additionInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarPairToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
{
input
:
[
0
0
]
expected
:
0
}
{
input
:
[
1
0
]
expected
:
1
}
{
input
:
[
0
1
]
expected
:
1
}
{
input
:
[
-
1
0
]
expected
:
-
1
}
{
input
:
[
0
-
1
]
expected
:
-
1
}
{
input
:
[
1
1
]
expected
:
2
}
{
input
:
[
1
-
1
]
expected
:
0
}
{
input
:
[
-
1
1
]
expected
:
0
}
{
input
:
[
-
1
-
1
]
expected
:
-
2
}
.
.
.
kAdditionInterval64BitsNormalCases
[
p
.
trait
]
{
input
:
[
constants
.
positive
.
subnormal
.
max
0
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
max
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
constants
.
positive
.
subnormal
.
min
0
]
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
min
]
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
input
:
[
constants
.
negative
.
subnormal
.
max
0
]
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
input
:
[
0
constants
.
negative
.
subnormal
.
max
]
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
input
:
[
constants
.
negative
.
subnormal
.
min
0
]
expected
:
[
constants
.
negative
.
subnormal
.
min
0
]
}
{
input
:
[
0
constants
.
negative
.
subnormal
.
min
]
expected
:
[
constants
.
negative
.
subnormal
.
min
0
]
}
{
input
:
[
0
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
[
x
y
]
=
t
.
params
.
input
;
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
additionInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
additionInterval
(
{
x
}
{
y
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kAtan2IntervalCases
=
{
f32
:
[
{
input
:
[
1
reinterpretU32AsF32
(
0x3fddb3d7
)
]
expected
:
[
kMinusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
sixth
4097
)
kPlusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
sixth
4096
)
]
}
{
input
:
[
1
1
]
expected
:
[
kMinusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
quarter
4097
)
kPlusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
quarter
4096
)
]
}
{
input
:
[
reinterpretU32AsF32
(
0x3fddb3d7
)
1
]
expected
:
[
kMinusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
third
4097
)
kPlusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
third
4096
)
]
}
{
input
:
[
1
-
1
]
expected
:
[
kMinusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
three_quarters
4097
)
kPlusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
three_quarters
4096
)
]
}
{
input
:
[
-
1
-
1
]
expected
:
[
kMinusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
three_quarters
4096
)
kPlusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
three_quarters
4097
)
]
}
{
input
:
[
-
1
1
]
expected
:
[
kMinusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
quarter
4096
)
kPlusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
quarter
4097
)
]
}
{
input
:
[
kValue
.
f32
.
negative
.
max
-
1
]
expected
:
[
kMinusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
whole
4096
)
kPlusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
negative
.
pi
.
whole
4097
)
]
}
{
input
:
[
kValue
.
f32
.
positive
.
min
-
1
]
expected
:
[
kMinusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
whole
4097
)
kPlusNULPFunctions
[
'
f32
'
]
(
kValue
.
f32
.
positive
.
pi
.
whole
4096
)
]
}
]
as
ScalarPairToIntervalCase
[
]
f16
:
[
{
input
:
[
1
reinterpretU16AsF16
(
0x3eed
)
]
expected
:
[
kMinusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
sixth
5
)
kPlusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
sixth
6
)
]
}
{
input
:
[
1
1
]
expected
:
[
kMinusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
quarter
5
)
kPlusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
quarter
6
)
]
}
{
input
:
[
reinterpretU16AsF16
(
0x3eed
)
1
]
expected
:
[
kMinusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
third
5
)
kPlusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
third
6
)
]
}
{
input
:
[
1
-
1
]
expected
:
[
kMinusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
three_quarters
5
)
kPlusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
three_quarters
6
)
]
}
{
input
:
[
-
1
-
1
]
expected
:
[
kMinusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
three_quarters
6
)
kPlusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
three_quarters
5
)
]
}
{
input
:
[
-
1
1
]
expected
:
[
kMinusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
quarter
6
)
kPlusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
quarter
5
)
]
}
{
input
:
[
kValue
.
f16
.
negative
.
max
-
1
]
expected
:
[
kMinusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
whole
6
)
kPlusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
negative
.
pi
.
whole
5
)
]
}
{
input
:
[
kValue
.
f16
.
positive
.
min
-
1
]
expected
:
[
kMinusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
whole
5
)
kPlusNULPFunctions
[
'
f16
'
]
(
kValue
.
f16
.
positive
.
pi
.
whole
6
)
]
}
]
as
ScalarPairToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
atan2Interval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarPairToIntervalCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
return
[
.
.
.
kAtan2IntervalCases
[
p
.
trait
]
{
input
:
[
Number
.
POSITIVE_INFINITY
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
Number
.
POSITIVE_INFINITY
-
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
Number
.
NEGATIVE_INFINITY
-
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
Number
.
NEGATIVE_INFINITY
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
max
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
negative
.
subnormal
.
min
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
positive
.
min
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
negative
.
max
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
positive
.
max
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
negative
.
min
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
subnormal
.
min
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
constants
.
positive
.
max
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
constants
.
positive
.
nearest_max
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
constants
.
negative
.
min
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
constants
.
negative
.
nearest_min
]
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
[
y
x
]
=
t
.
params
.
input
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
atan2Interval
(
y
x
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
atan2Interval
(
{
y
}
{
x
}
)
returned
{
got
}
]
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
distanceIntervalScalar_f32
'
)
.
paramsSubcasesOnly
<
ScalarPairToIntervalCase
>
(
[
{
input
:
[
0
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
.
0
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
0
.
0
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
1
.
0
1
.
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
-
0
.
0
-
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
0
.
0
-
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
-
1
.
0
-
1
.
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
.
1
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_9000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_7000_0000n
)
]
}
{
input
:
[
0
0
.
1
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_9000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_7000_0000n
)
]
}
{
input
:
[
-
0
.
1
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_9000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_7000_0000n
)
]
}
{
input
:
[
0
-
0
.
1
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_9000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_7000_0000n
)
]
}
{
input
:
[
10
.
0
0
]
expected
:
[
reinterpretU64AsF64
(
0x4023_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x4024_0000_b000_0000n
)
]
}
{
input
:
[
0
10
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x4023_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x4024_0000_b000_0000n
)
]
}
{
input
:
[
-
10
.
0
0
]
expected
:
[
reinterpretU64AsF64
(
0x4023_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x4024_0000_b000_0000n
)
]
}
{
input
:
[
0
-
10
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x4023_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x4024_0000_b000_0000n
)
]
}
{
input
:
[
kValue
.
f32
.
subnormal
.
negative
.
min
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
subnormal
.
negative
.
max
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
subnormal
.
positive
.
min
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
subnormal
.
positive
.
max
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
infinity
.
positive
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
infinity
.
negative
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
negative
.
min
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
negative
.
max
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
positive
.
min
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
positive
.
max
0
]
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
distanceInterval
(
.
.
.
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
distanceInterval
(
{
t
.
params
.
input
[
0
]
}
{
t
.
params
.
input
[
1
]
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kDivisionInterval64BitsNormalCases
=
{
f32
:
[
{
input
:
[
0
0
.
1
]
expected
:
0
}
{
input
:
[
0
-
0
.
1
]
expected
:
0
}
{
input
:
[
1
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0x411fffff
)
reinterpretU32AsF32
(
0x41200001
)
]
}
{
input
:
[
-
1
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0x411fffff
)
reinterpretU32AsF32
(
0x41200001
)
]
}
{
input
:
[
-
1
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xc1200001
)
reinterpretU32AsF32
(
0xc11fffff
)
]
}
{
input
:
[
1
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xc1200001
)
reinterpretU32AsF32
(
0xc11fffff
)
]
}
{
input
:
[
1
0
.
000001
]
expected
:
[
reinterpretU32AsF32
(
0x497423fe
)
reinterpretU32AsF32
(
0x49742401
)
]
}
{
input
:
[
1
-
0
.
000001
]
expected
:
[
reinterpretU32AsF32
(
0xc9742401
)
reinterpretU32AsF32
(
0xc97423fe
)
]
}
]
as
ScalarPairToIntervalCase
[
]
f16
:
[
{
input
:
[
0
0
.
1
]
expected
:
0
}
{
input
:
[
0
-
0
.
1
]
expected
:
0
}
{
input
:
[
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x48ff
)
reinterpretU16AsF16
(
0x4901
)
]
}
{
input
:
[
-
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x48ff
)
reinterpretU16AsF16
(
0x4901
)
]
}
{
input
:
[
-
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xc901
)
reinterpretU16AsF16
(
0xc8ff
)
]
}
{
input
:
[
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xc901
)
reinterpretU16AsF16
(
0xc8ff
)
]
}
{
input
:
[
1
0
.
001
]
expected
:
[
reinterpretU16AsF16
(
0x63cf
)
reinterpretU16AsF16
(
0x63d2
)
]
}
{
input
:
[
1
-
0
.
001
]
expected
:
[
reinterpretU16AsF16
(
0xe3d2
)
reinterpretU16AsF16
(
0xe3cf
)
]
}
]
as
ScalarPairToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
divisionInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarPairToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
{
input
:
[
0
1
]
expected
:
0
}
{
input
:
[
0
-
1
]
expected
:
0
}
{
input
:
[
1
1
]
expected
:
1
}
{
input
:
[
1
-
1
]
expected
:
-
1
}
{
input
:
[
-
1
1
]
expected
:
-
1
}
{
input
:
[
-
1
-
1
]
expected
:
1
}
{
input
:
[
4
2
]
expected
:
2
}
{
input
:
[
-
4
2
]
expected
:
-
2
}
{
input
:
[
4
-
2
]
expected
:
-
2
}
{
input
:
[
-
4
-
2
]
expected
:
2
}
.
.
.
kDivisionInterval64BitsNormalCases
[
p
.
trait
]
{
input
:
[
1
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
constants
.
positive
.
max
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
constants
.
negative
.
min
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
constants
.
positive
.
subnormal
.
max
]
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
error
=
(
n
:
number
)
:
number
=
>
{
return
2
.
5
*
trait
.
oneULP
(
n
)
;
}
;
const
[
x
y
]
=
t
.
params
.
input
;
t
.
params
.
expected
=
applyError
(
t
.
params
.
expected
error
)
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
divisionInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
divisionInterval
(
{
x
}
{
y
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
ldexpInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarPairToIntervalCase
>
(
[
{
input
:
[
0
0
]
expected
:
0
}
{
input
:
[
0
1
]
expected
:
0
}
{
input
:
[
0
-
1
]
expected
:
0
}
{
input
:
[
1
1
]
expected
:
2
}
{
input
:
[
1
-
1
]
expected
:
0
.
5
}
{
input
:
[
-
1
1
]
expected
:
-
2
}
{
input
:
[
-
1
-
1
]
expected
:
-
0
.
5
}
{
input
:
[
0
0
.
1
]
expected
:
0
}
{
input
:
[
0
-
0
.
1
]
expected
:
0
}
{
input
:
[
1
.
0000000001
1
]
expected
:
[
2
kPlusNULPFunctions
[
'
f32
'
]
(
2
2
)
]
}
{
input
:
[
-
1
.
0000000001
1
]
expected
:
[
kMinusNULPFunctions
[
'
f32
'
]
(
-
2
2
)
-
2
]
}
{
input
:
[
1
.
9999998807907104
127
]
expected
:
kValue
.
f32
.
positive
.
max
}
{
input
:
[
1
-
126
]
expected
:
kValue
.
f32
.
positive
.
min
}
{
input
:
[
0
.
9999998807907104
-
126
]
expected
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
max
]
}
{
input
:
[
1
.
1920928955078125e
-
07
-
126
]
expected
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
min
]
}
{
input
:
[
-
1
.
1920928955078125e
-
07
-
126
]
expected
:
[
kValue
.
f32
.
subnormal
.
negative
.
max
0
]
}
{
input
:
[
-
0
.
9999998807907104
-
126
]
expected
:
[
kValue
.
f32
.
subnormal
.
negative
.
min
0
]
}
{
input
:
[
-
1
-
126
]
expected
:
kValue
.
f32
.
negative
.
max
}
{
input
:
[
-
1
.
9999998807907104
127
]
expected
:
kValue
.
f32
.
negative
.
min
}
{
input
:
[
1
128
]
expected
:
kUnboundedBounds
}
{
input
:
[
-
1
128
]
expected
:
kUnboundedBounds
}
{
input
:
[
100
126
]
expected
:
kUnboundedBounds
}
{
input
:
[
-
100
126
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
positive
.
max
kValue
.
i32
.
positive
.
max
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
negative
.
min
kValue
.
i32
.
positive
.
max
]
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
[
x
y
]
=
t
.
params
.
input
;
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
ldexpInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
ldexpInterval
(
{
x
}
{
y
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kMaxInterval64BitsCases
=
{
f32
:
[
{
input
:
[
0
.
1
0
]
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0x3dcccccd
)
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
0
0
.
1
]
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0x3dcccccd
)
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
0
.
1
0
.
1
]
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0x3dcccccd
)
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
0
.
1
-
0
.
1
]
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0x3dcccccd
)
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
-
0
.
1
0
.
1
]
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0x3dcccccd
)
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
-
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
kPlusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0xbdcccccd
)
)
]
}
]
as
ScalarPairToIntervalCase
[
]
f16
:
[
{
input
:
[
0
.
1
0
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
kPlusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0x2e66
)
)
]
}
{
input
:
[
0
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
kPlusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0x2e66
)
)
]
}
{
input
:
[
0
.
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
kPlusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0x2e66
)
)
]
}
{
input
:
[
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
kPlusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0x2e66
)
)
]
}
{
input
:
[
-
0
.
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
kPlusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0x2e66
)
)
]
}
{
input
:
[
-
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
kPlusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0xae67
)
)
]
}
]
as
ScalarPairToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
maxInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarPairToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
{
input
:
[
0
0
]
expected
:
0
}
{
input
:
[
1
0
]
expected
:
1
}
{
input
:
[
0
1
]
expected
:
1
}
{
input
:
[
-
1
0
]
expected
:
0
}
{
input
:
[
0
-
1
]
expected
:
0
}
{
input
:
[
1
1
]
expected
:
1
}
{
input
:
[
1
-
1
]
expected
:
1
}
{
input
:
[
-
1
1
]
expected
:
1
}
{
input
:
[
-
1
-
1
]
expected
:
-
1
}
{
input
:
[
-
0
.
1
0
]
expected
:
0
}
{
input
:
[
0
-
0
.
1
]
expected
:
0
}
.
.
.
kMaxInterval64BitsCases
[
p
.
trait
]
{
input
:
[
constants
.
positive
.
subnormal
.
max
0
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
max
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
constants
.
positive
.
subnormal
.
min
0
]
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
min
]
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
input
:
[
constants
.
negative
.
subnormal
.
max
0
]
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
input
:
[
0
constants
.
negative
.
subnormal
.
max
]
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
input
:
[
constants
.
negative
.
subnormal
.
min
0
]
expected
:
[
constants
.
negative
.
subnormal
.
min
0
]
}
{
input
:
[
0
constants
.
negative
.
subnormal
.
min
]
expected
:
[
constants
.
negative
.
subnormal
.
min
0
]
}
{
input
:
[
1
constants
.
positive
.
subnormal
.
max
]
expected
:
1
}
{
input
:
[
constants
.
negative
.
subnormal
.
min
constants
.
positive
.
subnormal
.
max
]
expected
:
[
constants
.
negative
.
subnormal
.
min
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
0
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
[
x
y
]
=
t
.
params
.
input
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
maxInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
maxInterval
(
{
x
}
{
y
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kMinInterval64BitsCases
=
{
f32
:
[
{
input
:
[
-
0
.
1
0
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
kPlusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0xbdcccccd
)
)
]
}
{
input
:
[
0
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
kPlusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0xbdcccccd
)
)
]
}
{
input
:
[
0
.
1
0
.
1
]
expected
:
[
kMinusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0x3dcccccd
)
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
kPlusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0xbdcccccd
)
)
]
}
{
input
:
[
-
0
.
1
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
kPlusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0xbdcccccd
)
)
]
}
{
input
:
[
-
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
kPlusOneULPFunctions
[
'
f32
'
]
(
reinterpretU32AsF32
(
0xbdcccccd
)
)
]
}
]
as
ScalarPairToIntervalCase
[
]
f16
:
[
{
input
:
[
-
0
.
1
0
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
kPlusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0xae67
)
)
]
}
{
input
:
[
0
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
kPlusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0xae67
)
)
]
}
{
input
:
[
0
.
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
kPlusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0x2e66
)
)
]
}
{
input
:
[
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
kPlusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0xae67
)
)
]
}
{
input
:
[
-
0
.
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
kPlusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0xae67
)
)
]
}
{
input
:
[
-
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
kPlusOneULPFunctions
[
'
f16
'
]
(
reinterpretU16AsF16
(
0xae67
)
)
]
}
]
as
ScalarPairToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
minInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarPairToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
{
input
:
[
0
0
]
expected
:
0
}
{
input
:
[
1
0
]
expected
:
0
}
{
input
:
[
0
1
]
expected
:
0
}
{
input
:
[
-
1
0
]
expected
:
-
1
}
{
input
:
[
0
-
1
]
expected
:
-
1
}
{
input
:
[
1
1
]
expected
:
1
}
{
input
:
[
1
-
1
]
expected
:
-
1
}
{
input
:
[
-
1
1
]
expected
:
-
1
}
{
input
:
[
-
1
-
1
]
expected
:
-
1
}
{
input
:
[
0
.
1
0
]
expected
:
0
}
{
input
:
[
0
0
.
1
]
expected
:
0
}
.
.
.
kMinInterval64BitsCases
[
p
.
trait
]
{
input
:
[
constants
.
positive
.
subnormal
.
max
0
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
max
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
constants
.
positive
.
subnormal
.
min
0
]
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
min
]
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
input
:
[
constants
.
negative
.
subnormal
.
max
0
]
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
input
:
[
0
constants
.
negative
.
subnormal
.
max
]
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
input
:
[
constants
.
negative
.
subnormal
.
min
0
]
expected
:
[
constants
.
negative
.
subnormal
.
min
0
]
}
{
input
:
[
0
constants
.
negative
.
subnormal
.
min
]
expected
:
[
constants
.
negative
.
subnormal
.
min
0
]
}
{
input
:
[
-
1
constants
.
positive
.
subnormal
.
max
]
expected
:
-
1
}
{
input
:
[
constants
.
negative
.
subnormal
.
min
constants
.
positive
.
subnormal
.
max
]
expected
:
[
constants
.
negative
.
subnormal
.
min
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
0
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
[
x
y
]
=
t
.
params
.
input
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
minInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
minInterval
(
{
x
}
{
y
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kMultiplicationInterval64BitsNormalCases
=
{
f32
:
[
{
input
:
[
0
.
1
0
]
expected
:
0
}
{
input
:
[
0
0
.
1
]
expected
:
0
}
{
input
:
[
-
0
.
1
0
]
expected
:
0
}
{
input
:
[
0
-
0
.
1
]
expected
:
0
}
{
input
:
[
0
.
1
1
]
expected
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
-
1
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
-
0
.
1
1
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
reinterpretU32AsF32
(
0xbdcccccc
)
]
}
{
input
:
[
-
1
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
reinterpretU32AsF32
(
0xbdcccccc
)
]
}
{
input
:
[
0
.
1
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0x3c23d708
)
reinterpretU32AsF32
(
0x3c23d70b
)
]
}
{
input
:
[
-
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0x3c23d708
)
reinterpretU32AsF32
(
0x3c23d70b
)
]
}
{
input
:
[
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbc23d70b
)
reinterpretU32AsF32
(
0xbc23d708
)
]
}
{
input
:
[
-
0
.
1
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbc23d70b
)
reinterpretU32AsF32
(
0xbc23d708
)
]
}
]
as
ScalarPairToIntervalCase
[
]
f16
:
[
{
input
:
[
0
.
1
0
]
expected
:
0
}
{
input
:
[
0
0
.
1
]
expected
:
0
}
{
input
:
[
-
0
.
1
0
]
expected
:
0
}
{
input
:
[
0
-
0
.
1
]
expected
:
0
}
{
input
:
[
0
.
1
1
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
reinterpretU16AsF16
(
0x2e67
)
]
}
{
input
:
[
-
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
reinterpretU16AsF16
(
0x2e67
)
]
}
{
input
:
[
-
0
.
1
1
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
reinterpretU16AsF16
(
0xae66
)
]
}
{
input
:
[
-
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
reinterpretU16AsF16
(
0xae66
)
]
}
{
input
:
[
0
.
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x211e
)
reinterpretU16AsF16
(
0x2120
)
]
}
{
input
:
[
-
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x211e
)
reinterpretU16AsF16
(
0x2120
)
]
}
{
input
:
[
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xa120
)
reinterpretU16AsF16
(
0xa11e
)
]
}
{
input
:
[
-
0
.
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xa120
)
reinterpretU16AsF16
(
0xa11e
)
]
}
]
as
ScalarPairToIntervalCase
[
]
abstract
:
[
{
input
:
[
0
.
1
0
]
expected
:
0
}
{
input
:
[
0
0
.
1
]
expected
:
0
}
{
input
:
[
-
0
.
1
0
]
expected
:
0
}
{
input
:
[
0
-
0
.
1
]
expected
:
0
}
{
input
:
[
0
.
1
1
]
expected
:
0
.
1
}
{
input
:
[
-
1
-
0
.
1
]
expected
:
0
.
1
}
{
input
:
[
-
0
.
1
1
]
expected
:
-
0
.
1
}
{
input
:
[
-
1
0
.
1
]
expected
:
-
0
.
1
}
{
input
:
[
0
.
1
0
.
1
]
expected
:
reinterpretU64AsF64
(
0x3f847ae147ae147cn
)
}
{
input
:
[
-
0
.
1
-
0
.
1
]
expected
:
reinterpretU64AsF64
(
0x3f847ae147ae147cn
)
}
{
input
:
[
0
.
1
-
0
.
1
]
expected
:
reinterpretU64AsF64
(
0xbf847ae147ae147cn
)
}
{
input
:
[
-
0
.
1
0
.
1
]
expected
:
reinterpretU64AsF64
(
0xbf847ae147ae147cn
)
}
]
as
ScalarPairToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
multiplicationInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarPairToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
{
input
:
[
0
0
]
expected
:
0
}
{
input
:
[
1
0
]
expected
:
0
}
{
input
:
[
0
1
]
expected
:
0
}
{
input
:
[
-
1
0
]
expected
:
0
}
{
input
:
[
0
-
1
]
expected
:
0
}
{
input
:
[
1
1
]
expected
:
1
}
{
input
:
[
1
-
1
]
expected
:
-
1
}
{
input
:
[
-
1
1
]
expected
:
-
1
}
{
input
:
[
-
1
-
1
]
expected
:
1
}
{
input
:
[
2
1
]
expected
:
2
}
{
input
:
[
1
-
2
]
expected
:
-
2
}
{
input
:
[
-
2
1
]
expected
:
-
2
}
{
input
:
[
-
2
-
1
]
expected
:
2
}
{
input
:
[
2
2
]
expected
:
4
}
{
input
:
[
2
-
2
]
expected
:
-
4
}
{
input
:
[
-
2
2
]
expected
:
-
4
}
{
input
:
[
-
2
-
2
]
expected
:
4
}
.
.
.
kMultiplicationInterval64BitsNormalCases
[
p
.
trait
]
{
input
:
[
0
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
-
1
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
-
1
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
max
constants
.
positive
.
max
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
min
constants
.
negative
.
min
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
max
constants
.
negative
.
min
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
min
constants
.
positive
.
max
]
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
[
x
y
]
=
t
.
params
.
input
;
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
multiplicationInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
multiplicationInterval
(
{
x
}
{
y
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
powInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarPairToIntervalCase
>
(
[
{
input
:
[
-
1
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
0
]
expected
:
[
kMinusNULPFunctions
[
'
f32
'
]
(
1
3
)
reinterpretU64AsF64
(
0x3ff0_0000_3000_0000n
)
]
}
{
input
:
[
2
0
]
expected
:
[
kMinusNULPFunctions
[
'
f32
'
]
(
1
3
)
reinterpretU64AsF64
(
0x3ff0_0000_3000_0000n
)
]
}
{
input
:
[
kValue
.
f32
.
positive
.
max
0
]
expected
:
[
kMinusNULPFunctions
[
'
f32
'
]
(
1
3
)
reinterpretU64AsF64
(
0x3ff0_0000_3000_0000n
)
]
}
{
input
:
[
0
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
1
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_fffe_dfff_fe00n
)
reinterpretU64AsF64
(
0x3ff0_0000_c000_0200n
)
]
}
{
input
:
[
1
100
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffba_3fff_3800n
)
reinterpretU64AsF64
(
0x3ff0_0023_2000_c800n
)
]
}
{
input
:
[
1
kValue
.
f32
.
positive
.
max
]
expected
:
kUnboundedBounds
}
{
input
:
[
2
1
]
expected
:
[
reinterpretU64AsF64
(
0x3fff_fffe_a000_0200n
)
reinterpretU64AsF64
(
0x4000_0001_0000_0200n
)
]
}
{
input
:
[
2
2
]
expected
:
[
reinterpretU64AsF64
(
0x400f_fffd_a000_0400n
)
reinterpretU64AsF64
(
0x4010_0001_a000_0400n
)
]
}
{
input
:
[
10
10
]
expected
:
[
reinterpretU64AsF64
(
0x4202_a04f_51f7_7000n
)
reinterpretU64AsF64
(
0x4202_a070_ee08_e000n
)
]
}
{
input
:
[
10
1
]
expected
:
[
reinterpretU64AsF64
(
0x4023_fffe_0b65_8b00n
)
reinterpretU64AsF64
(
0x4024_0002_149a_7c00n
)
]
}
{
input
:
[
kValue
.
f32
.
positive
.
max
1
]
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
[
x
y
]
=
t
.
params
.
input
;
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
powInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
powInterval
(
{
x
}
{
y
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kRemainderCases
=
{
f32
:
[
{
input
:
[
1
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xb4000000
)
reinterpretU32AsF32
(
0x3dccccd8
)
]
}
{
input
:
[
-
1
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbdccccd8
)
reinterpretU32AsF32
(
0x34000000
)
]
}
{
input
:
[
1
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xb4000000
)
reinterpretU32AsF32
(
0x3dccccd8
)
]
}
{
input
:
[
-
1
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbdccccd8
)
reinterpretU32AsF32
(
0x34000000
)
]
}
]
as
ScalarPairToIntervalCase
[
]
f16
:
[
{
input
:
[
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x9400
)
reinterpretU16AsF16
(
0x2e70
)
]
}
{
input
:
[
-
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xae70
)
reinterpretU16AsF16
(
0x1400
)
]
}
{
input
:
[
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x9400
)
reinterpretU16AsF16
(
0x2e70
)
]
}
{
input
:
[
-
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xae70
)
reinterpretU16AsF16
(
0x1400
)
]
}
]
as
ScalarPairToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
remainderInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarPairToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
.
.
.
kRemainderCases
[
p
.
trait
]
{
input
:
[
0
1
]
expected
:
0
}
{
input
:
[
0
-
1
]
expected
:
0
}
{
input
:
[
1
1
]
expected
:
[
0
1
]
}
{
input
:
[
1
-
1
]
expected
:
[
0
1
]
}
{
input
:
[
-
1
1
]
expected
:
[
-
1
0
]
}
{
input
:
[
-
1
-
1
]
expected
:
[
-
1
0
]
}
{
input
:
[
4
2
]
expected
:
[
0
2
]
}
{
input
:
[
-
4
2
]
expected
:
[
-
2
0
]
}
{
input
:
[
4
-
2
]
expected
:
[
0
2
]
}
{
input
:
[
-
4
-
2
]
expected
:
[
-
2
0
]
}
{
input
:
[
2
4
]
expected
:
[
2
2
]
}
{
input
:
[
-
2
4
]
expected
:
-
2
}
{
input
:
[
2
-
4
]
expected
:
2
}
{
input
:
[
-
2
-
4
]
expected
:
[
-
2
-
2
]
}
{
input
:
[
0
0
.
1
]
expected
:
0
}
{
input
:
[
0
-
0
.
1
]
expected
:
0
}
{
input
:
[
8
.
5
2
]
expected
:
0
.
5
}
{
input
:
[
1
.
125
1
]
expected
:
0
.
125
}
{
input
:
[
1
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
constants
.
positive
.
max
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
constants
.
negative
.
min
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
constants
.
positive
.
subnormal
.
max
]
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
[
x
y
]
=
t
.
params
.
input
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
remainderInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
FP
.
{
t
.
params
.
trait
}
.
remainderInterval
(
{
x
}
{
y
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
stepInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarPairToIntervalCase
>
(
p
=
>
{
const
constants
=
FP
[
p
.
trait
]
.
constants
(
)
;
return
[
{
input
:
[
0
0
]
expected
:
1
}
{
input
:
[
1
1
]
expected
:
1
}
{
input
:
[
0
1
]
expected
:
1
}
{
input
:
[
1
0
]
expected
:
0
}
{
input
:
[
-
1
-
1
]
expected
:
1
}
{
input
:
[
0
-
1
]
expected
:
0
}
{
input
:
[
-
1
0
]
expected
:
1
}
{
input
:
[
-
1
1
]
expected
:
1
}
{
input
:
[
1
-
1
]
expected
:
0
}
{
input
:
[
0
.
1
0
.
1
]
expected
:
[
0
1
]
}
{
input
:
[
0
0
.
1
]
expected
:
1
}
{
input
:
[
0
.
1
0
]
expected
:
0
}
{
input
:
[
0
.
1
1
]
expected
:
1
}
{
input
:
[
1
0
.
1
]
expected
:
0
}
{
input
:
[
-
0
.
1
-
0
.
1
]
expected
:
[
0
1
]
}
{
input
:
[
0
-
0
.
1
]
expected
:
0
}
{
input
:
[
-
0
.
1
0
]
expected
:
1
}
{
input
:
[
-
0
.
1
-
1
]
expected
:
0
}
{
input
:
[
-
1
-
0
.
1
]
expected
:
1
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
max
]
expected
:
1
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
min
]
expected
:
1
}
{
input
:
[
0
constants
.
negative
.
subnormal
.
max
]
expected
:
[
0
1
]
}
{
input
:
[
0
constants
.
negative
.
subnormal
.
min
]
expected
:
[
0
1
]
}
{
input
:
[
1
constants
.
positive
.
subnormal
.
max
]
expected
:
0
}
{
input
:
[
1
constants
.
positive
.
subnormal
.
min
]
expected
:
0
}
{
input
:
[
1
constants
.
negative
.
subnormal
.
max
]
expected
:
0
}
{
input
:
[
1
constants
.
negative
.
subnormal
.
min
]
expected
:
0
}
{
input
:
[
-
1
constants
.
positive
.
subnormal
.
max
]
expected
:
1
}
{
input
:
[
-
1
constants
.
positive
.
subnormal
.
min
]
expected
:
1
}
{
input
:
[
-
1
constants
.
negative
.
subnormal
.
max
]
expected
:
1
}
{
input
:
[
-
1
constants
.
negative
.
subnormal
.
min
]
expected
:
1
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
0
]
expected
:
[
0
1
]
}
{
input
:
[
constants
.
positive
.
subnormal
.
min
0
]
expected
:
[
0
1
]
}
{
input
:
[
constants
.
negative
.
subnormal
.
max
0
]
expected
:
1
}
{
input
:
[
constants
.
negative
.
subnormal
.
min
0
]
expected
:
1
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
1
]
expected
:
1
}
{
input
:
[
constants
.
positive
.
subnormal
.
min
1
]
expected
:
1
}
{
input
:
[
constants
.
negative
.
subnormal
.
max
1
]
expected
:
1
}
{
input
:
[
constants
.
negative
.
subnormal
.
min
1
]
expected
:
1
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
-
1
]
expected
:
0
}
{
input
:
[
constants
.
positive
.
subnormal
.
min
-
1
]
expected
:
0
}
{
input
:
[
constants
.
negative
.
subnormal
.
max
-
1
]
expected
:
0
}
{
input
:
[
constants
.
negative
.
subnormal
.
min
-
1
]
expected
:
0
}
{
input
:
[
constants
.
negative
.
subnormal
.
min
constants
.
positive
.
subnormal
.
max
]
expected
:
1
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
constants
.
negative
.
subnormal
.
min
]
expected
:
[
0
1
]
}
{
input
:
[
0
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
[
edge
x
]
=
t
.
params
.
input
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
stepInterval
(
edge
x
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
stepInterval
(
{
edge
}
{
x
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kSubtractionInterval64BitsNormalCases
=
{
f32
:
[
{
input
:
[
0
.
1
0
]
expected
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
0
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
-
0
.
1
0
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
reinterpretU32AsF32
(
0xbdcccccc
)
]
}
{
input
:
[
0
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
reinterpretU32AsF32
(
0xbdcccccc
)
]
}
{
input
:
[
0
.
1
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
-
reinterpretU32AsF32
(
0x3dcccccd
)
reinterpretU32AsF32
(
0x3dcccccd
)
-
reinterpretU32AsF32
(
0x3dcccccc
)
]
}
{
input
:
[
-
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
-
reinterpretU32AsF32
(
0xbdcccccc
)
reinterpretU32AsF32
(
0xbdcccccc
)
-
reinterpretU32AsF32
(
0xbdcccccd
)
]
}
{
input
:
[
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
-
reinterpretU32AsF32
(
0xbdcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
-
reinterpretU32AsF32
(
0xbdcccccd
)
]
}
{
input
:
[
-
0
.
1
0
.
1
]
expected
:
[
reinterpretU32AsF32
(
0xbdcccccd
)
-
reinterpretU32AsF32
(
0x3dcccccd
)
reinterpretU32AsF32
(
0xbdcccccc
)
-
reinterpretU32AsF32
(
0x3dcccccc
)
]
}
]
as
ScalarPairToIntervalCase
[
]
f16
:
[
{
input
:
[
0
.
1
0
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
reinterpretU16AsF16
(
0x2e67
)
]
}
{
input
:
[
0
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
reinterpretU16AsF16
(
0x2e67
)
]
}
{
input
:
[
-
0
.
1
0
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
reinterpretU16AsF16
(
0xae66
)
]
}
{
input
:
[
0
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
reinterpretU16AsF16
(
0xae66
)
]
}
{
input
:
[
0
.
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
-
reinterpretU16AsF16
(
0x2e67
)
reinterpretU16AsF16
(
0x2e67
)
-
reinterpretU16AsF16
(
0x2e66
)
]
}
{
input
:
[
-
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
-
reinterpretU16AsF16
(
0xae66
)
reinterpretU16AsF16
(
0xae66
)
-
reinterpretU16AsF16
(
0xae67
)
]
}
{
input
:
[
0
.
1
-
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
-
reinterpretU16AsF16
(
0xae66
)
reinterpretU16AsF16
(
0x2e67
)
-
reinterpretU16AsF16
(
0xae67
)
]
}
{
input
:
[
-
0
.
1
0
.
1
]
expected
:
[
reinterpretU16AsF16
(
0xae67
)
-
reinterpretU16AsF16
(
0x2e67
)
reinterpretU16AsF16
(
0xae66
)
-
reinterpretU16AsF16
(
0x2e66
)
]
}
]
as
ScalarPairToIntervalCase
[
]
abstract
:
[
{
input
:
[
0
.
1
0
]
expected
:
0
.
1
}
{
input
:
[
0
-
0
.
1
]
expected
:
0
.
1
}
{
input
:
[
-
0
.
1
0
]
expected
:
-
0
.
1
}
{
input
:
[
0
0
.
1
]
expected
:
-
0
.
1
}
{
input
:
[
0
.
1
0
.
1
]
expected
:
0
}
{
input
:
[
-
0
.
1
-
0
.
1
]
expected
:
0
}
{
input
:
[
0
.
1
-
0
.
1
]
expected
:
reinterpretU64AsF64
(
0x3fc999999999999an
)
}
{
input
:
[
-
0
.
1
0
.
1
]
expected
:
reinterpretU64AsF64
(
0xbfc999999999999an
)
}
]
as
ScalarPairToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
subtractionInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarPairToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
{
input
:
[
0
0
]
expected
:
0
}
{
input
:
[
1
0
]
expected
:
1
}
{
input
:
[
0
1
]
expected
:
-
1
}
{
input
:
[
-
1
0
]
expected
:
-
1
}
{
input
:
[
0
-
1
]
expected
:
1
}
{
input
:
[
1
1
]
expected
:
0
}
{
input
:
[
1
-
1
]
expected
:
2
}
{
input
:
[
-
1
1
]
expected
:
-
2
}
{
input
:
[
-
1
-
1
]
expected
:
0
}
.
.
.
kSubtractionInterval64BitsNormalCases
[
p
.
trait
]
{
input
:
[
constants
.
positive
.
subnormal
.
max
0
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
max
]
expected
:
[
constants
.
negative
.
subnormal
.
min
0
]
}
{
input
:
[
constants
.
positive
.
subnormal
.
min
0
]
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
min
]
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
input
:
[
constants
.
negative
.
subnormal
.
max
0
]
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
input
:
[
0
constants
.
negative
.
subnormal
.
max
]
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
input
:
[
constants
.
negative
.
subnormal
.
min
0
]
expected
:
[
constants
.
negative
.
subnormal
.
min
0
]
}
{
input
:
[
0
constants
.
negative
.
subnormal
.
min
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
0
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
0
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
positive
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
[
x
y
]
=
t
.
params
.
input
;
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
subtractionInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
subtractionInterval
(
{
x
}
{
y
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
interface
ScalarTripleToIntervalCase
{
input
:
[
number
number
number
]
;
expected
:
number
|
IntervalBounds
;
}
g
.
test
(
'
clampMedianInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarTripleToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
{
input
:
[
0
0
0
]
expected
:
0
}
{
input
:
[
1
0
0
]
expected
:
0
}
{
input
:
[
0
1
0
]
expected
:
0
}
{
input
:
[
0
0
1
]
expected
:
0
}
{
input
:
[
1
0
1
]
expected
:
1
}
{
input
:
[
1
1
0
]
expected
:
1
}
{
input
:
[
0
1
1
]
expected
:
1
}
{
input
:
[
1
1
1
]
expected
:
1
}
{
input
:
[
1
10
100
]
expected
:
10
}
{
input
:
[
10
1
100
]
expected
:
10
}
{
input
:
[
100
1
10
]
expected
:
10
}
{
input
:
[
-
10
1
100
]
expected
:
1
}
{
input
:
[
10
1
-
100
]
expected
:
1
}
{
input
:
[
-
10
1
-
100
]
expected
:
-
10
}
{
input
:
[
-
10
-
10
-
10
]
expected
:
-
10
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
0
0
]
expected
:
0
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
max
0
]
expected
:
0
}
{
input
:
[
0
0
constants
.
positive
.
subnormal
.
max
]
expected
:
0
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
0
constants
.
positive
.
subnormal
.
max
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
constants
.
positive
.
subnormal
.
max
0
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
max
constants
.
positive
.
subnormal
.
max
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
constants
.
positive
.
subnormal
.
max
constants
.
positive
.
subnormal
.
max
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
constants
.
positive
.
subnormal
.
min
constants
.
negative
.
subnormal
.
max
]
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
constants
.
negative
.
subnormal
.
min
constants
.
negative
.
subnormal
.
max
]
expected
:
[
constants
.
negative
.
subnormal
.
max
0
]
}
{
input
:
[
constants
.
positive
.
max
constants
.
positive
.
max
constants
.
positive
.
subnormal
.
min
]
expected
:
constants
.
positive
.
max
}
{
input
:
[
0
1
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
positive
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
[
x
y
z
]
=
t
.
params
.
input
;
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
clampMedianInterval
(
x
y
z
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
clampMedianInterval
(
{
x
}
{
y
}
{
z
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
clampMinMaxInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
ScalarTripleToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
{
input
:
[
0
0
0
]
expected
:
0
}
{
input
:
[
1
0
0
]
expected
:
0
}
{
input
:
[
0
1
0
]
expected
:
0
}
{
input
:
[
0
0
1
]
expected
:
0
}
{
input
:
[
1
0
1
]
expected
:
1
}
{
input
:
[
1
1
0
]
expected
:
0
}
{
input
:
[
0
1
1
]
expected
:
1
}
{
input
:
[
1
1
1
]
expected
:
1
}
{
input
:
[
1
10
100
]
expected
:
10
}
{
input
:
[
10
1
100
]
expected
:
10
}
{
input
:
[
100
1
10
]
expected
:
10
}
{
input
:
[
-
10
1
100
]
expected
:
1
}
{
input
:
[
10
1
-
100
]
expected
:
-
100
}
{
input
:
[
-
10
1
-
100
]
expected
:
-
100
}
{
input
:
[
-
10
-
10
-
10
]
expected
:
-
10
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
0
0
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
max
0
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
0
0
constants
.
positive
.
subnormal
.
max
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
0
constants
.
positive
.
subnormal
.
max
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
constants
.
positive
.
subnormal
.
max
0
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
0
constants
.
positive
.
subnormal
.
max
constants
.
positive
.
subnormal
.
max
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
constants
.
positive
.
subnormal
.
max
constants
.
positive
.
subnormal
.
max
]
expected
:
[
0
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
constants
.
positive
.
subnormal
.
min
constants
.
negative
.
subnormal
.
max
]
expected
:
[
constants
.
negative
.
subnormal
.
max
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
constants
.
positive
.
subnormal
.
max
constants
.
negative
.
subnormal
.
min
constants
.
negative
.
subnormal
.
max
]
expected
:
[
constants
.
negative
.
subnormal
.
min
constants
.
positive
.
subnormal
.
max
]
}
{
input
:
[
constants
.
positive
.
max
constants
.
positive
.
max
constants
.
positive
.
subnormal
.
min
]
expected
:
[
0
constants
.
positive
.
subnormal
.
min
]
}
{
input
:
[
0
1
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
constants
.
positive
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
constants
.
positive
.
infinity
]
expected
:
kUnboundedBounds
}
{
input
:
[
constants
.
negative
.
infinity
constants
.
positive
.
infinity
constants
.
negative
.
infinity
]
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
[
x
y
z
]
=
t
.
params
.
input
;
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
clampMinMaxInterval
(
x
y
z
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
clampMinMaxInterval
(
{
x
}
{
y
}
{
z
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
fmaInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarTripleToIntervalCase
>
(
[
{
input
:
[
0
0
0
]
expected
:
0
}
{
input
:
[
1
0
0
]
expected
:
0
}
{
input
:
[
0
1
0
]
expected
:
0
}
{
input
:
[
0
0
1
]
expected
:
1
}
{
input
:
[
1
0
1
]
expected
:
1
}
{
input
:
[
1
1
0
]
expected
:
1
}
{
input
:
[
0
1
1
]
expected
:
1
}
{
input
:
[
1
1
1
]
expected
:
2
}
{
input
:
[
1
10
100
]
expected
:
110
}
{
input
:
[
10
1
100
]
expected
:
110
}
{
input
:
[
100
1
10
]
expected
:
110
}
{
input
:
[
-
10
1
100
]
expected
:
90
}
{
input
:
[
10
1
-
100
]
expected
:
-
90
}
{
input
:
[
-
10
1
-
100
]
expected
:
-
110
}
{
input
:
[
-
10
-
10
-
10
]
expected
:
90
}
{
input
:
[
kValue
.
f32
.
subnormal
.
positive
.
max
0
0
]
expected
:
0
}
{
input
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
max
0
]
expected
:
0
}
{
input
:
[
0
0
kValue
.
f32
.
subnormal
.
positive
.
max
]
expected
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
max
]
}
{
input
:
[
kValue
.
f32
.
subnormal
.
positive
.
max
0
kValue
.
f32
.
subnormal
.
positive
.
max
]
expected
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
max
]
}
{
input
:
[
kValue
.
f32
.
subnormal
.
positive
.
max
kValue
.
f32
.
subnormal
.
positive
.
max
0
]
expected
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
min
]
}
{
input
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
max
kValue
.
f32
.
subnormal
.
positive
.
max
]
expected
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
max
]
}
{
input
:
[
kValue
.
f32
.
subnormal
.
positive
.
max
kValue
.
f32
.
subnormal
.
positive
.
max
kValue
.
f32
.
subnormal
.
positive
.
max
]
expected
:
[
0
kValue
.
f32
.
positive
.
min
]
}
{
input
:
[
kValue
.
f32
.
subnormal
.
positive
.
max
kValue
.
f32
.
subnormal
.
positive
.
min
kValue
.
f32
.
subnormal
.
negative
.
max
]
expected
:
[
kValue
.
f32
.
subnormal
.
negative
.
max
kValue
.
f32
.
subnormal
.
positive
.
min
]
}
{
input
:
[
kValue
.
f32
.
subnormal
.
positive
.
max
kValue
.
f32
.
subnormal
.
negative
.
min
kValue
.
f32
.
subnormal
.
negative
.
max
]
expected
:
[
reinterpretU32AsF32
(
0x80000002
)
0
]
}
{
input
:
[
0
1
kValue
.
f32
.
infinity
.
positive
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
kValue
.
f32
.
infinity
.
positive
kValue
.
f32
.
infinity
.
positive
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
infinity
.
negative
kValue
.
f32
.
infinity
.
positive
kValue
.
f32
.
infinity
.
positive
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
infinity
.
negative
kValue
.
f32
.
infinity
.
positive
kValue
.
f32
.
infinity
.
negative
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
subnormal
.
positive
.
min
]
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
fmaInterval
(
.
.
.
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
fmaInterval
(
{
t
.
params
.
input
.
join
(
'
'
)
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
mixImpreciseInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarTripleToIntervalCase
>
(
[
{
input
:
[
0
.
0
1
.
0
-
1
.
0
]
expected
:
-
1
.
0
}
{
input
:
[
0
.
0
1
.
0
0
.
0
]
expected
:
0
.
0
}
{
input
:
[
0
.
0
1
.
0
0
.
1
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9999_8000_0000n
)
reinterpretU64AsF64
(
0x3fb9_9999_a000_0000n
)
]
}
{
input
:
[
0
.
0
1
.
0
0
.
5
]
expected
:
0
.
5
}
{
input
:
[
0
.
0
1
.
0
0
.
9
]
expected
:
[
reinterpretU64AsF64
(
0x3fec_cccc_c000_0000n
)
reinterpretU64AsF64
(
0x3fec_cccc_e000_0000n
)
]
}
{
input
:
[
0
.
0
1
.
0
1
.
0
]
expected
:
1
.
0
}
{
input
:
[
0
.
0
1
.
0
2
.
0
]
expected
:
2
.
0
}
{
input
:
[
1
.
0
0
.
0
-
1
.
0
]
expected
:
2
.
0
}
{
input
:
[
1
.
0
0
.
0
0
.
0
]
expected
:
1
.
0
}
{
input
:
[
1
.
0
0
.
0
0
.
1
]
expected
:
[
reinterpretU64AsF64
(
0x3fec_cccc_c000_0000n
)
reinterpretU64AsF64
(
0x3fec_cccc_e000_0000n
)
]
}
{
input
:
[
1
.
0
0
.
0
0
.
5
]
expected
:
0
.
5
}
{
input
:
[
1
.
0
0
.
0
0
.
9
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9999_0000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_0000_0000n
)
]
}
{
input
:
[
1
.
0
0
.
0
1
.
0
]
expected
:
0
.
0
}
{
input
:
[
1
.
0
0
.
0
2
.
0
]
expected
:
-
1
.
0
}
{
input
:
[
0
.
0
10
.
0
-
1
.
0
]
expected
:
-
10
.
0
}
{
input
:
[
0
.
0
10
.
0
0
.
0
]
expected
:
0
.
0
}
{
input
:
[
0
.
0
10
.
0
0
.
1
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_e000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_2000_0000n
)
]
}
{
input
:
[
0
.
0
10
.
0
0
.
5
]
expected
:
5
.
0
}
{
input
:
[
0
.
0
10
.
0
0
.
9
]
expected
:
[
reinterpretU64AsF64
(
0x4021_ffff_e000_0000n
)
reinterpretU64AsF64
(
0x4022_0000_2000_0000n
)
]
}
{
input
:
[
0
.
0
10
.
0
1
.
0
]
expected
:
10
.
0
}
{
input
:
[
0
.
0
10
.
0
2
.
0
]
expected
:
20
.
0
}
{
input
:
[
2
.
0
10
.
0
-
1
.
0
]
expected
:
-
6
.
0
}
{
input
:
[
2
.
0
10
.
0
0
.
0
]
expected
:
2
.
0
}
{
input
:
[
2
.
0
10
.
0
0
.
1
]
expected
:
[
reinterpretU64AsF64
(
0x4006_6666_6000_0000n
)
reinterpretU64AsF64
(
0x4006_6666_8000_0000n
)
]
}
{
input
:
[
2
.
0
10
.
0
0
.
5
]
expected
:
6
.
0
}
{
input
:
[
2
.
0
10
.
0
0
.
9
]
expected
:
[
reinterpretU64AsF64
(
0x4022_6666_6000_0000n
)
reinterpretU64AsF64
(
0x4022_6666_8000_0000n
)
]
}
{
input
:
[
2
.
0
10
.
0
1
.
0
]
expected
:
10
.
0
}
{
input
:
[
2
.
0
10
.
0
2
.
0
]
expected
:
18
.
0
}
{
input
:
[
-
1
.
0
1
.
0
-
2
.
0
]
expected
:
-
5
.
0
}
{
input
:
[
-
1
.
0
1
.
0
0
.
0
]
expected
:
-
1
.
0
}
{
input
:
[
-
1
.
0
1
.
0
0
.
1
]
expected
:
[
reinterpretU64AsF64
(
0xbfe9_9999_a000_0000n
)
reinterpretU64AsF64
(
0xbfe9_9999_8000_0000n
)
]
}
{
input
:
[
-
1
.
0
1
.
0
0
.
5
]
expected
:
0
.
0
}
{
input
:
[
-
1
.
0
1
.
0
0
.
9
]
expected
:
[
reinterpretU64AsF64
(
0x3fe9_9999_8000_0000n
)
reinterpretU64AsF64
(
0x3fe9_9999_c000_0000n
)
]
}
{
input
:
[
-
1
.
0
1
.
0
1
.
0
]
expected
:
1
.
0
}
{
input
:
[
-
1
.
0
1
.
0
2
.
0
]
expected
:
3
.
0
}
{
input
:
[
0
.
0
kValue
.
f32
.
infinity
.
positive
0
.
5
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
infinity
.
positive
0
.
0
0
.
5
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
infinity
.
negative
1
.
0
0
.
5
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
.
0
kValue
.
f32
.
infinity
.
negative
0
.
5
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
infinity
.
negative
kValue
.
f32
.
infinity
.
positive
0
.
5
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
infinity
.
positive
kValue
.
f32
.
infinity
.
negative
0
.
5
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
.
0
1
.
0
kValue
.
f32
.
infinity
.
negative
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
.
0
0
.
0
kValue
.
f32
.
infinity
.
negative
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
.
0
1
.
0
kValue
.
f32
.
infinity
.
positive
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
.
0
0
.
0
kValue
.
f32
.
infinity
.
positive
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
negative
.
min
10
.
0
1
.
0
]
expected
:
0
.
0
}
]
)
.
fn
(
t
=
>
{
const
[
x
y
z
]
=
t
.
params
.
input
;
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
mixImpreciseInterval
(
x
y
z
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
mixImpreciseInterval
(
{
x
}
{
y
}
{
z
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
mixPreciseInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarTripleToIntervalCase
>
(
[
{
input
:
[
0
.
0
1
.
0
-
1
.
0
]
expected
:
-
1
.
0
}
{
input
:
[
0
.
0
1
.
0
0
.
0
]
expected
:
0
.
0
}
{
input
:
[
0
.
0
1
.
0
0
.
1
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9999_8000_0000n
)
reinterpretU64AsF64
(
0x3fb9_9999_a000_0000n
)
]
}
{
input
:
[
0
.
0
1
.
0
0
.
5
]
expected
:
0
.
5
}
{
input
:
[
0
.
0
1
.
0
0
.
9
]
expected
:
[
reinterpretU64AsF64
(
0x3fec_cccc_c000_0000n
)
reinterpretU64AsF64
(
0x3fec_cccc_e000_0000n
)
]
}
{
input
:
[
0
.
0
1
.
0
1
.
0
]
expected
:
1
.
0
}
{
input
:
[
0
.
0
1
.
0
2
.
0
]
expected
:
2
.
0
}
{
input
:
[
1
.
0
0
.
0
-
1
.
0
]
expected
:
2
.
0
}
{
input
:
[
1
.
0
0
.
0
0
.
0
]
expected
:
1
.
0
}
{
input
:
[
1
.
0
0
.
0
0
.
1
]
expected
:
[
reinterpretU64AsF64
(
0x3fec_cccc_c000_0000n
)
reinterpretU64AsF64
(
0x3fec_cccc_e000_0000n
)
]
}
{
input
:
[
1
.
0
0
.
0
0
.
5
]
expected
:
0
.
5
}
{
input
:
[
1
.
0
0
.
0
0
.
9
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9999_0000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_0000_0000n
)
]
}
{
input
:
[
1
.
0
0
.
0
1
.
0
]
expected
:
0
.
0
}
{
input
:
[
1
.
0
0
.
0
2
.
0
]
expected
:
-
1
.
0
}
{
input
:
[
0
.
0
10
.
0
-
1
.
0
]
expected
:
-
10
.
0
}
{
input
:
[
0
.
0
10
.
0
0
.
0
]
expected
:
0
.
0
}
{
input
:
[
0
.
0
10
.
0
0
.
1
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_e000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_2000_0000n
)
]
}
{
input
:
[
0
.
0
10
.
0
0
.
5
]
expected
:
5
.
0
}
{
input
:
[
0
.
0
10
.
0
0
.
9
]
expected
:
[
reinterpretU64AsF64
(
0x4021_ffff_e000_0000n
)
reinterpretU64AsF64
(
0x4022_0000_2000_0000n
)
]
}
{
input
:
[
0
.
0
10
.
0
1
.
0
]
expected
:
10
.
0
}
{
input
:
[
0
.
0
10
.
0
2
.
0
]
expected
:
20
.
0
}
{
input
:
[
2
.
0
10
.
0
-
1
.
0
]
expected
:
-
6
.
0
}
{
input
:
[
2
.
0
10
.
0
0
.
0
]
expected
:
2
.
0
}
{
input
:
[
2
.
0
10
.
0
0
.
1
]
expected
:
[
reinterpretU64AsF64
(
0x4006_6666_4000_0000n
)
reinterpretU64AsF64
(
0x4006_6666_8000_0000n
)
]
}
{
input
:
[
2
.
0
10
.
0
0
.
5
]
expected
:
6
.
0
}
{
input
:
[
2
.
0
10
.
0
0
.
9
]
expected
:
[
reinterpretU64AsF64
(
0x4022_6666_4000_0000n
)
reinterpretU64AsF64
(
0x4022_6666_a000_0000n
)
]
}
{
input
:
[
2
.
0
10
.
0
1
.
0
]
expected
:
10
.
0
}
{
input
:
[
2
.
0
10
.
0
2
.
0
]
expected
:
18
.
0
}
{
input
:
[
-
1
.
0
1
.
0
-
2
.
0
]
expected
:
-
5
.
0
}
{
input
:
[
-
1
.
0
1
.
0
0
.
0
]
expected
:
-
1
.
0
}
{
input
:
[
-
1
.
0
1
.
0
0
.
1
]
expected
:
[
reinterpretU64AsF64
(
0xbfe9_9999_c000_0000n
)
reinterpretU64AsF64
(
0xbfe9_9999_8000_0000n
)
]
}
{
input
:
[
-
1
.
0
1
.
0
0
.
5
]
expected
:
0
.
0
}
{
input
:
[
-
1
.
0
1
.
0
0
.
9
]
expected
:
[
reinterpretU64AsF64
(
0x3fe9_9999_8000_0000n
)
reinterpretU64AsF64
(
0x3fe9_9999_c000_0000n
)
]
}
{
input
:
[
-
1
.
0
1
.
0
1
.
0
]
expected
:
1
.
0
}
{
input
:
[
-
1
.
0
1
.
0
2
.
0
]
expected
:
3
.
0
}
{
input
:
[
0
.
0
kValue
.
f32
.
infinity
.
positive
0
.
5
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
infinity
.
positive
0
.
0
0
.
5
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
infinity
.
negative
1
.
0
0
.
5
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
.
0
kValue
.
f32
.
infinity
.
negative
0
.
5
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
infinity
.
negative
kValue
.
f32
.
infinity
.
positive
0
.
5
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
infinity
.
positive
kValue
.
f32
.
infinity
.
negative
0
.
5
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
.
0
1
.
0
kValue
.
f32
.
infinity
.
negative
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
.
0
0
.
0
kValue
.
f32
.
infinity
.
negative
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
.
0
1
.
0
kValue
.
f32
.
infinity
.
positive
]
expected
:
kUnboundedBounds
}
{
input
:
[
1
.
0
0
.
0
kValue
.
f32
.
infinity
.
positive
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
negative
.
min
10
.
0
1
.
0
]
expected
:
10
.
0
}
]
)
.
fn
(
t
=
>
{
const
[
x
y
z
]
=
t
.
params
.
input
;
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
mixPreciseInterval
(
x
y
z
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
mixPreciseInterval
(
{
x
}
{
y
}
{
z
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
smoothStepInterval_f32
'
)
.
paramsSubcasesOnly
<
ScalarTripleToIntervalCase
>
(
[
{
input
:
[
0
1
0
]
expected
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
min
]
}
{
input
:
[
0
1
1
]
expected
:
[
reinterpretU32AsF32
(
0x3f7ffffa
)
reinterpretU32AsF32
(
0x3f800003
)
]
}
{
input
:
[
0
1
10
]
expected
:
1
}
{
input
:
[
0
1
-
10
]
expected
:
0
}
{
input
:
[
0
2
1
]
expected
:
[
reinterpretU32AsF32
(
0x3efffff8
)
reinterpretU32AsF32
(
0x3f000007
)
]
}
{
input
:
[
0
2
0
.
5
]
expected
:
[
reinterpretU32AsF32
(
0x3e1ffffb
)
reinterpretU32AsF32
(
0x3e200007
)
]
}
{
input
:
[
2
0
1
]
expected
:
[
reinterpretU32AsF32
(
0x3efffff8
)
reinterpretU32AsF32
(
0x3f000007
)
]
}
{
input
:
[
2
0
1
.
5
]
expected
:
[
reinterpretU32AsF32
(
0x3e1ffffb
)
reinterpretU32AsF32
(
0x3e200007
)
]
}
{
input
:
[
0
100
50
]
expected
:
[
reinterpretU32AsF32
(
0x3efffff8
)
reinterpretU32AsF32
(
0x3f000007
)
]
}
{
input
:
[
0
100
25
]
expected
:
[
reinterpretU32AsF32
(
0x3e1ffffb
)
reinterpretU32AsF32
(
0x3e200007
)
]
}
{
input
:
[
0
-
2
-
1
]
expected
:
[
reinterpretU32AsF32
(
0x3efffff8
)
reinterpretU32AsF32
(
0x3f000007
)
]
}
{
input
:
[
0
-
2
-
0
.
5
]
expected
:
[
reinterpretU32AsF32
(
0x3e1ffffb
)
reinterpretU32AsF32
(
0x3e200007
)
]
}
{
input
:
[
0
2
kValue
.
f32
.
subnormal
.
positive
.
max
]
expected
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
min
]
}
{
input
:
[
0
2
kValue
.
f32
.
subnormal
.
positive
.
min
]
expected
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
min
]
}
{
input
:
[
0
2
kValue
.
f32
.
subnormal
.
negative
.
max
]
expected
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
min
]
}
{
input
:
[
0
2
kValue
.
f32
.
subnormal
.
negative
.
min
]
expected
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
min
]
}
{
input
:
[
kValue
.
f32
.
subnormal
.
positive
.
max
2
1
]
expected
:
[
reinterpretU32AsF32
(
0x3efffff8
)
reinterpretU32AsF32
(
0x3f000007
)
]
}
{
input
:
[
kValue
.
f32
.
subnormal
.
positive
.
min
2
1
]
expected
:
[
reinterpretU32AsF32
(
0x3efffff8
)
reinterpretU32AsF32
(
0x3f000007
)
]
}
{
input
:
[
kValue
.
f32
.
subnormal
.
negative
.
max
2
1
]
expected
:
[
reinterpretU32AsF32
(
0x3efffff8
)
reinterpretU32AsF32
(
0x3f000007
)
]
}
{
input
:
[
kValue
.
f32
.
subnormal
.
negative
.
min
2
1
]
expected
:
[
reinterpretU32AsF32
(
0x3efffff8
)
reinterpretU32AsF32
(
0x3f000007
)
]
}
{
input
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
max
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
min
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
kValue
.
f32
.
subnormal
.
negative
.
max
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
kValue
.
f32
.
subnormal
.
negative
.
min
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
2
Number
.
POSITIVE_INFINITY
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
2
Number
.
NEGATIVE_INFINITY
]
expected
:
kUnboundedBounds
}
{
input
:
[
Number
.
POSITIVE_INFINITY
2
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
Number
.
NEGATIVE_INFINITY
2
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
Number
.
POSITIVE_INFINITY
1
]
expected
:
kUnboundedBounds
}
{
input
:
[
0
Number
.
NEGATIVE_INFINITY
1
]
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
[
low
high
x
]
=
t
.
params
.
input
;
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
smoothStepInterval
(
low
high
x
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
smoothStepInterval
(
{
low
}
{
high
}
{
x
}
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
interface
ScalarToVectorCase
{
input
:
number
;
expected
:
(
number
|
IntervalBounds
)
[
]
;
}
g
.
test
(
'
unpack2x16floatInterval
'
)
.
paramsSubcasesOnly
<
ScalarToVectorCase
>
(
[
{
input
:
0x00000000
expected
:
[
0
0
]
}
{
input
:
0x80000000
expected
:
[
0
0
]
}
{
input
:
0x00008000
expected
:
[
0
0
]
}
{
input
:
0x80008000
expected
:
[
0
0
]
}
{
input
:
0x00003c00
expected
:
[
1
0
]
}
{
input
:
0x3c000000
expected
:
[
0
1
]
}
{
input
:
0x3c003c00
expected
:
[
1
1
]
}
{
input
:
0xbc00bc00
expected
:
[
-
1
-
1
]
}
{
input
:
0x49004900
expected
:
[
10
10
]
}
{
input
:
0xc900c900
expected
:
[
-
10
-
10
]
}
{
input
:
0x000003ff
expected
:
[
[
0
kValue
.
f16
.
subnormal
.
positive
.
max
]
0
]
}
{
input
:
0x000083ff
expected
:
[
[
kValue
.
f16
.
subnormal
.
negative
.
min
0
]
0
]
}
{
input
:
0x7c000000
expected
:
[
kUnboundedBounds
kUnboundedBounds
]
}
{
input
:
0xffff0000
expected
:
[
kUnboundedBounds
kUnboundedBounds
]
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toVector
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
unpack2x16floatInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
unpack2x16floatInterval
(
{
t
.
params
.
input
}
)
returned
[
{
got
}
]
.
Expected
[
{
expected
}
]
)
;
}
)
;
{
const
kZeroBounds
:
IntervalBounds
=
[
reinterpretU32AsF32
(
0x81400000
)
reinterpretU32AsF32
(
0x01400000
)
]
;
const
kOneBoundsSnorm
:
IntervalBounds
=
[
reinterpretU64AsF64
(
0x3fef_ffff_a000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_3000_0000n
)
]
;
const
kNegOneBoundsSnorm
:
IntervalBounds
=
[
reinterpretU64AsF64
(
0xbff0_0000_3000_0000n
)
reinterpretU64AsF64
(
0xbfef_ffff_a000_0000n
)
]
;
const
kHalfBounds2x16snorm
:
IntervalBounds
=
[
reinterpretU64AsF64
(
0x3fe0_001f_a000_0000n
)
reinterpretU64AsF64
(
0x3fe0_0020_8000_0000n
)
]
;
const
kNegHalfBounds2x16snorm
:
IntervalBounds
=
[
reinterpretU64AsF64
(
0xbfdf_ffc0_6000_0000n
)
reinterpretU64AsF64
(
0xbfdf_ffbf_8000_0000n
)
]
;
g
.
test
(
'
unpack2x16snormInterval
'
)
.
paramsSubcasesOnly
<
ScalarToVectorCase
>
(
[
{
input
:
0x00000000
expected
:
[
kZeroBounds
kZeroBounds
]
}
{
input
:
0x00007fff
expected
:
[
kOneBoundsSnorm
kZeroBounds
]
}
{
input
:
0x7fff0000
expected
:
[
kZeroBounds
kOneBoundsSnorm
]
}
{
input
:
0x7fff7fff
expected
:
[
kOneBoundsSnorm
kOneBoundsSnorm
]
}
{
input
:
0x80018001
expected
:
[
kNegOneBoundsSnorm
kNegOneBoundsSnorm
]
}
{
input
:
0x40004000
expected
:
[
kHalfBounds2x16snorm
kHalfBounds2x16snorm
]
}
{
input
:
0xc001c001
expected
:
[
kNegHalfBounds2x16snorm
kNegHalfBounds2x16snorm
]
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toVector
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
unpack2x16snormInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
unpack2x16snormInterval
(
{
t
.
params
.
input
}
)
returned
[
{
got
}
]
.
Expected
[
{
expected
}
]
)
;
}
)
;
}
{
const
kZeroBounds
:
IntervalBounds
=
[
reinterpretU32AsF32
(
0x8140_0000
)
reinterpretU32AsF32
(
0x0140_0000
)
]
;
const
kOneBounds
:
IntervalBounds
=
[
reinterpretU64AsF64
(
0x3fef_ffff_a000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_3000_0000n
)
]
;
const
kHalfBounds
:
IntervalBounds
=
[
reinterpretU64AsF64
(
0x3fe0_000f_a000_0000n
)
reinterpretU64AsF64
(
0x3fe0_0010_8000_0000n
)
]
;
g
.
test
(
'
unpack2x16unormInterval
'
)
.
paramsSubcasesOnly
<
ScalarToVectorCase
>
(
[
{
input
:
0x00000000
expected
:
[
kZeroBounds
kZeroBounds
]
}
{
input
:
0x0000ffff
expected
:
[
kOneBounds
kZeroBounds
]
}
{
input
:
0xffff0000
expected
:
[
kZeroBounds
kOneBounds
]
}
{
input
:
0xffffffff
expected
:
[
kOneBounds
kOneBounds
]
}
{
input
:
0x80008000
expected
:
[
kHalfBounds
kHalfBounds
]
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toVector
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
unpack2x16unormInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
unpack2x16unormInterval
(
{
t
.
params
.
input
}
)
\
n
\
tReturned
[
{
got
}
]
\
n
\
tExpected
[
{
expected
}
]
)
;
}
)
;
}
{
const
kZeroBounds
:
IntervalBounds
=
[
reinterpretU32AsF32
(
0x8140_0000
)
reinterpretU32AsF32
(
0x0140_0000
)
]
;
const
kOneBounds
:
IntervalBounds
=
[
reinterpretU64AsF64
(
0x3fef_ffff_a000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_3000_0000n
)
]
;
const
kNegOneBounds
:
IntervalBounds
=
[
reinterpretU64AsF64
(
0xbff0_0000_3000_0000n
)
reinterpretU64AsF64
(
0xbfef_ffff_a0000_000n
)
]
;
const
kHalfBounds
:
IntervalBounds
=
[
reinterpretU64AsF64
(
0x3fe0_2040_2000_0000n
)
reinterpretU64AsF64
(
0x3fe0_2041_0000_0000n
)
]
;
const
kNegHalfBounds
:
IntervalBounds
=
[
reinterpretU64AsF64
(
0xbfdf_bf7f_6000_0000n
)
reinterpretU64AsF64
(
0xbfdf_bf7e_8000_0000n
)
]
;
g
.
test
(
'
unpack4x8snormInterval
'
)
.
paramsSubcasesOnly
<
ScalarToVectorCase
>
(
[
{
input
:
0x00000000
expected
:
[
kZeroBounds
kZeroBounds
kZeroBounds
kZeroBounds
]
}
{
input
:
0x0000007f
expected
:
[
kOneBounds
kZeroBounds
kZeroBounds
kZeroBounds
]
}
{
input
:
0x00007f00
expected
:
[
kZeroBounds
kOneBounds
kZeroBounds
kZeroBounds
]
}
{
input
:
0x007f0000
expected
:
[
kZeroBounds
kZeroBounds
kOneBounds
kZeroBounds
]
}
{
input
:
0x7f000000
expected
:
[
kZeroBounds
kZeroBounds
kZeroBounds
kOneBounds
]
}
{
input
:
0x00007f7f
expected
:
[
kOneBounds
kOneBounds
kZeroBounds
kZeroBounds
]
}
{
input
:
0x7f7f0000
expected
:
[
kZeroBounds
kZeroBounds
kOneBounds
kOneBounds
]
}
{
input
:
0x7f007f00
expected
:
[
kZeroBounds
kOneBounds
kZeroBounds
kOneBounds
]
}
{
input
:
0x007f007f
expected
:
[
kOneBounds
kZeroBounds
kOneBounds
kZeroBounds
]
}
{
input
:
0x7f7f7f7f
expected
:
[
kOneBounds
kOneBounds
kOneBounds
kOneBounds
]
}
{
input
:
0x81818181
expected
:
[
kNegOneBounds
kNegOneBounds
kNegOneBounds
kNegOneBounds
]
}
{
input
:
0x40404040
expected
:
[
kHalfBounds
kHalfBounds
kHalfBounds
kHalfBounds
]
}
{
input
:
0xc1c1c1c1
expected
:
[
kNegHalfBounds
kNegHalfBounds
kNegHalfBounds
kNegHalfBounds
]
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toVector
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
unpack4x8snormInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
unpack4x8snormInterval
(
{
t
.
params
.
input
}
)
\
n
\
tReturned
[
{
got
}
]
\
n
\
tExpected
[
{
expected
}
]
)
;
}
)
;
}
{
const
kZeroBounds
:
IntervalBounds
=
[
reinterpretU32AsF32
(
0x8140_0000
)
reinterpretU32AsF32
(
0x0140_0000
)
]
;
const
kOneBounds
:
IntervalBounds
=
[
reinterpretU64AsF64
(
0x3fef_ffff_a000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_3000_0000n
)
]
;
const
kHalfBounds
:
IntervalBounds
=
[
reinterpretU64AsF64
(
0x3fe0_100f_a000_0000n
)
reinterpretU64AsF64
(
0x3fe0_1010_8000_0000n
)
]
;
g
.
test
(
'
unpack4x8unormInterval
'
)
.
paramsSubcasesOnly
<
ScalarToVectorCase
>
(
[
{
input
:
0x00000000
expected
:
[
kZeroBounds
kZeroBounds
kZeroBounds
kZeroBounds
]
}
{
input
:
0x000000ff
expected
:
[
kOneBounds
kZeroBounds
kZeroBounds
kZeroBounds
]
}
{
input
:
0x0000ff00
expected
:
[
kZeroBounds
kOneBounds
kZeroBounds
kZeroBounds
]
}
{
input
:
0x00ff0000
expected
:
[
kZeroBounds
kZeroBounds
kOneBounds
kZeroBounds
]
}
{
input
:
0xff000000
expected
:
[
kZeroBounds
kZeroBounds
kZeroBounds
kOneBounds
]
}
{
input
:
0x0000ffff
expected
:
[
kOneBounds
kOneBounds
kZeroBounds
kZeroBounds
]
}
{
input
:
0xffff0000
expected
:
[
kZeroBounds
kZeroBounds
kOneBounds
kOneBounds
]
}
{
input
:
0xff00ff00
expected
:
[
kZeroBounds
kOneBounds
kZeroBounds
kOneBounds
]
}
{
input
:
0x00ff00ff
expected
:
[
kOneBounds
kZeroBounds
kOneBounds
kZeroBounds
]
}
{
input
:
0xffffffff
expected
:
[
kOneBounds
kOneBounds
kOneBounds
kOneBounds
]
}
{
input
:
0x80808080
expected
:
[
kHalfBounds
kHalfBounds
kHalfBounds
kHalfBounds
]
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toVector
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
unpack4x8unormInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
unpack4x8unormInterval
(
{
t
.
params
.
input
}
)
\
n
\
tReturned
[
{
got
}
]
\
n
\
tExpected
[
{
expected
}
]
)
;
}
)
;
}
interface
VectorToIntervalCase
{
input
:
number
[
]
;
expected
:
number
|
IntervalBounds
;
}
g
.
test
(
'
lengthIntervalVector_f32
'
)
.
paramsSubcasesOnly
<
VectorToIntervalCase
>
(
[
{
input
:
[
1
.
0
0
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
0
.
0
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
1
.
0
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3ff6_a09d_b000_0000n
)
reinterpretU64AsF64
(
0x3ff6_a09f_1000_0000n
)
]
}
{
input
:
[
-
1
.
0
-
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3ff6_a09d_b000_0000n
)
reinterpretU64AsF64
(
0x3ff6_a09f_1000_0000n
)
]
}
{
input
:
[
-
1
.
0
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3ff6_a09d_b000_0000n
)
reinterpretU64AsF64
(
0x3ff6_a09f_1000_0000n
)
]
}
{
input
:
[
0
.
1
0
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_9000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_7000_0000n
)
]
}
{
input
:
[
1
.
0
0
.
0
0
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
0
.
0
1
.
0
0
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
0
.
0
0
.
0
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
1
.
0
1
.
0
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3ffb_b67a_1000_0000n
)
reinterpretU64AsF64
(
0x3ffb_b67b_b000_0000n
)
]
}
{
input
:
[
-
1
.
0
-
1
.
0
-
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3ffb_b67a_1000_0000n
)
reinterpretU64AsF64
(
0x3ffb_b67b_b000_0000n
)
]
}
{
input
:
[
1
.
0
-
1
.
0
-
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3ffb_b67a_1000_0000n
)
reinterpretU64AsF64
(
0x3ffb_b67b_b000_0000n
)
]
}
{
input
:
[
0
.
1
0
.
0
0
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_9000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_7000_0000n
)
]
}
{
input
:
[
1
.
0
0
.
0
0
.
0
0
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
0
.
0
1
.
0
0
.
0
0
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
0
.
0
0
.
0
1
.
0
0
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
0
.
0
0
.
0
0
.
0
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
1
.
0
1
.
0
1
.
0
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fff_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x4000_0000_9000_0000n
)
]
}
{
input
:
[
-
1
.
0
-
1
.
0
-
1
.
0
-
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fff_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x4000_0000_9000_0000n
)
]
}
{
input
:
[
-
1
.
0
1
.
0
-
1
.
0
1
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fff_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x4000_0000_9000_0000n
)
]
}
{
input
:
[
0
.
1
0
.
0
0
.
0
0
.
0
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_9000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_7000_0000n
)
]
}
{
input
:
[
kValue
.
f32
.
positive
.
nearest_max
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
negative
.
min
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
positive
.
nearest_max
kValue
.
f32
.
negative
.
min
]
expected
:
kUnboundedBounds
}
{
input
:
[
kValue
.
f32
.
negative
.
min
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
positive
.
nearest_max
]
expected
:
kUnboundedBounds
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
lengthInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
lengthInterval
(
[
{
t
.
params
.
input
}
]
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
interface
VectorPairToIntervalCase
{
input
:
[
number
[
]
number
[
]
]
;
expected
:
number
|
IntervalBounds
;
}
g
.
test
(
'
distanceIntervalVector_f32
'
)
.
paramsSubcasesOnly
<
VectorPairToIntervalCase
>
(
[
{
input
:
[
[
1
.
0
0
.
0
]
[
1
.
0
0
.
0
]
]
expected
:
kUnboundedBounds
}
{
input
:
[
[
1
.
0
0
.
0
]
[
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
]
[
1
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
-
1
.
0
0
.
0
]
[
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
]
[
-
1
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
1
.
0
]
[
-
1
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3ff6_a09d_b000_0000n
)
reinterpretU64AsF64
(
0x3ff6_a09f_1000_0000n
)
]
}
{
input
:
[
[
0
.
1
0
.
0
]
[
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_9000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_7000_0000n
)
]
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
]
]
expected
:
kUnboundedBounds
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
]
[
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
1
.
0
0
.
0
]
[
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
1
.
0
]
[
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
]
[
0
.
0
1
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
]
[
0
.
0
0
.
0
1
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
1
.
0
1
.
0
1
.
0
]
[
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3ffb_b67a_1000_0000n
)
reinterpretU64AsF64
(
0x3ffb_b67b_b000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3ffb_b67a_1000_0000n
)
reinterpretU64AsF64
(
0x3ffb_b67b_b000_0000n
)
]
}
{
input
:
[
[
-
1
.
0
-
1
.
0
-
1
.
0
]
[
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3ffb_b67a_1000_0000n
)
reinterpretU64AsF64
(
0x3ffb_b67b_b000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
]
[
-
1
.
0
-
1
.
0
-
1
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3ffb_b67a_1000_0000n
)
reinterpretU64AsF64
(
0x3ffb_b67b_b000_0000n
)
]
}
{
input
:
[
[
0
.
1
0
.
0
0
.
0
]
[
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_9000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_7000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
]
[
0
.
1
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_9000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_7000_0000n
)
]
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
kUnboundedBounds
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
0
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
1
.
0
0
.
0
0
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
1
.
0
0
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
1
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
0
.
0
]
[
0
.
0
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
0
.
0
]
[
0
.
0
0
.
0
1
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
0
.
0
]
[
0
.
0
0
.
0
0
.
0
1
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fef_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_9000_0000n
)
]
}
{
input
:
[
[
1
.
0
1
.
0
1
.
0
1
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fff_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x4000_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fff_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x4000_0000_9000_0000n
)
]
}
{
input
:
[
[
-
1
.
0
1
.
0
-
1
.
0
1
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fff_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x4000_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
-
1
.
0
1
.
0
-
1
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fff_ffff_7000_0000n
)
reinterpretU64AsF64
(
0x4000_0000_9000_0000n
)
]
}
{
input
:
[
[
0
.
1
0
.
0
0
.
0
0
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_9000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_7000_0000n
)
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
0
.
0
]
[
0
.
1
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU64AsF64
(
0x3fb9_9998_9000_0000n
)
reinterpretU64AsF64
(
0x3fb9_999a_7000_0000n
)
]
}
]
)
.
fn
(
t
=
>
{
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
distanceInterval
(
.
.
.
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
distanceInterval
(
[
{
t
.
params
.
input
[
0
]
}
{
t
.
params
.
input
[
1
]
}
]
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
const
kDotIntervalCases
=
{
f32
:
[
{
input
:
[
[
0
.
1
0
.
0
]
[
1
.
0
0
.
0
]
]
expected
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
[
0
.
1
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
[
0
.
1
0
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
}
{
input
:
[
[
kValue
.
f32
.
positive
.
max
1
.
0
2
.
0
3
.
0
]
[
-
1
.
0
kValue
.
f32
.
positive
.
max
-
2
.
0
-
3
.
0
]
]
expected
:
[
-
13
0
]
}
{
input
:
[
[
kValue
.
f32
.
positive
.
max
1
.
0
2
.
0
3
.
0
]
[
1
.
0
kValue
.
f32
.
negative
.
min
2
.
0
3
.
0
]
]
expected
:
[
0
13
]
}
]
as
VectorPairToIntervalCase
[
]
f16
:
[
{
input
:
[
[
0
.
1
0
.
0
]
[
1
.
0
0
.
0
]
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
reinterpretU16AsF16
(
0x2e67
)
]
}
{
input
:
[
[
0
.
1
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
reinterpretU16AsF16
(
0x2e67
)
]
}
{
input
:
[
[
0
.
1
0
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
reinterpretU16AsF16
(
0x2e66
)
reinterpretU16AsF16
(
0x2e67
)
]
}
{
input
:
[
[
kValue
.
f16
.
positive
.
max
1
.
0
2
.
0
3
.
0
]
[
-
1
.
0
kValue
.
f16
.
positive
.
max
-
2
.
0
-
3
.
0
]
]
expected
:
kUnboundedBounds
}
{
input
:
[
[
kValue
.
f16
.
positive
.
max
1
.
0
2
.
0
3
.
0
]
[
1
.
0
kValue
.
f16
.
negative
.
min
2
.
0
3
.
0
]
]
expected
:
kUnboundedBounds
}
]
as
VectorPairToIntervalCase
[
]
}
as
const
;
g
.
test
(
'
dotInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
VectorPairToIntervalCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
{
input
:
[
[
1
.
0
0
.
0
]
[
1
.
0
0
.
0
]
]
expected
:
1
.
0
}
{
input
:
[
[
0
.
0
1
.
0
]
[
0
.
0
1
.
0
]
]
expected
:
1
.
0
}
{
input
:
[
[
1
.
0
1
.
0
]
[
1
.
0
1
.
0
]
]
expected
:
2
.
0
}
{
input
:
[
[
-
1
.
0
-
1
.
0
]
[
-
1
.
0
-
1
.
0
]
]
expected
:
2
.
0
}
{
input
:
[
[
-
1
.
0
1
.
0
]
[
1
.
0
-
1
.
0
]
]
expected
:
-
2
.
0
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
]
]
expected
:
1
.
0
}
{
input
:
[
[
0
.
0
1
.
0
0
.
0
]
[
0
.
0
1
.
0
0
.
0
]
]
expected
:
1
.
0
}
{
input
:
[
[
0
.
0
0
.
0
1
.
0
]
[
0
.
0
0
.
0
1
.
0
]
]
expected
:
1
.
0
}
{
input
:
[
[
1
.
0
1
.
0
1
.
0
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
3
.
0
}
{
input
:
[
[
-
1
.
0
-
1
.
0
-
1
.
0
]
[
-
1
.
0
-
1
.
0
-
1
.
0
]
]
expected
:
3
.
0
}
{
input
:
[
[
1
.
0
-
1
.
0
-
1
.
0
]
[
-
1
.
0
1
.
0
-
1
.
0
]
]
expected
:
-
1
.
0
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
1
.
0
}
{
input
:
[
[
0
.
0
1
.
0
0
.
0
0
.
0
]
[
0
.
0
1
.
0
0
.
0
0
.
0
]
]
expected
:
1
.
0
}
{
input
:
[
[
0
.
0
0
.
0
1
.
0
0
.
0
]
[
0
.
0
0
.
0
1
.
0
0
.
0
]
]
expected
:
1
.
0
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
1
.
0
]
[
0
.
0
0
.
0
0
.
0
1
.
0
]
]
expected
:
1
.
0
}
{
input
:
[
[
1
.
0
1
.
0
1
.
0
1
.
0
]
[
1
.
0
1
.
0
1
.
0
1
.
0
]
]
expected
:
4
.
0
}
{
input
:
[
[
-
1
.
0
-
1
.
0
-
1
.
0
-
1
.
0
]
[
-
1
.
0
-
1
.
0
-
1
.
0
-
1
.
0
]
]
expected
:
4
.
0
}
{
input
:
[
[
-
1
.
0
1
.
0
-
1
.
0
1
.
0
]
[
1
.
0
-
1
.
0
1
.
0
-
1
.
0
]
]
expected
:
-
4
.
0
}
.
.
.
kDotIntervalCases
[
p
.
trait
]
{
input
:
[
[
constants
.
positive
.
nearest_max
constants
.
positive
.
max
constants
.
negative
.
min
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
kUnboundedBounds
}
{
input
:
[
[
constants
.
positive
.
nearest_max
constants
.
negative
.
min
constants
.
positive
.
max
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
kUnboundedBounds
}
{
input
:
[
[
constants
.
positive
.
max
constants
.
positive
.
nearest_max
constants
.
negative
.
min
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
kUnboundedBounds
}
{
input
:
[
[
constants
.
negative
.
min
constants
.
positive
.
nearest_max
constants
.
positive
.
max
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
kUnboundedBounds
}
{
input
:
[
[
constants
.
positive
.
max
constants
.
negative
.
min
constants
.
positive
.
nearest_max
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
kUnboundedBounds
}
{
input
:
[
[
constants
.
negative
.
min
constants
.
positive
.
max
constants
.
positive
.
nearest_max
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
kUnboundedBounds
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
[
x
y
]
=
t
.
params
.
input
;
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
trait
.
dotInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
dotInterval
(
[
{
x
}
]
[
{
y
}
]
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
interface
VectorToVectorCase
{
input
:
number
[
]
;
expected
:
(
number
|
IntervalBounds
)
[
]
;
}
g
.
test
(
'
normalizeInterval_f32
'
)
.
paramsSubcasesOnly
<
VectorToVectorCase
>
(
[
{
input
:
[
1
.
0
0
.
0
]
expected
:
[
[
reinterpretU64AsF64
(
0x3fef_fffe_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_b000_0000n
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
]
}
{
input
:
[
0
.
0
1
.
0
]
expected
:
[
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU64AsF64
(
0x3fef_fffe_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_b000_0000n
)
]
]
}
{
input
:
[
-
1
.
0
0
.
0
]
expected
:
[
[
reinterpretU64AsF64
(
0xbff0_0000_b000_0000n
)
reinterpretU64AsF64
(
0xbfef_fffe_7000_0000n
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
]
}
{
input
:
[
1
.
0
1
.
0
]
expected
:
[
[
reinterpretU64AsF64
(
0x3fe6_a09d_5000_0000n
)
reinterpretU64AsF64
(
0x3fe6_a09f_9000_0000n
)
]
[
reinterpretU64AsF64
(
0x3fe6_a09d_5000_0000n
)
reinterpretU64AsF64
(
0x3fe6_a09f_9000_0000n
)
]
]
}
{
input
:
[
1
.
0
0
.
0
0
.
0
]
expected
:
[
[
reinterpretU64AsF64
(
0x3fef_fffe_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_b000_0000n
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
]
}
{
input
:
[
0
.
0
1
.
0
0
.
0
]
expected
:
[
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU64AsF64
(
0x3fef_fffe_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_b000_0000n
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
]
}
{
input
:
[
0
.
0
0
.
0
1
.
0
]
expected
:
[
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU64AsF64
(
0x3fef_fffe_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_b000_0000n
)
]
]
}
{
input
:
[
-
1
.
0
0
.
0
0
.
0
]
expected
:
[
[
reinterpretU64AsF64
(
0xbff0_0000_b000_0000n
)
reinterpretU64AsF64
(
0xbfef_fffe_7000_0000n
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
]
}
{
input
:
[
1
.
0
1
.
0
1
.
0
]
expected
:
[
[
reinterpretU64AsF64
(
0x3fe2_79a6_5000_0000n
)
reinterpretU64AsF64
(
0x3fe2_79a8_5000_0000n
)
]
[
reinterpretU64AsF64
(
0x3fe2_79a6_5000_0000n
)
reinterpretU64AsF64
(
0x3fe2_79a8_5000_0000n
)
]
[
reinterpretU64AsF64
(
0x3fe2_79a6_5000_0000n
)
reinterpretU64AsF64
(
0x3fe2_79a8_5000_0000n
)
]
]
}
{
input
:
[
1
.
0
0
.
0
0
.
0
0
.
0
]
expected
:
[
[
reinterpretU64AsF64
(
0x3fef_fffe_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_b000_0000n
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
]
}
{
input
:
[
0
.
0
1
.
0
0
.
0
0
.
0
]
expected
:
[
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU64AsF64
(
0x3fef_fffe_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_b000_0000n
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
]
}
{
input
:
[
0
.
0
0
.
0
1
.
0
0
.
0
]
expected
:
[
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU64AsF64
(
0x3fef_fffe_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_b000_0000n
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
]
}
{
input
:
[
0
.
0
0
.
0
0
.
0
1
.
0
]
expected
:
[
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU64AsF64
(
0x3fef_fffe_7000_0000n
)
reinterpretU64AsF64
(
0x3ff0_0000_b000_0000n
)
]
]
}
{
input
:
[
-
1
.
0
0
.
0
0
.
0
0
.
0
]
expected
:
[
[
reinterpretU64AsF64
(
0xbff0_0000_b000_0000n
)
reinterpretU64AsF64
(
0xbfef_fffe_7000_0000n
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
[
reinterpretU32AsF32
(
0x81200000
)
reinterpretU32AsF32
(
0x01200000
)
]
]
}
{
input
:
[
1
.
0
1
.
0
1
.
0
1
.
0
]
expected
:
[
[
reinterpretU64AsF64
(
0x3fdf_fffe_7000_0000n
)
reinterpretU64AsF64
(
0x3fe0_0000_b000_0000n
)
]
[
reinterpretU64AsF64
(
0x3fdf_fffe_7000_0000n
)
reinterpretU64AsF64
(
0x3fe0_0000_b000_0000n
)
]
[
reinterpretU64AsF64
(
0x3fdf_fffe_7000_0000n
)
reinterpretU64AsF64
(
0x3fe0_0000_b000_0000n
)
]
[
reinterpretU64AsF64
(
0x3fdf_fffe_7000_0000n
)
reinterpretU64AsF64
(
0x3fe0_0000_b000_0000n
)
]
]
}
]
)
.
fn
(
t
=
>
{
const
x
=
t
.
params
.
input
;
const
expected
=
FP
.
f32
.
toVector
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
normalizeInterval
(
x
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
normalizeInterval
(
[
{
x
}
]
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
interface
VectorPairToVectorCase
{
input
:
[
number
[
]
number
[
]
]
;
expected
:
(
number
|
IntervalBounds
)
[
]
;
}
g
.
test
(
'
crossInterval_f32
'
)
.
paramsSubcasesOnly
<
VectorPairToVectorCase
>
(
[
{
input
:
[
[
1
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
0
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
0
.
0
1
.
0
0
.
0
]
[
0
.
0
1
.
0
0
.
0
]
]
expected
:
[
0
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
0
.
0
0
.
0
1
.
0
]
[
0
.
0
0
.
0
1
.
0
]
]
expected
:
[
0
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
1
.
0
1
.
0
1
.
0
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
0
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
-
1
.
0
-
1
.
0
-
1
.
0
]
[
-
1
.
0
-
1
.
0
-
1
.
0
]
]
expected
:
[
0
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
0
.
1
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
0
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
kValue
.
f32
.
subnormal
.
positive
.
max
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
0
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
1
.
0
-
1
.
0
-
1
.
0
]
[
-
1
.
0
1
.
0
-
1
.
0
]
]
expected
:
[
2
.
0
2
.
0
0
.
0
]
}
{
input
:
[
[
1
.
0
2
3
]
[
1
.
0
5
.
0
7
.
0
]
]
expected
:
[
-
1
-
4
3
]
}
{
input
:
[
[
0
.
1
-
0
.
1
-
0
.
1
]
[
-
0
.
1
0
.
1
-
0
.
1
]
]
expected
:
[
[
reinterpretU32AsF32
(
0x3ca3d708
)
reinterpretU32AsF32
(
0x3ca3d70b
)
]
[
reinterpretU32AsF32
(
0x3ca3d708
)
reinterpretU32AsF32
(
0x3ca3d70b
)
]
[
reinterpretU32AsF32
(
0xb1400000
)
reinterpretU32AsF32
(
0x31400000
)
]
]
}
{
input
:
[
[
kValue
.
f32
.
subnormal
.
positive
.
max
kValue
.
f32
.
subnormal
.
negative
.
max
kValue
.
f32
.
subnormal
.
negative
.
min
]
[
kValue
.
f32
.
subnormal
.
negative
.
min
kValue
.
f32
.
subnormal
.
positive
.
min
kValue
.
f32
.
subnormal
.
negative
.
max
]
]
expected
:
[
[
0
.
0
reinterpretU32AsF32
(
0x00000002
)
]
[
0
.
0
reinterpretU32AsF32
(
0x00000002
)
]
[
reinterpretU32AsF32
(
0x80000001
)
reinterpretU32AsF32
(
0x00000001
)
]
]
}
]
)
.
fn
(
t
=
>
{
const
[
x
y
]
=
t
.
params
.
input
;
const
expected
=
FP
.
f32
.
toVector
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
crossInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
crossInterval
(
[
{
x
}
]
[
{
y
}
]
)
returned
{
got
}
.
Expected
{
expected
}
)
;
}
)
;
g
.
test
(
'
reflectInterval_f32
'
)
.
paramsSubcasesOnly
<
VectorPairToVectorCase
>
(
[
{
input
:
[
[
1
.
0
0
.
0
]
[
1
.
0
0
.
0
]
]
expected
:
[
-
1
.
0
0
.
0
]
}
{
input
:
[
[
1
.
0
0
.
0
]
[
0
.
0
1
.
0
]
]
expected
:
[
1
.
0
0
.
0
]
}
{
input
:
[
[
0
.
0
1
.
0
]
[
0
.
0
1
.
0
]
]
expected
:
[
0
.
0
-
1
.
0
]
}
{
input
:
[
[
0
.
0
1
.
0
]
[
1
.
0
0
.
0
]
]
expected
:
[
0
.
0
1
.
0
]
}
{
input
:
[
[
1
.
0
1
.
0
]
[
1
.
0
1
.
0
]
]
expected
:
[
-
3
.
0
-
3
.
0
]
}
{
input
:
[
[
-
1
.
0
-
1
.
0
]
[
1
.
0
1
.
0
]
]
expected
:
[
3
.
0
3
.
0
]
}
{
input
:
[
[
0
.
1
0
.
1
]
[
1
.
0
1
.
0
]
]
expected
:
[
[
reinterpretU32AsF32
(
0xbe99999a
)
reinterpretU32AsF32
(
0xbe999998
)
]
[
reinterpretU32AsF32
(
0xbe99999a
)
reinterpretU32AsF32
(
0xbe999998
)
]
]
}
{
input
:
[
[
kValue
.
f32
.
subnormal
.
positive
.
max
kValue
.
f32
.
subnormal
.
negative
.
max
]
[
1
.
0
1
.
0
]
]
expected
:
[
[
reinterpretU32AsF32
(
0x80fffffe
)
reinterpretU32AsF32
(
0x00800001
)
]
[
reinterpretU32AsF32
(
0x80ffffff
)
reinterpretU32AsF32
(
0x00000002
)
]
]
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
-
1
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
0
.
0
1
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
0
.
0
1
.
0
0
.
0
]
}
{
input
:
[
[
0
.
0
0
.
0
1
.
0
]
[
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
0
.
0
0
.
0
1
.
0
]
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
]
[
0
.
0
1
.
0
0
.
0
]
]
expected
:
[
1
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
]
[
0
.
0
0
.
0
1
.
0
]
]
expected
:
[
1
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
1
.
0
1
.
0
1
.
0
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
-
5
.
0
-
5
.
0
-
5
.
0
]
}
{
input
:
[
[
-
1
.
0
-
1
.
0
-
1
.
0
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
5
.
0
5
.
0
5
.
0
]
}
{
input
:
[
[
0
.
1
0
.
1
0
.
1
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
[
reinterpretU32AsF32
(
0xbf000001
)
reinterpretU32AsF32
(
0xbefffffe
)
]
[
reinterpretU32AsF32
(
0xbf000001
)
reinterpretU32AsF32
(
0xbefffffe
)
]
[
reinterpretU32AsF32
(
0xbf000001
)
reinterpretU32AsF32
(
0xbefffffe
)
]
]
}
{
input
:
[
[
kValue
.
f32
.
subnormal
.
positive
.
max
kValue
.
f32
.
subnormal
.
negative
.
max
0
.
0
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
[
reinterpretU32AsF32
(
0x80fffffe
)
reinterpretU32AsF32
(
0x00800001
)
]
[
reinterpretU32AsF32
(
0x80ffffff
)
reinterpretU32AsF32
(
0x00000002
)
]
[
reinterpretU32AsF32
(
0x80fffffe
)
reinterpretU32AsF32
(
0x00000002
)
]
]
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
-
1
.
0
0
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
0
.
0
1
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
0
.
0
1
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
0
.
0
0
.
0
1
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
0
.
0
0
.
0
1
.
0
0
.
0
]
}
{
input
:
[
[
0
.
0
0
.
0
0
.
0
1
.
0
]
[
1
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
0
.
0
0
.
0
0
.
0
1
.
0
]
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
0
.
0
]
[
0
.
0
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
1
.
0
0
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
0
.
0
]
[
0
.
0
0
.
0
1
.
0
0
.
0
]
]
expected
:
[
1
.
0
0
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
0
.
0
]
[
0
.
0
0
.
0
0
.
0
1
.
0
]
]
expected
:
[
1
.
0
0
.
0
0
.
0
0
.
0
]
}
{
input
:
[
[
-
1
.
0
-
1
.
0
-
1
.
0
-
1
.
0
]
[
1
.
0
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
7
.
0
7
.
0
7
.
0
7
.
0
]
}
{
input
:
[
[
0
.
1
0
.
1
0
.
1
0
.
1
]
[
1
.
0
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
[
reinterpretU32AsF32
(
0xbf333335
)
reinterpretU32AsF32
(
0xbf333332
)
]
[
reinterpretU32AsF32
(
0xbf333335
)
reinterpretU32AsF32
(
0xbf333332
)
]
[
reinterpretU32AsF32
(
0xbf333335
)
reinterpretU32AsF32
(
0xbf333332
)
]
[
reinterpretU32AsF32
(
0xbf333335
)
reinterpretU32AsF32
(
0xbf333332
)
]
]
}
{
input
:
[
[
kValue
.
f32
.
subnormal
.
positive
.
max
kValue
.
f32
.
subnormal
.
negative
.
max
0
.
0
0
.
0
]
[
1
.
0
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
[
reinterpretU32AsF32
(
0x80fffffe
)
reinterpretU32AsF32
(
0x00800001
)
]
[
reinterpretU32AsF32
(
0x80ffffff
)
reinterpretU32AsF32
(
0x00000002
)
]
[
reinterpretU32AsF32
(
0x80fffffe
)
reinterpretU32AsF32
(
0x00000002
)
]
[
reinterpretU32AsF32
(
0x80fffffe
)
reinterpretU32AsF32
(
0x00000002
)
]
]
}
{
input
:
[
[
kValue
.
f32
.
positive
.
nearest_max
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
negative
.
min
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
kUnboundedBounds
kUnboundedBounds
kUnboundedBounds
]
}
{
input
:
[
[
kValue
.
f32
.
positive
.
nearest_max
kValue
.
f32
.
negative
.
min
kValue
.
f32
.
positive
.
max
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
kUnboundedBounds
kUnboundedBounds
kUnboundedBounds
]
}
{
input
:
[
[
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
positive
.
nearest_max
kValue
.
f32
.
negative
.
min
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
kUnboundedBounds
kUnboundedBounds
kUnboundedBounds
]
}
{
input
:
[
[
kValue
.
f32
.
negative
.
min
kValue
.
f32
.
positive
.
nearest_max
kValue
.
f32
.
positive
.
max
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
kUnboundedBounds
kUnboundedBounds
kUnboundedBounds
]
}
{
input
:
[
[
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
negative
.
min
kValue
.
f32
.
positive
.
nearest_max
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
kUnboundedBounds
kUnboundedBounds
kUnboundedBounds
]
}
{
input
:
[
[
kValue
.
f32
.
negative
.
min
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
positive
.
nearest_max
]
[
1
.
0
1
.
0
1
.
0
]
]
expected
:
[
kUnboundedBounds
kUnboundedBounds
kUnboundedBounds
]
}
{
input
:
[
[
kValue
.
f32
.
positive
.
max
1
.
0
2
.
0
3
.
0
]
[
-
1
.
0
kValue
.
f32
.
positive
.
max
-
2
.
0
-
3
.
0
]
]
expected
:
[
kUnboundedBounds
kUnboundedBounds
kUnboundedBounds
kUnboundedBounds
]
}
]
)
.
fn
(
t
=
>
{
const
[
x
y
]
=
t
.
params
.
input
;
const
expected
=
FP
.
f32
.
toVector
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
reflectInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
reflectInterval
(
[
{
x
}
]
[
{
y
}
]
)
returned
{
JSON
.
stringify
(
got
)
}
.
Expected
{
JSON
.
stringify
(
expected
)
}
)
;
}
)
;
interface
MatrixToScalarCase
{
input
:
number
[
]
[
]
;
expected
:
number
|
IntervalBounds
;
}
g
.
test
(
'
determinantInterval_f32
'
)
.
paramsSubcasesOnly
<
MatrixToScalarCase
>
(
[
{
input
:
[
[
1
2
]
[
3
4
]
]
expected
:
-
2
}
{
input
:
[
[
-
1
2
]
[
-
3
4
]
]
expected
:
2
}
{
input
:
[
[
11
22
]
[
33
44
]
]
expected
:
-
242
}
{
input
:
[
[
5
6
]
[
8
9
]
]
expected
:
-
3
}
{
input
:
[
[
4
6
]
[
7
9
]
]
expected
:
-
6
}
{
input
:
[
[
4
5
]
[
7
8
]
]
expected
:
-
3
}
{
input
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
]
expected
:
0
}
{
input
:
[
[
-
1
2
3
]
[
-
4
5
6
]
[
-
7
8
9
]
]
expected
:
0
}
{
input
:
[
[
11
22
33
]
[
44
55
66
]
[
77
88
99
]
]
expected
:
0
}
{
input
:
[
[
4
1
-
1
]
[
-
3
0
5
]
[
5
3
2
]
]
expected
:
-
20
}
{
input
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
[
13
14
15
16
]
]
expected
:
0
}
{
input
:
[
[
4
0
0
0
]
[
3
1
-
1
3
]
[
2
-
3
3
1
]
[
2
3
3
1
]
]
expected
:
-
240
}
]
)
.
fn
(
t
=
>
{
const
input
=
t
.
params
.
input
;
const
expected
=
FP
.
f32
.
toInterval
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
determinantInterval
(
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
determinantInterval
(
[
{
JSON
.
stringify
(
input
)
}
]
)
returned
'
{
got
}
.
Expected
'
{
expected
}
'
)
;
}
)
;
interface
MatrixToMatrixCase
{
input
:
number
[
]
[
]
;
expected
:
(
number
|
IntervalBounds
)
[
]
[
]
;
}
g
.
test
(
'
transposeInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
expandWithParams
<
MatrixToMatrixCase
>
(
p
=
>
{
const
trait
=
FP
[
p
.
trait
]
;
const
constants
=
trait
.
constants
(
)
;
return
[
{
input
:
[
[
1
2
]
[
3
4
]
]
expected
:
[
[
1
3
]
[
2
4
]
]
}
{
input
:
[
[
1
2
]
[
3
4
]
[
5
6
]
]
expected
:
[
[
1
3
5
]
[
2
4
6
]
]
}
{
input
:
[
[
1
2
]
[
3
4
]
[
5
6
]
[
7
8
]
]
expected
:
[
[
1
3
5
7
]
[
2
4
6
8
]
]
}
{
input
:
[
[
1
2
3
]
[
4
5
6
]
]
expected
:
[
[
1
4
]
[
2
5
]
[
3
6
]
]
}
{
input
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
]
expected
:
[
[
1
4
7
]
[
2
5
8
]
[
3
6
9
]
]
}
{
input
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
[
10
11
12
]
]
expected
:
[
[
1
4
7
10
]
[
2
5
8
11
]
[
3
6
9
12
]
]
}
{
input
:
[
[
1
2
3
4
]
[
5
6
7
8
]
]
expected
:
[
[
1
5
]
[
2
6
]
[
3
7
]
[
4
8
]
]
}
{
input
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
]
expected
:
[
[
1
5
9
]
[
2
6
10
]
[
3
7
11
]
[
4
8
12
]
]
}
{
input
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
[
13
14
15
16
]
]
expected
:
[
[
1
5
9
13
]
[
2
6
10
14
]
[
3
7
11
15
]
[
4
8
12
16
]
]
}
{
input
:
[
[
constants
.
positive
.
subnormal
.
max
constants
.
positive
.
subnormal
.
min
]
[
constants
.
negative
.
subnormal
.
min
constants
.
negative
.
subnormal
.
max
]
]
expected
:
[
[
[
0
constants
.
positive
.
subnormal
.
max
]
[
constants
.
negative
.
subnormal
.
min
0
]
]
[
[
0
constants
.
positive
.
subnormal
.
min
]
[
constants
.
negative
.
subnormal
.
max
0
]
]
]
}
]
;
}
)
)
.
fn
(
t
=
>
{
const
input
=
t
.
params
.
input
;
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toMatrix
(
t
.
params
.
expected
)
;
const
got
=
trait
.
transposeInterval
(
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
FP
.
{
t
.
params
.
trait
}
.
transposeInterval
(
[
{
JSON
.
stringify
(
input
)
}
]
)
returned
'
[
{
JSON
.
stringify
(
got
)
}
]
'
.
Expected
'
[
{
JSON
.
stringify
(
expected
)
}
]
'
)
;
}
)
;
interface
MatrixPairToMatrixCase
{
input
:
[
number
[
]
[
]
number
[
]
[
]
]
;
expected
:
(
number
|
IntervalBounds
)
[
]
[
]
;
}
g
.
test
(
'
additionMatrixMatrixInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
combineWithParams
<
MatrixPairToMatrixCase
>
(
[
{
input
:
[
[
[
1
2
]
[
3
4
]
]
[
[
10
20
]
[
30
40
]
]
]
expected
:
[
[
11
22
]
[
33
44
]
]
}
{
input
:
[
[
[
1
2
]
[
3
4
]
[
5
6
]
]
[
[
10
20
]
[
30
40
]
[
50
60
]
]
]
expected
:
[
[
11
22
]
[
33
44
]
[
55
66
]
]
}
{
input
:
[
[
[
1
2
]
[
3
4
]
[
5
6
]
[
7
8
]
]
[
[
10
20
]
[
30
40
]
[
50
60
]
[
70
80
]
]
]
expected
:
[
[
11
22
]
[
33
44
]
[
55
66
]
[
77
88
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
]
[
[
10
20
30
]
[
40
50
60
]
]
]
expected
:
[
[
11
22
33
]
[
44
55
66
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
]
[
[
10
20
30
]
[
40
50
60
]
[
70
80
90
]
]
]
expected
:
[
[
11
22
33
]
[
44
55
66
]
[
77
88
99
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
[
10
11
12
]
]
[
[
10
20
30
]
[
40
50
60
]
[
70
80
90
]
[
1000
1100
1200
]
]
]
expected
:
[
[
11
22
33
]
[
44
55
66
]
[
77
88
99
]
[
1010
1111
1212
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
]
[
[
10
20
30
40
]
[
50
60
70
80
]
]
]
expected
:
[
[
11
22
33
44
]
[
55
66
77
88
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
]
[
[
10
20
30
40
]
[
50
60
70
80
]
[
90
1000
1100
1200
]
]
]
expected
:
[
[
11
22
33
44
]
[
55
66
77
88
]
[
99
1010
1111
1212
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
[
13
14
15
16
]
]
[
[
10
20
30
40
]
[
50
60
70
80
]
[
90
1000
1100
1200
]
[
1300
1400
1500
1600
]
]
]
expected
:
[
[
11
22
33
44
]
[
55
66
77
88
]
[
99
1010
1111
1212
]
[
1313
1414
1515
1616
]
]
}
]
)
)
.
fn
(
t
=
>
{
const
[
x
y
]
=
t
.
params
.
input
;
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toMatrix
(
t
.
params
.
expected
)
;
const
got
=
trait
.
additionMatrixMatrixInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
additionMatrixMatrixInterval
(
[
{
JSON
.
stringify
(
x
)
}
]
[
{
JSON
.
stringify
(
y
)
}
]
)
returned
'
[
{
JSON
.
stringify
(
got
)
}
]
'
.
Expected
'
[
{
JSON
.
stringify
(
expected
)
}
]
'
)
;
}
)
;
g
.
test
(
'
subtractionMatrixMatrixInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
beginSubcases
(
)
.
combineWithParams
<
MatrixPairToMatrixCase
>
(
[
{
input
:
[
[
[
1
2
]
[
3
4
]
]
[
[
-
10
-
20
]
[
-
30
-
40
]
]
]
expected
:
[
[
11
22
]
[
33
44
]
]
}
{
input
:
[
[
[
1
2
]
[
3
4
]
[
5
6
]
]
[
[
-
10
-
20
]
[
-
30
-
40
]
[
-
50
-
60
]
]
]
expected
:
[
[
11
22
]
[
33
44
]
[
55
66
]
]
}
{
input
:
[
[
[
1
2
]
[
3
4
]
[
5
6
]
[
7
8
]
]
[
[
-
10
-
20
]
[
-
30
-
40
]
[
-
50
-
60
]
[
-
70
-
80
]
]
]
expected
:
[
[
11
22
]
[
33
44
]
[
55
66
]
[
77
88
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
]
[
[
-
10
-
20
-
30
]
[
-
40
-
50
-
60
]
]
]
expected
:
[
[
11
22
33
]
[
44
55
66
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
]
[
[
-
10
-
20
-
30
]
[
-
40
-
50
-
60
]
[
-
70
-
80
-
90
]
]
]
expected
:
[
[
11
22
33
]
[
44
55
66
]
[
77
88
99
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
[
10
11
12
]
]
[
[
-
10
-
20
-
30
]
[
-
40
-
50
-
60
]
[
-
70
-
80
-
90
]
[
-
1000
-
1100
-
1200
]
]
]
expected
:
[
[
11
22
33
]
[
44
55
66
]
[
77
88
99
]
[
1010
1111
1212
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
]
[
[
-
10
-
20
-
30
-
40
]
[
-
50
-
60
-
70
-
80
]
]
]
expected
:
[
[
11
22
33
44
]
[
55
66
77
88
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
]
[
[
-
10
-
20
-
30
-
40
]
[
-
50
-
60
-
70
-
80
]
[
-
90
-
1000
-
1100
-
1200
]
]
]
expected
:
[
[
11
22
33
44
]
[
55
66
77
88
]
[
99
1010
1111
1212
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
[
13
14
15
16
]
]
[
[
-
10
-
20
-
30
-
40
]
[
-
50
-
60
-
70
-
80
]
[
-
90
-
1000
-
1100
-
1200
]
[
-
1300
-
1400
-
1500
-
1600
]
]
]
expected
:
[
[
11
22
33
44
]
[
55
66
77
88
]
[
99
1010
1111
1212
]
[
1313
1414
1515
1616
]
]
}
]
)
)
.
fn
(
t
=
>
{
const
[
x
y
]
=
t
.
params
.
input
;
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toMatrix
(
t
.
params
.
expected
)
;
const
got
=
trait
.
subtractionMatrixMatrixInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
subtractionMatrixMatrixInterval
(
[
{
JSON
.
stringify
(
x
)
}
]
[
{
JSON
.
stringify
(
y
)
}
]
)
returned
'
[
{
JSON
.
stringify
(
got
)
}
]
'
.
Expected
'
[
{
JSON
.
stringify
(
expected
)
}
]
'
)
;
}
)
;
g
.
test
(
'
multiplicationMatrixMatrixInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
combineWithParams
<
MatrixPairToMatrixCase
>
(
[
{
input
:
[
[
[
1
2
]
[
3
4
]
]
[
[
11
22
]
[
33
44
]
]
]
expected
:
[
[
77
110
]
[
165
242
]
]
}
{
input
:
[
[
[
1
2
]
[
3
4
]
]
[
[
11
22
]
[
33
44
]
[
55
66
]
]
]
expected
:
[
[
77
110
]
[
165
242
]
[
253
374
]
]
}
{
input
:
[
[
[
1
2
]
[
3
4
]
]
[
[
11
22
]
[
33
44
]
[
55
66
]
[
77
88
]
]
]
expected
:
[
[
77
110
]
[
165
242
]
[
253
374
]
[
341
506
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
]
[
[
11
22
]
[
33
44
]
]
]
expected
:
[
[
99
132
165
]
[
209
286
363
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
]
[
[
11
22
]
[
33
44
]
[
55
66
]
]
]
expected
:
[
[
99
132
165
]
[
209
286
363
]
[
319
440
561
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
]
[
[
11
22
]
[
33
44
]
[
55
66
]
[
77
88
]
]
]
expected
:
[
[
99
132
165
]
[
209
286
363
]
[
319
440
561
]
[
429
594
759
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
]
[
[
11
22
]
[
33
44
]
]
]
expected
:
[
[
121
154
187
220
]
[
253
330
407
484
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
]
[
[
11
22
]
[
33
44
]
[
55
66
]
]
]
expected
:
[
[
121
154
187
220
]
[
253
330
407
484
]
[
385
506
627
748
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
]
[
[
11
22
]
[
33
44
]
[
55
66
]
[
77
88
]
]
]
expected
:
[
[
121
154
187
220
]
[
253
330
407
484
]
[
385
506
627
748
]
[
517
682
847
1012
]
]
}
{
input
:
[
[
[
1
2
]
[
3
4
]
[
5
6
]
]
[
[
11
22
33
]
[
44
55
66
]
]
]
expected
:
[
[
242
308
]
[
539
704
]
]
}
{
input
:
[
[
[
1
2
]
[
3
4
]
[
5
6
]
]
[
[
11
22
33
]
[
44
55
66
]
[
77
88
99
]
]
]
expected
:
[
[
242
308
]
[
539
704
]
[
836
1100
]
]
}
{
input
:
[
[
[
1
2
]
[
3
4
]
[
5
6
]
]
[
[
11
22
33
]
[
44
55
66
]
[
77
88
99
]
[
10
11
12
]
]
]
expected
:
[
[
242
308
]
[
539
704
]
[
836
1100
]
[
103
136
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
]
[
[
11
22
33
]
[
44
55
66
]
]
]
expected
:
[
[
330
396
462
]
[
726
891
1056
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
]
[
[
11
22
33
]
[
44
55
66
]
[
77
88
99
]
]
]
expected
:
[
[
330
396
462
]
[
726
891
1056
]
[
1122
1386
1650
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
]
[
[
11
22
33
]
[
44
55
66
]
[
77
88
99
]
[
10
11
12
]
]
]
expected
:
[
[
330
396
462
]
[
726
891
1056
]
[
1122
1386
1650
]
[
138
171
204
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
]
[
[
11
12
13
]
[
21
22
23
]
]
]
expected
:
[
[
188
224
260
296
]
[
338
404
470
536
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
]
[
[
11
12
13
]
[
21
22
23
]
[
31
32
33
]
]
]
expected
:
[
[
188
224
260
296
]
[
338
404
470
536
]
[
488
584
680
776
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
]
[
[
11
12
13
]
[
21
22
23
]
[
31
32
33
]
[
41
42
43
]
]
]
expected
:
[
[
188
224
260
296
]
[
338
404
470
536
]
[
488
584
680
776
]
[
638
764
890
1016
]
]
}
{
input
:
[
[
[
1
2
]
[
3
4
]
[
5
6
]
[
7
8
]
]
[
[
11
22
33
44
]
[
55
66
77
88
]
]
]
expected
:
[
[
550
660
]
[
1254
1540
]
]
}
{
input
:
[
[
[
1
2
]
[
3
4
]
[
5
6
]
[
7
8
]
]
[
[
11
12
13
14
]
[
21
22
23
24
]
[
31
32
33
34
]
]
]
expected
:
[
[
210
260
]
[
370
460
]
[
530
660
]
]
}
{
input
:
[
[
[
1
2
]
[
3
4
]
[
5
6
]
[
7
8
]
]
[
[
11
12
13
14
]
[
21
22
23
24
]
[
31
32
33
34
]
[
41
42
43
44
]
]
]
expected
:
[
[
210
260
]
[
370
460
]
[
530
660
]
[
690
860
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
[
10
11
12
]
]
[
[
11
12
13
14
]
[
21
22
23
24
]
]
]
expected
:
[
[
290
340
390
]
[
510
600
690
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
[
10
11
12
]
]
[
[
11
12
13
14
]
[
21
22
23
24
]
[
31
32
33
34
]
]
]
expected
:
[
[
290
340
390
]
[
510
600
690
]
[
730
860
990
]
]
}
{
input
:
[
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
[
10
11
12
]
]
[
[
11
12
13
14
]
[
21
22
23
24
]
[
31
32
33
34
]
[
41
42
43
44
]
]
]
expected
:
[
[
290
340
390
]
[
510
600
690
]
[
730
860
990
]
[
950
1120
1290
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
[
13
14
15
16
]
]
[
[
11
12
13
14
]
[
21
22
23
24
]
]
]
expected
:
[
[
370
420
470
520
]
[
650
740
830
920
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
[
13
14
15
16
]
]
[
[
11
12
13
14
]
[
21
22
23
24
]
[
31
32
33
34
]
]
]
expected
:
[
[
370
420
470
520
]
[
650
740
830
920
]
[
930
1060
1190
1320
]
]
}
{
input
:
[
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
[
13
14
15
16
]
]
[
[
11
12
13
14
]
[
21
22
23
24
]
[
31
32
33
34
]
[
41
42
43
44
]
]
]
expected
:
[
[
370
420
470
520
]
[
650
740
830
920
]
[
930
1060
1190
1320
]
[
1210
1380
1550
1720
]
]
}
]
)
)
.
fn
(
t
=
>
{
const
[
x
y
]
=
t
.
params
.
input
;
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toMatrix
(
t
.
params
.
expected
)
;
const
got
=
trait
.
multiplicationMatrixMatrixInterval
(
x
y
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
multiplicationMatrixMatrixInterval
(
[
{
JSON
.
stringify
(
x
)
}
]
[
{
JSON
.
stringify
(
y
)
}
]
)
returned
'
[
{
JSON
.
stringify
(
got
)
}
]
'
.
Expected
'
[
{
JSON
.
stringify
(
expected
)
}
]
'
)
;
}
)
;
interface
MatrixScalarToMatrixCase
{
matrix
:
number
[
]
[
]
;
scalar
:
number
;
expected
:
(
number
|
IntervalBounds
)
[
]
[
]
;
}
g
.
test
(
'
multiplicationMatrixScalarInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
combineWithParams
<
MatrixScalarToMatrixCase
>
(
[
{
matrix
:
[
[
1
2
]
[
3
4
]
]
scalar
:
10
expected
:
[
[
10
20
]
[
30
40
]
]
}
{
matrix
:
[
[
1
2
]
[
3
4
]
[
5
6
]
]
scalar
:
10
expected
:
[
[
10
20
]
[
30
40
]
[
50
60
]
]
}
{
matrix
:
[
[
1
2
]
[
3
4
]
[
5
6
]
[
7
8
]
]
scalar
:
10
expected
:
[
[
10
20
]
[
30
40
]
[
50
60
]
[
70
80
]
]
}
{
matrix
:
[
[
1
2
3
]
[
4
5
6
]
]
scalar
:
10
expected
:
[
[
10
20
30
]
[
40
50
60
]
]
}
{
matrix
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
]
scalar
:
10
expected
:
[
[
10
20
30
]
[
40
50
60
]
[
70
80
90
]
]
}
{
matrix
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
[
10
11
12
]
]
scalar
:
10
expected
:
[
[
10
20
30
]
[
40
50
60
]
[
70
80
90
]
[
100
110
120
]
]
}
{
matrix
:
[
[
1
2
3
4
]
[
5
6
7
8
]
]
scalar
:
10
expected
:
[
[
10
20
30
40
]
[
50
60
70
80
]
]
}
{
matrix
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
]
scalar
:
10
expected
:
[
[
10
20
30
40
]
[
50
60
70
80
]
[
90
100
110
120
]
]
}
{
matrix
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
[
13
14
15
16
]
]
scalar
:
10
expected
:
[
[
10
20
30
40
]
[
50
60
70
80
]
[
90
100
110
120
]
[
130
140
150
160
]
]
}
]
)
)
.
fn
(
t
=
>
{
const
matrix
=
t
.
params
.
matrix
;
const
scalar
=
t
.
params
.
scalar
;
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toMatrix
(
t
.
params
.
expected
)
;
const
got
=
trait
.
multiplicationMatrixScalarInterval
(
matrix
scalar
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
multiplicationMatrixScalarInterval
(
[
{
JSON
.
stringify
(
matrix
)
}
]
{
scalar
}
)
returned
'
[
{
JSON
.
stringify
(
got
)
}
]
'
.
Expected
'
[
{
JSON
.
stringify
(
expected
)
}
]
'
)
;
}
)
;
interface
MatrixVectorToVectorCase
{
matrix
:
number
[
]
[
]
;
vector
:
number
[
]
;
expected
:
(
number
|
IntervalBounds
)
[
]
;
}
g
.
test
(
'
multiplicationMatrixVectorInterval
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
combineWithParams
<
MatrixVectorToVectorCase
>
(
[
{
matrix
:
[
[
1
2
]
[
3
4
]
]
vector
:
[
11
22
]
expected
:
[
77
110
]
}
{
matrix
:
[
[
1
2
3
]
[
4
5
6
]
]
vector
:
[
11
22
]
expected
:
[
99
132
165
]
}
{
matrix
:
[
[
1
2
3
4
]
[
5
6
7
8
]
]
vector
:
[
11
22
]
expected
:
[
121
154
187
220
]
}
{
matrix
:
[
[
1
2
]
[
3
4
]
[
5
6
]
]
vector
:
[
11
22
33
]
expected
:
[
242
308
]
}
{
matrix
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
]
vector
:
[
11
22
33
]
expected
:
[
330
396
462
]
}
{
matrix
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
]
vector
:
[
11
22
33
]
expected
:
[
418
484
550
616
]
}
{
matrix
:
[
[
1
2
]
[
3
4
]
[
5
6
]
[
7
8
]
]
vector
:
[
11
22
33
44
]
expected
:
[
550
660
]
}
{
matrix
:
[
[
1
2
3
]
[
4
5
6
]
[
7
8
9
]
[
10
11
12
]
]
vector
:
[
11
22
33
44
]
expected
:
[
770
880
990
]
}
{
matrix
:
[
[
1
2
3
4
]
[
5
6
7
8
]
[
9
10
11
12
]
[
13
14
15
16
]
]
vector
:
[
11
22
33
44
]
expected
:
[
990
1100
1210
1320
]
}
]
)
)
.
fn
(
t
=
>
{
const
matrix
=
t
.
params
.
matrix
;
const
vector
=
t
.
params
.
vector
;
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toVector
(
t
.
params
.
expected
)
;
const
got
=
trait
.
multiplicationMatrixVectorInterval
(
matrix
vector
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
multiplicationMatrixVectorInterval
(
[
{
JSON
.
stringify
(
matrix
)
}
]
[
{
JSON
.
stringify
(
vector
)
}
]
)
returned
'
[
{
JSON
.
stringify
(
got
)
}
]
'
.
Expected
'
[
{
JSON
.
stringify
(
expected
)
}
]
'
)
;
}
)
;
interface
VectorMatrixToVectorCase
{
vector
:
number
[
]
;
matrix
:
number
[
]
[
]
;
expected
:
(
number
|
IntervalBounds
)
[
]
;
}
g
.
test
(
'
multiplicationVectorMatrixInterval_f32
'
)
.
params
(
u
=
>
u
.
combine
(
'
trait
'
[
'
f32
'
'
f16
'
]
as
const
)
.
beginSubcases
(
)
.
combineWithParams
<
VectorMatrixToVectorCase
>
(
[
{
vector
:
[
1
2
]
matrix
:
[
[
11
22
]
[
33
44
]
]
expected
:
[
55
121
]
}
{
vector
:
[
1
2
]
matrix
:
[
[
11
22
]
[
33
44
]
[
55
66
]
]
expected
:
[
55
121
187
]
}
{
vector
:
[
1
2
]
matrix
:
[
[
11
22
]
[
33
44
]
[
55
66
]
[
77
88
]
]
expected
:
[
55
121
187
253
]
}
{
vector
:
[
1
2
3
]
matrix
:
[
[
11
12
13
]
[
21
22
23
]
]
expected
:
[
74
134
]
}
{
vector
:
[
1
2
3
]
matrix
:
[
[
11
12
13
]
[
21
22
23
]
[
31
32
33
]
]
expected
:
[
74
134
194
]
}
{
vector
:
[
1
2
3
]
matrix
:
[
[
11
12
13
]
[
21
22
23
]
[
31
32
33
]
[
41
42
43
]
]
expected
:
[
74
134
194
254
]
}
{
vector
:
[
1
2
3
4
]
matrix
:
[
[
11
12
13
14
]
[
21
22
23
24
]
]
expected
:
[
130
230
]
}
{
vector
:
[
1
2
3
4
]
matrix
:
[
[
11
12
13
14
]
[
21
22
23
24
]
[
31
32
33
34
]
]
expected
:
[
130
230
330
]
}
{
vector
:
[
1
2
3
4
]
matrix
:
[
[
11
12
13
14
]
[
21
22
23
24
]
[
31
32
33
34
]
[
41
42
43
44
]
]
expected
:
[
130
230
330
430
]
}
]
)
)
.
fn
(
t
=
>
{
const
vector
=
t
.
params
.
vector
;
const
matrix
=
t
.
params
.
matrix
;
const
trait
=
FP
[
t
.
params
.
trait
]
;
const
expected
=
trait
.
toVector
(
t
.
params
.
expected
)
;
const
got
=
trait
.
multiplicationVectorMatrixInterval
(
vector
matrix
)
;
t
.
expect
(
objectEquals
(
expected
got
)
{
t
.
params
.
trait
}
.
multiplicationVectorMatrixInterval
(
[
{
JSON
.
stringify
(
vector
)
}
]
[
{
JSON
.
stringify
(
matrix
)
}
]
)
returned
'
[
{
JSON
.
stringify
(
got
)
}
]
'
.
Expected
'
[
{
JSON
.
stringify
(
expected
)
}
]
'
)
;
}
)
;
interface
FaceForwardCase
{
input
:
[
number
[
]
number
[
]
number
[
]
]
;
expected
:
(
(
number
|
IntervalBounds
)
[
]
|
undefined
)
[
]
;
}
g
.
test
(
'
faceForwardIntervals_f32
'
)
.
paramsSubcasesOnly
<
FaceForwardCase
>
(
[
{
input
:
[
[
1
.
0
0
.
0
]
[
1
.
0
0
.
0
]
[
1
.
0
0
.
0
]
]
expected
:
[
[
-
1
.
0
0
.
0
]
]
}
{
input
:
[
[
-
1
.
0
0
.
0
]
[
1
.
0
0
.
0
]
[
1
.
0
0
.
0
]
]
expected
:
[
[
1
.
0
0
.
0
]
]
}
{
input
:
[
[
1
.
0
0
.
0
]
[
-
1
.
0
1
.
0
]
[
1
.
0
-
1
.
0
]
]
expected
:
[
[
1
.
0
0
.
0
]
]
}
{
input
:
[
[
-
1
.
0
0
.
0
]
[
-
1
.
0
1
.
0
]
[
1
.
0
-
1
.
0
]
]
expected
:
[
[
-
1
.
0
0
.
0
]
]
}
{
input
:
[
[
10
.
0
0
.
0
]
[
10
.
0
0
.
0
]
[
10
.
0
0
.
0
]
]
expected
:
[
[
-
10
.
0
0
.
0
]
]
}
{
input
:
[
[
-
10
.
0
0
.
0
]
[
10
.
0
0
.
0
]
[
10
.
0
0
.
0
]
]
expected
:
[
[
10
.
0
0
.
0
]
]
}
{
input
:
[
[
10
.
0
0
.
0
]
[
-
10
.
0
10
.
0
]
[
10
.
0
-
10
.
0
]
]
expected
:
[
[
10
.
0
0
.
0
]
]
}
{
input
:
[
[
-
10
.
0
0
.
0
]
[
-
10
.
0
10
.
0
]
[
10
.
0
-
10
.
0
]
]
expected
:
[
[
-
10
.
0
0
.
0
]
]
}
{
input
:
[
[
0
.
1
0
.
0
]
[
0
.
1
0
.
0
]
[
0
.
1
0
.
0
]
]
expected
:
[
[
[
reinterpretU32AsF32
(
0xbdcccccd
)
reinterpretU32AsF32
(
0xbdcccccc
)
]
0
.
0
]
]
}
{
input
:
[
[
-
0
.
1
0
.
0
]
[
0
.
1
0
.
0
]
[
0
.
1
0
.
0
]
]
expected
:
[
[
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
0
.
0
]
]
}
{
input
:
[
[
0
.
1
0
.
0
]
[
-
0
.
1
0
.
1
]
[
0
.
1
-
0
.
1
]
]
expected
:
[
[
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
0
.
0
]
]
}
{
input
:
[
[
-
0
.
1
0
.
0
]
[
-
0
.
1
0
.
1
]
[
0
.
1
-
0
.
1
]
]
expected
:
[
[
[
reinterpretU32AsF32
(
0xbdcccccd
)
reinterpretU32AsF32
(
0xbdcccccc
)
]
0
.
0
]
]
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
-
1
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
-
1
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
1
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
]
[
-
1
.
0
1
.
0
0
.
0
]
[
1
.
0
-
1
.
0
0
.
0
]
]
expected
:
[
[
1
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
-
1
.
0
0
.
0
0
.
0
]
[
-
1
.
0
1
.
0
0
.
0
]
[
1
.
0
-
1
.
0
0
.
0
]
]
expected
:
[
[
-
1
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
10
.
0
0
.
0
0
.
0
]
[
10
.
0
0
.
0
0
.
0
]
[
10
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
-
10
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
-
10
.
0
0
.
0
0
.
0
]
[
10
.
0
0
.
0
0
.
0
]
[
10
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
10
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
10
.
0
0
.
0
0
.
0
]
[
-
10
.
0
10
.
0
0
.
0
]
[
10
.
0
-
10
.
0
0
.
0
]
]
expected
:
[
[
10
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
-
10
.
0
0
.
0
0
.
0
]
[
-
10
.
0
10
.
0
0
.
0
]
[
10
.
0
-
10
.
0
0
.
0
]
]
expected
:
[
[
-
10
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
0
.
1
0
.
0
0
.
0
]
[
0
.
1
0
.
0
0
.
0
]
[
0
.
1
0
.
0
0
.
0
]
]
expected
:
[
[
[
reinterpretU32AsF32
(
0xbdcccccd
)
reinterpretU32AsF32
(
0xbdcccccc
)
]
0
.
0
0
.
0
]
]
}
{
input
:
[
[
-
0
.
1
0
.
0
0
.
0
]
[
0
.
1
0
.
0
0
.
0
]
[
0
.
1
0
.
0
0
.
0
]
]
expected
:
[
[
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
0
.
0
0
.
0
]
]
}
{
input
:
[
[
0
.
1
0
.
0
0
.
0
]
[
-
0
.
1
0
.
0
0
.
0
]
[
0
.
1
-
0
.
0
0
.
0
]
]
expected
:
[
[
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
0
.
0
0
.
0
]
]
}
{
input
:
[
[
-
0
.
1
0
.
0
0
.
0
]
[
-
0
.
1
0
.
0
0
.
0
]
[
0
.
1
-
0
.
0
0
.
0
]
]
expected
:
[
[
[
reinterpretU32AsF32
(
0xbdcccccd
)
reinterpretU32AsF32
(
0xbdcccccc
)
]
0
.
0
0
.
0
]
]
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
-
1
.
0
0
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
-
1
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
1
.
0
0
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
1
.
0
0
.
0
0
.
0
0
.
0
]
[
-
1
.
0
1
.
0
0
.
0
0
.
0
]
[
1
.
0
-
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
1
.
0
0
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
-
1
.
0
0
.
0
0
.
0
0
.
0
]
[
-
1
.
0
1
.
0
0
.
0
0
.
0
]
[
1
.
0
-
1
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
-
1
.
0
0
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
10
.
0
0
.
0
0
.
0
0
.
0
]
[
10
.
0
0
.
0
0
.
0
0
.
0
]
[
10
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
-
10
.
0
0
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
-
10
.
0
0
.
0
0
.
0
0
.
0
]
[
10
.
0
0
.
0
0
.
0
0
.
0
]
[
10
.
0
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
10
.
0
0
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
10
.
0
0
.
0
0
.
0
0
.
0
]
[
-
10
.
0
10
.
0
0
.
0
0
.
0
]
[
10
.
0
-
10
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
10
.
0
0
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
-
10
.
0
0
.
0
0
.
0
0
.
0
]
[
-
10
.
0
10
.
0
0
.
0
0
.
0
]
[
10
.
0
-
10
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
-
10
.
0
0
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
0
.
1
0
.
0
0
.
0
0
.
0
]
[
0
.
1
0
.
0
0
.
0
0
.
0
]
[
0
.
1
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
[
reinterpretU32AsF32
(
0xbdcccccd
)
reinterpretU32AsF32
(
0xbdcccccc
)
]
0
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
-
0
.
1
0
.
0
0
.
0
0
.
0
]
[
0
.
1
0
.
0
0
.
0
0
.
0
]
[
0
.
1
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
0
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
0
.
1
0
.
0
0
.
0
0
.
0
]
[
-
0
.
1
0
.
0
0
.
0
0
.
0
]
[
0
.
1
-
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
[
reinterpretU32AsF32
(
0x3dcccccc
)
reinterpretU32AsF32
(
0x3dcccccd
)
]
0
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
-
0
.
1
0
.
0
0
.
0
0
.
0
]
[
-
0
.
1
0
.
0
0
.
0
0
.
0
]
[
0
.
1
-
0
.
0
0
.
0
0
.
0
]
]
expected
:
[
[
[
reinterpretU32AsF32
(
0xbdcccccd
)
reinterpretU32AsF32
(
0xbdcccccc
)
]
0
.
0
0
.
0
0
.
0
]
]
}
{
input
:
[
[
1
.
0
1
.
0
]
[
1
.
0
0
.
0
]
[
0
.
0
1
.
0
]
]
expected
:
[
[
-
1
.
0
-
1
.
0
]
]
}
{
input
:
[
[
kValue
.
f32
.
subnormal
.
positive
.
max
0
.
0
]
[
kValue
.
f32
.
subnormal
.
positive
.
min
0
.
0
]
[
kValue
.
f32
.
subnormal
.
negative
.
min
0
.
0
]
]
expected
:
[
[
[
0
.
0
kValue
.
f32
.
subnormal
.
positive
.
max
]
0
.
0
]
[
[
kValue
.
f32
.
subnormal
.
negative
.
min
0
]
0
.
0
]
]
}
{
input
:
[
[
1
.
0
1
.
0
]
[
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
positive
.
max
]
[
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
positive
.
max
]
]
expected
:
[
undefined
[
1
1
]
[
-
1
-
1
]
]
}
]
)
.
fn
(
t
=
>
{
const
[
x
y
z
]
=
t
.
params
.
input
;
const
expected
=
t
.
params
.
expected
.
map
(
e
=
>
(
e
!
=
=
undefined
?
FP
.
f32
.
toVector
(
e
)
:
undefined
)
)
;
const
got
=
FP
.
f32
.
faceForwardIntervals
(
x
y
z
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
faceForwardInterval
(
[
{
x
}
]
[
{
y
}
]
[
{
z
}
]
)
returned
[
{
got
}
]
.
Expected
[
{
expected
}
]
)
;
}
)
;
interface
ModfCase
{
input
:
number
;
fract
:
number
|
IntervalBounds
;
whole
:
number
|
IntervalBounds
;
}
g
.
test
(
'
modfInterval_f32
'
)
.
paramsSubcasesOnly
<
ModfCase
>
(
[
{
input
:
0
fract
:
0
whole
:
0
}
{
input
:
1
fract
:
0
whole
:
1
}
{
input
:
-
1
fract
:
0
whole
:
-
1
}
{
input
:
0
.
5
fract
:
0
.
5
whole
:
0
}
{
input
:
-
0
.
5
fract
:
-
0
.
5
whole
:
0
}
{
input
:
2
.
5
fract
:
0
.
5
whole
:
2
}
{
input
:
-
2
.
5
fract
:
-
0
.
5
whole
:
-
2
}
{
input
:
10
.
0
fract
:
0
whole
:
10
}
{
input
:
-
10
.
0
fract
:
0
whole
:
-
10
}
{
input
:
kValue
.
f32
.
subnormal
.
negative
.
min
fract
:
[
kValue
.
f32
.
subnormal
.
negative
.
min
0
]
whole
:
0
}
{
input
:
kValue
.
f32
.
subnormal
.
negative
.
max
fract
:
[
kValue
.
f32
.
subnormal
.
negative
.
max
0
]
whole
:
0
}
{
input
:
kValue
.
f32
.
subnormal
.
positive
.
min
fract
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
min
]
whole
:
0
}
{
input
:
kValue
.
f32
.
subnormal
.
positive
.
max
fract
:
[
0
kValue
.
f32
.
subnormal
.
positive
.
max
]
whole
:
0
}
{
input
:
kValue
.
f32
.
negative
.
min
fract
:
0
whole
:
kValue
.
f32
.
negative
.
min
}
{
input
:
kValue
.
f32
.
negative
.
max
fract
:
kValue
.
f32
.
negative
.
max
whole
:
0
}
{
input
:
kValue
.
f32
.
positive
.
min
fract
:
kValue
.
f32
.
positive
.
min
whole
:
0
}
{
input
:
kValue
.
f32
.
positive
.
max
fract
:
0
whole
:
kValue
.
f32
.
positive
.
max
}
]
)
.
fn
(
t
=
>
{
const
expected
=
{
fract
:
FP
.
f32
.
toInterval
(
t
.
params
.
fract
)
whole
:
FP
.
f32
.
toInterval
(
t
.
params
.
whole
)
}
;
const
got
=
FP
.
f32
.
modfInterval
(
t
.
params
.
input
)
;
t
.
expect
(
objectEquals
(
expected
got
)
f32
.
modfInterval
(
[
{
t
.
params
.
input
}
)
returned
{
fract
:
[
{
got
.
fract
}
]
whole
:
[
{
got
.
whole
}
]
}
.
Expected
{
fract
:
[
{
expected
.
fract
}
]
whole
:
[
{
expected
.
whole
}
]
}
)
;
}
)
;
interface
RefractCase
{
input
:
[
number
[
]
number
[
]
number
]
;
expected
:
(
number
|
IntervalBounds
)
[
]
;
}
{
const
kNegativeOneBounds
:
IntervalBounds
=
[
reinterpretU64AsF64
(
0xbff0_0000_c000_0000n
)
reinterpretU64AsF64
(
0xbfef_ffff_4000_0000n
)
]
;
g
.
test
(
'
refractInterval_f32
'
)
.
paramsSubcasesOnly
<
RefractCase
>
(
[
{
input
:
[
[
1
1
]
[
0
.
1
0
]
10
]
expected
:
[
0
0
]
}
{
input
:
[
[
1
1
]
[
0
.
1
0
]
1
.
005038
]
expected
:
[
kUnboundedBounds
kUnboundedBounds
]
}
{
input
:
[
[
1
1
]
[
1
0
]
1
]
expected
:
[
kNegativeOneBounds
1
]
}
{
input
:
[
[
1
-
2
]
[
3
4
]
5
]
expected
:
[
[
reinterpretU32AsF32
(
0x40ce87a4
)
reinterpretU32AsF32
(
0x40ce8840
)
]
[
reinterpretU32AsF32
(
0xc100fae8
)
reinterpretU32AsF32
(
0xc100fa80
)
]
]
}
{
input
:
[
[
1
1
1
]
[
1
0
0
]
1
]
expected
:
[
kNegativeOneBounds
1
1
]
}
{
input
:
[
[
1
-
2
3
]
[
-
4
5
-
6
]
7
]
expected
:
[
[
reinterpretU32AsF32
(
0x40d24480
)
reinterpretU32AsF32
(
0x40d24c00
)
]
[
reinterpretU32AsF32
(
0xc1576f80
)
reinterpretU32AsF32
(
0xc1576ad0
)
]
[
reinterpretU32AsF32
(
0x41a2d9b0
)
reinterpretU32AsF32
(
0x41a2dc80
)
]
]
}
{
input
:
[
[
1
1
1
1
]
[
1
0
0
0
]
1
]
expected
:
[
kNegativeOneBounds
1
1
1
]
}
{
input
:
[
[
1
-
2
3
-
4
]
[
-
5
6
-
7
8
]
9
]
expected
:
[
[
reinterpretU32AsF32
(
0x410ae480
)
reinterpretU32AsF32
(
0x410af240
)
]
[
reinterpretU32AsF32
(
0xc18cf7c0
)
reinterpretU32AsF32
(
0xc18cef80
)
]
[
reinterpretU32AsF32
(
0x41d46cc0
)
reinterpretU32AsF32
(
0x41d47660
)
]
[
reinterpretU32AsF32
(
0xc20dfa80
)
reinterpretU32AsF32
(
0xc20df500
)
]
]
}
{
input
:
[
[
kValue
.
f32
.
positive
.
nearest_max
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
negative
.
min
]
[
1
.
0
1
.
0
1
.
0
]
1
]
expected
:
[
kUnboundedBounds
kUnboundedBounds
kUnboundedBounds
]
}
{
input
:
[
[
kValue
.
f32
.
positive
.
nearest_max
kValue
.
f32
.
negative
.
min
kValue
.
f32
.
positive
.
max
]
[
1
.
0
1
.
0
1
.
0
]
1
]
expected
:
[
kUnboundedBounds
kUnboundedBounds
kUnboundedBounds
]
}
{
input
:
[
[
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
positive
.
nearest_max
kValue
.
f32
.
negative
.
min
]
[
1
.
0
1
.
0
1
.
0
]
1
]
expected
:
[
kUnboundedBounds
kUnboundedBounds
kUnboundedBounds
]
}
{
input
:
[
[
kValue
.
f32
.
negative
.
min
kValue
.
f32
.
positive
.
nearest_max
kValue
.
f32
.
positive
.
max
]
[
1
.
0
1
.
0
1
.
0
]
1
]
expected
:
[
kUnboundedBounds
kUnboundedBounds
kUnboundedBounds
]
}
{
input
:
[
[
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
negative
.
min
kValue
.
f32
.
positive
.
nearest_max
]
[
1
.
0
1
.
0
1
.
0
]
1
]
expected
:
[
kUnboundedBounds
kUnboundedBounds
kUnboundedBounds
]
}
{
input
:
[
[
kValue
.
f32
.
negative
.
min
kValue
.
f32
.
positive
.
max
kValue
.
f32
.
positive
.
nearest_max
]
[
1
.
0
1
.
0
1
.
0
]
1
]
expected
:
[
kUnboundedBounds
kUnboundedBounds
kUnboundedBounds
]
}
]
)
.
fn
(
t
=
>
{
const
[
i
s
r
]
=
t
.
params
.
input
;
const
expected
=
FP
.
f32
.
toVector
(
t
.
params
.
expected
)
;
const
got
=
FP
.
f32
.
refractInterval
(
i
s
r
)
;
t
.
expect
(
objectEquals
(
expected
got
)
refractIntervals
(
[
{
i
}
]
[
{
s
}
]
{
r
}
)
returned
[
{
got
}
]
.
Expected
[
{
expected
}
]
)
;
}
)
;
}
