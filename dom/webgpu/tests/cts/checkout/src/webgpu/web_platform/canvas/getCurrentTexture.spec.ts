export
const
description
=
Tests
for
GPUCanvasContext
.
getCurrentTexture
.
;
import
{
SkipTestCase
}
from
'
.
.
/
.
.
/
.
.
/
common
/
framework
/
fixture
.
js
'
;
import
{
makeTestGroup
}
from
'
.
.
/
.
.
/
.
.
/
common
/
framework
/
test_group
.
js
'
;
import
{
assert
unreachable
}
from
'
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
GPUTest
}
from
'
.
.
/
.
.
/
gpu_test
.
js
'
;
import
{
kAllCanvasTypes
createCanvas
CanvasType
}
from
'
.
.
/
.
.
/
util
/
create_elements
.
js
'
;
class
GPUContextTest
extends
GPUTest
{
initCanvasContext
(
canvasType
:
CanvasType
=
'
onscreen
'
)
:
GPUCanvasContext
{
const
canvas
=
createCanvas
(
this
canvasType
2
2
)
;
const
ctx
=
canvas
.
getContext
(
'
webgpu
'
)
;
assert
(
ctx
instanceof
GPUCanvasContext
'
Failed
to
get
WebGPU
context
from
canvas
'
)
;
ctx
.
configure
(
{
device
:
this
.
device
format
:
'
rgba8unorm
'
usage
:
GPUTextureUsage
.
RENDER_ATTACHMENT
|
GPUTextureUsage
.
COPY_SRC
}
)
;
return
ctx
;
}
}
export
const
g
=
makeTestGroup
(
GPUContextTest
)
;
g
.
test
(
'
configured
'
)
.
desc
(
Checks
that
calling
getCurrentTexture
requires
the
context
to
be
configured
first
and
that
each
call
to
configure
causes
getCurrentTexture
to
return
a
new
texture
.
)
.
params
(
u
=
>
u
.
combine
(
'
canvasType
'
kAllCanvasTypes
)
)
.
fn
(
async
t
=
>
{
const
canvas
=
createCanvas
(
t
t
.
params
.
canvasType
2
2
)
;
const
ctx
=
canvas
.
getContext
(
'
webgpu
'
)
;
assert
(
ctx
instanceof
GPUCanvasContext
'
Failed
to
get
WebGPU
context
from
canvas
'
)
;
t
.
shouldThrow
(
true
(
)
=
>
{
ctx
.
getCurrentTexture
(
)
;
}
)
;
ctx
.
configure
(
{
device
:
t
.
device
format
:
'
rgba8unorm
'
}
)
;
let
prevTexture
=
ctx
.
getCurrentTexture
(
)
;
ctx
.
configure
(
{
device
:
t
.
device
format
:
'
bgra8unorm
'
}
)
;
let
currentTexture
=
ctx
.
getCurrentTexture
(
)
;
t
.
expect
(
prevTexture
!
=
=
currentTexture
)
;
prevTexture
=
currentTexture
;
ctx
.
configure
(
{
device
:
t
.
device
format
:
'
bgra8unorm
'
}
)
;
currentTexture
=
ctx
.
getCurrentTexture
(
)
;
t
.
expect
(
prevTexture
!
=
=
currentTexture
)
;
prevTexture
=
currentTexture
;
ctx
.
unconfigure
(
)
;
t
.
shouldThrow
(
true
(
)
=
>
{
ctx
.
getCurrentTexture
(
)
;
}
)
;
}
)
;
g
.
test
(
'
single_frames
'
)
.
desc
(
Checks
that
the
value
of
getCurrentTexture
is
consistent
within
a
single
frame
.
)
.
params
(
u
=
>
u
.
combine
(
'
canvasType
'
kAllCanvasTypes
)
)
.
fn
(
async
t
=
>
{
const
ctx
=
t
.
initCanvasContext
(
t
.
params
.
canvasType
)
;
const
frameTexture
=
ctx
.
getCurrentTexture
(
)
;
t
.
expect
(
frameTexture
=
=
=
ctx
.
getCurrentTexture
(
)
)
;
const
encoder
=
t
.
device
.
createCommandEncoder
(
)
;
const
pass
=
encoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
frameTexture
.
createView
(
)
clearValue
:
[
1
.
0
0
.
0
0
.
0
1
.
0
]
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
]
}
)
;
pass
.
end
(
)
;
t
.
device
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
t
.
expect
(
frameTexture
=
=
=
ctx
.
getCurrentTexture
(
)
)
;
t
.
expectSingleColor
(
frameTexture
frameTexture
.
format
{
size
:
[
frameTexture
.
width
frameTexture
.
height
1
]
exp
:
{
R
:
1
G
:
0
B
:
0
A
:
1
}
}
)
;
frameTexture
.
destroy
(
)
;
t
.
expect
(
frameTexture
=
=
=
ctx
.
getCurrentTexture
(
)
)
;
}
)
;
g
.
test
(
'
multiple_frames
'
)
.
desc
(
Checks
that
the
value
of
getCurrentTexture
differs
across
multiple
frames
.
)
.
params
(
u
=
>
u
.
combine
(
'
canvasType
'
kAllCanvasTypes
)
.
beginSubcases
(
)
.
combine
(
'
clearTexture
'
[
true
false
]
)
)
.
beforeAllSubcases
(
t
=
>
{
const
{
canvasType
}
=
t
.
params
;
if
(
canvasType
=
=
=
'
offscreen
'
&
&
!
(
'
transferToImageBitmap
'
in
OffscreenCanvas
.
prototype
)
)
{
throw
new
SkipTestCase
(
'
transferToImageBitmap
not
supported
'
)
;
}
}
)
.
fn
(
async
t
=
>
{
const
{
canvasType
clearTexture
}
=
t
.
params
;
return
new
Promise
(
resolve
=
>
{
const
ctx
=
t
.
initCanvasContext
(
canvasType
)
;
let
prevTexture
:
GPUTexture
|
undefined
;
let
frameCount
=
0
;
async
function
frameCheck
(
)
{
const
currentTexture
=
ctx
.
getCurrentTexture
(
)
;
if
(
prevTexture
)
{
t
.
expect
(
currentTexture
!
=
=
prevTexture
)
;
t
.
expectSingleColor
(
currentTexture
currentTexture
.
format
{
size
:
[
currentTexture
.
width
currentTexture
.
height
1
]
exp
:
{
R
:
0
G
:
0
B
:
0
A
:
0
}
}
)
;
}
if
(
clearTexture
)
{
const
encoder
=
t
.
device
.
createCommandEncoder
(
)
;
const
pass
=
encoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
currentTexture
.
createView
(
)
clearValue
:
[
1
.
0
0
.
0
0
.
0
1
.
0
]
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
]
}
)
;
pass
.
end
(
)
;
t
.
device
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
}
prevTexture
=
currentTexture
;
if
(
frameCount
+
+
<
5
)
{
switch
(
canvasType
)
{
case
'
onscreen
'
:
requestAnimationFrame
(
frameCheck
)
;
break
;
case
'
offscreen
'
:
{
(
ctx
.
canvas
as
OffscreenCanvas
)
.
transferToImageBitmap
(
)
;
void
frameCheck
(
)
;
break
;
}
default
:
unreachable
(
)
;
}
}
else
{
resolve
(
)
;
}
}
void
frameCheck
(
)
;
}
)
;
}
)
;
g
.
test
(
'
resize
'
)
.
desc
(
Checks
the
value
of
getCurrentTexture
differs
when
the
canvas
is
resized
.
)
.
params
(
u
=
>
u
.
combine
(
'
canvasType
'
kAllCanvasTypes
)
)
.
fn
(
async
t
=
>
{
const
ctx
=
t
.
initCanvasContext
(
t
.
params
.
canvasType
)
;
let
prevTexture
=
ctx
.
getCurrentTexture
(
)
;
ctx
.
canvas
.
width
=
4
;
let
currentTexture
=
ctx
.
getCurrentTexture
(
)
;
t
.
expect
(
prevTexture
!
=
=
currentTexture
)
;
t
.
expect
(
currentTexture
.
width
=
=
=
ctx
.
canvas
.
width
)
;
t
.
expect
(
currentTexture
.
height
=
=
=
ctx
.
canvas
.
height
)
;
t
.
expect
(
prevTexture
.
width
=
=
=
2
)
;
t
.
expect
(
prevTexture
.
height
=
=
=
2
)
;
prevTexture
=
currentTexture
;
t
.
expectSingleColor
(
currentTexture
currentTexture
.
format
{
size
:
[
currentTexture
.
width
currentTexture
.
height
1
]
exp
:
{
R
:
0
G
:
0
B
:
0
A
:
0
}
}
)
;
ctx
.
canvas
.
height
=
4
;
currentTexture
=
ctx
.
getCurrentTexture
(
)
;
t
.
expect
(
prevTexture
!
=
=
currentTexture
)
;
t
.
expect
(
currentTexture
.
width
=
=
=
ctx
.
canvas
.
width
)
;
t
.
expect
(
currentTexture
.
height
=
=
=
ctx
.
canvas
.
height
)
;
t
.
expect
(
prevTexture
.
width
=
=
=
4
)
;
t
.
expect
(
prevTexture
.
height
=
=
=
2
)
;
prevTexture
=
currentTexture
;
t
.
expectSingleColor
(
currentTexture
currentTexture
.
format
{
size
:
[
currentTexture
.
width
currentTexture
.
height
1
]
exp
:
{
R
:
0
G
:
0
B
:
0
A
:
0
}
}
)
;
ctx
.
canvas
.
width
=
4
;
ctx
.
canvas
.
height
=
4
;
currentTexture
=
ctx
.
getCurrentTexture
(
)
;
t
.
expect
(
prevTexture
=
=
=
currentTexture
)
;
}
)
;
