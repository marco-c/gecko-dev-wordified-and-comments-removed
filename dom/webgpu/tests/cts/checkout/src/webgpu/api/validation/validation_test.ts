import
{
ValidBindableResource
BindableResource
kMaxQueryCount
ShaderStageKey
}
from
'
.
.
/
.
.
/
capability_info
.
js
'
;
import
{
GPUTest
ResourceState
}
from
'
.
.
/
.
.
/
gpu_test
.
js
'
;
export
class
ValidationTest
extends
GPUTest
{
createTextureWithState
(
state
:
ResourceState
descriptor
?
:
Readonly
<
GPUTextureDescriptor
>
)
:
GPUTexture
{
descriptor
=
descriptor
?
?
{
size
:
{
width
:
1
height
:
1
depthOrArrayLayers
:
1
}
format
:
'
rgba8unorm
'
usage
:
GPUTextureUsage
.
COPY_SRC
|
GPUTextureUsage
.
COPY_DST
|
GPUTextureUsage
.
TEXTURE_BINDING
|
GPUTextureUsage
.
STORAGE_BINDING
|
GPUTextureUsage
.
RENDER_ATTACHMENT
}
;
switch
(
state
)
{
case
'
valid
'
:
return
this
.
trackForCleanup
(
this
.
device
.
createTexture
(
descriptor
)
)
;
case
'
invalid
'
:
return
this
.
getErrorTexture
(
)
;
case
'
destroyed
'
:
{
const
texture
=
this
.
device
.
createTexture
(
descriptor
)
;
texture
.
destroy
(
)
;
return
texture
;
}
}
}
createBufferWithState
(
state
:
ResourceState
descriptor
?
:
Readonly
<
GPUBufferDescriptor
>
)
:
GPUBuffer
{
descriptor
=
descriptor
?
?
{
size
:
4
usage
:
GPUBufferUsage
.
VERTEX
}
;
switch
(
state
)
{
case
'
valid
'
:
return
this
.
trackForCleanup
(
this
.
device
.
createBuffer
(
descriptor
)
)
;
case
'
invalid
'
:
{
this
.
device
.
pushErrorScope
(
'
validation
'
)
;
const
buffer
=
this
.
device
.
createBuffer
(
{
.
.
.
descriptor
usage
:
descriptor
.
usage
|
GPUBufferUsage
.
MAP_READ
|
GPUBufferUsage
.
COPY_SRC
}
)
;
void
this
.
device
.
popErrorScope
(
)
;
return
buffer
;
}
case
'
destroyed
'
:
{
const
buffer
=
this
.
device
.
createBuffer
(
descriptor
)
;
buffer
.
destroy
(
)
;
return
buffer
;
}
}
}
createQuerySetWithState
(
state
:
ResourceState
desc
?
:
Readonly
<
GPUQuerySetDescriptor
>
)
:
GPUQuerySet
{
const
descriptor
=
{
type
:
'
occlusion
'
as
const
count
:
2
.
.
.
desc
}
;
switch
(
state
)
{
case
'
valid
'
:
return
this
.
trackForCleanup
(
this
.
device
.
createQuerySet
(
descriptor
)
)
;
case
'
invalid
'
:
{
descriptor
.
count
=
kMaxQueryCount
+
1
;
return
this
.
expectGPUError
(
'
validation
'
(
)
=
>
this
.
device
.
createQuerySet
(
descriptor
)
)
;
}
case
'
destroyed
'
:
{
const
queryset
=
this
.
device
.
createQuerySet
(
descriptor
)
;
queryset
.
destroy
(
)
;
return
queryset
;
}
}
}
getStorageBuffer
(
)
:
GPUBuffer
{
return
this
.
trackForCleanup
(
this
.
device
.
createBuffer
(
{
size
:
1024
usage
:
GPUBufferUsage
.
STORAGE
}
)
)
;
}
getUniformBuffer
(
)
:
GPUBuffer
{
return
this
.
trackForCleanup
(
this
.
device
.
createBuffer
(
{
size
:
1024
usage
:
GPUBufferUsage
.
UNIFORM
}
)
)
;
}
getErrorBuffer
(
)
:
GPUBuffer
{
return
this
.
createBufferWithState
(
'
invalid
'
)
;
}
getErrorSampler
(
)
:
GPUSampler
{
this
.
device
.
pushErrorScope
(
'
validation
'
)
;
const
sampler
=
this
.
device
.
createSampler
(
{
lodMinClamp
:
-
1
}
)
;
void
this
.
device
.
popErrorScope
(
)
;
return
sampler
;
}
getSampledTexture
(
sampleCount
:
number
=
1
)
:
GPUTexture
{
const
usage
=
sampleCount
>
1
?
GPUTextureUsage
.
TEXTURE_BINDING
|
GPUTextureUsage
.
RENDER_ATTACHMENT
:
GPUTextureUsage
.
TEXTURE_BINDING
;
return
this
.
trackForCleanup
(
this
.
device
.
createTexture
(
{
size
:
{
width
:
16
height
:
16
depthOrArrayLayers
:
1
}
format
:
'
rgba8unorm
'
usage
sampleCount
}
)
)
;
}
getStorageTexture
(
format
:
GPUTextureFormat
)
:
GPUTexture
{
return
this
.
trackForCleanup
(
this
.
device
.
createTexture
(
{
size
:
{
width
:
16
height
:
16
depthOrArrayLayers
:
1
}
format
usage
:
GPUTextureUsage
.
STORAGE_BINDING
}
)
)
;
}
getRenderTexture
(
sampleCount
:
number
=
1
)
:
GPUTexture
{
return
this
.
trackForCleanup
(
this
.
device
.
createTexture
(
{
size
:
{
width
:
16
height
:
16
depthOrArrayLayers
:
1
}
format
:
'
rgba8unorm
'
usage
:
GPUTextureUsage
.
RENDER_ATTACHMENT
sampleCount
}
)
)
;
}
getErrorTexture
(
)
:
GPUTexture
{
this
.
device
.
pushErrorScope
(
'
validation
'
)
;
const
texture
=
this
.
device
.
createTexture
(
{
size
:
{
width
:
0
height
:
0
depthOrArrayLayers
:
0
}
format
:
'
rgba8unorm
'
usage
:
GPUTextureUsage
.
TEXTURE_BINDING
}
)
;
void
this
.
device
.
popErrorScope
(
)
;
return
texture
;
}
getErrorTextureView
(
)
:
GPUTextureView
{
this
.
device
.
pushErrorScope
(
'
validation
'
)
;
const
view
=
this
.
getErrorTexture
(
)
.
createView
(
)
;
void
this
.
device
.
popErrorScope
(
)
;
return
view
;
}
getBindingResource
(
bindingType
:
BindableResource
)
:
GPUBindingResource
{
switch
(
bindingType
)
{
case
'
errorBuf
'
:
return
{
buffer
:
this
.
getErrorBuffer
(
)
}
;
case
'
errorSamp
'
:
return
this
.
getErrorSampler
(
)
;
case
'
errorTex
'
:
return
this
.
getErrorTextureView
(
)
;
case
'
uniformBuf
'
:
return
{
buffer
:
this
.
getUniformBuffer
(
)
}
;
case
'
storageBuf
'
:
return
{
buffer
:
this
.
getStorageBuffer
(
)
}
;
case
'
filtSamp
'
:
return
this
.
device
.
createSampler
(
{
minFilter
:
'
linear
'
}
)
;
case
'
nonFiltSamp
'
:
return
this
.
device
.
createSampler
(
)
;
case
'
compareSamp
'
:
return
this
.
device
.
createSampler
(
{
compare
:
'
never
'
}
)
;
case
'
sampledTex
'
:
return
this
.
getSampledTexture
(
1
)
.
createView
(
)
;
case
'
sampledTexMS
'
:
return
this
.
getSampledTexture
(
4
)
.
createView
(
)
;
case
'
readonlyStorageTex
'
:
case
'
writeonlyStorageTex
'
:
case
'
readwriteStorageTex
'
:
return
this
.
getStorageTexture
(
'
r32float
'
)
.
createView
(
)
;
}
}
getDeviceMismatchedStorageBuffer
(
)
:
GPUBuffer
{
return
this
.
trackForCleanup
(
this
.
mismatchedDevice
.
createBuffer
(
{
size
:
4
usage
:
GPUBufferUsage
.
STORAGE
}
)
)
;
}
getDeviceMismatchedUniformBuffer
(
)
:
GPUBuffer
{
return
this
.
trackForCleanup
(
this
.
mismatchedDevice
.
createBuffer
(
{
size
:
4
usage
:
GPUBufferUsage
.
UNIFORM
}
)
)
;
}
getDeviceMismatchedTexture
(
descriptor
:
GPUTextureDescriptor
)
:
GPUTexture
{
return
this
.
trackForCleanup
(
this
.
mismatchedDevice
.
createTexture
(
descriptor
)
)
;
}
getDeviceMismatchedSampledTexture
(
sampleCount
:
number
=
1
)
:
GPUTexture
{
return
this
.
getDeviceMismatchedTexture
(
{
size
:
{
width
:
4
height
:
4
depthOrArrayLayers
:
1
}
format
:
'
rgba8unorm
'
usage
:
GPUTextureUsage
.
TEXTURE_BINDING
sampleCount
}
)
;
}
getDeviceMismatchedStorageTexture
(
format
:
GPUTextureFormat
)
:
GPUTexture
{
return
this
.
getDeviceMismatchedTexture
(
{
size
:
{
width
:
4
height
:
4
depthOrArrayLayers
:
1
}
format
usage
:
GPUTextureUsage
.
STORAGE_BINDING
}
)
;
}
getDeviceMismatchedRenderTexture
(
sampleCount
:
number
=
1
)
:
GPUTexture
{
return
this
.
getDeviceMismatchedTexture
(
{
size
:
{
width
:
4
height
:
4
depthOrArrayLayers
:
1
}
format
:
'
rgba8unorm
'
usage
:
GPUTextureUsage
.
RENDER_ATTACHMENT
sampleCount
}
)
;
}
getDeviceMismatchedBindingResource
(
bindingType
:
ValidBindableResource
)
:
GPUBindingResource
{
switch
(
bindingType
)
{
case
'
uniformBuf
'
:
return
{
buffer
:
this
.
getDeviceMismatchedStorageBuffer
(
)
}
;
case
'
storageBuf
'
:
return
{
buffer
:
this
.
getDeviceMismatchedUniformBuffer
(
)
}
;
case
'
filtSamp
'
:
return
this
.
mismatchedDevice
.
createSampler
(
{
minFilter
:
'
linear
'
}
)
;
case
'
nonFiltSamp
'
:
return
this
.
mismatchedDevice
.
createSampler
(
)
;
case
'
compareSamp
'
:
return
this
.
mismatchedDevice
.
createSampler
(
{
compare
:
'
never
'
}
)
;
case
'
sampledTex
'
:
return
this
.
getDeviceMismatchedSampledTexture
(
1
)
.
createView
(
)
;
case
'
sampledTexMS
'
:
return
this
.
getDeviceMismatchedSampledTexture
(
4
)
.
createView
(
)
;
case
'
readonlyStorageTex
'
:
case
'
writeonlyStorageTex
'
:
case
'
readwriteStorageTex
'
:
return
this
.
getDeviceMismatchedStorageTexture
(
'
r32float
'
)
.
createView
(
)
;
}
}
getNoOpShaderCode
(
stage
:
ShaderStageKey
)
:
string
{
switch
(
stage
)
{
case
'
VERTEX
'
:
return
vertex
fn
main
(
)
-
>
builtin
(
position
)
vec4
<
f32
>
{
return
vec4
<
f32
>
(
)
;
}
;
case
'
FRAGMENT
'
:
return
fragment
fn
main
(
)
{
}
;
case
'
COMPUTE
'
:
return
compute
workgroup_size
(
1
)
fn
main
(
)
{
}
;
}
}
createRenderPipelineWithState
(
state
:
'
valid
'
|
'
invalid
'
)
:
GPURenderPipeline
{
return
state
=
=
=
'
valid
'
?
this
.
createNoOpRenderPipeline
(
)
:
this
.
createErrorRenderPipeline
(
)
;
}
createNoOpRenderPipeline
(
layout
:
GPUPipelineLayout
|
GPUAutoLayoutMode
=
'
auto
'
colorFormat
:
GPUTextureFormat
=
'
rgba8unorm
'
)
:
GPURenderPipeline
{
return
this
.
device
.
createRenderPipeline
(
{
layout
vertex
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
this
.
getNoOpShaderCode
(
'
VERTEX
'
)
}
)
entryPoint
:
'
main
'
}
fragment
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
this
.
getNoOpShaderCode
(
'
FRAGMENT
'
)
}
)
entryPoint
:
'
main
'
targets
:
[
{
format
:
colorFormat
writeMask
:
0
}
]
}
primitive
:
{
topology
:
'
triangle
-
list
'
}
}
)
;
}
createErrorRenderPipeline
(
)
:
GPURenderPipeline
{
this
.
device
.
pushErrorScope
(
'
validation
'
)
;
const
pipeline
=
this
.
device
.
createRenderPipeline
(
{
layout
:
'
auto
'
vertex
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
'
'
}
)
entryPoint
:
'
'
}
}
)
;
void
this
.
device
.
popErrorScope
(
)
;
return
pipeline
;
}
createNoOpComputePipeline
(
layout
:
GPUPipelineLayout
|
GPUAutoLayoutMode
=
'
auto
'
)
:
GPUComputePipeline
{
return
this
.
device
.
createComputePipeline
(
{
layout
compute
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
this
.
getNoOpShaderCode
(
'
COMPUTE
'
)
}
)
entryPoint
:
'
main
'
}
}
)
;
}
createErrorComputePipeline
(
)
:
GPUComputePipeline
{
this
.
device
.
pushErrorScope
(
'
validation
'
)
;
const
pipeline
=
this
.
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
'
'
}
)
entryPoint
:
'
'
}
}
)
;
void
this
.
device
.
popErrorScope
(
)
;
return
pipeline
;
}
createInvalidShaderModule
(
)
:
GPUShaderModule
{
this
.
device
.
pushErrorScope
(
'
validation
'
)
;
const
code
=
'
deadbeaf
'
;
const
shaderModule
=
this
.
device
.
createShaderModule
(
{
code
}
)
;
void
this
.
device
.
popErrorScope
(
)
;
return
shaderModule
;
}
doCreateRenderPipelineTest
(
isAsync
:
boolean
_success
:
boolean
descriptor
:
GPURenderPipelineDescriptor
errorTypeName
:
'
GPUPipelineError
'
|
'
TypeError
'
=
'
GPUPipelineError
'
)
{
if
(
isAsync
)
{
if
(
_success
)
{
this
.
shouldResolve
(
this
.
device
.
createRenderPipelineAsync
(
descriptor
)
)
;
}
else
{
this
.
shouldReject
(
errorTypeName
this
.
device
.
createRenderPipelineAsync
(
descriptor
)
)
;
}
}
else
{
if
(
errorTypeName
=
=
=
'
GPUPipelineError
'
)
{
this
.
expectValidationError
(
(
)
=
>
{
this
.
device
.
createRenderPipeline
(
descriptor
)
;
}
!
_success
)
;
}
else
{
this
.
shouldThrow
(
_success
?
false
:
errorTypeName
(
)
=
>
{
this
.
device
.
createRenderPipeline
(
descriptor
)
;
}
)
;
}
}
}
doCreateComputePipelineTest
(
isAsync
:
boolean
_success
:
boolean
descriptor
:
GPUComputePipelineDescriptor
errorTypeName
:
'
GPUPipelineError
'
|
'
TypeError
'
=
'
GPUPipelineError
'
)
{
if
(
isAsync
)
{
if
(
_success
)
{
this
.
shouldResolve
(
this
.
device
.
createComputePipelineAsync
(
descriptor
)
)
;
}
else
{
this
.
shouldReject
(
errorTypeName
this
.
device
.
createComputePipelineAsync
(
descriptor
)
)
;
}
}
else
{
if
(
errorTypeName
=
=
=
'
GPUPipelineError
'
)
{
this
.
expectValidationError
(
(
)
=
>
{
this
.
device
.
createComputePipeline
(
descriptor
)
;
}
!
_success
)
;
}
else
{
this
.
shouldThrow
(
_success
?
false
:
errorTypeName
(
)
=
>
{
this
.
device
.
createComputePipeline
(
descriptor
)
;
}
)
;
}
}
}
}
