export
const
description
=
Tests
the
behavior
of
different
filtering
modes
in
minFilter
/
magFilter
/
mipmapFilter
.
Note
:
It
'
s
possible
these
tests
duplicated
tests
under
shader
/
execution
/
expression
/
call
/
builtin
/
textureXXX
.
Further
these
tests
only
test
encodable
/
filterable
/
renderable
color
formats
.
Depth
sint
uint
and
compressed
formats
are
not
tested
.
;
import
{
makeTestGroup
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
framework
/
test_group
.
js
'
;
import
{
kAddressModes
kMipmapFilterModes
}
from
'
.
.
/
.
.
/
.
.
/
capability_info
.
js
'
;
import
{
EncodableTextureFormat
getTextureFormatType
kPossiblyRenderableColorTextureFormats
}
from
'
.
.
/
.
.
/
.
.
/
format_info
.
js
'
;
import
{
AllFeaturesMaxLimitsGPUTest
TextureTestMixin
}
from
'
.
.
/
.
.
/
.
.
/
gpu_test
.
js
'
;
import
{
getTextureCopyLayout
}
from
'
.
.
/
.
.
/
.
.
/
util
/
texture
/
layout
.
js
'
;
import
{
TexelView
}
from
'
.
.
/
.
.
/
.
.
/
util
/
texture
/
texel_view
.
js
'
;
const
kCheckerTextureSize
=
2
;
const
kCheckerTextureData
=
[
{
R
:
1
.
0
G
:
1
.
0
B
:
1
.
0
A
:
1
.
0
}
{
R
:
0
.
0
G
:
0
.
0
B
:
0
.
0
A
:
1
.
0
}
{
R
:
0
.
0
G
:
0
.
0
B
:
0
.
0
A
:
1
.
0
}
{
R
:
1
.
0
G
:
1
.
0
B
:
1
.
0
A
:
1
.
0
}
]
;
const
kPossiblyRenderablePossiblyFilterableColorTextureFormats
=
kPossiblyRenderableColorTextureFormats
.
filter
(
format
=
>
getTextureFormatType
(
format
)
=
=
=
'
float
'
|
|
getTextureFormatType
(
format
)
=
=
=
'
unfilterable
-
float
'
)
;
class
FilterModeTest
extends
TextureTestMixin
(
AllFeaturesMaxLimitsGPUTest
)
{
runFilterRenderPipeline
(
sampler
:
GPUSampler
module
:
GPUShaderModule
format
:
EncodableTextureFormat
renderSize
:
number
[
]
vertexCount
:
number
instanceCount
:
number
)
{
const
sampleTexture
=
this
.
createTextureFromTexelView
(
TexelView
.
fromTexelsAsColors
(
format
coord
=
>
{
const
id
=
coord
.
x
+
coord
.
y
*
kCheckerTextureSize
;
return
kCheckerTextureData
[
id
]
;
}
)
{
size
:
[
kCheckerTextureSize
kCheckerTextureSize
]
usage
:
GPUTextureUsage
.
TEXTURE_BINDING
|
GPUTextureUsage
.
COPY_DST
}
)
;
const
renderTexture
=
this
.
createTextureTracked
(
{
format
size
:
renderSize
usage
:
GPUTextureUsage
.
RENDER_ATTACHMENT
|
GPUTextureUsage
.
COPY_SRC
}
)
;
const
pipeline
=
this
.
device
.
createRenderPipeline
(
{
layout
:
'
auto
'
vertex
:
{
module
entryPoint
:
'
vs_main
'
}
fragment
:
{
module
entryPoint
:
'
fs_main
'
targets
:
[
{
format
}
]
}
}
)
;
const
bindgroup
=
this
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
sampler
}
{
binding
:
1
resource
:
sampleTexture
.
createView
(
)
}
]
}
)
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
const
renderPass
=
commandEncoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
renderTexture
.
createView
(
)
clearValue
:
[
0
0
0
0
]
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
]
}
)
;
renderPass
.
setPipeline
(
pipeline
)
;
renderPass
.
setBindGroup
(
0
bindgroup
)
;
renderPass
.
draw
(
vertexCount
instanceCount
)
;
renderPass
.
end
(
)
;
this
.
device
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
return
renderTexture
;
}
}
export
const
g
=
makeTestGroup
(
FilterModeTest
)
;
const
kNearestRenderSize
=
6
;
const
kNearestRenderDim
=
[
kNearestRenderSize
kNearestRenderSize
]
;
const
kNearestURepeatVRepeat
=
[
[
1
0
1
0
1
0
]
[
0
1
0
1
0
1
]
[
1
0
1
0
1
0
]
[
0
1
0
1
0
1
]
[
1
0
1
0
1
0
]
[
0
1
0
1
0
1
]
]
;
const
kNearestURepeatVClamped
=
[
[
1
0
1
0
1
0
]
[
1
0
1
0
1
0
]
[
1
0
1
0
1
0
]
[
0
1
0
1
0
1
]
[
0
1
0
1
0
1
]
[
0
1
0
1
0
1
]
]
;
const
kNearestURepeatVMirror
=
[
[
0
1
0
1
0
1
]
[
1
0
1
0
1
0
]
[
1
0
1
0
1
0
]
[
0
1
0
1
0
1
]
[
0
1
0
1
0
1
]
[
1
0
1
0
1
0
]
]
;
const
kNearestUClampedVRepeat
=
[
[
1
1
1
0
0
0
]
[
0
0
0
1
1
1
]
[
1
1
1
0
0
0
]
[
0
0
0
1
1
1
]
[
1
1
1
0
0
0
]
[
0
0
0
1
1
1
]
]
;
const
kNearestUClampedVClamped
=
[
[
1
1
1
0
0
0
]
[
1
1
1
0
0
0
]
[
1
1
1
0
0
0
]
[
0
0
0
1
1
1
]
[
0
0
0
1
1
1
]
[
0
0
0
1
1
1
]
]
;
const
kNearestUClampedVMirror
=
[
[
0
0
0
1
1
1
]
[
1
1
1
0
0
0
]
[
1
1
1
0
0
0
]
[
0
0
0
1
1
1
]
[
0
0
0
1
1
1
]
[
1
1
1
0
0
0
]
]
;
const
kNearestUMirrorVRepeat
=
[
[
0
1
1
0
0
1
]
[
1
0
0
1
1
0
]
[
0
1
1
0
0
1
]
[
1
0
0
1
1
0
]
[
0
1
1
0
0
1
]
[
1
0
0
1
1
0
]
]
;
const
kNearestUMirrorVClamped
=
[
[
0
1
1
0
0
1
]
[
0
1
1
0
0
1
]
[
0
1
1
0
0
1
]
[
1
0
0
1
1
0
]
[
1
0
0
1
1
0
]
[
1
0
0
1
1
0
]
]
;
const
kNearestUMirrorVMirror
=
[
[
1
0
0
1
1
0
]
[
0
1
1
0
0
1
]
[
0
1
1
0
0
1
]
[
1
0
0
1
1
0
]
[
1
0
0
1
1
0
]
[
0
1
1
0
0
1
]
]
;
const
kLinearRenderSize
=
4
;
const
kLinearRenderDim
=
[
kLinearRenderSize
kLinearRenderSize
]
;
const
kLinearURepeatVRepeat
=
[
[
10
6
10
6
]
[
10
6
10
6
]
[
6
10
6
10
]
[
6
10
6
10
]
]
;
const
kLinearURepeatVClamped
=
[
[
12
4
12
4
]
[
12
4
12
4
]
[
4
12
4
12
]
[
4
12
4
12
]
]
;
const
kLinearURepeatVMirror
=
[
[
4
12
4
12
]
[
12
4
12
4
]
[
4
12
4
12
]
[
12
4
12
4
]
]
;
const
kLinearUClampedVRepeat
=
[
[
12
12
4
4
]
[
12
12
4
4
]
[
4
4
12
12
]
[
4
4
12
12
]
]
;
const
kLinearUClampedVClamped
=
[
[
16
16
0
0
]
[
16
16
0
0
]
[
0
0
16
16
]
[
0
0
16
16
]
]
;
const
kLinearUClampedVMirror
=
[
[
0
0
16
16
]
[
16
16
0
0
]
[
0
0
16
16
]
[
16
16
0
0
]
]
;
const
kLinearUMirrorVRepeat
=
[
[
4
12
4
12
]
[
4
12
4
12
]
[
12
4
12
4
]
[
12
4
12
4
]
]
;
const
kLinearUMirrorVClamped
=
[
[
0
16
0
16
]
[
0
16
0
16
]
[
16
0
16
0
]
[
16
0
16
0
]
]
;
const
kLinearUMirrorVMirror
=
[
[
16
0
16
0
]
[
0
16
0
16
]
[
16
0
16
0
]
[
0
16
0
16
]
]
;
function
expectedNearestColors
(
format
:
EncodableTextureFormat
addressModeU
:
GPUAddressMode
addressModeV
:
GPUAddressMode
)
:
TexelView
{
let
expectedColors
:
number
[
]
[
]
;
switch
(
addressModeU
)
{
case
'
clamp
-
to
-
edge
'
:
{
switch
(
addressModeV
)
{
case
'
clamp
-
to
-
edge
'
:
expectedColors
=
kNearestUClampedVClamped
;
break
;
case
'
repeat
'
:
expectedColors
=
kNearestUClampedVRepeat
;
break
;
case
'
mirror
-
repeat
'
:
expectedColors
=
kNearestUClampedVMirror
;
break
;
}
break
;
}
case
'
repeat
'
:
switch
(
addressModeV
)
{
case
'
clamp
-
to
-
edge
'
:
expectedColors
=
kNearestURepeatVClamped
;
break
;
case
'
repeat
'
:
expectedColors
=
kNearestURepeatVRepeat
;
break
;
case
'
mirror
-
repeat
'
:
expectedColors
=
kNearestURepeatVMirror
;
break
;
}
break
;
case
'
mirror
-
repeat
'
:
switch
(
addressModeV
)
{
case
'
clamp
-
to
-
edge
'
:
expectedColors
=
kNearestUMirrorVClamped
;
break
;
case
'
repeat
'
:
expectedColors
=
kNearestUMirrorVRepeat
;
break
;
case
'
mirror
-
repeat
'
:
expectedColors
=
kNearestUMirrorVMirror
;
break
;
}
break
;
}
return
TexelView
.
fromTexelsAsColors
(
format
coord
=
>
{
const
c
=
expectedColors
[
coord
.
y
]
[
coord
.
x
]
;
return
{
R
:
c
G
:
c
B
:
c
A
:
1
.
0
}
;
}
)
;
}
function
expectedLinearColors
(
format
:
EncodableTextureFormat
addressModeU
:
GPUAddressMode
addressModeV
:
GPUAddressMode
)
:
TexelView
{
let
expectedColors
:
number
[
]
[
]
;
switch
(
addressModeU
)
{
case
'
clamp
-
to
-
edge
'
:
{
switch
(
addressModeV
)
{
case
'
clamp
-
to
-
edge
'
:
expectedColors
=
kLinearUClampedVClamped
;
break
;
case
'
repeat
'
:
expectedColors
=
kLinearUClampedVRepeat
;
break
;
case
'
mirror
-
repeat
'
:
expectedColors
=
kLinearUClampedVMirror
;
break
;
}
break
;
}
case
'
repeat
'
:
switch
(
addressModeV
)
{
case
'
clamp
-
to
-
edge
'
:
expectedColors
=
kLinearURepeatVClamped
;
break
;
case
'
repeat
'
:
expectedColors
=
kLinearURepeatVRepeat
;
break
;
case
'
mirror
-
repeat
'
:
expectedColors
=
kLinearURepeatVMirror
;
break
;
}
break
;
case
'
mirror
-
repeat
'
:
switch
(
addressModeV
)
{
case
'
clamp
-
to
-
edge
'
:
expectedColors
=
kLinearUMirrorVClamped
;
break
;
case
'
repeat
'
:
expectedColors
=
kLinearUMirrorVRepeat
;
break
;
case
'
mirror
-
repeat
'
:
expectedColors
=
kLinearUMirrorVMirror
;
break
;
}
break
;
}
return
TexelView
.
fromTexelsAsColors
(
format
coord
=
>
{
const
c
=
expectedColors
[
coord
.
y
]
[
coord
.
x
]
;
return
{
R
:
c
/
16
G
:
c
/
16
B
:
c
/
16
A
:
1
.
0
}
;
}
)
;
}
function
expectedColors
(
format
:
EncodableTextureFormat
filterMode
:
GPUFilterMode
addressModeU
:
GPUAddressMode
addressModeV
:
GPUAddressMode
)
:
TexelView
{
switch
(
filterMode
)
{
case
'
nearest
'
:
return
expectedNearestColors
(
format
addressModeU
addressModeV
)
;
case
'
linear
'
:
return
expectedLinearColors
(
format
addressModeU
addressModeV
)
;
}
}
g
.
test
(
'
magFilter
nearest
'
)
.
desc
(
Test
that
for
filterable
formats
magFilter
'
nearest
'
mode
correctly
modifies
the
sampling
.
-
format
=
{
<
filterable
formats
>
}
-
addressModeU
=
{
'
clamp
-
to
-
edge
'
'
repeat
'
'
mirror
-
repeat
'
}
-
addressModeV
=
{
'
clamp
-
to
-
edge
'
'
repeat
'
'
mirror
-
repeat
'
}
)
.
params
(
u
=
>
u
.
combine
(
'
format
'
kPossiblyRenderablePossiblyFilterableColorTextureFormats
)
.
beginSubcases
(
)
.
combine
(
'
addressModeU
'
kAddressModes
)
.
combine
(
'
addressModeV
'
kAddressModes
)
)
.
fn
(
t
=
>
{
const
{
format
addressModeU
addressModeV
}
=
t
.
params
;
t
.
skipIfTextureFormatNotSupported
(
format
)
;
t
.
skipIfTextureFormatNotFilterable
(
format
)
;
const
sampler
=
t
.
device
.
createSampler
(
{
addressModeU
addressModeV
magFilter
:
'
nearest
'
}
)
;
const
module
=
t
.
device
.
createShaderModule
(
{
code
:
group
(
0
)
binding
(
0
)
var
s
:
sampler
;
group
(
0
)
binding
(
1
)
var
t
:
texture_2d
<
f32
>
;
struct
VertexOut
{
builtin
(
position
)
pos
:
vec4f
location
(
0
)
uv
:
vec2f
}
;
vertex
fn
vs_main
(
builtin
(
vertex_index
)
vi
:
u32
builtin
(
instance_index
)
ii
:
u32
)
-
>
VertexOut
{
const
grid
=
vec2f
(
{
kNearestRenderSize
}
{
kNearestRenderSize
}
)
;
const
posBases
=
array
(
vec2f
(
1
1
)
vec2f
(
1
-
1
)
vec2f
(
-
1
-
1
)
vec2f
(
1
1
)
vec2f
(
-
1
-
1
)
vec2f
(
-
1
1
)
)
;
const
uvBases
=
array
(
vec2f
(
1
.
0
.
)
vec2f
(
1
.
1
.
)
vec2f
(
0
.
1
.
)
vec2f
(
1
.
0
.
)
vec2f
(
0
.
1
.
)
vec2f
(
0
.
0
.
)
)
;
/
/
Compute
the
offset
of
instance
plane
.
let
cell
=
vec2f
(
f32
(
ii
)
%
grid
.
x
floor
(
f32
(
ii
)
/
grid
.
y
)
)
;
let
cellOffset
=
cell
/
grid
*
2
;
let
pos
=
(
posBases
[
vi
]
+
1
)
/
grid
-
1
+
cellOffset
;
/
/
Compute
the
offset
of
the
UVs
.
let
uvBase
=
uvBases
[
vi
]
*
0
.
25
+
vec2f
(
-
0
.
875
1
.
625
)
;
const
uvPerPixelOffset
=
vec2f
(
0
.
5
-
0
.
5
)
;
return
VertexOut
(
vec4f
(
pos
0
.
0
1
.
0
)
uvBase
+
uvPerPixelOffset
*
cell
)
;
}
fragment
fn
fs_main
(
location
(
0
)
uv
:
vec2f
)
-
>
location
(
0
)
vec4f
{
return
textureSample
(
t
s
uv
)
;
}
}
)
;
const
vertexCount
=
6
;
const
instanceCount
=
kNearestRenderDim
.
reduce
(
(
sink
current
)
=
>
sink
*
current
)
;
const
render
=
t
.
runFilterRenderPipeline
(
sampler
module
format
kNearestRenderDim
vertexCount
instanceCount
)
;
t
.
expectTexelViewComparisonIsOkInTexture
(
{
texture
:
render
}
expectedColors
(
format
'
nearest
'
addressModeU
addressModeV
)
kNearestRenderDim
)
;
}
)
;
g
.
test
(
'
magFilter
linear
'
)
.
desc
(
Test
that
for
filterable
formats
magFilter
'
linear
'
mode
correctly
modifies
the
sampling
.
-
format
=
{
<
filterable
formats
>
}
-
addressModeU
=
{
'
clamp
-
to
-
edge
'
'
repeat
'
'
mirror
-
repeat
'
}
-
addressModeV
=
{
'
clamp
-
to
-
edge
'
'
repeat
'
'
mirror
-
repeat
'
}
)
.
params
(
u
=
>
u
.
combine
(
'
format
'
kPossiblyRenderablePossiblyFilterableColorTextureFormats
)
.
beginSubcases
(
)
.
combine
(
'
addressModeU
'
kAddressModes
)
.
combine
(
'
addressModeV
'
kAddressModes
)
)
.
fn
(
t
=
>
{
const
{
format
addressModeU
addressModeV
}
=
t
.
params
;
t
.
skipIfTextureFormatNotSupported
(
format
)
;
t
.
skipIfTextureFormatNotFilterable
(
format
)
;
const
sampler
=
t
.
device
.
createSampler
(
{
addressModeU
addressModeV
magFilter
:
'
linear
'
}
)
;
const
module
=
t
.
device
.
createShaderModule
(
{
code
:
group
(
0
)
binding
(
0
)
var
s
:
sampler
;
group
(
0
)
binding
(
1
)
var
t
:
texture_2d
<
f32
>
;
struct
VertexOut
{
builtin
(
position
)
pos
:
vec4f
location
(
0
)
uv
:
vec2f
}
;
vertex
fn
vs_main
(
builtin
(
vertex_index
)
vi
:
u32
builtin
(
instance_index
)
ii
:
u32
)
-
>
VertexOut
{
const
grid
=
vec2f
(
{
kLinearRenderSize
}
{
kLinearRenderSize
}
)
;
const
posBases
=
array
(
vec2f
(
1
1
)
vec2f
(
1
-
1
)
vec2f
(
-
1
-
1
)
vec2f
(
1
1
)
vec2f
(
-
1
-
1
)
vec2f
(
-
1
1
)
)
;
const
uvBases
=
array
(
vec2f
(
1
.
0
.
)
vec2f
(
1
.
1
.
)
vec2f
(
0
.
1
.
)
vec2f
(
1
.
0
.
)
vec2f
(
0
.
1
.
)
vec2f
(
0
.
0
.
)
)
;
/
/
Compute
the
offset
of
instance
plane
.
let
cell
=
vec2f
(
f32
(
ii
)
%
grid
.
x
floor
(
f32
(
ii
)
/
grid
.
y
)
)
;
let
cellOffset
=
cell
/
grid
*
2
;
let
pos
=
(
posBases
[
vi
]
+
1
)
/
grid
-
1
+
cellOffset
;
/
/
Compute
the
offset
of
the
UVs
.
const
uOffsets
=
array
(
0
.
0
.
75
2
.
2
.
75
)
;
const
vOffsets
=
array
(
0
.
1
.
1
.
75
2
.
75
)
;
let
uvBase
=
uvBases
[
vi
]
*
0
.
25
+
vec2f
(
-
1
.
1
.
75
)
;
let
uvPixelOffset
=
vec2f
(
uOffsets
[
u32
(
cell
.
x
)
]
-
vOffsets
[
u32
(
cell
.
y
)
]
)
;
return
VertexOut
(
vec4f
(
pos
0
.
0
1
.
0
)
uvBase
+
uvPixelOffset
)
;
}
fragment
fn
fs_main
(
location
(
0
)
uv
:
vec2f
)
-
>
location
(
0
)
vec4f
{
return
textureSample
(
t
s
uv
)
;
}
}
)
;
const
vertexCount
=
6
;
const
instanceCount
=
kLinearRenderDim
.
reduce
(
(
sink
current
)
=
>
sink
*
current
)
;
const
render
=
t
.
runFilterRenderPipeline
(
sampler
module
format
kLinearRenderDim
vertexCount
instanceCount
)
;
t
.
expectTexelViewComparisonIsOkInTexture
(
{
texture
:
render
}
expectedColors
(
format
'
linear
'
addressModeU
addressModeV
)
kLinearRenderDim
)
;
}
)
;
g
.
test
(
'
minFilter
nearest
'
)
.
desc
(
Test
that
for
filterable
formats
minFilter
'
nearest
'
mode
correctly
modifies
the
sampling
.
-
format
=
{
<
filterable
formats
>
}
-
addressModeU
=
{
'
clamp
-
to
-
edge
'
'
repeat
'
'
mirror
-
repeat
'
}
-
addressModeV
=
{
'
clamp
-
to
-
edge
'
'
repeat
'
'
mirror
-
repeat
'
}
)
.
params
(
u
=
>
u
.
combine
(
'
format
'
kPossiblyRenderablePossiblyFilterableColorTextureFormats
)
.
beginSubcases
(
)
.
combine
(
'
addressModeU
'
kAddressModes
)
.
combine
(
'
addressModeV
'
kAddressModes
)
)
.
fn
(
t
=
>
{
const
{
format
addressModeU
addressModeV
}
=
t
.
params
;
t
.
skipIfTextureFormatNotSupported
(
format
)
;
t
.
skipIfTextureFormatNotFilterable
(
format
)
;
const
sampler
=
t
.
device
.
createSampler
(
{
addressModeU
addressModeV
minFilter
:
'
nearest
'
}
)
;
const
module
=
t
.
device
.
createShaderModule
(
{
code
:
group
(
0
)
binding
(
0
)
var
s
:
sampler
;
group
(
0
)
binding
(
1
)
var
t
:
texture_2d
<
f32
>
;
struct
VertexOut
{
builtin
(
position
)
pos
:
vec4f
location
(
0
)
uv
:
vec2f
}
;
vertex
fn
vs_main
(
builtin
(
vertex_index
)
vi
:
u32
builtin
(
instance_index
)
ii
:
u32
)
-
>
VertexOut
{
const
grid
=
vec2f
(
{
kNearestRenderSize
}
{
kNearestRenderSize
}
)
;
const
posBases
=
array
(
vec2f
(
.
5
.
5
)
vec2f
(
.
5
-
.
5
)
vec2f
(
-
.
5
-
.
5
)
vec2f
(
.
5
.
5
)
vec2f
(
-
.
5
-
.
5
)
vec2f
(
-
.
5
.
5
)
)
;
/
/
Choose
UVs
so
that
the
quad
ends
up
being
the
6x6
texture
.
const
uvBases
=
array
(
vec2f
(
2
.
-
1
.
)
vec2f
(
2
.
2
.
)
vec2f
(
-
1
.
2
.
)
vec2f
(
2
.
-
1
.
)
vec2f
(
-
1
.
2
.
)
vec2f
(
-
1
.
-
1
.
)
)
;
let
cell
=
vec2f
(
f32
(
ii
)
%
grid
.
x
floor
(
f32
(
ii
)
/
grid
.
y
)
)
;
/
/
Compute
the
offset
of
instance
plane
(
pre
-
grid
transformation
)
.
const
constantPlaneOffset
=
vec2f
(
5
.
/
12
.
5
.
/
12
.
)
;
const
perPixelOffset
=
vec2f
(
1
.
/
6
.
1
.
/
6
.
)
;
let
posBase
=
posBases
[
vi
]
+
constantPlaneOffset
-
perPixelOffset
*
cell
;
/
/
Apply
the
grid
transformation
.
let
cellOffset
=
cell
/
grid
*
2
;
let
absPos
=
(
posBase
+
1
)
/
grid
-
1
+
cellOffset
;
return
VertexOut
(
vec4f
(
absPos
0
.
0
1
.
0
)
uvBases
[
vi
]
)
;
}
fragment
fn
fs_main
(
location
(
0
)
uv
:
vec2f
)
-
>
location
(
0
)
vec4f
{
return
textureSample
(
t
s
uv
)
;
}
}
)
;
const
vertexCount
=
6
;
const
instanceCount
=
kNearestRenderDim
.
reduce
(
(
sink
current
)
=
>
sink
*
current
)
;
const
render
=
t
.
runFilterRenderPipeline
(
sampler
module
format
kNearestRenderDim
vertexCount
instanceCount
)
;
t
.
expectTexelViewComparisonIsOkInTexture
(
{
texture
:
render
}
expectedColors
(
format
'
nearest
'
addressModeU
addressModeV
)
kNearestRenderDim
)
;
}
)
;
g
.
test
(
'
minFilter
linear
'
)
.
desc
(
Test
that
for
filterable
formats
minFilter
'
linear
'
mode
correctly
modifies
the
sampling
.
-
format
=
{
<
filterable
formats
>
}
-
addressModeU
=
{
'
clamp
-
to
-
edge
'
'
repeat
'
'
mirror
-
repeat
'
}
-
addressModeV
=
{
'
clamp
-
to
-
edge
'
'
repeat
'
'
mirror
-
repeat
'
}
)
.
params
(
u
=
>
u
.
combine
(
'
format
'
kPossiblyRenderablePossiblyFilterableColorTextureFormats
)
.
beginSubcases
(
)
.
combine
(
'
addressModeU
'
kAddressModes
)
.
combine
(
'
addressModeV
'
kAddressModes
)
)
.
fn
(
t
=
>
{
const
{
format
addressModeU
addressModeV
}
=
t
.
params
;
t
.
skipIfTextureFormatNotSupported
(
format
)
;
t
.
skipIfTextureFormatNotFilterable
(
format
)
;
const
sampler
=
t
.
device
.
createSampler
(
{
addressModeU
addressModeV
minFilter
:
'
linear
'
}
)
;
const
module
=
t
.
device
.
createShaderModule
(
{
code
:
group
(
0
)
binding
(
0
)
var
s
:
sampler
;
group
(
0
)
binding
(
1
)
var
t
:
texture_2d
<
f32
>
;
struct
VertexOut
{
builtin
(
position
)
pos
:
vec4f
location
(
0
)
uv
:
vec2f
}
;
vertex
fn
vs_main
(
builtin
(
vertex_index
)
vi
:
u32
builtin
(
instance_index
)
ii
:
u32
)
-
>
VertexOut
{
const
grid
=
vec2f
(
{
kLinearRenderSize
}
{
kLinearRenderSize
}
)
;
const
posBases
=
array
(
vec2f
(
.
5
.
5
)
vec2f
(
.
5
-
.
5
)
vec2f
(
-
.
5
-
.
5
)
vec2f
(
.
5
.
5
)
vec2f
(
-
.
5
-
.
5
)
vec2f
(
-
.
5
.
5
)
)
;
/
/
Choose
UVs
so
that
the
quad
ends
up
being
the
8x8
texture
.
const
uvBases
=
array
(
vec2f
(
2
.
5
-
1
.
5
)
vec2f
(
2
.
5
2
.
5
)
vec2f
(
-
1
.
5
2
.
5
)
vec2f
(
2
.
5
-
1
.
5
)
vec2f
(
-
1
.
5
2
.
5
)
vec2f
(
-
1
.
5
-
1
.
5
)
)
;
let
cell
=
vec2f
(
f32
(
ii
)
%
grid
.
x
floor
(
f32
(
ii
)
/
grid
.
y
)
)
;
/
/
Compute
the
offset
of
instance
plane
(
pre
-
grid
transformation
)
.
const
constantPlaneOffset
=
vec2f
(
11
.
/
32
.
11
.
/
32
.
)
;
const
xOffsets
=
array
(
0
.
3
.
/
16
.
1
.
/
2
.
11
.
/
16
.
)
;
const
yOffsets
=
array
(
0
.
1
.
/
4
.
7
.
/
16
.
11
.
/
16
.
)
;
let
pixelOffset
=
vec2f
(
xOffsets
[
u32
(
cell
.
x
)
]
yOffsets
[
u32
(
cell
.
y
)
]
)
;
let
posBase
=
posBases
[
vi
]
+
constantPlaneOffset
-
pixelOffset
;
/
/
Compute
the
offset
of
instance
plane
.
let
cellOffset
=
cell
/
grid
*
2
;
let
absPos
=
(
posBase
+
1
)
/
grid
-
1
+
cellOffset
;
return
VertexOut
(
vec4f
(
absPos
0
.
0
1
.
0
)
uvBases
[
vi
]
)
;
}
fragment
fn
fs_main
(
location
(
0
)
uv
:
vec2f
)
-
>
location
(
0
)
vec4f
{
return
textureSample
(
t
s
uv
)
;
}
}
)
;
const
vertexCount
=
6
;
const
instanceCount
=
kLinearRenderDim
.
reduce
(
(
sink
current
)
=
>
sink
*
current
)
;
const
render
=
t
.
runFilterRenderPipeline
(
sampler
module
format
kLinearRenderDim
vertexCount
instanceCount
)
;
t
.
expectTexelViewComparisonIsOkInTexture
(
{
texture
:
render
}
expectedColors
(
format
'
linear
'
addressModeU
addressModeV
)
kLinearRenderDim
)
;
}
)
;
g
.
test
(
'
mipmapFilter
'
)
.
desc
(
Test
that
for
filterable
formats
mipmapFilter
modes
correctly
modifies
the
sampling
.
-
format
=
{
<
filterable
formats
>
}
-
filterMode
=
{
'
nearest
'
'
linear
'
}
)
.
params
(
u
=
>
u
.
combine
(
'
format
'
kPossiblyRenderablePossiblyFilterableColorTextureFormats
)
.
beginSubcases
(
)
.
combine
(
'
filterMode
'
kMipmapFilterModes
)
)
.
fn
(
t
=
>
{
const
{
format
filterMode
}
=
t
.
params
;
t
.
skipIfTextureFormatNotSupported
(
format
)
;
t
.
skipIfTextureFormatNotFilterable
(
format
)
;
const
kTextureSize
=
8
;
const
kRenderSize
=
8
;
const
sampler
=
t
.
device
.
createSampler
(
{
mipmapFilter
:
filterMode
}
)
;
const
sampleTexture
=
t
.
createTextureFromTexelViewsMultipleMipmaps
(
[
TexelView
.
fromTexelsAsColors
(
format
(
)
=
>
{
return
{
R
:
0
.
0
G
:
0
.
0
B
:
0
.
0
A
:
1
.
0
}
;
}
)
TexelView
.
fromTexelsAsColors
(
format
_coords
=
>
{
return
{
R
:
1
.
0
G
:
1
.
0
B
:
1
.
0
A
:
1
.
0
}
;
}
)
]
{
size
:
[
kTextureSize
1
]
usage
:
GPUTextureUsage
.
TEXTURE_BINDING
|
GPUTextureUsage
.
COPY_DST
}
)
;
const
renderTexture
=
t
.
createTextureTracked
(
{
format
size
:
[
kRenderSize
1
]
usage
:
GPUTextureUsage
.
RENDER_ATTACHMENT
|
GPUTextureUsage
.
COPY_SRC
}
)
;
const
module
=
t
.
device
.
createShaderModule
(
{
code
:
group
(
0
)
binding
(
0
)
var
s
:
sampler
;
group
(
0
)
binding
(
1
)
var
t
:
texture_2d
<
f32
>
;
struct
VertexOut
{
builtin
(
position
)
pos
:
vec4f
location
(
0
)
uv
:
vec2f
}
;
vertex
fn
vs_main
(
builtin
(
vertex_index
)
vi
:
u32
builtin
(
instance_index
)
ii
:
u32
)
-
>
VertexOut
{
const
grid
=
vec2f
(
{
kRenderSize
}
.
1
.
)
;
const
pos
=
array
(
vec2f
(
1
.
0
1
.
0
)
vec2f
(
1
.
0
-
1
.
0
)
vec2f
(
-
1
.
0
-
1
.
0
)
vec2f
(
1
.
0
1
.
0
)
vec2f
(
-
1
.
0
-
1
.
0
)
vec2f
(
-
1
.
0
1
.
0
)
)
;
const
uv
=
array
(
vec2f
(
1
.
0
.
)
vec2f
(
1
.
1
.
)
vec2f
(
0
.
1
.
)
vec2f
(
1
.
0
.
)
vec2f
(
0
.
1
.
)
vec2f
(
0
.
0
.
)
)
;
/
/
Compute
the
offset
of
the
plane
.
let
cell
=
vec2f
(
f32
(
ii
)
%
grid
.
x
0
.
)
;
let
cellOffset
=
cell
/
grid
*
2
;
let
absPos
=
(
pos
[
vi
]
+
1
)
/
grid
-
1
+
cellOffset
;
let
uvFactor
=
(
1
.
/
8
.
)
*
(
1
+
(
f32
(
ii
)
/
(
grid
.
x
-
1
)
)
)
;
return
VertexOut
(
vec4f
(
absPos
0
.
0
1
.
0
)
uv
[
vi
]
*
uvFactor
)
;
}
fragment
fn
fs_main
(
location
(
0
)
uv
:
vec2f
)
-
>
location
(
0
)
vec4f
{
return
textureSample
(
t
s
uv
)
;
}
}
)
;
const
pipeline
=
t
.
device
.
createRenderPipeline
(
{
layout
:
'
auto
'
vertex
:
{
module
entryPoint
:
'
vs_main
'
}
fragment
:
{
module
entryPoint
:
'
fs_main
'
targets
:
[
{
format
}
]
}
}
)
;
const
bindgroup
=
t
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
sampler
}
{
binding
:
1
resource
:
sampleTexture
.
createView
(
)
}
]
}
)
;
const
commandEncoder
=
t
.
device
.
createCommandEncoder
(
)
;
const
renderPass
=
commandEncoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
renderTexture
.
createView
(
)
clearValue
:
[
0
0
0
0
]
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
]
}
)
;
renderPass
.
setPipeline
(
pipeline
)
;
renderPass
.
setBindGroup
(
0
bindgroup
)
;
renderPass
.
draw
(
6
kRenderSize
)
;
renderPass
.
end
(
)
;
t
.
device
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
const
buffer
=
t
.
copyWholeTextureToNewBufferSimple
(
renderTexture
0
)
;
t
.
expectGPUBufferValuesPassCheck
(
buffer
actual
=
>
{
const
layout
=
getTextureCopyLayout
(
format
'
2d
'
[
kRenderSize
1
1
]
)
;
const
view
=
TexelView
.
fromTextureDataByReference
(
format
actual
{
bytesPerRow
:
layout
.
bytesPerRow
rowsPerImage
:
layout
.
rowsPerImage
subrectOrigin
:
[
0
0
0
]
subrectSize
:
[
kRenderSize
1
1
]
}
)
;
switch
(
filterMode
)
{
case
'
linear
'
:
{
for
(
let
x
=
1
;
x
<
kRenderSize
;
x
+
+
)
{
const
{
R
:
Ri
}
=
view
.
color
(
{
x
:
x
-
1
y
:
0
z
:
0
}
)
;
const
{
R
:
Rj
}
=
view
.
color
(
{
x
y
:
0
z
:
0
}
)
;
if
(
Ri
!
>
=
Rj
!
)
{
return
Error
(
'
Linear
filtering
on
mipmaps
should
be
a
monotonically
increasing
sequence
:
\
n
'
+
view
.
toString
(
{
x
:
0
y
:
0
z
:
0
}
{
width
:
kRenderSize
height
:
1
depthOrArrayLayers
:
1
}
)
)
;
}
}
break
;
}
case
'
nearest
'
:
{
let
changes
=
0
;
for
(
let
x
=
1
;
x
<
kRenderSize
;
x
+
+
)
{
const
{
R
:
Ri
}
=
view
.
color
(
{
x
:
x
-
1
y
:
0
z
:
0
}
)
;
const
{
R
:
Rj
}
=
view
.
color
(
{
x
y
:
0
z
:
0
}
)
;
if
(
Ri
!
!
=
=
Rj
!
)
{
changes
+
+
;
}
}
if
(
changes
!
=
=
1
)
{
return
Error
(
Nearest
filtering
on
mipmaps
should
change
exactly
once
but
found
(
{
changes
}
)
:
\
n
+
view
.
toString
(
{
x
:
0
y
:
0
z
:
0
}
{
width
:
kRenderSize
height
:
1
depthOrArrayLayers
:
1
}
)
)
;
}
break
;
}
}
return
undefined
;
}
{
srcByteOffset
:
0
type
:
Uint8Array
typedLength
:
buffer
.
size
}
)
;
}
)
;
