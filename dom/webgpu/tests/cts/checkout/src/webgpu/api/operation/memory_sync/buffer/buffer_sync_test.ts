import
{
assert
unreachable
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
AllFeaturesMaxLimitsGPUTest
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
gpu_test
.
js
'
;
import
{
checkElementsEqualEither
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
util
/
check_contents
.
js
'
;
import
{
OperationContext
OperationContextHelper
}
from
'
.
.
/
operation_context_helper
.
js
'
;
export
const
kAllWriteOps
=
[
'
storage
'
'
b2b
-
copy
'
'
t2b
-
copy
'
'
write
-
buffer
'
]
as
const
;
export
const
kAllReadOps
=
[
'
input
-
vertex
'
'
input
-
index
'
'
input
-
indirect
'
'
input
-
indirect
-
index
'
'
input
-
indirect
-
dispatch
'
'
constant
-
uniform
'
'
storage
-
read
'
'
b2b
-
copy
'
'
b2t
-
copy
'
]
as
const
;
export
type
ReadOp
=
(
typeof
kAllReadOps
)
[
number
]
;
export
type
WriteOp
=
(
typeof
kAllWriteOps
)
[
number
]
;
export
type
Op
=
ReadOp
|
WriteOp
;
interface
OpInfo
{
readonly
contexts
:
OperationContext
[
]
;
}
const
kOpInfo
:
{
readonly
[
k
in
Op
]
:
OpInfo
;
}
=
{
'
write
-
buffer
'
:
{
contexts
:
[
'
queue
'
]
}
'
b2t
-
copy
'
:
{
contexts
:
[
'
command
-
encoder
'
]
}
'
b2b
-
copy
'
:
{
contexts
:
[
'
command
-
encoder
'
]
}
'
t2b
-
copy
'
:
{
contexts
:
[
'
command
-
encoder
'
]
}
storage
:
{
contexts
:
[
'
compute
-
pass
-
encoder
'
'
render
-
pass
-
encoder
'
'
render
-
bundle
-
encoder
'
]
}
'
storage
-
read
'
:
{
contexts
:
[
'
compute
-
pass
-
encoder
'
'
render
-
pass
-
encoder
'
'
render
-
bundle
-
encoder
'
]
}
'
input
-
vertex
'
:
{
contexts
:
[
'
render
-
pass
-
encoder
'
'
render
-
bundle
-
encoder
'
]
}
'
input
-
index
'
:
{
contexts
:
[
'
render
-
pass
-
encoder
'
'
render
-
bundle
-
encoder
'
]
}
'
input
-
indirect
'
:
{
contexts
:
[
'
render
-
pass
-
encoder
'
'
render
-
bundle
-
encoder
'
]
}
'
input
-
indirect
-
index
'
:
{
contexts
:
[
'
render
-
pass
-
encoder
'
'
render
-
bundle
-
encoder
'
]
}
'
input
-
indirect
-
dispatch
'
:
{
contexts
:
[
'
compute
-
pass
-
encoder
'
]
}
'
constant
-
uniform
'
:
{
contexts
:
[
'
render
-
pass
-
encoder
'
'
render
-
bundle
-
encoder
'
]
}
}
;
export
function
checkOpsValidForContext
(
ops
:
[
Op
Op
]
context
:
[
OperationContext
OperationContext
]
)
{
const
valid
=
kOpInfo
[
ops
[
0
]
]
.
contexts
.
includes
(
context
[
0
]
)
&
&
kOpInfo
[
ops
[
1
]
]
.
contexts
.
includes
(
context
[
1
]
)
;
if
(
!
valid
)
return
false
;
if
(
context
[
0
]
=
=
=
'
render
-
bundle
-
encoder
'
|
|
context
[
0
]
=
=
=
'
render
-
pass
-
encoder
'
|
|
context
[
1
]
=
=
=
'
render
-
bundle
-
encoder
'
|
|
context
[
1
]
=
=
=
'
render
-
pass
-
encoder
'
)
{
const
checkImpl
=
(
op1
:
Op
op2
:
Op
)
=
>
{
switch
(
op1
)
{
case
'
storage
'
:
switch
(
op2
)
{
case
'
storage
'
:
case
'
storage
-
read
'
:
case
'
input
-
vertex
'
:
case
'
input
-
index
'
:
case
'
input
-
indirect
'
:
case
'
input
-
indirect
-
index
'
:
case
'
constant
-
uniform
'
:
return
false
;
case
'
b2t
-
copy
'
:
case
'
t2b
-
copy
'
:
case
'
b2b
-
copy
'
:
case
'
write
-
buffer
'
:
return
true
;
}
break
;
case
'
input
-
vertex
'
:
case
'
input
-
index
'
:
case
'
input
-
indirect
'
:
case
'
input
-
indirect
-
index
'
:
case
'
constant
-
uniform
'
:
case
'
b2t
-
copy
'
:
case
'
t2b
-
copy
'
:
case
'
b2b
-
copy
'
:
case
'
write
-
buffer
'
:
break
;
}
return
true
;
}
;
return
checkImpl
(
ops
[
0
]
ops
[
1
]
)
&
&
checkImpl
(
ops
[
1
]
ops
[
0
]
)
;
}
return
true
;
}
function
readOpUsesStorageBufferInFragmentShader
(
readOp
:
ReadOp
)
{
return
(
readOp
=
=
=
'
storage
-
read
'
|
|
readOp
=
=
=
'
input
-
vertex
'
|
|
readOp
=
=
=
'
input
-
index
'
|
|
readOp
=
=
=
'
input
-
indirect
'
|
|
readOp
=
=
=
'
input
-
indirect
-
index
'
|
|
readOp
=
=
=
'
constant
-
uniform
'
)
;
}
function
writeOpUsesStorageBufferInFragmentShader
(
writeOp
:
WriteOp
)
{
return
writeOp
=
=
=
'
storage
'
|
|
writeOp
=
=
=
'
write
-
buffer
'
;
}
const
kDummyVertexShader
=
vertex
fn
vert_main
(
)
-
>
builtin
(
position
)
vec4
<
f32
>
{
return
vec4
<
f32
>
(
0
.
5
0
.
5
0
.
0
1
.
0
)
;
}
;
export
class
BufferSyncTest
extends
AllFeaturesMaxLimitsGPUTest
{
vertexBuffer
?
:
GPUBuffer
;
indexBuffer
?
:
GPUBuffer
;
tmpValueBuffers
:
(
GPUBuffer
|
undefined
)
[
]
=
[
undefined
undefined
]
;
tmpValueTextures
:
(
GPUTexture
|
undefined
)
[
]
=
[
undefined
undefined
]
;
skipIfNoSupportForStorageBuffersInFragmentStage
(
)
{
if
(
this
.
isCompatibility
)
{
this
.
skipIf
(
!
(
this
.
device
.
limits
.
maxStorageBuffersInFragmentStage
!
>
=
2
)
maxStorageBuffersInFragmentStage
(
{
this
.
device
.
limits
.
maxStorageBuffersInFragmentStage
}
)
<
2
)
;
}
}
skipIfReadOpsOrWriteOpsUsesStorageBufferInFragmentStageAndNoSupportStorageBuffersInFragmentShaders
(
readOp
:
ReadOp
|
readonly
ReadOp
[
]
writeOp
:
WriteOp
|
readonly
WriteOp
[
]
)
{
if
(
this
.
isCompatibility
)
{
const
readOps
=
Array
.
isArray
(
readOp
)
?
readOp
:
[
readOp
]
;
const
writeOps
=
Array
.
isArray
(
writeOp
)
?
writeOp
:
[
writeOp
]
;
const
readOpsUseStorageBuffersInFragmentStage
=
readOps
.
reduce
(
(
uses
op
)
=
>
uses
|
|
readOpUsesStorageBufferInFragmentShader
(
op
)
false
)
;
const
writeOpsUseStorageBuffersInFragmentStage
=
writeOps
.
reduce
(
(
uses
op
)
=
>
uses
|
|
writeOpUsesStorageBufferInFragmentShader
(
op
)
false
)
;
const
usesStorageBuffersInFragmentStage
=
readOpsUseStorageBuffersInFragmentStage
|
|
writeOpsUseStorageBuffersInFragmentStage
;
this
.
skipIf
(
usesStorageBuffersInFragmentStage
&
&
!
(
this
.
device
.
limits
.
maxStorageBuffersInFragmentStage
!
>
=
2
)
maxStorageBuffersInFragmentStage
(
{
this
.
device
.
limits
.
maxStorageBuffersInFragmentStage
}
)
<
2
)
;
}
}
async
createIntermediateBuffersAndTexturesForWriteOp
(
writeOp
:
WriteOp
slot
:
number
value
:
number
)
{
switch
(
writeOp
)
{
case
'
b2b
-
copy
'
:
this
.
tmpValueBuffers
[
slot
]
=
await
this
.
createBufferWithValue
(
value
)
;
break
;
case
'
t2b
-
copy
'
:
this
.
tmpValueTextures
[
slot
]
=
await
this
.
createTextureWithValue
(
value
)
;
break
;
default
:
break
;
}
}
async
createBuffersForReadOp
(
readOp
:
ReadOp
srcValue
:
number
opValue
:
number
)
{
switch
(
readOp
)
{
case
'
input
-
index
'
:
this
.
vertexBuffer
=
await
this
.
createBufferWithValues
(
[
srcValue
opValue
]
)
;
break
;
case
'
input
-
indirect
'
:
this
.
vertexBuffer
=
await
this
.
createBufferWithValues
(
[
opValue
]
)
;
break
;
case
'
input
-
indirect
-
index
'
:
this
.
vertexBuffer
=
await
this
.
createBufferWithValues
(
[
opValue
]
)
;
this
.
indexBuffer
=
await
this
.
createBufferWithValues
(
[
0
]
)
;
break
;
default
:
break
;
}
let
srcBuffer
:
GPUBuffer
;
switch
(
readOp
)
{
case
'
input
-
indirect
'
:
srcBuffer
=
await
this
.
createBufferWithValues
(
[
srcValue
1
0
0
]
)
;
break
;
case
'
input
-
indirect
-
index
'
:
srcBuffer
=
await
this
.
createBufferWithValues
(
[
srcValue
1
0
0
0
]
)
;
break
;
case
'
input
-
indirect
-
dispatch
'
:
srcBuffer
=
await
this
.
createBufferWithValues
(
[
srcValue
1
1
]
)
;
break
;
default
:
srcBuffer
=
await
this
.
createBufferWithValue
(
srcValue
)
;
break
;
}
const
dstBuffer
=
this
.
createBufferTracked
(
{
size
:
Uint32Array
.
BYTES_PER_ELEMENT
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
VERTEX
|
GPUBufferUsage
.
INDEX
|
GPUBufferUsage
.
INDIRECT
|
GPUBufferUsage
.
UNIFORM
}
)
;
return
{
srcBuffer
dstBuffer
}
;
}
async
createBufferWithValue
(
initValue
:
number
)
:
Promise
<
GPUBuffer
>
{
const
buffer
=
this
.
createBufferTracked
(
{
mappedAtCreation
:
true
size
:
Uint32Array
.
BYTES_PER_ELEMENT
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
VERTEX
|
GPUBufferUsage
.
INDEX
|
GPUBufferUsage
.
INDIRECT
|
GPUBufferUsage
.
UNIFORM
}
)
;
new
Uint32Array
(
buffer
.
getMappedRange
(
)
)
.
fill
(
initValue
)
;
buffer
.
unmap
(
)
;
await
this
.
queue
.
onSubmittedWorkDone
(
)
;
return
buffer
;
}
async
createBufferWithValues
(
initValues
:
number
[
]
)
:
Promise
<
GPUBuffer
>
{
const
buffer
=
this
.
createBufferTracked
(
{
mappedAtCreation
:
true
size
:
Uint32Array
.
BYTES_PER_ELEMENT
*
initValues
.
length
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
VERTEX
|
GPUBufferUsage
.
INDEX
|
GPUBufferUsage
.
INDIRECT
|
GPUBufferUsage
.
UNIFORM
}
)
;
const
bufferView
=
new
Uint32Array
(
buffer
.
getMappedRange
(
)
)
;
bufferView
.
set
(
initValues
)
;
buffer
.
unmap
(
)
;
await
this
.
queue
.
onSubmittedWorkDone
(
)
;
return
buffer
;
}
async
createTextureWithValue
(
initValue
:
number
)
:
Promise
<
GPUTexture
>
{
const
data
=
new
Uint32Array
(
1
)
.
fill
(
initValue
)
;
const
texture
=
this
.
createTextureTracked
(
{
size
:
{
width
:
1
height
:
1
depthOrArrayLayers
:
1
}
format
:
'
r32uint
'
usage
:
GPUTextureUsage
.
COPY_SRC
|
GPUTextureUsage
.
COPY_DST
}
)
;
this
.
device
.
queue
.
writeTexture
(
{
texture
mipLevel
:
0
origin
:
{
x
:
0
y
:
0
z
:
0
}
}
data
{
offset
:
0
bytesPerRow
:
256
rowsPerImage
:
1
}
{
width
:
1
height
:
1
depthOrArrayLayers
:
1
}
)
;
await
this
.
queue
.
onSubmittedWorkDone
(
)
;
return
texture
;
}
createBindGroup
(
pipeline
:
GPURenderPipeline
|
GPUComputePipeline
buffer
:
GPUBuffer
)
:
GPUBindGroup
{
return
this
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
}
}
]
}
)
;
}
createStorageWriteComputePipeline
(
value
:
number
)
:
GPUComputePipeline
{
const
wgslCompute
=
struct
Data
{
a
:
u32
}
;
group
(
0
)
binding
(
0
)
var
<
storage
read_write
>
data
:
Data
;
compute
workgroup_size
(
1
)
fn
main
(
)
{
data
.
a
=
{
value
}
u
;
}
;
return
this
.
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
wgslCompute
}
)
entryPoint
:
'
main
'
}
}
)
;
}
createTrivialRenderPipeline
(
wgslShaders
:
{
vertex
:
string
;
fragment
:
string
}
)
{
return
this
.
device
.
createRenderPipeline
(
{
layout
:
'
auto
'
vertex
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
wgslShaders
.
vertex
}
)
entryPoint
:
'
vert_main
'
}
fragment
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
wgslShaders
.
fragment
}
)
entryPoint
:
'
frag_main
'
targets
:
[
{
format
:
'
rgba8unorm
'
}
]
}
primitive
:
{
topology
:
'
point
-
list
'
}
}
)
;
}
createStorageWriteRenderPipeline
(
value
:
number
)
:
GPURenderPipeline
{
const
wgslShaders
=
{
vertex
:
kDummyVertexShader
fragment
:
struct
Data
{
a
:
u32
}
;
group
(
0
)
binding
(
0
)
var
<
storage
read_write
>
data
:
Data
;
fragment
fn
frag_main
(
)
-
>
location
(
0
)
vec4
<
f32
>
{
data
.
a
=
{
value
}
u
;
return
vec4
<
f32
>
(
)
;
/
/
result
does
'
t
matter
}
}
;
return
this
.
createTrivialRenderPipeline
(
wgslShaders
)
;
}
beginSimpleRenderPass
(
encoder
:
GPUCommandEncoder
)
:
GPURenderPassEncoder
{
const
view
=
this
.
createTextureTracked
(
{
size
:
{
width
:
1
height
:
1
depthOrArrayLayers
:
1
}
format
:
'
rgba8unorm
'
usage
:
GPUTextureUsage
.
RENDER_ATTACHMENT
}
)
.
createView
(
)
;
return
encoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
clearValue
:
{
r
:
0
.
0
g
:
1
.
0
b
:
0
.
0
a
:
1
.
0
}
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
]
}
)
;
}
encodeWriteAsStorageBufferInRenderPass
(
renderer
:
GPURenderPassEncoder
|
GPURenderBundleEncoder
buffer
:
GPUBuffer
value
:
number
)
{
const
pipeline
=
this
.
createStorageWriteRenderPipeline
(
value
)
;
const
bindGroup
=
this
.
createBindGroup
(
pipeline
buffer
)
;
renderer
.
setBindGroup
(
0
bindGroup
)
;
renderer
.
setPipeline
(
pipeline
)
;
renderer
.
draw
(
1
1
0
0
)
;
}
encodeWriteAsStorageBufferInComputePass
(
pass
:
GPUComputePassEncoder
buffer
:
GPUBuffer
value
:
number
)
{
const
pipeline
=
this
.
createStorageWriteComputePipeline
(
value
)
;
const
bindGroup
=
this
.
createBindGroup
(
pipeline
buffer
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
bindGroup
)
;
pass
.
dispatchWorkgroups
(
1
)
;
}
encodeWriteByB2BCopy
(
encoder
:
GPUCommandEncoder
buffer
:
GPUBuffer
slot
:
number
)
{
const
tmpBuffer
=
this
.
tmpValueBuffers
[
slot
]
;
assert
(
tmpBuffer
!
=
=
undefined
)
;
encoder
.
copyBufferToBuffer
(
tmpBuffer
0
buffer
0
Uint32Array
.
BYTES_PER_ELEMENT
)
;
}
encodeWriteByT2BCopy
(
encoder
:
GPUCommandEncoder
buffer
:
GPUBuffer
slot
:
number
)
{
const
tmpTexture
=
this
.
tmpValueTextures
[
slot
]
;
assert
(
tmpTexture
!
=
=
undefined
)
;
encoder
.
copyTextureToBuffer
(
{
texture
:
tmpTexture
mipLevel
:
0
origin
:
{
x
:
0
y
:
0
z
:
0
}
}
{
buffer
bytesPerRow
:
256
}
{
width
:
1
height
:
1
depthOrArrayLayers
:
1
}
)
;
}
writeByWriteBuffer
(
buffer
:
GPUBuffer
value
:
number
)
{
const
data
=
new
Uint32Array
(
1
)
.
fill
(
value
)
;
this
.
device
.
queue
.
writeBuffer
(
buffer
0
data
)
;
}
encodeWriteOp
(
helper
:
OperationContextHelper
operation
:
WriteOp
context
:
OperationContext
buffer
:
GPUBuffer
writeOpSlot
:
number
value
:
number
)
{
helper
.
ensureContext
(
context
)
;
switch
(
operation
)
{
case
'
write
-
buffer
'
:
this
.
writeByWriteBuffer
(
buffer
value
)
;
break
;
case
'
storage
'
:
switch
(
context
)
{
case
'
render
-
pass
-
encoder
'
:
assert
(
helper
.
renderPassEncoder
!
=
=
undefined
)
;
this
.
encodeWriteAsStorageBufferInRenderPass
(
helper
.
renderPassEncoder
buffer
value
)
;
break
;
case
'
render
-
bundle
-
encoder
'
:
assert
(
helper
.
renderBundleEncoder
!
=
=
undefined
)
;
this
.
encodeWriteAsStorageBufferInRenderPass
(
helper
.
renderBundleEncoder
buffer
value
)
;
break
;
case
'
compute
-
pass
-
encoder
'
:
assert
(
helper
.
computePassEncoder
!
=
=
undefined
)
;
this
.
encodeWriteAsStorageBufferInComputePass
(
helper
.
computePassEncoder
buffer
value
)
;
break
;
default
:
unreachable
(
)
;
}
break
;
case
'
b2b
-
copy
'
:
assert
(
helper
.
commandEncoder
!
=
=
undefined
)
;
this
.
encodeWriteByB2BCopy
(
helper
.
commandEncoder
buffer
writeOpSlot
)
;
break
;
case
'
t2b
-
copy
'
:
assert
(
helper
.
commandEncoder
!
=
=
undefined
)
;
this
.
encodeWriteByT2BCopy
(
helper
.
commandEncoder
buffer
writeOpSlot
)
;
break
;
default
:
unreachable
(
)
;
}
}
createStorageReadComputePipeline
(
)
:
GPUComputePipeline
{
const
wgslCompute
=
struct
Data
{
a
:
u32
}
;
group
(
0
)
binding
(
0
)
var
<
storage
read
>
srcData
:
Data
;
group
(
0
)
binding
(
1
)
var
<
storage
read_write
>
dstData
:
Data
;
compute
workgroup_size
(
1
)
fn
main
(
)
{
dstData
.
a
=
srcData
.
a
;
}
;
return
this
.
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
wgslCompute
}
)
entryPoint
:
'
main
'
}
}
)
;
}
createBindGroupSrcDstBuffer
(
pipeline
:
GPURenderPipeline
|
GPUComputePipeline
srcBuffer
:
GPUBuffer
dstBuffer
:
GPUBuffer
)
:
GPUBindGroup
{
return
this
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
srcBuffer
}
}
{
binding
:
1
resource
:
{
buffer
:
dstBuffer
}
}
]
}
)
;
}
createVertexReadRenderPipeline
(
)
:
GPURenderPipeline
{
const
wgslShaders
=
{
vertex
:
struct
VertexOutput
{
builtin
(
position
)
position
:
vec4
<
f32
>
location
(
0
)
interpolate
(
flat
either
)
data
:
u32
}
;
vertex
fn
vert_main
(
location
(
0
)
input
:
u32
)
-
>
VertexOutput
{
var
output
:
VertexOutput
;
output
.
position
=
vec4
<
f32
>
(
0
.
5
0
.
5
0
.
0
1
.
0
)
;
output
.
data
=
input
;
return
output
;
}
fragment
:
struct
Data
{
a
:
u32
}
;
group
(
0
)
binding
(
0
)
var
<
storage
read_write
>
data
:
Data
;
fragment
fn
frag_main
(
location
(
0
)
interpolate
(
flat
either
)
input
:
u32
)
-
>
location
(
0
)
vec4
<
f32
>
{
data
.
a
=
input
;
return
vec4
<
f32
>
(
)
;
/
/
result
does
'
t
matter
}
}
;
return
this
.
device
.
createRenderPipeline
(
{
layout
:
'
auto
'
vertex
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
wgslShaders
.
vertex
}
)
entryPoint
:
'
vert_main
'
buffers
:
[
{
arrayStride
:
Uint32Array
.
BYTES_PER_ELEMENT
attributes
:
[
{
shaderLocation
:
0
offset
:
0
format
:
'
uint32
'
}
]
}
]
}
fragment
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
wgslShaders
.
fragment
}
)
entryPoint
:
'
frag_main
'
targets
:
[
{
format
:
'
rgba8unorm
'
}
]
}
primitive
:
{
topology
:
'
point
-
list
'
}
}
)
;
}
createUniformReadRenderPipeline
(
)
:
GPURenderPipeline
{
const
wgslShaders
=
{
vertex
:
kDummyVertexShader
fragment
:
struct
Data
{
a
:
u32
}
;
group
(
0
)
binding
(
0
)
var
<
uniform
>
constant
:
Data
;
group
(
0
)
binding
(
1
)
var
<
storage
read_write
>
data
:
Data
;
fragment
fn
frag_main
(
)
-
>
location
(
0
)
vec4
<
f32
>
{
data
.
a
=
constant
.
a
;
return
vec4
<
f32
>
(
)
;
/
/
result
does
'
t
matter
}
}
;
return
this
.
createTrivialRenderPipeline
(
wgslShaders
)
;
}
createStorageReadRenderPipeline
(
)
:
GPURenderPipeline
{
const
wgslShaders
=
{
vertex
:
kDummyVertexShader
fragment
:
struct
Data
{
a
:
u32
}
;
group
(
0
)
binding
(
0
)
var
<
storage
read
>
srcData
:
Data
;
group
(
0
)
binding
(
1
)
var
<
storage
read_write
>
dstData
:
Data
;
fragment
fn
frag_main
(
)
-
>
location
(
0
)
vec4
<
f32
>
{
dstData
.
a
=
srcData
.
a
;
return
vec4
<
f32
>
(
)
;
/
/
result
does
'
t
matter
}
}
;
return
this
.
device
.
createRenderPipeline
(
{
layout
:
'
auto
'
vertex
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
wgslShaders
.
vertex
}
)
entryPoint
:
'
vert_main
'
}
fragment
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
wgslShaders
.
fragment
}
)
entryPoint
:
'
frag_main
'
targets
:
[
{
format
:
'
rgba8unorm
'
}
]
}
primitive
:
{
topology
:
'
point
-
list
'
}
}
)
;
}
encodeReadAsStorageBufferInComputePass
(
pass
:
GPUComputePassEncoder
srcBuffer
:
GPUBuffer
dstBuffer
:
GPUBuffer
)
{
const
pipeline
=
this
.
createStorageReadComputePipeline
(
)
;
const
bindGroup
=
this
.
createBindGroupSrcDstBuffer
(
pipeline
srcBuffer
dstBuffer
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
bindGroup
)
;
pass
.
dispatchWorkgroups
(
1
)
;
}
encodeReadAsIndirectBufferInComputePass
(
pass
:
GPUComputePassEncoder
srcBuffer
:
GPUBuffer
dstBuffer
:
GPUBuffer
value
:
number
)
{
const
pipeline
=
this
.
createStorageWriteComputePipeline
(
value
)
;
const
bindGroup
=
this
.
createBindGroup
(
pipeline
dstBuffer
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
bindGroup
)
;
pass
.
dispatchWorkgroupsIndirect
(
srcBuffer
0
)
;
}
encodeReadAsVertexBufferInRenderPass
(
renderer
:
GPURenderPassEncoder
|
GPURenderBundleEncoder
srcBuffer
:
GPUBuffer
dstBuffer
:
GPUBuffer
)
{
const
pipeline
=
this
.
createVertexReadRenderPipeline
(
)
;
const
bindGroup
=
this
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
dstBuffer
}
}
]
}
)
;
renderer
.
setBindGroup
(
0
bindGroup
)
;
renderer
.
setPipeline
(
pipeline
)
;
renderer
.
setVertexBuffer
(
0
srcBuffer
)
;
renderer
.
draw
(
1
)
;
}
encodeReadAsIndexBufferInRenderPass
(
renderer
:
GPURenderPassEncoder
|
GPURenderBundleEncoder
srcBuffer
:
GPUBuffer
dstBuffer
:
GPUBuffer
vertexBuffer
:
GPUBuffer
)
{
const
pipeline
=
this
.
createVertexReadRenderPipeline
(
)
;
const
bindGroup
=
this
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
dstBuffer
}
}
]
}
)
;
renderer
.
setBindGroup
(
0
bindGroup
)
;
renderer
.
setPipeline
(
pipeline
)
;
renderer
.
setVertexBuffer
(
0
vertexBuffer
)
;
renderer
.
setIndexBuffer
(
srcBuffer
'
uint32
'
)
;
renderer
.
drawIndexed
(
1
)
;
}
encodeReadAsIndirectBufferInRenderPass
(
renderer
:
GPURenderPassEncoder
|
GPURenderBundleEncoder
srcBuffer
:
GPUBuffer
dstBuffer
:
GPUBuffer
vertexBuffer
:
GPUBuffer
)
{
const
pipeline
=
this
.
createVertexReadRenderPipeline
(
)
;
const
bindGroup
=
this
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
dstBuffer
}
}
]
}
)
;
renderer
.
setBindGroup
(
0
bindGroup
)
;
renderer
.
setPipeline
(
pipeline
)
;
renderer
.
setVertexBuffer
(
0
vertexBuffer
)
;
renderer
.
drawIndirect
(
srcBuffer
0
)
;
}
encodeReadAsIndexedIndirectBufferInRenderPass
(
renderer
:
GPURenderPassEncoder
|
GPURenderBundleEncoder
srcBuffer
:
GPUBuffer
dstBuffer
:
GPUBuffer
vertexBuffer
:
GPUBuffer
indexBuffer
:
GPUBuffer
)
{
const
pipeline
=
this
.
createVertexReadRenderPipeline
(
)
;
const
bindGroup
=
this
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
dstBuffer
}
}
]
}
)
;
renderer
.
setBindGroup
(
0
bindGroup
)
;
renderer
.
setPipeline
(
pipeline
)
;
renderer
.
setVertexBuffer
(
0
vertexBuffer
)
;
renderer
.
setIndexBuffer
(
indexBuffer
'
uint32
'
)
;
renderer
.
drawIndexedIndirect
(
srcBuffer
0
)
;
}
encodeReadAsUniformBufferInRenderPass
(
renderer
:
GPURenderPassEncoder
|
GPURenderBundleEncoder
srcBuffer
:
GPUBuffer
dstBuffer
:
GPUBuffer
)
{
const
pipeline
=
this
.
createUniformReadRenderPipeline
(
)
;
const
bindGroup
=
this
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
srcBuffer
}
}
{
binding
:
1
resource
:
{
buffer
:
dstBuffer
}
}
]
}
)
;
renderer
.
setBindGroup
(
0
bindGroup
)
;
renderer
.
setPipeline
(
pipeline
)
;
renderer
.
draw
(
1
)
;
}
encodeReadAsStorageBufferInRenderPass
(
renderer
:
GPURenderPassEncoder
|
GPURenderBundleEncoder
srcBuffer
:
GPUBuffer
dstBuffer
:
GPUBuffer
)
{
const
pipeline
=
this
.
createStorageReadRenderPipeline
(
)
;
const
bindGroup
=
this
.
createBindGroupSrcDstBuffer
(
pipeline
srcBuffer
dstBuffer
)
;
renderer
.
setBindGroup
(
0
bindGroup
)
;
renderer
.
setPipeline
(
pipeline
)
;
renderer
.
draw
(
1
1
0
0
)
;
}
encodeReadByB2BCopy
(
encoder
:
GPUCommandEncoder
srcBuffer
:
GPUBuffer
dstBuffer
:
GPUBuffer
)
{
encoder
.
copyBufferToBuffer
(
srcBuffer
0
dstBuffer
0
Uint32Array
.
BYTES_PER_ELEMENT
)
;
}
encodeReadByB2TCopy
(
encoder
:
GPUCommandEncoder
srcBuffer
:
GPUBuffer
dstBuffer
:
GPUBuffer
)
{
const
tmpTexture
=
this
.
createTextureTracked
(
{
size
:
{
width
:
1
height
:
1
depthOrArrayLayers
:
1
}
format
:
'
r32uint
'
usage
:
GPUTextureUsage
.
COPY_SRC
|
GPUTextureUsage
.
COPY_DST
}
)
;
encoder
.
copyBufferToTexture
(
{
buffer
:
srcBuffer
bytesPerRow
:
256
}
{
texture
:
tmpTexture
mipLevel
:
0
origin
:
{
x
:
0
y
:
0
z
:
0
}
}
{
width
:
1
height
:
1
depthOrArrayLayers
:
1
}
)
;
encoder
.
copyTextureToBuffer
(
{
texture
:
tmpTexture
mipLevel
:
0
origin
:
{
x
:
0
y
:
0
z
:
0
}
}
{
buffer
:
dstBuffer
bytesPerRow
:
256
}
{
width
:
1
height
:
1
depthOrArrayLayers
:
1
}
)
;
}
encodeReadOp
(
helper
:
OperationContextHelper
operation
:
ReadOp
context
:
OperationContext
srcBuffer
:
GPUBuffer
dstBuffer
:
GPUBuffer
)
{
helper
.
ensureContext
(
context
)
;
const
renderer
=
context
=
=
=
'
render
-
bundle
-
encoder
'
?
helper
.
renderBundleEncoder
:
helper
.
renderPassEncoder
;
const
computePass
=
context
=
=
=
'
compute
-
pass
-
encoder
'
?
helper
.
computePassEncoder
:
undefined
;
switch
(
operation
)
{
case
'
input
-
vertex
'
:
assert
(
renderer
!
=
=
undefined
)
;
this
.
encodeReadAsVertexBufferInRenderPass
(
renderer
srcBuffer
dstBuffer
)
;
break
;
case
'
input
-
index
'
:
assert
(
renderer
!
=
=
undefined
)
;
assert
(
this
.
vertexBuffer
!
=
=
undefined
)
;
this
.
encodeReadAsIndexBufferInRenderPass
(
renderer
srcBuffer
dstBuffer
this
.
vertexBuffer
)
;
break
;
case
'
input
-
indirect
'
:
assert
(
renderer
!
=
=
undefined
)
;
assert
(
this
.
vertexBuffer
!
=
=
undefined
)
;
this
.
encodeReadAsIndirectBufferInRenderPass
(
renderer
srcBuffer
dstBuffer
this
.
vertexBuffer
)
;
break
;
case
'
input
-
indirect
-
index
'
:
assert
(
renderer
!
=
=
undefined
)
;
assert
(
this
.
vertexBuffer
!
=
=
undefined
)
;
assert
(
this
.
indexBuffer
!
=
=
undefined
)
;
this
.
encodeReadAsIndexedIndirectBufferInRenderPass
(
renderer
srcBuffer
dstBuffer
this
.
vertexBuffer
this
.
indexBuffer
)
;
break
;
case
'
input
-
indirect
-
dispatch
'
:
assert
(
computePass
!
=
=
undefined
)
;
this
.
encodeReadAsIndirectBufferInComputePass
(
computePass
srcBuffer
dstBuffer
1
)
;
break
;
case
'
constant
-
uniform
'
:
assert
(
renderer
!
=
=
undefined
)
;
this
.
encodeReadAsUniformBufferInRenderPass
(
renderer
srcBuffer
dstBuffer
)
;
break
;
case
'
storage
-
read
'
:
switch
(
context
)
{
case
'
render
-
pass
-
encoder
'
:
case
'
render
-
bundle
-
encoder
'
:
assert
(
renderer
!
=
=
undefined
)
;
this
.
encodeReadAsStorageBufferInRenderPass
(
renderer
srcBuffer
dstBuffer
)
;
break
;
case
'
compute
-
pass
-
encoder
'
:
assert
(
computePass
!
=
=
undefined
)
;
this
.
encodeReadAsStorageBufferInComputePass
(
computePass
srcBuffer
dstBuffer
)
;
break
;
default
:
unreachable
(
)
;
}
break
;
case
'
b2b
-
copy
'
:
assert
(
helper
.
commandEncoder
!
=
=
undefined
)
;
this
.
encodeReadByB2BCopy
(
helper
.
commandEncoder
srcBuffer
dstBuffer
)
;
break
;
case
'
b2t
-
copy
'
:
assert
(
helper
.
commandEncoder
!
=
=
undefined
)
;
this
.
encodeReadByB2TCopy
(
helper
.
commandEncoder
srcBuffer
dstBuffer
)
;
break
;
default
:
unreachable
(
)
;
}
}
verifyData
(
buffer
:
GPUBuffer
expectedValue
:
number
)
{
const
bufferData
=
new
Uint32Array
(
1
)
;
bufferData
[
0
]
=
expectedValue
;
this
.
expectGPUBufferValuesEqual
(
buffer
bufferData
)
;
}
verifyDataTwoValidValues
(
buffer
:
GPUBuffer
expectedValue1
:
number
expectedValue2
:
number
)
{
const
bufferData1
=
new
Uint32Array
(
1
)
;
bufferData1
[
0
]
=
expectedValue1
;
const
bufferData2
=
new
Uint32Array
(
1
)
;
bufferData2
[
0
]
=
expectedValue2
;
this
.
expectGPUBufferValuesPassCheck
(
buffer
a
=
>
checkElementsEqualEither
(
a
[
bufferData1
bufferData2
]
)
{
type
:
Uint32Array
typedLength
:
1
}
)
;
}
}
