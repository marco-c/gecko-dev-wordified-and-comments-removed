import
{
assert
unreachable
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
EncodableTextureFormat
}
from
'
.
.
/
.
.
/
.
.
/
format_info
.
js
'
;
import
{
GPUTest
}
from
'
.
.
/
.
.
/
.
.
/
gpu_test
.
js
'
;
export
const
kOperationBoundaries
=
[
'
queue
-
op
'
'
command
-
buffer
'
'
pass
'
'
execute
-
bundles
'
'
render
-
bundle
'
'
dispatch
'
'
draw
'
]
as
const
;
export
type
OperationBoundary
=
(
typeof
kOperationBoundaries
)
[
number
]
;
export
const
kOperationContexts
=
[
'
queue
'
'
command
-
encoder
'
'
compute
-
pass
-
encoder
'
'
render
-
pass
-
encoder
'
'
render
-
bundle
-
encoder
'
]
as
const
;
export
type
OperationContext
=
(
typeof
kOperationContexts
)
[
number
]
;
interface
BoundaryInfo
{
readonly
contexts
:
[
OperationContext
OperationContext
]
[
]
;
}
function
combineContexts
(
as
:
readonly
OperationContext
[
]
bs
:
readonly
OperationContext
[
]
)
:
[
OperationContext
OperationContext
]
[
]
{
const
result
:
[
OperationContext
OperationContext
]
[
]
=
[
]
;
for
(
const
a
of
as
)
{
for
(
const
b
of
bs
)
{
result
.
push
(
[
a
b
]
)
;
}
}
return
result
;
}
const
queueContexts
=
combineContexts
(
kOperationContexts
kOperationContexts
)
;
const
commandBufferContexts
=
combineContexts
(
kOperationContexts
.
filter
(
c
=
>
c
!
=
=
'
queue
'
)
kOperationContexts
.
filter
(
c
=
>
c
!
=
=
'
queue
'
)
)
;
export
const
kBoundaryInfo
:
{
readonly
[
k
in
OperationBoundary
]
:
BoundaryInfo
;
}
=
{
'
queue
-
op
'
:
{
contexts
:
queueContexts
}
'
command
-
buffer
'
:
{
contexts
:
commandBufferContexts
}
pass
:
{
contexts
:
[
[
'
compute
-
pass
-
encoder
'
'
compute
-
pass
-
encoder
'
]
[
'
compute
-
pass
-
encoder
'
'
render
-
pass
-
encoder
'
]
[
'
render
-
pass
-
encoder
'
'
compute
-
pass
-
encoder
'
]
[
'
render
-
pass
-
encoder
'
'
render
-
pass
-
encoder
'
]
[
'
render
-
bundle
-
encoder
'
'
render
-
pass
-
encoder
'
]
[
'
render
-
pass
-
encoder
'
'
render
-
bundle
-
encoder
'
]
[
'
render
-
bundle
-
encoder
'
'
render
-
bundle
-
encoder
'
]
]
}
'
execute
-
bundles
'
:
{
contexts
:
[
[
'
render
-
bundle
-
encoder
'
'
render
-
bundle
-
encoder
'
]
]
}
'
render
-
bundle
'
:
{
contexts
:
[
[
'
render
-
bundle
-
encoder
'
'
render
-
pass
-
encoder
'
]
[
'
render
-
pass
-
encoder
'
'
render
-
bundle
-
encoder
'
]
[
'
render
-
bundle
-
encoder
'
'
render
-
bundle
-
encoder
'
]
]
}
dispatch
:
{
contexts
:
[
[
'
compute
-
pass
-
encoder
'
'
compute
-
pass
-
encoder
'
]
]
}
draw
:
{
contexts
:
[
[
'
render
-
pass
-
encoder
'
'
render
-
pass
-
encoder
'
]
[
'
render
-
bundle
-
encoder
'
'
render
-
pass
-
encoder
'
]
[
'
render
-
pass
-
encoder
'
'
render
-
bundle
-
encoder
'
]
]
}
}
;
export
class
OperationContextHelper
{
protected
currentContext
:
OperationContext
=
'
queue
'
;
queue
:
GPUQueue
;
commandEncoder
?
:
GPUCommandEncoder
;
computePassEncoder
?
:
GPUComputePassEncoder
;
renderPassEncoder
?
:
GPURenderPassEncoder
;
renderBundleEncoder
?
:
GPURenderBundleEncoder
;
protected
t
:
GPUTest
;
protected
device
:
GPUDevice
;
protected
commandBuffers
:
GPUCommandBuffer
[
]
=
[
]
;
protected
renderBundles
:
GPURenderBundle
[
]
=
[
]
;
public
readonly
kTextureSize
=
[
4
4
]
as
const
;
public
readonly
kTextureFormat
:
EncodableTextureFormat
=
'
rgba8unorm
'
;
constructor
(
t
:
GPUTest
)
{
this
.
t
=
t
;
this
.
device
=
t
.
device
;
this
.
queue
=
t
.
device
.
queue
;
}
ensureSubmit
(
)
{
this
.
ensureContext
(
'
queue
'
)
;
this
.
flushCommandBuffers
(
)
;
}
private
popContext
(
)
:
GPURenderBundle
|
GPUCommandBuffer
|
null
{
switch
(
this
.
currentContext
)
{
case
'
queue
'
:
unreachable
(
)
;
break
;
case
'
command
-
encoder
'
:
{
assert
(
this
.
commandEncoder
!
=
=
undefined
)
;
const
commandBuffer
=
this
.
commandEncoder
.
finish
(
)
;
this
.
commandEncoder
=
undefined
;
this
.
currentContext
=
'
queue
'
;
return
commandBuffer
;
}
case
'
compute
-
pass
-
encoder
'
:
assert
(
this
.
computePassEncoder
!
=
=
undefined
)
;
this
.
computePassEncoder
.
end
(
)
;
this
.
computePassEncoder
=
undefined
;
this
.
currentContext
=
'
command
-
encoder
'
;
break
;
case
'
render
-
pass
-
encoder
'
:
assert
(
this
.
renderPassEncoder
!
=
=
undefined
)
;
this
.
renderPassEncoder
.
end
(
)
;
this
.
renderPassEncoder
=
undefined
;
this
.
currentContext
=
'
command
-
encoder
'
;
break
;
case
'
render
-
bundle
-
encoder
'
:
{
assert
(
this
.
renderBundleEncoder
!
=
=
undefined
)
;
const
renderBundle
=
this
.
renderBundleEncoder
.
finish
(
)
;
this
.
renderBundleEncoder
=
undefined
;
this
.
currentContext
=
'
render
-
pass
-
encoder
'
;
return
renderBundle
;
}
}
return
null
;
}
private
makeDummyAttachment
(
)
:
GPURenderPassColorAttachment
{
const
texture
=
this
.
t
.
trackForCleanup
(
this
.
device
.
createTexture
(
{
format
:
this
.
kTextureFormat
size
:
this
.
kTextureSize
usage
:
GPUTextureUsage
.
RENDER_ATTACHMENT
}
)
)
;
return
{
view
:
texture
.
createView
(
)
loadOp
:
'
load
'
storeOp
:
'
store
'
}
;
}
ensureContext
(
context
:
OperationContext
)
{
const
ancestorContext
=
kOperationContexts
[
Math
.
min
(
kOperationContexts
.
indexOf
(
context
)
kOperationContexts
.
indexOf
(
this
.
currentContext
)
)
]
;
while
(
this
.
currentContext
!
=
=
ancestorContext
)
{
if
(
this
.
currentContext
=
=
=
'
render
-
pass
-
encoder
'
)
{
this
.
flushRenderBundles
(
)
;
}
const
result
=
this
.
popContext
(
)
;
if
(
result
)
{
if
(
result
instanceof
GPURenderBundle
)
{
this
.
renderBundles
.
push
(
result
)
;
}
else
{
this
.
commandBuffers
.
push
(
result
)
;
}
}
}
if
(
this
.
currentContext
=
=
=
context
)
{
return
;
}
switch
(
context
)
{
case
'
queue
'
:
unreachable
(
)
;
break
;
case
'
command
-
encoder
'
:
assert
(
this
.
currentContext
=
=
=
'
queue
'
)
;
this
.
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
break
;
case
'
compute
-
pass
-
encoder
'
:
switch
(
this
.
currentContext
)
{
case
'
queue
'
:
this
.
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
case
'
command
-
encoder
'
:
assert
(
this
.
commandEncoder
!
=
=
undefined
)
;
this
.
computePassEncoder
=
this
.
commandEncoder
.
beginComputePass
(
)
;
break
;
case
'
compute
-
pass
-
encoder
'
:
case
'
render
-
bundle
-
encoder
'
:
case
'
render
-
pass
-
encoder
'
:
unreachable
(
)
;
}
break
;
case
'
render
-
pass
-
encoder
'
:
switch
(
this
.
currentContext
)
{
case
'
queue
'
:
this
.
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
case
'
command
-
encoder
'
:
assert
(
this
.
commandEncoder
!
=
=
undefined
)
;
this
.
renderPassEncoder
=
this
.
commandEncoder
.
beginRenderPass
(
{
colorAttachments
:
[
this
.
makeDummyAttachment
(
)
]
}
)
;
break
;
case
'
render
-
pass
-
encoder
'
:
case
'
render
-
bundle
-
encoder
'
:
case
'
compute
-
pass
-
encoder
'
:
unreachable
(
)
;
}
break
;
case
'
render
-
bundle
-
encoder
'
:
switch
(
this
.
currentContext
)
{
case
'
queue
'
:
this
.
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
case
'
command
-
encoder
'
:
assert
(
this
.
commandEncoder
!
=
=
undefined
)
;
this
.
renderPassEncoder
=
this
.
commandEncoder
.
beginRenderPass
(
{
colorAttachments
:
[
this
.
makeDummyAttachment
(
)
]
}
)
;
case
'
render
-
pass
-
encoder
'
:
this
.
renderBundleEncoder
=
this
.
device
.
createRenderBundleEncoder
(
{
colorFormats
:
[
this
.
kTextureFormat
]
}
)
;
break
;
case
'
render
-
bundle
-
encoder
'
:
case
'
compute
-
pass
-
encoder
'
:
unreachable
(
)
;
}
break
;
}
this
.
currentContext
=
context
;
}
private
flushRenderBundles
(
)
{
assert
(
this
.
renderPassEncoder
!
=
=
undefined
)
;
if
(
this
.
renderBundles
.
length
)
{
this
.
renderPassEncoder
.
executeBundles
(
this
.
renderBundles
)
;
this
.
renderBundles
=
[
]
;
}
}
private
flushCommandBuffers
(
)
{
if
(
this
.
commandBuffers
.
length
)
{
this
.
queue
.
submit
(
this
.
commandBuffers
)
;
this
.
commandBuffers
=
[
]
;
}
}
ensureBoundary
(
boundary
:
OperationBoundary
)
{
switch
(
boundary
)
{
case
'
command
-
buffer
'
:
this
.
ensureContext
(
'
queue
'
)
;
break
;
case
'
queue
-
op
'
:
this
.
ensureContext
(
'
queue
'
)
;
this
.
flushCommandBuffers
(
)
;
break
;
case
'
dispatch
'
:
assert
(
this
.
currentContext
=
=
=
'
compute
-
pass
-
encoder
'
)
;
break
;
case
'
draw
'
:
assert
(
this
.
currentContext
=
=
=
'
render
-
pass
-
encoder
'
|
|
this
.
currentContext
=
=
=
'
render
-
bundle
-
encoder
'
)
;
break
;
case
'
pass
'
:
this
.
ensureContext
(
'
command
-
encoder
'
)
;
break
;
case
'
render
-
bundle
'
:
this
.
ensureContext
(
'
render
-
pass
-
encoder
'
)
;
break
;
case
'
execute
-
bundles
'
:
this
.
ensureContext
(
'
render
-
pass
-
encoder
'
)
;
this
.
flushRenderBundles
(
)
;
break
;
}
}
}
