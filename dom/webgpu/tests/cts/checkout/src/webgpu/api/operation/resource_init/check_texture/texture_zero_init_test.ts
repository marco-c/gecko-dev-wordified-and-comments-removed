import
{
TestCaseRecorder
TestParams
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
common
/
framework
/
fixture
.
js
'
;
import
{
kUnitCaseParamsBuilder
ParamTypeOf
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
common
/
framework
/
params_builder
.
js
'
;
import
{
assert
unreachable
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
kTextureAspects
kTextureDimensions
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
capability_info
.
js
'
;
import
{
GPUConst
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
constants
.
js
'
;
import
{
kTextureFormatInfo
kUncompressedTextureFormats
textureDimensionAndFormatCompatible
UncompressedTextureFormat
EncodableTextureFormat
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
format_info
.
js
'
;
import
{
GPUTest
GPUTestSubcaseBatchState
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
gpu_test
.
js
'
;
import
{
virtualMipSize
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
util
/
texture
/
base
.
js
'
;
import
{
createTextureUploadBuffer
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
util
/
texture
/
layout
.
js
'
;
import
{
BeginEndRange
SubresourceRange
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
util
/
texture
/
subresource
.
js
'
;
import
{
PerTexelComponent
kTexelRepresentationInfo
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
util
/
texture
/
texel_data
.
js
'
;
export
enum
UninitializeMethod
{
Creation
=
'
Creation
'
StoreOpClear
=
'
StoreOpClear
'
}
const
kUninitializeMethods
=
Object
.
keys
(
UninitializeMethod
)
as
UninitializeMethod
[
]
;
export
const
enum
ReadMethod
{
Sample
=
'
Sample
'
CopyToBuffer
=
'
CopyToBuffer
'
CopyToTexture
=
'
CopyToTexture
'
DepthTest
=
'
DepthTest
'
StencilTest
=
'
StencilTest
'
ColorBlending
=
'
ColorBlending
'
Storage
=
'
Storage
'
}
type
MipLevels
=
1
|
5
;
const
kMipLevelCounts
:
MipLevels
[
]
=
[
1
5
]
;
const
kUninitializedMipRangesToTest
:
{
[
k
in
MipLevels
]
:
BeginEndRange
[
]
}
=
{
1
:
[
{
begin
:
0
end
:
1
}
]
5
:
[
{
begin
:
0
end
:
2
}
{
begin
:
3
end
:
4
}
]
}
;
const
kSampleCounts
:
number
[
]
=
[
1
4
]
;
type
LayerCounts
=
1
|
7
;
const
kUninitializedLayerRangesToTest
:
{
[
k
in
LayerCounts
]
:
BeginEndRange
[
]
}
=
{
1
:
[
{
begin
:
0
end
:
1
}
]
7
:
[
{
begin
:
2
end
:
4
}
{
begin
:
6
end
:
7
}
]
}
;
export
const
enum
InitializedState
{
Canary
Zero
}
const
initializedStateAsFloat
=
{
[
InitializedState
.
Zero
]
:
0
[
InitializedState
.
Canary
]
:
1
}
;
const
initializedStateAsUint
=
{
[
InitializedState
.
Zero
]
:
0
[
InitializedState
.
Canary
]
:
1
}
;
const
initializedStateAsSint
=
{
[
InitializedState
.
Zero
]
:
0
[
InitializedState
.
Canary
]
:
-
1
}
;
function
initializedStateAsColor
(
state
:
InitializedState
format
:
GPUTextureFormat
)
:
[
number
number
number
number
]
{
let
value
;
if
(
format
.
indexOf
(
'
uint
'
)
!
=
=
-
1
)
{
value
=
initializedStateAsUint
[
state
]
;
}
else
if
(
format
.
indexOf
(
'
sint
'
)
!
=
=
-
1
)
{
value
=
initializedStateAsSint
[
state
]
;
}
else
{
value
=
initializedStateAsFloat
[
state
]
;
}
return
[
value
value
value
value
]
;
}
const
initializedStateAsDepth
=
{
[
InitializedState
.
Zero
]
:
0
[
InitializedState
.
Canary
]
:
0
.
8
}
;
const
initializedStateAsStencil
=
{
[
InitializedState
.
Zero
]
:
0
[
InitializedState
.
Canary
]
:
42
}
;
function
allAspectsCopyDst
(
info
:
(
typeof
kTextureFormatInfo
)
[
UncompressedTextureFormat
]
)
{
return
(
(
!
info
.
color
|
|
info
.
color
.
copyDst
)
&
&
(
!
info
.
depth
|
|
info
.
depth
.
copyDst
)
&
&
(
!
info
.
stencil
|
|
info
.
stencil
.
copyDst
)
)
;
}
export
function
getRequiredTextureUsage
(
format
:
UncompressedTextureFormat
sampleCount
:
number
uninitializeMethod
:
UninitializeMethod
readMethod
:
ReadMethod
)
:
GPUTextureUsageFlags
{
let
usage
:
GPUTextureUsageFlags
=
GPUConst
.
TextureUsage
.
COPY_DST
;
switch
(
uninitializeMethod
)
{
case
UninitializeMethod
.
Creation
:
break
;
case
UninitializeMethod
.
StoreOpClear
:
usage
|
=
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
;
break
;
default
:
unreachable
(
)
;
}
switch
(
readMethod
)
{
case
ReadMethod
.
CopyToBuffer
:
case
ReadMethod
.
CopyToTexture
:
usage
|
=
GPUConst
.
TextureUsage
.
COPY_SRC
;
break
;
case
ReadMethod
.
Sample
:
usage
|
=
GPUConst
.
TextureUsage
.
TEXTURE_BINDING
;
break
;
case
ReadMethod
.
Storage
:
usage
|
=
GPUConst
.
TextureUsage
.
STORAGE_BINDING
;
break
;
case
ReadMethod
.
DepthTest
:
case
ReadMethod
.
StencilTest
:
case
ReadMethod
.
ColorBlending
:
usage
|
=
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
;
break
;
default
:
unreachable
(
)
;
}
if
(
sampleCount
>
1
)
{
usage
|
=
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
;
}
const
info
=
kTextureFormatInfo
[
format
]
;
if
(
!
allAspectsCopyDst
(
info
)
)
{
if
(
info
.
color
)
assert
(
!
!
info
.
colorRender
'
not
implemented
for
non
-
renderable
color
'
)
;
usage
|
=
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
;
}
return
usage
;
}
export
class
TextureZeroInitTest
extends
GPUTest
{
readonly
stateToTexelComponents
:
{
[
k
in
InitializedState
]
:
PerTexelComponent
<
number
>
}
;
private
p
:
TextureZeroParams
;
constructor
(
sharedState
:
GPUTestSubcaseBatchState
rec
:
TestCaseRecorder
params
:
TestParams
)
{
super
(
sharedState
rec
params
)
;
this
.
p
=
params
as
TextureZeroParams
;
const
stateToTexelComponents
=
(
state
:
InitializedState
)
=
>
{
const
[
R
G
B
A
]
=
initializedStateAsColor
(
state
this
.
p
.
format
)
;
return
{
R
G
B
A
Depth
:
initializedStateAsDepth
[
state
]
Stencil
:
initializedStateAsStencil
[
state
]
}
;
}
;
this
.
stateToTexelComponents
=
{
[
InitializedState
.
Zero
]
:
stateToTexelComponents
(
InitializedState
.
Zero
)
[
InitializedState
.
Canary
]
:
stateToTexelComponents
(
InitializedState
.
Canary
)
}
;
}
get
textureWidth
(
)
:
number
{
let
width
=
1
<
<
this
.
p
.
mipLevelCount
;
if
(
this
.
p
.
nonPowerOfTwo
)
{
width
=
2
*
width
-
1
;
}
return
width
;
}
get
textureHeight
(
)
:
number
{
if
(
this
.
p
.
dimension
=
=
=
'
1d
'
)
{
return
1
;
}
let
height
=
1
<
<
this
.
p
.
mipLevelCount
;
if
(
this
.
p
.
nonPowerOfTwo
)
{
height
=
2
*
height
-
1
;
}
return
height
;
}
get
textureDepth
(
)
:
number
{
return
this
.
p
.
dimension
=
=
=
'
3d
'
?
11
:
1
;
}
get
textureDepthOrArrayLayers
(
)
:
number
{
return
this
.
p
.
dimension
=
=
=
'
2d
'
?
this
.
p
.
layerCount
:
this
.
textureDepth
;
}
*
iterateUninitializedSubresources
(
)
:
Generator
<
SubresourceRange
>
{
for
(
const
mipRange
of
kUninitializedMipRangesToTest
[
this
.
p
.
mipLevelCount
]
)
{
for
(
const
layerRange
of
kUninitializedLayerRangesToTest
[
this
.
p
.
layerCount
]
)
{
yield
new
SubresourceRange
(
{
mipRange
layerRange
}
)
;
}
}
}
*
iterateInitializedSubresources
(
)
:
Generator
<
SubresourceRange
>
{
const
uninitialized
:
boolean
[
]
[
]
=
new
Array
(
this
.
p
.
mipLevelCount
)
;
for
(
let
level
=
0
;
level
<
uninitialized
.
length
;
+
+
level
)
{
uninitialized
[
level
]
=
new
Array
(
this
.
p
.
layerCount
)
;
}
for
(
const
subresources
of
this
.
iterateUninitializedSubresources
(
)
)
{
for
(
const
{
level
layer
}
of
subresources
.
each
(
)
)
{
uninitialized
[
level
]
[
layer
]
=
true
;
}
}
for
(
let
level
=
0
;
level
<
uninitialized
.
length
;
+
+
level
)
{
for
(
let
layer
=
0
;
layer
<
uninitialized
[
level
]
.
length
;
+
+
layer
)
{
if
(
!
uninitialized
[
level
]
[
layer
]
)
{
yield
new
SubresourceRange
(
{
mipRange
:
{
begin
:
level
count
:
1
}
layerRange
:
{
begin
:
layer
count
:
1
}
}
)
;
}
}
}
}
*
generateTextureViewDescriptorsForRendering
(
aspect
:
GPUTextureAspect
subresourceRange
?
:
SubresourceRange
)
:
Generator
<
GPUTextureViewDescriptor
>
{
const
viewDescriptor
:
GPUTextureViewDescriptor
=
{
dimension
:
'
2d
'
aspect
}
;
if
(
subresourceRange
=
=
=
undefined
)
{
return
viewDescriptor
;
}
for
(
const
{
level
layer
}
of
subresourceRange
.
each
(
)
)
{
yield
{
.
.
.
viewDescriptor
baseMipLevel
:
level
mipLevelCount
:
1
baseArrayLayer
:
layer
arrayLayerCount
:
1
}
;
}
}
private
initializeWithStoreOp
(
state
:
InitializedState
texture
:
GPUTexture
subresourceRange
?
:
SubresourceRange
)
:
void
{
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
commandEncoder
.
pushDebugGroup
(
'
initializeWithStoreOp
'
)
;
for
(
const
viewDescriptor
of
this
.
generateTextureViewDescriptorsForRendering
(
'
all
'
subresourceRange
)
)
{
if
(
kTextureFormatInfo
[
this
.
p
.
format
]
.
color
)
{
commandEncoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
texture
.
createView
(
viewDescriptor
)
storeOp
:
'
store
'
clearValue
:
initializedStateAsColor
(
state
this
.
p
.
format
)
loadOp
:
'
clear
'
}
]
}
)
.
end
(
)
;
}
else
{
const
depthStencilAttachment
:
GPURenderPassDepthStencilAttachment
=
{
view
:
texture
.
createView
(
viewDescriptor
)
}
;
if
(
kTextureFormatInfo
[
this
.
p
.
format
]
.
depth
)
{
depthStencilAttachment
.
depthClearValue
=
initializedStateAsDepth
[
state
]
;
depthStencilAttachment
.
depthLoadOp
=
'
clear
'
;
depthStencilAttachment
.
depthStoreOp
=
'
store
'
;
}
if
(
kTextureFormatInfo
[
this
.
p
.
format
]
.
stencil
)
{
depthStencilAttachment
.
stencilClearValue
=
initializedStateAsStencil
[
state
]
;
depthStencilAttachment
.
stencilLoadOp
=
'
clear
'
;
depthStencilAttachment
.
stencilStoreOp
=
'
store
'
;
}
commandEncoder
.
beginRenderPass
(
{
colorAttachments
:
[
]
depthStencilAttachment
}
)
.
end
(
)
;
}
}
commandEncoder
.
popDebugGroup
(
)
;
this
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
}
private
initializeWithCopy
(
texture
:
GPUTexture
state
:
InitializedState
subresourceRange
:
SubresourceRange
)
:
void
{
assert
(
this
.
p
.
format
in
kTextureFormatInfo
)
;
const
format
=
this
.
p
.
format
as
EncodableTextureFormat
;
const
firstSubresource
=
subresourceRange
.
each
(
)
.
next
(
)
.
value
;
assert
(
typeof
firstSubresource
!
=
=
'
undefined
'
)
;
const
[
largestWidth
largestHeight
largestDepth
]
=
virtualMipSize
(
this
.
p
.
dimension
[
this
.
textureWidth
this
.
textureHeight
this
.
textureDepth
]
firstSubresource
.
level
)
;
const
rep
=
kTexelRepresentationInfo
[
format
]
;
const
texelData
=
new
Uint8Array
(
rep
.
pack
(
rep
.
encode
(
this
.
stateToTexelComponents
[
state
]
)
)
)
;
const
{
buffer
bytesPerRow
rowsPerImage
}
=
createTextureUploadBuffer
(
texelData
this
.
device
format
this
.
p
.
dimension
[
largestWidth
largestHeight
largestDepth
]
)
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
for
(
const
{
level
layer
}
of
subresourceRange
.
each
(
)
)
{
const
[
width
height
depth
]
=
virtualMipSize
(
this
.
p
.
dimension
[
this
.
textureWidth
this
.
textureHeight
this
.
textureDepth
]
level
)
;
commandEncoder
.
copyBufferToTexture
(
{
buffer
bytesPerRow
rowsPerImage
}
{
texture
mipLevel
:
level
origin
:
{
x
:
0
y
:
0
z
:
layer
}
}
{
width
height
depthOrArrayLayers
:
depth
}
)
;
}
this
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
buffer
.
destroy
(
)
;
}
initializeTexture
(
texture
:
GPUTexture
state
:
InitializedState
subresourceRange
:
SubresourceRange
)
:
void
{
const
info
=
kTextureFormatInfo
[
this
.
p
.
format
]
;
if
(
this
.
p
.
sampleCount
>
1
|
|
!
allAspectsCopyDst
(
info
)
)
{
if
(
info
.
color
)
assert
(
!
!
info
.
colorRender
'
not
implemented
for
non
-
renderable
color
'
)
;
this
.
initializeWithStoreOp
(
state
texture
subresourceRange
)
;
}
else
{
this
.
initializeWithCopy
(
texture
state
subresourceRange
)
;
}
}
discardTexture
(
texture
:
GPUTexture
subresourceRange
:
SubresourceRange
)
:
void
{
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
commandEncoder
.
pushDebugGroup
(
'
discardTexture
'
)
;
for
(
const
desc
of
this
.
generateTextureViewDescriptorsForRendering
(
'
all
'
subresourceRange
)
)
{
if
(
kTextureFormatInfo
[
this
.
p
.
format
]
.
color
)
{
commandEncoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
texture
.
createView
(
desc
)
storeOp
:
'
discard
'
loadOp
:
'
load
'
}
]
}
)
.
end
(
)
;
}
else
{
const
depthStencilAttachment
:
GPURenderPassDepthStencilAttachment
=
{
view
:
texture
.
createView
(
desc
)
}
;
if
(
kTextureFormatInfo
[
this
.
p
.
format
]
.
depth
)
{
depthStencilAttachment
.
depthLoadOp
=
'
load
'
;
depthStencilAttachment
.
depthStoreOp
=
'
discard
'
;
}
if
(
kTextureFormatInfo
[
this
.
p
.
format
]
.
stencil
)
{
depthStencilAttachment
.
stencilLoadOp
=
'
load
'
;
depthStencilAttachment
.
stencilStoreOp
=
'
discard
'
;
}
commandEncoder
.
beginRenderPass
(
{
colorAttachments
:
[
]
depthStencilAttachment
}
)
.
end
(
)
;
}
}
commandEncoder
.
popDebugGroup
(
)
;
this
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
}
}
export
const
kTestParams
=
kUnitCaseParamsBuilder
.
combine
(
'
dimension
'
kTextureDimensions
)
.
combine
(
'
readMethod
'
[
ReadMethod
.
CopyToBuffer
ReadMethod
.
CopyToTexture
ReadMethod
.
Sample
ReadMethod
.
DepthTest
ReadMethod
.
StencilTest
]
)
.
combine
(
'
format
'
kUncompressedTextureFormats
)
.
filter
(
(
{
dimension
format
}
)
=
>
textureDimensionAndFormatCompatible
(
dimension
format
)
)
.
beginSubcases
(
)
.
combine
(
'
aspect
'
kTextureAspects
)
.
unless
(
(
{
readMethod
format
aspect
}
)
=
>
{
const
info
=
kTextureFormatInfo
[
format
]
;
return
(
(
readMethod
=
=
=
ReadMethod
.
DepthTest
&
&
(
!
info
.
depth
|
|
aspect
=
=
=
'
stencil
-
only
'
)
)
|
|
(
readMethod
=
=
=
ReadMethod
.
StencilTest
&
&
(
!
info
.
stencil
|
|
aspect
=
=
=
'
depth
-
only
'
)
)
|
|
(
readMethod
=
=
=
ReadMethod
.
ColorBlending
&
&
!
info
.
color
)
|
|
(
readMethod
=
=
=
ReadMethod
.
Sample
&
&
(
!
!
info
.
depth
|
|
!
!
info
.
stencil
)
)
|
|
(
aspect
=
=
=
'
depth
-
only
'
&
&
!
info
.
depth
)
|
|
(
aspect
=
=
=
'
stencil
-
only
'
&
&
!
info
.
stencil
)
|
|
(
aspect
=
=
=
'
all
'
&
&
!
!
info
.
depth
&
&
!
!
info
.
stencil
)
|
|
(
(
readMethod
=
=
=
ReadMethod
.
CopyToBuffer
|
|
readMethod
=
=
=
ReadMethod
.
CopyToTexture
)
&
&
(
format
=
=
=
'
depth24plus
'
|
|
format
=
=
=
'
depth24plus
-
stencil8
'
)
)
)
;
}
)
.
combine
(
'
mipLevelCount
'
kMipLevelCounts
)
.
unless
(
p
=
>
p
.
dimension
=
=
=
'
1d
'
&
&
p
.
mipLevelCount
!
=
=
1
)
.
combine
(
'
sampleCount
'
kSampleCounts
)
.
unless
(
(
{
readMethod
sampleCount
}
)
=
>
sampleCount
>
1
&
&
(
readMethod
=
=
=
ReadMethod
.
CopyToBuffer
|
|
readMethod
=
=
=
ReadMethod
.
CopyToTexture
)
)
.
unless
(
(
{
sampleCount
mipLevelCount
}
)
=
>
sampleCount
>
1
&
&
mipLevelCount
>
1
)
.
combine
(
'
uninitializeMethod
'
kUninitializeMethods
)
.
unless
(
(
{
dimension
readMethod
uninitializeMethod
format
sampleCount
}
)
=
>
{
const
formatInfo
=
kTextureFormatInfo
[
format
]
;
return
(
dimension
!
=
=
'
2d
'
&
&
(
sampleCount
>
1
|
|
!
!
formatInfo
.
depth
|
|
!
!
formatInfo
.
stencil
|
|
readMethod
=
=
=
ReadMethod
.
DepthTest
|
|
readMethod
=
=
=
ReadMethod
.
StencilTest
|
|
readMethod
=
=
=
ReadMethod
.
ColorBlending
|
|
uninitializeMethod
=
=
=
UninitializeMethod
.
StoreOpClear
)
)
;
}
)
.
expandWithParams
(
function
*
(
{
dimension
}
)
{
switch
(
dimension
)
{
case
'
2d
'
:
yield
{
layerCount
:
1
as
LayerCounts
}
;
yield
{
layerCount
:
7
as
LayerCounts
}
;
break
;
case
'
1d
'
:
case
'
3d
'
:
yield
{
layerCount
:
1
as
LayerCounts
}
;
break
;
}
}
)
.
unless
(
(
{
sampleCount
layerCount
}
)
=
>
sampleCount
>
1
&
&
layerCount
>
1
)
.
unless
(
(
{
format
sampleCount
uninitializeMethod
readMethod
}
)
=
>
{
const
usage
=
getRequiredTextureUsage
(
format
sampleCount
uninitializeMethod
readMethod
)
;
const
info
=
kTextureFormatInfo
[
format
]
;
return
(
(
(
usage
&
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
)
!
=
=
0
&
&
info
.
color
&
&
!
info
.
colorRender
)
|
|
(
(
usage
&
GPUConst
.
TextureUsage
.
STORAGE_BINDING
)
!
=
=
0
&
&
!
info
.
color
?
.
storage
)
|
|
(
sampleCount
>
1
&
&
!
info
.
multisample
)
)
;
}
)
.
combine
(
'
nonPowerOfTwo
'
[
false
true
]
)
.
combine
(
'
canaryOnCreation
'
[
false
true
]
)
;
type
TextureZeroParams
=
ParamTypeOf
<
typeof
kTestParams
>
;
export
type
CheckContents
=
(
t
:
TextureZeroInitTest
params
:
TextureZeroParams
texture
:
GPUTexture
state
:
InitializedState
subresourceRange
:
SubresourceRange
)
=
>
void
;
