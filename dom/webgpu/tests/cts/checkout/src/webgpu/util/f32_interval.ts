import
{
assert
unreachable
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
Float16Array
}
from
'
.
.
/
.
.
/
external
/
petamoriken
/
float16
/
float16
.
js
'
;
import
{
kValue
}
from
'
.
/
constants
.
js
'
;
import
{
reinterpretF32AsU32
reinterpretU32AsF32
}
from
'
.
/
conversion
.
js
'
;
import
{
calculatePermutations
cartesianProduct
correctlyRoundedF16
correctlyRoundedF32
flushSubnormalNumberF32
isFiniteF16
isFiniteF32
isSubnormalNumberF16
isSubnormalNumberF32
oneULP
}
from
'
.
/
math
.
js
'
;
export
type
IntervalBounds
=
[
number
]
|
[
number
number
]
;
export
class
F32Interval
{
public
readonly
begin
:
number
;
public
readonly
end
:
number
;
private
static
_any
:
F32Interval
;
public
constructor
(
.
.
.
bounds
:
IntervalBounds
)
{
const
[
begin
end
]
=
bounds
.
length
=
=
=
2
?
bounds
:
[
bounds
[
0
]
bounds
[
0
]
]
;
assert
(
!
Number
.
isNaN
(
begin
)
&
&
!
Number
.
isNaN
(
end
)
bounds
need
to
be
non
-
NaN
)
;
assert
(
begin
<
=
end
bounds
[
0
]
(
{
begin
}
)
must
be
less
than
or
equal
to
bounds
[
1
]
(
{
end
}
)
)
;
this
.
begin
=
begin
;
this
.
end
=
end
;
}
public
bounds
(
)
:
IntervalBounds
{
return
this
.
isPoint
(
)
?
[
this
.
begin
]
:
[
this
.
begin
this
.
end
]
;
}
public
contains
(
n
:
number
|
F32Interval
)
:
boolean
{
if
(
Number
.
isNaN
(
n
)
)
{
return
this
.
begin
=
=
=
Number
.
NEGATIVE_INFINITY
&
&
this
.
end
=
=
=
Number
.
POSITIVE_INFINITY
;
}
const
i
=
toF32Interval
(
n
)
;
return
this
.
begin
<
=
i
.
begin
&
&
this
.
end
>
=
i
.
end
;
}
public
containsZeroOrSubnormals
(
)
:
boolean
{
return
!
(
this
.
end
<
kValue
.
f32
.
subnormal
.
negative
.
min
|
|
this
.
begin
>
kValue
.
f32
.
subnormal
.
positive
.
max
)
;
}
public
isPoint
(
)
:
boolean
{
return
this
.
begin
=
=
=
this
.
end
;
}
public
isFinite
(
)
:
boolean
{
return
isFiniteF32
(
this
.
begin
)
&
&
isFiniteF32
(
this
.
end
)
;
}
static
span
(
.
.
.
intervals
:
F32Interval
[
]
)
:
F32Interval
{
assert
(
intervals
.
length
>
0
span
of
an
empty
list
of
F32Intervals
is
not
allowed
)
;
let
begin
=
Number
.
POSITIVE_INFINITY
;
let
end
=
Number
.
NEGATIVE_INFINITY
;
intervals
.
forEach
(
i
=
>
{
begin
=
Math
.
min
(
i
.
begin
begin
)
;
end
=
Math
.
max
(
i
.
end
end
)
;
}
)
;
return
new
F32Interval
(
begin
end
)
;
}
public
toString
(
)
:
string
{
return
[
{
this
.
bounds
(
)
}
]
;
}
public
static
any
(
)
:
F32Interval
{
if
(
this
.
_any
=
=
=
undefined
)
{
this
.
_any
=
new
F32Interval
(
Number
.
NEGATIVE_INFINITY
Number
.
POSITIVE_INFINITY
)
;
}
return
this
.
_any
;
}
}
export
type
SerializedF32Interval
=
{
begin
:
number
;
end
:
number
}
|
'
any
'
;
export
function
serializeF32Interval
(
i
:
F32Interval
)
:
SerializedF32Interval
{
return
i
=
=
=
F32Interval
.
any
(
)
?
'
any
'
:
{
begin
:
reinterpretF32AsU32
(
i
.
begin
)
end
:
reinterpretF32AsU32
(
i
.
end
)
}
;
}
export
function
deserializeF32Interval
(
data
:
SerializedF32Interval
)
:
F32Interval
{
return
data
=
=
=
'
any
'
?
F32Interval
.
any
(
)
:
toF32Interval
(
[
reinterpretU32AsF32
(
data
.
begin
)
reinterpretU32AsF32
(
data
.
end
)
]
)
;
}
export
function
toF32Interval
(
n
:
number
|
IntervalBounds
|
F32Interval
)
:
F32Interval
{
if
(
n
instanceof
F32Interval
)
{
return
n
;
}
if
(
n
instanceof
Array
)
{
return
new
F32Interval
(
.
.
.
n
)
;
}
return
new
F32Interval
(
n
n
)
;
}
const
kNegPiToPiInterval
=
toF32Interval
(
[
kValue
.
f32
.
negative
.
pi
.
whole
kValue
.
f32
.
positive
.
pi
.
whole
]
)
;
const
kGreaterThanZeroInterval
=
toF32Interval
(
[
kValue
.
f32
.
subnormal
.
positive
.
min
kValue
.
f32
.
positive
.
max
]
)
;
export
type
F32Vector
=
|
[
F32Interval
F32Interval
]
|
[
F32Interval
F32Interval
F32Interval
]
|
[
F32Interval
F32Interval
F32Interval
F32Interval
]
;
function
isF32Vector
(
v
:
number
[
]
|
IntervalBounds
[
]
|
F32Interval
[
]
|
F32Vector
)
:
v
is
F32Vector
{
if
(
v
[
0
]
instanceof
F32Interval
)
{
return
v
.
length
=
=
=
2
|
|
v
.
length
=
=
=
3
|
|
v
.
length
=
=
=
4
;
}
return
false
;
}
export
function
toF32Vector
(
v
:
number
[
]
|
IntervalBounds
[
]
|
F32Interval
[
]
|
F32Vector
)
:
F32Vector
{
if
(
isF32Vector
(
v
)
)
{
return
v
;
}
const
f
=
v
.
map
(
toF32Interval
)
;
if
(
isF32Vector
(
f
)
)
{
return
f
;
}
unreachable
(
Cannot
convert
[
{
v
}
]
to
F32Vector
)
;
}
const
kZeroVector
=
{
2
:
toF32Vector
(
[
0
0
]
)
3
:
toF32Vector
(
[
0
0
0
]
)
4
:
toF32Vector
(
[
0
0
0
0
]
)
}
;
const
kAnyVector
=
{
2
:
toF32Vector
(
[
F32Interval
.
any
(
)
F32Interval
.
any
(
)
]
)
3
:
toF32Vector
(
[
F32Interval
.
any
(
)
F32Interval
.
any
(
)
F32Interval
.
any
(
)
]
)
4
:
toF32Vector
(
[
F32Interval
.
any
(
)
F32Interval
.
any
(
)
F32Interval
.
any
(
)
F32Interval
.
any
(
)
]
)
}
;
function
spanF32Vector
(
.
.
.
vectors
:
F32Vector
[
]
)
:
F32Vector
{
const
vector_length
=
vectors
[
0
]
.
length
;
assert
(
vectors
.
every
(
e
=
>
e
.
length
=
=
=
vector_length
)
Vector
span
is
not
defined
for
vectors
of
differing
lengths
)
;
return
toF32Vector
(
vectors
[
0
]
.
map
(
(
_
idx
)
=
>
{
return
F32Interval
.
span
(
.
.
.
vectors
.
map
(
v
=
>
v
[
idx
]
)
)
;
}
)
)
;
}
function
multiplyVectorByScalar
(
v
:
number
[
]
c
:
number
|
F32Interval
)
:
F32Vector
{
return
toF32Vector
(
v
.
map
(
x
=
>
multiplicationInterval
(
x
c
)
)
)
;
}
function
addFlushedIfNeededF32
(
values
:
number
[
]
)
:
number
[
]
{
return
values
.
some
(
v
=
>
v
!
=
=
0
&
&
isSubnormalNumberF32
(
v
)
)
?
values
.
concat
(
0
)
:
values
;
}
function
addFlushedIfNeededF16
(
values
:
number
[
]
)
:
number
[
]
{
return
values
.
some
(
v
=
>
v
!
=
=
0
&
&
isSubnormalNumberF16
(
v
)
)
?
values
.
concat
(
0
)
:
values
;
}
export
interface
PointToInterval
{
(
x
:
number
)
:
F32Interval
;
}
export
interface
PointToIntervalOp
{
impl
:
PointToInterval
;
extrema
?
:
(
x
:
F32Interval
)
=
>
F32Interval
;
}
function
limitPointToIntervalDomain
(
domain
:
F32Interval
impl
:
PointToInterval
)
:
PointToInterval
{
return
(
n
:
number
)
:
F32Interval
=
>
{
return
domain
.
contains
(
n
)
?
impl
(
n
)
:
F32Interval
.
any
(
)
;
}
;
}
export
interface
BinaryToInterval
{
(
x
:
number
y
:
number
)
:
F32Interval
;
}
interface
BinaryToIntervalOp
{
impl
:
BinaryToInterval
;
extrema
?
:
(
x
:
F32Interval
y
:
F32Interval
)
=
>
[
F32Interval
F32Interval
]
;
}
interface
BinaryToIntervalDomain
{
x
:
F32Interval
[
]
;
y
:
F32Interval
[
]
;
}
function
limitBinaryToIntervalDomain
(
domain
:
BinaryToIntervalDomain
impl
:
BinaryToInterval
)
:
BinaryToInterval
{
return
(
x
:
number
y
:
number
)
:
F32Interval
=
>
{
if
(
!
domain
.
x
.
some
(
d
=
>
d
.
contains
(
x
)
)
|
|
!
domain
.
y
.
some
(
d
=
>
d
.
contains
(
y
)
)
)
{
return
F32Interval
.
any
(
)
;
}
return
impl
(
x
y
)
;
}
;
}
export
interface
TernaryToInterval
{
(
x
:
number
y
:
number
z
:
number
)
:
F32Interval
;
}
interface
TernaryToIntervalOp
{
impl
:
TernaryToInterval
;
}
export
interface
PointToVector
{
(
n
:
number
)
:
F32Vector
;
}
export
interface
VectorToInterval
{
(
x
:
number
[
]
)
:
F32Interval
;
}
interface
VectorToIntervalOp
{
impl
:
VectorToInterval
;
}
export
interface
VectorPairToInterval
{
(
x
:
number
[
]
y
:
number
[
]
)
:
F32Interval
;
}
interface
VectorPairToIntervalOp
{
impl
:
VectorPairToInterval
;
}
export
interface
VectorToVector
{
(
x
:
number
[
]
)
:
F32Vector
;
}
interface
VectorToVectorOp
{
impl
:
VectorToVector
;
}
export
interface
VectorPairToVector
{
(
x
:
number
[
]
y
:
number
[
]
)
:
F32Vector
;
}
interface
VectorPairToVectorOp
{
impl
:
VectorPairToVector
;
}
function
roundAndFlushPointToInterval
(
n
:
number
op
:
PointToIntervalOp
)
{
assert
(
!
Number
.
isNaN
(
n
)
flush
not
defined
for
NaN
)
;
const
values
=
correctlyRoundedF32
(
n
)
;
const
inputs
=
addFlushedIfNeededF32
(
values
)
;
const
results
=
new
Set
<
F32Interval
>
(
inputs
.
map
(
op
.
impl
)
)
;
return
F32Interval
.
span
(
.
.
.
results
)
;
}
function
roundAndFlushBinaryToInterval
(
x
:
number
y
:
number
op
:
BinaryToIntervalOp
)
:
F32Interval
{
assert
(
!
Number
.
isNaN
(
x
)
flush
not
defined
for
NaN
)
;
assert
(
!
Number
.
isNaN
(
y
)
flush
not
defined
for
NaN
)
;
const
x_values
=
correctlyRoundedF32
(
x
)
;
const
y_values
=
correctlyRoundedF32
(
y
)
;
const
x_inputs
=
addFlushedIfNeededF32
(
x_values
)
;
const
y_inputs
=
addFlushedIfNeededF32
(
y_values
)
;
const
intervals
=
new
Set
<
F32Interval
>
(
)
;
x_inputs
.
forEach
(
inner_x
=
>
{
y_inputs
.
forEach
(
inner_y
=
>
{
intervals
.
add
(
op
.
impl
(
inner_x
inner_y
)
)
;
}
)
;
}
)
;
return
F32Interval
.
span
(
.
.
.
intervals
)
;
}
function
roundAndFlushTernaryToInterval
(
x
:
number
y
:
number
z
:
number
op
:
TernaryToIntervalOp
)
:
F32Interval
{
assert
(
!
Number
.
isNaN
(
x
)
flush
not
defined
for
NaN
)
;
assert
(
!
Number
.
isNaN
(
y
)
flush
not
defined
for
NaN
)
;
assert
(
!
Number
.
isNaN
(
z
)
flush
not
defined
for
NaN
)
;
const
x_values
=
correctlyRoundedF32
(
x
)
;
const
y_values
=
correctlyRoundedF32
(
y
)
;
const
z_values
=
correctlyRoundedF32
(
z
)
;
const
x_inputs
=
addFlushedIfNeededF32
(
x_values
)
;
const
y_inputs
=
addFlushedIfNeededF32
(
y_values
)
;
const
z_inputs
=
addFlushedIfNeededF32
(
z_values
)
;
const
intervals
=
new
Set
<
F32Interval
>
(
)
;
x_inputs
.
forEach
(
inner_x
=
>
{
y_inputs
.
forEach
(
inner_y
=
>
{
z_inputs
.
forEach
(
inner_z
=
>
{
intervals
.
add
(
op
.
impl
(
inner_x
inner_y
inner_z
)
)
;
}
)
;
}
)
;
}
)
;
return
F32Interval
.
span
(
.
.
.
intervals
)
;
}
function
roundAndFlushVectorToInterval
(
x
:
number
[
]
op
:
VectorToIntervalOp
)
:
F32Interval
{
assert
(
x
.
every
(
e
=
>
!
Number
.
isNaN
(
e
)
)
flush
not
defined
for
NaN
)
;
const
x_rounded
:
number
[
]
[
]
=
x
.
map
(
correctlyRoundedF32
)
;
const
x_flushed
:
number
[
]
[
]
=
x_rounded
.
map
(
addFlushedIfNeededF32
)
;
const
x_inputs
=
cartesianProduct
<
number
>
(
.
.
.
x_flushed
)
;
const
intervals
=
new
Set
<
F32Interval
>
(
)
;
x_inputs
.
forEach
(
inner_x
=
>
{
intervals
.
add
(
op
.
impl
(
inner_x
)
)
;
}
)
;
return
F32Interval
.
span
(
.
.
.
intervals
)
;
}
function
roundAndFlushVectorPairToInterval
(
x
:
number
[
]
y
:
number
[
]
op
:
VectorPairToIntervalOp
)
:
F32Interval
{
assert
(
x
.
every
(
e
=
>
!
Number
.
isNaN
(
e
)
)
flush
not
defined
for
NaN
)
;
assert
(
y
.
every
(
e
=
>
!
Number
.
isNaN
(
e
)
)
flush
not
defined
for
NaN
)
;
const
x_rounded
:
number
[
]
[
]
=
x
.
map
(
correctlyRoundedF32
)
;
const
y_rounded
:
number
[
]
[
]
=
y
.
map
(
correctlyRoundedF32
)
;
const
x_flushed
:
number
[
]
[
]
=
x_rounded
.
map
(
addFlushedIfNeededF32
)
;
const
y_flushed
:
number
[
]
[
]
=
y_rounded
.
map
(
addFlushedIfNeededF32
)
;
const
x_inputs
=
cartesianProduct
<
number
>
(
.
.
.
x_flushed
)
;
const
y_inputs
=
cartesianProduct
<
number
>
(
.
.
.
y_flushed
)
;
const
intervals
=
new
Set
<
F32Interval
>
(
)
;
x_inputs
.
forEach
(
inner_x
=
>
{
y_inputs
.
forEach
(
inner_y
=
>
{
intervals
.
add
(
op
.
impl
(
inner_x
inner_y
)
)
;
}
)
;
}
)
;
return
F32Interval
.
span
(
.
.
.
intervals
)
;
}
function
roundAndFlushVectorToVector
(
x
:
number
[
]
op
:
VectorToVectorOp
)
:
F32Vector
{
assert
(
x
.
every
(
e
=
>
!
Number
.
isNaN
(
e
)
)
flush
not
defined
for
NaN
)
;
const
x_rounded
:
number
[
]
[
]
=
x
.
map
(
correctlyRoundedF32
)
;
const
x_flushed
:
number
[
]
[
]
=
x_rounded
.
map
(
addFlushedIfNeededF32
)
;
const
x_inputs
=
cartesianProduct
<
number
>
(
.
.
.
x_flushed
)
;
const
interval_vectors
=
new
Set
<
F32Vector
>
(
)
;
x_inputs
.
forEach
(
inner_x
=
>
{
interval_vectors
.
add
(
op
.
impl
(
inner_x
)
)
;
}
)
;
return
spanF32Vector
(
.
.
.
interval_vectors
)
;
}
function
roundAndFlushVectorPairToVector
(
x
:
number
[
]
y
:
number
[
]
op
:
VectorPairToVectorOp
)
:
F32Vector
{
assert
(
x
.
every
(
e
=
>
!
Number
.
isNaN
(
e
)
)
flush
not
defined
for
NaN
)
;
assert
(
y
.
every
(
e
=
>
!
Number
.
isNaN
(
e
)
)
flush
not
defined
for
NaN
)
;
const
x_rounded
:
number
[
]
[
]
=
x
.
map
(
correctlyRoundedF32
)
;
const
y_rounded
:
number
[
]
[
]
=
y
.
map
(
correctlyRoundedF32
)
;
const
x_flushed
:
number
[
]
[
]
=
x_rounded
.
map
(
addFlushedIfNeededF32
)
;
const
y_flushed
:
number
[
]
[
]
=
y_rounded
.
map
(
addFlushedIfNeededF32
)
;
const
x_inputs
=
cartesianProduct
<
number
>
(
.
.
.
x_flushed
)
;
const
y_inputs
=
cartesianProduct
<
number
>
(
.
.
.
y_flushed
)
;
const
interval_vectors
=
new
Set
<
F32Vector
>
(
)
;
x_inputs
.
forEach
(
inner_x
=
>
{
y_inputs
.
forEach
(
inner_y
=
>
{
interval_vectors
.
add
(
op
.
impl
(
inner_x
inner_y
)
)
;
}
)
;
}
)
;
return
spanF32Vector
(
.
.
.
interval_vectors
)
;
}
function
runPointToIntervalOp
(
x
:
F32Interval
op
:
PointToIntervalOp
)
:
F32Interval
{
if
(
!
x
.
isFinite
(
)
)
{
return
F32Interval
.
any
(
)
;
}
if
(
op
.
extrema
!
=
=
undefined
)
{
x
=
op
.
extrema
(
x
)
;
}
const
result
=
F32Interval
.
span
(
.
.
.
x
.
bounds
(
)
.
map
(
b
=
>
roundAndFlushPointToInterval
(
b
op
)
)
)
;
return
result
.
isFinite
(
)
?
result
:
F32Interval
.
any
(
)
;
}
function
runBinaryToIntervalOp
(
x
:
F32Interval
y
:
F32Interval
op
:
BinaryToIntervalOp
)
:
F32Interval
{
if
(
!
x
.
isFinite
(
)
|
|
!
y
.
isFinite
(
)
)
{
return
F32Interval
.
any
(
)
;
}
if
(
op
.
extrema
!
=
=
undefined
)
{
[
x
y
]
=
op
.
extrema
(
x
y
)
;
}
const
outputs
=
new
Set
<
F32Interval
>
(
)
;
x
.
bounds
(
)
.
forEach
(
inner_x
=
>
{
y
.
bounds
(
)
.
forEach
(
inner_y
=
>
{
outputs
.
add
(
roundAndFlushBinaryToInterval
(
inner_x
inner_y
op
)
)
;
}
)
;
}
)
;
const
result
=
F32Interval
.
span
(
.
.
.
outputs
)
;
return
result
.
isFinite
(
)
?
result
:
F32Interval
.
any
(
)
;
}
function
runTernaryToIntervalOp
(
x
:
F32Interval
y
:
F32Interval
z
:
F32Interval
op
:
TernaryToIntervalOp
)
:
F32Interval
{
if
(
!
x
.
isFinite
(
)
|
|
!
y
.
isFinite
(
)
|
|
!
z
.
isFinite
(
)
)
{
return
F32Interval
.
any
(
)
;
}
const
outputs
=
new
Set
<
F32Interval
>
(
)
;
x
.
bounds
(
)
.
forEach
(
inner_x
=
>
{
y
.
bounds
(
)
.
forEach
(
inner_y
=
>
{
z
.
bounds
(
)
.
forEach
(
inner_z
=
>
{
outputs
.
add
(
roundAndFlushTernaryToInterval
(
inner_x
inner_y
inner_z
op
)
)
;
}
)
;
}
)
;
}
)
;
const
result
=
F32Interval
.
span
(
.
.
.
outputs
)
;
return
result
.
isFinite
(
)
?
result
:
F32Interval
.
any
(
)
;
}
function
runVectorToIntervalOp
(
x
:
F32Vector
op
:
VectorToIntervalOp
)
:
F32Interval
{
if
(
x
.
some
(
e
=
>
!
e
.
isFinite
(
)
)
)
{
return
F32Interval
.
any
(
)
;
}
const
x_values
=
cartesianProduct
<
number
>
(
.
.
.
x
.
map
(
e
=
>
e
.
bounds
(
)
)
)
;
const
outputs
=
new
Set
<
F32Interval
>
(
)
;
x_values
.
forEach
(
inner_x
=
>
{
outputs
.
add
(
roundAndFlushVectorToInterval
(
inner_x
op
)
)
;
}
)
;
const
result
=
F32Interval
.
span
(
.
.
.
outputs
)
;
return
result
.
isFinite
(
)
?
result
:
F32Interval
.
any
(
)
;
}
function
runVectorPairToIntervalOp
(
x
:
F32Vector
y
:
F32Vector
op
:
VectorPairToIntervalOp
)
:
F32Interval
{
if
(
x
.
some
(
e
=
>
!
e
.
isFinite
(
)
)
|
|
y
.
some
(
e
=
>
!
e
.
isFinite
(
)
)
)
{
return
F32Interval
.
any
(
)
;
}
const
x_values
=
cartesianProduct
<
number
>
(
.
.
.
x
.
map
(
e
=
>
e
.
bounds
(
)
)
)
;
const
y_values
=
cartesianProduct
<
number
>
(
.
.
.
y
.
map
(
e
=
>
e
.
bounds
(
)
)
)
;
const
outputs
=
new
Set
<
F32Interval
>
(
)
;
x_values
.
forEach
(
inner_x
=
>
{
y_values
.
forEach
(
inner_y
=
>
{
outputs
.
add
(
roundAndFlushVectorPairToInterval
(
inner_x
inner_y
op
)
)
;
}
)
;
}
)
;
const
result
=
F32Interval
.
span
(
.
.
.
outputs
)
;
return
result
.
isFinite
(
)
?
result
:
F32Interval
.
any
(
)
;
}
function
runVectorToVectorOp
(
x
:
F32Vector
op
:
VectorToVectorOp
)
:
F32Vector
{
if
(
x
.
some
(
e
=
>
!
e
.
isFinite
(
)
)
)
{
return
kAnyVector
[
x
.
length
]
;
}
const
x_values
=
cartesianProduct
<
number
>
(
.
.
.
x
.
map
(
e
=
>
e
.
bounds
(
)
)
)
;
const
outputs
=
new
Set
<
F32Vector
>
(
)
;
x_values
.
forEach
(
inner_x
=
>
{
outputs
.
add
(
roundAndFlushVectorToVector
(
inner_x
op
)
)
;
}
)
;
const
result
=
spanF32Vector
(
.
.
.
outputs
)
;
return
result
.
every
(
e
=
>
e
.
isFinite
(
)
)
?
result
:
toF32Vector
(
x
.
map
(
_
=
>
F32Interval
.
any
(
)
)
)
;
}
function
runPointToIntervalOpComponentWise
(
x
:
F32Vector
op
:
PointToIntervalOp
)
:
F32Vector
{
return
toF32Vector
(
x
.
map
(
i
=
>
{
return
runPointToIntervalOp
(
i
op
)
;
}
)
)
;
}
function
runVectorPairToVectorOp
(
x
:
F32Vector
y
:
F32Vector
op
:
VectorPairToVectorOp
)
:
F32Vector
{
if
(
x
.
some
(
e
=
>
!
e
.
isFinite
(
)
)
|
|
y
.
some
(
e
=
>
!
e
.
isFinite
(
)
)
)
{
return
kAnyVector
[
x
.
length
]
;
}
const
x_values
=
cartesianProduct
<
number
>
(
.
.
.
x
.
map
(
e
=
>
e
.
bounds
(
)
)
)
;
const
y_values
=
cartesianProduct
<
number
>
(
.
.
.
y
.
map
(
e
=
>
e
.
bounds
(
)
)
)
;
const
outputs
=
new
Set
<
F32Vector
>
(
)
;
x_values
.
forEach
(
inner_x
=
>
{
y_values
.
forEach
(
inner_y
=
>
{
outputs
.
add
(
roundAndFlushVectorPairToVector
(
inner_x
inner_y
op
)
)
;
}
)
;
}
)
;
const
result
=
spanF32Vector
(
.
.
.
outputs
)
;
return
result
.
every
(
e
=
>
e
.
isFinite
(
)
)
?
result
:
toF32Vector
(
x
.
map
(
_
=
>
F32Interval
.
any
(
)
)
)
;
}
function
runBinaryToIntervalOpComponentWise
(
x
:
F32Vector
y
:
F32Vector
op
:
BinaryToIntervalOp
)
:
F32Vector
{
assert
(
x
.
length
=
=
=
y
.
length
runBinaryToIntervalOpComponentWise
requires
vectors
of
the
same
length
)
;
return
toF32Vector
(
x
.
map
(
(
i
idx
)
=
>
{
return
runBinaryToIntervalOp
(
i
y
[
idx
]
op
)
;
}
)
)
;
}
const
CorrectlyRoundedIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
=
>
{
assert
(
!
Number
.
isNaN
(
n
)
absolute
not
defined
for
NaN
)
;
return
toF32Interval
(
n
)
;
}
}
;
export
function
correctlyRoundedInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
CorrectlyRoundedIntervalOp
)
;
}
function
AbsoluteErrorIntervalOp
(
error_range
:
number
)
:
PointToIntervalOp
{
const
op
:
PointToIntervalOp
=
{
impl
:
(
_
:
number
)
=
>
{
return
F32Interval
.
any
(
)
;
}
}
;
if
(
isFiniteF32
(
error_range
)
)
{
op
.
impl
=
(
n
:
number
)
=
>
{
assert
(
!
Number
.
isNaN
(
n
)
absolute
error
not
defined
for
NaN
)
;
return
toF32Interval
(
[
n
-
error_range
n
+
error_range
]
)
;
}
;
}
return
op
;
}
export
function
absoluteErrorInterval
(
n
:
number
error_range
:
number
)
:
F32Interval
{
error_range
=
Math
.
abs
(
error_range
)
;
return
runPointToIntervalOp
(
toF32Interval
(
n
)
AbsoluteErrorIntervalOp
(
error_range
)
)
;
}
function
ULPIntervalOp
(
numULP
:
number
)
:
PointToIntervalOp
{
const
op
:
PointToIntervalOp
=
{
impl
:
(
_
:
number
)
=
>
{
return
F32Interval
.
any
(
)
;
}
}
;
if
(
isFiniteF32
(
numULP
)
)
{
op
.
impl
=
(
n
:
number
)
=
>
{
assert
(
!
Number
.
isNaN
(
n
)
ULP
error
not
defined
for
NaN
)
;
const
ulp
=
oneULP
(
n
)
;
const
begin
=
n
-
numULP
*
ulp
;
const
end
=
n
+
numULP
*
ulp
;
return
toF32Interval
(
[
Math
.
min
(
begin
flushSubnormalNumberF32
(
begin
)
)
Math
.
max
(
end
flushSubnormalNumberF32
(
end
)
)
]
)
;
}
;
}
return
op
;
}
export
function
ulpInterval
(
n
:
number
numULP
:
number
)
:
F32Interval
{
numULP
=
Math
.
abs
(
numULP
)
;
return
runPointToIntervalOp
(
toF32Interval
(
n
)
ULPIntervalOp
(
numULP
)
)
;
}
const
AbsIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
=
>
{
return
correctlyRoundedInterval
(
Math
.
abs
(
n
)
)
;
}
}
;
export
function
absInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
AbsIntervalOp
)
;
}
const
AcosIntervalOp
:
PointToIntervalOp
=
{
impl
:
limitPointToIntervalDomain
(
toF32Interval
(
[
-
1
.
0
1
.
0
]
)
(
n
:
number
)
=
>
{
const
y
=
sqrtInterval
(
subtractionInterval
(
1
multiplicationInterval
(
n
n
)
)
)
;
return
atan2Interval
(
y
n
)
;
}
)
}
;
export
function
acosInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
AcosIntervalOp
)
;
}
export
const
acoshIntervals
:
PointToInterval
[
]
=
[
acoshAlternativeInterval
acoshPrimaryInterval
]
;
const
AcoshAlternativeIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
x
:
number
)
:
F32Interval
=
>
{
const
inner_value
=
multiplicationInterval
(
additionInterval
(
x
1
.
0
)
subtractionInterval
(
x
1
.
0
)
)
;
const
sqrt_value
=
sqrtInterval
(
inner_value
)
;
return
logInterval
(
additionInterval
(
x
sqrt_value
)
)
;
}
}
;
export
function
acoshAlternativeInterval
(
x
:
number
|
F32Interval
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
x
)
AcoshAlternativeIntervalOp
)
;
}
const
AcoshPrimaryIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
x
:
number
)
:
F32Interval
=
>
{
const
inner_value
=
subtractionInterval
(
multiplicationInterval
(
x
x
)
1
.
0
)
;
const
sqrt_value
=
sqrtInterval
(
inner_value
)
;
return
logInterval
(
additionInterval
(
x
sqrt_value
)
)
;
}
}
;
export
function
acoshPrimaryInterval
(
x
:
number
|
F32Interval
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
x
)
AcoshPrimaryIntervalOp
)
;
}
const
AdditionIntervalOp
:
BinaryToIntervalOp
=
{
impl
:
(
x
:
number
y
:
number
)
:
F32Interval
=
>
{
return
correctlyRoundedInterval
(
x
+
y
)
;
}
}
;
export
function
additionInterval
(
x
:
number
|
F32Interval
y
:
number
|
F32Interval
)
:
F32Interval
{
return
runBinaryToIntervalOp
(
toF32Interval
(
x
)
toF32Interval
(
y
)
AdditionIntervalOp
)
;
}
const
AsinIntervalOp
:
PointToIntervalOp
=
{
impl
:
limitPointToIntervalDomain
(
toF32Interval
(
[
-
1
.
0
1
.
0
]
)
(
n
:
number
)
=
>
{
const
x
=
sqrtInterval
(
subtractionInterval
(
1
multiplicationInterval
(
n
n
)
)
)
;
return
atan2Interval
(
n
x
)
;
}
)
}
;
export
function
asinInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
AsinIntervalOp
)
;
}
const
AsinhIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
x
:
number
)
:
F32Interval
=
>
{
const
inner_value
=
additionInterval
(
multiplicationInterval
(
x
x
)
1
.
0
)
;
const
sqrt_value
=
sqrtInterval
(
inner_value
)
;
return
logInterval
(
additionInterval
(
x
sqrt_value
)
)
;
}
}
;
export
function
asinhInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
AsinhIntervalOp
)
;
}
const
AtanIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
return
ulpInterval
(
Math
.
atan
(
n
)
4096
)
;
}
}
;
export
function
atanInterval
(
n
:
number
|
F32Interval
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
AtanIntervalOp
)
;
}
const
Atan2IntervalOp
:
BinaryToIntervalOp
=
{
impl
:
limitBinaryToIntervalDomain
(
{
x
:
[
toF32Interval
(
[
kValue
.
f32
.
negative
.
min
kValue
.
f32
.
negative
.
max
]
)
toF32Interval
(
[
kValue
.
f32
.
positive
.
min
kValue
.
f32
.
positive
.
max
]
)
]
y
:
[
toF32Interval
(
[
-
(
2
*
*
126
)
-
(
2
*
*
-
126
)
]
)
toF32Interval
(
[
2
*
*
-
126
2
*
*
126
]
)
]
}
(
y
:
number
x
:
number
)
:
F32Interval
=
>
{
const
atan_yx
=
Math
.
atan
(
y
/
x
)
;
if
(
x
>
0
)
{
return
ulpInterval
(
atan_yx
4096
)
;
}
if
(
y
>
0
)
{
return
ulpInterval
(
atan_yx
+
kValue
.
f32
.
positive
.
pi
.
whole
4096
)
;
}
return
ulpInterval
(
atan_yx
-
kValue
.
f32
.
positive
.
pi
.
whole
4096
)
;
}
)
extrema
:
(
y
:
F32Interval
x
:
F32Interval
)
:
[
F32Interval
F32Interval
]
=
>
{
if
(
y
.
contains
(
0
)
)
{
if
(
x
.
contains
(
0
)
)
{
return
[
toF32Interval
(
0
)
toF32Interval
(
0
)
]
;
}
return
[
toF32Interval
(
0
)
x
]
;
}
return
[
y
x
]
;
}
}
;
export
function
atan2Interval
(
y
:
number
|
F32Interval
x
:
number
|
F32Interval
)
:
F32Interval
{
return
runBinaryToIntervalOp
(
toF32Interval
(
y
)
toF32Interval
(
x
)
Atan2IntervalOp
)
;
}
const
AtanhIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
=
>
{
const
numerator
=
additionInterval
(
1
.
0
n
)
;
const
denominator
=
subtractionInterval
(
1
.
0
n
)
;
const
log_interval
=
logInterval
(
divisionInterval
(
numerator
denominator
)
)
;
return
multiplicationInterval
(
log_interval
0
.
5
)
;
}
}
;
export
function
atanhInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
AtanhIntervalOp
)
;
}
const
CeilIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
return
correctlyRoundedInterval
(
Math
.
ceil
(
n
)
)
;
}
}
;
export
function
ceilInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
CeilIntervalOp
)
;
}
const
ClampMedianIntervalOp
:
TernaryToIntervalOp
=
{
impl
:
(
x
:
number
y
:
number
z
:
number
)
:
F32Interval
=
>
{
return
correctlyRoundedInterval
(
[
x
y
z
]
.
sort
(
(
a
b
)
=
>
{
if
(
a
<
b
)
{
return
-
1
;
}
if
(
a
>
b
)
{
return
1
;
}
return
0
;
}
)
[
1
]
)
;
}
}
;
export
const
clampIntervals
:
TernaryToInterval
[
]
=
[
clampMinMaxInterval
clampMedianInterval
]
;
export
function
clampMedianInterval
(
x
:
number
|
F32Interval
y
:
number
|
F32Interval
z
:
number
|
F32Interval
)
:
F32Interval
{
return
runTernaryToIntervalOp
(
toF32Interval
(
x
)
toF32Interval
(
y
)
toF32Interval
(
z
)
ClampMedianIntervalOp
)
;
}
const
ClampMinMaxIntervalOp
:
TernaryToIntervalOp
=
{
impl
:
(
x
:
number
low
:
number
high
:
number
)
:
F32Interval
=
>
{
return
correctlyRoundedInterval
(
Math
.
min
(
Math
.
max
(
x
low
)
high
)
)
;
}
}
;
export
function
clampMinMaxInterval
(
x
:
number
|
F32Interval
low
:
number
|
F32Interval
high
:
number
|
F32Interval
)
:
F32Interval
{
return
runTernaryToIntervalOp
(
toF32Interval
(
x
)
toF32Interval
(
low
)
toF32Interval
(
high
)
ClampMinMaxIntervalOp
)
;
}
const
CosIntervalOp
:
PointToIntervalOp
=
{
impl
:
limitPointToIntervalDomain
(
kNegPiToPiInterval
(
n
:
number
)
:
F32Interval
=
>
{
return
absoluteErrorInterval
(
Math
.
cos
(
n
)
2
*
*
-
11
)
;
}
)
}
;
export
function
cosInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
CosIntervalOp
)
;
}
const
CoshIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
const
minus_n
=
negationInterval
(
n
)
;
return
multiplicationInterval
(
additionInterval
(
expInterval
(
n
)
expInterval
(
minus_n
)
)
0
.
5
)
;
}
}
;
export
function
coshInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
CoshIntervalOp
)
;
}
const
CrossIntervalOp
:
VectorPairToVectorOp
=
{
impl
:
(
x
:
number
[
]
y
:
number
[
]
)
:
F32Vector
=
>
{
assert
(
x
.
length
=
=
=
3
CrossIntervalOp
received
x
with
{
x
.
length
}
instead
of
3
)
;
assert
(
y
.
length
=
=
=
3
CrossIntervalOp
received
y
with
{
y
.
length
}
instead
of
3
)
;
const
r0
=
subtractionInterval
(
multiplicationInterval
(
x
[
1
]
y
[
2
]
)
multiplicationInterval
(
x
[
2
]
y
[
1
]
)
)
;
const
r1
=
subtractionInterval
(
multiplicationInterval
(
x
[
2
]
y
[
0
]
)
multiplicationInterval
(
x
[
0
]
y
[
2
]
)
)
;
const
r2
=
subtractionInterval
(
multiplicationInterval
(
x
[
0
]
y
[
1
]
)
multiplicationInterval
(
x
[
1
]
y
[
0
]
)
)
;
return
[
r0
r1
r2
]
;
}
}
;
export
function
crossInterval
(
x
:
number
[
]
y
:
number
[
]
)
:
F32Vector
{
assert
(
x
.
length
=
=
=
3
Cross
is
only
defined
for
vec3
)
;
assert
(
y
.
length
=
=
=
3
Cross
is
only
defined
for
vec3
)
;
return
runVectorPairToVectorOp
(
toF32Vector
(
x
)
toF32Vector
(
y
)
CrossIntervalOp
)
;
}
const
DegreesIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
return
multiplicationInterval
(
n
57
.
295779513082322865
)
;
}
}
;
export
function
degreesInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
DegreesIntervalOp
)
;
}
const
DistanceIntervalScalarOp
:
BinaryToIntervalOp
=
{
impl
:
(
x
:
number
y
:
number
)
:
F32Interval
=
>
{
return
lengthInterval
(
subtractionInterval
(
x
y
)
)
;
}
}
;
const
DistanceIntervalVectorOp
:
VectorPairToIntervalOp
=
{
impl
:
(
x
:
number
[
]
y
:
number
[
]
)
:
F32Interval
=
>
{
return
lengthInterval
(
runBinaryToIntervalOpComponentWise
(
toF32Vector
(
x
)
toF32Vector
(
y
)
SubtractionIntervalOp
)
)
;
}
}
;
export
function
distanceInterval
(
x
:
number
|
number
[
]
y
:
number
|
number
[
]
)
:
F32Interval
{
if
(
x
instanceof
Array
&
&
y
instanceof
Array
)
{
assert
(
x
.
length
=
=
=
y
.
length
distanceInterval
requires
both
params
to
have
the
same
number
of
elements
)
;
return
runVectorPairToIntervalOp
(
toF32Vector
(
x
)
toF32Vector
(
y
)
DistanceIntervalVectorOp
)
;
}
else
if
(
!
(
x
instanceof
Array
)
&
&
!
(
y
instanceof
Array
)
)
{
return
runBinaryToIntervalOp
(
toF32Interval
(
x
)
toF32Interval
(
y
)
DistanceIntervalScalarOp
)
;
}
unreachable
(
distanceInterval
requires
both
params
to
both
the
same
type
either
scalars
or
vectors
)
;
}
const
DivisionIntervalOp
:
BinaryToIntervalOp
=
{
impl
:
limitBinaryToIntervalDomain
(
{
x
:
[
toF32Interval
(
[
kValue
.
f32
.
negative
.
min
kValue
.
f32
.
positive
.
max
]
)
]
y
:
[
toF32Interval
(
[
-
(
2
*
*
126
)
-
(
2
*
*
-
126
)
]
)
toF32Interval
(
[
2
*
*
-
126
2
*
*
126
]
)
]
}
(
x
:
number
y
:
number
)
:
F32Interval
=
>
{
if
(
y
=
=
=
0
)
{
return
F32Interval
.
any
(
)
;
}
return
ulpInterval
(
x
/
y
2
.
5
)
;
}
)
extrema
:
(
x
:
F32Interval
y
:
F32Interval
)
:
[
F32Interval
F32Interval
]
=
>
{
if
(
y
.
contains
(
0
)
)
{
y
=
toF32Interval
(
0
)
;
}
return
[
x
y
]
;
}
}
;
export
function
divisionInterval
(
x
:
number
|
F32Interval
y
:
number
|
F32Interval
)
:
F32Interval
{
return
runBinaryToIntervalOp
(
toF32Interval
(
x
)
toF32Interval
(
y
)
DivisionIntervalOp
)
;
}
const
DotIntervalOp
:
VectorPairToIntervalOp
=
{
impl
:
(
x
:
number
[
]
y
:
number
[
]
)
:
F32Interval
=
>
{
const
multiplications
=
runBinaryToIntervalOpComponentWise
(
toF32Vector
(
x
)
toF32Vector
(
y
)
MultiplicationIntervalOp
)
;
if
(
multiplications
.
length
=
=
=
2
)
{
return
additionInterval
(
multiplications
[
0
]
multiplications
[
1
]
)
;
}
const
permutations
:
F32Interval
[
]
[
]
=
calculatePermutations
(
multiplications
)
;
return
F32Interval
.
span
(
.
.
.
permutations
.
map
(
p
=
>
p
.
reduce
(
(
prev
cur
)
=
>
additionInterval
(
prev
cur
)
)
)
)
;
}
}
;
export
function
dotInterval
(
x
:
number
[
]
y
:
number
[
]
)
:
F32Interval
{
assert
(
x
.
length
=
=
=
y
.
length
dot
not
defined
for
vectors
with
different
lengths
)
;
return
runVectorPairToIntervalOp
(
toF32Vector
(
x
)
toF32Vector
(
y
)
DotIntervalOp
)
;
}
const
ExpIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
return
ulpInterval
(
Math
.
exp
(
n
)
3
+
2
*
Math
.
abs
(
n
)
)
;
}
}
;
export
function
expInterval
(
x
:
number
|
F32Interval
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
x
)
ExpIntervalOp
)
;
}
const
Exp2IntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
return
ulpInterval
(
Math
.
pow
(
2
n
)
3
+
2
*
Math
.
abs
(
n
)
)
;
}
}
;
export
function
exp2Interval
(
x
:
number
|
F32Interval
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
x
)
Exp2IntervalOp
)
;
}
export
function
faceForwardIntervals
(
x
:
number
[
]
y
:
number
[
]
z
:
number
[
]
)
:
(
F32Vector
|
undefined
)
[
]
{
const
x_vec
=
toF32Vector
(
x
)
;
const
positive_x
=
runPointToIntervalOpComponentWise
(
x_vec
{
impl
:
toF32Interval
}
)
;
const
negative_x
=
runPointToIntervalOpComponentWise
(
x_vec
NegationIntervalOp
)
;
const
dot_interval
=
dotInterval
(
z
y
)
;
const
results
:
(
F32Vector
|
undefined
)
[
]
=
[
]
;
if
(
!
dot_interval
.
isFinite
(
)
)
{
results
.
push
(
undefined
)
;
}
if
(
dot_interval
.
begin
<
0
|
|
dot_interval
.
end
<
0
)
{
results
.
push
(
positive_x
)
;
}
if
(
dot_interval
.
begin
>
=
0
|
|
dot_interval
.
end
>
=
0
)
{
results
.
push
(
negative_x
)
;
}
assert
(
results
.
length
>
0
|
|
results
.
every
(
r
=
>
r
=
=
=
undefined
)
faceForwardInterval
selected
neither
positive
x
or
negative
x
for
the
result
this
shouldn
'
t
be
possible
)
;
return
results
;
}
const
FloorIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
return
correctlyRoundedInterval
(
Math
.
floor
(
n
)
)
;
}
}
;
export
function
floorInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
FloorIntervalOp
)
;
}
const
FmaIntervalOp
:
TernaryToIntervalOp
=
{
impl
:
(
x
:
number
y
:
number
z
:
number
)
:
F32Interval
=
>
{
return
additionInterval
(
multiplicationInterval
(
x
y
)
z
)
;
}
}
;
export
function
fmaInterval
(
x
:
number
y
:
number
z
:
number
)
:
F32Interval
{
return
runTernaryToIntervalOp
(
toF32Interval
(
x
)
toF32Interval
(
y
)
toF32Interval
(
z
)
FmaIntervalOp
)
;
}
const
FractIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
const
result
=
subtractionInterval
(
n
floorInterval
(
n
)
)
;
if
(
result
.
contains
(
1
)
)
{
return
F32Interval
.
span
(
result
toF32Interval
(
kValue
.
f32
.
positive
.
less_than_one
)
)
;
}
return
result
;
}
}
;
export
function
fractInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
FractIntervalOp
)
;
}
const
InverseSqrtIntervalOp
:
PointToIntervalOp
=
{
impl
:
limitPointToIntervalDomain
(
kGreaterThanZeroInterval
(
n
:
number
)
:
F32Interval
=
>
{
return
ulpInterval
(
1
/
Math
.
sqrt
(
n
)
2
)
;
}
)
}
;
export
function
inverseSqrtInterval
(
n
:
number
|
F32Interval
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
InverseSqrtIntervalOp
)
;
}
const
LdexpIntervalOp
:
BinaryToIntervalOp
=
{
impl
:
limitBinaryToIntervalDomain
(
{
x
:
[
toF32Interval
(
[
kValue
.
f32
.
negative
.
min
kValue
.
f32
.
positive
.
max
]
)
]
y
:
[
toF32Interval
(
[
-
126
128
]
)
]
}
(
e1
:
number
e2
:
number
)
:
F32Interval
=
>
{
const
result
=
e1
*
2
*
*
e2
;
if
(
Number
.
isNaN
(
result
)
)
{
return
F32Interval
.
any
(
)
;
}
return
correctlyRoundedInterval
(
result
)
;
}
)
}
;
export
function
ldexpInterval
(
e1
:
number
e2
:
number
)
:
F32Interval
{
return
roundAndFlushBinaryToInterval
(
e1
e2
LdexpIntervalOp
)
;
}
const
LengthIntervalScalarOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
return
sqrtInterval
(
multiplicationInterval
(
n
n
)
)
;
}
}
;
const
LengthIntervalVectorOp
:
VectorToIntervalOp
=
{
impl
:
(
n
:
number
[
]
)
:
F32Interval
=
>
{
return
sqrtInterval
(
dotInterval
(
n
n
)
)
;
}
}
;
export
function
lengthInterval
(
n
:
number
|
F32Interval
|
number
[
]
|
F32Vector
)
:
F32Interval
{
if
(
n
instanceof
Array
)
{
return
runVectorToIntervalOp
(
toF32Vector
(
n
)
LengthIntervalVectorOp
)
;
}
else
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
LengthIntervalScalarOp
)
;
}
}
const
LogIntervalOp
:
PointToIntervalOp
=
{
impl
:
limitPointToIntervalDomain
(
kGreaterThanZeroInterval
(
n
:
number
)
:
F32Interval
=
>
{
if
(
n
>
=
0
.
5
&
&
n
<
=
2
.
0
)
{
return
absoluteErrorInterval
(
Math
.
log
(
n
)
2
*
*
-
21
)
;
}
return
ulpInterval
(
Math
.
log
(
n
)
3
)
;
}
)
}
;
export
function
logInterval
(
x
:
number
|
F32Interval
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
x
)
LogIntervalOp
)
;
}
const
Log2IntervalOp
:
PointToIntervalOp
=
{
impl
:
limitPointToIntervalDomain
(
kGreaterThanZeroInterval
(
n
:
number
)
:
F32Interval
=
>
{
if
(
n
>
=
0
.
5
&
&
n
<
=
2
.
0
)
{
return
absoluteErrorInterval
(
Math
.
log2
(
n
)
2
*
*
-
21
)
;
}
return
ulpInterval
(
Math
.
log2
(
n
)
3
)
;
}
)
}
;
export
function
log2Interval
(
x
:
number
|
F32Interval
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
x
)
Log2IntervalOp
)
;
}
const
MaxIntervalOp
:
BinaryToIntervalOp
=
{
impl
:
(
x
:
number
y
:
number
)
:
F32Interval
=
>
{
return
correctlyRoundedInterval
(
Math
.
max
(
x
y
)
)
;
}
}
;
export
function
maxInterval
(
x
:
number
|
F32Interval
y
:
number
|
F32Interval
)
:
F32Interval
{
return
runBinaryToIntervalOp
(
toF32Interval
(
x
)
toF32Interval
(
y
)
MaxIntervalOp
)
;
}
const
MinIntervalOp
:
BinaryToIntervalOp
=
{
impl
:
(
x
:
number
y
:
number
)
:
F32Interval
=
>
{
return
correctlyRoundedInterval
(
Math
.
min
(
x
y
)
)
;
}
}
;
export
function
minInterval
(
x
:
number
|
F32Interval
y
:
number
|
F32Interval
)
:
F32Interval
{
return
runBinaryToIntervalOp
(
toF32Interval
(
x
)
toF32Interval
(
y
)
MinIntervalOp
)
;
}
const
MixImpreciseIntervalOp
:
TernaryToIntervalOp
=
{
impl
:
(
x
:
number
y
:
number
z
:
number
)
:
F32Interval
=
>
{
const
t
=
multiplicationInterval
(
subtractionInterval
(
y
x
)
z
)
;
return
additionInterval
(
x
t
)
;
}
}
;
export
const
mixIntervals
:
TernaryToInterval
[
]
=
[
mixImpreciseInterval
mixPreciseInterval
]
;
export
function
mixImpreciseInterval
(
x
:
number
y
:
number
z
:
number
)
:
F32Interval
{
return
runTernaryToIntervalOp
(
toF32Interval
(
x
)
toF32Interval
(
y
)
toF32Interval
(
z
)
MixImpreciseIntervalOp
)
;
}
const
MixPreciseIntervalOp
:
TernaryToIntervalOp
=
{
impl
:
(
x
:
number
y
:
number
z
:
number
)
:
F32Interval
=
>
{
const
t
=
multiplicationInterval
(
x
subtractionInterval
(
1
.
0
z
)
)
;
const
s
=
multiplicationInterval
(
y
z
)
;
return
additionInterval
(
t
s
)
;
}
}
;
export
function
mixPreciseInterval
(
x
:
number
y
:
number
z
:
number
)
:
F32Interval
{
return
runTernaryToIntervalOp
(
toF32Interval
(
x
)
toF32Interval
(
y
)
toF32Interval
(
z
)
MixPreciseIntervalOp
)
;
}
export
function
modfInterval
(
n
:
number
)
:
{
fract
:
F32Interval
;
whole
:
F32Interval
}
{
const
fract
=
correctlyRoundedInterval
(
n
%
1
.
0
)
;
const
whole
=
correctlyRoundedInterval
(
n
-
(
n
%
1
.
0
)
)
;
return
{
fract
whole
}
;
}
const
MultiplicationInnerOp
=
{
impl
:
(
x
:
number
y
:
number
)
:
F32Interval
=
>
{
return
correctlyRoundedInterval
(
x
*
y
)
;
}
}
;
const
MultiplicationIntervalOp
:
BinaryToIntervalOp
=
{
impl
:
(
x
:
number
y
:
number
)
:
F32Interval
=
>
{
return
roundAndFlushBinaryToInterval
(
x
y
MultiplicationInnerOp
)
;
}
}
;
export
function
multiplicationInterval
(
x
:
number
|
F32Interval
y
:
number
|
F32Interval
)
:
F32Interval
{
return
runBinaryToIntervalOp
(
toF32Interval
(
x
)
toF32Interval
(
y
)
MultiplicationIntervalOp
)
;
}
const
NegationIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
return
correctlyRoundedInterval
(
-
n
)
;
}
}
;
export
function
negationInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
NegationIntervalOp
)
;
}
const
NormalizeIntervalOp
:
VectorToVectorOp
=
{
impl
:
(
n
:
number
[
]
)
:
F32Vector
=
>
{
const
length
=
lengthInterval
(
n
)
;
return
toF32Vector
(
n
.
map
(
e
=
>
divisionInterval
(
e
length
)
)
)
;
}
}
;
export
function
normalizeInterval
(
n
:
number
[
]
)
:
F32Vector
{
return
runVectorToVectorOp
(
toF32Vector
(
n
)
NormalizeIntervalOp
)
;
}
const
PowIntervalOp
:
BinaryToIntervalOp
=
{
impl
:
(
x
:
number
y
:
number
)
:
F32Interval
=
>
{
return
exp2Interval
(
multiplicationInterval
(
y
log2Interval
(
x
)
)
)
;
}
}
;
export
function
powInterval
(
x
:
number
|
F32Interval
y
:
number
|
F32Interval
)
:
F32Interval
{
return
runBinaryToIntervalOp
(
toF32Interval
(
x
)
toF32Interval
(
y
)
PowIntervalOp
)
;
}
const
QuantizeToF16IntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
const
rounded
=
correctlyRoundedF16
(
n
)
;
const
flushed
=
addFlushedIfNeededF16
(
rounded
)
;
return
F32Interval
.
span
(
.
.
.
flushed
.
map
(
toF32Interval
)
)
;
}
}
;
export
function
quantizeToF16Interval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
QuantizeToF16IntervalOp
)
;
}
const
RadiansIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
return
multiplicationInterval
(
n
0
.
017453292519943295474
)
;
}
}
;
export
function
radiansInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
RadiansIntervalOp
)
;
}
const
ReflectIntervalOp
:
VectorPairToVectorOp
=
{
impl
:
(
x
:
number
[
]
y
:
number
[
]
)
:
F32Vector
=
>
{
assert
(
x
.
length
=
=
=
y
.
length
ReflectIntervalOp
received
x
(
{
x
}
)
and
y
(
{
y
}
)
with
different
numbers
of
elements
)
;
const
t
=
multiplicationInterval
(
2
.
0
dotInterval
(
x
y
)
)
;
const
rhs
=
multiplyVectorByScalar
(
y
t
)
;
return
runBinaryToIntervalOpComponentWise
(
toF32Vector
(
x
)
rhs
SubtractionIntervalOp
)
;
}
}
;
export
function
reflectInterval
(
x
:
number
[
]
y
:
number
[
]
)
:
F32Vector
{
assert
(
x
.
length
=
=
=
y
.
length
reflect
is
only
defined
for
vectors
with
the
same
number
of
elements
)
;
return
runVectorPairToVectorOp
(
toF32Vector
(
x
)
toF32Vector
(
y
)
ReflectIntervalOp
)
;
}
export
function
refractInterval
(
i
:
number
[
]
s
:
number
[
]
r
:
number
)
:
F32Vector
{
assert
(
i
.
length
=
=
=
s
.
length
refract
is
only
defined
for
vectors
with
the
same
number
of
elements
)
;
const
r_squared
=
multiplicationInterval
(
r
r
)
;
const
dot
=
dotInterval
(
s
i
)
;
const
dot_squared
=
multiplicationInterval
(
dot
dot
)
;
const
one_minus_dot_squared
=
subtractionInterval
(
1
dot_squared
)
;
const
k
=
subtractionInterval
(
1
.
0
multiplicationInterval
(
r_squared
one_minus_dot_squared
)
)
;
if
(
!
k
.
isFinite
(
)
|
|
k
.
containsZeroOrSubnormals
(
)
)
{
return
kAnyVector
[
toF32Vector
(
i
)
.
length
]
;
}
if
(
k
.
end
<
0
.
0
)
{
return
kZeroVector
[
toF32Vector
(
i
)
.
length
]
;
}
const
dot_times_r
=
multiplicationInterval
(
dot
r
)
;
const
k_sqrt
=
sqrtInterval
(
k
)
;
const
t
=
additionInterval
(
dot_times_r
k_sqrt
)
;
const
result
=
runBinaryToIntervalOpComponentWise
(
multiplyVectorByScalar
(
i
r
)
multiplyVectorByScalar
(
s
t
)
SubtractionIntervalOp
)
;
return
result
;
}
const
RemainderIntervalOp
:
BinaryToIntervalOp
=
{
impl
:
(
x
:
number
y
:
number
)
:
F32Interval
=
>
{
return
subtractionInterval
(
x
multiplicationInterval
(
y
truncInterval
(
divisionInterval
(
x
y
)
)
)
)
;
}
}
;
export
function
remainderInterval
(
x
:
number
y
:
number
)
:
F32Interval
{
return
runBinaryToIntervalOp
(
toF32Interval
(
x
)
toF32Interval
(
y
)
RemainderIntervalOp
)
;
}
const
RoundIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
const
k
=
Math
.
floor
(
n
)
;
const
diff_before
=
n
-
k
;
const
diff_after
=
k
+
1
-
n
;
if
(
diff_before
<
diff_after
)
{
return
correctlyRoundedInterval
(
k
)
;
}
else
if
(
diff_before
>
diff_after
)
{
return
correctlyRoundedInterval
(
k
+
1
)
;
}
if
(
k
%
2
=
=
=
0
)
{
return
correctlyRoundedInterval
(
k
)
;
}
return
correctlyRoundedInterval
(
k
+
1
)
;
}
}
;
export
function
roundInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
RoundIntervalOp
)
;
}
export
function
saturateInterval
(
n
:
number
)
:
F32Interval
{
return
runTernaryToIntervalOp
(
toF32Interval
(
n
)
toF32Interval
(
0
.
0
)
toF32Interval
(
1
.
0
)
ClampMinMaxIntervalOp
)
;
}
const
SignIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
if
(
n
>
0
.
0
)
{
return
correctlyRoundedInterval
(
1
.
0
)
;
}
if
(
n
<
0
.
0
)
{
return
correctlyRoundedInterval
(
-
1
.
0
)
;
}
return
correctlyRoundedInterval
(
0
.
0
)
;
}
}
;
export
function
signInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
SignIntervalOp
)
;
}
const
SinIntervalOp
:
PointToIntervalOp
=
{
impl
:
limitPointToIntervalDomain
(
kNegPiToPiInterval
(
n
:
number
)
:
F32Interval
=
>
{
return
absoluteErrorInterval
(
Math
.
sin
(
n
)
2
*
*
-
11
)
;
}
)
}
;
export
function
sinInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
SinIntervalOp
)
;
}
const
SinhIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
const
minus_n
=
negationInterval
(
n
)
;
return
multiplicationInterval
(
subtractionInterval
(
expInterval
(
n
)
expInterval
(
minus_n
)
)
0
.
5
)
;
}
}
;
export
function
sinhInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
SinhIntervalOp
)
;
}
const
SmoothStepOp
:
TernaryToIntervalOp
=
{
impl
:
(
low
:
number
high
:
number
x
:
number
)
:
F32Interval
=
>
{
const
t
=
clampMedianInterval
(
divisionInterval
(
subtractionInterval
(
x
low
)
subtractionInterval
(
high
low
)
)
0
.
0
1
.
0
)
;
return
multiplicationInterval
(
t
multiplicationInterval
(
t
subtractionInterval
(
3
.
0
multiplicationInterval
(
2
.
0
t
)
)
)
)
;
}
}
;
export
function
smoothStepInterval
(
low
:
number
high
:
number
x
:
number
)
:
F32Interval
{
return
runTernaryToIntervalOp
(
toF32Interval
(
low
)
toF32Interval
(
high
)
toF32Interval
(
x
)
SmoothStepOp
)
;
}
const
SqrtIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
return
divisionInterval
(
1
.
0
inverseSqrtInterval
(
n
)
)
;
}
}
;
export
function
sqrtInterval
(
n
:
number
|
F32Interval
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
SqrtIntervalOp
)
;
}
const
StepIntervalOp
:
BinaryToIntervalOp
=
{
impl
:
(
edge
:
number
x
:
number
)
:
F32Interval
=
>
{
if
(
edge
<
=
x
)
{
return
correctlyRoundedInterval
(
1
.
0
)
;
}
return
correctlyRoundedInterval
(
0
.
0
)
;
}
}
;
export
function
stepInterval
(
edge
:
number
x
:
number
)
:
F32Interval
{
return
runBinaryToIntervalOp
(
toF32Interval
(
edge
)
toF32Interval
(
x
)
StepIntervalOp
)
;
}
const
SubtractionIntervalOp
:
BinaryToIntervalOp
=
{
impl
:
(
x
:
number
y
:
number
)
:
F32Interval
=
>
{
return
correctlyRoundedInterval
(
x
-
y
)
;
}
}
;
export
function
subtractionInterval
(
x
:
number
|
F32Interval
y
:
number
|
F32Interval
)
:
F32Interval
{
return
runBinaryToIntervalOp
(
toF32Interval
(
x
)
toF32Interval
(
y
)
SubtractionIntervalOp
)
;
}
const
TanIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
return
divisionInterval
(
sinInterval
(
n
)
cosInterval
(
n
)
)
;
}
}
;
export
function
tanInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
TanIntervalOp
)
;
}
const
TanhIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
return
divisionInterval
(
sinhInterval
(
n
)
coshInterval
(
n
)
)
;
}
}
;
export
function
tanhInterval
(
n
:
number
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
TanhIntervalOp
)
;
}
const
TruncIntervalOp
:
PointToIntervalOp
=
{
impl
:
(
n
:
number
)
:
F32Interval
=
>
{
return
correctlyRoundedInterval
(
Math
.
trunc
(
n
)
)
;
}
}
;
export
function
truncInterval
(
n
:
number
|
F32Interval
)
:
F32Interval
{
return
runPointToIntervalOp
(
toF32Interval
(
n
)
TruncIntervalOp
)
;
}
const
unpackData
=
new
ArrayBuffer
(
4
)
;
const
unpackDataU32
=
new
Uint32Array
(
unpackData
)
;
const
unpackDataU16
=
new
Uint16Array
(
unpackData
)
;
const
unpackDataU8
=
new
Uint8Array
(
unpackData
)
;
const
unpackDataI16
=
new
Int16Array
(
unpackData
)
;
const
unpackDataI8
=
new
Int8Array
(
unpackData
)
;
const
unpackDataF16
=
new
Float16Array
(
unpackData
)
;
export
function
unpack2x16floatInterval
(
n
:
number
)
:
F32Vector
{
assert
(
n
>
=
kValue
.
u32
.
min
&
&
n
<
=
kValue
.
u32
.
max
'
unpack2x16floatInterval
only
accepts
values
on
the
bounds
of
u32
'
)
;
unpackDataU32
[
0
]
=
n
;
if
(
unpackDataF16
.
some
(
f
=
>
!
isFiniteF16
(
f
)
)
)
{
return
[
F32Interval
.
any
(
)
F32Interval
.
any
(
)
]
;
}
const
result
:
F32Vector
=
[
quantizeToF16Interval
(
unpackDataF16
[
0
]
)
quantizeToF16Interval
(
unpackDataF16
[
1
]
)
]
;
if
(
result
.
some
(
r
=
>
!
r
.
isFinite
(
)
)
)
{
return
[
F32Interval
.
any
(
)
F32Interval
.
any
(
)
]
;
}
return
result
;
}
const
Unpack2x16snormIntervalOp
=
(
n
:
number
)
:
F32Interval
=
>
{
return
maxInterval
(
divisionInterval
(
n
32767
)
-
1
)
;
}
;
export
function
unpack2x16snormInterval
(
n
:
number
)
:
F32Vector
{
assert
(
n
>
=
kValue
.
u32
.
min
&
&
n
<
=
kValue
.
u32
.
max
'
unpack2x16snormInterval
only
accepts
values
on
the
bounds
of
u32
'
)
;
unpackDataU32
[
0
]
=
n
;
return
[
Unpack2x16snormIntervalOp
(
unpackDataI16
[
0
]
)
Unpack2x16snormIntervalOp
(
unpackDataI16
[
1
]
)
]
;
}
const
Unpack2x16unormIntervalOp
=
(
n
:
number
)
:
F32Interval
=
>
{
return
divisionInterval
(
n
65535
)
;
}
;
export
function
unpack2x16unormInterval
(
n
:
number
)
:
F32Vector
{
assert
(
n
>
=
kValue
.
u32
.
min
&
&
n
<
=
kValue
.
u32
.
max
'
unpack2x16unormInterval
only
accepts
values
on
the
bounds
of
u32
'
)
;
unpackDataU32
[
0
]
=
n
;
return
[
Unpack2x16unormIntervalOp
(
unpackDataU16
[
0
]
)
Unpack2x16unormIntervalOp
(
unpackDataU16
[
1
]
)
]
;
}
const
Unpack4x8snormIntervalOp
=
(
n
:
number
)
:
F32Interval
=
>
{
return
maxInterval
(
divisionInterval
(
n
127
)
-
1
)
;
}
;
export
function
unpack4x8snormInterval
(
n
:
number
)
:
F32Vector
{
assert
(
n
>
=
kValue
.
u32
.
min
&
&
n
<
=
kValue
.
u32
.
max
'
unpack4x8snormInterval
only
accepts
values
on
the
bounds
of
u32
'
)
;
unpackDataU32
[
0
]
=
n
;
return
[
Unpack4x8snormIntervalOp
(
unpackDataI8
[
0
]
)
Unpack4x8snormIntervalOp
(
unpackDataI8
[
1
]
)
Unpack4x8snormIntervalOp
(
unpackDataI8
[
2
]
)
Unpack4x8snormIntervalOp
(
unpackDataI8
[
3
]
)
]
;
}
const
Unpack4x8unormIntervalOp
=
(
n
:
number
)
:
F32Interval
=
>
{
return
divisionInterval
(
n
255
)
;
}
;
export
function
unpack4x8unormInterval
(
n
:
number
)
:
F32Vector
{
assert
(
n
>
=
kValue
.
u32
.
min
&
&
n
<
=
kValue
.
u32
.
max
'
unpack4x8unormInterval
only
accepts
values
on
the
bounds
of
u32
'
)
;
unpackDataU32
[
0
]
=
n
;
return
[
Unpack4x8unormIntervalOp
(
unpackDataU8
[
0
]
)
Unpack4x8unormIntervalOp
(
unpackDataU8
[
1
]
)
Unpack4x8unormIntervalOp
(
unpackDataU8
[
2
]
)
Unpack4x8unormIntervalOp
(
unpackDataU8
[
3
]
)
]
;
}
