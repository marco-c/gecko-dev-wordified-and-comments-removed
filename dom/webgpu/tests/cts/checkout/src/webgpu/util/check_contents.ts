import
{
assert
ErrorWithExtra
iterRange
range
TypedArrayBufferView
TypedArrayBufferViewConstructor
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
Float16Array
}
from
'
.
.
/
.
.
/
external
/
petamoriken
/
float16
/
float16
.
js
'
;
import
{
generatePrettyTable
}
from
'
.
/
pretty_diff_tables
.
js
'
;
export
type
CheckElementsGenerator
=
(
index
:
number
)
=
>
number
;
export
type
CheckElementsPredicate
=
(
index
:
number
value
:
number
|
bigint
)
=
>
boolean
;
export
type
CheckElementsSupplementalTableRows
=
Array
<
{
leftHeader
:
string
;
getValueForCell
:
(
index
:
number
)
=
>
string
|
number
|
bigint
;
}
>
;
export
function
checkElementsEqual
(
actual
:
TypedArrayBufferView
expected
:
TypedArrayBufferView
)
:
ErrorWithExtra
|
undefined
{
assert
(
actual
.
constructor
=
=
=
expected
.
constructor
'
TypedArray
type
mismatch
'
)
;
assert
(
actual
.
length
=
=
=
expected
.
length
length
mismatch
:
expected
{
expected
.
length
}
got
{
actual
.
length
}
)
;
let
failedElementsFirstMaybe
:
number
|
undefined
=
undefined
;
const
failedElements
:
(
true
|
undefined
)
[
]
=
[
]
;
for
(
let
i
=
0
;
i
<
actual
.
length
;
+
+
i
)
{
if
(
actual
[
i
]
!
=
=
expected
[
i
]
)
{
failedElementsFirstMaybe
?
?
=
i
;
failedElements
[
i
]
=
true
;
}
}
if
(
failedElementsFirstMaybe
=
=
=
undefined
)
{
return
undefined
;
}
const
failedElementsFirst
=
failedElementsFirstMaybe
;
return
failCheckElements
(
{
actual
failedElements
failedElementsFirst
predicatePrinter
:
[
{
leftHeader
:
'
expected
=
=
'
getValueForCell
:
index
=
>
expected
[
index
]
}
]
}
)
;
}
export
function
checkElementsBetween
(
actual
:
TypedArrayBufferView
expected
:
readonly
[
CheckElementsGenerator
CheckElementsGenerator
]
)
:
ErrorWithExtra
|
undefined
{
const
error
=
checkElementsPassPredicate
(
actual
(
index
value
)
=
>
value
>
=
Math
.
min
(
expected
[
0
]
(
index
)
expected
[
1
]
(
index
)
)
&
&
value
<
=
Math
.
max
(
expected
[
0
]
(
index
)
expected
[
1
]
(
index
)
)
{
predicatePrinter
:
[
{
leftHeader
:
'
between
'
getValueForCell
:
index
=
>
expected
[
0
]
(
index
)
}
{
leftHeader
:
'
and
'
getValueForCell
:
index
=
>
expected
[
1
]
(
index
)
}
]
}
)
;
return
error
?
new
ErrorWithExtra
(
error
(
)
=
>
(
{
expected
}
)
)
:
undefined
;
}
export
function
checkElementsEqualEither
(
actual
:
TypedArrayBufferView
expected
:
readonly
[
TypedArrayBufferView
TypedArrayBufferView
]
)
:
ErrorWithExtra
|
undefined
{
const
error
=
checkElementsPassPredicate
(
actual
(
index
value
)
=
>
value
=
=
=
expected
[
0
]
[
index
]
|
|
value
=
=
=
expected
[
1
]
[
index
]
{
predicatePrinter
:
[
{
leftHeader
:
'
either
'
getValueForCell
:
index
=
>
expected
[
0
]
[
index
]
}
{
leftHeader
:
'
or
'
getValueForCell
:
index
=
>
expected
[
1
]
[
index
]
}
]
}
)
;
return
error
?
new
ErrorWithExtra
(
error
(
)
=
>
(
{
expected
}
)
)
:
undefined
;
}
export
function
checkElementsEqualGenerated
(
actual
:
TypedArrayBufferView
generator
:
CheckElementsGenerator
)
:
ErrorWithExtra
|
undefined
{
let
failedElementsFirstMaybe
:
number
|
undefined
=
undefined
;
const
failedElements
:
(
true
|
undefined
)
[
]
=
[
]
;
for
(
let
i
=
0
;
i
<
actual
.
length
;
+
+
i
)
{
if
(
actual
[
i
]
!
=
=
generator
(
i
)
)
{
failedElementsFirstMaybe
?
?
=
i
;
failedElements
[
i
]
=
true
;
}
}
if
(
failedElementsFirstMaybe
=
=
=
undefined
)
{
return
undefined
;
}
const
failedElementsFirst
=
failedElementsFirstMaybe
;
const
error
=
failCheckElements
(
{
actual
failedElements
failedElementsFirst
predicatePrinter
:
[
{
leftHeader
:
'
expected
=
=
'
getValueForCell
:
index
=
>
generator
(
index
)
}
]
}
)
;
return
new
ErrorWithExtra
(
error
(
)
=
>
(
{
generator
}
)
)
;
}
export
function
checkElementsPassPredicate
(
actual
:
TypedArrayBufferView
predicate
:
CheckElementsPredicate
{
predicatePrinter
}
:
{
predicatePrinter
?
:
CheckElementsSupplementalTableRows
}
)
:
ErrorWithExtra
|
undefined
{
let
failedElementsFirstMaybe
:
number
|
undefined
=
undefined
;
const
failedElements
:
(
true
|
undefined
)
[
]
=
[
]
;
for
(
let
i
=
0
;
i
<
actual
.
length
;
+
+
i
)
{
if
(
!
predicate
(
i
actual
[
i
]
)
)
{
failedElementsFirstMaybe
?
?
=
i
;
failedElements
[
i
]
=
true
;
}
}
if
(
failedElementsFirstMaybe
=
=
=
undefined
)
{
return
undefined
;
}
const
failedElementsFirst
=
failedElementsFirstMaybe
;
return
failCheckElements
(
{
actual
failedElements
failedElementsFirst
predicatePrinter
}
)
;
}
interface
CheckElementsFailOpts
{
actual
:
TypedArrayBufferView
;
failedElements
:
(
true
|
undefined
)
[
]
;
failedElementsFirst
:
number
;
predicatePrinter
?
:
CheckElementsSupplementalTableRows
;
}
function
failCheckElements
(
{
actual
failedElements
failedElementsFirst
predicatePrinter
}
:
CheckElementsFailOpts
)
:
ErrorWithExtra
{
const
size
=
actual
.
length
;
const
ctor
=
actual
.
constructor
as
TypedArrayBufferViewConstructor
;
const
printAsFloat
=
ctor
=
=
=
Float16Array
|
|
ctor
=
=
=
Float32Array
|
|
ctor
=
=
=
Float64Array
;
const
failedElementsLast
=
failedElements
.
length
-
1
;
const
printElementsStart
=
Math
.
max
(
0
failedElementsFirst
-
1
)
;
const
printElementsEnd
=
Math
.
min
(
size
failedElementsLast
+
2
)
;
const
printElementsCount
=
printElementsEnd
-
printElementsStart
;
const
numericToString
=
(
val
:
number
|
bigint
)
:
string
=
>
{
if
(
typeof
val
=
=
=
'
number
'
&
&
printAsFloat
)
{
return
val
.
toPrecision
(
4
)
;
}
return
intToPaddedHex
(
val
{
byteLength
:
ctor
.
BYTES_PER_ELEMENT
}
)
;
}
;
const
numberPrefix
=
printAsFloat
?
'
'
:
'
0x
:
'
;
const
printActual
=
actual
.
subarray
(
printElementsStart
printElementsEnd
)
;
const
printExpected
:
Array
<
Iterable
<
string
|
number
|
bigint
>
>
=
[
]
;
if
(
predicatePrinter
)
{
for
(
const
{
leftHeader
getValueForCell
:
cell
}
of
predicatePrinter
)
{
printExpected
.
push
(
(
function
*
(
)
{
yield
*
[
leftHeader
'
'
]
;
yield
*
iterRange
(
printElementsCount
i
=
>
cell
(
printElementsStart
+
i
)
)
;
}
)
(
)
)
;
}
}
const
printFailedValueMarkers
=
(
function
*
(
)
{
yield
*
[
'
failed
-
>
'
'
'
]
;
yield
*
range
(
printElementsCount
i
=
>
(
failedElements
[
printElementsStart
+
i
]
?
'
xx
'
:
'
'
)
)
;
}
)
(
)
;
const
opts
=
{
fillToWidth
:
120
numericToString
}
;
const
msg
=
Array
had
unexpected
contents
at
indices
{
failedElementsFirst
}
through
{
failedElementsLast
}
.
Starting
at
index
{
printElementsStart
}
:
{
generatePrettyTable
(
opts
[
[
'
actual
=
=
'
numberPrefix
.
.
.
printActual
]
printFailedValueMarkers
.
.
.
printExpected
]
)
}
;
return
new
ErrorWithExtra
(
msg
(
)
=
>
(
{
actual
:
actual
.
slice
(
)
}
)
)
;
}
function
intToPaddedHex
(
val
:
number
|
bigint
{
byteLength
}
:
{
byteLength
:
number
}
)
{
assert
(
Number
.
isInteger
(
val
)
'
number
must
be
integer
'
)
;
const
is_negative
=
typeof
val
=
=
=
'
number
'
?
val
<
0
:
val
<
0n
;
let
str
=
(
is_negative
?
-
val
:
val
)
.
toString
(
16
)
;
if
(
byteLength
)
str
=
str
.
padStart
(
byteLength
*
2
'
0
'
)
;
if
(
is_negative
)
str
=
'
-
'
+
str
;
return
str
;
}
