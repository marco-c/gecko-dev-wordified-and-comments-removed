import
{
assert
ErrorWithExtra
iterRange
range
TypedArrayBufferView
TypedArrayBufferViewConstructor
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
float16BitsToFloat32
}
from
'
.
/
conversion
.
js
'
;
import
{
generatePrettyTable
}
from
'
.
/
pretty_diff_tables
.
js
'
;
export
type
CheckElementsGenerator
=
(
index
:
number
)
=
>
number
;
export
type
CheckElementsPredicate
=
(
index
:
number
value
:
number
)
=
>
boolean
;
export
type
CheckElementsSupplementalTableRows
=
Array
<
{
leftHeader
:
string
;
getValueForCell
:
(
index
:
number
)
=
>
number
|
string
;
}
>
;
export
function
checkElementsEqual
(
actual
:
TypedArrayBufferView
expected
:
TypedArrayBufferView
)
:
ErrorWithExtra
|
undefined
{
assert
(
actual
.
constructor
=
=
=
expected
.
constructor
'
TypedArray
type
mismatch
'
)
;
assert
(
actual
.
length
=
=
=
expected
.
length
'
size
mismatch
'
)
;
return
checkElementsEqualGenerated
(
actual
i
=
>
expected
[
i
]
)
;
}
export
function
checkElementsBetween
(
actual
:
TypedArrayBufferView
expected
:
readonly
[
CheckElementsGenerator
CheckElementsGenerator
]
)
:
ErrorWithExtra
|
undefined
{
const
error
=
checkElementsPassPredicate
(
actual
(
index
value
)
=
>
value
>
=
Math
.
min
(
expected
[
0
]
(
index
)
expected
[
1
]
(
index
)
)
&
&
value
<
=
Math
.
max
(
expected
[
0
]
(
index
)
expected
[
1
]
(
index
)
)
{
predicatePrinter
:
[
{
leftHeader
:
'
between
'
getValueForCell
:
index
=
>
expected
[
0
]
(
index
)
}
{
leftHeader
:
'
and
'
getValueForCell
:
index
=
>
expected
[
1
]
(
index
)
}
]
}
)
;
return
error
?
new
ErrorWithExtra
(
error
(
)
=
>
(
{
expected
}
)
)
:
undefined
;
}
export
function
checkElementsFloat16Between
(
actual
:
TypedArrayBufferView
expected
:
readonly
[
TypedArrayBufferView
TypedArrayBufferView
]
)
:
ErrorWithExtra
|
undefined
{
assert
(
actual
.
BYTES_PER_ELEMENT
=
=
=
2
'
bytes
per
element
need
to
be
2
(
16bit
)
'
)
;
const
actualF32
=
new
Float32Array
(
actual
.
length
)
;
actual
.
forEach
(
(
v
:
number
i
:
number
)
=
>
{
actualF32
[
i
]
=
float16BitsToFloat32
(
v
)
;
}
)
;
const
expectedF32
=
[
new
Float32Array
(
expected
[
0
]
.
length
)
new
Float32Array
(
expected
[
1
]
.
length
)
]
;
expected
[
0
]
.
forEach
(
(
v
:
number
i
:
number
)
=
>
{
expectedF32
[
0
]
[
i
]
=
float16BitsToFloat32
(
v
)
;
}
)
;
expected
[
1
]
.
forEach
(
(
v
:
number
i
:
number
)
=
>
{
expectedF32
[
1
]
[
i
]
=
float16BitsToFloat32
(
v
)
;
}
)
;
const
error
=
checkElementsPassPredicate
(
actualF32
(
index
value
)
=
>
value
>
=
Math
.
min
(
expectedF32
[
0
]
[
index
]
expectedF32
[
1
]
[
index
]
)
&
&
value
<
=
Math
.
max
(
expectedF32
[
0
]
[
index
]
expectedF32
[
1
]
[
index
]
)
{
predicatePrinter
:
[
{
leftHeader
:
'
between
'
getValueForCell
:
index
=
>
expectedF32
[
0
]
[
index
]
}
{
leftHeader
:
'
and
'
getValueForCell
:
index
=
>
expectedF32
[
1
]
[
index
]
}
]
}
)
;
return
error
?
new
ErrorWithExtra
(
error
(
)
=
>
(
{
expectedF32
}
)
)
:
undefined
;
}
export
function
checkElementsEqualEither
(
actual
:
TypedArrayBufferView
expected
:
readonly
[
TypedArrayBufferView
TypedArrayBufferView
]
)
:
ErrorWithExtra
|
undefined
{
const
error
=
checkElementsPassPredicate
(
actual
(
index
value
)
=
>
value
=
=
=
expected
[
0
]
[
index
]
|
|
value
=
=
=
expected
[
1
]
[
index
]
{
predicatePrinter
:
[
{
leftHeader
:
'
either
'
getValueForCell
:
index
=
>
expected
[
0
]
[
index
]
}
{
leftHeader
:
'
or
'
getValueForCell
:
index
=
>
expected
[
1
]
[
index
]
}
]
}
)
;
return
error
?
new
ErrorWithExtra
(
error
(
)
=
>
(
{
expected
}
)
)
:
undefined
;
}
export
function
checkElementsEqualGenerated
(
actual
:
TypedArrayBufferView
generator
:
CheckElementsGenerator
)
:
ErrorWithExtra
|
undefined
{
const
error
=
checkElementsPassPredicate
(
actual
(
index
value
)
=
>
value
=
=
=
generator
(
index
)
{
predicatePrinter
:
[
{
leftHeader
:
'
expected
=
=
'
getValueForCell
:
index
=
>
generator
(
index
)
}
]
}
)
;
return
error
?
new
ErrorWithExtra
(
error
(
)
=
>
(
{
generator
}
)
)
:
undefined
;
}
export
function
checkElementsPassPredicate
(
actual
:
TypedArrayBufferView
predicate
:
CheckElementsPredicate
{
predicatePrinter
}
:
{
predicatePrinter
?
:
CheckElementsSupplementalTableRows
}
)
:
ErrorWithExtra
|
undefined
{
const
size
=
actual
.
length
;
const
ctor
=
actual
.
constructor
as
TypedArrayBufferViewConstructor
;
const
printAsFloat
=
ctor
=
=
=
Float32Array
|
|
ctor
=
=
=
Float64Array
;
let
failedElementsFirstMaybe
:
number
|
undefined
=
undefined
;
const
failedElements
:
(
true
|
undefined
)
[
]
=
[
]
;
for
(
let
i
=
0
;
i
<
size
;
+
+
i
)
{
if
(
!
predicate
(
i
actual
[
i
]
)
)
{
failedElementsFirstMaybe
?
?
=
i
;
failedElements
[
i
]
=
true
;
}
}
if
(
failedElementsFirstMaybe
=
=
=
undefined
)
{
return
undefined
;
}
const
failedElementsFirst
=
failedElementsFirstMaybe
;
const
failedElementsLast
=
failedElements
.
length
-
1
;
const
printElementsStart
=
Math
.
max
(
0
failedElementsFirst
-
1
)
;
const
printElementsEnd
=
Math
.
min
(
size
failedElementsLast
+
2
)
;
const
printElementsCount
=
printElementsEnd
-
printElementsStart
;
const
numberToString
=
printAsFloat
?
(
n
:
number
)
=
>
n
.
toPrecision
(
4
)
:
(
n
:
number
)
=
>
intToPaddedHex
(
n
{
byteLength
:
ctor
.
BYTES_PER_ELEMENT
}
)
;
const
numberPrefix
=
printAsFloat
?
'
'
:
'
0x
:
'
;
const
printActual
=
actual
.
subarray
(
printElementsStart
printElementsEnd
)
;
const
printExpected
:
Array
<
Iterable
<
string
|
number
>
>
=
[
]
;
if
(
predicatePrinter
)
{
for
(
const
{
leftHeader
getValueForCell
:
cell
}
of
predicatePrinter
)
{
printExpected
.
push
(
(
function
*
(
)
{
yield
*
[
leftHeader
'
'
]
;
yield
*
iterRange
(
printElementsCount
i
=
>
cell
(
printElementsStart
+
i
)
)
;
}
)
(
)
)
;
}
}
const
printFailedValueMarkers
=
(
function
*
(
)
{
yield
*
[
'
failed
-
>
'
'
'
]
;
yield
*
range
(
printElementsCount
i
=
>
(
failedElements
[
printElementsStart
+
i
]
?
'
xx
'
:
'
'
)
)
;
}
)
(
)
;
const
opts
=
{
fillToWidth
:
120
numberToString
}
;
const
msg
=
Array
had
unexpected
contents
at
indices
{
failedElementsFirst
}
through
{
failedElementsLast
}
.
Starting
at
index
{
printElementsStart
}
:
{
generatePrettyTable
(
opts
[
[
'
actual
=
=
'
numberPrefix
.
.
.
printActual
]
printFailedValueMarkers
.
.
.
printExpected
]
)
}
;
return
new
ErrorWithExtra
(
msg
(
)
=
>
(
{
actual
:
actual
.
slice
(
)
}
)
)
;
}
function
intToPaddedHex
(
number
:
number
{
byteLength
}
:
{
byteLength
:
number
}
)
{
assert
(
Number
.
isInteger
(
number
)
'
number
must
be
integer
'
)
;
let
s
=
Math
.
abs
(
number
)
.
toString
(
16
)
;
if
(
byteLength
)
s
=
s
.
padStart
(
byteLength
*
2
'
0
'
)
;
if
(
number
<
0
)
s
=
'
-
'
+
s
;
return
s
;
}
