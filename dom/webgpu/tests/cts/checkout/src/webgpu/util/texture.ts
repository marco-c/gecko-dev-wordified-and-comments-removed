import
{
assert
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
kTextureFormatInfo
}
from
'
.
.
/
capability_info
.
js
'
;
import
{
align
}
from
'
.
/
math
.
js
'
;
import
{
TexelView
}
from
'
.
/
texture
/
texel_view
.
js
'
;
import
{
reifyExtent3D
}
from
'
.
/
unions
.
js
'
;
export
function
makeTextureWithContents
(
device
:
GPUDevice
texelView
:
TexelView
desc
:
Omit
<
GPUTextureDescriptor
'
format
'
>
)
:
GPUTexture
{
const
{
width
height
depthOrArrayLayers
}
=
reifyExtent3D
(
desc
.
size
)
;
const
{
bytesPerBlock
blockWidth
}
=
kTextureFormatInfo
[
texelView
.
format
]
;
assert
(
blockWidth
=
=
=
1
)
;
const
bytesPerRow
=
align
(
bytesPerBlock
*
width
256
)
;
const
stagingBuffer
=
device
.
createBuffer
(
{
mappedAtCreation
:
true
size
:
bytesPerRow
*
height
*
depthOrArrayLayers
usage
:
GPUBufferUsage
.
COPY_SRC
}
)
;
texelView
.
writeTextureData
(
new
Uint8Array
(
stagingBuffer
.
getMappedRange
(
)
)
{
bytesPerRow
rowsPerImage
:
height
subrectOrigin
:
[
0
0
0
]
subrectSize
:
[
width
height
depthOrArrayLayers
]
}
)
;
stagingBuffer
.
unmap
(
)
;
const
texture
=
device
.
createTexture
(
{
.
.
.
desc
format
:
texelView
.
format
usage
:
desc
.
usage
|
GPUTextureUsage
.
COPY_DST
}
)
;
const
commandEncoder
=
device
.
createCommandEncoder
(
)
;
commandEncoder
.
copyBufferToTexture
(
{
buffer
:
stagingBuffer
bytesPerRow
}
{
texture
}
desc
.
size
)
;
device
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
stagingBuffer
.
destroy
(
)
;
return
texture
;
}
