import
{
assert
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
GPUTest
}
from
'
.
.
/
gpu_test
.
js
'
;
import
{
getTextureCopyLayout
}
from
'
.
/
texture
/
layout
.
js
'
;
import
{
TexelView
}
from
'
.
/
texture
/
texel_view
.
js
'
;
import
{
reifyExtent3D
}
from
'
.
/
unions
.
js
'
;
export
function
createTextureFromTexelViews
(
t
:
GPUTest
texelViews
:
TexelView
[
]
desc
:
Omit
<
GPUTextureDescriptor
'
format
'
>
)
:
GPUTexture
{
assert
(
texelViews
.
length
>
0
&
&
texelViews
.
every
(
e
=
>
e
.
format
=
=
=
texelViews
[
0
]
.
format
)
)
;
const
format
=
texelViews
[
0
]
.
format
;
const
{
width
height
depthOrArrayLayers
}
=
reifyExtent3D
(
desc
.
size
)
;
const
texture
=
t
.
createTextureTracked
(
{
.
.
.
desc
format
:
texelViews
[
0
]
.
format
usage
:
desc
.
usage
|
GPUTextureUsage
.
COPY_DST
mipLevelCount
:
texelViews
.
length
}
)
;
const
commandEncoder
=
t
.
device
.
createCommandEncoder
(
)
;
const
stagingBuffers
=
[
]
;
for
(
let
mipLevel
=
0
;
mipLevel
<
texelViews
.
length
;
mipLevel
+
+
)
{
const
{
bytesPerRow
rowsPerImage
mipSize
:
[
mipWidth
mipHeight
mipDepthOrArray
]
}
=
getTextureCopyLayout
(
format
desc
.
dimension
?
?
'
2d
'
[
width
height
depthOrArrayLayers
]
{
mipLevel
}
)
;
const
stagingBuffer
=
t
.
createBufferTracked
(
{
mappedAtCreation
:
true
size
:
bytesPerRow
*
mipHeight
*
mipDepthOrArray
usage
:
GPUBufferUsage
.
COPY_SRC
}
)
;
stagingBuffers
.
push
(
stagingBuffer
)
;
texelViews
[
mipLevel
]
.
writeTextureData
(
new
Uint8Array
(
stagingBuffer
.
getMappedRange
(
)
)
{
bytesPerRow
rowsPerImage
:
mipHeight
subrectOrigin
:
[
0
0
0
]
subrectSize
:
[
mipWidth
mipHeight
mipDepthOrArray
]
}
)
;
stagingBuffer
.
unmap
(
)
;
commandEncoder
.
copyBufferToTexture
(
{
buffer
:
stagingBuffer
bytesPerRow
rowsPerImage
}
{
texture
mipLevel
}
[
mipWidth
mipHeight
mipDepthOrArray
]
)
;
}
t
.
device
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
stagingBuffers
.
forEach
(
value
=
>
value
.
destroy
(
)
)
;
return
texture
;
}
