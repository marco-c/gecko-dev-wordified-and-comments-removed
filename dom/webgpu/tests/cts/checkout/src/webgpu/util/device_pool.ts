import
{
SkipTestCase
}
from
'
.
.
/
.
.
/
common
/
framework
/
fixture
.
js
'
;
import
{
attemptGarbageCollection
}
from
'
.
.
/
.
.
/
common
/
util
/
collect_garbage
.
js
'
;
import
{
getGPU
}
from
'
.
.
/
.
.
/
common
/
util
/
navigator_gpu
.
js
'
;
import
{
assert
raceWithRejectOnTimeout
assertReject
unreachable
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
kLimitInfo
kLimits
}
from
'
.
.
/
capability_info
.
js
'
;
export
interface
DeviceProvider
{
readonly
device
:
GPUDevice
;
expectDeviceLost
(
reason
:
GPUDeviceLostReason
)
:
void
;
}
class
TestFailedButDeviceReusable
extends
Error
{
}
class
FeaturesNotSupported
extends
Error
{
}
export
class
TestOOMedShouldAttemptGC
extends
Error
{
}
export
class
DevicePool
{
private
holders
:
'
uninitialized
'
|
'
failed
'
|
DescriptorToHolderMap
=
'
uninitialized
'
;
async
acquire
(
descriptor
?
:
UncanonicalizedDeviceDescriptor
)
:
Promise
<
DeviceProvider
>
{
let
errorMessage
=
'
'
;
if
(
this
.
holders
=
=
=
'
uninitialized
'
)
{
this
.
holders
=
new
DescriptorToHolderMap
(
)
;
try
{
await
this
.
holders
.
getOrCreate
(
undefined
)
;
}
catch
(
ex
)
{
this
.
holders
=
'
failed
'
;
if
(
ex
instanceof
Error
)
{
errorMessage
=
with
{
ex
.
name
}
"
{
ex
.
message
}
"
;
}
}
}
assert
(
this
.
holders
!
=
=
'
failed
'
WebGPU
device
failed
to
initialize
{
errorMessage
}
;
not
retrying
)
;
const
holder
=
await
this
.
holders
.
getOrCreate
(
descriptor
)
;
assert
(
holder
.
state
=
=
=
'
free
'
'
Device
was
in
use
on
DevicePool
.
acquire
'
)
;
holder
.
state
=
'
acquired
'
;
holder
.
beginTestScope
(
)
;
return
holder
;
}
async
release
(
holder
:
DeviceProvider
)
:
Promise
<
void
>
{
assert
(
this
.
holders
instanceof
DescriptorToHolderMap
'
DevicePool
got
into
a
bad
state
'
)
;
assert
(
holder
instanceof
DeviceHolder
'
DeviceProvider
should
always
be
a
DeviceHolder
'
)
;
assert
(
holder
.
state
=
=
=
'
acquired
'
'
trying
to
release
a
device
while
already
released
'
)
;
try
{
await
holder
.
endTestScope
(
)
;
assert
(
holder
.
lostInfo
=
=
=
undefined
Device
was
unexpectedly
lost
.
Reason
:
{
holder
.
lostInfo
?
.
reason
}
Message
:
{
holder
.
lostInfo
?
.
message
}
)
;
}
catch
(
ex
)
{
if
(
!
(
ex
instanceof
TestFailedButDeviceReusable
)
)
{
this
.
holders
.
delete
(
holder
)
;
if
(
'
destroy
'
in
holder
.
device
)
{
holder
.
device
.
destroy
(
)
;
}
holder
.
releaseGPUDevice
(
)
;
if
(
ex
instanceof
TestOOMedShouldAttemptGC
)
{
await
attemptGarbageCollection
(
)
;
}
}
const
expectedDeviceLost
=
holder
.
expectedLostReason
!
=
=
undefined
&
&
holder
.
lostInfo
!
=
=
undefined
&
&
holder
.
expectedLostReason
=
=
=
holder
.
lostInfo
.
reason
;
if
(
!
expectedDeviceLost
)
{
throw
ex
;
}
}
finally
{
holder
.
state
=
'
free
'
;
}
}
}
class
DescriptorToHolderMap
{
private
unsupported
:
Set
<
string
>
=
new
Set
(
)
;
private
holders
:
Map
<
string
DeviceHolder
>
=
new
Map
(
)
;
delete
(
holder
:
DeviceHolder
)
:
void
{
for
(
const
[
k
v
]
of
this
.
holders
)
{
if
(
v
=
=
=
holder
)
{
this
.
holders
.
delete
(
k
)
;
return
;
}
}
unreachable
(
"
internal
error
:
couldn
'
t
find
DeviceHolder
to
delete
"
)
;
}
async
getOrCreate
(
uncanonicalizedDescriptor
:
UncanonicalizedDeviceDescriptor
|
undefined
)
:
Promise
<
DeviceHolder
>
{
const
[
descriptor
key
]
=
canonicalizeDescriptor
(
uncanonicalizedDescriptor
)
;
if
(
this
.
unsupported
.
has
(
key
)
)
{
throw
new
SkipTestCase
(
GPUDeviceDescriptor
previously
failed
:
{
JSON
.
stringify
(
descriptor
)
}
)
;
}
{
const
value
=
this
.
holders
.
get
(
key
)
;
if
(
value
)
{
this
.
holders
.
delete
(
key
)
;
this
.
holders
.
set
(
key
value
)
;
return
value
;
}
}
let
value
;
try
{
value
=
await
DeviceHolder
.
create
(
descriptor
)
;
}
catch
(
ex
)
{
if
(
ex
instanceof
FeaturesNotSupported
)
{
this
.
unsupported
.
add
(
key
)
;
throw
new
SkipTestCase
(
GPUDeviceDescriptor
not
supported
:
{
JSON
.
stringify
(
descriptor
)
}
\
n
{
ex
?
.
message
?
?
'
'
}
)
;
}
throw
ex
;
}
this
.
insertAndCleanUp
(
key
value
)
;
return
value
;
}
private
insertAndCleanUp
(
key
:
string
value
:
DeviceHolder
)
{
this
.
holders
.
set
(
key
value
)
;
const
kMaxEntries
=
5
;
if
(
this
.
holders
.
size
>
kMaxEntries
)
{
for
(
const
[
key
]
of
this
.
holders
)
{
this
.
holders
.
delete
(
key
)
;
return
;
}
}
}
}
export
type
UncanonicalizedDeviceDescriptor
=
{
requiredFeatures
?
:
Iterable
<
GPUFeatureName
>
;
requiredLimits
?
:
Record
<
string
GPUSize32
>
;
nonGuaranteedFeatures
?
:
undefined
;
nonGuaranteedLimits
?
:
undefined
;
extensions
?
:
undefined
;
features
?
:
undefined
;
}
;
type
CanonicalDeviceDescriptor
=
Omit
<
Required
<
GPUDeviceDescriptor
>
'
label
'
|
'
nonGuaranteedFeatures
'
|
'
nonGuaranteedLimits
'
>
;
function
canonicalizeDescriptor
(
desc
:
UncanonicalizedDeviceDescriptor
|
undefined
)
:
[
CanonicalDeviceDescriptor
|
undefined
string
]
{
if
(
desc
=
=
=
undefined
)
{
return
[
undefined
'
'
]
;
}
const
featuresCanonicalized
=
desc
.
requiredFeatures
?
Array
.
from
(
new
Set
(
desc
.
requiredFeatures
)
)
.
sort
(
)
:
[
]
;
const
limitsCanonicalized
:
Record
<
string
number
>
=
{
}
;
if
(
desc
.
requiredLimits
)
{
for
(
const
limit
of
kLimits
)
{
const
requestedValue
=
desc
.
requiredLimits
[
limit
]
;
const
defaultValue
=
kLimitInfo
[
limit
]
.
default
;
if
(
requestedValue
!
=
=
undefined
&
&
requestedValue
!
=
=
defaultValue
)
{
limitsCanonicalized
[
limit
]
=
requestedValue
;
}
}
}
const
descriptorCanonicalized
:
CanonicalDeviceDescriptor
=
{
requiredFeatures
:
featuresCanonicalized
requiredLimits
:
limitsCanonicalized
defaultQueue
:
{
}
}
;
return
[
descriptorCanonicalized
JSON
.
stringify
(
descriptorCanonicalized
)
]
;
}
function
supportsFeature
(
adapter
:
GPUAdapter
descriptor
:
CanonicalDeviceDescriptor
|
undefined
)
:
boolean
{
if
(
descriptor
=
=
=
undefined
)
{
return
true
;
}
for
(
const
feature
of
descriptor
.
requiredFeatures
)
{
if
(
!
adapter
.
features
.
has
(
feature
)
)
{
return
false
;
}
}
return
true
;
}
type
DeviceHolderState
=
'
free
'
|
'
acquired
'
;
class
DeviceHolder
implements
DeviceProvider
{
private
_device
:
GPUDevice
|
undefined
;
state
:
DeviceHolderState
=
'
free
'
;
lostInfo
?
:
GPUDeviceLostInfo
;
expectedLostReason
?
:
GPUDeviceLostReason
;
static
async
create
(
descriptor
:
CanonicalDeviceDescriptor
|
undefined
)
:
Promise
<
DeviceHolder
>
{
const
gpu
=
getGPU
(
)
;
const
adapter
=
await
gpu
.
requestAdapter
(
)
;
assert
(
adapter
!
=
=
null
'
requestAdapter
returned
null
'
)
;
if
(
!
supportsFeature
(
adapter
descriptor
)
)
{
throw
new
FeaturesNotSupported
(
'
One
or
more
features
are
not
supported
'
)
;
}
const
device
=
await
adapter
.
requestDevice
(
descriptor
)
;
assert
(
device
!
=
=
null
'
requestDevice
returned
null
'
)
;
return
new
DeviceHolder
(
device
)
;
}
private
constructor
(
device
:
GPUDevice
)
{
this
.
_device
=
device
;
void
this
.
_device
.
lost
.
then
(
ev
=
>
{
this
.
lostInfo
=
ev
;
}
)
;
}
get
device
(
)
{
assert
(
this
.
_device
!
=
=
undefined
)
;
return
this
.
_device
;
}
beginTestScope
(
)
:
void
{
assert
(
this
.
state
=
=
=
'
acquired
'
)
;
this
.
device
.
pushErrorScope
(
'
out
-
of
-
memory
'
)
;
this
.
device
.
pushErrorScope
(
'
validation
'
)
;
}
expectDeviceLost
(
reason
:
GPUDeviceLostReason
)
{
assert
(
this
.
state
=
=
=
'
acquired
'
)
;
this
.
expectedLostReason
=
reason
;
}
endTestScope
(
)
:
Promise
<
void
>
{
assert
(
this
.
state
=
=
=
'
acquired
'
)
;
const
kTimeout
=
5000
;
return
raceWithRejectOnTimeout
(
this
.
attemptEndTestScope
(
)
kTimeout
'
endTestScope
timed
out
'
)
;
}
private
async
attemptEndTestScope
(
)
:
Promise
<
void
>
{
let
gpuValidationError
:
GPUError
|
null
;
let
gpuOutOfMemoryError
:
GPUError
|
null
;
this
.
device
.
queue
.
submit
(
[
]
)
;
try
{
[
gpuValidationError
gpuOutOfMemoryError
]
=
await
Promise
.
all
(
[
this
.
device
.
popErrorScope
(
)
this
.
device
.
popErrorScope
(
)
]
)
;
}
catch
(
ex
)
{
assert
(
this
.
lostInfo
!
=
=
undefined
'
popErrorScope
failed
;
did
beginTestScope
get
missed
?
'
)
;
throw
ex
;
}
if
(
this
.
device
.
queue
.
onSubmittedWorkDone
)
{
await
this
.
device
.
queue
.
onSubmittedWorkDone
(
)
;
}
await
assertReject
(
this
.
device
.
popErrorScope
(
)
'
There
was
an
extra
error
scope
on
the
stack
after
a
test
'
)
;
if
(
gpuValidationError
!
=
=
null
)
{
assert
(
gpuValidationError
instanceof
GPUValidationError
)
;
throw
new
TestFailedButDeviceReusable
(
Unexpected
validation
error
occurred
:
{
gpuValidationError
.
message
}
)
;
}
if
(
gpuOutOfMemoryError
!
=
=
null
)
{
assert
(
gpuOutOfMemoryError
instanceof
GPUOutOfMemoryError
)
;
throw
new
TestOOMedShouldAttemptGC
(
'
Unexpected
out
-
of
-
memory
error
occurred
'
)
;
}
}
releaseGPUDevice
(
)
:
void
{
this
.
_device
=
undefined
;
}
}
