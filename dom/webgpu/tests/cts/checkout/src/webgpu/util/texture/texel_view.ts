import
{
assert
memcpy
}
from
'
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
kTextureFormatInfo
EncodableTextureFormat
}
from
'
.
.
/
.
.
/
format_info
.
js
'
;
import
{
generatePrettyTable
numericToStringBuilder
}
from
'
.
.
/
pretty_diff_tables
.
js
'
;
import
{
reifyExtent3D
reifyOrigin3D
}
from
'
.
.
/
unions
.
js
'
;
import
{
fullSubrectCoordinates
}
from
'
.
/
base
.
js
'
;
import
{
kTexelRepresentationInfo
makeClampToRange
PerTexelComponent
}
from
'
.
/
texel_data
.
js
'
;
export
type
PerPixelAtLevel
<
T
>
=
(
coords
:
Required
<
GPUOrigin3DDict
>
)
=
>
Readonly
<
T
>
;
export
class
TexelView
{
readonly
format
:
EncodableTextureFormat
;
readonly
bytes
:
PerPixelAtLevel
<
Uint8Array
>
;
readonly
ulpFromZero
:
PerPixelAtLevel
<
PerTexelComponent
<
number
>
>
;
readonly
color
:
PerPixelAtLevel
<
PerTexelComponent
<
number
>
>
;
private
constructor
(
format
:
EncodableTextureFormat
{
bytes
ulpFromZero
color
}
:
{
bytes
:
PerPixelAtLevel
<
Uint8Array
>
;
ulpFromZero
:
PerPixelAtLevel
<
PerTexelComponent
<
number
>
>
;
color
:
PerPixelAtLevel
<
PerTexelComponent
<
number
>
>
;
}
)
{
this
.
format
=
format
;
this
.
bytes
=
bytes
;
this
.
ulpFromZero
=
ulpFromZero
;
this
.
color
=
color
;
}
static
fromTextureDataByReference
(
format
:
EncodableTextureFormat
subrectData
:
Uint8Array
|
Uint8ClampedArray
{
bytesPerRow
rowsPerImage
subrectOrigin
subrectSize
}
:
{
bytesPerRow
:
number
;
rowsPerImage
:
number
;
subrectOrigin
:
GPUOrigin3D
;
subrectSize
:
GPUExtent3D
;
}
)
{
const
origin
=
reifyOrigin3D
(
subrectOrigin
)
;
const
size
=
reifyExtent3D
(
subrectSize
)
;
const
info
=
kTextureFormatInfo
[
format
]
;
assert
(
info
.
blockWidth
=
=
=
1
&
&
info
.
blockHeight
=
=
=
1
'
unimplemented
for
block
formats
'
)
;
return
TexelView
.
fromTexelsAsBytes
(
format
coords
=
>
{
assert
(
coords
.
x
>
=
origin
.
x
&
&
coords
.
y
>
=
origin
.
y
&
&
coords
.
z
>
=
origin
.
z
&
&
coords
.
x
<
origin
.
x
+
size
.
width
&
&
coords
.
y
<
origin
.
y
+
size
.
height
&
&
coords
.
z
<
origin
.
z
+
size
.
depthOrArrayLayers
(
)
=
>
coordinate
(
{
coords
.
x
}
{
coords
.
y
}
{
coords
.
z
}
)
out
of
bounds
)
;
const
imageOffsetInRows
=
(
coords
.
z
-
origin
.
z
)
*
rowsPerImage
;
const
rowOffset
=
(
imageOffsetInRows
+
(
coords
.
y
-
origin
.
y
)
)
*
bytesPerRow
;
const
offset
=
rowOffset
+
(
coords
.
x
-
origin
.
x
)
*
info
.
bytesPerBlock
;
return
subrectData
.
subarray
(
offset
offset
+
info
.
bytesPerBlock
)
as
Uint8Array
;
}
)
;
}
static
fromTexelsAsBytes
(
format
:
EncodableTextureFormat
generator
:
PerPixelAtLevel
<
Uint8Array
>
)
:
TexelView
{
const
info
=
kTextureFormatInfo
[
format
]
;
assert
(
info
.
blockWidth
=
=
=
1
&
&
info
.
blockHeight
=
=
=
1
'
unimplemented
for
block
formats
'
)
;
const
repr
=
kTexelRepresentationInfo
[
format
]
;
return
new
TexelView
(
format
{
bytes
:
generator
ulpFromZero
:
coords
=
>
repr
.
bitsToULPFromZero
(
repr
.
unpackBits
(
generator
(
coords
)
)
)
color
:
coords
=
>
repr
.
bitsToNumber
(
repr
.
unpackBits
(
generator
(
coords
)
)
)
}
)
;
}
static
fromTexelsAsColors
(
format
:
EncodableTextureFormat
generator
:
PerPixelAtLevel
<
PerTexelComponent
<
number
>
>
{
clampToFormatRange
=
false
}
:
{
clampToFormatRange
?
:
boolean
}
=
{
}
)
:
TexelView
{
const
info
=
kTextureFormatInfo
[
format
]
;
assert
(
info
.
blockWidth
=
=
=
1
&
&
info
.
blockHeight
=
=
=
1
'
unimplemented
for
block
formats
'
)
;
if
(
clampToFormatRange
)
{
const
applyClamp
=
makeClampToRange
(
format
)
;
const
oldGenerator
=
generator
;
generator
=
coords
=
>
applyClamp
(
oldGenerator
(
coords
)
)
;
}
const
repr
=
kTexelRepresentationInfo
[
format
]
;
return
new
TexelView
(
format
{
bytes
:
coords
=
>
new
Uint8Array
(
repr
.
pack
(
repr
.
encode
(
generator
(
coords
)
)
)
)
ulpFromZero
:
coords
=
>
repr
.
bitsToULPFromZero
(
repr
.
numberToBits
(
generator
(
coords
)
)
)
color
:
generator
}
)
;
}
writeTextureData
(
subrectData
:
Uint8Array
|
Uint8ClampedArray
{
bytesPerRow
rowsPerImage
subrectOrigin
:
subrectOrigin_
subrectSize
:
subrectSize_
}
:
{
bytesPerRow
:
number
;
rowsPerImage
:
number
;
subrectOrigin
:
GPUOrigin3D
;
subrectSize
:
GPUExtent3D
;
}
)
:
void
{
const
subrectOrigin
=
reifyOrigin3D
(
subrectOrigin_
)
;
const
subrectSize
=
reifyExtent3D
(
subrectSize_
)
;
const
info
=
kTextureFormatInfo
[
this
.
format
]
;
assert
(
info
.
blockWidth
=
=
=
1
&
&
info
.
blockHeight
=
=
=
1
'
unimplemented
for
block
formats
'
)
;
for
(
let
z
=
subrectOrigin
.
z
;
z
<
subrectOrigin
.
z
+
subrectSize
.
depthOrArrayLayers
;
+
+
z
)
{
for
(
let
y
=
subrectOrigin
.
y
;
y
<
subrectOrigin
.
y
+
subrectSize
.
height
;
+
+
y
)
{
for
(
let
x
=
subrectOrigin
.
x
;
x
<
subrectOrigin
.
x
+
subrectSize
.
width
;
+
+
x
)
{
const
start
=
(
z
*
rowsPerImage
+
y
)
*
bytesPerRow
+
x
*
info
.
bytesPerBlock
;
memcpy
(
{
src
:
this
.
bytes
(
{
x
y
z
}
)
}
{
dst
:
subrectData
start
}
)
;
}
}
}
}
toString
(
subrectOrigin
:
Required
<
GPUOrigin3DDict
>
subrectSize
:
Required
<
GPUExtent3DDict
>
)
{
const
info
=
kTextureFormatInfo
[
this
.
format
]
;
const
repr
=
kTexelRepresentationInfo
[
this
.
format
]
;
const
printAsInteger
=
info
.
color
?
[
'
uint
'
'
sint
'
]
.
includes
(
info
.
color
.
type
)
:
!
info
.
depth
;
const
numericToString
=
numericToStringBuilder
(
printAsInteger
)
;
const
componentOrderStr
=
repr
.
componentOrder
.
join
(
'
'
)
+
'
:
'
;
const
subrectCoords
=
[
.
.
.
fullSubrectCoordinates
(
subrectOrigin
subrectSize
)
]
;
const
printCoords
=
(
function
*
(
)
{
yield
*
[
'
coords
'
'
=
=
'
'
X
Y
Z
:
'
]
;
for
(
const
coords
of
subrectCoords
)
yield
{
coords
.
x
}
{
coords
.
y
}
{
coords
.
z
}
;
}
)
(
)
;
const
printActualBytes
=
(
function
*
(
t
:
TexelView
)
{
yield
*
[
'
act
.
texel
bytes
(
little
-
endian
)
'
'
=
=
'
'
0x
:
'
]
;
for
(
const
coords
of
subrectCoords
)
{
yield
Array
.
from
(
t
.
bytes
(
coords
)
b
=
>
b
.
toString
(
16
)
.
padStart
(
2
'
0
'
)
)
.
join
(
'
'
)
;
}
}
)
(
this
)
;
const
printActualColors
=
(
function
*
(
t
:
TexelView
)
{
yield
*
[
'
act
.
colors
'
'
=
=
'
componentOrderStr
]
;
for
(
const
coords
of
subrectCoords
)
{
const
pixel
=
t
.
color
(
coords
)
;
yield
{
repr
.
componentOrder
.
map
(
ch
=
>
numericToString
(
pixel
[
ch
]
!
)
)
.
join
(
'
'
)
}
;
}
}
)
(
this
)
;
const
opts
=
{
fillToWidth
:
120
numericToString
}
;
return
{
generatePrettyTable
(
opts
[
printCoords
printActualBytes
printActualColors
]
)
}
;
}
}
