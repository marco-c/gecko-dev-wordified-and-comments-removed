import
{
assert
memcpy
}
from
'
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
EncodableTextureFormat
kTextureFormatInfo
}
from
'
.
.
/
.
.
/
capability_info
.
js
'
;
import
{
reifyExtent3D
reifyOrigin3D
}
from
'
.
.
/
unions
.
js
'
;
import
{
kTexelRepresentationInfo
makeClampToRange
PerTexelComponent
}
from
'
.
/
texel_data
.
js
'
;
export
type
PerPixelAtLevel
<
T
>
=
(
coords
:
Required
<
GPUOrigin3DDict
>
)
=
>
Readonly
<
T
>
;
export
class
TexelView
{
readonly
format
:
EncodableTextureFormat
;
readonly
bytes
:
PerPixelAtLevel
<
Uint8Array
>
;
readonly
ulpFromZero
:
PerPixelAtLevel
<
PerTexelComponent
<
number
>
>
;
readonly
color
:
PerPixelAtLevel
<
PerTexelComponent
<
number
>
>
;
private
constructor
(
format
:
EncodableTextureFormat
{
bytes
ulpFromZero
color
}
:
{
bytes
:
PerPixelAtLevel
<
Uint8Array
>
;
ulpFromZero
:
PerPixelAtLevel
<
PerTexelComponent
<
number
>
>
;
color
:
PerPixelAtLevel
<
PerTexelComponent
<
number
>
>
;
}
)
{
this
.
format
=
format
;
this
.
bytes
=
bytes
;
this
.
ulpFromZero
=
ulpFromZero
;
this
.
color
=
color
;
}
static
fromTextureDataByReference
(
format
:
EncodableTextureFormat
subrectData
:
Uint8Array
|
Uint8ClampedArray
{
bytesPerRow
rowsPerImage
subrectOrigin
subrectSize
}
:
{
bytesPerRow
:
number
;
rowsPerImage
:
number
;
subrectOrigin
:
GPUOrigin3D
;
subrectSize
:
GPUExtent3D
;
}
)
{
const
origin
=
reifyOrigin3D
(
subrectOrigin
)
;
const
size
=
reifyExtent3D
(
subrectSize
)
;
const
info
=
kTextureFormatInfo
[
format
]
;
assert
(
info
.
blockWidth
=
=
=
1
&
&
info
.
blockHeight
=
=
=
1
'
unimplemented
for
block
formats
'
)
;
return
TexelView
.
fromTexelsAsBytes
(
format
coords
=
>
{
assert
(
coords
.
x
>
=
origin
.
x
&
&
coords
.
y
>
=
origin
.
y
&
&
coords
.
z
>
=
origin
.
z
&
&
coords
.
x
<
origin
.
x
+
size
.
width
&
&
coords
.
y
<
origin
.
y
+
size
.
height
&
&
coords
.
z
<
origin
.
z
+
size
.
depthOrArrayLayers
'
coordinate
out
of
bounds
'
)
;
const
imageOffsetInRows
=
(
coords
.
z
-
origin
.
z
)
*
rowsPerImage
;
const
rowOffset
=
(
imageOffsetInRows
+
(
coords
.
y
-
origin
.
y
)
)
*
bytesPerRow
;
const
offset
=
rowOffset
+
(
coords
.
x
-
origin
.
x
)
*
info
.
bytesPerBlock
;
return
subrectData
.
subarray
(
offset
offset
+
info
.
bytesPerBlock
)
as
Uint8Array
;
}
)
;
}
static
fromTexelsAsBytes
(
format
:
EncodableTextureFormat
generator
:
PerPixelAtLevel
<
Uint8Array
>
)
:
TexelView
{
const
info
=
kTextureFormatInfo
[
format
]
;
assert
(
info
.
blockWidth
=
=
=
1
&
&
info
.
blockHeight
=
=
=
1
'
unimplemented
for
block
formats
'
)
;
const
repr
=
kTexelRepresentationInfo
[
format
]
;
return
new
TexelView
(
format
{
bytes
:
generator
ulpFromZero
:
coords
=
>
repr
.
bitsToULPFromZero
(
repr
.
unpackBits
(
generator
(
coords
)
)
)
color
:
coords
=
>
repr
.
bitsToNumber
(
repr
.
unpackBits
(
generator
(
coords
)
)
)
}
)
;
}
static
fromTexelsAsColors
(
format
:
EncodableTextureFormat
generator
:
PerPixelAtLevel
<
PerTexelComponent
<
number
>
>
{
clampToFormatRange
=
false
}
:
{
clampToFormatRange
?
:
boolean
}
=
{
}
)
:
TexelView
{
const
info
=
kTextureFormatInfo
[
format
]
;
assert
(
info
.
blockWidth
=
=
=
1
&
&
info
.
blockHeight
=
=
=
1
'
unimplemented
for
block
formats
'
)
;
if
(
clampToFormatRange
)
{
const
applyClamp
=
makeClampToRange
(
format
)
;
const
oldGenerator
=
generator
;
generator
=
coords
=
>
applyClamp
(
oldGenerator
(
coords
)
)
;
}
const
repr
=
kTexelRepresentationInfo
[
format
]
;
return
new
TexelView
(
format
{
bytes
:
coords
=
>
new
Uint8Array
(
repr
.
pack
(
repr
.
encode
(
generator
(
coords
)
)
)
)
ulpFromZero
:
coords
=
>
repr
.
bitsToULPFromZero
(
repr
.
numberToBits
(
generator
(
coords
)
)
)
color
:
generator
}
)
;
}
writeTextureData
(
subrectData
:
Uint8Array
|
Uint8ClampedArray
{
bytesPerRow
rowsPerImage
subrectOrigin
:
subrectOrigin_
subrectSize
:
subrectSize_
}
:
{
bytesPerRow
:
number
;
rowsPerImage
:
number
;
subrectOrigin
:
GPUOrigin3D
;
subrectSize
:
GPUExtent3D
;
}
)
:
void
{
const
subrectOrigin
=
reifyOrigin3D
(
subrectOrigin_
)
;
const
subrectSize
=
reifyExtent3D
(
subrectSize_
)
;
const
info
=
kTextureFormatInfo
[
this
.
format
]
;
assert
(
info
.
blockWidth
=
=
=
1
&
&
info
.
blockHeight
=
=
=
1
'
unimplemented
for
block
formats
'
)
;
for
(
let
z
=
subrectOrigin
.
z
;
z
<
subrectOrigin
.
z
+
subrectSize
.
depthOrArrayLayers
;
+
+
z
)
{
for
(
let
y
=
subrectOrigin
.
y
;
y
<
subrectOrigin
.
y
+
subrectSize
.
height
;
+
+
y
)
{
for
(
let
x
=
subrectOrigin
.
x
;
x
<
subrectOrigin
.
x
+
subrectSize
.
width
;
+
+
x
)
{
const
start
=
(
z
*
rowsPerImage
+
y
)
*
bytesPerRow
+
x
*
info
.
bytesPerBlock
;
memcpy
(
{
src
:
this
.
bytes
(
{
x
y
z
}
)
}
{
dst
:
subrectData
start
}
)
;
}
}
}
}
}
