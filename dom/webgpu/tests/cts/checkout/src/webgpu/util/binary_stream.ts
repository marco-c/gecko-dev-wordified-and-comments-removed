import
{
assert
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
float16ToUint16
uint16ToFloat16
}
from
'
.
/
conversion
.
js
'
;
import
{
align
}
from
'
.
/
math
.
js
'
;
export
default
class
BinaryStream
{
constructor
(
buffer
:
ArrayBufferLike
)
{
this
.
offset
=
0
;
this
.
view
=
new
DataView
(
buffer
)
;
}
buffer
(
)
:
Uint8Array
{
return
new
Uint8Array
(
this
.
view
.
buffer
0
align
(
this
.
offset
8
)
)
;
}
writeBool
(
value
:
boolean
)
{
this
.
view
.
setUint8
(
this
.
offset
+
+
value
?
255
:
0
)
;
}
readBool
(
)
:
boolean
{
const
val
=
this
.
view
.
getUint8
(
this
.
offset
+
+
)
;
assert
(
val
=
=
=
0
|
|
val
=
=
=
255
)
;
return
val
!
=
=
0
;
}
writeU8
(
value
:
number
)
{
this
.
view
.
setUint8
(
this
.
offset
+
+
value
)
;
}
readU8
(
)
:
number
{
return
this
.
view
.
getUint8
(
this
.
offset
+
+
)
;
}
writeU16
(
value
:
number
)
{
this
.
view
.
setUint16
(
this
.
alignedOffset
(
2
)
value
true
)
;
}
readU16
(
)
:
number
{
return
this
.
view
.
getUint16
(
this
.
alignedOffset
(
2
)
true
)
;
}
writeU32
(
value
:
number
)
{
this
.
view
.
setUint32
(
this
.
alignedOffset
(
4
)
value
true
)
;
}
readU32
(
)
:
number
{
return
this
.
view
.
getUint32
(
this
.
alignedOffset
(
4
)
true
)
;
}
writeI8
(
value
:
number
)
{
this
.
view
.
setInt8
(
this
.
offset
+
+
value
)
;
}
readI8
(
)
:
number
{
return
this
.
view
.
getInt8
(
this
.
offset
+
+
)
;
}
writeI16
(
value
:
number
)
{
this
.
view
.
setInt16
(
this
.
alignedOffset
(
2
)
value
true
)
;
}
readI16
(
)
:
number
{
return
this
.
view
.
getInt16
(
this
.
alignedOffset
(
2
)
true
)
;
}
writeI64
(
value
:
bigint
)
{
this
.
view
.
setBigInt64
(
this
.
alignedOffset
(
8
)
value
true
)
;
}
readI64
(
)
:
bigint
{
return
this
.
view
.
getBigInt64
(
this
.
alignedOffset
(
8
)
true
)
;
}
writeI32
(
value
:
number
)
{
this
.
view
.
setInt32
(
this
.
alignedOffset
(
4
)
value
true
)
;
}
readI32
(
)
:
number
{
return
this
.
view
.
getInt32
(
this
.
alignedOffset
(
4
)
true
)
;
}
writeF16
(
value
:
number
)
{
this
.
writeU16
(
float16ToUint16
(
value
)
)
;
}
readF16
(
)
:
number
{
return
uint16ToFloat16
(
this
.
readU16
(
)
)
;
}
writeF32
(
value
:
number
)
{
this
.
view
.
setFloat32
(
this
.
alignedOffset
(
4
)
value
true
)
;
}
readF32
(
)
:
number
{
return
this
.
view
.
getFloat32
(
this
.
alignedOffset
(
4
)
true
)
;
}
writeF64
(
value
:
number
)
{
this
.
view
.
setFloat64
(
this
.
alignedOffset
(
8
)
value
true
)
;
}
readF64
(
)
:
number
{
return
this
.
view
.
getFloat64
(
this
.
alignedOffset
(
8
)
true
)
;
}
writeString
(
value
:
string
)
{
this
.
writeU32
(
value
.
length
)
;
for
(
let
i
=
0
;
i
<
value
.
length
;
i
+
+
)
{
this
.
writeU16
(
value
.
charCodeAt
(
i
)
)
;
}
}
readString
(
)
:
string
{
const
len
=
this
.
readU32
(
)
;
const
codes
=
new
Array
<
number
>
(
len
)
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
codes
[
i
]
=
this
.
readU16
(
)
;
}
return
String
.
fromCharCode
(
.
.
.
codes
)
;
}
writeArray
<
T
>
(
value
:
readonly
T
[
]
writeElement
:
(
s
:
BinaryStream
element
:
T
)
=
>
void
)
{
this
.
writeU32
(
value
.
length
)
;
for
(
const
element
of
value
)
{
writeElement
(
this
element
)
;
}
}
readArray
<
T
>
(
readElement
:
(
s
:
BinaryStream
)
=
>
T
)
:
T
[
]
{
const
len
=
this
.
readU32
(
)
;
const
array
=
new
Array
<
T
>
(
len
)
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
array
[
i
]
=
readElement
(
this
)
;
}
return
array
;
}
writeCond
<
T
F
>
(
cond
:
boolean
fns
:
{
if_true
:
(
)
=
>
T
;
if_false
:
(
)
=
>
F
}
)
{
this
.
writeBool
(
cond
)
;
if
(
cond
)
{
return
fns
.
if_true
(
)
;
}
else
{
return
fns
.
if_false
(
)
;
}
}
readCond
<
T
F
>
(
fns
:
{
if_true
:
(
)
=
>
T
;
if_false
:
(
)
=
>
F
}
)
{
if
(
this
.
readBool
(
)
)
{
return
fns
.
if_true
(
)
;
}
else
{
return
fns
.
if_false
(
)
;
}
}
private
alignedOffset
(
bytes
:
number
)
{
const
aligned
=
align
(
this
.
offset
bytes
)
;
this
.
offset
=
aligned
+
bytes
;
return
aligned
;
}
private
offset
:
number
;
private
view
:
DataView
;
}
