import
{
Colors
}
from
'
.
.
/
.
.
/
common
/
util
/
colors
.
js
'
;
import
{
objectsToRecord
}
from
'
.
.
/
.
.
/
common
/
util
/
data_tables
.
js
'
;
import
{
ROArrayArray
}
from
'
.
.
/
.
.
/
common
/
util
/
types
.
js
'
;
import
{
assert
objectEquals
TypedArrayBufferView
unreachable
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
Float16Array
}
from
'
.
.
/
.
.
/
external
/
petamoriken
/
float16
/
float16
.
js
'
;
import
BinaryStream
from
'
.
/
binary_stream
.
js
'
;
import
{
kBit
}
from
'
.
/
constants
.
js
'
;
import
{
align
cartesianProduct
clamp
correctlyRoundedF16
isFiniteF16
isSubnormalNumberF16
isSubnormalNumberF32
isSubnormalNumberF64
}
from
'
.
/
math
.
js
'
;
export
function
floatAsNormalizedIntegerUnquantized
(
float
:
number
bits
:
number
signed
:
boolean
)
:
number
{
if
(
signed
)
{
assert
(
float
>
=
-
1
&
&
float
<
=
1
(
)
=
>
{
float
}
out
of
bounds
of
snorm
)
;
const
max
=
Math
.
pow
(
2
bits
-
1
)
-
1
;
return
float
*
max
;
}
else
{
assert
(
float
>
=
0
&
&
float
<
=
1
(
)
=
>
{
float
}
out
of
bounds
of
unorm
)
;
const
max
=
Math
.
pow
(
2
bits
)
-
1
;
return
float
*
max
;
}
}
export
function
floatAsNormalizedInteger
(
float
:
number
bits
:
number
signed
:
boolean
)
:
number
{
return
Math
.
round
(
floatAsNormalizedIntegerUnquantized
(
float
bits
signed
)
)
;
}
export
function
normalizedIntegerAsFloat
(
integer
:
number
bits
:
number
signed
:
boolean
)
:
number
{
assert
(
Number
.
isInteger
(
integer
)
)
;
if
(
signed
)
{
const
max
=
Math
.
pow
(
2
bits
-
1
)
-
1
;
assert
(
integer
>
=
-
max
-
1
&
&
integer
<
=
max
)
;
if
(
integer
=
=
=
-
max
-
1
)
{
integer
=
-
max
;
}
return
integer
/
max
;
}
else
{
const
max
=
Math
.
pow
(
2
bits
)
-
1
;
assert
(
integer
>
=
0
&
&
integer
<
=
max
)
;
return
integer
/
max
;
}
}
export
function
numbersApproximatelyEqual
(
a
:
number
b
:
number
maxDiff
:
number
=
0
)
{
return
(
(
Number
.
isNaN
(
a
)
&
&
Number
.
isNaN
(
b
)
)
|
|
(
a
=
=
=
Number
.
POSITIVE_INFINITY
&
&
b
=
=
=
Number
.
POSITIVE_INFINITY
)
|
|
(
a
=
=
=
Number
.
NEGATIVE_INFINITY
&
&
b
=
=
=
Number
.
NEGATIVE_INFINITY
)
|
|
Math
.
abs
(
a
-
b
)
<
=
maxDiff
)
;
}
const
workingData
=
new
ArrayBuffer
(
8
)
;
const
workingDataU32
=
new
Uint32Array
(
workingData
)
;
const
workingDataU16
=
new
Uint16Array
(
workingData
)
;
const
workingDataU8
=
new
Uint8Array
(
workingData
)
;
const
workingDataF32
=
new
Float32Array
(
workingData
)
;
const
workingDataF16
=
new
Float16Array
(
workingData
)
;
const
workingDataI16
=
new
Int16Array
(
workingData
)
;
const
workingDataI32
=
new
Int32Array
(
workingData
)
;
const
workingDataI8
=
new
Int8Array
(
workingData
)
;
const
workingDataF64
=
new
Float64Array
(
workingData
)
;
const
workingDataI64
=
new
BigInt64Array
(
workingData
)
;
const
workingDataU64
=
new
BigUint64Array
(
workingData
)
;
const
workingDataView
=
new
DataView
(
workingData
)
;
export
function
float32ToFloatBits
(
n
:
number
signBits
:
0
|
1
exponentBits
:
number
mantissaBits
:
number
bias
:
number
)
:
number
{
assert
(
exponentBits
<
=
8
)
;
assert
(
mantissaBits
<
=
23
)
;
if
(
Number
.
isNaN
(
n
)
)
{
return
(
(
(
1
<
<
exponentBits
)
-
1
)
<
<
mantissaBits
)
|
(
(
1
<
<
mantissaBits
)
-
1
)
;
}
workingDataView
.
setFloat32
(
0
n
true
)
;
const
bits
=
workingDataView
.
getUint32
(
0
true
)
;
const
sign
=
(
bits
>
>
31
)
&
signBits
;
if
(
n
=
=
=
0
)
{
if
(
sign
=
=
=
1
)
{
return
1
<
<
(
exponentBits
+
mantissaBits
)
;
}
return
0
;
}
if
(
signBits
=
=
=
0
)
{
assert
(
n
>
=
0
)
;
}
if
(
!
Number
.
isFinite
(
n
)
)
{
return
(
(
(
(
1
<
<
exponentBits
)
-
1
)
<
<
mantissaBits
)
|
(
n
<
0
?
2
*
*
(
exponentBits
+
mantissaBits
)
:
0
)
)
;
}
const
mantissaBitsToDiscard
=
23
-
mantissaBits
;
const
exp
=
(
(
bits
>
>
23
)
&
0xff
)
-
127
;
const
newBiasedExp
=
bias
+
exp
;
assert
(
newBiasedExp
<
1
<
<
exponentBits
(
)
=
>
input
number
{
n
}
overflows
target
type
)
;
if
(
newBiasedExp
<
=
0
)
{
return
sign
<
<
(
exponentBits
+
mantissaBits
)
;
}
else
{
const
newMantissa
=
(
bits
&
0x7fffff
)
>
>
mantissaBitsToDiscard
;
return
(
sign
<
<
(
exponentBits
+
mantissaBits
)
)
|
(
newBiasedExp
<
<
mantissaBits
)
|
newMantissa
;
}
}
export
function
float32ToFloat16Bits
(
n
:
number
)
{
return
float32ToFloatBits
(
n
1
5
10
15
)
;
}
export
function
float16BitsToFloat32
(
float16Bits
:
number
)
:
number
{
return
floatBitsToNumber
(
float16Bits
kFloat16Format
)
;
}
type
FloatFormat
=
{
signed
:
0
|
1
;
exponentBits
:
number
;
mantissaBits
:
number
;
bias
:
number
}
;
export
const
kFloat32Format
=
{
signed
:
1
exponentBits
:
8
mantissaBits
:
23
bias
:
127
}
as
const
;
export
const
kFloat16Format
=
{
signed
:
1
exponentBits
:
5
mantissaBits
:
10
bias
:
15
}
as
const
;
export
const
kUFloat9e5Format
=
{
signed
:
0
exponentBits
:
5
mantissaBits
:
9
bias
:
15
}
as
const
;
export
function
float32BitsToNumber
(
bits
:
number
)
:
number
{
workingDataU32
[
0
]
=
bits
;
return
workingDataF32
[
0
]
;
}
export
function
numberToFloat32Bits
(
number
:
number
)
:
number
{
workingDataF32
[
0
]
=
number
;
return
workingDataU32
[
0
]
;
}
export
function
floatBitsToNumber
(
bits
:
number
fmt
:
FloatFormat
)
:
number
{
const
kNonSignBits
=
fmt
.
exponentBits
+
fmt
.
mantissaBits
;
const
kNonSignBitsMask
=
(
1
<
<
kNonSignBits
)
-
1
;
const
exponentAndMantissaBits
=
bits
&
kNonSignBitsMask
;
const
exponentMask
=
(
(
1
<
<
fmt
.
exponentBits
)
-
1
)
<
<
fmt
.
mantissaBits
;
const
infinityOrNaN
=
(
bits
&
exponentMask
)
=
=
=
exponentMask
;
if
(
infinityOrNaN
)
{
const
mantissaMask
=
(
1
<
<
fmt
.
mantissaBits
)
-
1
;
const
signBit
=
2
*
*
kNonSignBits
;
const
isNegative
=
(
bits
&
signBit
)
!
=
=
0
;
return
bits
&
mantissaMask
?
Number
.
NaN
:
isNegative
?
Number
.
NEGATIVE_INFINITY
:
Number
.
POSITIVE_INFINITY
;
}
let
f32BitsWithWrongBias
=
exponentAndMantissaBits
<
<
(
kFloat32Format
.
mantissaBits
-
fmt
.
mantissaBits
)
;
f32BitsWithWrongBias
|
=
(
bits
<
<
(
31
-
kNonSignBits
)
)
&
0x8000_0000
;
const
numberWithWrongBias
=
float32BitsToNumber
(
f32BitsWithWrongBias
)
;
return
numberWithWrongBias
*
2
*
*
(
kFloat32Format
.
bias
-
fmt
.
bias
)
;
}
export
function
ufloatM9E5BitsToNumber
(
bits
:
number
fmt
:
FloatFormat
)
:
number
{
const
exponent
=
bits
>
>
fmt
.
mantissaBits
;
const
mantissaMask
=
(
1
<
<
fmt
.
mantissaBits
)
-
1
;
const
mantissa
=
bits
&
mantissaMask
;
return
mantissa
*
2
*
*
(
exponent
-
fmt
.
bias
-
fmt
.
mantissaBits
)
;
}
export
function
numberToFloatBits
(
number
:
number
fmt
:
FloatFormat
)
:
number
{
return
float32ToFloatBits
(
number
fmt
.
signed
fmt
.
exponentBits
fmt
.
mantissaBits
fmt
.
bias
)
;
}
export
function
floatBitsToNormalULPFromZero
(
bits
:
number
fmt
:
FloatFormat
)
:
number
{
const
mask_sign
=
fmt
.
signed
<
<
(
fmt
.
exponentBits
+
fmt
.
mantissaBits
)
;
const
mask_expt
=
(
(
1
<
<
fmt
.
exponentBits
)
-
1
)
<
<
fmt
.
mantissaBits
;
const
mask_mant
=
(
1
<
<
fmt
.
mantissaBits
)
-
1
;
const
mask_rest
=
mask_expt
|
mask_mant
;
assert
(
fmt
.
exponentBits
+
fmt
.
mantissaBits
<
=
31
)
;
const
sign
=
bits
&
mask_sign
?
-
1
:
1
;
const
rest
=
bits
&
mask_rest
;
const
subnormal_or_zero
=
(
bits
&
mask_expt
)
=
=
=
0
;
const
infinity_or_nan
=
(
bits
&
mask_expt
)
=
=
=
mask_expt
;
assert
(
!
infinity_or_nan
'
no
ulp
representation
for
infinity
/
nan
'
)
;
const
abs_ulp_from_zero
=
subnormal_or_zero
?
0
:
rest
-
mask_mant
;
return
sign
*
abs_ulp_from_zero
;
}
export
function
packRGB9E5UFloat
(
r
:
number
g
:
number
b
:
number
)
:
number
{
const
N
=
9
;
const
Emax
=
31
;
const
B
=
15
;
const
sharedexp_max
=
(
(
(
1
<
<
N
)
-
1
)
/
(
1
<
<
N
)
)
*
2
*
*
(
Emax
-
B
)
;
const
red_c
=
clamp
(
r
{
min
:
0
max
:
sharedexp_max
}
)
;
const
green_c
=
clamp
(
g
{
min
:
0
max
:
sharedexp_max
}
)
;
const
blue_c
=
clamp
(
b
{
min
:
0
max
:
sharedexp_max
}
)
;
const
max_c
=
Math
.
max
(
red_c
green_c
blue_c
)
;
const
exp_shared_p
=
Math
.
max
(
-
B
-
1
Math
.
floor
(
Math
.
log2
(
max_c
)
)
)
+
1
+
B
;
const
max_s
=
Math
.
floor
(
max_c
/
2
*
*
(
exp_shared_p
-
B
-
N
)
+
0
.
5
)
;
const
exp_shared
=
max_s
=
=
=
1
<
<
N
?
exp_shared_p
+
1
:
exp_shared_p
;
const
scalar
=
1
/
2
*
*
(
exp_shared
-
B
-
N
)
;
const
red_s
=
Math
.
floor
(
red_c
*
scalar
+
0
.
5
)
;
const
green_s
=
Math
.
floor
(
green_c
*
scalar
+
0
.
5
)
;
const
blue_s
=
Math
.
floor
(
blue_c
*
scalar
+
0
.
5
)
;
assert
(
red_s
>
=
0
&
&
red_s
<
=
0b111111111
)
;
assert
(
green_s
>
=
0
&
&
green_s
<
=
0b111111111
)
;
assert
(
blue_s
>
=
0
&
&
blue_s
<
=
0b111111111
)
;
assert
(
exp_shared
>
=
0
&
&
exp_shared
<
=
0b11111
)
;
return
(
(
exp_shared
<
<
27
)
|
(
blue_s
<
<
18
)
|
(
green_s
<
<
9
)
|
red_s
)
>
>
>
0
;
}
export
function
unpackRGB9E5UFloat
(
encoded
:
number
)
:
{
R
:
number
;
G
:
number
;
B
:
number
}
{
const
N
=
9
;
const
B
=
15
;
const
red_s
=
(
encoded
>
>
>
0
)
&
0b111111111
;
const
green_s
=
(
encoded
>
>
>
9
)
&
0b111111111
;
const
blue_s
=
(
encoded
>
>
>
18
)
&
0b111111111
;
const
exp_shared
=
(
encoded
>
>
>
27
)
&
0b11111
;
const
exp
=
Math
.
pow
(
2
exp_shared
-
B
-
N
)
;
return
{
R
:
exp
*
red_s
G
:
exp
*
green_s
B
:
exp
*
blue_s
}
;
}
export
function
pack2x16float
(
x
:
number
y
:
number
)
:
(
number
|
undefined
)
[
]
{
const
generateU16s
=
(
n
:
number
)
:
readonly
number
[
]
=
>
{
let
contains_subnormals
=
isSubnormalNumberF32
(
n
)
;
const
n_f16s
=
correctlyRoundedF16
(
n
)
;
contains_subnormals
|
|
=
n_f16s
.
some
(
isSubnormalNumberF16
)
;
const
n_u16s
=
n_f16s
.
map
(
f16
=
>
{
workingDataF16
[
0
]
=
f16
;
return
workingDataU16
[
0
]
;
}
)
;
const
contains_poszero
=
n_u16s
.
some
(
u
=
>
u
=
=
=
kBit
.
f16
.
positive
.
zero
)
;
const
contains_negzero
=
n_u16s
.
some
(
u
=
>
u
=
=
=
kBit
.
f16
.
negative
.
zero
)
;
if
(
!
contains_negzero
&
&
(
contains_poszero
|
|
contains_subnormals
)
)
{
n_u16s
.
push
(
kBit
.
f16
.
negative
.
zero
)
;
}
if
(
!
contains_poszero
&
&
(
contains_negzero
|
|
contains_subnormals
)
)
{
n_u16s
.
push
(
kBit
.
f16
.
positive
.
zero
)
;
}
return
n_u16s
;
}
;
if
(
!
isFiniteF16
(
x
)
|
|
!
isFiniteF16
(
y
)
)
{
return
[
undefined
]
;
}
const
results
=
new
Array
<
number
>
(
)
;
for
(
const
p
of
cartesianProduct
(
generateU16s
(
x
)
generateU16s
(
y
)
)
)
{
assert
(
p
.
length
=
=
=
2
'
cartesianProduct
of
2
arrays
returned
an
entry
with
not
2
elements
'
)
;
workingDataU16
[
0
]
=
p
[
0
]
;
workingDataU16
[
1
]
=
p
[
1
]
;
results
.
push
(
workingDataU32
[
0
]
)
;
}
return
results
;
}
export
function
pack2x16snorm
(
x
:
number
y
:
number
)
:
number
{
const
generateI16
=
(
n
:
number
)
:
number
=
>
{
return
Math
.
floor
(
0
.
5
+
32767
*
Math
.
min
(
1
Math
.
max
(
-
1
n
)
)
)
;
}
;
workingDataI16
[
0
]
=
generateI16
(
x
)
;
workingDataI16
[
1
]
=
generateI16
(
y
)
;
return
workingDataU32
[
0
]
;
}
export
function
pack2x16unorm
(
x
:
number
y
:
number
)
:
number
{
const
generateU16
=
(
n
:
number
)
:
number
=
>
{
return
Math
.
floor
(
0
.
5
+
65535
*
Math
.
min
(
1
Math
.
max
(
0
n
)
)
)
;
}
;
workingDataU16
[
0
]
=
generateU16
(
x
)
;
workingDataU16
[
1
]
=
generateU16
(
y
)
;
return
workingDataU32
[
0
]
;
}
export
function
pack4x8snorm
(
.
.
.
vals
:
[
number
number
number
number
]
)
:
number
{
const
generateI8
=
(
n
:
number
)
:
number
=
>
{
return
Math
.
floor
(
0
.
5
+
127
*
Math
.
min
(
1
Math
.
max
(
-
1
n
)
)
)
;
}
;
for
(
const
idx
in
vals
)
{
workingDataI8
[
idx
]
=
generateI8
(
vals
[
idx
]
)
;
}
return
workingDataU32
[
0
]
;
}
export
function
pack4x8unorm
(
.
.
.
vals
:
[
number
number
number
number
]
)
:
number
{
const
generateU8
=
(
n
:
number
)
:
number
=
>
{
return
Math
.
floor
(
0
.
5
+
255
*
Math
.
min
(
1
Math
.
max
(
0
n
)
)
)
;
}
;
for
(
const
idx
in
vals
)
{
workingDataU8
[
idx
]
=
generateU8
(
vals
[
idx
]
)
;
}
return
workingDataU32
[
0
]
;
}
export
function
assertInIntegerRange
(
n
:
number
bits
:
number
signed
:
boolean
)
:
void
{
if
(
signed
)
{
const
min
=
-
Math
.
pow
(
2
bits
-
1
)
;
const
max
=
Math
.
pow
(
2
bits
-
1
)
-
1
;
assert
(
n
>
=
min
&
&
n
<
=
max
)
;
}
else
{
const
max
=
Math
.
pow
(
2
bits
)
-
1
;
assert
(
n
>
=
0
&
&
n
<
=
max
)
;
}
}
export
function
gammaCompress
(
n
:
number
)
:
number
{
n
=
n
<
=
0
.
0031308
?
(
323
*
n
)
/
25
:
(
211
*
Math
.
pow
(
n
5
/
12
)
-
11
)
/
200
;
return
clamp
(
n
{
min
:
0
max
:
1
}
)
;
}
export
function
gammaDecompress
(
n
:
number
)
:
number
{
n
=
n
<
=
0
.
04045
?
(
n
*
25
)
/
323
:
Math
.
pow
(
(
200
*
n
+
11
)
/
211
12
/
5
)
;
return
clamp
(
n
{
min
:
0
max
:
1
}
)
;
}
export
function
float32ToUint32
(
f32
:
number
)
:
number
{
workingDataF32
[
0
]
=
f32
;
return
workingDataU32
[
0
]
;
}
export
function
uint32ToFloat32
(
u32
:
number
)
:
number
{
workingDataU32
[
0
]
=
u32
;
return
workingDataF32
[
0
]
;
}
export
function
float32ToInt32
(
f32
:
number
)
:
number
{
workingDataF32
[
0
]
=
f32
;
return
workingDataI32
[
0
]
;
}
export
function
uint32ToInt32
(
u32
:
number
)
:
number
{
workingDataU32
[
0
]
=
u32
;
return
workingDataI32
[
0
]
;
}
export
function
float16ToUint16
(
f16
:
number
)
:
number
{
workingDataF16
[
0
]
=
f16
;
return
workingDataU16
[
0
]
;
}
export
function
uint16ToFloat16
(
u16
:
number
)
:
number
{
workingDataU16
[
0
]
=
u16
;
return
workingDataF16
[
0
]
;
}
export
function
float16ToInt16
(
f16
:
number
)
:
number
{
workingDataF16
[
0
]
=
f16
;
return
workingDataI16
[
0
]
;
}
export
type
ScalarKind
=
|
'
abstract
-
float
'
|
'
f64
'
|
'
f32
'
|
'
f16
'
|
'
u32
'
|
'
u16
'
|
'
u8
'
|
'
abstract
-
int
'
|
'
i32
'
|
'
i16
'
|
'
i8
'
|
'
bool
'
;
export
class
ScalarType
{
readonly
kind
:
ScalarKind
;
readonly
_size
:
number
;
readonly
_signed
:
boolean
;
readonly
read
:
(
buf
:
Uint8Array
offset
:
number
)
=
>
ScalarValue
;
constructor
(
kind
:
ScalarKind
size
:
number
signed
:
boolean
read
:
(
buf
:
Uint8Array
offset
:
number
)
=
>
ScalarValue
)
{
this
.
kind
=
kind
;
this
.
_size
=
size
;
this
.
_signed
=
signed
;
this
.
read
=
read
;
}
public
toString
(
)
:
string
{
return
this
.
kind
;
}
public
get
size
(
)
:
number
{
return
this
.
_size
;
}
public
get
alignment
(
)
:
number
{
return
this
.
_size
;
}
public
get
signed
(
)
:
boolean
{
return
this
.
_signed
;
}
public
get
width
(
)
:
number
{
return
1
;
}
public
requiresF16
(
)
:
boolean
{
return
this
.
kind
=
=
=
'
f16
'
;
}
public
create
(
value
:
number
|
bigint
)
:
ScalarValue
{
switch
(
typeof
value
)
{
case
'
number
'
:
switch
(
this
.
kind
)
{
case
'
abstract
-
float
'
:
return
abstractFloat
(
value
)
;
case
'
abstract
-
int
'
:
return
abstractInt
(
BigInt
(
value
)
)
;
case
'
f64
'
:
return
f64
(
value
)
;
case
'
f32
'
:
return
f32
(
value
)
;
case
'
f16
'
:
return
f16
(
value
)
;
case
'
u32
'
:
return
u32
(
value
)
;
case
'
u16
'
:
return
u16
(
value
)
;
case
'
u8
'
:
return
u8
(
value
)
;
case
'
i32
'
:
return
i32
(
value
)
;
case
'
i16
'
:
return
i16
(
value
)
;
case
'
i8
'
:
return
i8
(
value
)
;
case
'
bool
'
:
return
bool
(
value
!
=
=
0
)
;
}
break
;
case
'
bigint
'
:
switch
(
this
.
kind
)
{
case
'
abstract
-
int
'
:
return
abstractInt
(
value
)
;
case
'
bool
'
:
return
bool
(
value
!
=
=
0n
)
;
}
break
;
}
unreachable
(
Scalar
<
{
this
.
kind
}
>
.
create
(
)
does
not
support
{
typeof
value
}
)
;
}
}
export
class
VectorType
{
readonly
width
:
number
;
readonly
elementType
:
ScalarType
;
private
static
instances
=
new
Map
<
string
VectorType
>
(
)
;
static
create
(
width
:
number
elementType
:
ScalarType
)
:
VectorType
{
const
key
=
{
elementType
.
toString
(
)
}
{
width
}
}
;
let
ty
=
this
.
instances
.
get
(
key
)
;
if
(
ty
!
=
=
undefined
)
{
return
ty
;
}
ty
=
new
VectorType
(
width
elementType
)
;
this
.
instances
.
set
(
key
ty
)
;
return
ty
;
}
constructor
(
width
:
number
elementType
:
ScalarType
)
{
this
.
width
=
width
;
this
.
elementType
=
elementType
;
}
public
read
(
buf
:
Uint8Array
offset
:
number
)
:
VectorValue
{
const
elements
:
Array
<
ScalarValue
>
=
[
]
;
for
(
let
i
=
0
;
i
<
this
.
width
;
i
+
+
)
{
elements
[
i
]
=
this
.
elementType
.
read
(
buf
offset
)
;
offset
+
=
this
.
elementType
.
size
;
}
return
new
VectorValue
(
elements
)
;
}
public
toString
(
)
:
string
{
return
vec
{
this
.
width
}
<
{
this
.
elementType
}
>
;
}
public
get
size
(
)
:
number
{
return
this
.
elementType
.
size
*
this
.
width
;
}
public
get
alignment
(
)
:
number
{
return
VectorType
.
alignmentOf
(
this
.
width
this
.
elementType
)
;
}
public
static
alignmentOf
(
width
:
number
elementType
:
ScalarType
)
{
return
elementType
.
size
*
(
width
=
=
=
3
?
4
:
width
)
;
}
public
create
(
value
:
(
number
|
bigint
)
|
readonly
(
number
|
bigint
)
[
]
)
:
VectorValue
{
if
(
value
instanceof
Array
)
{
assert
(
value
.
length
=
=
=
this
.
width
)
;
}
else
{
value
=
Array
(
this
.
width
)
.
fill
(
value
)
;
}
return
new
VectorValue
(
value
.
map
(
v
=
>
this
.
elementType
.
create
(
v
)
)
)
;
}
public
requiresF16
(
)
:
boolean
{
return
this
.
elementType
.
requiresF16
(
)
;
}
}
export
class
MatrixType
{
readonly
cols
:
number
;
readonly
rows
:
number
;
readonly
elementType
:
ScalarType
;
private
static
instances
=
new
Map
<
string
MatrixType
>
(
)
;
static
create
(
cols
:
number
rows
:
number
elementType
:
ScalarType
)
:
MatrixType
{
const
key
=
{
elementType
.
toString
(
)
}
{
cols
}
{
rows
}
;
let
ty
=
this
.
instances
.
get
(
key
)
;
if
(
ty
!
=
=
undefined
)
{
return
ty
;
}
ty
=
new
MatrixType
(
cols
rows
elementType
)
;
this
.
instances
.
set
(
key
ty
)
;
return
ty
;
}
constructor
(
cols
:
number
rows
:
number
elementType
:
ScalarType
)
{
this
.
cols
=
cols
;
this
.
rows
=
rows
;
assert
(
elementType
.
kind
=
=
=
'
f32
'
|
|
elementType
.
kind
=
=
=
'
f16
'
|
|
elementType
.
kind
=
=
=
'
abstract
-
float
'
"
MatrixType
can
only
have
elementType
of
'
f32
'
or
'
f16
'
or
'
abstract
-
float
'
"
)
;
this
.
elementType
=
elementType
;
}
public
read
(
buf
:
Uint8Array
offset
:
number
)
:
MatrixValue
{
const
elements
:
ScalarValue
[
]
[
]
=
[
.
.
.
Array
(
this
.
cols
)
]
.
map
(
_
=
>
[
.
.
.
Array
(
this
.
rows
)
]
)
;
for
(
let
c
=
0
;
c
<
this
.
cols
;
c
+
+
)
{
for
(
let
r
=
0
;
r
<
this
.
rows
;
r
+
+
)
{
elements
[
c
]
[
r
]
=
this
.
elementType
.
read
(
buf
offset
)
;
offset
+
=
this
.
elementType
.
size
;
}
if
(
this
.
rows
=
=
=
3
)
{
offset
+
=
this
.
elementType
.
size
;
}
}
return
new
MatrixValue
(
elements
)
;
}
public
toString
(
)
:
string
{
return
mat
{
this
.
cols
}
x
{
this
.
rows
}
<
{
this
.
elementType
}
>
;
}
public
get
size
(
)
:
number
{
return
VectorType
.
alignmentOf
(
this
.
rows
this
.
elementType
)
*
this
.
cols
;
}
public
get
alignment
(
)
:
number
{
return
VectorType
.
alignmentOf
(
this
.
rows
this
.
elementType
)
;
}
public
requiresF16
(
)
:
boolean
{
return
this
.
elementType
.
requiresF16
(
)
;
}
public
create
(
value
:
(
number
|
bigint
)
|
readonly
(
number
|
bigint
)
[
]
)
:
MatrixValue
{
if
(
value
instanceof
Array
)
{
assert
(
value
.
length
=
=
=
this
.
cols
*
this
.
rows
)
;
}
else
{
value
=
Array
(
this
.
cols
*
this
.
rows
)
.
fill
(
value
)
;
}
const
columns
:
(
number
|
bigint
)
[
]
[
]
=
[
]
;
for
(
let
i
=
0
;
i
<
this
.
cols
;
i
+
+
)
{
const
start
=
i
*
this
.
rows
;
columns
.
push
(
value
.
slice
(
start
start
+
this
.
rows
)
)
;
}
return
new
MatrixValue
(
columns
.
map
(
c
=
>
c
.
map
(
v
=
>
this
.
elementType
.
create
(
v
)
)
)
)
;
}
}
export
class
ArrayType
{
readonly
count
:
number
;
readonly
elementType
:
Type
;
private
static
instances
=
new
Map
<
string
ArrayType
>
(
)
;
static
create
(
count
:
number
elementType
:
Type
)
:
ArrayType
{
const
key
=
{
elementType
.
toString
(
)
}
{
count
}
;
let
ty
=
this
.
instances
.
get
(
key
)
;
if
(
ty
!
=
=
undefined
)
{
return
ty
;
}
ty
=
new
ArrayType
(
count
elementType
)
;
this
.
instances
.
set
(
key
ty
)
;
return
ty
;
}
constructor
(
count
:
number
elementType
:
Type
)
{
this
.
count
=
count
;
this
.
elementType
=
elementType
;
}
public
read
(
buf
:
Uint8Array
offset
:
number
)
:
ArrayValue
{
const
elements
:
Array
<
Value
>
=
[
]
;
for
(
let
i
=
0
;
i
<
this
.
count
;
i
+
+
)
{
elements
[
i
]
=
this
.
elementType
.
read
(
buf
offset
)
;
offset
+
=
this
.
stride
;
}
return
new
ArrayValue
(
elements
)
;
}
public
toString
(
)
:
string
{
return
this
.
count
!
=
=
0
?
array
<
{
this
.
elementType
}
{
this
.
count
}
>
:
array
<
{
this
.
elementType
}
>
;
}
public
get
stride
(
)
:
number
{
return
align
(
this
.
elementType
.
size
this
.
elementType
.
alignment
)
;
}
public
get
size
(
)
:
number
{
return
this
.
stride
*
this
.
count
;
}
public
get
alignment
(
)
:
number
{
return
this
.
elementType
.
alignment
;
}
public
requiresF16
(
)
:
boolean
{
return
this
.
elementType
.
requiresF16
(
)
;
}
public
create
(
value
:
(
number
|
bigint
)
|
readonly
(
number
|
bigint
)
[
]
)
:
ArrayValue
{
if
(
value
instanceof
Array
)
{
assert
(
value
.
length
=
=
=
this
.
count
)
;
}
else
{
value
=
Array
(
this
.
count
)
.
fill
(
value
)
;
}
return
new
ArrayValue
(
value
.
map
(
v
=
>
this
.
elementType
.
create
(
v
)
)
)
;
}
}
type
ArrayElementType
<
A
>
=
A
extends
{
[
index
:
number
]
:
infer
T
}
?
T
:
never
;
function
valueFromBytes
<
A
extends
TypedArrayBufferView
>
(
workingDataOut
:
A
buf
:
Uint8Array
offset
:
number
)
:
ArrayElementType
<
A
>
{
for
(
let
i
=
0
;
i
<
workingDataOut
.
BYTES_PER_ELEMENT
;
+
+
i
)
{
workingDataU8
[
i
]
=
buf
[
offset
+
i
]
;
}
return
workingDataOut
[
0
]
as
ArrayElementType
<
A
>
;
}
const
abstractIntType
=
new
ScalarType
(
'
abstract
-
int
'
8
true
(
buf
:
Uint8Array
offset
:
number
)
=
>
abstractInt
(
valueFromBytes
(
workingDataI64
buf
offset
)
)
)
;
const
i32Type
=
new
ScalarType
(
'
i32
'
4
true
(
buf
:
Uint8Array
offset
:
number
)
=
>
i32
(
valueFromBytes
(
workingDataI32
buf
offset
)
)
)
;
const
u32Type
=
new
ScalarType
(
'
u32
'
4
false
(
buf
:
Uint8Array
offset
:
number
)
=
>
u32
(
valueFromBytes
(
workingDataU32
buf
offset
)
)
)
;
const
i16Type
=
new
ScalarType
(
'
i16
'
2
true
(
buf
:
Uint8Array
offset
:
number
)
=
>
i16
(
valueFromBytes
(
workingDataI16
buf
offset
)
)
)
;
const
u16Type
=
new
ScalarType
(
'
u16
'
2
false
(
buf
:
Uint8Array
offset
:
number
)
=
>
u16
(
valueFromBytes
(
workingDataU16
buf
offset
)
)
)
;
const
i8Type
=
new
ScalarType
(
'
i8
'
1
true
(
buf
:
Uint8Array
offset
:
number
)
=
>
i8
(
valueFromBytes
(
workingDataI8
buf
offset
)
)
)
;
const
u8Type
=
new
ScalarType
(
'
u8
'
1
false
(
buf
:
Uint8Array
offset
:
number
)
=
>
u8
(
valueFromBytes
(
workingDataU8
buf
offset
)
)
)
;
const
abstractFloatType
=
new
ScalarType
(
'
abstract
-
float
'
8
true
(
buf
:
Uint8Array
offset
:
number
)
=
>
abstractFloat
(
valueFromBytes
(
workingDataF64
buf
offset
)
)
)
;
const
f64Type
=
new
ScalarType
(
'
f64
'
8
true
(
buf
:
Uint8Array
offset
:
number
)
=
>
f64
(
valueFromBytes
(
workingDataF64
buf
offset
)
)
)
;
const
f32Type
=
new
ScalarType
(
'
f32
'
4
true
(
buf
:
Uint8Array
offset
:
number
)
=
>
f32
(
valueFromBytes
(
workingDataF32
buf
offset
)
)
)
;
const
f16Type
=
new
ScalarType
(
'
f16
'
2
true
(
buf
:
Uint8Array
offset
:
number
)
=
>
f16Bits
(
valueFromBytes
(
workingDataU16
buf
offset
)
)
)
;
const
boolType
=
new
ScalarType
(
'
bool
'
4
false
(
buf
:
Uint8Array
offset
:
number
)
=
>
bool
(
valueFromBytes
(
workingDataU32
buf
offset
)
!
=
=
0
)
)
;
export
type
Type
=
ScalarType
|
VectorType
|
MatrixType
|
ArrayType
;
const
kVecTypes
=
{
vec2ai
:
VectorType
.
create
(
2
abstractIntType
)
vec2i
:
VectorType
.
create
(
2
i32Type
)
vec2u
:
VectorType
.
create
(
2
u32Type
)
vec2af
:
VectorType
.
create
(
2
abstractFloatType
)
vec2f
:
VectorType
.
create
(
2
f32Type
)
vec2h
:
VectorType
.
create
(
2
f16Type
)
vec2b
:
VectorType
.
create
(
2
boolType
)
vec3ai
:
VectorType
.
create
(
3
abstractIntType
)
vec3i
:
VectorType
.
create
(
3
i32Type
)
vec3u
:
VectorType
.
create
(
3
u32Type
)
vec3af
:
VectorType
.
create
(
3
abstractFloatType
)
vec3f
:
VectorType
.
create
(
3
f32Type
)
vec3h
:
VectorType
.
create
(
3
f16Type
)
vec3b
:
VectorType
.
create
(
3
boolType
)
vec4ai
:
VectorType
.
create
(
4
abstractIntType
)
vec4i
:
VectorType
.
create
(
4
i32Type
)
vec4u
:
VectorType
.
create
(
4
u32Type
)
vec4af
:
VectorType
.
create
(
4
abstractFloatType
)
vec4f
:
VectorType
.
create
(
4
f32Type
)
vec4h
:
VectorType
.
create
(
4
f16Type
)
vec4b
:
VectorType
.
create
(
4
boolType
)
}
as
const
;
const
kMatTypes
=
{
mat2x2f
:
MatrixType
.
create
(
2
2
f32Type
)
mat2x2h
:
MatrixType
.
create
(
2
2
f16Type
)
mat3x2f
:
MatrixType
.
create
(
3
2
f32Type
)
mat3x2h
:
MatrixType
.
create
(
3
2
f16Type
)
mat4x2f
:
MatrixType
.
create
(
4
2
f32Type
)
mat4x2h
:
MatrixType
.
create
(
4
2
f16Type
)
mat2x3f
:
MatrixType
.
create
(
2
3
f32Type
)
mat2x3h
:
MatrixType
.
create
(
2
3
f16Type
)
mat3x3f
:
MatrixType
.
create
(
3
3
f32Type
)
mat3x3h
:
MatrixType
.
create
(
3
3
f16Type
)
mat4x3f
:
MatrixType
.
create
(
4
3
f32Type
)
mat4x3h
:
MatrixType
.
create
(
4
3
f16Type
)
mat2x4f
:
MatrixType
.
create
(
2
4
f32Type
)
mat2x4h
:
MatrixType
.
create
(
2
4
f16Type
)
mat3x4f
:
MatrixType
.
create
(
3
4
f32Type
)
mat3x4h
:
MatrixType
.
create
(
3
4
f16Type
)
mat4x4f
:
MatrixType
.
create
(
4
4
f32Type
)
mat4x4h
:
MatrixType
.
create
(
4
4
f16Type
)
}
as
const
;
export
const
Type
=
{
abstractInt
:
abstractIntType
'
abstract
-
int
'
:
abstractIntType
i32
:
i32Type
u32
:
u32Type
i16
:
i16Type
u16
:
u16Type
i8
:
i8Type
u8
:
u8Type
abstractFloat
:
abstractFloatType
'
abstract
-
float
'
:
abstractFloatType
f64
:
f64Type
f32
:
f32Type
f16
:
f16Type
bool
:
boolType
vec
:
(
width
:
number
elementType
:
ScalarType
)
=
>
VectorType
.
create
(
width
elementType
)
.
.
.
kVecTypes
.
.
.
objectsToRecord
(
Object
.
values
(
kVecTypes
)
)
mat
:
(
cols
:
number
rows
:
number
elementType
:
ScalarType
)
=
>
MatrixType
.
create
(
cols
rows
elementType
)
.
.
.
kMatTypes
.
.
.
objectsToRecord
(
Object
.
values
(
kVecTypes
)
)
array
:
(
count
:
number
elementType
:
Type
)
=
>
ArrayType
.
create
(
count
elementType
)
}
;
export
function
stringToType
(
s
:
string
)
:
Type
{
const
t
=
(
Type
as
unknown
as
{
[
key
:
string
]
:
Type
}
)
[
s
]
;
assert
(
!
!
t
)
;
return
t
;
}
export
function
scalarType
(
kind
:
ScalarKind
)
:
ScalarType
{
switch
(
kind
)
{
case
'
abstract
-
float
'
:
return
Type
.
abstractFloat
;
case
'
f64
'
:
return
Type
.
f64
;
case
'
f32
'
:
return
Type
.
f32
;
case
'
f16
'
:
return
Type
.
f16
;
case
'
u32
'
:
return
Type
.
u32
;
case
'
u16
'
:
return
Type
.
u16
;
case
'
u8
'
:
return
Type
.
u8
;
case
'
abstract
-
int
'
:
return
Type
.
abstractInt
;
case
'
i32
'
:
return
Type
.
i32
;
case
'
i16
'
:
return
Type
.
i16
;
case
'
i8
'
:
return
Type
.
i8
;
case
'
bool
'
:
return
Type
.
bool
;
}
}
export
function
numElementsOf
(
ty
:
Type
)
:
number
{
if
(
ty
instanceof
ScalarType
)
{
return
1
;
}
if
(
ty
instanceof
VectorType
)
{
return
ty
.
width
;
}
if
(
ty
instanceof
MatrixType
)
{
return
ty
.
cols
*
ty
.
rows
;
}
if
(
ty
instanceof
ArrayType
)
{
return
ty
.
count
;
}
throw
new
Error
(
unhandled
type
{
ty
}
)
;
}
export
function
elementsOf
(
value
:
Value
)
:
Value
[
]
{
if
(
isScalarValue
(
value
)
)
{
return
[
value
]
;
}
if
(
value
instanceof
VectorValue
)
{
return
value
.
elements
;
}
if
(
value
instanceof
MatrixValue
)
{
return
value
.
elements
.
flat
(
)
;
}
if
(
value
instanceof
ArrayValue
)
{
return
value
.
elements
;
}
throw
new
Error
(
unhandled
value
{
value
}
)
;
}
export
function
scalarElementsOf
(
value
:
Value
)
:
ScalarValue
[
]
{
if
(
isScalarValue
(
value
)
)
{
return
[
value
]
;
}
if
(
value
instanceof
VectorValue
)
{
return
value
.
elements
;
}
if
(
value
instanceof
MatrixValue
)
{
return
value
.
elements
.
flat
(
)
;
}
if
(
value
instanceof
ArrayValue
)
{
return
value
.
elements
.
map
(
els
=
>
scalarElementsOf
(
els
)
)
.
flat
(
)
;
}
throw
new
Error
(
unhandled
value
{
value
}
)
;
}
export
function
elementTypeOf
(
t
:
Type
)
{
if
(
t
instanceof
ScalarType
)
{
return
t
;
}
return
t
.
elementType
;
}
export
function
scalarTypeOf
(
ty
:
Type
)
:
ScalarType
{
if
(
ty
instanceof
ScalarType
)
{
return
ty
;
}
if
(
ty
instanceof
VectorType
)
{
return
ty
.
elementType
;
}
if
(
ty
instanceof
MatrixType
)
{
return
ty
.
elementType
;
}
if
(
ty
instanceof
ArrayType
)
{
return
scalarTypeOf
(
ty
.
elementType
)
;
}
throw
new
Error
(
unhandled
type
{
ty
}
)
;
}
export
function
concreteTypeOf
(
ty
:
Type
allowedScalarTypes
?
:
Type
[
]
)
:
Type
{
if
(
allowedScalarTypes
&
&
allowedScalarTypes
.
length
>
0
)
{
switch
(
ty
)
{
case
Type
.
abstractInt
:
if
(
allowedScalarTypes
.
includes
(
Type
.
i32
)
)
{
return
Type
.
i32
;
}
if
(
allowedScalarTypes
.
includes
(
Type
.
u32
)
)
{
return
Type
.
u32
;
}
case
Type
.
abstractFloat
:
if
(
allowedScalarTypes
.
includes
(
Type
.
f32
)
)
{
return
Type
.
f32
;
}
if
(
allowedScalarTypes
.
includes
(
Type
.
f16
)
)
{
return
Type
.
f16
;
}
throw
new
Error
(
no
{
ty
}
)
;
}
}
else
{
switch
(
ty
)
{
case
Type
.
abstractInt
:
return
Type
.
i32
;
case
Type
.
abstractFloat
:
return
Type
.
f32
;
}
}
if
(
ty
instanceof
ScalarType
)
{
return
ty
;
}
if
(
ty
instanceof
VectorType
)
{
return
Type
.
vec
(
ty
.
width
concreteTypeOf
(
ty
.
elementType
allowedScalarTypes
)
as
ScalarType
)
;
}
if
(
ty
instanceof
MatrixType
)
{
return
Type
.
mat
(
ty
.
cols
ty
.
rows
concreteTypeOf
(
ty
.
elementType
allowedScalarTypes
)
as
ScalarType
)
;
}
if
(
ty
instanceof
ArrayType
)
{
return
Type
.
array
(
ty
.
count
concreteTypeOf
(
ty
.
elementType
allowedScalarTypes
)
)
;
}
throw
new
Error
(
unhandled
type
{
ty
}
)
;
}
function
hex
(
sizeInBytes
:
number
bitsLow
:
number
bitsHigh
?
:
number
)
{
let
hex
=
'
'
;
workingDataU32
[
0
]
=
bitsLow
;
if
(
bitsHigh
!
=
=
undefined
)
{
workingDataU32
[
1
]
=
bitsHigh
;
}
for
(
let
i
=
0
;
i
<
sizeInBytes
;
+
+
i
)
{
hex
=
workingDataU8
[
i
]
.
toString
(
16
)
.
padStart
(
2
'
0
'
)
+
hex
;
}
return
0x
{
hex
}
;
}
function
withPoint
(
x
:
number
)
{
const
str
=
{
x
}
;
return
str
.
indexOf
(
'
.
'
)
>
0
|
|
str
.
indexOf
(
'
e
'
)
>
0
?
str
:
{
str
}
.
0
;
}
export
class
AbstractIntValue
{
readonly
value
:
bigint
;
readonly
bitsLow
:
number
;
readonly
bitsHigh
:
number
;
readonly
type
=
Type
.
abstractInt
;
public
constructor
(
value
:
bigint
bitsLow
:
number
bitsHigh
:
number
)
{
this
.
value
=
value
;
this
.
bitsLow
=
bitsLow
;
this
.
bitsHigh
=
bitsHigh
;
}
public
copyTo
(
buffer
:
TypedArrayBufferView
offset
:
number
)
{
workingDataU32
[
0
]
=
this
.
bitsLow
;
workingDataU32
[
1
]
=
this
.
bitsHigh
;
for
(
let
i
=
0
;
i
<
8
;
i
+
+
)
{
buffer
[
offset
+
i
]
=
workingDataU8
[
i
]
;
}
}
public
wgsl
(
)
:
string
{
if
(
this
.
value
=
=
=
-
9223372036854775808n
)
{
return
(
-
9223372036854775807
-
1
)
;
}
return
{
this
.
value
}
;
}
public
toString
(
)
:
string
{
return
{
Colors
.
bold
(
this
.
value
.
toString
(
)
)
}
(
{
hex
(
8
this
.
bitsLow
this
.
bitsHigh
)
}
)
;
}
}
export
class
AbstractFloatValue
{
readonly
value
:
number
;
readonly
bitsLow
:
number
;
readonly
bitsHigh
:
number
;
readonly
type
=
Type
.
abstractFloat
;
public
constructor
(
value
:
number
bitsLow
:
number
bitsHigh
:
number
)
{
this
.
value
=
value
;
this
.
bitsLow
=
bitsLow
;
this
.
bitsHigh
=
bitsHigh
;
}
public
copyTo
(
buffer
:
TypedArrayBufferView
offset
:
number
)
{
workingDataU32
[
0
]
=
this
.
bitsLow
;
workingDataU32
[
1
]
=
this
.
bitsHigh
;
for
(
let
i
=
0
;
i
<
8
;
i
+
+
)
{
buffer
[
offset
+
i
]
=
workingDataU8
[
i
]
;
}
}
public
wgsl
(
)
:
string
{
return
{
withPoint
(
this
.
value
)
}
;
}
public
toString
(
)
:
string
{
switch
(
this
.
value
)
{
case
Infinity
:
case
-
Infinity
:
return
Colors
.
bold
(
this
.
value
.
toString
(
)
)
;
default
:
{
let
str
=
this
.
value
.
toString
(
)
;
str
=
str
.
indexOf
(
'
.
'
)
>
0
|
|
str
.
indexOf
(
'
e
'
)
>
0
?
str
:
{
str
}
.
0
;
return
isSubnormalNumberF64
(
this
.
value
.
valueOf
(
)
)
?
{
Colors
.
bold
(
str
)
}
(
{
hex
(
8
this
.
bitsLow
this
.
bitsHigh
)
}
subnormal
)
:
{
Colors
.
bold
(
str
)
}
(
{
hex
(
8
this
.
bitsLow
this
.
bitsHigh
)
}
)
;
}
}
}
}
export
class
I32Value
{
readonly
value
:
number
;
readonly
bits
:
number
;
readonly
type
=
Type
.
i32
;
public
constructor
(
value
:
number
bits
:
number
)
{
this
.
value
=
value
;
this
.
bits
=
bits
;
}
public
copyTo
(
buffer
:
TypedArrayBufferView
offset
:
number
)
{
workingDataU32
[
0
]
=
this
.
bits
;
for
(
let
i
=
0
;
i
<
4
;
i
+
+
)
{
buffer
[
offset
+
i
]
=
workingDataU8
[
i
]
;
}
}
public
wgsl
(
)
:
string
{
return
i32
(
{
this
.
value
}
)
;
}
public
toString
(
)
:
string
{
return
{
Colors
.
bold
(
this
.
value
.
toString
(
)
)
}
(
{
hex
(
4
this
.
bits
)
}
)
;
}
}
export
class
U32Value
{
readonly
value
:
number
;
readonly
type
=
Type
.
u32
;
public
constructor
(
value
:
number
)
{
this
.
value
=
value
;
}
public
copyTo
(
buffer
:
TypedArrayBufferView
offset
:
number
)
{
workingDataU32
[
0
]
=
this
.
value
;
for
(
let
i
=
0
;
i
<
4
;
i
+
+
)
{
buffer
[
offset
+
i
]
=
workingDataU8
[
i
]
;
}
}
public
wgsl
(
)
:
string
{
return
{
this
.
value
}
u
;
}
public
toString
(
)
:
string
{
return
{
Colors
.
bold
(
this
.
value
.
toString
(
)
)
}
(
{
hex
(
4
this
.
value
)
}
)
;
}
}
export
class
I16Value
{
readonly
value
:
number
;
readonly
bits
:
number
;
readonly
type
=
Type
.
i16
;
public
constructor
(
value
:
number
bits
:
number
)
{
this
.
value
=
value
;
this
.
bits
=
bits
;
}
public
copyTo
(
buffer
:
TypedArrayBufferView
offset
:
number
)
{
workingDataU16
[
0
]
=
this
.
bits
;
for
(
let
i
=
0
;
i
<
4
;
i
+
+
)
{
buffer
[
offset
+
i
]
=
workingDataU8
[
i
]
;
}
}
public
wgsl
(
)
:
string
{
return
i16
(
{
this
.
value
}
)
;
}
public
toString
(
)
:
string
{
return
{
Colors
.
bold
(
this
.
value
.
toString
(
)
)
}
(
{
hex
(
2
this
.
bits
)
}
)
;
}
}
export
class
U16Value
{
readonly
value
:
number
;
readonly
type
=
Type
.
u16
;
public
constructor
(
value
:
number
)
{
this
.
value
=
value
;
}
public
copyTo
(
buffer
:
TypedArrayBufferView
offset
:
number
)
{
workingDataU16
[
0
]
=
this
.
value
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
buffer
[
offset
+
i
]
=
workingDataU8
[
i
]
;
}
}
public
wgsl
(
)
:
string
{
assert
(
false
'
u16
is
not
a
WGSL
type
'
)
;
return
u16
(
{
this
.
value
}
)
;
}
public
toString
(
)
:
string
{
return
{
Colors
.
bold
(
this
.
value
.
toString
(
)
)
}
(
{
hex
(
2
this
.
value
)
}
)
;
}
}
export
class
I8Value
{
readonly
value
:
number
;
readonly
bits
:
number
;
readonly
type
=
Type
.
i8
;
public
constructor
(
value
:
number
bits
:
number
)
{
this
.
value
=
value
;
this
.
bits
=
bits
;
}
public
copyTo
(
buffer
:
TypedArrayBufferView
offset
:
number
)
{
workingDataU8
[
0
]
=
this
.
bits
;
for
(
let
i
=
0
;
i
<
4
;
i
+
+
)
{
buffer
[
offset
+
i
]
=
workingDataU8
[
i
]
;
}
}
public
wgsl
(
)
:
string
{
return
i8
(
{
this
.
value
}
)
;
}
public
toString
(
)
:
string
{
return
{
Colors
.
bold
(
this
.
value
.
toString
(
)
)
}
(
{
hex
(
2
this
.
bits
)
}
)
;
}
}
export
class
U8Value
{
readonly
value
:
number
;
readonly
type
=
Type
.
u8
;
public
constructor
(
value
:
number
)
{
this
.
value
=
value
;
}
public
copyTo
(
buffer
:
TypedArrayBufferView
offset
:
number
)
{
workingDataU8
[
0
]
=
this
.
value
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
buffer
[
offset
+
i
]
=
workingDataU8
[
i
]
;
}
}
public
wgsl
(
)
:
string
{
assert
(
false
'
u8
is
not
a
WGSL
type
'
)
;
return
u8
(
{
this
.
value
}
)
;
}
public
toString
(
)
:
string
{
return
{
Colors
.
bold
(
this
.
value
.
toString
(
)
)
}
(
{
hex
(
2
this
.
value
)
}
)
;
}
}
export
class
F64Value
{
readonly
value
:
number
;
readonly
bitsLow
:
number
;
readonly
bitsHigh
:
number
;
readonly
type
=
Type
.
f64
;
public
constructor
(
value
:
number
bitsLow
:
number
bitsHigh
:
number
)
{
this
.
value
=
value
;
this
.
bitsLow
=
bitsLow
;
this
.
bitsHigh
=
bitsHigh
;
}
public
copyTo
(
buffer
:
TypedArrayBufferView
offset
:
number
)
{
workingDataU32
[
0
]
=
this
.
bitsLow
;
workingDataU32
[
1
]
=
this
.
bitsHigh
;
for
(
let
i
=
0
;
i
<
8
;
i
+
+
)
{
buffer
[
offset
+
i
]
=
workingDataU8
[
i
]
;
}
}
public
wgsl
(
)
:
string
{
assert
(
false
'
f64
is
not
a
WGSL
type
'
)
;
return
{
withPoint
(
this
.
value
)
}
;
}
public
toString
(
)
:
string
{
switch
(
this
.
value
)
{
case
Infinity
:
case
-
Infinity
:
return
Colors
.
bold
(
this
.
value
.
toString
(
)
)
;
default
:
{
let
str
=
this
.
value
.
toString
(
)
;
str
=
str
.
indexOf
(
'
.
'
)
>
0
|
|
str
.
indexOf
(
'
e
'
)
>
0
?
str
:
{
str
}
.
0
;
return
isSubnormalNumberF64
(
this
.
value
.
valueOf
(
)
)
?
{
Colors
.
bold
(
str
)
}
(
{
hex
(
8
this
.
bitsLow
this
.
bitsHigh
)
}
subnormal
)
:
{
Colors
.
bold
(
str
)
}
(
{
hex
(
8
this
.
bitsLow
this
.
bitsHigh
)
}
)
;
}
}
}
}
export
class
F32Value
{
readonly
value
:
number
;
readonly
bits
:
number
;
readonly
type
=
Type
.
f32
;
public
constructor
(
value
:
number
bits
:
number
)
{
this
.
value
=
value
;
this
.
bits
=
bits
;
}
public
copyTo
(
buffer
:
TypedArrayBufferView
offset
:
number
)
{
workingDataU32
[
0
]
=
this
.
bits
;
for
(
let
i
=
0
;
i
<
4
;
i
+
+
)
{
buffer
[
offset
+
i
]
=
workingDataU8
[
i
]
;
}
}
public
wgsl
(
)
:
string
{
return
{
withPoint
(
this
.
value
)
}
f
;
}
public
toString
(
)
:
string
{
switch
(
this
.
value
)
{
case
Infinity
:
case
-
Infinity
:
return
Colors
.
bold
(
this
.
value
.
toString
(
)
)
;
default
:
{
let
str
=
this
.
value
.
toString
(
)
;
str
=
str
.
indexOf
(
'
.
'
)
>
0
|
|
str
.
indexOf
(
'
e
'
)
>
0
?
str
:
{
str
}
.
0
;
return
isSubnormalNumberF32
(
this
.
value
.
valueOf
(
)
)
?
{
Colors
.
bold
(
str
)
}
(
{
hex
(
4
this
.
bits
)
}
subnormal
)
:
{
Colors
.
bold
(
str
)
}
(
{
hex
(
4
this
.
bits
)
}
)
;
}
}
}
}
export
class
F16Value
{
readonly
value
:
number
;
readonly
bits
:
number
;
readonly
type
=
Type
.
f16
;
public
constructor
(
value
:
number
bits
:
number
)
{
this
.
value
=
value
;
this
.
bits
=
bits
;
}
public
copyTo
(
buffer
:
TypedArrayBufferView
offset
:
number
)
{
workingDataU16
[
0
]
=
this
.
bits
;
for
(
let
i
=
0
;
i
<
2
;
i
+
+
)
{
buffer
[
offset
+
i
]
=
workingDataU8
[
i
]
;
}
}
public
wgsl
(
)
:
string
{
return
{
withPoint
(
this
.
value
)
}
h
;
}
public
toString
(
)
:
string
{
switch
(
this
.
value
)
{
case
Infinity
:
case
-
Infinity
:
return
Colors
.
bold
(
this
.
value
.
toString
(
)
)
;
default
:
{
let
str
=
this
.
value
.
toString
(
)
;
str
=
str
.
indexOf
(
'
.
'
)
>
0
|
|
str
.
indexOf
(
'
e
'
)
>
0
?
str
:
{
str
}
.
0
;
return
isSubnormalNumberF16
(
this
.
value
.
valueOf
(
)
)
?
{
Colors
.
bold
(
str
)
}
(
{
hex
(
2
this
.
bits
)
}
subnormal
)
:
{
Colors
.
bold
(
str
)
}
(
{
hex
(
2
this
.
bits
)
}
)
;
}
}
}
}
export
class
BoolValue
{
readonly
value
:
boolean
;
readonly
type
=
Type
.
bool
;
public
constructor
(
value
:
boolean
)
{
this
.
value
=
value
;
}
public
copyTo
(
buffer
:
TypedArrayBufferView
offset
:
number
)
{
buffer
[
offset
]
=
this
.
value
?
1
:
0
;
}
public
wgsl
(
)
:
string
{
return
this
.
value
.
toString
(
)
;
}
public
toString
(
)
:
string
{
return
Colors
.
bold
(
this
.
value
.
toString
(
)
)
;
}
}
export
type
ScalarValue
=
|
AbstractIntValue
|
AbstractFloatValue
|
I32Value
|
U32Value
|
I16Value
|
U16Value
|
I8Value
|
U8Value
|
F64Value
|
F32Value
|
F16Value
|
BoolValue
;
export
interface
ScalarBuilder
<
T
>
{
(
value
:
T
)
:
ScalarValue
;
}
export
function
isScalarValue
(
value
:
object
)
:
value
is
ScalarValue
{
return
(
value
instanceof
AbstractIntValue
|
|
value
instanceof
AbstractFloatValue
|
|
value
instanceof
I32Value
|
|
value
instanceof
U32Value
|
|
value
instanceof
I16Value
|
|
value
instanceof
U16Value
|
|
value
instanceof
I8Value
|
|
value
instanceof
U8Value
|
|
value
instanceof
F64Value
|
|
value
instanceof
F32Value
|
|
value
instanceof
F16Value
|
|
value
instanceof
BoolValue
)
;
}
export
function
abstractInt
(
value
:
bigint
)
{
workingDataI64
[
0
]
=
value
;
return
new
AbstractIntValue
(
workingDataI64
[
0
]
workingDataU32
[
0
]
workingDataU32
[
1
]
)
;
}
export
function
abstractIntBits
(
value
:
bigint
)
{
workingDataU64
[
0
]
=
value
;
return
new
AbstractIntValue
(
workingDataI64
[
0
]
workingDataU32
[
0
]
workingDataU32
[
1
]
)
;
}
export
function
abstractFloat
(
value
:
number
)
{
workingDataF64
[
0
]
=
value
;
return
new
AbstractFloatValue
(
workingDataF64
[
0
]
workingDataU32
[
0
]
workingDataU32
[
1
]
)
;
}
export
function
i32
(
value
:
number
)
{
workingDataI32
[
0
]
=
value
;
return
new
I32Value
(
workingDataI32
[
0
]
workingDataU32
[
0
]
)
;
}
export
function
i32Bits
(
bits
:
number
)
{
workingDataU32
[
0
]
=
bits
;
return
new
I32Value
(
workingDataI32
[
0
]
workingDataU32
[
0
]
)
;
}
export
function
u32
(
value
:
number
)
{
workingDataU32
[
0
]
=
value
;
return
new
U32Value
(
workingDataU32
[
0
]
)
;
}
export
function
u32Bits
(
bits
:
number
)
{
workingDataU32
[
0
]
=
bits
;
return
new
U32Value
(
workingDataU32
[
0
]
)
;
}
export
function
i16
(
value
:
number
)
{
workingDataI16
[
0
]
=
value
;
return
new
I16Value
(
workingDataI16
[
0
]
workingDataU16
[
0
]
)
;
}
export
function
u16
(
value
:
number
)
{
workingDataU16
[
0
]
=
value
;
return
new
U16Value
(
workingDataU16
[
0
]
)
;
}
export
function
i8
(
value
:
number
)
{
workingDataI8
[
0
]
=
value
;
return
new
I8Value
(
workingDataI8
[
0
]
workingDataU8
[
0
]
)
;
}
export
function
u8
(
value
:
number
)
{
workingDataU8
[
0
]
=
value
;
return
new
U8Value
(
workingDataU8
[
0
]
)
;
}
export
function
f64
(
value
:
number
)
{
workingDataF64
[
0
]
=
value
;
return
new
F64Value
(
workingDataF64
[
0
]
workingDataU32
[
0
]
workingDataU32
[
1
]
)
;
}
export
function
f32
(
value
:
number
)
{
workingDataF32
[
0
]
=
value
;
return
new
F32Value
(
workingDataF32
[
0
]
workingDataU32
[
0
]
)
;
}
export
function
f32Bits
(
bits
:
number
)
{
workingDataU32
[
0
]
=
bits
;
return
new
F32Value
(
workingDataF32
[
0
]
workingDataU32
[
0
]
)
;
}
export
function
f16
(
value
:
number
)
{
workingDataF16
[
0
]
=
value
;
return
new
F16Value
(
workingDataF16
[
0
]
workingDataU16
[
0
]
)
;
}
export
function
f16Bits
(
bits
:
number
)
{
workingDataU16
[
0
]
=
bits
;
return
new
F16Value
(
workingDataF16
[
0
]
workingDataU16
[
0
]
)
;
}
export
function
bool
(
value
:
boolean
)
:
ScalarValue
{
return
new
BoolValue
(
value
)
;
}
export
const
True
=
bool
(
true
)
;
export
const
False
=
bool
(
false
)
;
export
class
VectorValue
{
readonly
elements
:
Array
<
ScalarValue
>
;
readonly
type
:
VectorType
;
public
constructor
(
elements
:
Array
<
ScalarValue
>
)
{
if
(
elements
.
length
<
2
|
|
elements
.
length
>
4
)
{
throw
new
Error
(
vector
element
count
must
be
between
2
and
4
got
{
elements
.
length
}
)
;
}
for
(
let
i
=
1
;
i
<
elements
.
length
;
i
+
+
)
{
const
a
=
elements
[
0
]
.
type
;
const
b
=
elements
[
i
]
.
type
;
if
(
a
!
=
=
b
)
{
throw
new
Error
(
cannot
mix
vector
element
types
.
Found
elements
with
types
'
{
a
}
'
and
'
{
b
}
'
)
;
}
}
this
.
elements
=
elements
;
this
.
type
=
VectorType
.
create
(
elements
.
length
elements
[
0
]
.
type
)
;
}
public
copyTo
(
buffer
:
Uint8Array
offset
:
number
)
{
for
(
const
element
of
this
.
elements
)
{
element
.
copyTo
(
buffer
offset
)
;
offset
+
=
this
.
type
.
elementType
.
size
;
}
}
public
wgsl
(
)
:
string
{
const
els
=
this
.
elements
.
map
(
v
=
>
v
.
wgsl
(
)
)
.
join
(
'
'
)
;
return
vec
{
this
.
type
.
width
}
(
{
els
}
)
;
}
public
toString
(
)
:
string
{
return
{
this
.
type
}
(
{
this
.
elements
.
map
(
e
=
>
e
.
toString
(
)
)
.
join
(
'
'
)
}
)
;
}
public
get
x
(
)
{
assert
(
0
<
this
.
elements
.
length
)
;
return
this
.
elements
[
0
]
;
}
public
get
y
(
)
{
assert
(
1
<
this
.
elements
.
length
)
;
return
this
.
elements
[
1
]
;
}
public
get
z
(
)
{
assert
(
2
<
this
.
elements
.
length
)
;
return
this
.
elements
[
2
]
;
}
public
get
w
(
)
{
assert
(
3
<
this
.
elements
.
length
)
;
return
this
.
elements
[
3
]
;
}
}
export
function
vec
(
.
.
.
elements
:
ScalarValue
[
]
)
{
return
new
VectorValue
(
elements
)
;
}
export
function
vec2
(
x
:
ScalarValue
y
:
ScalarValue
)
{
return
new
VectorValue
(
[
x
y
]
)
;
}
export
function
vec3
(
x
:
ScalarValue
y
:
ScalarValue
z
:
ScalarValue
)
{
return
new
VectorValue
(
[
x
y
z
]
)
;
}
export
function
vec4
(
x
:
ScalarValue
y
:
ScalarValue
z
:
ScalarValue
w
:
ScalarValue
)
{
return
new
VectorValue
(
[
x
y
z
w
]
)
;
}
export
function
toVector
(
v
:
readonly
number
[
]
op
:
(
n
:
number
)
=
>
ScalarValue
)
:
VectorValue
{
switch
(
v
.
length
)
{
case
2
:
return
vec2
(
op
(
v
[
0
]
)
op
(
v
[
1
]
)
)
;
case
3
:
return
vec3
(
op
(
v
[
0
]
)
op
(
v
[
1
]
)
op
(
v
[
2
]
)
)
;
case
4
:
return
vec4
(
op
(
v
[
0
]
)
op
(
v
[
1
]
)
op
(
v
[
2
]
)
op
(
v
[
3
]
)
)
;
}
unreachable
(
input
to
'
toVector
'
must
contain
2
3
or
4
elements
)
;
}
export
class
MatrixValue
{
readonly
elements
:
ScalarValue
[
]
[
]
;
readonly
type
:
MatrixType
;
public
constructor
(
elements
:
Array
<
Array
<
ScalarValue
>
>
)
{
const
num_cols
=
elements
.
length
;
if
(
num_cols
<
2
|
|
num_cols
>
4
)
{
throw
new
Error
(
matrix
cols
count
must
be
between
2
and
4
got
{
num_cols
}
)
;
}
const
num_rows
=
elements
[
0
]
.
length
;
if
(
!
elements
.
every
(
c
=
>
c
.
length
=
=
=
num_rows
)
)
{
throw
new
Error
(
cannot
mix
matrix
column
lengths
)
;
}
if
(
num_rows
<
2
|
|
num_rows
>
4
)
{
throw
new
Error
(
matrix
rows
count
must
be
between
2
and
4
got
{
num_rows
}
)
;
}
const
elem_type
=
elements
[
0
]
[
0
]
.
type
;
if
(
!
elements
.
every
(
c
=
>
c
.
every
(
r
=
>
objectEquals
(
r
.
type
elem_type
)
)
)
)
{
throw
new
Error
(
cannot
mix
matrix
element
types
)
;
}
this
.
elements
=
elements
;
this
.
type
=
MatrixType
.
create
(
num_cols
num_rows
elem_type
)
;
}
public
copyTo
(
buffer
:
Uint8Array
offset
:
number
)
{
for
(
let
i
=
0
;
i
<
this
.
type
.
cols
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
this
.
type
.
rows
;
j
+
+
)
{
this
.
elements
[
i
]
[
j
]
.
copyTo
(
buffer
offset
)
;
offset
+
=
this
.
type
.
elementType
.
size
;
}
if
(
this
.
type
.
rows
=
=
=
3
)
{
offset
+
=
this
.
type
.
elementType
.
size
;
}
}
}
public
wgsl
(
)
:
string
{
const
els
=
this
.
elements
.
flatMap
(
c
=
>
c
.
map
(
r
=
>
r
.
wgsl
(
)
)
)
.
join
(
'
'
)
;
return
mat
{
this
.
type
.
cols
}
x
{
this
.
type
.
rows
}
(
{
els
}
)
;
}
public
toString
(
)
:
string
{
return
{
this
.
type
}
(
{
this
.
elements
.
map
(
c
=
>
c
.
join
(
'
'
)
)
.
join
(
'
'
)
}
)
;
}
}
export
class
ArrayValue
{
readonly
elements
:
Value
[
]
;
readonly
type
:
ArrayType
;
public
constructor
(
elements
:
Array
<
Value
>
)
{
const
elem_type
=
elements
[
0
]
.
type
;
if
(
!
elements
.
every
(
c
=
>
elements
.
every
(
r
=
>
objectEquals
(
r
.
type
elem_type
)
)
)
)
{
throw
new
Error
(
cannot
mix
array
element
types
)
;
}
this
.
elements
=
elements
;
this
.
type
=
ArrayType
.
create
(
elements
.
length
elem_type
)
;
}
public
copyTo
(
buffer
:
Uint8Array
offset
:
number
)
{
for
(
const
element
of
this
.
elements
)
{
element
.
copyTo
(
buffer
offset
)
;
offset
+
=
this
.
type
.
elementType
.
size
;
}
}
public
wgsl
(
)
:
string
{
const
els
=
this
.
elements
.
map
(
r
=
>
r
.
wgsl
(
)
)
.
join
(
'
'
)
;
return
isAbstractType
(
this
.
type
.
elementType
)
?
array
(
{
els
}
)
:
{
this
.
type
}
(
{
els
}
)
;
}
public
toString
(
)
:
string
{
return
this
.
wgsl
(
)
;
}
}
export
function
array
(
.
.
.
elements
:
Value
[
]
)
{
return
new
ArrayValue
(
elements
)
;
}
export
function
toMatrix
(
m
:
ROArrayArray
<
number
>
op
:
(
n
:
number
)
=
>
ScalarValue
)
:
MatrixValue
{
const
cols
=
m
.
length
;
const
rows
=
m
[
0
]
.
length
;
const
elements
:
ScalarValue
[
]
[
]
=
[
.
.
.
Array
<
ScalarValue
[
]
>
(
cols
)
]
.
map
(
_
=
>
[
.
.
.
Array
<
ScalarValue
>
(
rows
)
]
)
;
for
(
let
i
=
0
;
i
<
cols
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
rows
;
j
+
+
)
{
elements
[
i
]
[
j
]
=
op
(
m
[
i
]
[
j
]
)
;
}
}
return
new
MatrixValue
(
elements
)
;
}
export
type
Value
=
ScalarValue
|
VectorValue
|
MatrixValue
|
ArrayValue
;
export
type
SerializedScalarValue
=
{
kind
:
'
scalar
'
;
type
:
ScalarKind
;
value
:
boolean
|
number
;
}
;
export
type
SerializedVectorValue
=
{
kind
:
'
vector
'
;
type
:
ScalarKind
;
value
:
boolean
[
]
|
readonly
number
[
]
;
}
;
export
type
SerializedMatrixValue
=
{
kind
:
'
matrix
'
;
type
:
ScalarKind
;
value
:
ROArrayArray
<
number
>
;
}
;
enum
SerializedScalarKind
{
AbstractFloat
F64
F32
F16
U32
U16
U8
I32
I16
I8
Bool
AbstractInt
}
function
serializeScalarKind
(
s
:
BinaryStream
v
:
ScalarKind
)
{
switch
(
v
)
{
case
'
abstract
-
float
'
:
s
.
writeU8
(
SerializedScalarKind
.
AbstractFloat
)
;
return
;
case
'
f64
'
:
s
.
writeU8
(
SerializedScalarKind
.
F64
)
;
return
;
case
'
f32
'
:
s
.
writeU8
(
SerializedScalarKind
.
F32
)
;
return
;
case
'
f16
'
:
s
.
writeU8
(
SerializedScalarKind
.
F16
)
;
return
;
case
'
u32
'
:
s
.
writeU8
(
SerializedScalarKind
.
U32
)
;
return
;
case
'
u16
'
:
s
.
writeU8
(
SerializedScalarKind
.
U16
)
;
return
;
case
'
u8
'
:
s
.
writeU8
(
SerializedScalarKind
.
U8
)
;
return
;
case
'
abstract
-
int
'
:
s
.
writeU8
(
SerializedScalarKind
.
AbstractInt
)
;
return
;
case
'
i32
'
:
s
.
writeU8
(
SerializedScalarKind
.
I32
)
;
return
;
case
'
i16
'
:
s
.
writeU8
(
SerializedScalarKind
.
I16
)
;
return
;
case
'
i8
'
:
s
.
writeU8
(
SerializedScalarKind
.
I8
)
;
return
;
case
'
bool
'
:
s
.
writeU8
(
SerializedScalarKind
.
Bool
)
;
return
;
}
unreachable
(
Do
not
know
what
to
write
scalar
kind
=
{
v
}
)
;
}
function
deserializeScalarKind
(
s
:
BinaryStream
)
:
ScalarKind
{
const
kind
=
s
.
readU8
(
)
;
switch
(
kind
)
{
case
SerializedScalarKind
.
AbstractFloat
:
return
'
abstract
-
float
'
;
case
SerializedScalarKind
.
F64
:
return
'
f64
'
;
case
SerializedScalarKind
.
F32
:
return
'
f32
'
;
case
SerializedScalarKind
.
F16
:
return
'
f16
'
;
case
SerializedScalarKind
.
U32
:
return
'
u32
'
;
case
SerializedScalarKind
.
U16
:
return
'
u16
'
;
case
SerializedScalarKind
.
U8
:
return
'
u8
'
;
case
SerializedScalarKind
.
AbstractInt
:
return
'
abstract
-
int
'
;
case
SerializedScalarKind
.
I32
:
return
'
i32
'
;
case
SerializedScalarKind
.
I16
:
return
'
i16
'
;
case
SerializedScalarKind
.
I8
:
return
'
i8
'
;
case
SerializedScalarKind
.
Bool
:
return
'
bool
'
;
default
:
unreachable
(
invalid
serialized
ScalarKind
:
{
kind
}
)
;
}
}
enum
SerializedValueKind
{
Scalar
Vector
Matrix
}
export
function
serializeValue
(
s
:
BinaryStream
v
:
Value
)
{
const
serializeScalar
=
(
scalar
:
ScalarValue
kind
:
ScalarKind
)
=
>
{
switch
(
typeof
scalar
.
value
)
{
case
'
number
'
:
switch
(
kind
)
{
case
'
abstract
-
float
'
:
s
.
writeF64
(
scalar
.
value
)
;
return
;
case
'
f64
'
:
s
.
writeF64
(
scalar
.
value
)
;
return
;
case
'
f32
'
:
s
.
writeF32
(
scalar
.
value
)
;
return
;
case
'
f16
'
:
s
.
writeF16
(
scalar
.
value
)
;
return
;
case
'
u32
'
:
s
.
writeU32
(
scalar
.
value
)
;
return
;
case
'
u16
'
:
s
.
writeU16
(
scalar
.
value
)
;
return
;
case
'
u8
'
:
s
.
writeU8
(
scalar
.
value
)
;
return
;
case
'
i32
'
:
s
.
writeI32
(
scalar
.
value
)
;
return
;
case
'
i16
'
:
s
.
writeI16
(
scalar
.
value
)
;
return
;
case
'
i8
'
:
s
.
writeI8
(
scalar
.
value
)
;
return
;
}
break
;
case
'
bigint
'
:
switch
(
kind
)
{
case
'
abstract
-
int
'
:
s
.
writeI64
(
scalar
.
value
)
;
return
;
}
break
;
case
'
boolean
'
:
switch
(
kind
)
{
case
'
bool
'
:
s
.
writeBool
(
scalar
.
value
)
;
return
;
}
break
;
}
}
;
if
(
isScalarValue
(
v
)
)
{
s
.
writeU8
(
SerializedValueKind
.
Scalar
)
;
serializeScalarKind
(
s
v
.
type
.
kind
)
;
serializeScalar
(
v
v
.
type
.
kind
)
;
return
;
}
if
(
v
instanceof
VectorValue
)
{
s
.
writeU8
(
SerializedValueKind
.
Vector
)
;
serializeScalarKind
(
s
v
.
type
.
elementType
.
kind
)
;
s
.
writeU8
(
v
.
type
.
width
)
;
for
(
const
element
of
v
.
elements
)
{
serializeScalar
(
element
v
.
type
.
elementType
.
kind
)
;
}
return
;
}
if
(
v
instanceof
MatrixValue
)
{
s
.
writeU8
(
SerializedValueKind
.
Matrix
)
;
serializeScalarKind
(
s
v
.
type
.
elementType
.
kind
)
;
s
.
writeU8
(
v
.
type
.
cols
)
;
s
.
writeU8
(
v
.
type
.
rows
)
;
for
(
const
column
of
v
.
elements
)
{
for
(
const
element
of
column
)
{
serializeScalar
(
element
v
.
type
.
elementType
.
kind
)
;
}
}
return
;
}
unreachable
(
unhandled
value
type
:
{
v
}
)
;
}
export
function
deserializeValue
(
s
:
BinaryStream
)
:
Value
{
const
deserializeScalar
=
(
kind
:
ScalarKind
)
=
>
{
switch
(
kind
)
{
case
'
abstract
-
float
'
:
return
abstractFloat
(
s
.
readF64
(
)
)
;
case
'
f64
'
:
return
f64
(
s
.
readF64
(
)
)
;
case
'
f32
'
:
return
f32
(
s
.
readF32
(
)
)
;
case
'
f16
'
:
return
f16
(
s
.
readF16
(
)
)
;
case
'
u32
'
:
return
u32
(
s
.
readU32
(
)
)
;
case
'
u16
'
:
return
u16
(
s
.
readU16
(
)
)
;
case
'
u8
'
:
return
u8
(
s
.
readU8
(
)
)
;
case
'
abstract
-
int
'
:
return
abstractInt
(
s
.
readI64
(
)
)
;
case
'
i32
'
:
return
i32
(
s
.
readI32
(
)
)
;
case
'
i16
'
:
return
i16
(
s
.
readI16
(
)
)
;
case
'
i8
'
:
return
i8
(
s
.
readI8
(
)
)
;
case
'
bool
'
:
return
bool
(
s
.
readBool
(
)
)
;
}
}
;
const
valueKind
=
s
.
readU8
(
)
;
const
scalarKind
=
deserializeScalarKind
(
s
)
;
switch
(
valueKind
)
{
case
SerializedValueKind
.
Scalar
:
return
deserializeScalar
(
scalarKind
)
;
case
SerializedValueKind
.
Vector
:
{
const
width
=
s
.
readU8
(
)
;
const
scalars
=
new
Array
<
ScalarValue
>
(
width
)
;
for
(
let
i
=
0
;
i
<
width
;
i
+
+
)
{
scalars
[
i
]
=
deserializeScalar
(
scalarKind
)
;
}
return
new
VectorValue
(
scalars
)
;
}
case
SerializedValueKind
.
Matrix
:
{
const
numCols
=
s
.
readU8
(
)
;
const
numRows
=
s
.
readU8
(
)
;
const
columns
=
new
Array
<
ScalarValue
[
]
>
(
numCols
)
;
for
(
let
c
=
0
;
c
<
numCols
;
c
+
+
)
{
columns
[
c
]
=
new
Array
<
ScalarValue
>
(
numRows
)
;
for
(
let
i
=
0
;
i
<
numRows
;
i
+
+
)
{
columns
[
c
]
[
i
]
=
deserializeScalar
(
scalarKind
)
;
}
}
return
new
MatrixValue
(
columns
)
;
}
default
:
unreachable
(
invalid
serialized
value
kind
:
{
valueKind
}
)
;
}
}
export
function
isFloatValue
(
v
:
Value
)
:
boolean
{
return
isFloatType
(
v
.
type
)
;
}
export
function
isAbstractType
(
ty
:
Type
)
:
boolean
{
if
(
ty
instanceof
ScalarType
)
{
return
ty
.
kind
=
=
=
'
abstract
-
float
'
|
|
ty
.
kind
=
=
=
'
abstract
-
int
'
;
}
return
false
;
}
export
function
isFloatType
(
ty
:
Type
)
:
boolean
{
if
(
ty
instanceof
ScalarType
)
{
return
(
ty
.
kind
=
=
=
'
abstract
-
float
'
|
|
ty
.
kind
=
=
=
'
f64
'
|
|
ty
.
kind
=
=
=
'
f32
'
|
|
ty
.
kind
=
=
=
'
f16
'
)
;
}
return
false
;
}
export
function
isIntegerType
(
ty
:
Type
)
:
boolean
{
if
(
ty
instanceof
ScalarType
)
{
return
(
ty
.
kind
=
=
=
'
abstract
-
int
'
|
|
ty
.
kind
=
=
=
'
i32
'
|
|
ty
.
kind
=
=
=
'
i16
'
|
|
ty
.
kind
=
=
=
'
i8
'
|
|
ty
.
kind
=
=
=
'
u32
'
|
|
ty
.
kind
=
=
=
'
u16
'
|
|
ty
.
kind
=
=
=
'
u8
'
)
;
}
return
false
;
}
export
function
isConvertibleToFloatType
(
ty
:
Type
)
:
boolean
{
if
(
ty
instanceof
ScalarType
)
{
return
(
ty
.
kind
=
=
=
'
abstract
-
int
'
|
|
ty
.
kind
=
=
=
'
abstract
-
float
'
|
|
ty
.
kind
=
=
=
'
f64
'
|
|
ty
.
kind
=
=
=
'
f32
'
|
|
ty
.
kind
=
=
=
'
f16
'
)
;
}
return
false
;
}
export
function
isUnsignedType
(
ty
:
Type
)
:
boolean
{
if
(
ty
instanceof
ScalarType
)
{
return
ty
.
kind
=
=
=
'
u8
'
|
|
ty
.
kind
=
=
=
'
u16
'
|
|
ty
.
kind
=
=
=
'
u32
'
;
}
else
{
return
isUnsignedType
(
ty
.
elementType
)
;
}
}
export
function
isConvertible
(
src
:
Type
dst
:
Type
)
{
if
(
src
=
=
=
dst
)
{
return
true
;
}
const
shapeOf
=
(
ty
:
Type
)
=
>
{
if
(
ty
instanceof
ScalarType
)
{
return
scalar
;
}
if
(
ty
instanceof
VectorType
)
{
return
vec
{
ty
.
width
}
;
}
if
(
ty
instanceof
MatrixType
)
{
return
mat
{
ty
.
cols
}
x
{
ty
.
rows
}
;
}
if
(
ty
instanceof
ArrayType
)
{
return
array
<
{
ty
.
count
}
>
;
}
unreachable
(
unhandled
type
:
{
ty
}
)
;
}
;
if
(
shapeOf
(
src
)
!
=
=
shapeOf
(
dst
)
)
{
return
false
;
}
const
elSrc
=
scalarTypeOf
(
src
)
;
const
elDst
=
scalarTypeOf
(
dst
)
;
switch
(
elSrc
.
kind
)
{
case
'
abstract
-
float
'
:
switch
(
elDst
.
kind
)
{
case
'
abstract
-
float
'
:
case
'
f16
'
:
case
'
f32
'
:
case
'
f64
'
:
return
true
;
default
:
return
false
;
}
case
'
abstract
-
int
'
:
switch
(
elDst
.
kind
)
{
case
'
abstract
-
int
'
:
case
'
abstract
-
float
'
:
case
'
f16
'
:
case
'
f32
'
:
case
'
f64
'
:
case
'
u16
'
:
case
'
u32
'
:
case
'
u8
'
:
case
'
i16
'
:
case
'
i32
'
:
case
'
i8
'
:
return
true
;
default
:
return
false
;
}
default
:
return
false
;
}
}
export
const
kFloatScalars
=
[
Type
.
abstractFloat
Type
.
f32
Type
.
f16
]
as
const
;
export
const
kConcreteFloatScalars
=
[
Type
.
f32
Type
.
f16
]
as
const
;
const
kFloatVec2
=
[
Type
.
vec2af
Type
.
vec2f
Type
.
vec2h
]
as
const
;
const
kFloatVec3
=
[
Type
.
vec3af
Type
.
vec3f
Type
.
vec3h
]
as
const
;
const
kFloatVec4
=
[
Type
.
vec4af
Type
.
vec4f
Type
.
vec4h
]
as
const
;
export
const
kConcreteF32ScalarsAndVectors
=
[
Type
.
f32
Type
.
vec2f
Type
.
vec3f
Type
.
vec4f
]
as
const
;
export
const
kConcreteF16ScalarsAndVectors
=
[
Type
.
f16
Type
.
vec2h
Type
.
vec3h
Type
.
vec4h
]
as
const
;
export
const
kFloatVectors
=
[
.
.
.
kFloatVec2
.
.
.
kFloatVec3
.
.
.
kFloatVec4
]
as
const
;
export
const
kFloatScalarsAndVectors
=
[
.
.
.
kFloatScalars
.
.
.
kFloatVectors
]
as
const
;
export
const
kConcreteSignedIntegerVectors
=
[
Type
.
vec2i
Type
.
vec3i
Type
.
vec4i
]
as
const
;
export
const
kConcreteUnsignedIntegerVectors
=
[
Type
.
vec2u
Type
.
vec3u
Type
.
vec4u
]
as
const
;
export
const
kConcreteIntegerVectors
=
[
.
.
.
kConcreteSignedIntegerVectors
.
.
.
kConcreteUnsignedIntegerVectors
]
as
const
;
export
const
kConcreteSignedIntegerScalarsAndVectors
=
[
Type
.
i32
.
.
.
kConcreteSignedIntegerVectors
]
as
const
;
export
const
kConcreteUnsignedIntegerScalarsAndVectors
=
[
Type
.
u32
.
.
.
kConcreteUnsignedIntegerVectors
]
as
const
;
export
const
kConcreteIntegerScalarsAndVectors
=
[
.
.
.
kConcreteSignedIntegerScalarsAndVectors
.
.
.
kConcreteUnsignedIntegerScalarsAndVectors
]
as
const
;
export
const
kConvertableToFloatScalar
=
[
Type
.
abstractInt
.
.
.
kFloatScalars
]
as
const
;
export
const
kConvertableToFloatVec2
=
[
Type
.
vec2ai
.
.
.
kFloatVec2
]
as
const
;
export
const
kConvertableToFloatVec3
=
[
Type
.
vec3ai
.
.
.
kFloatVec3
]
as
const
;
export
const
kConvertableToFloatVec4
=
[
Type
.
vec4ai
.
.
.
kFloatVec4
]
as
const
;
export
const
kConvertableToFloatVectors
=
[
Type
.
vec2ai
Type
.
vec3ai
Type
.
vec4ai
.
.
.
kFloatVectors
]
as
const
;
export
const
kConvertableToFloatScalarsAndVectors
=
[
Type
.
abstractInt
.
.
.
kFloatScalars
.
.
.
kConvertableToFloatVectors
]
as
const
;
export
const
kAllNumericScalarsAndVectors
=
[
.
.
.
kConvertableToFloatScalarsAndVectors
.
.
.
kConcreteIntegerScalarsAndVectors
]
as
const
;
export
const
kConcreteNumericScalarsAndVectors
=
[
.
.
.
kConcreteIntegerScalarsAndVectors
.
.
.
kConcreteF16ScalarsAndVectors
.
.
.
kConcreteF32ScalarsAndVectors
]
as
const
;
export
const
kAllBoolScalarsAndVectors
=
[
Type
.
bool
Type
.
vec2b
Type
.
vec3b
Type
.
vec4b
]
as
const
;
export
const
kAllScalarsAndVectors
=
[
.
.
.
kAllBoolScalarsAndVectors
.
.
.
kAllNumericScalarsAndVectors
]
as
const
;
export
const
kAllVecTypes
=
Object
.
values
(
kVecTypes
)
;
export
const
kAllMatrices
=
Object
.
values
(
kMatTypes
)
;
