import
{
ROArrayArray
ROArrayArrayArray
}
from
'
.
.
/
.
.
/
common
/
util
/
types
.
js
'
;
import
{
assert
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
Float16Array
getFloat16
hfround
setFloat16
}
from
'
.
.
/
.
.
/
external
/
petamoriken
/
float16
/
float16
.
js
'
;
import
{
kBit
kValue
}
from
'
.
/
constants
.
js
'
;
import
{
reinterpretF64AsU64
reinterpretU64AsF64
reinterpretU32AsF32
reinterpretU16AsF16
}
from
'
.
/
reinterpret
.
js
'
;
export
const
kMaxSafeMultipleOf8
=
Number
.
MAX_SAFE_INTEGER
-
7
;
export
function
align
(
n
:
number
alignment
:
number
)
:
number
{
assert
(
Number
.
isInteger
(
n
)
&
&
n
>
=
0
'
n
must
be
a
non
-
negative
integer
'
)
;
assert
(
Number
.
isInteger
(
alignment
)
&
&
alignment
>
0
'
alignment
must
be
a
positive
integer
'
)
;
return
Math
.
ceil
(
n
/
alignment
)
*
alignment
;
}
export
function
roundDown
(
n
:
number
alignment
:
number
)
:
number
{
assert
(
Number
.
isInteger
(
n
)
&
&
n
>
=
0
'
n
must
be
a
non
-
negative
integer
'
)
;
assert
(
Number
.
isInteger
(
alignment
)
&
&
alignment
>
0
'
alignment
must
be
a
positive
integer
'
)
;
return
Math
.
floor
(
n
/
alignment
)
*
alignment
;
}
export
function
clamp
(
n
:
number
{
min
max
}
:
{
min
:
number
;
max
:
number
}
)
:
number
{
assert
(
max
>
=
min
)
;
return
Math
.
min
(
Math
.
max
(
n
min
)
max
)
;
}
export
function
flushSubnormalNumberF64
(
val
:
number
)
:
number
{
return
isSubnormalNumberF64
(
val
)
?
0
:
val
;
}
export
function
isSubnormalNumberF64
(
n
:
number
)
:
boolean
{
return
n
>
kValue
.
f64
.
negative
.
max
&
&
n
<
kValue
.
f64
.
positive
.
min
;
}
export
function
flushSubnormalNumberF32
(
val
:
number
)
:
number
{
return
isSubnormalNumberF32
(
val
)
?
0
:
val
;
}
export
function
isSubnormalNumberF32
(
n
:
number
)
:
boolean
{
return
n
>
kValue
.
f32
.
negative
.
max
&
&
n
<
kValue
.
f32
.
positive
.
min
;
}
export
function
isFiniteF32
(
n
:
number
)
{
return
n
>
=
kValue
.
f32
.
negative
.
min
&
&
n
<
=
kValue
.
f32
.
positive
.
max
;
}
export
function
flushSubnormalNumberF16
(
val
:
number
)
:
number
{
return
isSubnormalNumberF16
(
val
)
?
0
:
val
;
}
export
function
isSubnormalNumberF16
(
n
:
number
)
:
boolean
{
return
n
>
kValue
.
f16
.
negative
.
max
&
&
n
<
kValue
.
f16
.
positive
.
min
;
}
export
function
isFiniteF16
(
n
:
number
)
{
return
n
>
=
kValue
.
f16
.
negative
.
min
&
&
n
<
=
kValue
.
f16
.
positive
.
max
;
}
export
type
FlushMode
=
'
flush
'
|
'
no
-
flush
'
;
export
type
NextDirection
=
'
positive
'
|
'
negative
'
;
const
nextAfterF64Data
=
new
ArrayBuffer
(
8
)
;
const
nextAfterF64Int
=
new
BigUint64Array
(
nextAfterF64Data
)
;
const
nextAfterF64Float
=
new
Float64Array
(
nextAfterF64Data
)
;
export
function
nextAfterF64
(
val
:
number
dir
:
NextDirection
mode
:
FlushMode
)
:
number
{
if
(
Number
.
isNaN
(
val
)
)
{
return
val
;
}
if
(
val
=
=
=
Number
.
POSITIVE_INFINITY
)
{
return
kValue
.
f64
.
positive
.
infinity
;
}
if
(
val
=
=
=
Number
.
NEGATIVE_INFINITY
)
{
return
kValue
.
f64
.
negative
.
infinity
;
}
assert
(
val
<
=
kValue
.
f64
.
positive
.
max
&
&
val
>
=
kValue
.
f64
.
negative
.
min
{
val
}
is
not
in
the
range
of
f64
)
;
val
=
mode
=
=
=
'
flush
'
?
flushSubnormalNumberF64
(
val
)
:
val
;
if
(
val
=
=
=
0
)
{
if
(
dir
=
=
=
'
positive
'
)
{
return
mode
=
=
=
'
flush
'
?
kValue
.
f64
.
positive
.
min
:
kValue
.
f64
.
positive
.
subnormal
.
min
;
}
else
{
return
mode
=
=
=
'
flush
'
?
kValue
.
f64
.
negative
.
max
:
kValue
.
f64
.
negative
.
subnormal
.
max
;
}
}
nextAfterF64Float
[
0
]
=
val
;
const
is_positive
=
(
nextAfterF64Int
[
0
]
&
0x8000_0000_0000_0000n
)
=
=
=
0n
;
if
(
is_positive
=
=
=
(
dir
=
=
=
'
positive
'
)
)
{
nextAfterF64Int
[
0
]
+
=
1n
;
}
else
{
nextAfterF64Int
[
0
]
-
=
1n
;
}
if
(
(
nextAfterF64Int
[
0
]
&
0x7ff0_0000_0000_0000n
)
=
=
=
0x7ff0_0000_0000_0000n
)
{
if
(
dir
=
=
=
'
positive
'
)
{
return
kValue
.
f64
.
positive
.
infinity
;
}
else
{
return
kValue
.
f64
.
negative
.
infinity
;
}
}
return
mode
=
=
=
'
flush
'
?
flushSubnormalNumberF64
(
nextAfterF64Float
[
0
]
)
:
nextAfterF64Float
[
0
]
;
}
const
nextAfterF32Data
=
new
ArrayBuffer
(
4
)
;
const
nextAfterF32Int
=
new
Uint32Array
(
nextAfterF32Data
)
;
const
nextAfterF32Float
=
new
Float32Array
(
nextAfterF32Data
)
;
export
function
nextAfterF32
(
val
:
number
dir
:
NextDirection
mode
:
FlushMode
)
:
number
{
if
(
Number
.
isNaN
(
val
)
)
{
return
val
;
}
if
(
val
=
=
=
Number
.
POSITIVE_INFINITY
)
{
return
kValue
.
f32
.
positive
.
infinity
;
}
if
(
val
=
=
=
Number
.
NEGATIVE_INFINITY
)
{
return
kValue
.
f32
.
negative
.
infinity
;
}
assert
(
val
<
=
kValue
.
f32
.
positive
.
max
&
&
val
>
=
kValue
.
f32
.
negative
.
min
{
val
}
is
not
in
the
range
of
f32
)
;
val
=
mode
=
=
=
'
flush
'
?
flushSubnormalNumberF32
(
val
)
:
val
;
if
(
val
=
=
=
0
)
{
if
(
dir
=
=
=
'
positive
'
)
{
return
mode
=
=
=
'
flush
'
?
kValue
.
f32
.
positive
.
min
:
kValue
.
f32
.
positive
.
subnormal
.
min
;
}
else
{
return
mode
=
=
=
'
flush
'
?
kValue
.
f32
.
negative
.
max
:
kValue
.
f32
.
negative
.
subnormal
.
max
;
}
}
nextAfterF32Float
[
0
]
=
val
;
if
(
(
dir
=
=
=
'
positive
'
&
&
nextAfterF32Float
[
0
]
<
=
val
)
|
|
(
dir
=
=
=
'
negative
'
&
&
nextAfterF32Float
[
0
]
>
=
val
)
)
{
const
is_positive
=
(
nextAfterF32Int
[
0
]
&
0x80000000
)
=
=
=
0
;
if
(
is_positive
=
=
=
(
dir
=
=
=
'
positive
'
)
)
{
nextAfterF32Int
[
0
]
+
=
1
;
}
else
{
nextAfterF32Int
[
0
]
-
=
1
;
}
}
if
(
(
nextAfterF32Int
[
0
]
&
0x7f800000
)
=
=
=
0x7f800000
)
{
if
(
dir
=
=
=
'
positive
'
)
{
return
kValue
.
f32
.
positive
.
infinity
;
}
else
{
return
kValue
.
f32
.
negative
.
infinity
;
}
}
return
mode
=
=
=
'
flush
'
?
flushSubnormalNumberF32
(
nextAfterF32Float
[
0
]
)
:
nextAfterF32Float
[
0
]
;
}
const
nextAfterF16Data
=
new
ArrayBuffer
(
2
)
;
const
nextAfterF16Hex
=
new
Uint16Array
(
nextAfterF16Data
)
;
const
nextAfterF16Float
=
new
Float16Array
(
nextAfterF16Data
)
;
export
function
nextAfterF16
(
val
:
number
dir
:
NextDirection
mode
:
FlushMode
)
:
number
{
if
(
Number
.
isNaN
(
val
)
)
{
return
val
;
}
if
(
val
=
=
=
Number
.
POSITIVE_INFINITY
)
{
return
kValue
.
f16
.
positive
.
infinity
;
}
if
(
val
=
=
=
Number
.
NEGATIVE_INFINITY
)
{
return
kValue
.
f16
.
negative
.
infinity
;
}
assert
(
val
<
=
kValue
.
f16
.
positive
.
max
&
&
val
>
=
kValue
.
f16
.
negative
.
min
{
val
}
is
not
in
the
range
of
f16
)
;
val
=
mode
=
=
=
'
flush
'
?
flushSubnormalNumberF16
(
val
)
:
val
;
if
(
val
=
=
=
0
)
{
if
(
dir
=
=
=
'
positive
'
)
{
return
mode
=
=
=
'
flush
'
?
kValue
.
f16
.
positive
.
min
:
kValue
.
f16
.
positive
.
subnormal
.
min
;
}
else
{
return
mode
=
=
=
'
flush
'
?
kValue
.
f16
.
negative
.
max
:
kValue
.
f16
.
negative
.
subnormal
.
max
;
}
}
nextAfterF16Float
[
0
]
=
val
;
if
(
(
dir
=
=
=
'
positive
'
&
&
nextAfterF16Float
[
0
]
<
=
val
)
|
|
(
dir
=
=
=
'
negative
'
&
&
nextAfterF16Float
[
0
]
>
=
val
)
)
{
const
is_positive
=
(
nextAfterF16Hex
[
0
]
&
0x8000
)
=
=
=
0
;
if
(
is_positive
=
=
=
(
dir
=
=
=
'
positive
'
)
)
{
nextAfterF16Hex
[
0
]
+
=
1
;
}
else
{
nextAfterF16Hex
[
0
]
-
=
1
;
}
}
if
(
(
nextAfterF16Hex
[
0
]
&
0x7c00
)
=
=
=
0x7c00
)
{
if
(
dir
=
=
=
'
positive
'
)
{
return
kValue
.
f16
.
positive
.
infinity
;
}
else
{
return
kValue
.
f16
.
negative
.
infinity
;
}
}
return
mode
=
=
=
'
flush
'
?
flushSubnormalNumberF16
(
nextAfterF16Float
[
0
]
)
:
nextAfterF16Float
[
0
]
;
}
export
function
oneULPF64
(
target
:
number
mode
:
FlushMode
=
'
flush
'
)
:
number
{
if
(
Number
.
isNaN
(
target
)
)
{
return
Number
.
NaN
;
}
target
=
mode
=
=
=
'
flush
'
?
flushSubnormalNumberF64
(
target
)
:
target
;
if
(
target
=
=
=
Number
.
POSITIVE_INFINITY
|
|
target
>
=
kValue
.
f64
.
positive
.
max
|
|
target
=
=
=
Number
.
NEGATIVE_INFINITY
|
|
target
<
=
kValue
.
f64
.
negative
.
min
)
{
return
kValue
.
f64
.
max_ulp
;
}
const
before
=
nextAfterF64
(
target
'
negative
'
mode
)
;
const
after
=
nextAfterF64
(
target
'
positive
'
mode
)
;
return
Math
.
min
(
target
-
before
after
-
target
)
;
}
export
function
oneULPF32
(
target
:
number
mode
:
FlushMode
=
'
flush
'
)
:
number
{
if
(
Number
.
isNaN
(
target
)
)
{
return
Number
.
NaN
;
}
target
=
mode
=
=
=
'
flush
'
?
flushSubnormalNumberF32
(
target
)
:
target
;
if
(
target
=
=
=
Number
.
POSITIVE_INFINITY
|
|
target
>
=
kValue
.
f32
.
positive
.
max
|
|
target
=
=
=
Number
.
NEGATIVE_INFINITY
|
|
target
<
=
kValue
.
f32
.
negative
.
min
)
{
return
kValue
.
f32
.
max_ulp
;
}
const
before
=
nextAfterF32
(
target
'
negative
'
mode
)
;
const
after
=
nextAfterF32
(
target
'
positive
'
mode
)
;
const
converted
:
number
=
quantizeToF32
(
target
)
;
if
(
converted
=
=
=
target
)
{
return
Math
.
min
(
target
-
before
after
-
target
)
;
}
else
{
return
after
-
before
;
}
}
export
function
hashU32
(
.
.
.
values
:
number
[
]
)
{
let
n
=
0x3504_f333
;
for
(
const
v
of
values
)
{
n
=
v
+
(
n
<
<
7
)
+
(
n
>
>
>
1
)
;
n
=
(
n
*
0x29493
)
&
0xffff_ffff
;
}
n
^
=
n
>
>
>
8
;
n
+
=
n
<
<
15
;
n
=
n
&
0xffff_ffff
;
if
(
n
<
0
)
{
n
=
~
n
*
2
+
1
;
}
return
n
;
}
export
function
oneULPF16
(
target
:
number
mode
:
FlushMode
=
'
flush
'
)
:
number
{
if
(
Number
.
isNaN
(
target
)
)
{
return
Number
.
NaN
;
}
target
=
mode
=
=
=
'
flush
'
?
flushSubnormalNumberF16
(
target
)
:
target
;
if
(
target
=
=
=
Number
.
POSITIVE_INFINITY
|
|
target
>
=
kValue
.
f16
.
positive
.
max
|
|
target
=
=
=
Number
.
NEGATIVE_INFINITY
|
|
target
<
=
kValue
.
f16
.
negative
.
min
)
{
return
kValue
.
f16
.
max_ulp
;
}
const
before
=
nextAfterF16
(
target
'
negative
'
mode
)
;
const
after
=
nextAfterF16
(
target
'
positive
'
mode
)
;
const
converted
:
number
=
quantizeToF16
(
target
)
;
if
(
converted
=
=
=
target
)
{
return
Math
.
min
(
target
-
before
after
-
target
)
;
}
else
{
return
after
-
before
;
}
}
export
function
correctlyRoundedF64
(
n
:
number
)
:
readonly
number
[
]
{
assert
(
!
Number
.
isNaN
(
n
)
correctlyRoundedF32
not
defined
for
NaN
)
;
if
(
n
=
=
=
Number
.
POSITIVE_INFINITY
)
{
return
[
kValue
.
f64
.
positive
.
max
Number
.
POSITIVE_INFINITY
]
;
}
if
(
n
=
=
=
Number
.
NEGATIVE_INFINITY
)
{
return
[
Number
.
NEGATIVE_INFINITY
kValue
.
f64
.
negative
.
min
]
;
}
return
[
n
]
;
}
export
function
correctlyRoundedF32
(
n
:
number
)
:
readonly
number
[
]
{
if
(
Number
.
isNaN
(
n
)
)
{
return
[
n
]
;
}
if
(
n
>
=
2
*
*
(
kValue
.
f32
.
emax
+
1
)
)
{
return
[
Number
.
POSITIVE_INFINITY
]
;
}
if
(
n
>
kValue
.
f32
.
positive
.
max
)
{
return
[
kValue
.
f32
.
positive
.
max
Number
.
POSITIVE_INFINITY
]
;
}
if
(
n
<
=
kValue
.
f32
.
positive
.
max
&
&
n
>
=
kValue
.
f32
.
negative
.
min
)
{
const
n_32
=
quantizeToF32
(
n
)
;
if
(
n
=
=
=
n_32
)
{
return
[
n
]
;
}
if
(
n_32
>
n
)
{
const
other
=
nextAfterF32
(
n_32
'
negative
'
'
no
-
flush
'
)
;
return
[
other
n_32
]
;
}
else
{
const
other
=
nextAfterF32
(
n_32
'
positive
'
'
no
-
flush
'
)
;
return
[
n_32
other
]
;
}
}
if
(
n
>
-
(
2
*
*
(
kValue
.
f32
.
emax
+
1
)
)
)
{
return
[
Number
.
NEGATIVE_INFINITY
kValue
.
f32
.
negative
.
min
]
;
}
return
[
Number
.
NEGATIVE_INFINITY
]
;
}
export
function
correctlyRoundedF16
(
n
:
number
)
:
readonly
number
[
]
{
if
(
Number
.
isNaN
(
n
)
)
{
return
[
n
]
;
}
if
(
n
>
=
2
*
*
(
kValue
.
f16
.
emax
+
1
)
)
{
return
[
Number
.
POSITIVE_INFINITY
]
;
}
if
(
n
>
kValue
.
f16
.
positive
.
max
)
{
return
[
kValue
.
f16
.
positive
.
max
Number
.
POSITIVE_INFINITY
]
;
}
if
(
n
<
=
kValue
.
f16
.
positive
.
max
&
&
n
>
=
kValue
.
f16
.
negative
.
min
)
{
const
n_16
=
quantizeToF16
(
n
)
;
if
(
n
=
=
=
n_16
)
{
return
[
n
]
;
}
if
(
n_16
>
n
)
{
const
other
=
nextAfterF16
(
n_16
'
negative
'
'
no
-
flush
'
)
;
return
[
other
n_16
]
;
}
else
{
const
other
=
nextAfterF16
(
n_16
'
positive
'
'
no
-
flush
'
)
;
return
[
n_16
other
]
;
}
}
if
(
n
>
-
(
2
*
*
(
kValue
.
f16
.
emax
+
1
)
)
)
{
return
[
Number
.
NEGATIVE_INFINITY
kValue
.
f16
.
negative
.
min
]
;
}
return
[
Number
.
NEGATIVE_INFINITY
]
;
}
export
function
frexp
(
val
:
number
trait
:
'
f32
'
|
'
f16
'
|
'
f64
'
)
:
{
fract
:
number
;
exp
:
number
}
{
const
buffer
=
new
ArrayBuffer
(
8
)
;
const
dataView
=
new
DataView
(
buffer
)
;
let
expBitCount
:
number
fractBitCount
:
number
expBias
:
number
;
let
expMaskForHigh16Bits
:
number
targetExpBitsForHigh16Bits
:
number
;
let
setFloatToBuffer
:
(
v
:
number
)
=
>
void
;
let
getFloatFromBuffer
:
(
)
=
>
number
;
let
isFinite
:
(
v
:
number
)
=
>
boolean
;
let
isSubnormal
:
(
v
:
number
)
=
>
boolean
;
if
(
trait
=
=
=
'
f32
'
)
{
expBitCount
=
8
;
fractBitCount
=
23
;
expBias
=
127
;
expMaskForHigh16Bits
=
0x7f80
;
targetExpBitsForHigh16Bits
=
0x3f00
;
isFinite
=
isFiniteF32
;
isSubnormal
=
isSubnormalNumberF32
;
setFloatToBuffer
=
(
v
:
number
)
=
>
dataView
.
setFloat32
(
0
v
false
)
;
getFloatFromBuffer
=
(
)
=
>
dataView
.
getFloat32
(
0
false
)
;
}
else
if
(
trait
=
=
=
'
f16
'
)
{
expBitCount
=
5
;
fractBitCount
=
10
;
expBias
=
15
;
expMaskForHigh16Bits
=
0x7c00
;
targetExpBitsForHigh16Bits
=
0x3800
;
isFinite
=
isFiniteF16
;
isSubnormal
=
isSubnormalNumberF16
;
setFloatToBuffer
=
(
v
:
number
)
=
>
setFloat16
(
dataView
0
v
false
)
;
getFloatFromBuffer
=
(
)
=
>
getFloat16
(
dataView
0
false
)
;
}
else
{
assert
(
trait
=
=
=
'
f64
'
)
;
expBitCount
=
11
;
fractBitCount
=
52
;
expBias
=
1023
;
expMaskForHigh16Bits
=
0x7ff0
;
targetExpBitsForHigh16Bits
=
0x3fe0
;
isFinite
=
Number
.
isFinite
;
isSubnormal
=
isSubnormalNumberF64
;
setFloatToBuffer
=
(
v
:
number
)
=
>
dataView
.
setFloat64
(
0
v
false
)
;
getFloatFromBuffer
=
(
)
=
>
dataView
.
getFloat64
(
0
false
)
;
}
const
extractUnbiasedExpFromNormalFloatInBuffer
=
(
)
=
>
{
assert
(
isFinite
(
getFloatFromBuffer
(
)
)
&
&
!
isSubnormal
(
getFloatFromBuffer
(
)
)
)
;
const
high16BitsAsUint16
=
dataView
.
getUint16
(
0
false
)
;
return
(
(
high16BitsAsUint16
&
expMaskForHigh16Bits
)
>
>
(
16
-
1
-
expBitCount
)
)
-
expBias
;
}
;
const
modifyExpOfNormalFloatInBuffer
=
(
)
=
>
{
assert
(
isFinite
(
getFloatFromBuffer
(
)
)
&
&
!
isSubnormal
(
getFloatFromBuffer
(
)
)
)
;
const
high16BitsAsUint16
=
dataView
.
getUint16
(
0
false
)
;
const
modifiedHigh16Bits
=
(
high16BitsAsUint16
&
~
expMaskForHigh16Bits
)
|
targetExpBitsForHigh16Bits
;
dataView
.
setUint16
(
0
modifiedHigh16Bits
false
)
;
}
;
if
(
val
=
=
=
0
)
{
return
{
fract
:
val
exp
:
0
}
;
}
if
(
!
isFinite
(
val
)
)
{
return
{
fract
:
val
exp
:
0
}
;
}
setFloatToBuffer
(
val
)
;
let
exp
=
0
;
if
(
isSubnormal
(
getFloatFromBuffer
(
)
)
)
{
setFloatToBuffer
(
getFloatFromBuffer
(
)
*
2
*
*
fractBitCount
)
;
exp
=
-
fractBitCount
;
}
exp
+
=
extractUnbiasedExpFromNormalFloatInBuffer
(
)
+
1
;
modifyExpOfNormalFloatInBuffer
(
)
;
return
{
fract
:
getFloatFromBuffer
(
)
exp
}
;
}
export
function
lerp
(
a
:
number
b
:
number
t
:
number
)
:
number
{
if
(
!
Number
.
isFinite
(
a
)
|
|
!
Number
.
isFinite
(
b
)
)
{
return
Number
.
NaN
;
}
if
(
(
a
<
=
0
.
0
&
&
b
>
=
0
.
0
)
|
|
(
a
>
=
0
.
0
&
&
b
<
=
0
.
0
)
)
{
return
t
*
b
+
(
1
-
t
)
*
a
;
}
if
(
t
=
=
=
1
.
0
)
{
return
b
;
}
const
x
=
a
+
t
*
(
b
-
a
)
;
return
t
>
1
.
0
=
=
=
b
>
a
?
Math
.
max
(
b
x
)
:
Math
.
min
(
b
x
)
;
}
export
function
lerpBigInt
(
a
:
bigint
b
:
bigint
idx
:
number
steps
:
number
)
:
bigint
{
assert
(
Math
.
trunc
(
idx
)
=
=
=
idx
)
;
assert
(
Math
.
trunc
(
steps
)
=
=
=
steps
)
;
assert
(
idx
>
=
0
)
;
assert
(
steps
>
0
)
;
assert
(
idx
<
steps
)
;
if
(
steps
=
=
=
1
)
{
return
a
;
}
if
(
idx
=
=
=
0
)
{
return
a
;
}
if
(
idx
=
=
=
steps
-
1
)
{
return
b
;
}
const
min
=
(
x
:
bigint
y
:
bigint
)
:
bigint
=
>
{
return
x
<
y
?
x
:
y
;
}
;
const
max
=
(
x
:
bigint
y
:
bigint
)
:
bigint
=
>
{
return
x
>
y
?
x
:
y
;
}
;
const
big_idx
=
BigInt
(
idx
)
;
const
big_steps
=
BigInt
(
steps
)
;
if
(
(
a
<
=
0n
&
&
b
>
=
0n
)
|
|
(
a
>
=
0n
&
&
b
<
=
0n
)
)
{
return
(
b
*
big_idx
)
/
(
big_steps
-
1n
)
+
(
a
-
(
a
*
big_idx
)
/
(
big_steps
-
1n
)
)
;
}
const
x
=
a
+
(
b
*
big_idx
)
/
(
big_steps
-
1n
)
-
(
a
*
big_idx
)
/
(
big_steps
-
1n
)
;
return
!
(
b
>
a
)
?
max
(
b
x
)
:
min
(
b
x
)
;
}
export
function
linearRange
(
a
:
number
b
:
number
num_steps
:
number
)
:
readonly
number
[
]
{
if
(
num_steps
<
=
0
)
{
return
[
]
;
}
if
(
num_steps
=
=
=
1
)
{
return
[
a
]
;
}
return
Array
.
from
(
Array
(
num_steps
)
.
keys
(
)
)
.
map
(
i
=
>
lerp
(
a
b
i
/
(
num_steps
-
1
)
)
)
;
}
export
function
linearRangeBigInt
(
a
:
bigint
b
:
bigint
num_steps
:
number
)
:
Array
<
bigint
>
{
if
(
num_steps
<
=
0
)
{
return
[
]
;
}
if
(
num_steps
=
=
=
1
)
{
return
[
a
]
;
}
return
Array
.
from
(
Array
(
num_steps
)
.
keys
(
)
)
.
map
(
i
=
>
lerpBigInt
(
a
b
i
num_steps
)
)
;
}
export
function
biasedRange
(
a
:
number
b
:
number
num_steps
:
number
)
:
readonly
number
[
]
{
const
c
=
2
;
if
(
num_steps
<
=
0
)
{
return
[
]
;
}
if
(
num_steps
=
=
=
1
)
{
return
[
a
]
;
}
return
Array
.
from
(
Array
(
num_steps
)
.
keys
(
)
)
.
map
(
i
=
>
lerp
(
a
b
Math
.
pow
(
i
/
(
num_steps
-
1
)
c
)
)
)
;
}
export
function
biasedRangeBigInt
(
a
:
bigint
b
:
bigint
num_steps
:
number
)
:
readonly
bigint
[
]
{
if
(
num_steps
<
=
0
)
{
return
[
]
;
}
if
(
num_steps
=
=
=
1
)
{
return
[
a
]
;
}
const
c
=
2
;
const
scaling
=
1000
;
const
scaled_num_steps
=
num_steps
*
scaling
;
return
Array
.
from
(
Array
(
num_steps
)
.
keys
(
)
)
.
map
(
i
=
>
{
const
biased_i
=
Math
.
pow
(
i
/
(
num_steps
-
1
)
c
)
;
const
scaled_i
=
Math
.
trunc
(
(
scaled_num_steps
-
1
)
*
biased_i
)
;
return
lerpBigInt
(
a
b
scaled_i
scaled_num_steps
)
;
}
)
;
}
export
function
scalarF32Range
(
counts
:
{
neg_norm
?
:
number
;
neg_sub
?
:
number
;
pos_sub
:
number
;
pos_norm
:
number
;
}
=
{
pos_sub
:
10
pos_norm
:
50
}
)
:
Array
<
number
>
{
counts
.
neg_norm
=
counts
.
neg_norm
=
=
=
undefined
?
counts
.
pos_norm
:
counts
.
neg_norm
;
counts
.
neg_sub
=
counts
.
neg_sub
=
=
=
undefined
?
counts
.
pos_sub
:
counts
.
neg_sub
;
const
bit_fields
=
[
.
.
.
linearRange
(
kBit
.
f32
.
negative
.
min
kBit
.
f32
.
negative
.
max
counts
.
neg_norm
)
.
.
.
linearRange
(
kBit
.
f32
.
negative
.
subnormal
.
min
kBit
.
f32
.
negative
.
subnormal
.
max
counts
.
neg_sub
)
0x80000000
0
.
.
.
linearRange
(
kBit
.
f32
.
positive
.
subnormal
.
min
kBit
.
f32
.
positive
.
subnormal
.
max
counts
.
pos_sub
)
.
.
.
linearRange
(
kBit
.
f32
.
positive
.
min
kBit
.
f32
.
positive
.
max
counts
.
pos_norm
)
]
.
map
(
Math
.
trunc
)
;
return
bit_fields
.
map
(
reinterpretU32AsF32
)
;
}
export
function
filteredScalarF32Range
(
source
:
String
low
:
number
high
:
number
)
:
Array
<
number
>
{
return
scalarF32Range
(
)
.
filter
(
x
=
>
source
!
=
=
'
const
'
|
|
(
x
>
=
low
&
&
x
<
=
high
)
)
;
}
export
function
scalarF16Range
(
counts
:
{
neg_norm
?
:
number
;
neg_sub
?
:
number
;
pos_sub
:
number
;
pos_norm
:
number
;
}
=
{
pos_sub
:
10
pos_norm
:
50
}
)
:
Array
<
number
>
{
counts
.
neg_norm
=
counts
.
neg_norm
=
=
=
undefined
?
counts
.
pos_norm
:
counts
.
neg_norm
;
counts
.
neg_sub
=
counts
.
neg_sub
=
=
=
undefined
?
counts
.
pos_sub
:
counts
.
neg_sub
;
const
bit_fields
=
[
.
.
.
linearRange
(
kBit
.
f16
.
negative
.
min
kBit
.
f16
.
negative
.
max
counts
.
neg_norm
)
.
.
.
linearRange
(
kBit
.
f16
.
negative
.
subnormal
.
min
kBit
.
f16
.
negative
.
subnormal
.
max
counts
.
neg_sub
)
0x8000
0
.
.
.
linearRange
(
kBit
.
f16
.
positive
.
subnormal
.
min
kBit
.
f16
.
positive
.
subnormal
.
max
counts
.
pos_sub
)
.
.
.
linearRange
(
kBit
.
f16
.
positive
.
min
kBit
.
f16
.
positive
.
max
counts
.
pos_norm
)
]
.
map
(
Math
.
trunc
)
;
return
bit_fields
.
map
(
reinterpretU16AsF16
)
;
}
export
function
scalarF64Range
(
counts
:
{
neg_norm
?
:
number
;
neg_sub
?
:
number
;
pos_sub
:
number
;
pos_norm
:
number
;
}
=
{
pos_sub
:
10
pos_norm
:
50
}
)
:
Array
<
number
>
{
counts
.
neg_norm
=
counts
.
neg_norm
=
=
=
undefined
?
counts
.
pos_norm
:
counts
.
neg_norm
;
counts
.
neg_sub
=
counts
.
neg_sub
=
=
=
undefined
?
counts
.
pos_sub
:
counts
.
neg_sub
;
const
bit_fields
=
[
.
.
.
linearRangeBigInt
(
kBit
.
f64
.
negative
.
min
kBit
.
f64
.
negative
.
max
counts
.
neg_norm
)
.
.
.
linearRangeBigInt
(
kBit
.
f64
.
negative
.
subnormal
.
min
kBit
.
f64
.
negative
.
subnormal
.
max
counts
.
neg_sub
)
0x8000_0000_0000_0000n
0n
.
.
.
linearRangeBigInt
(
kBit
.
f64
.
positive
.
subnormal
.
min
kBit
.
f64
.
positive
.
subnormal
.
max
counts
.
pos_sub
)
.
.
.
linearRangeBigInt
(
kBit
.
f64
.
positive
.
min
kBit
.
f64
.
positive
.
max
counts
.
pos_norm
)
]
;
return
bit_fields
.
map
(
reinterpretU64AsF64
)
;
}
export
function
limitedScalarF64Range
(
begin
:
number
end
:
number
counts
:
{
neg_norm
?
:
number
;
neg_sub
?
:
number
;
pos_sub
:
number
;
pos_norm
:
number
}
=
{
pos_sub
:
10
pos_norm
:
50
}
)
:
Array
<
number
>
{
assert
(
begin
<
=
kValue
.
f64
.
negative
.
max
Beginning
of
range
{
begin
}
must
be
negative
f64
normal
)
;
assert
(
end
>
=
kValue
.
f64
.
positive
.
min
Ending
of
range
{
end
}
must
be
positive
f64
normal
)
;
counts
.
neg_norm
=
counts
.
neg_norm
=
=
=
undefined
?
counts
.
pos_norm
:
counts
.
neg_norm
;
counts
.
neg_sub
=
counts
.
neg_sub
=
=
=
undefined
?
counts
.
pos_sub
:
counts
.
neg_sub
;
const
u64_begin
=
reinterpretF64AsU64
(
begin
)
;
const
u64_end
=
reinterpretF64AsU64
(
end
)
;
const
bit_fields
=
[
.
.
.
linearRangeBigInt
(
u64_begin
kBit
.
f64
.
negative
.
max
counts
.
neg_norm
)
.
.
.
linearRangeBigInt
(
kBit
.
f64
.
negative
.
subnormal
.
min
kBit
.
f64
.
negative
.
subnormal
.
max
counts
.
neg_sub
)
0x8000_0000_0000_0000n
0n
.
.
.
linearRangeBigInt
(
kBit
.
f64
.
positive
.
subnormal
.
min
kBit
.
f64
.
positive
.
subnormal
.
max
counts
.
pos_sub
)
.
.
.
linearRangeBigInt
(
kBit
.
f64
.
positive
.
min
u64_end
counts
.
pos_norm
)
]
;
return
bit_fields
.
map
(
reinterpretU64AsF64
)
;
}
const
kInterestingI32Values
:
readonly
number
[
]
=
[
kValue
.
i32
.
negative
.
max
Math
.
trunc
(
kValue
.
i32
.
negative
.
max
/
2
)
-
256
-
10
-
1
0
1
10
256
Math
.
trunc
(
kValue
.
i32
.
positive
.
max
/
2
)
kValue
.
i32
.
positive
.
max
]
;
export
function
sparseI32Range
(
)
:
readonly
number
[
]
{
return
kInterestingI32Values
;
}
const
kVectorI32Values
=
{
2
:
kInterestingI32Values
.
flatMap
(
f
=
>
[
[
f
1
]
[
-
1
f
]
]
)
3
:
kInterestingI32Values
.
flatMap
(
f
=
>
[
[
f
1
-
2
]
[
-
1
f
2
]
[
1
-
2
f
]
]
)
4
:
kInterestingI32Values
.
flatMap
(
f
=
>
[
[
f
-
1
2
3
]
[
1
f
-
2
3
]
[
1
2
f
-
3
]
[
-
1
2
-
3
f
]
]
)
}
;
export
function
vectorI32Range
(
dim
:
number
)
:
ROArrayArray
<
number
>
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
vectorI32Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kVectorI32Values
[
dim
]
;
}
const
kSparseVectorI32Values
=
{
2
:
sparseI32Range
(
)
.
map
(
(
i
idx
)
=
>
[
idx
%
2
=
=
=
0
?
i
:
idx
idx
%
2
=
=
=
1
?
i
:
-
idx
]
)
3
:
sparseI32Range
(
)
.
map
(
(
i
idx
)
=
>
[
idx
%
3
=
=
=
0
?
i
:
idx
idx
%
3
=
=
=
1
?
i
:
-
idx
idx
%
3
=
=
=
2
?
i
:
idx
]
)
4
:
sparseI32Range
(
)
.
map
(
(
i
idx
)
=
>
[
idx
%
4
=
=
=
0
?
i
:
idx
idx
%
4
=
=
=
1
?
i
:
-
idx
idx
%
4
=
=
=
2
?
i
:
idx
idx
%
4
=
=
=
3
?
i
:
-
idx
]
)
}
;
export
function
sparseVectorI32Range
(
dim
:
number
)
:
ROArrayArray
<
number
>
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
sparseVectorI32Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kSparseVectorI32Values
[
dim
]
;
}
export
function
fullI32Range
(
counts
:
{
negative
?
:
number
;
positive
:
number
;
}
=
{
positive
:
50
}
)
:
Array
<
number
>
{
counts
.
negative
=
counts
.
negative
=
=
=
undefined
?
counts
.
positive
:
counts
.
negative
;
return
[
.
.
.
biasedRange
(
kValue
.
i32
.
negative
.
min
-
1
counts
.
negative
)
0
.
.
.
biasedRange
(
1
kValue
.
i32
.
positive
.
max
counts
.
positive
)
]
.
map
(
Math
.
trunc
)
;
}
const
kInterestingU32Values
:
readonly
number
[
]
=
[
0
1
10
256
Math
.
trunc
(
kValue
.
u32
.
max
/
2
)
kValue
.
u32
.
max
]
;
export
function
sparseU32Range
(
)
:
readonly
number
[
]
{
return
kInterestingU32Values
;
}
const
kVectorU32Values
=
{
2
:
kInterestingU32Values
.
flatMap
(
f
=
>
[
[
f
1
]
[
1
f
]
]
)
3
:
kInterestingU32Values
.
flatMap
(
f
=
>
[
[
f
1
2
]
[
1
f
2
]
[
1
2
f
]
]
)
4
:
kInterestingU32Values
.
flatMap
(
f
=
>
[
[
f
1
2
3
]
[
1
f
2
3
]
[
1
2
f
3
]
[
1
2
3
f
]
]
)
}
;
export
function
vectorU32Range
(
dim
:
number
)
:
ROArrayArray
<
number
>
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
vectorU32Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kVectorU32Values
[
dim
]
;
}
const
kSparseVectorU32Values
=
{
2
:
sparseU32Range
(
)
.
map
(
(
i
idx
)
=
>
[
idx
%
2
=
=
=
0
?
i
:
idx
idx
%
2
=
=
=
1
?
i
:
-
idx
]
)
3
:
sparseU32Range
(
)
.
map
(
(
i
idx
)
=
>
[
idx
%
3
=
=
=
0
?
i
:
idx
idx
%
3
=
=
=
1
?
i
:
-
idx
idx
%
3
=
=
=
2
?
i
:
idx
]
)
4
:
sparseU32Range
(
)
.
map
(
(
i
idx
)
=
>
[
idx
%
4
=
=
=
0
?
i
:
idx
idx
%
4
=
=
=
1
?
i
:
-
idx
idx
%
4
=
=
=
2
?
i
:
idx
idx
%
4
=
=
=
3
?
i
:
-
idx
]
)
}
;
export
function
sparseVectorU32Range
(
dim
:
number
)
:
ROArrayArray
<
number
>
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
sparseVectorU32Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kSparseVectorU32Values
[
dim
]
;
}
export
function
fullU32Range
(
count
:
number
=
50
)
:
Array
<
number
>
{
return
[
0
.
.
.
biasedRange
(
1
kValue
.
u32
.
max
count
)
]
.
map
(
Math
.
trunc
)
;
}
const
kInterestingI64Values
:
readonly
bigint
[
]
=
[
kValue
.
i64
.
negative
.
max
kValue
.
i64
.
negative
.
max
/
2n
-
256n
-
10n
-
1n
0n
1n
10n
256n
kValue
.
i64
.
positive
.
max
/
2n
kValue
.
i64
.
positive
.
max
]
;
export
function
sparseI64Range
(
)
:
readonly
bigint
[
]
{
return
kInterestingI64Values
;
}
const
kVectorI64Values
=
{
2
:
kInterestingI64Values
.
flatMap
(
f
=
>
[
[
f
1n
]
[
-
1n
f
]
]
)
3
:
kInterestingI64Values
.
flatMap
(
f
=
>
[
[
f
1n
-
2n
]
[
-
1n
f
2n
]
[
1n
-
2n
f
]
]
)
4
:
kInterestingI64Values
.
flatMap
(
f
=
>
[
[
f
-
1n
2n
3n
]
[
1n
f
-
2n
3n
]
[
1n
2n
f
-
3n
]
[
-
1n
2n
-
3n
f
]
]
)
}
;
export
function
vectorI64Range
(
dim
:
number
)
:
ROArrayArray
<
bigint
>
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
vectorI64Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kVectorI64Values
[
dim
]
;
}
const
kSparseVectorI64Values
=
{
2
:
sparseI64Range
(
)
.
map
(
(
i
idx
)
=
>
[
idx
%
2
=
=
=
0
?
i
:
BigInt
(
idx
)
idx
%
2
=
=
=
1
?
i
:
-
BigInt
(
idx
)
]
)
3
:
sparseI64Range
(
)
.
map
(
(
i
idx
)
=
>
[
idx
%
3
=
=
=
0
?
i
:
BigInt
(
idx
)
idx
%
3
=
=
=
1
?
i
:
-
BigInt
(
idx
)
idx
%
3
=
=
=
2
?
i
:
BigInt
(
idx
)
]
)
4
:
sparseI64Range
(
)
.
map
(
(
i
idx
)
=
>
[
idx
%
4
=
=
=
0
?
i
:
BigInt
(
idx
)
idx
%
4
=
=
=
1
?
i
:
-
BigInt
(
idx
)
idx
%
4
=
=
=
2
?
i
:
BigInt
(
idx
)
idx
%
4
=
=
=
3
?
i
:
-
BigInt
(
idx
)
]
)
}
;
export
function
sparseVectorI64Range
(
dim
:
number
)
:
ROArrayArray
<
bigint
>
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
sparseVectorI64Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kSparseVectorI64Values
[
dim
]
;
}
export
function
fullI64Range
(
counts
:
{
negative
?
:
number
;
positive
:
number
;
}
=
{
positive
:
50
}
)
:
Array
<
bigint
>
{
counts
.
negative
=
counts
.
negative
=
=
=
undefined
?
counts
.
positive
:
counts
.
negative
;
return
[
.
.
.
biasedRangeBigInt
(
kValue
.
i64
.
negative
.
min
-
1n
counts
.
negative
)
0n
.
.
.
biasedRangeBigInt
(
1n
kValue
.
i64
.
positive
.
max
counts
.
positive
)
]
;
}
const
kInterestingF32Values
:
readonly
number
[
]
=
[
kValue
.
f32
.
negative
.
min
-
10
.
0
-
1
.
0
-
0
.
125
kValue
.
f32
.
negative
.
max
kValue
.
f32
.
negative
.
subnormal
.
min
kValue
.
f32
.
negative
.
subnormal
.
max
-
0
.
0
0
.
0
kValue
.
f32
.
positive
.
subnormal
.
min
kValue
.
f32
.
positive
.
subnormal
.
max
kValue
.
f32
.
positive
.
min
0
.
125
1
.
0
10
.
0
kValue
.
f32
.
positive
.
max
]
;
export
function
sparseScalarF32Range
(
)
:
readonly
number
[
]
{
return
kInterestingF32Values
;
}
const
kVectorF32Values
=
{
2
:
kInterestingF32Values
.
flatMap
(
f
=
>
[
[
f
1
.
0
]
[
-
1
.
0
f
]
]
)
3
:
kInterestingF32Values
.
flatMap
(
f
=
>
[
[
f
1
.
0
-
2
.
0
]
[
-
1
.
0
f
2
.
0
]
[
1
.
0
-
2
.
0
f
]
]
)
4
:
kInterestingF32Values
.
flatMap
(
f
=
>
[
[
f
-
1
.
0
2
.
0
3
.
0
]
[
1
.
0
f
-
2
.
0
3
.
0
]
[
1
.
0
2
.
0
f
-
3
.
0
]
[
-
1
.
0
2
.
0
-
3
.
0
f
]
]
)
}
;
export
function
vectorF32Range
(
dim
:
number
)
:
ROArrayArray
<
number
>
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
vectorF32Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kVectorF32Values
[
dim
]
;
}
const
kSparseVectorF32Values
=
{
2
:
sparseScalarF32Range
(
)
.
map
(
(
f
idx
)
=
>
[
idx
%
2
=
=
=
0
?
f
:
idx
idx
%
2
=
=
=
1
?
f
:
-
idx
]
)
3
:
sparseScalarF32Range
(
)
.
map
(
(
f
idx
)
=
>
[
idx
%
3
=
=
=
0
?
f
:
idx
idx
%
3
=
=
=
1
?
f
:
-
idx
idx
%
3
=
=
=
2
?
f
:
idx
]
)
4
:
sparseScalarF32Range
(
)
.
map
(
(
f
idx
)
=
>
[
idx
%
4
=
=
=
0
?
f
:
idx
idx
%
4
=
=
=
1
?
f
:
-
idx
idx
%
4
=
=
=
2
?
f
:
idx
idx
%
4
=
=
=
3
?
f
:
-
idx
]
)
}
;
export
function
sparseVectorF32Range
(
dim
:
number
)
:
ROArrayArray
<
number
>
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
sparseVectorF32Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kSparseVectorF32Values
[
dim
]
;
}
const
kSparseMatrixF32Values
=
{
2
:
{
2
:
kInterestingF32Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
4
=
=
=
0
?
f
:
idx
idx
%
4
=
=
=
1
?
f
:
-
idx
]
[
idx
%
4
=
=
=
2
?
f
:
-
idx
idx
%
4
=
=
=
3
?
f
:
idx
]
]
)
3
:
kInterestingF32Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
6
=
=
=
0
?
f
:
idx
idx
%
6
=
=
=
1
?
f
:
-
idx
idx
%
6
=
=
=
2
?
f
:
idx
]
[
idx
%
6
=
=
=
3
?
f
:
-
idx
idx
%
6
=
=
=
4
?
f
:
idx
idx
%
6
=
=
=
5
?
f
:
-
idx
]
]
)
4
:
kInterestingF32Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
8
=
=
=
0
?
f
:
idx
idx
%
8
=
=
=
1
?
f
:
-
idx
idx
%
8
=
=
=
2
?
f
:
idx
idx
%
8
=
=
=
3
?
f
:
-
idx
]
[
idx
%
8
=
=
=
4
?
f
:
-
idx
idx
%
8
=
=
=
5
?
f
:
idx
idx
%
8
=
=
=
6
?
f
:
-
idx
idx
%
8
=
=
=
7
?
f
:
idx
]
]
)
}
3
:
{
2
:
kInterestingF32Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
6
=
=
=
0
?
f
:
idx
idx
%
6
=
=
=
1
?
f
:
-
idx
]
[
idx
%
6
=
=
=
2
?
f
:
-
idx
idx
%
6
=
=
=
3
?
f
:
idx
]
[
idx
%
6
=
=
=
4
?
f
:
idx
idx
%
6
=
=
=
5
?
f
:
-
idx
]
]
)
3
:
kInterestingF32Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
9
=
=
=
0
?
f
:
idx
idx
%
9
=
=
=
1
?
f
:
-
idx
idx
%
9
=
=
=
2
?
f
:
idx
]
[
idx
%
9
=
=
=
3
?
f
:
-
idx
idx
%
9
=
=
=
4
?
f
:
idx
idx
%
9
=
=
=
5
?
f
:
-
idx
]
[
idx
%
9
=
=
=
6
?
f
:
idx
idx
%
9
=
=
=
7
?
f
:
-
idx
idx
%
9
=
=
=
8
?
f
:
idx
]
]
)
4
:
kInterestingF32Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
12
=
=
=
0
?
f
:
idx
idx
%
12
=
=
=
1
?
f
:
-
idx
idx
%
12
=
=
=
2
?
f
:
idx
idx
%
12
=
=
=
3
?
f
:
-
idx
]
[
idx
%
12
=
=
=
4
?
f
:
-
idx
idx
%
12
=
=
=
5
?
f
:
idx
idx
%
12
=
=
=
6
?
f
:
-
idx
idx
%
12
=
=
=
7
?
f
:
idx
]
[
idx
%
12
=
=
=
8
?
f
:
idx
idx
%
12
=
=
=
9
?
f
:
-
idx
idx
%
12
=
=
=
10
?
f
:
idx
idx
%
12
=
=
=
11
?
f
:
-
idx
]
]
)
}
4
:
{
2
:
kInterestingF32Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
8
=
=
=
0
?
f
:
idx
idx
%
8
=
=
=
1
?
f
:
-
idx
]
[
idx
%
8
=
=
=
2
?
f
:
-
idx
idx
%
8
=
=
=
3
?
f
:
idx
]
[
idx
%
8
=
=
=
4
?
f
:
idx
idx
%
8
=
=
=
5
?
f
:
-
idx
]
[
idx
%
8
=
=
=
6
?
f
:
-
idx
idx
%
8
=
=
=
7
?
f
:
idx
]
]
)
3
:
kInterestingF32Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
12
=
=
=
0
?
f
:
idx
idx
%
12
=
=
=
1
?
f
:
-
idx
idx
%
12
=
=
=
2
?
f
:
idx
]
[
idx
%
12
=
=
=
3
?
f
:
-
idx
idx
%
12
=
=
=
4
?
f
:
idx
idx
%
12
=
=
=
5
?
f
:
-
idx
]
[
idx
%
12
=
=
=
6
?
f
:
idx
idx
%
12
=
=
=
7
?
f
:
-
idx
idx
%
12
=
=
=
8
?
f
:
idx
]
[
idx
%
12
=
=
=
9
?
f
:
-
idx
idx
%
12
=
=
=
10
?
f
:
idx
idx
%
12
=
=
=
11
?
f
:
-
idx
]
]
)
4
:
kInterestingF32Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
16
=
=
=
0
?
f
:
idx
idx
%
16
=
=
=
1
?
f
:
-
idx
idx
%
16
=
=
=
2
?
f
:
idx
idx
%
16
=
=
=
3
?
f
:
-
idx
]
[
idx
%
16
=
=
=
4
?
f
:
-
idx
idx
%
16
=
=
=
5
?
f
:
idx
idx
%
16
=
=
=
6
?
f
:
-
idx
idx
%
16
=
=
=
7
?
f
:
idx
]
[
idx
%
16
=
=
=
8
?
f
:
idx
idx
%
16
=
=
=
9
?
f
:
-
idx
idx
%
16
=
=
=
10
?
f
:
idx
idx
%
16
=
=
=
11
?
f
:
-
idx
]
[
idx
%
16
=
=
=
12
?
f
:
-
idx
idx
%
16
=
=
=
13
?
f
:
idx
idx
%
16
=
=
=
14
?
f
:
-
idx
idx
%
16
=
=
=
15
?
f
:
idx
]
]
)
}
}
;
export
function
sparseMatrixF32Range
(
c
:
number
r
:
number
)
:
ROArrayArrayArray
<
number
>
{
assert
(
c
=
=
=
2
|
|
c
=
=
=
3
|
|
c
=
=
=
4
'
sparseMatrixF32Range
only
accepts
column
counts
of
2
3
and
4
'
)
;
assert
(
r
=
=
=
2
|
|
r
=
=
=
3
|
|
r
=
=
=
4
'
sparseMatrixF32Range
only
accepts
row
counts
of
2
3
and
4
'
)
;
return
kSparseMatrixF32Values
[
c
]
[
r
]
;
}
const
kInterestingF16Values
:
readonly
number
[
]
=
[
kValue
.
f16
.
negative
.
min
-
10
.
0
-
1
.
0
-
0
.
125
kValue
.
f16
.
negative
.
max
kValue
.
f16
.
negative
.
subnormal
.
min
kValue
.
f16
.
negative
.
subnormal
.
max
-
0
.
0
0
.
0
kValue
.
f16
.
positive
.
subnormal
.
min
kValue
.
f16
.
positive
.
subnormal
.
max
kValue
.
f16
.
positive
.
min
0
.
125
1
.
0
10
.
0
kValue
.
f16
.
positive
.
max
]
;
export
function
sparseScalarF16Range
(
)
:
readonly
number
[
]
{
return
kInterestingF16Values
;
}
const
kVectorF16Values
=
{
2
:
kInterestingF16Values
.
flatMap
(
f
=
>
[
[
f
1
.
0
]
[
-
1
.
0
f
]
]
)
3
:
kInterestingF16Values
.
flatMap
(
f
=
>
[
[
f
1
.
0
-
2
.
0
]
[
-
1
.
0
f
2
.
0
]
[
1
.
0
-
2
.
0
f
]
]
)
4
:
kInterestingF16Values
.
flatMap
(
f
=
>
[
[
f
-
1
.
0
2
.
0
3
.
0
]
[
1
.
0
f
-
2
.
0
3
.
0
]
[
1
.
0
2
.
0
f
-
3
.
0
]
[
-
1
.
0
2
.
0
-
3
.
0
f
]
]
)
}
;
export
function
vectorF16Range
(
dim
:
number
)
:
ROArrayArray
<
number
>
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
vectorF16Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kVectorF16Values
[
dim
]
;
}
const
kSparseVectorF16Values
=
{
2
:
sparseScalarF16Range
(
)
.
map
(
(
f
idx
)
=
>
[
idx
%
2
=
=
=
0
?
f
:
idx
idx
%
2
=
=
=
1
?
f
:
-
idx
]
)
3
:
sparseScalarF16Range
(
)
.
map
(
(
f
idx
)
=
>
[
idx
%
3
=
=
=
0
?
f
:
idx
idx
%
3
=
=
=
1
?
f
:
-
idx
idx
%
3
=
=
=
2
?
f
:
idx
]
)
4
:
sparseScalarF16Range
(
)
.
map
(
(
f
idx
)
=
>
[
idx
%
4
=
=
=
0
?
f
:
idx
idx
%
4
=
=
=
1
?
f
:
-
idx
idx
%
4
=
=
=
2
?
f
:
idx
idx
%
4
=
=
=
3
?
f
:
-
idx
]
)
}
;
export
function
sparseVectorF16Range
(
dim
:
number
)
:
ROArrayArray
<
number
>
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
sparseVectorF16Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kSparseVectorF16Values
[
dim
]
;
}
const
kSparseMatrixF16Values
=
{
2
:
{
2
:
kInterestingF16Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
4
=
=
=
0
?
f
:
idx
idx
%
4
=
=
=
1
?
f
:
-
idx
]
[
idx
%
4
=
=
=
2
?
f
:
-
idx
idx
%
4
=
=
=
3
?
f
:
idx
]
]
)
3
:
kInterestingF16Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
6
=
=
=
0
?
f
:
idx
idx
%
6
=
=
=
1
?
f
:
-
idx
idx
%
6
=
=
=
2
?
f
:
idx
]
[
idx
%
6
=
=
=
3
?
f
:
-
idx
idx
%
6
=
=
=
4
?
f
:
idx
idx
%
6
=
=
=
5
?
f
:
-
idx
]
]
)
4
:
kInterestingF16Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
8
=
=
=
0
?
f
:
idx
idx
%
8
=
=
=
1
?
f
:
-
idx
idx
%
8
=
=
=
2
?
f
:
idx
idx
%
8
=
=
=
3
?
f
:
-
idx
]
[
idx
%
8
=
=
=
4
?
f
:
-
idx
idx
%
8
=
=
=
5
?
f
:
idx
idx
%
8
=
=
=
6
?
f
:
-
idx
idx
%
8
=
=
=
7
?
f
:
idx
]
]
)
}
3
:
{
2
:
kInterestingF16Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
6
=
=
=
0
?
f
:
idx
idx
%
6
=
=
=
1
?
f
:
-
idx
]
[
idx
%
6
=
=
=
2
?
f
:
-
idx
idx
%
6
=
=
=
3
?
f
:
idx
]
[
idx
%
6
=
=
=
4
?
f
:
idx
idx
%
6
=
=
=
5
?
f
:
-
idx
]
]
)
3
:
kInterestingF16Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
9
=
=
=
0
?
f
:
idx
idx
%
9
=
=
=
1
?
f
:
-
idx
idx
%
9
=
=
=
2
?
f
:
idx
]
[
idx
%
9
=
=
=
3
?
f
:
-
idx
idx
%
9
=
=
=
4
?
f
:
idx
idx
%
9
=
=
=
5
?
f
:
-
idx
]
[
idx
%
9
=
=
=
6
?
f
:
idx
idx
%
9
=
=
=
7
?
f
:
-
idx
idx
%
9
=
=
=
8
?
f
:
idx
]
]
)
4
:
kInterestingF16Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
12
=
=
=
0
?
f
:
idx
idx
%
12
=
=
=
1
?
f
:
-
idx
idx
%
12
=
=
=
2
?
f
:
idx
idx
%
12
=
=
=
3
?
f
:
-
idx
]
[
idx
%
12
=
=
=
4
?
f
:
-
idx
idx
%
12
=
=
=
5
?
f
:
idx
idx
%
12
=
=
=
6
?
f
:
-
idx
idx
%
12
=
=
=
7
?
f
:
idx
]
[
idx
%
12
=
=
=
8
?
f
:
idx
idx
%
12
=
=
=
9
?
f
:
-
idx
idx
%
12
=
=
=
10
?
f
:
idx
idx
%
12
=
=
=
11
?
f
:
-
idx
]
]
)
}
4
:
{
2
:
kInterestingF16Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
8
=
=
=
0
?
f
:
idx
idx
%
8
=
=
=
1
?
f
:
-
idx
]
[
idx
%
8
=
=
=
2
?
f
:
-
idx
idx
%
8
=
=
=
3
?
f
:
idx
]
[
idx
%
8
=
=
=
4
?
f
:
idx
idx
%
8
=
=
=
5
?
f
:
-
idx
]
[
idx
%
8
=
=
=
6
?
f
:
-
idx
idx
%
8
=
=
=
7
?
f
:
idx
]
]
)
3
:
kInterestingF16Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
12
=
=
=
0
?
f
:
idx
idx
%
12
=
=
=
1
?
f
:
-
idx
idx
%
12
=
=
=
2
?
f
:
idx
]
[
idx
%
12
=
=
=
3
?
f
:
-
idx
idx
%
12
=
=
=
4
?
f
:
idx
idx
%
12
=
=
=
5
?
f
:
-
idx
]
[
idx
%
12
=
=
=
6
?
f
:
idx
idx
%
12
=
=
=
7
?
f
:
-
idx
idx
%
12
=
=
=
8
?
f
:
idx
]
[
idx
%
12
=
=
=
9
?
f
:
-
idx
idx
%
12
=
=
=
10
?
f
:
idx
idx
%
12
=
=
=
11
?
f
:
-
idx
]
]
)
4
:
kInterestingF16Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
16
=
=
=
0
?
f
:
idx
idx
%
16
=
=
=
1
?
f
:
-
idx
idx
%
16
=
=
=
2
?
f
:
idx
idx
%
16
=
=
=
3
?
f
:
-
idx
]
[
idx
%
16
=
=
=
4
?
f
:
-
idx
idx
%
16
=
=
=
5
?
f
:
idx
idx
%
16
=
=
=
6
?
f
:
-
idx
idx
%
16
=
=
=
7
?
f
:
idx
]
[
idx
%
16
=
=
=
8
?
f
:
idx
idx
%
16
=
=
=
9
?
f
:
-
idx
idx
%
16
=
=
=
10
?
f
:
idx
idx
%
16
=
=
=
11
?
f
:
-
idx
]
[
idx
%
16
=
=
=
12
?
f
:
-
idx
idx
%
16
=
=
=
13
?
f
:
idx
idx
%
16
=
=
=
14
?
f
:
-
idx
idx
%
16
=
=
=
15
?
f
:
idx
]
]
)
}
}
;
export
function
sparseMatrixF16Range
(
c
:
number
r
:
number
)
:
ROArrayArray
<
number
>
[
]
{
assert
(
c
=
=
=
2
|
|
c
=
=
=
3
|
|
c
=
=
=
4
'
sparseMatrixF16Range
only
accepts
column
counts
of
2
3
and
4
'
)
;
assert
(
r
=
=
=
2
|
|
r
=
=
=
3
|
|
r
=
=
=
4
'
sparseMatrixF16Range
only
accepts
row
counts
of
2
3
and
4
'
)
;
return
kSparseMatrixF16Values
[
c
]
[
r
]
;
}
const
kInterestingF64Values
:
readonly
number
[
]
=
[
kValue
.
f64
.
negative
.
min
-
10
.
0
-
1
.
0
-
0
.
125
kValue
.
f64
.
negative
.
max
kValue
.
f64
.
negative
.
subnormal
.
min
kValue
.
f64
.
negative
.
subnormal
.
max
-
0
.
0
0
.
0
kValue
.
f64
.
positive
.
subnormal
.
min
kValue
.
f64
.
positive
.
subnormal
.
max
kValue
.
f64
.
positive
.
min
0
.
125
1
.
0
10
.
0
kValue
.
f64
.
positive
.
max
]
;
export
function
sparseScalarF64Range
(
)
:
readonly
number
[
]
{
return
kInterestingF64Values
;
}
const
kVectorF64Values
=
{
2
:
kInterestingF64Values
.
flatMap
(
f
=
>
[
[
f
1
.
0
]
[
-
1
.
0
f
]
]
)
3
:
kInterestingF64Values
.
flatMap
(
f
=
>
[
[
f
1
.
0
-
2
.
0
]
[
-
1
.
0
f
2
.
0
]
[
1
.
0
-
2
.
0
f
]
]
)
4
:
kInterestingF64Values
.
flatMap
(
f
=
>
[
[
f
-
1
.
0
2
.
0
3
.
0
]
[
1
.
0
f
-
2
.
0
3
.
0
]
[
1
.
0
2
.
0
f
-
3
.
0
]
[
-
1
.
0
2
.
0
-
3
.
0
f
]
]
)
}
;
export
function
vectorF64Range
(
dim
:
number
)
:
ROArrayArray
<
number
>
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
vectorF64Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kVectorF64Values
[
dim
]
;
}
const
kSparseVectorF64Values
=
{
2
:
sparseScalarF64Range
(
)
.
map
(
(
f
idx
)
=
>
[
idx
%
2
=
=
=
0
?
f
:
idx
idx
%
2
=
=
=
1
?
f
:
-
idx
]
)
3
:
sparseScalarF64Range
(
)
.
map
(
(
f
idx
)
=
>
[
idx
%
3
=
=
=
0
?
f
:
idx
idx
%
3
=
=
=
1
?
f
:
-
idx
idx
%
3
=
=
=
2
?
f
:
idx
]
)
4
:
sparseScalarF64Range
(
)
.
map
(
(
f
idx
)
=
>
[
idx
%
4
=
=
=
0
?
f
:
idx
idx
%
4
=
=
=
1
?
f
:
-
idx
idx
%
4
=
=
=
2
?
f
:
idx
idx
%
4
=
=
=
3
?
f
:
-
idx
]
)
}
;
export
function
sparseVectorF64Range
(
dim
:
number
)
:
ROArrayArray
<
number
>
{
assert
(
dim
=
=
=
2
|
|
dim
=
=
=
3
|
|
dim
=
=
=
4
'
sparseVectorF64Range
only
accepts
dimensions
2
3
and
4
'
)
;
return
kSparseVectorF64Values
[
dim
]
;
}
const
kSparseMatrixF64Values
=
{
2
:
{
2
:
kInterestingF64Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
4
=
=
=
0
?
f
:
idx
idx
%
4
=
=
=
1
?
f
:
-
idx
]
[
idx
%
4
=
=
=
2
?
f
:
-
idx
idx
%
4
=
=
=
3
?
f
:
idx
]
]
)
3
:
kInterestingF64Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
6
=
=
=
0
?
f
:
idx
idx
%
6
=
=
=
1
?
f
:
-
idx
idx
%
6
=
=
=
2
?
f
:
idx
]
[
idx
%
6
=
=
=
3
?
f
:
-
idx
idx
%
6
=
=
=
4
?
f
:
idx
idx
%
6
=
=
=
5
?
f
:
-
idx
]
]
)
4
:
kInterestingF64Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
8
=
=
=
0
?
f
:
idx
idx
%
8
=
=
=
1
?
f
:
-
idx
idx
%
8
=
=
=
2
?
f
:
idx
idx
%
8
=
=
=
3
?
f
:
-
idx
]
[
idx
%
8
=
=
=
4
?
f
:
-
idx
idx
%
8
=
=
=
5
?
f
:
idx
idx
%
8
=
=
=
6
?
f
:
-
idx
idx
%
8
=
=
=
7
?
f
:
idx
]
]
)
}
3
:
{
2
:
kInterestingF64Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
6
=
=
=
0
?
f
:
idx
idx
%
6
=
=
=
1
?
f
:
-
idx
]
[
idx
%
6
=
=
=
2
?
f
:
-
idx
idx
%
6
=
=
=
3
?
f
:
idx
]
[
idx
%
6
=
=
=
4
?
f
:
idx
idx
%
6
=
=
=
5
?
f
:
-
idx
]
]
)
3
:
kInterestingF64Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
9
=
=
=
0
?
f
:
idx
idx
%
9
=
=
=
1
?
f
:
-
idx
idx
%
9
=
=
=
2
?
f
:
idx
]
[
idx
%
9
=
=
=
3
?
f
:
-
idx
idx
%
9
=
=
=
4
?
f
:
idx
idx
%
9
=
=
=
5
?
f
:
-
idx
]
[
idx
%
9
=
=
=
6
?
f
:
idx
idx
%
9
=
=
=
7
?
f
:
-
idx
idx
%
9
=
=
=
8
?
f
:
idx
]
]
)
4
:
kInterestingF64Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
12
=
=
=
0
?
f
:
idx
idx
%
12
=
=
=
1
?
f
:
-
idx
idx
%
12
=
=
=
2
?
f
:
idx
idx
%
12
=
=
=
3
?
f
:
-
idx
]
[
idx
%
12
=
=
=
4
?
f
:
-
idx
idx
%
12
=
=
=
5
?
f
:
idx
idx
%
12
=
=
=
6
?
f
:
-
idx
idx
%
12
=
=
=
7
?
f
:
idx
]
[
idx
%
12
=
=
=
8
?
f
:
idx
idx
%
12
=
=
=
9
?
f
:
-
idx
idx
%
12
=
=
=
10
?
f
:
idx
idx
%
12
=
=
=
11
?
f
:
-
idx
]
]
)
}
4
:
{
2
:
kInterestingF64Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
8
=
=
=
0
?
f
:
idx
idx
%
8
=
=
=
1
?
f
:
-
idx
]
[
idx
%
8
=
=
=
2
?
f
:
-
idx
idx
%
8
=
=
=
3
?
f
:
idx
]
[
idx
%
8
=
=
=
4
?
f
:
idx
idx
%
8
=
=
=
5
?
f
:
-
idx
]
[
idx
%
8
=
=
=
6
?
f
:
-
idx
idx
%
8
=
=
=
7
?
f
:
idx
]
]
)
3
:
kInterestingF64Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
12
=
=
=
0
?
f
:
idx
idx
%
12
=
=
=
1
?
f
:
-
idx
idx
%
12
=
=
=
2
?
f
:
idx
]
[
idx
%
12
=
=
=
3
?
f
:
-
idx
idx
%
12
=
=
=
4
?
f
:
idx
idx
%
12
=
=
=
5
?
f
:
-
idx
]
[
idx
%
12
=
=
=
6
?
f
:
idx
idx
%
12
=
=
=
7
?
f
:
-
idx
idx
%
12
=
=
=
8
?
f
:
idx
]
[
idx
%
12
=
=
=
9
?
f
:
-
idx
idx
%
12
=
=
=
10
?
f
:
idx
idx
%
12
=
=
=
11
?
f
:
-
idx
]
]
)
4
:
kInterestingF64Values
.
map
(
(
f
idx
)
=
>
[
[
idx
%
16
=
=
=
0
?
f
:
idx
idx
%
16
=
=
=
1
?
f
:
-
idx
idx
%
16
=
=
=
2
?
f
:
idx
idx
%
16
=
=
=
3
?
f
:
-
idx
]
[
idx
%
16
=
=
=
4
?
f
:
-
idx
idx
%
16
=
=
=
5
?
f
:
idx
idx
%
16
=
=
=
6
?
f
:
-
idx
idx
%
16
=
=
=
7
?
f
:
idx
]
[
idx
%
16
=
=
=
8
?
f
:
idx
idx
%
16
=
=
=
9
?
f
:
-
idx
idx
%
16
=
=
=
10
?
f
:
idx
idx
%
16
=
=
=
11
?
f
:
-
idx
]
[
idx
%
16
=
=
=
12
?
f
:
-
idx
idx
%
16
=
=
=
13
?
f
:
idx
idx
%
16
=
=
=
14
?
f
:
-
idx
idx
%
16
=
=
=
15
?
f
:
idx
]
]
)
}
}
;
export
function
sparseMatrixF64Range
(
cols
:
number
rows
:
number
)
:
ROArrayArrayArray
<
number
>
{
assert
(
cols
=
=
=
2
|
|
cols
=
=
=
3
|
|
cols
=
=
=
4
'
sparseMatrixF64Range
only
accepts
column
counts
of
2
3
and
4
'
)
;
assert
(
rows
=
=
=
2
|
|
rows
=
=
=
3
|
|
rows
=
=
=
4
'
sparseMatrixF64Range
only
accepts
row
counts
of
2
3
and
4
'
)
;
return
kSparseMatrixF64Values
[
cols
]
[
rows
]
;
}
export
function
multiplyMatrices
(
A
:
Array
<
Array
<
number
>
>
B
:
Array
<
Array
<
number
>
>
)
:
Array
<
Array
<
number
>
>
{
assert
(
A
.
length
>
0
&
&
B
.
length
>
0
&
&
B
[
0
]
.
length
>
0
&
&
A
[
0
]
.
length
=
=
=
B
.
length
)
;
const
product
=
new
Array
<
Array
<
number
>
>
(
A
.
length
)
;
for
(
let
i
=
0
;
i
<
product
.
length
;
+
+
i
)
{
product
[
i
]
=
new
Array
<
number
>
(
B
[
0
]
.
length
)
.
fill
(
0
)
;
}
for
(
let
m
=
0
;
m
<
A
.
length
;
+
+
m
)
{
for
(
let
p
=
0
;
p
<
B
[
0
]
.
length
;
+
+
p
)
{
for
(
let
n
=
0
;
n
<
B
.
length
;
+
+
n
)
{
product
[
m
]
[
p
]
+
=
A
[
m
]
[
n
]
*
B
[
n
]
[
p
]
;
}
}
}
return
product
;
}
export
function
signExtend
(
n
:
number
bits
:
number
)
:
number
{
const
shift
=
32
-
bits
;
return
(
n
<
<
shift
)
>
>
shift
;
}
export
interface
QuantizeFunc
<
T
>
{
(
num
:
T
)
:
T
;
}
export
function
quantizeToF32
(
num
:
number
)
:
number
{
return
Math
.
fround
(
num
)
;
}
export
function
quantizeToF16
(
num
:
number
)
:
number
{
return
hfround
(
num
)
;
}
export
function
quantizeToI32
(
num
:
number
)
:
number
{
if
(
num
>
=
kValue
.
i32
.
positive
.
max
)
{
return
kValue
.
i32
.
positive
.
max
;
}
if
(
num
<
=
kValue
.
i32
.
negative
.
min
)
{
return
kValue
.
i32
.
negative
.
min
;
}
return
Math
.
trunc
(
num
)
;
}
export
function
quantizeToU32
(
num
:
number
)
:
number
{
if
(
num
>
=
kValue
.
u32
.
max
)
{
return
kValue
.
u32
.
max
;
}
if
(
num
<
=
0
)
{
return
0
;
}
return
Math
.
trunc
(
num
)
;
}
export
function
quantizeToI64
(
num
:
bigint
)
:
bigint
{
if
(
num
>
=
kValue
.
i64
.
positive
.
max
)
{
return
kValue
.
i64
.
positive
.
max
;
}
if
(
num
<
=
kValue
.
i64
.
negative
.
min
)
{
return
kValue
.
i64
.
negative
.
min
;
}
return
num
;
}
export
function
isPowerOfTwo
(
n
:
number
)
:
boolean
{
if
(
!
Number
.
isInteger
(
n
)
)
{
return
false
;
}
assert
(
(
n
|
0
)
=
=
=
n
'
isPowerOfTwo
only
supports
32
-
bit
numbers
'
)
;
return
n
!
=
=
0
&
&
(
n
&
(
n
-
1
)
)
=
=
=
0
;
}
export
function
gcd
(
a
:
number
b
:
number
)
:
number
{
assert
(
Number
.
isInteger
(
a
)
&
&
a
>
0
)
;
assert
(
Number
.
isInteger
(
b
)
&
&
b
>
0
)
;
while
(
b
!
=
=
0
)
{
const
bTemp
=
b
;
b
=
a
%
b
;
a
=
bTemp
;
}
return
a
;
}
export
function
lcm
(
a
:
number
b
:
number
)
:
number
{
return
(
a
*
b
)
/
gcd
(
a
b
)
;
}
function
cartesianProductImpl
<
T
>
(
elements
:
readonly
T
[
]
intermediate
:
ROArrayArray
<
T
>
)
:
ROArrayArray
<
T
>
{
const
result
:
T
[
]
[
]
=
[
]
;
elements
.
forEach
(
(
e
:
T
)
=
>
{
if
(
intermediate
.
length
>
0
)
{
intermediate
.
forEach
(
(
i
:
readonly
T
[
]
)
=
>
{
result
.
push
(
[
.
.
.
i
e
]
)
;
}
)
;
}
else
{
result
.
push
(
[
e
]
)
;
}
}
)
;
return
result
;
}
export
function
cartesianProduct
<
T
>
(
.
.
.
inputs
:
ROArrayArray
<
T
>
)
:
ROArrayArray
<
T
>
{
let
result
:
ROArrayArray
<
T
>
=
[
]
;
inputs
.
forEach
(
(
i
:
readonly
T
[
]
)
=
>
{
result
=
cartesianProductImpl
<
T
>
(
i
result
)
;
}
)
;
return
result
;
}
export
function
calculatePermutations
<
T
>
(
input
:
readonly
T
[
]
)
:
ROArrayArray
<
T
>
{
if
(
input
.
length
=
=
=
0
)
{
return
[
]
;
}
if
(
input
.
length
=
=
=
1
)
{
return
[
input
]
;
}
if
(
input
.
length
=
=
=
2
)
{
return
[
input
[
input
[
1
]
input
[
0
]
]
]
;
}
const
result
:
T
[
]
[
]
=
[
]
;
input
.
forEach
(
(
head
idx
)
=
>
{
const
tail
=
input
.
slice
(
0
idx
)
.
concat
(
input
.
slice
(
idx
+
1
)
)
;
const
permutations
=
calculatePermutations
(
tail
)
;
permutations
.
forEach
(
p
=
>
{
result
.
push
(
[
head
.
.
.
p
]
)
;
}
)
;
}
)
;
return
result
;
}
export
function
flatten2DArray
<
T
>
(
m
:
ROArrayArray
<
T
>
)
:
T
[
]
{
const
c
=
m
.
length
;
const
r
=
m
[
0
]
.
length
;
assert
(
m
.
every
(
c
=
>
c
.
length
=
=
=
r
)
Unexpectedly
received
jagged
array
to
flatten
)
;
const
result
:
T
[
]
=
Array
<
T
>
(
c
*
r
)
;
for
(
let
i
=
0
;
i
<
c
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
r
;
j
+
+
)
{
result
[
j
+
i
*
r
]
=
m
[
i
]
[
j
]
;
}
}
return
result
;
}
export
function
unflatten2DArray
<
T
>
(
n
:
readonly
T
[
]
c
:
number
r
:
number
)
:
ROArrayArray
<
T
>
{
assert
(
c
>
0
&
&
Number
.
isInteger
(
c
)
&
&
r
>
0
&
&
Number
.
isInteger
(
r
)
columns
(
{
c
}
)
and
rows
(
{
r
}
)
need
to
be
positive
integers
)
;
assert
(
n
.
length
=
=
=
c
*
r
m
.
length
(
{
n
.
length
}
)
should
equal
c
*
r
(
{
c
*
r
}
)
)
;
const
result
:
T
[
]
[
]
=
[
.
.
.
Array
(
c
)
]
.
map
(
_
=
>
[
.
.
.
Array
(
r
)
]
)
;
for
(
let
i
=
0
;
i
<
c
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
r
;
j
+
+
)
{
result
[
i
]
[
j
]
=
n
[
j
+
i
*
r
]
;
}
}
return
result
;
}
export
function
map2DArray
<
T
S
>
(
m
:
ROArrayArray
<
T
>
op
:
(
input
:
T
)
=
>
S
)
:
ROArrayArray
<
S
>
{
const
c
=
m
.
length
;
const
r
=
m
[
0
]
.
length
;
assert
(
m
.
every
(
c
=
>
c
.
length
=
=
=
r
)
Unexpectedly
received
jagged
array
to
map
)
;
const
result
:
S
[
]
[
]
=
[
.
.
.
Array
(
c
)
]
.
map
(
_
=
>
[
.
.
.
Array
(
r
)
]
)
;
for
(
let
i
=
0
;
i
<
c
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
r
;
j
+
+
)
{
result
[
i
]
[
j
]
=
op
(
m
[
i
]
[
j
]
)
;
}
}
return
result
;
}
export
function
every2DArray
<
T
>
(
m
:
ROArrayArray
<
T
>
op
:
(
input
:
T
)
=
>
boolean
)
:
boolean
{
const
r
=
m
[
0
]
.
length
;
assert
(
m
.
every
(
c
=
>
c
.
length
=
=
=
r
)
Unexpectedly
received
jagged
array
to
map
)
;
return
m
.
every
(
col
=
>
col
.
every
(
el
=
>
op
(
el
)
)
)
;
}
export
function
subtractVectors
(
v1
:
readonly
number
[
]
v2
:
readonly
number
[
]
)
{
return
v1
.
map
(
(
v
i
)
=
>
v
-
v2
[
i
]
)
;
}
export
function
dotProduct
(
v1
:
readonly
number
[
]
v2
:
readonly
number
[
]
)
{
return
v1
.
reduce
(
(
a
v
i
)
=
>
a
+
v
*
v2
[
i
]
0
)
;
}
export
function
absBigInt
(
v
:
bigint
)
:
bigint
{
return
v
<
0n
?
-
v
:
v
;
}
export
function
maxBigInt
(
.
.
.
vals
:
bigint
[
]
)
:
bigint
{
return
vals
.
reduce
(
(
prev
cur
)
=
>
(
cur
>
prev
?
cur
:
prev
)
)
;
}
export
function
minBigInt
(
.
.
.
vals
:
bigint
[
]
)
:
bigint
{
return
vals
.
reduce
(
(
prev
cur
)
=
>
(
cur
<
prev
?
cur
:
prev
)
)
;
}
