import
{
keysOf
makeTable
numericKeysOf
valueof
}
from
'
.
.
/
common
/
util
/
data_tables
.
js
'
;
import
{
assertTypeTrue
TypeEqual
}
from
'
.
.
/
common
/
util
/
types
.
js
'
;
import
{
unreachable
}
from
'
.
.
/
common
/
util
/
util
.
js
'
;
import
{
GPUConst
kMaxUnsignedLongValue
kMaxUnsignedLongLongValue
}
from
'
.
/
constants
.
js
'
;
export
const
kMaxQueryCount
=
4096
;
export
type
QueryTypeInfo
=
{
readonly
feature
:
GPUFeatureName
|
undefined
;
}
;
export
const
kQueryTypeInfo
:
{
readonly
[
k
in
GPUQueryType
]
:
QueryTypeInfo
;
}
=
{
'
occlusion
'
:
{
feature
:
undefined
}
'
timestamp
'
:
{
feature
:
'
timestamp
-
query
'
}
}
;
export
const
kQueryTypes
=
keysOf
(
kQueryTypeInfo
)
;
export
const
kBufferSizeAlignment
=
4
;
export
const
kBufferUsageCopyInfo
:
{
readonly
[
name
:
string
]
:
GPUBufferUsageFlags
;
}
=
{
'
COPY_NONE
'
:
0
'
COPY_SRC
'
:
GPUConst
.
BufferUsage
.
COPY_SRC
'
COPY_DST
'
:
GPUConst
.
BufferUsage
.
COPY_DST
'
COPY_SRC_DST
'
:
GPUConst
.
BufferUsage
.
COPY_SRC
|
GPUConst
.
BufferUsage
.
COPY_DST
}
;
export
const
kBufferUsageCopy
=
keysOf
(
kBufferUsageCopyInfo
)
;
type
BufferUsageKey
=
keyof
typeof
GPUConst
.
BufferUsage
;
export
const
kBufferUsageKeys
=
keysOf
(
GPUConst
.
BufferUsage
)
;
export
const
kBufferUsageInfo
:
{
readonly
[
k
in
BufferUsageKey
]
:
GPUBufferUsageFlags
;
}
=
{
.
.
.
GPUConst
.
BufferUsage
}
;
export
const
kBufferUsages
=
Object
.
values
(
GPUConst
.
BufferUsage
)
;
export
const
kAllBufferUsageBits
=
kBufferUsages
.
reduce
(
(
previousSet
currentUsage
)
=
>
previousSet
|
currentUsage
0
)
;
export
const
kErrorScopeFilterInfo
:
{
readonly
[
k
in
GPUErrorFilter
]
:
{
generatable
:
boolean
;
}
;
}
=
{
'
internal
'
:
{
generatable
:
false
}
'
out
-
of
-
memory
'
:
{
generatable
:
true
}
'
validation
'
:
{
generatable
:
true
}
}
;
export
const
kErrorScopeFilters
=
keysOf
(
kErrorScopeFilterInfo
)
;
export
const
kGeneratableErrorScopeFilters
=
kErrorScopeFilters
.
filter
(
e
=
>
kErrorScopeFilterInfo
[
e
]
.
generatable
)
;
export
const
kCanvasTextureFormats
=
[
'
bgra8unorm
'
'
rgba8unorm
'
'
rgba16float
'
]
as
const
;
export
const
kCanvasAlphaModesInfo
:
{
readonly
[
k
in
GPUCanvasAlphaMode
]
:
{
}
;
}
=
{
'
opaque
'
:
{
}
'
premultiplied
'
:
{
}
}
;
export
const
kCanvasAlphaModes
=
keysOf
(
kCanvasAlphaModesInfo
)
;
export
const
kCanvasColorSpacesInfo
:
{
readonly
[
k
in
PredefinedColorSpace
]
:
{
}
;
}
=
{
'
srgb
'
:
{
}
'
display
-
p3
'
:
{
}
}
;
export
const
kCanvasColorSpaces
=
keysOf
(
kCanvasColorSpacesInfo
)
;
export
const
kTextureDimensionInfo
:
{
readonly
[
k
in
GPUTextureDimension
]
:
{
}
;
}
=
{
'
1d
'
:
{
}
'
2d
'
:
{
}
'
3d
'
:
{
}
}
;
export
const
kTextureDimensions
=
keysOf
(
kTextureDimensionInfo
)
;
export
const
kTextureAspectInfo
:
{
readonly
[
k
in
GPUTextureAspect
]
:
{
}
;
}
=
{
'
all
'
:
{
}
'
depth
-
only
'
:
{
}
'
stencil
-
only
'
:
{
}
}
;
export
const
kTextureAspects
=
keysOf
(
kTextureAspectInfo
)
;
export
const
kCompareFunctionInfo
:
{
readonly
[
k
in
GPUCompareFunction
]
:
{
}
;
}
=
{
'
never
'
:
{
}
'
less
'
:
{
}
'
equal
'
:
{
}
'
less
-
equal
'
:
{
}
'
greater
'
:
{
}
'
not
-
equal
'
:
{
}
'
greater
-
equal
'
:
{
}
'
always
'
:
{
}
}
;
export
const
kCompareFunctions
=
keysOf
(
kCompareFunctionInfo
)
;
export
const
kStencilOperationInfo
:
{
readonly
[
k
in
GPUStencilOperation
]
:
{
}
;
}
=
{
'
keep
'
:
{
}
'
zero
'
:
{
}
'
replace
'
:
{
}
'
invert
'
:
{
}
'
increment
-
clamp
'
:
{
}
'
decrement
-
clamp
'
:
{
}
'
increment
-
wrap
'
:
{
}
'
decrement
-
wrap
'
:
{
}
}
;
export
const
kStencilOperations
=
keysOf
(
kStencilOperationInfo
)
;
export
const
kTextureUsageTypeInfo
:
{
readonly
[
name
:
string
]
:
number
;
}
=
{
'
texture
'
:
Number
(
GPUConst
.
TextureUsage
.
TEXTURE_BINDING
)
'
storage
'
:
Number
(
GPUConst
.
TextureUsage
.
STORAGE_BINDING
)
'
render
'
:
Number
(
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
)
}
;
export
const
kTextureUsageType
=
keysOf
(
kTextureUsageTypeInfo
)
;
export
const
kTextureUsageCopyInfo
:
{
readonly
[
name
:
string
]
:
number
;
}
=
{
'
none
'
:
0
'
src
'
:
Number
(
GPUConst
.
TextureUsage
.
COPY_SRC
)
'
dst
'
:
Number
(
GPUConst
.
TextureUsage
.
COPY_DST
)
'
src
-
dest
'
:
Number
(
GPUConst
.
TextureUsage
.
COPY_SRC
)
|
Number
(
GPUConst
.
TextureUsage
.
COPY_DST
)
}
;
export
const
kTextureUsageCopy
=
keysOf
(
kTextureUsageCopyInfo
)
;
export
const
kTextureUsageInfo
:
{
readonly
[
k
in
valueof
<
typeof
GPUConst
.
TextureUsage
>
]
:
{
}
;
}
=
{
[
GPUConst
.
TextureUsage
.
COPY_SRC
]
:
{
}
[
GPUConst
.
TextureUsage
.
COPY_DST
]
:
{
}
[
GPUConst
.
TextureUsage
.
TEXTURE_BINDING
]
:
{
}
[
GPUConst
.
TextureUsage
.
STORAGE_BINDING
]
:
{
}
[
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
]
:
{
}
}
;
export
const
kTextureUsages
=
numericKeysOf
<
GPUTextureUsageFlags
>
(
kTextureUsageInfo
)
;
export
type
TextureViewDimensionInfo
=
{
readonly
storage
:
boolean
;
}
;
export
const
kTextureViewDimensionInfo
:
{
readonly
[
k
in
GPUTextureViewDimension
]
:
TextureViewDimensionInfo
;
}
=
{
'
1d
'
:
{
storage
:
true
}
'
2d
'
:
{
storage
:
true
}
'
2d
-
array
'
:
{
storage
:
true
}
'
cube
'
:
{
storage
:
false
}
'
cube
-
array
'
:
{
storage
:
false
}
'
3d
'
:
{
storage
:
true
}
}
;
export
const
kTextureViewDimensions
=
keysOf
(
kTextureViewDimensionInfo
)
;
export
type
VertexFormatInfo
=
{
readonly
bytesPerComponent
:
1
|
2
|
4
;
readonly
type
:
'
float
'
|
'
unorm
'
|
'
snorm
'
|
'
uint
'
|
'
sint
'
;
readonly
componentCount
:
1
|
2
|
3
|
4
;
readonly
wgslType
:
|
'
f32
'
|
'
vec2
<
f32
>
'
|
'
vec3
<
f32
>
'
|
'
vec4
<
f32
>
'
|
'
u32
'
|
'
vec2
<
u32
>
'
|
'
vec3
<
u32
>
'
|
'
vec4
<
u32
>
'
|
'
i32
'
|
'
vec2
<
i32
>
'
|
'
vec3
<
i32
>
'
|
'
vec4
<
i32
>
'
;
}
;
export
const
kVertexFormatInfo
:
{
readonly
[
k
in
GPUVertexFormat
]
:
VertexFormatInfo
;
}
=
makeTable
(
[
'
bytesPerComponent
'
'
type
'
'
componentCount
'
'
wgslType
'
]
as
const
[
]
as
const
{
'
uint8x2
'
:
[
1
'
uint
'
2
'
vec2
<
u32
>
'
]
'
uint8x4
'
:
[
1
'
uint
'
4
'
vec4
<
u32
>
'
]
'
sint8x2
'
:
[
1
'
sint
'
2
'
vec2
<
i32
>
'
]
'
sint8x4
'
:
[
1
'
sint
'
4
'
vec4
<
i32
>
'
]
'
unorm8x2
'
:
[
1
'
unorm
'
2
'
vec2
<
f32
>
'
]
'
unorm8x4
'
:
[
1
'
unorm
'
4
'
vec4
<
f32
>
'
]
'
snorm8x2
'
:
[
1
'
snorm
'
2
'
vec2
<
f32
>
'
]
'
snorm8x4
'
:
[
1
'
snorm
'
4
'
vec4
<
f32
>
'
]
'
uint16x2
'
:
[
2
'
uint
'
2
'
vec2
<
u32
>
'
]
'
uint16x4
'
:
[
2
'
uint
'
4
'
vec4
<
u32
>
'
]
'
sint16x2
'
:
[
2
'
sint
'
2
'
vec2
<
i32
>
'
]
'
sint16x4
'
:
[
2
'
sint
'
4
'
vec4
<
i32
>
'
]
'
unorm16x2
'
:
[
2
'
unorm
'
2
'
vec2
<
f32
>
'
]
'
unorm16x4
'
:
[
2
'
unorm
'
4
'
vec4
<
f32
>
'
]
'
snorm16x2
'
:
[
2
'
snorm
'
2
'
vec2
<
f32
>
'
]
'
snorm16x4
'
:
[
2
'
snorm
'
4
'
vec4
<
f32
>
'
]
'
float16x2
'
:
[
2
'
float
'
2
'
vec2
<
f32
>
'
]
'
float16x4
'
:
[
2
'
float
'
4
'
vec4
<
f32
>
'
]
'
float32
'
:
[
4
'
float
'
1
'
f32
'
]
'
float32x2
'
:
[
4
'
float
'
2
'
vec2
<
f32
>
'
]
'
float32x3
'
:
[
4
'
float
'
3
'
vec3
<
f32
>
'
]
'
float32x4
'
:
[
4
'
float
'
4
'
vec4
<
f32
>
'
]
'
uint32
'
:
[
4
'
uint
'
1
'
u32
'
]
'
uint32x2
'
:
[
4
'
uint
'
2
'
vec2
<
u32
>
'
]
'
uint32x3
'
:
[
4
'
uint
'
3
'
vec3
<
u32
>
'
]
'
uint32x4
'
:
[
4
'
uint
'
4
'
vec4
<
u32
>
'
]
'
sint32
'
:
[
4
'
sint
'
1
'
i32
'
]
'
sint32x2
'
:
[
4
'
sint
'
2
'
vec2
<
i32
>
'
]
'
sint32x3
'
:
[
4
'
sint
'
3
'
vec3
<
i32
>
'
]
'
sint32x4
'
:
[
4
'
sint
'
4
'
vec4
<
i32
>
'
]
}
as
const
)
;
export
const
kVertexFormats
=
keysOf
(
kVertexFormatInfo
)
;
export
type
PerStageBindingLimitClass
=
|
'
uniformBuf
'
|
'
storageBuf
'
|
'
sampler
'
|
'
sampledTex
'
|
'
storageTex
'
;
export
type
PerPipelineBindingLimitClass
=
PerStageBindingLimitClass
;
export
type
ValidBindableResource
=
|
'
uniformBuf
'
|
'
storageBuf
'
|
'
filtSamp
'
|
'
nonFiltSamp
'
|
'
compareSamp
'
|
'
sampledTex
'
|
'
sampledTexMS
'
|
'
storageTex
'
;
type
ErrorBindableResource
=
'
errorBuf
'
|
'
errorSamp
'
|
'
errorTex
'
;
export
type
BindableResource
=
ValidBindableResource
|
ErrorBindableResource
;
export
const
kBindableResources
=
[
'
uniformBuf
'
'
storageBuf
'
'
filtSamp
'
'
nonFiltSamp
'
'
compareSamp
'
'
sampledTex
'
'
sampledTexMS
'
'
storageTex
'
'
errorBuf
'
'
errorSamp
'
'
errorTex
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
BindableResource
typeof
kBindableResources
[
number
]
>
>
(
)
;
export
const
kMinDynamicBufferOffsetAlignment
=
256
;
export
const
kPerStageBindingLimits
:
{
readonly
[
k
in
PerStageBindingLimitClass
]
:
{
readonly
class
:
k
;
readonly
max
:
number
;
}
;
}
=
{
'
uniformBuf
'
:
{
class
:
'
uniformBuf
'
max
:
12
}
'
storageBuf
'
:
{
class
:
'
storageBuf
'
max
:
8
}
'
sampler
'
:
{
class
:
'
sampler
'
max
:
16
}
'
sampledTex
'
:
{
class
:
'
sampledTex
'
max
:
16
}
'
storageTex
'
:
{
class
:
'
storageTex
'
max
:
4
}
}
;
export
const
kPerPipelineBindingLimits
:
{
readonly
[
k
in
PerPipelineBindingLimitClass
]
:
{
readonly
class
:
k
;
readonly
maxDynamic
:
number
;
}
;
}
=
{
'
uniformBuf
'
:
{
class
:
'
uniformBuf
'
maxDynamic
:
8
}
'
storageBuf
'
:
{
class
:
'
storageBuf
'
maxDynamic
:
4
}
'
sampler
'
:
{
class
:
'
sampler
'
maxDynamic
:
0
}
'
sampledTex
'
:
{
class
:
'
sampledTex
'
maxDynamic
:
0
}
'
storageTex
'
:
{
class
:
'
storageTex
'
maxDynamic
:
0
}
}
;
interface
BindingKindInfo
{
readonly
resource
:
ValidBindableResource
;
readonly
perStageLimitClass
:
typeof
kPerStageBindingLimits
[
PerStageBindingLimitClass
]
;
readonly
perPipelineLimitClass
:
typeof
kPerPipelineBindingLimits
[
PerPipelineBindingLimitClass
]
;
}
const
kBindingKind
:
{
readonly
[
k
in
ValidBindableResource
]
:
BindingKindInfo
;
}
=
{
uniformBuf
:
{
resource
:
'
uniformBuf
'
perStageLimitClass
:
kPerStageBindingLimits
.
uniformBuf
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
uniformBuf
}
storageBuf
:
{
resource
:
'
storageBuf
'
perStageLimitClass
:
kPerStageBindingLimits
.
storageBuf
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
storageBuf
}
filtSamp
:
{
resource
:
'
filtSamp
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampler
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampler
}
nonFiltSamp
:
{
resource
:
'
nonFiltSamp
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampler
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampler
}
compareSamp
:
{
resource
:
'
compareSamp
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampler
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampler
}
sampledTex
:
{
resource
:
'
sampledTex
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampledTex
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampledTex
}
sampledTexMS
:
{
resource
:
'
sampledTexMS
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampledTex
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampledTex
}
storageTex
:
{
resource
:
'
storageTex
'
perStageLimitClass
:
kPerStageBindingLimits
.
storageTex
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
storageTex
}
}
;
const
kValidStagesAll
=
{
validStages
:
GPUConst
.
ShaderStage
.
VERTEX
|
GPUConst
.
ShaderStage
.
FRAGMENT
|
GPUConst
.
ShaderStage
.
COMPUTE
}
as
const
;
const
kValidStagesStorageWrite
=
{
validStages
:
GPUConst
.
ShaderStage
.
FRAGMENT
|
GPUConst
.
ShaderStage
.
COMPUTE
}
as
const
;
export
function
bufferBindingTypeInfo
(
d
:
GPUBufferBindingLayout
)
{
switch
(
d
.
type
?
?
'
uniform
'
)
{
case
'
uniform
'
:
return
{
usage
:
GPUConst
.
BufferUsage
.
UNIFORM
.
.
.
kBindingKind
.
uniformBuf
.
.
.
kValidStagesAll
}
;
case
'
storage
'
:
return
{
usage
:
GPUConst
.
BufferUsage
.
STORAGE
.
.
.
kBindingKind
.
storageBuf
.
.
.
kValidStagesStorageWrite
}
;
case
'
read
-
only
-
storage
'
:
return
{
usage
:
GPUConst
.
BufferUsage
.
STORAGE
.
.
.
kBindingKind
.
storageBuf
.
.
.
kValidStagesAll
}
;
}
}
export
const
kBufferBindingTypes
=
[
'
uniform
'
'
storage
'
'
read
-
only
-
storage
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
GPUBufferBindingType
typeof
kBufferBindingTypes
[
number
]
>
>
(
)
;
export
function
samplerBindingTypeInfo
(
d
:
GPUSamplerBindingLayout
)
{
switch
(
d
.
type
?
?
'
filtering
'
)
{
case
'
filtering
'
:
return
{
.
.
.
kBindingKind
.
filtSamp
.
.
.
kValidStagesAll
}
;
case
'
non
-
filtering
'
:
return
{
.
.
.
kBindingKind
.
nonFiltSamp
.
.
.
kValidStagesAll
}
;
case
'
comparison
'
:
return
{
.
.
.
kBindingKind
.
compareSamp
.
.
.
kValidStagesAll
}
;
}
}
export
const
kSamplerBindingTypes
=
[
'
filtering
'
'
non
-
filtering
'
'
comparison
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
GPUSamplerBindingType
typeof
kSamplerBindingTypes
[
number
]
>
>
(
)
;
export
function
sampledTextureBindingTypeInfo
(
d
:
GPUTextureBindingLayout
)
{
if
(
d
.
multisampled
)
{
return
{
usage
:
GPUConst
.
TextureUsage
.
TEXTURE_BINDING
.
.
.
kBindingKind
.
sampledTexMS
.
.
.
kValidStagesAll
}
;
}
else
{
return
{
usage
:
GPUConst
.
TextureUsage
.
TEXTURE_BINDING
.
.
.
kBindingKind
.
sampledTex
.
.
.
kValidStagesAll
}
;
}
}
export
const
kTextureSampleTypes
=
[
'
float
'
'
unfilterable
-
float
'
'
depth
'
'
sint
'
'
uint
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
GPUTextureSampleType
typeof
kTextureSampleTypes
[
number
]
>
>
(
)
;
export
function
storageTextureBindingTypeInfo
(
d
:
GPUStorageTextureBindingLayout
)
{
return
{
usage
:
GPUConst
.
TextureUsage
.
STORAGE_BINDING
.
.
.
kBindingKind
.
storageTex
.
.
.
kValidStagesStorageWrite
}
;
}
export
const
kStorageTextureAccessValues
=
[
'
write
-
only
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
GPUStorageTextureAccess
typeof
kStorageTextureAccessValues
[
number
]
>
>
(
)
;
export
type
BGLEntry
=
Omit
<
GPUBindGroupLayoutEntry
'
binding
'
|
'
visibility
'
>
;
export
function
texBindingTypeInfo
(
e
:
BGLEntry
)
{
if
(
e
.
texture
!
=
=
undefined
)
return
sampledTextureBindingTypeInfo
(
e
.
texture
)
;
if
(
e
.
storageTexture
!
=
=
undefined
)
return
storageTextureBindingTypeInfo
(
e
.
storageTexture
)
;
unreachable
(
)
;
}
export
function
bindingTypeInfo
(
e
:
BGLEntry
)
{
if
(
e
.
buffer
!
=
=
undefined
)
return
bufferBindingTypeInfo
(
e
.
buffer
)
;
if
(
e
.
texture
!
=
=
undefined
)
return
sampledTextureBindingTypeInfo
(
e
.
texture
)
;
if
(
e
.
sampler
!
=
=
undefined
)
return
samplerBindingTypeInfo
(
e
.
sampler
)
;
if
(
e
.
storageTexture
!
=
=
undefined
)
return
storageTextureBindingTypeInfo
(
e
.
storageTexture
)
;
unreachable
(
'
GPUBindGroupLayoutEntry
has
no
BindingLayout
'
)
;
}
export
function
bufferBindingEntries
(
includeUndefined
:
boolean
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
(
includeUndefined
?
[
{
buffer
:
{
type
:
undefined
}
}
]
:
[
]
)
{
buffer
:
{
type
:
'
uniform
'
}
}
{
buffer
:
{
type
:
'
storage
'
}
}
{
buffer
:
{
type
:
'
read
-
only
-
storage
'
}
}
]
as
const
;
}
export
function
samplerBindingEntries
(
includeUndefined
:
boolean
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
(
includeUndefined
?
[
{
sampler
:
{
type
:
undefined
}
}
]
:
[
]
)
{
sampler
:
{
type
:
'
comparison
'
}
}
{
sampler
:
{
type
:
'
filtering
'
}
}
{
sampler
:
{
type
:
'
non
-
filtering
'
}
}
]
as
const
;
}
export
function
textureBindingEntries
(
includeUndefined
:
boolean
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
(
includeUndefined
?
[
{
texture
:
{
multisampled
:
undefined
}
}
]
:
[
]
)
{
texture
:
{
multisampled
:
false
}
}
{
texture
:
{
multisampled
:
true
sampleType
:
'
unfilterable
-
float
'
}
}
]
as
const
;
}
export
function
storageTextureBindingEntries
(
format
:
GPUTextureFormat
)
:
readonly
BGLEntry
[
]
{
return
[
{
storageTexture
:
{
access
:
'
write
-
only
'
format
}
}
]
as
const
;
}
export
function
sampledAndStorageBindingEntries
(
includeUndefined
:
boolean
storageTextureFormat
:
GPUTextureFormat
=
'
rgba8unorm
'
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
textureBindingEntries
(
includeUndefined
)
.
.
.
storageTextureBindingEntries
(
storageTextureFormat
)
]
as
const
;
}
export
function
allBindingEntries
(
includeUndefined
:
boolean
storageTextureFormat
:
GPUTextureFormat
=
'
rgba8unorm
'
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
bufferBindingEntries
(
includeUndefined
)
.
.
.
samplerBindingEntries
(
includeUndefined
)
.
.
.
sampledAndStorageBindingEntries
(
includeUndefined
storageTextureFormat
)
]
as
const
;
}
export
type
ShaderStageKey
=
keyof
typeof
GPUConst
.
ShaderStage
;
export
const
kShaderStageKeys
=
Object
.
keys
(
GPUConst
.
ShaderStage
)
as
ShaderStageKey
[
]
;
export
const
kShaderStages
:
readonly
GPUShaderStageFlags
[
]
=
[
GPUConst
.
ShaderStage
.
VERTEX
GPUConst
.
ShaderStage
.
FRAGMENT
GPUConst
.
ShaderStage
.
COMPUTE
]
;
export
const
kShaderStageCombinations
:
readonly
GPUShaderStageFlags
[
]
=
[
0
1
2
3
4
5
6
7
]
;
export
const
kShaderStageCombinationsWithStage
:
readonly
GPUShaderStageFlags
[
]
=
[
1
2
3
4
5
6
7
]
;
export
const
kTextureSampleCounts
=
[
1
4
]
as
const
;
export
const
kMipmapFilterModes
:
readonly
GPUMipmapFilterMode
[
]
=
[
'
nearest
'
'
linear
'
]
;
assertTypeTrue
<
TypeEqual
<
GPUMipmapFilterMode
typeof
kMipmapFilterModes
[
number
]
>
>
(
)
;
export
const
kAddressModes
:
readonly
GPUAddressMode
[
]
=
[
'
clamp
-
to
-
edge
'
'
repeat
'
'
mirror
-
repeat
'
]
;
assertTypeTrue
<
TypeEqual
<
GPUAddressMode
typeof
kAddressModes
[
number
]
>
>
(
)
;
export
const
kBlendFactors
:
readonly
GPUBlendFactor
[
]
=
[
'
zero
'
'
one
'
'
src
'
'
one
-
minus
-
src
'
'
src
-
alpha
'
'
one
-
minus
-
src
-
alpha
'
'
dst
'
'
one
-
minus
-
dst
'
'
dst
-
alpha
'
'
one
-
minus
-
dst
-
alpha
'
'
src
-
alpha
-
saturated
'
'
constant
'
'
one
-
minus
-
constant
'
]
;
export
const
kBlendOperations
:
readonly
GPUBlendOperation
[
]
=
[
'
add
'
'
subtract
'
'
reverse
-
subtract
'
'
min
'
'
max
'
]
;
export
const
kPrimitiveTopology
:
readonly
GPUPrimitiveTopology
[
]
=
[
'
point
-
list
'
'
line
-
list
'
'
line
-
strip
'
'
triangle
-
list
'
'
triangle
-
strip
'
]
;
assertTypeTrue
<
TypeEqual
<
GPUPrimitiveTopology
typeof
kPrimitiveTopology
[
number
]
>
>
(
)
;
export
const
kIndexFormat
:
readonly
GPUIndexFormat
[
]
=
[
'
uint16
'
'
uint32
'
]
;
assertTypeTrue
<
TypeEqual
<
GPUIndexFormat
typeof
kIndexFormat
[
number
]
>
>
(
)
;
export
const
kLimitInfo
=
makeTable
(
[
'
class
'
'
default
'
'
maximumValue
'
]
as
const
[
'
maximum
'
kMaxUnsignedLongValue
]
as
const
{
'
maxTextureDimension1D
'
:
[
8192
]
'
maxTextureDimension2D
'
:
[
8192
]
'
maxTextureDimension3D
'
:
[
2048
]
'
maxTextureArrayLayers
'
:
[
256
]
'
maxBindGroups
'
:
[
4
]
'
maxBindingsPerBindGroup
'
:
[
1000
]
'
maxDynamicUniformBuffersPerPipelineLayout
'
:
[
8
]
'
maxDynamicStorageBuffersPerPipelineLayout
'
:
[
4
]
'
maxSampledTexturesPerShaderStage
'
:
[
16
]
'
maxSamplersPerShaderStage
'
:
[
16
]
'
maxStorageBuffersPerShaderStage
'
:
[
8
]
'
maxStorageTexturesPerShaderStage
'
:
[
4
]
'
maxUniformBuffersPerShaderStage
'
:
[
12
]
'
maxUniformBufferBindingSize
'
:
[
65536
kMaxUnsignedLongLongValue
]
'
maxStorageBufferBindingSize
'
:
[
134217728
kMaxUnsignedLongLongValue
]
'
minUniformBufferOffsetAlignment
'
:
[
'
alignment
'
256
]
'
minStorageBufferOffsetAlignment
'
:
[
'
alignment
'
256
]
'
maxVertexBuffers
'
:
[
8
]
'
maxBufferSize
'
:
[
268435456
kMaxUnsignedLongLongValue
]
'
maxVertexAttributes
'
:
[
16
]
'
maxVertexBufferArrayStride
'
:
[
2048
]
'
maxInterStageShaderComponents
'
:
[
60
]
'
maxInterStageShaderVariables
'
:
[
16
]
'
maxColorAttachments
'
:
[
8
]
'
maxColorAttachmentBytesPerSample
'
:
[
32
]
'
maxComputeWorkgroupStorageSize
'
:
[
16384
]
'
maxComputeInvocationsPerWorkgroup
'
:
[
256
]
'
maxComputeWorkgroupSizeX
'
:
[
256
]
'
maxComputeWorkgroupSizeY
'
:
[
256
]
'
maxComputeWorkgroupSizeZ
'
:
[
64
]
'
maxComputeWorkgroupsPerDimension
'
:
[
65535
]
}
as
const
)
;
export
const
kLimits
=
keysOf
(
kLimitInfo
)
;
export
const
kMaxColorAttachments
=
kLimitInfo
.
maxColorAttachments
.
default
;
export
const
kMaxVertexBuffers
=
kLimitInfo
.
maxVertexBuffers
.
default
;
export
const
kMaxVertexAttributes
=
kLimitInfo
.
maxVertexAttributes
.
default
;
export
const
kMaxVertexBufferArrayStride
=
kLimitInfo
.
maxVertexBufferArrayStride
.
default
;
export
const
kDrawIndirectParametersSize
=
4
;
export
const
kDrawIndexedIndirectParametersSize
=
5
;
export
const
kFeatureNameInfo
:
{
readonly
[
k
in
GPUFeatureName
]
:
{
}
;
}
=
{
'
bgra8unorm
-
storage
'
:
{
}
'
depth
-
clip
-
control
'
:
{
}
'
depth32float
-
stencil8
'
:
{
}
'
texture
-
compression
-
bc
'
:
{
}
'
texture
-
compression
-
etc2
'
:
{
}
'
texture
-
compression
-
astc
'
:
{
}
'
timestamp
-
query
'
:
{
}
'
indirect
-
first
-
instance
'
:
{
}
'
shader
-
f16
'
:
{
}
'
rg11b10ufloat
-
renderable
'
:
{
}
'
float32
-
filterable
'
:
{
}
}
;
export
const
kFeatureNames
=
keysOf
(
kFeatureNameInfo
)
;
