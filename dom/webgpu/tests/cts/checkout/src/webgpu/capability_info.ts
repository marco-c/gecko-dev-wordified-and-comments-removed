import
{
globalTestConfig
}
from
'
.
.
/
common
/
framework
/
test_config
.
js
'
;
import
{
keysOf
makeTable
makeTableRenameAndFilter
numericKeysOf
valueof
}
from
'
.
.
/
common
/
util
/
data_tables
.
js
'
;
import
{
assertTypeTrue
TypeEqual
}
from
'
.
.
/
common
/
util
/
types
.
js
'
;
import
{
unreachable
}
from
'
.
.
/
common
/
util
/
util
.
js
'
;
import
{
GPUConst
kMaxUnsignedLongValue
kMaxUnsignedLongLongValue
}
from
'
.
/
constants
.
js
'
;
export
const
kMaxQueryCount
=
4096
;
export
type
QueryTypeInfo
=
{
readonly
feature
:
GPUFeatureName
|
undefined
;
}
;
export
const
kQueryTypeInfo
:
{
readonly
[
k
in
GPUQueryType
]
:
QueryTypeInfo
;
}
=
{
'
occlusion
'
:
{
feature
:
undefined
}
'
timestamp
'
:
{
feature
:
'
timestamp
-
query
'
}
}
;
export
const
kQueryTypes
=
keysOf
(
kQueryTypeInfo
)
;
export
const
kBufferSizeAlignment
=
4
;
export
const
kBufferUsageCopyInfo
:
{
readonly
[
name
:
string
]
:
GPUBufferUsageFlags
;
}
=
{
'
COPY_NONE
'
:
0
'
COPY_SRC
'
:
GPUConst
.
BufferUsage
.
COPY_SRC
'
COPY_DST
'
:
GPUConst
.
BufferUsage
.
COPY_DST
'
COPY_SRC_DST
'
:
GPUConst
.
BufferUsage
.
COPY_SRC
|
GPUConst
.
BufferUsage
.
COPY_DST
}
;
export
const
kBufferUsageCopy
=
keysOf
(
kBufferUsageCopyInfo
)
;
type
BufferUsageKey
=
keyof
typeof
GPUConst
.
BufferUsage
;
export
const
kBufferUsageKeys
=
keysOf
(
GPUConst
.
BufferUsage
)
;
export
const
kBufferUsageInfo
:
{
readonly
[
k
in
BufferUsageKey
]
:
GPUBufferUsageFlags
;
}
=
{
.
.
.
GPUConst
.
BufferUsage
}
;
export
const
kBufferUsages
=
Object
.
values
(
GPUConst
.
BufferUsage
)
;
export
const
kAllBufferUsageBits
=
kBufferUsages
.
reduce
(
(
previousSet
currentUsage
)
=
>
previousSet
|
currentUsage
0
)
;
export
const
kErrorScopeFilterInfo
:
{
readonly
[
k
in
GPUErrorFilter
]
:
{
generatable
:
boolean
;
}
;
}
=
{
'
internal
'
:
{
generatable
:
false
}
'
out
-
of
-
memory
'
:
{
generatable
:
true
}
'
validation
'
:
{
generatable
:
true
}
}
;
export
const
kErrorScopeFilters
=
keysOf
(
kErrorScopeFilterInfo
)
;
export
const
kGeneratableErrorScopeFilters
=
kErrorScopeFilters
.
filter
(
e
=
>
kErrorScopeFilterInfo
[
e
]
.
generatable
)
;
export
const
kCanvasTextureFormats
=
[
'
bgra8unorm
'
'
rgba8unorm
'
'
rgba16float
'
]
as
const
;
export
const
kCanvasAlphaModesInfo
:
{
readonly
[
k
in
GPUCanvasAlphaMode
]
:
{
}
;
}
=
{
'
opaque
'
:
{
}
'
premultiplied
'
:
{
}
}
;
export
const
kCanvasAlphaModes
=
keysOf
(
kCanvasAlphaModesInfo
)
;
export
const
kCanvasColorSpacesInfo
:
{
readonly
[
k
in
PredefinedColorSpace
]
:
{
}
;
}
=
{
'
srgb
'
:
{
}
'
display
-
p3
'
:
{
}
}
;
export
const
kCanvasColorSpaces
=
keysOf
(
kCanvasColorSpacesInfo
)
;
export
const
kTextureDimensionInfo
:
{
readonly
[
k
in
GPUTextureDimension
]
:
{
}
;
}
=
{
'
1d
'
:
{
}
'
2d
'
:
{
}
'
3d
'
:
{
}
}
;
export
const
kTextureDimensions
=
keysOf
(
kTextureDimensionInfo
)
;
export
const
kTextureAspectInfo
:
{
readonly
[
k
in
GPUTextureAspect
]
:
{
}
;
}
=
{
'
all
'
:
{
}
'
depth
-
only
'
:
{
}
'
stencil
-
only
'
:
{
}
}
;
export
const
kTextureAspects
=
keysOf
(
kTextureAspectInfo
)
;
export
const
kCompareFunctionInfo
:
{
readonly
[
k
in
GPUCompareFunction
]
:
{
}
;
}
=
{
'
never
'
:
{
}
'
less
'
:
{
}
'
equal
'
:
{
}
'
less
-
equal
'
:
{
}
'
greater
'
:
{
}
'
not
-
equal
'
:
{
}
'
greater
-
equal
'
:
{
}
'
always
'
:
{
}
}
;
export
const
kCompareFunctions
=
keysOf
(
kCompareFunctionInfo
)
;
export
const
kStencilOperationInfo
:
{
readonly
[
k
in
GPUStencilOperation
]
:
{
}
;
}
=
{
'
keep
'
:
{
}
'
zero
'
:
{
}
'
replace
'
:
{
}
'
invert
'
:
{
}
'
increment
-
clamp
'
:
{
}
'
decrement
-
clamp
'
:
{
}
'
increment
-
wrap
'
:
{
}
'
decrement
-
wrap
'
:
{
}
}
;
export
const
kStencilOperations
=
keysOf
(
kStencilOperationInfo
)
;
export
const
kTextureUsageTypeInfo
:
{
readonly
[
name
:
string
]
:
number
;
}
=
{
'
texture
'
:
Number
(
GPUConst
.
TextureUsage
.
TEXTURE_BINDING
)
'
storage
'
:
Number
(
GPUConst
.
TextureUsage
.
STORAGE_BINDING
)
'
render
'
:
Number
(
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
)
}
;
export
const
kTextureUsageType
=
keysOf
(
kTextureUsageTypeInfo
)
;
export
const
kTextureUsageCopyInfo
:
{
readonly
[
name
:
string
]
:
number
;
}
=
{
'
none
'
:
0
'
src
'
:
Number
(
GPUConst
.
TextureUsage
.
COPY_SRC
)
'
dst
'
:
Number
(
GPUConst
.
TextureUsage
.
COPY_DST
)
'
src
-
dest
'
:
Number
(
GPUConst
.
TextureUsage
.
COPY_SRC
)
|
Number
(
GPUConst
.
TextureUsage
.
COPY_DST
)
}
;
export
const
kTextureUsageCopy
=
keysOf
(
kTextureUsageCopyInfo
)
;
export
const
kTextureUsageInfo
:
{
readonly
[
k
in
valueof
<
typeof
GPUConst
.
TextureUsage
>
]
:
{
}
;
}
=
{
[
GPUConst
.
TextureUsage
.
COPY_SRC
]
:
{
}
[
GPUConst
.
TextureUsage
.
COPY_DST
]
:
{
}
[
GPUConst
.
TextureUsage
.
TEXTURE_BINDING
]
:
{
}
[
GPUConst
.
TextureUsage
.
STORAGE_BINDING
]
:
{
}
[
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
]
:
{
}
}
;
export
const
kTextureUsages
=
numericKeysOf
<
GPUTextureUsageFlags
>
(
kTextureUsageInfo
)
;
export
type
TextureViewDimensionInfo
=
{
readonly
storage
:
boolean
;
}
;
export
const
kTextureViewDimensionInfo
:
{
readonly
[
k
in
GPUTextureViewDimension
]
:
TextureViewDimensionInfo
;
}
=
{
'
1d
'
:
{
storage
:
true
}
'
2d
'
:
{
storage
:
true
}
'
2d
-
array
'
:
{
storage
:
true
}
'
cube
'
:
{
storage
:
false
}
'
cube
-
array
'
:
{
storage
:
false
}
'
3d
'
:
{
storage
:
true
}
}
;
export
const
kTextureViewDimensions
=
keysOf
(
kTextureViewDimensionInfo
)
;
export
type
VertexFormatInfo
=
{
readonly
bytesPerComponent
:
1
|
2
|
4
|
'
packed
'
;
readonly
type
:
'
float
'
|
'
unorm
'
|
'
snorm
'
|
'
uint
'
|
'
sint
'
;
readonly
componentCount
:
1
|
2
|
3
|
4
;
readonly
byteSize
:
1
|
2
|
4
|
8
|
12
|
16
;
readonly
wgslType
:
|
'
f32
'
|
'
vec2
<
f32
>
'
|
'
vec3
<
f32
>
'
|
'
vec4
<
f32
>
'
|
'
u32
'
|
'
vec2
<
u32
>
'
|
'
vec3
<
u32
>
'
|
'
vec4
<
u32
>
'
|
'
i32
'
|
'
vec2
<
i32
>
'
|
'
vec3
<
i32
>
'
|
'
vec4
<
i32
>
'
;
}
;
export
const
kVertexFormatInfo
:
{
readonly
[
k
in
GPUVertexFormat
]
:
VertexFormatInfo
;
}
=
makeTable
(
[
'
bytesPerComponent
'
'
type
'
'
componentCount
'
'
byteSize
'
'
wgslType
'
]
as
const
[
]
as
const
{
'
uint8
'
:
[
1
'
uint
'
1
1
'
u32
'
]
'
uint8x2
'
:
[
1
'
uint
'
2
2
'
vec2
<
u32
>
'
]
'
uint8x4
'
:
[
1
'
uint
'
4
4
'
vec4
<
u32
>
'
]
'
sint8
'
:
[
1
'
sint
'
1
1
'
i32
'
]
'
sint8x2
'
:
[
1
'
sint
'
2
2
'
vec2
<
i32
>
'
]
'
sint8x4
'
:
[
1
'
sint
'
4
4
'
vec4
<
i32
>
'
]
'
unorm8
'
:
[
1
'
unorm
'
1
1
'
f32
'
]
'
unorm8x2
'
:
[
1
'
unorm
'
2
2
'
vec2
<
f32
>
'
]
'
unorm8x4
'
:
[
1
'
unorm
'
4
4
'
vec4
<
f32
>
'
]
'
snorm8
'
:
[
1
'
snorm
'
1
1
'
f32
'
]
'
snorm8x2
'
:
[
1
'
snorm
'
2
2
'
vec2
<
f32
>
'
]
'
snorm8x4
'
:
[
1
'
snorm
'
4
4
'
vec4
<
f32
>
'
]
'
uint16
'
:
[
2
'
uint
'
1
2
'
u32
'
]
'
uint16x2
'
:
[
2
'
uint
'
2
4
'
vec2
<
u32
>
'
]
'
uint16x4
'
:
[
2
'
uint
'
4
8
'
vec4
<
u32
>
'
]
'
sint16
'
:
[
2
'
sint
'
1
2
'
i32
'
]
'
sint16x2
'
:
[
2
'
sint
'
2
4
'
vec2
<
i32
>
'
]
'
sint16x4
'
:
[
2
'
sint
'
4
8
'
vec4
<
i32
>
'
]
'
unorm16
'
:
[
2
'
unorm
'
1
2
'
f32
'
]
'
unorm16x2
'
:
[
2
'
unorm
'
2
4
'
vec2
<
f32
>
'
]
'
unorm16x4
'
:
[
2
'
unorm
'
4
8
'
vec4
<
f32
>
'
]
'
snorm16
'
:
[
2
'
snorm
'
1
2
'
f32
'
]
'
snorm16x2
'
:
[
2
'
snorm
'
2
4
'
vec2
<
f32
>
'
]
'
snorm16x4
'
:
[
2
'
snorm
'
4
8
'
vec4
<
f32
>
'
]
'
float16
'
:
[
2
'
float
'
1
2
'
f32
'
]
'
float16x2
'
:
[
2
'
float
'
2
4
'
vec2
<
f32
>
'
]
'
float16x4
'
:
[
2
'
float
'
4
8
'
vec4
<
f32
>
'
]
'
float32
'
:
[
4
'
float
'
1
4
'
f32
'
]
'
float32x2
'
:
[
4
'
float
'
2
8
'
vec2
<
f32
>
'
]
'
float32x3
'
:
[
4
'
float
'
3
12
'
vec3
<
f32
>
'
]
'
float32x4
'
:
[
4
'
float
'
4
16
'
vec4
<
f32
>
'
]
'
uint32
'
:
[
4
'
uint
'
1
4
'
u32
'
]
'
uint32x2
'
:
[
4
'
uint
'
2
8
'
vec2
<
u32
>
'
]
'
uint32x3
'
:
[
4
'
uint
'
3
12
'
vec3
<
u32
>
'
]
'
uint32x4
'
:
[
4
'
uint
'
4
16
'
vec4
<
u32
>
'
]
'
sint32
'
:
[
4
'
sint
'
1
4
'
i32
'
]
'
sint32x2
'
:
[
4
'
sint
'
2
8
'
vec2
<
i32
>
'
]
'
sint32x3
'
:
[
4
'
sint
'
3
12
'
vec3
<
i32
>
'
]
'
sint32x4
'
:
[
4
'
sint
'
4
16
'
vec4
<
i32
>
'
]
'
unorm10
-
10
-
10
-
2
'
:
[
'
packed
'
'
unorm
'
4
4
'
vec4
<
f32
>
'
]
'
unorm8x4
-
bgra
'
:
[
'
packed
'
'
unorm
'
4
4
'
vec4
<
f32
>
'
]
}
as
const
)
;
export
const
kVertexFormats
=
keysOf
(
kVertexFormatInfo
)
;
export
type
PerStageBindingLimitClass
=
|
'
uniformBuf
'
|
'
storageBuf
'
|
'
sampler
'
|
'
sampledTex
'
|
'
readonlyStorageTex
'
|
'
writeonlyStorageTex
'
|
'
readwriteStorageTex
'
;
export
type
PerPipelineBindingLimitClass
=
PerStageBindingLimitClass
;
export
type
ValidBindableResource
=
|
'
uniformBuf
'
|
'
storageBuf
'
|
'
filtSamp
'
|
'
nonFiltSamp
'
|
'
compareSamp
'
|
'
sampledTex
'
|
'
sampledTexMS
'
|
'
readonlyStorageTex
'
|
'
writeonlyStorageTex
'
|
'
readwriteStorageTex
'
;
type
ErrorBindableResource
=
'
errorBuf
'
|
'
errorSamp
'
|
'
errorTex
'
;
export
type
BindableResource
=
ValidBindableResource
|
ErrorBindableResource
;
export
const
kBindableResources
=
[
'
uniformBuf
'
'
storageBuf
'
'
filtSamp
'
'
nonFiltSamp
'
'
compareSamp
'
'
sampledTex
'
'
sampledTexMS
'
'
readonlyStorageTex
'
'
writeonlyStorageTex
'
'
readwriteStorageTex
'
'
errorBuf
'
'
errorSamp
'
'
errorTex
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
BindableResource
(
typeof
kBindableResources
)
[
number
]
>
>
(
)
;
export
const
kMinDynamicBufferOffsetAlignment
=
256
;
export
const
kPerStageBindingLimits
:
{
readonly
[
k
in
PerStageBindingLimitClass
]
:
{
readonly
class
:
k
;
readonly
maxLimits
:
{
[
key
in
ShaderStageKey
]
:
(
typeof
kPossibleLimits
)
[
number
]
}
;
}
;
}
=
{
'
uniformBuf
'
:
{
class
:
'
uniformBuf
'
maxLimits
:
{
COMPUTE
:
'
maxUniformBuffersPerShaderStage
'
FRAGMENT
:
'
maxUniformBuffersPerShaderStage
'
VERTEX
:
'
maxUniformBuffersPerShaderStage
'
}
}
'
storageBuf
'
:
{
class
:
'
storageBuf
'
maxLimits
:
{
COMPUTE
:
'
maxStorageBuffersPerShaderStage
'
FRAGMENT
:
'
maxStorageBuffersPerShaderStage
'
VERTEX
:
'
maxStorageBuffersPerShaderStage
'
}
}
'
sampler
'
:
{
class
:
'
sampler
'
maxLimits
:
{
COMPUTE
:
'
maxSamplersPerShaderStage
'
FRAGMENT
:
'
maxSamplersPerShaderStage
'
VERTEX
:
'
maxSamplersPerShaderStage
'
}
}
'
sampledTex
'
:
{
class
:
'
sampledTex
'
maxLimits
:
{
COMPUTE
:
'
maxSampledTexturesPerShaderStage
'
FRAGMENT
:
'
maxSampledTexturesPerShaderStage
'
VERTEX
:
'
maxSampledTexturesPerShaderStage
'
}
}
'
readonlyStorageTex
'
:
{
class
:
'
readonlyStorageTex
'
maxLimits
:
{
COMPUTE
:
'
maxStorageTexturesPerShaderStage
'
FRAGMENT
:
'
maxStorageTexturesPerShaderStage
'
VERTEX
:
'
maxStorageTexturesPerShaderStage
'
}
}
'
writeonlyStorageTex
'
:
{
class
:
'
writeonlyStorageTex
'
maxLimits
:
{
COMPUTE
:
'
maxStorageTexturesPerShaderStage
'
FRAGMENT
:
'
maxStorageTexturesPerShaderStage
'
VERTEX
:
'
maxStorageTexturesPerShaderStage
'
}
}
'
readwriteStorageTex
'
:
{
class
:
'
readwriteStorageTex
'
maxLimits
:
{
COMPUTE
:
'
maxStorageTexturesPerShaderStage
'
FRAGMENT
:
'
maxStorageTexturesPerShaderStage
'
VERTEX
:
'
maxStorageTexturesPerShaderStage
'
}
}
}
;
export
const
kPerPipelineBindingLimits
:
{
readonly
[
k
in
PerPipelineBindingLimitClass
]
:
{
readonly
class
:
k
;
readonly
maxDynamicLimit
:
(
typeof
kPossibleLimits
)
[
number
]
|
'
'
;
}
;
}
=
{
'
uniformBuf
'
:
{
class
:
'
uniformBuf
'
maxDynamicLimit
:
'
maxDynamicUniformBuffersPerPipelineLayout
'
}
'
storageBuf
'
:
{
class
:
'
storageBuf
'
maxDynamicLimit
:
'
maxDynamicStorageBuffersPerPipelineLayout
'
}
'
sampler
'
:
{
class
:
'
sampler
'
maxDynamicLimit
:
'
'
}
'
sampledTex
'
:
{
class
:
'
sampledTex
'
maxDynamicLimit
:
'
'
}
'
readonlyStorageTex
'
:
{
class
:
'
readonlyStorageTex
'
maxDynamicLimit
:
'
'
}
'
writeonlyStorageTex
'
:
{
class
:
'
writeonlyStorageTex
'
maxDynamicLimit
:
'
'
}
'
readwriteStorageTex
'
:
{
class
:
'
readwriteStorageTex
'
maxDynamicLimit
:
'
'
}
}
;
interface
BindingKindInfo
{
readonly
resource
:
ValidBindableResource
;
readonly
perStageLimitClass
:
(
typeof
kPerStageBindingLimits
)
[
PerStageBindingLimitClass
]
;
readonly
perPipelineLimitClass
:
(
typeof
kPerPipelineBindingLimits
)
[
PerPipelineBindingLimitClass
]
;
}
const
kBindingKind
:
{
readonly
[
k
in
ValidBindableResource
]
:
BindingKindInfo
;
}
=
{
uniformBuf
:
{
resource
:
'
uniformBuf
'
perStageLimitClass
:
kPerStageBindingLimits
.
uniformBuf
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
uniformBuf
}
storageBuf
:
{
resource
:
'
storageBuf
'
perStageLimitClass
:
kPerStageBindingLimits
.
storageBuf
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
storageBuf
}
filtSamp
:
{
resource
:
'
filtSamp
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampler
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampler
}
nonFiltSamp
:
{
resource
:
'
nonFiltSamp
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampler
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampler
}
compareSamp
:
{
resource
:
'
compareSamp
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampler
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampler
}
sampledTex
:
{
resource
:
'
sampledTex
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampledTex
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampledTex
}
sampledTexMS
:
{
resource
:
'
sampledTexMS
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampledTex
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampledTex
}
readonlyStorageTex
:
{
resource
:
'
readonlyStorageTex
'
perStageLimitClass
:
kPerStageBindingLimits
.
readonlyStorageTex
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
readonlyStorageTex
}
writeonlyStorageTex
:
{
resource
:
'
writeonlyStorageTex
'
perStageLimitClass
:
kPerStageBindingLimits
.
writeonlyStorageTex
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
writeonlyStorageTex
}
readwriteStorageTex
:
{
resource
:
'
readwriteStorageTex
'
perStageLimitClass
:
kPerStageBindingLimits
.
readwriteStorageTex
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
readwriteStorageTex
}
}
;
const
kValidStagesAll
=
{
validStages
:
GPUConst
.
ShaderStage
.
VERTEX
|
GPUConst
.
ShaderStage
.
FRAGMENT
|
GPUConst
.
ShaderStage
.
COMPUTE
}
as
const
;
const
kValidStagesStorageWrite
=
{
validStages
:
GPUConst
.
ShaderStage
.
FRAGMENT
|
GPUConst
.
ShaderStage
.
COMPUTE
}
as
const
;
export
function
bufferBindingTypeInfo
(
d
:
GPUBufferBindingLayout
)
{
switch
(
d
.
type
?
?
'
uniform
'
)
{
case
'
uniform
'
:
return
{
usage
:
GPUConst
.
BufferUsage
.
UNIFORM
.
.
.
kBindingKind
.
uniformBuf
.
.
.
kValidStagesAll
}
;
case
'
storage
'
:
return
{
usage
:
GPUConst
.
BufferUsage
.
STORAGE
.
.
.
kBindingKind
.
storageBuf
.
.
.
kValidStagesStorageWrite
}
;
case
'
read
-
only
-
storage
'
:
return
{
usage
:
GPUConst
.
BufferUsage
.
STORAGE
.
.
.
kBindingKind
.
storageBuf
.
.
.
kValidStagesAll
}
;
}
}
export
const
kBufferBindingTypes
=
[
'
uniform
'
'
storage
'
'
read
-
only
-
storage
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
GPUBufferBindingType
(
typeof
kBufferBindingTypes
)
[
number
]
>
>
(
)
;
export
function
samplerBindingTypeInfo
(
d
:
GPUSamplerBindingLayout
)
{
switch
(
d
.
type
?
?
'
filtering
'
)
{
case
'
filtering
'
:
return
{
.
.
.
kBindingKind
.
filtSamp
.
.
.
kValidStagesAll
}
;
case
'
non
-
filtering
'
:
return
{
.
.
.
kBindingKind
.
nonFiltSamp
.
.
.
kValidStagesAll
}
;
case
'
comparison
'
:
return
{
.
.
.
kBindingKind
.
compareSamp
.
.
.
kValidStagesAll
}
;
}
}
export
const
kSamplerBindingTypes
=
[
'
filtering
'
'
non
-
filtering
'
'
comparison
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
GPUSamplerBindingType
(
typeof
kSamplerBindingTypes
)
[
number
]
>
>
(
)
;
export
function
sampledTextureBindingTypeInfo
(
d
:
GPUTextureBindingLayout
)
{
if
(
d
.
multisampled
)
{
return
{
usage
:
GPUConst
.
TextureUsage
.
TEXTURE_BINDING
.
.
.
kBindingKind
.
sampledTexMS
.
.
.
kValidStagesAll
}
;
}
else
{
return
{
usage
:
GPUConst
.
TextureUsage
.
TEXTURE_BINDING
.
.
.
kBindingKind
.
sampledTex
.
.
.
kValidStagesAll
}
;
}
}
export
const
kTextureSampleTypes
=
[
'
float
'
'
unfilterable
-
float
'
'
depth
'
'
sint
'
'
uint
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
GPUTextureSampleType
(
typeof
kTextureSampleTypes
)
[
number
]
>
>
(
)
;
export
function
storageTextureBindingTypeInfo
(
d
:
{
access
?
:
GPUStorageTextureAccess
|
undefined
}
)
{
switch
(
d
.
access
)
{
case
undefined
:
case
'
write
-
only
'
:
return
{
wgslAccess
:
'
write
'
usage
:
GPUConst
.
TextureUsage
.
STORAGE_BINDING
.
.
.
kBindingKind
.
writeonlyStorageTex
.
.
.
kValidStagesStorageWrite
}
;
case
'
read
-
only
'
:
return
{
wgslAccess
:
'
read
'
usage
:
GPUConst
.
TextureUsage
.
STORAGE_BINDING
.
.
.
kBindingKind
.
readonlyStorageTex
.
.
.
kValidStagesAll
}
;
case
'
read
-
write
'
:
return
{
wgslAccess
:
'
read_write
'
usage
:
GPUConst
.
TextureUsage
.
STORAGE_BINDING
.
.
.
kBindingKind
.
readwriteStorageTex
.
.
.
kValidStagesStorageWrite
}
;
}
}
export
const
kStorageTextureAccessValues
=
[
'
read
-
only
'
'
read
-
write
'
'
write
-
only
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
GPUStorageTextureAccess
(
typeof
kStorageTextureAccessValues
)
[
number
]
>
>
(
)
;
export
type
BGLEntry
=
Omit
<
GPUBindGroupLayoutEntry
'
binding
'
|
'
visibility
'
>
;
export
function
texBindingTypeInfo
(
e
:
BGLEntry
)
{
if
(
e
.
texture
!
=
=
undefined
)
return
sampledTextureBindingTypeInfo
(
e
.
texture
)
;
if
(
e
.
storageTexture
!
=
=
undefined
)
return
storageTextureBindingTypeInfo
(
e
.
storageTexture
)
;
unreachable
(
)
;
}
export
function
bindingTypeInfo
(
e
:
BGLEntry
)
{
if
(
e
.
buffer
!
=
=
undefined
)
return
bufferBindingTypeInfo
(
e
.
buffer
)
;
if
(
e
.
texture
!
=
=
undefined
)
return
sampledTextureBindingTypeInfo
(
e
.
texture
)
;
if
(
e
.
sampler
!
=
=
undefined
)
return
samplerBindingTypeInfo
(
e
.
sampler
)
;
if
(
e
.
storageTexture
!
=
=
undefined
)
return
storageTextureBindingTypeInfo
(
e
.
storageTexture
)
;
unreachable
(
'
GPUBindGroupLayoutEntry
has
no
BindingLayout
'
)
;
}
export
function
bufferBindingEntries
(
includeUndefined
:
boolean
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
(
includeUndefined
?
[
{
buffer
:
{
type
:
undefined
}
}
]
:
[
]
)
{
buffer
:
{
type
:
'
uniform
'
}
}
{
buffer
:
{
type
:
'
storage
'
}
}
{
buffer
:
{
type
:
'
read
-
only
-
storage
'
}
}
]
as
const
;
}
export
function
samplerBindingEntries
(
includeUndefined
:
boolean
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
(
includeUndefined
?
[
{
sampler
:
{
type
:
undefined
}
}
]
:
[
]
)
{
sampler
:
{
type
:
'
comparison
'
}
}
{
sampler
:
{
type
:
'
filtering
'
}
}
{
sampler
:
{
type
:
'
non
-
filtering
'
}
}
]
as
const
;
}
export
function
textureBindingEntries
(
includeUndefined
:
boolean
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
(
includeUndefined
?
[
{
texture
:
{
multisampled
:
undefined
sampleType
:
'
unfilterable
-
float
'
}
}
as
const
]
:
[
]
)
{
texture
:
{
multisampled
:
false
sampleType
:
'
unfilterable
-
float
'
}
}
{
texture
:
{
multisampled
:
true
sampleType
:
'
unfilterable
-
float
'
}
}
]
as
const
;
}
export
function
storageTextureBindingEntries
(
format
:
GPUTextureFormat
)
:
readonly
BGLEntry
[
]
{
return
[
{
storageTexture
:
{
access
:
'
write
-
only
'
format
}
}
{
storageTexture
:
{
access
:
'
read
-
only
'
format
}
}
{
storageTexture
:
{
access
:
'
read
-
write
'
format
}
}
]
as
const
;
}
export
function
sampledAndStorageBindingEntries
(
includeUndefined
:
boolean
format
:
GPUTextureFormat
=
'
r32float
'
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
textureBindingEntries
(
includeUndefined
)
.
.
.
storageTextureBindingEntries
(
format
)
]
as
const
;
}
export
function
allBindingEntries
(
includeUndefined
:
boolean
format
:
GPUTextureFormat
=
'
r32float
'
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
bufferBindingEntries
(
includeUndefined
)
.
.
.
samplerBindingEntries
(
includeUndefined
)
.
.
.
sampledAndStorageBindingEntries
(
includeUndefined
format
)
]
as
const
;
}
export
type
ShaderStageKey
=
keyof
typeof
GPUConst
.
ShaderStage
;
export
const
kShaderStageKeys
=
Object
.
keys
(
GPUConst
.
ShaderStage
)
as
ShaderStageKey
[
]
;
export
const
kShaderStages
:
readonly
GPUShaderStageFlags
[
]
=
[
GPUConst
.
ShaderStage
.
VERTEX
GPUConst
.
ShaderStage
.
FRAGMENT
GPUConst
.
ShaderStage
.
COMPUTE
]
;
export
const
kShaderStageCombinations
:
readonly
GPUShaderStageFlags
[
]
=
[
0
1
2
3
4
5
6
7
]
;
export
const
kShaderStageCombinationsWithStage
:
readonly
GPUShaderStageFlags
[
]
=
[
1
2
3
4
5
6
7
]
;
export
const
kTextureSampleCounts
=
[
1
4
]
as
const
;
export
const
kMipmapFilterModes
:
readonly
GPUMipmapFilterMode
[
]
=
[
'
nearest
'
'
linear
'
]
;
assertTypeTrue
<
TypeEqual
<
GPUMipmapFilterMode
(
typeof
kMipmapFilterModes
)
[
number
]
>
>
(
)
;
export
const
kAddressModes
:
readonly
GPUAddressMode
[
]
=
[
'
clamp
-
to
-
edge
'
'
repeat
'
'
mirror
-
repeat
'
]
;
assertTypeTrue
<
TypeEqual
<
GPUAddressMode
(
typeof
kAddressModes
)
[
number
]
>
>
(
)
;
export
const
kBlendFactors
:
readonly
GPUBlendFactor
[
]
=
[
'
zero
'
'
one
'
'
src
'
'
one
-
minus
-
src
'
'
src
-
alpha
'
'
one
-
minus
-
src
-
alpha
'
'
dst
'
'
one
-
minus
-
dst
'
'
dst
-
alpha
'
'
one
-
minus
-
dst
-
alpha
'
'
src
-
alpha
-
saturated
'
'
constant
'
'
one
-
minus
-
constant
'
'
src1
'
'
one
-
minus
-
src1
'
'
src1
-
alpha
'
'
one
-
minus
-
src1
-
alpha
'
]
;
export
function
IsDualSourceBlendingFactor
(
blendFactor
?
:
GPUBlendFactor
)
:
boolean
{
switch
(
blendFactor
)
{
case
'
src1
'
:
case
'
one
-
minus
-
src1
'
:
case
'
src1
-
alpha
'
:
case
'
one
-
minus
-
src1
-
alpha
'
:
return
true
;
default
:
return
false
;
}
}
export
const
kBlendOperations
:
readonly
GPUBlendOperation
[
]
=
[
'
add
'
'
subtract
'
'
reverse
-
subtract
'
'
min
'
'
max
'
]
;
export
const
kPrimitiveTopology
:
readonly
GPUPrimitiveTopology
[
]
=
[
'
point
-
list
'
'
line
-
list
'
'
line
-
strip
'
'
triangle
-
list
'
'
triangle
-
strip
'
]
;
assertTypeTrue
<
TypeEqual
<
GPUPrimitiveTopology
(
typeof
kPrimitiveTopology
)
[
number
]
>
>
(
)
;
export
const
kIndexFormat
:
readonly
GPUIndexFormat
[
]
=
[
'
uint16
'
'
uint32
'
]
;
assertTypeTrue
<
TypeEqual
<
GPUIndexFormat
(
typeof
kIndexFormat
)
[
number
]
>
>
(
)
;
const
[
kLimitInfoKeys
kLimitInfoDefaults
kLimitInfoData
]
=
[
[
'
class
'
'
core
'
'
compatibility
'
'
maximumValue
'
]
as
const
[
'
maximum
'
kMaxUnsignedLongValue
]
as
const
{
'
maxTextureDimension1D
'
:
[
8192
4096
]
'
maxTextureDimension2D
'
:
[
8192
4096
]
'
maxTextureDimension3D
'
:
[
2048
1024
]
'
maxTextureArrayLayers
'
:
[
256
256
]
'
maxBindGroups
'
:
[
4
4
]
'
maxBindGroupsPlusVertexBuffers
'
:
[
24
24
]
'
maxBindingsPerBindGroup
'
:
[
1000
1000
]
'
maxDynamicUniformBuffersPerPipelineLayout
'
:
[
8
8
]
'
maxDynamicStorageBuffersPerPipelineLayout
'
:
[
4
4
]
'
maxSampledTexturesPerShaderStage
'
:
[
16
16
]
'
maxSamplersPerShaderStage
'
:
[
16
16
]
'
maxStorageBuffersInFragmentStage
'
:
[
8
4
]
'
maxStorageBuffersInVertexStage
'
:
[
8
0
]
'
maxStorageBuffersPerShaderStage
'
:
[
8
8
]
'
maxStorageTexturesInFragmentStage
'
:
[
4
4
]
'
maxStorageTexturesInVertexStage
'
:
[
4
0
]
'
maxStorageTexturesPerShaderStage
'
:
[
4
4
]
'
maxUniformBuffersPerShaderStage
'
:
[
12
12
]
'
maxUniformBufferBindingSize
'
:
[
65536
16384
kMaxUnsignedLongLongValue
]
'
maxStorageBufferBindingSize
'
:
[
134217728
134217728
kMaxUnsignedLongLongValue
]
'
minUniformBufferOffsetAlignment
'
:
[
'
alignment
'
256
256
]
'
minStorageBufferOffsetAlignment
'
:
[
'
alignment
'
256
256
]
'
maxVertexBuffers
'
:
[
8
8
]
'
maxBufferSize
'
:
[
268435456
268435456
kMaxUnsignedLongLongValue
]
'
maxVertexAttributes
'
:
[
16
16
]
'
maxVertexBufferArrayStride
'
:
[
2048
2048
]
'
maxInterStageShaderVariables
'
:
[
16
15
]
'
maxColorAttachments
'
:
[
8
4
]
'
maxColorAttachmentBytesPerSample
'
:
[
32
32
]
'
maxComputeWorkgroupStorageSize
'
:
[
16384
16384
]
'
maxComputeInvocationsPerWorkgroup
'
:
[
256
128
]
'
maxComputeWorkgroupSizeX
'
:
[
256
128
]
'
maxComputeWorkgroupSizeY
'
:
[
256
128
]
'
maxComputeWorkgroupSizeZ
'
:
[
64
64
]
'
maxComputeWorkgroupsPerDimension
'
:
[
65535
65535
]
}
as
const
]
;
const
kCompatOnlyLimits
=
[
'
maxStorageTexturesInFragmentStage
'
'
maxStorageTexturesInVertexStage
'
'
maxStorageBuffersInFragmentStage
'
'
maxStorageBuffersInVertexStage
'
]
as
const
;
export
const
kFeatureLevels
=
[
'
core
'
'
compatibility
'
]
as
const
;
export
type
FeatureLevel
=
(
typeof
kFeatureLevels
)
[
number
]
;
const
kLimitKeys
=
[
'
class
'
'
default
'
'
maximumValue
'
]
as
const
;
const
kLimitInfoCore
=
makeTableRenameAndFilter
(
{
default
:
'
core
'
}
kLimitKeys
kLimitInfoKeys
kLimitInfoDefaults
kLimitInfoData
)
;
const
kLimitInfoCompatibility
=
makeTableRenameAndFilter
(
{
default
:
'
compatibility
'
}
kLimitKeys
kLimitInfoKeys
kLimitInfoDefaults
kLimitInfoData
)
;
const
kLimitInfos
=
{
core
:
kLimitInfoCore
compatibility
:
kLimitInfoCompatibility
}
as
const
;
export
const
kLimitClasses
=
Object
.
fromEntries
(
Object
.
entries
(
kLimitInfoCore
)
.
map
(
(
[
k
{
class
:
c
}
]
)
=
>
[
k
c
]
)
)
;
export
function
getDefaultLimits
(
featureLevel
:
FeatureLevel
)
{
return
Object
.
fromEntries
(
Object
.
entries
(
kLimitInfos
[
featureLevel
]
)
.
filter
(
(
[
k
]
)
=
>
{
return
featureLevel
=
=
=
'
core
'
?
!
kCompatOnlyLimits
.
includes
(
k
as
(
typeof
kCompatOnlyLimits
)
[
number
]
)
:
true
;
}
)
)
as
typeof
kLimitInfoCore
;
}
export
function
getDefaultLimitsForCTS
(
)
{
return
getDefaultLimits
(
globalTestConfig
.
compatibility
?
'
compatibility
'
:
'
core
'
)
;
}
export
function
getDefaultLimitsForDevice
(
device
:
GPUDevice
)
{
const
featureLevel
=
device
.
features
.
has
(
'
core
-
features
-
and
-
limits
'
)
?
'
core
'
:
'
compatibility
'
;
return
getDefaultLimits
(
featureLevel
)
;
}
const
kEachStage
=
[
GPUConst
.
ShaderStage
.
COMPUTE
GPUConst
.
ShaderStage
.
FRAGMENT
GPUConst
.
ShaderStage
.
VERTEX
]
;
function
shaderStageFlagToStageName
(
stage
:
GPUShaderStageFlags
)
{
switch
(
stage
)
{
case
GPUConst
.
ShaderStage
.
COMPUTE
:
return
'
COMPUTE
'
;
case
GPUConst
.
ShaderStage
.
FRAGMENT
:
return
'
FRAGMENT
'
;
case
GPUConst
.
ShaderStage
.
VERTEX
:
return
'
VERTEX
'
;
default
:
unreachable
(
)
;
}
}
export
function
getBindingLimitForBindingType
(
device
:
GPUDevice
visibility
:
GPUShaderStageFlags
e
:
BGLEntry
)
{
const
info
=
bindingTypeInfo
(
e
)
;
const
maxLimits
=
info
.
perStageLimitClass
.
maxLimits
;
const
limits
=
kEachStage
.
filter
(
stage
=
>
stage
&
visibility
)
.
map
(
stage
=
>
device
.
limits
[
maxLimits
[
shaderStageFlagToStageName
(
stage
)
]
]
!
)
;
return
limits
.
length
>
0
?
Math
.
min
(
.
.
.
limits
)
:
0
;
}
export
const
kPossibleLimits
=
keysOf
(
kLimitInfoCore
)
;
export
const
kMaxColorAttachmentsToTest
=
32
;
export
const
kDrawIndirectParametersSize
=
4
;
export
const
kDrawIndexedIndirectParametersSize
=
5
;
export
const
kFeatureNameInfo
:
{
readonly
[
k
in
GPUFeatureName
]
:
{
}
;
}
=
{
'
bgra8unorm
-
storage
'
:
{
}
'
depth
-
clip
-
control
'
:
{
}
'
depth32float
-
stencil8
'
:
{
}
'
texture
-
compression
-
bc
'
:
{
}
'
texture
-
compression
-
bc
-
sliced
-
3d
'
:
{
}
'
texture
-
compression
-
etc2
'
:
{
}
'
texture
-
compression
-
astc
'
:
{
}
'
texture
-
compression
-
astc
-
sliced
-
3d
'
:
{
}
'
timestamp
-
query
'
:
{
}
'
indirect
-
first
-
instance
'
:
{
}
'
shader
-
f16
'
:
{
}
'
rg11b10ufloat
-
renderable
'
:
{
}
'
float32
-
filterable
'
:
{
}
'
float32
-
blendable
'
:
{
}
'
clip
-
distances
'
:
{
}
'
dual
-
source
-
blending
'
:
{
}
'
subgroups
'
:
{
}
'
core
-
features
-
and
-
limits
'
:
{
}
'
texture
-
formats
-
tier1
'
:
{
}
'
texture
-
formats
-
tier2
'
:
{
}
}
;
export
const
kFeatureNames
=
keysOf
(
kFeatureNameInfo
)
;
export
const
kKnownWGSLLanguageFeatures
=
[
'
readonly_and_readwrite_storage_textures
'
'
packed_4x8_integer_dot_product
'
'
unrestricted_pointer_parameters
'
'
pointer_composite_access
'
]
as
const
;
export
type
WGSLLanguageFeature
=
(
typeof
kKnownWGSLLanguageFeatures
)
[
number
]
;
