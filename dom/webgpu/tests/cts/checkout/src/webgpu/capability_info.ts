import
{
keysOf
makeTable
numericKeysOf
valueof
}
from
'
.
.
/
common
/
util
/
data_tables
.
js
'
;
import
{
assertTypeTrue
TypeEqual
}
from
'
.
.
/
common
/
util
/
types
.
js
'
;
import
{
assert
unreachable
}
from
'
.
.
/
common
/
util
/
util
.
js
'
;
import
{
GPUConst
kMaxUnsignedLongValue
kMaxUnsignedLongLongValue
}
from
'
.
/
constants
.
js
'
;
import
{
ImageCopyType
}
from
'
.
/
util
/
texture
/
layout
.
js
'
;
export
const
kMaxQueryCount
=
4096
;
export
type
QueryTypeInfo
=
{
readonly
feature
:
GPUFeatureName
|
undefined
;
}
;
export
const
kQueryTypeInfo
:
{
readonly
[
k
in
GPUQueryType
]
:
QueryTypeInfo
;
}
=
{
'
occlusion
'
:
{
feature
:
undefined
}
'
timestamp
'
:
{
feature
:
'
timestamp
-
query
'
}
}
;
export
const
kQueryTypes
=
keysOf
(
kQueryTypeInfo
)
;
export
const
kBufferSizeAlignment
=
4
;
export
const
kBufferUsageCopyInfo
:
{
readonly
[
name
:
string
]
:
GPUBufferUsageFlags
;
}
=
{
'
COPY_NONE
'
:
0
'
COPY_SRC
'
:
GPUConst
.
BufferUsage
.
COPY_SRC
'
COPY_DST
'
:
GPUConst
.
BufferUsage
.
COPY_DST
'
COPY_SRC_DST
'
:
GPUConst
.
BufferUsage
.
COPY_SRC
|
GPUConst
.
BufferUsage
.
COPY_DST
}
;
export
const
kBufferUsageCopy
=
keysOf
(
kBufferUsageCopyInfo
)
;
type
BufferUsageKey
=
keyof
typeof
GPUConst
.
BufferUsage
;
export
const
kBufferUsageKeys
=
keysOf
(
GPUConst
.
BufferUsage
)
;
export
const
kBufferUsageInfo
:
{
readonly
[
k
in
BufferUsageKey
]
:
GPUBufferUsageFlags
;
}
=
{
.
.
.
GPUConst
.
BufferUsage
}
;
export
const
kBufferUsages
=
Object
.
values
(
GPUConst
.
BufferUsage
)
;
export
const
kAllBufferUsageBits
=
kBufferUsages
.
reduce
(
(
previousSet
currentUsage
)
=
>
previousSet
|
currentUsage
0
)
;
export
const
kErrorScopeFilterInfo
:
{
readonly
[
k
in
GPUErrorFilter
]
:
{
}
;
}
=
{
'
out
-
of
-
memory
'
:
{
}
'
validation
'
:
{
}
'
internal
'
:
{
}
}
;
export
const
kErrorScopeFilters
=
keysOf
(
kErrorScopeFilterInfo
)
;
export
const
kGeneratableErrorScopeFilters
=
kErrorScopeFilters
.
filter
(
e
=
>
e
!
=
=
'
internal
'
)
;
const
kRegularTextureFormatInfo
=
makeTable
(
[
'
renderable
'
'
multisample
'
'
resolve
'
'
color
'
'
depth
'
'
stencil
'
'
storage
'
'
copySrc
'
'
copyDst
'
'
sampleType
'
'
bytesPerBlock
'
'
blockWidth
'
'
blockHeight
'
'
renderTargetPixelByteCost
'
'
renderTargetComponentAlignment
'
'
feature
'
'
baseFormat
'
]
as
const
[
true
false
false
true
true
1
1
undefined
undefined
undefined
]
as
const
{
'
r8unorm
'
:
[
true
true
true
false
'
float
'
1
1
1
]
'
r8snorm
'
:
[
false
false
false
false
'
float
'
1
]
'
r8uint
'
:
[
true
true
false
false
'
uint
'
1
1
1
]
'
r8sint
'
:
[
true
true
false
false
'
sint
'
1
1
1
]
'
r16uint
'
:
[
true
true
false
false
'
uint
'
2
2
2
]
'
r16sint
'
:
[
true
true
false
false
'
sint
'
2
2
2
]
'
r16float
'
:
[
true
true
true
false
'
float
'
2
2
2
]
'
rg8unorm
'
:
[
true
true
true
false
'
float
'
2
2
1
]
'
rg8snorm
'
:
[
false
false
false
false
'
float
'
2
]
'
rg8uint
'
:
[
true
true
false
false
'
uint
'
2
2
1
]
'
rg8sint
'
:
[
true
true
false
false
'
sint
'
2
2
1
]
'
r32uint
'
:
[
true
false
false
true
'
uint
'
4
4
4
]
'
r32sint
'
:
[
true
false
false
true
'
sint
'
4
4
4
]
'
r32float
'
:
[
true
true
false
true
'
unfilterable
-
float
'
4
4
4
]
'
rg16uint
'
:
[
true
true
false
false
'
uint
'
4
4
2
]
'
rg16sint
'
:
[
true
true
false
false
'
sint
'
4
4
2
]
'
rg16float
'
:
[
true
true
true
false
'
float
'
4
4
2
]
'
rgba8unorm
'
:
[
true
true
true
true
'
float
'
4
8
1
'
rgba8unorm
'
]
'
rgba8unorm
-
srgb
'
:
[
true
true
true
false
'
float
'
4
8
1
'
rgba8unorm
'
]
'
rgba8snorm
'
:
[
false
false
false
true
'
float
'
4
]
'
rgba8uint
'
:
[
true
true
false
true
'
uint
'
4
4
1
]
'
rgba8sint
'
:
[
true
true
false
true
'
sint
'
4
4
1
]
'
bgra8unorm
'
:
[
true
true
true
false
'
float
'
4
8
1
'
bgra8unorm
'
]
'
bgra8unorm
-
srgb
'
:
[
true
true
true
false
'
float
'
4
8
1
'
bgra8unorm
'
]
'
rgb10a2unorm
'
:
[
true
true
true
false
'
float
'
4
8
4
]
'
rg11b10ufloat
'
:
[
false
false
false
false
'
float
'
4
8
4
]
'
rgb9e5ufloat
'
:
[
false
false
false
false
'
float
'
4
]
'
rg32uint
'
:
[
true
false
false
true
'
uint
'
8
8
4
]
'
rg32sint
'
:
[
true
false
false
true
'
sint
'
8
8
4
]
'
rg32float
'
:
[
true
false
false
true
'
unfilterable
-
float
'
8
8
4
]
'
rgba16uint
'
:
[
true
true
false
true
'
uint
'
8
8
2
]
'
rgba16sint
'
:
[
true
true
false
true
'
sint
'
8
8
2
]
'
rgba16float
'
:
[
true
true
true
true
'
float
'
8
8
2
]
'
rgba32uint
'
:
[
true
false
false
true
'
uint
'
16
16
4
]
'
rgba32sint
'
:
[
true
false
false
true
'
sint
'
16
16
4
]
'
rgba32float
'
:
[
true
false
false
true
'
unfilterable
-
float
'
16
16
4
]
}
as
const
)
;
const
kTexFmtInfoHeader
=
[
'
renderable
'
'
multisample
'
'
resolve
'
'
color
'
'
depth
'
'
stencil
'
'
storage
'
'
copySrc
'
'
copyDst
'
'
sampleType
'
'
bytesPerBlock
'
'
blockWidth
'
'
blockHeight
'
'
renderTargetPixelByteCost
'
'
renderTargetComponentAlignment
'
'
feature
'
'
baseFormat
'
]
as
const
;
const
kSizedDepthStencilFormatInfo
=
makeTable
(
kTexFmtInfoHeader
[
true
true
false
false
false
1
1
undefined
undefined
undefined
]
as
const
{
'
depth32float
'
:
[
true
false
true
false
'
depth
'
4
]
'
depth16unorm
'
:
[
true
false
true
true
'
depth
'
2
]
'
stencil8
'
:
[
false
true
true
true
'
uint
'
1
]
}
as
const
)
;
const
kUnsizedDepthStencilFormatInfo
=
makeTable
(
kTexFmtInfoHeader
[
true
true
false
false
false
false
false
undefined
1
1
undefined
]
as
const
{
'
depth24plus
'
:
[
true
false
'
depth
'
]
'
depth24plus
-
stencil8
'
:
[
true
true
'
depth
'
]
'
depth32float
-
stencil8
'
:
[
true
true
'
depth
'
'
depth32float
-
stencil8
'
]
}
as
const
)
;
const
kBCTextureFormatInfo
=
makeTable
(
kTexFmtInfoHeader
[
false
false
false
true
false
false
false
true
true
4
4
undefined
]
as
const
{
'
bc1
-
rgba
-
unorm
'
:
[
'
float
'
8
4
4
'
texture
-
compression
-
bc
'
'
bc1
-
rgba
-
unorm
'
]
'
bc1
-
rgba
-
unorm
-
srgb
'
:
[
'
float
'
8
4
4
'
texture
-
compression
-
bc
'
'
bc1
-
rgba
-
unorm
'
]
'
bc2
-
rgba
-
unorm
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
bc
'
'
bc2
-
rgba
-
unorm
'
]
'
bc2
-
rgba
-
unorm
-
srgb
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
bc
'
'
bc2
-
rgba
-
unorm
'
]
'
bc3
-
rgba
-
unorm
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
bc
'
'
bc3
-
rgba
-
unorm
'
]
'
bc3
-
rgba
-
unorm
-
srgb
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
bc
'
'
bc3
-
rgba
-
unorm
'
]
'
bc4
-
r
-
unorm
'
:
[
'
float
'
8
4
4
'
texture
-
compression
-
bc
'
]
'
bc4
-
r
-
snorm
'
:
[
'
float
'
8
4
4
'
texture
-
compression
-
bc
'
]
'
bc5
-
rg
-
unorm
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
bc
'
]
'
bc5
-
rg
-
snorm
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
bc
'
]
'
bc6h
-
rgb
-
ufloat
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
bc
'
]
'
bc6h
-
rgb
-
float
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
bc
'
]
'
bc7
-
rgba
-
unorm
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
bc
'
'
bc7
-
rgba
-
unorm
'
]
'
bc7
-
rgba
-
unorm
-
srgb
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
bc
'
'
bc7
-
rgba
-
unorm
'
]
}
as
const
)
;
const
kETC2TextureFormatInfo
=
makeTable
(
kTexFmtInfoHeader
[
false
false
false
true
false
false
false
true
true
4
4
undefined
]
as
const
{
'
etc2
-
rgb8unorm
'
:
[
'
float
'
8
4
4
'
texture
-
compression
-
etc2
'
'
etc2
-
rgb8unorm
'
]
'
etc2
-
rgb8unorm
-
srgb
'
:
[
'
float
'
8
4
4
'
texture
-
compression
-
etc2
'
'
etc2
-
rgb8unorm
'
]
'
etc2
-
rgb8a1unorm
'
:
[
'
float
'
8
4
4
'
texture
-
compression
-
etc2
'
'
etc2
-
rgb8a1unorm
'
]
'
etc2
-
rgb8a1unorm
-
srgb
'
:
[
'
float
'
8
4
4
'
texture
-
compression
-
etc2
'
'
etc2
-
rgb8a1unorm
'
]
'
etc2
-
rgba8unorm
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
etc2
'
'
etc2
-
rgba8unorm
'
]
'
etc2
-
rgba8unorm
-
srgb
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
etc2
'
'
etc2
-
rgba8unorm
'
]
'
eac
-
r11unorm
'
:
[
'
float
'
8
4
4
'
texture
-
compression
-
etc2
'
]
'
eac
-
r11snorm
'
:
[
'
float
'
8
4
4
'
texture
-
compression
-
etc2
'
]
'
eac
-
rg11unorm
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
etc2
'
]
'
eac
-
rg11snorm
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
etc2
'
]
}
as
const
)
;
const
kASTCTextureFormatInfo
=
makeTable
(
kTexFmtInfoHeader
[
false
false
false
true
false
false
false
true
true
undefined
]
as
const
{
'
astc
-
4x4
-
unorm
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
astc
'
'
astc
-
4x4
-
unorm
'
]
'
astc
-
4x4
-
unorm
-
srgb
'
:
[
'
float
'
16
4
4
'
texture
-
compression
-
astc
'
'
astc
-
4x4
-
unorm
'
]
'
astc
-
5x4
-
unorm
'
:
[
'
float
'
16
5
4
'
texture
-
compression
-
astc
'
'
astc
-
5x4
-
unorm
'
]
'
astc
-
5x4
-
unorm
-
srgb
'
:
[
'
float
'
16
5
4
'
texture
-
compression
-
astc
'
'
astc
-
5x4
-
unorm
'
]
'
astc
-
5x5
-
unorm
'
:
[
'
float
'
16
5
5
'
texture
-
compression
-
astc
'
'
astc
-
5x5
-
unorm
'
]
'
astc
-
5x5
-
unorm
-
srgb
'
:
[
'
float
'
16
5
5
'
texture
-
compression
-
astc
'
'
astc
-
5x5
-
unorm
'
]
'
astc
-
6x5
-
unorm
'
:
[
'
float
'
16
6
5
'
texture
-
compression
-
astc
'
'
astc
-
6x5
-
unorm
'
]
'
astc
-
6x5
-
unorm
-
srgb
'
:
[
'
float
'
16
6
5
'
texture
-
compression
-
astc
'
'
astc
-
6x5
-
unorm
'
]
'
astc
-
6x6
-
unorm
'
:
[
'
float
'
16
6
6
'
texture
-
compression
-
astc
'
'
astc
-
6x6
-
unorm
'
]
'
astc
-
6x6
-
unorm
-
srgb
'
:
[
'
float
'
16
6
6
'
texture
-
compression
-
astc
'
'
astc
-
6x6
-
unorm
'
]
'
astc
-
8x5
-
unorm
'
:
[
'
float
'
16
8
5
'
texture
-
compression
-
astc
'
'
astc
-
8x5
-
unorm
'
]
'
astc
-
8x5
-
unorm
-
srgb
'
:
[
'
float
'
16
8
5
'
texture
-
compression
-
astc
'
'
astc
-
8x5
-
unorm
'
]
'
astc
-
8x6
-
unorm
'
:
[
'
float
'
16
8
6
'
texture
-
compression
-
astc
'
'
astc
-
8x6
-
unorm
'
]
'
astc
-
8x6
-
unorm
-
srgb
'
:
[
'
float
'
16
8
6
'
texture
-
compression
-
astc
'
'
astc
-
8x6
-
unorm
'
]
'
astc
-
8x8
-
unorm
'
:
[
'
float
'
16
8
8
'
texture
-
compression
-
astc
'
'
astc
-
8x8
-
unorm
'
]
'
astc
-
8x8
-
unorm
-
srgb
'
:
[
'
float
'
16
8
8
'
texture
-
compression
-
astc
'
'
astc
-
8x8
-
unorm
'
]
'
astc
-
10x5
-
unorm
'
:
[
'
float
'
16
10
5
'
texture
-
compression
-
astc
'
'
astc
-
10x5
-
unorm
'
]
'
astc
-
10x5
-
unorm
-
srgb
'
:
[
'
float
'
16
10
5
'
texture
-
compression
-
astc
'
'
astc
-
10x5
-
unorm
'
]
'
astc
-
10x6
-
unorm
'
:
[
'
float
'
16
10
6
'
texture
-
compression
-
astc
'
'
astc
-
10x6
-
unorm
'
]
'
astc
-
10x6
-
unorm
-
srgb
'
:
[
'
float
'
16
10
6
'
texture
-
compression
-
astc
'
'
astc
-
10x6
-
unorm
'
]
'
astc
-
10x8
-
unorm
'
:
[
'
float
'
16
10
8
'
texture
-
compression
-
astc
'
'
astc
-
10x8
-
unorm
'
]
'
astc
-
10x8
-
unorm
-
srgb
'
:
[
'
float
'
16
10
8
'
texture
-
compression
-
astc
'
'
astc
-
10x8
-
unorm
'
]
'
astc
-
10x10
-
unorm
'
:
[
'
float
'
16
10
10
'
texture
-
compression
-
astc
'
'
astc
-
10x10
-
unorm
'
]
'
astc
-
10x10
-
unorm
-
srgb
'
:
[
'
float
'
16
10
10
'
texture
-
compression
-
astc
'
'
astc
-
10x10
-
unorm
'
]
'
astc
-
12x10
-
unorm
'
:
[
'
float
'
16
12
10
'
texture
-
compression
-
astc
'
'
astc
-
12x10
-
unorm
'
]
'
astc
-
12x10
-
unorm
-
srgb
'
:
[
'
float
'
16
12
10
'
texture
-
compression
-
astc
'
'
astc
-
12x10
-
unorm
'
]
'
astc
-
12x12
-
unorm
'
:
[
'
float
'
16
12
12
'
texture
-
compression
-
astc
'
'
astc
-
12x12
-
unorm
'
]
'
astc
-
12x12
-
unorm
-
srgb
'
:
[
'
float
'
16
12
12
'
texture
-
compression
-
astc
'
'
astc
-
12x12
-
unorm
'
]
}
as
const
)
;
const
kCompressedTextureFormatInfo
=
{
.
.
.
kBCTextureFormatInfo
.
.
.
kETC2TextureFormatInfo
.
.
.
kASTCTextureFormatInfo
}
as
const
;
const
kColorTextureFormatInfo
=
{
.
.
.
kRegularTextureFormatInfo
.
.
.
kCompressedTextureFormatInfo
}
as
const
;
const
kEncodableTextureFormatInfo
=
{
.
.
.
kRegularTextureFormatInfo
.
.
.
kSizedDepthStencilFormatInfo
}
as
const
;
const
kSizedTextureFormatInfo
=
{
.
.
.
kRegularTextureFormatInfo
.
.
.
kSizedDepthStencilFormatInfo
.
.
.
kCompressedTextureFormatInfo
}
as
const
;
const
kDepthStencilFormatInfo
=
{
.
.
.
kSizedDepthStencilFormatInfo
.
.
.
kUnsizedDepthStencilFormatInfo
}
as
const
;
const
kUncompressedTextureFormatInfo
=
{
.
.
.
kRegularTextureFormatInfo
.
.
.
kSizedDepthStencilFormatInfo
.
.
.
kUnsizedDepthStencilFormatInfo
}
as
const
;
const
kAllTextureFormatInfo
=
{
.
.
.
kUncompressedTextureFormatInfo
.
.
.
kCompressedTextureFormatInfo
}
as
const
;
export
type
RegularTextureFormat
=
keyof
typeof
kRegularTextureFormatInfo
;
export
type
SizedDepthStencilFormat
=
keyof
typeof
kSizedDepthStencilFormatInfo
;
export
type
UnsizedDepthStencilFormat
=
keyof
typeof
kUnsizedDepthStencilFormatInfo
;
export
type
CompressedTextureFormat
=
keyof
typeof
kCompressedTextureFormatInfo
;
export
type
ColorTextureFormat
=
keyof
typeof
kColorTextureFormatInfo
;
export
type
EncodableTextureFormat
=
keyof
typeof
kEncodableTextureFormatInfo
;
export
type
SizedTextureFormat
=
keyof
typeof
kSizedTextureFormatInfo
;
export
type
DepthStencilFormat
=
keyof
typeof
kDepthStencilFormatInfo
;
export
type
UncompressedTextureFormat
=
keyof
typeof
kUncompressedTextureFormatInfo
;
export
const
kRegularTextureFormats
:
readonly
RegularTextureFormat
[
]
=
keysOf
(
kRegularTextureFormatInfo
)
;
export
const
kSizedDepthStencilFormats
:
readonly
SizedDepthStencilFormat
[
]
=
keysOf
(
kSizedDepthStencilFormatInfo
)
;
export
const
kUnsizedDepthStencilFormats
:
readonly
UnsizedDepthStencilFormat
[
]
=
keysOf
(
kUnsizedDepthStencilFormatInfo
)
;
export
const
kCompressedTextureFormats
:
readonly
CompressedTextureFormat
[
]
=
keysOf
(
kCompressedTextureFormatInfo
)
;
export
const
kColorTextureFormats
:
readonly
ColorTextureFormat
[
]
=
keysOf
(
kColorTextureFormatInfo
)
;
export
const
kEncodableTextureFormats
:
readonly
EncodableTextureFormat
[
]
=
keysOf
(
kEncodableTextureFormatInfo
)
;
export
const
kSizedTextureFormats
:
readonly
SizedTextureFormat
[
]
=
keysOf
(
kSizedTextureFormatInfo
)
;
export
const
kDepthStencilFormats
:
readonly
DepthStencilFormat
[
]
=
keysOf
(
kDepthStencilFormatInfo
)
;
export
const
kUncompressedTextureFormats
:
readonly
UncompressedTextureFormat
[
]
=
keysOf
(
kUncompressedTextureFormatInfo
)
;
export
const
kAllTextureFormats
:
readonly
GPUTextureFormat
[
]
=
keysOf
(
kAllTextureFormatInfo
)
;
export
const
kRenderableColorTextureFormats
=
kRegularTextureFormats
.
filter
(
v
=
>
kColorTextureFormatInfo
[
v
]
.
renderable
)
;
assert
(
kRenderableColorTextureFormats
.
every
(
f
=
>
kAllTextureFormatInfo
[
f
]
.
renderTargetComponentAlignment
!
=
=
undefined
&
&
kAllTextureFormatInfo
[
f
]
.
renderTargetPixelByteCost
!
=
=
undefined
)
)
;
export
const
kCanvasTextureFormats
=
[
'
bgra8unorm
'
'
rgba8unorm
'
'
rgba16float
'
]
as
const
;
export
const
kCanvasAlphaModesInfo
:
{
readonly
[
k
in
GPUCanvasAlphaMode
]
:
{
}
;
}
=
{
'
opaque
'
:
{
}
'
premultiplied
'
:
{
}
}
;
export
const
kCanvasAlphaModes
=
keysOf
(
kCanvasAlphaModesInfo
)
;
export
const
kCanvasColorSpacesInfo
:
{
readonly
[
k
in
PredefinedColorSpace
]
:
{
}
;
}
=
{
'
srgb
'
:
{
}
'
display
-
p3
'
:
{
}
}
;
export
const
kCanvasColorSpaces
=
keysOf
(
kCanvasColorSpacesInfo
)
;
export
type
TextureFormatInfo
=
{
renderable
:
boolean
;
multisample
:
boolean
;
resolve
:
boolean
;
color
:
boolean
;
depth
:
boolean
;
stencil
:
boolean
;
storage
:
boolean
;
copySrc
:
boolean
;
copyDst
:
boolean
;
bytesPerBlock
:
number
|
undefined
;
blockWidth
:
number
;
blockHeight
:
number
;
renderTargetPixelByteCost
:
number
|
undefined
;
renderTargetComponentAlignment
:
number
|
undefined
;
feature
:
GPUFeatureName
|
undefined
;
}
;
export
const
kTextureFormatInfo
:
{
readonly
[
k
in
GPUTextureFormat
]
:
TextureFormatInfo
&
typeof
kAllTextureFormatInfo
[
k
]
;
}
=
kAllTextureFormatInfo
;
export
const
kTextureFormats
:
readonly
GPUTextureFormat
[
]
=
keysOf
(
kAllTextureFormatInfo
)
;
export
const
kValidTextureFormatsForCopyE2T
=
[
'
r8unorm
'
'
r16float
'
'
r32float
'
'
rg8unorm
'
'
rg16float
'
'
rg32float
'
'
rgba8unorm
'
'
rgba8unorm
-
srgb
'
'
bgra8unorm
'
'
bgra8unorm
-
srgb
'
'
rgb10a2unorm
'
'
rgba16float
'
'
rgba32float
'
]
as
const
;
export
const
kTextureDimensionInfo
:
{
readonly
[
k
in
GPUTextureDimension
]
:
{
}
;
}
=
{
'
1d
'
:
{
}
'
2d
'
:
{
}
'
3d
'
:
{
}
}
;
export
const
kTextureDimensions
=
keysOf
(
kTextureDimensionInfo
)
;
export
const
kTextureAspectInfo
:
{
readonly
[
k
in
GPUTextureAspect
]
:
{
}
;
}
=
{
'
all
'
:
{
}
'
depth
-
only
'
:
{
}
'
stencil
-
only
'
:
{
}
}
;
export
const
kTextureAspects
=
keysOf
(
kTextureAspectInfo
)
;
export
const
kCompareFunctionInfo
:
{
readonly
[
k
in
GPUCompareFunction
]
:
{
}
;
}
=
{
'
never
'
:
{
}
'
less
'
:
{
}
'
equal
'
:
{
}
'
less
-
equal
'
:
{
}
'
greater
'
:
{
}
'
not
-
equal
'
:
{
}
'
greater
-
equal
'
:
{
}
'
always
'
:
{
}
}
;
export
const
kCompareFunctions
=
keysOf
(
kCompareFunctionInfo
)
;
export
const
kStencilOperationInfo
:
{
readonly
[
k
in
GPUStencilOperation
]
:
{
}
;
}
=
{
'
keep
'
:
{
}
'
zero
'
:
{
}
'
replace
'
:
{
}
'
invert
'
:
{
}
'
increment
-
clamp
'
:
{
}
'
decrement
-
clamp
'
:
{
}
'
increment
-
wrap
'
:
{
}
'
decrement
-
wrap
'
:
{
}
}
;
export
const
kStencilOperations
=
keysOf
(
kStencilOperationInfo
)
;
const
kDepthStencilFormatCapabilityInBufferTextureCopy
=
{
depth24plus
:
{
CopyB2T
:
[
]
CopyT2B
:
[
]
texelAspectSize
:
{
'
depth
-
only
'
:
-
1
'
stencil
-
only
'
:
-
1
}
}
'
depth24plus
-
stencil8
'
:
{
CopyB2T
:
[
'
stencil
-
only
'
]
CopyT2B
:
[
'
stencil
-
only
'
]
texelAspectSize
:
{
'
depth
-
only
'
:
-
1
'
stencil
-
only
'
:
1
}
}
depth16unorm
:
{
CopyB2T
:
[
'
all
'
'
depth
-
only
'
]
CopyT2B
:
[
'
all
'
'
depth
-
only
'
]
texelAspectSize
:
{
'
depth
-
only
'
:
2
'
stencil
-
only
'
:
-
1
}
}
depth32float
:
{
CopyB2T
:
[
]
CopyT2B
:
[
'
all
'
'
depth
-
only
'
]
texelAspectSize
:
{
'
depth
-
only
'
:
4
'
stencil
-
only
'
:
-
1
}
}
'
depth32float
-
stencil8
'
:
{
CopyB2T
:
[
'
stencil
-
only
'
]
CopyT2B
:
[
'
depth
-
only
'
'
stencil
-
only
'
]
texelAspectSize
:
{
'
depth
-
only
'
:
4
'
stencil
-
only
'
:
1
}
}
stencil8
:
{
CopyB2T
:
[
'
all
'
'
stencil
-
only
'
]
CopyT2B
:
[
'
all
'
'
stencil
-
only
'
]
texelAspectSize
:
{
'
depth
-
only
'
:
-
1
'
stencil
-
only
'
:
1
}
}
}
as
const
;
export
const
kDepthStencilFormatResolvedAspect
:
{
readonly
[
k
in
DepthStencilFormat
]
:
{
readonly
[
a
in
GPUTextureAspect
]
:
DepthStencilFormat
|
undefined
;
}
;
}
=
{
depth24plus
:
{
all
:
'
depth24plus
'
'
depth
-
only
'
:
'
depth24plus
'
'
stencil
-
only
'
:
undefined
}
'
depth24plus
-
stencil8
'
:
{
all
:
'
depth24plus
-
stencil8
'
'
depth
-
only
'
:
'
depth24plus
'
'
stencil
-
only
'
:
'
stencil8
'
}
depth16unorm
:
{
all
:
'
depth16unorm
'
'
depth
-
only
'
:
'
depth16unorm
'
'
stencil
-
only
'
:
undefined
}
depth32float
:
{
all
:
'
depth32float
'
'
depth
-
only
'
:
'
depth32float
'
'
stencil
-
only
'
:
undefined
}
'
depth32float
-
stencil8
'
:
{
all
:
'
depth32float
-
stencil8
'
'
depth
-
only
'
:
'
depth32float
'
'
stencil
-
only
'
:
'
stencil8
'
}
stencil8
:
{
all
:
'
stencil8
'
'
depth
-
only
'
:
undefined
'
stencil
-
only
'
:
'
stencil8
'
}
}
as
const
;
export
function
resolvePerAspectFormat
(
format
:
GPUTextureFormat
aspect
?
:
GPUTextureAspect
)
:
GPUTextureFormat
{
if
(
aspect
=
=
=
'
all
'
|
|
aspect
=
=
=
undefined
)
{
return
format
;
}
assert
(
kTextureFormatInfo
[
format
]
.
depth
|
|
kTextureFormatInfo
[
format
]
.
stencil
)
;
const
resolved
=
kDepthStencilFormatResolvedAspect
[
format
as
DepthStencilFormat
]
[
aspect
?
?
'
all
'
]
;
assert
(
resolved
!
=
=
undefined
)
;
return
resolved
;
}
export
function
depthStencilFormatCopyableAspects
(
type
:
ImageCopyType
format
:
DepthStencilFormat
)
:
readonly
GPUTextureAspect
[
]
{
const
appliedType
=
type
=
=
=
'
WriteTexture
'
?
'
CopyB2T
'
:
type
;
return
kDepthStencilFormatCapabilityInBufferTextureCopy
[
format
]
[
appliedType
]
;
}
export
function
depthStencilBufferTextureCopySupported
(
type
:
ImageCopyType
format
:
DepthStencilFormat
aspect
:
GPUTextureAspect
)
:
boolean
{
const
supportedAspects
:
readonly
GPUTextureAspect
[
]
=
depthStencilFormatCopyableAspects
(
type
format
)
;
return
supportedAspects
.
includes
(
aspect
)
;
}
export
function
depthStencilFormatAspectSize
(
format
:
DepthStencilFormat
aspect
:
'
depth
-
only
'
|
'
stencil
-
only
'
)
{
const
texelAspectSize
=
kDepthStencilFormatCapabilityInBufferTextureCopy
[
format
]
.
texelAspectSize
[
aspect
]
;
assert
(
texelAspectSize
>
0
)
;
return
texelAspectSize
;
}
export
function
textureDimensionAndFormatCompatible
(
dimension
:
undefined
|
GPUTextureDimension
format
:
GPUTextureFormat
)
:
boolean
{
const
info
=
kAllTextureFormatInfo
[
format
]
;
return
!
(
(
dimension
=
=
=
'
1d
'
|
|
dimension
=
=
=
'
3d
'
)
&
&
(
info
.
blockWidth
>
1
|
|
info
.
depth
|
|
info
.
stencil
)
)
;
}
export
const
kTextureUsageTypeInfo
:
{
readonly
[
name
:
string
]
:
number
;
}
=
{
'
texture
'
:
Number
(
GPUConst
.
TextureUsage
.
TEXTURE_BINDING
)
'
storage
'
:
Number
(
GPUConst
.
TextureUsage
.
STORAGE_BINDING
)
'
render
'
:
Number
(
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
)
}
;
export
const
kTextureUsageType
=
keysOf
(
kTextureUsageTypeInfo
)
;
export
const
kTextureUsageCopyInfo
:
{
readonly
[
name
:
string
]
:
number
;
}
=
{
'
none
'
:
0
'
src
'
:
Number
(
GPUConst
.
TextureUsage
.
COPY_SRC
)
'
dst
'
:
Number
(
GPUConst
.
TextureUsage
.
COPY_DST
)
'
src
-
dest
'
:
Number
(
GPUConst
.
TextureUsage
.
COPY_SRC
)
|
Number
(
GPUConst
.
TextureUsage
.
COPY_DST
)
}
;
export
const
kTextureUsageCopy
=
keysOf
(
kTextureUsageCopyInfo
)
;
export
const
kTextureUsageInfo
:
{
readonly
[
k
in
valueof
<
typeof
GPUConst
.
TextureUsage
>
]
:
{
}
;
}
=
{
[
GPUConst
.
TextureUsage
.
COPY_SRC
]
:
{
}
[
GPUConst
.
TextureUsage
.
COPY_DST
]
:
{
}
[
GPUConst
.
TextureUsage
.
TEXTURE_BINDING
]
:
{
}
[
GPUConst
.
TextureUsage
.
STORAGE_BINDING
]
:
{
}
[
GPUConst
.
TextureUsage
.
RENDER_ATTACHMENT
]
:
{
}
}
;
export
const
kTextureUsages
=
numericKeysOf
<
GPUTextureUsageFlags
>
(
kTextureUsageInfo
)
;
export
type
TextureViewDimensionInfo
=
{
readonly
storage
:
boolean
;
}
;
export
const
kTextureViewDimensionInfo
:
{
readonly
[
k
in
GPUTextureViewDimension
]
:
TextureViewDimensionInfo
;
}
=
{
'
1d
'
:
{
storage
:
true
}
'
2d
'
:
{
storage
:
true
}
'
2d
-
array
'
:
{
storage
:
true
}
'
cube
'
:
{
storage
:
false
}
'
cube
-
array
'
:
{
storage
:
false
}
'
3d
'
:
{
storage
:
true
}
}
;
export
const
kTextureViewDimensions
=
keysOf
(
kTextureViewDimensionInfo
)
;
export
type
VertexFormatInfo
=
{
readonly
bytesPerComponent
:
1
|
2
|
4
;
readonly
type
:
'
float
'
|
'
unorm
'
|
'
snorm
'
|
'
uint
'
|
'
sint
'
;
readonly
componentCount
:
1
|
2
|
3
|
4
;
readonly
wgslType
:
|
'
f32
'
|
'
vec2
<
f32
>
'
|
'
vec3
<
f32
>
'
|
'
vec4
<
f32
>
'
|
'
u32
'
|
'
vec2
<
u32
>
'
|
'
vec3
<
u32
>
'
|
'
vec4
<
u32
>
'
|
'
i32
'
|
'
vec2
<
i32
>
'
|
'
vec3
<
i32
>
'
|
'
vec4
<
i32
>
'
;
}
;
export
const
kVertexFormatInfo
:
{
readonly
[
k
in
GPUVertexFormat
]
:
VertexFormatInfo
;
}
=
makeTable
(
[
'
bytesPerComponent
'
'
type
'
'
componentCount
'
'
wgslType
'
]
as
const
[
]
as
const
{
'
uint8x2
'
:
[
1
'
uint
'
2
'
vec2
<
u32
>
'
]
'
uint8x4
'
:
[
1
'
uint
'
4
'
vec4
<
u32
>
'
]
'
sint8x2
'
:
[
1
'
sint
'
2
'
vec2
<
i32
>
'
]
'
sint8x4
'
:
[
1
'
sint
'
4
'
vec4
<
i32
>
'
]
'
unorm8x2
'
:
[
1
'
unorm
'
2
'
vec2
<
f32
>
'
]
'
unorm8x4
'
:
[
1
'
unorm
'
4
'
vec4
<
f32
>
'
]
'
snorm8x2
'
:
[
1
'
snorm
'
2
'
vec2
<
f32
>
'
]
'
snorm8x4
'
:
[
1
'
snorm
'
4
'
vec4
<
f32
>
'
]
'
uint16x2
'
:
[
2
'
uint
'
2
'
vec2
<
u32
>
'
]
'
uint16x4
'
:
[
2
'
uint
'
4
'
vec4
<
u32
>
'
]
'
sint16x2
'
:
[
2
'
sint
'
2
'
vec2
<
i32
>
'
]
'
sint16x4
'
:
[
2
'
sint
'
4
'
vec4
<
i32
>
'
]
'
unorm16x2
'
:
[
2
'
unorm
'
2
'
vec2
<
f32
>
'
]
'
unorm16x4
'
:
[
2
'
unorm
'
4
'
vec4
<
f32
>
'
]
'
snorm16x2
'
:
[
2
'
snorm
'
2
'
vec2
<
f32
>
'
]
'
snorm16x4
'
:
[
2
'
snorm
'
4
'
vec4
<
f32
>
'
]
'
float16x2
'
:
[
2
'
float
'
2
'
vec2
<
f32
>
'
]
'
float16x4
'
:
[
2
'
float
'
4
'
vec4
<
f32
>
'
]
'
float32
'
:
[
4
'
float
'
1
'
f32
'
]
'
float32x2
'
:
[
4
'
float
'
2
'
vec2
<
f32
>
'
]
'
float32x3
'
:
[
4
'
float
'
3
'
vec3
<
f32
>
'
]
'
float32x4
'
:
[
4
'
float
'
4
'
vec4
<
f32
>
'
]
'
uint32
'
:
[
4
'
uint
'
1
'
u32
'
]
'
uint32x2
'
:
[
4
'
uint
'
2
'
vec2
<
u32
>
'
]
'
uint32x3
'
:
[
4
'
uint
'
3
'
vec3
<
u32
>
'
]
'
uint32x4
'
:
[
4
'
uint
'
4
'
vec4
<
u32
>
'
]
'
sint32
'
:
[
4
'
sint
'
1
'
i32
'
]
'
sint32x2
'
:
[
4
'
sint
'
2
'
vec2
<
i32
>
'
]
'
sint32x3
'
:
[
4
'
sint
'
3
'
vec3
<
i32
>
'
]
'
sint32x4
'
:
[
4
'
sint
'
4
'
vec4
<
i32
>
'
]
}
as
const
)
;
export
const
kVertexFormats
=
keysOf
(
kVertexFormatInfo
)
;
export
type
PerStageBindingLimitClass
=
|
'
uniformBuf
'
|
'
storageBuf
'
|
'
sampler
'
|
'
sampledTex
'
|
'
storageTex
'
;
export
type
PerPipelineBindingLimitClass
=
PerStageBindingLimitClass
;
export
type
ValidBindableResource
=
|
'
uniformBuf
'
|
'
storageBuf
'
|
'
filtSamp
'
|
'
nonFiltSamp
'
|
'
compareSamp
'
|
'
sampledTex
'
|
'
sampledTexMS
'
|
'
storageTex
'
;
type
ErrorBindableResource
=
'
errorBuf
'
|
'
errorSamp
'
|
'
errorTex
'
;
export
type
BindableResource
=
ValidBindableResource
|
ErrorBindableResource
;
export
const
kBindableResources
=
[
'
uniformBuf
'
'
storageBuf
'
'
filtSamp
'
'
nonFiltSamp
'
'
compareSamp
'
'
sampledTex
'
'
sampledTexMS
'
'
storageTex
'
'
errorBuf
'
'
errorSamp
'
'
errorTex
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
BindableResource
typeof
kBindableResources
[
number
]
>
>
(
)
;
export
const
kMinDynamicBufferOffsetAlignment
=
256
;
export
const
kPerStageBindingLimits
:
{
readonly
[
k
in
PerStageBindingLimitClass
]
:
{
readonly
class
:
k
;
readonly
max
:
number
;
}
;
}
=
{
'
uniformBuf
'
:
{
class
:
'
uniformBuf
'
max
:
12
}
'
storageBuf
'
:
{
class
:
'
storageBuf
'
max
:
8
}
'
sampler
'
:
{
class
:
'
sampler
'
max
:
16
}
'
sampledTex
'
:
{
class
:
'
sampledTex
'
max
:
16
}
'
storageTex
'
:
{
class
:
'
storageTex
'
max
:
4
}
}
;
export
const
kPerPipelineBindingLimits
:
{
readonly
[
k
in
PerPipelineBindingLimitClass
]
:
{
readonly
class
:
k
;
readonly
maxDynamic
:
number
;
}
;
}
=
{
'
uniformBuf
'
:
{
class
:
'
uniformBuf
'
maxDynamic
:
8
}
'
storageBuf
'
:
{
class
:
'
storageBuf
'
maxDynamic
:
4
}
'
sampler
'
:
{
class
:
'
sampler
'
maxDynamic
:
0
}
'
sampledTex
'
:
{
class
:
'
sampledTex
'
maxDynamic
:
0
}
'
storageTex
'
:
{
class
:
'
storageTex
'
maxDynamic
:
0
}
}
;
interface
BindingKindInfo
{
readonly
resource
:
ValidBindableResource
;
readonly
perStageLimitClass
:
typeof
kPerStageBindingLimits
[
PerStageBindingLimitClass
]
;
readonly
perPipelineLimitClass
:
typeof
kPerPipelineBindingLimits
[
PerPipelineBindingLimitClass
]
;
}
const
kBindingKind
:
{
readonly
[
k
in
ValidBindableResource
]
:
BindingKindInfo
;
}
=
{
uniformBuf
:
{
resource
:
'
uniformBuf
'
perStageLimitClass
:
kPerStageBindingLimits
.
uniformBuf
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
uniformBuf
}
storageBuf
:
{
resource
:
'
storageBuf
'
perStageLimitClass
:
kPerStageBindingLimits
.
storageBuf
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
storageBuf
}
filtSamp
:
{
resource
:
'
filtSamp
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampler
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampler
}
nonFiltSamp
:
{
resource
:
'
nonFiltSamp
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampler
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampler
}
compareSamp
:
{
resource
:
'
compareSamp
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampler
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampler
}
sampledTex
:
{
resource
:
'
sampledTex
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampledTex
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampledTex
}
sampledTexMS
:
{
resource
:
'
sampledTexMS
'
perStageLimitClass
:
kPerStageBindingLimits
.
sampledTex
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
sampledTex
}
storageTex
:
{
resource
:
'
storageTex
'
perStageLimitClass
:
kPerStageBindingLimits
.
storageTex
perPipelineLimitClass
:
kPerPipelineBindingLimits
.
storageTex
}
}
;
const
kValidStagesAll
=
{
validStages
:
GPUConst
.
ShaderStage
.
VERTEX
|
GPUConst
.
ShaderStage
.
FRAGMENT
|
GPUConst
.
ShaderStage
.
COMPUTE
}
as
const
;
const
kValidStagesStorageWrite
=
{
validStages
:
GPUConst
.
ShaderStage
.
FRAGMENT
|
GPUConst
.
ShaderStage
.
COMPUTE
}
as
const
;
export
function
bufferBindingTypeInfo
(
d
:
GPUBufferBindingLayout
)
{
switch
(
d
.
type
?
?
'
uniform
'
)
{
case
'
uniform
'
:
return
{
usage
:
GPUConst
.
BufferUsage
.
UNIFORM
.
.
.
kBindingKind
.
uniformBuf
.
.
.
kValidStagesAll
}
;
case
'
storage
'
:
return
{
usage
:
GPUConst
.
BufferUsage
.
STORAGE
.
.
.
kBindingKind
.
storageBuf
.
.
.
kValidStagesStorageWrite
}
;
case
'
read
-
only
-
storage
'
:
return
{
usage
:
GPUConst
.
BufferUsage
.
STORAGE
.
.
.
kBindingKind
.
storageBuf
.
.
.
kValidStagesAll
}
;
}
}
export
const
kBufferBindingTypes
=
[
'
uniform
'
'
storage
'
'
read
-
only
-
storage
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
GPUBufferBindingType
typeof
kBufferBindingTypes
[
number
]
>
>
(
)
;
export
function
samplerBindingTypeInfo
(
d
:
GPUSamplerBindingLayout
)
{
switch
(
d
.
type
?
?
'
filtering
'
)
{
case
'
filtering
'
:
return
{
.
.
.
kBindingKind
.
filtSamp
.
.
.
kValidStagesAll
}
;
case
'
non
-
filtering
'
:
return
{
.
.
.
kBindingKind
.
nonFiltSamp
.
.
.
kValidStagesAll
}
;
case
'
comparison
'
:
return
{
.
.
.
kBindingKind
.
compareSamp
.
.
.
kValidStagesAll
}
;
}
}
export
const
kSamplerBindingTypes
=
[
'
filtering
'
'
non
-
filtering
'
'
comparison
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
GPUSamplerBindingType
typeof
kSamplerBindingTypes
[
number
]
>
>
(
)
;
export
function
sampledTextureBindingTypeInfo
(
d
:
GPUTextureBindingLayout
)
{
if
(
d
.
multisampled
)
{
return
{
usage
:
GPUConst
.
TextureUsage
.
TEXTURE_BINDING
.
.
.
kBindingKind
.
sampledTexMS
.
.
.
kValidStagesAll
}
;
}
else
{
return
{
usage
:
GPUConst
.
TextureUsage
.
TEXTURE_BINDING
.
.
.
kBindingKind
.
sampledTex
.
.
.
kValidStagesAll
}
;
}
}
export
const
kTextureSampleTypes
=
[
'
float
'
'
unfilterable
-
float
'
'
depth
'
'
sint
'
'
uint
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
GPUTextureSampleType
typeof
kTextureSampleTypes
[
number
]
>
>
(
)
;
export
function
storageTextureBindingTypeInfo
(
d
:
GPUStorageTextureBindingLayout
)
{
return
{
usage
:
GPUConst
.
TextureUsage
.
STORAGE_BINDING
.
.
.
kBindingKind
.
storageTex
.
.
.
kValidStagesStorageWrite
}
;
}
export
const
kStorageTextureAccessValues
=
[
'
write
-
only
'
]
as
const
;
assertTypeTrue
<
TypeEqual
<
GPUStorageTextureAccess
typeof
kStorageTextureAccessValues
[
number
]
>
>
(
)
;
export
type
BGLEntry
=
Omit
<
GPUBindGroupLayoutEntry
'
binding
'
|
'
visibility
'
>
;
export
function
texBindingTypeInfo
(
e
:
BGLEntry
)
{
if
(
e
.
texture
!
=
=
undefined
)
return
sampledTextureBindingTypeInfo
(
e
.
texture
)
;
if
(
e
.
storageTexture
!
=
=
undefined
)
return
storageTextureBindingTypeInfo
(
e
.
storageTexture
)
;
unreachable
(
)
;
}
export
function
bindingTypeInfo
(
e
:
BGLEntry
)
{
if
(
e
.
buffer
!
=
=
undefined
)
return
bufferBindingTypeInfo
(
e
.
buffer
)
;
if
(
e
.
texture
!
=
=
undefined
)
return
sampledTextureBindingTypeInfo
(
e
.
texture
)
;
if
(
e
.
sampler
!
=
=
undefined
)
return
samplerBindingTypeInfo
(
e
.
sampler
)
;
if
(
e
.
storageTexture
!
=
=
undefined
)
return
storageTextureBindingTypeInfo
(
e
.
storageTexture
)
;
unreachable
(
'
GPUBindGroupLayoutEntry
has
no
BindingLayout
'
)
;
}
export
function
bufferBindingEntries
(
includeUndefined
:
boolean
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
(
includeUndefined
?
[
{
buffer
:
{
type
:
undefined
}
}
]
:
[
]
)
{
buffer
:
{
type
:
'
uniform
'
}
}
{
buffer
:
{
type
:
'
storage
'
}
}
{
buffer
:
{
type
:
'
read
-
only
-
storage
'
}
}
]
as
const
;
}
export
function
samplerBindingEntries
(
includeUndefined
:
boolean
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
(
includeUndefined
?
[
{
sampler
:
{
type
:
undefined
}
}
]
:
[
]
)
{
sampler
:
{
type
:
'
comparison
'
}
}
{
sampler
:
{
type
:
'
filtering
'
}
}
{
sampler
:
{
type
:
'
non
-
filtering
'
}
}
]
as
const
;
}
export
function
textureBindingEntries
(
includeUndefined
:
boolean
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
(
includeUndefined
?
[
{
texture
:
{
multisampled
:
undefined
}
}
]
:
[
]
)
{
texture
:
{
multisampled
:
false
}
}
{
texture
:
{
multisampled
:
true
}
}
]
as
const
;
}
export
function
storageTextureBindingEntries
(
format
:
GPUTextureFormat
)
:
readonly
BGLEntry
[
]
{
return
[
{
storageTexture
:
{
access
:
'
write
-
only
'
format
}
}
]
as
const
;
}
export
function
sampledAndStorageBindingEntries
(
includeUndefined
:
boolean
storageTextureFormat
:
GPUTextureFormat
=
'
rgba8unorm
'
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
textureBindingEntries
(
includeUndefined
)
.
.
.
storageTextureBindingEntries
(
storageTextureFormat
)
]
as
const
;
}
export
function
allBindingEntries
(
includeUndefined
:
boolean
storageTextureFormat
:
GPUTextureFormat
=
'
rgba8unorm
'
)
:
readonly
BGLEntry
[
]
{
return
[
.
.
.
bufferBindingEntries
(
includeUndefined
)
.
.
.
samplerBindingEntries
(
includeUndefined
)
.
.
.
sampledAndStorageBindingEntries
(
includeUndefined
storageTextureFormat
)
]
as
const
;
}
export
type
ShaderStageKey
=
keyof
typeof
GPUConst
.
ShaderStage
;
export
const
kShaderStageKeys
=
Object
.
keys
(
GPUConst
.
ShaderStage
)
as
ShaderStageKey
[
]
;
export
const
kShaderStages
:
readonly
GPUShaderStageFlags
[
]
=
[
GPUConst
.
ShaderStage
.
VERTEX
GPUConst
.
ShaderStage
.
FRAGMENT
GPUConst
.
ShaderStage
.
COMPUTE
]
;
export
const
kShaderStageCombinations
:
readonly
GPUShaderStageFlags
[
]
=
[
0
1
2
3
4
5
6
7
]
;
export
const
kTextureSampleCounts
=
[
1
4
]
as
const
;
export
const
kBlendFactors
:
readonly
GPUBlendFactor
[
]
=
[
'
zero
'
'
one
'
'
src
'
'
one
-
minus
-
src
'
'
src
-
alpha
'
'
one
-
minus
-
src
-
alpha
'
'
dst
'
'
one
-
minus
-
dst
'
'
dst
-
alpha
'
'
one
-
minus
-
dst
-
alpha
'
'
src
-
alpha
-
saturated
'
'
constant
'
'
one
-
minus
-
constant
'
]
;
export
const
kBlendOperations
:
readonly
GPUBlendOperation
[
]
=
[
'
add
'
'
subtract
'
'
reverse
-
subtract
'
'
min
'
'
max
'
]
;
export
const
kPrimitiveTopology
:
readonly
GPUPrimitiveTopology
[
]
=
[
'
point
-
list
'
'
line
-
list
'
'
line
-
strip
'
'
triangle
-
list
'
'
triangle
-
strip
'
]
;
assertTypeTrue
<
TypeEqual
<
GPUPrimitiveTopology
typeof
kPrimitiveTopology
[
number
]
>
>
(
)
;
export
const
kIndexFormat
:
readonly
GPUIndexFormat
[
]
=
[
'
uint16
'
'
uint32
'
]
;
assertTypeTrue
<
TypeEqual
<
GPUIndexFormat
typeof
kIndexFormat
[
number
]
>
>
(
)
;
export
const
kLimitInfo
=
makeTable
(
[
'
class
'
'
default
'
'
maximumValue
'
]
as
const
[
'
maximum
'
kMaxUnsignedLongValue
]
as
const
{
'
maxTextureDimension1D
'
:
[
8192
]
'
maxTextureDimension2D
'
:
[
8192
]
'
maxTextureDimension3D
'
:
[
2048
]
'
maxTextureArrayLayers
'
:
[
256
]
'
maxBindGroups
'
:
[
4
]
'
maxDynamicUniformBuffersPerPipelineLayout
'
:
[
8
]
'
maxDynamicStorageBuffersPerPipelineLayout
'
:
[
4
]
'
maxSampledTexturesPerShaderStage
'
:
[
16
]
'
maxSamplersPerShaderStage
'
:
[
16
]
'
maxStorageBuffersPerShaderStage
'
:
[
8
]
'
maxStorageTexturesPerShaderStage
'
:
[
4
]
'
maxUniformBuffersPerShaderStage
'
:
[
12
]
'
maxUniformBufferBindingSize
'
:
[
65536
kMaxUnsignedLongLongValue
]
'
maxStorageBufferBindingSize
'
:
[
134217728
kMaxUnsignedLongLongValue
]
'
minUniformBufferOffsetAlignment
'
:
[
'
alignment
'
256
]
'
minStorageBufferOffsetAlignment
'
:
[
'
alignment
'
256
]
'
maxVertexBuffers
'
:
[
8
]
'
maxBufferSize
'
:
[
268435456
kMaxUnsignedLongLongValue
]
'
maxVertexAttributes
'
:
[
16
]
'
maxVertexBufferArrayStride
'
:
[
2048
]
'
maxInterStageShaderComponents
'
:
[
60
]
'
maxColorAttachments
'
:
[
8
]
'
maxColorAttachmentBytesPerSample
'
:
[
32
]
'
maxComputeWorkgroupStorageSize
'
:
[
16384
]
'
maxComputeInvocationsPerWorkgroup
'
:
[
256
]
'
maxComputeWorkgroupSizeX
'
:
[
256
]
'
maxComputeWorkgroupSizeY
'
:
[
256
]
'
maxComputeWorkgroupSizeZ
'
:
[
64
]
'
maxComputeWorkgroupsPerDimension
'
:
[
65535
]
}
as
const
)
;
export
const
kLimits
=
keysOf
(
kLimitInfo
)
;
export
const
kMaxColorAttachments
=
kLimitInfo
.
maxColorAttachments
.
default
;
export
const
kMaxVertexBuffers
=
kLimitInfo
.
maxVertexBuffers
.
default
;
export
const
kMaxVertexAttributes
=
kLimitInfo
.
maxVertexAttributes
.
default
;
export
const
kMaxVertexBufferArrayStride
=
kLimitInfo
.
maxVertexBufferArrayStride
.
default
;
export
const
kDrawIndirectParametersSize
=
4
;
export
const
kDrawIndexedIndirectParametersSize
=
5
;
export
const
kFeatureNameInfo
:
{
readonly
[
k
in
GPUFeatureName
]
:
{
}
;
}
=
{
'
depth
-
clip
-
control
'
:
{
}
'
depth32float
-
stencil8
'
:
{
}
'
texture
-
compression
-
bc
'
:
{
}
'
texture
-
compression
-
etc2
'
:
{
}
'
texture
-
compression
-
astc
'
:
{
}
'
timestamp
-
query
'
:
{
}
'
indirect
-
first
-
instance
'
:
{
}
'
shader
-
f16
'
:
{
}
'
rg11b10ufloat
-
renderable
'
:
{
}
}
;
export
const
kFeatureNames
=
keysOf
(
kFeatureNameInfo
)
;
export
function
viewCompatible
(
a
:
GPUTextureFormat
b
:
GPUTextureFormat
)
:
boolean
{
return
a
=
=
=
b
|
|
a
+
'
-
srgb
'
=
=
=
b
|
|
b
+
'
-
srgb
'
=
=
=
a
;
}
export
function
getFeaturesForFormats
<
T
>
(
formats
:
readonly
(
T
&
(
GPUTextureFormat
|
undefined
)
)
[
]
)
:
readonly
(
GPUFeatureName
|
undefined
)
[
]
{
return
Array
.
from
(
new
Set
(
formats
.
map
(
f
=
>
(
f
?
kTextureFormatInfo
[
f
]
.
feature
:
undefined
)
)
)
)
;
}
export
function
filterFormatsByFeature
<
T
>
(
feature
:
GPUFeatureName
|
undefined
formats
:
readonly
(
T
&
(
GPUTextureFormat
|
undefined
)
)
[
]
)
:
readonly
(
T
&
(
GPUTextureFormat
|
undefined
)
)
[
]
{
return
formats
.
filter
(
f
=
>
f
=
=
=
undefined
|
|
kTextureFormatInfo
[
f
]
.
feature
=
=
=
feature
)
;
}
export
const
kFeaturesForFormats
=
getFeaturesForFormats
(
kTextureFormats
)
;
