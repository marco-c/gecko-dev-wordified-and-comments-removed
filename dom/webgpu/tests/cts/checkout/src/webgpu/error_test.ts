import
{
Fixture
}
from
'
.
.
/
common
/
framework
/
fixture
.
js
'
;
import
{
getGPU
}
from
'
.
.
/
common
/
util
/
navigator_gpu
.
js
'
;
import
{
assert
raceWithRejectOnTimeout
}
from
'
.
.
/
common
/
util
/
util
.
js
'
;
export
class
ErrorTest
extends
Fixture
{
_device
:
GPUDevice
|
undefined
=
undefined
;
get
device
(
)
:
GPUDevice
{
assert
(
this
.
_device
!
=
=
undefined
)
;
return
this
.
_device
;
}
override
async
init
(
)
:
Promise
<
void
>
{
await
super
.
init
(
)
;
const
gpu
=
getGPU
(
this
.
rec
)
;
const
adapter
=
await
gpu
.
requestAdapter
(
)
;
assert
(
adapter
!
=
=
null
)
;
const
device
=
await
this
.
requestDeviceTracked
(
adapter
{
requiredLimits
:
{
maxTextureDimension2D
:
adapter
.
limits
.
maxTextureDimension2D
maxTextureArrayLayers
:
adapter
.
limits
.
maxTextureArrayLayers
}
}
)
;
assert
(
device
!
=
=
null
)
;
this
.
_device
=
device
;
}
generateError
(
filter
:
GPUErrorFilter
)
:
void
{
switch
(
filter
)
{
case
'
out
-
of
-
memory
'
:
this
.
trackForCleanup
(
this
.
device
.
createTexture
(
{
format
:
'
rgba32float
'
usage
:
GPUTextureUsage
.
COPY_DST
size
:
[
this
.
device
.
limits
.
maxTextureDimension2D
this
.
device
.
limits
.
maxTextureDimension2D
this
.
device
.
limits
.
maxTextureArrayLayers
]
}
)
)
;
break
;
case
'
validation
'
:
this
.
trackForCleanup
(
this
.
device
.
createBuffer
(
{
size
:
1024
usage
:
0xffff
}
)
)
;
break
;
}
this
.
device
.
queue
.
submit
(
[
]
)
;
}
isInstanceOfError
(
filter
:
GPUErrorFilter
error
:
GPUError
|
null
)
:
boolean
{
switch
(
filter
)
{
case
'
out
-
of
-
memory
'
:
return
error
instanceof
GPUOutOfMemoryError
;
case
'
validation
'
:
return
error
instanceof
GPUValidationError
;
case
'
internal
'
:
return
error
instanceof
GPUInternalError
;
}
}
async
chunkedPopManyErrorScopes
(
count
:
number
)
{
const
promises
=
[
]
;
for
(
let
i
=
0
;
i
<
count
;
i
+
+
)
{
promises
.
push
(
this
.
device
.
popErrorScope
(
)
)
;
if
(
promises
.
length
>
=
200
)
{
this
.
expect
(
(
await
Promise
.
all
(
promises
)
)
.
every
(
e
=
>
e
=
=
=
null
)
)
;
promises
.
length
=
0
;
}
}
this
.
expect
(
(
await
Promise
.
all
(
promises
)
)
.
every
(
e
=
>
e
=
=
=
null
)
)
;
}
async
expectUncapturedError
(
fn
:
Function
useOnuncapturederror
=
false
)
:
Promise
<
GPUUncapturedErrorEvent
>
{
return
this
.
immediateAsyncExpectation
(
(
)
=
>
{
const
promise
:
Promise
<
GPUUncapturedErrorEvent
>
=
new
Promise
(
resolve
=
>
{
const
eventListener
=
(
event
:
GPUUncapturedErrorEvent
)
=
>
{
if
(
useOnuncapturederror
)
{
this
.
device
.
onuncapturederror
=
null
;
}
else
{
this
.
device
.
removeEventListener
(
'
uncapturederror
'
eventListener
)
;
}
this
.
debug
(
Got
uncaptured
error
event
with
{
event
.
error
}
)
;
resolve
(
event
)
;
}
;
if
(
useOnuncapturederror
)
{
this
.
device
.
onuncapturederror
=
eventListener
;
}
else
{
this
.
device
.
addEventListener
(
'
uncapturederror
'
eventListener
{
once
:
true
}
)
;
}
}
)
;
fn
(
)
;
const
kTimeoutMS
=
1000
;
return
raceWithRejectOnTimeout
(
promise
kTimeoutMS
'
Timeout
occurred
waiting
for
uncaptured
error
'
)
;
}
)
;
}
}
