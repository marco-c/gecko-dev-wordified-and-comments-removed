import
{
Fixture
SubcaseBatchState
TestParams
}
from
'
.
.
/
common
/
framework
/
fixture
.
js
'
;
import
{
assert
range
TypedArrayBufferView
TypedArrayBufferViewConstructor
unreachable
}
from
'
.
.
/
common
/
util
/
util
.
js
'
;
import
{
EncodableTextureFormat
SizedTextureFormat
kTextureFormatInfo
kQueryTypeInfo
resolvePerAspectFormat
}
from
'
.
/
capability_info
.
js
'
;
import
{
makeBufferWithContents
}
from
'
.
/
util
/
buffer
.
js
'
;
import
{
checkElementsEqual
checkElementsBetween
checkElementsFloat16Between
}
from
'
.
/
util
/
check_contents
.
js
'
;
import
{
CommandBufferMaker
EncoderType
}
from
'
.
/
util
/
command_buffer_maker
.
js
'
;
import
{
ScalarType
}
from
'
.
/
util
/
conversion
.
js
'
;
import
{
DevicePool
DeviceProvider
UncanonicalizedDeviceDescriptor
}
from
'
.
/
util
/
device_pool
.
js
'
;
import
{
align
roundDown
}
from
'
.
/
util
/
math
.
js
'
;
import
{
makeTextureWithContents
}
from
'
.
/
util
/
texture
.
js
'
;
import
{
getTextureCopyLayout
getTextureSubCopyLayout
LayoutOptions
as
TextureLayoutOptions
}
from
'
.
/
util
/
texture
/
layout
.
js
'
;
import
{
PerTexelComponent
kTexelRepresentationInfo
}
from
'
.
/
util
/
texture
/
texel_data
.
js
'
;
import
{
TexelView
}
from
'
.
/
util
/
texture
/
texel_view
.
js
'
;
const
devicePool
=
new
DevicePool
(
)
;
const
mismatchedDevicePool
=
new
DevicePool
(
)
;
const
kResourceStateValues
=
[
'
valid
'
'
invalid
'
'
destroyed
'
]
as
const
;
export
type
ResourceState
=
typeof
kResourceStateValues
[
number
]
;
export
const
kResourceStates
:
readonly
ResourceState
[
]
=
kResourceStateValues
;
type
DeviceSelectionDescriptor
=
|
UncanonicalizedDeviceDescriptor
|
GPUFeatureName
|
undefined
|
Array
<
GPUFeatureName
|
undefined
>
;
export
function
initUncanonicalizedDeviceDescriptor
(
descriptor
:
DeviceSelectionDescriptor
)
:
UncanonicalizedDeviceDescriptor
|
undefined
{
if
(
typeof
descriptor
=
=
=
'
string
'
)
{
return
{
requiredFeatures
:
[
descriptor
]
}
;
}
else
if
(
descriptor
instanceof
Array
)
{
return
{
requiredFeatures
:
descriptor
.
filter
(
f
=
>
f
!
=
=
undefined
)
as
GPUFeatureName
[
]
}
;
}
else
{
return
descriptor
;
}
}
export
class
GPUTestSubcaseBatchState
extends
SubcaseBatchState
{
private
provider
:
Promise
<
DeviceProvider
>
|
undefined
;
private
mismatchedProvider
:
Promise
<
DeviceProvider
>
|
undefined
;
async
postInit
(
)
:
Promise
<
void
>
{
await
this
.
acquireProvider
(
)
;
}
async
finalize
(
)
:
Promise
<
void
>
{
await
super
.
finalize
(
)
;
await
Promise
.
all
(
[
this
.
provider
?
.
then
(
x
=
>
devicePool
.
release
(
x
)
)
this
.
mismatchedProvider
?
.
then
(
x
=
>
devicePool
.
release
(
x
)
)
]
)
;
}
acquireProvider
(
)
:
Promise
<
DeviceProvider
>
{
if
(
this
.
provider
=
=
=
undefined
)
{
this
.
selectDeviceOrSkipTestCase
(
undefined
)
;
}
assert
(
this
.
provider
!
=
=
undefined
)
;
return
this
.
provider
;
}
selectDeviceOrSkipTestCase
(
descriptor
:
DeviceSelectionDescriptor
)
:
void
{
assert
(
this
.
provider
=
=
=
undefined
"
Can
'
t
selectDeviceOrSkipTestCase
(
)
multiple
times
"
)
;
this
.
provider
=
devicePool
.
acquire
(
initUncanonicalizedDeviceDescriptor
(
descriptor
)
)
;
this
.
provider
.
catch
(
(
)
=
>
{
}
)
;
}
selectDeviceForTextureFormatOrSkipTestCase
(
formats
:
GPUTextureFormat
|
undefined
|
(
GPUTextureFormat
|
undefined
)
[
]
)
:
void
{
if
(
!
Array
.
isArray
(
formats
)
)
{
formats
=
[
formats
]
;
}
const
features
=
new
Set
<
GPUFeatureName
|
undefined
>
(
)
;
for
(
const
format
of
formats
)
{
if
(
format
!
=
=
undefined
)
{
features
.
add
(
kTextureFormatInfo
[
format
]
.
feature
)
;
}
}
this
.
selectDeviceOrSkipTestCase
(
Array
.
from
(
features
)
)
;
}
selectDeviceForQueryTypeOrSkipTestCase
(
types
:
GPUQueryType
|
GPUQueryType
[
]
)
:
void
{
if
(
!
Array
.
isArray
(
types
)
)
{
types
=
[
types
]
;
}
const
features
=
types
.
map
(
t
=
>
kQueryTypeInfo
[
t
]
.
feature
)
;
this
.
selectDeviceOrSkipTestCase
(
features
)
;
}
acquireMismatchedProvider
(
)
:
Promise
<
DeviceProvider
>
|
undefined
{
return
this
.
mismatchedProvider
;
}
selectMismatchedDeviceOrSkipTestCase
(
descriptor
:
DeviceSelectionDescriptor
)
:
void
{
assert
(
this
.
mismatchedProvider
=
=
=
undefined
"
Can
'
t
selectMismatchedDeviceOrSkipTestCase
(
)
multiple
times
"
)
;
this
.
mismatchedProvider
=
mismatchedDevicePool
.
acquire
(
initUncanonicalizedDeviceDescriptor
(
descriptor
)
)
;
this
.
mismatchedProvider
.
catch
(
(
)
=
>
{
}
)
;
}
}
export
class
GPUTest
extends
Fixture
<
GPUTestSubcaseBatchState
>
{
public
static
MakeSharedState
(
params
:
TestParams
)
:
GPUTestSubcaseBatchState
{
return
new
GPUTestSubcaseBatchState
(
params
)
;
}
private
provider
:
DeviceProvider
|
undefined
;
private
mismatchedProvider
:
DeviceProvider
|
undefined
;
async
init
(
)
{
await
super
.
init
(
)
;
this
.
provider
=
await
this
.
sharedState
.
acquireProvider
(
)
;
this
.
mismatchedProvider
=
await
this
.
sharedState
.
acquireMismatchedProvider
(
)
;
}
get
device
(
)
:
GPUDevice
{
assert
(
this
.
provider
!
=
=
undefined
'
internal
error
:
GPUDevice
missing
?
'
)
;
return
this
.
provider
.
device
;
}
get
mismatchedDevice
(
)
:
GPUDevice
{
assert
(
this
.
mismatchedProvider
!
=
=
undefined
'
selectMismatchedDeviceOrSkipTestCase
was
not
called
in
beforeAllSubcases
'
)
;
return
this
.
mismatchedProvider
.
device
;
}
get
queue
(
)
:
GPUQueue
{
return
this
.
device
.
queue
;
}
private
createCopyForMapRead
(
src
:
GPUBuffer
srcOffset
:
number
size
:
number
)
:
GPUBuffer
{
assert
(
srcOffset
%
4
=
=
=
0
)
;
assert
(
size
%
4
=
=
=
0
)
;
const
dst
=
this
.
device
.
createBuffer
(
{
size
usage
:
GPUBufferUsage
.
MAP_READ
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
dst
)
;
const
c
=
this
.
device
.
createCommandEncoder
(
)
;
c
.
copyBufferToBuffer
(
src
srcOffset
dst
0
size
)
;
this
.
queue
.
submit
(
[
c
.
finish
(
)
]
)
;
return
dst
;
}
private
createAlignedCopyForMapRead
(
src
:
GPUBuffer
size
:
number
offset
:
number
)
:
{
mappable
:
GPUBuffer
;
subarrayByteStart
:
number
}
{
const
alignedOffset
=
roundDown
(
offset
4
)
;
const
subarrayByteStart
=
offset
-
alignedOffset
;
const
alignedSize
=
align
(
size
+
subarrayByteStart
4
)
;
const
mappable
=
this
.
createCopyForMapRead
(
src
alignedOffset
alignedSize
)
;
return
{
mappable
subarrayByteStart
}
;
}
async
readGPUBufferRangeTyped
<
T
extends
TypedArrayBufferView
>
(
src
:
GPUBuffer
{
srcByteOffset
=
0
method
=
'
copy
'
type
typedLength
}
:
{
srcByteOffset
?
:
number
;
method
?
:
'
copy
'
|
'
map
'
;
type
:
TypedArrayBufferViewConstructor
<
T
>
;
typedLength
:
number
;
}
)
:
Promise
<
{
data
:
T
;
cleanup
(
)
:
void
}
>
{
assert
(
srcByteOffset
%
type
.
BYTES_PER_ELEMENT
=
=
=
0
'
srcByteOffset
must
be
a
multiple
of
BYTES_PER_ELEMENT
'
)
;
const
byteLength
=
typedLength
*
type
.
BYTES_PER_ELEMENT
;
let
mappable
:
GPUBuffer
;
let
mapOffset
:
number
|
undefined
mapSize
:
number
|
undefined
subarrayByteStart
:
number
;
if
(
method
=
=
=
'
copy
'
)
{
(
{
mappable
subarrayByteStart
}
=
this
.
createAlignedCopyForMapRead
(
src
byteLength
srcByteOffset
)
)
;
}
else
if
(
method
=
=
=
'
map
'
)
{
mappable
=
src
;
mapOffset
=
roundDown
(
srcByteOffset
8
)
;
mapSize
=
align
(
byteLength
4
)
;
subarrayByteStart
=
srcByteOffset
-
mapOffset
;
}
else
{
unreachable
(
)
;
}
assert
(
subarrayByteStart
%
type
.
BYTES_PER_ELEMENT
=
=
=
0
)
;
const
subarrayStart
=
subarrayByteStart
/
type
.
BYTES_PER_ELEMENT
;
await
mappable
.
mapAsync
(
GPUMapMode
.
READ
mapOffset
mapSize
)
;
const
mapped
=
new
type
(
mappable
.
getMappedRange
(
mapOffset
mapSize
)
)
;
const
data
=
mapped
.
subarray
(
subarrayStart
typedLength
)
as
T
;
return
{
data
cleanup
(
)
{
mappable
.
unmap
(
)
;
mappable
.
destroy
(
)
;
}
}
;
}
expectGPUBufferValuesPassCheck
<
T
extends
TypedArrayBufferView
>
(
src
:
GPUBuffer
check
:
(
actual
:
T
)
=
>
Error
|
undefined
{
srcByteOffset
=
0
type
typedLength
method
=
'
copy
'
mode
=
'
fail
'
}
:
{
srcByteOffset
?
:
number
;
type
:
TypedArrayBufferViewConstructor
<
T
>
;
typedLength
:
number
;
method
?
:
'
copy
'
|
'
map
'
;
mode
?
:
'
fail
'
|
'
warn
'
;
}
)
{
const
readbackPromise
=
this
.
readGPUBufferRangeTyped
(
src
{
srcByteOffset
type
typedLength
method
}
)
;
this
.
eventualAsyncExpectation
(
async
niceStack
=
>
{
const
readback
=
await
readbackPromise
;
this
.
expectOK
(
check
(
readback
.
data
)
{
mode
niceStack
}
)
;
readback
.
cleanup
(
)
;
}
)
;
}
expectGPUBufferValuesEqual
(
src
:
GPUBuffer
expected
:
TypedArrayBufferView
srcByteOffset
:
number
=
0
{
method
=
'
copy
'
mode
=
'
fail
'
}
:
{
method
?
:
'
copy
'
|
'
map
'
;
mode
?
:
'
fail
'
|
'
warn
'
}
=
{
}
)
:
void
{
this
.
expectGPUBufferValuesPassCheck
(
src
a
=
>
checkElementsEqual
(
a
expected
)
{
srcByteOffset
type
:
expected
.
constructor
as
TypedArrayBufferViewConstructor
typedLength
:
expected
.
length
method
mode
}
)
;
}
expectGPUBufferRepeatsSingleValue
(
buffer
:
GPUBuffer
{
expectedValue
numRows
minBytesPerRow
bytesPerRow
}
:
{
expectedValue
:
ArrayBuffer
;
numRows
:
number
;
minBytesPerRow
:
number
;
bytesPerRow
:
number
;
}
)
{
const
valueSize
=
expectedValue
.
byteLength
;
assert
(
valueSize
=
=
=
1
|
|
valueSize
=
=
=
2
|
|
valueSize
%
4
=
=
=
0
)
;
assert
(
minBytesPerRow
%
valueSize
=
=
=
0
)
;
assert
(
bytesPerRow
%
4
=
=
=
0
)
;
const
kMaxBufferSizeToCheckOnCpu
=
256
*
1024
;
const
bufferSize
=
bytesPerRow
*
(
numRows
-
1
)
+
minBytesPerRow
;
if
(
bufferSize
<
=
kMaxBufferSizeToCheckOnCpu
)
{
const
valueBytes
=
Array
.
from
(
new
Uint8Array
(
expectedValue
)
)
;
const
rowValues
=
new
Array
(
minBytesPerRow
/
valueSize
)
.
fill
(
valueBytes
)
;
const
rowBytes
=
new
Uint8Array
(
[
]
.
concat
(
.
.
.
rowValues
)
)
;
const
expectedContents
=
new
Uint8Array
(
bufferSize
)
;
range
(
numRows
row
=
>
expectedContents
.
set
(
rowBytes
row
*
bytesPerRow
)
)
;
this
.
expectGPUBufferValuesEqual
(
buffer
expectedContents
)
;
return
;
}
const
storageBuffer
=
this
.
device
.
createBuffer
(
{
size
:
bufferSize
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
storageBuffer
)
;
const
expectedDataSize
=
Math
.
max
(
4
valueSize
)
;
const
expectedDataBuffer
=
this
.
device
.
createBuffer
(
{
size
:
expectedDataSize
usage
:
GPUBufferUsage
.
STORAGE
mappedAtCreation
:
true
}
)
;
this
.
trackForCleanup
(
expectedDataBuffer
)
;
const
expectedData
=
new
Uint32Array
(
expectedDataBuffer
.
getMappedRange
(
)
)
;
if
(
valueSize
=
=
=
1
)
{
const
value
=
new
Uint8Array
(
expectedValue
)
[
0
]
;
const
values
=
new
Array
(
Math
.
min
(
4
minBytesPerRow
)
)
.
fill
(
value
)
;
const
padding
=
new
Array
(
Math
.
max
(
0
4
-
values
.
length
)
)
.
fill
(
0
)
;
const
expectedBytes
=
new
Uint8Array
(
expectedData
.
buffer
)
;
expectedBytes
.
set
(
[
.
.
.
values
.
.
.
padding
]
)
;
}
else
if
(
valueSize
=
=
=
2
)
{
const
value
=
new
Uint16Array
(
expectedValue
)
[
0
]
;
const
expectedWords
=
new
Uint16Array
(
expectedData
.
buffer
)
;
expectedWords
.
set
(
[
value
minBytesPerRow
>
2
?
value
:
0
]
)
;
}
else
{
expectedData
.
set
(
new
Uint32Array
(
expectedValue
)
)
;
}
expectedDataBuffer
.
unmap
(
)
;
const
resultBuffer
=
this
.
device
.
createBuffer
(
{
size
:
numRows
*
4
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_SRC
}
)
;
this
.
trackForCleanup
(
resultBuffer
)
;
const
readsPerRow
=
Math
.
ceil
(
minBytesPerRow
/
expectedDataSize
)
;
const
reducer
=
struct
Buffer
{
data
:
array
<
u32
>
}
;
group
(
0
)
binding
(
0
)
var
<
storage
read
>
expected
:
Buffer
;
group
(
0
)
binding
(
1
)
var
<
storage
read
>
in
:
Buffer
;
group
(
0
)
binding
(
2
)
var
<
storage
read_write
>
out
:
Buffer
;
compute
workgroup_size
(
1
)
fn
reduce
(
builtin
(
global_invocation_id
)
id
:
vec3
<
u32
>
)
{
let
rowBaseIndex
=
id
.
x
*
{
bytesPerRow
/
4
}
u
;
let
readSize
=
{
expectedDataSize
/
4
}
u
;
out
.
data
[
id
.
x
]
=
1u
;
for
(
var
i
:
u32
=
0u
;
i
<
{
readsPerRow
}
u
;
i
=
i
+
1u
)
{
let
elementBaseIndex
=
rowBaseIndex
+
i
*
readSize
;
for
(
var
j
:
u32
=
0u
;
j
<
readSize
;
j
=
j
+
1u
)
{
if
(
in
.
data
[
elementBaseIndex
+
j
]
!
=
expected
.
data
[
j
]
)
{
out
.
data
[
id
.
x
]
=
0u
;
return
;
}
}
}
}
;
const
pipeline
=
this
.
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
reducer
}
)
entryPoint
:
'
reduce
'
}
}
)
;
const
bindGroup
=
this
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
expectedDataBuffer
}
}
{
binding
:
1
resource
:
{
buffer
:
storageBuffer
}
}
{
binding
:
2
resource
:
{
buffer
:
resultBuffer
}
}
]
}
)
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
commandEncoder
.
copyBufferToBuffer
(
buffer
0
storageBuffer
0
bufferSize
)
;
const
pass
=
commandEncoder
.
beginComputePass
(
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
bindGroup
)
;
pass
.
dispatchWorkgroups
(
numRows
)
;
pass
.
end
(
)
;
this
.
device
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
const
expectedResults
=
new
Array
(
numRows
)
.
fill
(
1
)
;
this
.
expectGPUBufferValuesEqual
(
resultBuffer
new
Uint32Array
(
expectedResults
)
)
;
}
expectSingleColor
(
src
:
GPUTexture
format
:
GPUTextureFormat
{
size
exp
dimension
=
'
2d
'
slice
=
0
layout
}
:
{
size
:
[
number
number
number
]
;
exp
:
PerTexelComponent
<
number
>
;
dimension
?
:
GPUTextureDimension
;
slice
?
:
number
;
layout
?
:
TextureLayoutOptions
;
}
)
:
void
{
format
=
resolvePerAspectFormat
(
format
layout
?
.
aspect
)
;
const
{
byteLength
minBytesPerRow
bytesPerRow
rowsPerImage
mipSize
}
=
getTextureCopyLayout
(
format
dimension
size
layout
)
;
const
rep
=
kTexelRepresentationInfo
[
format
as
EncodableTextureFormat
]
;
const
expectedTexelData
=
rep
.
pack
(
rep
.
encode
(
exp
)
)
;
const
buffer
=
this
.
device
.
createBuffer
(
{
size
:
byteLength
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
buffer
)
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
commandEncoder
.
copyTextureToBuffer
(
{
texture
:
src
mipLevel
:
layout
?
.
mipLevel
origin
:
{
x
:
0
y
:
0
z
:
slice
}
aspect
:
layout
?
.
aspect
}
{
buffer
bytesPerRow
rowsPerImage
}
mipSize
)
;
this
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
this
.
expectGPUBufferRepeatsSingleValue
(
buffer
{
expectedValue
:
expectedTexelData
numRows
:
rowsPerImage
minBytesPerRow
bytesPerRow
}
)
;
}
private
readSinglePixelFrom2DTexture
(
src
:
GPUTexture
format
:
SizedTextureFormat
{
x
y
}
:
{
x
:
number
;
y
:
number
}
{
slice
=
0
layout
}
:
{
slice
?
:
number
;
layout
?
:
TextureLayoutOptions
}
)
:
GPUBuffer
{
const
{
byteLength
bytesPerRow
rowsPerImage
}
=
getTextureSubCopyLayout
(
format
[
1
1
]
layout
)
;
const
buffer
=
this
.
device
.
createBuffer
(
{
size
:
byteLength
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
buffer
)
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
commandEncoder
.
copyTextureToBuffer
(
{
texture
:
src
mipLevel
:
layout
?
.
mipLevel
origin
:
{
x
y
z
:
slice
}
}
{
buffer
bytesPerRow
rowsPerImage
}
[
1
1
]
)
;
this
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
return
buffer
;
}
expectSinglePixelIn2DTexture
(
src
:
GPUTexture
format
:
SizedTextureFormat
{
x
y
}
:
{
x
:
number
;
y
:
number
}
{
exp
slice
=
0
layout
generateWarningOnly
=
false
}
:
{
exp
:
Uint8Array
;
slice
?
:
number
;
layout
?
:
TextureLayoutOptions
;
generateWarningOnly
?
:
boolean
;
}
)
:
void
{
const
buffer
=
this
.
readSinglePixelFrom2DTexture
(
src
format
{
x
y
}
{
slice
layout
}
)
;
this
.
expectGPUBufferValuesEqual
(
buffer
exp
0
{
mode
:
generateWarningOnly
?
'
warn
'
:
'
fail
'
}
)
;
}
expectSinglePixelBetweenTwoValuesIn2DTexture
(
src
:
GPUTexture
format
:
SizedTextureFormat
{
x
y
}
:
{
x
:
number
;
y
:
number
}
{
exp
slice
=
0
layout
generateWarningOnly
=
false
checkElementsBetweenFn
=
(
act
[
a
b
]
)
=
>
checkElementsBetween
(
act
[
i
=
>
a
[
i
]
i
=
>
b
[
i
]
]
)
}
:
{
exp
:
[
TypedArrayBufferView
TypedArrayBufferView
]
;
slice
?
:
number
;
layout
?
:
TextureLayoutOptions
;
generateWarningOnly
?
:
boolean
;
checkElementsBetweenFn
?
:
(
actual
:
TypedArrayBufferView
expected
:
readonly
[
TypedArrayBufferView
TypedArrayBufferView
]
)
=
>
Error
|
undefined
;
}
)
:
void
{
assert
(
exp
[
0
]
.
constructor
=
=
=
exp
[
1
]
.
constructor
)
;
const
constructor
=
exp
[
0
]
.
constructor
as
TypedArrayBufferViewConstructor
;
assert
(
exp
[
0
]
.
length
=
=
=
exp
[
1
]
.
length
)
;
const
typedLength
=
exp
[
0
]
.
length
;
const
buffer
=
this
.
readSinglePixelFrom2DTexture
(
src
format
{
x
y
}
{
slice
layout
}
)
;
this
.
expectGPUBufferValuesPassCheck
(
buffer
a
=
>
checkElementsBetweenFn
(
a
exp
)
{
type
:
constructor
typedLength
mode
:
generateWarningOnly
?
'
warn
'
:
'
fail
'
}
)
;
}
expectSinglePixelBetweenTwoValuesFloat16In2DTexture
(
src
:
GPUTexture
format
:
SizedTextureFormat
{
x
y
}
:
{
x
:
number
;
y
:
number
}
{
exp
slice
=
0
layout
generateWarningOnly
=
false
}
:
{
exp
:
[
Uint16Array
Uint16Array
]
;
slice
?
:
number
;
layout
?
:
TextureLayoutOptions
;
generateWarningOnly
?
:
boolean
;
}
)
:
void
{
this
.
expectSinglePixelBetweenTwoValuesIn2DTexture
(
src
format
{
x
y
}
{
exp
slice
layout
generateWarningOnly
checkElementsBetweenFn
:
checkElementsFloat16Between
}
)
;
}
copySinglePixelTextureToBufferUsingComputePass
(
type
:
ScalarType
componentCount
:
number
textureView
:
GPUTextureView
sampleCount
:
number
)
:
GPUBuffer
{
const
textureSrcCode
=
sampleCount
=
=
=
1
?
group
(
0
)
binding
(
0
)
var
src
:
texture_2d
<
{
type
}
>
;
:
group
(
0
)
binding
(
0
)
var
src
:
texture_multisampled_2d
<
{
type
}
>
;
;
const
code
=
struct
Buffer
{
data
:
array
<
{
type
}
>
}
;
{
textureSrcCode
}
group
(
0
)
binding
(
1
)
var
<
storage
read_write
>
dst
:
Buffer
;
compute
workgroup_size
(
1
)
fn
main
(
)
{
var
coord
=
vec2
<
i32
>
(
0
0
)
;
for
(
var
sampleIndex
=
0
;
sampleIndex
<
{
sampleCount
}
;
sampleIndex
=
sampleIndex
+
1
)
{
let
o
=
sampleIndex
*
{
componentCount
}
;
let
v
=
textureLoad
(
src
coord
sampleIndex
)
;
for
(
var
component
=
0
;
component
<
{
componentCount
}
;
component
=
component
+
1
)
{
dst
.
data
[
o
+
component
]
=
v
[
component
]
;
}
}
}
;
const
computePipeline
=
this
.
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
}
)
entryPoint
:
'
main
'
}
}
)
;
const
storageBuffer
=
this
.
device
.
createBuffer
(
{
size
:
sampleCount
*
type
.
size
*
componentCount
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
COPY_SRC
}
)
;
this
.
trackForCleanup
(
storageBuffer
)
;
const
uniformBindGroup
=
this
.
device
.
createBindGroup
(
{
layout
:
computePipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
textureView
}
{
binding
:
1
resource
:
{
buffer
:
storageBuffer
}
}
]
}
)
;
const
encoder
=
this
.
device
.
createCommandEncoder
(
)
;
const
pass
=
encoder
.
beginComputePass
(
)
;
pass
.
setPipeline
(
computePipeline
)
;
pass
.
setBindGroup
(
0
uniformBindGroup
)
;
pass
.
dispatchWorkgroups
(
1
)
;
pass
.
end
(
)
;
this
.
device
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
return
storageBuffer
;
}
expectGPUError
<
R
>
(
filter
:
GPUErrorFilter
fn
:
(
)
=
>
R
shouldError
:
boolean
=
true
)
:
R
{
if
(
!
shouldError
)
{
return
fn
(
)
;
}
this
.
device
.
pushErrorScope
(
filter
)
;
const
returnValue
=
fn
(
)
;
const
promise
=
this
.
device
.
popErrorScope
(
)
;
this
.
eventualAsyncExpectation
(
async
niceStack
=
>
{
const
error
=
await
promise
;
let
failed
=
false
;
switch
(
filter
)
{
case
'
out
-
of
-
memory
'
:
failed
=
!
(
error
instanceof
GPUOutOfMemoryError
)
;
break
;
case
'
validation
'
:
failed
=
!
(
error
instanceof
GPUValidationError
)
;
break
;
}
if
(
failed
)
{
niceStack
.
message
=
Expected
{
filter
}
error
;
this
.
rec
.
expectationFailed
(
niceStack
)
;
}
else
{
niceStack
.
message
=
Captured
{
filter
}
error
;
if
(
error
instanceof
GPUValidationError
)
{
niceStack
.
message
+
=
-
{
error
.
message
}
;
}
this
.
rec
.
debug
(
niceStack
)
;
}
}
)
;
return
returnValue
;
}
expectValidationError
(
fn
:
(
)
=
>
void
shouldError
:
boolean
=
true
)
:
void
{
if
(
shouldError
)
{
this
.
device
.
pushErrorScope
(
'
validation
'
)
;
}
const
returnValue
=
fn
(
)
as
unknown
;
assert
(
returnValue
=
=
=
undefined
'
expectValidationError
callback
should
not
return
a
value
(
or
be
async
)
'
)
;
if
(
shouldError
)
{
const
promise
=
this
.
device
.
popErrorScope
(
)
;
this
.
eventualAsyncExpectation
(
async
niceStack
=
>
{
const
gpuValidationError
=
await
promise
;
if
(
!
gpuValidationError
)
{
niceStack
.
message
=
'
Validation
succeeded
unexpectedly
.
'
;
this
.
rec
.
validationFailed
(
niceStack
)
;
}
else
if
(
gpuValidationError
instanceof
GPUValidationError
)
{
niceStack
.
message
=
Validation
failed
as
expected
-
{
gpuValidationError
.
message
}
;
this
.
rec
.
debug
(
niceStack
)
;
}
}
)
;
}
}
expectDeviceLost
(
reason
:
GPUDeviceLostReason
)
:
void
{
assert
(
this
.
provider
!
=
=
undefined
'
internal
error
:
GPUDevice
missing
?
'
)
;
this
.
provider
.
expectDeviceLost
(
reason
)
;
}
makeBufferWithContents
(
dataArray
:
TypedArrayBufferView
usage
:
GPUBufferUsageFlags
)
:
GPUBuffer
{
return
this
.
trackForCleanup
(
makeBufferWithContents
(
this
.
device
dataArray
usage
)
)
;
}
makeTextureWithContents
(
texelView
:
TexelView
desc
:
Omit
<
GPUTextureDescriptor
'
format
'
>
)
:
GPUTexture
{
return
this
.
trackForCleanup
(
makeTextureWithContents
(
this
.
device
texelView
desc
)
)
;
}
createTexture2DWithMipmaps
(
mipmapDataArray
:
TypedArrayBufferView
[
]
)
:
GPUTexture
{
const
format
=
'
rgba8unorm
'
;
const
mipLevelCount
=
mipmapDataArray
.
length
;
const
textureSizeMipmap0
=
1
<
<
(
mipLevelCount
-
1
)
;
const
texture
=
this
.
device
.
createTexture
(
{
mipLevelCount
size
:
{
width
:
textureSizeMipmap0
height
:
textureSizeMipmap0
depthOrArrayLayers
:
1
}
format
usage
:
GPUTextureUsage
.
COPY_DST
|
GPUTextureUsage
.
TEXTURE_BINDING
}
)
;
this
.
trackForCleanup
(
texture
)
;
const
textureEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
for
(
let
i
=
0
;
i
<
mipLevelCount
;
i
+
+
)
{
const
{
byteLength
bytesPerRow
rowsPerImage
mipSize
}
=
getTextureCopyLayout
(
format
'
2d
'
[
textureSizeMipmap0
textureSizeMipmap0
1
]
{
mipLevel
:
i
}
)
;
const
data
:
Uint8Array
=
new
Uint8Array
(
byteLength
)
;
const
mipLevelData
=
mipmapDataArray
[
i
]
;
assert
(
rowsPerImage
=
=
=
mipSize
[
0
]
)
;
for
(
let
r
=
0
;
r
<
rowsPerImage
;
r
+
+
)
{
const
o
=
r
*
bytesPerRow
;
for
(
let
c
=
o
end
=
o
+
mipSize
[
1
]
*
4
;
c
<
end
;
c
+
=
4
)
{
data
[
c
]
=
mipLevelData
[
0
]
;
data
[
c
+
1
]
=
mipLevelData
[
1
]
;
data
[
c
+
2
]
=
mipLevelData
[
2
]
;
data
[
c
+
3
]
=
mipLevelData
[
3
]
;
}
}
const
buffer
=
this
.
makeBufferWithContents
(
data
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
COPY_DST
)
;
textureEncoder
.
copyBufferToTexture
(
{
buffer
bytesPerRow
rowsPerImage
}
{
texture
mipLevel
:
i
origin
:
[
0
0
0
]
}
mipSize
)
;
}
this
.
device
.
queue
.
submit
(
[
textureEncoder
.
finish
(
)
]
)
;
return
texture
;
}
createEncoder
<
T
extends
EncoderType
>
(
encoderType
:
T
{
attachmentInfo
occlusionQuerySet
}
:
{
attachmentInfo
?
:
GPURenderBundleEncoderDescriptor
;
occlusionQuerySet
?
:
GPUQuerySet
;
}
=
{
}
)
:
CommandBufferMaker
<
T
>
{
const
fullAttachmentInfo
=
{
colorFormats
:
[
'
rgba8unorm
'
]
sampleCount
:
1
.
.
.
attachmentInfo
}
as
const
;
switch
(
encoderType
)
{
case
'
non
-
pass
'
:
{
const
encoder
=
this
.
device
.
createCommandEncoder
(
)
;
return
new
CommandBufferMaker
(
this
encoder
(
)
=
>
{
return
encoder
.
finish
(
)
;
}
)
;
}
case
'
render
bundle
'
:
{
const
device
=
this
.
device
;
const
rbEncoder
=
device
.
createRenderBundleEncoder
(
fullAttachmentInfo
)
;
const
pass
=
this
.
createEncoder
(
'
render
pass
'
{
attachmentInfo
}
)
;
return
new
CommandBufferMaker
(
this
rbEncoder
(
)
=
>
{
pass
.
encoder
.
executeBundles
(
[
rbEncoder
.
finish
(
)
]
)
;
return
pass
.
finish
(
)
;
}
)
;
}
case
'
compute
pass
'
:
{
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
const
encoder
=
commandEncoder
.
beginComputePass
(
)
;
return
new
CommandBufferMaker
(
this
encoder
(
)
=
>
{
encoder
.
end
(
)
;
return
commandEncoder
.
finish
(
)
;
}
)
;
}
case
'
render
pass
'
:
{
const
makeAttachmentView
=
(
format
:
GPUTextureFormat
)
=
>
this
.
trackForCleanup
(
this
.
device
.
createTexture
(
{
size
:
[
16
16
1
]
format
usage
:
GPUTextureUsage
.
RENDER_ATTACHMENT
sampleCount
:
fullAttachmentInfo
.
sampleCount
}
)
)
.
createView
(
)
;
let
depthStencilAttachment
:
GPURenderPassDepthStencilAttachment
|
undefined
=
undefined
;
if
(
fullAttachmentInfo
.
depthStencilFormat
!
=
=
undefined
)
{
depthStencilAttachment
=
{
view
:
makeAttachmentView
(
fullAttachmentInfo
.
depthStencilFormat
)
depthReadOnly
:
fullAttachmentInfo
.
depthReadOnly
stencilReadOnly
:
fullAttachmentInfo
.
stencilReadOnly
}
;
if
(
kTextureFormatInfo
[
fullAttachmentInfo
.
depthStencilFormat
]
.
depth
&
&
!
fullAttachmentInfo
.
depthReadOnly
)
{
depthStencilAttachment
.
depthClearValue
=
0
;
depthStencilAttachment
.
depthLoadOp
=
'
clear
'
;
depthStencilAttachment
.
depthStoreOp
=
'
discard
'
;
}
if
(
kTextureFormatInfo
[
fullAttachmentInfo
.
depthStencilFormat
]
.
stencil
&
&
!
fullAttachmentInfo
.
stencilReadOnly
)
{
depthStencilAttachment
.
stencilClearValue
=
1
;
depthStencilAttachment
.
stencilLoadOp
=
'
clear
'
;
depthStencilAttachment
.
stencilStoreOp
=
'
discard
'
;
}
}
const
passDesc
:
GPURenderPassDescriptor
=
{
colorAttachments
:
Array
.
from
(
fullAttachmentInfo
.
colorFormats
format
=
>
format
?
{
view
:
makeAttachmentView
(
format
)
clearValue
:
[
0
0
0
0
]
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
:
null
)
depthStencilAttachment
occlusionQuerySet
}
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
const
encoder
=
commandEncoder
.
beginRenderPass
(
passDesc
)
;
return
new
CommandBufferMaker
(
this
encoder
(
)
=
>
{
encoder
.
end
(
)
;
return
commandEncoder
.
finish
(
)
;
}
)
;
}
}
unreachable
(
)
;
}
}
