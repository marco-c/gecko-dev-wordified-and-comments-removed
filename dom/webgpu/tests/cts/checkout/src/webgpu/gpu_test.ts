import
{
Fixture
FixtureClass
FixtureClassInterface
FixtureClassWithMixin
SkipTestCase
SubcaseBatchState
TestCaseRecorder
TestParams
}
from
'
.
.
/
common
/
framework
/
fixture
.
js
'
;
import
{
globalTestConfig
}
from
'
.
.
/
common
/
framework
/
test_config
.
js
'
;
import
{
getGPU
}
from
'
.
.
/
common
/
util
/
navigator_gpu
.
js
'
;
import
{
assert
makeValueTestVariant
memcpy
range
ValueTestVariant
TypedArrayBufferView
TypedArrayBufferViewConstructor
unreachable
}
from
'
.
.
/
common
/
util
/
util
.
js
'
;
import
{
getDefaultLimits
kLimits
kQueryTypeInfo
WGSLLanguageFeature
}
from
'
.
/
capability_info
.
js
'
;
import
{
InterpolationType
InterpolationSampling
}
from
'
.
/
constants
.
js
'
;
import
{
kTextureFormatInfo
kEncodableTextureFormats
resolvePerAspectFormat
SizedTextureFormat
EncodableTextureFormat
isCompressedTextureFormat
ColorTextureFormat
isTextureFormatUsableAsStorageFormat
}
from
'
.
/
format_info
.
js
'
;
import
{
makeBufferWithContents
}
from
'
.
/
util
/
buffer
.
js
'
;
import
{
checkElementsEqual
checkElementsBetween
}
from
'
.
/
util
/
check_contents
.
js
'
;
import
{
CommandBufferMaker
EncoderType
}
from
'
.
/
util
/
command_buffer_maker
.
js
'
;
import
{
ScalarType
}
from
'
.
/
util
/
conversion
.
js
'
;
import
{
DevicePool
DeviceProvider
UncanonicalizedDeviceDescriptor
}
from
'
.
/
util
/
device_pool
.
js
'
;
import
{
align
roundDown
}
from
'
.
/
util
/
math
.
js
'
;
import
{
physicalMipSizeFromTexture
virtualMipSize
}
from
'
.
/
util
/
texture
/
base
.
js
'
;
import
{
bytesInACompleteRow
getTextureCopyLayout
getTextureSubCopyLayout
LayoutOptions
as
TextureLayoutOptions
}
from
'
.
/
util
/
texture
/
layout
.
js
'
;
import
{
PerTexelComponent
kTexelRepresentationInfo
}
from
'
.
/
util
/
texture
/
texel_data
.
js
'
;
import
{
TexelView
}
from
'
.
/
util
/
texture
/
texel_view
.
js
'
;
import
{
PerPixelComparison
PixelExpectation
TexelCompareOptions
textureContentIsOKByT2B
}
from
'
.
/
util
/
texture
/
texture_ok
.
js
'
;
import
{
createTextureFromTexelView
createTextureFromTexelViews
}
from
'
.
/
util
/
texture
.
js
'
;
import
{
reifyExtent3D
reifyOrigin3D
}
from
'
.
/
util
/
unions
.
js
'
;
const
devicePool
=
new
DevicePool
(
)
;
const
mismatchedDevicePool
=
new
DevicePool
(
)
;
const
kResourceStateValues
=
[
'
valid
'
'
invalid
'
'
destroyed
'
]
as
const
;
export
type
ResourceState
=
(
typeof
kResourceStateValues
)
[
number
]
;
export
const
kResourceStates
:
readonly
ResourceState
[
]
=
kResourceStateValues
;
type
DeviceSelectionDescriptor
=
|
UncanonicalizedDeviceDescriptor
|
GPUFeatureName
|
undefined
|
Array
<
GPUFeatureName
|
undefined
>
;
export
function
initUncanonicalizedDeviceDescriptor
(
descriptor
:
DeviceSelectionDescriptor
)
:
UncanonicalizedDeviceDescriptor
|
undefined
{
if
(
typeof
descriptor
=
=
=
'
string
'
)
{
return
{
requiredFeatures
:
[
descriptor
]
}
;
}
else
if
(
descriptor
instanceof
Array
)
{
return
{
requiredFeatures
:
descriptor
.
filter
(
f
=
>
f
!
=
=
undefined
)
as
GPUFeatureName
[
]
}
;
}
else
{
return
descriptor
;
}
}
export
class
GPUTestSubcaseBatchState
extends
SubcaseBatchState
{
private
provider
:
Promise
<
DeviceProvider
>
|
undefined
;
private
mismatchedProvider
:
Promise
<
DeviceProvider
>
|
undefined
;
override
async
postInit
(
)
:
Promise
<
void
>
{
await
this
.
acquireProvider
(
)
;
}
override
async
finalize
(
)
:
Promise
<
void
>
{
await
super
.
finalize
(
)
;
await
Promise
.
all
(
[
this
.
provider
?
.
then
(
x
=
>
devicePool
.
release
(
x
)
)
this
.
mismatchedProvider
?
.
then
(
x
=
>
devicePool
.
release
(
x
)
)
]
)
;
}
acquireProvider
(
)
:
Promise
<
DeviceProvider
>
{
if
(
this
.
provider
=
=
=
undefined
)
{
this
.
selectDeviceOrSkipTestCase
(
undefined
)
;
}
assert
(
this
.
provider
!
=
=
undefined
)
;
return
this
.
provider
;
}
get
isCompatibility
(
)
{
return
globalTestConfig
.
compatibility
;
}
getDefaultLimits
(
)
{
return
getDefaultLimits
(
this
.
isCompatibility
?
'
compatibility
'
:
'
core
'
)
;
}
selectDeviceOrSkipTestCase
(
descriptor
:
DeviceSelectionDescriptor
)
:
void
{
assert
(
this
.
provider
=
=
=
undefined
"
Can
'
t
selectDeviceOrSkipTestCase
(
)
multiple
times
"
)
;
this
.
provider
=
devicePool
.
acquire
(
this
.
recorder
initUncanonicalizedDeviceDescriptor
(
descriptor
)
)
;
this
.
provider
.
catch
(
(
)
=
>
{
}
)
;
}
selectDeviceForTextureFormatOrSkipTestCase
(
formats
:
GPUTextureFormat
|
undefined
|
(
GPUTextureFormat
|
undefined
)
[
]
)
:
void
{
if
(
!
Array
.
isArray
(
formats
)
)
{
formats
=
[
formats
]
;
}
const
features
=
new
Set
<
GPUFeatureName
|
undefined
>
(
)
;
for
(
const
format
of
formats
)
{
if
(
format
!
=
=
undefined
)
{
this
.
skipIfTextureFormatNotSupported
(
format
)
;
features
.
add
(
kTextureFormatInfo
[
format
]
.
feature
)
;
}
}
this
.
selectDeviceOrSkipTestCase
(
Array
.
from
(
features
)
)
;
}
selectDeviceForQueryTypeOrSkipTestCase
(
types
:
GPUQueryType
|
GPUQueryType
[
]
)
:
void
{
if
(
!
Array
.
isArray
(
types
)
)
{
types
=
[
types
]
;
}
const
features
=
types
.
map
(
t
=
>
kQueryTypeInfo
[
t
]
.
feature
)
;
this
.
selectDeviceOrSkipTestCase
(
features
)
;
}
acquireMismatchedProvider
(
)
:
Promise
<
DeviceProvider
>
|
undefined
{
return
this
.
mismatchedProvider
;
}
selectMismatchedDeviceOrSkipTestCase
(
descriptor
:
DeviceSelectionDescriptor
)
:
void
{
assert
(
this
.
mismatchedProvider
=
=
=
undefined
"
Can
'
t
selectMismatchedDeviceOrSkipTestCase
(
)
multiple
times
"
)
;
this
.
mismatchedProvider
=
mismatchedDevicePool
.
acquire
(
this
.
recorder
initUncanonicalizedDeviceDescriptor
(
descriptor
)
)
;
this
.
mismatchedProvider
.
catch
(
(
)
=
>
{
}
)
;
}
skip
(
msg
:
string
)
:
never
{
throw
new
SkipTestCase
(
msg
)
;
}
skipIf
(
cond
:
boolean
msg
:
string
|
(
(
)
=
>
string
)
=
'
'
)
{
if
(
cond
)
{
this
.
skip
(
typeof
msg
=
=
=
'
function
'
?
msg
(
)
:
msg
)
;
}
}
skipIfTextureFormatNotSupported
(
.
.
.
formats
:
(
GPUTextureFormat
|
undefined
)
[
]
)
{
if
(
this
.
isCompatibility
)
{
for
(
const
format
of
formats
)
{
if
(
format
=
=
=
'
bgra8unorm
-
srgb
'
)
{
this
.
skip
(
texture
format
'
{
format
}
is
not
supported
)
;
}
}
}
}
skipIfCopyTextureToTextureNotSupportedForFormat
(
.
.
.
formats
:
(
GPUTextureFormat
|
undefined
)
[
]
)
{
if
(
this
.
isCompatibility
)
{
for
(
const
format
of
formats
)
{
if
(
format
&
&
isCompressedTextureFormat
(
format
)
)
{
this
.
skip
(
copyTextureToTexture
with
{
format
}
is
not
supported
)
;
}
}
}
}
skipIfTextureViewDimensionNotSupported
(
.
.
.
dimensions
:
(
GPUTextureViewDimension
|
undefined
)
[
]
)
{
if
(
this
.
isCompatibility
)
{
for
(
const
dimension
of
dimensions
)
{
if
(
dimension
=
=
=
'
cube
-
array
'
)
{
this
.
skip
(
texture
view
dimension
'
{
dimension
}
'
is
not
supported
)
;
}
}
}
}
skipIfTextureFormatNotUsableAsStorageTexture
(
.
.
.
formats
:
(
GPUTextureFormat
|
undefined
)
[
]
)
{
for
(
const
format
of
formats
)
{
if
(
format
&
&
!
isTextureFormatUsableAsStorageFormat
(
format
this
.
isCompatibility
)
)
{
this
.
skip
(
Texture
with
{
format
}
is
not
usable
as
a
storage
texture
)
;
}
}
}
skipIfInterpolationTypeOrSamplingNotSupported
(
{
type
sampling
}
:
{
type
?
:
InterpolationType
;
sampling
?
:
InterpolationSampling
;
}
)
{
if
(
this
.
isCompatibility
)
{
this
.
skipIf
(
type
=
=
=
'
linear
'
'
interpolation
type
linear
is
not
supported
in
compatibility
mode
'
)
;
this
.
skipIf
(
sampling
=
=
=
'
sample
'
'
interpolation
type
linear
is
not
supported
in
compatibility
mode
'
)
;
}
}
skipIfLanguageFeatureNotSupported
(
langFeature
:
WGSLLanguageFeature
)
{
if
(
!
this
.
hasLanguageFeature
(
langFeature
)
)
{
this
.
skip
(
WGSL
language
feature
'
{
langFeature
}
'
is
not
supported
)
;
}
}
skipIfLanguageFeatureSupported
(
langFeature
:
WGSLLanguageFeature
)
{
if
(
this
.
hasLanguageFeature
(
langFeature
)
)
{
this
.
skip
(
WGSL
language
feature
'
{
langFeature
}
'
is
supported
)
;
}
}
hasLanguageFeature
(
langFeature
:
WGSLLanguageFeature
)
{
const
lf
=
getGPU
(
this
.
recorder
)
.
wgslLanguageFeatures
;
return
lf
!
=
=
undefined
&
&
lf
.
has
(
langFeature
)
;
}
}
export
class
GPUTestBase
extends
Fixture
<
GPUTestSubcaseBatchState
>
{
public
static
override
MakeSharedState
(
recorder
:
TestCaseRecorder
params
:
TestParams
)
:
GPUTestSubcaseBatchState
{
return
new
GPUTestSubcaseBatchState
(
recorder
params
)
;
}
get
device
(
)
:
GPUDevice
{
unreachable
(
)
;
return
null
as
unknown
as
GPUDevice
;
}
get
queue
(
)
:
GPUQueue
{
return
this
.
device
.
queue
;
}
get
isCompatibility
(
)
{
return
globalTestConfig
.
compatibility
;
}
getDefaultLimits
(
)
{
return
getDefaultLimits
(
this
.
isCompatibility
?
'
compatibility
'
:
'
core
'
)
;
}
getDefaultLimit
(
limit
:
(
typeof
kLimits
)
[
number
]
)
{
return
this
.
getDefaultLimits
(
)
[
limit
]
.
default
;
}
makeLimitVariant
(
limit
:
(
typeof
kLimits
)
[
number
]
variant
:
ValueTestVariant
)
{
return
makeValueTestVariant
(
this
.
device
.
limits
[
limit
]
variant
)
;
}
canCallCopyTextureToBufferWithTextureFormat
(
format
:
GPUTextureFormat
)
{
return
!
this
.
isCompatibility
|
|
!
isCompressedTextureFormat
(
format
)
;
}
private
createCopyForMapRead
(
src
:
GPUBuffer
srcOffset
:
number
size
:
number
)
:
GPUBuffer
{
assert
(
srcOffset
%
4
=
=
=
0
)
;
assert
(
size
%
4
=
=
=
0
)
;
const
dst
=
this
.
device
.
createBuffer
(
{
size
usage
:
GPUBufferUsage
.
MAP_READ
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
dst
)
;
const
c
=
this
.
device
.
createCommandEncoder
(
)
;
c
.
copyBufferToBuffer
(
src
srcOffset
dst
0
size
)
;
this
.
queue
.
submit
(
[
c
.
finish
(
)
]
)
;
return
dst
;
}
private
createAlignedCopyForMapRead
(
src
:
GPUBuffer
size
:
number
offset
:
number
)
:
{
mappable
:
GPUBuffer
;
subarrayByteStart
:
number
}
{
const
alignedOffset
=
roundDown
(
offset
4
)
;
const
subarrayByteStart
=
offset
-
alignedOffset
;
const
alignedSize
=
align
(
size
+
subarrayByteStart
4
)
;
const
mappable
=
this
.
createCopyForMapRead
(
src
alignedOffset
alignedSize
)
;
return
{
mappable
subarrayByteStart
}
;
}
async
readGPUBufferRangeTyped
<
T
extends
TypedArrayBufferView
>
(
src
:
GPUBuffer
{
srcByteOffset
=
0
method
=
'
copy
'
type
typedLength
}
:
{
srcByteOffset
?
:
number
;
method
?
:
'
copy
'
|
'
map
'
;
type
:
TypedArrayBufferViewConstructor
<
T
>
;
typedLength
:
number
;
}
)
:
Promise
<
{
data
:
T
;
cleanup
(
)
:
void
}
>
{
assert
(
srcByteOffset
%
type
.
BYTES_PER_ELEMENT
=
=
=
0
'
srcByteOffset
must
be
a
multiple
of
BYTES_PER_ELEMENT
'
)
;
const
byteLength
=
typedLength
*
type
.
BYTES_PER_ELEMENT
;
let
mappable
:
GPUBuffer
;
let
mapOffset
:
number
|
undefined
mapSize
:
number
|
undefined
subarrayByteStart
:
number
;
if
(
method
=
=
=
'
copy
'
)
{
(
{
mappable
subarrayByteStart
}
=
this
.
createAlignedCopyForMapRead
(
src
byteLength
srcByteOffset
)
)
;
}
else
if
(
method
=
=
=
'
map
'
)
{
mappable
=
src
;
mapOffset
=
roundDown
(
srcByteOffset
8
)
;
mapSize
=
align
(
byteLength
4
)
;
subarrayByteStart
=
srcByteOffset
-
mapOffset
;
}
else
{
unreachable
(
)
;
}
assert
(
subarrayByteStart
%
type
.
BYTES_PER_ELEMENT
=
=
=
0
)
;
const
subarrayStart
=
subarrayByteStart
/
type
.
BYTES_PER_ELEMENT
;
await
mappable
.
mapAsync
(
GPUMapMode
.
READ
mapOffset
mapSize
)
;
const
mapped
=
new
type
(
mappable
.
getMappedRange
(
mapOffset
mapSize
)
)
;
const
data
=
mapped
.
subarray
(
subarrayStart
typedLength
)
as
T
;
return
{
data
cleanup
(
)
{
mappable
.
unmap
(
)
;
mappable
.
destroy
(
)
;
}
}
;
}
skipIfTextureFormatNotSupported
(
.
.
.
formats
:
(
GPUTextureFormat
|
undefined
)
[
]
)
{
if
(
this
.
isCompatibility
)
{
for
(
const
format
of
formats
)
{
if
(
format
=
=
=
'
bgra8unorm
-
srgb
'
)
{
this
.
skip
(
texture
format
'
{
format
}
is
not
supported
)
;
}
}
}
}
skipIfTextureViewDimensionNotSupported
(
.
.
.
dimensions
:
(
GPUTextureViewDimension
|
undefined
)
[
]
)
{
if
(
this
.
isCompatibility
)
{
for
(
const
dimension
of
dimensions
)
{
if
(
dimension
=
=
=
'
cube
-
array
'
)
{
this
.
skip
(
texture
view
dimension
'
{
dimension
}
'
is
not
supported
)
;
}
}
}
}
skipIfCopyTextureToTextureNotSupportedForFormat
(
.
.
.
formats
:
(
GPUTextureFormat
|
undefined
)
[
]
)
{
if
(
this
.
isCompatibility
)
{
for
(
const
format
of
formats
)
{
if
(
format
&
&
isCompressedTextureFormat
(
format
)
)
{
this
.
skip
(
copyTextureToTexture
with
{
format
}
is
not
supported
)
;
}
}
}
}
skipIfLanguageFeatureNotSupported
(
langFeature
:
WGSLLanguageFeature
)
{
if
(
!
this
.
hasLanguageFeature
(
langFeature
)
)
{
this
.
skip
(
WGSL
language
feature
'
{
langFeature
}
'
is
not
supported
)
;
}
}
skipIfLanguageFeatureSupported
(
langFeature
:
WGSLLanguageFeature
)
{
if
(
this
.
hasLanguageFeature
(
langFeature
)
)
{
this
.
skip
(
WGSL
language
feature
'
{
langFeature
}
'
is
supported
)
;
}
}
hasLanguageFeature
(
langFeature
:
WGSLLanguageFeature
)
{
const
lf
=
getGPU
(
this
.
rec
)
.
wgslLanguageFeatures
;
return
lf
!
=
=
undefined
&
&
lf
.
has
(
langFeature
)
;
}
expectGPUBufferValuesPassCheck
<
T
extends
TypedArrayBufferView
>
(
src
:
GPUBuffer
check
:
(
actual
:
T
)
=
>
Error
|
undefined
{
srcByteOffset
=
0
type
typedLength
method
=
'
copy
'
mode
=
'
fail
'
}
:
{
srcByteOffset
?
:
number
;
type
:
TypedArrayBufferViewConstructor
<
T
>
;
typedLength
:
number
;
method
?
:
'
copy
'
|
'
map
'
;
mode
?
:
'
fail
'
|
'
warn
'
;
}
)
{
const
readbackPromise
=
this
.
readGPUBufferRangeTyped
(
src
{
srcByteOffset
type
typedLength
method
}
)
;
this
.
eventualAsyncExpectation
(
async
niceStack
=
>
{
const
readback
=
await
readbackPromise
;
this
.
expectOK
(
check
(
readback
.
data
)
{
mode
niceStack
}
)
;
readback
.
cleanup
(
)
;
}
)
;
}
expectGPUBufferValuesEqual
(
src
:
GPUBuffer
expected
:
TypedArrayBufferView
srcByteOffset
:
number
=
0
{
method
=
'
copy
'
mode
=
'
fail
'
}
:
{
method
?
:
'
copy
'
|
'
map
'
;
mode
?
:
'
fail
'
|
'
warn
'
}
=
{
}
)
:
void
{
this
.
expectGPUBufferValuesPassCheck
(
src
a
=
>
checkElementsEqual
(
a
expected
)
{
srcByteOffset
type
:
expected
.
constructor
as
TypedArrayBufferViewConstructor
typedLength
:
expected
.
length
method
mode
}
)
;
}
expectGPUBufferRepeatsSingleValue
(
buffer
:
GPUBuffer
{
expectedValue
numRows
minBytesPerRow
bytesPerRow
}
:
{
expectedValue
:
ArrayBuffer
;
numRows
:
number
;
minBytesPerRow
:
number
;
bytesPerRow
:
number
;
}
)
{
const
valueSize
=
expectedValue
.
byteLength
;
assert
(
valueSize
=
=
=
1
|
|
valueSize
=
=
=
2
|
|
valueSize
%
4
=
=
=
0
)
;
assert
(
minBytesPerRow
%
valueSize
=
=
=
0
)
;
assert
(
bytesPerRow
%
4
=
=
=
0
)
;
const
kMaxBufferSizeToCheckOnCpu
=
256
*
1024
;
const
bufferSize
=
bytesPerRow
*
(
numRows
-
1
)
+
minBytesPerRow
;
if
(
bufferSize
<
=
kMaxBufferSizeToCheckOnCpu
)
{
const
valueBytes
=
Array
.
from
(
new
Uint8Array
(
expectedValue
)
)
;
const
rowValues
=
new
Array
(
minBytesPerRow
/
valueSize
)
.
fill
(
valueBytes
)
;
const
rowBytes
=
new
Uint8Array
(
[
]
.
concat
(
.
.
.
rowValues
)
)
;
const
expectedContents
=
new
Uint8Array
(
bufferSize
)
;
range
(
numRows
row
=
>
expectedContents
.
set
(
rowBytes
row
*
bytesPerRow
)
)
;
this
.
expectGPUBufferValuesEqual
(
buffer
expectedContents
)
;
return
;
}
const
storageBuffer
=
this
.
device
.
createBuffer
(
{
size
:
bufferSize
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
storageBuffer
)
;
const
expectedDataSize
=
Math
.
max
(
4
valueSize
)
;
const
expectedDataBuffer
=
this
.
device
.
createBuffer
(
{
size
:
expectedDataSize
usage
:
GPUBufferUsage
.
STORAGE
mappedAtCreation
:
true
}
)
;
this
.
trackForCleanup
(
expectedDataBuffer
)
;
const
expectedData
=
new
Uint32Array
(
expectedDataBuffer
.
getMappedRange
(
)
)
;
if
(
valueSize
=
=
=
1
)
{
const
value
=
new
Uint8Array
(
expectedValue
)
[
0
]
;
const
values
=
new
Array
(
Math
.
min
(
4
minBytesPerRow
)
)
.
fill
(
value
)
;
const
padding
=
new
Array
(
Math
.
max
(
0
4
-
values
.
length
)
)
.
fill
(
0
)
;
const
expectedBytes
=
new
Uint8Array
(
expectedData
.
buffer
)
;
expectedBytes
.
set
(
[
.
.
.
values
.
.
.
padding
]
)
;
}
else
if
(
valueSize
=
=
=
2
)
{
const
value
=
new
Uint16Array
(
expectedValue
)
[
0
]
;
const
expectedWords
=
new
Uint16Array
(
expectedData
.
buffer
)
;
expectedWords
.
set
(
[
value
minBytesPerRow
>
2
?
value
:
0
]
)
;
}
else
{
expectedData
.
set
(
new
Uint32Array
(
expectedValue
)
)
;
}
expectedDataBuffer
.
unmap
(
)
;
const
resultBuffer
=
this
.
device
.
createBuffer
(
{
size
:
numRows
*
4
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_SRC
}
)
;
this
.
trackForCleanup
(
resultBuffer
)
;
const
readsPerRow
=
Math
.
ceil
(
minBytesPerRow
/
expectedDataSize
)
;
const
reducer
=
struct
Buffer
{
data
:
array
<
u32
>
}
;
group
(
0
)
binding
(
0
)
var
<
storage
read
>
expected
:
Buffer
;
group
(
0
)
binding
(
1
)
var
<
storage
read
>
in
:
Buffer
;
group
(
0
)
binding
(
2
)
var
<
storage
read_write
>
out
:
Buffer
;
compute
workgroup_size
(
1
)
fn
reduce
(
builtin
(
global_invocation_id
)
id
:
vec3
<
u32
>
)
{
let
rowBaseIndex
=
id
.
x
*
{
bytesPerRow
/
4
}
u
;
let
readSize
=
{
expectedDataSize
/
4
}
u
;
out
.
data
[
id
.
x
]
=
1u
;
for
(
var
i
:
u32
=
0u
;
i
<
{
readsPerRow
}
u
;
i
=
i
+
1u
)
{
let
elementBaseIndex
=
rowBaseIndex
+
i
*
readSize
;
for
(
var
j
:
u32
=
0u
;
j
<
readSize
;
j
=
j
+
1u
)
{
if
(
in
.
data
[
elementBaseIndex
+
j
]
!
=
expected
.
data
[
j
]
)
{
out
.
data
[
id
.
x
]
=
0u
;
return
;
}
}
}
}
;
const
pipeline
=
this
.
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
:
reducer
}
)
entryPoint
:
'
reduce
'
}
}
)
;
const
bindGroup
=
this
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
expectedDataBuffer
}
}
{
binding
:
1
resource
:
{
buffer
:
storageBuffer
}
}
{
binding
:
2
resource
:
{
buffer
:
resultBuffer
}
}
]
}
)
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
commandEncoder
.
copyBufferToBuffer
(
buffer
0
storageBuffer
0
bufferSize
)
;
const
pass
=
commandEncoder
.
beginComputePass
(
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
bindGroup
)
;
pass
.
dispatchWorkgroups
(
numRows
)
;
pass
.
end
(
)
;
this
.
device
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
const
expectedResults
=
new
Array
(
numRows
)
.
fill
(
1
)
;
this
.
expectGPUBufferValuesEqual
(
resultBuffer
new
Uint32Array
(
expectedResults
)
)
;
}
expectSingleColor
(
src
:
GPUTexture
format
:
GPUTextureFormat
{
size
exp
dimension
=
'
2d
'
slice
=
0
layout
}
:
{
size
:
[
number
number
number
]
;
exp
:
PerTexelComponent
<
number
>
;
dimension
?
:
GPUTextureDimension
;
slice
?
:
number
;
layout
?
:
TextureLayoutOptions
;
}
)
:
void
{
assert
(
slice
=
=
=
0
|
|
dimension
=
=
=
'
2d
'
'
texture
slices
are
only
implemented
for
2d
textures
'
)
;
format
=
resolvePerAspectFormat
(
format
layout
?
.
aspect
)
;
const
{
byteLength
minBytesPerRow
bytesPerRow
rowsPerImage
mipSize
}
=
getTextureCopyLayout
(
format
dimension
size
layout
)
;
const
copySize
=
[
mipSize
[
0
]
dimension
!
=
=
'
1d
'
?
mipSize
[
1
]
:
1
dimension
=
=
=
'
3d
'
?
mipSize
[
2
]
:
1
]
;
const
rep
=
kTexelRepresentationInfo
[
format
as
EncodableTextureFormat
]
;
const
expectedTexelData
=
rep
.
pack
(
rep
.
encode
(
exp
)
)
;
const
buffer
=
this
.
device
.
createBuffer
(
{
size
:
byteLength
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
buffer
)
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
commandEncoder
.
copyTextureToBuffer
(
{
texture
:
src
mipLevel
:
layout
?
.
mipLevel
origin
:
{
x
:
0
y
:
0
z
:
slice
}
aspect
:
layout
?
.
aspect
}
{
buffer
bytesPerRow
rowsPerImage
}
copySize
)
;
this
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
this
.
expectGPUBufferRepeatsSingleValue
(
buffer
{
expectedValue
:
expectedTexelData
numRows
:
rowsPerImage
*
copySize
[
2
]
minBytesPerRow
bytesPerRow
}
)
;
}
private
readSinglePixelFrom2DTexture
(
src
:
GPUTexture
format
:
SizedTextureFormat
{
x
y
}
:
{
x
:
number
;
y
:
number
}
{
slice
=
0
layout
}
:
{
slice
?
:
number
;
layout
?
:
TextureLayoutOptions
}
)
:
GPUBuffer
{
const
{
byteLength
bytesPerRow
rowsPerImage
}
=
getTextureSubCopyLayout
(
format
[
1
1
]
layout
)
;
const
buffer
=
this
.
device
.
createBuffer
(
{
size
:
byteLength
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
buffer
)
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
commandEncoder
.
copyTextureToBuffer
(
{
texture
:
src
mipLevel
:
layout
?
.
mipLevel
origin
:
{
x
y
z
:
slice
}
}
{
buffer
bytesPerRow
rowsPerImage
}
[
1
1
]
)
;
this
.
queue
.
submit
(
[
commandEncoder
.
finish
(
)
]
)
;
return
buffer
;
}
expectSinglePixelBetweenTwoValuesIn2DTexture
(
src
:
GPUTexture
format
:
SizedTextureFormat
{
x
y
}
:
{
x
:
number
;
y
:
number
}
{
exp
slice
=
0
layout
generateWarningOnly
=
false
checkElementsBetweenFn
=
(
act
[
a
b
]
)
=
>
checkElementsBetween
(
act
[
i
=
>
a
[
i
]
as
number
i
=
>
b
[
i
]
as
number
]
)
}
:
{
exp
:
[
TypedArrayBufferView
TypedArrayBufferView
]
;
slice
?
:
number
;
layout
?
:
TextureLayoutOptions
;
generateWarningOnly
?
:
boolean
;
checkElementsBetweenFn
?
:
(
actual
:
TypedArrayBufferView
expected
:
readonly
[
TypedArrayBufferView
TypedArrayBufferView
]
)
=
>
Error
|
undefined
;
}
)
:
void
{
assert
(
exp
[
0
]
.
constructor
=
=
=
exp
[
1
]
.
constructor
)
;
const
constructor
=
exp
[
0
]
.
constructor
as
TypedArrayBufferViewConstructor
;
assert
(
exp
[
0
]
.
length
=
=
=
exp
[
1
]
.
length
)
;
const
typedLength
=
exp
[
0
]
.
length
;
const
buffer
=
this
.
readSinglePixelFrom2DTexture
(
src
format
{
x
y
}
{
slice
layout
}
)
;
this
.
expectGPUBufferValuesPassCheck
(
buffer
a
=
>
checkElementsBetweenFn
(
a
exp
)
{
type
:
constructor
typedLength
mode
:
generateWarningOnly
?
'
warn
'
:
'
fail
'
}
)
;
}
copy2DTextureToBufferUsingComputePass
(
type
:
ScalarType
componentCount
:
number
textureView
:
GPUTextureView
sampleCount
:
number
=
1
extent_
:
GPUExtent3D
=
[
1
1
1
]
origin_
:
GPUOrigin3D
=
[
0
0
0
]
)
:
GPUBuffer
{
const
origin
=
reifyOrigin3D
(
origin_
)
;
const
extent
=
reifyExtent3D
(
extent_
)
;
const
width
=
extent
.
width
;
const
height
=
extent
.
height
;
const
kWorkgroupSizeX
=
8
;
const
kWorkgroupSizeY
=
8
;
const
textureSrcCode
=
sampleCount
=
=
=
1
?
group
(
0
)
binding
(
0
)
var
src
:
texture_2d
<
{
type
}
>
;
:
group
(
0
)
binding
(
0
)
var
src
:
texture_multisampled_2d
<
{
type
}
>
;
;
const
code
=
struct
Buffer
{
data
:
array
<
{
type
}
>
}
;
{
textureSrcCode
}
group
(
0
)
binding
(
1
)
var
<
storage
read_write
>
dst
:
Buffer
;
struct
Params
{
origin
:
vec2u
extent
:
vec2u
}
;
group
(
0
)
binding
(
2
)
var
<
uniform
>
params
:
Params
;
compute
workgroup_size
(
{
kWorkgroupSizeX
}
{
kWorkgroupSizeY
}
1
)
fn
main
(
builtin
(
global_invocation_id
)
id
:
vec3u
)
{
let
boundary
=
params
.
origin
+
params
.
extent
;
let
coord
=
params
.
origin
+
id
.
xy
;
if
(
any
(
coord
>
=
boundary
)
)
{
return
;
}
let
offset
=
(
id
.
x
+
id
.
y
*
params
.
extent
.
x
)
*
{
componentCount
}
*
{
sampleCount
}
;
for
(
var
sampleIndex
=
0u
;
sampleIndex
<
{
sampleCount
}
;
sampleIndex
=
sampleIndex
+
1
)
{
let
o
=
offset
+
sampleIndex
*
{
componentCount
}
;
let
v
=
textureLoad
(
src
coord
.
xy
sampleIndex
)
;
for
(
var
component
=
0u
;
component
<
{
componentCount
}
;
component
=
component
+
1
)
{
dst
.
data
[
o
+
component
]
=
v
[
component
]
;
}
}
}
;
const
computePipeline
=
this
.
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
:
this
.
device
.
createShaderModule
(
{
code
}
)
entryPoint
:
'
main
'
}
}
)
;
const
storageBuffer
=
this
.
device
.
createBuffer
(
{
size
:
sampleCount
*
type
.
size
*
componentCount
*
width
*
height
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
COPY_SRC
}
)
;
this
.
trackForCleanup
(
storageBuffer
)
;
const
uniformBuffer
=
this
.
makeBufferWithContents
(
new
Uint32Array
(
[
origin
.
x
origin
.
y
width
height
]
)
GPUBufferUsage
.
UNIFORM
)
;
const
uniformBindGroup
=
this
.
device
.
createBindGroup
(
{
layout
:
computePipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
textureView
}
{
binding
:
1
resource
:
{
buffer
:
storageBuffer
}
}
{
binding
:
2
resource
:
{
buffer
:
uniformBuffer
}
}
]
}
)
;
const
encoder
=
this
.
device
.
createCommandEncoder
(
)
;
const
pass
=
encoder
.
beginComputePass
(
)
;
pass
.
setPipeline
(
computePipeline
)
;
pass
.
setBindGroup
(
0
uniformBindGroup
)
;
pass
.
dispatchWorkgroups
(
Math
.
floor
(
(
width
+
kWorkgroupSizeX
-
1
)
/
kWorkgroupSizeX
)
Math
.
floor
(
(
height
+
kWorkgroupSizeY
-
1
)
/
kWorkgroupSizeY
)
1
)
;
pass
.
end
(
)
;
this
.
device
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
return
storageBuffer
;
}
expectGPUError
<
R
>
(
filter
:
GPUErrorFilter
fn
:
(
)
=
>
R
shouldError
:
boolean
=
true
)
:
R
{
if
(
!
shouldError
)
{
return
fn
(
)
;
}
this
.
device
.
pushErrorScope
(
filter
)
;
const
returnValue
=
fn
(
)
;
const
promise
=
this
.
device
.
popErrorScope
(
)
;
this
.
eventualAsyncExpectation
(
async
niceStack
=
>
{
const
error
=
await
promise
;
let
failed
=
false
;
switch
(
filter
)
{
case
'
out
-
of
-
memory
'
:
failed
=
!
(
error
instanceof
GPUOutOfMemoryError
)
;
break
;
case
'
validation
'
:
failed
=
!
(
error
instanceof
GPUValidationError
)
;
break
;
}
if
(
failed
)
{
niceStack
.
message
=
Expected
{
filter
}
error
;
this
.
rec
.
expectationFailed
(
niceStack
)
;
}
else
{
niceStack
.
message
=
Captured
{
filter
}
error
;
if
(
error
instanceof
GPUValidationError
)
{
niceStack
.
message
+
=
-
{
error
.
message
}
;
}
this
.
rec
.
debug
(
niceStack
)
;
}
}
)
;
return
returnValue
;
}
expectValidationError
(
fn
:
(
)
=
>
void
shouldError
:
boolean
=
true
)
:
void
{
if
(
shouldError
)
{
this
.
device
.
pushErrorScope
(
'
validation
'
)
;
}
const
returnValue
=
fn
(
)
as
unknown
;
assert
(
returnValue
=
=
=
undefined
'
expectValidationError
callback
should
not
return
a
value
(
or
be
async
)
'
)
;
if
(
shouldError
)
{
const
promise
=
this
.
device
.
popErrorScope
(
)
;
this
.
eventualAsyncExpectation
(
async
niceStack
=
>
{
const
gpuValidationError
=
await
promise
;
if
(
!
gpuValidationError
)
{
niceStack
.
message
=
'
Validation
succeeded
unexpectedly
.
'
;
this
.
rec
.
validationFailed
(
niceStack
)
;
}
else
if
(
gpuValidationError
instanceof
GPUValidationError
)
{
niceStack
.
message
=
Validation
failed
as
expected
-
{
gpuValidationError
.
message
}
;
this
.
rec
.
debug
(
niceStack
)
;
}
}
)
;
}
}
makeBufferWithContents
(
dataArray
:
TypedArrayBufferView
usage
:
GPUBufferUsageFlags
)
:
GPUBuffer
{
return
this
.
trackForCleanup
(
makeBufferWithContents
(
this
.
device
dataArray
usage
)
)
;
}
createEncoder
<
T
extends
EncoderType
>
(
encoderType
:
T
{
attachmentInfo
occlusionQuerySet
}
:
{
attachmentInfo
?
:
GPURenderBundleEncoderDescriptor
;
occlusionQuerySet
?
:
GPUQuerySet
;
}
=
{
}
)
:
CommandBufferMaker
<
T
>
{
const
fullAttachmentInfo
=
{
colorFormats
:
[
'
rgba8unorm
'
]
sampleCount
:
1
.
.
.
attachmentInfo
}
as
const
;
switch
(
encoderType
)
{
case
'
non
-
pass
'
:
{
const
encoder
=
this
.
device
.
createCommandEncoder
(
)
;
return
new
CommandBufferMaker
(
this
encoder
(
)
=
>
{
return
encoder
.
finish
(
)
;
}
)
;
}
case
'
render
bundle
'
:
{
const
device
=
this
.
device
;
const
rbEncoder
=
device
.
createRenderBundleEncoder
(
fullAttachmentInfo
)
;
const
pass
=
this
.
createEncoder
(
'
render
pass
'
{
attachmentInfo
}
)
;
return
new
CommandBufferMaker
(
this
rbEncoder
(
)
=
>
{
pass
.
encoder
.
executeBundles
(
[
rbEncoder
.
finish
(
)
]
)
;
return
pass
.
finish
(
)
;
}
)
;
}
case
'
compute
pass
'
:
{
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
const
encoder
=
commandEncoder
.
beginComputePass
(
)
;
return
new
CommandBufferMaker
(
this
encoder
(
)
=
>
{
encoder
.
end
(
)
;
return
commandEncoder
.
finish
(
)
;
}
)
;
}
case
'
render
pass
'
:
{
const
makeAttachmentView
=
(
format
:
GPUTextureFormat
)
=
>
this
.
trackForCleanup
(
this
.
device
.
createTexture
(
{
size
:
[
16
16
1
]
format
usage
:
GPUTextureUsage
.
RENDER_ATTACHMENT
sampleCount
:
fullAttachmentInfo
.
sampleCount
}
)
)
.
createView
(
)
;
let
depthStencilAttachment
:
GPURenderPassDepthStencilAttachment
|
undefined
=
undefined
;
if
(
fullAttachmentInfo
.
depthStencilFormat
!
=
=
undefined
)
{
depthStencilAttachment
=
{
view
:
makeAttachmentView
(
fullAttachmentInfo
.
depthStencilFormat
)
depthReadOnly
:
fullAttachmentInfo
.
depthReadOnly
stencilReadOnly
:
fullAttachmentInfo
.
stencilReadOnly
}
;
if
(
kTextureFormatInfo
[
fullAttachmentInfo
.
depthStencilFormat
]
.
depth
&
&
!
fullAttachmentInfo
.
depthReadOnly
)
{
depthStencilAttachment
.
depthClearValue
=
0
;
depthStencilAttachment
.
depthLoadOp
=
'
clear
'
;
depthStencilAttachment
.
depthStoreOp
=
'
discard
'
;
}
if
(
kTextureFormatInfo
[
fullAttachmentInfo
.
depthStencilFormat
]
.
stencil
&
&
!
fullAttachmentInfo
.
stencilReadOnly
)
{
depthStencilAttachment
.
stencilClearValue
=
1
;
depthStencilAttachment
.
stencilLoadOp
=
'
clear
'
;
depthStencilAttachment
.
stencilStoreOp
=
'
discard
'
;
}
}
const
passDesc
:
GPURenderPassDescriptor
=
{
colorAttachments
:
Array
.
from
(
fullAttachmentInfo
.
colorFormats
format
=
>
format
?
{
view
:
makeAttachmentView
(
format
)
clearValue
:
[
0
0
0
0
]
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
:
null
)
depthStencilAttachment
occlusionQuerySet
}
;
const
commandEncoder
=
this
.
device
.
createCommandEncoder
(
)
;
const
encoder
=
commandEncoder
.
beginRenderPass
(
passDesc
)
;
return
new
CommandBufferMaker
(
this
encoder
(
)
=
>
{
encoder
.
end
(
)
;
return
commandEncoder
.
finish
(
)
;
}
)
;
}
}
unreachable
(
)
;
}
}
export
class
GPUTest
extends
GPUTestBase
{
private
provider
:
DeviceProvider
|
undefined
;
private
mismatchedProvider
:
DeviceProvider
|
undefined
;
override
async
init
(
)
{
await
super
.
init
(
)
;
this
.
provider
=
await
this
.
sharedState
.
acquireProvider
(
)
;
this
.
mismatchedProvider
=
await
this
.
sharedState
.
acquireMismatchedProvider
(
)
;
}
get
adapter
(
)
:
GPUAdapter
{
assert
(
this
.
provider
!
=
=
undefined
'
internal
error
:
DeviceProvider
missing
'
)
;
return
this
.
provider
.
adapter
;
}
override
get
device
(
)
:
GPUDevice
{
assert
(
this
.
provider
!
=
=
undefined
'
internal
error
:
DeviceProvider
missing
'
)
;
return
this
.
provider
.
device
;
}
get
mismatchedDevice
(
)
:
GPUDevice
{
assert
(
this
.
mismatchedProvider
!
=
=
undefined
'
selectMismatchedDeviceOrSkipTestCase
was
not
called
in
beforeAllSubcases
'
)
;
return
this
.
mismatchedProvider
.
device
;
}
expectDeviceLost
(
reason
:
GPUDeviceLostReason
)
:
void
{
assert
(
this
.
provider
!
=
=
undefined
'
internal
error
:
GPUDevice
missing
?
'
)
;
this
.
provider
.
expectDeviceLost
(
reason
)
;
}
}
export
interface
TextureTestMixinType
{
createTextureFromTexelView
(
texelView
:
TexelView
desc
:
Omit
<
GPUTextureDescriptor
'
format
'
>
)
:
GPUTexture
;
createTextureFromTexelViewsMultipleMipmaps
(
texelViews
:
TexelView
[
]
desc
:
Omit
<
GPUTextureDescriptor
'
format
'
>
)
:
GPUTexture
;
expectTexelViewComparisonIsOkInTexture
(
src
:
GPUImageCopyTexture
exp
:
TexelView
size
:
GPUExtent3D
comparisonOptions
?
:
TexelCompareOptions
)
:
void
;
expectSinglePixelComparisonsAreOkInTexture
<
E
extends
PixelExpectation
>
(
src
:
GPUImageCopyTexture
exp
:
PerPixelComparison
<
E
>
[
]
comparisonOptions
?
:
TexelCompareOptions
)
:
void
;
expectTexturesToMatchByRendering
(
actualTexture
:
GPUTexture
expectedTexture
:
GPUTexture
mipLevel
:
number
origin
:
Required
<
GPUOrigin3DDict
>
size
:
Required
<
GPUExtent3DDict
>
)
:
void
;
copyWholeTextureToNewBufferSimple
(
texture
:
GPUTexture
mipLevel
:
number
)
:
GPUBuffer
;
copyWholeTextureToNewBuffer
(
{
texture
mipLevel
}
:
{
texture
:
GPUTexture
;
mipLevel
:
number
|
undefined
}
resultDataLayout
:
{
bytesPerBlock
:
number
;
byteLength
:
number
;
bytesPerRow
:
number
;
rowsPerImage
:
number
;
mipSize
:
[
number
number
number
]
;
}
)
:
GPUBuffer
;
updateLinearTextureDataSubBox
(
format
:
ColorTextureFormat
copySize
:
Required
<
GPUExtent3DDict
>
copyParams
:
{
dest
:
LinearCopyParameters
;
src
:
LinearCopyParameters
;
}
)
:
void
;
getTexelOffsetInBytes
(
textureDataLayout
:
Required
<
GPUImageDataLayout
>
format
:
ColorTextureFormat
texel
:
Required
<
GPUOrigin3DDict
>
origin
?
:
Required
<
GPUOrigin3DDict
>
)
:
number
;
iterateBlockRows
(
size
:
Required
<
GPUExtent3DDict
>
format
:
ColorTextureFormat
)
:
Generator
<
Required
<
GPUOrigin3DDict
>
>
;
}
type
PipelineType
=
'
2d
'
|
'
2d
-
array
'
;
type
ImageCopyTestResources
=
{
pipelineByPipelineType
:
Map
<
PipelineType
GPURenderPipeline
>
;
}
;
const
s_deviceToResourcesMap
=
new
WeakMap
<
GPUDevice
ImageCopyTestResources
>
(
)
;
function
getPipelineToRenderTextureToRGB8UnormTexture
(
device
:
GPUDevice
texture
:
GPUTexture
isCompatibility
:
boolean
)
{
if
(
!
s_deviceToResourcesMap
.
has
(
device
)
)
{
s_deviceToResourcesMap
.
set
(
device
{
pipelineByPipelineType
:
new
Map
<
PipelineType
GPURenderPipeline
>
(
)
}
)
;
}
const
{
pipelineByPipelineType
}
=
s_deviceToResourcesMap
.
get
(
device
)
!
;
const
pipelineType
:
PipelineType
=
isCompatibility
&
&
texture
.
depthOrArrayLayers
>
1
?
'
2d
-
array
'
:
'
2d
'
;
if
(
!
pipelineByPipelineType
.
get
(
pipelineType
)
)
{
const
[
textureType
layerCode
]
=
pipelineType
=
=
=
'
2d
'
?
[
'
texture_2d
'
'
'
]
:
[
'
texture_2d_array
'
'
uni
.
baseArrayLayer
'
]
;
const
module
=
device
.
createShaderModule
(
{
code
:
struct
VSOutput
{
builtin
(
position
)
position
:
vec4f
location
(
0
)
texcoord
:
vec2f
}
;
struct
Uniforms
{
baseArrayLayer
:
u32
}
;
vertex
fn
vs
(
builtin
(
vertex_index
)
vertexIndex
:
u32
)
-
>
VSOutput
{
let
pos
=
array
(
vec2f
(
-
1
-
1
)
vec2f
(
-
1
3
)
vec2f
(
3
-
1
)
)
;
var
vsOutput
:
VSOutput
;
let
xy
=
pos
[
vertexIndex
]
;
vsOutput
.
position
=
vec4f
(
xy
0
.
0
1
.
0
)
;
vsOutput
.
texcoord
=
xy
*
vec2f
(
0
.
5
-
0
.
5
)
+
vec2f
(
0
.
5
)
;
return
vsOutput
;
}
group
(
0
)
binding
(
0
)
var
ourSampler
:
sampler
;
group
(
0
)
binding
(
1
)
var
ourTexture
:
{
textureType
}
<
f32
>
;
group
(
0
)
binding
(
2
)
var
<
uniform
>
uni
:
Uniforms
;
fragment
fn
fs
(
fsInput
:
VSOutput
)
-
>
location
(
0
)
vec4f
{
return
textureSample
(
ourTexture
ourSampler
fsInput
.
texcoord
{
layerCode
}
)
;
}
}
)
;
const
pipeline
=
device
.
createRenderPipeline
(
{
layout
:
'
auto
'
vertex
:
{
module
entryPoint
:
'
vs
'
}
fragment
:
{
module
entryPoint
:
'
fs
'
targets
:
[
{
format
:
'
rgba8unorm
'
}
]
}
}
)
;
pipelineByPipelineType
.
set
(
pipelineType
pipeline
)
;
}
const
pipeline
=
pipelineByPipelineType
.
get
(
pipelineType
)
!
;
return
{
pipelineType
pipeline
}
;
}
type
LinearCopyParameters
=
{
dataLayout
:
Required
<
GPUImageDataLayout
>
;
origin
:
Required
<
GPUOrigin3DDict
>
;
data
:
Uint8Array
;
}
;
export
function
TextureTestMixin
<
F
extends
FixtureClass
<
GPUTest
>
>
(
Base
:
F
)
:
FixtureClassWithMixin
<
F
TextureTestMixinType
>
{
class
TextureExpectations
extends
(
Base
as
FixtureClassInterface
<
GPUTest
>
)
implements
TextureTestMixinType
{
createTextureFromTexelView
(
texelView
:
TexelView
desc
:
Omit
<
GPUTextureDescriptor
'
format
'
>
)
:
GPUTexture
{
return
this
.
trackForCleanup
(
createTextureFromTexelView
(
this
.
device
texelView
desc
)
)
;
}
createTextureFromTexelViewsMultipleMipmaps
(
texelViews
:
TexelView
[
]
desc
:
Omit
<
GPUTextureDescriptor
'
format
'
>
)
:
GPUTexture
{
return
this
.
trackForCleanup
(
createTextureFromTexelViews
(
this
.
device
texelViews
desc
)
)
;
}
expectTexelViewComparisonIsOkInTexture
(
src
:
GPUImageCopyTexture
exp
:
TexelView
size
:
GPUExtent3D
comparisonOptions
=
{
maxIntDiff
:
0
maxDiffULPsForNormFormat
:
1
maxDiffULPsForFloatFormat
:
1
}
)
:
void
{
this
.
eventualExpectOK
(
textureContentIsOKByT2B
(
this
src
size
{
expTexelView
:
exp
}
comparisonOptions
)
)
;
}
expectSinglePixelComparisonsAreOkInTexture
<
E
extends
PixelExpectation
>
(
src
:
GPUImageCopyTexture
exp
:
PerPixelComparison
<
E
>
[
]
comparisonOptions
=
{
maxIntDiff
:
0
maxDiffULPsForNormFormat
:
1
maxDiffULPsForFloatFormat
:
1
}
)
:
void
{
assert
(
exp
.
length
>
0
'
must
specify
at
least
one
pixel
comparison
'
)
;
assert
(
(
kEncodableTextureFormats
as
GPUTextureFormat
[
]
)
.
includes
(
src
.
texture
.
format
)
(
)
=
>
{
src
.
texture
.
format
}
is
not
an
encodable
format
)
;
const
lowerCorner
=
[
src
.
texture
.
width
src
.
texture
.
height
src
.
texture
.
depthOrArrayLayers
]
;
const
upperCorner
=
[
0
0
0
]
;
const
expMap
=
new
Map
<
string
E
>
(
)
;
const
coords
:
Required
<
GPUOrigin3DDict
>
[
]
=
[
]
;
for
(
const
e
of
exp
)
{
const
coord
=
reifyOrigin3D
(
e
.
coord
)
;
const
coordKey
=
JSON
.
stringify
(
coord
)
;
coords
.
push
(
coord
)
;
lowerCorner
[
0
]
=
Math
.
min
(
lowerCorner
[
0
]
coord
.
x
)
;
lowerCorner
[
1
]
=
Math
.
min
(
lowerCorner
[
1
]
coord
.
y
)
;
lowerCorner
[
2
]
=
Math
.
min
(
lowerCorner
[
2
]
coord
.
z
)
;
upperCorner
[
0
]
=
Math
.
max
(
upperCorner
[
0
]
coord
.
x
)
;
upperCorner
[
1
]
=
Math
.
max
(
upperCorner
[
1
]
coord
.
y
)
;
upperCorner
[
2
]
=
Math
.
max
(
upperCorner
[
2
]
coord
.
z
)
;
assert
(
!
expMap
.
has
(
coordKey
)
(
)
=
>
duplicate
pixel
expectation
at
coordinate
(
{
coord
.
x
}
{
coord
.
y
}
{
coord
.
z
}
)
)
;
expMap
.
set
(
coordKey
e
.
exp
)
;
}
const
size
:
GPUExtent3D
=
[
upperCorner
[
0
]
-
lowerCorner
[
0
]
+
1
upperCorner
[
1
]
-
lowerCorner
[
1
]
+
1
upperCorner
[
2
]
-
lowerCorner
[
2
]
+
1
]
;
let
expTexelView
:
TexelView
;
if
(
Symbol
.
iterator
in
exp
[
0
]
.
exp
)
{
expTexelView
=
TexelView
.
fromTexelsAsBytes
(
src
.
texture
.
format
as
EncodableTextureFormat
coord
=
>
{
const
res
=
expMap
.
get
(
JSON
.
stringify
(
coord
)
)
;
assert
(
res
!
=
=
undefined
(
)
=
>
invalid
coordinate
(
{
coord
.
x
}
{
coord
.
y
}
{
coord
.
z
}
)
in
sparse
texel
view
)
;
return
res
as
Uint8Array
;
}
)
;
}
else
{
expTexelView
=
TexelView
.
fromTexelsAsColors
(
src
.
texture
.
format
as
EncodableTextureFormat
coord
=
>
{
const
res
=
expMap
.
get
(
JSON
.
stringify
(
coord
)
)
;
assert
(
res
!
=
=
undefined
(
)
=
>
invalid
coordinate
(
{
coord
.
x
}
{
coord
.
y
}
{
coord
.
z
}
)
in
sparse
texel
view
)
;
return
res
as
PerTexelComponent
<
number
>
;
}
)
;
}
const
coordsF
=
(
function
*
(
)
{
for
(
const
coord
of
coords
)
{
yield
coord
;
}
}
)
(
)
;
this
.
eventualExpectOK
(
textureContentIsOKByT2B
(
this
{
.
.
.
src
origin
:
reifyOrigin3D
(
lowerCorner
)
}
size
{
expTexelView
}
comparisonOptions
coordsF
)
)
;
}
expectTexturesToMatchByRendering
(
actualTexture
:
GPUTexture
expectedTexture
:
GPUTexture
mipLevel
:
number
origin
:
Required
<
GPUOrigin3DDict
>
size
:
Required
<
GPUExtent3DDict
>
)
:
void
{
const
{
pipelineType
pipeline
}
=
getPipelineToRenderTextureToRGB8UnormTexture
(
this
.
device
actualTexture
this
.
isCompatibility
)
;
const
readbackPromisesPerTexturePerLayer
=
[
actualTexture
expectedTexture
]
.
map
(
(
texture
ndx
)
=
>
{
const
attachmentSize
=
virtualMipSize
(
'
2d
'
[
texture
.
width
texture
.
height
1
]
mipLevel
)
;
const
attachment
=
this
.
device
.
createTexture
(
{
label
:
readback
{
ndx
}
size
:
attachmentSize
format
:
'
rgba8unorm
'
usage
:
GPUTextureUsage
.
COPY_SRC
|
GPUTextureUsage
.
RENDER_ATTACHMENT
}
)
;
this
.
trackForCleanup
(
attachment
)
;
const
sampler
=
this
.
device
.
createSampler
(
)
;
const
numLayers
=
texture
.
depthOrArrayLayers
;
const
readbackPromisesPerLayer
=
[
]
;
const
uniformBuffer
=
this
.
device
.
createBuffer
(
{
size
:
4
usage
:
GPUBufferUsage
.
UNIFORM
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
uniformBuffer
)
;
for
(
let
layer
=
0
;
layer
<
numLayers
;
+
+
layer
)
{
const
viewDescriptor
:
GPUTextureViewDescriptor
=
{
baseMipLevel
:
mipLevel
mipLevelCount
:
1
.
.
.
(
!
this
.
isCompatibility
&
&
{
baseArrayLayer
:
layer
arrayLayerCount
:
1
}
)
dimension
:
pipelineType
}
;
const
bindGroup
=
this
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
sampler
}
{
binding
:
1
resource
:
texture
.
createView
(
viewDescriptor
)
}
.
.
.
(
pipelineType
=
=
=
'
2d
-
array
'
?
[
{
binding
:
2
resource
:
{
buffer
:
uniformBuffer
}
}
]
:
[
]
)
]
}
)
;
this
.
device
.
queue
.
writeBuffer
(
uniformBuffer
0
new
Uint32Array
(
[
layer
]
)
)
;
const
encoder
=
this
.
device
.
createCommandEncoder
(
)
;
const
pass
=
encoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
attachment
.
createView
(
)
clearValue
:
[
0
.
5
0
.
5
0
.
5
0
.
5
]
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
]
}
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
bindGroup
)
;
pass
.
draw
(
3
)
;
pass
.
end
(
)
;
this
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
const
buffer
=
this
.
copyWholeTextureToNewBufferSimple
(
attachment
0
)
;
readbackPromisesPerLayer
.
push
(
this
.
readGPUBufferRangeTyped
(
buffer
{
type
:
Uint8Array
typedLength
:
buffer
.
size
}
)
)
;
}
return
readbackPromisesPerLayer
;
}
)
;
this
.
eventualAsyncExpectation
(
async
niceStack
=
>
{
const
readbacksPerTexturePerLayer
=
[
]
;
for
(
const
readbackPromises
of
readbackPromisesPerTexturePerLayer
)
{
readbacksPerTexturePerLayer
.
push
(
await
Promise
.
all
(
readbackPromises
)
)
;
}
function
arrayNotAllTheSameValue
(
arr
:
TypedArrayBufferView
|
number
[
]
msg
?
:
string
)
{
const
first
=
arr
[
0
]
;
return
arr
.
length
<
=
1
|
|
arr
.
findIndex
(
v
=
>
v
!
=
=
first
)
>
=
0
?
undefined
:
Error
(
array
is
entirely
{
first
}
so
likely
nothing
was
tested
:
{
msg
|
|
'
'
}
)
;
}
const
[
actualReadbacksPerLayer
expectedReadbacksPerLayer
]
=
readbacksPerTexturePerLayer
;
for
(
let
layer
=
0
;
layer
<
actualReadbacksPerLayer
.
length
;
+
+
layer
)
{
const
actualReadback
=
actualReadbacksPerLayer
[
layer
]
;
const
expectedReadback
=
expectedReadbacksPerLayer
[
layer
]
;
const
sameOk
=
size
.
width
=
=
=
0
|
|
size
.
height
=
=
=
0
|
|
layer
<
origin
.
z
|
|
layer
>
=
origin
.
z
+
size
.
depthOrArrayLayers
;
this
.
expectOK
(
sameOk
?
undefined
:
arrayNotAllTheSameValue
(
actualReadback
.
data
'
actualTexture
'
)
)
;
this
.
expectOK
(
sameOk
?
undefined
:
arrayNotAllTheSameValue
(
expectedReadback
.
data
'
expectedTexture
'
)
)
;
this
.
expectOK
(
checkElementsEqual
(
actualReadback
.
data
expectedReadback
.
data
)
{
mode
:
'
fail
'
niceStack
}
)
;
actualReadback
.
cleanup
(
)
;
expectedReadback
.
cleanup
(
)
;
}
}
)
;
}
copyWholeTextureToNewBufferSimple
(
texture
:
GPUTexture
mipLevel
:
number
)
{
const
{
blockWidth
blockHeight
bytesPerBlock
}
=
kTextureFormatInfo
[
texture
.
format
]
;
const
mipSize
=
physicalMipSizeFromTexture
(
texture
mipLevel
)
;
assert
(
bytesPerBlock
!
=
=
undefined
)
;
const
blocksPerRow
=
mipSize
[
0
]
/
blockWidth
;
const
blocksPerColumn
=
mipSize
[
1
]
/
blockHeight
;
assert
(
blocksPerRow
%
1
=
=
=
0
)
;
assert
(
blocksPerColumn
%
1
=
=
=
0
)
;
const
bytesPerRow
=
align
(
blocksPerRow
*
bytesPerBlock
256
)
;
const
byteLength
=
bytesPerRow
*
blocksPerColumn
*
mipSize
[
2
]
;
return
this
.
copyWholeTextureToNewBuffer
(
{
texture
mipLevel
}
{
bytesPerBlock
bytesPerRow
rowsPerImage
:
blocksPerColumn
byteLength
}
)
;
}
copyWholeTextureToNewBuffer
(
{
texture
mipLevel
}
:
{
texture
:
GPUTexture
;
mipLevel
:
number
|
undefined
}
resultDataLayout
:
{
bytesPerBlock
:
number
;
byteLength
:
number
;
bytesPerRow
:
number
;
rowsPerImage
:
number
;
}
)
:
GPUBuffer
{
const
{
byteLength
bytesPerRow
rowsPerImage
}
=
resultDataLayout
;
const
buffer
=
this
.
device
.
createBuffer
(
{
size
:
align
(
byteLength
4
)
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
COPY_DST
}
)
;
this
.
trackForCleanup
(
buffer
)
;
const
mipSize
=
physicalMipSizeFromTexture
(
texture
mipLevel
|
|
0
)
;
const
encoder
=
this
.
device
.
createCommandEncoder
(
)
;
encoder
.
copyTextureToBuffer
(
{
texture
mipLevel
}
{
buffer
bytesPerRow
rowsPerImage
}
mipSize
)
;
this
.
device
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
return
buffer
;
}
updateLinearTextureDataSubBox
(
format
:
ColorTextureFormat
copySize
:
Required
<
GPUExtent3DDict
>
copyParams
:
{
dest
:
LinearCopyParameters
;
src
:
LinearCopyParameters
;
}
)
:
void
{
const
{
src
dest
}
=
copyParams
;
const
rowLength
=
bytesInACompleteRow
(
copySize
.
width
format
)
;
for
(
const
texel
of
this
.
iterateBlockRows
(
copySize
format
)
)
{
const
srcOffsetElements
=
this
.
getTexelOffsetInBytes
(
src
.
dataLayout
format
texel
src
.
origin
)
;
const
dstOffsetElements
=
this
.
getTexelOffsetInBytes
(
dest
.
dataLayout
format
texel
dest
.
origin
)
;
memcpy
(
{
src
:
src
.
data
start
:
srcOffsetElements
length
:
rowLength
}
{
dst
:
dest
.
data
start
:
dstOffsetElements
}
)
;
}
}
getTexelOffsetInBytes
(
textureDataLayout
:
Required
<
GPUImageDataLayout
>
format
:
ColorTextureFormat
texel
:
Required
<
GPUOrigin3DDict
>
origin
:
Required
<
GPUOrigin3DDict
>
=
{
x
:
0
y
:
0
z
:
0
}
)
:
number
{
const
{
offset
bytesPerRow
rowsPerImage
}
=
textureDataLayout
;
const
info
=
kTextureFormatInfo
[
format
]
;
assert
(
texel
.
x
%
info
.
blockWidth
=
=
=
0
)
;
assert
(
texel
.
y
%
info
.
blockHeight
=
=
=
0
)
;
assert
(
origin
.
x
%
info
.
blockWidth
=
=
=
0
)
;
assert
(
origin
.
y
%
info
.
blockHeight
=
=
=
0
)
;
const
bytesPerImage
=
rowsPerImage
*
bytesPerRow
;
return
(
offset
+
(
texel
.
z
+
origin
.
z
)
*
bytesPerImage
+
(
(
texel
.
y
+
origin
.
y
)
/
info
.
blockHeight
)
*
bytesPerRow
+
(
(
texel
.
x
+
origin
.
x
)
/
info
.
blockWidth
)
*
info
.
color
.
bytes
)
;
}
*
iterateBlockRows
(
size
:
Required
<
GPUExtent3DDict
>
format
:
ColorTextureFormat
)
:
Generator
<
Required
<
GPUOrigin3DDict
>
>
{
if
(
size
.
width
=
=
=
0
|
|
size
.
height
=
=
=
0
|
|
size
.
depthOrArrayLayers
=
=
=
0
)
{
return
;
}
const
info
=
kTextureFormatInfo
[
format
]
;
assert
(
size
.
height
%
info
.
blockHeight
=
=
=
0
)
;
for
(
let
z
=
0
;
z
<
size
.
depthOrArrayLayers
;
+
+
z
)
{
for
(
let
y
=
0
;
y
<
size
.
height
;
y
+
=
info
.
blockHeight
)
{
yield
{
x
:
0
y
z
}
;
}
}
}
}
return
TextureExpectations
as
unknown
as
FixtureClassWithMixin
<
F
TextureTestMixinType
>
;
}
