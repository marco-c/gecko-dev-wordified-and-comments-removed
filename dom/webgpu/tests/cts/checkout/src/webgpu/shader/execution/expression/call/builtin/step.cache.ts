import
{
anyOf
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
util
/
compare
.
js
'
;
import
{
FP
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
util
/
floating_point
.
js
'
;
import
{
Case
}
from
'
.
.
/
.
.
/
case
.
js
'
;
import
{
makeCaseCache
}
from
'
.
.
/
.
.
/
case_cache
.
js
'
;
const
makeCase
=
(
trait
:
'
f32
'
|
'
f16
'
|
'
abstract
'
edge
:
number
x
:
number
)
:
Case
=
>
{
const
FPTrait
=
FP
[
trait
]
;
edge
=
FPTrait
.
quantize
(
edge
)
;
x
=
FPTrait
.
quantize
(
x
)
;
const
expected
=
FPTrait
.
stepInterval
(
edge
x
)
;
if
(
expected
.
isPoint
(
)
|
|
!
expected
.
isFinite
(
)
)
{
return
{
input
:
[
FPTrait
.
scalarBuilder
(
edge
)
FPTrait
.
scalarBuilder
(
x
)
]
expected
}
;
}
const
zeroInterval
=
FPTrait
.
toInterval
(
0
)
;
const
oneInterval
=
FPTrait
.
toInterval
(
1
)
;
return
{
input
:
[
FPTrait
.
scalarBuilder
(
edge
)
FPTrait
.
scalarBuilder
(
x
)
]
expected
:
anyOf
(
zeroInterval
oneInterval
)
}
;
}
;
const
cases
=
(
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
map
(
trait
=
>
(
{
[
{
trait
}
]
:
(
)
=
>
{
return
FP
[
trait
]
.
sparseScalarRange
(
)
.
flatMap
(
edge
=
>
FP
[
trait
]
.
sparseScalarRange
(
)
.
map
(
x
=
>
makeCase
(
trait
edge
x
)
)
)
;
}
}
)
)
.
reduce
(
(
a
b
)
=
>
(
{
.
.
.
a
.
.
.
b
}
)
{
}
)
;
export
const
d
=
makeCaseCache
(
'
step
'
cases
)
;
