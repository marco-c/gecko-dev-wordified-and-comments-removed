import
{
AccessMode
AddressSpace
AddressSpaceInfo
kAccessModeInfo
kAddressSpaceInfo
}
from
'
.
.
/
.
.
/
types
.
js
'
;
export
type
ShaderStage
=
'
vertex
'
|
'
fragment
'
|
'
compute
'
;
export
const
kShaderStages
=
[
'
vertex
'
'
fragment
'
'
compute
'
]
as
const
;
export
function
declareEntryPoint
(
arg
:
{
name
?
:
string
;
stage
:
ShaderStage
;
body
:
string
;
}
)
:
string
{
if
(
arg
.
name
=
=
=
undefined
)
{
arg
.
name
=
'
main
'
;
}
switch
(
arg
.
stage
)
{
case
'
vertex
'
:
return
vertex
fn
{
arg
.
name
}
(
)
-
>
builtin
(
position
)
vec4f
{
{
arg
.
body
}
return
vec4f
(
)
;
}
;
case
'
fragment
'
:
return
fragment
fn
{
arg
.
name
}
(
)
{
{
arg
.
body
}
}
;
case
'
compute
'
:
return
compute
workgroup_size
(
1
)
fn
{
arg
.
name
}
(
)
{
{
arg
.
body
}
}
;
}
}
export
function
declareVarX
(
addressSpace
:
AddressSpace
|
'
'
accessMode
:
AccessMode
|
'
'
)
:
string
{
const
parts
:
string
[
]
=
[
]
;
if
(
addressSpace
&
&
kAddressSpaceInfo
[
addressSpace
]
.
binding
)
parts
.
push
(
'
group
(
0
)
binding
(
0
)
'
)
;
parts
.
push
(
'
var
'
)
;
const
template_parts
:
string
[
]
=
[
]
;
if
(
addressSpace
)
template_parts
.
push
(
addressSpace
)
;
if
(
accessMode
)
template_parts
.
push
(
accessMode
)
;
if
(
template_parts
.
length
>
0
)
parts
.
push
(
<
{
template_parts
.
join
(
'
'
)
}
>
)
;
parts
.
push
(
'
x
:
i32
;
'
)
;
return
parts
.
join
(
'
'
)
;
}
export
function
explicitSpaceExpander
(
p
:
{
addressSpace
:
AddressSpace
}
)
:
readonly
boolean
[
]
{
const
info
=
kAddressSpaceInfo
[
p
.
addressSpace
]
;
return
info
.
spell
=
=
=
'
must
'
?
[
true
]
:
[
true
false
]
;
}
export
function
accessModeExpander
(
p
:
{
addressSpace
:
AddressSpace
;
explicitAccess
:
boolean
;
}
)
:
readonly
(
AccessMode
|
'
'
)
[
]
{
const
info
=
kAddressSpaceInfo
[
p
.
addressSpace
]
;
return
p
.
explicitAccess
&
&
info
.
spellAccessMode
!
=
=
'
never
'
?
info
.
accessModes
:
[
'
'
]
;
}
export
function
getVarDeclShader
(
p
:
{
addressSpace
:
AddressSpace
;
explicitSpace
:
boolean
;
accessMode
:
AccessMode
|
'
'
;
explicitAccess
:
boolean
;
stage
:
ShaderStage
;
}
additionalBody
?
:
string
)
:
string
{
const
info
=
kAddressSpaceInfo
[
p
.
addressSpace
]
;
const
decl
=
declareVarX
(
p
.
explicitSpace
?
p
.
addressSpace
:
'
'
p
.
explicitAccess
?
p
.
accessMode
:
'
'
)
;
additionalBody
=
additionalBody
?
?
'
'
;
switch
(
info
.
scope
)
{
case
'
module
'
:
return
decl
+
'
\
n
'
+
declareEntryPoint
(
{
stage
:
p
.
stage
body
:
additionalBody
}
)
;
case
'
function
'
:
return
declareEntryPoint
(
{
stage
:
p
.
stage
body
:
decl
+
'
\
n
'
+
additionalBody
}
)
;
}
}
export
function
pointerType
(
p
:
{
addressSpace
:
AddressSpace
;
explicitSpace
:
boolean
;
accessMode
:
AccessMode
|
'
'
;
ptrStoreType
:
string
;
}
)
:
string
{
const
space
=
p
.
explicitSpace
?
p
.
addressSpace
:
'
function
'
;
const
modePart
=
p
.
accessMode
?
'
'
+
p
.
accessMode
:
'
'
;
return
ptr
<
{
space
}
{
p
.
ptrStoreType
}
{
modePart
}
>
;
}
export
function
effectiveAccessMode
(
info
:
AddressSpaceInfo
accessMode
:
AccessMode
|
'
'
)
:
AccessMode
{
return
accessMode
|
|
info
.
accessModes
[
0
]
;
}
export
function
supportsRead
(
p
:
{
addressSpace
:
AddressSpace
;
accessMode
:
AccessMode
|
'
'
;
}
)
:
boolean
{
const
info
=
kAddressSpaceInfo
[
p
.
addressSpace
]
;
const
mode
=
effectiveAccessMode
(
info
p
.
accessMode
)
;
return
info
.
accessModes
.
includes
(
mode
)
&
&
kAccessModeInfo
[
mode
]
.
read
;
}
export
function
supportsWrite
(
p
:
{
addressSpace
:
AddressSpace
;
accessMode
:
AccessMode
|
'
'
;
}
)
:
boolean
{
const
info
=
kAddressSpaceInfo
[
p
.
addressSpace
]
;
const
mode
=
effectiveAccessMode
(
info
p
.
accessMode
)
;
return
info
.
accessModes
.
includes
(
mode
)
&
&
kAccessModeInfo
[
mode
]
.
write
;
}
