import
{
Cacheable
dataCache
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
framework
/
data_cache
.
js
'
;
import
{
SerializedComparator
deserializeComparator
}
from
'
.
.
/
.
.
/
.
.
/
util
/
compare
.
js
'
;
import
{
Scalar
Vector
serializeValue
SerializedValue
deserializeValue
}
from
'
.
.
/
.
.
/
.
.
/
util
/
conversion
.
js
'
;
import
{
deserializeF32Interval
F32Interval
SerializedF32Interval
serializeF32Interval
}
from
'
.
.
/
.
.
/
.
.
/
util
/
f32_interval
.
js
'
;
import
{
Case
CaseList
Expectation
}
from
'
.
/
expression
.
js
'
;
type
SerializedExpectationValue
=
{
kind
:
'
value
'
;
value
:
SerializedValue
;
}
;
type
SerializedExpectationInterval
=
{
kind
:
'
interval
'
;
value
:
SerializedF32Interval
;
}
;
type
SerializedExpectationIntervals
=
{
kind
:
'
intervals
'
;
value
:
SerializedF32Interval
[
]
;
}
;
type
SerializedExpectationComparator
=
{
kind
:
'
comparator
'
;
value
:
SerializedComparator
;
}
;
export
type
SerializedExpectation
=
|
SerializedExpectationValue
|
SerializedExpectationInterval
|
SerializedExpectationIntervals
|
SerializedExpectationComparator
;
export
function
serializeExpectation
(
e
:
Expectation
)
:
SerializedExpectation
{
if
(
e
instanceof
Scalar
|
|
e
instanceof
Vector
)
{
return
{
kind
:
'
value
'
value
:
serializeValue
(
e
)
}
;
}
if
(
e
instanceof
F32Interval
)
{
return
{
kind
:
'
interval
'
value
:
serializeF32Interval
(
e
)
}
;
}
if
(
e
instanceof
Array
)
{
return
{
kind
:
'
intervals
'
value
:
e
.
map
(
i
=
>
serializeF32Interval
(
i
)
)
}
;
}
if
(
e
instanceof
Function
)
{
const
comp
=
(
e
as
unknown
)
as
SerializedComparator
;
if
(
comp
!
=
=
undefined
)
{
if
(
comp
.
kind
=
=
=
'
anyOf
'
)
{
return
{
kind
:
'
comparator
'
value
:
{
kind
:
comp
.
kind
data
:
comp
.
data
}
}
;
}
if
(
comp
.
kind
=
=
=
'
skipUndefined
'
)
{
return
{
kind
:
'
comparator
'
value
:
{
kind
:
comp
.
kind
data
:
comp
.
data
}
}
;
}
}
throw
'
cannot
serialize
comparator
'
;
}
throw
'
cannot
serialize
expectation
'
;
}
export
function
deserializeExpectation
(
data
:
SerializedExpectation
)
:
Expectation
{
switch
(
data
.
kind
)
{
case
'
value
'
:
return
deserializeValue
(
data
.
value
)
;
case
'
interval
'
:
return
deserializeF32Interval
(
data
.
value
)
;
case
'
intervals
'
:
return
data
.
value
.
map
(
i
=
>
deserializeF32Interval
(
i
)
)
;
case
'
comparator
'
:
return
deserializeComparator
(
data
.
value
)
;
}
}
export
type
SerializedCase
=
{
input
:
SerializedValue
|
SerializedValue
[
]
;
expected
:
SerializedExpectation
;
}
;
export
function
serializeCase
(
c
:
Case
)
:
SerializedCase
{
return
{
input
:
c
.
input
instanceof
Array
?
c
.
input
.
map
(
v
=
>
serializeValue
(
v
)
)
:
serializeValue
(
c
.
input
)
expected
:
serializeExpectation
(
c
.
expected
)
}
;
}
export
function
deserializeCase
(
data
:
SerializedCase
)
:
Case
{
return
{
input
:
data
.
input
instanceof
Array
?
data
.
input
.
map
(
v
=
>
deserializeValue
(
v
)
)
:
deserializeValue
(
data
.
input
)
expected
:
deserializeExpectation
(
data
.
expected
)
}
;
}
export
type
CaseListBuilder
=
(
)
=
>
CaseList
;
export
class
CaseCache
implements
Cacheable
<
Record
<
string
CaseList
>
>
{
constructor
(
name
:
string
builders
:
Record
<
string
CaseListBuilder
>
)
{
this
.
path
=
webgpu
/
shader
/
execution
/
case
-
cache
/
{
name
}
.
json
;
this
.
builders
=
builders
;
}
public
async
get
(
name
:
string
)
:
Promise
<
CaseList
>
{
const
data
=
await
dataCache
.
fetch
(
this
)
;
return
data
[
name
]
;
}
build
(
)
:
Promise
<
Record
<
string
CaseList
>
>
{
const
built
:
Record
<
string
CaseList
>
=
{
}
;
for
(
const
name
in
this
.
builders
)
{
const
cases
=
this
.
builders
[
name
]
(
)
;
built
[
name
]
=
cases
;
}
return
Promise
.
resolve
(
built
)
;
}
serialize
(
data
:
Record
<
string
CaseList
>
)
:
string
{
const
serialized
:
Record
<
string
SerializedCase
[
]
>
=
{
}
;
for
(
const
name
in
data
)
{
serialized
[
name
]
=
data
[
name
]
.
map
(
c
=
>
serializeCase
(
c
)
)
;
}
return
JSON
.
stringify
(
serialized
)
;
}
deserialize
(
serialized
:
string
)
:
Record
<
string
CaseList
>
{
const
data
=
JSON
.
parse
(
serialized
)
as
Record
<
string
SerializedCase
[
]
>
;
const
casesByName
:
Record
<
string
CaseList
>
=
{
}
;
for
(
const
name
in
data
)
{
const
cases
=
data
[
name
]
.
map
(
caseData
=
>
deserializeCase
(
caseData
)
)
;
casesByName
[
name
]
=
cases
;
}
return
casesByName
;
}
public
readonly
path
:
string
;
private
readonly
builders
:
Record
<
string
CaseListBuilder
>
;
}
export
function
makeCaseCache
(
name
:
string
builders
:
Record
<
string
CaseListBuilder
>
)
:
CaseCache
{
return
new
CaseCache
(
name
builders
)
;
}
