import
{
GPUTest
}
from
'
.
.
/
.
.
/
.
.
/
gpu_test
'
;
import
{
checkElementsPassPredicate
}
from
'
.
.
/
.
.
/
.
.
/
util
/
check_contents
.
js
'
;
export
type
AccessValueType
=
'
f16
'
|
'
u32
'
;
export
const
kAccessValueTypes
=
[
'
f16
'
'
u32
'
]
as
const
;
export
type
MemoryModelTestParams
=
{
workgroupSize
:
number
;
testingWorkgroups
:
number
;
maxWorkgroups
:
number
;
shufflePct
:
number
;
barrierPct
:
number
;
memStressPct
:
number
;
memStressIterations
:
number
;
memStressStoreFirstPct
:
number
;
memStressStoreSecondPct
:
number
;
preStressPct
:
number
;
preStressIterations
:
number
;
preStressStoreFirstPct
:
number
;
preStressStoreSecondPct
:
number
;
scratchMemorySize
:
number
;
stressLineSize
:
number
;
stressTargetLines
:
number
;
stressStrategyBalancePct
:
number
;
permuteFirst
:
number
;
permuteSecond
:
number
;
memStride
:
number
;
aliasedMemory
:
boolean
;
numBehaviors
:
number
;
}
;
const
numMemLocations
=
2
;
const
numReadOutputs
=
2
;
type
BufferWithSource
=
{
deviceBuf
:
GPUBuffer
;
srcBuf
:
GPUBuffer
;
size
:
number
;
}
;
type
MemoryModelBuffers
=
{
testLocations
:
BufferWithSource
;
readResults
:
BufferWithSource
;
testResults
:
BufferWithSource
;
shuffledWorkgroups
:
BufferWithSource
;
barrier
:
BufferWithSource
;
scratchpad
:
BufferWithSource
;
scratchMemoryLocations
:
BufferWithSource
;
stressParams
:
BufferWithSource
;
}
;
const
numStressParams
=
12
;
const
barrierParamIndex
=
0
;
const
memStressIndex
=
1
;
const
memStressIterationsIndex
=
2
;
const
memStressPatternIndex
=
3
;
const
preStressIndex
=
4
;
const
preStressIterationsIndex
=
5
;
const
preStressPatternIndex
=
6
;
const
permuteFirstIndex
=
7
;
const
permuteSecondIndex
=
8
;
const
testingWorkgroupsIndex
=
9
;
const
memStrideIndex
=
10
;
const
memLocationOffsetIndex
=
11
;
const
bytesPerWord
=
4
;
function
shaderPreamble
(
accessValueType
:
AccessValueType
)
:
string
{
if
(
accessValueType
=
=
=
'
f16
'
)
{
return
'
enable
f16
;
\
nalias
AccessValueTy
=
f16
;
\
n
'
;
}
return
alias
AccessValueTy
=
{
accessValueType
}
;
\
n
;
}
export
class
MemoryModelTester
{
protected
test
:
GPUTest
;
protected
params
:
MemoryModelTestParams
;
protected
buffers
:
MemoryModelBuffers
;
protected
testPipeline
:
GPUComputePipeline
;
protected
testBindGroup
:
GPUBindGroup
;
protected
resultPipeline
:
GPUComputePipeline
;
protected
resultBindGroup
:
GPUBindGroup
;
constructor
(
t
:
GPUTest
params
:
MemoryModelTestParams
testShader
:
string
resultShader
:
string
accessValueType
:
AccessValueType
=
'
u32
'
)
{
this
.
test
=
t
;
this
.
params
=
params
;
testShader
=
shaderPreamble
(
accessValueType
)
+
testShader
;
resultShader
=
shaderPreamble
(
accessValueType
)
+
resultShader
;
const
testingThreads
=
this
.
params
.
workgroupSize
*
this
.
params
.
testingWorkgroups
;
const
testLocationsSize
=
testingThreads
*
numMemLocations
*
this
.
params
.
memStride
*
bytesPerWord
;
const
testLocationsBuffer
:
BufferWithSource
=
{
deviceBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
testLocationsSize
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
}
)
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
testLocationsSize
usage
:
GPUBufferUsage
.
COPY_SRC
}
)
size
:
testLocationsSize
}
;
const
readResultsSize
=
testingThreads
*
numReadOutputs
*
bytesPerWord
;
const
readResultsBuffer
:
BufferWithSource
=
{
deviceBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
readResultsSize
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
}
)
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
readResultsSize
usage
:
GPUBufferUsage
.
COPY_SRC
}
)
size
:
readResultsSize
}
;
const
testResultsSize
=
this
.
params
.
numBehaviors
*
bytesPerWord
;
const
testResultsBuffer
:
BufferWithSource
=
{
deviceBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
testResultsSize
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_SRC
}
)
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
testResultsSize
usage
:
GPUBufferUsage
.
COPY_SRC
}
)
size
:
testResultsSize
}
;
const
shuffledWorkgroupsSize
=
this
.
params
.
maxWorkgroups
*
bytesPerWord
;
const
shuffledWorkgroupsBuffer
:
BufferWithSource
=
{
deviceBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
shuffledWorkgroupsSize
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
}
)
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
shuffledWorkgroupsSize
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
MAP_WRITE
}
)
size
:
shuffledWorkgroupsSize
}
;
const
barrierSize
=
bytesPerWord
;
const
barrierBuffer
:
BufferWithSource
=
{
deviceBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
barrierSize
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
}
)
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
barrierSize
usage
:
GPUBufferUsage
.
COPY_SRC
}
)
size
:
barrierSize
}
;
const
scratchpadSize
=
this
.
params
.
scratchMemorySize
*
bytesPerWord
;
const
scratchpadBuffer
:
BufferWithSource
=
{
deviceBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
scratchpadSize
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
}
)
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
scratchpadSize
usage
:
GPUBufferUsage
.
COPY_SRC
}
)
size
:
scratchpadSize
}
;
const
scratchMemoryLocationsSize
=
this
.
params
.
maxWorkgroups
*
bytesPerWord
;
const
scratchMemoryLocationsBuffer
:
BufferWithSource
=
{
deviceBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
scratchMemoryLocationsSize
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
}
)
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
scratchMemoryLocationsSize
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
MAP_WRITE
}
)
size
:
scratchMemoryLocationsSize
}
;
const
stressParamsSize
=
numStressParams
*
bytesPerWord
;
const
stressParamsBuffer
:
BufferWithSource
=
{
deviceBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
stressParamsSize
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
UNIFORM
}
)
srcBuf
:
this
.
test
.
device
.
createBuffer
(
{
size
:
stressParamsSize
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
MAP_WRITE
}
)
size
:
stressParamsSize
}
;
this
.
buffers
=
{
testLocations
:
testLocationsBuffer
readResults
:
readResultsBuffer
testResults
:
testResultsBuffer
shuffledWorkgroups
:
shuffledWorkgroupsBuffer
barrier
:
barrierBuffer
scratchpad
:
scratchpadBuffer
scratchMemoryLocations
:
scratchMemoryLocationsBuffer
stressParams
:
stressParamsBuffer
}
;
const
testLayout
=
this
.
test
.
device
.
createBindGroupLayout
(
{
entries
:
[
{
binding
:
0
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
{
binding
:
1
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
{
binding
:
2
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
read
-
only
-
storage
'
}
}
{
binding
:
3
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
{
binding
:
4
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
{
binding
:
5
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
{
binding
:
6
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
uniform
'
}
}
]
}
)
;
this
.
testPipeline
=
this
.
test
.
device
.
createComputePipeline
(
{
layout
:
this
.
test
.
device
.
createPipelineLayout
(
{
bindGroupLayouts
:
[
testLayout
]
}
)
compute
:
{
module
:
this
.
test
.
device
.
createShaderModule
(
{
code
:
testShader
}
)
entryPoint
:
'
main
'
}
}
)
;
this
.
testBindGroup
=
this
.
test
.
device
.
createBindGroup
(
{
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
this
.
buffers
.
testLocations
.
deviceBuf
}
}
{
binding
:
1
resource
:
{
buffer
:
this
.
buffers
.
readResults
.
deviceBuf
}
}
{
binding
:
2
resource
:
{
buffer
:
this
.
buffers
.
shuffledWorkgroups
.
deviceBuf
}
}
{
binding
:
3
resource
:
{
buffer
:
this
.
buffers
.
barrier
.
deviceBuf
}
}
{
binding
:
4
resource
:
{
buffer
:
this
.
buffers
.
scratchpad
.
deviceBuf
}
}
{
binding
:
5
resource
:
{
buffer
:
this
.
buffers
.
scratchMemoryLocations
.
deviceBuf
}
}
{
binding
:
6
resource
:
{
buffer
:
this
.
buffers
.
stressParams
.
deviceBuf
}
}
]
layout
:
testLayout
}
)
;
const
resultLayout
=
this
.
test
.
device
.
createBindGroupLayout
(
{
entries
:
[
{
binding
:
0
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
{
binding
:
1
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
{
binding
:
2
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
{
binding
:
3
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
uniform
'
}
}
]
}
)
;
this
.
resultPipeline
=
this
.
test
.
device
.
createComputePipeline
(
{
layout
:
this
.
test
.
device
.
createPipelineLayout
(
{
bindGroupLayouts
:
[
resultLayout
]
}
)
compute
:
{
module
:
this
.
test
.
device
.
createShaderModule
(
{
code
:
resultShader
}
)
entryPoint
:
'
main
'
}
}
)
;
this
.
resultBindGroup
=
this
.
test
.
device
.
createBindGroup
(
{
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
this
.
buffers
.
testLocations
.
deviceBuf
}
}
{
binding
:
1
resource
:
{
buffer
:
this
.
buffers
.
readResults
.
deviceBuf
}
}
{
binding
:
2
resource
:
{
buffer
:
this
.
buffers
.
testResults
.
deviceBuf
}
}
{
binding
:
3
resource
:
{
buffer
:
this
.
buffers
.
stressParams
.
deviceBuf
}
}
]
layout
:
resultLayout
}
)
;
}
async
run
(
iterations
:
number
weakIndex
:
number
)
:
Promise
<
void
>
{
for
(
let
i
=
0
;
i
<
iterations
;
i
+
+
)
{
const
numWorkgroups
=
this
.
getRandomInRange
(
this
.
params
.
testingWorkgroups
this
.
params
.
maxWorkgroups
)
;
await
this
.
setShuffledWorkgroups
(
numWorkgroups
)
;
await
this
.
setScratchLocations
(
numWorkgroups
)
;
await
this
.
setStressParams
(
)
;
const
encoder
=
this
.
test
.
device
.
createCommandEncoder
(
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
testLocations
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
readResults
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
testResults
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
barrier
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
shuffledWorkgroups
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
scratchpad
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
scratchMemoryLocations
)
;
this
.
copyBufferToBuffer
(
encoder
this
.
buffers
.
stressParams
)
;
const
testPass
=
encoder
.
beginComputePass
(
)
;
testPass
.
setPipeline
(
this
.
testPipeline
)
;
testPass
.
setBindGroup
(
0
this
.
testBindGroup
)
;
testPass
.
dispatchWorkgroups
(
numWorkgroups
)
;
testPass
.
end
(
)
;
const
resultPass
=
encoder
.
beginComputePass
(
)
;
resultPass
.
setPipeline
(
this
.
resultPipeline
)
;
resultPass
.
setBindGroup
(
0
this
.
resultBindGroup
)
;
resultPass
.
dispatchWorkgroups
(
this
.
params
.
testingWorkgroups
)
;
resultPass
.
end
(
)
;
this
.
test
.
device
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
this
.
test
.
expectGPUBufferValuesPassCheck
(
this
.
buffers
.
testResults
.
deviceBuf
this
.
checkWeakIndex
(
weakIndex
)
{
type
:
Uint32Array
typedLength
:
this
.
params
.
numBehaviors
}
)
;
}
}
protected
checkWeakIndex
(
weakIndex
:
number
)
:
(
a
:
Uint32Array
)
=
>
Error
|
undefined
{
const
checkResult
=
this
.
checkResult
(
weakIndex
)
;
const
resultPrinter
=
this
.
resultPrinter
(
weakIndex
)
;
return
function
(
a
:
Uint32Array
)
:
Error
|
undefined
{
return
checkElementsPassPredicate
(
a
checkResult
{
predicatePrinter
:
[
{
leftHeader
:
'
expected
=
=
'
getValueForCell
:
resultPrinter
}
]
}
)
;
}
;
}
protected
checkResult
(
weakIndex
:
number
)
:
(
i
:
number
v
:
number
)
=
>
boolean
{
return
function
(
i
:
number
v
:
number
)
:
boolean
{
if
(
i
=
=
=
weakIndex
&
&
v
>
0
)
{
return
false
;
}
return
true
;
}
;
}
protected
resultPrinter
(
weakIndex
:
number
)
:
(
i
:
number
)
=
>
string
|
number
{
return
function
(
i
:
number
)
:
string
|
number
{
if
(
i
=
=
=
weakIndex
)
{
return
0
;
}
else
{
return
'
any
value
'
;
}
}
;
}
protected
copyBufferToBuffer
(
encoder
:
GPUCommandEncoder
buffer
:
BufferWithSource
)
:
void
{
encoder
.
copyBufferToBuffer
(
buffer
.
srcBuf
0
buffer
.
deviceBuf
0
buffer
.
size
)
;
}
protected
getRandomInt
(
max
:
number
)
:
number
{
return
Math
.
floor
(
Math
.
random
(
)
*
max
)
;
}
protected
getRandomInRange
(
min
:
number
max
:
number
)
:
number
{
if
(
min
=
=
=
max
)
{
return
min
;
}
else
{
const
offset
=
this
.
getRandomInt
(
max
-
min
)
;
return
min
+
offset
;
}
}
protected
shuffleArray
(
a
:
number
[
]
)
:
void
{
for
(
let
i
=
a
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
toSwap
=
this
.
getRandomInt
(
i
+
1
)
;
const
temp
=
a
[
toSwap
]
;
a
[
toSwap
]
=
a
[
i
]
;
a
[
i
]
=
temp
;
}
}
protected
async
setShuffledWorkgroups
(
numWorkgroups
:
number
)
:
Promise
<
void
>
{
await
this
.
buffers
.
shuffledWorkgroups
.
srcBuf
.
mapAsync
(
GPUMapMode
.
WRITE
)
;
const
shuffledWorkgroupsBuffer
=
this
.
buffers
.
shuffledWorkgroups
.
srcBuf
.
getMappedRange
(
)
;
const
shuffledWorkgroupsArray
=
new
Uint32Array
(
shuffledWorkgroupsBuffer
)
;
for
(
let
i
=
0
;
i
<
numWorkgroups
;
i
+
+
)
{
shuffledWorkgroupsArray
[
i
]
=
i
;
}
if
(
this
.
getRandomInt
(
100
)
<
this
.
params
.
shufflePct
)
{
for
(
let
i
=
numWorkgroups
-
1
;
i
>
0
;
i
-
-
)
{
const
x
=
this
.
getRandomInt
(
i
+
1
)
;
const
temp
=
shuffledWorkgroupsArray
[
i
]
;
shuffledWorkgroupsArray
[
i
]
=
shuffledWorkgroupsArray
[
x
]
;
shuffledWorkgroupsArray
[
x
]
=
temp
;
}
}
this
.
buffers
.
shuffledWorkgroups
.
srcBuf
.
unmap
(
)
;
}
protected
async
setScratchLocations
(
numWorkgroups
:
number
)
:
Promise
<
void
>
{
await
this
.
buffers
.
scratchMemoryLocations
.
srcBuf
.
mapAsync
(
GPUMapMode
.
WRITE
)
;
const
scratchLocationsArrayBuffer
=
this
.
buffers
.
scratchMemoryLocations
.
srcBuf
.
getMappedRange
(
)
;
const
scratchLocationsArray
=
new
Uint32Array
(
scratchLocationsArrayBuffer
)
;
const
scratchNumRegions
=
this
.
params
.
scratchMemorySize
/
this
.
params
.
stressLineSize
;
const
scratchRegions
=
[
.
.
.
Array
(
scratchNumRegions
)
.
keys
(
)
]
;
this
.
shuffleArray
(
scratchRegions
)
;
for
(
let
i
=
0
;
i
<
this
.
params
.
stressTargetLines
;
i
+
+
)
{
const
region
=
scratchRegions
[
i
]
;
const
locInRegion
=
this
.
getRandomInt
(
this
.
params
.
stressLineSize
)
;
if
(
this
.
getRandomInt
(
100
)
<
this
.
params
.
stressStrategyBalancePct
)
{
for
(
let
j
=
i
;
j
<
numWorkgroups
;
j
+
=
this
.
params
.
stressTargetLines
)
{
scratchLocationsArray
[
j
]
=
region
*
this
.
params
.
stressLineSize
+
locInRegion
;
}
}
else
{
const
workgroupsPerLocation
=
numWorkgroups
/
this
.
params
.
stressTargetLines
;
for
(
let
j
=
0
;
j
<
workgroupsPerLocation
;
j
+
+
)
{
scratchLocationsArray
[
i
*
workgroupsPerLocation
+
j
]
=
region
*
this
.
params
.
stressLineSize
+
locInRegion
;
}
if
(
i
=
=
=
this
.
params
.
stressTargetLines
-
1
&
&
numWorkgroups
%
this
.
params
.
stressTargetLines
!
=
=
0
)
{
for
(
let
j
=
0
;
j
<
numWorkgroups
%
this
.
params
.
stressTargetLines
;
j
+
+
)
{
scratchLocationsArray
[
numWorkgroups
-
j
-
1
]
=
region
*
this
.
params
.
stressLineSize
+
locInRegion
;
}
}
}
}
this
.
buffers
.
scratchMemoryLocations
.
srcBuf
.
unmap
(
)
;
}
protected
async
setStressParams
(
)
:
Promise
<
void
>
{
await
this
.
buffers
.
stressParams
.
srcBuf
.
mapAsync
(
GPUMapMode
.
WRITE
)
;
const
stressParamsArrayBuffer
=
this
.
buffers
.
stressParams
.
srcBuf
.
getMappedRange
(
)
;
const
stressParamsArray
=
new
Uint32Array
(
stressParamsArrayBuffer
)
;
if
(
this
.
getRandomInt
(
100
)
<
this
.
params
.
barrierPct
)
{
stressParamsArray
[
barrierParamIndex
]
=
1
;
}
else
{
stressParamsArray
[
barrierParamIndex
]
=
0
;
}
if
(
this
.
getRandomInt
(
100
)
<
this
.
params
.
memStressPct
)
{
stressParamsArray
[
memStressIndex
]
=
1
;
}
else
{
stressParamsArray
[
memStressIndex
]
=
0
;
}
stressParamsArray
[
memStressIterationsIndex
]
=
this
.
params
.
memStressIterations
;
const
memStressStoreFirst
=
this
.
getRandomInt
(
100
)
<
this
.
params
.
memStressStoreFirstPct
;
const
memStressStoreSecond
=
this
.
getRandomInt
(
100
)
<
this
.
params
.
memStressStoreSecondPct
;
let
memStressPattern
;
if
(
memStressStoreFirst
&
&
memStressStoreSecond
)
{
memStressPattern
=
0
;
}
else
if
(
memStressStoreFirst
&
&
!
memStressStoreSecond
)
{
memStressPattern
=
1
;
}
else
if
(
!
memStressStoreFirst
&
&
memStressStoreSecond
)
{
memStressPattern
=
2
;
}
else
{
memStressPattern
=
3
;
}
stressParamsArray
[
memStressPatternIndex
]
=
memStressPattern
;
if
(
this
.
getRandomInt
(
100
)
<
this
.
params
.
preStressPct
)
{
stressParamsArray
[
preStressIndex
]
=
1
;
}
else
{
stressParamsArray
[
preStressIndex
]
=
0
;
}
stressParamsArray
[
preStressIterationsIndex
]
=
this
.
params
.
preStressIterations
;
const
preStressStoreFirst
=
this
.
getRandomInt
(
100
)
<
this
.
params
.
preStressStoreFirstPct
;
const
preStressStoreSecond
=
this
.
getRandomInt
(
100
)
<
this
.
params
.
preStressStoreSecondPct
;
let
preStressPattern
;
if
(
preStressStoreFirst
&
&
preStressStoreSecond
)
{
preStressPattern
=
0
;
}
else
if
(
preStressStoreFirst
&
&
!
preStressStoreSecond
)
{
preStressPattern
=
1
;
}
else
if
(
!
preStressStoreFirst
&
&
preStressStoreSecond
)
{
preStressPattern
=
2
;
}
else
{
preStressPattern
=
3
;
}
stressParamsArray
[
preStressPatternIndex
]
=
preStressPattern
;
stressParamsArray
[
permuteFirstIndex
]
=
this
.
params
.
permuteFirst
;
stressParamsArray
[
permuteSecondIndex
]
=
this
.
params
.
permuteSecond
;
stressParamsArray
[
testingWorkgroupsIndex
]
=
this
.
params
.
testingWorkgroups
;
stressParamsArray
[
memStrideIndex
]
=
this
.
params
.
memStride
;
if
(
this
.
params
.
aliasedMemory
)
{
stressParamsArray
[
memLocationOffsetIndex
]
=
0
;
}
else
{
stressParamsArray
[
memLocationOffsetIndex
]
=
this
.
params
.
memStride
;
}
this
.
buffers
.
stressParams
.
srcBuf
.
unmap
(
)
;
}
}
const
shaderMemStructures
=
struct
Memory
{
value
:
array
<
AccessValueTy
>
}
;
struct
AtomicMemory
{
value
:
array
<
atomic
<
u32
>
>
}
;
struct
IndexMemory
{
value
:
array
<
u32
>
}
;
struct
ReadResult
{
r0
:
atomic
<
u32
>
r1
:
atomic
<
u32
>
}
;
struct
ReadResults
{
value
:
array
<
ReadResult
>
}
;
struct
StressParamsMemory
{
do_barrier
:
u32
mem_stress
:
u32
mem_stress_iterations
:
u32
mem_stress_pattern
:
u32
pre_stress
:
u32
pre_stress_iterations
:
u32
pre_stress_pattern
:
u32
permute_first
:
u32
permute_second
:
u32
testing_workgroups
:
u32
mem_stride
:
u32
location_offset
:
u32
}
;
;
const
fourBehaviorTestResultStructure
=
struct
TestResults
{
seq0
:
atomic
<
u32
>
seq1
:
atomic
<
u32
>
interleaved
:
atomic
<
u32
>
weak
:
atomic
<
u32
>
}
;
;
const
twoBehaviorTestResultStructure
=
struct
TestResults
{
seq
:
atomic
<
u32
>
weak
:
atomic
<
u32
>
}
;
;
const
commonTestShaderBindings
=
group
(
0
)
binding
(
1
)
var
<
storage
read_write
>
results
:
ReadResults
;
group
(
0
)
binding
(
2
)
var
<
storage
read
>
shuffled_workgroups
:
IndexMemory
;
group
(
0
)
binding
(
3
)
var
<
storage
read_write
>
barrier
:
AtomicMemory
;
group
(
0
)
binding
(
4
)
var
<
storage
read_write
>
scratchpad
:
IndexMemory
;
group
(
0
)
binding
(
5
)
var
<
storage
read_write
>
scratch_locations
:
IndexMemory
;
group
(
0
)
binding
(
6
)
var
<
uniform
>
stress_params
:
StressParamsMemory
;
;
const
atomicTestShaderBindings
=
[
group
(
0
)
binding
(
0
)
var
<
storage
read_write
>
test_locations
:
AtomicMemory
;
commonTestShaderBindings
]
.
join
(
'
\
n
'
)
;
const
nonAtomicTestShaderBindings
=
[
group
(
0
)
binding
(
0
)
var
<
storage
read_write
>
test_locations
:
Memory
;
commonTestShaderBindings
]
.
join
(
'
\
n
'
)
;
const
resultShaderBindings
=
group
(
0
)
binding
(
0
)
var
<
storage
read_write
>
test_locations
:
Memory
;
group
(
0
)
binding
(
1
)
var
<
storage
read_write
>
read_results
:
ReadResults
;
group
(
0
)
binding
(
2
)
var
<
storage
read_write
>
test_results
:
TestResults
;
group
(
0
)
binding
(
3
)
var
<
uniform
>
stress_params
:
StressParamsMemory
;
;
const
atomicWorkgroupMemory
=
var
<
workgroup
>
wg_test_locations
:
array
<
atomic
<
u32
>
3584
>
;
;
const
nonAtomicWorkgroupMemory
=
var
<
workgroup
>
wg_test_locations
:
array
<
AccessValueTy
3584
>
;
;
const
memoryLocationFunctions
=
fn
permute_id
(
id
:
u32
factor
:
u32
mask
:
u32
)
-
>
u32
{
return
(
id
*
factor
)
%
mask
;
}
fn
stripe_workgroup
(
workgroup_id
:
u32
local_id
:
u32
)
-
>
u32
{
return
(
workgroup_id
+
1u
+
local_id
%
(
stress_params
.
testing_workgroups
-
1u
)
)
%
stress_params
.
testing_workgroups
;
}
;
const
testShaderFunctions
=
/
/
Force
the
invocations
in
the
workgroup
to
wait
for
each
other
but
without
the
general
memory
ordering
/
/
effects
of
a
control
barrier
.
The
barrier
spins
until
either
all
invocations
have
incremented
the
atomic
/
/
variable
or
1024
loops
have
occurred
.
1024
was
chosen
because
it
gives
more
time
for
invocations
to
enter
/
/
the
barrier
but
does
not
overly
reduce
testing
throughput
.
fn
spin
(
limit
:
u32
)
{
var
i
:
u32
=
0u
;
var
bar_val
:
u32
=
atomicAdd
(
&
barrier
.
value
[
0
]
1u
)
;
loop
{
if
(
i
=
=
1024u
|
|
bar_val
>
=
limit
)
{
break
;
}
bar_val
=
atomicAdd
(
&
barrier
.
value
[
0
]
0u
)
;
i
=
i
+
1u
;
}
}
/
/
Perform
iterations
of
stress
depending
on
the
specified
pattern
.
Pattern
0
is
store
-
store
pattern
1
is
store
-
load
/
/
pattern
2
is
load
-
store
and
pattern
3
is
load
-
load
.
The
extra
if
condition
(
if
tmpX
>
100000u
)
is
used
to
avoid
/
/
the
compiler
optimizing
out
unused
loads
where
100
000
is
larger
than
the
maximum
number
of
stress
iterations
used
/
/
in
any
test
.
fn
do_stress
(
iterations
:
u32
pattern
:
u32
workgroup_id
:
u32
)
{
let
addr
=
scratch_locations
.
value
[
workgroup_id
]
;
switch
(
pattern
)
{
case
0u
:
{
for
(
var
i
:
u32
=
0u
;
i
<
iterations
;
i
=
i
+
1u
)
{
scratchpad
.
value
[
addr
]
=
i
;
scratchpad
.
value
[
addr
]
=
i
+
1u
;
}
}
case
1u
:
{
for
(
var
i
:
u32
=
0u
;
i
<
iterations
;
i
=
i
+
1u
)
{
scratchpad
.
value
[
addr
]
=
i
;
let
tmp1
:
u32
=
scratchpad
.
value
[
addr
]
;
if
(
tmp1
>
100000u
)
{
scratchpad
.
value
[
addr
]
=
i
;
break
;
}
}
}
case
2u
:
{
for
(
var
i
:
u32
=
0u
;
i
<
iterations
;
i
=
i
+
1u
)
{
let
tmp1
:
u32
=
scratchpad
.
value
[
addr
]
;
if
(
tmp1
>
100000u
)
{
scratchpad
.
value
[
addr
]
=
i
;
break
;
}
scratchpad
.
value
[
addr
]
=
i
;
}
}
case
3u
:
{
for
(
var
i
:
u32
=
0u
;
i
<
iterations
;
i
=
i
+
1u
)
{
let
tmp1
:
u32
=
scratchpad
.
value
[
addr
]
;
if
(
tmp1
>
100000u
)
{
scratchpad
.
value
[
addr
]
=
i
;
break
;
}
let
tmp2
:
u32
=
scratchpad
.
value
[
addr
]
;
if
(
tmp2
>
100000u
)
{
scratchpad
.
value
[
addr
]
=
i
;
break
;
}
}
}
default
:
{
}
}
}
;
const
shaderEntryPoint
=
/
/
Change
to
pipeline
overridable
constant
when
possible
.
const
workgroupXSize
=
256u
;
compute
workgroup_size
(
workgroupXSize
)
fn
main
(
builtin
(
local_invocation_id
)
local_invocation_id
:
vec3
<
u32
>
builtin
(
workgroup_id
)
workgroup_id
:
vec3
<
u32
>
)
{
;
const
testShaderCommonHeader
=
let
shuffled_workgroup
=
shuffled_workgroups
.
value
[
workgroup_id
[
0
]
]
;
if
(
shuffled_workgroup
<
stress_params
.
testing_workgroups
)
{
;
const
testShaderCommonCalculations
=
let
x_0
=
id_0
*
stress_params
.
mem_stride
*
2u
;
let
y_0
=
permute_id
(
id_0
stress_params
.
permute_second
total_ids
)
*
stress_params
.
mem_stride
*
2u
+
stress_params
.
location_offset
;
let
x_1
=
id_1
*
stress_params
.
mem_stride
*
2u
;
let
y_1
=
permute_id
(
id_1
stress_params
.
permute_second
total_ids
)
*
stress_params
.
mem_stride
*
2u
+
stress_params
.
location_offset
;
if
(
stress_params
.
pre_stress
=
=
1u
)
{
do_stress
(
stress_params
.
pre_stress_iterations
stress_params
.
pre_stress_pattern
shuffled_workgroup
)
;
}
;
const
interWorkgroupTestShaderCode
=
[
let
total_ids
=
workgroupXSize
*
stress_params
.
testing_workgroups
;
let
id_0
=
shuffled_workgroup
*
workgroupXSize
+
local_invocation_id
[
0
]
;
let
new_workgroup
=
stripe_workgroup
(
shuffled_workgroup
local_invocation_id
[
0
]
)
;
let
id_1
=
new_workgroup
*
workgroupXSize
+
permute_id
(
local_invocation_id
[
0
]
stress_params
.
permute_first
workgroupXSize
)
;
testShaderCommonCalculations
if
(
stress_params
.
do_barrier
=
=
1u
)
{
spin
(
workgroupXSize
*
stress_params
.
testing_workgroups
)
;
}
]
.
join
(
'
\
n
'
)
;
const
intraWorkgroupTestShaderCode
=
[
let
total_ids
=
workgroupXSize
;
let
id_0
=
local_invocation_id
[
0
]
;
let
id_1
=
permute_id
(
local_invocation_id
[
0
]
stress_params
.
permute_first
workgroupXSize
)
;
testShaderCommonCalculations
if
(
stress_params
.
do_barrier
=
=
1u
)
{
spin
(
workgroupXSize
)
;
}
]
.
join
(
'
\
n
'
)
;
const
storageIntraWorkgroupTestShaderCode
=
let
total_ids
=
workgroupXSize
;
let
id_0
=
local_invocation_id
[
0
]
;
let
id_1
=
permute_id
(
local_invocation_id
[
0
]
stress_params
.
permute_first
workgroupXSize
)
;
let
x_0
=
(
shuffled_workgroup
*
workgroupXSize
+
id_0
)
*
stress_params
.
mem_stride
*
2u
;
let
y_0
=
(
shuffled_workgroup
*
workgroupXSize
+
permute_id
(
id_0
stress_params
.
permute_second
total_ids
)
)
*
stress_params
.
mem_stride
*
2u
+
stress_params
.
location_offset
;
let
x_1
=
(
shuffled_workgroup
*
workgroupXSize
+
id_1
)
*
stress_params
.
mem_stride
*
2u
;
let
y_1
=
(
shuffled_workgroup
*
workgroupXSize
+
permute_id
(
id_1
stress_params
.
permute_second
total_ids
)
)
*
stress_params
.
mem_stride
*
2u
+
stress_params
.
location_offset
;
if
(
stress_params
.
pre_stress
=
=
1u
)
{
do_stress
(
stress_params
.
pre_stress_iterations
stress_params
.
pre_stress_pattern
shuffled_workgroup
)
;
}
if
(
stress_params
.
do_barrier
=
=
1u
)
{
spin
(
workgroupXSize
)
;
}
;
const
testShaderCommonFooter
=
}
else
if
(
stress_params
.
mem_stress
=
=
1u
)
{
do_stress
(
stress_params
.
mem_stress_iterations
stress_params
.
mem_stress_pattern
shuffled_workgroup
)
;
}
}
;
const
resultShaderCommonCalculations
=
let
id_0
=
workgroup_id
[
0
]
*
workgroupXSize
+
local_invocation_id
[
0
]
;
let
x_0
=
id_0
*
stress_params
.
mem_stride
*
2u
;
let
mem_x_0
=
u32
(
test_locations
.
value
[
x_0
]
)
;
let
r0
=
atomicLoad
(
&
read_results
.
value
[
id_0
]
.
r0
)
;
let
r1
=
atomicLoad
(
&
read_results
.
value
[
id_0
]
.
r1
)
;
;
const
interWorkgroupResultShaderCode
=
[
resultShaderCommonCalculations
let
total_ids
=
workgroupXSize
*
stress_params
.
testing_workgroups
;
let
y_0
=
permute_id
(
id_0
stress_params
.
permute_second
total_ids
)
*
stress_params
.
mem_stride
*
2u
+
stress_params
.
location_offset
;
let
mem_y_0
=
u32
(
test_locations
.
value
[
y_0
]
)
;
]
.
join
(
'
\
n
'
)
;
const
intraWorkgroupResultShaderCode
=
[
resultShaderCommonCalculations
let
total_ids
=
workgroupXSize
;
let
y_0
=
(
workgroup_id
[
0
]
*
workgroupXSize
+
permute_id
(
local_invocation_id
[
0
]
stress_params
.
permute_second
total_ids
)
)
*
stress_params
.
mem_stride
*
2u
+
stress_params
.
location_offset
;
let
mem_y_0
=
u32
(
test_locations
.
value
[
y_0
]
)
;
]
.
join
(
'
\
n
'
)
;
const
resultShaderCommonFooter
=
}
;
const
storageMemoryAtomicTestShaderCode
=
[
shaderMemStructures
atomicTestShaderBindings
memoryLocationFunctions
testShaderFunctions
shaderEntryPoint
testShaderCommonHeader
]
.
join
(
'
\
n
'
)
;
const
storageMemoryNonAtomicTestShaderCode
=
[
shaderMemStructures
nonAtomicTestShaderBindings
memoryLocationFunctions
testShaderFunctions
shaderEntryPoint
testShaderCommonHeader
]
.
join
(
'
\
n
'
)
;
const
workgroupMemoryAtomicTestShaderCode
=
[
shaderMemStructures
atomicTestShaderBindings
atomicWorkgroupMemory
memoryLocationFunctions
testShaderFunctions
shaderEntryPoint
testShaderCommonHeader
]
.
join
(
'
\
n
'
)
;
const
workgroupMemoryNonAtomicTestShaderCode
=
[
shaderMemStructures
nonAtomicTestShaderBindings
nonAtomicWorkgroupMemory
memoryLocationFunctions
testShaderFunctions
shaderEntryPoint
testShaderCommonHeader
]
.
join
(
'
\
n
'
)
;
const
resultShaderCommonCode
=
[
shaderMemStructures
resultShaderBindings
memoryLocationFunctions
shaderEntryPoint
]
.
join
(
'
\
n
'
)
;
export
enum
MemoryType
{
AtomicStorageClass
=
'
atomic_storage
'
NonAtomicStorageClass
=
'
non_atomic_storage
'
AtomicWorkgroupClass
=
'
atomic_workgroup
'
NonAtomicWorkgroupClass
=
'
non_atomic_workgroup
'
}
export
enum
TestType
{
InterWorkgroup
=
'
inter_workgroup
'
IntraWorkgroup
=
'
intra_workgroup
'
}
export
enum
ResultType
{
TwoBehavior
FourBehavior
}
export
function
buildTestShader
(
testCode
:
string
memoryType
:
MemoryType
testType
:
TestType
)
:
string
{
let
memoryTypeCode
;
let
isStorageAS
=
false
;
switch
(
memoryType
)
{
case
MemoryType
.
AtomicStorageClass
:
memoryTypeCode
=
storageMemoryAtomicTestShaderCode
;
isStorageAS
=
true
;
break
;
case
MemoryType
.
NonAtomicStorageClass
:
memoryTypeCode
=
storageMemoryNonAtomicTestShaderCode
;
isStorageAS
=
true
;
break
;
case
MemoryType
.
AtomicWorkgroupClass
:
memoryTypeCode
=
workgroupMemoryAtomicTestShaderCode
;
break
;
case
MemoryType
.
NonAtomicWorkgroupClass
:
memoryTypeCode
=
workgroupMemoryNonAtomicTestShaderCode
;
}
let
testTypeCode
;
switch
(
testType
)
{
case
TestType
.
InterWorkgroup
:
testTypeCode
=
interWorkgroupTestShaderCode
;
break
;
case
TestType
.
IntraWorkgroup
:
if
(
isStorageAS
)
{
testTypeCode
=
storageIntraWorkgroupTestShaderCode
;
}
else
{
testTypeCode
=
intraWorkgroupTestShaderCode
;
}
}
return
[
memoryTypeCode
testTypeCode
testCode
testShaderCommonFooter
]
.
join
(
'
\
n
'
)
;
}
export
function
buildResultShader
(
resultCode
:
string
testType
:
TestType
resultType
:
ResultType
)
:
string
{
let
resultStructure
;
switch
(
resultType
)
{
case
ResultType
.
TwoBehavior
:
resultStructure
=
twoBehaviorTestResultStructure
;
break
;
case
ResultType
.
FourBehavior
:
resultStructure
=
fourBehaviorTestResultStructure
;
}
let
testTypeCode
;
switch
(
testType
)
{
case
TestType
.
InterWorkgroup
:
testTypeCode
=
interWorkgroupResultShaderCode
;
break
;
case
TestType
.
IntraWorkgroup
:
testTypeCode
=
intraWorkgroupResultShaderCode
;
}
return
[
resultStructure
resultShaderCommonCode
testTypeCode
resultCode
resultShaderCommonFooter
]
.
join
(
'
\
n
'
)
;
}
