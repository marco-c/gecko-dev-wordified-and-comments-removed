import
{
FP
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
util
/
floating_point
.
js
'
;
import
{
selectNCases
}
from
'
.
.
/
.
.
/
case
.
js
'
;
import
{
makeCaseCache
}
from
'
.
.
/
.
.
/
case_cache
.
js
'
;
const
scalar_cases
=
(
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
flatMap
(
trait
=
>
(
[
true
false
]
as
const
)
.
map
(
nonConst
=
>
(
{
[
{
trait
}
_
{
nonConst
?
'
non_const
'
:
'
const
'
}
]
:
(
)
=
>
{
if
(
trait
=
=
=
'
abstract
'
&
&
nonConst
)
{
return
[
]
;
}
const
cases
=
FP
[
trait
]
.
generateScalarTripleToIntervalCases
(
FP
[
trait
]
.
sparseScalarRange
(
)
FP
[
trait
]
.
sparseScalarRange
(
)
FP
[
trait
]
.
sparseScalarRange
(
)
nonConst
?
'
unfiltered
'
:
'
finite
'
.
.
.
FP
[
trait
!
=
=
'
abstract
'
?
trait
:
'
f32
'
]
.
mixIntervals
)
;
return
selectNCases
(
'
mix_scalar
'
trait
=
=
=
'
abstract
'
?
50
:
cases
.
length
cases
)
;
}
}
)
)
)
.
reduce
(
(
a
b
)
=
>
(
{
.
.
.
a
.
.
.
b
}
)
{
}
)
;
const
vec_scalar_cases
=
(
[
'
f32
'
'
f16
'
'
abstract
'
]
as
const
)
.
flatMap
(
trait
=
>
(
[
2
3
4
]
as
const
)
.
flatMap
(
dim
=
>
(
[
true
false
]
as
const
)
.
map
(
nonConst
=
>
(
{
[
{
trait
}
_vec
{
dim
}
_scalar_
{
nonConst
?
'
non_const
'
:
'
const
'
}
]
:
(
)
=
>
{
if
(
trait
=
=
=
'
abstract
'
&
&
nonConst
)
{
return
[
]
;
}
const
cases
=
FP
[
trait
]
.
generateVectorPairScalarToVectorComponentWiseCase
(
FP
[
trait
]
.
sparseVectorRange
(
dim
)
FP
[
trait
]
.
sparseVectorRange
(
dim
)
FP
[
trait
]
.
sparseScalarRange
(
)
nonConst
?
'
unfiltered
'
:
'
finite
'
.
.
.
FP
[
trait
!
=
=
'
abstract
'
?
trait
:
'
f32
'
]
.
mixIntervals
)
;
return
selectNCases
(
'
mix_vector
'
trait
=
=
=
'
abstract
'
?
50
:
cases
.
length
cases
)
;
}
}
)
)
)
)
.
reduce
(
(
a
b
)
=
>
(
{
.
.
.
a
.
.
.
b
}
)
{
}
)
;
export
const
d
=
makeCaseCache
(
'
mix
'
{
.
.
.
scalar_cases
.
.
.
vec_scalar_cases
}
)
;
