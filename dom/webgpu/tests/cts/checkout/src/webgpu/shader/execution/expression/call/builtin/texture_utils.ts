import
{
keysOf
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
data_tables
.
js
'
;
import
{
assert
range
unreachable
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
Float16Array
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
external
/
petamoriken
/
float16
/
float16
.
js
'
;
import
{
ColorTextureFormat
EncodableTextureFormat
getBlockInfoForColorTextureFormat
getBlockInfoForTextureFormat
getTextureFormatType
is32Float
isColorTextureFormat
isCompressedFloatTextureFormat
isCompressedTextureFormat
isDepthOrStencilTextureFormat
isDepthTextureFormat
isEncodableTextureFormat
isSintOrUintFormat
isStencilTextureFormat
kEncodableTextureFormats
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
format_info
.
js
'
;
import
{
AllFeaturesMaxLimitsGPUTest
GPUTest
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
gpu_test
.
js
'
;
import
{
align
clamp
dotProduct
hashU32
lcm
lerp
quantizeToF32
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
util
/
math
.
js
'
;
import
{
effectiveViewDimensionForDimension
physicalMipSize
physicalMipSizeFromTexture
reifyTextureDescriptor
SampleCoord
virtualMipSize
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
util
/
texture
/
base
.
js
'
;
import
{
kTexelRepresentationInfo
NumericRange
PerComponentNumericRange
PerTexelComponent
TexelComponent
TexelRepresentationInfo
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
util
/
texture
/
texel_data
.
js
'
;
import
{
PerPixelAtLevel
TexelView
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
util
/
texture
/
texel_view
.
js
'
;
import
{
createTextureFromTexelViews
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
util
/
texture
.
js
'
;
import
{
reifyExtent3D
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
util
/
unions
.
js
'
;
import
{
ShaderStage
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
validation
/
decl
/
util
.
js
'
;
export
const
kShortShaderStageToShaderStage
=
{
c
:
'
compute
'
as
ShaderStage
f
:
'
fragment
'
as
ShaderStage
v
:
'
vertex
'
as
ShaderStage
}
as
const
;
export
const
kShortShaderStages
=
keysOf
(
kShortShaderStageToShaderStage
)
;
export
type
ShortShaderStage
=
(
typeof
kShortShaderStages
)
[
number
]
;
export
const
kShortAddressModeToAddressMode
:
Record
<
string
GPUAddressMode
>
=
{
c
:
'
clamp
-
to
-
edge
'
r
:
'
repeat
'
m
:
'
mirror
-
repeat
'
}
;
export
const
kShortAddressModes
=
keysOf
(
kShortAddressModeToAddressMode
)
;
export
const
kSampleTypeInfo
=
{
f32
:
{
format
:
'
rgba8unorm
'
}
i32
:
{
format
:
'
rgba8sint
'
}
u32
:
{
format
:
'
rgba8uint
'
}
}
as
const
;
export
function
isSupportedViewFormatCombo
(
format
:
GPUTextureFormat
viewDimension
:
GPUTextureViewDimension
)
{
return
!
(
(
isCompressedTextureFormat
(
format
)
|
|
isDepthOrStencilTextureFormat
(
format
)
)
&
&
(
viewDimension
=
=
=
'
3d
'
|
|
viewDimension
=
=
=
'
1d
'
)
)
;
}
export
function
getTextureTypeForTextureViewDimension
(
viewDimension
:
GPUTextureViewDimension
)
{
switch
(
viewDimension
)
{
case
'
1d
'
:
return
'
texture_1d
<
f32
>
'
;
case
'
2d
'
:
return
'
texture_2d
<
f32
>
'
;
case
'
2d
-
array
'
:
return
'
texture_2d_array
<
f32
>
'
;
case
'
3d
'
:
return
'
texture_3d
<
f32
>
'
;
case
'
cube
'
:
return
'
texture_cube
<
f32
>
'
;
case
'
cube
-
array
'
:
return
'
texture_cube_array
<
f32
>
'
;
default
:
unreachable
(
)
;
}
}
const
isUnencodableDepthFormat
=
(
format
:
GPUTextureFormat
)
=
>
format
=
=
=
'
depth24plus
'
|
|
format
=
=
=
'
depth24plus
-
stencil8
'
|
|
format
=
=
=
'
depth32float
-
stencil8
'
;
export
function
skipIfTextureFormatNotSupportedOrNeedsFilteringAndIsUnfilterable
(
t
:
GPUTest
filter
:
GPUFilterMode
format
:
GPUTextureFormat
)
{
t
.
skipIfTextureFormatNotSupported
(
format
)
;
if
(
filter
=
=
=
'
linear
'
)
{
t
.
skipIf
(
isDepthTextureFormat
(
format
)
'
depth
texture
are
unfilterable
'
)
;
const
type
=
getTextureFormatType
(
format
)
;
if
(
type
=
=
=
'
unfilterable
-
float
'
)
{
assert
(
is32Float
(
format
)
)
;
t
.
skipIfDeviceDoesNotHaveFeature
(
'
float32
-
filterable
'
)
;
}
}
}
export
function
isFillable
(
format
:
GPUTextureFormat
)
{
return
!
isCompressedTextureFormat
(
format
)
|
|
!
format
.
endsWith
(
'
float
'
)
;
}
export
function
isPotentiallyFilterableAndFillable
(
format
:
GPUTextureFormat
)
{
const
type
=
getTextureFormatType
(
format
)
;
const
canPotentiallyFilter
=
type
=
=
=
'
float
'
|
|
type
=
=
=
'
unfilterable
-
float
'
|
|
type
=
=
=
'
depth
'
;
const
result
=
canPotentiallyFilter
&
&
isFillable
(
format
)
;
return
result
;
}
const
builtinNeedsMipLevelWeights
=
(
builtin
:
TextureBuiltin
)
=
>
builtin
!
=
=
'
textureLoad
'
&
&
builtin
!
=
=
'
textureGather
'
&
&
builtin
!
=
=
'
textureGatherCompare
'
&
&
builtin
!
=
=
'
textureSampleBaseClampToEdge
'
;
function
unzip
<
T
>
(
array
:
T
[
]
num
:
number
srcStride
?
:
number
)
{
srcStride
=
srcStride
=
=
=
undefined
?
num
:
srcStride
;
const
arrays
:
T
[
]
[
]
=
range
(
num
(
)
=
>
[
]
)
;
const
numEntries
=
Math
.
ceil
(
array
.
length
/
srcStride
)
;
for
(
let
i
=
0
;
i
<
numEntries
;
+
+
i
)
{
for
(
let
j
=
0
;
j
<
num
;
+
+
j
)
{
arrays
[
j
]
.
push
(
array
[
i
*
srcStride
+
j
]
)
;
}
}
return
arrays
;
}
type
MipWeights
=
{
sampleLevelWeights
?
:
number
[
]
;
softwareMixToGPUMixGradWeights
?
:
number
[
]
;
}
;
type
MipWeightType
=
keyof
MipWeights
;
function
makeGraph
(
width
:
number
height
:
number
)
{
const
data
=
new
Uint8Array
(
width
*
height
)
;
return
{
plot
(
norm
:
number
x
:
number
c
:
number
)
{
const
y
=
clamp
(
Math
.
floor
(
norm
*
height
)
{
min
:
0
max
:
height
-
1
}
)
;
const
offset
=
(
height
-
y
-
1
)
*
width
+
x
;
data
[
offset
]
=
c
;
}
plotValues
(
values
:
Iterable
<
number
>
c
:
number
)
{
let
i
=
0
;
for
(
const
v
of
values
)
{
this
.
plot
(
v
i
c
)
;
+
+
i
;
}
}
toString
(
conversion
=
[
'
.
'
'
e
'
'
A
'
]
)
{
const
lines
=
[
]
;
for
(
let
y
=
0
;
y
<
height
;
+
+
y
)
{
const
offset
=
y
*
width
;
lines
.
push
(
[
.
.
.
data
.
subarray
(
offset
offset
+
width
)
]
.
map
(
v
=
>
conversion
[
v
]
)
.
join
(
'
'
)
)
;
}
return
lines
.
join
(
'
\
n
'
)
;
}
}
;
}
function
*
linear0to1OverN
(
n
:
number
)
{
for
(
let
i
=
0
;
i
<
=
n
;
+
+
i
)
{
yield
i
/
n
;
}
}
export
function
graphWeights
(
height
:
number
weights
:
number
[
]
)
{
const
graph
=
makeGraph
(
weights
.
length
height
)
;
graph
.
plotValues
(
linear0to1OverN
(
weights
.
length
-
1
)
1
)
;
graph
.
plotValues
(
weights
2
)
;
return
graph
.
toString
(
)
;
}
function
validateWeights
(
t
:
GPUTest
stage
:
string
weights
:
number
[
]
)
{
const
showWeights
=
t
.
rec
.
debugging
?
(
)
=
>
{
weights
.
map
(
(
v
i
)
=
>
{
i
.
toString
(
)
.
padStart
(
2
)
}
:
{
v
}
)
.
join
(
'
\
n
'
)
}
e
=
expected
A
=
actual
{
graphWeights
(
32
weights
)
}
:
(
)
=
>
;
assert
(
weights
[
0
]
=
=
=
0
stage
:
{
stage
}
weight
0
expected
0
but
was
{
weights
[
0
]
}
\
n
{
showWeights
(
)
}
)
;
assert
(
weights
[
kMipLevelWeightSteps
]
=
=
=
1
stage
:
{
stage
}
top
weight
expected
1
but
was
{
weights
[
kMipLevelWeightSteps
]
}
\
n
{
showWeights
(
)
}
)
;
const
kMinPercentUniqueWeights
=
25
;
assert
(
new
Set
(
weights
)
.
size
>
=
(
(
weights
.
length
*
kMinPercentUniqueWeights
*
0
.
01
)
|
0
)
stage
:
{
stage
}
expected
at
least
~
{
kMinPercentUniqueWeights
}
%
unique
weights
\
n
{
showWeights
(
)
}
)
;
}
export
async
function
queryMipLevelMixWeightsForDevice
(
t
:
GPUTest
stage
:
ShaderStage
)
{
const
{
device
}
=
t
;
const
kNumWeightTypes
=
2
;
assert
(
kNumWeightTypes
<
=
4
)
;
const
module
=
device
.
createShaderModule
(
{
code
:
group
(
0
)
binding
(
0
)
var
tex
:
texture_2d
<
f32
>
;
group
(
0
)
binding
(
1
)
var
smp
:
sampler
;
group
(
0
)
binding
(
2
)
var
<
storage
read_write
>
result
:
array
<
vec4f
>
;
struct
VSOutput
{
builtin
(
position
)
pos
:
vec4f
location
(
0
)
interpolate
(
flat
either
)
ndx
:
u32
location
(
1
)
interpolate
(
flat
either
)
result
:
vec4f
}
;
fn
getMixLevels
(
wNdx
:
u32
)
-
>
vec4f
{
let
mipLevel
=
f32
(
wNdx
)
/
{
kMipLevelWeightSteps
}
;
let
size
=
textureDimensions
(
tex
)
;
let
g
=
mix
(
1
.
0
2
.
0
mipLevel
)
/
f32
(
size
.
x
)
;
let
ddx
=
vec2f
(
g
0
)
;
return
vec4f
(
textureSampleLevel
(
tex
smp
vec2f
(
0
.
5
)
mipLevel
)
.
r
textureSampleGrad
(
tex
smp
vec2f
(
0
.
5
)
ddx
vec2f
(
0
)
)
.
r
0
0
)
;
}
fn
getPosition
(
vNdx
:
u32
)
-
>
vec4f
{
let
pos
=
array
(
vec2f
(
-
1
3
)
vec2f
(
3
-
1
)
vec2f
(
-
1
-
1
)
)
;
let
p
=
pos
[
vNdx
]
;
return
vec4f
(
p
0
1
)
;
}
/
/
-
-
for
getting
fragment
stage
weights
-
-
vertex
fn
vs
(
builtin
(
vertex_index
)
vNdx
:
u32
builtin
(
instance_index
)
iNdx
:
u32
)
-
>
VSOutput
{
return
VSOutput
(
getPosition
(
vNdx
)
iNdx
vec4f
(
0
)
)
;
}
fragment
fn
fsRecord
(
v
:
VSOutput
)
-
>
location
(
0
)
vec4u
{
return
bitcast
<
vec4u
>
(
getMixLevels
(
v
.
ndx
)
)
;
}
/
/
-
-
for
getting
compute
stage
weights
-
-
compute
workgroup_size
(
1
)
fn
csRecord
(
builtin
(
global_invocation_id
)
id
:
vec3u
)
{
result
[
id
.
x
]
=
getMixLevels
(
id
.
x
)
;
}
/
/
-
-
for
getting
vertex
stage
weights
-
-
vertex
fn
vsRecord
(
builtin
(
vertex_index
)
vNdx
:
u32
builtin
(
instance_index
)
iNdx
:
u32
)
-
>
VSOutput
{
return
VSOutput
(
getPosition
(
vNdx
)
iNdx
getMixLevels
(
iNdx
)
)
;
}
fragment
fn
fsSaveVs
(
v
:
VSOutput
)
-
>
location
(
0
)
vec4u
{
return
bitcast
<
vec4u
>
(
v
.
result
)
;
}
}
)
;
const
texture
=
t
.
createTextureTracked
(
{
size
:
[
2
2
1
]
format
:
'
r8unorm
'
usage
:
GPUTextureUsage
.
TEXTURE_BINDING
|
GPUTextureUsage
.
COPY_DST
mipLevelCount
:
2
}
)
;
device
.
queue
.
writeTexture
(
{
texture
mipLevel
:
1
}
new
Uint8Array
(
[
255
]
)
{
bytesPerRow
:
1
}
[
1
1
]
)
;
const
sampler
=
device
.
createSampler
(
{
minFilter
:
'
linear
'
magFilter
:
'
linear
'
mipmapFilter
:
'
linear
'
}
)
;
const
target
=
t
.
createTextureTracked
(
{
size
:
[
kMipLevelWeightSteps
+
1
1
]
format
:
'
rgba32uint
'
usage
:
GPUTextureUsage
.
RENDER_ATTACHMENT
|
GPUTextureUsage
.
COPY_SRC
}
)
;
const
storageBuffer
=
t
.
createBufferTracked
(
{
size
:
4
*
4
*
(
kMipLevelWeightSteps
+
1
)
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_SRC
}
)
;
const
resultBuffer
=
t
.
createBufferTracked
(
{
size
:
align
(
storageBuffer
.
size
256
)
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
MAP_READ
}
)
;
const
createBindGroup
=
(
pipeline
:
GPUComputePipeline
|
GPURenderPipeline
)
=
>
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
texture
.
createView
(
)
}
{
binding
:
1
resource
:
sampler
}
.
.
.
(
stage
=
=
=
'
compute
'
?
[
{
binding
:
2
resource
:
{
buffer
:
storageBuffer
}
}
]
:
[
]
)
]
}
)
;
const
encoder
=
device
.
createCommandEncoder
(
)
;
switch
(
stage
)
{
case
'
compute
'
:
{
const
pipeline
=
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
}
}
)
;
const
pass
=
encoder
.
beginComputePass
(
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
createBindGroup
(
pipeline
)
)
;
pass
.
dispatchWorkgroups
(
kMipLevelWeightSteps
+
1
)
;
pass
.
end
(
)
;
encoder
.
copyBufferToBuffer
(
storageBuffer
0
resultBuffer
0
storageBuffer
.
size
)
;
break
;
}
case
'
fragment
'
:
{
const
pipeline
=
device
.
createRenderPipeline
(
{
layout
:
'
auto
'
vertex
:
{
module
entryPoint
:
'
vs
'
}
fragment
:
{
module
entryPoint
:
'
fsRecord
'
targets
:
[
{
format
:
'
rgba32uint
'
}
]
}
}
)
;
const
pass
=
encoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
target
.
createView
(
)
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
]
}
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
createBindGroup
(
pipeline
)
)
;
for
(
let
x
=
0
;
x
<
=
kMipLevelWeightSteps
;
+
+
x
)
{
pass
.
setViewport
(
x
0
1
1
0
1
)
;
pass
.
draw
(
3
1
0
x
)
;
}
pass
.
end
(
)
;
encoder
.
copyTextureToBuffer
(
{
texture
:
target
}
{
buffer
:
resultBuffer
}
[
target
.
width
]
)
;
break
;
}
case
'
vertex
'
:
{
const
pipeline
=
device
.
createRenderPipeline
(
{
layout
:
'
auto
'
vertex
:
{
module
entryPoint
:
'
vsRecord
'
}
fragment
:
{
module
entryPoint
:
'
fsSaveVs
'
targets
:
[
{
format
:
'
rgba32uint
'
}
]
}
}
)
;
const
pass
=
encoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
target
.
createView
(
)
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
]
}
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
createBindGroup
(
pipeline
)
)
;
for
(
let
x
=
0
;
x
<
=
kMipLevelWeightSteps
;
+
+
x
)
{
pass
.
setViewport
(
x
0
1
1
0
1
)
;
pass
.
draw
(
3
1
0
x
)
;
}
pass
.
end
(
)
;
encoder
.
copyTextureToBuffer
(
{
texture
:
target
}
{
buffer
:
resultBuffer
}
[
target
.
width
]
)
;
break
;
}
}
device
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
await
resultBuffer
.
mapAsync
(
GPUMapMode
.
READ
)
;
const
result
=
Array
.
from
(
new
Float32Array
(
resultBuffer
.
getMappedRange
(
0
(
kMipLevelWeightSteps
+
1
)
*
16
)
)
)
;
resultBuffer
.
unmap
(
)
;
resultBuffer
.
destroy
(
)
;
const
[
sampleLevelWeights
gradWeights
]
=
unzip
(
result
kNumWeightTypes
4
)
;
validateWeights
(
t
stage
sampleLevelWeights
)
;
validateWeights
(
t
stage
gradWeights
)
;
texture
.
destroy
(
)
;
storageBuffer
.
destroy
(
)
;
return
{
sampleLevelWeights
softwareMixToGPUMixGradWeights
:
generateSoftwareMixToGPUMixGradWeights
(
gradWeights
texture
)
}
;
}
function
getIndexAndWeight
(
values
:
readonly
number
[
]
v
:
number
)
{
assert
(
v
>
=
values
[
0
]
&
&
v
<
=
values
[
values
.
length
-
1
]
)
;
let
lo
=
0
;
let
hi
=
values
.
length
-
1
;
for
(
;
;
)
{
const
i
=
(
lo
+
(
hi
-
lo
)
/
2
)
|
0
;
const
w0
=
values
[
i
]
;
const
w1
=
values
[
i
+
1
]
;
if
(
lo
=
=
=
hi
|
|
(
v
>
=
w0
&
&
v
<
=
w1
)
)
{
const
weight
=
(
v
-
w0
)
/
(
w1
-
w0
)
;
return
[
i
weight
]
;
}
if
(
v
<
w0
)
{
hi
=
i
;
}
else
{
lo
=
i
+
1
;
}
}
}
function
bilinearFilter
(
values
:
readonly
number
[
]
ndx
:
number
weight
:
number
)
{
const
v0
=
values
[
ndx
]
;
const
v1
=
values
[
ndx
+
1
]
?
?
0
;
assert
(
ndx
<
values
.
length
-
1
|
|
(
ndx
=
=
=
values
.
length
-
1
&
&
weight
=
=
=
0
)
)
;
return
lerp
(
v0
v1
weight
)
;
}
function
generateSoftwareMixToGPUMixGradWeights
(
gpuWeights
:
number
[
]
texture
:
GPUTexture
)
{
const
numSteps
=
gpuWeights
.
length
-
1
;
const
size
=
[
texture
.
width
texture
.
height
texture
.
depthOrArrayLayers
]
;
const
softwareWeights
=
range
(
numSteps
+
1
i
=
>
{
const
u
=
i
/
numSteps
;
const
g
=
lerp
(
1
2
u
)
/
texture
.
width
;
const
mipLevel
=
computeMipLevelFromGradients
(
[
g
]
[
0
]
size
)
;
assert
(
mipLevel
>
=
0
&
&
mipLevel
<
=
1
)
;
return
mipLevel
;
}
)
;
const
softwareMixToGPUMixMap
=
range
(
numSteps
+
1
i
=
>
{
const
mix
=
i
/
numSteps
;
const
[
ndx
weight
]
=
getIndexAndWeight
(
softwareWeights
mix
)
;
return
bilinearFilter
(
gpuWeights
ndx
weight
)
;
}
)
;
return
softwareMixToGPUMixMap
;
}
function
mapSoftwareMipLevelToGPUMipLevel
(
t
:
GPUTest
stage
:
ShaderStage
mipLevel
:
number
)
{
const
baseLevel
=
Math
.
floor
(
mipLevel
)
;
const
softwareMix
=
mipLevel
-
baseLevel
;
const
gpuMix
=
getMixWeightByTypeForMipLevel
(
t
stage
'
softwareMixToGPUMixGradWeights
'
softwareMix
)
;
return
baseLevel
+
gpuMix
;
}
const
euclideanModulo
=
(
n
:
number
m
:
number
)
=
>
(
(
n
%
m
)
+
m
)
%
m
;
const
kMipLevelWeightSteps
=
64
;
const
s_deviceToMipLevelWeightsPromise
=
new
WeakMap
<
GPUDevice
Record
<
ShaderStage
Promise
<
MipWeights
>
>
>
(
)
;
const
s_deviceToMipLevelWeights
=
new
WeakMap
<
GPUDevice
Record
<
ShaderStage
MipWeights
>
>
(
)
;
async
function
initMipLevelWeightsForDevice
(
t
:
GPUTest
stage
:
ShaderStage
)
{
const
{
device
}
=
t
;
const
stageWeightsP
=
s_deviceToMipLevelWeightsPromise
.
get
(
device
)
?
?
(
{
}
as
Record
<
ShaderStage
Promise
<
MipWeights
>
>
)
;
s_deviceToMipLevelWeightsPromise
.
set
(
device
stageWeightsP
)
;
let
weightsP
=
stageWeightsP
[
stage
]
;
if
(
!
weightsP
)
{
weightsP
=
queryMipLevelMixWeightsForDevice
(
t
stage
)
;
weightsP
.
then
(
weights
=
>
{
const
stageWeights
=
s_deviceToMipLevelWeights
.
get
(
device
)
?
?
(
{
}
as
Record
<
ShaderStage
MipWeights
>
)
;
s_deviceToMipLevelWeights
.
set
(
device
stageWeights
)
;
stageWeights
[
stage
]
=
weights
;
}
)
.
catch
(
e
=
>
{
throw
e
;
}
)
;
stageWeightsP
[
stage
]
=
weightsP
;
}
return
await
weightsP
;
}
function
getMixWeightByTypeForMipLevel
(
t
:
GPUTest
stage
:
ShaderStage
weightType
:
MipWeightType
|
'
identity
'
mipLevel
:
number
)
{
if
(
weightType
=
=
=
'
identity
'
)
{
return
euclideanModulo
(
mipLevel
1
)
;
}
const
weights
=
s_deviceToMipLevelWeights
.
get
(
t
.
device
)
!
[
stage
]
[
weightType
]
;
assert
(
!
!
weights
'
you
must
use
WGSLTextureSampleTest
or
call
initializeDeviceMipWeights
before
calling
this
function
'
)
;
const
steps
=
weights
.
length
-
1
;
const
w
=
euclideanModulo
(
mipLevel
1
)
*
steps
;
const
lowerNdx
=
Math
.
floor
(
w
)
;
const
upperNdx
=
Math
.
ceil
(
w
)
;
const
mix
=
w
%
1
;
return
lerp
(
weights
[
lowerNdx
]
weights
[
upperNdx
]
mix
)
;
}
function
getWeightForMipLevel
(
t
:
GPUTest
stage
:
ShaderStage
weightType
:
MipWeightType
|
'
identity
'
mipLevelCount
:
number
mipLevel
:
number
)
{
if
(
mipLevel
<
0
|
|
mipLevel
>
=
mipLevelCount
)
{
return
1
;
}
return
getMixWeightByTypeForMipLevel
(
t
stage
weightType
mipLevel
)
;
}
export
class
WGSLTextureQueryTest
extends
AllFeaturesMaxLimitsGPUTest
{
skipIfNoStorageTexturesInStage
(
stage
:
ShaderStage
)
{
if
(
this
.
isCompatibility
)
{
this
.
skipIf
(
stage
=
=
=
'
fragment
'
&
&
!
(
this
.
device
.
limits
.
maxStorageTexturesInFragmentStage
!
>
0
)
'
device
does
not
support
storage
textures
in
fragment
shaders
'
)
;
this
.
skipIf
(
stage
=
=
=
'
vertex
'
&
&
!
(
this
.
device
.
limits
.
maxStorageTexturesInVertexStage
!
>
0
)
'
device
does
not
support
storage
textures
in
vertex
shaders
'
)
;
}
}
executeAndExpectResult
(
stage
:
ShaderStage
code
:
string
texture
:
GPUTexture
|
GPUExternalTexture
viewDescriptor
:
GPUTextureViewDescriptor
|
undefined
expected
:
number
[
]
)
{
const
{
device
}
=
this
;
const
returnType
=
vec4
<
u32
>
;
const
castWGSL
=
{
returnType
}
(
getValue
(
)
{
range
(
4
-
expected
.
length
(
)
=
>
'
0
'
)
.
join
(
'
'
)
}
)
;
const
stageWGSL
=
stage
=
=
=
'
vertex
'
?
/
/
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
vertex
stage
shaders
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
vertex
fn
vsVertex
(
builtin
(
vertex_index
)
vertex_index
:
u32
builtin
(
instance_index
)
instance_index
:
u32
)
-
>
VOut
{
let
positions
=
array
(
vec2f
(
-
1
3
)
vec2f
(
3
-
1
)
vec2f
(
-
1
-
1
)
)
;
return
VOut
(
vec4f
(
positions
[
vertex_index
]
0
1
)
instance_index
{
castWGSL
}
)
;
}
fragment
fn
fsVertex
(
v
:
VOut
)
-
>
location
(
0
)
vec4u
{
return
bitcast
<
vec4u
>
(
v
.
result
)
;
}
:
stage
=
=
=
'
fragment
'
?
/
/
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
fragment
stage
shaders
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
vertex
fn
vsFragment
(
builtin
(
vertex_index
)
vertex_index
:
u32
builtin
(
instance_index
)
instance_index
:
u32
)
-
>
VOut
{
let
positions
=
array
(
vec2f
(
-
1
3
)
vec2f
(
3
-
1
)
vec2f
(
-
1
-
1
)
)
;
return
VOut
(
vec4f
(
positions
[
vertex_index
]
0
1
)
instance_index
{
returnType
}
(
0
)
)
;
}
fragment
fn
fsFragment
(
v
:
VOut
)
-
>
location
(
0
)
vec4u
{
return
bitcast
<
vec4u
>
(
{
castWGSL
}
)
;
}
:
/
/
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
compute
stage
shaders
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
group
(
1
)
binding
(
0
)
var
<
storage
read_write
>
results
:
array
<
{
returnType
}
>
;
compute
workgroup_size
(
1
)
fn
csCompute
(
builtin
(
global_invocation_id
)
id
:
vec3u
)
{
results
[
id
.
x
]
=
{
castWGSL
}
;
}
;
const
wgsl
=
{
code
}
struct
VOut
{
builtin
(
position
)
pos
:
vec4f
location
(
0
)
interpolate
(
flat
either
)
ndx
:
u32
location
(
1
)
interpolate
(
flat
either
)
result
:
{
returnType
}
}
;
{
stageWGSL
}
;
const
module
=
device
.
createShaderModule
(
{
code
:
wgsl
}
)
;
const
visibility
=
stage
=
=
=
'
compute
'
?
GPUShaderStage
.
COMPUTE
:
stage
=
=
=
'
fragment
'
?
GPUShaderStage
.
FRAGMENT
:
GPUShaderStage
.
VERTEX
;
const
entries
:
GPUBindGroupLayoutEntry
[
]
=
[
]
;
if
(
texture
instanceof
GPUExternalTexture
)
{
entries
.
push
(
{
binding
:
0
visibility
externalTexture
:
{
}
}
)
;
}
else
if
(
code
.
includes
(
'
texture_storage
'
)
)
{
entries
.
push
(
{
binding
:
0
visibility
storageTexture
:
{
access
:
code
.
includes
(
'
read
>
'
)
?
'
read
-
only
'
:
code
.
includes
(
'
write
>
'
)
?
'
write
-
only
'
:
'
read
-
write
'
viewDimension
:
viewDescriptor
?
.
dimension
?
?
'
2d
'
format
:
texture
.
format
}
}
)
;
}
else
{
const
sampleType
=
viewDescriptor
?
.
aspect
=
=
=
'
stencil
-
only
'
?
'
uint
'
:
code
.
includes
(
'
texture_depth
'
)
?
'
depth
'
:
isDepthTextureFormat
(
texture
.
format
)
?
'
unfilterable
-
float
'
:
isStencilTextureFormat
(
texture
.
format
)
?
'
uint
'
:
texture
.
sampleCount
>
1
&
&
getTextureFormatType
(
texture
.
format
)
=
=
=
'
float
'
?
'
unfilterable
-
float
'
:
getTextureFormatType
(
texture
.
format
)
?
?
'
unfilterable
-
float
'
;
entries
.
push
(
{
binding
:
0
visibility
texture
:
{
sampleType
viewDimension
:
viewDescriptor
?
.
dimension
?
?
'
2d
'
multisampled
:
texture
.
sampleCount
>
1
}
}
)
;
}
const
bindGroupLayouts
:
GPUBindGroupLayout
[
]
=
[
device
.
createBindGroupLayout
(
{
entries
}
)
]
;
if
(
stage
=
=
=
'
compute
'
)
{
bindGroupLayouts
.
push
(
device
.
createBindGroupLayout
(
{
entries
:
[
{
binding
:
0
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
hasDynamicOffset
:
false
minBindingSize
:
16
}
}
]
}
)
)
;
}
const
layout
=
device
.
createPipelineLayout
(
{
bindGroupLayouts
}
)
;
let
pipeline
:
GPUComputePipeline
|
GPURenderPipeline
;
switch
(
stage
)
{
case
'
compute
'
:
pipeline
=
device
.
createComputePipeline
(
{
layout
compute
:
{
module
}
}
)
;
break
;
case
'
fragment
'
:
case
'
vertex
'
:
pipeline
=
device
.
createRenderPipeline
(
{
layout
vertex
:
{
module
}
fragment
:
{
module
targets
:
[
{
format
:
'
rgba32uint
'
}
]
}
}
)
;
break
;
}
const
bindGroup0
=
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
texture
instanceof
GPUExternalTexture
?
texture
:
texture
.
createView
(
viewDescriptor
)
}
]
}
)
;
const
renderTarget
=
this
.
createTextureTracked
(
{
format
:
'
rgba32uint
'
size
:
[
expected
.
length
1
]
usage
:
GPUTextureUsage
.
COPY_SRC
|
GPUTextureUsage
.
RENDER_ATTACHMENT
}
)
;
const
resultBuffer
=
this
.
createBufferTracked
(
{
size
:
align
(
expected
.
length
*
4
256
)
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
COPY_SRC
}
)
;
let
storageBuffer
:
GPUBuffer
|
undefined
;
const
encoder
=
device
.
createCommandEncoder
(
)
;
if
(
stage
=
=
=
'
compute
'
)
{
storageBuffer
=
this
.
createBufferTracked
(
{
size
:
resultBuffer
.
size
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_SRC
}
)
;
const
bindGroup1
=
device
.
createBindGroup
(
{
layout
:
pipeline
!
.
getBindGroupLayout
(
1
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
storageBuffer
}
}
]
}
)
;
const
pass
=
encoder
.
beginComputePass
(
)
;
pass
.
setPipeline
(
pipeline
!
as
GPUComputePipeline
)
;
pass
.
setBindGroup
(
0
bindGroup0
)
;
pass
.
setBindGroup
(
1
bindGroup1
)
;
pass
.
dispatchWorkgroups
(
expected
.
length
)
;
pass
.
end
(
)
;
encoder
.
copyBufferToBuffer
(
storageBuffer
0
resultBuffer
0
storageBuffer
.
size
)
;
}
else
{
const
pass
=
encoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
renderTarget
.
createView
(
)
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
]
}
)
;
pass
.
setPipeline
(
pipeline
!
as
GPURenderPipeline
)
;
pass
.
setBindGroup
(
0
bindGroup0
)
;
for
(
let
i
=
0
;
i
<
expected
.
length
;
+
+
i
)
{
pass
.
setViewport
(
i
0
1
1
0
1
)
;
pass
.
draw
(
3
1
0
i
)
;
}
pass
.
end
(
)
;
encoder
.
copyTextureToBuffer
(
{
texture
:
renderTarget
}
{
buffer
:
resultBuffer
bytesPerRow
:
resultBuffer
.
size
}
[
renderTarget
.
width
1
]
)
;
}
this
.
device
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
const
e
=
new
Uint32Array
(
4
)
;
e
.
set
(
expected
)
;
this
.
expectGPUBufferValuesEqual
(
resultBuffer
e
)
;
}
}
export
class
WGSLTextureSampleTest
extends
AllFeaturesMaxLimitsGPUTest
{
override
async
init
(
)
:
Promise
<
void
>
{
await
super
.
init
(
)
;
}
}
export
type
RangeDef
=
{
num
:
number
;
type
:
'
f32
'
|
'
i32
'
|
'
u32
'
;
}
;
function
getLimitValue
(
v
:
number
)
{
switch
(
v
)
{
case
Number
.
POSITIVE_INFINITY
:
return
1000
;
case
Number
.
NEGATIVE_INFINITY
:
return
-
1000
;
default
:
return
v
;
}
}
function
getMinAndMaxTexelValueForComponent
(
rep
:
TexelRepresentationInfo
component
:
TexelComponent
)
{
assert
(
!
!
rep
.
numericRange
)
;
const
perComponentRanges
=
rep
.
numericRange
as
PerComponentNumericRange
;
const
perComponentRange
=
perComponentRanges
[
component
]
;
const
range
=
rep
.
numericRange
as
NumericRange
;
const
{
min
max
}
=
perComponentRange
?
perComponentRange
:
range
;
return
{
min
:
getLimitValue
(
min
)
max
:
getLimitValue
(
max
)
}
;
}
export
function
getTexelViewFormatForTextureFormat
(
format
:
GPUTextureFormat
)
{
if
(
format
.
endsWith
(
'
sint
'
)
)
{
return
'
rgba32sint
'
;
}
else
if
(
format
.
endsWith
(
'
uint
'
)
)
{
return
'
rgba32uint
'
;
}
return
format
.
endsWith
(
'
-
srgb
'
)
?
'
rgba8unorm
-
srgb
'
:
'
rgba32float
'
;
}
const
kTextureTypeInfo
=
{
depth
:
{
componentType
:
'
f32
'
resultType
:
'
vec4f
'
resultFormat
:
'
rgba32float
'
}
float
:
{
componentType
:
'
f32
'
resultType
:
'
vec4f
'
resultFormat
:
'
rgba32float
'
}
'
unfilterable
-
float
'
:
{
componentType
:
'
f32
'
resultType
:
'
vec4f
'
resultFormat
:
'
rgba32float
'
}
sint
:
{
componentType
:
'
i32
'
resultType
:
'
vec4i
'
resultFormat
:
'
rgba32sint
'
}
uint
:
{
componentType
:
'
u32
'
resultType
:
'
vec4u
'
resultFormat
:
'
rgba32uint
'
}
}
as
const
;
export
function
getTextureFormatTypeInfo
(
format
:
GPUTextureFormat
)
{
const
type
=
getTextureFormatType
(
format
)
;
assert
(
!
!
type
)
;
return
kTextureTypeInfo
[
type
]
;
}
export
function
appendComponentTypeForFormatToTextureType
(
base
:
string
format
:
GPUTextureFormat
)
{
return
base
.
includes
(
'
depth
'
)
?
base
:
{
base
}
<
{
getTextureFormatTypeInfo
(
format
)
.
componentType
}
>
;
}
type
RandomTextureOptions
=
{
generator
:
PerPixelAtLevel
<
PerTexelComponent
<
number
>
>
;
}
;
export
function
makeRandomDepthComparisonTexelGenerator
(
info
:
{
format
:
GPUTextureFormat
;
size
:
GPUExtent3D
;
}
comparison
:
GPUCompareFunction
)
{
const
format
=
isUnencodableDepthFormat
(
info
.
format
)
?
'
depth32float
'
:
info
.
format
;
const
rep
=
kTexelRepresentationInfo
[
format
as
EncodableTextureFormat
]
;
const
size
=
reifyExtent3D
(
info
.
size
)
;
const
comparisonIsEqualOrNotEqual
=
comparison
=
=
=
'
equal
'
|
|
comparison
=
=
=
'
not
-
equal
'
;
const
fixedValues
=
[
0
0
.
6
1
1
]
;
const
encode
=
comparisonIsEqualOrNotEqual
?
(
norm
:
number
)
=
>
fixedValues
[
(
norm
*
(
fixedValues
.
length
-
1
)
)
|
0
]
:
(
norm
:
number
)
=
>
norm
;
return
(
coords
:
SampleCoord
)
:
Readonly
<
PerTexelComponent
<
number
>
>
=
>
{
const
texel
:
PerTexelComponent
<
number
>
=
{
}
;
for
(
const
component
of
rep
.
componentOrder
)
{
const
rnd
=
hashU32
(
coords
.
x
coords
.
y
coords
.
z
coords
.
sampleIndex
?
?
0
component
.
charCodeAt
(
0
)
size
.
width
size
.
height
size
.
depthOrArrayLayers
)
;
const
normalized
=
clamp
(
rnd
/
0xffffffff
{
min
:
0
max
:
1
}
)
;
texel
[
component
]
=
encode
(
normalized
)
;
}
return
quantize
(
texel
rep
)
;
}
;
}
function
createRandomTexelViewViaColors
(
info
:
{
format
:
GPUTextureFormat
;
size
:
GPUExtent3D
;
mipLevel
:
number
;
}
options
?
:
RandomTextureOptions
|
undefined
)
:
TexelView
{
const
rep
=
kTexelRepresentationInfo
[
info
.
format
as
EncodableTextureFormat
]
;
const
size
=
reifyExtent3D
(
info
.
size
)
;
const
minMax
=
Object
.
fromEntries
(
rep
.
componentOrder
.
map
(
component
=
>
[
component
getMinAndMaxTexelValueForComponent
(
rep
component
)
]
)
)
;
const
generator
=
(
coords
:
SampleCoord
)
:
Readonly
<
PerTexelComponent
<
number
>
>
=
>
{
const
texel
:
PerTexelComponent
<
number
>
=
{
}
;
for
(
const
component
of
rep
.
componentOrder
)
{
const
rnd
=
hashU32
(
coords
.
x
coords
.
y
coords
.
z
coords
.
sampleIndex
?
?
0
component
.
charCodeAt
(
0
)
info
.
mipLevel
size
.
width
size
.
height
size
.
depthOrArrayLayers
)
;
const
normalized
=
clamp
(
rnd
/
0xffffffff
{
min
:
0
max
:
1
}
)
;
const
{
min
max
}
=
minMax
[
component
]
;
texel
[
component
]
=
lerp
(
min
max
normalized
)
;
}
return
quantize
(
texel
rep
)
;
}
;
return
TexelView
.
fromTexelsAsColors
(
info
.
format
as
EncodableTextureFormat
options
?
.
generator
?
?
generator
)
;
}
function
createRandomTexelViewViaBytes
(
info
:
{
format
:
GPUTextureFormat
;
size
:
GPUExtent3D
;
mipLevel
:
number
;
sampleCount
:
number
;
}
)
:
TexelView
{
const
{
format
}
=
info
;
const
formatInfo
=
getBlockInfoForTextureFormat
(
format
)
;
const
rep
=
kTexelRepresentationInfo
[
info
.
format
as
EncodableTextureFormat
]
;
assert
(
!
!
rep
)
;
const
{
bytesPerBlock
}
=
formatInfo
;
assert
(
bytesPerBlock
!
=
=
undefined
&
&
bytesPerBlock
>
0
)
;
const
size
=
physicalMipSize
(
reifyExtent3D
(
info
.
size
)
info
.
format
'
2d
'
0
)
;
const
blocksAcross
=
Math
.
ceil
(
size
.
width
/
formatInfo
.
blockWidth
)
;
const
blocksDown
=
Math
.
ceil
(
size
.
height
/
formatInfo
.
blockHeight
)
;
const
bytesPerRow
=
blocksAcross
*
bytesPerBlock
*
info
.
sampleCount
;
const
bytesNeeded
=
bytesPerRow
*
blocksDown
*
size
.
depthOrArrayLayers
;
const
data
=
new
Uint8Array
(
bytesNeeded
)
;
const
hashBase
=
sumOfCharCodesOfString
(
info
.
format
)
+
size
.
width
+
size
.
height
+
size
.
depthOrArrayLayers
+
info
.
mipLevel
+
info
.
sampleCount
;
if
(
info
.
format
.
includes
(
'
32float
'
)
|
|
info
.
format
.
includes
(
'
16float
'
)
)
{
const
{
min
max
}
=
getMinAndMaxTexelValueForComponent
(
rep
TexelComponent
.
R
)
;
const
asFloat
=
info
.
format
.
includes
(
'
32float
'
)
?
new
Float32Array
(
data
.
buffer
)
:
new
Float16Array
(
data
.
buffer
)
;
for
(
let
i
=
0
;
i
<
asFloat
.
length
;
+
+
i
)
{
asFloat
[
i
]
=
lerp
(
min
max
hashU32
(
hashBase
+
i
)
/
0xffff_ffff
)
;
}
}
else
if
(
bytesNeeded
%
4
=
=
=
0
)
{
const
asU32
=
new
Uint32Array
(
data
.
buffer
)
;
for
(
let
i
=
0
;
i
<
asU32
.
length
;
+
+
i
)
{
asU32
[
i
]
=
hashU32
(
hashBase
+
i
)
;
}
}
else
{
for
(
let
i
=
0
;
i
<
bytesNeeded
;
+
+
i
)
{
data
[
i
]
=
hashU32
(
hashBase
+
i
)
;
}
}
return
TexelView
.
fromTextureDataByReference
(
info
.
format
as
EncodableTextureFormat
data
{
bytesPerRow
rowsPerImage
:
size
.
height
subrectOrigin
:
[
0
0
0
]
subrectSize
:
size
}
)
;
}
function
createRandomTexelView
(
info
:
{
format
:
GPUTextureFormat
;
size
:
GPUExtent3D
;
mipLevel
:
number
;
sampleCount
:
number
;
}
options
?
:
RandomTextureOptions
|
undefined
)
:
TexelView
{
const
{
format
}
=
info
;
assert
(
!
isCompressedTextureFormat
(
format
)
)
;
const
type
=
getTextureFormatType
(
format
)
;
const
canFillWithRandomTypedData
=
!
options
&
&
isEncodableTextureFormat
(
format
)
&
&
(
(
format
.
includes
(
'
norm
'
)
&
&
type
!
=
=
'
depth
'
)
|
|
format
.
includes
(
'
16float
'
)
|
|
(
format
.
includes
(
'
32float
'
)
&
&
type
!
=
=
'
depth
'
)
|
|
type
=
=
=
'
sint
'
|
|
type
=
=
=
'
uint
'
)
;
return
canFillWithRandomTypedData
?
createRandomTexelViewViaBytes
(
info
)
:
createRandomTexelViewViaColors
(
info
options
)
;
}
function
createRandomTexelViewMipmap
(
info
:
{
format
:
GPUTextureFormat
;
size
:
GPUExtent3D
;
mipLevelCount
?
:
number
;
dimension
?
:
GPUTextureDimension
;
sampleCount
?
:
number
;
}
options
?
:
RandomTextureOptions
|
undefined
)
:
TexelView
[
]
{
const
mipLevelCount
=
info
.
mipLevelCount
?
?
1
;
const
dimension
=
info
.
dimension
?
?
'
2d
'
;
return
range
(
mipLevelCount
i
=
>
createRandomTexelView
(
{
format
:
info
.
format
size
:
virtualMipSize
(
dimension
info
.
size
i
)
mipLevel
:
i
sampleCount
:
info
.
sampleCount
?
?
1
}
options
)
)
;
}
export
type
vec1
=
[
number
]
;
export
type
vec2
=
[
number
number
]
;
export
type
vec3
=
[
number
number
number
]
;
export
type
vec4
=
[
number
number
number
number
]
;
export
type
Dimensionality
=
vec1
|
vec2
|
vec3
;
type
TextureCallArgKeys
=
keyof
TextureCallArgs
<
vec1
>
;
const
kTextureCallArgNames
:
readonly
TextureCallArgKeys
[
]
=
[
'
component
'
'
coords
'
'
derivativeMult
'
'
arrayIndex
'
'
bias
'
'
sampleIndex
'
'
mipLevel
'
'
ddx
'
'
ddy
'
'
depthRef
'
'
offset
'
]
as
const
;
export
interface
TextureCallArgs
<
T
extends
Dimensionality
>
{
component
?
:
number
;
coords
?
:
T
;
derivativeMult
?
:
T
;
mipLevel
?
:
number
;
arrayIndex
?
:
number
;
bias
?
:
number
;
sampleIndex
?
:
number
;
depthRef
?
:
number
;
ddx
?
:
T
;
ddy
?
:
T
;
offset
?
:
T
;
}
export
type
TextureBuiltin
=
|
'
textureGather
'
|
'
textureGatherCompare
'
|
'
textureLoad
'
|
'
textureSample
'
|
'
textureSampleBaseClampToEdge
'
|
'
textureSampleBias
'
|
'
textureSampleCompare
'
|
'
textureSampleCompareLevel
'
|
'
textureSampleGrad
'
|
'
textureSampleLevel
'
;
export
interface
TextureCall
<
T
extends
Dimensionality
>
extends
TextureCallArgs
<
T
>
{
builtin
:
TextureBuiltin
;
coordType
:
'
f
'
|
'
i
'
|
'
u
'
;
levelType
?
:
'
i
'
|
'
u
'
|
'
f
'
;
arrayIndexType
?
:
'
i
'
|
'
u
'
;
sampleIndexType
?
:
'
i
'
|
'
u
'
;
componentType
?
:
'
i
'
|
'
u
'
;
}
const
isBuiltinComparison
=
(
builtin
:
TextureBuiltin
)
=
>
builtin
=
=
=
'
textureGatherCompare
'
|
|
builtin
=
=
=
'
textureSampleCompare
'
|
|
builtin
=
=
=
'
textureSampleCompareLevel
'
;
const
isBuiltinGather
=
(
builtin
:
TextureBuiltin
|
undefined
)
=
>
builtin
=
=
=
'
textureGather
'
|
|
builtin
=
=
=
'
textureGatherCompare
'
;
const
builtinNeedsSampler
=
(
builtin
:
TextureBuiltin
)
=
>
builtin
.
startsWith
(
'
textureSample
'
)
|
|
builtin
.
startsWith
(
'
textureGather
'
)
;
const
builtinNeedsDerivatives
=
(
builtin
:
TextureBuiltin
)
=
>
builtin
=
=
=
'
textureSample
'
|
|
builtin
=
=
=
'
textureSampleBias
'
|
|
builtin
=
=
=
'
textureSampleCompare
'
;
const
isCubeViewDimension
=
(
viewDescriptor
?
:
GPUTextureViewDescriptor
)
=
>
viewDescriptor
?
.
dimension
=
=
=
'
cube
'
|
|
viewDescriptor
?
.
dimension
=
=
=
'
cube
-
array
'
;
const
isViewDimensionCubeOrCubeArray
=
(
viewDimension
:
GPUTextureViewDimension
)
=
>
viewDimension
=
=
=
'
cube
'
|
|
viewDimension
=
=
=
'
cube
-
array
'
;
const
s_u32
=
new
Uint32Array
(
1
)
;
const
s_f32
=
new
Float32Array
(
s_u32
.
buffer
)
;
const
s_i32
=
new
Int32Array
(
s_u32
.
buffer
)
;
const
kBitCastFunctions
=
{
f
:
(
v
:
number
)
=
>
{
s_f32
[
0
]
=
v
;
return
s_u32
[
0
]
;
}
i
:
(
v
:
number
)
=
>
{
s_i32
[
0
]
=
v
;
assert
(
s_i32
[
0
]
=
=
=
v
'
check
we
are
not
casting
non
-
int
or
out
-
of
-
range
value
'
)
;
return
s_u32
[
0
]
;
}
u
:
(
v
:
number
)
=
>
{
s_u32
[
0
]
=
v
;
assert
(
s_u32
[
0
]
=
=
=
v
'
check
we
are
not
casting
non
-
uint
or
out
-
of
-
range
value
'
)
;
return
s_u32
[
0
]
;
}
}
;
function
getCallArgType
<
T
extends
Dimensionality
>
(
call
:
TextureCall
<
T
>
argName
:
(
typeof
kTextureCallArgNames
)
[
number
]
)
{
switch
(
argName
)
{
case
'
coords
'
:
case
'
derivativeMult
'
:
return
call
.
coordType
;
case
'
component
'
:
assert
(
call
.
componentType
!
=
=
undefined
)
;
return
call
.
componentType
;
case
'
mipLevel
'
:
assert
(
call
.
levelType
!
=
=
undefined
)
;
return
call
.
levelType
;
case
'
arrayIndex
'
:
assert
(
call
.
arrayIndexType
!
=
=
undefined
)
;
return
call
.
arrayIndexType
;
case
'
sampleIndex
'
:
assert
(
call
.
sampleIndexType
!
=
=
undefined
)
;
return
call
.
sampleIndexType
;
case
'
bias
'
:
case
'
depthRef
'
:
case
'
ddx
'
:
case
'
ddy
'
:
return
'
f
'
;
default
:
unreachable
(
)
;
}
}
function
toArray
(
coords
:
Dimensionality
)
:
number
[
]
{
if
(
coords
instanceof
Array
)
{
return
coords
;
}
return
[
coords
]
;
}
function
quantize
(
texel
:
PerTexelComponent
<
number
>
repl
:
TexelRepresentationInfo
)
{
return
repl
.
bitsToNumber
(
repl
.
unpackBits
(
new
Uint8Array
(
repl
.
pack
(
repl
.
encode
(
texel
)
)
)
)
)
;
}
function
apply
(
a
:
number
[
]
b
:
number
[
]
op
:
(
x
:
number
y
:
number
)
=
>
number
)
{
assert
(
a
.
length
=
=
=
b
.
length
apply
(
{
a
}
{
b
}
)
:
arrays
must
have
same
length
)
;
return
a
.
map
(
(
v
i
)
=
>
op
(
v
b
[
i
]
)
)
;
}
function
getUnusedCubeCornerSampleIndex
(
textureSize
:
number
coords
:
vec3
)
{
const
u
=
coords
[
0
]
*
textureSize
;
const
v
=
coords
[
1
]
*
textureSize
;
if
(
v
<
0
.
5
)
{
if
(
u
<
0
.
5
)
{
return
0
;
}
else
if
(
u
>
=
textureSize
-
0
.
5
)
{
return
1
;
}
}
else
if
(
v
>
=
textureSize
-
0
.
5
)
{
if
(
u
<
0
.
5
)
{
return
2
;
}
else
if
(
u
>
=
textureSize
-
0
.
5
)
{
return
3
;
}
}
return
-
1
;
}
const
add
=
(
a
:
number
[
]
b
:
number
[
]
)
=
>
apply
(
a
b
(
x
y
)
=
>
x
+
y
)
;
export
interface
Texture
{
texels
:
TexelView
[
]
;
descriptor
:
GPUTextureDescriptor
;
viewDescriptor
:
GPUTextureViewDescriptor
;
}
export
function
convertPerTexelComponentToResultFormat
(
src
:
PerTexelComponent
<
number
>
format
:
EncodableTextureFormat
)
:
PerTexelComponent
<
number
>
{
const
rep
=
kTexelRepresentationInfo
[
format
]
;
const
out
:
PerTexelComponent
<
number
>
=
{
R
:
0
G
:
0
B
:
0
A
:
1
}
;
for
(
const
component
of
rep
.
componentOrder
)
{
switch
(
component
)
{
case
'
Stencil
'
:
case
'
Depth
'
:
out
.
R
=
src
[
component
]
;
break
;
default
:
assert
(
out
[
component
]
!
=
=
undefined
)
;
out
[
component
]
=
src
[
component
]
;
}
}
return
out
;
}
function
convertToTexelViewFormat
(
src
:
PerTexelComponent
<
number
>
format
:
GPUTextureFormat
)
{
const
componentOrder
=
isDepthTextureFormat
(
format
)
?
[
TexelComponent
.
Depth
]
:
isStencilTextureFormat
(
format
)
?
[
TexelComponent
.
Stencil
]
:
[
TexelComponent
.
R
TexelComponent
.
G
TexelComponent
.
B
TexelComponent
.
A
]
;
const
out
:
PerTexelComponent
<
number
>
=
{
}
;
for
(
const
component
of
componentOrder
)
{
let
v
=
src
[
component
]
;
if
(
v
=
=
=
undefined
)
{
if
(
component
=
=
=
'
Depth
'
|
|
component
=
=
=
'
Stencil
'
)
{
v
=
src
.
R
;
}
else
if
(
component
=
=
=
'
G
'
|
|
component
=
=
=
'
B
'
)
{
v
=
0
;
}
else
{
v
=
1
;
}
}
out
[
component
]
=
v
;
}
return
out
;
}
function
convertResultFormatToTexelViewFormat
(
src
:
PerTexelComponent
<
number
>
format
:
EncodableTextureFormat
)
:
PerTexelComponent
<
number
>
{
const
rep
=
kTexelRepresentationInfo
[
format
]
;
const
out
:
PerTexelComponent
<
number
>
=
{
}
;
for
(
const
component
of
rep
.
componentOrder
)
{
out
[
component
]
=
src
[
component
]
?
?
src
.
R
;
}
return
out
;
}
function
zeroValuePerTexelComponent
(
components
:
TexelComponent
[
]
)
{
const
out
:
PerTexelComponent
<
number
>
=
{
}
;
for
(
const
component
of
components
)
{
out
[
component
]
=
0
;
}
return
out
;
}
const
kSamplerFns
:
Record
<
GPUCompareFunction
(
ref
:
number
v
:
number
)
=
>
boolean
>
=
{
never
:
(
ref
:
number
v
:
number
)
=
>
false
less
:
(
ref
:
number
v
:
number
)
=
>
ref
<
v
equal
:
(
ref
:
number
v
:
number
)
=
>
ref
=
=
=
v
'
less
-
equal
'
:
(
ref
:
number
v
:
number
)
=
>
ref
<
=
v
greater
:
(
ref
:
number
v
:
number
)
=
>
ref
>
v
'
not
-
equal
'
:
(
ref
:
number
v
:
number
)
=
>
ref
!
=
=
v
'
greater
-
equal
'
:
(
ref
:
number
v
:
number
)
=
>
ref
>
=
v
always
:
(
ref
:
number
v
:
number
)
=
>
true
}
as
const
;
function
applyCompare
<
T
extends
Dimensionality
>
(
call
:
TextureCall
<
T
>
sampler
:
GPUSamplerDescriptor
|
undefined
components
:
TexelComponent
[
]
src
:
PerTexelComponent
<
number
>
)
:
PerTexelComponent
<
number
>
{
if
(
isBuiltinComparison
(
call
.
builtin
)
)
{
assert
(
sampler
!
=
=
undefined
)
;
assert
(
call
.
depthRef
!
=
=
undefined
)
;
const
out
:
PerTexelComponent
<
number
>
=
{
}
;
const
compareFn
=
kSamplerFns
[
sampler
.
compare
!
]
;
for
(
const
component
of
components
)
{
out
[
component
]
=
compareFn
(
call
.
depthRef
src
[
component
]
!
)
?
1
:
0
;
}
return
out
;
}
else
{
return
src
;
}
}
function
softwareTextureReadMipLevel
<
T
extends
Dimensionality
>
(
call
:
TextureCall
<
T
>
texture
:
Texture
sampler
:
GPUSamplerDescriptor
|
undefined
mipLevel
:
number
)
:
PerTexelComponent
<
number
>
{
assert
(
mipLevel
%
1
=
=
=
0
)
;
const
{
format
}
=
texture
.
texels
[
0
]
;
const
rep
=
kTexelRepresentationInfo
[
format
]
;
const
textureSize
=
virtualMipSize
(
texture
.
descriptor
.
dimension
|
|
'
2d
'
texture
.
descriptor
.
size
mipLevel
)
;
const
addressMode
:
GPUAddressMode
[
]
=
call
.
builtin
=
=
=
'
textureSampleBaseClampToEdge
'
?
[
'
clamp
-
to
-
edge
'
'
clamp
-
to
-
edge
'
'
clamp
-
to
-
edge
'
]
:
[
sampler
?
.
addressModeU
?
?
'
clamp
-
to
-
edge
'
sampler
?
.
addressModeV
?
?
'
clamp
-
to
-
edge
'
sampler
?
.
addressModeW
?
?
'
clamp
-
to
-
edge
'
]
;
const
isCube
=
isCubeViewDimension
(
texture
.
viewDescriptor
)
;
const
arrayIndexMult
=
isCube
?
6
:
1
;
const
numLayers
=
textureSize
[
2
]
/
arrayIndexMult
;
assert
(
numLayers
%
1
=
=
=
0
)
;
const
textureSizeForCube
=
[
textureSize
[
0
]
textureSize
[
1
]
6
]
;
const
load
=
(
at
:
number
[
]
)
=
>
{
const
zFromArrayIndex
=
call
.
arrayIndex
!
=
=
undefined
?
clamp
(
call
.
arrayIndex
{
min
:
0
max
:
numLayers
-
1
}
)
*
arrayIndexMult
:
0
;
return
texture
.
texels
[
mipLevel
]
.
color
(
{
x
:
Math
.
floor
(
at
[
0
]
)
y
:
Math
.
floor
(
at
[
1
]
?
?
0
)
z
:
Math
.
floor
(
at
[
2
]
?
?
0
)
+
zFromArrayIndex
sampleIndex
:
call
.
sampleIndex
}
)
;
}
;
switch
(
call
.
builtin
)
{
case
'
textureGather
'
:
case
'
textureGatherCompare
'
:
case
'
textureSample
'
:
case
'
textureSampleBias
'
:
case
'
textureSampleBaseClampToEdge
'
:
case
'
textureSampleCompare
'
:
case
'
textureSampleCompareLevel
'
:
case
'
textureSampleGrad
'
:
case
'
textureSampleLevel
'
:
{
let
coords
=
toArray
(
call
.
coords
!
)
;
if
(
isCube
)
{
coords
=
convertCubeCoordToNormalized3DTextureCoord
(
coords
as
vec3
)
;
}
let
at
=
coords
.
map
(
(
v
i
)
=
>
v
*
(
isCube
?
textureSizeForCube
:
textureSize
)
[
i
]
-
0
.
5
)
;
if
(
call
.
offset
!
=
=
undefined
)
{
at
=
add
(
at
toArray
(
call
.
offset
)
)
;
}
const
samples
:
{
at
:
number
[
]
;
weight
:
number
}
[
]
=
[
]
;
const
filter
=
isBuiltinGather
(
call
.
builtin
)
?
'
linear
'
:
sampler
?
.
minFilter
?
?
'
nearest
'
;
switch
(
filter
)
{
case
'
linear
'
:
{
const
p0
=
at
.
map
(
v
=
>
Math
.
floor
(
v
)
)
;
const
p1
=
p0
.
map
(
(
v
i
)
=
>
v
+
(
isCube
?
(
i
=
=
=
2
?
0
:
1
)
:
1
)
)
;
const
p1W
=
at
.
map
(
(
v
i
)
=
>
v
-
p0
[
i
]
)
;
const
p0W
=
p1W
.
map
(
v
=
>
1
-
v
)
;
switch
(
coords
.
length
)
{
case
1
:
samples
.
push
(
{
at
:
p0
weight
:
p0W
[
0
]
}
)
;
samples
.
push
(
{
at
:
p1
weight
:
p1W
[
0
]
}
)
;
break
;
case
2
:
{
samples
.
push
(
{
at
:
[
p0
[
0
]
p1
[
1
]
]
weight
:
p0W
[
0
]
*
p1W
[
1
]
}
)
;
samples
.
push
(
{
at
:
p1
weight
:
p1W
[
0
]
*
p1W
[
1
]
}
)
;
samples
.
push
(
{
at
:
[
p1
[
0
]
p0
[
1
]
]
weight
:
p1W
[
0
]
*
p0W
[
1
]
}
)
;
samples
.
push
(
{
at
:
p0
weight
:
p0W
[
0
]
*
p0W
[
1
]
}
)
;
break
;
}
case
3
:
{
if
(
isCube
)
{
samples
.
push
(
{
at
:
[
p0
[
0
]
p1
[
1
]
p0
[
2
]
]
weight
:
p0W
[
0
]
*
p1W
[
1
]
}
)
;
samples
.
push
(
{
at
:
p1
weight
:
p1W
[
0
]
*
p1W
[
1
]
}
)
;
samples
.
push
(
{
at
:
[
p1
[
0
]
p0
[
1
]
p0
[
2
]
]
weight
:
p1W
[
0
]
*
p0W
[
1
]
}
)
;
samples
.
push
(
{
at
:
p0
weight
:
p0W
[
0
]
*
p0W
[
1
]
}
)
;
const
ndx
=
getUnusedCubeCornerSampleIndex
(
textureSize
[
0
]
coords
as
vec3
)
;
if
(
ndx
>
=
0
)
{
unreachable
(
corners
of
cubemaps
are
not
testable
:
\
n
{
describeTextureCall
(
call
)
}
)
;
}
}
else
{
const
p
=
[
p0
p1
]
;
const
w
=
[
p0W
p1W
]
;
for
(
let
z
=
0
;
z
<
2
;
+
+
z
)
{
for
(
let
y
=
0
;
y
<
2
;
+
+
y
)
{
for
(
let
x
=
0
;
x
<
2
;
+
+
x
)
{
samples
.
push
(
{
at
:
[
p
[
x
]
[
0
]
p
[
y
]
[
1
]
p
[
z
]
[
2
]
]
weight
:
w
[
x
]
[
0
]
*
w
[
y
]
[
1
]
*
w
[
z
]
[
2
]
}
)
;
}
}
}
}
break
;
}
}
break
;
}
case
'
nearest
'
:
{
const
p
=
at
.
map
(
v
=
>
Math
.
round
(
quantizeToF32
(
v
)
)
)
;
samples
.
push
(
{
at
:
p
weight
:
1
}
)
;
break
;
}
default
:
unreachable
(
)
;
}
if
(
isBuiltinGather
(
call
.
builtin
)
)
{
const
componentNdx
=
call
.
component
?
?
0
;
assert
(
componentNdx
>
=
0
&
&
componentNdx
<
4
)
;
assert
(
samples
.
length
=
=
=
4
)
;
const
component
=
kRGBAComponents
[
componentNdx
]
;
const
out
:
PerTexelComponent
<
number
>
=
{
}
;
samples
.
forEach
(
(
sample
i
)
=
>
{
const
c
=
isCube
?
wrapFaceCoordToCubeFaceAtEdgeBoundaries
(
textureSize
[
0
]
sample
.
at
as
vec3
)
:
applyAddressModesToCoords
(
addressMode
textureSize
sample
.
at
)
;
const
v
=
load
(
c
)
;
const
postV
=
applyCompare
(
call
sampler
rep
.
componentOrder
v
)
;
const
rgba
=
convertPerTexelComponentToResultFormat
(
postV
format
)
;
out
[
kRGBAComponents
[
i
]
]
=
rgba
[
component
]
;
}
)
;
return
out
;
}
const
out
:
PerTexelComponent
<
number
>
=
{
}
;
for
(
const
sample
of
samples
)
{
const
c
=
isCube
?
wrapFaceCoordToCubeFaceAtEdgeBoundaries
(
textureSize
[
0
]
sample
.
at
as
vec3
)
:
applyAddressModesToCoords
(
addressMode
textureSize
sample
.
at
)
;
const
v
=
load
(
c
)
;
const
postV
=
applyCompare
(
call
sampler
rep
.
componentOrder
v
)
;
for
(
const
component
of
rep
.
componentOrder
)
{
out
[
component
]
=
(
out
[
component
]
?
?
0
)
+
postV
[
component
]
!
*
sample
.
weight
;
}
}
return
convertPerTexelComponentToResultFormat
(
out
format
)
;
}
case
'
textureLoad
'
:
{
const
out
:
PerTexelComponent
<
number
>
=
isOutOfBoundsCall
(
texture
call
)
?
zeroValuePerTexelComponent
(
rep
.
componentOrder
)
:
load
(
call
.
coords
!
)
;
return
convertPerTexelComponentToResultFormat
(
out
format
)
;
}
default
:
unreachable
(
)
;
}
}
function
softwareTextureReadLevel
<
T
extends
Dimensionality
>
(
t
:
GPUTest
stage
:
ShaderStage
call
:
TextureCall
<
T
>
texture
:
Texture
sampler
:
GPUSamplerDescriptor
|
undefined
mipLevel
:
number
)
:
PerTexelComponent
<
number
>
{
const
mipLevelCount
=
texture
.
texels
.
length
;
const
maxLevel
=
mipLevelCount
-
1
;
if
(
!
sampler
)
{
return
softwareTextureReadMipLevel
<
T
>
(
call
texture
sampler
mipLevel
)
;
}
const
effectiveMipmapFilter
=
isBuiltinGather
(
call
.
builtin
)
?
'
nearest
'
:
sampler
.
mipmapFilter
;
switch
(
effectiveMipmapFilter
)
{
case
'
linear
'
:
{
const
clampedMipLevel
=
clamp
(
mipLevel
{
min
:
0
max
:
maxLevel
}
)
;
const
baseMipLevel
=
Math
.
floor
(
clampedMipLevel
)
;
const
nextMipLevel
=
Math
.
ceil
(
clampedMipLevel
)
;
const
t0
=
softwareTextureReadMipLevel
<
T
>
(
call
texture
sampler
baseMipLevel
)
;
const
t1
=
softwareTextureReadMipLevel
<
T
>
(
call
texture
sampler
nextMipLevel
)
;
const
weightType
=
call
.
builtin
=
=
=
'
textureSampleLevel
'
?
'
sampleLevelWeights
'
:
'
identity
'
;
const
mix
=
getWeightForMipLevel
(
t
stage
weightType
mipLevelCount
clampedMipLevel
)
;
assert
(
mix
>
=
0
&
&
mix
<
=
1
)
;
const
values
=
[
{
v
:
t0
weight
:
1
-
mix
}
{
v
:
t1
weight
:
mix
}
]
;
const
out
:
PerTexelComponent
<
number
>
=
{
}
;
for
(
const
{
v
weight
}
of
values
)
{
for
(
const
component
of
kRGBAComponents
)
{
out
[
component
]
=
(
out
[
component
]
?
?
0
)
+
v
[
component
]
!
*
weight
;
}
}
return
out
;
}
default
:
{
const
baseMipLevel
=
Math
.
floor
(
clamp
(
mipLevel
+
0
.
5
{
min
:
0
max
:
texture
.
texels
.
length
-
1
}
)
)
;
return
softwareTextureReadMipLevel
<
T
>
(
call
texture
sampler
baseMipLevel
)
;
}
}
}
function
computeMipLevelFromGradients
(
ddx
:
readonly
number
[
]
ddy
:
readonly
number
[
]
size
:
GPUExtent3D
)
{
const
texSize
=
reifyExtent3D
(
size
)
;
const
textureSize
=
[
texSize
.
width
texSize
.
height
texSize
.
depthOrArrayLayers
]
;
const
scaledDdx
=
ddx
.
map
(
(
v
i
)
=
>
v
*
textureSize
[
i
]
)
;
const
scaledDdy
=
ddy
.
map
(
(
v
i
)
=
>
v
*
textureSize
[
i
]
)
;
const
dotDDX
=
dotProduct
(
scaledDdx
scaledDdx
)
;
const
dotDDY
=
dotProduct
(
scaledDdy
scaledDdy
)
;
const
deltaMax
=
Math
.
max
(
dotDDX
dotDDY
)
;
const
mipLevel
=
0
.
5
*
Math
.
log2
(
deltaMax
)
;
return
mipLevel
;
}
function
computeMipLevelFromGradientsForCall
<
T
extends
Dimensionality
>
(
call
:
TextureCall
<
T
>
size
:
GPUExtent3D
)
{
assert
(
!
!
call
.
ddx
)
;
assert
(
!
!
call
.
ddy
)
;
const
ddx
:
readonly
number
[
]
=
typeof
call
.
ddx
=
=
=
'
number
'
?
[
call
.
ddx
]
:
call
.
ddx
;
const
ddy
:
readonly
number
[
]
=
typeof
call
.
ddy
=
=
=
'
number
'
?
[
call
.
ddy
]
:
call
.
ddy
;
return
computeMipLevelFromGradients
(
ddx
ddy
size
)
;
}
function
softwareTextureReadGrad
<
T
extends
Dimensionality
>
(
t
:
GPUTest
stage
:
ShaderStage
call
:
TextureCall
<
T
>
texture
:
Texture
sampler
?
:
GPUSamplerDescriptor
)
:
PerTexelComponent
<
number
>
{
const
bias
=
call
.
bias
=
=
=
undefined
?
0
:
clamp
(
call
.
bias
{
min
:
-
16
.
0
max
:
15
.
99
}
)
;
if
(
call
.
ddx
)
{
const
mipLevel
=
computeMipLevelFromGradientsForCall
(
call
texture
.
descriptor
.
size
)
;
const
mipLevelCount
=
texture
.
descriptor
.
mipLevelCount
?
?
1
;
const
clampedMipLevel
=
clamp
(
mipLevel
+
bias
{
min
:
0
max
:
mipLevelCount
-
1
}
)
;
const
weightMipLevel
=
mapSoftwareMipLevelToGPUMipLevel
(
t
stage
clampedMipLevel
)
;
return
softwareTextureReadLevel
(
t
stage
call
texture
sampler
weightMipLevel
)
;
}
else
{
return
softwareTextureReadLevel
(
t
stage
call
texture
sampler
(
call
.
mipLevel
?
?
0
)
+
bias
)
;
}
}
function
derivativeBaseForCall
<
T
extends
Dimensionality
>
(
texture
:
Texture
isDDX
:
boolean
)
{
const
texSize
=
reifyExtent3D
(
texture
.
descriptor
.
size
)
;
const
textureSize
=
[
texSize
.
width
texSize
.
height
texSize
.
depthOrArrayLayers
]
;
if
(
isCubeViewDimension
(
texture
.
viewDescriptor
)
)
{
return
(
isDDX
?
[
1
/
textureSize
[
0
]
0
1
]
:
[
0
1
/
textureSize
[
1
]
1
]
)
as
T
;
}
else
if
(
texture
.
descriptor
.
dimension
=
=
=
'
3d
'
)
{
return
(
isDDX
?
[
1
/
textureSize
[
0
]
0
0
]
:
[
0
1
/
textureSize
[
1
]
0
]
)
as
T
;
}
else
if
(
texture
.
descriptor
.
dimension
=
=
=
'
1d
'
)
{
return
[
1
/
textureSize
[
0
]
]
as
T
;
}
else
{
return
(
isDDX
?
[
1
/
textureSize
[
0
]
0
]
:
[
0
1
/
textureSize
[
1
]
]
)
as
T
;
}
}
function
derivativeForCall
<
T
extends
Dimensionality
>
(
texture
:
Texture
call
:
TextureCall
<
T
>
isDDX
:
boolean
)
{
const
dd
=
derivativeBaseForCall
(
texture
isDDX
)
;
return
dd
.
map
(
(
v
i
)
=
>
v
*
(
call
.
derivativeMult
?
.
[
i
]
?
?
1
)
)
as
T
;
}
function
softwareTextureRead
<
T
extends
Dimensionality
>
(
t
:
GPUTest
stage
:
ShaderStage
call
:
TextureCall
<
T
>
texture
:
Texture
sampler
?
:
GPUSamplerDescriptor
)
:
PerTexelComponent
<
number
>
{
if
(
builtinNeedsDerivatives
(
call
.
builtin
)
&
&
!
call
.
ddx
)
{
const
newCall
:
TextureCall
<
T
>
=
{
.
.
.
call
ddx
:
call
.
ddx
?
?
derivativeForCall
<
T
>
(
texture
call
true
)
ddy
:
call
.
ddy
?
?
derivativeForCall
<
T
>
(
texture
call
false
)
}
;
call
=
newCall
;
}
return
softwareTextureReadGrad
(
t
stage
call
texture
sampler
)
;
}
export
type
TextureTestOptions
<
T
extends
Dimensionality
>
=
{
ddx
?
:
number
;
ddy
?
:
number
;
uvwStart
?
:
Readonly
<
T
>
;
offset
?
:
Readonly
<
T
>
;
depthTexture
?
:
boolean
;
arrayIndexType
?
:
'
i
'
|
'
u
'
;
}
;
function
isOutOfBoundsCall
<
T
extends
Dimensionality
>
(
texture
:
Texture
call
:
TextureCall
<
T
>
)
{
assert
(
call
.
coords
!
=
=
undefined
)
;
const
desc
=
reifyTextureDescriptor
(
texture
.
descriptor
)
;
const
{
coords
mipLevel
arrayIndex
sampleIndex
}
=
call
;
if
(
mipLevel
!
=
=
undefined
&
&
(
mipLevel
<
0
|
|
mipLevel
>
=
desc
.
mipLevelCount
)
)
{
return
true
;
}
const
size
=
virtualMipSize
(
texture
.
descriptor
.
dimension
|
|
'
2d
'
texture
.
descriptor
.
size
mipLevel
?
?
0
)
;
for
(
let
i
=
0
;
i
<
coords
.
length
;
+
+
i
)
{
const
v
=
coords
[
i
]
;
if
(
v
<
0
|
|
v
>
=
size
[
i
]
)
{
return
true
;
}
}
if
(
arrayIndex
!
=
=
undefined
)
{
const
size
=
reifyExtent3D
(
desc
.
size
)
;
if
(
arrayIndex
<
0
|
|
arrayIndex
>
=
size
.
depthOrArrayLayers
)
{
return
true
;
}
}
if
(
sampleIndex
!
=
=
undefined
)
{
if
(
sampleIndex
<
0
|
|
sampleIndex
>
=
desc
.
sampleCount
)
{
return
true
;
}
}
return
false
;
}
function
isValidOutOfBoundsValue
(
texture
:
Texture
gotRGBA
:
PerTexelComponent
<
number
>
maxFractionalDiff
:
number
)
{
if
(
texture
.
descriptor
.
format
.
includes
(
'
depth
'
)
)
{
if
(
gotRGBA
.
R
=
=
=
0
)
{
return
true
;
}
}
else
{
if
(
gotRGBA
.
R
=
=
=
0
&
&
gotRGBA
.
B
=
=
=
0
&
&
gotRGBA
.
G
=
=
=
0
&
&
(
gotRGBA
.
A
=
=
=
0
|
|
gotRGBA
.
A
=
=
=
1
)
)
{
return
true
;
}
}
for
(
let
mipLevel
=
0
;
mipLevel
<
texture
.
texels
.
length
;
+
+
mipLevel
)
{
const
mipTexels
=
texture
.
texels
[
mipLevel
]
;
const
size
=
virtualMipSize
(
texture
.
descriptor
.
dimension
|
|
'
2d
'
texture
.
descriptor
.
size
mipLevel
)
;
const
sampleCount
=
texture
.
descriptor
.
sampleCount
?
?
1
;
for
(
let
z
=
0
;
z
<
size
[
2
]
;
+
+
z
)
{
for
(
let
y
=
0
;
y
<
size
[
1
]
;
+
+
y
)
{
for
(
let
x
=
0
;
x
<
size
[
0
]
;
+
+
x
)
{
for
(
let
sampleIndex
=
0
;
sampleIndex
<
sampleCount
;
+
+
sampleIndex
)
{
const
texel
=
mipTexels
.
color
(
{
x
y
z
sampleIndex
}
)
;
const
rgba
=
convertPerTexelComponentToResultFormat
(
texel
mipTexels
.
format
)
;
if
(
texelsApproximatelyEqual
(
gotRGBA
texture
.
descriptor
.
format
rgba
mipTexels
.
format
maxFractionalDiff
)
)
{
return
true
;
}
}
}
}
}
}
return
false
;
}
function
okBecauseOutOfBounds
<
T
extends
Dimensionality
>
(
texture
:
Texture
call
:
TextureCall
<
T
>
gotRGBA
:
PerTexelComponent
<
number
>
maxFractionalDiff
:
number
)
{
if
(
!
isOutOfBoundsCall
(
texture
call
)
)
{
return
false
;
}
return
isValidOutOfBoundsValue
(
texture
gotRGBA
maxFractionalDiff
)
;
}
const
kRGBAComponents
=
[
TexelComponent
.
R
TexelComponent
.
G
TexelComponent
.
B
TexelComponent
.
A
]
as
const
;
const
kRComponent
=
[
TexelComponent
.
R
]
as
const
;
export
function
texelsApproximatelyEqual
(
gotRGBA
:
PerTexelComponent
<
number
>
gotFormat
:
GPUTextureFormat
expectRGBA
:
PerTexelComponent
<
number
>
expectedFormat
:
EncodableTextureFormat
maxFractionalDiff
:
number
)
{
const
rep
=
kTexelRepresentationInfo
[
expectedFormat
]
;
const
got
=
convertResultFormatToTexelViewFormat
(
gotRGBA
expectedFormat
)
;
const
expect
=
convertResultFormatToTexelViewFormat
(
expectRGBA
expectedFormat
)
;
const
gULP
=
convertPerTexelComponentToResultFormat
(
rep
.
bitsToULPFromZero
(
rep
.
numberToBits
(
got
)
)
expectedFormat
)
;
const
eULP
=
convertPerTexelComponentToResultFormat
(
rep
.
bitsToULPFromZero
(
rep
.
numberToBits
(
expect
)
)
expectedFormat
)
;
const
rgbaComponentsToCheck
=
isDepthOrStencilTextureFormat
(
gotFormat
)
?
kRComponent
:
kRGBAComponents
;
for
(
const
component
of
rgbaComponentsToCheck
)
{
const
g
=
gotRGBA
[
component
]
!
;
const
e
=
expectRGBA
[
component
]
!
;
assert
(
!
isNaN
(
g
)
(
)
=
>
got
component
is
NaN
:
{
g
}
)
;
assert
(
!
isNaN
(
e
)
(
)
=
>
expected
component
is
NaN
:
{
e
}
)
;
const
absDiff
=
Math
.
abs
(
g
-
e
)
;
const
ulpDiff
=
Math
.
abs
(
gULP
[
component
]
!
-
eULP
[
component
]
!
)
;
if
(
ulpDiff
>
3
&
&
absDiff
>
maxFractionalDiff
)
{
return
false
;
}
}
return
true
;
}
function
getULPFromZeroForComponents
(
rgba
:
PerTexelComponent
<
number
>
format
:
EncodableTextureFormat
builtin
:
TextureBuiltin
componentNdx
?
:
number
)
:
PerTexelComponent
<
number
>
{
const
rep
=
kTexelRepresentationInfo
[
format
]
;
if
(
isBuiltinGather
(
builtin
)
)
{
const
out
:
PerTexelComponent
<
number
>
=
{
}
;
const
component
=
kRGBAComponents
[
componentNdx
?
?
0
]
;
const
temp
:
PerTexelComponent
<
number
>
=
{
R
:
0
G
:
0
B
:
0
A
:
1
}
;
for
(
const
comp
of
kRGBAComponents
)
{
temp
[
component
]
=
rgba
[
comp
]
;
const
texel
=
convertResultFormatToTexelViewFormat
(
temp
format
)
;
const
ulp
=
convertPerTexelComponentToResultFormat
(
rep
.
bitsToULPFromZero
(
rep
.
numberToBits
(
texel
)
)
format
)
;
out
[
comp
]
=
ulp
[
component
]
;
}
return
out
;
}
else
{
const
texel
=
convertResultFormatToTexelViewFormat
(
rgba
format
)
;
return
convertPerTexelComponentToResultFormat
(
rep
.
bitsToULPFromZero
(
rep
.
numberToBits
(
texel
)
)
format
)
;
}
}
export
async
function
checkCallResults
<
T
extends
Dimensionality
>
(
t
:
GPUTest
texture
:
Texture
textureType
:
string
sampler
:
GPUSamplerDescriptor
|
undefined
calls
:
TextureCall
<
T
>
[
]
results
:
Awaited
<
ReturnType
<
typeof
doTextureCalls
<
T
>
>
>
shortShaderStage
:
ShortShaderStage
gpuTexture
?
:
GPUTexture
)
{
const
stage
=
kShortShaderStageToShaderStage
[
shortShaderStage
]
;
if
(
builtinNeedsMipLevelWeights
(
calls
[
0
]
.
builtin
)
)
{
await
initMipLevelWeightsForDevice
(
t
stage
)
;
}
let
haveComparisonCheckInfo
=
false
;
let
checkInfo
=
{
runner
:
results
.
runner
calls
sampler
}
;
let
gpuTexels
:
TexelView
[
]
|
undefined
;
const
errs
:
string
[
]
=
[
]
;
const
format
=
texture
.
texels
[
0
]
.
format
;
const
size
=
reifyExtent3D
(
texture
.
descriptor
.
size
)
;
const
maxFractionalDiff
=
sampler
?
.
minFilter
=
=
=
'
linear
'
|
|
sampler
?
.
magFilter
=
=
=
'
linear
'
|
|
sampler
?
.
mipmapFilter
=
=
=
'
linear
'
?
getMaxFractionalDiffForTextureFormat
(
texture
.
descriptor
.
format
)
:
0
;
for
(
let
callIdx
=
0
;
callIdx
<
calls
.
length
;
callIdx
+
+
)
{
const
call
=
calls
[
callIdx
]
;
const
gotRGBA
=
results
.
results
[
callIdx
]
;
const
expectRGBA
=
softwareTextureRead
(
t
stage
call
texture
sampler
)
;
const
callSpecificMaxFractionalDiff
=
call
.
bias
!
>
=
12
?
maxFractionalDiff
*
(
2
+
call
.
bias
!
-
12
)
:
maxFractionalDiff
;
if
(
isDepthOrStencilTextureFormat
(
format
)
&
&
isBuiltinGather
(
call
.
builtin
)
&
&
call
.
component
!
>
0
)
{
continue
;
}
if
(
texelsApproximatelyEqual
(
gotRGBA
texture
.
descriptor
.
format
expectRGBA
format
callSpecificMaxFractionalDiff
)
)
{
continue
;
}
if
(
!
sampler
&
&
okBecauseOutOfBounds
(
texture
call
gotRGBA
callSpecificMaxFractionalDiff
)
)
{
continue
;
}
const
gULP
=
getULPFromZeroForComponents
(
gotRGBA
format
call
.
builtin
call
.
component
)
;
const
eULP
=
getULPFromZeroForComponents
(
expectRGBA
format
call
.
builtin
call
.
component
)
;
const
rgbaComponentsToCheck
=
isBuiltinGather
(
call
.
builtin
)
|
|
!
isDepthOrStencilTextureFormat
(
format
)
?
kRGBAComponents
:
kRComponent
;
let
bad
=
false
;
const
diffs
=
rgbaComponentsToCheck
.
map
(
component
=
>
{
const
g
=
gotRGBA
[
component
]
!
;
const
e
=
expectRGBA
[
component
]
!
;
const
absDiff
=
Math
.
abs
(
g
-
e
)
;
const
ulpDiff
=
Math
.
abs
(
gULP
[
component
]
!
-
eULP
[
component
]
!
)
;
assert
(
!
Number
.
isNaN
(
ulpDiff
)
)
;
const
maxAbs
=
Math
.
max
(
Math
.
abs
(
g
)
Math
.
abs
(
e
)
)
;
const
relDiff
=
maxAbs
>
0
?
absDiff
/
maxAbs
:
0
;
if
(
ulpDiff
>
3
&
&
absDiff
>
callSpecificMaxFractionalDiff
)
{
bad
=
true
;
}
return
{
absDiff
relDiff
ulpDiff
}
;
}
)
;
const
isFloatType
=
(
format
:
GPUTextureFormat
)
=
>
{
const
type
=
getTextureFormatType
(
format
)
;
return
type
=
=
=
'
float
'
|
|
type
=
=
=
'
depth
'
;
}
;
const
fix5
=
(
n
:
number
)
=
>
(
isFloatType
(
format
)
?
n
.
toFixed
(
5
)
:
n
.
toString
(
)
)
;
const
fix5v
=
(
arr
:
number
[
]
)
=
>
arr
.
map
(
v
=
>
fix5
(
v
)
)
.
join
(
'
'
)
;
const
rgbaToArray
=
(
p
:
PerTexelComponent
<
number
>
)
:
number
[
]
=
>
rgbaComponentsToCheck
.
map
(
component
=
>
p
[
component
]
!
)
;
if
(
bad
)
{
const
desc
=
describeTextureCall
(
call
)
;
errs
.
push
(
result
was
not
as
expected
:
size
:
[
{
size
.
width
}
{
size
.
height
}
{
size
.
depthOrArrayLayers
}
]
mipCount
:
{
texture
.
descriptor
.
mipLevelCount
?
?
1
}
call
:
{
desc
}
/
/
#
{
callIdx
}
)
;
if
(
isCubeViewDimension
(
texture
.
viewDescriptor
)
)
{
const
coord
=
convertCubeCoordToNormalized3DTextureCoord
(
call
.
coords
as
vec3
)
;
const
faceNdx
=
Math
.
floor
(
coord
[
2
]
*
6
)
;
errs
.
push
(
:
as
3D
texture
coord
:
(
{
coord
[
0
]
}
{
coord
[
1
]
}
{
coord
[
2
]
}
)
)
;
for
(
let
mipLevel
=
0
;
mipLevel
<
(
texture
.
descriptor
.
mipLevelCount
?
?
1
)
;
+
+
mipLevel
)
{
const
mipSize
=
virtualMipSize
(
texture
.
descriptor
.
dimension
?
?
'
2d
'
texture
.
descriptor
.
size
mipLevel
)
;
const
t
=
coord
.
slice
(
0
2
)
.
map
(
(
v
i
)
=
>
(
v
*
mipSize
[
i
]
)
.
toFixed
(
3
)
)
;
errs
.
push
(
:
as
texel
coord
mip
level
[
{
mipLevel
}
]
:
(
{
t
[
0
]
}
{
t
[
1
]
}
)
face
:
{
faceNdx
}
(
{
kFaceNames
[
faceNdx
]
}
)
)
;
}
}
else
if
(
call
.
coordType
=
=
=
'
f
'
)
{
for
(
let
mipLevel
=
0
;
mipLevel
<
(
texture
.
descriptor
.
mipLevelCount
?
?
1
)
;
+
+
mipLevel
)
{
const
mipSize
=
virtualMipSize
(
texture
.
descriptor
.
dimension
?
?
'
2d
'
texture
.
descriptor
.
size
mipLevel
)
;
const
t
=
call
.
coords
!
.
map
(
(
v
i
)
=
>
(
v
*
mipSize
[
i
]
)
.
toFixed
(
3
)
)
;
errs
.
push
(
:
as
texel
coord
mip
level
[
{
mipLevel
}
]
:
(
{
t
.
join
(
'
'
)
}
)
)
;
}
}
if
(
builtinNeedsDerivatives
(
call
.
builtin
)
)
{
const
ddx
=
derivativeForCall
<
T
>
(
texture
call
true
)
;
const
ddy
=
derivativeForCall
<
T
>
(
texture
call
false
)
;
const
mipLevel
=
computeMipLevelFromGradients
(
ddx
ddy
size
)
;
const
biasStr
=
call
.
bias
=
=
=
undefined
?
'
'
:
'
(
without
bias
)
'
;
errs
.
push
(
implicit
derivative
based
mip
level
:
{
fix5
(
mipLevel
)
}
{
biasStr
}
)
;
if
(
call
.
bias
)
{
const
clampedBias
=
clamp
(
call
.
bias
?
?
0
{
min
:
-
16
.
0
max
:
15
.
99
}
)
;
errs
.
push
(
\
clamped
bias
:
{
fix5
(
clampedBias
)
}
mip
level
with
bias
:
{
fix5
(
mipLevel
+
clampedBias
)
}
)
;
}
}
else
if
(
call
.
ddx
)
{
const
mipLevel
=
computeMipLevelFromGradientsForCall
(
call
size
)
;
errs
.
push
(
gradient
based
mip
level
:
{
mipLevel
}
)
;
}
errs
.
push
(
\
got
:
{
fix5v
(
rgbaToArray
(
gotRGBA
)
)
}
expected
:
{
fix5v
(
rgbaToArray
(
expectRGBA
)
)
}
max
diff
:
{
callSpecificMaxFractionalDiff
}
abs
diffs
:
{
fix5v
(
diffs
.
map
(
(
{
absDiff
}
)
=
>
absDiff
)
)
}
rel
diffs
:
{
diffs
.
map
(
(
{
relDiff
}
)
=
>
{
(
relDiff
*
100
)
.
toFixed
(
2
)
}
%
)
.
join
(
'
'
)
}
ulp
diffs
:
{
diffs
.
map
(
(
{
ulpDiff
}
)
=
>
ulpDiff
)
.
join
(
'
'
)
}
)
;
if
(
sampler
)
{
if
(
t
.
rec
.
debugging
)
{
if
(
isBuiltinComparison
(
call
.
builtin
)
)
{
if
(
!
haveComparisonCheckInfo
)
{
const
debugCalls
=
calls
.
map
(
call
=
>
{
const
debugCall
=
{
.
.
.
call
}
;
debugCall
.
depthRef
=
undefined
;
switch
(
call
.
builtin
)
{
case
'
textureGatherCompare
'
:
debugCall
.
builtin
=
'
textureGather
'
;
break
;
case
'
textureSampleCompare
'
:
debugCall
.
builtin
=
'
textureSample
'
;
break
;
case
'
textureSampleCompareLevel
'
:
debugCall
.
builtin
=
'
textureSampleLevel
'
;
debugCall
.
levelType
=
'
u
'
;
debugCall
.
mipLevel
=
0
;
break
;
default
:
unreachable
(
)
;
}
return
debugCall
;
}
)
;
const
debugSampler
=
{
.
.
.
sampler
}
;
delete
debugSampler
.
compare
;
const
debugRunner
=
createTextureCallsRunner
(
t
{
format
dimension
:
texture
.
descriptor
.
dimension
?
?
'
2d
'
sampleCount
:
texture
.
descriptor
.
sampleCount
?
?
1
depthOrArrayLayers
:
size
.
depthOrArrayLayers
}
texture
.
viewDescriptor
textureType
debugSampler
debugCalls
stage
)
;
checkInfo
=
{
runner
:
debugRunner
sampler
:
debugSampler
calls
:
debugCalls
}
;
haveComparisonCheckInfo
=
true
;
}
}
if
(
!
gpuTexels
&
&
gpuTexture
)
{
gpuTexels
=
await
readTextureToTexelViews
(
t
gpuTexture
texture
.
descriptor
getTexelViewFormatForTextureFormat
(
gpuTexture
.
format
)
)
;
}
const
callForSamplePoints
=
checkInfo
.
calls
[
callIdx
]
;
const
useTexelFormatForGPUTexture
=
isCompressedTextureFormat
(
texture
.
descriptor
.
format
)
;
if
(
useTexelFormatForGPUTexture
)
{
errs
.
push
(
#
#
#
WARNING
:
sample
points
are
derived
from
un
-
compressed
textures
and
may
not
match
the
actual
GPU
results
of
sampling
a
compressed
texture
.
The
test
itself
failed
at
this
point
(
see
expected
:
and
got
:
above
)
.
We
'
re
only
trying
to
determine
what
the
GPU
sampled
but
we
can
not
do
that
easily
with
compressed
textures
.
#
#
#
)
;
}
const
expectedSamplePoints
=
[
'
expected
:
'
.
.
.
(
await
identifySamplePoints
(
texture
sampler
callForSamplePoints
call
texture
.
texels
(
texels
:
TexelView
[
]
)
=
>
{
return
Promise
.
resolve
(
softwareTextureRead
(
t
stage
callForSamplePoints
{
texels
descriptor
:
texture
.
descriptor
viewDescriptor
:
texture
.
viewDescriptor
}
checkInfo
.
sampler
)
)
;
}
)
)
]
;
const
gotSamplePoints
=
[
'
got
:
'
.
.
.
(
await
identifySamplePoints
(
texture
sampler
callForSamplePoints
call
gpuTexels
async
(
texels
:
TexelView
[
]
)
=
>
{
const
descriptor
=
{
.
.
.
texture
.
descriptor
}
;
if
(
useTexelFormatForGPUTexture
)
{
descriptor
.
format
=
texels
[
0
]
.
format
;
}
const
gpuTexture
=
createTextureFromTexelViewsLocal
(
t
texels
descriptor
)
;
const
result
=
(
await
checkInfo
.
runner
.
run
(
gpuTexture
)
)
[
callIdx
]
;
gpuTexture
.
destroy
(
)
;
return
result
;
}
)
)
]
;
errs
.
push
(
'
sample
points
:
'
)
;
errs
.
push
(
layoutTwoColumns
(
expectedSamplePoints
gotSamplePoints
)
.
join
(
'
\
n
'
)
)
;
errs
.
push
(
'
'
'
'
)
;
}
if
(
!
t
.
rec
.
debugging
)
{
errs
.
push
(
'
#
#
#
turn
on
debugging
to
see
sample
points
#
#
#
'
)
;
}
}
break
;
}
}
results
.
runner
.
destroy
(
)
;
checkInfo
.
runner
.
destroy
(
)
;
return
errs
.
length
>
0
?
new
Error
(
errs
.
join
(
'
\
n
'
)
)
:
undefined
;
}
function
getMaxFractionalDiffForTextureFormat
(
format
:
GPUTextureFormat
)
{
if
(
format
.
includes
(
'
depth
'
)
)
{
return
3
/
100
;
}
else
if
(
format
.
includes
(
'
8unorm
'
)
)
{
return
7
/
255
;
}
else
if
(
format
.
includes
(
'
2unorm
'
)
)
{
return
13
/
512
;
}
else
if
(
format
.
includes
(
'
unorm
'
)
)
{
return
7
/
255
;
}
else
if
(
format
.
includes
(
'
8snorm
'
)
)
{
return
7
.
9
/
128
;
}
else
if
(
format
.
includes
(
'
snorm
'
)
)
{
return
7
.
9
/
128
;
}
else
if
(
format
.
endsWith
(
'
ufloat
'
)
)
{
return
156
.
249
;
}
else
if
(
format
.
endsWith
(
'
float
'
)
)
{
return
44
;
}
else
{
return
0
;
}
}
const
sumOfCharCodesOfString
=
(
s
:
unknown
)
=
>
String
(
s
)
.
split
(
'
'
)
.
reduce
(
(
sum
c
)
=
>
sum
+
c
.
charCodeAt
(
0
)
0
)
;
function
makeAstcBlockFiller
(
format
:
ColorTextureFormat
)
{
const
{
bytesPerBlock
}
=
getBlockInfoForColorTextureFormat
(
format
)
;
return
(
data
:
Uint8Array
offset
:
number
hashBase
:
number
)
=
>
{
data
.
set
(
[
0b1111_1100
0b1111_1101
0b1111_1111
0b1111_1111
0b1111_1111
0b1111_1111
0b1111_1111
0b1111_1111
]
offset
)
;
const
end
=
offset
+
bytesPerBlock
;
for
(
let
i
=
offset
+
8
;
i
<
end
;
+
+
i
)
{
data
[
i
]
=
hashU32
(
hashBase
i
)
;
}
}
;
}
function
makeRandomBytesBlockFiller
(
format
:
ColorTextureFormat
)
{
const
{
bytesPerBlock
}
=
getBlockInfoForColorTextureFormat
(
format
)
;
return
(
data
:
Uint8Array
offset
:
number
hashBase
:
number
)
=
>
{
const
end
=
offset
+
bytesPerBlock
;
for
(
let
i
=
offset
;
i
<
end
;
+
+
i
)
{
data
[
i
]
=
hashU32
(
hashBase
i
)
;
}
}
;
}
function
getBlockFiller
(
format
:
ColorTextureFormat
)
{
if
(
format
.
startsWith
(
'
astc
'
)
)
{
return
makeAstcBlockFiller
(
format
)
;
}
else
{
return
makeRandomBytesBlockFiller
(
format
)
;
}
}
function
fillTextureWithRandomData
(
device
:
GPUDevice
texture
:
GPUTexture
)
{
assert
(
isColorTextureFormat
(
texture
.
format
)
)
;
assert
(
!
isCompressedFloatTextureFormat
(
texture
.
format
)
)
;
const
info
=
getBlockInfoForColorTextureFormat
(
texture
.
format
as
ColorTextureFormat
)
;
const
hashBase
=
sumOfCharCodesOfString
(
texture
.
format
)
+
sumOfCharCodesOfString
(
texture
.
dimension
)
+
texture
.
width
+
texture
.
height
+
texture
.
depthOrArrayLayers
+
texture
.
mipLevelCount
;
const
bytesPerBlock
=
info
.
bytesPerBlock
;
const
fillBlock
=
getBlockFiller
(
texture
.
format
as
ColorTextureFormat
)
;
for
(
let
mipLevel
=
0
;
mipLevel
<
texture
.
mipLevelCount
;
+
+
mipLevel
)
{
const
size
=
physicalMipSizeFromTexture
(
texture
mipLevel
)
;
const
blocksAcross
=
Math
.
ceil
(
size
[
0
]
/
info
.
blockWidth
)
;
const
blocksDown
=
Math
.
ceil
(
size
[
1
]
/
info
.
blockHeight
)
;
const
bytesPerRow
=
blocksAcross
*
bytesPerBlock
;
const
bytesNeeded
=
bytesPerRow
*
blocksDown
*
size
[
2
]
;
const
data
=
new
Uint8Array
(
bytesNeeded
)
;
for
(
let
offset
=
0
;
offset
<
bytesNeeded
;
offset
+
=
bytesPerBlock
)
{
fillBlock
(
data
offset
hashBase
)
;
}
device
.
queue
.
writeTexture
(
{
texture
mipLevel
}
data
{
bytesPerRow
rowsPerImage
:
blocksDown
}
size
)
;
}
}
const
s_readTextureToRGBA32DeviceToPipeline
=
new
WeakMap
<
GPUDevice
Map
<
string
GPUComputePipeline
>
>
(
)
;
function
getEffectiveViewDimension
(
t
:
GPUTest
descriptor
:
Omit
<
GPUTextureDescriptor
'
format
'
|
'
usage
'
>
)
:
GPUTextureViewDimension
{
const
{
textureBindingViewDimension
}
=
descriptor
as
unknown
as
{
textureBindingViewDimension
?
:
GPUTextureViewDimension
;
}
;
const
size
=
reifyExtent3D
(
descriptor
.
size
)
;
return
effectiveViewDimensionForDimension
(
textureBindingViewDimension
descriptor
.
dimension
size
.
depthOrArrayLayers
)
;
}
export
async
function
readTextureToTexelViews
(
t
:
GPUTest
texture
:
GPUTexture
descriptor
:
Omit
<
GPUTextureDescriptor
'
format
'
|
'
usage
'
>
format
:
EncodableTextureFormat
)
{
const
device
=
t
.
device
;
const
viewDimensionToPipelineMap
=
s_readTextureToRGBA32DeviceToPipeline
.
get
(
device
)
?
?
new
Map
<
GPUTextureViewDimension
GPUComputePipeline
>
(
)
;
s_readTextureToRGBA32DeviceToPipeline
.
set
(
device
viewDimensionToPipelineMap
)
;
const
{
componentType
resultType
}
=
getTextureFormatTypeInfo
(
texture
.
format
)
;
const
viewDimension
=
getEffectiveViewDimension
(
t
descriptor
)
;
const
id
=
{
texture
.
format
}
:
{
viewDimension
}
:
{
texture
.
sampleCount
}
;
let
pipeline
=
viewDimensionToPipelineMap
.
get
(
id
)
;
if
(
!
pipeline
)
{
let
textureWGSL
;
let
loadWGSL
;
let
dimensionWGSL
=
'
textureDimensions
(
tex
0
)
'
;
switch
(
viewDimension
)
{
case
'
2d
'
:
if
(
texture
.
sampleCount
>
1
)
{
textureWGSL
=
texture_multisampled_2d
<
{
componentType
}
>
;
loadWGSL
=
'
textureLoad
(
tex
coord
.
xy
sampleIndex
)
'
;
dimensionWGSL
=
'
textureDimensions
(
tex
)
'
;
}
else
{
textureWGSL
=
texture_2d
<
{
componentType
}
>
;
loadWGSL
=
'
textureLoad
(
tex
coord
.
xy
0
)
'
;
}
break
;
case
'
cube
-
array
'
:
case
'
2d
-
array
'
:
textureWGSL
=
texture_2d_array
<
{
componentType
}
>
;
loadWGSL
=
textureLoad
(
tex
coord
.
xy
coord
.
z
0
)
;
break
;
case
'
3d
'
:
textureWGSL
=
texture_3d
<
{
componentType
}
>
;
loadWGSL
=
'
textureLoad
(
tex
coord
.
xyz
0
)
'
;
break
;
case
'
cube
'
:
textureWGSL
=
texture_cube
<
{
componentType
}
>
;
loadWGSL
=
textureLoadCubeAs2DArray
(
tex
coord
.
xy
coord
.
z
)
;
;
break
;
case
'
1d
'
:
textureWGSL
=
texture_1d
<
{
componentType
}
>
;
loadWGSL
=
textureLoad
(
tex
coord
.
x
0
)
;
dimensionWGSL
=
vec2u
(
textureDimensions
(
tex
)
1
)
;
break
;
default
:
unreachable
(
unsupported
view
:
{
viewDimension
}
)
;
}
const
textureLoadCubeWGSL
=
const
faceMat
=
array
(
mat3x3f
(
0
0
-
2
0
-
2
0
1
1
1
)
/
/
pos
-
x
mat3x3f
(
0
0
2
0
-
2
0
-
1
1
-
1
)
/
/
neg
-
x
mat3x3f
(
2
0
0
0
0
2
-
1
1
-
1
)
/
/
pos
-
y
mat3x3f
(
2
0
0
0
0
-
2
-
1
-
1
1
)
/
/
neg
-
y
mat3x3f
(
2
0
0
0
-
2
0
-
1
1
1
)
/
/
pos
-
z
mat3x3f
(
-
2
0
0
0
-
2
0
1
1
-
1
)
)
;
/
/
neg
-
z
/
/
needed
for
compat
mode
.
fn
textureLoadCubeAs2DArray
(
tex
:
texture_cube
<
{
componentType
}
>
coord
:
vec2u
layer
:
u32
)
-
>
{
resultType
}
{
/
/
convert
texel
coord
normalized
coord
let
size
=
textureDimensions
(
tex
0
)
;
/
/
Offset
by
0
.
75
instead
of
the
more
common
0
.
5
for
converting
from
texel
to
normalized
texture
coordinate
/
/
because
we
'
re
using
textureGather
.
0
.
5
would
indicate
the
center
of
a
texel
but
based
on
precision
issues
/
/
the
"
gather
"
could
go
in
any
direction
from
that
center
.
Off
center
it
should
go
in
an
expected
direction
.
let
uv
=
(
vec2f
(
coord
)
+
0
.
75
)
/
vec2f
(
size
.
xy
)
;
/
/
convert
uv
+
layer
into
cube
coord
let
cubeCoord
=
faceMat
[
layer
]
*
vec3f
(
uv
1
.
0
)
;
/
/
We
have
to
use
textureGather
as
it
'
s
the
only
texture
builtin
that
works
on
cubemaps
/
/
with
integer
texture
formats
.
let
r
=
textureGather
(
0
tex
smp
cubeCoord
)
;
let
g
=
textureGather
(
1
tex
smp
cubeCoord
)
;
let
b
=
textureGather
(
2
tex
smp
cubeCoord
)
;
let
a
=
textureGather
(
3
tex
smp
cubeCoord
)
;
/
/
element
3
is
the
texel
corresponding
to
cubeCoord
return
{
resultType
}
(
r
[
3
]
g
[
3
]
b
[
3
]
a
[
3
]
)
;
}
;
const
module
=
device
.
createShaderModule
(
{
code
:
{
isViewDimensionCubeOrCubeArray
(
viewDimension
)
?
textureLoadCubeWGSL
:
'
'
}
struct
Uniforms
{
sampleCount
:
u32
}
;
group
(
0
)
binding
(
0
)
var
<
uniform
>
uni
:
Uniforms
;
group
(
0
)
binding
(
1
)
var
tex
:
{
textureWGSL
}
;
group
(
0
)
binding
(
2
)
var
smp
:
sampler
;
group
(
0
)
binding
(
3
)
var
<
storage
read_write
>
data
:
array
<
{
resultType
}
>
;
compute
workgroup_size
(
1
)
fn
cs
(
builtin
(
global_invocation_id
)
global_invocation_id
:
vec3
<
u32
>
)
{
_
=
smp
;
let
size
=
{
dimensionWGSL
}
;
let
ndx
=
global_invocation_id
.
z
*
size
.
x
*
size
.
y
*
uni
.
sampleCount
+
global_invocation_id
.
y
*
size
.
x
*
uni
.
sampleCount
+
global_invocation_id
.
x
;
let
coord
=
vec3u
(
global_invocation_id
.
x
/
uni
.
sampleCount
global_invocation_id
.
yz
)
;
let
sampleIndex
=
global_invocation_id
.
x
%
uni
.
sampleCount
;
data
[
ndx
]
=
{
loadWGSL
}
;
}
}
)
;
const
type
=
getTextureFormatType
(
texture
.
format
)
;
const
sampleType
=
isDepthTextureFormat
(
texture
.
format
)
?
'
unfilterable
-
float
'
:
isStencilTextureFormat
(
texture
.
format
)
?
'
uint
'
:
type
=
=
=
'
float
'
?
'
unfilterable
-
float
'
:
type
;
const
bindGroupLayout
=
device
.
createBindGroupLayout
(
{
entries
:
[
{
binding
:
0
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
uniform
'
}
}
{
binding
:
1
visibility
:
GPUShaderStage
.
COMPUTE
texture
:
{
sampleType
viewDimension
multisampled
:
texture
.
sampleCount
>
1
}
}
{
binding
:
2
visibility
:
GPUShaderStage
.
COMPUTE
sampler
:
{
type
:
'
non
-
filtering
'
}
}
{
binding
:
3
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
]
}
)
;
const
layout
=
device
.
createPipelineLayout
(
{
bindGroupLayouts
:
[
bindGroupLayout
]
}
)
;
pipeline
=
device
.
createComputePipeline
(
{
layout
compute
:
{
module
}
}
)
;
viewDimensionToPipelineMap
.
set
(
id
pipeline
)
;
}
const
encoder
=
device
.
createCommandEncoder
(
)
;
const
readBuffers
=
[
]
;
for
(
let
mipLevel
=
0
;
mipLevel
<
texture
.
mipLevelCount
;
+
+
mipLevel
)
{
const
size
=
virtualMipSize
(
texture
.
dimension
texture
mipLevel
)
;
const
uniformValues
=
new
Uint32Array
(
[
texture
.
sampleCount
0
0
0
]
)
;
const
uniformBuffer
=
t
.
createBufferTracked
(
{
size
:
uniformValues
.
byteLength
usage
:
GPUBufferUsage
.
UNIFORM
|
GPUBufferUsage
.
COPY_DST
}
)
;
device
.
queue
.
writeBuffer
(
uniformBuffer
0
uniformValues
)
;
const
storageBuffer
=
t
.
createBufferTracked
(
{
size
:
size
[
0
]
*
size
[
1
]
*
size
[
2
]
*
4
*
4
*
texture
.
sampleCount
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_SRC
}
)
;
const
readBuffer
=
t
.
createBufferTracked
(
{
size
:
storageBuffer
.
size
usage
:
GPUBufferUsage
.
MAP_READ
|
GPUBufferUsage
.
COPY_DST
}
)
;
readBuffers
.
push
(
{
size
readBuffer
}
)
;
const
sampler
=
device
.
createSampler
(
)
;
const
aspect
=
getAspectForTexture
(
texture
)
;
const
bindGroup
=
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
uniformBuffer
}
}
{
binding
:
1
resource
:
texture
.
createView
(
{
dimension
:
viewDimension
aspect
baseMipLevel
:
mipLevel
mipLevelCount
:
1
}
)
}
{
binding
:
2
resource
:
sampler
}
{
binding
:
3
resource
:
{
buffer
:
storageBuffer
}
}
]
}
)
;
const
pass
=
encoder
.
beginComputePass
(
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
bindGroup
)
;
pass
.
dispatchWorkgroups
(
size
[
0
]
*
texture
.
sampleCount
size
[
1
]
size
[
2
]
)
;
pass
.
end
(
)
;
encoder
.
copyBufferToBuffer
(
storageBuffer
0
readBuffer
0
readBuffer
.
size
)
;
}
device
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
const
texelViews
:
TexelView
[
]
=
[
]
;
for
(
const
{
readBuffer
size
}
of
readBuffers
)
{
await
readBuffer
.
mapAsync
(
GPUMapMode
.
READ
)
;
const
Ctor
=
componentType
=
=
=
'
i32
'
?
Int32Array
:
componentType
=
=
=
'
u32
'
?
Uint32Array
:
Float32Array
;
const
data
=
new
Ctor
(
readBuffer
.
getMappedRange
(
)
)
.
slice
(
)
;
readBuffer
.
unmap
(
)
;
const
{
sampleCount
}
=
texture
;
texelViews
.
push
(
TexelView
.
fromTexelsAsColors
(
format
coord
=
>
{
const
offset
=
(
(
coord
.
z
*
size
[
0
]
*
size
[
1
]
+
coord
.
y
*
size
[
0
]
+
coord
.
x
)
*
sampleCount
+
(
coord
.
sampleIndex
?
?
0
)
)
*
4
;
return
convertResultFormatToTexelViewFormat
(
{
R
:
data
[
offset
+
0
]
G
:
data
[
offset
+
1
]
B
:
data
[
offset
+
2
]
A
:
data
[
offset
+
3
]
}
format
)
;
}
)
)
;
}
return
texelViews
;
}
function
createTextureFromTexelViewsLocal
(
t
:
GPUTest
texelViews
:
TexelView
[
]
desc
:
GPUTextureDescriptor
)
:
GPUTexture
{
const
modifiedDescriptor
=
{
.
.
.
desc
}
;
if
(
isDepthOrStencilTextureFormat
(
desc
.
format
)
|
|
desc
.
sampleCount
!
>
1
)
{
modifiedDescriptor
.
usage
=
desc
.
usage
|
GPUTextureUsage
.
RENDER_ATTACHMENT
;
}
return
createTextureFromTexelViews
(
t
texelViews
modifiedDescriptor
)
;
}
export
async
function
createTextureWithRandomDataAndGetTexels
(
t
:
GPUTest
descriptor
:
GPUTextureDescriptor
options
?
:
RandomTextureOptions
)
{
if
(
isCompressedTextureFormat
(
descriptor
.
format
)
)
{
assert
(
!
options
'
options
not
supported
for
compressed
textures
'
)
;
const
texture
=
t
.
createTextureTracked
(
descriptor
)
;
fillTextureWithRandomData
(
t
.
device
texture
)
;
const
texels
=
await
readTextureToTexelViews
(
t
texture
descriptor
getTexelViewFormatForTextureFormat
(
texture
.
format
)
)
;
return
{
texture
texels
}
;
}
else
if
(
isUnencodableDepthFormat
(
descriptor
.
format
)
)
{
const
d32Descriptor
=
{
.
.
.
descriptor
format
:
'
depth32float
'
as
GPUTextureFormat
}
;
const
tempTexels
=
createRandomTexelViewMipmap
(
d32Descriptor
options
)
;
const
texture
=
createTextureFromTexelViewsLocal
(
t
tempTexels
descriptor
)
;
const
texels
=
await
readTextureToTexelViews
(
t
texture
descriptor
getTexelViewFormatForTextureFormat
(
texture
.
format
)
)
;
return
{
texture
texels
}
;
}
else
{
const
texels
=
createRandomTexelViewMipmap
(
descriptor
options
)
;
const
texture
=
createTextureFromTexelViewsLocal
(
t
texels
descriptor
)
;
return
{
texture
texels
}
;
}
}
function
valueIfAllComponentsAreEqual
(
c
:
PerTexelComponent
<
number
>
componentOrder
:
readonly
TexelComponent
[
]
)
{
const
s
=
new
Set
(
componentOrder
.
map
(
component
=
>
c
[
component
]
!
)
)
;
return
s
.
size
=
=
=
1
?
s
.
values
(
)
.
next
(
)
.
value
:
undefined
;
}
export
function
createVideoFrameWithRandomDataAndGetTexels
(
textureSize
:
GPUExtent3D
)
{
const
size
=
reifyExtent3D
(
textureSize
)
;
assert
(
size
.
depthOrArrayLayers
=
=
=
1
)
;
const
imageData
=
new
ImageData
(
size
.
width
size
.
height
)
;
const
data
=
imageData
.
data
;
const
asU32
=
new
Uint32Array
(
data
.
buffer
)
;
for
(
let
i
=
0
;
i
<
asU32
.
length
;
+
+
i
)
{
asU32
[
i
]
=
hashU32
(
i
)
;
}
const
canvas
=
new
OffscreenCanvas
(
size
.
width
size
.
height
)
;
const
ctx
=
canvas
.
getContext
(
'
2d
'
)
!
;
ctx
.
putImageData
(
imageData
0
0
)
;
const
videoFrame
=
new
VideoFrame
(
canvas
{
timestamp
:
0
}
)
;
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
=
4
)
{
const
alpha
=
data
[
i
+
3
]
/
255
;
data
[
i
+
0
]
=
data
[
i
+
0
]
*
alpha
;
data
[
i
+
1
]
=
data
[
i
+
1
]
*
alpha
;
data
[
i
+
2
]
=
data
[
i
+
2
]
*
alpha
;
}
const
texels
=
[
TexelView
.
fromTextureDataByReference
(
'
rgba8unorm
'
data
{
bytesPerRow
:
size
.
width
*
4
rowsPerImage
:
size
.
height
subrectOrigin
:
[
0
0
0
]
subrectSize
:
size
}
)
]
;
return
{
videoFrame
texels
}
;
}
const
kFaceNames
=
[
'
+
x
'
'
-
x
'
'
+
y
'
'
-
y
'
'
+
z
'
'
-
z
'
]
as
const
;
async
function
identifySamplePoints
<
T
extends
Dimensionality
>
(
texture
:
Texture
sampler
:
GPUSamplerDescriptor
callForSamples
:
TextureCall
<
T
>
originalCall
:
TextureCall
<
T
>
texels
:
TexelView
[
]
|
undefined
run
:
(
texels
:
TexelView
[
]
)
=
>
Promise
<
PerTexelComponent
<
number
>
>
)
{
const
info
=
texture
.
descriptor
;
const
isCube
=
isCubeViewDimension
(
texture
.
viewDescriptor
)
;
const
mipLevelCount
=
texture
.
descriptor
.
mipLevelCount
?
?
1
;
const
mipLevelSize
=
range
(
mipLevelCount
mipLevel
=
>
virtualMipSize
(
texture
.
descriptor
.
dimension
?
?
'
2d
'
texture
.
descriptor
.
size
mipLevel
)
)
;
const
numTexelsPerLevel
=
mipLevelSize
.
map
(
size
=
>
size
.
reduce
(
(
s
v
)
=
>
s
*
v
)
)
;
const
numTexelsOfPrecedingLevels
=
(
(
)
=
>
{
let
total
=
0
;
return
numTexelsPerLevel
.
map
(
v
=
>
{
const
num
=
total
;
total
+
=
v
;
return
num
;
}
)
;
}
)
(
)
;
const
numTexels
=
numTexelsPerLevel
.
reduce
(
(
sum
v
)
=
>
sum
+
v
)
;
const
getMipLevelFromTexelId
=
(
texelId
:
number
)
=
>
{
for
(
let
mipLevel
=
mipLevelCount
-
1
;
mipLevel
>
0
;
-
-
mipLevel
)
{
if
(
texelId
-
numTexelsOfPrecedingLevels
[
mipLevel
]
>
=
0
)
{
return
mipLevel
;
}
}
return
0
;
}
;
const
getTexelCoordFromTexelId
=
(
texelId
:
number
)
=
>
{
const
mipLevel
=
getMipLevelFromTexelId
(
texelId
)
;
const
size
=
mipLevelSize
[
mipLevel
]
;
const
texelsPerSlice
=
size
[
0
]
*
size
[
1
]
;
const
id
=
texelId
-
numTexelsOfPrecedingLevels
[
mipLevel
]
;
const
layer
=
Math
.
floor
(
id
/
texelsPerSlice
)
;
const
xyId
=
id
-
layer
*
texelsPerSlice
;
const
y
=
(
xyId
/
size
[
0
]
)
|
0
;
const
x
=
xyId
%
size
[
0
]
;
return
{
x
y
z
:
layer
mipLevel
xyId
}
;
}
;
const
format
=
(
kEncodableTextureFormats
.
includes
(
info
.
format
as
EncodableTextureFormat
)
?
info
.
format
:
isDepthTextureFormat
(
info
.
format
)
?
'
depth16unorm
'
:
'
rgba8unorm
'
)
as
EncodableTextureFormat
;
const
rep
=
kTexelRepresentationInfo
[
format
]
;
const
components
=
isBuiltinGather
(
callForSamples
.
builtin
)
?
kRGBAComponents
:
rep
.
componentOrder
;
const
convertResultAsAppropriate
=
isBuiltinGather
(
callForSamples
.
builtin
)
?
<
T
>
(
v
:
T
)
=
>
v
:
convertResultFormatToTexelViewFormat
;
const
sampledTexelWeights
=
new
Map
<
number
PerTexelComponent
<
number
>
>
(
)
;
const
unclassifiedStack
=
[
new
Set
<
number
>
(
range
(
numTexels
v
=
>
v
)
)
]
;
while
(
unclassifiedStack
.
length
>
0
)
{
const
unclassified
=
unclassifiedStack
.
pop
(
)
!
;
const
setA
=
new
Set
<
number
>
(
)
;
const
setB
=
new
Set
<
number
>
(
)
;
[
.
.
.
unclassified
.
keys
(
)
]
.
forEach
(
(
t
i
)
=
>
(
(
i
&
1
)
=
=
=
0
?
setA
:
setB
)
.
add
(
t
)
)
;
if
(
setB
.
size
>
0
)
{
unclassifiedStack
.
push
(
setB
)
;
}
const
results
=
convertResultAsAppropriate
(
await
run
(
range
(
mipLevelCount
mipLevel
=
>
TexelView
.
fromTexelsAsColors
(
format
(
coords
:
Required
<
GPUOrigin3DDict
>
)
:
Readonly
<
PerTexelComponent
<
number
>
>
=
>
{
const
size
=
mipLevelSize
[
mipLevel
]
;
const
texelsPerSlice
=
size
[
0
]
*
size
[
1
]
;
const
texelsPerRow
=
size
[
0
]
;
const
texelId
=
numTexelsOfPrecedingLevels
[
mipLevel
]
+
coords
.
x
+
coords
.
y
*
texelsPerRow
+
coords
.
z
*
texelsPerSlice
;
const
isCandidate
=
setA
.
has
(
texelId
)
;
const
texel
:
PerTexelComponent
<
number
>
=
{
}
;
for
(
const
component
of
rep
.
componentOrder
)
{
texel
[
component
]
=
isCandidate
?
1
:
0
;
}
return
texel
;
}
)
)
)
format
)
;
if
(
components
.
some
(
c
=
>
results
[
c
]
!
=
=
0
)
)
{
if
(
setA
.
size
=
=
=
1
)
{
setA
.
forEach
(
texel
=
>
sampledTexelWeights
.
set
(
texel
results
)
)
;
}
else
{
unclassifiedStack
.
push
(
setA
)
;
}
}
}
const
levels
:
Map
<
number
PerTexelComponent
<
number
>
>
[
]
[
]
=
[
]
;
for
(
const
[
texelId
weight
]
of
sampledTexelWeights
.
entries
(
)
)
{
const
{
xyId
z
mipLevel
}
=
getTexelCoordFromTexelId
(
texelId
)
;
const
level
=
levels
[
mipLevel
]
?
?
[
]
;
levels
[
mipLevel
]
=
level
;
const
layerEntries
=
level
[
z
]
?
?
new
Map
(
)
;
level
[
z
]
=
layerEntries
;
layerEntries
.
set
(
xyId
weight
)
;
}
const
blockParts
=
{
top
:
{
left
:
'
'
fill
:
'
'
right
:
'
'
block
:
'
'
texel
:
'
'
}
mid
:
{
left
:
'
'
fill
:
'
'
right
:
'
'
block
:
'
'
texel
:
'
'
}
bot
:
{
left
:
'
'
fill
:
'
'
right
:
'
'
block
:
'
'
texel
:
'
'
}
texelMid
:
{
left
:
'
'
fill
:
'
'
right
:
'
'
block
:
'
'
texel
:
'
'
}
value
:
{
left
:
'
'
fill
:
'
'
right
:
'
'
block
:
'
'
texel
:
'
'
}
}
as
const
;
const
nonBlockParts
=
{
top
:
{
left
:
'
'
fill
:
'
'
right
:
'
'
block
:
'
'
texel
:
'
'
}
mid
:
{
left
:
'
'
fill
:
'
'
right
:
'
'
block
:
'
'
texel
:
'
'
}
bot
:
{
left
:
'
'
fill
:
'
'
right
:
'
'
block
:
'
'
texel
:
'
'
}
texelMid
:
{
left
:
'
'
fill
:
'
'
right
:
'
'
block
:
'
'
texel
:
'
'
}
value
:
{
left
:
'
'
fill
:
'
'
right
:
'
'
block
:
'
'
texel
:
'
'
}
}
as
const
;
const
lines
:
string
[
]
=
[
]
;
const
letter
=
(
idx
:
number
)
=
>
String
.
fromCodePoint
(
idx
<
30
?
97
+
idx
:
idx
+
9600
-
30
)
;
let
idCount
=
0
;
const
{
blockWidth
blockHeight
}
=
getBlockInfoForTextureFormat
(
texture
.
descriptor
.
format
)
;
const
rangeCat
=
<
T
>
(
num
:
number
fn
:
(
i
:
number
)
=
>
T
)
=
>
range
(
num
fn
)
.
join
(
'
'
)
;
const
joinFn
=
(
arr
:
string
[
]
fn
:
(
i
:
number
)
=
>
string
)
=
>
{
const
joins
=
range
(
arr
.
length
-
1
fn
)
;
return
arr
.
map
(
(
s
i
)
=
>
{
s
}
{
joins
[
i
]
?
?
'
'
}
)
.
join
(
'
'
)
;
}
;
const
parts
=
Math
.
max
(
blockWidth
blockHeight
)
>
1
?
blockParts
:
nonBlockParts
;
const
makeRow
=
(
blockPaddedWidth
:
number
width
:
number
{
left
fill
right
block
texel
}
:
{
left
:
string
;
fill
:
string
;
right
:
string
;
block
:
string
;
texel
:
string
;
}
contents
?
:
string
[
]
)
=
>
{
return
{
left
}
{
joinFn
(
contents
?
?
range
(
blockPaddedWidth
x
=
>
fill
)
x
=
>
{
return
(
x
+
1
)
%
blockWidth
=
=
=
0
?
block
:
texel
;
}
)
}
{
right
}
;
}
;
for
(
let
mipLevel
=
0
;
mipLevel
<
mipLevelCount
;
+
+
mipLevel
)
{
const
level
=
levels
[
mipLevel
]
;
if
(
!
level
)
{
continue
;
}
const
[
width
height
depthOrArrayLayers
]
=
mipLevelSize
[
mipLevel
]
;
const
texelsPerRow
=
width
;
for
(
let
layer
=
0
;
layer
<
depthOrArrayLayers
;
+
+
layer
)
{
const
layerEntries
=
level
[
layer
]
;
const
orderedTexelIndices
:
number
[
]
=
[
]
;
lines
.
push
(
'
'
)
;
const
unSampled
=
layerEntries
?
'
'
:
'
un
-
sampled
'
;
if
(
isCube
)
{
const
face
=
kFaceNames
[
layer
%
6
]
;
lines
.
push
(
layer
:
{
layer
}
mip
(
{
mipLevel
}
)
cube
-
layer
:
{
(
layer
/
6
)
|
0
}
(
{
face
}
)
{
unSampled
}
)
;
}
else
{
lines
.
push
(
layer
:
{
layer
}
mip
(
{
mipLevel
}
)
{
unSampled
}
)
;
}
if
(
!
layerEntries
)
{
continue
;
}
const
blockPaddedHeight
=
align
(
height
blockHeight
)
;
const
blockPaddedWidth
=
align
(
width
blockWidth
)
;
lines
.
push
(
{
rangeCat
(
width
x
=
>
{
x
.
toString
(
)
.
padEnd
(
2
)
}
)
}
)
;
lines
.
push
(
{
makeRow
(
blockPaddedWidth
width
parts
.
top
)
}
)
;
for
(
let
y
=
0
;
y
<
blockPaddedHeight
;
y
+
+
)
{
lines
.
push
(
{
y
.
toString
(
)
.
padStart
(
2
)
}
{
makeRow
(
blockPaddedWidth
width
parts
.
value
range
(
blockPaddedWidth
x
=
>
{
const
texelIdx
=
x
+
y
*
texelsPerRow
;
const
weight
=
layerEntries
.
get
(
texelIdx
)
;
const
outside
=
y
>
=
height
|
|
x
>
=
width
;
if
(
outside
|
|
weight
=
=
=
undefined
)
{
return
outside
?
'
'
:
'
'
;
}
else
{
const
id
=
letter
(
idCount
+
orderedTexelIndices
.
length
)
;
orderedTexelIndices
.
push
(
texelIdx
)
;
return
{
id
}
;
}
}
)
)
}
)
;
const
end
=
y
<
blockPaddedHeight
-
1
;
const
lineParts
=
end
?
(
y
+
1
)
%
blockHeight
=
=
=
0
?
parts
.
mid
:
parts
.
texelMid
:
parts
.
bot
;
lines
.
push
(
{
makeRow
(
blockPaddedWidth
width
lineParts
)
}
)
;
}
const
pad2
=
(
n
:
number
)
=
>
n
.
toString
(
)
.
padStart
(
2
)
;
const
pad3
=
(
n
:
number
)
=
>
n
.
toString
(
)
.
padStart
(
3
)
;
const
fix5
=
(
n
:
number
)
=
>
{
const
s
=
n
.
toFixed
(
5
)
;
return
s
=
=
=
'
0
.
00000
'
&
&
n
!
=
=
0
?
n
.
toString
(
)
:
s
;
}
;
const
formatValue
=
isSintOrUintFormat
(
format
)
?
pad3
:
fix5
;
const
formatTexel
=
(
texel
:
PerTexelComponent
<
number
>
|
undefined
)
=
>
texel
?
Object
.
entries
(
texel
)
.
map
(
(
[
k
v
]
)
=
>
{
k
}
:
{
formatValue
(
v
)
}
)
.
join
(
'
'
)
:
'
*
texel
values
unavailable
*
'
;
const
colorLines
:
string
[
]
=
[
]
;
const
compareLines
:
string
[
]
=
[
]
;
let
levelWeight
=
0
;
orderedTexelIndices
.
forEach
(
(
texelIdx
i
)
=
>
{
const
weights
=
layerEntries
.
get
(
texelIdx
)
!
;
const
y
=
Math
.
floor
(
texelIdx
/
texelsPerRow
)
;
const
x
=
texelIdx
%
texelsPerRow
;
const
singleWeight
=
valueIfAllComponentsAreEqual
(
weights
components
)
!
;
levelWeight
+
=
singleWeight
;
const
w
=
singleWeight
!
=
=
undefined
?
weight
:
{
fix5
(
singleWeight
)
}
:
weights
:
[
{
components
.
map
(
c
=
>
{
c
}
:
{
fix5
(
weights
[
c
]
!
)
}
)
.
join
(
'
'
)
}
]
;
const
coord
=
{
pad2
(
x
)
}
{
pad2
(
y
)
}
{
pad2
(
layer
)
}
;
const
texel
=
texels
&
&
convertToTexelViewFormat
(
texels
[
mipLevel
]
.
color
(
{
x
y
z
:
layer
}
)
texture
.
descriptor
.
format
)
;
const
texelStr
=
formatTexel
(
texel
)
;
const
id
=
letter
(
idCount
+
i
)
;
lines
.
push
(
{
id
}
:
mip
(
{
mipLevel
}
)
at
:
[
{
coord
}
]
{
w
}
)
;
colorLines
.
push
(
{
id
}
:
value
:
{
texelStr
}
)
;
if
(
isBuiltinComparison
(
originalCall
.
builtin
)
)
{
assert
(
!
!
texel
)
;
const
compareTexel
=
applyCompare
(
originalCall
sampler
[
TexelComponent
.
Depth
]
texel
)
;
compareLines
.
push
(
{
id
}
:
compare
(
{
sampler
.
compare
}
)
result
with
depthRef
(
{
fix5
(
originalCall
.
depthRef
!
)
}
)
:
{
fix5
(
compareTexel
.
Depth
!
)
}
)
;
}
}
)
;
lines
.
push
(
.
.
.
colorLines
)
;
lines
.
push
(
.
.
.
compareLines
)
;
if
(
!
isNaN
(
levelWeight
)
)
{
lines
.
push
(
mip
level
(
{
mipLevel
}
)
weight
:
{
fix5
(
levelWeight
)
}
)
;
}
idCount
+
=
orderedTexelIndices
.
length
;
}
}
return
lines
;
}
function
layoutTwoColumns
(
columnA
:
string
[
]
columnB
:
string
[
]
)
{
const
widthA
=
Math
.
max
(
.
.
.
columnA
.
map
(
l
=
>
l
.
length
)
)
;
const
lines
=
Math
.
max
(
columnA
.
length
columnB
.
length
)
;
const
out
:
string
[
]
=
new
Array
<
string
>
(
lines
)
;
for
(
let
line
=
0
;
line
<
lines
;
line
+
+
)
{
const
a
=
columnA
[
line
]
?
?
'
'
;
const
b
=
columnB
[
line
]
?
?
'
'
;
out
[
line
]
=
{
a
}
{
'
'
.
repeat
(
widthA
-
a
.
length
)
}
|
{
b
}
;
}
return
out
;
}
export
function
getDepthOrArrayLayersForViewDimension
(
viewDimension
?
:
GPUTextureViewDimension
)
{
switch
(
viewDimension
)
{
case
'
1d
'
:
return
1
;
case
undefined
:
case
'
2d
'
:
return
1
;
case
'
2d
-
array
'
:
return
4
;
case
'
3d
'
:
return
8
;
case
'
cube
'
:
return
6
;
default
:
unreachable
(
)
;
}
}
export
function
chooseTextureSize
(
{
minSize
minBlocks
format
viewDimension
}
:
{
minSize
:
number
;
minBlocks
:
number
;
format
:
GPUTextureFormat
;
viewDimension
?
:
GPUTextureViewDimension
;
}
)
{
const
{
blockWidth
blockHeight
}
=
getBlockInfoForTextureFormat
(
format
)
;
const
width
=
align
(
Math
.
max
(
minSize
blockWidth
*
minBlocks
)
blockWidth
)
;
const
height
=
viewDimension
=
=
=
'
1d
'
?
1
:
align
(
Math
.
max
(
minSize
blockHeight
*
minBlocks
)
blockHeight
)
;
if
(
viewDimension
=
=
=
'
cube
'
|
|
viewDimension
=
=
=
'
cube
-
array
'
)
{
const
blockLCM
=
lcm
(
blockWidth
blockHeight
)
;
const
largest
=
Math
.
max
(
width
height
)
;
const
size
=
align
(
largest
blockLCM
)
;
return
[
size
size
viewDimension
=
=
=
'
cube
-
array
'
?
24
:
6
]
;
}
const
depthOrArrayLayers
=
getDepthOrArrayLayersForViewDimension
(
viewDimension
)
;
return
[
width
height
depthOrArrayLayers
]
;
}
export
const
kSamplePointMethods
=
[
'
texel
-
centre
'
'
spiral
'
]
as
const
;
export
type
SamplePointMethods
=
(
typeof
kSamplePointMethods
)
[
number
]
;
export
const
kCubeSamplePointMethods
=
[
'
cube
-
edges
'
'
texel
-
centre
'
'
spiral
'
]
as
const
;
export
type
CubeSamplePointMethods
=
(
typeof
kSamplePointMethods
)
[
number
]
;
type
TextureBuiltinInputArgs
=
{
textureBuiltin
?
:
TextureBuiltin
;
descriptor
:
GPUTextureDescriptor
;
sampler
?
:
GPUSamplerDescriptor
;
derivatives
?
:
boolean
;
mipLevel
?
:
RangeDef
;
sampleIndex
?
:
RangeDef
;
arrayIndex
?
:
RangeDef
;
grad
?
:
boolean
;
bias
?
:
boolean
;
component
?
:
boolean
;
depthRef
?
:
boolean
;
offset
?
:
boolean
;
hashInputs
:
(
number
|
string
|
boolean
)
[
]
;
}
;
function
generateTextureBuiltinInputsImpl
<
T
extends
Dimensionality
>
(
makeValue
:
(
x
:
number
y
:
number
z
:
number
)
=
>
T
n
:
number
args
:
|
(
TextureBuiltinInputArgs
&
{
method
:
'
texel
-
centre
'
;
}
)
|
(
TextureBuiltinInputArgs
&
{
method
:
'
spiral
'
;
radius
?
:
number
;
loops
?
:
number
;
}
)
)
:
{
coords
:
T
;
derivativeMult
?
:
T
;
ddx
?
:
T
;
ddy
?
:
T
;
mipLevel
:
number
;
sampleIndex
?
:
number
;
arrayIndex
?
:
number
;
bias
?
:
number
;
offset
?
:
T
;
component
?
:
number
;
depthRef
?
:
number
;
}
[
]
{
const
{
method
descriptor
}
=
args
;
const
dimension
=
descriptor
.
dimension
?
?
'
2d
'
;
const
mipLevelCount
=
descriptor
.
mipLevelCount
?
?
1
;
const
size
=
virtualMipSize
(
dimension
descriptor
.
size
0
)
;
const
coords
:
T
[
]
=
[
]
;
switch
(
method
)
{
case
'
texel
-
centre
'
:
{
for
(
let
i
=
0
;
i
<
n
;
i
+
+
)
{
const
r
=
hashU32
(
i
)
;
const
x
=
Math
.
floor
(
lerp
(
0
size
[
0
]
-
1
(
r
&
0xff
)
/
0xff
)
)
+
0
.
5
;
const
y
=
Math
.
floor
(
lerp
(
0
size
[
1
]
-
1
(
(
r
>
>
8
)
&
0xff
)
/
0xff
)
)
+
0
.
5
;
const
z
=
Math
.
floor
(
lerp
(
0
size
[
2
]
-
1
(
(
r
>
>
16
)
&
0xff
)
/
0xff
)
)
+
0
.
5
;
coords
.
push
(
makeValue
(
x
/
size
[
0
]
y
/
size
[
1
]
z
/
size
[
2
]
)
)
;
}
break
;
}
case
'
spiral
'
:
{
const
{
radius
=
1
.
5
loops
=
2
}
=
args
;
for
(
let
i
=
0
;
i
<
n
;
i
+
+
)
{
const
f
=
i
/
(
Math
.
max
(
n
2
)
-
1
)
;
const
r
=
radius
*
f
;
const
a
=
loops
*
2
*
Math
.
PI
*
f
;
coords
.
push
(
makeValue
(
0
.
5
+
r
*
Math
.
cos
(
a
)
0
.
5
+
r
*
Math
.
sin
(
a
)
0
)
)
;
}
break
;
}
}
const
_hashInputs
=
args
.
hashInputs
.
map
(
v
=
>
typeof
v
=
=
=
'
string
'
?
sumOfCharCodesOfString
(
v
)
:
typeof
v
=
=
=
'
boolean
'
?
(
v
?
1
:
0
)
:
v
)
;
const
makeRandValue
=
(
{
num
type
}
:
RangeDef
.
.
.
hashInputs
:
number
[
]
)
=
>
{
const
range
=
num
;
const
number
=
(
hashU32
(
.
.
.
_hashInputs
.
.
.
hashInputs
)
/
0x1_0000_0000
)
*
range
;
return
type
=
=
=
'
f32
'
?
number
:
Math
.
floor
(
number
)
;
}
;
const
makeRangeValue
=
(
{
num
type
}
:
RangeDef
.
.
.
hashInputs
:
number
[
]
)
=
>
{
const
range
=
num
+
(
type
=
=
=
'
u32
'
?
1
:
2
)
;
const
number
=
(
hashU32
(
.
.
.
_hashInputs
.
.
.
hashInputs
)
/
0x1_0000_0000
)
*
range
-
(
type
=
=
=
'
u32
'
?
0
:
1
)
;
return
type
=
=
=
'
f32
'
?
number
:
Math
.
floor
(
number
)
;
}
;
const
makeIntHashValueRepeatable
=
(
min
:
number
max
:
number
.
.
.
hashInputs
:
number
[
]
)
=
>
{
const
range
=
max
-
min
;
return
min
+
Math
.
floor
(
(
hashU32
(
.
.
.
hashInputs
)
/
0x1_0000_0000
)
*
range
)
;
}
;
const
kSubdivisionsPerTexel
=
4
;
const
avoidEdgeCase
=
!
args
.
sampler
|
|
args
.
sampler
.
minFilter
=
=
=
'
nearest
'
|
|
isBuiltinGather
(
args
.
textureBuiltin
)
;
const
edgeRemainder
=
isBuiltinGather
(
args
.
textureBuiltin
)
?
kSubdivisionsPerTexel
/
2
:
0
;
const
euclideanModulo
=
(
n
:
number
m
:
number
)
=
>
(
(
n
%
m
)
+
m
)
%
m
;
const
addressMode
:
GPUAddressMode
[
]
=
args
.
textureBuiltin
=
=
=
'
textureSampleBaseClampToEdge
'
?
[
'
clamp
-
to
-
edge
'
'
clamp
-
to
-
edge
'
'
clamp
-
to
-
edge
'
]
:
[
args
.
sampler
?
.
addressModeU
?
?
'
clamp
-
to
-
edge
'
args
.
sampler
?
.
addressModeV
?
?
'
clamp
-
to
-
edge
'
args
.
sampler
?
.
addressModeW
?
?
'
clamp
-
to
-
edge
'
]
;
const
avoidTextureEdge
=
(
axis
:
number
textureDimensionUnits
:
number
v
:
number
)
=
>
{
assert
(
isBuiltinGather
(
args
.
textureBuiltin
)
)
;
if
(
addressMode
[
axis
]
=
=
=
'
repeat
'
)
{
return
v
;
}
const
inside
=
euclideanModulo
(
v
textureDimensionUnits
)
;
const
outside
=
v
-
inside
;
return
outside
+
clamp
(
inside
{
min
:
1
max
:
textureDimensionUnits
-
1
}
)
;
}
;
const
numComponents
=
isDepthOrStencilTextureFormat
(
descriptor
.
format
)
?
1
:
4
;
return
coords
.
map
(
(
c
i
)
=
>
{
const
mipLevel
=
args
.
mipLevel
?
quantizeMipLevel
(
makeRangeValue
(
args
.
mipLevel
i
)
args
.
sampler
?
.
mipmapFilter
?
?
'
nearest
'
)
:
0
;
const
clampedMipLevel
=
clamp
(
mipLevel
{
min
:
0
max
:
mipLevelCount
-
1
}
)
;
const
mipSize
=
virtualMipSize
(
dimension
size
clampedMipLevel
)
;
const
q
=
mipSize
.
map
(
v
=
>
v
*
kSubdivisionsPerTexel
)
;
const
coords
=
c
.
map
(
(
v
i
)
=
>
{
const
v1
=
Math
.
floor
(
v
*
q
[
i
]
)
;
const
isTexelEdgeCase
=
Math
.
abs
(
v1
%
kSubdivisionsPerTexel
)
=
=
=
edgeRemainder
;
const
v2
=
isTexelEdgeCase
&
&
avoidEdgeCase
?
v1
+
1
:
v1
;
const
v3
=
isBuiltinGather
(
args
.
textureBuiltin
)
?
avoidTextureEdge
(
i
q
[
i
]
v2
)
:
v2
;
return
v3
/
q
[
i
]
;
}
)
as
T
;
const
makeGradient
=
<
T
>
(
hashInput
:
number
)
:
T
=
>
{
return
coords
.
map
(
(
_
i
)
=
>
{
const
intPart
=
makeRangeValue
(
{
num
:
8
type
:
'
u32
'
}
i
hashInput
)
-
4
;
const
fractPart
=
makeRangeValue
(
{
num
:
0
type
:
'
f32
'
}
i
hashInput
+
1
)
*
0
.
25
;
assert
(
fractPart
>
=
-
0
.
25
&
&
fractPart
<
=
0
.
25
)
;
return
intPart
+
fractPart
;
}
)
as
T
;
}
;
const
makeDerivativeMult
=
(
coords
:
T
mipLevel
:
number
)
:
T
=
>
{
const
mult
=
new
Array
(
coords
.
length
)
.
fill
(
0
)
;
const
ndx
=
makeRangeValue
(
{
num
:
coords
.
length
-
1
type
:
'
u32
'
}
i
8
)
;
assert
(
ndx
<
coords
.
length
)
;
mult
[
ndx
]
=
Math
.
pow
(
2
mipLevel
)
;
return
mult
as
T
;
}
;
const
chooseMipLevel
=
(
)
=
>
{
const
innerLevelR
=
makeRandValue
(
{
num
:
9
type
:
'
u32
'
}
i
11
)
;
const
innerLevel
=
args
?
.
sampler
?
.
mipmapFilter
=
=
=
'
linear
'
?
innerLevelR
+
1
:
innerLevelR
<
5
?
innerLevelR
:
innerLevelR
+
1
;
const
outerLevel
=
makeRangeValue
(
{
num
:
mipLevelCount
-
1
type
:
'
i32
'
}
i
11
)
;
return
outerLevel
+
innerLevel
/
10
;
}
;
const
makeDerivativeMultForTextureSample
=
(
coords
:
T
)
:
T
=
>
{
const
mipLevel
=
chooseMipLevel
(
)
;
return
makeDerivativeMult
(
coords
mipLevel
)
;
}
;
const
makeBiasAndDerivativeMult
=
(
coords
:
T
)
:
[
number
T
]
=
>
{
const
mipLevel
=
chooseMipLevel
(
)
;
const
bias
=
makeRangeValue
(
{
num
:
34
type
:
'
f32
'
}
i
9
)
-
17
;
const
clampedBias
=
clamp
(
bias
{
min
:
-
16
max
:
15
.
99
}
)
;
const
derivativeBasedMipLevel
=
mipLevel
-
clampedBias
;
const
derivativeMult
=
makeDerivativeMult
(
coords
derivativeBasedMipLevel
)
;
return
[
bias
derivativeMult
]
;
}
;
const
[
bias
derivativeMult
]
=
args
.
bias
?
makeBiasAndDerivativeMult
(
coords
)
:
args
.
derivatives
?
[
undefined
makeDerivativeMultForTextureSample
(
coords
)
]
:
[
]
;
return
{
coords
derivativeMult
mipLevel
sampleIndex
:
args
.
sampleIndex
?
makeRangeValue
(
args
.
sampleIndex
i
1
)
:
undefined
arrayIndex
:
args
.
arrayIndex
?
makeRangeValue
(
args
.
arrayIndex
i
2
)
:
undefined
depthRef
:
args
.
depthRef
?
makeRandValue
(
{
num
:
3
type
:
'
u32
'
}
i
5
)
/
2
:
undefined
ddx
:
args
.
grad
?
makeGradient
(
7
)
:
undefined
ddy
:
args
.
grad
?
makeGradient
(
8
)
:
undefined
bias
offset
:
args
.
offset
?
(
coords
.
map
(
(
_
j
)
=
>
makeIntHashValueRepeatable
(
-
8
8
i
3
+
j
)
)
as
T
)
:
undefined
component
:
args
.
component
?
makeIntHashValueRepeatable
(
0
numComponents
i
4
)
:
undefined
}
;
}
)
;
}
const
kMipEpsilon
=
0
.
02
;
function
quantizeMipLevel
(
mipLevel
:
number
mipmapFilter
:
GPUMipmapFilterMode
)
{
if
(
mipmapFilter
=
=
=
'
linear
'
)
{
return
mipLevel
;
}
const
intMip
=
Math
.
floor
(
mipLevel
)
;
const
fractionalMip
=
mipLevel
-
intMip
;
if
(
fractionalMip
<
0
.
5
-
kMipEpsilon
|
|
fractionalMip
>
0
.
5
+
kMipEpsilon
)
{
return
mipLevel
;
}
else
{
return
intMip
+
0
.
5
+
(
fractionalMip
<
0
.
5
?
-
kMipEpsilon
:
+
kMipEpsilon
)
;
}
}
type
FilterFirstElement
<
T
extends
unknown
[
]
>
=
T
extends
[
unknown
.
.
.
infer
R
]
?
R
:
[
]
;
type
GenerateTextureBuiltinInputsImplArgs
=
FilterFirstElement
<
Parameters
<
typeof
generateTextureBuiltinInputsImpl
>
>
;
export
function
generateTextureBuiltinInputs1D
(
.
.
.
args
:
GenerateTextureBuiltinInputsImplArgs
)
{
return
generateTextureBuiltinInputsImpl
<
vec1
>
(
(
x
:
number
)
=
>
[
x
]
.
.
.
args
)
;
}
export
function
generateTextureBuiltinInputs2D
(
.
.
.
args
:
GenerateTextureBuiltinInputsImplArgs
)
{
return
generateTextureBuiltinInputsImpl
<
vec2
>
(
(
x
:
number
y
:
number
)
=
>
[
x
y
]
.
.
.
args
)
;
}
export
function
generateTextureBuiltinInputs3D
(
.
.
.
args
:
GenerateTextureBuiltinInputsImplArgs
)
{
return
generateTextureBuiltinInputsImpl
<
vec3
>
(
(
x
:
number
y
:
number
z
:
number
)
=
>
[
x
y
z
]
.
.
.
args
)
;
}
type
mat3
=
[
number
number
number
number
number
number
number
number
number
]
;
const
kFaceUVMatrices
:
mat3
[
]
=
[
[
0
0
-
2
0
-
2
0
1
1
1
]
[
0
0
2
0
-
2
0
-
1
1
-
1
]
[
2
0
0
0
0
2
-
1
1
-
1
]
[
2
0
0
0
0
-
2
-
1
-
1
1
]
[
2
0
0
0
-
2
0
-
1
1
1
]
[
-
2
0
0
0
-
2
0
1
1
-
1
]
]
;
function
transformMat3
(
v
:
vec3
m
:
mat3
)
:
vec3
{
const
x
=
v
[
0
]
;
const
y
=
v
[
1
]
;
const
z
=
v
[
2
]
;
return
[
x
*
m
[
0
]
+
y
*
m
[
3
]
+
z
*
m
[
6
]
x
*
m
[
1
]
+
y
*
m
[
4
]
+
z
*
m
[
7
]
x
*
m
[
2
]
+
y
*
m
[
5
]
+
z
*
m
[
8
]
]
;
}
function
normalize
(
v
:
vec3
)
:
vec3
{
const
length
=
Math
.
sqrt
(
v
[
0
]
*
v
[
0
]
+
v
[
1
]
*
v
[
1
]
+
v
[
2
]
*
v
[
2
]
)
;
assert
(
length
>
0
)
;
return
v
.
map
(
v
=
>
v
/
length
)
as
vec3
;
}
function
convertCubeCoordToNormalized3DTextureCoord
(
v
:
vec3
)
:
vec3
{
let
uvw
;
let
layer
;
const
r
=
normalize
(
v
)
;
const
absR
=
r
.
map
(
v
=
>
Math
.
abs
(
v
)
)
;
if
(
absR
[
0
]
>
absR
[
1
]
&
&
absR
[
0
]
>
absR
[
2
]
)
{
const
negX
=
r
[
0
]
<
0
.
0
?
1
:
0
;
uvw
=
[
negX
?
r
[
2
]
:
-
r
[
2
]
-
r
[
1
]
absR
[
0
]
]
;
layer
=
negX
;
}
else
if
(
absR
[
1
]
>
absR
[
2
]
)
{
const
negY
=
r
[
1
]
<
0
.
0
?
1
:
0
;
uvw
=
[
r
[
0
]
negY
?
-
r
[
2
]
:
r
[
2
]
absR
[
1
]
]
;
layer
=
2
+
negY
;
}
else
{
const
negZ
=
r
[
2
]
<
0
.
0
?
1
:
0
;
uvw
=
[
negZ
?
-
r
[
0
]
:
r
[
0
]
-
r
[
1
]
absR
[
2
]
]
;
layer
=
4
+
negZ
;
}
return
[
(
uvw
[
0
]
/
uvw
[
2
]
+
1
)
*
0
.
5
(
uvw
[
1
]
/
uvw
[
2
]
+
1
)
*
0
.
5
(
layer
+
0
.
5
)
/
6
]
;
}
function
convertNormalized3DTexCoordToCubeCoord
(
uvLayer
:
vec3
)
{
const
[
u
v
faceLayer
]
=
uvLayer
;
return
normalize
(
transformMat3
(
[
u
v
1
]
kFaceUVMatrices
[
Math
.
min
(
5
faceLayer
*
6
)
|
0
]
)
)
;
}
function
wrapFaceCoordToCubeFaceAtEdgeBoundaries
(
textureSize
:
number
faceCoord
:
vec3
)
{
const
nc0
:
vec3
=
[
(
faceCoord
[
0
]
+
0
.
5
)
/
textureSize
(
faceCoord
[
1
]
+
0
.
5
)
/
textureSize
(
faceCoord
[
2
]
+
0
.
5
)
/
6
]
;
const
cc
=
convertNormalized3DTexCoordToCubeCoord
(
nc0
)
;
const
nc1
=
convertCubeCoordToNormalized3DTextureCoord
(
cc
)
;
const
fc
=
[
Math
.
floor
(
nc1
[
0
]
*
textureSize
)
Math
.
floor
(
nc1
[
1
]
*
textureSize
)
Math
.
floor
(
nc1
[
2
]
*
6
)
]
;
return
fc
;
}
function
applyAddressModesToCoords
(
addressMode
:
GPUAddressMode
[
]
textureSize
:
number
[
]
coord
:
number
[
]
)
{
return
coord
.
map
(
(
v
i
)
=
>
{
switch
(
addressMode
[
i
]
)
{
case
'
clamp
-
to
-
edge
'
:
return
clamp
(
v
{
min
:
0
max
:
textureSize
[
i
]
-
1
}
)
;
case
'
mirror
-
repeat
'
:
{
const
n
=
Math
.
floor
(
v
/
textureSize
[
i
]
)
;
v
=
v
-
n
*
textureSize
[
i
]
;
return
(
n
&
1
)
!
=
=
0
?
textureSize
[
i
]
-
v
-
1
:
v
;
}
case
'
repeat
'
:
return
v
-
Math
.
floor
(
v
/
textureSize
[
i
]
)
*
textureSize
[
i
]
;
default
:
unreachable
(
)
;
}
}
)
;
}
export
function
generateSamplePointsCube
(
n
:
number
args
:
|
(
TextureBuiltinInputArgs
&
{
method
:
'
texel
-
centre
'
;
}
)
|
(
TextureBuiltinInputArgs
&
{
method
:
'
spiral
'
;
radius
?
:
number
;
loops
?
:
number
;
}
)
|
(
TextureBuiltinInputArgs
&
{
method
:
'
cube
-
edges
'
;
}
)
)
:
{
coords
:
vec3
;
derivativeMult
?
:
vec3
;
ddx
?
:
vec3
;
ddy
?
:
vec3
;
mipLevel
:
number
;
arrayIndex
?
:
number
;
bias
?
:
number
;
offset
?
:
undefined
;
component
?
:
number
;
depthRef
?
:
number
;
}
[
]
{
const
{
method
descriptor
}
=
args
;
const
mipLevelCount
=
descriptor
.
mipLevelCount
?
?
1
;
const
size
=
virtualMipSize
(
'
2d
'
descriptor
.
size
0
)
;
const
textureWidth
=
size
[
0
]
;
const
coords
:
vec3
[
]
=
[
]
;
switch
(
method
)
{
case
'
texel
-
centre
'
:
{
for
(
let
i
=
0
;
i
<
n
;
i
+
+
)
{
const
r
=
hashU32
(
i
)
;
const
u
=
(
Math
.
floor
(
lerp
(
0
textureWidth
-
1
(
r
&
0xff
)
/
0xff
)
)
+
0
.
5
)
/
textureWidth
;
const
v
=
(
Math
.
floor
(
lerp
(
0
textureWidth
-
1
(
(
r
>
>
8
)
&
0xff
)
/
0xff
)
)
+
0
.
5
)
/
textureWidth
;
const
face
=
Math
.
floor
(
lerp
(
0
6
(
(
r
>
>
16
)
&
0xff
)
/
0x100
)
)
;
coords
.
push
(
convertNormalized3DTexCoordToCubeCoord
(
[
u
v
face
]
)
)
;
}
break
;
}
case
'
spiral
'
:
{
const
{
radius
=
1
.
5
loops
=
2
}
=
args
;
for
(
let
i
=
0
;
i
<
n
;
i
+
+
)
{
const
f
=
(
i
+
1
)
/
(
Math
.
max
(
n
2
)
-
1
)
;
const
r
=
radius
*
f
;
const
theta
=
loops
*
2
*
Math
.
PI
*
f
;
const
phi
=
loops
*
1
.
3
*
Math
.
PI
*
f
;
const
sinTheta
=
Math
.
sin
(
theta
)
;
const
cosTheta
=
Math
.
cos
(
theta
)
;
const
sinPhi
=
Math
.
sin
(
phi
)
;
const
cosPhi
=
Math
.
cos
(
phi
)
;
const
ux
=
cosTheta
*
sinPhi
;
const
uy
=
cosPhi
;
const
uz
=
sinTheta
*
sinPhi
;
coords
.
push
(
[
ux
*
r
uy
*
r
uz
*
r
]
)
;
}
break
;
}
case
'
cube
-
edges
'
:
{
coords
.
push
(
[
1
-
1
.
01
0
]
[
1
+
1
.
01
0
]
[
1
0
-
1
.
01
]
[
1
0
+
1
.
01
]
[
-
1
-
1
.
01
0
]
[
-
1
+
1
.
01
0
]
[
-
1
0
-
1
.
01
]
[
-
1
0
+
1
.
01
]
[
-
1
.
01
1
0
]
[
+
1
.
01
1
0
]
[
0
1
-
1
.
01
]
[
0
1
+
1
.
01
]
[
-
1
.
01
-
1
0
]
[
+
1
.
01
-
1
0
]
[
0
-
1
-
1
.
01
]
[
0
-
1
+
1
.
01
]
[
-
1
.
01
0
1
]
[
+
1
.
01
0
1
]
[
0
-
1
.
01
1
]
[
0
+
1
.
01
1
]
[
-
1
.
01
0
-
1
]
[
+
1
.
01
0
-
1
]
[
0
-
1
.
01
-
1
]
[
0
+
1
.
01
-
1
]
)
;
break
;
}
}
const
_hashInputs
=
args
.
hashInputs
.
map
(
v
=
>
typeof
v
=
=
=
'
string
'
?
sumOfCharCodesOfString
(
v
)
:
typeof
v
=
=
=
'
boolean
'
?
(
v
?
1
:
0
)
:
v
)
;
const
makeRandValue
=
(
{
num
type
}
:
RangeDef
.
.
.
hashInputs
:
number
[
]
)
=
>
{
const
range
=
num
;
const
number
=
(
hashU32
(
.
.
.
_hashInputs
.
.
.
hashInputs
)
/
0x1_0000_0000
)
*
range
;
return
type
=
=
=
'
f32
'
?
number
:
Math
.
floor
(
number
)
;
}
;
const
makeRangeValue
=
(
{
num
type
}
:
RangeDef
.
.
.
hashInputs
:
number
[
]
)
=
>
{
const
range
=
num
+
(
type
=
=
=
'
u32
'
?
1
:
2
)
;
const
number
=
(
hashU32
(
.
.
.
_hashInputs
.
.
.
hashInputs
)
/
0x1_0000_0000
)
*
range
-
(
type
=
=
=
'
u32
'
?
0
:
1
)
;
return
type
=
=
=
'
f32
'
?
number
:
Math
.
floor
(
number
)
;
}
;
const
makeIntHashValue
=
(
min
:
number
max
:
number
.
.
.
hashInputs
:
number
[
]
)
=
>
{
const
range
=
max
-
min
;
return
min
+
Math
.
floor
(
(
hashU32
(
.
.
.
_hashInputs
.
.
.
hashInputs
)
/
0x1_0000_0000
)
*
range
)
;
}
;
const
kSubdivisionsPerTexel
=
4
;
const
avoidEdgeCase
=
!
args
.
sampler
|
|
args
.
sampler
.
minFilter
=
=
=
'
nearest
'
|
|
isBuiltinGather
(
args
.
textureBuiltin
)
;
const
edgeRemainder
=
isBuiltinGather
(
args
.
textureBuiltin
)
?
kSubdivisionsPerTexel
/
2
:
0
;
return
coords
.
map
(
(
c
i
)
=
>
{
const
mipLevel
=
args
.
mipLevel
?
quantizeMipLevel
(
makeRangeValue
(
args
.
mipLevel
i
)
args
.
sampler
?
.
mipmapFilter
?
?
'
nearest
'
)
:
0
;
const
clampedMipLevel
=
clamp
(
mipLevel
{
min
:
0
max
:
mipLevelCount
-
1
}
)
;
const
mipSize
=
virtualMipSize
(
'
2d
'
size
Math
.
ceil
(
clampedMipLevel
)
)
;
const
q
=
[
mipSize
[
0
]
*
kSubdivisionsPerTexel
mipSize
[
0
]
*
kSubdivisionsPerTexel
6
*
kSubdivisionsPerTexel
]
;
const
uvw
=
convertCubeCoordToNormalized3DTextureCoord
(
c
)
;
const
ndx
=
getUnusedCubeCornerSampleIndex
(
mipSize
[
0
]
uvw
)
;
if
(
ndx
>
=
0
)
{
const
halfTexel
=
0
.
5
/
mipSize
[
0
]
;
uvw
[
0
]
=
clamp
(
uvw
[
0
]
{
min
:
halfTexel
max
:
1
-
halfTexel
}
)
;
}
const
quantizedUVW
=
uvw
.
map
(
(
v
i
)
=
>
{
const
v1
=
Math
.
floor
(
v
*
q
[
i
]
)
;
const
isEdgeCase
=
Math
.
abs
(
v1
%
kSubdivisionsPerTexel
)
=
=
=
edgeRemainder
;
const
v2
=
isEdgeCase
&
&
avoidEdgeCase
?
v1
+
1
:
v1
;
return
(
v2
+
1
/
16
)
/
q
[
i
]
;
}
)
as
vec3
;
const
quantize
=
(
v
:
number
units
:
number
)
=
>
Math
.
floor
(
v
*
units
)
*
units
;
const
makeGradient
=
<
T
>
(
hashInput
:
number
)
:
T
=
>
{
return
coords
.
map
(
(
_
i
)
=
>
quantize
(
makeRangeValue
(
{
num
:
8
type
:
'
f32
'
}
i
hashInput
)
-
4
1
/
3
)
)
as
T
;
}
;
const
coords
=
convertNormalized3DTexCoordToCubeCoord
(
quantizedUVW
)
;
const
makeDerivativeMult
=
(
coords
:
vec3
mipLevel
:
number
)
:
vec3
=
>
{
const
mult
=
new
Array
(
coords
.
length
)
.
fill
(
0
)
;
const
ndx
=
makeRangeValue
(
{
num
:
coords
.
length
-
1
type
:
'
u32
'
}
i
8
)
;
assert
(
ndx
<
coords
.
length
)
;
mult
[
ndx
]
=
Math
.
pow
(
2
mipLevel
)
;
return
mult
as
vec3
;
}
;
const
chooseMipLevel
=
(
)
=
>
{
const
innerLevelR
=
makeRandValue
(
{
num
:
9
type
:
'
u32
'
}
i
11
)
;
const
innerLevel
=
args
?
.
sampler
?
.
mipmapFilter
=
=
=
'
linear
'
?
innerLevelR
+
1
:
innerLevelR
<
4
?
innerLevelR
:
innerLevelR
+
1
;
const
outerLevel
=
makeRangeValue
(
{
num
:
mipLevelCount
-
1
type
:
'
i32
'
}
i
11
)
;
return
outerLevel
+
innerLevel
/
10
;
}
;
const
makeDerivativeMultForTextureSample
=
(
coords
:
vec3
)
:
vec3
=
>
{
const
mipLevel
=
chooseMipLevel
(
)
;
return
makeDerivativeMult
(
coords
mipLevel
)
;
}
;
const
makeBiasAndDerivativeMult
=
(
coords
:
vec3
)
:
[
number
vec3
]
=
>
{
const
mipLevel
=
chooseMipLevel
(
)
;
const
bias
=
makeRangeValue
(
{
num
:
34
type
:
'
f32
'
}
i
9
)
-
17
;
const
clampedBias
=
clamp
(
bias
{
min
:
-
16
max
:
15
.
99
}
)
;
const
derivativeBasedMipLevel
=
mipLevel
-
clampedBias
;
const
derivativeMult
=
makeDerivativeMult
(
coords
derivativeBasedMipLevel
)
;
return
[
bias
derivativeMult
]
;
}
;
const
[
bias
derivativeMult
]
=
args
.
bias
?
makeBiasAndDerivativeMult
(
coords
)
:
args
.
derivatives
?
[
undefined
makeDerivativeMultForTextureSample
(
coords
)
]
:
[
]
;
return
{
coords
derivativeMult
ddx
:
args
.
grad
?
makeGradient
(
7
)
:
undefined
ddy
:
args
.
grad
?
makeGradient
(
8
)
:
undefined
mipLevel
arrayIndex
:
args
.
arrayIndex
?
makeRangeValue
(
args
.
arrayIndex
i
2
)
:
undefined
bias
depthRef
:
args
.
depthRef
?
makeRandValue
(
{
num
:
3
type
:
'
u32
'
}
i
5
)
/
2
:
undefined
component
:
args
.
component
?
makeIntHashValue
(
0
4
i
4
)
:
undefined
}
;
}
)
;
}
function
wgslTypeFor
(
data
:
number
|
Dimensionality
type
:
'
f
'
|
'
i
'
|
'
u
'
)
:
string
{
if
(
Array
.
isArray
(
data
)
)
{
switch
(
data
.
length
)
{
case
1
:
return
{
type
}
32
;
case
2
:
return
vec2
{
type
}
;
case
3
:
return
vec3
{
type
}
;
default
:
unreachable
(
)
;
}
}
return
{
type
}
32
;
}
function
wgslExpr
(
data
:
number
|
Readonly
<
vec1
>
|
Readonly
<
vec2
>
|
Readonly
<
vec3
>
|
Readonly
<
vec4
>
)
:
string
{
if
(
Array
.
isArray
(
data
)
)
{
switch
(
data
.
length
)
{
case
1
:
return
data
[
0
]
.
toString
(
)
;
case
2
:
return
vec2
(
{
data
.
map
(
v
=
>
v
.
toString
(
)
)
.
join
(
'
'
)
}
)
;
case
3
:
return
vec3
(
{
data
.
map
(
v
=
>
v
.
toString
(
)
)
.
join
(
'
'
)
}
)
;
default
:
unreachable
(
)
;
}
}
return
data
.
toString
(
)
;
}
function
wgslExprFor
(
data
:
number
|
vec1
|
vec2
|
vec3
|
vec4
type
:
'
f
'
|
'
i
'
|
'
u
'
)
:
string
{
if
(
Array
.
isArray
(
data
)
)
{
switch
(
data
.
length
)
{
case
1
:
return
{
type
}
(
{
data
[
0
]
.
toString
(
)
}
)
;
case
2
:
return
vec2
{
type
}
(
{
data
.
map
(
v
=
>
v
.
toString
(
)
)
.
join
(
'
'
)
}
)
;
case
3
:
return
vec3
{
type
}
(
{
data
.
map
(
v
=
>
v
.
toString
(
)
)
.
join
(
'
'
)
}
)
;
default
:
unreachable
(
)
;
}
}
return
{
type
}
32
(
{
data
.
toString
(
)
}
)
;
}
function
binKey
<
T
extends
Dimensionality
>
(
call
:
TextureCall
<
T
>
)
:
string
{
const
keys
:
string
[
]
=
[
]
;
for
(
const
name
of
kTextureCallArgNames
)
{
const
value
=
call
[
name
]
;
if
(
value
!
=
=
undefined
)
{
if
(
name
=
=
=
'
offset
'
|
|
name
=
=
=
'
component
'
)
{
keys
.
push
(
{
name
}
:
{
wgslExpr
(
value
)
}
)
;
}
else
{
keys
.
push
(
{
name
}
:
{
wgslTypeFor
(
value
call
.
coordType
)
}
)
;
}
}
}
return
{
call
.
builtin
}
(
{
keys
.
join
(
'
'
)
}
)
;
}
function
buildBinnedCalls
<
T
extends
Dimensionality
>
(
calls
:
TextureCall
<
T
>
[
]
)
{
const
args
:
string
[
]
=
[
]
;
const
fields
:
string
[
]
=
[
]
;
const
data
:
number
[
]
=
[
]
;
const
prototype
=
calls
[
0
]
;
if
(
isBuiltinGather
(
prototype
.
builtin
)
&
&
prototype
[
'
componentType
'
]
)
{
args
.
push
(
/
*
component
*
/
{
wgslExpr
(
prototype
[
'
component
'
]
!
)
}
)
;
}
args
.
push
(
'
T
'
)
;
if
(
builtinNeedsSampler
(
prototype
.
builtin
)
)
{
args
.
push
(
'
S
'
)
;
}
for
(
const
name
of
kTextureCallArgNames
)
{
const
value
=
prototype
[
name
]
;
if
(
value
!
=
=
undefined
)
{
if
(
name
=
=
=
'
offset
'
)
{
args
.
push
(
/
*
offset
*
/
{
wgslExpr
(
value
)
}
)
;
}
else
if
(
name
=
=
=
'
component
'
)
{
}
else
{
const
type
=
name
=
=
=
'
mipLevel
'
?
prototype
.
levelType
!
:
name
=
=
=
'
arrayIndex
'
?
prototype
.
arrayIndexType
!
:
name
=
=
=
'
sampleIndex
'
?
prototype
.
sampleIndexType
!
:
name
=
=
=
'
bias
'
|
|
name
=
=
=
'
depthRef
'
|
|
name
=
=
=
'
ddx
'
|
|
name
=
=
=
'
ddy
'
?
'
f
'
:
prototype
.
coordType
;
if
(
name
!
=
=
'
derivativeMult
'
)
{
args
.
push
(
args
.
{
name
}
{
name
=
=
=
'
coords
'
&
&
builtinNeedsDerivatives
(
prototype
.
builtin
)
?
'
+
derivativeBase
*
args
.
derivativeMult
'
:
'
'
}
)
;
}
fields
.
push
(
align
(
16
)
{
name
}
:
{
wgslTypeFor
(
value
type
)
}
)
;
}
}
}
for
(
const
call
of
calls
)
{
for
(
const
name
of
kTextureCallArgNames
)
{
const
value
=
call
[
name
]
;
assert
(
(
prototype
[
name
]
=
=
=
undefined
)
=
=
=
(
value
=
=
=
undefined
)
'
texture
calls
are
not
binned
correctly
'
)
;
if
(
value
!
=
=
undefined
&
&
name
!
=
=
'
offset
'
&
&
name
!
=
=
'
component
'
)
{
const
type
=
getCallArgType
<
T
>
(
call
name
)
;
const
bitcastToU32
=
kBitCastFunctions
[
type
]
;
if
(
value
instanceof
Array
)
{
for
(
const
c
of
value
)
{
data
.
push
(
bitcastToU32
(
c
)
)
;
}
}
else
{
data
.
push
(
bitcastToU32
(
value
)
)
;
}
while
(
(
data
.
length
&
3
)
!
=
=
0
)
{
data
.
push
(
0
)
;
}
}
}
}
const
expr
=
{
prototype
.
builtin
}
(
{
args
.
join
(
'
'
)
}
)
;
return
{
expr
fields
data
}
;
}
function
binCalls
<
T
extends
Dimensionality
>
(
calls
:
TextureCall
<
T
>
[
]
)
:
number
[
]
[
]
{
const
map
=
new
Map
<
string
number
>
(
)
;
const
bins
:
number
[
]
[
]
=
[
]
;
calls
.
forEach
(
(
call
callIdx
)
=
>
{
const
key
=
binKey
(
call
)
;
const
binIdx
=
map
.
get
(
key
)
;
if
(
binIdx
=
=
=
undefined
)
{
map
.
set
(
key
bins
.
length
)
;
bins
.
push
(
[
callIdx
]
)
;
}
else
{
bins
[
binIdx
]
.
push
(
callIdx
)
;
}
}
)
;
return
bins
;
}
function
describeTextureCall
<
T
extends
Dimensionality
>
(
call
:
TextureCall
<
T
>
)
:
string
{
const
args
:
string
[
]
=
[
]
;
if
(
isBuiltinGather
(
call
.
builtin
)
&
&
call
.
componentType
)
{
args
.
push
(
component
:
{
wgslExprFor
(
call
.
component
!
call
.
componentType
)
}
)
;
}
args
.
push
(
'
texture
:
T
'
)
;
if
(
builtinNeedsSampler
(
call
.
builtin
)
)
{
args
.
push
(
'
sampler
:
S
'
)
;
}
for
(
const
name
of
kTextureCallArgNames
)
{
const
value
=
call
[
name
]
;
if
(
value
!
=
=
undefined
&
&
name
!
=
=
'
component
'
)
{
if
(
name
=
=
=
'
coords
'
)
{
const
derivativeWGSL
=
builtinNeedsDerivatives
(
call
.
builtin
)
?
+
derivativeBase
*
derivativeMult
(
{
call
.
derivativeMult
?
wgslExprFor
(
call
.
derivativeMult
call
.
coordType
)
:
'
1
'
}
)
:
'
'
;
args
.
push
(
{
name
}
:
{
wgslExprFor
(
value
call
.
coordType
)
}
{
derivativeWGSL
}
)
;
}
else
if
(
name
=
=
=
'
derivativeMult
'
)
{
}
else
if
(
name
=
=
=
'
ddx
'
|
|
name
=
=
=
'
ddy
'
)
{
args
.
push
(
{
name
}
:
{
wgslExprFor
(
value
call
.
coordType
)
}
)
;
}
else
if
(
name
=
=
=
'
mipLevel
'
)
{
args
.
push
(
{
name
}
:
{
wgslExprFor
(
value
call
.
levelType
!
)
}
)
;
}
else
if
(
name
=
=
=
'
arrayIndex
'
)
{
args
.
push
(
{
name
}
:
{
wgslExprFor
(
value
call
.
arrayIndexType
!
)
}
)
;
}
else
if
(
name
=
=
=
'
bias
'
)
{
args
.
push
(
{
name
}
:
{
wgslExprFor
(
value
'
f
'
)
}
)
;
}
else
if
(
name
=
=
=
'
sampleIndex
'
)
{
args
.
push
(
{
name
}
:
{
wgslExprFor
(
value
call
.
sampleIndexType
!
)
}
)
;
}
else
if
(
name
=
=
=
'
depthRef
'
)
{
args
.
push
(
{
name
}
:
{
wgslExprFor
(
value
'
f
'
)
}
)
;
}
else
{
args
.
push
(
{
name
}
:
{
wgslExpr
(
value
)
}
)
;
}
}
}
return
{
call
.
builtin
}
(
{
args
.
join
(
'
'
)
}
)
;
}
const
getAspectForTexture
=
(
texture
:
GPUTexture
|
GPUExternalTexture
)
:
GPUTextureAspect
=
>
texture
instanceof
GPUExternalTexture
?
'
all
'
:
isDepthTextureFormat
(
texture
.
format
)
?
'
depth
-
only
'
:
isStencilTextureFormat
(
texture
.
format
)
?
'
stencil
-
only
'
:
'
all
'
;
const
s_deviceToPipelines
=
new
WeakMap
<
GPUDevice
Map
<
string
GPURenderPipeline
|
GPUComputePipeline
>
>
(
)
;
function
createTextureCallsRunner
<
T
extends
Dimensionality
>
(
t
:
GPUTest
{
format
dimension
sampleCount
depthOrArrayLayers
}
:
{
format
:
GPUTextureFormat
;
dimension
:
GPUTextureDimension
;
sampleCount
:
number
;
depthOrArrayLayers
:
number
;
}
viewDescriptor
:
GPUTextureViewDescriptor
textureType
:
string
sampler
:
GPUSamplerDescriptor
|
undefined
calls
:
TextureCall
<
T
>
[
]
stage
:
ShaderStage
)
{
let
structs
=
'
'
;
let
body
=
'
'
;
let
dataFields
=
'
'
;
const
data
:
number
[
]
=
[
]
;
let
callCount
=
0
;
const
binned
=
binCalls
(
calls
)
;
binned
.
forEach
(
(
binCalls
binIdx
)
=
>
{
const
b
=
buildBinnedCalls
(
binCalls
.
map
(
callIdx
=
>
calls
[
callIdx
]
)
)
;
structs
+
=
struct
Args
{
binIdx
}
{
{
b
.
fields
.
join
(
'
\
n
'
)
}
}
;
dataFields
+
=
args
{
binIdx
}
:
array
<
Args
{
binIdx
}
{
binCalls
.
length
}
>
;
body
+
=
{
let
is_active
=
(
idx
>
=
{
callCount
}
)
&
(
idx
<
{
callCount
+
binCalls
.
length
}
)
;
let
args
=
data
.
args
{
binIdx
}
[
idx
-
{
callCount
}
]
;
let
call
=
{
b
.
expr
}
;
result
=
select
(
result
call
is_active
)
;
}
;
callCount
+
=
binCalls
.
length
;
data
.
push
(
.
.
.
b
.
data
)
;
}
)
;
const
dataBuffer
=
t
.
createBufferTracked
(
{
size
:
data
.
length
*
4
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
UNIFORM
}
)
;
t
.
device
.
queue
.
writeBuffer
(
dataBuffer
0
new
Uint32Array
(
data
)
)
;
const
builtin
=
calls
[
0
]
.
builtin
;
const
isCompare
=
isBuiltinComparison
(
builtin
)
;
const
{
resultType
resultFormat
componentType
}
=
isBuiltinGather
(
builtin
)
?
getTextureFormatTypeInfo
(
format
)
:
textureType
=
=
=
'
texture_external
'
?
(
{
resultType
:
'
vec4f
'
resultFormat
:
'
rgba32float
'
componentType
:
'
f32
'
}
as
const
)
:
textureType
.
includes
(
'
depth
'
)
?
(
{
resultType
:
'
f32
'
resultFormat
:
'
rgba32float
'
componentType
:
'
f32
'
}
as
const
)
:
getTextureFormatTypeInfo
(
format
)
;
const
returnType
=
vec4
<
{
componentType
}
>
;
const
samplerType
=
isCompare
?
'
sampler_comparison
'
:
'
sampler
'
;
const
renderTarget
=
t
.
createTextureTracked
(
{
format
:
'
rgba32uint
'
size
:
[
calls
.
length
1
]
usage
:
GPUTextureUsage
.
COPY_SRC
|
GPUTextureUsage
.
RENDER_ATTACHMENT
}
)
;
const
derivativeBaseWGSL
=
let
derivativeBase
=
{
isCubeViewDimension
(
viewDescriptor
)
?
'
(
v
.
pos
.
xyx
-
0
.
5
-
vec3f
(
f32
(
v
.
ndx
)
0
f32
(
v
.
ndx
)
)
)
/
vec3f
(
vec2f
(
textureDimensions
(
T
)
)
1
.
0
)
'
:
dimension
=
=
=
'
1d
'
?
'
f32
(
v
.
pos
.
x
-
0
.
5
-
f32
(
v
.
ndx
)
)
/
f32
(
textureDimensions
(
T
)
)
'
:
dimension
=
=
=
'
3d
'
?
'
vec3f
(
v
.
pos
.
xy
-
0
.
5
-
vec2f
(
f32
(
v
.
ndx
)
0
)
0
)
/
vec3f
(
textureDimensions
(
T
)
)
'
:
'
(
v
.
pos
.
xy
-
0
.
5
-
vec2f
(
f32
(
v
.
ndx
)
0
)
)
/
vec2f
(
textureDimensions
(
T
)
)
'
}
;
;
const
derivativeType
=
isCubeViewDimension
(
viewDescriptor
)
|
|
dimension
=
=
=
'
3d
'
?
'
vec3f
'
:
dimension
=
=
=
'
1d
'
?
'
f32
'
:
'
vec2f
'
;
const
stageWGSL
=
stage
=
=
=
'
vertex
'
?
/
/
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
vertex
stage
shaders
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
vertex
fn
vsVertex
(
builtin
(
vertex_index
)
vertex_index
:
u32
builtin
(
instance_index
)
instance_index
:
u32
)
-
>
VOut
{
let
positions
=
array
(
vec2f
(
-
1
3
)
vec2f
(
3
-
1
)
vec2f
(
-
1
-
1
)
)
;
return
VOut
(
vec4f
(
positions
[
vertex_index
]
0
1
)
instance_index
getResult
(
instance_index
{
derivativeType
}
(
0
)
)
)
;
}
fragment
fn
fsVertex
(
v
:
VOut
)
-
>
location
(
0
)
vec4u
{
return
bitcast
<
vec4u
>
(
v
.
result
)
;
}
:
stage
=
=
=
'
fragment
'
?
/
/
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
fragment
stage
shaders
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
vertex
fn
vsFragment
(
builtin
(
vertex_index
)
vertex_index
:
u32
builtin
(
instance_index
)
instance_index
:
u32
)
-
>
VOut
{
let
positions
=
array
(
vec2f
(
-
1
3
)
vec2f
(
3
-
1
)
vec2f
(
-
1
-
1
)
)
;
return
VOut
(
vec4f
(
positions
[
vertex_index
]
0
1
)
instance_index
{
returnType
}
(
0
)
)
;
}
fragment
fn
fsFragment
(
v
:
VOut
)
-
>
location
(
0
)
vec4u
{
{
derivativeBaseWGSL
}
return
bitcast
<
vec4u
>
(
getResult
(
v
.
ndx
derivativeBase
)
)
;
}
:
/
/
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
compute
stage
shaders
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
group
(
1
)
binding
(
0
)
var
<
storage
read_write
>
results
:
array
<
{
returnType
}
>
;
compute
workgroup_size
(
1
)
fn
csCompute
(
builtin
(
global_invocation_id
)
id
:
vec3u
)
{
results
[
id
.
x
]
=
getResult
(
id
.
x
{
derivativeType
}
(
0
)
)
;
}
;
const
code
=
{
structs
}
struct
Data
{
{
dataFields
}
}
struct
VOut
{
builtin
(
position
)
pos
:
vec4f
location
(
0
)
interpolate
(
flat
either
)
ndx
:
u32
location
(
1
)
interpolate
(
flat
either
)
result
:
{
returnType
}
}
;
group
(
0
)
binding
(
0
)
var
T
:
{
textureType
}
;
{
sampler
?
group
(
0
)
binding
(
1
)
var
S
:
{
samplerType
}
:
'
'
}
;
group
(
0
)
binding
(
2
)
var
<
uniform
>
data
:
Data
;
fn
getResult
(
idx
:
u32
derivativeBase
:
{
derivativeType
}
)
-
>
{
returnType
}
{
var
result
:
{
resultType
}
;
{
body
}
return
{
returnType
}
(
result
)
;
}
{
stageWGSL
}
;
const
pipelines
=
s_deviceToPipelines
.
get
(
t
.
device
)
?
?
new
Map
<
string
GPURenderPipeline
|
GPUComputePipeline
>
(
)
;
s_deviceToPipelines
.
set
(
t
.
device
pipelines
)
;
const
type
=
getTextureFormatType
(
format
?
?
'
rgba8unorm
'
)
;
const
isFiltering
=
!
!
sampler
&
&
(
sampler
.
minFilter
=
=
=
'
linear
'
|
|
sampler
.
magFilter
=
=
=
'
linear
'
|
|
sampler
.
mipmapFilter
=
=
=
'
linear
'
)
;
let
sampleType
:
GPUTextureSampleType
=
textureType
.
startsWith
(
'
texture_depth
'
)
?
'
depth
'
:
isDepthTextureFormat
(
format
)
?
'
unfilterable
-
float
'
:
isStencilTextureFormat
(
format
)
?
'
uint
'
:
type
?
?
'
float
'
;
if
(
isFiltering
&
&
sampleType
=
=
=
'
unfilterable
-
float
'
)
{
assert
(
is32Float
(
format
)
)
;
assert
(
t
.
device
.
features
.
has
(
'
float32
-
filterable
'
)
)
;
sampleType
=
'
float
'
;
}
if
(
sampleCount
>
1
&
&
sampleType
=
=
=
'
float
'
)
{
sampleType
=
'
unfilterable
-
float
'
;
}
const
visibility
=
stage
=
=
=
'
compute
'
?
GPUShaderStage
.
COMPUTE
:
stage
=
=
=
'
fragment
'
?
GPUShaderStage
.
FRAGMENT
:
GPUShaderStage
.
VERTEX
;
const
entries
:
GPUBindGroupLayoutEntry
[
]
=
[
{
binding
:
2
visibility
buffer
:
{
type
:
'
uniform
'
}
}
]
;
const
viewDimension
=
effectiveViewDimensionForDimension
(
viewDescriptor
.
dimension
dimension
depthOrArrayLayers
)
;
if
(
textureType
.
includes
(
'
storage
'
)
)
{
entries
.
push
(
{
binding
:
0
visibility
storageTexture
:
{
access
:
'
read
-
only
'
viewDimension
format
}
}
)
;
}
else
if
(
textureType
=
=
=
'
texture_external
'
)
{
entries
.
push
(
{
binding
:
0
visibility
externalTexture
:
{
}
}
)
;
}
else
{
entries
.
push
(
{
binding
:
0
visibility
texture
:
{
sampleType
viewDimension
multisampled
:
sampleCount
>
1
}
}
)
;
}
if
(
sampler
)
{
const
type
=
isCompare
?
'
comparison
'
:
isFiltering
?
'
filtering
'
:
'
non
-
filtering
'
;
entries
.
push
(
{
binding
:
1
visibility
sampler
:
{
type
}
}
)
;
}
const
id
=
{
resultType
}
:
{
stage
}
:
{
JSON
.
stringify
(
entries
)
}
:
{
code
}
;
let
pipeline
=
pipelines
.
get
(
id
)
;
if
(
!
pipeline
)
{
const
module
=
t
.
device
.
createShaderModule
(
{
code
}
)
;
const
bindGroupLayout0
=
t
.
device
.
createBindGroupLayout
(
{
entries
}
)
;
const
bindGroupLayouts
=
[
bindGroupLayout0
]
;
if
(
stage
=
=
=
'
compute
'
)
{
const
bindGroupLayout1
=
t
.
device
.
createBindGroupLayout
(
{
entries
:
[
{
binding
:
0
visibility
:
GPUShaderStage
.
COMPUTE
buffer
:
{
type
:
'
storage
'
}
}
]
}
)
;
bindGroupLayouts
.
push
(
bindGroupLayout1
)
;
}
const
layout
=
t
.
device
.
createPipelineLayout
(
{
bindGroupLayouts
}
)
;
switch
(
stage
)
{
case
'
compute
'
:
pipeline
=
t
.
device
.
createComputePipeline
(
{
layout
compute
:
{
module
}
}
)
;
break
;
case
'
fragment
'
:
case
'
vertex
'
:
pipeline
=
t
.
device
.
createRenderPipeline
(
{
layout
vertex
:
{
module
}
fragment
:
{
module
targets
:
[
{
format
:
'
rgba32uint
'
}
]
}
}
)
;
break
;
}
pipelines
.
set
(
id
pipeline
)
;
}
const
gpuSampler
=
sampler
?
t
.
device
.
createSampler
(
sampler
)
:
undefined
;
const
run
=
async
(
gpuTexture
:
GPUTexture
|
GPUExternalTexture
)
=
>
{
const
resultBuffer
=
t
.
createBufferTracked
(
{
size
:
align
(
calls
.
length
*
16
256
)
usage
:
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
MAP_READ
}
)
;
const
aspect
=
getAspectForTexture
(
gpuTexture
)
;
const
runViewDescriptor
=
{
.
.
.
viewDescriptor
aspect
}
;
const
bindGroup0
=
t
.
device
.
createBindGroup
(
{
layout
:
pipeline
!
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
gpuTexture
instanceof
GPUExternalTexture
?
gpuTexture
:
gpuTexture
.
createView
(
runViewDescriptor
)
}
.
.
.
(
sampler
?
[
{
binding
:
1
resource
:
gpuSampler
!
}
]
:
[
]
)
{
binding
:
2
resource
:
{
buffer
:
dataBuffer
}
}
]
}
)
;
let
storageBuffer
:
GPUBuffer
|
undefined
;
const
encoder
=
t
.
device
.
createCommandEncoder
(
)
;
if
(
stage
=
=
=
'
compute
'
)
{
storageBuffer
=
t
.
createBufferTracked
(
{
size
:
resultBuffer
.
size
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_SRC
}
)
;
const
bindGroup1
=
t
.
device
.
createBindGroup
(
{
layout
:
pipeline
!
.
getBindGroupLayout
(
1
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
storageBuffer
}
}
]
}
)
;
const
pass
=
encoder
.
beginComputePass
(
)
;
pass
.
setPipeline
(
pipeline
!
as
GPUComputePipeline
)
;
pass
.
setBindGroup
(
0
bindGroup0
)
;
pass
.
setBindGroup
(
1
bindGroup1
)
;
pass
.
dispatchWorkgroups
(
calls
.
length
)
;
pass
.
end
(
)
;
encoder
.
copyBufferToBuffer
(
storageBuffer
0
resultBuffer
0
storageBuffer
.
size
)
;
}
else
{
const
pass
=
encoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
renderTarget
.
createView
(
)
loadOp
:
'
clear
'
storeOp
:
'
store
'
}
]
}
)
;
pass
.
setPipeline
(
pipeline
!
as
GPURenderPipeline
)
;
pass
.
setBindGroup
(
0
bindGroup0
)
;
for
(
let
i
=
0
;
i
<
calls
.
length
;
+
+
i
)
{
pass
.
setViewport
(
i
0
1
1
0
1
)
;
pass
.
draw
(
3
1
0
i
)
;
}
pass
.
end
(
)
;
encoder
.
copyTextureToBuffer
(
{
texture
:
renderTarget
}
{
buffer
:
resultBuffer
bytesPerRow
:
resultBuffer
.
size
}
[
renderTarget
.
width
1
]
)
;
}
t
.
device
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
await
resultBuffer
.
mapAsync
(
GPUMapMode
.
READ
)
;
const
view
=
TexelView
.
fromTextureDataByReference
(
resultFormat
new
Uint8Array
(
resultBuffer
.
getMappedRange
(
)
)
{
bytesPerRow
:
calls
.
length
*
16
rowsPerImage
:
1
subrectOrigin
:
[
0
0
0
]
subrectSize
:
[
calls
.
length
1
]
}
)
;
let
outIdx
=
0
;
const
out
=
new
Array
<
PerTexelComponent
<
number
>
>
(
calls
.
length
)
;
for
(
const
bin
of
binned
)
{
for
(
const
callIdx
of
bin
)
{
const
x
=
outIdx
;
out
[
callIdx
]
=
view
.
color
(
{
x
y
:
0
z
:
0
}
)
;
outIdx
+
+
;
}
}
storageBuffer
?
.
destroy
(
)
;
resultBuffer
.
destroy
(
)
;
return
out
;
}
;
return
{
run
destroy
(
)
{
dataBuffer
.
destroy
(
)
;
renderTarget
.
destroy
(
)
;
}
}
;
}
export
async
function
doTextureCalls
<
T
extends
Dimensionality
>
(
t
:
GPUTest
gpuTexture
:
GPUTexture
|
GPUExternalTexture
viewDescriptor
:
GPUTextureViewDescriptor
textureType
:
string
sampler
:
GPUSamplerDescriptor
|
undefined
calls
:
TextureCall
<
T
>
[
]
shortShaderStage
:
ShortShaderStage
)
{
const
stage
=
kShortShaderStageToShaderStage
[
shortShaderStage
]
;
const
runner
=
createTextureCallsRunner
(
t
gpuTexture
instanceof
GPUExternalTexture
?
{
format
:
'
rgba8unorm
'
dimension
:
'
2d
'
depthOrArrayLayers
:
1
sampleCount
:
1
}
:
gpuTexture
viewDescriptor
textureType
sampler
calls
stage
)
;
const
results
=
await
runner
.
run
(
gpuTexture
)
;
return
{
runner
results
}
;
}
