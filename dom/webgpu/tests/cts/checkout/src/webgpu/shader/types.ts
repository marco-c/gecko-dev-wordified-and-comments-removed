import
{
keysOf
}
from
'
.
.
/
.
.
/
common
/
util
/
data_tables
.
js
'
;
import
{
assert
}
from
'
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
align
}
from
'
.
.
/
util
/
math
.
js
'
;
const
kDefaultArrayLength
=
3
;
export
type
Requirement
=
'
never
'
|
'
may
'
|
'
must
'
;
export
type
ContainerType
=
'
scalar
'
|
'
vector
'
|
'
matrix
'
|
'
array
'
;
export
type
ScalarType
=
'
i32
'
|
'
u32
'
|
'
f16
'
|
'
f32
'
|
'
bool
'
;
export
const
HostSharableTypes
=
[
'
i32
'
'
u32
'
'
f16
'
'
f32
'
]
as
const
;
type
AlignmentAndSize
=
{
alignment
:
number
;
size
:
number
;
}
;
export
const
kScalarTypeInfo
=
{
'
i32
'
:
{
layout
:
{
alignment
:
4
size
:
4
}
supportsAtomics
:
true
arrayLength
:
1
innerLength
:
0
}
'
u32
'
:
{
layout
:
{
alignment
:
4
size
:
4
}
supportsAtomics
:
true
arrayLength
:
1
innerLength
:
0
}
'
f16
'
:
{
layout
:
{
alignment
:
2
size
:
2
}
supportsAtomics
:
false
arrayLength
:
1
innerLength
:
0
feature
:
'
shader
-
f16
'
}
'
f32
'
:
{
layout
:
{
alignment
:
4
size
:
4
}
supportsAtomics
:
false
arrayLength
:
1
innerLength
:
0
}
'
bool
'
:
{
layout
:
undefined
supportsAtomics
:
false
arrayLength
:
1
innerLength
:
0
}
}
as
const
;
export
const
kScalarTypes
=
keysOf
(
kScalarTypeInfo
)
;
export
const
kVectorContainerTypeInfo
=
{
'
vec2
'
:
{
arrayLength
:
2
innerLength
:
0
}
'
vec3
'
:
{
arrayLength
:
3
innerLength
:
0
}
'
vec4
'
:
{
arrayLength
:
4
innerLength
:
0
}
}
as
const
;
export
const
kVectorContainerTypes
=
keysOf
(
kVectorContainerTypeInfo
)
;
function
vectorLayout
(
vectorContainer
:
'
vec2
'
|
'
vec3
'
|
'
vec4
'
baseType
:
ScalarType
)
:
undefined
|
AlignmentAndSize
{
const
n
=
kVectorContainerTypeInfo
[
vectorContainer
]
.
arrayLength
;
const
scalarLayout
=
kScalarTypeInfo
[
baseType
]
.
layout
;
if
(
scalarLayout
=
=
=
undefined
)
{
return
undefined
;
}
if
(
n
=
=
=
3
)
{
return
{
alignment
:
scalarLayout
.
alignment
*
4
size
:
scalarLayout
.
size
*
3
}
;
}
return
{
alignment
:
scalarLayout
.
alignment
*
n
size
:
scalarLayout
.
size
*
n
}
;
}
export
const
kMatrixContainerTypeInfo
=
{
'
mat2x2
'
:
{
arrayLength
:
2
innerLength
:
2
}
'
mat3x2
'
:
{
arrayLength
:
3
innerLength
:
2
}
'
mat4x2
'
:
{
arrayLength
:
4
innerLength
:
2
}
'
mat2x3
'
:
{
arrayLength
:
2
innerLength
:
3
}
'
mat3x3
'
:
{
arrayLength
:
3
innerLength
:
3
}
'
mat4x3
'
:
{
arrayLength
:
4
innerLength
:
3
}
'
mat2x4
'
:
{
arrayLength
:
2
innerLength
:
4
}
'
mat3x4
'
:
{
arrayLength
:
3
innerLength
:
4
}
'
mat4x4
'
:
{
arrayLength
:
4
innerLength
:
4
}
}
as
const
;
export
const
kMatrixContainerTypes
=
keysOf
(
kMatrixContainerTypeInfo
)
;
export
const
kMatrixContainerTypeLayoutInfo
=
{
'
f16
'
:
{
'
mat2x2
'
:
{
layout
:
{
alignment
:
4
size
:
8
}
}
'
mat3x2
'
:
{
layout
:
{
alignment
:
4
size
:
12
}
}
'
mat4x2
'
:
{
layout
:
{
alignment
:
4
size
:
16
}
}
'
mat2x3
'
:
{
layout
:
{
alignment
:
8
size
:
16
}
}
'
mat3x3
'
:
{
layout
:
{
alignment
:
8
size
:
24
}
}
'
mat4x3
'
:
{
layout
:
{
alignment
:
8
size
:
32
}
}
'
mat2x4
'
:
{
layout
:
{
alignment
:
8
size
:
16
}
}
'
mat3x4
'
:
{
layout
:
{
alignment
:
8
size
:
24
}
}
'
mat4x4
'
:
{
layout
:
{
alignment
:
8
size
:
32
}
}
}
'
f32
'
:
{
'
mat2x2
'
:
{
layout
:
{
alignment
:
8
size
:
16
}
}
'
mat3x2
'
:
{
layout
:
{
alignment
:
8
size
:
24
}
}
'
mat4x2
'
:
{
layout
:
{
alignment
:
8
size
:
32
}
}
'
mat2x3
'
:
{
layout
:
{
alignment
:
16
size
:
32
}
}
'
mat3x3
'
:
{
layout
:
{
alignment
:
16
size
:
48
}
}
'
mat4x3
'
:
{
layout
:
{
alignment
:
16
size
:
64
}
}
'
mat2x4
'
:
{
layout
:
{
alignment
:
16
size
:
32
}
}
'
mat3x4
'
:
{
layout
:
{
alignment
:
16
size
:
48
}
}
'
mat4x4
'
:
{
layout
:
{
alignment
:
16
size
:
64
}
}
}
}
as
const
;
export
type
AddressSpace
=
'
storage
'
|
'
uniform
'
|
'
private
'
|
'
function
'
|
'
workgroup
'
|
'
handle
'
;
export
type
AccessMode
=
'
read
'
|
'
write
'
|
'
read_write
'
;
export
type
Scope
=
'
module
'
|
'
function
'
;
export
const
kAccessModeInfo
=
{
read
:
{
read
:
true
write
:
false
}
write
:
{
read
:
false
write
:
true
}
read_write
:
{
read
:
true
write
:
true
}
}
as
const
;
export
type
AddressSpaceInfo
=
{
scope
:
Scope
;
binding
:
boolean
;
spell
:
Requirement
;
accessModes
:
readonly
AccessMode
[
]
;
spellAccessMode
:
Requirement
;
}
;
export
const
kAddressSpaceInfo
:
Record
<
string
AddressSpaceInfo
>
=
{
storage
:
{
scope
:
'
module
'
binding
:
true
spell
:
'
must
'
accessModes
:
[
'
read
'
'
read_write
'
]
spellAccessMode
:
'
may
'
}
uniform
:
{
scope
:
'
module
'
binding
:
true
spell
:
'
must
'
accessModes
:
[
'
read
'
]
spellAccessMode
:
'
never
'
}
private
:
{
scope
:
'
module
'
binding
:
false
spell
:
'
must
'
accessModes
:
[
'
read_write
'
]
spellAccessMode
:
'
never
'
}
workgroup
:
{
scope
:
'
module
'
binding
:
false
spell
:
'
must
'
accessModes
:
[
'
read_write
'
]
spellAccessMode
:
'
never
'
}
function
:
{
scope
:
'
function
'
binding
:
false
spell
:
'
may
'
accessModes
:
[
'
read_write
'
]
spellAccessMode
:
'
never
'
}
handle
:
{
scope
:
'
module
'
binding
:
true
spell
:
'
never
'
accessModes
:
[
]
spellAccessMode
:
'
never
'
}
}
as
const
;
export
function
*
generateTypes
(
{
addressSpace
baseType
containerType
isAtomic
=
false
}
:
{
addressSpace
:
AddressSpace
;
baseType
:
ScalarType
;
containerType
:
ContainerType
;
isAtomic
?
:
boolean
;
}
)
:
Generator
<
{
type
:
string
;
_kTypeInfo
:
{
elementBaseType
:
string
;
layout
:
undefined
|
AlignmentAndSize
;
supportsAtomics
:
boolean
;
arrayLength
:
number
;
innerLength
?
:
number
;
accessSuffixes
?
:
string
[
]
;
}
;
}
void
>
{
const
scalarInfo
=
kScalarTypeInfo
[
baseType
]
;
if
(
isAtomic
)
{
assert
(
scalarInfo
.
supportsAtomics
'
type
does
not
support
atomics
'
)
;
assert
(
containerType
=
=
=
'
scalar
'
|
|
containerType
=
=
=
'
array
'
"
can
only
generate
atomic
inner
types
with
containerType
'
scalar
'
or
'
array
'
"
)
;
}
const
scalarType
=
isAtomic
?
atomic
<
{
baseType
}
>
:
baseType
;
if
(
addressSpace
=
=
=
'
storage
'
|
|
addressSpace
=
=
=
'
uniform
'
)
{
assert
(
isHostSharable
(
baseType
)
'
type
'
+
baseType
.
toString
(
)
+
'
is
not
host
sharable
'
)
;
}
if
(
containerType
=
=
=
'
scalar
'
)
{
yield
{
type
:
{
scalarType
}
_kTypeInfo
:
{
elementBaseType
:
{
scalarType
}
.
.
.
scalarInfo
}
}
;
}
if
(
containerType
=
=
=
'
vector
'
)
{
for
(
const
vectorType
of
kVectorContainerTypes
)
{
yield
{
type
:
{
vectorType
}
<
{
scalarType
}
>
_kTypeInfo
:
{
elementBaseType
:
baseType
.
.
.
kVectorContainerTypeInfo
[
vectorType
]
layout
:
vectorLayout
(
vectorType
scalarType
as
ScalarType
)
supportsAtomics
:
false
}
}
;
}
}
if
(
containerType
=
=
=
'
matrix
'
)
{
if
(
baseType
=
=
=
'
f16
'
|
|
baseType
=
=
=
'
f32
'
)
{
for
(
const
matrixType
of
kMatrixContainerTypes
)
{
const
matrixDimInfo
=
kMatrixContainerTypeInfo
[
matrixType
]
;
const
matrixLayoutInfo
=
kMatrixContainerTypeLayoutInfo
[
baseType
]
[
matrixType
]
;
yield
{
type
:
{
matrixType
}
<
{
scalarType
}
>
_kTypeInfo
:
{
elementBaseType
:
vec
{
matrixDimInfo
.
innerLength
}
<
{
scalarType
}
>
.
.
.
matrixDimInfo
.
.
.
matrixLayoutInfo
supportsAtomics
:
false
}
}
;
}
}
}
if
(
containerType
=
=
=
'
array
'
)
{
let
arrayElemType
:
string
=
scalarType
;
let
arrayElementCount
:
number
=
kDefaultArrayLength
;
let
supportsAtomics
=
scalarInfo
.
supportsAtomics
;
let
layout
:
undefined
|
AlignmentAndSize
=
undefined
;
let
accessSuffixes
:
undefined
|
string
[
]
=
undefined
;
let
validLayoutForAddressSpace
=
true
;
if
(
scalarInfo
.
layout
)
{
if
(
addressSpace
=
=
=
'
uniform
'
)
{
assert
(
!
isAtomic
'
the
uniform
case
is
making
vec4
of
scalar
which
cannot
handle
atomics
'
)
;
arrayElemType
=
vec4
<
{
baseType
}
>
;
supportsAtomics
=
false
;
accessSuffixes
=
[
'
.
x
'
'
.
y
'
'
.
z
'
'
.
w
'
]
;
const
arrayElemLayout
=
vectorLayout
(
'
vec4
'
baseType
)
as
AlignmentAndSize
;
validLayoutForAddressSpace
=
arrayElemLayout
.
alignment
%
16
=
=
=
0
;
arrayElementCount
=
align
(
arrayElementCount
4
)
/
4
;
const
arrayByteSize
=
arrayElementCount
*
arrayElemLayout
.
size
;
layout
=
{
alignment
:
arrayElemLayout
.
alignment
size
:
arrayByteSize
}
;
}
else
{
const
stride
=
arrayStride
(
scalarInfo
.
layout
)
;
let
arrayByteSize
=
arrayElementCount
*
stride
;
if
(
addressSpace
=
=
=
'
storage
'
)
{
while
(
arrayByteSize
%
4
>
0
)
{
arrayElementCount
+
+
;
arrayByteSize
=
arrayElementCount
*
stride
;
}
}
layout
=
{
alignment
:
scalarInfo
.
layout
.
alignment
size
:
arrayByteSize
}
;
}
}
const
arrayTypeInfo
=
{
elementBaseType
:
{
baseType
}
arrayLength
:
arrayElementCount
layout
supportsAtomics
accessSuffixes
}
;
if
(
validLayoutForAddressSpace
)
{
yield
{
type
:
array
<
{
arrayElemType
}
{
arrayElementCount
}
>
_kTypeInfo
:
arrayTypeInfo
}
;
if
(
addressSpace
=
=
=
'
storage
'
)
{
yield
{
type
:
array
<
{
arrayElemType
}
>
_kTypeInfo
:
arrayTypeInfo
}
;
}
}
}
function
arrayStride
(
elementLayout
:
AlignmentAndSize
)
{
return
align
(
elementLayout
.
size
elementLayout
.
alignment
)
;
}
function
isHostSharable
(
baseType
:
ScalarType
)
{
for
(
const
sharableType
of
HostSharableTypes
)
{
if
(
sharableType
=
=
=
baseType
)
return
true
;
}
return
false
;
}
}
export
function
supportsAtomics
(
p
:
{
addressSpace
:
string
;
storageMode
:
AccessMode
|
undefined
;
access
:
string
;
containerType
:
ContainerType
;
}
)
{
return
(
(
(
p
.
addressSpace
=
=
=
'
storage
'
&
&
p
.
storageMode
=
=
=
'
read_write
'
)
|
|
p
.
addressSpace
=
=
=
'
workgroup
'
)
&
&
(
p
.
containerType
=
=
=
'
scalar
'
|
|
p
.
containerType
=
=
=
'
array
'
)
)
;
}
export
function
*
supportedScalarTypes
(
p
:
{
isAtomic
:
boolean
;
addressSpace
:
string
}
)
{
for
(
const
scalarType
of
kScalarTypes
)
{
const
info
=
kScalarTypeInfo
[
scalarType
]
;
if
(
p
.
isAtomic
&
&
!
info
.
supportsAtomics
)
continue
;
const
isHostShared
=
p
.
addressSpace
=
=
=
'
storage
'
|
|
p
.
addressSpace
=
=
=
'
uniform
'
;
if
(
isHostShared
&
&
info
.
layout
=
=
=
undefined
)
continue
;
yield
scalarType
;
}
}
