import
{
GPUTest
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
gpu_test
.
js
'
;
import
{
Type
Value
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
util
/
conversion
.
js
'
;
import
{
Case
}
from
'
.
.
/
.
.
/
case
.
js
'
;
import
{
toComparator
}
from
'
.
.
/
.
.
/
expectation
.
js
'
;
import
{
packScalarsToVector
}
from
'
.
.
/
.
.
/
expression
.
js
'
;
export
function
runDerivativeTest
(
t
:
GPUTest
cases
:
Case
[
]
builtin
:
string
non_uniform_discard
:
boolean
vectorize
?
:
number
)
{
let
type
:
Type
=
Type
.
f32
;
if
(
vectorize
!
=
=
undefined
)
{
const
packed
=
packScalarsToVector
(
[
type
type
]
type
cases
vectorize
)
;
cases
=
packed
.
cases
;
type
=
packed
.
resultType
;
}
const
dir
=
builtin
[
3
]
;
let
valueStride
=
4
;
let
wgslType
=
'
f32
'
;
if
(
vectorize
)
{
wgslType
=
vec
{
vectorize
}
f
;
valueStride
=
vectorize
*
4
;
if
(
vectorize
=
=
=
3
)
{
valueStride
=
16
;
}
}
const
code
=
struct
CaseInfo
{
builtin
(
position
)
position
:
vec4f
location
(
0
)
interpolate
(
flat
)
quad_idx
:
u32
}
vertex
fn
vert
(
builtin
(
vertex_index
)
vertex_idx
:
u32
builtin
(
instance_index
)
instance_idx
:
u32
)
-
>
CaseInfo
{
const
kVertices
=
array
(
vec2f
(
-
2
-
2
)
vec2f
(
2
-
2
)
vec2f
(
0
2
)
)
;
return
CaseInfo
(
vec4
(
kVertices
[
vertex_idx
]
0
1
)
instance_idx
)
;
}
group
(
0
)
binding
(
0
)
var
<
storage
read
>
inputs
:
array
<
{
wgslType
}
>
;
group
(
0
)
binding
(
1
)
var
<
storage
read_write
>
outputs
:
array
<
{
wgslType
}
>
;
fragment
fn
frag
(
info
:
CaseInfo
)
{
let
case_idx
=
u32
(
info
.
position
.
{
dir
=
=
=
'
x
'
?
'
y
'
:
'
x
'
}
)
;
let
inv_idx
=
u32
(
info
.
position
.
{
dir
}
)
;
let
index
=
info
.
quad_idx
*
4
+
case_idx
*
2
+
inv_idx
;
let
input
=
inputs
[
index
]
;
{
non_uniform_discard
?
'
if
inv_idx
=
=
0
{
discard
;
}
'
:
'
'
}
outputs
[
index
]
=
{
builtin
}
(
input
)
;
}
;
const
module
=
t
.
device
.
createShaderModule
(
{
code
}
)
;
const
pipeline
=
t
.
device
.
createRenderPipeline
(
{
layout
:
'
auto
'
vertex
:
{
module
}
fragment
:
{
module
targets
:
[
{
format
:
'
rgba8unorm
'
writeMask
:
0
}
]
}
}
)
;
const
bufferSize
=
cases
.
length
*
2
*
valueStride
;
const
inputBuffer
=
t
.
device
.
createBuffer
(
{
size
:
bufferSize
usage
:
GPUBufferUsage
.
STORAGE
mappedAtCreation
:
true
}
)
;
const
outputBuffer
=
t
.
device
.
createBuffer
(
{
size
:
bufferSize
usage
:
GPUBufferUsage
.
STORAGE
|
GPUBufferUsage
.
COPY_SRC
}
)
;
const
valuesData
=
new
Uint8Array
(
inputBuffer
.
getMappedRange
(
)
)
;
for
(
let
i
=
0
;
i
<
cases
.
length
;
i
+
+
)
{
const
inputs
=
cases
[
i
]
.
input
as
ReadonlyArray
<
Value
>
;
inputs
[
0
]
.
copyTo
(
valuesData
(
i
*
2
+
1
)
*
valueStride
)
;
inputs
[
1
]
.
copyTo
(
valuesData
i
*
2
*
valueStride
)
;
}
inputBuffer
.
unmap
(
)
;
const
group
=
t
.
device
.
createBindGroup
(
{
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
inputBuffer
}
}
{
binding
:
1
resource
:
{
buffer
:
outputBuffer
}
}
]
layout
:
pipeline
.
getBindGroupLayout
(
0
)
}
)
;
const
colorAttachment
=
t
.
device
.
createTexture
(
{
size
:
{
width
:
2
height
:
2
}
format
:
'
rgba8unorm
'
usage
:
GPUTextureUsage
.
RENDER_ATTACHMENT
}
)
;
const
encoder
=
t
.
device
.
createCommandEncoder
(
)
;
const
pass
=
encoder
.
beginRenderPass
(
{
colorAttachments
:
[
{
view
:
colorAttachment
.
createView
(
)
loadOp
:
'
clear
'
storeOp
:
'
discard
'
}
]
}
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
group
)
;
for
(
let
quad
=
0
;
quad
<
cases
.
length
/
2
;
quad
+
+
)
{
pass
.
draw
(
3
1
undefined
quad
)
;
}
pass
.
end
(
)
;
t
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
t
.
expectGPUBufferValuesPassCheck
(
outputBuffer
(
outputData
:
Uint8Array
)
=
>
{
for
(
let
i
=
0
;
i
<
cases
.
length
;
i
+
+
)
{
const
c
=
cases
[
i
]
;
for
(
let
d
=
0
;
d
<
2
;
d
+
+
)
{
if
(
non_uniform_discard
&
&
d
=
=
=
0
)
{
continue
;
}
const
index
=
(
i
*
2
+
d
)
*
valueStride
;
const
result
=
type
.
read
(
outputData
index
)
;
const
cmp
=
toComparator
(
c
.
expected
)
.
compare
(
result
)
;
if
(
!
cmp
.
matched
)
{
if
(
!
builtin
.
endsWith
(
'
Fine
'
)
)
{
const
c0
=
cases
[
i
%
2
=
=
=
0
?
i
+
1
:
i
-
1
]
;
const
cmp0
=
toComparator
(
c0
.
expected
)
.
compare
(
result
)
;
if
(
!
cmp0
.
matched
)
{
return
new
Error
(
1st
pair
:
(
{
(
c
.
input
as
Value
[
]
)
.
join
(
'
'
)
}
)
expected
:
{
cmp
.
expected
}
2nd
pair
:
(
{
(
c0
.
input
as
Value
[
]
)
.
join
(
'
'
)
}
)
expected
:
{
cmp0
.
expected
}
returned
:
{
result
}
)
;
}
}
else
{
return
new
Error
(
inputs
:
(
{
(
c
.
input
as
Value
[
]
)
.
join
(
'
'
)
}
)
expected
:
{
cmp
.
expected
}
returned
:
{
result
}
)
;
}
}
}
}
return
undefined
;
}
{
type
:
Uint8Array
typedLength
:
bufferSize
}
)
;
}
