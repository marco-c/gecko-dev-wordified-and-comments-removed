import
{
globalTestConfig
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
framework
/
test_config
.
js
'
;
import
{
assert
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
GPUTest
}
from
'
.
.
/
.
.
/
.
.
/
gpu_test
.
js
'
;
import
{
compare
Comparator
anyOf
}
from
'
.
.
/
.
.
/
.
.
/
util
/
compare
.
js
'
;
import
{
ScalarType
Scalar
Type
TypeVec
TypeU32
Value
Vector
VectorType
f32
u32
i32
}
from
'
.
.
/
.
.
/
.
.
/
util
/
conversion
.
js
'
;
import
{
BinaryToInterval
F32Interval
PointToInterval
PointToVector
TernaryToInterval
VectorPairToInterval
VectorPairToVector
VectorToInterval
VectorToVector
}
from
'
.
.
/
.
.
/
.
.
/
util
/
f32_interval
.
js
'
;
import
{
cartesianProduct
quantizeToF32
quantizeToU32
}
from
'
.
.
/
.
.
/
.
.
/
util
/
math
.
js
'
;
export
type
Expectation
=
Value
|
F32Interval
|
F32Interval
[
]
|
Comparator
;
function
isComparator
(
e
:
Expectation
)
:
boolean
{
return
!
(
e
instanceof
F32Interval
|
|
e
instanceof
Scalar
|
|
e
instanceof
Vector
|
|
e
instanceof
Array
)
;
}
export
function
toComparator
(
input
:
Expectation
)
:
Comparator
{
if
(
!
isComparator
(
input
)
)
{
return
got
=
>
compare
(
got
input
as
Value
)
;
}
return
input
as
Comparator
;
}
export
type
Case
=
{
input
:
Value
|
Array
<
Value
>
;
expected
:
Expectation
;
}
;
export
type
CaseList
=
Array
<
Case
>
;
export
type
InputSource
=
|
'
const
'
|
'
uniform
'
|
'
storage_r
'
|
'
storage_rw
'
;
export
const
allInputSources
:
InputSource
[
]
=
[
'
const
'
'
uniform
'
'
storage_r
'
'
storage_rw
'
]
;
export
type
Config
=
{
inputSource
:
InputSource
;
vectorize
?
:
number
;
}
;
function
storageType
(
ty
:
Type
)
:
Type
{
if
(
ty
instanceof
ScalarType
)
{
if
(
ty
.
kind
=
=
=
'
bool
'
)
{
return
TypeU32
;
}
}
if
(
ty
instanceof
VectorType
)
{
return
TypeVec
(
ty
.
width
storageType
(
ty
.
elementType
)
as
ScalarType
)
;
}
return
ty
;
}
function
fromStorage
(
ty
:
Type
expr
:
string
)
:
string
{
if
(
ty
instanceof
ScalarType
)
{
if
(
ty
.
kind
=
=
=
'
bool
'
)
{
return
{
expr
}
!
=
0u
;
}
}
if
(
ty
instanceof
VectorType
)
{
if
(
ty
.
elementType
.
kind
=
=
=
'
bool
'
)
{
return
{
expr
}
!
=
vec
{
ty
.
width
}
<
u32
>
(
0u
)
;
}
}
return
expr
;
}
function
toStorage
(
ty
:
Type
expr
:
string
)
:
string
{
if
(
ty
instanceof
ScalarType
)
{
if
(
ty
.
kind
=
=
=
'
bool
'
)
{
return
select
(
0u
1u
{
expr
}
)
;
}
}
if
(
ty
instanceof
VectorType
)
{
if
(
ty
.
elementType
.
kind
=
=
=
'
bool
'
)
{
return
select
(
vec
{
ty
.
width
}
<
u32
>
(
0u
)
vec
{
ty
.
width
}
<
u32
>
(
1u
)
{
expr
}
)
;
}
}
return
expr
;
}
const
kValueStride
=
16
;
export
interface
ExpressionBuilder
{
(
values
:
Array
<
string
>
)
:
string
;
}
type
PipelineCache
=
Map
<
String
GPUComputePipeline
>
;
function
getOrCreate
<
K
V
>
(
map
:
Map
<
K
V
>
key
:
K
create
:
(
)
=
>
V
)
{
const
existing
=
map
.
get
(
key
)
;
if
(
existing
!
=
=
undefined
)
{
return
existing
;
}
const
value
=
create
(
)
;
map
.
set
(
key
value
)
;
return
value
;
}
export
async
function
run
(
t
:
GPUTest
expressionBuilder
:
ExpressionBuilder
parameterTypes
:
Array
<
Type
>
returnType
:
Type
cfg
:
Config
=
{
inputSource
:
'
storage_r
'
}
cases
:
CaseList
)
{
if
(
cfg
.
vectorize
!
=
=
undefined
)
{
const
packed
=
packScalarsToVector
(
parameterTypes
returnType
cases
cfg
.
vectorize
)
;
cases
=
packed
.
cases
;
parameterTypes
=
packed
.
parameterTypes
;
returnType
=
packed
.
returnType
;
}
const
casesPerBatch
=
(
function
(
)
{
switch
(
cfg
.
inputSource
)
{
case
'
const
'
:
return
32
;
case
'
uniform
'
:
return
Math
.
floor
(
Math
.
min
(
1024
*
2
t
.
device
.
limits
.
maxUniformBufferBindingSize
)
/
(
parameterTypes
.
length
*
kValueStride
)
)
;
case
'
storage_r
'
:
case
'
storage_rw
'
:
return
Math
.
floor
(
t
.
device
.
limits
.
maxStorageBufferBindingSize
/
(
parameterTypes
.
length
*
kValueStride
)
)
;
}
}
)
(
)
;
const
pipelineCache
=
new
Map
<
String
GPUComputePipeline
>
(
)
;
const
checkResults
:
Array
<
Promise
<
void
>
>
=
[
]
;
for
(
let
i
=
0
;
i
<
cases
.
length
;
i
+
=
casesPerBatch
)
{
const
batchCases
=
cases
.
slice
(
i
Math
.
min
(
i
+
casesPerBatch
cases
.
length
)
)
;
t
.
device
.
pushErrorScope
(
'
validation
'
)
;
const
checkBatch
=
submitBatch
(
t
expressionBuilder
parameterTypes
returnType
batchCases
cfg
.
inputSource
pipelineCache
)
;
checkResults
.
push
(
t
.
device
.
popErrorScope
(
)
.
then
(
error
=
>
{
if
(
error
=
=
=
null
)
{
checkBatch
(
)
;
}
else
{
t
.
fail
(
error
.
message
)
;
}
}
)
)
;
}
await
Promise
.
all
(
checkResults
)
;
}
function
submitBatch
(
t
:
GPUTest
expressionBuilder
:
ExpressionBuilder
parameterTypes
:
Array
<
Type
>
returnType
:
Type
cases
:
CaseList
inputSource
:
InputSource
pipelineCache
:
PipelineCache
)
:
(
)
=
>
void
{
const
outputBufferSize
=
cases
.
length
*
kValueStride
;
const
outputBuffer
=
t
.
device
.
createBuffer
(
{
size
:
outputBufferSize
usage
:
GPUBufferUsage
.
COPY_SRC
|
GPUBufferUsage
.
COPY_DST
|
GPUBufferUsage
.
STORAGE
}
)
;
const
[
pipeline
group
]
=
buildPipeline
(
t
expressionBuilder
parameterTypes
returnType
cases
inputSource
outputBuffer
pipelineCache
)
;
const
encoder
=
t
.
device
.
createCommandEncoder
(
)
;
const
pass
=
encoder
.
beginComputePass
(
)
;
pass
.
setPipeline
(
pipeline
)
;
pass
.
setBindGroup
(
0
group
)
;
pass
.
dispatchWorkgroups
(
1
)
;
pass
.
end
(
)
;
globalTestConfig
.
testHeartbeatCallback
(
)
;
t
.
queue
.
submit
(
[
encoder
.
finish
(
)
]
)
;
return
(
)
=
>
{
const
checkExpectation
=
(
outputData
:
Uint8Array
)
=
>
{
const
outputs
=
new
Array
<
Value
>
(
cases
.
length
)
;
for
(
let
i
=
0
;
i
<
cases
.
length
;
i
+
+
)
{
outputs
[
i
]
=
returnType
.
read
(
outputData
i
*
kValueStride
)
;
}
const
errs
:
string
[
]
=
[
]
;
for
(
let
caseIdx
=
0
;
caseIdx
<
cases
.
length
;
caseIdx
+
+
)
{
const
c
=
cases
[
caseIdx
]
;
const
got
=
outputs
[
caseIdx
]
;
const
cmp
=
toComparator
(
c
.
expected
)
(
got
)
;
if
(
!
cmp
.
matched
)
{
errs
.
push
(
(
{
c
.
input
instanceof
Array
?
c
.
input
.
join
(
'
'
)
:
c
.
input
}
)
returned
:
{
cmp
.
got
}
expected
:
{
cmp
.
expected
}
)
;
}
}
return
errs
.
length
>
0
?
new
Error
(
errs
.
join
(
'
\
n
\
n
'
)
)
:
undefined
;
}
;
globalTestConfig
.
testHeartbeatCallback
(
)
;
t
.
expectGPUBufferValuesPassCheck
(
outputBuffer
checkExpectation
{
type
:
Uint8Array
typedLength
:
outputBufferSize
}
)
;
}
;
}
function
ith
<
T
>
(
v
:
T
|
T
[
]
i
:
number
)
:
T
{
if
(
v
instanceof
Array
)
{
assert
(
i
<
v
.
length
)
;
return
v
[
i
]
;
}
assert
(
i
=
=
=
0
)
;
return
v
;
}
function
buildPipeline
(
t
:
GPUTest
expressionBuilder
:
ExpressionBuilder
parameterTypes
:
Array
<
Type
>
returnType
:
Type
cases
:
CaseList
inputSource
:
InputSource
outputBuffer
:
GPUBuffer
pipelineCache
:
PipelineCache
)
:
[
GPUComputePipeline
GPUBindGroup
]
{
const
wgslStorageType
=
storageType
(
returnType
)
;
const
wgslOutputs
=
struct
Output
{
size
(
{
kValueStride
}
)
value
:
{
wgslStorageType
}
}
;
group
(
0
)
binding
(
0
)
var
<
storage
read_write
>
outputs
:
array
<
Output
{
cases
.
length
}
>
;
;
switch
(
inputSource
)
{
case
'
const
'
:
{
const
wgslValues
=
cases
.
map
(
c
=
>
{
const
args
=
parameterTypes
.
map
(
(
_
i
)
=
>
(
{
ith
(
c
.
input
i
)
.
wgsl
(
)
}
)
)
;
return
{
toStorage
(
returnType
expressionBuilder
(
args
)
)
}
;
}
)
;
const
wgslBody
=
globalTestConfig
.
unrollConstEvalLoops
?
wgslValues
.
map
(
(
_
i
)
=
>
outputs
[
{
i
}
]
.
value
=
values
[
{
i
}
]
;
)
.
join
(
'
\
n
'
)
:
for
(
var
i
=
0u
;
i
<
{
cases
.
length
}
;
i
+
+
)
{
outputs
[
i
]
.
value
=
values
[
i
]
;
}
;
const
source
=
{
wgslOutputs
}
const
values
=
array
<
{
wgslStorageType
}
{
cases
.
length
}
>
(
{
wgslValues
.
join
(
'
\
n
'
)
}
)
;
compute
workgroup_size
(
1
)
fn
main
(
)
{
{
wgslBody
}
}
;
const
module
=
t
.
device
.
createShaderModule
(
{
code
:
source
}
)
;
const
pipeline
=
t
.
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
entryPoint
:
'
main
'
}
}
)
;
const
group
=
t
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
outputBuffer
}
}
]
}
)
;
return
[
pipeline
group
]
;
}
case
'
uniform
'
:
case
'
storage_r
'
:
case
'
storage_rw
'
:
{
const
paramExpr
=
(
ty
:
Type
i
:
number
)
=
>
fromStorage
(
ty
inputs
[
i
]
.
param
{
i
}
)
;
const
expr
=
toStorage
(
returnType
expressionBuilder
(
parameterTypes
.
map
(
paramExpr
)
)
)
;
const
wgslInputVar
=
(
function
(
)
{
switch
(
inputSource
)
{
case
'
storage_r
'
:
return
'
var
<
storage
read
>
'
;
case
'
storage_rw
'
:
return
'
var
<
storage
read_write
>
'
;
case
'
uniform
'
:
return
'
var
<
uniform
>
'
;
}
}
)
(
)
;
const
source
=
struct
Input
{
{
parameterTypes
.
map
(
(
ty
i
)
=
>
size
(
{
kValueStride
}
)
param
{
i
}
:
{
storageType
(
ty
)
}
)
.
join
(
'
\
n
'
)
}
}
;
{
wgslOutputs
}
group
(
0
)
binding
(
1
)
{
wgslInputVar
}
inputs
:
array
<
Input
{
cases
.
length
}
>
;
compute
workgroup_size
(
1
)
fn
main
(
)
{
for
(
var
i
=
0
;
i
<
{
cases
.
length
}
;
i
+
+
)
{
outputs
[
i
]
.
value
=
{
expr
}
;
}
}
;
const
inputSize
=
cases
.
length
*
parameterTypes
.
length
*
kValueStride
;
const
inputData
=
new
Uint8Array
(
inputSize
)
;
{
const
caseStride
=
kValueStride
*
parameterTypes
.
length
;
for
(
let
caseIdx
=
0
;
caseIdx
<
cases
.
length
;
caseIdx
+
+
)
{
const
caseBase
=
caseIdx
*
caseStride
;
for
(
let
paramIdx
=
0
;
paramIdx
<
parameterTypes
.
length
;
paramIdx
+
+
)
{
const
offset
=
caseBase
+
paramIdx
*
kValueStride
;
const
params
=
cases
[
caseIdx
]
.
input
;
if
(
params
instanceof
Array
)
{
params
[
paramIdx
]
.
copyTo
(
inputData
offset
)
;
}
else
{
params
.
copyTo
(
inputData
offset
)
;
}
}
}
}
const
pipeline
=
getOrCreate
(
pipelineCache
source
(
)
=
>
{
const
module
=
t
.
device
.
createShaderModule
(
{
code
:
source
}
)
;
return
t
.
device
.
createComputePipeline
(
{
layout
:
'
auto
'
compute
:
{
module
entryPoint
:
'
main
'
}
}
)
;
}
)
;
const
inputBuffer
=
t
.
makeBufferWithContents
(
inputData
GPUBufferUsage
.
COPY_SRC
|
(
inputSource
=
=
=
'
uniform
'
?
GPUBufferUsage
.
UNIFORM
:
GPUBufferUsage
.
STORAGE
)
)
;
const
group
=
t
.
device
.
createBindGroup
(
{
layout
:
pipeline
.
getBindGroupLayout
(
0
)
entries
:
[
{
binding
:
0
resource
:
{
buffer
:
outputBuffer
}
}
{
binding
:
1
resource
:
{
buffer
:
inputBuffer
}
}
]
}
)
;
return
[
pipeline
group
]
;
}
}
}
function
packScalarsToVector
(
parameterTypes
:
Array
<
Type
>
returnType
:
Type
cases
:
CaseList
vectorWidth
:
number
)
:
{
cases
:
CaseList
;
parameterTypes
:
Array
<
Type
>
;
returnType
:
Type
}
{
for
(
let
i
=
0
;
i
<
parameterTypes
.
length
;
i
+
+
)
{
const
ty
=
parameterTypes
[
i
]
;
if
(
!
(
ty
instanceof
ScalarType
)
)
{
throw
new
Error
(
packScalarsToVector
(
)
can
only
be
used
on
scalar
parameter
types
but
the
{
i
}
'
th
parameter
type
is
a
{
ty
}
'
)
;
}
}
if
(
!
(
returnType
instanceof
ScalarType
)
)
{
throw
new
Error
(
packScalarsToVector
(
)
can
only
be
used
with
a
scalar
return
type
but
the
return
type
is
a
{
returnType
}
'
)
;
}
const
packedCases
:
Array
<
Case
>
=
[
]
;
const
packedParameterTypes
=
parameterTypes
.
map
(
p
=
>
TypeVec
(
vectorWidth
p
as
ScalarType
)
)
;
const
packedReturnType
=
new
VectorType
(
vectorWidth
returnType
)
;
const
clampCaseIdx
=
(
idx
:
number
)
=
>
Math
.
min
(
idx
cases
.
length
-
1
)
;
let
caseIdx
=
0
;
while
(
caseIdx
<
cases
.
length
)
{
const
packedInputs
=
new
Array
<
Vector
>
(
parameterTypes
.
length
)
;
for
(
let
paramIdx
=
0
;
paramIdx
<
parameterTypes
.
length
;
paramIdx
+
+
)
{
const
inputElements
=
new
Array
<
Scalar
>
(
vectorWidth
)
;
for
(
let
i
=
0
;
i
<
vectorWidth
;
i
+
+
)
{
const
input
=
cases
[
clampCaseIdx
(
caseIdx
+
i
)
]
.
input
;
inputElements
[
i
]
=
(
input
instanceof
Array
?
input
[
paramIdx
]
:
input
)
as
Scalar
;
}
packedInputs
[
paramIdx
]
=
new
Vector
(
inputElements
)
;
}
const
comparators
=
new
Array
<
Comparator
>
(
vectorWidth
)
;
for
(
let
i
=
0
;
i
<
vectorWidth
;
i
+
+
)
{
comparators
[
i
]
=
toComparator
(
cases
[
clampCaseIdx
(
caseIdx
+
i
)
]
.
expected
)
;
}
const
packedComparator
=
(
got
:
Value
)
=
>
{
let
matched
=
true
;
const
gElements
=
new
Array
<
string
>
(
vectorWidth
)
;
const
eElements
=
new
Array
<
string
>
(
vectorWidth
)
;
for
(
let
i
=
0
;
i
<
vectorWidth
;
i
+
+
)
{
const
d
=
comparators
[
i
]
(
(
got
as
Vector
)
.
elements
[
i
]
)
;
matched
=
matched
&
&
d
.
matched
;
gElements
[
i
]
=
d
.
got
;
eElements
[
i
]
=
d
.
expected
;
}
return
{
matched
got
:
{
packedReturnType
}
(
{
gElements
.
join
(
'
'
)
}
)
expected
:
{
packedReturnType
}
(
{
eElements
.
join
(
'
'
)
}
)
}
;
}
;
packedCases
.
push
(
{
input
:
packedInputs
expected
:
packedComparator
}
)
;
caseIdx
+
=
vectorWidth
;
}
return
{
cases
:
packedCases
parameterTypes
:
packedParameterTypes
returnType
:
packedReturnType
}
;
}
export
type
IntervalFilter
=
|
'
f32
-
only
'
|
'
unfiltered
'
;
function
makeUnaryToF32IntervalCase
(
param
:
number
filter
:
IntervalFilter
.
.
.
ops
:
PointToInterval
[
]
)
:
Case
|
undefined
{
param
=
quantizeToF32
(
param
)
;
const
intervals
=
ops
.
map
(
o
=
>
o
(
param
)
)
;
if
(
filter
=
=
=
'
f32
-
only
'
&
&
intervals
.
some
(
i
=
>
!
i
.
isFinite
(
)
)
)
{
return
undefined
;
}
return
{
input
:
[
f32
(
param
)
]
expected
:
anyOf
(
.
.
.
intervals
)
}
;
}
export
function
generateUnaryToF32IntervalCases
(
params
:
number
[
]
filter
:
IntervalFilter
.
.
.
ops
:
PointToInterval
[
]
)
:
Case
[
]
{
return
params
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
makeUnaryToF32IntervalCase
(
e
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
<
Case
>
(
)
)
;
}
function
makeBinaryToF32IntervalCase
(
param0
:
number
param1
:
number
filter
:
IntervalFilter
.
.
.
ops
:
BinaryToInterval
[
]
)
:
Case
|
undefined
{
param0
=
quantizeToF32
(
param0
)
;
param1
=
quantizeToF32
(
param1
)
;
const
intervals
=
ops
.
map
(
o
=
>
o
(
param0
param1
)
)
;
if
(
filter
=
=
=
'
f32
-
only
'
&
&
intervals
.
some
(
i
=
>
!
i
.
isFinite
(
)
)
)
{
return
undefined
;
}
return
{
input
:
[
f32
(
param0
)
f32
(
param1
)
]
expected
:
anyOf
(
.
.
.
intervals
)
}
;
}
export
function
generateBinaryToF32IntervalCases
(
param0s
:
number
[
]
param1s
:
number
[
]
filter
:
IntervalFilter
.
.
.
ops
:
BinaryToInterval
[
]
)
:
Case
[
]
{
return
cartesianProduct
(
param0s
param1s
)
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
makeBinaryToF32IntervalCase
(
e
[
0
]
e
[
1
]
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
<
Case
>
(
)
)
;
}
function
makeTernaryToF32IntervalCase
(
param0
:
number
param1
:
number
param2
:
number
filter
:
IntervalFilter
.
.
.
ops
:
TernaryToInterval
[
]
)
:
Case
|
undefined
{
param0
=
quantizeToF32
(
param0
)
;
param1
=
quantizeToF32
(
param1
)
;
param2
=
quantizeToF32
(
param2
)
;
const
intervals
=
ops
.
map
(
o
=
>
o
(
param0
param1
param2
)
)
;
if
(
filter
=
=
=
'
f32
-
only
'
&
&
intervals
.
some
(
i
=
>
!
i
.
isFinite
(
)
)
)
{
return
undefined
;
}
return
{
input
:
[
f32
(
param0
)
f32
(
param1
)
f32
(
param2
)
]
expected
:
anyOf
(
.
.
.
intervals
)
}
;
}
export
function
generateTernaryToF32IntervalCases
(
param0s
:
number
[
]
param1s
:
number
[
]
param2s
:
number
[
]
filter
:
IntervalFilter
.
.
.
ops
:
TernaryToInterval
[
]
)
:
Case
[
]
{
return
cartesianProduct
(
param0s
param1s
param2s
)
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
makeTernaryToF32IntervalCase
(
e
[
0
]
e
[
1
]
e
[
2
]
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
<
Case
>
(
)
)
;
}
function
makeVectorToF32IntervalCase
(
param
:
number
[
]
filter
:
IntervalFilter
.
.
.
ops
:
VectorToInterval
[
]
)
:
Case
|
undefined
{
param
=
param
.
map
(
quantizeToF32
)
;
const
param_f32
=
param
.
map
(
f32
)
;
const
intervals
=
ops
.
map
(
o
=
>
o
(
param
)
)
;
if
(
filter
=
=
=
'
f32
-
only
'
&
&
intervals
.
some
(
i
=
>
!
i
.
isFinite
(
)
)
)
{
return
undefined
;
}
return
{
input
:
[
new
Vector
(
param_f32
)
]
expected
:
anyOf
(
.
.
.
intervals
)
}
;
}
export
function
generateVectorToF32IntervalCases
(
params
:
number
[
]
[
]
filter
:
IntervalFilter
.
.
.
ops
:
VectorToInterval
[
]
)
:
Case
[
]
{
return
params
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
makeVectorToF32IntervalCase
(
e
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
<
Case
>
(
)
)
;
}
function
makeVectorPairToF32IntervalCase
(
param0
:
number
[
]
param1
:
number
[
]
filter
:
IntervalFilter
.
.
.
ops
:
VectorPairToInterval
[
]
)
:
Case
|
undefined
{
param0
=
param0
.
map
(
quantizeToF32
)
;
param1
=
param1
.
map
(
quantizeToF32
)
;
const
param0_f32
=
param0
.
map
(
f32
)
;
const
param1_f32
=
param1
.
map
(
f32
)
;
const
intervals
=
ops
.
map
(
o
=
>
o
(
param0
param1
)
)
;
if
(
filter
=
=
=
'
f32
-
only
'
&
&
intervals
.
some
(
i
=
>
!
i
.
isFinite
(
)
)
)
{
return
undefined
;
}
return
{
input
:
[
new
Vector
(
param0_f32
)
new
Vector
(
param1_f32
)
]
expected
:
anyOf
(
.
.
.
intervals
)
}
;
}
export
function
generateVectorPairToF32IntervalCases
(
param0s
:
number
[
]
[
]
param1s
:
number
[
]
[
]
filter
:
IntervalFilter
.
.
.
ops
:
VectorPairToInterval
[
]
)
:
Case
[
]
{
return
cartesianProduct
(
param0s
param1s
)
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
makeVectorPairToF32IntervalCase
(
e
[
0
]
e
[
1
]
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
<
Case
>
(
)
)
;
}
function
makeVectorToVectorCase
(
param
:
number
[
]
filter
:
IntervalFilter
.
.
.
ops
:
VectorToVector
[
]
)
:
Case
|
undefined
{
param
=
param
.
map
(
quantizeToF32
)
;
const
param_f32
=
param
.
map
(
f32
)
;
const
vectors
=
ops
.
map
(
o
=
>
o
(
param
)
)
;
if
(
filter
=
=
=
'
f32
-
only
'
&
&
vectors
.
some
(
v
=
>
!
v
.
every
(
e
=
>
e
.
isFinite
(
)
)
)
)
{
return
undefined
;
}
return
{
input
:
[
new
Vector
(
param_f32
)
]
expected
:
anyOf
(
.
.
.
vectors
)
}
;
}
export
function
generateVectorToVectorCases
(
params
:
number
[
]
[
]
filter
:
IntervalFilter
.
.
.
ops
:
VectorToVector
[
]
)
:
Case
[
]
{
return
params
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
makeVectorToVectorCase
(
e
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
<
Case
>
(
)
)
;
}
function
makeVectorPairToVectorCase
(
param0
:
number
[
]
param1
:
number
[
]
filter
:
IntervalFilter
.
.
.
ops
:
VectorPairToVector
[
]
)
:
Case
|
undefined
{
param0
=
param0
.
map
(
quantizeToF32
)
;
param1
=
param1
.
map
(
quantizeToF32
)
;
const
param0_f32
=
param0
.
map
(
f32
)
;
const
param1_f32
=
param1
.
map
(
f32
)
;
const
vectors
=
ops
.
map
(
o
=
>
o
(
param0
param1
)
)
;
if
(
filter
=
=
=
'
f32
-
only
'
&
&
vectors
.
some
(
v
=
>
!
v
.
every
(
e
=
>
e
.
isFinite
(
)
)
)
)
{
return
undefined
;
}
return
{
input
:
[
new
Vector
(
param0_f32
)
new
Vector
(
param1_f32
)
]
expected
:
anyOf
(
.
.
.
vectors
)
}
;
}
export
function
generateVectorPairToVectorCases
(
param0s
:
number
[
]
[
]
param1s
:
number
[
]
[
]
filter
:
IntervalFilter
.
.
.
ops
:
VectorPairToVector
[
]
)
:
Case
[
]
{
return
cartesianProduct
(
param0s
param1s
)
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
makeVectorPairToVectorCase
(
e
[
0
]
e
[
1
]
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
<
Case
>
(
)
)
;
}
function
makeU32ToVectorCase
(
param
:
number
filter
:
IntervalFilter
.
.
.
ops
:
PointToVector
[
]
)
:
Case
|
undefined
{
param
=
Math
.
trunc
(
param
)
;
const
param_u32
=
u32
(
param
)
;
const
vectors
=
ops
.
map
(
o
=
>
o
(
param
)
)
;
if
(
filter
=
=
=
'
f32
-
only
'
&
&
vectors
.
some
(
v
=
>
!
v
.
every
(
e
=
>
e
.
isFinite
(
)
)
)
)
{
return
undefined
;
}
return
{
input
:
param_u32
expected
:
anyOf
(
.
.
.
vectors
)
}
;
}
export
function
generateU32ToVectorCases
(
params
:
number
[
]
filter
:
IntervalFilter
.
.
.
ops
:
PointToVector
[
]
)
:
Case
[
]
{
return
params
.
reduce
(
(
cases
e
)
=
>
{
const
c
=
makeU32ToVectorCase
(
e
filter
.
.
.
ops
)
;
if
(
c
!
=
=
undefined
)
{
cases
.
push
(
c
)
;
}
return
cases
;
}
new
Array
<
Case
>
(
)
)
;
}
export
interface
BinaryToI32Op
{
(
x
:
number
y
:
number
)
:
number
|
undefined
;
}
export
function
generateBinaryToI32Cases
(
params0s
:
number
[
]
params1s
:
number
[
]
op
:
BinaryToI32Op
)
{
return
cartesianProduct
(
params0s
params1s
)
.
reduce
(
(
cases
e
)
=
>
{
const
expected
=
op
(
e
[
0
]
e
[
1
]
)
;
if
(
expected
!
=
=
undefined
)
{
cases
.
push
(
{
input
:
[
i32
(
e
[
0
]
)
i32
(
e
[
1
]
)
]
expected
:
i32
(
expected
)
}
)
;
}
return
cases
;
}
new
Array
<
Case
>
(
)
)
;
}
export
interface
BinaryToU32Op
{
(
x
:
number
y
:
number
)
:
number
|
undefined
;
}
export
function
generateBinaryToU32Cases
(
params0s
:
number
[
]
params1s
:
number
[
]
op
:
BinaryToU32Op
)
{
return
cartesianProduct
(
params0s
params1s
)
.
reduce
(
(
cases
e
)
=
>
{
const
expected
=
op
(
e
[
0
]
e
[
1
]
)
;
if
(
expected
!
=
=
undefined
)
{
cases
.
push
(
{
input
:
[
u32
(
e
[
0
]
)
u32
(
e
[
1
]
)
]
expected
:
u32
(
expected
)
}
)
;
}
return
cases
;
}
new
Array
<
Case
>
(
)
)
;
}
export
interface
BinaryOp
{
(
x
:
number
y
:
number
)
:
number
;
}
function
makeU32VectorBinaryToVectorCase
(
scalar
:
number
vector
:
number
[
]
op
:
BinaryOp
)
:
Case
{
scalar
=
quantizeToU32
(
scalar
)
;
vector
=
vector
.
map
(
quantizeToU32
)
;
const
result
=
new
Vector
(
vector
.
map
(
v
=
>
u32
(
op
(
scalar
v
)
)
)
)
;
return
{
input
:
[
u32
(
scalar
)
new
Vector
(
vector
.
map
(
u32
)
)
]
expected
:
result
}
;
}
export
function
generateU32VectorBinaryToVectorCases
(
scalars
:
number
[
]
vectors
:
number
[
]
[
]
op
:
BinaryOp
)
:
Case
[
]
{
return
scalars
.
flatMap
(
s
=
>
{
return
vectors
.
map
(
v
=
>
{
return
makeU32VectorBinaryToVectorCase
(
s
v
op
)
;
}
)
;
}
)
;
}
function
makeVectorU32BinaryToVectorCase
(
vector
:
number
[
]
scalar
:
number
op
:
BinaryOp
)
:
Case
{
vector
=
vector
.
map
(
quantizeToU32
)
;
scalar
=
quantizeToU32
(
scalar
)
;
const
result
=
new
Vector
(
vector
.
map
(
v
=
>
u32
(
op
(
v
scalar
)
)
)
)
;
return
{
input
:
[
new
Vector
(
vector
.
map
(
u32
)
)
u32
(
scalar
)
]
expected
:
result
}
;
}
export
function
generateVectorU32BinaryToVectorCases
(
vectors
:
number
[
]
[
]
scalars
:
number
[
]
op
:
BinaryOp
)
:
Case
[
]
{
return
scalars
.
flatMap
(
s
=
>
{
return
vectors
.
map
(
v
=
>
{
return
makeVectorU32BinaryToVectorCase
(
v
s
op
)
;
}
)
;
}
)
;
}
