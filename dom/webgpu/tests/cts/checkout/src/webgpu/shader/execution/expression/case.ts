import
{
crc32
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
crc32
.
js
'
;
import
{
ROArrayArray
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
types
.
js
'
;
import
{
assert
}
from
'
.
.
/
.
.
/
.
.
/
.
.
/
common
/
util
/
util
.
js
'
;
import
{
abstractInt
i32
ScalarBuilder
u32
Value
VectorValue
}
from
'
.
.
/
.
.
/
.
.
/
util
/
conversion
.
js
'
;
import
{
cartesianProduct
QuantizeFunc
quantizeToI32
quantizeToI64
quantizeToU32
}
from
'
.
.
/
.
.
/
.
.
/
util
/
math
.
js
'
;
import
{
Expectation
}
from
'
.
/
expectation
.
js
'
;
function
notUndefined
<
T
>
(
value
:
T
|
undefined
)
:
value
is
T
{
return
value
!
=
=
undefined
;
}
export
type
Case
=
{
input
:
Value
|
ReadonlyArray
<
Value
>
;
expected
:
Expectation
;
}
;
export
function
selectNCases
(
dis
:
string
n
:
number
cases
:
Case
[
]
)
:
Case
[
]
{
assert
(
n
>
0
&
&
Math
.
round
(
n
)
=
=
=
n
n
{
n
}
is
expected
to
be
a
positive
integer
)
;
const
count
=
cases
.
length
;
if
(
n
>
=
count
)
{
return
cases
;
}
const
dis_crc32
=
crc32
(
dis
)
;
return
cases
.
filter
(
c
=
>
Math
.
trunc
(
(
n
/
count
)
*
0xffff_ffff
)
>
(
crc32
(
c
.
input
.
toString
(
)
)
^
dis_crc32
)
>
>
>
0
)
;
}
export
interface
BinaryOp
<
T
>
{
(
x
:
T
y
:
T
)
:
T
|
undefined
;
}
export
interface
VectorVectorToScalarOp
<
T
>
{
(
x
:
T
[
]
y
:
T
[
]
)
:
T
|
undefined
;
}
function
makeScalarVectorBinaryToVectorCase
<
T
>
(
scalar
:
T
vector
:
readonly
T
[
]
op
:
BinaryOp
<
T
>
quantize
:
QuantizeFunc
<
T
>
scalarize
:
ScalarBuilder
<
T
>
)
:
Case
|
undefined
{
scalar
=
quantize
(
scalar
)
;
vector
=
vector
.
map
(
quantize
)
;
const
result
=
vector
.
map
(
v
=
>
op
(
scalar
v
)
)
;
if
(
result
.
includes
(
undefined
)
)
{
return
undefined
;
}
return
{
input
:
[
scalarize
(
scalar
)
new
VectorValue
(
vector
.
map
(
scalarize
)
)
]
expected
:
new
VectorValue
(
result
.
filter
(
notUndefined
)
.
map
(
scalarize
)
)
}
;
}
function
generateScalarVectorBinaryToVectorCases
<
T
>
(
scalars
:
readonly
T
[
]
vectors
:
ROArrayArray
<
T
>
op
:
BinaryOp
<
T
>
quantize
:
QuantizeFunc
<
T
>
scalarize
:
ScalarBuilder
<
T
>
)
:
Case
[
]
{
return
scalars
.
flatMap
(
s
=
>
{
return
vectors
.
map
(
v
=
>
{
return
makeScalarVectorBinaryToVectorCase
(
s
v
op
quantize
scalarize
)
;
}
)
.
filter
(
notUndefined
)
;
}
)
;
}
function
makeVectorScalarBinaryToVectorCase
<
T
>
(
vector
:
readonly
T
[
]
scalar
:
T
op
:
BinaryOp
<
T
>
quantize
:
QuantizeFunc
<
T
>
scalarize
:
ScalarBuilder
<
T
>
)
:
Case
|
undefined
{
vector
=
vector
.
map
(
quantize
)
;
scalar
=
quantize
(
scalar
)
;
const
result
=
vector
.
map
(
v
=
>
op
(
v
scalar
)
)
;
if
(
result
.
includes
(
undefined
)
)
{
return
undefined
;
}
return
{
input
:
[
new
VectorValue
(
vector
.
map
(
scalarize
)
)
scalarize
(
scalar
)
]
expected
:
new
VectorValue
(
result
.
filter
(
notUndefined
)
.
map
(
scalarize
)
)
}
;
}
function
generateVectorScalarBinaryToVectorCases
<
T
>
(
vectors
:
ROArrayArray
<
T
>
scalars
:
readonly
T
[
]
op
:
BinaryOp
<
T
>
quantize
:
QuantizeFunc
<
T
>
scalarize
:
ScalarBuilder
<
T
>
)
:
Case
[
]
{
return
scalars
.
flatMap
(
s
=
>
{
return
vectors
.
map
(
v
=
>
{
return
makeVectorScalarBinaryToVectorCase
(
v
s
op
quantize
scalarize
)
;
}
)
.
filter
(
notUndefined
)
;
}
)
;
}
export
function
generateU32VectorBinaryToVectorCases
(
scalars
:
readonly
number
[
]
vectors
:
ROArrayArray
<
number
>
op
:
BinaryOp
<
number
>
)
:
Case
[
]
{
return
generateScalarVectorBinaryToVectorCases
(
scalars
vectors
op
quantizeToU32
u32
)
;
}
export
function
generateVectorU32BinaryToVectorCases
(
vectors
:
ROArrayArray
<
number
>
scalars
:
readonly
number
[
]
op
:
BinaryOp
<
number
>
)
:
Case
[
]
{
return
generateVectorScalarBinaryToVectorCases
(
vectors
scalars
op
quantizeToU32
u32
)
;
}
export
function
generateI32VectorBinaryToVectorCases
(
scalars
:
readonly
number
[
]
vectors
:
ROArrayArray
<
number
>
op
:
BinaryOp
<
number
>
)
:
Case
[
]
{
return
generateScalarVectorBinaryToVectorCases
(
scalars
vectors
op
quantizeToI32
i32
)
;
}
export
function
generateVectorI32BinaryToVectorCases
(
vectors
:
ROArrayArray
<
number
>
scalars
:
readonly
number
[
]
op
:
BinaryOp
<
number
>
)
:
Case
[
]
{
return
generateVectorScalarBinaryToVectorCases
(
vectors
scalars
op
quantizeToI32
i32
)
;
}
export
function
generateI64VectorBinaryToVectorCases
(
scalars
:
readonly
bigint
[
]
vectors
:
ROArrayArray
<
bigint
>
op
:
BinaryOp
<
bigint
>
)
:
Case
[
]
{
return
generateScalarVectorBinaryToVectorCases
(
scalars
vectors
op
quantizeToI64
abstractInt
)
;
}
export
function
generateVectorI64BinaryToVectorCases
(
vectors
:
ROArrayArray
<
bigint
>
scalars
:
readonly
bigint
[
]
op
:
BinaryOp
<
bigint
>
)
:
Case
[
]
{
return
generateVectorScalarBinaryToVectorCases
(
vectors
scalars
op
quantizeToI64
abstractInt
)
;
}
function
generateScalarBinaryToScalarCases
<
T
>
(
param0s
:
readonly
T
[
]
param1s
:
readonly
T
[
]
op
:
BinaryOp
<
T
>
quantize
:
QuantizeFunc
<
T
>
scalarize
:
ScalarBuilder
<
T
>
)
:
Case
[
]
{
param0s
=
param0s
.
map
(
quantize
)
;
param1s
=
param1s
.
map
(
quantize
)
;
return
cartesianProduct
(
param0s
param1s
)
.
reduce
(
(
cases
e
)
=
>
{
const
expected
=
op
(
e
[
0
]
e
[
1
]
)
;
if
(
expected
!
=
=
undefined
)
{
cases
.
push
(
{
input
:
[
scalarize
(
e
[
0
]
)
scalarize
(
e
[
1
]
)
]
expected
:
scalarize
(
expected
)
}
)
;
}
return
cases
;
}
new
Array
<
Case
>
(
)
)
;
}
export
function
generateBinaryToI32Cases
(
param0s
:
readonly
number
[
]
param1s
:
readonly
number
[
]
op
:
BinaryOp
<
number
>
)
{
return
generateScalarBinaryToScalarCases
(
param0s
param1s
op
quantizeToI32
i32
)
;
}
export
function
generateBinaryToU32Cases
(
param0s
:
readonly
number
[
]
param1s
:
readonly
number
[
]
op
:
BinaryOp
<
number
>
)
{
return
generateScalarBinaryToScalarCases
(
param0s
param1s
op
quantizeToU32
u32
)
;
}
export
function
generateBinaryToI64Cases
(
param0s
:
readonly
bigint
[
]
param1s
:
readonly
bigint
[
]
op
:
BinaryOp
<
bigint
>
)
{
return
generateScalarBinaryToScalarCases
(
param0s
param1s
op
quantizeToI64
abstractInt
)
;
}
function
makeVectorVectorToScalarCase
<
T
>
(
param0
:
readonly
T
[
]
param1
:
readonly
T
[
]
op
:
VectorVectorToScalarOp
<
T
>
quantize
:
QuantizeFunc
<
T
>
scalarize
:
ScalarBuilder
<
T
>
)
:
Case
|
undefined
{
const
param0_quantized
=
param0
.
map
(
quantize
)
;
const
param1_quantized
=
param1
.
map
(
quantize
)
;
const
result
=
op
(
param0_quantized
param1_quantized
)
;
if
(
result
=
=
=
undefined
)
return
undefined
;
return
{
input
:
[
new
VectorValue
(
param0_quantized
.
map
(
scalarize
)
)
new
VectorValue
(
param1_quantized
.
map
(
scalarize
)
)
]
expected
:
scalarize
(
result
)
}
;
}
function
generateVectorVectorToScalarCases
<
T
>
(
param0s
:
ROArrayArray
<
T
>
param1s
:
ROArrayArray
<
T
>
op
:
VectorVectorToScalarOp
<
T
>
quantize
:
QuantizeFunc
<
T
>
scalarize
:
ScalarBuilder
<
T
>
)
:
Case
[
]
{
return
param0s
.
flatMap
(
param0
=
>
{
return
param1s
.
map
(
param1
=
>
{
return
makeVectorVectorToScalarCase
(
param0
param1
op
quantize
scalarize
)
;
}
)
.
filter
(
notUndefined
)
;
}
)
;
}
export
function
generateVectorVectorToI32Cases
(
param0s
:
ROArrayArray
<
number
>
param1s
:
ROArrayArray
<
number
>
op
:
VectorVectorToScalarOp
<
number
>
)
:
Case
[
]
{
return
generateVectorVectorToScalarCases
(
param0s
param1s
op
quantizeToI32
i32
)
;
}
export
function
generateVectorVectorToU32Cases
(
param0s
:
ROArrayArray
<
number
>
param1s
:
ROArrayArray
<
number
>
op
:
VectorVectorToScalarOp
<
number
>
)
:
Case
[
]
{
return
generateVectorVectorToScalarCases
(
param0s
param1s
op
quantizeToU32
u32
)
;
}
export
function
generateVectorVectorToI64Cases
(
param0s
:
ROArrayArray
<
bigint
>
param1s
:
ROArrayArray
<
bigint
>
op
:
VectorVectorToScalarOp
<
bigint
>
)
:
Case
[
]
{
return
generateVectorVectorToScalarCases
(
param0s
param1s
op
quantizeToI64
abstractInt
)
;
}
