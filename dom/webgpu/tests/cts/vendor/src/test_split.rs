use
std
:
:
collections
:
:
BTreeSet
;
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Config
<
O
>
{
pub
new_sibling_basename
:
&
'
static
str
pub
split_by
:
SplitBy
<
O
>
}
impl
<
O
>
Config
<
O
>
{
pub
fn
map_observed_values
<
T
>
(
self
f
:
impl
FnOnce
(
O
)
-
>
T
)
-
>
Config
<
T
>
{
let
Self
{
new_sibling_basename
split_by
}
=
self
;
Config
{
new_sibling_basename
split_by
:
split_by
.
map_observed_values
(
f
)
}
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
enum
SplitBy
<
O
>
{
FirstParam
{
expected_name
:
&
'
static
str
split_to
:
SplitParamsTo
observed_values
:
O
}
}
impl
SplitBy
<
(
)
>
{
pub
fn
first_param
(
name
:
&
'
static
str
split_to
:
SplitParamsTo
)
-
>
Self
{
Self
:
:
FirstParam
{
expected_name
:
name
split_to
observed_values
:
(
)
}
}
}
impl
<
O
>
SplitBy
<
O
>
{
pub
fn
map_observed_values
<
T
>
(
self
f
:
impl
FnOnce
(
O
)
-
>
T
)
-
>
SplitBy
<
T
>
{
match
self
{
Self
:
:
FirstParam
{
expected_name
split_to
observed_values
}
=
>
{
let
observed_values
=
f
(
observed_values
)
;
SplitBy
:
:
FirstParam
{
expected_name
split_to
observed_values
}
}
}
}
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
enum
SplitParamsTo
{
SeparateTestsInSameFile
}
#
[
derive
(
Debug
)
]
pub
(
crate
)
struct
Entry
<
'
a
>
{
pub
seen
:
SeenIn
pub
config
:
Config
<
BTreeSet
<
&
'
a
str
>
>
}
impl
Entry
<
'
_
>
{
pub
fn
from_config
(
config
:
Config
<
(
)
>
)
-
>
Self
{
Self
{
seen
:
SeenIn
:
:
nowhere
(
)
config
:
config
.
map_observed_values
(
|
(
)
|
BTreeSet
:
:
new
(
)
)
}
}
}
#
[
derive
(
Debug
Default
)
]
pub
(
crate
)
struct
SeenIn
{
pub
listing
:
bool
pub
wpt_files
:
bool
}
impl
SeenIn
{
pub
fn
nowhere
(
)
-
>
Self
{
Self
:
:
default
(
)
}
}
impl
<
'
a
>
Entry
<
'
a
>
{
pub
(
crate
)
fn
process_listing_line
(
&
mut
self
test_group_and_later_path
:
&
'
a
str
)
-
>
miette
:
:
Result
<
(
)
>
{
let
rest
=
test_group_and_later_path
;
let
Self
{
seen
config
}
=
self
;
let
Config
{
new_sibling_basename
:
_
split_by
}
=
config
;
match
split_by
{
SplitBy
:
:
FirstParam
{
ref
expected_name
split_to
:
_
observed_values
}
=
>
{
let
(
ident
rest
)
=
rest
.
split_once
(
"
=
"
)
.
ok_or_else
(
|
|
{
miette
:
:
diagnostic
!
(
"
failed
to
get
start
of
value
of
first
arg
"
)
}
)
?
;
if
ident
!
=
*
expected_name
{
return
Err
(
miette
:
:
diagnostic
!
(
"
expected
{
:
?
}
got
{
:
?
}
"
expected_name
ident
)
.
into
(
)
)
;
}
let
value
=
rest
.
split_once
(
'
;
'
)
.
map
(
|
(
value
_rest
)
|
value
)
.
unwrap_or
(
rest
)
;
observed_values
.
insert
(
value
)
;
}
}
seen
.
listing
=
true
;
Ok
(
(
)
)
}
}
pub
(
crate
)
fn
assert_seen
<
'
a
>
(
entries
:
impl
Iterator
<
Item
=
(
&
'
a
&
'
a
str
&
'
a
Entry
<
'
a
>
)
>
mut
in_
:
impl
FnMut
(
&
'
a
SeenIn
)
-
>
&
'
a
bool
)
{
let
mut
unseen
=
Vec
:
:
new
(
)
;
entries
.
for_each
(
|
(
test_path
entry
)
|
{
if
!
*
in_
(
&
entry
.
seen
)
{
unseen
.
push
(
test_path
)
;
}
}
)
;
if
!
unseen
.
is_empty
(
)
{
panic
!
(
concat
!
(
"
did
not
find
the
following
test
split
config
.
entries
"
"
in
test
listing
output
:
{
:
#
?
}
"
)
unseen
)
;
}
}
