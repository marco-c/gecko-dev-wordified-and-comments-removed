#
ifndef
GPU_Adapter_H_
#
define
GPU_Adapter_H_
#
include
<
memory
>
#
include
"
ObjectModel
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
webgpu
/
WebGPUTypes
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
class
Promise
;
struct
GPUDeviceDescriptor
;
struct
GPUExtensions
;
struct
GPUFeatures
;
enum
class
GPUFeatureName
:
uint8_t
;
enum
class
WgpuBackend
:
uint8_t
;
enum
class
WgpuDeviceType
:
uint8_t
;
template
<
typename
T
>
class
Sequence
;
}
namespace
webgpu
{
class
Adapter
;
class
Device
;
class
Instance
;
class
SupportedFeatures
;
class
SupportedLimits
;
class
WebGPUChild
;
namespace
ffi
{
struct
WGPUAdapterInformation
;
}
class
AdapterInfo
final
:
public
nsWrapperCache
public
ChildOf
<
Adapter
>
{
public
:
GPU_DECL_CYCLE_COLLECTION
(
AdapterInfo
)
GPU_DECL_JS_WRAP
(
AdapterInfo
)
protected
:
const
std
:
:
shared_ptr
<
ffi
:
:
WGPUAdapterInformation
>
mAboutSupportInfo
;
virtual
~
AdapterInfo
(
)
=
default
;
public
:
explicit
AdapterInfo
(
Adapter
*
const
aParent
const
std
:
:
shared_ptr
<
ffi
:
:
WGPUAdapterInformation
>
&
aAboutSupportInfo
)
:
ChildOf
(
aParent
)
mAboutSupportInfo
(
aAboutSupportInfo
)
{
}
void
GetVendor
(
nsString
&
s
)
const
{
s
=
nsString
(
)
;
}
void
GetArchitecture
(
nsString
&
s
)
const
{
s
=
nsString
(
)
;
}
void
GetDevice
(
nsString
&
s
)
const
{
s
=
nsString
(
)
;
}
void
GetDescription
(
nsString
&
s
)
const
{
s
=
nsString
(
)
;
}
uint32_t
SubgroupMinSize
(
)
const
;
uint32_t
SubgroupMaxSize
(
)
const
;
bool
IsFallbackAdapter
(
)
const
;
void
GetWgpuName
(
nsString
&
)
const
;
uint32_t
WgpuVendor
(
)
const
;
uint32_t
WgpuDevice
(
)
const
;
void
GetWgpuDeviceType
(
nsString
&
)
const
;
void
GetWgpuDriver
(
nsString
&
)
const
;
void
GetWgpuDriverInfo
(
nsString
&
)
const
;
void
GetWgpuBackend
(
nsString
&
)
const
;
}
;
inline
auto
ToHexCString
(
const
uint64_t
v
)
{
return
nsPrintfCString
(
"
0x
%
"
PRIx64
v
)
;
}
class
Adapter
final
:
public
nsWrapperCache
public
ObjectBase
public
ChildOf
<
Instance
>
{
public
:
GPU_DECL_CYCLE_COLLECTION
(
Adapter
)
GPU_DECL_JS_WRAP
(
Adapter
)
private
:
virtual
~
Adapter
(
)
=
default
;
RefPtr
<
SupportedFeatures
>
mFeatures
;
RefPtr
<
SupportedLimits
>
mLimits
;
RefPtr
<
AdapterInfo
>
mInfo
;
const
std
:
:
shared_ptr
<
ffi
:
:
WGPUAdapterInformation
>
mInfoInner
;
public
:
Adapter
(
Instance
*
const
aParent
WebGPUChild
*
const
aChild
const
std
:
:
shared_ptr
<
ffi
:
:
WGPUAdapterInformation
>
&
aInfo
)
;
const
RefPtr
<
SupportedFeatures
>
&
Features
(
)
const
;
const
RefPtr
<
SupportedLimits
>
&
Limits
(
)
const
;
const
RefPtr
<
AdapterInfo
>
&
Info
(
)
const
;
bool
SupportSharedTextureInSwapChain
(
)
const
;
uint64_t
MissingFeatures
(
)
const
;
nsCString
LabelOrId
(
)
const
{
nsCString
ret
=
this
-
>
CLabel
(
)
;
if
(
ret
.
IsEmpty
(
)
)
{
ret
=
ToHexCString
(
GetId
(
)
)
;
}
return
ret
;
}
already_AddRefed
<
dom
:
:
Promise
>
RequestDevice
(
const
dom
:
:
GPUDeviceDescriptor
&
aDesc
ErrorResult
&
aRv
)
;
}
;
}
}
#
endif
