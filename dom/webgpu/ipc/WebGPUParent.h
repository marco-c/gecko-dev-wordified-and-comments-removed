#
ifndef
WEBGPU_PARENT_H_
#
define
WEBGPU_PARENT_H_
#
include
<
unordered_map
>
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
webgpu
/
ffi
/
wgpu
.
h
"
#
include
"
mozilla
/
webgpu
/
PWebGPUParent
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
ipc
/
RawShmem
.
h
"
#
include
"
WebGPUTypes
.
h
"
#
include
"
base
/
timer
.
h
"
namespace
mozilla
{
namespace
layers
{
class
RemoteTextureOwnerClient
;
}
namespace
webgpu
{
class
ErrorBuffer
;
class
ExternalTexture
;
class
PresentationData
;
class
WebGPUParent
final
:
public
PWebGPUParent
public
SupportsWeakPtr
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
WebGPUParent
override
)
public
:
explicit
WebGPUParent
(
)
;
ipc
:
:
IPCResult
RecvInstanceRequestAdapter
(
const
dom
:
:
GPURequestAdapterOptions
&
aOptions
RawId
aAdapterId
InstanceRequestAdapterResolver
&
&
resolver
)
;
ipc
:
:
IPCResult
RecvAdapterRequestDevice
(
RawId
aAdapterId
const
ipc
:
:
ByteBuf
&
aByteBuf
RawId
aDeviceId
RawId
aQueueId
AdapterRequestDeviceResolver
&
&
resolver
)
;
ipc
:
:
IPCResult
RecvAdapterDrop
(
RawId
aAdapterId
)
;
ipc
:
:
IPCResult
RecvDeviceDestroy
(
RawId
aDeviceId
)
;
ipc
:
:
IPCResult
RecvDeviceDrop
(
RawId
aDeviceId
)
;
ipc
:
:
IPCResult
RecvDeviceCreateBuffer
(
RawId
aDeviceId
RawId
aBufferId
dom
:
:
GPUBufferDescriptor
&
&
aDesc
ipc
:
:
UnsafeSharedMemoryHandle
&
&
aShmem
)
;
ipc
:
:
IPCResult
RecvBufferMap
(
RawId
aDeviceId
RawId
aBufferId
uint32_t
aMode
uint64_t
aOffset
uint64_t
size
BufferMapResolver
&
&
aResolver
)
;
ipc
:
:
IPCResult
RecvBufferUnmap
(
RawId
aDeviceId
RawId
aBufferId
bool
aFlush
)
;
ipc
:
:
IPCResult
RecvBufferDestroy
(
RawId
aBufferId
)
;
ipc
:
:
IPCResult
RecvBufferDrop
(
RawId
aBufferId
)
;
ipc
:
:
IPCResult
RecvTextureDestroy
(
RawId
aTextureId
RawId
aDeviceId
)
;
ipc
:
:
IPCResult
RecvTextureDrop
(
RawId
aTextureId
)
;
ipc
:
:
IPCResult
RecvTextureViewDrop
(
RawId
aTextureViewId
)
;
ipc
:
:
IPCResult
RecvSamplerDrop
(
RawId
aSamplerId
)
;
ipc
:
:
IPCResult
RecvCommandEncoderFinish
(
RawId
aEncoderId
RawId
aDeviceId
const
dom
:
:
GPUCommandBufferDescriptor
&
aDesc
)
;
ipc
:
:
IPCResult
RecvCommandEncoderDrop
(
RawId
aEncoderId
)
;
ipc
:
:
IPCResult
RecvCommandBufferDrop
(
RawId
aCommandBufferId
)
;
ipc
:
:
IPCResult
RecvRenderBundleDrop
(
RawId
aBundleId
)
;
ipc
:
:
IPCResult
RecvQueueSubmit
(
RawId
aQueueId
RawId
aDeviceId
const
nsTArray
<
RawId
>
&
aCommandBuffers
const
nsTArray
<
RawId
>
&
aTextureIds
)
;
ipc
:
:
IPCResult
RecvQueueOnSubmittedWorkDone
(
RawId
aQueueId
std
:
:
function
<
void
(
mozilla
:
:
void_t
)
>
&
&
aResolver
)
;
ipc
:
:
IPCResult
RecvQueueWriteAction
(
RawId
aQueueId
RawId
aDeviceId
const
ipc
:
:
ByteBuf
&
aByteBuf
ipc
:
:
UnsafeSharedMemoryHandle
&
&
aShmem
)
;
ipc
:
:
IPCResult
RecvBindGroupLayoutDrop
(
RawId
aBindGroupLayoutId
)
;
ipc
:
:
IPCResult
RecvPipelineLayoutDrop
(
RawId
aPipelineLayoutId
)
;
ipc
:
:
IPCResult
RecvBindGroupDrop
(
RawId
aBindGroupId
)
;
ipc
:
:
IPCResult
RecvShaderModuleDrop
(
RawId
aModuleId
)
;
ipc
:
:
IPCResult
RecvComputePipelineDrop
(
RawId
aPipelineId
)
;
ipc
:
:
IPCResult
RecvRenderPipelineDrop
(
RawId
aPipelineId
)
;
ipc
:
:
IPCResult
RecvImplicitLayoutDrop
(
RawId
aImplicitPlId
const
nsTArray
<
RawId
>
&
aImplicitBglIds
)
;
ipc
:
:
IPCResult
RecvDeviceCreateSwapChain
(
RawId
aDeviceId
RawId
aQueueId
const
layers
:
:
RGBDescriptor
&
aDesc
const
nsTArray
<
RawId
>
&
aBufferIds
const
layers
:
:
RemoteTextureOwnerId
&
aOwnerId
bool
aUseExternalTextureInSwapChain
)
;
ipc
:
:
IPCResult
RecvDeviceCreateShaderModule
(
RawId
aDeviceId
RawId
aModuleId
const
nsString
&
aLabel
const
nsCString
&
aCode
DeviceCreateShaderModuleResolver
&
&
aOutMessage
)
;
ipc
:
:
IPCResult
RecvSwapChainPresent
(
RawId
aTextureId
RawId
aCommandEncoderId
const
layers
:
:
RemoteTextureId
&
aRemoteTextureId
const
layers
:
:
RemoteTextureOwnerId
&
aOwnerId
)
;
ipc
:
:
IPCResult
RecvSwapChainDrop
(
const
layers
:
:
RemoteTextureOwnerId
&
aOwnerId
layers
:
:
RemoteTextureTxnType
aTxnType
layers
:
:
RemoteTextureTxnId
aTxnId
)
;
ipc
:
:
IPCResult
RecvDeviceAction
(
RawId
aDeviceId
const
ipc
:
:
ByteBuf
&
aByteBuf
)
;
ipc
:
:
IPCResult
RecvDeviceActionWithAck
(
RawId
aDeviceId
const
ipc
:
:
ByteBuf
&
aByteBuf
DeviceActionWithAckResolver
&
&
aResolver
)
;
ipc
:
:
IPCResult
RecvTextureAction
(
RawId
aTextureId
RawId
aDevice
const
ipc
:
:
ByteBuf
&
aByteBuf
)
;
ipc
:
:
IPCResult
RecvCommandEncoderAction
(
RawId
aEncoderId
RawId
aDeviceId
const
ipc
:
:
ByteBuf
&
aByteBuf
)
;
ipc
:
:
IPCResult
RecvRenderPass
(
RawId
aEncoderId
RawId
aDeviceId
const
ipc
:
:
ByteBuf
&
aByteBuf
)
;
ipc
:
:
IPCResult
RecvComputePass
(
RawId
aEncoderId
RawId
aDeviceId
const
ipc
:
:
ByteBuf
&
aByteBuf
)
;
ipc
:
:
IPCResult
RecvBumpImplicitBindGroupLayout
(
RawId
aPipelineId
bool
aIsCompute
uint32_t
aIndex
RawId
aAssignId
)
;
ipc
:
:
IPCResult
RecvDevicePushErrorScope
(
RawId
aDeviceId
dom
:
:
GPUErrorFilter
)
;
ipc
:
:
IPCResult
RecvDevicePopErrorScope
(
RawId
aDeviceId
DevicePopErrorScopeResolver
&
&
aResolver
)
;
ipc
:
:
IPCResult
RecvGenerateError
(
Maybe
<
RawId
>
aDeviceId
dom
:
:
GPUErrorFilter
const
nsCString
&
message
)
;
ipc
:
:
IPCResult
GetFrontBufferSnapshot
(
IProtocol
*
aProtocol
const
layers
:
:
RemoteTextureOwnerId
&
aOwnerId
Maybe
<
Shmem
>
&
aShmem
gfx
:
:
IntSize
&
aSize
)
;
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
struct
BufferMapData
{
ipc
:
:
WritableSharedMemoryMapping
mShmem
;
bool
mHasMapFlags
;
uint64_t
mMappedOffset
;
uint64_t
mMappedSize
;
RawId
mDeviceId
;
}
;
BufferMapData
*
GetBufferMapData
(
RawId
aBufferId
)
;
bool
UseExternalTextureForSwapChain
(
ffi
:
:
WGPUSwapChainId
aSwapChainId
)
;
bool
EnsureExternalTextureForSwapChain
(
ffi
:
:
WGPUSwapChainId
aSwapChainId
ffi
:
:
WGPUDeviceId
aDeviceId
ffi
:
:
WGPUTextureId
aTextureId
uint32_t
aWidth
uint32_t
aHeight
struct
ffi
:
:
WGPUTextureFormat
aFormat
ffi
:
:
WGPUTextureUsages
aUsage
)
;
std
:
:
shared_ptr
<
ExternalTexture
>
CreateExternalTexture
(
ffi
:
:
WGPUDeviceId
aDeviceId
ffi
:
:
WGPUTextureId
aTextureId
uint32_t
aWidth
uint32_t
aHeight
const
struct
ffi
:
:
WGPUTextureFormat
aFormat
ffi
:
:
WGPUTextureUsages
aUsage
)
;
std
:
:
shared_ptr
<
ExternalTexture
>
GetExternalTexture
(
ffi
:
:
WGPUTextureId
aId
)
;
void
PostExternalTexture
(
const
std
:
:
shared_ptr
<
ExternalTexture
>
&
&
aExternalTexture
const
layers
:
:
RemoteTextureId
aRemoteTextureId
const
layers
:
:
RemoteTextureOwnerId
aOwnerId
)
;
bool
ForwardError
(
const
RawId
aDeviceId
ErrorBuffer
&
aError
)
{
return
ForwardError
(
Some
(
aDeviceId
)
aError
)
;
}
private
:
static
void
MapCallback
(
ffi
:
:
WGPUBufferMapAsyncStatus
aStatus
uint8_t
*
aUserData
)
;
static
void
DeviceLostCallback
(
uint8_t
*
aUserData
uint8_t
aReason
const
char
*
aMessage
)
;
void
DeallocBufferShmem
(
RawId
aBufferId
)
;
void
RemoveExternalTexture
(
RawId
aTextureId
)
;
virtual
~
WebGPUParent
(
)
;
void
MaintainDevices
(
)
;
void
LoseDevice
(
const
RawId
aDeviceId
Maybe
<
uint8_t
>
aReason
const
nsACString
&
aMessage
)
;
bool
ForwardError
(
Maybe
<
RawId
>
aDeviceId
ErrorBuffer
&
aError
)
;
void
ReportError
(
Maybe
<
RawId
>
aDeviceId
GPUErrorFilter
const
nsCString
&
message
)
;
static
Maybe
<
ffi
:
:
WGPUFfiLUID
>
GetCompositorDeviceLuid
(
)
;
UniquePtr
<
ffi
:
:
WGPUGlobal
>
mContext
;
base
:
:
RepeatingTimer
<
WebGPUParent
>
mTimer
;
std
:
:
unordered_map
<
uint64_t
BufferMapData
>
mSharedMemoryMap
;
std
:
:
unordered_map
<
layers
:
:
RemoteTextureOwnerId
RefPtr
<
PresentationData
>
layers
:
:
RemoteTextureOwnerId
:
:
HashFn
>
mPresentationDataMap
;
RefPtr
<
layers
:
:
RemoteTextureOwnerClient
>
mRemoteTextureOwner
;
std
:
:
unordered_map
<
uint64_t
std
:
:
vector
<
ErrorScope
>
>
mErrorScopeStackByDevice
;
std
:
:
unordered_map
<
ffi
:
:
WGPUTextureId
std
:
:
shared_ptr
<
ExternalTexture
>
>
mExternalTextures
;
nsTHashSet
<
RawId
>
mLostDeviceIds
;
std
:
:
unordered_map
<
RawId
RefPtr
<
gfx
:
:
FileHandleWrapper
>
>
mDeviceFenceHandles
;
struct
DeviceLostRequest
{
WeakPtr
<
WebGPUParent
>
mParent
;
RawId
mDeviceId
;
}
;
std
:
:
unordered_map
<
RawId
std
:
:
unique_ptr
<
DeviceLostRequest
>
>
mDeviceLostRequests
;
}
;
}
}
#
endif
