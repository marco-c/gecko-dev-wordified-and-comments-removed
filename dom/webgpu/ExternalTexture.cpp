#
include
"
ExternalTexture
.
h
"
#
include
"
Colorspaces
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
HTMLVideoElement
.
h
"
#
include
"
mozilla
/
dom
/
VideoFrame
.
h
"
#
include
"
mozilla
/
dom
/
WebGPUBinding
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
webgpu
/
Queue
.
h
"
#
include
"
mozilla
/
webgpu
/
Utility
.
h
"
#
include
"
mozilla
/
webgpu
/
WebGPUChild
.
h
"
#
include
"
mozilla
/
webgpu
/
WebGPUParent
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
namespace
mozilla
:
:
webgpu
{
GPU_IMPL_CYCLE_COLLECTION
(
ExternalTexture
mParent
)
GPU_IMPL_JS_WRAP
(
ExternalTexture
)
ExternalTexture
:
:
ExternalTexture
(
Device
*
const
aParent
RawId
aId
RefPtr
<
ExternalTextureSourceClient
>
aSource
)
:
ChildOf
(
aParent
)
mId
(
aId
)
mSource
(
aSource
)
{
MOZ_RELEASE_ASSERT
(
aId
)
;
}
already_AddRefed
<
ExternalTexture
>
ExternalTexture
:
:
Create
(
Device
*
const
aParent
const
nsString
&
aLabel
const
RefPtr
<
ExternalTextureSourceClient
>
&
aSource
dom
:
:
PredefinedColorSpace
aColorSpace
)
{
const
webgpu
:
:
StringHelper
label
(
aLabel
)
;
const
ffi
:
:
WGPUPredefinedColorSpace
colorSpace
=
ConvertPredefinedColorSpace
(
aColorSpace
)
;
const
ffi
:
:
WGPUExternalTextureDescriptor
desc
=
{
.
label
=
label
.
Get
(
)
.
source
=
aSource
?
aSource
-
>
mId
:
0
.
color_space
=
colorSpace
}
;
const
RawId
id
=
ffi
:
:
wgpu_client_create_external_texture
(
aParent
-
>
GetBridge
(
)
-
>
GetClient
(
)
aParent
-
>
mId
&
desc
)
;
RefPtr
<
ExternalTexture
>
externalTexture
=
new
ExternalTexture
(
aParent
id
aSource
)
;
externalTexture
-
>
SetLabel
(
aLabel
)
;
return
externalTexture
.
forget
(
)
;
}
void
ExternalTexture
:
:
Expire
(
)
{
mIsExpired
=
true
;
MaybeDestroy
(
)
;
}
void
ExternalTexture
:
:
Unexpire
(
)
{
MOZ_ASSERT
(
!
mIsDestroyed
)
;
MOZ_ASSERT
(
mSource
)
;
mIsExpired
=
false
;
}
void
ExternalTexture
:
:
OnSubmit
(
uint64_t
aSubmissionIndex
)
{
mLastSubmittedIndex
=
aSubmissionIndex
;
}
void
ExternalTexture
:
:
OnSubmittedWorkDone
(
uint64_t
aSubmissionIndex
)
{
mLastSubmittedWorkDoneIndex
=
aSubmissionIndex
;
MaybeDestroy
(
)
;
}
void
ExternalTexture
:
:
MaybeDestroy
(
)
{
if
(
!
mIsDestroyed
&
&
mIsExpired
&
&
mLastSubmittedWorkDoneIndex
>
=
mLastSubmittedIndex
)
{
mIsDestroyed
=
true
;
mSource
=
nullptr
;
if
(
auto
bridge
=
mParent
-
>
GetBridge
(
)
)
{
ffi
:
:
wgpu_client_destroy_external_texture
(
bridge
-
>
GetClient
(
)
mId
)
;
}
}
}
void
ExternalTexture
:
:
Cleanup
(
)
{
if
(
!
mValid
)
{
return
;
}
mValid
=
false
;
mSource
=
nullptr
;
auto
bridge
=
mParent
-
>
GetBridge
(
)
;
if
(
!
bridge
)
{
return
;
}
ffi
:
:
wgpu_client_drop_external_texture
(
bridge
-
>
GetClient
(
)
mId
)
;
}
ExternalTexture
:
:
~
ExternalTexture
(
)
{
Cleanup
(
)
;
}
RefPtr
<
ExternalTexture
>
ExternalTextureCache
:
:
GetOrCreate
(
Device
*
aDevice
const
dom
:
:
GPUExternalTextureDescriptor
&
aDesc
ErrorResult
&
aRv
)
{
const
RefPtr
<
ExternalTextureSourceClient
>
source
=
GetOrCreateSource
(
aDevice
aDesc
.
mSource
aRv
)
;
if
(
source
)
{
return
source
-
>
GetOrCreateExternalTexture
(
aDevice
aDesc
)
;
}
return
ExternalTexture
:
:
Create
(
aDevice
aDesc
.
mLabel
nullptr
aDesc
.
mColorSpace
)
;
}
RefPtr
<
ExternalTextureSourceClient
>
ExternalTextureCache
:
:
GetOrCreateSource
(
Device
*
aDevice
const
dom
:
:
OwningHTMLVideoElementOrVideoFrame
&
aSource
ErrorResult
&
aRv
)
{
RefPtr
<
layers
:
:
Image
>
image
;
switch
(
aSource
.
GetType
(
)
)
{
case
dom
:
:
OwningHTMLVideoElementOrVideoFrame
:
:
Type
:
:
eHTMLVideoElement
:
image
=
aSource
.
GetAsHTMLVideoElement
(
)
-
>
GetCurrentImage
(
)
;
break
;
case
dom
:
:
OwningHTMLVideoElementOrVideoFrame
:
:
Type
:
:
eVideoFrame
:
image
=
aSource
.
GetAsVideoFrame
(
)
-
>
GetImage
(
)
;
break
;
}
typename
decltype
(
mSources
)
:
:
AddPtr
p
;
if
(
image
)
{
p
=
mSources
.
lookupForAdd
(
image
-
>
GetSerial
(
)
)
;
if
(
p
)
{
const
RefPtr
<
ExternalTextureSourceClient
>
source
=
p
-
>
value
(
)
;
MOZ_ASSERT
(
source
-
>
mImage
=
=
image
)
;
return
source
;
}
}
const
RefPtr
<
ExternalTextureSourceClient
>
source
=
ExternalTextureSourceClient
:
:
Create
(
aDevice
this
aSource
aRv
)
;
if
(
source
)
{
Unused
<
<
mSources
.
add
(
p
source
-
>
mImage
-
>
GetSerial
(
)
source
)
;
}
return
source
;
}
void
ExternalTextureCache
:
:
RemoveSource
(
const
ExternalTextureSourceClient
*
aSource
)
{
mSources
.
remove
(
aSource
-
>
mImage
-
>
GetSerial
(
)
)
;
}
ExternalTextureSourceClient
:
:
ExternalTextureSourceClient
(
WebGPUChild
*
aBridge
RawId
aId
ExternalTextureCache
*
aCache
const
RefPtr
<
layers
:
:
Image
>
&
aImage
const
std
:
:
array
<
RawId
3
>
&
aTextureIds
const
std
:
:
array
<
RawId
3
>
&
aViewIds
)
:
mId
(
aId
)
mImage
(
aImage
)
mTextureIds
(
std
:
:
move
(
aTextureIds
)
)
mViewIds
(
std
:
:
move
(
aViewIds
)
)
mBridge
(
aBridge
)
mCache
(
aCache
)
{
MOZ_RELEASE_ASSERT
(
aId
)
;
}
ExternalTextureSourceClient
:
:
~
ExternalTextureSourceClient
(
)
{
if
(
mCache
)
{
mCache
-
>
RemoveSource
(
this
)
;
}
if
(
!
mBridge
)
{
return
;
}
ffi
:
:
wgpu_client_destroy_external_texture_source
(
mBridge
-
>
GetClient
(
)
mId
)
;
ffi
:
:
wgpu_client_drop_external_texture_source
(
mBridge
-
>
GetClient
(
)
mId
)
;
for
(
const
auto
id
:
mViewIds
)
{
wgpu_client_free_texture_view_id
(
mBridge
-
>
GetClient
(
)
id
)
;
}
for
(
const
auto
id
:
mTextureIds
)
{
wgpu_client_free_texture_id
(
mBridge
-
>
GetClient
(
)
id
)
;
}
}
already_AddRefed
<
ExternalTextureSourceClient
>
ExternalTextureSourceClient
:
:
Create
(
Device
*
aDevice
ExternalTextureCache
*
aCache
const
dom
:
:
OwningHTMLVideoElementOrVideoFrame
&
aSource
ErrorResult
&
aRv
)
{
const
uint32_t
flags
=
nsLayoutUtils
:
:
SFE_ALLOW_UNCROPPED_UNSCALED
;
SurfaceFromElementResult
sfeResult
;
VideoRotation
rotation
;
switch
(
aSource
.
GetType
(
)
)
{
case
dom
:
:
OwningHTMLVideoElementOrVideoFrame
:
:
Type
:
:
eHTMLVideoElement
:
{
const
auto
&
videoElement
=
aSource
.
GetAsHTMLVideoElement
(
)
;
sfeResult
=
nsLayoutUtils
:
:
SurfaceFromElement
(
videoElement
.
get
(
)
flags
)
;
rotation
=
videoElement
-
>
RotationDegrees
(
)
;
}
break
;
case
dom
:
:
OwningHTMLVideoElementOrVideoFrame
:
:
Type
:
:
eVideoFrame
:
{
const
auto
&
videoFrame
=
aSource
.
GetAsVideoFrame
(
)
;
sfeResult
=
nsLayoutUtils
:
:
SurfaceFromVideoFrame
(
videoFrame
.
get
(
)
flags
)
;
rotation
=
VideoRotation
:
:
kDegree_0
;
}
break
;
}
if
(
!
sfeResult
.
mCORSUsed
)
{
const
nsIGlobalObject
*
const
global
=
aDevice
-
>
GetOwnerGlobal
(
)
;
nsIPrincipal
*
const
dstPrincipal
=
global
?
global
-
>
PrincipalOrNull
(
)
:
nullptr
;
if
(
!
sfeResult
.
mPrincipal
|
|
!
dstPrincipal
|
|
!
dstPrincipal
-
>
Subsumes
(
sfeResult
.
mPrincipal
)
)
{
aRv
.
ThrowSecurityError
(
"
Cross
-
origin
elements
require
CORS
!
"
)
;
return
nullptr
;
}
}
if
(
sfeResult
.
mIsWriteOnly
)
{
aRv
.
ThrowSecurityError
(
"
Write
only
source
data
not
supported
!
"
)
;
return
nullptr
;
}
const
auto
bridge
=
aDevice
-
>
GetBridge
(
)
;
const
RefPtr
<
layers
:
:
Image
>
image
=
sfeResult
.
mLayersImage
;
if
(
!
image
)
{
ffi
:
:
wgpu_report_validation_error
(
bridge
-
>
GetClient
(
)
aDevice
-
>
mId
"
Video
source
'
s
usability
is
bad
"
)
;
return
nullptr
;
}
layers
:
:
SurfaceDescriptorBuffer
sd
;
const
nsresult
rv
=
image
-
>
BuildSurfaceDescriptorBuffer
(
sd
layers
:
:
Image
:
:
BuildSdbFlags
:
:
Default
[
&
]
(
uint32_t
aBufferSize
)
{
ipc
:
:
Shmem
buffer
;
if
(
!
bridge
-
>
AllocShmem
(
aBufferSize
&
buffer
)
)
{
return
layers
:
:
MemoryOrShmem
(
)
;
}
return
layers
:
:
MemoryOrShmem
(
std
:
:
move
(
buffer
)
)
;
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
gfxCriticalErrorOnce
(
)
<
<
"
BuildSurfaceDescriptorBuffer
failed
"
;
ffi
:
:
wgpu_report_internal_error
(
bridge
-
>
GetClient
(
)
aDevice
-
>
mId
"
BuildSurfaceDescriptorBuffer
failed
"
)
;
if
(
sd
.
data
(
)
.
type
(
)
=
=
layers
:
:
MemoryOrShmem
:
:
TShmem
)
{
bridge
-
>
DeallocShmem
(
sd
.
data
(
)
.
get_Shmem
(
)
)
;
}
return
nullptr
;
}
const
auto
sourceId
=
ffi
:
:
wgpu_client_make_external_texture_source_id
(
bridge
-
>
GetClient
(
)
)
;
const
std
:
:
array
<
RawId
3
>
textureIds
{
ffi
:
:
wgpu_client_make_texture_id
(
bridge
-
>
GetClient
(
)
)
ffi
:
:
wgpu_client_make_texture_id
(
bridge
-
>
GetClient
(
)
)
ffi
:
:
wgpu_client_make_texture_id
(
bridge
-
>
GetClient
(
)
)
}
;
const
std
:
:
array
<
RawId
3
>
viewIds
{
ffi
:
:
wgpu_client_make_texture_view_id
(
bridge
-
>
GetClient
(
)
)
ffi
:
:
wgpu_client_make_texture_view_id
(
bridge
-
>
GetClient
(
)
)
ffi
:
:
wgpu_client_make_texture_view_id
(
bridge
-
>
GetClient
(
)
)
}
;
const
gfx
:
:
IntSize
codedSize
=
sfeResult
.
mSize
;
const
gfx
:
:
IntRect
cropRect
=
sfeResult
.
mCropRect
.
valueOr
(
gfx
:
:
IntRect
(
{
}
codedSize
)
)
;
const
gfx
:
:
IntSize
intrinsicSize
=
sfeResult
.
mIntrinsicSize
;
gfx
:
:
Matrix
sampleTransform
;
switch
(
rotation
)
{
case
VideoRotation
:
:
kDegree_0
:
break
;
case
VideoRotation
:
:
kDegree_90
:
sampleTransform
=
gfx
:
:
Matrix
(
0
.
0
-
1
.
0
1
.
0
0
.
0
0
.
0
1
.
0
)
;
break
;
case
VideoRotation
:
:
kDegree_180
:
sampleTransform
=
gfx
:
:
Matrix
(
-
1
.
0
0
.
0
0
.
0
-
1
.
0
1
.
0
1
.
0
)
;
break
;
case
VideoRotation
:
:
kDegree_270
:
sampleTransform
=
gfx
:
:
Matrix
(
0
.
0
1
.
0
-
1
.
0
0
.
0
1
.
0
0
.
0
)
;
break
;
}
gfx
:
:
Rect
normalizedCropRect
=
gfx
:
:
Rect
(
cropRect
)
;
normalizedCropRect
.
Scale
(
1
.
0
/
static_cast
<
float
>
(
codedSize
.
width
)
1
.
0
/
static_cast
<
float
>
(
codedSize
.
height
)
)
;
sampleTransform
.
PreTranslate
(
normalizedCropRect
.
x
normalizedCropRect
.
y
)
;
sampleTransform
.
PreScale
(
normalizedCropRect
.
Width
(
)
normalizedCropRect
.
Height
(
)
)
;
gfx
:
:
Matrix
loadTransform
=
sampleTransform
;
loadTransform
.
PreScale
(
1
.
0
/
static_cast
<
float
>
(
std
:
:
max
(
intrinsicSize
.
width
-
1
1
)
)
1
.
0
/
static_cast
<
float
>
(
std
:
:
max
(
intrinsicSize
.
height
-
1
1
)
)
)
;
loadTransform
.
PostScale
(
static_cast
<
float
>
(
codedSize
.
width
-
1
)
static_cast
<
float
>
(
codedSize
.
height
-
1
)
)
;
const
ExternalTextureSourceDescriptor
sourceDesc
=
{
.
mTextureIds
=
textureIds
.
mViewIds
=
viewIds
.
mSurfaceDescriptor
=
std
:
:
move
(
sd
)
.
mSize
=
intrinsicSize
.
mSampleTransform
=
{
sampleTransform
.
_11
sampleTransform
.
_12
sampleTransform
.
_21
sampleTransform
.
_22
sampleTransform
.
_31
sampleTransform
.
_32
}
.
mLoadTransform
=
{
loadTransform
.
_11
loadTransform
.
_12
loadTransform
.
_21
loadTransform
.
_22
loadTransform
.
_31
loadTransform
.
_32
}
}
;
bridge
-
>
FlushQueuedMessages
(
)
;
bridge
-
>
SendCreateExternalTextureSource
(
aDevice
-
>
mId
aDevice
-
>
GetQueue
(
)
-
>
mId
sourceId
sourceDesc
)
;
RefPtr
<
ExternalTextureSourceClient
>
source
=
new
ExternalTextureSourceClient
(
aDevice
-
>
GetBridge
(
)
.
get
(
)
sourceId
aCache
image
textureIds
viewIds
)
;
return
source
.
forget
(
)
;
}
RefPtr
<
ExternalTexture
>
ExternalTextureSourceClient
:
:
GetOrCreateExternalTexture
(
Device
*
aDevice
const
dom
:
:
GPUExternalTextureDescriptor
&
aDesc
)
{
auto
p
=
mExternalTextures
.
lookupForAdd
(
aDesc
.
mColorSpace
)
;
if
(
p
)
{
if
(
auto
*
const
externalTexture
=
p
-
>
value
(
)
.
get
(
)
)
{
if
(
!
externalTexture
-
>
IsDestroyed
(
)
)
{
externalTexture
-
>
Unexpire
(
)
;
return
externalTexture
;
}
}
}
const
RefPtr
<
ExternalTexture
>
externalTexture
=
ExternalTexture
:
:
Create
(
aDevice
aDesc
.
mLabel
this
aDesc
.
mColorSpace
)
;
if
(
externalTexture
)
{
if
(
p
)
{
p
-
>
value
(
)
=
externalTexture
;
}
else
{
Unused
<
<
mExternalTextures
.
add
(
p
aDesc
.
mColorSpace
externalTexture
)
;
}
}
return
externalTexture
;
}
ExternalTextureSourceHost
:
:
ExternalTextureSourceHost
(
Span
<
const
RawId
>
aTextureIds
Span
<
const
RawId
>
aViewIds
gfx
:
:
IntSize
aSize
gfx
:
:
SurfaceFormat
aFormat
gfx
:
:
YUVRangedColorSpace
aColorSpace
const
std
:
:
array
<
float
6
>
&
aSampleTransform
const
std
:
:
array
<
float
6
>
&
aLoadTransform
)
:
mSize
(
aSize
)
mFormat
(
aFormat
)
mColorSpace
(
aColorSpace
)
mSampleTransform
(
aSampleTransform
)
mLoadTransform
(
aLoadTransform
)
{
mTextureIds
.
AppendElements
(
aTextureIds
)
;
mViewIds
.
AppendElements
(
aViewIds
)
;
}
ExternalTextureSourceHost
ExternalTextureSourceHost
:
:
Create
(
WebGPUParent
*
aParent
RawId
aDeviceId
RawId
aQueueId
const
ExternalTextureSourceDescriptor
&
aDesc
)
{
const
auto
&
sd
=
aDesc
.
mSurfaceDescriptor
;
switch
(
sd
.
type
(
)
)
{
case
layers
:
:
SurfaceDescriptor
:
:
TSurfaceDescriptorBuffer
:
{
const
layers
:
:
SurfaceDescriptorBuffer
&
bufferDesc
=
sd
.
get_SurfaceDescriptorBuffer
(
)
;
auto
source
=
CreateFromBufferDesc
(
aParent
aDeviceId
aQueueId
aDesc
bufferDesc
.
desc
(
)
GetAddressFromDescriptor
(
sd
)
)
;
if
(
bufferDesc
.
data
(
)
.
type
(
)
=
=
layers
:
:
MemoryOrShmem
:
:
TShmem
)
{
aParent
-
>
DeallocShmem
(
bufferDesc
.
data
(
)
.
get_Shmem
(
)
)
;
}
return
source
;
}
break
;
default
:
gfxCriticalErrorOnce
(
)
<
<
"
Unexpected
SurfaceDescriptor
type
:
"
<
<
sd
.
type
(
)
;
aParent
-
>
ReportError
(
aDeviceId
dom
:
:
GPUErrorFilter
:
:
Internal
nsPrintfCString
(
"
Unexpected
SurfaceDescriptor
type
:
%
d
"
sd
.
type
(
)
)
)
;
return
CreateError
(
)
;
}
}
ExternalTextureSourceHost
ExternalTextureSourceHost
:
:
CreateFromBufferDesc
(
WebGPUParent
*
aParent
RawId
aDeviceId
RawId
aQueueId
const
ExternalTextureSourceDescriptor
&
aDesc
const
layers
:
:
BufferDescriptor
&
aSd
uint8_t
*
aBuffer
)
{
const
gfx
:
:
SurfaceFormat
format
=
layers
:
:
ImageDataSerializer
:
:
FormatFromBufferDescriptor
(
aSd
)
;
auto
createPlane
=
[
aParent
aDeviceId
aQueueId
]
(
RawId
texId
RawId
viewId
ffi
:
:
WGPUTextureFormat
format
gfx
:
:
IntSize
size
uint8_t
*
buffer
uint32_t
stride
)
{
const
ffi
:
:
WGPUTextureDescriptor
textureDesc
{
.
size
=
ffi
:
:
WGPUExtent3d
{
.
width
=
static_cast
<
uint32_t
>
(
size
.
width
)
.
height
=
static_cast
<
uint32_t
>
(
size
.
height
)
.
depth_or_array_layers
=
1
}
.
mip_level_count
=
1
.
sample_count
=
1
.
dimension
=
ffi
:
:
WGPUTextureDimension_D2
.
format
=
format
.
usage
=
WGPUTextureUsages_TEXTURE_BINDING
|
WGPUTextureUsages_COPY_DST
.
view_formats
=
{
}
}
;
{
ErrorBuffer
error
;
ffi
:
:
wgpu_server_device_create_texture
(
aParent
-
>
GetContext
(
)
aDeviceId
texId
&
textureDesc
error
.
ToFFI
(
)
)
;
error
.
CoerceValidationToInternal
(
)
;
aParent
-
>
ForwardError
(
error
)
;
}
const
ffi
:
:
WGPUTexelCopyTextureInfo
dest
{
.
texture
=
texId
.
mip_level
=
0
.
origin
=
{
}
.
aspect
=
ffi
:
:
WGPUTextureAspect_All
}
;
const
ffi
:
:
WGPUTexelCopyBufferLayout
layout
{
.
offset
=
0
.
bytes_per_row
=
&
stride
.
rows_per_image
=
nullptr
}
;
const
ffi
:
:
WGPUFfiSlice_u8
data
{
.
data
=
buffer
.
length
=
size
.
height
*
stride
}
;
{
ErrorBuffer
error
;
ffi
:
:
wgpu_server_queue_write_texture
(
aParent
-
>
GetContext
(
)
aDeviceId
aQueueId
&
dest
data
&
layout
&
textureDesc
.
size
error
.
ToFFI
(
)
)
;
error
.
CoerceValidationToInternal
(
)
;
aParent
-
>
ForwardError
(
error
)
;
}
const
ffi
:
:
WGPUTextureViewDescriptor
viewDesc
{
}
;
{
ErrorBuffer
error
;
ffi
:
:
wgpu_server_texture_create_view
(
aParent
-
>
GetContext
(
)
aDeviceId
texId
viewId
&
viewDesc
error
.
ToFFI
(
)
)
;
error
.
CoerceValidationToInternal
(
)
;
aParent
-
>
ForwardError
(
error
)
;
}
}
;
AutoTArray
<
RawId
3
>
usedTextureIds
;
AutoTArray
<
RawId
3
>
usedViewIds
;
gfx
:
:
YUVRangedColorSpace
colorSpace
;
switch
(
aSd
.
type
(
)
)
{
case
layers
:
:
BufferDescriptor
:
:
TRGBDescriptor
:
{
const
layers
:
:
RGBDescriptor
&
rgbDesc
=
aSd
.
get_RGBDescriptor
(
)
;
ffi
:
:
WGPUTextureFormat
planeFormat
;
switch
(
rgbDesc
.
format
(
)
)
{
case
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
:
case
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
:
planeFormat
=
{
ffi
:
:
WGPUTextureFormat_Bgra8Unorm
}
;
break
;
case
gfx
:
:
SurfaceFormat
:
:
R8G8B8A8
:
case
gfx
:
:
SurfaceFormat
:
:
R8G8B8X8
:
planeFormat
=
{
ffi
:
:
WGPUTextureFormat_Rgba8Unorm
}
;
break
;
default
:
gfxCriticalErrorOnce
(
)
<
<
"
Unexpected
RGBDescriptor
format
:
"
<
<
rgbDesc
.
format
(
)
;
aParent
-
>
ReportError
(
aDeviceId
dom
:
:
GPUErrorFilter
:
:
Internal
nsPrintfCString
(
"
Unexpected
RGBDescriptor
format
:
%
s
"
mozilla
:
:
ToString
(
rgbDesc
.
format
(
)
)
.
c_str
(
)
)
)
;
return
CreateError
(
)
;
}
createPlane
(
aDesc
.
mTextureIds
[
0
]
aDesc
.
mViewIds
[
0
]
planeFormat
rgbDesc
.
size
(
)
aBuffer
layers
:
:
ImageDataSerializer
:
:
GetRGBStride
(
rgbDesc
)
)
;
usedTextureIds
.
AppendElement
(
aDesc
.
mTextureIds
[
0
]
)
;
usedViewIds
.
AppendElement
(
aDesc
.
mViewIds
[
0
]
)
;
colorSpace
=
gfx
:
:
YUVRangedColorSpace
:
:
GbrIdentity
;
}
break
;
case
layers
:
:
BufferDescriptor
:
:
TYCbCrDescriptor
:
{
const
layers
:
:
YCbCrDescriptor
&
yCbCrDesc
=
aSd
.
get_YCbCrDescriptor
(
)
;
const
gfx
:
:
IntSize
ySize
=
layers
:
:
ImageDataSerializer
:
:
SizeFromBufferDescriptor
(
aSd
)
;
const
gfx
:
:
IntSize
cbCrSize
=
layers
:
:
ImageDataSerializer
:
:
GetCroppedCbCrSize
(
aSd
)
;
ffi
:
:
WGPUTextureFormat
planeFormat
;
switch
(
yCbCrDesc
.
colorDepth
(
)
)
{
case
gfx
:
:
ColorDepth
:
:
COLOR_8
:
planeFormat
=
{
ffi
:
:
WGPUTextureFormat_R8Unorm
}
;
break
;
case
gfx
:
:
ColorDepth
:
:
COLOR_10
:
case
gfx
:
:
ColorDepth
:
:
COLOR_12
:
case
gfx
:
:
ColorDepth
:
:
COLOR_16
:
gfxCriticalNoteOnce
<
<
"
Unsupported
color
depth
:
"
<
<
yCbCrDesc
.
colorDepth
(
)
;
aParent
-
>
ReportError
(
aDeviceId
dom
:
:
GPUErrorFilter
:
:
Internal
nsPrintfCString
(
"
Unsupported
color
depth
:
%
s
"
mozilla
:
:
ToString
(
yCbCrDesc
.
colorDepth
(
)
)
.
c_str
(
)
)
)
;
return
CreateError
(
)
;
}
createPlane
(
aDesc
.
mTextureIds
[
0
]
aDesc
.
mViewIds
[
0
]
planeFormat
ySize
aBuffer
+
yCbCrDesc
.
yOffset
(
)
yCbCrDesc
.
yStride
(
)
)
;
createPlane
(
aDesc
.
mTextureIds
[
1
]
aDesc
.
mViewIds
[
1
]
planeFormat
cbCrSize
aBuffer
+
yCbCrDesc
.
cbOffset
(
)
yCbCrDesc
.
cbCrStride
(
)
)
;
createPlane
(
aDesc
.
mTextureIds
[
2
]
aDesc
.
mViewIds
[
2
]
planeFormat
cbCrSize
aBuffer
+
yCbCrDesc
.
crOffset
(
)
yCbCrDesc
.
cbCrStride
(
)
)
;
usedTextureIds
.
AppendElements
(
aDesc
.
mTextureIds
.
data
(
)
aDesc
.
mTextureIds
.
size
(
)
)
;
usedViewIds
.
AppendElements
(
aDesc
.
mViewIds
.
data
(
)
aDesc
.
mViewIds
.
size
(
)
)
;
colorSpace
=
gfx
:
:
ToYUVRangedColorSpace
(
yCbCrDesc
.
yUVColorSpace
(
)
yCbCrDesc
.
colorRange
(
)
)
;
}
break
;
case
layers
:
:
BufferDescriptor
:
:
T__None
:
{
gfxCriticalErrorOnce
(
)
<
<
"
Invalid
BufferDescriptor
"
;
aParent
-
>
ReportError
(
aDeviceId
dom
:
:
GPUErrorFilter
:
:
Internal
"
Invalid
BufferDescriptor
"
_ns
)
;
return
CreateError
(
)
;
}
break
;
}
return
ExternalTextureSourceHost
(
usedTextureIds
usedViewIds
aDesc
.
mSize
format
colorSpace
aDesc
.
mSampleTransform
aDesc
.
mLoadTransform
)
;
}
ExternalTextureSourceHost
ExternalTextureSourceHost
:
:
CreateError
(
)
{
return
ExternalTextureSourceHost
(
{
}
{
}
gfx
:
:
IntSize
(
0
0
)
gfx
:
:
SurfaceFormat
:
:
R8G8B8A8
gfx
:
:
YUVRangedColorSpace
:
:
GbrIdentity
{
}
{
}
)
;
}
static
color
:
:
ColorspaceTransform
GetColorSpaceTransform
(
gfx
:
:
YUVRangedColorSpace
aSrcColorSpace
ffi
:
:
WGPUPredefinedColorSpace
aDestColorSpace
)
{
const
bool
rec709GammaAsSrgb
=
StaticPrefs
:
:
gfx_color_management_rec709_gamma_as_srgb
(
)
;
const
bool
rec2020GammaAsRec709
=
StaticPrefs
:
:
gfx_color_management_rec2020_gamma_as_rec709
(
)
;
color
:
:
ColorspaceDesc
srcColorSpace
;
switch
(
aSrcColorSpace
)
{
case
gfx
:
:
YUVRangedColorSpace
:
:
BT601_Narrow
:
srcColorSpace
=
{
.
chrom
=
color
:
:
Chromaticities
:
:
Rec601_525_Ntsc
(
)
.
tf
=
rec709GammaAsSrgb
?
color
:
:
PiecewiseGammaDesc
:
:
Srgb
(
)
:
color
:
:
PiecewiseGammaDesc
:
:
Rec709
(
)
.
yuv
=
color
:
:
YuvDesc
{
.
yCoeffs
=
color
:
:
YuvLumaCoeffs
:
:
Rec601
(
)
.
ycbcr
=
color
:
:
YcbcrDesc
:
:
Narrow8
(
)
}
}
;
break
;
case
gfx
:
:
YUVRangedColorSpace
:
:
BT601_Full
:
srcColorSpace
=
{
.
chrom
=
color
:
:
Chromaticities
:
:
Rec601_525_Ntsc
(
)
.
tf
=
rec709GammaAsSrgb
?
color
:
:
PiecewiseGammaDesc
:
:
Srgb
(
)
:
color
:
:
PiecewiseGammaDesc
:
:
Rec709
(
)
.
yuv
=
color
:
:
YuvDesc
{
.
yCoeffs
=
color
:
:
YuvLumaCoeffs
:
:
Rec601
(
)
.
ycbcr
=
color
:
:
YcbcrDesc
:
:
Full8
(
)
}
}
;
break
;
case
gfx
:
:
YUVRangedColorSpace
:
:
BT709_Narrow
:
srcColorSpace
=
{
.
chrom
=
color
:
:
Chromaticities
:
:
Rec709
(
)
.
tf
=
rec709GammaAsSrgb
?
color
:
:
PiecewiseGammaDesc
:
:
Srgb
(
)
:
color
:
:
PiecewiseGammaDesc
:
:
Rec709
(
)
.
yuv
=
color
:
:
YuvDesc
{
.
yCoeffs
=
color
:
:
YuvLumaCoeffs
:
:
Rec709
(
)
.
ycbcr
=
color
:
:
YcbcrDesc
:
:
Narrow8
(
)
}
}
;
break
;
case
gfx
:
:
YUVRangedColorSpace
:
:
BT709_Full
:
srcColorSpace
=
{
.
chrom
=
color
:
:
Chromaticities
:
:
Rec709
(
)
.
tf
=
rec709GammaAsSrgb
?
color
:
:
PiecewiseGammaDesc
:
:
Srgb
(
)
:
color
:
:
PiecewiseGammaDesc
:
:
Rec709
(
)
.
yuv
=
color
:
:
YuvDesc
{
.
yCoeffs
=
color
:
:
YuvLumaCoeffs
:
:
Rec709
(
)
.
ycbcr
=
color
:
:
YcbcrDesc
:
:
Full8
(
)
}
}
;
break
;
case
gfx
:
:
YUVRangedColorSpace
:
:
BT2020_Narrow
:
srcColorSpace
=
{
.
chrom
=
color
:
:
Chromaticities
:
:
Rec2020
(
)
.
tf
=
rec2020GammaAsRec709
&
&
rec709GammaAsSrgb
?
color
:
:
PiecewiseGammaDesc
:
:
Srgb
(
)
:
(
rec2020GammaAsRec709
?
color
:
:
PiecewiseGammaDesc
:
:
Rec709
(
)
:
color
:
:
PiecewiseGammaDesc
:
:
Rec2020_12bit
(
)
)
.
yuv
=
color
:
:
YuvDesc
{
.
yCoeffs
=
color
:
:
YuvLumaCoeffs
:
:
Rec2020
(
)
.
ycbcr
=
color
:
:
YcbcrDesc
:
:
Narrow8
(
)
}
}
;
break
;
case
gfx
:
:
YUVRangedColorSpace
:
:
BT2020_Full
:
srcColorSpace
=
{
.
chrom
=
color
:
:
Chromaticities
:
:
Rec2020
(
)
.
tf
=
rec2020GammaAsRec709
&
&
rec709GammaAsSrgb
?
color
:
:
PiecewiseGammaDesc
:
:
Srgb
(
)
:
(
rec2020GammaAsRec709
?
color
:
:
PiecewiseGammaDesc
:
:
Rec709
(
)
:
color
:
:
PiecewiseGammaDesc
:
:
Rec2020_12bit
(
)
)
.
yuv
=
color
:
:
YuvDesc
{
.
yCoeffs
=
color
:
:
YuvLumaCoeffs
:
:
Rec2020
(
)
.
ycbcr
=
color
:
:
YcbcrDesc
:
:
Full8
(
)
}
}
;
break
;
case
gfx
:
:
YUVRangedColorSpace
:
:
GbrIdentity
:
srcColorSpace
=
{
.
chrom
=
color
:
:
Chromaticities
:
:
Rec709
(
)
.
tf
=
color
:
:
PiecewiseGammaDesc
:
:
Rec709
(
)
.
yuv
=
color
:
:
YuvDesc
{
.
yCoeffs
=
color
:
:
YuvLumaCoeffs
:
:
Gbr
(
)
.
ycbcr
=
color
:
:
YcbcrDesc
:
:
Full8
(
)
}
}
;
break
;
}
color
:
:
ColorspaceDesc
destColorSpace
{
}
;
switch
(
aDestColorSpace
)
{
case
ffi
:
:
WGPUPredefinedColorSpace_Srgb
:
destColorSpace
=
{
.
chrom
=
color
:
:
Chromaticities
:
:
Srgb
(
)
.
tf
=
color
:
:
PiecewiseGammaDesc
:
:
Srgb
(
)
}
;
break
;
case
ffi
:
:
WGPUPredefinedColorSpace_DisplayP3
:
destColorSpace
=
{
.
chrom
=
color
:
:
Chromaticities
:
:
DisplayP3
(
)
.
tf
=
color
:
:
PiecewiseGammaDesc
:
:
DisplayP3
(
)
}
;
break
;
case
ffi
:
:
WGPUPredefinedColorSpace_Sentinel
:
MOZ_CRASH
(
"
Invalid
WGPUPredefinedColorSpace
"
)
;
}
return
color
:
:
ColorspaceTransform
:
:
Create
(
srcColorSpace
destColorSpace
)
;
}
static
ffi
:
:
WGPUExternalTextureFormat
MapFormat
(
gfx
:
:
SurfaceFormat
aFormat
)
{
switch
(
aFormat
)
{
case
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
:
case
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
:
case
gfx
:
:
SurfaceFormat
:
:
R8G8B8A8
:
case
gfx
:
:
SurfaceFormat
:
:
R8G8B8X8
:
return
ffi
:
:
WGPUExternalTextureFormat_Rgba
;
case
gfx
:
:
SurfaceFormat
:
:
YUV420
:
return
ffi
:
:
WGPUExternalTextureFormat_Yu12
;
case
gfx
:
:
SurfaceFormat
:
:
NV12
:
return
ffi
:
:
WGPUExternalTextureFormat_Nv12
;
default
:
MOZ_CRASH
(
"
Unexpected
SurfaceFormat
"
)
;
}
}
static
ffi
:
:
WGPUExternalTextureTransferFunction
MapTransferFunction
(
std
:
:
optional
<
color
:
:
PiecewiseGammaDesc
>
aTf
)
{
if
(
aTf
)
{
return
ffi
:
:
WGPUExternalTextureTransferFunction
{
.
a
=
aTf
-
>
a
.
b
=
aTf
-
>
b
.
g
=
aTf
-
>
g
.
k
=
aTf
-
>
k
}
;
}
else
{
return
ffi
:
:
WGPUExternalTextureTransferFunction
{
.
a
=
1
.
0
.
b
=
1
.
0
.
g
=
1
.
0
.
k
=
1
.
0
}
;
}
}
ffi
:
:
WGPUExternalTextureDescriptorFromSource
ExternalTextureSourceHost
:
:
GetExternalTextureDescriptor
(
ffi
:
:
WGPUPredefinedColorSpace
aDestColorSpace
)
const
{
ffi
:
:
WGPUExternalTextureDescriptorFromSource
desc
;
desc
.
planes
=
ffi
:
:
WGPUFfiSlice_TextureViewId
{
.
data
=
mViewIds
.
Elements
(
)
.
length
=
mViewIds
.
Length
(
)
}
;
desc
.
width
=
static_cast
<
uint32_t
>
(
mSize
.
width
)
;
desc
.
height
=
static_cast
<
uint32_t
>
(
mSize
.
height
)
;
desc
.
format
=
MapFormat
(
mFormat
)
;
auto
colorSpaceTransform
=
GetColorSpaceTransform
(
mColorSpace
aDestColorSpace
)
;
auto
make_column_major_generator
=
[
]
(
auto
mat
)
{
return
[
i
=
0
mat
]
(
)
mutable
{
auto
val
=
mat
.
at
(
i
/
mat
.
y_rows
i
%
mat
.
y_rows
)
;
i
+
+
;
return
val
;
}
;
}
;
std
:
:
generate
(
std
:
:
begin
(
desc
.
yuv_conversion_matrix
)
std
:
:
end
(
desc
.
yuv_conversion_matrix
)
make_column_major_generator
(
colorSpaceTransform
.
srcRgbTfFromSrc
)
)
;
std
:
:
generate
(
std
:
:
begin
(
desc
.
gamut_conversion_matrix
)
std
:
:
end
(
desc
.
gamut_conversion_matrix
)
make_column_major_generator
(
colorSpaceTransform
.
dstRgbLinFromSrcRgbLin
)
)
;
desc
.
src_transfer_function
=
MapTransferFunction
(
colorSpaceTransform
.
srcTf
)
;
desc
.
dst_transfer_function
=
MapTransferFunction
(
colorSpaceTransform
.
dstTf
)
;
std
:
:
copy
(
mSampleTransform
.
begin
(
)
mSampleTransform
.
end
(
)
desc
.
sample_transform
)
;
std
:
:
copy
(
mLoadTransform
.
begin
(
)
mLoadTransform
.
end
(
)
desc
.
load_transform
)
;
return
desc
;
}
}
