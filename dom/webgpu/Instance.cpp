#
include
"
Instance
.
h
"
#
include
"
Adapter
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
ipc
/
WebGPUChild
.
h
"
#
include
"
ipc
/
WebGPUTypes
.
h
"
#
include
"
mozilla
/
webgpu
/
ffi
/
wgpu
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
gfx
/
CanvasManagerChild
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
namespace
mozilla
{
namespace
webgpu
{
GPU_IMPL_CYCLE_COLLECTION
(
Instance
mBridge
mOwner
)
already_AddRefed
<
Instance
>
Instance
:
:
Create
(
nsIGlobalObject
*
aOwner
)
{
RefPtr
<
WebGPUChild
>
bridge
;
if
(
gfx
:
:
gfxVars
:
:
AllowWebGPU
(
)
)
{
bridge
=
gfx
:
:
CanvasManagerChild
:
:
Get
(
)
-
>
GetWebGPUChild
(
)
;
if
(
NS_WARN_IF
(
!
bridge
)
)
{
MOZ_CRASH
(
"
Failed
to
create
an
IPDL
bridge
for
WebGPU
!
"
)
;
}
}
RefPtr
<
Instance
>
result
=
new
Instance
(
aOwner
bridge
)
;
return
result
.
forget
(
)
;
}
Instance
:
:
Instance
(
nsIGlobalObject
*
aOwner
WebGPUChild
*
aBridge
)
:
mBridge
(
aBridge
)
mOwner
(
aOwner
)
{
}
Instance
:
:
~
Instance
(
)
{
Cleanup
(
)
;
}
void
Instance
:
:
Cleanup
(
)
{
}
JSObject
*
Instance
:
:
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
givenProto
)
{
return
dom
:
:
GPU_Binding
:
:
Wrap
(
cx
this
givenProto
)
;
}
already_AddRefed
<
dom
:
:
Promise
>
Instance
:
:
RequestAdapter
(
const
dom
:
:
GPURequestAdapterOptions
&
aOptions
ErrorResult
&
aRv
)
{
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
mOwner
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
!
mBridge
)
{
promise
-
>
MaybeRejectWithInvalidStateError
(
"
WebGPU
is
not
enabled
!
"
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
Instance
>
instance
=
this
;
mBridge
-
>
InstanceRequestAdapter
(
aOptions
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
instance
]
(
ipc
:
:
ByteBuf
aInfoBuf
)
{
ffi
:
:
WGPUAdapterInformation
info
=
{
}
;
ffi
:
:
wgpu_client_adapter_extract_info
(
ToFFI
(
&
aInfoBuf
)
&
info
)
;
MOZ_ASSERT
(
info
.
id
!
=
0
)
;
RefPtr
<
Adapter
>
adapter
=
new
Adapter
(
instance
info
)
;
promise
-
>
MaybeResolve
(
adapter
)
;
}
[
promise
]
(
const
Maybe
<
ipc
:
:
ResponseRejectReason
>
&
aResponseReason
)
{
if
(
aResponseReason
.
isSome
(
)
)
{
promise
-
>
MaybeRejectWithAbortError
(
"
Internal
communication
error
!
"
)
;
}
else
{
promise
-
>
MaybeResolve
(
JS
:
:
NullHandleValue
)
;
}
}
)
;
return
promise
.
forget
(
)
;
}
}
}
