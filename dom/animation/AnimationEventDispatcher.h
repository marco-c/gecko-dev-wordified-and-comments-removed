#
ifndef
mozilla_AnimationEventDispatcher_h
#
define
mozilla_AnimationEventDispatcher_h
#
include
<
algorithm
>
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffect
.
h
"
#
include
"
mozilla
/
dom
/
AnimationPlaybackEvent
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsPresContext
.
h
"
class
nsRefreshDriver
;
namespace
geckoprofiler
:
:
markers
{
using
namespace
mozilla
;
struct
CSSAnimationMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
CSSAnimation
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
nsCString
&
aName
const
nsCString
&
aTarget
nsCSSPropertyIDSet
aPropertySet
)
{
aWriter
.
StringProperty
(
"
Name
"
aName
)
;
aWriter
.
StringProperty
(
"
Target
"
aTarget
)
;
nsAutoCString
properties
;
nsAutoCString
oncompositor
;
for
(
nsCSSPropertyID
property
:
aPropertySet
)
{
if
(
!
properties
.
IsEmpty
(
)
)
{
properties
.
AppendLiteral
(
"
"
)
;
oncompositor
.
AppendLiteral
(
"
"
)
;
}
properties
.
Append
(
nsCSSProps
:
:
GetStringValue
(
property
)
)
;
oncompositor
.
Append
(
nsCSSProps
:
:
PropHasFlags
(
property
CSSPropFlags
:
:
CanAnimateOnCompositor
)
?
"
true
"
:
"
false
"
)
;
}
aWriter
.
StringProperty
(
"
properties
"
properties
)
;
aWriter
.
StringProperty
(
"
oncompositor
"
oncompositor
)
;
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyFormatSearchable
(
"
Name
"
MS
:
:
Format
:
:
String
MS
:
:
Searchable
:
:
Searchable
)
;
schema
.
AddKeyLabelFormat
(
"
properties
"
"
Animated
Properties
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddKeyLabelFormat
(
"
oncompositor
"
"
Can
Run
on
Compositor
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddKeyFormat
(
"
Target
"
MS
:
:
Format
:
:
String
)
;
schema
.
SetChartLabel
(
"
{
marker
.
data
.
Name
}
"
)
;
schema
.
SetTableLabel
(
"
{
marker
.
name
}
-
{
marker
.
data
.
Name
}
:
{
marker
.
data
.
properties
}
"
)
;
return
schema
;
}
}
;
struct
CSSTransitionMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
CSSTransition
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
nsCString
&
aTarget
nsCSSPropertyID
aProperty
bool
aCanceled
)
{
aWriter
.
StringProperty
(
"
Target
"
aTarget
)
;
aWriter
.
StringProperty
(
"
property
"
nsCSSProps
:
:
GetStringValue
(
aProperty
)
)
;
aWriter
.
BoolProperty
(
"
oncompositor
"
nsCSSProps
:
:
PropHasFlags
(
aProperty
CSSPropFlags
:
:
CanAnimateOnCompositor
)
)
;
if
(
aCanceled
)
{
aWriter
.
BoolProperty
(
"
Canceled
"
aCanceled
)
;
}
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyLabelFormat
(
"
property
"
"
Animated
Property
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddKeyLabelFormat
(
"
oncompositor
"
"
Can
Run
on
Compositor
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddKeyFormat
(
"
Canceled
"
MS
:
:
Format
:
:
String
)
;
schema
.
AddKeyFormat
(
"
Target
"
MS
:
:
Format
:
:
String
)
;
schema
.
SetChartLabel
(
"
{
marker
.
data
.
property
}
"
)
;
schema
.
SetTableLabel
(
"
{
marker
.
name
}
-
{
marker
.
data
.
property
}
"
)
;
return
schema
;
}
}
;
}
namespace
mozilla
{
struct
AnimationEventInfo
{
struct
CssAnimationOrTransitionData
{
OwningAnimationTarget
mTarget
;
const
EventMessage
mMessage
;
const
double
mElapsedTime
;
const
TimeStamp
mEventEnqueueTimeStamp
{
TimeStamp
:
:
Now
(
)
}
;
}
;
struct
CssAnimationData
:
public
CssAnimationOrTransitionData
{
const
RefPtr
<
nsAtom
>
mAnimationName
;
}
;
struct
CssTransitionData
:
public
CssAnimationOrTransitionData
{
const
nsCSSPropertyID
mPropertyId
=
eCSSProperty_UNKNOWN
;
}
;
struct
WebAnimationData
{
RefPtr
<
dom
:
:
AnimationPlaybackEvent
>
mEvent
;
}
;
using
Data
=
Variant
<
CssAnimationData
CssTransitionData
WebAnimationData
>
;
RefPtr
<
dom
:
:
Animation
>
mAnimation
;
TimeStamp
mScheduledEventTimeStamp
;
Data
mData
;
OwningAnimationTarget
*
GetOwningAnimationTarget
(
)
{
if
(
mData
.
is
<
CssAnimationData
>
(
)
)
{
return
&
mData
.
as
<
CssAnimationData
>
(
)
.
mTarget
;
}
if
(
mData
.
is
<
CssTransitionData
>
(
)
)
{
return
&
mData
.
as
<
CssTransitionData
>
(
)
.
mTarget
;
}
return
nullptr
;
}
void
MaybeAddMarker
(
)
const
;
AnimationEventInfo
(
nsAtom
*
aAnimationName
const
NonOwningAnimationTarget
&
aTarget
EventMessage
aMessage
double
aElapsedTime
const
TimeStamp
&
aScheduledEventTimeStamp
dom
:
:
Animation
*
aAnimation
)
:
mAnimation
(
aAnimation
)
mScheduledEventTimeStamp
(
aScheduledEventTimeStamp
)
mData
(
CssAnimationData
{
{
OwningAnimationTarget
(
aTarget
.
mElement
aTarget
.
mPseudoType
)
aMessage
aElapsedTime
}
aAnimationName
}
)
{
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
MaybeAddMarker
(
)
;
}
}
AnimationEventInfo
(
nsCSSPropertyID
aProperty
const
NonOwningAnimationTarget
&
aTarget
EventMessage
aMessage
double
aElapsedTime
const
TimeStamp
&
aScheduledEventTimeStamp
dom
:
:
Animation
*
aAnimation
)
:
mAnimation
(
aAnimation
)
mScheduledEventTimeStamp
(
aScheduledEventTimeStamp
)
mData
(
CssTransitionData
{
{
OwningAnimationTarget
(
aTarget
.
mElement
aTarget
.
mPseudoType
)
aMessage
aElapsedTime
}
aProperty
}
)
{
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
MaybeAddMarker
(
)
;
}
}
AnimationEventInfo
(
RefPtr
<
dom
:
:
AnimationPlaybackEvent
>
&
&
aEvent
TimeStamp
&
&
aScheduledEventTimeStamp
dom
:
:
Animation
*
aAnimation
)
:
mAnimation
(
aAnimation
)
mScheduledEventTimeStamp
(
std
:
:
move
(
aScheduledEventTimeStamp
)
)
mData
(
WebAnimationData
{
std
:
:
move
(
aEvent
)
}
)
{
}
AnimationEventInfo
(
const
AnimationEventInfo
&
aOther
)
=
delete
;
AnimationEventInfo
&
operator
=
(
const
AnimationEventInfo
&
aOther
)
=
delete
;
AnimationEventInfo
(
AnimationEventInfo
&
&
aOther
)
=
default
;
AnimationEventInfo
&
operator
=
(
AnimationEventInfo
&
&
aOther
)
=
default
;
bool
IsWebAnimationEvent
(
)
const
{
return
mData
.
is
<
WebAnimationData
>
(
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
Dispatch
(
nsPresContext
*
aPresContext
)
{
if
(
mData
.
is
<
WebAnimationData
>
(
)
)
{
RefPtr
playbackEvent
=
mData
.
as
<
WebAnimationData
>
(
)
.
mEvent
;
RefPtr
target
=
mAnimation
;
EventDispatcher
:
:
DispatchDOMEvent
(
target
nullptr
playbackEvent
aPresContext
nullptr
)
;
return
;
}
if
(
mData
.
is
<
CssTransitionData
>
(
)
)
{
const
auto
&
data
=
mData
.
as
<
CssTransitionData
>
(
)
;
nsPIDOMWindowInner
*
win
=
data
.
mTarget
.
mElement
-
>
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
win
&
&
!
win
-
>
HasTransitionEventListeners
(
)
)
{
MOZ_ASSERT
(
data
.
mMessage
=
=
eTransitionStart
|
|
data
.
mMessage
=
=
eTransitionRun
|
|
data
.
mMessage
=
=
eTransitionEnd
|
|
data
.
mMessage
=
=
eTransitionCancel
)
;
return
;
}
InternalTransitionEvent
event
(
true
data
.
mMessage
)
;
CopyUTF8toUTF16
(
nsCSSProps
:
:
GetStringValue
(
data
.
mPropertyId
)
event
.
mPropertyName
)
;
event
.
mElapsedTime
=
data
.
mElapsedTime
;
event
.
mPseudoElement
=
nsCSSPseudoElements
:
:
PseudoTypeAsString
(
data
.
mTarget
.
mPseudoType
)
;
event
.
AssignEventTime
(
WidgetEventTime
(
data
.
mEventEnqueueTimeStamp
)
)
;
RefPtr
target
=
data
.
mTarget
.
mElement
;
EventDispatcher
:
:
Dispatch
(
target
aPresContext
&
event
)
;
return
;
}
const
auto
&
data
=
mData
.
as
<
CssAnimationData
>
(
)
;
InternalAnimationEvent
event
(
true
data
.
mMessage
)
;
data
.
mAnimationName
-
>
ToString
(
event
.
mAnimationName
)
;
event
.
mElapsedTime
=
data
.
mElapsedTime
;
event
.
mPseudoElement
=
nsCSSPseudoElements
:
:
PseudoTypeAsString
(
data
.
mTarget
.
mPseudoType
)
;
event
.
AssignEventTime
(
WidgetEventTime
(
data
.
mEventEnqueueTimeStamp
)
)
;
RefPtr
target
=
data
.
mTarget
.
mElement
;
EventDispatcher
:
:
Dispatch
(
target
aPresContext
&
event
)
;
}
}
;
class
AnimationEventDispatcher
final
{
public
:
explicit
AnimationEventDispatcher
(
nsPresContext
*
aPresContext
)
:
mPresContext
(
aPresContext
)
mIsSorted
(
true
)
mIsObserving
(
false
)
{
}
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
AnimationEventDispatcher
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
AnimationEventDispatcher
)
void
Disconnect
(
)
;
void
QueueEvent
(
AnimationEventInfo
&
&
aEvent
)
;
void
QueueEvents
(
nsTArray
<
AnimationEventInfo
>
&
&
aEvents
)
;
void
DispatchEvents
(
)
{
mIsObserving
=
false
;
if
(
!
mPresContext
|
|
mPendingEvents
.
IsEmpty
(
)
)
{
return
;
}
SortEvents
(
)
;
EventArray
events
=
std
:
:
move
(
mPendingEvents
)
;
for
(
AnimationEventInfo
&
info
:
events
)
{
info
.
Dispatch
(
mPresContext
)
;
if
(
!
mPresContext
)
{
break
;
}
}
}
void
ClearEventQueue
(
)
{
mPendingEvents
.
Clear
(
)
;
mIsSorted
=
true
;
}
bool
HasQueuedEvents
(
)
const
{
return
!
mPendingEvents
.
IsEmpty
(
)
;
}
private
:
#
ifndef
DEBUG
~
AnimationEventDispatcher
(
)
=
default
;
#
else
~
AnimationEventDispatcher
(
)
{
MOZ_ASSERT
(
!
mIsObserving
"
AnimationEventDispatcher
should
have
disassociated
from
"
"
nsRefreshDriver
"
)
;
}
#
endif
class
AnimationEventInfoLessThan
{
public
:
bool
operator
(
)
(
const
AnimationEventInfo
&
a
const
AnimationEventInfo
&
b
)
const
{
if
(
a
.
mScheduledEventTimeStamp
!
=
b
.
mScheduledEventTimeStamp
)
{
if
(
a
.
mScheduledEventTimeStamp
.
IsNull
(
)
|
|
b
.
mScheduledEventTimeStamp
.
IsNull
(
)
)
{
return
a
.
mScheduledEventTimeStamp
.
IsNull
(
)
;
}
return
a
.
mScheduledEventTimeStamp
<
b
.
mScheduledEventTimeStamp
;
}
if
(
a
.
IsWebAnimationEvent
(
)
!
=
b
.
IsWebAnimationEvent
(
)
)
{
return
a
.
IsWebAnimationEvent
(
)
;
}
AnimationPtrComparator
<
RefPtr
<
dom
:
:
Animation
>
>
comparator
;
return
comparator
.
LessThan
(
a
.
mAnimation
b
.
mAnimation
)
;
}
}
;
void
SortEvents
(
)
{
if
(
mIsSorted
)
{
return
;
}
for
(
auto
&
pending
:
mPendingEvents
)
{
pending
.
mAnimation
-
>
CachedChildIndexRef
(
)
.
reset
(
)
;
}
std
:
:
stable_sort
(
mPendingEvents
.
begin
(
)
mPendingEvents
.
end
(
)
AnimationEventInfoLessThan
(
)
)
;
mIsSorted
=
true
;
}
void
ScheduleDispatch
(
)
;
nsPresContext
*
mPresContext
;
typedef
nsTArray
<
AnimationEventInfo
>
EventArray
;
EventArray
mPendingEvents
;
bool
mIsSorted
;
bool
mIsObserving
;
}
;
}
#
endif
