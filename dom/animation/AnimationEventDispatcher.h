#
ifndef
mozilla_AnimationEventDispatcher_h
#
define
mozilla_AnimationEventDispatcher_h
#
include
<
algorithm
>
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
class
nsPresContext
;
class
nsRefreshDriver
;
namespace
mozilla
{
struct
AnimationEventInfo
{
RefPtr
<
dom
:
:
EventTarget
>
mTarget
;
RefPtr
<
dom
:
:
Animation
>
mAnimation
;
TimeStamp
mTimeStamp
;
typedef
Variant
<
InternalTransitionEvent
InternalAnimationEvent
>
EventVariant
;
EventVariant
mEvent
;
AnimationEventInfo
(
nsAtom
*
aAnimationName
const
NonOwningAnimationTarget
&
aTarget
EventMessage
aMessage
double
aElapsedTime
const
TimeStamp
&
aTimeStamp
dom
:
:
Animation
*
aAnimation
)
:
mTarget
(
aTarget
.
mElement
)
mAnimation
(
aAnimation
)
mTimeStamp
(
aTimeStamp
)
mEvent
(
EventVariant
(
InternalAnimationEvent
(
true
aMessage
)
)
)
{
InternalAnimationEvent
&
event
=
mEvent
.
as
<
InternalAnimationEvent
>
(
)
;
aAnimationName
-
>
ToString
(
event
.
mAnimationName
)
;
event
.
mElapsedTime
=
aElapsedTime
;
event
.
mPseudoElement
=
nsCSSPseudoElements
:
:
PseudoTypeAsString
(
aTarget
.
mPseudoType
)
;
}
AnimationEventInfo
(
nsCSSPropertyID
aProperty
const
NonOwningAnimationTarget
&
aTarget
EventMessage
aMessage
double
aElapsedTime
const
TimeStamp
&
aTimeStamp
dom
:
:
Animation
*
aAnimation
)
:
mTarget
(
aTarget
.
mElement
)
mAnimation
(
aAnimation
)
mTimeStamp
(
aTimeStamp
)
mEvent
(
EventVariant
(
InternalTransitionEvent
(
true
aMessage
)
)
)
{
InternalTransitionEvent
&
event
=
mEvent
.
as
<
InternalTransitionEvent
>
(
)
;
event
.
mPropertyName
=
NS_ConvertUTF8toUTF16
(
nsCSSProps
:
:
GetStringValue
(
aProperty
)
)
;
event
.
mElapsedTime
=
aElapsedTime
;
event
.
mPseudoElement
=
nsCSSPseudoElements
:
:
PseudoTypeAsString
(
aTarget
.
mPseudoType
)
;
}
AnimationEventInfo
(
const
AnimationEventInfo
&
aOther
)
=
delete
;
AnimationEventInfo
&
operator
=
(
const
AnimationEventInfo
&
aOther
)
=
delete
;
AnimationEventInfo
(
AnimationEventInfo
&
&
aOther
)
=
default
;
AnimationEventInfo
&
operator
=
(
AnimationEventInfo
&
&
aOther
)
=
default
;
WidgetEvent
*
AsWidgetEvent
(
)
{
if
(
mEvent
.
is
<
InternalTransitionEvent
>
(
)
)
{
return
&
mEvent
.
as
<
InternalTransitionEvent
>
(
)
;
}
if
(
mEvent
.
is
<
InternalAnimationEvent
>
(
)
)
{
return
&
mEvent
.
as
<
InternalAnimationEvent
>
(
)
;
}
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Unexpected
event
type
"
)
;
return
nullptr
;
}
}
;
class
AnimationEventDispatcher
final
{
public
:
explicit
AnimationEventDispatcher
(
nsPresContext
*
aPresContext
)
:
mPresContext
(
aPresContext
)
mIsSorted
(
true
)
mIsObserving
(
false
)
{
}
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
AnimationEventDispatcher
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
AnimationEventDispatcher
)
void
Disconnect
(
)
;
void
QueueEvents
(
nsTArray
<
AnimationEventInfo
>
&
&
aEvents
)
;
void
DispatchEvents
(
)
{
mIsObserving
=
false
;
if
(
!
mPresContext
|
|
mPendingEvents
.
IsEmpty
(
)
)
{
return
;
}
SortEvents
(
)
;
EventArray
events
;
mPendingEvents
.
SwapElements
(
events
)
;
for
(
AnimationEventInfo
&
info
:
events
)
{
MOZ_ASSERT
(
!
info
.
AsWidgetEvent
(
)
-
>
mFlags
.
mIsBeingDispatched
&
&
!
info
.
AsWidgetEvent
(
)
-
>
mFlags
.
mDispatchedAtLeastOnce
"
The
WidgetEvent
should
be
fresh
"
)
;
EventDispatcher
:
:
Dispatch
(
info
.
mTarget
mPresContext
info
.
AsWidgetEvent
(
)
)
;
if
(
!
mPresContext
)
{
break
;
}
}
}
void
ClearEventQueue
(
)
{
mPendingEvents
.
Clear
(
)
;
mIsSorted
=
true
;
}
bool
HasQueuedEvents
(
)
const
{
return
!
mPendingEvents
.
IsEmpty
(
)
;
}
private
:
#
ifndef
DEBUG
~
AnimationEventDispatcher
(
)
=
default
;
#
else
~
AnimationEventDispatcher
(
)
{
MOZ_ASSERT
(
!
mIsObserving
"
AnimationEventDispatcher
should
have
disassociated
from
"
"
nsRefreshDriver
"
)
;
}
#
endif
class
AnimationEventInfoLessThan
{
public
:
bool
operator
(
)
(
const
AnimationEventInfo
&
a
const
AnimationEventInfo
&
b
)
const
{
if
(
a
.
mTimeStamp
!
=
b
.
mTimeStamp
)
{
if
(
a
.
mTimeStamp
.
IsNull
(
)
|
|
b
.
mTimeStamp
.
IsNull
(
)
)
{
return
a
.
mTimeStamp
.
IsNull
(
)
;
}
else
{
return
a
.
mTimeStamp
<
b
.
mTimeStamp
;
}
}
AnimationPtrComparator
<
RefPtr
<
dom
:
:
Animation
>
>
comparator
;
return
comparator
.
LessThan
(
a
.
mAnimation
b
.
mAnimation
)
;
}
}
;
void
SortEvents
(
)
{
if
(
mIsSorted
)
{
return
;
}
std
:
:
stable_sort
(
mPendingEvents
.
begin
(
)
mPendingEvents
.
end
(
)
AnimationEventInfoLessThan
(
)
)
;
mIsSorted
=
true
;
}
nsPresContext
*
mPresContext
;
typedef
nsTArray
<
AnimationEventInfo
>
EventArray
;
EventArray
mPendingEvents
;
bool
mIsSorted
;
bool
mIsObserving
;
}
;
}
#
endif
