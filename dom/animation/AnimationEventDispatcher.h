#
ifndef
mozilla_AnimationEventDispatcher_h
#
define
mozilla_AnimationEventDispatcher_h
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
dom
/
AnimationPlaybackEvent
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsPresContext
.
h
"
class
nsRefreshDriver
;
namespace
mozilla
{
struct
AnimationEventInfo
{
struct
CssAnimationOrTransitionData
{
OwningAnimationTarget
mTarget
;
const
EventMessage
mMessage
;
const
double
mElapsedTime
;
const
uint64_t
mAnimationIndex
;
const
TimeStamp
mEventEnqueueTimeStamp
{
TimeStamp
:
:
Now
(
)
}
;
}
;
struct
CssAnimationData
:
public
CssAnimationOrTransitionData
{
const
RefPtr
<
nsAtom
>
mAnimationName
;
}
;
struct
CssTransitionData
:
public
CssAnimationOrTransitionData
{
const
AnimatedPropertyID
mProperty
;
}
;
struct
WebAnimationData
{
const
RefPtr
<
nsAtom
>
mOnEvent
;
const
dom
:
:
Nullable
<
double
>
mCurrentTime
;
const
dom
:
:
Nullable
<
double
>
mTimelineTime
;
const
TimeStamp
mEventEnqueueTimeStamp
{
TimeStamp
:
:
Now
(
)
}
;
}
;
using
Data
=
Variant
<
CssAnimationData
CssTransitionData
WebAnimationData
>
;
RefPtr
<
dom
:
:
Animation
>
mAnimation
;
TimeStamp
mScheduledEventTimeStamp
;
Data
mData
;
OwningAnimationTarget
*
GetOwningAnimationTarget
(
)
{
if
(
mData
.
is
<
CssAnimationData
>
(
)
)
{
return
&
mData
.
as
<
CssAnimationData
>
(
)
.
mTarget
;
}
if
(
mData
.
is
<
CssTransitionData
>
(
)
)
{
return
&
mData
.
as
<
CssTransitionData
>
(
)
.
mTarget
;
}
return
nullptr
;
}
Maybe
<
dom
:
:
Animation
:
:
EventContext
>
GetEventContext
(
)
const
{
if
(
mData
.
is
<
CssAnimationData
>
(
)
)
{
const
auto
&
data
=
mData
.
as
<
CssAnimationData
>
(
)
;
return
Some
(
dom
:
:
Animation
:
:
EventContext
{
NonOwningAnimationTarget
(
data
.
mTarget
)
data
.
mAnimationIndex
}
)
;
}
if
(
mData
.
is
<
CssTransitionData
>
(
)
)
{
const
auto
&
data
=
mData
.
as
<
CssTransitionData
>
(
)
;
return
Some
(
dom
:
:
Animation
:
:
EventContext
{
NonOwningAnimationTarget
(
data
.
mTarget
)
data
.
mAnimationIndex
}
)
;
}
return
Nothing
(
)
;
}
void
MaybeAddMarker
(
)
const
;
AnimationEventInfo
(
RefPtr
<
nsAtom
>
aAnimationName
const
NonOwningAnimationTarget
&
aTarget
EventMessage
aMessage
double
aElapsedTime
uint64_t
aAnimationIndex
const
TimeStamp
&
aScheduledEventTimeStamp
dom
:
:
Animation
*
aAnimation
)
:
mAnimation
(
aAnimation
)
mScheduledEventTimeStamp
(
aScheduledEventTimeStamp
)
mData
(
CssAnimationData
{
{
OwningAnimationTarget
(
aTarget
.
mElement
aTarget
.
mPseudoRequest
)
aMessage
aElapsedTime
aAnimationIndex
}
std
:
:
move
(
aAnimationName
)
}
)
{
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
MaybeAddMarker
(
)
;
}
}
AnimationEventInfo
(
const
AnimatedPropertyID
&
aProperty
const
NonOwningAnimationTarget
&
aTarget
EventMessage
aMessage
double
aElapsedTime
uint64_t
aTransitionGeneration
const
TimeStamp
&
aScheduledEventTimeStamp
dom
:
:
Animation
*
aAnimation
)
:
mAnimation
(
aAnimation
)
mScheduledEventTimeStamp
(
aScheduledEventTimeStamp
)
mData
(
CssTransitionData
{
{
OwningAnimationTarget
(
aTarget
.
mElement
aTarget
.
mPseudoRequest
)
aMessage
aElapsedTime
aTransitionGeneration
}
aProperty
}
)
{
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
MaybeAddMarker
(
)
;
}
}
AnimationEventInfo
(
nsAtom
*
aOnEvent
const
dom
:
:
Nullable
<
double
>
&
aCurrentTime
const
dom
:
:
Nullable
<
double
>
&
aTimelineTime
TimeStamp
&
&
aScheduledEventTimeStamp
dom
:
:
Animation
*
aAnimation
)
:
mAnimation
(
aAnimation
)
mScheduledEventTimeStamp
(
std
:
:
move
(
aScheduledEventTimeStamp
)
)
mData
(
WebAnimationData
{
RefPtr
{
aOnEvent
}
aCurrentTime
aTimelineTime
}
)
{
}
AnimationEventInfo
(
const
AnimationEventInfo
&
aOther
)
=
delete
;
AnimationEventInfo
&
operator
=
(
const
AnimationEventInfo
&
aOther
)
=
delete
;
AnimationEventInfo
(
AnimationEventInfo
&
&
aOther
)
=
default
;
AnimationEventInfo
&
operator
=
(
AnimationEventInfo
&
&
aOther
)
=
default
;
int32_t
Compare
(
const
AnimationEventInfo
&
aOther
nsContentUtils
:
:
NodeIndexCache
&
aCache
)
const
{
if
(
mScheduledEventTimeStamp
!
=
aOther
.
mScheduledEventTimeStamp
)
{
if
(
mScheduledEventTimeStamp
.
IsNull
(
)
)
{
return
-
1
;
}
if
(
aOther
.
mScheduledEventTimeStamp
.
IsNull
(
)
)
{
return
1
;
}
return
mScheduledEventTimeStamp
<
aOther
.
mScheduledEventTimeStamp
?
-
1
:
1
;
}
if
(
IsWebAnimationEvent
(
)
!
=
aOther
.
IsWebAnimationEvent
(
)
)
{
return
IsWebAnimationEvent
(
)
?
-
1
:
1
;
}
return
mAnimation
-
>
CompareCompositeOrder
(
GetEventContext
(
)
*
aOther
.
mAnimation
aOther
.
GetEventContext
(
)
aCache
)
;
}
bool
IsWebAnimationEvent
(
)
const
{
return
mData
.
is
<
WebAnimationData
>
(
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
Dispatch
(
nsPresContext
*
aPresContext
)
{
if
(
mData
.
is
<
WebAnimationData
>
(
)
)
{
const
auto
&
data
=
mData
.
as
<
WebAnimationData
>
(
)
;
EventListenerManager
*
elm
=
mAnimation
-
>
GetExistingListenerManager
(
)
;
if
(
!
elm
|
|
!
elm
-
>
HasListenersFor
(
data
.
mOnEvent
)
)
{
return
;
}
dom
:
:
AnimationPlaybackEventInit
init
;
init
.
mCurrentTime
=
data
.
mCurrentTime
;
init
.
mTimelineTime
=
data
.
mTimelineTime
;
MOZ_ASSERT
(
nsDependentAtomString
(
data
.
mOnEvent
)
.
Find
(
u
"
on
"
_ns
)
=
=
0
"
mOnEvent
atom
should
start
with
'
on
'
!
"
)
;
RefPtr
<
dom
:
:
AnimationPlaybackEvent
>
event
=
dom
:
:
AnimationPlaybackEvent
:
:
Constructor
(
mAnimation
Substring
(
nsDependentAtomString
(
data
.
mOnEvent
)
2
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
event
-
>
WidgetEventPtr
(
)
-
>
AssignEventTime
(
WidgetEventTime
(
data
.
mEventEnqueueTimeStamp
)
)
;
RefPtr
target
=
mAnimation
;
EventDispatcher
:
:
DispatchDOMEvent
(
target
nullptr
event
aPresContext
nullptr
)
;
return
;
}
if
(
mData
.
is
<
CssTransitionData
>
(
)
)
{
const
auto
&
data
=
mData
.
as
<
CssTransitionData
>
(
)
;
nsPIDOMWindowInner
*
win
=
data
.
mTarget
.
mElement
-
>
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
win
&
&
!
win
-
>
HasTransitionEventListeners
(
)
)
{
MOZ_ASSERT
(
data
.
mMessage
=
=
eTransitionStart
|
|
data
.
mMessage
=
=
eTransitionRun
|
|
data
.
mMessage
=
=
eTransitionEnd
|
|
data
.
mMessage
=
=
eTransitionCancel
)
;
return
;
}
InternalTransitionEvent
event
(
true
data
.
mMessage
)
;
data
.
mProperty
.
ToString
(
event
.
mPropertyName
)
;
event
.
mElapsedTime
=
data
.
mElapsedTime
;
event
.
mPseudoElement
=
nsCSSPseudoElements
:
:
PseudoRequestAsString
(
data
.
mTarget
.
mPseudoRequest
)
;
event
.
AssignEventTime
(
WidgetEventTime
(
data
.
mEventEnqueueTimeStamp
)
)
;
RefPtr
target
=
data
.
mTarget
.
mElement
;
EventDispatcher
:
:
Dispatch
(
target
aPresContext
&
event
)
;
return
;
}
const
auto
&
data
=
mData
.
as
<
CssAnimationData
>
(
)
;
InternalAnimationEvent
event
(
true
data
.
mMessage
)
;
data
.
mAnimationName
-
>
ToString
(
event
.
mAnimationName
)
;
event
.
mElapsedTime
=
data
.
mElapsedTime
;
event
.
mPseudoElement
=
nsCSSPseudoElements
:
:
PseudoRequestAsString
(
data
.
mTarget
.
mPseudoRequest
)
;
event
.
AssignEventTime
(
WidgetEventTime
(
data
.
mEventEnqueueTimeStamp
)
)
;
RefPtr
target
=
data
.
mTarget
.
mElement
;
EventDispatcher
:
:
Dispatch
(
target
aPresContext
&
event
)
;
}
}
;
class
AnimationEventDispatcher
final
{
public
:
explicit
AnimationEventDispatcher
(
nsPresContext
*
aPresContext
)
:
mPresContext
(
aPresContext
)
mIsSorted
(
true
)
mIsObserving
(
false
)
{
}
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
AnimationEventDispatcher
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
AnimationEventDispatcher
)
void
Disconnect
(
)
;
void
QueueEvent
(
AnimationEventInfo
&
&
aEvent
)
;
void
QueueEvents
(
nsTArray
<
AnimationEventInfo
>
&
&
aEvents
)
;
void
DispatchEvents
(
)
{
mIsObserving
=
false
;
if
(
!
mPresContext
|
|
mPendingEvents
.
IsEmpty
(
)
)
{
return
;
}
SortEvents
(
)
;
EventArray
events
=
std
:
:
move
(
mPendingEvents
)
;
for
(
AnimationEventInfo
&
info
:
events
)
{
info
.
Dispatch
(
mPresContext
)
;
if
(
!
mPresContext
)
{
break
;
}
}
}
void
ClearEventQueue
(
)
{
mPendingEvents
.
Clear
(
)
;
mIsSorted
=
true
;
}
bool
HasQueuedEvents
(
)
const
{
return
!
mPendingEvents
.
IsEmpty
(
)
;
}
bool
HasQueuedEventsFor
(
const
dom
:
:
Animation
*
aAnimation
)
const
{
for
(
const
AnimationEventInfo
&
info
:
mPendingEvents
)
{
if
(
info
.
mAnimation
.
get
(
)
=
=
aAnimation
)
{
return
true
;
}
}
return
false
;
}
private
:
#
ifndef
DEBUG
~
AnimationEventDispatcher
(
)
=
default
;
#
else
~
AnimationEventDispatcher
(
)
{
MOZ_ASSERT
(
!
mIsObserving
"
AnimationEventDispatcher
should
have
disassociated
from
"
"
nsRefreshDriver
"
)
;
}
#
endif
void
SortEvents
(
)
{
if
(
mIsSorted
)
{
return
;
}
struct
AnimationEventInfoComparator
{
mutable
nsContentUtils
:
:
NodeIndexCache
mCache
;
bool
LessThan
(
const
AnimationEventInfo
&
aOne
const
AnimationEventInfo
&
aOther
)
const
{
return
aOne
.
Compare
(
aOther
mCache
)
<
0
;
}
}
;
mPendingEvents
.
StableSort
(
AnimationEventInfoComparator
(
)
)
;
mIsSorted
=
true
;
}
void
ScheduleDispatch
(
)
;
nsPresContext
*
mPresContext
;
using
EventArray
=
nsTArray
<
AnimationEventInfo
>
;
EventArray
mPendingEvents
;
bool
mIsSorted
;
bool
mIsObserving
;
}
;
}
#
endif
