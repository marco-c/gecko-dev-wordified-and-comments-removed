#
ifndef
mozilla_AnimationEventDispatcher_h
#
define
mozilla_AnimationEventDispatcher_h
#
include
<
algorithm
>
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
dom
/
AnimationPlaybackEvent
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsPresContext
.
h
"
class
nsRefreshDriver
;
namespace
mozilla
{
struct
AnimationEventInfo
{
RefPtr
<
dom
:
:
EventTarget
>
mTarget
;
RefPtr
<
dom
:
:
Animation
>
mAnimation
;
TimeStamp
mScheduledEventTimeStamp
;
typedef
Variant
<
InternalTransitionEvent
InternalAnimationEvent
RefPtr
<
dom
:
:
AnimationPlaybackEvent
>
>
EventVariant
;
EventVariant
mEvent
;
AnimationEventInfo
(
nsAtom
*
aAnimationName
const
NonOwningAnimationTarget
&
aTarget
EventMessage
aMessage
double
aElapsedTime
const
TimeStamp
&
aScheduledEventTimeStamp
dom
:
:
Animation
*
aAnimation
)
:
mTarget
(
aTarget
.
mElement
)
mAnimation
(
aAnimation
)
mScheduledEventTimeStamp
(
aScheduledEventTimeStamp
)
mEvent
(
EventVariant
(
InternalAnimationEvent
(
true
aMessage
)
)
)
{
InternalAnimationEvent
&
event
=
mEvent
.
as
<
InternalAnimationEvent
>
(
)
;
aAnimationName
-
>
ToString
(
event
.
mAnimationName
)
;
event
.
mElapsedTime
=
aElapsedTime
;
event
.
mPseudoElement
=
nsCSSPseudoElements
:
:
PseudoTypeAsString
(
aTarget
.
mPseudoType
)
;
if
(
(
aMessage
=
=
eAnimationCancel
|
|
aMessage
=
=
eAnimationEnd
)
&
&
profiler_thread_is_being_profiled
(
)
)
{
nsCString
markerText
;
aAnimationName
-
>
ToUTF8String
(
markerText
)
;
PROFILER_MARKER_TEXT
(
"
CSS
animation
"
DOM
MarkerOptions
(
MarkerTiming
:
:
Interval
(
aScheduledEventTimeStamp
-
TimeDuration
:
:
FromSeconds
(
aElapsedTime
)
aScheduledEventTimeStamp
)
aAnimation
-
>
GetOwner
(
)
?
MarkerInnerWindowId
(
aAnimation
-
>
GetOwner
(
)
-
>
WindowID
(
)
)
:
MarkerInnerWindowId
:
:
NoId
(
)
)
markerText
)
;
}
}
AnimationEventInfo
(
nsCSSPropertyID
aProperty
const
NonOwningAnimationTarget
&
aTarget
EventMessage
aMessage
double
aElapsedTime
const
TimeStamp
&
aScheduledEventTimeStamp
dom
:
:
Animation
*
aAnimation
)
:
mTarget
(
aTarget
.
mElement
)
mAnimation
(
aAnimation
)
mScheduledEventTimeStamp
(
aScheduledEventTimeStamp
)
mEvent
(
EventVariant
(
InternalTransitionEvent
(
true
aMessage
)
)
)
{
InternalTransitionEvent
&
event
=
mEvent
.
as
<
InternalTransitionEvent
>
(
)
;
event
.
mPropertyName
=
NS_ConvertUTF8toUTF16
(
nsCSSProps
:
:
GetStringValue
(
aProperty
)
)
;
event
.
mElapsedTime
=
aElapsedTime
;
event
.
mPseudoElement
=
nsCSSPseudoElements
:
:
PseudoTypeAsString
(
aTarget
.
mPseudoType
)
;
if
(
(
aMessage
=
=
eTransitionEnd
|
|
aMessage
=
=
eTransitionCancel
)
&
&
profiler_thread_is_being_profiled
(
)
)
{
nsCString
markerText
;
markerText
.
Assign
(
nsCSSProps
:
:
GetStringValue
(
aProperty
)
)
;
if
(
aMessage
=
=
eTransitionCancel
)
{
markerText
.
AppendLiteral
(
"
(
canceled
)
"
)
;
}
PROFILER_MARKER_TEXT
(
"
CSS
transition
"
DOM
MarkerOptions
(
MarkerTiming
:
:
Interval
(
aScheduledEventTimeStamp
-
TimeDuration
:
:
FromSeconds
(
aElapsedTime
)
aScheduledEventTimeStamp
)
aAnimation
-
>
GetOwner
(
)
?
MarkerInnerWindowId
(
aAnimation
-
>
GetOwner
(
)
-
>
WindowID
(
)
)
:
MarkerInnerWindowId
:
:
NoId
(
)
)
markerText
)
;
}
}
AnimationEventInfo
(
const
nsAString
&
aName
RefPtr
<
dom
:
:
AnimationPlaybackEvent
>
&
&
aEvent
TimeStamp
&
&
aScheduledEventTimeStamp
dom
:
:
Animation
*
aAnimation
)
:
mTarget
(
aAnimation
)
mAnimation
(
aAnimation
)
mScheduledEventTimeStamp
(
std
:
:
move
(
aScheduledEventTimeStamp
)
)
mEvent
(
std
:
:
move
(
aEvent
)
)
{
}
AnimationEventInfo
(
const
AnimationEventInfo
&
aOther
)
=
delete
;
AnimationEventInfo
&
operator
=
(
const
AnimationEventInfo
&
aOther
)
=
delete
;
AnimationEventInfo
(
AnimationEventInfo
&
&
aOther
)
=
default
;
AnimationEventInfo
&
operator
=
(
AnimationEventInfo
&
&
aOther
)
=
default
;
bool
IsWebAnimationEvent
(
)
const
{
return
mEvent
.
is
<
RefPtr
<
dom
:
:
AnimationPlaybackEvent
>
>
(
)
;
}
#
ifdef
DEBUG
bool
IsStale
(
)
const
{
const
WidgetEvent
*
widgetEvent
=
AsWidgetEvent
(
)
;
return
widgetEvent
-
>
mFlags
.
mIsBeingDispatched
|
|
widgetEvent
-
>
mFlags
.
mDispatchedAtLeastOnce
;
}
const
WidgetEvent
*
AsWidgetEvent
(
)
const
{
return
const_cast
<
AnimationEventInfo
*
>
(
this
)
-
>
AsWidgetEvent
(
)
;
}
#
endif
WidgetEvent
*
AsWidgetEvent
(
)
{
if
(
mEvent
.
is
<
InternalTransitionEvent
>
(
)
)
{
return
&
mEvent
.
as
<
InternalTransitionEvent
>
(
)
;
}
if
(
mEvent
.
is
<
InternalAnimationEvent
>
(
)
)
{
return
&
mEvent
.
as
<
InternalAnimationEvent
>
(
)
;
}
if
(
mEvent
.
is
<
RefPtr
<
dom
:
:
AnimationPlaybackEvent
>
>
(
)
)
{
return
mEvent
.
as
<
RefPtr
<
dom
:
:
AnimationPlaybackEvent
>
>
(
)
-
>
WidgetEventPtr
(
)
;
}
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Unexpected
event
type
"
)
;
return
nullptr
;
}
void
Dispatch
(
nsPresContext
*
aPresContext
)
{
if
(
mEvent
.
is
<
RefPtr
<
dom
:
:
AnimationPlaybackEvent
>
>
(
)
)
{
EventDispatcher
:
:
DispatchDOMEvent
(
mTarget
nullptr
mEvent
.
as
<
RefPtr
<
dom
:
:
AnimationPlaybackEvent
>
>
(
)
aPresContext
nullptr
)
;
return
;
}
MOZ_ASSERT
(
mEvent
.
is
<
InternalTransitionEvent
>
(
)
|
|
mEvent
.
is
<
InternalAnimationEvent
>
(
)
)
;
EventDispatcher
:
:
Dispatch
(
mTarget
aPresContext
AsWidgetEvent
(
)
)
;
}
}
;
class
AnimationEventDispatcher
final
{
public
:
explicit
AnimationEventDispatcher
(
nsPresContext
*
aPresContext
)
:
mPresContext
(
aPresContext
)
mIsSorted
(
true
)
mIsObserving
(
false
)
{
}
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
AnimationEventDispatcher
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
AnimationEventDispatcher
)
void
Disconnect
(
)
;
void
QueueEvent
(
AnimationEventInfo
&
&
aEvent
)
;
void
QueueEvents
(
nsTArray
<
AnimationEventInfo
>
&
&
aEvents
)
;
void
DispatchEvents
(
)
{
mIsObserving
=
false
;
if
(
!
mPresContext
|
|
mPendingEvents
.
IsEmpty
(
)
)
{
return
;
}
SortEvents
(
)
;
EventArray
events
=
std
:
:
move
(
mPendingEvents
)
;
for
(
AnimationEventInfo
&
info
:
events
)
{
MOZ_ASSERT
(
!
info
.
IsStale
(
)
"
The
event
shouldn
'
t
be
stale
"
)
;
info
.
Dispatch
(
mPresContext
)
;
if
(
!
mPresContext
)
{
break
;
}
}
}
void
ClearEventQueue
(
)
{
mPendingEvents
.
Clear
(
)
;
mIsSorted
=
true
;
}
bool
HasQueuedEvents
(
)
const
{
return
!
mPendingEvents
.
IsEmpty
(
)
;
}
private
:
#
ifndef
DEBUG
~
AnimationEventDispatcher
(
)
=
default
;
#
else
~
AnimationEventDispatcher
(
)
{
MOZ_ASSERT
(
!
mIsObserving
"
AnimationEventDispatcher
should
have
disassociated
from
"
"
nsRefreshDriver
"
)
;
}
#
endif
class
AnimationEventInfoLessThan
{
public
:
bool
operator
(
)
(
const
AnimationEventInfo
&
a
const
AnimationEventInfo
&
b
)
const
{
if
(
a
.
mScheduledEventTimeStamp
!
=
b
.
mScheduledEventTimeStamp
)
{
if
(
a
.
mScheduledEventTimeStamp
.
IsNull
(
)
|
|
b
.
mScheduledEventTimeStamp
.
IsNull
(
)
)
{
return
a
.
mScheduledEventTimeStamp
.
IsNull
(
)
;
}
else
{
return
a
.
mScheduledEventTimeStamp
<
b
.
mScheduledEventTimeStamp
;
}
}
if
(
a
.
IsWebAnimationEvent
(
)
!
=
b
.
IsWebAnimationEvent
(
)
)
{
return
a
.
IsWebAnimationEvent
(
)
;
}
AnimationPtrComparator
<
RefPtr
<
dom
:
:
Animation
>
>
comparator
;
return
comparator
.
LessThan
(
a
.
mAnimation
b
.
mAnimation
)
;
}
}
;
void
SortEvents
(
)
{
if
(
mIsSorted
)
{
return
;
}
for
(
auto
&
pending
:
mPendingEvents
)
{
pending
.
mAnimation
-
>
CachedChildIndexRef
(
)
=
-
1
;
}
std
:
:
stable_sort
(
mPendingEvents
.
begin
(
)
mPendingEvents
.
end
(
)
AnimationEventInfoLessThan
(
)
)
;
mIsSorted
=
true
;
}
void
ScheduleDispatch
(
)
;
nsPresContext
*
mPresContext
;
typedef
nsTArray
<
AnimationEventInfo
>
EventArray
;
EventArray
mPendingEvents
;
bool
mIsSorted
;
bool
mIsObserving
;
}
;
}
#
endif
