#
ifndef
mozilla_AnimationEventDispatcher_h
#
define
mozilla_AnimationEventDispatcher_h
#
include
<
algorithm
>
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
class
nsPresContext
;
namespace
mozilla
{
template
<
class
EventInfo
>
class
AnimationEventDispatcher
final
{
public
:
AnimationEventDispatcher
(
)
:
mIsSorted
(
true
)
{
}
void
QueueEvents
(
nsTArray
<
EventInfo
>
&
&
aEvents
)
{
mPendingEvents
.
AppendElements
(
Forward
<
nsTArray
<
EventInfo
>
>
(
aEvents
)
)
;
mIsSorted
=
false
;
}
void
SortEvents
(
)
{
if
(
mIsSorted
)
{
return
;
}
std
:
:
stable_sort
(
mPendingEvents
.
begin
(
)
mPendingEvents
.
end
(
)
EventInfoLessThan
(
)
)
;
mIsSorted
=
true
;
}
void
DispatchEvents
(
nsPresContext
*
const
&
aPresContext
)
{
if
(
!
aPresContext
|
|
mPendingEvents
.
IsEmpty
(
)
)
{
return
;
}
SortEvents
(
)
;
EventArray
events
;
mPendingEvents
.
SwapElements
(
events
)
;
for
(
EventInfo
&
info
:
events
)
{
EventDispatcher
:
:
Dispatch
(
info
.
mElement
aPresContext
&
info
.
mEvent
)
;
if
(
!
aPresContext
)
{
break
;
}
}
}
void
ClearEventQueue
(
)
{
mPendingEvents
.
Clear
(
)
;
mIsSorted
=
true
;
}
bool
HasQueuedEvents
(
)
const
{
return
!
mPendingEvents
.
IsEmpty
(
)
;
}
void
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
const
char
*
aName
)
{
for
(
EventInfo
&
info
:
mPendingEvents
)
{
ImplCycleCollectionTraverse
(
*
aCallback
info
.
mElement
aName
)
;
ImplCycleCollectionTraverse
(
*
aCallback
info
.
mAnimation
aName
)
;
}
}
void
Unlink
(
)
{
ClearEventQueue
(
)
;
}
protected
:
class
EventInfoLessThan
{
public
:
bool
operator
(
)
(
const
EventInfo
&
a
const
EventInfo
&
b
)
const
{
if
(
a
.
mTimeStamp
!
=
b
.
mTimeStamp
)
{
if
(
a
.
mTimeStamp
.
IsNull
(
)
|
|
b
.
mTimeStamp
.
IsNull
(
)
)
{
return
a
.
mTimeStamp
.
IsNull
(
)
;
}
else
{
return
a
.
mTimeStamp
<
b
.
mTimeStamp
;
}
}
AnimationPtrComparator
<
RefPtr
<
dom
:
:
Animation
>
>
comparator
;
return
comparator
.
LessThan
(
a
.
mAnimation
b
.
mAnimation
)
;
}
}
;
typedef
nsTArray
<
EventInfo
>
EventArray
;
EventArray
mPendingEvents
;
bool
mIsSorted
;
}
;
template
<
class
EventInfo
>
inline
void
ImplCycleCollectionUnlink
(
AnimationEventDispatcher
<
EventInfo
>
&
aField
)
{
aField
.
Unlink
(
)
;
}
template
<
class
EventInfo
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
AnimationEventDispatcher
<
EventInfo
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
aField
.
Traverse
(
&
aCallback
aName
)
;
}
}
#
endif
