#
include
"
ComputedTimingFunction
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsStyleUtil
.
h
"
namespace
mozilla
{
void
ComputedTimingFunction
:
:
Init
(
const
nsTimingFunction
&
aFunction
)
{
mType
=
aFunction
.
mType
;
if
(
nsTimingFunction
:
:
IsSplineType
(
mType
)
)
{
mTimingFunction
.
Init
(
aFunction
.
mFunc
.
mX1
aFunction
.
mFunc
.
mY1
aFunction
.
mFunc
.
mX2
aFunction
.
mFunc
.
mY2
)
;
}
else
{
mSteps
=
aFunction
.
mSteps
;
mStepSyntax
=
aFunction
.
mStepSyntax
;
}
}
static
inline
double
StepEnd
(
uint32_t
aSteps
double
aPortion
)
{
MOZ_ASSERT
(
0
.
0
<
=
aPortion
&
&
aPortion
<
=
1
.
0
"
out
of
range
"
)
;
uint32_t
step
=
uint32_t
(
aPortion
*
aSteps
)
;
return
double
(
step
)
/
double
(
aSteps
)
;
}
double
ComputedTimingFunction
:
:
GetValue
(
double
aPortion
)
const
{
if
(
HasSpline
(
)
)
{
if
(
mTimingFunction
.
X1
(
)
=
=
mTimingFunction
.
Y1
(
)
&
&
mTimingFunction
.
X2
(
)
=
=
mTimingFunction
.
Y2
(
)
)
{
return
aPortion
;
}
if
(
aPortion
<
0
.
0
)
{
if
(
mTimingFunction
.
X1
(
)
>
0
.
0
)
{
return
aPortion
*
mTimingFunction
.
Y1
(
)
/
mTimingFunction
.
X1
(
)
;
}
else
if
(
mTimingFunction
.
Y1
(
)
=
=
0
&
&
mTimingFunction
.
X2
(
)
>
0
.
0
)
{
return
aPortion
*
mTimingFunction
.
Y2
(
)
/
mTimingFunction
.
X2
(
)
;
}
return
0
.
0
;
}
if
(
aPortion
>
1
.
0
)
{
if
(
mTimingFunction
.
X2
(
)
<
1
.
0
)
{
return
1
.
0
+
(
aPortion
-
1
.
0
)
*
(
mTimingFunction
.
Y2
(
)
-
1
)
/
(
mTimingFunction
.
X2
(
)
-
1
)
;
}
else
if
(
mTimingFunction
.
Y2
(
)
=
=
1
&
&
mTimingFunction
.
X1
(
)
<
1
.
0
)
{
return
1
.
0
+
(
aPortion
-
1
.
0
)
*
(
mTimingFunction
.
Y1
(
)
-
1
)
/
(
mTimingFunction
.
X1
(
)
-
1
)
;
}
return
1
.
0
;
}
return
mTimingFunction
.
GetSplineValue
(
aPortion
)
;
}
if
(
aPortion
<
0
.
0
)
{
return
0
.
0
;
}
aPortion
=
clamped
(
aPortion
0
.
0
1
.
0
)
;
if
(
mType
=
=
nsTimingFunction
:
:
Type
:
:
StepStart
)
{
return
1
.
0
-
StepEnd
(
mSteps
1
.
0
-
aPortion
)
;
}
MOZ_ASSERT
(
mType
=
=
nsTimingFunction
:
:
Type
:
:
StepEnd
"
bad
type
"
)
;
return
StepEnd
(
mSteps
aPortion
)
;
}
int32_t
ComputedTimingFunction
:
:
Compare
(
const
ComputedTimingFunction
&
aRhs
)
const
{
if
(
mType
!
=
aRhs
.
mType
)
{
return
int32_t
(
mType
)
-
int32_t
(
aRhs
.
mType
)
;
}
if
(
mType
=
=
nsTimingFunction
:
:
Type
:
:
CubicBezier
)
{
int32_t
order
=
mTimingFunction
.
Compare
(
aRhs
.
mTimingFunction
)
;
if
(
order
!
=
0
)
{
return
order
;
}
}
else
if
(
mType
=
=
nsTimingFunction
:
:
Type
:
:
StepStart
|
|
mType
=
=
nsTimingFunction
:
:
Type
:
:
StepEnd
)
{
if
(
mSteps
!
=
aRhs
.
mSteps
)
{
return
int32_t
(
mSteps
)
-
int32_t
(
aRhs
.
mSteps
)
;
}
if
(
mStepSyntax
!
=
aRhs
.
mStepSyntax
)
{
return
int32_t
(
mStepSyntax
)
-
int32_t
(
aRhs
.
mStepSyntax
)
;
}
}
return
0
;
}
void
ComputedTimingFunction
:
:
AppendToString
(
nsAString
&
aResult
)
const
{
switch
(
mType
)
{
case
nsTimingFunction
:
:
Type
:
:
CubicBezier
:
nsStyleUtil
:
:
AppendCubicBezierTimingFunction
(
mTimingFunction
.
X1
(
)
mTimingFunction
.
Y1
(
)
mTimingFunction
.
X2
(
)
mTimingFunction
.
Y2
(
)
aResult
)
;
break
;
case
nsTimingFunction
:
:
Type
:
:
StepStart
:
case
nsTimingFunction
:
:
Type
:
:
StepEnd
:
nsStyleUtil
:
:
AppendStepsTimingFunction
(
mType
mSteps
mStepSyntax
aResult
)
;
break
;
default
:
nsStyleUtil
:
:
AppendCubicBezierKeywordTimingFunction
(
mType
aResult
)
;
break
;
}
}
int32_t
ComputedTimingFunction
:
:
Compare
(
const
Maybe
<
ComputedTimingFunction
>
&
aLhs
const
Maybe
<
ComputedTimingFunction
>
&
aRhs
)
{
nsTimingFunction
:
:
Type
lhsType
=
aLhs
.
isNothing
(
)
?
nsTimingFunction
:
:
Type
:
:
Linear
:
aLhs
-
>
GetType
(
)
;
nsTimingFunction
:
:
Type
rhsType
=
aRhs
.
isNothing
(
)
?
nsTimingFunction
:
:
Type
:
:
Linear
:
aRhs
-
>
GetType
(
)
;
if
(
lhsType
!
=
rhsType
)
{
return
int32_t
(
lhsType
)
-
int32_t
(
rhsType
)
;
}
if
(
lhsType
=
=
nsTimingFunction
:
:
Type
:
:
Linear
)
{
return
0
;
}
return
aLhs
-
>
Compare
(
aRhs
.
value
(
)
)
;
}
}
