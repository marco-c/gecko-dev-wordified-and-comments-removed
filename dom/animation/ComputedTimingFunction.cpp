#
include
"
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
namespace
mozilla
{
ComputedTimingFunction
:
:
Function
ComputedTimingFunction
:
:
ConstructFunction
(
const
StyleComputedTimingFunction
&
aFunction
)
{
switch
(
aFunction
.
tag
)
{
case
StyleComputedTimingFunction
:
:
Tag
:
:
Keyword
:
{
static_assert
(
static_cast
<
uint8_t
>
(
StyleTimingKeyword
:
:
Linear
)
=
=
0
&
&
static_cast
<
uint8_t
>
(
StyleTimingKeyword
:
:
Ease
)
=
=
1
&
&
static_cast
<
uint8_t
>
(
StyleTimingKeyword
:
:
EaseIn
)
=
=
2
&
&
static_cast
<
uint8_t
>
(
StyleTimingKeyword
:
:
EaseOut
)
=
=
3
&
&
static_cast
<
uint8_t
>
(
StyleTimingKeyword
:
:
EaseInOut
)
=
=
4
"
transition
timing
function
constants
not
as
expected
"
)
;
static
const
float
timingFunctionValues
[
5
]
[
4
]
=
{
{
0
.
00f
0
.
00f
1
.
00f
1
.
00f
}
{
0
.
25f
0
.
10f
0
.
25f
1
.
00f
}
{
0
.
42f
0
.
00f
1
.
00f
1
.
00f
}
{
0
.
00f
0
.
00f
0
.
58f
1
.
00f
}
{
0
.
42f
0
.
00f
0
.
58f
1
.
00f
}
}
;
const
float
(
&
values
)
[
4
]
=
timingFunctionValues
[
uint8_t
(
aFunction
.
keyword
.
_0
)
]
;
return
AsVariant
(
KeywordFunction
{
aFunction
.
keyword
.
_0
SMILKeySpline
{
values
[
0
]
values
[
1
]
values
[
2
]
values
[
3
]
}
}
)
;
}
case
StyleComputedTimingFunction
:
:
Tag
:
:
CubicBezier
:
return
AsVariant
(
SMILKeySpline
{
aFunction
.
cubic_bezier
.
x1
aFunction
.
cubic_bezier
.
y1
aFunction
.
cubic_bezier
.
x2
aFunction
.
cubic_bezier
.
y2
}
)
;
case
StyleComputedTimingFunction
:
:
Tag
:
:
Steps
:
return
AsVariant
(
StepFunc
{
static_cast
<
uint32_t
>
(
aFunction
.
steps
.
_0
)
aFunction
.
steps
.
_1
}
)
;
case
StyleComputedTimingFunction
:
:
Tag
:
:
LinearFunction
:
{
StylePiecewiseLinearFunction
result
;
Servo_CreatePiecewiseLinearFunction
(
&
aFunction
.
linear_function
.
_0
&
result
)
;
return
AsVariant
(
result
)
;
}
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
timing
function
.
"
)
;
return
ConstructFunction
(
mozilla
:
:
StyleComputedTimingFunction
:
:
Keyword
(
StyleTimingKeyword
:
:
Linear
)
)
;
}
ComputedTimingFunction
:
:
ComputedTimingFunction
(
const
StyleComputedTimingFunction
&
aFunction
)
:
mFunction
{
ConstructFunction
(
aFunction
)
}
{
}
ComputedTimingFunction
:
:
ComputedTimingFunction
(
const
nsTimingFunction
&
aFunction
)
:
ComputedTimingFunction
{
aFunction
.
mTiming
}
{
}
double
ComputedTimingFunction
:
:
StepTiming
(
const
ComputedTimingFunction
:
:
StepFunc
&
aStepFunc
double
aPortion
StyleEasingBeforeFlag
aBeforeFlag
)
{
const
int32_t
currentStep
=
static_cast
<
int32_t
>
(
clamped
(
floor
(
aPortion
*
aStepFunc
.
mSteps
)
(
double
)
std
:
:
numeric_limits
<
int32_t
>
:
:
min
(
)
(
double
)
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
)
;
CheckedInt32
checkedCurrentStep
=
currentStep
;
if
(
aStepFunc
.
mPos
=
=
StyleStepPosition
:
:
Start
|
|
aStepFunc
.
mPos
=
=
StyleStepPosition
:
:
JumpStart
|
|
aStepFunc
.
mPos
=
=
StyleStepPosition
:
:
JumpBoth
)
{
+
+
checkedCurrentStep
;
}
if
(
aBeforeFlag
=
=
StyleEasingBeforeFlag
:
:
Set
&
&
fmod
(
aPortion
*
aStepFunc
.
mSteps
1
)
=
=
0
)
{
-
-
checkedCurrentStep
;
}
if
(
!
checkedCurrentStep
.
isValid
(
)
)
{
checkedCurrentStep
=
currentStep
;
}
if
(
aPortion
>
=
0
.
0
&
&
checkedCurrentStep
.
value
(
)
<
0
)
{
checkedCurrentStep
=
0
;
}
CheckedInt32
jumps
=
aStepFunc
.
mSteps
;
if
(
aStepFunc
.
mPos
=
=
StyleStepPosition
:
:
JumpBoth
)
{
+
+
jumps
;
}
else
if
(
aStepFunc
.
mPos
=
=
StyleStepPosition
:
:
JumpNone
)
{
-
-
jumps
;
}
if
(
!
jumps
.
isValid
(
)
)
{
jumps
=
aStepFunc
.
mSteps
;
}
if
(
aPortion
<
=
1
.
0
&
&
checkedCurrentStep
.
value
(
)
>
jumps
.
value
(
)
)
{
checkedCurrentStep
=
jumps
;
}
MOZ_ASSERT
(
jumps
.
value
(
)
>
0
"
jumps
should
be
a
positive
integer
"
)
;
return
double
(
checkedCurrentStep
.
value
(
)
)
/
double
(
jumps
.
value
(
)
)
;
}
static
inline
double
GetSplineValue
(
double
aPortion
const
SMILKeySpline
&
aSpline
)
{
if
(
aSpline
.
X1
(
)
=
=
aSpline
.
Y1
(
)
&
&
aSpline
.
X2
(
)
=
=
aSpline
.
Y2
(
)
)
{
return
aPortion
;
}
if
(
aPortion
=
=
0
.
0
)
{
return
0
.
0
;
}
if
(
aPortion
=
=
1
.
0
)
{
return
1
.
0
;
}
if
(
aPortion
<
0
.
0
)
{
if
(
aSpline
.
X1
(
)
>
0
.
0
)
{
return
aPortion
*
aSpline
.
Y1
(
)
/
aSpline
.
X1
(
)
;
}
if
(
aSpline
.
Y1
(
)
=
=
0
&
&
aSpline
.
X2
(
)
>
0
.
0
)
{
return
aPortion
*
aSpline
.
Y2
(
)
/
aSpline
.
X2
(
)
;
}
return
0
.
0
;
}
if
(
aPortion
>
1
.
0
)
{
if
(
aSpline
.
X2
(
)
<
1
.
0
)
{
return
1
.
0
+
(
aPortion
-
1
.
0
)
*
(
aSpline
.
Y2
(
)
-
1
)
/
(
aSpline
.
X2
(
)
-
1
)
;
}
if
(
aSpline
.
Y2
(
)
=
=
1
&
&
aSpline
.
X1
(
)
<
1
.
0
)
{
return
1
.
0
+
(
aPortion
-
1
.
0
)
*
(
aSpline
.
Y1
(
)
-
1
)
/
(
aSpline
.
X1
(
)
-
1
)
;
}
return
1
.
0
;
}
return
aSpline
.
GetSplineValue
(
aPortion
)
;
}
double
ComputedTimingFunction
:
:
GetValue
(
double
aPortion
StyleEasingBeforeFlag
aBeforeFlag
)
const
{
return
mFunction
.
match
(
[
aPortion
]
(
const
KeywordFunction
&
aFunction
)
{
return
GetSplineValue
(
aPortion
aFunction
.
mFunction
)
;
}
[
aPortion
]
(
const
SMILKeySpline
&
aFunction
)
{
return
GetSplineValue
(
aPortion
aFunction
)
;
}
[
aPortion
aBeforeFlag
]
(
const
StepFunc
&
aFunction
)
{
return
StepTiming
(
aFunction
aPortion
aBeforeFlag
)
;
}
[
aPortion
]
(
const
StylePiecewiseLinearFunction
&
aFunction
)
{
return
static_cast
<
double
>
(
Servo_PiecewiseLinearFunctionAt
(
&
aFunction
static_cast
<
float
>
(
aPortion
)
)
)
;
}
)
;
}
void
ComputedTimingFunction
:
:
AppendToString
(
nsACString
&
aResult
)
const
{
nsTimingFunction
timing
;
timing
.
mTiming
=
{
ToStyleComputedTimingFunction
(
*
this
)
}
;
Servo_SerializeEasing
(
&
timing
&
aResult
)
;
}
StyleComputedTimingFunction
ComputedTimingFunction
:
:
ToStyleComputedTimingFunction
(
const
ComputedTimingFunction
&
aComputedTimingFunction
)
{
return
aComputedTimingFunction
.
mFunction
.
match
(
[
]
(
const
KeywordFunction
&
aFunction
)
{
return
StyleComputedTimingFunction
:
:
Keyword
(
aFunction
.
mKeyword
)
;
}
[
]
(
const
SMILKeySpline
&
aFunction
)
{
return
StyleComputedTimingFunction
:
:
CubicBezier
(
static_cast
<
float
>
(
aFunction
.
X1
(
)
)
static_cast
<
float
>
(
aFunction
.
Y1
(
)
)
static_cast
<
float
>
(
aFunction
.
X2
(
)
)
static_cast
<
float
>
(
aFunction
.
Y2
(
)
)
)
;
}
[
]
(
const
StepFunc
&
aFunction
)
{
return
StyleComputedTimingFunction
:
:
Steps
(
static_cast
<
int
>
(
aFunction
.
mSteps
)
aFunction
.
mPos
)
;
}
[
]
(
const
StylePiecewiseLinearFunction
&
aFunction
)
{
Vector
<
StyleComputedLinearStop
>
stops
;
bool
reserved
=
stops
.
initCapacity
(
aFunction
.
entries
.
Length
(
)
)
;
MOZ_RELEASE_ASSERT
(
reserved
"
Failed
to
reserve
memory
"
)
;
for
(
const
auto
&
e
:
aFunction
.
entries
.
AsSpan
(
)
)
{
stops
.
infallibleAppend
(
StyleComputedLinearStop
{
e
.
y
StyleOptional
<
StylePercentage
>
:
:
Some
(
StylePercentage
{
e
.
x
}
)
}
)
;
}
return
StyleComputedTimingFunction
:
:
LinearFunction
(
StyleOwnedSlice
<
StyleComputedLinearStop
>
{
std
:
:
move
(
stops
)
}
)
;
}
)
;
}
}
