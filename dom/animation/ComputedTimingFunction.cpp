#
include
"
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
nsAlgorithm
.
h
"
namespace
mozilla
{
ComputedTimingFunction
:
:
Function
ComputedTimingFunction
:
:
ConstructFunction
(
const
nsTimingFunction
&
aFunction
)
{
const
StyleComputedTimingFunction
&
timing
=
aFunction
.
mTiming
;
switch
(
timing
.
tag
)
{
case
StyleComputedTimingFunction
:
:
Tag
:
:
Keyword
:
{
static_assert
(
static_cast
<
uint8_t
>
(
StyleTimingKeyword
:
:
Linear
)
=
=
0
&
&
static_cast
<
uint8_t
>
(
StyleTimingKeyword
:
:
Ease
)
=
=
1
&
&
static_cast
<
uint8_t
>
(
StyleTimingKeyword
:
:
EaseIn
)
=
=
2
&
&
static_cast
<
uint8_t
>
(
StyleTimingKeyword
:
:
EaseOut
)
=
=
3
&
&
static_cast
<
uint8_t
>
(
StyleTimingKeyword
:
:
EaseInOut
)
=
=
4
"
transition
timing
function
constants
not
as
expected
"
)
;
static
const
float
timingFunctionValues
[
5
]
[
4
]
=
{
{
0
.
00f
0
.
00f
1
.
00f
1
.
00f
}
{
0
.
25f
0
.
10f
0
.
25f
1
.
00f
}
{
0
.
42f
0
.
00f
1
.
00f
1
.
00f
}
{
0
.
00f
0
.
00f
0
.
58f
1
.
00f
}
{
0
.
42f
0
.
00f
0
.
58f
1
.
00f
}
}
;
const
float
(
&
values
)
[
4
]
=
timingFunctionValues
[
uint8_t
(
timing
.
keyword
.
_0
)
]
;
return
AsVariant
(
KeywordFunction
{
timing
.
keyword
.
_0
SMILKeySpline
{
values
[
0
]
values
[
1
]
values
[
2
]
values
[
3
]
}
}
)
;
}
case
StyleComputedTimingFunction
:
:
Tag
:
:
CubicBezier
:
return
AsVariant
(
SMILKeySpline
{
timing
.
cubic_bezier
.
x1
timing
.
cubic_bezier
.
y1
timing
.
cubic_bezier
.
x2
timing
.
cubic_bezier
.
y2
}
)
;
case
StyleComputedTimingFunction
:
:
Tag
:
:
Steps
:
return
AsVariant
(
StepFunc
{
static_cast
<
uint32_t
>
(
timing
.
steps
.
_0
)
timing
.
steps
.
_1
}
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
timing
function
.
"
)
;
return
ConstructFunction
(
nsTimingFunction
{
StyleTimingKeyword
:
:
Linear
}
)
;
}
ComputedTimingFunction
:
:
ComputedTimingFunction
(
const
nsTimingFunction
&
aFunction
)
:
mFunction
{
ConstructFunction
(
aFunction
)
}
{
}
static
inline
double
StepTiming
(
const
ComputedTimingFunction
:
:
StepFunc
&
aStepFunc
double
aPortion
ComputedTimingFunction
:
:
BeforeFlag
aBeforeFlag
)
{
const
int32_t
currentStep
=
static_cast
<
int32_t
>
(
clamped
(
floor
(
aPortion
*
aStepFunc
.
mSteps
)
(
double
)
std
:
:
numeric_limits
<
int32_t
>
:
:
min
(
)
(
double
)
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
)
;
CheckedInt32
checkedCurrentStep
=
currentStep
;
if
(
aStepFunc
.
mPos
=
=
StyleStepPosition
:
:
Start
|
|
aStepFunc
.
mPos
=
=
StyleStepPosition
:
:
JumpStart
|
|
aStepFunc
.
mPos
=
=
StyleStepPosition
:
:
JumpBoth
)
{
+
+
checkedCurrentStep
;
}
if
(
aBeforeFlag
=
=
ComputedTimingFunction
:
:
BeforeFlag
:
:
Set
&
&
fmod
(
aPortion
*
aStepFunc
.
mSteps
1
)
=
=
0
)
{
-
-
checkedCurrentStep
;
}
if
(
!
checkedCurrentStep
.
isValid
(
)
)
{
checkedCurrentStep
=
currentStep
;
}
if
(
aPortion
>
=
0
.
0
&
&
checkedCurrentStep
.
value
(
)
<
0
)
{
checkedCurrentStep
=
0
;
}
CheckedInt32
jumps
=
aStepFunc
.
mSteps
;
if
(
aStepFunc
.
mPos
=
=
StyleStepPosition
:
:
JumpBoth
)
{
+
+
jumps
;
}
else
if
(
aStepFunc
.
mPos
=
=
StyleStepPosition
:
:
JumpNone
)
{
-
-
jumps
;
}
if
(
!
jumps
.
isValid
(
)
)
{
jumps
=
aStepFunc
.
mSteps
;
}
if
(
aPortion
<
=
1
.
0
&
&
checkedCurrentStep
.
value
(
)
>
jumps
.
value
(
)
)
{
checkedCurrentStep
=
jumps
;
}
MOZ_ASSERT
(
jumps
.
value
(
)
>
0
"
jumps
should
be
a
positive
integer
"
)
;
return
double
(
checkedCurrentStep
.
value
(
)
)
/
double
(
jumps
.
value
(
)
)
;
}
static
inline
double
GetSplineValue
(
double
aPortion
const
SMILKeySpline
&
aSpline
)
{
if
(
aSpline
.
X1
(
)
=
=
aSpline
.
Y1
(
)
&
&
aSpline
.
X2
(
)
=
=
aSpline
.
Y2
(
)
)
{
return
aPortion
;
}
if
(
aPortion
=
=
0
.
0
)
{
return
0
.
0
;
}
if
(
aPortion
=
=
1
.
0
)
{
return
1
.
0
;
}
if
(
aPortion
<
0
.
0
)
{
if
(
aSpline
.
X1
(
)
>
0
.
0
)
{
return
aPortion
*
aSpline
.
Y1
(
)
/
aSpline
.
X1
(
)
;
}
if
(
aSpline
.
Y1
(
)
=
=
0
&
&
aSpline
.
X2
(
)
>
0
.
0
)
{
return
aPortion
*
aSpline
.
Y2
(
)
/
aSpline
.
X2
(
)
;
}
return
0
.
0
;
}
if
(
aPortion
>
1
.
0
)
{
if
(
aSpline
.
X2
(
)
<
1
.
0
)
{
return
1
.
0
+
(
aPortion
-
1
.
0
)
*
(
aSpline
.
Y2
(
)
-
1
)
/
(
aSpline
.
X2
(
)
-
1
)
;
}
if
(
aSpline
.
Y2
(
)
=
=
1
&
&
aSpline
.
X1
(
)
<
1
.
0
)
{
return
1
.
0
+
(
aPortion
-
1
.
0
)
*
(
aSpline
.
Y1
(
)
-
1
)
/
(
aSpline
.
X1
(
)
-
1
)
;
}
return
1
.
0
;
}
return
aSpline
.
GetSplineValue
(
aPortion
)
;
}
double
ComputedTimingFunction
:
:
GetValue
(
double
aPortion
ComputedTimingFunction
:
:
BeforeFlag
aBeforeFlag
)
const
{
return
mFunction
.
match
(
[
aPortion
]
(
const
KeywordFunction
&
aFunction
)
{
return
GetSplineValue
(
aPortion
aFunction
.
mFunction
)
;
}
[
aPortion
]
(
const
SMILKeySpline
&
aFunction
)
{
return
GetSplineValue
(
aPortion
aFunction
)
;
}
[
aPortion
aBeforeFlag
]
(
const
StepFunc
&
aFunction
)
{
return
StepTiming
(
aFunction
aPortion
aBeforeFlag
)
;
}
)
;
}
void
ComputedTimingFunction
:
:
AppendToString
(
nsACString
&
aResult
)
const
{
nsTimingFunction
timing
;
timing
.
mTiming
=
{
mFunction
.
match
(
[
]
(
const
KeywordFunction
&
aFunction
)
{
return
StyleComputedTimingFunction
:
:
Keyword
(
aFunction
.
mKeyword
)
;
}
[
]
(
const
SMILKeySpline
&
aFunction
)
{
return
StyleComputedTimingFunction
:
:
CubicBezier
(
static_cast
<
float
>
(
aFunction
.
X1
(
)
)
static_cast
<
float
>
(
aFunction
.
Y1
(
)
)
static_cast
<
float
>
(
aFunction
.
X2
(
)
)
static_cast
<
float
>
(
aFunction
.
Y2
(
)
)
)
;
}
[
]
(
const
StepFunc
&
aFunction
)
{
return
StyleComputedTimingFunction
:
:
Steps
(
static_cast
<
int
>
(
aFunction
.
mSteps
)
aFunction
.
mPos
)
;
}
)
}
;
Servo_SerializeEasing
(
&
timing
&
aResult
)
;
}
}
