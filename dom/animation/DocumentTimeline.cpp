#
include
"
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimelineBinding
.
h
"
#
include
"
AnimationUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRefreshDriver
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
DocumentTimeline
AnimationTimeline
mDocument
)
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
DocumentTimeline
AnimationTimeline
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
DocumentTimeline
)
NS_INTERFACE_MAP_END_INHERITING
(
AnimationTimeline
)
NS_IMPL_ADDREF_INHERITED
(
DocumentTimeline
AnimationTimeline
)
NS_IMPL_RELEASE_INHERITED
(
DocumentTimeline
AnimationTimeline
)
JSObject
*
DocumentTimeline
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
DocumentTimelineBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
Nullable
<
TimeDuration
>
DocumentTimeline
:
:
GetCurrentTime
(
)
const
{
return
ToTimelineTime
(
GetCurrentTimeStamp
(
)
)
;
}
TimeStamp
DocumentTimeline
:
:
GetCurrentTimeStamp
(
)
const
{
nsRefreshDriver
*
refreshDriver
=
GetRefreshDriver
(
)
;
TimeStamp
refreshTime
=
refreshDriver
?
refreshDriver
-
>
MostRecentRefresh
(
)
:
TimeStamp
(
)
;
TimeStamp
result
=
!
refreshTime
.
IsNull
(
)
?
refreshTime
:
mLastRefreshDriverTime
;
if
(
result
.
IsNull
(
)
)
{
RefPtr
<
nsDOMNavigationTiming
>
timing
=
mDocument
-
>
GetNavigationTiming
(
)
;
if
(
timing
)
{
result
=
timing
-
>
GetNavigationStartTimeStamp
(
)
;
refreshTime
=
result
;
}
}
if
(
!
refreshTime
.
IsNull
(
)
)
{
mLastRefreshDriverTime
=
refreshTime
;
}
return
result
;
}
Nullable
<
TimeDuration
>
DocumentTimeline
:
:
ToTimelineTime
(
const
TimeStamp
&
aTimeStamp
)
const
{
Nullable
<
TimeDuration
>
result
;
if
(
aTimeStamp
.
IsNull
(
)
)
{
return
result
;
}
RefPtr
<
nsDOMNavigationTiming
>
timing
=
mDocument
-
>
GetNavigationTiming
(
)
;
if
(
MOZ_UNLIKELY
(
!
timing
)
)
{
return
result
;
}
result
.
SetValue
(
aTimeStamp
-
timing
-
>
GetNavigationStartTimeStamp
(
)
-
mOriginTime
)
;
return
result
;
}
void
DocumentTimeline
:
:
NotifyAnimationUpdated
(
Animation
&
aAnimation
)
{
AnimationTimeline
:
:
NotifyAnimationUpdated
(
aAnimation
)
;
if
(
!
mIsObservingRefreshDriver
)
{
nsRefreshDriver
*
refreshDriver
=
GetRefreshDriver
(
)
;
if
(
refreshDriver
)
{
refreshDriver
-
>
AddRefreshObserver
(
this
Flush_Style
)
;
mIsObservingRefreshDriver
=
true
;
}
}
}
void
DocumentTimeline
:
:
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
{
MOZ_ASSERT
(
mIsObservingRefreshDriver
)
;
MOZ_ASSERT
(
GetRefreshDriver
(
)
"
Should
be
able
to
reach
refresh
driver
from
within
WillRefresh
"
)
;
bool
needsTicks
=
false
;
nsTArray
<
Animation
*
>
animationsToRemove
(
mAnimations
.
Count
(
)
)
;
nsAutoAnimationMutationBatch
mb
(
mDocument
)
;
for
(
Animation
*
animation
=
mAnimationOrder
.
getFirst
(
)
;
animation
;
animation
=
animation
-
>
getNext
(
)
)
{
if
(
animation
-
>
GetTimeline
(
)
!
=
this
)
{
MOZ_ASSERT
(
!
animation
-
>
GetTimeline
(
)
)
;
animationsToRemove
.
AppendElement
(
animation
)
;
continue
;
}
needsTicks
|
=
animation
-
>
NeedsTicks
(
)
;
animation
-
>
Tick
(
)
;
if
(
!
animation
-
>
IsRelevant
(
)
&
&
!
animation
-
>
NeedsTicks
(
)
)
{
animationsToRemove
.
AppendElement
(
animation
)
;
}
}
for
(
Animation
*
animation
:
animationsToRemove
)
{
RemoveAnimation
(
animation
)
;
}
if
(
!
needsTicks
)
{
MOZ_ASSERT
(
GetRefreshDriver
(
)
"
Refresh
driver
should
still
be
valid
at
end
of
WillRefresh
"
)
;
GetRefreshDriver
(
)
-
>
RemoveRefreshObserver
(
this
Flush_Style
)
;
mIsObservingRefreshDriver
=
false
;
}
}
void
DocumentTimeline
:
:
NotifyRefreshDriverCreated
(
nsRefreshDriver
*
aDriver
)
{
MOZ_ASSERT
(
!
mIsObservingRefreshDriver
"
Timeline
should
not
be
observing
the
refresh
driver
before
"
"
it
is
created
"
)
;
if
(
!
mAnimationOrder
.
isEmpty
(
)
)
{
aDriver
-
>
AddRefreshObserver
(
this
Flush_Style
)
;
mIsObservingRefreshDriver
=
true
;
}
}
void
DocumentTimeline
:
:
NotifyRefreshDriverDestroying
(
nsRefreshDriver
*
aDriver
)
{
if
(
!
mIsObservingRefreshDriver
)
{
return
;
}
aDriver
-
>
RemoveRefreshObserver
(
this
Flush_Style
)
;
mIsObservingRefreshDriver
=
false
;
}
void
DocumentTimeline
:
:
RemoveAnimation
(
Animation
*
aAnimation
)
{
AnimationTimeline
:
:
RemoveAnimation
(
aAnimation
)
;
if
(
mIsObservingRefreshDriver
&
&
mAnimations
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
GetRefreshDriver
(
)
"
Refresh
driver
should
still
be
valid
when
"
"
mIsObservingRefreshDriver
is
true
"
)
;
GetRefreshDriver
(
)
-
>
RemoveRefreshObserver
(
this
Flush_Style
)
;
mIsObservingRefreshDriver
=
false
;
}
}
TimeStamp
DocumentTimeline
:
:
ToTimeStamp
(
const
TimeDuration
&
aTimeDuration
)
const
{
TimeStamp
result
;
RefPtr
<
nsDOMNavigationTiming
>
timing
=
mDocument
-
>
GetNavigationTiming
(
)
;
if
(
MOZ_UNLIKELY
(
!
timing
)
)
{
return
result
;
}
result
=
timing
-
>
GetNavigationStartTimeStamp
(
)
+
aTimeDuration
+
mOriginTime
;
return
result
;
}
nsRefreshDriver
*
DocumentTimeline
:
:
GetRefreshDriver
(
)
const
{
nsIPresShell
*
presShell
=
mDocument
-
>
GetShell
(
)
;
if
(
MOZ_UNLIKELY
(
!
presShell
)
)
{
return
nullptr
;
}
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
if
(
MOZ_UNLIKELY
(
!
presContext
)
)
{
return
nullptr
;
}
return
presContext
-
>
RefreshDriver
(
)
;
}
}
}
