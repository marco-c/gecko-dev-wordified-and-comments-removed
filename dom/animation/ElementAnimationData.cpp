#
include
"
ElementAnimationData
.
h
"
#
include
"
mozilla
/
AnimationCollection
.
h
"
#
include
"
mozilla
/
TimelineCollection
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
dom
/
CSSTransition
.
h
"
#
include
"
mozilla
/
dom
/
CSSAnimation
.
h
"
#
include
"
mozilla
/
dom
/
ScrollTimeline
.
h
"
#
include
"
mozilla
/
dom
/
ViewTimeline
.
h
"
namespace
mozilla
{
void
ElementAnimationData
:
:
Traverse
(
nsCycleCollectionTraversalCallback
&
cb
)
{
mElementData
.
Traverse
(
cb
)
;
mBeforeData
.
Traverse
(
cb
)
;
mAfterData
.
Traverse
(
cb
)
;
mMarkerData
.
Traverse
(
cb
)
;
}
void
ElementAnimationData
:
:
ClearAllAnimationCollections
(
)
{
for
(
auto
*
data
:
{
&
mElementData
&
mBeforeData
&
mAfterData
&
mMarkerData
}
)
{
data
-
>
mAnimations
=
nullptr
;
data
-
>
mTransitions
=
nullptr
;
data
-
>
mScrollTimelines
=
nullptr
;
data
-
>
mViewTimelines
=
nullptr
;
data
-
>
mProgressTimelineScheduler
=
nullptr
;
}
}
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
PerElementOrPseudoData
(
)
=
default
;
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
~
PerElementOrPseudoData
(
)
=
default
;
void
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
Traverse
(
nsCycleCollectionTraversalCallback
&
cb
)
{
if
(
mEffectSet
)
{
mEffectSet
-
>
Traverse
(
cb
)
;
}
}
EffectSet
&
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
DoEnsureEffectSet
(
)
{
MOZ_ASSERT
(
!
mEffectSet
)
;
mEffectSet
=
MakeUnique
<
EffectSet
>
(
)
;
return
*
mEffectSet
;
}
CSSTransitionCollection
&
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
DoEnsureTransitions
(
dom
:
:
Element
&
aOwner
const
PseudoStyleRequest
&
aRequest
)
{
MOZ_ASSERT
(
!
mTransitions
)
;
mTransitions
=
MakeUnique
<
CSSTransitionCollection
>
(
aOwner
aRequest
)
;
return
*
mTransitions
;
}
CSSAnimationCollection
&
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
DoEnsureAnimations
(
dom
:
:
Element
&
aOwner
const
PseudoStyleRequest
&
aRequest
)
{
MOZ_ASSERT
(
!
mAnimations
)
;
mAnimations
=
MakeUnique
<
CSSAnimationCollection
>
(
aOwner
aRequest
)
;
return
*
mAnimations
;
}
ScrollTimelineCollection
&
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
DoEnsureScrollTimelines
(
dom
:
:
Element
&
aOwner
const
PseudoStyleRequest
&
aRequest
)
{
MOZ_ASSERT
(
!
mScrollTimelines
)
;
mScrollTimelines
=
MakeUnique
<
ScrollTimelineCollection
>
(
aOwner
aRequest
)
;
return
*
mScrollTimelines
;
}
ViewTimelineCollection
&
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
DoEnsureViewTimelines
(
dom
:
:
Element
&
aOwner
const
PseudoStyleRequest
&
aRequest
)
{
MOZ_ASSERT
(
!
mViewTimelines
)
;
mViewTimelines
=
MakeUnique
<
ViewTimelineCollection
>
(
aOwner
aRequest
)
;
return
*
mViewTimelines
;
}
dom
:
:
ProgressTimelineScheduler
&
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
DoEnsureProgressTimelineScheduler
(
)
{
MOZ_ASSERT
(
!
mProgressTimelineScheduler
)
;
mProgressTimelineScheduler
=
MakeUnique
<
dom
:
:
ProgressTimelineScheduler
>
(
)
;
return
*
mProgressTimelineScheduler
;
}
void
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
DoClearEffectSet
(
)
{
MOZ_ASSERT
(
mEffectSet
)
;
mEffectSet
=
nullptr
;
}
void
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
DoClearTransitions
(
)
{
MOZ_ASSERT
(
mTransitions
)
;
mTransitions
=
nullptr
;
}
void
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
DoClearAnimations
(
)
{
MOZ_ASSERT
(
mAnimations
)
;
mAnimations
=
nullptr
;
}
void
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
DoClearScrollTimelines
(
)
{
MOZ_ASSERT
(
mScrollTimelines
)
;
mScrollTimelines
=
nullptr
;
}
void
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
DoClearViewTimelines
(
)
{
MOZ_ASSERT
(
mViewTimelines
)
;
mViewTimelines
=
nullptr
;
}
void
ElementAnimationData
:
:
PerElementOrPseudoData
:
:
DoClearProgressTimelineScheduler
(
)
{
MOZ_ASSERT
(
mProgressTimelineScheduler
)
;
mProgressTimelineScheduler
=
nullptr
;
}
}
