#
include
"
mozilla
/
TimingParams
.
h
"
#
include
"
mozilla
/
AnimationUtils
.
h
"
#
include
"
mozilla
/
ServoCSSParser
.
h
"
#
include
"
mozilla
/
dom
/
AnimatableBinding
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeAnimationOptionsBinding
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectBinding
.
h
"
namespace
mozilla
{
template
<
class
OptionsType
>
static
const
dom
:
:
EffectTiming
&
GetTimingProperties
(
const
OptionsType
&
aOptions
)
;
template
<
>
const
dom
:
:
EffectTiming
&
GetTimingProperties
(
const
dom
:
:
UnrestrictedDoubleOrKeyframeEffectOptions
&
aOptions
)
{
MOZ_ASSERT
(
aOptions
.
IsKeyframeEffectOptions
(
)
)
;
return
aOptions
.
GetAsKeyframeEffectOptions
(
)
;
}
template
<
>
const
dom
:
:
EffectTiming
&
GetTimingProperties
(
const
dom
:
:
UnrestrictedDoubleOrKeyframeAnimationOptions
&
aOptions
)
{
MOZ_ASSERT
(
aOptions
.
IsKeyframeAnimationOptions
(
)
)
;
return
aOptions
.
GetAsKeyframeAnimationOptions
(
)
;
}
template
<
class
OptionsType
>
TimingParams
TimingParams
:
:
FromOptionsType
(
const
OptionsType
&
aOptions
ErrorResult
&
aRv
)
{
TimingParams
result
;
if
(
aOptions
.
IsUnrestrictedDouble
(
)
)
{
double
durationInMs
=
aOptions
.
GetAsUnrestrictedDouble
(
)
;
if
(
durationInMs
>
=
0
)
{
result
.
mDuration
.
emplace
(
StickyTimeDuration
:
:
FromMilliseconds
(
durationInMs
)
)
;
}
else
{
nsPrintfCString
error
(
"
Duration
value
%
g
is
less
than
0
"
durationInMs
)
;
aRv
.
ThrowTypeError
(
error
)
;
return
result
;
}
result
.
Update
(
)
;
}
else
{
const
dom
:
:
EffectTiming
&
timing
=
GetTimingProperties
(
aOptions
)
;
result
=
FromEffectTiming
(
timing
aRv
)
;
}
return
result
;
}
TimingParams
TimingParams
:
:
FromOptionsUnion
(
const
dom
:
:
UnrestrictedDoubleOrKeyframeEffectOptions
&
aOptions
ErrorResult
&
aRv
)
{
return
FromOptionsType
(
aOptions
aRv
)
;
}
TimingParams
TimingParams
:
:
FromOptionsUnion
(
const
dom
:
:
UnrestrictedDoubleOrKeyframeAnimationOptions
&
aOptions
ErrorResult
&
aRv
)
{
return
FromOptionsType
(
aOptions
aRv
)
;
}
TimingParams
TimingParams
:
:
FromEffectTiming
(
const
dom
:
:
EffectTiming
&
aEffectTiming
ErrorResult
&
aRv
)
{
TimingParams
result
;
Maybe
<
StickyTimeDuration
>
duration
=
TimingParams
:
:
ParseDuration
(
aEffectTiming
.
mDuration
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
result
;
}
TimingParams
:
:
ValidateIterationStart
(
aEffectTiming
.
mIterationStart
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
result
;
}
TimingParams
:
:
ValidateIterations
(
aEffectTiming
.
mIterations
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
result
;
}
Maybe
<
StyleComputedTimingFunction
>
easing
=
ParseEasing
(
aEffectTiming
.
mEasing
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
result
;
}
result
.
mDuration
=
duration
;
result
.
mDelay
=
TimeDuration
:
:
FromMilliseconds
(
aEffectTiming
.
mDelay
)
;
result
.
mEndDelay
=
TimeDuration
:
:
FromMilliseconds
(
aEffectTiming
.
mEndDelay
)
;
result
.
mIterations
=
aEffectTiming
.
mIterations
;
result
.
mIterationStart
=
aEffectTiming
.
mIterationStart
;
result
.
mDirection
=
aEffectTiming
.
mDirection
;
result
.
mFill
=
aEffectTiming
.
mFill
;
result
.
mFunction
=
std
:
:
move
(
easing
)
;
result
.
Update
(
)
;
return
result
;
}
TimingParams
TimingParams
:
:
MergeOptionalEffectTiming
(
const
TimingParams
&
aSource
const
dom
:
:
OptionalEffectTiming
&
aEffectTiming
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
"
Initially
return
value
should
be
ok
"
)
;
TimingParams
result
=
aSource
;
Maybe
<
StickyTimeDuration
>
duration
;
if
(
aEffectTiming
.
mDuration
.
WasPassed
(
)
)
{
duration
=
TimingParams
:
:
ParseDuration
(
aEffectTiming
.
mDuration
.
Value
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
result
;
}
}
if
(
aEffectTiming
.
mIterationStart
.
WasPassed
(
)
)
{
TimingParams
:
:
ValidateIterationStart
(
aEffectTiming
.
mIterationStart
.
Value
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
result
;
}
}
if
(
aEffectTiming
.
mIterations
.
WasPassed
(
)
)
{
TimingParams
:
:
ValidateIterations
(
aEffectTiming
.
mIterations
.
Value
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
result
;
}
}
Maybe
<
StyleComputedTimingFunction
>
easing
;
if
(
aEffectTiming
.
mEasing
.
WasPassed
(
)
)
{
easing
=
ParseEasing
(
aEffectTiming
.
mEasing
.
Value
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
result
;
}
}
if
(
aEffectTiming
.
mDuration
.
WasPassed
(
)
)
{
result
.
mDuration
=
duration
;
}
if
(
aEffectTiming
.
mDelay
.
WasPassed
(
)
)
{
result
.
mDelay
=
TimeDuration
:
:
FromMilliseconds
(
aEffectTiming
.
mDelay
.
Value
(
)
)
;
}
if
(
aEffectTiming
.
mEndDelay
.
WasPassed
(
)
)
{
result
.
mEndDelay
=
TimeDuration
:
:
FromMilliseconds
(
aEffectTiming
.
mEndDelay
.
Value
(
)
)
;
}
if
(
aEffectTiming
.
mIterations
.
WasPassed
(
)
)
{
result
.
mIterations
=
aEffectTiming
.
mIterations
.
Value
(
)
;
}
if
(
aEffectTiming
.
mIterationStart
.
WasPassed
(
)
)
{
result
.
mIterationStart
=
aEffectTiming
.
mIterationStart
.
Value
(
)
;
}
if
(
aEffectTiming
.
mDirection
.
WasPassed
(
)
)
{
result
.
mDirection
=
aEffectTiming
.
mDirection
.
Value
(
)
;
}
if
(
aEffectTiming
.
mFill
.
WasPassed
(
)
)
{
result
.
mFill
=
aEffectTiming
.
mFill
.
Value
(
)
;
}
if
(
aEffectTiming
.
mEasing
.
WasPassed
(
)
)
{
result
.
mFunction
=
easing
;
}
result
.
Update
(
)
;
return
result
;
}
Maybe
<
StyleComputedTimingFunction
>
TimingParams
:
:
ParseEasing
(
const
nsACString
&
aEasing
ErrorResult
&
aRv
)
{
auto
timingFunction
=
StyleComputedTimingFunction
:
:
LinearKeyword
(
)
;
if
(
!
ServoCSSParser
:
:
ParseEasing
(
aEasing
timingFunction
)
)
{
aRv
.
ThrowTypeError
<
dom
:
:
MSG_INVALID_EASING_ERROR
>
(
aEasing
)
;
return
Nothing
(
)
;
}
if
(
timingFunction
.
IsLinearKeyword
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
std
:
:
move
(
timingFunction
)
)
;
}
bool
TimingParams
:
:
operator
=
=
(
const
TimingParams
&
aOther
)
const
{
return
mDuration
=
=
aOther
.
mDuration
&
&
mDelay
=
=
aOther
.
mDelay
&
&
mEndDelay
=
=
aOther
.
mEndDelay
&
&
mIterations
=
=
aOther
.
mIterations
&
&
mIterationStart
=
=
aOther
.
mIterationStart
&
&
mDirection
=
=
aOther
.
mDirection
&
&
mFill
=
=
aOther
.
mFill
&
&
mFunction
=
=
aOther
.
mFunction
;
}
TimingParams
TimingParams
:
:
Normalize
(
const
TimeDuration
&
aTimelineDuration
)
const
{
MOZ_ASSERT
(
aTimelineDuration
"
the
timeline
duration
of
scroll
-
timeline
is
always
non
-
zero
now
"
)
;
TimingParams
normalizedTiming
(
*
this
)
;
if
(
!
mDuration
)
{
normalizedTiming
.
mDelay
=
TimeDuration
(
)
;
normalizedTiming
.
mEndDelay
=
TimeDuration
(
)
;
normalizedTiming
.
mDuration
.
emplace
(
aTimelineDuration
)
;
normalizedTiming
.
Update
(
)
;
return
normalizedTiming
;
}
if
(
mEndTime
.
IsZero
(
)
)
{
normalizedTiming
.
mDelay
=
TimeDuration
(
)
;
normalizedTiming
.
mEndDelay
=
TimeDuration
(
)
;
normalizedTiming
.
mDuration
=
Some
(
TimeDuration
(
)
)
;
}
else
if
(
mEndTime
=
=
TimeDuration
:
:
Forever
(
)
)
{
normalizedTiming
.
mDelay
=
TimeDuration
(
)
;
normalizedTiming
.
mEndDelay
=
TimeDuration
(
)
;
normalizedTiming
.
mDuration
=
Some
(
aTimelineDuration
.
MultDouble
(
1
.
0
/
mIterations
)
)
;
}
else
{
const
double
endTimeInSec
=
mEndTime
.
ToSeconds
(
)
;
normalizedTiming
.
mDelay
=
aTimelineDuration
.
MultDouble
(
mDelay
.
ToSeconds
(
)
/
endTimeInSec
)
;
normalizedTiming
.
mEndDelay
=
aTimelineDuration
.
MultDouble
(
mEndDelay
.
ToSeconds
(
)
/
endTimeInSec
)
;
normalizedTiming
.
mDuration
=
Some
(
StickyTimeDuration
(
aTimelineDuration
.
MultDouble
(
mDuration
-
>
ToSeconds
(
)
/
endTimeInSec
)
)
)
;
}
normalizedTiming
.
Update
(
)
;
return
normalizedTiming
;
}
}
