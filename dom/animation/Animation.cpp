#
include
"
Animation
.
h
"
#
include
"
AnimationUtils
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
mozilla
/
dom
/
AnimationBinding
.
h
"
#
include
"
mozilla
/
dom
/
AnimationPlaybackEvent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
MutationObservers
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
AnimationEventDispatcher
.
h
"
#
include
"
mozilla
/
AnimationTarget
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
DeclarationBlock
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsDOMCSSAttrDeclaration
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
PendingAnimationTracker
.
h
"
namespace
mozilla
:
:
dom
{
uint64_t
Animation
:
:
sNextAnimationIndex
=
0
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
Animation
DOMEventTargetHelper
mTimeline
mEffect
mReady
mFinished
)
NS_IMPL_ADDREF_INHERITED
(
Animation
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
Animation
DOMEventTargetHelper
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Animation
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
JSObject
*
Animation
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
Animation_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
namespace
{
class
MOZ_RAII
AutoMutationBatchForAnimation
{
public
:
explicit
AutoMutationBatchForAnimation
(
const
Animation
&
aAnimation
)
{
NonOwningAnimationTarget
target
=
aAnimation
.
GetTargetForAnimation
(
)
;
if
(
!
target
)
{
return
;
}
mAutoBatch
.
emplace
(
target
.
mElement
-
>
OwnerDoc
(
)
)
;
}
private
:
Maybe
<
nsAutoAnimationMutationBatch
>
mAutoBatch
;
}
;
}
Animation
:
:
Animation
(
nsIGlobalObject
*
aGlobal
)
:
DOMEventTargetHelper
(
aGlobal
)
mAnimationIndex
(
sNextAnimationIndex
+
+
)
{
}
Animation
:
:
~
Animation
(
)
=
default
;
already_AddRefed
<
Animation
>
Animation
:
:
ClonePausedAnimation
(
nsIGlobalObject
*
aGlobal
const
Animation
&
aOther
AnimationEffect
&
aEffect
AnimationTimeline
&
aTimeline
)
{
RefPtr
<
Animation
>
animation
=
new
Animation
(
aGlobal
)
;
animation
-
>
mTimeline
=
&
aTimeline
;
const
Nullable
<
TimeDuration
>
timelineTime
=
aTimeline
.
GetCurrentTimeAsDuration
(
)
;
MOZ_ASSERT
(
!
timelineTime
.
IsNull
(
)
"
Timeline
not
yet
set
"
)
;
const
Nullable
<
TimeDuration
>
currentTime
=
aOther
.
GetCurrentTimeAsDuration
(
)
;
animation
-
>
mHoldTime
=
currentTime
;
if
(
!
currentTime
.
IsNull
(
)
)
{
animation
-
>
mPreviousCurrentTime
=
timelineTime
;
}
animation
-
>
mPlaybackRate
=
aOther
.
mPlaybackRate
;
animation
-
>
mEffect
=
&
aEffect
;
animation
-
>
mEffect
-
>
SetAnimation
(
animation
)
;
animation
-
>
mPendingState
=
PendingState
:
:
PausePending
;
Document
*
doc
=
animation
-
>
GetRenderedDocument
(
)
;
MOZ_ASSERT
(
doc
"
Cloning
animation
should
already
have
the
rendered
document
"
)
;
PendingAnimationTracker
*
tracker
=
doc
-
>
GetOrCreatePendingAnimationTracker
(
)
;
tracker
-
>
AddPausePending
(
*
animation
)
;
animation
-
>
mIsRelevant
=
aOther
.
mIsRelevant
;
animation
-
>
PostUpdate
(
)
;
animation
-
>
mTimeline
-
>
NotifyAnimationUpdated
(
*
animation
)
;
return
animation
.
forget
(
)
;
}
NonOwningAnimationTarget
Animation
:
:
GetTargetForAnimation
(
)
const
{
AnimationEffect
*
effect
=
GetEffect
(
)
;
NonOwningAnimationTarget
target
;
if
(
!
effect
|
|
!
effect
-
>
AsKeyframeEffect
(
)
)
{
return
target
;
}
return
effect
-
>
AsKeyframeEffect
(
)
-
>
GetAnimationTarget
(
)
;
}
already_AddRefed
<
Animation
>
Animation
:
:
Constructor
(
const
GlobalObject
&
aGlobal
AnimationEffect
*
aEffect
const
Optional
<
AnimationTimeline
*
>
&
aTimeline
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
RefPtr
<
Animation
>
animation
=
new
Animation
(
global
)
;
AnimationTimeline
*
timeline
;
if
(
aTimeline
.
WasPassed
(
)
)
{
timeline
=
aTimeline
.
Value
(
)
;
}
else
{
Document
*
document
=
AnimationUtils
:
:
GetCurrentRealmDocument
(
aGlobal
.
Context
(
)
)
;
if
(
!
document
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
timeline
=
document
-
>
Timeline
(
)
;
}
animation
-
>
SetTimelineNoUpdate
(
timeline
)
;
animation
-
>
SetEffectNoUpdate
(
aEffect
)
;
return
animation
.
forget
(
)
;
}
void
Animation
:
:
SetId
(
const
nsAString
&
aId
)
{
if
(
mId
=
=
aId
)
{
return
;
}
mId
=
aId
;
MutationObservers
:
:
NotifyAnimationChanged
(
this
)
;
}
void
Animation
:
:
SetEffect
(
AnimationEffect
*
aEffect
)
{
SetEffectNoUpdate
(
aEffect
)
;
PostUpdate
(
)
;
}
void
Animation
:
:
SetEffectNoUpdate
(
AnimationEffect
*
aEffect
)
{
RefPtr
<
Animation
>
kungFuDeathGrip
(
this
)
;
if
(
mEffect
=
=
aEffect
)
{
return
;
}
AutoMutationBatchForAnimation
mb
(
*
this
)
;
bool
wasRelevant
=
mIsRelevant
;
if
(
mEffect
)
{
if
(
mIsRelevant
)
{
MutationObservers
:
:
NotifyAnimationRemoved
(
this
)
;
}
RefPtr
<
AnimationEffect
>
oldEffect
=
mEffect
;
mEffect
=
nullptr
;
if
(
IsPartialPrerendered
(
)
)
{
if
(
KeyframeEffect
*
oldKeyframeEffect
=
oldEffect
-
>
AsKeyframeEffect
(
)
)
{
oldKeyframeEffect
-
>
ResetPartialPrerendered
(
)
;
}
}
oldEffect
-
>
SetAnimation
(
nullptr
)
;
UpdateRelevance
(
)
;
}
if
(
aEffect
)
{
RefPtr
<
AnimationEffect
>
newEffect
=
aEffect
;
Animation
*
prevAnim
=
aEffect
-
>
GetAnimation
(
)
;
if
(
prevAnim
)
{
prevAnim
-
>
SetEffect
(
nullptr
)
;
}
mEffect
=
newEffect
;
mEffect
-
>
SetAnimation
(
this
)
;
if
(
wasRelevant
&
&
mIsRelevant
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
this
)
;
}
ReschedulePendingTasks
(
)
;
}
MaybeScheduleReplacementCheck
(
)
;
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
}
void
Animation
:
:
SetTimeline
(
AnimationTimeline
*
aTimeline
)
{
SetTimelineNoUpdate
(
aTimeline
)
;
PostUpdate
(
)
;
}
void
Animation
:
:
SetTimelineNoUpdate
(
AnimationTimeline
*
aTimeline
)
{
if
(
mTimeline
=
=
aTimeline
)
{
return
;
}
StickyTimeDuration
activeTime
=
mEffect
?
mEffect
-
>
GetComputedTiming
(
)
.
mActiveTime
:
StickyTimeDuration
(
)
;
RefPtr
<
AnimationTimeline
>
oldTimeline
=
mTimeline
;
if
(
oldTimeline
)
{
oldTimeline
-
>
RemoveAnimation
(
this
)
;
}
mTimeline
=
aTimeline
;
if
(
mEffect
)
{
mEffect
-
>
UpdateNormalizedTiming
(
)
;
}
if
(
!
mStartTime
.
IsNull
(
)
)
{
mHoldTime
.
SetNull
(
)
;
}
if
(
!
aTimeline
)
{
MaybeQueueCancelEvent
(
activeTime
)
;
}
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
}
void
Animation
:
:
SetStartTime
(
const
Nullable
<
TimeDuration
>
&
aNewStartTime
)
{
if
(
!
Pending
(
)
&
&
aNewStartTime
=
=
mStartTime
)
{
return
;
}
AutoMutationBatchForAnimation
mb
(
*
this
)
;
Nullable
<
TimeDuration
>
timelineTime
;
if
(
mTimeline
)
{
timelineTime
=
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
;
}
if
(
timelineTime
.
IsNull
(
)
&
&
!
aNewStartTime
.
IsNull
(
)
)
{
mHoldTime
.
SetNull
(
)
;
}
Nullable
<
TimeDuration
>
previousCurrentTime
=
GetCurrentTimeAsDuration
(
)
;
ApplyPendingPlaybackRate
(
)
;
mStartTime
=
aNewStartTime
;
if
(
!
aNewStartTime
.
IsNull
(
)
)
{
if
(
mPlaybackRate
!
=
0
.
0
)
{
mHoldTime
.
SetNull
(
)
;
}
}
else
{
mHoldTime
=
previousCurrentTime
;
}
CancelPendingTasks
(
)
;
if
(
mReady
)
{
mReady
-
>
MaybeResolve
(
this
)
;
}
UpdateTiming
(
SeekFlag
:
:
DidSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
this
)
;
}
PostUpdate
(
)
;
}
Nullable
<
TimeDuration
>
Animation
:
:
GetCurrentTimeForHoldTime
(
const
Nullable
<
TimeDuration
>
&
aHoldTime
)
const
{
Nullable
<
TimeDuration
>
result
;
if
(
!
aHoldTime
.
IsNull
(
)
)
{
result
=
aHoldTime
;
return
result
;
}
if
(
mTimeline
&
&
!
mStartTime
.
IsNull
(
)
)
{
Nullable
<
TimeDuration
>
timelineTime
=
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
;
if
(
!
timelineTime
.
IsNull
(
)
)
{
result
=
CurrentTimeFromTimelineTime
(
timelineTime
.
Value
(
)
mStartTime
.
Value
(
)
mPlaybackRate
)
;
}
}
return
result
;
}
void
Animation
:
:
SetCurrentTime
(
const
TimeDuration
&
aSeekTime
)
{
if
(
mPendingState
!
=
PendingState
:
:
PausePending
&
&
Nullable
<
TimeDuration
>
(
aSeekTime
)
=
=
GetCurrentTimeAsDuration
(
)
)
{
return
;
}
AutoMutationBatchForAnimation
mb
(
*
this
)
;
SilentlySetCurrentTime
(
aSeekTime
)
;
if
(
mPendingState
=
=
PendingState
:
:
PausePending
)
{
mHoldTime
.
SetValue
(
aSeekTime
)
;
ApplyPendingPlaybackRate
(
)
;
mStartTime
.
SetNull
(
)
;
if
(
mReady
)
{
mReady
-
>
MaybeResolve
(
this
)
;
}
CancelPendingTasks
(
)
;
}
UpdateTiming
(
SeekFlag
:
:
DidSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
this
)
;
}
PostUpdate
(
)
;
}
void
Animation
:
:
SetPlaybackRate
(
double
aPlaybackRate
)
{
mPendingPlaybackRate
.
reset
(
)
;
if
(
aPlaybackRate
=
=
mPlaybackRate
)
{
return
;
}
AutoMutationBatchForAnimation
mb
(
*
this
)
;
Nullable
<
TimeDuration
>
previousTime
=
GetCurrentTimeAsDuration
(
)
;
mPlaybackRate
=
aPlaybackRate
;
if
(
!
previousTime
.
IsNull
(
)
)
{
SetCurrentTime
(
previousTime
.
Value
(
)
)
;
}
UpdateTiming
(
SeekFlag
:
:
DidSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
this
)
;
}
PostUpdate
(
)
;
}
void
Animation
:
:
UpdatePlaybackRate
(
double
aPlaybackRate
)
{
if
(
mPendingPlaybackRate
&
&
mPendingPlaybackRate
.
value
(
)
=
=
aPlaybackRate
)
{
return
;
}
AnimationPlayState
playState
=
PlayState
(
)
;
mPendingPlaybackRate
=
Some
(
aPlaybackRate
)
;
if
(
Pending
(
)
)
{
UpdateEffect
(
PostRestyleMode
:
:
Never
)
;
return
;
}
AutoMutationBatchForAnimation
mb
(
*
this
)
;
if
(
playState
=
=
AnimationPlayState
:
:
Idle
|
|
playState
=
=
AnimationPlayState
:
:
Paused
|
|
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
)
{
ApplyPendingPlaybackRate
(
)
;
UpdateEffect
(
PostRestyleMode
:
:
Never
)
;
if
(
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
this
)
;
}
}
else
if
(
playState
=
=
AnimationPlayState
:
:
Finished
)
{
MOZ_ASSERT
(
mTimeline
&
&
!
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
"
If
we
have
no
active
timeline
we
should
be
idle
or
paused
"
)
;
if
(
aPlaybackRate
!
=
0
)
{
MOZ_ASSERT
(
!
GetUnconstrainedCurrentTime
(
)
.
IsNull
(
)
"
Unconstrained
current
time
should
be
resolved
"
)
;
TimeDuration
unconstrainedCurrentTime
=
GetUnconstrainedCurrentTime
(
)
.
Value
(
)
;
TimeDuration
timelineTime
=
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
Value
(
)
;
mStartTime
=
StartTimeFromTimelineTime
(
timelineTime
unconstrainedCurrentTime
aPlaybackRate
)
;
}
else
{
mStartTime
=
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
;
}
ApplyPendingPlaybackRate
(
)
;
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
this
)
;
}
PostUpdate
(
)
;
}
else
{
ErrorResult
rv
;
Play
(
rv
LimitBehavior
:
:
Continue
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
"
We
should
only
fail
to
play
when
using
auto
-
rewind
behavior
"
)
;
}
}
AnimationPlayState
Animation
:
:
PlayState
(
)
const
{
Nullable
<
TimeDuration
>
currentTime
=
GetCurrentTimeAsDuration
(
)
;
if
(
currentTime
.
IsNull
(
)
&
&
mStartTime
.
IsNull
(
)
&
&
!
Pending
(
)
)
{
return
AnimationPlayState
:
:
Idle
;
}
if
(
mPendingState
=
=
PendingState
:
:
PausePending
|
|
(
mStartTime
.
IsNull
(
)
&
&
!
Pending
(
)
)
)
{
return
AnimationPlayState
:
:
Paused
;
}
double
playbackRate
=
CurrentOrPendingPlaybackRate
(
)
;
if
(
!
currentTime
.
IsNull
(
)
&
&
(
(
playbackRate
>
0
.
0
&
&
currentTime
.
Value
(
)
>
=
EffectEnd
(
)
)
|
|
(
playbackRate
<
0
.
0
&
&
currentTime
.
Value
(
)
<
=
TimeDuration
(
)
)
)
)
{
return
AnimationPlayState
:
:
Finished
;
}
return
AnimationPlayState
:
:
Running
;
}
Promise
*
Animation
:
:
GetReady
(
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
GetOwnerGlobal
(
)
;
if
(
!
mReady
&
&
global
)
{
mReady
=
Promise
:
:
Create
(
global
aRv
)
;
}
if
(
!
mReady
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
!
Pending
(
)
)
{
mReady
-
>
MaybeResolve
(
this
)
;
}
return
mReady
;
}
Promise
*
Animation
:
:
GetFinished
(
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
GetOwnerGlobal
(
)
;
if
(
!
mFinished
&
&
global
)
{
mFinished
=
Promise
:
:
Create
(
global
aRv
)
;
}
if
(
!
mFinished
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
mFinishedIsResolved
)
{
MaybeResolveFinishedPromise
(
)
;
}
return
mFinished
;
}
void
Animation
:
:
Cancel
(
PostRestyleMode
aPostRestyle
)
{
bool
newlyIdle
=
false
;
if
(
PlayState
(
)
!
=
AnimationPlayState
:
:
Idle
)
{
newlyIdle
=
true
;
ResetPendingTasks
(
)
;
if
(
mFinished
)
{
mFinished
-
>
MaybeReject
(
NS_ERROR_DOM_ABORT_ERR
)
;
MOZ_ALWAYS_TRUE
(
mFinished
-
>
SetAnyPromiseIsHandled
(
)
)
;
}
ResetFinishedPromise
(
)
;
QueuePlaybackEvent
(
u
"
cancel
"
_ns
GetTimelineCurrentTimeAsTimeStamp
(
)
)
;
}
StickyTimeDuration
activeTime
=
mEffect
?
mEffect
-
>
GetComputedTiming
(
)
.
mActiveTime
:
StickyTimeDuration
(
)
;
mHoldTime
.
SetNull
(
)
;
mStartTime
.
SetNull
(
)
;
UpdateEffect
(
aPostRestyle
)
;
if
(
mTimeline
)
{
mTimeline
-
>
RemoveAnimation
(
this
)
;
}
MaybeQueueCancelEvent
(
activeTime
)
;
if
(
newlyIdle
&
&
aPostRestyle
=
=
PostRestyleMode
:
:
IfNeeded
)
{
PostUpdate
(
)
;
}
}
void
Animation
:
:
Finish
(
ErrorResult
&
aRv
)
{
double
effectivePlaybackRate
=
CurrentOrPendingPlaybackRate
(
)
;
if
(
effectivePlaybackRate
=
=
0
)
{
return
aRv
.
ThrowInvalidStateError
(
"
Can
'
t
finish
animation
with
zero
playback
rate
"
)
;
}
if
(
effectivePlaybackRate
>
0
&
&
EffectEnd
(
)
=
=
TimeDuration
:
:
Forever
(
)
)
{
return
aRv
.
ThrowInvalidStateError
(
"
Can
'
t
finish
infinite
animation
"
)
;
}
AutoMutationBatchForAnimation
mb
(
*
this
)
;
ApplyPendingPlaybackRate
(
)
;
TimeDuration
limit
=
mPlaybackRate
>
0
?
TimeDuration
(
EffectEnd
(
)
)
:
TimeDuration
(
0
)
;
bool
didChange
=
GetCurrentTimeAsDuration
(
)
!
=
Nullable
<
TimeDuration
>
(
limit
)
;
SilentlySetCurrentTime
(
limit
)
;
if
(
mStartTime
.
IsNull
(
)
&
&
mTimeline
&
&
!
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
)
{
mStartTime
=
StartTimeFromTimelineTime
(
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
Value
(
)
limit
mPlaybackRate
)
;
didChange
=
true
;
}
if
(
!
mStartTime
.
IsNull
(
)
&
&
(
mPendingState
=
=
PendingState
:
:
PlayPending
|
|
mPendingState
=
=
PendingState
:
:
PausePending
)
)
{
if
(
mPendingState
=
=
PendingState
:
:
PausePending
)
{
mHoldTime
.
SetNull
(
)
;
}
CancelPendingTasks
(
)
;
didChange
=
true
;
if
(
mReady
)
{
mReady
-
>
MaybeResolve
(
this
)
;
}
}
UpdateTiming
(
SeekFlag
:
:
DidSeek
SyncNotifyFlag
:
:
Sync
)
;
if
(
didChange
&
&
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
this
)
;
}
PostUpdate
(
)
;
}
void
Animation
:
:
Play
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
{
PlayNoUpdate
(
aRv
aLimitBehavior
)
;
PostUpdate
(
)
;
}
void
Animation
:
:
Reverse
(
ErrorResult
&
aRv
)
{
if
(
!
mTimeline
)
{
return
aRv
.
ThrowInvalidStateError
(
"
Can
'
t
reverse
an
animation
with
no
associated
timeline
"
)
;
}
if
(
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
)
{
return
aRv
.
ThrowInvalidStateError
(
"
Can
'
t
reverse
an
animation
associated
with
an
inactive
timeline
"
)
;
}
double
effectivePlaybackRate
=
CurrentOrPendingPlaybackRate
(
)
;
if
(
effectivePlaybackRate
=
=
0
.
0
)
{
return
;
}
Maybe
<
double
>
originalPendingPlaybackRate
=
mPendingPlaybackRate
;
mPendingPlaybackRate
=
Some
(
-
effectivePlaybackRate
)
;
Play
(
aRv
LimitBehavior
:
:
AutoRewind
)
;
if
(
aRv
.
Failed
(
)
)
{
mPendingPlaybackRate
=
originalPendingPlaybackRate
;
}
}
void
Animation
:
:
Persist
(
)
{
if
(
mReplaceState
=
=
AnimationReplaceState
:
:
Persisted
)
{
return
;
}
bool
wasRemoved
=
mReplaceState
=
=
AnimationReplaceState
:
:
Removed
;
mReplaceState
=
AnimationReplaceState
:
:
Persisted
;
if
(
wasRemoved
)
{
UpdateEffect
(
PostRestyleMode
:
:
IfNeeded
)
;
PostUpdate
(
)
;
}
}
void
Animation
:
:
CommitStyles
(
ErrorResult
&
aRv
)
{
if
(
!
mEffect
)
{
return
;
}
RefPtr
<
KeyframeEffect
>
keyframeEffect
=
mEffect
-
>
AsKeyframeEffect
(
)
;
if
(
!
keyframeEffect
)
{
return
;
}
NonOwningAnimationTarget
target
=
keyframeEffect
-
>
GetAnimationTarget
(
)
;
if
(
!
target
)
{
return
;
}
if
(
target
.
mPseudoType
!
=
PseudoStyleType
:
:
NotPseudo
)
{
return
aRv
.
ThrowNoModificationAllowedError
(
"
Can
'
t
commit
styles
of
a
pseudo
-
element
"
)
;
}
RefPtr
<
nsStyledElement
>
styledElement
=
nsStyledElement
:
:
FromNodeOrNull
(
target
.
mElement
)
;
if
(
!
styledElement
)
{
return
aRv
.
ThrowNoModificationAllowedError
(
"
Target
is
not
capable
of
having
a
style
attribute
"
)
;
}
RefPtr
<
Document
>
doc
=
target
.
mElement
-
>
GetComposedDoc
(
)
;
if
(
doc
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
if
(
!
target
.
mElement
-
>
IsRendered
(
)
)
{
return
aRv
.
ThrowInvalidStateError
(
"
Target
is
not
rendered
"
)
;
}
nsPresContext
*
presContext
=
nsContentUtils
:
:
GetContextForContent
(
target
.
mElement
)
;
if
(
!
presContext
)
{
return
aRv
.
ThrowInvalidStateError
(
"
Target
is
not
rendered
"
)
;
}
UniquePtr
<
RawServoAnimationValueMap
>
animationValues
=
Servo_AnimationValueMap_Create
(
)
.
Consume
(
)
;
if
(
!
presContext
-
>
EffectCompositor
(
)
-
>
ComposeServoAnimationRuleForEffect
(
*
keyframeEffect
CascadeLevel
(
)
animationValues
.
get
(
)
)
)
{
NS_WARNING
(
"
Failed
to
compose
animation
style
to
commit
"
)
;
return
;
}
mozAutoDocUpdate
autoUpdate
(
target
.
mElement
-
>
OwnerDoc
(
)
true
)
;
RefPtr
<
DeclarationBlock
>
declarationBlock
;
if
(
auto
*
existing
=
target
.
mElement
-
>
GetInlineStyleDeclaration
(
)
)
{
declarationBlock
=
existing
-
>
EnsureMutable
(
)
;
}
else
{
declarationBlock
=
new
DeclarationBlock
(
)
;
declarationBlock
-
>
SetDirty
(
)
;
}
MutationClosureData
closureData
;
closureData
.
mShouldBeCalled
=
true
;
closureData
.
mElement
=
target
.
mElement
;
DeclarationBlockMutationClosure
beforeChangeClosure
=
{
nsDOMCSSAttributeDeclaration
:
:
MutationClosureFunction
&
closureData
}
;
bool
changed
=
false
;
nsCSSPropertyIDSet
properties
=
keyframeEffect
-
>
GetPropertySet
(
)
;
for
(
nsCSSPropertyID
property
:
properties
)
{
RefPtr
<
RawServoAnimationValue
>
computedValue
=
Servo_AnimationValueMap_GetValue
(
animationValues
.
get
(
)
property
)
.
Consume
(
)
;
if
(
computedValue
)
{
changed
|
=
Servo_DeclarationBlock_SetPropertyToAnimationValue
(
declarationBlock
-
>
Raw
(
)
computedValue
beforeChangeClosure
)
;
}
}
if
(
!
changed
)
{
MOZ_ASSERT
(
!
closureData
.
mWasCalled
)
;
return
;
}
MOZ_ASSERT
(
closureData
.
mWasCalled
)
;
target
.
mElement
-
>
SetInlineStyleDeclaration
(
*
declarationBlock
closureData
)
;
}
Nullable
<
double
>
Animation
:
:
GetStartTimeAsDouble
(
)
const
{
return
AnimationUtils
:
:
TimeDurationToDouble
(
mStartTime
)
;
}
void
Animation
:
:
SetStartTimeAsDouble
(
const
Nullable
<
double
>
&
aStartTime
)
{
return
SetStartTime
(
AnimationUtils
:
:
DoubleToTimeDuration
(
aStartTime
)
)
;
}
Nullable
<
double
>
Animation
:
:
GetCurrentTimeAsDouble
(
)
const
{
return
AnimationUtils
:
:
TimeDurationToDouble
(
GetCurrentTimeAsDuration
(
)
)
;
}
void
Animation
:
:
SetCurrentTimeAsDouble
(
const
Nullable
<
double
>
&
aCurrentTime
ErrorResult
&
aRv
)
{
if
(
aCurrentTime
.
IsNull
(
)
)
{
if
(
!
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
)
{
aRv
.
ThrowTypeError
(
"
Current
time
is
resolved
but
trying
to
set
it
to
an
unresolved
"
"
time
"
)
;
}
return
;
}
return
SetCurrentTime
(
TimeDuration
:
:
FromMilliseconds
(
aCurrentTime
.
Value
(
)
)
)
;
}
void
Animation
:
:
Tick
(
)
{
if
(
mPendingState
!
=
PendingState
:
:
NotPending
&
&
!
mPendingReadyTime
.
IsNull
(
)
&
&
mTimeline
&
&
!
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
)
{
TimeDuration
currentTime
=
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
Value
(
)
;
if
(
currentTime
<
mPendingReadyTime
.
Value
(
)
)
{
mPendingReadyTime
.
SetValue
(
currentTime
)
;
}
FinishPendingAt
(
mPendingReadyTime
.
Value
(
)
)
;
mPendingReadyTime
.
SetNull
(
)
;
}
if
(
IsPossiblyOrphanedPendingAnimation
(
)
)
{
MOZ_ASSERT
(
mTimeline
&
&
!
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
"
Orphaned
pending
animations
should
have
an
active
timeline
"
)
;
FinishPendingAt
(
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
Value
(
)
)
;
}
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Sync
)
;
bool
isReplaceable
=
IsReplaceable
(
)
;
if
(
isReplaceable
&
&
!
mWasReplaceableAtLastTick
)
{
ScheduleReplacementCheck
(
)
;
}
mWasReplaceableAtLastTick
=
isReplaceable
;
if
(
!
mEffect
)
{
return
;
}
KeyframeEffect
*
keyframeEffect
=
mEffect
-
>
AsKeyframeEffect
(
)
;
if
(
keyframeEffect
&
&
!
keyframeEffect
-
>
Properties
(
)
.
IsEmpty
(
)
&
&
!
mFinishedAtLastComposeStyle
&
&
PlayState
(
)
=
=
AnimationPlayState
:
:
Finished
)
{
PostUpdate
(
)
;
}
}
void
Animation
:
:
TriggerOnNextTick
(
const
Nullable
<
TimeDuration
>
&
aReadyTime
)
{
if
(
!
Pending
(
)
)
{
return
;
}
mPendingReadyTime
=
aReadyTime
;
}
void
Animation
:
:
TriggerNow
(
)
{
if
(
!
Pending
(
)
)
{
return
;
}
if
(
!
mTimeline
|
|
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
)
{
NS_WARNING
(
"
Failed
to
trigger
an
animation
with
an
active
timeline
"
)
;
return
;
}
FinishPendingAt
(
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
Value
(
)
)
;
}
Nullable
<
TimeDuration
>
Animation
:
:
GetCurrentOrPendingStartTime
(
)
const
{
Nullable
<
TimeDuration
>
result
;
if
(
mPendingPlaybackRate
&
&
!
mPendingReadyTime
.
IsNull
(
)
&
&
!
mStartTime
.
IsNull
(
)
)
{
TimeDuration
currentTimeToMatch
=
!
mHoldTime
.
IsNull
(
)
?
mHoldTime
.
Value
(
)
:
CurrentTimeFromTimelineTime
(
mPendingReadyTime
.
Value
(
)
mStartTime
.
Value
(
)
mPlaybackRate
)
;
result
=
StartTimeFromTimelineTime
(
mPendingReadyTime
.
Value
(
)
currentTimeToMatch
*
mPendingPlaybackRate
)
;
return
result
;
}
if
(
!
mStartTime
.
IsNull
(
)
)
{
result
=
mStartTime
;
return
result
;
}
if
(
mPendingReadyTime
.
IsNull
(
)
|
|
mHoldTime
.
IsNull
(
)
)
{
return
result
;
}
result
=
StartTimeFromTimelineTime
(
mPendingReadyTime
.
Value
(
)
mHoldTime
.
Value
(
)
mPlaybackRate
)
;
return
result
;
}
TimeStamp
Animation
:
:
AnimationTimeToTimeStamp
(
const
StickyTimeDuration
&
aTime
)
const
{
TimeStamp
result
;
if
(
!
mTimeline
)
{
return
result
;
}
if
(
aTime
=
=
TimeDuration
:
:
Forever
(
)
|
|
mPlaybackRate
=
=
0
.
0
|
|
mStartTime
.
IsNull
(
)
)
{
return
result
;
}
TimeDuration
timelineTime
=
TimeDuration
(
aTime
)
.
MultDouble
(
1
.
0
/
mPlaybackRate
)
+
mStartTime
.
Value
(
)
;
result
=
mTimeline
-
>
ToTimeStamp
(
timelineTime
)
;
return
result
;
}
TimeStamp
Animation
:
:
ElapsedTimeToTimeStamp
(
const
StickyTimeDuration
&
aElapsedTime
)
const
{
TimeDuration
delay
=
mEffect
?
mEffect
-
>
NormalizedTiming
(
)
.
Delay
(
)
:
TimeDuration
(
)
;
return
AnimationTimeToTimeStamp
(
aElapsedTime
+
delay
)
;
}
void
Animation
:
:
SilentlySetCurrentTime
(
const
TimeDuration
&
aSeekTime
)
{
if
(
!
mHoldTime
.
IsNull
(
)
|
|
mStartTime
.
IsNull
(
)
|
|
!
mTimeline
|
|
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
|
|
mPlaybackRate
=
=
0
.
0
)
{
mHoldTime
.
SetValue
(
aSeekTime
)
;
if
(
!
mTimeline
|
|
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
)
{
mStartTime
.
SetNull
(
)
;
}
}
else
{
mStartTime
=
StartTimeFromTimelineTime
(
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
Value
(
)
aSeekTime
mPlaybackRate
)
;
}
mPreviousCurrentTime
.
SetNull
(
)
;
}
bool
Animation
:
:
ShouldBeSynchronizedWithMainThread
(
const
nsCSSPropertyIDSet
&
aPropertySet
const
nsIFrame
*
aFrame
AnimationPerformanceWarning
:
:
Type
&
aPerformanceWarning
)
const
{
if
(
!
IsPlaying
(
)
)
{
return
false
;
}
if
(
!
aPropertySet
.
Intersects
(
nsCSSPropertyIDSet
:
:
TransformLikeProperties
(
)
)
)
{
return
false
;
}
KeyframeEffect
*
keyframeEffect
=
mEffect
?
mEffect
-
>
AsKeyframeEffect
(
)
:
nullptr
;
if
(
!
keyframeEffect
)
{
return
false
;
}
if
(
StaticPrefs
:
:
dom_animations_mainthread_synchronization_with_geometric_animations
(
)
&
&
mSyncWithGeometricAnimations
&
&
keyframeEffect
-
>
HasAnimationOfPropertySet
(
nsCSSPropertyIDSet
:
:
TransformLikeProperties
(
)
)
)
{
aPerformanceWarning
=
AnimationPerformanceWarning
:
:
Type
:
:
TransformWithSyncGeometricAnimations
;
return
true
;
}
return
keyframeEffect
-
>
ShouldBlockAsyncTransformAnimations
(
aFrame
aPropertySet
aPerformanceWarning
)
;
}
void
Animation
:
:
UpdateRelevance
(
)
{
bool
wasRelevant
=
mIsRelevant
;
mIsRelevant
=
mReplaceState
!
=
AnimationReplaceState
:
:
Removed
&
&
(
HasCurrentEffect
(
)
|
|
IsInEffect
(
)
)
;
if
(
wasRelevant
&
&
!
mIsRelevant
)
{
MutationObservers
:
:
NotifyAnimationRemoved
(
this
)
;
}
else
if
(
!
wasRelevant
&
&
mIsRelevant
)
{
MutationObservers
:
:
NotifyAnimationAdded
(
this
)
;
}
}
template
<
class
T
>
bool
IsMarkupAnimation
(
T
*
aAnimation
)
{
return
aAnimation
&
&
aAnimation
-
>
IsTiedToMarkup
(
)
;
}
bool
Animation
:
:
IsReplaceable
(
)
const
{
if
(
IsMarkupAnimation
(
AsCSSAnimation
(
)
)
|
|
IsMarkupAnimation
(
AsCSSTransition
(
)
)
)
{
return
false
;
}
if
(
PlayState
(
)
!
=
AnimationPlayState
:
:
Finished
)
{
return
false
;
}
if
(
ReplaceState
(
)
=
=
AnimationReplaceState
:
:
Removed
)
{
return
false
;
}
if
(
!
GetTimeline
(
)
|
|
!
GetTimeline
(
)
-
>
TracksWallclockTime
(
)
)
{
return
false
;
}
if
(
!
GetEffect
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
"
Effect
should
be
a
keyframe
effect
"
)
;
if
(
GetEffect
(
)
-
>
GetComputedTiming
(
)
.
mProgress
.
IsNull
(
)
)
{
return
false
;
}
if
(
!
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
-
>
GetAnimationTarget
(
)
)
{
return
false
;
}
return
true
;
}
bool
Animation
:
:
IsRemovable
(
)
const
{
return
ReplaceState
(
)
=
=
AnimationReplaceState
:
:
Active
&
&
IsReplaceable
(
)
;
}
void
Animation
:
:
ScheduleReplacementCheck
(
)
{
MOZ_ASSERT
(
IsReplaceable
(
)
"
Should
only
schedule
a
replacement
check
for
a
replaceable
animation
"
)
;
MOZ_ASSERT
(
GetEffect
(
)
)
;
MOZ_ASSERT
(
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
)
;
NonOwningAnimationTarget
target
=
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
-
>
GetAnimationTarget
(
)
;
MOZ_ASSERT
(
target
)
;
nsPresContext
*
presContext
=
nsContentUtils
:
:
GetContextForContent
(
target
.
mElement
)
;
if
(
presContext
)
{
presContext
-
>
EffectCompositor
(
)
-
>
NoteElementForReducing
(
target
)
;
}
}
void
Animation
:
:
MaybeScheduleReplacementCheck
(
)
{
if
(
!
IsReplaceable
(
)
)
{
return
;
}
ScheduleReplacementCheck
(
)
;
}
void
Animation
:
:
Remove
(
)
{
MOZ_ASSERT
(
IsRemovable
(
)
"
Should
not
be
trying
to
remove
an
effect
that
is
not
removable
"
)
;
mReplaceState
=
AnimationReplaceState
:
:
Removed
;
UpdateEffect
(
PostRestyleMode
:
:
IfNeeded
)
;
PostUpdate
(
)
;
QueuePlaybackEvent
(
u
"
remove
"
_ns
GetTimelineCurrentTimeAsTimeStamp
(
)
)
;
}
bool
Animation
:
:
HasLowerCompositeOrderThan
(
const
Animation
&
aOther
)
const
{
if
(
&
aOther
=
=
this
)
{
return
false
;
}
{
auto
asCSSTransitionForSorting
=
[
]
(
const
Animation
&
anim
)
-
>
const
CSSTransition
*
{
const
CSSTransition
*
transition
=
anim
.
AsCSSTransition
(
)
;
return
transition
&
&
transition
-
>
IsTiedToMarkup
(
)
?
transition
:
nullptr
;
}
;
auto
thisTransition
=
asCSSTransitionForSorting
(
*
this
)
;
auto
otherTransition
=
asCSSTransitionForSorting
(
aOther
)
;
if
(
thisTransition
&
&
otherTransition
)
{
return
thisTransition
-
>
HasLowerCompositeOrderThan
(
*
otherTransition
)
;
}
if
(
thisTransition
|
|
otherTransition
)
{
return
thisTransition
;
}
}
{
auto
asCSSAnimationForSorting
=
[
]
(
const
Animation
&
anim
)
-
>
const
CSSAnimation
*
{
const
CSSAnimation
*
animation
=
anim
.
AsCSSAnimation
(
)
;
return
animation
&
&
animation
-
>
IsTiedToMarkup
(
)
?
animation
:
nullptr
;
}
;
auto
thisAnimation
=
asCSSAnimationForSorting
(
*
this
)
;
auto
otherAnimation
=
asCSSAnimationForSorting
(
aOther
)
;
if
(
thisAnimation
&
&
otherAnimation
)
{
return
thisAnimation
-
>
HasLowerCompositeOrderThan
(
*
otherAnimation
)
;
}
if
(
thisAnimation
|
|
otherAnimation
)
{
return
thisAnimation
;
}
}
MOZ_ASSERT
(
mAnimationIndex
!
=
aOther
.
mAnimationIndex
"
Animation
indices
should
be
unique
"
)
;
return
mAnimationIndex
<
aOther
.
mAnimationIndex
;
}
void
Animation
:
:
WillComposeStyle
(
)
{
mFinishedAtLastComposeStyle
=
(
PlayState
(
)
=
=
AnimationPlayState
:
:
Finished
)
;
MOZ_ASSERT
(
mEffect
)
;
KeyframeEffect
*
keyframeEffect
=
mEffect
-
>
AsKeyframeEffect
(
)
;
if
(
keyframeEffect
)
{
keyframeEffect
-
>
WillComposeStyle
(
)
;
}
}
void
Animation
:
:
ComposeStyle
(
RawServoAnimationValueMap
&
aComposeResult
const
nsCSSPropertyIDSet
&
aPropertiesToSkip
)
{
if
(
!
mEffect
)
{
return
;
}
bool
pending
=
Pending
(
)
;
{
AutoRestore
<
Nullable
<
TimeDuration
>
>
restoreHoldTime
(
mHoldTime
)
;
if
(
pending
&
&
mHoldTime
.
IsNull
(
)
&
&
!
mStartTime
.
IsNull
(
)
)
{
Nullable
<
TimeDuration
>
timeToUse
=
mPendingReadyTime
;
if
(
timeToUse
.
IsNull
(
)
&
&
mTimeline
&
&
mTimeline
-
>
TracksWallclockTime
(
)
)
{
timeToUse
=
mTimeline
-
>
ToTimelineTime
(
TimeStamp
:
:
Now
(
)
)
;
}
if
(
!
timeToUse
.
IsNull
(
)
)
{
mHoldTime
=
CurrentTimeFromTimelineTime
(
timeToUse
.
Value
(
)
mStartTime
.
Value
(
)
mPlaybackRate
)
;
}
}
KeyframeEffect
*
keyframeEffect
=
mEffect
-
>
AsKeyframeEffect
(
)
;
if
(
keyframeEffect
)
{
keyframeEffect
-
>
ComposeStyle
(
aComposeResult
aPropertiesToSkip
)
;
}
}
MOZ_ASSERT
(
pending
=
=
Pending
(
)
"
Pending
state
should
not
change
during
the
course
of
compositing
"
)
;
}
void
Animation
:
:
NotifyEffectTimingUpdated
(
)
{
MOZ_ASSERT
(
mEffect
"
We
should
only
update
effect
timing
when
we
have
a
target
"
"
effect
"
)
;
UpdateTiming
(
Animation
:
:
SeekFlag
:
:
NoSeek
Animation
:
:
SyncNotifyFlag
:
:
Async
)
;
}
void
Animation
:
:
NotifyEffectPropertiesUpdated
(
)
{
MOZ_ASSERT
(
mEffect
"
We
should
only
update
effect
properties
when
we
have
a
target
"
"
effect
"
)
;
MaybeScheduleReplacementCheck
(
)
;
}
void
Animation
:
:
NotifyEffectTargetUpdated
(
)
{
MOZ_ASSERT
(
mEffect
"
We
should
only
update
the
effect
target
when
we
have
a
target
"
"
effect
"
)
;
MaybeScheduleReplacementCheck
(
)
;
}
void
Animation
:
:
NotifyGeometricAnimationsStartingThisFrame
(
)
{
if
(
!
IsNewlyStarted
(
)
|
|
!
mEffect
)
{
return
;
}
mSyncWithGeometricAnimations
=
true
;
}
void
Animation
:
:
PlayNoUpdate
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
{
AutoMutationBatchForAnimation
mb
(
*
this
)
;
const
bool
isAutoRewind
=
aLimitBehavior
=
=
LimitBehavior
:
:
AutoRewind
;
const
bool
abortedPause
=
mPendingState
=
=
PendingState
:
:
PausePending
;
double
effectivePlaybackRate
=
CurrentOrPendingPlaybackRate
(
)
;
Nullable
<
TimeDuration
>
currentTime
=
GetCurrentTimeAsDuration
(
)
;
Nullable
<
TimeDuration
>
seekTime
;
if
(
isAutoRewind
)
{
if
(
effectivePlaybackRate
>
=
0
.
0
&
&
(
currentTime
.
IsNull
(
)
|
|
currentTime
.
Value
(
)
<
TimeDuration
(
)
|
|
currentTime
.
Value
(
)
>
=
EffectEnd
(
)
)
)
{
seekTime
.
SetValue
(
TimeDuration
(
)
)
;
}
else
if
(
effectivePlaybackRate
<
0
.
0
&
&
(
currentTime
.
IsNull
(
)
|
|
currentTime
.
Value
(
)
<
=
TimeDuration
(
)
|
|
currentTime
.
Value
(
)
>
EffectEnd
(
)
)
)
{
if
(
EffectEnd
(
)
=
=
TimeDuration
:
:
Forever
(
)
)
{
return
aRv
.
ThrowInvalidStateError
(
"
Can
'
t
rewind
animation
with
infinite
effect
end
"
)
;
}
seekTime
.
SetValue
(
TimeDuration
(
EffectEnd
(
)
)
)
;
}
}
if
(
seekTime
.
IsNull
(
)
&
&
mStartTime
.
IsNull
(
)
&
&
currentTime
.
IsNull
(
)
)
{
seekTime
.
SetValue
(
TimeDuration
(
)
)
;
}
if
(
!
seekTime
.
IsNull
(
)
)
{
if
(
HasFiniteTimeline
(
)
)
{
mStartTime
=
seekTime
;
mHoldTime
.
SetNull
(
)
;
ApplyPendingPlaybackRate
(
)
;
}
else
{
mHoldTime
=
seekTime
;
}
}
bool
reuseReadyPromise
=
false
;
if
(
mPendingState
!
=
PendingState
:
:
NotPending
)
{
CancelPendingTasks
(
)
;
reuseReadyPromise
=
true
;
}
if
(
mHoldTime
.
IsNull
(
)
&
&
seekTime
.
IsNull
(
)
&
&
!
abortedPause
&
&
!
mPendingPlaybackRate
)
{
return
;
}
if
(
!
mHoldTime
.
IsNull
(
)
)
{
mStartTime
.
SetNull
(
)
;
}
if
(
!
reuseReadyPromise
)
{
mReady
=
nullptr
;
}
mPendingState
=
PendingState
:
:
PlayPending
;
mSyncWithGeometricAnimations
=
false
;
if
(
HasFiniteTimeline
(
)
)
{
TriggerNow
(
)
;
}
else
{
if
(
Document
*
doc
=
GetRenderedDocument
(
)
)
{
PendingAnimationTracker
*
tracker
=
doc
-
>
GetOrCreatePendingAnimationTracker
(
)
;
tracker
-
>
AddPlayPending
(
*
this
)
;
}
else
{
TriggerOnNextTick
(
Nullable
<
TimeDuration
>
(
)
)
;
}
}
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
this
)
;
}
}
void
Animation
:
:
Pause
(
ErrorResult
&
aRv
)
{
if
(
IsPausedOrPausing
(
)
)
{
return
;
}
AutoMutationBatchForAnimation
mb
(
*
this
)
;
Nullable
<
TimeDuration
>
seekTime
;
if
(
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
)
{
if
(
mPlaybackRate
>
=
0
.
0
)
{
seekTime
.
SetValue
(
TimeDuration
(
0
)
)
;
}
else
{
if
(
EffectEnd
(
)
=
=
TimeDuration
:
:
Forever
(
)
)
{
return
aRv
.
ThrowInvalidStateError
(
"
Can
'
t
seek
to
infinite
effect
end
"
)
;
}
seekTime
.
SetValue
(
TimeDuration
(
EffectEnd
(
)
)
)
;
}
}
if
(
!
seekTime
.
IsNull
(
)
)
{
if
(
HasFiniteTimeline
(
)
)
{
mStartTime
=
seekTime
;
}
else
{
mHoldTime
=
seekTime
;
}
}
bool
reuseReadyPromise
=
false
;
if
(
mPendingState
=
=
PendingState
:
:
PlayPending
)
{
CancelPendingTasks
(
)
;
reuseReadyPromise
=
true
;
}
if
(
!
reuseReadyPromise
)
{
mReady
=
nullptr
;
}
mPendingState
=
PendingState
:
:
PausePending
;
if
(
HasFiniteTimeline
(
)
)
{
TriggerNow
(
)
;
}
else
{
if
(
Document
*
doc
=
GetRenderedDocument
(
)
)
{
PendingAnimationTracker
*
tracker
=
doc
-
>
GetOrCreatePendingAnimationTracker
(
)
;
tracker
-
>
AddPausePending
(
*
this
)
;
}
else
{
TriggerOnNextTick
(
Nullable
<
TimeDuration
>
(
)
)
;
}
}
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
this
)
;
}
PostUpdate
(
)
;
}
void
Animation
:
:
ResumeAt
(
const
TimeDuration
&
aReadyTime
)
{
MOZ_ASSERT
(
mPendingState
=
=
PendingState
:
:
PlayPending
"
Expected
to
resume
a
play
-
pending
animation
"
)
;
MOZ_ASSERT
(
!
mHoldTime
.
IsNull
(
)
|
|
!
mStartTime
.
IsNull
(
)
"
An
animation
in
the
play
-
pending
state
should
have
either
a
"
"
resolved
hold
time
or
resolved
start
time
"
)
;
AutoMutationBatchForAnimation
mb
(
*
this
)
;
bool
hadPendingPlaybackRate
=
mPendingPlaybackRate
.
isSome
(
)
;
if
(
!
mHoldTime
.
IsNull
(
)
)
{
ApplyPendingPlaybackRate
(
)
;
mStartTime
=
StartTimeFromTimelineTime
(
aReadyTime
mHoldTime
.
Value
(
)
mPlaybackRate
)
;
if
(
mPlaybackRate
!
=
0
)
{
mHoldTime
.
SetNull
(
)
;
}
}
else
if
(
!
mStartTime
.
IsNull
(
)
&
&
mPendingPlaybackRate
)
{
TimeDuration
currentTimeToMatch
=
CurrentTimeFromTimelineTime
(
aReadyTime
mStartTime
.
Value
(
)
mPlaybackRate
)
;
ApplyPendingPlaybackRate
(
)
;
mStartTime
=
StartTimeFromTimelineTime
(
aReadyTime
currentTimeToMatch
mPlaybackRate
)
;
if
(
mPlaybackRate
=
=
0
)
{
mHoldTime
.
SetValue
(
currentTimeToMatch
)
;
}
}
mPendingState
=
PendingState
:
:
NotPending
;
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Sync
)
;
if
(
hadPendingPlaybackRate
&
&
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
this
)
;
}
if
(
mReady
)
{
mReady
-
>
MaybeResolve
(
this
)
;
}
}
void
Animation
:
:
PauseAt
(
const
TimeDuration
&
aReadyTime
)
{
MOZ_ASSERT
(
mPendingState
=
=
PendingState
:
:
PausePending
"
Expected
to
pause
a
pause
-
pending
animation
"
)
;
if
(
!
mStartTime
.
IsNull
(
)
&
&
mHoldTime
.
IsNull
(
)
)
{
mHoldTime
=
CurrentTimeFromTimelineTime
(
aReadyTime
mStartTime
.
Value
(
)
mPlaybackRate
)
;
}
ApplyPendingPlaybackRate
(
)
;
mStartTime
.
SetNull
(
)
;
mPendingState
=
PendingState
:
:
NotPending
;
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
mReady
)
{
mReady
-
>
MaybeResolve
(
this
)
;
}
}
void
Animation
:
:
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
{
UpdateFinishedState
(
aSeekFlag
aSyncNotifyFlag
)
;
UpdateEffect
(
PostRestyleMode
:
:
IfNeeded
)
;
if
(
mTimeline
)
{
mTimeline
-
>
NotifyAnimationUpdated
(
*
this
)
;
}
}
void
Animation
:
:
UpdateFinishedState
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
{
Nullable
<
TimeDuration
>
unconstrainedCurrentTime
=
aSeekFlag
=
=
SeekFlag
:
:
NoSeek
?
GetUnconstrainedCurrentTime
(
)
:
GetCurrentTimeAsDuration
(
)
;
TimeDuration
effectEnd
=
TimeDuration
(
EffectEnd
(
)
)
;
if
(
!
unconstrainedCurrentTime
.
IsNull
(
)
&
&
!
mStartTime
.
IsNull
(
)
&
&
mPendingState
=
=
PendingState
:
:
NotPending
)
{
if
(
mPlaybackRate
>
0
.
0
&
&
unconstrainedCurrentTime
.
Value
(
)
>
=
effectEnd
)
{
if
(
aSeekFlag
=
=
SeekFlag
:
:
DidSeek
)
{
mHoldTime
=
unconstrainedCurrentTime
;
}
else
if
(
!
mPreviousCurrentTime
.
IsNull
(
)
)
{
mHoldTime
.
SetValue
(
std
:
:
max
(
mPreviousCurrentTime
.
Value
(
)
effectEnd
)
)
;
}
else
{
mHoldTime
.
SetValue
(
effectEnd
)
;
}
}
else
if
(
mPlaybackRate
<
0
.
0
&
&
unconstrainedCurrentTime
.
Value
(
)
<
=
TimeDuration
(
)
)
{
if
(
aSeekFlag
=
=
SeekFlag
:
:
DidSeek
)
{
mHoldTime
=
unconstrainedCurrentTime
;
}
else
if
(
!
mPreviousCurrentTime
.
IsNull
(
)
)
{
mHoldTime
.
SetValue
(
std
:
:
min
(
mPreviousCurrentTime
.
Value
(
)
TimeDuration
(
0
)
)
)
;
}
else
{
mHoldTime
.
SetValue
(
0
)
;
}
}
else
if
(
mPlaybackRate
!
=
0
.
0
&
&
mTimeline
&
&
!
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
)
{
if
(
aSeekFlag
=
=
SeekFlag
:
:
DidSeek
&
&
!
mHoldTime
.
IsNull
(
)
)
{
mStartTime
=
StartTimeFromTimelineTime
(
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
Value
(
)
mHoldTime
.
Value
(
)
mPlaybackRate
)
;
}
mHoldTime
.
SetNull
(
)
;
}
}
mPreviousCurrentTime
=
GetCurrentTimeAsDuration
(
)
;
bool
currentFinishedState
=
PlayState
(
)
=
=
AnimationPlayState
:
:
Finished
;
if
(
currentFinishedState
&
&
!
mFinishedIsResolved
)
{
DoFinishNotification
(
aSyncNotifyFlag
)
;
}
else
if
(
!
currentFinishedState
&
&
mFinishedIsResolved
)
{
ResetFinishedPromise
(
)
;
}
}
void
Animation
:
:
UpdateEffect
(
PostRestyleMode
aPostRestyle
)
{
if
(
mEffect
)
{
UpdateRelevance
(
)
;
KeyframeEffect
*
keyframeEffect
=
mEffect
-
>
AsKeyframeEffect
(
)
;
if
(
keyframeEffect
)
{
keyframeEffect
-
>
NotifyAnimationTimingUpdated
(
aPostRestyle
)
;
}
}
}
void
Animation
:
:
FlushUnanimatedStyle
(
)
const
{
if
(
Document
*
doc
=
GetRenderedDocument
(
)
)
{
doc
-
>
FlushPendingNotifications
(
ChangesToFlush
(
FlushType
:
:
Style
false
)
)
;
}
}
void
Animation
:
:
PostUpdate
(
)
{
if
(
!
mEffect
)
{
return
;
}
KeyframeEffect
*
keyframeEffect
=
mEffect
-
>
AsKeyframeEffect
(
)
;
if
(
!
keyframeEffect
)
{
return
;
}
keyframeEffect
-
>
RequestRestyle
(
EffectCompositor
:
:
RestyleType
:
:
Layer
)
;
}
void
Animation
:
:
CancelPendingTasks
(
)
{
if
(
mPendingState
=
=
PendingState
:
:
NotPending
)
{
return
;
}
if
(
Document
*
doc
=
GetRenderedDocument
(
)
)
{
PendingAnimationTracker
*
tracker
=
doc
-
>
GetPendingAnimationTracker
(
)
;
if
(
tracker
)
{
if
(
mPendingState
=
=
PendingState
:
:
PlayPending
)
{
tracker
-
>
RemovePlayPending
(
*
this
)
;
}
else
{
tracker
-
>
RemovePausePending
(
*
this
)
;
}
}
}
mPendingState
=
PendingState
:
:
NotPending
;
mPendingReadyTime
.
SetNull
(
)
;
}
void
Animation
:
:
ResetPendingTasks
(
)
{
if
(
mPendingState
=
=
PendingState
:
:
NotPending
)
{
return
;
}
CancelPendingTasks
(
)
;
ApplyPendingPlaybackRate
(
)
;
if
(
mReady
)
{
mReady
-
>
MaybeReject
(
NS_ERROR_DOM_ABORT_ERR
)
;
MOZ_ALWAYS_TRUE
(
mReady
-
>
SetAnyPromiseIsHandled
(
)
)
;
mReady
=
nullptr
;
}
}
void
Animation
:
:
ReschedulePendingTasks
(
)
{
if
(
mPendingState
=
=
PendingState
:
:
NotPending
)
{
return
;
}
mPendingReadyTime
.
SetNull
(
)
;
if
(
Document
*
doc
=
GetRenderedDocument
(
)
)
{
PendingAnimationTracker
*
tracker
=
doc
-
>
GetOrCreatePendingAnimationTracker
(
)
;
if
(
mPendingState
=
=
PendingState
:
:
PlayPending
&
&
!
tracker
-
>
IsWaitingToPlay
(
*
this
)
)
{
tracker
-
>
AddPlayPending
(
*
this
)
;
}
else
if
(
mPendingState
=
=
PendingState
:
:
PausePending
&
&
!
tracker
-
>
IsWaitingToPause
(
*
this
)
)
{
tracker
-
>
AddPausePending
(
*
this
)
;
}
}
}
Animation
:
:
ProgressTimelinePosition
Animation
:
:
AtProgressTimelineBoundary
(
const
Nullable
<
TimeDuration
>
&
aTimelineDuration
const
Nullable
<
TimeDuration
>
&
aCurrentTime
const
TimeDuration
&
aEffectStartTime
const
double
aPlaybackRate
)
{
if
(
aTimelineDuration
.
IsNull
(
)
|
|
aTimelineDuration
.
Value
(
)
.
IsZero
(
)
|
|
aPlaybackRate
=
=
0
.
0
)
{
return
ProgressTimelinePosition
:
:
NotBoundary
;
}
const
TimeDuration
&
effectiveStartTime
=
aEffectStartTime
;
const
TimeDuration
effectiveTimelineTime
=
(
aCurrentTime
.
IsNull
(
)
?
TimeDuration
(
)
:
aCurrentTime
.
Value
(
)
.
MultDouble
(
1
.
0
/
aPlaybackRate
)
)
+
effectiveStartTime
;
return
effectiveTimelineTime
.
IsZero
(
)
|
|
(
AnimationUtils
:
:
IsWithinAnimationTimeTolerance
(
effectiveTimelineTime
aTimelineDuration
.
Value
(
)
)
)
?
ProgressTimelinePosition
:
:
Boundary
:
ProgressTimelinePosition
:
:
NotBoundary
;
}
bool
Animation
:
:
IsPossiblyOrphanedPendingAnimation
(
)
const
{
if
(
mPendingState
=
=
PendingState
:
:
NotPending
)
{
return
false
;
}
if
(
!
mPendingReadyTime
.
IsNull
(
)
)
{
return
false
;
}
if
(
!
mTimeline
|
|
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
)
{
return
false
;
}
Document
*
doc
=
GetRenderedDocument
(
)
;
if
(
!
doc
)
{
return
true
;
}
PendingAnimationTracker
*
tracker
=
doc
-
>
GetPendingAnimationTracker
(
)
;
return
!
tracker
|
|
(
!
tracker
-
>
IsWaitingToPlay
(
*
this
)
&
&
!
tracker
-
>
IsWaitingToPause
(
*
this
)
)
;
}
StickyTimeDuration
Animation
:
:
EffectEnd
(
)
const
{
if
(
!
mEffect
)
{
return
StickyTimeDuration
(
0
)
;
}
return
mEffect
-
>
NormalizedTiming
(
)
.
EndTime
(
)
;
}
Document
*
Animation
:
:
GetRenderedDocument
(
)
const
{
if
(
!
mEffect
|
|
!
mEffect
-
>
AsKeyframeEffect
(
)
)
{
return
nullptr
;
}
return
mEffect
-
>
AsKeyframeEffect
(
)
-
>
GetRenderedDocument
(
)
;
}
Document
*
Animation
:
:
GetTimelineDocument
(
)
const
{
return
mTimeline
?
mTimeline
-
>
GetDocument
(
)
:
nullptr
;
}
class
AsyncFinishNotification
:
public
MicroTaskRunnable
{
public
:
explicit
AsyncFinishNotification
(
Animation
*
aAnimation
)
:
MicroTaskRunnable
(
)
mAnimation
(
aAnimation
)
{
}
virtual
void
Run
(
AutoSlowOperation
&
aAso
)
override
{
mAnimation
-
>
DoFinishNotificationImmediately
(
this
)
;
mAnimation
=
nullptr
;
}
virtual
bool
Suppressed
(
)
override
{
nsIGlobalObject
*
global
=
mAnimation
-
>
GetOwnerGlobal
(
)
;
return
global
&
&
global
-
>
IsInSyncOperation
(
)
;
}
private
:
RefPtr
<
Animation
>
mAnimation
;
}
;
void
Animation
:
:
DoFinishNotification
(
SyncNotifyFlag
aSyncNotifyFlag
)
{
CycleCollectedJSContext
*
context
=
CycleCollectedJSContext
:
:
Get
(
)
;
if
(
aSyncNotifyFlag
=
=
SyncNotifyFlag
:
:
Sync
)
{
DoFinishNotificationImmediately
(
)
;
}
else
if
(
!
mFinishNotificationTask
)
{
RefPtr
<
MicroTaskRunnable
>
runnable
=
new
AsyncFinishNotification
(
this
)
;
context
-
>
DispatchToMicroTask
(
do_AddRef
(
runnable
)
)
;
mFinishNotificationTask
=
std
:
:
move
(
runnable
)
;
}
}
void
Animation
:
:
ResetFinishedPromise
(
)
{
mFinishedIsResolved
=
false
;
mFinished
=
nullptr
;
}
void
Animation
:
:
MaybeResolveFinishedPromise
(
)
{
if
(
mFinished
)
{
mFinished
-
>
MaybeResolve
(
this
)
;
}
mFinishedIsResolved
=
true
;
}
void
Animation
:
:
DoFinishNotificationImmediately
(
MicroTaskRunnable
*
aAsync
)
{
if
(
aAsync
&
&
aAsync
!
=
mFinishNotificationTask
)
{
return
;
}
mFinishNotificationTask
=
nullptr
;
if
(
PlayState
(
)
!
=
AnimationPlayState
:
:
Finished
)
{
return
;
}
MaybeResolveFinishedPromise
(
)
;
QueuePlaybackEvent
(
u
"
finish
"
_ns
AnimationTimeToTimeStamp
(
EffectEnd
(
)
)
)
;
}
void
Animation
:
:
QueuePlaybackEvent
(
const
nsAString
&
aName
TimeStamp
&
&
aScheduledEventTime
)
{
Document
*
doc
=
GetTimelineDocument
(
)
;
if
(
!
doc
)
{
return
;
}
nsPresContext
*
presContext
=
doc
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
;
}
AnimationPlaybackEventInit
init
;
if
(
aName
.
EqualsLiteral
(
"
finish
"
)
|
|
aName
.
EqualsLiteral
(
"
remove
"
)
)
{
init
.
mCurrentTime
=
GetCurrentTimeAsDouble
(
)
;
}
if
(
mTimeline
)
{
init
.
mTimelineTime
=
mTimeline
-
>
GetCurrentTimeAsDouble
(
)
;
}
RefPtr
<
AnimationPlaybackEvent
>
event
=
AnimationPlaybackEvent
:
:
Constructor
(
this
aName
init
)
;
event
-
>
SetTrusted
(
true
)
;
presContext
-
>
AnimationEventDispatcher
(
)
-
>
QueueEvent
(
AnimationEventInfo
(
aName
std
:
:
move
(
event
)
std
:
:
move
(
aScheduledEventTime
)
this
)
)
;
}
bool
Animation
:
:
IsRunningOnCompositor
(
)
const
{
return
mEffect
&
&
mEffect
-
>
AsKeyframeEffect
(
)
&
&
mEffect
-
>
AsKeyframeEffect
(
)
-
>
IsRunningOnCompositor
(
)
;
}
bool
Animation
:
:
HasCurrentEffect
(
)
const
{
return
GetEffect
(
)
&
&
GetEffect
(
)
-
>
IsCurrent
(
)
;
}
bool
Animation
:
:
IsInEffect
(
)
const
{
return
GetEffect
(
)
&
&
GetEffect
(
)
-
>
IsInEffect
(
)
;
}
void
Animation
:
:
SetHiddenByContentVisibility
(
bool
hidden
)
{
if
(
mHiddenByContentVisibility
=
=
hidden
)
{
return
;
}
mHiddenByContentVisibility
=
hidden
;
if
(
!
GetTimeline
(
)
)
{
return
;
}
GetTimeline
(
)
-
>
NotifyAnimationContentVisibilityChanged
(
this
!
hidden
)
;
}
StickyTimeDuration
Animation
:
:
IntervalStartTime
(
const
StickyTimeDuration
&
aActiveDuration
)
const
{
MOZ_ASSERT
(
AsCSSTransition
(
)
|
|
AsCSSAnimation
(
)
"
Should
be
called
for
CSS
animations
or
transitions
"
)
;
static
constexpr
StickyTimeDuration
zeroDuration
=
StickyTimeDuration
(
)
;
return
std
:
:
max
(
std
:
:
min
(
StickyTimeDuration
(
-
mEffect
-
>
NormalizedTiming
(
)
.
Delay
(
)
)
aActiveDuration
)
zeroDuration
)
;
}
StickyTimeDuration
Animation
:
:
IntervalEndTime
(
const
StickyTimeDuration
&
aActiveDuration
)
const
{
MOZ_ASSERT
(
AsCSSTransition
(
)
|
|
AsCSSAnimation
(
)
"
Should
be
called
for
CSS
animations
or
transitions
"
)
;
static
constexpr
StickyTimeDuration
zeroDuration
=
StickyTimeDuration
(
)
;
const
StickyTimeDuration
&
effectEnd
=
EffectEnd
(
)
;
if
(
MOZ_UNLIKELY
(
effectEnd
=
=
TimeDuration
:
:
Forever
(
)
&
&
effectEnd
=
=
mEffect
-
>
NormalizedTiming
(
)
.
Delay
(
)
)
)
{
return
zeroDuration
;
}
return
std
:
:
max
(
std
:
:
min
(
effectEnd
-
mEffect
-
>
NormalizedTiming
(
)
.
Delay
(
)
aActiveDuration
)
zeroDuration
)
;
}
}
