#
include
"
Animation
.
h
"
#
include
"
AnimationUtils
.
h
"
#
include
"
mozilla
/
dom
/
AnimationBinding
.
h
"
#
include
"
mozilla
/
dom
/
AnimationPlaybackEvent
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
PendingAnimationTracker
.
h
"
namespace
mozilla
{
namespace
dom
{
uint64_t
Animation
:
:
sNextAnimationIndex
=
0
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
Animation
DOMEventTargetHelper
mTimeline
mEffect
mReady
mFinished
)
NS_IMPL_ADDREF_INHERITED
(
Animation
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
Animation
DOMEventTargetHelper
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
Animation
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
JSObject
*
Animation
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
AnimationBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
namespace
{
class
MOZ_RAII
AutoMutationBatchForAnimation
{
public
:
explicit
AutoMutationBatchForAnimation
(
const
Animation
&
aAnimation
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
Element
*
targetElement
=
nsNodeUtils
:
:
GetTargetForAnimation
(
&
aAnimation
)
;
if
(
!
targetElement
)
{
return
;
}
nsIDocument
*
doc
=
targetElement
-
>
OwnerDoc
(
)
;
if
(
!
doc
)
{
return
;
}
mAutoBatch
.
emplace
(
doc
)
;
}
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
Maybe
<
nsAutoAnimationMutationBatch
>
mAutoBatch
;
}
;
}
already_AddRefed
<
Animation
>
Animation
:
:
Constructor
(
const
GlobalObject
&
aGlobal
KeyframeEffectReadOnly
*
aEffect
AnimationTimeline
*
aTimeline
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
RefPtr
<
Animation
>
animation
=
new
Animation
(
global
)
;
if
(
!
aTimeline
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
!
aEffect
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
animation
-
>
SetTimeline
(
aTimeline
)
;
animation
-
>
SetEffect
(
aEffect
)
;
return
animation
.
forget
(
)
;
}
void
Animation
:
:
SetId
(
const
nsAString
&
aId
)
{
if
(
mId
=
=
aId
)
{
return
;
}
mId
=
aId
;
nsNodeUtils
:
:
AnimationChanged
(
this
)
;
}
void
Animation
:
:
SetEffect
(
KeyframeEffectReadOnly
*
aEffect
)
{
RefPtr
<
Animation
>
kungFuDeathGrip
(
this
)
;
if
(
mEffect
=
=
aEffect
)
{
return
;
}
if
(
mEffect
)
{
mEffect
-
>
SetAnimation
(
nullptr
)
;
}
mEffect
=
aEffect
;
if
(
mEffect
)
{
mEffect
-
>
SetAnimation
(
this
)
;
}
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
}
void
Animation
:
:
SetTimeline
(
AnimationTimeline
*
aTimeline
)
{
if
(
mTimeline
=
=
aTimeline
)
{
return
;
}
if
(
mTimeline
)
{
mTimeline
-
>
NotifyAnimationUpdated
(
*
this
)
;
}
mTimeline
=
aTimeline
;
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
}
void
Animation
:
:
SetStartTime
(
const
Nullable
<
TimeDuration
>
&
aNewStartTime
)
{
if
(
aNewStartTime
=
=
mStartTime
)
{
return
;
}
AutoMutationBatchForAnimation
mb
(
*
this
)
;
Nullable
<
TimeDuration
>
timelineTime
;
if
(
mTimeline
)
{
timelineTime
=
mTimeline
-
>
GetCurrentTime
(
)
;
}
if
(
timelineTime
.
IsNull
(
)
&
&
!
aNewStartTime
.
IsNull
(
)
)
{
mHoldTime
.
SetNull
(
)
;
}
Nullable
<
TimeDuration
>
previousCurrentTime
=
GetCurrentTime
(
)
;
mStartTime
=
aNewStartTime
;
if
(
!
aNewStartTime
.
IsNull
(
)
)
{
if
(
mPlaybackRate
!
=
0
.
0
)
{
mHoldTime
.
SetNull
(
)
;
}
}
else
{
mHoldTime
=
previousCurrentTime
;
}
CancelPendingTasks
(
)
;
if
(
mReady
)
{
mReady
-
>
MaybeResolve
(
this
)
;
}
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
IsRelevant
(
)
)
{
nsNodeUtils
:
:
AnimationChanged
(
this
)
;
}
PostUpdate
(
)
;
}
Nullable
<
TimeDuration
>
Animation
:
:
GetCurrentTime
(
)
const
{
Nullable
<
TimeDuration
>
result
;
if
(
!
mHoldTime
.
IsNull
(
)
)
{
result
=
mHoldTime
;
return
result
;
}
if
(
mTimeline
&
&
!
mStartTime
.
IsNull
(
)
)
{
Nullable
<
TimeDuration
>
timelineTime
=
mTimeline
-
>
GetCurrentTime
(
)
;
if
(
!
timelineTime
.
IsNull
(
)
)
{
result
.
SetValue
(
(
timelineTime
.
Value
(
)
-
mStartTime
.
Value
(
)
)
.
MultDouble
(
mPlaybackRate
)
)
;
}
}
return
result
;
}
void
Animation
:
:
SetCurrentTime
(
const
TimeDuration
&
aSeekTime
)
{
if
(
mPendingState
!
=
PendingState
:
:
PausePending
&
&
Nullable
<
TimeDuration
>
(
aSeekTime
)
=
=
GetCurrentTime
(
)
)
{
return
;
}
AutoMutationBatchForAnimation
mb
(
*
this
)
;
SilentlySetCurrentTime
(
aSeekTime
)
;
if
(
mPendingState
=
=
PendingState
:
:
PausePending
)
{
mHoldTime
.
SetValue
(
aSeekTime
)
;
mStartTime
.
SetNull
(
)
;
if
(
mReady
)
{
mReady
-
>
MaybeResolve
(
this
)
;
}
CancelPendingTasks
(
)
;
}
UpdateTiming
(
SeekFlag
:
:
DidSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
IsRelevant
(
)
)
{
nsNodeUtils
:
:
AnimationChanged
(
this
)
;
}
PostUpdate
(
)
;
}
void
Animation
:
:
SetPlaybackRate
(
double
aPlaybackRate
)
{
if
(
aPlaybackRate
=
=
mPlaybackRate
)
{
return
;
}
AutoMutationBatchForAnimation
mb
(
*
this
)
;
Nullable
<
TimeDuration
>
previousTime
=
GetCurrentTime
(
)
;
mPlaybackRate
=
aPlaybackRate
;
if
(
!
previousTime
.
IsNull
(
)
)
{
SetCurrentTime
(
previousTime
.
Value
(
)
)
;
}
UpdateTiming
(
SeekFlag
:
:
DidSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
IsRelevant
(
)
)
{
nsNodeUtils
:
:
AnimationChanged
(
this
)
;
}
PostUpdate
(
)
;
}
AnimationPlayState
Animation
:
:
PlayState
(
)
const
{
if
(
mPendingState
!
=
PendingState
:
:
NotPending
)
{
return
AnimationPlayState
:
:
Pending
;
}
Nullable
<
TimeDuration
>
currentTime
=
GetCurrentTime
(
)
;
if
(
currentTime
.
IsNull
(
)
)
{
return
AnimationPlayState
:
:
Idle
;
}
if
(
mStartTime
.
IsNull
(
)
)
{
return
AnimationPlayState
:
:
Paused
;
}
if
(
(
mPlaybackRate
>
0
.
0
&
&
currentTime
.
Value
(
)
>
=
EffectEnd
(
)
)
|
|
(
mPlaybackRate
<
0
.
0
&
&
currentTime
.
Value
(
)
.
ToMilliseconds
(
)
<
=
0
.
0
)
)
{
return
AnimationPlayState
:
:
Finished
;
}
return
AnimationPlayState
:
:
Running
;
}
Promise
*
Animation
:
:
GetReady
(
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
GetOwnerGlobal
(
)
;
if
(
!
mReady
&
&
global
)
{
mReady
=
Promise
:
:
Create
(
global
aRv
)
;
}
if
(
!
mReady
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
}
else
if
(
PlayState
(
)
!
=
AnimationPlayState
:
:
Pending
)
{
mReady
-
>
MaybeResolve
(
this
)
;
}
return
mReady
;
}
Promise
*
Animation
:
:
GetFinished
(
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
GetOwnerGlobal
(
)
;
if
(
!
mFinished
&
&
global
)
{
mFinished
=
Promise
:
:
Create
(
global
aRv
)
;
}
if
(
!
mFinished
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
}
else
if
(
mFinishedIsResolved
)
{
MaybeResolveFinishedPromise
(
)
;
}
return
mFinished
;
}
void
Animation
:
:
Cancel
(
)
{
DoCancel
(
)
;
PostUpdate
(
)
;
}
void
Animation
:
:
Finish
(
ErrorResult
&
aRv
)
{
if
(
mPlaybackRate
=
=
0
|
|
(
mPlaybackRate
>
0
&
&
EffectEnd
(
)
=
=
TimeDuration
:
:
Forever
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
AutoMutationBatchForAnimation
mb
(
*
this
)
;
TimeDuration
limit
=
mPlaybackRate
>
0
?
TimeDuration
(
EffectEnd
(
)
)
:
TimeDuration
(
0
)
;
bool
didChange
=
GetCurrentTime
(
)
!
=
Nullable
<
TimeDuration
>
(
limit
)
;
SilentlySetCurrentTime
(
limit
)
;
if
(
mStartTime
.
IsNull
(
)
&
&
mTimeline
&
&
!
mTimeline
-
>
GetCurrentTime
(
)
.
IsNull
(
)
)
{
mStartTime
.
SetValue
(
mTimeline
-
>
GetCurrentTime
(
)
.
Value
(
)
-
limit
.
MultDouble
(
1
.
0
/
mPlaybackRate
)
)
;
didChange
=
true
;
}
if
(
!
mStartTime
.
IsNull
(
)
&
&
(
mPendingState
=
=
PendingState
:
:
PlayPending
|
|
mPendingState
=
=
PendingState
:
:
PausePending
)
)
{
if
(
mPendingState
=
=
PendingState
:
:
PausePending
)
{
mHoldTime
.
SetNull
(
)
;
}
CancelPendingTasks
(
)
;
didChange
=
true
;
if
(
mReady
)
{
mReady
-
>
MaybeResolve
(
this
)
;
}
}
UpdateTiming
(
SeekFlag
:
:
DidSeek
SyncNotifyFlag
:
:
Sync
)
;
if
(
didChange
&
&
IsRelevant
(
)
)
{
nsNodeUtils
:
:
AnimationChanged
(
this
)
;
}
PostUpdate
(
)
;
}
void
Animation
:
:
Play
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
{
DoPlay
(
aRv
aLimitBehavior
)
;
PostUpdate
(
)
;
}
void
Animation
:
:
Pause
(
ErrorResult
&
aRv
)
{
DoPause
(
aRv
)
;
PostUpdate
(
)
;
}
void
Animation
:
:
Reverse
(
ErrorResult
&
aRv
)
{
if
(
!
mTimeline
|
|
mTimeline
-
>
GetCurrentTime
(
)
.
IsNull
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
mPlaybackRate
=
=
0
.
0
)
{
return
;
}
AutoMutationBatchForAnimation
mb
(
*
this
)
;
SilentlySetPlaybackRate
(
-
mPlaybackRate
)
;
Play
(
aRv
LimitBehavior
:
:
AutoRewind
)
;
if
(
IsRelevant
(
)
)
{
nsNodeUtils
:
:
AnimationChanged
(
this
)
;
}
}
Nullable
<
double
>
Animation
:
:
GetStartTimeAsDouble
(
)
const
{
return
AnimationUtils
:
:
TimeDurationToDouble
(
mStartTime
)
;
}
void
Animation
:
:
SetStartTimeAsDouble
(
const
Nullable
<
double
>
&
aStartTime
)
{
return
SetStartTime
(
AnimationUtils
:
:
DoubleToTimeDuration
(
aStartTime
)
)
;
}
Nullable
<
double
>
Animation
:
:
GetCurrentTimeAsDouble
(
)
const
{
return
AnimationUtils
:
:
TimeDurationToDouble
(
GetCurrentTime
(
)
)
;
}
void
Animation
:
:
SetCurrentTimeAsDouble
(
const
Nullable
<
double
>
&
aCurrentTime
ErrorResult
&
aRv
)
{
if
(
aCurrentTime
.
IsNull
(
)
)
{
if
(
!
GetCurrentTime
(
)
.
IsNull
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_TYPE_ERR
)
;
}
return
;
}
return
SetCurrentTime
(
TimeDuration
:
:
FromMilliseconds
(
aCurrentTime
.
Value
(
)
)
)
;
}
void
Animation
:
:
Tick
(
)
{
if
(
mPendingState
!
=
PendingState
:
:
NotPending
&
&
!
mPendingReadyTime
.
IsNull
(
)
&
&
mTimeline
&
&
!
mTimeline
-
>
GetCurrentTime
(
)
.
IsNull
(
)
)
{
mPendingReadyTime
.
SetValue
(
std
:
:
min
(
mTimeline
-
>
GetCurrentTime
(
)
.
Value
(
)
mPendingReadyTime
.
Value
(
)
)
)
;
FinishPendingAt
(
mPendingReadyTime
.
Value
(
)
)
;
mPendingReadyTime
.
SetNull
(
)
;
}
if
(
IsPossiblyOrphanedPendingAnimation
(
)
)
{
MOZ_ASSERT
(
mTimeline
&
&
!
mTimeline
-
>
GetCurrentTime
(
)
.
IsNull
(
)
"
Orphaned
pending
animtaions
should
have
an
active
timeline
"
)
;
FinishPendingAt
(
mTimeline
-
>
GetCurrentTime
(
)
.
Value
(
)
)
;
}
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
mEffect
&
&
!
mEffect
-
>
Properties
(
)
.
IsEmpty
(
)
&
&
!
mFinishedAtLastComposeStyle
&
&
PlayState
(
)
=
=
AnimationPlayState
:
:
Finished
)
{
PostUpdate
(
)
;
}
}
void
Animation
:
:
TriggerOnNextTick
(
const
Nullable
<
TimeDuration
>
&
aReadyTime
)
{
if
(
PlayState
(
)
!
=
AnimationPlayState
:
:
Pending
)
{
return
;
}
mPendingReadyTime
=
aReadyTime
;
}
void
Animation
:
:
TriggerNow
(
)
{
if
(
PlayState
(
)
!
=
AnimationPlayState
:
:
Pending
)
{
return
;
}
if
(
!
mTimeline
|
|
mTimeline
-
>
GetCurrentTime
(
)
.
IsNull
(
)
)
{
NS_WARNING
(
"
Failed
to
trigger
an
animation
with
an
active
timeline
"
)
;
return
;
}
FinishPendingAt
(
mTimeline
-
>
GetCurrentTime
(
)
.
Value
(
)
)
;
}
Nullable
<
TimeDuration
>
Animation
:
:
GetCurrentOrPendingStartTime
(
)
const
{
Nullable
<
TimeDuration
>
result
;
if
(
!
mStartTime
.
IsNull
(
)
)
{
result
=
mStartTime
;
return
result
;
}
if
(
mPendingReadyTime
.
IsNull
(
)
|
|
mHoldTime
.
IsNull
(
)
)
{
return
result
;
}
result
.
SetValue
(
mPendingReadyTime
.
Value
(
)
-
mHoldTime
.
Value
(
)
)
;
return
result
;
}
TimeStamp
Animation
:
:
AnimationTimeToTimeStamp
(
const
StickyTimeDuration
&
aTime
)
const
{
TimeStamp
result
;
if
(
!
mTimeline
)
{
return
result
;
}
if
(
aTime
=
=
TimeDuration
:
:
Forever
(
)
|
|
mPlaybackRate
=
=
0
.
0
|
|
mStartTime
.
IsNull
(
)
)
{
return
result
;
}
TimeDuration
timelineTime
=
TimeDuration
(
aTime
)
.
MultDouble
(
1
.
0
/
mPlaybackRate
)
+
mStartTime
.
Value
(
)
;
result
=
mTimeline
-
>
ToTimeStamp
(
timelineTime
)
;
return
result
;
}
void
Animation
:
:
SilentlySetCurrentTime
(
const
TimeDuration
&
aSeekTime
)
{
if
(
!
mHoldTime
.
IsNull
(
)
|
|
mStartTime
.
IsNull
(
)
|
|
!
mTimeline
|
|
mTimeline
-
>
GetCurrentTime
(
)
.
IsNull
(
)
|
|
mPlaybackRate
=
=
0
.
0
)
{
mHoldTime
.
SetValue
(
aSeekTime
)
;
if
(
!
mTimeline
|
|
mTimeline
-
>
GetCurrentTime
(
)
.
IsNull
(
)
)
{
mStartTime
.
SetNull
(
)
;
}
}
else
{
mStartTime
.
SetValue
(
mTimeline
-
>
GetCurrentTime
(
)
.
Value
(
)
-
(
aSeekTime
.
MultDouble
(
1
/
mPlaybackRate
)
)
)
;
}
mPreviousCurrentTime
.
SetNull
(
)
;
}
void
Animation
:
:
SilentlySetPlaybackRate
(
double
aPlaybackRate
)
{
Nullable
<
TimeDuration
>
previousTime
=
GetCurrentTime
(
)
;
mPlaybackRate
=
aPlaybackRate
;
if
(
!
previousTime
.
IsNull
(
)
)
{
SilentlySetCurrentTime
(
previousTime
.
Value
(
)
)
;
}
}
void
Animation
:
:
DoCancel
(
)
{
if
(
mPendingState
!
=
PendingState
:
:
NotPending
)
{
CancelPendingTasks
(
)
;
if
(
mReady
)
{
mReady
-
>
MaybeReject
(
NS_ERROR_DOM_ABORT_ERR
)
;
}
}
if
(
mFinished
)
{
mFinished
-
>
MaybeReject
(
NS_ERROR_DOM_ABORT_ERR
)
;
}
ResetFinishedPromise
(
)
;
DispatchPlaybackEvent
(
NS_LITERAL_STRING
(
"
cancel
"
)
)
;
mHoldTime
.
SetNull
(
)
;
mStartTime
.
SetNull
(
)
;
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
mTimeline
)
{
mTimeline
-
>
RemoveAnimation
(
this
)
;
}
}
void
Animation
:
:
UpdateRelevance
(
)
{
bool
wasRelevant
=
mIsRelevant
;
mIsRelevant
=
HasCurrentEffect
(
)
|
|
IsInEffect
(
)
;
if
(
wasRelevant
&
&
!
mIsRelevant
)
{
nsNodeUtils
:
:
AnimationRemoved
(
this
)
;
}
else
if
(
!
wasRelevant
&
&
mIsRelevant
)
{
nsNodeUtils
:
:
AnimationAdded
(
this
)
;
}
}
bool
Animation
:
:
HasLowerCompositeOrderThan
(
const
Animation
&
aOther
)
const
{
if
(
&
aOther
=
=
this
)
{
return
false
;
}
{
auto
asCSSTransitionForSorting
=
[
]
(
const
Animation
&
anim
)
-
>
const
CSSTransition
*
{
const
CSSTransition
*
transition
=
anim
.
AsCSSTransition
(
)
;
return
transition
&
&
transition
-
>
IsTiedToMarkup
(
)
?
transition
:
nullptr
;
}
;
auto
thisTransition
=
asCSSTransitionForSorting
(
*
this
)
;
auto
otherTransition
=
asCSSTransitionForSorting
(
aOther
)
;
if
(
thisTransition
&
&
otherTransition
)
{
return
thisTransition
-
>
HasLowerCompositeOrderThan
(
*
otherTransition
)
;
}
if
(
thisTransition
|
|
otherTransition
)
{
return
thisTransition
;
}
}
{
auto
asCSSAnimationForSorting
=
[
]
(
const
Animation
&
anim
)
-
>
const
CSSAnimation
*
{
const
CSSAnimation
*
animation
=
anim
.
AsCSSAnimation
(
)
;
return
animation
&
&
animation
-
>
IsTiedToMarkup
(
)
?
animation
:
nullptr
;
}
;
auto
thisAnimation
=
asCSSAnimationForSorting
(
*
this
)
;
auto
otherAnimation
=
asCSSAnimationForSorting
(
aOther
)
;
if
(
thisAnimation
&
&
otherAnimation
)
{
return
thisAnimation
-
>
HasLowerCompositeOrderThan
(
*
otherAnimation
)
;
}
if
(
thisAnimation
|
|
otherAnimation
)
{
return
thisAnimation
;
}
}
MOZ_ASSERT
(
mAnimationIndex
!
=
aOther
.
mAnimationIndex
"
Animation
indices
should
be
unique
"
)
;
return
mAnimationIndex
<
aOther
.
mAnimationIndex
;
}
void
Animation
:
:
ComposeStyle
(
RefPtr
<
AnimValuesStyleRule
>
&
aStyleRule
nsCSSPropertySet
&
aSetProperties
)
{
if
(
!
mEffect
)
{
return
;
}
if
(
!
IsInEffect
(
)
)
{
return
;
}
AnimationPlayState
playState
=
PlayState
(
)
;
{
AutoRestore
<
Nullable
<
TimeDuration
>
>
restoreHoldTime
(
mHoldTime
)
;
if
(
playState
=
=
AnimationPlayState
:
:
Pending
&
&
mHoldTime
.
IsNull
(
)
&
&
!
mStartTime
.
IsNull
(
)
)
{
Nullable
<
TimeDuration
>
timeToUse
=
mPendingReadyTime
;
if
(
timeToUse
.
IsNull
(
)
&
&
mTimeline
&
&
mTimeline
-
>
TracksWallclockTime
(
)
)
{
timeToUse
=
mTimeline
-
>
ToTimelineTime
(
TimeStamp
:
:
Now
(
)
)
;
}
if
(
!
timeToUse
.
IsNull
(
)
)
{
mHoldTime
.
SetValue
(
(
timeToUse
.
Value
(
)
-
mStartTime
.
Value
(
)
)
.
MultDouble
(
mPlaybackRate
)
)
;
}
}
mEffect
-
>
ComposeStyle
(
aStyleRule
aSetProperties
)
;
}
MOZ_ASSERT
(
playState
=
=
PlayState
(
)
"
Play
state
should
not
change
during
the
course
of
compositing
"
)
;
mFinishedAtLastComposeStyle
=
(
playState
=
=
AnimationPlayState
:
:
Finished
)
;
}
void
Animation
:
:
NotifyEffectTimingUpdated
(
)
{
MOZ_ASSERT
(
mEffect
"
We
should
only
update
timing
effect
when
we
have
a
target
"
"
effect
"
)
;
UpdateTiming
(
Animation
:
:
SeekFlag
:
:
NoSeek
Animation
:
:
SyncNotifyFlag
:
:
Async
)
;
}
void
Animation
:
:
DoPlay
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
{
AutoMutationBatchForAnimation
mb
(
*
this
)
;
bool
abortedPause
=
mPendingState
=
=
PendingState
:
:
PausePending
;
Nullable
<
TimeDuration
>
currentTime
=
GetCurrentTime
(
)
;
if
(
mPlaybackRate
>
0
.
0
&
&
(
currentTime
.
IsNull
(
)
|
|
(
aLimitBehavior
=
=
LimitBehavior
:
:
AutoRewind
&
&
(
currentTime
.
Value
(
)
.
ToMilliseconds
(
)
<
0
.
0
|
|
currentTime
.
Value
(
)
>
=
EffectEnd
(
)
)
)
)
)
{
mHoldTime
.
SetValue
(
TimeDuration
(
0
)
)
;
}
else
if
(
mPlaybackRate
<
0
.
0
&
&
(
currentTime
.
IsNull
(
)
|
|
(
aLimitBehavior
=
=
LimitBehavior
:
:
AutoRewind
&
&
(
currentTime
.
Value
(
)
.
ToMilliseconds
(
)
<
=
0
.
0
|
|
currentTime
.
Value
(
)
>
EffectEnd
(
)
)
)
)
)
{
if
(
EffectEnd
(
)
=
=
TimeDuration
:
:
Forever
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
mHoldTime
.
SetValue
(
TimeDuration
(
EffectEnd
(
)
)
)
;
}
else
if
(
mPlaybackRate
=
=
0
.
0
&
&
currentTime
.
IsNull
(
)
)
{
mHoldTime
.
SetValue
(
TimeDuration
(
0
)
)
;
}
bool
reuseReadyPromise
=
false
;
if
(
mPendingState
!
=
PendingState
:
:
NotPending
)
{
CancelPendingTasks
(
)
;
reuseReadyPromise
=
true
;
}
if
(
mHoldTime
.
IsNull
(
)
&
&
!
abortedPause
)
{
return
;
}
if
(
!
mHoldTime
.
IsNull
(
)
)
{
mStartTime
.
SetNull
(
)
;
}
if
(
!
reuseReadyPromise
)
{
mReady
=
nullptr
;
}
mPendingState
=
PendingState
:
:
PlayPending
;
nsIDocument
*
doc
=
GetRenderedDocument
(
)
;
if
(
doc
)
{
PendingAnimationTracker
*
tracker
=
doc
-
>
GetOrCreatePendingAnimationTracker
(
)
;
tracker
-
>
AddPlayPending
(
*
this
)
;
}
else
{
TriggerOnNextTick
(
Nullable
<
TimeDuration
>
(
)
)
;
}
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
IsRelevant
(
)
)
{
nsNodeUtils
:
:
AnimationChanged
(
this
)
;
}
}
void
Animation
:
:
DoPause
(
ErrorResult
&
aRv
)
{
if
(
IsPausedOrPausing
(
)
)
{
return
;
}
AutoMutationBatchForAnimation
mb
(
*
this
)
;
if
(
GetCurrentTime
(
)
.
IsNull
(
)
)
{
if
(
mPlaybackRate
>
=
0
.
0
)
{
mHoldTime
.
SetValue
(
TimeDuration
(
0
)
)
;
}
else
{
if
(
EffectEnd
(
)
=
=
TimeDuration
:
:
Forever
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
mHoldTime
.
SetValue
(
TimeDuration
(
EffectEnd
(
)
)
)
;
}
}
bool
reuseReadyPromise
=
false
;
if
(
mPendingState
=
=
PendingState
:
:
PlayPending
)
{
CancelPendingTasks
(
)
;
reuseReadyPromise
=
true
;
}
if
(
!
reuseReadyPromise
)
{
mReady
=
nullptr
;
}
mPendingState
=
PendingState
:
:
PausePending
;
nsIDocument
*
doc
=
GetRenderedDocument
(
)
;
if
(
doc
)
{
PendingAnimationTracker
*
tracker
=
doc
-
>
GetOrCreatePendingAnimationTracker
(
)
;
tracker
-
>
AddPausePending
(
*
this
)
;
}
else
{
TriggerOnNextTick
(
Nullable
<
TimeDuration
>
(
)
)
;
}
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
IsRelevant
(
)
)
{
nsNodeUtils
:
:
AnimationChanged
(
this
)
;
}
}
void
Animation
:
:
ResumeAt
(
const
TimeDuration
&
aReadyTime
)
{
MOZ_ASSERT
(
mPendingState
=
=
PendingState
:
:
PlayPending
"
Expected
to
resume
a
play
-
pending
animation
"
)
;
MOZ_ASSERT
(
mHoldTime
.
IsNull
(
)
!
=
mStartTime
.
IsNull
(
)
"
An
animation
in
the
play
-
pending
state
should
have
either
a
"
"
resolved
hold
time
or
resolved
start
time
(
but
not
both
)
"
)
;
if
(
mStartTime
.
IsNull
(
)
)
{
if
(
mPlaybackRate
!
=
0
)
{
mStartTime
.
SetValue
(
aReadyTime
-
(
mHoldTime
.
Value
(
)
.
MultDouble
(
1
/
mPlaybackRate
)
)
)
;
mHoldTime
.
SetNull
(
)
;
}
else
{
mStartTime
.
SetValue
(
aReadyTime
)
;
}
}
mPendingState
=
PendingState
:
:
NotPending
;
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
mReady
)
{
mReady
-
>
MaybeResolve
(
this
)
;
}
}
void
Animation
:
:
PauseAt
(
const
TimeDuration
&
aReadyTime
)
{
MOZ_ASSERT
(
mPendingState
=
=
PendingState
:
:
PausePending
"
Expected
to
pause
a
pause
-
pending
animation
"
)
;
if
(
!
mStartTime
.
IsNull
(
)
&
&
mHoldTime
.
IsNull
(
)
)
{
mHoldTime
.
SetValue
(
(
aReadyTime
-
mStartTime
.
Value
(
)
)
.
MultDouble
(
mPlaybackRate
)
)
;
}
mStartTime
.
SetNull
(
)
;
mPendingState
=
PendingState
:
:
NotPending
;
UpdateTiming
(
SeekFlag
:
:
NoSeek
SyncNotifyFlag
:
:
Async
)
;
if
(
mReady
)
{
mReady
-
>
MaybeResolve
(
this
)
;
}
}
void
Animation
:
:
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
{
UpdateFinishedState
(
aSeekFlag
aSyncNotifyFlag
)
;
UpdateEffect
(
)
;
if
(
mTimeline
)
{
mTimeline
-
>
NotifyAnimationUpdated
(
*
this
)
;
}
}
void
Animation
:
:
UpdateFinishedState
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
{
Nullable
<
TimeDuration
>
currentTime
=
GetCurrentTime
(
)
;
TimeDuration
effectEnd
=
TimeDuration
(
EffectEnd
(
)
)
;
if
(
!
mStartTime
.
IsNull
(
)
&
&
mPendingState
=
=
PendingState
:
:
NotPending
)
{
if
(
mPlaybackRate
>
0
.
0
&
&
!
currentTime
.
IsNull
(
)
&
&
currentTime
.
Value
(
)
>
=
effectEnd
)
{
if
(
aSeekFlag
=
=
SeekFlag
:
:
DidSeek
)
{
mHoldTime
=
currentTime
;
}
else
if
(
!
mPreviousCurrentTime
.
IsNull
(
)
)
{
mHoldTime
.
SetValue
(
std
:
:
max
(
mPreviousCurrentTime
.
Value
(
)
effectEnd
)
)
;
}
else
{
mHoldTime
.
SetValue
(
effectEnd
)
;
}
}
else
if
(
mPlaybackRate
<
0
.
0
&
&
!
currentTime
.
IsNull
(
)
&
&
currentTime
.
Value
(
)
.
ToMilliseconds
(
)
<
=
0
.
0
)
{
if
(
aSeekFlag
=
=
SeekFlag
:
:
DidSeek
)
{
mHoldTime
=
currentTime
;
}
else
{
mHoldTime
.
SetValue
(
0
)
;
}
}
else
if
(
mPlaybackRate
!
=
0
.
0
&
&
!
currentTime
.
IsNull
(
)
&
&
mTimeline
&
&
!
mTimeline
-
>
GetCurrentTime
(
)
.
IsNull
(
)
)
{
if
(
aSeekFlag
=
=
SeekFlag
:
:
DidSeek
&
&
!
mHoldTime
.
IsNull
(
)
)
{
mStartTime
.
SetValue
(
mTimeline
-
>
GetCurrentTime
(
)
.
Value
(
)
-
(
mHoldTime
.
Value
(
)
.
MultDouble
(
1
/
mPlaybackRate
)
)
)
;
}
mHoldTime
.
SetNull
(
)
;
}
}
bool
currentFinishedState
=
PlayState
(
)
=
=
AnimationPlayState
:
:
Finished
;
if
(
currentFinishedState
&
&
!
mFinishedIsResolved
)
{
DoFinishNotification
(
aSyncNotifyFlag
)
;
}
else
if
(
!
currentFinishedState
&
&
mFinishedIsResolved
)
{
ResetFinishedPromise
(
)
;
}
mPreviousCurrentTime
=
GetCurrentTime
(
)
;
}
void
Animation
:
:
UpdateEffect
(
)
{
if
(
mEffect
)
{
UpdateRelevance
(
)
;
mEffect
-
>
NotifyAnimationTimingUpdated
(
)
;
}
}
void
Animation
:
:
FlushStyle
(
)
const
{
nsIDocument
*
doc
=
GetRenderedDocument
(
)
;
if
(
doc
)
{
doc
-
>
FlushPendingNotifications
(
Flush_Style
)
;
}
}
void
Animation
:
:
PostUpdate
(
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
;
}
Element
*
targetElement
;
CSSPseudoElementType
targetPseudoType
;
mEffect
-
>
GetTarget
(
targetElement
targetPseudoType
)
;
if
(
!
targetElement
)
{
return
;
}
presContext
-
>
EffectCompositor
(
)
-
>
RequestRestyle
(
targetElement
targetPseudoType
EffectCompositor
:
:
RestyleType
:
:
Layer
CascadeLevel
(
)
)
;
}
void
Animation
:
:
CancelPendingTasks
(
)
{
if
(
mPendingState
=
=
PendingState
:
:
NotPending
)
{
return
;
}
nsIDocument
*
doc
=
GetRenderedDocument
(
)
;
if
(
doc
)
{
PendingAnimationTracker
*
tracker
=
doc
-
>
GetPendingAnimationTracker
(
)
;
if
(
tracker
)
{
if
(
mPendingState
=
=
PendingState
:
:
PlayPending
)
{
tracker
-
>
RemovePlayPending
(
*
this
)
;
}
else
{
tracker
-
>
RemovePausePending
(
*
this
)
;
}
}
}
mPendingState
=
PendingState
:
:
NotPending
;
mPendingReadyTime
.
SetNull
(
)
;
}
bool
Animation
:
:
IsPossiblyOrphanedPendingAnimation
(
)
const
{
if
(
mPendingState
=
=
PendingState
:
:
NotPending
)
{
return
false
;
}
if
(
!
mPendingReadyTime
.
IsNull
(
)
)
{
return
false
;
}
if
(
!
mTimeline
|
|
mTimeline
-
>
GetCurrentTime
(
)
.
IsNull
(
)
)
{
return
false
;
}
nsIDocument
*
doc
=
GetRenderedDocument
(
)
;
if
(
!
doc
)
{
return
true
;
}
PendingAnimationTracker
*
tracker
=
doc
-
>
GetPendingAnimationTracker
(
)
;
return
!
tracker
|
|
(
!
tracker
-
>
IsWaitingToPlay
(
*
this
)
&
&
!
tracker
-
>
IsWaitingToPause
(
*
this
)
)
;
}
StickyTimeDuration
Animation
:
:
EffectEnd
(
)
const
{
if
(
!
mEffect
)
{
return
StickyTimeDuration
(
0
)
;
}
return
mEffect
-
>
GetComputedTiming
(
)
.
mEndTime
;
}
nsIDocument
*
Animation
:
:
GetRenderedDocument
(
)
const
{
if
(
!
mEffect
)
{
return
nullptr
;
}
return
mEffect
-
>
GetRenderedDocument
(
)
;
}
nsPresContext
*
Animation
:
:
GetPresContext
(
)
const
{
if
(
!
mEffect
)
{
return
nullptr
;
}
return
mEffect
-
>
GetPresContext
(
)
;
}
void
Animation
:
:
DoFinishNotification
(
SyncNotifyFlag
aSyncNotifyFlag
)
{
if
(
aSyncNotifyFlag
=
=
SyncNotifyFlag
:
:
Sync
)
{
DoFinishNotificationImmediately
(
)
;
}
else
if
(
!
mFinishNotificationTask
.
IsPending
(
)
)
{
RefPtr
<
nsRunnableMethod
<
Animation
>
>
runnable
=
NS_NewRunnableMethod
(
this
&
Animation
:
:
DoFinishNotificationImmediately
)
;
Promise
:
:
DispatchToMicroTask
(
runnable
)
;
mFinishNotificationTask
=
runnable
;
}
}
void
Animation
:
:
ResetFinishedPromise
(
)
{
mFinishedIsResolved
=
false
;
mFinished
=
nullptr
;
}
void
Animation
:
:
MaybeResolveFinishedPromise
(
)
{
if
(
mFinished
)
{
mFinished
-
>
MaybeResolve
(
this
)
;
}
mFinishedIsResolved
=
true
;
}
void
Animation
:
:
DoFinishNotificationImmediately
(
)
{
mFinishNotificationTask
.
Revoke
(
)
;
if
(
PlayState
(
)
!
=
AnimationPlayState
:
:
Finished
)
{
return
;
}
MaybeResolveFinishedPromise
(
)
;
DispatchPlaybackEvent
(
NS_LITERAL_STRING
(
"
finish
"
)
)
;
}
void
Animation
:
:
DispatchPlaybackEvent
(
const
nsAString
&
aName
)
{
AnimationPlaybackEventInit
init
;
if
(
aName
.
EqualsLiteral
(
"
finish
"
)
)
{
init
.
mCurrentTime
=
GetCurrentTimeAsDouble
(
)
;
}
if
(
mTimeline
)
{
init
.
mTimelineTime
=
mTimeline
-
>
GetCurrentTimeAsDouble
(
)
;
}
RefPtr
<
AnimationPlaybackEvent
>
event
=
AnimationPlaybackEvent
:
:
Constructor
(
this
aName
init
)
;
event
-
>
SetTrusted
(
true
)
;
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
this
event
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
bool
Animation
:
:
IsRunningOnCompositor
(
)
const
{
return
mEffect
&
&
mEffect
-
>
IsRunningOnCompositor
(
)
;
}
}
}
