#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectBinding
.
h
"
#
include
"
mozilla
/
dom
/
PropertyIndexedKeyframesBinding
.
h
"
#
include
"
mozilla
/
AnimationUtils
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
Layers
.
h
"
#
include
"
nsCSSParser
.
h
"
#
include
"
nsCSSPropertySet
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
static
void
GetComputedTimingDictionary
(
const
ComputedTiming
&
aComputedTiming
const
Nullable
<
TimeDuration
>
&
aLocalTime
const
TimingParams
&
aTiming
dom
:
:
ComputedTimingProperties
&
aRetVal
)
{
aRetVal
.
mDelay
=
aTiming
.
mDelay
.
ToMilliseconds
(
)
;
aRetVal
.
mFill
=
aComputedTiming
.
mFill
;
aRetVal
.
mIterations
=
aComputedTiming
.
mIterations
;
aRetVal
.
mDuration
.
SetAsUnrestrictedDouble
(
)
=
aComputedTiming
.
mDuration
.
ToMilliseconds
(
)
;
aRetVal
.
mDirection
=
aTiming
.
mDirection
;
aRetVal
.
mActiveDuration
=
aComputedTiming
.
mActiveDuration
.
ToMilliseconds
(
)
;
aRetVal
.
mEndTime
=
std
:
:
max
(
aRetVal
.
mDelay
+
aRetVal
.
mActiveDuration
+
aRetVal
.
mEndDelay
0
.
0
)
;
aRetVal
.
mLocalTime
=
AnimationUtils
:
:
TimeDurationToDouble
(
aLocalTime
)
;
aRetVal
.
mProgress
=
aComputedTiming
.
mProgress
;
if
(
!
aRetVal
.
mProgress
.
IsNull
(
)
)
{
double
iteration
=
aComputedTiming
.
mCurrentIteration
=
=
UINT64_MAX
?
PositiveInfinity
<
double
>
(
)
:
static_cast
<
double
>
(
aComputedTiming
.
mCurrentIteration
)
;
aRetVal
.
mCurrentIteration
.
SetValue
(
iteration
)
;
}
}
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
KeyframeEffectReadOnly
AnimationEffectReadOnly
mTarget
mAnimation
)
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
KeyframeEffectReadOnly
AnimationEffectReadOnly
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
KeyframeEffectReadOnly
)
NS_INTERFACE_MAP_END_INHERITING
(
AnimationEffectReadOnly
)
NS_IMPL_ADDREF_INHERITED
(
KeyframeEffectReadOnly
AnimationEffectReadOnly
)
NS_IMPL_RELEASE_INHERITED
(
KeyframeEffectReadOnly
AnimationEffectReadOnly
)
KeyframeEffectReadOnly
:
:
KeyframeEffectReadOnly
(
nsIDocument
*
aDocument
Element
*
aTarget
CSSPseudoElementType
aPseudoType
const
TimingParams
&
aTiming
)
:
KeyframeEffectReadOnly
(
aDocument
aTarget
aPseudoType
new
AnimationEffectTimingReadOnly
(
aTiming
)
)
{
}
KeyframeEffectReadOnly
:
:
KeyframeEffectReadOnly
(
nsIDocument
*
aDocument
Element
*
aTarget
CSSPseudoElementType
aPseudoType
AnimationEffectTimingReadOnly
*
aTiming
)
:
AnimationEffectReadOnly
(
aDocument
)
mTarget
(
aTarget
)
mTiming
(
*
aTiming
)
mPseudoType
(
aPseudoType
)
mInEffectOnLastAnimationTimingUpdate
(
false
)
{
MOZ_ASSERT
(
aTiming
)
;
MOZ_ASSERT
(
aTarget
"
null
animation
target
is
not
yet
supported
"
)
;
}
JSObject
*
KeyframeEffectReadOnly
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
KeyframeEffectReadOnlyBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
IterationCompositeOperation
KeyframeEffectReadOnly
:
:
IterationComposite
(
)
const
{
return
IterationCompositeOperation
:
:
Replace
;
}
CompositeOperation
KeyframeEffectReadOnly
:
:
Composite
(
)
const
{
return
CompositeOperation
:
:
Replace
;
}
already_AddRefed
<
AnimationEffectTimingReadOnly
>
KeyframeEffectReadOnly
:
:
Timing
(
)
const
{
RefPtr
<
AnimationEffectTimingReadOnly
>
temp
(
mTiming
)
;
return
temp
.
forget
(
)
;
}
void
KeyframeEffectReadOnly
:
:
SetSpecifiedTiming
(
const
TimingParams
&
aTiming
)
{
if
(
mTiming
-
>
AsTimingParams
(
)
=
=
aTiming
)
{
return
;
}
mTiming
-
>
SetTimingParams
(
aTiming
)
;
if
(
mAnimation
)
{
mAnimation
-
>
NotifyEffectTimingUpdated
(
)
;
}
}
void
KeyframeEffectReadOnly
:
:
NotifyAnimationTimingUpdated
(
)
{
UpdateTargetRegistration
(
)
;
bool
isRelevant
=
mAnimation
&
&
mAnimation
-
>
IsRelevant
(
)
;
if
(
!
isRelevant
)
{
ResetIsRunningOnCompositor
(
)
;
}
bool
inEffect
=
IsInEffect
(
)
;
if
(
inEffect
!
=
mInEffectOnLastAnimationTimingUpdate
)
{
if
(
mTarget
)
{
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
mTarget
mPseudoType
)
;
if
(
effectSet
)
{
effectSet
-
>
MarkCascadeNeedsUpdate
(
)
;
}
}
mInEffectOnLastAnimationTimingUpdate
=
inEffect
;
}
if
(
mAnimation
&
&
GetComputedTiming
(
)
.
mProgress
!
=
mProgressOnLastCompose
)
{
EffectCompositor
:
:
RestyleType
restyleType
=
CanThrottle
(
)
?
EffectCompositor
:
:
RestyleType
:
:
Throttled
:
EffectCompositor
:
:
RestyleType
:
:
Standard
;
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
presContext
-
>
EffectCompositor
(
)
-
>
RequestRestyle
(
mTarget
mPseudoType
restyleType
mAnimation
-
>
CascadeLevel
(
)
)
;
}
if
(
!
isRelevant
)
{
mProgressOnLastCompose
.
SetNull
(
)
;
}
}
}
Nullable
<
TimeDuration
>
KeyframeEffectReadOnly
:
:
GetLocalTime
(
)
const
{
Nullable
<
TimeDuration
>
result
;
if
(
mAnimation
)
{
result
=
mAnimation
-
>
GetCurrentTime
(
)
;
}
return
result
;
}
void
KeyframeEffectReadOnly
:
:
GetComputedTimingAsDict
(
ComputedTimingProperties
&
aRetVal
)
const
{
const
Nullable
<
TimeDuration
>
currentTime
=
GetLocalTime
(
)
;
GetComputedTimingDictionary
(
GetComputedTimingAt
(
currentTime
SpecifiedTiming
(
)
)
currentTime
SpecifiedTiming
(
)
aRetVal
)
;
}
ComputedTiming
KeyframeEffectReadOnly
:
:
GetComputedTimingAt
(
const
Nullable
<
TimeDuration
>
&
aLocalTime
const
TimingParams
&
aTiming
)
{
const
StickyTimeDuration
zeroDuration
;
ComputedTiming
result
;
if
(
aTiming
.
mDuration
.
IsUnrestrictedDouble
(
)
)
{
double
durationMs
=
aTiming
.
mDuration
.
GetAsUnrestrictedDouble
(
)
;
if
(
!
IsNaN
(
durationMs
)
&
&
durationMs
>
=
0
.
0f
)
{
result
.
mDuration
=
StickyTimeDuration
:
:
FromMilliseconds
(
durationMs
)
;
}
}
result
.
mIterations
=
IsNaN
(
aTiming
.
mIterations
)
|
|
aTiming
.
mIterations
<
0
.
0f
?
1
.
0f
:
aTiming
.
mIterations
;
result
.
mActiveDuration
=
ActiveDuration
(
result
.
mDuration
result
.
mIterations
)
;
result
.
mFill
=
aTiming
.
mFill
=
=
dom
:
:
FillMode
:
:
Auto
?
dom
:
:
FillMode
:
:
None
:
aTiming
.
mFill
;
if
(
aLocalTime
.
IsNull
(
)
)
{
return
result
;
}
const
TimeDuration
&
localTime
=
aLocalTime
.
Value
(
)
;
bool
isEndOfFinalIteration
=
false
;
StickyTimeDuration
activeTime
;
if
(
localTime
>
=
aTiming
.
mDelay
+
result
.
mActiveDuration
)
{
result
.
mPhase
=
ComputedTiming
:
:
AnimationPhase
:
:
After
;
if
(
!
result
.
FillsForwards
(
)
)
{
result
.
mProgress
.
SetNull
(
)
;
return
result
;
}
activeTime
=
result
.
mActiveDuration
;
isEndOfFinalIteration
=
result
.
mIterations
!
=
0
.
0
&
&
result
.
mIterations
=
=
floor
(
result
.
mIterations
)
;
}
else
if
(
localTime
<
aTiming
.
mDelay
)
{
result
.
mPhase
=
ComputedTiming
:
:
AnimationPhase
:
:
Before
;
if
(
!
result
.
FillsBackwards
(
)
)
{
result
.
mProgress
.
SetNull
(
)
;
return
result
;
}
}
else
{
MOZ_ASSERT
(
result
.
mActiveDuration
!
=
zeroDuration
"
How
can
we
be
in
the
middle
of
a
zero
-
duration
interval
?
"
)
;
result
.
mPhase
=
ComputedTiming
:
:
AnimationPhase
:
:
Active
;
activeTime
=
localTime
-
aTiming
.
mDelay
;
}
StickyTimeDuration
iterationTime
;
if
(
result
.
mDuration
!
=
zeroDuration
)
{
iterationTime
=
isEndOfFinalIteration
?
result
.
mDuration
:
activeTime
%
result
.
mDuration
;
}
if
(
isEndOfFinalIteration
)
{
result
.
mCurrentIteration
=
IsInfinite
(
result
.
mIterations
)
?
UINT64_MAX
:
static_cast
<
uint64_t
>
(
result
.
mIterations
)
-
1
;
}
else
if
(
activeTime
=
=
zeroDuration
)
{
result
.
mCurrentIteration
=
result
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
After
?
static_cast
<
uint64_t
>
(
result
.
mIterations
)
:
0
;
}
else
{
result
.
mCurrentIteration
=
static_cast
<
uint64_t
>
(
activeTime
/
result
.
mDuration
)
;
}
if
(
result
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Before
)
{
result
.
mProgress
.
SetValue
(
0
.
0
)
;
}
else
if
(
result
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
After
)
{
double
progress
=
isEndOfFinalIteration
?
1
.
0
:
fmod
(
result
.
mIterations
1
.
0
)
;
result
.
mProgress
.
SetValue
(
progress
)
;
}
else
{
MOZ_ASSERT
(
result
.
mDuration
!
=
zeroDuration
"
In
the
active
phase
of
a
zero
-
duration
animation
?
"
)
;
double
progress
=
result
.
mDuration
=
=
StickyTimeDuration
:
:
Forever
(
)
?
0
.
0
:
iterationTime
/
result
.
mDuration
;
result
.
mProgress
.
SetValue
(
progress
)
;
}
bool
thisIterationReverse
=
false
;
switch
(
aTiming
.
mDirection
)
{
case
PlaybackDirection
:
:
Normal
:
thisIterationReverse
=
false
;
break
;
case
PlaybackDirection
:
:
Reverse
:
thisIterationReverse
=
true
;
break
;
case
PlaybackDirection
:
:
Alternate
:
thisIterationReverse
=
(
result
.
mCurrentIteration
&
1
)
=
=
1
;
break
;
case
PlaybackDirection
:
:
Alternate_reverse
:
thisIterationReverse
=
(
result
.
mCurrentIteration
&
1
)
=
=
0
;
break
;
default
:
MOZ_ASSERT
(
true
"
Unknown
PlaybackDirection
type
"
)
;
}
if
(
thisIterationReverse
)
{
result
.
mProgress
.
SetValue
(
1
.
0
-
result
.
mProgress
.
Value
(
)
)
;
}
if
(
aTiming
.
mFunction
)
{
result
.
mProgress
.
SetValue
(
aTiming
.
mFunction
-
>
GetValue
(
result
.
mProgress
.
Value
(
)
)
)
;
}
return
result
;
}
StickyTimeDuration
KeyframeEffectReadOnly
:
:
ActiveDuration
(
const
StickyTimeDuration
&
aIterationDuration
double
aIterationCount
)
{
if
(
IsInfinite
(
aIterationCount
)
)
{
const
StickyTimeDuration
zeroDuration
;
return
aIterationDuration
=
=
zeroDuration
?
zeroDuration
:
StickyTimeDuration
:
:
Forever
(
)
;
}
return
aIterationDuration
.
MultDouble
(
aIterationCount
)
;
}
bool
KeyframeEffectReadOnly
:
:
IsInPlay
(
)
const
{
if
(
!
mAnimation
|
|
mAnimation
-
>
PlayState
(
)
=
=
AnimationPlayState
:
:
Finished
)
{
return
false
;
}
return
GetComputedTiming
(
)
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Active
;
}
bool
KeyframeEffectReadOnly
:
:
IsCurrent
(
)
const
{
if
(
!
mAnimation
|
|
mAnimation
-
>
PlayState
(
)
=
=
AnimationPlayState
:
:
Finished
)
{
return
false
;
}
ComputedTiming
computedTiming
=
GetComputedTiming
(
)
;
return
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Before
|
|
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Active
;
}
bool
KeyframeEffectReadOnly
:
:
IsInEffect
(
)
const
{
ComputedTiming
computedTiming
=
GetComputedTiming
(
)
;
return
!
computedTiming
.
mProgress
.
IsNull
(
)
;
}
void
KeyframeEffectReadOnly
:
:
SetAnimation
(
Animation
*
aAnimation
)
{
mAnimation
=
aAnimation
;
NotifyAnimationTimingUpdated
(
)
;
}
const
AnimationProperty
*
KeyframeEffectReadOnly
:
:
GetAnimationOfProperty
(
nsCSSProperty
aProperty
)
const
{
for
(
size_t
propIdx
=
0
propEnd
=
mProperties
.
Length
(
)
;
propIdx
!
=
propEnd
;
+
+
propIdx
)
{
if
(
aProperty
=
=
mProperties
[
propIdx
]
.
mProperty
)
{
const
AnimationProperty
*
result
=
&
mProperties
[
propIdx
]
;
if
(
!
result
-
>
mWinsInCascade
)
{
result
=
nullptr
;
}
return
result
;
}
}
return
nullptr
;
}
bool
KeyframeEffectReadOnly
:
:
HasAnimationOfProperties
(
const
nsCSSProperty
*
aProperties
size_t
aPropertyCount
)
const
{
for
(
size_t
i
=
0
;
i
<
aPropertyCount
;
i
+
+
)
{
if
(
HasAnimationOfProperty
(
aProperties
[
i
]
)
)
{
return
true
;
}
}
return
false
;
}
void
KeyframeEffectReadOnly
:
:
CopyPropertiesFrom
(
const
KeyframeEffectReadOnly
&
aOther
)
{
nsCSSPropertySet
winningInCascadeProperties
;
nsCSSPropertySet
runningOnCompositorProperties
;
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
if
(
property
.
mWinsInCascade
)
{
winningInCascadeProperties
.
AddProperty
(
property
.
mProperty
)
;
}
if
(
property
.
mIsRunningOnCompositor
)
{
runningOnCompositorProperties
.
AddProperty
(
property
.
mProperty
)
;
}
}
mProperties
=
aOther
.
mProperties
;
for
(
AnimationProperty
&
property
:
mProperties
)
{
property
.
mWinsInCascade
=
winningInCascadeProperties
.
HasProperty
(
property
.
mProperty
)
;
property
.
mIsRunningOnCompositor
=
runningOnCompositorProperties
.
HasProperty
(
property
.
mProperty
)
;
}
}
void
KeyframeEffectReadOnly
:
:
ComposeStyle
(
RefPtr
<
AnimValuesStyleRule
>
&
aStyleRule
nsCSSPropertySet
&
aSetProperties
)
{
ComputedTiming
computedTiming
=
GetComputedTiming
(
)
;
mProgressOnLastCompose
=
computedTiming
.
mProgress
;
if
(
computedTiming
.
mProgress
.
IsNull
(
)
)
{
return
;
}
MOZ_ASSERT
(
!
computedTiming
.
mProgress
.
IsNull
(
)
&
&
0
.
0
<
=
computedTiming
.
mProgress
.
Value
(
)
&
&
computedTiming
.
mProgress
.
Value
(
)
<
=
1
.
0
"
iteration
progress
should
be
in
[
0
-
1
]
"
)
;
for
(
size_t
propIdx
=
0
propEnd
=
mProperties
.
Length
(
)
;
propIdx
!
=
propEnd
;
+
+
propIdx
)
{
const
AnimationProperty
&
prop
=
mProperties
[
propIdx
]
;
MOZ_ASSERT
(
prop
.
mSegments
[
0
]
.
mFromKey
=
=
0
.
0
"
incorrect
first
from
key
"
)
;
MOZ_ASSERT
(
prop
.
mSegments
[
prop
.
mSegments
.
Length
(
)
-
1
]
.
mToKey
=
=
1
.
0
"
incorrect
last
to
key
"
)
;
if
(
aSetProperties
.
HasProperty
(
prop
.
mProperty
)
)
{
continue
;
}
if
(
!
prop
.
mWinsInCascade
)
{
continue
;
}
aSetProperties
.
AddProperty
(
prop
.
mProperty
)
;
MOZ_ASSERT
(
prop
.
mSegments
.
Length
(
)
>
0
"
property
should
not
be
in
animations
if
it
has
no
segments
"
)
;
const
AnimationPropertySegment
*
segment
=
prop
.
mSegments
.
Elements
(
)
*
segmentEnd
=
segment
+
prop
.
mSegments
.
Length
(
)
;
while
(
segment
-
>
mToKey
<
computedTiming
.
mProgress
.
Value
(
)
)
{
MOZ_ASSERT
(
segment
-
>
mFromKey
<
segment
-
>
mToKey
"
incorrect
keys
"
)
;
+
+
segment
;
if
(
segment
=
=
segmentEnd
)
{
MOZ_ASSERT_UNREACHABLE
(
"
incorrect
iteration
progress
"
)
;
break
;
}
MOZ_ASSERT
(
segment
-
>
mFromKey
=
=
(
segment
-
1
)
-
>
mToKey
"
incorrect
keys
"
)
;
}
if
(
segment
=
=
segmentEnd
)
{
continue
;
}
MOZ_ASSERT
(
segment
-
>
mFromKey
<
segment
-
>
mToKey
"
incorrect
keys
"
)
;
MOZ_ASSERT
(
segment
>
=
prop
.
mSegments
.
Elements
(
)
&
&
size_t
(
segment
-
prop
.
mSegments
.
Elements
(
)
)
<
prop
.
mSegments
.
Length
(
)
"
out
of
array
bounds
"
)
;
if
(
!
aStyleRule
)
{
aStyleRule
=
new
AnimValuesStyleRule
(
)
;
}
double
positionInSegment
=
(
computedTiming
.
mProgress
.
Value
(
)
-
segment
-
>
mFromKey
)
/
(
segment
-
>
mToKey
-
segment
-
>
mFromKey
)
;
double
valuePosition
=
ComputedTimingFunction
:
:
GetPortion
(
segment
-
>
mTimingFunction
positionInSegment
)
;
StyleAnimationValue
*
val
=
aStyleRule
-
>
AddEmptyValue
(
prop
.
mProperty
)
;
#
ifdef
DEBUG
bool
result
=
#
endif
StyleAnimationValue
:
:
Interpolate
(
prop
.
mProperty
segment
-
>
mFromValue
segment
-
>
mToValue
valuePosition
*
val
)
;
MOZ_ASSERT
(
result
"
interpolate
must
succeed
now
"
)
;
}
}
bool
KeyframeEffectReadOnly
:
:
IsRunningOnCompositor
(
)
const
{
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
if
(
property
.
mIsRunningOnCompositor
)
{
return
true
;
}
}
return
false
;
}
void
KeyframeEffectReadOnly
:
:
SetIsRunningOnCompositor
(
nsCSSProperty
aProperty
bool
aIsRunning
)
{
MOZ_ASSERT
(
nsCSSProps
:
:
PropHasFlags
(
aProperty
CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR
)
"
Property
being
animated
on
compositor
is
a
recognized
"
"
compositor
-
animatable
property
"
)
;
for
(
AnimationProperty
&
property
:
mProperties
)
{
if
(
property
.
mProperty
=
=
aProperty
)
{
property
.
mIsRunningOnCompositor
=
aIsRunning
;
return
;
}
}
}
KeyframeEffectReadOnly
:
:
~
KeyframeEffectReadOnly
(
)
{
}
template
<
class
KeyframeEffectType
>
already_AddRefed
<
KeyframeEffectType
>
KeyframeEffectReadOnly
:
:
ConstructKeyframeEffect
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aFrames
const
TimingParams
&
aTiming
ErrorResult
&
aRv
)
{
if
(
aTarget
.
IsNull
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_ANIM_NO_TARGET_ERR
)
;
return
nullptr
;
}
const
ElementOrCSSPseudoElement
&
target
=
aTarget
.
Value
(
)
;
MOZ_ASSERT
(
target
.
IsElement
(
)
|
|
target
.
IsCSSPseudoElement
(
)
"
Uninitialized
target
"
)
;
RefPtr
<
Element
>
targetElement
;
CSSPseudoElementType
pseudoType
=
CSSPseudoElementType
:
:
NotPseudo
;
if
(
target
.
IsElement
(
)
)
{
targetElement
=
&
target
.
GetAsElement
(
)
;
}
else
{
targetElement
=
target
.
GetAsCSSPseudoElement
(
)
.
ParentElement
(
)
;
pseudoType
=
target
.
GetAsCSSPseudoElement
(
)
.
GetType
(
)
;
}
if
(
!
targetElement
-
>
GetComposedDoc
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_ANIM_TARGET_NOT_IN_DOC_ERR
)
;
return
nullptr
;
}
InfallibleTArray
<
AnimationProperty
>
animationProperties
;
BuildAnimationPropertyList
(
aGlobal
.
Context
(
)
targetElement
pseudoType
aFrames
animationProperties
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
KeyframeEffectType
>
effect
=
new
KeyframeEffectType
(
targetElement
-
>
OwnerDoc
(
)
targetElement
pseudoType
aTiming
)
;
effect
-
>
mProperties
=
Move
(
animationProperties
)
;
return
effect
.
forget
(
)
;
}
template
already_AddRefed
<
KeyframeEffectReadOnly
>
KeyframeEffectReadOnly
:
:
ConstructKeyframeEffect
<
>
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aFrames
const
TimingParams
&
aTiming
ErrorResult
&
aRv
)
;
template
already_AddRefed
<
KeyframeEffect
>
KeyframeEffectReadOnly
:
:
ConstructKeyframeEffect
<
>
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aFrames
const
TimingParams
&
aTiming
ErrorResult
&
aRv
)
;
void
KeyframeEffectReadOnly
:
:
ResetIsRunningOnCompositor
(
)
{
for
(
AnimationProperty
&
property
:
mProperties
)
{
property
.
mIsRunningOnCompositor
=
false
;
}
}
void
KeyframeEffectReadOnly
:
:
UpdateTargetRegistration
(
)
{
if
(
!
mTarget
)
{
return
;
}
bool
isRelevant
=
mAnimation
&
&
mAnimation
-
>
IsRelevant
(
)
;
MOZ_ASSERT
(
isRelevant
=
=
IsCurrent
(
)
|
|
IsInEffect
(
)
"
Out
of
date
Animation
:
:
IsRelevant
value
"
)
;
if
(
isRelevant
)
{
EffectSet
*
effectSet
=
EffectSet
:
:
GetOrCreateEffectSet
(
mTarget
mPseudoType
)
;
effectSet
-
>
AddEffect
(
*
this
)
;
}
else
{
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
mTarget
mPseudoType
)
;
if
(
effectSet
)
{
effectSet
-
>
RemoveEffect
(
*
this
)
;
if
(
effectSet
-
>
IsEmpty
(
)
)
{
EffectSet
:
:
DestroyEffectSet
(
mTarget
mPseudoType
)
;
}
}
}
}
#
ifdef
DEBUG
void
DumpAnimationProperties
(
nsTArray
<
AnimationProperty
>
&
aAnimationProperties
)
{
for
(
auto
&
p
:
aAnimationProperties
)
{
printf
(
"
%
s
\
n
"
nsCSSProps
:
:
GetStringValue
(
p
.
mProperty
)
.
get
(
)
)
;
for
(
auto
&
s
:
p
.
mSegments
)
{
nsString
fromValue
toValue
;
StyleAnimationValue
:
:
UncomputeValue
(
p
.
mProperty
s
.
mFromValue
fromValue
)
;
StyleAnimationValue
:
:
UncomputeValue
(
p
.
mProperty
s
.
mToValue
toValue
)
;
printf
(
"
%
f
.
.
%
f
:
%
s
.
.
%
s
\
n
"
s
.
mFromKey
s
.
mToKey
NS_ConvertUTF16toUTF8
(
fromValue
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
toValue
)
.
get
(
)
)
;
}
}
}
#
endif
struct
KeyframeValue
{
nsCSSProperty
mProperty
;
StyleAnimationValue
mValue
;
}
;
enum
class
ValuePosition
{
First
Left
Right
Last
}
;
struct
OrderedKeyframeValueEntry
:
KeyframeValue
{
float
mOffset
;
const
Maybe
<
ComputedTimingFunction
>
*
mTimingFunction
;
ValuePosition
mPosition
;
bool
SameKeyframe
(
const
OrderedKeyframeValueEntry
&
aOther
)
const
{
return
mOffset
=
=
aOther
.
mOffset
&
&
!
!
mTimingFunction
=
=
!
!
aOther
.
mTimingFunction
&
&
(
!
mTimingFunction
|
|
*
mTimingFunction
=
=
*
aOther
.
mTimingFunction
)
&
&
mPosition
=
=
aOther
.
mPosition
;
}
struct
ForKeyframeGenerationComparator
{
static
bool
Equals
(
const
OrderedKeyframeValueEntry
&
aLhs
const
OrderedKeyframeValueEntry
&
aRhs
)
{
return
aLhs
.
SameKeyframe
(
aRhs
)
&
&
aLhs
.
mProperty
=
=
aRhs
.
mProperty
;
}
static
bool
LessThan
(
const
OrderedKeyframeValueEntry
&
aLhs
const
OrderedKeyframeValueEntry
&
aRhs
)
{
if
(
aLhs
.
mOffset
!
=
aRhs
.
mOffset
)
{
return
aLhs
.
mOffset
<
aRhs
.
mOffset
;
}
if
(
aLhs
.
mPosition
!
=
aRhs
.
mPosition
)
{
return
aLhs
.
mPosition
<
aRhs
.
mPosition
;
}
if
(
aLhs
.
mTimingFunction
)
{
if
(
aRhs
.
mTimingFunction
)
{
int32_t
order
=
ComputedTimingFunction
:
:
Compare
(
*
aLhs
.
mTimingFunction
*
aRhs
.
mTimingFunction
)
;
if
(
order
!
=
0
)
{
return
order
<
0
;
}
}
else
{
return
true
;
}
}
else
{
if
(
aRhs
.
mTimingFunction
)
{
return
false
;
}
}
return
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aLhs
.
mProperty
)
<
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aRhs
.
mProperty
)
;
}
}
;
}
;
struct
KeyframeValueEntry
:
KeyframeValue
{
float
mOffset
;
Maybe
<
ComputedTimingFunction
>
mTimingFunction
;
struct
PropertyOffsetComparator
{
static
bool
Equals
(
const
KeyframeValueEntry
&
aLhs
const
KeyframeValueEntry
&
aRhs
)
{
return
aLhs
.
mProperty
=
=
aRhs
.
mProperty
&
&
aLhs
.
mOffset
=
=
aRhs
.
mOffset
;
}
static
bool
LessThan
(
const
KeyframeValueEntry
&
aLhs
const
KeyframeValueEntry
&
aRhs
)
{
int32_t
order
=
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aLhs
.
mProperty
)
-
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aRhs
.
mProperty
)
;
if
(
order
!
=
0
)
{
return
order
<
0
;
}
return
aLhs
.
mOffset
<
aRhs
.
mOffset
;
}
}
;
}
;
struct
PropertyValuesPair
{
nsCSSProperty
mProperty
;
nsTArray
<
nsString
>
mValues
;
class
PropertyPriorityComparator
{
public
:
PropertyPriorityComparator
(
)
:
mSubpropertyCountInitialized
(
false
)
{
}
bool
Equals
(
const
PropertyValuesPair
&
aLhs
const
PropertyValuesPair
&
aRhs
)
const
{
return
aLhs
.
mProperty
=
=
aRhs
.
mProperty
;
}
bool
LessThan
(
const
PropertyValuesPair
&
aLhs
const
PropertyValuesPair
&
aRhs
)
const
{
bool
isShorthandLhs
=
nsCSSProps
:
:
IsShorthand
(
aLhs
.
mProperty
)
;
bool
isShorthandRhs
=
nsCSSProps
:
:
IsShorthand
(
aRhs
.
mProperty
)
;
if
(
isShorthandLhs
)
{
if
(
isShorthandRhs
)
{
uint32_t
subpropCountLhs
=
SubpropertyCount
(
aLhs
.
mProperty
)
;
uint32_t
subpropCountRhs
=
SubpropertyCount
(
aRhs
.
mProperty
)
;
if
(
subpropCountLhs
!
=
subpropCountRhs
)
{
return
subpropCountLhs
<
subpropCountRhs
;
}
}
else
{
return
false
;
}
}
else
{
if
(
isShorthandRhs
)
{
return
true
;
}
}
return
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aLhs
.
mProperty
)
<
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aRhs
.
mProperty
)
;
}
uint32_t
SubpropertyCount
(
nsCSSProperty
aProperty
)
const
{
if
(
!
mSubpropertyCountInitialized
)
{
PodZero
(
&
mSubpropertyCount
)
;
mSubpropertyCountInitialized
=
true
;
}
if
(
mSubpropertyCount
[
aProperty
]
=
=
0
)
{
uint32_t
count
=
0
;
CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES
(
p
aProperty
nsCSSProps
:
:
eEnabledForAllContent
)
{
+
+
count
;
}
mSubpropertyCount
[
aProperty
]
=
count
;
}
return
mSubpropertyCount
[
aProperty
]
;
}
private
:
mutable
RangedArray
<
uint32_t
eCSSProperty_COUNT_no_shorthands
eCSSProperty_COUNT
-
eCSSProperty_COUNT_no_shorthands
>
mSubpropertyCount
;
mutable
bool
mSubpropertyCountInitialized
;
}
;
}
;
struct
OffsetIndexedKeyframe
{
binding_detail
:
:
FastKeyframe
mKeyframeDict
;
nsTArray
<
PropertyValuesPair
>
mPropertyValuePairs
;
}
;
struct
AdditionalProperty
{
nsCSSProperty
mProperty
;
size_t
mJsidIndex
;
struct
PropertyComparator
{
bool
Equals
(
const
AdditionalProperty
&
aLhs
const
AdditionalProperty
&
aRhs
)
const
{
return
aLhs
.
mProperty
=
=
aRhs
.
mProperty
;
}
bool
LessThan
(
const
AdditionalProperty
&
aLhs
const
AdditionalProperty
&
aRhs
)
const
{
return
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aLhs
.
mProperty
)
<
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aRhs
.
mProperty
)
;
}
}
;
}
;
static
bool
AppendValueAsString
(
JSContext
*
aCx
nsTArray
<
nsString
>
&
aValues
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
return
ConvertJSValueToString
(
aCx
aValue
eStringify
eStringify
*
aValues
.
AppendElement
(
)
)
;
}
enum
class
ListAllowance
{
eDisallow
eAllow
}
;
static
bool
AppendStringOrStringSequenceToArray
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ListAllowance
aAllowLists
nsTArray
<
nsString
>
&
aValues
)
{
if
(
aAllowLists
=
=
ListAllowance
:
:
eAllow
&
&
aValue
.
isObject
(
)
)
{
JS
:
:
ForOfIterator
iter
(
aCx
)
;
if
(
!
iter
.
init
(
aValue
JS
:
:
ForOfIterator
:
:
AllowNonIterable
)
)
{
return
false
;
}
if
(
iter
.
valueIsIterable
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
element
(
aCx
)
;
for
(
;
;
)
{
bool
done
;
if
(
!
iter
.
next
(
&
element
&
done
)
)
{
return
false
;
}
if
(
done
)
{
break
;
}
if
(
!
AppendValueAsString
(
aCx
aValues
element
)
)
{
return
false
;
}
}
return
true
;
}
}
if
(
!
AppendValueAsString
(
aCx
aValues
aValue
)
)
{
return
false
;
}
return
true
;
}
static
bool
GetPropertyValuesPairs
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
ListAllowance
aAllowLists
nsTArray
<
PropertyValuesPair
>
&
aResult
)
{
nsTArray
<
AdditionalProperty
>
properties
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
ids
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
aObject
&
ids
)
)
{
return
false
;
}
for
(
size_t
i
=
0
n
=
ids
.
length
(
)
;
i
<
n
;
i
+
+
)
{
nsAutoJSString
propName
;
if
(
!
propName
.
init
(
aCx
ids
[
i
]
)
)
{
return
false
;
}
nsCSSProperty
property
=
nsCSSProps
:
:
LookupPropertyByIDLName
(
propName
nsCSSProps
:
:
eEnabledForAllContent
)
;
if
(
property
!
=
eCSSProperty_UNKNOWN
&
&
(
nsCSSProps
:
:
IsShorthand
(
property
)
|
|
nsCSSProps
:
:
kAnimTypeTable
[
property
]
!
=
eStyleAnimType_None
)
)
{
AdditionalProperty
*
p
=
properties
.
AppendElement
(
)
;
p
-
>
mProperty
=
property
;
p
-
>
mJsidIndex
=
i
;
}
}
properties
.
Sort
(
AdditionalProperty
:
:
PropertyComparator
(
)
)
;
for
(
AdditionalProperty
&
p
:
properties
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
JS_GetPropertyById
(
aCx
aObject
ids
[
p
.
mJsidIndex
]
&
value
)
)
{
return
false
;
}
PropertyValuesPair
*
pair
=
aResult
.
AppendElement
(
)
;
pair
-
>
mProperty
=
p
.
mProperty
;
if
(
!
AppendStringOrStringSequenceToArray
(
aCx
value
aAllowLists
pair
-
>
mValues
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
ConvertKeyframeSequence
(
JSContext
*
aCx
JS
:
:
ForOfIterator
&
aIterator
nsTArray
<
OffsetIndexedKeyframe
>
&
aResult
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
for
(
;
;
)
{
bool
done
;
if
(
!
aIterator
.
next
(
&
value
&
done
)
)
{
return
false
;
}
if
(
done
)
{
break
;
}
if
(
!
value
.
isObject
(
)
&
&
!
value
.
isNullOrUndefined
(
)
)
{
ThrowErrorMessage
(
aCx
MSG_NOT_OBJECT
"
Element
of
sequence
<
Keyframes
>
argument
"
)
;
return
false
;
}
OffsetIndexedKeyframe
*
keyframe
=
aResult
.
AppendElement
(
)
;
if
(
!
keyframe
-
>
mKeyframeDict
.
Init
(
aCx
value
"
Element
of
sequence
<
Keyframes
>
argument
"
)
)
{
return
false
;
}
if
(
value
.
isObject
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
object
(
aCx
&
value
.
toObject
(
)
)
;
if
(
!
GetPropertyValuesPairs
(
aCx
object
ListAllowance
:
:
eDisallow
keyframe
-
>
mPropertyValuePairs
)
)
{
return
false
;
}
}
}
return
true
;
}
static
bool
HasValidOffsets
(
const
nsTArray
<
OffsetIndexedKeyframe
>
&
aKeyframes
)
{
double
offset
=
0
.
0
;
for
(
const
OffsetIndexedKeyframe
&
keyframe
:
aKeyframes
)
{
if
(
!
keyframe
.
mKeyframeDict
.
mOffset
.
IsNull
(
)
)
{
double
thisOffset
=
keyframe
.
mKeyframeDict
.
mOffset
.
Value
(
)
;
if
(
thisOffset
<
offset
|
|
thisOffset
>
1
.
0f
)
{
return
false
;
}
offset
=
thisOffset
;
}
}
return
true
;
}
static
void
ApplyDistributeSpacing
(
nsTArray
<
OffsetIndexedKeyframe
>
&
aKeyframes
)
{
if
(
aKeyframes
.
LastElement
(
)
.
mKeyframeDict
.
mOffset
.
IsNull
(
)
)
{
aKeyframes
.
LastElement
(
)
.
mKeyframeDict
.
mOffset
.
SetValue
(
1
.
0
)
;
}
if
(
aKeyframes
[
0
]
.
mKeyframeDict
.
mOffset
.
IsNull
(
)
)
{
aKeyframes
[
0
]
.
mKeyframeDict
.
mOffset
.
SetValue
(
0
.
0
)
;
}
size_t
i
=
0
;
while
(
i
<
aKeyframes
.
Length
(
)
-
1
)
{
MOZ_ASSERT
(
!
aKeyframes
[
i
]
.
mKeyframeDict
.
mOffset
.
IsNull
(
)
)
;
double
start
=
aKeyframes
[
i
]
.
mKeyframeDict
.
mOffset
.
Value
(
)
;
size_t
j
=
i
+
1
;
while
(
aKeyframes
[
j
]
.
mKeyframeDict
.
mOffset
.
IsNull
(
)
)
{
+
+
j
;
}
double
end
=
aKeyframes
[
j
]
.
mKeyframeDict
.
mOffset
.
Value
(
)
;
size_t
n
=
j
-
i
;
for
(
size_t
k
=
1
;
k
<
n
;
+
+
k
)
{
double
offset
=
start
+
double
(
k
)
/
n
*
(
end
-
start
)
;
aKeyframes
[
i
+
k
]
.
mKeyframeDict
.
mOffset
.
SetValue
(
offset
)
;
}
i
=
j
;
}
}
static
void
GenerateValueEntries
(
Element
*
aTarget
CSSPseudoElementType
aPseudoType
nsTArray
<
OffsetIndexedKeyframe
>
&
aKeyframes
nsTArray
<
KeyframeValueEntry
>
&
aResult
ErrorResult
&
aRv
)
{
nsCSSPropertySet
properties
;
nsCSSPropertySet
propertiesWithFromValue
;
nsCSSPropertySet
propertiesWithToValue
;
for
(
OffsetIndexedKeyframe
&
keyframe
:
aKeyframes
)
{
float
offset
=
float
(
keyframe
.
mKeyframeDict
.
mOffset
.
Value
(
)
)
;
Maybe
<
ComputedTimingFunction
>
easing
=
AnimationUtils
:
:
ParseEasing
(
aTarget
keyframe
.
mKeyframeDict
.
mEasing
)
;
keyframe
.
mPropertyValuePairs
.
Sort
(
PropertyValuesPair
:
:
PropertyPriorityComparator
(
)
)
;
nsCSSPropertySet
propertiesOnThisKeyframe
;
for
(
const
PropertyValuesPair
&
pair
:
keyframe
.
mPropertyValuePairs
)
{
MOZ_ASSERT
(
pair
.
mValues
.
Length
(
)
=
=
1
"
ConvertKeyframeSequence
should
have
parsed
single
"
"
DOMString
values
from
the
property
-
values
pairs
"
)
;
nsTArray
<
PropertyStyleAnimationValuePair
>
values
;
if
(
StyleAnimationValue
:
:
ComputeValues
(
pair
.
mProperty
nsCSSProps
:
:
eEnabledForAllContent
aTarget
aPseudoType
pair
.
mValues
[
0
]
false
values
)
)
{
for
(
auto
&
value
:
values
)
{
if
(
propertiesOnThisKeyframe
.
HasProperty
(
value
.
mProperty
)
)
{
continue
;
}
KeyframeValueEntry
*
entry
=
aResult
.
AppendElement
(
)
;
entry
-
>
mOffset
=
offset
;
entry
-
>
mProperty
=
value
.
mProperty
;
entry
-
>
mValue
=
value
.
mValue
;
entry
-
>
mTimingFunction
=
easing
;
if
(
offset
=
=
0
.
0
)
{
propertiesWithFromValue
.
AddProperty
(
value
.
mProperty
)
;
}
else
if
(
offset
=
=
1
.
0
)
{
propertiesWithToValue
.
AddProperty
(
value
.
mProperty
)
;
}
propertiesOnThisKeyframe
.
AddProperty
(
value
.
mProperty
)
;
properties
.
AddProperty
(
value
.
mProperty
)
;
}
}
}
}
if
(
!
propertiesWithFromValue
.
Equals
(
properties
)
|
|
!
propertiesWithToValue
.
Equals
(
properties
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR
)
;
return
;
}
}
static
void
BuildSegmentsFromValueEntries
(
nsTArray
<
KeyframeValueEntry
>
&
aEntries
nsTArray
<
AnimationProperty
>
&
aResult
)
{
if
(
aEntries
.
IsEmpty
(
)
)
{
return
;
}
std
:
:
stable_sort
(
aEntries
.
begin
(
)
aEntries
.
end
(
)
&
KeyframeValueEntry
:
:
PropertyOffsetComparator
:
:
LessThan
)
;
MOZ_ASSERT
(
aEntries
[
0
]
.
mOffset
=
=
0
.
0f
)
;
MOZ_ASSERT
(
aEntries
.
LastElement
(
)
.
mOffset
=
=
1
.
0f
)
;
nsCSSProperty
lastProperty
=
eCSSProperty_UNKNOWN
;
AnimationProperty
*
animationProperty
=
nullptr
;
size_t
i
=
0
n
=
aEntries
.
Length
(
)
;
while
(
i
+
1
<
n
)
{
size_t
j
;
if
(
aEntries
[
i
]
.
mOffset
=
=
0
.
0f
&
&
aEntries
[
i
+
1
]
.
mOffset
=
=
0
.
0f
)
{
MOZ_ASSERT
(
aEntries
[
i
]
.
mProperty
=
=
aEntries
[
i
+
1
]
.
mProperty
)
;
j
=
i
+
1
;
while
(
aEntries
[
j
+
1
]
.
mOffset
=
=
0
.
0f
)
{
MOZ_ASSERT
(
aEntries
[
j
]
.
mProperty
=
=
aEntries
[
j
+
1
]
.
mProperty
)
;
+
+
j
;
}
}
else
if
(
aEntries
[
i
]
.
mOffset
=
=
1
.
0f
)
{
if
(
aEntries
[
i
+
1
]
.
mOffset
=
=
1
.
0f
)
{
MOZ_ASSERT
(
aEntries
[
i
]
.
mProperty
=
=
aEntries
[
i
]
.
mProperty
)
;
j
=
i
+
1
;
while
(
j
+
1
<
n
&
&
aEntries
[
j
+
1
]
.
mOffset
=
=
1
.
0f
)
{
MOZ_ASSERT
(
aEntries
[
j
]
.
mProperty
=
=
aEntries
[
j
+
1
]
.
mProperty
)
;
+
+
j
;
}
}
else
{
MOZ_ASSERT
(
aEntries
[
i
+
1
]
.
mOffset
=
=
0
.
0f
)
;
MOZ_ASSERT
(
aEntries
[
i
]
.
mProperty
!
=
aEntries
[
i
+
1
]
.
mProperty
)
;
+
+
i
;
continue
;
}
}
else
{
while
(
aEntries
[
i
]
.
mOffset
=
=
aEntries
[
i
+
1
]
.
mOffset
&
&
aEntries
[
i
]
.
mProperty
=
=
aEntries
[
i
+
1
]
.
mProperty
)
{
+
+
i
;
}
j
=
i
+
1
;
}
if
(
aEntries
[
i
]
.
mProperty
!
=
lastProperty
)
{
MOZ_ASSERT
(
aEntries
[
i
]
.
mOffset
=
=
0
.
0f
)
;
animationProperty
=
aResult
.
AppendElement
(
)
;
animationProperty
-
>
mProperty
=
aEntries
[
i
]
.
mProperty
;
lastProperty
=
aEntries
[
i
]
.
mProperty
;
}
MOZ_ASSERT
(
animationProperty
"
animationProperty
should
be
valid
pointer
.
"
)
;
AnimationPropertySegment
*
segment
=
animationProperty
-
>
mSegments
.
AppendElement
(
)
;
segment
-
>
mFromKey
=
aEntries
[
i
]
.
mOffset
;
segment
-
>
mToKey
=
aEntries
[
j
]
.
mOffset
;
segment
-
>
mFromValue
=
aEntries
[
i
]
.
mValue
;
segment
-
>
mToValue
=
aEntries
[
j
]
.
mValue
;
segment
-
>
mTimingFunction
=
aEntries
[
i
]
.
mTimingFunction
;
i
=
j
;
}
}
static
void
BuildAnimationPropertyListFromKeyframeSequence
(
JSContext
*
aCx
Element
*
aTarget
CSSPseudoElementType
aPseudoType
JS
:
:
ForOfIterator
&
aIterator
nsTArray
<
AnimationProperty
>
&
aResult
ErrorResult
&
aRv
)
{
AutoTArray
<
OffsetIndexedKeyframe
4
>
keyframes
;
if
(
!
ConvertKeyframeSequence
(
aCx
aIterator
keyframes
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
keyframes
.
IsEmpty
(
)
)
{
return
;
}
if
(
!
HasValidOffsets
(
keyframes
)
)
{
aRv
.
ThrowTypeError
<
MSG_INVALID_KEYFRAME_OFFSETS
>
(
)
;
return
;
}
ApplyDistributeSpacing
(
keyframes
)
;
nsTArray
<
KeyframeValueEntry
>
entries
;
GenerateValueEntries
(
aTarget
aPseudoType
keyframes
entries
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
BuildSegmentsFromValueEntries
(
entries
aResult
)
;
}
static
void
BuildAnimationPropertyListFromPropertyIndexedKeyframes
(
JSContext
*
aCx
Element
*
aTarget
CSSPseudoElementType
aPseudoType
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
InfallibleTArray
<
AnimationProperty
>
&
aResult
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aValue
.
isObject
(
)
)
;
binding_detail
:
:
FastPropertyIndexedKeyframes
keyframes
;
if
(
!
keyframes
.
Init
(
aCx
aValue
"
PropertyIndexedKeyframes
argument
"
false
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
Maybe
<
ComputedTimingFunction
>
easing
=
AnimationUtils
:
:
ParseEasing
(
aTarget
keyframes
.
mEasing
)
;
JS
:
:
Rooted
<
JSObject
*
>
object
(
aCx
&
aValue
.
toObject
(
)
)
;
nsTArray
<
PropertyValuesPair
>
propertyValuesPairs
;
if
(
!
GetPropertyValuesPairs
(
aCx
object
ListAllowance
:
:
eAllow
propertyValuesPairs
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsCSSPropertySet
properties
;
for
(
const
PropertyValuesPair
&
pair
:
propertyValuesPairs
)
{
size_t
count
=
pair
.
mValues
.
Length
(
)
;
if
(
count
=
=
0
)
{
continue
;
}
if
(
count
=
=
1
)
{
aRv
.
Throw
(
NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR
)
;
return
;
}
nsTArray
<
PropertyStyleAnimationValuePair
>
fromValues
;
float
fromKey
=
0
.
0f
;
if
(
!
StyleAnimationValue
:
:
ComputeValues
(
pair
.
mProperty
nsCSSProps
:
:
eEnabledForAllContent
aTarget
aPseudoType
pair
.
mValues
[
0
]
false
fromValues
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR
)
;
return
;
}
if
(
fromValues
.
IsEmpty
(
)
)
{
continue
;
}
nsTArray
<
size_t
>
animationPropertyIndexes
;
animationPropertyIndexes
.
SetLength
(
fromValues
.
Length
(
)
)
;
for
(
size_t
i
=
0
n
=
fromValues
.
Length
(
)
;
i
<
n
;
+
+
i
)
{
nsCSSProperty
p
=
fromValues
[
i
]
.
mProperty
;
bool
found
=
false
;
if
(
properties
.
HasProperty
(
p
)
)
{
for
(
size_t
j
=
0
m
=
aResult
.
Length
(
)
;
j
<
m
;
+
+
j
)
{
if
(
aResult
[
j
]
.
mProperty
=
=
p
)
{
aResult
[
j
]
.
mSegments
.
Clear
(
)
;
animationPropertyIndexes
[
i
]
=
j
;
found
=
true
;
break
;
}
}
MOZ_ASSERT
(
found
"
properties
is
inconsistent
with
aResult
"
)
;
}
if
(
!
found
)
{
animationPropertyIndexes
[
i
]
=
aResult
.
Length
(
)
;
AnimationProperty
*
animationProperty
=
aResult
.
AppendElement
(
)
;
animationProperty
-
>
mProperty
=
p
;
properties
.
AddProperty
(
p
)
;
}
}
double
portion
=
1
.
0
/
(
count
-
1
)
;
for
(
size_t
i
=
0
;
i
<
count
-
1
;
+
+
i
)
{
nsTArray
<
PropertyStyleAnimationValuePair
>
toValues
;
float
toKey
=
(
i
+
1
)
*
portion
;
if
(
!
StyleAnimationValue
:
:
ComputeValues
(
pair
.
mProperty
nsCSSProps
:
:
eEnabledForAllContent
aTarget
aPseudoType
pair
.
mValues
[
i
+
1
]
false
toValues
)
)
{
if
(
i
+
1
=
=
count
-
1
)
{
aRv
.
Throw
(
NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR
)
;
return
;
}
continue
;
}
MOZ_ASSERT
(
toValues
.
Length
(
)
=
=
fromValues
.
Length
(
)
"
should
get
the
same
number
of
properties
as
the
last
time
"
"
we
called
ComputeValues
for
pair
.
mProperty
"
)
;
for
(
size_t
j
=
0
n
=
toValues
.
Length
(
)
;
j
<
n
;
+
+
j
)
{
size_t
index
=
animationPropertyIndexes
[
j
]
;
AnimationPropertySegment
*
segment
=
aResult
[
index
]
.
mSegments
.
AppendElement
(
)
;
segment
-
>
mFromKey
=
fromKey
;
segment
-
>
mFromValue
=
fromValues
[
j
]
.
mValue
;
segment
-
>
mToKey
=
toKey
;
segment
-
>
mToValue
=
toValues
[
j
]
.
mValue
;
segment
-
>
mTimingFunction
=
easing
;
}
fromValues
=
Move
(
toValues
)
;
fromKey
=
toKey
;
}
}
}
void
KeyframeEffectReadOnly
:
:
BuildAnimationPropertyList
(
JSContext
*
aCx
Element
*
aTarget
CSSPseudoElementType
aPseudoType
JS
:
:
Handle
<
JSObject
*
>
aFrames
InfallibleTArray
<
AnimationProperty
>
&
aResult
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
)
;
if
(
!
aFrames
)
{
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
objectValue
(
aCx
JS
:
:
ObjectValue
(
*
aFrames
)
)
;
JS
:
:
ForOfIterator
iter
(
aCx
)
;
if
(
!
iter
.
init
(
objectValue
JS
:
:
ForOfIterator
:
:
AllowNonIterable
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
iter
.
valueIsIterable
(
)
)
{
BuildAnimationPropertyListFromKeyframeSequence
(
aCx
aTarget
aPseudoType
iter
aResult
aRv
)
;
}
else
{
BuildAnimationPropertyListFromPropertyIndexedKeyframes
(
aCx
aTarget
aPseudoType
objectValue
aResult
aRv
)
;
}
}
void
KeyframeEffectReadOnly
:
:
GetTarget
(
Nullable
<
OwningElementOrCSSPseudoElement
>
&
aRv
)
const
{
if
(
!
mTarget
)
{
aRv
.
SetNull
(
)
;
return
;
}
switch
(
mPseudoType
)
{
case
CSSPseudoElementType
:
:
before
:
case
CSSPseudoElementType
:
:
after
:
aRv
.
SetValue
(
)
.
SetAsCSSPseudoElement
(
)
=
CSSPseudoElement
:
:
GetCSSPseudoElement
(
mTarget
mPseudoType
)
;
break
;
case
CSSPseudoElementType
:
:
NotPseudo
:
aRv
.
SetValue
(
)
.
SetAsElement
(
)
=
mTarget
;
break
;
default
:
NS_NOTREACHED
(
"
Animation
of
unsupported
pseudo
-
type
"
)
;
aRv
.
SetNull
(
)
;
}
}
void
KeyframeEffectReadOnly
:
:
GetFrames
(
JSContext
*
&
aCx
nsTArray
<
JSObject
*
>
&
aResult
ErrorResult
&
aRv
)
{
nsTArray
<
OrderedKeyframeValueEntry
>
entries
;
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
for
(
size_t
i
=
0
n
=
property
.
mSegments
.
Length
(
)
;
i
<
n
;
i
+
+
)
{
const
AnimationPropertySegment
&
segment
=
property
.
mSegments
[
i
]
;
OrderedKeyframeValueEntry
*
entry
=
entries
.
AppendElement
(
)
;
entry
-
>
mProperty
=
property
.
mProperty
;
entry
-
>
mValue
=
segment
.
mFromValue
;
entry
-
>
mOffset
=
segment
.
mFromKey
;
entry
-
>
mTimingFunction
=
&
segment
.
mTimingFunction
;
entry
-
>
mPosition
=
segment
.
mFromKey
=
=
segment
.
mToKey
&
&
segment
.
mFromKey
=
=
0
.
0f
?
ValuePosition
:
:
First
:
ValuePosition
:
:
Right
;
if
(
i
=
=
n
-
1
|
|
segment
.
mToValue
!
=
property
.
mSegments
[
i
+
1
]
.
mFromValue
)
{
entry
=
entries
.
AppendElement
(
)
;
entry
-
>
mProperty
=
property
.
mProperty
;
entry
-
>
mValue
=
segment
.
mToValue
;
entry
-
>
mOffset
=
segment
.
mToKey
;
entry
-
>
mTimingFunction
=
segment
.
mToKey
=
=
1
.
0f
?
nullptr
:
&
segment
.
mTimingFunction
;
entry
-
>
mPosition
=
segment
.
mFromKey
=
=
segment
.
mToKey
&
&
segment
.
mToKey
=
=
1
.
0f
?
ValuePosition
:
:
Last
:
ValuePosition
:
:
Left
;
}
}
}
entries
.
Sort
(
OrderedKeyframeValueEntry
:
:
ForKeyframeGenerationComparator
(
)
)
;
for
(
size_t
i
=
0
n
=
entries
.
Length
(
)
;
i
<
n
;
)
{
OrderedKeyframeValueEntry
*
entry
=
&
entries
[
i
]
;
OrderedKeyframeValueEntry
*
previousEntry
=
nullptr
;
ComputedKeyframe
keyframeDict
;
keyframeDict
.
mOffset
.
SetValue
(
entry
-
>
mOffset
)
;
keyframeDict
.
mComputedOffset
.
Construct
(
entry
-
>
mOffset
)
;
if
(
entry
-
>
mTimingFunction
&
&
entry
-
>
mTimingFunction
-
>
isSome
(
)
)
{
keyframeDict
.
mEasing
.
Truncate
(
)
;
entry
-
>
mTimingFunction
-
>
value
(
)
.
AppendToString
(
keyframeDict
.
mEasing
)
;
}
keyframeDict
.
mComposite
.
SetValue
(
CompositeOperation
:
:
Replace
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
keyframeJSValue
(
aCx
)
;
if
(
!
ToJSValue
(
aCx
keyframeDict
&
keyframeJSValue
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
keyframe
(
aCx
&
keyframeJSValue
.
toObject
(
)
)
;
do
{
const
char
*
name
=
nsCSSProps
:
:
PropertyIDLName
(
entry
-
>
mProperty
)
;
nsString
stringValue
;
StyleAnimationValue
:
:
UncomputeValue
(
entry
-
>
mProperty
entry
-
>
mValue
stringValue
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
ToJSValue
(
aCx
stringValue
&
value
)
|
|
!
JS_DefineProperty
(
aCx
keyframe
name
value
JSPROP_ENUMERATE
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
+
+
i
=
=
n
)
{
break
;
}
previousEntry
=
entry
;
entry
=
&
entries
[
i
]
;
}
while
(
entry
-
>
SameKeyframe
(
*
previousEntry
)
)
;
aResult
.
AppendElement
(
keyframe
)
;
}
}
const
TimeDuration
KeyframeEffectReadOnly
:
:
OverflowRegionRefreshInterval
(
)
{
static
const
TimeDuration
kOverflowRegionRefreshInterval
=
TimeDuration
:
:
FromMilliseconds
(
200
)
;
return
kOverflowRegionRefreshInterval
;
}
bool
KeyframeEffectReadOnly
:
:
CanThrottle
(
)
const
{
if
(
!
IsInEffect
(
)
|
|
!
IsCurrent
(
)
)
{
return
false
;
}
nsIFrame
*
frame
=
GetAnimationFrame
(
)
;
if
(
!
frame
)
{
return
true
;
}
for
(
const
LayerAnimationInfo
:
:
Record
&
record
:
LayerAnimationInfo
:
:
sRecords
)
{
if
(
!
HasAnimationOfProperty
(
record
.
mProperty
)
)
{
continue
;
}
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
mTarget
mPseudoType
)
;
MOZ_ASSERT
(
effectSet
"
CanThrottle
should
be
called
on
an
effect
"
"
associated
with
a
target
element
"
)
;
layers
:
:
Layer
*
layer
=
FrameLayerBuilder
:
:
GetDedicatedLayer
(
frame
record
.
mLayerType
)
;
if
(
!
layer
|
|
effectSet
-
>
GetAnimationGeneration
(
)
!
=
layer
-
>
GetAnimationGeneration
(
)
)
{
return
false
;
}
if
(
record
.
mProperty
=
=
eCSSProperty_transform
&
&
!
CanThrottleTransformChanges
(
*
frame
)
)
{
return
false
;
}
}
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
if
(
!
property
.
mIsRunningOnCompositor
)
{
return
false
;
}
}
return
true
;
}
bool
KeyframeEffectReadOnly
:
:
CanThrottleTransformChanges
(
nsIFrame
&
aFrame
)
const
{
if
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_ShowHideScrollbars
)
=
=
0
)
{
return
true
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
MOZ_ASSERT
(
presContext
)
;
TimeStamp
now
=
presContext
-
>
RefreshDriver
(
)
-
>
MostRecentRefresh
(
)
;
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
mTarget
mPseudoType
)
;
MOZ_ASSERT
(
effectSet
"
CanThrottleTransformChanges
is
expected
to
be
called
"
"
on
an
effect
in
an
effect
set
"
)
;
MOZ_ASSERT
(
mAnimation
"
CanThrottleTransformChanges
is
expected
to
be
called
"
"
on
an
effect
with
a
parent
animation
"
)
;
TimeStamp
animationRuleRefreshTime
=
effectSet
-
>
AnimationRuleRefreshTime
(
mAnimation
-
>
CascadeLevel
(
)
)
;
if
(
!
animationRuleRefreshTime
.
IsNull
(
)
&
&
(
now
-
animationRuleRefreshTime
)
<
OverflowRegionRefreshInterval
(
)
)
{
return
true
;
}
nsIScrollableFrame
*
scrollable
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
&
aFrame
)
;
if
(
!
scrollable
)
{
return
true
;
}
ScrollbarStyles
ss
=
scrollable
-
>
GetScrollbarStyles
(
)
;
if
(
ss
.
mVertical
=
=
NS_STYLE_OVERFLOW_HIDDEN
&
&
ss
.
mHorizontal
=
=
NS_STYLE_OVERFLOW_HIDDEN
&
&
scrollable
-
>
GetLogicalScrollPosition
(
)
=
=
nsPoint
(
0
0
)
)
{
return
true
;
}
return
false
;
}
nsIFrame
*
KeyframeEffectReadOnly
:
:
GetAnimationFrame
(
)
const
{
if
(
!
mTarget
)
{
return
nullptr
;
}
nsIFrame
*
frame
=
mTarget
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
nullptr
;
}
if
(
mPseudoType
=
=
CSSPseudoElementType
:
:
before
)
{
frame
=
nsLayoutUtils
:
:
GetBeforeFrame
(
frame
)
;
}
else
if
(
mPseudoType
=
=
CSSPseudoElementType
:
:
after
)
{
frame
=
nsLayoutUtils
:
:
GetAfterFrame
(
frame
)
;
}
else
{
MOZ_ASSERT
(
mPseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
"
unknown
mPseudoType
"
)
;
}
if
(
!
frame
)
{
return
nullptr
;
}
return
nsLayoutUtils
:
:
GetStyleFrame
(
frame
)
;
}
nsIDocument
*
KeyframeEffectReadOnly
:
:
GetRenderedDocument
(
)
const
{
if
(
!
mTarget
)
{
return
nullptr
;
}
return
mTarget
-
>
GetComposedDoc
(
)
;
}
nsPresContext
*
KeyframeEffectReadOnly
:
:
GetPresContext
(
)
const
{
nsIDocument
*
doc
=
GetRenderedDocument
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
nsIPresShell
*
shell
=
doc
-
>
GetShell
(
)
;
if
(
!
shell
)
{
return
nullptr
;
}
return
shell
-
>
GetPresContext
(
)
;
}
bool
KeyframeEffectReadOnly
:
:
IsGeometricProperty
(
const
nsCSSProperty
aProperty
)
{
switch
(
aProperty
)
{
case
eCSSProperty_bottom
:
case
eCSSProperty_height
:
case
eCSSProperty_left
:
case
eCSSProperty_right
:
case
eCSSProperty_top
:
case
eCSSProperty_width
:
return
true
;
default
:
return
false
;
}
}
bool
KeyframeEffectReadOnly
:
:
CanAnimateTransformOnCompositor
(
const
nsIFrame
*
aFrame
const
nsIContent
*
aContent
)
{
if
(
aFrame
-
>
Combines3DTransformWithAncestors
(
)
|
|
aFrame
-
>
StyleDisplay
(
)
-
>
mTransformStyle
=
=
NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D
)
{
if
(
aContent
)
{
nsCString
message
;
message
.
AppendLiteral
(
"
Gecko
bug
:
Async
animation
of
'
preserve
-
3d
'
"
"
transforms
is
not
supported
.
See
bug
779598
"
)
;
AnimationUtils
:
:
LogAsyncAnimationFailure
(
message
aContent
)
;
}
return
false
;
}
if
(
aFrame
-
>
StyleDisplay
(
)
-
>
BackfaceIsHidden
(
)
)
{
if
(
aContent
)
{
nsCString
message
;
message
.
AppendLiteral
(
"
Gecko
bug
:
Async
animation
of
"
"
'
backface
-
visibility
:
hidden
'
transforms
is
not
supported
.
"
"
See
bug
1186204
.
"
)
;
AnimationUtils
:
:
LogAsyncAnimationFailure
(
message
aContent
)
;
}
return
false
;
}
if
(
aFrame
-
>
IsSVGTransformed
(
)
)
{
if
(
aContent
)
{
nsCString
message
;
message
.
AppendLiteral
(
"
Gecko
bug
:
Async
'
transform
'
animations
of
"
"
aFrames
with
SVG
transforms
is
not
supported
.
See
bug
779599
"
)
;
AnimationUtils
:
:
LogAsyncAnimationFailure
(
message
aContent
)
;
}
return
false
;
}
return
true
;
}
bool
KeyframeEffectReadOnly
:
:
ShouldBlockCompositorAnimations
(
const
nsIFrame
*
aFrame
)
const
{
MOZ_ASSERT
(
mAnimation
&
&
mAnimation
-
>
IsPlaying
(
)
)
;
bool
shouldLog
=
nsLayoutUtils
:
:
IsAnimationLoggingEnabled
(
)
;
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
if
(
!
property
.
mWinsInCascade
)
{
continue
;
}
if
(
IsGeometricProperty
(
property
.
mProperty
)
)
{
if
(
shouldLog
)
{
nsCString
message
;
message
.
AppendLiteral
(
"
Performance
warning
:
Async
animation
of
"
"
'
transform
'
or
'
opacity
'
not
possible
due
to
animation
of
geometric
"
"
properties
on
the
same
element
"
)
;
AnimationUtils
:
:
LogAsyncAnimationFailure
(
message
aFrame
-
>
GetContent
(
)
)
;
}
return
true
;
}
if
(
property
.
mProperty
=
=
eCSSProperty_transform
)
{
if
(
!
CanAnimateTransformOnCompositor
(
aFrame
shouldLog
?
aFrame
-
>
GetContent
(
)
:
nullptr
)
)
{
return
true
;
}
}
}
return
false
;
}
KeyframeEffect
:
:
KeyframeEffect
(
nsIDocument
*
aDocument
Element
*
aTarget
CSSPseudoElementType
aPseudoType
const
TimingParams
&
aTiming
)
:
KeyframeEffectReadOnly
(
aDocument
aTarget
aPseudoType
new
AnimationEffectTiming
(
aTiming
)
)
{
}
JSObject
*
KeyframeEffect
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
KeyframeEffectBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
}
