#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeAnimationOptionsBinding
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectBinding
.
h
"
#
include
"
mozilla
/
dom
/
MutationObservers
.
h
"
#
include
"
mozilla
/
AnimationUtils
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
ComputedStyleInlines
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
LayerAnimationInfo
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
KeyframeUtils
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
Layers
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSPropertyIDSet
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsPresContextInlines
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
WindowRenderer
.
h
"
namespace
mozilla
{
void
AnimationProperty
:
:
SetPerformanceWarning
(
const
AnimationPerformanceWarning
&
aWarning
const
dom
:
:
Element
*
aElement
)
{
if
(
mPerformanceWarning
&
&
*
mPerformanceWarning
=
=
aWarning
)
{
return
;
}
mPerformanceWarning
=
Some
(
aWarning
)
;
nsAutoString
localizedString
;
if
(
StaticPrefs
:
:
layers_offmainthreadcomposition_log_animations
(
)
&
&
mPerformanceWarning
-
>
ToLocalizedString
(
localizedString
)
)
{
nsAutoCString
logMessage
=
NS_ConvertUTF16toUTF8
(
localizedString
)
;
AnimationUtils
:
:
LogAsyncAnimationFailure
(
logMessage
aElement
)
;
}
}
bool
PropertyValuePair
:
:
operator
=
=
(
const
PropertyValuePair
&
aOther
)
const
{
if
(
mProperty
!
=
aOther
.
mProperty
)
{
return
false
;
}
if
(
mServoDeclarationBlock
=
=
aOther
.
mServoDeclarationBlock
)
{
return
true
;
}
if
(
!
mServoDeclarationBlock
|
|
!
aOther
.
mServoDeclarationBlock
)
{
return
false
;
}
return
Servo_DeclarationBlock_Equals
(
mServoDeclarationBlock
aOther
.
mServoDeclarationBlock
)
;
}
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
KeyframeEffect
AnimationEffect
mTarget
.
mElement
)
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
KeyframeEffect
AnimationEffect
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
KeyframeEffect
)
NS_INTERFACE_MAP_END_INHERITING
(
AnimationEffect
)
NS_IMPL_ADDREF_INHERITED
(
KeyframeEffect
AnimationEffect
)
NS_IMPL_RELEASE_INHERITED
(
KeyframeEffect
AnimationEffect
)
KeyframeEffect
:
:
KeyframeEffect
(
Document
*
aDocument
OwningAnimationTarget
&
&
aTarget
TimingParams
&
&
aTiming
const
KeyframeEffectParams
&
aOptions
)
:
AnimationEffect
(
aDocument
std
:
:
move
(
aTiming
)
)
mTarget
(
std
:
:
move
(
aTarget
)
)
mEffectOptions
(
aOptions
)
{
}
KeyframeEffect
:
:
KeyframeEffect
(
Document
*
aDocument
OwningAnimationTarget
&
&
aTarget
const
KeyframeEffect
&
aOther
)
:
AnimationEffect
(
aDocument
TimingParams
{
aOther
.
SpecifiedTiming
(
)
}
)
mTarget
(
std
:
:
move
(
aTarget
)
)
mEffectOptions
{
aOther
.
IterationComposite
(
)
aOther
.
Composite
(
)
mTarget
.
mPseudoType
}
mKeyframes
(
aOther
.
mKeyframes
.
Clone
(
)
)
mProperties
(
aOther
.
mProperties
.
Clone
(
)
)
mBaseValues
(
aOther
.
mBaseValues
.
Clone
(
)
)
{
}
JSObject
*
KeyframeEffect
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
KeyframeEffect_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
IterationCompositeOperation
KeyframeEffect
:
:
IterationComposite
(
)
const
{
return
mEffectOptions
.
mIterationComposite
;
}
void
KeyframeEffect
:
:
SetIterationComposite
(
const
IterationCompositeOperation
&
aIterationComposite
)
{
if
(
mEffectOptions
.
mIterationComposite
=
=
aIterationComposite
)
{
return
;
}
if
(
mAnimation
&
&
mAnimation
-
>
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
mAnimation
)
;
}
mEffectOptions
.
mIterationComposite
=
aIterationComposite
;
RequestRestyle
(
EffectCompositor
:
:
RestyleType
:
:
Layer
)
;
}
CompositeOperation
KeyframeEffect
:
:
Composite
(
)
const
{
return
mEffectOptions
.
mComposite
;
}
void
KeyframeEffect
:
:
SetComposite
(
const
CompositeOperation
&
aComposite
)
{
if
(
mEffectOptions
.
mComposite
=
=
aComposite
)
{
return
;
}
mEffectOptions
.
mComposite
=
aComposite
;
if
(
mAnimation
&
&
mAnimation
-
>
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
mAnimation
)
;
}
if
(
mTarget
)
{
RefPtr
<
const
ComputedStyle
>
computedStyle
=
GetTargetComputedStyle
(
Flush
:
:
None
)
;
if
(
computedStyle
)
{
UpdateProperties
(
computedStyle
)
;
}
}
}
void
KeyframeEffect
:
:
NotifySpecifiedTimingUpdated
(
)
{
nsAutoAnimationMutationBatch
mb
(
mTarget
?
mTarget
.
mElement
-
>
OwnerDoc
(
)
:
nullptr
)
;
if
(
mAnimation
)
{
mAnimation
-
>
NotifyEffectTimingUpdated
(
)
;
if
(
mAnimation
-
>
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
mAnimation
)
;
}
RequestRestyle
(
EffectCompositor
:
:
RestyleType
:
:
Layer
)
;
}
}
void
KeyframeEffect
:
:
NotifyAnimationTimingUpdated
(
PostRestyleMode
aPostRestyle
)
{
UpdateTargetRegistration
(
)
;
bool
isRelevant
=
mAnimation
&
&
mAnimation
-
>
IsRelevant
(
)
;
if
(
!
isRelevant
)
{
ResetIsRunningOnCompositor
(
)
;
}
if
(
aPostRestyle
=
=
PostRestyleMode
:
:
IfNeeded
&
&
mAnimation
&
&
!
mProperties
.
IsEmpty
(
)
&
&
HasComputedTimingChanged
(
)
)
{
EffectCompositor
:
:
RestyleType
restyleType
=
CanThrottle
(
)
?
EffectCompositor
:
:
RestyleType
:
:
Throttled
:
EffectCompositor
:
:
RestyleType
:
:
Standard
;
RequestRestyle
(
restyleType
)
;
}
bool
inEffect
=
IsInEffect
(
)
;
if
(
inEffect
!
=
mInEffectOnLastAnimationTimingUpdate
)
{
MarkCascadeNeedsUpdate
(
)
;
mInEffectOnLastAnimationTimingUpdate
=
inEffect
;
}
if
(
!
inEffect
)
{
mProgressOnLastCompose
.
SetNull
(
)
;
mCurrentIterationOnLastCompose
=
0
;
}
}
static
bool
KeyframesEqualIgnoringComputedOffsets
(
const
nsTArray
<
Keyframe
>
&
aLhs
const
nsTArray
<
Keyframe
>
&
aRhs
)
{
if
(
aLhs
.
Length
(
)
!
=
aRhs
.
Length
(
)
)
{
return
false
;
}
for
(
size_t
i
=
0
len
=
aLhs
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
const
Keyframe
&
a
=
aLhs
[
i
]
;
const
Keyframe
&
b
=
aRhs
[
i
]
;
if
(
a
.
mOffset
!
=
b
.
mOffset
|
|
a
.
mTimingFunction
!
=
b
.
mTimingFunction
|
|
a
.
mPropertyValues
!
=
b
.
mPropertyValues
)
{
return
false
;
}
}
return
true
;
}
void
KeyframeEffect
:
:
SetKeyframes
(
JSContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
ErrorResult
&
aRv
)
{
nsTArray
<
Keyframe
>
keyframes
=
KeyframeUtils
:
:
GetKeyframesFromObject
(
aContext
mDocument
aKeyframes
"
KeyframeEffect
.
setKeyframes
"
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
RefPtr
<
const
ComputedStyle
>
style
=
GetTargetComputedStyle
(
Flush
:
:
None
)
;
SetKeyframes
(
std
:
:
move
(
keyframes
)
style
nullptr
)
;
}
void
KeyframeEffect
:
:
SetKeyframes
(
nsTArray
<
Keyframe
>
&
&
aKeyframes
const
ComputedStyle
*
aStyle
const
AnimationTimeline
*
aTimeline
)
{
if
(
KeyframesEqualIgnoringComputedOffsets
(
aKeyframes
mKeyframes
)
)
{
return
;
}
mKeyframes
=
std
:
:
move
(
aKeyframes
)
;
KeyframeUtils
:
:
DistributeKeyframes
(
mKeyframes
)
;
if
(
mAnimation
&
&
mAnimation
-
>
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
mAnimation
)
;
}
if
(
aStyle
)
{
UpdateProperties
(
aStyle
aTimeline
)
;
}
}
void
KeyframeEffect
:
:
ReplaceTransitionStartValue
(
AnimationValue
&
&
aStartValue
)
{
if
(
!
aStartValue
.
mServo
)
{
return
;
}
if
(
mProperties
.
Length
(
)
!
=
1
|
|
mProperties
[
0
]
.
mSegments
.
Length
(
)
!
=
1
)
{
return
;
}
if
(
mKeyframes
.
Length
(
)
!
=
2
|
|
mKeyframes
[
0
]
.
mPropertyValues
.
Length
(
)
!
=
1
)
{
return
;
}
if
(
Servo_AnimationValue_GetPropertyId
(
aStartValue
.
mServo
)
!
=
mProperties
[
0
]
.
mProperty
)
{
return
;
}
mKeyframes
[
0
]
.
mPropertyValues
[
0
]
.
mServoDeclarationBlock
=
Servo_AnimationValue_Uncompute
(
aStartValue
.
mServo
)
.
Consume
(
)
;
mProperties
[
0
]
.
mSegments
[
0
]
.
mFromValue
=
std
:
:
move
(
aStartValue
)
;
}
static
bool
IsEffectiveProperty
(
const
EffectSet
&
aEffects
nsCSSPropertyID
aProperty
)
{
return
!
aEffects
.
PropertiesWithImportantRules
(
)
.
HasProperty
(
aProperty
)
|
|
!
aEffects
.
PropertiesForAnimationsLevel
(
)
.
HasProperty
(
aProperty
)
;
}
const
AnimationProperty
*
KeyframeEffect
:
:
GetEffectiveAnimationOfProperty
(
nsCSSPropertyID
aProperty
const
EffectSet
&
aEffects
)
const
{
MOZ_ASSERT
(
mTarget
&
&
&
aEffects
=
=
EffectSet
:
:
GetEffectSet
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
)
;
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
if
(
aProperty
!
=
property
.
mProperty
)
{
continue
;
}
const
AnimationProperty
*
result
=
nullptr
;
if
(
IsEffectiveProperty
(
aEffects
property
.
mProperty
)
)
{
result
=
&
property
;
}
return
result
;
}
return
nullptr
;
}
bool
KeyframeEffect
:
:
HasEffectiveAnimationOfPropertySet
(
const
nsCSSPropertyIDSet
&
aPropertySet
const
EffectSet
&
aEffectSet
)
const
{
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
if
(
aPropertySet
.
HasProperty
(
property
.
mProperty
)
&
&
IsEffectiveProperty
(
aEffectSet
property
.
mProperty
)
)
{
return
true
;
}
}
return
false
;
}
nsCSSPropertyIDSet
KeyframeEffect
:
:
GetPropertiesForCompositor
(
EffectSet
&
aEffects
const
nsIFrame
*
aFrame
)
const
{
MOZ_ASSERT
(
&
aEffects
=
=
EffectSet
:
:
GetEffectSet
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
)
;
nsCSSPropertyIDSet
properties
;
if
(
!
mAnimation
|
|
!
mAnimation
-
>
IsRelevant
(
)
)
{
return
properties
;
}
static
constexpr
nsCSSPropertyIDSet
compositorAnimatables
=
nsCSSPropertyIDSet
:
:
CompositorAnimatables
(
)
;
static
constexpr
nsCSSPropertyIDSet
transformLikeProperties
=
nsCSSPropertyIDSet
:
:
TransformLikeProperties
(
)
;
nsCSSPropertyIDSet
transformSet
;
AnimationPerformanceWarning
:
:
Type
dummyWarning
;
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
if
(
!
compositorAnimatables
.
HasProperty
(
property
.
mProperty
)
)
{
continue
;
}
if
(
transformLikeProperties
.
HasProperty
(
property
.
mProperty
)
)
{
transformSet
.
AddProperty
(
property
.
mProperty
)
;
continue
;
}
KeyframeEffect
:
:
MatchForCompositor
matchResult
=
IsMatchForCompositor
(
nsCSSPropertyIDSet
{
property
.
mProperty
}
aFrame
aEffects
dummyWarning
)
;
if
(
matchResult
=
=
KeyframeEffect
:
:
MatchForCompositor
:
:
NoAndBlockThisProperty
|
|
matchResult
=
=
KeyframeEffect
:
:
MatchForCompositor
:
:
No
)
{
continue
;
}
properties
.
AddProperty
(
property
.
mProperty
)
;
}
if
(
!
transformSet
.
IsEmpty
(
)
)
{
KeyframeEffect
:
:
MatchForCompositor
matchResult
=
IsMatchForCompositor
(
transformSet
aFrame
aEffects
dummyWarning
)
;
if
(
matchResult
=
=
KeyframeEffect
:
:
MatchForCompositor
:
:
Yes
|
|
matchResult
=
=
KeyframeEffect
:
:
MatchForCompositor
:
:
IfNeeded
)
{
properties
|
=
transformSet
;
}
}
return
properties
;
}
nsCSSPropertyIDSet
KeyframeEffect
:
:
GetPropertySet
(
)
const
{
nsCSSPropertyIDSet
result
;
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
result
.
AddProperty
(
property
.
mProperty
)
;
}
return
result
;
}
#
ifdef
DEBUG
bool
SpecifiedKeyframeArraysAreEqual
(
const
nsTArray
<
Keyframe
>
&
aA
const
nsTArray
<
Keyframe
>
&
aB
)
{
if
(
aA
.
Length
(
)
!
=
aB
.
Length
(
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
aA
.
Length
(
)
;
i
+
+
)
{
const
Keyframe
&
a
=
aA
[
i
]
;
const
Keyframe
&
b
=
aB
[
i
]
;
if
(
a
.
mOffset
!
=
b
.
mOffset
|
|
a
.
mTimingFunction
!
=
b
.
mTimingFunction
|
|
a
.
mPropertyValues
!
=
b
.
mPropertyValues
)
{
return
false
;
}
}
return
true
;
}
#
endif
static
bool
HasCurrentColor
(
const
nsTArray
<
AnimationPropertySegment
>
&
aSegments
)
{
for
(
const
AnimationPropertySegment
&
segment
:
aSegments
)
{
if
(
(
!
segment
.
mFromValue
.
IsNull
(
)
&
&
segment
.
mFromValue
.
IsCurrentColor
(
)
)
|
|
(
!
segment
.
mToValue
.
IsNull
(
)
&
&
segment
.
mToValue
.
IsCurrentColor
(
)
)
)
{
return
true
;
}
}
return
false
;
}
void
KeyframeEffect
:
:
UpdateProperties
(
const
ComputedStyle
*
aStyle
const
AnimationTimeline
*
aTimeline
)
{
MOZ_ASSERT
(
aStyle
)
;
nsTArray
<
AnimationProperty
>
properties
=
BuildProperties
(
aStyle
)
;
bool
propertiesChanged
=
mProperties
!
=
properties
;
bool
baseStylesChanged
=
false
;
EnsureBaseStyles
(
aStyle
properties
aTimeline
!
propertiesChanged
?
&
baseStylesChanged
:
nullptr
)
;
if
(
!
propertiesChanged
)
{
if
(
baseStylesChanged
)
{
RequestRestyle
(
EffectCompositor
:
:
RestyleType
:
:
Layer
)
;
}
if
(
mNeedsStyleData
&
&
mTarget
&
&
mTarget
.
mElement
-
>
HasServoData
(
)
)
{
CalculateCumulativeChangeHint
(
aStyle
)
;
}
return
;
}
nsCSSPropertyIDSet
runningOnCompositorProperties
;
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
if
(
property
.
mIsRunningOnCompositor
)
{
runningOnCompositorProperties
.
AddProperty
(
property
.
mProperty
)
;
}
}
mProperties
=
std
:
:
move
(
properties
)
;
UpdateEffectSet
(
)
;
mHasCurrentColor
=
false
;
for
(
AnimationProperty
&
property
:
mProperties
)
{
property
.
mIsRunningOnCompositor
=
runningOnCompositorProperties
.
HasProperty
(
property
.
mProperty
)
;
if
(
property
.
mProperty
=
=
eCSSProperty_background_color
&
&
!
mHasCurrentColor
)
{
if
(
HasCurrentColor
(
property
.
mSegments
)
)
{
mHasCurrentColor
=
true
;
break
;
}
}
}
CalculateCumulativeChangeHint
(
aStyle
)
;
MarkCascadeNeedsUpdate
(
)
;
if
(
mAnimation
)
{
mAnimation
-
>
NotifyEffectPropertiesUpdated
(
)
;
}
RequestRestyle
(
EffectCompositor
:
:
RestyleType
:
:
Layer
)
;
}
void
KeyframeEffect
:
:
EnsureBaseStyles
(
const
ComputedStyle
*
aComputedValues
const
nsTArray
<
AnimationProperty
>
&
aProperties
const
AnimationTimeline
*
aTimeline
bool
*
aBaseStylesChanged
)
{
if
(
aBaseStylesChanged
!
=
nullptr
)
{
*
aBaseStylesChanged
=
false
;
}
if
(
!
mTarget
)
{
return
;
}
BaseValuesHashmap
previousBaseStyles
;
if
(
aBaseStylesChanged
!
=
nullptr
)
{
previousBaseStyles
=
std
:
:
move
(
mBaseValues
)
;
}
mBaseValues
.
Clear
(
)
;
nsPresContext
*
presContext
=
nsContentUtils
:
:
GetContextForContent
(
mTarget
.
mElement
)
;
MOZ_ASSERT
(
presContext
|
|
aProperties
.
IsEmpty
(
)
"
Typically
presContext
should
not
be
nullptr
but
if
it
is
"
"
we
should
have
also
failed
to
calculate
the
computed
values
"
"
passed
-
in
as
aProperties
"
)
;
if
(
!
aTimeline
)
{
aTimeline
=
mAnimation
?
mAnimation
-
>
GetTimeline
(
)
:
nullptr
;
}
RefPtr
<
const
ComputedStyle
>
baseComputedStyle
;
for
(
const
AnimationProperty
&
property
:
aProperties
)
{
EnsureBaseStyle
(
property
presContext
aComputedValues
aTimeline
baseComputedStyle
)
;
}
if
(
aBaseStylesChanged
!
=
nullptr
&
&
std
:
:
any_of
(
mBaseValues
.
cbegin
(
)
mBaseValues
.
cend
(
)
[
&
]
(
const
auto
&
entry
)
{
return
AnimationValue
(
entry
.
GetData
(
)
)
!
=
AnimationValue
(
previousBaseStyles
.
Get
(
entry
.
GetKey
(
)
)
)
;
}
)
)
{
*
aBaseStylesChanged
=
true
;
}
}
void
KeyframeEffect
:
:
EnsureBaseStyle
(
const
AnimationProperty
&
aProperty
nsPresContext
*
aPresContext
const
ComputedStyle
*
aComputedStyle
const
AnimationTimeline
*
aTimeline
RefPtr
<
const
ComputedStyle
>
&
aBaseComputedStyle
)
{
auto
needBaseStyleForScrollTimeline
=
[
this
]
(
const
AnimationProperty
&
aProperty
const
AnimationTimeline
*
aTimeline
)
{
static
constexpr
TimeDuration
zeroDuration
;
const
TimingParams
&
timing
=
NormalizedTiming
(
)
;
return
aTimeline
&
&
aTimeline
-
>
IsScrollTimeline
(
)
&
&
nsCSSPropertyIDSet
:
:
CompositorAnimatables
(
)
.
HasProperty
(
aProperty
.
mProperty
)
&
&
(
timing
.
Delay
(
)
>
zeroDuration
|
|
timing
.
EndDelay
(
)
>
zeroDuration
)
;
}
;
auto
hasAdditiveValues
=
[
]
(
const
AnimationProperty
&
aProperty
)
{
for
(
const
AnimationPropertySegment
&
segment
:
aProperty
.
mSegments
)
{
if
(
!
segment
.
HasReplaceableValues
(
)
)
{
return
true
;
}
}
return
false
;
}
;
const
bool
needBaseStyle
=
needBaseStyleForScrollTimeline
(
aProperty
aTimeline
)
|
|
hasAdditiveValues
(
aProperty
)
;
if
(
!
needBaseStyle
)
{
return
;
}
if
(
!
aBaseComputedStyle
)
{
MOZ_ASSERT
(
mTarget
"
Should
have
a
valid
target
"
)
;
Element
*
animatingElement
=
EffectCompositor
:
:
GetElementToRestyle
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
;
if
(
!
animatingElement
)
{
return
;
}
aBaseComputedStyle
=
aPresContext
-
>
StyleSet
(
)
-
>
GetBaseContextForElement
(
animatingElement
aComputedStyle
)
;
}
RefPtr
<
RawServoAnimationValue
>
baseValue
=
Servo_ComputedValues_ExtractAnimationValue
(
aBaseComputedStyle
aProperty
.
mProperty
)
.
Consume
(
)
;
mBaseValues
.
InsertOrUpdate
(
aProperty
.
mProperty
std
:
:
move
(
baseValue
)
)
;
}
void
KeyframeEffect
:
:
WillComposeStyle
(
)
{
ComputedTiming
computedTiming
=
GetComputedTiming
(
)
;
mProgressOnLastCompose
=
computedTiming
.
mProgress
;
mCurrentIterationOnLastCompose
=
computedTiming
.
mCurrentIteration
;
}
void
KeyframeEffect
:
:
ComposeStyleRule
(
RawServoAnimationValueMap
&
aAnimationValues
const
AnimationProperty
&
aProperty
const
AnimationPropertySegment
&
aSegment
const
ComputedTiming
&
aComputedTiming
)
{
auto
*
opaqueTable
=
reinterpret_cast
<
RawServoAnimationValueTable
*
>
(
&
mBaseValues
)
;
Servo_AnimationCompose
(
&
aAnimationValues
opaqueTable
aProperty
.
mProperty
&
aSegment
&
aProperty
.
mSegments
.
LastElement
(
)
&
aComputedTiming
mEffectOptions
.
mIterationComposite
)
;
}
void
KeyframeEffect
:
:
ComposeStyle
(
RawServoAnimationValueMap
&
aComposeResult
const
nsCSSPropertyIDSet
&
aPropertiesToSkip
)
{
ComputedTiming
computedTiming
=
GetComputedTiming
(
)
;
if
(
computedTiming
.
mProgress
.
IsNull
(
)
)
{
return
;
}
for
(
size_t
propIdx
=
0
propEnd
=
mProperties
.
Length
(
)
;
propIdx
!
=
propEnd
;
+
+
propIdx
)
{
const
AnimationProperty
&
prop
=
mProperties
[
propIdx
]
;
MOZ_ASSERT
(
prop
.
mSegments
[
0
]
.
mFromKey
=
=
0
.
0
"
incorrect
first
from
key
"
)
;
MOZ_ASSERT
(
prop
.
mSegments
[
prop
.
mSegments
.
Length
(
)
-
1
]
.
mToKey
=
=
1
.
0
"
incorrect
last
to
key
"
)
;
if
(
aPropertiesToSkip
.
HasProperty
(
prop
.
mProperty
)
)
{
continue
;
}
MOZ_ASSERT
(
prop
.
mSegments
.
Length
(
)
>
0
"
property
should
not
be
in
animations
if
it
has
no
segments
"
)
;
const
AnimationPropertySegment
*
segment
=
prop
.
mSegments
.
Elements
(
)
*
segmentEnd
=
segment
+
prop
.
mSegments
.
Length
(
)
;
while
(
segment
-
>
mToKey
<
=
computedTiming
.
mProgress
.
Value
(
)
)
{
MOZ_ASSERT
(
segment
-
>
mFromKey
<
=
segment
-
>
mToKey
"
incorrect
keys
"
)
;
if
(
(
segment
+
1
)
=
=
segmentEnd
)
{
break
;
}
+
+
segment
;
MOZ_ASSERT
(
segment
-
>
mFromKey
=
=
(
segment
-
1
)
-
>
mToKey
"
incorrect
keys
"
)
;
}
MOZ_ASSERT
(
segment
-
>
mFromKey
<
=
segment
-
>
mToKey
"
incorrect
keys
"
)
;
MOZ_ASSERT
(
segment
>
=
prop
.
mSegments
.
Elements
(
)
&
&
size_t
(
segment
-
prop
.
mSegments
.
Elements
(
)
)
<
prop
.
mSegments
.
Length
(
)
"
out
of
array
bounds
"
)
;
ComposeStyleRule
(
aComposeResult
prop
*
segment
computedTiming
)
;
}
if
(
HasPropertiesThatMightAffectOverflow
(
)
)
{
nsPresContext
*
presContext
=
nsContentUtils
:
:
GetContextForContent
(
mTarget
.
mElement
)
;
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
;
if
(
presContext
&
&
effectSet
)
{
TimeStamp
now
=
presContext
-
>
RefreshDriver
(
)
-
>
MostRecentRefresh
(
)
;
effectSet
-
>
UpdateLastOverflowAnimationSyncTime
(
now
)
;
}
}
}
bool
KeyframeEffect
:
:
IsRunningOnCompositor
(
)
const
{
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
if
(
property
.
mIsRunningOnCompositor
)
{
return
true
;
}
}
return
false
;
}
void
KeyframeEffect
:
:
SetIsRunningOnCompositor
(
nsCSSPropertyID
aProperty
bool
aIsRunning
)
{
MOZ_ASSERT
(
nsCSSProps
:
:
PropHasFlags
(
aProperty
CSSPropFlags
:
:
CanAnimateOnCompositor
)
"
Property
being
animated
on
compositor
is
a
recognized
"
"
compositor
-
animatable
property
"
)
;
for
(
AnimationProperty
&
property
:
mProperties
)
{
if
(
property
.
mProperty
=
=
aProperty
)
{
property
.
mIsRunningOnCompositor
=
aIsRunning
;
if
(
aIsRunning
)
{
property
.
mPerformanceWarning
.
reset
(
)
;
}
else
if
(
mAnimation
&
&
mAnimation
-
>
IsPartialPrerendered
(
)
)
{
ResetPartialPrerendered
(
)
;
}
return
;
}
}
}
void
KeyframeEffect
:
:
SetIsRunningOnCompositor
(
const
nsCSSPropertyIDSet
&
aPropertySet
bool
aIsRunning
)
{
for
(
AnimationProperty
&
property
:
mProperties
)
{
if
(
aPropertySet
.
HasProperty
(
property
.
mProperty
)
)
{
MOZ_ASSERT
(
nsCSSProps
:
:
PropHasFlags
(
property
.
mProperty
CSSPropFlags
:
:
CanAnimateOnCompositor
)
"
Property
being
animated
on
compositor
is
a
recognized
"
"
compositor
-
animatable
property
"
)
;
property
.
mIsRunningOnCompositor
=
aIsRunning
;
if
(
aIsRunning
)
{
property
.
mPerformanceWarning
.
reset
(
)
;
}
}
}
if
(
!
aIsRunning
&
&
mAnimation
&
&
mAnimation
-
>
IsPartialPrerendered
(
)
)
{
ResetPartialPrerendered
(
)
;
}
}
void
KeyframeEffect
:
:
ResetIsRunningOnCompositor
(
)
{
for
(
AnimationProperty
&
property
:
mProperties
)
{
property
.
mIsRunningOnCompositor
=
false
;
}
if
(
mAnimation
&
&
mAnimation
-
>
IsPartialPrerendered
(
)
)
{
ResetPartialPrerendered
(
)
;
}
}
void
KeyframeEffect
:
:
ResetPartialPrerendered
(
)
{
MOZ_ASSERT
(
mAnimation
&
&
mAnimation
-
>
IsPartialPrerendered
(
)
)
;
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
;
}
nsIWidget
*
widget
=
frame
-
>
GetNearestWidget
(
)
;
if
(
!
widget
)
{
return
;
}
if
(
WindowRenderer
*
windowRenderer
=
widget
-
>
GetWindowRenderer
(
)
)
{
windowRenderer
-
>
RemovePartialPrerenderedAnimation
(
mAnimation
-
>
IdOnCompositor
(
)
mAnimation
)
;
}
}
static
const
KeyframeEffectOptions
&
KeyframeEffectOptionsFromUnion
(
const
UnrestrictedDoubleOrKeyframeEffectOptions
&
aOptions
)
{
MOZ_ASSERT
(
aOptions
.
IsKeyframeEffectOptions
(
)
)
;
return
aOptions
.
GetAsKeyframeEffectOptions
(
)
;
}
static
const
KeyframeEffectOptions
&
KeyframeEffectOptionsFromUnion
(
const
UnrestrictedDoubleOrKeyframeAnimationOptions
&
aOptions
)
{
MOZ_ASSERT
(
aOptions
.
IsKeyframeAnimationOptions
(
)
)
;
return
aOptions
.
GetAsKeyframeAnimationOptions
(
)
;
}
template
<
class
OptionsType
>
static
KeyframeEffectParams
KeyframeEffectParamsFromUnion
(
const
OptionsType
&
aOptions
CallerType
aCallerType
ErrorResult
&
aRv
)
{
KeyframeEffectParams
result
;
if
(
aOptions
.
IsUnrestrictedDouble
(
)
)
{
return
result
;
}
const
KeyframeEffectOptions
&
options
=
KeyframeEffectOptionsFromUnion
(
aOptions
)
;
result
.
mIterationComposite
=
options
.
mIterationComposite
;
result
.
mComposite
=
options
.
mComposite
;
result
.
mPseudoType
=
PseudoStyleType
:
:
NotPseudo
;
if
(
DOMStringIsNull
(
options
.
mPseudoElement
)
)
{
return
result
;
}
Maybe
<
PseudoStyleType
>
pseudoType
=
nsCSSPseudoElements
:
:
GetPseudoType
(
options
.
mPseudoElement
)
;
if
(
!
pseudoType
)
{
aRv
.
ThrowSyntaxError
(
nsPrintfCString
(
"
'
%
s
'
is
a
syntactically
invalid
pseudo
-
element
.
"
NS_ConvertUTF16toUTF8
(
options
.
mPseudoElement
)
.
get
(
)
)
)
;
return
result
;
}
result
.
mPseudoType
=
*
pseudoType
;
if
(
!
AnimationUtils
:
:
IsSupportedPseudoForAnimations
(
result
.
mPseudoType
)
)
{
aRv
.
ThrowSyntaxError
(
nsPrintfCString
(
"
'
%
s
'
is
an
unsupported
pseudo
-
element
.
"
NS_ConvertUTF16toUTF8
(
options
.
mPseudoElement
)
.
get
(
)
)
)
;
}
return
result
;
}
template
<
class
OptionsType
>
already_AddRefed
<
KeyframeEffect
>
KeyframeEffect
:
:
ConstructKeyframeEffect
(
const
GlobalObject
&
aGlobal
Element
*
aTarget
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
OptionsType
&
aOptions
ErrorResult
&
aRv
)
{
Document
*
doc
=
AnimationUtils
:
:
GetDocumentFromGlobal
(
aGlobal
.
Get
(
)
)
;
if
(
!
doc
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
KeyframeEffectParams
effectOptions
=
KeyframeEffectParamsFromUnion
(
aOptions
aGlobal
.
CallerType
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
TimingParams
timingParams
=
TimingParams
:
:
FromOptionsUnion
(
aOptions
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
KeyframeEffect
>
effect
=
new
KeyframeEffect
(
doc
OwningAnimationTarget
(
aTarget
effectOptions
.
mPseudoType
)
std
:
:
move
(
timingParams
)
effectOptions
)
;
effect
-
>
SetKeyframes
(
aGlobal
.
Context
(
)
aKeyframes
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
effect
.
forget
(
)
;
}
nsTArray
<
AnimationProperty
>
KeyframeEffect
:
:
BuildProperties
(
const
ComputedStyle
*
aStyle
)
{
MOZ_ASSERT
(
aStyle
)
;
nsTArray
<
AnimationProperty
>
result
;
if
(
!
mTarget
)
{
return
result
;
}
auto
keyframesCopy
(
mKeyframes
.
Clone
(
)
)
;
result
=
KeyframeUtils
:
:
GetAnimationPropertiesFromKeyframes
(
keyframesCopy
mTarget
.
mElement
mTarget
.
mPseudoType
aStyle
mEffectOptions
.
mComposite
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
SpecifiedKeyframeArraysAreEqual
(
mKeyframes
keyframesCopy
)
"
Apart
from
the
computed
offset
members
the
keyframes
array
"
"
should
not
be
modified
"
)
;
#
endif
mKeyframes
=
std
:
:
move
(
keyframesCopy
)
;
return
result
;
}
template
<
typename
FrameEnumFunc
>
static
void
EnumerateContinuationsOrIBSplitSiblings
(
nsIFrame
*
aFrame
FrameEnumFunc
&
&
aFunc
)
{
while
(
aFrame
)
{
aFunc
(
aFrame
)
;
aFrame
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
aFrame
)
;
}
}
void
KeyframeEffect
:
:
UpdateTarget
(
Element
*
aElement
PseudoStyleType
aPseudoType
)
{
OwningAnimationTarget
newTarget
(
aElement
aPseudoType
)
;
if
(
mTarget
=
=
newTarget
)
{
return
;
}
if
(
mTarget
)
{
ResetIsRunningOnCompositor
(
)
;
UnregisterTarget
(
)
;
RequestRestyle
(
EffectCompositor
:
:
RestyleType
:
:
Layer
)
;
nsAutoAnimationMutationBatch
mb
(
mTarget
.
mElement
-
>
OwnerDoc
(
)
)
;
if
(
mAnimation
)
{
MutationObservers
:
:
NotifyAnimationRemoved
(
mAnimation
)
;
}
}
mTarget
=
newTarget
;
if
(
mTarget
)
{
UpdateTargetRegistration
(
)
;
RefPtr
<
const
ComputedStyle
>
computedStyle
=
GetTargetComputedStyle
(
Flush
:
:
None
)
;
if
(
computedStyle
)
{
UpdateProperties
(
computedStyle
)
;
}
RequestRestyle
(
EffectCompositor
:
:
RestyleType
:
:
Layer
)
;
nsAutoAnimationMutationBatch
mb
(
mTarget
.
mElement
-
>
OwnerDoc
(
)
)
;
if
(
mAnimation
)
{
MutationObservers
:
:
NotifyAnimationAdded
(
mAnimation
)
;
mAnimation
-
>
ReschedulePendingTasks
(
)
;
}
}
if
(
mAnimation
)
{
mAnimation
-
>
NotifyEffectTargetUpdated
(
)
;
}
}
void
KeyframeEffect
:
:
UpdateTargetRegistration
(
)
{
if
(
!
mTarget
)
{
return
;
}
bool
isRelevant
=
mAnimation
&
&
mAnimation
-
>
IsRelevant
(
)
;
MOZ_ASSERT
(
isRelevant
=
=
(
(
IsCurrent
(
)
|
|
IsInEffect
(
)
)
&
&
mAnimation
&
&
mAnimation
-
>
ReplaceState
(
)
!
=
AnimationReplaceState
:
:
Removed
)
"
Out
of
date
Animation
:
:
IsRelevant
value
"
)
;
if
(
isRelevant
&
&
!
mInEffectSet
)
{
EffectSet
*
effectSet
=
EffectSet
:
:
GetOrCreateEffectSet
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
;
effectSet
-
>
AddEffect
(
*
this
)
;
mInEffectSet
=
true
;
UpdateEffectSet
(
effectSet
)
;
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
EnumerateContinuationsOrIBSplitSiblings
(
frame
[
]
(
nsIFrame
*
aFrame
)
{
aFrame
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
)
;
}
else
if
(
!
isRelevant
&
&
mInEffectSet
)
{
UnregisterTarget
(
)
;
}
}
void
KeyframeEffect
:
:
UnregisterTarget
(
)
{
if
(
!
mInEffectSet
)
{
return
;
}
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
;
MOZ_ASSERT
(
effectSet
"
If
mInEffectSet
is
true
there
must
be
an
EffectSet
"
"
on
the
target
element
"
)
;
mInEffectSet
=
false
;
if
(
effectSet
)
{
effectSet
-
>
RemoveEffect
(
*
this
)
;
if
(
effectSet
-
>
IsEmpty
(
)
)
{
EffectSet
:
:
DestroyEffectSet
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
;
}
}
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
EnumerateContinuationsOrIBSplitSiblings
(
frame
[
]
(
nsIFrame
*
aFrame
)
{
aFrame
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
)
;
}
void
KeyframeEffect
:
:
RequestRestyle
(
EffectCompositor
:
:
RestyleType
aRestyleType
)
{
if
(
!
mTarget
)
{
return
;
}
nsPresContext
*
presContext
=
nsContentUtils
:
:
GetContextForContent
(
mTarget
.
mElement
)
;
if
(
presContext
&
&
mAnimation
)
{
presContext
-
>
EffectCompositor
(
)
-
>
RequestRestyle
(
mTarget
.
mElement
mTarget
.
mPseudoType
aRestyleType
mAnimation
-
>
CascadeLevel
(
)
)
;
}
}
already_AddRefed
<
const
ComputedStyle
>
KeyframeEffect
:
:
GetTargetComputedStyle
(
Flush
aFlushType
)
const
{
if
(
!
GetRenderedDocument
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mTarget
"
Should
only
have
a
document
when
we
have
a
target
element
"
)
;
OwningAnimationTarget
kungfuDeathGrip
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
;
return
aFlushType
=
=
Flush
:
:
Style
?
nsComputedDOMStyle
:
:
GetComputedStyle
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
:
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
;
}
#
ifdef
DEBUG
void
DumpAnimationProperties
(
const
RawServoStyleSet
*
aRawSet
nsTArray
<
AnimationProperty
>
&
aAnimationProperties
)
{
for
(
auto
&
p
:
aAnimationProperties
)
{
printf
(
"
%
s
\
n
"
nsCString
(
nsCSSProps
:
:
GetStringValue
(
p
.
mProperty
)
)
.
get
(
)
)
;
for
(
auto
&
s
:
p
.
mSegments
)
{
nsAutoCString
fromValue
toValue
;
s
.
mFromValue
.
SerializeSpecifiedValue
(
p
.
mProperty
aRawSet
fromValue
)
;
s
.
mToValue
.
SerializeSpecifiedValue
(
p
.
mProperty
aRawSet
toValue
)
;
printf
(
"
%
f
.
.
%
f
:
%
s
.
.
%
s
\
n
"
s
.
mFromKey
s
.
mToKey
fromValue
.
get
(
)
toValue
.
get
(
)
)
;
}
}
}
#
endif
already_AddRefed
<
KeyframeEffect
>
KeyframeEffect
:
:
Constructor
(
const
GlobalObject
&
aGlobal
Element
*
aTarget
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
UnrestrictedDoubleOrKeyframeEffectOptions
&
aOptions
ErrorResult
&
aRv
)
{
return
ConstructKeyframeEffect
(
aGlobal
aTarget
aKeyframes
aOptions
aRv
)
;
}
already_AddRefed
<
KeyframeEffect
>
KeyframeEffect
:
:
Constructor
(
const
GlobalObject
&
aGlobal
Element
*
aTarget
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
UnrestrictedDoubleOrKeyframeAnimationOptions
&
aOptions
ErrorResult
&
aRv
)
{
return
ConstructKeyframeEffect
(
aGlobal
aTarget
aKeyframes
aOptions
aRv
)
;
}
already_AddRefed
<
KeyframeEffect
>
KeyframeEffect
:
:
Constructor
(
const
GlobalObject
&
aGlobal
KeyframeEffect
&
aSource
ErrorResult
&
aRv
)
{
Document
*
doc
=
AnimationUtils
:
:
GetCurrentRealmDocument
(
aGlobal
.
Context
(
)
)
;
if
(
!
doc
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
RefPtr
<
KeyframeEffect
>
effect
=
new
KeyframeEffect
(
doc
OwningAnimationTarget
{
aSource
.
mTarget
}
aSource
)
;
effect
-
>
mCumulativeChangeHint
=
aSource
.
mCumulativeChangeHint
;
return
effect
.
forget
(
)
;
}
void
KeyframeEffect
:
:
SetPseudoElement
(
const
nsAString
&
aPseudoElement
ErrorResult
&
aRv
)
{
if
(
DOMStringIsNull
(
aPseudoElement
)
)
{
UpdateTarget
(
mTarget
.
mElement
PseudoStyleType
:
:
NotPseudo
)
;
return
;
}
Maybe
<
PseudoStyleType
>
pseudoType
=
nsCSSPseudoElements
:
:
GetPseudoType
(
aPseudoElement
)
;
if
(
!
pseudoType
|
|
*
pseudoType
=
=
PseudoStyleType
:
:
NotPseudo
)
{
aRv
.
ThrowSyntaxError
(
nsPrintfCString
(
"
'
%
s
'
is
a
syntactically
invalid
pseudo
-
element
.
"
NS_ConvertUTF16toUTF8
(
aPseudoElement
)
.
get
(
)
)
)
;
return
;
}
if
(
!
AnimationUtils
:
:
IsSupportedPseudoForAnimations
(
*
pseudoType
)
)
{
aRv
.
ThrowSyntaxError
(
nsPrintfCString
(
"
'
%
s
'
is
an
unsupported
pseudo
-
element
.
"
NS_ConvertUTF16toUTF8
(
aPseudoElement
)
.
get
(
)
)
)
;
return
;
}
UpdateTarget
(
mTarget
.
mElement
*
pseudoType
)
;
}
static
void
CreatePropertyValue
(
nsCSSPropertyID
aProperty
float
aOffset
const
Maybe
<
StyleComputedTimingFunction
>
&
aTimingFunction
const
AnimationValue
&
aValue
dom
:
:
CompositeOperation
aComposite
const
RawServoStyleSet
*
aRawSet
AnimationPropertyValueDetails
&
aResult
)
{
aResult
.
mOffset
=
aOffset
;
if
(
!
aValue
.
IsNull
(
)
)
{
nsAutoCString
stringValue
;
aValue
.
SerializeSpecifiedValue
(
aProperty
aRawSet
stringValue
)
;
aResult
.
mValue
.
Construct
(
stringValue
)
;
}
if
(
aTimingFunction
)
{
aResult
.
mEasing
.
Construct
(
)
;
aTimingFunction
-
>
AppendToString
(
aResult
.
mEasing
.
Value
(
)
)
;
}
else
{
aResult
.
mEasing
.
Construct
(
"
linear
"
_ns
)
;
}
aResult
.
mComposite
=
aComposite
;
}
void
KeyframeEffect
:
:
GetProperties
(
nsTArray
<
AnimationPropertyDetails
>
&
aProperties
ErrorResult
&
aRv
)
const
{
const
RawServoStyleSet
*
rawSet
=
mDocument
-
>
StyleSetForPresShellOrMediaQueryEvaluation
(
)
-
>
RawSet
(
)
;
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
AnimationPropertyDetails
propertyDetails
;
propertyDetails
.
mProperty
=
NS_ConvertASCIItoUTF16
(
nsCSSProps
:
:
GetStringValue
(
property
.
mProperty
)
)
;
propertyDetails
.
mRunningOnCompositor
=
property
.
mIsRunningOnCompositor
;
nsAutoString
localizedString
;
if
(
property
.
mPerformanceWarning
&
&
property
.
mPerformanceWarning
-
>
ToLocalizedString
(
localizedString
)
)
{
propertyDetails
.
mWarning
.
Construct
(
localizedString
)
;
}
if
(
!
propertyDetails
.
mValues
.
SetCapacity
(
property
.
mSegments
.
Length
(
)
mozilla
:
:
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
for
(
size_t
segmentIdx
=
0
segmentLen
=
property
.
mSegments
.
Length
(
)
;
segmentIdx
<
segmentLen
;
segmentIdx
+
+
)
{
const
AnimationPropertySegment
&
segment
=
property
.
mSegments
[
segmentIdx
]
;
binding_detail
:
:
FastAnimationPropertyValueDetails
fromValue
;
CreatePropertyValue
(
property
.
mProperty
segment
.
mFromKey
segment
.
mTimingFunction
segment
.
mFromValue
segment
.
mFromComposite
rawSet
fromValue
)
;
if
(
segment
.
mFromKey
=
=
segment
.
mToKey
)
{
fromValue
.
mEasing
.
Reset
(
)
;
}
if
(
!
propertyDetails
.
mValues
.
AppendElement
(
fromValue
mozilla
:
:
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
if
(
segmentIdx
=
=
segmentLen
-
1
|
|
property
.
mSegments
[
segmentIdx
+
1
]
.
mFromValue
!
=
segment
.
mToValue
)
{
binding_detail
:
:
FastAnimationPropertyValueDetails
toValue
;
CreatePropertyValue
(
property
.
mProperty
segment
.
mToKey
Nothing
(
)
segment
.
mToValue
segment
.
mToComposite
rawSet
toValue
)
;
toValue
.
mEasing
.
Reset
(
)
;
if
(
!
propertyDetails
.
mValues
.
AppendElement
(
toValue
mozilla
:
:
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
}
}
aProperties
.
AppendElement
(
propertyDetails
)
;
}
}
void
KeyframeEffect
:
:
GetKeyframes
(
JSContext
*
aCx
nsTArray
<
JSObject
*
>
&
aResult
ErrorResult
&
aRv
)
const
{
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
if
(
!
aResult
.
SetCapacity
(
mKeyframes
.
Length
(
)
mozilla
:
:
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
bool
isCSSAnimation
=
mAnimation
&
&
mAnimation
-
>
AsCSSAnimation
(
)
;
RefPtr
<
const
ComputedStyle
>
computedStyle
;
if
(
isCSSAnimation
)
{
computedStyle
=
GetTargetComputedStyle
(
Flush
:
:
Style
)
;
}
const
RawServoStyleSet
*
rawSet
=
mDocument
-
>
StyleSetForPresShellOrMediaQueryEvaluation
(
)
-
>
RawSet
(
)
;
for
(
const
Keyframe
&
keyframe
:
mKeyframes
)
{
BaseComputedKeyframe
keyframeDict
;
if
(
keyframe
.
mOffset
)
{
keyframeDict
.
mOffset
.
SetValue
(
keyframe
.
mOffset
.
value
(
)
)
;
}
MOZ_ASSERT
(
keyframe
.
mComputedOffset
!
=
Keyframe
:
:
kComputedOffsetNotSet
"
Invalid
computed
offset
"
)
;
keyframeDict
.
mComputedOffset
.
Construct
(
keyframe
.
mComputedOffset
)
;
if
(
keyframe
.
mTimingFunction
)
{
keyframeDict
.
mEasing
.
Truncate
(
)
;
keyframe
.
mTimingFunction
.
ref
(
)
.
AppendToString
(
keyframeDict
.
mEasing
)
;
}
keyframeDict
.
mComposite
=
keyframe
.
mComposite
;
JS
:
:
Rooted
<
JS
:
:
Value
>
keyframeJSValue
(
aCx
)
;
if
(
!
ToJSValue
(
aCx
keyframeDict
&
keyframeJSValue
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
RefPtr
<
RawServoDeclarationBlock
>
customProperties
;
if
(
isCSSAnimation
)
{
for
(
const
PropertyValuePair
&
propertyValue
:
keyframe
.
mPropertyValues
)
{
if
(
propertyValue
.
mProperty
=
=
nsCSSPropertyID
:
:
eCSSPropertyExtra_variable
)
{
customProperties
=
propertyValue
.
mServoDeclarationBlock
;
break
;
}
}
}
JS
:
:
Rooted
<
JSObject
*
>
keyframeObject
(
aCx
&
keyframeJSValue
.
toObject
(
)
)
;
for
(
const
PropertyValuePair
&
propertyValue
:
keyframe
.
mPropertyValues
)
{
nsAutoCString
stringValue
;
if
(
propertyValue
.
mProperty
=
=
nsCSSPropertyID
:
:
eCSSPropertyExtra_variable
)
{
continue
;
}
if
(
propertyValue
.
mServoDeclarationBlock
)
{
Servo_DeclarationBlock_SerializeOneValue
(
propertyValue
.
mServoDeclarationBlock
propertyValue
.
mProperty
&
stringValue
computedStyle
customProperties
rawSet
)
;
}
else
{
RawServoAnimationValue
*
value
=
mBaseValues
.
GetWeak
(
propertyValue
.
mProperty
)
;
if
(
value
)
{
Servo_AnimationValue_Serialize
(
value
propertyValue
.
mProperty
rawSet
&
stringValue
)
;
}
}
const
char
*
name
=
nullptr
;
switch
(
propertyValue
.
mProperty
)
{
case
nsCSSPropertyID
:
:
eCSSProperty_offset
:
name
=
"
cssOffset
"
;
break
;
case
nsCSSPropertyID
:
:
eCSSProperty_float
:
default
:
name
=
nsCSSProps
:
:
PropertyIDLName
(
propertyValue
.
mProperty
)
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
NonVoidUTF8StringToJsval
(
aCx
stringValue
&
value
)
|
|
!
JS_DefineProperty
(
aCx
keyframeObject
name
value
JSPROP_ENUMERATE
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
}
aResult
.
AppendElement
(
keyframeObject
)
;
}
}
const
TimeDuration
KeyframeEffect
:
:
OverflowRegionRefreshInterval
(
)
{
static
const
TimeDuration
kOverflowRegionRefreshInterval
=
TimeDuration
:
:
FromMilliseconds
(
200
)
;
return
kOverflowRegionRefreshInterval
;
}
static
bool
IsDefinitivelyInvisibleDueToOpacity
(
const
nsIFrame
&
aFrame
)
{
if
(
!
aFrame
.
Style
(
)
-
>
IsInOpacityZeroSubtree
(
)
)
{
return
false
;
}
const
nsIFrame
*
root
=
&
aFrame
;
while
(
true
)
{
auto
*
parent
=
root
-
>
GetInFlowParent
(
)
;
if
(
!
parent
|
|
!
parent
-
>
Style
(
)
-
>
IsInOpacityZeroSubtree
(
)
)
{
break
;
}
root
=
parent
;
}
MOZ_ASSERT
(
root
&
&
root
-
>
Style
(
)
-
>
IsInOpacityZeroSubtree
(
)
)
;
if
(
root
=
=
&
aFrame
)
{
return
false
;
}
return
!
root
-
>
HasAnimationOfOpacity
(
)
;
}
static
bool
CanOptimizeAwayDueToOpacity
(
const
KeyframeEffect
&
aEffect
const
nsIFrame
&
aFrame
)
{
if
(
!
aFrame
.
Style
(
)
-
>
IsInOpacityZeroSubtree
(
)
)
{
return
false
;
}
if
(
IsDefinitivelyInvisibleDueToOpacity
(
aFrame
)
)
{
return
true
;
}
return
!
aEffect
.
HasOpacityChange
(
)
&
&
!
aFrame
.
HasAnimationOfOpacity
(
)
;
}
bool
KeyframeEffect
:
:
CanThrottleIfNotVisible
(
nsIFrame
&
aFrame
)
const
{
if
(
!
mInEffectOnLastAnimationTimingUpdate
|
|
!
CanIgnoreIfNotVisible
(
)
)
{
return
false
;
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
presShell
&
&
!
presShell
-
>
IsActive
(
)
)
{
return
true
;
}
const
bool
isVisibilityHidden
=
!
aFrame
.
IsVisibleOrMayHaveVisibleDescendants
(
)
;
const
bool
canOptimizeAwayVisibility
=
isVisibilityHidden
&
&
!
HasVisibilityChange
(
)
;
const
bool
invisible
=
canOptimizeAwayVisibility
|
|
CanOptimizeAwayDueToOpacity
(
*
this
aFrame
)
|
|
aFrame
.
IsScrolledOutOfView
(
)
;
if
(
!
invisible
)
{
return
false
;
}
if
(
!
HasPropertiesThatMightAffectOverflow
(
)
)
{
return
true
;
}
if
(
HasFiniteActiveDuration
(
)
)
{
return
false
;
}
return
isVisibilityHidden
?
CanThrottleOverflowChangesInScrollable
(
aFrame
)
:
CanThrottleOverflowChanges
(
aFrame
)
;
}
bool
KeyframeEffect
:
:
CanThrottle
(
)
const
{
if
(
!
IsInEffect
(
)
|
|
!
IsCurrent
(
)
)
{
return
false
;
}
nsIFrame
*
const
frame
=
GetStyleFrame
(
)
;
if
(
!
frame
)
{
return
true
;
}
if
(
frame
-
>
PresContext
(
)
-
>
IsPrintingOrPrintPreview
(
)
)
{
return
false
;
}
if
(
CanThrottleIfNotVisible
(
*
frame
)
)
{
return
true
;
}
EffectSet
*
effectSet
=
nullptr
;
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
if
(
!
property
.
mIsRunningOnCompositor
)
{
return
false
;
}
MOZ_ASSERT
(
nsCSSPropertyIDSet
:
:
CompositorAnimatables
(
)
.
HasProperty
(
property
.
mProperty
)
"
The
property
should
be
able
to
run
on
the
compositor
"
)
;
if
(
!
effectSet
)
{
effectSet
=
EffectSet
:
:
GetEffectSet
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
;
MOZ_ASSERT
(
effectSet
"
CanThrottle
should
be
called
on
an
effect
"
"
associated
with
a
target
element
"
)
;
}
MOZ_ASSERT
(
HasEffectiveAnimationOfProperty
(
property
.
mProperty
*
effectSet
)
"
There
should
be
an
effective
animation
of
the
property
while
"
"
it
is
marked
as
being
run
on
the
compositor
"
)
;
DisplayItemType
displayItemType
=
LayerAnimationInfo
:
:
GetDisplayItemTypeForProperty
(
property
.
mProperty
)
;
Maybe
<
uint64_t
>
generation
=
layers
:
:
AnimationInfo
:
:
GetGenerationFromFrame
(
GetPrimaryFrame
(
)
displayItemType
)
;
if
(
!
generation
|
|
effectSet
-
>
GetAnimationGeneration
(
)
!
=
*
generation
)
{
return
false
;
}
if
(
HasPropertiesThatMightAffectOverflow
(
)
&
&
!
CanThrottleOverflowChangesInScrollable
(
*
frame
)
)
{
return
false
;
}
}
return
true
;
}
bool
KeyframeEffect
:
:
CanThrottleOverflowChanges
(
const
nsIFrame
&
aFrame
)
const
{
TimeStamp
now
=
aFrame
.
PresContext
(
)
-
>
RefreshDriver
(
)
-
>
MostRecentRefresh
(
)
;
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
;
MOZ_ASSERT
(
effectSet
"
CanOverflowTransformChanges
is
expected
to
be
called
"
"
on
an
effect
in
an
effect
set
"
)
;
MOZ_ASSERT
(
mAnimation
"
CanOverflowTransformChanges
is
expected
to
be
called
"
"
on
an
effect
with
a
parent
animation
"
)
;
TimeStamp
lastSyncTime
=
effectSet
-
>
LastOverflowAnimationSyncTime
(
)
;
return
(
!
lastSyncTime
.
IsNull
(
)
&
&
(
now
-
lastSyncTime
)
<
OverflowRegionRefreshInterval
(
)
)
;
}
bool
KeyframeEffect
:
:
CanThrottleOverflowChangesInScrollable
(
nsIFrame
&
aFrame
)
const
{
Document
*
doc
=
GetRenderedDocument
(
)
;
if
(
!
doc
)
{
return
true
;
}
if
(
!
doc
-
>
HasIntersectionObservers
(
)
)
{
return
true
;
}
if
(
CanThrottleOverflowChanges
(
aFrame
)
)
{
return
true
;
}
nsIScrollableFrame
*
scrollable
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
&
aFrame
)
;
if
(
!
scrollable
)
{
return
true
;
}
ScrollStyles
ss
=
scrollable
-
>
GetScrollStyles
(
)
;
if
(
ss
.
mVertical
=
=
StyleOverflow
:
:
Hidden
&
&
ss
.
mHorizontal
=
=
StyleOverflow
:
:
Hidden
&
&
scrollable
-
>
GetLogicalScrollPosition
(
)
=
=
nsPoint
(
0
0
)
)
{
return
true
;
}
return
false
;
}
nsIFrame
*
KeyframeEffect
:
:
GetStyleFrame
(
)
const
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
nullptr
;
}
return
nsLayoutUtils
:
:
GetStyleFrame
(
frame
)
;
}
nsIFrame
*
KeyframeEffect
:
:
GetPrimaryFrame
(
)
const
{
nsIFrame
*
frame
=
nullptr
;
if
(
!
mTarget
)
{
return
frame
;
}
if
(
mTarget
.
mPseudoType
=
=
PseudoStyleType
:
:
before
)
{
frame
=
nsLayoutUtils
:
:
GetBeforeFrame
(
mTarget
.
mElement
)
;
}
else
if
(
mTarget
.
mPseudoType
=
=
PseudoStyleType
:
:
after
)
{
frame
=
nsLayoutUtils
:
:
GetAfterFrame
(
mTarget
.
mElement
)
;
}
else
if
(
mTarget
.
mPseudoType
=
=
PseudoStyleType
:
:
marker
)
{
frame
=
nsLayoutUtils
:
:
GetMarkerFrame
(
mTarget
.
mElement
)
;
}
else
{
frame
=
mTarget
.
mElement
-
>
GetPrimaryFrame
(
)
;
MOZ_ASSERT
(
mTarget
.
mPseudoType
=
=
PseudoStyleType
:
:
NotPseudo
"
unknown
mTarget
.
mPseudoType
"
)
;
}
return
frame
;
}
Document
*
KeyframeEffect
:
:
GetRenderedDocument
(
)
const
{
if
(
!
mTarget
)
{
return
nullptr
;
}
return
mTarget
.
mElement
-
>
GetComposedDoc
(
)
;
}
PresShell
*
KeyframeEffect
:
:
GetPresShell
(
)
const
{
Document
*
doc
=
GetRenderedDocument
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
return
doc
-
>
GetPresShell
(
)
;
}
bool
KeyframeEffect
:
:
IsGeometricProperty
(
const
nsCSSPropertyID
aProperty
)
{
MOZ_ASSERT
(
!
nsCSSProps
:
:
IsShorthand
(
aProperty
)
"
Property
should
be
a
longhand
property
"
)
;
switch
(
aProperty
)
{
case
eCSSProperty_bottom
:
case
eCSSProperty_height
:
case
eCSSProperty_left
:
case
eCSSProperty_margin_bottom
:
case
eCSSProperty_margin_left
:
case
eCSSProperty_margin_right
:
case
eCSSProperty_margin_top
:
case
eCSSProperty_padding_bottom
:
case
eCSSProperty_padding_left
:
case
eCSSProperty_padding_right
:
case
eCSSProperty_padding_top
:
case
eCSSProperty_right
:
case
eCSSProperty_top
:
case
eCSSProperty_width
:
return
true
;
default
:
return
false
;
}
}
bool
KeyframeEffect
:
:
CanAnimateTransformOnCompositor
(
const
nsIFrame
*
aFrame
AnimationPerformanceWarning
:
:
Type
&
aPerformanceWarning
)
{
const
nsIFrame
*
primaryFrame
=
nsLayoutUtils
:
:
GetPrimaryFrameFromStyleFrame
(
aFrame
)
;
if
(
primaryFrame
-
>
BackfaceIsHidden
(
)
)
{
aPerformanceWarning
=
AnimationPerformanceWarning
:
:
Type
:
:
TransformBackfaceVisibilityHidden
;
return
false
;
}
if
(
primaryFrame
-
>
IsSVGTransformed
(
)
)
{
aPerformanceWarning
=
AnimationPerformanceWarning
:
:
Type
:
:
TransformSVG
;
return
false
;
}
return
true
;
}
bool
KeyframeEffect
:
:
ShouldBlockAsyncTransformAnimations
(
const
nsIFrame
*
aFrame
const
nsCSSPropertyIDSet
&
aPropertySet
AnimationPerformanceWarning
:
:
Type
&
aPerformanceWarning
)
const
{
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
;
nsCSSPropertyIDSet
blockedProperties
=
effectSet
-
>
PropertiesWithImportantRules
(
)
.
Intersect
(
effectSet
-
>
PropertiesForAnimationsLevel
(
)
)
;
if
(
blockedProperties
.
Intersects
(
aPropertySet
)
)
{
aPerformanceWarning
=
AnimationPerformanceWarning
:
:
Type
:
:
TransformIsBlockedByImportantRules
;
return
true
;
}
MOZ_ASSERT
(
mAnimation
)
;
const
bool
enableMainthreadSynchronizationWithGeometricAnimations
=
StaticPrefs
:
:
dom_animations_mainthread_synchronization_with_geometric_animations
(
)
&
&
!
mAnimation
-
>
UsingScrollTimeline
(
)
;
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
if
(
effectSet
&
&
effectSet
-
>
PropertiesWithImportantRules
(
)
.
HasProperty
(
property
.
mProperty
)
&
&
effectSet
-
>
PropertiesForAnimationsLevel
(
)
.
HasProperty
(
property
.
mProperty
)
)
{
continue
;
}
if
(
enableMainthreadSynchronizationWithGeometricAnimations
&
&
IsGeometricProperty
(
property
.
mProperty
)
)
{
aPerformanceWarning
=
AnimationPerformanceWarning
:
:
Type
:
:
TransformWithGeometricProperties
;
return
true
;
}
if
(
LayerAnimationInfo
:
:
GetCSSPropertiesFor
(
DisplayItemType
:
:
TYPE_TRANSFORM
)
.
HasProperty
(
property
.
mProperty
)
)
{
if
(
!
CanAnimateTransformOnCompositor
(
aFrame
aPerformanceWarning
)
)
{
return
true
;
}
}
}
return
false
;
}
bool
KeyframeEffect
:
:
HasGeometricProperties
(
)
const
{
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
if
(
IsGeometricProperty
(
property
.
mProperty
)
)
{
return
true
;
}
}
return
false
;
}
void
KeyframeEffect
:
:
SetPerformanceWarning
(
const
nsCSSPropertyIDSet
&
aPropertySet
const
AnimationPerformanceWarning
&
aWarning
)
{
nsCSSPropertyIDSet
curr
=
aPropertySet
;
for
(
AnimationProperty
&
property
:
mProperties
)
{
if
(
!
curr
.
HasProperty
(
property
.
mProperty
)
)
{
continue
;
}
property
.
SetPerformanceWarning
(
aWarning
mTarget
.
mElement
)
;
curr
.
RemoveProperty
(
property
.
mProperty
)
;
if
(
curr
.
IsEmpty
(
)
)
{
return
;
}
}
}
already_AddRefed
<
const
ComputedStyle
>
KeyframeEffect
:
:
CreateComputedStyleForAnimationValue
(
nsCSSPropertyID
aProperty
const
AnimationValue
&
aValue
nsPresContext
*
aPresContext
const
ComputedStyle
*
aBaseComputedStyle
)
{
MOZ_ASSERT
(
aBaseComputedStyle
"
CreateComputedStyleForAnimationValue
needs
to
be
called
"
"
with
a
valid
ComputedStyle
"
)
;
Element
*
elementForResolve
=
EffectCompositor
:
:
GetElementToRestyle
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
;
if
(
!
elementForResolve
)
{
return
nullptr
;
}
ServoStyleSet
*
styleSet
=
aPresContext
-
>
StyleSet
(
)
;
return
styleSet
-
>
ResolveServoStyleByAddingAnimation
(
elementForResolve
aBaseComputedStyle
aValue
.
mServo
)
;
}
void
KeyframeEffect
:
:
CalculateCumulativeChangeHint
(
const
ComputedStyle
*
aComputedStyle
)
{
mCumulativeChangeHint
=
nsChangeHint
(
0
)
;
mNeedsStyleData
=
false
;
nsPresContext
*
presContext
=
mTarget
?
nsContentUtils
:
:
GetContextForContent
(
mTarget
.
mElement
)
:
nullptr
;
if
(
!
presContext
)
{
mNeedsStyleData
=
true
;
return
;
}
for
(
const
AnimationProperty
&
property
:
mProperties
)
{
if
(
property
.
mProperty
=
=
eCSSProperty_opacity
)
{
continue
;
}
for
(
const
AnimationPropertySegment
&
segment
:
property
.
mSegments
)
{
if
(
!
segment
.
HasReplaceableValues
(
)
)
{
if
(
!
nsCSSPropertyIDSet
:
:
TransformLikeProperties
(
)
.
HasProperty
(
property
.
mProperty
)
)
{
mCumulativeChangeHint
=
~
nsChangeHint_Hints_CanIgnoreIfNotVisible
;
return
;
}
mCumulativeChangeHint
|
=
nsChangeHint_ComprehensiveAddOrRemoveTransform
|
nsChangeHint_UpdatePostTransformOverflow
|
nsChangeHint_UpdateTransformLayer
;
continue
;
}
RefPtr
<
const
ComputedStyle
>
fromContext
=
CreateComputedStyleForAnimationValue
(
property
.
mProperty
segment
.
mFromValue
presContext
aComputedStyle
)
;
if
(
!
fromContext
)
{
mCumulativeChangeHint
=
~
nsChangeHint_Hints_CanIgnoreIfNotVisible
;
mNeedsStyleData
=
true
;
return
;
}
RefPtr
<
const
ComputedStyle
>
toContext
=
CreateComputedStyleForAnimationValue
(
property
.
mProperty
segment
.
mToValue
presContext
aComputedStyle
)
;
if
(
!
toContext
)
{
mCumulativeChangeHint
=
~
nsChangeHint_Hints_CanIgnoreIfNotVisible
;
mNeedsStyleData
=
true
;
return
;
}
uint32_t
equalStructs
=
0
;
nsChangeHint
changeHint
=
fromContext
-
>
CalcStyleDifference
(
*
toContext
&
equalStructs
)
;
mCumulativeChangeHint
|
=
changeHint
;
}
}
}
void
KeyframeEffect
:
:
SetAnimation
(
Animation
*
aAnimation
)
{
if
(
mAnimation
=
=
aAnimation
)
{
return
;
}
RequestRestyle
(
EffectCompositor
:
:
RestyleType
:
:
Layer
)
;
mAnimation
=
aAnimation
;
UpdateNormalizedTiming
(
)
;
if
(
mAnimation
)
{
mAnimation
-
>
UpdateRelevance
(
)
;
}
NotifyAnimationTimingUpdated
(
PostRestyleMode
:
:
IfNeeded
)
;
if
(
mAnimation
)
{
MarkCascadeNeedsUpdate
(
)
;
}
}
bool
KeyframeEffect
:
:
CanIgnoreIfNotVisible
(
)
const
{
if
(
!
StaticPrefs
:
:
dom_animations_offscreen_throttling
(
)
)
{
return
false
;
}
return
NS_IsHintSubset
(
mCumulativeChangeHint
nsChangeHint_Hints_CanIgnoreIfNotVisible
)
;
}
void
KeyframeEffect
:
:
MarkCascadeNeedsUpdate
(
)
{
if
(
!
mTarget
)
{
return
;
}
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
;
if
(
!
effectSet
)
{
return
;
}
effectSet
-
>
MarkCascadeNeedsUpdate
(
)
;
}
bool
KeyframeEffect
:
:
HasComputedTimingChanged
(
const
ComputedTiming
&
aComputedTiming
IterationCompositeOperation
aIterationComposite
const
Nullable
<
double
>
&
aProgressOnLastCompose
uint64_t
aCurrentIterationOnLastCompose
)
{
return
aComputedTiming
.
mProgress
!
=
aProgressOnLastCompose
|
|
(
aIterationComposite
=
=
IterationCompositeOperation
:
:
Accumulate
&
&
aComputedTiming
.
mCurrentIteration
!
=
aCurrentIterationOnLastCompose
)
;
}
bool
KeyframeEffect
:
:
HasComputedTimingChanged
(
)
const
{
ComputedTiming
computedTiming
=
GetComputedTiming
(
)
;
return
HasComputedTimingChanged
(
computedTiming
mEffectOptions
.
mIterationComposite
mProgressOnLastCompose
mCurrentIterationOnLastCompose
)
;
}
bool
KeyframeEffect
:
:
ContainsAnimatedScale
(
const
nsIFrame
*
aFrame
)
const
{
MOZ_ASSERT
(
aFrame
&
&
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSupportsCSSTransforms
)
"
We
should
be
passed
a
frame
that
supports
transforms
"
)
;
if
(
!
IsCurrent
(
)
)
{
return
false
;
}
if
(
!
mAnimation
|
|
mAnimation
-
>
ReplaceState
(
)
=
=
AnimationReplaceState
:
:
Removed
)
{
return
false
;
}
for
(
const
AnimationProperty
&
prop
:
mProperties
)
{
if
(
prop
.
mProperty
!
=
eCSSProperty_transform
&
&
prop
.
mProperty
!
=
eCSSProperty_scale
&
&
prop
.
mProperty
!
=
eCSSProperty_rotate
)
{
continue
;
}
AnimationValue
baseStyle
=
BaseStyle
(
prop
.
mProperty
)
;
if
(
!
baseStyle
.
IsNull
(
)
)
{
gfx
:
:
MatrixScales
size
=
baseStyle
.
GetScaleValue
(
aFrame
)
;
if
(
size
!
=
gfx
:
:
MatrixScales
(
)
)
{
return
true
;
}
}
for
(
const
AnimationPropertySegment
&
segment
:
prop
.
mSegments
)
{
if
(
!
segment
.
mFromValue
.
IsNull
(
)
)
{
gfx
:
:
MatrixScales
from
=
segment
.
mFromValue
.
GetScaleValue
(
aFrame
)
;
if
(
from
!
=
gfx
:
:
MatrixScales
(
)
)
{
return
true
;
}
}
if
(
!
segment
.
mToValue
.
IsNull
(
)
)
{
gfx
:
:
MatrixScales
to
=
segment
.
mToValue
.
GetScaleValue
(
aFrame
)
;
if
(
to
!
=
gfx
:
:
MatrixScales
(
)
)
{
return
true
;
}
}
}
}
return
false
;
}
void
KeyframeEffect
:
:
UpdateEffectSet
(
EffectSet
*
aEffectSet
)
const
{
if
(
!
mInEffectSet
)
{
return
;
}
EffectSet
*
effectSet
=
aEffectSet
?
aEffectSet
:
EffectSet
:
:
GetEffectSet
(
mTarget
.
mElement
mTarget
.
mPseudoType
)
;
if
(
!
effectSet
)
{
return
;
}
nsIFrame
*
styleFrame
=
GetStyleFrame
(
)
;
if
(
HasAnimationOfPropertySet
(
nsCSSPropertyIDSet
:
:
OpacityProperties
(
)
)
)
{
effectSet
-
>
SetMayHaveOpacityAnimation
(
)
;
EnumerateContinuationsOrIBSplitSiblings
(
styleFrame
[
]
(
nsIFrame
*
aFrame
)
{
aFrame
-
>
SetMayHaveOpacityAnimation
(
)
;
}
)
;
}
nsIFrame
*
primaryFrame
=
GetPrimaryFrame
(
)
;
if
(
HasAnimationOfPropertySet
(
nsCSSPropertyIDSet
:
:
TransformLikeProperties
(
)
)
)
{
effectSet
-
>
SetMayHaveTransformAnimation
(
)
;
EnumerateContinuationsOrIBSplitSiblings
(
primaryFrame
[
]
(
nsIFrame
*
aFrame
)
{
aFrame
-
>
SetMayHaveTransformAnimation
(
)
;
}
)
;
}
}
KeyframeEffect
:
:
MatchForCompositor
KeyframeEffect
:
:
IsMatchForCompositor
(
const
nsCSSPropertyIDSet
&
aPropertySet
const
nsIFrame
*
aFrame
const
EffectSet
&
aEffects
AnimationPerformanceWarning
:
:
Type
&
aPerformanceWarning
)
const
{
MOZ_ASSERT
(
mAnimation
)
;
if
(
!
mAnimation
-
>
IsRelevant
(
)
)
{
return
KeyframeEffect
:
:
MatchForCompositor
:
:
No
;
}
if
(
mAnimation
-
>
ShouldBeSynchronizedWithMainThread
(
aPropertySet
aFrame
aPerformanceWarning
)
)
{
return
KeyframeEffect
:
:
MatchForCompositor
:
:
NoAndBlockThisProperty
;
}
if
(
mAnimation
-
>
UsingScrollTimeline
(
)
)
{
const
ScrollTimeline
*
scrollTimeline
=
mAnimation
-
>
GetTimeline
(
)
-
>
AsScrollTimeline
(
)
;
if
(
!
scrollTimeline
-
>
APZIsActiveForSource
(
)
|
|
!
scrollTimeline
-
>
IsActive
(
)
|
|
!
scrollTimeline
-
>
ScrollingDirectionIsAvailable
(
)
|
|
scrollTimeline
-
>
SourceScrollStyle
(
)
=
=
StyleOverflow
:
:
Hidden
)
{
return
KeyframeEffect
:
:
MatchForCompositor
:
:
No
;
}
}
if
(
!
HasEffectiveAnimationOfPropertySet
(
aPropertySet
aEffects
)
)
{
return
KeyframeEffect
:
:
MatchForCompositor
:
:
No
;
}
if
(
!
aFrame
-
>
IsVisibleOrMayHaveVisibleDescendants
(
)
|
|
IsDefinitivelyInvisibleDueToOpacity
(
*
aFrame
)
|
|
aFrame
-
>
IsScrolledOutOfView
(
)
)
{
return
KeyframeEffect
:
:
MatchForCompositor
:
:
NoAndBlockThisProperty
;
}
if
(
aPropertySet
.
HasProperty
(
eCSSProperty_background_color
)
)
{
if
(
!
StaticPrefs
:
:
gfx_omta_background_color
(
)
)
{
return
KeyframeEffect
:
:
MatchForCompositor
:
:
No
;
}
if
(
aFrame
-
>
IsCanvasFrame
(
)
|
|
(
aFrame
-
>
GetContent
(
)
&
&
(
aFrame
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
|
|
aFrame
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
html
)
)
)
)
{
return
KeyframeEffect
:
:
MatchForCompositor
:
:
No
;
}
}
if
(
mHasCurrentColor
)
{
aPerformanceWarning
=
AnimationPerformanceWarning
:
:
Type
:
:
HasCurrentColor
;
return
KeyframeEffect
:
:
MatchForCompositor
:
:
NoAndBlockThisProperty
;
}
return
mAnimation
-
>
IsPlaying
(
)
?
KeyframeEffect
:
:
MatchForCompositor
:
:
Yes
:
KeyframeEffect
:
:
MatchForCompositor
:
:
IfNeeded
;
}
}
}
