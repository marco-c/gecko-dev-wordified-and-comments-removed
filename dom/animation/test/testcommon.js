const
MS_PER_SEC
=
1000
;
var
TIME_PRECISION
=
0
.
0005
;
function
assert_times_equal
(
actual
expected
description
)
{
assert_approx_equals
(
actual
expected
TIME_PRECISION
description
)
;
}
function
addDivAndAnimate
(
t
attrs
frames
options
)
{
let
animDur
=
(
typeof
options
=
=
=
'
object
'
)
?
options
.
duration
:
options
;
assert_greater_than_equal
(
animDur
100
*
MS_PER_SEC
'
Clients
of
this
addDivAndAnimate
API
must
request
a
duration
'
+
'
of
at
least
100s
to
avoid
intermittent
failures
from
e
.
g
.
'
+
'
the
main
thread
being
busy
for
an
extended
period
'
)
;
return
addDiv
(
t
attrs
)
.
animate
(
frames
options
)
;
}
function
addDiv
(
t
attrs
)
{
var
div
=
document
.
createElement
(
'
div
'
)
;
if
(
attrs
)
{
for
(
var
attrName
in
attrs
)
{
div
.
setAttribute
(
attrName
attrs
[
attrName
]
)
;
}
}
document
.
body
.
appendChild
(
div
)
;
if
(
t
&
&
typeof
t
.
add_cleanup
=
=
=
'
function
'
)
{
t
.
add_cleanup
(
function
(
)
{
if
(
div
.
parentNode
)
{
div
.
parentNode
.
removeChild
(
div
)
;
}
}
)
;
}
return
div
;
}
function
addStyle
(
t
rules
)
{
var
extraStyle
=
document
.
createElement
(
'
style
'
)
;
document
.
head
.
appendChild
(
extraStyle
)
;
if
(
rules
)
{
var
sheet
=
extraStyle
.
sheet
;
for
(
var
selector
in
rules
)
{
sheet
.
insertRule
(
selector
+
'
{
'
+
rules
[
selector
]
+
'
}
'
sheet
.
cssRules
.
length
)
;
}
}
if
(
t
&
&
typeof
t
.
add_cleanup
=
=
=
'
function
'
)
{
t
.
add_cleanup
(
function
(
)
{
extraStyle
.
remove
(
)
;
}
)
;
}
}
function
waitForFrame
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
window
.
requestAnimationFrame
(
resolve
)
;
}
)
;
}
function
waitForAnimationFrames
(
frameCount
onFrame
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
function
handleFrame
(
)
{
if
(
onFrame
&
&
typeof
onFrame
=
=
=
'
function
'
)
{
onFrame
(
)
;
}
if
(
-
-
frameCount
<
=
0
)
{
resolve
(
)
;
}
else
{
window
.
requestAnimationFrame
(
handleFrame
)
;
}
}
window
.
requestAnimationFrame
(
handleFrame
)
;
}
)
;
}
function
waitForAllAnimations
(
animations
)
{
return
Promise
.
all
(
animations
.
map
(
function
(
animation
)
{
return
animation
.
ready
;
}
)
)
;
}
function
flushComputedStyle
(
elem
)
{
var
cs
=
window
.
getComputedStyle
(
elem
)
;
cs
.
marginLeft
;
}
if
(
opener
)
{
for
(
var
funcName
of
[
"
async_test
"
"
assert_not_equals
"
"
assert_equals
"
"
assert_approx_equals
"
"
assert_less_than
"
"
assert_less_than_equal
"
"
assert_greater_than
"
"
assert_between_inclusive
"
"
assert_true
"
"
assert_false
"
"
assert_class_string
"
"
assert_throws
"
"
assert_unreached
"
"
promise_test
"
"
test
"
]
)
{
window
[
funcName
]
=
opener
[
funcName
]
.
bind
(
opener
)
;
}
window
.
EventWatcher
=
opener
.
EventWatcher
;
function
done
(
)
{
opener
.
add_completion_callback
(
function
(
)
{
self
.
close
(
)
;
}
)
;
opener
.
done
(
)
;
}
}
function
setupSynchronousObserver
(
t
target
subtree
)
{
var
observer
=
new
MutationObserver
(
records
=
>
{
assert_unreached
(
"
Any
MutationRecords
should
not
be
observed
in
this
"
+
"
callback
"
)
;
}
)
;
t
.
add_cleanup
(
(
)
=
>
{
observer
.
disconnect
(
)
;
}
)
;
observer
.
observe
(
target
{
animations
:
true
subtree
:
subtree
}
)
;
return
observer
;
}
function
isOMTAEnabled
(
)
{
const
OMTAPrefKey
=
'
layers
.
offmainthreadcomposition
.
async
-
animations
'
;
return
SpecialPowers
.
DOMWindowUtils
.
layerManagerRemote
&
&
SpecialPowers
.
getBoolPref
(
OMTAPrefKey
)
;
}
