const
MS_PER_SEC
=
1000
;
var
TIME_PRECISION
=
0
.
0005
;
function
assert_times_equal
(
actual
expected
description
)
{
assert_approx_equals
(
actual
expected
TIME_PRECISION
*
2
description
)
;
}
function
assert_time_equals_literal
(
actual
expected
description
)
{
assert_approx_equals
(
actual
expected
TIME_PRECISION
description
)
;
}
function
assert_matrix_equals
(
actual
expected
description
)
{
var
matrixRegExp
=
/
^
matrix
\
(
(
.
+
)
(
.
+
)
(
.
+
)
(
.
+
)
(
.
+
)
(
.
+
)
\
)
/
;
assert_regexp_match
(
actual
matrixRegExp
"
Actual
value
should
be
a
matrix
"
)
;
assert_regexp_match
(
expected
matrixRegExp
"
Expected
value
should
be
a
matrix
"
)
;
var
actualMatrixArray
=
actual
.
match
(
matrixRegExp
)
.
slice
(
1
)
.
map
(
Number
)
;
var
expectedMatrixArray
=
expected
.
match
(
matrixRegExp
)
.
slice
(
1
)
.
map
(
Number
)
;
assert_equals
(
actualMatrixArray
.
length
expectedMatrixArray
.
length
"
Array
lengths
should
be
equal
(
got
'
"
+
expected
+
"
'
and
'
"
+
actual
+
"
'
)
:
"
+
description
)
;
for
(
var
i
=
0
;
i
<
actualMatrixArray
.
length
;
i
+
+
)
{
assert_approx_equals
(
actualMatrixArray
[
i
]
expectedMatrixArray
[
i
]
0
.
01
"
Matrix
array
should
be
equal
(
got
'
"
+
expected
+
"
'
and
'
"
+
actual
+
"
'
)
:
"
+
description
)
;
}
}
function
assert_properties_equal
(
actual
expected
)
{
assert_equals
(
actual
.
length
expected
.
length
)
;
const
compareProperties
=
(
a
b
)
=
>
a
.
property
=
=
b
.
property
?
0
:
a
.
property
<
b
.
property
?
-
1
:
1
;
const
sortedActual
=
actual
.
sort
(
compareProperties
)
;
const
sortedExpected
=
expected
.
sort
(
compareProperties
)
;
const
serializeValues
=
values
=
>
values
.
map
(
value
=
>
"
{
"
+
[
"
offset
"
"
value
"
"
easing
"
"
composite
"
]
.
map
(
member
=
>
{
member
}
:
{
value
[
member
]
}
)
.
join
(
"
"
)
+
"
}
"
)
.
join
(
"
"
)
;
for
(
let
i
=
0
;
i
<
sortedActual
.
length
;
i
+
+
)
{
assert_equals
(
sortedActual
[
i
]
.
property
sortedExpected
[
i
]
.
property
"
CSS
property
name
should
match
"
)
;
assert_equals
(
serializeValues
(
sortedActual
[
i
]
.
values
)
serializeValues
(
sortedExpected
[
i
]
.
values
)
Values
arrays
do
not
match
for
+
{
sortedActual
[
i
]
.
property
}
property
)
;
}
}
function
valueFormat
(
offset
value
composite
easing
)
{
return
{
offset
:
offset
value
:
value
easing
:
easing
composite
:
composite
}
;
}
function
addDivAndAnimate
(
t
attrs
frames
options
)
{
let
animDur
=
typeof
options
=
=
=
"
object
"
?
options
.
duration
:
options
;
assert_greater_than_equal
(
animDur
100
*
MS_PER_SEC
"
Clients
of
this
addDivAndAnimate
API
must
request
a
duration
"
+
"
of
at
least
100s
to
avoid
intermittent
failures
from
e
.
g
.
"
+
"
the
main
thread
being
busy
for
an
extended
period
"
)
;
return
addDiv
(
t
attrs
)
.
animate
(
frames
options
)
;
}
function
addDiv
(
t
attrs
)
{
var
div
=
document
.
createElement
(
"
div
"
)
;
if
(
attrs
)
{
for
(
var
attrName
in
attrs
)
{
div
.
setAttribute
(
attrName
attrs
[
attrName
]
)
;
}
}
document
.
body
.
appendChild
(
div
)
;
if
(
t
&
&
typeof
t
.
add_cleanup
=
=
=
"
function
"
)
{
t
.
add_cleanup
(
function
(
)
{
if
(
div
.
parentNode
)
{
div
.
remove
(
)
;
}
}
)
;
}
return
div
;
}
function
addStyle
(
t
rules
)
{
var
extraStyle
=
document
.
createElement
(
"
style
"
)
;
document
.
head
.
appendChild
(
extraStyle
)
;
if
(
rules
)
{
var
sheet
=
extraStyle
.
sheet
;
for
(
var
selector
in
rules
)
{
sheet
.
insertRule
(
selector
+
"
{
"
+
rules
[
selector
]
+
"
}
"
sheet
.
cssRules
.
length
)
;
}
}
if
(
t
&
&
typeof
t
.
add_cleanup
=
=
=
"
function
"
)
{
t
.
add_cleanup
(
function
(
)
{
extraStyle
.
remove
(
)
;
}
)
;
}
}
function
propertyToIDL
(
property
)
{
var
prefixMatch
=
property
.
match
(
/
^
-
(
\
w
+
)
-
/
)
;
if
(
prefixMatch
)
{
var
prefix
=
prefixMatch
[
1
]
=
=
=
"
moz
"
?
"
Moz
"
:
prefixMatch
[
1
]
;
property
=
prefix
+
property
.
substring
(
prefixMatch
[
0
]
.
length
-
1
)
;
}
return
property
.
replace
(
/
-
(
[
a
-
z
]
)
/
gi
function
(
str
group
)
{
return
group
.
toUpperCase
(
)
;
}
)
;
}
function
waitForFrame
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
window
.
requestAnimationFrame
(
resolve
)
;
}
)
;
}
function
waitForNextFrame
(
)
{
const
timeAtStart
=
document
.
timeline
.
currentTime
;
return
new
Promise
(
resolve
=
>
{
window
.
requestAnimationFrame
(
(
)
=
>
{
if
(
timeAtStart
=
=
=
document
.
timeline
.
currentTime
)
{
window
.
requestAnimationFrame
(
resolve
)
;
}
else
{
resolve
(
)
;
}
}
)
;
}
)
;
}
function
waitForAnimationFrames
(
frameCount
onFrame
)
{
const
timeAtStart
=
document
.
timeline
.
currentTime
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
handleFrame
(
)
{
if
(
onFrame
&
&
typeof
onFrame
=
=
=
"
function
"
)
{
onFrame
(
)
;
}
if
(
timeAtStart
!
=
document
.
timeline
.
currentTime
&
&
-
-
frameCount
<
=
0
)
{
resolve
(
)
;
}
else
{
window
.
requestAnimationFrame
(
handleFrame
)
;
}
}
window
.
requestAnimationFrame
(
handleFrame
)
;
}
)
;
}
function
waitForIdle
(
)
{
return
new
Promise
(
resolve
=
>
{
requestIdleCallback
(
resolve
)
;
}
)
;
}
function
waitForAllAnimations
(
animations
)
{
return
Promise
.
all
(
animations
.
map
(
function
(
animation
)
{
return
animation
.
ready
;
}
)
)
;
}
function
flushComputedStyle
(
elem
)
{
var
cs
=
getComputedStyle
(
elem
)
;
cs
.
marginLeft
;
}
if
(
opener
)
{
for
(
var
funcName
of
[
"
async_test
"
"
assert_not_equals
"
"
assert_equals
"
"
assert_approx_equals
"
"
assert_less_than
"
"
assert_less_than_equal
"
"
assert_greater_than
"
"
assert_between_inclusive
"
"
assert_true
"
"
assert_false
"
"
assert_class_string
"
"
assert_throws
"
"
assert_unreached
"
"
assert_regexp_match
"
"
promise_test
"
"
test
"
]
)
{
if
(
opener
[
funcName
]
)
{
window
[
funcName
]
=
opener
[
funcName
]
.
bind
(
opener
)
;
}
}
window
.
EventWatcher
=
opener
.
EventWatcher
;
function
done
(
)
{
opener
.
add_completion_callback
(
function
(
)
{
self
.
close
(
)
;
}
)
;
opener
.
done
(
)
;
}
}
function
waitForDocumentLoad
(
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
if
(
document
.
readyState
=
=
=
"
complete
"
)
{
resolve
(
)
;
}
else
{
window
.
addEventListener
(
"
load
"
resolve
)
;
}
}
)
;
}
function
useTestRefreshMode
(
t
)
{
function
ensureNoSuppressedPaints
(
)
{
return
new
Promise
(
resolve
=
>
{
function
checkSuppressedPaints
(
)
{
if
(
!
SpecialPowers
.
DOMWindowUtils
.
paintingSuppressed
)
{
resolve
(
)
;
}
else
{
window
.
requestAnimationFrame
(
checkSuppressedPaints
)
;
}
}
checkSuppressedPaints
(
)
;
}
)
;
}
return
ensureNoSuppressedPaints
(
)
.
then
(
(
)
=
>
{
SpecialPowers
.
DOMWindowUtils
.
advanceTimeAndRefresh
(
0
)
;
t
.
add_cleanup
(
(
)
=
>
{
SpecialPowers
.
DOMWindowUtils
.
restoreNormalRefresh
(
)
;
}
)
;
}
)
;
}
function
isOMTAEnabled
(
)
{
const
OMTAPrefKey
=
"
layers
.
offmainthreadcomposition
.
async
-
animations
"
;
return
(
SpecialPowers
.
DOMWindowUtils
.
layerManagerRemote
&
&
SpecialPowers
.
getBoolPref
(
OMTAPrefKey
)
)
;
}
function
addSVGElement
(
target
tag
attrs
)
{
if
(
!
target
)
{
return
null
;
}
var
element
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
tag
)
;
if
(
attrs
)
{
for
(
var
attrName
in
attrs
)
{
element
.
setAttributeNS
(
null
attrName
attrs
[
attrName
]
)
;
}
}
target
.
appendChild
(
element
)
;
return
element
;
}
function
getDistance
(
target
prop
v1
v2
)
{
if
(
!
target
)
{
return
0
.
0
;
}
return
SpecialPowers
.
DOMWindowUtils
.
computeAnimationDistance
(
target
prop
v1
v2
)
;
}
function
waitForPaints
(
)
{
return
waitForAnimationFrames
(
2
)
;
}
function
animationStartsRightNow
(
aAnimation
)
{
return
(
aAnimation
.
startTime
=
=
=
aAnimation
.
timeline
.
currentTime
&
&
aAnimation
.
currentTime
=
=
=
0
)
;
}
async
function
waitForAnimationReadyToRestyle
(
aAnimation
)
{
await
aAnimation
.
ready
;
if
(
animationStartsRightNow
(
aAnimation
)
)
{
await
waitForNextFrame
(
)
;
}
}
