#
ifndef
mozilla_AnimationTarget_h
#
define
mozilla_AnimationTarget_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PseudoStyleType
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
class
nsAtom
;
namespace
mozilla
{
namespace
dom
{
class
Element
;
}
struct
OwningAnimationTarget
{
OwningAnimationTarget
(
)
=
default
;
OwningAnimationTarget
(
dom
:
:
Element
*
aElement
const
PseudoStyleRequest
&
aRequest
)
:
mElement
(
aElement
)
mPseudoRequest
(
aRequest
)
{
}
explicit
OwningAnimationTarget
(
dom
:
:
Element
*
aElement
)
:
mElement
(
aElement
)
{
}
bool
operator
=
=
(
const
OwningAnimationTarget
&
aOther
)
const
{
return
mElement
=
=
aOther
.
mElement
&
&
mPseudoRequest
=
=
aOther
.
mPseudoRequest
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mElement
;
}
RefPtr
<
dom
:
:
Element
>
mElement
;
PseudoStyleRequest
mPseudoRequest
;
}
;
struct
NonOwningAnimationTarget
{
NonOwningAnimationTarget
(
)
=
default
;
NonOwningAnimationTarget
(
dom
:
:
Element
*
aElement
const
PseudoStyleRequest
&
aRequest
)
:
mElement
(
aElement
)
mPseudoRequest
(
aRequest
)
{
}
explicit
NonOwningAnimationTarget
(
const
OwningAnimationTarget
&
aOther
)
:
mElement
(
aOther
.
mElement
)
mPseudoRequest
(
aOther
.
mPseudoRequest
)
{
}
bool
operator
=
=
(
const
NonOwningAnimationTarget
&
aOther
)
const
{
return
mElement
=
=
aOther
.
mElement
&
&
mPseudoRequest
=
=
aOther
.
mPseudoRequest
;
}
NonOwningAnimationTarget
&
operator
=
(
const
OwningAnimationTarget
&
aOther
)
{
mElement
=
aOther
.
mElement
;
mPseudoRequest
=
aOther
.
mPseudoRequest
;
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mElement
;
}
dom
:
:
Element
*
MOZ_NON_OWNING_REF
mElement
=
nullptr
;
PseudoStyleRequest
mPseudoRequest
;
}
;
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
Maybe
<
OwningAnimationTarget
>
&
aTarget
const
char
*
aName
uint32_t
aFlags
=
0
)
{
if
(
aTarget
)
{
ImplCycleCollectionTraverse
(
aCallback
aTarget
-
>
mElement
aName
aFlags
)
;
}
}
inline
void
ImplCycleCollectionUnlink
(
Maybe
<
OwningAnimationTarget
>
&
aTarget
)
{
if
(
aTarget
)
{
ImplCycleCollectionUnlink
(
aTarget
-
>
mElement
)
;
}
}
template
<
>
struct
DefaultHasher
<
OwningAnimationTarget
>
{
using
Key
=
OwningAnimationTarget
;
using
Lookup
=
OwningAnimationTarget
;
using
PtrHasher
=
PointerHasher
<
dom
:
:
Element
*
>
;
using
AtomPtrHasher
=
DefaultHasher
<
nsAtom
*
>
;
static
HashNumber
hash
(
const
Lookup
&
aLookup
)
{
return
AddToHash
(
PtrHasher
:
:
hash
(
aLookup
.
mElement
.
get
(
)
)
static_cast
<
uint8_t
>
(
aLookup
.
mPseudoRequest
.
mType
)
AtomPtrHasher
:
:
hash
(
aLookup
.
mPseudoRequest
.
mIdentifier
.
get
(
)
)
)
;
}
static
bool
match
(
const
Key
&
aKey
const
Lookup
&
aLookup
)
{
return
PtrHasher
:
:
match
(
aKey
.
mElement
.
get
(
)
aLookup
.
mElement
.
get
(
)
)
&
&
aKey
.
mPseudoRequest
.
mType
=
=
aLookup
.
mPseudoRequest
.
mType
&
&
AtomPtrHasher
:
:
match
(
aKey
.
mPseudoRequest
.
mIdentifier
.
get
(
)
aLookup
.
mPseudoRequest
.
mIdentifier
.
get
(
)
)
;
}
static
void
rekey
(
Key
&
aKey
Key
&
&
aNewKey
)
{
aKey
=
std
:
:
move
(
aNewKey
)
;
}
}
;
}
#
endif
