#
ifndef
mozilla_AnimationTarget_h
#
define
mozilla_AnimationTarget_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
namespace
mozilla
{
namespace
dom
{
class
Element
;
}
struct
OwningAnimationTarget
{
OwningAnimationTarget
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aType
)
:
mElement
(
aElement
)
mPseudoType
(
aType
)
{
}
explicit
OwningAnimationTarget
(
dom
:
:
Element
*
aElement
)
:
mElement
(
aElement
)
{
}
bool
operator
=
=
(
const
OwningAnimationTarget
&
aOther
)
const
{
return
mElement
=
=
aOther
.
mElement
&
&
mPseudoType
=
=
aOther
.
mPseudoType
;
}
RefPtr
<
dom
:
:
Element
>
mElement
;
CSSPseudoElementType
mPseudoType
=
CSSPseudoElementType
:
:
NotPseudo
;
}
;
struct
NonOwningAnimationTarget
{
NonOwningAnimationTarget
(
)
=
default
;
NonOwningAnimationTarget
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aType
)
:
mElement
(
aElement
)
mPseudoType
(
aType
)
{
}
explicit
NonOwningAnimationTarget
(
const
OwningAnimationTarget
&
aOther
)
:
mElement
(
aOther
.
mElement
)
mPseudoType
(
aOther
.
mPseudoType
)
{
}
bool
operator
=
=
(
const
NonOwningAnimationTarget
&
aOther
)
const
{
return
mElement
=
=
aOther
.
mElement
&
&
mPseudoType
=
=
aOther
.
mPseudoType
;
}
dom
:
:
Element
*
MOZ_NON_OWNING_REF
mElement
=
nullptr
;
CSSPseudoElementType
mPseudoType
=
CSSPseudoElementType
:
:
NotPseudo
;
}
;
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
Maybe
<
OwningAnimationTarget
>
&
aTarget
const
char
*
aName
uint32_t
aFlags
=
0
)
{
if
(
aTarget
)
{
ImplCycleCollectionTraverse
(
aCallback
aTarget
-
>
mElement
aName
aFlags
)
;
}
}
inline
void
ImplCycleCollectionUnlink
(
Maybe
<
OwningAnimationTarget
>
&
aTarget
)
{
if
(
aTarget
)
{
ImplCycleCollectionUnlink
(
aTarget
-
>
mElement
)
;
}
}
}
#
endif
