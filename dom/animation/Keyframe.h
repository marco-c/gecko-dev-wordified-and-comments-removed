#
ifndef
mozilla_dom_Keyframe_h
#
define
mozilla_dom_Keyframe_h
#
include
"
nsCSSPropertyID
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
struct
RawServoDeclarationBlock
;
namespace
mozilla
{
namespace
dom
{
enum
class
CompositeOperation
:
uint8_t
;
}
struct
PropertyValuePair
{
explicit
PropertyValuePair
(
nsCSSPropertyID
aProperty
)
:
mProperty
(
aProperty
)
{
}
PropertyValuePair
(
nsCSSPropertyID
aProperty
nsCSSValue
&
&
aValue
)
:
mProperty
(
aProperty
)
mValue
(
Move
(
aValue
)
)
{
}
PropertyValuePair
(
nsCSSPropertyID
aProperty
RefPtr
<
RawServoDeclarationBlock
>
&
&
aValue
)
:
mProperty
(
aProperty
)
mServoDeclarationBlock
(
Move
(
aValue
)
)
{
MOZ_ASSERT
(
mServoDeclarationBlock
"
Should
be
valid
property
value
"
)
;
}
nsCSSPropertyID
mProperty
;
nsCSSValue
mValue
;
RefPtr
<
RawServoDeclarationBlock
>
mServoDeclarationBlock
;
#
ifdef
DEBUG
bool
mSimulateComputeValuesFailure
=
false
;
#
endif
bool
operator
=
=
(
const
PropertyValuePair
&
)
const
;
}
;
struct
Keyframe
{
Keyframe
(
)
=
default
;
Keyframe
(
const
Keyframe
&
aOther
)
=
default
;
Keyframe
(
Keyframe
&
&
aOther
)
{
*
this
=
Move
(
aOther
)
;
}
Keyframe
&
operator
=
(
const
Keyframe
&
aOther
)
=
default
;
Keyframe
&
operator
=
(
Keyframe
&
&
aOther
)
{
mOffset
=
aOther
.
mOffset
;
mComputedOffset
=
aOther
.
mComputedOffset
;
mTimingFunction
=
Move
(
aOther
.
mTimingFunction
)
;
mComposite
=
Move
(
aOther
.
mComposite
)
;
mPropertyValues
=
Move
(
aOther
.
mPropertyValues
)
;
return
*
this
;
}
Maybe
<
double
>
mOffset
;
static
constexpr
double
kComputedOffsetNotSet
=
-
1
.
0
;
double
mComputedOffset
=
kComputedOffsetNotSet
;
Maybe
<
ComputedTimingFunction
>
mTimingFunction
;
Maybe
<
dom
:
:
CompositeOperation
>
mComposite
;
nsTArray
<
PropertyValuePair
>
mPropertyValues
;
}
;
}
#
endif
