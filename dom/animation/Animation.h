#
ifndef
mozilla_dom_Animation_h
#
define
mozilla_dom_Animation_h
#
include
"
X11UndefineNone
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
mozilla
/
AnimationPerformanceWarning
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PostRestyleMode
.
h
"
#
include
"
mozilla
/
StickyTimeDuration
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
AnimationBinding
.
h
"
#
include
"
mozilla
/
dom
/
AnimationTimeline
.
h
"
struct
JSContext
;
class
nsCSSPropertyIDSet
;
class
nsIFrame
;
class
nsIGlobalObject
;
namespace
mozilla
{
struct
AnimationRule
;
class
MicroTaskRunnable
;
namespace
dom
{
class
AnimationEffect
;
class
AsyncFinishNotification
;
class
CSSAnimation
;
class
CSSTransition
;
class
Document
;
class
Promise
;
class
Animation
:
public
DOMEventTargetHelper
public
LinkedListElement
<
Animation
>
{
protected
:
virtual
~
Animation
(
)
;
public
:
explicit
Animation
(
nsIGlobalObject
*
aGlobal
)
;
static
already_AddRefed
<
Animation
>
ClonePausedAnimation
(
nsIGlobalObject
*
aGlobal
const
Animation
&
aOther
AnimationEffect
&
aEffect
AnimationTimeline
&
aTimeline
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
Animation
DOMEventTargetHelper
)
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
GetOwnerGlobal
(
)
;
}
NonOwningAnimationTarget
GetTargetForAnimation
(
)
const
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
virtual
CSSAnimation
*
AsCSSAnimation
(
)
{
return
nullptr
;
}
virtual
const
CSSAnimation
*
AsCSSAnimation
(
)
const
{
return
nullptr
;
}
virtual
CSSTransition
*
AsCSSTransition
(
)
{
return
nullptr
;
}
virtual
const
CSSTransition
*
AsCSSTransition
(
)
const
{
return
nullptr
;
}
enum
class
LimitBehavior
{
AutoRewind
Continue
}
;
static
already_AddRefed
<
Animation
>
Constructor
(
const
GlobalObject
&
aGlobal
AnimationEffect
*
aEffect
const
Optional
<
AnimationTimeline
*
>
&
aTimeline
ErrorResult
&
aRv
)
;
void
GetId
(
nsAString
&
aResult
)
const
{
aResult
=
mId
;
}
void
SetId
(
const
nsAString
&
aId
)
;
AnimationEffect
*
GetEffect
(
)
const
{
return
mEffect
;
}
virtual
void
SetEffect
(
AnimationEffect
*
aEffect
)
;
void
SetEffectNoUpdate
(
AnimationEffect
*
aEffect
)
;
already_AddRefed
<
AnimationTimeline
>
GetTimelineFromJS
(
)
const
{
return
mTimeline
&
&
mTimeline
-
>
IsScrollTimeline
(
)
?
nullptr
:
do_AddRef
(
mTimeline
)
;
}
void
SetTimelineFromJS
(
AnimationTimeline
*
aTimeline
)
{
SetTimeline
(
aTimeline
)
;
}
AnimationTimeline
*
GetTimeline
(
)
const
{
return
mTimeline
;
}
void
SetTimeline
(
AnimationTimeline
*
aTimeline
)
;
void
SetTimelineNoUpdate
(
AnimationTimeline
*
aTimeline
)
;
Nullable
<
TimeDuration
>
GetStartTime
(
)
const
{
return
mStartTime
;
}
Nullable
<
double
>
GetStartTimeAsDouble
(
)
const
;
void
SetStartTime
(
const
Nullable
<
TimeDuration
>
&
aNewStartTime
)
;
virtual
void
SetStartTimeAsDouble
(
const
Nullable
<
double
>
&
aStartTime
)
;
Nullable
<
TimeDuration
>
GetCurrentTimeAsDuration
(
)
const
{
return
GetCurrentTimeForHoldTime
(
mHoldTime
)
;
}
Nullable
<
double
>
GetCurrentTimeAsDouble
(
)
const
;
void
SetCurrentTime
(
const
TimeDuration
&
aSeekTime
)
;
void
SetCurrentTimeNoUpdate
(
const
TimeDuration
&
aSeekTime
)
;
void
SetCurrentTimeAsDouble
(
const
Nullable
<
double
>
&
aCurrentTime
ErrorResult
&
aRv
)
;
double
PlaybackRate
(
)
const
{
return
mPlaybackRate
;
}
void
SetPlaybackRate
(
double
aPlaybackRate
)
;
AnimationPlayState
PlayState
(
)
const
;
virtual
AnimationPlayState
PlayStateFromJS
(
)
const
{
return
PlayState
(
)
;
}
bool
Pending
(
)
const
{
return
mPendingState
!
=
PendingState
:
:
NotPending
;
}
virtual
bool
PendingFromJS
(
)
const
{
return
Pending
(
)
;
}
AnimationReplaceState
ReplaceState
(
)
const
{
return
mReplaceState
;
}
virtual
Promise
*
GetReady
(
ErrorResult
&
aRv
)
;
Promise
*
GetFinished
(
ErrorResult
&
aRv
)
;
IMPL_EVENT_HANDLER
(
finish
)
;
IMPL_EVENT_HANDLER
(
cancel
)
;
IMPL_EVENT_HANDLER
(
remove
)
;
void
Cancel
(
PostRestyleMode
aPostRestyle
=
PostRestyleMode
:
:
IfNeeded
)
;
void
Finish
(
ErrorResult
&
aRv
)
;
void
Play
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
;
virtual
void
PlayFromJS
(
ErrorResult
&
aRv
)
{
Play
(
aRv
LimitBehavior
:
:
AutoRewind
)
;
}
void
Pause
(
ErrorResult
&
aRv
)
;
virtual
void
PauseFromJS
(
ErrorResult
&
aRv
)
{
Pause
(
aRv
)
;
}
void
UpdatePlaybackRate
(
double
aPlaybackRate
)
;
virtual
void
Reverse
(
ErrorResult
&
aRv
)
;
void
Persist
(
)
;
MOZ_CAN_RUN_SCRIPT
void
CommitStyles
(
ErrorResult
&
aRv
)
;
bool
IsRunningOnCompositor
(
)
const
;
virtual
void
Tick
(
)
;
bool
NeedsTicks
(
)
const
{
return
Pending
(
)
|
|
(
PlayState
(
)
=
=
AnimationPlayState
:
:
Running
&
&
PlaybackRate
(
)
!
=
0
.
0
)
|
|
(
mTimeline
&
&
!
mTimeline
-
>
IsMonotonicallyIncreasing
(
)
&
&
PlayState
(
)
!
=
AnimationPlayState
:
:
Idle
)
;
}
void
TriggerOnNextTick
(
const
Nullable
<
TimeDuration
>
&
aReadyTime
)
;
void
TriggerNow
(
)
;
bool
TryTriggerNowForFiniteTimeline
(
)
;
Nullable
<
TimeDuration
>
GetCurrentOrPendingStartTime
(
)
const
;
double
CurrentOrPendingPlaybackRate
(
)
const
{
return
mPendingPlaybackRate
.
valueOr
(
mPlaybackRate
)
;
}
bool
HasPendingPlaybackRate
(
)
const
{
return
mPendingPlaybackRate
.
isSome
(
)
;
}
static
TimeDuration
CurrentTimeFromTimelineTime
(
const
TimeDuration
&
aTimelineTime
const
TimeDuration
&
aStartTime
float
aPlaybackRate
)
{
return
(
aTimelineTime
-
aStartTime
)
.
MultDouble
(
aPlaybackRate
)
;
}
static
TimeDuration
StartTimeFromTimelineTime
(
const
TimeDuration
&
aTimelineTime
const
TimeDuration
&
aCurrentTime
float
aPlaybackRate
)
{
TimeDuration
result
=
aTimelineTime
;
if
(
aPlaybackRate
=
=
0
)
{
return
result
;
}
result
-
=
aCurrentTime
.
MultDouble
(
1
.
0
/
aPlaybackRate
)
;
return
result
;
}
TimeStamp
AnimationTimeToTimeStamp
(
const
StickyTimeDuration
&
aTime
)
const
;
TimeStamp
ElapsedTimeToTimeStamp
(
const
StickyTimeDuration
&
aElapsedTime
)
const
;
bool
IsPausedOrPausing
(
)
const
{
return
PlayState
(
)
=
=
AnimationPlayState
:
:
Paused
;
}
bool
HasCurrentEffect
(
)
const
;
bool
IsInEffect
(
)
const
;
bool
IsPlaying
(
)
const
{
return
mPlaybackRate
!
=
0
.
0
&
&
mTimeline
&
&
!
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
&
&
PlayState
(
)
=
=
AnimationPlayState
:
:
Running
;
}
bool
ShouldBeSynchronizedWithMainThread
(
const
nsCSSPropertyIDSet
&
aPropertySet
const
nsIFrame
*
aFrame
AnimationPerformanceWarning
:
:
Type
&
aPerformanceWarning
)
const
;
bool
IsRelevant
(
)
const
{
return
mIsRelevant
;
}
void
UpdateRelevance
(
)
;
bool
IsReplaceable
(
)
const
;
bool
IsRemovable
(
)
const
;
void
Remove
(
)
;
bool
HasLowerCompositeOrderThan
(
const
Animation
&
aOther
)
const
;
virtual
EffectCompositor
:
:
CascadeLevel
CascadeLevel
(
)
const
{
return
EffectCompositor
:
:
CascadeLevel
:
:
Animations
;
}
bool
CanThrottle
(
)
const
;
void
WillComposeStyle
(
)
;
void
ComposeStyle
(
StyleAnimationValueMap
&
aComposeResult
const
nsCSSPropertyIDSet
&
aPropertiesToSkip
)
;
void
NotifyEffectTimingUpdated
(
)
;
void
NotifyEffectPropertiesUpdated
(
)
;
void
NotifyEffectTargetUpdated
(
)
;
void
NotifyGeometricAnimationsStartingThisFrame
(
)
;
void
ReschedulePendingTasks
(
)
;
virtual
void
MaybeQueueCancelEvent
(
const
StickyTimeDuration
&
aActiveTime
)
{
}
;
Maybe
<
uint32_t
>
&
CachedChildIndexRef
(
)
{
return
mCachedChildIndex
;
}
void
SetPartialPrerendered
(
uint64_t
aIdOnCompositor
)
{
mIdOnCompositor
=
aIdOnCompositor
;
mIsPartialPrerendered
=
true
;
}
bool
IsPartialPrerendered
(
)
const
{
return
mIsPartialPrerendered
;
}
uint64_t
IdOnCompositor
(
)
const
{
return
mIdOnCompositor
;
}
void
ResetPartialPrerendered
(
)
{
MOZ_ASSERT
(
mIsPartialPrerendered
)
;
mIsPartialPrerendered
=
false
;
mIdOnCompositor
=
0
;
}
void
UpdatePartialPrerendered
(
)
{
ResetPartialPrerendered
(
)
;
PostUpdate
(
)
;
}
bool
UsingScrollTimeline
(
)
const
{
return
mTimeline
&
&
mTimeline
-
>
IsScrollTimeline
(
)
;
}
enum
class
ProgressTimelinePosition
:
uint8_t
{
Boundary
NotBoundary
}
;
static
ProgressTimelinePosition
AtProgressTimelineBoundary
(
const
Nullable
<
TimeDuration
>
&
aTimelineDuration
const
Nullable
<
TimeDuration
>
&
aCurrentTime
const
TimeDuration
&
aEffectStartTime
const
double
aPlaybackRate
)
;
ProgressTimelinePosition
AtProgressTimelineBoundary
(
)
const
{
Nullable
<
TimeDuration
>
currentTime
=
GetUnconstrainedCurrentTime
(
)
;
return
AtProgressTimelineBoundary
(
mTimeline
?
mTimeline
-
>
TimelineDuration
(
)
:
nullptr
!
currentTime
.
IsNull
(
)
?
currentTime
:
GetCurrentTimeAsDuration
(
)
mStartTime
.
IsNull
(
)
?
TimeDuration
(
)
:
mStartTime
.
Value
(
)
mPlaybackRate
)
;
}
void
SetHiddenByContentVisibility
(
bool
hidden
)
;
bool
IsHiddenByContentVisibility
(
)
const
{
return
mHiddenByContentVisibility
;
}
DocGroup
*
GetDocGroup
(
)
;
protected
:
void
SilentlySetCurrentTime
(
const
TimeDuration
&
aNewCurrentTime
)
;
void
CancelNoUpdate
(
)
;
void
PlayNoUpdate
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
;
void
ResumeAt
(
const
TimeDuration
&
aReadyTime
)
;
void
PauseAt
(
const
TimeDuration
&
aReadyTime
)
;
void
FinishPendingAt
(
const
TimeDuration
&
aReadyTime
)
{
if
(
mPendingState
=
=
PendingState
:
:
PlayPending
)
{
ResumeAt
(
aReadyTime
)
;
}
else
if
(
mPendingState
=
=
PendingState
:
:
PausePending
)
{
PauseAt
(
aReadyTime
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Can
'
t
finish
pending
if
we
'
re
not
in
a
pending
state
"
)
;
}
}
void
ApplyPendingPlaybackRate
(
)
{
if
(
mPendingPlaybackRate
)
{
mPlaybackRate
=
*
mPendingPlaybackRate
;
mPendingPlaybackRate
.
reset
(
)
;
}
}
enum
class
SeekFlag
{
NoSeek
DidSeek
}
;
enum
class
SyncNotifyFlag
{
Sync
Async
}
;
virtual
void
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
;
void
UpdateFinishedState
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
;
void
UpdateEffect
(
PostRestyleMode
aPostRestyle
)
;
void
FlushUnanimatedStyle
(
)
const
;
void
PostUpdate
(
)
;
void
ResetFinishedPromise
(
)
;
void
MaybeResolveFinishedPromise
(
)
;
void
DoFinishNotification
(
SyncNotifyFlag
aSyncNotifyFlag
)
;
friend
class
AsyncFinishNotification
;
void
DoFinishNotificationImmediately
(
MicroTaskRunnable
*
aAsync
=
nullptr
)
;
void
QueuePlaybackEvent
(
const
nsAString
&
aName
TimeStamp
&
&
aScheduledEventTime
)
;
void
CancelPendingTasks
(
)
;
void
ResetPendingTasks
(
)
;
bool
IsNewlyStarted
(
)
const
{
return
mPendingState
=
=
PendingState
:
:
PlayPending
&
&
mPendingReadyTime
.
IsNull
(
)
&
&
mStartTime
.
IsNull
(
)
;
}
bool
IsPossiblyOrphanedPendingAnimation
(
)
const
;
StickyTimeDuration
EffectEnd
(
)
const
;
Nullable
<
TimeDuration
>
GetCurrentTimeForHoldTime
(
const
Nullable
<
TimeDuration
>
&
aHoldTime
)
const
;
Nullable
<
TimeDuration
>
GetUnconstrainedCurrentTime
(
)
const
{
return
GetCurrentTimeForHoldTime
(
Nullable
<
TimeDuration
>
(
)
)
;
}
void
ScheduleReplacementCheck
(
)
;
void
MaybeScheduleReplacementCheck
(
)
;
StickyTimeDuration
IntervalStartTime
(
const
StickyTimeDuration
&
aActiveDuration
)
const
;
StickyTimeDuration
IntervalEndTime
(
const
StickyTimeDuration
&
aActiveDuration
)
const
;
TimeStamp
GetTimelineCurrentTimeAsTimeStamp
(
)
const
{
return
mTimeline
?
mTimeline
-
>
GetCurrentTimeAsTimeStamp
(
)
:
TimeStamp
(
)
;
}
Document
*
GetRenderedDocument
(
)
const
;
Document
*
GetTimelineDocument
(
)
const
;
bool
HasFiniteTimeline
(
)
const
{
return
mTimeline
&
&
!
mTimeline
-
>
IsMonotonicallyIncreasing
(
)
;
}
void
UpdatePendingAnimationTracker
(
AnimationTimeline
*
aOldTimeline
AnimationTimeline
*
aNewTimeline
)
;
RefPtr
<
AnimationTimeline
>
mTimeline
;
RefPtr
<
AnimationEffect
>
mEffect
;
Nullable
<
TimeDuration
>
mStartTime
;
Nullable
<
TimeDuration
>
mHoldTime
;
Nullable
<
TimeDuration
>
mPendingReadyTime
;
Nullable
<
TimeDuration
>
mPreviousCurrentTime
;
double
mPlaybackRate
=
1
.
0
;
Maybe
<
double
>
mPendingPlaybackRate
;
RefPtr
<
Promise
>
mReady
;
RefPtr
<
Promise
>
mFinished
;
static
uint64_t
sNextAnimationIndex
;
uint64_t
mAnimationIndex
;
Maybe
<
uint32_t
>
mCachedChildIndex
;
enum
class
PendingState
:
uint8_t
{
NotPending
PlayPending
PausePending
}
;
PendingState
mPendingState
=
PendingState
:
:
NotPending
;
AnimationReplaceState
mReplaceState
=
AnimationReplaceState
:
:
Active
;
bool
mFinishedAtLastComposeStyle
=
false
;
bool
mWasReplaceableAtLastTick
=
false
;
bool
mHiddenByContentVisibility
=
false
;
bool
mIsRelevant
=
false
;
bool
mFinishedIsResolved
=
false
;
bool
mSyncWithGeometricAnimations
=
false
;
RefPtr
<
MicroTaskRunnable
>
mFinishNotificationTask
;
nsString
mId
;
bool
mResetCurrentTimeOnResume
=
false
;
RTPCallerType
mRTPCallerType
;
private
:
uint64_t
mIdOnCompositor
=
0
;
bool
mIsPartialPrerendered
=
false
;
}
;
}
}
#
endif
