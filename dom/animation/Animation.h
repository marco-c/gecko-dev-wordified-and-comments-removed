#
ifndef
mozilla_dom_Animation_h
#
define
mozilla_dom_Animation_h
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
mozilla
/
AnimationPerformanceWarning
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PostRestyleMode
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
AnimationBinding
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffect
.
h
"
#
include
"
mozilla
/
dom
/
AnimationTimeline
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
ifdef
CurrentTime
#
undef
CurrentTime
#
endif
struct
JSContext
;
class
nsCSSPropertyIDSet
;
class
nsIFrame
;
namespace
mozilla
{
struct
AnimationRule
;
namespace
dom
{
class
AsyncFinishNotification
;
class
CSSAnimation
;
class
CSSTransition
;
class
Document
;
class
Animation
:
public
DOMEventTargetHelper
public
LinkedListElement
<
Animation
>
{
protected
:
virtual
~
Animation
(
)
{
}
public
:
explicit
Animation
(
nsIGlobalObject
*
aGlobal
)
:
DOMEventTargetHelper
(
aGlobal
)
mAnimationIndex
(
sNextAnimationIndex
+
+
)
{
}
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
Animation
DOMEventTargetHelper
)
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
GetOwnerGlobal
(
)
;
}
NonOwningAnimationTarget
GetTargetForAnimation
(
)
const
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
virtual
CSSAnimation
*
AsCSSAnimation
(
)
{
return
nullptr
;
}
virtual
const
CSSAnimation
*
AsCSSAnimation
(
)
const
{
return
nullptr
;
}
virtual
CSSTransition
*
AsCSSTransition
(
)
{
return
nullptr
;
}
virtual
const
CSSTransition
*
AsCSSTransition
(
)
const
{
return
nullptr
;
}
enum
class
LimitBehavior
{
AutoRewind
Continue
}
;
static
already_AddRefed
<
Animation
>
Constructor
(
const
GlobalObject
&
aGlobal
AnimationEffect
*
aEffect
const
Optional
<
AnimationTimeline
*
>
&
aTimeline
ErrorResult
&
aRv
)
;
void
GetId
(
nsAString
&
aResult
)
const
{
aResult
=
mId
;
}
void
SetId
(
const
nsAString
&
aId
)
;
AnimationEffect
*
GetEffect
(
)
const
{
return
mEffect
;
}
void
SetEffect
(
AnimationEffect
*
aEffect
)
;
void
SetEffectNoUpdate
(
AnimationEffect
*
aEffect
)
;
AnimationTimeline
*
GetTimeline
(
)
const
{
return
mTimeline
;
}
void
SetTimeline
(
AnimationTimeline
*
aTimeline
)
;
void
SetTimelineNoUpdate
(
AnimationTimeline
*
aTimeline
)
;
Nullable
<
TimeDuration
>
GetStartTime
(
)
const
{
return
mStartTime
;
}
Nullable
<
double
>
GetStartTimeAsDouble
(
)
const
;
void
SetStartTime
(
const
Nullable
<
TimeDuration
>
&
aNewStartTime
)
;
void
SetStartTimeAsDouble
(
const
Nullable
<
double
>
&
aStartTime
)
;
Nullable
<
TimeDuration
>
GetCurrentTimeAsDuration
(
)
const
{
return
GetCurrentTimeForHoldTime
(
mHoldTime
)
;
}
Nullable
<
double
>
GetCurrentTimeAsDouble
(
)
const
;
void
SetCurrentTime
(
const
TimeDuration
&
aNewCurrentTime
)
;
void
SetCurrentTimeAsDouble
(
const
Nullable
<
double
>
&
aCurrentTime
ErrorResult
&
aRv
)
;
double
PlaybackRate
(
)
const
{
return
mPlaybackRate
;
}
void
SetPlaybackRate
(
double
aPlaybackRate
)
;
AnimationPlayState
PlayState
(
)
const
;
virtual
AnimationPlayState
PlayStateFromJS
(
)
const
{
return
PlayState
(
)
;
}
bool
Pending
(
)
const
{
return
mPendingState
!
=
PendingState
:
:
NotPending
;
}
virtual
bool
PendingFromJS
(
)
const
{
return
Pending
(
)
;
}
AnimationReplaceState
ReplaceState
(
)
const
{
return
mReplaceState
;
}
virtual
Promise
*
GetReady
(
ErrorResult
&
aRv
)
;
Promise
*
GetFinished
(
ErrorResult
&
aRv
)
;
IMPL_EVENT_HANDLER
(
finish
)
;
IMPL_EVENT_HANDLER
(
cancel
)
;
IMPL_EVENT_HANDLER
(
remove
)
;
void
Cancel
(
PostRestyleMode
aPostRestyle
=
PostRestyleMode
:
:
IfNeeded
)
;
void
Finish
(
ErrorResult
&
aRv
)
;
virtual
void
Play
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
;
virtual
void
PlayFromJS
(
ErrorResult
&
aRv
)
{
Play
(
aRv
LimitBehavior
:
:
AutoRewind
)
;
}
virtual
void
Pause
(
ErrorResult
&
aRv
)
;
void
PauseFromJS
(
ErrorResult
&
aRv
)
{
Pause
(
aRv
)
;
}
void
UpdatePlaybackRate
(
double
aPlaybackRate
)
;
void
Reverse
(
ErrorResult
&
aRv
)
;
void
Persist
(
)
;
void
CommitStyles
(
ErrorResult
&
aRv
)
;
bool
IsRunningOnCompositor
(
)
const
;
virtual
void
Tick
(
)
;
bool
NeedsTicks
(
)
const
{
return
Pending
(
)
|
|
(
PlayState
(
)
=
=
AnimationPlayState
:
:
Running
&
&
PlaybackRate
(
)
!
=
0
.
0
)
;
}
void
TriggerOnNextTick
(
const
Nullable
<
TimeDuration
>
&
aReadyTime
)
;
void
TriggerNow
(
)
;
Nullable
<
TimeDuration
>
GetCurrentOrPendingStartTime
(
)
const
;
double
CurrentOrPendingPlaybackRate
(
)
const
{
return
mPendingPlaybackRate
.
valueOr
(
mPlaybackRate
)
;
}
bool
HasPendingPlaybackRate
(
)
const
{
return
mPendingPlaybackRate
.
isSome
(
)
;
}
static
TimeDuration
CurrentTimeFromTimelineTime
(
const
TimeDuration
&
aTimelineTime
const
TimeDuration
&
aStartTime
float
aPlaybackRate
)
{
return
(
aTimelineTime
-
aStartTime
)
.
MultDouble
(
aPlaybackRate
)
;
}
static
TimeDuration
StartTimeFromTimelineTime
(
const
TimeDuration
&
aTimelineTime
const
TimeDuration
&
aCurrentTime
float
aPlaybackRate
)
{
TimeDuration
result
=
aTimelineTime
;
if
(
aPlaybackRate
=
=
0
)
{
return
result
;
}
result
-
=
aCurrentTime
.
MultDouble
(
1
.
0
/
aPlaybackRate
)
;
return
result
;
}
TimeStamp
AnimationTimeToTimeStamp
(
const
StickyTimeDuration
&
aTime
)
const
;
TimeStamp
ElapsedTimeToTimeStamp
(
const
StickyTimeDuration
&
aElapsedTime
)
const
;
bool
IsPausedOrPausing
(
)
const
{
return
PlayState
(
)
=
=
AnimationPlayState
:
:
Paused
;
}
bool
HasCurrentEffect
(
)
const
{
return
GetEffect
(
)
&
&
GetEffect
(
)
-
>
IsCurrent
(
)
;
}
bool
IsInEffect
(
)
const
{
return
GetEffect
(
)
&
&
GetEffect
(
)
-
>
IsInEffect
(
)
;
}
bool
IsPlaying
(
)
const
{
return
mPlaybackRate
!
=
0
.
0
&
&
mTimeline
&
&
!
mTimeline
-
>
GetCurrentTimeAsDuration
(
)
.
IsNull
(
)
&
&
PlayState
(
)
=
=
AnimationPlayState
:
:
Running
;
}
bool
ShouldBeSynchronizedWithMainThread
(
const
nsCSSPropertyIDSet
&
aPropertySet
const
nsIFrame
*
aFrame
AnimationPerformanceWarning
:
:
Type
&
aPerformanceWarning
)
const
;
bool
IsRelevant
(
)
const
{
return
mIsRelevant
;
}
void
UpdateRelevance
(
)
;
bool
IsReplaceable
(
)
const
;
bool
IsRemovable
(
)
const
;
void
Remove
(
)
;
bool
HasLowerCompositeOrderThan
(
const
Animation
&
aOther
)
const
;
virtual
EffectCompositor
:
:
CascadeLevel
CascadeLevel
(
)
const
{
return
EffectCompositor
:
:
CascadeLevel
:
:
Animations
;
}
bool
CanThrottle
(
)
const
;
void
WillComposeStyle
(
)
;
void
ComposeStyle
(
RawServoAnimationValueMap
&
aComposeResult
const
nsCSSPropertyIDSet
&
aPropertiesToSkip
)
;
void
NotifyEffectTimingUpdated
(
)
;
void
NotifyEffectPropertiesUpdated
(
)
;
void
NotifyEffectTargetUpdated
(
)
;
void
NotifyGeometricAnimationsStartingThisFrame
(
)
;
void
ReschedulePendingTasks
(
)
;
virtual
void
MaybeQueueCancelEvent
(
const
StickyTimeDuration
&
aActiveTime
)
{
}
;
int32_t
&
CachedChildIndexRef
(
)
{
return
mCachedChildIndex
;
}
protected
:
void
SilentlySetCurrentTime
(
const
TimeDuration
&
aNewCurrentTime
)
;
void
CancelNoUpdate
(
)
;
void
PlayNoUpdate
(
ErrorResult
&
aRv
LimitBehavior
aLimitBehavior
)
;
void
ResumeAt
(
const
TimeDuration
&
aReadyTime
)
;
void
PauseAt
(
const
TimeDuration
&
aReadyTime
)
;
void
FinishPendingAt
(
const
TimeDuration
&
aReadyTime
)
{
if
(
mPendingState
=
=
PendingState
:
:
PlayPending
)
{
ResumeAt
(
aReadyTime
)
;
}
else
if
(
mPendingState
=
=
PendingState
:
:
PausePending
)
{
PauseAt
(
aReadyTime
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Can
'
t
finish
pending
if
we
'
re
not
in
a
pending
state
"
)
;
}
}
void
ApplyPendingPlaybackRate
(
)
{
if
(
mPendingPlaybackRate
)
{
mPlaybackRate
=
*
mPendingPlaybackRate
;
mPendingPlaybackRate
.
reset
(
)
;
}
}
enum
class
SeekFlag
{
NoSeek
DidSeek
}
;
enum
class
SyncNotifyFlag
{
Sync
Async
}
;
virtual
void
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
;
void
UpdateFinishedState
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
;
void
UpdateEffect
(
PostRestyleMode
aPostRestyle
)
;
void
FlushUnanimatedStyle
(
)
const
;
void
PostUpdate
(
)
;
void
ResetFinishedPromise
(
)
;
void
MaybeResolveFinishedPromise
(
)
;
void
DoFinishNotification
(
SyncNotifyFlag
aSyncNotifyFlag
)
;
friend
class
AsyncFinishNotification
;
void
DoFinishNotificationImmediately
(
MicroTaskRunnable
*
aAsync
=
nullptr
)
;
void
QueuePlaybackEvent
(
const
nsAString
&
aName
TimeStamp
&
&
aScheduledEventTime
)
;
void
CancelPendingTasks
(
)
;
void
ResetPendingTasks
(
)
;
bool
IsNewlyStarted
(
)
const
{
return
mPendingState
=
=
PendingState
:
:
PlayPending
&
&
mPendingReadyTime
.
IsNull
(
)
&
&
mStartTime
.
IsNull
(
)
;
}
bool
IsPossiblyOrphanedPendingAnimation
(
)
const
;
StickyTimeDuration
EffectEnd
(
)
const
;
Nullable
<
TimeDuration
>
GetCurrentTimeForHoldTime
(
const
Nullable
<
TimeDuration
>
&
aHoldTime
)
const
;
Nullable
<
TimeDuration
>
GetUnconstrainedCurrentTime
(
)
const
{
return
GetCurrentTimeForHoldTime
(
Nullable
<
TimeDuration
>
(
)
)
;
}
void
ScheduleReplacementCheck
(
)
;
void
MaybeScheduleReplacementCheck
(
)
;
StickyTimeDuration
IntervalStartTime
(
const
StickyTimeDuration
&
aActiveDuration
)
const
{
MOZ_ASSERT
(
AsCSSTransition
(
)
|
|
AsCSSAnimation
(
)
"
Should
be
called
for
CSS
animations
or
transitions
"
)
;
static
constexpr
StickyTimeDuration
zeroDuration
=
StickyTimeDuration
(
)
;
return
std
:
:
max
(
std
:
:
min
(
StickyTimeDuration
(
-
mEffect
-
>
SpecifiedTiming
(
)
.
Delay
(
)
)
aActiveDuration
)
zeroDuration
)
;
}
StickyTimeDuration
IntervalEndTime
(
const
StickyTimeDuration
&
aActiveDuration
)
const
{
MOZ_ASSERT
(
AsCSSTransition
(
)
|
|
AsCSSAnimation
(
)
"
Should
be
called
for
CSS
animations
or
transitions
"
)
;
static
constexpr
StickyTimeDuration
zeroDuration
=
StickyTimeDuration
(
)
;
return
std
:
:
max
(
std
:
:
min
(
(
EffectEnd
(
)
-
mEffect
-
>
SpecifiedTiming
(
)
.
Delay
(
)
)
aActiveDuration
)
zeroDuration
)
;
}
TimeStamp
GetTimelineCurrentTimeAsTimeStamp
(
)
const
{
return
mTimeline
?
mTimeline
-
>
GetCurrentTimeAsTimeStamp
(
)
:
TimeStamp
(
)
;
}
Document
*
GetRenderedDocument
(
)
const
;
Document
*
GetTimelineDocument
(
)
const
;
RefPtr
<
AnimationTimeline
>
mTimeline
;
RefPtr
<
AnimationEffect
>
mEffect
;
Nullable
<
TimeDuration
>
mStartTime
;
Nullable
<
TimeDuration
>
mHoldTime
;
Nullable
<
TimeDuration
>
mPendingReadyTime
;
Nullable
<
TimeDuration
>
mPreviousCurrentTime
;
double
mPlaybackRate
=
1
.
0
;
Maybe
<
double
>
mPendingPlaybackRate
;
RefPtr
<
Promise
>
mReady
;
RefPtr
<
Promise
>
mFinished
;
static
uint64_t
sNextAnimationIndex
;
uint64_t
mAnimationIndex
;
int32_t
mCachedChildIndex
=
-
1
;
enum
class
PendingState
:
uint8_t
{
NotPending
PlayPending
PausePending
}
;
PendingState
mPendingState
=
PendingState
:
:
NotPending
;
AnimationReplaceState
mReplaceState
=
AnimationReplaceState
:
:
Active
;
bool
mFinishedAtLastComposeStyle
=
false
;
bool
mWasReplaceableAtLastTick
=
false
;
bool
mIsRelevant
=
false
;
bool
mFinishedIsResolved
=
false
;
bool
mSyncWithGeometricAnimations
=
false
;
RefPtr
<
MicroTaskRunnable
>
mFinishNotificationTask
;
nsString
mId
;
}
;
}
}
#
endif
