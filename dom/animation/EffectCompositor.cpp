#
include
"
EffectCompositor
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectReadOnly
.
h
"
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
AnimationPerformanceWarning
.
h
"
#
include
"
mozilla
/
AnimationTarget
.
h
"
#
include
"
mozilla
/
AnimationUtils
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
LayerAnimationInfo
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
RestyleManagerInlines
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCSSPropertyIDSet
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsIAtom
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIPresShellInlines
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsRuleNode
.
h
"
#
include
"
nsRuleProcessorData
.
h
"
#
include
"
nsTArray
.
h
"
#
include
<
bitset
>
#
include
<
initializer_list
>
using
mozilla
:
:
dom
:
:
Animation
;
using
mozilla
:
:
dom
:
:
Element
;
using
mozilla
:
:
dom
:
:
KeyframeEffectReadOnly
;
namespace
mozilla
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
EffectCompositor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
EffectCompositor
)
for
(
auto
&
elementSet
:
tmp
-
>
mElementsToRestyle
)
{
elementSet
.
Clear
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
EffectCompositor
)
for
(
auto
&
elementSet
:
tmp
-
>
mElementsToRestyle
)
{
for
(
auto
iter
=
elementSet
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
CycleCollectionNoteChild
(
cb
iter
.
Key
(
)
.
mElement
"
EffectCompositor
:
:
mElementsToRestyle
[
]
"
cb
.
Flags
(
)
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
EffectCompositor
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
EffectCompositor
Release
)
namespace
{
enum
class
MatchForCompositor
{
Yes
IfNeeded
No
NoAndBlockThisProperty
}
;
}
static
MatchForCompositor
IsMatchForCompositor
(
const
KeyframeEffectReadOnly
&
aEffect
nsCSSPropertyID
aProperty
const
nsIFrame
*
aFrame
)
{
const
Animation
*
animation
=
aEffect
.
GetAnimation
(
)
;
MOZ_ASSERT
(
animation
)
;
if
(
!
animation
-
>
IsRelevant
(
)
)
{
return
MatchForCompositor
:
:
No
;
}
AnimationPerformanceWarning
:
:
Type
warningType
;
if
(
animation
-
>
ShouldBeSynchronizedWithMainThread
(
aProperty
aFrame
warningType
)
)
{
EffectCompositor
:
:
SetPerformanceWarning
(
aFrame
aProperty
AnimationPerformanceWarning
(
warningType
)
)
;
return
MatchForCompositor
:
:
NoAndBlockThisProperty
;
}
if
(
!
aEffect
.
HasEffectiveAnimationOfProperty
(
aProperty
)
)
{
return
MatchForCompositor
:
:
No
;
}
return
animation
-
>
IsPlaying
(
)
?
MatchForCompositor
:
:
Yes
:
MatchForCompositor
:
:
IfNeeded
;
}
bool
FindAnimationsForCompositor
(
const
nsIFrame
*
aFrame
nsCSSPropertyID
aProperty
nsTArray
<
RefPtr
<
dom
:
:
Animation
>
>
*
aMatches
)
{
MOZ_ASSERT
(
!
aMatches
|
|
aMatches
-
>
IsEmpty
(
)
"
Matches
array
if
provided
should
be
empty
"
)
;
EffectSet
*
effects
=
EffectSet
:
:
GetEffectSet
(
aFrame
)
;
if
(
!
effects
|
|
effects
-
>
IsEmpty
(
)
)
{
return
false
;
}
if
(
aFrame
-
>
StyleContext
(
)
-
>
StyleSource
(
)
.
IsServoComputedValues
(
)
)
{
NS_WARNING
(
"
stylo
:
return
false
in
FindAnimationsForCompositor
because
"
"
haven
'
t
supported
compositor
-
driven
animations
yet
"
)
;
return
false
;
}
if
(
aProperty
=
=
eCSSProperty_transform
)
{
PendingAnimationTracker
*
tracker
=
aFrame
-
>
PresContext
(
)
-
>
Document
(
)
-
>
GetPendingAnimationTracker
(
)
;
if
(
tracker
)
{
tracker
-
>
MarkAnimationsThatMightNeedSynchronization
(
)
;
}
}
if
(
effects
-
>
PropertiesWithImportantRules
(
)
.
HasProperty
(
aProperty
)
&
&
effects
-
>
PropertiesForAnimationsLevel
(
)
.
HasProperty
(
aProperty
)
)
{
return
false
;
}
if
(
aFrame
-
>
RefusedAsyncAnimation
(
)
)
{
return
false
;
}
Maybe
<
NonOwningAnimationTarget
>
pseudoElement
=
EffectCompositor
:
:
GetAnimationElementAndPseudoForFrame
(
aFrame
)
;
if
(
pseudoElement
)
{
EffectCompositor
:
:
MaybeUpdateCascadeResults
(
pseudoElement
-
>
mElement
pseudoElement
-
>
mPseudoType
aFrame
-
>
StyleContext
(
)
)
;
}
if
(
!
nsLayoutUtils
:
:
AreAsyncAnimationsEnabled
(
)
)
{
if
(
nsLayoutUtils
:
:
IsAnimationLoggingEnabled
(
)
)
{
nsCString
message
;
message
.
AppendLiteral
(
"
Performance
warning
:
Async
animations
are
"
"
disabled
"
)
;
AnimationUtils
:
:
LogAsyncAnimationFailure
(
message
)
;
}
return
false
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
while
(
content
)
{
if
(
content
-
>
HasRenderingObservers
(
)
)
{
EffectCompositor
:
:
SetPerformanceWarning
(
aFrame
aProperty
AnimationPerformanceWarning
(
AnimationPerformanceWarning
:
:
Type
:
:
HasRenderingObserver
)
)
;
return
false
;
}
content
=
content
-
>
GetParent
(
)
;
}
bool
foundRunningAnimations
=
false
;
for
(
KeyframeEffectReadOnly
*
effect
:
*
effects
)
{
MatchForCompositor
matchResult
=
IsMatchForCompositor
(
*
effect
aProperty
aFrame
)
;
if
(
matchResult
=
=
MatchForCompositor
:
:
NoAndBlockThisProperty
)
{
if
(
aMatches
)
{
aMatches
-
>
Clear
(
)
;
}
return
false
;
}
if
(
matchResult
=
=
MatchForCompositor
:
:
No
)
{
continue
;
}
if
(
aMatches
)
{
aMatches
-
>
AppendElement
(
effect
-
>
GetAnimation
(
)
)
;
}
if
(
matchResult
=
=
MatchForCompositor
:
:
Yes
)
{
foundRunningAnimations
=
true
;
}
}
if
(
aMatches
&
&
!
foundRunningAnimations
)
{
aMatches
-
>
Clear
(
)
;
}
MOZ_ASSERT
(
!
foundRunningAnimations
|
|
!
aMatches
|
|
!
aMatches
-
>
IsEmpty
(
)
"
If
return
value
is
true
matches
array
should
be
non
-
empty
"
)
;
if
(
aMatches
&
&
foundRunningAnimations
)
{
aMatches
-
>
Sort
(
AnimationPtrComparator
<
RefPtr
<
dom
:
:
Animation
>
>
(
)
)
;
}
return
foundRunningAnimations
;
}
void
EffectCompositor
:
:
RequestRestyle
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
RestyleType
aRestyleType
CascadeLevel
aCascadeLevel
)
{
if
(
!
mPresContext
)
{
return
;
}
if
(
!
aElement
-
>
IsInComposedDoc
(
)
)
{
return
;
}
auto
&
elementsToRestyle
=
mElementsToRestyle
[
aCascadeLevel
]
;
PseudoElementHashEntry
:
:
KeyType
key
=
{
aElement
aPseudoType
}
;
if
(
aRestyleType
=
=
RestyleType
:
:
Throttled
)
{
if
(
!
elementsToRestyle
.
Contains
(
key
)
)
{
elementsToRestyle
.
Put
(
key
false
)
;
}
mPresContext
-
>
PresShell
(
)
-
>
SetNeedThrottledAnimationFlush
(
)
;
}
else
{
bool
hasPendingRestyle
=
elementsToRestyle
.
Get
(
key
)
;
if
(
!
hasPendingRestyle
)
{
PostRestyleForAnimation
(
aElement
aPseudoType
aCascadeLevel
)
;
}
elementsToRestyle
.
Put
(
key
true
)
;
}
if
(
aRestyleType
=
=
RestyleType
:
:
Layer
)
{
mPresContext
-
>
RestyleManager
(
)
-
>
IncrementAnimationGeneration
(
)
;
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
effectSet
)
{
effectSet
-
>
UpdateAnimationGeneration
(
mPresContext
)
;
}
}
}
void
EffectCompositor
:
:
PostRestyleForAnimation
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
CascadeLevel
aCascadeLevel
)
{
if
(
!
mPresContext
)
{
return
;
}
dom
:
:
Element
*
element
=
GetElementToRestyle
(
aElement
aPseudoType
)
;
if
(
!
element
)
{
return
;
}
nsRestyleHint
hint
=
aCascadeLevel
=
=
CascadeLevel
:
:
Transitions
?
eRestyle_CSSTransitions
:
eRestyle_CSSAnimations
;
if
(
mPresContext
-
>
StyleSet
(
)
-
>
IsServo
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Restyle
request
during
restyling
should
be
requested
only
on
"
"
the
main
-
thread
.
e
.
g
.
after
the
parallel
traversal
"
)
;
if
(
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
{
MOZ_ASSERT
(
hint
=
=
eRestyle_CSSAnimations
|
|
hint
=
=
eRestyle_CSSTransitions
)
;
return
;
}
else
{
MOZ_ASSERT
(
!
mPresContext
-
>
RestyleManager
(
)
-
>
IsInStyleRefresh
(
)
)
;
}
}
mPresContext
-
>
PresShell
(
)
-
>
RestyleForAnimation
(
element
hint
)
;
}
void
EffectCompositor
:
:
PostRestyleForThrottledAnimations
(
)
{
for
(
size_t
i
=
0
;
i
<
kCascadeLevelCount
;
i
+
+
)
{
CascadeLevel
cascadeLevel
=
CascadeLevel
(
i
)
;
auto
&
elementSet
=
mElementsToRestyle
[
cascadeLevel
]
;
for
(
auto
iter
=
elementSet
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
bool
&
postedRestyle
=
iter
.
Data
(
)
;
if
(
postedRestyle
)
{
continue
;
}
PostRestyleForAnimation
(
iter
.
Key
(
)
.
mElement
iter
.
Key
(
)
.
mPseudoType
cascadeLevel
)
;
postedRestyle
=
true
;
}
}
}
template
<
typename
StyleType
>
void
EffectCompositor
:
:
UpdateEffectProperties
(
StyleType
&
&
aStyleType
Element
*
aElement
CSSPseudoElementType
aPseudoType
)
{
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
!
effectSet
)
{
return
;
}
effectSet
-
>
MarkCascadeNeedsUpdate
(
)
;
for
(
KeyframeEffectReadOnly
*
effect
:
*
effectSet
)
{
effect
-
>
UpdateProperties
(
Forward
<
StyleType
>
(
aStyleType
)
)
;
}
}
void
EffectCompositor
:
:
MaybeUpdateAnimationRule
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
CascadeLevel
aCascadeLevel
nsStyleContext
*
aStyleContext
)
{
MaybeUpdateCascadeResults
(
aElement
aPseudoType
aStyleContext
)
;
auto
&
elementsToRestyle
=
mElementsToRestyle
[
aCascadeLevel
]
;
PseudoElementHashEntry
:
:
KeyType
key
=
{
aElement
aPseudoType
}
;
if
(
!
elementsToRestyle
.
Contains
(
key
)
)
{
return
;
}
ComposeAnimationRule
(
aElement
aPseudoType
aCascadeLevel
)
;
elementsToRestyle
.
Remove
(
key
)
;
}
nsIStyleRule
*
EffectCompositor
:
:
GetAnimationRule
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
CascadeLevel
aCascadeLevel
nsStyleContext
*
aStyleContext
)
{
if
(
!
mPresContext
|
|
!
mPresContext
-
>
IsDynamic
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mPresContext
-
>
RestyleManager
(
)
-
>
IsGecko
(
)
"
stylo
:
Servo
-
backed
style
system
should
not
be
using
"
"
EffectCompositor
"
)
;
if
(
mPresContext
-
>
RestyleManager
(
)
-
>
AsGecko
(
)
-
>
SkipAnimationRules
(
)
)
{
return
nullptr
;
}
MaybeUpdateAnimationRule
(
aElement
aPseudoType
aCascadeLevel
aStyleContext
)
;
#
ifdef
DEBUG
{
auto
&
elementsToRestyle
=
mElementsToRestyle
[
aCascadeLevel
]
;
PseudoElementHashEntry
:
:
KeyType
key
=
{
aElement
aPseudoType
}
;
MOZ_ASSERT
(
!
elementsToRestyle
.
Contains
(
key
)
"
Element
should
no
longer
require
a
restyle
after
its
"
"
animation
rule
has
been
updated
"
)
;
}
#
endif
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
!
effectSet
)
{
return
nullptr
;
}
return
effectSet
-
>
AnimationRule
(
aCascadeLevel
)
;
}
namespace
{
class
EffectCompositeOrderComparator
{
public
:
bool
Equals
(
const
KeyframeEffectReadOnly
*
a
const
KeyframeEffectReadOnly
*
b
)
const
{
return
a
=
=
b
;
}
bool
LessThan
(
const
KeyframeEffectReadOnly
*
a
const
KeyframeEffectReadOnly
*
b
)
const
{
MOZ_ASSERT
(
a
-
>
GetAnimation
(
)
&
&
b
-
>
GetAnimation
(
)
)
;
MOZ_ASSERT
(
Equals
(
a
b
)
|
|
a
-
>
GetAnimation
(
)
-
>
HasLowerCompositeOrderThan
(
*
b
-
>
GetAnimation
(
)
)
!
=
b
-
>
GetAnimation
(
)
-
>
HasLowerCompositeOrderThan
(
*
a
-
>
GetAnimation
(
)
)
)
;
return
a
-
>
GetAnimation
(
)
-
>
HasLowerCompositeOrderThan
(
*
b
-
>
GetAnimation
(
)
)
;
}
}
;
}
bool
EffectCompositor
:
:
GetServoAnimationRule
(
const
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
CascadeLevel
aCascadeLevel
RawServoAnimationValueMapBorrowed
aAnimationValues
)
{
MOZ_ASSERT
(
aAnimationValues
)
;
MOZ_ASSERT
(
mPresContext
&
&
mPresContext
-
>
IsDynamic
(
)
"
Should
not
be
in
print
preview
"
)
;
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
!
effectSet
)
{
return
false
;
}
nsTArray
<
KeyframeEffectReadOnly
*
>
sortedEffectList
(
effectSet
-
>
Count
(
)
)
;
for
(
KeyframeEffectReadOnly
*
effect
:
*
effectSet
)
{
sortedEffectList
.
AppendElement
(
effect
)
;
}
sortedEffectList
.
Sort
(
EffectCompositeOrderComparator
(
)
)
;
const
nsCSSPropertyIDSet
propertiesToSkip
=
aCascadeLevel
=
=
CascadeLevel
:
:
Animations
?
effectSet
-
>
PropertiesForAnimationsLevel
(
)
.
Inverse
(
)
:
effectSet
-
>
PropertiesForAnimationsLevel
(
)
;
for
(
KeyframeEffectReadOnly
*
effect
:
sortedEffectList
)
{
effect
-
>
GetAnimation
(
)
-
>
ComposeStyle
(
*
aAnimationValues
propertiesToSkip
)
;
}
MOZ_ASSERT
(
effectSet
=
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
"
EffectSet
should
not
change
while
composing
style
"
)
;
return
true
;
}
dom
:
:
Element
*
EffectCompositor
:
:
GetElementToRestyle
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
)
{
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
)
{
return
aElement
;
}
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
before
)
{
return
nsLayoutUtils
:
:
GetBeforePseudo
(
aElement
)
;
}
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
after
)
{
return
nsLayoutUtils
:
:
GetAfterPseudo
(
aElement
)
;
}
NS_NOTREACHED
(
"
Should
not
try
to
get
the
element
to
restyle
for
a
pseudo
"
"
other
that
:
before
or
:
after
"
)
;
return
nullptr
;
}
bool
EffectCompositor
:
:
HasPendingStyleUpdates
(
)
const
{
for
(
auto
&
elementSet
:
mElementsToRestyle
)
{
if
(
elementSet
.
Count
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
EffectCompositor
:
:
HasThrottledStyleUpdates
(
)
const
{
for
(
auto
&
elementSet
:
mElementsToRestyle
)
{
for
(
auto
iter
=
elementSet
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
!
iter
.
Data
(
)
)
{
return
true
;
}
}
}
return
false
;
}
void
EffectCompositor
:
:
AddStyleUpdatesTo
(
RestyleTracker
&
aTracker
)
{
if
(
!
mPresContext
)
{
return
;
}
for
(
size_t
i
=
0
;
i
<
kCascadeLevelCount
;
i
+
+
)
{
CascadeLevel
cascadeLevel
=
CascadeLevel
(
i
)
;
auto
&
elementSet
=
mElementsToRestyle
[
cascadeLevel
]
;
nsTArray
<
PseudoElementHashEntry
:
:
KeyType
>
elementsToRestyle
(
elementSet
.
Count
(
)
)
;
for
(
auto
iter
=
elementSet
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
Key
(
)
.
mElement
-
>
IsInComposedDoc
(
)
)
{
elementsToRestyle
.
AppendElement
(
iter
.
Key
(
)
)
;
}
}
for
(
auto
&
pseudoElem
:
elementsToRestyle
)
{
MaybeUpdateCascadeResults
(
pseudoElem
.
mElement
pseudoElem
.
mPseudoType
nullptr
)
;
ComposeAnimationRule
(
pseudoElem
.
mElement
pseudoElem
.
mPseudoType
cascadeLevel
)
;
dom
:
:
Element
*
elementToRestyle
=
GetElementToRestyle
(
pseudoElem
.
mElement
pseudoElem
.
mPseudoType
)
;
if
(
elementToRestyle
)
{
nsRestyleHint
rshint
=
cascadeLevel
=
=
CascadeLevel
:
:
Transitions
?
eRestyle_CSSTransitions
:
eRestyle_CSSAnimations
;
aTracker
.
AddPendingRestyle
(
elementToRestyle
rshint
nsChangeHint
(
0
)
)
;
}
}
elementSet
.
Clear
(
)
;
}
}
bool
EffectCompositor
:
:
HasAnimationsForCompositor
(
const
nsIFrame
*
aFrame
nsCSSPropertyID
aProperty
)
{
return
FindAnimationsForCompositor
(
aFrame
aProperty
nullptr
)
;
}
nsTArray
<
RefPtr
<
dom
:
:
Animation
>
>
EffectCompositor
:
:
GetAnimationsForCompositor
(
const
nsIFrame
*
aFrame
nsCSSPropertyID
aProperty
)
{
nsTArray
<
RefPtr
<
dom
:
:
Animation
>
>
result
;
#
ifdef
DEBUG
bool
foundSome
=
#
endif
FindAnimationsForCompositor
(
aFrame
aProperty
&
result
)
;
MOZ_ASSERT
(
!
foundSome
|
|
!
result
.
IsEmpty
(
)
"
If
return
value
is
true
matches
array
should
be
non
-
empty
"
)
;
return
result
;
}
void
EffectCompositor
:
:
ClearIsRunningOnCompositor
(
const
nsIFrame
*
aFrame
nsCSSPropertyID
aProperty
)
{
EffectSet
*
effects
=
EffectSet
:
:
GetEffectSet
(
aFrame
)
;
if
(
!
effects
)
{
return
;
}
for
(
KeyframeEffectReadOnly
*
effect
:
*
effects
)
{
effect
-
>
SetIsRunningOnCompositor
(
aProperty
false
)
;
}
}
void
EffectCompositor
:
:
MaybeUpdateCascadeResults
(
Element
*
aElement
CSSPseudoElementType
aPseudoType
nsStyleContext
*
aStyleContext
)
{
EffectSet
*
effects
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
!
effects
|
|
!
effects
-
>
CascadeNeedsUpdate
(
)
)
{
return
;
}
nsStyleContext
*
styleContext
=
aStyleContext
;
if
(
!
styleContext
)
{
dom
:
:
Element
*
elementToRestyle
=
GetElementToRestyle
(
aElement
aPseudoType
)
;
if
(
elementToRestyle
)
{
nsIFrame
*
frame
=
elementToRestyle
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
styleContext
=
frame
-
>
StyleContext
(
)
;
}
}
}
UpdateCascadeResults
(
*
effects
aElement
aPseudoType
styleContext
)
;
MOZ_ASSERT
(
!
effects
-
>
CascadeNeedsUpdate
(
)
"
Failed
to
update
cascade
state
"
)
;
}
void
EffectCompositor
:
:
MaybeUpdateCascadeResults
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
)
{
EffectSet
*
effects
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
MOZ_ASSERT
(
effects
)
;
if
(
!
effects
-
>
CascadeNeedsUpdate
(
)
)
{
return
;
}
UpdateCascadeResults
(
*
effects
aElement
aPseudoType
nullptr
)
;
MOZ_ASSERT
(
!
effects
-
>
CascadeNeedsUpdate
(
)
"
Failed
to
update
cascade
state
"
)
;
}
void
EffectCompositor
:
:
UpdateCascadeResults
(
Element
*
aElement
CSSPseudoElementType
aPseudoType
nsStyleContext
*
aStyleContext
)
{
EffectSet
*
effects
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
!
effects
)
{
return
;
}
UpdateCascadeResults
(
*
effects
aElement
aPseudoType
aStyleContext
)
;
}
Maybe
<
NonOwningAnimationTarget
>
EffectCompositor
:
:
GetAnimationElementAndPseudoForFrame
(
const
nsIFrame
*
aFrame
)
{
Maybe
<
NonOwningAnimationTarget
>
result
;
CSSPseudoElementType
pseudoType
=
aFrame
-
>
StyleContext
(
)
-
>
GetPseudoType
(
)
;
if
(
pseudoType
!
=
CSSPseudoElementType
:
:
NotPseudo
&
&
pseudoType
!
=
CSSPseudoElementType
:
:
before
&
&
pseudoType
!
=
CSSPseudoElementType
:
:
after
)
{
return
result
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
)
{
return
result
;
}
if
(
pseudoType
=
=
CSSPseudoElementType
:
:
before
|
|
pseudoType
=
=
CSSPseudoElementType
:
:
after
)
{
content
=
content
-
>
GetParent
(
)
;
if
(
!
content
)
{
return
result
;
}
}
if
(
!
content
-
>
IsElement
(
)
)
{
return
result
;
}
result
.
emplace
(
content
-
>
AsElement
(
)
pseudoType
)
;
return
result
;
}
void
EffectCompositor
:
:
ComposeAnimationRule
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
CascadeLevel
aCascadeLevel
)
{
EffectSet
*
effects
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
!
effects
)
{
return
;
}
MOZ_ASSERT
(
!
effects
-
>
CascadeNeedsUpdate
(
)
"
Animation
cascade
out
of
date
when
composing
animation
rule
"
)
;
nsTArray
<
KeyframeEffectReadOnly
*
>
sortedEffectList
(
effects
-
>
Count
(
)
)
;
for
(
KeyframeEffectReadOnly
*
effect
:
*
effects
)
{
sortedEffectList
.
AppendElement
(
effect
)
;
}
sortedEffectList
.
Sort
(
EffectCompositeOrderComparator
(
)
)
;
RefPtr
<
AnimValuesStyleRule
>
&
animRule
=
effects
-
>
AnimationRule
(
aCascadeLevel
)
;
animRule
=
nullptr
;
const
nsCSSPropertyIDSet
&
propertiesToSkip
=
aCascadeLevel
=
=
CascadeLevel
:
:
Animations
?
effects
-
>
PropertiesForAnimationsLevel
(
)
.
Inverse
(
)
:
effects
-
>
PropertiesForAnimationsLevel
(
)
;
for
(
KeyframeEffectReadOnly
*
effect
:
sortedEffectList
)
{
effect
-
>
GetAnimation
(
)
-
>
WillComposeStyle
(
)
;
effect
-
>
GetAnimation
(
)
-
>
ComposeStyle
(
animRule
propertiesToSkip
)
;
}
MOZ_ASSERT
(
effects
=
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
"
EffectSet
should
not
change
while
composing
style
"
)
;
}
void
EffectCompositor
:
:
GetOverriddenProperties
(
nsStyleContext
*
aStyleContext
EffectSet
&
aEffectSet
nsCSSPropertyIDSet
&
aPropertiesOverridden
)
{
AutoTArray
<
nsCSSPropertyID
LayerAnimationInfo
:
:
kRecords
>
propertiesToTrack
;
{
nsCSSPropertyIDSet
propertiesToTrackAsSet
;
for
(
KeyframeEffectReadOnly
*
effect
:
aEffectSet
)
{
for
(
const
AnimationProperty
&
property
:
effect
-
>
Properties
(
)
)
{
if
(
nsCSSProps
:
:
PropHasFlags
(
property
.
mProperty
CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR
)
&
&
!
propertiesToTrackAsSet
.
HasProperty
(
property
.
mProperty
)
)
{
propertiesToTrackAsSet
.
AddProperty
(
property
.
mProperty
)
;
propertiesToTrack
.
AppendElement
(
property
.
mProperty
)
;
}
}
if
(
propertiesToTrack
.
Length
(
)
=
=
LayerAnimationInfo
:
:
kRecords
)
{
break
;
}
}
}
if
(
propertiesToTrack
.
IsEmpty
(
)
)
{
return
;
}
nsRuleNode
:
:
ComputePropertiesOverridingAnimation
(
propertiesToTrack
aStyleContext
aPropertiesOverridden
)
;
}
void
EffectCompositor
:
:
UpdateCascadeResults
(
EffectSet
&
aEffectSet
Element
*
aElement
CSSPseudoElementType
aPseudoType
nsStyleContext
*
aStyleContext
)
{
MOZ_ASSERT
(
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
=
=
&
aEffectSet
"
Effect
set
should
correspond
to
the
specified
(
pseudo
-
)
element
"
)
;
if
(
aEffectSet
.
IsEmpty
(
)
)
{
aEffectSet
.
MarkCascadeUpdated
(
)
;
return
;
}
nsTArray
<
KeyframeEffectReadOnly
*
>
sortedEffectList
(
aEffectSet
.
Count
(
)
)
;
for
(
KeyframeEffectReadOnly
*
effect
:
aEffectSet
)
{
sortedEffectList
.
AppendElement
(
effect
)
;
}
sortedEffectList
.
Sort
(
EffectCompositeOrderComparator
(
)
)
;
nsCSSPropertyIDSet
overriddenProperties
;
if
(
aStyleContext
)
{
MOZ_ASSERT
(
!
aStyleContext
-
>
StyleSource
(
)
.
IsServoComputedValues
(
)
"
stylo
:
Not
support
get
properties
overriding
animation
yet
.
"
)
;
GetOverriddenProperties
(
aStyleContext
aEffectSet
overriddenProperties
)
;
}
auto
compositorPropertiesInSet
=
[
]
(
nsCSSPropertyIDSet
&
aPropertySet
)
-
>
std
:
:
bitset
<
LayerAnimationInfo
:
:
kRecords
>
{
std
:
:
bitset
<
LayerAnimationInfo
:
:
kRecords
>
result
;
for
(
size_t
i
=
0
;
i
<
LayerAnimationInfo
:
:
kRecords
;
i
+
+
)
{
if
(
aPropertySet
.
HasProperty
(
LayerAnimationInfo
:
:
sRecords
[
i
]
.
mProperty
)
)
{
result
.
set
(
i
)
;
}
}
return
result
;
}
;
nsCSSPropertyIDSet
&
propertiesWithImportantRules
=
aEffectSet
.
PropertiesWithImportantRules
(
)
;
nsCSSPropertyIDSet
&
propertiesForAnimationsLevel
=
aEffectSet
.
PropertiesForAnimationsLevel
(
)
;
std
:
:
bitset
<
LayerAnimationInfo
:
:
kRecords
>
prevCompositorPropertiesWithImportantRules
=
compositorPropertiesInSet
(
propertiesWithImportantRules
)
;
std
:
:
bitset
<
LayerAnimationInfo
:
:
kRecords
>
prevCompositorPropertiesForAnimationsLevel
=
compositorPropertiesInSet
(
propertiesForAnimationsLevel
)
;
propertiesWithImportantRules
.
Empty
(
)
;
propertiesForAnimationsLevel
.
Empty
(
)
;
bool
hasCompositorPropertiesForTransition
=
false
;
for
(
const
KeyframeEffectReadOnly
*
effect
:
sortedEffectList
)
{
MOZ_ASSERT
(
effect
-
>
GetAnimation
(
)
"
Effects
on
a
target
element
should
have
an
Animation
"
)
;
CascadeLevel
cascadeLevel
=
effect
-
>
GetAnimation
(
)
-
>
CascadeLevel
(
)
;
for
(
const
AnimationProperty
&
prop
:
effect
-
>
Properties
(
)
)
{
if
(
overriddenProperties
.
HasProperty
(
prop
.
mProperty
)
)
{
propertiesWithImportantRules
.
AddProperty
(
prop
.
mProperty
)
;
}
if
(
cascadeLevel
=
=
EffectCompositor
:
:
CascadeLevel
:
:
Animations
)
{
propertiesForAnimationsLevel
.
AddProperty
(
prop
.
mProperty
)
;
}
if
(
nsCSSProps
:
:
PropHasFlags
(
prop
.
mProperty
CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR
)
&
&
cascadeLevel
=
=
EffectCompositor
:
:
CascadeLevel
:
:
Transitions
)
{
hasCompositorPropertiesForTransition
=
true
;
}
}
}
aEffectSet
.
MarkCascadeUpdated
(
)
;
nsPresContext
*
presContext
=
nsContentUtils
:
:
GetContextForContent
(
aElement
)
;
if
(
!
presContext
)
{
return
;
}
if
(
prevCompositorPropertiesWithImportantRules
!
=
compositorPropertiesInSet
(
propertiesWithImportantRules
)
)
{
presContext
-
>
EffectCompositor
(
)
-
>
RequestRestyle
(
aElement
aPseudoType
EffectCompositor
:
:
RestyleType
:
:
Layer
EffectCompositor
:
:
CascadeLevel
:
:
Animations
)
;
}
if
(
hasCompositorPropertiesForTransition
&
&
prevCompositorPropertiesForAnimationsLevel
!
=
compositorPropertiesInSet
(
propertiesForAnimationsLevel
)
)
{
presContext
-
>
EffectCompositor
(
)
-
>
RequestRestyle
(
aElement
aPseudoType
EffectCompositor
:
:
RestyleType
:
:
Layer
EffectCompositor
:
:
CascadeLevel
:
:
Transitions
)
;
}
}
void
EffectCompositor
:
:
SetPerformanceWarning
(
const
nsIFrame
*
aFrame
nsCSSPropertyID
aProperty
const
AnimationPerformanceWarning
&
aWarning
)
{
EffectSet
*
effects
=
EffectSet
:
:
GetEffectSet
(
aFrame
)
;
if
(
!
effects
)
{
return
;
}
for
(
KeyframeEffectReadOnly
*
effect
:
*
effects
)
{
effect
-
>
SetPerformanceWarning
(
aProperty
aWarning
)
;
}
}
bool
EffectCompositor
:
:
PreTraverse
(
)
{
return
PreTraverseInSubtree
(
nullptr
)
;
}
static
bool
IsFlattenedTreeDescendantOf
(
nsINode
*
aPossibleDescendant
nsINode
*
aPossibleAncestor
)
{
do
{
if
(
aPossibleDescendant
=
=
aPossibleAncestor
)
{
return
true
;
}
aPossibleDescendant
=
aPossibleDescendant
-
>
GetFlattenedTreeParentNode
(
)
;
}
while
(
aPossibleDescendant
)
;
return
false
;
}
bool
EffectCompositor
:
:
PreTraverseInSubtree
(
Element
*
aRoot
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mPresContext
-
>
RestyleManager
(
)
-
>
IsServo
(
)
)
;
bool
foundElementsNeedingRestyle
=
false
;
for
(
size_t
i
=
0
;
i
<
kCascadeLevelCount
;
+
+
i
)
{
CascadeLevel
cascadeLevel
=
CascadeLevel
(
i
)
;
for
(
auto
iter
=
mElementsToRestyle
[
cascadeLevel
]
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
bool
postedRestyle
=
iter
.
Data
(
)
;
if
(
!
postedRestyle
)
{
continue
;
}
NonOwningAnimationTarget
target
=
iter
.
Key
(
)
;
if
(
aRoot
&
&
!
IsFlattenedTreeDescendantOf
(
target
.
mElement
aRoot
)
)
{
continue
;
}
mPresContext
-
>
RestyleManager
(
)
-
>
AsServo
(
)
-
>
PostRestyleEventForAnimations
(
target
.
mElement
cascadeLevel
=
=
CascadeLevel
:
:
Transitions
?
eRestyle_CSSTransitions
:
eRestyle_CSSAnimations
)
;
foundElementsNeedingRestyle
=
true
;
EffectSet
*
effects
=
EffectSet
:
:
GetEffectSet
(
target
.
mElement
target
.
mPseudoType
)
;
if
(
!
effects
)
{
iter
.
Remove
(
)
;
continue
;
}
MaybeUpdateCascadeResults
(
target
.
mElement
target
.
mPseudoType
)
;
for
(
KeyframeEffectReadOnly
*
effect
:
*
effects
)
{
effect
-
>
GetAnimation
(
)
-
>
WillComposeStyle
(
)
;
}
iter
.
Remove
(
)
;
}
}
return
foundElementsNeedingRestyle
;
}
bool
EffectCompositor
:
:
PreTraverse
(
dom
:
:
Element
*
aElement
nsIAtom
*
aPseudoTagOrNull
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mPresContext
-
>
RestyleManager
(
)
-
>
IsServo
(
)
)
;
bool
found
=
false
;
if
(
aPseudoTagOrNull
&
&
aPseudoTagOrNull
!
=
nsCSSPseudoElements
:
:
before
&
&
aPseudoTagOrNull
!
=
nsCSSPseudoElements
:
:
after
)
{
return
found
;
}
CSSPseudoElementType
pseudoType
=
nsCSSPseudoElements
:
:
GetPseudoType
(
aPseudoTagOrNull
CSSEnabledState
:
:
eForAllContent
)
;
PseudoElementHashEntry
:
:
KeyType
key
=
{
aElement
pseudoType
}
;
for
(
size_t
i
=
0
;
i
<
kCascadeLevelCount
;
+
+
i
)
{
CascadeLevel
cascadeLevel
=
CascadeLevel
(
i
)
;
auto
&
elementSet
=
mElementsToRestyle
[
cascadeLevel
]
;
if
(
!
elementSet
.
Get
(
key
)
)
{
continue
;
}
mPresContext
-
>
RestyleManager
(
)
-
>
AsServo
(
)
-
>
PostRestyleEventForAnimations
(
aElement
cascadeLevel
=
=
CascadeLevel
:
:
Transitions
?
eRestyle_CSSTransitions
:
eRestyle_CSSAnimations
)
;
EffectSet
*
effects
=
EffectSet
:
:
GetEffectSet
(
aElement
pseudoType
)
;
if
(
effects
)
{
MaybeUpdateCascadeResults
(
aElement
pseudoType
)
;
for
(
KeyframeEffectReadOnly
*
effect
:
*
effects
)
{
effect
-
>
GetAnimation
(
)
-
>
WillComposeStyle
(
)
;
}
}
elementSet
.
Remove
(
key
)
;
found
=
true
;
}
return
found
;
}
NS_IMPL_ISUPPORTS
(
EffectCompositor
:
:
AnimationStyleRuleProcessor
nsIStyleRuleProcessor
)
nsRestyleHint
EffectCompositor
:
:
AnimationStyleRuleProcessor
:
:
HasStateDependentStyle
(
StateRuleProcessorData
*
aData
)
{
return
nsRestyleHint
(
0
)
;
}
nsRestyleHint
EffectCompositor
:
:
AnimationStyleRuleProcessor
:
:
HasStateDependentStyle
(
PseudoElementStateRuleProcessorData
*
aData
)
{
return
nsRestyleHint
(
0
)
;
}
bool
EffectCompositor
:
:
AnimationStyleRuleProcessor
:
:
HasDocumentStateDependentStyle
(
StateRuleProcessorData
*
aData
)
{
return
false
;
}
nsRestyleHint
EffectCompositor
:
:
AnimationStyleRuleProcessor
:
:
HasAttributeDependentStyle
(
AttributeRuleProcessorData
*
aData
RestyleHintData
&
aRestyleHintDataResult
)
{
return
nsRestyleHint
(
0
)
;
}
bool
EffectCompositor
:
:
AnimationStyleRuleProcessor
:
:
MediumFeaturesChanged
(
nsPresContext
*
aPresContext
)
{
return
false
;
}
void
EffectCompositor
:
:
AnimationStyleRuleProcessor
:
:
RulesMatching
(
ElementRuleProcessorData
*
aData
)
{
nsIStyleRule
*
rule
=
mCompositor
-
>
GetAnimationRule
(
aData
-
>
mElement
CSSPseudoElementType
:
:
NotPseudo
mCascadeLevel
nullptr
)
;
if
(
rule
)
{
aData
-
>
mRuleWalker
-
>
Forward
(
rule
)
;
aData
-
>
mRuleWalker
-
>
CurrentNode
(
)
-
>
SetIsAnimationRule
(
)
;
}
}
void
EffectCompositor
:
:
AnimationStyleRuleProcessor
:
:
RulesMatching
(
PseudoElementRuleProcessorData
*
aData
)
{
if
(
aData
-
>
mPseudoType
!
=
CSSPseudoElementType
:
:
before
&
&
aData
-
>
mPseudoType
!
=
CSSPseudoElementType
:
:
after
)
{
return
;
}
nsIStyleRule
*
rule
=
mCompositor
-
>
GetAnimationRule
(
aData
-
>
mElement
aData
-
>
mPseudoType
mCascadeLevel
nullptr
)
;
if
(
rule
)
{
aData
-
>
mRuleWalker
-
>
Forward
(
rule
)
;
aData
-
>
mRuleWalker
-
>
CurrentNode
(
)
-
>
SetIsAnimationRule
(
)
;
}
}
void
EffectCompositor
:
:
AnimationStyleRuleProcessor
:
:
RulesMatching
(
AnonBoxRuleProcessorData
*
aData
)
{
}
#
ifdef
MOZ_XUL
void
EffectCompositor
:
:
AnimationStyleRuleProcessor
:
:
RulesMatching
(
XULTreeRuleProcessorData
*
aData
)
{
}
#
endif
size_t
EffectCompositor
:
:
AnimationStyleRuleProcessor
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
size_t
EffectCompositor
:
:
AnimationStyleRuleProcessor
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
template
void
EffectCompositor
:
:
UpdateEffectProperties
<
RefPtr
<
nsStyleContext
>
&
>
(
RefPtr
<
nsStyleContext
>
&
aStyleContext
Element
*
aElement
CSSPseudoElementType
aPseudoType
)
;
template
void
EffectCompositor
:
:
UpdateEffectProperties
<
const
ServoComputedValuesWithParent
&
>
(
const
ServoComputedValuesWithParent
&
aServoValues
Element
*
aElement
CSSPseudoElementType
aPseudoType
)
;
}
