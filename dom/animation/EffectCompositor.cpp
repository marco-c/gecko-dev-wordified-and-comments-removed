#
include
"
EffectCompositor
.
h
"
#
include
<
bitset
>
#
include
<
initializer_list
>
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
AnimationPerformanceWarning
.
h
"
#
include
"
mozilla
/
AnimationTarget
.
h
"
#
include
"
mozilla
/
AnimationUtils
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
ComputedStyleInlines
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
LayerAnimationInfo
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCSSPropertyIDSet
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsDisplayItemTypes
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
PendingAnimationTracker
.
h
"
using
mozilla
:
:
dom
:
:
Animation
;
using
mozilla
:
:
dom
:
:
Element
;
using
mozilla
:
:
dom
:
:
KeyframeEffect
;
namespace
mozilla
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
EffectCompositor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
EffectCompositor
)
for
(
auto
&
elementSet
:
tmp
-
>
mElementsToRestyle
)
{
elementSet
.
Clear
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
EffectCompositor
)
for
(
const
auto
&
elementSet
:
tmp
-
>
mElementsToRestyle
)
{
for
(
const
auto
&
key
:
elementSet
.
Keys
(
)
)
{
CycleCollectionNoteChild
(
cb
key
.
mElement
"
EffectCompositor
:
:
mElementsToRestyle
[
]
"
cb
.
Flags
(
)
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
bool
EffectCompositor
:
:
AllowCompositorAnimationsOnFrame
(
const
nsIFrame
*
aFrame
AnimationPerformanceWarning
:
:
Type
&
aWarning
)
{
if
(
aFrame
-
>
RefusedAsyncAnimation
(
)
)
{
return
false
;
}
if
(
!
nsLayoutUtils
:
:
AreAsyncAnimationsEnabled
(
)
)
{
if
(
StaticPrefs
:
:
layers_offmainthreadcomposition_log_animations
(
)
)
{
nsCString
message
;
message
.
AppendLiteral
(
"
Performance
warning
:
Async
animations
are
"
"
disabled
"
)
;
AnimationUtils
:
:
LogAsyncAnimationFailure
(
message
)
;
}
return
false
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
while
(
content
)
{
if
(
content
-
>
HasRenderingObservers
(
)
)
{
aWarning
=
AnimationPerformanceWarning
:
:
Type
:
:
HasRenderingObserver
;
return
false
;
}
content
=
content
-
>
GetParent
(
)
;
}
return
true
;
}
bool
FindAnimationsForCompositor
(
const
nsIFrame
*
aFrame
const
nsCSSPropertyIDSet
&
aPropertySet
nsTArray
<
RefPtr
<
dom
:
:
Animation
>
>
*
aMatches
)
{
if
(
aFrame
-
>
PresContext
(
)
-
>
IsPrintingOrPrintPreview
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
aPropertySet
.
IsSubsetOf
(
LayerAnimationInfo
:
:
GetCSSPropertiesFor
(
DisplayItemType
:
:
TYPE_TRANSFORM
)
)
|
|
aPropertySet
.
IsSubsetOf
(
LayerAnimationInfo
:
:
GetCSSPropertiesFor
(
DisplayItemType
:
:
TYPE_OPACITY
)
)
|
|
aPropertySet
.
IsSubsetOf
(
LayerAnimationInfo
:
:
GetCSSPropertiesFor
(
DisplayItemType
:
:
TYPE_BACKGROUND_COLOR
)
)
"
Should
be
the
subset
of
transform
-
like
properties
or
opacity
"
"
or
background
color
"
)
;
MOZ_ASSERT
(
!
aMatches
|
|
aMatches
-
>
IsEmpty
(
)
"
Matches
array
if
provided
should
be
empty
"
)
;
EffectSet
*
effects
=
EffectSet
:
:
GetForFrame
(
aFrame
aPropertySet
)
;
if
(
!
effects
|
|
effects
-
>
IsEmpty
(
)
)
{
return
false
;
}
if
(
aPropertySet
.
Intersects
(
LayerAnimationInfo
:
:
GetCSSPropertiesFor
(
DisplayItemType
:
:
TYPE_TRANSFORM
)
)
)
{
PendingAnimationTracker
*
tracker
=
aFrame
-
>
PresContext
(
)
-
>
Document
(
)
-
>
GetPendingAnimationTracker
(
)
;
if
(
tracker
)
{
tracker
-
>
MarkAnimationsThatMightNeedSynchronization
(
)
;
}
}
AnimationPerformanceWarning
:
:
Type
warning
=
AnimationPerformanceWarning
:
:
Type
:
:
None
;
if
(
!
EffectCompositor
:
:
AllowCompositorAnimationsOnFrame
(
aFrame
warning
)
)
{
if
(
warning
!
=
AnimationPerformanceWarning
:
:
Type
:
:
None
)
{
EffectCompositor
:
:
SetPerformanceWarning
(
aFrame
aPropertySet
AnimationPerformanceWarning
(
warning
)
)
;
}
return
false
;
}
Maybe
<
NonOwningAnimationTarget
>
pseudoElement
=
EffectCompositor
:
:
GetAnimationElementAndPseudoForFrame
(
nsLayoutUtils
:
:
GetStyleFrame
(
aFrame
)
)
;
MOZ_ASSERT
(
pseudoElement
"
We
have
a
valid
element
for
the
frame
if
we
don
'
t
we
should
"
"
have
bailed
out
at
above
the
call
to
EffectSet
:
:
Get
"
)
;
EffectCompositor
:
:
MaybeUpdateCascadeResults
(
pseudoElement
-
>
mElement
pseudoElement
-
>
mPseudoType
)
;
bool
foundRunningAnimations
=
false
;
for
(
KeyframeEffect
*
effect
:
*
effects
)
{
AnimationPerformanceWarning
:
:
Type
effectWarning
=
AnimationPerformanceWarning
:
:
Type
:
:
None
;
KeyframeEffect
:
:
MatchForCompositor
matchResult
=
effect
-
>
IsMatchForCompositor
(
aPropertySet
aFrame
*
effects
effectWarning
)
;
if
(
effectWarning
!
=
AnimationPerformanceWarning
:
:
Type
:
:
None
)
{
EffectCompositor
:
:
SetPerformanceWarning
(
aFrame
aPropertySet
AnimationPerformanceWarning
(
effectWarning
)
)
;
}
if
(
matchResult
=
=
KeyframeEffect
:
:
MatchForCompositor
:
:
NoAndBlockThisProperty
)
{
if
(
aMatches
)
{
aMatches
-
>
Clear
(
)
;
}
return
false
;
}
if
(
matchResult
=
=
KeyframeEffect
:
:
MatchForCompositor
:
:
No
)
{
continue
;
}
if
(
aMatches
)
{
aMatches
-
>
AppendElement
(
effect
-
>
GetAnimation
(
)
)
;
}
if
(
matchResult
=
=
KeyframeEffect
:
:
MatchForCompositor
:
:
Yes
)
{
foundRunningAnimations
=
true
;
}
}
if
(
aMatches
&
&
!
foundRunningAnimations
)
{
aMatches
-
>
Clear
(
)
;
}
MOZ_ASSERT
(
!
foundRunningAnimations
|
|
!
aMatches
|
|
!
aMatches
-
>
IsEmpty
(
)
"
If
return
value
is
true
matches
array
should
be
non
-
empty
"
)
;
if
(
aMatches
&
&
foundRunningAnimations
)
{
aMatches
-
>
Sort
(
AnimationPtrComparator
<
RefPtr
<
dom
:
:
Animation
>
>
(
)
)
;
}
return
foundRunningAnimations
;
}
void
EffectCompositor
:
:
RequestRestyle
(
dom
:
:
Element
*
aElement
PseudoStyleType
aPseudoType
RestyleType
aRestyleType
CascadeLevel
aCascadeLevel
)
{
if
(
!
mPresContext
)
{
return
;
}
if
(
!
nsContentUtils
:
:
GetPresShellForContent
(
aElement
)
)
{
return
;
}
auto
&
elementsToRestyle
=
mElementsToRestyle
[
aCascadeLevel
]
;
PseudoElementHashEntry
:
:
KeyType
key
=
{
aElement
aPseudoType
}
;
bool
&
restyleEntry
=
elementsToRestyle
.
LookupOrInsert
(
key
false
)
;
if
(
aRestyleType
=
=
RestyleType
:
:
Throttled
)
{
mPresContext
-
>
PresShell
(
)
-
>
SetNeedThrottledAnimationFlush
(
)
;
}
else
{
bool
skipRestyle
=
std
:
:
exchange
(
restyleEntry
true
)
;
if
(
!
skipRestyle
)
{
PostRestyleForAnimation
(
aElement
aPseudoType
aCascadeLevel
)
;
}
}
if
(
aRestyleType
=
=
RestyleType
:
:
Layer
)
{
mPresContext
-
>
RestyleManager
(
)
-
>
IncrementAnimationGeneration
(
)
;
if
(
auto
*
effectSet
=
EffectSet
:
:
Get
(
aElement
aPseudoType
)
)
{
effectSet
-
>
UpdateAnimationGeneration
(
mPresContext
)
;
}
}
}
void
EffectCompositor
:
:
PostRestyleForAnimation
(
dom
:
:
Element
*
aElement
PseudoStyleType
aPseudoType
CascadeLevel
aCascadeLevel
)
{
if
(
!
mPresContext
)
{
return
;
}
Element
*
element
=
AnimationUtils
:
:
GetElementForRestyle
(
aElement
aPseudoType
)
;
if
(
!
element
)
{
return
;
}
RestyleHint
hint
=
aCascadeLevel
=
=
CascadeLevel
:
:
Transitions
?
RestyleHint
:
:
RESTYLE_CSS_TRANSITIONS
:
RestyleHint
:
:
RESTYLE_CSS_ANIMATIONS
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Restyle
request
during
restyling
should
be
requested
only
on
"
"
the
main
-
thread
.
e
.
g
.
after
the
parallel
traversal
"
)
;
if
(
ServoStyleSet
:
:
IsInServoTraversal
(
)
|
|
mIsInPreTraverse
)
{
MOZ_ASSERT
(
hint
=
=
RestyleHint
:
:
RESTYLE_CSS_ANIMATIONS
|
|
hint
=
=
RestyleHint
:
:
RESTYLE_CSS_TRANSITIONS
)
;
return
;
}
MOZ_ASSERT
(
!
mPresContext
-
>
RestyleManager
(
)
-
>
IsInStyleRefresh
(
)
)
;
mPresContext
-
>
PresShell
(
)
-
>
RestyleForAnimation
(
element
hint
)
;
}
void
EffectCompositor
:
:
PostRestyleForThrottledAnimations
(
)
{
for
(
size_t
i
=
0
;
i
<
kCascadeLevelCount
;
i
+
+
)
{
CascadeLevel
cascadeLevel
=
CascadeLevel
(
i
)
;
auto
&
elementSet
=
mElementsToRestyle
[
cascadeLevel
]
;
for
(
auto
iter
=
elementSet
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
bool
&
postedRestyle
=
iter
.
Data
(
)
;
if
(
postedRestyle
)
{
continue
;
}
PostRestyleForAnimation
(
iter
.
Key
(
)
.
mElement
iter
.
Key
(
)
.
mPseudoType
cascadeLevel
)
;
postedRestyle
=
true
;
}
}
}
void
EffectCompositor
:
:
ClearRestyleRequestsFor
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
auto
&
elementsToRestyle
=
mElementsToRestyle
[
CascadeLevel
:
:
Animations
]
;
PseudoStyleType
pseudoType
=
aElement
-
>
GetPseudoElementType
(
)
;
if
(
pseudoType
=
=
PseudoStyleType
:
:
NotPseudo
)
{
PseudoElementHashEntry
:
:
KeyType
notPseudoKey
=
{
aElement
PseudoStyleType
:
:
NotPseudo
}
;
PseudoElementHashEntry
:
:
KeyType
beforePseudoKey
=
{
aElement
PseudoStyleType
:
:
before
}
;
PseudoElementHashEntry
:
:
KeyType
afterPseudoKey
=
{
aElement
PseudoStyleType
:
:
after
}
;
PseudoElementHashEntry
:
:
KeyType
markerPseudoKey
=
{
aElement
PseudoStyleType
:
:
marker
}
;
elementsToRestyle
.
Remove
(
notPseudoKey
)
;
elementsToRestyle
.
Remove
(
beforePseudoKey
)
;
elementsToRestyle
.
Remove
(
afterPseudoKey
)
;
elementsToRestyle
.
Remove
(
markerPseudoKey
)
;
}
else
if
(
AnimationUtils
:
:
IsSupportedPseudoForAnimations
(
pseudoType
)
)
{
Element
*
parentElement
=
aElement
-
>
GetParentElement
(
)
;
MOZ_ASSERT
(
parentElement
)
;
PseudoElementHashEntry
:
:
KeyType
key
=
{
parentElement
pseudoType
}
;
elementsToRestyle
.
Remove
(
key
)
;
}
}
void
EffectCompositor
:
:
UpdateEffectProperties
(
const
ComputedStyle
*
aStyle
Element
*
aElement
PseudoStyleType
aPseudoType
)
{
EffectSet
*
effectSet
=
EffectSet
:
:
Get
(
aElement
aPseudoType
)
;
if
(
!
effectSet
)
{
return
;
}
effectSet
-
>
MarkCascadeNeedsUpdate
(
)
;
for
(
KeyframeEffect
*
effect
:
*
effectSet
)
{
effect
-
>
UpdateProperties
(
aStyle
)
;
}
}
namespace
{
class
EffectCompositeOrderComparator
{
public
:
bool
Equals
(
const
KeyframeEffect
*
a
const
KeyframeEffect
*
b
)
const
{
return
a
=
=
b
;
}
bool
LessThan
(
const
KeyframeEffect
*
a
const
KeyframeEffect
*
b
)
const
{
MOZ_ASSERT
(
a
-
>
GetAnimation
(
)
&
&
b
-
>
GetAnimation
(
)
)
;
MOZ_ASSERT
(
Equals
(
a
b
)
|
|
a
-
>
GetAnimation
(
)
-
>
HasLowerCompositeOrderThan
(
*
b
-
>
GetAnimation
(
)
)
!
=
b
-
>
GetAnimation
(
)
-
>
HasLowerCompositeOrderThan
(
*
a
-
>
GetAnimation
(
)
)
)
;
return
a
-
>
GetAnimation
(
)
-
>
HasLowerCompositeOrderThan
(
*
b
-
>
GetAnimation
(
)
)
;
}
}
;
}
static
void
ComposeSortedEffects
(
const
nsTArray
<
KeyframeEffect
*
>
&
aSortedEffects
const
EffectSet
*
aEffectSet
EffectCompositor
:
:
CascadeLevel
aCascadeLevel
StyleAnimationValueMap
*
aAnimationValues
)
{
const
bool
isTransition
=
aCascadeLevel
=
=
EffectCompositor
:
:
CascadeLevel
:
:
Transitions
;
nsCSSPropertyIDSet
propertiesToSkip
;
if
(
aEffectSet
)
{
propertiesToSkip
=
isTransition
?
aEffectSet
-
>
PropertiesForAnimationsLevel
(
)
:
aEffectSet
-
>
PropertiesForAnimationsLevel
(
)
.
Inverse
(
)
;
}
for
(
KeyframeEffect
*
effect
:
aSortedEffects
)
{
auto
*
animation
=
effect
-
>
GetAnimation
(
)
;
MOZ_ASSERT
(
!
isTransition
|
|
animation
-
>
CascadeLevel
(
)
=
=
aCascadeLevel
)
;
animation
-
>
ComposeStyle
(
*
aAnimationValues
propertiesToSkip
)
;
}
}
bool
EffectCompositor
:
:
GetServoAnimationRule
(
const
dom
:
:
Element
*
aElement
PseudoStyleType
aPseudoType
CascadeLevel
aCascadeLevel
StyleAnimationValueMap
*
aAnimationValues
)
{
MOZ_ASSERT
(
aAnimationValues
)
;
MOZ_ASSERT
(
nsContentUtils
:
:
GetPresShellForContent
(
aElement
)
"
Should
not
be
trying
to
run
animations
on
elements
in
documents
"
"
without
a
pres
shell
(
e
.
g
.
XMLHttpRequest
documents
)
"
)
;
EffectSet
*
effectSet
=
EffectSet
:
:
Get
(
aElement
aPseudoType
)
;
if
(
!
effectSet
)
{
return
false
;
}
const
bool
isTransition
=
aCascadeLevel
=
=
CascadeLevel
:
:
Transitions
;
nsTArray
<
KeyframeEffect
*
>
sortedEffectList
(
effectSet
-
>
Count
(
)
)
;
for
(
KeyframeEffect
*
effect
:
*
effectSet
)
{
if
(
isTransition
&
&
effect
-
>
GetAnimation
(
)
-
>
CascadeLevel
(
)
!
=
aCascadeLevel
)
{
continue
;
}
sortedEffectList
.
AppendElement
(
effect
)
;
}
if
(
sortedEffectList
.
IsEmpty
(
)
)
{
return
false
;
}
sortedEffectList
.
Sort
(
EffectCompositeOrderComparator
(
)
)
;
ComposeSortedEffects
(
sortedEffectList
effectSet
aCascadeLevel
aAnimationValues
)
;
MOZ_ASSERT
(
effectSet
=
=
EffectSet
:
:
Get
(
aElement
aPseudoType
)
"
EffectSet
should
not
change
while
composing
style
"
)
;
return
true
;
}
bool
EffectCompositor
:
:
ComposeServoAnimationRuleForEffect
(
KeyframeEffect
&
aEffect
CascadeLevel
aCascadeLevel
StyleAnimationValueMap
*
aAnimationValues
)
{
MOZ_ASSERT
(
aAnimationValues
)
;
MOZ_ASSERT
(
mPresContext
&
&
mPresContext
-
>
IsDynamic
(
)
"
Should
not
be
in
print
preview
"
)
;
NonOwningAnimationTarget
target
=
aEffect
.
GetAnimationTarget
(
)
;
if
(
!
target
)
{
return
false
;
}
if
(
!
nsContentUtils
:
:
GetPresShellForContent
(
target
.
mElement
)
)
{
return
false
;
}
MaybeUpdateCascadeResults
(
target
.
mElement
target
.
mPseudoType
)
;
EffectSet
*
effectSet
=
EffectSet
:
:
Get
(
target
.
mElement
target
.
mPseudoType
)
;
auto
comparator
=
EffectCompositeOrderComparator
(
)
;
nsTArray
<
KeyframeEffect
*
>
sortedEffectList
(
effectSet
?
effectSet
-
>
Count
(
)
+
1
:
1
)
;
if
(
effectSet
)
{
for
(
KeyframeEffect
*
effect
:
*
effectSet
)
{
if
(
comparator
.
LessThan
(
effect
&
aEffect
)
)
{
sortedEffectList
.
AppendElement
(
effect
)
;
}
}
sortedEffectList
.
Sort
(
comparator
)
;
}
sortedEffectList
.
AppendElement
(
&
aEffect
)
;
ComposeSortedEffects
(
sortedEffectList
effectSet
aCascadeLevel
aAnimationValues
)
;
MOZ_ASSERT
(
effectSet
=
=
EffectSet
:
:
Get
(
target
.
mElement
target
.
mPseudoType
)
"
EffectSet
should
not
change
while
composing
style
"
)
;
return
true
;
}
bool
EffectCompositor
:
:
HasPendingStyleUpdates
(
)
const
{
for
(
auto
&
elementSet
:
mElementsToRestyle
)
{
if
(
elementSet
.
Count
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
EffectCompositor
:
:
HasAnimationsForCompositor
(
const
nsIFrame
*
aFrame
DisplayItemType
aType
)
{
return
FindAnimationsForCompositor
(
aFrame
LayerAnimationInfo
:
:
GetCSSPropertiesFor
(
aType
)
nullptr
)
;
}
nsTArray
<
RefPtr
<
dom
:
:
Animation
>
>
EffectCompositor
:
:
GetAnimationsForCompositor
(
const
nsIFrame
*
aFrame
const
nsCSSPropertyIDSet
&
aPropertySet
)
{
nsTArray
<
RefPtr
<
dom
:
:
Animation
>
>
result
;
#
ifdef
DEBUG
bool
foundSome
=
#
endif
FindAnimationsForCompositor
(
aFrame
aPropertySet
&
result
)
;
MOZ_ASSERT
(
!
foundSome
|
|
!
result
.
IsEmpty
(
)
"
If
return
value
is
true
matches
array
should
be
non
-
empty
"
)
;
return
result
;
}
void
EffectCompositor
:
:
ClearIsRunningOnCompositor
(
const
nsIFrame
*
aFrame
DisplayItemType
aType
)
{
EffectSet
*
effects
=
EffectSet
:
:
GetForFrame
(
aFrame
aType
)
;
if
(
!
effects
)
{
return
;
}
const
nsCSSPropertyIDSet
&
propertySet
=
LayerAnimationInfo
:
:
GetCSSPropertiesFor
(
aType
)
;
for
(
KeyframeEffect
*
effect
:
*
effects
)
{
effect
-
>
SetIsRunningOnCompositor
(
propertySet
false
)
;
}
}
void
EffectCompositor
:
:
MaybeUpdateCascadeResults
(
Element
*
aElement
PseudoStyleType
aPseudoType
)
{
EffectSet
*
effects
=
EffectSet
:
:
Get
(
aElement
aPseudoType
)
;
if
(
!
effects
|
|
!
effects
-
>
CascadeNeedsUpdate
(
)
)
{
return
;
}
UpdateCascadeResults
(
*
effects
aElement
aPseudoType
)
;
MOZ_ASSERT
(
!
effects
-
>
CascadeNeedsUpdate
(
)
"
Failed
to
update
cascade
state
"
)
;
}
Maybe
<
NonOwningAnimationTarget
>
EffectCompositor
:
:
GetAnimationElementAndPseudoForFrame
(
const
nsIFrame
*
aFrame
)
{
Maybe
<
NonOwningAnimationTarget
>
result
;
PseudoStyleType
pseudoType
=
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
;
if
(
pseudoType
!
=
PseudoStyleType
:
:
NotPseudo
&
&
!
AnimationUtils
:
:
IsSupportedPseudoForAnimations
(
pseudoType
)
)
{
return
result
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
)
{
return
result
;
}
if
(
AnimationUtils
:
:
IsSupportedPseudoForAnimations
(
pseudoType
)
)
{
content
=
content
-
>
GetParent
(
)
;
if
(
!
content
)
{
return
result
;
}
}
if
(
!
content
-
>
IsElement
(
)
)
{
return
result
;
}
result
.
emplace
(
content
-
>
AsElement
(
)
pseudoType
)
;
return
result
;
}
nsCSSPropertyIDSet
EffectCompositor
:
:
GetOverriddenProperties
(
EffectSet
&
aEffectSet
Element
*
aElement
PseudoStyleType
aPseudoType
)
{
MOZ_ASSERT
(
aElement
"
Should
have
an
element
to
get
style
data
from
"
)
;
nsCSSPropertyIDSet
result
;
Element
*
elementForRestyle
=
AnimationUtils
:
:
GetElementForRestyle
(
aElement
aPseudoType
)
;
if
(
!
elementForRestyle
)
{
return
result
;
}
static
constexpr
size_t
compositorAnimatableCount
=
nsCSSPropertyIDSet
:
:
CompositorAnimatableCount
(
)
;
AutoTArray
<
nsCSSPropertyID
compositorAnimatableCount
>
propertiesToTrack
;
{
nsCSSPropertyIDSet
propertiesToTrackAsSet
;
for
(
KeyframeEffect
*
effect
:
aEffectSet
)
{
for
(
const
AnimationProperty
&
property
:
effect
-
>
Properties
(
)
)
{
if
(
nsCSSProps
:
:
PropHasFlags
(
property
.
mProperty
CSSPropFlags
:
:
CanAnimateOnCompositor
)
&
&
!
propertiesToTrackAsSet
.
HasProperty
(
property
.
mProperty
)
)
{
propertiesToTrackAsSet
.
AddProperty
(
property
.
mProperty
)
;
propertiesToTrack
.
AppendElement
(
property
.
mProperty
)
;
}
}
if
(
propertiesToTrack
.
Length
(
)
=
=
compositorAnimatableCount
)
{
break
;
}
}
}
if
(
propertiesToTrack
.
IsEmpty
(
)
)
{
return
result
;
}
Servo_GetProperties_Overriding_Animation
(
elementForRestyle
&
propertiesToTrack
&
result
)
;
return
result
;
}
void
EffectCompositor
:
:
UpdateCascadeResults
(
EffectSet
&
aEffectSet
Element
*
aElement
PseudoStyleType
aPseudoType
)
{
MOZ_ASSERT
(
EffectSet
:
:
Get
(
aElement
aPseudoType
)
=
=
&
aEffectSet
"
Effect
set
should
correspond
to
the
specified
(
pseudo
-
)
element
"
)
;
if
(
aEffectSet
.
IsEmpty
(
)
)
{
aEffectSet
.
MarkCascadeUpdated
(
)
;
return
;
}
nsTArray
<
KeyframeEffect
*
>
sortedEffectList
(
aEffectSet
.
Count
(
)
)
;
for
(
KeyframeEffect
*
effect
:
aEffectSet
)
{
sortedEffectList
.
AppendElement
(
effect
)
;
}
sortedEffectList
.
Sort
(
EffectCompositeOrderComparator
(
)
)
;
nsCSSPropertyIDSet
overriddenProperties
=
GetOverriddenProperties
(
aEffectSet
aElement
aPseudoType
)
;
nsCSSPropertyIDSet
&
propertiesWithImportantRules
=
aEffectSet
.
PropertiesWithImportantRules
(
)
;
nsCSSPropertyIDSet
&
propertiesForAnimationsLevel
=
aEffectSet
.
PropertiesForAnimationsLevel
(
)
;
static
constexpr
nsCSSPropertyIDSet
compositorAnimatables
=
nsCSSPropertyIDSet
:
:
CompositorAnimatables
(
)
;
nsCSSPropertyIDSet
prevCompositorPropertiesWithImportantRules
=
propertiesWithImportantRules
.
Intersect
(
compositorAnimatables
)
;
nsCSSPropertyIDSet
prevPropertiesForAnimationsLevel
=
propertiesForAnimationsLevel
;
propertiesWithImportantRules
.
Empty
(
)
;
propertiesForAnimationsLevel
.
Empty
(
)
;
nsCSSPropertyIDSet
propertiesForTransitionsLevel
;
for
(
const
KeyframeEffect
*
effect
:
sortedEffectList
)
{
MOZ_ASSERT
(
effect
-
>
GetAnimation
(
)
"
Effects
on
a
target
element
should
have
an
Animation
"
)
;
CascadeLevel
cascadeLevel
=
effect
-
>
GetAnimation
(
)
-
>
CascadeLevel
(
)
;
for
(
const
AnimationProperty
&
prop
:
effect
-
>
Properties
(
)
)
{
if
(
overriddenProperties
.
HasProperty
(
prop
.
mProperty
)
)
{
propertiesWithImportantRules
.
AddProperty
(
prop
.
mProperty
)
;
}
switch
(
cascadeLevel
)
{
case
EffectCompositor
:
:
CascadeLevel
:
:
Animations
:
propertiesForAnimationsLevel
.
AddProperty
(
prop
.
mProperty
)
;
break
;
case
EffectCompositor
:
:
CascadeLevel
:
:
Transitions
:
propertiesForTransitionsLevel
.
AddProperty
(
prop
.
mProperty
)
;
break
;
}
}
}
aEffectSet
.
MarkCascadeUpdated
(
)
;
nsPresContext
*
presContext
=
nsContentUtils
:
:
GetContextForContent
(
aElement
)
;
if
(
!
presContext
)
{
return
;
}
if
(
!
prevCompositorPropertiesWithImportantRules
.
Equals
(
propertiesWithImportantRules
.
Intersect
(
compositorAnimatables
)
)
)
{
presContext
-
>
EffectCompositor
(
)
-
>
RequestRestyle
(
aElement
aPseudoType
EffectCompositor
:
:
RestyleType
:
:
Layer
EffectCompositor
:
:
CascadeLevel
:
:
Animations
)
;
}
nsCSSPropertyIDSet
changedPropertiesForAnimationLevel
=
prevPropertiesForAnimationsLevel
.
Xor
(
propertiesForAnimationsLevel
)
;
nsCSSPropertyIDSet
commonProperties
=
propertiesForTransitionsLevel
.
Intersect
(
changedPropertiesForAnimationLevel
)
;
if
(
!
commonProperties
.
IsEmpty
(
)
)
{
EffectCompositor
:
:
RestyleType
restyleType
=
changedPropertiesForAnimationLevel
.
Intersects
(
compositorAnimatables
)
?
EffectCompositor
:
:
RestyleType
:
:
Standard
:
EffectCompositor
:
:
RestyleType
:
:
Layer
;
presContext
-
>
EffectCompositor
(
)
-
>
RequestRestyle
(
aElement
aPseudoType
restyleType
EffectCompositor
:
:
CascadeLevel
:
:
Transitions
)
;
}
}
void
EffectCompositor
:
:
SetPerformanceWarning
(
const
nsIFrame
*
aFrame
const
nsCSSPropertyIDSet
&
aPropertySet
const
AnimationPerformanceWarning
&
aWarning
)
{
EffectSet
*
effects
=
EffectSet
:
:
GetForFrame
(
aFrame
aPropertySet
)
;
if
(
!
effects
)
{
return
;
}
for
(
KeyframeEffect
*
effect
:
*
effects
)
{
effect
-
>
SetPerformanceWarning
(
aPropertySet
aWarning
)
;
}
}
bool
EffectCompositor
:
:
PreTraverse
(
ServoTraversalFlags
aFlags
)
{
return
PreTraverseInSubtree
(
aFlags
nullptr
)
;
}
bool
EffectCompositor
:
:
PreTraverseInSubtree
(
ServoTraversalFlags
aFlags
Element
*
aRoot
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
aRoot
|
|
nsContentUtils
:
:
GetPresShellForContent
(
aRoot
)
"
Traversal
root
if
provided
should
be
bound
to
a
display
"
"
document
"
)
;
if
(
aRoot
&
&
(
aRoot
-
>
IsGeneratedContentContainerForBefore
(
)
|
|
aRoot
-
>
IsGeneratedContentContainerForAfter
(
)
|
|
aRoot
-
>
IsGeneratedContentContainerForMarker
(
)
)
)
{
aRoot
=
aRoot
-
>
GetParentElement
(
)
;
}
AutoRestore
<
bool
>
guard
(
mIsInPreTraverse
)
;
mIsInPreTraverse
=
true
;
bool
flushThrottledRestyles
=
(
aRoot
&
&
aRoot
-
>
HasDirtyDescendantsForServo
(
)
)
|
|
(
aFlags
&
ServoTraversalFlags
:
:
FlushThrottledAnimations
)
;
using
ElementsToRestyleIterType
=
nsTHashMap
<
PseudoElementHashEntry
bool
>
:
:
ConstIterator
;
auto
getNeededRestyleTarget
=
[
&
]
(
const
ElementsToRestyleIterType
&
aIter
)
-
>
NonOwningAnimationTarget
{
NonOwningAnimationTarget
returnTarget
;
if
(
!
flushThrottledRestyles
&
&
!
aIter
.
Data
(
)
)
{
return
returnTarget
;
}
const
NonOwningAnimationTarget
&
target
=
aIter
.
Key
(
)
;
if
(
!
nsContentUtils
:
:
GetPresShellForContent
(
target
.
mElement
)
)
{
return
returnTarget
;
}
if
(
aRoot
&
&
!
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOfForStyle
(
target
.
mElement
aRoot
)
)
{
return
returnTarget
;
}
returnTarget
=
target
;
return
returnTarget
;
}
;
bool
foundElementsNeedingRestyle
=
false
;
nsTArray
<
NonOwningAnimationTarget
>
elementsWithCascadeUpdates
;
for
(
size_t
i
=
0
;
i
<
kCascadeLevelCount
;
+
+
i
)
{
CascadeLevel
cascadeLevel
=
CascadeLevel
(
i
)
;
auto
&
elementSet
=
mElementsToRestyle
[
cascadeLevel
]
;
for
(
auto
iter
=
elementSet
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
NonOwningAnimationTarget
&
target
=
getNeededRestyleTarget
(
iter
)
;
if
(
!
target
.
mElement
)
{
continue
;
}
EffectSet
*
effects
=
EffectSet
:
:
Get
(
target
.
mElement
target
.
mPseudoType
)
;
if
(
!
effects
|
|
!
effects
-
>
CascadeNeedsUpdate
(
)
)
{
continue
;
}
elementsWithCascadeUpdates
.
AppendElement
(
target
)
;
}
}
for
(
const
NonOwningAnimationTarget
&
target
:
elementsWithCascadeUpdates
)
{
MaybeUpdateCascadeResults
(
target
.
mElement
target
.
mPseudoType
)
;
}
elementsWithCascadeUpdates
.
Clear
(
)
;
for
(
size_t
i
=
0
;
i
<
kCascadeLevelCount
;
+
+
i
)
{
CascadeLevel
cascadeLevel
=
CascadeLevel
(
i
)
;
auto
&
elementSet
=
mElementsToRestyle
[
cascadeLevel
]
;
for
(
auto
iter
=
elementSet
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
NonOwningAnimationTarget
&
target
=
getNeededRestyleTarget
(
iter
)
;
if
(
!
target
.
mElement
)
{
continue
;
}
if
(
target
.
mElement
-
>
GetComposedDoc
(
)
!
=
mPresContext
-
>
Document
(
)
)
{
iter
.
Remove
(
)
;
continue
;
}
mPresContext
-
>
RestyleManager
(
)
-
>
PostRestyleEventForAnimations
(
target
.
mElement
target
.
mPseudoType
cascadeLevel
=
=
CascadeLevel
:
:
Transitions
?
RestyleHint
:
:
RESTYLE_CSS_TRANSITIONS
:
RestyleHint
:
:
RESTYLE_CSS_ANIMATIONS
)
;
foundElementsNeedingRestyle
=
true
;
auto
*
effects
=
EffectSet
:
:
Get
(
target
.
mElement
target
.
mPseudoType
)
;
if
(
!
effects
)
{
iter
.
Remove
(
)
;
continue
;
}
for
(
KeyframeEffect
*
effect
:
*
effects
)
{
effect
-
>
GetAnimation
(
)
-
>
WillComposeStyle
(
)
;
}
iter
.
Remove
(
)
;
}
if
(
!
aRoot
&
&
flushThrottledRestyles
)
{
elementSet
.
Clear
(
)
;
}
}
return
foundElementsNeedingRestyle
;
}
void
EffectCompositor
:
:
NoteElementForReducing
(
const
NonOwningAnimationTarget
&
aTarget
)
{
if
(
!
StaticPrefs
:
:
dom_animations_api_autoremove_enabled
(
)
)
{
return
;
}
Unused
<
<
mElementsToReduce
.
put
(
OwningAnimationTarget
{
aTarget
.
mElement
aTarget
.
mPseudoType
}
)
;
}
static
void
ReduceEffectSet
(
EffectSet
&
aEffectSet
)
{
nsTArray
<
KeyframeEffect
*
>
sortedEffectList
(
aEffectSet
.
Count
(
)
)
;
for
(
KeyframeEffect
*
effect
:
aEffectSet
)
{
sortedEffectList
.
AppendElement
(
effect
)
;
}
sortedEffectList
.
Sort
(
EffectCompositeOrderComparator
(
)
)
;
nsCSSPropertyIDSet
setProperties
;
for
(
auto
iter
=
sortedEffectList
.
rbegin
(
)
;
iter
!
=
sortedEffectList
.
rend
(
)
;
+
+
iter
)
{
MOZ_ASSERT
(
*
iter
&
&
(
*
iter
)
-
>
GetAnimation
(
)
"
Effect
in
an
EffectSet
should
have
an
animation
"
)
;
KeyframeEffect
&
effect
=
*
*
iter
;
Animation
&
animation
=
*
effect
.
GetAnimation
(
)
;
if
(
animation
.
IsRemovable
(
)
&
&
effect
.
GetPropertySet
(
)
.
IsSubsetOf
(
setProperties
)
)
{
animation
.
Remove
(
)
;
}
else
if
(
animation
.
IsReplaceable
(
)
)
{
setProperties
|
=
effect
.
GetPropertySet
(
)
;
}
}
}
void
EffectCompositor
:
:
ReduceAnimations
(
)
{
for
(
auto
iter
=
mElementsToReduce
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
const
OwningAnimationTarget
&
target
=
iter
.
get
(
)
;
auto
*
effectSet
=
EffectSet
:
:
Get
(
target
.
mElement
target
.
mPseudoType
)
;
if
(
effectSet
)
{
ReduceEffectSet
(
*
effectSet
)
;
}
}
mElementsToReduce
.
clear
(
)
;
}
}
