#
include
"
mozilla
/
KeyframeUtils
.
h
"
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
js
/
ForOfIterator
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
mozilla
/
AnimatedPropertyID
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
RangedArray
.
h
"
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoCSSParser
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
TimingParams
.
h
"
#
include
"
mozilla
/
dom
/
BaseKeyframeTypesBinding
.
h
"
#
include
"
mozilla
/
dom
/
BindingCallContext
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectBinding
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
nsCSSPropertyIDSet
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsPresContextInlines
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
using
mozilla
:
:
dom
:
:
Nullable
;
namespace
mozilla
{
enum
class
ListAllowance
{
eDisallow
eAllow
}
;
struct
PropertyValuesPair
{
PropertyValuesPair
(
)
:
mProperty
(
eCSSProperty_UNKNOWN
)
{
}
AnimatedPropertyID
mProperty
;
nsTArray
<
nsCString
>
mValues
;
}
;
struct
AdditionalProperty
{
AnimatedPropertyID
mProperty
;
size_t
mJsidIndex
=
0
;
struct
PropertyComparator
{
bool
Equals
(
const
AdditionalProperty
&
aLhs
const
AdditionalProperty
&
aRhs
)
const
{
return
aLhs
.
mProperty
=
=
aRhs
.
mProperty
;
}
bool
LessThan
(
const
AdditionalProperty
&
aLhs
const
AdditionalProperty
&
aRhs
)
const
{
bool
customLhs
=
aLhs
.
mProperty
.
mID
=
=
nsCSSPropertyID
:
:
eCSSPropertyExtra_variable
;
bool
customRhs
=
aRhs
.
mProperty
.
mID
=
=
nsCSSPropertyID
:
:
eCSSPropertyExtra_variable
;
if
(
!
customLhs
&
&
!
customRhs
)
{
return
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aLhs
.
mProperty
.
mID
)
<
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aRhs
.
mProperty
.
mID
)
;
}
if
(
customLhs
&
&
customRhs
)
{
return
nsDependentAtomString
(
aLhs
.
mProperty
.
mCustomName
)
<
nsDependentAtomString
(
aRhs
.
mProperty
.
mCustomName
)
;
}
return
!
customLhs
&
&
customRhs
;
}
}
;
}
;
struct
KeyframeValueEntry
{
KeyframeValueEntry
(
)
:
mProperty
(
eCSSProperty_UNKNOWN
)
mOffset
(
)
mComposite
(
)
{
}
AnimatedPropertyID
mProperty
;
AnimationValue
mValue
;
float
mOffset
;
Maybe
<
StyleComputedTimingFunction
>
mTimingFunction
;
dom
:
:
CompositeOperation
mComposite
;
struct
PropertyOffsetComparator
{
static
bool
Equals
(
const
KeyframeValueEntry
&
aLhs
const
KeyframeValueEntry
&
aRhs
)
{
return
aLhs
.
mProperty
=
=
aRhs
.
mProperty
&
&
aLhs
.
mOffset
=
=
aRhs
.
mOffset
;
}
static
bool
LessThan
(
const
KeyframeValueEntry
&
aLhs
const
KeyframeValueEntry
&
aRhs
)
{
bool
customLhs
=
aLhs
.
mProperty
.
mID
=
=
nsCSSPropertyID
:
:
eCSSPropertyExtra_variable
;
bool
customRhs
=
aRhs
.
mProperty
.
mID
=
=
nsCSSPropertyID
:
:
eCSSPropertyExtra_variable
;
if
(
!
customLhs
&
&
!
customRhs
)
{
int32_t
order
=
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aLhs
.
mProperty
.
mID
)
-
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aRhs
.
mProperty
.
mID
)
;
if
(
order
!
=
0
)
{
return
order
<
0
;
}
}
else
if
(
customLhs
&
&
customRhs
)
{
int
order
=
Compare
(
nsDependentAtomString
(
aLhs
.
mProperty
.
mCustomName
)
nsDependentAtomString
(
aRhs
.
mProperty
.
mCustomName
)
)
;
if
(
order
!
=
0
)
{
return
order
<
0
;
}
}
else
{
return
!
customLhs
&
&
customRhs
;
}
return
aLhs
.
mOffset
<
aRhs
.
mOffset
;
}
}
;
}
;
class
ComputedOffsetComparator
{
public
:
static
bool
Equals
(
const
Keyframe
&
aLhs
const
Keyframe
&
aRhs
)
{
return
aLhs
.
mComputedOffset
=
=
aRhs
.
mComputedOffset
;
}
static
bool
LessThan
(
const
Keyframe
&
aLhs
const
Keyframe
&
aRhs
)
{
return
aLhs
.
mComputedOffset
<
aRhs
.
mComputedOffset
;
}
}
;
static
void
GetKeyframeListFromKeyframeSequence
(
JSContext
*
aCx
dom
:
:
Document
*
aDocument
JS
:
:
ForOfIterator
&
aIterator
nsTArray
<
Keyframe
>
&
aResult
const
char
*
aContext
ErrorResult
&
aRv
)
;
static
bool
ConvertKeyframeSequence
(
JSContext
*
aCx
dom
:
:
Document
*
aDocument
JS
:
:
ForOfIterator
&
aIterator
const
char
*
aContext
nsTArray
<
Keyframe
>
&
aResult
)
;
static
bool
GetPropertyValuesPairs
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
ListAllowance
aAllowLists
nsTArray
<
PropertyValuesPair
>
&
aResult
)
;
static
bool
AppendStringOrStringSequenceToArray
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ListAllowance
aAllowLists
nsTArray
<
nsCString
>
&
aValues
)
;
static
bool
AppendValueAsString
(
JSContext
*
aCx
nsTArray
<
nsCString
>
&
aValues
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
;
static
Maybe
<
PropertyValuePair
>
MakePropertyValuePair
(
const
AnimatedPropertyID
&
aProperty
const
nsACString
&
aStringValue
dom
:
:
Document
*
aDocument
)
;
static
bool
HasValidOffsets
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
)
;
#
ifdef
DEBUG
static
void
MarkAsComputeValuesFailureKey
(
PropertyValuePair
&
aPair
)
;
#
endif
static
nsTArray
<
ComputedKeyframeValues
>
GetComputedKeyframeValues
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
dom
:
:
Element
*
aElement
const
PseudoStyleRequest
&
aPseudoRequest
const
ComputedStyle
*
aComputedValues
)
;
static
void
BuildSegmentsFromValueEntries
(
nsTArray
<
KeyframeValueEntry
>
&
aEntries
nsTArray
<
AnimationProperty
>
&
aResult
)
;
static
void
GetKeyframeListFromPropertyIndexedKeyframe
(
JSContext
*
aCx
dom
:
:
Document
*
aDocument
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
nsTArray
<
Keyframe
>
&
aResult
ErrorResult
&
aRv
)
;
static
void
DistributeRange
(
const
Range
<
Keyframe
>
&
aRange
)
;
nsTArray
<
Keyframe
>
KeyframeUtils
:
:
GetKeyframesFromObject
(
JSContext
*
aCx
dom
:
:
Document
*
aDocument
JS
:
:
Handle
<
JSObject
*
>
aFrames
const
char
*
aContext
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
nsTArray
<
Keyframe
>
keyframes
;
if
(
!
aFrames
)
{
return
keyframes
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
objectValue
(
aCx
JS
:
:
ObjectValue
(
*
aFrames
)
)
;
JS
:
:
ForOfIterator
iter
(
aCx
)
;
if
(
!
iter
.
init
(
objectValue
JS
:
:
ForOfIterator
:
:
AllowNonIterable
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
keyframes
;
}
if
(
iter
.
valueIsIterable
(
)
)
{
GetKeyframeListFromKeyframeSequence
(
aCx
aDocument
iter
keyframes
aContext
aRv
)
;
}
else
{
GetKeyframeListFromPropertyIndexedKeyframe
(
aCx
aDocument
objectValue
keyframes
aRv
)
;
}
if
(
aRv
.
Failed
(
)
)
{
MOZ_ASSERT
(
keyframes
.
IsEmpty
(
)
"
Should
not
set
any
keyframes
when
there
is
an
error
"
)
;
return
keyframes
;
}
return
keyframes
;
}
void
KeyframeUtils
:
:
DistributeKeyframes
(
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
if
(
aKeyframes
.
IsEmpty
(
)
)
{
return
;
}
if
(
aKeyframes
.
Length
(
)
>
1
)
{
Keyframe
&
firstElement
=
aKeyframes
[
0
]
;
firstElement
.
mComputedOffset
=
firstElement
.
mOffset
.
valueOr
(
0
.
0
)
;
}
else
{
Keyframe
&
lastElement
=
aKeyframes
.
LastElement
(
)
;
lastElement
.
mComputedOffset
=
lastElement
.
mOffset
.
valueOr
(
1
.
0
)
;
}
const
Keyframe
*
const
last
=
&
aKeyframes
.
LastElement
(
)
;
const
RangedPtr
<
Keyframe
>
begin
(
aKeyframes
.
Elements
(
)
aKeyframes
.
Length
(
)
)
;
RangedPtr
<
Keyframe
>
keyframeA
=
begin
;
while
(
keyframeA
!
=
last
)
{
RangedPtr
<
Keyframe
>
keyframeB
=
keyframeA
+
1
;
while
(
keyframeB
-
>
mOffset
.
isNothing
(
)
&
&
keyframeB
!
=
last
)
{
+
+
keyframeB
;
}
keyframeB
-
>
mComputedOffset
=
keyframeB
-
>
mOffset
.
valueOr
(
1
.
0
)
;
DistributeRange
(
Range
<
Keyframe
>
(
keyframeA
keyframeB
+
1
)
)
;
keyframeA
=
keyframeB
;
}
}
nsTArray
<
AnimationProperty
>
KeyframeUtils
:
:
GetAnimationPropertiesFromKeyframes
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
dom
:
:
Element
*
aElement
const
PseudoStyleRequest
&
aPseudoRequest
const
ComputedStyle
*
aStyle
dom
:
:
CompositeOperation
aEffectComposite
)
{
nsTArray
<
AnimationProperty
>
result
;
const
nsTArray
<
ComputedKeyframeValues
>
computedValues
=
GetComputedKeyframeValues
(
aKeyframes
aElement
aPseudoRequest
aStyle
)
;
if
(
computedValues
.
IsEmpty
(
)
)
{
return
result
;
}
MOZ_ASSERT
(
aKeyframes
.
Length
(
)
=
=
computedValues
.
Length
(
)
"
Array
length
mismatch
"
)
;
nsTArray
<
KeyframeValueEntry
>
entries
(
aKeyframes
.
Length
(
)
)
;
const
size_t
len
=
aKeyframes
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
len
;
+
+
i
)
{
const
Keyframe
&
frame
=
aKeyframes
[
i
]
;
for
(
auto
&
value
:
computedValues
[
i
]
)
{
MOZ_ASSERT
(
frame
.
mComputedOffset
!
=
Keyframe
:
:
kComputedOffsetNotSet
"
Invalid
computed
offset
"
)
;
KeyframeValueEntry
*
entry
=
entries
.
AppendElement
(
)
;
entry
-
>
mOffset
=
frame
.
mComputedOffset
;
entry
-
>
mProperty
=
value
.
mProperty
;
entry
-
>
mValue
=
value
.
mValue
;
entry
-
>
mTimingFunction
=
frame
.
mTimingFunction
;
entry
-
>
mComposite
=
frame
.
mComposite
=
=
dom
:
:
CompositeOperationOrAuto
:
:
Auto
?
aEffectComposite
:
static_cast
<
dom
:
:
CompositeOperation
>
(
frame
.
mComposite
)
;
}
}
BuildSegmentsFromValueEntries
(
entries
result
)
;
return
result
;
}
bool
KeyframeUtils
:
:
IsAnimatableProperty
(
const
AnimatedPropertyID
&
aProperty
)
{
if
(
aProperty
.
mID
=
=
eCSSProperty_display
)
{
return
false
;
}
return
Servo_Property_IsAnimatable
(
&
aProperty
)
;
}
static
void
GetKeyframeListFromKeyframeSequence
(
JSContext
*
aCx
dom
:
:
Document
*
aDocument
JS
:
:
ForOfIterator
&
aIterator
nsTArray
<
Keyframe
>
&
aResult
const
char
*
aContext
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
)
;
if
(
!
ConvertKeyframeSequence
(
aCx
aDocument
aIterator
aContext
aResult
)
)
{
aResult
.
Clear
(
)
;
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
if
(
aResult
.
IsEmpty
(
)
)
{
return
;
}
if
(
!
HasValidOffsets
(
aResult
)
)
{
aResult
.
Clear
(
)
;
aRv
.
ThrowTypeError
<
dom
:
:
MSG_INVALID_KEYFRAME_OFFSETS
>
(
)
;
return
;
}
}
static
bool
ConvertKeyframeSequence
(
JSContext
*
aCx
dom
:
:
Document
*
aDocument
JS
:
:
ForOfIterator
&
aIterator
const
char
*
aContext
nsTArray
<
Keyframe
>
&
aResult
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
IgnoredErrorResult
parseEasingResult
;
for
(
;
;
)
{
bool
done
;
if
(
!
aIterator
.
next
(
&
value
&
done
)
)
{
return
false
;
}
if
(
done
)
{
break
;
}
if
(
!
value
.
isObject
(
)
&
&
!
value
.
isNullOrUndefined
(
)
)
{
dom
:
:
ThrowErrorMessage
<
dom
:
:
MSG_NOT_OBJECT
>
(
aCx
aContext
"
Element
of
sequence
<
Keyframe
>
argument
"
)
;
return
false
;
}
dom
:
:
binding_detail
:
:
FastBaseKeyframe
keyframeDict
;
dom
:
:
BindingCallContext
callCx
(
aCx
aContext
)
;
if
(
!
keyframeDict
.
Init
(
callCx
value
"
Element
of
sequence
<
Keyframe
>
argument
"
)
)
{
return
false
;
}
Keyframe
*
keyframe
=
aResult
.
AppendElement
(
fallible
)
;
if
(
!
keyframe
)
{
return
false
;
}
if
(
!
keyframeDict
.
mOffset
.
IsNull
(
)
)
{
keyframe
-
>
mOffset
.
emplace
(
keyframeDict
.
mOffset
.
Value
(
)
)
;
}
keyframe
-
>
mComposite
=
keyframeDict
.
mComposite
;
nsTArray
<
PropertyValuesPair
>
propertyValuePairs
;
if
(
value
.
isObject
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
object
(
aCx
&
value
.
toObject
(
)
)
;
if
(
!
GetPropertyValuesPairs
(
aCx
object
ListAllowance
:
:
eDisallow
propertyValuePairs
)
)
{
return
false
;
}
}
if
(
!
parseEasingResult
.
Failed
(
)
)
{
keyframe
-
>
mTimingFunction
=
TimingParams
:
:
ParseEasing
(
keyframeDict
.
mEasing
parseEasingResult
)
;
}
for
(
PropertyValuesPair
&
pair
:
propertyValuePairs
)
{
MOZ_ASSERT
(
pair
.
mValues
.
Length
(
)
=
=
1
)
;
Maybe
<
PropertyValuePair
>
valuePair
=
MakePropertyValuePair
(
pair
.
mProperty
pair
.
mValues
[
0
]
aDocument
)
;
if
(
!
valuePair
)
{
continue
;
}
keyframe
-
>
mPropertyValues
.
AppendElement
(
std
:
:
move
(
valuePair
.
ref
(
)
)
)
;
#
ifdef
DEBUG
if
(
nsCSSProps
:
:
IsShorthand
(
pair
.
mProperty
.
mID
)
&
&
keyframeDict
.
mSimulateComputeValuesFailure
)
{
MarkAsComputeValuesFailureKey
(
keyframe
-
>
mPropertyValues
.
LastElement
(
)
)
;
}
#
endif
}
}
if
(
parseEasingResult
.
MaybeSetPendingException
(
aCx
)
)
{
return
false
;
}
return
true
;
}
static
bool
GetPropertyValuesPairs
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
ListAllowance
aAllowLists
nsTArray
<
PropertyValuesPair
>
&
aResult
)
{
nsTArray
<
AdditionalProperty
>
properties
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
ids
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
aObject
&
ids
)
)
{
return
false
;
}
for
(
size_t
i
=
0
n
=
ids
.
length
(
)
;
i
<
n
;
i
+
+
)
{
nsAutoJSCString
propName
;
if
(
!
propName
.
init
(
aCx
ids
[
i
]
)
)
{
return
false
;
}
nsCSSPropertyID
propertyID
=
nsCSSPropertyID
:
:
eCSSProperty_UNKNOWN
;
if
(
nsCSSProps
:
:
IsCustomPropertyName
(
propName
)
)
{
propertyID
=
eCSSPropertyExtra_variable
;
}
else
if
(
propName
.
EqualsLiteral
(
"
cssOffset
"
)
)
{
propertyID
=
nsCSSPropertyID
:
:
eCSSProperty_offset
;
}
else
if
(
propName
.
EqualsLiteral
(
"
cssFloat
"
)
)
{
propertyID
=
nsCSSPropertyID
:
:
eCSSProperty_float
;
}
else
if
(
!
propName
.
EqualsLiteral
(
"
offset
"
)
&
&
!
propName
.
EqualsLiteral
(
"
float
"
)
)
{
propertyID
=
nsCSSProps
:
:
LookupPropertyByIDLName
(
propName
CSSEnabledState
:
:
ForAllContent
)
;
}
AnimatedPropertyID
property
=
propertyID
=
=
eCSSPropertyExtra_variable
?
AnimatedPropertyID
(
NS_Atomize
(
Substring
(
propName
2
propName
.
Length
(
)
-
2
)
)
)
:
AnimatedPropertyID
(
propertyID
)
;
if
(
KeyframeUtils
:
:
IsAnimatableProperty
(
property
)
)
{
properties
.
AppendElement
(
AdditionalProperty
{
std
:
:
move
(
property
)
i
}
)
;
}
}
properties
.
Sort
(
AdditionalProperty
:
:
PropertyComparator
(
)
)
;
for
(
AdditionalProperty
&
p
:
properties
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
JS_GetPropertyById
(
aCx
aObject
ids
[
p
.
mJsidIndex
]
&
value
)
)
{
return
false
;
}
PropertyValuesPair
*
pair
=
aResult
.
AppendElement
(
)
;
pair
-
>
mProperty
=
p
.
mProperty
;
if
(
!
AppendStringOrStringSequenceToArray
(
aCx
value
aAllowLists
pair
-
>
mValues
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
AppendStringOrStringSequenceToArray
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ListAllowance
aAllowLists
nsTArray
<
nsCString
>
&
aValues
)
{
if
(
aAllowLists
=
=
ListAllowance
:
:
eAllow
&
&
aValue
.
isObject
(
)
)
{
JS
:
:
ForOfIterator
iter
(
aCx
)
;
if
(
!
iter
.
init
(
aValue
JS
:
:
ForOfIterator
:
:
AllowNonIterable
)
)
{
return
false
;
}
if
(
iter
.
valueIsIterable
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
element
(
aCx
)
;
for
(
;
;
)
{
bool
done
;
if
(
!
iter
.
next
(
&
element
&
done
)
)
{
return
false
;
}
if
(
done
)
{
break
;
}
if
(
!
AppendValueAsString
(
aCx
aValues
element
)
)
{
return
false
;
}
}
return
true
;
}
}
if
(
!
AppendValueAsString
(
aCx
aValues
aValue
)
)
{
return
false
;
}
return
true
;
}
static
bool
AppendValueAsString
(
JSContext
*
aCx
nsTArray
<
nsCString
>
&
aValues
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
return
ConvertJSValueToString
(
aCx
aValue
dom
:
:
eStringify
dom
:
:
eStringify
*
aValues
.
AppendElement
(
)
)
;
}
static
void
ReportInvalidPropertyValueToConsole
(
const
AnimatedPropertyID
&
aProperty
const
nsACString
&
aInvalidPropertyValue
dom
:
:
Document
*
aDoc
)
{
AutoTArray
<
nsString
2
>
params
;
params
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
aInvalidPropertyValue
)
)
;
aProperty
.
ToString
(
*
params
.
AppendElement
(
)
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
Animation
"
_ns
aDoc
nsContentUtils
:
:
eDOM_PROPERTIES
"
InvalidKeyframePropertyValue
"
params
)
;
}
static
Maybe
<
PropertyValuePair
>
MakePropertyValuePair
(
const
AnimatedPropertyID
&
aProperty
const
nsACString
&
aStringValue
dom
:
:
Document
*
aDocument
)
{
MOZ_ASSERT
(
aDocument
)
;
Maybe
<
PropertyValuePair
>
result
;
ServoCSSParser
:
:
ParsingEnvironment
env
=
ServoCSSParser
:
:
GetParsingEnvironment
(
aDocument
)
;
RefPtr
<
StyleLockedDeclarationBlock
>
servoDeclarationBlock
=
ServoCSSParser
:
:
ParseProperty
(
aProperty
aStringValue
env
StyleParsingMode
:
:
DEFAULT
)
;
if
(
servoDeclarationBlock
)
{
result
.
emplace
(
aProperty
std
:
:
move
(
servoDeclarationBlock
)
)
;
}
else
{
ReportInvalidPropertyValueToConsole
(
aProperty
aStringValue
aDocument
)
;
}
return
result
;
}
static
bool
HasValidOffsets
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
double
offset
=
0
.
0
;
for
(
const
Keyframe
&
keyframe
:
aKeyframes
)
{
if
(
keyframe
.
mOffset
)
{
double
thisOffset
=
keyframe
.
mOffset
.
value
(
)
;
if
(
thisOffset
<
offset
|
|
thisOffset
>
1
.
0f
)
{
return
false
;
}
offset
=
thisOffset
;
}
}
return
true
;
}
#
ifdef
DEBUG
static
void
MarkAsComputeValuesFailureKey
(
PropertyValuePair
&
aPair
)
{
MOZ_ASSERT
(
nsCSSProps
:
:
IsShorthand
(
aPair
.
mProperty
.
mID
)
"
Only
shorthand
property
values
can
be
marked
as
failure
values
"
)
;
aPair
.
mSimulateComputeValuesFailure
=
true
;
}
#
endif
static
nsTArray
<
ComputedKeyframeValues
>
GetComputedKeyframeValues
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
dom
:
:
Element
*
aElement
const
PseudoStyleRequest
&
aPseudoRequest
const
ComputedStyle
*
aComputedStyle
)
{
MOZ_ASSERT
(
aElement
)
;
nsTArray
<
ComputedKeyframeValues
>
result
;
nsPresContext
*
presContext
=
nsContentUtils
:
:
GetContextForContent
(
aElement
)
;
if
(
!
presContext
)
{
return
result
;
}
result
=
presContext
-
>
StyleSet
(
)
-
>
GetComputedKeyframeValuesFor
(
aKeyframes
aElement
aPseudoRequest
aComputedStyle
)
;
return
result
;
}
static
void
AppendInitialSegment
(
AnimationProperty
*
aAnimationProperty
const
KeyframeValueEntry
&
aFirstEntry
)
{
AnimationPropertySegment
*
segment
=
aAnimationProperty
-
>
mSegments
.
AppendElement
(
)
;
segment
-
>
mFromKey
=
0
.
0f
;
segment
-
>
mToKey
=
aFirstEntry
.
mOffset
;
segment
-
>
mToValue
=
aFirstEntry
.
mValue
;
segment
-
>
mToComposite
=
aFirstEntry
.
mComposite
;
}
static
void
AppendFinalSegment
(
AnimationProperty
*
aAnimationProperty
const
KeyframeValueEntry
&
aLastEntry
)
{
AnimationPropertySegment
*
segment
=
aAnimationProperty
-
>
mSegments
.
AppendElement
(
)
;
segment
-
>
mFromKey
=
aLastEntry
.
mOffset
;
segment
-
>
mFromValue
=
aLastEntry
.
mValue
;
segment
-
>
mFromComposite
=
aLastEntry
.
mComposite
;
segment
-
>
mToKey
=
1
.
0f
;
segment
-
>
mTimingFunction
=
aLastEntry
.
mTimingFunction
;
}
static
AnimationProperty
*
HandleMissingInitialKeyframe
(
nsTArray
<
AnimationProperty
>
&
aResult
const
KeyframeValueEntry
&
aEntry
)
{
MOZ_ASSERT
(
aEntry
.
mOffset
!
=
0
.
0f
"
The
offset
of
the
entry
should
not
be
0
.
0
"
)
;
AnimationProperty
*
result
=
aResult
.
AppendElement
(
)
;
result
-
>
mProperty
=
aEntry
.
mProperty
;
AppendInitialSegment
(
result
aEntry
)
;
return
result
;
}
static
void
HandleMissingFinalKeyframe
(
nsTArray
<
AnimationProperty
>
&
aResult
const
KeyframeValueEntry
&
aEntry
AnimationProperty
*
aCurrentAnimationProperty
)
{
MOZ_ASSERT
(
aEntry
.
mOffset
!
=
1
.
0f
"
The
offset
of
the
entry
should
not
be
1
.
0
"
)
;
if
(
!
aCurrentAnimationProperty
)
{
aCurrentAnimationProperty
=
aResult
.
AppendElement
(
)
;
aCurrentAnimationProperty
-
>
mProperty
=
aEntry
.
mProperty
;
if
(
aEntry
.
mOffset
!
=
0
.
0f
)
{
AppendInitialSegment
(
aCurrentAnimationProperty
aEntry
)
;
}
}
AppendFinalSegment
(
aCurrentAnimationProperty
aEntry
)
;
}
static
void
BuildSegmentsFromValueEntries
(
nsTArray
<
KeyframeValueEntry
>
&
aEntries
nsTArray
<
AnimationProperty
>
&
aResult
)
{
if
(
aEntries
.
IsEmpty
(
)
)
{
return
;
}
std
:
:
stable_sort
(
aEntries
.
begin
(
)
aEntries
.
end
(
)
&
KeyframeValueEntry
:
:
PropertyOffsetComparator
:
:
LessThan
)
;
AnimatedPropertyID
lastProperty
(
eCSSProperty_UNKNOWN
)
;
AnimationProperty
*
animationProperty
=
nullptr
;
size_t
i
=
0
n
=
aEntries
.
Length
(
)
;
while
(
i
<
n
)
{
if
(
i
+
1
=
=
n
)
{
if
(
aEntries
[
i
]
.
mOffset
!
=
1
.
0f
)
{
HandleMissingFinalKeyframe
(
aResult
aEntries
[
i
]
animationProperty
)
;
}
else
if
(
aEntries
[
i
]
.
mOffset
=
=
1
.
0f
&
&
!
animationProperty
)
{
Unused
<
<
HandleMissingInitialKeyframe
(
aResult
aEntries
[
i
]
)
;
}
animationProperty
=
nullptr
;
break
;
}
MOZ_ASSERT
(
aEntries
[
i
]
.
mProperty
.
IsValid
(
)
&
&
aEntries
[
i
+
1
]
.
mProperty
.
IsValid
(
)
"
Each
entry
should
specify
a
valid
property
"
)
;
if
(
aEntries
[
i
]
.
mProperty
!
=
lastProperty
&
&
aEntries
[
i
]
.
mOffset
!
=
0
.
0f
)
{
animationProperty
=
HandleMissingInitialKeyframe
(
aResult
aEntries
[
i
]
)
;
if
(
animationProperty
)
{
lastProperty
=
aEntries
[
i
]
.
mProperty
;
}
else
{
+
+
i
;
continue
;
}
}
if
(
aEntries
[
i
]
.
mProperty
=
=
aEntries
[
i
+
1
]
.
mProperty
&
&
aEntries
[
i
]
.
mOffset
=
=
aEntries
[
i
+
1
]
.
mOffset
&
&
aEntries
[
i
]
.
mOffset
!
=
1
.
0f
&
&
aEntries
[
i
]
.
mOffset
!
=
0
.
0f
)
{
+
+
i
;
continue
;
}
if
(
aEntries
[
i
]
.
mProperty
!
=
aEntries
[
i
+
1
]
.
mProperty
&
&
aEntries
[
i
]
.
mOffset
!
=
1
.
0f
)
{
HandleMissingFinalKeyframe
(
aResult
aEntries
[
i
]
animationProperty
)
;
animationProperty
=
nullptr
;
+
+
i
;
continue
;
}
size_t
j
=
i
+
1
;
if
(
aEntries
[
i
]
.
mOffset
=
=
0
.
0f
&
&
aEntries
[
i
+
1
]
.
mOffset
=
=
0
.
0f
)
{
MOZ_ASSERT
(
aEntries
[
i
]
.
mProperty
=
=
aEntries
[
i
+
1
]
.
mProperty
)
;
while
(
j
+
1
<
n
&
&
aEntries
[
j
+
1
]
.
mOffset
=
=
0
.
0f
&
&
aEntries
[
j
+
1
]
.
mProperty
=
=
aEntries
[
j
]
.
mProperty
)
{
+
+
j
;
}
}
else
if
(
aEntries
[
i
]
.
mOffset
=
=
1
.
0f
)
{
if
(
aEntries
[
i
+
1
]
.
mOffset
=
=
1
.
0f
&
&
aEntries
[
i
+
1
]
.
mProperty
=
=
aEntries
[
i
]
.
mProperty
)
{
while
(
j
+
1
<
n
&
&
aEntries
[
j
+
1
]
.
mOffset
=
=
1
.
0f
&
&
aEntries
[
j
+
1
]
.
mProperty
=
=
aEntries
[
j
]
.
mProperty
)
{
+
+
j
;
}
}
else
{
MOZ_ASSERT
(
aEntries
[
i
]
.
mProperty
!
=
aEntries
[
i
+
1
]
.
mProperty
)
;
animationProperty
=
nullptr
;
+
+
i
;
continue
;
}
}
if
(
aEntries
[
i
]
.
mProperty
!
=
lastProperty
)
{
MOZ_ASSERT
(
aEntries
[
i
]
.
mOffset
=
=
0
.
0f
)
;
MOZ_ASSERT
(
!
animationProperty
)
;
animationProperty
=
aResult
.
AppendElement
(
)
;
animationProperty
-
>
mProperty
=
aEntries
[
i
]
.
mProperty
;
lastProperty
=
aEntries
[
i
]
.
mProperty
;
}
MOZ_ASSERT
(
animationProperty
"
animationProperty
should
be
valid
pointer
.
"
)
;
AnimationPropertySegment
*
segment
=
animationProperty
-
>
mSegments
.
AppendElement
(
)
;
segment
-
>
mFromKey
=
aEntries
[
i
]
.
mOffset
;
segment
-
>
mToKey
=
aEntries
[
j
]
.
mOffset
;
segment
-
>
mFromValue
=
aEntries
[
i
]
.
mValue
;
segment
-
>
mToValue
=
aEntries
[
j
]
.
mValue
;
segment
-
>
mTimingFunction
=
aEntries
[
i
]
.
mTimingFunction
;
segment
-
>
mFromComposite
=
aEntries
[
i
]
.
mComposite
;
segment
-
>
mToComposite
=
aEntries
[
j
]
.
mComposite
;
i
=
j
;
}
}
static
void
GetKeyframeListFromPropertyIndexedKeyframe
(
JSContext
*
aCx
dom
:
:
Document
*
aDocument
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
nsTArray
<
Keyframe
>
&
aResult
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aValue
.
isObject
(
)
)
;
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
dom
:
:
binding_detail
:
:
FastBasePropertyIndexedKeyframe
keyframeDict
;
if
(
!
keyframeDict
.
Init
(
aCx
aValue
"
BasePropertyIndexedKeyframe
argument
"
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
object
(
aCx
&
aValue
.
toObject
(
)
)
;
nsTArray
<
PropertyValuesPair
>
propertyValuesPairs
;
if
(
!
GetPropertyValuesPairs
(
aCx
object
ListAllowance
:
:
eAllow
propertyValuesPairs
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsTHashMap
<
nsFloatHashKey
Keyframe
>
processedKeyframes
;
for
(
const
PropertyValuesPair
&
pair
:
propertyValuesPairs
)
{
size_t
count
=
pair
.
mValues
.
Length
(
)
;
if
(
count
=
=
0
)
{
continue
;
}
size_t
n
=
pair
.
mValues
.
Length
(
)
-
1
;
size_t
i
=
0
;
for
(
const
nsCString
&
stringValue
:
pair
.
mValues
)
{
double
offset
=
n
?
i
+
+
/
double
(
n
)
:
1
;
Keyframe
&
keyframe
=
processedKeyframes
.
LookupOrInsert
(
offset
)
;
if
(
keyframe
.
mPropertyValues
.
IsEmpty
(
)
)
{
keyframe
.
mComputedOffset
=
offset
;
}
Maybe
<
PropertyValuePair
>
valuePair
=
MakePropertyValuePair
(
pair
.
mProperty
stringValue
aDocument
)
;
if
(
!
valuePair
)
{
continue
;
}
keyframe
.
mPropertyValues
.
AppendElement
(
std
:
:
move
(
valuePair
.
ref
(
)
)
)
;
}
}
aResult
.
SetCapacity
(
processedKeyframes
.
Count
(
)
)
;
std
:
:
transform
(
processedKeyframes
.
begin
(
)
processedKeyframes
.
end
(
)
MakeBackInserter
(
aResult
)
[
]
(
auto
&
entry
)
{
return
std
:
:
move
(
*
entry
.
GetModifiableData
(
)
)
;
}
)
;
aResult
.
Sort
(
ComputedOffsetComparator
(
)
)
;
const
FallibleTArray
<
Nullable
<
double
>
>
*
offsets
=
nullptr
;
AutoTArray
<
Nullable
<
double
>
1
>
singleOffset
;
auto
&
offset
=
keyframeDict
.
mOffset
;
if
(
offset
.
IsDouble
(
)
)
{
singleOffset
.
AppendElement
(
offset
.
GetAsDouble
(
)
)
;
const
FallibleTArray
<
Nullable
<
double
>
>
&
asFallibleArray
=
singleOffset
;
offsets
=
&
asFallibleArray
;
}
else
if
(
offset
.
IsDoubleOrNullSequence
(
)
)
{
offsets
=
&
offset
.
GetAsDoubleOrNullSequence
(
)
;
}
size_t
offsetsToFill
=
offsets
?
std
:
:
min
(
offsets
-
>
Length
(
)
aResult
.
Length
(
)
)
:
0
;
for
(
size_t
i
=
0
;
i
<
offsetsToFill
;
i
+
+
)
{
if
(
!
offsets
-
>
ElementAt
(
i
)
.
IsNull
(
)
)
{
aResult
[
i
]
.
mOffset
.
emplace
(
offsets
-
>
ElementAt
(
i
)
.
Value
(
)
)
;
}
}
if
(
!
HasValidOffsets
(
aResult
)
)
{
aResult
.
Clear
(
)
;
aRv
.
ThrowTypeError
<
dom
:
:
MSG_INVALID_KEYFRAME_OFFSETS
>
(
)
;
return
;
}
FallibleTArray
<
Maybe
<
StyleComputedTimingFunction
>
>
easings
;
auto
parseAndAppendEasing
=
[
&
]
(
const
nsACString
&
easingString
ErrorResult
&
aRv
)
{
auto
easing
=
TimingParams
:
:
ParseEasing
(
easingString
aRv
)
;
if
(
!
aRv
.
Failed
(
)
&
&
!
easings
.
AppendElement
(
std
:
:
move
(
easing
)
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
}
;
auto
&
easing
=
keyframeDict
.
mEasing
;
if
(
easing
.
IsUTF8String
(
)
)
{
parseAndAppendEasing
(
easing
.
GetAsUTF8String
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
aResult
.
Clear
(
)
;
return
;
}
}
else
{
for
(
const
auto
&
easingString
:
easing
.
GetAsUTF8StringSequence
(
)
)
{
parseAndAppendEasing
(
easingString
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
aResult
.
Clear
(
)
;
return
;
}
}
}
if
(
!
easings
.
IsEmpty
(
)
)
{
for
(
size_t
i
=
0
;
i
<
aResult
.
Length
(
)
;
i
+
+
)
{
aResult
[
i
]
.
mTimingFunction
=
easings
[
i
%
easings
.
Length
(
)
]
;
}
}
const
FallibleTArray
<
dom
:
:
CompositeOperationOrAuto
>
*
compositeOps
=
nullptr
;
AutoTArray
<
dom
:
:
CompositeOperationOrAuto
1
>
singleCompositeOp
;
auto
&
composite
=
keyframeDict
.
mComposite
;
if
(
composite
.
IsCompositeOperationOrAuto
(
)
)
{
singleCompositeOp
.
AppendElement
(
composite
.
GetAsCompositeOperationOrAuto
(
)
)
;
const
FallibleTArray
<
dom
:
:
CompositeOperationOrAuto
>
&
asFallibleArray
=
singleCompositeOp
;
compositeOps
=
&
asFallibleArray
;
}
else
if
(
composite
.
IsCompositeOperationOrAutoSequence
(
)
)
{
compositeOps
=
&
composite
.
GetAsCompositeOperationOrAutoSequence
(
)
;
}
if
(
compositeOps
&
&
!
compositeOps
-
>
IsEmpty
(
)
)
{
size_t
length
=
compositeOps
-
>
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
aResult
.
Length
(
)
;
i
+
+
)
{
aResult
[
i
]
.
mComposite
=
compositeOps
-
>
ElementAt
(
i
%
length
)
;
}
}
}
static
void
DistributeRange
(
const
Range
<
Keyframe
>
&
aRange
)
{
const
Range
<
Keyframe
>
rangeToAdjust
=
Range
<
Keyframe
>
(
aRange
.
begin
(
)
+
1
aRange
.
end
(
)
-
1
)
;
const
size_t
n
=
aRange
.
length
(
)
-
1
;
const
double
startOffset
=
aRange
[
0
]
.
mComputedOffset
;
const
double
diffOffset
=
aRange
[
n
]
.
mComputedOffset
-
startOffset
;
for
(
auto
iter
=
rangeToAdjust
.
begin
(
)
;
iter
!
=
rangeToAdjust
.
end
(
)
;
+
+
iter
)
{
size_t
index
=
iter
-
aRange
.
begin
(
)
;
iter
-
>
mComputedOffset
=
startOffset
+
double
(
index
)
/
n
*
diffOffset
;
}
}
}
