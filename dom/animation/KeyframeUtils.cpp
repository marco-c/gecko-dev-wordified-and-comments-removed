#
include
"
mozilla
/
KeyframeUtils
.
h
"
#
include
"
mozilla
/
AnimationUtils
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
RangedArray
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
TimingParams
.
h
"
#
include
"
mozilla
/
dom
/
BaseKeyframeTypesBinding
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectBinding
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectReadOnly
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsCSSParser
.
h
"
#
include
"
nsCSSPropertyIDSet
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsTArray
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
const
double
kNotPaceable
=
-
1
.
0
;
enum
class
ListAllowance
{
eDisallow
eAllow
}
;
class
PropertyPriorityComparator
{
public
:
PropertyPriorityComparator
(
)
:
mSubpropertyCountInitialized
(
false
)
{
}
bool
Equals
(
nsCSSPropertyID
aLhs
nsCSSPropertyID
aRhs
)
const
{
return
aLhs
=
=
aRhs
;
}
bool
LessThan
(
nsCSSPropertyID
aLhs
nsCSSPropertyID
aRhs
)
const
{
bool
isShorthandLhs
=
nsCSSProps
:
:
IsShorthand
(
aLhs
)
;
bool
isShorthandRhs
=
nsCSSProps
:
:
IsShorthand
(
aRhs
)
;
if
(
isShorthandLhs
)
{
if
(
isShorthandRhs
)
{
uint32_t
subpropCountLhs
=
SubpropertyCount
(
aLhs
)
;
uint32_t
subpropCountRhs
=
SubpropertyCount
(
aRhs
)
;
if
(
subpropCountLhs
!
=
subpropCountRhs
)
{
return
subpropCountLhs
<
subpropCountRhs
;
}
}
else
{
return
false
;
}
}
else
{
if
(
isShorthandRhs
)
{
return
true
;
}
}
return
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aLhs
)
<
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aRhs
)
;
}
uint32_t
SubpropertyCount
(
nsCSSPropertyID
aProperty
)
const
{
if
(
!
mSubpropertyCountInitialized
)
{
PodZero
(
&
mSubpropertyCount
)
;
mSubpropertyCountInitialized
=
true
;
}
if
(
mSubpropertyCount
[
aProperty
]
=
=
0
)
{
uint32_t
count
=
0
;
CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES
(
p
aProperty
CSSEnabledState
:
:
eForAllContent
)
{
+
+
count
;
}
mSubpropertyCount
[
aProperty
]
=
count
;
}
return
mSubpropertyCount
[
aProperty
]
;
}
private
:
mutable
RangedArray
<
uint32_t
eCSSProperty_COUNT_no_shorthands
eCSSProperty_COUNT
-
eCSSProperty_COUNT_no_shorthands
>
mSubpropertyCount
;
mutable
bool
mSubpropertyCountInitialized
;
}
;
template
<
typename
T
>
class
TPropertyPriorityComparator
:
PropertyPriorityComparator
{
public
:
bool
Equals
(
const
T
&
aLhs
const
T
&
aRhs
)
const
{
return
PropertyPriorityComparator
:
:
Equals
(
aLhs
.
mProperty
aRhs
.
mProperty
)
;
}
bool
LessThan
(
const
T
&
aLhs
const
T
&
aRhs
)
const
{
return
PropertyPriorityComparator
:
:
LessThan
(
aLhs
.
mProperty
aRhs
.
mProperty
)
;
}
}
;
class
PropertyPriorityIterator
{
public
:
explicit
PropertyPriorityIterator
(
const
nsTArray
<
PropertyValuePair
>
&
aProperties
)
:
mProperties
(
aProperties
)
{
mSortedPropertyIndices
.
SetCapacity
(
mProperties
.
Length
(
)
)
;
for
(
size_t
i
=
0
len
=
mProperties
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
PropertyAndIndex
propertyIndex
=
{
mProperties
[
i
]
.
mProperty
i
}
;
mSortedPropertyIndices
.
AppendElement
(
propertyIndex
)
;
}
mSortedPropertyIndices
.
Sort
(
PropertyAndIndex
:
:
Comparator
(
)
)
;
}
class
Iter
{
public
:
explicit
Iter
(
const
PropertyPriorityIterator
&
aParent
)
:
mParent
(
aParent
)
mIndex
(
0
)
{
}
static
Iter
EndIter
(
const
PropertyPriorityIterator
&
aParent
)
{
Iter
iter
(
aParent
)
;
iter
.
mIndex
=
aParent
.
mSortedPropertyIndices
.
Length
(
)
;
return
iter
;
}
bool
operator
!
=
(
const
Iter
&
aOther
)
const
{
return
mIndex
!
=
aOther
.
mIndex
;
}
Iter
&
operator
+
+
(
)
{
MOZ_ASSERT
(
mIndex
+
1
<
=
mParent
.
mSortedPropertyIndices
.
Length
(
)
"
Should
not
seek
past
end
iterator
"
)
;
mIndex
+
+
;
return
*
this
;
}
const
PropertyValuePair
&
operator
*
(
)
{
MOZ_ASSERT
(
mIndex
<
mParent
.
mSortedPropertyIndices
.
Length
(
)
"
Should
not
try
to
dereference
an
end
iterator
"
)
;
return
mParent
.
mProperties
[
mParent
.
mSortedPropertyIndices
[
mIndex
]
.
mIndex
]
;
}
private
:
const
PropertyPriorityIterator
&
mParent
;
size_t
mIndex
;
}
;
Iter
begin
(
)
{
return
Iter
(
*
this
)
;
}
Iter
end
(
)
{
return
Iter
:
:
EndIter
(
*
this
)
;
}
private
:
struct
PropertyAndIndex
{
nsCSSPropertyID
mProperty
;
size_t
mIndex
;
typedef
TPropertyPriorityComparator
<
PropertyAndIndex
>
Comparator
;
}
;
const
nsTArray
<
PropertyValuePair
>
&
mProperties
;
nsTArray
<
PropertyAndIndex
>
mSortedPropertyIndices
;
}
;
struct
PropertyValuesPair
{
nsCSSPropertyID
mProperty
;
nsTArray
<
nsString
>
mValues
;
typedef
TPropertyPriorityComparator
<
PropertyValuesPair
>
Comparator
;
}
;
struct
AdditionalProperty
{
nsCSSPropertyID
mProperty
;
size_t
mJsidIndex
;
struct
PropertyComparator
{
bool
Equals
(
const
AdditionalProperty
&
aLhs
const
AdditionalProperty
&
aRhs
)
const
{
return
aLhs
.
mProperty
=
=
aRhs
.
mProperty
;
}
bool
LessThan
(
const
AdditionalProperty
&
aLhs
const
AdditionalProperty
&
aRhs
)
const
{
return
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aLhs
.
mProperty
)
<
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aRhs
.
mProperty
)
;
}
}
;
}
;
struct
KeyframeValueEntry
{
nsCSSPropertyID
mProperty
;
StyleAnimationValue
mValue
;
float
mOffset
;
Maybe
<
ComputedTimingFunction
>
mTimingFunction
;
dom
:
:
CompositeOperation
mComposite
;
struct
PropertyOffsetComparator
{
static
bool
Equals
(
const
KeyframeValueEntry
&
aLhs
const
KeyframeValueEntry
&
aRhs
)
{
return
aLhs
.
mProperty
=
=
aRhs
.
mProperty
&
&
aLhs
.
mOffset
=
=
aRhs
.
mOffset
;
}
static
bool
LessThan
(
const
KeyframeValueEntry
&
aLhs
const
KeyframeValueEntry
&
aRhs
)
{
int32_t
order
=
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aLhs
.
mProperty
)
-
nsCSSProps
:
:
PropertyIDLNameSortPosition
(
aRhs
.
mProperty
)
;
if
(
order
!
=
0
)
{
return
order
<
0
;
}
return
aLhs
.
mOffset
<
aRhs
.
mOffset
;
}
}
;
}
;
class
ComputedOffsetComparator
{
public
:
static
bool
Equals
(
const
Keyframe
&
aLhs
const
Keyframe
&
aRhs
)
{
return
aLhs
.
mComputedOffset
=
=
aRhs
.
mComputedOffset
;
}
static
bool
LessThan
(
const
Keyframe
&
aLhs
const
Keyframe
&
aRhs
)
{
return
aLhs
.
mComputedOffset
<
aRhs
.
mComputedOffset
;
}
}
;
inline
bool
IsInvalidValuePair
(
const
PropertyValuePair
&
aPair
StyleBackendType
aBackend
)
{
if
(
aBackend
=
=
StyleBackendType
:
:
Servo
)
{
return
!
aPair
.
mServoDeclarationBlock
;
}
return
!
nsCSSProps
:
:
IsShorthand
(
aPair
.
mProperty
)
&
&
aPair
.
mValue
.
GetUnit
(
)
=
=
eCSSUnit_TokenStream
&
&
aPair
.
mValue
.
GetTokenStreamValue
(
)
-
>
mPropertyID
=
=
eCSSProperty_UNKNOWN
;
}
static
void
GetKeyframeListFromKeyframeSequence
(
JSContext
*
aCx
nsIDocument
*
aDocument
JS
:
:
ForOfIterator
&
aIterator
nsTArray
<
Keyframe
>
&
aResult
ErrorResult
&
aRv
)
;
static
bool
ConvertKeyframeSequence
(
JSContext
*
aCx
nsIDocument
*
aDocument
JS
:
:
ForOfIterator
&
aIterator
nsTArray
<
Keyframe
>
&
aResult
)
;
static
bool
GetPropertyValuesPairs
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
ListAllowance
aAllowLists
nsTArray
<
PropertyValuesPair
>
&
aResult
)
;
static
bool
AppendStringOrStringSequenceToArray
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ListAllowance
aAllowLists
nsTArray
<
nsString
>
&
aValues
)
;
static
bool
AppendValueAsString
(
JSContext
*
aCx
nsTArray
<
nsString
>
&
aValues
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
;
static
PropertyValuePair
MakePropertyValuePair
(
nsCSSPropertyID
aProperty
const
nsAString
&
aStringValue
nsCSSParser
&
aParser
nsIDocument
*
aDocument
)
;
static
bool
HasValidOffsets
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
)
;
static
void
MarkAsComputeValuesFailureKey
(
PropertyValuePair
&
aPair
)
;
static
bool
IsComputeValuesFailureKey
(
const
PropertyValuePair
&
aPair
)
;
static
void
BuildSegmentsFromValueEntries
(
nsTArray
<
KeyframeValueEntry
>
&
aEntries
nsTArray
<
AnimationProperty
>
&
aResult
)
;
static
void
GetKeyframeListFromPropertyIndexedKeyframe
(
JSContext
*
aCx
nsIDocument
*
aDocument
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
nsTArray
<
Keyframe
>
&
aResult
ErrorResult
&
aRv
)
;
static
bool
RequiresAdditiveAnimation
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
nsIDocument
*
aDocument
)
;
static
void
DistributeRange
(
const
Range
<
Keyframe
>
&
aSpacingRange
const
Range
<
Keyframe
>
&
aRangeToAdjust
)
;
static
void
DistributeRange
(
const
Range
<
Keyframe
>
&
aSpacingRange
)
;
static
void
PaceRange
(
const
Range
<
Keyframe
>
&
aKeyframes
const
Range
<
double
>
&
aCumulativeDistances
)
;
static
nsTArray
<
double
>
GetCumulativeDistances
(
const
nsTArray
<
ComputedKeyframeValues
>
&
aValues
nsCSSPropertyID
aProperty
nsStyleContext
*
aStyleContext
)
;
nsTArray
<
Keyframe
>
KeyframeUtils
:
:
GetKeyframesFromObject
(
JSContext
*
aCx
nsIDocument
*
aDocument
JS
:
:
Handle
<
JSObject
*
>
aFrames
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
nsTArray
<
Keyframe
>
keyframes
;
if
(
!
aFrames
)
{
return
keyframes
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
objectValue
(
aCx
JS
:
:
ObjectValue
(
*
aFrames
)
)
;
JS
:
:
ForOfIterator
iter
(
aCx
)
;
if
(
!
iter
.
init
(
objectValue
JS
:
:
ForOfIterator
:
:
AllowNonIterable
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
keyframes
;
}
if
(
iter
.
valueIsIterable
(
)
)
{
GetKeyframeListFromKeyframeSequence
(
aCx
aDocument
iter
keyframes
aRv
)
;
}
else
{
GetKeyframeListFromPropertyIndexedKeyframe
(
aCx
aDocument
objectValue
keyframes
aRv
)
;
}
if
(
aRv
.
Failed
(
)
)
{
MOZ_ASSERT
(
keyframes
.
IsEmpty
(
)
"
Should
not
set
any
keyframes
when
there
is
an
error
"
)
;
return
keyframes
;
}
if
(
(
!
AnimationUtils
:
:
IsCoreAPIEnabled
(
)
|
|
aDocument
-
>
IsStyledByServo
(
)
)
&
&
RequiresAdditiveAnimation
(
keyframes
aDocument
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR
)
;
keyframes
.
Clear
(
)
;
}
return
keyframes
;
}
void
KeyframeUtils
:
:
ApplySpacing
(
nsTArray
<
Keyframe
>
&
aKeyframes
SpacingMode
aSpacingMode
nsCSSPropertyID
aProperty
nsTArray
<
ComputedKeyframeValues
>
&
aComputedValues
nsStyleContext
*
aStyleContext
)
{
if
(
aKeyframes
.
IsEmpty
(
)
)
{
return
;
}
nsTArray
<
double
>
cumulativeDistances
;
if
(
aSpacingMode
=
=
SpacingMode
:
:
paced
)
{
MOZ_ASSERT
(
IsAnimatableProperty
(
aProperty
)
"
Paced
property
should
be
animatable
"
)
;
cumulativeDistances
=
GetCumulativeDistances
(
aComputedValues
aProperty
aStyleContext
)
;
for
(
Keyframe
&
keyframe
:
aKeyframes
)
{
keyframe
.
mComputedOffset
=
Keyframe
:
:
kComputedOffsetNotSet
;
}
}
if
(
aKeyframes
.
Length
(
)
>
1
)
{
Keyframe
&
firstElement
=
aKeyframes
[
0
]
;
firstElement
.
mComputedOffset
=
firstElement
.
mOffset
.
valueOr
(
0
.
0
)
;
}
else
{
Keyframe
&
lastElement
=
aKeyframes
.
LastElement
(
)
;
lastElement
.
mComputedOffset
=
lastElement
.
mOffset
.
valueOr
(
1
.
0
)
;
}
const
Keyframe
*
const
last
=
aKeyframes
.
cend
(
)
-
1
;
const
RangedPtr
<
Keyframe
>
begin
(
aKeyframes
.
begin
(
)
aKeyframes
.
Length
(
)
)
;
RangedPtr
<
Keyframe
>
keyframeA
=
begin
;
while
(
keyframeA
!
=
last
)
{
RangedPtr
<
Keyframe
>
keyframeB
=
keyframeA
+
1
;
while
(
keyframeB
-
>
mOffset
.
isNothing
(
)
&
&
keyframeB
!
=
last
)
{
+
+
keyframeB
;
}
keyframeB
-
>
mComputedOffset
=
keyframeB
-
>
mOffset
.
valueOr
(
1
.
0
)
;
if
(
aSpacingMode
=
=
SpacingMode
:
:
distribute
)
{
DistributeRange
(
Range
<
Keyframe
>
(
keyframeA
keyframeB
+
1
)
)
;
}
else
{
RangedPtr
<
Keyframe
>
pacedA
=
keyframeA
;
while
(
pacedA
<
keyframeB
&
&
cumulativeDistances
[
pacedA
-
begin
]
=
=
kNotPaceable
)
{
+
+
pacedA
;
}
RangedPtr
<
Keyframe
>
pacedB
=
keyframeB
;
while
(
pacedB
>
keyframeA
&
&
cumulativeDistances
[
pacedB
-
begin
]
=
=
kNotPaceable
)
{
-
-
pacedB
;
}
if
(
pacedA
>
pacedB
)
{
pacedA
=
pacedB
=
keyframeB
;
}
DistributeRange
(
Range
<
Keyframe
>
(
keyframeA
keyframeB
+
1
)
Range
<
Keyframe
>
(
keyframeA
+
1
pacedA
+
1
)
)
;
DistributeRange
(
Range
<
Keyframe
>
(
keyframeA
keyframeB
+
1
)
Range
<
Keyframe
>
(
pacedB
keyframeB
)
)
;
PaceRange
(
Range
<
Keyframe
>
(
pacedA
pacedB
+
1
)
Range
<
double
>
(
&
cumulativeDistances
[
pacedA
-
begin
]
pacedB
-
pacedA
+
1
)
)
;
for
(
RangedPtr
<
Keyframe
>
frame
=
pacedA
+
1
;
frame
<
pacedB
;
+
+
frame
)
{
if
(
frame
-
>
mComputedOffset
!
=
Keyframe
:
:
kComputedOffsetNotSet
)
{
continue
;
}
RangedPtr
<
Keyframe
>
start
=
frame
-
1
;
RangedPtr
<
Keyframe
>
end
=
frame
+
1
;
while
(
end
<
pacedB
&
&
end
-
>
mComputedOffset
=
=
Keyframe
:
:
kComputedOffsetNotSet
)
{
+
+
end
;
}
DistributeRange
(
Range
<
Keyframe
>
(
start
end
+
1
)
)
;
frame
=
end
;
}
}
keyframeA
=
keyframeB
;
}
}
void
KeyframeUtils
:
:
ApplyDistributeSpacing
(
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
nsTArray
<
ComputedKeyframeValues
>
emptyArray
;
ApplySpacing
(
aKeyframes
SpacingMode
:
:
distribute
eCSSProperty_UNKNOWN
emptyArray
nullptr
)
;
}
nsTArray
<
ComputedKeyframeValues
>
KeyframeUtils
:
:
GetComputedKeyframeValues
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
dom
:
:
Element
*
aElement
nsStyleContext
*
aStyleContext
)
{
MOZ_ASSERT
(
aStyleContext
)
;
MOZ_ASSERT
(
aElement
)
;
StyleBackendType
styleBackend
=
aElement
-
>
OwnerDoc
(
)
-
>
GetStyleBackendType
(
)
;
const
size_t
len
=
aKeyframes
.
Length
(
)
;
nsTArray
<
ComputedKeyframeValues
>
result
(
len
)
;
for
(
const
Keyframe
&
frame
:
aKeyframes
)
{
nsCSSPropertyIDSet
propertiesOnThisKeyframe
;
ComputedKeyframeValues
*
computedValues
=
result
.
AppendElement
(
)
;
for
(
const
PropertyValuePair
&
pair
:
PropertyPriorityIterator
(
frame
.
mPropertyValues
)
)
{
MOZ_ASSERT
(
!
pair
.
mServoDeclarationBlock
|
|
styleBackend
=
=
StyleBackendType
:
:
Servo
"
Animation
values
were
parsed
using
Servo
backend
but
target
"
"
element
is
not
using
Servo
backend
?
"
)
;
if
(
IsInvalidValuePair
(
pair
styleBackend
)
)
{
continue
;
}
nsTArray
<
PropertyStyleAnimationValuePair
>
values
;
if
(
styleBackend
=
=
StyleBackendType
:
:
Servo
)
{
if
(
!
StyleAnimationValue
:
:
ComputeValues
(
pair
.
mProperty
CSSEnabledState
:
:
eForAllContent
aStyleContext
*
pair
.
mServoDeclarationBlock
values
)
)
{
continue
;
}
}
else
{
if
(
nsCSSProps
:
:
IsShorthand
(
pair
.
mProperty
)
)
{
nsCSSValueTokenStream
*
tokenStream
=
pair
.
mValue
.
GetTokenStreamValue
(
)
;
if
(
!
StyleAnimationValue
:
:
ComputeValues
(
pair
.
mProperty
CSSEnabledState
:
:
eForAllContent
aElement
aStyleContext
tokenStream
-
>
mTokenStream
false
values
)
|
|
IsComputeValuesFailureKey
(
pair
)
)
{
continue
;
}
}
else
{
if
(
!
StyleAnimationValue
:
:
ComputeValues
(
pair
.
mProperty
CSSEnabledState
:
:
eForAllContent
aElement
aStyleContext
pair
.
mValue
false
values
)
)
{
continue
;
}
MOZ_ASSERT
(
values
.
Length
(
)
=
=
1
"
Longhand
properties
should
produce
a
single
"
"
StyleAnimationValue
"
)
;
}
}
for
(
auto
&
value
:
values
)
{
if
(
propertiesOnThisKeyframe
.
HasProperty
(
value
.
mProperty
)
)
{
continue
;
}
computedValues
-
>
AppendElement
(
value
)
;
propertiesOnThisKeyframe
.
AddProperty
(
value
.
mProperty
)
;
}
}
}
MOZ_ASSERT
(
result
.
Length
(
)
=
=
aKeyframes
.
Length
(
)
"
Array
length
mismatch
"
)
;
return
result
;
}
nsTArray
<
AnimationProperty
>
KeyframeUtils
:
:
GetAnimationPropertiesFromKeyframes
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
const
nsTArray
<
ComputedKeyframeValues
>
&
aComputedValues
dom
:
:
CompositeOperation
aEffectComposite
nsStyleContext
*
aStyleContext
)
{
MOZ_ASSERT
(
aKeyframes
.
Length
(
)
=
=
aComputedValues
.
Length
(
)
"
Array
length
mismatch
"
)
;
nsTArray
<
KeyframeValueEntry
>
entries
(
aKeyframes
.
Length
(
)
)
;
const
size_t
len
=
aKeyframes
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
len
;
+
+
i
)
{
const
Keyframe
&
frame
=
aKeyframes
[
i
]
;
for
(
auto
&
value
:
aComputedValues
[
i
]
)
{
MOZ_ASSERT
(
frame
.
mComputedOffset
!
=
Keyframe
:
:
kComputedOffsetNotSet
"
Invalid
computed
offset
"
)
;
KeyframeValueEntry
*
entry
=
entries
.
AppendElement
(
)
;
entry
-
>
mOffset
=
frame
.
mComputedOffset
;
entry
-
>
mProperty
=
value
.
mProperty
;
entry
-
>
mValue
=
value
.
mValue
;
entry
-
>
mTimingFunction
=
frame
.
mTimingFunction
;
entry
-
>
mComposite
=
frame
.
mComposite
?
frame
.
mComposite
.
value
(
)
:
aEffectComposite
;
}
}
nsTArray
<
AnimationProperty
>
result
;
BuildSegmentsFromValueEntries
(
entries
result
)
;
return
result
;
}
bool
KeyframeUtils
:
:
IsAnimatableProperty
(
nsCSSPropertyID
aProperty
)
{
if
(
aProperty
=
=
eCSSProperty_UNKNOWN
)
{
return
false
;
}
if
(
!
nsCSSProps
:
:
IsShorthand
(
aProperty
)
)
{
return
nsCSSProps
:
:
kAnimTypeTable
[
aProperty
]
!
=
eStyleAnimType_None
;
}
CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES
(
subprop
aProperty
CSSEnabledState
:
:
eForAllContent
)
{
if
(
nsCSSProps
:
:
kAnimTypeTable
[
*
subprop
]
!
=
eStyleAnimType_None
)
{
return
true
;
}
}
return
false
;
}
static
void
GetKeyframeListFromKeyframeSequence
(
JSContext
*
aCx
nsIDocument
*
aDocument
JS
:
:
ForOfIterator
&
aIterator
nsTArray
<
Keyframe
>
&
aResult
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
)
;
if
(
!
ConvertKeyframeSequence
(
aCx
aDocument
aIterator
aResult
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
aResult
.
Clear
(
)
;
return
;
}
if
(
aResult
.
IsEmpty
(
)
)
{
return
;
}
if
(
!
HasValidOffsets
(
aResult
)
)
{
aRv
.
ThrowTypeError
<
dom
:
:
MSG_INVALID_KEYFRAME_OFFSETS
>
(
)
;
aResult
.
Clear
(
)
;
return
;
}
}
static
bool
ConvertKeyframeSequence
(
JSContext
*
aCx
nsIDocument
*
aDocument
JS
:
:
ForOfIterator
&
aIterator
nsTArray
<
Keyframe
>
&
aResult
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
nsCSSParser
parser
(
aDocument
-
>
CSSLoader
(
)
)
;
for
(
;
;
)
{
bool
done
;
if
(
!
aIterator
.
next
(
&
value
&
done
)
)
{
return
false
;
}
if
(
done
)
{
break
;
}
if
(
!
value
.
isObject
(
)
&
&
!
value
.
isNullOrUndefined
(
)
)
{
dom
:
:
ThrowErrorMessage
(
aCx
dom
:
:
MSG_NOT_OBJECT
"
Element
of
sequence
<
Keyframe
>
argument
"
)
;
return
false
;
}
dom
:
:
binding_detail
:
:
FastBaseKeyframe
keyframeDict
;
if
(
!
keyframeDict
.
Init
(
aCx
value
"
Element
of
sequence
<
Keyframe
>
argument
"
)
)
{
return
false
;
}
Keyframe
*
keyframe
=
aResult
.
AppendElement
(
fallible
)
;
if
(
!
keyframe
)
{
return
false
;
}
if
(
!
keyframeDict
.
mOffset
.
IsNull
(
)
)
{
keyframe
-
>
mOffset
.
emplace
(
keyframeDict
.
mOffset
.
Value
(
)
)
;
}
if
(
keyframeDict
.
mComposite
.
WasPassed
(
)
)
{
if
(
keyframeDict
.
mComposite
.
Value
(
)
!
=
dom
:
:
CompositeOperation
:
:
Add
)
{
keyframe
-
>
mComposite
.
emplace
(
keyframeDict
.
mComposite
.
Value
(
)
)
;
}
}
ErrorResult
rv
;
keyframe
-
>
mTimingFunction
=
TimingParams
:
:
ParseEasing
(
keyframeDict
.
mEasing
aDocument
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
aCx
)
)
{
return
false
;
}
nsTArray
<
PropertyValuesPair
>
propertyValuePairs
;
if
(
value
.
isObject
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
object
(
aCx
&
value
.
toObject
(
)
)
;
if
(
!
GetPropertyValuesPairs
(
aCx
object
ListAllowance
:
:
eDisallow
propertyValuePairs
)
)
{
return
false
;
}
}
for
(
PropertyValuesPair
&
pair
:
propertyValuePairs
)
{
MOZ_ASSERT
(
pair
.
mValues
.
Length
(
)
=
=
1
)
;
keyframe
-
>
mPropertyValues
.
AppendElement
(
MakePropertyValuePair
(
pair
.
mProperty
pair
.
mValues
[
0
]
parser
aDocument
)
)
;
if
(
nsCSSProps
:
:
IsShorthand
(
pair
.
mProperty
)
&
&
keyframeDict
.
mSimulateComputeValuesFailure
)
{
MarkAsComputeValuesFailureKey
(
keyframe
-
>
mPropertyValues
.
LastElement
(
)
)
;
}
}
}
return
true
;
}
static
bool
GetPropertyValuesPairs
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
ListAllowance
aAllowLists
nsTArray
<
PropertyValuesPair
>
&
aResult
)
{
nsTArray
<
AdditionalProperty
>
properties
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
ids
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
aObject
&
ids
)
)
{
return
false
;
}
for
(
size_t
i
=
0
n
=
ids
.
length
(
)
;
i
<
n
;
i
+
+
)
{
nsAutoJSString
propName
;
if
(
!
propName
.
init
(
aCx
ids
[
i
]
)
)
{
return
false
;
}
nsCSSPropertyID
property
=
nsCSSProps
:
:
LookupPropertyByIDLName
(
propName
CSSEnabledState
:
:
eForAllContent
)
;
if
(
KeyframeUtils
:
:
IsAnimatableProperty
(
property
)
)
{
AdditionalProperty
*
p
=
properties
.
AppendElement
(
)
;
p
-
>
mProperty
=
property
;
p
-
>
mJsidIndex
=
i
;
}
}
properties
.
Sort
(
AdditionalProperty
:
:
PropertyComparator
(
)
)
;
for
(
AdditionalProperty
&
p
:
properties
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
JS_GetPropertyById
(
aCx
aObject
ids
[
p
.
mJsidIndex
]
&
value
)
)
{
return
false
;
}
PropertyValuesPair
*
pair
=
aResult
.
AppendElement
(
)
;
pair
-
>
mProperty
=
p
.
mProperty
;
if
(
!
AppendStringOrStringSequenceToArray
(
aCx
value
aAllowLists
pair
-
>
mValues
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
AppendStringOrStringSequenceToArray
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ListAllowance
aAllowLists
nsTArray
<
nsString
>
&
aValues
)
{
if
(
aAllowLists
=
=
ListAllowance
:
:
eAllow
&
&
aValue
.
isObject
(
)
)
{
JS
:
:
ForOfIterator
iter
(
aCx
)
;
if
(
!
iter
.
init
(
aValue
JS
:
:
ForOfIterator
:
:
AllowNonIterable
)
)
{
return
false
;
}
if
(
iter
.
valueIsIterable
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
element
(
aCx
)
;
for
(
;
;
)
{
bool
done
;
if
(
!
iter
.
next
(
&
element
&
done
)
)
{
return
false
;
}
if
(
done
)
{
break
;
}
if
(
!
AppendValueAsString
(
aCx
aValues
element
)
)
{
return
false
;
}
}
return
true
;
}
}
if
(
!
AppendValueAsString
(
aCx
aValues
aValue
)
)
{
return
false
;
}
return
true
;
}
static
bool
AppendValueAsString
(
JSContext
*
aCx
nsTArray
<
nsString
>
&
aValues
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
return
ConvertJSValueToString
(
aCx
aValue
dom
:
:
eStringify
dom
:
:
eStringify
*
aValues
.
AppendElement
(
)
)
;
}
static
PropertyValuePair
MakePropertyValuePair
(
nsCSSPropertyID
aProperty
const
nsAString
&
aStringValue
nsCSSParser
&
aParser
nsIDocument
*
aDocument
)
{
MOZ_ASSERT
(
aDocument
)
;
PropertyValuePair
result
;
result
.
mProperty
=
aProperty
;
if
(
aDocument
-
>
GetStyleBackendType
(
)
=
=
StyleBackendType
:
:
Servo
)
{
nsCString
name
=
nsCSSProps
:
:
GetStringValue
(
aProperty
)
;
NS_ConvertUTF16toUTF8
value
(
aStringValue
)
;
RefPtr
<
ThreadSafeURIHolder
>
base
=
new
ThreadSafeURIHolder
(
aDocument
-
>
GetDocumentURI
(
)
)
;
RefPtr
<
ThreadSafeURIHolder
>
referrer
=
new
ThreadSafeURIHolder
(
aDocument
-
>
GetDocumentURI
(
)
)
;
RefPtr
<
ThreadSafePrincipalHolder
>
principal
=
new
ThreadSafePrincipalHolder
(
aDocument
-
>
NodePrincipal
(
)
)
;
nsCString
baseString
;
aDocument
-
>
GetDocumentURI
(
)
-
>
GetSpec
(
baseString
)
;
RefPtr
<
RawServoDeclarationBlock
>
servoDeclarationBlock
=
Servo_ParseProperty
(
&
name
&
value
&
baseString
base
referrer
principal
)
.
Consume
(
)
;
if
(
servoDeclarationBlock
)
{
result
.
mServoDeclarationBlock
=
servoDeclarationBlock
.
forget
(
)
;
return
result
;
}
}
nsCSSValue
value
;
if
(
!
nsCSSProps
:
:
IsShorthand
(
aProperty
)
)
{
aParser
.
ParseLonghandProperty
(
aProperty
aStringValue
aDocument
-
>
GetDocumentURI
(
)
aDocument
-
>
GetDocumentURI
(
)
aDocument
-
>
NodePrincipal
(
)
value
)
;
}
if
(
value
.
GetUnit
(
)
=
=
eCSSUnit_Null
)
{
nsCSSValueTokenStream
*
tokenStream
=
new
nsCSSValueTokenStream
;
tokenStream
-
>
mTokenStream
=
aStringValue
;
MOZ_ASSERT
(
tokenStream
-
>
mPropertyID
=
=
eCSSProperty_UNKNOWN
"
The
property
of
a
token
stream
should
be
initialized
"
"
to
unknown
"
)
;
MOZ_ASSERT
(
tokenStream
-
>
mShorthandPropertyID
=
=
eCSSProperty_UNKNOWN
"
The
shorthand
property
of
a
token
stream
should
be
initialized
"
"
to
unknown
"
)
;
value
.
SetTokenStreamValue
(
tokenStream
)
;
}
else
{
NS_WARNING_ASSERTION
(
aDocument
-
>
GetStyleBackendType
(
)
!
=
StyleBackendType
:
:
Servo
"
Gecko
succeeded
in
parsing
where
Servo
failed
"
)
;
}
result
.
mValue
=
value
;
return
result
;
}
static
bool
HasValidOffsets
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
)
{
double
offset
=
0
.
0
;
for
(
const
Keyframe
&
keyframe
:
aKeyframes
)
{
if
(
keyframe
.
mOffset
)
{
double
thisOffset
=
keyframe
.
mOffset
.
value
(
)
;
if
(
thisOffset
<
offset
|
|
thisOffset
>
1
.
0f
)
{
return
false
;
}
offset
=
thisOffset
;
}
}
return
true
;
}
static
void
MarkAsComputeValuesFailureKey
(
PropertyValuePair
&
aPair
)
{
MOZ_ASSERT
(
nsCSSProps
:
:
IsShorthand
(
aPair
.
mProperty
)
"
Only
shorthand
property
values
can
be
marked
as
failure
values
"
)
;
nsCSSValueTokenStream
*
tokenStream
=
aPair
.
mValue
.
GetTokenStreamValue
(
)
;
MOZ_ASSERT
(
tokenStream
-
>
mPropertyID
=
=
eCSSProperty_UNKNOWN
"
Shorthand
value
should
initially
have
an
unknown
property
ID
"
)
;
tokenStream
-
>
mPropertyID
=
eCSSPropertyExtra_no_properties
;
}
static
bool
IsComputeValuesFailureKey
(
const
PropertyValuePair
&
aPair
)
{
return
nsCSSProps
:
:
IsShorthand
(
aPair
.
mProperty
)
&
&
aPair
.
mValue
.
GetTokenStreamValue
(
)
-
>
mPropertyID
=
=
eCSSPropertyExtra_no_properties
;
}
static
void
AppendInitialSegment
(
AnimationProperty
*
aAnimationProperty
const
KeyframeValueEntry
&
aFirstEntry
)
{
AnimationPropertySegment
*
segment
=
aAnimationProperty
-
>
mSegments
.
AppendElement
(
)
;
segment
-
>
mFromKey
=
0
.
0f
;
segment
-
>
mFromComposite
=
dom
:
:
CompositeOperation
:
:
Add
;
segment
-
>
mToKey
=
aFirstEntry
.
mOffset
;
segment
-
>
mToValue
=
aFirstEntry
.
mValue
;
segment
-
>
mToComposite
=
aFirstEntry
.
mComposite
;
}
static
void
AppendFinalSegment
(
AnimationProperty
*
aAnimationProperty
const
KeyframeValueEntry
&
aLastEntry
)
{
AnimationPropertySegment
*
segment
=
aAnimationProperty
-
>
mSegments
.
AppendElement
(
)
;
segment
-
>
mFromKey
=
aLastEntry
.
mOffset
;
segment
-
>
mFromValue
=
aLastEntry
.
mValue
;
segment
-
>
mFromComposite
=
aLastEntry
.
mComposite
;
segment
-
>
mToKey
=
1
.
0f
;
segment
-
>
mToComposite
=
dom
:
:
CompositeOperation
:
:
Add
;
segment
-
>
mTimingFunction
=
aLastEntry
.
mTimingFunction
;
}
static
AnimationProperty
*
HandleMissingInitialKeyframe
(
nsTArray
<
AnimationProperty
>
&
aResult
const
KeyframeValueEntry
&
aEntry
)
{
MOZ_ASSERT
(
aEntry
.
mOffset
!
=
0
.
0f
"
The
offset
of
the
entry
should
not
be
0
.
0
"
)
;
if
(
!
AnimationUtils
:
:
IsCoreAPIEnabled
(
)
)
{
return
nullptr
;
}
AnimationProperty
*
result
=
aResult
.
AppendElement
(
)
;
result
-
>
mProperty
=
aEntry
.
mProperty
;
AppendInitialSegment
(
result
aEntry
)
;
return
result
;
}
static
void
HandleMissingFinalKeyframe
(
nsTArray
<
AnimationProperty
>
&
aResult
const
KeyframeValueEntry
&
aEntry
AnimationProperty
*
aCurrentAnimationProperty
)
{
MOZ_ASSERT
(
aEntry
.
mOffset
!
=
1
.
0f
"
The
offset
of
the
entry
should
not
be
1
.
0
"
)
;
if
(
!
AnimationUtils
:
:
IsCoreAPIEnabled
(
)
)
{
if
(
aCurrentAnimationProperty
)
{
aResult
.
RemoveElementAt
(
aResult
.
Length
(
)
-
1
)
;
}
return
;
}
if
(
!
aCurrentAnimationProperty
)
{
aCurrentAnimationProperty
=
aResult
.
AppendElement
(
)
;
aCurrentAnimationProperty
-
>
mProperty
=
aEntry
.
mProperty
;
if
(
aEntry
.
mOffset
!
=
0
.
0f
)
{
AppendInitialSegment
(
aCurrentAnimationProperty
aEntry
)
;
}
}
AppendFinalSegment
(
aCurrentAnimationProperty
aEntry
)
;
}
static
void
BuildSegmentsFromValueEntries
(
nsTArray
<
KeyframeValueEntry
>
&
aEntries
nsTArray
<
AnimationProperty
>
&
aResult
)
{
if
(
aEntries
.
IsEmpty
(
)
)
{
return
;
}
std
:
:
stable_sort
(
aEntries
.
begin
(
)
aEntries
.
end
(
)
&
KeyframeValueEntry
:
:
PropertyOffsetComparator
:
:
LessThan
)
;
nsCSSPropertyID
lastProperty
=
eCSSProperty_UNKNOWN
;
AnimationProperty
*
animationProperty
=
nullptr
;
size_t
i
=
0
n
=
aEntries
.
Length
(
)
;
while
(
i
<
n
)
{
if
(
i
+
1
=
=
n
)
{
if
(
aEntries
[
i
]
.
mOffset
!
=
1
.
0f
)
{
HandleMissingFinalKeyframe
(
aResult
aEntries
[
i
]
animationProperty
)
;
}
else
if
(
aEntries
[
i
]
.
mOffset
=
=
1
.
0f
&
&
!
animationProperty
)
{
Unused
<
<
HandleMissingInitialKeyframe
(
aResult
aEntries
[
i
]
)
;
}
animationProperty
=
nullptr
;
break
;
}
MOZ_ASSERT
(
aEntries
[
i
]
.
mProperty
!
=
eCSSProperty_UNKNOWN
&
&
aEntries
[
i
+
1
]
.
mProperty
!
=
eCSSProperty_UNKNOWN
"
Each
entry
should
specify
a
valid
property
"
)
;
if
(
aEntries
[
i
]
.
mProperty
!
=
lastProperty
&
&
aEntries
[
i
]
.
mOffset
!
=
0
.
0f
)
{
animationProperty
=
HandleMissingInitialKeyframe
(
aResult
aEntries
[
i
]
)
;
if
(
animationProperty
)
{
lastProperty
=
aEntries
[
i
]
.
mProperty
;
}
else
{
+
+
i
;
continue
;
}
}
if
(
aEntries
[
i
]
.
mProperty
!
=
aEntries
[
i
+
1
]
.
mProperty
&
&
aEntries
[
i
]
.
mOffset
!
=
1
.
0f
)
{
HandleMissingFinalKeyframe
(
aResult
aEntries
[
i
]
animationProperty
)
;
animationProperty
=
nullptr
;
+
+
i
;
continue
;
}
size_t
j
;
if
(
aEntries
[
i
]
.
mOffset
=
=
0
.
0f
&
&
aEntries
[
i
+
1
]
.
mOffset
=
=
0
.
0f
)
{
MOZ_ASSERT
(
aEntries
[
i
]
.
mProperty
=
=
aEntries
[
i
+
1
]
.
mProperty
)
;
j
=
i
+
1
;
while
(
aEntries
[
j
+
1
]
.
mOffset
=
=
0
.
0f
&
&
aEntries
[
j
+
1
]
.
mProperty
=
=
aEntries
[
j
]
.
mProperty
)
{
+
+
j
;
}
}
else
if
(
aEntries
[
i
]
.
mOffset
=
=
1
.
0f
)
{
if
(
aEntries
[
i
+
1
]
.
mOffset
=
=
1
.
0f
&
&
aEntries
[
i
+
1
]
.
mProperty
=
=
aEntries
[
i
]
.
mProperty
)
{
j
=
i
+
1
;
while
(
j
+
1
<
n
&
&
aEntries
[
j
+
1
]
.
mOffset
=
=
1
.
0f
&
&
aEntries
[
j
+
1
]
.
mProperty
=
=
aEntries
[
j
]
.
mProperty
)
{
+
+
j
;
}
}
else
{
MOZ_ASSERT
(
aEntries
[
i
]
.
mProperty
!
=
aEntries
[
i
+
1
]
.
mProperty
)
;
animationProperty
=
nullptr
;
+
+
i
;
continue
;
}
}
else
{
while
(
aEntries
[
i
]
.
mOffset
=
=
aEntries
[
i
+
1
]
.
mOffset
&
&
aEntries
[
i
]
.
mProperty
=
=
aEntries
[
i
+
1
]
.
mProperty
)
{
+
+
i
;
}
j
=
i
+
1
;
}
if
(
aEntries
[
i
]
.
mProperty
!
=
lastProperty
)
{
MOZ_ASSERT
(
aEntries
[
i
]
.
mOffset
=
=
0
.
0f
)
;
MOZ_ASSERT
(
!
animationProperty
)
;
animationProperty
=
aResult
.
AppendElement
(
)
;
animationProperty
-
>
mProperty
=
aEntries
[
i
]
.
mProperty
;
lastProperty
=
aEntries
[
i
]
.
mProperty
;
}
MOZ_ASSERT
(
animationProperty
"
animationProperty
should
be
valid
pointer
.
"
)
;
AnimationPropertySegment
*
segment
=
animationProperty
-
>
mSegments
.
AppendElement
(
)
;
segment
-
>
mFromKey
=
aEntries
[
i
]
.
mOffset
;
segment
-
>
mToKey
=
aEntries
[
j
]
.
mOffset
;
segment
-
>
mFromValue
=
aEntries
[
i
]
.
mValue
;
segment
-
>
mToValue
=
aEntries
[
j
]
.
mValue
;
segment
-
>
mTimingFunction
=
aEntries
[
i
]
.
mTimingFunction
;
segment
-
>
mFromComposite
=
aEntries
[
i
]
.
mComposite
;
segment
-
>
mToComposite
=
aEntries
[
j
]
.
mComposite
;
i
=
j
;
}
}
static
void
GetKeyframeListFromPropertyIndexedKeyframe
(
JSContext
*
aCx
nsIDocument
*
aDocument
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
nsTArray
<
Keyframe
>
&
aResult
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aValue
.
isObject
(
)
)
;
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
dom
:
:
binding_detail
:
:
FastBasePropertyIndexedKeyframe
keyframeDict
;
if
(
!
keyframeDict
.
Init
(
aCx
aValue
"
BasePropertyIndexedKeyframe
argument
"
false
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
Maybe
<
dom
:
:
CompositeOperation
>
composite
;
if
(
keyframeDict
.
mComposite
.
WasPassed
(
)
)
{
if
(
keyframeDict
.
mComposite
.
Value
(
)
!
=
dom
:
:
CompositeOperation
:
:
Add
)
{
composite
.
emplace
(
keyframeDict
.
mComposite
.
Value
(
)
)
;
}
}
Maybe
<
ComputedTimingFunction
>
easing
=
TimingParams
:
:
ParseEasing
(
keyframeDict
.
mEasing
aDocument
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
object
(
aCx
&
aValue
.
toObject
(
)
)
;
nsTArray
<
PropertyValuesPair
>
propertyValuesPairs
;
if
(
!
GetPropertyValuesPairs
(
aCx
object
ListAllowance
:
:
eAllow
propertyValuesPairs
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
bool
isServoBackend
=
aDocument
-
>
IsStyledByServo
(
)
;
nsCSSParser
parser
(
aDocument
-
>
CSSLoader
(
)
)
;
nsClassHashtable
<
nsFloatHashKey
Keyframe
>
processedKeyframes
;
for
(
const
PropertyValuesPair
&
pair
:
propertyValuesPairs
)
{
size_t
count
=
pair
.
mValues
.
Length
(
)
;
if
(
count
=
=
0
)
{
continue
;
}
if
(
(
!
AnimationUtils
:
:
IsCoreAPIEnabled
(
)
|
|
isServoBackend
)
&
&
count
=
=
1
)
{
aRv
.
Throw
(
NS_ERROR_DOM_ANIM_MISSING_PROPS_ERR
)
;
return
;
}
size_t
n
=
pair
.
mValues
.
Length
(
)
-
1
;
size_t
i
=
0
;
for
(
const
nsString
&
stringValue
:
pair
.
mValues
)
{
double
offset
=
i
+
+
/
double
(
n
)
;
Keyframe
*
keyframe
=
processedKeyframes
.
LookupOrAdd
(
offset
)
;
if
(
keyframe
-
>
mPropertyValues
.
IsEmpty
(
)
)
{
keyframe
-
>
mTimingFunction
=
easing
;
keyframe
-
>
mComposite
=
composite
;
keyframe
-
>
mComputedOffset
=
offset
;
}
keyframe
-
>
mPropertyValues
.
AppendElement
(
MakePropertyValuePair
(
pair
.
mProperty
stringValue
parser
aDocument
)
)
;
}
}
aResult
.
SetCapacity
(
processedKeyframes
.
Count
(
)
)
;
for
(
auto
iter
=
processedKeyframes
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aResult
.
AppendElement
(
Move
(
*
iter
.
UserData
(
)
)
)
;
}
aResult
.
Sort
(
ComputedOffsetComparator
(
)
)
;
}
static
bool
RequiresAdditiveAnimation
(
const
nsTArray
<
Keyframe
>
&
aKeyframes
nsIDocument
*
aDocument
)
{
nsCSSPropertyIDSet
properties
;
nsCSSPropertyIDSet
propertiesWithFromValue
;
nsCSSPropertyIDSet
propertiesWithToValue
;
auto
addToPropertySets
=
[
&
]
(
nsCSSPropertyID
aProperty
double
aOffset
)
{
properties
.
AddProperty
(
aProperty
)
;
if
(
aOffset
=
=
0
.
0
)
{
propertiesWithFromValue
.
AddProperty
(
aProperty
)
;
}
else
if
(
aOffset
=
=
1
.
0
)
{
propertiesWithToValue
.
AddProperty
(
aProperty
)
;
}
}
;
StyleBackendType
styleBackend
=
aDocument
-
>
GetStyleBackendType
(
)
;
for
(
size_t
i
=
0
len
=
aKeyframes
.
Length
(
)
;
i
<
len
;
i
+
+
)
{
const
Keyframe
&
frame
=
aKeyframes
[
i
]
;
double
computedOffset
=
i
=
=
len
-
1
?
1
.
0
:
i
=
=
0
?
0
.
0
:
0
.
5
;
double
offsetToUse
=
frame
.
mOffset
?
frame
.
mOffset
.
value
(
)
:
computedOffset
;
for
(
const
PropertyValuePair
&
pair
:
frame
.
mPropertyValues
)
{
if
(
IsInvalidValuePair
(
pair
styleBackend
)
)
{
continue
;
}
if
(
nsCSSProps
:
:
IsShorthand
(
pair
.
mProperty
)
)
{
if
(
styleBackend
=
=
StyleBackendType
:
:
Gecko
)
{
nsCSSValueTokenStream
*
tokenStream
=
pair
.
mValue
.
GetTokenStreamValue
(
)
;
nsCSSParser
parser
(
aDocument
-
>
CSSLoader
(
)
)
;
if
(
!
parser
.
IsValueValidForProperty
(
pair
.
mProperty
tokenStream
-
>
mTokenStream
)
)
{
continue
;
}
}
MOZ_ASSERT
(
styleBackend
!
=
StyleBackendType
:
:
Servo
|
|
pair
.
mServoDeclarationBlock
)
;
CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES
(
prop
pair
.
mProperty
CSSEnabledState
:
:
eForAllContent
)
{
addToPropertySets
(
*
prop
offsetToUse
)
;
}
}
else
{
addToPropertySets
(
pair
.
mProperty
offsetToUse
)
;
}
}
}
return
!
propertiesWithFromValue
.
Equals
(
properties
)
|
|
!
propertiesWithToValue
.
Equals
(
properties
)
;
}
static
void
DistributeRange
(
const
Range
<
Keyframe
>
&
aSpacingRange
const
Range
<
Keyframe
>
&
aRangeToAdjust
)
{
MOZ_ASSERT
(
aRangeToAdjust
.
begin
(
)
>
=
aSpacingRange
.
begin
(
)
&
&
aRangeToAdjust
.
end
(
)
<
=
aSpacingRange
.
end
(
)
"
Out
of
range
"
)
;
const
size_t
n
=
aSpacingRange
.
length
(
)
-
1
;
const
double
startOffset
=
aSpacingRange
[
0
]
.
mComputedOffset
;
const
double
diffOffset
=
aSpacingRange
[
n
]
.
mComputedOffset
-
startOffset
;
for
(
auto
iter
=
aRangeToAdjust
.
begin
(
)
;
iter
!
=
aRangeToAdjust
.
end
(
)
;
+
+
iter
)
{
size_t
index
=
iter
-
aSpacingRange
.
begin
(
)
;
iter
-
>
mComputedOffset
=
startOffset
+
double
(
index
)
/
n
*
diffOffset
;
}
}
static
void
DistributeRange
(
const
Range
<
Keyframe
>
&
aSpacingRange
)
{
DistributeRange
(
aSpacingRange
Range
<
Keyframe
>
(
aSpacingRange
.
begin
(
)
+
1
aSpacingRange
.
end
(
)
-
1
)
)
;
}
static
void
PaceRange
(
const
Range
<
Keyframe
>
&
aKeyframes
const
Range
<
double
>
&
aCumulativeDistances
)
{
MOZ_ASSERT
(
aKeyframes
.
length
(
)
=
=
aCumulativeDistances
.
length
(
)
"
Range
length
mismatch
"
)
;
const
size_t
len
=
aKeyframes
.
length
(
)
;
if
(
len
<
3
)
{
return
;
}
const
double
distA
=
*
(
aCumulativeDistances
.
begin
(
)
)
;
const
double
distB
=
*
(
aCumulativeDistances
.
end
(
)
-
1
)
;
MOZ_ASSERT
(
distA
!
=
kNotPaceable
&
&
distB
!
=
kNotPaceable
"
Both
Paced
A
and
Paced
B
should
be
paceable
"
)
;
if
(
distA
=
=
distB
)
{
return
;
}
const
RangedPtr
<
Keyframe
>
pacedA
=
aKeyframes
.
begin
(
)
;
const
RangedPtr
<
Keyframe
>
pacedB
=
aKeyframes
.
end
(
)
-
1
;
MOZ_ASSERT
(
pacedA
-
>
mComputedOffset
!
=
Keyframe
:
:
kComputedOffsetNotSet
&
&
pacedB
-
>
mComputedOffset
!
=
Keyframe
:
:
kComputedOffsetNotSet
"
Both
Paced
A
and
Paced
B
should
have
valid
computed
offsets
"
)
;
const
double
offsetA
=
pacedA
-
>
mComputedOffset
;
const
double
diffOffset
=
pacedB
-
>
mComputedOffset
-
offsetA
;
const
double
initialDist
=
distA
;
const
double
totalDist
=
distB
-
initialDist
;
for
(
auto
iter
=
pacedA
+
1
;
iter
!
=
pacedB
;
+
+
iter
)
{
size_t
k
=
iter
-
aKeyframes
.
begin
(
)
;
if
(
aCumulativeDistances
[
k
]
=
=
kNotPaceable
)
{
continue
;
}
double
dist
=
aCumulativeDistances
[
k
]
-
initialDist
;
iter
-
>
mComputedOffset
=
offsetA
+
diffOffset
*
dist
/
totalDist
;
}
}
static
nsTArray
<
double
>
GetCumulativeDistances
(
const
nsTArray
<
ComputedKeyframeValues
>
&
aValues
nsCSSPropertyID
aPacedProperty
nsStyleContext
*
aStyleContext
)
{
size_t
pacedPropertyCount
=
0
;
nsCSSPropertyIDSet
pacedPropertySet
;
bool
isShorthand
=
nsCSSProps
:
:
IsShorthand
(
aPacedProperty
)
;
if
(
isShorthand
)
{
CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES
(
p
aPacedProperty
CSSEnabledState
:
:
eForAllContent
)
{
pacedPropertySet
.
AddProperty
(
*
p
)
;
+
+
pacedPropertyCount
;
}
}
else
{
pacedPropertySet
.
AddProperty
(
aPacedProperty
)
;
pacedPropertyCount
=
1
;
}
const
size_t
len
=
aValues
.
Length
(
)
;
nsTArray
<
double
>
cumulativeDistances
(
len
)
;
cumulativeDistances
.
SetLength
(
len
)
;
ComputedKeyframeValues
prevPacedValues
;
size_t
preIdx
=
0
;
for
(
size_t
i
=
0
;
i
<
len
;
+
+
i
)
{
ComputedKeyframeValues
pacedValues
;
for
(
const
PropertyStyleAnimationValuePair
&
pair
:
aValues
[
i
]
)
{
if
(
pacedPropertySet
.
HasProperty
(
pair
.
mProperty
)
)
{
pacedValues
.
AppendElement
(
pair
)
;
}
}
if
(
pacedValues
.
Length
(
)
!
=
pacedPropertyCount
)
{
cumulativeDistances
[
i
]
=
kNotPaceable
;
continue
;
}
if
(
isShorthand
)
{
pacedValues
.
Sort
(
TPropertyPriorityComparator
<
PropertyStyleAnimationValuePair
>
(
)
)
;
}
if
(
prevPacedValues
.
IsEmpty
(
)
)
{
cumulativeDistances
[
i
]
=
0
.
0
;
}
else
{
double
dist
=
0
.
0
;
if
(
isShorthand
)
{
for
(
size_t
propIdx
=
0
;
propIdx
<
pacedPropertyCount
;
+
+
propIdx
)
{
nsCSSPropertyID
prop
=
prevPacedValues
[
propIdx
]
.
mProperty
;
MOZ_ASSERT
(
pacedValues
[
propIdx
]
.
mProperty
=
=
prop
"
Property
mismatch
"
)
;
double
componentDistance
=
0
.
0
;
if
(
StyleAnimationValue
:
:
ComputeDistance
(
prop
prevPacedValues
[
propIdx
]
.
mValue
pacedValues
[
propIdx
]
.
mValue
aStyleContext
componentDistance
)
)
{
dist
+
=
componentDistance
*
componentDistance
;
}
}
dist
=
sqrt
(
dist
)
;
}
else
{
Unused
<
<
StyleAnimationValue
:
:
ComputeDistance
(
aPacedProperty
prevPacedValues
[
0
]
.
mValue
pacedValues
[
0
]
.
mValue
aStyleContext
dist
)
;
}
cumulativeDistances
[
i
]
=
cumulativeDistances
[
preIdx
]
+
dist
;
}
prevPacedValues
.
SwapElements
(
pacedValues
)
;
preIdx
=
i
;
}
return
cumulativeDistances
;
}
}
