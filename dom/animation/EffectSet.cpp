#
include
"
EffectSet
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCycleCollectionNoteChild
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsLayoutUtils
.
h
"
namespace
mozilla
{
void
EffectSet
:
:
PropertyDtor
(
void
*
aObject
nsAtom
*
aPropertyName
void
*
aPropertyValue
void
*
aData
)
{
EffectSet
*
effectSet
=
static_cast
<
EffectSet
*
>
(
aPropertyValue
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
!
effectSet
-
>
mCalledPropertyDtor
"
Should
not
call
dtor
twice
"
)
;
effectSet
-
>
mCalledPropertyDtor
=
true
;
#
endif
delete
effectSet
;
}
void
EffectSet
:
:
Traverse
(
nsCycleCollectionTraversalCallback
&
aCallback
)
{
for
(
auto
iter
=
mEffects
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
CycleCollectionNoteChild
(
aCallback
iter
.
Get
(
)
-
>
GetKey
(
)
"
EffectSet
:
:
mEffects
[
]
"
aCallback
.
Flags
(
)
)
;
}
}
EffectSet
*
EffectSet
:
:
GetEffectSet
(
const
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
)
{
if
(
!
aElement
-
>
MayHaveAnimations
(
)
)
{
return
nullptr
;
}
nsAtom
*
propName
=
GetEffectSetPropertyAtom
(
aPseudoType
)
;
return
static_cast
<
EffectSet
*
>
(
aElement
-
>
GetProperty
(
propName
)
)
;
}
EffectSet
*
EffectSet
:
:
GetEffectSet
(
const
nsIFrame
*
aFrame
)
{
Maybe
<
NonOwningAnimationTarget
>
target
=
EffectCompositor
:
:
GetAnimationElementAndPseudoForFrame
(
aFrame
)
;
if
(
!
target
)
{
return
nullptr
;
}
return
GetEffectSet
(
target
-
>
mElement
target
-
>
mPseudoType
)
;
}
EffectSet
*
EffectSet
:
:
GetOrCreateEffectSet
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
)
{
EffectSet
*
effectSet
=
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
effectSet
)
{
return
effectSet
;
}
nsAtom
*
propName
=
GetEffectSetPropertyAtom
(
aPseudoType
)
;
effectSet
=
new
EffectSet
(
)
;
nsresult
rv
=
aElement
-
>
SetProperty
(
propName
effectSet
&
EffectSet
:
:
PropertyDtor
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
SetProperty
failed
"
)
;
EffectSet
:
:
PropertyDtor
(
aElement
propName
effectSet
nullptr
)
;
return
nullptr
;
}
aElement
-
>
SetMayHaveAnimations
(
)
;
return
effectSet
;
}
void
EffectSet
:
:
DestroyEffectSet
(
dom
:
:
Element
*
aElement
CSSPseudoElementType
aPseudoType
)
{
nsAtom
*
propName
=
GetEffectSetPropertyAtom
(
aPseudoType
)
;
EffectSet
*
effectSet
=
static_cast
<
EffectSet
*
>
(
aElement
-
>
GetProperty
(
propName
)
)
;
if
(
!
effectSet
)
{
return
;
}
MOZ_ASSERT
(
!
effectSet
-
>
IsBeingEnumerated
(
)
"
Should
not
destroy
an
effect
set
while
it
is
being
enumerated
"
)
;
effectSet
=
nullptr
;
aElement
-
>
DeleteProperty
(
propName
)
;
}
void
EffectSet
:
:
UpdateAnimationGeneration
(
nsPresContext
*
aPresContext
)
{
mAnimationGeneration
=
aPresContext
-
>
RestyleManager
(
)
-
>
GetAnimationGeneration
(
)
;
}
nsAtom
*
*
EffectSet
:
:
GetEffectSetPropertyAtoms
(
)
{
static
nsAtom
*
effectSetPropertyAtoms
[
]
=
{
nsGkAtoms
:
:
animationEffectsProperty
nsGkAtoms
:
:
animationEffectsForBeforeProperty
nsGkAtoms
:
:
animationEffectsForAfterProperty
nullptr
}
;
return
effectSetPropertyAtoms
;
}
nsAtom
*
EffectSet
:
:
GetEffectSetPropertyAtom
(
CSSPseudoElementType
aPseudoType
)
{
switch
(
aPseudoType
)
{
case
CSSPseudoElementType
:
:
NotPseudo
:
return
nsGkAtoms
:
:
animationEffectsProperty
;
case
CSSPseudoElementType
:
:
before
:
return
nsGkAtoms
:
:
animationEffectsForBeforeProperty
;
case
CSSPseudoElementType
:
:
after
:
return
nsGkAtoms
:
:
animationEffectsForAfterProperty
;
default
:
NS_NOTREACHED
(
"
Should
not
try
to
get
animation
effects
for
a
pseudo
"
"
other
that
:
before
or
:
after
"
)
;
return
nullptr
;
}
}
void
EffectSet
:
:
AddEffect
(
dom
:
:
KeyframeEffectReadOnly
&
aEffect
)
{
if
(
mEffects
.
Contains
(
&
aEffect
)
)
{
return
;
}
mEffects
.
PutEntry
(
&
aEffect
)
;
MarkCascadeNeedsUpdate
(
)
;
}
void
EffectSet
:
:
RemoveEffect
(
dom
:
:
KeyframeEffectReadOnly
&
aEffect
)
{
if
(
!
mEffects
.
Contains
(
&
aEffect
)
)
{
return
;
}
mEffects
.
RemoveEntry
(
&
aEffect
)
;
MarkCascadeNeedsUpdate
(
)
;
}
}
