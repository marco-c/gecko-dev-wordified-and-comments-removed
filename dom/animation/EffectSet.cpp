#
include
"
EffectSet
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
LayerAnimationInfo
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCycleCollectionNoteChild
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
ElementAnimationData
.
h
"
namespace
mozilla
{
void
EffectSet
:
:
Traverse
(
nsCycleCollectionTraversalCallback
&
aCallback
)
{
for
(
const
auto
&
key
:
mEffects
)
{
CycleCollectionNoteChild
(
aCallback
key
"
EffectSet
:
:
mEffects
[
]
"
aCallback
.
Flags
(
)
)
;
}
}
EffectSet
*
EffectSet
:
:
Get
(
const
dom
:
:
Element
*
aElement
PseudoStyleType
aPseudoType
)
{
if
(
auto
*
data
=
aElement
-
>
GetAnimationData
(
)
)
{
return
data
-
>
GetEffectSetFor
(
aPseudoType
)
;
}
return
nullptr
;
}
EffectSet
*
EffectSet
:
:
GetOrCreate
(
dom
:
:
Element
*
aElement
PseudoStyleType
aPseudoType
)
{
return
&
aElement
-
>
EnsureAnimationData
(
)
.
EnsureEffectSetFor
(
aPseudoType
)
;
}
EffectSet
*
EffectSet
:
:
GetForFrame
(
const
nsIFrame
*
aFrame
const
nsCSSPropertyIDSet
&
aProperties
)
{
MOZ_ASSERT
(
aFrame
)
;
const
nsIFrame
*
frameToQuery
=
nullptr
;
if
(
aProperties
.
IsSubsetOf
(
nsCSSPropertyIDSet
:
:
TransformLikeProperties
(
)
)
)
{
if
(
!
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSupportsCSSTransforms
)
)
{
return
nullptr
;
}
frameToQuery
=
nsLayoutUtils
:
:
GetStyleFrame
(
aFrame
)
;
}
else
{
MOZ_ASSERT
(
!
aProperties
.
Intersects
(
nsCSSPropertyIDSet
:
:
TransformLikeProperties
(
)
)
"
We
should
have
only
transform
properties
or
no
transform
properties
"
)
;
frameToQuery
=
aFrame
;
}
Maybe
<
NonOwningAnimationTarget
>
target
=
EffectCompositor
:
:
GetAnimationElementAndPseudoForFrame
(
frameToQuery
)
;
if
(
!
target
)
{
return
nullptr
;
}
return
Get
(
target
-
>
mElement
target
-
>
mPseudoType
)
;
}
EffectSet
*
EffectSet
:
:
GetForFrame
(
const
nsIFrame
*
aFrame
DisplayItemType
aDisplayItemType
)
{
return
EffectSet
:
:
GetForFrame
(
aFrame
LayerAnimationInfo
:
:
GetCSSPropertiesFor
(
aDisplayItemType
)
)
;
}
EffectSet
*
EffectSet
:
:
GetForStyleFrame
(
const
nsIFrame
*
aStyleFrame
)
{
Maybe
<
NonOwningAnimationTarget
>
target
=
EffectCompositor
:
:
GetAnimationElementAndPseudoForFrame
(
aStyleFrame
)
;
if
(
!
target
)
{
return
nullptr
;
}
return
Get
(
target
-
>
mElement
target
-
>
mPseudoType
)
;
}
EffectSet
*
EffectSet
:
:
GetForEffect
(
const
dom
:
:
KeyframeEffect
*
aEffect
)
{
NonOwningAnimationTarget
target
=
aEffect
-
>
GetAnimationTarget
(
)
;
if
(
!
target
)
{
return
nullptr
;
}
return
EffectSet
:
:
Get
(
target
.
mElement
target
.
mPseudoType
)
;
}
void
EffectSet
:
:
DestroyEffectSet
(
dom
:
:
Element
*
aElement
PseudoStyleType
aPseudoType
)
{
if
(
auto
*
data
=
aElement
-
>
GetAnimationData
(
)
)
{
data
-
>
ClearEffectSetFor
(
aPseudoType
)
;
}
}
void
EffectSet
:
:
UpdateAnimationGeneration
(
nsPresContext
*
aPresContext
)
{
mAnimationGeneration
=
aPresContext
-
>
RestyleManager
(
)
-
>
GetAnimationGeneration
(
)
;
}
void
EffectSet
:
:
AddEffect
(
dom
:
:
KeyframeEffect
&
aEffect
)
{
if
(
!
mEffects
.
EnsureInserted
(
&
aEffect
)
)
{
return
;
}
MarkCascadeNeedsUpdate
(
)
;
}
void
EffectSet
:
:
RemoveEffect
(
dom
:
:
KeyframeEffect
&
aEffect
)
{
if
(
!
mEffects
.
EnsureRemoved
(
&
aEffect
)
)
{
return
;
}
MarkCascadeNeedsUpdate
(
)
;
}
}
