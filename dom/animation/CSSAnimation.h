#
ifndef
mozilla_dom_CSSAnimation_h
#
define
mozilla_dom_CSSAnimation_h
#
include
"
AnimationCommon
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
mozilla
/
dom
/
MutationObservers
.
h
"
namespace
mozilla
{
enum
class
CSSAnimationProperties
{
None
=
0
Keyframes
=
1
<
<
0
Duration
=
1
<
<
1
IterationCount
=
1
<
<
2
Direction
=
1
<
<
3
Delay
=
1
<
<
4
FillMode
=
1
<
<
5
Composition
=
1
<
<
6
Effect
=
Keyframes
|
Duration
|
IterationCount
|
Direction
|
Delay
|
FillMode
|
Composition
PlayState
=
1
<
<
7
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
CSSAnimationProperties
)
namespace
dom
{
class
CSSAnimation
final
:
public
Animation
{
public
:
explicit
CSSAnimation
(
nsIGlobalObject
*
aGlobal
nsAtom
*
aAnimationName
)
:
dom
:
:
Animation
(
aGlobal
)
mAnimationName
(
aAnimationName
)
mNeedsNewAnimationIndexWhenRun
(
false
)
mPreviousPhase
(
ComputedTiming
:
:
AnimationPhase
:
:
Idle
)
mPreviousIteration
(
0
)
{
MOZ_ASSERT
(
mAnimationName
!
=
nsGkAtoms
:
:
_empty
"
animation
-
name
should
not
be
'
none
'
"
)
;
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
CSSAnimation
*
AsCSSAnimation
(
)
override
{
return
this
;
}
const
CSSAnimation
*
AsCSSAnimation
(
)
const
override
{
return
this
;
}
void
GetAnimationName
(
nsString
&
aRetVal
)
const
{
mAnimationName
-
>
ToString
(
aRetVal
)
;
}
nsAtom
*
AnimationName
(
)
const
{
return
mAnimationName
;
}
void
SetEffect
(
AnimationEffect
*
aEffect
)
override
;
void
SetStartTimeAsDouble
(
const
Nullable
<
double
>
&
aStartTime
)
override
;
Promise
*
GetReady
(
ErrorResult
&
aRv
)
override
;
void
Reverse
(
ErrorResult
&
aRv
)
override
;
AnimationPlayState
PlayStateFromJS
(
)
const
override
;
bool
PendingFromJS
(
)
const
override
;
void
PlayFromJS
(
ErrorResult
&
aRv
)
override
;
void
PauseFromJS
(
ErrorResult
&
aRv
)
override
;
void
PlayFromStyle
(
)
;
void
PauseFromStyle
(
)
;
void
CancelFromStyle
(
PostRestyleMode
aPostRestyle
)
{
Animation
:
:
Cancel
(
aPostRestyle
)
;
mAnimationIndex
=
sNextAnimationIndex
+
+
;
mNeedsNewAnimationIndexWhenRun
=
true
;
mOwningElement
=
OwningElementRef
(
)
;
}
void
Tick
(
TickState
&
)
override
;
void
QueueEvents
(
const
StickyTimeDuration
&
aActiveTime
=
StickyTimeDuration
(
)
)
;
int32_t
CompareCompositeOrder
(
const
CSSAnimation
&
aOther
nsContentUtils
:
:
NodeIndexCache
&
)
const
;
void
SetAnimationIndex
(
uint64_t
aIndex
)
{
MOZ_ASSERT
(
IsTiedToMarkup
(
)
)
;
if
(
IsRelevant
(
)
&
&
mAnimationIndex
!
=
aIndex
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
this
)
;
PostUpdate
(
)
;
}
mAnimationIndex
=
aIndex
;
}
void
SetOwningElement
(
const
OwningElementRef
&
aElement
)
{
mOwningElement
=
aElement
;
}
bool
IsTiedToMarkup
(
)
const
{
return
mOwningElement
.
IsSet
(
)
;
}
void
MaybeQueueCancelEvent
(
const
StickyTimeDuration
&
aActiveTime
)
override
{
QueueEvents
(
aActiveTime
)
;
}
CSSAnimationProperties
GetOverriddenProperties
(
)
const
{
return
mOverriddenProperties
;
}
void
AddOverriddenProperties
(
CSSAnimationProperties
aProperties
)
{
mOverriddenProperties
|
=
aProperties
;
}
protected
:
virtual
~
CSSAnimation
(
)
{
MOZ_ASSERT
(
!
mOwningElement
.
IsSet
(
)
"
Owning
element
should
be
cleared
"
"
before
a
CSS
animation
is
destroyed
"
)
;
}
void
UpdateTiming
(
SeekFlag
aSeekFlag
SyncNotifyFlag
aSyncNotifyFlag
)
override
;
TimeDuration
InitialAdvance
(
)
const
{
return
mEffect
?
std
:
:
max
(
TimeDuration
(
)
mEffect
-
>
NormalizedTiming
(
)
.
Delay
(
)
*
-
1
)
:
TimeDuration
(
)
;
}
RefPtr
<
nsAtom
>
mAnimationName
;
OwningElementRef
mOwningElement
;
bool
mNeedsNewAnimationIndexWhenRun
;
ComputedTiming
:
:
AnimationPhase
mPreviousPhase
;
uint64_t
mPreviousIteration
;
CSSAnimationProperties
mOverriddenProperties
=
CSSAnimationProperties
:
:
None
;
}
;
class
CSSAnimationKeyframeEffect
:
public
KeyframeEffect
{
public
:
CSSAnimationKeyframeEffect
(
Document
*
aDocument
OwningAnimationTarget
&
&
aTarget
TimingParams
&
&
aTiming
const
KeyframeEffectParams
&
aOptions
)
:
KeyframeEffect
(
aDocument
std
:
:
move
(
aTarget
)
std
:
:
move
(
aTiming
)
aOptions
)
{
}
void
GetTiming
(
EffectTiming
&
aRetVal
)
const
override
;
void
GetComputedTimingAsDict
(
ComputedEffectTiming
&
aRetVal
)
const
override
;
void
UpdateTiming
(
const
OptionalEffectTiming
&
aTiming
ErrorResult
&
aRv
)
override
;
void
SetKeyframes
(
JSContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
ErrorResult
&
aRv
)
override
;
void
SetComposite
(
const
CompositeOperation
&
aComposite
)
override
;
private
:
CSSAnimation
*
GetOwningCSSAnimation
(
)
{
return
mAnimation
?
mAnimation
-
>
AsCSSAnimation
(
)
:
nullptr
;
}
const
CSSAnimation
*
GetOwningCSSAnimation
(
)
const
{
return
mAnimation
?
mAnimation
-
>
AsCSSAnimation
(
)
:
nullptr
;
}
void
MaybeFlushUnanimatedStyle
(
)
const
;
}
;
}
}
#
endif
