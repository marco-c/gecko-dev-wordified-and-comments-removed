#
ifndef
mozilla_dom_KeyframeEffect_h
#
define
mozilla_dom_KeyframeEffect_h
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
LayerAnimationInfo
.
h
"
#
include
"
mozilla
/
StickyTimeDuration
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectReadOnly
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeBinding
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
dom
/
UnionTypes
.
h
"
#
ifdef
None
#
undef
None
#
endif
#
include
"
mozilla
/
dom
/
AnimationEffectReadOnlyBinding
.
h
"
struct
JSContext
;
class
nsCSSPropertySet
;
class
nsIContent
;
class
nsIDocument
;
class
nsIFrame
;
class
nsPresContext
;
namespace
mozilla
{
struct
AnimationCollection
;
class
AnimValuesStyleRule
;
namespace
dom
{
class
UnrestrictedDoubleOrKeyframeEffectOptions
;
enum
class
IterationCompositeOperation
:
uint32_t
;
enum
class
CompositeOperation
:
uint32_t
;
}
struct
AnimationTiming
{
dom
:
:
OwningUnrestrictedDoubleOrString
mDuration
;
TimeDuration
mDelay
;
double
mIterations
;
dom
:
:
PlaybackDirection
mDirection
;
dom
:
:
FillMode
mFill
;
bool
operator
=
=
(
const
AnimationTiming
&
aOther
)
const
{
bool
durationEqual
;
if
(
mDuration
.
IsUnrestrictedDouble
(
)
)
{
durationEqual
=
aOther
.
mDuration
.
IsUnrestrictedDouble
(
)
&
&
(
mDuration
.
GetAsUnrestrictedDouble
(
)
=
=
aOther
.
mDuration
.
GetAsUnrestrictedDouble
(
)
)
;
}
else
if
(
mDuration
.
IsString
(
)
)
{
durationEqual
=
aOther
.
mDuration
.
IsString
(
)
&
&
(
mDuration
.
GetAsString
(
)
=
=
aOther
.
mDuration
.
GetAsString
(
)
)
;
}
else
{
durationEqual
=
!
aOther
.
mDuration
.
IsUnrestrictedDouble
(
)
&
&
!
aOther
.
mDuration
.
IsString
(
)
;
}
return
durationEqual
&
&
mDelay
=
=
aOther
.
mDelay
&
&
mIterations
=
=
aOther
.
mIterations
&
&
mDirection
=
=
aOther
.
mDirection
&
&
mFill
=
=
aOther
.
mFill
;
}
bool
operator
!
=
(
const
AnimationTiming
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
ComputedTiming
{
StickyTimeDuration
mActiveDuration
;
Nullable
<
double
>
mProgress
;
uint64_t
mCurrentIteration
=
0
;
double
mIterations
=
1
.
0
;
StickyTimeDuration
mDuration
;
dom
:
:
FillMode
mFill
=
dom
:
:
FillMode
:
:
None
;
bool
FillsForwards
(
)
const
{
MOZ_ASSERT
(
mFill
!
=
dom
:
:
FillMode
:
:
Auto
"
mFill
should
not
be
Auto
in
ComputedTiming
.
"
)
;
return
mFill
=
=
dom
:
:
FillMode
:
:
Both
|
|
mFill
=
=
dom
:
:
FillMode
:
:
Forwards
;
}
bool
FillsBackwards
(
)
const
{
MOZ_ASSERT
(
mFill
!
=
dom
:
:
FillMode
:
:
Auto
"
mFill
should
not
be
Auto
in
ComputedTiming
.
"
)
;
return
mFill
=
=
dom
:
:
FillMode
:
:
Both
|
|
mFill
=
=
dom
:
:
FillMode
:
:
Backwards
;
}
enum
class
AnimationPhase
{
Null
Before
Active
After
}
;
AnimationPhase
mPhase
=
AnimationPhase
:
:
Null
;
}
;
struct
AnimationPropertySegment
{
float
mFromKey
mToKey
;
StyleAnimationValue
mFromValue
mToValue
;
ComputedTimingFunction
mTimingFunction
;
bool
operator
=
=
(
const
AnimationPropertySegment
&
aOther
)
const
{
return
mFromKey
=
=
aOther
.
mFromKey
&
&
mToKey
=
=
aOther
.
mToKey
&
&
mFromValue
=
=
aOther
.
mFromValue
&
&
mToValue
=
=
aOther
.
mToValue
&
&
mTimingFunction
=
=
aOther
.
mTimingFunction
;
}
bool
operator
!
=
(
const
AnimationPropertySegment
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
AnimationProperty
{
nsCSSProperty
mProperty
=
eCSSProperty_UNKNOWN
;
bool
mWinsInCascade
=
false
;
bool
mIsRunningOnCompositor
=
false
;
InfallibleTArray
<
AnimationPropertySegment
>
mSegments
;
bool
operator
=
=
(
const
AnimationProperty
&
aOther
)
const
{
return
mProperty
=
=
aOther
.
mProperty
&
&
mSegments
=
=
aOther
.
mSegments
;
}
bool
operator
!
=
(
const
AnimationProperty
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
ElementPropertyTransition
;
namespace
dom
{
class
Animation
;
class
KeyframeEffectReadOnly
:
public
AnimationEffectReadOnly
{
public
:
KeyframeEffectReadOnly
(
nsIDocument
*
aDocument
Element
*
aTarget
nsCSSPseudoElements
:
:
Type
aPseudoType
const
AnimationTiming
&
aTiming
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED
(
KeyframeEffectReadOnly
AnimationEffectReadOnly
)
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
virtual
ElementPropertyTransition
*
AsTransition
(
)
{
return
nullptr
;
}
virtual
const
ElementPropertyTransition
*
AsTransition
(
)
const
{
return
nullptr
;
}
static
already_AddRefed
<
KeyframeEffectReadOnly
>
Constructor
(
const
GlobalObject
&
aGlobal
Element
*
aTarget
const
Optional
<
JS
:
:
Handle
<
JSObject
*
>
>
&
aFrames
const
UnrestrictedDoubleOrKeyframeEffectOptions
&
aOptions
ErrorResult
&
aRv
)
;
Element
*
GetTarget
(
)
const
{
MOZ_ASSERT
(
mPseudoType
=
=
nsCSSPseudoElements
:
:
ePseudo_NotPseudoElement
"
Requesting
the
target
of
a
KeyframeEffect
that
targets
a
"
"
pseudo
-
element
is
not
yet
supported
.
"
)
;
return
mTarget
;
}
void
GetFrames
(
JSContext
*
&
aCx
nsTArray
<
JSObject
*
>
&
aResult
ErrorResult
&
aRv
)
;
void
GetTarget
(
Element
*
&
aTarget
nsCSSPseudoElements
:
:
Type
&
aPseudoType
)
const
{
aTarget
=
mTarget
;
aPseudoType
=
mPseudoType
;
}
IterationCompositeOperation
IterationComposite
(
)
const
;
CompositeOperation
Composite
(
)
const
;
void
GetSpacing
(
nsString
&
aRetVal
)
const
{
aRetVal
.
AssignLiteral
(
"
distribute
"
)
;
}
const
AnimationTiming
&
Timing
(
)
const
{
return
mTiming
;
}
AnimationTiming
&
Timing
(
)
{
return
mTiming
;
}
void
SetTiming
(
const
AnimationTiming
&
aTiming
)
;
void
NotifyAnimationTimingUpdated
(
)
;
Nullable
<
TimeDuration
>
GetLocalTime
(
)
const
;
static
ComputedTiming
GetComputedTimingAt
(
const
Nullable
<
TimeDuration
>
&
aLocalTime
const
AnimationTiming
&
aTiming
)
;
ComputedTiming
GetComputedTiming
(
const
AnimationTiming
*
aTiming
=
nullptr
)
const
{
return
GetComputedTimingAt
(
GetLocalTime
(
)
aTiming
?
*
aTiming
:
mTiming
)
;
}
void
GetComputedTimingAsDict
(
ComputedTimingProperties
&
aRetVal
)
const
override
;
static
StickyTimeDuration
ActiveDuration
(
const
StickyTimeDuration
&
aIterationDuration
double
aIterationCount
)
;
bool
IsInPlay
(
)
const
;
bool
IsCurrent
(
)
const
;
bool
IsInEffect
(
)
const
;
void
SetAnimation
(
Animation
*
aAnimation
)
;
Animation
*
GetAnimation
(
)
const
{
return
mAnimation
;
}
const
AnimationProperty
*
GetAnimationOfProperty
(
nsCSSProperty
aProperty
)
const
;
bool
HasAnimationOfProperty
(
nsCSSProperty
aProperty
)
const
{
return
GetAnimationOfProperty
(
aProperty
)
!
=
nullptr
;
}
bool
HasAnimationOfProperties
(
const
nsCSSProperty
*
aProperties
size_t
aPropertyCount
)
const
;
const
InfallibleTArray
<
AnimationProperty
>
&
Properties
(
)
const
{
return
mProperties
;
}
InfallibleTArray
<
AnimationProperty
>
&
Properties
(
)
{
return
mProperties
;
}
void
CopyPropertiesFrom
(
const
KeyframeEffectReadOnly
&
aOther
)
;
void
ComposeStyle
(
RefPtr
<
AnimValuesStyleRule
>
&
aStyleRule
nsCSSPropertySet
&
aSetProperties
)
;
bool
IsRunningOnCompositor
(
)
const
;
void
SetIsRunningOnCompositor
(
nsCSSProperty
aProperty
bool
aIsRunning
)
;
bool
ShouldBlockCompositorAnimations
(
const
nsIFrame
*
aFrame
)
const
;
nsIDocument
*
GetRenderedDocument
(
)
const
;
nsPresContext
*
GetPresContext
(
)
const
;
inline
AnimationCollection
*
GetCollection
(
)
const
;
protected
:
virtual
~
KeyframeEffectReadOnly
(
)
;
void
ResetIsRunningOnCompositor
(
)
;
void
UpdateTargetRegistration
(
)
;
static
AnimationTiming
ConvertKeyframeEffectOptions
(
const
UnrestrictedDoubleOrKeyframeEffectOptions
&
aOptions
)
;
static
void
BuildAnimationPropertyList
(
JSContext
*
aCx
Element
*
aTarget
const
Optional
<
JS
:
:
Handle
<
JSObject
*
>
>
&
aFrames
InfallibleTArray
<
AnimationProperty
>
&
aResult
ErrorResult
&
aRv
)
;
nsCOMPtr
<
Element
>
mTarget
;
RefPtr
<
Animation
>
mAnimation
;
AnimationTiming
mTiming
;
nsCSSPseudoElements
:
:
Type
mPseudoType
;
InfallibleTArray
<
AnimationProperty
>
mProperties
;
Nullable
<
double
>
mProgressOnLastCompose
;
bool
mInEffectOnLastAnimationTimingUpdate
;
private
:
nsIFrame
*
GetAnimationFrame
(
)
const
;
bool
CanThrottle
(
)
const
;
bool
CanThrottleTransformChanges
(
nsIFrame
&
aFrame
)
const
;
static
bool
CanAnimateTransformOnCompositor
(
const
nsIFrame
*
aFrame
const
nsIContent
*
aContent
)
;
static
bool
IsGeometricProperty
(
const
nsCSSProperty
aProperty
)
;
static
const
TimeDuration
OverflowRegionRefreshInterval
(
)
;
}
;
}
}
#
endif
