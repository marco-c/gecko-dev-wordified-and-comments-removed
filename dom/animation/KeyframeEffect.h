#
ifndef
mozilla_dom_KeyframeEffect_h
#
define
mozilla_dom_KeyframeEffect_h
#
include
"
nsChangeHint
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
include
"
nsCSSPropertyIDSet
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
AnimationPerformanceWarning
.
h
"
#
include
"
mozilla
/
AnimationPropertySegment
.
h
"
#
include
"
mozilla
/
AnimationTarget
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
Keyframe
.
h
"
#
include
"
mozilla
/
KeyframeEffectParams
.
h
"
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffect
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
struct
JSContext
;
class
JSObject
;
class
nsIContent
;
class
nsIDocument
;
class
nsIFrame
;
class
nsIPresShell
;
namespace
mozilla
{
class
AnimValuesStyleRule
;
enum
class
CSSPseudoElementType
:
uint8_t
;
class
ErrorResult
;
struct
AnimationRule
;
struct
TimingParams
;
class
EffectSet
;
class
ComputedStyle
;
namespace
dom
{
class
ElementOrCSSPseudoElement
;
class
GlobalObject
;
class
OwningElementOrCSSPseudoElement
;
class
UnrestrictedDoubleOrKeyframeAnimationOptions
;
class
UnrestrictedDoubleOrKeyframeEffectOptions
;
enum
class
IterationCompositeOperation
:
uint8_t
;
enum
class
CompositeOperation
:
uint8_t
;
struct
AnimationPropertyDetails
;
}
struct
AnimationProperty
{
nsCSSPropertyID
mProperty
=
eCSSProperty_UNKNOWN
;
bool
mIsRunningOnCompositor
=
false
;
Maybe
<
AnimationPerformanceWarning
>
mPerformanceWarning
;
InfallibleTArray
<
AnimationPropertySegment
>
mSegments
;
AnimationProperty
(
)
=
default
;
AnimationProperty
(
const
AnimationProperty
&
aOther
)
:
mProperty
(
aOther
.
mProperty
)
mSegments
(
aOther
.
mSegments
)
{
}
AnimationProperty
&
operator
=
(
const
AnimationProperty
&
aOther
)
{
mProperty
=
aOther
.
mProperty
;
mSegments
=
aOther
.
mSegments
;
return
*
this
;
}
bool
operator
=
=
(
const
AnimationProperty
&
aOther
)
const
{
return
mProperty
=
=
aOther
.
mProperty
&
&
mSegments
=
=
aOther
.
mSegments
;
}
bool
operator
!
=
(
const
AnimationProperty
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
ElementPropertyTransition
;
namespace
dom
{
class
Animation
;
class
KeyframeEffect
:
public
AnimationEffect
{
public
:
KeyframeEffect
(
nsIDocument
*
aDocument
const
Maybe
<
OwningAnimationTarget
>
&
aTarget
const
TimingParams
&
aTiming
const
KeyframeEffectParams
&
aOptions
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED
(
KeyframeEffect
AnimationEffect
)
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
KeyframeEffect
*
AsKeyframeEffect
(
)
override
{
return
this
;
}
static
already_AddRefed
<
KeyframeEffect
>
Constructor
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
UnrestrictedDoubleOrKeyframeEffectOptions
&
aOptions
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
KeyframeEffect
>
Constructor
(
const
GlobalObject
&
aGlobal
KeyframeEffect
&
aSource
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
KeyframeEffect
>
Constructor
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
UnrestrictedDoubleOrKeyframeAnimationOptions
&
aOptions
ErrorResult
&
aRv
)
;
void
GetTarget
(
Nullable
<
OwningElementOrCSSPseudoElement
>
&
aRv
)
const
;
Maybe
<
NonOwningAnimationTarget
>
GetTarget
(
)
const
{
Maybe
<
NonOwningAnimationTarget
>
result
;
if
(
mTarget
)
{
result
.
emplace
(
*
mTarget
)
;
}
return
result
;
}
void
SetTarget
(
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
)
;
void
GetKeyframes
(
JSContext
*
&
aCx
nsTArray
<
JSObject
*
>
&
aResult
ErrorResult
&
aRv
)
;
void
GetProperties
(
nsTArray
<
AnimationPropertyDetails
>
&
aProperties
ErrorResult
&
aRv
)
const
;
IterationCompositeOperation
IterationComposite
(
)
const
;
void
SetIterationComposite
(
const
IterationCompositeOperation
&
aIterationComposite
)
;
CompositeOperation
Composite
(
)
const
;
void
SetComposite
(
const
CompositeOperation
&
aComposite
)
;
void
NotifySpecifiedTimingUpdated
(
)
;
void
NotifyAnimationTimingUpdated
(
)
;
void
RequestRestyle
(
EffectCompositor
:
:
RestyleType
aRestyleType
)
;
void
SetAnimation
(
Animation
*
aAnimation
)
override
;
void
SetKeyframes
(
JSContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
ErrorResult
&
aRv
)
;
void
SetKeyframes
(
nsTArray
<
Keyframe
>
&
&
aKeyframes
const
ComputedStyle
*
aStyle
)
;
bool
HasAnimationOfProperty
(
nsCSSPropertyID
aProperty
)
const
;
bool
HasEffectiveAnimationOfProperty
(
nsCSSPropertyID
aProperty
)
const
{
return
GetEffectiveAnimationOfProperty
(
aProperty
)
!
=
nullptr
;
}
const
AnimationProperty
*
GetEffectiveAnimationOfProperty
(
nsCSSPropertyID
aProperty
)
const
;
const
InfallibleTArray
<
AnimationProperty
>
&
Properties
(
)
const
{
return
mProperties
;
}
void
UpdateProperties
(
const
ComputedStyle
*
aComputedValues
)
;
void
WillComposeStyle
(
)
;
void
ComposeStyle
(
RawServoAnimationValueMap
&
aComposeResult
const
nsCSSPropertyIDSet
&
aPropertiesToSkip
)
;
bool
IsRunningOnCompositor
(
)
const
;
void
SetIsRunningOnCompositor
(
nsCSSPropertyID
aProperty
bool
aIsRunning
)
;
void
ResetIsRunningOnCompositor
(
)
;
bool
ShouldBlockAsyncTransformAnimations
(
const
nsIFrame
*
aFrame
AnimationPerformanceWarning
:
:
Type
&
aPerformanceWarning
)
const
;
bool
HasGeometricProperties
(
)
const
;
bool
AffectsGeometry
(
)
const
override
{
return
GetTarget
(
)
&
&
HasGeometricProperties
(
)
;
}
nsIDocument
*
GetRenderedDocument
(
)
const
;
nsIPresShell
*
GetPresShell
(
)
const
;
void
SetPerformanceWarning
(
nsCSSPropertyID
aProperty
const
AnimationPerformanceWarning
&
aWarning
)
;
void
CalculateCumulativeChangeHint
(
const
ComputedStyle
*
aStyle
)
;
bool
CanIgnoreIfNotVisible
(
)
const
;
bool
ContainsAnimatedScale
(
const
nsIFrame
*
aFrame
)
const
;
AnimationValue
BaseStyle
(
nsCSSPropertyID
aProperty
)
const
{
AnimationValue
result
;
bool
hasProperty
=
false
;
result
.
mServo
=
mBaseStyleValuesForServo
.
GetWeak
(
aProperty
&
hasProperty
)
;
MOZ_ASSERT
(
hasProperty
|
|
result
.
IsNull
(
)
)
;
return
result
;
}
static
bool
HasComputedTimingChanged
(
const
ComputedTiming
&
aComputedTiming
IterationCompositeOperation
aIterationComposite
const
Nullable
<
double
>
&
aProgressOnLastCompose
uint64_t
aCurrentIterationOnLastCompose
)
;
protected
:
~
KeyframeEffect
(
)
override
=
default
;
static
Maybe
<
OwningAnimationTarget
>
ConvertTarget
(
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
)
;
template
<
class
OptionsType
>
static
already_AddRefed
<
KeyframeEffect
>
ConstructKeyframeEffect
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
OptionsType
&
aOptions
ErrorResult
&
aRv
)
;
nsTArray
<
AnimationProperty
>
BuildProperties
(
const
ComputedStyle
*
aStyle
)
;
void
UpdateTargetRegistration
(
)
;
void
UnregisterTarget
(
)
;
void
MaybeUpdateFrameForCompositor
(
)
;
already_AddRefed
<
ComputedStyle
>
GetTargetComputedStyle
(
)
;
void
MarkCascadeNeedsUpdate
(
)
;
void
EnsureBaseStyles
(
const
ComputedStyle
*
aComputedValues
const
nsTArray
<
AnimationProperty
>
&
aProperties
)
;
void
EnsureBaseStyle
(
const
AnimationProperty
&
aProperty
nsPresContext
*
aPresContext
const
ComputedStyle
*
aComputedValues
RefPtr
<
ComputedStyle
>
&
aBaseComputedValues
)
;
Maybe
<
OwningAnimationTarget
>
mTarget
;
KeyframeEffectParams
mEffectOptions
;
nsTArray
<
Keyframe
>
mKeyframes
;
nsTArray
<
AnimationProperty
>
mProperties
;
Nullable
<
double
>
mProgressOnLastCompose
;
uint64_t
mCurrentIterationOnLastCompose
=
0
;
bool
mInEffectOnLastAnimationTimingUpdate
;
nsRefPtrHashtable
<
nsUint32HashKey
RawServoAnimationValue
>
mBaseStyleValuesForServo
;
bool
mInEffectSet
=
false
;
private
:
nsChangeHint
mCumulativeChangeHint
;
void
ComposeStyleRule
(
RawServoAnimationValueMap
&
aAnimationValues
const
AnimationProperty
&
aProperty
const
AnimationPropertySegment
&
aSegment
const
ComputedTiming
&
aComputedTiming
)
;
already_AddRefed
<
ComputedStyle
>
CreateComputedStyleForAnimationValue
(
nsCSSPropertyID
aProperty
const
AnimationValue
&
aValue
nsPresContext
*
aPresContext
const
ComputedStyle
*
aBaseComputedStyle
)
;
nsIFrame
*
GetPrimaryFrame
(
)
const
;
nsIFrame
*
GetStyleFrame
(
)
const
;
bool
CanThrottle
(
)
const
;
bool
CanThrottleOverflowChanges
(
const
nsIFrame
&
aFrame
)
const
;
bool
CanThrottleOverflowChangesInScrollable
(
nsIFrame
&
aFrame
)
const
;
bool
CanThrottleIfNotVisible
(
nsIFrame
&
aFrame
)
const
;
bool
HasComputedTimingChanged
(
)
const
;
static
bool
CanAnimateTransformOnCompositor
(
const
nsIFrame
*
aFrame
AnimationPerformanceWarning
:
:
Type
&
aPerformanceWarning
)
;
static
bool
IsGeometricProperty
(
const
nsCSSPropertyID
aProperty
)
;
static
const
TimeDuration
OverflowRegionRefreshInterval
(
)
;
void
UpdateEffectSet
(
mozilla
:
:
EffectSet
*
aEffectSet
=
nullptr
)
const
;
bool
HasPropertiesThatMightAffectOverflow
(
)
const
{
return
mCumulativeChangeHint
&
(
nsChangeHint_AddOrRemoveTransform
|
nsChangeHint_UpdateOverflow
|
nsChangeHint_UpdatePostTransformOverflow
|
nsChangeHint_UpdateTransformLayer
)
;
}
bool
HasVisibilityChange
(
)
const
{
return
mCumulativeChangeHint
&
nsChangeHint_VisibilityChange
;
}
}
;
}
}
#
endif
