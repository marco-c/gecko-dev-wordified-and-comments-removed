#
ifndef
mozilla_dom_KeyframeEffect_h
#
define
mozilla_dom_KeyframeEffect_h
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
LayerAnimationInfo
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
StickyTimeDuration
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectReadOnly
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectTiming
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectTimingReadOnly
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeBinding
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
struct
JSContext
;
class
nsCSSPropertySet
;
class
nsIContent
;
class
nsIDocument
;
class
nsIFrame
;
class
nsPresContext
;
namespace
mozilla
{
class
AnimValuesStyleRule
;
enum
class
CSSPseudoElementType
:
uint8_t
;
namespace
dom
{
class
ElementOrCSSPseudoElement
;
class
OwningElementOrCSSPseudoElement
;
class
UnrestrictedDoubleOrKeyframeEffectOptions
;
enum
class
IterationCompositeOperation
:
uint32_t
;
enum
class
CompositeOperation
:
uint32_t
;
}
struct
ComputedTiming
{
StickyTimeDuration
mActiveDuration
;
StickyTimeDuration
mEndTime
;
Nullable
<
double
>
mProgress
;
uint64_t
mCurrentIteration
=
0
;
double
mIterations
=
1
.
0
;
StickyTimeDuration
mDuration
;
dom
:
:
FillMode
mFill
=
dom
:
:
FillMode
:
:
None
;
bool
FillsForwards
(
)
const
{
MOZ_ASSERT
(
mFill
!
=
dom
:
:
FillMode
:
:
Auto
"
mFill
should
not
be
Auto
in
ComputedTiming
.
"
)
;
return
mFill
=
=
dom
:
:
FillMode
:
:
Both
|
|
mFill
=
=
dom
:
:
FillMode
:
:
Forwards
;
}
bool
FillsBackwards
(
)
const
{
MOZ_ASSERT
(
mFill
!
=
dom
:
:
FillMode
:
:
Auto
"
mFill
should
not
be
Auto
in
ComputedTiming
.
"
)
;
return
mFill
=
=
dom
:
:
FillMode
:
:
Both
|
|
mFill
=
=
dom
:
:
FillMode
:
:
Backwards
;
}
enum
class
AnimationPhase
{
Null
Before
Active
After
}
;
AnimationPhase
mPhase
=
AnimationPhase
:
:
Null
;
}
;
struct
AnimationPropertySegment
{
float
mFromKey
mToKey
;
StyleAnimationValue
mFromValue
mToValue
;
Maybe
<
ComputedTimingFunction
>
mTimingFunction
;
bool
operator
=
=
(
const
AnimationPropertySegment
&
aOther
)
const
{
return
mFromKey
=
=
aOther
.
mFromKey
&
&
mToKey
=
=
aOther
.
mToKey
&
&
mFromValue
=
=
aOther
.
mFromValue
&
&
mToValue
=
=
aOther
.
mToValue
&
&
mTimingFunction
=
=
aOther
.
mTimingFunction
;
}
bool
operator
!
=
(
const
AnimationPropertySegment
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
AnimationProperty
{
nsCSSProperty
mProperty
=
eCSSProperty_UNKNOWN
;
bool
mWinsInCascade
=
false
;
bool
mIsRunningOnCompositor
=
false
;
InfallibleTArray
<
AnimationPropertySegment
>
mSegments
;
bool
operator
=
=
(
const
AnimationProperty
&
aOther
)
const
{
return
mProperty
=
=
aOther
.
mProperty
&
&
mSegments
=
=
aOther
.
mSegments
;
}
bool
operator
!
=
(
const
AnimationProperty
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
ElementPropertyTransition
;
namespace
dom
{
class
Animation
;
class
KeyframeEffectReadOnly
:
public
AnimationEffectReadOnly
{
public
:
KeyframeEffectReadOnly
(
nsIDocument
*
aDocument
Element
*
aTarget
CSSPseudoElementType
aPseudoType
const
TimingParams
&
aTiming
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED
(
KeyframeEffectReadOnly
AnimationEffectReadOnly
)
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
virtual
ElementPropertyTransition
*
AsTransition
(
)
{
return
nullptr
;
}
virtual
const
ElementPropertyTransition
*
AsTransition
(
)
const
{
return
nullptr
;
}
static
already_AddRefed
<
KeyframeEffectReadOnly
>
Constructor
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aFrames
const
UnrestrictedDoubleOrKeyframeEffectOptions
&
aOptions
ErrorResult
&
aRv
)
{
return
ConstructKeyframeEffect
<
KeyframeEffectReadOnly
>
(
aGlobal
aTarget
aFrames
TimingParams
:
:
FromOptionsUnion
(
aOptions
aTarget
)
aRv
)
;
}
void
GetTarget
(
Nullable
<
OwningElementOrCSSPseudoElement
>
&
aRv
)
const
;
void
GetFrames
(
JSContext
*
&
aCx
nsTArray
<
JSObject
*
>
&
aResult
ErrorResult
&
aRv
)
;
void
GetTarget
(
Element
*
&
aTarget
CSSPseudoElementType
&
aPseudoType
)
const
{
aTarget
=
mTarget
;
aPseudoType
=
mPseudoType
;
}
IterationCompositeOperation
IterationComposite
(
)
const
;
CompositeOperation
Composite
(
)
const
;
void
GetSpacing
(
nsString
&
aRetVal
)
const
{
aRetVal
.
AssignLiteral
(
"
distribute
"
)
;
}
already_AddRefed
<
AnimationEffectTimingReadOnly
>
Timing
(
)
const
override
;
const
TimingParams
&
SpecifiedTiming
(
)
const
{
return
mTiming
-
>
AsTimingParams
(
)
;
}
void
SetSpecifiedTiming
(
const
TimingParams
&
aTiming
)
;
void
NotifyAnimationTimingUpdated
(
)
;
Nullable
<
TimeDuration
>
GetLocalTime
(
)
const
;
static
ComputedTiming
GetComputedTimingAt
(
const
Nullable
<
TimeDuration
>
&
aLocalTime
const
TimingParams
&
aTiming
)
;
ComputedTiming
GetComputedTiming
(
const
TimingParams
*
aTiming
=
nullptr
)
const
{
return
GetComputedTimingAt
(
GetLocalTime
(
)
aTiming
?
*
aTiming
:
SpecifiedTiming
(
)
)
;
}
void
GetComputedTimingAsDict
(
ComputedTimingProperties
&
aRetVal
)
const
override
;
static
StickyTimeDuration
ActiveDuration
(
const
StickyTimeDuration
&
aIterationDuration
double
aIterationCount
)
;
bool
IsInPlay
(
)
const
;
bool
IsCurrent
(
)
const
;
bool
IsInEffect
(
)
const
;
void
SetAnimation
(
Animation
*
aAnimation
)
;
Animation
*
GetAnimation
(
)
const
{
return
mAnimation
;
}
const
AnimationProperty
*
GetAnimationOfProperty
(
nsCSSProperty
aProperty
)
const
;
bool
HasAnimationOfProperty
(
nsCSSProperty
aProperty
)
const
{
return
GetAnimationOfProperty
(
aProperty
)
!
=
nullptr
;
}
bool
HasAnimationOfProperties
(
const
nsCSSProperty
*
aProperties
size_t
aPropertyCount
)
const
;
const
InfallibleTArray
<
AnimationProperty
>
&
Properties
(
)
const
{
return
mProperties
;
}
InfallibleTArray
<
AnimationProperty
>
&
Properties
(
)
{
return
mProperties
;
}
bool
UpdateProperties
(
const
InfallibleTArray
<
AnimationProperty
>
&
aProperties
)
;
void
ComposeStyle
(
RefPtr
<
AnimValuesStyleRule
>
&
aStyleRule
nsCSSPropertySet
&
aSetProperties
)
;
bool
IsRunningOnCompositor
(
)
const
;
void
SetIsRunningOnCompositor
(
nsCSSProperty
aProperty
bool
aIsRunning
)
;
bool
ShouldBlockCompositorAnimations
(
const
nsIFrame
*
aFrame
)
const
;
nsIDocument
*
GetRenderedDocument
(
)
const
;
nsPresContext
*
GetPresContext
(
)
const
;
protected
:
KeyframeEffectReadOnly
(
nsIDocument
*
aDocument
Element
*
aTarget
CSSPseudoElementType
aPseudoType
AnimationEffectTimingReadOnly
*
aTiming
)
;
virtual
~
KeyframeEffectReadOnly
(
)
;
template
<
typename
KeyframeEffectType
>
static
already_AddRefed
<
KeyframeEffectType
>
ConstructKeyframeEffect
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aFrames
const
TimingParams
&
aTiming
ErrorResult
&
aRv
)
;
void
ResetIsRunningOnCompositor
(
)
;
void
UpdateTargetRegistration
(
)
;
static
void
BuildAnimationPropertyList
(
JSContext
*
aCx
Element
*
aTarget
CSSPseudoElementType
aPseudoType
JS
:
:
Handle
<
JSObject
*
>
aFrames
InfallibleTArray
<
AnimationProperty
>
&
aResult
ErrorResult
&
aRv
)
;
nsCOMPtr
<
Element
>
mTarget
;
RefPtr
<
Animation
>
mAnimation
;
OwningNonNull
<
AnimationEffectTimingReadOnly
>
mTiming
;
CSSPseudoElementType
mPseudoType
;
InfallibleTArray
<
AnimationProperty
>
mProperties
;
Nullable
<
double
>
mProgressOnLastCompose
;
bool
mInEffectOnLastAnimationTimingUpdate
;
private
:
nsIFrame
*
GetAnimationFrame
(
)
const
;
bool
CanThrottle
(
)
const
;
bool
CanThrottleTransformChanges
(
nsIFrame
&
aFrame
)
const
;
static
bool
CanAnimateTransformOnCompositor
(
const
nsIFrame
*
aFrame
const
nsIContent
*
aContent
)
;
static
bool
IsGeometricProperty
(
const
nsCSSProperty
aProperty
)
;
static
const
TimeDuration
OverflowRegionRefreshInterval
(
)
;
}
;
class
KeyframeEffect
:
public
KeyframeEffectReadOnly
{
public
:
KeyframeEffect
(
nsIDocument
*
aDocument
Element
*
aTarget
CSSPseudoElementType
aPseudoType
const
TimingParams
&
aTiming
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
static
already_AddRefed
<
KeyframeEffect
>
Constructor
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aFrames
const
UnrestrictedDoubleOrKeyframeEffectOptions
&
aOptions
ErrorResult
&
aRv
)
{
return
ConstructKeyframeEffect
<
KeyframeEffect
>
(
aGlobal
aTarget
aFrames
TimingParams
:
:
FromOptionsUnion
(
aOptions
aTarget
)
aRv
)
;
}
static
already_AddRefed
<
KeyframeEffect
>
inline
Constructor
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aFrames
const
TimingParams
&
aTiming
ErrorResult
&
aRv
)
{
return
ConstructKeyframeEffect
<
KeyframeEffect
>
(
aGlobal
aTarget
aFrames
aTiming
aRv
)
;
}
}
;
}
}
#
endif
