#
ifndef
mozilla_dom_KeyframeEffect_h
#
define
mozilla_dom_KeyframeEffect_h
#
include
"
nsChangeHint
.
h
"
#
include
"
nsCSSProperty
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
AnimationPerformanceWarning
.
h
"
#
include
"
mozilla
/
AnimationTarget
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ComputedTiming
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
KeyframeEffectParams
.
h
"
#
include
"
mozilla
/
LayerAnimationInfo
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StickyTimeDuration
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TimingParams
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectReadOnly
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectTimingReadOnly
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
struct
JSContext
;
class
nsCSSPropertySet
;
class
nsIContent
;
class
nsIDocument
;
class
nsIFrame
;
class
nsIPresShell
;
class
nsPresContext
;
namespace
mozilla
{
class
AnimValuesStyleRule
;
enum
class
CSSPseudoElementType
:
uint8_t
;
namespace
dom
{
class
ElementOrCSSPseudoElement
;
class
OwningElementOrCSSPseudoElement
;
class
UnrestrictedDoubleOrKeyframeAnimationOptions
;
class
UnrestrictedDoubleOrKeyframeEffectOptions
;
enum
class
IterationCompositeOperation
:
uint32_t
;
enum
class
CompositeOperation
:
uint32_t
;
struct
AnimationPropertyDetails
;
}
struct
PropertyValuePair
{
nsCSSProperty
mProperty
;
nsCSSValue
mValue
;
bool
operator
=
=
(
const
PropertyValuePair
&
aOther
)
const
{
return
mProperty
=
=
aOther
.
mProperty
&
&
mValue
=
=
aOther
.
mValue
;
}
}
;
struct
Keyframe
{
Keyframe
(
)
=
default
;
Keyframe
(
const
Keyframe
&
aOther
)
=
default
;
Keyframe
(
Keyframe
&
&
aOther
)
{
*
this
=
Move
(
aOther
)
;
}
Keyframe
&
operator
=
(
const
Keyframe
&
aOther
)
=
default
;
Keyframe
&
operator
=
(
Keyframe
&
&
aOther
)
{
mOffset
=
aOther
.
mOffset
;
mComputedOffset
=
aOther
.
mComputedOffset
;
mTimingFunction
=
Move
(
aOther
.
mTimingFunction
)
;
mPropertyValues
=
Move
(
aOther
.
mPropertyValues
)
;
return
*
this
;
}
Maybe
<
double
>
mOffset
;
static
constexpr
double
kComputedOffsetNotSet
=
-
1
.
0
;
double
mComputedOffset
=
kComputedOffsetNotSet
;
Maybe
<
ComputedTimingFunction
>
mTimingFunction
;
nsTArray
<
PropertyValuePair
>
mPropertyValues
;
}
;
struct
AnimationPropertySegment
{
float
mFromKey
mToKey
;
StyleAnimationValue
mFromValue
mToValue
;
Maybe
<
ComputedTimingFunction
>
mTimingFunction
;
bool
operator
=
=
(
const
AnimationPropertySegment
&
aOther
)
const
{
return
mFromKey
=
=
aOther
.
mFromKey
&
&
mToKey
=
=
aOther
.
mToKey
&
&
mFromValue
=
=
aOther
.
mFromValue
&
&
mToValue
=
=
aOther
.
mToValue
&
&
mTimingFunction
=
=
aOther
.
mTimingFunction
;
}
bool
operator
!
=
(
const
AnimationPropertySegment
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
AnimationProperty
{
nsCSSProperty
mProperty
=
eCSSProperty_UNKNOWN
;
bool
mWinsInCascade
=
false
;
bool
mIsRunningOnCompositor
=
false
;
Maybe
<
AnimationPerformanceWarning
>
mPerformanceWarning
;
InfallibleTArray
<
AnimationPropertySegment
>
mSegments
;
bool
operator
=
=
(
const
AnimationProperty
&
aOther
)
const
{
return
mProperty
=
=
aOther
.
mProperty
&
&
mSegments
=
=
aOther
.
mSegments
;
}
bool
operator
!
=
(
const
AnimationProperty
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
ElementPropertyTransition
;
namespace
dom
{
class
Animation
;
class
KeyframeEffectReadOnly
:
public
AnimationEffectReadOnly
{
public
:
KeyframeEffectReadOnly
(
nsIDocument
*
aDocument
const
Maybe
<
OwningAnimationTarget
>
&
aTarget
const
TimingParams
&
aTiming
const
KeyframeEffectParams
&
aOptions
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED
(
KeyframeEffectReadOnly
AnimationEffectReadOnly
)
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
virtual
ElementPropertyTransition
*
AsTransition
(
)
{
return
nullptr
;
}
virtual
const
ElementPropertyTransition
*
AsTransition
(
)
const
{
return
nullptr
;
}
static
already_AddRefed
<
KeyframeEffectReadOnly
>
Constructor
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
UnrestrictedDoubleOrKeyframeEffectOptions
&
aOptions
ErrorResult
&
aRv
)
;
void
GetTarget
(
Nullable
<
OwningElementOrCSSPseudoElement
>
&
aRv
)
const
;
Maybe
<
NonOwningAnimationTarget
>
GetTarget
(
)
const
{
Maybe
<
NonOwningAnimationTarget
>
result
;
if
(
mTarget
)
{
result
.
emplace
(
*
mTarget
)
;
}
return
result
;
}
void
GetKeyframes
(
JSContext
*
&
aCx
nsTArray
<
JSObject
*
>
&
aResult
ErrorResult
&
aRv
)
;
void
GetProperties
(
nsTArray
<
AnimationPropertyDetails
>
&
aProperties
ErrorResult
&
aRv
)
const
;
IterationCompositeOperation
IterationComposite
(
)
const
;
CompositeOperation
Composite
(
)
const
;
void
GetSpacing
(
nsString
&
aRetVal
)
const
{
mEffectOptions
.
GetSpacingAsString
(
aRetVal
)
;
}
already_AddRefed
<
AnimationEffectTimingReadOnly
>
Timing
(
)
const
override
;
const
TimingParams
&
SpecifiedTiming
(
)
const
{
return
mTiming
-
>
AsTimingParams
(
)
;
}
void
SetSpecifiedTiming
(
const
TimingParams
&
aTiming
)
;
void
NotifyAnimationTimingUpdated
(
)
;
Nullable
<
TimeDuration
>
GetLocalTime
(
)
const
;
static
ComputedTiming
GetComputedTimingAt
(
const
Nullable
<
TimeDuration
>
&
aLocalTime
const
TimingParams
&
aTiming
)
;
ComputedTiming
GetComputedTiming
(
const
TimingParams
*
aTiming
=
nullptr
)
const
{
return
GetComputedTimingAt
(
GetLocalTime
(
)
aTiming
?
*
aTiming
:
SpecifiedTiming
(
)
)
;
}
void
GetComputedTimingAsDict
(
ComputedTimingProperties
&
aRetVal
)
const
override
;
bool
IsInPlay
(
)
const
;
bool
IsCurrent
(
)
const
;
bool
IsInEffect
(
)
const
;
void
SetAnimation
(
Animation
*
aAnimation
)
;
Animation
*
GetAnimation
(
)
const
{
return
mAnimation
;
}
void
SetKeyframes
(
JSContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
ErrorResult
&
aRv
)
;
void
SetKeyframes
(
nsTArray
<
Keyframe
>
&
&
aKeyframes
nsStyleContext
*
aStyleContext
)
;
const
AnimationProperty
*
GetAnimationOfProperty
(
nsCSSProperty
aProperty
)
const
;
bool
HasAnimationOfProperty
(
nsCSSProperty
aProperty
)
const
{
return
GetAnimationOfProperty
(
aProperty
)
!
=
nullptr
;
}
const
InfallibleTArray
<
AnimationProperty
>
&
Properties
(
)
const
{
return
mProperties
;
}
InfallibleTArray
<
AnimationProperty
>
&
Properties
(
)
{
return
mProperties
;
}
void
UpdateProperties
(
nsStyleContext
*
aStyleContext
)
;
void
ComposeStyle
(
RefPtr
<
AnimValuesStyleRule
>
&
aStyleRule
nsCSSPropertySet
&
aSetProperties
)
;
bool
IsRunningOnCompositor
(
)
const
;
void
SetIsRunningOnCompositor
(
nsCSSProperty
aProperty
bool
aIsRunning
)
;
void
ResetIsRunningOnCompositor
(
)
;
bool
ShouldBlockAsyncTransformAnimations
(
const
nsIFrame
*
aFrame
AnimationPerformanceWarning
:
:
Type
&
aPerformanceWarning
)
const
;
nsIDocument
*
GetRenderedDocument
(
)
const
;
nsPresContext
*
GetPresContext
(
)
const
;
nsIPresShell
*
GetPresShell
(
)
const
;
void
SetPerformanceWarning
(
nsCSSProperty
aProperty
const
AnimationPerformanceWarning
&
aWarning
)
;
void
CalculateCumulativeChangeHint
(
nsStyleContext
*
aStyleContext
)
;
bool
CanIgnoreIfNotVisible
(
)
const
;
protected
:
KeyframeEffectReadOnly
(
nsIDocument
*
aDocument
const
Maybe
<
OwningAnimationTarget
>
&
aTarget
AnimationEffectTimingReadOnly
*
aTiming
const
KeyframeEffectParams
&
aOptions
)
;
virtual
~
KeyframeEffectReadOnly
(
)
;
template
<
class
KeyframeEffectType
class
OptionsType
>
static
already_AddRefed
<
KeyframeEffectType
>
ConstructKeyframeEffect
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
OptionsType
&
aOptions
ErrorResult
&
aRv
)
;
void
ResetWinsInCascade
(
)
;
void
UpdateTargetRegistration
(
)
;
void
UnregisterTarget
(
)
;
void
RequestRestyle
(
EffectCompositor
:
:
RestyleType
aRestyleType
)
;
void
MaybeUpdateFrameForCompositor
(
)
;
already_AddRefed
<
nsStyleContext
>
GetTargetStyleContext
(
)
;
Maybe
<
OwningAnimationTarget
>
mTarget
;
RefPtr
<
Animation
>
mAnimation
;
RefPtr
<
AnimationEffectTimingReadOnly
>
mTiming
;
KeyframeEffectParams
mEffectOptions
;
nsTArray
<
Keyframe
>
mKeyframes
;
nsTArray
<
AnimationProperty
>
mProperties
;
Nullable
<
double
>
mProgressOnLastCompose
;
bool
mInEffectOnLastAnimationTimingUpdate
;
private
:
nsChangeHint
mCumulativeChangeHint
;
nsIFrame
*
GetAnimationFrame
(
)
const
;
bool
CanThrottle
(
)
const
;
bool
CanThrottleTransformChanges
(
nsIFrame
&
aFrame
)
const
;
static
bool
CanAnimateTransformOnCompositor
(
const
nsIFrame
*
aFrame
AnimationPerformanceWarning
:
:
Type
&
aPerformanceWarning
)
;
static
bool
IsGeometricProperty
(
const
nsCSSProperty
aProperty
)
;
static
const
TimeDuration
OverflowRegionRefreshInterval
(
)
;
}
;
class
KeyframeEffect
:
public
KeyframeEffectReadOnly
{
public
:
KeyframeEffect
(
nsIDocument
*
aDocument
const
Maybe
<
OwningAnimationTarget
>
&
aTarget
const
TimingParams
&
aTiming
const
KeyframeEffectParams
&
aOptions
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
static
already_AddRefed
<
KeyframeEffect
>
Constructor
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
UnrestrictedDoubleOrKeyframeEffectOptions
&
aOptions
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
KeyframeEffect
>
Constructor
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
UnrestrictedDoubleOrKeyframeAnimationOptions
&
aOptions
ErrorResult
&
aRv
)
;
void
NotifySpecifiedTimingUpdated
(
)
;
void
SetTarget
(
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
)
;
protected
:
~
KeyframeEffect
(
)
override
;
}
;
}
}
#
endif
