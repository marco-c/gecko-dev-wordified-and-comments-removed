#
ifndef
mozilla_dom_KeyframeEffect_h
#
define
mozilla_dom_KeyframeEffect_h
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
LayerAnimationInfo
.
h
"
#
include
"
mozilla
/
StickyTimeDuration
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectReadOnly
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeBinding
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
struct
JSContext
;
class
nsCSSPropertySet
;
class
nsIContent
;
class
nsIFrame
;
namespace
mozilla
{
class
AnimValuesStyleRule
;
namespace
dom
{
struct
ComputedTimingProperties
;
}
struct
AnimationTiming
{
TimeDuration
mIterationDuration
;
TimeDuration
mDelay
;
float
mIterationCount
;
uint8_t
mDirection
;
uint8_t
mFillMode
;
bool
FillsForwards
(
)
const
{
return
mFillMode
=
=
NS_STYLE_ANIMATION_FILL_MODE_BOTH
|
|
mFillMode
=
=
NS_STYLE_ANIMATION_FILL_MODE_FORWARDS
;
}
bool
FillsBackwards
(
)
const
{
return
mFillMode
=
=
NS_STYLE_ANIMATION_FILL_MODE_BOTH
|
|
mFillMode
=
=
NS_STYLE_ANIMATION_FILL_MODE_BACKWARDS
;
}
bool
operator
=
=
(
const
AnimationTiming
&
aOther
)
const
{
return
mIterationDuration
=
=
aOther
.
mIterationDuration
&
&
mDelay
=
=
aOther
.
mDelay
&
&
mIterationCount
=
=
aOther
.
mIterationCount
&
&
mDirection
=
=
aOther
.
mDirection
&
&
mFillMode
=
=
aOther
.
mFillMode
;
}
bool
operator
!
=
(
const
AnimationTiming
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
ComputedTiming
{
StickyTimeDuration
mActiveDuration
;
Nullable
<
double
>
mProgress
;
uint64_t
mCurrentIteration
=
0
;
enum
class
AnimationPhase
{
Null
Before
Active
After
}
;
AnimationPhase
mPhase
=
AnimationPhase
:
:
Null
;
}
;
struct
AnimationPropertySegment
{
float
mFromKey
mToKey
;
StyleAnimationValue
mFromValue
mToValue
;
ComputedTimingFunction
mTimingFunction
;
bool
operator
=
=
(
const
AnimationPropertySegment
&
aOther
)
const
{
return
mFromKey
=
=
aOther
.
mFromKey
&
&
mToKey
=
=
aOther
.
mToKey
&
&
mFromValue
=
=
aOther
.
mFromValue
&
&
mToValue
=
=
aOther
.
mToValue
&
&
mTimingFunction
=
=
aOther
.
mTimingFunction
;
}
bool
operator
!
=
(
const
AnimationPropertySegment
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
AnimationProperty
{
nsCSSProperty
mProperty
;
bool
mWinsInCascade
;
InfallibleTArray
<
AnimationPropertySegment
>
mSegments
;
bool
operator
=
=
(
const
AnimationProperty
&
aOther
)
const
{
return
mProperty
=
=
aOther
.
mProperty
&
&
mSegments
=
=
aOther
.
mSegments
;
}
bool
operator
!
=
(
const
AnimationProperty
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
ElementPropertyTransition
;
namespace
dom
{
class
Animation
;
class
KeyframeEffectReadOnly
:
public
AnimationEffectReadOnly
{
public
:
KeyframeEffectReadOnly
(
nsIDocument
*
aDocument
Element
*
aTarget
nsCSSPseudoElements
:
:
Type
aPseudoType
const
AnimationTiming
&
aTiming
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED
(
KeyframeEffectReadOnly
AnimationEffectReadOnly
)
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
virtual
ElementPropertyTransition
*
AsTransition
(
)
{
return
nullptr
;
}
virtual
const
ElementPropertyTransition
*
AsTransition
(
)
const
{
return
nullptr
;
}
static
already_AddRefed
<
KeyframeEffectReadOnly
>
Constructor
(
const
GlobalObject
&
aGlobal
Element
*
aTarget
const
Optional
<
JS
:
:
Handle
<
JSObject
*
>
>
&
aFrames
const
Optional
<
double
>
&
aOptions
ErrorResult
&
aRv
)
;
Element
*
GetTarget
(
)
const
{
MOZ_ASSERT
(
mPseudoType
=
=
nsCSSPseudoElements
:
:
ePseudo_NotPseudoElement
"
Requesting
the
target
of
a
KeyframeEffect
that
targets
a
"
"
pseudo
-
element
is
not
yet
supported
.
"
)
;
return
mTarget
;
}
void
GetFrames
(
JSContext
*
&
aCx
nsTArray
<
JSObject
*
>
&
aResult
ErrorResult
&
aRv
)
;
void
GetTarget
(
Element
*
&
aTarget
nsCSSPseudoElements
:
:
Type
&
aPseudoType
)
const
{
aTarget
=
mTarget
;
aPseudoType
=
mPseudoType
;
}
const
AnimationTiming
&
Timing
(
)
const
{
return
mTiming
;
}
AnimationTiming
&
Timing
(
)
{
return
mTiming
;
}
void
SetTiming
(
const
AnimationTiming
&
aTiming
)
;
Nullable
<
TimeDuration
>
GetLocalTime
(
)
const
;
static
ComputedTiming
GetComputedTimingAt
(
const
Nullable
<
TimeDuration
>
&
aLocalTime
const
AnimationTiming
&
aTiming
)
;
ComputedTiming
GetComputedTiming
(
const
AnimationTiming
*
aTiming
=
nullptr
)
const
{
return
GetComputedTimingAt
(
GetLocalTime
(
)
aTiming
?
*
aTiming
:
mTiming
)
;
}
void
GetComputedTimingAsDict
(
ComputedTimingProperties
&
aRetVal
)
const
override
;
static
StickyTimeDuration
ActiveDuration
(
const
AnimationTiming
&
aTiming
)
;
bool
IsInPlay
(
)
const
;
bool
IsCurrent
(
)
const
;
bool
IsInEffect
(
)
const
;
void
SetAnimation
(
Animation
*
aAnimation
)
;
const
AnimationProperty
*
GetAnimationOfProperty
(
nsCSSProperty
aProperty
)
const
;
bool
HasAnimationOfProperty
(
nsCSSProperty
aProperty
)
const
{
return
GetAnimationOfProperty
(
aProperty
)
!
=
nullptr
;
}
bool
HasAnimationOfProperties
(
const
nsCSSProperty
*
aProperties
size_t
aPropertyCount
)
const
;
const
InfallibleTArray
<
AnimationProperty
>
&
Properties
(
)
const
{
return
mProperties
;
}
InfallibleTArray
<
AnimationProperty
>
&
Properties
(
)
{
return
mProperties
;
}
void
ComposeStyle
(
RefPtr
<
AnimValuesStyleRule
>
&
aStyleRule
nsCSSPropertySet
&
aSetProperties
)
;
bool
IsRunningOnCompositor
(
)
const
;
void
SetIsRunningOnCompositor
(
nsCSSProperty
aProperty
bool
aIsRunning
)
;
static
bool
CanAnimateTransformOnCompositor
(
const
nsIFrame
*
aFrame
const
nsIContent
*
aContent
)
;
static
bool
IsGeometricProperty
(
const
nsCSSProperty
aProperty
)
;
protected
:
virtual
~
KeyframeEffectReadOnly
(
)
;
void
ResetIsRunningOnCompositor
(
)
;
static
AnimationTiming
ConvertKeyframeEffectOptions
(
const
Optional
<
double
>
&
aOptions
)
;
static
void
BuildAnimationPropertyList
(
JSContext
*
aCx
Element
*
aTarget
const
Optional
<
JS
:
:
Handle
<
JSObject
*
>
>
&
aFrames
InfallibleTArray
<
AnimationProperty
>
&
aResult
ErrorResult
&
aRv
)
;
nsCOMPtr
<
Element
>
mTarget
;
RefPtr
<
Animation
>
mAnimation
;
AnimationTiming
mTiming
;
nsCSSPseudoElements
:
:
Type
mPseudoType
;
InfallibleTArray
<
AnimationProperty
>
mProperties
;
bool
mIsPropertyRunningOnCompositor
[
LayerAnimationInfo
:
:
kRecords
]
;
private
:
nsIFrame
*
GetAnimationFrame
(
)
const
;
}
;
}
}
#
endif
