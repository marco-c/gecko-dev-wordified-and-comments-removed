#
include
"
PendingAnimationTracker
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffect
.
h
"
#
include
"
mozilla
/
dom
/
AnimationTimeline
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsTransitionManager
.
h
"
using
mozilla
:
:
dom
:
:
Nullable
;
namespace
mozilla
{
NS_IMPL_CYCLE_COLLECTION
(
PendingAnimationTracker
mPlayPendingSet
mPausePendingSet
mDocument
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
PendingAnimationTracker
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
PendingAnimationTracker
Release
)
void
PendingAnimationTracker
:
:
AddPending
(
dom
:
:
Animation
&
aAnimation
AnimationSet
&
aSet
)
{
aSet
.
PutEntry
(
&
aAnimation
)
;
EnsurePaintIsScheduled
(
)
;
}
void
PendingAnimationTracker
:
:
RemovePending
(
dom
:
:
Animation
&
aAnimation
AnimationSet
&
aSet
)
{
aSet
.
RemoveEntry
(
&
aAnimation
)
;
}
bool
PendingAnimationTracker
:
:
IsWaiting
(
const
dom
:
:
Animation
&
aAnimation
const
AnimationSet
&
aSet
)
const
{
return
aSet
.
Contains
(
const_cast
<
dom
:
:
Animation
*
>
(
&
aAnimation
)
)
;
}
void
PendingAnimationTracker
:
:
TriggerPendingAnimationsOnNextTick
(
const
TimeStamp
&
aReadyTime
)
{
auto
triggerAnimationsAtReadyTime
=
[
aReadyTime
]
(
AnimationSet
&
aAnimationSet
)
{
for
(
auto
iter
=
aAnimationSet
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
dom
:
:
Animation
*
animation
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
dom
:
:
AnimationTimeline
*
timeline
=
animation
-
>
GetTimeline
(
)
;
if
(
!
timeline
)
{
iter
.
Remove
(
)
;
continue
;
}
if
(
!
timeline
-
>
TracksWallclockTime
(
)
)
{
continue
;
}
Nullable
<
TimeDuration
>
readyTime
=
timeline
-
>
ToTimelineTime
(
aReadyTime
)
;
animation
-
>
TriggerOnNextTick
(
readyTime
)
;
iter
.
Remove
(
)
;
}
}
;
triggerAnimationsAtReadyTime
(
mPlayPendingSet
)
;
triggerAnimationsAtReadyTime
(
mPausePendingSet
)
;
mHasPlayPendingGeometricAnimations
=
mPlayPendingSet
.
Count
(
)
?
CheckState
:
:
Indeterminate
:
CheckState
:
:
Absent
;
}
void
PendingAnimationTracker
:
:
TriggerPendingAnimationsNow
(
)
{
auto
triggerAndClearAnimations
=
[
]
(
AnimationSet
&
aAnimationSet
)
{
for
(
auto
iter
=
aAnimationSet
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
TriggerNow
(
)
;
}
aAnimationSet
.
Clear
(
)
;
}
;
triggerAndClearAnimations
(
mPlayPendingSet
)
;
triggerAndClearAnimations
(
mPausePendingSet
)
;
mHasPlayPendingGeometricAnimations
=
CheckState
:
:
Absent
;
}
static
bool
IsTransition
(
const
dom
:
:
Animation
&
aAnimation
)
{
const
dom
:
:
CSSTransition
*
transition
=
aAnimation
.
AsCSSTransition
(
)
;
return
transition
&
&
transition
-
>
IsTiedToMarkup
(
)
;
}
void
PendingAnimationTracker
:
:
MarkAnimationsThatMightNeedSynchronization
(
)
{
if
(
mHasPlayPendingGeometricAnimations
!
=
CheckState
:
:
Indeterminate
)
{
return
;
}
mHasPlayPendingGeometricAnimations
=
CheckState
:
:
Absent
;
for
(
auto
iter
=
mPlayPendingSet
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
animation
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
if
(
animation
-
>
GetEffect
(
)
&
&
animation
-
>
GetEffect
(
)
-
>
AffectsGeometry
(
)
)
{
mHasPlayPendingGeometricAnimations
&
=
~
CheckState
:
:
Absent
;
mHasPlayPendingGeometricAnimations
|
=
IsTransition
(
*
animation
)
?
CheckState
:
:
TransitionsPresent
:
CheckState
:
:
AnimationsPresent
;
if
(
mHasPlayPendingGeometricAnimations
=
=
(
CheckState
:
:
TransitionsPresent
|
CheckState
:
:
AnimationsPresent
)
)
{
break
;
}
}
}
if
(
mHasPlayPendingGeometricAnimations
=
=
CheckState
:
:
Absent
)
{
return
;
}
for
(
auto
iter
=
mPlayPendingSet
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
animation
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
bool
isTransition
=
IsTransition
(
*
animation
)
;
if
(
(
isTransition
&
&
mHasPlayPendingGeometricAnimations
&
CheckState
:
:
TransitionsPresent
)
|
|
(
!
isTransition
&
&
mHasPlayPendingGeometricAnimations
&
CheckState
:
:
AnimationsPresent
)
)
{
animation
-
>
NotifyGeometricAnimationsStartingThisFrame
(
)
;
}
}
}
void
PendingAnimationTracker
:
:
EnsurePaintIsScheduled
(
)
{
if
(
!
mDocument
)
{
return
;
}
PresShell
*
presShell
=
mDocument
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
;
}
rootFrame
-
>
SchedulePaintWithoutInvalidatingObservers
(
)
;
}
}
