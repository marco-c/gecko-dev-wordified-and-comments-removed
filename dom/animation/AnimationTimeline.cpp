#
include
"
AnimationTimeline
.
h
"
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
namespace
mozilla
:
:
dom
{
AnimationTimeline
:
:
~
AnimationTimeline
(
)
{
mAnimationOrder
.
clear
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
AnimationTimeline
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
AnimationTimeline
)
tmp
-
>
mAnimationOrder
.
clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mWindow
mAnimations
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
AnimationTimeline
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mWindow
mAnimations
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
AnimationTimeline
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
AnimationTimeline
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
AnimationTimeline
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
bool
AnimationTimeline
:
:
Tick
(
)
{
bool
needsTicks
=
false
;
nsTArray
<
Animation
*
>
animationsToRemove
;
for
(
Animation
*
animation
=
mAnimationOrder
.
getFirst
(
)
;
animation
;
animation
=
static_cast
<
LinkedListElement
<
Animation
>
*
>
(
animation
)
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
!
animation
-
>
IsHiddenByContentVisibility
(
)
)
;
if
(
animation
-
>
GetTimeline
(
)
!
=
this
)
{
MOZ_ASSERT
(
!
animation
-
>
GetTimeline
(
)
)
;
animationsToRemove
.
AppendElement
(
animation
)
;
continue
;
}
needsTicks
|
=
animation
-
>
NeedsTicks
(
)
;
animation
-
>
Tick
(
)
;
if
(
!
animation
-
>
NeedsTicks
(
)
)
{
animationsToRemove
.
AppendElement
(
animation
)
;
}
}
for
(
Animation
*
animation
:
animationsToRemove
)
{
RemoveAnimation
(
animation
)
;
}
return
needsTicks
;
}
void
AnimationTimeline
:
:
NotifyAnimationUpdated
(
Animation
&
aAnimation
)
{
if
(
mAnimations
.
EnsureInserted
(
&
aAnimation
)
)
{
if
(
aAnimation
.
GetTimeline
(
)
&
&
aAnimation
.
GetTimeline
(
)
!
=
this
)
{
aAnimation
.
GetTimeline
(
)
-
>
RemoveAnimation
(
&
aAnimation
)
;
}
if
(
!
aAnimation
.
IsHiddenByContentVisibility
(
)
)
{
mAnimationOrder
.
insertBack
(
&
aAnimation
)
;
}
}
}
void
AnimationTimeline
:
:
RemoveAnimation
(
Animation
*
aAnimation
)
{
MOZ_ASSERT
(
!
aAnimation
-
>
GetTimeline
(
)
|
|
aAnimation
-
>
GetTimeline
(
)
=
=
this
)
;
if
(
static_cast
<
LinkedListElement
<
Animation
>
*
>
(
aAnimation
)
-
>
isInList
(
)
)
{
static_cast
<
LinkedListElement
<
Animation
>
*
>
(
aAnimation
)
-
>
remove
(
)
;
}
mAnimations
.
Remove
(
aAnimation
)
;
}
void
AnimationTimeline
:
:
NotifyAnimationContentVisibilityChanged
(
Animation
*
aAnimation
bool
visible
)
{
bool
inList
=
static_cast
<
LinkedListElement
<
Animation
>
*
>
(
aAnimation
)
-
>
isInList
(
)
;
if
(
visible
&
&
!
inList
)
{
mAnimationOrder
.
insertBack
(
aAnimation
)
;
}
else
if
(
!
visible
&
&
inList
)
{
static_cast
<
LinkedListElement
<
Animation
>
*
>
(
aAnimation
)
-
>
remove
(
)
;
}
}
}
