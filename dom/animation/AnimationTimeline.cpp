#
include
"
AnimationTimeline
.
h
"
#
include
"
mozilla
/
AnimationComparator
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
AnimationTimeline
mWindow
mAnimationOrder
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
AnimationTimeline
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
AnimationTimeline
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
AnimationTimeline
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
void
AnimationTimeline
:
:
GetAnimations
(
AnimationSequence
&
aAnimations
)
{
nsCOMPtr
<
nsPIDOMWindow
>
window
=
do_QueryInterface
(
mWindow
)
;
if
(
mWindow
)
{
nsIDocument
*
doc
=
window
-
>
GetDoc
(
)
;
if
(
doc
)
{
doc
-
>
FlushPendingNotifications
(
Flush_Style
)
;
}
}
aAnimations
.
SetCapacity
(
mAnimationOrder
.
Length
(
)
)
;
for
(
Animation
*
animation
:
mAnimationOrder
)
{
if
(
!
animation
-
>
IsRelevant
(
)
|
|
animation
-
>
GetTimeline
(
)
!
=
this
)
{
continue
;
}
Element
*
target
;
nsCSSPseudoElements
:
:
Type
pseudoType
;
animation
-
>
GetEffect
(
)
-
>
GetTarget
(
target
pseudoType
)
;
if
(
pseudoType
=
=
nsCSSPseudoElements
:
:
ePseudo_NotPseudoElement
)
{
aAnimations
.
AppendElement
(
animation
)
;
}
}
aAnimations
.
Sort
(
AnimationPtrComparator
<
nsRefPtr
<
Animation
>
>
(
)
)
;
}
void
AnimationTimeline
:
:
NotifyAnimationUpdated
(
Animation
&
aAnimation
)
{
if
(
mAnimations
.
Contains
(
&
aAnimation
)
)
{
return
;
}
mAnimations
.
PutEntry
(
&
aAnimation
)
;
mAnimationOrder
.
AppendElement
(
&
aAnimation
)
;
}
}
}
