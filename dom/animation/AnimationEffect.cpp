#
include
"
mozilla
/
dom
/
AnimationEffect
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectBinding
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
mozilla
/
dom
/
MutationObservers
.
h
"
#
include
"
mozilla
/
AnimationUtils
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
AnimationEffect
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
AnimationEffect
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocument
mAnimation
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
AnimationEffect
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocument
mAnimation
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE
(
AnimationEffect
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
AnimationEffect
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
AnimationEffect
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
AnimationEffect
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
AnimationEffect
:
:
AnimationEffect
(
Document
*
aDocument
TimingParams
&
&
aTiming
)
:
mDocument
(
aDocument
)
mTiming
(
std
:
:
move
(
aTiming
)
)
{
}
AnimationEffect
:
:
~
AnimationEffect
(
)
=
default
;
bool
AnimationEffect
:
:
IsCurrent
(
)
const
{
if
(
!
mAnimation
|
|
mAnimation
-
>
PlayState
(
)
=
=
AnimationPlayState
:
:
Finished
)
{
return
false
;
}
ComputedTiming
computedTiming
=
GetComputedTiming
(
)
;
if
(
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Active
)
{
return
true
;
}
return
(
mAnimation
-
>
PlaybackRate
(
)
>
0
&
&
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Before
)
|
|
(
mAnimation
-
>
PlaybackRate
(
)
<
0
&
&
computedTiming
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
After
)
;
}
bool
AnimationEffect
:
:
IsInEffect
(
)
const
{
ComputedTiming
computedTiming
=
GetComputedTiming
(
)
;
return
!
computedTiming
.
mProgress
.
IsNull
(
)
;
}
void
AnimationEffect
:
:
SetSpecifiedTiming
(
TimingParams
&
&
aTiming
)
{
if
(
mTiming
=
=
aTiming
)
{
return
;
}
mTiming
=
aTiming
;
if
(
mAnimation
)
{
Maybe
<
nsAutoAnimationMutationBatch
>
mb
;
if
(
AsKeyframeEffect
(
)
&
&
AsKeyframeEffect
(
)
-
>
GetAnimationTarget
(
)
)
{
mb
.
emplace
(
AsKeyframeEffect
(
)
-
>
GetAnimationTarget
(
)
.
mElement
-
>
OwnerDoc
(
)
)
;
}
mAnimation
-
>
NotifyEffectTimingUpdated
(
)
;
if
(
mAnimation
-
>
IsRelevant
(
)
)
{
MutationObservers
:
:
NotifyAnimationChanged
(
mAnimation
)
;
}
if
(
AsKeyframeEffect
(
)
)
{
AsKeyframeEffect
(
)
-
>
RequestRestyle
(
EffectCompositor
:
:
RestyleType
:
:
Layer
)
;
}
}
}
ComputedTiming
AnimationEffect
:
:
GetComputedTimingAt
(
const
Nullable
<
TimeDuration
>
&
aLocalTime
const
TimingParams
&
aTiming
double
aPlaybackRate
)
{
static
const
StickyTimeDuration
zeroDuration
;
ComputedTiming
result
;
if
(
aTiming
.
Duration
(
)
)
{
MOZ_ASSERT
(
aTiming
.
Duration
(
)
.
ref
(
)
>
=
zeroDuration
"
Iteration
duration
should
be
positive
"
)
;
result
.
mDuration
=
aTiming
.
Duration
(
)
.
ref
(
)
;
}
MOZ_ASSERT
(
aTiming
.
Iterations
(
)
>
=
0
.
0
&
&
!
IsNaN
(
aTiming
.
Iterations
(
)
)
"
mIterations
should
be
nonnegative
&
finite
as
ensured
by
"
"
ValidateIterations
or
CSSParser
"
)
;
result
.
mIterations
=
aTiming
.
Iterations
(
)
;
MOZ_ASSERT
(
aTiming
.
IterationStart
(
)
>
=
0
.
0
"
mIterationStart
should
be
nonnegative
as
ensured
by
"
"
ValidateIterationStart
"
)
;
result
.
mIterationStart
=
aTiming
.
IterationStart
(
)
;
result
.
mActiveDuration
=
aTiming
.
ActiveDuration
(
)
;
result
.
mEndTime
=
aTiming
.
EndTime
(
)
;
result
.
mFill
=
aTiming
.
Fill
(
)
=
=
dom
:
:
FillMode
:
:
Auto
?
dom
:
:
FillMode
:
:
None
:
aTiming
.
Fill
(
)
;
if
(
aLocalTime
.
IsNull
(
)
)
{
return
result
;
}
const
TimeDuration
&
localTime
=
aLocalTime
.
Value
(
)
;
StickyTimeDuration
beforeActiveBoundary
=
std
:
:
max
(
std
:
:
min
(
StickyTimeDuration
(
aTiming
.
Delay
(
)
)
result
.
mEndTime
)
zeroDuration
)
;
StickyTimeDuration
activeAfterBoundary
=
std
:
:
max
(
std
:
:
min
(
StickyTimeDuration
(
aTiming
.
Delay
(
)
+
result
.
mActiveDuration
)
result
.
mEndTime
)
zeroDuration
)
;
if
(
localTime
>
activeAfterBoundary
|
|
(
aPlaybackRate
>
=
0
&
&
localTime
=
=
activeAfterBoundary
)
)
{
result
.
mPhase
=
ComputedTiming
:
:
AnimationPhase
:
:
After
;
if
(
!
result
.
FillsForwards
(
)
)
{
return
result
;
}
result
.
mActiveTime
=
std
:
:
max
(
std
:
:
min
(
StickyTimeDuration
(
localTime
-
aTiming
.
Delay
(
)
)
result
.
mActiveDuration
)
zeroDuration
)
;
}
else
if
(
localTime
<
beforeActiveBoundary
|
|
(
aPlaybackRate
<
0
&
&
localTime
=
=
beforeActiveBoundary
)
)
{
result
.
mPhase
=
ComputedTiming
:
:
AnimationPhase
:
:
Before
;
if
(
!
result
.
FillsBackwards
(
)
)
{
return
result
;
}
result
.
mActiveTime
=
std
:
:
max
(
StickyTimeDuration
(
localTime
-
aTiming
.
Delay
(
)
)
zeroDuration
)
;
}
else
{
MOZ_ASSERT
(
result
.
mActiveDuration
"
How
can
we
be
in
the
middle
of
a
zero
-
duration
interval
?
"
)
;
result
.
mPhase
=
ComputedTiming
:
:
AnimationPhase
:
:
Active
;
result
.
mActiveTime
=
localTime
-
aTiming
.
Delay
(
)
;
}
double
overallProgress
;
if
(
!
result
.
mDuration
)
{
overallProgress
=
result
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Before
?
0
.
0
:
result
.
mIterations
;
}
else
{
overallProgress
=
result
.
mActiveTime
/
result
.
mDuration
;
}
if
(
IsFinite
(
overallProgress
)
)
{
overallProgress
+
=
result
.
mIterationStart
;
}
result
.
mCurrentIteration
=
(
result
.
mIterations
>
=
double
(
UINT64_MAX
)
&
&
result
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
After
)
|
|
overallProgress
>
=
double
(
UINT64_MAX
)
?
UINT64_MAX
:
static_cast
<
uint64_t
>
(
overallProgress
)
;
double
progress
=
IsFinite
(
overallProgress
)
?
fmod
(
overallProgress
1
.
0
)
:
fmod
(
result
.
mIterationStart
1
.
0
)
;
if
(
progress
=
=
0
.
0
&
&
(
result
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
After
|
|
result
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Active
)
&
&
result
.
mActiveTime
=
=
result
.
mActiveDuration
&
&
result
.
mIterations
!
=
0
.
0
)
{
MOZ_ASSERT
(
result
.
mCurrentIteration
!
=
0
"
Should
not
have
zero
current
iteration
"
)
;
progress
=
1
.
0
;
if
(
result
.
mCurrentIteration
!
=
UINT64_MAX
)
{
result
.
mCurrentIteration
-
-
;
}
}
bool
thisIterationReverse
=
false
;
switch
(
aTiming
.
Direction
(
)
)
{
case
PlaybackDirection
:
:
Normal
:
thisIterationReverse
=
false
;
break
;
case
PlaybackDirection
:
:
Reverse
:
thisIterationReverse
=
true
;
break
;
case
PlaybackDirection
:
:
Alternate
:
thisIterationReverse
=
(
result
.
mCurrentIteration
&
1
)
=
=
1
;
break
;
case
PlaybackDirection
:
:
Alternate_reverse
:
thisIterationReverse
=
(
result
.
mCurrentIteration
&
1
)
=
=
0
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
PlaybackDirection
type
"
)
;
}
if
(
thisIterationReverse
)
{
progress
=
1
.
0
-
progress
;
}
if
(
(
result
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
After
&
&
thisIterationReverse
)
|
|
(
result
.
mPhase
=
=
ComputedTiming
:
:
AnimationPhase
:
:
Before
&
&
!
thisIterationReverse
)
)
{
result
.
mBeforeFlag
=
ComputedTimingFunction
:
:
BeforeFlag
:
:
Set
;
}
if
(
aTiming
.
TimingFunction
(
)
)
{
progress
=
aTiming
.
TimingFunction
(
)
-
>
GetValue
(
progress
result
.
mBeforeFlag
)
;
}
MOZ_ASSERT
(
IsFinite
(
progress
)
"
Progress
value
should
be
finite
"
)
;
result
.
mProgress
.
SetValue
(
progress
)
;
return
result
;
}
ComputedTiming
AnimationEffect
:
:
GetComputedTiming
(
const
TimingParams
*
aTiming
)
const
{
double
playbackRate
=
mAnimation
?
mAnimation
-
>
PlaybackRate
(
)
:
1
;
return
GetComputedTimingAt
(
GetLocalTime
(
)
aTiming
?
*
aTiming
:
SpecifiedTiming
(
)
playbackRate
)
;
}
static
void
GetEffectTimingDictionary
(
const
TimingParams
&
aTiming
EffectTiming
&
aRetVal
)
{
aRetVal
.
mDelay
=
aTiming
.
Delay
(
)
.
ToMilliseconds
(
)
;
aRetVal
.
mEndDelay
=
aTiming
.
EndDelay
(
)
.
ToMilliseconds
(
)
;
aRetVal
.
mFill
=
aTiming
.
Fill
(
)
;
aRetVal
.
mIterationStart
=
aTiming
.
IterationStart
(
)
;
aRetVal
.
mIterations
=
aTiming
.
Iterations
(
)
;
if
(
aTiming
.
Duration
(
)
)
{
aRetVal
.
mDuration
.
SetAsUnrestrictedDouble
(
)
=
aTiming
.
Duration
(
)
-
>
ToMilliseconds
(
)
;
}
aRetVal
.
mDirection
=
aTiming
.
Direction
(
)
;
if
(
aTiming
.
TimingFunction
(
)
)
{
aRetVal
.
mEasing
.
Truncate
(
)
;
aTiming
.
TimingFunction
(
)
-
>
AppendToString
(
aRetVal
.
mEasing
)
;
}
}
void
AnimationEffect
:
:
GetTiming
(
EffectTiming
&
aRetVal
)
const
{
GetEffectTimingDictionary
(
SpecifiedTiming
(
)
aRetVal
)
;
}
void
AnimationEffect
:
:
GetComputedTimingAsDict
(
ComputedEffectTiming
&
aRetVal
)
const
{
GetEffectTimingDictionary
(
SpecifiedTiming
(
)
aRetVal
)
;
double
playbackRate
=
mAnimation
?
mAnimation
-
>
PlaybackRate
(
)
:
1
;
const
Nullable
<
TimeDuration
>
currentTime
=
GetLocalTime
(
)
;
ComputedTiming
computedTiming
=
GetComputedTimingAt
(
currentTime
SpecifiedTiming
(
)
playbackRate
)
;
aRetVal
.
mDuration
.
SetAsUnrestrictedDouble
(
)
=
computedTiming
.
mDuration
.
ToMilliseconds
(
)
;
aRetVal
.
mFill
=
computedTiming
.
mFill
;
aRetVal
.
mActiveDuration
=
computedTiming
.
mActiveDuration
.
ToMilliseconds
(
)
;
aRetVal
.
mEndTime
=
computedTiming
.
mEndTime
.
ToMilliseconds
(
)
;
aRetVal
.
mLocalTime
=
AnimationUtils
:
:
TimeDurationToDouble
(
currentTime
)
;
aRetVal
.
mProgress
=
computedTiming
.
mProgress
;
if
(
!
aRetVal
.
mProgress
.
IsNull
(
)
)
{
double
iteration
=
computedTiming
.
mCurrentIteration
=
=
UINT64_MAX
?
PositiveInfinity
<
double
>
(
)
:
static_cast
<
double
>
(
computedTiming
.
mCurrentIteration
)
;
aRetVal
.
mCurrentIteration
.
SetValue
(
iteration
)
;
}
}
void
AnimationEffect
:
:
UpdateTiming
(
const
OptionalEffectTiming
&
aTiming
ErrorResult
&
aRv
)
{
TimingParams
timing
=
TimingParams
:
:
MergeOptionalEffectTiming
(
mTiming
aTiming
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SetSpecifiedTiming
(
std
:
:
move
(
timing
)
)
;
}
Nullable
<
TimeDuration
>
AnimationEffect
:
:
GetLocalTime
(
)
const
{
Nullable
<
TimeDuration
>
result
;
if
(
mAnimation
)
{
result
=
mAnimation
-
>
GetCurrentTimeAsDuration
(
)
;
}
return
result
;
}
}
