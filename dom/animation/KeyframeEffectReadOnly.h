#
ifndef
mozilla_dom_KeyframeEffectReadOnly_h
#
define
mozilla_dom_KeyframeEffectReadOnly_h
#
include
"
nsChangeHint
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
include
"
nsCSSPropertyIDSet
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
AnimationPerformanceWarning
.
h
"
#
include
"
mozilla
/
AnimationPropertySegment
.
h
"
#
include
"
mozilla
/
AnimationTarget
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
Keyframe
.
h
"
#
include
"
mozilla
/
KeyframeEffectParams
.
h
"
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectReadOnly
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
struct
JSContext
;
class
JSObject
;
class
nsIContent
;
class
nsIDocument
;
class
nsIFrame
;
class
nsIPresShell
;
namespace
mozilla
{
class
AnimValuesStyleRule
;
enum
class
CSSPseudoElementType
:
uint8_t
;
class
ErrorResult
;
struct
AnimationRule
;
struct
TimingParams
;
class
EffectSet
;
class
ServoStyleContext
;
class
GeckoStyleContext
;
namespace
dom
{
class
ElementOrCSSPseudoElement
;
class
GlobalObject
;
class
OwningElementOrCSSPseudoElement
;
class
UnrestrictedDoubleOrKeyframeAnimationOptions
;
class
UnrestrictedDoubleOrKeyframeEffectOptions
;
enum
class
IterationCompositeOperation
:
uint8_t
;
enum
class
CompositeOperation
:
uint8_t
;
struct
AnimationPropertyDetails
;
}
struct
AnimationProperty
{
nsCSSPropertyID
mProperty
=
eCSSProperty_UNKNOWN
;
bool
mIsRunningOnCompositor
=
false
;
Maybe
<
AnimationPerformanceWarning
>
mPerformanceWarning
;
InfallibleTArray
<
AnimationPropertySegment
>
mSegments
;
AnimationProperty
(
)
=
default
;
AnimationProperty
(
const
AnimationProperty
&
aOther
)
:
mProperty
(
aOther
.
mProperty
)
mSegments
(
aOther
.
mSegments
)
{
}
AnimationProperty
&
operator
=
(
const
AnimationProperty
&
aOther
)
{
mProperty
=
aOther
.
mProperty
;
mSegments
=
aOther
.
mSegments
;
return
*
this
;
}
bool
operator
=
=
(
const
AnimationProperty
&
aOther
)
const
{
return
mProperty
=
=
aOther
.
mProperty
&
&
mSegments
=
=
aOther
.
mSegments
;
}
bool
operator
!
=
(
const
AnimationProperty
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
ElementPropertyTransition
;
namespace
dom
{
class
Animation
;
class
KeyframeEffectReadOnly
:
public
AnimationEffectReadOnly
{
public
:
KeyframeEffectReadOnly
(
nsIDocument
*
aDocument
const
Maybe
<
OwningAnimationTarget
>
&
aTarget
const
TimingParams
&
aTiming
const
KeyframeEffectParams
&
aOptions
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED
(
KeyframeEffectReadOnly
AnimationEffectReadOnly
)
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
KeyframeEffectReadOnly
*
AsKeyframeEffect
(
)
override
{
return
this
;
}
static
already_AddRefed
<
KeyframeEffectReadOnly
>
Constructor
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
UnrestrictedDoubleOrKeyframeEffectOptions
&
aOptions
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
KeyframeEffectReadOnly
>
Constructor
(
const
GlobalObject
&
aGlobal
KeyframeEffectReadOnly
&
aSource
ErrorResult
&
aRv
)
;
void
GetTarget
(
Nullable
<
OwningElementOrCSSPseudoElement
>
&
aRv
)
const
;
Maybe
<
NonOwningAnimationTarget
>
GetTarget
(
)
const
{
Maybe
<
NonOwningAnimationTarget
>
result
;
if
(
mTarget
)
{
result
.
emplace
(
*
mTarget
)
;
}
return
result
;
}
void
GetKeyframes
(
JSContext
*
&
aCx
nsTArray
<
JSObject
*
>
&
aResult
ErrorResult
&
aRv
)
;
void
GetProperties
(
nsTArray
<
AnimationPropertyDetails
>
&
aProperties
ErrorResult
&
aRv
)
const
;
IterationCompositeOperation
IterationComposite
(
)
const
;
CompositeOperation
Composite
(
)
const
;
void
NotifyAnimationTimingUpdated
(
)
;
void
RequestRestyle
(
EffectCompositor
:
:
RestyleType
aRestyleType
)
;
void
SetAnimation
(
Animation
*
aAnimation
)
override
;
void
SetKeyframes
(
JSContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
ErrorResult
&
aRv
)
;
#
ifdef
MOZ_OLD_STYLE
void
SetKeyframes
(
nsTArray
<
Keyframe
>
&
&
aKeyframes
GeckoStyleContext
*
aStyleContext
)
;
#
endif
void
SetKeyframes
(
nsTArray
<
Keyframe
>
&
&
aKeyframes
const
ServoStyleContext
*
aComputedValues
)
;
bool
HasAnimationOfProperty
(
nsCSSPropertyID
aProperty
)
const
;
bool
HasEffectiveAnimationOfProperty
(
nsCSSPropertyID
aProperty
)
const
{
return
GetEffectiveAnimationOfProperty
(
aProperty
)
!
=
nullptr
;
}
const
AnimationProperty
*
GetEffectiveAnimationOfProperty
(
nsCSSPropertyID
aProperty
)
const
;
const
InfallibleTArray
<
AnimationProperty
>
&
Properties
(
)
const
{
return
mProperties
;
}
void
UpdateProperties
(
nsStyleContext
*
aStyleContext
)
;
void
UpdateProperties
(
const
ServoStyleContext
*
aComputedValues
)
;
void
WillComposeStyle
(
)
;
template
<
typename
ComposeAnimationResult
>
void
ComposeStyle
(
ComposeAnimationResult
&
&
aRestultContainer
const
nsCSSPropertyIDSet
&
aPropertiesToSkip
)
;
#
ifdef
MOZ_OLD_STYLE
static
StyleAnimationValue
CompositeValue
(
nsCSSPropertyID
aProperty
const
StyleAnimationValue
&
aValueToComposite
const
StyleAnimationValue
&
aUnderlyingValue
CompositeOperation
aCompositeOperation
)
;
#
endif
bool
IsRunningOnCompositor
(
)
const
;
void
SetIsRunningOnCompositor
(
nsCSSPropertyID
aProperty
bool
aIsRunning
)
;
void
ResetIsRunningOnCompositor
(
)
;
bool
ShouldBlockAsyncTransformAnimations
(
const
nsIFrame
*
aFrame
AnimationPerformanceWarning
:
:
Type
&
aPerformanceWarning
)
const
;
bool
HasGeometricProperties
(
)
const
;
bool
AffectsGeometry
(
)
const
override
{
return
GetTarget
(
)
&
&
HasGeometricProperties
(
)
;
}
nsIDocument
*
GetRenderedDocument
(
)
const
;
nsIPresShell
*
GetPresShell
(
)
const
;
void
SetPerformanceWarning
(
nsCSSPropertyID
aProperty
const
AnimationPerformanceWarning
&
aWarning
)
;
template
<
typename
StyleType
>
void
CalculateCumulativeChangeHint
(
StyleType
*
aStyleContext
)
;
bool
CanIgnoreIfNotVisible
(
)
const
;
bool
ContainsAnimatedScale
(
const
nsIFrame
*
aFrame
)
const
;
AnimationValue
BaseStyle
(
nsCSSPropertyID
aProperty
)
const
{
AnimationValue
result
;
bool
hasProperty
=
false
;
if
(
mDocument
-
>
IsStyledByServo
(
)
)
{
result
.
mServo
=
mBaseStyleValuesForServo
.
GetWeak
(
aProperty
&
hasProperty
)
;
}
else
{
#
ifdef
MOZ_OLD_STYLE
hasProperty
=
mBaseStyleValues
.
Get
(
aProperty
&
result
.
mGecko
)
;
#
else
MOZ_CRASH
(
"
old
style
system
disabled
"
)
;
#
endif
}
MOZ_ASSERT
(
hasProperty
|
|
result
.
IsNull
(
)
)
;
return
result
;
}
protected
:
KeyframeEffectReadOnly
(
nsIDocument
*
aDocument
const
Maybe
<
OwningAnimationTarget
>
&
aTarget
AnimationEffectTimingReadOnly
*
aTiming
const
KeyframeEffectParams
&
aOptions
)
;
~
KeyframeEffectReadOnly
(
)
override
=
default
;
static
Maybe
<
OwningAnimationTarget
>
ConvertTarget
(
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
)
;
template
<
class
KeyframeEffectType
class
OptionsType
>
static
already_AddRefed
<
KeyframeEffectType
>
ConstructKeyframeEffect
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
OptionsType
&
aOptions
ErrorResult
&
aRv
)
;
template
<
class
KeyframeEffectType
>
static
already_AddRefed
<
KeyframeEffectType
>
ConstructKeyframeEffect
(
const
GlobalObject
&
aGlobal
KeyframeEffectReadOnly
&
aSource
ErrorResult
&
aRv
)
;
template
<
typename
StyleType
>
nsTArray
<
AnimationProperty
>
BuildProperties
(
StyleType
*
aStyle
)
;
void
UpdateTargetRegistration
(
)
;
void
UnregisterTarget
(
)
;
void
MaybeUpdateFrameForCompositor
(
)
;
already_AddRefed
<
nsStyleContext
>
GetTargetStyleContext
(
)
;
void
MarkCascadeNeedsUpdate
(
)
;
#
ifdef
MOZ_OLD_STYLE
StyleAnimationValue
CompositeValue
(
nsCSSPropertyID
aProperty
const
RefPtr
<
AnimValuesStyleRule
>
&
aAnimationRule
const
StyleAnimationValue
&
aValueToComposite
CompositeOperation
aCompositeOperation
)
;
StyleAnimationValue
GetUnderlyingStyle
(
nsCSSPropertyID
aProperty
const
RefPtr
<
AnimValuesStyleRule
>
&
aAnimationRule
)
;
void
EnsureBaseStyles
(
GeckoStyleContext
*
aStyleContext
const
nsTArray
<
AnimationProperty
>
&
aProperties
)
;
#
endif
void
EnsureBaseStyles
(
const
ServoStyleContext
*
aComputedValues
const
nsTArray
<
AnimationProperty
>
&
aProperties
)
;
#
ifdef
MOZ_OLD_STYLE
void
EnsureBaseStyle
(
nsCSSPropertyID
aProperty
GeckoStyleContext
*
aStyleContext
RefPtr
<
GeckoStyleContext
>
&
aCachedBaseStyleContext
)
;
#
endif
void
EnsureBaseStyle
(
const
AnimationProperty
&
aProperty
nsPresContext
*
aPresContext
const
ServoStyleContext
*
aComputedValues
RefPtr
<
mozilla
:
:
ServoStyleContext
>
&
aBaseComputedValues
)
;
Maybe
<
OwningAnimationTarget
>
mTarget
;
KeyframeEffectParams
mEffectOptions
;
nsTArray
<
Keyframe
>
mKeyframes
;
nsTArray
<
AnimationProperty
>
mProperties
;
Nullable
<
double
>
mProgressOnLastCompose
;
uint64_t
mCurrentIterationOnLastCompose
=
0
;
bool
mInEffectOnLastAnimationTimingUpdate
;
#
ifdef
MOZ_OLD_STYLE
nsDataHashtable
<
nsUint32HashKey
StyleAnimationValue
>
mBaseStyleValues
;
#
endif
nsRefPtrHashtable
<
nsUint32HashKey
RawServoAnimationValue
>
mBaseStyleValuesForServo
;
bool
mInEffectSet
=
false
;
private
:
nsChangeHint
mCumulativeChangeHint
;
template
<
typename
StyleType
>
void
DoSetKeyframes
(
nsTArray
<
Keyframe
>
&
&
aKeyframes
StyleType
*
aStyle
)
;
template
<
typename
StyleType
>
void
DoUpdateProperties
(
StyleType
*
aStyle
)
;
#
ifdef
MOZ_OLD_STYLE
void
ComposeStyleRule
(
RefPtr
<
AnimValuesStyleRule
>
&
aStyleRule
const
AnimationProperty
&
aProperty
const
AnimationPropertySegment
&
aSegment
const
ComputedTiming
&
aComputedTiming
)
;
#
endif
void
ComposeStyleRule
(
RawServoAnimationValueMap
&
aAnimationValues
const
AnimationProperty
&
aProperty
const
AnimationPropertySegment
&
aSegment
const
ComputedTiming
&
aComputedTiming
)
;
#
ifdef
MOZ_OLD_STYLE
already_AddRefed
<
nsStyleContext
>
CreateStyleContextForAnimationValue
(
nsCSSPropertyID
aProperty
const
AnimationValue
&
aValue
GeckoStyleContext
*
aBaseStyleContext
)
;
#
endif
already_AddRefed
<
nsStyleContext
>
CreateStyleContextForAnimationValue
(
nsCSSPropertyID
aProperty
const
AnimationValue
&
aValue
const
ServoStyleContext
*
aBaseStyleContext
)
;
nsIFrame
*
GetAnimationFrame
(
)
const
;
bool
CanThrottle
(
)
const
;
bool
CanThrottleTransformChanges
(
const
nsIFrame
&
aFrame
)
const
;
bool
CanThrottleTransformChangesInScrollable
(
nsIFrame
&
aFrame
)
const
;
bool
HasComputedTimingChanged
(
)
const
;
static
bool
CanAnimateTransformOnCompositor
(
const
nsIFrame
*
aFrame
AnimationPerformanceWarning
:
:
Type
&
aPerformanceWarning
)
;
static
bool
IsGeometricProperty
(
const
nsCSSPropertyID
aProperty
)
;
static
const
TimeDuration
OverflowRegionRefreshInterval
(
)
;
void
UpdateEffectSet
(
mozilla
:
:
EffectSet
*
aEffectSet
=
nullptr
)
const
;
bool
mIsComposingStyle
=
false
;
}
;
}
}
#
endif
