#
ifndef
mozilla_dom_KeyframeEffectReadOnly_h
#
define
mozilla_dom_KeyframeEffectReadOnly_h
#
include
"
nsChangeHint
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
include
"
nsCSSPropertyIDSet
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
AnimationPerformanceWarning
.
h
"
#
include
"
mozilla
/
AnimationTarget
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ComputedTimingFunction
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
Keyframe
.
h
"
#
include
"
mozilla
/
KeyframeEffectParams
.
h
"
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
include
"
mozilla
/
StyleAnimationValueInlines
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffectReadOnly
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
struct
JSContext
;
class
JSObject
;
class
nsIContent
;
class
nsIDocument
;
class
nsIFrame
;
class
nsIPresShell
;
class
nsPresContext
;
namespace
mozilla
{
class
AnimValuesStyleRule
;
enum
class
CSSPseudoElementType
:
uint8_t
;
class
ErrorResult
;
struct
AnimationRule
;
struct
TimingParams
;
namespace
dom
{
class
ElementOrCSSPseudoElement
;
class
GlobalObject
;
class
OwningElementOrCSSPseudoElement
;
class
UnrestrictedDoubleOrKeyframeAnimationOptions
;
class
UnrestrictedDoubleOrKeyframeEffectOptions
;
enum
class
IterationCompositeOperation
:
uint8_t
;
enum
class
CompositeOperation
:
uint8_t
;
struct
AnimationPropertyDetails
;
}
struct
AnimationPropertySegment
{
float
mFromKey
mToKey
;
AnimationValue
mFromValue
mToValue
;
Maybe
<
ComputedTimingFunction
>
mTimingFunction
;
dom
:
:
CompositeOperation
mFromComposite
=
dom
:
:
CompositeOperation
:
:
Replace
;
dom
:
:
CompositeOperation
mToComposite
=
dom
:
:
CompositeOperation
:
:
Replace
;
bool
HasReplacableValues
(
)
const
{
return
HasReplacableFromValue
(
)
&
&
HasReplacableToValue
(
)
;
}
bool
HasReplacableFromValue
(
)
const
{
return
!
mFromValue
.
IsNull
(
)
&
&
mFromComposite
=
=
dom
:
:
CompositeOperation
:
:
Replace
;
}
bool
HasReplacableToValue
(
)
const
{
return
!
mToValue
.
IsNull
(
)
&
&
mToComposite
=
=
dom
:
:
CompositeOperation
:
:
Replace
;
}
bool
operator
=
=
(
const
AnimationPropertySegment
&
aOther
)
const
{
return
mFromKey
=
=
aOther
.
mFromKey
&
&
mToKey
=
=
aOther
.
mToKey
&
&
mFromValue
=
=
aOther
.
mFromValue
&
&
mToValue
=
=
aOther
.
mToValue
&
&
mTimingFunction
=
=
aOther
.
mTimingFunction
&
&
mFromComposite
=
=
aOther
.
mFromComposite
&
&
mToComposite
=
=
aOther
.
mToComposite
;
}
bool
operator
!
=
(
const
AnimationPropertySegment
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
AnimationProperty
{
nsCSSPropertyID
mProperty
=
eCSSProperty_UNKNOWN
;
bool
mIsRunningOnCompositor
=
false
;
Maybe
<
AnimationPerformanceWarning
>
mPerformanceWarning
;
InfallibleTArray
<
AnimationPropertySegment
>
mSegments
;
AnimationProperty
(
)
=
default
;
AnimationProperty
(
const
AnimationProperty
&
aOther
)
:
mProperty
(
aOther
.
mProperty
)
mSegments
(
aOther
.
mSegments
)
{
}
AnimationProperty
&
operator
=
(
const
AnimationProperty
&
aOther
)
{
mProperty
=
aOther
.
mProperty
;
mSegments
=
aOther
.
mSegments
;
return
*
this
;
}
bool
operator
=
=
(
const
AnimationProperty
&
aOther
)
const
{
return
mProperty
=
=
aOther
.
mProperty
&
&
mSegments
=
=
aOther
.
mSegments
;
}
bool
operator
!
=
(
const
AnimationProperty
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
ServoComputedStyleValues
{
const
ServoComputedValues
*
mCurrentStyle
;
const
ServoComputedValues
*
mParentStyle
;
explicit
operator
bool
(
)
const
{
return
true
;
}
}
;
struct
ElementPropertyTransition
;
namespace
dom
{
class
Animation
;
class
KeyframeEffectReadOnly
:
public
AnimationEffectReadOnly
{
public
:
KeyframeEffectReadOnly
(
nsIDocument
*
aDocument
const
Maybe
<
OwningAnimationTarget
>
&
aTarget
const
TimingParams
&
aTiming
const
KeyframeEffectParams
&
aOptions
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED
(
KeyframeEffectReadOnly
AnimationEffectReadOnly
)
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
KeyframeEffectReadOnly
*
AsKeyframeEffect
(
)
override
{
return
this
;
}
static
already_AddRefed
<
KeyframeEffectReadOnly
>
Constructor
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
UnrestrictedDoubleOrKeyframeEffectOptions
&
aOptions
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
KeyframeEffectReadOnly
>
Constructor
(
const
GlobalObject
&
aGlobal
KeyframeEffectReadOnly
&
aSource
ErrorResult
&
aRv
)
;
void
GetTarget
(
Nullable
<
OwningElementOrCSSPseudoElement
>
&
aRv
)
const
;
Maybe
<
NonOwningAnimationTarget
>
GetTarget
(
)
const
{
Maybe
<
NonOwningAnimationTarget
>
result
;
if
(
mTarget
)
{
result
.
emplace
(
*
mTarget
)
;
}
return
result
;
}
void
GetKeyframes
(
JSContext
*
&
aCx
nsTArray
<
JSObject
*
>
&
aResult
ErrorResult
&
aRv
)
;
void
GetProperties
(
nsTArray
<
AnimationPropertyDetails
>
&
aProperties
ErrorResult
&
aRv
)
const
;
IterationCompositeOperation
IterationComposite
(
)
const
;
CompositeOperation
Composite
(
)
const
;
void
GetSpacing
(
nsString
&
aRetVal
)
const
{
mEffectOptions
.
GetSpacingAsString
(
aRetVal
)
;
}
void
NotifyAnimationTimingUpdated
(
)
;
void
SetAnimation
(
Animation
*
aAnimation
)
override
;
void
SetKeyframes
(
JSContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
ErrorResult
&
aRv
)
;
void
SetKeyframes
(
nsTArray
<
Keyframe
>
&
&
aKeyframes
nsStyleContext
*
aStyleContext
)
;
void
SetKeyframes
(
nsTArray
<
Keyframe
>
&
&
aKeyframes
const
ServoComputedStyleValues
&
aServoValues
)
;
bool
HasAnimationOfProperty
(
nsCSSPropertyID
aProperty
)
const
;
bool
HasEffectiveAnimationOfProperty
(
nsCSSPropertyID
aProperty
)
const
{
return
GetEffectiveAnimationOfProperty
(
aProperty
)
!
=
nullptr
;
}
const
AnimationProperty
*
GetEffectiveAnimationOfProperty
(
nsCSSPropertyID
aProperty
)
const
;
const
InfallibleTArray
<
AnimationProperty
>
&
Properties
(
)
const
{
return
mProperties
;
}
void
UpdateProperties
(
nsStyleContext
*
aStyleContext
)
;
void
UpdateProperties
(
const
ServoComputedStyleValues
&
aServoValues
)
;
void
ComposeStyle
(
AnimationRule
&
aStyleRule
const
nsCSSPropertyIDSet
&
aPropertiesToSkip
)
;
static
StyleAnimationValue
CompositeValue
(
nsCSSPropertyID
aProperty
const
StyleAnimationValue
&
aValueToComposite
const
StyleAnimationValue
&
aUnderlyingValue
CompositeOperation
aCompositeOperation
)
;
bool
IsRunningOnCompositor
(
)
const
;
void
SetIsRunningOnCompositor
(
nsCSSPropertyID
aProperty
bool
aIsRunning
)
;
void
ResetIsRunningOnCompositor
(
)
;
bool
ShouldBlockAsyncTransformAnimations
(
const
nsIFrame
*
aFrame
AnimationPerformanceWarning
:
:
Type
&
aPerformanceWarning
)
const
;
bool
HasGeometricProperties
(
)
const
;
bool
AffectsGeometry
(
)
const
override
{
return
GetTarget
(
)
&
&
HasGeometricProperties
(
)
;
}
nsIDocument
*
GetRenderedDocument
(
)
const
;
nsPresContext
*
GetPresContext
(
)
const
;
nsIPresShell
*
GetPresShell
(
)
const
;
void
SetPerformanceWarning
(
nsCSSPropertyID
aProperty
const
AnimationPerformanceWarning
&
aWarning
)
;
void
CalculateCumulativeChangeHint
(
nsStyleContext
*
aStyleContext
)
;
void
CalculateCumulativeChangeHint
(
const
ServoComputedStyleValues
&
aServoValues
)
{
}
bool
CanIgnoreIfNotVisible
(
)
const
;
bool
ContainsAnimatedScale
(
const
nsIFrame
*
aFrame
)
const
;
StyleAnimationValue
BaseStyle
(
nsCSSPropertyID
aProperty
)
const
{
StyleAnimationValue
result
;
DebugOnly
<
bool
>
hasProperty
=
mBaseStyleValues
.
Get
(
aProperty
&
result
)
;
MOZ_ASSERT
(
hasProperty
|
|
result
.
IsNull
(
)
)
;
return
result
;
}
protected
:
KeyframeEffectReadOnly
(
nsIDocument
*
aDocument
const
Maybe
<
OwningAnimationTarget
>
&
aTarget
AnimationEffectTimingReadOnly
*
aTiming
const
KeyframeEffectParams
&
aOptions
)
;
~
KeyframeEffectReadOnly
(
)
override
=
default
;
static
Maybe
<
OwningAnimationTarget
>
ConvertTarget
(
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
)
;
template
<
class
KeyframeEffectType
class
OptionsType
>
static
already_AddRefed
<
KeyframeEffectType
>
ConstructKeyframeEffect
(
const
GlobalObject
&
aGlobal
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
OptionsType
&
aOptions
ErrorResult
&
aRv
)
;
template
<
class
KeyframeEffectType
>
static
already_AddRefed
<
KeyframeEffectType
>
ConstructKeyframeEffect
(
const
GlobalObject
&
aGlobal
KeyframeEffectReadOnly
&
aSource
ErrorResult
&
aRv
)
;
template
<
typename
StyleType
>
nsTArray
<
AnimationProperty
>
BuildProperties
(
StyleType
&
&
aStyle
)
;
void
UpdateTargetRegistration
(
)
;
void
UnregisterTarget
(
)
;
void
RequestRestyle
(
EffectCompositor
:
:
RestyleType
aRestyleType
)
;
void
MaybeUpdateFrameForCompositor
(
)
;
already_AddRefed
<
nsStyleContext
>
GetTargetStyleContext
(
)
;
void
MarkCascadeNeedsUpdate
(
)
;
StyleAnimationValue
CompositeValue
(
nsCSSPropertyID
aProperty
const
RefPtr
<
AnimValuesStyleRule
>
&
aAnimationRule
const
StyleAnimationValue
&
aValueToComposite
CompositeOperation
aCompositeOperation
)
;
StyleAnimationValue
GetUnderlyingStyle
(
nsCSSPropertyID
aProperty
const
RefPtr
<
AnimValuesStyleRule
>
&
aAnimationRule
)
;
void
EnsureBaseStyles
(
nsStyleContext
*
aStyleContext
const
nsTArray
<
AnimationProperty
>
&
aProperties
)
;
void
EnsureBaseStyles
(
const
ServoComputedStyleValues
&
aServoValues
const
nsTArray
<
AnimationProperty
>
&
aProperties
)
{
}
StyleAnimationValue
ResolveBaseStyle
(
nsCSSPropertyID
aProperty
nsStyleContext
*
aStyleContext
)
;
Maybe
<
OwningAnimationTarget
>
mTarget
;
KeyframeEffectParams
mEffectOptions
;
nsTArray
<
Keyframe
>
mKeyframes
;
nsTArray
<
AnimationProperty
>
mProperties
;
Nullable
<
double
>
mProgressOnLastCompose
;
uint64_t
mCurrentIterationOnLastCompose
=
0
;
bool
mInEffectOnLastAnimationTimingUpdate
;
nsDataHashtable
<
nsUint32HashKey
StyleAnimationValue
>
mBaseStyleValues
;
private
:
nsChangeHint
mCumulativeChangeHint
;
template
<
typename
StyleType
>
void
DoSetKeyframes
(
nsTArray
<
Keyframe
>
&
&
aKeyframes
StyleType
&
&
aStyle
)
;
template
<
typename
StyleType
>
void
DoUpdateProperties
(
StyleType
&
&
aStyle
)
;
nsIFrame
*
GetAnimationFrame
(
)
const
;
bool
CanThrottle
(
)
const
;
bool
CanThrottleTransformChanges
(
nsIFrame
&
aFrame
)
const
;
bool
HasComputedTimingChanged
(
)
const
;
static
bool
CanAnimateTransformOnCompositor
(
const
nsIFrame
*
aFrame
AnimationPerformanceWarning
:
:
Type
&
aPerformanceWarning
)
;
static
bool
IsGeometricProperty
(
const
nsCSSPropertyID
aProperty
)
;
static
const
TimeDuration
OverflowRegionRefreshInterval
(
)
;
bool
mIsComposingStyle
=
false
;
}
;
}
}
#
endif
