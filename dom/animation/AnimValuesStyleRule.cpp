#
include
"
AnimValuesStyleRule
.
h
"
#
include
"
nsRuleData
.
h
"
#
include
"
nsStyleContext
.
h
"
namespace
mozilla
{
NS_IMPL_ISUPPORTS
(
AnimValuesStyleRule
nsIStyleRule
)
void
AnimValuesStyleRule
:
:
MapRuleInfoInto
(
nsRuleData
*
aRuleData
)
{
nsStyleContext
*
contextParent
=
aRuleData
-
>
mStyleContext
-
>
GetParent
(
)
;
if
(
contextParent
&
&
contextParent
-
>
HasPseudoElementData
(
)
)
{
aRuleData
-
>
mConditions
.
SetUncacheable
(
)
;
return
;
}
for
(
uint32_t
i
=
0
i_end
=
mPropertyValuePairs
.
Length
(
)
;
i
<
i_end
;
+
+
i
)
{
PropertyValuePair
&
cv
=
mPropertyValuePairs
[
i
]
;
if
(
aRuleData
-
>
mSIDs
&
nsCachedStyleData
:
:
GetBitForSID
(
nsCSSProps
:
:
kSIDTable
[
cv
.
mProperty
]
)
)
{
nsCSSValue
*
prop
=
aRuleData
-
>
ValueFor
(
cv
.
mProperty
)
;
if
(
prop
-
>
GetUnit
(
)
=
=
eCSSUnit_Null
)
{
#
ifdef
DEBUG
bool
ok
=
#
endif
StyleAnimationValue
:
:
UncomputeValue
(
cv
.
mProperty
cv
.
mValue
*
prop
)
;
MOZ_ASSERT
(
ok
"
could
not
store
computed
value
"
)
;
}
}
}
}
bool
AnimValuesStyleRule
:
:
MightMapInheritedStyleData
(
)
{
return
mStyleBits
&
NS_STYLE_INHERITED_STRUCT_MASK
;
}
#
ifdef
DEBUG
void
AnimValuesStyleRule
:
:
List
(
FILE
*
out
int32_t
aIndent
)
const
{
nsAutoCString
str
;
for
(
int32_t
index
=
aIndent
;
-
-
index
>
=
0
;
)
{
str
.
AppendLiteral
(
"
"
)
;
}
str
.
AppendLiteral
(
"
[
anim
values
]
{
"
)
;
for
(
uint32_t
i
=
0
i_end
=
mPropertyValuePairs
.
Length
(
)
;
i
<
i_end
;
+
+
i
)
{
const
PropertyValuePair
&
pair
=
mPropertyValuePairs
[
i
]
;
str
.
Append
(
nsCSSProps
:
:
GetStringValue
(
pair
.
mProperty
)
)
;
str
.
AppendLiteral
(
"
:
"
)
;
nsAutoString
value
;
StyleAnimationValue
:
:
UncomputeValue
(
pair
.
mProperty
pair
.
mValue
value
)
;
AppendUTF16toUTF8
(
value
str
)
;
str
.
AppendLiteral
(
"
;
"
)
;
}
str
.
AppendLiteral
(
"
}
\
n
"
)
;
fprintf_stderr
(
out
"
%
s
"
str
.
get
(
)
)
;
}
#
endif
}
