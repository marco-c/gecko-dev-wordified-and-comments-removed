#
include
"
ScrollTimeline
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
mozilla
/
AnimationTarget
.
h
"
#
include
"
mozilla
/
DisplayPortUtils
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
define
SCROLL_TIMELINE_DURATION_MILLISEC
100000
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
ScrollTimeline
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
ScrollTimeline
AnimationTimeline
)
tmp
-
>
Teardown
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocument
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSource
.
mElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
ScrollTimeline
AnimationTimeline
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocument
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSource
.
mElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
ScrollTimeline
AnimationTimeline
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
ScrollTimeline
AnimationTimeline
)
TimingParams
ScrollTimeline
:
:
sTiming
;
ScrollTimeline
:
:
ScrollTimeline
(
Document
*
aDocument
const
Scroller
&
aScroller
StyleScrollAxis
aAxis
)
:
AnimationTimeline
(
aDocument
-
>
GetParentObject
(
)
)
mDocument
(
aDocument
)
mSource
(
aScroller
)
mAxis
(
aAxis
)
{
MOZ_ASSERT
(
aDocument
)
;
sTiming
=
TimingParams
(
SCROLL_TIMELINE_DURATION_MILLISEC
0
.
0
std
:
:
numeric_limits
<
float
>
:
:
infinity
(
)
PlaybackDirection
:
:
Alternate
FillMode
:
:
Both
)
;
}
already_AddRefed
<
ScrollTimeline
>
ScrollTimeline
:
:
GetOrCreateScrollTimeline
(
Document
*
aDocument
const
Scroller
&
aScroller
const
StyleScrollAxis
&
aAxis
)
{
MOZ_ASSERT
(
aScroller
)
;
RefPtr
<
ScrollTimeline
>
timeline
;
auto
*
set
=
ScrollTimelineSet
:
:
GetOrCreateScrollTimelineSet
(
aScroller
.
mElement
)
;
auto
p
=
set
-
>
LookupForAdd
(
aAxis
)
;
if
(
!
p
)
{
timeline
=
new
ScrollTimeline
(
aDocument
aScroller
aAxis
)
;
set
-
>
Add
(
p
aAxis
timeline
)
;
}
else
{
timeline
=
p
-
>
value
(
)
;
}
return
timeline
.
forget
(
)
;
}
static
StyleScrollAxis
ToStyleScrollAxis
(
const
StyleScrollDirection
aDirection
)
{
switch
(
aDirection
)
{
case
StyleScrollDirection
:
:
Auto
:
case
StyleScrollDirection
:
:
Block
:
return
StyleScrollAxis
:
:
Block
;
case
StyleScrollDirection
:
:
Inline
:
return
StyleScrollAxis
:
:
Inline
;
case
StyleScrollDirection
:
:
Horizontal
:
return
StyleScrollAxis
:
:
Horizontal
;
case
StyleScrollDirection
:
:
Vertical
:
return
StyleScrollAxis
:
:
Vertical
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
StyleScrollDirection
"
)
;
return
StyleScrollAxis
:
:
Block
;
}
already_AddRefed
<
ScrollTimeline
>
ScrollTimeline
:
:
FromRule
(
const
RawServoScrollTimelineRule
&
aRule
Document
*
aDocument
const
NonOwningAnimationTarget
&
aTarget
)
{
StyleScrollAxis
axis
=
ToStyleScrollAxis
(
Servo_ScrollTimelineRule_GetOrientation
(
&
aRule
)
)
;
auto
autoScroller
=
Scroller
:
:
Root
(
aTarget
.
mElement
-
>
OwnerDoc
(
)
)
;
return
GetOrCreateScrollTimeline
(
aDocument
autoScroller
axis
)
;
}
already_AddRefed
<
ScrollTimeline
>
ScrollTimeline
:
:
FromAnonymousScroll
(
Document
*
aDocument
const
NonOwningAnimationTarget
&
aTarget
StyleScrollAxis
aAxis
StyleScroller
aScroller
)
{
MOZ_ASSERT
(
aTarget
)
;
Scroller
scroller
;
switch
(
aScroller
)
{
case
StyleScroller
:
:
Root
:
scroller
=
Scroller
:
:
Root
(
aTarget
.
mElement
-
>
OwnerDoc
(
)
)
;
break
;
case
StyleScroller
:
:
Nearest
:
{
Element
*
curr
=
aTarget
.
mElement
-
>
GetFlattenedTreeParentElement
(
)
;
Element
*
root
=
aTarget
.
mElement
-
>
OwnerDoc
(
)
-
>
GetDocumentElement
(
)
;
while
(
curr
&
&
curr
!
=
root
)
{
const
ComputedStyle
*
style
=
Servo_Element_GetMaybeOutOfDateStyle
(
curr
)
;
MOZ_ASSERT
(
style
"
The
ancestor
should
be
styled
.
"
)
;
if
(
style
-
>
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
break
;
}
curr
=
curr
-
>
GetFlattenedTreeParentElement
(
)
;
}
scroller
=
Scroller
:
:
Nearest
(
curr
?
curr
:
root
)
;
}
}
return
GetOrCreateScrollTimeline
(
aDocument
scroller
aAxis
)
;
}
already_AddRefed
<
ScrollTimeline
>
ScrollTimeline
:
:
FromNamedScroll
(
Document
*
aDocument
const
NonOwningAnimationTarget
&
aTarget
const
nsAtom
*
aName
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aTarget
)
;
Element
*
result
=
nullptr
;
StyleScrollAxis
axis
=
StyleScrollAxis
:
:
Block
;
for
(
Element
*
curr
=
aTarget
.
mElement
;
curr
;
curr
=
curr
-
>
GetParentElement
(
)
)
{
for
(
Element
*
e
=
curr
;
e
;
e
=
e
-
>
GetPreviousElementSibling
(
)
)
{
const
ComputedStyle
*
style
=
Servo_Element_GetMaybeOutOfDateStyle
(
e
)
;
if
(
!
style
)
{
continue
;
}
const
nsStyleUIReset
*
styleUIReset
=
style
-
>
StyleUIReset
(
)
;
if
(
styleUIReset
-
>
mScrollTimelineName
.
_0
.
AsAtom
(
)
=
=
aName
)
{
result
=
e
;
axis
=
styleUIReset
-
>
mScrollTimelineAxis
;
break
;
}
}
if
(
result
)
{
break
;
}
}
if
(
!
result
)
{
return
nullptr
;
}
Scroller
scroller
=
Scroller
:
:
Named
(
result
)
;
return
GetOrCreateScrollTimeline
(
aDocument
scroller
axis
)
;
}
Nullable
<
TimeDuration
>
ScrollTimeline
:
:
GetCurrentTimeAsDuration
(
)
const
{
if
(
!
mSource
|
|
!
mSource
.
mElement
-
>
GetPrimaryFrame
(
)
)
{
return
nullptr
;
}
const
nsIScrollableFrame
*
scrollFrame
=
GetScrollFrame
(
)
;
if
(
!
scrollFrame
)
{
return
nullptr
;
}
const
auto
orientation
=
Axis
(
)
;
if
(
!
scrollFrame
-
>
GetAvailableScrollingDirections
(
)
.
contains
(
orientation
)
)
{
return
TimeDuration
:
:
FromMilliseconds
(
SCROLL_TIMELINE_DURATION_MILLISEC
)
;
}
const
nsPoint
&
scrollOffset
=
scrollFrame
-
>
GetScrollPosition
(
)
;
const
nsRect
&
scrollRange
=
scrollFrame
-
>
GetScrollRange
(
)
;
const
bool
isHorizontal
=
orientation
=
=
layers
:
:
ScrollDirection
:
:
eHorizontal
;
double
position
=
std
:
:
abs
(
isHorizontal
?
scrollOffset
.
x
:
scrollOffset
.
y
)
;
double
range
=
isHorizontal
?
scrollRange
.
width
:
scrollRange
.
height
;
MOZ_ASSERT
(
range
>
0
.
0
)
;
double
progress
=
position
/
range
;
return
TimeDuration
:
:
FromMilliseconds
(
progress
*
SCROLL_TIMELINE_DURATION_MILLISEC
)
;
}
layers
:
:
ScrollDirection
ScrollTimeline
:
:
Axis
(
)
const
{
MOZ_ASSERT
(
mSource
&
&
mSource
.
mElement
-
>
GetPrimaryFrame
(
)
)
;
const
WritingMode
wm
=
mSource
.
mElement
-
>
GetPrimaryFrame
(
)
-
>
GetWritingMode
(
)
;
return
mAxis
=
=
StyleScrollAxis
:
:
Horizontal
|
|
(
!
wm
.
IsVertical
(
)
&
&
mAxis
=
=
StyleScrollAxis
:
:
Inline
)
|
|
(
wm
.
IsVertical
(
)
&
&
mAxis
=
=
StyleScrollAxis
:
:
Block
)
?
layers
:
:
ScrollDirection
:
:
eHorizontal
:
layers
:
:
ScrollDirection
:
:
eVertical
;
}
StyleOverflow
ScrollTimeline
:
:
SourceScrollStyle
(
)
const
{
MOZ_ASSERT
(
mSource
&
&
mSource
.
mElement
-
>
GetPrimaryFrame
(
)
)
;
const
nsIScrollableFrame
*
scrollFrame
=
GetScrollFrame
(
)
;
MOZ_ASSERT
(
scrollFrame
)
;
const
ScrollStyles
scrollStyles
=
scrollFrame
-
>
GetScrollStyles
(
)
;
return
Axis
(
)
=
=
layers
:
:
ScrollDirection
:
:
eHorizontal
?
scrollStyles
.
mHorizontal
:
scrollStyles
.
mVertical
;
}
bool
ScrollTimeline
:
:
APZIsActiveForSource
(
)
const
{
MOZ_ASSERT
(
mSource
)
;
return
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
&
&
!
nsLayoutUtils
:
:
ShouldDisableApzForElement
(
mSource
.
mElement
)
&
&
DisplayPortUtils
:
:
HasNonMinimalNonZeroDisplayPort
(
mSource
.
mElement
)
;
}
bool
ScrollTimeline
:
:
ScrollingDirectionIsAvailable
(
)
const
{
const
nsIScrollableFrame
*
scrollFrame
=
GetScrollFrame
(
)
;
MOZ_ASSERT
(
scrollFrame
)
;
return
scrollFrame
-
>
GetAvailableScrollingDirections
(
)
.
contains
(
Axis
(
)
)
;
}
void
ScrollTimeline
:
:
UnregisterFromScrollSource
(
)
{
if
(
!
mSource
)
{
return
;
}
if
(
ScrollTimelineSet
*
scrollTimelineSet
=
ScrollTimelineSet
:
:
GetScrollTimelineSet
(
mSource
.
mElement
)
)
{
scrollTimelineSet
-
>
Remove
(
mAxis
)
;
if
(
scrollTimelineSet
-
>
IsEmpty
(
)
)
{
ScrollTimelineSet
:
:
DestroyScrollTimelineSet
(
mSource
.
mElement
)
;
}
}
}
const
nsIScrollableFrame
*
ScrollTimeline
:
:
GetScrollFrame
(
)
const
{
if
(
!
mSource
)
{
return
nullptr
;
}
switch
(
mSource
.
mType
)
{
case
Scroller
:
:
Type
:
:
Root
:
if
(
const
PresShell
*
presShell
=
mSource
.
mElement
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
)
{
return
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
}
return
nullptr
;
case
Scroller
:
:
Type
:
:
Nearest
:
case
Scroller
:
:
Type
:
:
Name
:
return
nsLayoutUtils
:
:
FindScrollableFrameFor
(
mSource
.
mElement
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
scroller
type
"
)
;
return
nullptr
;
}
ScrollTimelineSet
*
ScrollTimelineSet
:
:
GetScrollTimelineSet
(
Element
*
aElement
)
{
return
aElement
?
static_cast
<
ScrollTimelineSet
*
>
(
aElement
-
>
GetProperty
(
nsGkAtoms
:
:
scrollTimelinesProperty
)
)
:
nullptr
;
}
ScrollTimelineSet
*
ScrollTimelineSet
:
:
GetOrCreateScrollTimelineSet
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
ScrollTimelineSet
*
scrollTimelineSet
=
GetScrollTimelineSet
(
aElement
)
;
if
(
scrollTimelineSet
)
{
return
scrollTimelineSet
;
}
scrollTimelineSet
=
new
ScrollTimelineSet
(
)
;
nsresult
rv
=
aElement
-
>
SetProperty
(
nsGkAtoms
:
:
scrollTimelinesProperty
scrollTimelineSet
nsINode
:
:
DeleteProperty
<
ScrollTimelineSet
>
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
SetProperty
failed
"
)
;
delete
scrollTimelineSet
;
return
nullptr
;
}
return
scrollTimelineSet
;
}
void
ScrollTimelineSet
:
:
DestroyScrollTimelineSet
(
Element
*
aElement
)
{
aElement
-
>
RemoveProperty
(
nsGkAtoms
:
:
scrollTimelinesProperty
)
;
}
}
