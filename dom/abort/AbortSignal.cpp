#
include
"
AbortSignal
.
h
"
#
include
"
mozilla
/
dom
/
DOMException
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventBinding
.
h
"
#
include
"
mozilla
/
dom
/
AbortSignalBinding
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
namespace
mozilla
:
:
dom
{
AbortSignalImpl
:
:
AbortSignalImpl
(
bool
aAborted
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
)
:
mReason
(
aReason
)
mAborted
(
aAborted
)
{
MOZ_ASSERT_IF
(
!
mReason
.
isUndefined
(
)
mAborted
)
;
}
bool
AbortSignalImpl
:
:
Aborted
(
)
const
{
return
mAborted
;
}
void
AbortSignalImpl
:
:
GetReason
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aReason
)
{
if
(
!
mAborted
)
{
return
;
}
MaybeAssignAbortError
(
aCx
)
;
aReason
.
set
(
mReason
)
;
}
JS
:
:
Value
AbortSignalImpl
:
:
RawReason
(
)
const
{
return
mReason
.
get
(
)
;
}
void
AbortSignalImpl
:
:
SignalAbort
(
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
)
{
if
(
mAborted
)
{
return
;
}
mAborted
=
true
;
mReason
=
aReason
;
for
(
RefPtr
<
AbortFollower
>
follower
:
mFollowers
.
ForwardRange
(
)
)
{
MOZ_ASSERT
(
follower
-
>
mFollowingSignal
=
=
this
)
;
follower
-
>
RunAbortAlgorithm
(
)
;
}
for
(
AbortFollower
*
follower
:
mFollowers
.
ForwardRange
(
)
)
{
follower
-
>
mFollowingSignal
=
nullptr
;
}
mFollowers
.
Clear
(
)
;
}
void
AbortSignalImpl
:
:
Traverse
(
AbortSignalImpl
*
aSignal
nsCycleCollectionTraversalCallback
&
cb
)
{
}
void
AbortSignalImpl
:
:
Unlink
(
AbortSignalImpl
*
aSignal
)
{
aSignal
-
>
mReason
.
setUndefined
(
)
;
}
void
AbortSignalImpl
:
:
MaybeAssignAbortError
(
JSContext
*
aCx
)
{
MOZ_ASSERT
(
mAborted
)
;
if
(
!
mReason
.
isUndefined
(
)
)
{
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
exception
(
aCx
)
;
RefPtr
<
DOMException
>
dom
=
DOMException
:
:
Create
(
NS_ERROR_DOM_ABORT_ERR
)
;
if
(
NS_WARN_IF
(
!
ToJSValue
(
aCx
dom
&
exception
)
)
)
{
return
;
}
mReason
.
set
(
exception
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
AbortSignal
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
AbortSignal
DOMEventTargetHelper
)
AbortSignalImpl
:
:
Traverse
(
static_cast
<
AbortSignalImpl
*
>
(
tmp
)
cb
)
;
AbortFollower
:
:
Traverse
(
static_cast
<
AbortFollower
*
>
(
tmp
)
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
AbortSignal
DOMEventTargetHelper
)
AbortSignalImpl
:
:
Unlink
(
static_cast
<
AbortSignalImpl
*
>
(
tmp
)
)
;
AbortFollower
:
:
Unlink
(
static_cast
<
AbortFollower
*
>
(
tmp
)
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
AbortSignal
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
AbortSignal
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mReason
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_ADDREF_INHERITED
(
AbortSignal
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
AbortSignal
DOMEventTargetHelper
)
AbortSignal
:
:
AbortSignal
(
nsIGlobalObject
*
aGlobalObject
bool
aAborted
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
)
:
DOMEventTargetHelper
(
aGlobalObject
)
AbortSignalImpl
(
aAborted
aReason
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
}
JSObject
*
AbortSignal
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
AbortSignal_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
AbortSignal
>
AbortSignal
:
:
Abort
(
GlobalObject
&
aGlobal
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
RefPtr
<
AbortSignal
>
abortSignal
=
new
AbortSignal
(
global
true
aReason
)
;
return
abortSignal
.
forget
(
)
;
}
void
AbortSignal
:
:
ThrowIfAborted
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
aRv
.
MightThrowJSException
(
)
;
if
(
Aborted
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
reason
(
aCx
)
;
GetReason
(
aCx
&
reason
)
;
aRv
.
ThrowJSException
(
aCx
reason
)
;
}
}
void
AbortSignal
:
:
SignalAbort
(
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
)
{
AbortSignalImpl
:
:
SignalAbort
(
aReason
)
;
EventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
RefPtr
<
Event
>
event
=
Event
:
:
Constructor
(
this
u
"
abort
"
_ns
init
)
;
event
-
>
SetTrusted
(
true
)
;
DispatchEvent
(
*
event
)
;
}
void
AbortSignal
:
:
RunAbortAlgorithm
(
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
reason
(
RootingCx
(
)
Signal
(
)
-
>
RawReason
(
)
)
;
SignalAbort
(
reason
)
;
}
AbortSignal
:
:
~
AbortSignal
(
)
{
mozilla
:
:
DropJSObjects
(
this
)
;
}
AbortFollower
:
:
~
AbortFollower
(
)
{
Unfollow
(
)
;
}
void
AbortFollower
:
:
Follow
(
AbortSignalImpl
*
aSignal
)
{
if
(
aSignal
-
>
mAborted
)
{
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aSignal
)
;
Unfollow
(
)
;
mFollowingSignal
=
aSignal
;
MOZ_ASSERT
(
!
aSignal
-
>
mFollowers
.
Contains
(
this
)
)
;
aSignal
-
>
mFollowers
.
AppendElement
(
this
)
;
}
void
AbortFollower
:
:
Unfollow
(
)
{
if
(
mFollowingSignal
)
{
mFollowingSignal
-
>
mFollowers
.
RemoveElement
(
this
)
;
mFollowingSignal
=
nullptr
;
}
}
bool
AbortFollower
:
:
IsFollowing
(
)
const
{
return
!
!
mFollowingSignal
;
}
void
AbortFollower
:
:
Traverse
(
AbortFollower
*
aFollower
nsCycleCollectionTraversalCallback
&
cb
)
{
ImplCycleCollectionTraverse
(
cb
aFollower
-
>
mFollowingSignal
"
mFollowingSignal
"
0
)
;
}
}
