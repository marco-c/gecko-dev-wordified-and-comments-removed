#
include
"
AbortSignal
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
AbortSignalBinding
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
namespace
mozilla
{
namespace
dom
{
AbortSignalImpl
:
:
AbortSignalImpl
(
bool
aAborted
)
:
mAborted
(
aAborted
)
{
}
bool
AbortSignalImpl
:
:
Aborted
(
)
const
{
return
mAborted
;
}
void
AbortSignalImpl
:
:
SignalAbort
(
)
{
if
(
mAborted
)
{
return
;
}
mAborted
=
true
;
for
(
RefPtr
<
AbortFollower
>
follower
:
mFollowers
.
ForwardRange
(
)
)
{
MOZ_ASSERT
(
follower
-
>
mFollowingSignal
=
=
this
)
;
follower
-
>
RunAbortAlgorithm
(
)
;
}
for
(
AbortFollower
*
follower
:
mFollowers
.
ForwardRange
(
)
)
{
follower
-
>
mFollowingSignal
=
nullptr
;
}
mFollowers
.
Clear
(
)
;
}
void
AbortSignalImpl
:
:
Traverse
(
AbortSignalImpl
*
aSignal
nsCycleCollectionTraversalCallback
&
cb
)
{
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
AbortSignal
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
AbortSignal
DOMEventTargetHelper
)
AbortSignalImpl
:
:
Traverse
(
static_cast
<
AbortSignalImpl
*
>
(
tmp
)
cb
)
;
AbortFollower
:
:
Traverse
(
static_cast
<
AbortFollower
*
>
(
tmp
)
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
AbortSignal
DOMEventTargetHelper
)
AbortSignalImpl
:
:
Unlink
(
static_cast
<
AbortSignalImpl
*
>
(
tmp
)
)
;
AbortFollower
:
:
Unlink
(
static_cast
<
AbortFollower
*
>
(
tmp
)
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
AbortSignal
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
NS_IMPL_ADDREF_INHERITED
(
AbortSignal
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
AbortSignal
DOMEventTargetHelper
)
AbortSignal
:
:
AbortSignal
(
nsIGlobalObject
*
aGlobalObject
bool
aAborted
)
:
DOMEventTargetHelper
(
aGlobalObject
)
AbortSignalImpl
(
aAborted
)
{
}
JSObject
*
AbortSignal
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
AbortSignal_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
AbortSignal
:
:
SignalAbort
(
)
{
AbortSignalImpl
:
:
SignalAbort
(
)
;
EventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
RefPtr
<
Event
>
event
=
Event
:
:
Constructor
(
this
u
"
abort
"
_ns
init
)
;
event
-
>
SetTrusted
(
true
)
;
DispatchEvent
(
*
event
)
;
}
AbortFollower
:
:
~
AbortFollower
(
)
{
Unfollow
(
)
;
}
void
AbortFollower
:
:
Follow
(
AbortSignalImpl
*
aSignal
)
{
if
(
aSignal
-
>
mAborted
)
{
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aSignal
)
;
Unfollow
(
)
;
mFollowingSignal
=
aSignal
;
MOZ_ASSERT
(
!
aSignal
-
>
mFollowers
.
Contains
(
this
)
)
;
aSignal
-
>
mFollowers
.
AppendElement
(
this
)
;
}
void
AbortFollower
:
:
Unfollow
(
)
{
if
(
mFollowingSignal
)
{
mFollowingSignal
-
>
mFollowers
.
RemoveElement
(
this
)
;
mFollowingSignal
=
nullptr
;
}
}
bool
AbortFollower
:
:
IsFollowing
(
)
const
{
return
!
!
mFollowingSignal
;
}
void
AbortFollower
:
:
Traverse
(
AbortFollower
*
aFollower
nsCycleCollectionTraversalCallback
&
cb
)
{
ImplCycleCollectionTraverse
(
cb
aFollower
-
>
mFollowingSignal
"
mFollowingSignal
"
0
)
;
}
}
}
