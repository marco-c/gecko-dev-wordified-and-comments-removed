#
include
"
SMILValue
.
h
"
#
include
"
nsDebug
.
h
"
#
include
<
string
.
h
>
namespace
mozilla
{
SMILValue
:
:
SMILValue
(
const
SMILType
*
aType
)
:
mType
(
SMILNullType
:
:
Singleton
(
)
)
{
mU
.
mBool
=
false
;
if
(
!
aType
)
{
NS_ERROR
(
"
Trying
to
construct
SMILValue
with
null
mType
pointer
"
)
;
return
;
}
InitAndCheckPostcondition
(
aType
)
;
}
SMILValue
:
:
SMILValue
(
const
SMILValue
&
aVal
)
:
mType
(
SMILNullType
:
:
Singleton
(
)
)
{
InitAndCheckPostcondition
(
aVal
.
mType
)
;
mType
-
>
Assign
(
*
this
aVal
)
;
}
const
SMILValue
&
SMILValue
:
:
operator
=
(
const
SMILValue
&
aVal
)
{
if
(
&
aVal
=
=
this
)
return
*
this
;
if
(
mType
!
=
aVal
.
mType
)
{
DestroyAndReinit
(
aVal
.
mType
)
;
}
mType
-
>
Assign
(
*
this
aVal
)
;
return
*
this
;
}
SMILValue
:
:
SMILValue
(
SMILValue
&
&
aVal
)
noexcept
:
mU
(
aVal
.
mU
)
mType
(
aVal
.
mType
)
{
aVal
.
mType
=
SMILNullType
:
:
Singleton
(
)
;
}
SMILValue
&
SMILValue
:
:
operator
=
(
SMILValue
&
&
aVal
)
noexcept
{
if
(
!
IsNull
(
)
)
{
DestroyAndCheckPostcondition
(
)
;
}
mU
=
aVal
.
mU
;
mType
=
aVal
.
mType
;
aVal
.
mType
=
SMILNullType
:
:
Singleton
(
)
;
return
*
this
;
}
bool
SMILValue
:
:
operator
=
=
(
const
SMILValue
&
aVal
)
const
{
if
(
&
aVal
=
=
this
)
return
true
;
return
mType
=
=
aVal
.
mType
&
&
mType
-
>
IsEqual
(
*
this
aVal
)
;
}
nsresult
SMILValue
:
:
Add
(
const
SMILValue
&
aValueToAdd
uint32_t
aCount
)
{
if
(
aValueToAdd
.
mType
!
=
mType
)
{
NS_ERROR
(
"
Trying
to
add
incompatible
types
"
)
;
return
NS_ERROR_FAILURE
;
}
return
mType
-
>
Add
(
*
this
aValueToAdd
aCount
)
;
}
nsresult
SMILValue
:
:
SandwichAdd
(
const
SMILValue
&
aValueToAdd
)
{
if
(
aValueToAdd
.
mType
!
=
mType
)
{
NS_ERROR
(
"
Trying
to
add
incompatible
types
"
)
;
return
NS_ERROR_FAILURE
;
}
return
mType
-
>
SandwichAdd
(
*
this
aValueToAdd
)
;
}
nsresult
SMILValue
:
:
ComputeDistance
(
const
SMILValue
&
aTo
double
&
aDistance
)
const
{
if
(
aTo
.
mType
!
=
mType
)
{
NS_ERROR
(
"
Trying
to
calculate
distance
between
incompatible
types
"
)
;
return
NS_ERROR_FAILURE
;
}
return
mType
-
>
ComputeDistance
(
*
this
aTo
aDistance
)
;
}
nsresult
SMILValue
:
:
Interpolate
(
const
SMILValue
&
aEndVal
double
aUnitDistance
SMILValue
&
aResult
)
const
{
if
(
aEndVal
.
mType
!
=
mType
)
{
NS_ERROR
(
"
Trying
to
interpolate
between
incompatible
types
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
aResult
.
mType
!
=
mType
)
{
aResult
.
DestroyAndReinit
(
mType
)
;
}
return
mType
-
>
Interpolate
(
*
this
aEndVal
aUnitDistance
aResult
)
;
}
void
SMILValue
:
:
InitAndCheckPostcondition
(
const
SMILType
*
aNewType
)
{
aNewType
-
>
Init
(
*
this
)
;
MOZ_ASSERT
(
mType
=
=
aNewType
"
Post
-
condition
of
Init
failed
.
SMILValue
is
invalid
"
)
;
}
void
SMILValue
:
:
DestroyAndCheckPostcondition
(
)
{
mType
-
>
Destroy
(
*
this
)
;
MOZ_ASSERT
(
IsNull
(
)
"
Post
-
condition
of
Destroy
failed
.
"
"
SMILValue
not
null
after
destroying
"
)
;
}
void
SMILValue
:
:
DestroyAndReinit
(
const
SMILType
*
aNewType
)
{
DestroyAndCheckPostcondition
(
)
;
InitAndCheckPostcondition
(
aNewType
)
;
}
}
