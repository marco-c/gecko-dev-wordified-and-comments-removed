#
include
"
nsSMILAnimationController
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
SVGAnimationElement
.
h
"
#
include
"
mozilla
/
RestyleManagerInlines
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIPresShellInlines
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsSMILCompositor
.
h
"
#
include
"
nsSMILCSSProperty
.
h
"
#
include
"
nsSMILTimedElement
.
h
"
#
include
"
RestyleTracker
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
nsSMILAnimationController
:
:
nsSMILAnimationController
(
nsIDocument
*
aDoc
)
:
mAvgTimeBetweenSamples
(
0
)
mResampleNeeded
(
false
)
mDeferredStartSampling
(
false
)
mRunningSample
(
false
)
mRegisteredWithRefreshDriver
(
false
)
mMightHavePendingStyleUpdates
(
false
)
mDocument
(
aDoc
)
{
MOZ_ASSERT
(
aDoc
"
need
a
non
-
null
document
"
)
;
nsRefreshDriver
*
refreshDriver
=
GetRefreshDriver
(
)
;
if
(
refreshDriver
)
{
mStartTime
=
refreshDriver
-
>
MostRecentRefresh
(
)
;
}
else
{
mStartTime
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
}
mCurrentSampleTime
=
mStartTime
;
Begin
(
)
;
}
nsSMILAnimationController
:
:
~
nsSMILAnimationController
(
)
{
NS_ASSERTION
(
mAnimationElementTable
.
Count
(
)
=
=
0
"
Animation
controller
shouldn
'
t
be
tracking
any
animation
"
"
elements
when
it
dies
"
)
;
NS_ASSERTION
(
!
mRegisteredWithRefreshDriver
"
Leaving
stale
entry
in
refresh
driver
'
s
observer
list
"
)
;
}
void
nsSMILAnimationController
:
:
Disconnect
(
)
{
MOZ_ASSERT
(
mDocument
"
disconnecting
when
we
weren
'
t
connected
.
.
.
?
"
)
;
MOZ_ASSERT
(
mRefCnt
.
get
(
)
=
=
1
"
Expecting
to
disconnect
when
doc
is
sole
remaining
owner
"
)
;
NS_ASSERTION
(
mPauseState
&
nsSMILTimeContainer
:
:
PAUSE_PAGEHIDE
"
Expecting
to
be
paused
for
pagehide
before
disconnect
"
)
;
StopSampling
(
GetRefreshDriver
(
)
)
;
mDocument
=
nullptr
;
}
void
nsSMILAnimationController
:
:
Pause
(
uint32_t
aType
)
{
nsSMILTimeContainer
:
:
Pause
(
aType
)
;
if
(
mPauseState
)
{
mDeferredStartSampling
=
false
;
StopSampling
(
GetRefreshDriver
(
)
)
;
}
}
void
nsSMILAnimationController
:
:
Resume
(
uint32_t
aType
)
{
bool
wasPaused
=
(
mPauseState
!
=
0
)
;
mCurrentSampleTime
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
nsSMILTimeContainer
:
:
Resume
(
aType
)
;
if
(
wasPaused
&
&
!
mPauseState
&
&
mChildContainerTable
.
Count
(
)
)
{
MaybeStartSampling
(
GetRefreshDriver
(
)
)
;
Sample
(
)
;
}
}
nsSMILTime
nsSMILAnimationController
:
:
GetParentTime
(
)
const
{
return
(
nsSMILTime
)
(
mCurrentSampleTime
-
mStartTime
)
.
ToMilliseconds
(
)
;
}
NS_IMPL_ADDREF
(
nsSMILAnimationController
)
NS_IMPL_RELEASE
(
nsSMILAnimationController
)
void
nsSMILAnimationController
:
:
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
{
aTime
=
std
:
:
max
(
mCurrentSampleTime
aTime
)
;
static
const
double
SAMPLE_DUR_WEIGHTING
=
0
.
2
;
static
const
double
SAMPLE_DEV_THRESHOLD
=
200
.
0
;
nsSMILTime
elapsedTime
=
(
nsSMILTime
)
(
aTime
-
mCurrentSampleTime
)
.
ToMilliseconds
(
)
;
if
(
mAvgTimeBetweenSamples
=
=
0
)
{
mAvgTimeBetweenSamples
=
elapsedTime
;
}
else
{
if
(
elapsedTime
>
SAMPLE_DEV_THRESHOLD
*
mAvgTimeBetweenSamples
)
{
NS_WARNING
(
"
Detected
really
long
delay
between
samples
continuing
from
"
"
previous
sample
"
)
;
mParentOffset
+
=
elapsedTime
-
mAvgTimeBetweenSamples
;
}
mAvgTimeBetweenSamples
=
(
nsSMILTime
)
(
elapsedTime
*
SAMPLE_DUR_WEIGHTING
+
mAvgTimeBetweenSamples
*
(
1
.
0
-
SAMPLE_DUR_WEIGHTING
)
)
;
}
mCurrentSampleTime
=
aTime
;
Sample
(
)
;
}
void
nsSMILAnimationController
:
:
RegisterAnimationElement
(
SVGAnimationElement
*
aAnimationElement
)
{
mAnimationElementTable
.
PutEntry
(
aAnimationElement
)
;
if
(
mDeferredStartSampling
)
{
mDeferredStartSampling
=
false
;
if
(
mChildContainerTable
.
Count
(
)
)
{
MOZ_ASSERT
(
mAnimationElementTable
.
Count
(
)
=
=
1
"
we
shouldn
'
t
have
deferred
sampling
if
we
already
had
"
"
animations
registered
"
)
;
StartSampling
(
GetRefreshDriver
(
)
)
;
Sample
(
)
;
}
}
}
void
nsSMILAnimationController
:
:
UnregisterAnimationElement
(
SVGAnimationElement
*
aAnimationElement
)
{
mAnimationElementTable
.
RemoveEntry
(
aAnimationElement
)
;
}
void
nsSMILAnimationController
:
:
OnPageShow
(
)
{
Resume
(
nsSMILTimeContainer
:
:
PAUSE_PAGEHIDE
)
;
}
void
nsSMILAnimationController
:
:
OnPageHide
(
)
{
Pause
(
nsSMILTimeContainer
:
:
PAUSE_PAGEHIDE
)
;
}
void
nsSMILAnimationController
:
:
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
)
{
if
(
mLastCompositorTable
)
{
for
(
auto
iter
=
mLastCompositorTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsSMILCompositor
*
compositor
=
iter
.
Get
(
)
;
compositor
-
>
Traverse
(
aCallback
)
;
}
}
}
void
nsSMILAnimationController
:
:
Unlink
(
)
{
mLastCompositorTable
=
nullptr
;
}
void
nsSMILAnimationController
:
:
NotifyRefreshDriverCreated
(
nsRefreshDriver
*
aRefreshDriver
)
{
if
(
!
mPauseState
)
{
MaybeStartSampling
(
aRefreshDriver
)
;
}
}
void
nsSMILAnimationController
:
:
NotifyRefreshDriverDestroying
(
nsRefreshDriver
*
aRefreshDriver
)
{
if
(
!
mPauseState
&
&
!
mDeferredStartSampling
)
{
StopSampling
(
aRefreshDriver
)
;
}
}
void
nsSMILAnimationController
:
:
StartSampling
(
nsRefreshDriver
*
aRefreshDriver
)
{
NS_ASSERTION
(
mPauseState
=
=
0
"
Starting
sampling
but
controller
is
paused
"
)
;
NS_ASSERTION
(
!
mDeferredStartSampling
"
Started
sampling
but
the
deferred
start
flag
is
still
set
"
)
;
if
(
aRefreshDriver
)
{
MOZ_ASSERT
(
!
mRegisteredWithRefreshDriver
"
Redundantly
registering
with
refresh
driver
"
)
;
MOZ_ASSERT
(
!
GetRefreshDriver
(
)
|
|
aRefreshDriver
=
=
GetRefreshDriver
(
)
"
Starting
sampling
with
wrong
refresh
driver
"
)
;
mCurrentSampleTime
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
aRefreshDriver
-
>
AddRefreshObserver
(
this
FlushType
:
:
Style
)
;
mRegisteredWithRefreshDriver
=
true
;
}
}
void
nsSMILAnimationController
:
:
StopSampling
(
nsRefreshDriver
*
aRefreshDriver
)
{
if
(
aRefreshDriver
&
&
mRegisteredWithRefreshDriver
)
{
MOZ_ASSERT
(
!
GetRefreshDriver
(
)
|
|
aRefreshDriver
=
=
GetRefreshDriver
(
)
"
Stopping
sampling
with
wrong
refresh
driver
"
)
;
aRefreshDriver
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
mRegisteredWithRefreshDriver
=
false
;
}
}
void
nsSMILAnimationController
:
:
MaybeStartSampling
(
nsRefreshDriver
*
aRefreshDriver
)
{
if
(
mDeferredStartSampling
)
{
return
;
}
if
(
mAnimationElementTable
.
Count
(
)
)
{
StartSampling
(
aRefreshDriver
)
;
}
else
{
mDeferredStartSampling
=
true
;
}
}
void
nsSMILAnimationController
:
:
DoSample
(
)
{
DoSample
(
true
)
;
}
void
nsSMILAnimationController
:
:
DoSample
(
bool
aSkipUnchangedContainers
)
{
if
(
!
mDocument
)
{
NS_ERROR
(
"
Shouldn
'
t
be
sampling
after
document
has
disconnected
"
)
;
return
;
}
if
(
mRunningSample
)
{
NS_ERROR
(
"
Shouldn
'
t
be
recursively
sampling
"
)
;
return
;
}
bool
isStyleFlushNeeded
=
mResampleNeeded
;
mResampleNeeded
=
false
;
nsCOMPtr
<
nsIDocument
>
document
(
mDocument
)
;
AutoRestore
<
bool
>
autoRestoreRunningSample
(
mRunningSample
)
;
mRunningSample
=
true
;
RewindElements
(
)
;
DoMilestoneSamples
(
)
;
TimeContainerHashtable
activeContainers
(
mChildContainerTable
.
Count
(
)
)
;
for
(
auto
iter
=
mChildContainerTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsSMILTimeContainer
*
container
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
if
(
!
container
)
{
continue
;
}
if
(
!
container
-
>
IsPausedByType
(
nsSMILTimeContainer
:
:
PAUSE_BEGIN
)
&
&
(
container
-
>
NeedsSample
(
)
|
|
!
aSkipUnchangedContainers
)
)
{
container
-
>
ClearMilestones
(
)
;
container
-
>
Sample
(
)
;
container
-
>
MarkSeekFinished
(
)
;
activeContainers
.
PutEntry
(
container
)
;
}
}
nsAutoPtr
<
nsSMILCompositorTable
>
currentCompositorTable
(
new
nsSMILCompositorTable
(
0
)
)
;
nsTArray
<
RefPtr
<
SVGAnimationElement
>
>
animElems
(
mAnimationElementTable
.
Count
(
)
)
;
for
(
auto
iter
=
mAnimationElementTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
SVGAnimationElement
*
animElem
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
SampleTimedElement
(
animElem
&
activeContainers
)
;
AddAnimationToCompositorTable
(
animElem
currentCompositorTable
isStyleFlushNeeded
)
;
animElems
.
AppendElement
(
animElem
)
;
}
activeContainers
.
Clear
(
)
;
if
(
mLastCompositorTable
)
{
for
(
auto
iter
=
currentCompositorTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsSMILCompositor
*
compositor
=
iter
.
Get
(
)
;
nsSMILCompositor
*
lastCompositor
=
mLastCompositorTable
-
>
GetEntry
(
compositor
-
>
GetKey
(
)
)
;
if
(
lastCompositor
)
{
compositor
-
>
StealCachedBaseValue
(
lastCompositor
)
;
}
}
for
(
auto
iter
=
currentCompositorTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
mLastCompositorTable
-
>
RemoveEntry
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
}
for
(
auto
iter
=
mLastCompositorTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Get
(
)
-
>
ClearAnimationEffects
(
)
;
}
}
if
(
currentCompositorTable
-
>
Count
(
)
=
=
0
)
{
mLastCompositorTable
=
nullptr
;
return
;
}
if
(
isStyleFlushNeeded
)
{
document
-
>
FlushPendingNotifications
(
FlushType
:
:
Style
)
;
}
bool
mightHavePendingStyleUpdates
=
false
;
for
(
auto
iter
=
currentCompositorTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Get
(
)
-
>
ComposeAttribute
(
mightHavePendingStyleUpdates
)
;
}
mLastCompositorTable
=
currentCompositorTable
.
forget
(
)
;
mMightHavePendingStyleUpdates
=
mightHavePendingStyleUpdates
;
NS_ASSERTION
(
!
mResampleNeeded
"
Resample
dirty
flag
set
during
sample
!
"
)
;
}
void
nsSMILAnimationController
:
:
RewindElements
(
)
{
bool
rewindNeeded
=
false
;
for
(
auto
iter
=
mChildContainerTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsSMILTimeContainer
*
container
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
if
(
container
-
>
NeedsRewind
(
)
)
{
rewindNeeded
=
true
;
break
;
}
}
if
(
!
rewindNeeded
)
return
;
for
(
auto
iter
=
mAnimationElementTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
SVGAnimationElement
*
animElem
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
nsSMILTimeContainer
*
timeContainer
=
animElem
-
>
GetTimeContainer
(
)
;
if
(
timeContainer
&
&
timeContainer
-
>
NeedsRewind
(
)
)
{
animElem
-
>
TimedElement
(
)
.
Rewind
(
)
;
}
}
for
(
auto
iter
=
mChildContainerTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
ClearNeedsRewind
(
)
;
}
}
void
nsSMILAnimationController
:
:
DoMilestoneSamples
(
)
{
nsSMILTime
sampleTime
=
INT64_MIN
;
while
(
true
)
{
nsSMILMilestone
nextMilestone
(
GetCurrentTime
(
)
+
1
true
)
;
for
(
auto
iter
=
mChildContainerTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsSMILTimeContainer
*
container
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
if
(
container
-
>
IsPausedByType
(
nsSMILTimeContainer
:
:
PAUSE_BEGIN
)
)
{
continue
;
}
nsSMILMilestone
thisMilestone
;
bool
didGetMilestone
=
container
-
>
GetNextMilestoneInParentTime
(
thisMilestone
)
;
if
(
didGetMilestone
&
&
thisMilestone
<
nextMilestone
)
{
nextMilestone
=
thisMilestone
;
}
}
if
(
nextMilestone
.
mTime
>
GetCurrentTime
(
)
)
{
break
;
}
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
SVGAnimationElement
>
>
elements
;
for
(
auto
iter
=
mChildContainerTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsSMILTimeContainer
*
container
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
if
(
container
-
>
IsPausedByType
(
nsSMILTimeContainer
:
:
PAUSE_BEGIN
)
)
{
continue
;
}
container
-
>
PopMilestoneElementsAtMilestone
(
nextMilestone
elements
)
;
}
uint32_t
length
=
elements
.
Length
(
)
;
sampleTime
=
std
:
:
max
(
nextMilestone
.
mTime
sampleTime
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
SVGAnimationElement
*
elem
=
elements
[
i
]
.
get
(
)
;
MOZ_ASSERT
(
elem
"
nullptr
animation
element
in
list
"
)
;
nsSMILTimeContainer
*
container
=
elem
-
>
GetTimeContainer
(
)
;
if
(
!
container
)
continue
;
nsSMILTimeValue
containerTimeValue
=
container
-
>
ParentToContainerTime
(
sampleTime
)
;
if
(
!
containerTimeValue
.
IsDefinite
(
)
)
continue
;
nsSMILTime
containerTime
=
std
:
:
max
<
nsSMILTime
>
(
0
containerTimeValue
.
GetMillis
(
)
)
;
if
(
nextMilestone
.
mIsEnd
)
{
elem
-
>
TimedElement
(
)
.
SampleEndAt
(
containerTime
)
;
}
else
{
elem
-
>
TimedElement
(
)
.
SampleAt
(
containerTime
)
;
}
}
}
}
void
nsSMILAnimationController
:
:
SampleTimedElement
(
SVGAnimationElement
*
aElement
TimeContainerHashtable
*
aActiveContainers
)
{
nsSMILTimeContainer
*
timeContainer
=
aElement
-
>
GetTimeContainer
(
)
;
if
(
!
timeContainer
)
return
;
if
(
!
aActiveContainers
-
>
GetEntry
(
timeContainer
)
)
return
;
nsSMILTime
containerTime
=
timeContainer
-
>
GetCurrentTime
(
)
;
MOZ_ASSERT
(
!
timeContainer
-
>
IsSeeking
(
)
"
Doing
a
regular
sample
but
the
time
container
is
still
seeking
"
)
;
aElement
-
>
TimedElement
(
)
.
SampleAt
(
containerTime
)
;
}
void
nsSMILAnimationController
:
:
AddAnimationToCompositorTable
(
SVGAnimationElement
*
aElement
nsSMILCompositorTable
*
aCompositorTable
bool
&
aStyleFlushNeeded
)
{
nsSMILTargetIdentifier
key
;
if
(
!
GetTargetIdentifierForAnimation
(
aElement
key
)
)
return
;
nsSMILAnimationFunction
&
func
=
aElement
-
>
AnimationFunction
(
)
;
if
(
func
.
IsActiveOrFrozen
(
)
)
{
nsSMILCompositor
*
result
=
aCompositorTable
-
>
PutEntry
(
key
)
;
result
-
>
AddAnimationFunction
(
&
func
)
;
}
else
if
(
func
.
HasChanged
(
)
)
{
nsSMILCompositor
*
result
=
aCompositorTable
-
>
PutEntry
(
key
)
;
result
-
>
ToggleForceCompositing
(
)
;
func
.
ClearHasChanged
(
)
;
}
aStyleFlushNeeded
|
=
func
.
ValueNeedsReparsingEverySample
(
)
;
}
static
inline
bool
IsTransformAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttributeName
)
{
return
aNamespaceID
=
=
kNameSpaceID_None
&
&
(
aAttributeName
=
=
nsGkAtoms
:
:
transform
|
|
aAttributeName
=
=
nsGkAtoms
:
:
patternTransform
|
|
aAttributeName
=
=
nsGkAtoms
:
:
gradientTransform
)
;
}
bool
nsSMILAnimationController
:
:
GetTargetIdentifierForAnimation
(
SVGAnimationElement
*
aAnimElem
nsSMILTargetIdentifier
&
aResult
)
{
Element
*
targetElem
=
aAnimElem
-
>
GetTargetElementContent
(
)
;
if
(
!
targetElem
)
return
false
;
RefPtr
<
nsAtom
>
attributeName
;
int32_t
attributeNamespaceID
;
if
(
!
aAnimElem
-
>
GetTargetAttributeName
(
&
attributeNamespaceID
getter_AddRefs
(
attributeName
)
)
)
return
false
;
if
(
IsTransformAttribute
(
attributeNamespaceID
attributeName
)
!
=
(
aAnimElem
-
>
IsSVGElement
(
nsGkAtoms
:
:
animateTransform
)
)
)
return
false
;
aResult
.
mElement
=
targetElem
;
aResult
.
mAttributeName
=
attributeName
;
aResult
.
mAttributeNamespaceID
=
attributeNamespaceID
;
return
true
;
}
void
nsSMILAnimationController
:
:
AddStyleUpdatesTo
(
RestyleTracker
&
aTracker
)
{
MOZ_ASSERT
(
mMightHavePendingStyleUpdates
"
Should
only
add
style
updates
when
we
think
we
might
have
some
"
)
;
for
(
auto
iter
=
mAnimationElementTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
SVGAnimationElement
*
animElement
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
nsSMILTargetIdentifier
key
;
if
(
!
GetTargetIdentifierForAnimation
(
animElement
key
)
)
{
continue
;
}
aTracker
.
AddPendingRestyle
(
key
.
mElement
eRestyle_StyleAttribute_Animations
nsChangeHint
(
0
)
)
;
}
mMightHavePendingStyleUpdates
=
false
;
}
bool
nsSMILAnimationController
:
:
PreTraverse
(
)
{
return
PreTraverseInSubtree
(
nullptr
)
;
}
bool
nsSMILAnimationController
:
:
PreTraverseInSubtree
(
Element
*
aRoot
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mMightHavePendingStyleUpdates
)
{
return
false
;
}
nsPresContext
*
context
=
mDocument
-
>
GetPresContext
(
)
;
if
(
!
context
)
{
return
false
;
}
MOZ_ASSERT
(
context
-
>
RestyleManager
(
)
-
>
IsServo
(
)
"
PreTraverse
should
only
be
called
for
the
servo
style
system
"
)
;
bool
foundElementsNeedingRestyle
=
false
;
for
(
auto
iter
=
mAnimationElementTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
SVGAnimationElement
*
animElement
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
nsSMILTargetIdentifier
key
;
if
(
!
GetTargetIdentifierForAnimation
(
animElement
key
)
)
{
continue
;
}
if
(
aRoot
&
&
!
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOf
(
key
.
mElement
aRoot
)
)
{
continue
;
}
context
-
>
RestyleManager
(
)
-
>
AsServo
(
)
-
>
PostRestyleEventForAnimations
(
key
.
mElement
CSSPseudoElementType
:
:
NotPseudo
eRestyle_StyleAttribute_Animations
)
;
foundElementsNeedingRestyle
=
true
;
}
if
(
!
aRoot
)
{
mMightHavePendingStyleUpdates
=
false
;
}
return
foundElementsNeedingRestyle
;
}
nsresult
nsSMILAnimationController
:
:
AddChild
(
nsSMILTimeContainer
&
aChild
)
{
TimeContainerPtrKey
*
key
=
mChildContainerTable
.
PutEntry
(
&
aChild
)
;
NS_ENSURE_TRUE
(
key
NS_ERROR_OUT_OF_MEMORY
)
;
if
(
!
mPauseState
&
&
mChildContainerTable
.
Count
(
)
=
=
1
)
{
MaybeStartSampling
(
GetRefreshDriver
(
)
)
;
Sample
(
)
;
}
return
NS_OK
;
}
void
nsSMILAnimationController
:
:
RemoveChild
(
nsSMILTimeContainer
&
aChild
)
{
mChildContainerTable
.
RemoveEntry
(
&
aChild
)
;
if
(
!
mPauseState
&
&
mChildContainerTable
.
Count
(
)
=
=
0
)
{
StopSampling
(
GetRefreshDriver
(
)
)
;
}
}
nsRefreshDriver
*
nsSMILAnimationController
:
:
GetRefreshDriver
(
)
{
if
(
!
mDocument
)
{
NS_ERROR
(
"
Requesting
refresh
driver
after
document
has
disconnected
!
"
)
;
return
nullptr
;
}
nsPresContext
*
context
=
mDocument
-
>
GetPresContext
(
)
;
return
context
?
context
-
>
RefreshDriver
(
)
:
nullptr
;
}
void
nsSMILAnimationController
:
:
FlagDocumentNeedsFlush
(
)
{
if
(
nsIPresShell
*
shell
=
mDocument
-
>
GetShell
(
)
)
{
shell
-
>
SetNeedStyleFlush
(
)
;
}
}
