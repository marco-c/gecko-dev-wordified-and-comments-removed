#
ifndef
NS_SMILANIMATIONFUNCTION_H_
#
define
NS_SMILANIMATIONFUNCTION_H_
#
include
"
mozilla
/
SMILAttr
.
h
"
#
include
"
mozilla
/
SMILKeySpline
.
h
"
#
include
"
mozilla
/
SMILTargetIdentifier
.
h
"
#
include
"
mozilla
/
SMILTimeValue
.
h
"
#
include
"
mozilla
/
SMILTypes
.
h
"
#
include
"
mozilla
/
SMILValue
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
dom
{
class
SVGAnimationElement
;
}
class
SMILAnimationFunction
{
public
:
SMILAnimationFunction
(
)
;
void
SetAnimationElement
(
mozilla
:
:
dom
:
:
SVGAnimationElement
*
aAnimationElement
)
;
virtual
bool
SetAttr
(
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsAttrValue
&
aResult
nsresult
*
aParseResult
=
nullptr
)
;
virtual
bool
UnsetAttr
(
nsAtom
*
aAttribute
)
;
void
SampleAt
(
SMILTime
aSampleTime
const
SMILTimeValue
&
aSimpleDuration
uint32_t
aRepeatIteration
)
;
void
SampleLastValue
(
uint32_t
aRepeatIteration
)
;
void
Activate
(
SMILTime
aBeginTime
)
;
void
Inactivate
(
bool
aIsFrozen
)
;
void
ComposeResult
(
const
SMILAttr
&
aSMILAttr
SMILValue
&
aResult
)
;
int8_t
CompareTo
(
const
SMILAnimationFunction
*
aOther
)
const
;
bool
IsActiveOrFrozen
(
)
const
{
return
(
mIsActive
|
|
mIsFrozen
)
;
}
bool
IsActive
(
)
const
{
return
mIsActive
;
}
virtual
bool
WillReplace
(
)
const
;
bool
HasChanged
(
)
const
;
void
ClearHasChanged
(
)
{
MOZ_ASSERT
(
HasChanged
(
)
"
clearing
mHasChanged
flag
when
it
'
s
already
false
"
)
;
MOZ_ASSERT
(
!
IsActiveOrFrozen
(
)
"
clearing
mHasChanged
flag
for
active
animation
"
)
;
mHasChanged
=
false
;
}
bool
UpdateCachedTarget
(
const
SMILTargetIdentifier
&
aNewTarget
)
;
bool
WasSkippedInPrevSample
(
)
const
{
return
mWasSkippedInPrevSample
;
}
void
SetWasSkipped
(
)
{
mWasSkippedInPrevSample
=
true
;
}
bool
ValueNeedsReparsingEverySample
(
)
const
{
return
mValueNeedsReparsingEverySample
;
}
class
Comparator
{
public
:
bool
Equals
(
const
SMILAnimationFunction
*
aElem1
const
SMILAnimationFunction
*
aElem2
)
const
{
return
(
aElem1
-
>
CompareTo
(
aElem2
)
=
=
0
)
;
}
bool
LessThan
(
const
SMILAnimationFunction
*
aElem1
const
SMILAnimationFunction
*
aElem2
)
const
{
return
(
aElem1
-
>
CompareTo
(
aElem2
)
<
0
)
;
}
}
;
protected
:
typedef
FallibleTArray
<
SMILValue
>
SMILValueArray
;
enum
SMILCalcMode
:
uint8_t
{
CALC_LINEAR
CALC_DISCRETE
CALC_PACED
CALC_SPLINE
}
;
SMILTime
GetBeginTime
(
)
const
{
return
mBeginTime
;
}
bool
GetAccumulate
(
)
const
;
bool
GetAdditive
(
)
const
;
virtual
SMILCalcMode
GetCalcMode
(
)
const
;
nsresult
SetAccumulate
(
const
nsAString
&
aAccumulate
nsAttrValue
&
aResult
)
;
nsresult
SetAdditive
(
const
nsAString
&
aAdditive
nsAttrValue
&
aResult
)
;
nsresult
SetCalcMode
(
const
nsAString
&
aCalcMode
nsAttrValue
&
aResult
)
;
nsresult
SetKeyTimes
(
const
nsAString
&
aKeyTimes
nsAttrValue
&
aResult
)
;
nsresult
SetKeySplines
(
const
nsAString
&
aKeySplines
nsAttrValue
&
aResult
)
;
void
UnsetAccumulate
(
)
;
void
UnsetAdditive
(
)
;
void
UnsetCalcMode
(
)
;
void
UnsetKeyTimes
(
)
;
void
UnsetKeySplines
(
)
;
virtual
nsresult
InterpolateResult
(
const
SMILValueArray
&
aValues
SMILValue
&
aResult
SMILValue
&
aBaseValue
)
;
nsresult
AccumulateResult
(
const
SMILValueArray
&
aValues
SMILValue
&
aResult
)
;
nsresult
ComputePacedPosition
(
const
SMILValueArray
&
aValues
double
aSimpleProgress
double
&
aIntervalProgress
const
SMILValue
*
&
aFrom
const
SMILValue
*
&
aTo
)
;
double
ComputePacedTotalDistance
(
const
SMILValueArray
&
aValues
)
const
;
double
ScaleSimpleProgress
(
double
aProgress
SMILCalcMode
aCalcMode
)
;
double
ScaleIntervalProgress
(
double
aProgress
uint32_t
aIntervalIndex
)
;
virtual
bool
HasAttr
(
nsAtom
*
aAttName
)
const
;
virtual
const
nsAttrValue
*
GetAttr
(
nsAtom
*
aAttName
)
const
;
virtual
bool
GetAttr
(
nsAtom
*
aAttName
nsAString
&
aResult
)
const
;
bool
ParseAttr
(
nsAtom
*
aAttName
const
SMILAttr
&
aSMILAttr
SMILValue
&
aResult
bool
&
aPreventCachingOfSandwich
)
const
;
virtual
nsresult
GetValues
(
const
SMILAttr
&
aSMILAttr
SMILValueArray
&
aResult
)
;
virtual
void
CheckValueListDependentAttrs
(
uint32_t
aNumValues
)
;
void
CheckKeyTimes
(
uint32_t
aNumValues
)
;
void
CheckKeySplines
(
uint32_t
aNumValues
)
;
virtual
bool
IsToAnimation
(
)
const
{
return
!
HasAttr
(
nsGkAtoms
:
:
values
)
&
&
HasAttr
(
nsGkAtoms
:
:
to
)
&
&
!
HasAttr
(
nsGkAtoms
:
:
from
)
;
}
virtual
bool
IsValueFixedForSimpleDuration
(
)
const
;
inline
bool
IsAdditive
(
)
const
{
bool
isByAnimation
=
(
!
HasAttr
(
nsGkAtoms
:
:
values
)
&
&
HasAttr
(
nsGkAtoms
:
:
by
)
&
&
!
HasAttr
(
nsGkAtoms
:
:
from
)
)
;
return
!
IsToAnimation
(
)
&
&
(
GetAdditive
(
)
|
|
isByAnimation
)
;
}
enum
AnimationAttributeIdx
{
BF_ACCUMULATE
=
0
BF_ADDITIVE
=
1
BF_CALC_MODE
=
2
BF_KEY_TIMES
=
3
BF_KEY_SPLINES
=
4
BF_KEY_POINTS
=
5
}
;
inline
void
SetAccumulateErrorFlag
(
bool
aNewValue
)
{
SetErrorFlag
(
BF_ACCUMULATE
aNewValue
)
;
}
inline
void
SetAdditiveErrorFlag
(
bool
aNewValue
)
{
SetErrorFlag
(
BF_ADDITIVE
aNewValue
)
;
}
inline
void
SetCalcModeErrorFlag
(
bool
aNewValue
)
{
SetErrorFlag
(
BF_CALC_MODE
aNewValue
)
;
}
inline
void
SetKeyTimesErrorFlag
(
bool
aNewValue
)
{
SetErrorFlag
(
BF_KEY_TIMES
aNewValue
)
;
}
inline
void
SetKeySplinesErrorFlag
(
bool
aNewValue
)
{
SetErrorFlag
(
BF_KEY_SPLINES
aNewValue
)
;
}
inline
void
SetKeyPointsErrorFlag
(
bool
aNewValue
)
{
SetErrorFlag
(
BF_KEY_POINTS
aNewValue
)
;
}
inline
void
SetErrorFlag
(
AnimationAttributeIdx
aField
bool
aValue
)
{
if
(
aValue
)
{
mErrorFlags
|
=
(
0x01
<
<
aField
)
;
}
else
{
mErrorFlags
&
=
~
(
0x01
<
<
aField
)
;
}
}
static
nsAttrValue
:
:
EnumTable
sAdditiveTable
[
]
;
static
nsAttrValue
:
:
EnumTable
sCalcModeTable
[
]
;
static
nsAttrValue
:
:
EnumTable
sAccumulateTable
[
]
;
FallibleTArray
<
double
>
mKeyTimes
;
FallibleTArray
<
SMILKeySpline
>
mKeySplines
;
SMILTime
mSampleTime
;
SMILTimeValue
mSimpleDuration
;
uint32_t
mRepeatIteration
;
SMILTime
mBeginTime
;
mozilla
:
:
dom
:
:
SVGAnimationElement
*
mAnimationElement
;
uint16_t
mErrorFlags
;
SMILWeakTargetIdentifier
mLastTarget
;
bool
mIsActive
:
1
;
bool
mIsFrozen
:
1
;
bool
mLastValue
:
1
;
bool
mHasChanged
:
1
;
bool
mValueNeedsReparsingEverySample
:
1
;
bool
mPrevSampleWasSingleValueAnimation
:
1
;
bool
mWasSkippedInPrevSample
:
1
;
}
;
}
#
endif
