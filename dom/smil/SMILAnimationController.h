#
ifndef
DOM_SMIL_SMILANIMATIONCONTROLLER_H_
#
define
DOM_SMIL_SMILANIMATIONCONTROLLER_H_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
SMILCompositorTable
.
h
"
#
include
"
mozilla
/
SMILMilestone
.
h
"
#
include
"
mozilla
/
SMILTimeContainer
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsRefreshObservers
.
h
"
class
nsRefreshDriver
;
namespace
mozilla
{
struct
SMILTargetIdentifier
;
namespace
dom
{
class
Element
;
class
SVGAnimationElement
;
}
class
SMILAnimationController
final
:
public
SMILTimeContainer
public
nsARefreshObserver
{
public
:
explicit
SMILAnimationController
(
mozilla
:
:
dom
:
:
Document
*
aDoc
)
;
using
DiscardArray
=
nsTObserverArray
<
RefPtr
<
dom
:
:
Element
>
>
;
void
Disconnect
(
)
;
void
Pause
(
uint32_t
aType
)
override
;
void
Resume
(
uint32_t
aType
)
override
;
SMILTime
GetParentTime
(
)
const
override
;
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
)
override
;
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
)
override
;
void
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
override
;
void
RegisterAnimationElement
(
mozilla
:
:
dom
:
:
SVGAnimationElement
*
aAnimationElement
)
;
void
UnregisterAnimationElement
(
mozilla
:
:
dom
:
:
SVGAnimationElement
*
aAnimationElement
)
;
void
Resample
(
)
{
DoSample
(
false
)
;
}
void
SetResampleNeeded
(
)
{
if
(
!
mRunningSample
&
&
!
mResampleNeeded
)
{
FlagDocumentNeedsFlush
(
)
;
mResampleNeeded
=
true
;
}
}
void
FlushResampleRequests
(
)
{
if
(
!
mResampleNeeded
)
return
;
Resample
(
)
;
}
void
OnPageShow
(
)
;
void
OnPageHide
(
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
)
;
void
Unlink
(
)
;
void
NotifyRefreshDriverCreated
(
nsRefreshDriver
*
aRefreshDriver
)
;
void
NotifyRefreshDriverDestroying
(
nsRefreshDriver
*
aRefreshDriver
)
;
bool
HasRegisteredAnimations
(
)
const
{
return
mAnimationElementTable
.
Count
(
)
!
=
0
;
}
bool
MightHavePendingStyleUpdates
(
)
const
{
return
mMightHavePendingStyleUpdates
;
}
void
PreTraverse
(
)
;
void
PreTraverseInSubtree
(
mozilla
:
:
dom
:
:
Element
*
aRoot
)
;
protected
:
~
SMILAnimationController
(
)
;
using
TimeContainerPtrKey
=
nsPtrHashKey
<
SMILTimeContainer
>
;
using
TimeContainerHashtable
=
nsTHashtable
<
TimeContainerPtrKey
>
;
using
AnimationElementPtrKey
=
nsPtrHashKey
<
dom
:
:
SVGAnimationElement
>
;
using
AnimationElementHashtable
=
nsTHashtable
<
AnimationElementPtrKey
>
;
nsRefreshDriver
*
GetRefreshDriver
(
)
;
void
UpdateSampling
(
)
;
bool
ShouldSample
(
)
const
;
void
StopSampling
(
nsRefreshDriver
*
aRefreshDriver
)
;
void
MaybeStartSampling
(
nsRefreshDriver
*
aRefreshDriver
)
;
void
DoSample
(
)
override
;
void
DoSample
(
bool
aSkipUnchangedContainers
)
;
void
RewindElements
(
)
;
void
DoMilestoneSamples
(
)
;
static
void
SampleTimedElement
(
dom
:
:
SVGAnimationElement
*
aElement
DiscardArray
&
aDiscards
TimeContainerHashtable
*
aActiveContainers
)
;
static
void
AddAnimationToCompositorTable
(
mozilla
:
:
dom
:
:
SVGAnimationElement
*
aElement
SMILCompositorTable
*
aCompositorTable
)
;
static
bool
GetTargetIdentifierForAnimation
(
mozilla
:
:
dom
:
:
SVGAnimationElement
*
aAnimElem
SMILTargetIdentifier
&
aResult
)
;
nsresult
AddChild
(
SMILTimeContainer
&
aChild
)
override
;
void
RemoveChild
(
SMILTimeContainer
&
aChild
)
override
;
void
FlagDocumentNeedsFlush
(
)
;
nsAutoRefCnt
mRefCnt
;
NS_DECL_OWNINGTHREAD
AnimationElementHashtable
mAnimationElementTable
;
TimeContainerHashtable
mChildContainerTable
;
mozilla
:
:
TimeStamp
mCurrentSampleTime
;
mozilla
:
:
TimeStamp
mStartTime
;
SMILTime
mAvgTimeBetweenSamples
=
0
;
bool
mResampleNeeded
=
false
;
bool
mRunningSample
=
false
;
bool
mRegisteredWithRefreshDriver
=
false
;
bool
mMightHavePendingStyleUpdates
=
false
;
mozilla
:
:
dom
:
:
Document
*
mDocument
;
UniquePtr
<
SMILCompositorTable
>
mLastCompositorTable
;
}
;
}
#
endif
