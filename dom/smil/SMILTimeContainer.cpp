#
include
"
SMILTimeContainer
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
SMILTimedElement
.
h
"
#
include
"
mozilla
/
SMILTimeValue
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
SMILTimeContainer
:
:
SMILTimeContainer
(
)
:
mParent
(
nullptr
)
mCurrentTime
(
0L
)
mParentOffset
(
0L
)
mPauseStart
(
0L
)
mNeedsPauseSample
(
false
)
mNeedsRewind
(
false
)
mIsSeeking
(
false
)
#
ifdef
DEBUG
mHoldingEntries
(
false
)
#
endif
mPauseState
(
PAUSE_BEGIN
)
{
}
SMILTimeContainer
:
:
~
SMILTimeContainer
(
)
{
if
(
mParent
)
{
mParent
-
>
RemoveChild
(
*
this
)
;
}
}
SMILTimeValue
SMILTimeContainer
:
:
ContainerToParentTime
(
SMILTime
aContainerTime
)
const
{
if
(
IsPaused
(
)
&
&
aContainerTime
>
mCurrentTime
)
return
SMILTimeValue
:
:
Indefinite
(
)
;
return
SMILTimeValue
(
aContainerTime
+
mParentOffset
)
;
}
SMILTimeValue
SMILTimeContainer
:
:
ParentToContainerTime
(
SMILTime
aParentTime
)
const
{
if
(
IsPaused
(
)
&
&
aParentTime
>
mPauseStart
)
return
SMILTimeValue
:
:
Indefinite
(
)
;
return
SMILTimeValue
(
aParentTime
-
mParentOffset
)
;
}
void
SMILTimeContainer
:
:
Begin
(
)
{
Resume
(
PAUSE_BEGIN
)
;
if
(
mPauseState
)
{
mNeedsPauseSample
=
true
;
}
UpdateCurrentTime
(
)
;
}
void
SMILTimeContainer
:
:
Pause
(
uint32_t
aType
)
{
bool
didStartPause
=
false
;
if
(
!
mPauseState
&
&
aType
)
{
mPauseStart
=
GetParentTime
(
)
;
mNeedsPauseSample
=
true
;
didStartPause
=
true
;
}
mPauseState
|
=
aType
;
if
(
didStartPause
)
{
NotifyTimeChange
(
)
;
}
}
void
SMILTimeContainer
:
:
Resume
(
uint32_t
aType
)
{
if
(
!
mPauseState
)
return
;
mPauseState
&
=
~
aType
;
if
(
!
mPauseState
)
{
SMILTime
extraOffset
=
GetParentTime
(
)
-
mPauseStart
;
mParentOffset
+
=
extraOffset
;
NotifyTimeChange
(
)
;
}
}
SMILTime
SMILTimeContainer
:
:
GetCurrentTimeAsSMILTime
(
)
const
{
if
(
IsPausedByType
(
PAUSE_BEGIN
)
)
return
0L
;
return
mCurrentTime
;
}
void
SMILTimeContainer
:
:
SetCurrentTime
(
SMILTime
aSeekTo
)
{
aSeekTo
=
std
:
:
max
<
SMILTime
>
(
0
aSeekTo
)
;
SMILTime
parentTime
=
GetParentTime
(
)
;
mParentOffset
=
parentTime
-
aSeekTo
;
mIsSeeking
=
true
;
if
(
IsPaused
(
)
)
{
mNeedsPauseSample
=
true
;
mPauseStart
=
parentTime
;
}
if
(
aSeekTo
<
mCurrentTime
)
{
mNeedsRewind
=
true
;
ClearMilestones
(
)
;
}
UpdateCurrentTime
(
)
;
NotifyTimeChange
(
)
;
}
SMILTime
SMILTimeContainer
:
:
GetParentTime
(
)
const
{
if
(
mParent
)
return
mParent
-
>
GetCurrentTimeAsSMILTime
(
)
;
return
0L
;
}
void
SMILTimeContainer
:
:
SyncPauseTime
(
)
{
if
(
IsPaused
(
)
)
{
SMILTime
parentTime
=
GetParentTime
(
)
;
SMILTime
extraOffset
=
parentTime
-
mPauseStart
;
mParentOffset
+
=
extraOffset
;
mPauseStart
=
parentTime
;
}
}
void
SMILTimeContainer
:
:
Sample
(
)
{
if
(
!
NeedsSample
(
)
)
return
;
UpdateCurrentTime
(
)
;
DoSample
(
)
;
mNeedsPauseSample
=
false
;
}
nsresult
SMILTimeContainer
:
:
SetParent
(
SMILTimeContainer
*
aParent
)
{
if
(
mParent
)
{
mParent
-
>
RemoveChild
(
*
this
)
;
mParentOffset
=
-
mCurrentTime
;
mPauseStart
=
0L
;
}
mParent
=
aParent
;
nsresult
rv
=
NS_OK
;
if
(
mParent
)
{
rv
=
mParent
-
>
AddChild
(
*
this
)
;
}
return
rv
;
}
bool
SMILTimeContainer
:
:
AddMilestone
(
const
SMILMilestone
&
aMilestone
mozilla
:
:
dom
:
:
SVGAnimationElement
&
aElement
)
{
MOZ_ASSERT
(
!
mHoldingEntries
)
;
return
mMilestoneEntries
.
Push
(
MilestoneEntry
(
aMilestone
aElement
)
)
;
}
void
SMILTimeContainer
:
:
ClearMilestones
(
)
{
MOZ_ASSERT
(
!
mHoldingEntries
)
;
mMilestoneEntries
.
Clear
(
)
;
}
bool
SMILTimeContainer
:
:
GetNextMilestoneInParentTime
(
SMILMilestone
&
aNextMilestone
)
const
{
if
(
mMilestoneEntries
.
IsEmpty
(
)
)
return
false
;
SMILTimeValue
parentTime
=
ContainerToParentTime
(
mMilestoneEntries
.
Top
(
)
.
mMilestone
.
mTime
)
;
if
(
!
parentTime
.
IsDefinite
(
)
)
return
false
;
aNextMilestone
=
SMILMilestone
(
parentTime
.
GetMillis
(
)
mMilestoneEntries
.
Top
(
)
.
mMilestone
.
mIsEnd
)
;
return
true
;
}
bool
SMILTimeContainer
:
:
PopMilestoneElementsAtMilestone
(
const
SMILMilestone
&
aMilestone
AnimElemArray
&
aMatchedElements
)
{
if
(
mMilestoneEntries
.
IsEmpty
(
)
)
return
false
;
SMILTimeValue
containerTime
=
ParentToContainerTime
(
aMilestone
.
mTime
)
;
if
(
!
containerTime
.
IsDefinite
(
)
)
return
false
;
SMILMilestone
containerMilestone
(
containerTime
.
GetMillis
(
)
aMilestone
.
mIsEnd
)
;
MOZ_ASSERT
(
mMilestoneEntries
.
Top
(
)
.
mMilestone
>
=
containerMilestone
"
Trying
to
pop
off
earliest
times
but
we
have
earlier
ones
that
"
"
were
overlooked
"
)
;
MOZ_ASSERT
(
!
mHoldingEntries
)
;
bool
gotOne
=
false
;
while
(
!
mMilestoneEntries
.
IsEmpty
(
)
&
&
mMilestoneEntries
.
Top
(
)
.
mMilestone
=
=
containerMilestone
)
{
aMatchedElements
.
AppendElement
(
mMilestoneEntries
.
Pop
(
)
.
mTimebase
)
;
gotOne
=
true
;
}
return
gotOne
;
}
void
SMILTimeContainer
:
:
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
)
{
#
ifdef
DEBUG
AutoRestore
<
bool
>
saveHolding
(
mHoldingEntries
)
;
mHoldingEntries
=
true
;
#
endif
const
MilestoneEntry
*
p
=
mMilestoneEntries
.
Elements
(
)
;
while
(
p
<
mMilestoneEntries
.
Elements
(
)
+
mMilestoneEntries
.
Length
(
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
*
aCallback
"
mTimebase
"
)
;
aCallback
-
>
NoteXPCOMChild
(
static_cast
<
nsIContent
*
>
(
p
-
>
mTimebase
.
get
(
)
)
)
;
+
+
p
;
}
}
void
SMILTimeContainer
:
:
Unlink
(
)
{
MOZ_ASSERT
(
!
mHoldingEntries
)
;
mMilestoneEntries
.
Clear
(
)
;
}
void
SMILTimeContainer
:
:
UpdateCurrentTime
(
)
{
SMILTime
now
=
IsPaused
(
)
?
mPauseStart
:
GetParentTime
(
)
;
mCurrentTime
=
now
-
mParentOffset
;
MOZ_ASSERT
(
mCurrentTime
>
=
0
"
Container
has
negative
time
"
)
;
}
void
SMILTimeContainer
:
:
NotifyTimeChange
(
)
{
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
SVGAnimationElement
>
>
elems
;
{
#
ifdef
DEBUG
AutoRestore
<
bool
>
saveHolding
(
mHoldingEntries
)
;
mHoldingEntries
=
true
;
#
endif
for
(
const
MilestoneEntry
*
p
=
mMilestoneEntries
.
Elements
(
)
;
p
<
mMilestoneEntries
.
Elements
(
)
+
mMilestoneEntries
.
Length
(
)
;
+
+
p
)
{
elems
.
AppendElement
(
p
-
>
mTimebase
.
get
(
)
)
;
}
}
for
(
auto
&
elem
:
elems
)
{
elem
-
>
TimedElement
(
)
.
HandleContainerTimeChange
(
)
;
}
}
}
