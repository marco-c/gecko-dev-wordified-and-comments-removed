#
include
"
nsSMILCSSValueType
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsSMILParserUtils
.
h
"
#
include
"
nsSMILValue
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
Keyframe
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoComputedValuesWithParent
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
StyleSetHandleInlines
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsIDocument
.
h
"
using
namespace
mozilla
:
:
dom
;
using
mozilla
:
:
StyleAnimationValue
;
nsSMILCSSValueType
nsSMILCSSValueType
:
:
sSingleton
;
struct
ValueWrapper
{
ValueWrapper
(
nsCSSPropertyID
aPropID
const
AnimationValue
&
aValue
)
:
mPropID
(
aPropID
)
mCSSValue
(
aValue
)
{
}
ValueWrapper
(
nsCSSPropertyID
aPropID
const
StyleAnimationValue
&
aValue
)
:
mPropID
(
aPropID
)
mCSSValue
(
aValue
)
{
}
ValueWrapper
(
nsCSSPropertyID
aPropID
const
RefPtr
<
RawServoAnimationValue
>
&
aValue
)
:
mPropID
(
aPropID
)
mCSSValue
(
aValue
)
{
}
nsCSSPropertyID
mPropID
;
AnimationValue
mCSSValue
;
}
;
static
const
AnimationValue
*
GetZeroValueForUnit
(
StyleAnimationValue
:
:
Unit
aUnit
)
{
static
const
AnimationValue
sZeroCoord
(
StyleAnimationValue
(
0
StyleAnimationValue
:
:
CoordConstructor
)
)
;
static
const
AnimationValue
sZeroPercent
(
StyleAnimationValue
(
0
.
0f
StyleAnimationValue
:
:
PercentConstructor
)
)
;
static
const
AnimationValue
sZeroFloat
(
StyleAnimationValue
(
0
.
0f
StyleAnimationValue
:
:
FloatConstructor
)
)
;
static
const
AnimationValue
sZeroColor
(
StyleAnimationValue
(
NS_RGB
(
0
0
0
)
StyleAnimationValue
:
:
ColorConstructor
)
)
;
MOZ_ASSERT
(
aUnit
!
=
StyleAnimationValue
:
:
eUnit_Null
"
Need
non
-
null
unit
for
a
zero
value
"
)
;
switch
(
aUnit
)
{
case
StyleAnimationValue
:
:
eUnit_Coord
:
return
&
sZeroCoord
;
case
StyleAnimationValue
:
:
eUnit_Percent
:
return
&
sZeroPercent
;
case
StyleAnimationValue
:
:
eUnit_Float
:
return
&
sZeroFloat
;
case
StyleAnimationValue
:
:
eUnit_Color
:
return
&
sZeroColor
;
default
:
return
nullptr
;
}
}
static
bool
FinalizeStyleAnimationValues
(
const
AnimationValue
*
&
aValue1
const
AnimationValue
*
&
aValue2
)
{
MOZ_ASSERT
(
aValue1
|
|
aValue2
"
expecting
at
least
one
non
-
null
value
"
)
;
MOZ_ASSERT
(
!
aValue1
|
|
!
aValue2
|
|
!
aValue1
-
>
mServo
=
=
!
aValue2
-
>
mServo
"
If
both
values
are
specified
they
should
be
for
the
same
"
"
style
system
"
)
;
bool
isServo
=
aValue1
?
aValue1
-
>
mServo
:
aValue2
-
>
mServo
;
if
(
isServo
)
{
if
(
!
aValue1
|
|
!
aValue2
)
{
NS_WARNING
(
"
stylo
:
Missing
values
are
not
yet
supported
(
bug
1355349
)
"
)
;
return
false
;
}
return
true
;
}
if
(
!
aValue1
)
{
aValue1
=
GetZeroValueForUnit
(
aValue2
-
>
mGecko
.
GetUnit
(
)
)
;
return
!
!
aValue1
;
}
if
(
!
aValue2
)
{
aValue2
=
GetZeroValueForUnit
(
aValue1
-
>
mGecko
.
GetUnit
(
)
)
;
return
!
!
aValue2
;
}
const
AnimationValue
&
zeroCoord
=
*
GetZeroValueForUnit
(
StyleAnimationValue
:
:
eUnit_Coord
)
;
if
(
*
aValue1
=
=
zeroCoord
&
&
aValue2
-
>
mGecko
.
GetUnit
(
)
=
=
StyleAnimationValue
:
:
eUnit_Float
)
{
aValue1
=
GetZeroValueForUnit
(
StyleAnimationValue
:
:
eUnit_Float
)
;
}
else
if
(
*
aValue2
=
=
zeroCoord
&
&
aValue1
-
>
mGecko
.
GetUnit
(
)
=
=
StyleAnimationValue
:
:
eUnit_Float
)
{
aValue2
=
GetZeroValueForUnit
(
StyleAnimationValue
:
:
eUnit_Float
)
;
}
return
true
;
}
static
void
InvertSign
(
StyleAnimationValue
&
aValue
)
{
switch
(
aValue
.
GetUnit
(
)
)
{
case
StyleAnimationValue
:
:
eUnit_Coord
:
aValue
.
SetCoordValue
(
-
aValue
.
GetCoordValue
(
)
)
;
break
;
case
StyleAnimationValue
:
:
eUnit_Percent
:
aValue
.
SetPercentValue
(
-
aValue
.
GetPercentValue
(
)
)
;
break
;
case
StyleAnimationValue
:
:
eUnit_Float
:
aValue
.
SetFloatValue
(
-
aValue
.
GetFloatValue
(
)
)
;
break
;
default
:
NS_NOTREACHED
(
"
Calling
InvertSign
with
an
unsupported
unit
"
)
;
break
;
}
}
static
ValueWrapper
*
ExtractValueWrapper
(
nsSMILValue
&
aValue
)
{
return
static_cast
<
ValueWrapper
*
>
(
aValue
.
mU
.
mPtr
)
;
}
static
const
ValueWrapper
*
ExtractValueWrapper
(
const
nsSMILValue
&
aValue
)
{
return
static_cast
<
const
ValueWrapper
*
>
(
aValue
.
mU
.
mPtr
)
;
}
void
nsSMILCSSValueType
:
:
Init
(
nsSMILValue
&
aValue
)
const
{
MOZ_ASSERT
(
aValue
.
IsNull
(
)
"
Unexpected
SMIL
value
type
"
)
;
aValue
.
mU
.
mPtr
=
nullptr
;
aValue
.
mType
=
this
;
}
void
nsSMILCSSValueType
:
:
Destroy
(
nsSMILValue
&
aValue
)
const
{
MOZ_ASSERT
(
aValue
.
mType
=
=
this
"
Unexpected
SMIL
value
type
"
)
;
delete
static_cast
<
ValueWrapper
*
>
(
aValue
.
mU
.
mPtr
)
;
aValue
.
mType
=
nsSMILNullType
:
:
Singleton
(
)
;
}
nsresult
nsSMILCSSValueType
:
:
Assign
(
nsSMILValue
&
aDest
const
nsSMILValue
&
aSrc
)
const
{
MOZ_ASSERT
(
aDest
.
mType
=
=
aSrc
.
mType
"
Incompatible
SMIL
types
"
)
;
MOZ_ASSERT
(
aDest
.
mType
=
=
this
"
Unexpected
SMIL
value
type
"
)
;
const
ValueWrapper
*
srcWrapper
=
ExtractValueWrapper
(
aSrc
)
;
ValueWrapper
*
destWrapper
=
ExtractValueWrapper
(
aDest
)
;
if
(
srcWrapper
)
{
if
(
!
destWrapper
)
{
aDest
.
mU
.
mPtr
=
new
ValueWrapper
(
*
srcWrapper
)
;
}
else
{
*
destWrapper
=
*
srcWrapper
;
}
}
else
if
(
destWrapper
)
{
delete
destWrapper
;
aDest
.
mU
.
mPtr
=
destWrapper
=
nullptr
;
}
return
NS_OK
;
}
bool
nsSMILCSSValueType
:
:
IsEqual
(
const
nsSMILValue
&
aLeft
const
nsSMILValue
&
aRight
)
const
{
MOZ_ASSERT
(
aLeft
.
mType
=
=
aRight
.
mType
"
Incompatible
SMIL
types
"
)
;
MOZ_ASSERT
(
aLeft
.
mType
=
=
this
"
Unexpected
SMIL
value
"
)
;
const
ValueWrapper
*
leftWrapper
=
ExtractValueWrapper
(
aLeft
)
;
const
ValueWrapper
*
rightWrapper
=
ExtractValueWrapper
(
aRight
)
;
if
(
leftWrapper
)
{
if
(
rightWrapper
)
{
NS_WARNING_ASSERTION
(
leftWrapper
!
=
rightWrapper
"
Two
nsSMILValues
with
matching
ValueWrapper
ptr
"
)
;
return
(
leftWrapper
-
>
mPropID
=
=
rightWrapper
-
>
mPropID
&
&
leftWrapper
-
>
mCSSValue
=
=
rightWrapper
-
>
mCSSValue
)
;
}
return
false
;
}
if
(
rightWrapper
)
{
return
false
;
}
return
true
;
}
nsresult
nsSMILCSSValueType
:
:
Add
(
nsSMILValue
&
aDest
const
nsSMILValue
&
aValueToAdd
uint32_t
aCount
)
const
{
MOZ_ASSERT
(
aValueToAdd
.
mType
=
=
aDest
.
mType
"
Trying
to
add
invalid
types
"
)
;
MOZ_ASSERT
(
aValueToAdd
.
mType
=
=
this
"
Unexpected
source
type
"
)
;
ValueWrapper
*
destWrapper
=
ExtractValueWrapper
(
aDest
)
;
const
ValueWrapper
*
valueToAddWrapper
=
ExtractValueWrapper
(
aValueToAdd
)
;
MOZ_ASSERT
(
destWrapper
|
|
valueToAddWrapper
"
need
at
least
one
fully
-
initialized
value
"
)
;
nsCSSPropertyID
property
=
(
valueToAddWrapper
?
valueToAddWrapper
-
>
mPropID
:
destWrapper
-
>
mPropID
)
;
if
(
property
=
=
eCSSProperty_font_size_adjust
|
|
property
=
=
eCSSProperty_stroke_dasharray
)
{
return
NS_ERROR_FAILURE
;
}
const
AnimationValue
*
valueToAdd
=
valueToAddWrapper
?
&
valueToAddWrapper
-
>
mCSSValue
:
nullptr
;
const
AnimationValue
*
destValue
=
destWrapper
?
&
destWrapper
-
>
mCSSValue
:
nullptr
;
if
(
!
FinalizeStyleAnimationValues
(
valueToAdd
destValue
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
destWrapper
&
&
&
destWrapper
-
>
mCSSValue
!
=
destValue
)
{
destWrapper
-
>
mCSSValue
=
*
destValue
;
}
if
(
!
destWrapper
)
{
aDest
.
mU
.
mPtr
=
destWrapper
=
new
ValueWrapper
(
property
*
destValue
)
;
}
if
(
destWrapper
-
>
mCSSValue
.
mServo
)
{
NS_WARNING
(
"
stylo
:
Additive
animation
not
supported
yet
(
bug
1355349
)
"
)
;
return
NS_ERROR_FAILURE
;
}
return
StyleAnimationValue
:
:
Add
(
property
destWrapper
-
>
mCSSValue
.
mGecko
valueToAdd
-
>
mGecko
aCount
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsresult
nsSMILCSSValueType
:
:
ComputeDistance
(
const
nsSMILValue
&
aFrom
const
nsSMILValue
&
aTo
double
&
aDistance
)
const
{
MOZ_ASSERT
(
aFrom
.
mType
=
=
aTo
.
mType
"
Trying
to
compare
different
types
"
)
;
MOZ_ASSERT
(
aFrom
.
mType
=
=
this
"
Unexpected
source
type
"
)
;
const
ValueWrapper
*
fromWrapper
=
ExtractValueWrapper
(
aFrom
)
;
const
ValueWrapper
*
toWrapper
=
ExtractValueWrapper
(
aTo
)
;
MOZ_ASSERT
(
toWrapper
"
expecting
non
-
null
endpoint
"
)
;
const
AnimationValue
*
fromCSSValue
=
fromWrapper
?
&
fromWrapper
-
>
mCSSValue
:
nullptr
;
const
AnimationValue
*
toCSSValue
=
&
toWrapper
-
>
mCSSValue
;
if
(
!
FinalizeStyleAnimationValues
(
fromCSSValue
toCSSValue
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
toCSSValue
-
>
mServo
)
{
aDistance
=
Servo_AnimationValues_ComputeDistance
(
fromCSSValue
-
>
mServo
toCSSValue
-
>
mServo
)
;
return
NS_OK
;
}
return
StyleAnimationValue
:
:
ComputeDistance
(
toWrapper
-
>
mPropID
fromCSSValue
-
>
mGecko
toCSSValue
-
>
mGecko
nullptr
aDistance
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsresult
nsSMILCSSValueType
:
:
Interpolate
(
const
nsSMILValue
&
aStartVal
const
nsSMILValue
&
aEndVal
double
aUnitDistance
nsSMILValue
&
aResult
)
const
{
MOZ_ASSERT
(
aStartVal
.
mType
=
=
aEndVal
.
mType
"
Trying
to
interpolate
different
types
"
)
;
MOZ_ASSERT
(
aStartVal
.
mType
=
=
this
"
Unexpected
types
for
interpolation
"
)
;
MOZ_ASSERT
(
aResult
.
mType
=
=
this
"
Unexpected
result
type
"
)
;
MOZ_ASSERT
(
aUnitDistance
>
=
0
.
0
&
&
aUnitDistance
<
=
1
.
0
"
unit
distance
value
out
of
bounds
"
)
;
MOZ_ASSERT
(
!
aResult
.
mU
.
mPtr
"
expecting
barely
-
initialized
outparam
"
)
;
const
ValueWrapper
*
startWrapper
=
ExtractValueWrapper
(
aStartVal
)
;
const
ValueWrapper
*
endWrapper
=
ExtractValueWrapper
(
aEndVal
)
;
MOZ_ASSERT
(
endWrapper
"
expecting
non
-
null
endpoint
"
)
;
const
AnimationValue
*
startCSSValue
=
startWrapper
?
&
startWrapper
-
>
mCSSValue
:
nullptr
;
const
AnimationValue
*
endCSSValue
=
&
endWrapper
-
>
mCSSValue
;
if
(
!
FinalizeStyleAnimationValues
(
startCSSValue
endCSSValue
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
startCSSValue
|
|
!
startCSSValue
-
>
mServo
=
=
!
endCSSValue
-
>
mServo
"
Start
and
end
values
should
use
the
same
style
system
"
)
;
if
(
endCSSValue
-
>
mServo
)
{
RefPtr
<
RawServoAnimationValue
>
resultValue
=
Servo_AnimationValues_Interpolate
(
startCSSValue
-
>
mServo
endCSSValue
-
>
mServo
aUnitDistance
)
.
Consume
(
)
;
if
(
!
resultValue
)
{
return
NS_ERROR_FAILURE
;
}
aResult
.
mU
.
mPtr
=
new
ValueWrapper
(
endWrapper
-
>
mPropID
resultValue
)
;
return
NS_OK
;
}
StyleAnimationValue
resultValue
;
if
(
StyleAnimationValue
:
:
Interpolate
(
endWrapper
-
>
mPropID
startCSSValue
-
>
mGecko
endCSSValue
-
>
mGecko
aUnitDistance
resultValue
)
)
{
aResult
.
mU
.
mPtr
=
new
ValueWrapper
(
endWrapper
-
>
mPropID
resultValue
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
static
nsPresContext
*
GetPresContextForElement
(
Element
*
aElem
)
{
nsIDocument
*
doc
=
aElem
-
>
GetUncomposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
nsIPresShell
*
shell
=
doc
-
>
GetShell
(
)
;
return
shell
?
shell
-
>
GetPresContext
(
)
:
nullptr
;
}
static
const
nsDependentSubstring
GetNonNegativePropValue
(
const
nsAString
&
aString
nsCSSPropertyID
aPropID
bool
&
aIsNegative
)
{
aIsNegative
=
false
;
uint32_t
subStringBegin
=
0
;
if
(
aPropID
!
=
eCSSProperty_stroke_dasharray
)
{
int32_t
absValuePos
=
nsSMILParserUtils
:
:
CheckForNegativeNumber
(
aString
)
;
if
(
absValuePos
>
0
)
{
aIsNegative
=
true
;
subStringBegin
=
(
uint32_t
)
absValuePos
;
}
}
return
Substring
(
aString
subStringBegin
)
;
}
static
bool
ValueFromStringHelper
(
nsCSSPropertyID
aPropID
Element
*
aTargetElement
nsPresContext
*
aPresContext
nsStyleContext
*
aStyleContext
const
nsAString
&
aString
StyleAnimationValue
&
aStyleAnimValue
bool
*
aIsContextSensitive
)
{
bool
isNegative
=
false
;
const
nsDependentSubstring
subString
=
GetNonNegativePropValue
(
aString
aPropID
isNegative
)
;
if
(
!
StyleAnimationValue
:
:
ComputeValue
(
aPropID
aTargetElement
aStyleContext
subString
true
aStyleAnimValue
aIsContextSensitive
)
)
{
return
false
;
}
if
(
isNegative
)
{
InvertSign
(
aStyleAnimValue
)
;
}
if
(
aPropID
=
=
eCSSProperty_font_size
)
{
MOZ_ASSERT
(
aStyleAnimValue
.
GetUnit
(
)
=
=
StyleAnimationValue
:
:
eUnit_Coord
"
'
font
-
size
'
value
with
unexpected
style
unit
"
)
;
aStyleAnimValue
.
SetCoordValue
(
aStyleAnimValue
.
GetCoordValue
(
)
/
aPresContext
-
>
EffectiveTextZoom
(
)
)
;
}
return
true
;
}
static
already_AddRefed
<
RawServoAnimationValue
>
ValueFromStringHelper
(
nsCSSPropertyID
aPropID
Element
*
aTargetElement
nsPresContext
*
aPresContext
nsStyleContext
*
aStyleContext
const
nsAString
&
aString
)
{
if
(
nsCSSProps
:
:
IsShorthand
(
aPropID
)
)
{
return
nullptr
;
}
const
ServoComputedValues
*
currentStyle
=
aStyleContext
-
>
StyleSource
(
)
.
AsServoComputedValues
(
)
;
const
ServoComputedValues
*
parentStyle
=
aStyleContext
-
>
GetParentAllowServo
(
)
?
aStyleContext
-
>
GetParentAllowServo
(
)
-
>
StyleSource
(
)
.
AsServoComputedValues
(
)
:
nullptr
;
const
ServoComputedValuesWithParent
servoStyles
=
{
currentStyle
parentStyle
}
;
#
ifdef
DEBUG
{
bool
isNegative
=
false
;
Unused
<
<
GetNonNegativePropValue
(
aString
aPropID
isNegative
)
;
if
(
isNegative
)
{
NS_WARNING
(
"
stylo
:
Special
negative
value
handling
not
yet
supported
"
"
(
bug
1357295
)
"
)
;
}
}
#
endif
nsIDocument
*
doc
=
aTargetElement
-
>
GetUncomposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
RefPtr
<
URLExtraData
>
data
=
new
URLExtraData
(
doc
-
>
GetDocumentURI
(
)
doc
-
>
GetDocumentURI
(
)
doc
-
>
NodePrincipal
(
)
)
;
NS_ConvertUTF16toUTF8
value
(
aString
)
;
RefPtr
<
RawServoDeclarationBlock
>
servoDeclarationBlock
=
Servo_ParseProperty
(
aPropID
&
value
data
ParsingMode
:
:
AllowUnitlessLength
)
.
Consume
(
)
;
if
(
!
servoDeclarationBlock
)
{
return
nullptr
;
}
PropertyValuePair
propValuePair
;
propValuePair
.
mProperty
=
aPropID
;
propValuePair
.
mServoDeclarationBlock
=
servoDeclarationBlock
;
AutoTArray
<
Keyframe
1
>
keyframes
;
keyframes
.
AppendElement
(
)
-
>
mPropertyValues
.
AppendElement
(
Move
(
propValuePair
)
)
;
nsTArray
<
ComputedKeyframeValues
>
computedValues
=
aPresContext
-
>
StyleSet
(
)
-
>
AsServo
(
)
-
>
GetComputedKeyframeValuesFor
(
keyframes
aTargetElement
servoStyles
)
;
if
(
computedValues
.
IsEmpty
(
)
|
|
computedValues
[
0
]
.
IsEmpty
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
computedValues
.
Length
(
)
=
=
1
&
&
computedValues
[
0
]
.
Length
(
)
=
=
1
"
Should
only
have
a
single
property
with
a
single
value
"
)
;
AnimationValue
computedValue
=
computedValues
[
0
]
[
0
]
.
mValue
;
if
(
!
computedValue
.
mServo
)
{
return
nullptr
;
}
if
(
aPropID
=
=
eCSSProperty_font_size
)
{
if
(
aPresContext
-
>
EffectiveTextZoom
(
)
!
=
1
.
0
)
{
NS_WARNING
(
"
stylo
:
Dividing
out
text
-
zoom
not
yet
supported
"
"
(
bug
1357296
)
"
)
;
}
}
return
computedValue
.
mServo
.
forget
(
)
;
}
void
nsSMILCSSValueType
:
:
ValueFromString
(
nsCSSPropertyID
aPropID
Element
*
aTargetElement
const
nsAString
&
aString
nsSMILValue
&
aValue
bool
*
aIsContextSensitive
)
{
MOZ_ASSERT
(
aValue
.
IsNull
(
)
"
Outparam
should
be
null
-
typed
"
)
;
nsPresContext
*
presContext
=
GetPresContextForElement
(
aTargetElement
)
;
if
(
!
presContext
)
{
NS_WARNING
(
"
Not
parsing
animation
value
;
unable
to
get
PresContext
"
)
;
return
;
}
nsIDocument
*
doc
=
aTargetElement
-
>
GetUncomposedDoc
(
)
;
if
(
doc
&
&
!
nsStyleUtil
:
:
CSPAllowsInlineStyle
(
nullptr
doc
-
>
NodePrincipal
(
)
doc
-
>
GetDocumentURI
(
)
0
aString
nullptr
)
)
{
return
;
}
RefPtr
<
nsStyleContext
>
styleContext
=
nsComputedDOMStyle
:
:
GetStyleContext
(
aTargetElement
nullptr
presContext
-
>
PresShell
(
)
)
;
if
(
!
styleContext
)
{
return
;
}
if
(
aTargetElement
-
>
IsStyledByServo
(
)
)
{
RefPtr
<
RawServoAnimationValue
>
parsedValue
=
ValueFromStringHelper
(
aPropID
aTargetElement
presContext
styleContext
aString
)
;
if
(
aIsContextSensitive
)
{
*
aIsContextSensitive
=
false
;
}
if
(
parsedValue
)
{
sSingleton
.
Init
(
aValue
)
;
aValue
.
mU
.
mPtr
=
new
ValueWrapper
(
aPropID
parsedValue
)
;
}
return
;
}
StyleAnimationValue
parsedValue
;
if
(
ValueFromStringHelper
(
aPropID
aTargetElement
presContext
styleContext
aString
parsedValue
aIsContextSensitive
)
)
{
sSingleton
.
Init
(
aValue
)
;
aValue
.
mU
.
mPtr
=
new
ValueWrapper
(
aPropID
parsedValue
)
;
}
}
nsSMILValue
nsSMILCSSValueType
:
:
ValueFromAnimationValue
(
nsCSSPropertyID
aPropID
Element
*
aTargetElement
const
AnimationValue
&
aValue
)
{
nsSMILValue
result
;
nsIDocument
*
doc
=
aTargetElement
-
>
GetUncomposedDoc
(
)
;
static
const
nsLiteralString
kPlaceholderText
=
NS_LITERAL_STRING
(
"
[
SVG
animation
of
CSS
]
"
)
;
if
(
doc
&
&
!
nsStyleUtil
:
:
CSPAllowsInlineStyle
(
nullptr
doc
-
>
NodePrincipal
(
)
doc
-
>
GetDocumentURI
(
)
0
kPlaceholderText
nullptr
)
)
{
return
result
;
}
sSingleton
.
Init
(
result
)
;
result
.
mU
.
mPtr
=
new
ValueWrapper
(
aPropID
aValue
)
;
return
result
;
}
void
nsSMILCSSValueType
:
:
ValueToString
(
const
nsSMILValue
&
aValue
nsAString
&
aString
)
{
MOZ_ASSERT
(
aValue
.
mType
=
=
&
nsSMILCSSValueType
:
:
sSingleton
"
Unexpected
SMIL
value
type
"
)
;
const
ValueWrapper
*
wrapper
=
ExtractValueWrapper
(
aValue
)
;
if
(
!
wrapper
)
{
return
;
}
wrapper
-
>
mCSSValue
.
SerializeSpecifiedValue
(
wrapper
-
>
mPropID
aString
)
;
}
nsCSSPropertyID
nsSMILCSSValueType
:
:
PropertyFromValue
(
const
nsSMILValue
&
aValue
)
{
if
(
aValue
.
mType
!
=
&
nsSMILCSSValueType
:
:
sSingleton
)
{
return
eCSSProperty_UNKNOWN
;
}
const
ValueWrapper
*
wrapper
=
ExtractValueWrapper
(
aValue
)
;
if
(
!
wrapper
)
{
return
eCSSProperty_UNKNOWN
;
}
return
wrapper
-
>
mPropID
;
}
