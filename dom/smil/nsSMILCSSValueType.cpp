#
include
"
nsSMILCSSValueType
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsSMILParserUtils
.
h
"
#
include
"
nsSMILValue
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
DeclarationBlock
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
ServoCSSParser
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
dom
/
BaseKeyframeTypesBinding
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsIDocument
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
mozilla
:
:
StyleAnimationValue
;
typedef
AutoTArray
<
RefPtr
<
RawServoAnimationValue
>
1
>
ServoAnimationValues
;
nsSMILCSSValueType
nsSMILCSSValueType
:
:
sSingleton
;
struct
ValueWrapper
{
ValueWrapper
(
nsCSSPropertyID
aPropID
const
AnimationValue
&
aValue
)
:
mPropID
(
aPropID
)
{
MOZ_ASSERT
(
!
aValue
.
IsNull
(
)
)
;
mServoValues
.
AppendElement
(
aValue
.
mServo
)
;
}
ValueWrapper
(
nsCSSPropertyID
aPropID
const
RefPtr
<
RawServoAnimationValue
>
&
aValue
)
:
mPropID
(
aPropID
)
mServoValues
{
(
aValue
)
}
{
}
ValueWrapper
(
nsCSSPropertyID
aPropID
ServoAnimationValues
&
&
aValues
)
:
mPropID
(
aPropID
)
mServoValues
{
aValues
}
{
}
bool
operator
=
=
(
const
ValueWrapper
&
aOther
)
const
{
if
(
mPropID
!
=
aOther
.
mPropID
)
{
return
false
;
}
MOZ_ASSERT
(
!
mServoValues
.
IsEmpty
(
)
)
;
size_t
len
=
mServoValues
.
Length
(
)
;
if
(
len
!
=
aOther
.
mServoValues
.
Length
(
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
!
Servo_AnimationValue_DeepEqual
(
mServoValues
[
i
]
aOther
.
mServoValues
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
bool
operator
!
=
(
const
ValueWrapper
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
nsCSSPropertyID
mPropID
;
ServoAnimationValues
mServoValues
;
}
;
static
bool
FinalizeServoAnimationValues
(
const
RefPtr
<
RawServoAnimationValue
>
*
&
aValue1
const
RefPtr
<
RawServoAnimationValue
>
*
&
aValue2
RefPtr
<
RawServoAnimationValue
>
&
aZeroValueStorage
)
{
if
(
!
aValue1
&
&
!
aValue2
)
{
return
false
;
}
if
(
!
aValue1
)
{
aZeroValueStorage
=
Servo_AnimationValues_GetZeroValue
(
*
aValue2
)
.
Consume
(
)
;
aValue1
=
&
aZeroValueStorage
;
}
else
if
(
!
aValue2
)
{
aZeroValueStorage
=
Servo_AnimationValues_GetZeroValue
(
*
aValue1
)
.
Consume
(
)
;
aValue2
=
&
aZeroValueStorage
;
}
return
*
aValue1
&
&
*
aValue2
;
}
static
ValueWrapper
*
ExtractValueWrapper
(
nsSMILValue
&
aValue
)
{
return
static_cast
<
ValueWrapper
*
>
(
aValue
.
mU
.
mPtr
)
;
}
static
const
ValueWrapper
*
ExtractValueWrapper
(
const
nsSMILValue
&
aValue
)
{
return
static_cast
<
const
ValueWrapper
*
>
(
aValue
.
mU
.
mPtr
)
;
}
void
nsSMILCSSValueType
:
:
Init
(
nsSMILValue
&
aValue
)
const
{
MOZ_ASSERT
(
aValue
.
IsNull
(
)
"
Unexpected
SMIL
value
type
"
)
;
aValue
.
mU
.
mPtr
=
nullptr
;
aValue
.
mType
=
this
;
}
void
nsSMILCSSValueType
:
:
Destroy
(
nsSMILValue
&
aValue
)
const
{
MOZ_ASSERT
(
aValue
.
mType
=
=
this
"
Unexpected
SMIL
value
type
"
)
;
delete
static_cast
<
ValueWrapper
*
>
(
aValue
.
mU
.
mPtr
)
;
aValue
.
mType
=
nsSMILNullType
:
:
Singleton
(
)
;
}
nsresult
nsSMILCSSValueType
:
:
Assign
(
nsSMILValue
&
aDest
const
nsSMILValue
&
aSrc
)
const
{
MOZ_ASSERT
(
aDest
.
mType
=
=
aSrc
.
mType
"
Incompatible
SMIL
types
"
)
;
MOZ_ASSERT
(
aDest
.
mType
=
=
this
"
Unexpected
SMIL
value
type
"
)
;
const
ValueWrapper
*
srcWrapper
=
ExtractValueWrapper
(
aSrc
)
;
ValueWrapper
*
destWrapper
=
ExtractValueWrapper
(
aDest
)
;
if
(
srcWrapper
)
{
if
(
!
destWrapper
)
{
aDest
.
mU
.
mPtr
=
new
ValueWrapper
(
*
srcWrapper
)
;
}
else
{
*
destWrapper
=
*
srcWrapper
;
}
}
else
if
(
destWrapper
)
{
delete
destWrapper
;
aDest
.
mU
.
mPtr
=
destWrapper
=
nullptr
;
}
return
NS_OK
;
}
bool
nsSMILCSSValueType
:
:
IsEqual
(
const
nsSMILValue
&
aLeft
const
nsSMILValue
&
aRight
)
const
{
MOZ_ASSERT
(
aLeft
.
mType
=
=
aRight
.
mType
"
Incompatible
SMIL
types
"
)
;
MOZ_ASSERT
(
aLeft
.
mType
=
=
this
"
Unexpected
SMIL
value
"
)
;
const
ValueWrapper
*
leftWrapper
=
ExtractValueWrapper
(
aLeft
)
;
const
ValueWrapper
*
rightWrapper
=
ExtractValueWrapper
(
aRight
)
;
if
(
leftWrapper
)
{
if
(
rightWrapper
)
{
NS_WARNING_ASSERTION
(
leftWrapper
!
=
rightWrapper
"
Two
nsSMILValues
with
matching
ValueWrapper
ptr
"
)
;
return
*
leftWrapper
=
=
*
rightWrapper
;
}
return
false
;
}
if
(
rightWrapper
)
{
return
false
;
}
return
true
;
}
static
bool
AddOrAccumulateForServo
(
nsSMILValue
&
aDest
const
ValueWrapper
*
aValueToAddWrapper
ValueWrapper
*
aDestWrapper
CompositeOperation
aCompositeOp
uint64_t
aCount
)
{
nsCSSPropertyID
property
=
aValueToAddWrapper
?
aValueToAddWrapper
-
>
mPropID
:
aDestWrapper
-
>
mPropID
;
size_t
len
=
aValueToAddWrapper
?
aValueToAddWrapper
-
>
mServoValues
.
Length
(
)
:
aDestWrapper
-
>
mServoValues
.
Length
(
)
;
MOZ_ASSERT
(
!
aValueToAddWrapper
|
|
!
aDestWrapper
|
|
aValueToAddWrapper
-
>
mServoValues
.
Length
(
)
=
=
aDestWrapper
-
>
mServoValues
.
Length
(
)
"
Both
of
values
'
length
in
the
wrappers
should
be
the
same
if
"
"
both
of
them
exist
"
)
;
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
const
RefPtr
<
RawServoAnimationValue
>
*
valueToAdd
=
aValueToAddWrapper
?
&
aValueToAddWrapper
-
>
mServoValues
[
i
]
:
nullptr
;
const
RefPtr
<
RawServoAnimationValue
>
*
destValue
=
aDestWrapper
?
&
aDestWrapper
-
>
mServoValues
[
i
]
:
nullptr
;
RefPtr
<
RawServoAnimationValue
>
zeroValueStorage
;
if
(
!
FinalizeServoAnimationValues
(
valueToAdd
destValue
zeroValueStorage
)
)
{
return
false
;
}
if
(
aDestWrapper
)
{
aDestWrapper
-
>
mServoValues
[
i
]
=
*
destValue
;
}
else
{
aDest
.
mU
.
mPtr
=
aDestWrapper
=
new
ValueWrapper
(
property
*
destValue
)
;
aDestWrapper
-
>
mServoValues
.
SetLength
(
len
)
;
}
RefPtr
<
RawServoAnimationValue
>
result
;
if
(
aCompositeOp
=
=
CompositeOperation
:
:
Add
)
{
result
=
Servo_AnimationValues_Add
(
*
destValue
*
valueToAdd
)
.
Consume
(
)
;
}
else
{
result
=
Servo_AnimationValues_Accumulate
(
*
destValue
*
valueToAdd
aCount
)
.
Consume
(
)
;
}
if
(
!
result
)
{
return
false
;
}
aDestWrapper
-
>
mServoValues
[
i
]
=
result
;
}
return
true
;
}
static
bool
AddOrAccumulate
(
nsSMILValue
&
aDest
const
nsSMILValue
&
aValueToAdd
CompositeOperation
aCompositeOp
uint64_t
aCount
)
{
MOZ_ASSERT
(
aValueToAdd
.
mType
=
=
aDest
.
mType
"
Trying
to
add
mismatching
types
"
)
;
MOZ_ASSERT
(
aValueToAdd
.
mType
=
=
&
nsSMILCSSValueType
:
:
sSingleton
"
Unexpected
SMIL
value
type
"
)
;
MOZ_ASSERT
(
aCompositeOp
=
=
CompositeOperation
:
:
Add
|
|
aCompositeOp
=
=
CompositeOperation
:
:
Accumulate
"
Composite
operation
should
be
add
or
accumulate
"
)
;
MOZ_ASSERT
(
aCompositeOp
!
=
CompositeOperation
:
:
Add
|
|
aCount
=
=
1
"
Count
should
be
1
if
composite
operation
is
add
"
)
;
ValueWrapper
*
destWrapper
=
ExtractValueWrapper
(
aDest
)
;
const
ValueWrapper
*
valueToAddWrapper
=
ExtractValueWrapper
(
aValueToAdd
)
;
if
(
!
destWrapper
&
&
!
valueToAddWrapper
)
{
return
false
;
}
nsCSSPropertyID
property
=
valueToAddWrapper
?
valueToAddWrapper
-
>
mPropID
:
destWrapper
-
>
mPropID
;
if
(
property
=
=
eCSSProperty_font_size_adjust
|
|
property
=
=
eCSSProperty_stroke_dasharray
)
{
return
false
;
}
if
(
property
=
=
eCSSProperty_font
)
{
return
false
;
}
return
AddOrAccumulateForServo
(
aDest
valueToAddWrapper
destWrapper
aCompositeOp
aCount
)
;
}
nsresult
nsSMILCSSValueType
:
:
SandwichAdd
(
nsSMILValue
&
aDest
const
nsSMILValue
&
aValueToAdd
)
const
{
return
AddOrAccumulate
(
aDest
aValueToAdd
CompositeOperation
:
:
Add
1
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsresult
nsSMILCSSValueType
:
:
Add
(
nsSMILValue
&
aDest
const
nsSMILValue
&
aValueToAdd
uint32_t
aCount
)
const
{
return
AddOrAccumulate
(
aDest
aValueToAdd
CompositeOperation
:
:
Accumulate
aCount
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
static
nsresult
ComputeDistanceForServo
(
const
ValueWrapper
*
aFromWrapper
const
ValueWrapper
&
aToWrapper
double
&
aDistance
)
{
size_t
len
=
aToWrapper
.
mServoValues
.
Length
(
)
;
MOZ_ASSERT
(
!
aFromWrapper
|
|
aFromWrapper
-
>
mServoValues
.
Length
(
)
=
=
len
"
From
and
to
values
length
should
be
the
same
if
"
"
The
start
value
exists
"
)
;
double
squareDistance
=
0
;
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
const
RefPtr
<
RawServoAnimationValue
>
*
fromValue
=
aFromWrapper
?
&
aFromWrapper
-
>
mServoValues
[
0
]
:
nullptr
;
const
RefPtr
<
RawServoAnimationValue
>
*
toValue
=
&
aToWrapper
.
mServoValues
[
0
]
;
RefPtr
<
RawServoAnimationValue
>
zeroValueStorage
;
if
(
!
FinalizeServoAnimationValues
(
fromValue
toValue
zeroValueStorage
)
)
{
return
NS_ERROR_FAILURE
;
}
double
distance
=
Servo_AnimationValues_ComputeDistance
(
*
fromValue
*
toValue
)
;
if
(
distance
<
0
.
0
)
{
return
NS_ERROR_FAILURE
;
}
if
(
len
=
=
1
)
{
aDistance
=
distance
;
return
NS_OK
;
}
squareDistance
+
=
distance
*
distance
;
}
aDistance
=
sqrt
(
squareDistance
)
;
return
NS_OK
;
}
nsresult
nsSMILCSSValueType
:
:
ComputeDistance
(
const
nsSMILValue
&
aFrom
const
nsSMILValue
&
aTo
double
&
aDistance
)
const
{
MOZ_ASSERT
(
aFrom
.
mType
=
=
aTo
.
mType
"
Trying
to
compare
different
types
"
)
;
MOZ_ASSERT
(
aFrom
.
mType
=
=
this
"
Unexpected
source
type
"
)
;
const
ValueWrapper
*
fromWrapper
=
ExtractValueWrapper
(
aFrom
)
;
const
ValueWrapper
*
toWrapper
=
ExtractValueWrapper
(
aTo
)
;
MOZ_ASSERT
(
toWrapper
"
expecting
non
-
null
endpoint
"
)
;
return
ComputeDistanceForServo
(
fromWrapper
*
toWrapper
aDistance
)
;
}
static
nsresult
InterpolateForServo
(
const
ValueWrapper
*
aStartWrapper
const
ValueWrapper
&
aEndWrapper
double
aUnitDistance
nsSMILValue
&
aResult
)
{
if
(
Servo_Property_IsDiscreteAnimatable
(
aEndWrapper
.
mPropID
)
)
{
return
NS_ERROR_FAILURE
;
}
ServoAnimationValues
results
;
size_t
len
=
aEndWrapper
.
mServoValues
.
Length
(
)
;
results
.
SetCapacity
(
len
)
;
MOZ_ASSERT
(
!
aStartWrapper
|
|
aStartWrapper
-
>
mServoValues
.
Length
(
)
=
=
len
"
Start
and
end
values
length
should
be
the
same
if
"
"
the
start
value
exists
"
)
;
for
(
size_t
i
=
0
;
i
<
len
;
i
+
+
)
{
const
RefPtr
<
RawServoAnimationValue
>
*
startValue
=
aStartWrapper
?
&
aStartWrapper
-
>
mServoValues
[
i
]
:
nullptr
;
const
RefPtr
<
RawServoAnimationValue
>
*
endValue
=
&
aEndWrapper
.
mServoValues
[
i
]
;
RefPtr
<
RawServoAnimationValue
>
zeroValueStorage
;
if
(
!
FinalizeServoAnimationValues
(
startValue
endValue
zeroValueStorage
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
RawServoAnimationValue
>
result
=
Servo_AnimationValues_Interpolate
(
*
startValue
*
endValue
aUnitDistance
)
.
Consume
(
)
;
if
(
!
result
)
{
return
NS_ERROR_FAILURE
;
}
results
.
AppendElement
(
result
)
;
}
aResult
.
mU
.
mPtr
=
new
ValueWrapper
(
aEndWrapper
.
mPropID
std
:
:
move
(
results
)
)
;
return
NS_OK
;
}
nsresult
nsSMILCSSValueType
:
:
Interpolate
(
const
nsSMILValue
&
aStartVal
const
nsSMILValue
&
aEndVal
double
aUnitDistance
nsSMILValue
&
aResult
)
const
{
MOZ_ASSERT
(
aStartVal
.
mType
=
=
aEndVal
.
mType
"
Trying
to
interpolate
different
types
"
)
;
MOZ_ASSERT
(
aStartVal
.
mType
=
=
this
"
Unexpected
types
for
interpolation
"
)
;
MOZ_ASSERT
(
aResult
.
mType
=
=
this
"
Unexpected
result
type
"
)
;
MOZ_ASSERT
(
aUnitDistance
>
=
0
.
0
&
&
aUnitDistance
<
=
1
.
0
"
unit
distance
value
out
of
bounds
"
)
;
MOZ_ASSERT
(
!
aResult
.
mU
.
mPtr
"
expecting
barely
-
initialized
outparam
"
)
;
const
ValueWrapper
*
startWrapper
=
ExtractValueWrapper
(
aStartVal
)
;
const
ValueWrapper
*
endWrapper
=
ExtractValueWrapper
(
aEndVal
)
;
MOZ_ASSERT
(
endWrapper
"
expecting
non
-
null
endpoint
"
)
;
return
InterpolateForServo
(
startWrapper
*
endWrapper
aUnitDistance
aResult
)
;
}
static
ServoAnimationValues
ValueFromStringHelper
(
nsCSSPropertyID
aPropID
Element
*
aTargetElement
nsPresContext
*
aPresContext
ComputedStyle
*
aComputedStyle
const
nsAString
&
aString
)
{
ServoAnimationValues
result
;
nsIDocument
*
doc
=
aTargetElement
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
result
;
}
ServoCSSParser
:
:
ParsingEnvironment
env
=
ServoCSSParser
:
:
GetParsingEnvironment
(
doc
)
;
RefPtr
<
RawServoDeclarationBlock
>
servoDeclarationBlock
=
ServoCSSParser
:
:
ParseProperty
(
aPropID
aString
env
ParsingMode
:
:
AllowUnitlessLength
|
ParsingMode
:
:
AllowAllNumericValues
)
;
if
(
!
servoDeclarationBlock
)
{
return
result
;
}
aPresContext
-
>
StyleSet
(
)
-
>
GetAnimationValues
(
servoDeclarationBlock
aTargetElement
aComputedStyle
result
)
;
return
result
;
}
void
nsSMILCSSValueType
:
:
ValueFromString
(
nsCSSPropertyID
aPropID
Element
*
aTargetElement
const
nsAString
&
aString
nsSMILValue
&
aValue
bool
*
aIsContextSensitive
)
{
MOZ_ASSERT
(
aValue
.
IsNull
(
)
"
Outparam
should
be
null
-
typed
"
)
;
nsPresContext
*
presContext
=
nsContentUtils
:
:
GetContextForContent
(
aTargetElement
)
;
if
(
!
presContext
)
{
NS_WARNING
(
"
Not
parsing
animation
value
;
unable
to
get
PresContext
"
)
;
return
;
}
nsIDocument
*
doc
=
aTargetElement
-
>
GetComposedDoc
(
)
;
if
(
doc
&
&
!
nsStyleUtil
:
:
CSPAllowsInlineStyle
(
nullptr
doc
-
>
NodePrincipal
(
)
nullptr
doc
-
>
GetDocumentURI
(
)
0
0
aString
nullptr
)
)
{
return
;
}
RefPtr
<
ComputedStyle
>
computedStyle
=
nsComputedDOMStyle
:
:
GetComputedStyle
(
aTargetElement
nullptr
)
;
if
(
!
computedStyle
)
{
return
;
}
ServoAnimationValues
parsedValues
=
ValueFromStringHelper
(
aPropID
aTargetElement
presContext
computedStyle
aString
)
;
if
(
aIsContextSensitive
)
{
*
aIsContextSensitive
=
false
;
}
if
(
!
parsedValues
.
IsEmpty
(
)
)
{
sSingleton
.
Init
(
aValue
)
;
aValue
.
mU
.
mPtr
=
new
ValueWrapper
(
aPropID
std
:
:
move
(
parsedValues
)
)
;
}
}
nsSMILValue
nsSMILCSSValueType
:
:
ValueFromAnimationValue
(
nsCSSPropertyID
aPropID
Element
*
aTargetElement
const
AnimationValue
&
aValue
)
{
nsSMILValue
result
;
nsIDocument
*
doc
=
aTargetElement
-
>
GetComposedDoc
(
)
;
static
const
nsLiteralString
kPlaceholderText
=
NS_LITERAL_STRING
(
"
[
SVG
animation
of
CSS
]
"
)
;
if
(
doc
&
&
!
nsStyleUtil
:
:
CSPAllowsInlineStyle
(
nullptr
doc
-
>
NodePrincipal
(
)
nullptr
doc
-
>
GetDocumentURI
(
)
0
0
kPlaceholderText
nullptr
)
)
{
return
result
;
}
sSingleton
.
Init
(
result
)
;
result
.
mU
.
mPtr
=
new
ValueWrapper
(
aPropID
aValue
)
;
return
result
;
}
bool
nsSMILCSSValueType
:
:
SetPropertyValues
(
const
nsSMILValue
&
aValue
DeclarationBlock
&
aDecl
)
{
MOZ_ASSERT
(
aValue
.
mType
=
=
&
nsSMILCSSValueType
:
:
sSingleton
"
Unexpected
SMIL
value
type
"
)
;
const
ValueWrapper
*
wrapper
=
ExtractValueWrapper
(
aValue
)
;
if
(
!
wrapper
)
{
return
false
;
}
bool
changed
=
false
;
for
(
const
auto
&
value
:
wrapper
-
>
mServoValues
)
{
changed
|
=
Servo_DeclarationBlock_SetPropertyToAnimationValue
(
aDecl
.
Raw
(
)
value
)
;
}
return
changed
;
}
nsCSSPropertyID
nsSMILCSSValueType
:
:
PropertyFromValue
(
const
nsSMILValue
&
aValue
)
{
if
(
aValue
.
mType
!
=
&
nsSMILCSSValueType
:
:
sSingleton
)
{
return
eCSSProperty_UNKNOWN
;
}
const
ValueWrapper
*
wrapper
=
ExtractValueWrapper
(
aValue
)
;
if
(
!
wrapper
)
{
return
eCSSProperty_UNKNOWN
;
}
return
wrapper
-
>
mPropID
;
}
void
nsSMILCSSValueType
:
:
FinalizeValue
(
nsSMILValue
&
aValue
const
nsSMILValue
&
aValueToMatch
)
{
MOZ_ASSERT
(
aValue
.
mType
=
=
aValueToMatch
.
mType
"
Incompatible
SMIL
types
"
)
;
MOZ_ASSERT
(
aValue
.
mType
=
=
&
nsSMILCSSValueType
:
:
sSingleton
"
Unexpected
SMIL
value
type
"
)
;
ValueWrapper
*
valueWrapper
=
ExtractValueWrapper
(
aValue
)
;
if
(
valueWrapper
)
{
return
;
}
const
ValueWrapper
*
valueToMatchWrapper
=
ExtractValueWrapper
(
aValueToMatch
)
;
if
(
!
valueToMatchWrapper
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Value
to
match
is
empty
"
)
;
return
;
}
ServoAnimationValues
zeroValues
;
zeroValues
.
SetCapacity
(
valueToMatchWrapper
-
>
mServoValues
.
Length
(
)
)
;
for
(
auto
&
valueToMatch
:
valueToMatchWrapper
-
>
mServoValues
)
{
RefPtr
<
RawServoAnimationValue
>
zeroValue
=
Servo_AnimationValues_GetZeroValue
(
valueToMatch
)
.
Consume
(
)
;
if
(
!
zeroValue
)
{
return
;
}
zeroValues
.
AppendElement
(
std
:
:
move
(
zeroValue
)
)
;
}
aValue
.
mU
.
mPtr
=
new
ValueWrapper
(
valueToMatchWrapper
-
>
mPropID
std
:
:
move
(
zeroValues
)
)
;
}
