#
ifndef
mozilla_dom_Console_h
#
define
mozilla_dom_Console_h
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
JSObjectHolder
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
class
nsIConsoleAPIStorage
;
class
nsIPrincipal
;
namespace
mozilla
{
namespace
dom
{
class
AnyCallback
;
class
ConsoleCallData
;
class
ConsoleInstance
;
class
ConsoleRunnable
;
class
ConsoleCallDataRunnable
;
class
ConsoleProfileRunnable
;
struct
ConsoleInstanceOptions
;
struct
ConsoleTimerError
;
struct
ConsoleStackEntry
;
class
Console
final
:
public
nsIObserver
public
nsSupportsWeakReference
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
Console
nsIObserver
)
NS_DECL_NSIOBSERVER
static
already_AddRefed
<
Console
>
Create
(
nsPIDOMWindowInner
*
aWindow
ErrorResult
&
aRv
)
;
nsPIDOMWindowInner
*
GetParentObject
(
)
const
{
return
mWindow
;
}
static
void
Log
(
const
GlobalObject
&
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
Info
(
const
GlobalObject
&
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
Warn
(
const
GlobalObject
&
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
Error
(
const
GlobalObject
&
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
Exception
(
const
GlobalObject
&
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
Debug
(
const
GlobalObject
&
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
Table
(
const
GlobalObject
&
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
Trace
(
const
GlobalObject
&
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
Dir
(
const
GlobalObject
&
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
Dirxml
(
const
GlobalObject
&
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
Group
(
const
GlobalObject
&
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
GroupCollapsed
(
const
GlobalObject
&
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
GroupEnd
(
const
GlobalObject
&
aGlobal
)
;
static
void
Time
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aLabel
)
;
static
void
TimeEnd
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aLabel
)
;
static
void
TimeStamp
(
const
GlobalObject
&
aGlobal
const
JS
:
:
Handle
<
JS
:
:
Value
>
aData
)
;
static
void
Profile
(
const
GlobalObject
&
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
ProfileEnd
(
const
GlobalObject
&
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
Assert
(
const
GlobalObject
&
aGlobal
bool
aCondition
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
Count
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aLabel
)
;
static
void
Clear
(
const
GlobalObject
&
aGlobal
)
;
static
already_AddRefed
<
ConsoleInstance
>
CreateInstance
(
const
GlobalObject
&
aGlobal
const
ConsoleInstanceOptions
&
aOptions
)
;
void
ClearStorage
(
)
;
void
RetrieveConsoleEvents
(
JSContext
*
aCx
nsTArray
<
JS
:
:
Value
>
&
aEvents
ErrorResult
&
aRv
)
;
void
SetConsoleEventHandler
(
AnyCallback
*
aHandler
)
;
private
:
explicit
Console
(
nsPIDOMWindowInner
*
aWindow
)
;
~
Console
(
)
;
void
Initialize
(
ErrorResult
&
aRv
)
;
void
Shutdown
(
)
;
enum
MethodName
{
MethodLog
MethodInfo
MethodWarn
MethodError
MethodException
MethodDebug
MethodTable
MethodTrace
MethodDir
MethodDirxml
MethodGroup
MethodGroupCollapsed
MethodGroupEnd
MethodTime
MethodTimeEnd
MethodTimeStamp
MethodAssert
MethodCount
MethodClear
}
;
static
already_AddRefed
<
Console
>
GetConsole
(
const
GlobalObject
&
aGlobal
)
;
static
already_AddRefed
<
Console
>
GetConsoleInternal
(
const
GlobalObject
&
aGlobal
ErrorResult
&
aRv
)
;
static
void
ProfileMethod
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aAction
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
void
ProfileMethodInternal
(
JSContext
*
aCx
const
nsAString
&
aAction
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
Method
(
const
GlobalObject
&
aGlobal
MethodName
aName
const
nsAString
&
aString
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
void
MethodInternal
(
JSContext
*
aCx
MethodName
aName
const
nsAString
&
aString
const
Sequence
<
JS
:
:
Value
>
&
aData
)
;
static
void
StringMethod
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aLabel
MethodName
aMethodName
const
nsAString
&
aMethodString
)
;
void
StringMethodInternal
(
JSContext
*
aCx
const
nsAString
&
aLabel
MethodName
aMethodName
const
nsAString
&
aMethodString
)
;
void
ProcessCallData
(
JSContext
*
aCx
ConsoleCallData
*
aData
const
Sequence
<
JS
:
:
Value
>
&
aArguments
)
;
void
StoreCallData
(
ConsoleCallData
*
aData
)
;
void
UnstoreCallData
(
ConsoleCallData
*
aData
)
;
void
ReleaseCallData
(
ConsoleCallData
*
aCallData
)
;
void
NotifyHandler
(
JSContext
*
aCx
const
Sequence
<
JS
:
:
Value
>
&
aArguments
ConsoleCallData
*
aData
)
;
bool
PopulateConsoleNotificationInTheTargetScope
(
JSContext
*
aCx
const
Sequence
<
JS
:
:
Value
>
&
aArguments
JSObject
*
aTargetScope
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
ConsoleCallData
*
aData
)
;
bool
ProcessArguments
(
JSContext
*
aCx
const
Sequence
<
JS
:
:
Value
>
&
aData
Sequence
<
JS
:
:
Value
>
&
aSequence
Sequence
<
nsString
>
&
aStyles
)
const
;
void
MakeFormatString
(
nsCString
&
aFormat
int32_t
aInteger
int32_t
aMantissa
char
aCh
)
const
;
void
ComposeAndStoreGroupName
(
JSContext
*
aCx
const
Sequence
<
JS
:
:
Value
>
&
aData
nsAString
&
aName
)
;
bool
UnstoreGroupName
(
nsAString
&
aName
)
;
enum
TimerStatus
{
eTimerUnknown
eTimerDone
eTimerAlreadyExists
eTimerDoesntExist
eTimerJSException
eTimerMaxReached
}
;
JS
:
:
Value
CreateTimerError
(
JSContext
*
aCx
const
nsAString
&
aTimerLabel
TimerStatus
aStatus
)
const
;
TimerStatus
StartTimer
(
JSContext
*
aCx
const
JS
:
:
Value
&
aName
DOMHighResTimeStamp
aTimestamp
nsAString
&
aTimerLabel
DOMHighResTimeStamp
*
aTimerValue
)
;
JS
:
:
Value
CreateStartTimerValue
(
JSContext
*
aCx
const
nsAString
&
aTimerLabel
TimerStatus
aTimerStatus
)
const
;
TimerStatus
StopTimer
(
JSContext
*
aCx
const
JS
:
:
Value
&
aName
DOMHighResTimeStamp
aTimestamp
nsAString
&
aTimerLabel
double
*
aTimerDuration
)
;
JS
:
:
Value
CreateStopTimerValue
(
JSContext
*
aCx
const
nsAString
&
aTimerLabel
double
aTimerDuration
TimerStatus
aTimerStatus
)
const
;
bool
ArgumentsToValueList
(
const
Sequence
<
JS
:
:
Value
>
&
aData
Sequence
<
JS
:
:
Value
>
&
aSequence
)
const
;
uint32_t
IncreaseCounter
(
JSContext
*
aCx
const
Sequence
<
JS
:
:
Value
>
&
aData
nsAString
&
aCountLabel
)
;
JS
:
:
Value
CreateCounterValue
(
JSContext
*
aCx
const
nsAString
&
aCountLabel
uint32_t
aCountValue
)
const
;
bool
ShouldIncludeStackTrace
(
MethodName
aMethodName
)
const
;
JSObject
*
GetOrCreateSandbox
(
JSContext
*
aCx
nsIPrincipal
*
aPrincipal
)
;
void
AssertIsOnOwningThread
(
)
const
;
bool
IsShuttingDown
(
)
const
;
bool
MonotonicTimer
(
JSContext
*
aCx
MethodName
aMethodName
const
Sequence
<
JS
:
:
Value
>
&
aData
DOMHighResTimeStamp
*
aTimeStamp
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mWindow
;
nsCOMPtr
<
nsIConsoleAPIStorage
>
mStorage
;
RefPtr
<
JSObjectHolder
>
mSandbox
;
nsDataHashtable
<
nsStringHashKey
DOMHighResTimeStamp
>
mTimerRegistry
;
nsDataHashtable
<
nsStringHashKey
uint32_t
>
mCounterRegistry
;
nsTArray
<
RefPtr
<
ConsoleCallData
>
>
mCallDataStorage
;
nsTArray
<
RefPtr
<
ConsoleCallData
>
>
mCallDataStoragePending
;
RefPtr
<
AnyCallback
>
mConsoleEventNotifier
;
nsTArray
<
nsString
>
mGroupStack
;
uint64_t
mOuterID
;
uint64_t
mInnerID
;
enum
{
eUnknown
eInitialized
eShuttingDown
}
mStatus
;
mozilla
:
:
TimeStamp
mCreationTimeStamp
;
friend
class
ConsoleCallData
;
friend
class
ConsoleInstance
;
friend
class
ConsoleRunnable
;
friend
class
ConsoleCallDataRunnable
;
friend
class
ConsoleProfileRunnable
;
}
;
}
}
#
endif
