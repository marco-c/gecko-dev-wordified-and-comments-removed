#
include
"
HardwareKeyHandler
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEvent
.
h
"
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
nsDeque
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDOMHTMLDocument
.
h
"
#
include
"
nsIDOMHTMLElement
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPresContext
.
h
"
namespace
mozilla
{
using
namespace
dom
;
NS_IMPL_ISUPPORTS
(
HardwareKeyHandler
nsIHardwareKeyHandler
)
StaticRefPtr
<
HardwareKeyHandler
>
HardwareKeyHandler
:
:
sInstance
;
HardwareKeyHandler
:
:
HardwareKeyHandler
(
)
:
mInputMethodAppConnected
(
false
)
{
}
HardwareKeyHandler
:
:
~
HardwareKeyHandler
(
)
{
}
NS_IMETHODIMP
HardwareKeyHandler
:
:
OnInputMethodAppConnected
(
)
{
if
(
NS_WARN_IF
(
mInputMethodAppConnected
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mInputMethodAppConnected
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
HardwareKeyHandler
:
:
OnInputMethodAppDisconnected
(
)
{
if
(
NS_WARN_IF
(
!
mInputMethodAppConnected
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mInputMethodAppConnected
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
HardwareKeyHandler
:
:
RegisterListener
(
nsIHardwareKeyEventListener
*
aListener
)
{
if
(
NS_WARN_IF
(
!
aListener
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
NS_WARN_IF
(
mHardwareKeyEventListener
)
)
{
return
NS_ERROR_ALREADY_INITIALIZED
;
}
mHardwareKeyEventListener
=
do_GetWeakReference
(
aListener
)
;
if
(
NS_WARN_IF
(
!
mHardwareKeyEventListener
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HardwareKeyHandler
:
:
UnregisterListener
(
)
{
mHardwareKeyEventListener
=
nullptr
;
return
NS_OK
;
}
bool
HardwareKeyHandler
:
:
ForwardKeyToInputMethodApp
(
nsINode
*
aTarget
WidgetKeyboardEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aTarget
"
No
target
provided
"
)
;
MOZ_ASSERT
(
aEvent
"
No
event
provided
"
)
;
if
(
aEvent
-
>
mFlags
.
mDefaultPrevented
)
{
return
false
;
}
if
(
!
mInputMethodAppConnected
)
{
return
false
;
}
if
(
aEvent
-
>
mIsSynthesizedByTIP
)
{
return
false
;
}
if
(
aEvent
-
>
mInputMethodAppState
!
=
WidgetKeyboardEvent
:
:
eNotHandled
)
{
return
false
;
}
nsCOMPtr
<
nsIHardwareKeyEventListener
>
keyHandler
(
do_QueryReferent
(
mHardwareKeyEventListener
)
)
;
if
(
!
keyHandler
)
{
return
false
;
}
aEvent
-
>
mInputMethodAppState
=
WidgetKeyboardEvent
:
:
eHandling
;
if
(
aEvent
-
>
mMessage
=
=
eKeyPress
&
&
mEventQueue
.
IsEmpty
(
)
)
{
DispatchKeyPress
(
aTarget
*
aEvent
*
aEventStatus
)
;
return
true
;
}
KeyboardInfo
*
copiedInfo
=
new
KeyboardInfo
(
aTarget
*
aEvent
aEventStatus
?
*
aEventStatus
:
nsEventStatus_eIgnore
)
;
if
(
!
mEventQueue
.
Push
(
copiedInfo
)
)
{
delete
copiedInfo
;
return
false
;
}
if
(
aEvent
-
>
mMessage
=
=
eKeyPress
)
{
return
true
;
}
nsCOMPtr
<
EventTarget
>
eventTarget
=
do_QueryInterface
(
aTarget
)
;
nsPresContext
*
presContext
=
GetPresContext
(
aTarget
)
;
RefPtr
<
KeyboardEvent
>
keyboardEvent
=
NS_NewDOMKeyboardEvent
(
eventTarget
presContext
aEvent
-
>
AsKeyboardEvent
(
)
)
;
keyboardEvent
-
>
DuplicatePrivateData
(
)
;
bool
isSent
=
false
;
keyHandler
-
>
OnHardwareKey
(
keyboardEvent
&
isSent
)
;
if
(
!
isSent
)
{
mEventQueue
.
RemoveFront
(
)
;
}
return
isSent
;
}
NS_IMETHODIMP
HardwareKeyHandler
:
:
OnHandledByInputMethodApp
(
const
nsAString
&
aType
uint16_t
aDefaultPrevented
)
{
if
(
mEventQueue
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
RefPtr
<
KeyboardInfo
>
keyInfo
=
mEventQueue
.
PopFront
(
)
;
if
(
NS_WARN_IF
(
aType
.
EqualsLiteral
(
"
keydown
"
)
&
&
keyInfo
-
>
mEvent
.
mMessage
!
=
eKeyDown
)
|
|
NS_WARN_IF
(
aType
.
EqualsLiteral
(
"
keyup
"
)
&
&
keyInfo
-
>
mEvent
.
mMessage
!
=
eKeyUp
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
SetDefaultPrevented
(
keyInfo
-
>
mEvent
aDefaultPrevented
)
;
keyInfo
-
>
mEvent
.
mInputMethodAppState
=
WidgetKeyboardEvent
:
:
eHandled
;
if
(
CanDispatchEvent
(
keyInfo
-
>
mTarget
keyInfo
-
>
mEvent
)
)
{
if
(
!
keyInfo
-
>
mEvent
.
mFlags
.
mDefaultPrevented
)
{
DispatchToTargetApp
(
keyInfo
-
>
mTarget
keyInfo
-
>
mEvent
keyInfo
-
>
mStatus
)
;
}
}
if
(
keyInfo
-
>
mEvent
.
mMessage
!
=
eKeyDown
)
{
return
NS_OK
;
}
mLatestKeyDownInfo
=
keyInfo
;
for
(
KeyboardInfo
*
keypressInfo
;
!
mEventQueue
.
IsEmpty
(
)
&
&
(
keypressInfo
=
mEventQueue
.
PeekFront
(
)
)
&
&
keypressInfo
-
>
mEvent
.
mMessage
=
=
eKeyPress
;
mEventQueue
.
RemoveFront
(
)
)
{
DispatchKeyPress
(
keypressInfo
-
>
mTarget
keypressInfo
-
>
mEvent
keypressInfo
-
>
mStatus
)
;
}
return
NS_OK
;
}
bool
HardwareKeyHandler
:
:
DispatchKeyPress
(
nsINode
*
aTarget
WidgetKeyboardEvent
&
aEvent
nsEventStatus
&
aStatus
)
{
MOZ_ASSERT
(
aTarget
"
No
target
provided
"
)
;
MOZ_ASSERT
(
aEvent
.
mMessage
=
=
eKeyPress
"
Event
is
not
keypress
"
)
;
if
(
mLatestKeyDownInfo
&
&
mLatestKeyDownInfo
-
>
mEvent
.
mFlags
.
mDefaultPrevented
)
{
return
false
;
}
if
(
mLatestKeyDownInfo
&
&
mLatestKeyDownInfo
-
>
mEvent
.
IsModifierKeyEvent
(
)
)
{
return
false
;
}
if
(
!
CanDispatchEvent
(
aTarget
aEvent
)
)
{
return
false
;
}
aEvent
.
mInputMethodAppState
=
WidgetKeyboardEvent
:
:
eHandled
;
bool
ret
=
DispatchToTargetApp
(
aTarget
aEvent
aStatus
)
;
PostHandleKeyboardEvent
(
aTarget
aEvent
aStatus
)
;
return
ret
;
}
bool
HardwareKeyHandler
:
:
DispatchToTargetApp
(
nsINode
*
aTarget
WidgetKeyboardEvent
&
aEvent
nsEventStatus
&
aStatus
)
{
MOZ_ASSERT
(
aTarget
"
No
target
provided
"
)
;
nsCOMPtr
<
nsIContent
>
currentTarget
=
GetCurrentTarget
(
)
;
if
(
NS_WARN_IF
(
!
currentTarget
)
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
originalRootWindow
=
GetRootWindow
(
aTarget
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
currentRootWindow
=
GetRootWindow
(
currentTarget
)
;
if
(
currentRootWindow
!
=
originalRootWindow
)
{
NS_WARNING
(
"
The
root
window
is
changed
during
the
event
is
dispatching
"
)
;
return
false
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
currentTarget
)
;
if
(
!
presShell
)
{
return
false
;
}
if
(
!
presShell
-
>
CanDispatchEvent
(
&
aEvent
)
)
{
return
false
;
}
if
(
!
PresShell
:
:
IsTargetIframe
(
currentTarget
)
)
{
DispatchToCurrentProcess
(
presShell
currentTarget
aEvent
aStatus
)
;
return
true
;
}
return
DispatchToCrossProcess
(
aTarget
aEvent
)
;
}
void
HardwareKeyHandler
:
:
DispatchToCurrentProcess
(
nsIPresShell
*
presShell
nsIContent
*
aTarget
WidgetKeyboardEvent
&
aEvent
nsEventStatus
&
aStatus
)
{
EventDispatcher
:
:
Dispatch
(
aTarget
presShell
-
>
GetPresContext
(
)
&
aEvent
nullptr
&
aStatus
nullptr
)
;
}
bool
HardwareKeyHandler
:
:
DispatchToCrossProcess
(
nsINode
*
aTarget
WidgetKeyboardEvent
&
aEvent
)
{
nsCOMPtr
<
nsIFrameLoaderOwner
>
remoteLoaderOwner
=
do_QueryInterface
(
aTarget
)
;
if
(
NS_WARN_IF
(
!
remoteLoaderOwner
)
)
{
return
false
;
}
RefPtr
<
nsFrameLoader
>
remoteFrameLoader
=
remoteLoaderOwner
-
>
GetFrameLoader
(
)
;
if
(
NS_WARN_IF
(
!
remoteFrameLoader
)
)
{
return
false
;
}
uint32_t
eventMode
;
remoteFrameLoader
-
>
GetEventMode
(
&
eventMode
)
;
if
(
eventMode
=
=
nsIFrameLoader
:
:
EVENT_MODE_DONT_FORWARD_TO_CHILD
)
{
return
false
;
}
PBrowserParent
*
remoteBrowser
=
remoteFrameLoader
-
>
GetRemoteBrowser
(
)
;
TabParent
*
remote
=
static_cast
<
TabParent
*
>
(
remoteBrowser
)
;
if
(
NS_WARN_IF
(
!
remote
)
)
{
return
false
;
}
return
remote
-
>
SendRealKeyEvent
(
aEvent
)
;
}
void
HardwareKeyHandler
:
:
PostHandleKeyboardEvent
(
nsINode
*
aTarget
WidgetKeyboardEvent
&
aEvent
nsEventStatus
&
aStatus
)
{
MOZ_ASSERT
(
aTarget
"
No
target
provided
"
)
;
nsPresContext
*
presContext
=
GetPresContext
(
aTarget
)
;
RefPtr
<
mozilla
:
:
EventStateManager
>
esm
=
presContext
-
>
EventStateManager
(
)
;
bool
dispatchedToChildProcess
=
PresShell
:
:
IsTargetIframe
(
aTarget
)
;
esm
-
>
PostHandleKeyboardEvent
(
&
aEvent
aStatus
dispatchedToChildProcess
)
;
}
void
HardwareKeyHandler
:
:
SetDefaultPrevented
(
WidgetKeyboardEvent
&
aEvent
uint16_t
aDefaultPrevented
)
{
if
(
aDefaultPrevented
&
DEFAULT_PREVENTED
)
{
aEvent
.
mFlags
.
mDefaultPrevented
=
true
;
}
if
(
aDefaultPrevented
&
DEFAULT_PREVENTED_BY_CHROME
)
{
aEvent
.
mFlags
.
mDefaultPreventedByChrome
=
true
;
}
if
(
aDefaultPrevented
&
DEFAULT_PREVENTED_BY_CONTENT
)
{
aEvent
.
mFlags
.
mDefaultPreventedByContent
=
true
;
}
}
bool
HardwareKeyHandler
:
:
CanDispatchEvent
(
nsINode
*
aTarget
WidgetKeyboardEvent
&
aEvent
)
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
aTarget
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
false
;
}
return
presShell
-
>
CanDispatchEvent
(
&
aEvent
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
HardwareKeyHandler
:
:
GetRootWindow
(
nsINode
*
aNode
)
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
aNode
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWindow
=
presShell
-
>
GetRootWindow
(
)
;
return
rootWindow
.
forget
(
)
;
}
already_AddRefed
<
nsIContent
>
HardwareKeyHandler
:
:
GetCurrentTarget
(
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
NS_WARN_IF
(
!
fm
)
)
{
return
nullptr
;
}
nsCOMPtr
<
mozIDOMWindowProxy
>
focusedWindow
;
fm
-
>
GetFocusedWindow
(
getter_AddRefs
(
focusedWindow
)
)
;
if
(
NS_WARN_IF
(
!
focusedWindow
)
)
{
return
nullptr
;
}
auto
*
ourWindow
=
nsPIDOMWindowOuter
:
:
From
(
focusedWindow
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWindow
=
ourWindow
-
>
GetPrivateRoot
(
)
;
if
(
NS_WARN_IF
(
!
rootWindow
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedFrame
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
fm
-
>
GetFocusedDescendant
(
rootWindow
true
getter_AddRefs
(
focusedFrame
)
)
;
if
(
NS_WARN_IF
(
!
focusedContent
|
|
!
focusedContent
-
>
GetPrimaryFrame
(
)
)
)
{
nsIDocument
*
document
=
ourWindow
-
>
GetExtantDoc
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
nullptr
;
}
focusedContent
=
document
-
>
GetRootElement
(
)
;
nsCOMPtr
<
nsIDOMHTMLDocument
>
htmlDocument
=
do_QueryInterface
(
document
)
;
if
(
htmlDocument
)
{
nsCOMPtr
<
nsIDOMHTMLElement
>
body
;
htmlDocument
-
>
GetBody
(
getter_AddRefs
(
body
)
)
;
nsCOMPtr
<
nsIContent
>
bodyContent
=
do_QueryInterface
(
body
)
;
if
(
bodyContent
)
{
focusedContent
=
bodyContent
;
}
}
}
return
focusedContent
?
focusedContent
.
forget
(
)
:
nullptr
;
}
nsPresContext
*
HardwareKeyHandler
:
:
GetPresContext
(
nsINode
*
aNode
)
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
aNode
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
nullptr
;
}
return
presShell
-
>
GetPresContext
(
)
;
}
already_AddRefed
<
nsIPresShell
>
HardwareKeyHandler
:
:
GetPresShell
(
nsINode
*
aNode
)
{
nsIDocument
*
doc
=
aNode
-
>
OwnerDoc
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
doc
-
>
GetShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
nullptr
;
}
return
presShell
.
forget
(
)
;
}
already_AddRefed
<
HardwareKeyHandler
>
HardwareKeyHandler
:
:
GetInstance
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
nullptr
;
}
if
(
!
sInstance
)
{
sInstance
=
new
HardwareKeyHandler
(
)
;
ClearOnShutdown
(
&
sInstance
)
;
}
RefPtr
<
HardwareKeyHandler
>
service
=
sInstance
.
get
(
)
;
return
service
.
forget
(
)
;
}
}
