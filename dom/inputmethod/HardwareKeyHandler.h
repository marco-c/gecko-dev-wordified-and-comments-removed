#
ifndef
mozilla_HardwareKeyHandler_h_
#
define
mozilla_HardwareKeyHandler_h_
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDeque
.
h
"
#
include
"
nsIHardwareKeyHandler
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
class
nsIContent
;
class
nsINode
;
class
nsIPresShell
;
class
nsPIDOMWindowOuter
;
class
nsPresContext
;
namespace
mozilla
{
struct
KeyboardInfo
:
public
RefCounted
<
KeyboardInfo
>
{
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
KeyboardInfo
)
nsINode
*
mTarget
;
WidgetKeyboardEvent
mEvent
;
nsEventStatus
mStatus
;
KeyboardInfo
(
nsINode
*
aTarget
WidgetKeyboardEvent
&
aEvent
nsEventStatus
aStatus
)
:
mTarget
(
aTarget
)
mEvent
(
aEvent
)
mStatus
(
aStatus
)
{
}
}
;
template
<
class
T
>
class
EventQueueDeallocator
:
public
nsDequeFunctor
{
virtual
void
*
operator
(
)
(
void
*
aObject
)
{
RefPtr
<
T
>
releaseMe
=
dont_AddRef
(
static_cast
<
T
*
>
(
aObject
)
)
;
return
nullptr
;
}
}
;
template
<
class
T
>
class
EventQueue
:
private
nsDeque
{
public
:
EventQueue
(
)
:
nsDeque
(
new
EventQueueDeallocator
<
T
>
(
)
)
{
}
;
~
EventQueue
(
)
{
Clear
(
)
;
}
inline
size_t
GetSize
(
)
{
return
nsDeque
:
:
GetSize
(
)
;
}
bool
IsEmpty
(
)
{
return
!
nsDeque
:
:
GetSize
(
)
;
}
inline
bool
Push
(
T
*
aItem
)
{
MOZ_ASSERT
(
aItem
)
;
NS_ADDREF
(
aItem
)
;
size_t
sizeBefore
=
GetSize
(
)
;
nsDeque
:
:
Push
(
aItem
)
;
if
(
GetSize
(
)
!
=
sizeBefore
+
1
)
{
NS_RELEASE
(
aItem
)
;
return
false
;
}
return
true
;
}
inline
already_AddRefed
<
T
>
PopFront
(
)
{
RefPtr
<
T
>
rv
=
dont_AddRef
(
static_cast
<
T
*
>
(
nsDeque
:
:
PopFront
(
)
)
)
;
return
rv
.
forget
(
)
;
}
inline
void
RemoveFront
(
)
{
RefPtr
<
T
>
releaseMe
=
PopFront
(
)
;
}
inline
T
*
PeekFront
(
)
{
return
static_cast
<
T
*
>
(
nsDeque
:
:
PeekFront
(
)
)
;
}
void
Clear
(
)
{
while
(
GetSize
(
)
>
0
)
{
RemoveFront
(
)
;
}
}
}
;
class
HardwareKeyHandler
:
public
nsIHardwareKeyHandler
{
public
:
HardwareKeyHandler
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIHARDWAREKEYHANDLER
static
already_AddRefed
<
HardwareKeyHandler
>
GetInstance
(
)
;
virtual
bool
ForwardKeyToInputMethodApp
(
nsINode
*
aTarget
WidgetKeyboardEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
override
;
private
:
virtual
~
HardwareKeyHandler
(
)
;
bool
DispatchKeyPress
(
nsINode
*
aTarget
WidgetKeyboardEvent
&
aEvent
nsEventStatus
&
aStatus
)
;
void
DispatchToCurrentProcess
(
nsIPresShell
*
aPresShell
nsIContent
*
aTarget
WidgetKeyboardEvent
&
aEvent
nsEventStatus
&
aStatus
)
;
bool
DispatchToCrossProcess
(
nsINode
*
aTarget
WidgetKeyboardEvent
&
aEvent
)
;
bool
DispatchToTargetApp
(
nsINode
*
aTarget
WidgetKeyboardEvent
&
aEvent
nsEventStatus
&
aStatus
)
;
void
PostHandleKeyboardEvent
(
nsINode
*
aTarget
WidgetKeyboardEvent
&
aEvent
nsEventStatus
&
aStatus
)
;
void
SetDefaultPrevented
(
WidgetKeyboardEvent
&
aEvent
uint16_t
aDefaultPrevented
)
;
bool
CanDispatchEvent
(
nsINode
*
aTarget
WidgetKeyboardEvent
&
aEvent
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetRootWindow
(
nsINode
*
aNode
)
;
already_AddRefed
<
nsIContent
>
GetCurrentTarget
(
)
;
nsPresContext
*
GetPresContext
(
nsINode
*
aNode
)
;
already_AddRefed
<
nsIPresShell
>
GetPresShell
(
nsINode
*
aNode
)
;
static
StaticRefPtr
<
HardwareKeyHandler
>
sInstance
;
EventQueue
<
KeyboardInfo
>
mEventQueue
;
RefPtr
<
KeyboardInfo
>
mLatestKeyDownInfo
;
nsWeakPtr
mHardwareKeyEventListener
;
bool
mInputMethodAppConnected
;
}
;
}
#
endif
