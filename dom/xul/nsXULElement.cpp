#
include
"
nsXULElement
.
h
"
#
include
<
new
>
#
include
<
utility
>
#
include
"
AttrArray
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
ReferrerInfo
.
h
"
#
include
"
Units
.
h
"
#
include
"
XULFrameElement
.
h
"
#
include
"
XULMenuElement
.
h
"
#
include
"
XULPopupElement
.
h
"
#
include
"
XULResizerElement
.
h
"
#
include
"
XULTextElement
.
h
"
#
include
"
XULTooltipElement
.
h
"
#
include
"
XULTreeElement
.
h
"
#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
experimental
/
JSStencil
.
h
"
#
include
"
js
/
OffThreadScriptCompilation
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
Transcoding
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ArrayIterator
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DeclarationBlock
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
GlobalKeyListener
.
h
"
#
include
"
mozilla
/
HoldDropJSObjects
.
h
"
#
include
"
mozilla
/
MacroForEach
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticAnalysisFunctions
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
URLExtraData
.
h
"
#
include
"
mozilla
/
dom
/
BindContext
.
h
"
#
include
"
mozilla
/
dom
/
BorrowedAttrInfo
.
h
"
#
include
"
mozilla
/
dom
/
CSSRuleBinding
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
FragmentOrElement
.
h
"
#
include
"
mozilla
/
dom
/
FromParser
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
mozilla
/
dom
/
ReferrerPolicyBinding
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
XULBroadcastManager
.
h
"
#
include
"
mozilla
/
dom
/
XULCommandEvent
.
h
"
#
include
"
mozilla
/
dom
/
XULElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPUtils
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsAttrValueOrString
.
h
"
#
include
"
nsCaseTreatment
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCompatibility
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCycleCollectionNoteChild
.
h
"
#
include
"
nsCycleCollectionTraversalCallback
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIControllers
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIDOMXULControlElement
.
h
"
#
include
"
nsIDOMXULSelectCntrlItemEl
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIFocusManager
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIObjectInputStream
.
h
"
#
include
"
nsIObjectOutputStream
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsMenuFrame
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPIDOMWindowInlines
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsQueryFrame
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStyledElement
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULControllers
.
h
"
#
include
"
nsXULPopupListener
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsXULPrototypeCache
.
h
"
#
include
"
nsXULTooltipListener
.
h
"
#
include
"
xpcpublic
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
ifdef
XUL_PROTOTYPE_ATTRIBUTE_METERING
uint32_t
nsXULPrototypeAttribute
:
:
gNumElements
;
uint32_t
nsXULPrototypeAttribute
:
:
gNumAttributes
;
uint32_t
nsXULPrototypeAttribute
:
:
gNumCacheTests
;
uint32_t
nsXULPrototypeAttribute
:
:
gNumCacheHits
;
uint32_t
nsXULPrototypeAttribute
:
:
gNumCacheSets
;
uint32_t
nsXULPrototypeAttribute
:
:
gNumCacheFills
;
#
endif
#
define
NS_DISPATCH_XUL_COMMAND
(
1
<
<
0
)
nsXULElement
:
:
nsXULElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
nsStyledElement
(
std
:
:
move
(
aNodeInfo
)
)
{
XUL_PROTOTYPE_ATTRIBUTE_METER
(
gNumElements
)
;
}
nsXULElement
:
:
~
nsXULElement
(
)
=
default
;
nsXULElement
*
NS_NewBasicXULElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
(
std
:
:
move
(
aNodeInfo
)
)
;
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
return
new
(
nim
)
nsXULElement
(
nodeInfo
.
forget
(
)
)
;
}
nsXULElement
*
nsXULElement
:
:
Construct
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
=
aNodeInfo
;
if
(
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
resizer
)
)
{
return
NS_NewXULResizerElement
(
nodeInfo
.
forget
(
)
)
;
}
if
(
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
label
)
|
|
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
description
)
)
{
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
return
new
(
nim
)
XULTextElement
(
nodeInfo
.
forget
(
)
)
;
}
if
(
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
menupopup
)
|
|
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
popup
)
|
|
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
panel
)
)
{
return
NS_NewXULPopupElement
(
nodeInfo
.
forget
(
)
)
;
}
if
(
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
tooltip
)
)
{
return
NS_NewXULTooltipElement
(
nodeInfo
.
forget
(
)
)
;
}
if
(
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
iframe
)
|
|
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
browser
)
|
|
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
editor
)
)
{
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
return
new
(
nim
)
XULFrameElement
(
nodeInfo
.
forget
(
)
)
;
}
if
(
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
menu
)
|
|
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
menulist
)
)
{
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
return
new
(
nim
)
XULMenuElement
(
nodeInfo
.
forget
(
)
)
;
}
if
(
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
tree
)
)
{
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
return
new
(
nim
)
XULTreeElement
(
nodeInfo
.
forget
(
)
)
;
}
return
NS_NewBasicXULElement
(
nodeInfo
.
forget
(
)
)
;
}
already_AddRefed
<
nsXULElement
>
nsXULElement
:
:
CreateFromPrototype
(
nsXULPrototypeElement
*
aPrototype
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
bool
aIsScriptable
bool
aIsRoot
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
aNodeInfo
;
nsCOMPtr
<
Element
>
baseElement
;
NS_NewXULElement
(
getter_AddRefs
(
baseElement
)
ni
.
forget
(
)
dom
:
:
FROM_PARSER_NETWORK
aPrototype
-
>
mIsAtom
)
;
if
(
baseElement
)
{
nsXULElement
*
element
=
FromNode
(
baseElement
)
;
if
(
aPrototype
-
>
mHasIdAttribute
)
{
element
-
>
SetHasID
(
)
;
}
if
(
aPrototype
-
>
mHasClassAttribute
)
{
element
-
>
SetMayHaveClass
(
)
;
}
if
(
aPrototype
-
>
mHasStyleAttribute
)
{
element
-
>
SetMayHaveStyle
(
)
;
}
element
-
>
MakeHeavyweight
(
aPrototype
)
;
if
(
aIsScriptable
)
{
for
(
const
auto
&
attribute
:
aPrototype
-
>
mAttributes
)
{
element
-
>
AddListenerForAttributeIfNeeded
(
attribute
.
mName
)
;
}
}
return
baseElement
.
forget
(
)
.
downcast
<
nsXULElement
>
(
)
;
}
return
nullptr
;
}
nsresult
nsXULElement
:
:
CreateFromPrototype
(
nsXULPrototypeElement
*
aPrototype
Document
*
aDocument
bool
aIsScriptable
bool
aIsRoot
Element
*
*
aResult
)
{
MOZ_ASSERT
(
aPrototype
!
=
nullptr
"
null
ptr
"
)
;
if
(
!
aPrototype
)
return
NS_ERROR_NULL_POINTER
;
MOZ_ASSERT
(
aResult
!
=
nullptr
"
null
ptr
"
)
;
if
(
!
aResult
)
return
NS_ERROR_NULL_POINTER
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
if
(
aDocument
)
{
mozilla
:
:
dom
:
:
NodeInfo
*
ni
=
aPrototype
-
>
mNodeInfo
;
nodeInfo
=
aDocument
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
ni
-
>
NameAtom
(
)
ni
-
>
GetPrefixAtom
(
)
ni
-
>
NamespaceID
(
)
ELEMENT_NODE
)
;
}
else
{
nodeInfo
=
aPrototype
-
>
mNodeInfo
;
}
RefPtr
<
nsXULElement
>
element
=
CreateFromPrototype
(
aPrototype
nodeInfo
aIsScriptable
aIsRoot
)
;
element
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsresult
NS_NewXULElement
(
Element
*
*
aResult
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FromParser
aFromParser
nsAtom
*
aIsAtom
mozilla
:
:
dom
:
:
CustomElementDefinition
*
aDefinition
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
=
aNodeInfo
;
MOZ_ASSERT
(
nodeInfo
"
need
nodeinfo
for
non
-
proto
Create
"
)
;
NS_ASSERTION
(
nodeInfo
-
>
NamespaceEquals
(
kNameSpaceID_XUL
)
"
Trying
to
create
XUL
elements
that
don
'
t
have
the
XUL
namespace
"
)
;
Document
*
doc
=
nodeInfo
-
>
GetDocument
(
)
;
if
(
doc
&
&
!
doc
-
>
AllowXULXBL
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
nsContentUtils
:
:
NewXULOrHTMLElement
(
aResult
nodeInfo
aFromParser
aIsAtom
aDefinition
)
;
}
void
NS_TrustedNewXULElement
(
Element
*
*
aResult
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
aNodeInfo
;
MOZ_ASSERT
(
ni
"
need
nodeinfo
for
non
-
proto
Create
"
)
;
NS_ADDREF
(
*
aResult
=
nsXULElement
:
:
Construct
(
ni
.
forget
(
)
)
)
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
nsXULElement
nsStyledElement
)
NS_IMPL_ADDREF_INHERITED
(
nsXULElement
nsStyledElement
)
NS_IMPL_RELEASE_INHERITED
(
nsXULElement
nsStyledElement
)
NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED
(
nsXULElement
)
NS_ELEMENT_INTERFACE_TABLE_TO_MAP_SEGUE
NS_INTERFACE_MAP_END_INHERITING
(
nsStyledElement
)
nsresult
nsXULElement
:
:
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
)
const
{
*
aResult
=
nullptr
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
aNodeInfo
;
RefPtr
<
nsXULElement
>
element
=
Construct
(
ni
.
forget
(
)
)
;
nsresult
rv
=
const_cast
<
nsXULElement
*
>
(
this
)
-
>
CopyInnerTo
(
element
ReparseAttributes
:
:
No
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
element
.
forget
(
aResult
)
;
return
rv
;
}
EventListenerManager
*
nsXULElement
:
:
GetEventListenerManagerForAttr
(
nsAtom
*
aAttrName
bool
*
aDefer
)
{
Document
*
doc
=
OwnerDoc
(
)
;
nsPIDOMWindowInner
*
window
;
Element
*
root
=
doc
-
>
GetRootElement
(
)
;
if
(
(
!
root
|
|
root
=
=
this
)
&
&
(
window
=
doc
-
>
GetInnerWindow
(
)
)
)
{
nsCOMPtr
<
EventTarget
>
piTarget
=
do_QueryInterface
(
window
)
;
*
aDefer
=
false
;
return
piTarget
-
>
GetOrCreateListenerManager
(
)
;
}
return
nsStyledElement
:
:
GetEventListenerManagerForAttr
(
aAttrName
aDefer
)
;
}
static
bool
IsNonList
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
)
{
return
!
aNodeInfo
-
>
Equals
(
nsGkAtoms
:
:
tree
)
&
&
!
aNodeInfo
-
>
Equals
(
nsGkAtoms
:
:
richlistbox
)
;
}
bool
nsXULElement
:
:
IsFocusableInternal
(
int32_t
*
aTabIndex
bool
aWithMouse
)
{
bool
shouldFocus
=
false
;
#
ifdef
XP_MACOSX
if
(
aWithMouse
&
&
IsNonList
(
mNodeInfo
)
&
&
!
EventStateManager
:
:
IsTopLevelRemoteTarget
(
this
)
)
{
return
false
;
}
#
endif
nsCOMPtr
<
nsIDOMXULControlElement
>
xulControl
=
AsXULControl
(
)
;
if
(
xulControl
)
{
bool
disabled
;
xulControl
-
>
GetDisabled
(
&
disabled
)
;
if
(
disabled
)
{
if
(
aTabIndex
)
*
aTabIndex
=
-
1
;
return
false
;
}
shouldFocus
=
true
;
}
if
(
aTabIndex
)
{
Maybe
<
int32_t
>
attrVal
=
GetTabIndexAttrValue
(
)
;
if
(
attrVal
.
isSome
(
)
)
{
shouldFocus
=
true
;
*
aTabIndex
=
attrVal
.
value
(
)
;
}
else
{
shouldFocus
=
*
aTabIndex
>
=
0
;
if
(
shouldFocus
)
{
*
aTabIndex
=
0
;
}
}
if
(
xulControl
&
&
shouldFocus
&
&
sTabFocusModelAppliesToXUL
&
&
!
(
sTabFocusModel
&
eTabFocus_formElementsMask
)
)
{
if
(
IsNonList
(
mNodeInfo
)
)
{
*
aTabIndex
=
-
1
;
}
}
}
return
shouldFocus
;
}
bool
nsXULElement
:
:
HasMenu
(
)
{
nsMenuFrame
*
menu
=
do_QueryFrame
(
GetPrimaryFrame
(
FlushType
:
:
Frames
)
)
;
return
!
!
menu
;
}
void
nsXULElement
:
:
OpenMenu
(
bool
aOpenFlag
)
{
if
(
Document
*
doc
=
GetComposedDoc
(
)
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
if
(
aOpenFlag
)
{
pm
-
>
ShowMenu
(
this
false
)
;
}
else
{
pm
-
>
HideMenu
(
this
)
;
}
}
}
Result
<
bool
nsresult
>
nsXULElement
:
:
PerformAccesskey
(
bool
aKeyCausesActivation
bool
aIsTrustedEvent
)
{
if
(
IsXULElement
(
nsGkAtoms
:
:
label
)
)
{
nsAutoString
control
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
control
control
)
;
if
(
control
.
IsEmpty
(
)
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
RefPtr
<
Document
>
document
=
GetUncomposedDoc
(
)
;
if
(
!
document
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
RefPtr
<
Element
>
element
=
document
-
>
GetElementById
(
control
)
;
if
(
!
element
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
nsIFrame
*
frame
=
element
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
|
|
!
frame
-
>
IsVisibleConsideringAncestors
(
)
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
return
element
-
>
PerformAccesskey
(
aKeyCausesActivation
aIsTrustedEvent
)
;
}
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
!
frame
|
|
!
frame
-
>
IsVisibleConsideringAncestors
(
)
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
bool
focused
=
false
;
if
(
!
IsXULElement
(
nsGkAtoms
:
:
toolbarbutton
)
)
{
if
(
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
RefPtr
<
Element
>
elementToFocus
=
this
;
if
(
IsXULElement
(
nsGkAtoms
:
:
radio
)
)
{
if
(
nsCOMPtr
<
nsIDOMXULSelectControlItemElement
>
controlItem
=
AsXULSelectControlItem
(
)
)
{
bool
disabled
;
controlItem
-
>
GetDisabled
(
&
disabled
)
;
if
(
!
disabled
)
{
controlItem
-
>
GetControl
(
getter_AddRefs
(
elementToFocus
)
)
;
}
}
}
if
(
elementToFocus
)
{
fm
-
>
SetFocus
(
elementToFocus
nsIFocusManager
:
:
FLAG_BYKEY
)
;
nsPIDOMWindowOuter
*
window
=
OwnerDoc
(
)
-
>
GetWindow
(
)
;
focused
=
(
window
&
&
window
-
>
GetFocusedElement
(
)
=
=
elementToFocus
)
;
}
}
}
if
(
aKeyCausesActivation
&
&
!
IsXULElement
(
nsGkAtoms
:
:
menulist
)
)
{
ClickWithInputSource
(
MouseEvent_Binding
:
:
MOZ_SOURCE_KEYBOARD
aIsTrustedEvent
)
;
return
focused
;
}
return
focused
?
Result
<
bool
nsresult
>
{
focused
}
:
Err
(
NS_ERROR_ABORT
)
;
}
void
nsXULElement
:
:
AddListenerForAttributeIfNeeded
(
nsAtom
*
aLocalName
)
{
if
(
aLocalName
=
=
nsGkAtoms
:
:
menu
|
|
aLocalName
=
=
nsGkAtoms
:
:
contextmenu
|
|
aLocalName
=
=
nsGkAtoms
:
:
popup
|
|
aLocalName
=
=
nsGkAtoms
:
:
context
)
{
AddPopupListener
(
aLocalName
)
;
}
if
(
nsContentUtils
:
:
IsEventAttributeName
(
aLocalName
EventNameType_XUL
)
)
{
nsAutoString
value
;
GetAttr
(
kNameSpaceID_None
aLocalName
value
)
;
SetEventHandler
(
aLocalName
value
true
)
;
}
}
void
nsXULElement
:
:
AddListenerForAttributeIfNeeded
(
const
nsAttrName
&
aName
)
{
if
(
aName
.
IsAtom
(
)
)
{
AddListenerForAttributeIfNeeded
(
aName
.
Atom
(
)
)
;
}
}
void
nsXULElement
:
:
UpdateEditableState
(
bool
aNotify
)
{
nsIContent
*
parent
=
GetParent
(
)
;
SetEditableFlag
(
parent
&
&
parent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
;
UpdateState
(
aNotify
)
;
}
class
XULInContentErrorReporter
:
public
Runnable
{
public
:
explicit
XULInContentErrorReporter
(
Document
&
aDocument
)
:
mozilla
:
:
Runnable
(
"
XULInContentErrorReporter
"
)
mDocument
(
aDocument
)
{
}
NS_IMETHOD
Run
(
)
override
{
mDocument
-
>
WarnOnceAbout
(
DeprecatedOperations
:
:
eImportXULIntoContent
false
)
;
return
NS_OK
;
}
private
:
OwningNonNull
<
Document
>
mDocument
;
}
;
static
bool
NeedTooltipSupport
(
const
nsXULElement
&
aXULElement
)
{
if
(
aXULElement
.
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
treechildren
)
)
{
return
true
;
}
return
aXULElement
.
GetBoolAttr
(
nsGkAtoms
:
:
tooltip
)
|
|
aXULElement
.
GetBoolAttr
(
nsGkAtoms
:
:
tooltiptext
)
;
}
nsresult
nsXULElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
nsresult
rv
=
nsStyledElement
:
:
BindToTree
(
aContext
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
IsInComposedDoc
(
)
)
{
return
rv
;
}
Document
&
doc
=
aContext
.
OwnerDoc
(
)
;
if
(
!
IsInNativeAnonymousSubtree
(
)
&
&
!
doc
.
AllowXULXBL
(
)
&
&
!
doc
.
HasWarnedAbout
(
DeprecatedOperations
:
:
eImportXULIntoContent
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
XULInContentErrorReporter
(
doc
)
)
;
}
#
ifdef
DEBUG
if
(
!
doc
.
AllowXULXBL
(
)
&
&
!
doc
.
IsUnstyledDocument
(
)
)
{
nsAtom
*
tag
=
NodeInfo
(
)
-
>
NameAtom
(
)
;
MOZ_ASSERT
(
tag
=
=
nsGkAtoms
:
:
scrollbar
|
|
tag
=
=
nsGkAtoms
:
:
scrollbarbutton
|
|
tag
=
=
nsGkAtoms
:
:
scrollcorner
|
|
tag
=
=
nsGkAtoms
:
:
slider
|
|
tag
=
=
nsGkAtoms
:
:
thumb
|
|
tag
=
=
nsGkAtoms
:
:
resizer
|
|
tag
=
=
nsGkAtoms
:
:
label
"
Unexpected
XUL
element
in
non
-
XUL
doc
"
)
;
}
#
endif
if
(
doc
.
GetRootElement
(
)
=
=
this
)
{
nsAutoString
cspPolicyStr
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
csp
cspPolicyStr
)
;
#
ifdef
DEBUG
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
docCSP
=
doc
.
GetCsp
(
)
;
uint32_t
policyCount
=
0
;
if
(
docCSP
)
{
docCSP
-
>
GetPolicyCount
(
&
policyCount
)
;
}
MOZ_ASSERT
(
policyCount
=
=
0
"
how
come
we
already
have
a
policy
?
"
)
;
}
#
endif
CSP_ApplyMetaCSPToDoc
(
doc
cspPolicyStr
)
;
}
if
(
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
keyset
kNameSpaceID_XUL
)
)
{
XULKeySetGlobalKeyListener
:
:
AttachKeyHandler
(
this
)
;
}
RegUnRegAccessKey
(
true
)
;
if
(
NeedTooltipSupport
(
*
this
)
)
{
AddTooltipSupport
(
)
;
}
if
(
XULBroadcastManager
:
:
MayNeedListener
(
*
this
)
)
{
if
(
!
doc
.
HasXULBroadcastManager
(
)
)
{
doc
.
InitializeXULBroadcastManager
(
)
;
}
XULBroadcastManager
*
broadcastManager
=
doc
.
GetXULBroadcastManager
(
)
;
broadcastManager
-
>
AddListener
(
this
)
;
}
return
rv
;
}
void
nsXULElement
:
:
UnbindFromTree
(
bool
aNullParent
)
{
if
(
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
keyset
kNameSpaceID_XUL
)
)
{
XULKeySetGlobalKeyListener
:
:
DetachKeyHandler
(
this
)
;
}
RegUnRegAccessKey
(
false
)
;
if
(
NeedTooltipSupport
(
*
this
)
)
{
RemoveTooltipSupport
(
)
;
}
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
doc
&
&
doc
-
>
HasXULBroadcastManager
(
)
&
&
XULBroadcastManager
:
:
MayNeedListener
(
*
this
)
)
{
RefPtr
<
XULBroadcastManager
>
broadcastManager
=
doc
-
>
GetXULBroadcastManager
(
)
;
broadcastManager
-
>
RemoveListener
(
this
)
;
}
nsExtendedDOMSlots
*
slots
=
GetExistingExtendedDOMSlots
(
)
;
if
(
slots
)
{
slots
-
>
mControllers
=
nullptr
;
}
nsStyledElement
:
:
UnbindFromTree
(
aNullParent
)
;
}
void
nsXULElement
:
:
DoneAddingChildren
(
bool
aHaveNotified
)
{
if
(
IsXULElement
(
nsGkAtoms
:
:
linkset
)
)
{
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
doc
)
{
doc
-
>
OnL10nResourceContainerParsed
(
)
;
}
}
}
void
nsXULElement
:
:
RegUnRegAccessKey
(
bool
aDoReg
)
{
if
(
!
SupportsAccessKey
(
)
)
{
return
;
}
nsStyledElement
:
:
RegUnRegAccessKey
(
aDoReg
)
;
}
bool
nsXULElement
:
:
SupportsAccessKey
(
)
const
{
if
(
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
label
)
&
&
HasAttr
(
nsGkAtoms
:
:
control
)
)
{
return
true
;
}
if
(
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
description
)
&
&
HasAttr
(
nsGkAtoms
:
:
value
)
&
&
HasAttr
(
nsGkAtoms
:
:
control
)
)
{
return
true
;
}
return
IsAnyOfXULElements
(
nsGkAtoms
:
:
button
nsGkAtoms
:
:
toolbarbutton
nsGkAtoms
:
:
checkbox
nsGkAtoms
:
:
tab
nsGkAtoms
:
:
radio
)
;
}
nsresult
nsXULElement
:
:
BeforeSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
&
&
(
aName
=
=
nsGkAtoms
:
:
accesskey
|
|
aName
=
=
nsGkAtoms
:
:
control
|
|
aName
=
=
nsGkAtoms
:
:
value
)
)
{
RegUnRegAccessKey
(
false
)
;
}
else
if
(
aNamespaceID
=
=
kNameSpaceID_None
&
&
(
aName
=
=
nsGkAtoms
:
:
command
|
|
aName
=
=
nsGkAtoms
:
:
observes
)
&
&
IsInUncomposedDoc
(
)
)
{
nsAutoString
oldValue
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
observes
oldValue
)
;
if
(
oldValue
.
IsEmpty
(
)
)
{
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
command
oldValue
)
;
}
Document
*
doc
=
GetUncomposedDoc
(
)
;
if
(
!
oldValue
.
IsEmpty
(
)
&
&
doc
-
>
HasXULBroadcastManager
(
)
)
{
RefPtr
<
XULBroadcastManager
>
broadcastManager
=
doc
-
>
GetXULBroadcastManager
(
)
;
broadcastManager
-
>
RemoveListener
(
this
)
;
}
}
else
if
(
aNamespaceID
=
=
kNameSpaceID_None
&
&
aValue
&
&
mNodeInfo
-
>
Equals
(
nsGkAtoms
:
:
window
)
&
&
aName
=
=
nsGkAtoms
:
:
chromemargin
)
{
nsAttrValue
attrValue
;
if
(
!
attrValue
.
ParseIntMarginValue
(
aValue
-
>
String
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
}
else
if
(
aNamespaceID
=
=
kNameSpaceID_None
&
&
aName
=
=
nsGkAtoms
:
:
usercontextid
)
{
nsAutoString
oldValue
;
bool
hasAttribute
=
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
usercontextid
oldValue
)
;
if
(
hasAttribute
&
&
(
!
aValue
|
|
!
aValue
-
>
String
(
)
.
Equals
(
oldValue
)
)
)
{
MOZ_ASSERT
(
false
"
Changing
usercontextid
is
not
allowed
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
return
nsStyledElement
:
:
BeforeSetAttr
(
aNamespaceID
aName
aValue
aNotify
)
;
}
nsresult
nsXULElement
:
:
AfterSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aValue
)
{
AddListenerForAttributeIfNeeded
(
aName
)
;
}
if
(
aName
=
=
nsGkAtoms
:
:
accesskey
|
|
aName
=
=
nsGkAtoms
:
:
control
|
|
aName
=
=
nsGkAtoms
:
:
value
)
{
RegUnRegAccessKey
(
true
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
tooltip
|
|
aName
=
=
nsGkAtoms
:
:
tooltiptext
)
{
if
(
!
!
aValue
!
=
!
!
aOldValue
&
&
IsInComposedDoc
(
)
&
&
!
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
treechildren
)
)
{
if
(
aValue
)
{
AddTooltipSupport
(
)
;
}
else
{
RemoveTooltipSupport
(
)
;
}
}
}
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
doc
&
&
doc
-
>
HasXULBroadcastManager
(
)
)
{
RefPtr
<
XULBroadcastManager
>
broadcastManager
=
doc
-
>
GetXULBroadcastManager
(
)
;
broadcastManager
-
>
AttributeChanged
(
this
aNamespaceID
aName
)
;
}
if
(
doc
&
&
XULBroadcastManager
:
:
MayNeedListener
(
*
this
)
)
{
if
(
!
doc
-
>
HasXULBroadcastManager
(
)
)
{
doc
-
>
InitializeXULBroadcastManager
(
)
;
}
XULBroadcastManager
*
broadcastManager
=
doc
-
>
GetXULBroadcastManager
(
)
;
broadcastManager
-
>
AddListener
(
this
)
;
}
}
return
nsStyledElement
:
:
AfterSetAttr
(
aNamespaceID
aName
aValue
aOldValue
aSubjectPrincipal
aNotify
)
;
}
void
nsXULElement
:
:
AddTooltipSupport
(
)
{
nsXULTooltipListener
*
listener
=
nsXULTooltipListener
:
:
GetInstance
(
)
;
if
(
!
listener
)
{
return
;
}
listener
-
>
AddTooltipSupport
(
this
)
;
}
void
nsXULElement
:
:
RemoveTooltipSupport
(
)
{
nsXULTooltipListener
*
listener
=
nsXULTooltipListener
:
:
GetInstance
(
)
;
if
(
!
listener
)
{
return
;
}
listener
-
>
RemoveTooltipSupport
(
this
)
;
}
bool
nsXULElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
&
&
aAttribute
=
=
nsGkAtoms
:
:
tabindex
)
{
return
aResult
.
ParseIntValue
(
aValue
)
;
}
if
(
!
nsStyledElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
)
{
aResult
.
ParseStringOrAtom
(
aValue
)
;
}
return
true
;
}
void
nsXULElement
:
:
DestroyContent
(
)
{
nsExtendedDOMSlots
*
slots
=
GetExistingExtendedDOMSlots
(
)
;
if
(
slots
)
{
slots
-
>
mControllers
=
nullptr
;
}
nsStyledElement
:
:
DestroyContent
(
)
;
}
#
ifdef
MOZ_DOM_LIST
void
nsXULElement
:
:
List
(
FILE
*
out
int32_t
aIndent
)
const
{
nsCString
prefix
(
"
XUL
"
)
;
if
(
HasSlots
(
)
)
{
prefix
.
Append
(
'
*
'
)
;
}
prefix
.
Append
(
'
'
)
;
nsStyledElement
:
:
List
(
out
aIndent
prefix
)
;
}
#
endif
bool
nsXULElement
:
:
IsEventStoppedFromAnonymousScrollbar
(
EventMessage
aMessage
)
{
return
(
IsRootOfNativeAnonymousSubtree
(
)
&
&
IsAnyOfXULElements
(
nsGkAtoms
:
:
scrollbar
nsGkAtoms
:
:
scrollcorner
)
&
&
(
aMessage
=
=
eMouseClick
|
|
aMessage
=
=
eMouseDoubleClick
|
|
aMessage
=
=
eXULCommand
|
|
aMessage
=
=
eContextMenu
|
|
aMessage
=
=
eDragStart
|
|
aMessage
=
=
eMouseAuxClick
)
)
;
}
nsresult
nsXULElement
:
:
DispatchXULCommand
(
const
EventChainVisitor
&
aVisitor
nsAutoString
&
aCommand
)
{
nsCOMPtr
<
Document
>
doc
=
GetUncomposedDoc
(
)
;
NS_ENSURE_STATE
(
doc
)
;
RefPtr
<
Element
>
commandElt
=
doc
-
>
GetElementById
(
aCommand
)
;
if
(
commandElt
)
{
RefPtr
<
Event
>
event
=
aVisitor
.
mDOMEvent
;
uint16_t
inputSource
=
MouseEvent_Binding
:
:
MOZ_SOURCE_UNKNOWN
;
int16_t
button
=
0
;
while
(
event
)
{
NS_ENSURE_STATE
(
event
-
>
GetOriginalTarget
(
)
!
=
commandElt
)
;
RefPtr
<
XULCommandEvent
>
commandEvent
=
event
-
>
AsXULCommandEvent
(
)
;
if
(
commandEvent
)
{
event
=
commandEvent
-
>
GetSourceEvent
(
)
;
inputSource
=
commandEvent
-
>
InputSource
(
)
;
button
=
commandEvent
-
>
Button
(
)
;
}
else
{
event
=
nullptr
;
}
}
WidgetInputEvent
*
orig
=
aVisitor
.
mEvent
-
>
AsInputEvent
(
)
;
nsContentUtils
:
:
DispatchXULCommand
(
commandElt
orig
-
>
IsTrusted
(
)
MOZ_KnownLive
(
aVisitor
.
mDOMEvent
)
nullptr
orig
-
>
IsControl
(
)
orig
-
>
IsAlt
(
)
orig
-
>
IsShift
(
)
orig
-
>
IsMeta
(
)
inputSource
button
)
;
}
else
{
NS_WARNING
(
"
A
XUL
element
is
attached
to
a
command
that
doesn
'
t
exist
!
\
n
"
)
;
}
return
NS_OK
;
}
void
nsXULElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
aVisitor
.
mForceContentDispatch
=
true
;
if
(
IsEventStoppedFromAnonymousScrollbar
(
aVisitor
.
mEvent
-
>
mMessage
)
)
{
aVisitor
.
mCanHandle
=
true
;
aVisitor
.
SetParentTarget
(
nullptr
false
)
;
return
;
}
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eXULCommand
&
&
aVisitor
.
mEvent
-
>
mClass
=
=
eInputEventClass
&
&
aVisitor
.
mEvent
-
>
mOriginalTarget
=
=
static_cast
<
nsIContent
*
>
(
this
)
&
&
!
IsXULElement
(
nsGkAtoms
:
:
command
)
)
{
if
(
aVisitor
.
mDOMEvent
&
&
aVisitor
.
mDOMEvent
-
>
AsXULCommandEvent
(
)
&
&
HasNonEmptyAttr
(
nsGkAtoms
:
:
command
)
)
{
aVisitor
.
mCanHandle
=
false
;
aVisitor
.
mAutomaticChromeDispatch
=
false
;
aVisitor
.
mWantsPreHandleEvent
=
true
;
aVisitor
.
mItemFlags
|
=
NS_DISPATCH_XUL_COMMAND
;
return
;
}
}
nsStyledElement
:
:
GetEventTargetParent
(
aVisitor
)
;
}
nsresult
nsXULElement
:
:
PreHandleEvent
(
EventChainVisitor
&
aVisitor
)
{
if
(
aVisitor
.
mItemFlags
&
NS_DISPATCH_XUL_COMMAND
)
{
nsAutoString
command
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
command
command
)
;
MOZ_ASSERT
(
!
command
.
IsEmpty
(
)
)
;
return
DispatchXULCommand
(
aVisitor
command
)
;
}
return
nsStyledElement
:
:
PreHandleEvent
(
aVisitor
)
;
}
nsChangeHint
nsXULElement
:
:
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
value
&
&
(
aModType
=
=
MutationEvent_Binding
:
:
REMOVAL
|
|
aModType
=
=
MutationEvent_Binding
:
:
ADDITION
)
&
&
IsAnyOfXULElements
(
nsGkAtoms
:
:
label
nsGkAtoms
:
:
description
)
)
{
return
nsChangeHint_ReconstructFrame
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
type
&
&
IsAnyOfXULElements
(
nsGkAtoms
:
:
toolbarbutton
nsGkAtoms
:
:
button
)
)
{
return
nsChangeHint_ReconstructFrame
;
}
return
nsChangeHint
(
0
)
;
}
NS_IMETHODIMP_
(
bool
)
nsXULElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
return
false
;
}
nsIControllers
*
nsXULElement
:
:
GetControllers
(
ErrorResult
&
rv
)
{
if
(
!
Controllers
(
)
)
{
nsExtendedDOMSlots
*
slots
=
ExtendedDOMSlots
(
)
;
slots
-
>
mControllers
=
new
nsXULControllers
(
)
;
}
return
Controllers
(
)
;
}
void
nsXULElement
:
:
Click
(
CallerType
aCallerType
)
{
ClickWithInputSource
(
MouseEvent_Binding
:
:
MOZ_SOURCE_UNKNOWN
aCallerType
=
=
CallerType
:
:
System
)
;
}
void
nsXULElement
:
:
ClickWithInputSource
(
uint16_t
aInputSource
bool
aIsTrustedEvent
)
{
if
(
BoolAttrIsTrue
(
nsGkAtoms
:
:
disabled
)
)
return
;
nsCOMPtr
<
Document
>
doc
=
GetComposedDoc
(
)
;
if
(
doc
)
{
RefPtr
<
nsPresContext
>
context
=
doc
-
>
GetPresContext
(
)
;
if
(
context
)
{
WidgetMouseEvent
eventDown
(
aIsTrustedEvent
eMouseDown
nullptr
WidgetMouseEvent
:
:
eReal
)
;
WidgetMouseEvent
eventUp
(
aIsTrustedEvent
eMouseUp
nullptr
WidgetMouseEvent
:
:
eReal
)
;
WidgetMouseEvent
eventClick
(
aIsTrustedEvent
eMouseClick
nullptr
WidgetMouseEvent
:
:
eReal
)
;
eventDown
.
mInputSource
=
eventUp
.
mInputSource
=
eventClick
.
mInputSource
=
aInputSource
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
EventDispatcher
:
:
Dispatch
(
static_cast
<
nsIContent
*
>
(
this
)
context
&
eventDown
nullptr
&
status
)
;
status
=
nsEventStatus_eIgnore
;
EventDispatcher
:
:
Dispatch
(
static_cast
<
nsIContent
*
>
(
this
)
context
&
eventUp
nullptr
&
status
)
;
status
=
nsEventStatus_eIgnore
;
EventDispatcher
:
:
Dispatch
(
static_cast
<
nsIContent
*
>
(
this
)
context
&
eventClick
nullptr
&
status
)
;
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
}
}
DoCommand
(
)
;
}
void
nsXULElement
:
:
DoCommand
(
)
{
nsCOMPtr
<
Document
>
doc
=
GetComposedDoc
(
)
;
if
(
doc
)
{
RefPtr
<
nsXULElement
>
self
=
this
;
nsContentUtils
:
:
DispatchXULCommand
(
self
true
)
;
}
}
bool
nsXULElement
:
:
IsNodeOfType
(
uint32_t
aFlags
)
const
{
return
false
;
}
nsresult
nsXULElement
:
:
AddPopupListener
(
nsAtom
*
aName
)
{
bool
isContext
=
(
aName
=
=
nsGkAtoms
:
:
context
|
|
aName
=
=
nsGkAtoms
:
:
contextmenu
)
;
uint32_t
listenerFlag
=
isContext
?
XUL_ELEMENT_HAS_CONTENTMENU_LISTENER
:
XUL_ELEMENT_HAS_POPUP_LISTENER
;
if
(
HasFlag
(
listenerFlag
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMEventListener
>
listener
=
new
nsXULPopupListener
(
this
isContext
)
;
EventListenerManager
*
manager
=
GetOrCreateListenerManager
(
)
;
SetFlags
(
listenerFlag
)
;
if
(
isContext
)
{
manager
-
>
AddEventListenerByType
(
listener
u
"
contextmenu
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
else
{
manager
-
>
AddEventListenerByType
(
listener
u
"
mousedown
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
return
NS_OK
;
}
nsresult
nsXULElement
:
:
MakeHeavyweight
(
nsXULPrototypeElement
*
aPrototype
)
{
if
(
!
aPrototype
)
{
return
NS_OK
;
}
size_t
i
;
nsresult
rv
;
for
(
i
=
0
;
i
<
aPrototype
-
>
mAttributes
.
Length
(
)
;
+
+
i
)
{
nsXULPrototypeAttribute
*
protoattr
=
&
aPrototype
-
>
mAttributes
[
i
]
;
nsAttrValue
attrValue
;
if
(
protoattr
-
>
mValue
.
Type
(
)
=
=
nsAttrValue
:
:
eCSSDeclaration
)
{
DeclarationBlock
*
decl
=
protoattr
-
>
mValue
.
GetCSSDeclarationValue
(
)
;
RefPtr
<
DeclarationBlock
>
declClone
=
decl
-
>
Clone
(
)
;
nsString
stringValue
;
protoattr
-
>
mValue
.
ToString
(
stringValue
)
;
attrValue
.
SetTo
(
declClone
.
forget
(
)
&
stringValue
)
;
}
else
{
attrValue
.
SetTo
(
protoattr
-
>
mValue
)
;
}
bool
oldValueSet
;
if
(
protoattr
-
>
mName
.
IsAtom
(
)
)
{
rv
=
mAttrs
.
SetAndSwapAttr
(
protoattr
-
>
mName
.
Atom
(
)
attrValue
&
oldValueSet
)
;
}
else
{
rv
=
mAttrs
.
SetAndSwapAttr
(
protoattr
-
>
mName
.
NodeInfo
(
)
attrValue
&
oldValueSet
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
bool
nsXULElement
:
:
BoolAttrIsTrue
(
nsAtom
*
aName
)
const
{
const
nsAttrValue
*
attr
=
GetAttrInfo
(
kNameSpaceID_None
aName
)
.
mValue
;
return
attr
&
&
attr
-
>
Type
(
)
=
=
nsAttrValue
:
:
eAtom
&
&
attr
-
>
GetAtomValue
(
)
=
=
nsGkAtoms
:
:
_true
;
}
bool
nsXULElement
:
:
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
{
return
nsContentUtils
:
:
IsEventAttributeName
(
aName
EventNameType_XUL
)
;
}
JSObject
*
nsXULElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
XULElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
bool
nsXULElement
:
:
IsInteractiveHTMLContent
(
)
const
{
return
IsXULElement
(
nsGkAtoms
:
:
menupopup
)
|
|
Element
:
:
IsInteractiveHTMLContent
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsXULPrototypeNode
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsXULPrototypeNode
)
if
(
tmp
-
>
mType
=
=
nsXULPrototypeNode
:
:
eType_Element
)
{
static_cast
<
nsXULPrototypeElement
*
>
(
tmp
)
-
>
Unlink
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsXULPrototypeNode
)
if
(
tmp
-
>
mType
=
=
nsXULPrototypeNode
:
:
eType_Element
)
{
nsXULPrototypeElement
*
elem
=
static_cast
<
nsXULPrototypeElement
*
>
(
tmp
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mNodeInfo
"
)
;
cb
.
NoteNativeChild
(
elem
-
>
mNodeInfo
NS_CYCLE_COLLECTION_PARTICIPANT
(
NodeInfo
)
)
;
size_t
i
;
for
(
i
=
0
;
i
<
elem
-
>
mAttributes
.
Length
(
)
;
+
+
i
)
{
const
nsAttrName
&
name
=
elem
-
>
mAttributes
[
i
]
.
mName
;
if
(
!
name
.
IsAtom
(
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mAttributes
[
i
]
.
mName
.
NodeInfo
(
)
"
)
;
cb
.
NoteNativeChild
(
name
.
NodeInfo
(
)
NS_CYCLE_COLLECTION_PARTICIPANT
(
NodeInfo
)
)
;
}
}
ImplCycleCollectionTraverse
(
cb
elem
-
>
mChildren
"
mChildren
"
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
nsXULPrototypeNode
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
nsXULPrototypeNode
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
nsXULPrototypeNode
Release
)
nsXULPrototypeAttribute
:
:
~
nsXULPrototypeAttribute
(
)
{
MOZ_COUNT_DTOR
(
nsXULPrototypeAttribute
)
;
}
nsresult
nsXULPrototypeElement
:
:
Serialize
(
nsIObjectOutputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
{
nsresult
rv
;
rv
=
aStream
-
>
Write32
(
mType
)
;
int32_t
index
=
aNodeInfos
-
>
IndexOf
(
mNodeInfo
)
;
NS_ASSERTION
(
index
>
=
0
"
unknown
mozilla
:
:
dom
:
:
NodeInfo
index
"
)
;
nsresult
tmp
=
aStream
-
>
Write32
(
index
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
tmp
=
aStream
-
>
Write32
(
mAttributes
.
Length
(
)
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
nsAutoString
attributeValue
;
size_t
i
;
for
(
i
=
0
;
i
<
mAttributes
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
;
if
(
mAttributes
[
i
]
.
mName
.
IsAtom
(
)
)
{
ni
=
mNodeInfo
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
mAttributes
[
i
]
.
mName
.
Atom
(
)
nullptr
kNameSpaceID_None
nsINode
:
:
ATTRIBUTE_NODE
)
;
NS_ASSERTION
(
ni
"
the
nodeinfo
should
already
exist
"
)
;
}
else
{
ni
=
mAttributes
[
i
]
.
mName
.
NodeInfo
(
)
;
}
index
=
aNodeInfos
-
>
IndexOf
(
ni
)
;
NS_ASSERTION
(
index
>
=
0
"
unknown
mozilla
:
:
dom
:
:
NodeInfo
index
"
)
;
tmp
=
aStream
-
>
Write32
(
index
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
mAttributes
[
i
]
.
mValue
.
ToString
(
attributeValue
)
;
tmp
=
aStream
-
>
WriteWStringZ
(
attributeValue
.
get
(
)
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
}
tmp
=
aStream
-
>
Write32
(
uint32_t
(
mChildren
.
Length
(
)
)
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
for
(
i
=
0
;
i
<
mChildren
.
Length
(
)
;
i
+
+
)
{
nsXULPrototypeNode
*
child
=
mChildren
[
i
]
.
get
(
)
;
switch
(
child
-
>
mType
)
{
case
eType_Element
:
case
eType_Text
:
case
eType_PI
:
tmp
=
child
-
>
Serialize
(
aStream
aProtoDoc
aNodeInfos
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
break
;
case
eType_Script
:
tmp
=
aStream
-
>
Write32
(
child
-
>
mType
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
nsXULPrototypeScript
*
script
=
static_cast
<
nsXULPrototypeScript
*
>
(
child
)
;
tmp
=
aStream
-
>
Write8
(
script
-
>
mOutOfLine
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
if
(
!
script
-
>
mOutOfLine
)
{
tmp
=
script
-
>
Serialize
(
aStream
aProtoDoc
aNodeInfos
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
}
else
{
tmp
=
aStream
-
>
WriteCompoundObject
(
script
-
>
mSrcURI
NS_GET_IID
(
nsIURI
)
true
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
if
(
script
-
>
HasStencil
(
)
)
{
tmp
=
script
-
>
SerializeOutOfLine
(
aStream
aProtoDoc
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
}
}
break
;
}
}
return
rv
;
}
nsresult
nsXULPrototypeElement
:
:
Deserialize
(
nsIObjectInputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
nsIURI
*
aDocumentURI
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
{
MOZ_ASSERT
(
aNodeInfos
"
missing
nodeinfo
array
"
)
;
uint32_t
number
=
0
;
nsresult
rv
=
aStream
-
>
Read32
(
&
number
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
mNodeInfo
=
aNodeInfos
-
>
SafeElementAt
(
number
nullptr
)
;
if
(
!
mNodeInfo
)
{
return
NS_ERROR_UNEXPECTED
;
}
rv
=
aStream
-
>
Read32
(
&
number
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
int32_t
attributes
=
int32_t
(
number
)
;
if
(
attributes
>
0
)
{
mAttributes
.
AppendElements
(
attributes
)
;
nsAutoString
attributeValue
;
for
(
size_t
i
=
0
;
i
<
mAttributes
.
Length
(
)
;
+
+
i
)
{
rv
=
aStream
-
>
Read32
(
&
number
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
mozilla
:
:
dom
:
:
NodeInfo
*
ni
=
aNodeInfos
-
>
SafeElementAt
(
number
nullptr
)
;
if
(
!
ni
)
{
return
NS_ERROR_UNEXPECTED
;
}
mAttributes
[
i
]
.
mName
.
SetTo
(
ni
)
;
rv
=
aStream
-
>
ReadString
(
attributeValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
rv
=
SetAttrAt
(
i
attributeValue
aDocumentURI
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
}
}
rv
=
aStream
-
>
Read32
(
&
number
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
uint32_t
numChildren
=
int32_t
(
number
)
;
if
(
numChildren
>
0
)
{
if
(
!
mChildren
.
SetCapacity
(
numChildren
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
for
(
uint32_t
i
=
0
;
i
<
numChildren
;
i
+
+
)
{
rv
=
aStream
-
>
Read32
(
&
number
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
Type
childType
=
(
Type
)
number
;
RefPtr
<
nsXULPrototypeNode
>
child
;
switch
(
childType
)
{
case
eType_Element
:
child
=
new
nsXULPrototypeElement
(
)
;
rv
=
child
-
>
Deserialize
(
aStream
aProtoDoc
aDocumentURI
aNodeInfos
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
break
;
case
eType_Text
:
child
=
new
nsXULPrototypeText
(
)
;
rv
=
child
-
>
Deserialize
(
aStream
aProtoDoc
aDocumentURI
aNodeInfos
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
break
;
case
eType_PI
:
child
=
new
nsXULPrototypePI
(
)
;
rv
=
child
-
>
Deserialize
(
aStream
aProtoDoc
aDocumentURI
aNodeInfos
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
break
;
case
eType_Script
:
{
RefPtr
<
nsXULPrototypeScript
>
script
=
new
nsXULPrototypeScript
(
0
)
;
rv
=
aStream
-
>
ReadBoolean
(
&
script
-
>
mOutOfLine
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
if
(
!
script
-
>
mOutOfLine
)
{
rv
=
script
-
>
Deserialize
(
aStream
aProtoDoc
aDocumentURI
aNodeInfos
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
}
else
{
nsCOMPtr
<
nsISupports
>
supports
;
rv
=
aStream
-
>
ReadObject
(
true
getter_AddRefs
(
supports
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
script
-
>
mSrcURI
=
do_QueryInterface
(
supports
)
;
rv
=
script
-
>
DeserializeOutOfLine
(
aStream
aProtoDoc
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
}
child
=
std
:
:
move
(
script
)
;
break
;
}
default
:
MOZ_ASSERT
(
false
"
Unexpected
child
type
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
child
"
Don
'
t
append
null
to
mChildren
"
)
;
MOZ_ASSERT
(
child
-
>
mType
=
=
childType
)
;
mChildren
.
AppendElement
(
child
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
return
rv
;
}
}
return
rv
;
}
nsresult
nsXULPrototypeElement
:
:
SetAttrAt
(
uint32_t
aPos
const
nsAString
&
aValue
nsIURI
*
aDocumentURI
)
{
MOZ_ASSERT
(
aPos
<
mAttributes
.
Length
(
)
"
out
-
of
-
bounds
"
)
;
if
(
!
mNodeInfo
-
>
NamespaceEquals
(
kNameSpaceID_XUL
)
)
{
if
(
mNodeInfo
-
>
NamespaceEquals
(
kNameSpaceID_XHTML
)
&
&
mAttributes
[
aPos
]
.
mName
.
Equals
(
nsGkAtoms
:
:
is
)
)
{
mAttributes
[
aPos
]
.
mValue
.
ParseAtom
(
aValue
)
;
mIsAtom
=
mAttributes
[
aPos
]
.
mValue
.
GetAtomValue
(
)
;
return
NS_OK
;
}
mAttributes
[
aPos
]
.
mValue
.
ParseStringOrAtom
(
aValue
)
;
return
NS_OK
;
}
if
(
mAttributes
[
aPos
]
.
mName
.
Equals
(
nsGkAtoms
:
:
id
)
&
&
!
aValue
.
IsEmpty
(
)
)
{
mHasIdAttribute
=
true
;
mAttributes
[
aPos
]
.
mValue
.
ParseAtom
(
aValue
)
;
return
NS_OK
;
}
else
if
(
mAttributes
[
aPos
]
.
mName
.
Equals
(
nsGkAtoms
:
:
is
)
)
{
mAttributes
[
aPos
]
.
mValue
.
ParseAtom
(
aValue
)
;
mIsAtom
=
mAttributes
[
aPos
]
.
mValue
.
GetAtomValue
(
)
;
return
NS_OK
;
}
else
if
(
mAttributes
[
aPos
]
.
mName
.
Equals
(
nsGkAtoms
:
:
_class
)
)
{
mHasClassAttribute
=
true
;
mAttributes
[
aPos
]
.
mValue
.
ParseAtomArray
(
aValue
)
;
return
NS_OK
;
}
else
if
(
mAttributes
[
aPos
]
.
mName
.
Equals
(
nsGkAtoms
:
:
style
)
)
{
mHasStyleAttribute
=
true
;
nsIPrincipal
*
principal
=
mNodeInfo
-
>
NodeInfoManager
(
)
-
>
DocumentPrincipal
(
)
;
auto
referrerInfo
=
MakeRefPtr
<
ReferrerInfo
>
(
aDocumentURI
ReferrerPolicy
:
:
_empty
)
;
auto
data
=
MakeRefPtr
<
URLExtraData
>
(
aDocumentURI
referrerInfo
principal
)
;
RefPtr
<
DeclarationBlock
>
declaration
=
DeclarationBlock
:
:
FromCssText
(
aValue
data
eCompatibility_FullStandards
nullptr
StyleCssRuleType
:
:
Style
)
;
if
(
declaration
)
{
mAttributes
[
aPos
]
.
mValue
.
SetTo
(
declaration
.
forget
(
)
&
aValue
)
;
return
NS_OK
;
}
}
else
if
(
mAttributes
[
aPos
]
.
mName
.
Equals
(
nsGkAtoms
:
:
tabindex
)
)
{
mAttributes
[
aPos
]
.
mValue
.
ParseIntValue
(
aValue
)
;
return
NS_OK
;
}
mAttributes
[
aPos
]
.
mValue
.
ParseStringOrAtom
(
aValue
)
;
return
NS_OK
;
}
void
nsXULPrototypeElement
:
:
Unlink
(
)
{
mAttributes
.
Clear
(
)
;
mChildren
.
Clear
(
)
;
}
nsXULPrototypeScript
:
:
nsXULPrototypeScript
(
uint32_t
aLineNo
)
:
nsXULPrototypeNode
(
eType_Script
)
mLineNo
(
aLineNo
)
mSrcLoading
(
false
)
mOutOfLine
(
true
)
mSrcLoadWaiters
(
nullptr
)
mStencil
(
nullptr
)
{
}
static
nsresult
WriteStencil
(
nsIObjectOutputStream
*
aStream
JSContext
*
aCx
JS
:
:
Stencil
*
aStencil
)
{
JS
:
:
TranscodeBuffer
buffer
;
JS
:
:
TranscodeResult
code
;
code
=
JS
:
:
EncodeStencil
(
aCx
aStencil
buffer
)
;
if
(
code
!
=
JS
:
:
TranscodeResult
:
:
Ok
)
{
if
(
code
=
=
JS
:
:
TranscodeResult
:
:
Throw
)
{
JS_ClearPendingException
(
aCx
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
MOZ_ASSERT
(
IsTranscodeFailureResult
(
code
)
)
;
return
NS_ERROR_FAILURE
;
}
size_t
size
=
buffer
.
length
(
)
;
if
(
size
>
UINT32_MAX
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
aStream
-
>
Write32
(
size
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
aStream
-
>
WriteBytes
(
Span
(
buffer
.
begin
(
)
size
)
)
;
}
return
rv
;
}
static
nsresult
ReadStencil
(
nsIObjectInputStream
*
aStream
JSContext
*
aCx
const
JS
:
:
DecodeOptions
&
aOptions
JS
:
:
Stencil
*
*
aStencilOut
)
{
JSObject
*
loaderGlobal
=
xpc
:
:
CompilationScope
(
)
;
MOZ_RELEASE_ASSERT
(
nsContentUtils
:
:
IsSystemCaller
(
aCx
)
|
|
JS
:
:
CurrentGlobalOrNull
(
aCx
)
=
=
loaderGlobal
)
;
uint32_t
size
;
nsresult
rv
=
aStream
-
>
Read32
(
&
size
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
char
*
data
;
rv
=
aStream
-
>
ReadBytes
(
size
&
data
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MOZ_ASSERT
(
!
aOptions
.
borrowBuffer
)
;
auto
cleanupData
=
MakeScopeExit
(
[
&
]
(
)
{
free
(
data
)
;
}
)
;
JS
:
:
TranscodeRange
range
(
reinterpret_cast
<
uint8_t
*
>
(
data
)
size
)
;
{
JS
:
:
TranscodeResult
code
;
RefPtr
<
JS
:
:
Stencil
>
stencil
;
code
=
JS
:
:
DecodeStencil
(
aCx
aOptions
range
getter_AddRefs
(
stencil
)
)
;
if
(
code
!
=
JS
:
:
TranscodeResult
:
:
Ok
)
{
if
(
code
=
=
JS
:
:
TranscodeResult
:
:
Throw
)
{
JS_ClearPendingException
(
aCx
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
MOZ_ASSERT
(
IsTranscodeFailureResult
(
code
)
)
;
return
NS_ERROR_FAILURE
;
}
stencil
.
forget
(
aStencilOut
)
;
}
return
rv
;
}
void
nsXULPrototypeScript
:
:
FillCompileOptions
(
JS
:
:
CompileOptions
&
options
)
{
options
.
setSourceIsLazy
(
mOutOfLine
)
;
}
nsresult
nsXULPrototypeScript
:
:
Serialize
(
nsIObjectOutputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
{
NS_ENSURE_TRUE
(
aProtoDoc
NS_ERROR_UNEXPECTED
)
;
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
xpc
:
:
CompilationScope
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
NS_ASSERTION
(
!
mSrcLoading
|
|
mSrcLoadWaiters
!
=
nullptr
|
|
!
mStencil
"
script
source
still
loading
when
serializing
?
!
"
)
;
if
(
!
mStencil
)
return
NS_ERROR_FAILURE
;
nsresult
rv
;
rv
=
aStream
-
>
Write32
(
mLineNo
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
MOZ_ASSERT
(
xpc
:
:
CompilationScope
(
)
=
=
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
return
WriteStencil
(
aStream
cx
mStencil
)
;
}
nsresult
nsXULPrototypeScript
:
:
SerializeOutOfLine
(
nsIObjectOutputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
)
{
if
(
!
mSrcURI
-
>
SchemeIs
(
"
chrome
"
)
)
return
NS_ERROR_NOT_IMPLEMENTED
;
nsXULPrototypeCache
*
cache
=
nsXULPrototypeCache
:
:
GetInstance
(
)
;
if
(
!
cache
)
return
NS_ERROR_OUT_OF_MEMORY
;
NS_ASSERTION
(
cache
-
>
IsEnabled
(
)
"
writing
to
the
cache
file
but
the
XUL
cache
is
off
?
"
)
;
bool
exists
;
cache
-
>
HasScript
(
mSrcURI
&
exists
)
;
if
(
exists
)
return
NS_OK
;
nsCOMPtr
<
nsIObjectOutputStream
>
oos
;
nsresult
rv
=
cache
-
>
GetScriptOutputStream
(
mSrcURI
getter_AddRefs
(
oos
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsresult
tmp
=
Serialize
(
oos
aProtoDoc
nullptr
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
tmp
=
cache
-
>
FinishScriptOutputStream
(
mSrcURI
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
if
(
NS_FAILED
(
rv
)
)
cache
-
>
AbortCaching
(
)
;
return
rv
;
}
nsresult
nsXULPrototypeScript
:
:
Deserialize
(
nsIObjectInputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
nsIURI
*
aDocumentURI
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
{
nsresult
rv
;
NS_ASSERTION
(
!
mSrcLoading
|
|
mSrcLoadWaiters
!
=
nullptr
|
|
!
mStencil
"
prototype
script
not
well
-
initialized
when
deserializing
?
!
"
)
;
rv
=
aStream
-
>
Read32
(
&
mLineNo
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
xpc
:
:
CompilationScope
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
DecodeOptions
options
;
RefPtr
<
JS
:
:
Stencil
>
newStencil
;
rv
=
ReadStencil
(
aStream
cx
options
getter_AddRefs
(
newStencil
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Set
(
newStencil
)
;
return
NS_OK
;
}
nsresult
nsXULPrototypeScript
:
:
DeserializeOutOfLine
(
nsIObjectInputStream
*
aInput
nsXULPrototypeDocument
*
aProtoDoc
)
{
nsresult
rv
=
NS_OK
;
nsXULPrototypeCache
*
cache
=
nsXULPrototypeCache
:
:
GetInstance
(
)
;
nsCOMPtr
<
nsIObjectInputStream
>
objectInput
=
aInput
;
if
(
cache
)
{
bool
useXULCache
=
true
;
if
(
mSrcURI
)
{
useXULCache
=
cache
-
>
IsEnabled
(
)
;
if
(
useXULCache
)
{
RefPtr
<
JS
:
:
Stencil
>
newStencil
=
cache
-
>
GetStencil
(
mSrcURI
)
;
if
(
newStencil
)
{
Set
(
newStencil
)
;
}
}
}
if
(
!
mStencil
)
{
if
(
mSrcURI
)
{
rv
=
cache
-
>
GetScriptInputStream
(
mSrcURI
getter_AddRefs
(
objectInput
)
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
Deserialize
(
objectInput
aProtoDoc
nullptr
nullptr
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
useXULCache
&
&
mSrcURI
&
&
mSrcURI
-
>
SchemeIs
(
"
chrome
"
)
)
{
cache
-
>
PutStencil
(
mSrcURI
GetStencil
(
)
)
;
}
cache
-
>
FinishScriptInputStream
(
mSrcURI
)
;
}
else
{
if
(
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
cache
-
>
AbortCaching
(
)
;
}
}
}
return
rv
;
}
class
NotifyOffThreadScriptCompletedRunnable
:
public
Runnable
{
static
StaticAutoPtr
<
nsTArray
<
nsCOMPtr
<
nsIOffThreadScriptReceiver
>
>
>
sReceivers
;
static
bool
sSetupClearOnShutdown
;
nsIOffThreadScriptReceiver
*
mReceiver
;
JS
:
:
OffThreadToken
*
mToken
;
public
:
NotifyOffThreadScriptCompletedRunnable
(
nsIOffThreadScriptReceiver
*
aReceiver
JS
:
:
OffThreadToken
*
aToken
)
:
mozilla
:
:
Runnable
(
"
NotifyOffThreadScriptCompletedRunnable
"
)
mReceiver
(
aReceiver
)
mToken
(
aToken
)
{
}
static
void
NoteReceiver
(
nsIOffThreadScriptReceiver
*
aReceiver
)
{
if
(
!
sSetupClearOnShutdown
)
{
ClearOnShutdown
(
&
sReceivers
)
;
sSetupClearOnShutdown
=
true
;
sReceivers
=
new
nsTArray
<
nsCOMPtr
<
nsIOffThreadScriptReceiver
>
>
(
)
;
}
sReceivers
-
>
AppendElement
(
aReceiver
)
;
}
NS_DECL_NSIRUNNABLE
}
;
StaticAutoPtr
<
nsTArray
<
nsCOMPtr
<
nsIOffThreadScriptReceiver
>
>
>
NotifyOffThreadScriptCompletedRunnable
:
:
sReceivers
;
bool
NotifyOffThreadScriptCompletedRunnable
:
:
sSetupClearOnShutdown
=
false
;
NS_IMETHODIMP
NotifyOffThreadScriptCompletedRunnable
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
JS
:
:
Stencil
>
stencil
;
{
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
xpc
:
:
CompilationScope
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
stencil
=
JS
:
:
FinishCompileToStencilOffThread
(
cx
mToken
)
;
}
if
(
!
sReceivers
)
{
return
NS_OK
;
}
auto
index
=
sReceivers
-
>
IndexOf
(
mReceiver
)
;
MOZ_RELEASE_ASSERT
(
index
!
=
sReceivers
-
>
NoIndex
)
;
nsCOMPtr
<
nsIOffThreadScriptReceiver
>
receiver
=
std
:
:
move
(
(
*
sReceivers
)
[
index
]
)
;
sReceivers
-
>
RemoveElementAt
(
index
)
;
return
receiver
-
>
OnScriptCompileComplete
(
stencil
stencil
?
NS_OK
:
NS_ERROR_FAILURE
)
;
}
static
void
OffThreadScriptReceiverCallback
(
JS
:
:
OffThreadToken
*
aToken
void
*
aCallbackData
)
{
nsIOffThreadScriptReceiver
*
aReceiver
=
static_cast
<
nsIOffThreadScriptReceiver
*
>
(
aCallbackData
)
;
RefPtr
<
NotifyOffThreadScriptCompletedRunnable
>
notify
=
new
NotifyOffThreadScriptCompletedRunnable
(
aReceiver
aToken
)
;
NS_DispatchToMainThread
(
notify
)
;
}
nsresult
nsXULPrototypeScript
:
:
Compile
(
const
char16_t
*
aText
size_t
aTextLength
JS
:
:
SourceOwnership
aOwnership
nsIURI
*
aURI
uint32_t
aLineNo
Document
*
aDocument
nsIOffThreadScriptReceiver
*
aOffThreadReceiver
)
{
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
xpc
:
:
CompilationScope
(
)
)
)
{
if
(
aOwnership
=
=
JS
:
:
SourceOwnership
:
:
TakeOwnership
)
{
js_free
(
const_cast
<
char16_t
*
>
(
aText
)
)
;
}
return
NS_ERROR_UNEXPECTED
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
SourceText
<
char16_t
>
srcBuf
;
if
(
NS_WARN_IF
(
!
srcBuf
.
init
(
cx
aText
aTextLength
aOwnership
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
urlspec
;
nsresult
rv
=
aURI
-
>
GetSpec
(
urlspec
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
JS
:
:
CompileOptions
options
(
cx
)
;
FillCompileOptions
(
options
)
;
options
.
setIntroductionType
(
mOutOfLine
?
"
srcScript
"
:
"
inlineScript
"
)
.
setFileAndLine
(
urlspec
.
get
(
)
mOutOfLine
?
1
:
aLineNo
)
;
JS
:
:
Rooted
<
JSObject
*
>
scope
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
if
(
aOffThreadReceiver
&
&
JS
:
:
CanCompileOffThread
(
cx
options
aTextLength
)
)
{
if
(
!
JS
:
:
CompileToStencilOffThread
(
cx
options
srcBuf
OffThreadScriptReceiverCallback
static_cast
<
void
*
>
(
aOffThreadReceiver
)
)
)
{
JS_ClearPendingException
(
cx
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
NotifyOffThreadScriptCompletedRunnable
:
:
NoteReceiver
(
aOffThreadReceiver
)
;
}
else
{
RefPtr
<
JS
:
:
Stencil
>
stencil
=
JS
:
:
CompileGlobalScriptToStencil
(
cx
options
srcBuf
)
;
if
(
!
stencil
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
Set
(
stencil
)
;
}
return
NS_OK
;
}
nsresult
nsXULPrototypeScript
:
:
InstantiateScript
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSScript
*
>
aScript
)
{
MOZ_ASSERT
(
mStencil
)
;
JS
:
:
CompileOptions
options
(
aCx
)
;
FillCompileOptions
(
options
)
;
JS
:
:
InstantiateOptions
instantiateOptions
(
options
)
;
aScript
.
set
(
JS
:
:
InstantiateGlobalStencil
(
aCx
instantiateOptions
mStencil
)
)
;
if
(
!
aScript
)
{
JS_ClearPendingException
(
aCx
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
void
nsXULPrototypeScript
:
:
Set
(
JS
:
:
Stencil
*
aStencil
)
{
mStencil
=
aStencil
;
}
nsresult
nsXULPrototypeText
:
:
Serialize
(
nsIObjectOutputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
{
nsresult
rv
;
rv
=
aStream
-
>
Write32
(
mType
)
;
nsresult
tmp
=
aStream
-
>
WriteWStringZ
(
mValue
.
get
(
)
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
return
rv
;
}
nsresult
nsXULPrototypeText
:
:
Deserialize
(
nsIObjectInputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
nsIURI
*
aDocumentURI
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
{
nsresult
rv
=
aStream
-
>
ReadString
(
mValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
nsXULPrototypePI
:
:
Serialize
(
nsIObjectOutputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
{
nsresult
rv
;
rv
=
aStream
-
>
Write32
(
mType
)
;
nsresult
tmp
=
aStream
-
>
WriteWStringZ
(
mTarget
.
get
(
)
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
tmp
=
aStream
-
>
WriteWStringZ
(
mData
.
get
(
)
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
return
rv
;
}
nsresult
nsXULPrototypePI
:
:
Deserialize
(
nsIObjectInputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
nsIURI
*
aDocumentURI
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
{
nsresult
rv
;
rv
=
aStream
-
>
ReadString
(
mTarget
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
aStream
-
>
ReadString
(
mData
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
rv
;
}
