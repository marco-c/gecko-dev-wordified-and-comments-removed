#
include
"
nsXULPopupListener
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
nsIObjectLoadingContent
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
FragmentOrElement
.
h
"
#
include
"
mozilla
/
dom
/
MouseEvent
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsMenuFrame
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
if
defined
(
XP_WIN
)
#
define
NS_CONTEXT_MENU_IS_MOUSEUP
1
#
endif
nsXULPopupListener
:
:
nsXULPopupListener
(
mozilla
:
:
dom
:
:
Element
*
aElement
bool
aIsContext
)
:
mElement
(
aElement
)
mPopupContent
(
nullptr
)
mIsContext
(
aIsContext
)
{
}
nsXULPopupListener
:
:
~
nsXULPopupListener
(
void
)
{
ClosePopup
(
)
;
}
NS_IMPL_CYCLE_COLLECTION
(
nsXULPopupListener
mElement
mPopupContent
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsXULPopupListener
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsXULPopupListener
)
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
nsXULPopupListener
)
if
(
tmp
-
>
mElement
)
{
return
mozilla
:
:
dom
:
:
FragmentOrElement
:
:
CanSkip
(
tmp
-
>
mElement
true
)
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
nsXULPopupListener
)
if
(
tmp
-
>
mElement
)
{
return
mozilla
:
:
dom
:
:
FragmentOrElement
:
:
CanSkipInCC
(
tmp
-
>
mElement
)
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
nsXULPopupListener
)
if
(
tmp
-
>
mElement
)
{
return
mozilla
:
:
dom
:
:
FragmentOrElement
:
:
CanSkipThis
(
tmp
-
>
mElement
)
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsXULPopupListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMEventListener
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
nsresult
nsXULPopupListener
:
:
HandleEvent
(
Event
*
aEvent
)
{
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
if
(
!
(
(
eventType
.
EqualsLiteral
(
"
mousedown
"
)
&
&
!
mIsContext
)
|
|
(
eventType
.
EqualsLiteral
(
"
contextmenu
"
)
&
&
mIsContext
)
)
)
return
NS_OK
;
MouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
!
mouseEvent
)
{
return
NS_OK
;
}
EventTarget
*
target
=
mouseEvent
-
>
GetTarget
(
)
;
nsCOMPtr
<
nsIDOMNode
>
targetNode
=
do_QueryInterface
(
target
)
;
if
(
!
targetNode
&
&
mIsContext
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
domWin
=
do_QueryInterface
(
target
)
;
if
(
!
domWin
)
{
return
NS_ERROR_DOM_WRONG_TYPE_ERR
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
domWin
-
>
GetDoc
(
)
;
if
(
doc
)
targetNode
=
do_QueryInterface
(
doc
-
>
GetRootElement
(
)
)
;
if
(
!
targetNode
)
{
return
NS_ERROR_FAILURE
;
}
}
nsCOMPtr
<
nsIContent
>
targetContent
=
do_QueryInterface
(
target
)
;
if
(
!
targetContent
)
{
return
NS_OK
;
}
{
EventTarget
*
originalTarget
=
mouseEvent
-
>
GetOriginalTarget
(
)
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
originalTarget
)
;
if
(
content
&
&
EventStateManager
:
:
IsRemoteTarget
(
content
)
)
{
return
NS_OK
;
}
}
bool
preventDefault
=
mouseEvent
-
>
DefaultPrevented
(
)
;
if
(
preventDefault
&
&
targetNode
&
&
mIsContext
)
{
bool
eventEnabled
=
Preferences
:
:
GetBool
(
"
dom
.
event
.
contextmenu
.
enabled
"
true
)
;
if
(
!
eventEnabled
)
{
nsCOMPtr
<
nsIObjectLoadingContent
>
olc
=
do_QueryInterface
(
targetNode
)
;
uint32_t
type
;
if
(
olc
&
&
NS_SUCCEEDED
(
olc
-
>
GetDisplayedType
(
&
type
)
)
&
&
type
=
=
nsIObjectLoadingContent
:
:
TYPE_PLUGIN
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
targetNode
)
;
if
(
node
)
{
nsCOMPtr
<
nsIPrincipal
>
system
;
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetSystemPrincipal
(
getter_AddRefs
(
system
)
)
;
if
(
node
-
>
NodePrincipal
(
)
!
=
system
)
{
preventDefault
=
false
;
}
}
}
}
if
(
preventDefault
)
{
return
NS_OK
;
}
if
(
!
mIsContext
)
{
if
(
targetContent
&
&
targetContent
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
menu
nsGkAtoms
:
:
menuitem
)
)
return
NS_OK
;
}
if
(
mIsContext
)
{
#
ifndef
NS_CONTEXT_MENU_IS_MOUSEUP
uint16_t
inputSource
=
mouseEvent
-
>
MozInputSource
(
)
;
bool
isTouch
=
inputSource
=
=
MouseEventBinding
:
:
MOZ_SOURCE_TOUCH
;
FireFocusOnTargetContent
(
targetNode
isTouch
)
;
#
endif
}
else
{
if
(
mouseEvent
-
>
Button
(
)
!
=
0
)
{
return
NS_OK
;
}
}
LaunchPopup
(
mouseEvent
targetContent
)
;
return
NS_OK
;
}
#
ifndef
NS_CONTEXT_MENU_IS_MOUSEUP
nsresult
nsXULPopupListener
:
:
FireFocusOnTargetContent
(
nsIDOMNode
*
aTargetNode
bool
aIsTouch
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aTargetNode
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
content
-
>
OwnerDoc
(
)
;
RefPtr
<
nsPresContext
>
context
=
doc
-
>
GetPresContext
(
)
;
if
(
!
context
)
{
return
NS_ERROR_FAILURE
;
}
nsIFrame
*
targetFrame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
!
targetFrame
)
return
NS_ERROR_FAILURE
;
const
nsStyleUserInterface
*
ui
=
targetFrame
-
>
StyleUserInterface
(
)
;
bool
suppressBlur
=
(
ui
-
>
mUserFocus
=
=
StyleUserFocus
:
:
Ignore
)
;
RefPtr
<
Element
>
newFocusElement
;
nsIFrame
*
currFrame
=
targetFrame
;
while
(
currFrame
)
{
int32_t
tabIndexUnused
;
if
(
currFrame
-
>
IsFocusable
(
&
tabIndexUnused
true
)
&
&
currFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
)
{
newFocusElement
=
currFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
break
;
}
currFrame
=
currFrame
-
>
GetParent
(
)
;
}
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
if
(
newFocusElement
)
{
uint32_t
focusFlags
=
nsIFocusManager
:
:
FLAG_BYMOUSE
|
nsIFocusManager
:
:
FLAG_NOSCROLL
;
if
(
aIsTouch
)
{
focusFlags
|
=
nsIFocusManager
:
:
FLAG_BYTOUCH
;
}
fm
-
>
SetFocus
(
newFocusElement
focusFlags
)
;
}
else
if
(
!
suppressBlur
)
{
nsPIDOMWindowOuter
*
window
=
doc
-
>
GetWindow
(
)
;
fm
-
>
ClearFocus
(
window
)
;
}
}
EventStateManager
*
esm
=
context
-
>
EventStateManager
(
)
;
esm
-
>
SetContentState
(
newFocusElement
NS_EVENT_STATE_ACTIVE
)
;
return
NS_OK
;
}
#
endif
void
nsXULPopupListener
:
:
ClosePopup
(
)
{
if
(
mPopupContent
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
pm
-
>
HidePopup
(
mPopupContent
false
true
true
false
)
;
mPopupContent
=
nullptr
;
}
}
static
already_AddRefed
<
Element
>
GetImmediateChild
(
nsIContent
*
aContent
nsAtom
*
aTag
)
{
for
(
nsIContent
*
child
=
aContent
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsXULElement
(
aTag
)
)
{
RefPtr
<
Element
>
ret
=
child
-
>
AsElement
(
)
;
return
ret
.
forget
(
)
;
}
}
return
nullptr
;
}
nsresult
nsXULPopupListener
:
:
LaunchPopup
(
MouseEvent
*
aEvent
nsIContent
*
aTargetContent
)
{
nsresult
rv
=
NS_OK
;
nsAutoString
identifier
;
nsAtom
*
type
=
mIsContext
?
nsGkAtoms
:
:
context
:
nsGkAtoms
:
:
popup
;
bool
hasPopupAttr
=
mElement
-
>
GetAttr
(
kNameSpaceID_None
type
identifier
)
;
if
(
identifier
.
IsEmpty
(
)
)
{
hasPopupAttr
=
mElement
-
>
GetAttr
(
kNameSpaceID_None
mIsContext
?
nsGkAtoms
:
:
contextmenu
:
nsGkAtoms
:
:
menu
identifier
)
|
|
hasPopupAttr
;
}
if
(
hasPopupAttr
)
{
aEvent
-
>
StopPropagation
(
)
;
aEvent
-
>
PreventDefault
(
)
;
}
if
(
identifier
.
IsEmpty
(
)
)
return
rv
;
nsCOMPtr
<
nsIDocument
>
document
=
mElement
-
>
GetComposedDoc
(
)
;
if
(
!
document
)
{
NS_WARNING
(
"
No
document
!
"
)
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Element
>
popup
;
if
(
identifier
.
EqualsLiteral
(
"
_child
"
)
)
{
popup
=
GetImmediateChild
(
mElement
nsGkAtoms
:
:
menupopup
)
;
if
(
!
popup
)
{
nsINodeList
*
list
=
document
-
>
GetAnonymousNodes
(
*
mElement
)
;
if
(
list
)
{
uint32_t
listLength
=
list
-
>
Length
(
)
;
for
(
uint32_t
ctr
=
0
;
ctr
<
listLength
;
ctr
+
+
)
{
nsIContent
*
childContent
=
list
-
>
Item
(
ctr
)
;
if
(
childContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
menupopup
kNameSpaceID_XUL
)
)
{
popup
=
childContent
-
>
AsElement
(
)
;
break
;
}
}
}
}
}
else
if
(
!
mElement
-
>
IsInUncomposedDoc
(
)
|
|
!
(
popup
=
document
-
>
GetElementById
(
identifier
)
)
)
{
NS_WARNING
(
"
GetElementById
had
some
kind
of
spasm
.
"
)
;
return
rv
;
}
if
(
!
popup
|
|
popup
=
=
mElement
)
return
NS_OK
;
nsIContent
*
parent
=
popup
-
>
GetParent
(
)
;
if
(
parent
)
{
nsMenuFrame
*
menu
=
do_QueryFrame
(
parent
-
>
GetPrimaryFrame
(
)
)
;
if
(
menu
)
return
NS_OK
;
}
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
!
pm
)
return
NS_OK
;
mPopupContent
=
popup
;
if
(
!
mIsContext
&
&
(
mPopupContent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
position
)
|
|
(
mPopupContent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
popupanchor
)
&
&
mPopupContent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
popupalign
)
)
)
)
{
pm
-
>
ShowPopup
(
mPopupContent
mElement
EmptyString
(
)
0
0
false
true
false
aEvent
)
;
}
else
{
int32_t
xPos
=
aEvent
-
>
ScreenX
(
CallerType
:
:
System
)
;
int32_t
yPos
=
aEvent
-
>
ScreenY
(
CallerType
:
:
System
)
;
pm
-
>
ShowPopupAtScreen
(
mPopupContent
xPos
yPos
mIsContext
aEvent
)
;
}
return
NS_OK
;
}
