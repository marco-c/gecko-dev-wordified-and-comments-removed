#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
XULTooltipElement
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCTooltipTextProvider
.
h
"
#
include
"
nsITooltipTextProvider
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
:
:
dom
{
nsXULElement
*
NS_NewXULTooltipElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
(
aNodeInfo
)
;
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
RefPtr
<
XULTooltipElement
>
tooltip
=
new
(
nim
)
XULTooltipElement
(
nodeInfo
.
forget
(
)
)
;
NS_ENSURE_SUCCESS
(
tooltip
-
>
Init
(
)
nullptr
)
;
return
tooltip
;
}
nsresult
XULTooltipElement
:
:
Init
(
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
nodeInfo
=
mNodeInfo
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
nsGkAtoms
:
:
description
nullptr
kNameSpaceID_XUL
nsINode
:
:
ELEMENT_NODE
)
;
nsCOMPtr
<
Element
>
description
;
nsresult
rv
=
NS_NewXULElement
(
getter_AddRefs
(
description
)
nodeInfo
.
forget
(
)
dom
:
:
NOT_FROM_PARSER
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
description
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
u
"
tooltip
-
label
"
_ns
false
)
;
description
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
flex
u
"
true
"
_ns
false
)
;
ErrorResult
error
;
AppendChild
(
*
description
error
)
;
return
error
.
StealNSResult
(
)
;
}
nsresult
XULTooltipElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
aName
=
=
nsGkAtoms
:
:
label
)
{
nsCOMPtr
<
nsIContent
>
description
=
GetFirstChild
(
)
;
if
(
description
&
&
description
-
>
IsXULElement
(
nsGkAtoms
:
:
description
)
)
{
nsAutoString
value
;
if
(
aValue
)
{
aValue
-
>
ToString
(
value
)
;
}
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
XULTooltipElement
:
:
AfterSetAttr
"
[
description
value
]
(
)
{
Element
*
descriptionElement
=
description
-
>
AsElement
(
)
;
descriptionElement
-
>
SetTextContent
(
value
IgnoreErrors
(
)
)
;
}
)
)
;
}
}
return
nsXULElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aSubjectPrincipal
aNotify
)
;
}
nsresult
XULTooltipElement
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eXULPopupShowing
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
&
&
!
aVisitor
.
mEvent
-
>
DefaultPrevented
(
)
&
&
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
page
nsGkAtoms
:
:
_true
eCaseMatters
)
&
&
!
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
titletip
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
nsCOMPtr
<
nsITooltipTextProvider
>
textProvider
=
do_GetService
(
NS_DEFAULTTOOLTIPTEXTPROVIDER_CONTRACTID
)
;
nsString
text
;
nsString
direction
;
bool
shouldChange
=
false
;
if
(
textProvider
)
{
textProvider
-
>
GetNodeText
(
GetTriggerNode
(
)
getter_Copies
(
text
)
getter_Copies
(
direction
)
&
shouldChange
)
;
}
if
(
shouldChange
)
{
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
text
true
)
;
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
direction
direction
true
)
;
}
else
{
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
aVisitor
.
mEvent
-
>
PreventDefault
(
)
;
}
}
return
NS_OK
;
}
}
