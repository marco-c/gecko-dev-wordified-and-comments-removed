#
ifndef
nsXULElement_h__
#
define
nsXULElement_h__
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
nsIControllers
.
h
"
#
include
"
nsIDOMXULMultSelectCntrlEl
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsLayoutCID
.
h
"
#
include
"
AttrArray
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStyledElement
.
h
"
#
include
"
mozilla
/
dom
/
DOMRect
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
DOMString
.
h
"
#
include
"
mozilla
/
dom
/
FromParser
.
h
"
class
nsXULPrototypeDocument
;
class
nsIObjectInputStream
;
class
nsIObjectOutputStream
;
class
nsIOffThreadScriptReceiver
;
class
nsXULPrototypeNode
;
typedef
nsTArray
<
RefPtr
<
nsXULPrototypeNode
>
>
nsPrototypeArray
;
namespace
mozilla
{
class
EventChainPreVisitor
;
class
EventListenerManager
;
namespace
css
{
class
StyleRule
;
}
namespace
dom
{
class
BoxObject
;
class
HTMLIFrameElement
;
enum
class
CallerType
:
uint32_t
;
}
}
#
ifdef
XUL_PROTOTYPE_ATTRIBUTE_METERING
#
define
XUL_PROTOTYPE_ATTRIBUTE_METER
(
counter
)
\
(
nsXULPrototypeAttribute
:
:
counter
+
+
)
#
else
#
define
XUL_PROTOTYPE_ATTRIBUTE_METER
(
counter
)
(
(
void
)
0
)
#
endif
class
nsXULPrototypeAttribute
{
public
:
nsXULPrototypeAttribute
(
)
:
mName
(
nsGkAtoms
:
:
id
)
{
XUL_PROTOTYPE_ATTRIBUTE_METER
(
gNumAttributes
)
;
MOZ_COUNT_CTOR
(
nsXULPrototypeAttribute
)
;
}
~
nsXULPrototypeAttribute
(
)
;
nsAttrName
mName
;
nsAttrValue
mValue
;
#
ifdef
XUL_PROTOTYPE_ATTRIBUTE_METERING
static
uint32_t
gNumElements
;
static
uint32_t
gNumAttributes
;
static
uint32_t
gNumCacheTests
;
static
uint32_t
gNumCacheHits
;
static
uint32_t
gNumCacheSets
;
static
uint32_t
gNumCacheFills
;
#
endif
}
;
class
nsXULPrototypeNode
{
public
:
enum
Type
{
eType_Element
eType_Script
eType_Text
eType_PI
}
;
Type
mType
;
virtual
nsresult
Serialize
(
nsIObjectOutputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
=
0
;
virtual
nsresult
Deserialize
(
nsIObjectInputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
nsIURI
*
aDocumentURI
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
=
0
;
virtual
void
ReleaseSubtree
(
)
{
}
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS
(
nsXULPrototypeNode
)
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
nsXULPrototypeNode
)
protected
:
explicit
nsXULPrototypeNode
(
Type
aType
)
:
mType
(
aType
)
{
}
virtual
~
nsXULPrototypeNode
(
)
{
}
}
;
class
nsXULPrototypeElement
:
public
nsXULPrototypeNode
{
public
:
nsXULPrototypeElement
(
)
:
nsXULPrototypeNode
(
eType_Element
)
mNumAttributes
(
0
)
mHasIdAttribute
(
false
)
mHasClassAttribute
(
false
)
mHasStyleAttribute
(
false
)
mAttributes
(
nullptr
)
mIsAtom
(
nullptr
)
{
}
virtual
~
nsXULPrototypeElement
(
)
{
Unlink
(
)
;
}
virtual
void
ReleaseSubtree
(
)
override
{
for
(
int32_t
i
=
mChildren
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
mChildren
[
i
]
.
get
(
)
)
mChildren
[
i
]
-
>
ReleaseSubtree
(
)
;
}
mChildren
.
Clear
(
)
;
nsXULPrototypeNode
:
:
ReleaseSubtree
(
)
;
}
virtual
nsresult
Serialize
(
nsIObjectOutputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
override
;
virtual
nsresult
Deserialize
(
nsIObjectInputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
nsIURI
*
aDocumentURI
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
override
;
nsresult
SetAttrAt
(
uint32_t
aPos
const
nsAString
&
aValue
nsIURI
*
aDocumentURI
)
;
void
Unlink
(
)
;
void
TraceAllScripts
(
JSTracer
*
aTrc
)
;
nsPrototypeArray
mChildren
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
mNodeInfo
;
uint32_t
mNumAttributes
:
29
;
uint32_t
mHasIdAttribute
:
1
;
uint32_t
mHasClassAttribute
:
1
;
uint32_t
mHasStyleAttribute
:
1
;
nsXULPrototypeAttribute
*
mAttributes
;
RefPtr
<
nsAtom
>
mIsAtom
;
}
;
namespace
mozilla
{
namespace
dom
{
class
XULDocument
;
}
}
class
nsXULPrototypeScript
:
public
nsXULPrototypeNode
{
public
:
explicit
nsXULPrototypeScript
(
uint32_t
aLineNo
)
;
virtual
~
nsXULPrototypeScript
(
)
;
virtual
nsresult
Serialize
(
nsIObjectOutputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
override
;
nsresult
SerializeOutOfLine
(
nsIObjectOutputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
)
;
virtual
nsresult
Deserialize
(
nsIObjectInputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
nsIURI
*
aDocumentURI
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
override
;
nsresult
DeserializeOutOfLine
(
nsIObjectInputStream
*
aInput
nsXULPrototypeDocument
*
aProtoDoc
)
;
nsresult
Compile
(
const
char16_t
*
aText
size_t
aTextLength
JS
:
:
SourceOwnership
aOwnership
nsIURI
*
aURI
uint32_t
aLineNo
mozilla
:
:
dom
:
:
Document
*
aDocument
nsIOffThreadScriptReceiver
*
aOffThreadReceiver
=
nullptr
)
;
void
UnlinkJSObjects
(
)
;
void
Set
(
JSScript
*
aObject
)
;
bool
HasScriptObject
(
)
{
return
mScriptObject
;
}
JSScript
*
GetScriptObject
(
)
{
return
mScriptObject
;
}
void
TraceScriptObject
(
JSTracer
*
aTrc
)
{
JS
:
:
TraceEdge
(
aTrc
&
mScriptObject
"
active
window
XUL
prototype
script
"
)
;
}
void
Trace
(
const
TraceCallbacks
&
aCallbacks
void
*
aClosure
)
{
if
(
mScriptObject
)
{
aCallbacks
.
Trace
(
&
mScriptObject
"
mScriptObject
"
aClosure
)
;
}
}
nsCOMPtr
<
nsIURI
>
mSrcURI
;
uint32_t
mLineNo
;
bool
mSrcLoading
;
bool
mOutOfLine
;
mozilla
:
:
dom
:
:
XULDocument
*
mSrcLoadWaiters
;
private
:
JS
:
:
Heap
<
JSScript
*
>
mScriptObject
;
}
;
class
nsXULPrototypeText
:
public
nsXULPrototypeNode
{
public
:
nsXULPrototypeText
(
)
:
nsXULPrototypeNode
(
eType_Text
)
{
}
virtual
~
nsXULPrototypeText
(
)
{
}
virtual
nsresult
Serialize
(
nsIObjectOutputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
override
;
virtual
nsresult
Deserialize
(
nsIObjectInputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
nsIURI
*
aDocumentURI
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
override
;
nsString
mValue
;
}
;
class
nsXULPrototypePI
:
public
nsXULPrototypeNode
{
public
:
nsXULPrototypePI
(
)
:
nsXULPrototypeNode
(
eType_PI
)
{
}
virtual
~
nsXULPrototypePI
(
)
{
}
virtual
nsresult
Serialize
(
nsIObjectOutputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
override
;
virtual
nsresult
Deserialize
(
nsIObjectInputStream
*
aStream
nsXULPrototypeDocument
*
aProtoDoc
nsIURI
*
aDocumentURI
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
>
*
aNodeInfos
)
override
;
nsString
mTarget
;
nsString
mData
;
}
;
#
define
XUL_ELEMENT_FLAG_BIT
(
n_
)
\
NODE_FLAG_BIT
(
ELEMENT_TYPE_SPECIFIC_BITS_OFFSET
+
(
n_
)
)
enum
{
XUL_ELEMENT_HAS_CONTENTMENU_LISTENER
=
XUL_ELEMENT_FLAG_BIT
(
0
)
XUL_ELEMENT_HAS_POPUP_LISTENER
=
XUL_ELEMENT_FLAG_BIT
(
1
)
}
;
ASSERT_NODE_FLAGS_SPACE
(
ELEMENT_TYPE_SPECIFIC_BITS_OFFSET
+
2
)
;
#
undef
XUL_ELEMENT_FLAG_BIT
class
nsXULElement
:
public
nsStyledElement
{
protected
:
typedef
mozilla
:
:
dom
:
:
Document
Document
;
explicit
nsXULElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
;
public
:
using
Element
:
:
Blur
;
using
Element
:
:
Focus
;
static
nsresult
CreateFromPrototype
(
nsXULPrototypeElement
*
aPrototype
Document
*
aDocument
bool
aIsScriptable
bool
aIsRoot
mozilla
:
:
dom
:
:
Element
*
*
aResult
)
;
static
nsXULElement
*
Construct
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
;
NS_IMPL_FROMNODE
(
nsXULElement
kNameSpaceID_XUL
)
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
nsXULElement
nsStyledElement
)
void
GetEventTargetParent
(
mozilla
:
:
EventChainPreVisitor
&
aVisitor
)
override
;
virtual
nsresult
PreHandleEvent
(
mozilla
:
:
EventChainVisitor
&
aVisitor
)
override
;
virtual
nsresult
BindToTree
(
Document
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
override
;
virtual
void
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
override
;
virtual
void
DestroyContent
(
)
override
;
virtual
void
DoneAddingChildren
(
bool
aHaveNotified
)
override
;
#
ifdef
DEBUG
virtual
void
List
(
FILE
*
out
int32_t
aIndent
)
const
override
;
virtual
void
DumpContent
(
FILE
*
out
int32_t
aIndent
bool
aDumpAll
)
const
override
{
}
#
endif
MOZ_CAN_RUN_SCRIPT
int32_t
ScreenX
(
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ScreenY
(
)
;
bool
HasMenu
(
)
;
MOZ_CAN_RUN_SCRIPT
void
OpenMenu
(
bool
aOpenFlag
)
;
virtual
bool
PerformAccesskey
(
bool
aKeyCausesActivation
bool
aIsTrustedEvent
)
override
;
void
ClickWithInputSource
(
uint16_t
aInputSource
bool
aIsTrustedEvent
)
;
nsIContent
*
GetBindingParent
(
)
const
final
{
return
mBindingParent
;
}
virtual
bool
IsNodeOfType
(
uint32_t
aFlags
)
const
override
;
virtual
bool
IsFocusableInternal
(
int32_t
*
aTabIndex
bool
aWithMouse
)
override
;
virtual
nsChangeHint
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
override
;
NS_IMETHOD_
(
bool
)
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
override
;
virtual
nsresult
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
nsINode
*
*
aResult
)
const
override
;
virtual
mozilla
:
:
EventStates
IntrinsicState
(
)
const
override
;
virtual
void
RecompileScriptEventListeners
(
)
override
;
void
SetXULBindingParent
(
nsIContent
*
aBindingParent
)
{
mBindingParent
=
aBindingParent
;
}
virtual
bool
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
override
;
typedef
mozilla
:
:
dom
:
:
DOMString
DOMString
;
void
GetXULAttr
(
nsAtom
*
aName
DOMString
&
aResult
)
const
{
GetAttr
(
kNameSpaceID_None
aName
aResult
)
;
}
void
SetXULAttr
(
nsAtom
*
aName
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
aError
)
{
SetAttr
(
aName
aValue
aError
)
;
}
bool
GetXULBoolAttr
(
nsAtom
*
aName
)
const
{
return
AttrValueIs
(
kNameSpaceID_None
aName
NS_LITERAL_STRING
(
"
true
"
)
eCaseMatters
)
;
}
void
SetXULBoolAttr
(
nsAtom
*
aName
bool
aValue
)
{
if
(
aValue
)
{
SetAttr
(
kNameSpaceID_None
aName
NS_LITERAL_STRING
(
"
true
"
)
true
)
;
}
else
{
UnsetAttr
(
kNameSpaceID_None
aName
true
)
;
}
}
void
GetAlign
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
align
aValue
)
;
}
void
SetAlign
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
align
aValue
rv
)
;
}
void
GetDir
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
dir
aValue
)
;
}
void
SetDir
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
dir
aValue
rv
)
;
}
void
GetFlex
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
flex
aValue
)
;
}
void
SetFlex
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
flex
aValue
rv
)
;
}
void
GetOrdinal
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
ordinal
aValue
)
;
}
void
SetOrdinal
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
ordinal
aValue
rv
)
;
}
void
GetOrient
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
orient
aValue
)
;
}
void
SetOrient
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
orient
aValue
rv
)
;
}
void
GetPack
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
pack
aValue
)
;
}
void
SetPack
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
pack
aValue
rv
)
;
}
bool
Hidden
(
)
const
{
return
BoolAttrIsTrue
(
nsGkAtoms
:
:
hidden
)
;
}
void
SetHidden
(
bool
aHidden
)
{
SetXULBoolAttr
(
nsGkAtoms
:
:
hidden
aHidden
)
;
}
bool
Collapsed
(
)
const
{
return
BoolAttrIsTrue
(
nsGkAtoms
:
:
collapsed
)
;
}
void
SetCollapsed
(
bool
aCollapsed
)
{
SetXULBoolAttr
(
nsGkAtoms
:
:
collapsed
aCollapsed
)
;
}
void
GetObserves
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
observes
aValue
)
;
}
void
SetObserves
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
observes
aValue
rv
)
;
}
void
GetMenu
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
menu
aValue
)
;
}
void
SetMenu
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
menu
aValue
rv
)
;
}
void
GetContextMenu
(
DOMString
&
aValue
)
{
GetXULAttr
(
nsGkAtoms
:
:
contextmenu
aValue
)
;
}
void
SetContextMenu
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
contextmenu
aValue
rv
)
;
}
void
GetTooltip
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
tooltip
aValue
)
;
}
void
SetTooltip
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
tooltip
aValue
rv
)
;
}
void
GetWidth
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
width
aValue
)
;
}
void
SetWidth
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
width
aValue
rv
)
;
}
void
GetHeight
(
DOMString
&
aValue
)
{
GetXULAttr
(
nsGkAtoms
:
:
height
aValue
)
;
}
void
SetHeight
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
height
aValue
rv
)
;
}
void
GetMinWidth
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
minwidth
aValue
)
;
}
void
SetMinWidth
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
minwidth
aValue
rv
)
;
}
void
GetMinHeight
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
minheight
aValue
)
;
}
void
SetMinHeight
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
minheight
aValue
rv
)
;
}
void
GetMaxWidth
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
maxwidth
aValue
)
;
}
void
SetMaxWidth
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
maxwidth
aValue
rv
)
;
}
void
GetMaxHeight
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
maxheight
aValue
)
;
}
void
SetMaxHeight
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
maxheight
aValue
rv
)
;
}
void
GetLeft
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
left
aValue
)
;
}
void
SetLeft
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
left
aValue
rv
)
;
}
void
GetTop
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
top
aValue
)
;
}
void
SetTop
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
top
aValue
rv
)
;
}
void
GetTooltipText
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
tooltiptext
aValue
)
;
}
void
SetTooltipText
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
tooltiptext
aValue
rv
)
;
}
void
GetSrc
(
DOMString
&
aValue
)
const
{
GetXULAttr
(
nsGkAtoms
:
:
src
aValue
)
;
}
void
SetSrc
(
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
rv
)
{
SetXULAttr
(
nsGkAtoms
:
:
src
aValue
rv
)
;
}
bool
AllowEvents
(
)
const
{
return
BoolAttrIsTrue
(
nsGkAtoms
:
:
allowevents
)
;
}
void
SetAllowEvents
(
bool
aAllowEvents
)
{
SetXULBoolAttr
(
nsGkAtoms
:
:
allowevents
aAllowEvents
)
;
}
nsIControllers
*
GetControllers
(
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
BoxObject
>
GetBoxObject
(
mozilla
:
:
ErrorResult
&
rv
)
;
void
Click
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
void
DoCommand
(
)
;
nsINode
*
GetScopeChainParent
(
)
const
override
{
Element
*
parent
=
GetParentElement
(
)
;
return
parent
?
parent
:
nsStyledElement
:
:
GetScopeChainParent
(
)
;
}
bool
IsInteractiveHTMLContent
(
bool
aIgnoreTabindex
)
const
override
;
protected
:
~
nsXULElement
(
)
;
friend
class
nsNSElementTearoff
;
nsresult
EnsureContentsGenerated
(
void
)
const
;
nsresult
AddPopupListener
(
nsAtom
*
aName
)
;
nsCOMPtr
<
nsIContent
>
mBindingParent
;
nsresult
MakeHeavyweight
(
nsXULPrototypeElement
*
aPrototype
)
;
virtual
nsresult
BeforeSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
override
;
virtual
nsresult
AfterSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
override
;
virtual
void
UpdateEditableState
(
bool
aNotify
)
override
;
virtual
bool
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
override
;
virtual
mozilla
:
:
EventListenerManager
*
GetEventListenerManagerForAttr
(
nsAtom
*
aAttrName
bool
*
aDefer
)
override
;
void
AddListenerFor
(
const
nsAttrName
&
aName
)
;
void
MaybeAddPopupListener
(
nsAtom
*
aLocalName
)
;
nsIWidget
*
GetWindowWidget
(
)
;
nsresult
HideWindowChrome
(
bool
aShouldHide
)
;
void
SetChromeMargins
(
const
nsAttrValue
*
aValue
)
;
void
ResetChromeMargins
(
)
;
void
SetDrawsInTitlebar
(
bool
aState
)
;
void
SetDrawsTitle
(
bool
aState
)
;
void
UpdateBrightTitlebarForeground
(
Document
*
aDocument
)
;
protected
:
void
AddTooltipSupport
(
)
;
void
RemoveTooltipSupport
(
)
;
nsIControllers
*
Controllers
(
)
{
nsExtendedDOMSlots
*
slots
=
GetExistingExtendedDOMSlots
(
)
;
return
slots
?
slots
-
>
mControllers
.
get
(
)
:
nullptr
;
}
void
UnregisterAccessKey
(
const
nsAString
&
aOldValue
)
;
bool
BoolAttrIsTrue
(
nsAtom
*
aName
)
const
;
friend
nsXULElement
*
NS_NewBasicXULElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
;
friend
nsresult
NS_NewXULElement
(
mozilla
:
:
dom
:
:
Element
*
*
aResult
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
mozilla
:
:
dom
:
:
FromParser
aFromParser
const
nsAString
*
aIs
)
;
friend
void
NS_TrustedNewXULElement
(
mozilla
:
:
dom
:
:
Element
*
*
aResult
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
)
;
static
already_AddRefed
<
nsXULElement
>
CreateFromPrototype
(
nsXULPrototypeElement
*
aPrototype
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
bool
aIsScriptable
bool
aIsRoot
)
;
bool
IsReadWriteTextElement
(
)
const
{
return
IsAnyOfXULElements
(
nsGkAtoms
:
:
textbox
nsGkAtoms
:
:
textarea
)
&
&
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
readonly
)
;
}
virtual
JSObject
*
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
void
MaybeUpdatePrivateLifetime
(
)
;
bool
IsEventStoppedFromAnonymousScrollbar
(
mozilla
:
:
EventMessage
aMessage
)
;
nsresult
DispatchXULCommand
(
const
mozilla
:
:
EventChainVisitor
&
aVisitor
nsAutoString
&
aCommand
)
;
}
;
#
endif
