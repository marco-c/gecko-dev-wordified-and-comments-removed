#
ifndef
nsTemplateRule_h__
#
define
nsTemplateRule_h__
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIRDFDataSource
.
h
"
#
include
"
nsIRDFResource
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIXULTemplateRuleFilter
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
class
nsIXULTemplateQueryProcessor
;
class
nsTemplateQuerySet
;
class
nsTemplateCondition
{
public
:
enum
ConditionRelation
{
eUnknown
eEquals
eLess
eGreater
eBefore
eAfter
eStartswith
eEndswith
eContains
}
;
nsTemplateCondition
(
nsAtom
*
aSourceVariable
const
nsAString
&
aRelation
nsAtom
*
aTargetVariable
bool
mIgnoreCase
bool
mNegate
)
;
nsTemplateCondition
(
nsAtom
*
aSourceVariable
const
nsAString
&
aRelation
const
nsAString
&
aTargets
bool
mIgnoreCase
bool
mNegate
bool
aIsMultiple
)
;
nsTemplateCondition
(
const
nsAString
&
aSource
const
nsAString
&
aRelation
nsAtom
*
aTargetVariable
bool
mIgnoreCase
bool
mNegate
)
;
~
nsTemplateCondition
(
)
{
MOZ_COUNT_DTOR
(
nsTemplateCondition
)
;
}
nsTemplateCondition
*
GetNext
(
)
{
return
mNext
;
}
void
SetNext
(
nsTemplateCondition
*
aNext
)
{
mNext
=
aNext
;
}
void
SetRelation
(
const
nsAString
&
aRelation
)
;
bool
CheckMatch
(
nsIXULTemplateResult
*
aResult
)
;
bool
CheckMatchStrings
(
const
nsAString
&
aLeftString
const
nsAString
&
aRightString
)
;
protected
:
RefPtr
<
nsAtom
>
mSourceVariable
;
nsString
mSource
;
ConditionRelation
mRelation
;
RefPtr
<
nsAtom
>
mTargetVariable
;
nsTArray
<
nsString
>
mTargetList
;
bool
mIgnoreCase
;
bool
mNegate
;
nsTemplateCondition
*
mNext
;
}
;
class
nsTemplateRule
{
public
:
nsTemplateRule
(
nsIContent
*
aRuleNode
nsIContent
*
aAction
nsTemplateQuerySet
*
aQuerySet
)
;
nsTemplateRule
(
const
nsTemplateRule
&
aOtherRule
)
;
~
nsTemplateRule
(
)
;
nsIContent
*
GetAction
(
)
const
{
return
mAction
;
}
nsresult
GetRuleNode
(
nsIDOMNode
*
*
aResult
)
const
;
void
SetVars
(
nsAtom
*
aRefVariable
nsAtom
*
aMemberVariable
)
{
mRefVariable
=
aRefVariable
;
mMemberVariable
=
aMemberVariable
;
}
void
SetRuleFilter
(
nsIXULTemplateRuleFilter
*
aRuleFilter
)
{
mRuleFilter
=
aRuleFilter
;
}
nsAtom
*
GetTag
(
)
{
return
mTag
;
}
void
SetTag
(
nsAtom
*
aTag
)
{
mTag
=
aTag
;
}
nsAtom
*
GetMemberVariable
(
)
{
return
mMemberVariable
;
}
void
SetCondition
(
nsTemplateCondition
*
aConditions
)
;
bool
CheckMatch
(
nsIXULTemplateResult
*
aResult
)
const
;
bool
HasBinding
(
nsAtom
*
aSourceVariable
nsAString
&
aExpr
nsAtom
*
aTargetVariable
)
const
;
nsresult
AddBinding
(
nsAtom
*
aSourceVariable
nsAString
&
aExpr
nsAtom
*
aTargetVariable
)
;
nsresult
AddBindingsToQueryProcessor
(
nsIXULTemplateQueryProcessor
*
aProcessor
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
&
cb
)
const
{
cb
.
NoteXPCOMChild
(
mRuleNode
)
;
cb
.
NoteXPCOMChild
(
mAction
)
;
}
protected
:
struct
Binding
{
RefPtr
<
nsAtom
>
mSourceVariable
;
RefPtr
<
nsAtom
>
mTargetVariable
;
nsString
mExpr
;
Binding
*
mNext
;
Binding
*
mParent
;
}
;
nsTemplateQuerySet
*
mQuerySet
;
nsCOMPtr
<
nsIDOMNode
>
mRuleNode
;
nsCOMPtr
<
nsIContent
>
mAction
;
nsCOMPtr
<
nsIXULTemplateRuleFilter
>
mRuleFilter
;
RefPtr
<
nsAtom
>
mTag
;
Binding
*
mBindings
;
RefPtr
<
nsAtom
>
mRefVariable
;
RefPtr
<
nsAtom
>
mMemberVariable
;
nsTemplateCondition
*
mConditions
;
}
;
class
nsTemplateQuerySet
{
protected
:
nsTArray
<
nsTemplateRule
>
mRules
;
int32_t
mPriority
;
public
:
nsCOMPtr
<
nsIContent
>
mQueryNode
;
nsCOMPtr
<
nsISupports
>
mCompiledQuery
;
RefPtr
<
nsAtom
>
mTag
;
explicit
nsTemplateQuerySet
(
int32_t
aPriority
)
:
mPriority
(
aPriority
)
{
MOZ_COUNT_CTOR
(
nsTemplateQuerySet
)
;
}
~
nsTemplateQuerySet
(
)
{
MOZ_COUNT_DTOR
(
nsTemplateQuerySet
)
;
}
int32_t
Priority
(
)
const
{
return
mPriority
;
}
nsAtom
*
GetTag
(
)
{
return
mTag
;
}
void
SetTag
(
nsAtom
*
aTag
)
{
mTag
=
aTag
;
}
nsTemplateRule
*
NewRule
(
nsIContent
*
aRuleNode
nsIContent
*
aAction
nsTemplateQuerySet
*
aQuerySet
)
{
if
(
mRules
.
Length
(
)
=
=
INT16_MAX
)
return
nullptr
;
return
mRules
.
AppendElement
(
nsTemplateRule
(
aRuleNode
aAction
aQuerySet
)
)
;
}
void
RemoveRule
(
nsTemplateRule
*
aRule
)
{
mRules
.
RemoveElementAt
(
aRule
-
mRules
.
Elements
(
)
)
;
}
int16_t
RuleCount
(
)
const
{
return
mRules
.
Length
(
)
;
}
nsTemplateRule
*
GetRuleAt
(
int16_t
aIndex
)
{
if
(
uint32_t
(
aIndex
)
<
mRules
.
Length
(
)
)
{
return
&
mRules
[
aIndex
]
;
}
return
nullptr
;
}
void
Clear
(
)
{
mRules
.
Clear
(
)
;
}
}
;
#
endif
