#
include
"
XULMenuParentElement
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
nsView
.
h
"
#
include
"
mozilla
/
AppUnits
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
dom
/
DOMRect
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
XULPopupElement
.
h
"
#
include
"
mozilla
/
dom
/
XULButtonElement
.
h
"
#
include
"
mozilla
/
dom
/
XULMenuElement
.
h
"
#
include
"
mozilla
/
dom
/
XULPopupElementBinding
.
h
"
#
ifdef
MOZ_WAYLAND
#
include
"
mozilla
/
WidgetUtilsGtk
.
h
"
#
endif
namespace
mozilla
:
:
dom
{
nsXULElement
*
NS_NewXULPopupElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
(
aNodeInfo
)
;
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
return
new
(
nim
)
XULPopupElement
(
nodeInfo
.
forget
(
)
)
;
}
JSObject
*
XULPopupElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
XULPopupElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsMenuPopupFrame
*
XULPopupElement
:
:
GetFrame
(
FlushType
aFlushType
)
{
nsIFrame
*
f
=
GetPrimaryFrame
(
aFlushType
)
;
MOZ_ASSERT
(
!
f
|
|
f
-
>
IsMenuPopupFrame
(
)
)
;
return
static_cast
<
nsMenuPopupFrame
*
>
(
f
)
;
}
void
XULPopupElement
:
:
OpenPopup
(
Element
*
aAnchorElement
const
StringOrOpenPopupOptions
&
aOptions
int32_t
aXPos
int32_t
aYPos
bool
aIsContextMenu
bool
aAttributesOverride
Event
*
aTriggerEvent
)
{
nsAutoString
position
;
if
(
aOptions
.
IsOpenPopupOptions
(
)
)
{
const
OpenPopupOptions
&
options
=
aOptions
.
GetAsOpenPopupOptions
(
)
;
position
=
options
.
mPosition
;
aXPos
=
options
.
mX
;
aYPos
=
options
.
mY
;
aIsContextMenu
=
options
.
mIsContextMenu
;
aAttributesOverride
=
options
.
mAttributesOverride
;
aTriggerEvent
=
options
.
mTriggerEvent
;
}
else
{
position
=
aOptions
.
GetAsString
(
)
;
}
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
if
(
!
aAnchorElement
&
&
position
.
IsEmpty
(
)
&
&
GetPrimaryFrame
(
)
)
{
if
(
auto
*
menu
=
GetContainingMenu
(
)
)
{
pm
-
>
ShowMenu
(
menu
false
)
;
return
;
}
}
pm
-
>
ShowPopup
(
this
aAnchorElement
position
aXPos
aYPos
aIsContextMenu
aAttributesOverride
false
aTriggerEvent
)
;
}
}
void
XULPopupElement
:
:
OpenPopupAtScreen
(
int32_t
aXPos
int32_t
aYPos
bool
aIsContextMenu
Event
*
aTriggerEvent
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
ShowPopupAtScreen
(
this
aXPos
aYPos
aIsContextMenu
aTriggerEvent
)
;
}
}
void
XULPopupElement
:
:
OpenPopupAtScreenRect
(
const
nsAString
&
aPosition
int32_t
aXPos
int32_t
aYPos
int32_t
aWidth
int32_t
aHeight
bool
aIsContextMenu
bool
aAttributesOverride
Event
*
aTriggerEvent
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
ShowPopupAtScreenRect
(
this
aPosition
nsIntRect
(
aXPos
aYPos
aWidth
aHeight
)
aIsContextMenu
aAttributesOverride
aTriggerEvent
)
;
}
}
void
XULPopupElement
:
:
HidePopup
(
bool
aCancel
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
!
pm
)
{
return
;
}
HidePopupOptions
options
{
HidePopupOption
:
:
DeselectMenu
}
;
if
(
aCancel
)
{
options
+
=
HidePopupOption
:
:
IsRollup
;
}
pm
-
>
HidePopup
(
this
options
)
;
}
static
Modifiers
ConvertModifiers
(
const
ActivateMenuItemOptions
&
aModifiers
)
{
Modifiers
modifiers
=
0
;
if
(
aModifiers
.
mCtrlKey
)
{
modifiers
|
=
MODIFIER_CONTROL
;
}
if
(
aModifiers
.
mAltKey
)
{
modifiers
|
=
MODIFIER_ALT
;
}
if
(
aModifiers
.
mShiftKey
)
{
modifiers
|
=
MODIFIER_SHIFT
;
}
if
(
aModifiers
.
mMetaKey
)
{
modifiers
|
=
MODIFIER_META
;
}
return
modifiers
;
}
void
XULPopupElement
:
:
PopupOpened
(
bool
aSelectFirstItem
)
{
if
(
aSelectFirstItem
)
{
SelectFirstItem
(
)
;
}
if
(
RefPtr
button
=
GetContainingMenu
(
)
)
{
if
(
RefPtr
parent
=
button
-
>
GetMenuParent
(
)
)
{
parent
-
>
SetActiveMenuChild
(
button
)
;
}
}
}
void
XULPopupElement
:
:
PopupClosed
(
bool
aDeselectMenu
)
{
LockMenuUntilClosed
(
false
)
;
SetActiveMenuChild
(
nullptr
)
;
auto
dispatcher
=
MakeRefPtr
<
AsyncEventDispatcher
>
(
this
u
"
DOMMenuInactive
"
_ns
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eNo
)
;
dispatcher
-
>
PostDOMEvent
(
)
;
if
(
RefPtr
button
=
GetContainingMenu
(
)
)
{
button
-
>
PopupClosed
(
aDeselectMenu
)
;
}
}
void
XULPopupElement
:
:
ActivateItem
(
Element
&
aItemElement
const
ActivateMenuItemOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
!
Contains
(
&
aItemElement
)
)
{
return
aRv
.
ThrowInvalidStateError
(
"
Menu
item
is
not
inside
this
menu
.
"
)
;
}
Modifiers
modifiers
=
ConvertModifiers
(
aOptions
)
;
if
(
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
)
{
if
(
pm
-
>
ActivateNativeMenuItem
(
&
aItemElement
modifiers
aOptions
.
mButton
aRv
)
)
{
return
;
}
}
auto
*
item
=
XULButtonElement
:
:
FromNode
(
aItemElement
)
;
if
(
!
item
|
|
!
item
-
>
IsMenu
(
)
)
{
return
aRv
.
ThrowInvalidStateError
(
"
Not
a
menu
item
"
)
;
}
if
(
!
item
-
>
GetPrimaryFrame
(
FlushType
:
:
Frames
)
)
{
return
aRv
.
ThrowInvalidStateError
(
"
Menu
item
is
hidden
"
)
;
}
auto
*
popup
=
item
-
>
GetContainingPopupElement
(
)
;
if
(
!
popup
)
{
return
aRv
.
ThrowInvalidStateError
(
"
No
popup
"
)
;
}
nsMenuPopupFrame
*
frame
=
popup
-
>
GetFrame
(
FlushType
:
:
None
)
;
if
(
!
frame
|
|
!
frame
-
>
IsOpen
(
)
)
{
return
aRv
.
ThrowInvalidStateError
(
"
Popup
is
not
open
"
)
;
}
const
bool
trusted
=
true
;
MOZ_KnownLive
(
item
)
-
>
ExecuteMenu
(
modifiers
aOptions
.
mButton
trusted
)
;
}
void
XULPopupElement
:
:
MoveTo
(
int32_t
aLeft
int32_t
aTop
)
{
nsMenuPopupFrame
*
menuPopupFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
menuPopupFrame
)
{
menuPopupFrame
-
>
MoveTo
(
CSSIntPoint
(
aLeft
aTop
)
true
)
;
}
}
void
XULPopupElement
:
:
MoveToAnchor
(
Element
*
aAnchorElement
const
nsAString
&
aPosition
int32_t
aXPos
int32_t
aYPos
bool
aAttributesOverride
)
{
nsMenuPopupFrame
*
menuPopupFrame
=
GetFrame
(
FlushType
:
:
None
)
;
if
(
menuPopupFrame
&
&
menuPopupFrame
-
>
IsVisibleOrShowing
(
)
)
{
menuPopupFrame
-
>
MoveToAnchor
(
aAnchorElement
aPosition
aXPos
aYPos
aAttributesOverride
)
;
}
}
void
XULPopupElement
:
:
SizeTo
(
int32_t
aWidth
int32_t
aHeight
)
{
nsAutoString
width
height
;
width
.
AppendInt
(
aWidth
)
;
height
.
AppendInt
(
aHeight
)
;
nsCOMPtr
<
nsIContent
>
kungFuDeathGrip
=
this
;
bool
heightSame
=
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
height
height
eCaseMatters
)
;
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
width
width
heightSame
)
;
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
height
height
true
)
;
nsMenuPopupFrame
*
menuPopupFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
menuPopupFrame
&
&
menuPopupFrame
-
>
PopupState
(
)
=
=
ePopupShown
)
{
menuPopupFrame
-
>
SetPopupPosition
(
false
)
;
}
}
void
XULPopupElement
:
:
GetState
(
nsString
&
aState
)
{
aState
.
AssignLiteral
(
"
closed
"
)
;
if
(
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
)
{
switch
(
pm
-
>
GetPopupState
(
this
)
)
{
case
ePopupShown
:
aState
.
AssignLiteral
(
"
open
"
)
;
break
;
case
ePopupShowing
:
case
ePopupPositioning
:
case
ePopupOpening
:
case
ePopupVisible
:
aState
.
AssignLiteral
(
"
showing
"
)
;
break
;
case
ePopupHiding
:
case
ePopupInvisible
:
aState
.
AssignLiteral
(
"
hiding
"
)
;
break
;
case
ePopupClosed
:
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Bad
popup
state
"
)
;
break
;
}
}
}
nsINode
*
XULPopupElement
:
:
GetTriggerNode
(
)
const
{
nsMenuPopupFrame
*
menuPopupFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
return
nsMenuPopupFrame
:
:
GetTriggerContent
(
menuPopupFrame
)
;
}
Element
*
XULPopupElement
:
:
GetAnchorNode
(
)
const
{
nsMenuPopupFrame
*
menuPopupFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
!
menuPopupFrame
)
{
return
nullptr
;
}
return
Element
:
:
FromNodeOrNull
(
menuPopupFrame
-
>
GetAnchor
(
)
)
;
}
already_AddRefed
<
DOMRect
>
XULPopupElement
:
:
GetOuterScreenRect
(
)
{
RefPtr
<
DOMRect
>
rect
=
new
DOMRect
(
ToSupports
(
OwnerDoc
(
)
)
)
;
nsMenuPopupFrame
*
menuPopupFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
FlushType
:
:
Frames
)
)
;
if
(
!
menuPopupFrame
|
|
!
menuPopupFrame
-
>
IsOpen
(
)
)
{
return
rect
.
forget
(
)
;
}
Maybe
<
CSSRect
>
screenRect
;
if
(
menuPopupFrame
-
>
IsNativeMenu
(
)
)
{
screenRect
=
Some
(
CSSRect
(
menuPopupFrame
-
>
GetScreenAnchorRect
(
)
)
)
;
}
else
{
if
(
nsView
*
view
=
menuPopupFrame
-
>
GetView
(
)
)
{
if
(
nsIWidget
*
widget
=
view
-
>
GetWidget
(
)
)
{
screenRect
=
Some
(
widget
-
>
GetScreenBounds
(
)
/
menuPopupFrame
-
>
PresContext
(
)
-
>
CSSToDevPixelScale
(
)
)
;
}
}
}
if
(
screenRect
)
{
rect
-
>
SetRect
(
screenRect
-
>
X
(
)
screenRect
-
>
Y
(
)
screenRect
-
>
Width
(
)
screenRect
-
>
Height
(
)
)
;
}
return
rect
.
forget
(
)
;
}
void
XULPopupElement
:
:
SetConstraintRect
(
dom
:
:
DOMRectReadOnly
&
aRect
)
{
nsMenuPopupFrame
*
menuPopupFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
FlushType
:
:
Frames
)
)
;
if
(
menuPopupFrame
)
{
menuPopupFrame
-
>
SetOverrideConstraintRect
(
LayoutDeviceIntRect
:
:
Truncate
(
aRect
.
Left
(
)
aRect
.
Top
(
)
aRect
.
Width
(
)
aRect
.
Height
(
)
)
)
;
}
}
bool
XULPopupElement
:
:
IsWaylandDragSource
(
)
const
{
#
ifdef
MOZ_WAYLAND
nsMenuPopupFrame
*
f
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
return
f
&
&
f
-
>
IsDragSource
(
)
;
#
else
return
false
;
#
endif
}
bool
XULPopupElement
:
:
IsWaylandPopup
(
)
const
{
#
ifdef
MOZ_WAYLAND
return
widget
:
:
GdkIsWaylandDisplay
(
)
|
|
widget
:
:
IsXWaylandProtocol
(
)
;
#
else
return
false
;
#
endif
}
}
