#
ifndef
mozilla_dom_XULDocument_h
#
define
mozilla_dom_XULDocument_h
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsXULPrototypeDocument
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
dom
/
XMLDocument
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
nsForwardReference
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDOMXULCommandDispatcher
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIXULDocument
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIStreamLoader
.
h
"
#
include
"
nsICSSLoaderObserver
.
h
"
#
include
"
nsIXULStore
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
class
nsIRDFResource
;
class
nsIRDFService
;
class
nsPIWindowRoot
;
class
nsXULPrototypeElement
;
#
if
0
class
nsIObjectInputStream
;
class
nsIObjectOutputStream
;
#
else
#
include
"
nsIObjectInputStream
.
h
"
#
include
"
nsIObjectOutputStream
.
h
"
#
include
"
nsXULElement
.
h
"
#
endif
#
include
"
nsURIHashKey
.
h
"
#
include
"
nsInterfaceHashtable
.
h
"
namespace
mozilla
{
namespace
dom
{
class
XULDocument
final
:
public
XMLDocument
public
nsIXULDocument
public
nsIStreamLoaderObserver
public
nsICSSLoaderObserver
public
nsIOffThreadScriptReceiver
{
public
:
XULDocument
(
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSISTREAMLOADEROBSERVER
virtual
void
Reset
(
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
)
override
;
virtual
void
ResetToURI
(
nsIURI
*
aURI
nsILoadGroup
*
aLoadGroup
nsIPrincipal
*
aPrincipal
)
override
;
virtual
nsresult
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
channel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
=
true
nsIContentSink
*
aSink
=
nullptr
)
override
;
virtual
void
SetContentType
(
const
nsAString
&
aContentType
)
override
;
virtual
void
EndLoad
(
)
override
;
virtual
XULDocument
*
AsXULDocument
(
)
override
{
return
this
;
}
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
NS_IMETHOD
AddSubtreeToDocument
(
nsIContent
*
aContent
)
override
;
NS_IMETHOD
RemoveSubtreeFromDocument
(
nsIContent
*
aContent
)
override
;
NS_IMETHOD
OnPrototypeLoadDone
(
bool
aResumeWalk
)
override
;
bool
OnDocumentParserError
(
)
override
;
virtual
nsresult
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
bool
aPreallocateChildren
)
const
override
;
using
nsDocument
:
:
CreateElement
;
using
nsDocument
:
:
CreateElementNS
;
NS_FORWARD_NSIDOMDOCUMENT
(
XMLDocument
:
:
)
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementById
;
using
nsDocument
:
:
GetImplementation
;
using
nsDocument
:
:
GetTitle
;
using
nsDocument
:
:
SetTitle
;
using
nsDocument
:
:
GetLastStyleSheetSet
;
using
nsDocument
:
:
MozSetImageElement
;
using
nsIDocument
:
:
GetLocation
;
NS_IMETHOD
StyleSheetLoaded
(
mozilla
:
:
StyleSheet
*
aSheet
bool
aWasAlternate
nsresult
aStatus
)
override
;
virtual
void
EndUpdate
(
nsUpdateType
aUpdateType
)
override
;
virtual
bool
IsDocumentRightToLeft
(
)
override
;
virtual
void
ResetDocumentDirection
(
)
override
;
virtual
nsIDocument
:
:
DocumentTheme
GetDocumentLWTheme
(
)
override
;
virtual
nsIDocument
:
:
DocumentTheme
ThreadSafeGetDocumentLWTheme
(
)
const
override
;
virtual
void
ResetDocumentLWTheme
(
)
override
{
mDocLWTheme
=
Doc_Theme_Uninitialized
;
}
NS_IMETHOD
OnScriptCompileComplete
(
JSScript
*
aScript
nsresult
aStatus
)
override
;
static
bool
MatchAttribute
(
Element
*
aContent
int32_t
aNameSpaceID
nsAtom
*
aAttrName
void
*
aData
)
;
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
XULDocument
XMLDocument
)
void
TraceProtos
(
JSTracer
*
aTrc
)
;
already_AddRefed
<
nsINode
>
GetPopupNode
(
)
;
void
SetPopupNode
(
nsINode
*
aNode
)
;
nsINode
*
GetPopupRangeParent
(
ErrorResult
&
aRv
)
;
int32_t
GetPopupRangeOffset
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
nsINode
>
GetTooltipNode
(
)
;
void
SetTooltipNode
(
nsINode
*
aNode
)
{
}
nsIDOMXULCommandDispatcher
*
GetCommandDispatcher
(
)
const
{
return
mCommandDispatcher
;
}
int32_t
GetWidth
(
ErrorResult
&
aRv
)
;
int32_t
GetHeight
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
nsINodeList
>
GetElementsByAttribute
(
const
nsAString
&
aAttribute
const
nsAString
&
aValue
)
;
already_AddRefed
<
nsINodeList
>
GetElementsByAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aAttribute
const
nsAString
&
aValue
ErrorResult
&
aRv
)
;
void
AddBroadcastListenerFor
(
Element
&
aBroadcaster
Element
&
aListener
const
nsAString
&
aAttr
ErrorResult
&
aRv
)
;
void
RemoveBroadcastListenerFor
(
Element
&
aBroadcaster
Element
&
aListener
const
nsAString
&
aAttr
)
;
void
Persist
(
const
nsAString
&
aId
const
nsAString
&
aAttr
ErrorResult
&
aRv
)
;
using
nsDocument
:
:
GetBoxObjectFor
;
void
LoadOverlay
(
const
nsAString
&
aURL
nsIObserver
*
aObserver
ErrorResult
&
aRv
)
;
protected
:
virtual
~
XULDocument
(
)
;
friend
nsresult
(
:
:
NS_NewXULDocument
(
nsIXULDocument
*
*
aResult
)
)
;
nsresult
Init
(
void
)
override
;
nsresult
StartLayout
(
void
)
;
nsresult
GetViewportSize
(
int32_t
*
aWidth
int32_t
*
aHeight
)
;
nsresult
PrepareToLoad
(
nsISupports
*
aContainer
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsIParser
*
*
aResult
)
;
nsresult
PrepareToLoadPrototype
(
nsIURI
*
aURI
const
char
*
aCommand
nsIPrincipal
*
aDocumentPrincipal
nsIParser
*
*
aResult
)
;
nsresult
LoadOverlayInternal
(
nsIURI
*
aURI
bool
aIsDynamic
bool
*
aShouldReturn
bool
*
aFailureFromContent
)
;
nsresult
ApplyPersistentAttributes
(
)
;
nsresult
ApplyPersistentAttributesInternal
(
)
;
nsresult
ApplyPersistentAttributesToElements
(
const
nsAString
&
aID
nsCOMArray
<
Element
>
&
aElements
)
;
nsresult
AddElementToDocumentPre
(
Element
*
aElement
)
;
nsresult
AddElementToDocumentPost
(
Element
*
aElement
)
;
nsresult
ExecuteOnBroadcastHandlerFor
(
Element
*
aBroadcaster
Element
*
aListener
nsAtom
*
aAttr
)
;
nsresult
BroadcastAttributeChangeFromOverlay
(
nsIContent
*
aNode
int32_t
aNameSpaceID
nsAtom
*
aAttribute
nsAtom
*
aPrefix
const
nsAString
&
aValue
)
;
already_AddRefed
<
nsPIWindowRoot
>
GetWindowRoot
(
)
;
static
void
DirectionChanged
(
const
char
*
aPrefName
void
*
aData
)
;
static
int32_t
gRefCnt
;
static
nsIRDFService
*
gRDFService
;
static
nsIRDFResource
*
kNC_persist
;
static
nsIRDFResource
*
kNC_attribute
;
static
nsIRDFResource
*
kNC_value
;
static
LazyLogModule
gXULLog
;
nsresult
Persist
(
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
)
;
void
DoPersist
(
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
)
{
Persist
(
aElement
aNameSpaceID
aAttribute
)
;
}
virtual
JSObject
*
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
XULDocument
*
mNextSrcLoadWaiter
;
nsCOMPtr
<
nsIXULStore
>
mLocalStore
;
bool
mApplyingPersistedAttrs
;
bool
mIsWritingFastLoad
;
bool
mDocumentLoaded
;
bool
mStillWalking
;
bool
mRestrictPersistence
;
nsTHashtable
<
nsStringHashKey
>
mPersistenceIds
;
nsTArray
<
RefPtr
<
StyleSheet
>
>
mOverlaySheets
;
nsCOMPtr
<
nsIDOMXULCommandDispatcher
>
mCommandDispatcher
;
uint32_t
mPendingSheets
;
DocumentTheme
mDocLWTheme
;
class
ContextStack
{
protected
:
struct
Entry
{
nsXULPrototypeElement
*
mPrototype
;
nsIContent
*
mElement
;
int32_t
mIndex
;
Entry
*
mNext
;
}
;
Entry
*
mTop
;
int32_t
mDepth
;
public
:
ContextStack
(
)
;
~
ContextStack
(
)
;
int32_t
Depth
(
)
{
return
mDepth
;
}
nsresult
Push
(
nsXULPrototypeElement
*
aPrototype
nsIContent
*
aElement
)
;
nsresult
Pop
(
)
;
nsresult
Peek
(
nsXULPrototypeElement
*
*
aPrototype
nsIContent
*
*
aElement
int32_t
*
aIndex
)
;
nsresult
SetTopIndex
(
int32_t
aIndex
)
;
}
;
friend
class
ContextStack
;
ContextStack
mContextStack
;
enum
State
{
eState_Master
eState_Overlay
}
;
State
mState
;
nsTArray
<
nsCOMPtr
<
nsIURI
>
>
mUnloadedOverlays
;
nsresult
LoadScript
(
nsXULPrototypeScript
*
aScriptProto
bool
*
aBlock
)
;
nsresult
ExecuteScript
(
nsXULPrototypeScript
*
aScript
)
;
nsresult
CreateElementFromPrototype
(
nsXULPrototypeElement
*
aPrototype
Element
*
*
aResult
bool
aIsRoot
)
;
nsresult
CreateOverlayElement
(
nsXULPrototypeElement
*
aPrototype
Element
*
*
aResult
)
;
nsresult
AddAttributes
(
nsXULPrototypeElement
*
aPrototype
Element
*
aElement
)
;
nsXULPrototypeScript
*
mCurrentScriptProto
;
bool
mOffThreadCompiling
;
char16_t
*
mOffThreadCompileStringBuf
;
size_t
mOffThreadCompileStringLength
;
nsresult
AddPrototypeSheets
(
)
;
protected
:
nsTArray
<
nsAutoPtr
<
nsForwardReference
>
>
mForwardReferences
;
nsForwardReference
:
:
Phase
mResolutionPhase
;
nsresult
AddForwardReference
(
nsForwardReference
*
aRef
)
;
nsresult
ResolveForwardReferences
(
)
;
class
BroadcasterHookup
:
public
nsForwardReference
{
protected
:
XULDocument
*
mDocument
;
RefPtr
<
Element
>
mObservesElement
;
bool
mResolved
;
public
:
BroadcasterHookup
(
XULDocument
*
aDocument
Element
*
aObservesElement
)
:
mDocument
(
aDocument
)
mObservesElement
(
aObservesElement
)
mResolved
(
false
)
{
}
virtual
~
BroadcasterHookup
(
)
;
virtual
Phase
GetPhase
(
)
override
{
return
eHookup
;
}
virtual
Result
Resolve
(
)
override
;
}
;
friend
class
BroadcasterHookup
;
class
OverlayForwardReference
:
public
nsForwardReference
{
protected
:
XULDocument
*
mDocument
;
nsCOMPtr
<
Element
>
mOverlay
;
bool
mResolved
;
nsresult
Merge
(
Element
*
aTargetNode
Element
*
aOverlayNode
bool
aNotify
)
;
public
:
OverlayForwardReference
(
XULDocument
*
aDocument
Element
*
aOverlay
)
:
mDocument
(
aDocument
)
mOverlay
(
aOverlay
)
mResolved
(
false
)
{
}
virtual
~
OverlayForwardReference
(
)
;
virtual
Phase
GetPhase
(
)
override
{
return
eConstruction
;
}
virtual
Result
Resolve
(
)
override
;
}
;
friend
class
OverlayForwardReference
;
nsresult
FindBroadcaster
(
Element
*
aElement
Element
*
*
aListener
nsString
&
aBroadcasterID
nsString
&
aAttribute
Element
*
*
aBroadcaster
)
;
nsresult
CheckBroadcasterHookup
(
Element
*
aElement
bool
*
aNeedsHookup
bool
*
aDidResolve
)
;
void
SynchronizeBroadcastListener
(
Element
*
aBroadcaster
Element
*
aListener
const
nsAString
&
aAttr
)
;
static
nsresult
InsertElement
(
nsINode
*
aParent
nsIContent
*
aChild
bool
aNotify
)
;
RefPtr
<
nsXULPrototypeDocument
>
mCurrentPrototype
;
RefPtr
<
nsXULPrototypeDocument
>
mMasterPrototype
;
nsTArray
<
RefPtr
<
nsXULPrototypeDocument
>
>
mPrototypes
;
nsresult
PrepareToWalk
(
)
;
nsresult
CreateAndInsertPI
(
const
nsXULPrototypePI
*
aProtoPI
nsINode
*
aParent
nsINode
*
aBeforeThis
)
;
nsresult
InsertXMLStylesheetPI
(
const
nsXULPrototypePI
*
aProtoPI
nsINode
*
aParent
nsINode
*
aBeforeThis
nsIContent
*
aPINode
)
;
nsresult
InsertXULOverlayPI
(
const
nsXULPrototypePI
*
aProtoPI
nsINode
*
aParent
nsINode
*
aBeforeThis
nsIContent
*
aPINode
)
;
nsresult
AddChromeOverlays
(
)
;
nsresult
ResumeWalk
(
)
;
nsresult
DoneWalking
(
)
;
void
ReportMissingOverlay
(
nsIURI
*
aURI
)
;
class
CachedChromeStreamListener
:
public
nsIStreamListener
{
protected
:
RefPtr
<
XULDocument
>
mDocument
;
bool
mProtoLoaded
;
virtual
~
CachedChromeStreamListener
(
)
;
public
:
CachedChromeStreamListener
(
XULDocument
*
aDocument
bool
aProtoLoaded
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
}
;
friend
class
CachedChromeStreamListener
;
class
ParserObserver
:
public
nsIRequestObserver
{
protected
:
RefPtr
<
XULDocument
>
mDocument
;
RefPtr
<
nsXULPrototypeDocument
>
mPrototype
;
virtual
~
ParserObserver
(
)
;
public
:
ParserObserver
(
XULDocument
*
aDocument
nsXULPrototypeDocument
*
aPrototype
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
}
;
friend
class
ParserObserver
;
PLDHashTable
*
mBroadcasterMap
;
nsAutoPtr
<
nsInterfaceHashtable
<
nsURIHashKey
nsIObserver
>
>
mOverlayLoadObservers
;
nsAutoPtr
<
nsInterfaceHashtable
<
nsURIHashKey
nsIObserver
>
>
mPendingOverlayLoadNotifications
;
bool
mInitialLayoutComplete
;
class
nsDelayedBroadcastUpdate
{
public
:
nsDelayedBroadcastUpdate
(
Element
*
aBroadcaster
Element
*
aListener
const
nsAString
&
aAttr
)
:
mBroadcaster
(
aBroadcaster
)
mListener
(
aListener
)
mAttr
(
aAttr
)
mSetAttr
(
false
)
mNeedsAttrChange
(
false
)
{
}
nsDelayedBroadcastUpdate
(
Element
*
aBroadcaster
Element
*
aListener
nsAtom
*
aAttrName
const
nsAString
&
aAttr
bool
aSetAttr
bool
aNeedsAttrChange
)
:
mBroadcaster
(
aBroadcaster
)
mListener
(
aListener
)
mAttr
(
aAttr
)
mAttrName
(
aAttrName
)
mSetAttr
(
aSetAttr
)
mNeedsAttrChange
(
aNeedsAttrChange
)
{
}
nsDelayedBroadcastUpdate
(
const
nsDelayedBroadcastUpdate
&
aOther
)
:
mBroadcaster
(
aOther
.
mBroadcaster
)
mListener
(
aOther
.
mListener
)
mAttr
(
aOther
.
mAttr
)
mAttrName
(
aOther
.
mAttrName
)
mSetAttr
(
aOther
.
mSetAttr
)
mNeedsAttrChange
(
aOther
.
mNeedsAttrChange
)
{
}
nsCOMPtr
<
Element
>
mBroadcaster
;
nsCOMPtr
<
Element
>
mListener
;
nsString
mAttr
;
RefPtr
<
nsAtom
>
mAttrName
;
bool
mSetAttr
;
bool
mNeedsAttrChange
;
class
Comparator
{
public
:
static
bool
Equals
(
const
nsDelayedBroadcastUpdate
&
a
const
nsDelayedBroadcastUpdate
&
b
)
{
return
a
.
mBroadcaster
=
=
b
.
mBroadcaster
&
&
a
.
mListener
=
=
b
.
mListener
&
&
a
.
mAttrName
=
=
b
.
mAttrName
;
}
}
;
}
;
nsTArray
<
nsDelayedBroadcastUpdate
>
mDelayedBroadcasters
;
nsTArray
<
nsDelayedBroadcastUpdate
>
mDelayedAttrChangeBroadcasts
;
bool
mHandlingDelayedAttrChange
;
bool
mHandlingDelayedBroadcasters
;
void
MaybeBroadcast
(
)
;
private
:
}
;
}
}
#
endif
