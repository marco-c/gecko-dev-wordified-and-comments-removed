#
ifndef
mozilla_dom_XULDocument_h
#
define
mozilla_dom_XULDocument_h
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsXULPrototypeDocument
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
dom
/
XMLDocument
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIStreamLoader
.
h
"
#
include
"
nsICSSLoaderObserver
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
class
nsPIWindowRoot
;
class
nsXULPrototypeElement
;
#
if
0
class
nsIObjectInputStream
;
class
nsIObjectOutputStream
;
#
else
#
include
"
nsIObjectInputStream
.
h
"
#
include
"
nsIObjectOutputStream
.
h
"
#
include
"
nsXULElement
.
h
"
#
endif
#
include
"
nsURIHashKey
.
h
"
#
include
"
nsInterfaceHashtable
.
h
"
nsresult
NS_NewXULDocument
(
nsIDocument
*
*
result
)
;
namespace
mozilla
{
namespace
dom
{
class
XULDocument
final
:
public
XMLDocument
public
nsIStreamLoaderObserver
public
nsICSSLoaderObserver
public
nsIOffThreadScriptReceiver
{
public
:
XULDocument
(
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSISTREAMLOADEROBSERVER
virtual
void
Reset
(
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
)
override
;
virtual
void
ResetToURI
(
nsIURI
*
aURI
nsILoadGroup
*
aLoadGroup
nsIPrincipal
*
aPrincipal
)
override
;
virtual
nsresult
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
channel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
=
true
nsIContentSink
*
aSink
=
nullptr
)
override
;
virtual
void
SetContentType
(
const
nsAString
&
aContentType
)
override
;
virtual
void
EndLoad
(
)
override
;
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
void
AddSubtreeToDocument
(
nsIContent
*
aContent
)
;
nsresult
OnPrototypeLoadDone
(
bool
aResumeWalk
)
;
virtual
nsresult
Clone
(
dom
:
:
NodeInfo
*
nsINode
*
*
aResult
)
const
override
;
NS_IMETHOD
StyleSheetLoaded
(
mozilla
:
:
StyleSheet
*
aSheet
bool
aWasAlternate
nsresult
aStatus
)
override
;
virtual
void
EndUpdate
(
)
override
;
virtual
bool
IsDocumentRightToLeft
(
)
override
;
void
ResetDocumentDirection
(
)
;
NS_IMETHOD
OnScriptCompileComplete
(
JSScript
*
aScript
nsresult
aStatus
)
override
;
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
XULDocument
XMLDocument
)
void
TraceProtos
(
JSTracer
*
aTrc
)
;
protected
:
virtual
~
XULDocument
(
)
;
friend
nsresult
(
:
:
NS_NewXULDocument
(
nsIDocument
*
*
aResult
)
)
;
nsresult
Init
(
void
)
override
;
nsresult
StartLayout
(
void
)
;
nsresult
PrepareToLoad
(
nsISupports
*
aContainer
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsIParser
*
*
aResult
)
;
nsresult
PrepareToLoadPrototype
(
nsIURI
*
aURI
const
char
*
aCommand
nsIPrincipal
*
aDocumentPrincipal
nsIParser
*
*
aResult
)
;
void
AddElementToDocumentPost
(
Element
*
aElement
)
;
static
void
DirectionChanged
(
const
char
*
aPrefName
XULDocument
*
aData
)
;
static
int32_t
gRefCnt
;
static
LazyLogModule
gXULLog
;
virtual
JSObject
*
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
XULDocument
*
mNextSrcLoadWaiter
;
bool
mIsWritingFastLoad
;
bool
mDocumentLoaded
;
bool
mStillWalking
;
uint32_t
mPendingSheets
;
class
ContextStack
{
protected
:
struct
Entry
{
nsXULPrototypeElement
*
mPrototype
;
nsIContent
*
mElement
;
int32_t
mIndex
;
Entry
*
mNext
;
}
;
Entry
*
mTop
;
int32_t
mDepth
;
public
:
ContextStack
(
)
;
~
ContextStack
(
)
;
int32_t
Depth
(
)
{
return
mDepth
;
}
nsresult
Push
(
nsXULPrototypeElement
*
aPrototype
nsIContent
*
aElement
)
;
nsresult
Pop
(
)
;
nsresult
Peek
(
nsXULPrototypeElement
*
*
aPrototype
nsIContent
*
*
aElement
int32_t
*
aIndex
)
;
nsresult
SetTopIndex
(
int32_t
aIndex
)
;
}
;
friend
class
ContextStack
;
ContextStack
mContextStack
;
nsresult
LoadScript
(
nsXULPrototypeScript
*
aScriptProto
bool
*
aBlock
)
;
nsresult
ExecuteScript
(
nsXULPrototypeScript
*
aScript
)
;
nsresult
CreateElementFromPrototype
(
nsXULPrototypeElement
*
aPrototype
Element
*
*
aResult
bool
aIsRoot
)
;
nsresult
AddAttributes
(
nsXULPrototypeElement
*
aPrototype
Element
*
aElement
)
;
nsXULPrototypeScript
*
mCurrentScriptProto
;
bool
mOffThreadCompiling
;
char16_t
*
mOffThreadCompileStringBuf
;
size_t
mOffThreadCompileStringLength
;
protected
:
RefPtr
<
nsXULPrototypeDocument
>
mCurrentPrototype
;
nsTArray
<
RefPtr
<
nsXULPrototypeDocument
>
>
mPrototypes
;
nsresult
PrepareToWalk
(
)
;
nsresult
CreateAndInsertPI
(
const
nsXULPrototypePI
*
aProtoPI
nsINode
*
aParent
nsINode
*
aBeforeThis
)
;
nsresult
InsertXMLStylesheetPI
(
const
nsXULPrototypePI
*
aProtoPI
nsINode
*
aParent
nsINode
*
aBeforeThis
nsIContent
*
aPINode
)
;
nsresult
ResumeWalk
(
)
;
nsresult
DoneWalking
(
)
;
class
CachedChromeStreamListener
:
public
nsIStreamListener
{
protected
:
RefPtr
<
XULDocument
>
mDocument
;
bool
mProtoLoaded
;
virtual
~
CachedChromeStreamListener
(
)
;
public
:
CachedChromeStreamListener
(
XULDocument
*
aDocument
bool
aProtoLoaded
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
}
;
friend
class
CachedChromeStreamListener
;
bool
mInitialLayoutComplete
;
private
:
}
;
}
}
inline
mozilla
:
:
dom
:
:
XULDocument
*
nsIDocument
:
:
AsXULDocument
(
)
{
MOZ_ASSERT
(
IsXULDocument
(
)
)
;
return
static_cast
<
mozilla
:
:
dom
:
:
XULDocument
*
>
(
this
)
;
}
#
endif
