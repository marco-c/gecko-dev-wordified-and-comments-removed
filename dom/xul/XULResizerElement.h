#
ifndef
mozilla_dom_XULResizerElement_h
#
define
mozilla_dom_XULResizerElement_h
#
include
"
nsXULElement
.
h
"
#
include
"
Units
.
h
"
namespace
mozilla
:
:
dom
{
nsXULElement
*
NS_NewXULResizerElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
;
class
XULResizerElement
final
:
public
nsXULElement
{
public
:
explicit
XULResizerElement
(
already_AddRefed
<
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
nsXULElement
(
std
:
:
move
(
aNodeInfo
)
)
{
}
MOZ_CAN_RUN_SCRIPT
nsresult
PostHandleEvent
(
EventChainPostVisitor
&
)
override
;
private
:
virtual
~
XULResizerElement
(
)
=
default
;
JSObject
*
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
final
;
MOZ_CAN_RUN_SCRIPT
void
PostHandleEventInternal
(
EventChainPostVisitor
&
)
;
struct
Direction
{
int8_t
mHorizontal
;
int8_t
mVertical
;
}
;
Direction
GetDirection
(
)
;
nsIContent
*
GetContentToResize
(
)
const
;
static
void
AdjustDimensions
(
int32_t
*
aPos
int32_t
*
aSize
int32_t
aMovement
int8_t
aResizerDirection
)
;
struct
SizeInfo
{
nsCString
width
height
;
}
;
static
void
SizeInfoDtorFunc
(
void
*
aObject
nsAtom
*
aPropertyName
void
*
aPropertyValue
void
*
aData
)
;
static
void
ResizeContent
(
nsIContent
*
aContent
const
Direction
&
aDirection
const
SizeInfo
&
aSizeInfo
SizeInfo
*
aOriginalSizeInfo
)
;
static
void
MaybePersistOriginalSize
(
nsIContent
*
aContent
const
SizeInfo
&
aSizeInfo
)
;
static
void
RestoreOriginalSize
(
nsIContent
*
aContent
)
;
LayoutDeviceIntRect
mMouseDownRect
;
LayoutDeviceIntPoint
mMouseDownPoint
;
bool
mTrackingMouseMove
=
false
;
}
;
}
#
endif
