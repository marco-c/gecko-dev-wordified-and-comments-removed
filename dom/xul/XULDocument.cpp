#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
XULDocument
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIBoxObject
.
h
"
#
include
"
nsIChromeRegistry
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsXMLContentSink
.
h
"
#
include
"
nsXULContentSink
.
h
"
#
include
"
nsXULContentUtils
.
h
"
#
include
"
nsIStringEnumerator
.
h
"
#
include
"
nsDocElementCreatedNotificationRunner
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsParserCIID
.
h
"
#
include
"
nsPIBoxObject
.
h
"
#
include
"
mozilla
/
dom
/
BoxObject
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsXULElement
.
h
"
#
include
"
nsXULPrototypeCache
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsXBLService
.
h
"
#
include
"
nsCExternalHandlerService
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsIObjectInputStream
.
h
"
#
include
"
nsIObjectOutputStream
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIParser
.
h
"
#
include
"
nsCharsetSource
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIStyleSheetLinkingElement
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsNodeUtils
.
h
"
#
include
"
nsIXULWindow
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsURILoader
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfoInlines
.
h
"
#
include
"
mozilla
/
dom
/
ProcessingInstruction
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
XULDocumentBinding
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
js
/
SourceBufferHolder
.
h
"
#
include
"
mozilla
/
dom
/
URL
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
nsIConsoleService
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
NS_DEFINE_CID
(
kParserCID
NS_PARSER_CID
)
;
const
nsForwardReference
:
:
Phase
nsForwardReference
:
:
kPasses
[
]
=
{
nsForwardReference
:
:
eConstruction
nsForwardReference
:
:
eHookup
nsForwardReference
:
:
eDone
}
;
int32_t
XULDocument
:
:
gRefCnt
=
0
;
LazyLogModule
XULDocument
:
:
gXULLog
(
"
XULDocument
"
)
;
struct
BroadcastListener
{
nsWeakPtr
mListener
;
RefPtr
<
nsAtom
>
mAttribute
;
}
;
struct
BroadcasterMapEntry
:
public
PLDHashEntryHdr
{
Element
*
mBroadcaster
;
nsTArray
<
BroadcastListener
*
>
mListeners
;
}
;
namespace
mozilla
{
namespace
dom
{
XULDocument
:
:
XULDocument
(
void
)
:
XMLDocument
(
"
application
/
vnd
.
mozilla
.
xul
+
xml
"
)
mNextSrcLoadWaiter
(
nullptr
)
mApplyingPersistedAttrs
(
false
)
mIsWritingFastLoad
(
false
)
mDocumentLoaded
(
false
)
mStillWalking
(
false
)
mPendingSheets
(
0
)
mDocLWTheme
(
Doc_Theme_Uninitialized
)
mCurrentScriptProto
(
nullptr
)
mOffThreadCompiling
(
false
)
mOffThreadCompileStringBuf
(
nullptr
)
mOffThreadCompileStringLength
(
0
)
mResolutionPhase
(
nsForwardReference
:
:
eStart
)
mBroadcasterMap
(
nullptr
)
mInitialLayoutComplete
(
false
)
mHandlingDelayedAttrChange
(
false
)
mHandlingDelayedBroadcasters
(
false
)
{
mCharacterSet
=
UTF_8_ENCODING
;
mDefaultElementType
=
kNameSpaceID_XUL
;
mType
=
eXUL
;
mDelayFrameLoaderInitialization
=
true
;
mAllowXULXBL
=
eTriTrue
;
}
XULDocument
:
:
~
XULDocument
(
)
{
NS_ASSERTION
(
mNextSrcLoadWaiter
=
=
nullptr
"
unreferenced
document
still
waiting
for
script
source
to
load
?
"
)
;
mForwardReferences
.
Clear
(
)
;
delete
mBroadcasterMap
;
Preferences
:
:
UnregisterCallback
(
XULDocument
:
:
DirectionChanged
"
intl
.
uidirection
"
this
)
;
if
(
mOffThreadCompileStringBuf
)
{
js_free
(
mOffThreadCompileStringBuf
)
;
}
}
}
}
nsresult
NS_NewXULDocument
(
nsIDocument
*
*
result
)
{
MOZ_ASSERT
(
result
!
=
nullptr
"
null
ptr
"
)
;
if
(
!
result
)
return
NS_ERROR_NULL_POINTER
;
RefPtr
<
XULDocument
>
doc
=
new
XULDocument
(
)
;
nsresult
rv
;
if
(
NS_FAILED
(
rv
=
doc
-
>
Init
(
)
)
)
{
return
rv
;
}
doc
.
forget
(
result
)
;
return
NS_OK
;
}
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
XULDocument
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
XULDocument
XMLDocument
)
NS_ASSERTION
(
!
nsCCUncollectableMarker
:
:
InGeneration
(
cb
tmp
-
>
GetMarkedCCGeneration
(
)
)
"
Shouldn
'
t
traverse
XULDocument
!
"
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCurrentPrototype
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPrototypes
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLocalStore
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
XULDocument
XMLDocument
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLocalStore
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED
(
XULDocument
XMLDocument
nsIStreamLoaderObserver
nsICSSLoaderObserver
nsIOffThreadScriptReceiver
)
void
XULDocument
:
:
Reset
(
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Reset
"
)
;
}
void
XULDocument
:
:
ResetToURI
(
nsIURI
*
aURI
nsILoadGroup
*
aLoadGroup
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT_UNREACHABLE
(
"
ResetToURI
"
)
;
}
void
XULDocument
:
:
SetContentType
(
const
nsAString
&
aContentType
)
{
NS_ASSERTION
(
aContentType
.
EqualsLiteral
(
"
application
/
vnd
.
mozilla
.
xul
+
xml
"
)
"
xul
-
documents
always
has
content
-
type
application
/
vnd
.
mozilla
.
xul
+
xml
"
)
;
}
nsresult
XULDocument
:
:
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
nsIContentSink
*
aSink
)
{
if
(
MOZ_LOG_TEST
(
gXULLog
LogLevel
:
:
Warning
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
urlspec
;
rv
=
uri
-
>
GetSpec
(
urlspec
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_LOG
(
gXULLog
LogLevel
:
:
Warning
(
"
xul
:
load
document
'
%
s
'
"
urlspec
.
get
(
)
)
)
;
}
}
}
mStillWalking
=
true
;
mMayStartLayout
=
false
;
mDocumentLoadGroup
=
do_GetWeakReference
(
aLoadGroup
)
;
mChannel
=
aChannel
;
nsresult
rv
=
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
mDocumentURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mOriginalURI
=
mDocumentURI
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
mChannel
getter_AddRefs
(
principal
)
)
;
principal
=
MaybeDowngradePrincipal
(
principal
)
;
ResetStylesheetsToURI
(
mDocumentURI
)
;
RetrieveRelevantHeaders
(
aChannel
)
;
nsXULPrototypeDocument
*
proto
=
IsChromeURI
(
mDocumentURI
)
?
nsXULPrototypeCache
:
:
GetInstance
(
)
-
>
GetPrototype
(
mDocumentURI
)
:
nullptr
;
if
(
proto
)
{
bool
loaded
;
rv
=
proto
-
>
AwaitLoadDone
(
this
&
loaded
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
mCurrentPrototype
=
proto
;
SetPrincipal
(
proto
-
>
DocumentPrincipal
(
)
)
;
*
aDocListener
=
new
CachedChromeStreamListener
(
this
loaded
)
;
}
else
{
bool
useXULCache
=
nsXULPrototypeCache
:
:
GetInstance
(
)
-
>
IsEnabled
(
)
;
bool
fillXULCache
=
(
useXULCache
&
&
IsChromeURI
(
mDocumentURI
)
)
;
nsCOMPtr
<
nsIParser
>
parser
;
rv
=
PrepareToLoadPrototype
(
mDocumentURI
aCommand
principal
getter_AddRefs
(
parser
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
mIsWritingFastLoad
=
useXULCache
;
nsCOMPtr
<
nsIStreamListener
>
listener
=
do_QueryInterface
(
parser
&
rv
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
parser
doesn
'
t
support
nsIStreamListener
"
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
*
aDocListener
=
listener
;
parser
-
>
Parse
(
mDocumentURI
)
;
if
(
fillXULCache
)
{
nsXULPrototypeCache
:
:
GetInstance
(
)
-
>
PutPrototype
(
mCurrentPrototype
)
;
}
}
NS_IF_ADDREF
(
*
aDocListener
)
;
return
NS_OK
;
}
void
XULDocument
:
:
EndLoad
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
uri
=
mCurrentPrototype
-
>
GetURI
(
)
;
bool
isChrome
=
IsChromeURI
(
uri
)
;
bool
useXULCache
=
nsXULPrototypeCache
:
:
GetInstance
(
)
-
>
IsEnabled
(
)
;
if
(
isChrome
&
&
useXULCache
)
{
rv
=
mCurrentPrototype
-
>
NotifyLoadDone
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
}
OnPrototypeLoadDone
(
true
)
;
if
(
MOZ_LOG_TEST
(
gXULLog
LogLevel
:
:
Warning
)
)
{
nsAutoCString
urlspec
;
rv
=
uri
-
>
GetSpec
(
urlspec
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_LOG
(
gXULLog
LogLevel
:
:
Warning
(
"
xul
:
Finished
loading
document
'
%
s
'
"
urlspec
.
get
(
)
)
)
;
}
}
}
nsresult
XULDocument
:
:
OnPrototypeLoadDone
(
bool
aResumeWalk
)
{
nsresult
rv
;
rv
=
PrepareToWalk
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
unable
to
prepare
for
walk
"
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
aResumeWalk
)
{
rv
=
ResumeWalk
(
)
;
}
return
rv
;
}
static
void
ClearBroadcasterMapEntry
(
PLDHashTable
*
aTable
PLDHashEntryHdr
*
aEntry
)
{
BroadcasterMapEntry
*
entry
=
static_cast
<
BroadcasterMapEntry
*
>
(
aEntry
)
;
for
(
size_t
i
=
entry
-
>
mListeners
.
Length
(
)
-
1
;
i
!
=
(
size_t
)
-
1
;
-
-
i
)
{
delete
entry
-
>
mListeners
[
i
]
;
}
entry
-
>
mListeners
.
Clear
(
)
;
entry
-
>
mListeners
.
~
nsTArray
<
BroadcastListener
*
>
(
)
;
}
static
bool
CanBroadcast
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
(
aAttribute
=
=
nsGkAtoms
:
:
id
)
|
|
(
aAttribute
=
=
nsGkAtoms
:
:
persist
)
|
|
(
aAttribute
=
=
nsGkAtoms
:
:
command
)
|
|
(
aAttribute
=
=
nsGkAtoms
:
:
observes
)
)
{
return
false
;
}
}
return
true
;
}
struct
nsAttrNameInfo
{
nsAttrNameInfo
(
int32_t
aNamespaceID
nsAtom
*
aName
nsAtom
*
aPrefix
)
:
mNamespaceID
(
aNamespaceID
)
mName
(
aName
)
mPrefix
(
aPrefix
)
{
}
nsAttrNameInfo
(
const
nsAttrNameInfo
&
aOther
)
:
mNamespaceID
(
aOther
.
mNamespaceID
)
mName
(
aOther
.
mName
)
mPrefix
(
aOther
.
mPrefix
)
{
}
int32_t
mNamespaceID
;
RefPtr
<
nsAtom
>
mName
;
RefPtr
<
nsAtom
>
mPrefix
;
}
;
void
XULDocument
:
:
SynchronizeBroadcastListener
(
Element
*
aBroadcaster
Element
*
aListener
const
nsAString
&
aAttr
)
{
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsDelayedBroadcastUpdate
delayedUpdate
(
aBroadcaster
aListener
aAttr
)
;
mDelayedBroadcasters
.
AppendElement
(
delayedUpdate
)
;
MaybeBroadcast
(
)
;
return
;
}
bool
notify
=
mDocumentLoaded
|
|
mHandlingDelayedBroadcasters
;
if
(
aAttr
.
EqualsLiteral
(
"
*
"
)
)
{
uint32_t
count
=
aBroadcaster
-
>
GetAttrCount
(
)
;
nsTArray
<
nsAttrNameInfo
>
attributes
(
count
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
const
nsAttrName
*
attrName
=
aBroadcaster
-
>
GetAttrNameAt
(
i
)
;
int32_t
nameSpaceID
=
attrName
-
>
NamespaceID
(
)
;
nsAtom
*
name
=
attrName
-
>
LocalName
(
)
;
if
(
!
CanBroadcast
(
nameSpaceID
name
)
)
continue
;
attributes
.
AppendElement
(
nsAttrNameInfo
(
nameSpaceID
name
attrName
-
>
GetPrefix
(
)
)
)
;
}
count
=
attributes
.
Length
(
)
;
while
(
count
-
-
>
0
)
{
int32_t
nameSpaceID
=
attributes
[
count
]
.
mNamespaceID
;
nsAtom
*
name
=
attributes
[
count
]
.
mName
;
nsAutoString
value
;
if
(
aBroadcaster
-
>
GetAttr
(
nameSpaceID
name
value
)
)
{
aListener
-
>
SetAttr
(
nameSpaceID
name
attributes
[
count
]
.
mPrefix
value
notify
)
;
}
#
if
0
ExecuteOnBroadcastHandlerFor
(
aBroadcaster
aListener
name
)
;
#
endif
}
}
else
{
RefPtr
<
nsAtom
>
name
=
NS_Atomize
(
aAttr
)
;
nsAutoString
value
;
if
(
aBroadcaster
-
>
GetAttr
(
kNameSpaceID_None
name
value
)
)
{
aListener
-
>
SetAttr
(
kNameSpaceID_None
name
value
notify
)
;
}
else
{
aListener
-
>
UnsetAttr
(
kNameSpaceID_None
name
notify
)
;
}
#
if
0
ExecuteOnBroadcastHandlerFor
(
aBroadcaster
aListener
name
)
;
#
endif
}
}
void
XULDocument
:
:
AddBroadcastListenerFor
(
Element
&
aBroadcaster
Element
&
aListener
const
nsAString
&
aAttr
ErrorResult
&
aRv
)
{
nsresult
rv
=
nsContentUtils
:
:
CheckSameOrigin
(
this
&
aBroadcaster
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
rv
=
nsContentUtils
:
:
CheckSameOrigin
(
this
&
aListener
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
static
const
PLDHashTableOps
gOps
=
{
PLDHashTable
:
:
HashVoidPtrKeyStub
PLDHashTable
:
:
MatchEntryStub
PLDHashTable
:
:
MoveEntryStub
ClearBroadcasterMapEntry
nullptr
}
;
if
(
!
mBroadcasterMap
)
{
mBroadcasterMap
=
new
PLDHashTable
(
&
gOps
sizeof
(
BroadcasterMapEntry
)
)
;
}
auto
entry
=
static_cast
<
BroadcasterMapEntry
*
>
(
mBroadcasterMap
-
>
Search
(
&
aBroadcaster
)
)
;
if
(
!
entry
)
{
entry
=
static_cast
<
BroadcasterMapEntry
*
>
(
mBroadcasterMap
-
>
Add
(
&
aBroadcaster
fallible
)
)
;
if
(
!
entry
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
entry
-
>
mBroadcaster
=
&
aBroadcaster
;
new
(
&
entry
-
>
mListeners
)
nsTArray
<
BroadcastListener
*
>
(
)
;
}
RefPtr
<
nsAtom
>
attr
=
NS_Atomize
(
aAttr
)
;
for
(
size_t
i
=
entry
-
>
mListeners
.
Length
(
)
-
1
;
i
!
=
(
size_t
)
-
1
;
-
-
i
)
{
BroadcastListener
*
bl
=
entry
-
>
mListeners
[
i
]
;
nsCOMPtr
<
Element
>
blListener
=
do_QueryReferent
(
bl
-
>
mListener
)
;
if
(
blListener
=
=
&
aListener
&
&
bl
-
>
mAttribute
=
=
attr
)
return
;
}
BroadcastListener
*
bl
=
new
BroadcastListener
;
bl
-
>
mListener
=
do_GetWeakReference
(
&
aListener
)
;
bl
-
>
mAttribute
=
attr
;
entry
-
>
mListeners
.
AppendElement
(
bl
)
;
SynchronizeBroadcastListener
(
&
aBroadcaster
&
aListener
aAttr
)
;
}
void
XULDocument
:
:
RemoveBroadcastListenerFor
(
Element
&
aBroadcaster
Element
&
aListener
const
nsAString
&
aAttr
)
{
if
(
!
mBroadcasterMap
)
return
;
auto
entry
=
static_cast
<
BroadcasterMapEntry
*
>
(
mBroadcasterMap
-
>
Search
(
&
aBroadcaster
)
)
;
if
(
entry
)
{
RefPtr
<
nsAtom
>
attr
=
NS_Atomize
(
aAttr
)
;
for
(
size_t
i
=
entry
-
>
mListeners
.
Length
(
)
-
1
;
i
!
=
(
size_t
)
-
1
;
-
-
i
)
{
BroadcastListener
*
bl
=
entry
-
>
mListeners
[
i
]
;
nsCOMPtr
<
Element
>
blListener
=
do_QueryReferent
(
bl
-
>
mListener
)
;
if
(
blListener
=
=
&
aListener
&
&
bl
-
>
mAttribute
=
=
attr
)
{
entry
-
>
mListeners
.
RemoveElementAt
(
i
)
;
delete
bl
;
if
(
entry
-
>
mListeners
.
IsEmpty
(
)
)
mBroadcasterMap
-
>
RemoveEntry
(
entry
)
;
break
;
}
}
}
}
nsresult
XULDocument
:
:
ExecuteOnBroadcastHandlerFor
(
Element
*
aBroadcaster
Element
*
aListener
nsAtom
*
aAttr
)
{
for
(
nsIContent
*
child
=
aListener
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
!
child
-
>
IsXULElement
(
nsGkAtoms
:
:
observes
)
)
continue
;
nsAutoString
listeningToID
;
child
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
element
listeningToID
)
;
nsAutoString
broadcasterID
;
aBroadcaster
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
broadcasterID
)
;
if
(
listeningToID
!
=
broadcasterID
)
continue
;
nsAutoString
listeningToAttribute
;
child
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
attribute
listeningToAttribute
)
;
if
(
!
aAttr
-
>
Equals
(
listeningToAttribute
)
&
&
!
listeningToAttribute
.
EqualsLiteral
(
"
*
"
)
)
{
continue
;
}
WidgetEvent
event
(
true
eXULBroadcast
)
;
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
EventDispatcher
:
:
Dispatch
(
child
presContext
&
event
nullptr
&
status
)
;
}
}
return
NS_OK
;
}
static
bool
ShouldPersistAttribute
(
Element
*
aElement
nsAtom
*
aAttribute
)
{
if
(
aElement
-
>
IsXULElement
(
nsGkAtoms
:
:
window
)
)
{
if
(
aElement
-
>
OwnerDoc
(
)
-
>
GetParentDocument
(
)
)
{
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
screenX
|
|
aAttribute
=
=
nsGkAtoms
:
:
screenY
|
|
aAttribute
=
=
nsGkAtoms
:
:
width
|
|
aAttribute
=
=
nsGkAtoms
:
:
height
|
|
aAttribute
=
=
nsGkAtoms
:
:
sizemode
)
{
return
false
;
}
}
return
true
;
}
void
XULDocument
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
NS_ASSERTION
(
aElement
-
>
OwnerDoc
(
)
=
=
this
"
unexpected
doc
"
)
;
nsCOMPtr
<
nsIMutationObserver
>
kungFuDeathGrip
(
this
)
;
if
(
mBroadcasterMap
&
&
CanBroadcast
(
aNameSpaceID
aAttribute
)
)
{
auto
entry
=
static_cast
<
BroadcasterMapEntry
*
>
(
mBroadcasterMap
-
>
Search
(
aElement
)
)
;
if
(
entry
)
{
nsAutoString
value
;
bool
attrSet
=
aElement
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
value
)
;
for
(
size_t
i
=
entry
-
>
mListeners
.
Length
(
)
-
1
;
i
!
=
(
size_t
)
-
1
;
-
-
i
)
{
BroadcastListener
*
bl
=
entry
-
>
mListeners
[
i
]
;
if
(
(
bl
-
>
mAttribute
=
=
aAttribute
)
|
|
(
bl
-
>
mAttribute
=
=
nsGkAtoms
:
:
_asterisk
)
)
{
nsCOMPtr
<
Element
>
listenerEl
=
do_QueryReferent
(
bl
-
>
mListener
)
;
if
(
listenerEl
)
{
nsAutoString
currentValue
;
bool
hasAttr
=
listenerEl
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
currentValue
)
;
bool
needsAttrChange
=
attrSet
!
=
hasAttr
|
|
!
value
.
Equals
(
currentValue
)
;
nsDelayedBroadcastUpdate
delayedUpdate
(
aElement
listenerEl
aAttribute
value
attrSet
needsAttrChange
)
;
size_t
index
=
mDelayedAttrChangeBroadcasts
.
IndexOf
(
delayedUpdate
0
nsDelayedBroadcastUpdate
:
:
Comparator
(
)
)
;
if
(
index
!
=
mDelayedAttrChangeBroadcasts
.
NoIndex
)
{
if
(
mHandlingDelayedAttrChange
)
{
NS_WARNING
(
"
Broadcasting
loop
!
"
)
;
continue
;
}
mDelayedAttrChangeBroadcasts
.
RemoveElementAt
(
index
)
;
}
mDelayedAttrChangeBroadcasts
.
AppendElement
(
delayedUpdate
)
;
}
}
}
}
}
bool
listener
resolved
;
CheckBroadcasterHookup
(
aElement
&
listener
&
resolved
)
;
nsAutoString
persist
;
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
persist
persist
)
;
if
(
ShouldPersistAttribute
(
aElement
aAttribute
)
&
&
!
persist
.
IsEmpty
(
)
&
&
persist
.
Find
(
nsDependentAtomString
(
aAttribute
)
)
>
=
0
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
<
Element
*
int32_t
nsAtom
*
>
(
"
dom
:
:
XULDocument
:
:
Persist
"
this
&
XULDocument
:
:
Persist
aElement
kNameSpaceID_None
aAttribute
)
)
;
}
}
void
XULDocument
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
NS_ASSERTION
(
aFirstNewContent
-
>
OwnerDoc
(
)
=
=
this
"
unexpected
doc
"
)
;
nsCOMPtr
<
nsIMutationObserver
>
kungFuDeathGrip
(
this
)
;
nsresult
rv
=
NS_OK
;
for
(
nsIContent
*
cur
=
aFirstNewContent
;
cur
&
&
NS_SUCCEEDED
(
rv
)
;
cur
=
cur
-
>
GetNextSibling
(
)
)
{
rv
=
AddSubtreeToDocument
(
cur
)
;
}
}
void
XULDocument
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
NS_ASSERTION
(
aChild
-
>
OwnerDoc
(
)
=
=
this
"
unexpected
doc
"
)
;
nsCOMPtr
<
nsIMutationObserver
>
kungFuDeathGrip
(
this
)
;
AddSubtreeToDocument
(
aChild
)
;
}
void
XULDocument
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
NS_ASSERTION
(
aChild
-
>
OwnerDoc
(
)
=
=
this
"
unexpected
doc
"
)
;
nsCOMPtr
<
nsIMutationObserver
>
kungFuDeathGrip
(
this
)
;
RemoveSubtreeFromDocument
(
aChild
)
;
}
nsresult
XULDocument
:
:
AddForwardReference
(
nsForwardReference
*
aRef
)
{
if
(
mResolutionPhase
<
aRef
-
>
GetPhase
(
)
)
{
if
(
!
mForwardReferences
.
AppendElement
(
aRef
)
)
{
delete
aRef
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
else
{
NS_ERROR
(
"
forward
references
have
already
been
resolved
"
)
;
delete
aRef
;
}
return
NS_OK
;
}
nsresult
XULDocument
:
:
ResolveForwardReferences
(
)
{
if
(
mResolutionPhase
=
=
nsForwardReference
:
:
eDone
)
return
NS_OK
;
NS_ASSERTION
(
mResolutionPhase
=
=
nsForwardReference
:
:
eStart
"
nested
ResolveForwardReferences
(
)
"
)
;
const
nsForwardReference
:
:
Phase
*
pass
=
nsForwardReference
:
:
kPasses
;
while
(
(
mResolutionPhase
=
*
pass
)
!
=
nsForwardReference
:
:
eDone
)
{
uint32_t
previous
=
0
;
while
(
mForwardReferences
.
Length
(
)
&
&
mForwardReferences
.
Length
(
)
!
=
previous
)
{
previous
=
mForwardReferences
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mForwardReferences
.
Length
(
)
;
+
+
i
)
{
nsForwardReference
*
fwdref
=
mForwardReferences
[
i
]
;
if
(
fwdref
-
>
GetPhase
(
)
=
=
*
pass
)
{
nsForwardReference
:
:
Result
result
=
fwdref
-
>
Resolve
(
)
;
switch
(
result
)
{
case
nsForwardReference
:
:
eResolve_Succeeded
:
case
nsForwardReference
:
:
eResolve_Error
:
mForwardReferences
.
RemoveElementAt
(
i
)
;
-
-
i
;
break
;
case
nsForwardReference
:
:
eResolve_Later
:
;
}
}
}
}
+
+
pass
;
}
mForwardReferences
.
Clear
(
)
;
return
NS_OK
;
}
void
XULDocument
:
:
Persist
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
)
{
if
(
!
nsContentUtils
:
:
IsSystemPrincipal
(
NodePrincipal
(
)
)
)
return
;
if
(
!
mLocalStore
)
{
mLocalStore
=
do_GetService
(
"
mozilla
.
org
/
xul
/
xulstore
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mLocalStore
)
)
{
return
;
}
}
nsAutoString
id
;
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
id
)
;
nsAtomString
attrstr
(
aAttribute
)
;
nsAutoString
valuestr
;
aElement
-
>
GetAttr
(
kNameSpaceID_None
aAttribute
valuestr
)
;
nsAutoCString
utf8uri
;
nsresult
rv
=
mDocumentURI
-
>
GetSpec
(
utf8uri
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
NS_ConvertUTF8toUTF16
uri
(
utf8uri
)
;
bool
hasAttr
;
rv
=
mLocalStore
-
>
HasValue
(
uri
id
attrstr
&
hasAttr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
hasAttr
&
&
valuestr
.
IsEmpty
(
)
)
{
mLocalStore
-
>
RemoveValue
(
uri
id
attrstr
)
;
return
;
}
if
(
aElement
-
>
IsXULElement
(
nsGkAtoms
:
:
window
)
)
{
if
(
nsCOMPtr
<
nsIXULWindow
>
win
=
GetXULWindowIfToplevelChrome
(
)
)
{
return
;
}
}
mLocalStore
-
>
SetValue
(
uri
id
attrstr
valuestr
)
;
}
nsresult
XULDocument
:
:
AddElementToDocumentPre
(
Element
*
aElement
)
{
nsresult
rv
;
nsAtom
*
id
=
aElement
-
>
GetID
(
)
;
if
(
id
)
{
nsAutoScriptBlocker
scriptBlocker
;
AddToIdTable
(
aElement
id
)
;
}
bool
listener
resolved
;
rv
=
CheckBroadcasterHookup
(
aElement
&
listener
&
resolved
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
listener
&
&
!
resolved
&
&
(
mResolutionPhase
!
=
nsForwardReference
:
:
eDone
)
)
{
BroadcasterHookup
*
hookup
=
new
BroadcasterHookup
(
this
aElement
)
;
rv
=
AddForwardReference
(
hookup
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
return
NS_OK
;
}
nsresult
XULDocument
:
:
AddElementToDocumentPost
(
Element
*
aElement
)
{
if
(
aElement
=
=
GetRootElement
(
)
)
{
ResetDocumentDirection
(
)
;
}
if
(
aElement
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
keyset
kNameSpaceID_XUL
)
)
{
nsXBLService
:
:
AttachGlobalKeyHandler
(
aElement
)
;
}
return
NS_OK
;
}
nsresult
XULDocument
:
:
AddSubtreeToDocument
(
nsIContent
*
aContent
)
{
NS_ASSERTION
(
aContent
-
>
GetUncomposedDoc
(
)
=
=
this
"
Element
not
in
doc
!
"
)
;
Element
*
aElement
=
Element
:
:
FromNode
(
aContent
)
;
if
(
!
aElement
)
{
return
NS_OK
;
}
nsresult
rv
=
AddElementToDocumentPre
(
aElement
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
for
(
nsIContent
*
child
=
aElement
-
>
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPreviousSibling
(
)
)
{
rv
=
AddSubtreeToDocument
(
child
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
return
AddElementToDocumentPost
(
aElement
)
;
}
nsresult
XULDocument
:
:
RemoveSubtreeFromDocument
(
nsIContent
*
aContent
)
{
Element
*
aElement
=
Element
:
:
FromNode
(
aContent
)
;
if
(
!
aElement
)
{
return
NS_OK
;
}
nsresult
rv
;
if
(
aElement
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
keyset
kNameSpaceID_XUL
)
)
{
nsXBLService
:
:
DetachGlobalKeyHandler
(
aElement
)
;
}
for
(
nsIContent
*
child
=
aElement
-
>
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPreviousSibling
(
)
)
{
rv
=
RemoveSubtreeFromDocument
(
child
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
nsAtom
*
id
=
aElement
-
>
GetID
(
)
;
if
(
id
)
{
nsAutoScriptBlocker
scriptBlocker
;
RemoveFromIdTable
(
aElement
id
)
;
}
nsCOMPtr
<
Element
>
broadcaster
listener
;
nsAutoString
attribute
broadcasterID
;
rv
=
FindBroadcaster
(
aElement
getter_AddRefs
(
listener
)
broadcasterID
attribute
getter_AddRefs
(
broadcaster
)
)
;
if
(
rv
=
=
NS_FINDBROADCASTER_FOUND
)
{
RemoveBroadcastListenerFor
(
*
broadcaster
*
listener
attribute
)
;
}
return
NS_OK
;
}
nsresult
XULDocument
:
:
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
)
const
{
*
aResult
=
nullptr
;
return
NS_ERROR_DOM_NOT_SUPPORTED_ERR
;
}
nsresult
XULDocument
:
:
Init
(
)
{
nsresult
rv
=
XMLDocument
:
:
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
gRefCnt
+
+
=
=
0
)
{
nsXULPrototypeCache
*
cache
=
nsXULPrototypeCache
:
:
GetInstance
(
)
;
if
(
!
cache
)
{
NS_ERROR
(
"
Could
not
instantiate
nsXULPrototypeCache
"
)
;
return
NS_ERROR_FAILURE
;
}
}
Preferences
:
:
RegisterCallback
(
XULDocument
:
:
DirectionChanged
"
intl
.
uidirection
"
this
)
;
return
NS_OK
;
}
nsresult
XULDocument
:
:
StartLayout
(
void
)
{
mMayStartLayout
=
true
;
nsCOMPtr
<
nsIPresShell
>
shell
=
GetShell
(
)
;
if
(
shell
)
{
nsPresContext
*
cx
=
shell
-
>
GetPresContext
(
)
;
NS_ASSERTION
(
cx
!
=
nullptr
"
no
pres
context
"
)
;
if
(
!
cx
)
return
NS_ERROR_UNEXPECTED
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
cx
-
>
GetDocShell
(
)
;
NS_ASSERTION
(
docShell
!
=
nullptr
"
container
is
not
a
docshell
"
)
;
if
(
!
docShell
)
return
NS_ERROR_UNEXPECTED
;
nsresult
rv
=
shell
-
>
Initialize
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
XULDocument
:
:
PrepareToLoadPrototype
(
nsIURI
*
aURI
const
char
*
aCommand
nsIPrincipal
*
aDocumentPrincipal
nsIParser
*
*
aResult
)
{
nsresult
rv
;
rv
=
NS_NewXULPrototypeDocument
(
getter_AddRefs
(
mCurrentPrototype
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
mCurrentPrototype
-
>
InitPrincipal
(
aURI
aDocumentPrincipal
)
;
if
(
NS_FAILED
(
rv
)
)
{
mCurrentPrototype
=
nullptr
;
return
rv
;
}
SetPrincipal
(
aDocumentPrincipal
)
;
RefPtr
<
XULContentSinkImpl
>
sink
=
new
XULContentSinkImpl
(
)
;
rv
=
sink
-
>
Init
(
this
mCurrentPrototype
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Unable
to
initialize
datasource
sink
"
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsCOMPtr
<
nsIParser
>
parser
=
do_CreateInstance
(
kParserCID
&
rv
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
unable
to
create
parser
"
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
parser
-
>
SetCommand
(
nsCRT
:
:
strcmp
(
aCommand
"
view
-
source
"
)
?
eViewNormal
:
eViewSource
)
;
parser
-
>
SetDocumentCharset
(
UTF_8_ENCODING
kCharsetFromDocTypeDefault
)
;
parser
-
>
SetContentSink
(
sink
)
;
parser
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsresult
XULDocument
:
:
ApplyPersistentAttributes
(
)
{
if
(
!
nsContentUtils
:
:
IsSystemPrincipal
(
NodePrincipal
(
)
)
)
return
NS_ERROR_NOT_AVAILABLE
;
if
(
!
mLocalStore
)
{
mLocalStore
=
do_GetService
(
"
mozilla
.
org
/
xul
/
xulstore
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mLocalStore
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
}
mApplyingPersistedAttrs
=
true
;
ApplyPersistentAttributesInternal
(
)
;
mApplyingPersistedAttrs
=
false
;
return
NS_OK
;
}
nsresult
XULDocument
:
:
ApplyPersistentAttributesInternal
(
)
{
nsCOMArray
<
Element
>
elements
;
nsAutoCString
utf8uri
;
nsresult
rv
=
mDocumentURI
-
>
GetSpec
(
utf8uri
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
NS_ConvertUTF8toUTF16
uri
(
utf8uri
)
;
nsCOMPtr
<
nsIStringEnumerator
>
ids
;
rv
=
mLocalStore
-
>
GetIDsEnumerator
(
uri
getter_AddRefs
(
ids
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
while
(
1
)
{
bool
hasmore
=
false
;
ids
-
>
HasMore
(
&
hasmore
)
;
if
(
!
hasmore
)
{
break
;
}
nsAutoString
id
;
ids
-
>
GetNext
(
id
)
;
nsIdentifierMapEntry
*
entry
=
mIdentifierMap
.
GetEntry
(
id
)
;
if
(
!
entry
)
{
continue
;
}
elements
.
Clear
(
)
;
elements
.
SetCapacity
(
entry
-
>
GetIdElements
(
)
.
Length
(
)
)
;
for
(
Element
*
element
:
entry
-
>
GetIdElements
(
)
)
{
elements
.
AppendObject
(
element
)
;
}
if
(
elements
.
IsEmpty
(
)
)
{
continue
;
}
rv
=
ApplyPersistentAttributesToElements
(
id
elements
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
XULDocument
:
:
ApplyPersistentAttributesToElements
(
const
nsAString
&
aID
nsCOMArray
<
Element
>
&
aElements
)
{
nsAutoCString
utf8uri
;
nsresult
rv
=
mDocumentURI
-
>
GetSpec
(
utf8uri
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
NS_ConvertUTF8toUTF16
uri
(
utf8uri
)
;
nsCOMPtr
<
nsIStringEnumerator
>
attrs
;
rv
=
mLocalStore
-
>
GetAttributeEnumerator
(
uri
aID
getter_AddRefs
(
attrs
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
while
(
1
)
{
bool
hasmore
=
PR_FALSE
;
attrs
-
>
HasMore
(
&
hasmore
)
;
if
(
!
hasmore
)
{
break
;
}
nsAutoString
attrstr
;
attrs
-
>
GetNext
(
attrstr
)
;
nsAutoString
value
;
rv
=
mLocalStore
-
>
GetValue
(
uri
aID
attrstr
value
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
RefPtr
<
nsAtom
>
attr
=
NS_Atomize
(
attrstr
)
;
if
(
NS_WARN_IF
(
!
attr
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
uint32_t
cnt
=
aElements
.
Count
(
)
;
for
(
int32_t
i
=
int32_t
(
cnt
)
-
1
;
i
>
=
0
;
-
-
i
)
{
RefPtr
<
Element
>
element
=
aElements
.
SafeObjectAt
(
i
)
;
if
(
!
element
)
{
continue
;
}
if
(
element
-
>
IsXULElement
(
nsGkAtoms
:
:
window
)
)
{
if
(
nsCOMPtr
<
nsIXULWindow
>
win
=
GetXULWindowIfToplevelChrome
(
)
)
{
continue
;
}
}
Unused
<
<
element
-
>
SetAttr
(
kNameSpaceID_None
attr
value
true
)
;
}
}
return
NS_OK
;
}
void
XULDocument
:
:
TraceProtos
(
JSTracer
*
aTrc
)
{
uint32_t
i
count
=
mPrototypes
.
Length
(
)
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
mPrototypes
[
i
]
-
>
TraceProtos
(
aTrc
)
;
}
if
(
mCurrentPrototype
)
{
mCurrentPrototype
-
>
TraceProtos
(
aTrc
)
;
}
}
XULDocument
:
:
ContextStack
:
:
ContextStack
(
)
:
mTop
(
nullptr
)
mDepth
(
0
)
{
}
XULDocument
:
:
ContextStack
:
:
~
ContextStack
(
)
{
while
(
mTop
)
{
Entry
*
doomed
=
mTop
;
mTop
=
mTop
-
>
mNext
;
NS_IF_RELEASE
(
doomed
-
>
mElement
)
;
delete
doomed
;
}
}
nsresult
XULDocument
:
:
ContextStack
:
:
Push
(
nsXULPrototypeElement
*
aPrototype
nsIContent
*
aElement
)
{
Entry
*
entry
=
new
Entry
;
entry
-
>
mPrototype
=
aPrototype
;
entry
-
>
mElement
=
aElement
;
NS_IF_ADDREF
(
entry
-
>
mElement
)
;
entry
-
>
mIndex
=
0
;
entry
-
>
mNext
=
mTop
;
mTop
=
entry
;
+
+
mDepth
;
return
NS_OK
;
}
nsresult
XULDocument
:
:
ContextStack
:
:
Pop
(
)
{
if
(
mDepth
=
=
0
)
return
NS_ERROR_UNEXPECTED
;
Entry
*
doomed
=
mTop
;
mTop
=
mTop
-
>
mNext
;
-
-
mDepth
;
NS_IF_RELEASE
(
doomed
-
>
mElement
)
;
delete
doomed
;
return
NS_OK
;
}
nsresult
XULDocument
:
:
ContextStack
:
:
Peek
(
nsXULPrototypeElement
*
*
aPrototype
nsIContent
*
*
aElement
int32_t
*
aIndex
)
{
if
(
mDepth
=
=
0
)
return
NS_ERROR_UNEXPECTED
;
*
aPrototype
=
mTop
-
>
mPrototype
;
*
aElement
=
mTop
-
>
mElement
;
NS_IF_ADDREF
(
*
aElement
)
;
*
aIndex
=
mTop
-
>
mIndex
;
return
NS_OK
;
}
nsresult
XULDocument
:
:
ContextStack
:
:
SetTopIndex
(
int32_t
aIndex
)
{
if
(
mDepth
=
=
0
)
return
NS_ERROR_UNEXPECTED
;
mTop
-
>
mIndex
=
aIndex
;
return
NS_OK
;
}
nsresult
XULDocument
:
:
PrepareToWalk
(
)
{
nsresult
rv
;
mPrototypes
.
AppendElement
(
mCurrentPrototype
)
;
nsXULPrototypeElement
*
proto
=
mCurrentPrototype
-
>
GetRootElement
(
)
;
if
(
!
proto
)
{
if
(
MOZ_LOG_TEST
(
gXULLog
LogLevel
:
:
Error
)
)
{
nsCOMPtr
<
nsIURI
>
url
=
mCurrentPrototype
-
>
GetURI
(
)
;
nsAutoCString
urlspec
;
rv
=
url
-
>
GetSpec
(
urlspec
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
MOZ_LOG
(
gXULLog
LogLevel
:
:
Error
(
"
xul
:
error
parsing
'
%
s
'
"
urlspec
.
get
(
)
)
)
;
}
return
NS_OK
;
}
nsINode
*
nodeToInsertBefore
=
nsINode
:
:
GetFirstChild
(
)
;
const
nsTArray
<
RefPtr
<
nsXULPrototypePI
>
>
&
processingInstructions
=
mCurrentPrototype
-
>
GetProcessingInstructions
(
)
;
uint32_t
total
=
processingInstructions
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
total
;
+
+
i
)
{
rv
=
CreateAndInsertPI
(
processingInstructions
[
i
]
this
nodeToInsertBefore
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
RefPtr
<
Element
>
root
;
rv
=
CreateElementFromPrototype
(
proto
getter_AddRefs
(
root
)
true
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
AppendChildTo
(
root
false
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
BlockOnload
(
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
nsDocElementCreatedNotificationRunner
(
this
)
)
;
NS_ASSERTION
(
mContextStack
.
Depth
(
)
=
=
0
"
something
'
s
on
the
context
stack
already
"
)
;
if
(
mContextStack
.
Depth
(
)
!
=
0
)
return
NS_ERROR_UNEXPECTED
;
rv
=
mContextStack
.
Push
(
proto
root
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
NS_OK
;
}
nsresult
XULDocument
:
:
CreateAndInsertPI
(
const
nsXULPrototypePI
*
aProtoPI
nsINode
*
aParent
nsINode
*
aBeforeThis
)
{
MOZ_ASSERT
(
aProtoPI
"
null
ptr
"
)
;
MOZ_ASSERT
(
aParent
"
null
ptr
"
)
;
RefPtr
<
ProcessingInstruction
>
node
=
NS_NewXMLProcessingInstruction
(
mNodeInfoManager
aProtoPI
-
>
mTarget
aProtoPI
-
>
mData
)
;
nsresult
rv
;
if
(
aProtoPI
-
>
mTarget
.
EqualsLiteral
(
"
xml
-
stylesheet
"
)
)
{
rv
=
InsertXMLStylesheetPI
(
aProtoPI
aParent
aBeforeThis
node
)
;
}
else
{
rv
=
aParent
-
>
InsertChildBefore
(
node
-
>
AsContent
(
)
aBeforeThis
?
aBeforeThis
-
>
AsContent
(
)
:
nullptr
false
)
;
}
return
rv
;
}
nsresult
XULDocument
:
:
InsertXMLStylesheetPI
(
const
nsXULPrototypePI
*
aProtoPI
nsINode
*
aParent
nsINode
*
aBeforeThis
nsIContent
*
aPINode
)
{
nsCOMPtr
<
nsIStyleSheetLinkingElement
>
ssle
(
do_QueryInterface
(
aPINode
)
)
;
NS_ASSERTION
(
ssle
"
passed
XML
Stylesheet
node
does
not
"
"
implement
nsIStyleSheetLinkingElement
!
"
)
;
nsresult
rv
;
ssle
-
>
InitStyleLinkElement
(
false
)
;
ssle
-
>
SetEnableUpdates
(
false
)
;
ssle
-
>
OverrideBaseURI
(
mCurrentPrototype
-
>
GetURI
(
)
)
;
rv
=
aParent
-
>
InsertChildBefore
(
aPINode
-
>
AsContent
(
)
aBeforeThis
?
aBeforeThis
-
>
AsContent
(
)
:
nullptr
false
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
ssle
-
>
SetEnableUpdates
(
true
)
;
auto
result
=
ssle
-
>
UpdateStyleSheet
(
this
)
;
if
(
result
.
isErr
(
)
)
{
if
(
result
.
unwrapErr
(
)
=
=
NS_ERROR_OUT_OF_MEMORY
)
{
return
result
.
unwrapErr
(
)
;
}
return
NS_OK
;
}
auto
update
=
result
.
unwrap
(
)
;
if
(
update
.
ShouldBlock
(
)
)
{
+
+
mPendingSheets
;
}
return
NS_OK
;
}
nsresult
XULDocument
:
:
ResumeWalk
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
docURI
=
mCurrentPrototype
?
mCurrentPrototype
-
>
GetURI
(
)
:
nullptr
;
while
(
1
)
{
while
(
mContextStack
.
Depth
(
)
>
0
)
{
nsXULPrototypeElement
*
proto
;
nsCOMPtr
<
nsIContent
>
element
;
int32_t
indx
;
rv
=
mContextStack
.
Peek
(
&
proto
getter_AddRefs
(
element
)
&
indx
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
indx
>
=
(
int32_t
)
proto
-
>
mChildren
.
Length
(
)
)
{
if
(
element
)
{
AddElementToDocumentPost
(
element
-
>
AsElement
(
)
)
;
if
(
element
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
style
kNameSpaceID_XHTML
)
|
|
element
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
style
kNameSpaceID_SVG
)
)
{
nsCOMPtr
<
nsIStyleSheetLinkingElement
>
ssle
=
do_QueryInterface
(
element
)
;
NS_ASSERTION
(
ssle
"
<
html
:
style
>
doesn
'
t
implement
"
"
nsIStyleSheetLinkingElement
?
"
)
;
Unused
<
<
ssle
-
>
UpdateStyleSheet
(
nullptr
)
;
}
}
mContextStack
.
Pop
(
)
;
continue
;
}
nsXULPrototypeNode
*
childproto
=
proto
-
>
mChildren
[
indx
]
;
mContextStack
.
SetTopIndex
(
+
+
indx
)
;
NS_ASSERTION
(
element
"
no
element
on
context
stack
"
)
;
switch
(
childproto
-
>
mType
)
{
case
nsXULPrototypeNode
:
:
eType_Element
:
{
nsXULPrototypeElement
*
protoele
=
static_cast
<
nsXULPrototypeElement
*
>
(
childproto
)
;
RefPtr
<
Element
>
child
;
rv
=
CreateElementFromPrototype
(
protoele
getter_AddRefs
(
child
)
false
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
element
-
>
AppendChildTo
(
child
false
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
AddElementToDocumentPre
(
child
)
;
if
(
protoele
-
>
mChildren
.
Length
(
)
>
0
)
{
rv
=
mContextStack
.
Push
(
protoele
child
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
else
{
AddElementToDocumentPost
(
child
)
;
}
}
break
;
case
nsXULPrototypeNode
:
:
eType_Script
:
{
nsXULPrototypeScript
*
scriptproto
=
static_cast
<
nsXULPrototypeScript
*
>
(
childproto
)
;
if
(
scriptproto
-
>
mSrcURI
)
{
bool
blocked
;
rv
=
LoadScript
(
scriptproto
&
blocked
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
blocked
)
return
NS_OK
;
}
else
if
(
scriptproto
-
>
HasScriptObject
(
)
)
{
rv
=
ExecuteScript
(
scriptproto
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
}
break
;
case
nsXULPrototypeNode
:
:
eType_Text
:
{
RefPtr
<
nsTextNode
>
text
=
new
nsTextNode
(
mNodeInfoManager
)
;
nsXULPrototypeText
*
textproto
=
static_cast
<
nsXULPrototypeText
*
>
(
childproto
)
;
text
-
>
SetText
(
textproto
-
>
mValue
false
)
;
rv
=
element
-
>
AppendChildTo
(
text
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
break
;
case
nsXULPrototypeNode
:
:
eType_PI
:
{
nsXULPrototypePI
*
piProto
=
static_cast
<
nsXULPrototypePI
*
>
(
childproto
)
;
if
(
piProto
-
>
mTarget
.
EqualsLiteral
(
"
xml
-
stylesheet
"
)
)
{
const
char16_t
*
params
[
]
=
{
piProto
-
>
mTarget
.
get
(
)
}
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
XUL
Document
"
)
nullptr
nsContentUtils
:
:
eXUL_PROPERTIES
"
PINotInProlog
"
params
ArrayLength
(
params
)
docURI
)
;
}
nsIContent
*
parent
=
element
.
get
(
)
;
if
(
parent
)
{
rv
=
CreateAndInsertPI
(
piProto
parent
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
nsXULPrototypeNode
:
:
Type
"
)
;
}
}
break
;
}
rv
=
ResolveForwardReferences
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
ApplyPersistentAttributes
(
)
;
mStillWalking
=
false
;
if
(
mPendingSheets
=
=
0
)
{
rv
=
DoneWalking
(
)
;
}
return
rv
;
}
nsresult
XULDocument
:
:
DoneWalking
(
)
{
MOZ_ASSERT
(
mPendingSheets
=
=
0
"
there
are
sheets
to
be
loaded
"
)
;
MOZ_ASSERT
(
!
mStillWalking
"
walk
not
done
"
)
;
if
(
!
mDocumentLoaded
)
{
mDocumentLoaded
=
true
;
NotifyPossibleTitleChange
(
false
)
;
nsContentUtils
:
:
DispatchTrustedEvent
(
this
static_cast
<
nsIDocument
*
>
(
this
)
NS_LITERAL_STRING
(
"
MozBeforeInitialXULLayout
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
if
(
nsCOMPtr
<
nsIXULWindow
>
win
=
GetXULWindowIfToplevelChrome
(
)
)
{
win
-
>
BeforeStartLayout
(
)
;
}
StartLayout
(
)
;
if
(
mIsWritingFastLoad
&
&
IsChromeURI
(
mDocumentURI
)
)
nsXULPrototypeCache
:
:
GetInstance
(
)
-
>
WritePrototype
(
mCurrentPrototype
)
;
NS_ASSERTION
(
mDelayFrameLoaderInitialization
"
mDelayFrameLoaderInitialization
should
be
true
!
"
)
;
mDelayFrameLoaderInitialization
=
false
;
NS_WARNING_ASSERTION
(
mUpdateNestLevel
=
=
0
"
Constructing
XUL
document
in
middle
of
an
update
?
"
)
;
if
(
mUpdateNestLevel
=
=
0
)
{
MaybeInitializeFinalizeFrameLoaders
(
)
;
}
NS_DOCUMENT_NOTIFY_OBSERVERS
(
EndLoad
(
this
)
)
;
DispatchContentLoadedEvents
(
)
;
mInitialLayoutComplete
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
XULDocument
:
:
StyleSheetLoaded
(
StyleSheet
*
aSheet
bool
aWasDeferred
nsresult
aStatus
)
{
if
(
!
aWasDeferred
)
{
MOZ_ASSERT
(
mPendingSheets
>
0
"
Unexpected
StyleSheetLoaded
notification
"
)
;
-
-
mPendingSheets
;
if
(
!
mStillWalking
&
&
mPendingSheets
=
=
0
)
{
return
DoneWalking
(
)
;
}
}
return
NS_OK
;
}
void
XULDocument
:
:
MaybeBroadcast
(
)
{
if
(
mUpdateNestLevel
=
=
0
&
&
(
mDelayedAttrChangeBroadcasts
.
Length
(
)
|
|
mDelayedBroadcasters
.
Length
(
)
)
)
{
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
if
(
!
mInDestructor
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
dom
:
:
XULDocument
:
:
MaybeBroadcast
"
this
&
XULDocument
:
:
MaybeBroadcast
)
)
;
}
return
;
}
if
(
!
mHandlingDelayedAttrChange
)
{
mHandlingDelayedAttrChange
=
true
;
for
(
uint32_t
i
=
0
;
i
<
mDelayedAttrChangeBroadcasts
.
Length
(
)
;
+
+
i
)
{
nsAtom
*
attrName
=
mDelayedAttrChangeBroadcasts
[
i
]
.
mAttrName
;
if
(
mDelayedAttrChangeBroadcasts
[
i
]
.
mNeedsAttrChange
)
{
nsCOMPtr
<
Element
>
listener
=
do_QueryInterface
(
mDelayedAttrChangeBroadcasts
[
i
]
.
mListener
)
;
const
nsString
&
value
=
mDelayedAttrChangeBroadcasts
[
i
]
.
mAttr
;
if
(
mDelayedAttrChangeBroadcasts
[
i
]
.
mSetAttr
)
{
listener
-
>
SetAttr
(
kNameSpaceID_None
attrName
value
true
)
;
}
else
{
listener
-
>
UnsetAttr
(
kNameSpaceID_None
attrName
true
)
;
}
}
ExecuteOnBroadcastHandlerFor
(
mDelayedAttrChangeBroadcasts
[
i
]
.
mBroadcaster
mDelayedAttrChangeBroadcasts
[
i
]
.
mListener
attrName
)
;
}
mDelayedAttrChangeBroadcasts
.
Clear
(
)
;
mHandlingDelayedAttrChange
=
false
;
}
uint32_t
length
=
mDelayedBroadcasters
.
Length
(
)
;
if
(
length
)
{
bool
oldValue
=
mHandlingDelayedBroadcasters
;
mHandlingDelayedBroadcasters
=
true
;
nsTArray
<
nsDelayedBroadcastUpdate
>
delayedBroadcasters
;
mDelayedBroadcasters
.
SwapElements
(
delayedBroadcasters
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
SynchronizeBroadcastListener
(
delayedBroadcasters
[
i
]
.
mBroadcaster
delayedBroadcasters
[
i
]
.
mListener
delayedBroadcasters
[
i
]
.
mAttr
)
;
}
mHandlingDelayedBroadcasters
=
oldValue
;
}
}
}
void
XULDocument
:
:
EndUpdate
(
)
{
XMLDocument
:
:
EndUpdate
(
)
;
MaybeBroadcast
(
)
;
}
nsresult
XULDocument
:
:
LoadScript
(
nsXULPrototypeScript
*
aScriptProto
bool
*
aBlock
)
{
nsresult
rv
;
bool
isChromeDoc
=
IsChromeURI
(
mDocumentURI
)
;
if
(
isChromeDoc
&
&
aScriptProto
-
>
HasScriptObject
(
)
)
{
rv
=
ExecuteScript
(
aScriptProto
)
;
*
aBlock
=
false
;
return
NS_OK
;
}
bool
useXULCache
=
nsXULPrototypeCache
:
:
GetInstance
(
)
-
>
IsEnabled
(
)
;
if
(
isChromeDoc
&
&
useXULCache
)
{
JSScript
*
newScriptObject
=
nsXULPrototypeCache
:
:
GetInstance
(
)
-
>
GetScript
(
aScriptProto
-
>
mSrcURI
)
;
if
(
newScriptObject
)
{
aScriptProto
-
>
Set
(
newScriptObject
)
;
}
if
(
aScriptProto
-
>
HasScriptObject
(
)
)
{
rv
=
ExecuteScript
(
aScriptProto
)
;
*
aBlock
=
false
;
return
NS_OK
;
}
}
aScriptProto
-
>
UnlinkJSObjects
(
)
;
NS_ASSERTION
(
!
mCurrentScriptProto
"
still
loading
a
script
when
starting
another
load
?
"
)
;
mCurrentScriptProto
=
aScriptProto
;
if
(
isChromeDoc
&
&
aScriptProto
-
>
mSrcLoading
)
{
mNextSrcLoadWaiter
=
aScriptProto
-
>
mSrcLoadWaiters
;
aScriptProto
-
>
mSrcLoadWaiters
=
this
;
NS_ADDREF_THIS
(
)
;
}
else
{
nsCOMPtr
<
nsILoadGroup
>
group
=
do_QueryReferent
(
mDocumentLoadGroup
)
;
nsCOMPtr
<
nsIStreamLoader
>
loader
;
rv
=
NS_NewStreamLoader
(
getter_AddRefs
(
loader
)
aScriptProto
-
>
mSrcURI
this
this
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
group
)
;
if
(
NS_FAILED
(
rv
)
)
{
mCurrentScriptProto
=
nullptr
;
return
rv
;
}
aScriptProto
-
>
mSrcLoading
=
true
;
}
*
aBlock
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
XULDocument
:
:
OnStreamComplete
(
nsIStreamLoader
*
aLoader
nsISupports
*
context
nsresult
aStatus
uint32_t
stringLen
const
uint8_t
*
string
)
{
nsCOMPtr
<
nsIRequest
>
request
;
aLoader
-
>
GetRequest
(
getter_AddRefs
(
request
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
request
)
;
#
ifdef
DEBUG
if
(
NS_FAILED
(
aStatus
)
)
{
if
(
channel
)
{
nsCOMPtr
<
nsIURI
>
uri
;
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
uri
)
{
printf
(
"
Failed
to
load
%
s
\
n
"
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
;
}
}
}
#
endif
nsresult
rv
=
aStatus
;
NS_ASSERTION
(
mCurrentScriptProto
&
&
mCurrentScriptProto
-
>
mSrcLoading
"
script
source
not
loading
on
unichar
stream
complete
?
"
)
;
if
(
!
mCurrentScriptProto
)
{
return
NS_OK
;
}
if
(
NS_SUCCEEDED
(
aStatus
)
)
{
nsCOMPtr
<
nsIURI
>
uri
=
mCurrentScriptProto
-
>
mSrcURI
;
MOZ_ASSERT
(
!
mOffThreadCompiling
&
&
(
mOffThreadCompileStringLength
=
=
0
&
&
!
mOffThreadCompileStringBuf
)
"
XULDocument
can
'
t
load
multiple
scripts
at
once
"
)
;
rv
=
ScriptLoader
:
:
ConvertToUTF16
(
channel
string
stringLen
EmptyString
(
)
this
mOffThreadCompileStringBuf
mOffThreadCompileStringLength
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
JS
:
:
SourceBufferHolder
srcBuf
(
mOffThreadCompileStringBuf
mOffThreadCompileStringLength
JS
:
:
SourceBufferHolder
:
:
GiveOwnership
)
;
mOffThreadCompileStringBuf
=
nullptr
;
mOffThreadCompileStringLength
=
0
;
rv
=
mCurrentScriptProto
-
>
Compile
(
srcBuf
uri
1
this
this
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
mCurrentScriptProto
-
>
HasScriptObject
(
)
)
{
MOZ_RELEASE_ASSERT
(
!
srcBuf
.
ownsChars
(
)
)
;
mOffThreadCompiling
=
true
;
BlockOnload
(
)
;
return
NS_OK
;
}
}
}
return
OnScriptCompileComplete
(
mCurrentScriptProto
-
>
GetScriptObject
(
)
rv
)
;
}
NS_IMETHODIMP
XULDocument
:
:
OnScriptCompileComplete
(
JSScript
*
aScript
nsresult
aStatus
)
{
if
(
aScript
&
&
!
mCurrentScriptProto
-
>
HasScriptObject
(
)
)
mCurrentScriptProto
-
>
Set
(
aScript
)
;
if
(
mOffThreadCompiling
)
{
mOffThreadCompiling
=
false
;
UnblockOnload
(
false
)
;
}
if
(
mOffThreadCompileStringBuf
)
{
js_free
(
mOffThreadCompileStringBuf
)
;
mOffThreadCompileStringBuf
=
nullptr
;
mOffThreadCompileStringLength
=
0
;
}
nsXULPrototypeScript
*
scriptProto
=
mCurrentScriptProto
;
mCurrentScriptProto
=
nullptr
;
scriptProto
-
>
mSrcLoading
=
false
;
nsresult
rv
=
aStatus
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
ExecuteScript
(
scriptProto
)
;
bool
useXULCache
=
nsXULPrototypeCache
:
:
GetInstance
(
)
-
>
IsEnabled
(
)
;
if
(
useXULCache
&
&
IsChromeURI
(
mDocumentURI
)
&
&
scriptProto
-
>
HasScriptObject
(
)
)
{
JS
:
:
Rooted
<
JSScript
*
>
script
(
RootingCx
(
)
scriptProto
-
>
GetScriptObject
(
)
)
;
nsXULPrototypeCache
:
:
GetInstance
(
)
-
>
PutScript
(
scriptProto
-
>
mSrcURI
script
)
;
}
}
rv
=
ResumeWalk
(
)
;
XULDocument
*
*
docp
=
&
scriptProto
-
>
mSrcLoadWaiters
;
XULDocument
*
doc
;
while
(
(
doc
=
*
docp
)
!
=
nullptr
)
{
NS_ASSERTION
(
doc
-
>
mCurrentScriptProto
=
=
scriptProto
"
waiting
for
wrong
script
to
load
?
"
)
;
doc
-
>
mCurrentScriptProto
=
nullptr
;
*
docp
=
doc
-
>
mNextSrcLoadWaiter
;
doc
-
>
mNextSrcLoadWaiter
=
nullptr
;
if
(
aStatus
=
=
NS_BINDING_ABORTED
&
&
!
scriptProto
-
>
HasScriptObject
(
)
)
{
bool
block
=
false
;
doc
-
>
LoadScript
(
scriptProto
&
block
)
;
NS_RELEASE
(
doc
)
;
return
rv
;
}
if
(
NS_SUCCEEDED
(
aStatus
)
&
&
scriptProto
-
>
HasScriptObject
(
)
)
{
doc
-
>
ExecuteScript
(
scriptProto
)
;
}
doc
-
>
ResumeWalk
(
)
;
NS_RELEASE
(
doc
)
;
}
return
rv
;
}
nsresult
XULDocument
:
:
ExecuteScript
(
nsXULPrototypeScript
*
aScript
)
{
MOZ_ASSERT
(
aScript
!
=
nullptr
"
null
ptr
"
)
;
NS_ENSURE_TRUE
(
aScript
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
mScriptGlobalObject
NS_ERROR_NOT_INITIALIZED
)
;
nsresult
rv
;
rv
=
mScriptGlobalObject
-
>
EnsureScriptEnvironment
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoMicroTask
mt
;
AutoEntryScript
aes
(
mScriptGlobalObject
"
precompiled
XUL
<
script
>
element
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JS
:
:
Rooted
<
JSScript
*
>
scriptObject
(
cx
aScript
-
>
GetScriptObject
(
)
)
;
NS_ENSURE_TRUE
(
scriptObject
NS_ERROR_UNEXPECTED
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
NS_ENSURE_TRUE
(
xpc
:
:
Scriptability
:
:
Get
(
global
)
.
Allowed
(
)
NS_OK
)
;
JS
:
:
ExposeObjectToActiveJS
(
global
)
;
JSAutoRealm
ar
(
cx
global
)
;
JS
:
:
RootedValue
rval
(
cx
)
;
JS
:
:
CloneAndExecuteScript
(
cx
scriptObject
&
rval
)
;
return
NS_OK
;
}
nsresult
XULDocument
:
:
CreateElementFromPrototype
(
nsXULPrototypeElement
*
aPrototype
Element
*
*
aResult
bool
aIsRoot
)
{
MOZ_ASSERT
(
aPrototype
!
=
nullptr
"
null
ptr
"
)
;
if
(
!
aPrototype
)
return
NS_ERROR_NULL_POINTER
;
*
aResult
=
nullptr
;
nsresult
rv
=
NS_OK
;
if
(
MOZ_LOG_TEST
(
gXULLog
LogLevel
:
:
Debug
)
)
{
MOZ_LOG
(
gXULLog
LogLevel
:
:
Debug
(
"
xul
:
creating
<
%
s
>
from
prototype
"
NS_ConvertUTF16toUTF8
(
aPrototype
-
>
mNodeInfo
-
>
QualifiedName
(
)
)
.
get
(
)
)
)
;
}
RefPtr
<
Element
>
result
;
if
(
aPrototype
-
>
mNodeInfo
-
>
NamespaceEquals
(
kNameSpaceID_XUL
)
)
{
rv
=
nsXULElement
:
:
CreateFromPrototype
(
aPrototype
this
true
aIsRoot
getter_AddRefs
(
result
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
else
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
newNodeInfo
;
newNodeInfo
=
mNodeInfoManager
-
>
GetNodeInfo
(
aPrototype
-
>
mNodeInfo
-
>
NameAtom
(
)
aPrototype
-
>
mNodeInfo
-
>
GetPrefixAtom
(
)
aPrototype
-
>
mNodeInfo
-
>
NamespaceID
(
)
ELEMENT_NODE
)
;
if
(
!
newNodeInfo
)
return
NS_ERROR_OUT_OF_MEMORY
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
xtfNi
=
newNodeInfo
;
rv
=
NS_NewElement
(
getter_AddRefs
(
result
)
newNodeInfo
.
forget
(
)
NOT_FROM_PARSER
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
AddAttributes
(
aPrototype
result
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
result
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsresult
XULDocument
:
:
AddAttributes
(
nsXULPrototypeElement
*
aPrototype
Element
*
aElement
)
{
nsresult
rv
;
for
(
uint32_t
i
=
0
;
i
<
aPrototype
-
>
mNumAttributes
;
+
+
i
)
{
nsXULPrototypeAttribute
*
protoattr
=
&
(
aPrototype
-
>
mAttributes
[
i
]
)
;
nsAutoString
valueStr
;
protoattr
-
>
mValue
.
ToString
(
valueStr
)
;
rv
=
aElement
-
>
SetAttr
(
protoattr
-
>
mName
.
NamespaceID
(
)
protoattr
-
>
mName
.
LocalName
(
)
protoattr
-
>
mName
.
GetPrefix
(
)
valueStr
false
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
return
NS_OK
;
}
nsForwardReference
:
:
Result
XULDocument
:
:
BroadcasterHookup
:
:
Resolve
(
)
{
nsresult
rv
;
bool
listener
;
rv
=
mDocument
-
>
CheckBroadcasterHookup
(
mObservesElement
&
listener
&
mResolved
)
;
if
(
NS_FAILED
(
rv
)
)
return
eResolve_Error
;
return
mResolved
?
eResolve_Succeeded
:
eResolve_Later
;
}
XULDocument
:
:
BroadcasterHookup
:
:
~
BroadcasterHookup
(
)
{
if
(
MOZ_LOG_TEST
(
gXULLog
LogLevel
:
:
Warning
)
&
&
!
mResolved
)
{
nsAutoString
broadcasterID
;
nsAutoString
attribute
;
if
(
mObservesElement
-
>
IsXULElement
(
nsGkAtoms
:
:
observes
)
)
{
mObservesElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
element
broadcasterID
)
;
mObservesElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
attribute
attribute
)
;
}
else
{
mObservesElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
observes
broadcasterID
)
;
attribute
.
Assign
(
'
*
'
)
;
}
nsAutoCString
attributeC
broadcasteridC
;
LossyCopyUTF16toASCII
(
attribute
attributeC
)
;
LossyCopyUTF16toASCII
(
broadcasterID
broadcasteridC
)
;
MOZ_LOG
(
gXULLog
LogLevel
:
:
Warning
(
"
xul
:
broadcaster
hookup
failed
<
%
s
attribute
=
'
%
s
'
>
to
%
s
"
nsAtomCString
(
mObservesElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
.
get
(
)
attributeC
.
get
(
)
broadcasteridC
.
get
(
)
)
)
;
}
}
nsresult
XULDocument
:
:
FindBroadcaster
(
Element
*
aElement
Element
*
*
aListener
nsString
&
aBroadcasterID
nsString
&
aAttribute
Element
*
*
aBroadcaster
)
{
mozilla
:
:
dom
:
:
NodeInfo
*
ni
=
aElement
-
>
NodeInfo
(
)
;
*
aListener
=
nullptr
;
*
aBroadcaster
=
nullptr
;
if
(
ni
-
>
Equals
(
nsGkAtoms
:
:
observes
kNameSpaceID_XUL
)
)
{
nsIContent
*
parent
=
aElement
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
NS_FINDBROADCASTER_NOT_FOUND
;
}
*
aListener
=
Element
:
:
FromNode
(
parent
)
;
NS_IF_ADDREF
(
*
aListener
)
;
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
element
aBroadcasterID
)
;
if
(
aBroadcasterID
.
IsEmpty
(
)
)
{
return
NS_FINDBROADCASTER_NOT_FOUND
;
}
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
attribute
aAttribute
)
;
}
else
{
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
observes
aBroadcasterID
)
;
if
(
aBroadcasterID
.
IsEmpty
(
)
)
{
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
command
aBroadcasterID
)
;
if
(
!
aBroadcasterID
.
IsEmpty
(
)
)
{
if
(
ni
-
>
Equals
(
nsGkAtoms
:
:
menuitem
kNameSpaceID_XUL
)
|
|
ni
-
>
Equals
(
nsGkAtoms
:
:
key
kNameSpaceID_XUL
)
)
{
return
NS_FINDBROADCASTER_NOT_FOUND
;
}
}
else
{
return
NS_FINDBROADCASTER_NOT_FOUND
;
}
}
*
aListener
=
aElement
;
NS_ADDREF
(
*
aListener
)
;
aAttribute
.
Assign
(
'
*
'
)
;
}
NS_ENSURE_TRUE
(
*
aListener
NS_ERROR_UNEXPECTED
)
;
*
aBroadcaster
=
GetElementById
(
aBroadcasterID
)
;
if
(
!
*
aBroadcaster
)
{
return
NS_FINDBROADCASTER_AWAIT_OVERLAYS
;
}
NS_ADDREF
(
*
aBroadcaster
)
;
return
NS_FINDBROADCASTER_FOUND
;
}
nsresult
XULDocument
:
:
CheckBroadcasterHookup
(
Element
*
aElement
bool
*
aNeedsHookup
bool
*
aDidResolve
)
{
nsresult
rv
;
*
aDidResolve
=
false
;
nsCOMPtr
<
Element
>
listener
;
nsAutoString
broadcasterID
;
nsAutoString
attribute
;
nsCOMPtr
<
Element
>
broadcaster
;
rv
=
FindBroadcaster
(
aElement
getter_AddRefs
(
listener
)
broadcasterID
attribute
getter_AddRefs
(
broadcaster
)
)
;
switch
(
rv
)
{
case
NS_FINDBROADCASTER_NOT_FOUND
:
*
aNeedsHookup
=
false
;
return
NS_OK
;
case
NS_FINDBROADCASTER_AWAIT_OVERLAYS
:
*
aNeedsHookup
=
true
;
return
NS_OK
;
case
NS_FINDBROADCASTER_FOUND
:
break
;
default
:
return
rv
;
}
NS_ENSURE_ARG
(
broadcaster
&
&
listener
)
;
ErrorResult
domRv
;
AddBroadcastListenerFor
(
*
broadcaster
*
listener
attribute
domRv
)
;
if
(
domRv
.
Failed
(
)
)
{
return
domRv
.
StealNSResult
(
)
;
}
if
(
MOZ_LOG_TEST
(
gXULLog
LogLevel
:
:
Debug
)
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
listener
)
;
NS_ASSERTION
(
content
!
=
nullptr
"
not
an
nsIContent
"
)
;
if
(
!
content
)
return
rv
;
nsAutoCString
attributeC
broadcasteridC
;
LossyCopyUTF16toASCII
(
attribute
attributeC
)
;
LossyCopyUTF16toASCII
(
broadcasterID
broadcasteridC
)
;
MOZ_LOG
(
gXULLog
LogLevel
:
:
Debug
(
"
xul
:
broadcaster
hookup
<
%
s
attribute
=
'
%
s
'
>
to
%
s
"
nsAtomCString
(
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
.
get
(
)
attributeC
.
get
(
)
broadcasteridC
.
get
(
)
)
)
;
}
*
aNeedsHookup
=
false
;
*
aDidResolve
=
true
;
return
NS_OK
;
}
XULDocument
:
:
CachedChromeStreamListener
:
:
CachedChromeStreamListener
(
XULDocument
*
aDocument
bool
aProtoLoaded
)
:
mDocument
(
aDocument
)
mProtoLoaded
(
aProtoLoaded
)
{
}
XULDocument
:
:
CachedChromeStreamListener
:
:
~
CachedChromeStreamListener
(
)
{
}
NS_IMPL_ISUPPORTS
(
XULDocument
:
:
CachedChromeStreamListener
nsIRequestObserver
nsIStreamListener
)
NS_IMETHODIMP
XULDocument
:
:
CachedChromeStreamListener
:
:
OnStartRequest
(
nsIRequest
*
request
nsISupports
*
acontext
)
{
return
NS_ERROR_PARSED_DATA_CACHED
;
}
NS_IMETHODIMP
XULDocument
:
:
CachedChromeStreamListener
:
:
OnStopRequest
(
nsIRequest
*
request
nsISupports
*
aContext
nsresult
aStatus
)
{
if
(
!
mProtoLoaded
)
return
NS_OK
;
return
mDocument
-
>
OnPrototypeLoadDone
(
true
)
;
}
NS_IMETHODIMP
XULDocument
:
:
CachedChromeStreamListener
:
:
OnDataAvailable
(
nsIRequest
*
request
nsISupports
*
aContext
nsIInputStream
*
aInStr
uint64_t
aSourceOffset
uint32_t
aCount
)
{
MOZ_ASSERT_UNREACHABLE
(
"
CachedChromeStream
doesn
'
t
receive
data
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
bool
XULDocument
:
:
IsDocumentRightToLeft
(
)
{
Element
*
element
=
GetRootElement
(
)
;
if
(
element
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
&
nsGkAtoms
:
:
ltr
&
nsGkAtoms
:
:
rtl
nullptr
}
;
switch
(
element
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
localedir
strings
eCaseMatters
)
)
{
case
0
:
return
false
;
case
1
:
return
true
;
default
:
break
;
}
}
nsCOMPtr
<
nsIXULChromeRegistry
>
reg
=
mozilla
:
:
services
:
:
GetXULChromeRegistryService
(
)
;
if
(
!
reg
)
return
false
;
nsAutoCString
package
;
bool
isChrome
;
if
(
NS_SUCCEEDED
(
mDocumentURI
-
>
SchemeIs
(
"
chrome
"
&
isChrome
)
)
&
&
isChrome
)
{
mDocumentURI
-
>
GetHostPort
(
package
)
;
}
else
{
bool
isAbout
isResource
;
if
(
NS_SUCCEEDED
(
mDocumentURI
-
>
SchemeIs
(
"
about
"
&
isAbout
)
)
&
&
isAbout
)
{
package
.
AssignLiteral
(
"
global
"
)
;
}
else
if
(
NS_SUCCEEDED
(
mDocumentURI
-
>
SchemeIs
(
"
resource
"
&
isResource
)
)
&
&
isResource
)
{
package
.
AssignLiteral
(
"
global
"
)
;
}
else
{
return
false
;
}
}
bool
isRTL
=
false
;
reg
-
>
IsLocaleRTL
(
package
&
isRTL
)
;
return
isRTL
;
}
void
XULDocument
:
:
ResetDocumentDirection
(
)
{
DocumentStatesChanged
(
NS_DOCUMENT_STATE_RTL_LOCALE
)
;
}
void
XULDocument
:
:
DirectionChanged
(
const
char
*
aPrefName
XULDocument
*
aDoc
)
{
if
(
aDoc
)
{
aDoc
-
>
ResetDocumentDirection
(
)
;
}
}
nsIDocument
:
:
DocumentTheme
XULDocument
:
:
GetDocumentLWTheme
(
)
{
if
(
mDocLWTheme
=
=
Doc_Theme_Uninitialized
)
{
mDocLWTheme
=
ThreadSafeGetDocumentLWTheme
(
)
;
}
return
mDocLWTheme
;
}
nsIDocument
:
:
DocumentTheme
XULDocument
:
:
ThreadSafeGetDocumentLWTheme
(
)
const
{
if
(
mDocLWTheme
!
=
Doc_Theme_Uninitialized
)
{
return
mDocLWTheme
;
}
DocumentTheme
theme
=
Doc_Theme_None
;
Element
*
element
=
GetRootElement
(
)
;
nsAutoString
hasLWTheme
;
if
(
element
&
&
element
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
lwtheme
hasLWTheme
)
&
&
!
(
hasLWTheme
.
IsEmpty
(
)
)
&
&
hasLWTheme
.
EqualsLiteral
(
"
true
"
)
)
{
theme
=
Doc_Theme_Neutral
;
nsAutoString
lwTheme
;
element
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
lwthemetextcolor
lwTheme
)
;
if
(
!
(
lwTheme
.
IsEmpty
(
)
)
)
{
if
(
lwTheme
.
EqualsLiteral
(
"
dark
"
)
)
theme
=
Doc_Theme_Dark
;
else
if
(
lwTheme
.
EqualsLiteral
(
"
bright
"
)
)
theme
=
Doc_Theme_Bright
;
}
}
return
theme
;
}
JSObject
*
XULDocument
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
XULDocument_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
}
