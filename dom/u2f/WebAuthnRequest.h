#
ifndef
mozilla_dom_WebAuthnAsync_h
#
define
mozilla_dom_WebAuthnAsync_h
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
namespace
mozilla
{
namespace
dom
{
extern
mozilla
:
:
LazyLogModule
gWebauthLog
;
template
<
class
Success
>
class
WebAuthnRequest
{
public
:
WebAuthnRequest
(
)
:
mCancelled
(
false
)
mSuccess
(
false
)
mCountTokens
(
0
)
mTokensFailed
(
0
)
mReentrantMonitor
(
"
WebAuthnRequest
"
)
{
}
void
AddActiveToken
(
const
char
*
aCallSite
)
{
MOZ_LOG
(
gWebauthLog
LogLevel
:
:
Debug
(
"
WebAuthnRequest
is
tracking
a
new
token
called
from
[
%
s
]
"
aCallSite
)
)
;
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
MOZ_ASSERT
(
!
IsComplete
(
)
)
;
mCountTokens
+
=
1
;
}
bool
IsComplete
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
return
mCancelled
|
|
mSuccess
|
|
(
mCountTokens
>
0
&
&
mTokensFailed
=
=
mCountTokens
)
;
}
void
CancelNow
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
if
(
IsComplete
(
)
)
{
return
;
}
mCancelled
=
true
;
mPromise
.
Reject
(
NS_ERROR_DOM_NOT_ALLOWED_ERR
__func__
)
;
}
void
SetFailure
(
nsresult
aError
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
if
(
IsComplete
(
)
)
{
return
;
}
mTokensFailed
+
=
1
;
MOZ_ASSERT
(
mTokensFailed
<
=
mCountTokens
)
;
if
(
mTokensFailed
=
=
mCountTokens
)
{
mPromise
.
Reject
(
aError
__func__
)
;
}
}
void
SetSuccess
(
const
Success
&
aResult
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
if
(
IsComplete
(
)
)
{
return
;
}
mSuccess
=
true
;
mPromise
.
Resolve
(
aResult
__func__
)
;
}
void
SetDeadline
(
TimeDuration
aDeadline
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
MOZ_ASSERT
(
!
IsComplete
(
)
)
;
}
RefPtr
<
MozPromise
<
Success
nsresult
false
>
>
Ensure
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
MOZ_ASSERT
(
!
IsComplete
(
)
)
;
return
mPromise
.
Ensure
(
__func__
)
;
}
void
CompleteTask
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
if
(
mCountTokens
=
=
0
)
{
mPromise
.
Reject
(
NS_ERROR_DOM_NOT_ALLOWED_ERR
__func__
)
;
}
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
WebAuthnRequest
)
private
:
~
WebAuthnRequest
(
)
{
}
;
bool
mCancelled
;
bool
mSuccess
;
int
mCountTokens
;
int
mTokensFailed
;
ReentrantMonitor
mReentrantMonitor
;
MozPromiseHolder
<
MozPromise
<
Success
nsresult
false
>
>
mPromise
;
}
;
}
}
#
endif
