#
include
"
gtest
/
gtest
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
PrioEncoder
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mprio
.
h
"
TEST
(
PrioEncoder
BadPublicKeys
)
{
mozilla
:
:
ErrorResult
rv
;
rv
=
mozilla
:
:
dom
:
:
PrioEncoder
:
:
SetKeys
(
"
badA
"
"
badB
"
)
;
ASSERT_TRUE
(
rv
.
Failed
(
)
)
;
rv
=
mozilla
:
:
ErrorResult
(
)
;
}
TEST
(
PrioEncoder
BooleanLimitExceeded
)
{
mozilla
:
:
dom
:
:
AutoJSAPI
jsAPI
;
ASSERT_TRUE
(
jsAPI
.
Init
(
xpc
:
:
PrivilegedJunkScope
(
)
)
)
;
JSContext
*
cx
=
jsAPI
.
cx
(
)
;
mozilla
:
:
dom
:
:
GlobalObject
global
(
cx
xpc
:
:
PrivilegedJunkScope
(
)
)
;
nsCString
batchID
=
"
abc123
"
_ns
;
mozilla
:
:
dom
:
:
PrioParams
prioParams
;
FallibleTArray
<
bool
>
sequence
;
const
int
ndata
=
mozilla
:
:
dom
:
:
PrioEncoder
:
:
gNumBooleans
+
1
;
const
int
seed
=
time
(
nullptr
)
;
srand
(
seed
)
;
for
(
int
i
=
0
;
i
<
ndata
;
i
+
+
)
{
*
(
sequence
.
AppendElement
(
mozilla
:
:
fallible
)
)
=
rand
(
)
%
2
;
}
ASSERT_TRUE
(
prioParams
.
mBooleans
.
Assign
(
sequence
)
)
;
mozilla
:
:
dom
:
:
RootedDictionary
<
mozilla
:
:
dom
:
:
PrioEncodedData
>
prioEncodedData
(
cx
)
;
mozilla
:
:
ErrorResult
rv
;
mozilla
:
:
dom
:
:
PrioEncoder
:
:
Encode
(
global
batchID
prioParams
prioEncodedData
rv
)
;
ASSERT_TRUE
(
rv
.
Failed
(
)
)
;
rv
=
mozilla
:
:
ErrorResult
(
)
;
}
TEST
(
PrioEncoder
VerifyFull
)
{
SECStatus
prioRv
=
SECSuccess
;
PublicKey
pkA
=
nullptr
;
PublicKey
pkB
=
nullptr
;
PrivateKey
skA
=
nullptr
;
PrivateKey
skB
=
nullptr
;
PrioConfig
cfg
=
nullptr
;
PrioServer
sA
=
nullptr
;
PrioServer
sB
=
nullptr
;
PrioVerifier
vA
=
nullptr
;
PrioVerifier
vB
=
nullptr
;
PrioPacketVerify1
p1A
=
nullptr
;
PrioPacketVerify1
p1B
=
nullptr
;
PrioPacketVerify2
p2A
=
nullptr
;
PrioPacketVerify2
p2B
=
nullptr
;
PrioTotalShare
tA
=
nullptr
;
PrioTotalShare
tB
=
nullptr
;
unsigned
char
*
forServerA
=
nullptr
;
unsigned
char
*
forServerB
=
nullptr
;
const
int
seed
=
time
(
nullptr
)
;
srand
(
seed
)
;
const
int
ndata
=
3
;
unsigned
char
batchIDStr
[
32
]
;
memset
(
batchIDStr
0
sizeof
batchIDStr
)
;
snprintf
(
(
char
*
)
batchIDStr
sizeof
batchIDStr
"
%
d
"
rand
(
)
)
;
bool
dataItems
[
ndata
]
;
unsigned
long
long
output
[
ndata
]
;
for
(
int
i
=
0
;
i
<
ndata
;
i
+
+
)
{
dataItems
[
i
]
=
rand
(
)
%
2
;
}
prioRv
=
Prio_init
(
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
Keypair_new
(
&
skA
&
pkA
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
Keypair_new
(
&
skB
&
pkB
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
const
int
keyLength
=
CURVE25519_KEY_LEN_HEX
+
1
;
unsigned
char
pkHexA
[
keyLength
]
;
unsigned
char
pkHexB
[
keyLength
]
;
prioRv
=
PublicKey_export_hex
(
pkA
pkHexA
keyLength
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
PublicKey_export_hex
(
pkB
pkHexB
keyLength
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
cfg
=
PrioConfig_new
(
ndata
pkA
pkB
batchIDStr
strlen
(
(
char
*
)
batchIDStr
)
)
;
ASSERT_TRUE
(
cfg
!
=
nullptr
)
;
PrioPRGSeed
serverSecret
;
prioRv
=
PrioPRGSeed_randomize
(
&
serverSecret
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
sA
=
PrioServer_new
(
cfg
PRIO_SERVER_A
skA
serverSecret
)
;
ASSERT_TRUE
(
sA
!
=
nullptr
)
;
sB
=
PrioServer_new
(
cfg
PRIO_SERVER_B
skB
serverSecret
)
;
ASSERT_TRUE
(
sB
!
=
nullptr
)
;
vA
=
PrioVerifier_new
(
sA
)
;
ASSERT_TRUE
(
vA
!
=
nullptr
)
;
vB
=
PrioVerifier_new
(
sB
)
;
ASSERT_TRUE
(
vB
!
=
nullptr
)
;
tA
=
PrioTotalShare_new
(
)
;
ASSERT_TRUE
(
tA
!
=
nullptr
)
;
tB
=
PrioTotalShare_new
(
)
;
ASSERT_TRUE
(
tB
!
=
nullptr
)
;
p1A
=
PrioPacketVerify1_new
(
)
;
ASSERT_TRUE
(
p1A
!
=
nullptr
)
;
p1B
=
PrioPacketVerify1_new
(
)
;
ASSERT_TRUE
(
p1B
!
=
nullptr
)
;
p2A
=
PrioPacketVerify2_new
(
)
;
ASSERT_TRUE
(
p2A
!
=
nullptr
)
;
p2B
=
PrioPacketVerify2_new
(
)
;
ASSERT_TRUE
(
p2B
!
=
nullptr
)
;
unsigned
int
aLen
=
0
bLen
=
0
;
mozilla
:
:
dom
:
:
AutoJSAPI
jsAPI
;
ASSERT_TRUE
(
jsAPI
.
Init
(
xpc
:
:
PrivilegedJunkScope
(
)
)
)
;
JSContext
*
cx
=
jsAPI
.
cx
(
)
;
mozilla
:
:
dom
:
:
GlobalObject
global
(
cx
xpc
:
:
PrivilegedJunkScope
(
)
)
;
nsCString
batchID
;
batchID
=
(
char
*
)
(
batchIDStr
)
;
mozilla
:
:
dom
:
:
PrioParams
prioParams
;
FallibleTArray
<
bool
>
sequence
;
*
(
sequence
.
AppendElement
(
mozilla
:
:
fallible
)
)
=
dataItems
[
0
]
;
*
(
sequence
.
AppendElement
(
mozilla
:
:
fallible
)
)
=
dataItems
[
1
]
;
*
(
sequence
.
AppendElement
(
mozilla
:
:
fallible
)
)
=
dataItems
[
2
]
;
ASSERT_TRUE
(
prioParams
.
mBooleans
.
Assign
(
sequence
)
)
;
mozilla
:
:
dom
:
:
RootedDictionary
<
mozilla
:
:
dom
:
:
PrioEncodedData
>
prioEncodedData
(
cx
)
;
mozilla
:
:
ErrorResult
rv
;
rv
=
mozilla
:
:
dom
:
:
PrioEncoder
:
:
SetKeys
(
reinterpret_cast
<
const
char
*
>
(
pkHexA
)
reinterpret_cast
<
const
char
*
>
(
pkHexB
)
)
;
ASSERT_FALSE
(
rv
.
Failed
(
)
)
;
mozilla
:
:
dom
:
:
PrioEncoder
:
:
Encode
(
global
batchID
prioParams
prioEncodedData
rv
)
;
ASSERT_FALSE
(
rv
.
Failed
(
)
)
;
prioEncodedData
.
mA
.
Value
(
)
.
ComputeState
(
)
;
prioEncodedData
.
mB
.
Value
(
)
.
ComputeState
(
)
;
forServerA
=
prioEncodedData
.
mA
.
Value
(
)
.
Data
(
)
;
forServerB
=
prioEncodedData
.
mB
.
Value
(
)
.
Data
(
)
;
aLen
=
prioEncodedData
.
mA
.
Value
(
)
.
Length
(
)
;
bLen
=
prioEncodedData
.
mB
.
Value
(
)
.
Length
(
)
;
prioRv
=
PrioVerifier_set_data
(
vA
forServerA
aLen
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
PrioVerifier_set_data
(
vB
forServerB
bLen
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
PrioPacketVerify1_set_data
(
p1A
vA
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
PrioPacketVerify1_set_data
(
p1B
vB
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
PrioPacketVerify2_set_data
(
p2A
vA
p1A
p1B
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
PrioPacketVerify2_set_data
(
p2B
vB
p1A
p1B
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
PrioVerifier_isValid
(
vA
p2A
p2B
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
PrioVerifier_isValid
(
vB
p2A
p2B
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
PrioServer_aggregate
(
sA
vA
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
PrioServer_aggregate
(
sB
vB
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
PrioTotalShare_set_data
(
tA
sA
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
PrioTotalShare_set_data
(
tB
sB
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
prioRv
=
PrioTotalShare_final
(
cfg
output
tA
tB
)
;
ASSERT_TRUE
(
prioRv
=
=
SECSuccess
)
;
for
(
int
i
=
0
;
i
<
ndata
;
i
+
+
)
{
ASSERT_TRUE
(
output
[
i
]
=
=
dataItems
[
i
]
)
;
}
PrioTotalShare_clear
(
tA
)
;
PrioTotalShare_clear
(
tB
)
;
PrioPacketVerify2_clear
(
p2A
)
;
PrioPacketVerify2_clear
(
p2B
)
;
PrioPacketVerify1_clear
(
p1A
)
;
PrioPacketVerify1_clear
(
p1B
)
;
PrioVerifier_clear
(
vA
)
;
PrioVerifier_clear
(
vB
)
;
PrioServer_clear
(
sA
)
;
PrioServer_clear
(
sB
)
;
PrioConfig_clear
(
cfg
)
;
PublicKey_clear
(
pkA
)
;
PublicKey_clear
(
pkB
)
;
PrivateKey_clear
(
skA
)
;
PrivateKey_clear
(
skB
)
;
Prio_clear
(
)
;
}
