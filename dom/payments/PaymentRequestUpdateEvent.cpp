#
include
"
mozilla
/
dom
/
PaymentRequestUpdateEvent
.
h
"
#
include
"
mozilla
/
dom
/
PaymentRequest
.
h
"
#
include
"
mozilla
/
dom
/
RootedDictionary
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
PaymentRequestUpdateEvent
Event
mRequest
)
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
PaymentRequestUpdateEvent
Event
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
PaymentRequestUpdateEvent
)
NS_INTERFACE_MAP_END_INHERITING
(
Event
)
NS_IMPL_ADDREF_INHERITED
(
PaymentRequestUpdateEvent
Event
)
NS_IMPL_RELEASE_INHERITED
(
PaymentRequestUpdateEvent
Event
)
already_AddRefed
<
PaymentRequestUpdateEvent
>
PaymentRequestUpdateEvent
:
:
Constructor
(
mozilla
:
:
dom
:
:
EventTarget
*
aOwner
const
nsAString
&
aType
const
PaymentRequestUpdateEventInit
&
aEventInitDict
)
{
RefPtr
<
PaymentRequestUpdateEvent
>
e
=
new
PaymentRequestUpdateEvent
(
aOwner
)
;
bool
trusted
=
e
-
>
Init
(
aOwner
)
;
e
-
>
InitEvent
(
aType
aEventInitDict
.
mBubbles
aEventInitDict
.
mCancelable
)
;
e
-
>
SetTrusted
(
trusted
)
;
e
-
>
SetComposed
(
aEventInitDict
.
mComposed
)
;
return
e
.
forget
(
)
;
}
already_AddRefed
<
PaymentRequestUpdateEvent
>
PaymentRequestUpdateEvent
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aType
const
PaymentRequestUpdateEventInit
&
aEventInitDict
)
{
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
owner
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
return
Constructor
(
owner
aType
aEventInitDict
)
;
}
PaymentRequestUpdateEvent
:
:
PaymentRequestUpdateEvent
(
EventTarget
*
aOwner
)
:
Event
(
aOwner
nullptr
nullptr
)
mWaitForUpdate
(
false
)
mRequest
(
nullptr
)
{
MOZ_ASSERT
(
aOwner
)
;
}
void
PaymentRequestUpdateEvent
:
:
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
aCx
)
;
MOZ_ASSERT
(
mRequest
)
;
if
(
!
mRequest
-
>
InFullyActiveDocument
(
)
)
{
return
;
}
if
(
NS_WARN_IF
(
!
aValue
.
isObject
(
)
)
|
|
!
mWaitForUpdate
)
{
return
;
}
ErrorResult
rv
;
RootedDictionary
<
PaymentDetailsUpdate
>
details
(
aCx
)
;
if
(
!
details
.
Init
(
aCx
aValue
)
)
{
rv
.
StealExceptionFromJSContext
(
aCx
)
;
mRequest
-
>
AbortUpdate
(
rv
)
;
return
;
}
mRequest
-
>
IsValidDetailsUpdate
(
details
true
rv
)
;
if
(
rv
.
Failed
(
)
)
{
mRequest
-
>
AbortUpdate
(
rv
)
;
return
;
}
mRequest
-
>
UpdatePayment
(
aCx
details
rv
)
;
if
(
rv
.
Failed
(
)
)
{
mRequest
-
>
AbortUpdate
(
rv
)
;
return
;
}
mWaitForUpdate
=
false
;
mRequest
-
>
SetUpdating
(
false
)
;
}
void
PaymentRequestUpdateEvent
:
:
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
mRequest
)
;
if
(
!
mRequest
-
>
InFullyActiveDocument
(
)
)
{
return
;
}
ErrorResult
rejectReason
;
rejectReason
.
ThrowAbortError
(
"
Details
promise
for
PaymentRequestUpdateEvent
.
updateWith
(
)
is
rejected
"
"
by
merchant
"
)
;
mRequest
-
>
AbortUpdate
(
rejectReason
)
;
mWaitForUpdate
=
false
;
mRequest
-
>
SetUpdating
(
false
)
;
}
void
PaymentRequestUpdateEvent
:
:
UpdateWith
(
Promise
&
aPromise
ErrorResult
&
aRv
)
{
if
(
!
IsTrusted
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Called
on
an
untrusted
event
"
)
;
return
;
}
MOZ_ASSERT
(
mRequest
)
;
if
(
!
mRequest
-
>
InFullyActiveDocument
(
)
)
{
return
;
}
if
(
mWaitForUpdate
|
|
!
mRequest
-
>
ReadyForUpdate
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
The
PaymentRequestUpdateEvent
is
waiting
for
update
"
)
;
return
;
}
if
(
!
mRequest
-
>
ReadyForUpdate
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
The
PaymentRequest
state
is
not
eInteractive
or
is
the
PaymentRequest
"
"
is
updating
"
)
;
return
;
}
aPromise
.
AppendNativeHandler
(
this
)
;
StopPropagation
(
)
;
StopImmediatePropagation
(
)
;
mWaitForUpdate
=
true
;
mRequest
-
>
SetUpdating
(
true
)
;
}
void
PaymentRequestUpdateEvent
:
:
SetRequest
(
PaymentRequest
*
aRequest
)
{
MOZ_ASSERT
(
IsTrusted
(
)
)
;
MOZ_ASSERT
(
!
mRequest
)
;
MOZ_ASSERT
(
aRequest
)
;
mRequest
=
aRequest
;
}
PaymentRequestUpdateEvent
:
:
~
PaymentRequestUpdateEvent
(
)
=
default
;
JSObject
*
PaymentRequestUpdateEvent
:
:
WrapObjectInternal
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
PaymentRequestUpdateEvent_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
