#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
ReadIntoRequest
.
h
"
#
include
"
ReadableStreamPipeTo
.
h
"
#
include
"
ReadableStreamTee
.
h
"
#
include
"
StreamUtils
.
h
"
#
include
"
TeeState
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
Exception
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
HoldDropJSObjects
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
dom
/
BindingCallContext
.
h
"
#
include
"
mozilla
/
dom
/
ByteStreamHelpers
.
h
"
#
include
"
mozilla
/
dom
/
BodyStream
.
h
"
#
include
"
mozilla
/
dom
/
QueueWithSizes
.
h
"
#
include
"
mozilla
/
dom
/
QueuingStrategyBinding
.
h
"
#
include
"
mozilla
/
dom
/
ReadRequest
.
h
"
#
include
"
mozilla
/
dom
/
ReadableByteStreamController
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamBYOBReader
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamBinding
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamController
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamDefaultController
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamDefaultReader
.
h
"
#
include
"
mozilla
/
dom
/
RootedDictionary
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
UnderlyingSourceBinding
.
h
"
#
include
"
mozilla
/
dom
/
UnderlyingSourceCallbackHelpers
.
h
"
#
include
"
mozilla
/
dom
/
WritableStream
.
h
"
#
include
"
mozilla
/
dom
/
WritableStreamDefaultWriter
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
dom
/
Promise
-
inl
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsISupports
.
h
"
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
mozilla
:
:
Variant
<
mozilla
:
:
Nothing
RefPtr
<
mozilla
:
:
dom
:
:
ReadableStreamDefaultReader
>
>
&
aReader
const
char
*
aName
uint32_t
aFlags
=
0
)
{
if
(
aReader
.
is
<
RefPtr
<
mozilla
:
:
dom
:
:
ReadableStreamDefaultReader
>
>
(
)
)
{
ImplCycleCollectionTraverse
(
aCallback
aReader
.
as
<
RefPtr
<
mozilla
:
:
dom
:
:
ReadableStreamDefaultReader
>
>
(
)
aName
aFlags
)
;
}
}
inline
void
ImplCycleCollectionUnlink
(
mozilla
:
:
Variant
<
mozilla
:
:
Nothing
RefPtr
<
mozilla
:
:
dom
:
:
ReadableStreamDefaultReader
>
>
&
aReader
)
{
aReader
=
AsVariant
(
mozilla
:
:
Nothing
(
)
)
;
}
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_WITH_JS_MEMBERS
(
ReadableStream
(
mGlobal
mController
mReader
)
(
mStoredError
)
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ReadableStream
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ReadableStream
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadableStream
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
ReadableStream
:
:
ReadableStream
(
nsIGlobalObject
*
aGlobal
)
:
mGlobal
(
aGlobal
)
mReader
(
nullptr
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
}
ReadableStream
:
:
ReadableStream
(
const
GlobalObject
&
aGlobal
)
:
mGlobal
(
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
)
mReader
(
nullptr
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
}
ReadableStream
:
:
~
ReadableStream
(
)
{
mozilla
:
:
DropJSObjects
(
this
)
;
}
JSObject
*
ReadableStream
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ReadableStream_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
ReadableStreamDefaultReader
*
ReadableStream
:
:
GetDefaultReader
(
)
{
return
mReader
-
>
AsDefault
(
)
;
}
void
ReadableStream
:
:
SetReader
(
ReadableStreamGenericReader
*
aReader
)
{
mReader
=
aReader
;
}
bool
ReadableStreamHasBYOBReader
(
ReadableStream
*
aStream
)
{
ReadableStreamGenericReader
*
reader
=
aStream
-
>
GetReader
(
)
;
if
(
!
reader
)
{
return
false
;
}
return
reader
-
>
IsBYOB
(
)
;
}
bool
ReadableStreamHasDefaultReader
(
ReadableStream
*
aStream
)
{
ReadableStreamGenericReader
*
reader
=
aStream
-
>
GetReader
(
)
;
if
(
!
reader
)
{
return
false
;
}
return
reader
-
>
IsDefault
(
)
;
}
already_AddRefed
<
ReadableStream
>
ReadableStream
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
Optional
<
JS
:
:
Handle
<
JSObject
*
>
>
&
aUnderlyingSource
const
QueuingStrategy
&
aStrategy
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JSObject
*
>
underlyingSourceObj
(
aGlobal
.
Context
(
)
aUnderlyingSource
.
WasPassed
(
)
?
aUnderlyingSource
.
Value
(
)
:
nullptr
)
;
RootedDictionary
<
UnderlyingSource
>
underlyingSourceDict
(
aGlobal
.
Context
(
)
)
;
if
(
underlyingSourceObj
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
objValue
(
aGlobal
.
Context
(
)
JS
:
:
ObjectValue
(
*
underlyingSourceObj
)
)
;
dom
:
:
BindingCallContext
callCx
(
aGlobal
.
Context
(
)
"
ReadableStream
.
constructor
"
)
;
aRv
.
MightThrowJSException
(
)
;
if
(
!
underlyingSourceDict
.
Init
(
callCx
objValue
)
)
{
aRv
.
StealExceptionFromJSContext
(
aGlobal
.
Context
(
)
)
;
return
nullptr
;
}
}
RefPtr
<
ReadableStream
>
readableStream
=
new
ReadableStream
(
aGlobal
)
;
if
(
underlyingSourceDict
.
mType
.
WasPassed
(
)
)
{
MOZ_ASSERT
(
underlyingSourceDict
.
mType
.
Value
(
)
=
=
ReadableStreamType
:
:
Bytes
)
;
if
(
aStrategy
.
mSize
.
WasPassed
(
)
)
{
aRv
.
ThrowRangeError
(
"
Implementation
preserved
member
'
size
'
"
)
;
return
nullptr
;
}
double
highWaterMark
=
ExtractHighWaterMark
(
aStrategy
0
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
SetUpReadableByteStreamControllerFromUnderlyingSource
(
aGlobal
.
Context
(
)
readableStream
underlyingSourceObj
underlyingSourceDict
highWaterMark
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
readableStream
.
forget
(
)
;
}
RefPtr
<
QueuingStrategySize
>
sizeAlgorithm
=
aStrategy
.
mSize
.
WasPassed
(
)
?
&
aStrategy
.
mSize
.
Value
(
)
:
nullptr
;
double
highWaterMark
=
ExtractHighWaterMark
(
aStrategy
1
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
SetupReadableStreamDefaultControllerFromUnderlyingSource
(
aGlobal
.
Context
(
)
readableStream
underlyingSourceObj
underlyingSourceDict
highWaterMark
sizeAlgorithm
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
readableStream
.
forget
(
)
;
}
bool
ReadableStream
:
:
Locked
(
)
const
{
return
mReader
;
}
static
void
InitializeReadableStream
(
ReadableStream
*
aStream
)
{
aStream
-
>
SetState
(
ReadableStream
:
:
ReaderState
:
:
Readable
)
;
aStream
-
>
SetReader
(
nullptr
)
;
aStream
-
>
SetStoredError
(
JS
:
:
UndefinedHandleValue
)
;
aStream
-
>
SetDisturbed
(
false
)
;
}
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
ReadableStream
>
CreateReadableStream
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
UnderlyingSourceAlgorithmsBase
*
aAlgorithms
mozilla
:
:
Maybe
<
double
>
aHighWaterMark
QueuingStrategySize
*
aSizeAlgorithm
ErrorResult
&
aRv
)
{
double
highWaterMark
=
aHighWaterMark
.
valueOr
(
1
.
0
)
;
MOZ_ASSERT
(
IsNonNegativeNumber
(
highWaterMark
)
)
;
RefPtr
<
ReadableStream
>
stream
=
new
ReadableStream
(
aGlobal
)
;
InitializeReadableStream
(
stream
)
;
RefPtr
<
ReadableStreamDefaultController
>
controller
=
new
ReadableStreamDefaultController
(
aGlobal
)
;
SetUpReadableStreamDefaultController
(
aCx
stream
controller
aAlgorithms
highWaterMark
aSizeAlgorithm
aRv
)
;
return
stream
.
forget
(
)
;
}
void
ReadableStreamClose
(
JSContext
*
aCx
ReadableStream
*
aStream
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aStream
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
;
aStream
-
>
SetState
(
ReadableStream
:
:
ReaderState
:
:
Closed
)
;
ReadableStreamGenericReader
*
reader
=
aStream
-
>
GetReader
(
)
;
if
(
!
reader
)
{
return
;
}
reader
-
>
ClosedPromise
(
)
-
>
MaybeResolveWithUndefined
(
)
;
if
(
reader
-
>
IsDefault
(
)
)
{
LinkedList
<
RefPtr
<
ReadRequest
>
>
readRequests
=
std
:
:
move
(
reader
-
>
AsDefault
(
)
-
>
ReadRequests
(
)
)
;
reader
-
>
AsDefault
(
)
-
>
ReadRequests
(
)
.
clear
(
)
;
while
(
RefPtr
<
ReadRequest
>
readRequest
=
readRequests
.
popFirst
(
)
)
{
readRequest
-
>
CloseSteps
(
aCx
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
}
}
already_AddRefed
<
Promise
>
ReadableStreamCancel
(
JSContext
*
aCx
ReadableStream
*
aStream
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
{
aStream
-
>
SetDisturbed
(
true
)
;
if
(
aStream
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Closed
)
{
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
aStream
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
if
(
aStream
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Errored
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
storedError
(
aCx
aStream
-
>
StoredError
(
)
)
;
return
Promise
:
:
CreateRejected
(
aStream
-
>
GetParentObject
(
)
storedError
aRv
)
;
}
ReadableStreamClose
(
aCx
aStream
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
ReadableStreamGenericReader
*
reader
=
aStream
-
>
GetReader
(
)
;
if
(
reader
&
&
reader
-
>
IsBYOB
(
)
)
{
LinkedList
<
RefPtr
<
ReadIntoRequest
>
>
readIntoRequests
=
std
:
:
move
(
reader
-
>
AsBYOB
(
)
-
>
ReadIntoRequests
(
)
)
;
reader
-
>
AsBYOB
(
)
-
>
ReadIntoRequests
(
)
.
clear
(
)
;
while
(
RefPtr
<
ReadIntoRequest
>
readIntoRequest
=
readIntoRequests
.
popFirst
(
)
)
{
readIntoRequest
-
>
CloseSteps
(
aCx
JS
:
:
UndefinedHandleValue
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
}
RefPtr
<
ReadableStreamController
>
controller
(
aStream
-
>
Controller
(
)
)
;
RefPtr
<
Promise
>
sourceCancelPromise
=
controller
-
>
CancelSteps
(
aCx
aError
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
sourceCancelPromise
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
Result
<
RefPtr
<
Promise
>
nsresult
>
returnResult
=
sourceCancelPromise
-
>
ThenWithCycleCollectedArgs
(
[
]
(
JSContext
*
JS
:
:
Handle
<
JS
:
:
Value
>
ErrorResult
&
RefPtr
<
Promise
>
newPromise
)
{
newPromise
-
>
MaybeResolveWithUndefined
(
)
;
return
newPromise
.
forget
(
)
;
}
promise
)
;
if
(
returnResult
.
isErr
(
)
)
{
aRv
.
Throw
(
returnResult
.
unwrapErr
(
)
)
;
return
nullptr
;
}
return
returnResult
.
unwrap
(
)
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
ReadableStream
:
:
Cancel
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
{
if
(
Locked
(
)
)
{
aRv
.
ThrowTypeError
(
"
Cannot
cancel
a
stream
locked
by
a
reader
.
"
)
;
return
nullptr
;
}
RefPtr
<
ReadableStream
>
thisRefPtr
=
this
;
return
ReadableStreamCancel
(
aCx
thisRefPtr
aReason
aRv
)
;
}
already_AddRefed
<
ReadableStreamDefaultReader
>
AcquireReadableStreamDefaultReader
(
ReadableStream
*
aStream
ErrorResult
&
aRv
)
{
RefPtr
<
ReadableStreamDefaultReader
>
reader
=
new
ReadableStreamDefaultReader
(
aStream
-
>
GetParentObject
(
)
)
;
SetUpReadableStreamDefaultReader
(
reader
aStream
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
reader
.
forget
(
)
;
}
void
ReadableStream
:
:
GetReader
(
const
ReadableStreamGetReaderOptions
&
aOptions
OwningReadableStreamReader
&
resultReader
ErrorResult
&
aRv
)
{
if
(
!
aOptions
.
mMode
.
WasPassed
(
)
)
{
RefPtr
<
ReadableStreamDefaultReader
>
defaultReader
=
AcquireReadableStreamDefaultReader
(
this
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
resultReader
.
SetAsReadableStreamDefaultReader
(
)
=
defaultReader
;
return
;
}
MOZ_ASSERT
(
aOptions
.
mMode
.
Value
(
)
=
=
ReadableStreamReaderMode
:
:
Byob
)
;
RefPtr
<
ReadableStreamBYOBReader
>
byobReader
=
AcquireReadableStreamBYOBReader
(
this
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
resultReader
.
SetAsReadableStreamBYOBReader
(
)
=
byobReader
;
}
bool
IsReadableStreamLocked
(
ReadableStream
*
aStream
)
{
return
aStream
-
>
Locked
(
)
;
}
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
ReadableStream
>
ReadableStream
:
:
PipeThrough
(
const
ReadableWritablePair
&
aTransform
const
StreamPipeOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
IsReadableStreamLocked
(
this
)
)
{
aRv
.
ThrowTypeError
(
"
Cannot
pipe
from
a
locked
stream
.
"
)
;
return
nullptr
;
}
if
(
IsWritableStreamLocked
(
aTransform
.
mWritable
)
)
{
aRv
.
ThrowTypeError
(
"
Cannot
pipe
to
a
locked
stream
.
"
)
;
return
nullptr
;
}
RefPtr
<
AbortSignal
>
signal
=
aOptions
.
mSignal
.
WasPassed
(
)
?
&
aOptions
.
mSignal
.
Value
(
)
:
nullptr
;
RefPtr
<
WritableStream
>
writable
=
aTransform
.
mWritable
;
RefPtr
<
Promise
>
promise
=
ReadableStreamPipeTo
(
this
writable
aOptions
.
mPreventClose
aOptions
.
mPreventAbort
aOptions
.
mPreventCancel
signal
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
MOZ_ALWAYS_TRUE
(
promise
-
>
SetAnyPromiseIsHandled
(
)
)
;
return
do_AddRef
(
aTransform
.
mReadable
.
get
(
)
)
;
}
;
double
ReadableStreamGetNumReadRequests
(
ReadableStream
*
aStream
)
{
MOZ_ASSERT
(
ReadableStreamHasDefaultReader
(
aStream
)
)
;
return
double
(
aStream
-
>
GetDefaultReader
(
)
-
>
ReadRequests
(
)
.
length
(
)
)
;
}
void
ReadableStreamError
(
JSContext
*
aCx
ReadableStream
*
aStream
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aStream
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
;
aStream
-
>
SetState
(
ReadableStream
:
:
ReaderState
:
:
Errored
)
;
aStream
-
>
SetStoredError
(
aValue
)
;
ReadableStreamGenericReader
*
reader
=
aStream
-
>
GetReader
(
)
;
if
(
!
reader
)
{
return
;
}
reader
-
>
ClosedPromise
(
)
-
>
MaybeReject
(
aValue
)
;
reader
-
>
ClosedPromise
(
)
-
>
SetSettledPromiseIsHandled
(
)
;
if
(
reader
-
>
IsDefault
(
)
)
{
RefPtr
<
ReadableStreamDefaultReader
>
defaultReader
=
reader
-
>
AsDefault
(
)
;
ReadableStreamDefaultReaderErrorReadRequests
(
aCx
defaultReader
aValue
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
else
{
MOZ_ASSERT
(
reader
-
>
IsBYOB
(
)
)
;
RefPtr
<
ReadableStreamBYOBReader
>
byobReader
=
reader
-
>
AsBYOB
(
)
;
ReadableStreamBYOBReaderErrorReadIntoRequests
(
aCx
byobReader
aValue
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
}
void
ReadableStreamFulfillReadRequest
(
JSContext
*
aCx
ReadableStream
*
aStream
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
bool
aDone
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
ReadableStreamHasDefaultReader
(
aStream
)
)
;
ReadableStreamDefaultReader
*
reader
=
aStream
-
>
GetDefaultReader
(
)
;
MOZ_ASSERT
(
!
reader
-
>
ReadRequests
(
)
.
isEmpty
(
)
)
;
RefPtr
<
ReadRequest
>
readRequest
=
reader
-
>
ReadRequests
(
)
.
popFirst
(
)
;
if
(
aDone
)
{
readRequest
-
>
CloseSteps
(
aCx
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
readRequest
-
>
ChunkSteps
(
aCx
aChunk
aRv
)
;
}
void
ReadableStreamAddReadRequest
(
ReadableStream
*
aStream
ReadRequest
*
aReadRequest
)
{
MOZ_ASSERT
(
aStream
-
>
GetReader
(
)
-
>
IsDefault
(
)
)
;
MOZ_ASSERT
(
aStream
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
;
aStream
-
>
GetDefaultReader
(
)
-
>
ReadRequests
(
)
.
insertBack
(
aReadRequest
)
;
}
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
ReadableStreamDefaultTeeSourceAlgorithms
:
:
CancelCallback
(
JSContext
*
aCx
const
Optional
<
JS
:
:
Handle
<
JS
:
:
Value
>
>
&
aReason
ErrorResult
&
aRv
)
{
mTeeState
-
>
SetCanceled
(
mBranch
true
)
;
mTeeState
-
>
SetReason
(
mBranch
aReason
.
Value
(
)
)
;
if
(
mTeeState
-
>
Canceled
(
OtherTeeBranch
(
mBranch
)
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
compositeReason
(
aCx
JS
:
:
NewArrayObject
(
aCx
2
)
)
;
if
(
!
compositeReason
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
nullptr
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
reason1
(
aCx
mTeeState
-
>
Reason1
(
)
)
;
if
(
!
JS_SetElement
(
aCx
compositeReason
0
reason1
)
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
nullptr
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
reason2
(
aCx
mTeeState
-
>
Reason2
(
)
)
;
if
(
!
JS_SetElement
(
aCx
compositeReason
1
reason2
)
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
nullptr
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
compositeReasonValue
(
aCx
JS
:
:
ObjectValue
(
*
compositeReason
)
)
;
RefPtr
<
ReadableStream
>
stream
(
mTeeState
-
>
GetStream
(
)
)
;
RefPtr
<
Promise
>
cancelResult
=
ReadableStreamCancel
(
aCx
stream
compositeReasonValue
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
mTeeState
-
>
CancelPromise
(
)
-
>
MaybeResolve
(
cancelResult
)
;
}
return
do_AddRef
(
mTeeState
-
>
CancelPromise
(
)
)
;
}
MOZ_CAN_RUN_SCRIPT
static
void
ReadableStreamDefaultTee
(
JSContext
*
aCx
ReadableStream
*
aStream
bool
aCloneForBranch2
nsTArray
<
RefPtr
<
ReadableStream
>
>
&
aResult
ErrorResult
&
aRv
)
{
RefPtr
<
TeeState
>
teeState
=
TeeState
:
:
Create
(
aStream
aCloneForBranch2
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
auto
branch1Algorithms
=
MakeRefPtr
<
ReadableStreamDefaultTeeSourceAlgorithms
>
(
teeState
TeeBranch
:
:
Branch1
)
;
auto
branch2Algorithms
=
MakeRefPtr
<
ReadableStreamDefaultTeeSourceAlgorithms
>
(
teeState
TeeBranch
:
:
Branch2
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
(
do_AddRef
(
teeState
-
>
GetStream
(
)
-
>
GetParentObject
(
)
)
)
;
teeState
-
>
SetBranch1
(
CreateReadableStream
(
aCx
global
branch1Algorithms
mozilla
:
:
Nothing
(
)
nullptr
aRv
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
teeState
-
>
SetBranch2
(
CreateReadableStream
(
aCx
global
branch2Algorithms
mozilla
:
:
Nothing
(
)
nullptr
aRv
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
teeState
-
>
GetReader
(
)
-
>
ClosedPromise
(
)
-
>
AddCallbacksWithCycleCollectedArgs
(
[
]
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
TeeState
*
aTeeState
)
{
}
[
]
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
TeeState
*
aTeeState
)
{
ReadableStreamDefaultControllerError
(
aCx
aTeeState
-
>
Branch1
(
)
-
>
DefaultController
(
)
aReason
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
ReadableStreamDefaultControllerError
(
aCx
aTeeState
-
>
Branch2
(
)
-
>
DefaultController
(
)
aReason
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
!
aTeeState
-
>
Canceled1
(
)
|
|
!
aTeeState
-
>
Canceled2
(
)
)
{
aTeeState
-
>
CancelPromise
(
)
-
>
MaybeResolveWithUndefined
(
)
;
}
}
RefPtr
(
teeState
)
)
;
aResult
.
AppendElement
(
teeState
-
>
Branch1
(
)
)
;
aResult
.
AppendElement
(
teeState
-
>
Branch2
(
)
)
;
}
already_AddRefed
<
Promise
>
ReadableStream
:
:
PipeTo
(
WritableStream
&
aDestination
const
StreamPipeOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
IsReadableStreamLocked
(
this
)
)
{
aRv
.
ThrowTypeError
(
"
Cannot
pipe
from
a
locked
stream
.
"
)
;
return
nullptr
;
}
if
(
IsWritableStreamLocked
(
&
aDestination
)
)
{
aRv
.
ThrowTypeError
(
"
Cannot
pipe
to
a
locked
stream
.
"
)
;
return
nullptr
;
}
RefPtr
<
AbortSignal
>
signal
=
aOptions
.
mSignal
.
WasPassed
(
)
?
&
aOptions
.
mSignal
.
Value
(
)
:
nullptr
;
return
ReadableStreamPipeTo
(
this
&
aDestination
aOptions
.
mPreventClose
aOptions
.
mPreventAbort
aOptions
.
mPreventCancel
signal
aRv
)
;
}
MOZ_CAN_RUN_SCRIPT
static
void
ReadableStreamTee
(
JSContext
*
aCx
ReadableStream
*
aStream
bool
aCloneForBranch2
nsTArray
<
RefPtr
<
ReadableStream
>
>
&
aResult
ErrorResult
&
aRv
)
{
if
(
aStream
-
>
Controller
(
)
-
>
IsByte
(
)
)
{
ReadableByteStreamTee
(
aCx
aStream
aResult
aRv
)
;
return
;
}
ReadableStreamDefaultTee
(
aCx
aStream
aCloneForBranch2
aResult
aRv
)
;
}
void
ReadableStream
:
:
Tee
(
JSContext
*
aCx
nsTArray
<
RefPtr
<
ReadableStream
>
>
&
aResult
ErrorResult
&
aRv
)
{
ReadableStreamTee
(
aCx
this
false
aResult
aRv
)
;
}
void
ReadableStream
:
:
IteratorData
:
:
Traverse
(
nsCycleCollectionTraversalCallback
&
cb
)
{
ReadableStream
:
:
IteratorData
*
tmp
=
this
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mReader
)
;
}
void
ReadableStream
:
:
IteratorData
:
:
Unlink
(
)
{
ReadableStream
:
:
IteratorData
*
tmp
=
this
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mReader
)
;
}
void
ReadableStream
:
:
InitAsyncIteratorData
(
IteratorData
&
aData
Iterator
:
:
IteratorType
aType
const
ReadableStreamIteratorOptions
&
aOptions
ErrorResult
&
aRv
)
{
RefPtr
<
ReadableStreamDefaultReader
>
reader
=
AcquireReadableStreamDefaultReader
(
this
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aData
.
mReader
=
reader
;
aData
.
mPreventCancel
=
aOptions
.
mPreventCancel
;
}
struct
IteratorReadRequest
:
public
ReadRequest
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
IteratorReadRequest
ReadRequest
)
RefPtr
<
Promise
>
mPromise
;
RefPtr
<
ReadableStreamDefaultReader
>
mReader
;
explicit
IteratorReadRequest
(
Promise
*
aPromise
ReadableStreamDefaultReader
*
aReader
)
:
mPromise
(
aPromise
)
mReader
(
aReader
)
{
}
void
ChunkSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
override
{
mPromise
-
>
MaybeResolve
(
aChunk
)
;
}
void
CloseSteps
(
JSContext
*
aCx
ErrorResult
&
aRv
)
override
{
ReadableStreamDefaultReaderRelease
(
aCx
mReader
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
mPromise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
iterator_utils
:
:
ResolvePromiseForFinished
(
mPromise
)
;
}
void
ErrorSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
override
{
ReadableStreamDefaultReaderRelease
(
aCx
mReader
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
mPromise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
mPromise
-
>
MaybeReject
(
aError
)
;
}
protected
:
virtual
~
IteratorReadRequest
(
)
=
default
;
}
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
IteratorReadRequest
ReadRequest
mPromise
mReader
)
NS_IMPL_ADDREF_INHERITED
(
IteratorReadRequest
ReadRequest
)
NS_IMPL_RELEASE_INHERITED
(
IteratorReadRequest
ReadRequest
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
IteratorReadRequest
)
NS_INTERFACE_MAP_END_INHERITING
(
ReadRequest
)
already_AddRefed
<
Promise
>
ReadableStream
:
:
GetNextIterationResult
(
Iterator
*
aIterator
ErrorResult
&
aRv
)
{
RefPtr
<
ReadableStreamDefaultReader
>
reader
=
aIterator
-
>
Data
(
)
.
mReader
;
MOZ_ASSERT
(
reader
-
>
GetStream
(
)
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
ReadRequest
>
request
=
new
IteratorReadRequest
(
promise
reader
)
;
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
mGlobal
)
)
{
aRv
.
ThrowUnknownError
(
"
Internal
error
"
)
;
return
nullptr
;
}
ReadableStreamDefaultReaderRead
(
jsapi
.
cx
(
)
reader
request
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
ReadableStream
:
:
IteratorReturn
(
JSContext
*
aCx
Iterator
*
aIterator
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
RefPtr
<
ReadableStreamDefaultReader
>
reader
=
aIterator
-
>
Data
(
)
.
mReader
;
MOZ_ASSERT
(
reader
-
>
GetStream
(
)
)
;
MOZ_ASSERT
(
reader
-
>
ReadRequests
(
)
.
isEmpty
(
)
)
;
if
(
!
aIterator
-
>
Data
(
)
.
mPreventCancel
)
{
RefPtr
<
ReadableStream
>
stream
(
reader
-
>
GetStream
(
)
)
;
RefPtr
<
Promise
>
result
=
ReadableStreamCancel
(
aCx
stream
aValue
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
ReadableStreamDefaultReaderRelease
(
aCx
reader
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
return
result
.
forget
(
)
;
}
ReadableStreamDefaultReaderRelease
(
aCx
reader
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
return
Promise
:
:
CreateResolvedWithUndefined
(
GetParentObject
(
)
aRv
)
;
}
void
ReadableStreamAddReadIntoRequest
(
ReadableStream
*
aStream
ReadIntoRequest
*
aReadIntoRequest
)
{
MOZ_ASSERT
(
aStream
-
>
GetReader
(
)
-
>
IsBYOB
(
)
)
;
MOZ_ASSERT
(
aStream
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
|
|
aStream
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Closed
)
;
aStream
-
>
GetReader
(
)
-
>
AsBYOB
(
)
-
>
ReadIntoRequests
(
)
.
insertBack
(
aReadIntoRequest
)
;
}
already_AddRefed
<
ReadableStream
>
CreateReadableByteStream
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
UnderlyingSourceAlgorithmsBase
*
aAlgorithms
ErrorResult
&
aRv
)
{
RefPtr
<
ReadableStream
>
stream
=
new
ReadableStream
(
aGlobal
)
;
InitializeReadableStream
(
stream
)
;
RefPtr
<
ReadableByteStreamController
>
controller
=
new
ReadableByteStreamController
(
aGlobal
)
;
SetUpReadableByteStreamController
(
aCx
stream
controller
aAlgorithms
0
mozilla
:
:
Nothing
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
stream
.
forget
(
)
;
}
already_AddRefed
<
ReadableStream
>
ReadableStream
:
:
CreateByteNative
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
UnderlyingSourceAlgorithmsWrapper
&
aAlgorithms
mozilla
:
:
Maybe
<
double
>
aHighWaterMark
ErrorResult
&
aRv
)
{
double
highWaterMark
=
aHighWaterMark
.
valueOr
(
0
)
;
auto
stream
=
MakeRefPtr
<
ReadableStream
>
(
aGlobal
)
;
auto
controller
=
MakeRefPtr
<
ReadableByteStreamController
>
(
aGlobal
)
;
SetUpReadableByteStreamController
(
aCx
stream
controller
&
aAlgorithms
highWaterMark
Nothing
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
stream
.
forget
(
)
;
}
void
ReadableStream
:
:
CloseNative
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mController
-
>
GetAlgorithms
(
)
-
>
IsNative
(
)
)
;
if
(
mController
-
>
IsByte
(
)
)
{
RefPtr
<
ReadableByteStreamController
>
controller
=
mController
-
>
AsByte
(
)
;
ReadableByteStreamControllerClose
(
aCx
controller
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
!
controller
-
>
PendingPullIntos
(
)
.
isEmpty
(
)
)
{
ReadableByteStreamControllerRespond
(
aCx
controller
0
aRv
)
;
}
return
;
}
RefPtr
<
ReadableStreamDefaultController
>
controller
=
mController
-
>
AsDefault
(
)
;
ReadableStreamDefaultControllerClose
(
aCx
controller
aRv
)
;
}
void
ReadableStream
:
:
ErrorNative
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
{
if
(
mController
-
>
IsByte
(
)
)
{
ReadableByteStreamControllerError
(
mController
-
>
AsByte
(
)
aError
aRv
)
;
return
;
}
ReadableStreamDefaultControllerError
(
aCx
mController
-
>
AsDefault
(
)
aError
aRv
)
;
}
static
void
CurrentBYOBRequestView
(
JSContext
*
aCx
ReadableByteStreamController
&
aController
JS
:
:
MutableHandle
<
JSObject
*
>
aRetVal
ErrorResult
&
aRv
)
{
RefPtr
<
ReadableStreamBYOBRequest
>
byobRequest
=
ReadableByteStreamControllerGetBYOBRequest
(
aCx
&
aController
aRv
)
;
if
(
!
byobRequest
)
{
aRetVal
.
set
(
nullptr
)
;
return
;
}
byobRequest
-
>
GetView
(
aCx
aRetVal
)
;
}
static
bool
HasSameBufferView
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aX
JS
:
:
Handle
<
JSObject
*
>
aY
ErrorResult
&
aRv
)
{
bool
isShared
;
JS
:
:
Rooted
<
JSObject
*
>
viewedBufferX
(
aCx
JS_GetArrayBufferViewBuffer
(
aCx
aX
&
isShared
)
)
;
if
(
!
viewedBufferX
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
viewedBufferY
(
aCx
JS_GetArrayBufferViewBuffer
(
aCx
aY
&
isShared
)
)
;
if
(
!
viewedBufferY
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
false
;
}
return
viewedBufferX
=
=
viewedBufferY
;
}
void
ReadableStream
:
:
EnqueueNative
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mController
-
>
GetAlgorithms
(
)
-
>
IsNative
(
)
)
;
if
(
mController
-
>
IsDefault
(
)
)
{
RefPtr
<
ReadableStreamDefaultController
>
controller
=
mController
-
>
AsDefault
(
)
;
ReadableStreamDefaultControllerEnqueue
(
aCx
controller
aChunk
aRv
)
;
return
;
}
MOZ_ASSERT
(
mController
-
>
IsByte
(
)
)
;
RefPtr
<
ReadableByteStreamController
>
controller
=
mController
-
>
AsByte
(
)
;
MOZ_ASSERT
(
aChunk
.
isObject
(
)
&
&
JS_IsArrayBufferViewObject
(
&
aChunk
.
toObject
(
)
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
chunk
(
aCx
&
aChunk
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
byobView
(
aCx
)
;
CurrentBYOBRequestView
(
aCx
*
controller
&
byobView
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
byobView
&
&
HasSameBufferView
(
aCx
chunk
byobView
aRv
)
)
{
MOZ_ASSERT
(
JS_GetArrayBufferViewByteOffset
(
chunk
)
=
=
JS_GetArrayBufferViewByteOffset
(
byobView
)
)
;
MOZ_ASSERT
(
JS_GetArrayBufferViewByteLength
(
chunk
)
=
=
JS_GetArrayBufferViewByteLength
(
byobView
)
)
;
ReadableByteStreamControllerRespond
(
aCx
controller
JS_GetArrayBufferViewByteLength
(
chunk
)
aRv
)
;
return
;
}
if
(
aRv
.
Failed
(
)
)
{
return
;
}
ReadableByteStreamControllerEnqueue
(
aCx
controller
chunk
aRv
)
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
ReadableStreamDefaultReader
>
ReadableStream
:
:
GetReader
(
ErrorResult
&
aRv
)
{
return
AcquireReadableStreamDefaultReader
(
this
aRv
)
;
}
}
