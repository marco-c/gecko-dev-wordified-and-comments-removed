function
assertEq
(
a
b
)
{
Assert
.
equal
(
a
b
)
;
}
function
assertThrowsInstanceOf
(
fun
err
)
{
var
regexp
=
new
RegExp
(
err
.
name
)
;
print
(
regexp
)
;
Assert
.
throws
(
fun
regexp
)
;
}
class
PartyStreamer
extends
ReadableStream
{
}
let
started
=
false
;
add_task
(
function
subclass_helper
(
)
{
let
stream
=
new
PartyStreamer
(
{
start
(
)
{
started
=
true
;
}
}
)
;
assertEq
(
started
true
)
;
assertEq
(
stream
.
__proto__
PartyStreamer
.
prototype
)
;
assertEq
(
stream
.
__proto__
.
__proto__
ReadableStream
.
prototype
)
;
assertEq
(
stream
.
__proto__
.
__proto__
.
__proto__
Object
.
prototype
)
;
assertEq
(
stream
.
__proto__
.
__proto__
.
__proto__
.
__proto__
null
)
;
assertEq
(
stream
instanceof
ReadableStream
true
)
;
stream
.
getReader
(
)
;
assertEq
(
stream
.
locked
true
)
;
}
)
;
add_task
(
function
strategy_helper
(
)
{
class
PixelStrategy
extends
CountQueuingStrategy
{
}
assertEq
(
new
PixelStrategy
(
{
highWaterMark
:
4
}
)
.
__proto__
PixelStrategy
.
prototype
)
;
assertThrowsInstanceOf
(
(
)
=
>
new
PixelStrategy
(
)
TypeError
)
;
assertEq
(
new
PixelStrategy
(
{
highWaterMark
:
-
1
}
)
.
highWaterMark
-
1
)
;
}
)
;
add_task
(
async
function
readerTest
(
)
{
const
ReadableStreamDefaultReader
=
new
ReadableStream
(
)
.
getReader
(
)
.
constructor
;
class
MindReader
extends
ReadableStreamDefaultReader
{
async
read
(
)
{
let
foretold
=
{
value
:
"
death
"
done
:
false
}
;
let
actual
=
await
super
.
read
(
)
;
actual
=
foretold
;
return
actual
;
}
}
let
stream
=
new
ReadableStream
(
{
start
(
c
)
{
c
.
enqueue
(
"
one
"
)
;
c
.
enqueue
(
"
two
"
)
;
}
pull
(
c
)
{
c
.
close
(
)
;
}
}
)
;
let
reader
=
new
MindReader
(
stream
)
;
let
result
=
await
reader
.
read
(
)
;
assertEq
(
result
.
value
"
death
"
)
;
reader
.
releaseLock
(
)
;
reader
=
stream
.
getReader
(
)
;
result
=
await
reader
.
read
(
)
;
assertEq
(
result
.
done
false
)
;
assertEq
(
result
.
value
"
two
"
)
;
result
=
await
reader
.
read
(
)
;
assertEq
(
result
.
done
true
)
;
assertEq
(
result
.
value
undefined
)
;
}
)
;
add_task
(
function
default_controller
(
)
{
let
ReadableStreamDefaultController
;
new
ReadableStream
(
{
start
(
c
)
{
ReadableStreamDefaultController
=
c
.
constructor
;
}
}
)
;
class
MasterController
extends
ReadableStreamDefaultController
{
constructor
(
)
{
return
Object
.
create
(
MasterController
.
prototype
)
;
}
}
let
c
=
new
MasterController
(
)
;
assertEq
(
c
instanceof
ReadableStreamDefaultController
true
)
;
assertThrowsInstanceOf
(
(
)
=
>
c
.
enqueue
(
"
horse
"
)
TypeError
)
;
}
)
;
