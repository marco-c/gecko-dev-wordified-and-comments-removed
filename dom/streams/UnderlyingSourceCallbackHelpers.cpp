#
include
"
StreamUtils
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamDefaultController
.
h
"
#
include
"
mozilla
/
dom
/
ReadableByteStreamController
.
h
"
#
include
"
mozilla
/
dom
/
UnderlyingSourceCallbackHelpers
.
h
"
#
include
"
mozilla
/
dom
/
UnderlyingSourceBinding
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRunnable
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
nsStreamUtils
.
h
"
namespace
mozilla
:
:
dom
{
using
namespace
streams_abstract
;
NS_IMPL_CYCLE_COLLECTION
(
UnderlyingSourceAlgorithmsBase
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
UnderlyingSourceAlgorithmsBase
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
UnderlyingSourceAlgorithmsBase
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
UnderlyingSourceAlgorithmsBase
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_INHERITED_WITH_JS_MEMBERS
(
UnderlyingSourceAlgorithms
UnderlyingSourceAlgorithmsBase
(
mGlobal
mStartCallback
mPullCallback
mCancelCallback
)
(
mUnderlyingSource
)
)
NS_IMPL_ADDREF_INHERITED
(
UnderlyingSourceAlgorithms
UnderlyingSourceAlgorithmsBase
)
NS_IMPL_RELEASE_INHERITED
(
UnderlyingSourceAlgorithms
UnderlyingSourceAlgorithmsBase
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
UnderlyingSourceAlgorithms
)
NS_INTERFACE_MAP_END_INHERITING
(
UnderlyingSourceAlgorithmsBase
)
void
UnderlyingSourceAlgorithms
:
:
StartCallback
(
JSContext
*
aCx
ReadableStreamControllerBase
&
aController
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetVal
ErrorResult
&
aRv
)
{
if
(
!
mStartCallback
)
{
aRetVal
.
setUndefined
(
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
thisObj
(
aCx
mUnderlyingSource
)
;
ReadableStreamDefaultControllerOrReadableByteStreamController
controller
;
if
(
aController
.
IsDefault
(
)
)
{
controller
.
SetAsReadableStreamDefaultController
(
)
=
aController
.
AsDefault
(
)
;
}
else
{
controller
.
SetAsReadableByteStreamController
(
)
=
aController
.
AsByte
(
)
;
}
return
mStartCallback
-
>
Call
(
thisObj
controller
aRetVal
aRv
"
UnderlyingSource
.
start
"
CallbackFunction
:
:
eRethrowExceptions
)
;
}
already_AddRefed
<
Promise
>
UnderlyingSourceAlgorithms
:
:
PullCallback
(
JSContext
*
aCx
ReadableStreamControllerBase
&
aController
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JSObject
*
>
thisObj
(
aCx
mUnderlyingSource
)
;
if
(
!
mPullCallback
)
{
return
Promise
:
:
CreateResolvedWithUndefined
(
mGlobal
aRv
)
;
}
ReadableStreamDefaultControllerOrReadableByteStreamController
controller
;
if
(
aController
.
IsDefault
(
)
)
{
controller
.
SetAsReadableStreamDefaultController
(
)
=
aController
.
AsDefault
(
)
;
}
else
{
controller
.
SetAsReadableByteStreamController
(
)
=
aController
.
AsByte
(
)
;
}
RefPtr
<
Promise
>
promise
=
mPullCallback
-
>
Call
(
thisObj
controller
aRv
"
UnderlyingSource
.
pull
"
CallbackFunction
:
:
eRethrowExceptions
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
UnderlyingSourceAlgorithms
:
:
CancelCallback
(
JSContext
*
aCx
const
Optional
<
JS
:
:
Handle
<
JS
:
:
Value
>
>
&
aReason
ErrorResult
&
aRv
)
{
if
(
!
mCancelCallback
)
{
return
Promise
:
:
CreateResolvedWithUndefined
(
mGlobal
aRv
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
thisObj
(
aCx
mUnderlyingSource
)
;
RefPtr
<
Promise
>
promise
=
mCancelCallback
-
>
Call
(
thisObj
aReason
aRv
"
UnderlyingSource
.
cancel
"
CallbackFunction
:
:
eRethrowExceptions
)
;
return
promise
.
forget
(
)
;
}
void
UnderlyingSourceAlgorithmsWrapper
:
:
StartCallback
(
JSContext
*
ReadableStreamControllerBase
&
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetVal
ErrorResult
&
)
{
aRetVal
.
setUndefined
(
)
;
}
already_AddRefed
<
Promise
>
UnderlyingSourceAlgorithmsWrapper
:
:
PullCallback
(
JSContext
*
aCx
ReadableStreamControllerBase
&
aController
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
aController
.
GetParentObject
(
)
;
return
PromisifyAlgorithm
(
global
[
&
]
(
ErrorResult
&
aRv
)
MOZ_CAN_RUN_SCRIPT_FOR_DEFINITION
{
return
PullCallbackImpl
(
aCx
aController
aRv
)
;
}
aRv
)
;
}
already_AddRefed
<
Promise
>
UnderlyingSourceAlgorithmsWrapper
:
:
CancelCallback
(
JSContext
*
aCx
const
Optional
<
JS
:
:
Handle
<
JS
:
:
Value
>
>
&
aReason
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
return
PromisifyAlgorithm
(
global
[
&
]
(
ErrorResult
&
aRv
)
MOZ_CAN_RUN_SCRIPT_FOR_DEFINITION
{
return
CancelCallbackImpl
(
aCx
aReason
aRv
)
;
}
aRv
)
;
}
NS_IMPL_ISUPPORTS
(
InputStreamHolder
nsIInputStreamCallback
)
InputStreamHolder
:
:
InputStreamHolder
(
nsIGlobalObject
*
aGlobal
InputToReadableStreamAlgorithms
*
aCallback
nsIAsyncInputStream
*
aInput
)
:
GlobalTeardownObserver
(
aGlobal
)
mCallback
(
aCallback
)
mInput
(
aInput
)
{
}
void
InputStreamHolder
:
:
Init
(
JSContext
*
aCx
)
{
if
(
!
NS_IsMainThread
(
)
)
{
WorkerPrivate
*
workerPrivate
=
GetWorkerPrivateFromContext
(
aCx
)
;
MOZ_ASSERT
(
workerPrivate
)
;
workerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
mWorkerRef
=
StrongWorkerRef
:
:
Create
(
workerPrivate
"
InputStreamHolder
"
[
self
=
RefPtr
{
this
}
]
(
)
{
}
)
;
if
(
NS_WARN_IF
(
!
mWorkerRef
)
)
{
return
;
}
}
}
InputStreamHolder
:
:
~
InputStreamHolder
(
)
=
default
;
void
InputStreamHolder
:
:
DisconnectFromOwner
(
)
{
Shutdown
(
)
;
GlobalTeardownObserver
:
:
DisconnectFromOwner
(
)
;
}
void
InputStreamHolder
:
:
Shutdown
(
)
{
if
(
mInput
)
{
mInput
-
>
Close
(
)
;
}
mAsyncWaitAlgorithms
=
nullptr
;
mWorkerRef
=
nullptr
;
}
nsresult
InputStreamHolder
:
:
AsyncWait
(
uint32_t
aFlags
uint32_t
aRequestedCount
nsIEventTarget
*
aEventTarget
)
{
nsresult
rv
=
mInput
-
>
AsyncWait
(
this
aFlags
aRequestedCount
aEventTarget
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mAsyncWaitWorkerRef
=
mWorkerRef
;
mAsyncWaitAlgorithms
=
mCallback
;
}
return
rv
;
}
NS_IMETHODIMP
InputStreamHolder
:
:
OnInputStreamReady
(
nsIAsyncInputStream
*
aStream
)
{
mAsyncWaitWorkerRef
=
nullptr
;
mAsyncWaitAlgorithms
=
nullptr
;
if
(
mCallback
)
{
return
mCallback
-
>
OnInputStreamReady
(
aStream
)
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED
(
InputToReadableStreamAlgorithms
UnderlyingSourceAlgorithmsWrapper
nsIInputStreamCallback
)
NS_IMPL_CYCLE_COLLECTION_WEAK_PTR_INHERITED
(
InputToReadableStreamAlgorithms
UnderlyingSourceAlgorithmsWrapper
mPullPromise
mStream
)
InputToReadableStreamAlgorithms
:
:
InputToReadableStreamAlgorithms
(
JSContext
*
aCx
nsIAsyncInputStream
*
aInput
ReadableStream
*
aStream
)
:
mOwningEventTarget
(
GetCurrentSerialEventTarget
(
)
)
mInput
(
new
InputStreamHolder
(
aStream
-
>
GetParentObject
(
)
this
aInput
)
)
mStream
(
aStream
)
{
mInput
-
>
Init
(
aCx
)
;
}
already_AddRefed
<
Promise
>
InputToReadableStreamAlgorithms
:
:
PullCallbackImpl
(
JSContext
*
aCx
ReadableStreamControllerBase
&
aController
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aController
.
IsByte
(
)
)
;
ReadableStream
*
stream
=
aController
.
Stream
(
)
;
MOZ_ASSERT
(
stream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
stream
-
>
Disturbed
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsClosed
(
)
)
;
MOZ_ASSERT
(
!
mPullPromise
)
;
mPullPromise
=
Promise
:
:
CreateInfallible
(
aController
.
GetParentObject
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInput
)
;
nsresult
rv
=
mInput
-
>
AsyncWait
(
0
0
mOwningEventTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
aCx
stream
rv
)
;
return
nullptr
;
}
return
do_AddRef
(
mPullPromise
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHODIMP
InputToReadableStreamAlgorithms
:
:
OnInputStreamReady
(
nsIAsyncInputStream
*
aStream
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aStream
)
;
if
(
IsClosed
(
)
)
{
return
NS_OK
;
}
AutoEntryScript
aes
(
mStream
-
>
GetParentObject
(
)
"
InputToReadableStream
data
available
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInput
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
uint64_t
size
=
0
;
nsresult
rv
=
mInput
-
>
Available
(
&
size
)
;
MOZ_ASSERT_IF
(
NS_SUCCEEDED
(
rv
)
size
>
0
)
;
if
(
rv
=
=
NS_BASE_STREAM_CLOSED
|
|
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
cx
mStream
rv
)
;
return
NS_OK
;
}
if
(
!
mPullPromise
)
{
return
NS_OK
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mPullPromise
-
>
State
(
)
=
=
Promise
:
:
PromiseState
:
:
Pending
)
;
ErrorResult
errorResult
;
PullFromInputStream
(
cx
size
errorResult
)
;
errorResult
.
WouldReportJSException
(
)
;
if
(
errorResult
.
Failed
(
)
)
{
ErrorPropagation
(
cx
mStream
errorResult
.
StealNSResult
(
)
)
;
return
NS_OK
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mPullPromise
)
;
if
(
mPullPromise
)
{
mPullPromise
-
>
MaybeResolveWithUndefined
(
)
;
mPullPromise
=
nullptr
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mInput
)
;
if
(
mInput
)
{
rv
=
mInput
-
>
AsyncWait
(
nsIAsyncInputStream
:
:
WAIT_CLOSURE_ONLY
0
mOwningEventTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
cx
mStream
errorResult
.
StealNSResult
(
)
)
;
return
NS_OK
;
}
}
return
NS_OK
;
}
void
InputToReadableStreamAlgorithms
:
:
WriteIntoReadRequestBuffer
(
JSContext
*
aCx
ReadableStream
*
aStream
JS
:
:
Handle
<
JSObject
*
>
aBuffer
uint32_t
aLength
uint32_t
*
aByteWritten
ErrorResult
&
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aBuffer
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aByteWritten
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInput
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsClosed
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mPullPromise
-
>
State
(
)
=
=
Promise
:
:
PromiseState
:
:
Pending
)
;
uint32_t
written
;
nsresult
rv
;
void
*
buffer
;
{
JS
:
:
AutoSuppressGCAnalysis
suppress
;
JS
:
:
AutoCheckCannotGC
noGC
;
bool
isSharedMemory
;
buffer
=
JS_GetArrayBufferViewData
(
aBuffer
&
isSharedMemory
noGC
)
;
MOZ_ASSERT
(
!
isSharedMemory
)
;
rv
=
mInput
-
>
Read
(
static_cast
<
char
*
>
(
buffer
)
aLength
&
written
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
}
*
aByteWritten
=
written
;
if
(
written
=
=
0
)
{
aRv
.
Throw
(
NS_BASE_STREAM_CLOSED
)
;
return
;
}
}
void
InputToReadableStreamAlgorithms
:
:
PullFromInputStream
(
JSContext
*
aCx
uint64_t
aAvailable
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mStream
-
>
Controller
(
)
-
>
IsByte
(
)
)
;
uint64_t
desiredSize
=
aAvailable
;
JS
:
:
Rooted
<
JSObject
*
>
byobView
(
aCx
)
;
mStream
-
>
GetCurrentBYOBRequestView
(
aCx
&
byobView
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
byobView
)
{
desiredSize
=
JS_GetArrayBufferViewByteLength
(
byobView
)
;
}
uint64_t
pullSize
=
std
:
:
min
(
static_cast
<
uint64_t
>
(
256
*
1024
*
1024
)
std
:
:
min
(
aAvailable
desiredSize
)
)
;
if
(
byobView
)
{
uint32_t
bytesWritten
=
0
;
WriteIntoReadRequestBuffer
(
aCx
mStream
byobView
pullSize
&
bytesWritten
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
pullSize
=
=
bytesWritten
)
;
ReadableByteStreamControllerRespond
(
aCx
MOZ_KnownLive
(
mStream
-
>
Controller
(
)
-
>
AsByte
(
)
)
bytesWritten
aRv
)
;
}
else
{
UniquePtr
<
uint8_t
[
]
JS
:
:
FreePolicy
>
buffer
(
static_cast
<
uint8_t
*
>
(
JS_malloc
(
aCx
pullSize
)
)
)
;
if
(
!
buffer
)
{
aRv
.
ThrowTypeError
(
"
Out
of
memory
"
)
;
return
;
}
uint32_t
bytesWritten
=
0
;
nsresult
rv
=
mInput
-
>
Read
(
(
char
*
)
buffer
.
get
(
)
pullSize
&
bytesWritten
)
;
if
(
!
bytesWritten
)
{
rv
=
NS_BASE_STREAM_CLOSED
;
}
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
pullSize
=
=
bytesWritten
)
;
JS
:
:
Rooted
<
JSObject
*
>
view
(
aCx
nsJSUtils
:
:
MoveBufferAsUint8Array
(
aCx
bytesWritten
std
:
:
move
(
buffer
)
)
)
;
if
(
!
view
)
{
JS_ClearPendingException
(
aCx
)
;
aRv
.
ThrowTypeError
(
"
Out
of
memory
"
)
;
return
;
}
ReadableByteStreamControllerEnqueue
(
aCx
MOZ_KnownLive
(
mStream
-
>
Controller
(
)
-
>
AsByte
(
)
)
view
aRv
)
;
}
}
void
InputToReadableStreamAlgorithms
:
:
CloseAndReleaseObjects
(
JSContext
*
aCx
ReadableStream
*
aStream
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsClosed
(
)
)
;
ReleaseObjects
(
)
;
if
(
aStream
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
IgnoredErrorResult
rv
;
aStream
-
>
CloseNative
(
aCx
rv
)
;
NS_WARNING_ASSERTION
(
!
rv
.
Failed
(
)
"
Failed
to
Close
Stream
"
)
;
}
}
void
InputToReadableStreamAlgorithms
:
:
ReleaseObjects
(
)
{
if
(
mInput
)
{
mInput
-
>
CloseWithStatus
(
NS_BASE_STREAM_CLOSED
)
;
mInput
-
>
Shutdown
(
)
;
mInput
=
nullptr
;
}
mPullPromise
=
nullptr
;
}
nsIInputStream
*
InputToReadableStreamAlgorithms
:
:
MaybeGetInputStreamIfUnread
(
)
{
MOZ_ASSERT
(
!
mStream
-
>
Disturbed
(
)
"
Should
be
only
called
on
non
-
disturbed
streams
"
)
;
return
mInput
-
>
GetInputStream
(
)
;
}
void
InputToReadableStreamAlgorithms
:
:
ErrorPropagation
(
JSContext
*
aCx
ReadableStream
*
aStream
nsresult
aError
)
{
if
(
IsClosed
(
)
)
{
return
;
}
if
(
aError
=
=
NS_BASE_STREAM_CLOSED
)
{
CloseAndReleaseObjects
(
aCx
aStream
)
;
return
;
}
ErrorResult
rv
;
rv
.
ThrowTypeError
(
"
Error
in
input
stream
"
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
errorValue
(
aCx
)
;
bool
ok
=
ToJSValue
(
aCx
std
:
:
move
(
rv
)
&
errorValue
)
;
MOZ_RELEASE_ASSERT
(
ok
"
ToJSValue
never
fails
for
ErrorResult
"
)
;
{
IgnoredErrorResult
rv
;
aStream
-
>
ErrorNative
(
aCx
errorValue
rv
)
;
NS_WARNING_ASSERTION
(
!
rv
.
Failed
(
)
"
Failed
to
error
InputToReadableStream
"
)
;
}
MOZ_ASSERT
(
IsClosed
(
)
)
;
}
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
NonAsyncInputToReadableStreamAlgorithms
UnderlyingSourceAlgorithmsWrapper
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
NonAsyncInputToReadableStreamAlgorithms
UnderlyingSourceAlgorithmsWrapper
mAsyncAlgorithms
)
already_AddRefed
<
Promise
>
NonAsyncInputToReadableStreamAlgorithms
:
:
PullCallbackImpl
(
JSContext
*
aCx
ReadableStreamControllerBase
&
aController
ErrorResult
&
aRv
)
{
if
(
!
mAsyncAlgorithms
)
{
nsCOMPtr
<
nsIAsyncInputStream
>
asyncStream
;
nsresult
rv
=
NS_MakeAsyncNonBlockingInputStream
(
mInput
.
forget
(
)
getter_AddRefs
(
asyncStream
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
nullptr
;
}
mAsyncAlgorithms
=
MakeRefPtr
<
InputToReadableStreamAlgorithms
>
(
aCx
asyncStream
aController
.
Stream
(
)
)
;
}
MOZ_ASSERT
(
!
mInput
)
;
return
mAsyncAlgorithms
-
>
PullCallbackImpl
(
aCx
aController
aRv
)
;
}
}
