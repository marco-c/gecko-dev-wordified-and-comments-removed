#
ifndef
mozilla_dom_TeeState_h
#
define
mozilla_dom_TeeState_h
#
include
"
mozilla
/
HoldDropJSObjects
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamDefaultReader
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
nsISupportsBase
.
h
"
namespace
mozilla
:
:
dom
{
class
ReadableStreamDefaultTeePullAlgorithm
;
enum
class
TeeBranch
:
bool
{
Branch1
Branch2
}
;
inline
TeeBranch
OtherTeeBranch
(
TeeBranch
aBranch
)
{
if
(
aBranch
=
=
TeeBranch
:
:
Branch1
)
{
return
TeeBranch
:
:
Branch2
;
}
return
TeeBranch
:
:
Branch1
;
}
struct
TeeState
:
public
nsISupports
{
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
TeeState
)
static
already_AddRefed
<
TeeState
>
Create
(
ReadableStream
*
aStream
bool
aCloneForBranch2
ErrorResult
&
aRv
)
;
ReadableStream
*
GetStream
(
)
const
{
return
mStream
;
}
void
SetStream
(
ReadableStream
*
aStream
)
{
mStream
=
aStream
;
}
ReadableStreamGenericReader
*
GetReader
(
)
const
{
return
mReader
;
}
void
SetReader
(
ReadableStreamGenericReader
*
aReader
)
{
mReader
=
aReader
;
}
ReadableStreamDefaultReader
*
GetDefaultReader
(
)
const
{
return
mReader
-
>
AsDefault
(
)
;
}
bool
ReadAgain
(
)
const
{
return
mReadAgain
;
}
void
SetReadAgain
(
bool
aReadAgain
)
{
mReadAgain
=
aReadAgain
;
}
bool
ReadAgainForBranch1
(
)
const
{
return
ReadAgain
(
)
;
}
void
SetReadAgainForBranch1
(
bool
aReadAgainForBranch1
)
{
SetReadAgain
(
aReadAgainForBranch1
)
;
}
bool
ReadAgainForBranch2
(
)
const
{
return
mReadAgainForBranch2
;
}
void
SetReadAgainForBranch2
(
bool
aReadAgainForBranch2
)
{
mReadAgainForBranch2
=
aReadAgainForBranch2
;
}
bool
Reading
(
)
const
{
return
mReading
;
}
void
SetReading
(
bool
aReading
)
{
mReading
=
aReading
;
}
bool
Canceled1
(
)
const
{
return
mCanceled1
;
}
void
SetCanceled1
(
bool
aCanceled1
)
{
mCanceled1
=
aCanceled1
;
}
bool
Canceled2
(
)
const
{
return
mCanceled2
;
}
void
SetCanceled2
(
bool
aCanceled2
)
{
mCanceled2
=
aCanceled2
;
}
void
SetCanceled
(
TeeBranch
aBranch
bool
aCanceled
)
{
aBranch
=
=
TeeBranch
:
:
Branch1
?
SetCanceled1
(
aCanceled
)
:
SetCanceled2
(
aCanceled
)
;
}
bool
Canceled
(
TeeBranch
aBranch
)
{
return
aBranch
=
=
TeeBranch
:
:
Branch1
?
Canceled1
(
)
:
Canceled2
(
)
;
}
JS
:
:
Value
Reason1
(
)
const
{
return
mReason1
;
}
void
SetReason1
(
JS
:
:
HandleValue
aReason1
)
{
mReason1
=
aReason1
;
}
JS
:
:
Value
Reason2
(
)
const
{
return
mReason2
;
}
void
SetReason2
(
JS
:
:
HandleValue
aReason2
)
{
mReason2
=
aReason2
;
}
void
SetReason
(
TeeBranch
aBranch
JS
:
:
HandleValue
aReason
)
{
aBranch
=
=
TeeBranch
:
:
Branch1
?
SetReason1
(
aReason
)
:
SetReason2
(
aReason
)
;
}
ReadableStream
*
Branch1
(
)
const
{
return
mBranch1
;
}
void
SetBranch1
(
already_AddRefed
<
ReadableStream
>
aBranch1
)
{
mBranch1
=
aBranch1
;
}
ReadableStream
*
Branch2
(
)
const
{
return
mBranch2
;
}
void
SetBranch2
(
already_AddRefed
<
ReadableStream
>
aBranch2
)
{
mBranch2
=
aBranch2
;
}
Promise
*
CancelPromise
(
)
const
{
return
mCancelPromise
;
}
void
SetCancelPromise
(
Promise
*
aCancelPromise
)
{
mCancelPromise
=
aCancelPromise
;
}
bool
CloneForBranch2
(
)
const
{
return
mCloneForBranch2
;
}
void
setCloneForBranch2
(
bool
aCloneForBranch2
)
{
mCloneForBranch2
=
aCloneForBranch2
;
}
void
SetPullAlgorithm
(
ReadableStreamDefaultTeePullAlgorithm
*
aPullAlgorithm
)
;
ReadableStreamDefaultTeePullAlgorithm
*
PullAlgorithm
(
)
{
return
mPullAlgorithm
;
}
ReadableStream
*
Branch
(
TeeBranch
aBranch
)
const
{
return
aBranch
=
=
TeeBranch
:
:
Branch1
?
Branch1
(
)
:
Branch2
(
)
;
}
void
SetReadAgainForBranch
(
TeeBranch
aBranch
bool
aValue
)
{
if
(
aBranch
=
=
TeeBranch
:
:
Branch1
)
{
SetReadAgainForBranch1
(
aValue
)
;
return
;
}
SetReadAgainForBranch2
(
aValue
)
;
}
private
:
TeeState
(
ReadableStream
*
aStream
bool
aCloneForBranch2
)
;
RefPtr
<
ReadableStream
>
mStream
;
RefPtr
<
ReadableStreamGenericReader
>
mReader
;
bool
mReading
=
false
;
bool
mReadAgain
=
false
;
bool
mReadAgainForBranch2
=
false
;
bool
mCanceled1
=
false
;
bool
mCanceled2
=
false
;
JS
:
:
Heap
<
JS
:
:
Value
>
mReason1
;
JS
:
:
Heap
<
JS
:
:
Value
>
mReason2
;
RefPtr
<
ReadableStream
>
mBranch1
;
RefPtr
<
ReadableStream
>
mBranch2
;
RefPtr
<
Promise
>
mCancelPromise
;
bool
mCloneForBranch2
=
false
;
RefPtr
<
ReadableStreamDefaultTeePullAlgorithm
>
mPullAlgorithm
;
virtual
~
TeeState
(
)
{
mozilla
:
:
DropJSObjects
(
this
)
;
}
}
;
}
#
endif
