#
include
"
mozilla
/
dom
/
WritableStreamDefaultWriter
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
HoldDropJSObjects
.
h
"
#
include
"
mozilla
/
dom
/
WritableStream
.
h
"
#
include
"
mozilla
/
dom
/
WritableStreamDefaultWriterBinding
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
dom
/
Promise
-
inl
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsISupports
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
WritableStreamDefaultWriter
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
WritableStreamDefaultWriter
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mGlobal
mStream
mReadyPromise
mClosedPromise
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
WritableStreamDefaultWriter
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mGlobal
mStream
mReadyPromise
mClosedPromise
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
WritableStreamDefaultWriter
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
WritableStreamDefaultWriter
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
WritableStreamDefaultWriter
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
WritableStreamDefaultWriter
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
WritableStreamDefaultWriter
:
:
WritableStreamDefaultWriter
(
nsIGlobalObject
*
aGlobal
)
:
mGlobal
(
aGlobal
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
}
WritableStreamDefaultWriter
:
:
~
WritableStreamDefaultWriter
(
)
{
mozilla
:
:
DropJSObjects
(
this
)
;
}
void
WritableStreamDefaultWriter
:
:
SetReadyPromise
(
Promise
*
aPromise
)
{
MOZ_ASSERT
(
aPromise
)
;
mReadyPromise
=
aPromise
;
}
void
WritableStreamDefaultWriter
:
:
SetClosedPromise
(
Promise
*
aPromise
)
{
MOZ_ASSERT
(
aPromise
)
;
mClosedPromise
=
aPromise
;
}
JSObject
*
WritableStreamDefaultWriter
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
WritableStreamDefaultWriter_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
WritableStreamDefaultWriter
>
WritableStreamDefaultWriter
:
:
Constructor
(
const
GlobalObject
&
aGlobal
WritableStream
&
aStream
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
RefPtr
<
WritableStreamDefaultWriter
>
writer
=
new
WritableStreamDefaultWriter
(
global
)
;
SetUpWritableStreamDefaultWriter
(
writer
&
aStream
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
writer
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
WritableStreamDefaultWriter
:
:
Closed
(
)
{
RefPtr
<
Promise
>
closedPromise
=
mClosedPromise
;
return
closedPromise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
WritableStreamDefaultWriter
:
:
Ready
(
)
{
RefPtr
<
Promise
>
readyPromise
=
mReadyPromise
;
return
readyPromise
.
forget
(
)
;
}
Nullable
<
double
>
WritableStreamDefaultWriterGetDesiredSize
(
WritableStreamDefaultWriter
*
aWriter
)
{
RefPtr
<
WritableStream
>
stream
=
aWriter
-
>
GetStream
(
)
;
WritableStream
:
:
WriterState
state
=
stream
-
>
State
(
)
;
if
(
state
=
=
WritableStream
:
:
WriterState
:
:
Errored
|
|
state
=
=
WritableStream
:
:
WriterState
:
:
Erroring
)
{
return
nullptr
;
}
if
(
state
=
=
WritableStream
:
:
WriterState
:
:
Closed
)
{
return
0
.
0
;
}
return
stream
-
>
Controller
(
)
-
>
GetDesiredSize
(
)
;
}
Nullable
<
double
>
WritableStreamDefaultWriter
:
:
GetDesiredSize
(
ErrorResult
&
aRv
)
{
if
(
!
mStream
)
{
aRv
.
ThrowTypeError
(
"
Missing
stream
"
)
;
return
nullptr
;
}
RefPtr
<
WritableStreamDefaultWriter
>
thisRefPtr
=
this
;
return
WritableStreamDefaultWriterGetDesiredSize
(
thisRefPtr
)
;
}
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
WritableStreamDefaultWriterAbort
(
JSContext
*
aCx
WritableStreamDefaultWriter
*
aWriter
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
{
RefPtr
<
WritableStream
>
stream
=
aWriter
-
>
GetStream
(
)
;
MOZ_ASSERT
(
stream
)
;
return
WritableStreamAbort
(
aCx
stream
aReason
aRv
)
;
}
already_AddRefed
<
Promise
>
WritableStreamDefaultWriter
:
:
Abort
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
{
if
(
!
mStream
)
{
aRv
.
ThrowTypeError
(
"
Missing
stream
"
)
;
return
nullptr
;
}
RefPtr
<
WritableStreamDefaultWriter
>
thisRefPtr
=
this
;
return
WritableStreamDefaultWriterAbort
(
aCx
thisRefPtr
aReason
aRv
)
;
}
MOZ_CAN_RUN_SCRIPT
static
already_AddRefed
<
Promise
>
WritableStreamDefaultWriterClose
(
JSContext
*
aCx
WritableStreamDefaultWriter
*
aWriter
ErrorResult
&
aRv
)
{
RefPtr
<
WritableStream
>
stream
=
aWriter
-
>
GetStream
(
)
;
MOZ_ASSERT
(
stream
)
;
return
WritableStreamClose
(
aCx
stream
aRv
)
;
}
already_AddRefed
<
Promise
>
WritableStreamDefaultWriter
:
:
Close
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
RefPtr
<
WritableStream
>
stream
=
mStream
;
if
(
!
stream
)
{
aRv
.
ThrowTypeError
(
"
Missing
stream
"
)
;
return
nullptr
;
}
if
(
stream
-
>
CloseQueuedOrInFlight
(
)
)
{
aRv
.
ThrowTypeError
(
"
Stream
is
closing
"
)
;
return
nullptr
;
}
RefPtr
<
WritableStreamDefaultWriter
>
thisRefPtr
=
this
;
return
WritableStreamDefaultWriterClose
(
aCx
thisRefPtr
aRv
)
;
}
void
WritableStreamDefaultWriterRelease
(
JSContext
*
aCx
WritableStreamDefaultWriter
*
aWriter
ErrorResult
&
aRv
)
{
RefPtr
<
WritableStream
>
stream
=
aWriter
-
>
GetStream
(
)
;
MOZ_ASSERT
(
stream
)
;
MOZ_ASSERT
(
stream
-
>
GetWriter
(
)
=
=
aWriter
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
releasedError
(
RootingCx
(
)
JS
:
:
UndefinedValue
(
)
)
;
{
ErrorResult
rv
;
rv
.
ThrowTypeError
(
"
Releasing
lock
"
)
;
bool
ok
=
ToJSValue
(
aCx
std
:
:
move
(
rv
)
&
releasedError
)
;
MOZ_RELEASE_ASSERT
(
ok
"
must
be
ok
"
)
;
}
WritableStreamDefaultWriterEnsureReadyPromiseRejected
(
aWriter
releasedError
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
WritableStreamDefaultWriterEnsureClosedPromiseRejected
(
aWriter
releasedError
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
stream
-
>
SetWriter
(
nullptr
)
;
aWriter
-
>
SetStream
(
nullptr
)
;
}
void
WritableStreamDefaultWriter
:
:
ReleaseLock
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
RefPtr
<
WritableStream
>
stream
=
mStream
;
if
(
!
stream
)
{
return
;
}
MOZ_ASSERT
(
stream
-
>
GetWriter
(
)
)
;
RefPtr
<
WritableStreamDefaultWriter
>
thisRefPtr
=
this
;
return
WritableStreamDefaultWriterRelease
(
aCx
thisRefPtr
aRv
)
;
}
already_AddRefed
<
Promise
>
WritableStreamDefaultWriterWrite
(
JSContext
*
aCx
WritableStreamDefaultWriter
*
aWriter
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
{
RefPtr
<
WritableStream
>
stream
=
aWriter
-
>
GetStream
(
)
;
MOZ_ASSERT
(
stream
)
;
RefPtr
<
WritableStreamDefaultController
>
controller
=
stream
-
>
Controller
(
)
;
double
chunkSize
=
WritableStreamDefaultControllerGetChunkSize
(
aCx
controller
aChunk
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
stream
!
=
aWriter
-
>
GetStream
(
)
)
{
aRv
.
ThrowTypeError
(
"
Can
not
write
on
WritableStream
owned
by
another
writer
.
"
)
;
return
nullptr
;
}
WritableStream
:
:
WriterState
state
=
stream
-
>
State
(
)
;
if
(
state
=
=
WritableStream
:
:
WriterState
:
:
Errored
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
stream
-
>
StoredError
(
)
)
;
return
Promise
:
:
CreateRejected
(
aWriter
-
>
GetParentObject
(
)
error
aRv
)
;
}
if
(
stream
-
>
CloseQueuedOrInFlight
(
)
|
|
state
=
=
WritableStream
:
:
WriterState
:
:
Closed
)
{
return
Promise
:
:
CreateRejectedWithTypeError
(
aWriter
-
>
GetParentObject
(
)
"
Stream
is
closed
or
closing
"
_ns
aRv
)
;
}
if
(
state
=
=
WritableStream
:
:
WriterState
:
:
Erroring
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
stream
-
>
StoredError
(
)
)
;
return
Promise
:
:
CreateRejected
(
aWriter
-
>
GetParentObject
(
)
error
aRv
)
;
}
MOZ_ASSERT
(
state
=
=
WritableStream
:
:
WriterState
:
:
Writable
)
;
RefPtr
<
Promise
>
promise
=
WritableStreamAddWriteRequest
(
stream
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
WritableStreamDefaultControllerWrite
(
aCx
controller
aChunk
chunkSize
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
WritableStreamDefaultWriter
:
:
Write
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
{
if
(
!
mStream
)
{
aRv
.
ThrowTypeError
(
"
Missing
stream
"
)
;
return
nullptr
;
}
return
WritableStreamDefaultWriterWrite
(
aCx
this
aChunk
aRv
)
;
}
void
SetUpWritableStreamDefaultWriter
(
WritableStreamDefaultWriter
*
aWriter
WritableStream
*
aStream
ErrorResult
&
aRv
)
{
if
(
IsWritableStreamLocked
(
aStream
)
)
{
aRv
.
ThrowTypeError
(
"
WritableStream
is
already
locked
!
"
)
;
return
;
}
aWriter
-
>
SetStream
(
aStream
)
;
aStream
-
>
SetWriter
(
aWriter
)
;
WritableStream
:
:
WriterState
state
=
aStream
-
>
State
(
)
;
if
(
state
=
=
WritableStream
:
:
WriterState
:
:
Writable
)
{
RefPtr
<
Promise
>
readyPromise
=
Promise
:
:
Create
(
aWriter
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
!
aStream
-
>
CloseQueuedOrInFlight
(
)
&
&
aStream
-
>
Backpressure
(
)
)
{
aWriter
-
>
SetReadyPromise
(
readyPromise
)
;
}
else
{
readyPromise
-
>
MaybeResolveWithUndefined
(
)
;
aWriter
-
>
SetReadyPromise
(
readyPromise
)
;
}
RefPtr
<
Promise
>
closedPromise
=
Promise
:
:
Create
(
aWriter
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aWriter
-
>
SetClosedPromise
(
closedPromise
)
;
}
else
if
(
state
=
=
WritableStream
:
:
WriterState
:
:
Erroring
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
storedError
(
RootingCx
(
)
aStream
-
>
StoredError
(
)
)
;
RefPtr
<
Promise
>
readyPromise
=
Promise
:
:
Create
(
aWriter
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
readyPromise
-
>
MaybeReject
(
storedError
)
;
aWriter
-
>
SetReadyPromise
(
readyPromise
)
;
readyPromise
-
>
SetSettledPromiseIsHandled
(
)
;
RefPtr
<
Promise
>
closedPromise
=
Promise
:
:
Create
(
aWriter
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aWriter
-
>
SetClosedPromise
(
closedPromise
)
;
}
else
if
(
state
=
=
WritableStream
:
:
WriterState
:
:
Closed
)
{
RefPtr
<
Promise
>
readyPromise
=
Promise
:
:
CreateResolvedWithUndefined
(
aWriter
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aWriter
-
>
SetReadyPromise
(
readyPromise
)
;
RefPtr
<
Promise
>
closedPromise
=
Promise
:
:
CreateResolvedWithUndefined
(
aWriter
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aWriter
-
>
SetClosedPromise
(
closedPromise
)
;
}
else
{
MOZ_ASSERT
(
state
=
=
WritableStream
:
:
WriterState
:
:
Errored
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
storedError
(
RootingCx
(
)
aStream
-
>
StoredError
(
)
)
;
RefPtr
<
Promise
>
readyPromise
=
Promise
:
:
Create
(
aWriter
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
readyPromise
-
>
MaybeReject
(
storedError
)
;
aWriter
-
>
SetReadyPromise
(
readyPromise
)
;
readyPromise
-
>
SetSettledPromiseIsHandled
(
)
;
RefPtr
<
Promise
>
closedPromise
=
Promise
:
:
Create
(
aWriter
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
closedPromise
-
>
MaybeReject
(
storedError
)
;
aWriter
-
>
SetClosedPromise
(
closedPromise
)
;
closedPromise
-
>
SetSettledPromiseIsHandled
(
)
;
}
}
void
WritableStreamDefaultWriterEnsureClosedPromiseRejected
(
WritableStreamDefaultWriter
*
aWriter
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
{
RefPtr
<
Promise
>
closedPromise
=
aWriter
-
>
ClosedPromise
(
)
;
if
(
closedPromise
-
>
State
(
)
=
=
Promise
:
:
PromiseState
:
:
Pending
)
{
closedPromise
-
>
MaybeReject
(
aError
)
;
}
else
{
closedPromise
=
Promise
:
:
Create
(
aWriter
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
closedPromise
-
>
MaybeReject
(
aError
)
;
aWriter
-
>
SetClosedPromise
(
closedPromise
)
;
}
closedPromise
-
>
SetSettledPromiseIsHandled
(
)
;
}
void
WritableStreamDefaultWriterEnsureReadyPromiseRejected
(
WritableStreamDefaultWriter
*
aWriter
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
{
RefPtr
<
Promise
>
readyPromise
=
aWriter
-
>
ReadyPromise
(
)
;
if
(
readyPromise
-
>
State
(
)
=
=
Promise
:
:
PromiseState
:
:
Pending
)
{
readyPromise
-
>
MaybeReject
(
aError
)
;
}
else
{
readyPromise
=
Promise
:
:
Create
(
aWriter
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
readyPromise
-
>
MaybeReject
(
aError
)
;
aWriter
-
>
SetReadyPromise
(
readyPromise
)
;
}
readyPromise
-
>
SetSettledPromiseIsHandled
(
)
;
}
already_AddRefed
<
Promise
>
WritableStreamDefaultWriterCloseWithErrorPropagation
(
JSContext
*
aCx
WritableStreamDefaultWriter
*
aWriter
ErrorResult
&
aRv
)
{
RefPtr
<
WritableStream
>
stream
=
aWriter
-
>
GetStream
(
)
;
MOZ_ASSERT
(
stream
)
;
WritableStream
:
:
WriterState
state
=
stream
-
>
State
(
)
;
if
(
stream
-
>
CloseQueuedOrInFlight
(
)
|
|
state
=
=
WritableStream
:
:
WriterState
:
:
Closed
)
{
return
Promise
:
:
CreateResolvedWithUndefined
(
aWriter
-
>
GetParentObject
(
)
aRv
)
;
}
if
(
state
=
=
WritableStream
:
:
WriterState
:
:
Errored
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
stream
-
>
StoredError
(
)
)
;
return
Promise
:
:
CreateRejected
(
aWriter
-
>
GetParentObject
(
)
error
aRv
)
;
}
MOZ_ASSERT
(
state
=
=
WritableStream
:
:
WriterState
:
:
Writable
|
|
state
=
=
WritableStream
:
:
WriterState
:
:
Erroring
)
;
return
WritableStreamDefaultWriterClose
(
aCx
aWriter
aRv
)
;
}
}
