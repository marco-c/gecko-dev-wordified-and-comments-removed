#
include
"
js
/
Exception
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
mozilla
/
dom
/
ByteStreamHelpers
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
ReadIntoRequest
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamBYOBReader
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamDefaultController
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamGenericReader
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamTee
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamDefaultReader
.
h
"
#
include
"
mozilla
/
dom
/
ReadableByteStreamController
.
h
"
#
include
"
mozilla
/
dom
/
UnderlyingSourceBinding
.
h
"
#
include
"
mozilla
/
dom
/
UnderlyingSourceCallbackHelpers
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
ReadableStreamDefaultTeePullAlgorithm
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
ReadableStreamDefaultTeePullAlgorithm
UnderlyingSourcePullCallbackHelper
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTeeState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
ReadableStreamDefaultTeePullAlgorithm
UnderlyingSourcePullCallbackHelper
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTeeState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ADDREF_INHERITED
(
ReadableStreamDefaultTeePullAlgorithm
UnderlyingSourcePullCallbackHelper
)
NS_IMPL_RELEASE_INHERITED
(
ReadableStreamDefaultTeePullAlgorithm
UnderlyingSourcePullCallbackHelper
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadableStreamDefaultTeePullAlgorithm
)
NS_INTERFACE_MAP_END_INHERITING
(
UnderlyingSourcePullCallbackHelper
)
already_AddRefed
<
Promise
>
ReadableStreamDefaultTeePullAlgorithm
:
:
PullCallback
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
)
{
if
(
mTeeState
-
>
Reading
(
)
)
{
mTeeState
-
>
SetReadAgain
(
true
)
;
return
Promise
:
:
CreateResolvedWithUndefined
(
aGlobal
aRv
)
;
}
mTeeState
-
>
SetReading
(
true
)
;
RefPtr
<
ReadRequest
>
readRequest
=
new
ReadableStreamDefaultTeeReadRequest
(
mTeeState
)
;
RefPtr
<
ReadableStreamGenericReader
>
reader
(
mTeeState
-
>
GetReader
(
)
)
;
ReadableStreamDefaultReaderRead
(
aCx
reader
readRequest
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
Promise
:
:
CreateResolvedWithUndefined
(
aGlobal
aRv
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
ReadableStreamDefaultTeeReadRequest
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
ReadableStreamDefaultTeeReadRequest
ReadRequest
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTeeState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
ReadableStreamDefaultTeeReadRequest
ReadRequest
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTeeState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ADDREF_INHERITED
(
ReadableStreamDefaultTeeReadRequest
ReadRequest
)
NS_IMPL_RELEASE_INHERITED
(
ReadableStreamDefaultTeeReadRequest
ReadRequest
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadableStreamDefaultTeeReadRequest
)
NS_INTERFACE_MAP_END_INHERITING
(
ReadRequest
)
void
ReadableStreamDefaultTeeReadRequest
:
:
ChunkSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
{
class
ReadableStreamDefaultTeeReadRequestChunkSteps
:
public
MicroTaskRunnable
{
RefPtr
<
TeeState
>
mTeeState
;
JS
:
:
PersistentRooted
<
JS
:
:
Value
>
mChunk
;
public
:
ReadableStreamDefaultTeeReadRequestChunkSteps
(
JSContext
*
aCx
TeeState
*
aTeeState
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
)
:
mTeeState
(
aTeeState
)
mChunk
(
aCx
aChunk
)
{
}
MOZ_CAN_RUN_SCRIPT
void
Run
(
AutoSlowOperation
&
aAso
)
override
{
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
mTeeState
-
>
GetStream
(
)
-
>
GetParentObject
(
)
)
)
)
{
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
mTeeState
-
>
SetReadAgain
(
false
)
;
JS
:
:
RootedValue
chunk1
(
cx
mChunk
)
;
JS
:
:
RootedValue
chunk2
(
cx
mChunk
)
;
MOZ_RELEASE_ASSERT
(
!
mTeeState
-
>
CloneForBranch2
(
)
)
;
if
(
!
mTeeState
-
>
Canceled1
(
)
)
{
IgnoredErrorResult
rv
;
RefPtr
<
ReadableStreamDefaultController
>
controller
(
mTeeState
-
>
Branch1
(
)
-
>
DefaultController
(
)
)
;
ReadableStreamDefaultControllerEnqueue
(
cx
controller
chunk1
rv
)
;
(
void
)
NS_WARN_IF
(
rv
.
Failed
(
)
)
;
}
if
(
!
mTeeState
-
>
Canceled2
(
)
)
{
IgnoredErrorResult
rv
;
RefPtr
<
ReadableStreamDefaultController
>
controller
(
mTeeState
-
>
Branch2
(
)
-
>
DefaultController
(
)
)
;
ReadableStreamDefaultControllerEnqueue
(
cx
controller
chunk2
rv
)
;
(
void
)
NS_WARN_IF
(
rv
.
Failed
(
)
)
;
}
mTeeState
-
>
SetReading
(
false
)
;
if
(
mTeeState
-
>
ReadAgain
(
)
)
{
RefPtr
<
ReadableStreamDefaultTeePullAlgorithm
>
pullAlgorithm
(
mTeeState
-
>
PullAlgorithm
(
)
)
;
IgnoredErrorResult
rv
;
nsCOMPtr
<
nsIGlobalObject
>
global
(
mTeeState
-
>
GetStream
(
)
-
>
GetParentObject
(
)
)
;
RefPtr
<
Promise
>
ignoredPromise
=
pullAlgorithm
-
>
PullCallback
(
cx
global
rv
)
;
(
void
)
NS_WARN_IF
(
rv
.
Failed
(
)
)
;
}
}
bool
Suppressed
(
)
override
{
nsIGlobalObject
*
global
=
mTeeState
-
>
GetStream
(
)
-
>
GetParentObject
(
)
;
return
global
&
&
global
-
>
IsInSyncOperation
(
)
;
}
}
;
RefPtr
<
ReadableStreamDefaultTeeReadRequestChunkSteps
>
task
=
MakeRefPtr
<
ReadableStreamDefaultTeeReadRequestChunkSteps
>
(
aCx
mTeeState
aChunk
)
;
CycleCollectedJSContext
:
:
Get
(
)
-
>
DispatchToMicroTask
(
task
.
forget
(
)
)
;
}
void
ReadableStreamDefaultTeeReadRequest
:
:
CloseSteps
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
mTeeState
-
>
SetReading
(
false
)
;
if
(
!
mTeeState
-
>
Canceled1
(
)
)
{
RefPtr
<
ReadableStreamDefaultController
>
controller
(
mTeeState
-
>
Branch1
(
)
-
>
DefaultController
(
)
)
;
ReadableStreamDefaultControllerClose
(
aCx
controller
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
if
(
!
mTeeState
-
>
Canceled2
(
)
)
{
RefPtr
<
ReadableStreamDefaultController
>
controller
(
mTeeState
-
>
Branch2
(
)
-
>
DefaultController
(
)
)
;
ReadableStreamDefaultControllerClose
(
aCx
controller
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
if
(
!
mTeeState
-
>
Canceled1
(
)
|
|
!
mTeeState
-
>
Canceled2
(
)
)
{
mTeeState
-
>
CancelPromise
(
)
-
>
MaybeResolveWithUndefined
(
)
;
}
}
void
ReadableStreamDefaultTeeReadRequest
:
:
ErrorSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
{
mTeeState
-
>
SetReading
(
false
)
;
}
MOZ_CAN_RUN_SCRIPT
void
PullWithDefaultReader
(
JSContext
*
aCx
TeeState
*
aTeeState
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
PullWithBYOBReader
(
JSContext
*
aCx
TeeState
*
aTeeState
JS
:
:
HandleObject
aView
TeeBranch
aForBranch
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
ByteStreamTeePullAlgorithm
(
JSContext
*
aCx
TeeBranch
aForBranch
TeeState
*
aTeeState
ErrorResult
&
aRv
)
{
if
(
aTeeState
-
>
Reading
(
)
)
{
aTeeState
-
>
SetReadAgainForBranch
(
aForBranch
true
)
;
return
;
}
aTeeState
-
>
SetReading
(
true
)
;
RefPtr
<
ReadableStreamBYOBRequest
>
byobRequest
=
ReadableByteStreamControllerGetBYOBRequest
(
aCx
aTeeState
-
>
Branch
(
aForBranch
)
-
>
Controller
(
)
-
>
AsByte
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
!
byobRequest
)
{
PullWithDefaultReader
(
aCx
aTeeState
aRv
)
;
}
else
{
JS
:
:
RootedObject
view
(
aCx
byobRequest
-
>
View
(
)
)
;
PullWithBYOBReader
(
aCx
aTeeState
view
aForBranch
aRv
)
;
}
}
class
NativeByteStreamTeePullAlgorithm
final
:
public
UnderlyingSourcePullCallbackHelper
{
RefPtr
<
TeeState
>
mTeeState
;
const
TeeBranch
mBranch
;
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
NativeByteStreamTeePullAlgorithm
UnderlyingSourcePullCallbackHelper
)
explicit
NativeByteStreamTeePullAlgorithm
(
TeeState
*
aTeeState
TeeBranch
aBranch
)
:
mTeeState
(
aTeeState
)
mBranch
(
aBranch
)
{
}
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
PullCallback
(
JSContext
*
aCx
ReadableStreamController
&
aController
ErrorResult
&
aRv
)
override
{
RefPtr
<
Promise
>
returnPromise
=
Promise
:
:
CreateResolvedWithUndefined
(
mTeeState
-
>
GetStream
(
)
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
ByteStreamTeePullAlgorithm
(
aCx
mBranch
MOZ_KnownLive
(
mTeeState
)
aRv
)
;
return
returnPromise
.
forget
(
)
;
}
protected
:
~
NativeByteStreamTeePullAlgorithm
(
)
override
=
default
;
}
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
NativeByteStreamTeePullAlgorithm
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
NativeByteStreamTeePullAlgorithm
UnderlyingSourcePullCallbackHelper
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTeeState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
NativeByteStreamTeePullAlgorithm
UnderlyingSourcePullCallbackHelper
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTeeState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ADDREF_INHERITED
(
NativeByteStreamTeePullAlgorithm
UnderlyingSourcePullCallbackHelper
)
NS_IMPL_RELEASE_INHERITED
(
NativeByteStreamTeePullAlgorithm
UnderlyingSourcePullCallbackHelper
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
NativeByteStreamTeePullAlgorithm
)
NS_INTERFACE_MAP_END_INHERITING
(
UnderlyingSourcePullCallbackHelper
)
struct
PullWithDefaultReaderReadRequest
final
:
public
ReadRequest
{
RefPtr
<
TeeState
>
mTeeState
;
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
PullWithDefaultReaderReadRequest
ReadRequest
)
explicit
PullWithDefaultReaderReadRequest
(
TeeState
*
aTeeState
)
:
mTeeState
(
aTeeState
)
{
}
void
ChunkSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
override
{
class
PullWithDefaultReaderChunkStepMicrotask
:
public
MicroTaskRunnable
{
RefPtr
<
TeeState
>
mTeeState
;
JS
:
:
PersistentRooted
<
JSObject
*
>
mChunk
;
public
:
PullWithDefaultReaderChunkStepMicrotask
(
JSContext
*
aCx
TeeState
*
aTeeState
JS
:
:
Handle
<
JSObject
*
>
aChunk
)
:
mTeeState
(
aTeeState
)
mChunk
(
aCx
aChunk
)
{
}
MOZ_CAN_RUN_SCRIPT
void
Run
(
AutoSlowOperation
&
aAso
)
override
{
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
mTeeState
-
>
GetStream
(
)
-
>
GetParentObject
(
)
)
)
)
{
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
mTeeState
-
>
SetReadAgainForBranch1
(
false
)
;
mTeeState
-
>
SetReadAgainForBranch2
(
false
)
;
JS
:
:
Rooted
<
JSObject
*
>
chunk1
(
cx
mChunk
)
;
JS
:
:
Rooted
<
JSObject
*
>
chunk2
(
cx
mChunk
)
;
ErrorResult
rv
;
if
(
!
mTeeState
-
>
Canceled1
(
)
&
&
!
mTeeState
-
>
Canceled2
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
cloneResult
(
cx
CloneAsUint8Array
(
cx
mChunk
)
)
;
if
(
!
cloneResult
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
exceptionValue
(
cx
)
;
if
(
!
JS_GetPendingException
(
cx
&
exceptionValue
)
)
{
return
;
}
JS_ClearPendingException
(
cx
)
;
ErrorResult
rv
;
ReadableByteStreamControllerError
(
mTeeState
-
>
Branch1
(
)
-
>
Controller
(
)
-
>
AsByte
(
)
exceptionValue
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
"
Error
during
ReadableByteStreamControllerError
"
)
)
{
return
;
}
ReadableByteStreamControllerError
(
mTeeState
-
>
Branch2
(
)
-
>
Controller
(
)
-
>
AsByte
(
)
exceptionValue
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
"
Error
during
ReadableByteStreamControllerError
"
)
)
{
return
;
}
RefPtr
<
ReadableStream
>
stream
(
mTeeState
-
>
GetStream
(
)
)
;
RefPtr
<
Promise
>
promise
=
ReadableStreamCancel
(
cx
stream
exceptionValue
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
"
Error
during
ReadableByteStreamControllerError
"
)
)
{
return
;
}
mTeeState
-
>
CancelPromise
(
)
-
>
MaybeResolve
(
promise
)
;
return
;
}
chunk2
=
cloneResult
;
}
if
(
!
mTeeState
-
>
Canceled1
(
)
)
{
ErrorResult
rv
;
RefPtr
<
ReadableByteStreamController
>
controller
(
mTeeState
-
>
Branch1
(
)
-
>
Controller
(
)
-
>
AsByte
(
)
)
;
ReadableByteStreamControllerEnqueue
(
cx
controller
chunk1
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
"
Error
during
ReadableByteStreamControllerEnqueue
"
)
)
{
return
;
}
}
if
(
!
mTeeState
-
>
Canceled2
(
)
)
{
ErrorResult
rv
;
RefPtr
<
ReadableByteStreamController
>
controller
(
mTeeState
-
>
Branch2
(
)
-
>
Controller
(
)
-
>
AsByte
(
)
)
;
ReadableByteStreamControllerEnqueue
(
cx
controller
chunk2
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
"
Error
during
ReadableByteStreamControllerEnqueue
"
)
)
{
return
;
}
}
mTeeState
-
>
SetReading
(
false
)
;
if
(
mTeeState
-
>
ReadAgainForBranch1
(
)
)
{
ByteStreamTeePullAlgorithm
(
cx
TeeBranch
:
:
Branch1
MOZ_KnownLive
(
mTeeState
)
rv
)
;
}
else
if
(
mTeeState
-
>
ReadAgainForBranch2
(
)
)
{
ByteStreamTeePullAlgorithm
(
cx
TeeBranch
:
:
Branch2
MOZ_KnownLive
(
mTeeState
)
rv
)
;
}
}
bool
Suppressed
(
)
override
{
nsIGlobalObject
*
global
=
mTeeState
-
>
GetStream
(
)
-
>
GetParentObject
(
)
;
return
global
&
&
global
-
>
IsInSyncOperation
(
)
;
}
}
;
MOZ_ASSERT
(
aChunk
.
isObjectOrNull
(
)
)
;
MOZ_ASSERT
(
aChunk
.
toObjectOrNull
(
)
!
=
nullptr
)
;
JS
:
:
RootedObject
chunk
(
aCx
&
aChunk
.
toObject
(
)
)
;
RefPtr
<
PullWithDefaultReaderChunkStepMicrotask
>
task
=
MakeRefPtr
<
PullWithDefaultReaderChunkStepMicrotask
>
(
aCx
mTeeState
chunk
)
;
CycleCollectedJSContext
:
:
Get
(
)
-
>
DispatchToMicroTask
(
task
.
forget
(
)
)
;
}
MOZ_CAN_RUN_SCRIPT
void
CloseSteps
(
JSContext
*
aCx
ErrorResult
&
aRv
)
override
{
mTeeState
-
>
SetReading
(
false
)
;
RefPtr
<
ReadableByteStreamController
>
branch1Controller
=
mTeeState
-
>
Branch1
(
)
-
>
Controller
(
)
-
>
AsByte
(
)
;
if
(
!
mTeeState
-
>
Canceled1
(
)
)
{
ReadableByteStreamControllerClose
(
aCx
branch1Controller
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
RefPtr
<
ReadableByteStreamController
>
branch2Controller
=
mTeeState
-
>
Branch2
(
)
-
>
Controller
(
)
-
>
AsByte
(
)
;
if
(
!
mTeeState
-
>
Canceled2
(
)
)
{
ReadableByteStreamControllerClose
(
aCx
branch2Controller
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
if
(
!
branch1Controller
-
>
PendingPullIntos
(
)
.
isEmpty
(
)
)
{
ReadableByteStreamControllerRespond
(
aCx
branch1Controller
0
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
if
(
!
branch2Controller
-
>
PendingPullIntos
(
)
.
isEmpty
(
)
)
{
ReadableByteStreamControllerRespond
(
aCx
branch2Controller
0
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
if
(
!
mTeeState
-
>
Canceled1
(
)
|
|
!
mTeeState
-
>
Canceled2
(
)
)
{
mTeeState
-
>
CancelPromise
(
)
-
>
MaybeResolveWithUndefined
(
)
;
}
}
void
ErrorSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
override
{
mTeeState
-
>
SetReading
(
false
)
;
}
protected
:
~
PullWithDefaultReaderReadRequest
(
)
override
=
default
;
}
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
PullWithDefaultReaderReadRequest
ReadRequest
mTeeState
)
NS_IMPL_ADDREF_INHERITED
(
PullWithDefaultReaderReadRequest
ReadRequest
)
NS_IMPL_RELEASE_INHERITED
(
PullWithDefaultReaderReadRequest
ReadRequest
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
PullWithDefaultReaderReadRequest
)
NS_INTERFACE_MAP_END_INHERITING
(
ReadRequest
)
void
ForwardReaderError
(
TeeState
*
aTeeState
ReadableStreamGenericReader
*
aThisReader
)
;
void
PullWithDefaultReader
(
JSContext
*
aCx
TeeState
*
aTeeState
ErrorResult
&
aRv
)
{
RefPtr
<
ReadableStreamGenericReader
>
reader
=
aTeeState
-
>
GetReader
(
)
;
if
(
reader
-
>
IsBYOB
(
)
)
{
MOZ_ASSERT
(
reader
-
>
AsBYOB
(
)
-
>
ReadIntoRequests
(
)
.
length
(
)
=
=
0
)
;
ReadableStreamBYOBReaderRelease
(
aCx
reader
-
>
AsBYOB
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
reader
=
AcquireReadableStreamDefaultReader
(
aCx
aTeeState
-
>
GetStream
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aTeeState
-
>
SetReader
(
reader
)
;
ForwardReaderError
(
aTeeState
reader
)
;
}
RefPtr
<
ReadRequest
>
readRequest
=
new
PullWithDefaultReaderReadRequest
(
aTeeState
)
;
ReadableStreamDefaultReaderRead
(
aCx
reader
readRequest
aRv
)
;
}
class
PullWithBYOBReader_ReadIntoRequest
final
:
public
ReadIntoRequest
{
RefPtr
<
TeeState
>
mTeeState
;
const
TeeBranch
mForBranch
;
~
PullWithBYOBReader_ReadIntoRequest
(
)
override
=
default
;
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
PullWithBYOBReader_ReadIntoRequest
ReadIntoRequest
)
explicit
PullWithBYOBReader_ReadIntoRequest
(
TeeState
*
aTeeState
TeeBranch
aForBranch
)
:
mTeeState
(
aTeeState
)
mForBranch
(
aForBranch
)
{
}
void
ChunkSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
override
{
class
PullWithBYOBReaderChunkMicrotask
:
public
MicroTaskRunnable
{
RefPtr
<
TeeState
>
mTeeState
;
JS
:
:
PersistentRooted
<
JSObject
*
>
mChunk
;
const
TeeBranch
mForBranch
;
public
:
PullWithBYOBReaderChunkMicrotask
(
JSContext
*
aCx
TeeState
*
aTeeState
JS
:
:
Handle
<
JSObject
*
>
aChunk
TeeBranch
aForBranch
)
:
mTeeState
(
aTeeState
)
mChunk
(
aCx
aChunk
)
mForBranch
(
aForBranch
)
{
}
MOZ_CAN_RUN_SCRIPT
void
Run
(
AutoSlowOperation
&
aAso
)
override
{
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
mTeeState
-
>
GetStream
(
)
-
>
GetParentObject
(
)
)
)
)
{
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
ErrorResult
rv
;
mTeeState
-
>
SetReadAgainForBranch1
(
false
)
;
mTeeState
-
>
SetReadAgainForBranch2
(
false
)
;
bool
byobCanceled
=
mTeeState
-
>
Canceled
(
mForBranch
)
;
bool
otherCanceled
=
mTeeState
-
>
Canceled
(
OtherTeeBranch
(
mForBranch
)
)
;
ReadableStream
*
byobBranch
=
mTeeState
-
>
Branch
(
mForBranch
)
;
ReadableStream
*
otherBranch
=
mTeeState
-
>
Branch
(
OtherTeeBranch
(
mForBranch
)
)
;
if
(
!
otherCanceled
)
{
JS
:
:
RootedObject
clonedChunk
(
cx
CloneAsUint8Array
(
cx
mChunk
)
)
;
if
(
!
clonedChunk
)
{
JS
:
:
RootedValue
exception
(
cx
)
;
if
(
!
JS_GetPendingException
(
cx
&
exception
)
)
{
return
;
}
JS_ClearPendingException
(
cx
)
;
ReadableByteStreamControllerError
(
byobBranch
-
>
Controller
(
)
-
>
AsByte
(
)
exception
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
)
)
{
return
;
}
ReadableByteStreamControllerError
(
otherBranch
-
>
Controller
(
)
-
>
AsByte
(
)
exception
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
)
)
{
return
;
}
RefPtr
<
ReadableStream
>
stream
=
mTeeState
-
>
GetStream
(
)
;
RefPtr
<
Promise
>
cancelPromise
=
ReadableStreamCancel
(
cx
stream
exception
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
)
)
{
return
;
}
mTeeState
-
>
CancelPromise
(
)
-
>
MaybeResolve
(
cancelPromise
)
;
return
;
}
if
(
!
byobCanceled
)
{
RefPtr
<
ReadableByteStreamController
>
controller
(
byobBranch
-
>
Controller
(
)
-
>
AsByte
(
)
)
;
ReadableByteStreamControllerRespondWithNewView
(
cx
controller
mChunk
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
)
)
{
return
;
}
}
RefPtr
<
ReadableByteStreamController
>
otherController
=
otherBranch
-
>
Controller
(
)
-
>
AsByte
(
)
;
ReadableByteStreamControllerEnqueue
(
cx
otherController
clonedChunk
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
)
)
{
return
;
}
}
else
if
(
!
byobCanceled
)
{
RefPtr
<
ReadableByteStreamController
>
byobController
=
byobBranch
-
>
Controller
(
)
-
>
AsByte
(
)
;
ReadableByteStreamControllerRespondWithNewView
(
cx
byobController
mChunk
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
)
)
{
return
;
}
}
mTeeState
-
>
SetReading
(
false
)
;
if
(
mTeeState
-
>
ReadAgainForBranch1
(
)
)
{
ByteStreamTeePullAlgorithm
(
cx
TeeBranch
:
:
Branch1
MOZ_KnownLive
(
mTeeState
)
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
)
)
{
return
;
}
}
else
if
(
mTeeState
-
>
ReadAgainForBranch2
(
)
)
{
ByteStreamTeePullAlgorithm
(
cx
TeeBranch
:
:
Branch2
MOZ_KnownLive
(
mTeeState
)
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
)
)
{
return
;
}
}
}
bool
Suppressed
(
)
override
{
nsIGlobalObject
*
global
=
mTeeState
-
>
GetStream
(
)
-
>
GetParentObject
(
)
;
return
global
&
&
global
-
>
IsInSyncOperation
(
)
;
}
}
;
MOZ_ASSERT
(
aChunk
.
isObjectOrNull
(
)
)
;
MOZ_ASSERT
(
aChunk
.
toObjectOrNull
(
)
)
;
JS
:
:
RootedObject
chunk
(
aCx
aChunk
.
toObjectOrNull
(
)
)
;
RefPtr
<
PullWithBYOBReaderChunkMicrotask
>
task
=
MakeRefPtr
<
PullWithBYOBReaderChunkMicrotask
>
(
aCx
mTeeState
chunk
mForBranch
)
;
CycleCollectedJSContext
:
:
Get
(
)
-
>
DispatchToMicroTask
(
task
.
forget
(
)
)
;
}
MOZ_CAN_RUN_SCRIPT
void
CloseSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
override
{
mTeeState
-
>
SetReading
(
false
)
;
bool
byobCanceled
=
mTeeState
-
>
Canceled
(
mForBranch
)
;
bool
otherCanceled
=
mTeeState
-
>
Canceled
(
OtherTeeBranch
(
mForBranch
)
)
;
ReadableStream
*
byobBranch
=
mTeeState
-
>
Branch
(
mForBranch
)
;
ReadableStream
*
otherBranch
=
mTeeState
-
>
Branch
(
OtherTeeBranch
(
mForBranch
)
)
;
if
(
!
byobCanceled
)
{
RefPtr
<
ReadableByteStreamController
>
controller
=
byobBranch
-
>
Controller
(
)
-
>
AsByte
(
)
;
ReadableByteStreamControllerClose
(
aCx
controller
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
if
(
!
otherCanceled
)
{
RefPtr
<
ReadableByteStreamController
>
controller
=
otherBranch
-
>
Controller
(
)
-
>
AsByte
(
)
;
ReadableByteStreamControllerClose
(
aCx
controller
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
if
(
!
aChunk
.
isUndefined
(
)
)
{
MOZ_ASSERT
(
aChunk
.
isObject
(
)
)
;
MOZ_ASSERT
(
aChunk
.
toObjectOrNull
(
)
)
;
JS
:
:
RootedObject
chunkObject
(
aCx
&
aChunk
.
toObject
(
)
)
;
MOZ_ASSERT
(
JS_IsArrayBufferViewObject
(
chunkObject
)
)
;
MOZ_ASSERT
(
JS_GetArrayBufferViewByteLength
(
chunkObject
)
=
=
0
)
;
if
(
!
byobCanceled
)
{
RefPtr
<
ReadableByteStreamController
>
byobController
(
byobBranch
-
>
Controller
(
)
-
>
AsByte
(
)
)
;
ReadableByteStreamControllerRespondWithNewView
(
aCx
byobController
chunkObject
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
if
(
!
otherCanceled
&
&
!
otherBranch
-
>
Controller
(
)
-
>
AsByte
(
)
-
>
PendingPullIntos
(
)
.
isEmpty
(
)
)
{
RefPtr
<
ReadableByteStreamController
>
otherController
(
otherBranch
-
>
Controller
(
)
-
>
AsByte
(
)
)
;
ReadableByteStreamControllerRespond
(
aCx
otherController
0
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
}
if
(
!
byobCanceled
|
|
!
otherCanceled
)
{
mTeeState
-
>
CancelPromise
(
)
-
>
MaybeResolveWithUndefined
(
)
;
}
}
void
ErrorSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
e
ErrorResult
&
errorResult
)
override
{
mTeeState
-
>
SetReading
(
false
)
;
}
}
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
PullWithBYOBReader_ReadIntoRequest
ReadIntoRequest
mTeeState
)
NS_IMPL_ADDREF_INHERITED
(
PullWithBYOBReader_ReadIntoRequest
ReadIntoRequest
)
NS_IMPL_RELEASE_INHERITED
(
PullWithBYOBReader_ReadIntoRequest
ReadIntoRequest
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
PullWithBYOBReader_ReadIntoRequest
)
NS_INTERFACE_MAP_END_INHERITING
(
ReadIntoRequest
)
void
PullWithBYOBReader
(
JSContext
*
aCx
TeeState
*
aTeeState
JS
:
:
HandleObject
aView
TeeBranch
aForBranch
ErrorResult
&
aRv
)
{
if
(
aTeeState
-
>
GetReader
(
)
-
>
IsDefault
(
)
)
{
MOZ_ASSERT
(
aTeeState
-
>
GetDefaultReader
(
)
-
>
ReadRequests
(
)
.
isEmpty
(
)
)
;
ReadableStreamDefaultReaderRelease
(
aCx
aTeeState
-
>
GetDefaultReader
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
RefPtr
<
ReadableStreamBYOBReader
>
reader
=
AcquireReadableStreamBYOBReader
(
aTeeState
-
>
GetStream
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aTeeState
-
>
SetReader
(
reader
)
;
ForwardReaderError
(
aTeeState
reader
)
;
}
RefPtr
<
ReadIntoRequest
>
readIntoRequest
=
new
PullWithBYOBReader_ReadIntoRequest
(
aTeeState
aForBranch
)
;
RefPtr
<
ReadableStreamBYOBReader
>
byobReader
=
aTeeState
-
>
GetReader
(
)
-
>
AsBYOB
(
)
;
ReadableStreamBYOBReaderRead
(
aCx
byobReader
aView
readIntoRequest
aRv
)
;
}
class
ForwardReaderErrorPromiseHandler
final
:
public
PromiseNativeHandler
{
~
ForwardReaderErrorPromiseHandler
(
)
override
=
default
;
RefPtr
<
TeeState
>
mTeeState
;
RefPtr
<
ReadableStreamGenericReader
>
mReader
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
ForwardReaderErrorPromiseHandler
)
ForwardReaderErrorPromiseHandler
(
TeeState
*
aTeeState
ReadableStreamGenericReader
*
aReader
)
:
mTeeState
(
aTeeState
)
mReader
(
aReader
)
{
}
MOZ_CAN_RUN_SCRIPT
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
{
}
MOZ_CAN_RUN_SCRIPT
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
{
if
(
mTeeState
-
>
GetReader
(
)
!
=
mReader
)
{
return
;
}
ErrorResult
rv
;
MOZ_ASSERT
(
mTeeState
-
>
Branch1
(
)
-
>
Controller
(
)
-
>
IsByte
(
)
)
;
ReadableByteStreamControllerError
(
mTeeState
-
>
Branch1
(
)
-
>
Controller
(
)
-
>
AsByte
(
)
aValue
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
MOZ_ASSERT
(
mTeeState
-
>
Branch2
(
)
-
>
Controller
(
)
-
>
IsByte
(
)
)
;
ReadableByteStreamControllerError
(
mTeeState
-
>
Branch2
(
)
-
>
Controller
(
)
-
>
AsByte
(
)
aValue
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
!
mTeeState
-
>
Canceled1
(
)
|
|
!
mTeeState
-
>
Canceled2
(
)
)
{
mTeeState
-
>
CancelPromise
(
)
-
>
MaybeResolveWithUndefined
(
)
;
}
}
}
;
NS_IMPL_CYCLE_COLLECTION
(
ForwardReaderErrorPromiseHandler
mTeeState
mReader
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ForwardReaderErrorPromiseHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ForwardReaderErrorPromiseHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ForwardReaderErrorPromiseHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
void
ForwardReaderError
(
TeeState
*
aTeeState
ReadableStreamGenericReader
*
aThisReader
)
{
aThisReader
-
>
ClosedPromise
(
)
-
>
AppendNativeHandler
(
new
ForwardReaderErrorPromiseHandler
(
aTeeState
aThisReader
)
)
;
}
class
ReadableByteStreamTeeCancelAlgorithm
final
:
public
UnderlyingSourceCancelCallbackHelper
{
RefPtr
<
TeeState
>
mTeeState
;
const
TeeBranch
mBranch
;
TeeBranch
otherStream
(
)
{
return
OtherTeeBranch
(
mBranch
)
;
}
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
ReadableByteStreamTeeCancelAlgorithm
UnderlyingSourceCancelCallbackHelper
)
explicit
ReadableByteStreamTeeCancelAlgorithm
(
TeeState
*
aTeeState
TeeBranch
aBranch
)
:
mTeeState
(
aTeeState
)
mBranch
(
aBranch
)
{
}
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
CancelCallback
(
JSContext
*
aCx
const
Optional
<
JS
:
:
Handle
<
JS
:
:
Value
>
>
&
aReason
ErrorResult
&
aRv
)
override
{
mTeeState
-
>
SetCanceled
(
mBranch
true
)
;
mTeeState
-
>
SetReason
(
mBranch
aReason
.
Value
(
)
)
;
if
(
mTeeState
-
>
Canceled
(
otherStream
(
)
)
)
{
JS
:
:
RootedObject
compositeReason
(
aCx
JS
:
:
NewArrayObject
(
aCx
2
)
)
;
if
(
!
compositeReason
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
nullptr
;
}
JS
:
:
RootedValue
reason1
(
aCx
mTeeState
-
>
Reason1
(
)
)
;
if
(
!
JS_SetElement
(
aCx
compositeReason
0
reason1
)
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
nullptr
;
}
JS
:
:
RootedValue
reason2
(
aCx
mTeeState
-
>
Reason2
(
)
)
;
if
(
!
JS_SetElement
(
aCx
compositeReason
1
reason2
)
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
nullptr
;
}
JS
:
:
RootedValue
compositeReasonValue
(
aCx
JS
:
:
ObjectValue
(
*
compositeReason
)
)
;
RefPtr
<
ReadableStream
>
stream
(
mTeeState
-
>
GetStream
(
)
)
;
RefPtr
<
Promise
>
cancelResult
=
ReadableStreamCancel
(
aCx
stream
compositeReasonValue
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
mTeeState
-
>
CancelPromise
(
)
-
>
MaybeResolve
(
cancelResult
)
;
}
return
do_AddRef
(
mTeeState
-
>
CancelPromise
(
)
)
;
}
protected
:
~
ReadableByteStreamTeeCancelAlgorithm
(
)
override
=
default
;
}
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
ReadableByteStreamTeeCancelAlgorithm
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
ReadableByteStreamTeeCancelAlgorithm
UnderlyingSourceCancelCallbackHelper
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTeeState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
ReadableByteStreamTeeCancelAlgorithm
UnderlyingSourceCancelCallbackHelper
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTeeState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ADDREF_INHERITED
(
ReadableByteStreamTeeCancelAlgorithm
UnderlyingSourceCancelCallbackHelper
)
NS_IMPL_RELEASE_INHERITED
(
ReadableByteStreamTeeCancelAlgorithm
UnderlyingSourceCancelCallbackHelper
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadableByteStreamTeeCancelAlgorithm
)
NS_INTERFACE_MAP_END_INHERITING
(
UnderlyingSourceCancelCallbackHelper
)
void
ReadableByteStreamTee
(
JSContext
*
aCx
ReadableStream
*
aStream
nsTArray
<
RefPtr
<
ReadableStream
>
>
&
aResult
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aStream
-
>
Controller
(
)
-
>
IsByte
(
)
)
;
RefPtr
<
TeeState
>
teeState
=
TeeState
:
:
Create
(
aCx
aStream
false
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
nsCOMPtr
<
nsIGlobalObject
>
global
=
aStream
-
>
GetParentObject
(
)
;
RefPtr
<
UnderlyingSourcePullCallbackHelper
>
pull1Algorithm
=
new
NativeByteStreamTeePullAlgorithm
(
teeState
TeeBranch
:
:
Branch1
)
;
RefPtr
<
UnderlyingSourceCancelCallbackHelper
>
cancel1Algorithm
=
new
ReadableByteStreamTeeCancelAlgorithm
(
teeState
TeeBranch
:
:
Branch1
)
;
teeState
-
>
SetBranch1
(
CreateReadableByteStream
(
aCx
global
nullptr
pull1Algorithm
cancel1Algorithm
aRv
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
RefPtr
<
UnderlyingSourcePullCallbackHelper
>
pull2Algorithm
=
new
NativeByteStreamTeePullAlgorithm
(
teeState
TeeBranch
:
:
Branch2
)
;
RefPtr
<
UnderlyingSourceCancelCallbackHelper
>
cancel2Algorithm
=
new
ReadableByteStreamTeeCancelAlgorithm
(
teeState
TeeBranch
:
:
Branch2
)
;
teeState
-
>
SetBranch2
(
CreateReadableByteStream
(
aCx
global
nullptr
pull2Algorithm
cancel2Algorithm
aRv
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
ForwardReaderError
(
teeState
teeState
-
>
GetReader
(
)
)
;
aResult
.
AppendElement
(
teeState
-
>
Branch1
(
)
)
;
aResult
.
AppendElement
(
teeState
-
>
Branch2
(
)
)
;
}
}
