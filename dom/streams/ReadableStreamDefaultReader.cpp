#
include
"
mozilla
/
dom
/
ReadableStreamDefaultReader
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamDefaultReaderBinding
.
h
"
#
include
"
mozilla
/
dom
/
UnderlyingSourceBinding
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsWrapperCache
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION
(
ReadableStreamGenericReader
mClosedPromise
mStream
mGlobal
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ReadableStreamGenericReader
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ReadableStreamGenericReader
)
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
ReadableStreamGenericReader
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadableStreamGenericReader
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
ReadableStreamDefaultReader
ReadableStreamGenericReader
mReadRequests
)
NS_IMPL_ADDREF_INHERITED
(
ReadableStreamDefaultReader
ReadableStreamGenericReader
)
NS_IMPL_RELEASE_INHERITED
(
ReadableStreamDefaultReader
ReadableStreamGenericReader
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadableStreamDefaultReader
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_END_INHERITING
(
ReadableStreamGenericReader
)
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
ReadableStreamDefaultReader
ReadableStreamGenericReader
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_TRACE_END
ReadableStreamDefaultReader
:
:
ReadableStreamDefaultReader
(
nsISupports
*
aGlobal
)
:
ReadableStreamGenericReader
(
do_QueryInterface
(
aGlobal
)
)
nsWrapperCache
(
)
{
}
ReadableStreamDefaultReader
:
:
~
ReadableStreamDefaultReader
(
)
{
mReadRequests
.
clear
(
)
;
}
JSObject
*
ReadableStreamDefaultReader
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ReadableStreamDefaultReader_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
static
bool
ReadableStreamReaderGenericInitialize
(
JSContext
*
aCx
ReadableStreamDefaultReader
*
aReader
ReadableStream
*
aStream
ErrorResult
&
aRv
)
{
aReader
-
>
SetStream
(
aStream
)
;
aStream
-
>
SetReader
(
aReader
)
;
aReader
-
>
SetClosedPromise
(
Promise
:
:
Create
(
aReader
-
>
GetParentObject
(
)
aRv
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
false
;
}
switch
(
aStream
-
>
State
(
)
)
{
case
ReadableStream
:
:
ReaderState
:
:
Readable
:
return
true
;
case
ReadableStream
:
:
ReaderState
:
:
Closed
:
aReader
-
>
ClosedPromise
(
)
-
>
MaybeResolve
(
JS
:
:
UndefinedHandleValue
)
;
return
true
;
case
ReadableStream
:
:
ReaderState
:
:
Errored
:
JS
:
:
RootedValue
rootedError
(
aCx
aStream
-
>
StoredError
(
)
)
;
aReader
-
>
ClosedPromise
(
)
-
>
MaybeReject
(
rootedError
)
;
aReader
-
>
ClosedPromise
(
)
-
>
SetSettledPromiseIsHandled
(
)
;
return
true
;
}
}
already_AddRefed
<
ReadableStreamDefaultReader
>
ReadableStreamDefaultReader
:
:
Constructor
(
const
GlobalObject
&
aGlobal
ReadableStream
&
aStream
ErrorResult
&
aRv
)
{
RefPtr
<
ReadableStreamDefaultReader
>
reader
=
new
ReadableStreamDefaultReader
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
aStream
.
Locked
(
)
)
{
aRv
.
ThrowTypeError
(
"
Stream
is
Locked
"
)
;
return
nullptr
;
}
RefPtr
<
ReadableStream
>
streamPtr
=
&
aStream
;
if
(
!
ReadableStreamReaderGenericInitialize
(
aGlobal
.
Context
(
)
reader
streamPtr
aRv
)
)
{
return
nullptr
;
}
reader
-
>
mReadRequests
.
clear
(
)
;
return
reader
.
forget
(
)
;
}
static
bool
CreateValueDonePair
(
JSContext
*
aCx
JS
:
:
HandleValue
aValue
bool
aDone
JS
:
:
MutableHandleValue
aReturnValue
)
{
JS
:
:
RootedObject
obj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
obj
)
{
return
false
;
}
if
(
!
JS_DefineProperty
(
aCx
obj
"
value
"
aValue
JSPROP_ENUMERATE
)
)
{
return
false
;
}
JS
:
:
RootedValue
done
(
aCx
JS
:
:
BooleanValue
(
aDone
)
)
;
if
(
!
JS_DefineProperty
(
aCx
obj
"
done
"
done
JSPROP_ENUMERATE
)
)
{
return
false
;
}
aReturnValue
.
setObject
(
*
obj
)
;
return
true
;
}
struct
Read_ReadRequest
:
public
ReadRequest
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
Read_ReadRequest
ReadRequest
)
RefPtr
<
Promise
>
mPromise
;
explicit
Read_ReadRequest
(
Promise
*
aPromise
)
:
mPromise
(
aPromise
)
{
}
void
ChunkSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
override
{
JS
:
:
RootedValue
resolvedValue
(
aCx
)
;
if
(
!
CreateValueDonePair
(
aCx
aChunk
false
&
resolvedValue
)
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
mPromise
-
>
MaybeResolve
(
resolvedValue
)
;
}
void
CloseSteps
(
JSContext
*
aCx
ErrorResult
&
aRv
)
override
{
JS
:
:
RootedValue
undefined
(
aCx
JS
:
:
UndefinedValue
(
)
)
;
JS
:
:
RootedValue
resolvedValue
(
aCx
)
;
if
(
!
CreateValueDonePair
(
aCx
undefined
true
&
resolvedValue
)
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
mPromise
-
>
MaybeResolve
(
resolvedValue
)
;
}
void
ErrorSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
e
ErrorResult
&
aRv
)
override
{
mPromise
-
>
MaybeReject
(
e
)
;
}
protected
:
virtual
~
Read_ReadRequest
(
)
=
default
;
}
;
NS_IMPL_CYCLE_COLLECTION
(
ReadRequest
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
Read_ReadRequest
ReadRequest
mPromise
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ReadRequest
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ReadRequest
)
NS_IMPL_ADDREF_INHERITED
(
Read_ReadRequest
ReadRequest
)
NS_IMPL_RELEASE_INHERITED
(
Read_ReadRequest
ReadRequest
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadRequest
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Read_ReadRequest
)
NS_INTERFACE_MAP_END_INHERITING
(
ReadRequest
)
MOZ_CAN_RUN_SCRIPT
void
ReadableStreamDefaultReaderRead
(
JSContext
*
aCx
ReadableStreamDefaultReader
*
aReader
ReadRequest
*
aRequest
ErrorResult
&
aRv
)
{
ReadableStream
*
stream
=
aReader
-
>
GetStream
(
)
;
MOZ_ASSERT
(
stream
)
;
stream
-
>
SetDisturbed
(
true
)
;
switch
(
stream
-
>
State
(
)
)
{
case
ReadableStream
:
:
ReaderState
:
:
Closed
:
{
aRequest
-
>
CloseSteps
(
aCx
aRv
)
;
return
;
}
case
ReadableStream
:
:
ReaderState
:
:
Errored
:
{
JS
:
:
RootedValue
storedError
(
aCx
stream
-
>
StoredError
(
)
)
;
aRequest
-
>
ErrorSteps
(
aCx
storedError
aRv
)
;
return
;
}
case
ReadableStream
:
:
ReaderState
:
:
Readable
:
{
RefPtr
<
ReadableStreamDefaultController
>
controller
(
stream
-
>
Controller
(
)
)
;
MOZ_ASSERT
(
controller
)
;
controller
-
>
PullSteps
(
aCx
aRequest
aRv
)
;
return
;
}
}
}
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
ReadableStreamDefaultReader
:
:
Read
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
if
(
!
mStream
)
{
RefPtr
<
Promise
>
rejected
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
rejected
-
>
MaybeRejectWithTypeError
(
"
Stream
is
Undefined
"
)
;
return
rejected
.
forget
(
)
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
RefPtr
<
ReadRequest
>
request
=
new
Read_ReadRequest
(
promise
)
;
ReadableStreamDefaultReaderRead
(
aCx
this
request
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
promise
.
forget
(
)
;
}
static
void
ReadableStreamGenericRelease
(
ReadableStreamDefaultReader
*
aReader
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aReader
-
>
GetStream
(
)
)
;
MOZ_ASSERT
(
aReader
-
>
GetStream
(
)
-
>
GetReader
(
)
=
=
aReader
)
;
if
(
aReader
-
>
GetStream
(
)
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
aReader
-
>
ClosedPromise
(
)
-
>
MaybeRejectWithTypeError
(
"
Releasing
lock
on
readable
stream
"
)
;
}
else
{
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
aReader
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
promise
-
>
MaybeRejectWithTypeError
(
"
Lock
Released
"
)
;
aReader
-
>
SetClosedPromise
(
promise
.
forget
(
)
)
;
}
aReader
-
>
ClosedPromise
(
)
-
>
SetSettledPromiseIsHandled
(
)
;
aReader
-
>
GetStream
(
)
-
>
SetReader
(
nullptr
)
;
aReader
-
>
SetStream
(
nullptr
)
;
}
void
ReadableStreamDefaultReader
:
:
ReleaseLock
(
ErrorResult
&
aRv
)
{
if
(
!
mStream
)
{
return
;
}
if
(
!
mReadRequests
.
isEmpty
(
)
)
{
aRv
.
ThrowTypeError
(
"
Pending
read
requests
"
)
;
return
;
}
ReadableStreamGenericRelease
(
this
aRv
)
;
}
already_AddRefed
<
Promise
>
ReadableStreamDefaultReader
:
:
Closed
(
)
const
{
return
do_AddRef
(
mClosedPromise
)
;
}
MOZ_CAN_RUN_SCRIPT
static
already_AddRefed
<
Promise
>
ReadableStreamGenericReaderCancel
(
JSContext
*
aCx
ReadableStreamDefaultReader
*
aReader
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
{
RefPtr
<
ReadableStream
>
stream
=
aReader
-
>
GetStream
(
)
;
MOZ_ASSERT
(
stream
)
;
return
ReadableStreamCancel
(
aCx
stream
aReason
aRv
)
;
}
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
ReadableStreamDefaultReader
:
:
Cancel
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
{
if
(
!
mStream
)
{
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
promise
-
>
MaybeRejectWithTypeError
(
"
Cancel
reader
with
undefined
stream
"
)
;
return
promise
.
forget
(
)
;
}
return
ReadableStreamGenericReaderCancel
(
aCx
this
aReason
aRv
)
;
}
void
SetUpReadableStreamDefaultReader
(
JSContext
*
aCx
ReadableStreamDefaultReader
*
aReader
ReadableStream
*
aStream
ErrorResult
&
aRv
)
{
if
(
IsReadableStreamLocked
(
aStream
)
)
{
aRv
.
ThrowTypeError
(
"
Locked
Stream
"
)
;
return
;
}
if
(
!
ReadableStreamReaderGenericInitialize
(
aCx
aReader
aStream
aRv
)
)
{
return
;
}
aReader
-
>
ReadRequests
(
)
.
clear
(
)
;
}
}
}
