#
include
"
mozilla
/
dom
/
ReadableStreamDefaultReader
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamDefaultReaderBinding
.
h
"
#
include
"
mozilla
/
dom
/
UnderlyingSourceBinding
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsWrapperCache
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION
(
ReadableStreamGenericReader
mClosedPromise
mStream
mGlobal
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ReadableStreamGenericReader
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ReadableStreamGenericReader
)
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
ReadableStreamGenericReader
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadableStreamGenericReader
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_INHERITED
(
ReadableStreamDefaultReader
ReadableStreamGenericReader
mReadRequests
)
NS_IMPL_ADDREF_INHERITED
(
ReadableStreamDefaultReader
ReadableStreamGenericReader
)
NS_IMPL_RELEASE_INHERITED
(
ReadableStreamDefaultReader
ReadableStreamGenericReader
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadableStreamDefaultReader
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_END_INHERITING
(
ReadableStreamGenericReader
)
ReadableStreamDefaultReader
:
:
ReadableStreamDefaultReader
(
nsISupports
*
aGlobal
)
:
ReadableStreamGenericReader
(
do_QueryInterface
(
aGlobal
)
)
nsWrapperCache
(
)
{
}
ReadableStreamDefaultReader
:
:
~
ReadableStreamDefaultReader
(
)
{
mReadRequests
.
clear
(
)
;
}
JSObject
*
ReadableStreamDefaultReader
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ReadableStreamDefaultReader_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
bool
ReadableStreamReaderGenericInitialize
(
JSContext
*
aCx
ReadableStreamGenericReader
*
aReader
ReadableStream
*
aStream
ErrorResult
&
aRv
)
{
aReader
-
>
SetStream
(
aStream
)
;
aStream
-
>
SetReader
(
aReader
)
;
aReader
-
>
SetClosedPromise
(
Promise
:
:
Create
(
aReader
-
>
GetParentObject
(
)
aRv
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
false
;
}
switch
(
aStream
-
>
State
(
)
)
{
case
ReadableStream
:
:
ReaderState
:
:
Readable
:
return
true
;
case
ReadableStream
:
:
ReaderState
:
:
Closed
:
aReader
-
>
ClosedPromise
(
)
-
>
MaybeResolve
(
JS
:
:
UndefinedHandleValue
)
;
return
true
;
case
ReadableStream
:
:
ReaderState
:
:
Errored
:
JS
:
:
RootedValue
rootedError
(
aCx
aStream
-
>
StoredError
(
)
)
;
aReader
-
>
ClosedPromise
(
)
-
>
MaybeReject
(
rootedError
)
;
aReader
-
>
ClosedPromise
(
)
-
>
SetSettledPromiseIsHandled
(
)
;
return
true
;
}
}
already_AddRefed
<
ReadableStreamDefaultReader
>
ReadableStreamDefaultReader
:
:
Constructor
(
const
GlobalObject
&
aGlobal
ReadableStream
&
aStream
ErrorResult
&
aRv
)
{
RefPtr
<
ReadableStreamDefaultReader
>
reader
=
new
ReadableStreamDefaultReader
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
aStream
.
Locked
(
)
)
{
aRv
.
ThrowTypeError
(
"
Cannot
create
a
new
reader
for
a
readable
stream
already
locked
by
"
"
another
reader
.
"
)
;
return
nullptr
;
}
RefPtr
<
ReadableStream
>
streamPtr
=
&
aStream
;
if
(
!
ReadableStreamReaderGenericInitialize
(
aGlobal
.
Context
(
)
reader
streamPtr
aRv
)
)
{
return
nullptr
;
}
reader
-
>
mReadRequests
.
clear
(
)
;
return
reader
.
forget
(
)
;
}
static
bool
CreateValueDonePair
(
JSContext
*
aCx
bool
forAuthorCode
JS
:
:
HandleValue
aValue
bool
aDone
JS
:
:
MutableHandleValue
aReturnValue
)
{
JS
:
:
RootedObject
obj
(
aCx
forAuthorCode
?
JS_NewPlainObject
(
aCx
)
:
JS_NewObjectWithGivenProto
(
aCx
nullptr
nullptr
)
)
;
if
(
!
obj
)
{
return
false
;
}
JS
:
:
RootedValue
value
(
aCx
aValue
)
;
if
(
!
JS_WrapValue
(
aCx
&
value
)
)
{
return
false
;
}
if
(
!
JS_DefineProperty
(
aCx
obj
"
value
"
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
JS
:
:
RootedValue
done
(
aCx
JS
:
:
BooleanValue
(
aDone
)
)
;
if
(
!
JS_DefineProperty
(
aCx
obj
"
done
"
done
JSPROP_ENUMERATE
)
)
{
return
false
;
}
aReturnValue
.
setObject
(
*
obj
)
;
return
true
;
}
void
Read_ReadRequest
:
:
ChunkSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
{
JS
:
:
RootedValue
resolvedValue
(
aCx
)
;
if
(
!
CreateValueDonePair
(
aCx
mForAuthorCode
aChunk
false
&
resolvedValue
)
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
mPromise
-
>
MaybeResolve
(
resolvedValue
)
;
}
void
Read_ReadRequest
:
:
CloseSteps
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
JS
:
:
RootedValue
undefined
(
aCx
JS
:
:
UndefinedValue
(
)
)
;
JS
:
:
RootedValue
resolvedValue
(
aCx
)
;
if
(
!
CreateValueDonePair
(
aCx
mForAuthorCode
undefined
true
&
resolvedValue
)
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
mPromise
-
>
MaybeResolve
(
resolvedValue
)
;
}
void
Read_ReadRequest
:
:
ErrorSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
e
ErrorResult
&
aRv
)
{
mPromise
-
>
MaybeReject
(
e
)
;
}
NS_IMPL_CYCLE_COLLECTION
(
ReadRequest
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
Read_ReadRequest
ReadRequest
mPromise
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ReadRequest
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ReadRequest
)
NS_IMPL_ADDREF_INHERITED
(
Read_ReadRequest
ReadRequest
)
NS_IMPL_RELEASE_INHERITED
(
Read_ReadRequest
ReadRequest
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadRequest
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Read_ReadRequest
)
NS_INTERFACE_MAP_END_INHERITING
(
ReadRequest
)
void
ReadableStreamDefaultReaderRead
(
JSContext
*
aCx
ReadableStreamGenericReader
*
aReader
ReadRequest
*
aRequest
ErrorResult
&
aRv
)
{
ReadableStream
*
stream
=
aReader
-
>
GetStream
(
)
;
MOZ_ASSERT
(
stream
)
;
stream
-
>
SetDisturbed
(
true
)
;
switch
(
stream
-
>
State
(
)
)
{
case
ReadableStream
:
:
ReaderState
:
:
Closed
:
{
aRequest
-
>
CloseSteps
(
aCx
aRv
)
;
return
;
}
case
ReadableStream
:
:
ReaderState
:
:
Errored
:
{
JS
:
:
RootedValue
storedError
(
aCx
stream
-
>
StoredError
(
)
)
;
aRequest
-
>
ErrorSteps
(
aCx
storedError
aRv
)
;
return
;
}
case
ReadableStream
:
:
ReaderState
:
:
Readable
:
{
RefPtr
<
ReadableStreamController
>
controller
(
stream
-
>
Controller
(
)
)
;
MOZ_ASSERT
(
controller
)
;
controller
-
>
PullSteps
(
aCx
aRequest
aRv
)
;
return
;
}
}
}
already_AddRefed
<
Promise
>
ReadableStreamDefaultReader
:
:
Read
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
if
(
!
mStream
)
{
aRv
.
ThrowTypeError
(
"
Reading
is
not
possible
after
calling
releaseLock
.
"
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
RefPtr
<
ReadRequest
>
request
=
new
Read_ReadRequest
(
promise
)
;
ReadableStreamDefaultReaderRead
(
aCx
this
request
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
promise
.
forget
(
)
;
}
void
ReadableStreamReaderGenericRelease
(
ReadableStreamGenericReader
*
aReader
ErrorResult
&
aRv
)
{
RefPtr
<
ReadableStream
>
stream
=
aReader
-
>
GetStream
(
)
;
MOZ_ASSERT
(
stream
)
;
MOZ_ASSERT
(
stream
-
>
GetReader
(
)
=
=
aReader
)
;
if
(
aReader
-
>
GetStream
(
)
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
aReader
-
>
ClosedPromise
(
)
-
>
MaybeRejectWithTypeError
(
"
Releasing
lock
on
readable
stream
"
)
;
}
else
{
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
aReader
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
promise
-
>
MaybeRejectWithTypeError
(
"
Lock
Released
"
)
;
aReader
-
>
SetClosedPromise
(
promise
.
forget
(
)
)
;
}
aReader
-
>
ClosedPromise
(
)
-
>
SetSettledPromiseIsHandled
(
)
;
stream
-
>
Controller
(
)
-
>
ReleaseSteps
(
)
;
stream
-
>
SetReader
(
nullptr
)
;
aReader
-
>
SetStream
(
nullptr
)
;
}
void
ReadableStreamDefaultReaderErrorReadRequests
(
JSContext
*
aCx
ReadableStreamDefaultReader
*
aReader
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
{
LinkedList
<
RefPtr
<
ReadRequest
>
>
readRequests
=
std
:
:
move
(
aReader
-
>
ReadRequests
(
)
)
;
aReader
-
>
ReadRequests
(
)
.
clear
(
)
;
while
(
RefPtr
<
ReadRequest
>
readRequest
=
readRequests
.
popFirst
(
)
)
{
readRequest
-
>
ErrorSteps
(
aCx
aError
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
}
void
ReadableStreamDefaultReaderRelease
(
JSContext
*
aCx
ReadableStreamDefaultReader
*
aReader
ErrorResult
&
aRv
)
{
ReadableStreamReaderGenericRelease
(
aReader
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
ErrorResult
rv
;
rv
.
ThrowTypeError
(
"
Releasing
lock
"
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
)
;
MOZ_ALWAYS_TRUE
(
ToJSValue
(
aCx
std
:
:
move
(
rv
)
&
error
)
)
;
ReadableStreamDefaultReaderErrorReadRequests
(
aCx
aReader
error
aRv
)
;
}
void
ReadableStreamDefaultReader
:
:
ReleaseLock
(
ErrorResult
&
aRv
)
{
if
(
!
mStream
)
{
return
;
}
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
mGlobal
)
)
{
return
aRv
.
ThrowUnknownError
(
"
Internal
error
"
)
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
RefPtr
<
ReadableStreamDefaultReader
>
thisRefPtr
=
this
;
ReadableStreamDefaultReaderRelease
(
cx
thisRefPtr
aRv
)
;
}
already_AddRefed
<
Promise
>
ReadableStreamGenericReader
:
:
Closed
(
)
const
{
return
do_AddRef
(
mClosedPromise
)
;
}
MOZ_CAN_RUN_SCRIPT
static
already_AddRefed
<
Promise
>
ReadableStreamGenericReaderCancel
(
JSContext
*
aCx
ReadableStreamGenericReader
*
aReader
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
{
RefPtr
<
ReadableStream
>
stream
=
aReader
-
>
GetStream
(
)
;
MOZ_ASSERT
(
stream
)
;
return
ReadableStreamCancel
(
aCx
stream
aReason
aRv
)
;
}
already_AddRefed
<
Promise
>
ReadableStreamGenericReader
:
:
Cancel
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
{
if
(
!
mStream
)
{
aRv
.
ThrowTypeError
(
"
Canceling
is
not
possible
after
calling
releaseLock
.
"
)
;
return
nullptr
;
}
return
ReadableStreamGenericReaderCancel
(
aCx
this
aReason
aRv
)
;
}
void
SetUpReadableStreamDefaultReader
(
JSContext
*
aCx
ReadableStreamDefaultReader
*
aReader
ReadableStream
*
aStream
ErrorResult
&
aRv
)
{
if
(
IsReadableStreamLocked
(
aStream
)
)
{
return
aRv
.
ThrowTypeError
(
"
Cannot
get
a
new
reader
for
a
readable
stream
already
locked
by
"
"
another
reader
.
"
)
;
}
if
(
!
ReadableStreamReaderGenericInitialize
(
aCx
aReader
aStream
aRv
)
)
{
return
;
}
aReader
-
>
ReadRequests
(
)
.
clear
(
)
;
}
}
}
