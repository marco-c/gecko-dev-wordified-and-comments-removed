#
include
"
mozilla
/
dom
/
BodyStream
.
h
"
#
include
"
mozilla
/
dom
/
ByteStreamHelpers
.
h
"
#
include
"
mozilla
/
dom
/
ReadableByteStreamController
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
namespace
mozilla
:
:
dom
{
JSObject
*
TransferArrayBuffer
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
)
{
MOZ_ASSERT
(
JS
:
:
IsArrayBufferObject
(
aObject
)
)
;
MOZ_ASSERT
(
!
JS
:
:
IsDetachedArrayBufferObject
(
aObject
)
)
;
size_t
bufferLength
=
JS
:
:
GetArrayBufferByteLength
(
aObject
)
;
void
*
bufferData
=
JS
:
:
StealArrayBufferContents
(
aCx
aObject
)
;
if
(
!
JS
:
:
DetachArrayBuffer
(
aCx
aObject
)
)
{
return
nullptr
;
}
return
JS
:
:
NewArrayBufferWithContents
(
aCx
bufferLength
bufferData
)
;
}
bool
CanTransferArrayBuffer
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
JS
:
:
IsArrayBufferObject
(
aObject
)
)
;
if
(
JS
:
:
IsDetachedArrayBufferObject
(
aObject
)
)
{
return
false
;
}
bool
hasDefinedArrayBufferDetachKey
=
false
;
if
(
!
JS
:
:
HasDefinedArrayBufferDetachKey
(
aCx
aObject
&
hasDefinedArrayBufferDetachKey
)
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
false
;
}
return
!
hasDefinedArrayBufferDetachKey
;
}
JSObject
*
CloneAsUint8Array
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
)
{
MOZ_ASSERT
(
JS_IsArrayBufferViewObject
(
aObject
)
)
;
bool
isShared
;
JS
:
:
Rooted
<
JSObject
*
>
viewedArrayBuffer
(
aCx
JS_GetArrayBufferViewBuffer
(
aCx
aObject
&
isShared
)
)
;
if
(
!
viewedArrayBuffer
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
JS
:
:
IsDetachedArrayBufferObject
(
viewedArrayBuffer
)
)
;
size_t
byteOffset
=
JS_GetTypedArrayByteOffset
(
aObject
)
;
size_t
byteLength
=
JS_GetTypedArrayByteLength
(
aObject
)
;
JS
:
:
Rooted
<
JSObject
*
>
buffer
(
aCx
JS
:
:
ArrayBufferClone
(
aCx
viewedArrayBuffer
byteOffset
byteLength
)
)
;
if
(
!
buffer
)
{
return
nullptr
;
}
JS
:
:
Rooted
<
JSObject
*
>
array
(
aCx
JS_NewUint8ArrayWithBuffer
(
aCx
buffer
0
static_cast
<
int64_t
>
(
byteLength
)
)
)
;
if
(
!
array
)
{
return
nullptr
;
}
return
array
;
}
class
BodyStreamUnderlyingSourceAlgorithms
final
:
public
UnderlyingSourceAlgorithmsBase
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
BodyStreamUnderlyingSourceAlgorithms
UnderlyingSourceAlgorithmsBase
)
explicit
BodyStreamUnderlyingSourceAlgorithms
(
BodyStreamHolder
*
underlyingSource
)
:
mUnderlyingSource
(
underlyingSource
)
{
}
MOZ_CAN_RUN_SCRIPT
void
StartCallback
(
JSContext
*
aCx
ReadableStreamController
&
aController
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetVal
ErrorResult
&
aRv
)
override
{
aRetVal
.
setUndefined
(
)
;
}
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
PullCallback
(
JSContext
*
aCx
ReadableStreamController
&
aController
ErrorResult
&
aRv
)
override
{
RefPtr
<
BodyStream
>
bodyStream
=
mUnderlyingSource
-
>
GetBodyStream
(
)
;
return
bodyStream
-
>
PullCallback
(
aCx
aController
aRv
)
;
}
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
CancelCallback
(
JSContext
*
aCx
const
Optional
<
JS
:
:
Handle
<
JS
:
:
Value
>
>
&
aReason
ErrorResult
&
aRv
)
override
{
RefPtr
<
BodyStream
>
bodyStream
=
mUnderlyingSource
-
>
GetBodyStream
(
)
;
return
bodyStream
-
>
CancelCallback
(
aCx
aReason
aRv
)
;
}
void
ReleaseObjects
(
)
override
{
RefPtr
<
BodyStreamHolder
>
holder
=
mUnderlyingSource
.
forget
(
)
;
if
(
RefPtr
<
BodyStream
>
bodyStream
=
holder
-
>
GetBodyStream
(
)
)
{
bodyStream
-
>
CloseInputAndReleaseObjects
(
)
;
}
}
BodyStreamHolder
*
GetBodyStreamHolder
(
)
override
{
return
mUnderlyingSource
;
}
protected
:
~
BodyStreamUnderlyingSourceAlgorithms
(
)
override
=
default
;
private
:
RefPtr
<
BodyStreamHolder
>
mUnderlyingSource
;
}
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
BodyStreamUnderlyingSourceAlgorithms
UnderlyingSourceAlgorithmsBase
mUnderlyingSource
)
NS_IMPL_ADDREF_INHERITED
(
BodyStreamUnderlyingSourceAlgorithms
UnderlyingSourceAlgorithmsBase
)
NS_IMPL_RELEASE_INHERITED
(
BodyStreamUnderlyingSourceAlgorithms
UnderlyingSourceAlgorithmsBase
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
BodyStreamUnderlyingSourceAlgorithms
)
NS_INTERFACE_MAP_END_INHERITING
(
UnderlyingSourceAlgorithmsBase
)
void
SetUpReadableByteStreamControllerFromBodyStreamUnderlyingSource
(
JSContext
*
aCx
ReadableStream
*
aStream
BodyStreamHolder
*
aUnderlyingSource
ErrorResult
&
aRv
)
{
auto
controller
=
MakeRefPtr
<
ReadableByteStreamController
>
(
aStream
-
>
GetParentObject
(
)
)
;
auto
algorithms
=
MakeRefPtr
<
BodyStreamUnderlyingSourceAlgorithms
>
(
aUnderlyingSource
)
;
Maybe
<
uint64_t
>
autoAllocateChunkSize
=
mozilla
:
:
Nothing
(
)
;
double
highWaterMark
=
0
.
0
;
SetUpReadableByteStreamController
(
aCx
aStream
controller
algorithms
highWaterMark
autoAllocateChunkSize
aRv
)
;
}
}
