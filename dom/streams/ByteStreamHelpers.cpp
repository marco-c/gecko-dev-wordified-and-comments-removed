#
include
"
mozilla
/
dom
/
ByteStreamHelpers
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
namespace
mozilla
{
namespace
dom
{
JSObject
*
TransferArrayBuffer
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
)
{
MOZ_ASSERT
(
!
JS
:
:
IsDetachedArrayBufferObject
(
aObject
)
)
;
size_t
bufferLength
=
JS
:
:
GetArrayBufferByteLength
(
aObject
)
;
void
*
bufferData
=
JS
:
:
StealArrayBufferContents
(
aCx
aObject
)
;
if
(
!
JS
:
:
DetachArrayBuffer
(
aCx
aObject
)
)
{
return
nullptr
;
}
return
JS
:
:
NewArrayBufferWithContents
(
aCx
bufferLength
bufferData
)
;
}
bool
CanTransferArrayBuffer
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
JS
:
:
IsArrayBufferObject
(
aObject
)
)
;
if
(
JS
:
:
IsDetachedArrayBufferObject
(
aObject
)
)
{
return
false
;
}
bool
hasDefinedArrayBufferDetachKey
;
if
(
!
JS
:
:
HasDefinedArrayBufferDetachKey
(
aCx
aObject
&
hasDefinedArrayBufferDetachKey
)
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
false
;
}
if
(
hasDefinedArrayBufferDetachKey
)
{
return
false
;
}
return
true
;
}
JSObject
*
CloneAsUint8Array
(
JSContext
*
aCx
JS
:
:
HandleObject
aObject
)
{
MOZ_ASSERT
(
JS_IsArrayBufferViewObject
(
aObject
)
)
;
bool
isShared
;
JS
:
:
RootedObject
viewedArrayBuffer
(
aCx
JS_GetArrayBufferViewBuffer
(
aCx
aObject
&
isShared
)
)
;
if
(
!
viewedArrayBuffer
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
JS
:
:
IsDetachedArrayBufferObject
(
viewedArrayBuffer
)
)
;
JS
:
:
RootedObject
buffer
(
aCx
JS
:
:
CopyArrayBuffer
(
aCx
aObject
)
)
;
if
(
!
buffer
)
{
return
nullptr
;
}
size_t
length
=
JS_GetTypedArrayLength
(
aObject
)
;
size_t
byteOffset
=
JS_GetTypedArrayByteOffset
(
aObject
)
;
JS
:
:
RootedObject
array
(
aCx
JS_NewUint8ArrayWithBuffer
(
aCx
buffer
byteOffset
(
int64_t
)
length
)
)
;
if
(
!
array
)
{
return
nullptr
;
}
return
array
;
}
}
}
