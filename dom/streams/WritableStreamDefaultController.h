#
ifndef
mozilla_dom_WritableStreamDefaultController_h
#
define
mozilla_dom_WritableStreamDefaultController_h
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
QueuingStrategyBinding
.
h
"
#
include
"
mozilla
/
dom
/
QueueWithSizes
.
h
"
#
include
"
mozilla
/
dom
/
ReadRequest
.
h
"
#
include
"
mozilla
/
dom
/
UnderlyingSinkCallbackHelpers
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsISupportsBase
.
h
"
namespace
mozilla
:
:
dom
{
class
AbortSignal
;
class
WritableStream
;
struct
UnderlyingSink
;
class
WritableStreamDefaultController
final
:
public
nsISupports
public
nsWrapperCache
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
WritableStreamDefaultController
)
explicit
WritableStreamDefaultController
(
nsISupports
*
aGlobal
WritableStream
&
aStream
)
;
protected
:
~
WritableStreamDefaultController
(
)
;
public
:
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
mGlobal
;
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
AbortSignal
*
Signal
(
)
{
return
mSignal
;
}
MOZ_CAN_RUN_SCRIPT
void
Error
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
virtual
already_AddRefed
<
Promise
>
AbortSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
;
virtual
void
ErrorSteps
(
)
;
QueueWithSizes
&
Queue
(
)
{
return
mQueue
;
}
double
QueueTotalSize
(
)
const
{
return
mQueueTotalSize
;
}
void
SetQueueTotalSize
(
double
aQueueTotalSize
)
{
mQueueTotalSize
=
aQueueTotalSize
;
}
void
SetSignal
(
AbortSignal
*
aSignal
)
;
bool
Started
(
)
const
{
return
mStarted
;
}
void
SetStarted
(
bool
aStarted
)
{
mStarted
=
aStarted
;
}
double
StrategyHWM
(
)
const
{
return
mStrategyHWM
;
}
void
SetStrategyHWM
(
double
aStrategyHWM
)
{
mStrategyHWM
=
aStrategyHWM
;
}
QueuingStrategySize
*
StrategySizeAlgorithm
(
)
const
{
return
mStrategySizeAlgorithm
;
}
void
SetStrategySizeAlgorithm
(
QueuingStrategySize
*
aStrategySizeAlgorithm
)
{
mStrategySizeAlgorithm
=
aStrategySizeAlgorithm
;
}
UnderlyingSinkWriteCallbackHelper
*
GetWriteAlgorithm
(
)
{
return
mWriteAlgorithm
;
}
void
SetWriteAlgorithm
(
UnderlyingSinkWriteCallbackHelper
*
aWriteAlgorithm
)
{
mWriteAlgorithm
=
aWriteAlgorithm
;
}
UnderlyingSinkCloseCallbackHelper
*
GetCloseAlgorithm
(
)
{
return
mCloseAlgorithm
;
}
void
SetCloseAlgorithm
(
UnderlyingSinkCloseCallbackHelper
*
aCloseAlgorithm
)
{
mCloseAlgorithm
=
aCloseAlgorithm
;
}
UnderlyingSinkAbortCallbackHelper
*
GetAbortAlgorithm
(
)
{
return
mAbortAlgorithm
;
}
void
SetAbortAlgorithm
(
UnderlyingSinkAbortCallbackHelper
*
aAbortAlgorithm
)
{
mAbortAlgorithm
=
aAbortAlgorithm
;
}
WritableStream
*
Stream
(
)
{
return
mStream
;
}
bool
GetBackpressure
(
)
const
{
double
desiredSize
=
GetDesiredSize
(
)
;
return
desiredSize
<
=
0
;
}
double
GetDesiredSize
(
)
const
{
return
mStrategyHWM
-
mQueueTotalSize
;
}
void
ClearAlgorithms
(
)
{
mWriteAlgorithm
=
nullptr
;
mCloseAlgorithm
=
nullptr
;
mAbortAlgorithm
=
nullptr
;
mStrategySizeAlgorithm
=
nullptr
;
}
private
:
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
QueueWithSizes
mQueue
=
{
}
;
double
mQueueTotalSize
=
0
.
0
;
RefPtr
<
AbortSignal
>
mSignal
;
bool
mStarted
=
false
;
double
mStrategyHWM
=
0
.
0
;
RefPtr
<
QueuingStrategySize
>
mStrategySizeAlgorithm
;
RefPtr
<
UnderlyingSinkWriteCallbackHelper
>
mWriteAlgorithm
;
RefPtr
<
UnderlyingSinkCloseCallbackHelper
>
mCloseAlgorithm
;
RefPtr
<
UnderlyingSinkAbortCallbackHelper
>
mAbortAlgorithm
;
RefPtr
<
WritableStream
>
mStream
;
}
;
MOZ_CAN_RUN_SCRIPT
void
SetUpWritableStreamDefaultController
(
JSContext
*
aCx
WritableStream
*
aStream
WritableStreamDefaultController
*
aController
UnderlyingSinkStartCallbackHelper
*
aStartAlgorithm
UnderlyingSinkWriteCallbackHelper
*
aWriteAlgorithm
UnderlyingSinkCloseCallbackHelper
*
aCloseAlgorithm
UnderlyingSinkAbortCallbackHelper
*
aAbortAlgorithm
double
aHighWaterMark
QueuingStrategySize
*
aSizeAlgorithm
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
SetUpWritableStreamDefaultControllerFromUnderlyingSink
(
JSContext
*
aCx
WritableStream
*
aStream
JS
:
:
HandleObject
aUnderlyingSink
UnderlyingSink
&
aUnderlyingSinkDict
double
aHighWaterMark
QueuingStrategySize
*
aSizeAlgorithm
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
WritableStreamDefaultControllerClose
(
JSContext
*
aCx
WritableStreamDefaultController
*
aController
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
WritableStreamDefaultControllerWrite
(
JSContext
*
aCx
WritableStreamDefaultController
*
aController
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
double
chunkSize
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
WritableStreamDefaultControllerError
(
JSContext
*
aCx
WritableStreamDefaultController
*
aController
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
WritableStreamDefaultControllerErrorIfNeeded
(
JSContext
*
aCx
WritableStreamDefaultController
*
aController
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
double
WritableStreamDefaultControllerGetChunkSize
(
JSContext
*
aCx
WritableStreamDefaultController
*
aController
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
;
}
#
endif
