#
include
"
ReadableStreamPipeTo
.
h
"
#
include
"
js
/
Exception
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
AbortFollower
.
h
"
#
include
"
mozilla
/
dom
/
AbortSignal
.
h
"
#
include
"
mozilla
/
dom
/
Promise
-
inl
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamDefaultReader
.
h
"
#
include
"
mozilla
/
dom
/
WritableStream
.
h
"
#
include
"
mozilla
/
dom
/
WritableStreamDefaultWriter
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mozilla
:
:
dom
{
using
namespace
streams_abstract
;
struct
PipeToReadRequest
;
class
WriteFinishedPromiseHandler
;
class
ShutdownActionFinishedPromiseHandler
;
class
PipeToPump
final
:
public
AbortFollower
{
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
PipeToPump
)
friend
struct
PipeToReadRequest
;
friend
class
WriteFinishedPromiseHandler
;
friend
class
ShutdownActionFinishedPromiseHandler
;
PipeToPump
(
Promise
*
aPromise
ReadableStreamDefaultReader
*
aReader
WritableStreamDefaultWriter
*
aWriter
bool
aPreventClose
bool
aPreventAbort
bool
aPreventCancel
)
:
mPromise
(
aPromise
)
mReader
(
aReader
)
mWriter
(
aWriter
)
mPreventClose
(
aPreventClose
)
mPreventAbort
(
aPreventAbort
)
mPreventCancel
(
aPreventCancel
)
{
}
MOZ_CAN_RUN_SCRIPT
void
Start
(
JSContext
*
aCx
AbortSignal
*
aSignal
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
RunAbortAlgorithm
(
)
override
;
private
:
~
PipeToPump
(
)
override
=
default
;
MOZ_CAN_RUN_SCRIPT
void
PerformAbortAlgorithm
(
JSContext
*
aCx
AbortSignalImpl
*
aSignal
)
;
MOZ_CAN_RUN_SCRIPT
bool
SourceOrDestErroredOrClosed
(
JSContext
*
aCx
)
;
using
ShutdownAction
=
already_AddRefed
<
Promise
>
(
*
)
(
JSContext
*
PipeToPump
*
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
ErrorResult
&
)
;
MOZ_CAN_RUN_SCRIPT
void
ShutdownWithAction
(
JSContext
*
aCx
ShutdownAction
aAction
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
)
;
MOZ_CAN_RUN_SCRIPT
void
ShutdownWithActionAfterFinishedWrite
(
JSContext
*
aCx
ShutdownAction
aAction
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
)
;
MOZ_CAN_RUN_SCRIPT
void
Shutdown
(
JSContext
*
aCx
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
)
;
void
Finalize
(
JSContext
*
aCx
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
)
;
MOZ_CAN_RUN_SCRIPT
void
OnReadFulfilled
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
OnWriterReady
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
)
;
MOZ_CAN_RUN_SCRIPT
void
Read
(
JSContext
*
aCx
)
;
MOZ_CAN_RUN_SCRIPT
void
OnSourceClosed
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
)
;
MOZ_CAN_RUN_SCRIPT
void
OnSourceErrored
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aSourceStoredError
)
;
MOZ_CAN_RUN_SCRIPT
void
OnDestClosed
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
)
;
MOZ_CAN_RUN_SCRIPT
void
OnDestErrored
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aDestStoredError
)
;
RefPtr
<
Promise
>
mPromise
;
RefPtr
<
ReadableStreamDefaultReader
>
mReader
;
RefPtr
<
WritableStreamDefaultWriter
>
mWriter
;
RefPtr
<
Promise
>
mLastWritePromise
;
const
bool
mPreventClose
;
const
bool
mPreventAbort
;
const
bool
mPreventCancel
;
bool
mShuttingDown
=
false
;
#
ifdef
DEBUG
bool
mReadChunk
=
false
;
#
endif
}
;
class
PipeToPumpHandler
final
:
public
PromiseNativeHandler
{
virtual
~
PipeToPumpHandler
(
)
=
default
;
using
FunPtr
=
void
(
PipeToPump
:
:
*
)
(
JSContext
*
JS
:
:
Handle
<
JS
:
:
Value
>
)
;
RefPtr
<
PipeToPump
>
mPipeToPump
;
FunPtr
mResolved
;
FunPtr
mRejected
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
PipeToPumpHandler
)
explicit
PipeToPumpHandler
(
PipeToPump
*
aPipeToPump
FunPtr
aResolved
FunPtr
aRejected
)
:
mPipeToPump
(
aPipeToPump
)
mResolved
(
aResolved
)
mRejected
(
aRejected
)
{
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
)
override
{
if
(
mResolved
)
{
(
mPipeToPump
-
>
*
mResolved
)
(
aCx
aValue
)
;
}
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
)
override
{
if
(
mRejected
)
{
(
mPipeToPump
-
>
*
mRejected
)
(
aCx
aReason
)
;
}
}
}
;
NS_IMPL_CYCLE_COLLECTION
(
PipeToPumpHandler
mPipeToPump
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
PipeToPumpHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
PipeToPumpHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
PipeToPumpHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
void
PipeToPump
:
:
RunAbortAlgorithm
(
)
{
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
mReader
-
>
GetStream
(
)
-
>
GetParentObject
(
)
)
)
{
NS_WARNING
(
"
Failed
to
initialize
AutoJSAPI
in
PipeToPump
:
:
RunAbortAlgorithm
"
)
;
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
RefPtr
<
AbortSignalImpl
>
signal
=
Signal
(
)
;
PerformAbortAlgorithm
(
cx
signal
)
;
}
void
PipeToPump
:
:
PerformAbortAlgorithm
(
JSContext
*
aCx
AbortSignalImpl
*
aSignal
)
{
MOZ_ASSERT
(
aSignal
-
>
Aborted
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
)
;
aSignal
-
>
GetReason
(
aCx
&
error
)
;
auto
action
=
[
]
(
JSContext
*
aCx
PipeToPump
*
aPipeToPump
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
ErrorResult
&
aRv
)
MOZ_CAN_RUN_SCRIPT
{
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
*
aError
)
;
nsTArray
<
RefPtr
<
Promise
>
>
actions
;
if
(
!
aPipeToPump
-
>
mPreventAbort
)
{
RefPtr
<
WritableStream
>
dest
=
aPipeToPump
-
>
mWriter
-
>
GetStream
(
)
;
if
(
dest
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Writable
)
{
RefPtr
<
Promise
>
p
=
WritableStreamAbort
(
aCx
dest
error
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
already_AddRefed
<
Promise
>
(
)
;
}
actions
.
AppendElement
(
p
)
;
}
}
if
(
!
aPipeToPump
-
>
mPreventCancel
)
{
RefPtr
<
ReadableStream
>
source
=
aPipeToPump
-
>
mReader
-
>
GetStream
(
)
;
if
(
source
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
RefPtr
<
Promise
>
p
=
ReadableStreamCancel
(
aCx
source
error
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
already_AddRefed
<
Promise
>
(
)
;
}
actions
.
AppendElement
(
p
)
;
}
}
return
Promise
:
:
All
(
aCx
actions
aRv
)
;
}
;
JS
:
:
Rooted
<
Maybe
<
JS
:
:
Value
>
>
someError
(
aCx
Some
(
error
.
get
(
)
)
)
;
ShutdownWithAction
(
aCx
action
someError
)
;
}
bool
PipeToPump
:
:
SourceOrDestErroredOrClosed
(
JSContext
*
aCx
)
{
RefPtr
<
ReadableStream
>
source
=
mReader
-
>
GetStream
(
)
;
RefPtr
<
WritableStream
>
dest
=
mWriter
-
>
GetStream
(
)
;
if
(
source
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Errored
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
storedError
(
aCx
source
-
>
StoredError
(
)
)
;
OnSourceErrored
(
aCx
storedError
)
;
return
true
;
}
if
(
dest
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Errored
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
storedError
(
aCx
dest
-
>
StoredError
(
)
)
;
OnDestErrored
(
aCx
storedError
)
;
return
true
;
}
if
(
source
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Closed
)
{
OnSourceClosed
(
aCx
JS
:
:
UndefinedHandleValue
)
;
return
true
;
}
if
(
dest
-
>
CloseQueuedOrInFlight
(
)
|
|
dest
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Closed
)
{
OnDestClosed
(
aCx
JS
:
:
UndefinedHandleValue
)
;
return
true
;
}
return
false
;
}
void
PipeToPump
:
:
Start
(
JSContext
*
aCx
AbortSignal
*
aSignal
)
{
if
(
aSignal
)
{
if
(
aSignal
-
>
Aborted
(
)
)
{
PerformAbortAlgorithm
(
aCx
aSignal
)
;
return
;
}
Follow
(
aSignal
)
;
}
if
(
SourceOrDestErroredOrClosed
(
aCx
)
)
{
return
;
}
RefPtr
<
Promise
>
readerClosed
=
mReader
-
>
ClosedPromise
(
)
;
readerClosed
-
>
AppendNativeHandler
(
new
PipeToPumpHandler
(
this
&
PipeToPump
:
:
OnSourceClosed
&
PipeToPump
:
:
OnSourceErrored
)
)
;
RefPtr
<
Promise
>
writerClosed
=
mWriter
-
>
ClosedPromise
(
)
;
writerClosed
-
>
AppendNativeHandler
(
new
PipeToPumpHandler
(
this
&
PipeToPump
:
:
OnDestClosed
&
PipeToPump
:
:
OnDestErrored
)
)
;
Read
(
aCx
)
;
}
class
WriteFinishedPromiseHandler
final
:
public
PromiseNativeHandler
{
RefPtr
<
PipeToPump
>
mPipeToPump
;
PipeToPump
:
:
ShutdownAction
mAction
;
bool
mHasError
;
JS
:
:
Heap
<
JS
:
:
Value
>
mError
;
virtual
~
WriteFinishedPromiseHandler
(
)
{
mozilla
:
:
DropJSObjects
(
this
)
;
}
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
WriteFinishedPromiseHandler
)
explicit
WriteFinishedPromiseHandler
(
JSContext
*
aCx
PipeToPump
*
aPipeToPump
PipeToPump
:
:
ShutdownAction
aAction
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
)
:
mPipeToPump
(
aPipeToPump
)
mAction
(
aAction
)
{
mHasError
=
aError
.
isSome
(
)
;
if
(
mHasError
)
{
mError
=
*
aError
;
}
mozilla
:
:
HoldJSObjects
(
this
)
;
}
MOZ_CAN_RUN_SCRIPT
void
WriteFinished
(
JSContext
*
aCx
)
{
RefPtr
<
PipeToPump
>
pipeToPump
=
mPipeToPump
;
JS
:
:
Rooted
<
Maybe
<
JS
:
:
Value
>
>
error
(
aCx
)
;
if
(
mHasError
)
{
error
=
Some
(
mError
)
;
}
pipeToPump
-
>
ShutdownWithActionAfterFinishedWrite
(
aCx
mAction
error
)
;
}
MOZ_CAN_RUN_SCRIPT
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
)
override
{
WriteFinished
(
aCx
)
;
}
MOZ_CAN_RUN_SCRIPT
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
)
override
{
WriteFinished
(
aCx
)
;
}
}
;
NS_IMPL_CYCLE_COLLECTION_WITH_JS_MEMBERS
(
WriteFinishedPromiseHandler
(
mPipeToPump
)
(
mError
)
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
WriteFinishedPromiseHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
WriteFinishedPromiseHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
WriteFinishedPromiseHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
void
PipeToPump
:
:
ShutdownWithAction
(
JSContext
*
aCx
ShutdownAction
aAction
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
)
{
if
(
mShuttingDown
)
{
return
;
}
mShuttingDown
=
true
;
RefPtr
<
WritableStream
>
dest
=
mWriter
-
>
GetStream
(
)
;
if
(
dest
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Writable
&
&
!
dest
-
>
CloseQueuedOrInFlight
(
)
)
{
if
(
mLastWritePromise
)
{
mLastWritePromise
-
>
AppendNativeHandler
(
new
WriteFinishedPromiseHandler
(
aCx
this
aAction
aError
)
)
;
return
;
}
}
ShutdownWithActionAfterFinishedWrite
(
aCx
aAction
aError
)
;
}
class
ShutdownActionFinishedPromiseHandler
final
:
public
PromiseNativeHandler
{
RefPtr
<
PipeToPump
>
mPipeToPump
;
bool
mHasError
;
JS
:
:
Heap
<
JS
:
:
Value
>
mError
;
virtual
~
ShutdownActionFinishedPromiseHandler
(
)
{
mozilla
:
:
DropJSObjects
(
this
)
;
}
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
ShutdownActionFinishedPromiseHandler
)
explicit
ShutdownActionFinishedPromiseHandler
(
JSContext
*
aCx
PipeToPump
*
aPipeToPump
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
)
:
mPipeToPump
(
aPipeToPump
)
{
mHasError
=
aError
.
isSome
(
)
;
if
(
mHasError
)
{
mError
=
*
aError
;
}
mozilla
:
:
HoldJSObjects
(
this
)
;
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
)
override
{
JS
:
:
Rooted
<
Maybe
<
JS
:
:
Value
>
>
error
(
aCx
)
;
if
(
mHasError
)
{
error
=
Some
(
mError
)
;
}
mPipeToPump
-
>
Finalize
(
aCx
error
)
;
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
)
override
{
JS
:
:
Rooted
<
Maybe
<
JS
:
:
Value
>
>
error
(
aCx
Some
(
aReason
)
)
;
mPipeToPump
-
>
Finalize
(
aCx
error
)
;
}
}
;
NS_IMPL_CYCLE_COLLECTION_WITH_JS_MEMBERS
(
ShutdownActionFinishedPromiseHandler
(
mPipeToPump
)
(
mError
)
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ShutdownActionFinishedPromiseHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ShutdownActionFinishedPromiseHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ShutdownActionFinishedPromiseHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
void
PipeToPump
:
:
ShutdownWithActionAfterFinishedWrite
(
JSContext
*
aCx
ShutdownAction
aAction
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
)
{
if
(
!
aAction
)
{
Finalize
(
aCx
aError
)
;
return
;
}
RefPtr
<
PipeToPump
>
thisRefPtr
=
this
;
ErrorResult
rv
;
RefPtr
<
Promise
>
p
=
aAction
(
aCx
thisRefPtr
aError
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
aCx
)
)
{
JS
:
:
Rooted
<
Maybe
<
JS
:
:
Value
>
>
someError
(
aCx
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
)
;
if
(
JS_GetPendingException
(
aCx
&
error
)
)
{
someError
=
Some
(
error
.
get
(
)
)
;
}
JS_ClearPendingException
(
aCx
)
;
Finalize
(
aCx
someError
)
;
return
;
}
p
-
>
AppendNativeHandler
(
new
ShutdownActionFinishedPromiseHandler
(
aCx
this
aError
)
)
;
}
void
PipeToPump
:
:
Shutdown
(
JSContext
*
aCx
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
)
{
ShutdownWithAction
(
aCx
nullptr
aError
)
;
}
void
PipeToPump
:
:
Finalize
(
JSContext
*
aCx
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
)
{
IgnoredErrorResult
rv
;
WritableStreamDefaultWriterRelease
(
aCx
mWriter
)
;
MOZ_ASSERT
(
!
mReader
-
>
IsBYOB
(
)
)
;
ReadableStreamDefaultReaderRelease
(
aCx
mReader
rv
)
;
NS_WARNING_ASSERTION
(
!
rv
.
Failed
(
)
"
ReadableStreamReaderGenericRelease
should
not
fail
.
"
)
;
if
(
IsFollowing
(
)
)
{
Unfollow
(
)
;
}
if
(
aError
.
isSome
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
*
aError
)
;
mPromise
-
>
MaybeReject
(
error
)
;
}
else
{
mPromise
-
>
MaybeResolveWithUndefined
(
)
;
}
mPromise
=
nullptr
;
mReader
=
nullptr
;
mWriter
=
nullptr
;
mLastWritePromise
=
nullptr
;
Unfollow
(
)
;
}
void
PipeToPump
:
:
OnReadFulfilled
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
{
if
(
mShuttingDown
)
{
return
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
CreateInfallible
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
)
;
promise
-
>
MaybeResolveWithUndefined
(
)
;
auto
result
=
promise
-
>
ThenWithCycleCollectedArgsJS
(
[
]
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
ErrorResult
&
aRv
const
RefPtr
<
PipeToPump
>
&
aSelf
const
RefPtr
<
WritableStreamDefaultWriter
>
&
aWriter
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
)
MOZ_CAN_RUN_SCRIPT_FOR_DEFINITION
-
>
already_AddRefed
<
Promise
>
{
RefPtr
<
Promise
>
promise
=
WritableStreamDefaultWriterWrite
(
aCx
aWriter
aChunk
aRv
)
;
aSelf
-
>
Read
(
aCx
)
;
return
promise
.
forget
(
)
;
}
std
:
:
make_tuple
(
RefPtr
{
this
}
mWriter
)
std
:
:
make_tuple
(
aChunk
)
)
;
if
(
result
.
isErr
(
)
)
{
mLastWritePromise
=
nullptr
;
return
;
}
mLastWritePromise
=
result
.
unwrap
(
)
;
mLastWritePromise
-
>
AppendNativeHandler
(
new
PipeToPumpHandler
(
this
nullptr
&
PipeToPump
:
:
OnDestErrored
)
)
;
}
void
PipeToPump
:
:
OnWriterReady
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
)
{
Read
(
aCx
)
;
}
struct
PipeToReadRequest
:
public
ReadRequest
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
PipeToReadRequest
ReadRequest
)
RefPtr
<
PipeToPump
>
mPipeToPump
;
explicit
PipeToReadRequest
(
PipeToPump
*
aPipeToPump
)
:
mPipeToPump
(
aPipeToPump
)
{
}
MOZ_CAN_RUN_SCRIPT
void
ChunkSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
override
{
RefPtr
<
PipeToPump
>
pipeToPump
=
mPipeToPump
;
pipeToPump
-
>
OnReadFulfilled
(
aCx
aChunk
aRv
)
;
}
void
CloseSteps
(
JSContext
*
aCx
ErrorResult
&
aRv
)
override
{
}
void
ErrorSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
override
{
}
protected
:
virtual
~
PipeToReadRequest
(
)
=
default
;
}
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
PipeToReadRequest
ReadRequest
mPipeToPump
)
NS_IMPL_ADDREF_INHERITED
(
PipeToReadRequest
ReadRequest
)
NS_IMPL_RELEASE_INHERITED
(
PipeToReadRequest
ReadRequest
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
PipeToReadRequest
)
NS_INTERFACE_MAP_END_INHERITING
(
ReadRequest
)
void
PipeToPump
:
:
Read
(
JSContext
*
aCx
)
{
#
ifdef
DEBUG
mReadChunk
=
true
;
#
endif
if
(
mShuttingDown
)
{
return
;
}
Nullable
<
double
>
desiredSize
=
WritableStreamDefaultWriterGetDesiredSize
(
mWriter
)
;
if
(
desiredSize
.
IsNull
(
)
)
{
return
;
}
if
(
desiredSize
.
Value
(
)
<
=
0
)
{
RefPtr
<
Promise
>
readyPromise
=
mWriter
-
>
Ready
(
)
;
readyPromise
-
>
AppendNativeHandler
(
new
PipeToPumpHandler
(
this
&
PipeToPump
:
:
OnWriterReady
nullptr
)
)
;
return
;
}
RefPtr
<
ReadableStreamDefaultReader
>
reader
=
mReader
;
RefPtr
<
ReadRequest
>
request
=
new
PipeToReadRequest
(
this
)
;
ErrorResult
rv
;
ReadableStreamDefaultReaderRead
(
aCx
reader
request
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
aCx
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
)
;
JS
:
:
Rooted
<
Maybe
<
JS
:
:
Value
>
>
someError
(
aCx
)
;
if
(
JS_GetPendingException
(
aCx
&
error
)
)
{
someError
=
Some
(
error
.
get
(
)
)
;
}
JS_ClearPendingException
(
aCx
)
;
Shutdown
(
aCx
someError
)
;
}
}
void
PipeToPump
:
:
OnSourceClosed
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
)
{
if
(
!
mPreventClose
)
{
ShutdownWithAction
(
aCx
[
]
(
JSContext
*
aCx
PipeToPump
*
aPipeToPump
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
ErrorResult
&
aRv
)
MOZ_CAN_RUN_SCRIPT
{
RefPtr
<
WritableStreamDefaultWriter
>
writer
=
aPipeToPump
-
>
mWriter
;
return
WritableStreamDefaultWriterCloseWithErrorPropagation
(
aCx
writer
aRv
)
;
}
JS
:
:
NothingHandleValue
)
;
}
else
{
Shutdown
(
aCx
JS
:
:
NothingHandleValue
)
;
}
}
void
PipeToPump
:
:
OnSourceErrored
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aSourceStoredError
)
{
JS
:
:
Rooted
<
Maybe
<
JS
:
:
Value
>
>
error
(
aCx
Some
(
aSourceStoredError
)
)
;
if
(
!
mPreventAbort
)
{
ShutdownWithAction
(
aCx
[
]
(
JSContext
*
aCx
PipeToPump
*
aPipeToPump
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
ErrorResult
&
aRv
)
MOZ_CAN_RUN_SCRIPT
{
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
*
aError
)
;
RefPtr
<
WritableStream
>
dest
=
aPipeToPump
-
>
mWriter
-
>
GetStream
(
)
;
return
WritableStreamAbort
(
aCx
dest
error
aRv
)
;
}
error
)
;
}
else
{
Shutdown
(
aCx
error
)
;
}
}
void
PipeToPump
:
:
OnDestClosed
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
)
{
if
(
mShuttingDown
)
{
return
;
}
MOZ_ASSERT
(
!
mReadChunk
)
;
JS
:
:
Rooted
<
Maybe
<
JS
:
:
Value
>
>
destClosed
(
aCx
Nothing
(
)
)
;
{
ErrorResult
rv
;
rv
.
ThrowTypeError
(
"
Cannot
pipe
to
closed
stream
"
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
)
;
bool
ok
=
ToJSValue
(
aCx
std
:
:
move
(
rv
)
&
error
)
;
MOZ_RELEASE_ASSERT
(
ok
"
must
be
ok
"
)
;
destClosed
=
Some
(
error
.
get
(
)
)
;
}
if
(
!
mPreventCancel
)
{
ShutdownWithAction
(
aCx
[
]
(
JSContext
*
aCx
PipeToPump
*
aPipeToPump
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
ErrorResult
&
aRv
)
MOZ_CAN_RUN_SCRIPT
{
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
*
aError
)
;
RefPtr
<
ReadableStream
>
dest
=
aPipeToPump
-
>
mReader
-
>
GetStream
(
)
;
return
ReadableStreamCancel
(
aCx
dest
error
aRv
)
;
}
destClosed
)
;
}
else
{
Shutdown
(
aCx
destClosed
)
;
}
}
void
PipeToPump
:
:
OnDestErrored
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aDestStoredError
)
{
JS
:
:
Rooted
<
Maybe
<
JS
:
:
Value
>
>
error
(
aCx
Some
(
aDestStoredError
)
)
;
if
(
!
mPreventCancel
)
{
ShutdownWithAction
(
aCx
[
]
(
JSContext
*
aCx
PipeToPump
*
aPipeToPump
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
ErrorResult
&
aRv
)
MOZ_CAN_RUN_SCRIPT
{
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
*
aError
)
;
RefPtr
<
ReadableStream
>
dest
=
aPipeToPump
-
>
mReader
-
>
GetStream
(
)
;
return
ReadableStreamCancel
(
aCx
dest
error
aRv
)
;
}
error
)
;
}
else
{
Shutdown
(
aCx
error
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
PipeToPump
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
PipeToPump
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
PipeToPump
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
PipeToPump
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
PipeToPump
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPromise
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mReader
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mWriter
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLastWritePromise
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
PipeToPump
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPromise
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mReader
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mWriter
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLastWritePromise
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
namespace
streams_abstract
{
already_AddRefed
<
Promise
>
ReadableStreamPipeTo
(
ReadableStream
*
aSource
WritableStream
*
aDest
bool
aPreventClose
bool
aPreventAbort
bool
aPreventCancel
AbortSignal
*
aSignal
mozilla
:
:
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
IsReadableStreamLocked
(
aSource
)
)
;
MOZ_ASSERT
(
!
IsWritableStreamLocked
(
aDest
)
)
;
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
aSource
-
>
GetParentObject
(
)
)
)
{
aRv
.
ThrowUnknownError
(
"
Internal
error
"
)
;
return
nullptr
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
RefPtr
<
ReadableStreamDefaultReader
>
reader
=
AcquireReadableStreamDefaultReader
(
aSource
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
WritableStreamDefaultWriter
>
writer
=
AcquireWritableStreamDefaultWriter
(
aDest
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
aSource
-
>
SetDisturbed
(
true
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
CreateInfallible
(
aSource
-
>
GetParentObject
(
)
)
;
RefPtr
<
PipeToPump
>
pump
=
new
PipeToPump
(
promise
reader
writer
aPreventClose
aPreventAbort
aPreventCancel
)
;
pump
-
>
Start
(
cx
aSignal
)
;
return
promise
.
forget
(
)
;
}
}
}
