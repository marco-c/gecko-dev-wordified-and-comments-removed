#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
ErrorReport
.
h
"
#
include
"
js
/
Exception
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
js
/
ValueArray
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
ByteStreamHelpers
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
ReadableByteStreamController
.
h
"
#
include
"
mozilla
/
dom
/
ReadableByteStreamControllerBinding
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamBYOBRequest
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamDefaultController
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsISupports
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
ReadableByteStreamController
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
ReadableByteStreamController
ReadableStreamController
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mByobRequest
mStream
)
tmp
-
>
ClearPendingPullIntos
(
)
;
tmp
-
>
ClearQueue
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
ReadableByteStreamController
ReadableStreamController
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mByobRequest
mStream
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
ReadableByteStreamController
ReadableStreamController
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
for
(
const
auto
&
queueEntry
:
tmp
-
>
mQueue
)
{
aCallbacks
.
Trace
(
&
queueEntry
-
>
mBuffer
"
mQueue
.
mBuffer
"
aClosure
)
;
}
for
(
const
auto
&
pullInto
:
tmp
-
>
mPendingPullIntos
)
{
aCallbacks
.
Trace
(
&
pullInto
-
>
mBuffer
"
mPendingPullIntos
.
mBuffer
"
aClosure
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_ADDREF_INHERITED
(
ReadableByteStreamController
ReadableStreamController
)
NS_IMPL_RELEASE_INHERITED
(
ReadableByteStreamController
ReadableStreamController
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadableByteStreamController
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_END_INHERITING
(
ReadableStreamController
)
ReadableByteStreamController
:
:
ReadableByteStreamController
(
nsIGlobalObject
*
aGlobal
)
:
ReadableStreamController
(
aGlobal
)
{
}
ReadableByteStreamController
:
:
~
ReadableByteStreamController
(
)
{
ClearPendingPullIntos
(
)
;
ClearQueue
(
)
;
}
void
ReadableByteStreamController
:
:
ClearQueue
(
)
{
for
(
auto
*
queueEntry
:
mQueue
)
{
queueEntry
-
>
ClearBuffer
(
)
;
}
mQueue
.
clear
(
)
;
}
void
ReadableByteStreamController
:
:
ClearPendingPullIntos
(
)
{
for
(
auto
*
pullInto
:
mPendingPullIntos
)
{
pullInto
-
>
ClearBuffer
(
)
;
}
mPendingPullIntos
.
clear
(
)
;
}
already_AddRefed
<
ReadableStreamBYOBRequest
>
ReadableByteStreamControllerGetBYOBRequest
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
)
{
if
(
!
aController
-
>
GetByobRequest
(
)
&
&
!
aController
-
>
PendingPullIntos
(
)
.
isEmpty
(
)
)
{
PullIntoDescriptor
*
firstDescriptor
=
aController
-
>
PendingPullIntos
(
)
.
getFirst
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
buffer
(
aCx
firstDescriptor
-
>
Buffer
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
view
(
aCx
JS_NewUint8ArrayWithBuffer
(
aCx
buffer
firstDescriptor
-
>
ByteOffset
(
)
+
firstDescriptor
-
>
BytesFilled
(
)
int64_t
(
firstDescriptor
-
>
ByteLength
(
)
-
firstDescriptor
-
>
BytesFilled
(
)
)
)
)
;
RefPtr
<
ReadableStreamBYOBRequest
>
byobRequest
=
new
ReadableStreamBYOBRequest
(
aController
-
>
GetParentObject
(
)
)
;
byobRequest
-
>
SetController
(
aController
)
;
byobRequest
-
>
SetView
(
view
)
;
aController
-
>
SetByobRequest
(
byobRequest
)
;
}
RefPtr
<
ReadableStreamBYOBRequest
>
request
(
aController
-
>
GetByobRequest
(
)
)
;
return
request
.
forget
(
)
;
}
already_AddRefed
<
ReadableStreamBYOBRequest
>
ReadableByteStreamController
:
:
GetByobRequest
(
JSContext
*
aCx
)
{
return
ReadableByteStreamControllerGetBYOBRequest
(
aCx
this
)
;
}
Nullable
<
double
>
ReadableByteStreamControllerGetDesiredSize
(
const
ReadableByteStreamController
*
aController
)
{
ReadableStream
:
:
ReaderState
state
=
aController
-
>
Stream
(
)
-
>
State
(
)
;
if
(
state
=
=
ReadableStream
:
:
ReaderState
:
:
Errored
)
{
return
nullptr
;
}
if
(
state
=
=
ReadableStream
:
:
ReaderState
:
:
Closed
)
{
return
0
.
0
;
}
return
aController
-
>
StrategyHWM
(
)
-
aController
-
>
QueueTotalSize
(
)
;
}
Nullable
<
double
>
ReadableByteStreamController
:
:
GetDesiredSize
(
)
const
{
return
ReadableByteStreamControllerGetDesiredSize
(
this
)
;
}
JSObject
*
ReadableByteStreamController
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ReadableByteStreamController_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
static
void
ReadableByteStreamControllerInvalidateBYOBRequest
(
ReadableByteStreamController
*
aController
)
{
if
(
!
aController
-
>
GetByobRequest
(
)
)
{
return
;
}
aController
-
>
GetByobRequest
(
)
-
>
SetController
(
nullptr
)
;
aController
-
>
GetByobRequest
(
)
-
>
SetView
(
nullptr
)
;
aController
-
>
SetByobRequest
(
nullptr
)
;
}
void
ReadableByteStreamControllerClearPendingPullIntos
(
ReadableByteStreamController
*
aController
)
{
ReadableByteStreamControllerInvalidateBYOBRequest
(
aController
)
;
aController
-
>
ClearPendingPullIntos
(
)
;
}
void
ResetQueue
(
ReadableByteStreamController
*
aContainer
)
{
aContainer
-
>
ClearQueue
(
)
;
aContainer
-
>
SetQueueTotalSize
(
0
)
;
}
void
ReadableByteStreamControllerClearAlgorithms
(
ReadableByteStreamController
*
aController
)
{
aController
-
>
SetPullAlgorithm
(
nullptr
)
;
aController
-
>
SetCancelAlgorithm
(
nullptr
)
;
}
void
ReadableByteStreamControllerError
(
ReadableByteStreamController
*
aController
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
ReadableStream
*
stream
=
aController
-
>
Stream
(
)
;
if
(
stream
-
>
State
(
)
!
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
return
;
}
ReadableByteStreamControllerClearPendingPullIntos
(
aController
)
;
ResetQueue
(
aController
)
;
ReadableByteStreamControllerClearAlgorithms
(
aController
)
;
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
aController
-
>
GetParentObject
(
)
)
)
{
return
;
}
ReadableStreamError
(
jsapi
.
cx
(
)
stream
aValue
aRv
)
;
}
void
ReadableByteStreamControllerClose
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
ErrorResult
&
aRv
)
{
ReadableStream
*
stream
=
aController
-
>
Stream
(
)
;
if
(
aController
-
>
CloseRequested
(
)
|
|
stream
-
>
State
(
)
!
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
return
;
}
if
(
aController
-
>
QueueTotalSize
(
)
>
0
)
{
aController
-
>
SetCloseRequested
(
true
)
;
return
;
}
if
(
!
aController
-
>
PendingPullIntos
(
)
.
isEmpty
(
)
)
{
PullIntoDescriptor
*
firstPendingPullInto
=
aController
-
>
PendingPullIntos
(
)
.
getFirst
(
)
;
if
(
firstPendingPullInto
-
>
BytesFilled
(
)
>
0
)
{
ErrorResult
rv
;
rv
.
ThrowTypeError
(
"
Leftover
Bytes
"
)
;
JS
:
:
RootedValue
exception
(
aCx
)
;
MOZ_ALWAYS_TRUE
(
ToJSValue
(
aCx
std
:
:
move
(
rv
)
&
exception
)
)
;
ReadableByteStreamControllerError
(
aController
exception
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aRv
.
ThrowJSException
(
aCx
exception
)
;
return
;
}
}
ReadableByteStreamControllerClearAlgorithms
(
aController
)
;
ReadableStreamClose
(
aCx
stream
aRv
)
;
}
void
ReadableByteStreamController
:
:
Close
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
if
(
mCloseRequested
)
{
aRv
.
ThrowTypeError
(
"
Close
already
requested
"
)
;
return
;
}
if
(
Stream
(
)
-
>
State
(
)
!
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
aRv
.
ThrowTypeError
(
"
Closing
un
-
readable
stream
controller
"
)
;
return
;
}
ReadableByteStreamControllerClose
(
aCx
this
aRv
)
;
}
void
ReadableByteStreamControllerEnqueueChunkToQueue
(
ReadableByteStreamController
*
aController
JS
:
:
Handle
<
JSObject
*
>
aTransferredBuffer
size_t
aByteOffset
size_t
aByteLength
)
{
RefPtr
<
ReadableByteStreamQueueEntry
>
queueEntry
=
new
ReadableByteStreamQueueEntry
(
aTransferredBuffer
aByteOffset
aByteLength
)
;
aController
-
>
Queue
(
)
.
insertBack
(
queueEntry
)
;
aController
-
>
AddToQueueTotalSize
(
double
(
aByteLength
)
)
;
}
bool
ReadableByteStreamControllerShouldCallPull
(
ReadableByteStreamController
*
aController
)
{
ReadableStream
*
stream
=
aController
-
>
Stream
(
)
;
if
(
stream
-
>
State
(
)
!
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
return
false
;
}
if
(
aController
-
>
CloseRequested
(
)
)
{
return
false
;
}
if
(
!
aController
-
>
Started
(
)
)
{
return
false
;
}
if
(
ReadableStreamHasDefaultReader
(
stream
)
&
&
ReadableStreamGetNumReadRequests
(
stream
)
>
0
)
{
return
true
;
}
#
if
0
if
(
ReadableStreamHasBYOBReader
(
stream
)
&
&
ReadableStreamGetNumR
)
#
endif
Nullable
<
double
>
desiredSize
=
ReadableByteStreamControllerGetDesiredSize
(
aController
)
;
MOZ_ASSERT
(
!
desiredSize
.
IsNull
(
)
)
;
if
(
desiredSize
.
Value
(
)
>
0
)
{
return
true
;
}
return
false
;
}
void
ReadableByteStreamControllerCallPullIfNeeded
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
ErrorResult
&
aRv
)
;
class
ByteStreamPullIfNeededPromiseHandler
final
:
public
PromiseNativeHandler
{
~
ByteStreamPullIfNeededPromiseHandler
(
)
=
default
;
RefPtr
<
ReadableByteStreamController
>
mController
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
ByteStreamPullIfNeededPromiseHandler
)
explicit
ByteStreamPullIfNeededPromiseHandler
(
ReadableByteStreamController
*
aController
)
:
PromiseNativeHandler
(
)
mController
(
aController
)
{
}
MOZ_CAN_RUN_SCRIPT
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
mController
-
>
SetPulling
(
false
)
;
if
(
mController
-
>
PullAgain
(
)
)
{
mController
-
>
SetPullAgain
(
false
)
;
ErrorResult
rv
;
ReadableByteStreamControllerCallPullIfNeeded
(
aCx
mController
rv
)
;
(
void
)
rv
.
MaybeSetPendingException
(
aCx
"
PullIfNeeded
Resolved
Error
"
)
;
}
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
ErrorResult
rv
;
ReadableByteStreamControllerError
(
mController
aValue
rv
)
;
(
void
)
rv
.
MaybeSetPendingException
(
aCx
"
PullIfNeeded
Rejected
Error
"
)
;
}
}
;
NS_IMPL_CYCLE_COLLECTION
(
ByteStreamPullIfNeededPromiseHandler
mController
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ByteStreamPullIfNeededPromiseHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ByteStreamPullIfNeededPromiseHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ByteStreamPullIfNeededPromiseHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamControllerCallPullIfNeeded
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
ErrorResult
&
aRv
)
{
bool
shouldPull
=
ReadableByteStreamControllerShouldCallPull
(
aController
)
;
if
(
!
shouldPull
)
{
return
;
}
if
(
aController
-
>
Pulling
(
)
)
{
aController
-
>
SetPullAgain
(
true
)
;
return
;
}
MOZ_ASSERT
(
!
aController
-
>
PullAgain
(
)
)
;
aController
-
>
SetPulling
(
true
)
;
RefPtr
<
ReadableStreamController
>
controller
(
aController
)
;
RefPtr
<
UnderlyingSourcePullCallbackHelper
>
pullAlgorithm
(
aController
-
>
GetPullAlgorithm
(
)
)
;
RefPtr
<
Promise
>
pullPromise
=
pullAlgorithm
?
pullAlgorithm
-
>
PullCallback
(
aCx
*
controller
aRv
)
:
Promise
:
:
CreateResolvedWithUndefined
(
controller
-
>
GetParentObject
(
)
aRv
)
;
RefPtr
<
ByteStreamPullIfNeededPromiseHandler
>
promiseHandler
=
new
ByteStreamPullIfNeededPromiseHandler
(
aController
)
;
pullPromise
-
>
AppendNativeHandler
(
promiseHandler
)
;
}
already_AddRefed
<
PullIntoDescriptor
>
ReadableByteStreamControllerShiftPendingPullInto
(
ReadableByteStreamController
*
aController
)
;
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamControllerEnqueue
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
JS
:
:
Handle
<
JSObject
*
>
aChunk
ErrorResult
&
aRv
)
{
ReadableStream
*
stream
=
aController
-
>
Stream
(
)
;
if
(
aController
-
>
CloseRequested
(
)
|
|
stream
-
>
State
(
)
!
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
return
;
}
bool
isShared
;
JS
:
:
Rooted
<
JSObject
*
>
buffer
(
aCx
JS_GetArrayBufferViewBuffer
(
aCx
aChunk
&
isShared
)
)
;
size_t
byteOffset
=
JS_GetArrayBufferViewByteOffset
(
aChunk
)
;
size_t
byteLength
=
JS_GetArrayBufferViewByteLength
(
aChunk
)
;
if
(
JS
:
:
IsDetachedArrayBufferObject
(
buffer
)
)
{
aRv
.
ThrowTypeError
(
"
Detatched
Array
Buffer
"
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
transferredBuffer
(
aCx
TransferArrayBuffer
(
aCx
buffer
)
)
;
if
(
!
transferredBuffer
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
if
(
!
aController
-
>
PendingPullIntos
(
)
.
isEmpty
(
)
)
{
PullIntoDescriptor
*
firstPendingPullInto
=
aController
-
>
PendingPullIntos
(
)
.
getFirst
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
pendingBuffer
(
aCx
firstPendingPullInto
-
>
Buffer
(
)
)
;
if
(
JS
:
:
IsDetachedArrayBufferObject
(
pendingBuffer
)
)
{
aRv
.
ThrowTypeError
(
"
Pending
PullInto
has
detatched
buffer
"
)
;
return
;
}
pendingBuffer
=
TransferArrayBuffer
(
aCx
pendingBuffer
)
;
if
(
!
pendingBuffer
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
firstPendingPullInto
-
>
SetBuffer
(
pendingBuffer
)
;
}
ReadableByteStreamControllerInvalidateBYOBRequest
(
aController
)
;
if
(
ReadableStreamHasDefaultReader
(
stream
)
)
{
if
(
ReadableStreamGetNumReadRequests
(
stream
)
=
=
0
)
{
MOZ_ASSERT
(
aController
-
>
PendingPullIntos
(
)
.
isEmpty
(
)
)
;
ReadableByteStreamControllerEnqueueChunkToQueue
(
aController
transferredBuffer
byteOffset
byteLength
)
;
}
else
{
MOZ_ASSERT
(
aController
-
>
Queue
(
)
.
isEmpty
(
)
)
;
if
(
!
aController
-
>
PendingPullIntos
(
)
.
isEmpty
(
)
)
{
MOZ_ASSERT
(
aController
-
>
PendingPullIntos
(
)
.
getFirst
(
)
-
>
GetReaderType
(
)
=
=
ReaderType
:
:
Default
)
;
ReadableByteStreamControllerShiftPendingPullInto
(
aController
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
transferredView
(
aCx
JS_NewUint8ArrayWithBuffer
(
aCx
transferredBuffer
byteOffset
int64_t
(
byteLength
)
)
)
;
if
(
!
transferredView
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
JS
:
:
RootedValue
transferredViewValue
(
aCx
JS
:
:
ObjectValue
(
*
transferredView
)
)
;
ReadableStreamFulfillReadRequest
(
aCx
stream
transferredViewValue
false
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
}
else
if
(
ReadableStreamHasBYOBReader
(
stream
)
)
{
MOZ_CRASH
(
"
MG
:
XXX
:
NYI
-
-
BYOBReaders
"
)
;
}
else
{
MOZ_ASSERT
(
IsReadableStreamLocked
(
stream
)
)
;
ReadableByteStreamControllerEnqueueChunkToQueue
(
aController
transferredBuffer
byteOffset
byteLength
)
;
}
ReadableByteStreamControllerCallPullIfNeeded
(
aCx
aController
aRv
)
;
}
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamController
:
:
Enqueue
(
JSContext
*
aCx
const
ArrayBufferView
&
aChunk
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JSObject
*
>
chunk
(
aCx
aChunk
.
Obj
(
)
)
;
if
(
JS_GetArrayBufferViewByteLength
(
chunk
)
=
=
0
)
{
aRv
.
ThrowTypeError
(
"
Zero
Length
View
"
)
;
return
;
}
bool
isShared
;
JS
:
:
Rooted
<
JSObject
*
>
viewedArrayBuffer
(
aCx
JS_GetArrayBufferViewBuffer
(
aCx
chunk
&
isShared
)
)
;
if
(
!
viewedArrayBuffer
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
if
(
JS
:
:
GetArrayBufferByteLength
(
viewedArrayBuffer
)
=
=
0
)
{
aRv
.
ThrowTypeError
(
"
Zero
Length
Buffer
"
)
;
return
;
}
if
(
CloseRequested
(
)
)
{
aRv
.
ThrowTypeError
(
"
close
requested
"
)
;
return
;
}
if
(
Stream
(
)
-
>
State
(
)
!
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
aRv
.
ThrowTypeError
(
"
Not
Readable
"
)
;
return
;
}
ReadableByteStreamControllerEnqueue
(
aCx
this
chunk
aRv
)
;
}
void
ReadableByteStreamController
:
:
Error
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aErrorValue
ErrorResult
&
aRv
)
{
ReadableByteStreamControllerError
(
this
aErrorValue
aRv
)
;
}
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
ReadableByteStreamController
:
:
CancelSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
{
ReadableByteStreamControllerClearPendingPullIntos
(
this
)
;
ResetQueue
(
this
)
;
Optional
<
JS
:
:
Handle
<
JS
:
:
Value
>
>
reason
(
aCx
aReason
)
;
RefPtr
<
UnderlyingSourceCancelCallbackHelper
>
cancelAlgorithm
(
GetCancelAlgorithm
(
)
)
;
RefPtr
<
Promise
>
result
=
cancelAlgorithm
?
cancelAlgorithm
-
>
CancelCallback
(
aCx
reason
aRv
)
:
Promise
:
:
CreateResolvedWithUndefined
(
GetParentObject
(
)
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
ReadableByteStreamControllerClearAlgorithms
(
this
)
;
return
result
.
forget
(
)
;
}
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamControllerHandleQueueDrain
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aController
-
>
Stream
(
)
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
;
if
(
aController
-
>
QueueTotalSize
(
)
=
=
0
&
&
aController
-
>
CloseRequested
(
)
)
{
ReadableByteStreamControllerClearAlgorithms
(
aController
)
;
ReadableStreamClose
(
aCx
aController
-
>
Stream
(
)
aRv
)
;
return
;
}
ReadableByteStreamControllerCallPullIfNeeded
(
aCx
aController
aRv
)
;
}
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamController
:
:
PullSteps
(
JSContext
*
aCx
ReadRequest
*
aReadRequest
ErrorResult
&
aRv
)
{
ReadableStream
*
stream
=
Stream
(
)
;
MOZ_ASSERT
(
ReadableStreamHasDefaultReader
(
stream
)
)
;
if
(
QueueTotalSize
(
)
>
0
)
{
MOZ_ASSERT
(
ReadableStreamGetNumReadRequests
(
stream
)
=
=
0
)
;
RefPtr
<
ReadableByteStreamQueueEntry
>
entry
=
Queue
(
)
.
popFirst
(
)
;
SetQueueTotalSize
(
QueueTotalSize
(
)
-
double
(
entry
-
>
ByteLength
(
)
)
)
;
ReadableByteStreamControllerHandleQueueDrain
(
aCx
this
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
buffer
(
aCx
entry
-
>
Buffer
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
view
(
aCx
JS_NewUint8ArrayWithBuffer
(
aCx
buffer
entry
-
>
ByteOffset
(
)
int64_t
(
entry
-
>
ByteLength
(
)
)
)
)
;
JS
:
:
RootedValue
viewValue
(
aCx
JS
:
:
ObjectValue
(
*
view
)
)
;
aReadRequest
-
>
ChunkSteps
(
aCx
viewValue
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
return
;
}
Maybe
<
uint64_t
>
autoAllocateChunkSize
=
AutoAllocateChunkSize
(
)
;
if
(
autoAllocateChunkSize
)
{
JS
:
:
Rooted
<
JSObject
*
>
buffer
(
aCx
JS
:
:
NewArrayBuffer
(
aCx
*
autoAllocateChunkSize
)
)
;
if
(
!
buffer
)
{
JS
:
:
RootedValue
bufferError
(
aCx
)
;
if
(
!
JS_GetPendingException
(
aCx
&
bufferError
)
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
JS_ClearPendingException
(
aCx
)
;
aReadRequest
-
>
ErrorSteps
(
aCx
bufferError
aRv
)
;
return
;
}
RefPtr
<
PullIntoDescriptor
>
pullIntoDescriptor
=
new
PullIntoDescriptor
(
buffer
*
autoAllocateChunkSize
0
*
autoAllocateChunkSize
0
1
PullIntoDescriptor
:
:
Constructor
:
:
Uint8
ReaderType
:
:
Default
)
;
PendingPullIntos
(
)
.
insertBack
(
pullIntoDescriptor
)
;
}
ReadableStreamAddReadRequest
(
stream
aReadRequest
)
;
ReadableByteStreamControllerCallPullIfNeeded
(
aCx
this
aRv
)
;
}
already_AddRefed
<
PullIntoDescriptor
>
ReadableByteStreamControllerShiftPendingPullInto
(
ReadableByteStreamController
*
aController
)
{
MOZ_ASSERT
(
!
aController
-
>
GetByobRequest
(
)
)
;
RefPtr
<
PullIntoDescriptor
>
descriptor
=
aController
-
>
PendingPullIntos
(
)
.
popFirst
(
)
;
return
descriptor
.
forget
(
)
;
}
JSObject
*
ReadableByteStreamControllerConvertPullIntoDescriptor
(
JSContext
*
aCx
RefPtr
<
PullIntoDescriptor
>
&
pullIntoDescriptor
ErrorResult
&
aRv
)
{
uint64_t
bytesFilled
=
pullIntoDescriptor
-
>
BytesFilled
(
)
;
uint64_t
elementSize
=
pullIntoDescriptor
-
>
ElementSize
(
)
;
MOZ_ASSERT
(
bytesFilled
<
=
pullIntoDescriptor
-
>
ByteLength
(
)
)
;
MOZ_ASSERT
(
bytesFilled
%
elementSize
=
=
0
)
;
JS
:
:
Rooted
<
JSObject
*
>
srcBuffer
(
aCx
pullIntoDescriptor
-
>
Buffer
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
buffer
(
aCx
TransferArrayBuffer
(
aCx
srcBuffer
)
)
;
if
(
!
buffer
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
nullptr
;
}
JS
:
:
Rooted
<
JSObject
*
>
res
(
aCx
)
;
switch
(
pullIntoDescriptor
-
>
ViewConstructor
(
)
)
{
case
PullIntoDescriptor
:
:
Constructor
:
:
DataView
:
res
=
JS_NewDataView
(
aCx
buffer
pullIntoDescriptor
-
>
ByteOffset
(
)
bytesFilled
%
elementSize
)
;
break
;
#
define
CONSTRUCT_TYPED_ARRAY_TYPE
(
ExternalT
NativeT
Name
)
\
case
PullIntoDescriptor
:
:
Constructor
:
:
Name
:
\
res
=
JS_New
#
#
Name
#
#
ArrayWithBuffer
(
aCx
buffer
\
pullIntoDescriptor
-
>
ByteOffset
(
)
\
int64_t
(
bytesFilled
%
elementSize
)
)
;
\
break
;
JS_FOR_EACH_TYPED_ARRAY
(
CONSTRUCT_TYPED_ARRAY_TYPE
)
#
undef
CONSTRUCT_TYPED_ARRAY_TYPE
}
if
(
!
res
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
nullptr
;
}
return
res
;
}
#
if
0
void
ReadableStreamFulfillReadIntoRequest
(
JSContext
*
aCx
RefPtr
<
ReadableStream
>
&
aStream
<
JS
:
:
JS
:
:
>
HandleValue
aChunk
bool
done
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
ReadableStreamHasBYOBReader
(
aStream
)
)
;
RefPtr
<
ReadableStreamBYOBReader
>
reader
=
aStream
-
>
mReader
.
as
<
RefPtr
<
ReadableStreamBYOBReader
>
>
(
)
;
MOZ_ASSERT
(
!
reader
-
>
mReadIntoRequests
.
isEmpty
(
)
)
;
RefPtr
<
ReadIntoRequest
>
readIntoRequest
=
reader
-
>
mReadIntoRequests
.
popFirst
(
)
;
if
(
done
)
{
readIntoRequest
-
>
closeSteps
(
aCx
aChunk
aRv
)
;
return
;
}
readIntoRequest
-
>
chunkSteps
(
aCx
aChunk
aRv
)
;
}
void
ReadableByteStreamControllerCommitPullIntoDescriptor
(
JSContext
*
aCx
RefPtr
<
ReadableStream
>
&
aStream
RefPtr
<
PullIntoDescriptor
>
&
pullIntoDescriptor
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aStream
-
>
state
(
)
!
=
ReadableStream
:
:
ReaderState
:
:
Errored
)
;
bool
done
=
false
;
if
(
aStream
-
>
state
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Closed
)
{
MOZ_ASSERT
(
pullIntoDescriptor
-
>
bytesFilled
(
)
=
=
0
)
;
done
=
true
;
}
JS
:
:
Rooted
<
JSObject
*
>
filledView
(
aCx
ReadableByteStreamControllerConvertPullIntoDescriptor
(
aCx
pullIntoDescriptor
aRv
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
JS
:
:
RootedValue
filledViewValue
(
aCx
JS
:
:
ObjectValue
(
*
filledView
)
)
;
if
(
pullIntoDescriptor
-
>
readerType
(
)
=
=
ReaderType
:
:
Default
)
{
ReadableStreamFulfillReadRequest
(
aCx
aStream
filledViewValue
done
aRv
)
;
return
;
}
MOZ_ASSERT
(
pullIntoDescriptor
-
>
readerType
(
)
=
=
ReaderType
:
:
BYOB
)
;
ReadableStreamFulfillReadIntoRequest
(
aCx
aStream
filledViewValue
done
aRv
)
;
}
#
endif
static
void
ReadableByteStreamControllerRespondInClosedState
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
RefPtr
<
PullIntoDescriptor
>
&
aFirstDescriptor
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aFirstDescriptor
-
>
BytesFilled
(
)
=
=
0
)
;
ReadableStream
*
stream
=
aController
-
>
Stream
(
)
;
if
(
ReadableStreamHasBYOBReader
(
stream
)
)
{
MOZ_CRASH
(
"
MG
:
XXX
:
NYI
-
-
BYOBReader
"
)
;
#
if
0
while
(
ReadableStreamGetNumReadIntoRequests
(
stream
)
>
0
)
{
RefPtr
<
PullIntoDescriptor
>
pullIntoDescriptor
=
ReadableByteStreamControllerShiftPendingPullInto
(
aController
)
;
ReadableByteStreamControllerCommitPullIntoDescriptor
(
aCx
stream
pullIntoDescriptor
aRv
)
;
MOZ_CRASH
(
"
MG
:
XXX
:
VERITY
NOT
MORE
STEPS
?
"
)
;
}
#
endif
}
}
static
void
ReadableByteStreamControllerRespondInReadableState
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
uint64_t
aBytesWritten
PullIntoDescriptor
*
aPullIntoDescriptor
ErrorResult
&
aRv
)
{
}
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamControllerRespondInternal
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
uint64_t
aBytesWritten
ErrorResult
&
aRv
)
{
RefPtr
<
PullIntoDescriptor
>
firstDescriptor
=
aController
-
>
PendingPullIntos
(
)
.
getFirst
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
buffer
(
aCx
firstDescriptor
-
>
Buffer
(
)
)
;
#
ifdef
DEBUG
bool
canTransferBuffer
=
CanTransferArrayBuffer
(
aCx
buffer
aRv
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
MOZ_ASSERT
(
canTransferBuffer
)
;
#
endif
ReadableByteStreamControllerInvalidateBYOBRequest
(
aController
)
;
auto
state
=
aController
-
>
Stream
(
)
-
>
State
(
)
;
if
(
state
=
=
ReadableStream
:
:
ReaderState
:
:
Closed
)
{
MOZ_ASSERT
(
aBytesWritten
=
=
0
)
;
ReadableByteStreamControllerRespondInClosedState
(
aCx
aController
firstDescriptor
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
else
{
MOZ_ASSERT
(
state
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
;
MOZ_ASSERT
(
aBytesWritten
>
0
)
;
ReadableByteStreamControllerRespondInReadableState
(
aCx
aController
aBytesWritten
firstDescriptor
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
ReadableByteStreamControllerCallPullIfNeeded
(
aCx
aController
aRv
)
;
}
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamControllerRespond
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
uint64_t
aBytesWritten
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aController
-
>
PendingPullIntos
(
)
.
isEmpty
(
)
)
;
PullIntoDescriptor
*
firstDescriptor
=
aController
-
>
PendingPullIntos
(
)
.
getFirst
(
)
;
auto
state
=
aController
-
>
Stream
(
)
-
>
State
(
)
;
if
(
state
=
=
ReadableStream
:
:
ReaderState
:
:
Closed
)
{
if
(
aBytesWritten
!
=
0
)
{
aRv
.
ThrowTypeError
(
"
bytesWritten
not
zero
on
closed
stream
"
)
;
return
;
}
}
else
{
MOZ_ASSERT
(
state
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
;
if
(
aBytesWritten
=
=
0
)
{
aRv
.
ThrowTypeError
(
"
bytesWritten
0
"
)
;
return
;
}
if
(
firstDescriptor
-
>
BytesFilled
(
)
+
aBytesWritten
>
firstDescriptor
-
>
ByteLength
(
)
)
{
aRv
.
ThrowRangeError
(
"
bytesFilled
+
bytesWritten
>
byteLength
"
)
;
return
;
}
}
JS
:
:
Rooted
<
JSObject
*
>
buffer
(
aCx
firstDescriptor
-
>
Buffer
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
transferredBuffer
(
aCx
TransferArrayBuffer
(
aCx
buffer
)
)
;
if
(
!
transferredBuffer
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
firstDescriptor
-
>
SetBuffer
(
transferredBuffer
)
;
ReadableByteStreamControllerRespondInternal
(
aCx
aController
aBytesWritten
aRv
)
;
}
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamControllerRespondWithNewView
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
JS
:
:
Handle
<
JSObject
*
>
aView
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aController
-
>
PendingPullIntos
(
)
.
isEmpty
(
)
)
;
bool
isSharedMemory
;
JS
:
:
Rooted
<
JSObject
*
>
viewedArrayBuffer
(
aCx
JS_GetArrayBufferViewBuffer
(
aCx
aView
&
isSharedMemory
)
)
;
if
(
!
viewedArrayBuffer
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
MOZ_ASSERT
(
!
JS
:
:
IsDetachedArrayBufferObject
(
viewedArrayBuffer
)
)
;
RefPtr
<
PullIntoDescriptor
>
firstDescriptor
=
aController
-
>
PendingPullIntos
(
)
.
getFirst
(
)
;
ReadableStream
:
:
ReaderState
state
=
aController
-
>
Stream
(
)
-
>
State
(
)
;
if
(
state
=
=
ReadableStream
:
:
ReaderState
:
:
Closed
)
{
if
(
JS_GetArrayBufferViewByteLength
(
aView
)
!
=
0
)
{
aRv
.
ThrowTypeError
(
"
View
has
non
-
zero
length
in
closed
stream
"
)
;
return
;
}
}
else
{
MOZ_ASSERT
(
state
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
;
if
(
JS_GetArrayBufferViewByteLength
(
aView
)
=
=
0
)
{
aRv
.
ThrowTypeError
(
"
View
has
zero
length
in
readable
stream
"
)
;
return
;
}
}
if
(
firstDescriptor
-
>
ByteOffset
(
)
+
firstDescriptor
-
>
BytesFilled
(
)
!
=
JS_GetArrayBufferViewByteOffset
(
aView
)
)
{
aRv
.
ThrowRangeError
(
"
Invalid
Offset
"
)
;
return
;
}
if
(
firstDescriptor
-
>
BufferByteLength
(
)
!
=
JS
:
:
GetArrayBufferByteLength
(
viewedArrayBuffer
)
)
{
aRv
.
ThrowRangeError
(
"
Mismatched
buffer
byte
lengths
"
)
;
return
;
}
if
(
firstDescriptor
-
>
BytesFilled
(
)
+
JS_GetArrayBufferViewByteLength
(
aView
)
>
firstDescriptor
-
>
ByteLength
(
)
)
{
aRv
.
ThrowRangeError
(
"
Too
many
bytes
"
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
transferedBuffer
(
aCx
TransferArrayBuffer
(
aCx
aView
)
)
;
if
(
!
transferedBuffer
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
firstDescriptor
-
>
SetBuffer
(
transferedBuffer
)
;
ReadableByteStreamControllerRespondInternal
(
aCx
aController
JS_GetArrayBufferViewByteLength
(
aView
)
aRv
)
;
}
}
}
