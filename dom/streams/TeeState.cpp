#
include
"
TeeState
.
h
"
#
include
"
ReadableStreamTee
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
mozilla
/
HoldDropJSObjects
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
namespace
mozilla
:
:
dom
{
using
namespace
streams_abstract
;
NS_IMPL_CYCLE_COLLECTION_WITH_JS_MEMBERS
(
TeeState
(
mStream
mReader
mBranch1
mBranch2
mCancelPromise
)
(
mReason1
mReason2
)
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TeeState
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
TeeState
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
TeeState
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
TeeState
:
:
TeeState
(
ReadableStream
*
aStream
bool
aCloneForBranch2
)
:
mStream
(
aStream
)
mReason1
(
JS
:
:
NullValue
(
)
)
mReason2
(
JS
:
:
NullValue
(
)
)
mCloneForBranch2
(
aCloneForBranch2
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
MOZ_RELEASE_ASSERT
(
!
aCloneForBranch2
"
cloneForBranch2
path
is
not
implemented
.
"
)
;
}
already_AddRefed
<
TeeState
>
TeeState
:
:
Create
(
ReadableStream
*
aStream
bool
aCloneForBranch2
ErrorResult
&
aRv
)
{
RefPtr
<
TeeState
>
teeState
=
new
TeeState
(
aStream
aCloneForBranch2
)
;
RefPtr
<
ReadableStreamDefaultReader
>
reader
=
AcquireReadableStreamDefaultReader
(
teeState
-
>
GetStream
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
teeState
-
>
SetReader
(
reader
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
CreateInfallible
(
teeState
-
>
GetStream
(
)
-
>
GetParentObject
(
)
)
;
teeState
-
>
SetCancelPromise
(
promise
)
;
return
teeState
.
forget
(
)
;
}
void
TeeState
:
:
PullCallback
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
)
{
if
(
Reading
(
)
)
{
SetReadAgain
(
true
)
;
return
;
}
SetReading
(
true
)
;
RefPtr
<
ReadRequest
>
readRequest
=
new
ReadableStreamDefaultTeeReadRequest
(
this
)
;
RefPtr
<
ReadableStreamGenericReader
>
reader
=
GetReader
(
)
;
ReadableStreamDefaultReaderRead
(
aCx
reader
readRequest
aRv
)
;
}
}
