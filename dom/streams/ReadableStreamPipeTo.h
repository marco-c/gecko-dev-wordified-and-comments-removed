#
ifndef
mozilla_dom_ReadableStreamPipeTo_h
#
define
mozilla_dom_ReadableStreamPipeTo_h
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
AbortFollower
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mozilla
:
:
dom
{
struct
PipeToReadRequest
;
class
WriteFinishedPromiseHandler
;
class
ShutdownActionFinishedPromiseHandler
;
class
ReadableStream
;
class
ReadableStreamDefaultReader
;
class
WritableStream
;
class
WritableStreamDefaultWriter
;
class
PipeToPump
final
:
public
AbortFollower
{
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
PipeToPump
)
friend
struct
PipeToReadRequest
;
friend
class
WriteFinishedPromiseHandler
;
friend
class
ShutdownActionFinishedPromiseHandler
;
PipeToPump
(
Promise
*
aPromise
ReadableStreamDefaultReader
*
aReader
WritableStreamDefaultWriter
*
aWriter
bool
aPreventClose
bool
aPreventAbort
bool
aPreventCancel
)
:
mPromise
(
aPromise
)
mReader
(
aReader
)
mWriter
(
aWriter
)
mPreventClose
(
aPreventClose
)
mPreventAbort
(
aPreventAbort
)
mPreventCancel
(
aPreventCancel
)
{
}
MOZ_CAN_RUN_SCRIPT
void
Start
(
JSContext
*
aCx
AbortSignal
*
aSignal
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
RunAbortAlgorithm
(
)
override
;
private
:
~
PipeToPump
(
)
override
=
default
;
MOZ_CAN_RUN_SCRIPT
void
PerformAbortAlgorithm
(
JSContext
*
aCx
AbortSignalImpl
*
aSignal
)
;
MOZ_CAN_RUN_SCRIPT
bool
SourceOrDestErroredOrClosed
(
JSContext
*
aCx
)
;
using
ShutdownAction
=
already_AddRefed
<
Promise
>
(
*
)
(
JSContext
*
PipeToPump
*
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
ErrorResult
&
)
;
MOZ_CAN_RUN_SCRIPT
void
ShutdownWithAction
(
JSContext
*
aCx
ShutdownAction
aAction
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
)
;
MOZ_CAN_RUN_SCRIPT
void
ShutdownWithActionAfterFinishedWrite
(
JSContext
*
aCx
ShutdownAction
aAction
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
)
;
MOZ_CAN_RUN_SCRIPT
void
Shutdown
(
JSContext
*
aCx
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
)
;
void
Finalize
(
JSContext
*
aCx
JS
:
:
Handle
<
mozilla
:
:
Maybe
<
JS
:
:
Value
>
>
aError
)
;
MOZ_CAN_RUN_SCRIPT
void
OnReadFulfilled
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
OnWriterReady
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
)
;
MOZ_CAN_RUN_SCRIPT
void
Read
(
JSContext
*
aCx
)
;
MOZ_CAN_RUN_SCRIPT
void
OnSourceClosed
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
)
;
MOZ_CAN_RUN_SCRIPT
void
OnSourceErrored
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
)
;
MOZ_CAN_RUN_SCRIPT
void
OnDestClosed
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
)
;
MOZ_CAN_RUN_SCRIPT
void
OnDestErrored
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
)
;
RefPtr
<
Promise
>
mPromise
;
RefPtr
<
ReadableStreamDefaultReader
>
mReader
;
RefPtr
<
WritableStreamDefaultWriter
>
mWriter
;
RefPtr
<
Promise
>
mLastWritePromise
;
const
bool
mPreventClose
;
const
bool
mPreventAbort
;
const
bool
mPreventCancel
;
bool
mShuttingDown
=
false
;
#
ifdef
DEBUG
bool
mReadChunk
=
false
;
#
endif
}
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
ReadableStreamPipeTo
(
ReadableStream
*
aSource
WritableStream
*
aDest
bool
aPreventClose
bool
aPreventAbort
bool
aPreventCancel
AbortSignal
*
aSignal
ErrorResult
&
aRv
)
;
}
#
endif
