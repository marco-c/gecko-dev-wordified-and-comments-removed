#
include
"
mozilla
/
dom
/
WritableStream
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
HoldDropJSObjects
.
h
"
#
include
"
mozilla
/
dom
/
AbortSignal
.
h
"
#
include
"
mozilla
/
dom
/
BindingCallContext
.
h
"
#
include
"
mozilla
/
dom
/
QueueWithSizes
.
h
"
#
include
"
mozilla
/
dom
/
QueuingStrategyBinding
.
h
"
#
include
"
mozilla
/
dom
/
ReadRequest
.
h
"
#
include
"
mozilla
/
dom
/
RootedDictionary
.
h
"
#
include
"
mozilla
/
dom
/
StreamUtils
.
h
"
#
include
"
mozilla
/
dom
/
UnderlyingSinkBinding
.
h
"
#
include
"
mozilla
/
dom
/
WritableStreamBinding
.
h
"
#
include
"
mozilla
/
dom
/
WritableStreamDefaultController
.
h
"
#
include
"
mozilla
/
dom
/
WritableStreamDefaultWriter
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
dom
/
Promise
-
inl
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsISupports
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_WITH_JS_MEMBERS
(
WritableStream
(
mGlobal
mCloseRequest
mController
mInFlightWriteRequest
mInFlightCloseRequest
mPendingAbortRequestPromise
mWriter
mWriteRequests
)
(
mPendingAbortRequestReason
mStoredError
)
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
WritableStream
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
WritableStream
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
WritableStream
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
WritableStream
:
:
WritableStream
(
nsIGlobalObject
*
aGlobal
)
:
mGlobal
(
aGlobal
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
}
WritableStream
:
:
WritableStream
(
const
GlobalObject
&
aGlobal
)
:
mGlobal
(
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
}
WritableStream
:
:
~
WritableStream
(
)
{
mozilla
:
:
DropJSObjects
(
this
)
;
}
JSObject
*
WritableStream
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
WritableStream_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
WritableStream
:
:
DealWithRejection
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
{
if
(
mState
=
=
WriterState
:
:
Writable
)
{
StartErroring
(
aCx
aError
aRv
)
;
return
;
}
MOZ_ASSERT
(
mState
=
=
WriterState
:
:
Erroring
)
;
FinishErroring
(
aCx
aRv
)
;
}
void
WritableStream
:
:
FinishErroring
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mState
=
=
WriterState
:
:
Erroring
)
;
MOZ_ASSERT
(
!
HasOperationMarkedInFlight
(
)
)
;
mState
=
WriterState
:
:
Errored
;
Controller
(
)
-
>
ErrorSteps
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
storedError
(
aCx
mStoredError
)
;
for
(
const
RefPtr
<
Promise
>
&
writeRequest
:
mWriteRequests
)
{
writeRequest
-
>
MaybeReject
(
storedError
)
;
}
mWriteRequests
.
Clear
(
)
;
if
(
!
mPendingAbortRequestPromise
)
{
RejectCloseAndClosedPromiseIfNeeded
(
)
;
return
;
}
RefPtr
<
Promise
>
abortPromise
=
mPendingAbortRequestPromise
;
JS
:
:
Rooted
<
JS
:
:
Value
>
abortReason
(
aCx
mPendingAbortRequestReason
)
;
bool
abortWasAlreadyErroring
=
mPendingAbortRequestWasAlreadyErroring
;
SetPendingAbortRequest
(
nullptr
JS
:
:
UndefinedHandleValue
false
)
;
if
(
abortWasAlreadyErroring
)
{
abortPromise
-
>
MaybeReject
(
storedError
)
;
RejectCloseAndClosedPromiseIfNeeded
(
)
;
return
;
}
RefPtr
<
WritableStreamDefaultController
>
controller
=
mController
;
RefPtr
<
Promise
>
promise
=
controller
-
>
AbortSteps
(
aCx
abortReason
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
promise
-
>
AddCallbacksWithCycleCollectedArgs
(
[
]
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
Promise
*
aAbortRequestPromise
WritableStream
*
aStream
)
{
aAbortRequestPromise
-
>
MaybeResolveWithUndefined
(
)
;
aStream
-
>
RejectCloseAndClosedPromiseIfNeeded
(
)
;
}
[
]
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
Promise
*
aAbortRequestPromise
WritableStream
*
aStream
)
{
aAbortRequestPromise
-
>
MaybeReject
(
aValue
)
;
aStream
-
>
RejectCloseAndClosedPromiseIfNeeded
(
)
;
}
RefPtr
(
abortPromise
)
RefPtr
(
this
)
)
;
}
void
WritableStream
:
:
FinishInFlightClose
(
)
{
MOZ_ASSERT
(
mInFlightCloseRequest
)
;
mInFlightCloseRequest
-
>
MaybeResolveWithUndefined
(
)
;
mInFlightCloseRequest
=
nullptr
;
MOZ_ASSERT
(
mState
=
=
WriterState
:
:
Writable
|
|
mState
=
=
WriterState
:
:
Erroring
)
;
if
(
mState
=
=
WriterState
:
:
Erroring
)
{
mStoredError
.
setUndefined
(
)
;
if
(
mPendingAbortRequestPromise
)
{
mPendingAbortRequestPromise
-
>
MaybeResolveWithUndefined
(
)
;
SetPendingAbortRequest
(
nullptr
JS
:
:
UndefinedHandleValue
false
)
;
}
}
mState
=
WriterState
:
:
Closed
;
if
(
mWriter
)
{
mWriter
-
>
ClosedPromise
(
)
-
>
MaybeResolveWithUndefined
(
)
;
}
MOZ_ASSERT
(
!
mPendingAbortRequestPromise
)
;
MOZ_ASSERT
(
mStoredError
.
isUndefined
(
)
)
;
}
void
WritableStream
:
:
FinishInFlightCloseWithError
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mInFlightCloseRequest
)
;
mInFlightCloseRequest
-
>
MaybeReject
(
aError
)
;
mInFlightCloseRequest
=
nullptr
;
MOZ_ASSERT
(
mState
=
=
WriterState
:
:
Writable
|
|
mState
=
=
WriterState
:
:
Erroring
)
;
if
(
mPendingAbortRequestPromise
)
{
mPendingAbortRequestPromise
-
>
MaybeReject
(
aError
)
;
SetPendingAbortRequest
(
nullptr
JS
:
:
UndefinedHandleValue
false
)
;
}
DealWithRejection
(
aCx
aError
aRv
)
;
}
void
WritableStream
:
:
FinishInFlightWrite
(
)
{
MOZ_ASSERT
(
mInFlightWriteRequest
)
;
mInFlightWriteRequest
-
>
MaybeResolveWithUndefined
(
)
;
mInFlightWriteRequest
=
nullptr
;
}
void
WritableStream
:
:
FinishInFlightWriteWithError
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mInFlightWriteRequest
)
;
mInFlightWriteRequest
-
>
MaybeReject
(
aError
)
;
mInFlightWriteRequest
=
nullptr
;
MOZ_ASSERT
(
mState
=
=
WriterState
:
:
Writable
|
|
mState
=
=
WriterState
:
:
Erroring
)
;
DealWithRejection
(
aCx
aError
aRv
)
;
}
void
WritableStream
:
:
MarkCloseRequestInFlight
(
)
{
MOZ_ASSERT
(
!
mInFlightCloseRequest
)
;
MOZ_ASSERT
(
mCloseRequest
)
;
mInFlightCloseRequest
=
mCloseRequest
;
mCloseRequest
=
nullptr
;
}
void
WritableStream
:
:
MarkFirstWriteRequestInFlight
(
)
{
MOZ_ASSERT
(
!
mInFlightWriteRequest
)
;
MOZ_ASSERT
(
!
mWriteRequests
.
IsEmpty
(
)
)
;
RefPtr
<
Promise
>
writeRequest
=
mWriteRequests
.
ElementAt
(
0
)
;
mWriteRequests
.
RemoveElementAt
(
0
)
;
mInFlightWriteRequest
=
writeRequest
;
}
void
WritableStream
:
:
RejectCloseAndClosedPromiseIfNeeded
(
)
{
MOZ_ASSERT
(
mState
=
=
WriterState
:
:
Errored
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
storedError
(
RootingCx
(
)
mStoredError
)
;
if
(
mCloseRequest
)
{
MOZ_ASSERT
(
!
mInFlightCloseRequest
)
;
mCloseRequest
-
>
MaybeReject
(
storedError
)
;
mCloseRequest
=
nullptr
;
}
RefPtr
<
WritableStreamDefaultWriter
>
writer
=
mWriter
;
if
(
writer
)
{
RefPtr
<
Promise
>
closedPromise
=
writer
-
>
ClosedPromise
(
)
;
closedPromise
-
>
MaybeReject
(
storedError
)
;
closedPromise
-
>
SetSettledPromiseIsHandled
(
)
;
}
}
void
WritableStream
:
:
StartErroring
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mStoredError
.
isUndefined
(
)
)
;
MOZ_ASSERT
(
mState
=
=
WriterState
:
:
Writable
)
;
RefPtr
<
WritableStreamDefaultController
>
controller
=
mController
;
MOZ_ASSERT
(
controller
)
;
mState
=
WriterState
:
:
Erroring
;
mStoredError
=
aReason
;
RefPtr
<
WritableStreamDefaultWriter
>
writer
=
mWriter
;
if
(
writer
)
{
WritableStreamDefaultWriterEnsureReadyPromiseRejected
(
writer
aReason
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
if
(
!
HasOperationMarkedInFlight
(
)
&
&
controller
-
>
Started
(
)
)
{
FinishErroring
(
aCx
aRv
)
;
}
}
void
WritableStream
:
:
UpdateBackpressure
(
bool
aBackpressure
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mState
=
=
WriterState
:
:
Writable
)
;
MOZ_ASSERT
(
!
CloseQueuedOrInFlight
(
)
)
;
RefPtr
<
WritableStreamDefaultWriter
>
writer
=
mWriter
;
if
(
writer
&
&
aBackpressure
!
=
mBackpressure
)
{
if
(
aBackpressure
)
{
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
writer
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
writer
-
>
SetReadyPromise
(
promise
)
;
}
else
{
writer
-
>
ReadyPromise
(
)
-
>
MaybeResolveWithUndefined
(
)
;
}
}
mBackpressure
=
aBackpressure
;
}
already_AddRefed
<
WritableStream
>
WritableStream
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
Optional
<
JS
:
:
Handle
<
JSObject
*
>
>
&
aUnderlyingSink
const
QueuingStrategy
&
aStrategy
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JSObject
*
>
underlyingSinkObj
(
aGlobal
.
Context
(
)
aUnderlyingSink
.
WasPassed
(
)
?
aUnderlyingSink
.
Value
(
)
:
nullptr
)
;
RootedDictionary
<
UnderlyingSink
>
underlyingSinkDict
(
aGlobal
.
Context
(
)
)
;
if
(
underlyingSinkObj
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
objValue
(
aGlobal
.
Context
(
)
JS
:
:
ObjectValue
(
*
underlyingSinkObj
)
)
;
dom
:
:
BindingCallContext
callCx
(
aGlobal
.
Context
(
)
"
WritableStream
.
constructor
"
)
;
aRv
.
MightThrowJSException
(
)
;
if
(
!
underlyingSinkDict
.
Init
(
callCx
objValue
)
)
{
aRv
.
StealExceptionFromJSContext
(
aGlobal
.
Context
(
)
)
;
return
nullptr
;
}
}
if
(
!
underlyingSinkDict
.
mType
.
isUndefined
(
)
)
{
aRv
.
ThrowRangeError
(
"
Implementation
preserved
member
'
type
'
"
)
;
return
nullptr
;
}
RefPtr
<
WritableStream
>
writableStream
=
new
WritableStream
(
aGlobal
)
;
RefPtr
<
QueuingStrategySize
>
sizeAlgorithm
=
aStrategy
.
mSize
.
WasPassed
(
)
?
&
aStrategy
.
mSize
.
Value
(
)
:
nullptr
;
double
highWaterMark
=
ExtractHighWaterMark
(
aStrategy
1
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
SetUpWritableStreamDefaultControllerFromUnderlyingSink
(
aGlobal
.
Context
(
)
writableStream
underlyingSinkObj
underlyingSinkDict
highWaterMark
sizeAlgorithm
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
writableStream
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
WritableStreamAbort
(
JSContext
*
aCx
WritableStream
*
aStream
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
{
if
(
aStream
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Closed
|
|
aStream
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Errored
)
{
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
aStream
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
WritableStreamDefaultController
>
controller
=
aStream
-
>
Controller
(
)
;
controller
-
>
Signal
(
)
-
>
SignalAbort
(
aReason
)
;
WritableStream
:
:
WriterState
state
=
aStream
-
>
State
(
)
;
if
(
aStream
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Closed
|
|
aStream
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Errored
)
{
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
aStream
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
if
(
aStream
-
>
GetPendingAbortRequestPromise
(
)
)
{
RefPtr
<
Promise
>
promise
=
aStream
-
>
GetPendingAbortRequestPromise
(
)
;
return
promise
.
forget
(
)
;
}
MOZ_ASSERT
(
state
=
=
WritableStream
:
:
WriterState
:
:
Writable
|
|
state
=
=
WritableStream
:
:
WriterState
:
:
Erroring
)
;
bool
wasAlreadyErroring
=
false
;
JS
:
:
Rooted
<
JS
:
:
Value
>
reason
(
aCx
aReason
)
;
if
(
state
=
=
WritableStream
:
:
WriterState
:
:
Erroring
)
{
wasAlreadyErroring
=
true
;
reason
.
setUndefined
(
)
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
aStream
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
aStream
-
>
SetPendingAbortRequest
(
promise
reason
wasAlreadyErroring
)
;
if
(
!
wasAlreadyErroring
)
{
aStream
-
>
StartErroring
(
aCx
reason
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
WritableStream
:
:
Abort
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
{
if
(
Locked
(
)
)
{
return
Promise
:
:
CreateRejectedWithTypeError
(
GetParentObject
(
)
"
Canceled
Locked
Stream
"
_ns
aRv
)
;
}
RefPtr
<
WritableStream
>
thisRefPtr
=
this
;
return
WritableStreamAbort
(
aCx
thisRefPtr
aReason
aRv
)
;
}
already_AddRefed
<
Promise
>
WritableStreamClose
(
JSContext
*
aCx
WritableStream
*
aStream
ErrorResult
&
aRv
)
{
WritableStream
:
:
WriterState
state
=
aStream
-
>
State
(
)
;
if
(
state
=
=
WritableStream
:
:
WriterState
:
:
Closed
|
|
state
=
=
WritableStream
:
:
WriterState
:
:
Errored
)
{
return
Promise
:
:
CreateRejectedWithTypeError
(
aStream
-
>
GetParentObject
(
)
"
Can
not
close
stream
after
closing
or
error
"
_ns
aRv
)
;
}
MOZ_ASSERT
(
state
=
=
WritableStream
:
:
WriterState
:
:
Writable
|
|
state
=
=
WritableStream
:
:
WriterState
:
:
Erroring
)
;
MOZ_ASSERT
(
!
aStream
-
>
CloseQueuedOrInFlight
(
)
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
aStream
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
aStream
-
>
SetCloseRequest
(
promise
)
;
RefPtr
<
WritableStreamDefaultWriter
>
writer
=
aStream
-
>
GetWriter
(
)
;
if
(
writer
&
&
aStream
-
>
Backpressure
(
)
&
&
state
=
=
WritableStream
:
:
WriterState
:
:
Writable
)
{
writer
-
>
ReadyPromise
(
)
-
>
MaybeResolveWithUndefined
(
)
;
}
RefPtr
<
WritableStreamDefaultController
>
controller
=
aStream
-
>
Controller
(
)
;
WritableStreamDefaultControllerClose
(
aCx
controller
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
WritableStream
:
:
Close
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
if
(
Locked
(
)
)
{
return
Promise
:
:
CreateRejectedWithTypeError
(
GetParentObject
(
)
"
Can
not
close
locked
stream
"
_ns
aRv
)
;
}
if
(
CloseQueuedOrInFlight
(
)
)
{
return
Promise
:
:
CreateRejectedWithTypeError
(
GetParentObject
(
)
"
Stream
is
already
closing
"
_ns
aRv
)
;
}
RefPtr
<
WritableStream
>
thisRefPtr
=
this
;
return
WritableStreamClose
(
aCx
thisRefPtr
aRv
)
;
}
already_AddRefed
<
WritableStreamDefaultWriter
>
AcquireWritableStreamDefaultWriter
(
WritableStream
*
aStream
ErrorResult
&
aRv
)
{
RefPtr
<
WritableStreamDefaultWriter
>
writer
=
new
WritableStreamDefaultWriter
(
aStream
-
>
GetParentObject
(
)
)
;
SetUpWritableStreamDefaultWriter
(
writer
aStream
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
writer
.
forget
(
)
;
}
already_AddRefed
<
WritableStream
>
CreateWritableStream
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
UnderlyingSinkAlgorithmsBase
*
aAlgorithms
double
aHighWaterMark
QueuingStrategySize
*
aSizeAlgorithm
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsNonNegativeNumber
(
aHighWaterMark
)
)
;
auto
stream
=
MakeRefPtr
<
WritableStream
>
(
aGlobal
)
;
auto
controller
=
MakeRefPtr
<
WritableStreamDefaultController
>
(
aGlobal
*
stream
)
;
SetUpWritableStreamDefaultController
(
aCx
stream
controller
aAlgorithms
aHighWaterMark
aSizeAlgorithm
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
stream
.
forget
(
)
;
}
already_AddRefed
<
WritableStreamDefaultWriter
>
WritableStream
:
:
GetWriter
(
ErrorResult
&
aRv
)
{
return
AcquireWritableStreamDefaultWriter
(
this
aRv
)
;
}
already_AddRefed
<
Promise
>
WritableStreamAddWriteRequest
(
WritableStream
*
aStream
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsWritableStreamLocked
(
aStream
)
)
;
MOZ_ASSERT
(
aStream
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Writable
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
aStream
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
aStream
-
>
AppendWriteRequest
(
promise
)
;
return
promise
.
forget
(
)
;
}
}
