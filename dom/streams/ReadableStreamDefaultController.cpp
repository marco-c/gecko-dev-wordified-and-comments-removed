#
include
"
js
/
Exception
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamController
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamDefaultController
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamDefaultControllerBinding
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamDefaultReaderBinding
.
h
"
#
include
"
mozilla
/
dom
/
UnderlyingSourceBinding
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsISupports
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION
(
ReadableStreamController
mGlobal
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ReadableStreamController
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ReadableStreamController
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadableStreamController
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
ReadableStreamDefaultController
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
ReadableStreamDefaultController
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCancelAlgorithm
mStrategySizeAlgorithm
mPullAlgorithm
mStream
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
ReadableStreamDefaultController
ReadableStreamController
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCancelAlgorithm
mStrategySizeAlgorithm
mPullAlgorithm
mStream
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
ReadableStreamDefaultController
ReadableStreamController
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
for
(
const
auto
&
queueEntry
:
tmp
-
>
mQueue
)
{
aCallbacks
.
Trace
(
&
queueEntry
-
>
mValue
"
mQueue
.
mValue
"
aClosure
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_ADDREF_INHERITED
(
ReadableStreamDefaultController
ReadableStreamController
)
NS_IMPL_RELEASE_INHERITED
(
ReadableStreamDefaultController
ReadableStreamController
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadableStreamDefaultController
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_END_INHERITING
(
ReadableStreamController
)
ReadableStreamDefaultController
:
:
ReadableStreamDefaultController
(
nsIGlobalObject
*
aGlobal
)
:
ReadableStreamController
(
aGlobal
)
{
}
ReadableStreamDefaultController
:
:
~
ReadableStreamDefaultController
(
)
{
mQueue
.
clear
(
)
;
}
JSObject
*
ReadableStreamDefaultController
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ReadableStreamDefaultController_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
ReadableStreamDefaultController
:
:
SetStream
(
ReadableStream
*
aStream
)
{
mStream
=
aStream
;
}
static
bool
ReadableStreamDefaultControllerCanCloseOrEnqueue
(
ReadableStreamDefaultController
*
aController
)
{
ReadableStream
:
:
ReaderState
state
=
aController
-
>
GetStream
(
)
-
>
State
(
)
;
if
(
!
aController
-
>
CloseRequested
(
)
&
&
state
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
return
true
;
}
return
false
;
}
enum
class
CloseOrEnqueue
{
Close
Enqueue
}
;
static
bool
ReadableStreamDefaultControllerCanCloseOrEnqueueAndThrow
(
ReadableStreamDefaultController
*
aController
CloseOrEnqueue
aCloseOrEnqueue
ErrorResult
&
aRv
)
{
ReadableStream
:
:
ReaderState
state
=
aController
-
>
GetStream
(
)
-
>
State
(
)
;
nsCString
prefix
;
if
(
aCloseOrEnqueue
=
=
CloseOrEnqueue
:
:
Close
)
{
prefix
=
"
Cannot
close
a
readable
stream
that
"
_ns
;
}
else
{
prefix
=
"
Cannot
enqueue
into
a
readable
stream
that
"
_ns
;
}
switch
(
state
)
{
case
ReadableStream
:
:
ReaderState
:
:
Readable
:
if
(
!
aController
-
>
CloseRequested
(
)
)
{
return
true
;
}
aRv
.
ThrowTypeError
(
prefix
+
"
has
already
been
requested
to
close
.
"
_ns
)
;
return
false
;
case
ReadableStream
:
:
ReaderState
:
:
Closed
:
aRv
.
ThrowTypeError
(
prefix
+
"
is
already
closed
.
"
_ns
)
;
return
false
;
case
ReadableStream
:
:
ReaderState
:
:
Errored
:
aRv
.
ThrowTypeError
(
prefix
+
"
has
errored
.
"
_ns
)
;
return
false
;
}
}
static
Nullable
<
double
>
ReadableStreamDefaultControllerGetDesiredSize
(
ReadableStreamDefaultController
*
aController
)
{
ReadableStream
:
:
ReaderState
state
=
aController
-
>
GetStream
(
)
-
>
State
(
)
;
if
(
state
=
=
ReadableStream
:
:
ReaderState
:
:
Errored
)
{
return
nullptr
;
}
if
(
state
=
=
ReadableStream
:
:
ReaderState
:
:
Closed
)
{
return
0
.
0
;
}
return
aController
-
>
StrategyHWM
(
)
-
aController
-
>
QueueTotalSize
(
)
;
}
Nullable
<
double
>
ReadableStreamDefaultController
:
:
GetDesiredSize
(
)
{
return
ReadableStreamDefaultControllerGetDesiredSize
(
this
)
;
}
static
void
ReadableStreamDefaultControllerClearAlgorithms
(
ReadableStreamDefaultController
*
aController
)
{
aController
-
>
SetPullAlgorithm
(
nullptr
)
;
aController
-
>
SetCancelAlgorithm
(
nullptr
)
;
aController
-
>
setStrategySizeAlgorithm
(
nullptr
)
;
}
void
ReadableStreamDefaultControllerClose
(
JSContext
*
aCx
ReadableStreamDefaultController
*
aController
ErrorResult
&
aRv
)
{
if
(
!
ReadableStreamDefaultControllerCanCloseOrEnqueue
(
aController
)
)
{
return
;
}
ReadableStream
*
stream
=
aController
-
>
GetStream
(
)
;
aController
-
>
SetCloseRequested
(
true
)
;
if
(
aController
-
>
Queue
(
)
.
isEmpty
(
)
)
{
ReadableStreamDefaultControllerClearAlgorithms
(
aController
)
;
ReadableStreamClose
(
aCx
stream
aRv
)
;
}
}
void
ReadableStreamDefaultController
:
:
Close
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
if
(
!
ReadableStreamDefaultControllerCanCloseOrEnqueueAndThrow
(
this
CloseOrEnqueue
:
:
Close
aRv
)
)
{
return
;
}
ReadableStreamDefaultControllerClose
(
aCx
this
aRv
)
;
}
MOZ_CAN_RUN_SCRIPT
static
void
ReadableStreamDefaultControllerCallPullIfNeeded
(
JSContext
*
aCx
ReadableStreamDefaultController
*
aController
ErrorResult
&
aRv
)
;
void
ReadableStreamDefaultControllerEnqueue
(
JSContext
*
aCx
ReadableStreamDefaultController
*
aController
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
{
if
(
!
ReadableStreamDefaultControllerCanCloseOrEnqueue
(
aController
)
)
{
return
;
}
ReadableStream
*
stream
=
aController
-
>
GetStream
(
)
;
if
(
IsReadableStreamLocked
(
stream
)
&
&
ReadableStreamGetNumReadRequests
(
stream
)
>
0
)
{
ReadableStreamFulfillReadRequest
(
aCx
stream
aChunk
false
aRv
)
;
}
else
{
Optional
<
JS
:
:
Handle
<
JS
:
:
Value
>
>
optionalChunk
(
aCx
aChunk
)
;
RefPtr
<
QueuingStrategySize
>
sizeAlgorithm
(
aController
-
>
StrategySizeAlgorithm
(
)
)
;
double
chunkSize
=
sizeAlgorithm
?
sizeAlgorithm
-
>
Call
(
optionalChunk
aRv
"
ReadableStreamDefaultController
.
[
[
strategySizeAlgorithm
]
]
"
CallbackObject
:
:
eRethrowExceptions
)
:
1
.
0
;
if
(
aRv
.
MaybeSetPendingException
(
aCx
"
ReadableStreamDefaultController
.
enqueue
"
)
)
{
JS
:
:
RootedValue
errorValue
(
aCx
)
;
JS_GetPendingException
(
aCx
&
errorValue
)
;
ReadableStreamDefaultControllerError
(
aCx
aController
errorValue
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aRv
.
MightThrowJSException
(
)
;
aRv
.
ThrowJSException
(
aCx
errorValue
)
;
return
;
}
EnqueueValueWithSize
(
aController
aChunk
chunkSize
aRv
)
;
if
(
aRv
.
MaybeSetPendingException
(
aCx
"
ReadableStreamDefaultController
.
enqueue
"
)
)
{
JS
:
:
RootedValue
errorValue
(
aCx
)
;
JS_GetPendingException
(
aCx
&
errorValue
)
;
ReadableStreamDefaultControllerError
(
aCx
aController
errorValue
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aRv
.
MightThrowJSException
(
)
;
aRv
.
ThrowJSException
(
aCx
errorValue
)
;
return
;
}
}
ReadableStreamDefaultControllerCallPullIfNeeded
(
aCx
aController
aRv
)
;
}
void
ReadableStreamDefaultController
:
:
Enqueue
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
{
if
(
!
ReadableStreamDefaultControllerCanCloseOrEnqueueAndThrow
(
this
CloseOrEnqueue
:
:
Enqueue
aRv
)
)
{
return
;
}
ReadableStreamDefaultControllerEnqueue
(
aCx
this
aChunk
aRv
)
;
}
void
ReadableStreamDefaultController
:
:
Error
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
{
ReadableStreamDefaultControllerError
(
aCx
this
aError
aRv
)
;
}
static
bool
ReadableStreamDefaultControllerShouldCallPull
(
ReadableStreamDefaultController
*
aController
)
{
ReadableStream
*
stream
=
aController
-
>
GetStream
(
)
;
if
(
!
ReadableStreamDefaultControllerCanCloseOrEnqueue
(
aController
)
)
{
return
false
;
}
if
(
!
aController
-
>
Started
(
)
)
{
return
false
;
}
if
(
IsReadableStreamLocked
(
stream
)
&
&
ReadableStreamGetNumReadRequests
(
stream
)
>
0
)
{
return
true
;
}
Nullable
<
double
>
desiredSize
=
ReadableStreamDefaultControllerGetDesiredSize
(
aController
)
;
MOZ_ASSERT
(
!
desiredSize
.
IsNull
(
)
)
;
return
desiredSize
.
Value
(
)
>
0
;
}
void
ReadableStreamDefaultControllerError
(
JSContext
*
aCx
ReadableStreamDefaultController
*
aController
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
ReadableStream
*
stream
=
aController
-
>
GetStream
(
)
;
if
(
stream
-
>
State
(
)
!
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
return
;
}
ResetQueue
(
aController
)
;
ReadableStreamDefaultControllerClearAlgorithms
(
aController
)
;
ReadableStreamError
(
aCx
stream
aValue
aRv
)
;
}
class
PullIfNeededNativePromiseHandler
final
:
public
PromiseNativeHandler
{
~
PullIfNeededNativePromiseHandler
(
)
=
default
;
RefPtr
<
ReadableStreamDefaultController
>
mController
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
PullIfNeededNativePromiseHandler
)
explicit
PullIfNeededNativePromiseHandler
(
ReadableStreamDefaultController
*
aController
)
:
PromiseNativeHandler
(
)
mController
(
aController
)
{
}
MOZ_CAN_RUN_SCRIPT
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
mController
-
>
SetPulling
(
false
)
;
if
(
mController
-
>
PullAgain
(
)
)
{
mController
-
>
SetPullAgain
(
false
)
;
IgnoredErrorResult
rv
;
ReadableStreamDefaultControllerCallPullIfNeeded
(
aCx
MOZ_KnownLive
(
mController
)
rv
)
;
(
void
)
NS_WARN_IF
(
rv
.
Failed
(
)
)
;
}
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
IgnoredErrorResult
rv
;
ReadableStreamDefaultControllerError
(
aCx
mController
aValue
rv
)
;
(
void
)
rv
.
MaybeSetPendingException
(
aCx
"
PullIfNeeded
Rejected
Error
"
)
;
}
}
;
NS_IMPL_CYCLE_COLLECTION
(
PullIfNeededNativePromiseHandler
mController
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
PullIfNeededNativePromiseHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
PullIfNeededNativePromiseHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
PullIfNeededNativePromiseHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
static
void
ReadableStreamDefaultControllerCallPullIfNeeded
(
JSContext
*
aCx
ReadableStreamDefaultController
*
aController
ErrorResult
&
aRv
)
{
bool
shouldPull
=
ReadableStreamDefaultControllerShouldCallPull
(
aController
)
;
if
(
!
shouldPull
)
{
return
;
}
if
(
aController
-
>
Pulling
(
)
)
{
aController
-
>
SetPullAgain
(
true
)
;
return
;
}
MOZ_ASSERT
(
!
aController
-
>
PullAgain
(
)
)
;
aController
-
>
SetPulling
(
true
)
;
RefPtr
<
UnderlyingSourcePullCallbackHelper
>
pullAlgorithm
(
aController
-
>
GetPullAlgorithm
(
)
)
;
RefPtr
<
Promise
>
maybeRejectPromise
=
Promise
:
:
Create
(
aController
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
RefPtr
<
Promise
>
pullPromise
=
pullAlgorithm
?
pullAlgorithm
-
>
PullCallback
(
aCx
*
aController
aRv
)
:
Promise
:
:
CreateResolvedWithUndefined
(
aController
-
>
GetParentObject
(
)
aRv
)
;
aRv
.
WouldReportJSException
(
)
;
if
(
aRv
.
Failed
(
)
)
{
MOZ_ASSERT
(
!
pullPromise
)
;
pullPromise
=
maybeRejectPromise
;
pullPromise
-
>
MaybeReject
(
std
:
:
move
(
aRv
)
)
;
}
pullPromise
-
>
AppendNativeHandler
(
new
PullIfNeededNativePromiseHandler
(
aController
)
)
;
}
class
StartPromiseNativeHandler
final
:
public
PromiseNativeHandler
{
~
StartPromiseNativeHandler
(
)
=
default
;
RefPtr
<
ReadableStreamDefaultController
>
mController
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
StartPromiseNativeHandler
)
explicit
StartPromiseNativeHandler
(
ReadableStreamDefaultController
*
aController
)
:
PromiseNativeHandler
(
)
mController
(
aController
)
{
}
MOZ_CAN_RUN_SCRIPT
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
MOZ_ASSERT
(
mController
)
;
mController
-
>
SetStarted
(
true
)
;
mController
-
>
SetPulling
(
false
)
;
mController
-
>
SetPullAgain
(
false
)
;
ErrorResult
rv
;
RefPtr
<
ReadableStreamDefaultController
>
stackController
=
mController
;
ReadableStreamDefaultControllerCallPullIfNeeded
(
aCx
stackController
rv
)
;
if
(
rv
.
Failed
(
)
)
{
MOZ_CRASH
(
"
Error
Handling
Not
Clear
Inside
Promise
Callback
"
)
;
}
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
ErrorResult
rv
;
ReadableStreamDefaultControllerError
(
aCx
mController
aValue
rv
)
;
(
void
)
rv
.
MaybeSetPendingException
(
aCx
"
StartPromise
Rejected
Error
"
)
;
}
}
;
NS_IMPL_CYCLE_COLLECTION
(
StartPromiseNativeHandler
mController
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
StartPromiseNativeHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
StartPromiseNativeHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
StartPromiseNativeHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
void
SetUpReadableStreamDefaultController
(
JSContext
*
aCx
ReadableStream
*
aStream
ReadableStreamDefaultController
*
aController
UnderlyingSourceStartCallbackHelper
*
aStartAlgorithm
UnderlyingSourcePullCallbackHelper
*
aPullAlgorithm
UnderlyingSourceCancelCallbackHelper
*
aCancelAlgorithm
double
aHighWaterMark
QueuingStrategySize
*
aSizeAlgorithm
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aStream
-
>
Controller
(
)
)
;
aController
-
>
SetStream
(
aStream
)
;
ResetQueue
(
aController
)
;
aController
-
>
SetStarted
(
false
)
;
aController
-
>
SetCloseRequested
(
false
)
;
aController
-
>
SetPullAgain
(
false
)
;
aController
-
>
SetPulling
(
false
)
;
aController
-
>
setStrategySizeAlgorithm
(
aSizeAlgorithm
)
;
aController
-
>
SetStrategyHWM
(
aHighWaterMark
)
;
aController
-
>
SetPullAlgorithm
(
aPullAlgorithm
)
;
aController
-
>
SetCancelAlgorithm
(
aCancelAlgorithm
)
;
aStream
-
>
SetController
(
aController
)
;
JS
:
:
RootedValue
startResult
(
aCx
JS
:
:
UndefinedValue
(
)
)
;
if
(
aStartAlgorithm
)
{
RefPtr
<
UnderlyingSourceStartCallbackHelper
>
startAlgorithm
(
aStartAlgorithm
)
;
RefPtr
<
ReadableStreamDefaultController
>
controller
(
aController
)
;
startAlgorithm
-
>
StartCallback
(
aCx
*
controller
&
startResult
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
RefPtr
<
Promise
>
startPromise
=
Promise
:
:
Create
(
GetIncumbentGlobal
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
startPromise
-
>
MaybeResolve
(
startResult
)
;
RefPtr
<
StartPromiseNativeHandler
>
startPromiseHandler
=
new
StartPromiseNativeHandler
(
aController
)
;
startPromise
-
>
AppendNativeHandler
(
startPromiseHandler
)
;
}
void
SetupReadableStreamDefaultControllerFromUnderlyingSource
(
JSContext
*
aCx
ReadableStream
*
aStream
JS
:
:
HandleObject
aUnderlyingSource
UnderlyingSource
&
aUnderlyingSourceDict
double
aHighWaterMark
QueuingStrategySize
*
aSizeAlgorithm
ErrorResult
&
aRv
)
{
RefPtr
<
ReadableStreamDefaultController
>
controller
=
new
ReadableStreamDefaultController
(
aStream
-
>
GetParentObject
(
)
)
;
RefPtr
<
UnderlyingSourceStartCallbackHelper
>
startAlgorithm
=
aUnderlyingSourceDict
.
mStart
.
WasPassed
(
)
?
new
UnderlyingSourceStartCallbackHelper
(
aUnderlyingSourceDict
.
mStart
.
Value
(
)
aUnderlyingSource
)
:
nullptr
;
RefPtr
<
UnderlyingSourcePullCallbackHelper
>
pullAlgorithm
=
aUnderlyingSourceDict
.
mPull
.
WasPassed
(
)
?
new
IDLUnderlyingSourcePullCallbackHelper
(
aUnderlyingSourceDict
.
mPull
.
Value
(
)
aUnderlyingSource
)
:
nullptr
;
RefPtr
<
UnderlyingSourceCancelCallbackHelper
>
cancelAlgorithm
=
aUnderlyingSourceDict
.
mCancel
.
WasPassed
(
)
?
new
IDLUnderlyingSourceCancelCallbackHelper
(
aUnderlyingSourceDict
.
mCancel
.
Value
(
)
aUnderlyingSource
)
:
nullptr
;
SetUpReadableStreamDefaultController
(
aCx
aStream
controller
startAlgorithm
pullAlgorithm
cancelAlgorithm
aHighWaterMark
aSizeAlgorithm
aRv
)
;
}
already_AddRefed
<
Promise
>
ReadableStreamDefaultController
:
:
CancelSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
{
ResetQueue
(
this
)
;
Optional
<
JS
:
:
Handle
<
JS
:
:
Value
>
>
errorOption
(
aCx
aReason
)
;
RefPtr
<
UnderlyingSourceCancelCallbackHelper
>
callback
=
this
-
>
GetCancelAlgorithm
(
)
;
RefPtr
<
Promise
>
result
=
callback
?
callback
-
>
CancelCallback
(
aCx
errorOption
aRv
)
:
Promise
:
:
CreateResolvedWithUndefined
(
GetParentObject
(
)
aRv
)
;
ReadableStreamDefaultControllerClearAlgorithms
(
this
)
;
return
result
.
forget
(
)
;
}
void
ReadableStreamDefaultController
:
:
PullSteps
(
JSContext
*
aCx
ReadRequest
*
aReadRequest
ErrorResult
&
aRv
)
{
ReadableStream
*
stream
=
mStream
;
if
(
!
mQueue
.
isEmpty
(
)
)
{
JS
:
:
RootedValue
chunk
(
aCx
)
;
DequeueValue
(
this
&
chunk
)
;
if
(
CloseRequested
(
)
&
&
mQueue
.
isEmpty
(
)
)
{
ReadableStreamDefaultControllerClearAlgorithms
(
this
)
;
ReadableStreamClose
(
aCx
stream
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
else
{
ReadableStreamDefaultControllerCallPullIfNeeded
(
aCx
this
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
aReadRequest
-
>
ChunkSteps
(
aCx
chunk
aRv
)
;
}
else
{
ReadableStreamAddReadRequest
(
stream
aReadRequest
)
;
ReadableStreamDefaultControllerCallPullIfNeeded
(
aCx
this
aRv
)
;
}
}
}
}
