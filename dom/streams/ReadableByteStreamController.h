#
ifndef
mozilla_dom_ReadableByteStreamController_h
#
define
mozilla_dom_ReadableByteStreamController_h
#
include
<
cstddef
>
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
QueuingStrategyBinding
.
h
"
#
include
"
mozilla
/
dom
/
QueueWithSizes
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
mozilla
/
dom
/
ReadRequest
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamBYOBRequest
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamController
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mozilla
:
:
dom
{
enum
ReaderType
{
Default
BYOB
None
}
;
struct
PullIntoDescriptor
;
struct
ReadableByteStreamQueueEntry
;
struct
ReadIntoRequest
;
class
ReadableByteStreamController
final
:
public
ReadableStreamController
public
nsWrapperCache
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED
(
ReadableByteStreamController
ReadableStreamController
)
public
:
explicit
ReadableByteStreamController
(
nsIGlobalObject
*
aGlobal
)
;
protected
:
~
ReadableByteStreamController
(
)
override
;
public
:
bool
IsDefault
(
)
override
{
return
false
;
}
bool
IsByte
(
)
override
{
return
true
;
}
ReadableStreamDefaultController
*
AsDefault
(
)
override
{
return
nullptr
;
}
ReadableByteStreamController
*
AsByte
(
)
override
{
return
this
;
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
already_AddRefed
<
ReadableStreamBYOBRequest
>
GetByobRequest
(
JSContext
*
aCx
ErrorResult
&
aRv
)
;
Nullable
<
double
>
GetDesiredSize
(
)
const
;
MOZ_CAN_RUN_SCRIPT
void
Close
(
JSContext
*
aCx
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
Enqueue
(
JSContext
*
aCx
const
ArrayBufferView
&
aChunk
ErrorResult
&
aRv
)
;
void
Error
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aErrorValue
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
CancelSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
override
;
MOZ_CAN_RUN_SCRIPT
void
PullSteps
(
JSContext
*
aCx
ReadRequest
*
aReadRequest
ErrorResult
&
aRv
)
override
;
void
ReleaseSteps
(
)
override
;
Maybe
<
uint64_t
>
AutoAllocateChunkSize
(
)
{
return
mAutoAllocateChunkSize
;
}
void
SetAutoAllocateChunkSize
(
Maybe
<
uint64_t
>
&
aSize
)
{
mAutoAllocateChunkSize
=
aSize
;
}
ReadableStreamBYOBRequest
*
GetByobRequest
(
)
const
{
return
mByobRequest
;
}
void
SetByobRequest
(
ReadableStreamBYOBRequest
*
aByobRequest
)
{
mByobRequest
=
aByobRequest
;
}
LinkedList
<
RefPtr
<
PullIntoDescriptor
>
>
&
PendingPullIntos
(
)
{
return
mPendingPullIntos
;
}
void
ClearPendingPullIntos
(
)
;
ReadableStream
*
Stream
(
)
const
{
return
mStream
;
}
void
SetStream
(
ReadableStream
*
aStream
)
{
mStream
=
aStream
;
}
double
QueueTotalSize
(
)
const
{
return
mQueueTotalSize
;
}
void
SetQueueTotalSize
(
double
aQueueTotalSize
)
{
mQueueTotalSize
=
aQueueTotalSize
;
}
void
AddToQueueTotalSize
(
double
aLength
)
{
mQueueTotalSize
+
=
aLength
;
}
double
StrategyHWM
(
)
const
{
return
mStrategyHWM
;
}
void
SetStrategyHWM
(
double
aStrategyHWM
)
{
mStrategyHWM
=
aStrategyHWM
;
}
bool
CloseRequested
(
)
const
{
return
mCloseRequested
;
}
void
SetCloseRequested
(
bool
aCloseRequested
)
{
mCloseRequested
=
aCloseRequested
;
}
UnderlyingSourceCancelCallbackHelper
*
GetCancelAlgorithm
(
)
const
{
return
mCancelAlgorithm
;
}
void
SetCancelAlgorithm
(
UnderlyingSourceCancelCallbackHelper
*
aCancelAlgorithm
)
{
mCancelAlgorithm
=
aCancelAlgorithm
;
}
UnderlyingSourcePullCallbackHelper
*
GetPullAlgorithm
(
)
const
{
return
mPullAlgorithm
;
}
void
SetPullAlgorithm
(
UnderlyingSourcePullCallbackHelper
*
aPullAlgorithm
)
{
mPullAlgorithm
=
aPullAlgorithm
;
}
LinkedList
<
RefPtr
<
ReadableByteStreamQueueEntry
>
>
&
Queue
(
)
{
return
mQueue
;
}
void
ClearQueue
(
)
;
bool
Started
(
)
const
{
return
mStarted
;
}
void
SetStarted
(
bool
aStarted
)
{
mStarted
=
aStarted
;
}
bool
Pulling
(
)
const
{
return
mPulling
;
}
void
SetPulling
(
bool
aPulling
)
{
mPulling
=
aPulling
;
}
bool
PullAgain
(
)
const
{
return
mPullAgain
;
}
void
SetPullAgain
(
bool
aPullAgain
)
{
mPullAgain
=
aPullAgain
;
}
private
:
bool
mCloseRequested
=
false
;
bool
mPullAgain
=
false
;
bool
mStarted
=
false
;
bool
mPulling
=
false
;
Maybe
<
uint64_t
>
mAutoAllocateChunkSize
;
RefPtr
<
ReadableStreamBYOBRequest
>
mByobRequest
;
RefPtr
<
UnderlyingSourceCancelCallbackHelper
>
mCancelAlgorithm
;
RefPtr
<
UnderlyingSourcePullCallbackHelper
>
mPullAlgorithm
;
LinkedList
<
RefPtr
<
PullIntoDescriptor
>
>
mPendingPullIntos
;
LinkedList
<
RefPtr
<
ReadableByteStreamQueueEntry
>
>
mQueue
;
double
mQueueTotalSize
=
0
.
0
;
double
mStrategyHWM
=
0
.
0
;
RefPtr
<
ReadableStream
>
mStream
;
}
;
struct
ReadableByteStreamQueueEntry
:
LinkedListElement
<
RefPtr
<
ReadableByteStreamQueueEntry
>
>
{
NS_INLINE_DECL_REFCOUNTING
(
mozilla
:
:
dom
:
:
ReadableByteStreamQueueEntry
)
friend
class
ReadableByteStreamController
:
:
cycleCollection
;
ReadableByteStreamQueueEntry
(
JS
:
:
Handle
<
JSObject
*
>
aBuffer
size_t
aByteOffset
size_t
aByteLength
)
:
LinkedListElement
<
RefPtr
<
ReadableByteStreamQueueEntry
>
>
(
)
mBuffer
(
aBuffer
)
mByteOffset
(
aByteOffset
)
mByteLength
(
aByteLength
)
{
}
JSObject
*
Buffer
(
)
const
{
return
mBuffer
;
}
void
SetBuffer
(
JS
:
:
Handle
<
JSObject
*
>
aBuffer
)
{
mBuffer
=
aBuffer
;
}
size_t
ByteOffset
(
)
const
{
return
mByteOffset
;
}
void
SetByteOffset
(
size_t
aByteOffset
)
{
mByteOffset
=
aByteOffset
;
}
size_t
ByteLength
(
)
const
{
return
mByteLength
;
}
void
SetByteLength
(
size_t
aByteLength
)
{
mByteLength
=
aByteLength
;
}
void
ClearBuffer
(
)
{
mBuffer
=
nullptr
;
}
private
:
JS
:
:
Heap
<
JSObject
*
>
mBuffer
;
size_t
mByteOffset
=
0
;
size_t
mByteLength
=
0
;
~
ReadableByteStreamQueueEntry
(
)
=
default
;
}
;
struct
PullIntoDescriptor
final
:
LinkedListElement
<
RefPtr
<
PullIntoDescriptor
>
>
{
NS_INLINE_DECL_REFCOUNTING
(
mozilla
:
:
dom
:
:
PullIntoDescriptor
)
enum
Constructor
{
DataView
#
define
DEFINE_TYPED_CONSTRUCTOR_ENUM_NAMES
(
ExternalT
NativeT
Name
)
Name
JS_FOR_EACH_TYPED_ARRAY
(
DEFINE_TYPED_CONSTRUCTOR_ENUM_NAMES
)
#
undef
DEFINE_TYPED_CONSTRUCTOR_ENUM_NAMES
}
;
static
Constructor
constructorFromScalar
(
JS
:
:
Scalar
:
:
Type
type
)
{
switch
(
type
)
{
#
define
REMAP_PULL_INTO_DESCRIPTOR_TYPE
(
ExternalT
NativeT
Name
)
\
case
JS
:
:
Scalar
:
:
Name
:
\
return
Constructor
:
:
Name
;
JS_FOR_EACH_TYPED_ARRAY
(
REMAP_PULL_INTO_DESCRIPTOR_TYPE
)
#
undef
REMAP
case
JS
:
:
Scalar
:
:
Int64
:
case
JS
:
:
Scalar
:
:
Simd128
:
case
JS
:
:
Scalar
:
:
MaxTypedArrayViewType
:
break
;
}
MOZ_CRASH
(
"
Unexpected
Scalar
:
:
Type
"
)
;
}
friend
class
ReadableByteStreamController
:
:
cycleCollection
;
PullIntoDescriptor
(
JS
:
:
Handle
<
JSObject
*
>
aBuffer
uint64_t
aBufferByteLength
uint64_t
aByteOffset
uint64_t
aByteLength
uint64_t
aBytesFilled
uint64_t
aElementSize
Constructor
aViewConstructor
ReaderType
aReaderType
)
:
LinkedListElement
<
RefPtr
<
PullIntoDescriptor
>
>
(
)
mBuffer
(
aBuffer
)
mBufferByteLength
(
aBufferByteLength
)
mByteOffset
(
aByteOffset
)
mByteLength
(
aByteLength
)
mBytesFilled
(
aBytesFilled
)
mElementSize
(
aElementSize
)
mViewConstructor
(
aViewConstructor
)
mReaderType
(
aReaderType
)
{
}
JSObject
*
Buffer
(
)
const
{
return
mBuffer
;
}
void
SetBuffer
(
JS
:
:
Handle
<
JSObject
*
>
aBuffer
)
{
mBuffer
=
aBuffer
;
}
uint64_t
BufferByteLength
(
)
const
{
return
mBufferByteLength
;
}
void
SetBufferByteLength
(
const
uint64_t
aBufferByteLength
)
{
mBufferByteLength
=
aBufferByteLength
;
}
uint64_t
ByteOffset
(
)
const
{
return
mByteOffset
;
}
void
SetByteOffset
(
const
uint64_t
aByteOffset
)
{
mByteOffset
=
aByteOffset
;
}
uint64_t
ByteLength
(
)
const
{
return
mByteLength
;
}
void
SetByteLength
(
const
uint64_t
aByteLength
)
{
mByteLength
=
aByteLength
;
}
uint64_t
BytesFilled
(
)
const
{
return
mBytesFilled
;
}
void
SetBytesFilled
(
const
uint64_t
aBytesFilled
)
{
mBytesFilled
=
aBytesFilled
;
}
uint64_t
ElementSize
(
)
const
{
return
mElementSize
;
}
void
SetElementSize
(
const
uint64_t
aElementSize
)
{
mElementSize
=
aElementSize
;
}
Constructor
ViewConstructor
(
)
const
{
return
mViewConstructor
;
}
ReaderType
GetReaderType
(
)
const
{
return
mReaderType
;
}
void
SetReaderType
(
const
ReaderType
aReaderType
)
{
mReaderType
=
aReaderType
;
}
void
ClearBuffer
(
)
{
mBuffer
=
nullptr
;
}
private
:
JS
:
:
Heap
<
JSObject
*
>
mBuffer
;
uint64_t
mBufferByteLength
=
0
;
uint64_t
mByteOffset
=
0
;
uint64_t
mByteLength
=
0
;
uint64_t
mBytesFilled
=
0
;
uint64_t
mElementSize
=
0
;
Constructor
mViewConstructor
;
ReaderType
mReaderType
;
~
PullIntoDescriptor
(
)
=
default
;
}
;
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamControllerRespond
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
uint64_t
aBytesWritten
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamControllerRespondInternal
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
uint64_t
aBytesWritten
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamControllerRespondWithNewView
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
JS
:
:
Handle
<
JSObject
*
>
aView
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamControllerPullInto
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
JS
:
:
HandleObject
aView
ReadIntoRequest
*
aReadIntoRequest
ErrorResult
&
aRv
)
;
void
ReadableByteStreamControllerError
(
ReadableByteStreamController
*
aController
JS
:
:
HandleValue
aValue
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamControllerEnqueue
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
JS
:
:
HandleObject
aChunk
ErrorResult
&
aRv
)
;
already_AddRefed
<
ReadableStreamBYOBRequest
>
ReadableByteStreamControllerGetBYOBRequest
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamControllerClose
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
SetUpReadableByteStreamController
(
JSContext
*
aCx
ReadableStream
*
aStream
ReadableByteStreamController
*
aController
UnderlyingSourceStartCallbackHelper
*
aStartAlgorithm
UnderlyingSourcePullCallbackHelper
*
aPullAlgorithm
UnderlyingSourceCancelCallbackHelper
*
aCancelAlgorithm
UnderlyingSourceErrorCallbackHelper
*
aErrorAlgorithm
double
aHighWaterMark
Maybe
<
uint64_t
>
aAutoAllocateChunkSize
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
ReadableByteStreamControllerCallPullIfNeeded
(
JSContext
*
aCx
ReadableByteStreamController
*
aController
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
SetUpReadableByteStreamControllerFromUnderlyingSource
(
JSContext
*
aCx
ReadableStream
*
aStream
JS
:
:
HandleObject
aUnderlyingSource
UnderlyingSource
&
aUnderlyingSourceDict
double
aHighWaterMark
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
SetUpReadableByteStreamControllerFromBodyStreamUnderlyingSource
(
JSContext
*
aCx
ReadableStream
*
aStream
BodyStreamHolder
*
aUnderlyingSource
ErrorResult
&
aRv
)
;
void
ReadableByteStreamControllerClearAlgorithms
(
ReadableByteStreamController
*
aController
)
;
}
#
endif
