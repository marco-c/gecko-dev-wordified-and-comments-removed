#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamBYOBReader
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamBYOBReaderBinding
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamGenericReader
.
h
"
#
include
"
mozilla
/
dom
/
ReadIntoRequest
.
h
"
#
include
"
mozilla
/
dom
/
RootedDictionary
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
mozilla
/
dom
/
ReadableByteStreamController
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamBYOBRequest
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamBYOBReader
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_INHERITED
(
ReadableStreamBYOBReader
ReadableStreamGenericReader
mReadIntoRequests
)
NS_IMPL_ADDREF_INHERITED
(
ReadableStreamBYOBReader
ReadableStreamGenericReader
)
NS_IMPL_RELEASE_INHERITED
(
ReadableStreamBYOBReader
ReadableStreamGenericReader
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadableStreamBYOBReader
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_END_INHERITING
(
ReadableStreamGenericReader
)
JSObject
*
ReadableStreamBYOBReader
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ReadableStreamBYOBReader_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
SetUpReadableStreamBYOBReader
(
JSContext
*
aCx
ReadableStreamBYOBReader
*
reader
ReadableStream
&
stream
ErrorResult
&
rv
)
{
if
(
IsReadableStreamLocked
(
&
stream
)
)
{
rv
.
ThrowTypeError
(
"
Trying
to
read
locked
stream
"
)
;
return
;
}
if
(
!
stream
.
Controller
(
)
-
>
IsByte
(
)
)
{
rv
.
ThrowTypeError
(
"
Trying
to
read
with
incompatible
controller
"
)
;
return
;
}
ReadableStreamReaderGenericInitialize
(
aCx
reader
&
stream
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
;
}
reader
-
>
ReadIntoRequests
(
)
.
clear
(
)
;
}
already_AddRefed
<
ReadableStreamBYOBReader
>
ReadableStreamBYOBReader
:
:
Constructor
(
const
GlobalObject
&
global
ReadableStream
&
stream
ErrorResult
&
rv
)
{
nsCOMPtr
<
nsIGlobalObject
>
globalObject
=
do_QueryInterface
(
global
.
GetAsSupports
(
)
)
;
RefPtr
<
ReadableStreamBYOBReader
>
reader
=
new
ReadableStreamBYOBReader
(
globalObject
)
;
SetUpReadableStreamBYOBReader
(
global
.
Context
(
)
reader
stream
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
return
reader
.
forget
(
)
;
}
struct
Read_ReadIntoRequest
final
:
public
ReadIntoRequest
{
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
Read_ReadIntoRequest
ReadIntoRequest
)
RefPtr
<
Promise
>
mPromise
;
explicit
Read_ReadIntoRequest
(
Promise
*
aPromise
)
:
mPromise
(
aPromise
)
{
}
void
ChunkSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
errorResult
)
override
{
MOZ_ASSERT
(
aChunk
.
isObject
(
)
)
;
JS
:
:
RootedObject
chunk
(
aCx
&
aChunk
.
toObject
(
)
)
;
if
(
!
JS_WrapObject
(
aCx
&
chunk
)
)
{
return
;
}
ReadableStreamBYOBReadResult
result
;
result
.
mValue
.
Construct
(
)
;
result
.
mValue
.
Value
(
)
.
Init
(
chunk
)
;
result
.
mDone
.
Construct
(
false
)
;
mPromise
-
>
MaybeResolve
(
result
)
;
}
void
CloseSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
errorResult
)
override
{
MOZ_ASSERT
(
aChunk
.
isObject
(
)
|
|
aChunk
.
isUndefined
(
)
)
;
RootedDictionary
<
ReadableStreamBYOBReadResult
>
result
(
aCx
)
;
if
(
aChunk
.
isObject
(
)
)
{
JS
:
:
RootedObject
chunk
(
aCx
&
aChunk
.
toObject
(
)
)
;
if
(
!
JS_WrapObject
(
aCx
&
chunk
)
)
{
return
;
}
result
.
mValue
.
Construct
(
)
;
result
.
mValue
.
Value
(
)
.
Init
(
chunk
)
;
}
result
.
mDone
.
Construct
(
true
)
;
mPromise
-
>
MaybeResolve
(
result
)
;
}
void
ErrorSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
e
ErrorResult
&
errorResult
)
override
{
mPromise
-
>
MaybeReject
(
e
)
;
}
protected
:
virtual
~
Read_ReadIntoRequest
(
)
=
default
;
}
;
NS_IMPL_CYCLE_COLLECTION
(
ReadIntoRequest
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ReadIntoRequest
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ReadIntoRequest
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ReadIntoRequest
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
Read_ReadIntoRequest
ReadIntoRequest
mPromise
)
NS_IMPL_ADDREF_INHERITED
(
Read_ReadIntoRequest
ReadIntoRequest
)
NS_IMPL_RELEASE_INHERITED
(
Read_ReadIntoRequest
ReadIntoRequest
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Read_ReadIntoRequest
)
NS_INTERFACE_MAP_END_INHERITING
(
ReadIntoRequest
)
void
ReadableStreamBYOBReaderRead
(
JSContext
*
aCx
ReadableStreamBYOBReader
*
aReader
JS
:
:
HandleObject
aView
ReadIntoRequest
*
aReadIntoRequest
ErrorResult
&
aRv
)
{
ReadableStream
*
stream
=
aReader
-
>
GetStream
(
)
;
MOZ_ASSERT
(
stream
)
;
stream
-
>
SetDisturbed
(
true
)
;
if
(
stream
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Errored
)
{
JS
:
:
RootedValue
error
(
aCx
stream
-
>
StoredError
(
)
)
;
aReadIntoRequest
-
>
ErrorSteps
(
aCx
error
aRv
)
;
return
;
}
MOZ_ASSERT
(
stream
-
>
Controller
(
)
-
>
IsByte
(
)
)
;
RefPtr
<
ReadableByteStreamController
>
controller
(
stream
-
>
Controller
(
)
-
>
AsByte
(
)
)
;
ReadableByteStreamControllerPullInto
(
aCx
controller
aView
aReadIntoRequest
aRv
)
;
}
already_AddRefed
<
Promise
>
ReadableStreamBYOBReader
:
:
Read
(
const
ArrayBufferView
&
aArray
ErrorResult
&
aRv
)
{
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
GetParentObject
(
)
)
)
{
aRv
.
ThrowUnknownError
(
"
Internal
error
"
)
;
return
nullptr
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
RootedObject
view
(
cx
aArray
.
Obj
(
)
)
;
if
(
JS_GetArrayBufferViewByteLength
(
view
)
=
=
0
)
{
aRv
.
ThrowTypeError
(
"
Zero
Length
View
"
)
;
return
nullptr
;
}
bool
isSharedMemory
;
JS
:
:
RootedObject
viewedArrayBuffer
(
cx
JS_GetArrayBufferViewBuffer
(
cx
view
&
isSharedMemory
)
)
;
if
(
!
viewedArrayBuffer
)
{
aRv
.
StealExceptionFromJSContext
(
cx
)
;
return
nullptr
;
}
if
(
JS
:
:
GetArrayBufferByteLength
(
viewedArrayBuffer
)
=
=
0
)
{
aRv
.
ThrowTypeError
(
"
zero
length
viewed
buffer
"
)
;
return
nullptr
;
}
if
(
JS
:
:
IsDetachedArrayBufferObject
(
viewedArrayBuffer
)
)
{
aRv
.
ThrowTypeError
(
"
Detatched
Buffer
"
)
;
return
nullptr
;
}
if
(
!
GetStream
(
)
)
{
aRv
.
ThrowTypeError
(
"
Reader
has
undefined
stream
"
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
ReadIntoRequest
>
readIntoRequest
=
new
Read_ReadIntoRequest
(
promise
)
;
ReadableStreamBYOBReaderRead
(
cx
this
view
readIntoRequest
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
promise
.
forget
(
)
;
}
void
ReadableStreamBYOBReaderErrorReadIntoRequests
(
JSContext
*
aCx
ReadableStreamBYOBReader
*
aReader
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
{
LinkedList
<
RefPtr
<
ReadIntoRequest
>
>
readIntoRequests
=
std
:
:
move
(
aReader
-
>
ReadIntoRequests
(
)
)
;
aReader
-
>
ReadIntoRequests
(
)
.
clear
(
)
;
while
(
RefPtr
<
ReadIntoRequest
>
readIntoRequest
=
readIntoRequests
.
popFirst
(
)
)
{
readIntoRequest
-
>
ErrorSteps
(
aCx
aError
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
}
void
ReadableStreamBYOBReaderRelease
(
JSContext
*
aCx
ReadableStreamBYOBReader
*
aReader
ErrorResult
&
aRv
)
{
ReadableStreamReaderGenericRelease
(
aReader
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
ErrorResult
rv
;
rv
.
ThrowTypeError
(
"
Releasing
lock
"
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
)
;
MOZ_ALWAYS_TRUE
(
ToJSValue
(
aCx
std
:
:
move
(
rv
)
&
error
)
)
;
ReadableStreamBYOBReaderErrorReadIntoRequests
(
aCx
aReader
error
aRv
)
;
}
void
ReadableStreamBYOBReader
:
:
ReleaseLock
(
ErrorResult
&
aRv
)
{
if
(
!
mStream
)
{
return
;
}
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
mGlobal
)
)
{
return
aRv
.
ThrowUnknownError
(
"
Internal
error
"
)
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
RefPtr
<
ReadableStreamBYOBReader
>
thisRefPtr
=
this
;
ReadableStreamBYOBReaderRelease
(
cx
thisRefPtr
aRv
)
;
}
already_AddRefed
<
ReadableStreamBYOBReader
>
AcquireReadableStreamBYOBReader
(
JSContext
*
aCx
ReadableStream
*
aStream
ErrorResult
&
aRv
)
{
RefPtr
<
ReadableStreamBYOBReader
>
reader
=
new
ReadableStreamBYOBReader
(
aStream
-
>
GetParentObject
(
)
)
;
SetUpReadableStreamBYOBReader
(
aCx
reader
*
aStream
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
reader
.
forget
(
)
;
}
}
}
