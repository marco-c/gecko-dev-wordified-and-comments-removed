#
ifndef
mozilla_dom_WritableStream_h
#
define
mozilla_dom_WritableStream_h
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
QueuingStrategyBinding
.
h
"
#
include
"
mozilla
/
dom
/
WritableStreamDefaultController
.
h
"
#
include
"
mozilla
/
dom
/
WritableStreamDefaultWriter
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
ifndef
MOZ_DOM_STREAMS
#
error
"
Shouldn
'
t
be
compiling
with
this
header
without
MOZ_DOM_STREAMS
set
"
#
endif
namespace
mozilla
:
:
dom
{
class
Promise
;
class
WritableStreamDefaultController
;
class
WritableStreamDefaultWriter
;
class
UnderlyingSinkAlgorithmsBase
;
class
WritableStream
:
public
nsISupports
public
nsWrapperCache
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
WritableStream
)
protected
:
virtual
~
WritableStream
(
)
;
public
:
explicit
WritableStream
(
const
GlobalObject
&
aGlobal
)
;
explicit
WritableStream
(
nsIGlobalObject
*
aGlobal
)
;
enum
class
WriterState
{
Writable
Closed
Erroring
Errored
}
;
public
:
bool
Backpressure
(
)
const
{
return
mBackpressure
;
}
void
SetBackpressure
(
bool
aBackpressure
)
{
mBackpressure
=
aBackpressure
;
}
Promise
*
GetCloseRequest
(
)
{
return
mCloseRequest
;
}
void
SetCloseRequest
(
Promise
*
aRequest
)
{
mCloseRequest
=
aRequest
;
}
MOZ_KNOWN_LIVE
WritableStreamDefaultController
*
Controller
(
)
{
return
mController
;
}
void
SetController
(
WritableStreamDefaultController
&
aController
)
{
MOZ_ASSERT
(
!
mController
)
;
mController
=
&
aController
;
}
Promise
*
GetInFlightWriteRequest
(
)
const
{
return
mInFlightWriteRequest
;
}
Promise
*
GetPendingAbortRequestPromise
(
)
const
{
return
mPendingAbortRequestPromise
;
}
void
SetPendingAbortRequest
(
Promise
*
aPromise
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
bool
aWasAlreadyErroring
)
{
mPendingAbortRequestPromise
=
aPromise
;
mPendingAbortRequestReason
=
aReason
;
mPendingAbortRequestWasAlreadyErroring
=
aWasAlreadyErroring
;
}
WritableStreamDefaultWriter
*
GetWriter
(
)
const
{
return
mWriter
;
}
void
SetWriter
(
WritableStreamDefaultWriter
*
aWriter
)
{
mWriter
=
aWriter
;
}
WriterState
State
(
)
const
{
return
mState
;
}
void
SetState
(
const
WriterState
&
aState
)
{
mState
=
aState
;
}
JS
:
:
Value
StoredError
(
)
const
{
return
mStoredError
;
}
void
SetStoredError
(
JS
:
:
HandleValue
aStoredError
)
{
mStoredError
=
aStoredError
;
}
void
AppendWriteRequest
(
RefPtr
<
Promise
>
&
aRequest
)
{
mWriteRequests
.
AppendElement
(
aRequest
)
;
}
bool
CloseQueuedOrInFlight
(
)
const
{
return
mCloseRequest
|
|
mInFlightCloseRequest
;
}
MOZ_CAN_RUN_SCRIPT
void
DealWithRejection
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
FinishErroring
(
JSContext
*
aCx
ErrorResult
&
aRv
)
;
void
FinishInFlightClose
(
)
;
MOZ_CAN_RUN_SCRIPT
void
FinishInFlightCloseWithError
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
;
void
FinishInFlightWrite
(
)
;
MOZ_CAN_RUN_SCRIPT
void
FinishInFlightWriteWithError
(
JSContext
*
aCX
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aR
)
;
bool
HasOperationMarkedInFlight
(
)
const
{
return
mInFlightWriteRequest
|
|
mInFlightCloseRequest
;
}
void
MarkCloseRequestInFlight
(
)
;
void
MarkFirstWriteRequestInFlight
(
)
;
void
RejectCloseAndClosedPromiseIfNeeded
(
)
;
MOZ_CAN_RUN_SCRIPT
void
StartErroring
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
;
void
UpdateBackpressure
(
bool
aBackpressure
ErrorResult
&
aRv
)
;
public
:
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
mGlobal
;
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
static
already_AddRefed
<
WritableStream
>
Constructor
(
const
GlobalObject
&
aGlobal
const
Optional
<
JS
:
:
Handle
<
JSObject
*
>
>
&
aUnderlyingSink
const
QueuingStrategy
&
aStrategy
ErrorResult
&
aRv
)
;
bool
Locked
(
)
const
{
return
!
!
mWriter
;
}
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
Abort
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
Close
(
JSContext
*
aCx
ErrorResult
&
aRv
)
;
already_AddRefed
<
WritableStreamDefaultWriter
>
GetWriter
(
ErrorResult
&
aRv
)
;
private
:
bool
mBackpressure
=
false
;
RefPtr
<
Promise
>
mCloseRequest
;
MOZ_KNOWN_LIVE
RefPtr
<
WritableStreamDefaultController
>
mController
;
RefPtr
<
Promise
>
mInFlightWriteRequest
;
RefPtr
<
Promise
>
mInFlightCloseRequest
;
RefPtr
<
Promise
>
mPendingAbortRequestPromise
;
JS
:
:
Heap
<
JS
:
:
Value
>
mPendingAbortRequestReason
;
bool
mPendingAbortRequestWasAlreadyErroring
=
false
;
WriterState
mState
=
WriterState
:
:
Writable
;
JS
:
:
Heap
<
JS
:
:
Value
>
mStoredError
;
RefPtr
<
WritableStreamDefaultWriter
>
mWriter
;
nsTArray
<
RefPtr
<
Promise
>
>
mWriteRequests
;
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
}
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
WritableStream
>
CreateWritableStream
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
UnderlyingSinkAlgorithmsBase
*
aAlgorithms
double
aHighWaterMark
QueuingStrategySize
*
aSizeAlgorithm
ErrorResult
&
aRv
)
;
inline
bool
IsWritableStreamLocked
(
WritableStream
*
aStream
)
{
return
aStream
-
>
Locked
(
)
;
}
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
WritableStreamAbort
(
JSContext
*
aCx
WritableStream
*
aStream
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
WritableStreamClose
(
JSContext
*
aCx
WritableStream
*
aStream
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
WritableStreamAddWriteRequest
(
WritableStream
*
aStream
ErrorResult
&
aRv
)
;
already_AddRefed
<
WritableStreamDefaultWriter
>
AcquireWritableStreamDefaultWriter
(
WritableStream
*
aStream
ErrorResult
&
aRv
)
;
}
#
endif
