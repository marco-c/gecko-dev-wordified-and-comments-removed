#
include
"
js
/
Exception
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
AbortSignal
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
WritableStream
.
h
"
#
include
"
mozilla
/
dom
/
WritableStreamDefaultController
.
h
"
#
include
"
mozilla
/
dom
/
WritableStreamDefaultControllerBinding
.
h
"
#
include
"
mozilla
/
dom
/
UnderlyingSinkBinding
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupports
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
WritableStreamDefaultController
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
WritableStreamDefaultController
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mGlobal
mSignal
mStrategySizeAlgorithm
mWriteAlgorithm
mCloseAlgorithm
mAbortAlgorithm
mStream
)
tmp
-
>
mQueue
.
clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
WritableStreamDefaultController
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mGlobal
mSignal
mStrategySizeAlgorithm
mWriteAlgorithm
mCloseAlgorithm
mAbortAlgorithm
mStream
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
WritableStreamDefaultController
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
for
(
const
auto
&
queueEntry
:
tmp
-
>
mQueue
)
{
aCallbacks
.
Trace
(
&
queueEntry
-
>
mValue
"
mQueue
.
mValue
"
aClosure
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
WritableStreamDefaultController
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
WritableStreamDefaultController
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
WritableStreamDefaultController
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
WritableStreamDefaultController
:
:
WritableStreamDefaultController
(
nsISupports
*
aGlobal
WritableStream
&
aStream
)
:
mGlobal
(
do_QueryInterface
(
aGlobal
)
)
mStream
(
&
aStream
)
{
}
WritableStreamDefaultController
:
:
~
WritableStreamDefaultController
(
)
{
mQueue
.
clear
(
)
;
}
JSObject
*
WritableStreamDefaultController
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
WritableStreamDefaultController_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
WritableStreamDefaultController
:
:
Error
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
{
if
(
mStream
-
>
State
(
)
!
=
WritableStream
:
:
WriterState
:
:
Writable
)
{
return
;
}
RefPtr
<
WritableStreamDefaultController
>
thisRefPtr
=
this
;
WritableStreamDefaultControllerError
(
aCx
thisRefPtr
aError
aRv
)
;
}
already_AddRefed
<
Promise
>
WritableStreamDefaultController
:
:
AbortSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
)
{
RefPtr
<
UnderlyingSinkAbortCallbackHelper
>
abortAlgorithm
(
mAbortAlgorithm
)
;
Optional
<
JS
:
:
Handle
<
JS
:
:
Value
>
>
optionalReason
(
aCx
aReason
)
;
RefPtr
<
Promise
>
abortPromise
=
abortAlgorithm
?
abortAlgorithm
-
>
AbortCallback
(
aCx
optionalReason
aRv
)
:
Promise
:
:
CreateResolvedWithUndefined
(
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
ClearAlgorithms
(
)
;
return
abortPromise
.
forget
(
)
;
}
void
WritableStreamDefaultController
:
:
ErrorSteps
(
)
{
ResetQueue
(
this
)
;
}
void
WritableStreamDefaultController
:
:
SetSignal
(
AbortSignal
*
aSignal
)
{
MOZ_ASSERT
(
aSignal
)
;
mSignal
=
aSignal
;
}
MOZ_CAN_RUN_SCRIPT
static
void
WritableStreamDefaultControllerAdvanceQueueIfNeeded
(
JSContext
*
aCx
WritableStreamDefaultController
*
aController
ErrorResult
&
aRv
)
;
class
WritableStartPromiseNativeHandler
final
:
public
PromiseNativeHandler
{
~
WritableStartPromiseNativeHandler
(
)
=
default
;
RefPtr
<
WritableStreamDefaultController
>
mController
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
WritableStartPromiseNativeHandler
)
explicit
WritableStartPromiseNativeHandler
(
WritableStreamDefaultController
*
aController
)
:
PromiseNativeHandler
(
)
mController
(
aController
)
{
}
MOZ_CAN_RUN_SCRIPT
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
{
MOZ_ASSERT
(
mController
-
>
Stream
(
)
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Writable
|
|
mController
-
>
Stream
(
)
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Erroring
)
;
mController
-
>
SetStarted
(
true
)
;
WritableStreamDefaultControllerAdvanceQueueIfNeeded
(
aCx
MOZ_KnownLive
(
mController
)
aRv
)
;
}
MOZ_CAN_RUN_SCRIPT
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
{
RefPtr
<
WritableStream
>
stream
=
mController
-
>
Stream
(
)
;
MOZ_ASSERT
(
stream
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Writable
|
|
stream
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Erroring
)
;
mController
-
>
SetStarted
(
true
)
;
stream
-
>
DealWithRejection
(
aCx
aValue
aRv
)
;
}
}
;
NS_IMPL_CYCLE_COLLECTION
(
WritableStartPromiseNativeHandler
mController
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
WritableStartPromiseNativeHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
WritableStartPromiseNativeHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
WritableStartPromiseNativeHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
void
SetUpWritableStreamDefaultController
(
JSContext
*
aCx
WritableStream
*
aStream
WritableStreamDefaultController
*
aController
UnderlyingSinkStartCallbackHelper
*
aStartAlgorithm
UnderlyingSinkWriteCallbackHelper
*
aWriteAlgorithm
UnderlyingSinkCloseCallbackHelper
*
aCloseAlgorithm
UnderlyingSinkAbortCallbackHelper
*
aAbortAlgorithm
double
aHighWaterMark
QueuingStrategySize
*
aSizeAlgorithm
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aStream
-
>
Controller
(
)
)
;
MOZ_ASSERT
(
aController
-
>
Stream
(
)
=
=
aStream
)
;
aStream
-
>
SetController
(
aController
)
;
ResetQueue
(
aController
)
;
RefPtr
<
AbortSignal
>
signal
=
new
AbortSignal
(
aController
-
>
GetParentObject
(
)
false
JS
:
:
UndefinedHandleValue
)
;
aController
-
>
SetSignal
(
signal
)
;
aController
-
>
SetStarted
(
false
)
;
aController
-
>
SetStrategySizeAlgorithm
(
aSizeAlgorithm
)
;
aController
-
>
SetStrategyHWM
(
aHighWaterMark
)
;
aController
-
>
SetWriteAlgorithm
(
aWriteAlgorithm
)
;
aController
-
>
SetCloseAlgorithm
(
aCloseAlgorithm
)
;
aController
-
>
SetAbortAlgorithm
(
aAbortAlgorithm
)
;
bool
backpressure
=
aController
-
>
GetBackpressure
(
)
;
aStream
-
>
UpdateBackpressure
(
backpressure
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
startResult
(
aCx
JS
:
:
UndefinedValue
(
)
)
;
if
(
aStartAlgorithm
)
{
RefPtr
<
UnderlyingSinkStartCallbackHelper
>
startAlgorithm
(
aStartAlgorithm
)
;
RefPtr
<
WritableStreamDefaultController
>
controller
(
aController
)
;
startAlgorithm
-
>
StartCallback
(
aCx
*
controller
&
startResult
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
RefPtr
<
Promise
>
startPromise
=
Promise
:
:
Create
(
GetIncumbentGlobal
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
startPromise
-
>
MaybeResolve
(
startResult
)
;
RefPtr
<
WritableStartPromiseNativeHandler
>
startPromiseHandler
=
new
WritableStartPromiseNativeHandler
(
aController
)
;
startPromise
-
>
AppendNativeHandler
(
startPromiseHandler
)
;
}
void
SetUpWritableStreamDefaultControllerFromUnderlyingSink
(
JSContext
*
aCx
WritableStream
*
aStream
JS
:
:
HandleObject
aUnderlyingSink
UnderlyingSink
&
aUnderlyingSinkDict
double
aHighWaterMark
QueuingStrategySize
*
aSizeAlgorithm
ErrorResult
&
aRv
)
{
RefPtr
<
WritableStreamDefaultController
>
controller
=
new
WritableStreamDefaultController
(
aStream
-
>
GetParentObject
(
)
*
aStream
)
;
RefPtr
<
UnderlyingSinkStartCallbackHelper
>
startAlgorithm
=
aUnderlyingSinkDict
.
mStart
.
WasPassed
(
)
?
new
UnderlyingSinkStartCallbackHelper
(
aUnderlyingSinkDict
.
mStart
.
Value
(
)
aUnderlyingSink
)
:
nullptr
;
RefPtr
<
UnderlyingSinkWriteCallbackHelper
>
writeAlgorithm
=
aUnderlyingSinkDict
.
mWrite
.
WasPassed
(
)
?
new
UnderlyingSinkWriteCallbackHelper
(
aUnderlyingSinkDict
.
mWrite
.
Value
(
)
aUnderlyingSink
)
:
nullptr
;
RefPtr
<
UnderlyingSinkCloseCallbackHelper
>
closeAlgorithm
=
aUnderlyingSinkDict
.
mClose
.
WasPassed
(
)
?
new
UnderlyingSinkCloseCallbackHelper
(
aUnderlyingSinkDict
.
mClose
.
Value
(
)
aUnderlyingSink
)
:
nullptr
;
RefPtr
<
UnderlyingSinkAbortCallbackHelper
>
abortAlgorithm
=
aUnderlyingSinkDict
.
mAbort
.
WasPassed
(
)
?
new
UnderlyingSinkAbortCallbackHelper
(
aUnderlyingSinkDict
.
mAbort
.
Value
(
)
aUnderlyingSink
)
:
nullptr
;
SetUpWritableStreamDefaultController
(
aCx
aStream
controller
startAlgorithm
writeAlgorithm
closeAlgorithm
abortAlgorithm
aHighWaterMark
aSizeAlgorithm
aRv
)
;
}
class
SinkCloseNativePromiseHandler
final
:
public
PromiseNativeHandler
{
~
SinkCloseNativePromiseHandler
(
)
=
default
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
SinkCloseNativePromiseHandler
)
explicit
SinkCloseNativePromiseHandler
(
WritableStreamDefaultController
*
aController
)
:
PromiseNativeHandler
(
)
mController
(
aController
)
{
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
{
RefPtr
<
WritableStream
>
stream
=
mController
-
>
Stream
(
)
;
stream
-
>
FinishInFlightClose
(
)
;
}
MOZ_CAN_RUN_SCRIPT
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
{
RefPtr
<
WritableStream
>
stream
=
mController
-
>
Stream
(
)
;
stream
-
>
FinishInFlightCloseWithError
(
aCx
aValue
aRv
)
;
}
private
:
RefPtr
<
WritableStreamDefaultController
>
mController
;
}
;
NS_IMPL_CYCLE_COLLECTION
(
SinkCloseNativePromiseHandler
mController
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
SinkCloseNativePromiseHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
SinkCloseNativePromiseHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
SinkCloseNativePromiseHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
MOZ_CAN_RUN_SCRIPT
static
void
WritableStreamDefaultControllerProcessClose
(
JSContext
*
aCx
WritableStreamDefaultController
*
aController
ErrorResult
&
aRv
)
{
RefPtr
<
WritableStream
>
stream
=
aController
-
>
Stream
(
)
;
stream
-
>
MarkCloseRequestInFlight
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
DequeueValue
(
aController
&
value
)
;
MOZ_ASSERT
(
aController
-
>
Queue
(
)
.
isEmpty
(
)
)
;
RefPtr
<
UnderlyingSinkCloseCallbackHelper
>
closeAlgorithm
(
aController
-
>
GetCloseAlgorithm
(
)
)
;
RefPtr
<
Promise
>
sinkClosePromise
=
closeAlgorithm
?
closeAlgorithm
-
>
CloseCallback
(
aCx
aRv
)
:
Promise
:
:
CreateResolvedWithUndefined
(
aController
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aController
-
>
ClearAlgorithms
(
)
;
sinkClosePromise
-
>
AppendNativeHandler
(
new
SinkCloseNativePromiseHandler
(
aController
)
)
;
}
class
SinkWriteNativePromiseHandler
final
:
public
PromiseNativeHandler
{
~
SinkWriteNativePromiseHandler
(
)
=
default
;
RefPtr
<
WritableStreamDefaultController
>
mController
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
SinkWriteNativePromiseHandler
)
explicit
SinkWriteNativePromiseHandler
(
WritableStreamDefaultController
*
aController
)
:
PromiseNativeHandler
(
)
mController
(
aController
)
{
}
MOZ_CAN_RUN_SCRIPT
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
{
RefPtr
<
WritableStream
>
stream
=
mController
-
>
Stream
(
)
;
stream
-
>
FinishInFlightWrite
(
)
;
WritableStream
:
:
WriterState
state
=
stream
-
>
State
(
)
;
MOZ_ASSERT
(
state
=
=
WritableStream
:
:
WriterState
:
:
Writable
|
|
state
=
=
WritableStream
:
:
WriterState
:
:
Erroring
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
DequeueValue
(
mController
&
value
)
;
if
(
!
stream
-
>
CloseQueuedOrInFlight
(
)
&
&
state
=
=
WritableStream
:
:
WriterState
:
:
Writable
)
{
bool
backpressure
=
mController
-
>
GetBackpressure
(
)
;
stream
-
>
UpdateBackpressure
(
backpressure
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
WritableStreamDefaultControllerAdvanceQueueIfNeeded
(
aCx
MOZ_KnownLive
(
mController
)
aRv
)
;
}
MOZ_CAN_RUN_SCRIPT
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
{
RefPtr
<
WritableStream
>
stream
=
mController
-
>
Stream
(
)
;
if
(
stream
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Writable
)
{
mController
-
>
ClearAlgorithms
(
)
;
}
stream
-
>
FinishInFlightWriteWithError
(
aCx
aValue
aRv
)
;
}
}
;
NS_IMPL_CYCLE_COLLECTION
(
SinkWriteNativePromiseHandler
mController
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
SinkWriteNativePromiseHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
SinkWriteNativePromiseHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
SinkWriteNativePromiseHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
MOZ_CAN_RUN_SCRIPT
static
void
WritableStreamDefaultControllerProcessWrite
(
JSContext
*
aCx
WritableStreamDefaultController
*
aController
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
{
RefPtr
<
WritableStream
>
stream
=
aController
-
>
Stream
(
)
;
stream
-
>
MarkFirstWriteRequestInFlight
(
)
;
RefPtr
<
UnderlyingSinkWriteCallbackHelper
>
writeAlgorithm
(
aController
-
>
GetWriteAlgorithm
(
)
)
;
RefPtr
<
Promise
>
sinkWritePromise
=
writeAlgorithm
?
writeAlgorithm
-
>
WriteCallback
(
aCx
aChunk
*
aController
aRv
)
:
Promise
:
:
CreateResolvedWithUndefined
(
aController
-
>
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
sinkWritePromise
-
>
AppendNativeHandler
(
new
SinkWriteNativePromiseHandler
(
aController
)
)
;
}
constexpr
JSWhyMagic
CLOSE_SENTINEL
=
JS_GENERIC_MAGIC
;
static
void
WritableStreamDefaultControllerAdvanceQueueIfNeeded
(
JSContext
*
aCx
WritableStreamDefaultController
*
aController
ErrorResult
&
aRv
)
{
RefPtr
<
WritableStream
>
stream
=
aController
-
>
Stream
(
)
;
if
(
!
aController
-
>
Started
(
)
)
{
return
;
}
if
(
stream
-
>
GetInFlightWriteRequest
(
)
)
{
return
;
}
WritableStream
:
:
WriterState
state
=
stream
-
>
State
(
)
;
MOZ_ASSERT
(
state
!
=
WritableStream
:
:
WriterState
:
:
Closed
&
&
state
!
=
WritableStream
:
:
WriterState
:
:
Errored
)
;
if
(
state
=
=
WritableStream
:
:
WriterState
:
:
Erroring
)
{
stream
-
>
FinishErroring
(
aCx
aRv
)
;
return
;
}
if
(
aController
-
>
Queue
(
)
.
isEmpty
(
)
)
{
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
PeekQueueValue
(
aController
&
value
)
;
if
(
value
.
isMagic
(
CLOSE_SENTINEL
)
)
{
WritableStreamDefaultControllerProcessClose
(
aCx
aController
aRv
)
;
return
;
}
WritableStreamDefaultControllerProcessWrite
(
aCx
aController
value
aRv
)
;
}
void
WritableStreamDefaultControllerClose
(
JSContext
*
aCx
WritableStreamDefaultController
*
aController
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
aCloseSentinel
(
aCx
JS
:
:
MagicValue
(
CLOSE_SENTINEL
)
)
;
EnqueueValueWithSize
(
aController
aCloseSentinel
0
aRv
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
WritableStreamDefaultControllerAdvanceQueueIfNeeded
(
aCx
aController
aRv
)
;
}
void
WritableStreamDefaultControllerWrite
(
JSContext
*
aCx
WritableStreamDefaultController
*
aController
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
double
chunkSize
ErrorResult
&
aRv
)
{
IgnoredErrorResult
rv
;
EnqueueValueWithSize
(
aController
aChunk
chunkSize
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
aCx
"
WritableStreamDefaultController
.
write
"
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
)
;
JS_GetPendingException
(
aCx
&
error
)
;
JS_ClearPendingException
(
aCx
)
;
WritableStreamDefaultControllerErrorIfNeeded
(
aCx
aController
error
aRv
)
;
return
;
}
RefPtr
<
WritableStream
>
stream
=
aController
-
>
Stream
(
)
;
if
(
!
stream
-
>
CloseQueuedOrInFlight
(
)
&
&
stream
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Writable
)
{
bool
backpressure
=
aController
-
>
GetBackpressure
(
)
;
stream
-
>
UpdateBackpressure
(
backpressure
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
WritableStreamDefaultControllerAdvanceQueueIfNeeded
(
aCx
aController
aRv
)
;
}
void
WritableStreamDefaultControllerError
(
JSContext
*
aCx
WritableStreamDefaultController
*
aController
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
{
RefPtr
<
WritableStream
>
stream
=
aController
-
>
Stream
(
)
;
MOZ_ASSERT
(
stream
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Writable
)
;
aController
-
>
ClearAlgorithms
(
)
;
stream
-
>
StartErroring
(
aCx
aError
aRv
)
;
}
void
WritableStreamDefaultControllerErrorIfNeeded
(
JSContext
*
aCx
WritableStreamDefaultController
*
aController
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
{
if
(
aController
-
>
Stream
(
)
-
>
State
(
)
=
=
WritableStream
:
:
WriterState
:
:
Writable
)
{
WritableStreamDefaultControllerError
(
aCx
aController
aError
aRv
)
;
}
}
double
WritableStreamDefaultControllerGetChunkSize
(
JSContext
*
aCx
WritableStreamDefaultController
*
aController
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
{
RefPtr
<
QueuingStrategySize
>
sizeAlgorithm
(
aController
-
>
StrategySizeAlgorithm
(
)
)
;
Optional
<
JS
:
:
Handle
<
JS
:
:
Value
>
>
optionalChunk
(
aCx
aChunk
)
;
double
chunkSize
=
sizeAlgorithm
?
sizeAlgorithm
-
>
Call
(
optionalChunk
aRv
"
WritableStreamDefaultController
.
[
[
strategySizeAlgorithm
]
]
"
CallbackObject
:
:
eRethrowExceptions
)
:
1
.
0
;
if
(
aRv
.
MaybeSetPendingException
(
aCx
"
WritableStreamDefaultController
.
[
[
strategySizeAlgorithm
]
]
"
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
)
;
JS_GetPendingException
(
aCx
&
error
)
;
JS_ClearPendingException
(
aCx
)
;
WritableStreamDefaultControllerErrorIfNeeded
(
aCx
aController
error
aRv
)
;
return
1
.
0
;
}
return
chunkSize
;
}
}
