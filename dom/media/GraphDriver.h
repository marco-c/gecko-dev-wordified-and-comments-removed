#
ifndef
GRAPHDRIVER_H_
#
define
GRAPHDRIVER_H_
#
include
"
nsAutoRef
.
h
"
#
include
"
AudioBufferUtils
.
h
"
#
include
"
AudioMixer
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
SelfRef
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
dom
/
AudioContext
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
WavDumper
.
h
"
#
include
<
thread
>
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
audio
/
AudioNotificationReceiver
.
h
"
#
endif
struct
cubeb_stream
;
template
<
>
class
nsAutoRefTraits
<
cubeb_stream
>
:
public
nsPointerRefTraits
<
cubeb_stream
>
{
public
:
static
void
Release
(
cubeb_stream
*
aStream
)
{
cubeb_stream_destroy
(
aStream
)
;
}
}
;
namespace
mozilla
{
static
const
int
MEDIA_GRAPH_TARGET_PERIOD_MS
=
10
;
static
const
int
SCHEDULE_SAFETY_MARGIN_MS
=
10
;
static
const
int
AUDIO_TARGET_MS
=
2
*
MEDIA_GRAPH_TARGET_PERIOD_MS
+
SCHEDULE_SAFETY_MARGIN_MS
;
static
const
int
AUDIO_INITIAL_FALLBACK_BACKOFF_STEP_MS
=
10
;
static
const
int
AUDIO_MAX_FALLBACK_BACKOFF_STEP_MS
=
1000
;
class
AudioCallbackDriver
;
class
GraphDriver
;
class
MediaTrack
;
class
OfflineClockDriver
;
class
SystemClockDriver
;
namespace
dom
{
enum
class
AudioContextOperation
;
}
struct
GraphInterface
:
public
nsISupports
{
class
IterationResult
final
{
struct
Undefined
{
}
;
struct
StillProcessing
{
}
;
struct
Stop
{
explicit
Stop
(
RefPtr
<
Runnable
>
aStoppedRunnable
)
:
mStoppedRunnable
(
std
:
:
move
(
aStoppedRunnable
)
)
{
}
Stop
(
const
Stop
&
)
=
delete
;
Stop
(
Stop
&
&
aOther
)
noexcept
:
mStoppedRunnable
(
std
:
:
move
(
aOther
.
mStoppedRunnable
)
)
{
}
~
Stop
(
)
{
MOZ_ASSERT
(
!
mStoppedRunnable
)
;
}
RefPtr
<
Runnable
>
mStoppedRunnable
;
void
Stopped
(
)
{
mStoppedRunnable
-
>
Run
(
)
;
mStoppedRunnable
=
nullptr
;
}
}
;
struct
SwitchDriver
{
SwitchDriver
(
RefPtr
<
GraphDriver
>
aDriver
RefPtr
<
Runnable
>
aSwitchedRunnable
)
:
mDriver
(
std
:
:
move
(
aDriver
)
)
mSwitchedRunnable
(
std
:
:
move
(
aSwitchedRunnable
)
)
{
}
SwitchDriver
(
const
SwitchDriver
&
)
=
delete
;
SwitchDriver
(
SwitchDriver
&
&
aOther
)
noexcept
:
mDriver
(
std
:
:
move
(
aOther
.
mDriver
)
)
mSwitchedRunnable
(
std
:
:
move
(
aOther
.
mSwitchedRunnable
)
)
{
}
~
SwitchDriver
(
)
{
MOZ_ASSERT
(
!
mSwitchedRunnable
)
;
}
RefPtr
<
GraphDriver
>
mDriver
;
RefPtr
<
Runnable
>
mSwitchedRunnable
;
void
Switched
(
)
{
mSwitchedRunnable
-
>
Run
(
)
;
mSwitchedRunnable
=
nullptr
;
}
}
;
Variant
<
Undefined
StillProcessing
Stop
SwitchDriver
>
mResult
;
explicit
IterationResult
(
StillProcessing
&
&
aArg
)
:
mResult
(
std
:
:
move
(
aArg
)
)
{
}
explicit
IterationResult
(
Stop
&
&
aArg
)
:
mResult
(
std
:
:
move
(
aArg
)
)
{
}
explicit
IterationResult
(
SwitchDriver
&
&
aArg
)
:
mResult
(
std
:
:
move
(
aArg
)
)
{
}
public
:
IterationResult
(
)
:
mResult
(
Undefined
(
)
)
{
}
IterationResult
(
const
IterationResult
&
)
=
delete
;
IterationResult
(
IterationResult
&
&
)
=
default
;
IterationResult
&
operator
=
(
const
IterationResult
&
)
=
delete
;
IterationResult
&
operator
=
(
IterationResult
&
&
)
=
default
;
static
IterationResult
CreateStillProcessing
(
)
{
return
IterationResult
(
StillProcessing
(
)
)
;
}
static
IterationResult
CreateStop
(
RefPtr
<
Runnable
>
aStoppedRunnable
)
{
return
IterationResult
(
Stop
(
std
:
:
move
(
aStoppedRunnable
)
)
)
;
}
static
IterationResult
CreateSwitchDriver
(
RefPtr
<
GraphDriver
>
aDriver
RefPtr
<
Runnable
>
aSwitchedRunnable
)
{
return
IterationResult
(
SwitchDriver
(
std
:
:
move
(
aDriver
)
std
:
:
move
(
aSwitchedRunnable
)
)
)
;
}
bool
IsStillProcessing
(
)
const
{
return
mResult
.
is
<
StillProcessing
>
(
)
;
}
bool
IsStop
(
)
const
{
return
mResult
.
is
<
Stop
>
(
)
;
}
bool
IsSwitchDriver
(
)
const
{
return
mResult
.
is
<
SwitchDriver
>
(
)
;
}
void
Stopped
(
)
{
MOZ_ASSERT
(
IsStop
(
)
)
;
mResult
.
as
<
Stop
>
(
)
.
Stopped
(
)
;
}
GraphDriver
*
NextDriver
(
)
const
{
if
(
!
IsSwitchDriver
(
)
)
{
return
nullptr
;
}
return
mResult
.
as
<
SwitchDriver
>
(
)
.
mDriver
;
}
void
Switched
(
)
{
MOZ_ASSERT
(
IsSwitchDriver
(
)
)
;
mResult
.
as
<
SwitchDriver
>
(
)
.
Switched
(
)
;
}
}
;
virtual
void
NotifyOutputData
(
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
=
0
;
virtual
void
NotifyStarted
(
)
=
0
;
virtual
void
NotifyInputData
(
const
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
=
0
;
virtual
void
DeviceChanged
(
)
=
0
;
virtual
IterationResult
OneIteration
(
GraphTime
aStateComputedEnd
GraphTime
aIterationEnd
AudioMixer
*
aMixer
)
=
0
;
#
ifdef
DEBUG
virtual
bool
InDriverIteration
(
GraphDriver
*
aDriver
)
=
0
;
#
endif
}
;
class
GraphDriver
{
public
:
using
IterationResult
=
GraphInterface
:
:
IterationResult
;
GraphDriver
(
GraphInterface
*
aGraphInterface
GraphDriver
*
aPreviousDriver
uint32_t
aSampleRate
)
;
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
virtual
void
Start
(
)
=
0
;
MOZ_CAN_RUN_SCRIPT
virtual
void
Shutdown
(
)
=
0
;
virtual
uint32_t
IterationDuration
(
)
=
0
;
virtual
void
EnsureNextIteration
(
)
=
0
;
void
SwitchToDriver
(
GraphDriver
*
aDriver
)
;
GraphDriver
*
PreviousDriver
(
)
;
void
SetPreviousDriver
(
GraphDriver
*
aPreviousDriver
)
;
virtual
AudioCallbackDriver
*
AsAudioCallbackDriver
(
)
{
return
nullptr
;
}
virtual
OfflineClockDriver
*
AsOfflineClockDriver
(
)
{
return
nullptr
;
}
virtual
SystemClockDriver
*
AsSystemClockDriver
(
)
{
return
nullptr
;
}
void
SetState
(
GraphTime
aIterationStart
GraphTime
aIterationEnd
GraphTime
aStateComputedTime
)
;
GraphInterface
*
Graph
(
)
const
{
return
mGraphInterface
;
}
#
ifdef
DEBUG
bool
InIteration
(
)
;
#
endif
virtual
bool
OnThread
(
)
=
0
;
virtual
bool
ThreadRunning
(
)
=
0
;
double
MediaTimeToSeconds
(
GraphTime
aTime
)
const
{
NS_ASSERTION
(
aTime
>
-
TRACK_TIME_MAX
&
&
aTime
<
=
TRACK_TIME_MAX
"
Bad
time
"
)
;
return
static_cast
<
double
>
(
aTime
)
/
mSampleRate
;
}
GraphTime
SecondsToMediaTime
(
double
aS
)
const
{
NS_ASSERTION
(
0
<
=
aS
&
&
aS
<
=
TRACK_TICKS_MAX
/
TRACK_RATE_MAX
"
Bad
seconds
"
)
;
return
mSampleRate
*
aS
;
}
GraphTime
MillisecondsToMediaTime
(
int32_t
aMS
)
const
{
return
RateConvertTicksRoundDown
(
mSampleRate
1000
aMS
)
;
}
protected
:
GraphTime
mIterationStart
=
0
;
GraphTime
mIterationEnd
=
0
;
GraphTime
mStateComputedTime
=
0
;
const
RefPtr
<
GraphInterface
>
mGraphInterface
;
const
uint32_t
mSampleRate
;
RefPtr
<
GraphDriver
>
mPreviousDriver
;
virtual
~
GraphDriver
(
)
=
default
;
}
;
class
MediaTrackGraphInitThreadRunnable
;
class
ThreadedDriver
:
public
GraphDriver
{
class
IterationWaitHelper
{
Monitor
mMonitor
;
bool
mNeedAnotherIteration
=
false
;
TimeStamp
mWakeTime
;
public
:
IterationWaitHelper
(
)
:
mMonitor
(
"
IterationWaitHelper
:
:
mMonitor
"
)
{
}
void
WaitForNextIterationAtLeast
(
TimeDuration
aDuration
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
mWakeTime
=
now
+
aDuration
;
while
(
true
)
{
if
(
mNeedAnotherIteration
&
&
now
>
=
mWakeTime
)
{
break
;
}
if
(
mNeedAnotherIteration
)
{
lock
.
Wait
(
mWakeTime
-
now
)
;
}
else
{
lock
.
Wait
(
TimeDuration
:
:
Forever
(
)
)
;
}
now
=
TimeStamp
:
:
Now
(
)
;
}
mWakeTime
=
TimeStamp
(
)
;
mNeedAnotherIteration
=
false
;
}
void
EnsureNextIteration
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mNeedAnotherIteration
=
true
;
lock
.
Notify
(
)
;
}
}
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ThreadedDriver
override
)
;
ThreadedDriver
(
GraphInterface
*
aGraphInterface
GraphDriver
*
aPreviousDriver
uint32_t
aSampleRate
)
;
void
EnsureNextIteration
(
)
override
;
void
Start
(
)
override
;
MOZ_CAN_RUN_SCRIPT
void
Shutdown
(
)
override
;
virtual
void
RunThread
(
)
;
friend
class
MediaTrackGraphInitThreadRunnable
;
uint32_t
IterationDuration
(
)
override
{
return
MEDIA_GRAPH_TARGET_PERIOD_MS
;
}
nsIThread
*
Thread
(
)
{
return
mThread
;
}
bool
OnThread
(
)
override
{
return
!
mThread
|
|
mThread
-
>
EventTarget
(
)
-
>
IsOnCurrentThread
(
)
;
}
bool
ThreadRunning
(
)
override
{
return
mThreadRunning
;
}
protected
:
void
WaitForNextIteration
(
)
;
virtual
TimeDuration
WaitInterval
(
)
=
0
;
virtual
MediaTime
GetIntervalForIteration
(
)
=
0
;
virtual
~
ThreadedDriver
(
)
;
nsCOMPtr
<
nsIThread
>
mThread
;
private
:
Atomic
<
bool
>
mThreadRunning
;
IterationWaitHelper
mWaitHelper
;
}
;
class
SystemClockDriver
:
public
ThreadedDriver
{
public
:
SystemClockDriver
(
GraphInterface
*
aGraphInterface
GraphDriver
*
aPreviousDriver
uint32_t
aSampleRate
)
;
virtual
~
SystemClockDriver
(
)
;
SystemClockDriver
*
AsSystemClockDriver
(
)
override
{
return
this
;
}
protected
:
TimeDuration
WaitInterval
(
)
override
;
MediaTime
GetIntervalForIteration
(
)
override
;
private
:
TimeStamp
mInitialTimeStamp
;
TimeStamp
mCurrentTimeStamp
;
TimeStamp
mLastTimeStamp
;
}
;
class
OfflineClockDriver
:
public
ThreadedDriver
{
public
:
OfflineClockDriver
(
GraphInterface
*
aGraphInterface
uint32_t
aSampleRate
GraphTime
aSlice
)
;
virtual
~
OfflineClockDriver
(
)
;
OfflineClockDriver
*
AsOfflineClockDriver
(
)
override
{
return
this
;
}
void
RunThread
(
)
override
;
protected
:
TimeDuration
WaitInterval
(
)
override
{
return
TimeDuration
(
)
;
}
MediaTime
GetIntervalForIteration
(
)
override
;
private
:
GraphTime
mSlice
;
}
;
struct
TrackAndPromiseForOperation
{
TrackAndPromiseForOperation
(
MediaTrack
*
aTrack
dom
:
:
AudioContextOperation
aOperation
AbstractThread
*
aMainThread
MozPromiseHolder
<
MediaTrackGraph
:
:
AudioContextOperationPromise
>
&
&
aHolder
)
;
TrackAndPromiseForOperation
(
TrackAndPromiseForOperation
&
&
aOther
)
noexcept
;
RefPtr
<
MediaTrack
>
mTrack
;
dom
:
:
AudioContextOperation
mOperation
;
RefPtr
<
AbstractThread
>
mMainThread
;
MozPromiseHolder
<
MediaTrackGraph
:
:
AudioContextOperationPromise
>
mHolder
;
}
;
enum
class
AsyncCubebOperation
{
INIT
SHUTDOWN
}
;
enum
class
AudioInputType
{
Unknown
Voice
}
;
class
AudioCallbackDriver
:
public
GraphDriver
public
MixerCallbackReceiver
#
if
defined
(
XP_WIN
)
public
audio
:
:
DeviceChangeListener
#
endif
{
using
IterationResult
=
GraphInterface
:
:
IterationResult
;
enum
class
FallbackDriverState
;
class
FallbackWrapper
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AudioCallbackDriver
override
)
;
AudioCallbackDriver
(
GraphInterface
*
aGraphInterface
GraphDriver
*
aPreviousDriver
uint32_t
aSampleRate
uint32_t
aOutputChannelCount
uint32_t
aInputChannelCount
CubebUtils
:
:
AudioDeviceID
aOutputDeviceID
CubebUtils
:
:
AudioDeviceID
aInputDeviceID
AudioInputType
aAudioInputType
)
;
void
Start
(
)
override
;
MOZ_CAN_RUN_SCRIPT
void
Shutdown
(
)
override
;
#
if
defined
(
XP_WIN
)
void
ResetDefaultDevice
(
)
override
;
#
endif
static
long
DataCallback_s
(
cubeb_stream
*
aStream
void
*
aUser
const
void
*
aInputBuffer
void
*
aOutputBuffer
long
aFrames
)
;
static
void
StateCallback_s
(
cubeb_stream
*
aStream
void
*
aUser
cubeb_state
aState
)
;
static
void
DeviceChangedCallback_s
(
void
*
aUser
)
;
long
DataCallback
(
const
AudioDataValue
*
aInputBuffer
AudioDataValue
*
aOutputBuffer
long
aFrames
)
;
void
StateCallback
(
cubeb_state
aState
)
;
uint32_t
IterationDuration
(
)
override
;
void
EnsureNextIteration
(
)
override
;
void
MixerCallback
(
AudioDataValue
*
aMixedBuffer
AudioSampleFormat
aFormat
uint32_t
aChannels
uint32_t
aFrames
uint32_t
aSampleRate
)
override
;
AudioCallbackDriver
*
AsAudioCallbackDriver
(
)
override
{
return
this
;
}
uint32_t
OutputChannelCount
(
)
{
return
mOutputChannelCount
;
}
uint32_t
InputChannelCount
(
)
{
return
mInputChannelCount
;
}
AudioInputType
InputDevicePreference
(
)
{
if
(
mInputDevicePreference
=
=
CUBEB_DEVICE_PREF_VOICE
)
{
return
AudioInputType
:
:
Voice
;
}
return
AudioInputType
:
:
Unknown
;
}
std
:
:
thread
:
:
id
ThreadId
(
)
{
return
mAudioThreadIdInCb
.
load
(
)
;
}
void
OnThreadIdChanged
(
)
;
bool
CheckThreadIdChanged
(
)
;
bool
OnThread
(
)
override
{
return
mAudioThreadIdInCb
.
load
(
)
=
=
std
:
:
this_thread
:
:
get_id
(
)
;
}
bool
ThreadRunning
(
)
override
{
return
mAudioStreamState
=
=
AudioStreamState
:
:
Running
;
}
bool
IsStarted
(
)
;
TimeDuration
AudioOutputLatency
(
)
;
private
:
void
PanOutputIfNeeded
(
bool
aMicrophoneActive
)
;
void
DeviceChangedCallback
(
)
;
bool
StartStream
(
)
;
friend
class
AsyncCubebTask
;
void
Init
(
)
;
void
Stop
(
)
;
void
FallbackToSystemClockDriver
(
)
;
void
FallbackDriverStopped
(
GraphTime
aIterationStart
GraphTime
aIterationEnd
GraphTime
aStateComputedTime
FallbackDriverState
aState
)
;
void
MaybeStartAudioStream
(
)
;
bool
OnCubebOperationThread
(
)
{
return
mInitShutdownThread
-
>
IsOnCurrentThreadInfallible
(
)
;
}
const
uint32_t
mOutputChannelCount
;
SpillBuffer
<
AudioDataValue
WEBAUDIO_BLOCK_SIZE
*
2
>
mScratchBuffer
;
AudioCallbackBufferWrapper
<
AudioDataValue
>
mBuffer
;
nsAutoRef
<
cubeb_stream
>
mAudioStream
;
const
uint32_t
mInputChannelCount
;
const
CubebUtils
:
:
AudioDeviceID
mOutputDeviceID
;
const
CubebUtils
:
:
AudioDeviceID
mInputDeviceID
;
uint32_t
mIterationDurationMS
;
Atomic
<
bool
>
mStarted
;
struct
AutoInCallback
{
explicit
AutoInCallback
(
AudioCallbackDriver
*
aDriver
)
;
~
AutoInCallback
(
)
;
AudioCallbackDriver
*
mDriver
;
}
;
const
RefPtr
<
SharedThreadPool
>
mInitShutdownThread
;
cubeb_device_pref
mInputDevicePreference
;
AudioMixer
mMixer
;
std
:
:
atomic
<
int
>
mAudioThreadId
;
std
:
:
atomic
<
std
:
:
thread
:
:
id
>
mAudioThreadIdInCb
;
enum
class
AudioStreamState
{
None
Pending
Running
Stopping
Errored
}
;
Atomic
<
AudioStreamState
>
mAudioStreamState
;
enum
class
FallbackDriverState
{
None
Running
Stopped
}
;
Atomic
<
FallbackDriverState
>
mFallbackDriverState
{
FallbackDriverState
:
:
None
}
;
DataMutex
<
RefPtr
<
FallbackWrapper
>
>
mFallback
;
bool
mRanFirstIteration
=
false
;
TimeDuration
mNextReInitBackoffStep
;
TimeStamp
mNextReInitAttempt
;
#
ifdef
XP_MACOSX
Atomic
<
bool
>
mNeedsPanning
;
#
endif
WavDumper
mInputStreamFile
;
WavDumper
mOutputStreamFile
;
virtual
~
AudioCallbackDriver
(
)
;
const
bool
mSandboxed
=
false
;
}
;
class
AsyncCubebTask
:
public
Runnable
{
public
:
AsyncCubebTask
(
AudioCallbackDriver
*
aDriver
AsyncCubebOperation
aOperation
)
;
nsresult
Dispatch
(
uint32_t
aFlags
=
NS_DISPATCH_NORMAL
)
{
return
mDriver
-
>
mInitShutdownThread
-
>
Dispatch
(
this
aFlags
)
;
}
protected
:
virtual
~
AsyncCubebTask
(
)
;
private
:
NS_IMETHOD
Run
(
)
final
;
RefPtr
<
AudioCallbackDriver
>
mDriver
;
AsyncCubebOperation
mOperation
;
RefPtr
<
GraphInterface
>
mShutdownGrip
;
}
;
}
#
endif
