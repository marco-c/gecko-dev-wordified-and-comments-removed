#
ifndef
GRAPHDRIVER_H_
#
define
GRAPHDRIVER_H_
#
include
"
nsAutoRef
.
h
"
#
include
"
AudioBufferUtils
.
h
"
#
include
"
AudioMixer
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
SelfRef
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
<
thread
>
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
audio
/
AudioNotificationReceiver
.
h
"
#
endif
struct
cubeb_stream
;
template
<
>
class
nsAutoRefTraits
<
cubeb_stream
>
:
public
nsPointerRefTraits
<
cubeb_stream
>
{
public
:
static
void
Release
(
cubeb_stream
*
aStream
)
{
cubeb_stream_destroy
(
aStream
)
;
}
}
;
namespace
mozilla
{
static
const
int
MEDIA_GRAPH_TARGET_PERIOD_MS
=
10
;
static
const
int
SCHEDULE_SAFETY_MARGIN_MS
=
10
;
static
const
int
AUDIO_TARGET_MS
=
2
*
MEDIA_GRAPH_TARGET_PERIOD_MS
+
SCHEDULE_SAFETY_MARGIN_MS
;
class
MediaStreamGraphImpl
;
class
AudioCallbackDriver
;
class
OfflineClockDriver
;
class
SystemClockDriver
;
class
GraphDriver
{
public
:
explicit
GraphDriver
(
MediaStreamGraphImpl
*
aGraphImpl
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
GraphDriver
)
;
virtual
void
WaitForNextIteration
(
)
=
0
;
virtual
void
WakeUp
(
)
=
0
;
virtual
void
Start
(
)
=
0
;
virtual
void
Revive
(
)
=
0
;
virtual
void
Shutdown
(
)
=
0
;
virtual
uint32_t
IterationDuration
(
)
=
0
;
bool
Switching
(
)
;
void
SwitchToNextDriver
(
)
;
GraphDriver
*
NextDriver
(
)
;
GraphDriver
*
PreviousDriver
(
)
;
void
SetPreviousDriver
(
GraphDriver
*
aPreviousDriver
)
;
virtual
TimeStamp
GetCurrentTimeStamp
(
)
{
return
mCurrentTimeStamp
;
}
GraphTime
IterationEnd
(
)
{
return
mIterationEnd
;
}
virtual
AudioCallbackDriver
*
AsAudioCallbackDriver
(
)
{
return
nullptr
;
}
virtual
OfflineClockDriver
*
AsOfflineClockDriver
(
)
{
return
nullptr
;
}
virtual
SystemClockDriver
*
AsSystemClockDriver
(
)
{
return
nullptr
;
}
virtual
void
SwitchAtNextIteration
(
GraphDriver
*
aDriver
)
;
void
SetGraphTime
(
GraphDriver
*
aPreviousDriver
GraphTime
aLastSwitchNextIterationStart
GraphTime
aLastSwitchNextIterationEnd
)
;
void
EnsureNextIteration
(
)
;
void
EnsureNextIterationLocked
(
)
;
MediaStreamGraphImpl
*
GraphImpl
(
)
const
{
return
mGraphImpl
;
}
virtual
bool
OnThread
(
)
=
0
;
virtual
bool
ThreadRunning
(
)
=
0
;
protected
:
GraphTime
StateComputedTime
(
)
const
;
void
SetNextDriver
(
GraphDriver
*
aNextDriver
)
;
GraphTime
mIterationStart
;
GraphTime
mIterationEnd
;
const
RefPtr
<
MediaStreamGraphImpl
>
mGraphImpl
;
TimeStamp
mCurrentTimeStamp
;
RefPtr
<
GraphDriver
>
mPreviousDriver
;
RefPtr
<
GraphDriver
>
mNextDriver
;
virtual
~
GraphDriver
(
)
{
}
}
;
class
MediaStreamGraphInitThreadRunnable
;
class
ThreadedDriver
:
public
GraphDriver
{
public
:
explicit
ThreadedDriver
(
MediaStreamGraphImpl
*
aGraphImpl
)
;
virtual
~
ThreadedDriver
(
)
;
void
Start
(
)
override
;
void
Revive
(
)
override
;
void
Shutdown
(
)
override
;
void
RunThread
(
)
;
friend
class
MediaStreamGraphInitThreadRunnable
;
uint32_t
IterationDuration
(
)
override
{
return
MEDIA_GRAPH_TARGET_PERIOD_MS
;
}
bool
OnThread
(
)
override
{
return
!
mThread
|
|
mThread
-
>
EventTarget
(
)
-
>
IsOnCurrentThread
(
)
;
}
bool
ThreadRunning
(
)
override
{
return
mThreadRunning
;
}
virtual
MediaTime
GetIntervalForIteration
(
)
=
0
;
protected
:
nsCOMPtr
<
nsIThread
>
mThread
;
private
:
Atomic
<
bool
>
mThreadRunning
;
}
;
class
SystemClockDriver
:
public
ThreadedDriver
{
public
:
explicit
SystemClockDriver
(
MediaStreamGraphImpl
*
aGraphImpl
)
;
virtual
~
SystemClockDriver
(
)
;
MediaTime
GetIntervalForIteration
(
)
override
;
void
WaitForNextIteration
(
)
override
;
void
WakeUp
(
)
override
;
void
MarkAsFallback
(
)
;
bool
IsFallback
(
)
;
SystemClockDriver
*
AsSystemClockDriver
(
)
override
{
return
this
;
}
private
:
TimeStamp
mInitialTimeStamp
;
TimeStamp
mLastTimeStamp
;
enum
WaitState
{
WAITSTATE_RUNNING
WAITSTATE_WAITING_FOR_NEXT_ITERATION
WAITSTATE_WAITING_INDEFINITELY
WAITSTATE_WAKING_UP
}
;
WaitState
mWaitState
;
bool
mIsFallback
;
}
;
class
OfflineClockDriver
:
public
ThreadedDriver
{
public
:
OfflineClockDriver
(
MediaStreamGraphImpl
*
aGraphImpl
GraphTime
aSlice
)
;
virtual
~
OfflineClockDriver
(
)
;
MediaTime
GetIntervalForIteration
(
)
override
;
void
WaitForNextIteration
(
)
override
;
void
WakeUp
(
)
override
;
TimeStamp
GetCurrentTimeStamp
(
)
override
;
OfflineClockDriver
*
AsOfflineClockDriver
(
)
override
{
return
this
;
}
private
:
GraphTime
mSlice
;
}
;
struct
StreamAndPromiseForOperation
{
StreamAndPromiseForOperation
(
MediaStream
*
aStream
void
*
aPromise
dom
:
:
AudioContextOperation
aOperation
)
;
RefPtr
<
MediaStream
>
mStream
;
void
*
mPromise
;
dom
:
:
AudioContextOperation
mOperation
;
}
;
enum
AsyncCubebOperation
{
INIT
SHUTDOWN
}
;
class
AudioCallbackDriver
:
public
GraphDriver
public
MixerCallbackReceiver
#
if
defined
(
XP_WIN
)
public
audio
:
:
DeviceChangeListener
#
endif
{
public
:
AudioCallbackDriver
(
MediaStreamGraphImpl
*
aGraphImpl
uint32_t
aInputChannelCount
)
;
virtual
~
AudioCallbackDriver
(
)
;
void
Start
(
)
override
;
void
Revive
(
)
override
;
void
WaitForNextIteration
(
)
override
;
void
WakeUp
(
)
override
;
void
Shutdown
(
)
override
;
#
if
defined
(
XP_WIN
)
void
ResetDefaultDevice
(
)
override
;
#
endif
static
long
DataCallback_s
(
cubeb_stream
*
aStream
void
*
aUser
const
void
*
aInputBuffer
void
*
aOutputBuffer
long
aFrames
)
;
static
void
StateCallback_s
(
cubeb_stream
*
aStream
void
*
aUser
cubeb_state
aState
)
;
static
void
DeviceChangedCallback_s
(
void
*
aUser
)
;
long
DataCallback
(
const
AudioDataValue
*
aInputBuffer
AudioDataValue
*
aOutputBuffer
long
aFrames
)
;
void
StateCallback
(
cubeb_state
aState
)
;
uint32_t
IterationDuration
(
)
override
;
void
MixerCallback
(
AudioDataValue
*
aMixedBuffer
AudioSampleFormat
aFormat
uint32_t
aChannels
uint32_t
aFrames
uint32_t
aSampleRate
)
override
;
AudioCallbackDriver
*
AsAudioCallbackDriver
(
)
override
{
return
this
;
}
uint32_t
OutputChannelCount
(
)
{
MOZ_ASSERT
(
mOutputChannels
!
=
0
&
&
mOutputChannels
<
=
8
)
;
return
mOutputChannels
;
}
uint32_t
InputChannelCount
(
)
{
return
mInputChannelCount
;
}
void
EnqueueStreamAndPromiseForOperation
(
MediaStream
*
aStream
void
*
aPromise
dom
:
:
AudioContextOperation
aOperation
)
;
bool
OnThread
(
)
override
{
return
mAudioThreadId
.
load
(
)
=
=
std
:
:
this_thread
:
:
get_id
(
)
;
}
bool
ThreadRunning
(
)
override
{
return
mAudioThreadRunning
;
}
bool
IsStarted
(
)
;
void
CompleteAudioContextOperations
(
AsyncCubebOperation
aOperation
)
;
private
:
void
RemoveMixerCallback
(
)
;
void
AddMixerCallback
(
)
;
void
PanOutputIfNeeded
(
bool
aMicrophoneActive
)
;
void
DeviceChangedCallback
(
)
;
bool
StartStream
(
)
;
friend
class
AsyncCubebTask
;
bool
Init
(
)
;
void
Stop
(
)
;
void
FallbackToSystemClockDriver
(
)
;
bool
OnCubebOperationThread
(
)
{
return
mInitShutdownThread
-
>
IsOnCurrentThreadInfallible
(
)
;
}
uint32_t
mOutputChannels
;
SpillBuffer
<
AudioDataValue
WEBAUDIO_BLOCK_SIZE
*
2
>
mScratchBuffer
;
AudioCallbackBufferWrapper
<
AudioDataValue
>
mBuffer
;
nsAutoRef
<
cubeb_stream
>
mAudioStream
;
uint32_t
mSampleRate
;
const
uint32_t
mInputChannelCount
;
uint32_t
mIterationDurationMS
;
Atomic
<
bool
>
mStarted
;
struct
AutoInCallback
{
explicit
AutoInCallback
(
AudioCallbackDriver
*
aDriver
)
;
~
AutoInCallback
(
)
;
AudioCallbackDriver
*
mDriver
;
}
;
const
RefPtr
<
SharedThreadPool
>
mInitShutdownThread
;
AutoTArray
<
StreamAndPromiseForOperation
1
>
mPromisesForOperation
;
Atomic
<
bool
>
mAddedMixer
;
std
:
:
atomic
<
std
:
:
thread
:
:
id
>
mAudioThreadId
;
Atomic
<
bool
>
mAudioThreadRunning
;
bool
mShouldFallbackIfError
;
bool
mFromFallback
;
}
;
class
AsyncCubebTask
:
public
Runnable
{
public
:
AsyncCubebTask
(
AudioCallbackDriver
*
aDriver
AsyncCubebOperation
aOperation
)
;
nsresult
Dispatch
(
uint32_t
aFlags
=
NS_DISPATCH_NORMAL
)
{
return
mDriver
-
>
mInitShutdownThread
-
>
Dispatch
(
this
aFlags
)
;
}
protected
:
virtual
~
AsyncCubebTask
(
)
;
private
:
NS_IMETHOD
Run
(
)
final
;
RefPtr
<
AudioCallbackDriver
>
mDriver
;
AsyncCubebOperation
mOperation
;
RefPtr
<
MediaStreamGraphImpl
>
mShutdownGrip
;
}
;
}
#
endif
