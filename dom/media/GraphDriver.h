#
ifndef
GRAPHDRIVER_H_
#
define
GRAPHDRIVER_H_
#
include
"
nsAutoRef
.
h
"
#
include
"
AudioBufferUtils
.
h
"
#
include
"
AudioMixer
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
SelfRef
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
dom
/
AudioContext
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
<
thread
>
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
audio
/
AudioNotificationReceiver
.
h
"
#
endif
struct
cubeb_stream
;
template
<
>
class
nsAutoRefTraits
<
cubeb_stream
>
:
public
nsPointerRefTraits
<
cubeb_stream
>
{
public
:
static
void
Release
(
cubeb_stream
*
aStream
)
{
cubeb_stream_destroy
(
aStream
)
;
}
}
;
namespace
mozilla
{
static
const
int
MEDIA_GRAPH_TARGET_PERIOD_MS
=
10
;
static
const
int
SCHEDULE_SAFETY_MARGIN_MS
=
10
;
static
const
int
AUDIO_TARGET_MS
=
2
*
MEDIA_GRAPH_TARGET_PERIOD_MS
+
SCHEDULE_SAFETY_MARGIN_MS
;
class
MediaTrack
;
class
MediaTrackGraphImpl
;
class
AudioCallbackDriver
;
class
OfflineClockDriver
;
class
SystemClockDriver
;
namespace
dom
{
enum
class
AudioContextOperation
;
}
class
GraphDriver
{
public
:
GraphDriver
(
MediaTrackGraphImpl
*
aGraphImpl
uint32_t
aSampleRate
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
GraphDriver
)
;
virtual
void
Start
(
)
=
0
;
MOZ_CAN_RUN_SCRIPT
virtual
void
Shutdown
(
)
=
0
;
virtual
uint32_t
IterationDuration
(
)
=
0
;
virtual
void
EnsureNextIteration
(
)
{
}
bool
Switching
(
)
;
void
SwitchToNextDriver
(
)
;
GraphDriver
*
NextDriver
(
)
;
GraphDriver
*
PreviousDriver
(
)
;
void
SetPreviousDriver
(
GraphDriver
*
aPreviousDriver
)
;
GraphTime
IterationEnd
(
)
{
return
mIterationEnd
;
}
virtual
AudioCallbackDriver
*
AsAudioCallbackDriver
(
)
{
return
nullptr
;
}
virtual
OfflineClockDriver
*
AsOfflineClockDriver
(
)
{
return
nullptr
;
}
virtual
SystemClockDriver
*
AsSystemClockDriver
(
)
{
return
nullptr
;
}
void
SwitchAtNextIteration
(
GraphDriver
*
aDriver
)
;
void
SetState
(
GraphDriver
*
aPreviousDriver
GraphTime
aIterationStart
GraphTime
aIterationEnd
GraphTime
aStateComputedTime
)
;
MediaTrackGraphImpl
*
GraphImpl
(
)
const
{
return
mGraphImpl
;
}
#
ifdef
DEBUG
bool
OnGraphThread
(
)
;
#
endif
virtual
bool
OnThread
(
)
=
0
;
virtual
bool
ThreadRunning
(
)
=
0
;
protected
:
void
SetNextDriver
(
GraphDriver
*
aNextDriver
)
;
GraphTime
mIterationStart
=
0
;
GraphTime
mIterationEnd
=
0
;
GraphTime
mStateComputedTime
=
0
;
const
RefPtr
<
MediaTrackGraphImpl
>
mGraphImpl
;
const
uint32_t
mSampleRate
;
RefPtr
<
GraphDriver
>
mPreviousDriver
;
RefPtr
<
GraphDriver
>
mNextDriver
;
virtual
~
GraphDriver
(
)
=
default
;
}
;
class
MediaTrackGraphInitThreadRunnable
;
class
ThreadedDriver
:
public
GraphDriver
{
class
IterationWaitHelper
{
Monitor
mMonitor
;
bool
mNeedAnotherIteration
=
false
;
TimeStamp
mWakeTime
;
public
:
IterationWaitHelper
(
)
:
mMonitor
(
"
IterationWaitHelper
:
:
mMonitor
"
)
{
}
void
WaitForNextIterationAtLeast
(
TimeDuration
aDuration
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
mWakeTime
=
now
+
aDuration
;
while
(
true
)
{
if
(
mNeedAnotherIteration
&
&
now
>
=
mWakeTime
)
{
break
;
}
if
(
mNeedAnotherIteration
)
{
lock
.
Wait
(
mWakeTime
-
now
)
;
}
else
{
lock
.
Wait
(
TimeDuration
:
:
Forever
(
)
)
;
}
now
=
TimeStamp
:
:
Now
(
)
;
}
mWakeTime
=
TimeStamp
(
)
;
mNeedAnotherIteration
=
false
;
}
void
EnsureNextIteration
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mNeedAnotherIteration
=
true
;
lock
.
Notify
(
)
;
}
}
;
public
:
ThreadedDriver
(
MediaTrackGraphImpl
*
aGraphImpl
uint32_t
aSampleRate
)
;
virtual
~
ThreadedDriver
(
)
;
void
EnsureNextIteration
(
)
override
;
void
Start
(
)
override
;
MOZ_CAN_RUN_SCRIPT
void
Shutdown
(
)
override
;
void
RunThread
(
)
;
friend
class
MediaTrackGraphInitThreadRunnable
;
uint32_t
IterationDuration
(
)
override
{
return
MEDIA_GRAPH_TARGET_PERIOD_MS
;
}
nsIThread
*
Thread
(
)
{
return
mThread
;
}
bool
OnThread
(
)
override
{
return
!
mThread
|
|
mThread
-
>
EventTarget
(
)
-
>
IsOnCurrentThread
(
)
;
}
bool
ThreadRunning
(
)
override
{
return
mThreadRunning
;
}
protected
:
void
WaitForNextIteration
(
)
;
virtual
TimeDuration
WaitInterval
(
)
=
0
;
virtual
MediaTime
GetIntervalForIteration
(
)
=
0
;
nsCOMPtr
<
nsIThread
>
mThread
;
private
:
Atomic
<
bool
>
mThreadRunning
;
IterationWaitHelper
mWaitHelper
;
}
;
enum
class
FallbackMode
{
Regular
Fallback
}
;
class
SystemClockDriver
:
public
ThreadedDriver
{
public
:
SystemClockDriver
(
MediaTrackGraphImpl
*
aGraphImpl
uint32_t
aSampleRate
FallbackMode
aFallback
=
FallbackMode
:
:
Regular
)
;
virtual
~
SystemClockDriver
(
)
;
bool
IsFallback
(
)
;
SystemClockDriver
*
AsSystemClockDriver
(
)
override
{
return
this
;
}
protected
:
TimeDuration
WaitInterval
(
)
override
;
MediaTime
GetIntervalForIteration
(
)
override
;
private
:
TimeStamp
mInitialTimeStamp
;
TimeStamp
mCurrentTimeStamp
;
TimeStamp
mLastTimeStamp
;
const
bool
mIsFallback
;
}
;
class
OfflineClockDriver
:
public
ThreadedDriver
{
public
:
OfflineClockDriver
(
MediaTrackGraphImpl
*
aGraphImpl
uint32_t
aSampleRate
GraphTime
aSlice
)
;
virtual
~
OfflineClockDriver
(
)
;
OfflineClockDriver
*
AsOfflineClockDriver
(
)
override
{
return
this
;
}
protected
:
TimeDuration
WaitInterval
(
)
override
{
return
0
;
}
MediaTime
GetIntervalForIteration
(
)
override
;
private
:
GraphTime
mSlice
;
}
;
struct
TrackAndPromiseForOperation
{
TrackAndPromiseForOperation
(
MediaTrack
*
aTrack
void
*
aPromise
dom
:
:
AudioContextOperation
aOperation
dom
:
:
AudioContextOperationFlags
aFlags
)
;
RefPtr
<
MediaTrack
>
mTrack
;
void
*
mPromise
;
dom
:
:
AudioContextOperation
mOperation
;
dom
:
:
AudioContextOperationFlags
mFlags
;
}
;
enum
class
AsyncCubebOperation
{
INIT
SHUTDOWN
}
;
enum
class
AudioInputType
{
Unknown
Voice
}
;
class
AudioCallbackDriver
:
public
GraphDriver
public
MixerCallbackReceiver
#
if
defined
(
XP_WIN
)
public
audio
:
:
DeviceChangeListener
#
endif
{
public
:
AudioCallbackDriver
(
MediaTrackGraphImpl
*
aGraphImpl
uint32_t
aSampleRate
uint32_t
aOutputChannelCount
uint32_t
aInputChannelCount
CubebUtils
:
:
AudioDeviceID
aOutputDeviceID
CubebUtils
:
:
AudioDeviceID
aInputDeviceID
AudioInputType
aAudioInputType
)
;
virtual
~
AudioCallbackDriver
(
)
;
void
Start
(
)
override
;
MOZ_CAN_RUN_SCRIPT
void
Shutdown
(
)
override
;
#
if
defined
(
XP_WIN
)
void
ResetDefaultDevice
(
)
override
;
#
endif
static
long
DataCallback_s
(
cubeb_stream
*
aStream
void
*
aUser
const
void
*
aInputBuffer
void
*
aOutputBuffer
long
aFrames
)
;
static
void
StateCallback_s
(
cubeb_stream
*
aStream
void
*
aUser
cubeb_state
aState
)
;
static
void
DeviceChangedCallback_s
(
void
*
aUser
)
;
long
DataCallback
(
const
AudioDataValue
*
aInputBuffer
AudioDataValue
*
aOutputBuffer
long
aFrames
)
;
void
StateCallback
(
cubeb_state
aState
)
;
uint32_t
IterationDuration
(
)
override
;
void
MixerCallback
(
AudioDataValue
*
aMixedBuffer
AudioSampleFormat
aFormat
uint32_t
aChannels
uint32_t
aFrames
uint32_t
aSampleRate
)
override
;
AudioCallbackDriver
*
AsAudioCallbackDriver
(
)
override
{
return
this
;
}
uint32_t
OutputChannelCount
(
)
{
MOZ_ASSERT
(
mOutputChannels
!
=
0
&
&
mOutputChannels
<
=
8
)
;
return
mOutputChannels
;
}
uint32_t
InputChannelCount
(
)
{
return
mInputChannelCount
;
}
AudioInputType
InputDevicePreference
(
)
{
if
(
mInputDevicePreference
=
=
CUBEB_DEVICE_PREF_VOICE
)
{
return
AudioInputType
:
:
Voice
;
}
return
AudioInputType
:
:
Unknown
;
}
void
EnqueueTrackAndPromiseForOperation
(
MediaTrack
*
aTrack
void
*
aPromise
dom
:
:
AudioContextOperation
aOperation
dom
:
:
AudioContextOperationFlags
aFlags
)
;
std
:
:
thread
:
:
id
ThreadId
(
)
{
return
mAudioThreadId
.
load
(
)
;
}
bool
OnThread
(
)
override
{
return
mAudioThreadId
.
load
(
)
=
=
std
:
:
this_thread
:
:
get_id
(
)
;
}
bool
ThreadRunning
(
)
override
{
return
mAudioThreadRunning
;
}
bool
IsStarted
(
)
;
void
CompleteAudioContextOperations
(
AsyncCubebOperation
aOperation
)
;
TimeDuration
AudioOutputLatency
(
)
;
private
:
void
PanOutputIfNeeded
(
bool
aMicrophoneActive
)
;
void
DeviceChangedCallback
(
)
;
bool
StartStream
(
)
;
friend
class
AsyncCubebTask
;
bool
Init
(
)
;
void
Stop
(
)
;
void
FallbackToSystemClockDriver
(
)
;
bool
OnCubebOperationThread
(
)
{
return
mInitShutdownThread
-
>
IsOnCurrentThreadInfallible
(
)
;
}
const
uint32_t
mOutputChannels
;
SpillBuffer
<
AudioDataValue
WEBAUDIO_BLOCK_SIZE
*
2
>
mScratchBuffer
;
AudioCallbackBufferWrapper
<
AudioDataValue
>
mBuffer
;
nsAutoRef
<
cubeb_stream
>
mAudioStream
;
const
uint32_t
mInputChannelCount
;
const
CubebUtils
:
:
AudioDeviceID
mOutputDeviceID
;
const
CubebUtils
:
:
AudioDeviceID
mInputDeviceID
;
uint32_t
mIterationDurationMS
;
Atomic
<
bool
>
mStarted
;
struct
AutoInCallback
{
explicit
AutoInCallback
(
AudioCallbackDriver
*
aDriver
)
;
~
AutoInCallback
(
)
;
AudioCallbackDriver
*
mDriver
;
}
;
const
RefPtr
<
SharedThreadPool
>
mInitShutdownThread
;
AutoTArray
<
TrackAndPromiseForOperation
1
>
mPromisesForOperation
;
cubeb_device_pref
mInputDevicePreference
;
AudioMixer
mMixer
;
std
:
:
atomic
<
std
:
:
thread
:
:
id
>
mAudioThreadId
;
Atomic
<
bool
>
mAudioThreadRunning
;
bool
mShouldFallbackIfError
;
bool
mFromFallback
;
#
ifdef
XP_MACOSX
Atomic
<
bool
>
mNeedsPanning
;
#
endif
}
;
class
AsyncCubebTask
:
public
Runnable
{
public
:
AsyncCubebTask
(
AudioCallbackDriver
*
aDriver
AsyncCubebOperation
aOperation
)
;
nsresult
Dispatch
(
uint32_t
aFlags
=
NS_DISPATCH_NORMAL
)
{
return
mDriver
-
>
mInitShutdownThread
-
>
Dispatch
(
this
aFlags
)
;
}
protected
:
virtual
~
AsyncCubebTask
(
)
;
private
:
NS_IMETHOD
Run
(
)
final
;
RefPtr
<
AudioCallbackDriver
>
mDriver
;
AsyncCubebOperation
mOperation
;
RefPtr
<
MediaTrackGraphImpl
>
mShutdownGrip
;
}
;
}
#
endif
