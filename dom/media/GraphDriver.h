#
ifndef
GRAPHDRIVER_H_
#
define
GRAPHDRIVER_H_
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsAutoRef
.
h
"
#
include
"
AudioBufferUtils
.
h
"
#
include
"
AudioMixer
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
SelfRef
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
struct
cubeb_stream
;
template
<
>
class
nsAutoRefTraits
<
cubeb_stream
>
:
public
nsPointerRefTraits
<
cubeb_stream
>
{
public
:
static
void
Release
(
cubeb_stream
*
aStream
)
{
cubeb_stream_destroy
(
aStream
)
;
}
}
;
namespace
mozilla
{
static
const
int
MEDIA_GRAPH_TARGET_PERIOD_MS
=
10
;
static
const
int
SCHEDULE_SAFETY_MARGIN_MS
=
10
;
static
const
int
AUDIO_TARGET_MS
=
2
*
MEDIA_GRAPH_TARGET_PERIOD_MS
+
SCHEDULE_SAFETY_MARGIN_MS
;
class
MediaStreamGraphImpl
;
class
AudioCallbackDriver
;
class
OfflineClockDriver
;
class
GraphDriver
{
public
:
explicit
GraphDriver
(
MediaStreamGraphImpl
*
aGraphImpl
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
GraphDriver
)
;
virtual
void
WaitForNextIteration
(
)
=
0
;
virtual
void
WakeUp
(
)
=
0
;
virtual
void
Destroy
(
)
{
}
virtual
void
Start
(
)
=
0
;
virtual
void
Stop
(
)
=
0
;
virtual
void
Resume
(
)
=
0
;
virtual
void
Revive
(
)
=
0
;
virtual
void
RemoveCallback
(
)
=
0
;
void
Shutdown
(
)
;
virtual
uint32_t
IterationDuration
(
)
=
0
;
bool
Switching
(
)
;
GraphDriver
*
NextDriver
(
)
;
GraphDriver
*
PreviousDriver
(
)
;
void
SetNextDriver
(
GraphDriver
*
aNextDriver
)
;
void
SetPreviousDriver
(
GraphDriver
*
aPreviousDriver
)
;
virtual
TimeStamp
GetCurrentTimeStamp
(
)
{
return
mCurrentTimeStamp
;
}
GraphTime
IterationEnd
(
)
{
return
mIterationEnd
;
}
virtual
AudioCallbackDriver
*
AsAudioCallbackDriver
(
)
{
return
nullptr
;
}
virtual
OfflineClockDriver
*
AsOfflineClockDriver
(
)
{
return
nullptr
;
}
virtual
void
SwitchAtNextIteration
(
GraphDriver
*
aDriver
)
;
void
SetGraphTime
(
GraphDriver
*
aPreviousDriver
GraphTime
aLastSwitchNextIterationStart
GraphTime
aLastSwitchNextIterationEnd
)
;
void
EnsureNextIteration
(
)
;
void
EnsureNextIterationLocked
(
)
;
MediaStreamGraphImpl
*
GraphImpl
(
)
{
return
mGraphImpl
;
}
virtual
bool
OnThread
(
)
=
0
;
virtual
void
SetInputListener
(
AudioDataListener
*
aListener
)
{
mAudioInput
=
aListener
;
}
virtual
void
RemoveInputListener
(
AudioDataListener
*
aListener
)
{
mAudioInput
=
nullptr
;
}
protected
:
GraphTime
StateComputedTime
(
)
const
;
GraphTime
mIterationStart
;
GraphTime
mIterationEnd
;
MediaStreamGraphImpl
*
mGraphImpl
;
enum
WaitState
{
WAITSTATE_RUNNING
WAITSTATE_WAITING_FOR_NEXT_ITERATION
WAITSTATE_WAITING_INDEFINITELY
WAITSTATE_WAKING_UP
}
;
WaitState
mWaitState
;
AudioDataListener
*
mAudioInput
;
TimeStamp
mCurrentTimeStamp
;
RefPtr
<
GraphDriver
>
mPreviousDriver
;
RefPtr
<
GraphDriver
>
mNextDriver
;
virtual
~
GraphDriver
(
)
{
}
}
;
class
MediaStreamGraphInitThreadRunnable
;
class
ThreadedDriver
:
public
GraphDriver
{
public
:
explicit
ThreadedDriver
(
MediaStreamGraphImpl
*
aGraphImpl
)
;
virtual
~
ThreadedDriver
(
)
;
void
Start
(
)
override
;
void
Stop
(
)
override
;
void
Resume
(
)
override
;
void
Revive
(
)
override
;
void
RemoveCallback
(
)
override
;
void
RunThread
(
)
;
friend
class
MediaStreamGraphInitThreadRunnable
;
uint32_t
IterationDuration
(
)
override
{
return
MEDIA_GRAPH_TARGET_PERIOD_MS
;
}
bool
OnThread
(
)
override
{
return
!
mThread
|
|
NS_GetCurrentThread
(
)
=
=
mThread
;
}
virtual
MediaTime
GetIntervalForIteration
(
)
=
0
;
protected
:
nsCOMPtr
<
nsIThread
>
mThread
;
}
;
class
SystemClockDriver
:
public
ThreadedDriver
{
public
:
explicit
SystemClockDriver
(
MediaStreamGraphImpl
*
aGraphImpl
)
;
virtual
~
SystemClockDriver
(
)
;
MediaTime
GetIntervalForIteration
(
)
override
;
void
WaitForNextIteration
(
)
override
;
void
WakeUp
(
)
override
;
private
:
TimeStamp
mInitialTimeStamp
;
TimeStamp
mLastTimeStamp
;
}
;
class
OfflineClockDriver
:
public
ThreadedDriver
{
public
:
OfflineClockDriver
(
MediaStreamGraphImpl
*
aGraphImpl
GraphTime
aSlice
)
;
virtual
~
OfflineClockDriver
(
)
;
MediaTime
GetIntervalForIteration
(
)
override
;
void
WaitForNextIteration
(
)
override
;
void
WakeUp
(
)
override
;
TimeStamp
GetCurrentTimeStamp
(
)
override
;
OfflineClockDriver
*
AsOfflineClockDriver
(
)
override
{
return
this
;
}
private
:
GraphTime
mSlice
;
}
;
struct
StreamAndPromiseForOperation
{
StreamAndPromiseForOperation
(
MediaStream
*
aStream
void
*
aPromise
dom
:
:
AudioContextOperation
aOperation
)
;
RefPtr
<
MediaStream
>
mStream
;
void
*
mPromise
;
dom
:
:
AudioContextOperation
mOperation
;
}
;
enum
AsyncCubebOperation
{
INIT
SHUTDOWN
}
;
class
AudioCallbackDriver
:
public
GraphDriver
public
MixerCallbackReceiver
{
public
:
explicit
AudioCallbackDriver
(
MediaStreamGraphImpl
*
aGraphImpl
)
;
virtual
~
AudioCallbackDriver
(
)
;
void
Destroy
(
)
override
;
void
Start
(
)
override
;
void
Stop
(
)
override
;
void
Resume
(
)
override
;
void
Revive
(
)
override
;
void
RemoveCallback
(
)
override
;
void
WaitForNextIteration
(
)
override
;
void
WakeUp
(
)
override
;
static
long
DataCallback_s
(
cubeb_stream
*
aStream
void
*
aUser
void
*
aInputBuffer
void
*
aOutputBuffer
long
aFrames
)
;
static
void
StateCallback_s
(
cubeb_stream
*
aStream
void
*
aUser
cubeb_state
aState
)
;
static
void
DeviceChangedCallback_s
(
void
*
aUser
)
;
long
DataCallback
(
AudioDataValue
*
aInputBuffer
AudioDataValue
*
aOutputBuffer
long
aFrames
)
;
void
StateCallback
(
cubeb_state
aState
)
;
uint32_t
IterationDuration
(
)
override
;
void
MixerCallback
(
AudioDataValue
*
aMixedBuffer
AudioSampleFormat
aFormat
uint32_t
aChannels
uint32_t
aFrames
uint32_t
aSampleRate
)
override
;
AudioCallbackDriver
*
AsAudioCallbackDriver
(
)
override
{
return
this
;
}
void
EnqueueStreamAndPromiseForOperation
(
MediaStream
*
aStream
void
*
aPromise
dom
:
:
AudioContextOperation
aOperation
)
;
bool
IsSwitchingDevice
(
)
{
#
ifdef
XP_MACOSX
return
mSelfReference
;
#
else
return
false
;
#
endif
}
bool
InCallback
(
)
;
bool
OnThread
(
)
override
{
return
!
mStarted
|
|
InCallback
(
)
;
}
bool
IsStarted
(
)
;
void
SetMicrophoneActive
(
bool
aActive
)
;
void
CompleteAudioContextOperations
(
AsyncCubebOperation
aOperation
)
;
private
:
void
PanOutputIfNeeded
(
bool
aMicrophoneActive
)
;
void
DeviceChangedCallback
(
)
;
void
StartStream
(
)
;
friend
class
AsyncCubebTask
;
void
Init
(
)
;
static
const
uint32_t
ChannelCount
=
2
;
SpillBuffer
<
AudioDataValue
WEBAUDIO_BLOCK_SIZE
*
2
ChannelCount
>
mScratchBuffer
;
AudioCallbackBufferWrapper
<
AudioDataValue
ChannelCount
>
mBuffer
;
nsAutoRef
<
cubeb_stream
>
mAudioStream
;
uint32_t
mSampleRate
;
uint32_t
mIterationDurationMS
;
bool
mStarted
;
RefPtr
<
AudioDataListener
>
mAudioInput
;
struct
AutoInCallback
{
explicit
AutoInCallback
(
AudioCallbackDriver
*
aDriver
)
;
~
AutoInCallback
(
)
;
AudioCallbackDriver
*
mDriver
;
}
;
nsCOMPtr
<
nsIThread
>
mInitShutdownThread
;
nsAutoTArray
<
StreamAndPromiseForOperation
1
>
mPromisesForOperation
;
dom
:
:
AudioChannel
mAudioChannel
;
bool
mAddedMixer
;
Atomic
<
bool
>
mInCallback
;
bool
mMicrophoneActive
;
#
ifdef
XP_MACOSX
bool
OSXDeviceSwitchingWorkaround
(
)
;
SelfReference
<
AudioCallbackDriver
>
mSelfReference
;
uint32_t
mCallbackReceivedWhileSwitching
;
#
endif
}
;
class
AsyncCubebTask
:
public
nsRunnable
{
public
:
AsyncCubebTask
(
AudioCallbackDriver
*
aDriver
AsyncCubebOperation
aOperation
)
;
nsresult
Dispatch
(
)
{
nsresult
rv
=
EnsureThread
(
)
;
if
(
!
NS_FAILED
(
rv
)
)
{
rv
=
sThreadPool
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
}
return
rv
;
}
protected
:
virtual
~
AsyncCubebTask
(
)
;
private
:
static
nsresult
EnsureThread
(
)
;
NS_IMETHOD
Run
(
)
override
final
;
static
StaticRefPtr
<
nsIThreadPool
>
sThreadPool
;
RefPtr
<
AudioCallbackDriver
>
mDriver
;
AsyncCubebOperation
mOperation
;
RefPtr
<
MediaStreamGraphImpl
>
mShutdownGrip
;
}
;
}
#
endif
