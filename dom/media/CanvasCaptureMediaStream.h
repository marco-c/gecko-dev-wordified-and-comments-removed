#
ifndef
mozilla_dom_CanvasCaptureMediaStream_h_
#
define
mozilla_dom_CanvasCaptureMediaStream_h_
#
include
"
DOMMediaStream
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCanvasElement
.
h
"
#
include
"
StreamBuffer
.
h
"
namespace
mozilla
{
class
DOMMediaStream
;
class
MediaStreamListener
;
class
SourceMediaStream
;
namespace
layers
{
class
Image
;
}
namespace
dom
{
class
CanvasCaptureMediaStream
;
class
HTMLCanvasElement
;
class
OutputStreamFrameListener
;
class
OutputStreamDriver
:
public
FrameCaptureListener
{
public
:
OutputStreamDriver
(
SourceMediaStream
*
aSourceStream
const
TrackID
&
aTrackId
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
OutputStreamDriver
)
;
void
SetImage
(
const
nsRefPtr
<
layers
:
:
Image
>
&
aImage
)
;
virtual
void
Forget
(
)
{
}
protected
:
virtual
~
OutputStreamDriver
(
)
;
class
StreamListener
;
private
:
nsRefPtr
<
SourceMediaStream
>
mSourceStream
;
nsRefPtr
<
StreamListener
>
mStreamListener
;
}
;
class
CanvasCaptureMediaStream
:
public
DOMMediaStream
{
public
:
explicit
CanvasCaptureMediaStream
(
HTMLCanvasElement
*
aCanvas
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
CanvasCaptureMediaStream
DOMMediaStream
)
nsresult
Init
(
const
dom
:
:
Optional
<
double
>
&
aFPS
const
TrackID
&
aTrackId
)
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
HTMLCanvasElement
*
Canvas
(
)
const
{
return
mCanvas
;
}
void
RequestFrame
(
)
;
dom
:
:
FrameCaptureListener
*
FrameCaptureListener
(
)
;
static
already_AddRefed
<
CanvasCaptureMediaStream
>
CreateSourceStream
(
nsIDOMWindow
*
aWindow
HTMLCanvasElement
*
aCanvas
)
;
protected
:
~
CanvasCaptureMediaStream
(
)
;
private
:
nsRefPtr
<
HTMLCanvasElement
>
mCanvas
;
nsRefPtr
<
OutputStreamDriver
>
mOutputStreamDriver
;
}
;
}
}
#
endif
