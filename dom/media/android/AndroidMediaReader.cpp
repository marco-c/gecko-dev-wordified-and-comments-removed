#
include
"
AndroidMediaReader
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
MediaResource
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
AndroidMediaDecoder
.
h
"
#
include
"
AndroidMediaPluginHost
.
h
"
#
include
"
MediaDecoderStateMachine
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
AbstractMediaDecoder
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
VideoFrameContainer
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
namespace
mozilla
{
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
media
;
typedef
mozilla
:
:
layers
:
:
Image
Image
;
typedef
mozilla
:
:
layers
:
:
PlanarYCbCrImage
PlanarYCbCrImage
;
AndroidMediaReader
:
:
AndroidMediaReader
(
AbstractMediaDecoder
*
aDecoder
const
MediaContainerType
&
aContainerType
)
:
MediaDecoderReader
(
aDecoder
)
mType
(
aContainerType
)
mPlugin
(
nullptr
)
mHasAudio
(
false
)
mHasVideo
(
false
)
mVideoSeekTimeUs
(
-
1
)
mAudioSeekTimeUs
(
-
1
)
{
}
nsresult
AndroidMediaReader
:
:
ReadMetadata
(
MediaInfo
*
aInfo
MetadataTags
*
*
aTags
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
!
mPlugin
)
{
mPlugin
=
GetAndroidMediaPluginHost
(
)
-
>
CreateDecoder
(
mDecoder
-
>
GetResource
(
)
mType
)
;
if
(
!
mPlugin
)
{
return
NS_ERROR_FAILURE
;
}
}
int64_t
durationUs
;
mPlugin
-
>
GetDuration
(
mPlugin
&
durationUs
)
;
if
(
durationUs
)
{
mInfo
.
mMetadataDuration
.
emplace
(
TimeUnit
:
:
FromMicroseconds
(
durationUs
)
)
;
}
if
(
mPlugin
-
>
HasVideo
(
mPlugin
)
)
{
int32_t
width
height
;
mPlugin
-
>
GetVideoParameters
(
mPlugin
&
width
&
height
)
;
nsIntRect
pictureRect
(
0
0
width
height
)
;
nsIntSize
displaySize
(
width
height
)
;
nsIntSize
frameSize
(
width
height
)
;
if
(
!
IsValidVideoRegion
(
frameSize
pictureRect
displaySize
)
)
{
return
NS_ERROR_FAILURE
;
}
mHasVideo
=
true
;
mInfo
.
mVideo
.
mDisplay
=
displaySize
;
mPicture
=
pictureRect
;
mInitialFrame
=
frameSize
;
VideoFrameContainer
*
container
=
mDecoder
-
>
GetVideoFrameContainer
(
)
;
if
(
container
)
{
container
-
>
ClearCurrentFrame
(
IntSize
(
displaySize
.
width
displaySize
.
height
)
)
;
}
}
if
(
mPlugin
-
>
HasAudio
(
mPlugin
)
)
{
int32_t
numChannels
sampleRate
;
mPlugin
-
>
GetAudioParameters
(
mPlugin
&
numChannels
&
sampleRate
)
;
mHasAudio
=
true
;
mInfo
.
mAudio
.
mChannels
=
numChannels
;
mInfo
.
mAudio
.
mRate
=
sampleRate
;
}
*
aInfo
=
mInfo
;
*
aTags
=
nullptr
;
return
NS_OK
;
}
RefPtr
<
ShutdownPromise
>
AndroidMediaReader
:
:
Shutdown
(
)
{
ResetDecode
(
)
;
if
(
mPlugin
)
{
GetAndroidMediaPluginHost
(
)
-
>
DestroyDecoder
(
mPlugin
)
;
mPlugin
=
nullptr
;
}
return
MediaDecoderReader
:
:
Shutdown
(
)
;
}
nsresult
AndroidMediaReader
:
:
ResetDecode
(
TrackSet
aTracks
)
{
if
(
mLastVideoFrame
)
{
mLastVideoFrame
=
nullptr
;
}
mSeekRequest
.
DisconnectIfExists
(
)
;
mSeekPromise
.
RejectIfExists
(
NS_OK
__func__
)
;
return
MediaDecoderReader
:
:
ResetDecode
(
aTracks
)
;
}
bool
AndroidMediaReader
:
:
DecodeVideoFrame
(
bool
&
aKeyframeSkip
const
media
:
:
TimeUnit
&
aTimeThreshold
)
{
AbstractMediaDecoder
:
:
AutoNotifyDecoded
a
(
mDecoder
)
;
if
(
mLastVideoFrame
&
&
mVideoSeekTimeUs
!
=
-
1
)
{
mLastVideoFrame
=
nullptr
;
}
ImageBufferCallback
bufferCallback
(
mDecoder
-
>
GetImageContainer
(
)
)
;
RefPtr
<
Image
>
currentImage
;
while
(
true
)
{
MPAPI
:
:
VideoFrame
frame
;
if
(
!
mPlugin
-
>
ReadVideo
(
mPlugin
&
frame
mVideoSeekTimeUs
&
bufferCallback
)
)
{
if
(
mLastVideoFrame
)
{
int64_t
durationUs
;
mPlugin
-
>
GetDuration
(
mPlugin
&
durationUs
)
;
durationUs
=
std
:
:
max
<
int64_t
>
(
durationUs
-
mLastVideoFrame
-
>
mTime
0
)
;
mLastVideoFrame
-
>
UpdateDuration
(
TimeUnit
:
:
FromMicroseconds
(
durationUs
)
)
;
mVideoQueue
.
Push
(
mLastVideoFrame
)
;
mLastVideoFrame
=
nullptr
;
}
return
false
;
}
mVideoSeekTimeUs
=
-
1
;
if
(
aKeyframeSkip
)
{
#
if
0
if
(
!
frame
.
mKeyFrame
)
{
+
+
a
.
mStats
.
mParsedFrames
;
+
+
a
.
mStats
.
mDroppedFrames
;
continue
;
}
#
endif
aKeyframeSkip
=
false
;
}
if
(
frame
.
mSize
=
=
0
)
return
true
;
currentImage
=
bufferCallback
.
GetImage
(
)
;
int64_t
pos
=
mDecoder
-
>
GetResource
(
)
-
>
Tell
(
)
;
IntRect
picture
=
mPicture
;
RefPtr
<
VideoData
>
v
;
if
(
currentImage
)
{
v
=
VideoData
:
:
CreateFromImage
(
mInfo
.
mVideo
.
mDisplay
pos
frame
.
mTimeUs
TimeUnit
:
:
FromMicroseconds
(
1
)
currentImage
frame
.
mKeyFrame
-
1
)
;
}
else
{
VideoData
:
:
YCbCrBuffer
b
;
b
.
mPlanes
[
0
]
.
mData
=
static_cast
<
uint8_t
*
>
(
frame
.
Y
.
mData
)
;
b
.
mPlanes
[
0
]
.
mStride
=
frame
.
Y
.
mStride
;
b
.
mPlanes
[
0
]
.
mHeight
=
frame
.
Y
.
mHeight
;
b
.
mPlanes
[
0
]
.
mWidth
=
frame
.
Y
.
mWidth
;
b
.
mPlanes
[
0
]
.
mOffset
=
frame
.
Y
.
mOffset
;
b
.
mPlanes
[
0
]
.
mSkip
=
frame
.
Y
.
mSkip
;
b
.
mPlanes
[
1
]
.
mData
=
static_cast
<
uint8_t
*
>
(
frame
.
Cb
.
mData
)
;
b
.
mPlanes
[
1
]
.
mStride
=
frame
.
Cb
.
mStride
;
b
.
mPlanes
[
1
]
.
mHeight
=
frame
.
Cb
.
mHeight
;
b
.
mPlanes
[
1
]
.
mWidth
=
frame
.
Cb
.
mWidth
;
b
.
mPlanes
[
1
]
.
mOffset
=
frame
.
Cb
.
mOffset
;
b
.
mPlanes
[
1
]
.
mSkip
=
frame
.
Cb
.
mSkip
;
b
.
mPlanes
[
2
]
.
mData
=
static_cast
<
uint8_t
*
>
(
frame
.
Cr
.
mData
)
;
b
.
mPlanes
[
2
]
.
mStride
=
frame
.
Cr
.
mStride
;
b
.
mPlanes
[
2
]
.
mHeight
=
frame
.
Cr
.
mHeight
;
b
.
mPlanes
[
2
]
.
mWidth
=
frame
.
Cr
.
mWidth
;
b
.
mPlanes
[
2
]
.
mOffset
=
frame
.
Cr
.
mOffset
;
b
.
mPlanes
[
2
]
.
mSkip
=
frame
.
Cr
.
mSkip
;
if
(
frame
.
Y
.
mWidth
!
=
mInitialFrame
.
width
|
|
frame
.
Y
.
mHeight
!
=
mInitialFrame
.
height
)
{
picture
.
x
=
(
mPicture
.
x
*
frame
.
Y
.
mWidth
)
/
mInitialFrame
.
width
;
picture
.
y
=
(
mPicture
.
y
*
frame
.
Y
.
mHeight
)
/
mInitialFrame
.
height
;
picture
.
width
=
(
frame
.
Y
.
mWidth
*
mPicture
.
width
)
/
mInitialFrame
.
width
;
picture
.
height
=
(
frame
.
Y
.
mHeight
*
mPicture
.
height
)
/
mInitialFrame
.
height
;
}
v
=
VideoData
:
:
CreateAndCopyData
(
mInfo
.
mVideo
mDecoder
-
>
GetImageContainer
(
)
pos
frame
.
mTimeUs
TimeUnit
:
:
FromMicroseconds
(
1
)
b
frame
.
mKeyFrame
-
1
picture
)
;
}
if
(
!
v
)
{
return
false
;
}
a
.
mStats
.
mParsedFrames
+
+
;
a
.
mStats
.
mDecodedFrames
+
+
;
NS_ASSERTION
(
a
.
mStats
.
mDecodedFrames
<
=
a
.
mStats
.
mParsedFrames
"
Expect
to
decode
fewer
frames
than
parsed
in
AndroidMedia
.
.
.
"
)
;
if
(
!
mLastVideoFrame
)
{
mLastVideoFrame
=
v
;
continue
;
}
int64_t
duration
=
v
-
>
mTime
-
mLastVideoFrame
-
>
mTime
;
mLastVideoFrame
-
>
UpdateDuration
(
TimeUnit
:
:
FromMicroseconds
(
duration
)
)
;
if
(
mLastVideoFrame
-
>
GetEndTime
(
)
<
aTimeThreshold
.
ToMicroseconds
(
)
)
{
mLastVideoFrame
=
nullptr
;
continue
;
}
mVideoQueue
.
Push
(
mLastVideoFrame
)
;
mLastVideoFrame
=
v
;
break
;
}
return
true
;
}
bool
AndroidMediaReader
:
:
DecodeAudioData
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
int64_t
pos
=
mDecoder
-
>
GetResource
(
)
-
>
Tell
(
)
;
MPAPI
:
:
AudioFrame
source
;
if
(
!
mPlugin
-
>
ReadAudio
(
mPlugin
&
source
mAudioSeekTimeUs
)
)
{
return
false
;
}
mAudioSeekTimeUs
=
-
1
;
if
(
source
.
mSize
=
=
0
)
return
true
;
uint32_t
frames
=
source
.
mSize
/
(
source
.
mAudioChannels
*
sizeof
(
AudioDataValue
)
)
;
typedef
AudioCompactor
:
:
NativeCopy
MPCopy
;
return
mAudioCompactor
.
Push
(
pos
source
.
mTimeUs
source
.
mAudioSampleRate
frames
source
.
mAudioChannels
MPCopy
(
static_cast
<
uint8_t
*
>
(
source
.
mData
)
source
.
mSize
source
.
mAudioChannels
)
)
;
}
RefPtr
<
MediaDecoderReader
:
:
SeekPromise
>
AndroidMediaReader
:
:
Seek
(
const
SeekTarget
&
aTarget
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
RefPtr
<
SeekPromise
>
p
=
mSeekPromise
.
Ensure
(
__func__
)
;
if
(
mHasAudio
&
&
mHasVideo
)
{
mVideoSeekTimeUs
=
aTarget
.
GetTime
(
)
.
ToMicroseconds
(
)
;
RefPtr
<
AndroidMediaReader
>
self
=
this
;
DecodeToFirstVideoData
(
)
-
>
Then
(
OwnerThread
(
)
__func__
[
self
]
(
MediaData
*
v
)
{
self
-
>
mSeekRequest
.
Complete
(
)
;
self
-
>
mAudioSeekTimeUs
=
v
-
>
mTime
;
self
-
>
mSeekPromise
.
Resolve
(
media
:
:
TimeUnit
:
:
FromMicroseconds
(
self
-
>
mAudioSeekTimeUs
)
__func__
)
;
}
[
self
aTarget
]
(
)
{
self
-
>
mSeekRequest
.
Complete
(
)
;
self
-
>
mAudioSeekTimeUs
=
aTarget
.
GetTime
(
)
.
ToMicroseconds
(
)
;
self
-
>
mSeekPromise
.
Resolve
(
aTarget
.
GetTime
(
)
__func__
)
;
}
)
-
>
Track
(
mSeekRequest
)
;
}
else
{
mAudioSeekTimeUs
=
mVideoSeekTimeUs
=
aTarget
.
GetTime
(
)
.
ToMicroseconds
(
)
;
mSeekPromise
.
Resolve
(
aTarget
.
GetTime
(
)
__func__
)
;
}
return
p
;
}
AndroidMediaReader
:
:
ImageBufferCallback
:
:
ImageBufferCallback
(
mozilla
:
:
layers
:
:
ImageContainer
*
aImageContainer
)
:
mImageContainer
(
aImageContainer
)
{
}
void
*
AndroidMediaReader
:
:
ImageBufferCallback
:
:
operator
(
)
(
size_t
aWidth
size_t
aHeight
MPAPI
:
:
ColorFormat
aColorFormat
)
{
if
(
!
mImageContainer
)
{
NS_WARNING
(
"
No
image
container
to
construct
an
image
"
)
;
return
nullptr
;
}
RefPtr
<
Image
>
image
;
switch
(
aColorFormat
)
{
case
MPAPI
:
:
RGB565
:
image
=
mozilla
:
:
layers
:
:
CreateSharedRGBImage
(
mImageContainer
nsIntSize
(
aWidth
aHeight
)
SurfaceFormat
:
:
R5G6B5_UINT16
)
;
if
(
!
image
)
{
NS_WARNING
(
"
Could
not
create
rgb
image
"
)
;
return
nullptr
;
}
mImage
=
image
;
return
image
-
>
GetBuffer
(
)
;
case
MPAPI
:
:
I420
:
return
CreateI420Image
(
aWidth
aHeight
)
;
default
:
NS_NOTREACHED
(
"
Color
format
not
supported
"
)
;
return
nullptr
;
}
}
uint8_t
*
AndroidMediaReader
:
:
ImageBufferCallback
:
:
CreateI420Image
(
size_t
aWidth
size_t
aHeight
)
{
RefPtr
<
PlanarYCbCrImage
>
yuvImage
=
mImageContainer
-
>
CreatePlanarYCbCrImage
(
)
;
mImage
=
yuvImage
;
if
(
!
yuvImage
)
{
NS_WARNING
(
"
Could
not
create
I420
image
"
)
;
return
nullptr
;
}
const
auto
checkedFrameSize
=
CheckedInt
<
uint32_t
>
(
aWidth
)
*
aHeight
;
const
auto
checkedBufferSize
=
checkedFrameSize
+
checkedFrameSize
/
2
;
if
(
!
checkedBufferSize
.
isValid
(
)
)
{
NS_WARNING
(
"
Could
not
create
I420
image
"
)
;
return
nullptr
;
}
const
auto
frameSize
=
checkedFrameSize
.
value
(
)
;
uint8_t
*
buffer
=
yuvImage
-
>
AllocateAndGetNewBuffer
(
checkedBufferSize
.
value
(
)
)
;
mozilla
:
:
layers
:
:
PlanarYCbCrData
frameDesc
;
frameDesc
.
mYChannel
=
buffer
;
frameDesc
.
mCbChannel
=
buffer
+
frameSize
;
frameDesc
.
mCrChannel
=
frameDesc
.
mCbChannel
+
frameSize
/
4
;
frameDesc
.
mYSize
=
IntSize
(
aWidth
aHeight
)
;
frameDesc
.
mCbCrSize
=
IntSize
(
aWidth
/
2
aHeight
/
2
)
;
frameDesc
.
mYStride
=
aWidth
;
frameDesc
.
mCbCrStride
=
aWidth
/
2
;
frameDesc
.
mYSkip
=
0
;
frameDesc
.
mCbSkip
=
0
;
frameDesc
.
mCrSkip
=
0
;
frameDesc
.
mPicX
=
0
;
frameDesc
.
mPicY
=
0
;
frameDesc
.
mPicSize
=
IntSize
(
aWidth
aHeight
)
;
yuvImage
-
>
AdoptData
(
frameDesc
)
;
return
buffer
;
}
already_AddRefed
<
Image
>
AndroidMediaReader
:
:
ImageBufferCallback
:
:
GetImage
(
)
{
return
mImage
.
forget
(
)
;
}
}
