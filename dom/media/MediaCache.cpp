#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
MediaCache
.
h
"
#
include
"
prio
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
MediaResource
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
FileBlockCache
.
h
"
#
include
"
MediaBlockCacheBase
.
h
"
#
include
"
MemoryBlockCache
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
#
undef
LOG
#
undef
LOGI
LazyLogModule
gMediaCacheLog
(
"
MediaCache
"
)
;
#
define
LOG
(
.
.
.
)
MOZ_LOG
(
gMediaCacheLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
define
LOGI
(
.
.
.
)
MOZ_LOG
(
gMediaCacheLog
LogLevel
:
:
Info
(
__VA_ARGS__
)
)
static
const
double
NONSEEKABLE_READAHEAD_MAX
=
0
.
5
;
static
const
uint32_t
REPLAY_PENALTY_FACTOR
=
3
;
static
const
uint32_t
FREE_BLOCK_SCAN_LIMIT
=
16
;
#
ifdef
DEBUG
#
endif
class
MediaCacheFlusher
final
:
public
nsIObserver
public
nsSupportsWeakReference
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
static
void
RegisterMediaCache
(
MediaCache
*
aMediaCache
)
;
static
void
UnregisterMediaCache
(
MediaCache
*
aMediaCache
)
;
private
:
MediaCacheFlusher
(
)
{
}
~
MediaCacheFlusher
(
)
{
}
static
StaticRefPtr
<
MediaCacheFlusher
>
gMediaCacheFlusher
;
nsTArray
<
MediaCache
*
>
mMediaCaches
;
}
;
StaticRefPtr
<
MediaCacheFlusher
>
MediaCacheFlusher
:
:
gMediaCacheFlusher
;
NS_IMPL_ISUPPORTS
(
MediaCacheFlusher
nsIObserver
nsISupportsWeakReference
)
void
MediaCacheFlusher
:
:
RegisterMediaCache
(
MediaCache
*
aMediaCache
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
!
gMediaCacheFlusher
)
{
gMediaCacheFlusher
=
new
MediaCacheFlusher
(
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
AddObserver
(
gMediaCacheFlusher
"
last
-
pb
-
context
-
exited
"
true
)
;
observerService
-
>
AddObserver
(
gMediaCacheFlusher
"
cacheservice
:
empty
-
cache
"
true
)
;
}
}
gMediaCacheFlusher
-
>
mMediaCaches
.
AppendElement
(
aMediaCache
)
;
}
void
MediaCacheFlusher
:
:
UnregisterMediaCache
(
MediaCache
*
aMediaCache
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
gMediaCacheFlusher
-
>
mMediaCaches
.
RemoveElement
(
aMediaCache
)
;
if
(
gMediaCacheFlusher
-
>
mMediaCaches
.
Length
(
)
=
=
0
)
{
gMediaCacheFlusher
=
nullptr
;
}
}
class
MediaCache
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaCache
)
friend
class
MediaCacheStream
:
:
BlockList
;
typedef
MediaCacheStream
:
:
BlockList
BlockList
;
static
const
int64_t
BLOCK_SIZE
=
MediaCacheStream
:
:
BLOCK_SIZE
;
static
RefPtr
<
MediaCache
>
GetMediaCache
(
int64_t
aContentLength
)
;
void
Flush
(
)
;
void
CloseStreamsForPrivateBrowsing
(
)
;
nsresult
ReadCacheFile
(
int64_t
aOffset
void
*
aData
int32_t
aLength
int32_t
*
aBytes
)
;
int64_t
AllocateResourceID
(
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
return
mNextResourceID
+
+
;
}
void
OpenStream
(
MediaCacheStream
*
aStream
)
;
void
ReleaseStream
(
MediaCacheStream
*
aStream
)
;
void
ReleaseStreamBlocks
(
MediaCacheStream
*
aStream
)
;
void
AllocateAndWriteBlock
(
MediaCacheStream
*
aStream
MediaCacheStream
:
:
ReadMode
aMode
Span
<
const
uint8_t
>
aData1
Span
<
const
uint8_t
>
aData2
=
Span
<
const
uint8_t
>
(
)
)
;
void
NoteSeek
(
MediaCacheStream
*
aStream
int64_t
aOldOffset
)
;
void
NoteBlockUsage
(
MediaCacheStream
*
aStream
int32_t
aBlockIndex
int64_t
aStreamOffset
MediaCacheStream
:
:
ReadMode
aMode
TimeStamp
aNow
)
;
void
AddBlockOwnerAsReadahead
(
int32_t
aBlockIndex
MediaCacheStream
*
aStream
int32_t
aStreamBlockIndex
)
;
void
QueueUpdate
(
)
;
void
QueueSuspendedStatusUpdate
(
int64_t
aResourceID
)
;
void
Update
(
)
;
#
ifdef
DEBUG_VERIFY_CACHE
void
Verify
(
)
;
#
else
void
Verify
(
)
{
}
#
endif
ReentrantMonitor
&
GetReentrantMonitor
(
)
{
return
mReentrantMonitor
;
}
class
ResourceStreamIterator
{
public
:
ResourceStreamIterator
(
MediaCache
*
aMediaCache
int64_t
aResourceID
)
:
mMediaCache
(
aMediaCache
)
mResourceID
(
aResourceID
)
mNext
(
0
)
{
}
MediaCacheStream
*
Next
(
)
{
while
(
mNext
<
mMediaCache
-
>
mStreams
.
Length
(
)
)
{
MediaCacheStream
*
stream
=
mMediaCache
-
>
mStreams
[
mNext
]
;
+
+
mNext
;
if
(
stream
-
>
GetResourceID
(
)
=
=
mResourceID
&
&
!
stream
-
>
IsClosed
(
)
)
return
stream
;
}
return
nullptr
;
}
private
:
MediaCache
*
mMediaCache
;
int64_t
mResourceID
;
uint32_t
mNext
;
}
;
protected
:
explicit
MediaCache
(
MediaBlockCacheBase
*
aCache
)
:
mNextResourceID
(
1
)
mReentrantMonitor
(
"
MediaCache
.
mReentrantMonitor
"
)
mBlockCache
(
aCache
)
mUpdateQueued
(
false
)
#
ifdef
DEBUG
mInUpdate
(
false
)
#
endif
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
construct
MediaCache
on
main
thread
"
)
;
MOZ_COUNT_CTOR
(
MediaCache
)
;
MediaCacheFlusher
:
:
RegisterMediaCache
(
this
)
;
}
~
MediaCache
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
destroy
MediaCache
on
main
thread
"
)
;
if
(
this
=
=
gMediaCache
)
{
LOG
(
"
~
MediaCache
(
Global
file
-
backed
MediaCache
)
"
)
;
gMediaCache
=
nullptr
;
LOG
(
"
MediaCache
:
:
~
MediaCache
(
this
=
%
p
)
MEDIACACHE_WATERMARK_KB
=
%
u
"
this
unsigned
(
mIndexWatermark
*
MediaCache
:
:
BLOCK_SIZE
/
1024
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HistogramID
:
:
MEDIACACHE_WATERMARK_KB
uint32_t
(
mIndexWatermark
*
MediaCache
:
:
BLOCK_SIZE
/
1024
)
)
;
LOG
(
"
MediaCache
:
:
~
MediaCache
(
this
=
%
p
)
MEDIACACHE_BLOCKOWNERS_WATERMARK
=
%
u
"
this
unsigned
(
mBlockOwnersWatermark
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HistogramID
:
:
MEDIACACHE_BLOCKOWNERS_WATERMARK
mBlockOwnersWatermark
)
;
}
else
{
LOG
(
"
~
MediaCache
(
Memory
-
backed
MediaCache
%
p
)
"
this
)
;
}
MediaCacheFlusher
:
:
UnregisterMediaCache
(
this
)
;
NS_ASSERTION
(
mStreams
.
IsEmpty
(
)
"
Stream
(
s
)
still
open
!
"
)
;
Truncate
(
)
;
NS_ASSERTION
(
mIndex
.
Length
(
)
=
=
0
"
Blocks
leaked
?
"
)
;
MOZ_COUNT_DTOR
(
MediaCache
)
;
}
int32_t
FindBlockForIncomingData
(
TimeStamp
aNow
MediaCacheStream
*
aStream
)
;
int32_t
FindReusableBlock
(
TimeStamp
aNow
MediaCacheStream
*
aForStream
int32_t
aForStreamBlock
int32_t
aMaxSearchBlockIndex
)
;
bool
BlockIsReusable
(
int32_t
aBlockIndex
)
;
void
AppendMostReusableBlock
(
BlockList
*
aBlockList
nsTArray
<
uint32_t
>
*
aResult
int32_t
aBlockIndexLimit
)
;
enum
BlockClass
{
METADATA_BLOCK
PLAYED_BLOCK
READAHEAD_BLOCK
}
;
struct
BlockOwner
{
constexpr
BlockOwner
(
)
{
}
MediaCacheStream
*
mStream
=
nullptr
;
uint32_t
mStreamBlock
=
UINT32_MAX
;
TimeStamp
mLastUseTime
;
BlockClass
mClass
=
READAHEAD_BLOCK
;
}
;
struct
Block
{
nsTArray
<
BlockOwner
>
mOwners
;
}
;
BlockList
*
GetListForBlock
(
BlockOwner
*
aBlock
)
;
BlockOwner
*
GetBlockOwner
(
int32_t
aBlockIndex
MediaCacheStream
*
aStream
)
;
bool
IsBlockFree
(
int32_t
aBlockIndex
)
{
return
mIndex
[
aBlockIndex
]
.
mOwners
.
IsEmpty
(
)
;
}
void
FreeBlock
(
int32_t
aBlock
)
;
void
RemoveBlockOwner
(
int32_t
aBlockIndex
MediaCacheStream
*
aStream
)
;
void
SwapBlocks
(
int32_t
aBlockIndex1
int32_t
aBlockIndex2
)
;
void
InsertReadaheadBlock
(
BlockOwner
*
aBlockOwner
int32_t
aBlockIndex
)
;
TimeDuration
PredictNextUse
(
TimeStamp
aNow
int32_t
aBlock
)
;
TimeDuration
PredictNextUseForIncomingData
(
MediaCacheStream
*
aStream
)
;
void
Truncate
(
)
;
static
MediaCache
*
gMediaCache
;
int64_t
mNextResourceID
;
ReentrantMonitor
mReentrantMonitor
;
nsTArray
<
MediaCacheStream
*
>
mStreams
;
nsTArray
<
Block
>
mIndex
;
int32_t
mIndexWatermark
=
0
;
uint32_t
mBlockOwnersWatermark
=
0
;
RefPtr
<
MediaBlockCacheBase
>
mBlockCache
;
BlockList
mFreeBlocks
;
bool
mUpdateQueued
;
#
ifdef
DEBUG
bool
mInUpdate
;
#
endif
nsTArray
<
int64_t
>
mSuspendedStatusToNotify
;
}
;
MediaCache
*
MediaCache
:
:
gMediaCache
;
NS_IMETHODIMP
MediaCacheFlusher
:
:
Observe
(
nsISupports
*
aSubject
char
const
*
aTopic
char16_t
const
*
aData
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
strcmp
(
aTopic
"
last
-
pb
-
context
-
exited
"
)
=
=
0
)
{
for
(
MediaCache
*
mc
:
mMediaCaches
)
{
mc
-
>
CloseStreamsForPrivateBrowsing
(
)
;
}
return
NS_OK
;
}
if
(
strcmp
(
aTopic
"
cacheservice
:
empty
-
cache
"
)
=
=
0
)
{
for
(
MediaCache
*
mc
:
mMediaCaches
)
{
mc
-
>
Flush
(
)
;
}
return
NS_OK
;
}
return
NS_OK
;
}
MediaCacheStream
:
:
MediaCacheStream
(
ChannelMediaResource
*
aClient
bool
aIsPrivateBrowsing
)
:
mMediaCache
(
nullptr
)
mClient
(
aClient
)
mHasHadUpdate
(
false
)
mClosed
(
false
)
mDidNotifyDataEnded
(
false
)
mResourceID
(
0
)
mIsTransportSeekable
(
false
)
mCacheSuspended
(
false
)
mChannelEnded
(
false
)
mChannelOffset
(
0
)
mStreamLength
(
-
1
)
mStreamOffset
(
0
)
mPlaybackBytesPerSecond
(
10000
)
mPinCount
(
0
)
mCurrentMode
(
MODE_PLAYBACK
)
mMetadataInPartialBlockBuffer
(
false
)
mIsPrivateBrowsing
(
aIsPrivateBrowsing
)
{
}
size_t
MediaCacheStream
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
size
=
mBlocks
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
size
+
=
mReadaheadBlocks
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
size
+
=
mMetadataBlocks
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
size
+
=
mPlayedBlocks
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
size
+
=
aMallocSizeOf
(
mPartialBlockBuffer
.
get
(
)
)
;
return
size
;
}
size_t
MediaCacheStream
:
:
BlockList
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
mEntries
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
void
MediaCacheStream
:
:
BlockList
:
:
AddFirstBlock
(
int32_t
aBlock
)
{
NS_ASSERTION
(
!
mEntries
.
GetEntry
(
aBlock
)
"
Block
already
in
list
"
)
;
Entry
*
entry
=
mEntries
.
PutEntry
(
aBlock
)
;
if
(
mFirstBlock
<
0
)
{
entry
-
>
mNextBlock
=
entry
-
>
mPrevBlock
=
aBlock
;
}
else
{
entry
-
>
mNextBlock
=
mFirstBlock
;
entry
-
>
mPrevBlock
=
mEntries
.
GetEntry
(
mFirstBlock
)
-
>
mPrevBlock
;
mEntries
.
GetEntry
(
entry
-
>
mNextBlock
)
-
>
mPrevBlock
=
aBlock
;
mEntries
.
GetEntry
(
entry
-
>
mPrevBlock
)
-
>
mNextBlock
=
aBlock
;
}
mFirstBlock
=
aBlock
;
+
+
mCount
;
}
void
MediaCacheStream
:
:
BlockList
:
:
AddAfter
(
int32_t
aBlock
int32_t
aBefore
)
{
NS_ASSERTION
(
!
mEntries
.
GetEntry
(
aBlock
)
"
Block
already
in
list
"
)
;
Entry
*
entry
=
mEntries
.
PutEntry
(
aBlock
)
;
Entry
*
addAfter
=
mEntries
.
GetEntry
(
aBefore
)
;
NS_ASSERTION
(
addAfter
"
aBefore
not
in
list
"
)
;
entry
-
>
mNextBlock
=
addAfter
-
>
mNextBlock
;
entry
-
>
mPrevBlock
=
aBefore
;
mEntries
.
GetEntry
(
entry
-
>
mNextBlock
)
-
>
mPrevBlock
=
aBlock
;
mEntries
.
GetEntry
(
entry
-
>
mPrevBlock
)
-
>
mNextBlock
=
aBlock
;
+
+
mCount
;
}
void
MediaCacheStream
:
:
BlockList
:
:
RemoveBlock
(
int32_t
aBlock
)
{
Entry
*
entry
=
mEntries
.
GetEntry
(
aBlock
)
;
MOZ_DIAGNOSTIC_ASSERT
(
entry
"
Block
not
in
list
"
)
;
if
(
entry
-
>
mNextBlock
=
=
aBlock
)
{
MOZ_DIAGNOSTIC_ASSERT
(
entry
-
>
mPrevBlock
=
=
aBlock
"
Linked
list
inconsistency
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mFirstBlock
=
=
aBlock
"
Linked
list
inconsistency
"
)
;
mFirstBlock
=
-
1
;
}
else
{
if
(
mFirstBlock
=
=
aBlock
)
{
mFirstBlock
=
entry
-
>
mNextBlock
;
}
mEntries
.
GetEntry
(
entry
-
>
mNextBlock
)
-
>
mPrevBlock
=
entry
-
>
mPrevBlock
;
mEntries
.
GetEntry
(
entry
-
>
mPrevBlock
)
-
>
mNextBlock
=
entry
-
>
mNextBlock
;
}
mEntries
.
RemoveEntry
(
entry
)
;
-
-
mCount
;
}
int32_t
MediaCacheStream
:
:
BlockList
:
:
GetLastBlock
(
)
const
{
if
(
mFirstBlock
<
0
)
return
-
1
;
return
mEntries
.
GetEntry
(
mFirstBlock
)
-
>
mPrevBlock
;
}
int32_t
MediaCacheStream
:
:
BlockList
:
:
GetNextBlock
(
int32_t
aBlock
)
const
{
int32_t
block
=
mEntries
.
GetEntry
(
aBlock
)
-
>
mNextBlock
;
if
(
block
=
=
mFirstBlock
)
return
-
1
;
return
block
;
}
int32_t
MediaCacheStream
:
:
BlockList
:
:
GetPrevBlock
(
int32_t
aBlock
)
const
{
if
(
aBlock
=
=
mFirstBlock
)
return
-
1
;
return
mEntries
.
GetEntry
(
aBlock
)
-
>
mPrevBlock
;
}
#
ifdef
DEBUG
void
MediaCacheStream
:
:
BlockList
:
:
Verify
(
)
{
int32_t
count
=
0
;
if
(
mFirstBlock
>
=
0
)
{
int32_t
block
=
mFirstBlock
;
do
{
Entry
*
entry
=
mEntries
.
GetEntry
(
block
)
;
NS_ASSERTION
(
mEntries
.
GetEntry
(
entry
-
>
mNextBlock
)
-
>
mPrevBlock
=
=
block
"
Bad
prev
link
"
)
;
NS_ASSERTION
(
mEntries
.
GetEntry
(
entry
-
>
mPrevBlock
)
-
>
mNextBlock
=
=
block
"
Bad
next
link
"
)
;
block
=
entry
-
>
mNextBlock
;
+
+
count
;
}
while
(
block
!
=
mFirstBlock
)
;
}
NS_ASSERTION
(
count
=
=
mCount
"
Bad
count
"
)
;
}
#
endif
static
void
UpdateSwappedBlockIndex
(
int32_t
*
aBlockIndex
int32_t
aBlock1Index
int32_t
aBlock2Index
)
{
int32_t
index
=
*
aBlockIndex
;
if
(
index
=
=
aBlock1Index
)
{
*
aBlockIndex
=
aBlock2Index
;
}
else
if
(
index
=
=
aBlock2Index
)
{
*
aBlockIndex
=
aBlock1Index
;
}
}
void
MediaCacheStream
:
:
BlockList
:
:
NotifyBlockSwapped
(
int32_t
aBlockIndex1
int32_t
aBlockIndex2
)
{
Entry
*
e1
=
mEntries
.
GetEntry
(
aBlockIndex1
)
;
Entry
*
e2
=
mEntries
.
GetEntry
(
aBlockIndex2
)
;
int32_t
e1Prev
=
-
1
e1Next
=
-
1
e2Prev
=
-
1
e2Next
=
-
1
;
UpdateSwappedBlockIndex
(
&
mFirstBlock
aBlockIndex1
aBlockIndex2
)
;
if
(
e1
)
{
e1Prev
=
e1
-
>
mPrevBlock
;
e1Next
=
e1
-
>
mNextBlock
;
}
if
(
e2
)
{
e2Prev
=
e2
-
>
mPrevBlock
;
e2Next
=
e2
-
>
mNextBlock
;
}
if
(
e1
)
{
mEntries
.
GetEntry
(
e1Prev
)
-
>
mNextBlock
=
aBlockIndex2
;
mEntries
.
GetEntry
(
e1Next
)
-
>
mPrevBlock
=
aBlockIndex2
;
}
if
(
e2
)
{
mEntries
.
GetEntry
(
e2Prev
)
-
>
mNextBlock
=
aBlockIndex1
;
mEntries
.
GetEntry
(
e2Next
)
-
>
mPrevBlock
=
aBlockIndex1
;
}
if
(
e1
)
{
e1Prev
=
e1
-
>
mPrevBlock
;
e1Next
=
e1
-
>
mNextBlock
;
mEntries
.
RemoveEntry
(
e1
)
;
e2
=
mEntries
.
GetEntry
(
aBlockIndex2
)
;
}
if
(
e2
)
{
e2Prev
=
e2
-
>
mPrevBlock
;
e2Next
=
e2
-
>
mNextBlock
;
mEntries
.
RemoveEntry
(
e2
)
;
}
if
(
e1
)
{
e1
=
mEntries
.
PutEntry
(
aBlockIndex2
)
;
e1
-
>
mNextBlock
=
e1Next
;
e1
-
>
mPrevBlock
=
e1Prev
;
}
if
(
e2
)
{
e2
=
mEntries
.
PutEntry
(
aBlockIndex1
)
;
e2
-
>
mNextBlock
=
e2Next
;
e2
-
>
mPrevBlock
=
e2Prev
;
}
}
void
MediaCache
:
:
Flush
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
for
(
uint32_t
blockIndex
=
0
;
blockIndex
<
mIndex
.
Length
(
)
;
+
+
blockIndex
)
{
FreeBlock
(
blockIndex
)
;
}
Truncate
(
)
;
NS_ASSERTION
(
mIndex
.
Length
(
)
=
=
0
"
Blocks
leaked
?
"
)
;
nsresult
rv
=
mBlockCache
-
>
Init
(
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
void
MediaCache
:
:
CloseStreamsForPrivateBrowsing
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
MediaCacheStream
*
s
:
mStreams
)
{
if
(
s
-
>
mIsPrivateBrowsing
)
{
s
-
>
Close
(
)
;
}
}
}
RefPtr
<
MediaCache
>
MediaCache
:
:
GetMediaCache
(
int64_t
aContentLength
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
aContentLength
>
0
&
&
aContentLength
<
=
int64_t
(
MediaPrefs
:
:
MediaMemoryCacheMaxSize
(
)
)
*
1024
)
{
RefPtr
<
MediaBlockCacheBase
>
bc
=
new
MemoryBlockCache
(
aContentLength
)
;
nsresult
rv
=
bc
-
>
Init
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
RefPtr
<
MediaCache
>
mc
=
new
MediaCache
(
bc
)
;
LOG
(
"
GetMediaCache
(
%
"
PRIi64
"
)
-
>
Memory
MediaCache
%
p
"
aContentLength
mc
.
get
(
)
)
;
return
mc
;
}
}
if
(
gMediaCache
)
{
LOG
(
"
GetMediaCache
(
%
"
PRIi64
"
)
-
>
Existing
file
-
backed
MediaCache
"
aContentLength
)
;
return
gMediaCache
;
}
RefPtr
<
MediaBlockCacheBase
>
bc
=
new
FileBlockCache
(
)
;
nsresult
rv
=
bc
-
>
Init
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
gMediaCache
=
new
MediaCache
(
bc
)
;
LOG
(
"
GetMediaCache
(
%
"
PRIi64
"
)
-
>
Created
file
-
backed
MediaCache
"
aContentLength
)
;
}
else
{
LOG
(
"
GetMediaCache
(
%
"
PRIi64
"
)
-
>
Failed
to
create
file
-
backed
MediaCache
"
aContentLength
)
;
}
return
gMediaCache
;
}
nsresult
MediaCache
:
:
ReadCacheFile
(
int64_t
aOffset
void
*
aData
int32_t
aLength
int32_t
*
aBytes
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
RefPtr
<
MediaBlockCacheBase
>
blockCache
=
mBlockCache
;
if
(
!
blockCache
)
{
return
NS_ERROR_FAILURE
;
}
{
ReentrantMonitorAutoExit
unlock
(
mReentrantMonitor
)
;
return
blockCache
-
>
Read
(
aOffset
reinterpret_cast
<
uint8_t
*
>
(
aData
)
aLength
aBytes
)
;
}
}
static
int32_t
GetMaxBlocks
(
)
{
int32_t
cacheSize
=
Preferences
:
:
GetInt
(
"
media
.
cache_size
"
500
*
1024
)
;
int64_t
maxBlocks
=
static_cast
<
int64_t
>
(
cacheSize
)
*
1024
/
MediaCache
:
:
BLOCK_SIZE
;
maxBlocks
=
std
:
:
max
<
int64_t
>
(
maxBlocks
1
)
;
return
int32_t
(
std
:
:
min
<
int64_t
>
(
maxBlocks
INT32_MAX
)
)
;
}
int32_t
MediaCache
:
:
FindBlockForIncomingData
(
TimeStamp
aNow
MediaCacheStream
*
aStream
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
int32_t
blockIndex
=
FindReusableBlock
(
aNow
aStream
aStream
-
>
mChannelOffset
/
BLOCK_SIZE
INT32_MAX
)
;
if
(
blockIndex
<
0
|
|
!
IsBlockFree
(
blockIndex
)
)
{
if
(
(
mIndex
.
Length
(
)
<
uint32_t
(
GetMaxBlocks
(
)
)
|
|
blockIndex
<
0
|
|
PredictNextUseForIncomingData
(
aStream
)
>
=
PredictNextUse
(
aNow
blockIndex
)
)
)
{
blockIndex
=
mIndex
.
Length
(
)
;
if
(
!
mIndex
.
AppendElement
(
)
)
return
-
1
;
mIndexWatermark
=
std
:
:
max
(
mIndexWatermark
blockIndex
+
1
)
;
mFreeBlocks
.
AddFirstBlock
(
blockIndex
)
;
return
blockIndex
;
}
}
return
blockIndex
;
}
bool
MediaCache
:
:
BlockIsReusable
(
int32_t
aBlockIndex
)
{
Block
*
block
=
&
mIndex
[
aBlockIndex
]
;
for
(
uint32_t
i
=
0
;
i
<
block
-
>
mOwners
.
Length
(
)
;
+
+
i
)
{
MediaCacheStream
*
stream
=
block
-
>
mOwners
[
i
]
.
mStream
;
if
(
stream
-
>
mPinCount
>
0
|
|
stream
-
>
mStreamOffset
/
BLOCK_SIZE
=
=
block
-
>
mOwners
[
i
]
.
mStreamBlock
)
{
return
false
;
}
}
return
true
;
}
void
MediaCache
:
:
AppendMostReusableBlock
(
BlockList
*
aBlockList
nsTArray
<
uint32_t
>
*
aResult
int32_t
aBlockIndexLimit
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
int32_t
blockIndex
=
aBlockList
-
>
GetLastBlock
(
)
;
if
(
blockIndex
<
0
)
return
;
do
{
if
(
blockIndex
<
aBlockIndexLimit
&
&
BlockIsReusable
(
blockIndex
)
)
{
aResult
-
>
AppendElement
(
blockIndex
)
;
return
;
}
blockIndex
=
aBlockList
-
>
GetPrevBlock
(
blockIndex
)
;
}
while
(
blockIndex
>
=
0
)
;
}
int32_t
MediaCache
:
:
FindReusableBlock
(
TimeStamp
aNow
MediaCacheStream
*
aForStream
int32_t
aForStreamBlock
int32_t
aMaxSearchBlockIndex
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
uint32_t
length
=
std
:
:
min
(
uint32_t
(
aMaxSearchBlockIndex
)
uint32_t
(
mIndex
.
Length
(
)
)
)
;
if
(
aForStream
&
&
aForStreamBlock
>
0
&
&
uint32_t
(
aForStreamBlock
)
<
=
aForStream
-
>
mBlocks
.
Length
(
)
)
{
int32_t
prevCacheBlock
=
aForStream
-
>
mBlocks
[
aForStreamBlock
-
1
]
;
if
(
prevCacheBlock
>
=
0
)
{
uint32_t
freeBlockScanEnd
=
std
:
:
min
(
length
prevCacheBlock
+
FREE_BLOCK_SCAN_LIMIT
)
;
for
(
uint32_t
i
=
prevCacheBlock
;
i
<
freeBlockScanEnd
;
+
+
i
)
{
if
(
IsBlockFree
(
i
)
)
return
i
;
}
}
}
if
(
!
mFreeBlocks
.
IsEmpty
(
)
)
{
int32_t
blockIndex
=
mFreeBlocks
.
GetFirstBlock
(
)
;
do
{
if
(
blockIndex
<
aMaxSearchBlockIndex
)
return
blockIndex
;
blockIndex
=
mFreeBlocks
.
GetNextBlock
(
blockIndex
)
;
}
while
(
blockIndex
>
=
0
)
;
}
AutoTArray
<
uint32_t
8
>
candidates
;
for
(
uint32_t
i
=
0
;
i
<
mStreams
.
Length
(
)
;
+
+
i
)
{
MediaCacheStream
*
stream
=
mStreams
[
i
]
;
if
(
stream
-
>
mPinCount
>
0
)
{
continue
;
}
AppendMostReusableBlock
(
&
stream
-
>
mMetadataBlocks
&
candidates
length
)
;
AppendMostReusableBlock
(
&
stream
-
>
mPlayedBlocks
&
candidates
length
)
;
if
(
stream
-
>
mIsTransportSeekable
)
{
AppendMostReusableBlock
(
&
stream
-
>
mReadaheadBlocks
&
candidates
length
)
;
}
}
TimeDuration
latestUse
;
int32_t
latestUseBlock
=
-
1
;
for
(
uint32_t
i
=
0
;
i
<
candidates
.
Length
(
)
;
+
+
i
)
{
TimeDuration
nextUse
=
PredictNextUse
(
aNow
candidates
[
i
]
)
;
if
(
nextUse
>
latestUse
)
{
latestUse
=
nextUse
;
latestUseBlock
=
candidates
[
i
]
;
}
}
return
latestUseBlock
;
}
MediaCache
:
:
BlockList
*
MediaCache
:
:
GetListForBlock
(
BlockOwner
*
aBlock
)
{
switch
(
aBlock
-
>
mClass
)
{
case
METADATA_BLOCK
:
NS_ASSERTION
(
aBlock
-
>
mStream
"
Metadata
block
has
no
stream
?
"
)
;
return
&
aBlock
-
>
mStream
-
>
mMetadataBlocks
;
case
PLAYED_BLOCK
:
NS_ASSERTION
(
aBlock
-
>
mStream
"
Metadata
block
has
no
stream
?
"
)
;
return
&
aBlock
-
>
mStream
-
>
mPlayedBlocks
;
case
READAHEAD_BLOCK
:
NS_ASSERTION
(
aBlock
-
>
mStream
"
Readahead
block
has
no
stream
?
"
)
;
return
&
aBlock
-
>
mStream
-
>
mReadaheadBlocks
;
default
:
NS_ERROR
(
"
Invalid
block
class
"
)
;
return
nullptr
;
}
}
MediaCache
:
:
BlockOwner
*
MediaCache
:
:
GetBlockOwner
(
int32_t
aBlockIndex
MediaCacheStream
*
aStream
)
{
Block
*
block
=
&
mIndex
[
aBlockIndex
]
;
for
(
uint32_t
i
=
0
;
i
<
block
-
>
mOwners
.
Length
(
)
;
+
+
i
)
{
if
(
block
-
>
mOwners
[
i
]
.
mStream
=
=
aStream
)
return
&
block
-
>
mOwners
[
i
]
;
}
return
nullptr
;
}
void
MediaCache
:
:
SwapBlocks
(
int32_t
aBlockIndex1
int32_t
aBlockIndex2
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
Block
*
block1
=
&
mIndex
[
aBlockIndex1
]
;
Block
*
block2
=
&
mIndex
[
aBlockIndex2
]
;
block1
-
>
mOwners
.
SwapElements
(
block2
-
>
mOwners
)
;
const
Block
*
blocks
[
]
=
{
block1
block2
}
;
int32_t
blockIndices
[
]
=
{
aBlockIndex1
aBlockIndex2
}
;
for
(
int32_t
i
=
0
;
i
<
2
;
+
+
i
)
{
for
(
uint32_t
j
=
0
;
j
<
blocks
[
i
]
-
>
mOwners
.
Length
(
)
;
+
+
j
)
{
const
BlockOwner
*
b
=
&
blocks
[
i
]
-
>
mOwners
[
j
]
;
b
-
>
mStream
-
>
mBlocks
[
b
-
>
mStreamBlock
]
=
blockIndices
[
i
]
;
}
}
mFreeBlocks
.
NotifyBlockSwapped
(
aBlockIndex1
aBlockIndex2
)
;
nsTHashtable
<
nsPtrHashKey
<
MediaCacheStream
>
>
visitedStreams
;
for
(
int32_t
i
=
0
;
i
<
2
;
+
+
i
)
{
for
(
uint32_t
j
=
0
;
j
<
blocks
[
i
]
-
>
mOwners
.
Length
(
)
;
+
+
j
)
{
MediaCacheStream
*
stream
=
blocks
[
i
]
-
>
mOwners
[
j
]
.
mStream
;
if
(
visitedStreams
.
GetEntry
(
stream
)
)
continue
;
visitedStreams
.
PutEntry
(
stream
)
;
stream
-
>
mReadaheadBlocks
.
NotifyBlockSwapped
(
aBlockIndex1
aBlockIndex2
)
;
stream
-
>
mPlayedBlocks
.
NotifyBlockSwapped
(
aBlockIndex1
aBlockIndex2
)
;
stream
-
>
mMetadataBlocks
.
NotifyBlockSwapped
(
aBlockIndex1
aBlockIndex2
)
;
}
}
Verify
(
)
;
}
void
MediaCache
:
:
RemoveBlockOwner
(
int32_t
aBlockIndex
MediaCacheStream
*
aStream
)
{
Block
*
block
=
&
mIndex
[
aBlockIndex
]
;
for
(
uint32_t
i
=
0
;
i
<
block
-
>
mOwners
.
Length
(
)
;
+
+
i
)
{
BlockOwner
*
bo
=
&
block
-
>
mOwners
[
i
]
;
if
(
bo
-
>
mStream
=
=
aStream
)
{
GetListForBlock
(
bo
)
-
>
RemoveBlock
(
aBlockIndex
)
;
bo
-
>
mStream
-
>
mBlocks
[
bo
-
>
mStreamBlock
]
=
-
1
;
block
-
>
mOwners
.
RemoveElementAt
(
i
)
;
if
(
block
-
>
mOwners
.
IsEmpty
(
)
)
{
mFreeBlocks
.
AddFirstBlock
(
aBlockIndex
)
;
}
return
;
}
}
}
void
MediaCache
:
:
AddBlockOwnerAsReadahead
(
int32_t
aBlockIndex
MediaCacheStream
*
aStream
int32_t
aStreamBlockIndex
)
{
Block
*
block
=
&
mIndex
[
aBlockIndex
]
;
if
(
block
-
>
mOwners
.
IsEmpty
(
)
)
{
mFreeBlocks
.
RemoveBlock
(
aBlockIndex
)
;
}
BlockOwner
*
bo
=
block
-
>
mOwners
.
AppendElement
(
)
;
mBlockOwnersWatermark
=
std
:
:
max
(
mBlockOwnersWatermark
uint32_t
(
block
-
>
mOwners
.
Length
(
)
)
)
;
bo
-
>
mStream
=
aStream
;
bo
-
>
mStreamBlock
=
aStreamBlockIndex
;
aStream
-
>
mBlocks
[
aStreamBlockIndex
]
=
aBlockIndex
;
bo
-
>
mClass
=
READAHEAD_BLOCK
;
InsertReadaheadBlock
(
bo
aBlockIndex
)
;
}
void
MediaCache
:
:
FreeBlock
(
int32_t
aBlock
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
Block
*
block
=
&
mIndex
[
aBlock
]
;
if
(
block
-
>
mOwners
.
IsEmpty
(
)
)
{
return
;
}
LOG
(
"
Released
block
%
d
"
aBlock
)
;
for
(
uint32_t
i
=
0
;
i
<
block
-
>
mOwners
.
Length
(
)
;
+
+
i
)
{
BlockOwner
*
bo
=
&
block
-
>
mOwners
[
i
]
;
GetListForBlock
(
bo
)
-
>
RemoveBlock
(
aBlock
)
;
bo
-
>
mStream
-
>
mBlocks
[
bo
-
>
mStreamBlock
]
=
-
1
;
}
block
-
>
mOwners
.
Clear
(
)
;
mFreeBlocks
.
AddFirstBlock
(
aBlock
)
;
Verify
(
)
;
}
TimeDuration
MediaCache
:
:
PredictNextUse
(
TimeStamp
aNow
int32_t
aBlock
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
NS_ASSERTION
(
!
IsBlockFree
(
aBlock
)
"
aBlock
is
free
"
)
;
Block
*
block
=
&
mIndex
[
aBlock
]
;
TimeDuration
result
;
for
(
uint32_t
i
=
0
;
i
<
block
-
>
mOwners
.
Length
(
)
;
+
+
i
)
{
BlockOwner
*
bo
=
&
block
-
>
mOwners
[
i
]
;
TimeDuration
prediction
;
switch
(
bo
-
>
mClass
)
{
case
METADATA_BLOCK
:
prediction
=
aNow
-
bo
-
>
mLastUseTime
;
break
;
case
PLAYED_BLOCK
:
{
NS_ASSERTION
(
static_cast
<
int64_t
>
(
bo
-
>
mStreamBlock
)
*
BLOCK_SIZE
<
bo
-
>
mStream
-
>
mStreamOffset
"
Played
block
after
the
current
stream
position
?
"
)
;
int64_t
bytesBehind
=
bo
-
>
mStream
-
>
mStreamOffset
-
static_cast
<
int64_t
>
(
bo
-
>
mStreamBlock
)
*
BLOCK_SIZE
;
int64_t
millisecondsBehind
=
bytesBehind
*
1000
/
bo
-
>
mStream
-
>
mPlaybackBytesPerSecond
;
prediction
=
TimeDuration
:
:
FromMilliseconds
(
std
:
:
min
<
int64_t
>
(
millisecondsBehind
*
REPLAY_PENALTY_FACTOR
INT32_MAX
)
)
;
break
;
}
case
READAHEAD_BLOCK
:
{
int64_t
bytesAhead
=
static_cast
<
int64_t
>
(
bo
-
>
mStreamBlock
)
*
BLOCK_SIZE
-
bo
-
>
mStream
-
>
mStreamOffset
;
NS_ASSERTION
(
bytesAhead
>
=
0
"
Readahead
block
before
the
current
stream
position
?
"
)
;
int64_t
millisecondsAhead
=
bytesAhead
*
1000
/
bo
-
>
mStream
-
>
mPlaybackBytesPerSecond
;
prediction
=
TimeDuration
:
:
FromMilliseconds
(
std
:
:
min
<
int64_t
>
(
millisecondsAhead
INT32_MAX
)
)
;
break
;
}
default
:
NS_ERROR
(
"
Invalid
class
for
predicting
next
use
"
)
;
return
TimeDuration
(
0
)
;
}
if
(
i
=
=
0
|
|
prediction
<
result
)
{
result
=
prediction
;
}
}
return
result
;
}
TimeDuration
MediaCache
:
:
PredictNextUseForIncomingData
(
MediaCacheStream
*
aStream
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
int64_t
bytesAhead
=
aStream
-
>
mChannelOffset
-
aStream
-
>
mStreamOffset
;
if
(
bytesAhead
<
=
-
BLOCK_SIZE
)
{
return
TimeDuration
:
:
FromSeconds
(
24
*
60
*
60
)
;
}
if
(
bytesAhead
<
=
0
)
return
TimeDuration
(
0
)
;
int64_t
millisecondsAhead
=
bytesAhead
*
1000
/
aStream
-
>
mPlaybackBytesPerSecond
;
return
TimeDuration
:
:
FromMilliseconds
(
std
:
:
min
<
int64_t
>
(
millisecondsAhead
INT32_MAX
)
)
;
}
enum
StreamAction
{
NONE
SEEK
SEEK_AND_RESUME
RESUME
SUSPEND
}
;
void
MediaCache
:
:
Update
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
AutoTArray
<
StreamAction
10
>
actions
;
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
mUpdateQueued
=
false
;
#
ifdef
DEBUG
mInUpdate
=
true
;
#
endif
int32_t
maxBlocks
=
GetMaxBlocks
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
int32_t
freeBlockCount
=
mFreeBlocks
.
GetCount
(
)
;
TimeDuration
latestPredictedUseForOverflow
=
0
;
if
(
mIndex
.
Length
(
)
>
uint32_t
(
maxBlocks
)
)
{
for
(
int32_t
blockIndex
=
mIndex
.
Length
(
)
-
1
;
blockIndex
>
=
maxBlocks
;
-
-
blockIndex
)
{
if
(
IsBlockFree
(
blockIndex
)
)
{
-
-
freeBlockCount
;
continue
;
}
TimeDuration
predictedUse
=
PredictNextUse
(
now
blockIndex
)
;
latestPredictedUseForOverflow
=
std
:
:
max
(
latestPredictedUseForOverflow
predictedUse
)
;
}
}
else
{
freeBlockCount
+
=
maxBlocks
-
mIndex
.
Length
(
)
;
}
for
(
int32_t
blockIndex
=
mIndex
.
Length
(
)
-
1
;
blockIndex
>
=
maxBlocks
;
-
-
blockIndex
)
{
if
(
IsBlockFree
(
blockIndex
)
)
continue
;
Block
*
block
=
&
mIndex
[
blockIndex
]
;
int32_t
destinationBlockIndex
=
FindReusableBlock
(
now
block
-
>
mOwners
[
0
]
.
mStream
block
-
>
mOwners
[
0
]
.
mStreamBlock
maxBlocks
)
;
if
(
destinationBlockIndex
<
0
)
{
break
;
}
if
(
IsBlockFree
(
destinationBlockIndex
)
|
|
PredictNextUse
(
now
destinationBlockIndex
)
>
latestPredictedUseForOverflow
)
{
nsresult
rv
=
mBlockCache
-
>
MoveBlock
(
blockIndex
destinationBlockIndex
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
"
Swapping
blocks
%
d
and
%
d
(
trimming
cache
)
"
blockIndex
destinationBlockIndex
)
;
SwapBlocks
(
blockIndex
destinationBlockIndex
)
;
LOG
(
"
Released
block
%
d
(
trimming
cache
)
"
blockIndex
)
;
FreeBlock
(
blockIndex
)
;
}
}
else
{
LOG
(
"
Could
not
trim
cache
block
%
d
(
destination
%
d
"
"
predicted
next
use
%
f
latest
predicted
use
for
overflow
%
f
"
blockIndex
destinationBlockIndex
PredictNextUse
(
now
destinationBlockIndex
)
.
ToSeconds
(
)
latestPredictedUseForOverflow
.
ToSeconds
(
)
)
;
}
}
Truncate
(
)
;
int32_t
nonSeekableReadaheadBlockCount
=
0
;
for
(
uint32_t
i
=
0
;
i
<
mStreams
.
Length
(
)
;
+
+
i
)
{
MediaCacheStream
*
stream
=
mStreams
[
i
]
;
if
(
!
stream
-
>
mIsTransportSeekable
)
{
nonSeekableReadaheadBlockCount
+
=
stream
-
>
mReadaheadBlocks
.
GetCount
(
)
;
}
}
TimeDuration
latestNextUse
;
if
(
freeBlockCount
=
=
0
)
{
int32_t
reusableBlock
=
FindReusableBlock
(
now
nullptr
0
maxBlocks
)
;
if
(
reusableBlock
>
=
0
)
{
latestNextUse
=
PredictNextUse
(
now
reusableBlock
)
;
}
}
int32_t
resumeThreshold
=
Preferences
:
:
GetInt
(
"
media
.
cache_resume_threshold
"
10
)
;
int32_t
readaheadLimit
=
Preferences
:
:
GetInt
(
"
media
.
cache_readahead_limit
"
30
)
;
for
(
uint32_t
i
=
0
;
i
<
mStreams
.
Length
(
)
;
+
+
i
)
{
actions
.
AppendElement
(
NONE
)
;
MediaCacheStream
*
stream
=
mStreams
[
i
]
;
if
(
stream
-
>
mClosed
)
{
LOG
(
"
Stream
%
p
closed
"
stream
)
;
continue
;
}
int64_t
dataOffset
=
stream
-
>
GetCachedDataEndInternal
(
stream
-
>
mStreamOffset
)
;
MOZ_ASSERT
(
dataOffset
>
=
0
)
;
int64_t
desiredOffset
=
dataOffset
;
if
(
stream
-
>
mIsTransportSeekable
)
{
if
(
desiredOffset
>
stream
-
>
mChannelOffset
&
&
desiredOffset
<
=
stream
-
>
mChannelOffset
+
SEEK_VS_READ_THRESHOLD
)
{
desiredOffset
=
stream
-
>
mChannelOffset
;
}
}
else
{
if
(
stream
-
>
mChannelOffset
>
desiredOffset
)
{
NS_WARNING
(
"
Can
'
t
seek
backwards
so
seeking
to
0
"
)
;
desiredOffset
=
0
;
ReleaseStreamBlocks
(
stream
)
;
}
else
{
desiredOffset
=
stream
-
>
mChannelOffset
;
}
}
bool
enableReading
;
if
(
stream
-
>
mStreamLength
>
=
0
&
&
dataOffset
>
=
stream
-
>
mStreamLength
)
{
LOG
(
"
Stream
%
p
at
end
of
stream
"
stream
)
;
enableReading
=
!
stream
-
>
mCacheSuspended
&
&
stream
-
>
mStreamLength
=
=
stream
-
>
mChannelOffset
;
}
else
if
(
desiredOffset
<
stream
-
>
mStreamOffset
)
{
LOG
(
"
Stream
%
p
catching
up
"
stream
)
;
enableReading
=
true
;
}
else
if
(
desiredOffset
<
stream
-
>
mStreamOffset
+
BLOCK_SIZE
)
{
LOG
(
"
Stream
%
p
feeding
reader
"
stream
)
;
enableReading
=
true
;
}
else
if
(
!
stream
-
>
mIsTransportSeekable
&
&
nonSeekableReadaheadBlockCount
>
=
maxBlocks
*
NONSEEKABLE_READAHEAD_MAX
)
{
LOG
(
"
Stream
%
p
throttling
non
-
seekable
readahead
"
stream
)
;
enableReading
=
false
;
}
else
if
(
mIndex
.
Length
(
)
>
uint32_t
(
maxBlocks
)
)
{
LOG
(
"
Stream
%
p
throttling
to
reduce
cache
size
"
stream
)
;
enableReading
=
false
;
}
else
{
TimeDuration
predictedNewDataUse
=
PredictNextUseForIncomingData
(
stream
)
;
if
(
stream
-
>
mThrottleReadahead
&
&
stream
-
>
mCacheSuspended
&
&
predictedNewDataUse
.
ToSeconds
(
)
>
resumeThreshold
)
{
LOG
(
"
Stream
%
p
avoiding
wakeup
since
more
data
is
not
needed
"
stream
)
;
enableReading
=
false
;
}
else
if
(
stream
-
>
mThrottleReadahead
&
&
predictedNewDataUse
.
ToSeconds
(
)
>
readaheadLimit
)
{
LOG
(
"
Stream
%
p
throttling
to
avoid
reading
ahead
too
far
"
stream
)
;
enableReading
=
false
;
}
else
if
(
freeBlockCount
>
0
)
{
LOG
(
"
Stream
%
p
reading
since
there
are
free
blocks
"
stream
)
;
enableReading
=
true
;
}
else
if
(
latestNextUse
<
=
TimeDuration
(
0
)
)
{
LOG
(
"
Stream
%
p
throttling
due
to
no
reusable
blocks
"
stream
)
;
enableReading
=
false
;
}
else
{
LOG
(
"
Stream
%
p
predict
next
data
in
%
f
current
worst
block
is
%
f
"
stream
predictedNewDataUse
.
ToSeconds
(
)
latestNextUse
.
ToSeconds
(
)
)
;
enableReading
=
predictedNewDataUse
<
latestNextUse
;
}
}
if
(
enableReading
)
{
for
(
uint32_t
j
=
0
;
j
<
i
;
+
+
j
)
{
MediaCacheStream
*
other
=
mStreams
[
j
]
;
if
(
other
-
>
mResourceID
=
=
stream
-
>
mResourceID
&
&
!
other
-
>
mClosed
&
&
!
other
-
>
mClient
-
>
IsSuspended
(
)
&
&
other
-
>
mChannelOffset
/
BLOCK_SIZE
=
=
desiredOffset
/
BLOCK_SIZE
)
{
enableReading
=
false
;
LOG
(
"
Stream
%
p
waiting
on
same
block
(
%
"
PRId64
"
)
from
stream
%
p
"
stream
desiredOffset
/
BLOCK_SIZE
other
)
;
break
;
}
}
}
if
(
stream
-
>
mChannelOffset
!
=
desiredOffset
&
&
enableReading
)
{
NS_ASSERTION
(
stream
-
>
mIsTransportSeekable
|
|
desiredOffset
=
=
0
"
Trying
to
seek
in
a
non
-
seekable
stream
!
"
)
;
stream
-
>
mChannelOffset
=
(
desiredOffset
/
BLOCK_SIZE
)
*
BLOCK_SIZE
;
actions
[
i
]
=
stream
-
>
mCacheSuspended
?
SEEK_AND_RESUME
:
SEEK
;
}
else
if
(
enableReading
&
&
stream
-
>
mCacheSuspended
)
{
actions
[
i
]
=
RESUME
;
}
else
if
(
!
enableReading
&
&
!
stream
-
>
mCacheSuspended
)
{
actions
[
i
]
=
SUSPEND
;
}
}
#
ifdef
DEBUG
mInUpdate
=
false
;
#
endif
}
for
(
uint32_t
i
=
0
;
i
<
mStreams
.
Length
(
)
;
+
+
i
)
{
MediaCacheStream
*
stream
=
mStreams
[
i
]
;
switch
(
actions
[
i
]
)
{
case
SEEK
:
case
SEEK_AND_RESUME
:
stream
-
>
mCacheSuspended
=
false
;
stream
-
>
mChannelEnded
=
false
;
break
;
case
RESUME
:
stream
-
>
mCacheSuspended
=
false
;
break
;
case
SUSPEND
:
stream
-
>
mCacheSuspended
=
true
;
break
;
default
:
break
;
}
stream
-
>
mHasHadUpdate
=
true
;
}
for
(
uint32_t
i
=
0
;
i
<
mStreams
.
Length
(
)
;
+
+
i
)
{
MediaCacheStream
*
stream
=
mStreams
[
i
]
;
nsresult
rv
;
switch
(
actions
[
i
]
)
{
case
SEEK
:
case
SEEK_AND_RESUME
:
LOG
(
"
Stream
%
p
CacheSeek
to
%
"
PRId64
"
(
resume
=
%
d
)
"
stream
stream
-
>
mChannelOffset
actions
[
i
]
=
=
SEEK_AND_RESUME
)
;
rv
=
stream
-
>
mClient
-
>
CacheClientSeek
(
stream
-
>
mChannelOffset
actions
[
i
]
=
=
SEEK_AND_RESUME
)
;
break
;
case
RESUME
:
LOG
(
"
Stream
%
p
Resumed
"
stream
)
;
rv
=
stream
-
>
mClient
-
>
CacheClientResume
(
)
;
QueueSuspendedStatusUpdate
(
stream
-
>
mResourceID
)
;
break
;
case
SUSPEND
:
LOG
(
"
Stream
%
p
Suspended
"
stream
)
;
rv
=
stream
-
>
mClient
-
>
CacheClientSuspend
(
)
;
QueueSuspendedStatusUpdate
(
stream
-
>
mResourceID
)
;
break
;
default
:
rv
=
NS_OK
;
break
;
}
if
(
NS_FAILED
(
rv
)
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
stream
-
>
CloseInternal
(
mon
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
mSuspendedStatusToNotify
.
Length
(
)
;
+
+
i
)
{
MediaCache
:
:
ResourceStreamIterator
iter
(
this
mSuspendedStatusToNotify
[
i
]
)
;
while
(
MediaCacheStream
*
stream
=
iter
.
Next
(
)
)
{
stream
-
>
mClient
-
>
CacheClientNotifySuspendedStatusChanged
(
)
;
}
}
mSuspendedStatusToNotify
.
Clear
(
)
;
}
class
UpdateEvent
:
public
Runnable
{
public
:
explicit
UpdateEvent
(
MediaCache
*
aMediaCache
)
:
Runnable
(
"
MediaCache
:
:
UpdateEvent
"
)
mMediaCache
(
aMediaCache
)
{
}
NS_IMETHOD
Run
(
)
override
{
mMediaCache
-
>
Update
(
)
;
return
NS_OK
;
}
private
:
RefPtr
<
MediaCache
>
mMediaCache
;
}
;
void
MediaCache
:
:
QueueUpdate
(
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
NS_ASSERTION
(
!
mInUpdate
"
Queuing
an
update
while
we
'
re
in
an
update
"
)
;
if
(
mUpdateQueued
)
return
;
mUpdateQueued
=
true
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
UpdateEvent
(
this
)
;
SystemGroup
:
:
Dispatch
(
"
MediaCache
:
:
UpdateEvent
"
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
}
void
MediaCache
:
:
QueueSuspendedStatusUpdate
(
int64_t
aResourceID
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
!
mSuspendedStatusToNotify
.
Contains
(
aResourceID
)
)
{
mSuspendedStatusToNotify
.
AppendElement
(
aResourceID
)
;
}
}
#
ifdef
DEBUG_VERIFY_CACHE
void
MediaCache
:
:
Verify
(
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
mFreeBlocks
.
Verify
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mStreams
.
Length
(
)
;
+
+
i
)
{
MediaCacheStream
*
stream
=
mStreams
[
i
]
;
stream
-
>
mReadaheadBlocks
.
Verify
(
)
;
stream
-
>
mPlayedBlocks
.
Verify
(
)
;
stream
-
>
mMetadataBlocks
.
Verify
(
)
;
int32_t
block
=
stream
-
>
mReadaheadBlocks
.
GetFirstBlock
(
)
;
int32_t
lastStreamBlock
=
-
1
;
while
(
block
>
=
0
)
{
uint32_t
j
=
0
;
while
(
mIndex
[
block
]
.
mOwners
[
j
]
.
mStream
!
=
stream
)
{
+
+
j
;
}
int32_t
nextStreamBlock
=
int32_t
(
mIndex
[
block
]
.
mOwners
[
j
]
.
mStreamBlock
)
;
NS_ASSERTION
(
lastStreamBlock
<
nextStreamBlock
"
Blocks
not
increasing
in
readahead
stream
"
)
;
lastStreamBlock
=
nextStreamBlock
;
block
=
stream
-
>
mReadaheadBlocks
.
GetNextBlock
(
block
)
;
}
}
}
#
endif
void
MediaCache
:
:
InsertReadaheadBlock
(
BlockOwner
*
aBlockOwner
int32_t
aBlockIndex
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
MediaCacheStream
*
stream
=
aBlockOwner
-
>
mStream
;
int32_t
readaheadIndex
=
stream
-
>
mReadaheadBlocks
.
GetLastBlock
(
)
;
while
(
readaheadIndex
>
=
0
)
{
BlockOwner
*
bo
=
GetBlockOwner
(
readaheadIndex
stream
)
;
NS_ASSERTION
(
bo
"
stream
must
own
its
blocks
"
)
;
if
(
bo
-
>
mStreamBlock
<
aBlockOwner
-
>
mStreamBlock
)
{
stream
-
>
mReadaheadBlocks
.
AddAfter
(
aBlockIndex
readaheadIndex
)
;
return
;
}
NS_ASSERTION
(
bo
-
>
mStreamBlock
>
aBlockOwner
-
>
mStreamBlock
"
Duplicated
blocks
?
?
"
)
;
readaheadIndex
=
stream
-
>
mReadaheadBlocks
.
GetPrevBlock
(
readaheadIndex
)
;
}
stream
-
>
mReadaheadBlocks
.
AddFirstBlock
(
aBlockIndex
)
;
Verify
(
)
;
}
void
MediaCache
:
:
AllocateAndWriteBlock
(
MediaCacheStream
*
aStream
MediaCacheStream
:
:
ReadMode
aMode
Span
<
const
uint8_t
>
aData1
Span
<
const
uint8_t
>
aData2
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
int32_t
streamBlockIndex
=
aStream
-
>
mChannelOffset
/
BLOCK_SIZE
;
ResourceStreamIterator
iter
(
this
aStream
-
>
mResourceID
)
;
while
(
MediaCacheStream
*
stream
=
iter
.
Next
(
)
)
{
while
(
streamBlockIndex
>
=
int32_t
(
stream
-
>
mBlocks
.
Length
(
)
)
)
{
stream
-
>
mBlocks
.
AppendElement
(
-
1
)
;
}
if
(
stream
-
>
mBlocks
[
streamBlockIndex
]
>
=
0
)
{
int32_t
globalBlockIndex
=
stream
-
>
mBlocks
[
streamBlockIndex
]
;
LOG
(
"
Released
block
%
d
from
stream
%
p
block
%
d
(
%
"
PRId64
"
)
"
globalBlockIndex
stream
streamBlockIndex
streamBlockIndex
*
BLOCK_SIZE
)
;
RemoveBlockOwner
(
globalBlockIndex
stream
)
;
}
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
int32_t
blockIndex
=
FindBlockForIncomingData
(
now
aStream
)
;
if
(
blockIndex
>
=
0
)
{
FreeBlock
(
blockIndex
)
;
Block
*
block
=
&
mIndex
[
blockIndex
]
;
LOG
(
"
Allocated
block
%
d
to
stream
%
p
block
%
d
(
%
"
PRId64
"
)
"
blockIndex
aStream
streamBlockIndex
streamBlockIndex
*
BLOCK_SIZE
)
;
ResourceStreamIterator
iter
(
this
aStream
-
>
mResourceID
)
;
while
(
MediaCacheStream
*
stream
=
iter
.
Next
(
)
)
{
BlockOwner
*
bo
=
block
-
>
mOwners
.
AppendElement
(
)
;
if
(
!
bo
)
{
block
-
>
mOwners
.
Clear
(
)
;
return
;
}
mBlockOwnersWatermark
=
std
:
:
max
(
mBlockOwnersWatermark
uint32_t
(
block
-
>
mOwners
.
Length
(
)
)
)
;
bo
-
>
mStream
=
stream
;
}
if
(
block
-
>
mOwners
.
IsEmpty
(
)
)
{
return
;
}
for
(
auto
&
bo
:
block
-
>
mOwners
)
{
bo
.
mStreamBlock
=
streamBlockIndex
;
bo
.
mLastUseTime
=
now
;
bo
.
mStream
-
>
mBlocks
[
streamBlockIndex
]
=
blockIndex
;
if
(
streamBlockIndex
*
BLOCK_SIZE
<
bo
.
mStream
-
>
mStreamOffset
)
{
bo
.
mClass
=
aMode
=
=
MediaCacheStream
:
:
MODE_PLAYBACK
?
PLAYED_BLOCK
:
METADATA_BLOCK
;
GetListForBlock
(
&
bo
)
-
>
AddFirstBlock
(
blockIndex
)
;
Verify
(
)
;
}
else
{
bo
.
mClass
=
READAHEAD_BLOCK
;
InsertReadaheadBlock
(
&
bo
blockIndex
)
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
!
block
-
>
mOwners
.
IsEmpty
(
)
)
;
mFreeBlocks
.
RemoveBlock
(
blockIndex
)
;
nsresult
rv
=
mBlockCache
-
>
WriteBlock
(
blockIndex
aData1
aData2
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
"
Released
block
%
d
from
stream
%
p
block
%
d
(
%
"
PRId64
"
)
"
blockIndex
aStream
streamBlockIndex
streamBlockIndex
*
BLOCK_SIZE
)
;
FreeBlock
(
blockIndex
)
;
}
}
QueueUpdate
(
)
;
}
void
MediaCache
:
:
OpenStream
(
MediaCacheStream
*
aStream
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
LOG
(
"
Stream
%
p
opened
"
aStream
)
;
mStreams
.
AppendElement
(
aStream
)
;
aStream
-
>
mResourceID
=
AllocateResourceID
(
)
;
QueueUpdate
(
)
;
}
void
MediaCache
:
:
ReleaseStream
(
MediaCacheStream
*
aStream
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
LOG
(
"
Stream
%
p
closed
"
aStream
)
;
mStreams
.
RemoveElement
(
aStream
)
;
QueueUpdate
(
)
;
}
void
MediaCache
:
:
ReleaseStreamBlocks
(
MediaCacheStream
*
aStream
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
uint32_t
length
=
aStream
-
>
mBlocks
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
int32_t
blockIndex
=
aStream
-
>
mBlocks
[
i
]
;
if
(
blockIndex
>
=
0
)
{
LOG
(
"
Released
block
%
d
from
stream
%
p
block
%
d
(
%
"
PRId64
"
)
"
blockIndex
aStream
i
i
*
BLOCK_SIZE
)
;
RemoveBlockOwner
(
blockIndex
aStream
)
;
}
}
}
void
MediaCache
:
:
Truncate
(
)
{
uint32_t
end
;
for
(
end
=
mIndex
.
Length
(
)
;
end
>
0
;
-
-
end
)
{
if
(
!
IsBlockFree
(
end
-
1
)
)
break
;
mFreeBlocks
.
RemoveBlock
(
end
-
1
)
;
}
if
(
end
<
mIndex
.
Length
(
)
)
{
mIndex
.
TruncateLength
(
end
)
;
}
}
void
MediaCache
:
:
NoteBlockUsage
(
MediaCacheStream
*
aStream
int32_t
aBlockIndex
int64_t
aStreamOffset
MediaCacheStream
:
:
ReadMode
aMode
TimeStamp
aNow
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
if
(
aBlockIndex
<
0
)
{
return
;
}
BlockOwner
*
bo
=
GetBlockOwner
(
aBlockIndex
aStream
)
;
if
(
!
bo
)
{
return
;
}
NS_ASSERTION
(
bo
-
>
mStreamBlock
*
BLOCK_SIZE
<
=
aStreamOffset
"
Using
a
block
that
'
s
behind
the
read
position
?
"
)
;
GetListForBlock
(
bo
)
-
>
RemoveBlock
(
aBlockIndex
)
;
bo
-
>
mClass
=
(
aMode
=
=
MediaCacheStream
:
:
MODE_METADATA
|
|
bo
-
>
mClass
=
=
METADATA_BLOCK
)
?
METADATA_BLOCK
:
PLAYED_BLOCK
;
GetListForBlock
(
bo
)
-
>
AddFirstBlock
(
aBlockIndex
)
;
bo
-
>
mLastUseTime
=
aNow
;
Verify
(
)
;
}
void
MediaCache
:
:
NoteSeek
(
MediaCacheStream
*
aStream
int64_t
aOldOffset
)
{
mReentrantMonitor
.
AssertCurrentThreadIn
(
)
;
if
(
aOldOffset
<
aStream
-
>
mStreamOffset
)
{
int32_t
blockIndex
=
aOldOffset
/
BLOCK_SIZE
;
int32_t
endIndex
=
std
:
:
min
<
int64_t
>
(
(
aStream
-
>
mStreamOffset
+
BLOCK_SIZE
-
1
)
/
BLOCK_SIZE
aStream
-
>
mBlocks
.
Length
(
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
while
(
blockIndex
<
endIndex
)
{
int32_t
cacheBlockIndex
=
aStream
-
>
mBlocks
[
blockIndex
]
;
if
(
cacheBlockIndex
>
=
0
)
{
NoteBlockUsage
(
aStream
cacheBlockIndex
aStream
-
>
mStreamOffset
MediaCacheStream
:
:
MODE_PLAYBACK
now
)
;
}
+
+
blockIndex
;
}
}
else
{
int32_t
blockIndex
=
(
aStream
-
>
mStreamOffset
+
BLOCK_SIZE
-
1
)
/
BLOCK_SIZE
;
int32_t
endIndex
=
std
:
:
min
<
int64_t
>
(
(
aOldOffset
+
BLOCK_SIZE
-
1
)
/
BLOCK_SIZE
aStream
-
>
mBlocks
.
Length
(
)
)
;
while
(
blockIndex
<
endIndex
)
{
MOZ_ASSERT
(
endIndex
>
0
)
;
int32_t
cacheBlockIndex
=
aStream
-
>
mBlocks
[
endIndex
-
1
]
;
if
(
cacheBlockIndex
>
=
0
)
{
BlockOwner
*
bo
=
GetBlockOwner
(
cacheBlockIndex
aStream
)
;
NS_ASSERTION
(
bo
"
Stream
doesn
'
t
own
its
blocks
?
"
)
;
if
(
bo
-
>
mClass
=
=
PLAYED_BLOCK
)
{
aStream
-
>
mPlayedBlocks
.
RemoveBlock
(
cacheBlockIndex
)
;
bo
-
>
mClass
=
READAHEAD_BLOCK
;
aStream
-
>
mReadaheadBlocks
.
AddFirstBlock
(
cacheBlockIndex
)
;
Verify
(
)
;
}
}
-
-
endIndex
;
}
}
}
void
MediaCacheStream
:
:
NotifyDataLength
(
int64_t
aLength
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
mStreamLength
=
aLength
;
}
void
MediaCacheStream
:
:
NotifyDataStarted
(
int64_t
aOffset
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
NS_WARNING_ASSERTION
(
aOffset
=
=
mChannelOffset
"
Server
is
giving
us
unexpected
offset
"
)
;
MOZ_ASSERT
(
aOffset
>
=
0
)
;
mChannelOffset
=
aOffset
;
if
(
mStreamLength
>
=
0
)
{
mStreamLength
=
std
:
:
max
(
mStreamLength
mChannelOffset
)
;
}
}
bool
MediaCacheStream
:
:
UpdatePrincipal
(
nsIPrincipal
*
aPrincipal
)
{
return
nsContentUtils
:
:
CombineResourcePrincipals
(
&
mPrincipal
aPrincipal
)
;
}
void
MediaCacheStream
:
:
NotifyDataReceived
(
int64_t
aSize
const
char
*
aData
nsIPrincipal
*
aPrincipal
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
mClosed
)
{
return
;
}
{
MediaCache
:
:
ResourceStreamIterator
iter
(
mMediaCache
mResourceID
)
;
while
(
MediaCacheStream
*
stream
=
iter
.
Next
(
)
)
{
if
(
stream
-
>
UpdatePrincipal
(
aPrincipal
)
)
{
stream
-
>
mClient
-
>
CacheClientNotifyPrincipalChanged
(
)
;
}
}
}
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
int64_t
size
=
aSize
;
const
char
*
data
=
aData
;
LOG
(
"
Stream
%
p
DataReceived
at
%
"
PRId64
"
count
=
%
"
PRId64
this
mChannelOffset
aSize
)
;
while
(
size
>
0
)
{
uint32_t
blockIndex
=
mChannelOffset
/
BLOCK_SIZE
;
int32_t
blockOffset
=
int32_t
(
mChannelOffset
-
blockIndex
*
BLOCK_SIZE
)
;
int32_t
chunkSize
=
std
:
:
min
<
int64_t
>
(
BLOCK_SIZE
-
blockOffset
size
)
;
if
(
blockOffset
=
=
0
)
{
mMetadataInPartialBlockBuffer
=
false
;
}
ReadMode
mode
=
mMetadataInPartialBlockBuffer
?
MODE_METADATA
:
MODE_PLAYBACK
;
if
(
blockOffset
+
chunkSize
=
=
BLOCK_SIZE
)
{
auto
data1
=
MakeSpan
<
const
uint8_t
>
(
mPartialBlockBuffer
.
get
(
)
blockOffset
)
;
auto
data2
=
MakeSpan
<
const
uint8_t
>
(
reinterpret_cast
<
const
uint8_t
*
>
(
data
)
chunkSize
)
;
mMediaCache
-
>
AllocateAndWriteBlock
(
this
mode
data1
data2
)
;
}
else
{
memcpy
(
mPartialBlockBuffer
.
get
(
)
+
blockOffset
data
chunkSize
)
;
}
mChannelOffset
+
=
chunkSize
;
size
-
=
chunkSize
;
data
+
=
chunkSize
;
}
MediaCache
:
:
ResourceStreamIterator
iter
(
mMediaCache
mResourceID
)
;
while
(
MediaCacheStream
*
stream
=
iter
.
Next
(
)
)
{
if
(
stream
-
>
mStreamLength
>
=
0
)
{
stream
-
>
mStreamLength
=
std
:
:
max
(
stream
-
>
mStreamLength
mChannelOffset
)
;
}
stream
-
>
mClient
-
>
CacheClientNotifyDataReceived
(
)
;
}
mon
.
NotifyAll
(
)
;
}
void
MediaCacheStream
:
:
FlushPartialBlockInternal
(
bool
aNotifyAll
ReentrantMonitorAutoEnter
&
aReentrantMonitor
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
int32_t
blockOffset
=
int32_t
(
mChannelOffset
%
BLOCK_SIZE
)
;
if
(
blockOffset
>
0
)
{
LOG
(
"
Stream
%
p
writing
partial
block
:
[
%
d
]
bytes
;
"
"
mStreamOffset
[
%
"
PRId64
"
]
mChannelOffset
[
%
"
PRId64
"
]
mStreamLength
[
%
"
PRId64
"
]
notifying
:
[
%
s
]
"
this
blockOffset
mStreamOffset
mChannelOffset
mStreamLength
aNotifyAll
?
"
yes
"
:
"
no
"
)
;
memset
(
mPartialBlockBuffer
.
get
(
)
+
blockOffset
0
BLOCK_SIZE
-
blockOffset
)
;
auto
data
=
MakeSpan
<
const
uint8_t
>
(
mPartialBlockBuffer
.
get
(
)
BLOCK_SIZE
)
;
mMediaCache
-
>
AllocateAndWriteBlock
(
this
mMetadataInPartialBlockBuffer
?
MODE_METADATA
:
MODE_PLAYBACK
data
)
;
}
if
(
(
blockOffset
>
0
|
|
mChannelOffset
=
=
0
)
&
&
aNotifyAll
)
{
aReentrantMonitor
.
NotifyAll
(
)
;
}
}
void
MediaCacheStream
:
:
FlushPartialBlock
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
FlushPartialBlockInternal
(
false
mon
)
;
mMediaCache
-
>
QueueUpdate
(
)
;
}
void
MediaCacheStream
:
:
NotifyDataEnded
(
nsresult
aStatus
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
if
(
NS_FAILED
(
aStatus
)
)
{
mResourceID
=
mMediaCache
-
>
AllocateResourceID
(
)
;
}
FlushPartialBlockInternal
(
true
mon
)
;
mChannelEnded
=
true
;
mMediaCache
-
>
QueueUpdate
(
)
;
MediaCache
:
:
ResourceStreamIterator
iter
(
mMediaCache
mResourceID
)
;
while
(
MediaCacheStream
*
stream
=
iter
.
Next
(
)
)
{
if
(
NS_SUCCEEDED
(
aStatus
)
)
{
stream
-
>
mStreamLength
=
mChannelOffset
;
}
if
(
!
stream
-
>
mDidNotifyDataEnded
)
{
stream
-
>
mDidNotifyDataEnded
=
true
;
stream
-
>
mNotifyDataEndedStatus
=
aStatus
;
stream
-
>
mClient
-
>
CacheClientNotifyDataEnded
(
aStatus
)
;
}
}
}
void
MediaCacheStream
:
:
NotifyChannelRecreated
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
mChannelEnded
=
false
;
mDidNotifyDataEnded
=
false
;
}
MediaCacheStream
:
:
~
MediaCacheStream
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
NS_ASSERTION
(
!
mPinCount
"
Unbalanced
Pin
"
)
;
if
(
mMediaCache
)
{
NS_ASSERTION
(
mClosed
"
Stream
was
not
closed
"
)
;
mMediaCache
-
>
ReleaseStream
(
this
)
;
}
uint32_t
lengthKb
=
uint32_t
(
std
:
:
min
(
std
:
:
max
(
mStreamLength
int64_t
(
0
)
)
/
1024
int64_t
(
UINT32_MAX
)
)
)
;
LOG
(
"
MediaCacheStream
:
:
~
MediaCacheStream
(
this
=
%
p
)
"
"
MEDIACACHESTREAM_LENGTH_KB
=
%
"
PRIu32
this
lengthKb
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HistogramID
:
:
MEDIACACHESTREAM_LENGTH_KB
lengthKb
)
;
}
void
MediaCacheStream
:
:
SetTransportSeekable
(
bool
aIsTransportSeekable
)
{
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
NS_ASSERTION
(
mIsTransportSeekable
|
|
aIsTransportSeekable
|
|
mChannelOffset
=
=
0
"
channel
offset
must
be
zero
when
we
become
non
-
seekable
"
)
;
mIsTransportSeekable
=
aIsTransportSeekable
;
mMediaCache
-
>
QueueUpdate
(
)
;
}
bool
MediaCacheStream
:
:
IsTransportSeekable
(
)
{
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
return
mIsTransportSeekable
;
}
bool
MediaCacheStream
:
:
AreAllStreamsForResourceSuspended
(
)
{
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
MediaCache
:
:
ResourceStreamIterator
iter
(
mMediaCache
mResourceID
)
;
int64_t
dataOffset
=
-
1
;
while
(
MediaCacheStream
*
stream
=
iter
.
Next
(
)
)
{
if
(
stream
-
>
mCacheSuspended
|
|
stream
-
>
mChannelEnded
|
|
stream
-
>
mClosed
)
{
continue
;
}
if
(
dataOffset
<
0
)
{
dataOffset
=
GetCachedDataEndInternal
(
mStreamOffset
)
;
}
if
(
stream
-
>
mChannelOffset
>
dataOffset
)
{
continue
;
}
return
false
;
}
return
true
;
}
void
MediaCacheStream
:
:
Close
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
!
mMediaCache
)
{
return
;
}
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
CloseInternal
(
mon
)
;
mMediaCache
-
>
QueueUpdate
(
)
;
}
void
MediaCacheStream
:
:
EnsureCacheUpdate
(
)
{
if
(
mHasHadUpdate
)
return
;
mMediaCache
-
>
Update
(
)
;
}
void
MediaCacheStream
:
:
CloseInternal
(
ReentrantMonitorAutoEnter
&
aReentrantMonitor
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
mClosed
)
return
;
mClosed
=
true
;
mMediaCache
-
>
QueueSuspendedStatusUpdate
(
mResourceID
)
;
mMediaCache
-
>
ReleaseStreamBlocks
(
this
)
;
aReentrantMonitor
.
NotifyAll
(
)
;
}
void
MediaCacheStream
:
:
Pin
(
)
{
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
+
+
mPinCount
;
mMediaCache
-
>
QueueUpdate
(
)
;
}
void
MediaCacheStream
:
:
Unpin
(
)
{
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
NS_ASSERTION
(
mPinCount
>
0
"
Unbalanced
Unpin
"
)
;
-
-
mPinCount
;
mMediaCache
-
>
QueueUpdate
(
)
;
}
int64_t
MediaCacheStream
:
:
GetLength
(
)
{
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
return
mStreamLength
;
}
int64_t
MediaCacheStream
:
:
GetNextCachedData
(
int64_t
aOffset
)
{
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
return
GetNextCachedDataInternal
(
aOffset
)
;
}
int64_t
MediaCacheStream
:
:
GetCachedDataEnd
(
int64_t
aOffset
)
{
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
return
GetCachedDataEndInternal
(
aOffset
)
;
}
bool
MediaCacheStream
:
:
IsDataCachedToEndOfStream
(
int64_t
aOffset
)
{
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
if
(
mStreamLength
<
0
)
return
false
;
return
GetCachedDataEndInternal
(
aOffset
)
>
=
mStreamLength
;
}
int64_t
MediaCacheStream
:
:
GetCachedDataEndInternal
(
int64_t
aOffset
)
{
mMediaCache
-
>
GetReentrantMonitor
(
)
.
AssertCurrentThreadIn
(
)
;
uint32_t
startBlockIndex
=
aOffset
/
BLOCK_SIZE
;
uint32_t
blockIndex
=
startBlockIndex
;
while
(
blockIndex
<
mBlocks
.
Length
(
)
&
&
mBlocks
[
blockIndex
]
!
=
-
1
)
{
+
+
blockIndex
;
}
int64_t
result
=
blockIndex
*
BLOCK_SIZE
;
if
(
blockIndex
=
=
mChannelOffset
/
BLOCK_SIZE
)
{
result
=
mChannelOffset
;
}
if
(
mStreamLength
>
=
0
)
{
result
=
std
:
:
min
(
result
mStreamLength
)
;
}
return
std
:
:
max
(
result
aOffset
)
;
}
int64_t
MediaCacheStream
:
:
GetNextCachedDataInternal
(
int64_t
aOffset
)
{
mMediaCache
-
>
GetReentrantMonitor
(
)
.
AssertCurrentThreadIn
(
)
;
if
(
aOffset
=
=
mStreamLength
)
return
-
1
;
uint32_t
startBlockIndex
=
aOffset
/
BLOCK_SIZE
;
uint32_t
channelBlockIndex
=
mChannelOffset
/
BLOCK_SIZE
;
if
(
startBlockIndex
=
=
channelBlockIndex
&
&
aOffset
<
mChannelOffset
)
{
return
aOffset
;
}
if
(
startBlockIndex
>
=
mBlocks
.
Length
(
)
)
return
-
1
;
if
(
mBlocks
[
startBlockIndex
]
!
=
-
1
)
return
aOffset
;
bool
hasPartialBlock
=
(
mChannelOffset
%
BLOCK_SIZE
)
!
=
0
;
uint32_t
blockIndex
=
startBlockIndex
+
1
;
while
(
true
)
{
if
(
(
hasPartialBlock
&
&
blockIndex
=
=
channelBlockIndex
)
|
|
(
blockIndex
<
mBlocks
.
Length
(
)
&
&
mBlocks
[
blockIndex
]
!
=
-
1
)
)
{
return
blockIndex
*
BLOCK_SIZE
;
}
if
(
blockIndex
>
=
mBlocks
.
Length
(
)
)
return
-
1
;
+
+
blockIndex
;
}
NS_NOTREACHED
(
"
Should
return
in
loop
"
)
;
return
-
1
;
}
void
MediaCacheStream
:
:
SetReadMode
(
ReadMode
aMode
)
{
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
if
(
aMode
=
=
mCurrentMode
)
return
;
mCurrentMode
=
aMode
;
mMediaCache
-
>
QueueUpdate
(
)
;
}
void
MediaCacheStream
:
:
SetPlaybackRate
(
uint32_t
aBytesPerSecond
)
{
NS_ASSERTION
(
aBytesPerSecond
>
0
"
Zero
playback
rate
not
allowed
"
)
;
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
if
(
aBytesPerSecond
=
=
mPlaybackBytesPerSecond
)
return
;
mPlaybackBytesPerSecond
=
aBytesPerSecond
;
mMediaCache
-
>
QueueUpdate
(
)
;
}
nsresult
MediaCacheStream
:
:
SeekInternal
(
int64_t
aOffset
)
{
if
(
aOffset
<
0
)
{
return
NS_ERROR_FAILURE
;
}
mMediaCache
-
>
GetReentrantMonitor
(
)
.
AssertCurrentThreadIn
(
)
;
if
(
mClosed
)
{
return
NS_ERROR_FAILURE
;
}
int64_t
oldOffset
=
mStreamOffset
;
mStreamOffset
=
aOffset
;
LOG
(
"
Stream
%
p
Seek
to
%
"
PRId64
this
mStreamOffset
)
;
mMediaCache
-
>
NoteSeek
(
this
oldOffset
)
;
mMediaCache
-
>
QueueUpdate
(
)
;
return
NS_OK
;
}
void
MediaCacheStream
:
:
ThrottleReadahead
(
bool
bThrottle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mThrottleReadahead
!
=
bThrottle
)
{
LOGI
(
"
Stream
%
p
ThrottleReadahead
%
d
"
this
bThrottle
)
;
mThrottleReadahead
=
bThrottle
;
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
mMediaCache
-
>
QueueUpdate
(
)
;
}
}
int64_t
MediaCacheStream
:
:
Tell
(
)
{
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
return
mStreamOffset
;
}
nsresult
MediaCacheStream
:
:
ReadInternal
(
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
{
mMediaCache
-
>
GetReentrantMonitor
(
)
.
AssertCurrentThreadIn
(
)
;
if
(
mClosed
)
return
NS_ERROR_FAILURE
;
auto
streamOffset
=
mStreamOffset
;
uint32_t
count
=
0
;
while
(
count
<
aCount
)
{
uint32_t
streamBlock
=
uint32_t
(
streamOffset
/
BLOCK_SIZE
)
;
uint32_t
offsetInStreamBlock
=
uint32_t
(
streamOffset
-
streamBlock
*
BLOCK_SIZE
)
;
int64_t
size
=
std
:
:
min
<
int64_t
>
(
aCount
-
count
BLOCK_SIZE
-
offsetInStreamBlock
)
;
if
(
mStreamLength
>
=
0
)
{
int64_t
bytesRemaining
=
mStreamLength
-
streamOffset
;
if
(
bytesRemaining
<
=
0
)
{
break
;
}
size
=
std
:
:
min
(
size
bytesRemaining
)
;
size
=
std
:
:
min
(
size
int64_t
(
INT32_MAX
)
)
;
}
int32_t
cacheBlock
=
streamBlock
<
mBlocks
.
Length
(
)
?
mBlocks
[
streamBlock
]
:
-
1
;
if
(
cacheBlock
<
0
)
{
if
(
count
>
0
)
{
break
;
}
MediaCacheStream
*
streamWithPartialBlock
=
nullptr
;
MediaCache
:
:
ResourceStreamIterator
iter
(
mMediaCache
mResourceID
)
;
while
(
MediaCacheStream
*
stream
=
iter
.
Next
(
)
)
{
if
(
uint32_t
(
stream
-
>
mChannelOffset
/
BLOCK_SIZE
)
=
=
streamBlock
&
&
streamOffset
<
stream
-
>
mChannelOffset
)
{
streamWithPartialBlock
=
stream
;
break
;
}
}
if
(
streamWithPartialBlock
)
{
int64_t
bytes
=
std
:
:
min
<
int64_t
>
(
size
streamWithPartialBlock
-
>
mChannelOffset
-
streamOffset
)
;
bytes
=
std
:
:
min
(
bytes
int64_t
(
INT32_MAX
)
)
;
MOZ_ASSERT
(
bytes
>
=
0
&
&
bytes
<
=
aCount
"
Bytes
out
of
range
.
"
)
;
memcpy
(
aBuffer
streamWithPartialBlock
-
>
mPartialBlockBuffer
.
get
(
)
+
offsetInStreamBlock
bytes
)
;
if
(
mCurrentMode
=
=
MODE_METADATA
)
{
streamWithPartialBlock
-
>
mMetadataInPartialBlockBuffer
=
true
;
}
streamOffset
+
=
bytes
;
count
=
bytes
;
break
;
}
mMediaCache
-
>
GetReentrantMonitor
(
)
.
Wait
(
)
;
if
(
mClosed
)
{
return
NS_ERROR_FAILURE
;
}
continue
;
}
mMediaCache
-
>
NoteBlockUsage
(
this
cacheBlock
streamOffset
mCurrentMode
TimeStamp
:
:
Now
(
)
)
;
int64_t
offset
=
cacheBlock
*
BLOCK_SIZE
+
offsetInStreamBlock
;
int32_t
bytes
;
MOZ_ASSERT
(
size
>
=
0
&
&
size
<
=
INT32_MAX
"
Size
out
of
range
.
"
)
;
nsresult
rv
=
mMediaCache
-
>
ReadCacheFile
(
offset
aBuffer
+
count
int32_t
(
size
)
&
bytes
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
count
=
=
0
)
return
rv
;
break
;
}
streamOffset
+
=
bytes
;
count
+
=
bytes
;
}
if
(
count
>
0
)
{
mMediaCache
-
>
QueueUpdate
(
)
;
}
LOG
(
"
Stream
%
p
Read
at
%
"
PRId64
"
count
=
%
d
"
this
streamOffset
-
count
count
)
;
*
aBytes
=
count
;
mStreamOffset
=
streamOffset
;
return
NS_OK
;
}
nsresult
MediaCacheStream
:
:
ReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
{
NS_ASSERTION
(
!
NS_IsMainThread
(
)
"
Don
'
t
call
on
main
thread
"
)
;
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
nsresult
rv
=
SeekInternal
(
aOffset
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
ReadInternal
(
aBuffer
aCount
aBytes
)
;
}
nsresult
MediaCacheStream
:
:
ReadFromCache
(
char
*
aBuffer
int64_t
aOffset
int64_t
aCount
)
{
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
uint32_t
count
=
0
;
int64_t
streamOffset
=
aOffset
;
while
(
count
<
aCount
)
{
if
(
mClosed
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
streamBlock
=
uint32_t
(
streamOffset
/
BLOCK_SIZE
)
;
uint32_t
offsetInStreamBlock
=
uint32_t
(
streamOffset
-
streamBlock
*
BLOCK_SIZE
)
;
int64_t
size
=
std
:
:
min
<
int64_t
>
(
aCount
-
count
BLOCK_SIZE
-
offsetInStreamBlock
)
;
if
(
mStreamLength
>
=
0
)
{
int64_t
bytesRemaining
=
mStreamLength
-
streamOffset
;
if
(
bytesRemaining
<
=
0
)
{
return
NS_ERROR_FAILURE
;
}
size
=
std
:
:
min
(
size
bytesRemaining
)
;
size
=
std
:
:
min
(
size
int64_t
(
INT32_MAX
)
)
;
}
int32_t
bytes
;
uint32_t
channelBlock
=
uint32_t
(
mChannelOffset
/
BLOCK_SIZE
)
;
int32_t
cacheBlock
=
streamBlock
<
mBlocks
.
Length
(
)
?
mBlocks
[
streamBlock
]
:
-
1
;
if
(
channelBlock
=
=
streamBlock
&
&
streamOffset
<
mChannelOffset
)
{
int64_t
toCopy
=
std
:
:
min
<
int64_t
>
(
size
mChannelOffset
-
streamOffset
)
;
bytes
=
std
:
:
min
(
toCopy
int64_t
(
INT32_MAX
)
)
;
MOZ_ASSERT
(
bytes
>
=
0
&
&
bytes
<
=
toCopy
"
Bytes
out
of
range
.
"
)
;
memcpy
(
aBuffer
+
count
mPartialBlockBuffer
.
get
(
)
+
offsetInStreamBlock
bytes
)
;
}
else
{
if
(
cacheBlock
<
0
)
{
return
NS_ERROR_FAILURE
;
}
int64_t
offset
=
cacheBlock
*
BLOCK_SIZE
+
offsetInStreamBlock
;
MOZ_ASSERT
(
size
>
=
0
&
&
size
<
=
INT32_MAX
"
Size
out
of
range
.
"
)
;
nsresult
rv
=
mMediaCache
-
>
ReadCacheFile
(
offset
aBuffer
+
count
int32_t
(
size
)
&
bytes
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
streamOffset
+
=
bytes
;
count
+
=
bytes
;
}
return
NS_OK
;
}
nsresult
MediaCacheStream
:
:
Init
(
int64_t
aContentLength
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
mMediaCache
)
{
return
NS_OK
;
}
if
(
aContentLength
>
0
)
{
uint32_t
length
=
uint32_t
(
std
:
:
min
(
aContentLength
int64_t
(
UINT32_MAX
)
)
)
;
LOG
(
"
MediaCacheStream
:
:
NotifyDataLength
(
this
=
%
p
)
"
"
MEDIACACHESTREAM_NOTIFIED_LENGTH
=
%
"
PRIu32
this
length
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HistogramID
:
:
MEDIACACHESTREAM_NOTIFIED_LENGTH
length
)
;
mStreamLength
=
aContentLength
;
}
mMediaCache
=
MediaCache
:
:
GetMediaCache
(
aContentLength
)
;
if
(
!
mMediaCache
)
{
return
NS_ERROR_FAILURE
;
}
mMediaCache
-
>
OpenStream
(
this
)
;
return
NS_OK
;
}
nsresult
MediaCacheStream
:
:
InitAsClone
(
MediaCacheStream
*
aOriginal
)
{
if
(
!
aOriginal
-
>
IsAvailableForSharing
(
)
)
return
NS_ERROR_FAILURE
;
if
(
mMediaCache
)
{
return
NS_OK
;
}
NS_ASSERTION
(
aOriginal
-
>
mMediaCache
"
Don
'
t
clone
an
uninitialized
stream
"
)
;
mMediaCache
=
aOriginal
-
>
mMediaCache
;
mMediaCache
-
>
OpenStream
(
this
)
;
mResourceID
=
aOriginal
-
>
mResourceID
;
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
mPrincipal
=
aOriginal
-
>
mPrincipal
;
mStreamLength
=
aOriginal
-
>
mStreamLength
;
mIsTransportSeekable
=
aOriginal
-
>
mIsTransportSeekable
;
mCacheSuspended
=
true
;
mChannelEnded
=
true
;
if
(
aOriginal
-
>
mDidNotifyDataEnded
)
{
mNotifyDataEndedStatus
=
aOriginal
-
>
mNotifyDataEndedStatus
;
mDidNotifyDataEnded
=
true
;
mClient
-
>
CacheClientNotifyDataEnded
(
mNotifyDataEndedStatus
)
;
}
for
(
uint32_t
i
=
0
;
i
<
aOriginal
-
>
mBlocks
.
Length
(
)
;
+
+
i
)
{
int32_t
cacheBlockIndex
=
aOriginal
-
>
mBlocks
[
i
]
;
if
(
cacheBlockIndex
<
0
)
continue
;
while
(
i
>
=
mBlocks
.
Length
(
)
)
{
mBlocks
.
AppendElement
(
-
1
)
;
}
mMediaCache
-
>
AddBlockOwnerAsReadahead
(
cacheBlockIndex
this
i
)
;
}
return
NS_OK
;
}
nsresult
MediaCacheStream
:
:
GetCachedRanges
(
MediaByteRangeSet
&
aRanges
)
{
ReentrantMonitorAutoEnter
mon
(
mMediaCache
-
>
GetReentrantMonitor
(
)
)
;
NS_ASSERTION
(
mPinCount
>
0
"
Must
be
pinned
"
)
;
int64_t
startOffset
=
GetNextCachedDataInternal
(
0
)
;
while
(
startOffset
>
=
0
)
{
int64_t
endOffset
=
GetCachedDataEndInternal
(
startOffset
)
;
NS_ASSERTION
(
startOffset
<
endOffset
"
Buffered
range
must
end
after
its
start
"
)
;
aRanges
+
=
MediaByteRange
(
startOffset
endOffset
)
;
startOffset
=
GetNextCachedDataInternal
(
endOffset
)
;
NS_ASSERTION
(
startOffset
=
=
-
1
|
|
startOffset
>
endOffset
"
Must
have
advanced
to
start
of
next
range
or
hit
end
of
stream
"
)
;
}
return
NS_OK
;
}
}
#
undef
LOG
#
undef
LOGI
