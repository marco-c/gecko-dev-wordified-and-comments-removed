#
include
"
AudioStreamTrack
.
h
"
#
include
"
MediaTrackGraph
.
h
"
#
include
"
nsContentUtils
.
h
"
namespace
mozilla
:
:
dom
{
RefPtr
<
GenericPromise
>
AudioStreamTrack
:
:
AddAudioOutput
(
void
*
aKey
AudioDeviceInfo
*
aSink
)
{
MOZ_ASSERT
(
!
mCrossGraphs
.
Get
(
aKey
)
"
A
previous
audio
output
for
this
aKey
should
have
been
removed
"
)
;
if
(
Ended
(
)
)
{
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
UniquePtr
<
CrossGraphPort
>
manager
;
if
(
!
aSink
|
|
!
(
manager
=
CrossGraphPort
:
:
Connect
(
this
aSink
mWindow
)
)
)
{
mTrack
-
>
AddAudioOutput
(
aKey
)
;
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
const
UniquePtr
<
CrossGraphPort
>
&
crossGraph
=
mCrossGraphs
.
WithEntryHandle
(
aKey
[
&
manager
]
(
auto
entry
)
-
>
UniquePtr
<
CrossGraphPort
>
&
{
return
entry
.
Insert
(
std
:
:
move
(
manager
)
)
;
}
)
;
crossGraph
-
>
AddAudioOutput
(
aKey
)
;
return
crossGraph
-
>
EnsureConnected
(
)
;
}
void
AudioStreamTrack
:
:
RemoveAudioOutput
(
void
*
aKey
)
{
if
(
Ended
(
)
)
{
return
;
}
if
(
auto
entry
=
mCrossGraphs
.
Lookup
(
aKey
)
)
{
entry
.
Remove
(
)
;
return
;
}
mTrack
-
>
RemoveAudioOutput
(
aKey
)
;
}
void
AudioStreamTrack
:
:
SetAudioOutputVolume
(
void
*
aKey
float
aVolume
)
{
if
(
Ended
(
)
)
{
return
;
}
if
(
CrossGraphPort
*
cgm
=
mCrossGraphs
.
Get
(
aKey
)
)
{
cgm
-
>
SetAudioOutputVolume
(
aKey
aVolume
)
;
return
;
}
mTrack
-
>
SetAudioOutputVolume
(
aKey
aVolume
)
;
}
void
AudioStreamTrack
:
:
GetLabel
(
nsAString
&
aLabel
CallerType
aCallerType
)
{
nsIGlobalObject
*
global
=
GetParentObject
(
)
?
GetParentObject
(
)
-
>
AsGlobal
(
)
:
nullptr
;
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
aCallerType
global
RFPTarget
:
:
StreamTrackLabel
)
)
{
aLabel
.
AssignLiteral
(
"
Internal
Microphone
"
)
;
return
;
}
MediaStreamTrack
:
:
GetLabel
(
aLabel
aCallerType
)
;
}
already_AddRefed
<
MediaStreamTrack
>
AudioStreamTrack
:
:
CloneInternal
(
)
{
return
do_AddRef
(
new
AudioStreamTrack
(
mWindow
mInputTrack
mSource
ReadyState
(
)
Muted
(
)
mConstraints
)
)
;
}
void
AudioStreamTrack
:
:
SetReadyState
(
MediaStreamTrackState
aState
)
{
if
(
!
mCrossGraphs
.
IsEmpty
(
)
&
&
!
Ended
(
)
&
&
mReadyState
=
=
MediaStreamTrackState
:
:
Live
&
&
aState
=
=
MediaStreamTrackState
:
:
Ended
)
{
mCrossGraphs
.
Clear
(
)
;
}
MediaStreamTrack
:
:
SetReadyState
(
aState
)
;
}
}
