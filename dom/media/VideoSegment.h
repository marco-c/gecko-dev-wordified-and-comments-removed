#
ifndef
MOZILLA_VIDEOSEGMENT_H_
#
define
MOZILLA_VIDEOSEGMENT_H_
#
include
"
MediaSegment
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
ImageContainer
.
h
"
namespace
mozilla
{
namespace
layers
{
class
Image
;
}
class
VideoFrame
{
public
:
typedef
mozilla
:
:
layers
:
:
Image
Image
;
VideoFrame
(
already_AddRefed
<
Image
>
&
aImage
const
gfx
:
:
IntSize
&
aIntrinsicSize
)
;
VideoFrame
(
)
;
~
VideoFrame
(
)
;
bool
operator
=
=
(
const
VideoFrame
&
aFrame
)
const
{
return
mIntrinsicSize
=
=
aFrame
.
mIntrinsicSize
&
&
mForceBlack
=
=
aFrame
.
mForceBlack
&
&
(
(
mForceBlack
&
&
aFrame
.
mForceBlack
)
|
|
mImage
=
=
aFrame
.
mImage
)
&
&
mPrincipalHandle
=
=
aFrame
.
mPrincipalHandle
;
}
bool
operator
!
=
(
const
VideoFrame
&
aFrame
)
const
{
return
!
operator
=
=
(
aFrame
)
;
}
Image
*
GetImage
(
)
const
{
return
mImage
;
}
void
SetForceBlack
(
bool
aForceBlack
)
{
mForceBlack
=
aForceBlack
;
}
bool
GetForceBlack
(
)
const
{
return
mForceBlack
;
}
void
SetPrincipalHandle
(
PrincipalHandle
aPrincipalHandle
)
{
mPrincipalHandle
=
std
:
:
forward
<
PrincipalHandle
>
(
aPrincipalHandle
)
;
}
const
PrincipalHandle
&
GetPrincipalHandle
(
)
const
{
return
mPrincipalHandle
;
}
const
gfx
:
:
IntSize
&
GetIntrinsicSize
(
)
const
{
return
mIntrinsicSize
;
}
void
SetNull
(
)
;
void
TakeFrom
(
VideoFrame
*
aFrame
)
;
static
already_AddRefed
<
Image
>
CreateBlackImage
(
const
gfx
:
:
IntSize
&
aSize
)
;
protected
:
RefPtr
<
Image
>
mImage
;
gfx
:
:
IntSize
mIntrinsicSize
;
bool
mForceBlack
;
PrincipalHandle
mPrincipalHandle
;
}
;
struct
VideoChunk
{
void
SliceTo
(
StreamTime
aStart
StreamTime
aEnd
)
{
NS_ASSERTION
(
aStart
>
=
0
&
&
aStart
<
aEnd
&
&
aEnd
<
=
mDuration
"
Slice
out
of
bounds
"
)
;
mDuration
=
aEnd
-
aStart
;
}
StreamTime
GetDuration
(
)
const
{
return
mDuration
;
}
bool
CanCombineWithFollowing
(
const
VideoChunk
&
aOther
)
const
{
return
aOther
.
mFrame
=
=
mFrame
;
}
bool
IsNull
(
)
const
{
return
!
mFrame
.
GetImage
(
)
;
}
void
SetNull
(
StreamTime
aDuration
)
{
mDuration
=
aDuration
;
mFrame
.
SetNull
(
)
;
mTimeStamp
=
TimeStamp
(
)
;
}
void
SetForceBlack
(
bool
aForceBlack
)
{
mFrame
.
SetForceBlack
(
aForceBlack
)
;
}
size_t
SizeOfExcludingThisIfUnshared
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
const
PrincipalHandle
&
GetPrincipalHandle
(
)
const
{
return
mFrame
.
GetPrincipalHandle
(
)
;
}
StreamTime
mDuration
;
VideoFrame
mFrame
;
TimeStamp
mTimeStamp
;
}
;
class
VideoSegment
:
public
MediaSegmentBase
<
VideoSegment
VideoChunk
>
{
public
:
typedef
mozilla
:
:
layers
:
:
Image
Image
;
typedef
mozilla
:
:
gfx
:
:
IntSize
IntSize
;
VideoSegment
(
)
;
VideoSegment
(
VideoSegment
&
&
aSegment
)
;
VideoSegment
(
const
VideoSegment
&
)
=
delete
;
VideoSegment
&
operator
=
(
const
VideoSegment
&
)
=
delete
;
~
VideoSegment
(
)
;
void
AppendFrame
(
already_AddRefed
<
Image
>
&
&
aImage
StreamTime
aDuration
const
IntSize
&
aIntrinsicSize
const
PrincipalHandle
&
aPrincipalHandle
bool
aForceBlack
=
false
TimeStamp
aTimeStamp
=
TimeStamp
:
:
Now
(
)
)
;
const
VideoFrame
*
GetLastFrame
(
StreamTime
*
aStart
=
nullptr
)
{
VideoChunk
*
c
=
GetLastChunk
(
)
;
if
(
!
c
)
{
return
nullptr
;
}
if
(
aStart
)
{
*
aStart
=
mDuration
-
c
-
>
mDuration
;
}
return
&
c
-
>
mFrame
;
}
VideoChunk
*
FindChunkContainingTime
(
const
TimeStamp
&
aTime
)
{
VideoChunk
*
previousChunk
=
nullptr
;
for
(
VideoChunk
&
c
:
mChunks
)
{
if
(
c
.
mTimeStamp
.
IsNull
(
)
)
{
continue
;
}
if
(
c
.
mTimeStamp
>
aTime
)
{
return
previousChunk
;
}
previousChunk
=
&
c
;
}
return
previousChunk
;
}
void
ForgetUpToTime
(
const
TimeStamp
&
aTime
)
{
VideoChunk
*
chunk
=
FindChunkContainingTime
(
aTime
)
;
if
(
!
chunk
)
{
return
;
}
StreamTime
duration
=
0
;
size_t
chunksToRemove
=
0
;
for
(
const
VideoChunk
&
c
:
mChunks
)
{
if
(
c
.
mTimeStamp
>
=
chunk
-
>
mTimeStamp
)
{
break
;
}
duration
+
=
c
.
GetDuration
(
)
;
+
+
chunksToRemove
;
}
mChunks
.
RemoveElementsAt
(
0
chunksToRemove
)
;
mDuration
-
=
duration
;
MOZ_ASSERT
(
mChunks
.
Capacity
(
)
>
=
DEFAULT_SEGMENT_CAPACITY
"
Capacity
must
be
retained
after
removing
chunks
"
)
;
}
void
ReplaceWithDisabled
(
)
override
{
for
(
ChunkIterator
i
(
*
this
)
;
!
i
.
IsEnded
(
)
;
i
.
Next
(
)
)
{
VideoChunk
&
chunk
=
*
i
;
chunk
.
SetForceBlack
(
true
)
;
}
}
static
Type
StaticType
(
)
{
return
VIDEO
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
bool
IsEmpty
(
)
const
{
return
mChunks
.
IsEmpty
(
)
;
}
}
;
}
#
endif
