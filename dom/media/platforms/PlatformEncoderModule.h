#
if
!
defined
(
PlatformEncoderModule_h_
)
#
define
PlatformEncoderModule_h_
#
include
"
MP4Decoder
.
h
"
#
include
"
MediaCodecsSupport
.
h
"
#
include
"
MediaResult
.
h
"
#
include
"
VPXDecoder
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmapBinding
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
EncoderConfig
.
h
"
namespace
mozilla
{
class
MediaDataEncoder
;
class
MediaData
;
struct
EncoderConfigurationChangeList
;
class
PlatformEncoderModule
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
PlatformEncoderModule
)
virtual
already_AddRefed
<
MediaDataEncoder
>
CreateVideoEncoder
(
const
EncoderConfig
&
aConfig
const
RefPtr
<
TaskQueue
>
&
aTaskQueue
)
const
{
return
nullptr
;
}
;
virtual
already_AddRefed
<
MediaDataEncoder
>
CreateAudioEncoder
(
const
EncoderConfig
&
aConfig
const
RefPtr
<
TaskQueue
>
&
aTaskQueue
)
const
{
return
nullptr
;
}
;
using
CreateEncoderPromise
=
MozPromise
<
RefPtr
<
MediaDataEncoder
>
MediaResult
true
>
;
virtual
media
:
:
EncodeSupportSet
Supports
(
const
EncoderConfig
&
aConfig
)
const
=
0
;
virtual
media
:
:
EncodeSupportSet
SupportsCodec
(
CodecType
aCodecType
)
const
=
0
;
virtual
const
char
*
GetName
(
)
const
=
0
;
RefPtr
<
PlatformEncoderModule
:
:
CreateEncoderPromise
>
AsyncCreateEncoder
(
const
EncoderConfig
&
aEncoderConfig
const
RefPtr
<
TaskQueue
>
&
aTaskQueue
)
;
protected
:
PlatformEncoderModule
(
)
=
default
;
virtual
~
PlatformEncoderModule
(
)
=
default
;
}
;
class
MediaDataEncoder
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
static
bool
IsVideo
(
const
CodecType
aCodec
)
{
return
aCodec
>
CodecType
:
:
_BeginVideo_
&
&
aCodec
<
CodecType
:
:
_EndVideo_
;
}
static
bool
IsAudio
(
const
CodecType
aCodec
)
{
return
aCodec
>
CodecType
:
:
_BeginAudio_
&
&
aCodec
<
CodecType
:
:
_EndAudio_
;
}
using
InitPromise
=
MozPromise
<
bool
MediaResult
true
>
;
using
EncodedData
=
nsTArray
<
RefPtr
<
MediaRawData
>
>
;
using
EncodePromise
=
MozPromise
<
EncodedData
MediaResult
true
>
;
using
ReconfigurationPromise
=
MozPromise
<
bool
MediaResult
true
>
;
virtual
RefPtr
<
InitPromise
>
Init
(
)
=
0
;
virtual
RefPtr
<
EncodePromise
>
Encode
(
const
MediaData
*
aSample
)
=
0
;
virtual
RefPtr
<
ReconfigurationPromise
>
Reconfigure
(
const
RefPtr
<
const
EncoderConfigurationChangeList
>
&
aConfigurationChanges
)
=
0
;
virtual
RefPtr
<
EncodePromise
>
Drain
(
)
=
0
;
virtual
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
=
0
;
virtual
RefPtr
<
GenericPromise
>
SetBitrate
(
uint32_t
aBitsPerSec
)
{
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
virtual
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
{
return
false
;
}
virtual
nsCString
GetDescriptionName
(
)
const
=
0
;
friend
class
PlatformEncoderModule
;
protected
:
virtual
~
MediaDataEncoder
(
)
=
default
;
}
;
template
<
typename
T
typename
Phantom
>
class
StrongTypedef
{
public
:
explicit
StrongTypedef
(
T
const
&
value
)
:
mValue
(
value
)
{
}
explicit
StrongTypedef
(
T
&
&
value
)
:
mValue
(
std
:
:
move
(
value
)
)
{
}
T
&
get
(
)
{
return
mValue
;
}
T
const
&
get
(
)
const
{
return
mValue
;
}
private
:
T
mValue
;
}
;
using
DimensionsChange
=
StrongTypedef
<
gfx
:
:
IntSize
struct
DimensionsChangeType
>
;
using
DisplayDimensionsChange
=
StrongTypedef
<
Maybe
<
gfx
:
:
IntSize
>
struct
DisplayDimensionsChangeType
>
;
using
BitrateChange
=
StrongTypedef
<
Maybe
<
uint32_t
>
struct
BitrateChangeType
>
;
using
FramerateChange
=
StrongTypedef
<
Maybe
<
double
>
struct
FramerateChangeType
>
;
using
BitrateModeChange
=
StrongTypedef
<
BitrateMode
struct
BitrateModeChangeType
>
;
using
UsageChange
=
StrongTypedef
<
Usage
struct
UsageChangeType
>
;
using
ContentHintChange
=
StrongTypedef
<
Maybe
<
nsString
>
struct
ContentHintTypeType
>
;
using
SampleRateChange
=
StrongTypedef
<
uint32_t
struct
SampleRateChangeType
>
;
using
NumberOfChannelsChange
=
StrongTypedef
<
uint32_t
struct
NumberOfChannelsChangeType
>
;
using
EncoderConfigurationItem
=
Variant
<
DimensionsChange
DisplayDimensionsChange
BitrateModeChange
BitrateChange
FramerateChange
UsageChange
ContentHintChange
SampleRateChange
NumberOfChannelsChange
>
;
struct
EncoderConfigurationChangeList
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
EncoderConfigurationChangeList
)
bool
Empty
(
)
const
{
return
mChanges
.
IsEmpty
(
)
;
}
template
<
typename
T
>
void
Push
(
const
T
&
aItem
)
{
mChanges
.
AppendElement
(
aItem
)
;
}
nsString
ToString
(
)
const
;
nsTArray
<
EncoderConfigurationItem
>
mChanges
;
private
:
~
EncoderConfigurationChangeList
(
)
=
default
;
}
;
bool
CanLikelyEncode
(
const
EncoderConfig
&
aConfig
)
;
}
#
endif
