#
ifndef
mozilla_SimpleMap_h
#
define
mozilla_SimpleMap_h
#
include
<
utility
>
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
struct
ThreadSafePolicy
{
struct
PolicyLock
{
explicit
PolicyLock
(
const
char
*
aName
)
:
mMutex
(
aName
)
{
}
Mutex
mMutex
MOZ_UNANNOTATED
;
}
;
PolicyLock
&
mPolicyLock
;
explicit
ThreadSafePolicy
(
PolicyLock
&
aPolicyLock
)
:
mPolicyLock
(
aPolicyLock
)
{
mPolicyLock
.
mMutex
.
Lock
(
)
;
}
~
ThreadSafePolicy
(
)
{
mPolicyLock
.
mMutex
.
Unlock
(
)
;
}
}
;
struct
NoOpPolicy
{
struct
PolicyLock
{
explicit
PolicyLock
(
const
char
*
)
{
}
}
;
explicit
NoOpPolicy
(
PolicyLock
&
)
{
}
~
NoOpPolicy
(
)
=
default
;
}
;
template
<
typename
K
typename
V
typename
Policy
=
NoOpPolicy
>
class
SimpleMap
{
using
ElementType
=
std
:
:
pair
<
K
V
>
;
using
MapType
=
AutoTArray
<
ElementType
16
>
;
public
:
SimpleMap
(
)
:
mLock
(
"
SimpleMap
"
)
{
}
;
void
Insert
(
const
K
&
aKey
const
V
&
aValue
)
{
Policy
guard
(
mLock
)
;
mMap
.
AppendElement
(
std
:
:
make_pair
(
aKey
aValue
)
)
;
}
bool
Find
(
const
K
&
aKey
V
&
aValue
)
{
Policy
guard
(
mLock
)
;
for
(
uint32_t
i
=
0
;
i
<
mMap
.
Length
(
)
;
i
+
+
)
{
ElementType
&
element
=
mMap
[
i
]
;
if
(
element
.
first
=
=
aKey
)
{
aValue
=
element
.
second
;
mMap
.
RemoveElementAt
(
i
)
;
return
true
;
}
}
return
false
;
}
void
Clear
(
)
{
Policy
guard
(
mLock
)
;
mMap
.
Clear
(
)
;
}
template
<
typename
F
>
void
ForEach
(
F
&
&
aCallback
)
{
Policy
guard
(
mLock
)
;
for
(
const
auto
&
element
:
mMap
)
{
aCallback
(
element
.
first
element
.
second
)
;
}
}
private
:
typename
Policy
:
:
PolicyLock
mLock
;
MapType
mMap
;
}
;
}
#
endif
