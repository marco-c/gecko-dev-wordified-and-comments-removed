#
if
!
defined
(
OmxDataDecoder_h_
)
#
define
OmxDataDecoder_h_
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
AudioCompactor
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
OMX_Component
.
h
"
#
include
"
OmxPromiseLayer
.
h
"
namespace
mozilla
{
class
MediaDataHelper
;
typedef
OmxPromiseLayer
:
:
OmxCommandPromise
OmxCommandPromise
;
typedef
OmxPromiseLayer
:
:
OmxBufferPromise
OmxBufferPromise
;
typedef
OmxPromiseLayer
:
:
OmxBufferFailureHolder
OmxBufferFailureHolder
;
typedef
OmxPromiseLayer
:
:
OmxCommandFailureHolder
OmxCommandFailureHolder
;
typedef
OmxPromiseLayer
:
:
BufferData
BufferData
;
typedef
OmxPromiseLayer
:
:
BUFFERLIST
BUFFERLIST
;
class
OmxDataDecoder
:
public
MediaDataDecoder
{
protected
:
virtual
~
OmxDataDecoder
(
)
;
public
:
OmxDataDecoder
(
const
TrackInfo
&
aTrackInfo
MediaDataDecoderCallback
*
aCallback
layers
:
:
ImageContainer
*
aImageContainer
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
nsresult
Input
(
MediaRawData
*
aSample
)
override
;
nsresult
Flush
(
)
override
;
nsresult
Drain
(
)
override
;
nsresult
Shutdown
(
)
override
;
const
char
*
GetDescriptionName
(
)
const
override
{
return
"
omx
decoder
"
;
}
bool
Event
(
OMX_EVENTTYPE
aEvent
OMX_U32
aData1
OMX_U32
aData2
)
;
protected
:
void
InitializationTask
(
)
;
void
ResolveInitPromise
(
const
char
*
aMethodName
)
;
void
RejectInitPromise
(
DecoderFailureReason
aReason
const
char
*
aMethodName
)
;
void
OmxStateRunner
(
)
;
void
FillAndEmptyBuffers
(
)
;
void
FillBufferDone
(
BufferData
*
aData
)
;
void
FillBufferFailure
(
OmxBufferFailureHolder
aFailureHolder
)
;
void
EmptyBufferDone
(
BufferData
*
aData
)
;
void
EmptyBufferFailure
(
OmxBufferFailureHolder
aFailureHolder
)
;
void
NotifyError
(
OMX_ERRORTYPE
aError
const
char
*
aLine
)
;
void
ConfigCodec
(
)
;
void
FillCodecConfigDataToOmx
(
)
;
void
SendEosBuffer
(
)
;
void
EndOfStream
(
)
;
void
PortSettingsChanged
(
)
;
void
Output
(
BufferData
*
aData
)
;
bool
BuffersCanBeReleased
(
OMX_DIRTYPE
aType
)
;
OMX_DIRTYPE
GetPortDirection
(
uint32_t
aPortIndex
)
;
void
DoAsyncShutdown
(
)
;
void
DoFlush
(
)
;
void
FlushComplete
(
OMX_COMMANDTYPE
aCommandType
)
;
void
FlushFailure
(
OmxCommandFailureHolder
aFailureHolder
)
;
BUFFERLIST
*
GetBuffers
(
OMX_DIRTYPE
aType
)
;
nsresult
AllocateBuffers
(
OMX_DIRTYPE
aType
)
;
nsresult
ReleaseBuffers
(
OMX_DIRTYPE
aType
)
;
BufferData
*
FindAvailableBuffer
(
OMX_DIRTYPE
aType
)
;
RefPtr
<
OmxPromiseLayer
:
:
OmxBufferPromise
:
:
AllPromiseType
>
CollectBufferPromises
(
OMX_DIRTYPE
aType
)
;
Monitor
mMonitor
;
RefPtr
<
TaskQueue
>
mOmxTaskQueue
;
RefPtr
<
TaskQueue
>
mReaderTaskQueue
;
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
WatchManager
<
OmxDataDecoder
>
mWatchManager
;
Watchable
<
OMX_STATETYPE
>
mOmxState
;
RefPtr
<
OmxPromiseLayer
>
mOmxLayer
;
UniquePtr
<
TrackInfo
>
mTrackInfo
;
Atomic
<
bool
>
mFlushing
;
Atomic
<
bool
>
mShuttingDown
;
bool
mCheckingInputExhausted
;
MozPromiseHolder
<
InitPromise
>
mInitPromise
;
Watchable
<
int32_t
>
mPortSettingsChanged
;
nsTArray
<
RefPtr
<
MediaRawData
>
>
mMediaRawDatas
;
BUFFERLIST
mInPortBuffers
;
BUFFERLIST
mOutPortBuffers
;
RefPtr
<
MediaDataHelper
>
mMediaDataHelper
;
MediaDataDecoderCallback
*
mCallback
;
}
;
template
<
class
T
>
void
InitOmxParameter
(
T
*
aParam
)
{
PodZero
(
aParam
)
;
aParam
-
>
nSize
=
sizeof
(
T
)
;
aParam
-
>
nVersion
.
s
.
nVersionMajor
=
1
;
}
void
GetOmxPortIndex
(
nsTArray
<
uint32_t
>
&
aPortIndex
)
{
aPortIndex
.
AppendElement
(
0
)
;
aPortIndex
.
AppendElement
(
1
)
;
}
}
#
endif
