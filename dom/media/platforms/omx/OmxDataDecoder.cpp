#
include
"
OmxDataDecoder
.
h
"
#
include
"
OMX_Audio
.
h
"
#
include
"
OMX_Component
.
h
"
#
include
"
OMX_Types
.
h
"
#
include
"
OmxPlatformLayer
.
h
"
extern
mozilla
:
:
LogModule
*
GetPDMLog
(
)
;
#
ifdef
LOG
#
undef
LOG
#
undef
LOGL
#
endif
#
define
LOG
(
arg
.
.
.
)
MOZ_LOG
(
GetPDMLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
OmxDataDecoder
(
%
p
)
:
:
%
s
:
"
arg
this
__func__
#
#
__VA_ARGS__
)
)
#
define
LOGL
(
arg
.
.
.
)
\
{
\
void
*
p
=
self
;
\
MOZ_LOG
(
GetPDMLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
\
(
"
OmxDataDecoder
(
%
p
)
:
:
%
s
:
"
arg
p
__func__
#
#
__VA_ARGS__
)
)
;
\
}
#
define
CHECK_OMX_ERR
(
err
)
\
if
(
err
!
=
OMX_ErrorNone
)
{
\
NotifyError
(
err
__func__
)
;
\
return
;
\
}
\
namespace
mozilla
{
static
const
char
*
StateTypeToStr
(
OMX_STATETYPE
aType
)
{
MOZ_ASSERT
(
aType
=
=
OMX_StateLoaded
|
|
aType
=
=
OMX_StateIdle
|
|
aType
=
=
OMX_StateExecuting
|
|
aType
=
=
OMX_StatePause
|
|
aType
=
=
OMX_StateWaitForResources
|
|
aType
=
=
OMX_StateInvalid
)
;
switch
(
aType
)
{
case
OMX_StateLoaded
:
return
"
OMX_StateLoaded
"
;
case
OMX_StateIdle
:
return
"
OMX_StateIdle
"
;
case
OMX_StateExecuting
:
return
"
OMX_StateExecuting
"
;
case
OMX_StatePause
:
return
"
OMX_StatePause
"
;
case
OMX_StateWaitForResources
:
return
"
OMX_StateWaitForResources
"
;
case
OMX_StateInvalid
:
return
"
OMX_StateInvalid
"
;
default
:
return
"
Unknown
"
;
}
}
class
MediaDataHelper
{
protected
:
virtual
~
MediaDataHelper
(
)
{
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDataHelper
)
MediaDataHelper
(
const
TrackInfo
*
aTrackInfo
layers
:
:
ImageContainer
*
aImageContainer
OmxPromiseLayer
*
aOmxLayer
)
;
already_AddRefed
<
MediaData
>
GetMediaData
(
BufferData
*
aBufferData
bool
&
aPlatformDepenentData
)
;
protected
:
already_AddRefed
<
AudioData
>
CreateAudioData
(
BufferData
*
aBufferData
)
;
already_AddRefed
<
VideoData
>
CreateYUV420VideoData
(
BufferData
*
aBufferData
)
;
const
TrackInfo
*
mTrackInfo
;
OMX_PARAM_PORTDEFINITIONTYPE
mOutputPortDef
;
MediaQueue
<
AudioData
>
mAudioQueue
;
AudioCompactor
mAudioCompactor
;
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
}
;
OmxDataDecoder
:
:
OmxDataDecoder
(
const
TrackInfo
&
aTrackInfo
MediaDataDecoderCallback
*
aCallback
layers
:
:
ImageContainer
*
aImageContainer
)
:
mMonitor
(
"
OmxDataDecoder
"
)
mOmxTaskQueue
(
CreateMediaDecodeTaskQueue
(
)
)
mImageContainer
(
aImageContainer
)
mWatchManager
(
this
mOmxTaskQueue
)
mOmxState
(
OMX_STATETYPE
:
:
OMX_StateInvalid
"
OmxDataDecoder
:
:
mOmxState
"
)
mTrackInfo
(
aTrackInfo
.
Clone
(
)
)
mFlushing
(
false
)
mShuttingDown
(
false
)
mCheckingInputExhausted
(
false
)
mPortSettingsChanged
(
-
1
"
OmxDataDecoder
:
:
mPortSettingsChanged
"
)
mCallback
(
aCallback
)
{
LOG
(
"
"
)
;
mOmxLayer
=
new
OmxPromiseLayer
(
mOmxTaskQueue
this
aImageContainer
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableMethod
(
this
&
OmxDataDecoder
:
:
InitializationTask
)
;
mOmxTaskQueue
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
OmxDataDecoder
:
:
~
OmxDataDecoder
(
)
{
LOG
(
"
"
)
;
}
void
OmxDataDecoder
:
:
InitializationTask
(
)
{
mWatchManager
.
Watch
(
mOmxState
&
OmxDataDecoder
:
:
OmxStateRunner
)
;
mWatchManager
.
Watch
(
mPortSettingsChanged
&
OmxDataDecoder
:
:
PortSettingsChanged
)
;
}
void
OmxDataDecoder
:
:
EndOfStream
(
)
{
LOG
(
"
"
)
;
MOZ_ASSERT
(
mOmxTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
mFlushing
=
true
;
RefPtr
<
OmxDataDecoder
>
self
=
this
;
mOmxLayer
-
>
SendCommand
(
OMX_CommandFlush
OMX_ALL
nullptr
)
-
>
Then
(
mReaderTaskQueue
__func__
[
self
]
(
)
{
self
-
>
mFlushing
=
false
;
self
-
>
mCallback
-
>
DrainComplete
(
)
;
}
[
self
]
(
)
{
self
-
>
mFlushing
=
false
;
self
-
>
mCallback
-
>
DrainComplete
(
)
;
}
)
;
}
RefPtr
<
MediaDataDecoder
:
:
InitPromise
>
OmxDataDecoder
:
:
Init
(
)
{
LOG
(
"
"
)
;
mReaderTaskQueue
=
AbstractThread
:
:
GetCurrent
(
)
-
>
AsTaskQueue
(
)
;
MOZ_ASSERT
(
mReaderTaskQueue
)
;
RefPtr
<
InitPromise
>
p
=
mInitPromise
.
Ensure
(
__func__
)
;
RefPtr
<
OmxDataDecoder
>
self
=
this
;
InvokeAsync
(
mOmxTaskQueue
mOmxLayer
.
get
(
)
__func__
&
OmxPromiseLayer
:
:
Init
mTrackInfo
.
get
(
)
)
-
>
Then
(
mOmxTaskQueue
__func__
[
self
]
(
)
{
self
-
>
mOmxState
=
self
-
>
mOmxLayer
-
>
GetState
(
)
;
MOZ_ASSERT
(
self
-
>
mOmxState
!
=
OMX_StateIdle
)
;
}
[
self
]
(
)
{
self
-
>
RejectInitPromise
(
DecoderFailureReason
:
:
INIT_ERROR
__func__
)
;
}
)
;
return
p
;
}
nsresult
OmxDataDecoder
:
:
Input
(
MediaRawData
*
aSample
)
{
LOG
(
"
sample
%
p
"
aSample
)
;
MOZ_ASSERT
(
mInitPromise
.
IsEmpty
(
)
)
;
RefPtr
<
OmxDataDecoder
>
self
=
this
;
RefPtr
<
MediaRawData
>
sample
=
aSample
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
self
sample
]
(
)
{
self
-
>
mMediaRawDatas
.
AppendElement
(
sample
)
;
if
(
self
-
>
mOmxState
=
=
OMX_StateIdle
|
|
self
-
>
mOmxState
=
=
OMX_StateExecuting
)
{
self
-
>
FillAndEmptyBuffers
(
)
;
}
}
)
;
mOmxTaskQueue
-
>
Dispatch
(
r
.
forget
(
)
)
;
return
NS_OK
;
}
nsresult
OmxDataDecoder
:
:
Flush
(
)
{
LOG
(
"
"
)
;
mFlushing
=
true
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableMethod
(
this
&
OmxDataDecoder
:
:
DoFlush
)
;
mOmxTaskQueue
-
>
Dispatch
(
r
.
forget
(
)
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
mFlushing
)
{
lock
.
Wait
(
)
;
}
return
NS_OK
;
}
nsresult
OmxDataDecoder
:
:
Drain
(
)
{
LOG
(
"
"
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableMethod
(
this
&
OmxDataDecoder
:
:
SendEosBuffer
)
;
mOmxTaskQueue
-
>
Dispatch
(
r
.
forget
(
)
)
;
return
NS_OK
;
}
nsresult
OmxDataDecoder
:
:
Shutdown
(
)
{
LOG
(
"
"
)
;
mShuttingDown
=
true
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableMethod
(
this
&
OmxDataDecoder
:
:
DoAsyncShutdown
)
;
mOmxTaskQueue
-
>
Dispatch
(
r
.
forget
(
)
)
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
mShuttingDown
)
{
lock
.
Wait
(
)
;
}
}
mOmxTaskQueue
-
>
BeginShutdown
(
)
;
mOmxTaskQueue
-
>
AwaitShutdownAndIdle
(
)
;
return
NS_OK
;
}
void
OmxDataDecoder
:
:
DoAsyncShutdown
(
)
{
LOG
(
"
"
)
;
MOZ_ASSERT
(
mOmxTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
MOZ_ASSERT
(
!
mFlushing
)
;
mWatchManager
.
Unwatch
(
mOmxState
&
OmxDataDecoder
:
:
OmxStateRunner
)
;
mWatchManager
.
Unwatch
(
mPortSettingsChanged
&
OmxDataDecoder
:
:
PortSettingsChanged
)
;
RefPtr
<
OmxDataDecoder
>
self
=
this
;
mOmxLayer
-
>
SendCommand
(
OMX_CommandFlush
OMX_ALL
nullptr
)
-
>
Then
(
mOmxTaskQueue
__func__
[
self
]
(
)
-
>
RefPtr
<
OmxCommandPromise
>
{
LOGL
(
"
DoAsyncShutdown
:
flush
complete
"
)
;
return
self
-
>
mOmxLayer
-
>
SendCommand
(
OMX_CommandStateSet
OMX_StateIdle
nullptr
)
;
}
[
self
]
(
)
{
self
-
>
mOmxLayer
-
>
Shutdown
(
)
;
}
)
-
>
CompletionPromise
(
)
-
>
Then
(
mOmxTaskQueue
__func__
[
self
]
(
)
-
>
RefPtr
<
OmxCommandPromise
>
{
RefPtr
<
OmxCommandPromise
>
p
=
self
-
>
mOmxLayer
-
>
SendCommand
(
OMX_CommandStateSet
OMX_StateLoaded
nullptr
)
;
LOGL
(
"
DoAsyncShutdown
:
releasing
buffers
.
.
.
"
)
;
self
-
>
ReleaseBuffers
(
OMX_DirInput
)
;
self
-
>
ReleaseBuffers
(
OMX_DirOutput
)
;
return
p
;
}
[
self
]
(
)
{
self
-
>
mOmxLayer
-
>
Shutdown
(
)
;
}
)
-
>
CompletionPromise
(
)
-
>
Then
(
mOmxTaskQueue
__func__
[
self
]
(
)
{
LOGL
(
"
DoAsyncShutdown
:
OMX_StateLoaded
it
is
safe
to
shutdown
omx
"
)
;
self
-
>
mOmxLayer
-
>
Shutdown
(
)
;
self
-
>
mWatchManager
.
Shutdown
(
)
;
self
-
>
mOmxLayer
=
nullptr
;
self
-
>
mMediaDataHelper
=
nullptr
;
MonitorAutoLock
lock
(
self
-
>
mMonitor
)
;
self
-
>
mShuttingDown
=
false
;
self
-
>
mMonitor
.
Notify
(
)
;
}
[
self
]
(
)
{
self
-
>
mOmxLayer
-
>
Shutdown
(
)
;
self
-
>
mWatchManager
.
Shutdown
(
)
;
self
-
>
mOmxLayer
=
nullptr
;
self
-
>
mMediaDataHelper
=
nullptr
;
MonitorAutoLock
lock
(
self
-
>
mMonitor
)
;
self
-
>
mShuttingDown
=
false
;
self
-
>
mMonitor
.
Notify
(
)
;
}
)
;
}
void
OmxDataDecoder
:
:
FillBufferDone
(
BufferData
*
aData
)
{
MOZ_ASSERT
(
!
aData
|
|
aData
-
>
mStatus
=
=
BufferData
:
:
BufferStatus
:
:
OMX_CLIENT
)
;
if
(
mFlushing
|
|
mShuttingDown
)
{
LOG
(
"
mFlush
or
mShuttingDown
drop
data
"
)
;
aData
-
>
mStatus
=
BufferData
:
:
BufferStatus
:
:
FREE
;
return
;
}
if
(
aData
-
>
mBuffer
-
>
nFlags
&
OMX_BUFFERFLAG_EOS
)
{
EndOfStream
(
)
;
aData
-
>
mStatus
=
BufferData
:
:
BufferStatus
:
:
FREE
;
}
else
{
Output
(
aData
)
;
FillAndEmptyBuffers
(
)
;
}
}
void
OmxDataDecoder
:
:
Output
(
BufferData
*
aData
)
{
if
(
!
mMediaDataHelper
)
{
mMediaDataHelper
=
new
MediaDataHelper
(
mTrackInfo
.
get
(
)
mImageContainer
mOmxLayer
)
;
}
bool
isPlatformData
=
false
;
RefPtr
<
MediaData
>
data
=
mMediaDataHelper
-
>
GetMediaData
(
aData
isPlatformData
)
;
if
(
!
data
)
{
aData
-
>
mStatus
=
BufferData
:
:
BufferStatus
:
:
FREE
;
return
;
}
if
(
isPlatformData
)
{
aData
-
>
mStatus
=
BufferData
:
:
BufferStatus
:
:
OMX_CLIENT_OUTPUT
;
MOZ_RELEASE_ASSERT
(
aData
-
>
mPromise
.
IsEmpty
(
)
)
;
RefPtr
<
OmxBufferPromise
>
p
=
aData
-
>
mPromise
.
Ensure
(
__func__
)
;
RefPtr
<
OmxDataDecoder
>
self
=
this
;
RefPtr
<
BufferData
>
buffer
=
aData
;
p
-
>
Then
(
mOmxTaskQueue
__func__
[
self
buffer
]
(
)
{
MOZ_RELEASE_ASSERT
(
buffer
-
>
mStatus
=
=
BufferData
:
:
BufferStatus
:
:
OMX_CLIENT_OUTPUT
)
;
buffer
-
>
mStatus
=
BufferData
:
:
BufferStatus
:
:
FREE
;
self
-
>
FillAndEmptyBuffers
(
)
;
}
[
buffer
]
(
)
{
MOZ_RELEASE_ASSERT
(
buffer
-
>
mStatus
=
=
BufferData
:
:
BufferStatus
:
:
OMX_CLIENT_OUTPUT
)
;
buffer
-
>
mStatus
=
BufferData
:
:
BufferStatus
:
:
FREE
;
}
)
;
}
else
{
aData
-
>
mStatus
=
BufferData
:
:
BufferStatus
:
:
FREE
;
}
mCallback
-
>
Output
(
data
)
;
}
void
OmxDataDecoder
:
:
FillBufferFailure
(
OmxBufferFailureHolder
aFailureHolder
)
{
NotifyError
(
aFailureHolder
.
mError
__func__
)
;
}
void
OmxDataDecoder
:
:
EmptyBufferDone
(
BufferData
*
aData
)
{
MOZ_ASSERT
(
!
aData
|
|
aData
-
>
mStatus
=
=
BufferData
:
:
BufferStatus
:
:
OMX_CLIENT
)
;
aData
-
>
mStatus
=
BufferData
:
:
BufferStatus
:
:
FREE
;
FillAndEmptyBuffers
(
)
;
if
(
!
mCheckingInputExhausted
&
&
!
mMediaRawDatas
.
Length
(
)
)
{
mCheckingInputExhausted
=
true
;
RefPtr
<
OmxDataDecoder
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
self
]
(
)
{
MOZ_ASSERT
(
self
-
>
mOmxTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
self
-
>
mCheckingInputExhausted
=
false
;
if
(
self
-
>
mMediaRawDatas
.
Length
(
)
)
{
return
;
}
LOGL
(
"
Call
InputExhausted
(
)
"
)
;
self
-
>
mCallback
-
>
InputExhausted
(
)
;
}
)
;
mOmxTaskQueue
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
}
void
OmxDataDecoder
:
:
EmptyBufferFailure
(
OmxBufferFailureHolder
aFailureHolder
)
{
NotifyError
(
aFailureHolder
.
mError
__func__
)
;
}
void
OmxDataDecoder
:
:
NotifyError
(
OMX_ERRORTYPE
aError
const
char
*
aLine
)
{
LOG
(
"
NotifyError
%
d
at
%
s
"
aError
aLine
)
;
mCallback
-
>
Error
(
)
;
}
void
OmxDataDecoder
:
:
FillAndEmptyBuffers
(
)
{
MOZ_ASSERT
(
mOmxTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
MOZ_ASSERT
(
mOmxState
=
=
OMX_StateExecuting
)
;
if
(
mPortSettingsChanged
!
=
-
1
|
|
mShuttingDown
|
|
mFlushing
)
{
return
;
}
while
(
!
!
mMediaRawDatas
.
Length
(
)
)
{
RefPtr
<
BufferData
>
inbuf
=
FindAvailableBuffer
(
OMX_DirInput
)
;
if
(
!
inbuf
)
{
LOG
(
"
no
input
buffer
!
"
)
;
break
;
}
RefPtr
<
MediaRawData
>
data
=
mMediaRawDatas
[
0
]
;
MOZ_RELEASE_ASSERT
(
inbuf
-
>
mBuffer
-
>
nAllocLen
>
=
data
-
>
Size
(
)
)
;
memcpy
(
inbuf
-
>
mBuffer
-
>
pBuffer
data
-
>
Data
(
)
data
-
>
Size
(
)
)
;
inbuf
-
>
mBuffer
-
>
nFilledLen
=
data
-
>
Size
(
)
;
inbuf
-
>
mBuffer
-
>
nOffset
=
0
;
inbuf
-
>
mBuffer
-
>
nFlags
=
inbuf
-
>
mBuffer
-
>
nAllocLen
>
data
-
>
Size
(
)
?
OMX_BUFFERFLAG_ENDOFFRAME
:
0
;
inbuf
-
>
mBuffer
-
>
nTimeStamp
=
data
-
>
mTime
;
if
(
data
-
>
Size
(
)
)
{
inbuf
-
>
mRawData
=
mMediaRawDatas
[
0
]
;
}
else
{
LOG
(
"
send
EOS
buffer
"
)
;
inbuf
-
>
mBuffer
-
>
nFlags
|
=
OMX_BUFFERFLAG_EOS
;
}
LOG
(
"
feed
sample
%
p
to
omx
component
len
%
d
flag
%
X
"
data
.
get
(
)
inbuf
-
>
mBuffer
-
>
nFilledLen
inbuf
-
>
mBuffer
-
>
nFlags
)
;
mOmxLayer
-
>
EmptyBuffer
(
inbuf
)
-
>
Then
(
mOmxTaskQueue
__func__
this
&
OmxDataDecoder
:
:
EmptyBufferDone
&
OmxDataDecoder
:
:
EmptyBufferFailure
)
;
mMediaRawDatas
.
RemoveElementAt
(
0
)
;
}
while
(
true
)
{
RefPtr
<
BufferData
>
outbuf
=
FindAvailableBuffer
(
OMX_DirOutput
)
;
if
(
!
outbuf
)
{
break
;
}
mOmxLayer
-
>
FillBuffer
(
outbuf
)
-
>
Then
(
mOmxTaskQueue
__func__
this
&
OmxDataDecoder
:
:
FillBufferDone
&
OmxDataDecoder
:
:
FillBufferFailure
)
;
}
}
OmxPromiseLayer
:
:
BufferData
*
OmxDataDecoder
:
:
FindAvailableBuffer
(
OMX_DIRTYPE
aType
)
{
BUFFERLIST
*
buffers
=
GetBuffers
(
aType
)
;
for
(
uint32_t
i
=
0
;
i
<
buffers
-
>
Length
(
)
;
i
+
+
)
{
BufferData
*
buf
=
buffers
-
>
ElementAt
(
i
)
;
if
(
buf
-
>
mStatus
=
=
BufferData
:
:
BufferStatus
:
:
FREE
)
{
return
buf
;
}
}
return
nullptr
;
}
nsresult
OmxDataDecoder
:
:
AllocateBuffers
(
OMX_DIRTYPE
aType
)
{
MOZ_ASSERT
(
mOmxTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
return
mOmxLayer
-
>
AllocateOmxBuffer
(
aType
GetBuffers
(
aType
)
)
;
}
nsresult
OmxDataDecoder
:
:
ReleaseBuffers
(
OMX_DIRTYPE
aType
)
{
MOZ_ASSERT
(
mOmxTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
return
mOmxLayer
-
>
ReleaseOmxBuffer
(
aType
GetBuffers
(
aType
)
)
;
}
nsTArray
<
RefPtr
<
OmxPromiseLayer
:
:
BufferData
>
>
*
OmxDataDecoder
:
:
GetBuffers
(
OMX_DIRTYPE
aType
)
{
MOZ_ASSERT
(
aType
=
=
OMX_DIRTYPE
:
:
OMX_DirInput
|
|
aType
=
=
OMX_DIRTYPE
:
:
OMX_DirOutput
)
;
if
(
aType
=
=
OMX_DIRTYPE
:
:
OMX_DirInput
)
{
return
&
mInPortBuffers
;
}
return
&
mOutPortBuffers
;
}
void
OmxDataDecoder
:
:
ResolveInitPromise
(
const
char
*
aMethodName
)
{
LOG
(
"
called
from
%
s
"
aMethodName
)
;
RefPtr
<
OmxDataDecoder
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
self
aMethodName
]
(
)
{
MOZ_ASSERT
(
self
-
>
mReaderTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
self
-
>
mInitPromise
.
ResolveIfExists
(
self
-
>
mTrackInfo
-
>
GetType
(
)
aMethodName
)
;
}
)
;
mReaderTaskQueue
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
OmxDataDecoder
:
:
RejectInitPromise
(
DecoderFailureReason
aReason
const
char
*
aMethodName
)
{
RefPtr
<
OmxDataDecoder
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
self
aReason
aMethodName
]
(
)
{
MOZ_ASSERT
(
self
-
>
mReaderTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
self
-
>
mInitPromise
.
RejectIfExists
(
aReason
aMethodName
)
;
}
)
;
mReaderTaskQueue
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
OmxDataDecoder
:
:
OmxStateRunner
(
)
{
MOZ_ASSERT
(
mOmxTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
LOG
(
"
OMX
state
:
%
s
"
StateTypeToStr
(
mOmxState
)
)
;
if
(
mOmxState
=
=
OMX_StateLoaded
)
{
ConfigCodec
(
)
;
RefPtr
<
OmxDataDecoder
>
self
=
this
;
mOmxLayer
-
>
SendCommand
(
OMX_CommandStateSet
OMX_StateIdle
nullptr
)
-
>
Then
(
mOmxTaskQueue
__func__
[
self
]
(
)
{
self
-
>
mOmxState
=
self
-
>
mOmxLayer
-
>
GetState
(
)
;
MOZ_ASSERT
(
self
-
>
mOmxState
=
=
OMX_StateIdle
)
;
}
[
self
]
(
)
{
self
-
>
RejectInitPromise
(
DecoderFailureReason
:
:
INIT_ERROR
__func__
)
;
}
)
;
OMX_DIRTYPE
types
[
]
=
{
OMX_DIRTYPE
:
:
OMX_DirInput
OMX_DIRTYPE
:
:
OMX_DirOutput
}
;
for
(
const
auto
id
:
types
)
{
if
(
NS_FAILED
(
AllocateBuffers
(
id
)
)
)
{
LOG
(
"
Failed
to
allocate
buffer
on
port
%
d
"
id
)
;
RejectInitPromise
(
DecoderFailureReason
:
:
INIT_ERROR
__func__
)
;
break
;
}
}
}
else
if
(
mOmxState
=
=
OMX_StateIdle
)
{
RefPtr
<
OmxDataDecoder
>
self
=
this
;
mOmxLayer
-
>
SendCommand
(
OMX_CommandStateSet
OMX_StateExecuting
nullptr
)
-
>
Then
(
mOmxTaskQueue
__func__
[
self
]
(
)
{
self
-
>
mOmxState
=
self
-
>
mOmxLayer
-
>
GetState
(
)
;
MOZ_ASSERT
(
self
-
>
mOmxState
=
=
OMX_StateExecuting
)
;
self
-
>
ResolveInitPromise
(
__func__
)
;
}
[
self
]
(
)
{
self
-
>
RejectInitPromise
(
DecoderFailureReason
:
:
INIT_ERROR
__func__
)
;
}
)
;
}
else
if
(
mOmxState
=
=
OMX_StateExecuting
)
{
FillCodecConfigDataToOmx
(
)
;
}
else
{
MOZ_ASSERT
(
0
)
;
}
}
void
OmxDataDecoder
:
:
ConfigCodec
(
)
{
OMX_ERRORTYPE
err
=
mOmxLayer
-
>
Config
(
)
;
CHECK_OMX_ERR
(
err
)
;
}
void
OmxDataDecoder
:
:
FillCodecConfigDataToOmx
(
)
{
MOZ_ASSERT
(
mOmxTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
MOZ_ASSERT
(
!
mMediaRawDatas
.
Length
(
)
)
;
MOZ_ASSERT
(
mOmxState
=
=
OMX_StateIdle
|
|
mOmxState
=
=
OMX_StateExecuting
)
;
RefPtr
<
BufferData
>
inbuf
=
FindAvailableBuffer
(
OMX_DirInput
)
;
RefPtr
<
MediaByteBuffer
>
csc
;
if
(
mTrackInfo
-
>
IsAudio
(
)
)
{
csc
=
mTrackInfo
-
>
GetAsAudioInfo
(
)
-
>
mCodecSpecificConfig
;
}
else
if
(
mTrackInfo
-
>
IsVideo
(
)
)
{
csc
=
mTrackInfo
-
>
GetAsVideoInfo
(
)
-
>
mCodecSpecificConfig
;
}
MOZ_RELEASE_ASSERT
(
csc
)
;
if
(
csc
-
>
Length
(
)
)
{
memcpy
(
inbuf
-
>
mBuffer
-
>
pBuffer
csc
-
>
Elements
(
)
csc
-
>
Length
(
)
)
;
inbuf
-
>
mBuffer
-
>
nFilledLen
=
csc
-
>
Length
(
)
;
inbuf
-
>
mBuffer
-
>
nOffset
=
0
;
inbuf
-
>
mBuffer
-
>
nFlags
=
(
OMX_BUFFERFLAG_ENDOFFRAME
|
OMX_BUFFERFLAG_CODECCONFIG
)
;
LOG
(
"
Feed
codec
configure
data
to
OMX
component
"
)
;
mOmxLayer
-
>
EmptyBuffer
(
inbuf
)
-
>
Then
(
mOmxTaskQueue
__func__
this
&
OmxDataDecoder
:
:
EmptyBufferDone
&
OmxDataDecoder
:
:
EmptyBufferFailure
)
;
}
}
bool
OmxDataDecoder
:
:
Event
(
OMX_EVENTTYPE
aEvent
OMX_U32
aData1
OMX_U32
aData2
)
{
MOZ_ASSERT
(
mOmxTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
if
(
mOmxLayer
-
>
Event
(
aEvent
aData1
aData2
)
)
{
return
true
;
}
switch
(
aEvent
)
{
case
OMX_EventPortSettingsChanged
:
{
if
(
aData2
=
=
0
|
|
aData2
=
=
OMX_IndexParamPortDefinition
)
{
MOZ_ASSERT
(
mPortSettingsChanged
=
=
-
1
)
;
mPortSettingsChanged
=
aData1
;
}
LOG
(
"
Got
OMX_EventPortSettingsChanged
event
"
)
;
break
;
}
default
:
{
LOG
(
"
WARNING
:
got
none
handle
event
:
%
d
aData1
:
%
d
aData2
:
%
d
"
aEvent
aData1
aData2
)
;
return
false
;
}
}
return
true
;
}
bool
OmxDataDecoder
:
:
BuffersCanBeReleased
(
OMX_DIRTYPE
aType
)
{
BUFFERLIST
*
buffers
=
GetBuffers
(
aType
)
;
uint32_t
len
=
buffers
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
BufferData
:
:
BufferStatus
buf_status
=
buffers
-
>
ElementAt
(
i
)
-
>
mStatus
;
if
(
buf_status
=
=
BufferData
:
:
BufferStatus
:
:
OMX_COMPONENT
|
|
buf_status
=
=
BufferData
:
:
BufferStatus
:
:
OMX_CLIENT_OUTPUT
)
{
return
false
;
}
}
return
true
;
}
OMX_DIRTYPE
OmxDataDecoder
:
:
GetPortDirection
(
uint32_t
aPortIndex
)
{
OMX_PARAM_PORTDEFINITIONTYPE
def
;
InitOmxParameter
(
&
def
)
;
def
.
nPortIndex
=
mPortSettingsChanged
;
OMX_ERRORTYPE
err
=
mOmxLayer
-
>
GetParameter
(
OMX_IndexParamPortDefinition
&
def
sizeof
(
def
)
)
;
if
(
err
!
=
OMX_ErrorNone
)
{
return
OMX_DirMax
;
}
return
def
.
eDir
;
}
RefPtr
<
OmxPromiseLayer
:
:
OmxBufferPromise
:
:
AllPromiseType
>
OmxDataDecoder
:
:
CollectBufferPromises
(
OMX_DIRTYPE
aType
)
{
MOZ_ASSERT
(
mOmxTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
nsTArray
<
RefPtr
<
OmxBufferPromise
>
>
promises
;
OMX_DIRTYPE
types
[
]
=
{
OMX_DIRTYPE
:
:
OMX_DirInput
OMX_DIRTYPE
:
:
OMX_DirOutput
}
;
for
(
const
auto
type
:
types
)
{
if
(
(
aType
=
=
type
)
|
|
(
aType
=
=
OMX_DirMax
)
)
{
BUFFERLIST
*
buffers
=
GetBuffers
(
type
)
;
for
(
uint32_t
i
=
0
;
i
<
buffers
-
>
Length
(
)
;
i
+
+
)
{
BufferData
*
buf
=
buffers
-
>
ElementAt
(
i
)
;
if
(
!
buf
-
>
mPromise
.
IsEmpty
(
)
)
{
promises
.
AppendElement
(
buf
-
>
mPromise
.
Ensure
(
__func__
)
)
;
}
}
}
}
LOG
(
"
CollectBufferPromises
:
type
%
d
total
%
d
promiese
"
aType
promises
.
Length
(
)
)
;
if
(
promises
.
Length
(
)
)
{
return
OmxBufferPromise
:
:
All
(
mOmxTaskQueue
promises
)
;
}
nsTArray
<
BufferData
*
>
headers
;
return
OmxBufferPromise
:
:
AllPromiseType
:
:
CreateAndResolve
(
headers
__func__
)
;
}
void
OmxDataDecoder
:
:
PortSettingsChanged
(
)
{
MOZ_ASSERT
(
mOmxTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
if
(
mPortSettingsChanged
=
=
-
1
|
|
mOmxState
=
=
OMX_STATETYPE
:
:
OMX_StateInvalid
)
{
return
;
}
OMX_PARAM_PORTDEFINITIONTYPE
def
;
InitOmxParameter
(
&
def
)
;
def
.
nPortIndex
=
mPortSettingsChanged
;
OMX_ERRORTYPE
err
=
mOmxLayer
-
>
GetParameter
(
OMX_IndexParamPortDefinition
&
def
sizeof
(
def
)
)
;
CHECK_OMX_ERR
(
err
)
;
RefPtr
<
OmxDataDecoder
>
self
=
this
;
if
(
def
.
bEnabled
)
{
LOG
(
"
PortSettingsChanged
:
disable
port
%
d
"
def
.
nPortIndex
)
;
mOmxLayer
-
>
SendCommand
(
OMX_CommandPortDisable
mPortSettingsChanged
nullptr
)
-
>
Then
(
mOmxTaskQueue
__func__
[
self
def
]
(
)
-
>
RefPtr
<
OmxCommandPromise
>
{
RefPtr
<
OmxCommandPromise
>
p
=
self
-
>
mOmxLayer
-
>
SendCommand
(
OMX_CommandPortEnable
self
-
>
mPortSettingsChanged
nullptr
)
;
nsresult
rv
=
self
-
>
AllocateBuffers
(
def
.
eDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
self
-
>
NotifyError
(
OMX_ErrorUndefined
__func__
)
;
}
return
p
;
}
[
self
]
(
)
{
self
-
>
NotifyError
(
OMX_ErrorUndefined
__func__
)
;
}
)
-
>
CompletionPromise
(
)
-
>
Then
(
mOmxTaskQueue
__func__
[
self
]
(
)
{
LOGL
(
"
PortSettingsChanged
:
port
settings
changed
complete
"
)
;
self
-
>
mPortSettingsChanged
=
-
1
;
self
-
>
FillAndEmptyBuffers
(
)
;
}
[
self
]
(
)
{
self
-
>
NotifyError
(
OMX_ErrorUndefined
__func__
)
;
}
)
;
CollectBufferPromises
(
def
.
eDir
)
-
>
Then
(
mOmxTaskQueue
__func__
[
self
def
]
(
)
{
MOZ_ASSERT
(
self
-
>
BuffersCanBeReleased
(
def
.
eDir
)
)
;
nsresult
rv
=
self
-
>
ReleaseBuffers
(
def
.
eDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_RELEASE_ASSERT
(
0
)
;
self
-
>
NotifyError
(
OMX_ErrorUndefined
__func__
)
;
}
}
[
self
]
(
)
{
self
-
>
NotifyError
(
OMX_ErrorUndefined
__func__
)
;
}
)
;
}
}
void
OmxDataDecoder
:
:
SendEosBuffer
(
)
{
MOZ_ASSERT
(
mOmxTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
RefPtr
<
MediaRawData
>
eos_data
=
new
MediaRawData
(
)
;
mMediaRawDatas
.
AppendElement
(
eos_data
)
;
FillAndEmptyBuffers
(
)
;
}
void
OmxDataDecoder
:
:
DoFlush
(
)
{
MOZ_ASSERT
(
mOmxTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
mOmxLayer
-
>
SendCommand
(
OMX_CommandFlush
OMX_ALL
nullptr
)
-
>
Then
(
mOmxTaskQueue
__func__
this
&
OmxDataDecoder
:
:
FlushComplete
&
OmxDataDecoder
:
:
FlushFailure
)
;
}
void
OmxDataDecoder
:
:
FlushComplete
(
OMX_COMMANDTYPE
aCommandType
)
{
mMediaRawDatas
.
Clear
(
)
;
mFlushing
=
false
;
MonitorAutoLock
lock
(
mMonitor
)
;
mMonitor
.
Notify
(
)
;
LOG
(
"
Flush
complete
"
)
;
}
void
OmxDataDecoder
:
:
FlushFailure
(
OmxCommandFailureHolder
aFailureHolder
)
{
NotifyError
(
OMX_ErrorUndefined
__func__
)
;
mFlushing
=
false
;
MonitorAutoLock
lock
(
mMonitor
)
;
mMonitor
.
Notify
(
)
;
}
MediaDataHelper
:
:
MediaDataHelper
(
const
TrackInfo
*
aTrackInfo
layers
:
:
ImageContainer
*
aImageContainer
OmxPromiseLayer
*
aOmxLayer
)
:
mTrackInfo
(
aTrackInfo
)
mAudioCompactor
(
mAudioQueue
)
mImageContainer
(
aImageContainer
)
{
nsTArray
<
uint32_t
>
ports
;
GetOmxPortIndex
(
ports
)
;
for
(
auto
idx
:
ports
)
{
InitOmxParameter
(
&
mOutputPortDef
)
;
mOutputPortDef
.
nPortIndex
=
idx
;
aOmxLayer
-
>
GetParameter
(
OMX_IndexParamPortDefinition
&
mOutputPortDef
sizeof
(
mOutputPortDef
)
)
;
if
(
mOutputPortDef
.
eDir
=
=
OMX_DirOutput
)
{
break
;
}
}
}
already_AddRefed
<
MediaData
>
MediaDataHelper
:
:
GetMediaData
(
BufferData
*
aBufferData
bool
&
aPlatformDepenentData
)
{
aPlatformDepenentData
=
false
;
RefPtr
<
MediaData
>
data
;
if
(
mTrackInfo
-
>
IsAudio
(
)
)
{
if
(
!
aBufferData
-
>
mBuffer
-
>
nFilledLen
)
{
return
nullptr
;
}
data
=
CreateAudioData
(
aBufferData
)
;
}
else
if
(
mTrackInfo
-
>
IsVideo
(
)
)
{
data
=
aBufferData
-
>
GetPlatformMediaData
(
)
;
if
(
data
)
{
aPlatformDepenentData
=
true
;
}
else
{
if
(
!
aBufferData
-
>
mBuffer
-
>
nFilledLen
)
{
return
nullptr
;
}
data
=
CreateYUV420VideoData
(
aBufferData
)
;
}
VideoData
*
video
(
data
-
>
As
<
VideoData
>
(
)
)
;
if
(
aBufferData
-
>
mRawData
)
{
video
-
>
mTime
=
aBufferData
-
>
mRawData
-
>
mTime
;
video
-
>
mTimecode
=
aBufferData
-
>
mRawData
-
>
mTimecode
;
video
-
>
mOffset
=
aBufferData
-
>
mRawData
-
>
mOffset
;
video
-
>
mDuration
=
aBufferData
-
>
mRawData
-
>
mDuration
;
video
-
>
mKeyframe
=
aBufferData
-
>
mRawData
-
>
mKeyframe
;
}
}
return
data
.
forget
(
)
;
}
already_AddRefed
<
AudioData
>
MediaDataHelper
:
:
CreateAudioData
(
BufferData
*
aBufferData
)
{
RefPtr
<
AudioData
>
audio
;
OMX_BUFFERHEADERTYPE
*
buf
=
aBufferData
-
>
mBuffer
;
const
AudioInfo
*
info
=
mTrackInfo
-
>
GetAsAudioInfo
(
)
;
if
(
buf
-
>
nFilledLen
)
{
uint64_t
offset
=
0
;
uint32_t
frames
=
buf
-
>
nFilledLen
/
(
2
*
info
-
>
mChannels
)
;
if
(
aBufferData
-
>
mRawData
)
{
offset
=
aBufferData
-
>
mRawData
-
>
mOffset
;
}
typedef
AudioCompactor
:
:
NativeCopy
OmxCopy
;
mAudioCompactor
.
Push
(
offset
buf
-
>
nTimeStamp
info
-
>
mRate
frames
info
-
>
mChannels
OmxCopy
(
buf
-
>
pBuffer
+
buf
-
>
nOffset
buf
-
>
nFilledLen
info
-
>
mChannels
)
)
;
audio
=
mAudioQueue
.
PopFront
(
)
;
}
return
audio
.
forget
(
)
;
}
already_AddRefed
<
VideoData
>
MediaDataHelper
:
:
CreateYUV420VideoData
(
BufferData
*
aBufferData
)
{
uint8_t
*
yuv420p_buffer
=
(
uint8_t
*
)
aBufferData
-
>
mBuffer
-
>
pBuffer
;
int32_t
stride
=
mOutputPortDef
.
format
.
video
.
nStride
;
int32_t
slice_height
=
mOutputPortDef
.
format
.
video
.
nSliceHeight
;
int32_t
width
=
mTrackInfo
-
>
GetAsVideoInfo
(
)
-
>
mImage
.
width
;
int32_t
height
=
mTrackInfo
-
>
GetAsVideoInfo
(
)
-
>
mImage
.
height
;
if
(
mOutputPortDef
.
format
.
video
.
eColorFormat
!
=
OMX_COLOR_FormatYUV420Planar
)
{
return
nullptr
;
}
size_t
yuv420p_y_size
=
stride
*
slice_height
;
size_t
yuv420p_u_size
=
(
(
stride
+
1
)
/
2
)
*
(
(
slice_height
+
1
)
/
2
)
;
uint8_t
*
yuv420p_y
=
yuv420p_buffer
;
uint8_t
*
yuv420p_u
=
yuv420p_y
+
yuv420p_y_size
;
uint8_t
*
yuv420p_v
=
yuv420p_u
+
yuv420p_u_size
;
VideoData
:
:
YCbCrBuffer
b
;
b
.
mPlanes
[
0
]
.
mData
=
yuv420p_y
;
b
.
mPlanes
[
0
]
.
mWidth
=
width
;
b
.
mPlanes
[
0
]
.
mHeight
=
height
;
b
.
mPlanes
[
0
]
.
mStride
=
stride
;
b
.
mPlanes
[
0
]
.
mOffset
=
0
;
b
.
mPlanes
[
0
]
.
mSkip
=
0
;
b
.
mPlanes
[
1
]
.
mData
=
yuv420p_u
;
b
.
mPlanes
[
1
]
.
mWidth
=
(
width
+
1
)
/
2
;
b
.
mPlanes
[
1
]
.
mHeight
=
(
height
+
1
)
/
2
;
b
.
mPlanes
[
1
]
.
mStride
=
(
stride
+
1
)
/
2
;
b
.
mPlanes
[
1
]
.
mOffset
=
0
;
b
.
mPlanes
[
1
]
.
mSkip
=
0
;
b
.
mPlanes
[
2
]
.
mData
=
yuv420p_v
;
b
.
mPlanes
[
2
]
.
mWidth
=
(
width
+
1
)
/
2
;
b
.
mPlanes
[
2
]
.
mHeight
=
(
height
+
1
)
/
2
;
b
.
mPlanes
[
2
]
.
mStride
=
(
stride
+
1
)
/
2
;
b
.
mPlanes
[
2
]
.
mOffset
=
0
;
b
.
mPlanes
[
2
]
.
mSkip
=
0
;
VideoInfo
info
;
info
.
mDisplay
=
mTrackInfo
-
>
GetAsVideoInfo
(
)
-
>
mDisplay
;
info
.
mImage
=
mTrackInfo
-
>
GetAsVideoInfo
(
)
-
>
mImage
;
RefPtr
<
VideoData
>
data
=
VideoData
:
:
Create
(
info
mImageContainer
0
0
1
b
0
-
1
info
.
mImage
)
;
LOG
(
"
YUV420
VideoData
:
disp
width
%
d
height
%
d
pic
width
%
d
height
%
d
time
%
ld
"
info
.
mDisplay
.
width
info
.
mDisplay
.
height
info
.
mImage
.
width
info
.
mImage
.
height
aBufferData
-
>
mBuffer
-
>
nTimeStamp
)
;
return
data
.
forget
(
)
;
}
}
