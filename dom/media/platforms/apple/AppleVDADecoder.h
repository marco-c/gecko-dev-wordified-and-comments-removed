#
ifndef
mozilla_AppleVDADecoder_h
#
define
mozilla_AppleVDADecoder_h
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
MP4Decoder
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
ReorderQueue
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
VideoDecodeAcceleration
/
VDADecoder
.
h
"
namespace
mozilla
{
class
TaskQueue
;
class
MediaDataDecoderCallback
;
namespace
layers
{
class
ImageContainer
;
}
class
AppleVDADecoder
:
public
MediaDataDecoder
{
public
:
class
AppleFrameRef
{
public
:
media
:
:
TimeUnit
decode_timestamp
;
media
:
:
TimeUnit
composition_timestamp
;
media
:
:
TimeUnit
duration
;
int64_t
byte_offset
;
bool
is_sync_point
;
explicit
AppleFrameRef
(
const
MediaRawData
&
aSample
)
:
decode_timestamp
(
media
:
:
TimeUnit
:
:
FromMicroseconds
(
aSample
.
mTimecode
)
)
composition_timestamp
(
media
:
:
TimeUnit
:
:
FromMicroseconds
(
aSample
.
mTime
)
)
duration
(
media
:
:
TimeUnit
:
:
FromMicroseconds
(
aSample
.
mDuration
)
)
byte_offset
(
aSample
.
mOffset
)
is_sync_point
(
aSample
.
mKeyframe
)
{
}
AppleFrameRef
(
const
media
:
:
TimeUnit
&
aDts
const
media
:
:
TimeUnit
&
aPts
const
media
:
:
TimeUnit
&
aDuration
int64_t
aByte_offset
bool
aIs_sync_point
)
:
decode_timestamp
(
aDts
)
composition_timestamp
(
aPts
)
duration
(
aDuration
)
byte_offset
(
aByte_offset
)
is_sync_point
(
aIs_sync_point
)
{
}
}
;
static
already_AddRefed
<
AppleVDADecoder
>
CreateVDADecoder
(
const
VideoInfo
&
aConfig
TaskQueue
*
aTaskQueue
MediaDataDecoderCallback
*
aCallback
layers
:
:
ImageContainer
*
aImageContainer
)
;
nsresult
OutputFrame
(
CVPixelBufferRef
aImage
AppleFrameRef
aFrameRef
)
;
private
:
RefPtr
<
InitPromise
>
Init
(
)
override
;
nsresult
Input
(
MediaRawData
*
aSample
)
override
;
nsresult
Flush
(
)
override
;
nsresult
Drain
(
)
override
;
nsresult
Shutdown
(
)
override
;
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
override
{
return
true
;
}
const
char
*
GetDescriptionName
(
)
const
override
{
return
"
apple
VDA
decoder
"
;
}
protected
:
AppleVDADecoder
(
const
VideoInfo
&
aConfig
TaskQueue
*
aTaskQueue
MediaDataDecoderCallback
*
aCallback
layers
:
:
ImageContainer
*
aImageContainer
)
;
virtual
~
AppleVDADecoder
(
)
;
void
AssertOnTaskQueueThread
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
}
AppleFrameRef
*
CreateAppleFrameRef
(
const
MediaRawData
*
aSample
)
;
void
DrainReorderedFrames
(
)
;
void
ClearReorderedFrames
(
)
;
CFDictionaryRef
CreateOutputConfiguration
(
)
;
const
RefPtr
<
MediaByteBuffer
>
mExtraData
;
MediaDataDecoderCallback
*
mCallback
;
const
uint32_t
mPictureWidth
;
const
uint32_t
mPictureHeight
;
const
uint32_t
mDisplayWidth
;
const
uint32_t
mDisplayHeight
;
Atomic
<
uint32_t
>
mQueuedSamples
;
private
:
virtual
void
ProcessFlush
(
)
;
virtual
void
ProcessDrain
(
)
;
virtual
void
ProcessShutdown
(
)
;
const
RefPtr
<
TaskQueue
>
mTaskQueue
;
VDADecoder
mDecoder
;
const
uint32_t
mMaxRefFrames
;
const
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
Atomic
<
uint32_t
>
mInputIncoming
;
Atomic
<
bool
>
mIsShutDown
;
const
bool
mUseSoftwareImages
;
const
bool
mIs106
;
Monitor
mMonitor
;
Atomic
<
bool
>
mIsFlushing
;
ReorderQueue
mReorderQueue
;
nsresult
InitializeSession
(
)
;
nsresult
ProcessDecode
(
MediaRawData
*
aSample
)
;
virtual
nsresult
DoDecode
(
MediaRawData
*
aSample
)
;
CFDictionaryRef
CreateDecoderSpecification
(
)
;
}
;
}
#
endif
