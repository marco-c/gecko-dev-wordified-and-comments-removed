#
include
"
AppleUtils
.
h
"
#
include
"
MP4Decoder
.
h
"
#
include
"
mp4_demuxer
/
Adts
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
AppleATDecoder
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
define
LOG
(
.
.
.
)
MOZ_LOG
(
sPDMLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
define
FourCC2Str
(
n
)
(
(
char
[
5
]
)
{
(
char
)
(
n
>
>
24
)
(
char
)
(
n
>
>
16
)
(
char
)
(
n
>
>
8
)
(
char
)
(
n
)
0
}
)
namespace
mozilla
{
AppleATDecoder
:
:
AppleATDecoder
(
const
AudioInfo
&
aConfig
TaskQueue
*
aTaskQueue
MediaDataDecoderCallback
*
aCallback
)
:
mConfig
(
aConfig
)
mFileStreamError
(
false
)
mTaskQueue
(
aTaskQueue
)
mCallback
(
aCallback
)
mConverter
(
nullptr
)
mStream
(
nullptr
)
mIsFlushing
(
false
)
mParsedFramesForAACMagicCookie
(
0
)
{
MOZ_COUNT_CTOR
(
AppleATDecoder
)
;
LOG
(
"
Creating
Apple
AudioToolbox
decoder
"
)
;
LOG
(
"
Audio
Decoder
configuration
:
%
s
%
d
Hz
%
d
channels
%
d
bits
per
channel
"
mConfig
.
mMimeType
.
get
(
)
mConfig
.
mRate
mConfig
.
mChannels
mConfig
.
mBitDepth
)
;
if
(
mConfig
.
mMimeType
.
EqualsLiteral
(
"
audio
/
mpeg
"
)
)
{
mFormatID
=
kAudioFormatMPEGLayer3
;
}
else
if
(
mConfig
.
mMimeType
.
EqualsLiteral
(
"
audio
/
mp4a
-
latm
"
)
)
{
mFormatID
=
kAudioFormatMPEG4AAC
;
}
else
{
mFormatID
=
0
;
}
}
AppleATDecoder
:
:
~
AppleATDecoder
(
)
{
MOZ_COUNT_DTOR
(
AppleATDecoder
)
;
MOZ_ASSERT
(
!
mConverter
)
;
}
RefPtr
<
MediaDataDecoder
:
:
InitPromise
>
AppleATDecoder
:
:
Init
(
)
{
if
(
!
mFormatID
)
{
NS_ERROR
(
"
Non
recognised
format
"
)
;
return
InitPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
__func__
)
;
}
return
InitPromise
:
:
CreateAndResolve
(
TrackType
:
:
kAudioTrack
__func__
)
;
}
void
AppleATDecoder
:
:
Input
(
MediaRawData
*
aSample
)
{
MOZ_ASSERT
(
mCallback
-
>
OnReaderTaskQueue
(
)
)
;
LOG
(
"
mp4
input
sample
%
p
%
lld
us
%
lld
pts
%
s
%
llu
bytes
audio
"
aSample
aSample
-
>
mDuration
aSample
-
>
mTime
aSample
-
>
mKeyframe
?
"
keyframe
"
:
"
"
(
unsigned
long
long
)
aSample
-
>
Size
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
<
RefPtr
<
MediaRawData
>
>
(
this
&
AppleATDecoder
:
:
SubmitSample
RefPtr
<
MediaRawData
>
(
aSample
)
)
;
mTaskQueue
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
}
void
AppleATDecoder
:
:
ProcessFlush
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
mQueuedSamples
.
Clear
(
)
;
OSStatus
rv
=
AudioConverterReset
(
mConverter
)
;
if
(
rv
)
{
LOG
(
"
Error
%
d
resetting
AudioConverter
"
rv
)
;
}
}
void
AppleATDecoder
:
:
Flush
(
)
{
MOZ_ASSERT
(
mCallback
-
>
OnReaderTaskQueue
(
)
)
;
LOG
(
"
Flushing
AudioToolbox
AAC
decoder
"
)
;
mIsFlushing
=
true
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
(
this
&
AppleATDecoder
:
:
ProcessFlush
)
;
SyncRunnable
:
:
DispatchToThread
(
mTaskQueue
runnable
)
;
mIsFlushing
=
false
;
}
void
AppleATDecoder
:
:
Drain
(
)
{
MOZ_ASSERT
(
mCallback
-
>
OnReaderTaskQueue
(
)
)
;
LOG
(
"
Draining
AudioToolbox
AAC
decoder
"
)
;
mTaskQueue
-
>
AwaitIdle
(
)
;
mCallback
-
>
DrainComplete
(
)
;
Flush
(
)
;
}
void
AppleATDecoder
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
mCallback
-
>
OnReaderTaskQueue
(
)
)
;
LOG
(
"
Shutdown
:
Apple
AudioToolbox
AAC
decoder
"
)
;
mQueuedSamples
.
Clear
(
)
;
OSStatus
rv
=
AudioConverterDispose
(
mConverter
)
;
if
(
rv
)
{
LOG
(
"
error
%
d
disposing
of
AudioConverter
"
rv
)
;
return
;
}
mConverter
=
nullptr
;
if
(
mStream
)
{
rv
=
AudioFileStreamClose
(
mStream
)
;
if
(
rv
)
{
LOG
(
"
error
%
d
disposing
of
AudioFileStream
"
rv
)
;
return
;
}
mStream
=
nullptr
;
}
}
struct
PassthroughUserData
{
UInt32
mChannels
;
UInt32
mDataSize
;
const
void
*
mData
;
AudioStreamPacketDescription
mPacket
;
}
;
const
uint32_t
kNoMoreDataErr
=
'
MOAR
'
;
static
OSStatus
_PassthroughInputDataCallback
(
AudioConverterRef
aAudioConverter
UInt32
*
aNumDataPackets
AudioBufferList
*
aData
AudioStreamPacketDescription
*
*
aPacketDesc
void
*
aUserData
)
{
PassthroughUserData
*
userData
=
(
PassthroughUserData
*
)
aUserData
;
if
(
!
userData
-
>
mDataSize
)
{
*
aNumDataPackets
=
0
;
return
kNoMoreDataErr
;
}
if
(
aPacketDesc
)
{
userData
-
>
mPacket
.
mStartOffset
=
0
;
userData
-
>
mPacket
.
mVariableFramesInPacket
=
0
;
userData
-
>
mPacket
.
mDataByteSize
=
userData
-
>
mDataSize
;
*
aPacketDesc
=
&
userData
-
>
mPacket
;
}
aData
-
>
mBuffers
[
0
]
.
mNumberChannels
=
userData
-
>
mChannels
;
aData
-
>
mBuffers
[
0
]
.
mDataByteSize
=
userData
-
>
mDataSize
;
aData
-
>
mBuffers
[
0
]
.
mData
=
const_cast
<
void
*
>
(
userData
-
>
mData
)
;
userData
-
>
mDataSize
=
0
;
return
noErr
;
}
void
AppleATDecoder
:
:
SubmitSample
(
MediaRawData
*
aSample
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
if
(
mIsFlushing
)
{
return
;
}
nsresult
rv
=
NS_OK
;
if
(
!
mConverter
)
{
rv
=
SetupDecoder
(
aSample
)
;
if
(
rv
!
=
NS_OK
&
&
rv
!
=
NS_ERROR_NOT_INITIALIZED
)
{
mCallback
-
>
Error
(
MediaResult
(
rv
RESULT_DETAIL
(
"
Unable
to
create
decoder
"
)
)
)
;
return
;
}
}
mQueuedSamples
.
AppendElement
(
aSample
)
;
if
(
rv
=
=
NS_OK
)
{
for
(
size_t
i
=
0
;
i
<
mQueuedSamples
.
Length
(
)
;
i
+
+
)
{
rv
=
DecodeSample
(
mQueuedSamples
[
i
]
)
;
if
(
NS_FAILED
(
rv
)
)
{
mQueuedSamples
.
Clear
(
)
;
mCallback
-
>
Error
(
MediaResult
(
rv
RESULT_DETAIL
(
"
Unable
to
decode
sample
%
lld
"
aSample
-
>
mTime
)
)
)
;
return
;
}
}
mQueuedSamples
.
Clear
(
)
;
}
mCallback
-
>
InputExhausted
(
)
;
}
nsresult
AppleATDecoder
:
:
DecodeSample
(
MediaRawData
*
aSample
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
nsTArray
<
AudioDataValue
>
outputData
;
UInt32
channels
=
mOutputFormat
.
mChannelsPerFrame
;
const
uint32_t
MAX_AUDIO_FRAMES
=
128
;
const
uint32_t
maxDecodedSamples
=
MAX_AUDIO_FRAMES
*
channels
;
auto
packets
=
MakeUnique
<
AudioStreamPacketDescription
[
]
>
(
MAX_AUDIO_FRAMES
)
;
PassthroughUserData
userData
=
{
channels
(
UInt32
)
aSample
-
>
Size
(
)
aSample
-
>
Data
(
)
}
;
AlignedAudioBuffer
decoded
(
maxDecodedSamples
)
;
if
(
!
decoded
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
do
{
AudioBufferList
decBuffer
;
decBuffer
.
mNumberBuffers
=
1
;
decBuffer
.
mBuffers
[
0
]
.
mNumberChannels
=
channels
;
decBuffer
.
mBuffers
[
0
]
.
mDataByteSize
=
maxDecodedSamples
*
sizeof
(
AudioDataValue
)
;
decBuffer
.
mBuffers
[
0
]
.
mData
=
decoded
.
get
(
)
;
UInt32
numFrames
=
MAX_AUDIO_FRAMES
;
OSStatus
rv
=
AudioConverterFillComplexBuffer
(
mConverter
_PassthroughInputDataCallback
&
userData
&
numFrames
&
decBuffer
packets
.
get
(
)
)
;
if
(
rv
&
&
rv
!
=
kNoMoreDataErr
)
{
LOG
(
"
Error
decoding
audio
stream
:
%
d
\
n
"
rv
)
;
return
NS_ERROR_DOM_MEDIA_DECODE_ERR
;
}
if
(
numFrames
)
{
outputData
.
AppendElements
(
decoded
.
get
(
)
numFrames
*
channels
)
;
}
if
(
rv
=
=
kNoMoreDataErr
)
{
break
;
}
}
while
(
true
)
;
if
(
outputData
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
size_t
numFrames
=
outputData
.
Length
(
)
/
channels
;
int
rate
=
mOutputFormat
.
mSampleRate
;
media
:
:
TimeUnit
duration
=
FramesToTimeUnit
(
numFrames
rate
)
;
if
(
!
duration
.
IsValid
(
)
)
{
NS_WARNING
(
"
Invalid
count
of
accumulated
audio
samples
"
)
;
return
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
;
}
#
ifdef
LOG_SAMPLE_DECODE
LOG
(
"
pushed
audio
at
time
%
lfs
;
duration
%
lfs
\
n
"
(
double
)
aSample
-
>
mTime
/
USECS_PER_S
duration
.
ToSeconds
(
)
)
;
#
endif
AudioSampleBuffer
data
(
outputData
.
Elements
(
)
outputData
.
Length
(
)
)
;
if
(
!
data
.
Data
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
mChannelLayout
&
&
!
mAudioConverter
)
{
AudioConfig
in
(
*
mChannelLayout
.
get
(
)
rate
)
;
AudioConfig
out
(
channels
rate
)
;
if
(
!
in
.
IsValid
(
)
|
|
!
out
.
IsValid
(
)
)
{
return
NS_ERROR_DOM_MEDIA_DECODE_ERR
;
}
mAudioConverter
=
MakeUnique
<
AudioConverter
>
(
in
out
)
;
}
if
(
mAudioConverter
)
{
MOZ_ASSERT
(
mAudioConverter
-
>
CanWorkInPlace
(
)
)
;
data
=
mAudioConverter
-
>
Process
(
Move
(
data
)
)
;
}
RefPtr
<
AudioData
>
audio
=
new
AudioData
(
aSample
-
>
mOffset
aSample
-
>
mTime
duration
.
ToMicroseconds
(
)
numFrames
data
.
Forget
(
)
channels
rate
)
;
mCallback
-
>
Output
(
audio
)
;
return
NS_OK
;
}
nsresult
AppleATDecoder
:
:
GetInputAudioDescription
(
AudioStreamBasicDescription
&
aDesc
const
nsTArray
<
uint8_t
>
&
aExtraData
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
AudioFormatInfo
formatInfo
;
PodZero
(
&
formatInfo
.
mASBD
)
;
formatInfo
.
mASBD
.
mFormatID
=
mFormatID
;
if
(
mFormatID
=
=
kAudioFormatMPEG4AAC
)
{
formatInfo
.
mASBD
.
mFormatFlags
=
mConfig
.
mExtendedProfile
;
}
formatInfo
.
mMagicCookieSize
=
aExtraData
.
Length
(
)
;
formatInfo
.
mMagicCookie
=
aExtraData
.
Elements
(
)
;
UInt32
formatListSize
;
aDesc
.
mFormatID
=
mFormatID
;
aDesc
.
mChannelsPerFrame
=
mConfig
.
mChannels
;
aDesc
.
mSampleRate
=
mConfig
.
mRate
;
UInt32
inputFormatSize
=
sizeof
(
aDesc
)
;
OSStatus
rv
=
AudioFormatGetProperty
(
kAudioFormatProperty_FormatInfo
0
NULL
&
inputFormatSize
&
aDesc
)
;
if
(
NS_WARN_IF
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
AudioFormatGetPropertyInfo
(
kAudioFormatProperty_FormatList
sizeof
(
formatInfo
)
&
formatInfo
&
formatListSize
)
;
if
(
rv
|
|
(
formatListSize
%
sizeof
(
AudioFormatListItem
)
)
)
{
return
NS_OK
;
}
size_t
listCount
=
formatListSize
/
sizeof
(
AudioFormatListItem
)
;
auto
formatList
=
MakeUnique
<
AudioFormatListItem
[
]
>
(
listCount
)
;
rv
=
AudioFormatGetProperty
(
kAudioFormatProperty_FormatList
sizeof
(
formatInfo
)
&
formatInfo
&
formatListSize
formatList
.
get
(
)
)
;
if
(
rv
)
{
return
NS_OK
;
}
LOG
(
"
found
%
u
available
audio
stream
(
s
)
"
formatListSize
/
sizeof
(
AudioFormatListItem
)
)
;
UInt32
itemIndex
;
UInt32
indexSize
=
sizeof
(
itemIndex
)
;
rv
=
AudioFormatGetProperty
(
kAudioFormatProperty_FirstPlayableFormatFromList
formatListSize
formatList
.
get
(
)
&
indexSize
&
itemIndex
)
;
if
(
rv
)
{
return
NS_OK
;
}
aDesc
=
formatList
[
itemIndex
]
.
mASBD
;
return
NS_OK
;
}
AudioConfig
:
:
Channel
ConvertChannelLabel
(
AudioChannelLabel
id
)
{
switch
(
id
)
{
case
kAudioChannelLabel_Mono
:
return
AudioConfig
:
:
CHANNEL_MONO
;
case
kAudioChannelLabel_Left
:
return
AudioConfig
:
:
CHANNEL_LEFT
;
case
kAudioChannelLabel_Right
:
return
AudioConfig
:
:
CHANNEL_RIGHT
;
case
kAudioChannelLabel_Center
:
return
AudioConfig
:
:
CHANNEL_CENTER
;
case
kAudioChannelLabel_LFEScreen
:
return
AudioConfig
:
:
CHANNEL_LFE
;
case
kAudioChannelLabel_LeftSurround
:
return
AudioConfig
:
:
CHANNEL_LS
;
case
kAudioChannelLabel_RightSurround
:
return
AudioConfig
:
:
CHANNEL_RS
;
case
kAudioChannelLabel_CenterSurround
:
return
AudioConfig
:
:
CHANNEL_RCENTER
;
case
kAudioChannelLabel_RearSurroundLeft
:
return
AudioConfig
:
:
CHANNEL_RLS
;
case
kAudioChannelLabel_RearSurroundRight
:
return
AudioConfig
:
:
CHANNEL_RRS
;
default
:
return
AudioConfig
:
:
CHANNEL_INVALID
;
}
}
nsresult
AppleATDecoder
:
:
SetupChannelLayout
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
UInt32
propertySize
;
UInt32
size
;
OSStatus
status
=
AudioConverterGetPropertyInfo
(
mConverter
kAudioConverterOutputChannelLayout
&
propertySize
NULL
)
;
if
(
status
|
|
!
propertySize
)
{
LOG
(
"
Couldn
'
t
get
channel
layout
property
(
%
s
)
"
FourCC2Str
(
status
)
)
;
return
NS_ERROR_FAILURE
;
}
auto
data
=
MakeUnique
<
uint8_t
[
]
>
(
propertySize
)
;
size
=
propertySize
;
status
=
AudioConverterGetProperty
(
mConverter
kAudioConverterInputChannelLayout
&
size
data
.
get
(
)
)
;
if
(
status
|
|
size
!
=
propertySize
)
{
LOG
(
"
Couldn
'
t
get
channel
layout
property
(
%
s
)
"
FourCC2Str
(
status
)
)
;
return
NS_ERROR_FAILURE
;
}
AudioChannelLayout
*
layout
=
reinterpret_cast
<
AudioChannelLayout
*
>
(
data
.
get
(
)
)
;
AudioChannelLayoutTag
tag
=
layout
-
>
mChannelLayoutTag
;
if
(
tag
!
=
kAudioChannelLayoutTag_UseChannelDescriptions
)
{
AudioFormatPropertyID
property
=
tag
=
=
kAudioChannelLayoutTag_UseChannelBitmap
?
kAudioFormatProperty_ChannelLayoutForBitmap
:
kAudioFormatProperty_ChannelLayoutForTag
;
if
(
property
=
=
kAudioFormatProperty_ChannelLayoutForBitmap
)
{
status
=
AudioFormatGetPropertyInfo
(
property
sizeof
(
UInt32
)
&
layout
-
>
mChannelBitmap
&
propertySize
)
;
}
else
{
status
=
AudioFormatGetPropertyInfo
(
property
sizeof
(
AudioChannelLayoutTag
)
&
tag
&
propertySize
)
;
}
if
(
status
|
|
!
propertySize
)
{
LOG
(
"
Couldn
'
t
get
channel
layout
property
info
(
%
s
:
%
s
)
"
FourCC2Str
(
property
)
FourCC2Str
(
status
)
)
;
return
NS_ERROR_FAILURE
;
}
data
=
MakeUnique
<
uint8_t
[
]
>
(
propertySize
)
;
layout
=
reinterpret_cast
<
AudioChannelLayout
*
>
(
data
.
get
(
)
)
;
size
=
propertySize
;
if
(
property
=
=
kAudioFormatProperty_ChannelLayoutForBitmap
)
{
status
=
AudioFormatGetProperty
(
property
sizeof
(
UInt32
)
&
layout
-
>
mChannelBitmap
&
size
layout
)
;
}
else
{
status
=
AudioFormatGetProperty
(
property
sizeof
(
AudioChannelLayoutTag
)
&
tag
&
size
layout
)
;
}
if
(
status
|
|
size
!
=
propertySize
)
{
LOG
(
"
Couldn
'
t
get
channel
layout
property
(
%
s
:
%
s
)
"
FourCC2Str
(
property
)
FourCC2Str
(
status
)
)
;
return
NS_ERROR_FAILURE
;
}
layout
-
>
mChannelLayoutTag
=
kAudioChannelLayoutTag_UseChannelDescriptions
;
}
if
(
layout
-
>
mNumberChannelDescriptions
>
MAX_AUDIO_CHANNELS
|
|
layout
-
>
mNumberChannelDescriptions
!
=
mOutputFormat
.
mChannelsPerFrame
)
{
LOG
(
"
Nonsensical
channel
layout
or
not
matching
the
original
channel
number
"
)
;
return
NS_ERROR_FAILURE
;
}
AudioConfig
:
:
Channel
channels
[
MAX_AUDIO_CHANNELS
]
;
for
(
uint32_t
i
=
0
;
i
<
layout
-
>
mNumberChannelDescriptions
;
i
+
+
)
{
AudioChannelLabel
id
=
layout
-
>
mChannelDescriptions
[
i
]
.
mChannelLabel
;
AudioConfig
:
:
Channel
channel
=
ConvertChannelLabel
(
id
)
;
channels
[
i
]
=
channel
;
}
mChannelLayout
=
MakeUnique
<
AudioConfig
:
:
ChannelLayout
>
(
mOutputFormat
.
mChannelsPerFrame
channels
)
;
return
NS_OK
;
}
nsresult
AppleATDecoder
:
:
SetupDecoder
(
MediaRawData
*
aSample
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
static
const
uint32_t
MAX_FRAMES
=
2
;
if
(
mFormatID
=
=
kAudioFormatMPEG4AAC
&
&
mConfig
.
mExtendedProfile
=
=
2
&
&
mParsedFramesForAACMagicCookie
<
MAX_FRAMES
)
{
if
(
NS_SUCCEEDED
(
GetImplicitAACMagicCookie
(
aSample
)
)
&
&
!
mMagicCookie
.
Length
(
)
)
{
mParsedFramesForAACMagicCookie
+
+
;
return
NS_ERROR_NOT_INITIALIZED
;
}
}
LOG
(
"
Initializing
Apple
AudioToolbox
decoder
"
)
;
AudioStreamBasicDescription
inputFormat
;
PodZero
(
&
inputFormat
)
;
nsresult
rv
=
GetInputAudioDescription
(
inputFormat
mMagicCookie
.
Length
(
)
?
mMagicCookie
:
*
mConfig
.
mExtraData
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
PodZero
(
&
mOutputFormat
)
;
mOutputFormat
.
mFormatID
=
kAudioFormatLinearPCM
;
mOutputFormat
.
mSampleRate
=
inputFormat
.
mSampleRate
;
mOutputFormat
.
mChannelsPerFrame
=
inputFormat
.
mChannelsPerFrame
;
#
if
defined
(
MOZ_SAMPLE_TYPE_FLOAT32
)
mOutputFormat
.
mBitsPerChannel
=
32
;
mOutputFormat
.
mFormatFlags
=
kLinearPCMFormatFlagIsFloat
|
0
;
#
elif
defined
(
MOZ_SAMPLE_TYPE_S16
)
mOutputFormat
.
mBitsPerChannel
=
16
;
mOutputFormat
.
mFormatFlags
=
kLinearPCMFormatFlagIsSignedInteger
|
0
;
#
else
#
error
Unknown
audio
sample
type
#
endif
mOutputFormat
.
mFramesPerPacket
=
1
;
mOutputFormat
.
mBytesPerPacket
=
mOutputFormat
.
mBytesPerFrame
=
mOutputFormat
.
mChannelsPerFrame
*
mOutputFormat
.
mBitsPerChannel
/
8
;
OSStatus
status
=
AudioConverterNew
(
&
inputFormat
&
mOutputFormat
&
mConverter
)
;
if
(
status
)
{
LOG
(
"
Error
%
d
constructing
AudioConverter
"
status
)
;
mConverter
=
nullptr
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_FAILED
(
SetupChannelLayout
(
)
)
)
{
NS_WARNING
(
"
Couldn
'
t
retrieve
channel
layout
will
use
default
layout
"
)
;
}
return
NS_OK
;
}
static
void
_MetadataCallback
(
void
*
aAppleATDecoder
AudioFileStreamID
aStream
AudioFileStreamPropertyID
aProperty
UInt32
*
aFlags
)
{
AppleATDecoder
*
decoder
=
static_cast
<
AppleATDecoder
*
>
(
aAppleATDecoder
)
;
LOG
(
"
MetadataCallback
receiving
:
'
%
s
'
"
FourCC2Str
(
aProperty
)
)
;
if
(
aProperty
=
=
kAudioFileStreamProperty_MagicCookieData
)
{
UInt32
size
;
Boolean
writeable
;
OSStatus
rv
=
AudioFileStreamGetPropertyInfo
(
aStream
aProperty
&
size
&
writeable
)
;
if
(
rv
)
{
LOG
(
"
Couldn
'
t
get
property
info
for
'
%
s
'
(
%
s
)
"
FourCC2Str
(
aProperty
)
FourCC2Str
(
rv
)
)
;
decoder
-
>
mFileStreamError
=
true
;
return
;
}
auto
data
=
MakeUnique
<
uint8_t
[
]
>
(
size
)
;
rv
=
AudioFileStreamGetProperty
(
aStream
aProperty
&
size
data
.
get
(
)
)
;
if
(
rv
)
{
LOG
(
"
Couldn
'
t
get
property
'
%
s
'
(
%
s
)
"
FourCC2Str
(
aProperty
)
FourCC2Str
(
rv
)
)
;
decoder
-
>
mFileStreamError
=
true
;
return
;
}
decoder
-
>
mMagicCookie
.
AppendElements
(
data
.
get
(
)
size
)
;
}
}
static
void
_SampleCallback
(
void
*
aSBR
UInt32
aNumBytes
UInt32
aNumPackets
const
void
*
aData
AudioStreamPacketDescription
*
aPackets
)
{
}
nsresult
AppleATDecoder
:
:
GetImplicitAACMagicCookie
(
const
MediaRawData
*
aSample
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
RefPtr
<
MediaRawData
>
adtssample
(
aSample
-
>
Clone
(
)
)
;
if
(
!
adtssample
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
int8_t
frequency_index
=
mp4_demuxer
:
:
Adts
:
:
GetFrequencyIndex
(
mConfig
.
mRate
)
;
bool
rv
=
mp4_demuxer
:
:
Adts
:
:
ConvertSample
(
mConfig
.
mChannels
frequency_index
mConfig
.
mProfile
adtssample
)
;
if
(
!
rv
)
{
NS_WARNING
(
"
Failed
to
apply
ADTS
header
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
mStream
)
{
OSStatus
rv
=
AudioFileStreamOpen
(
this
_MetadataCallback
_SampleCallback
kAudioFileAAC_ADTSType
&
mStream
)
;
if
(
rv
)
{
NS_WARNING
(
"
Couldn
'
t
open
AudioFileStream
"
)
;
return
NS_ERROR_FAILURE
;
}
}
OSStatus
status
=
AudioFileStreamParseBytes
(
mStream
adtssample
-
>
Size
(
)
adtssample
-
>
Data
(
)
0
)
;
if
(
status
)
{
NS_WARNING
(
"
Couldn
'
t
parse
sample
"
)
;
}
if
(
status
|
|
mFileStreamError
|
|
mMagicCookie
.
Length
(
)
)
{
AudioFileStreamClose
(
mStream
)
;
mStream
=
nullptr
;
}
return
(
mFileStreamError
|
|
status
)
?
NS_ERROR_FAILURE
:
NS_OK
;
}
}
