#
ifndef
mozilla_AppleVTDecoder_h
#
define
mozilla_AppleVTDecoder_h
#
include
<
CoreFoundation
/
CFDictionary
.
h
>
#
include
<
CoreMedia
/
CoreMedia
.
h
>
#
include
<
VideoToolbox
/
VideoToolbox
.
h
>
#
include
"
AppleDecoderModule
.
h
"
#
include
"
PerformanceRecorder
.
h
"
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
ReorderQueue
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
ProfilerUtils
.
h
"
namespace
mozilla
{
DDLoggedTypeDeclNameAndBase
(
AppleVTDecoder
MediaDataDecoder
)
;
class
AppleVTDecoder
:
public
MediaDataDecoder
public
DecoderDoctorLifeLogger
<
AppleVTDecoder
>
{
public
:
AppleVTDecoder
(
const
VideoInfo
&
aConfig
layers
:
:
ImageContainer
*
aImageContainer
CreateDecoderParams
:
:
OptionSet
aOptions
layers
:
:
KnowsCompositor
*
aKnowsCompositor
Maybe
<
TrackingId
>
aTrackingId
)
;
class
AppleFrameRef
{
public
:
media
:
:
TimeUnit
decode_timestamp
;
media
:
:
TimeUnit
composition_timestamp
;
media
:
:
TimeUnit
duration
;
int64_t
byte_offset
;
bool
is_sync_point
;
explicit
AppleFrameRef
(
const
MediaRawData
&
aSample
)
:
decode_timestamp
(
aSample
.
mTimecode
)
composition_timestamp
(
aSample
.
mTime
)
duration
(
aSample
.
mDuration
)
byte_offset
(
aSample
.
mOffset
)
is_sync_point
(
aSample
.
mKeyframe
)
{
}
}
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
RefPtr
<
DecodePromise
>
Decode
(
MediaRawData
*
aSample
)
override
;
RefPtr
<
DecodePromise
>
Drain
(
)
override
;
RefPtr
<
FlushPromise
>
Flush
(
)
override
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
void
SetSeekThreshold
(
const
media
:
:
TimeUnit
&
aTime
)
override
;
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
override
{
return
mIsHardwareAccelerated
;
}
nsCString
GetDescriptionName
(
)
const
override
{
return
mIsHardwareAccelerated
?
"
apple
hardware
VT
decoder
"
_ns
:
"
apple
software
VT
decoder
"
_ns
;
}
nsCString
GetCodecName
(
)
const
override
;
ConversionRequired
NeedsConversion
(
)
const
override
{
return
ConversionRequired
:
:
kNeedAVCC
;
}
void
OutputFrame
(
CVPixelBufferRef
aImage
AppleFrameRef
aFrameRef
)
;
void
OnDecodeError
(
OSStatus
aError
)
;
private
:
friend
class
AppleDecoderModule
;
virtual
~
AppleVTDecoder
(
)
;
RefPtr
<
FlushPromise
>
ProcessFlush
(
)
;
RefPtr
<
DecodePromise
>
ProcessDrain
(
)
;
void
ProcessShutdown
(
)
;
void
ProcessDecode
(
MediaRawData
*
aSample
)
;
void
MaybeResolveBufferedFrames
(
)
;
void
MaybeRegisterCallbackThread
(
)
;
void
AssertOnTaskQueue
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
}
AppleFrameRef
*
CreateAppleFrameRef
(
const
MediaRawData
*
aSample
)
;
CFDictionaryRef
CreateOutputConfiguration
(
)
;
const
RefPtr
<
MediaByteBuffer
>
mExtraData
;
const
uint32_t
mPictureWidth
;
const
uint32_t
mPictureHeight
;
const
uint32_t
mDisplayWidth
;
const
uint32_t
mDisplayHeight
;
const
gfx
:
:
YUVColorSpace
mColorSpace
;
const
gfx
:
:
ColorSpace2
mColorPrimaries
;
const
gfx
:
:
TransferFunction
mTransferFunction
;
const
gfx
:
:
ColorRange
mColorRange
;
const
gfx
:
:
ColorDepth
mColorDepth
;
MediaResult
InitializeSession
(
)
;
nsresult
WaitForAsynchronousFrames
(
)
;
CFDictionaryRef
CreateDecoderSpecification
(
)
;
CFDictionaryRef
CreateDecoderExtensions
(
)
;
enum
class
StreamType
{
Unknown
H264
VP9
}
;
const
StreamType
mStreamType
;
const
RefPtr
<
TaskQueue
>
mTaskQueue
;
const
uint32_t
mMaxRefFrames
;
const
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
const
RefPtr
<
layers
:
:
KnowsCompositor
>
mKnowsCompositor
;
const
bool
mUseSoftwareImages
;
const
Maybe
<
TrackingId
>
mTrackingId
;
Atomic
<
bool
>
mIsFlushing
;
std
:
:
atomic
<
ProfilerThreadId
>
mCallbackThreadId
;
Monitor
mMonitor
MOZ_UNANNOTATED
;
ReorderQueue
mReorderQueue
;
MozMonitoredPromiseHolder
<
DecodePromise
>
mPromise
;
Maybe
<
media
:
:
TimeUnit
>
mSeekTargetThreshold
;
CMVideoFormatDescriptionRef
mFormat
;
VTDecompressionSessionRef
mSession
;
Atomic
<
bool
>
mIsHardwareAccelerated
;
PerformanceRecorderMulti
<
DecodeStage
>
mPerformanceRecorder
;
}
;
}
#
endif
