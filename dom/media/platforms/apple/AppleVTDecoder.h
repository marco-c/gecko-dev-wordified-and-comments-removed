#
ifndef
mozilla_AppleVTDecoder_h
#
define
mozilla_AppleVTDecoder_h
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
ReorderQueue
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
VideoToolbox
/
VideoToolbox
.
h
"
namespace
mozilla
{
class
AppleVTDecoder
:
public
MediaDataDecoder
{
public
:
AppleVTDecoder
(
const
VideoInfo
&
aConfig
TaskQueue
*
aTaskQueue
MediaDataDecoderCallback
*
aCallback
layers
:
:
ImageContainer
*
aImageContainer
)
;
class
AppleFrameRef
{
public
:
media
:
:
TimeUnit
decode_timestamp
;
media
:
:
TimeUnit
composition_timestamp
;
media
:
:
TimeUnit
duration
;
int64_t
byte_offset
;
bool
is_sync_point
;
explicit
AppleFrameRef
(
const
MediaRawData
&
aSample
)
:
decode_timestamp
(
media
:
:
TimeUnit
:
:
FromMicroseconds
(
aSample
.
mTimecode
)
)
composition_timestamp
(
media
:
:
TimeUnit
:
:
FromMicroseconds
(
aSample
.
mTime
)
)
duration
(
media
:
:
TimeUnit
:
:
FromMicroseconds
(
aSample
.
mDuration
)
)
byte_offset
(
aSample
.
mOffset
)
is_sync_point
(
aSample
.
mKeyframe
)
{
}
}
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
nsresult
Input
(
MediaRawData
*
aSample
)
override
;
nsresult
Flush
(
)
override
;
nsresult
Drain
(
)
override
;
nsresult
Shutdown
(
)
override
;
void
SetSeekThreshold
(
const
media
:
:
TimeUnit
&
aTime
)
override
;
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
override
{
return
mIsHardwareAccelerated
;
}
const
char
*
GetDescriptionName
(
)
const
override
{
return
mIsHardwareAccelerated
?
"
apple
hardware
VT
decoder
"
:
"
apple
software
VT
decoder
"
;
}
nsresult
OutputFrame
(
CVPixelBufferRef
aImage
AppleFrameRef
aFrameRef
)
;
private
:
virtual
~
AppleVTDecoder
(
)
;
void
ProcessFlush
(
)
;
void
ProcessDrain
(
)
;
void
ProcessShutdown
(
)
;
nsresult
ProcessDecode
(
MediaRawData
*
aSample
)
;
void
AssertOnTaskQueueThread
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
}
AppleFrameRef
*
CreateAppleFrameRef
(
const
MediaRawData
*
aSample
)
;
void
DrainReorderedFrames
(
)
;
void
ClearReorderedFrames
(
)
;
CFDictionaryRef
CreateOutputConfiguration
(
)
;
const
RefPtr
<
MediaByteBuffer
>
mExtraData
;
MediaDataDecoderCallback
*
mCallback
;
const
uint32_t
mPictureWidth
;
const
uint32_t
mPictureHeight
;
const
uint32_t
mDisplayWidth
;
const
uint32_t
mDisplayHeight
;
Atomic
<
uint32_t
>
mQueuedSamples
;
nsresult
InitializeSession
(
)
;
nsresult
WaitForAsynchronousFrames
(
)
;
CFDictionaryRef
CreateDecoderSpecification
(
)
;
CFDictionaryRef
CreateDecoderExtensions
(
)
;
nsresult
DoDecode
(
MediaRawData
*
aSample
)
;
const
RefPtr
<
TaskQueue
>
mTaskQueue
;
const
uint32_t
mMaxRefFrames
;
const
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
Atomic
<
uint32_t
>
mInputIncoming
;
Atomic
<
bool
>
mIsShutDown
;
const
bool
mUseSoftwareImages
;
Atomic
<
bool
>
mIsFlushing
;
Monitor
mMonitor
;
ReorderQueue
mReorderQueue
;
Maybe
<
media
:
:
TimeUnit
>
mSeekTargetThreshold
;
CMVideoFormatDescriptionRef
mFormat
;
VTDecompressionSessionRef
mSession
;
Atomic
<
bool
>
mIsHardwareAccelerated
;
}
;
}
#
endif
