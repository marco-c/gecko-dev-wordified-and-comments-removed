#
include
"
AppleATDecoder
.
h
"
#
include
"
AppleCMLinker
.
h
"
#
include
"
AppleDecoderModule
.
h
"
#
include
"
AppleVDADecoder
.
h
"
#
include
"
AppleVDALinker
.
h
"
#
include
"
AppleVTDecoder
.
h
"
#
include
"
AppleVTLinker
.
h
"
#
include
"
MacIOSurfaceImage
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
namespace
mozilla
{
bool
AppleDecoderModule
:
:
sInitialized
=
false
;
bool
AppleDecoderModule
:
:
sIsCoreMediaAvailable
=
false
;
bool
AppleDecoderModule
:
:
sIsVTAvailable
=
false
;
bool
AppleDecoderModule
:
:
sIsVTHWAvailable
=
false
;
bool
AppleDecoderModule
:
:
sIsVDAAvailable
=
false
;
bool
AppleDecoderModule
:
:
sForceVDA
=
false
;
bool
AppleDecoderModule
:
:
sCanUseHardwareVideoDecoder
=
true
;
AppleDecoderModule
:
:
AppleDecoderModule
(
)
{
}
AppleDecoderModule
:
:
~
AppleDecoderModule
(
)
{
}
void
AppleDecoderModule
:
:
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
on
main
thread
.
"
)
;
if
(
sInitialized
)
{
return
;
}
Preferences
:
:
AddBoolVarCache
(
&
sForceVDA
"
media
.
apple
.
forcevda
"
false
)
;
MacIOSurfaceLib
:
:
LoadLibrary
(
)
;
const
bool
loaded
=
MacIOSurfaceLib
:
:
isInit
(
)
;
sIsVDAAvailable
=
loaded
&
&
AppleVDALinker
:
:
Link
(
)
;
sIsCoreMediaAvailable
=
AppleCMLinker
:
:
Link
(
)
;
bool
haveVideoToolbox
=
loaded
&
&
AppleVTLinker
:
:
Link
(
)
;
sIsVTAvailable
=
sIsCoreMediaAvailable
&
&
haveVideoToolbox
;
sIsVTHWAvailable
=
AppleVTLinker
:
:
skPropEnableHWAccel
!
=
nullptr
;
sCanUseHardwareVideoDecoder
=
loaded
&
&
gfxPlatform
:
:
GetPlatform
(
)
-
>
CanUseHardwareVideoDecoding
(
)
;
sInitialized
=
true
;
}
nsresult
AppleDecoderModule
:
:
Startup
(
)
{
if
(
!
sInitialized
|
|
(
!
sIsVDAAvailable
&
&
!
sIsVTAvailable
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
already_AddRefed
<
MediaDataDecoder
>
AppleDecoderModule
:
:
CreateVideoDecoder
(
const
VideoInfo
&
aConfig
layers
:
:
LayersBackend
aLayersBackend
layers
:
:
ImageContainer
*
aImageContainer
FlushableTaskQueue
*
aVideoTaskQueue
MediaDataDecoderCallback
*
aCallback
)
{
RefPtr
<
MediaDataDecoder
>
decoder
;
if
(
sIsVDAAvailable
&
&
(
!
sIsVTHWAvailable
|
|
sForceVDA
)
)
{
decoder
=
AppleVDADecoder
:
:
CreateVDADecoder
(
aConfig
aVideoTaskQueue
aCallback
aImageContainer
)
;
if
(
decoder
)
{
return
decoder
.
forget
(
)
;
}
}
if
(
sIsVTAvailable
)
{
decoder
=
new
AppleVTDecoder
(
aConfig
aVideoTaskQueue
aCallback
aImageContainer
)
;
}
return
decoder
.
forget
(
)
;
}
already_AddRefed
<
MediaDataDecoder
>
AppleDecoderModule
:
:
CreateAudioDecoder
(
const
AudioInfo
&
aConfig
FlushableTaskQueue
*
aAudioTaskQueue
MediaDataDecoderCallback
*
aCallback
)
{
RefPtr
<
MediaDataDecoder
>
decoder
=
new
AppleATDecoder
(
aConfig
aAudioTaskQueue
aCallback
)
;
return
decoder
.
forget
(
)
;
}
bool
AppleDecoderModule
:
:
SupportsMimeType
(
const
nsACString
&
aMimeType
)
const
{
return
(
sIsCoreMediaAvailable
&
&
(
aMimeType
.
EqualsLiteral
(
"
audio
/
mpeg
"
)
|
|
aMimeType
.
EqualsLiteral
(
"
audio
/
mp4a
-
latm
"
)
)
)
|
|
(
(
sIsVTAvailable
|
|
sIsVDAAvailable
)
&
&
(
aMimeType
.
EqualsLiteral
(
"
video
/
mp4
"
)
|
|
aMimeType
.
EqualsLiteral
(
"
video
/
avc
"
)
)
)
;
}
PlatformDecoderModule
:
:
ConversionRequired
AppleDecoderModule
:
:
DecoderNeedsConversion
(
const
TrackInfo
&
aConfig
)
const
{
if
(
aConfig
.
IsVideo
(
)
)
{
return
kNeedAVCC
;
}
else
{
return
kNeedNone
;
}
}
}
