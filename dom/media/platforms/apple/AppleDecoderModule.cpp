#
include
"
AppleDecoderModule
.
h
"
#
include
<
dlfcn
.
h
>
#
include
"
AppleATDecoder
.
h
"
#
include
"
AppleVTDecoder
.
h
"
#
include
"
MP4Decoder
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
VPXDecoder
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
extern
"
C
"
{
extern
void
VTRegisterSupplementalVideoDecoderIfAvailable
(
CMVideoCodecType
codecType
)
__attribute__
(
(
weak_import
)
)
;
extern
Boolean
VTIsHardwareDecodeSupported
(
CMVideoCodecType
codecType
)
__attribute__
(
(
weak_import
)
)
;
}
namespace
mozilla
{
using
media
:
:
DecodeSupport
;
using
media
:
:
DecodeSupportSet
;
using
media
:
:
MCSInfo
;
using
media
:
:
MediaCodec
;
bool
AppleDecoderModule
:
:
sInitialized
=
false
;
bool
AppleDecoderModule
:
:
sCanUseVP9Decoder
=
false
;
bool
AppleDecoderModule
:
:
sCanUseAV1Decoder
=
false
;
void
AppleDecoderModule
:
:
Init
(
)
{
if
(
sInitialized
)
{
return
;
}
sInitialized
=
true
;
if
(
RegisterSupplementalVP9Decoder
(
)
)
{
sCanUseVP9Decoder
=
CanCreateHWDecoder
(
MediaCodec
:
:
VP9
)
;
}
sCanUseAV1Decoder
=
CanCreateHWDecoder
(
MediaCodec
:
:
AV1
)
;
}
nsresult
AppleDecoderModule
:
:
Startup
(
)
{
if
(
!
sInitialized
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
already_AddRefed
<
MediaDataDecoder
>
AppleDecoderModule
:
:
CreateVideoDecoder
(
const
CreateDecoderParams
&
aParams
)
{
if
(
Supports
(
SupportDecoderParams
(
aParams
)
nullptr
)
.
isEmpty
(
)
)
{
return
nullptr
;
}
RefPtr
<
MediaDataDecoder
>
decoder
;
if
(
IsVideoSupported
(
aParams
.
VideoConfig
(
)
aParams
.
mOptions
)
)
{
decoder
=
new
AppleVTDecoder
(
aParams
.
VideoConfig
(
)
aParams
.
mImageContainer
aParams
.
mOptions
aParams
.
mKnowsCompositor
aParams
.
mTrackingId
)
;
}
return
decoder
.
forget
(
)
;
}
already_AddRefed
<
MediaDataDecoder
>
AppleDecoderModule
:
:
CreateAudioDecoder
(
const
CreateDecoderParams
&
aParams
)
{
if
(
Supports
(
SupportDecoderParams
(
aParams
)
nullptr
)
.
isEmpty
(
)
)
{
return
nullptr
;
}
RefPtr
<
MediaDataDecoder
>
decoder
=
new
AppleATDecoder
(
aParams
.
AudioConfig
(
)
)
;
return
decoder
.
forget
(
)
;
}
DecodeSupportSet
AppleDecoderModule
:
:
SupportsMimeType
(
const
nsACString
&
aMimeType
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
bool
checkSupport
=
aMimeType
.
EqualsLiteral
(
"
audio
/
mp4a
-
latm
"
)
|
|
MP4Decoder
:
:
IsH264
(
aMimeType
)
|
|
VPXDecoder
:
:
IsVP9
(
aMimeType
)
|
|
AOMDecoder
:
:
IsAV1
(
aMimeType
)
;
DecodeSupportSet
supportType
{
}
;
if
(
checkSupport
)
{
UniquePtr
<
TrackInfo
>
trackInfo
=
CreateTrackInfoWithMIMEType
(
aMimeType
)
;
if
(
trackInfo
&
&
trackInfo
-
>
IsAudio
(
)
)
{
supportType
=
DecodeSupport
:
:
SoftwareDecode
;
}
else
if
(
trackInfo
&
&
trackInfo
-
>
IsVideo
(
)
)
{
supportType
=
Supports
(
SupportDecoderParams
(
*
trackInfo
)
aDiagnostics
)
;
}
}
MOZ_LOG
(
sPDMLog
LogLevel
:
:
Debug
(
"
Apple
decoder
%
s
requested
type
'
%
s
'
"
supportType
.
isEmpty
(
)
?
"
rejects
"
:
"
supports
"
aMimeType
.
BeginReading
(
)
)
)
;
return
supportType
;
}
DecodeSupportSet
AppleDecoderModule
:
:
Supports
(
const
SupportDecoderParams
&
aParams
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
const
auto
&
trackInfo
=
aParams
.
mConfig
;
if
(
trackInfo
.
IsAudio
(
)
)
{
return
SupportsMimeType
(
trackInfo
.
mMimeType
aDiagnostics
)
;
}
const
bool
checkSupport
=
trackInfo
.
GetAsVideoInfo
(
)
&
&
IsVideoSupported
(
*
trackInfo
.
GetAsVideoInfo
(
)
)
;
DecodeSupportSet
dss
{
}
;
if
(
!
checkSupport
)
{
return
dss
;
}
const
MediaCodec
codec
=
MCSInfo
:
:
GetMediaCodecFromMimeType
(
trackInfo
.
mMimeType
)
;
if
(
CanCreateHWDecoder
(
codec
)
)
{
dss
+
=
DecodeSupport
:
:
HardwareDecode
;
}
switch
(
codec
)
{
case
MediaCodec
:
:
VP8
:
[
[
fallthrough
]
]
;
case
MediaCodec
:
:
VP9
:
if
(
StaticPrefs
:
:
media_rdd_vpx_enabled
(
)
&
&
StaticPrefs
:
:
media_utility_ffvpx_enabled
(
)
)
{
dss
+
=
DecodeSupport
:
:
SoftwareDecode
;
}
break
;
default
:
dss
+
=
DecodeSupport
:
:
SoftwareDecode
;
break
;
}
return
dss
;
}
bool
AppleDecoderModule
:
:
IsVideoSupported
(
const
VideoInfo
&
aConfig
const
CreateDecoderParams
:
:
OptionSet
&
aOptions
)
const
{
if
(
MP4Decoder
:
:
IsH264
(
aConfig
.
mMimeType
)
)
{
return
true
;
}
if
(
AOMDecoder
:
:
IsAV1
(
aConfig
.
mMimeType
)
)
{
if
(
!
sCanUseAV1Decoder
|
|
aOptions
.
contains
(
CreateDecoderParams
:
:
Option
:
:
HardwareDecoderNotAllowed
)
)
{
return
false
;
}
return
true
;
}
if
(
!
VPXDecoder
:
:
IsVP9
(
aConfig
.
mMimeType
)
|
|
!
sCanUseVP9Decoder
|
|
aOptions
.
contains
(
CreateDecoderParams
:
:
Option
:
:
HardwareDecoderNotAllowed
)
)
{
return
false
;
}
if
(
VPXDecoder
:
:
IsVP9
(
aConfig
.
mMimeType
)
&
&
aOptions
.
contains
(
CreateDecoderParams
:
:
Option
:
:
LowLatency
)
)
{
return
false
;
}
if
(
aConfig
.
HasAlpha
(
)
)
{
return
false
;
}
if
(
aConfig
.
mColorDepth
!
=
gfx
:
:
ColorDepth
:
:
COLOR_8
&
&
aConfig
.
mColorDepth
!
=
gfx
:
:
ColorDepth
:
:
COLOR_10
)
{
return
false
;
}
if
(
aConfig
.
mExtraData
&
&
aConfig
.
mExtraData
-
>
Length
(
)
<
5
)
{
return
true
;
}
int
profile
=
aConfig
.
mExtraData
-
>
ElementAt
(
4
)
;
return
profile
=
=
0
|
|
profile
=
=
2
;
}
bool
AppleDecoderModule
:
:
CanCreateHWDecoder
(
MediaCodec
aCodec
)
{
if
(
!
gfx
:
:
gfxVars
:
:
CanUseHardwareVideoDecoding
(
)
)
{
return
false
;
}
VideoInfo
info
(
1920
1080
)
;
bool
vtReportsSupport
=
false
;
if
(
!
VTIsHardwareDecodeSupported
)
{
return
false
;
}
switch
(
aCodec
)
{
case
MediaCodec
:
:
AV1
:
{
info
.
mMimeType
=
"
video
/
av1
"
;
bool
hasSeqHdr
;
AOMDecoder
:
:
AV1SequenceInfo
seqInfo
;
AOMDecoder
:
:
OperatingPoint
op
;
seqInfo
.
mOperatingPoints
.
AppendElement
(
op
)
;
seqInfo
.
mImage
=
{
1920
1080
}
;
AOMDecoder
:
:
WriteAV1CBox
(
seqInfo
info
.
mExtraData
hasSeqHdr
)
;
vtReportsSupport
=
VTIsHardwareDecodeSupported
(
kCMVideoCodecType_AV1
)
;
break
;
}
case
MediaCodec
:
:
VP9
:
info
.
mMimeType
=
"
video
/
vp9
"
;
VPXDecoder
:
:
GetVPCCBox
(
info
.
mExtraData
VPXDecoder
:
:
VPXStreamInfo
(
)
)
;
vtReportsSupport
=
VTIsHardwareDecodeSupported
(
kCMVideoCodecType_VP9
)
;
break
;
case
MediaCodec
:
:
H264
:
if
(
__builtin_available
(
macos
10
.
15
*
)
)
{
info
.
mMimeType
=
"
video
/
avc
"
;
vtReportsSupport
=
VTIsHardwareDecodeSupported
(
kCMVideoCodecType_H264
)
;
}
break
;
default
:
vtReportsSupport
=
false
;
break
;
}
if
(
vtReportsSupport
)
{
RefPtr
<
AppleVTDecoder
>
decoder
=
new
AppleVTDecoder
(
info
nullptr
{
}
nullptr
Nothing
(
)
)
;
MediaResult
rv
=
decoder
-
>
InitializeSession
(
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
)
{
MOZ_LOG
(
sPDMLog
LogLevel
:
:
Debug
(
"
Apple
HW
decode
failure
while
initializing
VT
decoder
session
"
)
)
;
return
false
;
}
nsAutoCString
failureReason
;
bool
hwSupport
=
decoder
-
>
IsHardwareAccelerated
(
failureReason
)
|
|
aCodec
=
=
MediaCodec
:
:
H264
;
if
(
!
hwSupport
)
{
MOZ_LOG
(
sPDMLog
LogLevel
:
:
Debug
(
"
Apple
HW
decode
failure
:
'
%
s
'
"
failureReason
.
BeginReading
(
)
)
)
;
}
decoder
-
>
Shutdown
(
)
;
return
hwSupport
;
}
return
false
;
}
bool
AppleDecoderModule
:
:
RegisterSupplementalVP9Decoder
(
)
{
#
ifdef
XP_MACOSX
static
bool
sRegisterIfAvailable
=
[
]
(
)
{
if
(
__builtin_available
(
macos
11
.
0
*
)
)
{
VTRegisterSupplementalVideoDecoderIfAvailable
(
kCMVideoCodecType_VP9
)
;
return
true
;
}
return
false
;
}
(
)
;
return
sRegisterIfAvailable
;
#
else
return
false
;
#
endif
}
already_AddRefed
<
PlatformDecoderModule
>
AppleDecoderModule
:
:
Create
(
)
{
return
MakeAndAddRef
<
AppleDecoderModule
>
(
)
;
}
}
