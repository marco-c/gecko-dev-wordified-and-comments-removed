#
ifndef
AllocationPolicy_h_
#
define
AllocationPolicy_h_
#
include
<
queue
>
#
include
"
MediaInfo
.
h
"
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
namespace
mozilla
{
class
GlobalAllocPolicy
{
public
:
class
Token
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Token
)
protected
:
virtual
~
Token
(
)
{
}
}
;
using
Promise
=
MozPromise
<
RefPtr
<
Token
>
bool
true
>
;
RefPtr
<
Promise
>
Alloc
(
)
;
void
operator
=
(
decltype
(
nullptr
)
)
;
static
GlobalAllocPolicy
&
Instance
(
TrackInfo
:
:
TrackType
aTrack
)
;
private
:
class
AutoDeallocToken
;
using
PromisePrivate
=
Promise
:
:
Private
;
GlobalAllocPolicy
(
)
;
~
GlobalAllocPolicy
(
)
;
void
Dealloc
(
)
;
void
ResolvePromise
(
ReentrantMonitorAutoEnter
&
aProofOfLock
)
;
static
StaticMutex
sMutex
;
ReentrantMonitor
mMonitor
;
int
mDecoderLimit
;
std
:
:
queue
<
RefPtr
<
PromisePrivate
>
>
mPromises
;
}
;
class
LocalAllocPolicy
{
using
TrackType
=
TrackInfo
:
:
TrackType
;
using
Promise
=
GlobalAllocPolicy
:
:
Promise
;
using
Token
=
GlobalAllocPolicy
:
:
Token
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
LocalAllocPolicy
)
public
:
LocalAllocPolicy
(
TrackType
aTrack
TaskQueue
*
aOwnerThread
)
:
mTrack
(
aTrack
)
mOwnerThread
(
aOwnerThread
)
{
}
RefPtr
<
Promise
>
Alloc
(
)
;
void
Cancel
(
)
;
private
:
class
AutoDeallocToken
:
public
Token
{
public
:
explicit
AutoDeallocToken
(
LocalAllocPolicy
*
aOwner
)
:
mOwner
(
aOwner
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mOwner
-
>
mDecoderLimit
>
0
)
;
-
-
mOwner
-
>
mDecoderLimit
;
}
void
Append
(
Token
*
aToken
)
{
mToken
=
aToken
;
}
private
:
~
AutoDeallocToken
(
)
{
mToken
=
nullptr
;
+
+
mOwner
-
>
mDecoderLimit
;
mOwner
-
>
ProcessRequest
(
)
;
}
RefPtr
<
LocalAllocPolicy
>
mOwner
;
RefPtr
<
Token
>
mToken
;
}
;
~
LocalAllocPolicy
(
)
=
default
;
void
ProcessRequest
(
)
;
int
mDecoderLimit
=
1
;
const
TrackType
mTrack
;
RefPtr
<
TaskQueue
>
mOwnerThread
;
MozPromiseHolder
<
Promise
>
mPendingPromise
;
MozPromiseRequestHolder
<
Promise
>
mTokenRequest
;
}
;
class
AllocationWrapper
:
public
MediaDataDecoder
{
using
Token
=
GlobalAllocPolicy
:
:
Token
;
public
:
AllocationWrapper
(
already_AddRefed
<
MediaDataDecoder
>
aDecoder
already_AddRefed
<
Token
>
aToken
)
;
~
AllocationWrapper
(
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
{
return
mDecoder
-
>
Init
(
)
;
}
RefPtr
<
DecodePromise
>
Decode
(
MediaRawData
*
aSample
)
override
{
return
mDecoder
-
>
Decode
(
aSample
)
;
}
RefPtr
<
DecodePromise
>
Drain
(
)
override
{
return
mDecoder
-
>
Drain
(
)
;
}
RefPtr
<
FlushPromise
>
Flush
(
)
override
{
return
mDecoder
-
>
Flush
(
)
;
}
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
override
{
return
mDecoder
-
>
IsHardwareAccelerated
(
aFailureReason
)
;
}
nsCString
GetDescriptionName
(
)
const
override
{
return
mDecoder
-
>
GetDescriptionName
(
)
;
}
void
SetSeekThreshold
(
const
media
:
:
TimeUnit
&
aTime
)
override
{
mDecoder
-
>
SetSeekThreshold
(
aTime
)
;
}
bool
SupportDecoderRecycling
(
)
const
override
{
return
mDecoder
-
>
SupportDecoderRecycling
(
)
;
}
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
typedef
MozPromise
<
RefPtr
<
MediaDataDecoder
>
MediaResult
true
>
AllocateDecoderPromise
;
static
RefPtr
<
AllocateDecoderPromise
>
CreateDecoder
(
const
CreateDecoderParams
&
aParams
)
;
private
:
RefPtr
<
MediaDataDecoder
>
mDecoder
;
RefPtr
<
Token
>
mToken
;
}
;
}
#
endif
