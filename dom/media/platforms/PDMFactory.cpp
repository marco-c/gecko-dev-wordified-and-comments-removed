#
include
"
PDMFactory
.
h
"
#
ifdef
XP_WIN
#
include
"
WMFDecoderModule
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
endif
#
ifdef
MOZ_FFVPX
#
include
"
FFVPXRuntimeLinker
.
h
"
#
endif
#
ifdef
MOZ_FFMPEG
#
include
"
FFmpegRuntimeLinker
.
h
"
#
endif
#
ifdef
MOZ_APPLEMEDIA
#
include
"
AppleDecoderModule
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
AndroidDecoderModule
.
h
"
#
endif
#
ifdef
MOZ_OMX
#
include
"
OmxDecoderModule
.
h
"
#
endif
#
include
"
GMPDecoderModule
.
h
"
#
include
"
mozilla
/
CDMProxy
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
H264Converter
.
h
"
#
include
"
AgnosticDecoderModule
.
h
"
#
include
"
EMEDecoderModule
.
h
"
#
include
"
DecoderDoctorDiagnostics
.
h
"
#
include
"
MP4Decoder
.
h
"
#
include
"
mozilla
/
dom
/
RemoteVideoDecoder
.
h
"
#
include
"
H264
.
h
"
#
include
<
functional
>
namespace
mozilla
{
extern
already_AddRefed
<
PlatformDecoderModule
>
CreateBlankDecoderModule
(
)
;
extern
already_AddRefed
<
PlatformDecoderModule
>
CreateNullDecoderModule
(
)
;
class
PDMFactoryImpl
final
{
public
:
PDMFactoryImpl
(
)
{
#
ifdef
XP_WIN
WMFDecoderModule
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_APPLEMEDIA
AppleDecoderModule
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_OMX
OmxDecoderModule
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_FFVPX
FFVPXRuntimeLinker
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_FFMPEG
FFmpegRuntimeLinker
:
:
Init
(
)
;
#
endif
}
}
;
StaticAutoPtr
<
PDMFactoryImpl
>
PDMFactory
:
:
sInstance
;
StaticMutex
PDMFactory
:
:
sMonitor
;
class
SupportChecker
{
public
:
enum
class
Reason
:
uint8_t
{
kSupported
kVideoFormatNotSupported
kAudioFormatNotSupported
kUnknown
}
;
struct
CheckResult
{
explicit
CheckResult
(
Reason
aReason
MediaResult
aResult
=
MediaResult
(
NS_OK
)
)
:
mReason
(
aReason
)
mMediaResult
(
std
:
:
move
(
aResult
)
)
{
}
CheckResult
(
const
CheckResult
&
aOther
)
=
default
;
CheckResult
(
CheckResult
&
&
aOther
)
=
default
;
CheckResult
&
operator
=
(
const
CheckResult
&
aOther
)
=
default
;
CheckResult
&
operator
=
(
CheckResult
&
&
aOther
)
=
default
;
Reason
mReason
;
MediaResult
mMediaResult
;
}
;
template
<
class
Func
>
void
AddToCheckList
(
Func
&
&
aChecker
)
{
mCheckerList
.
AppendElement
(
mozilla
:
:
Forward
<
Func
>
(
aChecker
)
)
;
}
void
AddMediaFormatChecker
(
const
TrackInfo
&
aTrackConfig
)
{
if
(
aTrackConfig
.
IsVideo
(
)
)
{
auto
mimeType
=
aTrackConfig
.
GetAsVideoInfo
(
)
-
>
mMimeType
;
RefPtr
<
MediaByteBuffer
>
extraData
=
aTrackConfig
.
GetAsVideoInfo
(
)
-
>
mExtraData
;
AddToCheckList
(
[
mimeType
extraData
]
(
)
{
if
(
MP4Decoder
:
:
IsH264
(
mimeType
)
)
{
SPSData
spsdata
;
if
(
H264
:
:
DecodeSPSFromExtraData
(
extraData
spsdata
)
&
&
(
spsdata
.
profile_idc
=
=
244
|
|
spsdata
.
chroma_format_idc
=
=
PDMFactory
:
:
kYUV444
)
)
{
return
CheckResult
(
SupportChecker
:
:
Reason
:
:
kVideoFormatNotSupported
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
Decoder
may
not
have
the
capability
"
"
to
handle
the
requested
video
format
"
"
with
YUV444
chroma
subsampling
.
"
)
)
)
;
}
}
return
CheckResult
(
SupportChecker
:
:
Reason
:
:
kSupported
)
;
}
)
;
}
}
SupportChecker
:
:
CheckResult
Check
(
)
{
for
(
auto
&
checker
:
mCheckerList
)
{
auto
result
=
checker
(
)
;
if
(
result
.
mReason
!
=
SupportChecker
:
:
Reason
:
:
kSupported
)
{
return
result
;
}
}
return
CheckResult
(
SupportChecker
:
:
Reason
:
:
kSupported
)
;
}
void
Clear
(
)
{
mCheckerList
.
Clear
(
)
;
}
private
:
nsTArray
<
std
:
:
function
<
CheckResult
(
)
>
>
mCheckerList
;
}
;
PDMFactory
:
:
PDMFactory
(
)
{
EnsureInit
(
)
;
CreatePDMs
(
)
;
CreateNullPDM
(
)
;
}
PDMFactory
:
:
~
PDMFactory
(
)
{
}
void
PDMFactory
:
:
EnsureInit
(
)
const
{
{
StaticMutexAutoLock
mon
(
sMonitor
)
;
if
(
sInstance
)
{
return
;
}
if
(
NS_IsMainThread
(
)
)
{
sInstance
=
new
PDMFactoryImpl
(
)
;
ClearOnShutdown
(
&
sInstance
)
;
return
;
}
}
nsCOMPtr
<
nsIEventTarget
>
mainTarget
=
GetMainThreadEventTarget
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
PDMFactory
:
:
EnsureInit
"
[
]
(
)
{
StaticMutexAutoLock
mon
(
sMonitor
)
;
if
(
!
sInstance
)
{
sInstance
=
new
PDMFactoryImpl
(
)
;
ClearOnShutdown
(
&
sInstance
)
;
}
}
)
;
SyncRunnable
:
:
DispatchToThread
(
mainTarget
runnable
)
;
}
already_AddRefed
<
MediaDataDecoder
>
PDMFactory
:
:
CreateDecoder
(
const
CreateDecoderParams
&
aParams
)
{
if
(
aParams
.
mUseNullDecoder
.
mUse
)
{
MOZ_ASSERT
(
mNullPDM
)
;
return
CreateDecoderWithPDM
(
mNullPDM
aParams
)
;
}
const
TrackInfo
&
config
=
aParams
.
mConfig
;
bool
isEncrypted
=
mEMEPDM
&
&
config
.
mCrypto
.
mValid
;
if
(
isEncrypted
)
{
return
CreateDecoderWithPDM
(
mEMEPDM
aParams
)
;
}
DecoderDoctorDiagnostics
*
diagnostics
=
aParams
.
mDiagnostics
;
if
(
diagnostics
)
{
if
(
mWMFFailedToLoad
)
{
diagnostics
-
>
SetWMFFailedToLoad
(
)
;
}
if
(
mFFmpegFailedToLoad
)
{
diagnostics
-
>
SetFFmpegFailedToLoad
(
)
;
}
if
(
mGMPPDMFailedToStartup
)
{
diagnostics
-
>
SetGMPPDMFailedToStartup
(
)
;
}
}
for
(
auto
&
current
:
mCurrentPDMs
)
{
if
(
!
current
-
>
Supports
(
config
diagnostics
)
)
{
continue
;
}
RefPtr
<
MediaDataDecoder
>
m
=
CreateDecoderWithPDM
(
current
aParams
)
;
if
(
m
)
{
return
m
.
forget
(
)
;
}
}
NS_WARNING
(
"
Unable
to
create
a
decoder
no
platform
found
.
"
)
;
return
nullptr
;
}
already_AddRefed
<
MediaDataDecoder
>
PDMFactory
:
:
CreateDecoderWithPDM
(
PlatformDecoderModule
*
aPDM
const
CreateDecoderParams
&
aParams
)
{
MOZ_ASSERT
(
aPDM
)
;
RefPtr
<
MediaDataDecoder
>
m
;
MediaResult
*
result
=
aParams
.
mError
;
SupportChecker
supportChecker
;
const
TrackInfo
&
config
=
aParams
.
mConfig
;
supportChecker
.
AddMediaFormatChecker
(
config
)
;
auto
checkResult
=
supportChecker
.
Check
(
)
;
if
(
checkResult
.
mReason
!
=
SupportChecker
:
:
Reason
:
:
kSupported
)
{
DecoderDoctorDiagnostics
*
diagnostics
=
aParams
.
mDiagnostics
;
if
(
checkResult
.
mReason
=
=
SupportChecker
:
:
Reason
:
:
kVideoFormatNotSupported
)
{
if
(
diagnostics
)
{
diagnostics
-
>
SetVideoNotSupported
(
)
;
}
if
(
result
)
{
*
result
=
checkResult
.
mMediaResult
;
}
}
else
if
(
checkResult
.
mReason
=
=
SupportChecker
:
:
Reason
:
:
kAudioFormatNotSupported
)
{
if
(
diagnostics
)
{
diagnostics
-
>
SetAudioNotSupported
(
)
;
}
if
(
result
)
{
*
result
=
checkResult
.
mMediaResult
;
}
}
return
nullptr
;
}
if
(
config
.
IsAudio
(
)
)
{
m
=
aPDM
-
>
CreateAudioDecoder
(
aParams
)
;
return
m
.
forget
(
)
;
}
if
(
!
config
.
IsVideo
(
)
)
{
*
result
=
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
Decoder
configuration
error
expected
audio
or
video
.
"
)
)
;
return
nullptr
;
}
if
(
MP4Decoder
:
:
IsH264
(
config
.
mMimeType
)
&
&
!
aParams
.
mUseNullDecoder
.
mUse
)
{
RefPtr
<
H264Converter
>
h
=
new
H264Converter
(
aPDM
aParams
)
;
const
MediaResult
result
=
h
-
>
GetLastError
(
)
;
if
(
NS_SUCCEEDED
(
result
)
|
|
result
=
=
NS_ERROR_NOT_INITIALIZED
)
{
m
=
h
.
forget
(
)
;
}
else
if
(
aParams
.
mError
)
{
*
aParams
.
mError
=
result
;
}
}
else
{
m
=
aPDM
-
>
CreateVideoDecoder
(
aParams
)
;
}
return
m
.
forget
(
)
;
}
bool
PDMFactory
:
:
SupportsMimeType
(
const
nsACString
&
aMimeType
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
UniquePtr
<
TrackInfo
>
trackInfo
=
CreateTrackInfoWithMIMEType
(
aMimeType
)
;
if
(
!
trackInfo
)
{
return
false
;
}
return
Supports
(
*
trackInfo
aDiagnostics
)
;
}
bool
PDMFactory
:
:
Supports
(
const
TrackInfo
&
aTrackInfo
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
if
(
mEMEPDM
)
{
return
mEMEPDM
-
>
Supports
(
aTrackInfo
aDiagnostics
)
;
}
RefPtr
<
PlatformDecoderModule
>
current
=
GetDecoder
(
aTrackInfo
aDiagnostics
)
;
return
!
!
current
;
}
void
PDMFactory
:
:
CreatePDMs
(
)
{
RefPtr
<
PlatformDecoderModule
>
m
;
if
(
StaticPrefs
:
:
MediaUseBlankDecoder
(
)
)
{
m
=
CreateBlankDecoderModule
(
)
;
StartupPDM
(
m
)
;
return
;
}
#
ifdef
XP_WIN
if
(
StaticPrefs
:
:
MediaWmfEnabled
(
)
&
&
!
IsWin7AndPre2000Compatible
(
)
)
{
m
=
new
WMFDecoderModule
(
)
;
RefPtr
<
PlatformDecoderModule
>
remote
=
new
dom
:
:
RemoteDecoderModule
(
m
)
;
StartupPDM
(
remote
)
;
mWMFFailedToLoad
=
!
StartupPDM
(
m
)
;
}
else
{
mWMFFailedToLoad
=
StaticPrefs
:
:
MediaDecoderDoctorWmfDisabledIsFailure
(
)
;
}
#
endif
#
ifdef
MOZ_OMX
if
(
StaticPrefs
:
:
MediaOmxEnabled
(
)
)
{
m
=
OmxDecoderModule
:
:
Create
(
)
;
StartupPDM
(
m
)
;
}
#
endif
#
ifdef
MOZ_FFVPX
if
(
StaticPrefs
:
:
MediaFfvpxEnabled
(
)
)
{
m
=
FFVPXRuntimeLinker
:
:
CreateDecoderModule
(
)
;
StartupPDM
(
m
)
;
}
#
endif
#
ifdef
MOZ_FFMPEG
if
(
StaticPrefs
:
:
MediaFfmpegEnabled
(
)
)
{
m
=
FFmpegRuntimeLinker
:
:
CreateDecoderModule
(
)
;
mFFmpegFailedToLoad
=
!
StartupPDM
(
m
)
;
}
else
{
mFFmpegFailedToLoad
=
false
;
}
#
endif
#
ifdef
MOZ_APPLEMEDIA
m
=
new
AppleDecoderModule
(
)
;
StartupPDM
(
m
)
;
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
if
(
StaticPrefs
:
:
MediaAndroidMediaCodecEnabled
(
)
)
{
m
=
new
AndroidDecoderModule
(
)
;
StartupPDM
(
m
StaticPrefs
:
:
MediaAndroidMediaCodecPreferred
(
)
)
;
}
#
endif
m
=
new
AgnosticDecoderModule
(
)
;
StartupPDM
(
m
)
;
if
(
StaticPrefs
:
:
MediaGmpDecoderEnabled
(
)
)
{
m
=
new
GMPDecoderModule
(
)
;
mGMPPDMFailedToStartup
=
!
StartupPDM
(
m
)
;
}
else
{
mGMPPDMFailedToStartup
=
false
;
}
}
void
PDMFactory
:
:
CreateNullPDM
(
)
{
mNullPDM
=
CreateNullDecoderModule
(
)
;
MOZ_ASSERT
(
mNullPDM
&
&
NS_SUCCEEDED
(
mNullPDM
-
>
Startup
(
)
)
)
;
}
bool
PDMFactory
:
:
StartupPDM
(
PlatformDecoderModule
*
aPDM
bool
aInsertAtBeginning
)
{
if
(
aPDM
&
&
NS_SUCCEEDED
(
aPDM
-
>
Startup
(
)
)
)
{
if
(
aInsertAtBeginning
)
{
mCurrentPDMs
.
InsertElementAt
(
0
aPDM
)
;
}
else
{
mCurrentPDMs
.
AppendElement
(
aPDM
)
;
}
return
true
;
}
return
false
;
}
already_AddRefed
<
PlatformDecoderModule
>
PDMFactory
:
:
GetDecoder
(
const
TrackInfo
&
aTrackInfo
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
if
(
aDiagnostics
)
{
if
(
mWMFFailedToLoad
)
{
aDiagnostics
-
>
SetWMFFailedToLoad
(
)
;
}
if
(
mFFmpegFailedToLoad
)
{
aDiagnostics
-
>
SetFFmpegFailedToLoad
(
)
;
}
if
(
mGMPPDMFailedToStartup
)
{
aDiagnostics
-
>
SetGMPPDMFailedToStartup
(
)
;
}
}
RefPtr
<
PlatformDecoderModule
>
pdm
;
for
(
auto
&
current
:
mCurrentPDMs
)
{
if
(
current
-
>
Supports
(
aTrackInfo
aDiagnostics
)
)
{
pdm
=
current
;
break
;
}
}
return
pdm
.
forget
(
)
;
}
void
PDMFactory
:
:
SetCDMProxy
(
CDMProxy
*
aProxy
)
{
MOZ_ASSERT
(
aProxy
)
;
#
ifdef
MOZ_WIDGET_ANDROID
if
(
IsWidevineKeySystem
(
aProxy
-
>
KeySystem
(
)
)
)
{
mEMEPDM
=
new
AndroidDecoderModule
(
aProxy
)
;
return
;
}
#
endif
RefPtr
<
PDMFactory
>
m
=
new
PDMFactory
(
)
;
mEMEPDM
=
new
EMEDecoderModule
(
aProxy
m
)
;
}
}
