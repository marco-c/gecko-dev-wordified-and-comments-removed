#
include
"
PDMFactory
.
h
"
#
ifdef
XP_WIN
#
include
"
WMFDecoderModule
.
h
"
#
endif
#
ifdef
MOZ_FFVPX
#
include
"
FFVPXRuntimeLinker
.
h
"
#
endif
#
ifdef
MOZ_FFMPEG
#
include
"
FFmpegRuntimeLinker
.
h
"
#
endif
#
ifdef
MOZ_APPLEMEDIA
#
include
"
AppleDecoderModule
.
h
"
#
endif
#
ifdef
MOZ_GONK_MEDIACODEC
#
include
"
GonkDecoderModule
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
AndroidDecoderModule
.
h
"
#
endif
#
include
"
GMPDecoderModule
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
MediaPrefs
.
h
"
#
include
"
FuzzingWrapper
.
h
"
#
include
"
H264Converter
.
h
"
#
include
"
AgnosticDecoderModule
.
h
"
#
ifdef
MOZ_EME
#
include
"
EMEDecoderModule
.
h
"
#
include
"
mozilla
/
CDMProxy
.
h
"
#
endif
#
include
"
DecoderDoctorDiagnostics
.
h
"
namespace
mozilla
{
extern
already_AddRefed
<
PlatformDecoderModule
>
CreateAgnosticDecoderModule
(
)
;
extern
already_AddRefed
<
PlatformDecoderModule
>
CreateBlankDecoderModule
(
)
;
class
PDMFactoryImpl
final
{
public
:
PDMFactoryImpl
(
)
{
#
ifdef
XP_WIN
WMFDecoderModule
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_APPLEMEDIA
AppleDecoderModule
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_FFVPX
FFVPXRuntimeLinker
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_FFMPEG
FFmpegRuntimeLinker
:
:
Init
(
)
;
#
endif
GMPDecoderModule
:
:
Init
(
)
;
}
}
;
StaticAutoPtr
<
PDMFactoryImpl
>
PDMFactory
:
:
sInstance
;
StaticMutex
PDMFactory
:
:
sMonitor
;
PDMFactory
:
:
PDMFactory
(
)
{
EnsureInit
(
)
;
CreatePDMs
(
)
;
}
PDMFactory
:
:
~
PDMFactory
(
)
{
}
void
PDMFactory
:
:
EnsureInit
(
)
const
{
StaticMutexAutoLock
mon
(
sMonitor
)
;
if
(
!
sInstance
)
{
sInstance
=
new
PDMFactoryImpl
(
)
;
if
(
NS_IsMainThread
(
)
)
{
ClearOnShutdown
(
&
sInstance
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
[
]
(
)
{
ClearOnShutdown
(
&
sInstance
)
;
}
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
}
}
already_AddRefed
<
MediaDataDecoder
>
PDMFactory
:
:
CreateDecoder
(
const
TrackInfo
&
aConfig
TaskQueue
*
aTaskQueue
MediaDataDecoderCallback
*
aCallback
DecoderDoctorDiagnostics
*
aDiagnostics
layers
:
:
LayersBackend
aLayersBackend
layers
:
:
ImageContainer
*
aImageContainer
)
const
{
bool
isEncrypted
=
mEMEPDM
&
&
aConfig
.
mCrypto
.
mValid
;
if
(
isEncrypted
)
{
return
CreateDecoderWithPDM
(
mEMEPDM
aConfig
aTaskQueue
aCallback
aDiagnostics
aLayersBackend
aImageContainer
)
;
}
if
(
aDiagnostics
)
{
if
(
mWMFFailedToLoad
)
{
aDiagnostics
-
>
SetWMFFailedToLoad
(
)
;
}
if
(
mFFmpegFailedToLoad
)
{
aDiagnostics
-
>
SetFFmpegFailedToLoad
(
)
;
}
if
(
mGMPPDMFailedToStartup
)
{
aDiagnostics
-
>
SetGMPPDMFailedToStartup
(
)
;
}
}
for
(
auto
&
current
:
mCurrentPDMs
)
{
if
(
!
current
-
>
SupportsMimeType
(
aConfig
.
mMimeType
aDiagnostics
)
)
{
continue
;
}
RefPtr
<
MediaDataDecoder
>
m
=
CreateDecoderWithPDM
(
current
aConfig
aTaskQueue
aCallback
aDiagnostics
aLayersBackend
aImageContainer
)
;
if
(
m
)
{
return
m
.
forget
(
)
;
}
}
NS_WARNING
(
"
Unable
to
create
a
decoder
no
platform
found
.
"
)
;
return
nullptr
;
}
already_AddRefed
<
MediaDataDecoder
>
PDMFactory
:
:
CreateDecoderWithPDM
(
PlatformDecoderModule
*
aPDM
const
TrackInfo
&
aConfig
TaskQueue
*
aTaskQueue
MediaDataDecoderCallback
*
aCallback
DecoderDoctorDiagnostics
*
aDiagnostics
layers
:
:
LayersBackend
aLayersBackend
layers
:
:
ImageContainer
*
aImageContainer
)
const
{
MOZ_ASSERT
(
aPDM
)
;
RefPtr
<
MediaDataDecoder
>
m
;
if
(
aConfig
.
GetAsAudioInfo
(
)
)
{
m
=
aPDM
-
>
CreateAudioDecoder
(
*
aConfig
.
GetAsAudioInfo
(
)
aTaskQueue
aCallback
aDiagnostics
)
;
return
m
.
forget
(
)
;
}
if
(
!
aConfig
.
GetAsVideoInfo
(
)
)
{
return
nullptr
;
}
MediaDataDecoderCallback
*
callback
=
aCallback
;
RefPtr
<
DecoderCallbackFuzzingWrapper
>
callbackWrapper
;
if
(
MediaPrefs
:
:
PDMFuzzingEnabled
(
)
)
{
callbackWrapper
=
new
DecoderCallbackFuzzingWrapper
(
aCallback
)
;
callbackWrapper
-
>
SetVideoOutputMinimumInterval
(
TimeDuration
:
:
FromMilliseconds
(
MediaPrefs
:
:
PDMFuzzingInterval
(
)
)
)
;
callbackWrapper
-
>
SetDontDelayInputExhausted
(
!
MediaPrefs
:
:
PDMFuzzingDelayInputExhausted
(
)
)
;
callback
=
callbackWrapper
.
get
(
)
;
}
if
(
H264Converter
:
:
IsH264
(
aConfig
)
)
{
RefPtr
<
H264Converter
>
h
=
new
H264Converter
(
aPDM
*
aConfig
.
GetAsVideoInfo
(
)
aLayersBackend
aImageContainer
aTaskQueue
callback
aDiagnostics
)
;
const
nsresult
rv
=
h
-
>
GetLastError
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
|
|
rv
=
=
NS_ERROR_NOT_INITIALIZED
)
{
m
=
h
.
forget
(
)
;
}
}
else
{
m
=
aPDM
-
>
CreateVideoDecoder
(
*
aConfig
.
GetAsVideoInfo
(
)
aLayersBackend
aImageContainer
aTaskQueue
callback
aDiagnostics
)
;
}
if
(
callbackWrapper
&
&
m
)
{
m
=
new
DecoderFuzzingWrapper
(
m
.
forget
(
)
callbackWrapper
.
forget
(
)
)
;
}
return
m
.
forget
(
)
;
}
bool
PDMFactory
:
:
SupportsMimeType
(
const
nsACString
&
aMimeType
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
if
(
mEMEPDM
)
{
return
mEMEPDM
-
>
SupportsMimeType
(
aMimeType
aDiagnostics
)
;
}
RefPtr
<
PlatformDecoderModule
>
current
=
GetDecoder
(
aMimeType
aDiagnostics
)
;
return
!
!
current
;
}
void
PDMFactory
:
:
CreatePDMs
(
)
{
RefPtr
<
PlatformDecoderModule
>
m
;
if
(
MediaPrefs
:
:
PDMUseBlankDecoder
(
)
)
{
m
=
CreateBlankDecoderModule
(
)
;
StartupPDM
(
m
)
;
return
;
}
#
ifdef
MOZ_WIDGET_ANDROID
if
(
MediaPrefs
:
:
PDMAndroidMediaCodecPreferred
(
)
&
&
MediaPrefs
:
:
PDMAndroidMediaCodecEnabled
(
)
)
{
m
=
new
AndroidDecoderModule
(
)
;
StartupPDM
(
m
)
;
}
#
endif
#
ifdef
XP_WIN
if
(
MediaPrefs
:
:
PDMWMFEnabled
(
)
)
{
m
=
new
WMFDecoderModule
(
)
;
mWMFFailedToLoad
=
!
StartupPDM
(
m
)
;
}
else
{
mWMFFailedToLoad
=
MediaPrefs
:
:
DecoderDoctorWMFDisabledIsFailure
(
)
;
}
#
endif
#
ifdef
MOZ_FFVPX
if
(
MediaPrefs
:
:
PDMFFVPXEnabled
(
)
)
{
m
=
FFVPXRuntimeLinker
:
:
CreateDecoderModule
(
)
;
StartupPDM
(
m
)
;
}
#
endif
#
ifdef
MOZ_FFMPEG
if
(
MediaPrefs
:
:
PDMFFmpegEnabled
(
)
)
{
m
=
FFmpegRuntimeLinker
:
:
CreateDecoderModule
(
)
;
mFFmpegFailedToLoad
=
!
StartupPDM
(
m
)
;
}
else
{
mFFmpegFailedToLoad
=
false
;
}
#
endif
#
ifdef
MOZ_APPLEMEDIA
m
=
new
AppleDecoderModule
(
)
;
StartupPDM
(
m
)
;
#
endif
#
ifdef
MOZ_GONK_MEDIACODEC
if
(
MediaPrefs
:
:
PDMGonkDecoderEnabled
(
)
)
{
m
=
new
GonkDecoderModule
(
)
;
StartupPDM
(
m
)
;
}
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
if
(
MediaPrefs
:
:
PDMAndroidMediaCodecEnabled
(
)
)
{
m
=
new
AndroidDecoderModule
(
)
;
StartupPDM
(
m
)
;
}
#
endif
m
=
new
AgnosticDecoderModule
(
)
;
StartupPDM
(
m
)
;
if
(
MediaPrefs
:
:
PDMGMPEnabled
(
)
)
{
m
=
new
GMPDecoderModule
(
)
;
mGMPPDMFailedToStartup
=
!
StartupPDM
(
m
)
;
}
else
{
mGMPPDMFailedToStartup
=
false
;
}
}
bool
PDMFactory
:
:
StartupPDM
(
PlatformDecoderModule
*
aPDM
)
{
if
(
aPDM
&
&
NS_SUCCEEDED
(
aPDM
-
>
Startup
(
)
)
)
{
mCurrentPDMs
.
AppendElement
(
aPDM
)
;
return
true
;
}
return
false
;
}
already_AddRefed
<
PlatformDecoderModule
>
PDMFactory
:
:
GetDecoder
(
const
nsACString
&
aMimeType
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
if
(
aDiagnostics
)
{
if
(
mWMFFailedToLoad
)
{
aDiagnostics
-
>
SetWMFFailedToLoad
(
)
;
}
if
(
mFFmpegFailedToLoad
)
{
aDiagnostics
-
>
SetFFmpegFailedToLoad
(
)
;
}
if
(
mGMPPDMFailedToStartup
)
{
aDiagnostics
-
>
SetGMPPDMFailedToStartup
(
)
;
}
}
RefPtr
<
PlatformDecoderModule
>
pdm
;
for
(
auto
&
current
:
mCurrentPDMs
)
{
if
(
current
-
>
SupportsMimeType
(
aMimeType
aDiagnostics
)
)
{
pdm
=
current
;
break
;
}
}
return
pdm
.
forget
(
)
;
}
#
ifdef
MOZ_EME
void
PDMFactory
:
:
SetCDMProxy
(
CDMProxy
*
aProxy
)
{
RefPtr
<
PDMFactory
>
m
=
new
PDMFactory
(
)
;
mEMEPDM
=
new
EMEDecoderModule
(
aProxy
m
)
;
}
#
endif
}
