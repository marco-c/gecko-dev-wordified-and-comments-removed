#
include
"
PDMFactory
.
h
"
#
include
"
AgnosticDecoderModule
.
h
"
#
include
"
AudioTrimmer
.
h
"
#
include
"
BlankDecoderModule
.
h
"
#
include
"
DecoderDoctorDiagnostics
.
h
"
#
include
"
EMEDecoderModule
.
h
"
#
include
"
GMPDecoderModule
.
h
"
#
include
"
H264
.
h
"
#
include
"
MP4Decoder
.
h
"
#
include
"
MediaChangeMonitor
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
VPXDecoder
.
h
"
#
include
"
mozilla
/
CDMProxy
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
RemoteDecoderManagerChild
.
h
"
#
include
"
mozilla
/
RemoteDecoderModule
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
ifdef
XP_WIN
#
include
"
WMFDecoderModule
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
endif
#
ifdef
MOZ_FFVPX
#
include
"
FFVPXRuntimeLinker
.
h
"
#
endif
#
ifdef
MOZ_FFMPEG
#
include
"
FFmpegRuntimeLinker
.
h
"
#
endif
#
ifdef
MOZ_APPLEMEDIA
#
include
"
AppleDecoderModule
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
AndroidDecoderModule
.
h
"
#
endif
#
ifdef
MOZ_OMX
#
include
"
OmxDecoderModule
.
h
"
#
endif
#
include
<
functional
>
namespace
mozilla
{
static
Maybe
<
PDMFactory
:
:
MediaCodecsSupported
>
sSupported
;
extern
already_AddRefed
<
PlatformDecoderModule
>
CreateNullDecoderModule
(
)
;
class
PDMFactoryImpl
final
{
public
:
PDMFactoryImpl
(
)
{
if
(
XRE_IsGPUProcess
(
)
)
{
InitGpuPDMs
(
)
;
}
else
if
(
XRE_IsRDDProcess
(
)
)
{
InitRddPDMs
(
)
;
}
else
if
(
XRE_IsContentProcess
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sSupported
.
isSome
(
)
"
PDMFactory
accessed
while
not
initialized
"
)
;
InitContentPDMs
(
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
"
PDMFactory
is
only
usable
in
the
Parent
/
GPU
/
RDD
/
Content
process
"
)
;
InitDefaultPDMs
(
)
;
}
}
private
:
void
InitGpuPDMs
(
)
{
#
ifdef
XP_WIN
if
(
!
IsWin7AndPre2000Compatible
(
)
)
{
WMFDecoderModule
:
:
Init
(
)
;
}
#
endif
}
void
InitRddPDMs
(
)
{
#
ifdef
XP_WIN
if
(
!
IsWin7AndPre2000Compatible
(
)
)
{
WMFDecoderModule
:
:
Init
(
)
;
}
#
endif
#
ifdef
MOZ_APPLEMEDIA
AppleDecoderModule
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_FFVPX
FFVPXRuntimeLinker
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_FFMPEG
if
(
StaticPrefs
:
:
media_rdd_ffmpeg_enabled
(
)
)
{
FFmpegRuntimeLinker
:
:
Init
(
)
;
}
#
endif
}
void
InitContentPDMs
(
)
{
#
ifdef
XP_WIN
if
(
!
IsWin7AndPre2000Compatible
(
)
)
{
WMFDecoderModule
:
:
Init
(
)
;
}
#
endif
#
ifdef
MOZ_APPLEMEDIA
AppleDecoderModule
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_OMX
OmxDecoderModule
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_FFVPX
FFVPXRuntimeLinker
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_FFMPEG
FFmpegRuntimeLinker
:
:
Init
(
)
;
#
endif
RemoteDecoderManagerChild
:
:
Init
(
)
;
}
void
InitDefaultPDMs
(
)
{
#
ifdef
XP_WIN
if
(
!
IsWin7AndPre2000Compatible
(
)
)
{
WMFDecoderModule
:
:
Init
(
)
;
}
#
endif
#
ifdef
MOZ_APPLEMEDIA
AppleDecoderModule
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_OMX
OmxDecoderModule
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_FFVPX
FFVPXRuntimeLinker
:
:
Init
(
)
;
#
endif
#
ifdef
MOZ_FFMPEG
FFmpegRuntimeLinker
:
:
Init
(
)
;
#
endif
}
}
;
StaticAutoPtr
<
PDMFactoryImpl
>
PDMFactory
:
:
sInstance
;
StaticMutex
PDMFactory
:
:
sMonitor
;
class
SupportChecker
{
public
:
enum
class
Reason
:
uint8_t
{
kSupported
kVideoFormatNotSupported
kAudioFormatNotSupported
kUnknown
}
;
struct
CheckResult
{
explicit
CheckResult
(
Reason
aReason
MediaResult
aResult
=
MediaResult
(
NS_OK
)
)
:
mReason
(
aReason
)
mMediaResult
(
std
:
:
move
(
aResult
)
)
{
}
CheckResult
(
const
CheckResult
&
aOther
)
=
default
;
CheckResult
(
CheckResult
&
&
aOther
)
=
default
;
CheckResult
&
operator
=
(
const
CheckResult
&
aOther
)
=
default
;
CheckResult
&
operator
=
(
CheckResult
&
&
aOther
)
=
default
;
Reason
mReason
;
MediaResult
mMediaResult
;
}
;
template
<
class
Func
>
void
AddToCheckList
(
Func
&
&
aChecker
)
{
mCheckerList
.
AppendElement
(
std
:
:
forward
<
Func
>
(
aChecker
)
)
;
}
void
AddMediaFormatChecker
(
const
TrackInfo
&
aTrackConfig
)
{
if
(
aTrackConfig
.
IsVideo
(
)
)
{
auto
mimeType
=
aTrackConfig
.
GetAsVideoInfo
(
)
-
>
mMimeType
;
RefPtr
<
MediaByteBuffer
>
extraData
=
aTrackConfig
.
GetAsVideoInfo
(
)
-
>
mExtraData
;
AddToCheckList
(
[
mimeType
extraData
]
(
)
{
if
(
MP4Decoder
:
:
IsH264
(
mimeType
)
)
{
SPSData
spsdata
;
if
(
H264
:
:
DecodeSPSFromExtraData
(
extraData
spsdata
)
&
&
(
spsdata
.
profile_idc
=
=
244
|
|
spsdata
.
chroma_format_idc
=
=
PDMFactory
:
:
kYUV444
)
)
{
return
CheckResult
(
SupportChecker
:
:
Reason
:
:
kVideoFormatNotSupported
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
Decoder
may
not
have
the
capability
"
"
to
handle
the
requested
video
format
"
"
with
YUV444
chroma
subsampling
.
"
)
)
)
;
}
}
return
CheckResult
(
SupportChecker
:
:
Reason
:
:
kSupported
)
;
}
)
;
}
}
SupportChecker
:
:
CheckResult
Check
(
)
{
for
(
auto
&
checker
:
mCheckerList
)
{
auto
result
=
checker
(
)
;
if
(
result
.
mReason
!
=
SupportChecker
:
:
Reason
:
:
kSupported
)
{
return
result
;
}
}
return
CheckResult
(
SupportChecker
:
:
Reason
:
:
kSupported
)
;
}
void
Clear
(
)
{
mCheckerList
.
Clear
(
)
;
}
private
:
nsTArray
<
std
:
:
function
<
CheckResult
(
)
>
>
mCheckerList
;
}
;
PDMFactory
:
:
PDMFactory
(
)
{
EnsureInit
(
)
;
CreatePDMs
(
)
;
CreateNullPDM
(
)
;
}
PDMFactory
:
:
PDMFactory
(
const
RemoteDecodeIn
&
aProcess
)
{
switch
(
aProcess
)
{
case
RemoteDecodeIn
:
:
RddProcess
:
CreateRddPDMs
(
)
;
break
;
case
RemoteDecodeIn
:
:
GpuProcess
:
CreateGpuPDMs
(
)
;
break
;
default
:
MOZ_CRASH
(
"
Not
to
be
used
for
any
other
process
"
)
;
}
}
already_AddRefed
<
PDMFactory
>
PDMFactory
:
:
PDMFactoryForRdd
(
)
{
RefPtr
<
PDMFactory
>
pdm
=
new
PDMFactory
(
RemoteDecodeIn
:
:
RddProcess
)
;
return
pdm
.
forget
(
)
;
}
already_AddRefed
<
PDMFactory
>
PDMFactory
:
:
PDMFactoryForGpu
(
)
{
RefPtr
<
PDMFactory
>
pdm
=
new
PDMFactory
(
RemoteDecodeIn
:
:
GpuProcess
)
;
return
pdm
.
forget
(
)
;
}
void
PDMFactory
:
:
EnsureInit
(
)
{
{
StaticMutexAutoLock
mon
(
sMonitor
)
;
if
(
sInstance
)
{
return
;
}
}
auto
initalization
=
[
]
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
StaticMutexAutoLock
mon
(
sMonitor
)
;
if
(
!
sInstance
)
{
gfx
:
:
gfxVars
:
:
Initialize
(
)
;
Unused
<
<
BrowserTabsRemoteAutostart
(
)
;
sInstance
=
new
PDMFactoryImpl
(
)
;
ClearOnShutdown
(
&
sInstance
)
;
}
}
;
if
(
NS_IsMainThread
(
)
)
{
initalization
(
)
;
return
;
}
nsCOMPtr
<
nsIEventTarget
>
mainTarget
=
GetMainThreadEventTarget
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
PDMFactory
:
:
EnsureInit
"
std
:
:
move
(
initalization
)
)
;
SyncRunnable
:
:
DispatchToThread
(
mainTarget
runnable
)
;
}
RefPtr
<
PlatformDecoderModule
:
:
CreateDecoderPromise
>
PDMFactory
:
:
CreateDecoder
(
const
CreateDecoderParams
&
aParams
)
{
if
(
aParams
.
mUseNullDecoder
.
mUse
)
{
MOZ_ASSERT
(
mNullPDM
)
;
return
CreateDecoderWithPDM
(
mNullPDM
aParams
)
;
}
bool
isEncrypted
=
mEMEPDM
&
&
aParams
.
mConfig
.
mCrypto
.
IsEncrypted
(
)
;
if
(
isEncrypted
)
{
return
CreateDecoderWithPDM
(
mEMEPDM
aParams
)
;
}
return
CheckAndMaybeCreateDecoder
(
CreateDecoderParamsForAsync
(
aParams
)
0
)
;
}
RefPtr
<
PlatformDecoderModule
:
:
CreateDecoderPromise
>
PDMFactory
:
:
CheckAndMaybeCreateDecoder
(
CreateDecoderParamsForAsync
&
&
aParams
uint32_t
aIndex
)
{
uint32_t
i
=
aIndex
;
auto
params
=
SupportDecoderParams
(
aParams
)
;
for
(
;
i
<
mCurrentPDMs
.
Length
(
)
;
i
+
+
)
{
if
(
!
mCurrentPDMs
[
i
]
-
>
Supports
(
params
nullptr
)
)
{
continue
;
}
RefPtr
<
PlatformDecoderModule
:
:
CreateDecoderPromise
>
p
=
CreateDecoderWithPDM
(
mCurrentPDMs
[
i
]
aParams
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
]
(
RefPtr
<
MediaDataDecoder
>
&
&
aDecoder
)
{
return
PlatformDecoderModule
:
:
CreateDecoderPromise
:
:
CreateAndResolve
(
std
:
:
move
(
aDecoder
)
__func__
)
;
}
[
self
=
RefPtr
{
this
}
i
params
=
std
:
:
move
(
aParams
)
]
(
const
MediaResult
&
aError
)
mutable
{
return
self
-
>
CheckAndMaybeCreateDecoder
(
std
:
:
move
(
params
)
i
+
1
)
;
}
)
;
return
p
;
}
return
PlatformDecoderModule
:
:
CreateDecoderPromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
nsPrintfCString
(
"
Error
no
decoder
found
for
%
s
"
aParams
.
mConfig
-
>
mMimeType
.
get
(
)
)
.
get
(
)
)
__func__
)
;
}
RefPtr
<
PlatformDecoderModule
:
:
CreateDecoderPromise
>
PDMFactory
:
:
CreateDecoderWithPDM
(
PlatformDecoderModule
*
aPDM
const
CreateDecoderParams
&
aParams
)
{
MOZ_ASSERT
(
aPDM
)
;
MediaResult
result
=
NS_OK
;
SupportChecker
supportChecker
;
const
TrackInfo
&
config
=
aParams
.
mConfig
;
supportChecker
.
AddMediaFormatChecker
(
config
)
;
auto
checkResult
=
supportChecker
.
Check
(
)
;
if
(
checkResult
.
mReason
!
=
SupportChecker
:
:
Reason
:
:
kSupported
)
{
if
(
checkResult
.
mReason
=
=
SupportChecker
:
:
Reason
:
:
kVideoFormatNotSupported
)
{
result
=
checkResult
.
mMediaResult
;
}
else
if
(
checkResult
.
mReason
=
=
SupportChecker
:
:
Reason
:
:
kAudioFormatNotSupported
)
{
result
=
checkResult
.
mMediaResult
;
}
return
PlatformDecoderModule
:
:
CreateDecoderPromise
:
:
CreateAndReject
(
result
__func__
)
;
}
if
(
config
.
IsAudio
(
)
)
{
RefPtr
<
PlatformDecoderModule
:
:
CreateDecoderPromise
>
p
;
p
=
aPDM
-
>
AsyncCreateDecoder
(
aParams
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
params
=
CreateDecoderParamsForAsync
(
aParams
)
]
(
RefPtr
<
MediaDataDecoder
>
&
&
aDecoder
)
{
RefPtr
<
MediaDataDecoder
>
decoder
=
std
:
:
move
(
aDecoder
)
;
if
(
!
params
.
mNoWrapper
.
mDontUseWrapper
)
{
decoder
=
new
AudioTrimmer
(
decoder
.
forget
(
)
CreateDecoderParams
(
params
)
)
;
}
return
PlatformDecoderModule
:
:
CreateDecoderPromise
:
:
CreateAndResolve
(
decoder
__func__
)
;
}
[
]
(
const
MediaResult
&
aError
)
{
return
PlatformDecoderModule
:
:
CreateDecoderPromise
:
:
CreateAndReject
(
aError
__func__
)
;
}
)
;
return
p
;
}
if
(
!
config
.
IsVideo
(
)
)
{
return
PlatformDecoderModule
:
:
CreateDecoderPromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
Decoder
configuration
error
expected
audio
or
video
.
"
)
)
__func__
)
;
}
if
(
(
MP4Decoder
:
:
IsH264
(
config
.
mMimeType
)
|
|
VPXDecoder
:
:
IsVPX
(
config
.
mMimeType
)
)
&
&
!
aParams
.
mUseNullDecoder
.
mUse
&
&
!
aParams
.
mNoWrapper
.
mDontUseWrapper
)
{
return
MediaChangeMonitor
:
:
Create
(
aPDM
aParams
)
;
}
return
aPDM
-
>
AsyncCreateDecoder
(
aParams
)
;
}
bool
PDMFactory
:
:
SupportsMimeType
(
const
nsACString
&
aMimeType
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
UniquePtr
<
TrackInfo
>
trackInfo
=
CreateTrackInfoWithMIMEType
(
aMimeType
)
;
if
(
!
trackInfo
)
{
return
false
;
}
return
Supports
(
SupportDecoderParams
(
*
trackInfo
)
aDiagnostics
)
;
}
bool
PDMFactory
:
:
Supports
(
const
SupportDecoderParams
&
aParams
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
if
(
mEMEPDM
)
{
return
mEMEPDM
-
>
Supports
(
aParams
aDiagnostics
)
;
}
if
(
VPXDecoder
:
:
IsVPX
(
aParams
.
MimeType
(
)
VPXDecoder
:
:
VP8
|
VPXDecoder
:
:
VP9
)
&
&
!
aParams
.
mConfig
.
GetAsVideoInfo
(
)
-
>
HasAlpha
(
)
)
{
return
true
;
}
RefPtr
<
PlatformDecoderModule
>
current
=
GetDecoderModule
(
aParams
aDiagnostics
)
;
return
!
!
current
;
}
void
PDMFactory
:
:
CreatePDMs
(
)
{
if
(
StaticPrefs
:
:
media_use_blank_decoder
(
)
)
{
CreateAndStartupPDM
<
BlankDecoderModule
>
(
)
;
return
;
}
if
(
XRE_IsGPUProcess
(
)
)
{
CreateGpuPDMs
(
)
;
}
else
if
(
XRE_IsRDDProcess
(
)
)
{
CreateRddPDMs
(
)
;
}
else
if
(
XRE_IsContentProcess
(
)
)
{
CreateContentPDMs
(
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
"
PDMFactory
is
only
usable
in
the
Parent
/
GPU
/
RDD
/
Content
process
"
)
;
CreateDefaultPDMs
(
)
;
}
}
void
PDMFactory
:
:
CreateGpuPDMs
(
)
{
#
ifdef
XP_WIN
if
(
StaticPrefs
:
:
media_wmf_enabled
(
)
&
&
!
IsWin7AndPre2000Compatible
(
)
)
{
CreateAndStartupPDM
<
WMFDecoderModule
>
(
)
;
}
#
endif
}
void
PDMFactory
:
:
CreateRddPDMs
(
)
{
#
ifdef
XP_WIN
if
(
StaticPrefs
:
:
media_wmf_enabled
(
)
&
&
StaticPrefs
:
:
media_rdd_wmf_enabled
(
)
)
{
CreateAndStartupPDM
<
WMFDecoderModule
>
(
)
;
}
#
endif
#
ifdef
MOZ_APPLEMEDIA
if
(
StaticPrefs
:
:
media_rdd_applemedia_enabled
(
)
)
{
CreateAndStartupPDM
<
AppleDecoderModule
>
(
)
;
}
#
endif
#
ifdef
MOZ_FFVPX
if
(
StaticPrefs
:
:
media_ffvpx_enabled
(
)
&
&
StaticPrefs
:
:
media_rdd_ffvpx_enabled
(
)
)
{
CreateAndStartupPDM
<
FFVPXRuntimeLinker
>
(
)
;
}
#
endif
#
ifdef
MOZ_FFMPEG
if
(
StaticPrefs
:
:
media_ffmpeg_enabled
(
)
&
&
StaticPrefs
:
:
media_rdd_ffmpeg_enabled
(
)
&
&
!
CreateAndStartupPDM
<
FFmpegRuntimeLinker
>
(
)
)
{
mFailureFlags
+
=
DecoderDoctorDiagnostics
:
:
Flags
:
:
FFmpegFailedToLoad
;
}
else
{
mFailureFlags
-
=
DecoderDoctorDiagnostics
:
:
Flags
:
:
FFmpegFailedToLoad
;
}
#
endif
CreateAndStartupPDM
<
AgnosticDecoderModule
>
(
)
;
}
void
PDMFactory
:
:
CreateContentPDMs
(
)
{
if
(
StaticPrefs
:
:
media_gpu_process_decoder
(
)
)
{
CreateAndStartupPDM
<
RemoteDecoderModule
>
(
RemoteDecodeIn
:
:
GpuProcess
)
;
}
if
(
StaticPrefs
:
:
media_rdd_process_enabled
(
)
)
{
CreateAndStartupPDM
<
RemoteDecoderModule
>
(
RemoteDecodeIn
:
:
RddProcess
)
;
}
#
ifdef
XP_WIN
if
(
StaticPrefs
:
:
media_wmf_enabled
(
)
&
&
!
IsWin7AndPre2000Compatible
(
)
)
{
RefPtr
<
WMFDecoderModule
>
m
=
MakeAndAddRef
<
WMFDecoderModule
>
(
)
;
if
(
!
StartupPDM
(
m
.
forget
(
)
)
)
{
mFailureFlags
+
=
DecoderDoctorDiagnostics
:
:
Flags
:
:
WMFFailedToLoad
;
}
}
else
if
(
StaticPrefs
:
:
media_decoder_doctor_wmf_disabled_is_failure
(
)
)
{
mFailureFlags
+
=
DecoderDoctorDiagnostics
:
:
Flags
:
:
WMFFailedToLoad
;
}
#
endif
#
ifdef
MOZ_APPLEMEDIA
CreateAndStartupPDM
<
AppleDecoderModule
>
(
)
;
#
endif
#
ifdef
MOZ_OMX
if
(
StaticPrefs
:
:
media_omx_enabled
(
)
)
{
CreateAndStartupPDM
<
OmxDecoderModule
>
(
)
;
}
#
endif
#
ifdef
MOZ_FFVPX
if
(
StaticPrefs
:
:
media_ffvpx_enabled
(
)
)
{
CreateAndStartupPDM
<
FFVPXRuntimeLinker
>
(
)
;
}
#
endif
#
ifdef
MOZ_FFMPEG
if
(
StaticPrefs
:
:
media_ffmpeg_enabled
(
)
&
&
!
CreateAndStartupPDM
<
FFmpegRuntimeLinker
>
(
)
)
{
mFailureFlags
+
=
DecoderDoctorDiagnostics
:
:
Flags
:
:
FFmpegFailedToLoad
;
}
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
if
(
StaticPrefs
:
:
media_android_media_codec_enabled
(
)
)
{
StartupPDM
(
AndroidDecoderModule
:
:
Create
(
)
StaticPrefs
:
:
media_android_media_codec_preferred
(
)
)
;
}
#
endif
CreateAndStartupPDM
<
AgnosticDecoderModule
>
(
)
;
if
(
StaticPrefs
:
:
media_gmp_decoder_enabled
(
)
&
&
!
CreateAndStartupPDM
<
GMPDecoderModule
>
(
)
)
{
mFailureFlags
+
=
DecoderDoctorDiagnostics
:
:
Flags
:
:
GMPPDMFailedToStartup
;
}
}
void
PDMFactory
:
:
CreateDefaultPDMs
(
)
{
#
ifdef
XP_WIN
if
(
StaticPrefs
:
:
media_wmf_enabled
(
)
&
&
!
IsWin7AndPre2000Compatible
(
)
)
{
RefPtr
<
WMFDecoderModule
>
m
=
MakeAndAddRef
<
WMFDecoderModule
>
(
)
;
if
(
!
StartupPDM
(
m
.
forget
(
)
)
)
{
mFailureFlags
+
=
DecoderDoctorDiagnostics
:
:
Flags
:
:
WMFFailedToLoad
;
}
}
else
if
(
StaticPrefs
:
:
media_decoder_doctor_wmf_disabled_is_failure
(
)
)
{
mFailureFlags
+
=
DecoderDoctorDiagnostics
:
:
Flags
:
:
WMFFailedToLoad
;
}
#
endif
#
ifdef
MOZ_APPLEMEDIA
CreateAndStartupPDM
<
AppleDecoderModule
>
(
)
;
#
endif
#
ifdef
MOZ_OMX
if
(
StaticPrefs
:
:
media_omx_enabled
(
)
)
{
CreateAndStartupPDM
<
OmxDecoderModule
>
(
)
;
}
#
endif
#
ifdef
MOZ_FFVPX
if
(
StaticPrefs
:
:
media_ffvpx_enabled
(
)
)
{
CreateAndStartupPDM
<
FFVPXRuntimeLinker
>
(
)
;
}
#
endif
#
ifdef
MOZ_FFMPEG
if
(
StaticPrefs
:
:
media_ffmpeg_enabled
(
)
&
&
!
CreateAndStartupPDM
<
FFmpegRuntimeLinker
>
(
)
)
{
mFailureFlags
+
=
DecoderDoctorDiagnostics
:
:
Flags
:
:
FFmpegFailedToLoad
;
}
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
if
(
StaticPrefs
:
:
media_android_media_codec_enabled
(
)
)
{
StartupPDM
(
AndroidDecoderModule
:
:
Create
(
)
StaticPrefs
:
:
media_android_media_codec_preferred
(
)
)
;
}
#
endif
CreateAndStartupPDM
<
AgnosticDecoderModule
>
(
)
;
if
(
StaticPrefs
:
:
media_gmp_decoder_enabled
(
)
&
&
!
CreateAndStartupPDM
<
GMPDecoderModule
>
(
)
)
{
mFailureFlags
+
=
DecoderDoctorDiagnostics
:
:
Flags
:
:
GMPPDMFailedToStartup
;
}
}
void
PDMFactory
:
:
CreateNullPDM
(
)
{
mNullPDM
=
CreateNullDecoderModule
(
)
;
MOZ_ASSERT
(
mNullPDM
&
&
NS_SUCCEEDED
(
mNullPDM
-
>
Startup
(
)
)
)
;
}
bool
PDMFactory
:
:
StartupPDM
(
already_AddRefed
<
PlatformDecoderModule
>
aPDM
bool
aInsertAtBeginning
)
{
RefPtr
<
PlatformDecoderModule
>
pdm
=
aPDM
;
if
(
pdm
&
&
NS_SUCCEEDED
(
pdm
-
>
Startup
(
)
)
)
{
if
(
aInsertAtBeginning
)
{
mCurrentPDMs
.
InsertElementAt
(
0
pdm
)
;
}
else
{
mCurrentPDMs
.
AppendElement
(
pdm
)
;
}
return
true
;
}
return
false
;
}
already_AddRefed
<
PlatformDecoderModule
>
PDMFactory
:
:
GetDecoderModule
(
const
SupportDecoderParams
&
aParams
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
if
(
aDiagnostics
)
{
aDiagnostics
-
>
SetFailureFlags
(
mFailureFlags
)
;
}
RefPtr
<
PlatformDecoderModule
>
pdm
;
for
(
auto
&
current
:
mCurrentPDMs
)
{
if
(
current
-
>
Supports
(
aParams
aDiagnostics
)
)
{
pdm
=
current
;
break
;
}
}
return
pdm
.
forget
(
)
;
}
void
PDMFactory
:
:
SetCDMProxy
(
CDMProxy
*
aProxy
)
{
MOZ_ASSERT
(
aProxy
)
;
#
ifdef
MOZ_WIDGET_ANDROID
if
(
IsWidevineKeySystem
(
aProxy
-
>
KeySystem
(
)
)
)
{
mEMEPDM
=
AndroidDecoderModule
:
:
Create
(
aProxy
)
;
return
;
}
#
endif
auto
m
=
MakeRefPtr
<
PDMFactory
>
(
)
;
mEMEPDM
=
MakeRefPtr
<
EMEDecoderModule
>
(
aProxy
m
)
;
}
PDMFactory
:
:
MediaCodecsSupported
PDMFactory
:
:
Supported
(
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
*
sSupported
;
}
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
static
MediaCodecsSupported
supported
=
[
]
(
)
{
auto
pdm
=
MakeRefPtr
<
PDMFactory
>
(
)
;
MediaCodecsSupported
supported
;
if
(
pdm
-
>
SupportsMimeType
(
"
video
/
avc
"
_ns
nullptr
)
)
{
supported
+
=
MediaCodecs
:
:
H264
;
}
if
(
pdm
-
>
SupportsMimeType
(
"
audio
/
mp4a
-
latm
"
_ns
nullptr
)
)
{
supported
+
=
MediaCodecs
:
:
AAC
;
}
if
(
pdm
-
>
SupportsMimeType
(
"
audio
/
mpeg
"
_ns
nullptr
)
)
{
supported
+
=
MediaCodecs
:
:
MP3
;
}
supported
+
=
MediaCodecs
:
:
VP9
;
supported
+
=
MediaCodecs
:
:
VP8
;
supported
+
=
MediaCodecs
:
:
AV1
;
supported
+
=
MediaCodecs
:
:
Theora
;
supported
+
=
MediaCodecs
:
:
Opus
;
supported
+
=
MediaCodecs
:
:
Vorbis
;
supported
+
=
MediaCodecs
:
:
Flac
;
supported
+
=
MediaCodecs
:
:
Wave
;
return
supported
;
}
(
)
;
return
supported
;
}
void
PDMFactory
:
:
SetSupported
(
const
MediaCodecsSupported
&
aSupported
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sSupported
=
Some
(
aSupported
)
;
}
}
