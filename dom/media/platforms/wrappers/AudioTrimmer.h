#
if
!
defined
(
AudioTrimmer_h_
)
#
define
AudioTrimmer_h_
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
namespace
mozilla
{
DDLoggedTypeDeclNameAndBase
(
AudioTrimmer
MediaDataDecoder
)
;
class
AudioTrimmer
final
:
public
MediaDataDecoder
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AudioTrimmer
final
)
;
explicit
AudioTrimmer
(
already_AddRefed
<
MediaDataDecoder
>
aDecoder
)
:
mDecoder
(
aDecoder
)
{
}
RefPtr
<
InitPromise
>
Init
(
)
override
;
RefPtr
<
DecodePromise
>
Decode
(
MediaRawData
*
aSample
)
override
;
bool
CanDecodeBatch
(
)
const
override
{
return
mDecoder
-
>
CanDecodeBatch
(
)
;
}
RefPtr
<
DecodePromise
>
DecodeBatch
(
nsTArray
<
RefPtr
<
MediaRawData
>
>
&
&
aSamples
)
override
;
RefPtr
<
DecodePromise
>
Drain
(
)
override
;
RefPtr
<
FlushPromise
>
Flush
(
)
override
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
nsCString
GetDescriptionName
(
)
const
override
;
nsCString
GetProcessName
(
)
const
override
;
nsCString
GetCodecName
(
)
const
override
;
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
override
;
void
SetSeekThreshold
(
const
media
:
:
TimeUnit
&
aTime
)
override
;
bool
SupportDecoderRecycling
(
)
const
override
;
bool
ShouldDecoderAlwaysBeRecycled
(
)
const
override
;
ConversionRequired
NeedsConversion
(
)
const
override
;
private
:
~
AudioTrimmer
(
)
=
default
;
RefPtr
<
DecodePromise
>
HandleDecodedResult
(
DecodePromise
:
:
ResolveOrRejectValue
&
&
aValue
)
;
void
PrepareTrimmers
(
MediaRawData
*
aRaw
)
;
const
RefPtr
<
MediaDataDecoder
>
mDecoder
;
nsCOMPtr
<
nsISerialEventTarget
>
mThread
;
AutoTArray
<
Maybe
<
media
:
:
TimeInterval
>
2
>
mTrimmers
;
}
;
}
#
endif
