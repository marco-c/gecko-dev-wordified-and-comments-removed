#
ifndef
mozilla_H264Converter_h
#
define
mozilla_H264Converter_h
#
include
"
PlatformDecoderModule
.
h
"
namespace
mozilla
{
class
H264Converter
:
public
MediaDataDecoder
{
public
:
H264Converter
(
PlatformDecoderModule
*
aPDM
const
VideoInfo
&
aConfig
layers
:
:
LayersBackend
aLayersBackend
layers
:
:
ImageContainer
*
aImageContainer
FlushableTaskQueue
*
aVideoTaskQueue
MediaDataDecoderCallback
*
aCallback
)
;
virtual
~
H264Converter
(
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
nsresult
Input
(
MediaRawData
*
aSample
)
override
;
nsresult
Flush
(
)
override
;
nsresult
Drain
(
)
override
;
nsresult
Shutdown
(
)
override
;
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
override
;
const
char
*
GetDescriptionName
(
)
const
override
{
if
(
mDecoder
)
{
return
mDecoder
-
>
GetDescriptionName
(
)
;
}
return
"
H264Converter
decoder
(
pending
)
"
;
}
static
bool
IsH264
(
const
TrackInfo
&
aConfig
)
;
nsresult
GetLastError
(
)
const
{
return
mLastError
;
}
private
:
nsresult
CreateDecoder
(
)
;
nsresult
CreateDecoderAndInit
(
MediaRawData
*
aSample
)
;
nsresult
CheckForSPSChange
(
MediaRawData
*
aSample
)
;
void
UpdateConfigFromExtraData
(
MediaByteBuffer
*
aExtraData
)
;
void
OnDecoderInitDone
(
const
TrackType
aTrackType
)
;
void
OnDecoderInitFailed
(
MediaDataDecoder
:
:
DecoderFailureReason
aReason
)
;
RefPtr
<
PlatformDecoderModule
>
mPDM
;
VideoInfo
mOriginalConfig
;
VideoInfo
mCurrentConfig
;
layers
:
:
LayersBackend
mLayersBackend
;
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
RefPtr
<
FlushableTaskQueue
>
mVideoTaskQueue
;
nsTArray
<
RefPtr
<
MediaRawData
>
>
mMediaRawSamples
;
MediaDataDecoderCallback
*
mCallback
;
RefPtr
<
MediaDataDecoder
>
mDecoder
;
MozPromiseRequestHolder
<
InitPromise
>
mInitPromiseRequest
;
bool
mNeedAVCC
;
nsresult
mLastError
;
}
;
}
#
endif
