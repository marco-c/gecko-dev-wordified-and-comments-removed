#
ifndef
mozilla_H264Converter_h
#
define
mozilla_H264Converter_h
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
namespace
mozilla
{
class
DecoderDoctorDiagnostics
;
class
H264Converter
:
public
MediaDataDecoder
{
public
:
H264Converter
(
PlatformDecoderModule
*
aPDM
const
CreateDecoderParams
&
aParams
)
;
virtual
~
H264Converter
(
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
RefPtr
<
DecodePromise
>
Decode
(
MediaRawData
*
aSample
)
override
;
RefPtr
<
DecodePromise
>
Drain
(
)
override
;
RefPtr
<
FlushPromise
>
Flush
(
)
override
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
override
;
nsCString
GetDescriptionName
(
)
const
override
{
if
(
mDecoder
)
{
return
mDecoder
-
>
GetDescriptionName
(
)
;
}
return
NS_LITERAL_CSTRING
(
"
H264Converter
decoder
(
pending
)
"
)
;
}
void
SetSeekThreshold
(
const
media
:
:
TimeUnit
&
aTime
)
override
;
bool
SupportDecoderRecycling
(
)
const
override
{
if
(
mDecoder
)
{
return
mDecoder
-
>
SupportDecoderRecycling
(
)
;
}
return
false
;
}
ConversionRequired
NeedsConversion
(
)
const
override
{
if
(
mDecoder
)
{
return
mDecoder
-
>
NeedsConversion
(
)
;
}
return
ConversionRequired
:
:
kNeedAVCC
;
}
nsresult
GetLastError
(
)
const
{
return
mLastError
;
}
private
:
nsresult
CreateDecoder
(
const
VideoInfo
&
aConfig
DecoderDoctorDiagnostics
*
aDiagnostics
)
;
nsresult
CreateDecoderAndInit
(
MediaRawData
*
aSample
)
;
nsresult
CheckForSPSChange
(
MediaRawData
*
aSample
)
;
void
UpdateConfigFromExtraData
(
MediaByteBuffer
*
aExtraData
)
;
bool
CanRecycleDecoder
(
)
const
;
void
DecodeFirstSample
(
MediaRawData
*
aSample
)
;
void
DrainThenFlushDecoder
(
MediaRawData
*
aPendingSample
)
;
void
FlushThenShutdownDecoder
(
MediaRawData
*
aPendingSample
)
;
RefPtr
<
ShutdownPromise
>
ShutdownDecoder
(
)
;
RefPtr
<
PlatformDecoderModule
>
mPDM
;
const
VideoInfo
mOriginalConfig
;
VideoInfo
mCurrentConfig
;
RefPtr
<
MediaByteBuffer
>
mOriginalExtraData
;
RefPtr
<
layers
:
:
KnowsCompositor
>
mKnowsCompositor
;
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
const
RefPtr
<
TaskQueue
>
mTaskQueue
;
RefPtr
<
MediaDataDecoder
>
mDecoder
;
MozPromiseRequestHolder
<
InitPromise
>
mInitPromiseRequest
;
MozPromiseRequestHolder
<
DecodePromise
>
mDecodePromiseRequest
;
MozPromiseHolder
<
DecodePromise
>
mDecodePromise
;
MozPromiseRequestHolder
<
FlushPromise
>
mFlushRequest
;
MediaDataDecoder
:
:
DecodedData
mPendingFrames
;
MozPromiseRequestHolder
<
DecodePromise
>
mDrainRequest
;
MozPromiseRequestHolder
<
ShutdownPromise
>
mShutdownRequest
;
RefPtr
<
ShutdownPromise
>
mShutdownPromise
;
MozPromiseHolder
<
FlushPromise
>
mFlushPromise
;
RefPtr
<
GMPCrashHelper
>
mGMPCrashHelper
;
Maybe
<
bool
>
mNeedAVCC
;
nsresult
mLastError
;
bool
mNeedKeyframe
=
true
;
const
TrackInfo
:
:
TrackType
mType
;
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
*
const
mOnWaitingForKeyEvent
;
const
CreateDecoderParams
:
:
OptionSet
mDecoderOptions
;
Maybe
<
bool
>
mCanRecycleDecoder
;
}
;
}
#
endif
