#
include
"
H264Converter
.
h
"
#
include
"
DecoderDoctorDiagnostics
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
MediaPrefs
.
h
"
#
include
"
PDMFactory
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mp4_demuxer
/
AnnexB
.
h
"
#
include
"
mp4_demuxer
/
H264
.
h
"
namespace
mozilla
{
H264Converter
:
:
H264Converter
(
PlatformDecoderModule
*
aPDM
const
CreateDecoderParams
&
aParams
)
:
mPDM
(
aPDM
)
mOriginalConfig
(
aParams
.
VideoConfig
(
)
)
mCurrentConfig
(
aParams
.
VideoConfig
(
)
)
mKnowsCompositor
(
aParams
.
mKnowsCompositor
)
mImageContainer
(
aParams
.
mImageContainer
)
mTaskQueue
(
aParams
.
mTaskQueue
)
mDecoder
(
nullptr
)
mGMPCrashHelper
(
aParams
.
mCrashHelper
)
mLastError
(
NS_OK
)
mType
(
aParams
.
mType
)
mOnWaitingForKeyEvent
(
aParams
.
mOnWaitingForKeyEvent
)
mDecoderOptions
(
aParams
.
mOptions
)
{
mLastError
=
CreateDecoder
(
mOriginalConfig
aParams
.
mDiagnostics
)
;
if
(
mDecoder
)
{
MOZ_ASSERT
(
mp4_demuxer
:
:
H264
:
:
HasSPS
(
mOriginalConfig
.
mExtraData
)
)
;
mOriginalExtraData
=
mOriginalConfig
.
mExtraData
;
}
}
H264Converter
:
:
~
H264Converter
(
)
{
}
RefPtr
<
MediaDataDecoder
:
:
InitPromise
>
H264Converter
:
:
Init
(
)
{
if
(
mDecoder
)
{
return
mDecoder
-
>
Init
(
)
;
}
return
MediaDataDecoder
:
:
InitPromise
:
:
CreateAndResolve
(
TrackType
:
:
kVideoTrack
__func__
)
;
}
RefPtr
<
MediaDataDecoder
:
:
DecodePromise
>
H264Converter
:
:
Decode
(
MediaRawData
*
aSample
)
{
MOZ_RELEASE_ASSERT
(
mFlushPromise
.
IsEmpty
(
)
"
Flush
operatin
didn
'
t
complete
"
)
;
MOZ_RELEASE_ASSERT
(
!
mDecodePromiseRequest
.
Exists
(
)
&
&
!
mInitPromiseRequest
.
Exists
(
)
"
Can
'
t
request
a
new
decode
until
previous
one
completed
"
)
;
if
(
!
mp4_demuxer
:
:
AnnexB
:
:
ConvertSampleToAVCC
(
aSample
)
)
{
return
DecodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
ConvertSampleToAVCC
"
)
)
__func__
)
;
}
if
(
!
mp4_demuxer
:
:
AnnexB
:
:
IsAVCC
(
aSample
)
)
{
return
DecodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
Invalid
H264
content
"
)
)
__func__
)
;
}
MediaResult
rv
(
NS_OK
)
;
if
(
!
mDecoder
)
{
rv
=
CreateDecoderAndInit
(
aSample
)
;
if
(
rv
=
=
NS_ERROR_NOT_INITIALIZED
)
{
return
DecodePromise
:
:
CreateAndResolve
(
DecodedData
(
)
__func__
)
;
}
}
else
{
if
(
!
mNeedAVCC
)
{
mNeedAVCC
=
Some
(
mDecoder
-
>
NeedsConversion
(
)
=
=
ConversionRequired
:
:
kNeedAVCC
)
;
}
if
(
!
mCanRecycleDecoder
)
{
mCanRecycleDecoder
=
Some
(
CanRecycleDecoder
(
)
)
;
}
rv
=
CheckForSPSChange
(
aSample
)
;
}
if
(
rv
=
=
NS_ERROR_DOM_MEDIA_INITIALIZING_DECODER
)
{
RefPtr
<
DecodePromise
>
p
=
mDecodePromise
.
Ensure
(
__func__
)
;
return
p
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
DecodePromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
if
(
mNeedKeyframe
&
&
!
aSample
-
>
mKeyframe
)
{
return
DecodePromise
:
:
CreateAndResolve
(
DecodedData
(
)
__func__
)
;
}
if
(
!
*
mNeedAVCC
&
&
!
mp4_demuxer
:
:
AnnexB
:
:
ConvertSampleToAnnexB
(
aSample
mNeedKeyframe
)
)
{
return
DecodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
ConvertSampleToAnnexB
"
)
)
__func__
)
;
}
mNeedKeyframe
=
false
;
aSample
-
>
mExtraData
=
mCurrentConfig
.
mExtraData
;
return
mDecoder
-
>
Decode
(
aSample
)
;
}
RefPtr
<
MediaDataDecoder
:
:
FlushPromise
>
H264Converter
:
:
Flush
(
)
{
mDecodePromiseRequest
.
DisconnectIfExists
(
)
;
mDecodePromise
.
RejectIfExists
(
NS_ERROR_DOM_MEDIA_CANCELED
__func__
)
;
mNeedKeyframe
=
true
;
mPendingFrames
.
Clear
(
)
;
MOZ_RELEASE_ASSERT
(
mFlushPromise
.
IsEmpty
(
)
"
Previous
flush
didn
'
t
complete
"
)
;
if
(
mDrainRequest
.
Exists
(
)
|
|
mFlushRequest
.
Exists
(
)
|
|
mShutdownRequest
.
Exists
(
)
|
|
mInitPromiseRequest
.
Exists
(
)
)
{
return
mFlushPromise
.
Ensure
(
__func__
)
;
}
if
(
mDecoder
)
{
return
mDecoder
-
>
Flush
(
)
;
}
return
FlushPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
RefPtr
<
MediaDataDecoder
:
:
DecodePromise
>
H264Converter
:
:
Drain
(
)
{
MOZ_RELEASE_ASSERT
(
!
mDrainRequest
.
Exists
(
)
)
;
mNeedKeyframe
=
true
;
if
(
mDecoder
)
{
return
mDecoder
-
>
Drain
(
)
;
}
return
DecodePromise
:
:
CreateAndResolve
(
DecodedData
(
)
__func__
)
;
}
RefPtr
<
ShutdownPromise
>
H264Converter
:
:
Shutdown
(
)
{
mInitPromiseRequest
.
DisconnectIfExists
(
)
;
mDecodePromiseRequest
.
DisconnectIfExists
(
)
;
mDecodePromise
.
RejectIfExists
(
NS_ERROR_DOM_MEDIA_CANCELED
__func__
)
;
mDrainRequest
.
DisconnectIfExists
(
)
;
mFlushRequest
.
DisconnectIfExists
(
)
;
mFlushPromise
.
RejectIfExists
(
NS_ERROR_DOM_MEDIA_CANCELED
__func__
)
;
mShutdownRequest
.
DisconnectIfExists
(
)
;
if
(
mShutdownPromise
)
{
return
mShutdownPromise
.
forget
(
)
;
}
return
ShutdownDecoder
(
)
;
}
RefPtr
<
ShutdownPromise
>
H264Converter
:
:
ShutdownDecoder
(
)
{
mNeedAVCC
.
reset
(
)
;
if
(
mDecoder
)
{
RefPtr
<
MediaDataDecoder
>
decoder
=
mDecoder
.
forget
(
)
;
return
decoder
-
>
Shutdown
(
)
;
}
return
ShutdownPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
bool
H264Converter
:
:
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
{
if
(
mDecoder
)
{
return
mDecoder
-
>
IsHardwareAccelerated
(
aFailureReason
)
;
}
return
MediaDataDecoder
:
:
IsHardwareAccelerated
(
aFailureReason
)
;
}
void
H264Converter
:
:
SetSeekThreshold
(
const
media
:
:
TimeUnit
&
aTime
)
{
if
(
mDecoder
)
{
mDecoder
-
>
SetSeekThreshold
(
aTime
)
;
}
else
{
MediaDataDecoder
:
:
SetSeekThreshold
(
aTime
)
;
}
}
MediaResult
H264Converter
:
:
CreateDecoder
(
const
VideoInfo
&
aConfig
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
if
(
!
mp4_demuxer
:
:
H264
:
:
HasSPS
(
aConfig
.
mExtraData
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
UpdateConfigFromExtraData
(
aConfig
.
mExtraData
)
;
mp4_demuxer
:
:
SPSData
spsdata
;
if
(
mp4_demuxer
:
:
H264
:
:
DecodeSPSFromExtraData
(
aConfig
.
mExtraData
spsdata
)
)
{
if
(
spsdata
.
profile_idc
=
=
244
|
|
spsdata
.
chroma_format_idc
=
=
PDMFactory
:
:
kYUV444
)
{
if
(
aDiagnostics
)
{
aDiagnostics
-
>
SetVideoNotSupported
(
)
;
}
return
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
No
support
for
YUV444
format
.
"
)
)
;
}
}
else
{
return
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
Invalid
SPS
NAL
.
"
)
)
;
}
MediaResult
error
=
NS_OK
;
mDecoder
=
mPDM
-
>
CreateVideoDecoder
(
{
aConfig
mTaskQueue
aDiagnostics
mImageContainer
mKnowsCompositor
mGMPCrashHelper
mType
mOnWaitingForKeyEvent
mDecoderOptions
&
error
}
)
;
if
(
!
mDecoder
)
{
if
(
NS_FAILED
(
error
)
)
{
return
error
;
}
else
{
return
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
Unable
to
create
H264
decoder
"
)
)
;
}
}
mNeedKeyframe
=
true
;
return
NS_OK
;
}
MediaResult
H264Converter
:
:
CreateDecoderAndInit
(
MediaRawData
*
aSample
)
{
RefPtr
<
MediaByteBuffer
>
extra_data
=
mp4_demuxer
:
:
H264
:
:
ExtractExtraData
(
aSample
)
;
bool
inbandExtradata
=
mp4_demuxer
:
:
H264
:
:
HasSPS
(
extra_data
)
;
if
(
!
inbandExtradata
&
&
!
mp4_demuxer
:
:
H264
:
:
HasSPS
(
mCurrentConfig
.
mExtraData
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
inbandExtradata
)
{
UpdateConfigFromExtraData
(
extra_data
)
;
}
MediaResult
rv
=
CreateDecoder
(
mCurrentConfig
nullptr
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
RefPtr
<
H264Converter
>
self
=
this
;
RefPtr
<
MediaRawData
>
sample
=
aSample
;
mDecoder
-
>
Init
(
)
-
>
Then
(
AbstractThread
:
:
GetCurrent
(
)
-
>
AsTaskQueue
(
)
__func__
[
self
sample
this
]
(
const
TrackType
aTrackType
)
{
mInitPromiseRequest
.
Complete
(
)
;
mNeedAVCC
=
Some
(
mDecoder
-
>
NeedsConversion
(
)
=
=
ConversionRequired
:
:
kNeedAVCC
)
;
mCanRecycleDecoder
=
Some
(
CanRecycleDecoder
(
)
)
;
if
(
!
mFlushPromise
.
IsEmpty
(
)
)
{
mFlushPromise
.
Resolve
(
true
__func__
)
;
return
;
}
DecodeFirstSample
(
sample
)
;
}
[
self
this
]
(
const
MediaResult
&
aError
)
{
mInitPromiseRequest
.
Complete
(
)
;
if
(
!
mFlushPromise
.
IsEmpty
(
)
)
{
mFlushPromise
.
Reject
(
aError
__func__
)
;
return
;
}
mDecodePromise
.
Reject
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
Unable
to
initialize
H264
decoder
"
)
)
__func__
)
;
}
)
-
>
Track
(
mInitPromiseRequest
)
;
return
NS_ERROR_DOM_MEDIA_INITIALIZING_DECODER
;
}
return
rv
;
}
bool
H264Converter
:
:
CanRecycleDecoder
(
)
const
{
MOZ_ASSERT
(
mDecoder
)
;
return
MediaPrefs
:
:
MediaDecoderCheckRecycling
(
)
&
&
mDecoder
-
>
SupportDecoderRecycling
(
)
;
}
void
H264Converter
:
:
DecodeFirstSample
(
MediaRawData
*
aSample
)
{
if
(
mNeedKeyframe
&
&
!
aSample
-
>
mKeyframe
)
{
mDecodePromise
.
Resolve
(
mPendingFrames
__func__
)
;
mPendingFrames
.
Clear
(
)
;
return
;
}
if
(
!
*
mNeedAVCC
&
&
!
mp4_demuxer
:
:
AnnexB
:
:
ConvertSampleToAnnexB
(
aSample
mNeedKeyframe
)
)
{
mDecodePromise
.
Reject
(
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
ConvertSampleToAnnexB
"
)
)
__func__
)
;
return
;
}
mNeedKeyframe
=
false
;
RefPtr
<
H264Converter
>
self
=
this
;
mDecoder
-
>
Decode
(
aSample
)
-
>
Then
(
AbstractThread
:
:
GetCurrent
(
)
-
>
AsTaskQueue
(
)
__func__
[
self
this
]
(
const
MediaDataDecoder
:
:
DecodedData
&
aResults
)
{
mDecodePromiseRequest
.
Complete
(
)
;
mPendingFrames
.
AppendElements
(
aResults
)
;
mDecodePromise
.
Resolve
(
mPendingFrames
__func__
)
;
mPendingFrames
.
Clear
(
)
;
}
[
self
this
]
(
const
MediaResult
&
aError
)
{
mDecodePromiseRequest
.
Complete
(
)
;
mDecodePromise
.
Reject
(
aError
__func__
)
;
}
)
-
>
Track
(
mDecodePromiseRequest
)
;
}
MediaResult
H264Converter
:
:
CheckForSPSChange
(
MediaRawData
*
aSample
)
{
RefPtr
<
MediaByteBuffer
>
extra_data
=
mp4_demuxer
:
:
H264
:
:
ExtractExtraData
(
aSample
)
;
if
(
!
mp4_demuxer
:
:
H264
:
:
HasSPS
(
extra_data
)
)
{
MOZ_ASSERT
(
mCanRecycleDecoder
.
isSome
(
)
)
;
if
(
!
*
mCanRecycleDecoder
)
{
return
NS_OK
;
}
if
(
!
mp4_demuxer
:
:
H264
:
:
HasSPS
(
aSample
-
>
mExtraData
)
|
|
mp4_demuxer
:
:
H264
:
:
CompareExtraData
(
aSample
-
>
mExtraData
mOriginalExtraData
)
)
{
return
NS_OK
;
}
extra_data
=
mOriginalExtraData
=
aSample
-
>
mExtraData
;
}
if
(
mp4_demuxer
:
:
H264
:
:
CompareExtraData
(
extra_data
mCurrentConfig
.
mExtraData
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mCanRecycleDecoder
.
isSome
(
)
)
;
if
(
*
mCanRecycleDecoder
)
{
UpdateConfigFromExtraData
(
extra_data
)
;
if
(
!
aSample
-
>
mTrackInfo
)
{
aSample
-
>
mTrackInfo
=
new
TrackInfoSharedPtr
(
mCurrentConfig
0
)
;
}
mNeedKeyframe
=
true
;
return
NS_OK
;
}
DrainThenFlushDecoder
(
aSample
)
;
return
NS_ERROR_DOM_MEDIA_INITIALIZING_DECODER
;
}
void
H264Converter
:
:
DrainThenFlushDecoder
(
MediaRawData
*
aPendingSample
)
{
RefPtr
<
MediaRawData
>
sample
=
aPendingSample
;
RefPtr
<
H264Converter
>
self
=
this
;
mDecoder
-
>
Drain
(
)
-
>
Then
(
AbstractThread
:
:
GetCurrent
(
)
-
>
AsTaskQueue
(
)
__func__
[
self
sample
this
]
(
const
MediaDataDecoder
:
:
DecodedData
&
aResults
)
{
mDrainRequest
.
Complete
(
)
;
if
(
!
mFlushPromise
.
IsEmpty
(
)
)
{
mFlushPromise
.
Resolve
(
true
__func__
)
;
return
;
}
if
(
aResults
.
Length
(
)
>
0
)
{
mPendingFrames
.
AppendElements
(
aResults
)
;
DrainThenFlushDecoder
(
sample
)
;
return
;
}
FlushThenShutdownDecoder
(
sample
)
;
}
[
self
this
]
(
const
MediaResult
&
aError
)
{
mDrainRequest
.
Complete
(
)
;
if
(
!
mFlushPromise
.
IsEmpty
(
)
)
{
mFlushPromise
.
Reject
(
aError
__func__
)
;
return
;
}
mDecodePromise
.
Reject
(
aError
__func__
)
;
}
)
-
>
Track
(
mDrainRequest
)
;
}
void
H264Converter
:
:
FlushThenShutdownDecoder
(
MediaRawData
*
aPendingSample
)
{
RefPtr
<
MediaRawData
>
sample
=
aPendingSample
;
RefPtr
<
H264Converter
>
self
=
this
;
mDecoder
-
>
Flush
(
)
-
>
Then
(
AbstractThread
:
:
GetCurrent
(
)
-
>
AsTaskQueue
(
)
__func__
[
self
sample
this
]
(
)
{
mFlushRequest
.
Complete
(
)
;
if
(
!
mFlushPromise
.
IsEmpty
(
)
)
{
mFlushPromise
.
Resolve
(
true
__func__
)
;
return
;
}
mShutdownPromise
=
ShutdownDecoder
(
)
;
mShutdownPromise
-
>
Then
(
AbstractThread
:
:
GetCurrent
(
)
-
>
AsTaskQueue
(
)
__func__
[
self
sample
this
]
(
)
{
mShutdownRequest
.
Complete
(
)
;
mShutdownPromise
=
nullptr
;
if
(
!
mFlushPromise
.
IsEmpty
(
)
)
{
mFlushPromise
.
Resolve
(
true
__func__
)
;
return
;
}
MediaResult
rv
=
CreateDecoderAndInit
(
sample
)
;
if
(
rv
=
=
NS_ERROR_DOM_MEDIA_INITIALIZING_DECODER
)
{
return
;
}
MOZ_ASSERT
(
NS_FAILED
(
rv
)
)
;
mDecodePromise
.
Reject
(
rv
__func__
)
;
return
;
}
[
]
{
MOZ_CRASH
(
"
Can
'
t
reach
here
'
"
)
;
}
)
-
>
Track
(
mShutdownRequest
)
;
}
[
self
this
]
(
const
MediaResult
&
aError
)
{
mFlushRequest
.
Complete
(
)
;
if
(
!
mFlushPromise
.
IsEmpty
(
)
)
{
mFlushPromise
.
Reject
(
aError
__func__
)
;
return
;
}
mDecodePromise
.
Reject
(
aError
__func__
)
;
}
)
-
>
Track
(
mFlushRequest
)
;
}
void
H264Converter
:
:
UpdateConfigFromExtraData
(
MediaByteBuffer
*
aExtraData
)
{
mp4_demuxer
:
:
SPSData
spsdata
;
if
(
mp4_demuxer
:
:
H264
:
:
DecodeSPSFromExtraData
(
aExtraData
spsdata
)
&
&
spsdata
.
pic_width
>
0
&
&
spsdata
.
pic_height
>
0
)
{
mp4_demuxer
:
:
H264
:
:
EnsureSPSIsSane
(
spsdata
)
;
mCurrentConfig
.
mImage
.
width
=
spsdata
.
pic_width
;
mCurrentConfig
.
mImage
.
height
=
spsdata
.
pic_height
;
mCurrentConfig
.
mDisplay
.
width
=
spsdata
.
display_width
;
mCurrentConfig
.
mDisplay
.
height
=
spsdata
.
display_height
;
}
mCurrentConfig
.
mExtraData
=
aExtraData
;
}
}
