#
ifndef
__FFmpegH264Decoder_h__
#
define
__FFmpegH264Decoder_h__
#
include
"
FFmpegDataDecoder
.
h
"
#
include
"
mozilla
/
Pair
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
template
<
int
V
>
class
FFmpegH264Decoder
:
public
FFmpegDataDecoder
<
V
>
{
}
;
template
<
>
class
FFmpegH264Decoder
<
LIBAV_VER
>
:
public
FFmpegDataDecoder
<
LIBAV_VER
>
{
typedef
mozilla
:
:
layers
:
:
Image
Image
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
enum
DecodeResult
{
DECODE_FRAME
DECODE_NO_FRAME
DECODE_ERROR
}
;
public
:
FFmpegH264Decoder
(
FlushableTaskQueue
*
aTaskQueue
MediaDataDecoderCallback
*
aCallback
const
VideoInfo
&
aConfig
ImageContainer
*
aImageContainer
)
;
virtual
~
FFmpegH264Decoder
(
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
nsresult
Input
(
MediaRawData
*
aSample
)
override
;
void
ProcessDrain
(
)
override
;
void
ProcessFlush
(
)
override
;
static
AVCodecID
GetCodecId
(
const
nsACString
&
aMimeType
)
;
private
:
void
DecodeFrame
(
MediaRawData
*
aSample
)
;
DecodeResult
DoDecodeFrame
(
MediaRawData
*
aSample
)
;
DecodeResult
DoDecodeFrame
(
MediaRawData
*
aSample
uint8_t
*
aData
int
aSize
)
;
void
DoDrain
(
)
;
void
OutputDelayedFrames
(
)
;
int
AllocateYUV420PVideoBuffer
(
AVCodecContext
*
aCodecContext
AVFrame
*
aFrame
)
;
static
int
AllocateBufferCb
(
AVCodecContext
*
aCodecContext
AVFrame
*
aFrame
)
;
static
void
ReleaseBufferCb
(
AVCodecContext
*
aCodecContext
AVFrame
*
aFrame
)
;
RefPtr
<
ImageContainer
>
mImageContainer
;
uint32_t
mPictureWidth
;
uint32_t
mPictureHeight
;
uint32_t
mDisplayWidth
;
uint32_t
mDisplayHeight
;
class
PtsCorrectionContext
{
public
:
PtsCorrectionContext
(
)
;
int64_t
GuessCorrectPts
(
int64_t
aPts
int64_t
aDts
)
;
void
Reset
(
)
;
private
:
int64_t
mNumFaultyPts
;
int64_t
mNumFaultyDts
;
int64_t
mLastPts
;
int64_t
mLastDts
;
}
;
PtsCorrectionContext
mPtsContext
;
class
DurationMap
{
public
:
typedef
Pair
<
int64_t
int64_t
>
DurationElement
;
void
Insert
(
int64_t
aDts
int64_t
aDuration
)
{
mMap
.
AppendElement
(
MakePair
(
aDts
aDuration
)
)
;
}
bool
Find
(
int64_t
aDts
int64_t
&
aDuration
)
{
for
(
uint32_t
i
=
0
;
i
<
mMap
.
Length
(
)
;
i
+
+
)
{
DurationElement
&
element
=
mMap
[
i
]
;
if
(
element
.
first
(
)
=
=
aDts
)
{
aDuration
=
element
.
second
(
)
;
mMap
.
RemoveElementAt
(
i
)
;
return
true
;
}
}
return
false
;
}
void
Clear
(
)
{
mMap
.
Clear
(
)
;
}
private
:
nsAutoTArray
<
DurationElement
16
>
mMap
;
}
;
DurationMap
mDurationMap
;
}
;
}
#
endif
