#
ifndef
__FFmpegH264Decoder_h__
#
define
__FFmpegH264Decoder_h__
#
include
"
FFmpegDataDecoder
.
h
"
namespace
mozilla
{
template
<
int
V
>
class
FFmpegH264Decoder
:
public
FFmpegDataDecoder
<
V
>
{
}
;
template
<
>
class
FFmpegH264Decoder
<
LIBAV_VER
>
:
public
FFmpegDataDecoder
<
LIBAV_VER
>
{
typedef
mozilla
:
:
layers
:
:
Image
Image
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
enum
DecodeResult
{
DECODE_FRAME
DECODE_NO_FRAME
DECODE_ERROR
}
;
public
:
FFmpegH264Decoder
(
FlushableTaskQueue
*
aTaskQueue
MediaDataDecoderCallback
*
aCallback
const
VideoInfo
&
aConfig
ImageContainer
*
aImageContainer
)
;
virtual
~
FFmpegH264Decoder
(
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
nsresult
Input
(
MediaRawData
*
aSample
)
override
;
void
ProcessDrain
(
)
override
;
void
ProcessFlush
(
)
override
;
static
AVCodecID
GetCodecId
(
const
nsACString
&
aMimeType
)
;
private
:
void
DecodeFrame
(
MediaRawData
*
aSample
)
;
DecodeResult
DoDecodeFrame
(
MediaRawData
*
aSample
)
;
DecodeResult
DoDecodeFrame
(
MediaRawData
*
aSample
uint8_t
*
aData
int
aSize
)
;
void
DoDrain
(
)
;
void
OutputDelayedFrames
(
)
;
int
AllocateYUV420PVideoBuffer
(
AVCodecContext
*
aCodecContext
AVFrame
*
aFrame
)
;
static
int
AllocateBufferCb
(
AVCodecContext
*
aCodecContext
AVFrame
*
aFrame
)
;
static
void
ReleaseBufferCb
(
AVCodecContext
*
aCodecContext
AVFrame
*
aFrame
)
;
RefPtr
<
ImageContainer
>
mImageContainer
;
uint32_t
mPictureWidth
;
uint32_t
mPictureHeight
;
uint32_t
mDisplayWidth
;
uint32_t
mDisplayHeight
;
class
PtsCorrectionContext
{
public
:
PtsCorrectionContext
(
)
;
int64_t
GuessCorrectPts
(
int64_t
aPts
int64_t
aDts
)
;
void
Reset
(
)
;
private
:
int64_t
mNumFaultyPts
;
int64_t
mNumFaultyDts
;
int64_t
mLastPts
;
int64_t
mLastDts
;
}
;
PtsCorrectionContext
mPtsContext
;
}
;
}
#
endif
