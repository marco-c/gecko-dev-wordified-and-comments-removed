#
include
"
FFmpegVideoEncoder
.
h
"
#
include
"
BufferReader
.
h
"
#
include
"
FFmpegLog
.
h
"
#
include
"
FFmpegRuntimeLinker
.
h
"
#
include
"
H264
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
libavutil
/
error
.
h
"
#
include
"
libavutil
/
pixfmt
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmapBinding
.
h
"
#
include
"
mozilla
/
dom
/
ImageUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
ImageToI420
.
h
"
#
include
"
libyuv
.
h
"
namespace
ffmpeg
{
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
57
using
FFmpegBitRate
=
int64_t
;
constexpr
size_t
FFmpegErrorMaxStringSize
=
AV_ERROR_MAX_STRING_SIZE
;
#
else
using
FFmpegBitRate
=
int
;
constexpr
size_t
FFmpegErrorMaxStringSize
=
64
;
#
endif
struct
H264Setting
{
int
mValue
;
nsCString
mString
;
}
;
static
const
H264Setting
H264Profiles
[
]
{
{
FF_PROFILE_H264_BASELINE
"
baseline
"
_ns
}
{
FF_PROFILE_H264_MAIN
"
main
"
_ns
}
{
FF_PROFILE_H264_EXTENDED
EmptyCString
(
)
}
{
FF_PROFILE_H264_HIGH
"
high
"
_ns
}
}
;
static
mozilla
:
:
Maybe
<
H264Setting
>
GetH264Profile
(
const
mozilla
:
:
H264_PROFILE
&
aProfile
)
{
switch
(
aProfile
)
{
case
mozilla
:
:
H264_PROFILE
:
:
H264_PROFILE_UNKNOWN
:
return
mozilla
:
:
Nothing
(
)
;
case
mozilla
:
:
H264_PROFILE
:
:
H264_PROFILE_BASE
:
return
mozilla
:
:
Some
(
H264Profiles
[
0
]
)
;
case
mozilla
:
:
H264_PROFILE
:
:
H264_PROFILE_MAIN
:
return
mozilla
:
:
Some
(
H264Profiles
[
1
]
)
;
case
mozilla
:
:
H264_PROFILE
:
:
H264_PROFILE_EXTENDED
:
return
mozilla
:
:
Some
(
H264Profiles
[
2
]
)
;
case
mozilla
:
:
H264_PROFILE
:
:
H264_PROFILE_HIGH
:
return
mozilla
:
:
Some
(
H264Profiles
[
3
]
)
;
default
:
break
;
}
MOZ_ASSERT_UNREACHABLE
(
"
undefined
profile
"
)
;
return
mozilla
:
:
Nothing
(
)
;
}
static
mozilla
:
:
Maybe
<
H264Setting
>
GetH264Level
(
const
mozilla
:
:
H264_LEVEL
&
aLevel
)
{
int
val
=
static_cast
<
int
>
(
aLevel
)
;
if
(
val
<
10
|
|
val
>
52
)
{
return
mozilla
:
:
Nothing
(
)
;
}
if
(
(
val
%
10
)
>
2
)
{
if
(
val
!
=
13
)
{
return
mozilla
:
:
Nothing
(
)
;
}
}
nsPrintfCString
str
(
"
%
d
"
val
)
;
str
.
Insert
(
'
.
'
1
)
;
return
mozilla
:
:
Some
(
H264Setting
{
val
str
}
)
;
}
#
if
LIBAVCODEC_VERSION_MAJOR
<
54
using
FFmpegPixelFormat
=
enum
PixelFormat
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_NONE
=
FFmpegPixelFormat
:
:
PIX_FMT_NONE
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_RGBA
=
FFmpegPixelFormat
:
:
PIX_FMT_RGBA
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_BGRA
=
FFmpegPixelFormat
:
:
PIX_FMT_BGRA
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_RGB24
=
FFmpegPixelFormat
:
:
PIX_FMT_RGB24
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_BGR24
=
FFmpegPixelFormat
:
:
PIX_FMT_BGR24
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_YUV444P
=
FFmpegPixelFormat
:
:
PIX_FMT_YUV444P
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_YUV422P
=
FFmpegPixelFormat
:
:
PIX_FMT_YUV422P
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_YUV420P
=
FFmpegPixelFormat
:
:
PIX_FMT_YUV420P
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_NV12
=
FFmpegPixelFormat
:
:
PIX_FMT_NV12
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_NV21
=
FFmpegPixelFormat
:
:
PIX_FMT_NV21
;
#
else
using
FFmpegPixelFormat
=
enum
AVPixelFormat
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_NONE
=
FFmpegPixelFormat
:
:
AV_PIX_FMT_NONE
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_RGBA
=
FFmpegPixelFormat
:
:
AV_PIX_FMT_RGBA
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_BGRA
=
FFmpegPixelFormat
:
:
AV_PIX_FMT_BGRA
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_RGB24
=
FFmpegPixelFormat
:
:
AV_PIX_FMT_RGB24
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_BGR24
=
FFmpegPixelFormat
:
:
AV_PIX_FMT_BGR24
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_YUV444P
=
FFmpegPixelFormat
:
:
AV_PIX_FMT_YUV444P
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_YUV422P
=
FFmpegPixelFormat
:
:
AV_PIX_FMT_YUV422P
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_YUV420P
=
FFmpegPixelFormat
:
:
AV_PIX_FMT_YUV420P
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_NV12
=
FFmpegPixelFormat
:
:
AV_PIX_FMT_NV12
;
const
FFmpegPixelFormat
FFMPEG_PIX_FMT_NV21
=
FFmpegPixelFormat
:
:
AV_PIX_FMT_NV21
;
#
endif
static
const
char
*
GetPixelFormatString
(
FFmpegPixelFormat
aFormat
)
{
switch
(
aFormat
)
{
case
FFMPEG_PIX_FMT_NONE
:
return
"
none
"
;
case
FFMPEG_PIX_FMT_RGBA
:
return
"
packed
RGBA
8
:
8
:
8
:
8
(
32bpp
RGBARGBA
.
.
.
)
"
;
case
FFMPEG_PIX_FMT_BGRA
:
return
"
packed
BGRA
8
:
8
:
8
:
8
(
32bpp
BGRABGRA
.
.
.
)
"
;
case
FFMPEG_PIX_FMT_RGB24
:
return
"
packed
RGB
8
:
8
:
8
(
24bpp
RGBRGB
.
.
.
)
"
;
case
FFMPEG_PIX_FMT_BGR24
:
return
"
packed
RGB
8
:
8
:
8
(
24bpp
BGRBGR
.
.
.
)
"
;
case
FFMPEG_PIX_FMT_YUV444P
:
return
"
planar
YUV
4
:
4
:
4
(
24bpp
1
Cr
&
Cb
sample
per
1x1
Y
samples
)
"
;
case
FFMPEG_PIX_FMT_YUV422P
:
return
"
planar
YUV
4
:
2
:
2
(
16bpp
1
Cr
&
Cb
sample
per
2x1
Y
samples
)
"
;
case
FFMPEG_PIX_FMT_YUV420P
:
return
"
planar
YUV
4
:
2
:
0
(
12bpp
1
Cr
&
Cb
sample
per
2x2
Y
samples
)
"
;
case
FFMPEG_PIX_FMT_NV12
:
return
"
planar
YUV
4
:
2
:
0
(
12bpp
1
interleaved
UV
components
per
1x1
Y
"
"
samples
)
"
;
case
FFMPEG_PIX_FMT_NV21
:
return
"
planar
YUV
4
:
2
:
0
(
12bpp
1
interleaved
VU
components
per
1x1
Y
"
"
samples
)
"
;
default
:
break
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
pixel
format
"
)
;
return
"
unsupported
"
;
}
}
;
namespace
mozilla
{
static
nsCString
MakeErrorString
(
const
FFmpegLibWrapper
*
aLib
int
aErrNum
)
{
MOZ_ASSERT
(
aLib
)
;
char
errStr
[
ffmpeg
:
:
FFmpegErrorMaxStringSize
]
;
aLib
-
>
av_strerror
(
aErrNum
errStr
ffmpeg
:
:
FFmpegErrorMaxStringSize
)
;
return
nsCString
(
errStr
)
;
}
template
<
>
AVCodecID
GetFFmpegEncoderCodecId
<
LIBAV_VER
>
(
CodecType
aCodec
)
{
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
58
if
(
aCodec
=
=
CodecType
:
:
VP8
)
{
return
AV_CODEC_ID_VP8
;
}
if
(
aCodec
=
=
CodecType
:
:
VP9
)
{
return
AV_CODEC_ID_VP9
;
}
#
if
!
defined
(
USING_MOZFFVPX
)
if
(
aCodec
=
=
CodecType
:
:
H264
)
{
return
AV_CODEC_ID_H264
;
}
#
endif
if
(
aCodec
=
=
CodecType
:
:
AV1
)
{
return
AV_CODEC_ID_AV1
;
}
#
endif
return
AV_CODEC_ID_NONE
;
}
StaticMutex
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
sMutex
;
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
FFmpegVideoEncoder
(
const
FFmpegLibWrapper
*
aLib
AVCodecID
aCodecID
const
RefPtr
<
TaskQueue
>
&
aTaskQueue
const
EncoderConfig
&
aConfig
)
:
mLib
(
aLib
)
mCodecID
(
aCodecID
)
mTaskQueue
(
aTaskQueue
)
mConfig
(
aConfig
)
mCodecContext
(
nullptr
)
mFrame
(
nullptr
)
{
MOZ_ASSERT
(
mLib
)
;
MOZ_ASSERT
(
mTaskQueue
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
<
58
MOZ_CRASH
(
"
FFmpegVideoEncoder
needs
ffmpeg
58
at
least
.
"
)
;
#
endif
}
;
RefPtr
<
MediaDataEncoder
:
:
InitPromise
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
Init
(
)
{
FFMPEGV_LOG
(
"
Init
"
)
;
return
InvokeAsync
(
mTaskQueue
this
__func__
&
FFmpegVideoEncoder
:
:
ProcessInit
)
;
}
RefPtr
<
MediaDataEncoder
:
:
EncodePromise
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
Encode
(
const
MediaData
*
aSample
)
{
MOZ_ASSERT
(
aSample
!
=
nullptr
)
;
FFMPEGV_LOG
(
"
Encode
"
)
;
return
InvokeAsync
(
mTaskQueue
__func__
[
self
=
RefPtr
<
FFmpegVideoEncoder
<
LIBAV_VER
>
>
(
this
)
sample
=
RefPtr
<
const
MediaData
>
(
aSample
)
]
(
)
{
return
self
-
>
ProcessEncode
(
std
:
:
move
(
sample
)
)
;
}
)
;
}
RefPtr
<
MediaDataEncoder
:
:
ReconfigurationPromise
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
Reconfigure
(
const
RefPtr
<
const
EncoderConfigurationChangeList
>
&
aConfigurationChanges
)
{
return
InvokeAsync
<
const
RefPtr
<
const
EncoderConfigurationChangeList
>
>
(
mTaskQueue
this
__func__
&
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
ProcessReconfigure
aConfigurationChanges
)
;
}
RefPtr
<
MediaDataEncoder
:
:
EncodePromise
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
Drain
(
)
{
FFMPEGV_LOG
(
"
Drain
"
)
;
return
InvokeAsync
(
mTaskQueue
this
__func__
&
FFmpegVideoEncoder
:
:
ProcessDrain
)
;
}
RefPtr
<
ShutdownPromise
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
Shutdown
(
)
{
FFMPEGV_LOG
(
"
Shutdown
"
)
;
return
InvokeAsync
(
mTaskQueue
this
__func__
&
FFmpegVideoEncoder
:
:
ProcessShutdown
)
;
}
RefPtr
<
GenericPromise
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
SetBitrate
(
uint32_t
aBitrate
)
{
FFMPEGV_LOG
(
"
SetBitrate
"
)
;
return
GenericPromise
:
:
CreateAndReject
(
NS_ERROR_NOT_IMPLEMENTED
__func__
)
;
}
nsCString
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
GetDescriptionName
(
)
const
{
#
ifdef
USING_MOZFFVPX
return
"
ffvpx
video
encoder
"
_ns
;
#
else
const
char
*
lib
=
#
if
defined
(
MOZ_FFMPEG
)
FFmpegRuntimeLinker
:
:
LinkStatusLibraryName
(
)
;
#
else
"
no
library
:
ffmpeg
disabled
during
build
"
;
#
endif
return
nsPrintfCString
(
"
ffmpeg
video
encoder
(
%
s
)
"
lib
)
;
#
endif
}
RefPtr
<
MediaDataEncoder
:
:
InitPromise
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
ProcessInit
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEGV_LOG
(
"
ProcessInit
"
)
;
MediaResult
r
=
InitInternal
(
)
;
return
NS_FAILED
(
r
)
?
InitPromise
:
:
CreateAndReject
(
r
__func__
)
:
InitPromise
:
:
CreateAndResolve
(
TrackInfo
:
:
kVideoTrack
__func__
)
;
}
RefPtr
<
MediaDataEncoder
:
:
EncodePromise
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
ProcessEncode
(
RefPtr
<
const
MediaData
>
aSample
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEGV_LOG
(
"
ProcessEncode
"
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
<
58
MOZ_CRASH
(
"
FFmpegVideoEncoder
needs
ffmpeg
58
at
least
.
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
NS_ERROR_NOT_IMPLEMENTED
__func__
)
;
#
else
RefPtr
<
const
VideoData
>
sample
(
aSample
-
>
As
<
const
VideoData
>
(
)
)
;
MOZ_ASSERT
(
sample
)
;
return
EncodeWithModernAPIs
(
sample
)
;
#
endif
}
RefPtr
<
MediaDataEncoder
:
:
ReconfigurationPromise
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
ProcessReconfigure
(
const
RefPtr
<
const
EncoderConfigurationChangeList
>
aConfigurationChanges
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEGV_LOG
(
"
ProcessReconfigure
"
)
;
using
P
=
MediaDataEncoder
:
:
ReconfigurationPromise
;
return
P
:
:
CreateAndReject
(
NS_ERROR_NOT_IMPLEMENTED
__func__
)
;
}
RefPtr
<
MediaDataEncoder
:
:
EncodePromise
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
ProcessDrain
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEGV_LOG
(
"
ProcessDrain
"
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
<
58
MOZ_CRASH
(
"
FFmpegVideoEncoder
needs
ffmpeg
58
at
least
.
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
NS_ERROR_NOT_IMPLEMENTED
__func__
)
;
#
else
return
DrainWithModernAPIs
(
)
;
#
endif
}
RefPtr
<
ShutdownPromise
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
ProcessShutdown
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEGV_LOG
(
"
ProcessShutdown
"
)
;
ShutdownInternal
(
)
;
return
ShutdownPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
MediaResult
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
InitInternal
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEGV_LOG
(
"
InitInternal
"
)
;
if
(
mCodecID
=
=
AV_CODEC_ID_H264
)
{
if
(
!
mConfig
.
mCodecSpecific
|
|
!
mConfig
.
mCodecSpecific
-
>
is
<
H264Specific
>
(
)
)
{
return
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
Unable
to
get
H264
necessary
encoding
info
"
)
)
;
}
}
AVCodec
*
codec
=
mLib
-
>
avcodec_find_encoder
(
mCodecID
)
;
if
(
!
codec
)
{
FFMPEGV_LOG
(
"
failed
to
find
ffmpeg
encoder
for
codec
id
%
d
"
mCodecID
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
Unable
to
find
codec
"
)
)
;
}
FFMPEGV_LOG
(
"
find
codec
:
%
s
"
codec
-
>
name
)
;
ForceEnablingFFmpegDebugLogs
(
)
;
MOZ_ASSERT
(
!
mCodecContext
)
;
if
(
!
(
mCodecContext
=
mLib
-
>
avcodec_alloc_context3
(
codec
)
)
)
{
FFMPEGV_LOG
(
"
failed
to
allocate
ffmpeg
context
for
codec
%
s
"
codec
-
>
name
)
;
return
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
Failed
to
initialize
ffmpeg
context
"
)
)
;
}
mCodecContext
-
>
pix_fmt
=
ffmpeg
:
:
FFMPEG_PIX_FMT_YUV420P
;
mCodecContext
-
>
bit_rate
=
static_cast
<
ffmpeg
:
:
FFmpegBitRate
>
(
mConfig
.
mBitrate
)
;
mCodecContext
-
>
width
=
static_cast
<
int
>
(
mConfig
.
mSize
.
width
)
;
mCodecContext
-
>
height
=
static_cast
<
int
>
(
mConfig
.
mSize
.
height
)
;
if
(
mConfig
.
mFramerate
)
{
mCodecContext
-
>
time_base
=
AVRational
{
.
num
=
1
.
den
=
static_cast
<
int
>
(
mConfig
.
mFramerate
)
}
;
}
else
{
mCodecContext
-
>
time_base
=
AVRational
{
.
num
=
1
.
den
=
90000
}
;
}
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
57
mCodecContext
-
>
framerate
=
AVRational
{
.
num
=
static_cast
<
int
>
(
mConfig
.
mFramerate
)
.
den
=
1
}
;
#
endif
mCodecContext
-
>
gop_size
=
static_cast
<
int
>
(
mConfig
.
mKeyframeInterval
)
;
if
(
mConfig
.
mUsage
=
=
MediaDataEncoder
:
:
Usage
:
:
Realtime
)
{
mLib
-
>
av_opt_set
(
mCodecContext
-
>
priv_data
"
deadline
"
"
realtime
"
0
)
;
mLib
-
>
av_opt_set
(
mCodecContext
-
>
priv_data
"
lag
-
in
-
frames
"
"
0
"
0
)
;
}
nsCString
codecSpecificLog
;
if
(
mConfig
.
mCodecSpecific
)
{
if
(
mConfig
.
mCodecSpecific
-
>
is
<
H264Specific
>
(
)
)
{
codecSpecificLog
.
Append
(
"
H264
:
"
)
;
const
H264Specific
&
specific
=
mConfig
.
mCodecSpecific
-
>
as
<
H264Specific
>
(
)
;
Maybe
<
ffmpeg
:
:
H264Setting
>
profile
=
ffmpeg
:
:
GetH264Profile
(
specific
.
mProfile
)
;
if
(
!
profile
)
{
FFMPEGV_LOG
(
"
failed
to
get
h264
profile
"
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR
RESULT_DETAIL
(
"
H264
profile
is
unknown
"
)
)
;
}
codecSpecificLog
.
Append
(
nsPrintfCString
(
"
profile
-
%
d
"
profile
-
>
mValue
)
)
;
mCodecContext
-
>
profile
=
profile
-
>
mValue
;
if
(
!
profile
-
>
mString
.
IsEmpty
(
)
)
{
codecSpecificLog
.
Append
(
nsPrintfCString
(
"
(
%
s
)
"
profile
-
>
mString
.
get
(
)
)
)
;
mLib
-
>
av_opt_set
(
mCodecContext
-
>
priv_data
"
profile
"
profile
-
>
mString
.
get
(
)
0
)
;
}
Maybe
<
ffmpeg
:
:
H264Setting
>
level
=
ffmpeg
:
:
GetH264Level
(
specific
.
mLevel
)
;
if
(
!
level
)
{
FFMPEGV_LOG
(
"
failed
to
get
h264
level
"
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR
RESULT_DETAIL
(
"
H264
level
is
unknown
"
)
)
;
}
codecSpecificLog
.
Append
(
nsPrintfCString
(
"
level
%
d
(
%
s
)
"
level
-
>
mValue
level
-
>
mString
.
get
(
)
)
)
;
mCodecContext
-
>
level
=
level
-
>
mValue
;
MOZ_ASSERT
(
!
level
-
>
mString
.
IsEmpty
(
)
)
;
mLib
-
>
av_opt_set
(
mCodecContext
-
>
priv_data
"
level
"
level
-
>
mString
.
get
(
)
0
)
;
if
(
specific
.
mFormat
=
=
H264BitStreamFormat
:
:
AVC
)
{
codecSpecificLog
.
Append
(
"
AVCC
"
)
;
mLib
-
>
av_opt_set
(
mCodecContext
-
>
priv_data
"
x264
-
params
"
"
annexb
=
0
"
0
)
;
}
else
{
codecSpecificLog
.
Append
(
"
AnnexB
"
)
;
mLib
-
>
av_opt_set
(
mCodecContext
-
>
priv_data
"
x264
-
params
"
"
annexb
=
1
"
0
)
;
}
}
}
AVDictionary
*
options
=
nullptr
;
if
(
int
ret
=
OpenCodecContext
(
codec
&
options
)
;
ret
<
0
)
{
FFMPEGV_LOG
(
"
failed
to
open
%
s
avcodec
:
%
s
"
codec
-
>
name
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
Unable
to
open
avcodec
"
)
)
;
}
mLib
-
>
av_dict_free
(
&
options
)
;
FFMPEGV_LOG
(
"
%
s
has
been
initialized
with
format
:
%
s
bitrate
:
%
"
PRIi64
"
width
:
%
d
height
:
%
d
time_base
:
%
d
/
%
d
%
s
"
codec
-
>
name
ffmpeg
:
:
GetPixelFormatString
(
mCodecContext
-
>
pix_fmt
)
static_cast
<
int64_t
>
(
mCodecContext
-
>
bit_rate
)
mCodecContext
-
>
width
mCodecContext
-
>
height
mCodecContext
-
>
time_base
.
num
mCodecContext
-
>
time_base
.
den
codecSpecificLog
.
IsEmpty
(
)
?
"
"
:
codecSpecificLog
.
get
(
)
)
;
return
MediaResult
(
NS_OK
)
;
}
void
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
ShutdownInternal
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEGV_LOG
(
"
ShutdownInternal
"
)
;
DestroyFrame
(
)
;
if
(
mCodecContext
)
{
CloseCodecContext
(
)
;
mLib
-
>
av_freep
(
&
mCodecContext
)
;
mCodecContext
=
nullptr
;
}
}
int
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
OpenCodecContext
(
const
AVCodec
*
aCodec
AVDictionary
*
*
aOptions
)
{
MOZ_ASSERT
(
mCodecContext
)
;
StaticMutexAutoLock
mon
(
sMutex
)
;
mCodecContext
-
>
strict_std_compliance
=
-
2
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
60
mCodecContext
-
>
flags
|
=
AV_CODEC_FLAG_FRAME_DURATION
;
#
endif
return
mLib
-
>
avcodec_open2
(
mCodecContext
aCodec
aOptions
)
;
}
void
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
CloseCodecContext
(
)
{
MOZ_ASSERT
(
mCodecContext
)
;
StaticMutexAutoLock
mon
(
sMutex
)
;
mLib
-
>
avcodec_close
(
mCodecContext
)
;
}
bool
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
PrepareFrame
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
55
if
(
mFrame
)
{
mLib
-
>
av_frame_unref
(
mFrame
)
;
}
else
{
mFrame
=
mLib
-
>
av_frame_alloc
(
)
;
}
#
elif
LIBAVCODEC_VERSION_MAJOR
=
=
54
if
(
mFrame
)
{
mLib
-
>
avcodec_get_frame_defaults
(
mFrame
)
;
}
else
{
mFrame
=
mLib
-
>
avcodec_alloc_frame
(
)
;
}
#
else
mLib
-
>
av_freep
(
&
mFrame
)
;
mFrame
=
mLib
-
>
avcodec_alloc_frame
(
)
;
#
endif
return
!
!
mFrame
;
}
void
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
DestroyFrame
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
if
(
mFrame
)
{
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
55
mLib
-
>
av_frame_unref
(
mFrame
)
;
mLib
-
>
av_frame_free
(
&
mFrame
)
;
#
elif
LIBAVCODEC_VERSION_MAJOR
=
=
54
mLib
-
>
avcodec_free_frame
(
&
mFrame
)
;
#
else
mLib
-
>
av_freep
(
&
mFrame
)
;
#
endif
mFrame
=
nullptr
;
}
}
bool
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
ScaleInputFrame
(
)
{
AVFrame
*
source
=
mFrame
;
mFrame
=
nullptr
;
if
(
!
PrepareFrame
(
)
)
{
FFMPEGV_LOG
(
"
failed
to
allocate
frame
"
)
;
return
false
;
}
mFrame
-
>
format
=
AV_PIX_FMT_YUV420P
;
mFrame
-
>
width
=
static_cast
<
int
>
(
mConfig
.
mSize
.
Width
(
)
)
;
mFrame
-
>
height
=
static_cast
<
int
>
(
mConfig
.
mSize
.
Height
(
)
)
;
if
(
int
ret
=
mLib
-
>
av_frame_get_buffer
(
mFrame
16
)
;
ret
<
0
)
{
FFMPEGV_LOG
(
"
failed
to
allocate
frame
data
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
false
;
}
if
(
int
ret
=
mLib
-
>
av_frame_make_writable
(
mFrame
)
;
ret
<
0
)
{
FFMPEGV_LOG
(
"
failed
to
make
frame
writable
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
false
;
}
int
rv
=
I420Scale
(
source
-
>
data
[
0
]
source
-
>
linesize
[
0
]
source
-
>
data
[
1
]
source
-
>
linesize
[
1
]
source
-
>
data
[
2
]
source
-
>
linesize
[
2
]
source
-
>
width
source
-
>
height
mFrame
-
>
data
[
0
]
mFrame
-
>
linesize
[
0
]
mFrame
-
>
data
[
1
]
mFrame
-
>
linesize
[
1
]
mFrame
-
>
data
[
2
]
mFrame
-
>
linesize
[
2
]
mFrame
-
>
width
mFrame
-
>
height
libyuv
:
:
FilterMode
:
:
kFilterBox
)
;
if
(
!
rv
)
{
FFMPEGV_LOG
(
"
YUV
scale
error
"
)
;
}
mLib
-
>
av_frame_unref
(
source
)
;
mLib
-
>
av_frame_free
(
&
source
)
;
return
true
;
}
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
58
RefPtr
<
MediaDataEncoder
:
:
EncodePromise
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
EncodeWithModernAPIs
(
RefPtr
<
const
VideoData
>
aSample
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
mCodecContext
)
;
MOZ_ASSERT
(
aSample
)
;
if
(
!
aSample
-
>
mImage
)
{
FFMPEGV_LOG
(
"
No
image
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_ILLEGAL_INPUT
RESULT_DETAIL
(
"
No
image
in
sample
"
)
)
__func__
)
;
}
else
if
(
aSample
-
>
mImage
-
>
GetSize
(
)
.
IsEmpty
(
)
)
{
FFMPEGV_LOG
(
"
image
width
or
height
is
invalid
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_ILLEGAL_INPUT
RESULT_DETAIL
(
"
Invalid
image
size
"
)
)
__func__
)
;
}
if
(
!
PrepareFrame
(
)
)
{
FFMPEGV_LOG
(
"
failed
to
allocate
frame
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
Unable
to
allocate
frame
"
)
)
__func__
)
;
}
mFrame
-
>
format
=
ffmpeg
:
:
FFMPEG_PIX_FMT_YUV420P
;
mFrame
-
>
width
=
static_cast
<
int
>
(
aSample
-
>
mImage
-
>
GetSize
(
)
.
width
)
;
mFrame
-
>
height
=
static_cast
<
int
>
(
aSample
-
>
mImage
-
>
GetSize
(
)
.
height
)
;
if
(
int
ret
=
mLib
-
>
av_frame_get_buffer
(
mFrame
0
)
;
ret
<
0
)
{
FFMPEGV_LOG
(
"
failed
to
allocate
frame
data
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
Unable
to
allocate
frame
data
"
)
)
__func__
)
;
}
if
(
int
ret
=
mLib
-
>
av_frame_make_writable
(
mFrame
)
;
ret
<
0
)
{
FFMPEGV_LOG
(
"
failed
to
make
frame
writable
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_NOT_AVAILABLE
RESULT_DETAIL
(
"
Unable
to
make
frame
writable
"
)
)
__func__
)
;
}
nsresult
rv
=
ConvertToI420
(
aSample
-
>
mImage
mFrame
-
>
data
[
0
]
mFrame
-
>
linesize
[
0
]
mFrame
-
>
data
[
1
]
mFrame
-
>
linesize
[
1
]
mFrame
-
>
data
[
2
]
mFrame
-
>
linesize
[
2
]
)
;
if
(
NS_FAILED
(
rv
)
)
{
FFMPEGV_LOG
(
"
Conversion
error
!
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_ILLEGAL_INPUT
RESULT_DETAIL
(
"
libyuv
conversion
error
"
)
)
__func__
)
;
}
if
(
mFrame
-
>
width
!
=
mConfig
.
mSize
.
Width
(
)
|
|
mFrame
-
>
height
!
=
mConfig
.
mSize
.
Height
(
)
)
{
if
(
!
ScaleInputFrame
(
)
)
{
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
libyuv
scaling
error
"
)
)
__func__
)
;
}
}
mFrame
-
>
pts
=
aSample
-
>
mTime
.
ToMicroseconds
(
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
60
mFrame
-
>
duration
=
aSample
-
>
mDuration
.
ToMicroseconds
(
)
;
mFrame
-
>
pkt_duration
=
aSample
-
>
mDuration
.
ToMicroseconds
(
)
;
#
else
mFrame
-
>
pkt_duration
=
aSample
-
>
mDuration
.
ToMicroseconds
(
)
;
#
endif
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
59
mFrame
-
>
time_base
=
{
1
USECS_PER_S
}
;
#
endif
AVPacket
*
pkt
=
mLib
-
>
av_packet_alloc
(
)
;
if
(
!
pkt
)
{
FFMPEGV_LOG
(
"
failed
to
allocate
packet
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
Unable
to
allocate
packet
"
)
)
__func__
)
;
}
auto
freePacket
=
MakeScopeExit
(
[
this
&
pkt
]
{
mLib
-
>
av_packet_free
(
&
pkt
)
;
}
)
;
if
(
int
ret
=
mLib
-
>
avcodec_send_frame
(
mCodecContext
mFrame
)
;
ret
<
0
)
{
FFMPEGV_LOG
(
"
avcodec_send_frame
error
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
avcodec_send_frame
error
"
)
)
__func__
)
;
}
EncodedData
output
;
while
(
true
)
{
int
ret
=
mLib
-
>
avcodec_receive_packet
(
mCodecContext
pkt
)
;
if
(
ret
=
=
AVERROR
(
EAGAIN
)
)
{
FFMPEGV_LOG
(
"
encoder
is
asking
for
more
input
!
"
)
;
break
;
}
if
(
ret
<
0
)
{
FFMPEGV_LOG
(
"
avcodec_receive_packet
error
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
avcodec_receive_packet
error
"
)
)
__func__
)
;
}
RefPtr
<
MediaRawData
>
d
=
ToMediaRawData
(
pkt
)
;
mLib
-
>
av_packet_unref
(
pkt
)
;
if
(
!
d
)
{
FFMPEGV_LOG
(
"
failed
to
create
a
MediaRawData
from
the
AVPacket
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
Unable
to
get
MediaRawData
from
AVPacket
"
)
)
__func__
)
;
}
output
.
AppendElement
(
std
:
:
move
(
d
)
)
;
}
FFMPEGV_LOG
(
"
get
%
zu
encoded
data
"
output
.
Length
(
)
)
;
return
EncodePromise
:
:
CreateAndResolve
(
std
:
:
move
(
output
)
__func__
)
;
}
RefPtr
<
MediaDataEncoder
:
:
EncodePromise
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
DrainWithModernAPIs
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
mCodecContext
)
;
AVPacket
*
pkt
=
mLib
-
>
av_packet_alloc
(
)
;
if
(
!
pkt
)
{
FFMPEGV_LOG
(
"
failed
to
allocate
packet
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
Unable
to
allocate
packet
"
)
)
__func__
)
;
}
auto
freePacket
=
MakeScopeExit
(
[
this
&
pkt
]
{
mLib
-
>
av_packet_free
(
&
pkt
)
;
}
)
;
if
(
int
ret
=
mLib
-
>
avcodec_send_frame
(
mCodecContext
nullptr
)
;
ret
<
0
)
{
if
(
ret
=
=
AVERROR_EOF
)
{
FFMPEGV_LOG
(
"
encoder
has
been
flushed
!
"
)
;
return
EncodePromise
:
:
CreateAndResolve
(
EncodedData
(
)
__func__
)
;
}
FFMPEGV_LOG
(
"
avcodec_send_frame
error
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
avcodec_send_frame
error
"
)
)
__func__
)
;
}
EncodedData
output
;
while
(
true
)
{
int
ret
=
mLib
-
>
avcodec_receive_packet
(
mCodecContext
pkt
)
;
if
(
ret
=
=
AVERROR_EOF
)
{
FFMPEGV_LOG
(
"
encoder
has
no
more
output
packet
!
"
)
;
break
;
}
if
(
ret
<
0
)
{
FFMPEGV_LOG
(
"
avcodec_receive_packet
error
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
avcodec_receive_packet
error
"
)
)
__func__
)
;
}
RefPtr
<
MediaRawData
>
d
=
ToMediaRawData
(
pkt
)
;
mLib
-
>
av_packet_unref
(
pkt
)
;
if
(
!
d
)
{
FFMPEGV_LOG
(
"
failed
to
create
a
MediaRawData
from
the
AVPacket
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
Unable
to
get
MediaRawData
from
AVPacket
"
)
)
__func__
)
;
}
output
.
AppendElement
(
std
:
:
move
(
d
)
)
;
}
FFMPEGV_LOG
(
"
get
%
zu
encoded
data
"
output
.
Length
(
)
)
;
ShutdownInternal
(
)
;
MediaResult
r
=
InitInternal
(
)
;
return
NS_FAILED
(
r
)
?
EncodePromise
:
:
CreateAndReject
(
r
__func__
)
:
EncodePromise
:
:
CreateAndResolve
(
std
:
:
move
(
output
)
__func__
)
;
}
#
endif
RefPtr
<
MediaRawData
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
ToMediaRawData
(
AVPacket
*
aPacket
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
aPacket
)
;
auto
data
=
MakeRefPtr
<
MediaRawData
>
(
)
;
UniquePtr
<
MediaRawDataWriter
>
writer
(
data
-
>
CreateWriter
(
)
)
;
if
(
!
writer
-
>
Append
(
aPacket
-
>
data
static_cast
<
size_t
>
(
aPacket
-
>
size
)
)
)
{
FFMPEGV_LOG
(
"
fail
to
allocate
MediaRawData
buffer
"
)
;
return
nullptr
;
}
data
-
>
mKeyframe
=
(
aPacket
-
>
flags
&
AV_PKT_FLAG_KEY
)
!
=
0
;
data
-
>
mTime
=
media
:
:
TimeUnit
:
:
FromMicroseconds
(
aPacket
-
>
pts
)
;
data
-
>
mDuration
=
media
:
:
TimeUnit
:
:
FromMicroseconds
(
aPacket
-
>
duration
)
;
data
-
>
mTimecode
=
media
:
:
TimeUnit
:
:
FromMicroseconds
(
aPacket
-
>
dts
)
;
return
data
;
}
Result
<
already_AddRefed
<
MediaByteBuffer
>
nsresult
>
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
GetExtraData
(
AVPacket
*
aPacket
)
{
MOZ_ASSERT
(
aPacket
)
;
if
(
mCodecID
!
=
AV_CODEC_ID_H264
|
|
!
mConfig
.
mCodecSpecific
|
|
!
mConfig
.
mCodecSpecific
-
>
is
<
H264Specific
>
(
)
|
|
mConfig
.
mCodecSpecific
-
>
as
<
H264Specific
>
(
)
.
mFormat
!
=
H264BitStreamFormat
:
:
AVC
|
|
!
(
aPacket
-
>
flags
&
AV_PKT_FLAG_KEY
)
)
{
return
Err
(
NS_ERROR_NOT_AVAILABLE
)
;
}
bool
useGlobalHeader
=
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
57
mCodecContext
-
>
flags
&
AV_CODEC_FLAG_GLOBAL_HEADER
;
#
else
false
;
#
endif
Span
<
const
uint8_t
>
buf
;
if
(
useGlobalHeader
)
{
buf
=
Span
<
const
uint8_t
>
(
mCodecContext
-
>
extradata
static_cast
<
size_t
>
(
mCodecContext
-
>
extradata_size
)
)
;
}
else
{
buf
=
Span
<
const
uint8_t
>
(
aPacket
-
>
data
static_cast
<
size_t
>
(
aPacket
-
>
size
)
)
;
}
if
(
buf
.
empty
(
)
)
{
FFMPEGV_LOG
(
"
fail
to
get
H264
AVCC
header
in
key
frame
!
"
)
;
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
BufferReader
reader
(
buf
)
;
uint32_t
spsSize
;
MOZ_TRY_VAR
(
spsSize
reader
.
ReadU32
(
)
)
;
Span
<
const
uint8_t
>
spsData
;
MOZ_TRY_VAR
(
spsData
reader
.
ReadSpan
<
const
uint8_t
>
(
static_cast
<
size_t
>
(
spsSize
)
)
)
;
uint32_t
ppsSize
;
MOZ_TRY_VAR
(
ppsSize
reader
.
ReadU32
(
)
)
;
Span
<
const
uint8_t
>
ppsData
;
MOZ_TRY_VAR
(
ppsData
reader
.
ReadSpan
<
const
uint8_t
>
(
static_cast
<
size_t
>
(
ppsSize
)
)
)
;
if
(
spsData
.
Length
(
)
<
4
)
{
return
Err
(
NS_ERROR_NOT_AVAILABLE
)
;
}
FFMPEGV_LOG
(
"
Generate
extra
data
:
profile
-
%
u
constraints
:
%
u
level
:
%
u
for
pts
"
"
%
"
PRId64
spsData
[
1
]
spsData
[
2
]
spsData
[
3
]
aPacket
-
>
pts
)
;
auto
extraData
=
MakeRefPtr
<
MediaByteBuffer
>
(
)
;
H264
:
:
WriteExtraData
(
extraData
spsData
[
1
]
spsData
[
2
]
spsData
[
3
]
spsData
ppsData
)
;
MOZ_ASSERT
(
extraData
)
;
return
extraData
.
forget
(
)
;
}
void
FFmpegVideoEncoder
<
LIBAV_VER
>
:
:
ForceEnablingFFmpegDebugLogs
(
)
{
#
if
DEBUG
if
(
!
getenv
(
"
MOZ_AV_LOG_LEVEL
"
)
&
&
MOZ_LOG_TEST
(
sFFmpegVideoLog
LogLevel
:
:
Debug
)
)
{
mLib
-
>
av_log_set_level
(
AV_LOG_DEBUG
)
;
}
#
endif
}
}
