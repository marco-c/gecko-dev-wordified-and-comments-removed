#
include
"
FFmpegAudioEncoder
.
h
"
#
include
"
FFmpegRuntimeLinker
.
h
"
#
include
"
FFmpegLog
.
h
"
#
include
"
FFmpegUtils
.
h
"
#
include
"
AudioSegment
.
h
"
namespace
mozilla
{
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
FFmpegAudioEncoder
(
const
FFmpegLibWrapper
*
aLib
AVCodecID
aCodecID
const
RefPtr
<
TaskQueue
>
&
aTaskQueue
const
EncoderConfig
&
aConfig
)
:
FFmpegDataEncoder
(
aLib
aCodecID
aTaskQueue
aConfig
)
{
}
nsCString
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
GetDescriptionName
(
)
const
{
#
ifdef
USING_MOZFFVPX
return
"
ffvpx
audio
encoder
"
_ns
;
#
else
const
char
*
lib
=
#
if
defined
(
MOZ_FFMPEG
)
FFmpegRuntimeLinker
:
:
LinkStatusLibraryName
(
)
;
#
else
"
no
library
:
ffmpeg
disabled
during
build
"
;
#
endif
return
nsPrintfCString
(
"
ffmpeg
audio
encoder
(
%
s
)
"
lib
)
;
#
endif
}
nsresult
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
InitSpecific
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEG_LOG
(
"
FFmpegAudioEncoder
:
:
InitInternal
"
)
;
AVCodec
*
codec
=
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
InitCommon
(
)
;
if
(
!
codec
)
{
FFMPEG_LOG
(
"
FFmpegDataEncoder
:
:
InitCommon
failed
"
)
;
return
NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR
;
}
mCodecContext
-
>
sample_rate
=
AssertedCast
<
int
>
(
mConfig
.
mSampleRate
)
;
mCodecContext
-
>
channels
=
AssertedCast
<
int
>
(
mConfig
.
mNumberOfChannels
)
;
switch
(
mConfig
.
mCodec
)
{
case
CodecType
:
:
Opus
:
mCodecContext
-
>
sample_fmt
=
AV_SAMPLE_FMT_FLT
;
break
;
case
CodecType
:
:
Vorbis
:
mCodecContext
-
>
sample_fmt
=
AV_SAMPLE_FMT_FLTP
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Not
supported
"
)
;
}
if
(
mConfig
.
mCodec
=
=
CodecType
:
:
Opus
)
{
if
(
mConfig
.
mBitrateMode
=
=
BitrateMode
:
:
Constant
)
{
mLib
-
>
av_opt_set
(
mCodecContext
-
>
priv_data
"
vbr
"
"
off
"
0
)
;
}
}
mCodecContext
-
>
time_base
=
AVRational
{
.
num
=
1
.
den
=
mCodecContext
-
>
sample_rate
}
;
nsAutoCString
codecSpecificLog
;
if
(
mConfig
.
mCodecSpecific
)
{
}
MediaResult
rv
=
FinishInitCommon
(
codec
)
;
if
(
NS_FAILED
(
rv
)
)
{
FFMPEG_LOG
(
"
FFmpeg
encode
initialization
failure
.
"
)
;
return
rv
.
Code
(
)
;
}
return
NS_OK
;
}
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
58
Result
<
MediaDataEncoder
:
:
EncodedData
nsresult
>
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
EncodeOnePacket
(
Span
<
float
>
aSamples
uint32_t
aChannels
uint32_t
aRate
media
:
:
TimeUnit
aPts
)
{
if
(
!
PrepareFrame
(
)
)
{
FFMPEG_LOG
(
"
failed
to
allocate
frame
"
)
;
return
Err
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
uint32_t
frameCount
=
aFrames
.
Length
(
)
/
aChannels
;
MOZ_ASSERT
(
AssertedCast
<
int
>
(
frameCount
)
<
=
mCodecContext
-
>
frame_size
)
;
mFrame
-
>
channels
=
AssertedCast
<
int
>
(
aChannels
)
;
mFrame
-
>
sample_rate
=
AssertedCast
<
int
>
(
aRate
)
;
mFrame
-
>
nb_samples
=
AssertedCast
<
int
>
(
frameCount
)
;
mFrame
-
>
format
=
mCodecContext
-
>
sample_fmt
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
59
mFrame
-
>
time_base
=
AVRational
{
.
num
=
1
.
den
=
static_cast
<
int
>
(
aRate
)
}
;
#
endif
mFrame
-
>
pts
=
aPts
.
ToTicksAtRate
(
aRate
)
;
mFrame
-
>
pkt_duration
=
frameCount
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
60
mFrame
-
>
duration
=
frameCount
;
#
else
mDurationMap
.
Insert
(
mFrame
-
>
pts
mFrame
-
>
pkt_duration
)
;
#
endif
if
(
int
ret
=
mLib
-
>
av_frame_get_buffer
(
mFrame
16
)
;
ret
<
0
)
{
FFMPEG_LOG
(
"
failed
to
allocate
frame
data
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
Err
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
if
(
int
ret
=
mLib
-
>
av_frame_make_writable
(
mFrame
)
;
ret
<
0
)
{
FFMPEG_LOG
(
"
failed
to
make
frame
writable
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
Err
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
)
;
}
if
(
mCodecContext
-
>
sample_fmt
=
=
AV_SAMPLE_FMT_FLT
)
{
PodCopy
(
reinterpret_cast
<
float
*
>
(
mFrame
-
>
data
[
0
]
)
aSamples
.
data
(
)
aSamples
.
Length
(
)
)
;
}
else
{
MOZ_ASSERT
(
mCodecContext
-
>
sample_fmt
=
=
AV_SAMPLE_FMT_FLTP
)
;
for
(
uint32_t
i
=
0
;
i
<
aChannels
;
i
+
+
)
{
DeinterleaveAndConvertBuffer
(
aSamples
.
data
(
)
mFrame
-
>
nb_samples
aChannels
mFrame
-
>
data
)
;
}
}
return
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
EncodeWithModernAPIs
(
)
;
}
Result
<
MediaDataEncoder
:
:
EncodedData
nsresult
>
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
EncodeInputWithModernAPIs
(
RefPtr
<
const
MediaData
>
aSample
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
mCodecContext
)
;
MOZ_ASSERT
(
aSample
)
;
RefPtr
<
const
AudioData
>
sample
(
aSample
-
>
As
<
AudioData
>
(
)
)
;
FFMPEG_LOG
(
"
Encoding
%
"
PRIu32
"
frames
of
audio
at
pts
:
%
s
"
sample
-
>
Frames
(
)
sample
-
>
mTime
.
ToString
(
)
.
get
(
)
)
;
if
(
sample
-
>
mRate
!
=
mConfig
.
mSampleRate
|
|
sample
-
>
mChannels
!
=
mConfig
.
mNumberOfChannels
)
{
FFMPEG_LOG
(
"
Rate
or
sample
-
rate
mismatch
at
the
input
of
the
audio
encoder
"
"
erroring
out
"
)
;
return
Result
<
MediaDataEncoder
:
:
EncodedData
nsresult
>
(
NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR
)
;
}
if
(
!
mPacketizer
)
{
media
:
:
TimeUnit
basePts
=
media
:
:
TimeUnit
:
:
Zero
(
mConfig
.
mSampleRate
)
;
basePts
+
=
sample
-
>
mTime
;
mPacketizer
.
emplace
(
mCodecContext
-
>
frame_size
sample
-
>
mChannels
basePts
.
ToTicksAtRate
(
mConfig
.
mSampleRate
)
mConfig
.
mSampleRate
)
;
}
if
(
!
mFirstPacketPts
.
IsValid
(
)
)
{
mFirstPacketPts
=
sample
-
>
mTime
;
}
EncodedData
output
;
MediaResult
rv
=
NS_OK
;
mPacketizer
-
>
Input
(
sample
-
>
Data
(
)
.
data
(
)
sample
-
>
Frames
(
)
)
;
while
(
mPacketizer
-
>
PacketsAvailable
(
)
&
&
rv
.
Code
(
)
=
=
NS_OK
)
{
mTempBuffer
.
SetLength
(
mCodecContext
-
>
frame_size
*
mConfig
.
mNumberOfChannels
)
;
media
:
:
TimeUnit
pts
=
mPacketizer
-
>
Output
(
mTempBuffer
.
Elements
(
)
)
;
auto
audio
=
Span
(
mTempBuffer
.
Elements
(
)
mTempBuffer
.
Length
(
)
)
;
FFMPEG_LOG
(
"
Encoding
%
"
PRIu32
"
frames
pts
:
%
s
"
mPacketizer
-
>
PacketSize
(
)
pts
.
ToString
(
)
.
get
(
)
)
;
auto
encodeResult
=
EncodeOnePacket
(
audio
pts
)
;
if
(
encodeResult
.
isOk
(
)
)
{
output
.
AppendElements
(
std
:
:
move
(
encodeResult
.
unwrap
(
)
)
)
;
}
else
{
return
encodeResult
;
}
pts
+
=
media
:
:
TimeUnit
(
mPacketizer
-
>
PacketSize
(
)
mConfig
.
mSampleRate
)
;
}
return
Result
<
MediaDataEncoder
:
:
EncodedData
nsresult
>
(
std
:
:
move
(
output
)
)
;
}
Result
<
MediaDataEncoder
:
:
EncodedData
nsresult
>
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
DrainWithModernAPIs
(
)
{
if
(
!
mPacketizer
|
|
mPacketizer
-
>
FramesAvailable
(
)
=
=
0
)
{
return
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
DrainWithModernAPIs
(
)
;
}
EncodedData
output
;
MediaResult
rv
=
NS_OK
;
mTempBuffer
.
SetLength
(
mCodecContext
-
>
frame_size
*
mPacketizer
-
>
ChannelCount
(
)
)
;
uint32_t
written
;
media
:
:
TimeUnit
pts
=
mPacketizer
-
>
Drain
(
mTempBuffer
.
Elements
(
)
written
)
;
auto
audio
=
Span
(
mTempBuffer
.
Elements
(
)
written
*
mPacketizer
-
>
ChannelCount
(
)
)
;
auto
encodeResult
=
EncodeOnePacket
(
audio
mPacketizer
-
>
ChannelCount
(
)
mConfig
.
mSampleRate
pts
)
;
if
(
encodeResult
.
isOk
(
)
)
{
auto
array
=
encodeResult
.
unwrap
(
)
;
output
.
AppendElements
(
std
:
:
move
(
array
)
)
;
}
else
{
return
encodeResult
;
}
auto
drainResult
=
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
DrainWithModernAPIs
(
)
;
if
(
drainResult
.
isOk
(
)
)
{
auto
array
=
drainResult
.
unwrap
(
)
;
output
.
AppendElements
(
std
:
:
move
(
array
)
)
;
}
else
{
return
drainResult
;
}
return
Result
<
MediaDataEncoder
:
:
EncodedData
nsresult
>
(
std
:
:
move
(
output
)
)
;
}
#
endif
RefPtr
<
MediaRawData
>
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
ToMediaRawData
(
AVPacket
*
aPacket
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
aPacket
)
;
RefPtr
<
MediaRawData
>
data
=
ToMediaRawDataCommon
(
aPacket
)
;
data
-
>
mTime
=
media
:
:
TimeUnit
(
aPacket
-
>
pts
mConfig
.
mSampleRate
)
;
data
-
>
mTimecode
=
data
-
>
mTime
;
data
-
>
mDuration
=
media
:
:
TimeUnit
(
mCodecContext
-
>
frame_size
mConfig
.
mSampleRate
)
;
if
(
mFirstPacketPts
>
data
-
>
mTime
)
{
data
-
>
mOriginalPresentationWindow
=
Some
(
media
:
:
TimeInterval
{
data
-
>
mTime
data
-
>
GetEndTime
(
)
}
)
;
data
-
>
mTime
=
mFirstPacketPts
;
}
if
(
auto
r
=
GetExtraData
(
aPacket
)
;
r
.
isOk
(
)
)
{
data
-
>
mExtraData
=
r
.
unwrap
(
)
;
}
if
(
data
-
>
mExtraData
)
{
FFMPEG_LOG
(
"
FFmpegAudioEncoder
out
:
[
%
s
%
s
]
(
%
zu
bytes
extradata
%
zu
bytes
)
"
data
-
>
mTime
.
ToString
(
)
.
get
(
)
data
-
>
mDuration
.
ToString
(
)
.
get
(
)
data
-
>
Size
(
)
data
-
>
mExtraData
-
>
Length
(
)
)
;
}
else
{
FFMPEG_LOG
(
"
FFmpegAudioEncoder
out
:
[
%
s
%
s
]
(
%
zu
bytes
)
"
data
-
>
mTime
.
ToString
(
)
.
get
(
)
data
-
>
mDuration
.
ToString
(
)
.
get
(
)
data
-
>
Size
(
)
)
;
}
return
data
;
}
Result
<
already_AddRefed
<
MediaByteBuffer
>
nsresult
>
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
GetExtraData
(
AVPacket
*
aPacket
)
{
MOZ_ASSERT
(
aPacket
)
;
auto
extraData
=
MakeRefPtr
<
MediaByteBuffer
>
(
)
;
extraData
-
>
SetLength
(
mCodecContext
-
>
extradata_size
)
;
MOZ_ASSERT
(
extraData
)
;
return
extraData
.
forget
(
)
;
}
}
