#
include
"
FFmpegAudioEncoder
.
h
"
#
include
"
FFmpegRuntimeLinker
.
h
"
#
include
"
FFmpegLog
.
h
"
#
include
"
FFmpegUtils
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
AudioSegment
.
h
"
namespace
mozilla
{
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
FFmpegAudioEncoder
(
const
FFmpegLibWrapper
*
aLib
AVCodecID
aCodecID
const
RefPtr
<
TaskQueue
>
&
aTaskQueue
const
EncoderConfig
&
aConfig
)
:
FFmpegDataEncoder
(
aLib
aCodecID
aTaskQueue
aConfig
)
{
}
nsCString
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
GetDescriptionName
(
)
const
{
#
ifdef
USING_MOZFFVPX
return
"
ffvpx
audio
encoder
"
_ns
;
#
else
const
char
*
lib
=
#
if
defined
(
MOZ_FFMPEG
)
FFmpegRuntimeLinker
:
:
LinkStatusLibraryName
(
)
;
#
else
"
no
library
:
ffmpeg
disabled
during
build
"
;
#
endif
return
nsPrintfCString
(
"
ffmpeg
audio
encoder
(
%
s
)
"
lib
)
;
#
endif
}
void
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
ResamplerDestroy
:
:
operator
(
)
(
SpeexResamplerState
*
aResampler
)
{
speex_resampler_destroy
(
aResampler
)
;
}
nsresult
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
InitSpecific
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEG_LOG
(
"
FFmpegAudioEncoder
:
:
InitInternal
"
)
;
AVCodec
*
codec
=
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
InitCommon
(
)
;
if
(
!
codec
)
{
FFMPEG_LOG
(
"
FFmpegDataEncoder
:
:
InitCommon
failed
"
)
;
return
NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR
;
}
mInputSampleRate
=
AssertedCast
<
int
>
(
mConfig
.
mSampleRate
)
;
if
(
codec
-
>
supported_samplerates
)
{
AutoTArray
<
int
16
>
supportedSampleRates
;
IterateZeroTerminated
(
codec
-
>
supported_samplerates
[
&
supportedSampleRates
]
(
int
aRate
)
mutable
{
supportedSampleRates
.
AppendElement
(
aRate
)
;
}
)
;
supportedSampleRates
.
Sort
(
)
;
for
(
const
auto
&
rate
:
supportedSampleRates
)
{
if
(
mInputSampleRate
=
=
rate
)
{
mConfig
.
mSampleRate
=
rate
;
break
;
}
if
(
mInputSampleRate
<
rate
)
{
mConfig
.
mSampleRate
=
rate
;
break
;
}
if
(
mInputSampleRate
>
rate
)
{
mConfig
.
mSampleRate
=
rate
;
}
}
}
if
(
mConfig
.
mSampleRate
!
=
AssertedCast
<
uint32_t
>
(
mInputSampleRate
)
)
{
int
err
;
SpeexResamplerState
*
resampler
=
speex_resampler_init
(
mConfig
.
mNumberOfChannels
mInputSampleRate
mConfig
.
mSampleRate
SPEEX_RESAMPLER_QUALITY_DEFAULT
&
err
)
;
if
(
!
err
)
{
mResampler
.
reset
(
resampler
)
;
}
else
{
FFMPEG_LOG
(
"
Error
creating
resampler
in
FFmpegAudioEncoder
%
dHz
-
>
%
dHz
(
%
dch
)
"
mInputSampleRate
mConfig
.
mSampleRate
mConfig
.
mNumberOfChannels
)
;
}
}
mCodecContext
-
>
sample_rate
=
AssertedCast
<
int
>
(
mConfig
.
mSampleRate
)
;
mCodecContext
-
>
channels
=
AssertedCast
<
int
>
(
mConfig
.
mNumberOfChannels
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
60
mLib
-
>
av_channel_layout_default
(
&
mCodecContext
-
>
ch_layout
AssertedCast
<
int
>
(
mCodecContext
-
>
channels
)
)
;
#
endif
switch
(
mConfig
.
mCodec
)
{
case
CodecType
:
:
Opus
:
mCodecContext
-
>
sample_fmt
=
AV_SAMPLE_FMT_FLT
;
break
;
case
CodecType
:
:
Vorbis
:
mCodecContext
-
>
sample_fmt
=
AV_SAMPLE_FMT_FLTP
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Not
supported
"
)
;
}
if
(
mConfig
.
mCodec
=
=
CodecType
:
:
Opus
)
{
if
(
mConfig
.
mBitrateMode
=
=
BitrateMode
:
:
Constant
)
{
mLib
-
>
av_opt_set
(
mCodecContext
-
>
priv_data
"
vbr
"
"
off
"
0
)
;
}
if
(
mConfig
.
mCodecSpecific
.
isSome
(
)
)
{
MOZ_ASSERT
(
mConfig
.
mCodecSpecific
-
>
is
<
OpusSpecific
>
(
)
)
;
const
OpusSpecific
&
specific
=
mConfig
.
mCodecSpecific
-
>
as
<
OpusSpecific
>
(
)
;
mCodecContext
-
>
compression_level
=
specific
.
mComplexity
;
FFMPEG_LOG
(
"
Opus
complexity
set
to
%
d
"
specific
.
mComplexity
)
;
float
frameDurationMs
=
AssertedCast
<
float
>
(
specific
.
mFrameDuration
)
/
1000
.
f
;
if
(
mLib
-
>
av_opt_set_double
(
mCodecContext
-
>
priv_data
"
frame_duration
"
frameDurationMs
0
)
)
{
FFMPEG_LOG
(
"
Error
setting
the
frame
duration
on
Opus
encoder
"
)
;
return
NS_ERROR_FAILURE
;
}
FFMPEG_LOG
(
"
Opus
frame
duration
set
to
%
0
.
2f
"
frameDurationMs
)
;
if
(
specific
.
mPacketLossPerc
)
{
if
(
mLib
-
>
av_opt_set_int
(
mCodecContext
-
>
priv_data
"
packet_loss
"
AssertedCast
<
int64_t
>
(
specific
.
mPacketLossPerc
)
0
)
)
{
FFMPEG_LOG
(
"
Error
setting
the
packet
loss
percentage
to
%
"
PRIu64
"
on
Opus
encoder
"
specific
.
mPacketLossPerc
)
;
return
NS_ERROR_FAILURE
;
}
FFMPEG_LOGV
(
"
Packet
loss
set
to
%
d
%
%
in
Opus
encoder
"
AssertedCast
<
int
>
(
specific
.
mPacketLossPerc
)
)
;
}
if
(
specific
.
mUseInBandFEC
)
{
if
(
mLib
-
>
av_opt_set
(
mCodecContext
-
>
priv_data
"
fec
"
"
on
"
0
)
)
{
FFMPEG_LOG
(
"
Error
%
s
FEC
on
Opus
encoder
"
specific
.
mUseInBandFEC
?
"
enabling
"
:
"
disabling
"
)
;
return
NS_ERROR_FAILURE
;
}
FFMPEG_LOGV
(
"
In
-
band
FEC
enabled
for
Opus
encoder
.
"
)
;
}
}
}
mCodecContext
-
>
time_base
=
AVRational
{
.
num
=
1
.
den
=
mCodecContext
-
>
sample_rate
}
;
MediaResult
rv
=
FinishInitCommon
(
codec
)
;
if
(
NS_FAILED
(
rv
)
)
{
FFMPEG_LOG
(
"
FFmpeg
encode
initialization
failure
.
"
)
;
return
rv
.
Code
(
)
;
}
return
NS_OK
;
}
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
58
Result
<
MediaDataEncoder
:
:
EncodedData
nsresult
>
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
EncodeOnePacket
(
Span
<
float
>
aSamples
media
:
:
TimeUnit
aPts
)
{
if
(
!
PrepareFrame
(
)
)
{
FFMPEG_LOG
(
"
failed
to
allocate
frame
"
)
;
return
Err
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
uint32_t
frameCount
=
aSamples
.
Length
(
)
/
mConfig
.
mNumberOfChannels
;
MOZ_ASSERT
(
AssertedCast
<
int
>
(
frameCount
)
<
=
mCodecContext
-
>
frame_size
)
;
mFrame
-
>
channels
=
AssertedCast
<
int
>
(
mConfig
.
mNumberOfChannels
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
60
int
rv
=
mLib
-
>
av_channel_layout_copy
(
&
mFrame
-
>
ch_layout
&
mCodecContext
-
>
ch_layout
)
;
if
(
rv
<
0
)
{
FFMPEG_LOG
(
"
channel
layout
copy
error
:
%
s
"
MakeErrorString
(
mLib
rv
)
.
get
(
)
)
;
return
Err
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
)
;
}
#
endif
mFrame
-
>
sample_rate
=
AssertedCast
<
int
>
(
mConfig
.
mSampleRate
)
;
mFrame
-
>
nb_samples
=
AssertedCast
<
int
>
(
frameCount
)
;
mFrame
-
>
format
=
mCodecContext
-
>
sample_fmt
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
59
mFrame
-
>
time_base
=
AVRational
{
.
num
=
1
.
den
=
static_cast
<
int
>
(
mConfig
.
mSampleRate
)
}
;
#
endif
mFrame
-
>
pts
=
aPts
.
ToTicksAtRate
(
mConfig
.
mSampleRate
)
;
mFrame
-
>
pkt_duration
=
frameCount
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
60
mFrame
-
>
duration
=
frameCount
;
#
else
mDurationMap
.
Insert
(
mFrame
-
>
pts
mFrame
-
>
pkt_duration
)
;
#
endif
if
(
int
ret
=
mLib
-
>
av_frame_get_buffer
(
mFrame
16
)
;
ret
<
0
)
{
FFMPEG_LOG
(
"
failed
to
allocate
frame
data
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
Err
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
if
(
int
ret
=
mLib
-
>
av_frame_make_writable
(
mFrame
)
;
ret
<
0
)
{
FFMPEG_LOG
(
"
failed
to
make
frame
writable
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
Err
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
)
;
}
if
(
mCodecContext
-
>
sample_fmt
=
=
AV_SAMPLE_FMT_FLT
)
{
PodCopy
(
reinterpret_cast
<
float
*
>
(
mFrame
-
>
data
[
0
]
)
aSamples
.
data
(
)
aSamples
.
Length
(
)
)
;
}
else
{
MOZ_ASSERT
(
mCodecContext
-
>
sample_fmt
=
=
AV_SAMPLE_FMT_FLTP
)
;
for
(
uint32_t
i
=
0
;
i
<
mConfig
.
mNumberOfChannels
;
i
+
+
)
{
DeinterleaveAndConvertBuffer
(
aSamples
.
data
(
)
mFrame
-
>
nb_samples
mFrame
-
>
channels
mFrame
-
>
data
)
;
}
}
return
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
EncodeWithModernAPIs
(
)
;
}
Result
<
MediaDataEncoder
:
:
EncodedData
nsresult
>
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
EncodeInputWithModernAPIs
(
RefPtr
<
const
MediaData
>
aSample
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
mCodecContext
)
;
MOZ_ASSERT
(
aSample
)
;
RefPtr
<
const
AudioData
>
sample
(
aSample
-
>
As
<
AudioData
>
(
)
)
;
FFMPEG_LOG
(
"
Encoding
%
"
PRIu32
"
frames
of
audio
at
pts
:
%
s
"
sample
-
>
Frames
(
)
sample
-
>
mTime
.
ToString
(
)
.
get
(
)
)
;
if
(
(
!
mResampler
&
&
sample
-
>
mRate
!
=
mConfig
.
mSampleRate
)
|
|
(
mResampler
&
&
sample
-
>
mRate
!
=
AssertedCast
<
uint32_t
>
(
mInputSampleRate
)
)
|
|
sample
-
>
mChannels
!
=
mConfig
.
mNumberOfChannels
)
{
FFMPEG_LOG
(
"
Rate
or
sample
-
rate
at
the
inputof
the
encoder
different
from
what
"
"
has
been
configured
initially
erroring
out
"
)
;
return
Result
<
MediaDataEncoder
:
:
EncodedData
nsresult
>
(
NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR
)
;
}
if
(
!
mPacketizer
)
{
media
:
:
TimeUnit
basePts
=
media
:
:
TimeUnit
:
:
Zero
(
mConfig
.
mSampleRate
)
;
basePts
+
=
sample
-
>
mTime
;
mPacketizer
.
emplace
(
mCodecContext
-
>
frame_size
sample
-
>
mChannels
basePts
.
ToTicksAtRate
(
mConfig
.
mSampleRate
)
mConfig
.
mSampleRate
)
;
}
if
(
!
mFirstPacketPts
.
IsValid
(
)
)
{
mFirstPacketPts
=
sample
-
>
mTime
;
}
Span
<
float
>
audio
=
sample
-
>
Data
(
)
;
if
(
mResampler
)
{
int
bufferLengthGuess
=
std
:
:
ceil
(
2
.
*
static_cast
<
float
>
(
audio
.
size
(
)
)
*
mConfig
.
mSampleRate
/
mInputSampleRate
)
;
mTempBuffer
.
SetLength
(
bufferLengthGuess
)
;
uint32_t
inputFrames
=
audio
.
size
(
)
/
mConfig
.
mNumberOfChannels
;
uint32_t
inputFramesProcessed
=
inputFrames
;
uint32_t
outputFrames
=
bufferLengthGuess
/
mConfig
.
mNumberOfChannels
;
DebugOnly
<
int
>
rv
=
speex_resampler_process_interleaved_float
(
mResampler
.
get
(
)
audio
.
data
(
)
&
inputFramesProcessed
mTempBuffer
.
Elements
(
)
&
outputFrames
)
;
audio
=
Span
<
float
>
(
mTempBuffer
.
Elements
(
)
outputFrames
*
mConfig
.
mNumberOfChannels
)
;
MOZ_ASSERT
(
inputFrames
=
=
inputFramesProcessed
"
increate
the
buffer
to
consume
all
input
each
time
"
)
;
MOZ_ASSERT
(
rv
=
=
RESAMPLER_ERR_SUCCESS
)
;
}
EncodedData
output
;
MediaResult
rv
=
NS_OK
;
mPacketizer
-
>
Input
(
audio
.
data
(
)
audio
.
Length
(
)
/
mConfig
.
mNumberOfChannels
)
;
while
(
mPacketizer
-
>
PacketsAvailable
(
)
&
&
rv
.
Code
(
)
=
=
NS_OK
)
{
mTempBuffer
.
SetLength
(
mCodecContext
-
>
frame_size
*
mConfig
.
mNumberOfChannels
)
;
media
:
:
TimeUnit
pts
=
mPacketizer
-
>
Output
(
mTempBuffer
.
Elements
(
)
)
;
auto
audio
=
Span
(
mTempBuffer
.
Elements
(
)
mTempBuffer
.
Length
(
)
)
;
FFMPEG_LOG
(
"
Encoding
%
"
PRIu32
"
frames
pts
:
%
s
"
mPacketizer
-
>
PacketSize
(
)
pts
.
ToString
(
)
.
get
(
)
)
;
auto
encodeResult
=
EncodeOnePacket
(
audio
pts
)
;
if
(
encodeResult
.
isOk
(
)
)
{
output
.
AppendElements
(
std
:
:
move
(
encodeResult
.
unwrap
(
)
)
)
;
}
else
{
return
encodeResult
;
}
pts
+
=
media
:
:
TimeUnit
(
mPacketizer
-
>
PacketSize
(
)
mConfig
.
mSampleRate
)
;
}
return
Result
<
MediaDataEncoder
:
:
EncodedData
nsresult
>
(
std
:
:
move
(
output
)
)
;
}
Result
<
MediaDataEncoder
:
:
EncodedData
nsresult
>
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
DrainWithModernAPIs
(
)
{
if
(
!
mPacketizer
|
|
mPacketizer
-
>
FramesAvailable
(
)
=
=
0
)
{
return
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
DrainWithModernAPIs
(
)
;
}
EncodedData
output
;
MediaResult
rv
=
NS_OK
;
mTempBuffer
.
SetLength
(
mCodecContext
-
>
frame_size
*
mPacketizer
-
>
ChannelCount
(
)
)
;
uint32_t
written
;
media
:
:
TimeUnit
pts
=
mPacketizer
-
>
Drain
(
mTempBuffer
.
Elements
(
)
written
)
;
auto
audio
=
Span
(
mTempBuffer
.
Elements
(
)
written
*
mPacketizer
-
>
ChannelCount
(
)
)
;
auto
encodeResult
=
EncodeOnePacket
(
audio
pts
)
;
if
(
encodeResult
.
isOk
(
)
)
{
auto
array
=
encodeResult
.
unwrap
(
)
;
output
.
AppendElements
(
std
:
:
move
(
array
)
)
;
}
else
{
return
encodeResult
;
}
auto
drainResult
=
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
DrainWithModernAPIs
(
)
;
if
(
drainResult
.
isOk
(
)
)
{
auto
array
=
drainResult
.
unwrap
(
)
;
output
.
AppendElements
(
std
:
:
move
(
array
)
)
;
}
else
{
return
drainResult
;
}
return
Result
<
MediaDataEncoder
:
:
EncodedData
nsresult
>
(
std
:
:
move
(
output
)
)
;
}
#
endif
RefPtr
<
MediaRawData
>
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
ToMediaRawData
(
AVPacket
*
aPacket
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
aPacket
)
;
RefPtr
<
MediaRawData
>
data
=
ToMediaRawDataCommon
(
aPacket
)
;
data
-
>
mTime
=
media
:
:
TimeUnit
(
aPacket
-
>
pts
mConfig
.
mSampleRate
)
;
data
-
>
mTimecode
=
data
-
>
mTime
;
data
-
>
mDuration
=
media
:
:
TimeUnit
(
mCodecContext
-
>
frame_size
mConfig
.
mSampleRate
)
;
if
(
mFirstPacketPts
>
data
-
>
mTime
)
{
data
-
>
mOriginalPresentationWindow
=
Some
(
media
:
:
TimeInterval
{
data
-
>
mTime
data
-
>
GetEndTime
(
)
}
)
;
data
-
>
mTime
=
mFirstPacketPts
;
}
if
(
mPacketsDelivered
+
+
=
=
0
)
{
if
(
auto
r
=
GetExtraData
(
aPacket
)
;
r
.
isOk
(
)
)
{
data
-
>
mExtraData
=
r
.
unwrap
(
)
;
}
data
-
>
mConfig
=
MakeUnique
<
EncoderConfig
>
(
mConfig
)
;
}
if
(
data
-
>
mExtraData
)
{
FFMPEG_LOG
(
"
FFmpegAudioEncoder
out
:
[
%
s
%
s
]
(
%
zu
bytes
extradata
%
zu
bytes
)
"
data
-
>
mTime
.
ToString
(
)
.
get
(
)
data
-
>
mDuration
.
ToString
(
)
.
get
(
)
data
-
>
Size
(
)
data
-
>
mExtraData
-
>
Length
(
)
)
;
}
else
{
FFMPEG_LOG
(
"
FFmpegAudioEncoder
out
:
[
%
s
%
s
]
(
%
zu
bytes
)
"
data
-
>
mTime
.
ToString
(
)
.
get
(
)
data
-
>
mDuration
.
ToString
(
)
.
get
(
)
data
-
>
Size
(
)
)
;
}
return
data
;
}
Result
<
already_AddRefed
<
MediaByteBuffer
>
nsresult
>
FFmpegAudioEncoder
<
LIBAV_VER
>
:
:
GetExtraData
(
AVPacket
*
)
{
if
(
!
mCodecContext
-
>
extradata_size
)
{
return
Err
(
NS_ERROR_NOT_AVAILABLE
)
;
}
auto
extraData
=
MakeRefPtr
<
MediaByteBuffer
>
(
)
;
extraData
-
>
SetLength
(
mCodecContext
-
>
extradata_size
)
;
MOZ_ASSERT
(
extraData
)
;
PodCopy
(
extraData
-
>
Elements
(
)
mCodecContext
-
>
extradata
mCodecContext
-
>
extradata_size
)
;
return
extraData
.
forget
(
)
;
}
}
