#
ifndef
__FFmpegAACDecoder_h__
#
define
__FFmpegAACDecoder_h__
#
include
"
FFmpegDataDecoder
.
h
"
#
include
"
FFmpegLibWrapper
.
h
"
namespace
mozilla
{
template
<
int
V
>
class
FFmpegAudioDecoder
{
}
;
template
<
>
class
FFmpegAudioDecoder
<
LIBAV_VER
>
;
DDLoggedTypeNameAndBase
(
FFmpegAudioDecoder
<
LIBAV_VER
>
FFmpegDataDecoder
<
LIBAV_VER
>
)
;
template
<
>
class
FFmpegAudioDecoder
<
LIBAV_VER
>
:
public
FFmpegDataDecoder
<
LIBAV_VER
>
public
DecoderDoctorLifeLogger
<
FFmpegAudioDecoder
<
LIBAV_VER
>
>
{
public
:
FFmpegAudioDecoder
(
FFmpegLibWrapper
*
aLib
const
AudioInfo
&
aInfo
)
;
virtual
~
FFmpegAudioDecoder
(
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
void
InitCodecContext
(
)
MOZ_REQUIRES
(
sMutex
)
override
;
static
AVCodecID
GetCodecId
(
const
nsACString
&
aMimeType
const
AudioInfo
&
aInfo
)
;
nsCString
GetDescriptionName
(
)
const
override
{
#
ifdef
USING_MOZFFVPX
return
"
ffvpx
audio
decoder
"
_ns
;
#
else
return
"
ffmpeg
audio
decoder
"
_ns
;
#
endif
}
nsCString
GetCodecName
(
)
const
override
;
private
:
MediaResult
DoDecode
(
MediaRawData
*
aSample
uint8_t
*
aData
int
aSize
bool
*
aGotFrame
DecodedData
&
aResults
)
override
;
MediaResult
DecodeUsingFFmpeg
(
AVPacket
*
aPacket
int
&
aOutBytesConsumed
bool
&
aDecoded
MediaRawData
*
aSample
DecodedData
&
aResults
bool
*
aGotFrame
)
;
MediaResult
PostProcessOutput
(
bool
aDecoded
MediaRawData
*
aSample
DecodedData
&
aResults
bool
*
aGotFrame
size_t
aSamplePositionOffset
)
;
const
AudioInfo
mAudioInfo
;
}
;
}
#
endif
