#
include
"
FFmpegVideoDecoder
.
h
"
#
include
"
FFmpegLog
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
MP4Decoder
.
h
"
#
include
"
VPXDecoder
.
h
"
#
include
"
mozilla
/
layers
/
KnowsCompositor
.
h
"
#
include
"
libavutil
/
pixfmt
.
h
"
#
if
LIBAVCODEC_VERSION_MAJOR
<
54
#
define
AVPixelFormat
PixelFormat
#
define
AV_PIX_FMT_YUV420P
PIX_FMT_YUV420P
#
define
AV_PIX_FMT_YUVJ420P
PIX_FMT_YUVJ420P
#
define
AV_PIX_FMT_YUV422P
PIX_FMT_YUV422P
#
define
AV_PIX_FMT_YUV444P
PIX_FMT_YUV444P
#
define
AV_PIX_FMT_YUV420P10LE
PIX_FMT_YUV420P10LE
#
define
AV_PIX_FMT_YUV444P10LE
PIX_FMT_YUV444P10LE
#
define
AV_PIX_FMT_NONE
PIX_FMT_NONE
#
endif
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
prsystem
.
h
"
typedef
mozilla
:
:
layers
:
:
Image
Image
;
typedef
mozilla
:
:
layers
:
:
PlanarYCbCrImage
PlanarYCbCrImage
;
namespace
mozilla
{
using
media
:
:
TimeUnit
;
static
AVPixelFormat
ChoosePixelFormat
(
AVCodecContext
*
aCodecContext
const
AVPixelFormat
*
aFormats
)
{
FFMPEG_LOG
(
"
Choosing
FFmpeg
pixel
format
for
video
decoding
.
"
)
;
for
(
;
*
aFormats
>
-
1
;
aFormats
+
+
)
{
switch
(
*
aFormats
)
{
case
AV_PIX_FMT_YUV444P
:
FFMPEG_LOG
(
"
Requesting
pixel
format
YUV444P
.
"
)
;
return
AV_PIX_FMT_YUV444P
;
case
AV_PIX_FMT_YUV422P
:
FFMPEG_LOG
(
"
Requesting
pixel
format
YUV422P
.
"
)
;
return
AV_PIX_FMT_YUV422P
;
case
AV_PIX_FMT_YUV420P
:
FFMPEG_LOG
(
"
Requesting
pixel
format
YUV420P
.
"
)
;
return
AV_PIX_FMT_YUV420P
;
case
AV_PIX_FMT_YUVJ420P
:
FFMPEG_LOG
(
"
Requesting
pixel
format
YUVJ420P
.
"
)
;
return
AV_PIX_FMT_YUVJ420P
;
case
AV_PIX_FMT_YUV420P10LE
:
FFMPEG_LOG
(
"
Requesting
pixel
format
YUV420P10LE
.
"
)
;
return
AV_PIX_FMT_YUV420P10LE
;
case
AV_PIX_FMT_YUV444P10LE
:
FFMPEG_LOG
(
"
Requesting
pixel
format
YUV444P10LE
.
"
)
;
return
AV_PIX_FMT_YUV444P10LE
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
57
case
AV_PIX_FMT_YUV444P12LE
:
FFMPEG_LOG
(
"
Requesting
pixel
format
YUV444P12LE
.
"
)
;
return
AV_PIX_FMT_YUV444P12LE
;
#
endif
default
:
break
;
}
}
NS_WARNING
(
"
FFmpeg
does
not
share
any
supported
pixel
formats
.
"
)
;
return
AV_PIX_FMT_NONE
;
}
FFmpegVideoDecoder
<
LIBAV_VER
>
:
:
PtsCorrectionContext
:
:
PtsCorrectionContext
(
)
:
mNumFaultyPts
(
0
)
mNumFaultyDts
(
0
)
mLastPts
(
INT64_MIN
)
mLastDts
(
INT64_MIN
)
{
}
int64_t
FFmpegVideoDecoder
<
LIBAV_VER
>
:
:
PtsCorrectionContext
:
:
GuessCorrectPts
(
int64_t
aPts
int64_t
aDts
)
{
int64_t
pts
=
AV_NOPTS_VALUE
;
if
(
aDts
!
=
int64_t
(
AV_NOPTS_VALUE
)
)
{
mNumFaultyDts
+
=
aDts
<
=
mLastDts
;
mLastDts
=
aDts
;
}
if
(
aPts
!
=
int64_t
(
AV_NOPTS_VALUE
)
)
{
mNumFaultyPts
+
=
aPts
<
=
mLastPts
;
mLastPts
=
aPts
;
}
if
(
(
mNumFaultyPts
<
=
mNumFaultyDts
|
|
aDts
=
=
int64_t
(
AV_NOPTS_VALUE
)
)
&
&
aPts
!
=
int64_t
(
AV_NOPTS_VALUE
)
)
{
pts
=
aPts
;
}
else
{
pts
=
aDts
;
}
return
pts
;
}
void
FFmpegVideoDecoder
<
LIBAV_VER
>
:
:
PtsCorrectionContext
:
:
Reset
(
)
{
mNumFaultyPts
=
0
;
mNumFaultyDts
=
0
;
mLastPts
=
INT64_MIN
;
mLastDts
=
INT64_MIN
;
}
FFmpegVideoDecoder
<
LIBAV_VER
>
:
:
FFmpegVideoDecoder
(
FFmpegLibWrapper
*
aLib
TaskQueue
*
aTaskQueue
const
VideoInfo
&
aConfig
KnowsCompositor
*
aAllocator
ImageContainer
*
aImageContainer
bool
aLowLatency
)
:
FFmpegDataDecoder
(
aLib
aTaskQueue
GetCodecId
(
aConfig
.
mMimeType
)
)
mImageAllocator
(
aAllocator
)
mImageContainer
(
aImageContainer
)
mInfo
(
aConfig
)
mCodecParser
(
nullptr
)
mLastInputDts
(
INT64_MIN
)
mLowLatency
(
aLowLatency
)
{
MOZ_COUNT_CTOR
(
FFmpegVideoDecoder
)
;
mExtraData
=
new
MediaByteBuffer
;
mExtraData
-
>
AppendElements
(
*
aConfig
.
mExtraData
)
;
}
RefPtr
<
MediaDataDecoder
:
:
InitPromise
>
FFmpegVideoDecoder
<
LIBAV_VER
>
:
:
Init
(
)
{
MediaResult
rv
=
InitDecoder
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
InitPromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
return
InitPromise
:
:
CreateAndResolve
(
TrackInfo
:
:
kVideoTrack
__func__
)
;
}
void
FFmpegVideoDecoder
<
LIBAV_VER
>
:
:
InitCodecContext
(
)
{
mCodecContext
-
>
width
=
mInfo
.
mImage
.
width
;
mCodecContext
-
>
height
=
mInfo
.
mImage
.
height
;
int
decode_threads
=
1
;
if
(
mInfo
.
mDisplay
.
width
>
=
2048
)
{
decode_threads
=
8
;
}
else
if
(
mInfo
.
mDisplay
.
width
>
=
1024
)
{
decode_threads
=
4
;
}
else
if
(
mInfo
.
mDisplay
.
width
>
=
320
)
{
decode_threads
=
2
;
}
if
(
mLowLatency
)
{
mCodecContext
-
>
flags
|
=
CODEC_FLAG_LOW_DELAY
;
mCodecContext
-
>
thread_type
=
FF_THREAD_SLICE
;
}
else
{
decode_threads
=
std
:
:
min
(
decode_threads
PR_GetNumberOfProcessors
(
)
-
1
)
;
decode_threads
=
std
:
:
max
(
decode_threads
1
)
;
mCodecContext
-
>
thread_count
=
decode_threads
;
if
(
decode_threads
>
1
)
{
mCodecContext
-
>
thread_type
=
FF_THREAD_SLICE
|
FF_THREAD_FRAME
;
}
}
mCodecContext
-
>
get_format
=
ChoosePixelFormat
;
mCodecParser
=
mLib
-
>
av_parser_init
(
mCodecID
)
;
if
(
mCodecParser
)
{
mCodecParser
-
>
flags
|
=
PARSER_FLAG_COMPLETE_FRAMES
;
}
}
RefPtr
<
MediaDataDecoder
:
:
DecodePromise
>
FFmpegVideoDecoder
<
LIBAV_VER
>
:
:
ProcessDecode
(
MediaRawData
*
aSample
)
{
bool
gotFrame
=
false
;
DecodedData
results
;
MediaResult
rv
=
DoDecode
(
aSample
&
gotFrame
results
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
DecodePromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
return
DecodePromise
:
:
CreateAndResolve
(
Move
(
results
)
__func__
)
;
}
MediaResult
FFmpegVideoDecoder
<
LIBAV_VER
>
:
:
DoDecode
(
MediaRawData
*
aSample
bool
*
aGotFrame
MediaDataDecoder
:
:
DecodedData
&
aResults
)
{
uint8_t
*
inputData
=
const_cast
<
uint8_t
*
>
(
aSample
-
>
Data
(
)
)
;
size_t
inputSize
=
aSample
-
>
Size
(
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
54
if
(
inputSize
&
&
mCodecParser
&
&
(
mCodecID
=
=
AV_CODEC_ID_VP8
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
55
|
|
mCodecID
=
=
AV_CODEC_ID_VP9
#
endif
)
)
{
while
(
inputSize
)
{
uint8_t
*
data
;
int
size
;
int
len
=
mLib
-
>
av_parser_parse2
(
mCodecParser
mCodecContext
&
data
&
size
inputData
inputSize
aSample
-
>
mTime
.
ToMicroseconds
(
)
aSample
-
>
mTimecode
.
ToMicroseconds
(
)
aSample
-
>
mOffset
)
;
if
(
size_t
(
len
)
>
inputSize
)
{
return
NS_ERROR_DOM_MEDIA_DECODE_ERR
;
}
inputData
+
=
len
;
inputSize
-
=
len
;
if
(
size
)
{
bool
gotFrame
=
false
;
MediaResult
rv
=
DoDecode
(
aSample
data
size
&
gotFrame
aResults
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
gotFrame
&
&
aGotFrame
)
{
*
aGotFrame
=
true
;
}
}
}
return
NS_OK
;
}
#
endif
return
DoDecode
(
aSample
inputData
inputSize
aGotFrame
aResults
)
;
}
MediaResult
FFmpegVideoDecoder
<
LIBAV_VER
>
:
:
DoDecode
(
MediaRawData
*
aSample
uint8_t
*
aData
int
aSize
bool
*
aGotFrame
MediaDataDecoder
:
:
DecodedData
&
aResults
)
{
AVPacket
packet
;
mLib
-
>
av_init_packet
(
&
packet
)
;
packet
.
data
=
aData
;
packet
.
size
=
aSize
;
packet
.
dts
=
mLastInputDts
=
aSample
-
>
mTimecode
.
ToMicroseconds
(
)
;
packet
.
pts
=
aSample
-
>
mTime
.
ToMicroseconds
(
)
;
packet
.
flags
=
aSample
-
>
mKeyframe
?
AV_PKT_FLAG_KEY
:
0
;
packet
.
pos
=
aSample
-
>
mOffset
;
mDurationMap
.
Insert
(
aSample
-
>
mTimecode
.
ToMicroseconds
(
)
aSample
-
>
mDuration
.
ToMicroseconds
(
)
)
;
if
(
!
PrepareFrame
(
)
)
{
NS_WARNING
(
"
FFmpeg
h264
decoder
failed
to
allocate
frame
.
"
)
;
return
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
}
mFrame
-
>
reordered_opaque
=
AV_NOPTS_VALUE
;
int
decoded
;
int
bytesConsumed
=
mLib
-
>
avcodec_decode_video2
(
mCodecContext
mFrame
&
decoded
&
packet
)
;
FFMPEG_LOG
(
"
DoDecodeFrame
:
decode_video
:
rv
=
%
d
decoded
=
%
d
"
"
(
Input
:
pts
(
%
"
PRId64
"
)
dts
(
%
"
PRId64
"
)
Output
:
pts
(
%
"
PRId64
"
)
"
"
opaque
(
%
"
PRId64
"
)
pkt_pts
(
%
"
PRId64
"
)
pkt_dts
(
%
"
PRId64
"
)
)
"
bytesConsumed
decoded
packet
.
pts
packet
.
dts
mFrame
-
>
pts
mFrame
-
>
reordered_opaque
mFrame
-
>
pkt_pts
mFrame
-
>
pkt_dts
)
;
if
(
bytesConsumed
<
0
)
{
return
MediaResult
(
NS_ERROR_DOM_MEDIA_DECODE_ERR
RESULT_DETAIL
(
"
FFmpeg
video
error
:
%
d
"
bytesConsumed
)
)
;
}
if
(
!
decoded
)
{
if
(
aGotFrame
)
{
*
aGotFrame
=
false
;
}
return
NS_OK
;
}
int64_t
pts
=
mPtsContext
.
GuessCorrectPts
(
mFrame
-
>
pkt_pts
mFrame
-
>
pkt_dts
)
;
int64_t
duration
;
if
(
!
mDurationMap
.
Find
(
mFrame
-
>
pkt_dts
duration
)
)
{
NS_WARNING
(
"
Unable
to
retrieve
duration
from
map
"
)
;
duration
=
aSample
-
>
mDuration
.
ToMicroseconds
(
)
;
mDurationMap
.
Clear
(
)
;
}
FFMPEG_LOG
(
"
Got
one
frame
output
with
pts
=
%
"
PRId64
"
dts
=
%
"
PRId64
"
duration
=
%
"
PRId64
"
opaque
=
%
"
PRId64
pts
mFrame
-
>
pkt_dts
duration
mCodecContext
-
>
reordered_opaque
)
;
VideoData
:
:
YCbCrBuffer
b
;
b
.
mPlanes
[
0
]
.
mData
=
mFrame
-
>
data
[
0
]
;
b
.
mPlanes
[
1
]
.
mData
=
mFrame
-
>
data
[
1
]
;
b
.
mPlanes
[
2
]
.
mData
=
mFrame
-
>
data
[
2
]
;
b
.
mPlanes
[
0
]
.
mStride
=
mFrame
-
>
linesize
[
0
]
;
b
.
mPlanes
[
1
]
.
mStride
=
mFrame
-
>
linesize
[
1
]
;
b
.
mPlanes
[
2
]
.
mStride
=
mFrame
-
>
linesize
[
2
]
;
b
.
mPlanes
[
0
]
.
mOffset
=
b
.
mPlanes
[
0
]
.
mSkip
=
0
;
b
.
mPlanes
[
1
]
.
mOffset
=
b
.
mPlanes
[
1
]
.
mSkip
=
0
;
b
.
mPlanes
[
2
]
.
mOffset
=
b
.
mPlanes
[
2
]
.
mSkip
=
0
;
b
.
mPlanes
[
0
]
.
mWidth
=
mFrame
-
>
width
;
b
.
mPlanes
[
0
]
.
mHeight
=
mFrame
-
>
height
;
if
(
mCodecContext
-
>
pix_fmt
=
=
AV_PIX_FMT_YUV444P
|
|
mCodecContext
-
>
pix_fmt
=
=
AV_PIX_FMT_YUV444P10LE
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
57
|
|
mCodecContext
-
>
pix_fmt
=
=
AV_PIX_FMT_YUV444P12LE
#
endif
)
{
b
.
mPlanes
[
1
]
.
mWidth
=
b
.
mPlanes
[
2
]
.
mWidth
=
mFrame
-
>
width
;
b
.
mPlanes
[
1
]
.
mHeight
=
b
.
mPlanes
[
2
]
.
mHeight
=
mFrame
-
>
height
;
if
(
mCodecContext
-
>
pix_fmt
=
=
AV_PIX_FMT_YUV444P10LE
)
{
b
.
mBitDepth
=
10
;
}
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
57
else
if
(
mCodecContext
-
>
pix_fmt
=
=
AV_PIX_FMT_YUV444P12LE
)
{
b
.
mBitDepth
=
12
;
}
#
endif
}
else
if
(
mCodecContext
-
>
pix_fmt
=
=
AV_PIX_FMT_YUV422P
)
{
b
.
mPlanes
[
1
]
.
mWidth
=
b
.
mPlanes
[
2
]
.
mWidth
=
(
mFrame
-
>
width
+
1
)
>
>
1
;
b
.
mPlanes
[
1
]
.
mHeight
=
b
.
mPlanes
[
2
]
.
mHeight
=
mFrame
-
>
height
;
}
else
{
b
.
mPlanes
[
1
]
.
mWidth
=
b
.
mPlanes
[
2
]
.
mWidth
=
(
mFrame
-
>
width
+
1
)
>
>
1
;
b
.
mPlanes
[
1
]
.
mHeight
=
b
.
mPlanes
[
2
]
.
mHeight
=
(
mFrame
-
>
height
+
1
)
>
>
1
;
if
(
mCodecContext
-
>
pix_fmt
=
=
AV_PIX_FMT_YUV420P10LE
)
{
b
.
mBitDepth
=
10
;
}
}
if
(
mLib
-
>
av_frame_get_colorspace
)
{
switch
(
mLib
-
>
av_frame_get_colorspace
(
mFrame
)
)
{
case
AVCOL_SPC_BT709
:
b
.
mYUVColorSpace
=
YUVColorSpace
:
:
BT709
;
break
;
case
AVCOL_SPC_SMPTE170M
:
case
AVCOL_SPC_BT470BG
:
b
.
mYUVColorSpace
=
YUVColorSpace
:
:
BT601
;
break
;
case
AVCOL_SPC_UNSPECIFIED
:
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
55
if
(
mCodecContext
-
>
codec_id
=
=
AV_CODEC_ID_VP9
)
{
b
.
mYUVColorSpace
=
YUVColorSpace
:
:
BT709
;
}
#
endif
break
;
default
:
break
;
}
}
RefPtr
<
VideoData
>
v
=
VideoData
:
:
CreateAndCopyData
(
mInfo
mImageContainer
aSample
-
>
mOffset
TimeUnit
:
:
FromMicroseconds
(
pts
)
TimeUnit
:
:
FromMicroseconds
(
duration
)
b
!
!
mFrame
-
>
key_frame
TimeUnit
:
:
FromMicroseconds
(
-
1
)
mInfo
.
ScaledImageRect
(
mFrame
-
>
width
mFrame
-
>
height
)
mImageAllocator
)
;
if
(
!
v
)
{
return
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
image
allocation
error
"
)
)
;
}
aResults
.
AppendElement
(
Move
(
v
)
)
;
if
(
aGotFrame
)
{
*
aGotFrame
=
true
;
}
return
NS_OK
;
}
RefPtr
<
MediaDataDecoder
:
:
DecodePromise
>
FFmpegVideoDecoder
<
LIBAV_VER
>
:
:
ProcessDrain
(
)
{
RefPtr
<
MediaRawData
>
empty
(
new
MediaRawData
(
)
)
;
empty
-
>
mTimecode
=
TimeUnit
:
:
FromMicroseconds
(
mLastInputDts
)
;
bool
gotFrame
=
false
;
DecodedData
results
;
while
(
NS_SUCCEEDED
(
DoDecode
(
empty
&
gotFrame
results
)
)
&
&
gotFrame
)
{
}
return
DecodePromise
:
:
CreateAndResolve
(
Move
(
results
)
__func__
)
;
}
RefPtr
<
MediaDataDecoder
:
:
FlushPromise
>
FFmpegVideoDecoder
<
LIBAV_VER
>
:
:
ProcessFlush
(
)
{
mPtsContext
.
Reset
(
)
;
mDurationMap
.
Clear
(
)
;
return
FFmpegDataDecoder
:
:
ProcessFlush
(
)
;
}
FFmpegVideoDecoder
<
LIBAV_VER
>
:
:
~
FFmpegVideoDecoder
(
)
{
MOZ_COUNT_DTOR
(
FFmpegVideoDecoder
)
;
if
(
mCodecParser
)
{
mLib
-
>
av_parser_close
(
mCodecParser
)
;
mCodecParser
=
nullptr
;
}
}
AVCodecID
FFmpegVideoDecoder
<
LIBAV_VER
>
:
:
GetCodecId
(
const
nsACString
&
aMimeType
)
{
if
(
MP4Decoder
:
:
IsH264
(
aMimeType
)
)
{
return
AV_CODEC_ID_H264
;
}
if
(
aMimeType
.
EqualsLiteral
(
"
video
/
x
-
vnd
.
on2
.
vp6
"
)
)
{
return
AV_CODEC_ID_VP6F
;
}
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
54
if
(
VPXDecoder
:
:
IsVP8
(
aMimeType
)
)
{
return
AV_CODEC_ID_VP8
;
}
#
endif
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
55
if
(
VPXDecoder
:
:
IsVP9
(
aMimeType
)
)
{
return
AV_CODEC_ID_VP9
;
}
#
endif
return
AV_CODEC_ID_NONE
;
}
}
