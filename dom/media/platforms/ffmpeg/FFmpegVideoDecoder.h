#
ifndef
__FFmpegVideoDecoder_h__
#
define
__FFmpegVideoDecoder_h__
#
include
<
atomic
>
#
include
"
AndroidSurfaceTexture
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
FFmpegDataDecoder
.
h
"
#
include
"
FFmpegLibWrapper
.
h
"
#
include
"
PerformanceRecorder
.
h
"
#
include
"
SimpleMap
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
nsTHashSet
.
h
"
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
57
&
&
LIBAVUTIL_VERSION_MAJOR
>
=
56
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
endif
#
if
defined
(
MOZ_USE_HWDECODE
)
&
&
defined
(
MOZ_WIDGET_GTK
)
#
include
"
FFmpegVideoFramePool
.
h
"
#
endif
#
include
"
libavutil
/
pixfmt
.
h
"
#
if
LIBAVCODEC_VERSION_MAJOR
<
54
#
define
AVPixelFormat
PixelFormat
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
mozilla
/
java
/
GeckoSurfaceWrappers
.
h
"
#
endif
#
if
LIBAVCODEC_VERSION_MAJOR
<
58
|
|
defined
(
MOZ_WIDGET_ANDROID
)
#
define
MOZ_FFMPEG_USE_INPUT_INFO_MAP
#
endif
struct
_VADRMPRIMESurfaceDescriptor
;
typedef
struct
_VADRMPRIMESurfaceDescriptor
VADRMPRIMESurfaceDescriptor
;
namespace
mozilla
{
namespace
layers
{
class
BufferRecycleBin
;
}
class
ImageBufferWrapper
;
#
ifdef
MOZ_ENABLE_D3D11VA
class
DXVA2Manager
;
#
endif
template
<
int
V
>
class
FFmpegVideoDecoder
:
public
FFmpegDataDecoder
<
V
>
{
}
;
template
<
>
class
FFmpegVideoDecoder
<
LIBAV_VER
>
;
DDLoggedTypeNameAndBase
(
FFmpegVideoDecoder
<
LIBAV_VER
>
FFmpegDataDecoder
<
LIBAV_VER
>
)
;
template
<
>
class
FFmpegVideoDecoder
<
LIBAV_VER
>
:
public
FFmpegDataDecoder
<
LIBAV_VER
>
public
DecoderDoctorLifeLogger
<
FFmpegVideoDecoder
<
LIBAV_VER
>
>
{
typedef
mozilla
:
:
layers
:
:
Image
Image
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
typedef
mozilla
:
:
layers
:
:
KnowsCompositor
KnowsCompositor
;
public
:
FFmpegVideoDecoder
(
FFmpegLibWrapper
*
aLib
const
VideoInfo
&
aConfig
KnowsCompositor
*
aAllocator
ImageContainer
*
aImageContainer
bool
aLowLatency
bool
aDisableHardwareDecoding
bool
a8BitOutput
Maybe
<
TrackingId
>
aTrackingId
)
;
~
FFmpegVideoDecoder
(
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
void
InitCodecContext
(
)
MOZ_REQUIRES
(
sMutex
)
override
;
nsCString
GetDescriptionName
(
)
const
override
{
#
ifdef
USING_MOZFFVPX
return
"
ffvpx
video
decoder
"
_ns
;
#
else
return
"
ffmpeg
video
decoder
"
_ns
;
#
endif
}
nsCString
GetCodecName
(
)
const
override
;
ConversionRequired
NeedsConversion
(
)
const
override
{
#
ifdef
MOZ_WIDGET_ANDROID
return
mCodecID
=
=
AV_CODEC_ID_H264
|
|
mCodecID
=
=
AV_CODEC_ID_HEVC
?
ConversionRequired
:
:
kNeedAnnexB
:
ConversionRequired
:
:
kNeedNone
;
#
else
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
55
if
(
mCodecID
=
=
AV_CODEC_ID_HEVC
)
{
return
ConversionRequired
:
:
kNeedHVCC
;
}
#
endif
return
mCodecID
=
=
AV_CODEC_ID_H264
?
ConversionRequired
:
:
kNeedAVCC
:
ConversionRequired
:
:
kNeedNone
;
#
endif
}
static
AVCodecID
GetCodecId
(
const
nsACString
&
aMimeType
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
57
&
&
LIBAVUTIL_VERSION_MAJOR
>
=
56
int
GetVideoBuffer
(
struct
AVCodecContext
*
aCodecContext
AVFrame
*
aFrame
int
aFlags
)
;
int
GetVideoBufferDefault
(
struct
AVCodecContext
*
aCodecContext
AVFrame
*
aFrame
int
aFlags
)
{
mIsUsingShmemBufferForDecode
=
Some
(
false
)
;
return
mLib
-
>
avcodec_default_get_buffer2
(
aCodecContext
aFrame
aFlags
)
;
}
void
ReleaseAllocatedImage
(
ImageBufferWrapper
*
aImage
)
{
mAllocatedImages
.
Remove
(
aImage
)
;
}
#
endif
bool
IsHardwareAccelerated
(
)
const
{
nsAutoCString
dummy
;
return
IsHardwareAccelerated
(
dummy
)
;
}
private
:
RefPtr
<
FlushPromise
>
ProcessFlush
(
)
override
;
void
ProcessShutdown
(
)
override
;
MediaResult
DoDecode
(
MediaRawData
*
aSample
uint8_t
*
aData
int
aSize
bool
*
aGotFrame
DecodedData
&
aResults
)
override
;
void
OutputDelayedFrames
(
)
;
bool
NeedParser
(
)
const
override
{
return
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
58
false
;
#
else
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
55
mCodecID
=
=
AV_CODEC_ID_VP9
|
|
#
endif
mCodecID
=
=
AV_CODEC_ID_VP8
;
#
endif
}
gfx
:
:
ColorDepth
GetColorDepth
(
const
AVPixelFormat
&
aFormat
)
const
;
gfx
:
:
YUVColorSpace
GetFrameColorSpace
(
)
const
;
gfx
:
:
ColorSpace2
GetFrameColorPrimaries
(
)
const
;
gfx
:
:
ColorRange
GetFrameColorRange
(
)
const
;
gfx
:
:
SurfaceFormat
GetSurfaceFormat
(
)
const
;
MediaResult
CreateImage
(
int64_t
aOffset
int64_t
aPts
int64_t
aDuration
MediaDataDecoder
:
:
DecodedData
&
aResults
)
;
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
override
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
57
&
&
LIBAVUTIL_VERSION_MAJOR
>
=
56
layers
:
:
TextureClient
*
AllocateTextureClientForImage
(
struct
AVCodecContext
*
aCodecContext
layers
:
:
PlanarYCbCrImage
*
aImage
)
;
gfx
:
:
IntSize
GetAlignmentVideoFrameSize
(
struct
AVCodecContext
*
aCodecContext
int32_t
aWidth
int32_t
aHeight
)
const
;
#
endif
RefPtr
<
KnowsCompositor
>
mImageAllocator
;
#
ifdef
MOZ_USE_HWDECODE
public
:
static
AVCodec
*
FindVideoHardwareAVCodec
(
FFmpegLibWrapper
*
aLib
AVCodecID
aCodec
AVHWDeviceType
aDeviceType
=
AV_HWDEVICE_TYPE_NONE
)
;
private
:
void
InitHWDecoderIfAllowed
(
)
;
enum
class
ContextType
{
D3D11VA
MediaCodec
VAAPI
V4L2
}
;
void
InitHWCodecContext
(
ContextType
aType
)
;
bool
ShouldDisableHWDecoding
(
bool
aDisableHardwareDecoding
)
const
;
const
bool
mHardwareDecodingDisabled
;
#
endif
#
ifdef
MOZ_ENABLE_D3D11VA
MediaResult
InitD3D11VADecoder
(
)
;
MediaResult
CreateImageD3D11
(
int64_t
aOffset
int64_t
aPts
int64_t
aDuration
MediaDataDecoder
:
:
DecodedData
&
aResults
)
;
bool
CanUseZeroCopyVideoFrame
(
)
const
;
AVBufferRef
*
mD3D11VADeviceContext
=
nullptr
;
RefPtr
<
ID3D11Device
>
mDevice
;
UniquePtr
<
DXVA2Manager
>
mDXVA2Manager
;
std
:
:
atomic
<
uint8_t
>
mNumOfHWTexturesInUse
{
0
}
;
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
MediaResult
InitMediaCodecDecoder
(
)
;
MediaResult
CreateImageMediaCodec
(
int64_t
aOffset
int64_t
aPts
int64_t
aTimecode
int64_t
aDuration
MediaDataDecoder
:
:
DecodedData
&
aResults
)
;
int32_t
mTextureAlignment
;
AVBufferRef
*
mMediaCodecDeviceContext
=
nullptr
;
java
:
:
GeckoSurface
:
:
GlobalRef
mSurface
;
AndroidSurfaceTextureHandle
mSurfaceHandle
{
}
;
#
endif
#
if
defined
(
MOZ_USE_HWDECODE
)
&
&
defined
(
MOZ_WIDGET_GTK
)
bool
UploadSWDecodeToDMABuf
(
)
const
;
bool
IsLinuxHDR
(
)
const
;
MediaResult
InitVAAPIDecoder
(
)
;
MediaResult
InitV4L2Decoder
(
)
;
bool
CreateVAAPIDeviceContext
(
)
;
bool
GetVAAPISurfaceDescriptor
(
VADRMPRIMESurfaceDescriptor
*
aVaDesc
)
;
void
AddAcceleratedFormats
(
nsTArray
<
AVCodecID
>
&
aCodecList
AVCodecID
aCodecID
AVVAAPIHWConfig
*
hwconfig
)
;
nsTArray
<
AVCodecID
>
GetAcceleratedFormats
(
)
;
bool
IsFormatAccelerated
(
AVCodecID
aCodecID
)
const
;
MediaResult
CreateImageVAAPI
(
int64_t
aOffset
int64_t
aPts
int64_t
aDuration
MediaDataDecoder
:
:
DecodedData
&
aResults
)
;
MediaResult
CreateImageV4L2
(
int64_t
aOffset
int64_t
aPts
int64_t
aDuration
MediaDataDecoder
:
:
DecodedData
&
aResults
)
;
void
AdjustHWDecodeLogging
(
)
;
AVBufferRef
*
mVAAPIDeviceContext
=
nullptr
;
bool
mUsingV4L2
=
false
;
bool
mUploadSWDecodeToDMABuf
=
false
;
VADisplay
mDisplay
=
nullptr
;
UniquePtr
<
VideoFramePool
<
LIBAV_VER
>
>
mVideoFramePool
;
static
nsTArray
<
AVCodecID
>
mAcceleratedFormats
;
#
endif
RefPtr
<
ImageContainer
>
mImageContainer
;
VideoInfo
mInfo
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
58
class
DecodeStats
{
public
:
void
DecodeStart
(
)
;
void
UpdateDecodeTimes
(
int64_t
aDuration
)
;
bool
IsDecodingSlow
(
)
const
;
private
:
uint32_t
mDecodedFrames
=
0
;
float
mAverageFrameDecodeTime
=
0
;
float
mAverageFrameDuration
=
0
;
const
uint32_t
mMaxLateDecodedFrames
=
15
;
uint32_t
mDecodedFramesLate
=
0
;
const
uint32_t
mDelayedFrameReset
=
3000
;
uint32_t
mLastDelayedFrameNum
=
0
;
TimeStamp
mDecodeStart
;
}
;
DecodeStats
mDecodeStats
;
#
endif
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
58
bool
mHasSentDrainPacket
=
false
;
#
endif
#
if
LIBAVCODEC_VERSION_MAJOR
<
58
class
PtsCorrectionContext
{
public
:
PtsCorrectionContext
(
)
;
int64_t
GuessCorrectPts
(
int64_t
aPts
int64_t
aDts
)
;
void
Reset
(
)
;
int64_t
LastDts
(
)
const
{
return
mLastDts
;
}
private
:
int64_t
mNumFaultyPts
;
int64_t
mNumFaultyDts
;
int64_t
mLastPts
;
int64_t
mLastDts
;
}
;
PtsCorrectionContext
mPtsContext
;
#
endif
#
ifdef
MOZ_FFMPEG_USE_INPUT_INFO_MAP
struct
InputInfo
{
explicit
InputInfo
(
const
MediaRawData
*
aSample
)
:
mDuration
(
aSample
-
>
mDuration
.
ToMicroseconds
(
)
)
#
ifdef
MOZ_WIDGET_ANDROID
mTimecode
(
aSample
-
>
mTimecode
.
ToMicroseconds
(
)
)
#
endif
{
}
int64_t
mDuration
;
#
ifdef
MOZ_WIDGET_ANDROID
int64_t
mTimecode
;
#
endif
}
;
SimpleMap
<
int64_t
InputInfo
ThreadSafePolicy
>
mInputInfo
;
static
int64_t
GetSampleInputKey
(
const
MediaRawData
*
aSample
)
{
#
ifdef
MOZ_WIDGET_ANDROID
return
aSample
-
>
mTime
.
ToMicroseconds
(
)
;
#
else
return
aSample
-
>
mTimecode
.
ToMicroseconds
(
)
;
#
endif
}
static
int64_t
GetFrameInputKey
(
const
AVFrame
*
aFrame
)
{
#
ifdef
MOZ_WIDGET_ANDROID
return
aFrame
-
>
pts
;
#
else
return
aFrame
-
>
pkt_dts
;
#
endif
}
void
InsertInputInfo
(
const
MediaRawData
*
aSample
)
{
mInputInfo
.
Insert
(
GetSampleInputKey
(
aSample
)
InputInfo
(
aSample
)
)
;
}
void
TakeInputInfo
(
const
AVFrame
*
aFrame
InputInfo
&
aEntry
)
{
if
(
!
mInputInfo
.
Find
(
GetFrameInputKey
(
aFrame
)
aEntry
)
)
{
NS_WARNING
(
"
Unable
to
retrieve
input
info
from
map
"
)
;
mInputInfo
.
Clear
(
)
;
}
}
#
endif
const
bool
mLowLatency
;
const
Maybe
<
TrackingId
>
mTrackingId
;
void
RecordFrame
(
const
MediaRawData
*
aSample
const
MediaData
*
aData
)
;
PerformanceRecorderMulti
<
DecodeStage
>
mPerformanceRecorder
;
Maybe
<
Atomic
<
bool
>
>
mIsUsingShmemBufferForDecode
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
57
&
&
LIBAVUTIL_VERSION_MAJOR
>
=
56
nsTHashSet
<
RefPtr
<
ImageBufferWrapper
>
>
mAllocatedImages
;
#
endif
Atomic
<
bool
>
m8BitOutput
;
RefPtr
<
layers
:
:
BufferRecycleBin
>
m8BitRecycleBin
;
}
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
57
&
&
LIBAVUTIL_VERSION_MAJOR
>
=
56
class
ImageBufferWrapper
final
{
public
:
typedef
mozilla
:
:
layers
:
:
Image
Image
;
typedef
mozilla
:
:
layers
:
:
PlanarYCbCrImage
PlanarYCbCrImage
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ImageBufferWrapper
)
ImageBufferWrapper
(
Image
*
aImage
void
*
aDecoder
)
:
mImage
(
aImage
)
mDecoder
(
aDecoder
)
{
MOZ_ASSERT
(
aImage
)
;
MOZ_ASSERT
(
mDecoder
)
;
}
Image
*
AsImage
(
)
{
return
mImage
;
}
void
ReleaseBuffer
(
)
{
auto
*
decoder
=
static_cast
<
FFmpegVideoDecoder
<
LIBAV_VER
>
*
>
(
mDecoder
)
;
decoder
-
>
ReleaseAllocatedImage
(
this
)
;
}
private
:
~
ImageBufferWrapper
(
)
=
default
;
const
RefPtr
<
Image
>
mImage
;
void
*
const
MOZ_NON_OWNING_REF
mDecoder
;
}
;
#
endif
}
#
endif
