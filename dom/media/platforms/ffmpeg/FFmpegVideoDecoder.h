#
ifndef
__FFmpegVideoDecoder_h__
#
define
__FFmpegVideoDecoder_h__
#
include
"
FFmpegDataDecoder
.
h
"
#
include
"
FFmpegLibWrapper
.
h
"
#
include
"
SimpleMap
.
h
"
#
ifdef
MOZ_WAYLAND_USE_VAAPI
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
widget
/
DMABufSurface
.
h
"
#
endif
namespace
mozilla
{
#
ifdef
MOZ_WAYLAND_USE_VAAPI
class
DMABufSurfaceWrapper
final
{
public
:
DMABufSurfaceWrapper
(
DMABufSurface
*
aSurface
FFmpegLibWrapper
*
aLib
)
;
~
DMABufSurfaceWrapper
(
)
;
void
LockVAAPIData
(
AVCodecContext
*
aAVCodecContext
AVFrame
*
aAVFrame
)
;
void
ReleaseVAAPIData
(
)
;
bool
IsUsed
(
)
const
{
return
mSurface
-
>
IsGlobalRefSet
(
)
;
}
RefPtr
<
DMABufSurfaceYUV
>
GetDMABufSurface
(
)
const
{
return
mSurface
-
>
GetAsDMABufSurfaceYUV
(
)
;
}
DMABufSurfaceWrapper
(
const
DMABufSurfaceWrapper
&
)
=
delete
;
const
DMABufSurfaceWrapper
&
operator
=
(
DMABufSurfaceWrapper
const
&
)
=
delete
;
private
:
const
RefPtr
<
DMABufSurface
>
mSurface
;
const
FFmpegLibWrapper
*
mLib
;
AVBufferRef
*
mAVHWFramesContext
;
AVBufferRef
*
mHWAVBuffer
;
}
;
#
endif
template
<
int
V
>
class
FFmpegVideoDecoder
:
public
FFmpegDataDecoder
<
V
>
{
}
;
template
<
>
class
FFmpegVideoDecoder
<
LIBAV_VER
>
;
DDLoggedTypeNameAndBase
(
FFmpegVideoDecoder
<
LIBAV_VER
>
FFmpegDataDecoder
<
LIBAV_VER
>
)
;
template
<
>
class
FFmpegVideoDecoder
<
LIBAV_VER
>
:
public
FFmpegDataDecoder
<
LIBAV_VER
>
public
DecoderDoctorLifeLogger
<
FFmpegVideoDecoder
<
LIBAV_VER
>
>
{
typedef
mozilla
:
:
layers
:
:
Image
Image
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
typedef
mozilla
:
:
layers
:
:
KnowsCompositor
KnowsCompositor
;
typedef
SimpleMap
<
int64_t
>
DurationMap
;
public
:
FFmpegVideoDecoder
(
FFmpegLibWrapper
*
aLib
const
VideoInfo
&
aConfig
KnowsCompositor
*
aAllocator
ImageContainer
*
aImageContainer
bool
aLowLatency
bool
aDisableHardwareDecoding
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
void
InitCodecContext
(
)
override
;
nsCString
GetDescriptionName
(
)
const
override
{
#
ifdef
USING_MOZFFVPX
return
"
ffvpx
video
decoder
"
_ns
;
#
else
return
"
ffmpeg
video
decoder
"
_ns
;
#
endif
}
ConversionRequired
NeedsConversion
(
)
const
override
{
return
ConversionRequired
:
:
kNeedAVCC
;
}
static
AVCodecID
GetCodecId
(
const
nsACString
&
aMimeType
)
;
private
:
RefPtr
<
FlushPromise
>
ProcessFlush
(
)
override
;
void
ProcessShutdown
(
)
override
;
MediaResult
DoDecode
(
MediaRawData
*
aSample
uint8_t
*
aData
int
aSize
bool
*
aGotFrame
DecodedData
&
aResults
)
override
;
void
OutputDelayedFrames
(
)
;
bool
NeedParser
(
)
const
override
{
return
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
58
false
;
#
else
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
55
mCodecID
=
=
AV_CODEC_ID_VP9
|
|
#
endif
mCodecID
=
=
AV_CODEC_ID_VP8
;
#
endif
}
gfx
:
:
YUVColorSpace
GetFrameColorSpace
(
)
const
;
MediaResult
CreateImage
(
int64_t
aOffset
int64_t
aPts
int64_t
aDuration
MediaDataDecoder
:
:
DecodedData
&
aResults
)
const
;
#
ifdef
MOZ_WAYLAND_USE_VAAPI
MediaResult
InitVAAPIDecoder
(
)
;
bool
CreateVAAPIDeviceContext
(
)
;
void
InitVAAPICodecContext
(
)
;
AVCodec
*
FindVAAPICodec
(
)
;
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
override
;
bool
GetVAAPISurfaceDescriptor
(
VADRMPRIMESurfaceDescriptor
&
aVaDesc
)
;
MediaResult
CreateImageDMABuf
(
int64_t
aOffset
int64_t
aPts
int64_t
aDuration
MediaDataDecoder
:
:
DecodedData
&
aResults
)
;
void
ReleaseUnusedVAAPIFrames
(
)
;
DMABufSurfaceWrapper
*
GetUnusedDMABufSurfaceWrapper
(
)
;
void
ReleaseDMABufSurfaces
(
)
;
#
endif
int
AllocateYUV420PVideoBuffer
(
AVCodecContext
*
aCodecContext
AVFrame
*
aFrame
)
;
#
ifdef
MOZ_WAYLAND_USE_VAAPI
AVBufferRef
*
mVAAPIDeviceContext
;
const
bool
mDisableHardwareDecoding
;
VADisplay
mDisplay
;
bool
mUseDMABufSurfaces
;
nsTArray
<
DMABufSurfaceWrapper
>
mDMABufSurfaces
;
#
endif
RefPtr
<
KnowsCompositor
>
mImageAllocator
;
RefPtr
<
ImageContainer
>
mImageContainer
;
VideoInfo
mInfo
;
class
PtsCorrectionContext
{
public
:
PtsCorrectionContext
(
)
;
int64_t
GuessCorrectPts
(
int64_t
aPts
int64_t
aDts
)
;
void
Reset
(
)
;
int64_t
LastDts
(
)
const
{
return
mLastDts
;
}
private
:
int64_t
mNumFaultyPts
;
int64_t
mNumFaultyDts
;
int64_t
mLastPts
;
int64_t
mLastDts
;
}
;
PtsCorrectionContext
mPtsContext
;
DurationMap
mDurationMap
;
const
bool
mLowLatency
;
}
;
}
#
endif
