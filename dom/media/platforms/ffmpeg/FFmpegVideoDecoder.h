#
ifndef
__FFmpegVideoDecoder_h__
#
define
__FFmpegVideoDecoder_h__
#
include
"
FFmpegLibWrapper
.
h
"
#
include
"
FFmpegDataDecoder
.
h
"
#
include
"
mozilla
/
Pair
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
template
<
int
V
>
class
FFmpegVideoDecoder
:
public
FFmpegDataDecoder
<
V
>
{
}
;
template
<
>
class
FFmpegVideoDecoder
<
LIBAV_VER
>
:
public
FFmpegDataDecoder
<
LIBAV_VER
>
{
typedef
mozilla
:
:
layers
:
:
Image
Image
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
enum
DecodeResult
{
DECODE_FRAME
DECODE_NO_FRAME
DECODE_ERROR
}
;
public
:
FFmpegVideoDecoder
(
FFmpegLibWrapper
*
aLib
FlushableTaskQueue
*
aTaskQueue
MediaDataDecoderCallback
*
aCallback
const
VideoInfo
&
aConfig
ImageContainer
*
aImageContainer
)
;
virtual
~
FFmpegVideoDecoder
(
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
nsresult
Input
(
MediaRawData
*
aSample
)
override
;
void
ProcessDrain
(
)
override
;
void
ProcessFlush
(
)
override
;
void
InitCodecContext
(
)
override
;
const
char
*
GetDescriptionName
(
)
const
override
{
#
ifdef
USING_MOZFFVPX
return
"
ffvpx
video
decoder
"
;
#
else
return
"
ffmpeg
video
decoder
"
;
#
endif
}
static
AVCodecID
GetCodecId
(
const
nsACString
&
aMimeType
)
;
private
:
void
ProcessDecode
(
MediaRawData
*
aSample
)
;
DecodeResult
DoDecode
(
MediaRawData
*
aSample
)
;
DecodeResult
DoDecode
(
MediaRawData
*
aSample
uint8_t
*
aData
int
aSize
)
;
void
DoDrain
(
)
;
void
OutputDelayedFrames
(
)
;
int
AllocateYUV420PVideoBuffer
(
AVCodecContext
*
aCodecContext
AVFrame
*
aFrame
)
;
RefPtr
<
ImageContainer
>
mImageContainer
;
VideoInfo
mInfo
;
AVCodecParserContext
*
mCodecParser
;
class
PtsCorrectionContext
{
public
:
PtsCorrectionContext
(
)
;
int64_t
GuessCorrectPts
(
int64_t
aPts
int64_t
aDts
)
;
void
Reset
(
)
;
int64_t
LastDts
(
)
const
{
return
mLastDts
;
}
private
:
int64_t
mNumFaultyPts
;
int64_t
mNumFaultyDts
;
int64_t
mLastPts
;
int64_t
mLastDts
;
}
;
PtsCorrectionContext
mPtsContext
;
class
DurationMap
{
public
:
typedef
Pair
<
int64_t
int64_t
>
DurationElement
;
void
Insert
(
int64_t
aKey
int64_t
aDuration
)
{
mMap
.
AppendElement
(
MakePair
(
aKey
aDuration
)
)
;
}
bool
Find
(
int64_t
aKey
int64_t
&
aDuration
)
{
for
(
uint32_t
i
=
0
;
i
<
mMap
.
Length
(
)
;
i
+
+
)
{
DurationElement
&
element
=
mMap
[
i
]
;
if
(
element
.
first
(
)
=
=
aKey
)
{
aDuration
=
element
.
second
(
)
;
mMap
.
RemoveElementAt
(
i
)
;
return
true
;
}
}
return
false
;
}
void
Clear
(
)
{
mMap
.
Clear
(
)
;
}
private
:
AutoTArray
<
DurationElement
16
>
mMap
;
}
;
DurationMap
mDurationMap
;
}
;
}
#
endif
