#
ifndef
__FFmpegVideoDecoder_h__
#
define
__FFmpegVideoDecoder_h__
#
include
"
FFmpegLibWrapper
.
h
"
#
include
"
FFmpegDataDecoder
.
h
"
#
include
"
SimpleMap
.
h
"
namespace
mozilla
{
#
ifdef
MOZ_WAYLAND_USE_VAAPI
class
VAAPIFrameHolder
{
public
:
VAAPIFrameHolder
(
FFmpegLibWrapper
*
aLib
AVBufferRef
*
aVAAPIDeviceContext
AVBufferRef
*
aAVHWFramesContext
AVBufferRef
*
aHWFrame
)
;
~
VAAPIFrameHolder
(
)
;
private
:
FFmpegLibWrapper
*
mLib
;
AVBufferRef
*
mVAAPIDeviceContext
;
AVBufferRef
*
mAVHWFramesContext
;
AVBufferRef
*
mHWFrame
;
}
;
#
endif
template
<
int
V
>
class
FFmpegVideoDecoder
:
public
FFmpegDataDecoder
<
V
>
{
}
;
template
<
>
class
FFmpegVideoDecoder
<
LIBAV_VER
>
;
DDLoggedTypeNameAndBase
(
FFmpegVideoDecoder
<
LIBAV_VER
>
FFmpegDataDecoder
<
LIBAV_VER
>
)
;
template
<
>
class
FFmpegVideoDecoder
<
LIBAV_VER
>
:
public
FFmpegDataDecoder
<
LIBAV_VER
>
public
DecoderDoctorLifeLogger
<
FFmpegVideoDecoder
<
LIBAV_VER
>
>
{
typedef
mozilla
:
:
layers
:
:
Image
Image
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
typedef
mozilla
:
:
layers
:
:
KnowsCompositor
KnowsCompositor
;
typedef
SimpleMap
<
int64_t
>
DurationMap
;
public
:
FFmpegVideoDecoder
(
FFmpegLibWrapper
*
aLib
TaskQueue
*
aTaskQueue
const
VideoInfo
&
aConfig
KnowsCompositor
*
aAllocator
ImageContainer
*
aImageContainer
bool
aLowLatency
bool
aDisableHardwareDecoding
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
void
InitCodecContext
(
)
override
;
nsCString
GetDescriptionName
(
)
const
override
{
#
ifdef
USING_MOZFFVPX
return
NS_LITERAL_CSTRING
(
"
ffvpx
video
decoder
"
)
;
#
else
return
NS_LITERAL_CSTRING
(
"
ffmpeg
video
decoder
"
)
;
#
endif
}
ConversionRequired
NeedsConversion
(
)
const
override
{
return
ConversionRequired
:
:
kNeedAVCC
;
}
static
AVCodecID
GetCodecId
(
const
nsACString
&
aMimeType
)
;
private
:
RefPtr
<
FlushPromise
>
ProcessFlush
(
)
override
;
void
ProcessShutdown
(
)
override
;
MediaResult
DoDecode
(
MediaRawData
*
aSample
uint8_t
*
aData
int
aSize
bool
*
aGotFrame
DecodedData
&
aResults
)
override
;
void
OutputDelayedFrames
(
)
;
bool
NeedParser
(
)
const
override
{
return
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
58
false
;
#
else
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
55
mCodecID
=
=
AV_CODEC_ID_VP9
|
|
#
endif
mCodecID
=
=
AV_CODEC_ID_VP8
;
#
endif
}
gfx
:
:
YUVColorSpace
GetFrameColorSpace
(
)
;
MediaResult
CreateImage
(
int64_t
aOffset
int64_t
aPts
int64_t
aDuration
MediaDataDecoder
:
:
DecodedData
&
aResults
)
;
#
ifdef
MOZ_WAYLAND_USE_VAAPI
MediaResult
InitVAAPIDecoder
(
)
;
bool
CreateVAAPIDeviceContext
(
)
;
void
InitVAAPICodecContext
(
)
;
AVCodec
*
FindVAAPICodec
(
)
;
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
override
;
MediaResult
CreateImageVAAPI
(
int64_t
aOffset
int64_t
aPts
int64_t
aDuration
MediaDataDecoder
:
:
DecodedData
&
aResults
)
;
#
endif
int
AllocateYUV420PVideoBuffer
(
AVCodecContext
*
aCodecContext
AVFrame
*
aFrame
)
;
#
ifdef
MOZ_WAYLAND_USE_VAAPI
AVBufferRef
*
mVAAPIDeviceContext
;
const
bool
mDisableHardwareDecoding
;
VADisplay
mDisplay
;
#
endif
RefPtr
<
KnowsCompositor
>
mImageAllocator
;
RefPtr
<
ImageContainer
>
mImageContainer
;
VideoInfo
mInfo
;
class
PtsCorrectionContext
{
public
:
PtsCorrectionContext
(
)
;
int64_t
GuessCorrectPts
(
int64_t
aPts
int64_t
aDts
)
;
void
Reset
(
)
;
int64_t
LastDts
(
)
const
{
return
mLastDts
;
}
private
:
int64_t
mNumFaultyPts
;
int64_t
mNumFaultyDts
;
int64_t
mLastPts
;
int64_t
mLastDts
;
}
;
PtsCorrectionContext
mPtsContext
;
DurationMap
mDurationMap
;
const
bool
mLowLatency
;
}
;
}
#
endif
