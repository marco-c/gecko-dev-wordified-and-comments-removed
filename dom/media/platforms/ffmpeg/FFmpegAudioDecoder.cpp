#
include
"
FFmpegAudioDecoder
.
h
"
#
include
"
FFmpegLog
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
BufferReader
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
namespace
mozilla
{
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
FFmpegAudioDecoder
(
FFmpegLibWrapper
*
aLib
const
AudioInfo
&
aConfig
)
:
FFmpegDataDecoder
(
aLib
GetCodecId
(
aConfig
.
mMimeType
)
)
{
MOZ_COUNT_CTOR
(
FFmpegAudioDecoder
)
;
if
(
mCodecID
=
=
AV_CODEC_ID_AAC
&
&
aConfig
.
mCodecSpecificConfig
.
is
<
AacCodecSpecificData
>
(
)
)
{
const
AacCodecSpecificData
&
aacCodecSpecificData
=
aConfig
.
mCodecSpecificConfig
.
as
<
AacCodecSpecificData
>
(
)
;
mExtraData
=
new
MediaByteBuffer
;
mExtraData
-
>
AppendElements
(
*
aacCodecSpecificData
.
mDecoderConfigDescriptorBinaryBlob
)
;
mRemainingEncoderDelay
=
mEncoderDelay
=
aacCodecSpecificData
.
mEncoderDelayFrames
;
mEncoderPaddingOrTotalFrames
=
aacCodecSpecificData
.
mMediaFrameCount
;
FFMPEG_LOG
(
"
FFmpegAudioDecoder
(
aac
)
found
encoder
delay
(
%
"
PRIu32
"
)
and
total
frame
count
(
%
"
PRIu64
"
)
in
codec
-
specific
side
data
"
mEncoderDelay
TotalFrames
(
)
)
;
return
;
}
if
(
mCodecID
=
=
AV_CODEC_ID_MP3
)
{
MOZ_ASSERT
(
aConfig
.
mCodecSpecificConfig
.
is
<
Mp3CodecSpecificData
>
(
)
)
;
if
(
aConfig
.
mCodecSpecificConfig
.
is
<
Mp3CodecSpecificData
>
(
)
)
{
const
Mp3CodecSpecificData
&
mp3CodecSpecificData
=
aConfig
.
mCodecSpecificConfig
.
as
<
Mp3CodecSpecificData
>
(
)
;
mEncoderDelay
=
mRemainingEncoderDelay
=
mp3CodecSpecificData
.
mEncoderDelayFrames
;
mEncoderPaddingOrTotalFrames
=
mp3CodecSpecificData
.
mEncoderPaddingFrames
;
FFMPEG_LOG
(
"
FFmpegAudioDecoder
(
mp3
)
found
encoder
delay
(
%
"
PRIu32
"
)
"
"
and
padding
values
(
%
"
PRIu64
"
)
in
codec
-
specific
side
-
data
"
mEncoderDelay
Padding
(
)
)
;
return
;
}
}
if
(
mCodecID
=
=
AV_CODEC_ID_FLAC
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aConfig
.
mCodecSpecificConfig
.
is
<
FlacCodecSpecificData
>
(
)
)
;
if
(
aConfig
.
mCodecSpecificConfig
.
is
<
FlacCodecSpecificData
>
(
)
)
{
const
FlacCodecSpecificData
&
flacCodecSpecificData
=
aConfig
.
mCodecSpecificConfig
.
as
<
FlacCodecSpecificData
>
(
)
;
if
(
flacCodecSpecificData
.
mStreamInfoBinaryBlob
-
>
IsEmpty
(
)
)
{
return
;
}
mExtraData
=
new
MediaByteBuffer
;
mExtraData
-
>
AppendElements
(
*
flacCodecSpecificData
.
mStreamInfoBinaryBlob
)
;
return
;
}
}
RefPtr
<
MediaByteBuffer
>
audioCodecSpecificBinaryBlob
=
GetAudioCodecSpecificBlob
(
aConfig
.
mCodecSpecificConfig
)
;
if
(
audioCodecSpecificBinaryBlob
&
&
audioCodecSpecificBinaryBlob
-
>
Length
(
)
)
{
mExtraData
=
new
MediaByteBuffer
;
mExtraData
-
>
AppendElements
(
*
audioCodecSpecificBinaryBlob
)
;
}
}
RefPtr
<
MediaDataDecoder
:
:
InitPromise
>
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
Init
(
)
{
MediaResult
rv
=
InitDecoder
(
)
;
return
NS_SUCCEEDED
(
rv
)
?
InitPromise
:
:
CreateAndResolve
(
TrackInfo
:
:
kAudioTrack
__func__
)
:
InitPromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
void
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
InitCodecContext
(
)
{
MOZ_ASSERT
(
mCodecContext
)
;
mCodecContext
-
>
thread_count
=
1
;
#
ifdef
MOZ_SAMPLE_TYPE_S16
mCodecContext
-
>
request_sample_fmt
=
AV_SAMPLE_FMT_S16
;
#
else
mCodecContext
-
>
request_sample_fmt
=
(
mLib
-
>
mVersion
=
=
53
)
?
AV_SAMPLE_FMT_S16
:
AV_SAMPLE_FMT_FLT
;
#
endif
}
static
AlignedAudioBuffer
CopyAndPackAudio
(
AVFrame
*
aFrame
uint32_t
aNumChannels
uint32_t
aNumAFrames
)
{
AlignedAudioBuffer
audio
(
aNumChannels
*
aNumAFrames
)
;
if
(
!
audio
)
{
return
audio
;
}
#
ifdef
MOZ_SAMPLE_TYPE_S16
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_FLT
)
{
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
float
*
data
=
reinterpret_cast
<
float
*
*
>
(
aFrame
-
>
data
)
[
0
]
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
FloatToAudioSample
<
int16_t
>
(
*
data
+
+
)
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_FLTP
)
{
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
float
*
*
data
=
reinterpret_cast
<
float
*
*
>
(
aFrame
-
>
data
)
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
FloatToAudioSample
<
int16_t
>
(
data
[
channel
]
[
frame
]
)
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S16
)
{
memcpy
(
audio
.
get
(
)
aFrame
-
>
data
[
0
]
aNumChannels
*
aNumAFrames
*
sizeof
(
AudioDataValue
)
)
;
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S16P
)
{
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
AudioDataValue
*
*
data
=
reinterpret_cast
<
AudioDataValue
*
*
>
(
aFrame
-
>
data
)
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
data
[
channel
]
[
frame
]
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S32
)
{
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
int32_t
*
data
=
reinterpret_cast
<
int32_t
*
*
>
(
aFrame
-
>
data
)
[
0
]
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
*
data
+
+
/
(
1U
<
<
16
)
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S32P
)
{
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
int32_t
*
*
data
=
reinterpret_cast
<
int32_t
*
*
>
(
aFrame
-
>
data
)
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
data
[
channel
]
[
frame
]
/
(
1U
<
<
16
)
;
}
}
}
#
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_FLT
)
{
memcpy
(
audio
.
get
(
)
aFrame
-
>
data
[
0
]
aNumChannels
*
aNumAFrames
*
sizeof
(
AudioDataValue
)
)
;
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_FLTP
)
{
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
AudioDataValue
*
*
data
=
reinterpret_cast
<
AudioDataValue
*
*
>
(
aFrame
-
>
data
)
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
data
[
channel
]
[
frame
]
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S16
)
{
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
int16_t
*
data
=
reinterpret_cast
<
int16_t
*
*
>
(
aFrame
-
>
data
)
[
0
]
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
AudioSampleToFloat
(
*
data
+
+
)
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S16P
)
{
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
int16_t
*
*
data
=
reinterpret_cast
<
int16_t
*
*
>
(
aFrame
-
>
data
)
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
AudioSampleToFloat
(
data
[
channel
]
[
frame
]
)
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S32
)
{
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
int32_t
*
data
=
reinterpret_cast
<
int32_t
*
*
>
(
aFrame
-
>
data
)
[
0
]
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
AudioSampleToFloat
(
*
data
+
+
)
;
}
}
}
else
if
(
aFrame
-
>
format
=
=
AV_SAMPLE_FMT_S32P
)
{
AudioDataValue
*
tmp
=
audio
.
get
(
)
;
int32_t
*
*
data
=
reinterpret_cast
<
int32_t
*
*
>
(
aFrame
-
>
data
)
;
for
(
uint32_t
frame
=
0
;
frame
<
aNumAFrames
;
frame
+
+
)
{
for
(
uint32_t
channel
=
0
;
channel
<
aNumChannels
;
channel
+
+
)
{
*
tmp
+
+
=
AudioSampleToFloat
(
data
[
channel
]
[
frame
]
)
;
}
}
}
#
endif
return
audio
;
}
using
ChannelLayout
=
AudioConfig
:
:
ChannelLayout
;
uint64_t
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
Padding
(
)
const
{
MOZ_ASSERT
(
mCodecID
=
=
AV_CODEC_ID_MP3
)
;
return
mEncoderPaddingOrTotalFrames
;
}
uint64_t
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
TotalFrames
(
)
const
{
MOZ_ASSERT
(
mCodecID
=
=
AV_CODEC_ID_AAC
)
;
return
mEncoderPaddingOrTotalFrames
;
}
MediaResult
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
DoDecode
(
MediaRawData
*
aSample
uint8_t
*
aData
int
aSize
bool
*
aGotFrame
DecodedData
&
aResults
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
PROCESS_DECODE_LOG
(
aSample
)
;
AVPacket
packet
;
mLib
-
>
av_init_packet
(
&
packet
)
;
packet
.
data
=
const_cast
<
uint8_t
*
>
(
aData
)
;
packet
.
size
=
aSize
;
if
(
aGotFrame
)
{
*
aGotFrame
=
false
;
}
if
(
!
PrepareFrame
(
)
)
{
FFMPEG_LOG
(
"
FFmpegAudioDecoder
:
OOM
in
PrepareFrame
"
)
;
return
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
FFmpeg
audio
decoder
failed
to
allocate
frame
"
)
)
;
}
int64_t
samplePosition
=
aSample
-
>
mOffset
;
media
:
:
TimeUnit
pts
=
aSample
-
>
mTime
;
while
(
packet
.
size
>
0
)
{
int
decoded
=
false
;
int
bytesConsumed
=
-
1
;
#
if
LIBAVCODEC_VERSION_MAJOR
<
59
bytesConsumed
=
mLib
-
>
avcodec_decode_audio4
(
mCodecContext
mFrame
&
decoded
&
packet
)
;
if
(
bytesConsumed
<
0
)
{
NS_WARNING
(
"
FFmpeg
audio
decoder
error
.
"
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_DECODE_ERR
RESULT_DETAIL
(
"
FFmpeg
audio
error
:
%
d
"
bytesConsumed
)
)
;
}
#
else
#
define
AVRESULT_OK
0
int
ret
=
mLib
-
>
avcodec_send_packet
(
mCodecContext
&
packet
)
;
switch
(
ret
)
{
case
AVRESULT_OK
:
bytesConsumed
=
packet
.
size
;
break
;
case
AVERROR
(
EAGAIN
)
:
break
;
case
AVERROR_EOF
:
FFMPEG_LOG
(
"
End
of
stream
.
"
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_END_OF_STREAM
RESULT_DETAIL
(
"
End
of
stream
"
)
)
;
default
:
NS_WARNING
(
"
FFmpeg
audio
decoder
error
.
"
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_DECODE_ERR
RESULT_DETAIL
(
"
FFmpeg
audio
error
"
)
)
;
}
ret
=
mLib
-
>
avcodec_receive_frame
(
mCodecContext
mFrame
)
;
switch
(
ret
)
{
case
AVRESULT_OK
:
decoded
=
true
;
break
;
case
AVERROR
(
EAGAIN
)
:
break
;
case
AVERROR_EOF
:
{
FFMPEG_LOG
(
"
End
of
stream
.
"
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_END_OF_STREAM
RESULT_DETAIL
(
"
End
of
stream
"
)
)
;
}
}
#
endif
if
(
decoded
)
{
if
(
mFrame
-
>
format
!
=
AV_SAMPLE_FMT_FLT
&
&
mFrame
-
>
format
!
=
AV_SAMPLE_FMT_FLTP
&
&
mFrame
-
>
format
!
=
AV_SAMPLE_FMT_S16
&
&
mFrame
-
>
format
!
=
AV_SAMPLE_FMT_S16P
&
&
mFrame
-
>
format
!
=
AV_SAMPLE_FMT_S32
&
&
mFrame
-
>
format
!
=
AV_SAMPLE_FMT_S32P
)
{
return
MediaResult
(
NS_ERROR_DOM_MEDIA_DECODE_ERR
RESULT_DETAIL
(
"
FFmpeg
audio
decoder
outputs
unsupported
audio
format
"
)
)
;
}
uint32_t
numChannels
=
mCodecContext
-
>
channels
;
uint32_t
samplingRate
=
mCodecContext
-
>
sample_rate
;
AlignedAudioBuffer
audio
=
CopyAndPackAudio
(
mFrame
numChannels
mFrame
-
>
nb_samples
)
;
if
(
!
audio
)
{
FFMPEG_LOG
(
"
FFmpegAudioDecoder
:
OOM
"
)
;
return
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
}
DebugOnly
<
bool
>
trimmed
=
false
;
if
(
mEncoderDelay
)
{
trimmed
=
true
;
int
toPop
=
std
:
:
min
(
mFrame
-
>
nb_samples
static_cast
<
int
>
(
mRemainingEncoderDelay
)
)
;
audio
.
PopFront
(
toPop
*
numChannels
)
;
mFrame
-
>
nb_samples
-
=
toPop
;
mRemainingEncoderDelay
-
=
toPop
;
FFMPEG_LOG
(
"
FFmpegAudioDecoder
dropped
%
"
PRIu32
"
audio
frames
corresponding
to
the
encoder
delay
"
"
(
remaining
:
%
"
PRIu32
"
)
"
toPop
mRemainingEncoderDelay
)
;
}
mDecodedFrames
+
=
mFrame
-
>
nb_samples
;
if
(
mCodecID
=
=
AV_CODEC_ID_MP3
&
&
aSample
-
>
mEOS
&
&
Padding
(
)
)
{
trimmed
=
true
;
uint32_t
toTrim
=
std
:
:
min
(
static_cast
<
uint64_t
>
(
mFrame
-
>
nb_samples
)
Padding
(
)
)
;
audio
.
PopBack
(
toTrim
*
numChannels
)
;
MOZ_ASSERT
(
audio
.
Length
(
)
/
numChannels
<
=
INT32_MAX
)
;
mFrame
-
>
nb_samples
=
static_cast
<
int
>
(
audio
.
Length
(
)
/
numChannels
)
;
FFMPEG_LOG
(
"
FFmpegAudioDecoder
(
mp3
)
dropped
%
"
PRIu32
"
audio
frames
corresponding
to
the
padding
.
"
toTrim
)
;
}
if
(
mCodecID
=
=
AV_CODEC_ID_AAC
&
&
TotalFrames
(
)
&
&
mDecodedFrames
>
TotalFrames
(
)
)
{
trimmed
=
true
;
uint32_t
paddingFrames
=
std
:
:
min
(
mDecodedFrames
-
TotalFrames
(
)
static_cast
<
uint64_t
>
(
mFrame
-
>
nb_samples
)
)
;
audio
.
PopBack
(
paddingFrames
*
numChannels
)
;
MOZ_ASSERT
(
audio
.
Length
(
)
/
numChannels
<
=
INT32_MAX
)
;
mFrame
-
>
nb_samples
=
static_cast
<
int
>
(
audio
.
Length
(
)
/
numChannels
)
;
FFMPEG_LOG
(
"
FFmpegAudioDecoder
(
aac
)
dropped
%
"
PRIu32
"
audio
frames
corresponding
to
the
padding
.
"
paddingFrames
)
;
mDecodedFrames
=
0
;
mRemainingEncoderDelay
=
mEncoderDelay
;
}
media
:
:
TimeUnit
duration
=
FramesToTimeUnit
(
mFrame
-
>
nb_samples
samplingRate
)
;
if
(
!
duration
.
IsValid
(
)
)
{
FFMPEG_LOG
(
"
FFmpegAudioDecoder
:
invalid
duration
"
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
RESULT_DETAIL
(
"
Invalid
sample
duration
"
)
)
;
}
media
:
:
TimeUnit
newpts
=
pts
+
duration
;
if
(
!
newpts
.
IsValid
(
)
)
{
FFMPEG_LOG
(
"
FFmpegAudioDecoder
:
invalid
PTS
.
"
)
;
return
MediaResult
(
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
RESULT_DETAIL
(
"
Invalid
count
of
accumulated
audio
samples
"
)
)
;
}
RefPtr
<
AudioData
>
data
=
new
AudioData
(
samplePosition
pts
std
:
:
move
(
audio
)
numChannels
samplingRate
mCodecContext
-
>
channel_layout
)
;
MOZ_ASSERT
(
duration
=
=
data
-
>
mDuration
|
|
trimmed
"
must
be
equal
"
)
;
aResults
.
AppendElement
(
std
:
:
move
(
data
)
)
;
pts
=
newpts
;
if
(
aGotFrame
)
{
*
aGotFrame
=
true
;
}
}
if
(
bytesConsumed
!
=
-
1
)
{
packet
.
data
+
=
bytesConsumed
;
packet
.
size
-
=
bytesConsumed
;
samplePosition
+
=
bytesConsumed
;
}
}
return
NS_OK
;
}
AVCodecID
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
GetCodecId
(
const
nsACString
&
aMimeType
)
{
if
(
aMimeType
.
EqualsLiteral
(
"
audio
/
mpeg
"
)
)
{
#
ifdef
FFVPX_VERSION
if
(
!
StaticPrefs
:
:
media_ffvpx_mp3_enabled
(
)
)
{
return
AV_CODEC_ID_NONE
;
}
#
endif
return
AV_CODEC_ID_MP3
;
}
if
(
aMimeType
.
EqualsLiteral
(
"
audio
/
flac
"
)
)
{
return
AV_CODEC_ID_FLAC
;
}
if
(
aMimeType
.
EqualsLiteral
(
"
audio
/
mp4a
-
latm
"
)
)
{
return
AV_CODEC_ID_AAC
;
}
return
AV_CODEC_ID_NONE
;
}
nsCString
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
GetCodecName
(
)
const
{
#
if
LIBAVCODEC_VERSION_MAJOR
>
53
return
nsCString
(
mLib
-
>
avcodec_descriptor_get
(
mCodecID
)
-
>
name
)
;
#
else
return
"
unknown
"
_ns
;
#
endif
}
FFmpegAudioDecoder
<
LIBAV_VER
>
:
:
~
FFmpegAudioDecoder
(
)
{
MOZ_COUNT_DTOR
(
FFmpegAudioDecoder
)
;
}
}
