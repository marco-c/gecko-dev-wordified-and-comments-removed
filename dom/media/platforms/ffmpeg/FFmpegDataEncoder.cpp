#
include
"
FFmpegDataEncoder
.
h
"
#
include
"
PlatformEncoderModule
.
h
"
#
include
<
utility
>
#
include
"
FFmpegLog
.
h
"
#
include
"
libavutil
/
error
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
FFmpegUtils
.
h
"
namespace
mozilla
{
static
AVCodec
*
FindEncoderWithPreference
(
const
FFmpegLibWrapper
*
aLib
AVCodecID
aCodecId
)
{
MOZ_ASSERT
(
aLib
)
;
AVCodec
*
codec
=
nullptr
;
if
(
aCodecId
=
=
AV_CODEC_ID_H264
)
{
codec
=
aLib
-
>
avcodec_find_encoder_by_name
(
"
libx264
"
)
;
if
(
codec
)
{
FFMPEGV_LOG
(
"
Prefer
libx264
for
h264
codec
"
)
;
return
codec
;
}
}
FFMPEGV_LOG
(
"
Fallback
to
other
h264
library
.
Fingers
crossed
"
)
;
return
aLib
-
>
avcodec_find_encoder
(
aCodecId
)
;
}
template
<
>
AVCodecID
GetFFmpegEncoderCodecId
<
LIBAV_VER
>
(
CodecType
aCodec
)
{
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
58
if
(
aCodec
=
=
CodecType
:
:
VP8
)
{
return
AV_CODEC_ID_VP8
;
}
if
(
aCodec
=
=
CodecType
:
:
VP9
)
{
return
AV_CODEC_ID_VP9
;
}
#
if
!
defined
(
USING_MOZFFVPX
)
if
(
aCodec
=
=
CodecType
:
:
H264
)
{
return
AV_CODEC_ID_H264
;
}
#
endif
if
(
aCodec
=
=
CodecType
:
:
AV1
)
{
return
AV_CODEC_ID_AV1
;
}
#
endif
return
AV_CODEC_ID_NONE
;
}
StaticMutex
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
sMutex
;
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
FFmpegDataEncoder
(
const
FFmpegLibWrapper
*
aLib
AVCodecID
aCodecID
const
RefPtr
<
TaskQueue
>
&
aTaskQueue
const
EncoderConfig
&
aConfig
)
:
mLib
(
aLib
)
mCodecID
(
aCodecID
)
mTaskQueue
(
aTaskQueue
)
mConfig
(
aConfig
)
mCodecName
(
EmptyCString
(
)
)
mCodecContext
(
nullptr
)
mFrame
(
nullptr
)
mVideoCodec
(
IsVideoCodec
(
aCodecID
)
)
{
MOZ_ASSERT
(
mLib
)
;
MOZ_ASSERT
(
mTaskQueue
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
<
58
MOZ_CRASH
(
"
FFmpegDataEncoder
needs
ffmpeg
58
at
least
.
"
)
;
#
endif
}
;
RefPtr
<
MediaDataEncoder
:
:
InitPromise
>
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
Init
(
)
{
FFMPEG_LOG
(
"
Init
"
)
;
return
InvokeAsync
(
mTaskQueue
this
__func__
&
FFmpegDataEncoder
:
:
ProcessInit
)
;
}
RefPtr
<
MediaDataEncoder
:
:
EncodePromise
>
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
Encode
(
const
MediaData
*
aSample
)
{
MOZ_ASSERT
(
aSample
!
=
nullptr
)
;
FFMPEG_LOG
(
"
Encode
"
)
;
return
InvokeAsync
(
mTaskQueue
__func__
[
self
=
RefPtr
<
FFmpegDataEncoder
<
LIBAV_VER
>
>
(
this
)
sample
=
RefPtr
<
const
MediaData
>
(
aSample
)
]
(
)
{
return
self
-
>
ProcessEncode
(
sample
)
;
}
)
;
}
RefPtr
<
MediaDataEncoder
:
:
ReconfigurationPromise
>
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
Reconfigure
(
const
RefPtr
<
const
EncoderConfigurationChangeList
>
&
aConfigurationChanges
)
{
return
InvokeAsync
<
const
RefPtr
<
const
EncoderConfigurationChangeList
>
>
(
mTaskQueue
this
__func__
&
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
ProcessReconfigure
aConfigurationChanges
)
;
}
RefPtr
<
MediaDataEncoder
:
:
EncodePromise
>
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
Drain
(
)
{
FFMPEG_LOG
(
"
Drain
"
)
;
return
InvokeAsync
(
mTaskQueue
this
__func__
&
FFmpegDataEncoder
:
:
ProcessDrain
)
;
}
RefPtr
<
ShutdownPromise
>
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
Shutdown
(
)
{
FFMPEG_LOG
(
"
Shutdown
"
)
;
return
InvokeAsync
(
mTaskQueue
this
__func__
&
FFmpegDataEncoder
:
:
ProcessShutdown
)
;
}
RefPtr
<
GenericPromise
>
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
SetBitrate
(
uint32_t
aBitrate
)
{
FFMPEG_LOG
(
"
SetBitrate
"
)
;
return
GenericPromise
:
:
CreateAndReject
(
NS_ERROR_NOT_IMPLEMENTED
__func__
)
;
}
RefPtr
<
MediaDataEncoder
:
:
InitPromise
>
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
ProcessInit
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEG_LOG
(
"
ProcessInit
"
)
;
MediaResult
r
=
InitSpecific
(
)
;
return
NS_FAILED
(
r
)
?
InitPromise
:
:
CreateAndReject
(
r
__func__
)
:
InitPromise
:
:
CreateAndResolve
(
TrackInfo
:
:
kVideoTrack
__func__
)
;
}
RefPtr
<
MediaDataEncoder
:
:
EncodePromise
>
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
ProcessEncode
(
RefPtr
<
const
MediaData
>
aSample
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEG_LOG
(
"
ProcessEncode
"
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
<
58
MOZ_CRASH
(
"
FFmpegDataEncoder
needs
ffmpeg
58
at
least
.
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
NS_ERROR_NOT_IMPLEMENTED
__func__
)
;
#
else
return
EncodeWithModernAPIs
(
aSample
)
;
#
endif
}
RefPtr
<
MediaDataEncoder
:
:
ReconfigurationPromise
>
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
ProcessReconfigure
(
const
RefPtr
<
const
EncoderConfigurationChangeList
>
&
aConfigurationChanges
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEG_LOG
(
"
ProcessReconfigure
"
)
;
return
MediaDataEncoder
:
:
ReconfigurationPromise
:
:
CreateAndReject
(
NS_ERROR_NOT_IMPLEMENTED
__func__
)
;
}
RefPtr
<
MediaDataEncoder
:
:
EncodePromise
>
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
ProcessDrain
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEG_LOG
(
"
ProcessDrain
"
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
<
58
MOZ_CRASH
(
"
FFmpegDataEncoder
needs
ffmpeg
58
at
least
.
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
NS_ERROR_NOT_IMPLEMENTED
__func__
)
;
#
else
return
DrainWithModernAPIs
(
)
;
#
endif
}
RefPtr
<
ShutdownPromise
>
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
ProcessShutdown
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEG_LOG
(
"
ProcessShutdown
"
)
;
ShutdownInternal
(
)
;
return
ShutdownPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
AVCodec
*
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
InitCommon
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEG_LOG
(
"
FFmpegDataEncoder
:
:
InitCommon
"
)
;
AVCodec
*
codec
=
FindEncoderWithPreference
(
mLib
mCodecID
)
;
if
(
!
codec
)
{
FFMPEG_LOG
(
"
failed
to
find
ffmpeg
encoder
for
codec
id
%
d
"
mCodecID
)
;
return
nullptr
;
}
FFMPEG_LOG
(
"
found
codec
:
%
s
"
codec
-
>
name
)
;
mCodecName
=
codec
-
>
name
;
ForceEnablingFFmpegDebugLogs
(
)
;
MOZ_ASSERT
(
!
mCodecContext
)
;
if
(
!
(
mCodecContext
=
mLib
-
>
avcodec_alloc_context3
(
codec
)
)
)
{
FFMPEG_LOG
(
"
failed
to
allocate
ffmpeg
context
for
codec
%
s
"
codec
-
>
name
)
;
return
nullptr
;
}
return
codec
;
}
MediaResult
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
FinishInitCommon
(
AVCodec
*
aCodec
)
{
mCodecContext
-
>
bit_rate
=
static_cast
<
FFmpegBitRate
>
(
mConfig
.
mBitrate
)
;
mCodecContext
-
>
time_base
=
AVRational
{
.
num
=
1
.
den
=
static_cast
<
int
>
(
USECS_PER_S
)
}
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
60
mCodecContext
-
>
flags
|
=
AV_CODEC_FLAG_FRAME_DURATION
;
#
endif
AVDictionary
*
options
=
nullptr
;
if
(
int
ret
=
OpenCodecContext
(
aCodec
&
options
)
;
ret
<
0
)
{
FFMPEG_LOG
(
"
failed
to
open
%
s
avcodec
:
%
s
"
aCodec
-
>
name
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
avcodec_open2
error
"
)
)
;
}
mLib
-
>
av_dict_free
(
&
options
)
;
return
MediaResult
(
NS_OK
)
;
}
void
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
ShutdownInternal
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
FFMPEG_LOG
(
"
ShutdownInternal
"
)
;
DestroyFrame
(
)
;
if
(
mCodecContext
)
{
CloseCodecContext
(
)
;
mLib
-
>
av_freep
(
&
mCodecContext
)
;
mCodecContext
=
nullptr
;
}
}
int
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
OpenCodecContext
(
const
AVCodec
*
aCodec
AVDictionary
*
*
aOptions
)
{
MOZ_ASSERT
(
mCodecContext
)
;
StaticMutexAutoLock
mon
(
sMutex
)
;
return
mLib
-
>
avcodec_open2
(
mCodecContext
aCodec
aOptions
)
;
}
void
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
CloseCodecContext
(
)
{
MOZ_ASSERT
(
mCodecContext
)
;
StaticMutexAutoLock
mon
(
sMutex
)
;
mLib
-
>
avcodec_close
(
mCodecContext
)
;
}
bool
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
PrepareFrame
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
55
if
(
mFrame
)
{
mLib
-
>
av_frame_unref
(
mFrame
)
;
}
else
{
mFrame
=
mLib
-
>
av_frame_alloc
(
)
;
}
#
elif
LIBAVCODEC_VERSION_MAJOR
=
=
54
if
(
mFrame
)
{
mLib
-
>
avcodec_get_frame_defaults
(
mFrame
)
;
}
else
{
mFrame
=
mLib
-
>
avcodec_alloc_frame
(
)
;
}
#
else
mLib
-
>
av_freep
(
&
mFrame
)
;
mFrame
=
mLib
-
>
avcodec_alloc_frame
(
)
;
#
endif
return
!
!
mFrame
;
}
void
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
DestroyFrame
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
if
(
mFrame
)
{
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
55
mLib
-
>
av_frame_unref
(
mFrame
)
;
mLib
-
>
av_frame_free
(
&
mFrame
)
;
#
elif
LIBAVCODEC_VERSION_MAJOR
=
=
54
mLib
-
>
avcodec_free_frame
(
&
mFrame
)
;
#
else
mLib
-
>
av_freep
(
&
mFrame
)
;
#
endif
mFrame
=
nullptr
;
}
}
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
58
RefPtr
<
MediaDataEncoder
:
:
EncodePromise
>
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
EncodeWithModernAPIs
(
RefPtr
<
const
MediaData
>
aSample
)
{
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
59
mFrame
-
>
time_base
=
AVRational
{
.
num
=
1
.
den
=
static_cast
<
int
>
(
USECS_PER_S
)
}
;
#
endif
mFrame
-
>
pts
=
aSample
-
>
mTime
.
ToMicroseconds
(
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
60
mFrame
-
>
duration
=
aSample
-
>
mDuration
.
ToMicroseconds
(
)
;
#
else
mDurationMap
.
Insert
(
mFrame
-
>
pts
aSample
-
>
mDuration
.
ToMicroseconds
(
)
)
;
#
endif
mFrame
-
>
pkt_duration
=
aSample
-
>
mDuration
.
ToMicroseconds
(
)
;
AVPacket
*
pkt
=
mLib
-
>
av_packet_alloc
(
)
;
if
(
!
pkt
)
{
FFMPEG_LOG
(
"
failed
to
allocate
packet
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
Unable
to
allocate
packet
"
)
)
__func__
)
;
}
auto
freePacket
=
MakeScopeExit
(
[
this
&
pkt
]
{
mLib
-
>
av_packet_free
(
&
pkt
)
;
}
)
;
if
(
int
ret
=
mLib
-
>
avcodec_send_frame
(
mCodecContext
mFrame
)
;
ret
<
0
)
{
FFMPEG_LOG
(
"
avcodec_send_frame
error
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
avcodec_send_frame
error
"
)
)
__func__
)
;
}
EncodedData
output
;
while
(
true
)
{
int
ret
=
mLib
-
>
avcodec_receive_packet
(
mCodecContext
pkt
)
;
if
(
ret
=
=
AVERROR
(
EAGAIN
)
)
{
FFMPEG_LOG
(
"
encoder
is
asking
for
more
input
!
"
)
;
break
;
}
if
(
ret
<
0
)
{
FFMPEG_LOG
(
"
avcodec_receive_packet
error
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
avcodec_receive_packet
error
"
)
)
__func__
)
;
}
RefPtr
<
MediaRawData
>
d
=
ToMediaRawData
(
pkt
)
;
mLib
-
>
av_packet_unref
(
pkt
)
;
if
(
!
d
)
{
FFMPEGV_LOG
(
"
failed
to
create
a
MediaRawData
from
the
AVPacket
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
Unable
to
get
MediaRawData
from
AVPacket
"
)
)
__func__
)
;
}
output
.
AppendElement
(
std
:
:
move
(
d
)
)
;
}
FFMPEG_LOG
(
"
Got
%
zu
encoded
data
"
output
.
Length
(
)
)
;
return
EncodePromise
:
:
CreateAndResolve
(
std
:
:
move
(
output
)
__func__
)
;
}
RefPtr
<
MediaDataEncoder
:
:
EncodePromise
>
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
DrainWithModernAPIs
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
mCodecContext
)
;
AVPacket
*
pkt
=
mLib
-
>
av_packet_alloc
(
)
;
if
(
!
pkt
)
{
FFMPEG_LOG
(
"
failed
to
allocate
packet
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
Unable
to
allocate
packet
"
)
)
__func__
)
;
}
auto
freePacket
=
MakeScopeExit
(
[
this
&
pkt
]
{
mLib
-
>
av_packet_free
(
&
pkt
)
;
}
)
;
if
(
int
ret
=
mLib
-
>
avcodec_send_frame
(
mCodecContext
nullptr
)
;
ret
<
0
)
{
if
(
ret
=
=
AVERROR_EOF
)
{
FFMPEG_LOG
(
"
encoder
has
been
flushed
!
"
)
;
return
EncodePromise
:
:
CreateAndResolve
(
EncodedData
(
)
__func__
)
;
}
FFMPEG_LOG
(
"
avcodec_send_frame
error
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
avcodec_send_frame
error
"
)
)
__func__
)
;
}
EncodedData
output
;
while
(
true
)
{
int
ret
=
mLib
-
>
avcodec_receive_packet
(
mCodecContext
pkt
)
;
if
(
ret
=
=
AVERROR_EOF
)
{
FFMPEG_LOG
(
"
encoder
has
no
more
output
packet
!
"
)
;
break
;
}
if
(
ret
<
0
)
{
FFMPEG_LOG
(
"
avcodec_receive_packet
error
:
%
s
"
MakeErrorString
(
mLib
ret
)
.
get
(
)
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
RESULT_DETAIL
(
"
avcodec_receive_packet
error
"
)
)
__func__
)
;
}
RefPtr
<
MediaRawData
>
d
=
ToMediaRawData
(
pkt
)
;
mLib
-
>
av_packet_unref
(
pkt
)
;
if
(
!
d
)
{
FFMPEG_LOG
(
"
failed
to
create
a
MediaRawData
from
the
AVPacket
"
)
;
return
EncodePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
RESULT_DETAIL
(
"
Unable
to
get
MediaRawData
from
AVPacket
"
)
)
__func__
)
;
}
output
.
AppendElement
(
std
:
:
move
(
d
)
)
;
}
FFMPEG_LOG
(
"
Encoding
successful
%
zu
packets
"
output
.
Length
(
)
)
;
ShutdownInternal
(
)
;
MediaResult
r
=
InitSpecific
(
)
;
return
NS_FAILED
(
r
)
?
EncodePromise
:
:
CreateAndReject
(
r
__func__
)
:
EncodePromise
:
:
CreateAndResolve
(
std
:
:
move
(
output
)
__func__
)
;
}
#
endif
RefPtr
<
MediaRawData
>
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
ToMediaRawDataCommon
(
AVPacket
*
aPacket
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
aPacket
)
;
auto
data
=
MakeRefPtr
<
MediaRawData
>
(
)
;
UniquePtr
<
MediaRawDataWriter
>
writer
(
data
-
>
CreateWriter
(
)
)
;
if
(
!
writer
-
>
Append
(
aPacket
-
>
data
static_cast
<
size_t
>
(
aPacket
-
>
size
)
)
)
{
FFMPEG_LOG
(
"
fail
to
allocate
MediaRawData
buffer
"
)
;
return
nullptr
;
}
data
-
>
mKeyframe
=
(
aPacket
-
>
flags
&
AV_PKT_FLAG_KEY
)
!
=
0
;
data
-
>
mTime
=
media
:
:
TimeUnit
:
:
FromMicroseconds
(
aPacket
-
>
pts
)
;
#
if
LIBAVCODEC_VERSION_MAJOR
>
=
60
data
-
>
mDuration
=
media
:
:
TimeUnit
:
:
FromMicroseconds
(
aPacket
-
>
duration
)
;
#
else
int64_t
duration
;
if
(
mDurationMap
.
Find
(
aPacket
-
>
pts
duration
)
)
{
data
-
>
mDuration
=
media
:
:
TimeUnit
:
:
FromMicroseconds
(
duration
)
;
}
else
{
data
-
>
mDuration
=
media
:
:
TimeUnit
:
:
FromMicroseconds
(
aPacket
-
>
duration
)
;
}
#
endif
data
-
>
mTimecode
=
media
:
:
TimeUnit
:
:
FromMicroseconds
(
aPacket
-
>
dts
)
;
if
(
auto
r
=
GetExtraData
(
aPacket
)
;
r
.
isOk
(
)
)
{
data
-
>
mExtraData
=
r
.
unwrap
(
)
;
}
return
data
;
}
void
FFmpegDataEncoder
<
LIBAV_VER
>
:
:
ForceEnablingFFmpegDebugLogs
(
)
{
#
if
DEBUG
if
(
!
getenv
(
"
MOZ_AV_LOG_LEVEL
"
)
&
&
MOZ_LOG_TEST
(
sFFmpegVideoLog
LogLevel
:
:
Debug
)
)
{
mLib
-
>
av_log_set_level
(
AV_LOG_DEBUG
)
;
}
#
endif
}
}
