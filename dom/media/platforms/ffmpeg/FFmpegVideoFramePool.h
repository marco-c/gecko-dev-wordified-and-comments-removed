#
ifndef
__FFmpegVideoFramePool_h__
#
define
__FFmpegVideoFramePool_h__
#
include
"
FFmpegLibWrapper
.
h
"
#
include
"
FFmpegLibs
.
h
"
#
include
"
FFmpegLog
.
h
"
#
include
"
mozilla
/
layers
/
DMABUFSurfaceImage
.
h
"
#
include
"
mozilla
/
widget
/
DMABufLibWrapper
.
h
"
#
include
"
mozilla
/
widget
/
DMABufSurface
.
h
"
namespace
mozilla
:
:
layers
{
class
PlanarYCbCrImage
;
}
namespace
mozilla
{
template
<
int
V
>
class
VideoFrameSurface
{
}
;
template
<
>
class
VideoFrameSurface
<
LIBAV_VER
>
;
template
<
int
V
>
class
VideoFramePool
{
}
;
template
<
>
class
VideoFramePool
<
LIBAV_VER
>
;
template
<
>
class
VideoFrameSurface
<
LIBAV_VER
>
{
friend
class
VideoFramePool
<
LIBAV_VER
>
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
VideoFrameSurface
)
explicit
VideoFrameSurface
(
DMABufSurface
*
aSurface
VASurfaceID
aFFMPEGSurfaceID
)
;
void
SetYUVColorSpace
(
mozilla
:
:
gfx
:
:
YUVColorSpace
aColorSpace
)
{
mSurface
-
>
GetAsDMABufSurfaceYUV
(
)
-
>
SetYUVColorSpace
(
aColorSpace
)
;
}
void
SetColorRange
(
mozilla
:
:
gfx
:
:
ColorRange
aColorRange
)
{
mSurface
-
>
GetAsDMABufSurfaceYUV
(
)
-
>
SetColorRange
(
aColorRange
)
;
}
void
SetColorPrimaries
(
mozilla
:
:
gfx
:
:
ColorSpace2
aColorPrimaries
)
{
mSurface
-
>
GetAsDMABufSurfaceYUV
(
)
-
>
SetColorPrimaries
(
aColorPrimaries
)
;
}
void
SetTransferFunction
(
mozilla
:
:
gfx
:
:
TransferFunction
aTransferFunction
)
{
mSurface
-
>
GetAsDMABufSurfaceYUV
(
)
-
>
SetTransferFunction
(
aTransferFunction
)
;
}
RefPtr
<
DMABufSurfaceYUV
>
GetDMABufSurface
(
)
{
return
mSurface
-
>
GetAsDMABufSurfaceYUV
(
)
;
}
;
RefPtr
<
layers
:
:
Image
>
GetAsImage
(
)
;
VideoFrameSurface
(
const
VideoFrameSurface
&
)
=
delete
;
const
VideoFrameSurface
&
operator
=
(
VideoFrameSurface
const
&
)
=
delete
;
void
DisableRecycle
(
)
;
protected
:
void
LockVAAPIData
(
AVCodecContext
*
aAVCodecContext
AVFrame
*
aAVFrame
FFmpegLibWrapper
*
aLib
)
;
void
ReleaseVAAPIData
(
bool
aForFrameRecycle
=
true
)
;
bool
IsUsedByRenderer
(
)
const
{
return
mSurface
-
>
IsGlobalRefSet
(
)
;
}
bool
IsFFMPEGSurface
(
)
const
{
return
!
!
mLib
;
}
private
:
virtual
~
VideoFrameSurface
(
)
;
const
RefPtr
<
DMABufSurface
>
mSurface
;
const
FFmpegLibWrapper
*
mLib
;
AVBufferRef
*
mAVHWFrameContext
;
AVBufferRef
*
mHWAVBuffer
;
VASurfaceID
mFFMPEGSurfaceID
;
bool
mHoldByFFmpeg
;
}
;
template
<
>
class
VideoFramePool
<
LIBAV_VER
>
{
public
:
explicit
VideoFramePool
(
int
aFFMPEGPoolSize
)
;
~
VideoFramePool
(
)
;
RefPtr
<
VideoFrameSurface
<
LIBAV_VER
>
>
GetVideoFrameSurface
(
VADRMPRIMESurfaceDescriptor
&
aVaDesc
int
aWidth
int
aHeight
AVCodecContext
*
aAVCodecContext
AVFrame
*
aAVFrame
FFmpegLibWrapper
*
aLib
)
;
RefPtr
<
VideoFrameSurface
<
LIBAV_VER
>
>
GetVideoFrameSurface
(
AVDRMFrameDescriptor
&
aDesc
int
aWidth
int
aHeight
AVCodecContext
*
aAVCodecContext
AVFrame
*
aAVFrame
FFmpegLibWrapper
*
aLib
)
;
RefPtr
<
VideoFrameSurface
<
LIBAV_VER
>
>
GetVideoFrameSurface
(
const
layers
:
:
PlanarYCbCrData
&
aData
AVCodecContext
*
aAVCodecContext
)
;
void
ReleaseUnusedVAAPIFrames
(
)
;
void
FlushFFmpegFrames
(
)
;
private
:
RefPtr
<
VideoFrameSurface
<
LIBAV_VER
>
>
GetTargetVideoFrameSurfaceLocked
(
const
MutexAutoLock
&
aProofOfLock
VASurfaceID
aFFmpegSurfaceID
bool
aRecycleSurface
)
;
RefPtr
<
VideoFrameSurface
<
LIBAV_VER
>
>
GetFFmpegVideoFrameSurfaceLocked
(
const
MutexAutoLock
&
aProofOfLock
VASurfaceID
aFFMPEGSurfaceID
)
;
RefPtr
<
VideoFrameSurface
<
LIBAV_VER
>
>
GetFreeVideoFrameSurfaceLocked
(
const
MutexAutoLock
&
aProofOfLock
)
;
bool
ShouldCopySurface
(
)
;
private
:
Mutex
mSurfaceLock
MOZ_UNANNOTATED
;
nsTArray
<
RefPtr
<
VideoFrameSurface
<
LIBAV_VER
>
>
>
mDMABufSurfaces
;
int
mMaxFFMPEGPoolSize
;
Maybe
<
bool
>
mTextureCreationWorks
;
bool
mTextureCopyWorks
=
true
;
}
;
}
#
endif
