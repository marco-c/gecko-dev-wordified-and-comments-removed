#
ifndef
__FFmpegVideoFramePool_h__
#
define
__FFmpegVideoFramePool_h__
#
include
"
FFmpegVideoDecoder
.
h
"
#
include
"
FFmpegLibWrapper
.
h
"
#
include
"
mozilla
/
layers
/
DMABUFSurfaceImage
.
h
"
#
include
"
mozilla
/
widget
/
DMABufLibWrapper
.
h
"
#
include
"
mozilla
/
widget
/
DMABufSurface
.
h
"
namespace
mozilla
{
class
VideoFramePool
;
class
VideoFrameSurfaceDMABuf
;
class
VideoFrameSurfaceVAAPI
;
class
VideoFrameSurface
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
VideoFrameSurface
)
VideoFrameSurface
(
)
=
default
;
virtual
VideoFrameSurfaceDMABuf
*
AsVideoFrameSurfaceDMABuf
(
)
{
return
nullptr
;
}
virtual
VideoFrameSurfaceVAAPI
*
AsVideoFrameSurfaceVAAPI
(
)
{
return
nullptr
;
}
virtual
void
SetYUVColorSpace
(
gfx
:
:
YUVColorSpace
aColorSpace
)
=
0
;
virtual
void
SetColorRange
(
gfx
:
:
ColorRange
aColorRange
)
=
0
;
virtual
RefPtr
<
DMABufSurfaceYUV
>
GetDMABufSurface
(
)
{
return
nullptr
;
}
;
virtual
RefPtr
<
layers
:
:
Image
>
GetAsImage
(
)
=
0
;
VideoFrameSurface
(
const
VideoFrameSurface
&
)
=
delete
;
const
VideoFrameSurface
&
operator
=
(
VideoFrameSurface
const
&
)
=
delete
;
protected
:
virtual
~
VideoFrameSurface
(
)
{
}
;
}
;
class
VideoFrameSurfaceDMABuf
:
public
VideoFrameSurface
{
friend
class
VideoFramePool
;
public
:
explicit
VideoFrameSurfaceDMABuf
(
DMABufSurface
*
aSurface
)
;
VideoFrameSurfaceDMABuf
*
AsVideoFrameSurfaceDMABuf
(
)
final
{
return
this
;
}
void
SetYUVColorSpace
(
gfx
:
:
YUVColorSpace
aColorSpace
)
final
{
mSurface
-
>
GetAsDMABufSurfaceYUV
(
)
-
>
SetYUVColorSpace
(
aColorSpace
)
;
}
void
SetColorRange
(
gfx
:
:
ColorRange
aColorRange
)
final
{
mSurface
-
>
GetAsDMABufSurfaceYUV
(
)
-
>
SetColorRange
(
aColorRange
)
;
}
RefPtr
<
DMABufSurfaceYUV
>
GetDMABufSurface
(
)
final
{
return
mSurface
-
>
GetAsDMABufSurfaceYUV
(
)
;
}
;
RefPtr
<
layers
:
:
Image
>
GetAsImage
(
)
final
;
protected
:
bool
IsUsed
(
)
const
{
return
mSurface
-
>
IsGlobalRefSet
(
)
;
}
void
MarkAsUsed
(
)
{
mSurface
-
>
GlobalRefAdd
(
)
;
}
protected
:
const
RefPtr
<
DMABufSurface
>
mSurface
;
virtual
~
VideoFrameSurfaceDMABuf
(
)
=
default
;
}
;
class
VideoFrameSurfaceVAAPI
final
:
public
VideoFrameSurfaceDMABuf
{
friend
class
VideoFramePool
;
public
:
explicit
VideoFrameSurfaceVAAPI
(
DMABufSurface
*
aSurface
)
;
VideoFrameSurfaceVAAPI
*
AsVideoFrameSurfaceVAAPI
(
)
final
{
return
this
;
}
protected
:
void
LockVAAPIData
(
AVCodecContext
*
aAVCodecContext
AVFrame
*
aAVFrame
FFmpegLibWrapper
*
aLib
)
;
void
ReleaseVAAPIData
(
bool
aForFrameRecycle
=
true
)
;
private
:
virtual
~
VideoFrameSurfaceVAAPI
(
)
;
const
FFmpegLibWrapper
*
mLib
;
AVBufferRef
*
mAVHWFramesContext
;
AVBufferRef
*
mHWAVBuffer
;
}
;
class
VideoFramePool
final
{
public
:
explicit
VideoFramePool
(
bool
aUseVAAPI
)
;
~
VideoFramePool
(
)
;
RefPtr
<
VideoFrameSurface
>
GetVideoFrameSurface
(
VADRMPRIMESurfaceDescriptor
&
aVaDesc
AVCodecContext
*
aAVCodecContext
AVFrame
*
aAVFrame
FFmpegLibWrapper
*
aLib
)
;
RefPtr
<
VideoFrameSurface
>
GetVideoFrameSurface
(
AVPixelFormat
aPixelFormat
AVFrame
*
aFrame
)
;
void
ReleaseUnusedVAAPIFrames
(
)
;
private
:
RefPtr
<
VideoFrameSurface
>
GetFreeVideoFrameSurface
(
)
;
private
:
const
bool
mUseVAAPI
;
Mutex
mSurfaceLock
;
nsTArray
<
RefPtr
<
VideoFrameSurfaceDMABuf
>
>
mDMABufSurfaces
;
Maybe
<
bool
>
mTextureCreationWorks
;
}
;
}
#
endif
