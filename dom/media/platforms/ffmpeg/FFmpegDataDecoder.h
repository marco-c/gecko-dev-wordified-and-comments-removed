#
ifndef
__FFmpegDataDecoder_h__
#
define
__FFmpegDataDecoder_h__
#
include
"
FFmpegLibWrapper
.
h
"
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
FFmpegLibs
.
h
"
namespace
mozilla
{
#
if
defined
(
MOZ_WIDGET_ANDROID
)
&
&
defined
(
USING_MOZFFVPX
)
class
MediaDrmCrypto
;
class
MediaDrmRemoteCDMParent
;
#
endif
template
<
int
V
>
class
FFmpegDataDecoder
:
public
MediaDataDecoder
{
}
;
template
<
>
class
FFmpegDataDecoder
<
LIBAV_VER
>
;
DDLoggedTypeNameAndBase
(
FFmpegDataDecoder
<
LIBAV_VER
>
MediaDataDecoder
)
;
template
<
>
class
FFmpegDataDecoder
<
LIBAV_VER
>
:
public
MediaDataDecoder
public
DecoderDoctorLifeLogger
<
FFmpegDataDecoder
<
LIBAV_VER
>
>
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
FFmpegDataDecoder
final
)
;
FFmpegDataDecoder
(
const
FFmpegLibWrapper
*
aLib
AVCodecID
aCodecID
PRemoteCDMActor
*
aCDM
)
;
static
bool
Link
(
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
=
0
;
RefPtr
<
DecodePromise
>
Decode
(
MediaRawData
*
aSample
)
override
;
RefPtr
<
DecodePromise
>
Drain
(
)
override
;
RefPtr
<
FlushPromise
>
Flush
(
)
override
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
static
AVCodec
*
FindSoftwareAVCodec
(
const
FFmpegLibWrapper
*
aLib
AVCodecID
aCodec
)
;
#
ifdef
MOZ_USE_HWDECODE
static
AVCodec
*
FindHardwareAVCodec
(
const
FFmpegLibWrapper
*
aLib
AVCodecID
aCodec
AVHWDeviceType
aDeviceType
=
AV_HWDEVICE_TYPE_NONE
)
;
#
endif
protected
:
virtual
RefPtr
<
FlushPromise
>
ProcessFlush
(
)
;
virtual
void
ProcessShutdown
(
)
;
virtual
void
InitCodecContext
(
)
MOZ_REQUIRES
(
sMutex
)
{
}
void
ReleaseCodecContext
(
)
MOZ_REQUIRES
(
sMutex
)
;
AVFrame
*
PrepareFrame
(
)
;
MediaResult
InitSWDecoder
(
AVDictionary
*
*
aOptions
)
;
MediaResult
InitDecoder
(
AVCodec
*
aCodec
AVDictionary
*
*
aOptions
)
;
MediaResult
AllocateExtraData
(
)
;
MediaResult
DoDecode
(
MediaRawData
*
aSample
bool
*
aGotFrame
DecodedData
&
aResults
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
&
&
defined
(
USING_MOZFFVPX
)
static
void
CryptoInfoAddRef
(
void
*
aCryptoInfo
)
;
static
void
CryptoInfoRelease
(
void
*
aCryptoInfo
)
;
MediaResult
MaybeAttachCryptoInfo
(
MediaRawData
*
aSample
AVPacket
*
aPacket
)
;
MediaResult
MaybeAttachCDM
(
)
;
void
MaybeDetachCDM
(
)
;
#
endif
const
FFmpegLibWrapper
*
mLib
;
AVCodecContext
*
mCodecContext
;
AVCodecParserContext
*
mCodecParser
;
AVFrame
*
mFrame
;
RefPtr
<
MediaByteBuffer
>
mExtraData
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
&
&
defined
(
FFVPX_VERSION
)
RefPtr
<
MediaDrmCrypto
>
mCrypto
;
RefPtr
<
MediaDrmRemoteCDMParent
>
mCDM
;
#
endif
AVCodecID
mCodecID
;
bool
mVideoCodec
;
protected
:
virtual
~
FFmpegDataDecoder
(
)
;
static
StaticMutex
sMutex
;
const
RefPtr
<
TaskQueue
>
mTaskQueue
;
RefPtr
<
DecodePromise
>
ProcessDrain
(
)
;
MozPromiseHolder
<
DecodePromise
>
mDrainPromise
;
private
:
RefPtr
<
DecodePromise
>
ProcessDecode
(
MediaRawData
*
aSample
)
;
virtual
MediaResult
DoDecode
(
MediaRawData
*
aSample
uint8_t
*
aData
int
aSize
bool
*
aGotFrame
MediaDataDecoder
:
:
DecodedData
&
aOutResults
)
=
0
;
virtual
bool
NeedParser
(
)
const
{
return
false
;
}
virtual
int
ParserFlags
(
)
const
{
return
PARSER_FLAG_COMPLETE_FRAMES
;
}
MozPromiseHolder
<
DecodePromise
>
mPromise
;
media
:
:
TimeUnit
mLastInputDts
;
}
;
}
#
endif
