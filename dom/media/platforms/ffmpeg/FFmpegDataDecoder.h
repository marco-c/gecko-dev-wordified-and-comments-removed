#
ifndef
__FFmpegDataDecoder_h__
#
define
__FFmpegDataDecoder_h__
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
FFmpegLibWrapper
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
FFmpegLibs
.
h
"
namespace
mozilla
{
template
<
int
V
>
class
FFmpegDataDecoder
:
public
MediaDataDecoder
{
}
;
template
<
>
class
FFmpegDataDecoder
<
LIBAV_VER
>
:
public
MediaDataDecoder
{
public
:
FFmpegDataDecoder
(
FFmpegLibWrapper
*
aLib
TaskQueue
*
aTaskQueue
MediaDataDecoderCallback
*
aCallback
AVCodecID
aCodecID
)
;
virtual
~
FFmpegDataDecoder
(
)
;
static
bool
Link
(
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
=
0
;
nsresult
Input
(
MediaRawData
*
aSample
)
override
;
nsresult
Flush
(
)
override
;
nsresult
Drain
(
)
override
;
nsresult
Shutdown
(
)
override
;
void
SetSeekThreshold
(
const
media
:
:
TimeUnit
&
aTime
)
override
;
static
AVCodec
*
FindAVCodec
(
FFmpegLibWrapper
*
aLib
AVCodecID
aCodec
)
;
protected
:
enum
DecodeResult
{
DECODE_FRAME
DECODE_NO_FRAME
DECODE_ERROR
}
;
virtual
void
ProcessFlush
(
)
;
virtual
void
ProcessShutdown
(
)
;
virtual
void
InitCodecContext
(
)
{
}
AVFrame
*
PrepareFrame
(
)
;
nsresult
InitDecoder
(
)
;
FFmpegLibWrapper
*
mLib
;
MediaDataDecoderCallback
*
mCallback
;
AVCodecContext
*
mCodecContext
;
AVFrame
*
mFrame
;
RefPtr
<
MediaByteBuffer
>
mExtraData
;
AVCodecID
mCodecID
;
Maybe
<
media
:
:
TimeUnit
>
mSeekTargetThreshold
;
private
:
void
ProcessDecode
(
MediaRawData
*
aSample
)
;
virtual
DecodeResult
DoDecode
(
MediaRawData
*
aSample
)
=
0
;
virtual
void
ProcessDrain
(
)
=
0
;
static
StaticMutex
sMonitor
;
const
RefPtr
<
TaskQueue
>
mTaskQueue
;
Atomic
<
bool
>
mIsFlushing
;
}
;
}
#
endif
