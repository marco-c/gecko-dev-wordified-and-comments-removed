#
if
!
defined
(
WMFMediaDataDecoder_h_
)
#
define
WMFMediaDataDecoder_h_
#
include
"
WMF
.
h
"
#
include
"
MFTDecoder
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
PlatformDecoderModule
.
h
"
namespace
mozilla
{
class
MFTManager
{
public
:
virtual
~
MFTManager
(
)
{
}
virtual
HRESULT
Input
(
MediaRawData
*
aSample
)
=
0
;
virtual
HRESULT
Output
(
int64_t
aStreamOffset
RefPtr
<
MediaData
>
&
aOutput
)
=
0
;
void
Flush
(
)
{
mDecoder
-
>
Flush
(
)
;
}
void
Drain
(
)
{
if
(
FAILED
(
mDecoder
-
>
SendMFTMessage
(
MFT_MESSAGE_COMMAND_DRAIN
0
)
)
)
{
NS_WARNING
(
"
Failed
to
send
DRAIN
command
to
MFT
"
)
;
}
}
virtual
void
Shutdown
(
)
=
0
;
virtual
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
{
return
false
;
}
virtual
TrackInfo
:
:
TrackType
GetType
(
)
=
0
;
virtual
void
ConfigurationChanged
(
const
TrackInfo
&
aConfig
)
{
}
protected
:
RefPtr
<
MFTDecoder
>
mDecoder
;
}
;
class
WMFMediaDataDecoder
:
public
MediaDataDecoder
{
public
:
WMFMediaDataDecoder
(
MFTManager
*
aOutputSource
FlushableTaskQueue
*
aAudioTaskQueue
MediaDataDecoderCallback
*
aCallback
)
;
~
WMFMediaDataDecoder
(
)
;
RefPtr
<
MediaDataDecoder
:
:
InitPromise
>
Init
(
)
override
;
nsresult
Input
(
MediaRawData
*
aSample
)
;
nsresult
Flush
(
)
override
;
nsresult
Drain
(
)
override
;
nsresult
Shutdown
(
)
override
;
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
override
;
nsresult
ConfigurationChanged
(
const
TrackInfo
&
aConfig
)
override
;
private
:
void
ProcessDecode
(
MediaRawData
*
aSample
)
;
void
ProcessOutput
(
)
;
void
ProcessFlush
(
)
;
void
ProcessDrain
(
)
;
void
ProcessShutdown
(
)
;
void
ProcessConfigurationChanged
(
UniquePtr
<
TrackInfo
>
&
&
aConfig
)
;
RefPtr
<
FlushableTaskQueue
>
mTaskQueue
;
MediaDataDecoderCallback
*
mCallback
;
nsAutoPtr
<
MFTManager
>
mMFTManager
;
int64_t
mLastStreamOffset
;
Monitor
mMonitor
;
bool
mIsFlushing
;
bool
mIsShutDown
;
bool
mHasSuccessfulOutput
=
false
;
bool
mRecordedError
=
false
;
}
;
}
#
endif
