#
if
!
defined
(
WMFMediaDataDecoder_h_
)
#
define
WMFMediaDataDecoder_h_
#
include
<
set
>
#
include
"
MFTDecoder
.
h
"
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
WMF
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
namespace
mozilla
{
class
MFTManager
{
public
:
virtual
~
MFTManager
(
)
{
}
virtual
HRESULT
Input
(
MediaRawData
*
aSample
)
=
0
;
virtual
HRESULT
Output
(
int64_t
aStreamOffset
RefPtr
<
MediaData
>
&
aOutput
)
=
0
;
virtual
void
Flush
(
)
{
mDecoder
-
>
Flush
(
)
;
mSeekTargetThreshold
.
reset
(
)
;
}
void
Drain
(
)
{
if
(
FAILED
(
mDecoder
-
>
SendMFTMessage
(
MFT_MESSAGE_COMMAND_DRAIN
0
)
)
)
{
NS_WARNING
(
"
Failed
to
send
DRAIN
command
to
MFT
"
)
;
}
}
virtual
void
Shutdown
(
)
=
0
;
virtual
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
{
return
false
;
}
virtual
TrackInfo
:
:
TrackType
GetType
(
)
=
0
;
virtual
nsCString
GetDescriptionName
(
)
const
=
0
;
virtual
nsCString
GetCodecName
(
)
const
=
0
;
virtual
void
SetSeekThreshold
(
const
media
:
:
TimeUnit
&
aTime
)
{
if
(
aTime
.
IsValid
(
)
)
{
mSeekTargetThreshold
=
Some
(
aTime
)
;
}
else
{
mSeekTargetThreshold
.
reset
(
)
;
}
}
virtual
bool
HasSeekThreshold
(
)
const
{
return
mSeekTargetThreshold
.
isSome
(
)
;
}
virtual
MediaDataDecoder
:
:
ConversionRequired
NeedsConversion
(
)
const
{
return
MediaDataDecoder
:
:
ConversionRequired
:
:
kNeedNone
;
}
protected
:
RefPtr
<
MFTDecoder
>
mDecoder
;
Maybe
<
media
:
:
TimeUnit
>
mSeekTargetThreshold
;
}
;
DDLoggedTypeDeclNameAndBase
(
WMFMediaDataDecoder
MediaDataDecoder
)
;
class
WMFMediaDataDecoder
final
:
public
MediaDataDecoder
public
DecoderDoctorLifeLogger
<
WMFMediaDataDecoder
>
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
WMFMediaDataDecoder
final
)
;
explicit
WMFMediaDataDecoder
(
MFTManager
*
aOutputSource
)
;
RefPtr
<
MediaDataDecoder
:
:
InitPromise
>
Init
(
)
override
;
RefPtr
<
DecodePromise
>
Decode
(
MediaRawData
*
aSample
)
override
;
RefPtr
<
DecodePromise
>
Drain
(
)
override
;
RefPtr
<
FlushPromise
>
Flush
(
)
override
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
override
;
nsCString
GetDescriptionName
(
)
const
override
{
return
mMFTManager
?
mMFTManager
-
>
GetDescriptionName
(
)
:
"
unknown
"
_ns
;
}
nsCString
GetCodecName
(
)
const
override
{
return
mMFTManager
?
mMFTManager
-
>
GetCodecName
(
)
:
"
"
_ns
;
}
ConversionRequired
NeedsConversion
(
)
const
override
{
MOZ_ASSERT
(
mMFTManager
)
;
return
mMFTManager
-
>
NeedsConversion
(
)
;
}
virtual
void
SetSeekThreshold
(
const
media
:
:
TimeUnit
&
aTime
)
override
;
private
:
~
WMFMediaDataDecoder
(
)
;
RefPtr
<
DecodePromise
>
ProcessError
(
HRESULT
aError
const
char
*
aReason
)
;
RefPtr
<
DecodePromise
>
ProcessDecode
(
MediaRawData
*
aSample
)
;
HRESULT
ProcessOutput
(
DecodedData
&
aResults
)
;
RefPtr
<
FlushPromise
>
ProcessFlush
(
)
;
RefPtr
<
DecodePromise
>
ProcessDrain
(
)
;
bool
ShouldGuardAgaintIncorrectFirstSample
(
MediaData
*
aOutput
)
const
;
const
RefPtr
<
TaskQueue
>
mTaskQueue
;
UniquePtr
<
MFTManager
>
mMFTManager
;
int64_t
mLastStreamOffset
;
Maybe
<
media
:
:
TimeUnit
>
mLastTime
;
media
:
:
TimeUnit
mLastDuration
;
std
:
:
set
<
int64_t
>
mInputTimesSet
;
int64_t
mSamplesCount
=
0
;
int64_t
mOutputsCount
=
0
;
bool
mIsShutDown
=
false
;
enum
class
DrainStatus
{
DRAINED
DRAINABLE
DRAINING
}
;
DrainStatus
mDrainStatus
=
DrainStatus
:
:
DRAINED
;
}
;
}
#
endif
