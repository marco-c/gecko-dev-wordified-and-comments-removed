#
include
"
WMFAudioMFTManager
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
WMFUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
extern
mozilla
:
:
LogModule
*
GetPDMLog
(
)
;
#
define
LOG
(
.
.
.
)
MOZ_LOG
(
GetPDMLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
namespace
mozilla
{
static
void
AACAudioSpecificConfigToUserData
(
uint8_t
aAACProfileLevelIndication
const
uint8_t
*
aAudioSpecConfig
uint32_t
aConfigLength
nsTArray
<
BYTE
>
&
aOutUserData
)
{
MOZ_ASSERT
(
aOutUserData
.
IsEmpty
(
)
)
;
const
UINT32
heeInfoLen
=
4
*
sizeof
(
WORD
)
+
sizeof
(
DWORD
)
;
BYTE
heeInfo
[
heeInfoLen
]
=
{
0
}
;
WORD
*
w
=
(
WORD
*
)
heeInfo
;
w
[
0
]
=
0x0
;
w
[
1
]
=
aAACProfileLevelIndication
;
aOutUserData
.
AppendElements
(
heeInfo
heeInfoLen
)
;
aOutUserData
.
AppendElements
(
aAudioSpecConfig
aConfigLength
)
;
}
WMFAudioMFTManager
:
:
WMFAudioMFTManager
(
const
AudioInfo
&
aConfig
)
:
mAudioChannels
(
aConfig
.
mChannels
)
mAudioRate
(
aConfig
.
mRate
)
mAudioFrameSum
(
0
)
mMustRecaptureAudioPosition
(
true
)
{
MOZ_COUNT_CTOR
(
WMFAudioMFTManager
)
;
if
(
aConfig
.
mMimeType
.
EqualsLiteral
(
"
audio
/
mpeg
"
)
)
{
mStreamType
=
MP3
;
}
else
if
(
aConfig
.
mMimeType
.
EqualsLiteral
(
"
audio
/
mp4a
-
latm
"
)
)
{
mStreamType
=
AAC
;
AACAudioSpecificConfigToUserData
(
aConfig
.
mProfile
aConfig
.
mCodecSpecificConfig
-
>
Elements
(
)
aConfig
.
mCodecSpecificConfig
-
>
Length
(
)
mUserData
)
;
}
else
{
mStreamType
=
Unknown
;
}
}
WMFAudioMFTManager
:
:
~
WMFAudioMFTManager
(
)
{
MOZ_COUNT_DTOR
(
WMFAudioMFTManager
)
;
}
const
GUID
&
WMFAudioMFTManager
:
:
GetMFTGUID
(
)
{
MOZ_ASSERT
(
mStreamType
!
=
Unknown
)
;
switch
(
mStreamType
)
{
case
AAC
:
return
CLSID_CMSAACDecMFT
;
case
MP3
:
return
CLSID_CMP3DecMediaObject
;
default
:
return
GUID_NULL
;
}
;
}
const
GUID
&
WMFAudioMFTManager
:
:
GetMediaSubtypeGUID
(
)
{
MOZ_ASSERT
(
mStreamType
!
=
Unknown
)
;
switch
(
mStreamType
)
{
case
AAC
:
return
MFAudioFormat_AAC
;
case
MP3
:
return
MFAudioFormat_MP3
;
default
:
return
GUID_NULL
;
}
;
}
bool
WMFAudioMFTManager
:
:
Init
(
)
{
NS_ENSURE_TRUE
(
mStreamType
!
=
Unknown
false
)
;
RefPtr
<
MFTDecoder
>
decoder
(
new
MFTDecoder
(
)
)
;
HRESULT
hr
=
decoder
-
>
Create
(
GetMFTGUID
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
RefPtr
<
IMFMediaType
>
inputType
;
hr
=
wmf
:
:
MFCreateMediaType
(
getter_AddRefs
(
inputType
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
inputType
-
>
SetGUID
(
MF_MT_MAJOR_TYPE
MFMediaType_Audio
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
inputType
-
>
SetGUID
(
MF_MT_SUBTYPE
GetMediaSubtypeGUID
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
inputType
-
>
SetUINT32
(
MF_MT_AUDIO_SAMPLES_PER_SECOND
mAudioRate
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
inputType
-
>
SetUINT32
(
MF_MT_AUDIO_NUM_CHANNELS
mAudioChannels
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
if
(
mStreamType
=
=
AAC
)
{
hr
=
inputType
-
>
SetUINT32
(
MF_MT_AAC_PAYLOAD_TYPE
0x0
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
inputType
-
>
SetBlob
(
MF_MT_USER_DATA
mUserData
.
Elements
(
)
mUserData
.
Length
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
}
RefPtr
<
IMFMediaType
>
outputType
;
hr
=
wmf
:
:
MFCreateMediaType
(
getter_AddRefs
(
outputType
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
outputType
-
>
SetGUID
(
MF_MT_MAJOR_TYPE
MFMediaType_Audio
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
outputType
-
>
SetGUID
(
MF_MT_SUBTYPE
MFAudioFormat_PCM
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
outputType
-
>
SetUINT32
(
MF_MT_AUDIO_BITS_PER_SAMPLE
16
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
decoder
-
>
SetMediaTypes
(
inputType
outputType
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
mDecoder
=
decoder
;
return
true
;
}
HRESULT
WMFAudioMFTManager
:
:
Input
(
MediaRawData
*
aSample
)
{
return
mDecoder
-
>
Input
(
aSample
-
>
Data
(
)
uint32_t
(
aSample
-
>
Size
(
)
)
aSample
-
>
mTime
)
;
}
HRESULT
WMFAudioMFTManager
:
:
UpdateOutputType
(
)
{
HRESULT
hr
;
RefPtr
<
IMFMediaType
>
type
;
hr
=
mDecoder
-
>
GetOutputMediaType
(
type
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
hr
=
type
-
>
GetUINT32
(
MF_MT_AUDIO_SAMPLES_PER_SECOND
&
mAudioRate
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
hr
=
type
-
>
GetUINT32
(
MF_MT_AUDIO_NUM_CHANNELS
&
mAudioChannels
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
return
S_OK
;
}
HRESULT
WMFAudioMFTManager
:
:
Output
(
int64_t
aStreamOffset
RefPtr
<
MediaData
>
&
aOutData
)
{
aOutData
=
nullptr
;
RefPtr
<
IMFSample
>
sample
;
HRESULT
hr
;
int
typeChangeCount
=
0
;
while
(
true
)
{
hr
=
mDecoder
-
>
Output
(
&
sample
)
;
if
(
hr
=
=
MF_E_TRANSFORM_NEED_MORE_INPUT
)
{
return
hr
;
}
if
(
hr
=
=
MF_E_TRANSFORM_STREAM_CHANGE
)
{
hr
=
UpdateOutputType
(
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
NS_ENSURE_TRUE
(
typeChangeCount
<
100
MF_E_TRANSFORM_STREAM_CHANGE
)
;
+
+
typeChangeCount
;
continue
;
}
break
;
}
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
if
(
!
sample
)
{
LOG
(
"
Audio
MFTDecoder
returned
success
but
null
output
.
"
)
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
[
]
(
)
-
>
void
{
LOG
(
"
Reporting
telemetry
AUDIO_MFT_OUTPUT_NULL_SAMPLES
"
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
ID
:
:
AUDIO_MFT_OUTPUT_NULL_SAMPLES
1
)
;
}
)
;
AbstractThread
:
:
MainThread
(
)
-
>
Dispatch
(
task
.
forget
(
)
)
;
return
E_FAIL
;
}
RefPtr
<
IMFMediaBuffer
>
buffer
;
hr
=
sample
-
>
ConvertToContiguousBuffer
(
getter_AddRefs
(
buffer
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
BYTE
*
data
=
nullptr
;
DWORD
maxLength
=
0
currentLength
=
0
;
hr
=
buffer
-
>
Lock
(
&
data
&
maxLength
&
currentLength
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
UINT32
discontinuity
=
false
;
sample
-
>
GetUINT32
(
MFSampleExtension_Discontinuity
&
discontinuity
)
;
if
(
mMustRecaptureAudioPosition
|
|
discontinuity
)
{
hr
=
UpdateOutputType
(
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
mAudioFrameSum
=
0
;
LONGLONG
timestampHns
=
0
;
hr
=
sample
-
>
GetSampleTime
(
&
timestampHns
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
mAudioTimeOffset
=
media
:
:
TimeUnit
:
:
FromMicroseconds
(
timestampHns
/
10
)
;
mMustRecaptureAudioPosition
=
false
;
}
int32_t
numSamples
=
currentLength
/
2
;
int32_t
numFrames
=
numSamples
/
mAudioChannels
;
MOZ_ASSERT
(
numFrames
>
=
0
)
;
MOZ_ASSERT
(
numSamples
>
=
0
)
;
if
(
numFrames
=
=
0
)
{
return
S_OK
;
}
auto
audioData
=
MakeUnique
<
AudioDataValue
[
]
>
(
numSamples
)
;
int16_t
*
pcm
=
(
int16_t
*
)
data
;
for
(
int32_t
i
=
0
;
i
<
numSamples
;
+
+
i
)
{
audioData
[
i
]
=
AudioSampleToFloat
(
pcm
[
i
]
)
;
}
buffer
-
>
Unlock
(
)
;
media
:
:
TimeUnit
timestamp
=
mAudioTimeOffset
+
FramesToTimeUnit
(
mAudioFrameSum
mAudioRate
)
;
NS_ENSURE_TRUE
(
timestamp
.
IsValid
(
)
E_FAIL
)
;
mAudioFrameSum
+
=
numFrames
;
media
:
:
TimeUnit
duration
=
FramesToTimeUnit
(
numFrames
mAudioRate
)
;
NS_ENSURE_TRUE
(
duration
.
IsValid
(
)
E_FAIL
)
;
aOutData
=
new
AudioData
(
aStreamOffset
timestamp
.
ToMicroseconds
(
)
duration
.
ToMicroseconds
(
)
numFrames
Move
(
audioData
)
mAudioChannels
mAudioRate
)
;
#
ifdef
LOG_SAMPLE_DECODE
LOG
(
"
Decoded
audio
sample
!
timestamp
=
%
lld
duration
=
%
lld
currentLength
=
%
u
"
timestamp
.
ToMicroseconds
(
)
duration
.
ToMicroseconds
(
)
currentLength
)
;
#
endif
return
S_OK
;
}
void
WMFAudioMFTManager
:
:
Shutdown
(
)
{
mDecoder
=
nullptr
;
}
}
