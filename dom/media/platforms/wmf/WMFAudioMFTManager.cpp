#
include
"
WMFAudioMFTManager
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
WMFUtils
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsTArray
.
h
"
#
define
LOG
(
.
.
.
)
MOZ_LOG
(
sPDMLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
namespace
mozilla
{
using
media
:
:
TimeUnit
;
static
void
AACAudioSpecificConfigToUserData
(
uint8_t
aAACProfileLevelIndication
const
uint8_t
*
aAudioSpecConfig
uint32_t
aConfigLength
nsTArray
<
BYTE
>
&
aOutUserData
)
{
MOZ_ASSERT
(
aOutUserData
.
IsEmpty
(
)
)
;
const
UINT32
heeInfoLen
=
4
*
sizeof
(
WORD
)
+
sizeof
(
DWORD
)
;
BYTE
heeInfo
[
heeInfoLen
]
=
{
0
}
;
WORD
*
w
=
(
WORD
*
)
heeInfo
;
w
[
0
]
=
0x0
;
w
[
1
]
=
aAACProfileLevelIndication
;
aOutUserData
.
AppendElements
(
heeInfo
heeInfoLen
)
;
if
(
aAACProfileLevelIndication
=
=
2
&
&
aConfigLength
>
2
)
{
int8_t
frequency
=
(
aAudioSpecConfig
[
0
]
&
0x7
)
<
<
1
|
(
aAudioSpecConfig
[
1
]
&
0x80
)
>
>
7
;
int8_t
channels
=
(
aAudioSpecConfig
[
1
]
&
0x78
)
>
>
3
;
int8_t
gasc
=
aAudioSpecConfig
[
1
]
&
0x7
;
if
(
frequency
!
=
0xf
&
&
channels
&
&
!
gasc
)
{
aConfigLength
=
2
;
}
}
aOutUserData
.
AppendElements
(
aAudioSpecConfig
aConfigLength
)
;
}
WMFAudioMFTManager
:
:
WMFAudioMFTManager
(
const
AudioInfo
&
aConfig
)
:
mAudioChannels
(
aConfig
.
mChannels
)
mChannelsMap
(
AudioConfig
:
:
ChannelLayout
:
:
UNKNOWN_MAP
)
mAudioRate
(
aConfig
.
mRate
)
mStreamType
(
WMFDecoderModule
:
:
GetStreamTypeFromMimeType
(
aConfig
.
mMimeType
)
)
{
MOZ_COUNT_CTOR
(
WMFAudioMFTManager
)
;
if
(
mStreamType
=
=
WMFStreamType
:
:
AAC
)
{
const
AacCodecSpecificData
&
aacCodecSpecificData
=
aConfig
.
mCodecSpecificConfig
.
as
<
AacCodecSpecificData
>
(
)
;
AACAudioSpecificConfigToUserData
(
aConfig
.
mExtendedProfile
aacCodecSpecificData
.
mDecoderConfigDescriptorBinaryBlob
-
>
Elements
(
)
aacCodecSpecificData
.
mDecoderConfigDescriptorBinaryBlob
-
>
Length
(
)
mUserData
)
;
}
}
WMFAudioMFTManager
:
:
~
WMFAudioMFTManager
(
)
{
MOZ_COUNT_DTOR
(
WMFAudioMFTManager
)
;
}
const
GUID
&
WMFAudioMFTManager
:
:
GetMediaSubtypeGUID
(
)
{
MOZ_ASSERT
(
WMFDecoderModule
:
:
StreamTypeIsAudio
(
mStreamType
)
)
;
switch
(
mStreamType
)
{
case
WMFStreamType
:
:
AAC
:
return
MFAudioFormat_AAC
;
case
WMFStreamType
:
:
MP3
:
return
MFAudioFormat_MP3
;
default
:
return
GUID_NULL
;
}
;
}
bool
WMFAudioMFTManager
:
:
Init
(
)
{
NS_ENSURE_TRUE
(
WMFDecoderModule
:
:
StreamTypeIsAudio
(
mStreamType
)
false
)
;
RefPtr
<
MFTDecoder
>
decoder
(
new
MFTDecoder
(
)
)
;
HRESULT
hr
=
WMFDecoderModule
:
:
CreateMFTDecoder
(
mStreamType
decoder
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
RefPtr
<
IMFMediaType
>
inputType
;
hr
=
wmf
:
:
MFCreateMediaType
(
getter_AddRefs
(
inputType
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
inputType
-
>
SetGUID
(
MF_MT_MAJOR_TYPE
MFMediaType_Audio
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
inputType
-
>
SetGUID
(
MF_MT_SUBTYPE
GetMediaSubtypeGUID
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
inputType
-
>
SetUINT32
(
MF_MT_AUDIO_SAMPLES_PER_SECOND
mAudioRate
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
inputType
-
>
SetUINT32
(
MF_MT_AUDIO_NUM_CHANNELS
mAudioChannels
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
if
(
mStreamType
=
=
WMFStreamType
:
:
AAC
)
{
hr
=
inputType
-
>
SetUINT32
(
MF_MT_AAC_PAYLOAD_TYPE
0x0
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
inputType
-
>
SetBlob
(
MF_MT_USER_DATA
mUserData
.
Elements
(
)
mUserData
.
Length
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
}
RefPtr
<
IMFMediaType
>
outputType
;
hr
=
wmf
:
:
MFCreateMediaType
(
getter_AddRefs
(
outputType
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
outputType
-
>
SetGUID
(
MF_MT_MAJOR_TYPE
MFMediaType_Audio
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
outputType
-
>
SetGUID
(
MF_MT_SUBTYPE
MFAudioFormat_Float
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
outputType
-
>
SetUINT32
(
MF_MT_AUDIO_BITS_PER_SAMPLE
32
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
decoder
-
>
SetMediaTypes
(
inputType
outputType
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
mDecoder
=
decoder
;
return
true
;
}
HRESULT
WMFAudioMFTManager
:
:
Input
(
MediaRawData
*
aSample
)
{
mLastInputTime
=
aSample
-
>
mTime
;
return
mDecoder
-
>
Input
(
aSample
-
>
Data
(
)
uint32_t
(
aSample
-
>
Size
(
)
)
aSample
-
>
mTime
.
ToMicroseconds
(
)
aSample
-
>
mDuration
.
ToMicroseconds
(
)
)
;
}
HRESULT
WMFAudioMFTManager
:
:
UpdateOutputType
(
)
{
HRESULT
hr
;
RefPtr
<
IMFMediaType
>
type
;
hr
=
mDecoder
-
>
GetOutputMediaType
(
type
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
hr
=
type
-
>
GetUINT32
(
MF_MT_AUDIO_SAMPLES_PER_SECOND
&
mAudioRate
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
hr
=
type
-
>
GetUINT32
(
MF_MT_AUDIO_NUM_CHANNELS
&
mAudioChannels
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
uint32_t
channelsMap
;
hr
=
type
-
>
GetUINT32
(
MF_MT_AUDIO_CHANNEL_MASK
&
channelsMap
)
;
if
(
SUCCEEDED
(
hr
)
)
{
mChannelsMap
=
channelsMap
;
}
else
{
LOG
(
"
Unable
to
retrieve
channel
layout
.
Ignoring
"
)
;
mChannelsMap
=
AudioConfig
:
:
ChannelLayout
:
:
UNKNOWN_MAP
;
}
return
S_OK
;
}
HRESULT
WMFAudioMFTManager
:
:
Output
(
int64_t
aStreamOffset
RefPtr
<
MediaData
>
&
aOutData
)
{
aOutData
=
nullptr
;
RefPtr
<
IMFSample
>
sample
;
HRESULT
hr
;
int
typeChangeCount
=
0
;
const
auto
oldAudioRate
=
mAudioRate
;
while
(
true
)
{
hr
=
mDecoder
-
>
Output
(
&
sample
)
;
if
(
hr
=
=
MF_E_TRANSFORM_NEED_MORE_INPUT
)
{
return
hr
;
}
if
(
hr
=
=
MF_E_TRANSFORM_STREAM_CHANGE
)
{
hr
=
mDecoder
-
>
FindDecoderOutputType
(
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
hr
=
UpdateOutputType
(
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
NS_ENSURE_TRUE
(
typeChangeCount
<
100
MF_E_TRANSFORM_STREAM_CHANGE
)
;
+
+
typeChangeCount
;
continue
;
}
break
;
}
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
if
(
!
sample
)
{
LOG
(
"
Audio
MFTDecoder
returned
success
but
null
output
.
"
)
;
return
E_FAIL
;
}
UINT32
discontinuity
=
false
;
sample
-
>
GetUINT32
(
MFSampleExtension_Discontinuity
&
discontinuity
)
;
if
(
mFirstFrame
|
|
discontinuity
)
{
hr
=
UpdateOutputType
(
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
mFirstFrame
=
false
;
}
TimeUnit
pts
=
GetSampleTime
(
sample
)
;
NS_ENSURE_TRUE
(
pts
.
IsValid
(
)
E_FAIL
)
;
RefPtr
<
IMFMediaBuffer
>
buffer
;
hr
=
sample
-
>
ConvertToContiguousBuffer
(
getter_AddRefs
(
buffer
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
BYTE
*
data
=
nullptr
;
DWORD
maxLength
=
0
currentLength
=
0
;
hr
=
buffer
-
>
Lock
(
&
data
&
maxLength
&
currentLength
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
int32_t
numSamples
=
currentLength
/
sizeof
(
float
)
;
int32_t
numFrames
=
numSamples
/
mAudioChannels
;
MOZ_ASSERT
(
numFrames
>
=
0
)
;
MOZ_ASSERT
(
numSamples
>
=
0
)
;
if
(
numFrames
=
=
0
)
{
return
S_OK
;
}
if
(
oldAudioRate
!
=
mAudioRate
)
{
LOG
(
"
Audio
rate
changed
from
%
"
PRIu32
"
to
%
"
PRIu32
oldAudioRate
mAudioRate
)
;
}
AlignedAudioBuffer
audioData
(
numSamples
)
;
if
(
!
audioData
)
{
return
E_OUTOFMEMORY
;
}
PodCopy
(
audioData
.
Data
(
)
reinterpret_cast
<
float
*
>
(
data
)
numSamples
)
;
buffer
-
>
Unlock
(
)
;
TimeUnit
duration
=
FramesToTimeUnit
(
numFrames
mAudioRate
)
;
NS_ENSURE_TRUE
(
duration
.
IsValid
(
)
E_FAIL
)
;
const
bool
isAudioRateChangedToHigher
=
oldAudioRate
<
mAudioRate
;
if
(
IsPartialOutput
(
duration
isAudioRateChangedToHigher
)
)
{
LOG
(
"
Encounter
a
partial
frame
?
!
duration
shrinks
from
%
"
PRId64
"
to
%
"
PRId64
mLastOutputDuration
.
ToMicroseconds
(
)
duration
.
ToMicroseconds
(
)
)
;
return
MF_E_TRANSFORM_NEED_MORE_INPUT
;
}
aOutData
=
new
AudioData
(
aStreamOffset
pts
std
:
:
move
(
audioData
)
mAudioChannels
mAudioRate
mChannelsMap
)
;
MOZ_DIAGNOSTIC_ASSERT
(
duration
=
=
aOutData
-
>
mDuration
"
must
be
equal
"
)
;
mLastOutputDuration
=
aOutData
-
>
mDuration
;
#
ifdef
LOG_SAMPLE_DECODE
LOG
(
"
Decoded
audio
sample
!
timestamp
=
%
lld
duration
=
%
lld
currentLength
=
%
u
"
pts
.
ToMicroseconds
(
)
duration
.
ToMicroseconds
(
)
currentLength
)
;
#
endif
return
S_OK
;
}
bool
WMFAudioMFTManager
:
:
IsPartialOutput
(
const
media
:
:
TimeUnit
&
aNewOutputDuration
const
bool
aIsRateChangedToHigher
)
const
{
if
(
mStreamType
!
=
WMFStreamType
:
:
AAC
)
{
return
false
;
}
if
(
mLastOutputDuration
>
aNewOutputDuration
&
&
!
aIsRateChangedToHigher
)
{
return
true
;
}
return
false
;
}
void
WMFAudioMFTManager
:
:
Shutdown
(
)
{
mDecoder
=
nullptr
;
}
}
#
undef
LOG
