#
ifndef
DOM_MEDIA_PLATFORM_WMF_MFMEDIAENGINEVIDEOSTREAM_H
#
define
DOM_MEDIA_PLATFORM_WMF_MFMEDIAENGINEVIDEOSTREAM_H
#
include
"
MFMediaEngineStream
.
h
"
#
include
"
WMFUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
namespace
mozilla
{
namespace
layers
{
class
Image
;
class
DcompSurfaceImage
;
}
class
MFMediaSource
;
class
MFMediaEngineVideoStream
final
:
public
MFMediaEngineStream
{
public
:
MFMediaEngineVideoStream
(
)
=
default
;
static
MFMediaEngineVideoStream
*
Create
(
uint64_t
aStreamId
const
TrackInfo
&
aInfo
MFMediaSource
*
aParentSource
)
;
nsCString
GetDescriptionName
(
)
const
override
{
return
"
media
engine
video
stream
"
_ns
;
}
TrackInfo
:
:
TrackType
TrackType
(
)
override
{
return
TrackInfo
:
:
TrackType
:
:
kVideoTrack
;
}
void
SetKnowsCompositor
(
layers
:
:
KnowsCompositor
*
aKnowsCompositor
)
;
void
SetDCompSurfaceHandle
(
HANDLE
aDCompSurfaceHandle
)
;
MFMediaEngineVideoStream
*
AsVideoStream
(
)
override
{
return
this
;
}
MediaDataDecoder
:
:
ConversionRequired
NeedsConversion
(
)
const
override
;
void
SetConfig
(
const
TrackInfo
&
aConfig
)
;
RefPtr
<
MediaDataDecoder
:
:
DecodePromise
>
Drain
(
)
override
;
private
:
HRESULT
CreateMediaType
(
const
TrackInfo
&
aInfo
IMFMediaType
*
*
aMediaType
)
override
;
bool
HasEnoughRawData
(
)
const
override
;
void
UpdateConfig
(
const
VideoInfo
&
aInfo
)
;
already_AddRefed
<
MediaData
>
OutputDataInternal
(
)
override
;
bool
IsDCompImageReady
(
)
;
void
ResolvePendingDrainPromiseIfNeeded
(
)
;
void
ShutdownCleanUpOnTaskQueue
(
)
override
;
HANDLE
mDCompSurfaceHandle
;
bool
mNeedRecreateImage
;
RefPtr
<
layers
:
:
KnowsCompositor
>
mKnowsCompositor
;
Mutex
mMutex
{
"
MFMediaEngineVideoStream
"
}
;
gfx
:
:
IntSize
mDisplay
MOZ_GUARDED_BY
(
mMutex
)
;
WMFStreamType
mStreamType
;
RefPtr
<
layers
:
:
DcompSurfaceImage
>
mDcompSurfaceImage
;
bool
mHasReceivedInitialCreateDecoderConfig
;
MozPromiseHolder
<
MediaDataDecoder
:
:
DecodePromise
>
mPendingDrainPromise
;
}
;
}
#
endif
