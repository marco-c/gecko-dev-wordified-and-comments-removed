#
ifndef
DOM_MEDIA_PLATFORM_WMF_MFMEDIAENGINESTREAM_H
#
define
DOM_MEDIA_PLATFORM_WMF_MFMEDIAENGINESTREAM_H
#
include
<
mfidl
.
h
>
#
include
<
wrl
.
h
>
#
include
<
queue
>
#
include
"
BlankDecoderModule
.
h
"
#
include
"
MediaQueue
.
h
"
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
SPSCQueue
.
h
"
namespace
mozilla
{
class
MFMediaEngineVideoStream
;
class
MFMediaSource
;
class
MFMediaEngineStream
:
public
Microsoft
:
:
WRL
:
:
RuntimeClass
<
Microsoft
:
:
WRL
:
:
RuntimeClassFlags
<
Microsoft
:
:
WRL
:
:
RuntimeClassType
:
:
ClassicCom
>
IMFMediaStream
>
{
public
:
MFMediaEngineStream
(
)
;
~
MFMediaEngineStream
(
)
;
virtual
nsCString
GetDescriptionName
(
)
const
=
0
;
virtual
nsCString
GetCodecName
(
)
const
=
0
;
HRESULT
RuntimeClassInitialize
(
uint64_t
aStreamId
const
TrackInfo
&
aInfo
MFMediaSource
*
aParentSource
)
;
HRESULT
Start
(
const
PROPVARIANT
*
aPosition
)
;
HRESULT
Seek
(
const
PROPVARIANT
*
aPosition
)
;
HRESULT
Stop
(
)
;
HRESULT
Pause
(
)
;
void
Shutdown
(
)
;
void
SetSelected
(
bool
aSelected
)
;
bool
IsSelected
(
)
const
{
return
mIsSelected
;
}
DWORD
DescriptorId
(
)
const
{
return
mStreamDescriptorId
;
}
IFACEMETHODIMP
GetMediaSource
(
IMFMediaSource
*
*
aMediaSource
)
override
;
IFACEMETHODIMP
GetStreamDescriptor
(
IMFStreamDescriptor
*
*
aStreamDescriptor
)
override
;
IFACEMETHODIMP
RequestSample
(
IUnknown
*
aToken
)
override
;
IFACEMETHODIMP
GetEvent
(
DWORD
aFlags
IMFMediaEvent
*
*
aEvent
)
override
;
IFACEMETHODIMP
BeginGetEvent
(
IMFAsyncCallback
*
aCallback
IUnknown
*
aState
)
override
;
IFACEMETHODIMP
EndGetEvent
(
IMFAsyncResult
*
aResult
IMFMediaEvent
*
*
aEvent
)
override
;
IFACEMETHODIMP
QueueEvent
(
MediaEventType
aType
REFGUID
aExtendedType
HRESULT
aStatus
const
PROPVARIANT
*
aValue
)
override
;
TaskQueue
*
GetTaskQueue
(
)
{
return
mTaskQueue
;
}
void
NotifyEndOfStream
(
)
{
Microsoft
:
:
WRL
:
:
ComPtr
<
MFMediaEngineStream
>
self
=
this
;
Unused
<
<
mTaskQueue
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
MFMediaEngineStream
:
:
NotifyEndOfStream
"
[
self
]
(
)
{
self
-
>
NotifyEndOfStreamInternal
(
)
;
}
)
)
;
}
virtual
TrackInfo
:
:
TrackType
TrackType
(
)
=
0
;
RefPtr
<
MediaDataDecoder
:
:
FlushPromise
>
Flush
(
)
;
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
&
EndedEvent
(
)
{
return
mEndedEvent
;
}
bool
IsShutdown
(
)
const
{
return
mIsShutdown
;
}
virtual
MFMediaEngineVideoStream
*
AsVideoStream
(
)
{
return
nullptr
;
}
RefPtr
<
MediaDataDecoder
:
:
DecodePromise
>
OutputData
(
RefPtr
<
MediaRawData
>
aSample
)
;
virtual
RefPtr
<
MediaDataDecoder
:
:
DecodePromise
>
Drain
(
)
;
virtual
MediaDataDecoder
:
:
ConversionRequired
NeedsConversion
(
)
const
{
return
MediaDataDecoder
:
:
ConversionRequired
:
:
kNeedNone
;
}
virtual
bool
IsEncrypted
(
)
const
=
0
;
protected
:
HRESULT
GenerateStreamDescriptor
(
Microsoft
:
:
WRL
:
:
ComPtr
<
IMFMediaType
>
&
aMediaType
)
;
virtual
HRESULT
CreateMediaType
(
const
TrackInfo
&
aInfo
IMFMediaType
*
*
aMediaType
)
=
0
;
virtual
bool
HasEnoughRawData
(
)
const
=
0
;
HRESULT
CreateInputSample
(
IMFSample
*
*
aSample
)
;
void
ReplySampleRequestIfPossible
(
)
;
bool
ShouldServeSamples
(
)
const
;
void
NotifyNewData
(
MediaRawData
*
aSample
)
;
void
NotifyEndOfStreamInternal
(
)
;
virtual
bool
IsEnded
(
)
const
;
virtual
void
ShutdownCleanUpOnTaskQueue
(
)
{
}
;
virtual
already_AddRefed
<
MediaData
>
OutputDataInternal
(
)
=
0
;
void
SendRequestSampleEvent
(
bool
aIsEnough
)
;
HRESULT
AddEncryptAttributes
(
IMFSample
*
aSample
const
CryptoSample
&
aCryptoConfig
)
;
void
AssertOnTaskQueue
(
)
const
;
void
AssertOnMFThreadPool
(
)
const
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IMFMediaEventQueue
>
mMediaEventQueue
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IMFStreamDescriptor
>
mStreamDescriptor
;
Microsoft
:
:
WRL
:
:
ComPtr
<
MFMediaSource
>
mParentSource
;
DWORD
mStreamDescriptorId
=
0
;
uint64_t
mStreamId
=
0
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
Atomic
<
bool
>
mIsShutdown
;
Atomic
<
bool
>
mIsSelected
;
MediaQueue
<
MediaRawData
>
mRawDataQueueForFeedingEngine
;
MediaQueue
<
MediaRawData
>
mRawDataQueueForGeneratingOutput
;
std
:
:
queue
<
Microsoft
:
:
WRL
:
:
ComPtr
<
IUnknown
>
>
mSampleRequestTokens
;
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
mEndedEvent
;
bool
mReceivedEOS
;
}
;
class
MFMediaEngineStreamWrapper
final
:
public
MediaDataDecoder
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MFMediaEngineStreamWrapper
final
)
;
MFMediaEngineStreamWrapper
(
MFMediaEngineStream
*
aStream
TaskQueue
*
aTaskQueue
const
CreateDecoderParams
&
aParams
)
:
mStream
(
aStream
)
mTaskQueue
(
aTaskQueue
)
{
MOZ_ASSERT
(
mStream
)
;
MOZ_ASSERT
(
mTaskQueue
)
;
}
RefPtr
<
InitPromise
>
Init
(
)
override
;
RefPtr
<
DecodePromise
>
Decode
(
MediaRawData
*
aSample
)
override
;
RefPtr
<
DecodePromise
>
Drain
(
)
override
;
RefPtr
<
FlushPromise
>
Flush
(
)
override
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
nsCString
GetDescriptionName
(
)
const
override
;
nsCString
GetCodecName
(
)
const
override
;
ConversionRequired
NeedsConversion
(
)
const
override
;
private
:
~
MFMediaEngineStreamWrapper
(
)
=
default
;
Microsoft
:
:
WRL
:
:
ComPtr
<
MFMediaEngineStream
>
mStream
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
}
;
}
#
endif
