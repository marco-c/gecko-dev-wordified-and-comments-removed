#
ifndef
DOM_MEDIA_PLATFORM_WMF_MFMEDIAENGINESTREAM_H
#
define
DOM_MEDIA_PLATFORM_WMF_MFMEDIAENGINESTREAM_H
#
include
<
mfidl
.
h
>
#
include
<
wrl
.
h
>
#
include
<
queue
>
#
include
"
BlankDecoderModule
.
h
"
#
include
"
MediaQueue
.
h
"
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
SPSCQueue
.
h
"
namespace
mozilla
{
class
MFMediaSource
;
class
MFMediaEngineStream
:
public
Microsoft
:
:
WRL
:
:
RuntimeClass
<
Microsoft
:
:
WRL
:
:
RuntimeClassFlags
<
Microsoft
:
:
WRL
:
:
RuntimeClassType
:
:
ClassicCom
>
IMFMediaStream
>
{
public
:
MFMediaEngineStream
(
)
;
~
MFMediaEngineStream
(
)
;
virtual
nsCString
GetDescriptionName
(
)
const
=
0
;
HRESULT
RuntimeClassInitialize
(
uint64_t
aStreamId
const
TrackInfo
&
aInfo
MFMediaSource
*
aParentSource
)
;
HRESULT
Start
(
const
PROPVARIANT
*
aPosition
)
;
HRESULT
Seek
(
const
PROPVARIANT
*
aPosition
)
;
HRESULT
Stop
(
)
;
HRESULT
Pause
(
)
;
void
Shutdown
(
)
;
void
SetSelected
(
bool
aSelected
)
;
bool
IsSelected
(
)
const
{
return
mIsSelected
;
}
DWORD
DescriptorId
(
)
const
{
return
mStreamDescriptorId
;
}
IFACEMETHODIMP
GetMediaSource
(
IMFMediaSource
*
*
aMediaSource
)
override
;
IFACEMETHODIMP
GetStreamDescriptor
(
IMFStreamDescriptor
*
*
aStreamDescriptor
)
override
;
IFACEMETHODIMP
RequestSample
(
IUnknown
*
aToken
)
override
;
IFACEMETHODIMP
GetEvent
(
DWORD
aFlags
IMFMediaEvent
*
*
aEvent
)
override
;
IFACEMETHODIMP
BeginGetEvent
(
IMFAsyncCallback
*
aCallback
IUnknown
*
aState
)
override
;
IFACEMETHODIMP
EndGetEvent
(
IMFAsyncResult
*
aResult
IMFMediaEvent
*
*
aEvent
)
override
;
IFACEMETHODIMP
QueueEvent
(
MediaEventType
aType
REFGUID
aExtendedType
HRESULT
aStatus
const
PROPVARIANT
*
aValue
)
override
;
TaskQueue
*
GetTaskQueue
(
)
{
return
mTaskQueue
;
}
void
NotifyNewData
(
MediaRawData
*
aSample
)
;
void
NotifyEndOfStream
(
)
;
virtual
TrackInfo
:
:
TrackType
TrackType
(
)
=
0
;
RefPtr
<
MediaDataDecoder
:
:
FlushPromise
>
Flush
(
)
;
bool
IsEnded
(
)
const
;
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
&
EndedEvent
(
)
{
return
mEndedEvent
;
}
bool
IsShutdown
(
)
const
{
return
mIsShutdown
;
}
protected
:
HRESULT
GenerateStreamDescriptor
(
uint64_t
aStreamId
const
TrackInfo
&
aInfo
)
;
virtual
HRESULT
CreateMediaType
(
const
TrackInfo
&
aInfo
IMFMediaType
*
*
aMediaType
)
=
0
;
virtual
bool
HasEnoughRawData
(
)
const
=
0
;
HRESULT
CreateInputSample
(
IMFSample
*
*
aSample
)
;
void
ReplySampleRequestIfPossible
(
)
;
bool
ShouldServeSamples
(
)
const
;
void
AssertOnTaskQueue
(
)
const
;
void
AssertOnMFThreadPool
(
)
const
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IMFMediaEventQueue
>
mMediaEventQueue
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IMFStreamDescriptor
>
mStreamDescriptor
;
Microsoft
:
:
WRL
:
:
ComPtr
<
MFMediaSource
>
mParentSource
;
DWORD
mStreamDescriptorId
=
0
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
Atomic
<
bool
>
mIsShutdown
;
Atomic
<
bool
>
mIsSelected
;
Atomic
<
bool
>
mReceivedEOS
;
Atomic
<
bool
>
mShouldServeSmamples
;
MediaQueue
<
MediaRawData
>
mRawDataQueue
;
std
:
:
queue
<
Microsoft
:
:
WRL
:
:
ComPtr
<
IUnknown
>
>
mSampleRequestTokens
;
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
mEndedEvent
;
}
;
class
MFMediaEngineStreamWrapper
:
public
MediaDataDecoder
{
public
:
MFMediaEngineStreamWrapper
(
MFMediaEngineStream
*
aStream
TaskQueue
*
aTaskQueue
const
CreateDecoderParams
&
aParams
)
:
mStream
(
aStream
)
mTaskQueue
(
aTaskQueue
)
mFakeDataCreator
(
new
FakeDecodedDataCreator
(
aParams
)
)
{
MOZ_ASSERT
(
mStream
)
;
MOZ_ASSERT
(
mTaskQueue
)
;
MOZ_ASSERT
(
mFakeDataCreator
)
;
}
RefPtr
<
InitPromise
>
Init
(
)
override
;
RefPtr
<
DecodePromise
>
Decode
(
MediaRawData
*
aSample
)
override
;
RefPtr
<
DecodePromise
>
Drain
(
)
override
;
RefPtr
<
FlushPromise
>
Flush
(
)
override
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
nsCString
GetDescriptionName
(
)
const
override
;
private
:
Microsoft
:
:
WRL
:
:
ComPtr
<
MFMediaEngineStream
>
mStream
;
class
FakeDecodedDataCreator
final
{
public
:
explicit
FakeDecodedDataCreator
(
const
CreateDecoderParams
&
aParams
)
{
if
(
aParams
.
mConfig
.
IsVideo
(
)
)
{
const
VideoInfo
&
config
=
aParams
.
VideoConfig
(
)
;
mDummyDecoder
=
new
DummyMediaDataDecoder
(
MakeUnique
<
BlankVideoDataCreator
>
(
config
.
mDisplay
.
width
config
.
mDisplay
.
height
aParams
.
mImageContainer
)
"
blank
video
data
decoder
for
media
engine
"
_ns
aParams
)
;
mType
=
TrackInfo
:
:
TrackType
:
:
kVideoTrack
;
}
else
if
(
aParams
.
mConfig
.
IsAudio
(
)
)
{
const
AudioInfo
&
config
=
aParams
.
AudioConfig
(
)
;
mDummyDecoder
=
new
DummyMediaDataDecoder
(
MakeUnique
<
BlankAudioDataCreator
>
(
config
.
mChannels
config
.
mRate
)
"
blank
audio
data
decoder
for
media
engine
"
_ns
aParams
)
;
mType
=
TrackInfo
:
:
TrackType
:
:
kAudioTrack
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
config
type
"
)
;
}
}
RefPtr
<
MediaDataDecoder
:
:
DecodePromise
>
Decode
(
MediaRawData
*
aSample
)
{
return
mDummyDecoder
-
>
Decode
(
aSample
)
;
}
void
Flush
(
)
{
Unused
<
<
mDummyDecoder
-
>
Flush
(
)
;
}
TrackInfo
:
:
TrackType
Type
(
)
const
{
return
mType
;
}
private
:
RefPtr
<
MediaDataDecoder
>
mDummyDecoder
;
TrackInfo
:
:
TrackType
mType
;
}
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
UniquePtr
<
FakeDecodedDataCreator
>
mFakeDataCreator
;
}
;
}
#
endif
