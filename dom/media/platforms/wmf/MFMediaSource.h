#
ifndef
DOM_MEDIA_PLATFORM_WMF_MFMEDIASOURCE_H
#
define
DOM_MEDIA_PLATFORM_WMF_MFMEDIASOURCE_H
#
include
<
mfidl
.
h
>
#
include
<
wrl
.
h
>
#
include
"
MediaInfo
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MFMediaEngineExtra
.
h
"
#
include
"
MFMediaEngineStream
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
namespace
mozilla
{
struct
SampleRequest
{
SampleRequest
(
TrackInfo
:
:
TrackType
aType
bool
aIsEnough
)
:
mType
(
aType
)
mIsEnough
(
aIsEnough
)
{
}
TrackInfo
:
:
TrackType
mType
;
bool
mIsEnough
;
}
;
class
MFMediaSource
:
public
Microsoft
:
:
WRL
:
:
RuntimeClass
<
Microsoft
:
:
WRL
:
:
RuntimeClassFlags
<
Microsoft
:
:
WRL
:
:
RuntimeClassType
:
:
ClassicCom
>
IMFMediaSource
>
{
public
:
MFMediaSource
(
)
;
HRESULT
RuntimeClassInitialize
(
const
Maybe
<
AudioInfo
>
&
aAudio
const
Maybe
<
VideoInfo
>
&
aVideo
)
;
IFACEMETHODIMP
GetCharacteristics
(
DWORD
*
aCharacteristics
)
override
;
IFACEMETHODIMP
CreatePresentationDescriptor
(
IMFPresentationDescriptor
*
*
aPresentationDescriptor
)
override
;
IFACEMETHODIMP
Start
(
IMFPresentationDescriptor
*
aPresentationDescriptor
const
GUID
*
aGuidTimeFormat
const
PROPVARIANT
*
aStartPosition
)
override
;
IFACEMETHODIMP
Stop
(
)
override
;
IFACEMETHODIMP
Pause
(
)
override
;
IFACEMETHODIMP
Shutdown
(
)
override
;
IFACEMETHODIMP
GetEvent
(
DWORD
aFlags
IMFMediaEvent
*
*
aEvent
)
override
;
IFACEMETHODIMP
BeginGetEvent
(
IMFAsyncCallback
*
aCallback
IUnknown
*
aState
)
override
;
IFACEMETHODIMP
EndGetEvent
(
IMFAsyncResult
*
aResult
IMFMediaEvent
*
*
aEvent
)
override
;
IFACEMETHODIMP
QueueEvent
(
MediaEventType
aType
REFGUID
aExtendedType
HRESULT
aStatus
const
PROPVARIANT
*
aValue
)
override
;
MFMediaEngineStream
*
GetAudioStream
(
)
{
return
mAudioStream
.
Get
(
)
;
}
MFMediaEngineStream
*
GetVideoStream
(
)
{
return
mVideoStream
.
Get
(
)
;
}
TaskQueue
*
GetTaskQueue
(
)
{
return
mTaskQueue
;
}
MediaEventSource
<
SampleRequest
>
&
RequestSampleEvent
(
)
{
return
mRequestSampleEvent
;
}
void
NotifyEndOfStream
(
TrackInfo
:
:
TrackType
aType
)
{
Unused
<
<
GetTaskQueue
(
)
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
MFMediaSource
:
:
NotifyEndOfStream
"
[
aType
self
=
RefPtr
{
this
}
]
(
)
{
self
-
>
NotifyEndOfStreamInternal
(
aType
)
;
}
)
)
;
}
void
NotifyEndOfStreamInternal
(
TrackInfo
:
:
TrackType
aType
)
;
void
HandleStreamEnded
(
TrackInfo
:
:
TrackType
aType
)
;
enum
class
State
{
Initialized
Started
Stopped
Paused
Shutdowned
}
;
State
GetState
(
)
const
{
return
mState
;
}
private
:
void
AssertOnTaskQueue
(
)
const
;
void
AssertOnMFThreadPool
(
)
const
;
bool
IsSeekable
(
)
const
;
MFMediaEngineStream
*
GetStreamByDescriptorId
(
DWORD
aId
)
const
;
Microsoft
:
:
WRL
:
:
ComPtr
<
IMFMediaEventQueue
>
mMediaEventQueue
;
Microsoft
:
:
WRL
:
:
ComPtr
<
MFMediaEngineStream
>
mAudioStream
;
Microsoft
:
:
WRL
:
:
ComPtr
<
MFMediaEngineStream
>
mVideoStream
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
friend
class
MFMediaEngineStream
;
MediaEventProducer
<
SampleRequest
>
mRequestSampleEvent
;
MediaEventListener
mAudioStreamEndedListener
;
MediaEventListener
mVideoStreamEndedListener
;
Atomic
<
bool
>
mPresentationEnded
;
State
mState
;
}
;
}
#
endif
