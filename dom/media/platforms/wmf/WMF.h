#
ifndef
WMF_H_
#
define
WMF_H_
#
include
<
windows
.
h
>
#
include
<
mfapi
.
h
>
#
include
<
mfidl
.
h
>
#
include
<
mfreadwrite
.
h
>
#
include
<
mfobjects
.
h
>
#
include
<
ks
.
h
>
#
include
<
stdio
.
h
>
#
include
<
mferror
.
h
>
#
include
<
propvarutil
.
h
>
#
include
<
wmcodecdsp
.
h
>
#
include
<
d3d9
.
h
>
#
include
<
dxva2api
.
h
>
#
include
<
wmcodecdsp
.
h
>
#
include
<
codecapi
.
h
>
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
ifdef
min
#
undef
min
#
endif
#
ifdef
max
#
undef
max
#
endif
namespace
mozilla
{
namespace
wmf
{
class
MediaFoundationInitializer
final
{
public
:
~
MediaFoundationInitializer
(
)
{
if
(
mHasInitialized
)
{
if
(
FAILED
(
MFShutdown
(
)
)
)
{
NS_WARNING
(
"
MFShutdown
failed
"
)
;
}
}
}
static
bool
HasInitialized
(
)
{
if
(
sIsShutdown
)
{
return
false
;
}
return
Get
(
)
-
>
mHasInitialized
;
}
private
:
static
MediaFoundationInitializer
*
Get
(
)
{
{
StaticMutexAutoLock
lock
(
sCreateMutex
)
;
if
(
!
sInitializer
)
{
sInitializer
.
reset
(
new
MediaFoundationInitializer
(
)
)
;
GetMainThreadSerialEventTarget
(
)
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
MediaFoundationInitializer
:
:
Get
"
[
&
]
{
RunOnShutdown
(
[
&
]
{
sInitializer
.
reset
(
)
;
sIsShutdown
=
true
;
}
ShutdownPhase
:
:
XPCOMShutdown
)
;
}
)
)
;
}
}
return
sInitializer
.
get
(
)
;
}
MediaFoundationInitializer
(
)
:
mHasInitialized
(
SUCCEEDED
(
MFStartup
(
)
)
)
{
if
(
!
mHasInitialized
)
{
NS_WARNING
(
"
MFStartup
failed
"
)
;
}
}
HRESULT
MFStartup
(
)
;
HRESULT
MFShutdown
(
)
;
static
inline
UniquePtr
<
MediaFoundationInitializer
>
sInitializer
;
static
inline
StaticMutex
sCreateMutex
;
static
inline
Atomic
<
bool
>
sIsShutdown
{
false
}
;
const
bool
mHasInitialized
;
}
;
HRESULT
MFCreateMediaType
(
IMFMediaType
*
*
aOutMFType
)
;
HRESULT
MFGetStrideForBitmapInfoHeader
(
DWORD
aFormat
DWORD
aWidth
LONG
*
aOutStride
)
;
HRESULT
MFGetService
(
IUnknown
*
punkObject
REFGUID
guidService
REFIID
riid
LPVOID
*
ppvObject
)
;
HRESULT
DXVA2CreateDirect3DDeviceManager9
(
UINT
*
pResetToken
IDirect3DDeviceManager9
*
*
ppDXVAManager
)
;
HRESULT
MFCreateDXGIDeviceManager
(
UINT
*
pResetToken
IMFDXGIDeviceManager
*
*
ppDXVAManager
)
;
HRESULT
MFCreateSample
(
IMFSample
*
*
ppIMFSample
)
;
HRESULT
MFCreateAlignedMemoryBuffer
(
DWORD
cbMaxLength
DWORD
fAlignmentFlags
IMFMediaBuffer
*
*
ppBuffer
)
;
HRESULT
MFCreateDXGISurfaceBuffer
(
REFIID
riid
IUnknown
*
punkSurface
UINT
uSubresourceIndex
BOOL
fButtomUpWhenLinear
IMFMediaBuffer
*
*
ppBuffer
)
;
HRESULT
MFTEnumEx
(
GUID
guidCategory
UINT32
Flags
const
MFT_REGISTER_TYPE_INFO
*
pInputType
const
MFT_REGISTER_TYPE_INFO
*
pOutputType
IMFActivate
*
*
*
pppMFTActivate
UINT32
*
pnumMFTActivate
)
;
HRESULT
MFTGetInfo
(
CLSID
clsidMFT
LPWSTR
*
pszName
MFT_REGISTER_TYPE_INFO
*
*
ppInputTypes
UINT32
*
pcInputTypes
MFT_REGISTER_TYPE_INFO
*
*
ppOutputTypes
UINT32
*
pcOutputTypes
IMFAttributes
*
*
ppAttributes
)
;
HRESULT
MFCreateAttributes
(
IMFAttributes
*
*
ppMFAttributes
UINT32
cInitialSize
)
;
HRESULT
MFCreateEventQueue
(
IMFMediaEventQueue
*
*
ppMediaEventQueue
)
;
HRESULT
MFCreateStreamDescriptor
(
DWORD
dwStreamIdentifier
DWORD
cMediaTypes
IMFMediaType
*
*
apMediaTypes
IMFStreamDescriptor
*
*
ppDescriptor
)
;
HRESULT
MFCreateAsyncResult
(
IUnknown
*
punkObject
IMFAsyncCallback
*
pCallback
IUnknown
*
punkState
IMFAsyncResult
*
*
ppAsyncResult
)
;
HRESULT
MFCreatePresentationDescriptor
(
DWORD
cStreamDescriptors
IMFStreamDescriptor
*
*
apStreamDescriptors
IMFPresentationDescriptor
*
*
ppPresentationDescriptor
)
;
HRESULT
MFCreateMemoryBuffer
(
DWORD
cbMaxLength
IMFMediaBuffer
*
*
ppBuffer
)
;
}
}
#
endif
