#
include
<
algorithm
>
#
include
"
WMFVideoMFTManager
.
h
"
#
include
"
MediaDecoderReader
.
h
"
#
include
"
MediaPrefs
.
h
"
#
include
"
WMFUtils
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
DXVA2Manager
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
Layers
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
MediaPrefs
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxWindowsPlatform
.
h
"
#
include
"
IMFYCbCrImage
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
MediaTelemetryConstants
.
h
"
extern
mozilla
:
:
LogModule
*
GetPDMLog
(
)
;
#
define
LOG
(
.
.
.
)
MOZ_LOG
(
GetPDMLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
using
mozilla
:
:
layers
:
:
Image
;
using
mozilla
:
:
layers
:
:
IMFYCbCrImage
;
using
mozilla
:
:
layers
:
:
LayerManager
;
using
mozilla
:
:
layers
:
:
LayersBackend
;
#
if
MOZ_WINSDK_MAXVER
<
0x0A000000
const
GUID
MFVideoFormat_VP80
=
{
0x30385056
0x0000
0x0010
{
0x80
0x00
0x00
0xaa
0x00
0x38
0x9b
0x71
}
}
;
const
GUID
MFVideoFormat_VP90
=
{
0x30395056
0x0000
0x0010
{
0x80
0x00
0x00
0xaa
0x00
0x38
0x9b
0x71
}
}
;
#
endif
const
CLSID
CLSID_WebmMfVp8Dec
=
{
0x451e3cb7
0x2622
0x4ba5
{
0x8e
0x1d
0x44
0xb3
0xc4
0x1d
0x09
0x24
}
}
;
const
CLSID
CLSID_WebmMfVp9Dec
=
{
0x7ab4bd2
0x1979
0x4fcd
{
0xa6
0x97
0xdf
0x9a
0xd1
0x5b
0x34
0xfe
}
}
;
namespace
mozilla
{
WMFVideoMFTManager
:
:
WMFVideoMFTManager
(
const
VideoInfo
&
aConfig
mozilla
:
:
layers
:
:
LayersBackend
aLayersBackend
mozilla
:
:
layers
:
:
ImageContainer
*
aImageContainer
bool
aDXVAEnabled
)
:
mVideoInfo
(
aConfig
)
mVideoStride
(
0
)
mImageSize
(
aConfig
.
mImage
)
mImageContainer
(
aImageContainer
)
mDXVAEnabled
(
aDXVAEnabled
)
mLayersBackend
(
aLayersBackend
)
mNullOutputCount
(
0
)
mGotValidOutputAfterNullOutput
(
false
)
mGotExcessiveNullOutput
(
false
)
{
MOZ_COUNT_CTOR
(
WMFVideoMFTManager
)
;
if
(
aConfig
.
mMimeType
.
EqualsLiteral
(
"
video
/
mp4
"
)
|
|
aConfig
.
mMimeType
.
EqualsLiteral
(
"
video
/
avc
"
)
)
{
mStreamType
=
H264
;
}
else
if
(
aConfig
.
mMimeType
.
EqualsLiteral
(
"
video
/
webm
;
codecs
=
vp8
"
)
)
{
mStreamType
=
VP8
;
}
else
if
(
aConfig
.
mMimeType
.
EqualsLiteral
(
"
video
/
webm
;
codecs
=
vp9
"
)
)
{
mStreamType
=
VP9
;
}
else
{
mStreamType
=
Unknown
;
}
}
WMFVideoMFTManager
:
:
~
WMFVideoMFTManager
(
)
{
MOZ_COUNT_DTOR
(
WMFVideoMFTManager
)
;
if
(
mDXVA2Manager
)
{
DeleteOnMainThread
(
mDXVA2Manager
)
;
}
uint32_t
telemetry
=
(
mNullOutputCount
=
=
0
)
?
0
:
(
mGotValidOutputAfterNullOutput
&
&
mGotExcessiveNullOutput
)
?
1
:
mGotExcessiveNullOutput
?
2
:
mGotValidOutputAfterNullOutput
?
3
:
4
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
[
=
]
(
)
-
>
void
{
LOG
(
nsPrintfCString
(
"
Reporting
telemetry
VIDEO_MFT_OUTPUT_NULL_SAMPLES
=
%
d
"
telemetry
)
.
get
(
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
ID
:
:
VIDEO_MFT_OUTPUT_NULL_SAMPLES
telemetry
)
;
}
)
;
AbstractThread
:
:
MainThread
(
)
-
>
Dispatch
(
task
.
forget
(
)
)
;
}
const
GUID
&
WMFVideoMFTManager
:
:
GetMFTGUID
(
)
{
MOZ_ASSERT
(
mStreamType
!
=
Unknown
)
;
switch
(
mStreamType
)
{
case
H264
:
return
CLSID_CMSH264DecoderMFT
;
case
VP8
:
return
CLSID_WebmMfVp8Dec
;
case
VP9
:
return
CLSID_WebmMfVp9Dec
;
default
:
return
GUID_NULL
;
}
;
}
const
GUID
&
WMFVideoMFTManager
:
:
GetMediaSubtypeGUID
(
)
{
MOZ_ASSERT
(
mStreamType
!
=
Unknown
)
;
switch
(
mStreamType
)
{
case
H264
:
return
MFVideoFormat_H264
;
case
VP8
:
return
MFVideoFormat_VP80
;
case
VP9
:
return
MFVideoFormat_VP90
;
default
:
return
GUID_NULL
;
}
;
}
struct
BlacklistedD3D11DLL
{
LPCWSTR
name
;
DWORD
ms
;
DWORD
ls
;
}
;
#
define
DLLVER
(
a
b
c
d
)
\
(
(
DWORD
(
a
)
<
<
16
)
|
DWORD
(
b
)
)
(
(
DWORD
(
c
)
<
<
16
)
|
DWORD
(
d
)
)
static
const
BlacklistedD3D11DLL
sBlacklistedD3D11DLL
[
]
=
{
{
L
"
igd10umd32
.
dll
"
DLLVER
(
9
17
10
2857
)
}
{
L
"
tosqep
.
dll
"
DLLVER
(
1
2
15
526
)
}
{
L
"
tosqep
.
dll
"
DLLVER
(
1
1
12
201
)
}
{
L
"
tosqep
.
dll
"
DLLVER
(
1
0
11
318
)
}
{
L
"
tosqep
.
dll
"
DLLVER
(
1
0
11
215
)
}
{
L
"
tosqep64
.
dll
"
DLLVER
(
1
1
12
201
)
}
{
L
"
tosqep64
.
dll
"
DLLVER
(
1
0
11
215
)
}
{
nullptr
0u
0u
}
}
;
#
undef
DLLVER
static
const
BlacklistedD3D11DLL
*
IsD3D11DLLBlacklisted
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Must
be
on
main
thread
.
"
)
;
static
const
BlacklistedD3D11DLL
*
sAlreadySearched
=
nullptr
;
if
(
sAlreadySearched
)
{
return
sAlreadySearched
-
>
name
?
sAlreadySearched
:
nullptr
;
}
WCHAR
systemPath
[
MAX_PATH
+
1
]
;
LPCWSTR
previousDLLName
=
L
"
"
;
VS_FIXEDFILEINFO
*
vInfo
=
nullptr
;
UniquePtr
<
unsigned
char
[
]
>
infoData
;
for
(
const
BlacklistedD3D11DLL
*
dll
=
sBlacklistedD3D11DLL
;
;
+
+
dll
)
{
if
(
!
dll
-
>
name
)
{
sAlreadySearched
=
dll
;
return
nullptr
;
}
if
(
wcscmp
(
previousDLLName
dll
-
>
name
)
!
=
0
)
{
previousDLLName
=
dll
-
>
name
;
vInfo
=
nullptr
;
infoData
=
nullptr
;
if
(
!
ConstructSystem32Path
(
dll
-
>
name
systemPath
MAX_PATH
+
1
)
)
{
continue
;
}
DWORD
zero
;
DWORD
infoSize
=
GetFileVersionInfoSizeW
(
systemPath
&
zero
)
;
if
(
infoSize
=
=
0
)
{
continue
;
}
infoData
=
MakeUnique
<
unsigned
char
[
]
>
(
infoSize
)
;
UINT
vInfoLen
;
if
(
!
GetFileVersionInfoW
(
systemPath
0
infoSize
infoData
.
get
(
)
)
|
|
!
VerQueryValueW
(
infoData
.
get
(
)
L
"
\
\
"
(
LPVOID
*
)
&
vInfo
&
vInfoLen
)
)
{
vInfo
=
nullptr
;
infoData
=
nullptr
;
continue
;
}
}
if
(
vInfo
&
&
vInfo
-
>
dwFileVersionMS
=
=
dll
-
>
ms
&
&
vInfo
-
>
dwFileVersionLS
=
=
dll
-
>
ls
)
{
sAlreadySearched
=
dll
;
return
dll
;
}
}
}
class
CreateDXVAManagerEvent
:
public
Runnable
{
public
:
CreateDXVAManagerEvent
(
LayersBackend
aBackend
nsCString
&
aFailureReason
)
:
mBackend
(
aBackend
)
mFailureReason
(
aFailureReason
)
{
}
NS_IMETHOD
Run
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Must
be
on
main
thread
.
"
)
;
nsACString
*
failureReason
=
&
mFailureReason
;
nsCString
secondFailureReason
;
if
(
mBackend
=
=
LayersBackend
:
:
LAYERS_D3D11
&
&
MediaPrefs
:
:
PDMWMFAllowD3D11
(
)
&
&
IsWin8OrLater
(
)
)
{
const
BlacklistedD3D11DLL
*
blacklistedDLL
=
IsD3D11DLLBlacklisted
(
)
;
if
(
blacklistedDLL
)
{
failureReason
-
>
AppendPrintf
(
"
D3D11
blacklisted
with
DLL
%
s
(
%
u
.
%
u
.
%
u
.
%
u
)
"
blacklistedDLL
-
>
name
blacklistedDLL
-
>
ms
>
>
16
blacklistedDLL
-
>
ms
&
0xFFu
blacklistedDLL
-
>
ls
>
>
16
blacklistedDLL
-
>
ls
&
0xFFu
)
;
}
else
{
mDXVA2Manager
=
DXVA2Manager
:
:
CreateD3D11DXVA
(
*
failureReason
)
;
if
(
mDXVA2Manager
)
{
return
NS_OK
;
}
}
failureReason
=
&
secondFailureReason
;
mFailureReason
.
Append
(
NS_LITERAL_CSTRING
(
"
;
"
)
)
;
}
mDXVA2Manager
=
DXVA2Manager
:
:
CreateD3D9DXVA
(
*
failureReason
)
;
mFailureReason
.
Append
(
secondFailureReason
)
;
return
NS_OK
;
}
nsAutoPtr
<
DXVA2Manager
>
mDXVA2Manager
;
LayersBackend
mBackend
;
nsACString
&
mFailureReason
;
}
;
bool
WMFVideoMFTManager
:
:
InitializeDXVA
(
bool
aForceD3D9
)
{
if
(
!
mDXVAEnabled
)
{
mDXVAFailureReason
.
AssignLiteral
(
"
Hardware
video
decoding
disabled
or
blacklisted
"
)
;
return
false
;
}
MOZ_ASSERT
(
!
mDXVA2Manager
)
;
if
(
mLayersBackend
!
=
LayersBackend
:
:
LAYERS_D3D9
&
&
mLayersBackend
!
=
LayersBackend
:
:
LAYERS_D3D11
)
{
mDXVAFailureReason
.
AssignLiteral
(
"
Unsupported
layers
backend
"
)
;
return
false
;
}
RefPtr
<
CreateDXVAManagerEvent
>
event
=
new
CreateDXVAManagerEvent
(
aForceD3D9
?
LayersBackend
:
:
LAYERS_D3D9
:
mLayersBackend
mDXVAFailureReason
)
;
if
(
NS_IsMainThread
(
)
)
{
event
-
>
Run
(
)
;
}
else
{
NS_DispatchToMainThread
(
event
NS_DISPATCH_SYNC
)
;
}
mDXVA2Manager
=
event
-
>
mDXVA2Manager
;
return
mDXVA2Manager
!
=
nullptr
;
}
bool
WMFVideoMFTManager
:
:
Init
(
)
{
bool
success
=
InitInternal
(
false
)
;
if
(
success
&
&
mDXVA2Manager
)
{
if
(
mDXVA2Manager
-
>
IsD3D11
(
)
)
{
mDXVAFailureReason
.
Append
(
NS_LITERAL_CSTRING
(
"
Using
D3D11
API
"
)
)
;
}
else
{
mDXVAFailureReason
.
Append
(
NS_LITERAL_CSTRING
(
"
Using
D3D9
API
"
)
)
;
}
}
return
success
;
}
bool
WMFVideoMFTManager
:
:
InitInternal
(
bool
aForceD3D9
)
{
mUseHwAccel
=
false
;
bool
useDxva
=
InitializeDXVA
(
aForceD3D9
|
|
mStreamType
=
=
VP8
|
|
mStreamType
=
=
VP9
)
;
RefPtr
<
MFTDecoder
>
decoder
(
new
MFTDecoder
(
)
)
;
HRESULT
hr
=
decoder
-
>
Create
(
GetMFTGUID
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
RefPtr
<
IMFAttributes
>
attr
(
decoder
-
>
GetAttributes
(
)
)
;
UINT32
aware
=
0
;
if
(
attr
)
{
attr
-
>
GetUINT32
(
MF_SA_D3D_AWARE
&
aware
)
;
attr
-
>
SetUINT32
(
CODECAPI_AVDecNumWorkerThreads
WMFDecoderModule
:
:
GetNumDecoderThreads
(
)
)
;
if
(
MediaPrefs
:
:
PDMWMFLowLatencyEnabled
(
)
)
{
hr
=
attr
-
>
SetUINT32
(
CODECAPI_AVLowLatencyMode
TRUE
)
;
if
(
SUCCEEDED
(
hr
)
)
{
LOG
(
"
Enabling
Low
Latency
Mode
"
)
;
}
else
{
LOG
(
"
Couldn
'
t
enable
Low
Latency
Mode
"
)
;
}
}
}
if
(
useDxva
)
{
if
(
aware
)
{
MOZ_ASSERT
(
mDXVA2Manager
)
;
ULONG_PTR
manager
=
ULONG_PTR
(
mDXVA2Manager
-
>
GetDXVADeviceManager
(
)
)
;
hr
=
decoder
-
>
SendMFTMessage
(
MFT_MESSAGE_SET_D3D_MANAGER
manager
)
;
if
(
SUCCEEDED
(
hr
)
)
{
mUseHwAccel
=
true
;
}
else
{
mDXVA2Manager
=
nullptr
;
mDXVAFailureReason
=
nsPrintfCString
(
"
MFT_MESSAGE_SET_D3D_MANAGER
failed
with
code
%
X
"
hr
)
;
}
}
else
{
mDXVAFailureReason
.
AssignLiteral
(
"
Decoder
returned
false
for
MF_SA_D3D_AWARE
"
)
;
}
}
if
(
!
mUseHwAccel
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MEDIA_DECODER_BACKEND_USED
uint32_t
(
media
:
:
MediaDecoderBackend
:
:
WMFSoftware
)
)
;
}
mDecoder
=
decoder
;
hr
=
SetDecoderMediaTypes
(
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
LOG
(
"
Video
Decoder
initialized
Using
DXVA
:
%
s
"
(
mUseHwAccel
?
"
Yes
"
:
"
No
"
)
)
;
return
true
;
}
HRESULT
WMFVideoMFTManager
:
:
SetDecoderMediaTypes
(
)
{
RefPtr
<
IMFMediaType
>
inputType
;
HRESULT
hr
=
wmf
:
:
MFCreateMediaType
(
getter_AddRefs
(
inputType
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
hr
=
inputType
-
>
SetGUID
(
MF_MT_MAJOR_TYPE
MFMediaType_Video
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
hr
=
inputType
-
>
SetGUID
(
MF_MT_SUBTYPE
GetMediaSubtypeGUID
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
hr
=
inputType
-
>
SetUINT32
(
MF_MT_INTERLACE_MODE
MFVideoInterlace_MixedInterlaceOrProgressive
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
RefPtr
<
IMFMediaType
>
outputType
;
hr
=
wmf
:
:
MFCreateMediaType
(
getter_AddRefs
(
outputType
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
hr
=
outputType
-
>
SetGUID
(
MF_MT_MAJOR_TYPE
MFMediaType_Video
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
GUID
outputSubType
=
mUseHwAccel
?
MFVideoFormat_NV12
:
MFVideoFormat_YV12
;
hr
=
outputType
-
>
SetGUID
(
MF_MT_SUBTYPE
outputSubType
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
return
mDecoder
-
>
SetMediaTypes
(
inputType
outputType
)
;
}
HRESULT
WMFVideoMFTManager
:
:
Input
(
MediaRawData
*
aSample
)
{
if
(
!
mDecoder
)
{
return
E_FAIL
;
}
HRESULT
hr
=
mDecoder
-
>
CreateInputSample
(
aSample
-
>
Data
(
)
uint32_t
(
aSample
-
>
Size
(
)
)
aSample
-
>
mTime
&
mLastInput
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
&
&
mLastInput
!
=
nullptr
hr
)
;
mLastDuration
=
aSample
-
>
mDuration
;
return
mDecoder
-
>
Input
(
mLastInput
)
;
}
bool
WMFVideoMFTManager
:
:
CanUseDXVA
(
IMFMediaType
*
aType
)
{
MOZ_ASSERT
(
mDXVA2Manager
)
;
if
(
mStreamType
!
=
H264
)
{
return
true
;
}
float
framerate
=
1000000
.
0
/
mLastDuration
;
return
mDXVA2Manager
-
>
SupportsConfig
(
aType
framerate
)
;
}
HRESULT
WMFVideoMFTManager
:
:
ConfigureVideoFrameGeometry
(
)
{
RefPtr
<
IMFMediaType
>
mediaType
;
HRESULT
hr
=
mDecoder
-
>
GetOutputMediaType
(
mediaType
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
if
(
mUseHwAccel
&
&
!
CanUseDXVA
(
mediaType
)
)
{
mDXVAEnabled
=
false
;
if
(
!
Init
(
)
)
{
return
E_FAIL
;
}
mDecoder
-
>
Input
(
mLastInput
)
;
return
S_OK
;
}
GUID
videoFormat
;
hr
=
mediaType
-
>
GetGUID
(
MF_MT_SUBTYPE
&
videoFormat
)
;
NS_ENSURE_TRUE
(
videoFormat
=
=
MFVideoFormat_NV12
|
|
!
mUseHwAccel
E_FAIL
)
;
NS_ENSURE_TRUE
(
videoFormat
=
=
MFVideoFormat_YV12
|
|
mUseHwAccel
E_FAIL
)
;
nsIntRect
pictureRegion
;
hr
=
GetPictureRegion
(
mediaType
pictureRegion
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
UINT32
width
=
pictureRegion
.
width
;
UINT32
height
=
pictureRegion
.
height
;
mImageSize
=
nsIntSize
(
width
height
)
;
pictureRegion
=
mVideoInfo
.
ScaledImageRect
(
width
height
)
;
if
(
!
IsValidVideoRegion
(
mImageSize
pictureRegion
mVideoInfo
.
mDisplay
)
)
{
return
E_FAIL
;
}
if
(
mDXVA2Manager
)
{
hr
=
mDXVA2Manager
-
>
ConfigureForSize
(
width
height
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
}
GetDefaultStride
(
mediaType
width
&
mVideoStride
)
;
LOG
(
"
WMFVideoMFTManager
frame
geometry
frame
=
(
%
u
%
u
)
stride
=
%
u
picture
=
(
%
d
%
d
%
d
%
d
)
display
=
(
%
d
%
d
)
"
width
height
mVideoStride
pictureRegion
.
x
pictureRegion
.
y
pictureRegion
.
width
pictureRegion
.
height
mVideoInfo
.
mDisplay
.
width
mVideoInfo
.
mDisplay
.
height
)
;
return
S_OK
;
}
HRESULT
WMFVideoMFTManager
:
:
CreateBasicVideoFrame
(
IMFSample
*
aSample
int64_t
aStreamOffset
VideoData
*
*
aOutVideoData
)
{
NS_ENSURE_TRUE
(
aSample
E_POINTER
)
;
NS_ENSURE_TRUE
(
aOutVideoData
E_POINTER
)
;
*
aOutVideoData
=
nullptr
;
HRESULT
hr
;
RefPtr
<
IMFMediaBuffer
>
buffer
;
hr
=
aSample
-
>
ConvertToContiguousBuffer
(
getter_AddRefs
(
buffer
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
BYTE
*
data
=
nullptr
;
LONG
stride
=
0
;
RefPtr
<
IMF2DBuffer
>
twoDBuffer
;
hr
=
buffer
-
>
QueryInterface
(
static_cast
<
IMF2DBuffer
*
*
>
(
getter_AddRefs
(
twoDBuffer
)
)
)
;
if
(
SUCCEEDED
(
hr
)
)
{
hr
=
twoDBuffer
-
>
Lock2D
(
&
data
&
stride
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
}
else
{
hr
=
buffer
-
>
Lock
(
&
data
nullptr
nullptr
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
stride
=
mVideoStride
;
}
VideoData
:
:
YCbCrBuffer
b
;
uint32_t
videoWidth
=
mImageSize
.
width
;
uint32_t
videoHeight
=
mImageSize
.
height
;
b
.
mPlanes
[
0
]
.
mData
=
data
;
b
.
mPlanes
[
0
]
.
mStride
=
stride
;
b
.
mPlanes
[
0
]
.
mHeight
=
videoHeight
;
b
.
mPlanes
[
0
]
.
mWidth
=
videoWidth
;
b
.
mPlanes
[
0
]
.
mOffset
=
0
;
b
.
mPlanes
[
0
]
.
mSkip
=
0
;
uint32_t
padding
=
0
;
if
(
videoHeight
%
16
!
=
0
)
{
padding
=
16
-
(
videoHeight
%
16
)
;
}
uint32_t
y_size
=
stride
*
(
videoHeight
+
padding
)
;
uint32_t
v_size
=
stride
*
(
videoHeight
+
padding
)
/
4
;
uint32_t
halfStride
=
(
stride
+
1
)
/
2
;
uint32_t
halfHeight
=
(
videoHeight
+
1
)
/
2
;
uint32_t
halfWidth
=
(
videoWidth
+
1
)
/
2
;
b
.
mPlanes
[
1
]
.
mData
=
data
+
y_size
+
v_size
;
b
.
mPlanes
[
1
]
.
mStride
=
halfStride
;
b
.
mPlanes
[
1
]
.
mHeight
=
halfHeight
;
b
.
mPlanes
[
1
]
.
mWidth
=
halfWidth
;
b
.
mPlanes
[
1
]
.
mOffset
=
0
;
b
.
mPlanes
[
1
]
.
mSkip
=
0
;
b
.
mPlanes
[
2
]
.
mData
=
data
+
y_size
;
b
.
mPlanes
[
2
]
.
mStride
=
halfStride
;
b
.
mPlanes
[
2
]
.
mHeight
=
halfHeight
;
b
.
mPlanes
[
2
]
.
mWidth
=
halfWidth
;
b
.
mPlanes
[
2
]
.
mOffset
=
0
;
b
.
mPlanes
[
2
]
.
mSkip
=
0
;
media
:
:
TimeUnit
pts
=
GetSampleTime
(
aSample
)
;
NS_ENSURE_TRUE
(
pts
.
IsValid
(
)
E_FAIL
)
;
media
:
:
TimeUnit
duration
=
GetSampleDuration
(
aSample
)
;
NS_ENSURE_TRUE
(
duration
.
IsValid
(
)
E_FAIL
)
;
RefPtr
<
layers
:
:
PlanarYCbCrImage
>
image
=
new
IMFYCbCrImage
(
buffer
twoDBuffer
)
;
nsIntRect
pictureRegion
=
mVideoInfo
.
ScaledImageRect
(
videoWidth
videoHeight
)
;
VideoData
:
:
SetVideoDataToImage
(
image
mVideoInfo
b
pictureRegion
false
)
;
RefPtr
<
VideoData
>
v
=
VideoData
:
:
CreateFromImage
(
mVideoInfo
mImageContainer
aStreamOffset
pts
.
ToMicroseconds
(
)
duration
.
ToMicroseconds
(
)
image
.
forget
(
)
false
-
1
pictureRegion
)
;
v
.
forget
(
aOutVideoData
)
;
return
S_OK
;
}
HRESULT
WMFVideoMFTManager
:
:
CreateD3DVideoFrame
(
IMFSample
*
aSample
int64_t
aStreamOffset
VideoData
*
*
aOutVideoData
)
{
NS_ENSURE_TRUE
(
aSample
E_POINTER
)
;
NS_ENSURE_TRUE
(
aOutVideoData
E_POINTER
)
;
NS_ENSURE_TRUE
(
mDXVA2Manager
E_ABORT
)
;
NS_ENSURE_TRUE
(
mUseHwAccel
E_ABORT
)
;
*
aOutVideoData
=
nullptr
;
HRESULT
hr
;
nsIntRect
pictureRegion
=
mVideoInfo
.
ScaledImageRect
(
mImageSize
.
width
mImageSize
.
height
)
;
RefPtr
<
Image
>
image
;
hr
=
mDXVA2Manager
-
>
CopyToImage
(
aSample
pictureRegion
mImageContainer
getter_AddRefs
(
image
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
NS_ENSURE_TRUE
(
image
E_FAIL
)
;
media
:
:
TimeUnit
pts
=
GetSampleTime
(
aSample
)
;
NS_ENSURE_TRUE
(
pts
.
IsValid
(
)
E_FAIL
)
;
media
:
:
TimeUnit
duration
=
GetSampleDuration
(
aSample
)
;
NS_ENSURE_TRUE
(
duration
.
IsValid
(
)
E_FAIL
)
;
RefPtr
<
VideoData
>
v
=
VideoData
:
:
CreateFromImage
(
mVideoInfo
mImageContainer
aStreamOffset
pts
.
ToMicroseconds
(
)
duration
.
ToMicroseconds
(
)
image
.
forget
(
)
false
-
1
pictureRegion
)
;
NS_ENSURE_TRUE
(
v
E_FAIL
)
;
v
.
forget
(
aOutVideoData
)
;
return
S_OK
;
}
HRESULT
WMFVideoMFTManager
:
:
Output
(
int64_t
aStreamOffset
RefPtr
<
MediaData
>
&
aOutData
)
{
RefPtr
<
IMFSample
>
sample
;
HRESULT
hr
;
aOutData
=
nullptr
;
int
typeChangeCount
=
0
;
while
(
true
)
{
hr
=
mDecoder
-
>
Output
(
&
sample
)
;
if
(
hr
=
=
MF_E_TRANSFORM_NEED_MORE_INPUT
)
{
return
MF_E_TRANSFORM_NEED_MORE_INPUT
;
}
if
(
hr
=
=
MF_E_TRANSFORM_STREAM_CHANGE
)
{
MOZ_ASSERT
(
!
sample
)
;
hr
=
ConfigureVideoFrameGeometry
(
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
NS_ENSURE_TRUE
(
typeChangeCount
<
100
MF_E_TRANSFORM_STREAM_CHANGE
)
;
+
+
typeChangeCount
;
continue
;
}
if
(
SUCCEEDED
(
hr
)
)
{
if
(
!
sample
)
{
LOG
(
"
Video
MFTDecoder
returned
success
but
no
output
!
"
)
;
+
+
mNullOutputCount
;
if
(
mNullOutputCount
>
250
)
{
LOG
(
"
Excessive
Video
MFTDecoder
returning
success
but
no
output
;
giving
up
"
)
;
mGotExcessiveNullOutput
=
true
;
return
E_FAIL
;
}
continue
;
}
break
;
}
NS_WARNING
(
"
WMFVideoMFTManager
:
:
Output
(
)
unexpected
error
"
)
;
return
hr
;
}
RefPtr
<
VideoData
>
frame
;
if
(
mUseHwAccel
)
{
hr
=
CreateD3DVideoFrame
(
sample
aStreamOffset
getter_AddRefs
(
frame
)
)
;
}
else
{
hr
=
CreateBasicVideoFrame
(
sample
aStreamOffset
getter_AddRefs
(
frame
)
)
;
}
MOZ_ASSERT
(
(
frame
!
=
nullptr
)
=
=
SUCCEEDED
(
hr
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
hr
)
;
NS_ENSURE_TRUE
(
frame
E_FAIL
)
;
aOutData
=
frame
;
if
(
mNullOutputCount
)
{
mGotValidOutputAfterNullOutput
=
true
;
}
return
S_OK
;
}
void
WMFVideoMFTManager
:
:
Shutdown
(
)
{
mDecoder
=
nullptr
;
DeleteOnMainThread
(
mDXVA2Manager
)
;
}
bool
WMFVideoMFTManager
:
:
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
{
aFailureReason
=
mDXVAFailureReason
;
return
mDecoder
&
&
mUseHwAccel
;
}
const
char
*
WMFVideoMFTManager
:
:
GetDescriptionName
(
)
const
{
if
(
mDecoder
&
&
mUseHwAccel
&
&
mDXVA2Manager
)
{
return
(
mDXVA2Manager
-
>
IsD3D11
(
)
)
?
"
D3D11
Hardware
Decoder
"
:
"
D3D9
Hardware
Decoder
"
;
}
else
{
return
"
wmf
software
video
decoder
"
;
}
}
void
WMFVideoMFTManager
:
:
ConfigurationChanged
(
const
TrackInfo
&
aConfig
)
{
MOZ_ASSERT
(
aConfig
.
GetAsVideoInfo
(
)
)
;
mVideoInfo
=
*
aConfig
.
GetAsVideoInfo
(
)
;
mImageSize
=
mVideoInfo
.
mImage
;
}
}
