#
include
"
WMFDecoderModule
.
h
"
#
include
<
algorithm
>
#
include
<
vector
>
#
include
"
DriverCrashGuard
.
h
"
#
include
"
GfxDriverInfo
.
h
"
#
include
"
MFTDecoder
.
h
"
#
include
"
MP4Decoder
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
PDMFactory
.
h
"
#
include
"
VPXDecoder
.
h
"
#
include
"
WMF
.
h
"
#
include
"
WMFAudioMFTManager
.
h
"
#
include
"
WMFMediaDataDecoder
.
h
"
#
include
"
WMFVideoMFTManager
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
mscom
/
EnsureMTA
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
prsystem
.
h
"
#
define
LOG
(
.
.
.
)
MOZ_LOG
(
sPDMLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
ProfilerMarkerPayload
.
h
"
#
define
WFM_DECODER_MODULE_STATUS_MARKER
(
tag
text
markerTime
)
\
PROFILER_ADD_MARKER_WITH_PAYLOAD
(
tag
MEDIA_PLAYBACK
TextMarkerPayload
\
(
text
markerTime
)
)
#
else
#
define
WFM_DECODER_MODULE_STATUS_MARKER
(
tag
text
markerTime
)
#
endif
extern
const
GUID
CLSID_WebmMfVpxDec
;
namespace
mozilla
{
static
void
MOZ_FORMAT_PRINTF
(
2
3
)
WmfDeocderModuleMarkerAndLog
(
const
char
*
aTag
const
char
*
aFormat
.
.
.
)
{
va_list
ap
;
va_start
(
ap
aFormat
)
;
const
nsVprintfCString
markerString
(
aFormat
ap
)
;
va_end
(
ap
)
;
WFM_DECODER_MODULE_STATUS_MARKER
(
aTag
markerString
TimeStamp
:
:
NowUnfuzzed
(
)
)
;
LOG
(
"
%
s
"
markerString
.
get
(
)
)
;
}
static
Atomic
<
bool
>
sDXVAEnabled
(
false
)
;
static
Atomic
<
bool
>
sUsableVPXMFT
(
false
)
;
already_AddRefed
<
PlatformDecoderModule
>
WMFDecoderModule
:
:
Create
(
)
{
return
MakeAndAddRef
<
WMFDecoderModule
>
(
)
;
}
WMFDecoderModule
:
:
~
WMFDecoderModule
(
)
{
if
(
mWMFInitialized
)
{
DebugOnly
<
HRESULT
>
hr
=
wmf
:
:
MFShutdown
(
)
;
NS_ASSERTION
(
SUCCEEDED
(
hr
)
"
MFShutdown
failed
"
)
;
}
}
static
bool
IsRemoteAcceleratedCompositor
(
const
SupportDecoderParams
&
aParams
)
{
if
(
!
aParams
.
mKnowsCompositor
)
{
return
false
;
}
TextureFactoryIdentifier
ident
=
aParams
.
mKnowsCompositor
-
>
GetTextureFactoryIdentifier
(
)
;
return
ident
.
mParentBackend
!
=
LayersBackend
:
:
LAYERS_BASIC
&
&
!
aParams
.
mKnowsCompositor
-
>
UsingSoftwareWebRender
(
)
&
&
ident
.
mParentProcessType
=
=
GeckoProcessType_GPU
;
}
static
bool
CanCreateMFTDecoder
(
const
GUID
&
aGuid
)
{
bool
canCreateDecoder
=
false
;
mozilla
:
:
mscom
:
:
EnsureMTA
(
[
&
]
(
)
-
>
void
{
if
(
FAILED
(
wmf
:
:
MFStartup
(
)
)
)
{
return
;
}
RefPtr
<
MFTDecoder
>
decoder
(
new
MFTDecoder
(
)
)
;
canCreateDecoder
=
SUCCEEDED
(
decoder
-
>
Create
(
aGuid
)
)
;
wmf
:
:
MFShutdown
(
)
;
}
)
;
return
canCreateDecoder
;
}
void
WMFDecoderModule
:
:
Init
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
XRE_IsContentProcess
(
)
)
{
sDXVAEnabled
=
!
StaticPrefs
:
:
media_gpu_process_decoder
(
)
;
}
else
if
(
XRE_IsGPUProcess
(
)
|
|
XRE_IsRDDProcess
(
)
)
{
sDXVAEnabled
=
true
;
}
else
{
sDXVAEnabled
=
!
mozilla
:
:
BrowserTabsRemoteAutostart
(
)
;
}
sDXVAEnabled
=
sDXVAEnabled
&
&
gfx
:
:
gfxVars
:
:
CanUseHardwareVideoDecoding
(
)
;
bool
testForVPx
=
gfx
:
:
gfxVars
:
:
CanUseHardwareVideoDecoding
(
)
;
if
(
testForVPx
&
&
StaticPrefs
:
:
media_wmf_vp9_enabled_AtStartup
(
)
)
{
gfx
:
:
WMFVPXVideoCrashGuard
guard
;
if
(
!
guard
.
Crashed
(
)
)
{
WmfDeocderModuleMarkerAndLog
(
"
WMFInit
VPx
Pending
"
"
Attempting
to
create
MFT
decoder
for
VPx
"
)
;
sUsableVPXMFT
=
CanCreateMFTDecoder
(
CLSID_WebmMfVpxDec
)
;
WmfDeocderModuleMarkerAndLog
(
"
WMFInit
VPx
Initialized
"
"
CanCreateMFTDecoder
returned
%
s
for
VPx
"
sUsableVPXMFT
?
"
true
"
:
"
false
"
)
;
}
else
{
WmfDeocderModuleMarkerAndLog
(
"
WMFInit
VPx
Failure
"
"
Will
not
use
MFT
VPx
due
to
crash
guard
reporting
a
crash
"
)
;
}
}
WmfDeocderModuleMarkerAndLog
(
"
WMFInit
Result
"
"
WMFDecoderModule
:
:
Init
finishing
with
sDXVAEnabled
=
%
s
testForVPx
=
%
s
"
"
sUsableVPXMFT
=
%
s
"
sDXVAEnabled
?
"
true
"
:
"
false
"
testForVPx
?
"
true
"
:
"
false
"
sUsableVPXMFT
?
"
true
"
:
"
false
"
)
;
}
int
WMFDecoderModule
:
:
GetNumDecoderThreads
(
)
{
int32_t
numCores
=
PR_GetNumberOfProcessors
(
)
;
static
const
int
WMF_DECODER_DEFAULT
=
-
1
;
if
(
numCores
>
4
)
{
return
WMF_DECODER_DEFAULT
;
}
return
std
:
:
max
(
numCores
-
1
1
)
;
}
nsresult
WMFDecoderModule
:
:
Startup
(
)
{
mWMFInitialized
=
SUCCEEDED
(
wmf
:
:
MFStartup
(
)
)
;
return
mWMFInitialized
?
NS_OK
:
NS_ERROR_FAILURE
;
}
already_AddRefed
<
MediaDataDecoder
>
WMFDecoderModule
:
:
CreateVideoDecoder
(
const
CreateDecoderParams
&
aParams
)
{
UniquePtr
<
WMFVideoMFTManager
>
manager
(
new
WMFVideoMFTManager
(
aParams
.
VideoConfig
(
)
aParams
.
mKnowsCompositor
aParams
.
mImageContainer
aParams
.
mRate
.
mValue
aParams
.
mOptions
sDXVAEnabled
)
)
;
MediaResult
result
=
manager
-
>
Init
(
)
;
if
(
NS_FAILED
(
result
)
)
{
if
(
aParams
.
mError
)
{
*
aParams
.
mError
=
result
;
}
WmfDeocderModuleMarkerAndLog
(
"
WMFVDecoderCreation
Failure
"
"
WMFDecoderModule
:
:
CreateVideoDecoder
failed
for
manager
with
"
"
description
%
s
with
result
:
%
s
"
manager
-
>
GetDescriptionName
(
)
.
get
(
)
result
.
Description
(
)
.
get
(
)
)
;
return
nullptr
;
}
WmfDeocderModuleMarkerAndLog
(
"
WMFVDecoderCreation
Success
"
"
WMFDecoderModule
:
:
CreateVideoDecoder
success
for
manager
with
"
"
description
%
s
"
manager
-
>
GetDescriptionName
(
)
.
get
(
)
)
;
RefPtr
<
MediaDataDecoder
>
decoder
=
new
WMFMediaDataDecoder
(
manager
.
release
(
)
)
;
return
decoder
.
forget
(
)
;
}
already_AddRefed
<
MediaDataDecoder
>
WMFDecoderModule
:
:
CreateAudioDecoder
(
const
CreateDecoderParams
&
aParams
)
{
UniquePtr
<
WMFAudioMFTManager
>
manager
(
new
WMFAudioMFTManager
(
aParams
.
AudioConfig
(
)
)
)
;
if
(
!
manager
-
>
Init
(
)
)
{
WmfDeocderModuleMarkerAndLog
(
"
WMFADecoderCreation
Failure
"
"
WMFDecoderModule
:
:
CreateAudioDecoder
failed
for
manager
with
"
"
description
%
s
"
manager
-
>
GetDescriptionName
(
)
.
get
(
)
)
;
return
nullptr
;
}
WmfDeocderModuleMarkerAndLog
(
"
WMFADecoderCreation
Success
"
"
WMFDecoderModule
:
:
CreateAudioDecoder
success
for
manager
with
"
"
description
%
s
"
manager
-
>
GetDescriptionName
(
)
.
get
(
)
)
;
RefPtr
<
MediaDataDecoder
>
decoder
=
new
WMFMediaDataDecoder
(
manager
.
release
(
)
)
;
return
decoder
.
forget
(
)
;
}
template
<
const
GUID
&
aGuid
>
static
bool
CanCreateWMFDecoder
(
)
{
static
StaticMutex
sMutex
;
StaticMutexAutoLock
lock
(
sMutex
)
;
static
Maybe
<
bool
>
result
;
if
(
result
.
isNothing
(
)
)
{
result
.
emplace
(
CanCreateMFTDecoder
(
aGuid
)
)
;
}
return
result
.
value
(
)
;
}
bool
WMFDecoderModule
:
:
HasH264
(
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
PDMFactory
:
:
Supported
(
)
.
contains
(
PDMFactory
:
:
MediaCodecs
:
:
H264
)
;
}
return
CanCreateWMFDecoder
<
CLSID_CMSH264DecoderMFT
>
(
)
;
}
bool
WMFDecoderModule
:
:
HasVP8
(
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
PDMFactory
:
:
Supported
(
)
.
contains
(
PDMFactory
:
:
MediaCodecs
:
:
VP8
)
;
}
return
sUsableVPXMFT
&
&
CanCreateWMFDecoder
<
CLSID_WebmMfVpxDec
>
(
)
;
}
bool
WMFDecoderModule
:
:
HasVP9
(
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
PDMFactory
:
:
Supported
(
)
.
contains
(
PDMFactory
:
:
MediaCodecs
:
:
VP9
)
;
}
return
sUsableVPXMFT
&
&
CanCreateWMFDecoder
<
CLSID_WebmMfVpxDec
>
(
)
;
}
bool
WMFDecoderModule
:
:
HasAAC
(
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
PDMFactory
:
:
Supported
(
)
.
contains
(
PDMFactory
:
:
MediaCodecs
:
:
AAC
)
;
}
return
CanCreateWMFDecoder
<
CLSID_CMSAACDecMFT
>
(
)
;
}
bool
WMFDecoderModule
:
:
HasMP3
(
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
PDMFactory
:
:
Supported
(
)
.
contains
(
PDMFactory
:
:
MediaCodecs
:
:
MP3
)
;
}
return
CanCreateWMFDecoder
<
CLSID_CMP3DecMediaObject
>
(
)
;
}
bool
WMFDecoderModule
:
:
SupportsMimeType
(
const
nsACString
&
aMimeType
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
UniquePtr
<
TrackInfo
>
trackInfo
=
CreateTrackInfoWithMIMEType
(
aMimeType
)
;
if
(
!
trackInfo
)
{
return
false
;
}
return
Supports
(
SupportDecoderParams
(
*
trackInfo
)
aDiagnostics
)
;
}
bool
WMFDecoderModule
:
:
Supports
(
const
SupportDecoderParams
&
aParams
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
if
(
XRE_IsGPUProcess
(
)
&
&
!
IsRemoteAcceleratedCompositor
(
aParams
)
)
{
return
false
;
}
const
auto
&
trackInfo
=
aParams
.
mConfig
;
const
auto
*
videoInfo
=
trackInfo
.
GetAsVideoInfo
(
)
;
if
(
videoInfo
&
&
(
!
SupportsColorDepth
(
videoInfo
-
>
mColorDepth
aDiagnostics
)
|
|
videoInfo
-
>
HasAlpha
(
)
)
)
{
return
false
;
}
if
(
(
trackInfo
.
mMimeType
.
EqualsLiteral
(
"
audio
/
mp4a
-
latm
"
)
|
|
trackInfo
.
mMimeType
.
EqualsLiteral
(
"
audio
/
mp4
"
)
)
&
&
WMFDecoderModule
:
:
HasAAC
(
)
)
{
const
auto
audioInfo
=
trackInfo
.
GetAsAudioInfo
(
)
;
if
(
audioInfo
&
&
audioInfo
-
>
mRate
>
0
)
{
const
std
:
:
vector
<
uint32_t
>
frequencies
=
{
8000
11025
12000
16000
22050
24000
32000
44100
48000
}
;
return
std
:
:
find
(
frequencies
.
begin
(
)
frequencies
.
end
(
)
audioInfo
-
>
mRate
)
!
=
frequencies
.
end
(
)
;
}
return
true
;
}
if
(
MP4Decoder
:
:
IsH264
(
trackInfo
.
mMimeType
)
&
&
WMFDecoderModule
:
:
HasH264
(
)
)
{
return
true
;
}
if
(
trackInfo
.
mMimeType
.
EqualsLiteral
(
"
audio
/
mpeg
"
)
&
&
!
StaticPrefs
:
:
media_ffvpx_mp3_enabled
(
)
&
&
WMFDecoderModule
:
:
HasMP3
(
)
)
{
return
true
;
}
static
const
uint32_t
VP8_USABLE_BUILD
=
16287
;
if
(
VPXDecoder
:
:
IsVP8
(
trackInfo
.
mMimeType
)
&
&
IsWindowsBuildOrLater
(
VP8_USABLE_BUILD
)
&
&
WMFDecoderModule
:
:
HasVP8
(
)
)
{
return
true
;
}
if
(
VPXDecoder
:
:
IsVP9
(
trackInfo
.
mMimeType
)
&
&
WMFDecoderModule
:
:
HasVP9
(
)
)
{
return
true
;
}
return
false
;
}
}
#
undef
WFM_DECODER_MODULE_STATUS_MARKER
#
undef
LOG
