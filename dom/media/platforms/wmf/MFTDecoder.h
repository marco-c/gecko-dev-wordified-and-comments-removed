#
if
!
defined
(
MFTDecoder_h_
)
#
define
MFTDecoder_h_
#
include
"
WMF
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsIThread
.
h
"
namespace
mozilla
{
class
MFTDecoder
final
{
~
MFTDecoder
(
)
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MFTDecoder
)
MFTDecoder
(
)
;
HRESULT
Create
(
const
GUID
&
aMFTClsID
)
;
HRESULT
SetMediaTypes
(
IMFMediaType
*
aInputType
IMFMediaType
*
aOutputType
std
:
:
function
<
HRESULT
(
IMFMediaType
*
)
>
&
&
aCallback
=
[
]
(
IMFMediaType
*
aOutput
)
{
return
S_OK
;
}
)
;
already_AddRefed
<
IMFAttributes
>
GetAttributes
(
)
;
HRESULT
GetOutputMediaType
(
RefPtr
<
IMFMediaType
>
&
aMediaType
)
;
const
GUID
&
GetOutputMediaSubType
(
)
const
{
return
mOutputSubType
;
}
HRESULT
Input
(
const
uint8_t
*
aData
uint32_t
aDataSize
int64_t
aTimestampUsecs
)
;
HRESULT
Input
(
IMFSample
*
aSample
)
;
HRESULT
CreateInputSample
(
const
uint8_t
*
aData
uint32_t
aDataSize
int64_t
aTimestampUsecs
RefPtr
<
IMFSample
>
*
aOutSample
)
;
HRESULT
Output
(
RefPtr
<
IMFSample
>
*
aOutput
)
;
HRESULT
Flush
(
)
;
HRESULT
SendMFTMessage
(
MFT_MESSAGE_TYPE
aMsg
ULONG_PTR
aData
)
;
HRESULT
FindDecoderOutputTypeWithSubtype
(
const
GUID
&
aSubType
)
;
HRESULT
FindDecoderOutputType
(
)
;
private
:
HRESULT
SetDecoderOutputType
(
const
GUID
&
aSubType
IMFMediaType
*
aTypeToUse
std
:
:
function
<
HRESULT
(
IMFMediaType
*
)
>
&
&
aCallback
)
;
HRESULT
CreateOutputSample
(
RefPtr
<
IMFSample
>
*
aOutSample
)
;
MFT_INPUT_STREAM_INFO
mInputStreamInfo
;
MFT_OUTPUT_STREAM_INFO
mOutputStreamInfo
;
RefPtr
<
IMFTransform
>
mDecoder
;
RefPtr
<
IMFMediaType
>
mOutputType
;
GUID
mOutputSubType
;
bool
mMFTProvidesOutputSamples
=
false
;
bool
mDiscontinuity
=
true
;
}
;
}
#
endif
