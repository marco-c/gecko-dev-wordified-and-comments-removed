#
if
!
defined
(
WMFVideoMFTManager_h_
)
#
define
WMFVideoMFTManager_h_
#
include
"
MFTDecoder
.
h
"
#
include
"
MediaResult
.
h
"
#
include
"
PerformanceRecorder
.
h
"
#
include
"
WMF
.
h
"
#
include
"
WMFDecoderModule
.
h
"
#
include
"
WMFMediaDataDecoder
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
namespace
mozilla
{
class
DXVA2Manager
;
class
WMFVideoMFTManager
:
public
MFTManager
{
public
:
WMFVideoMFTManager
(
const
VideoInfo
&
aConfig
layers
:
:
KnowsCompositor
*
aKnowsCompositor
layers
:
:
ImageContainer
*
aImageContainer
float
aFramerate
const
CreateDecoderParams
:
:
OptionSet
&
aOptions
bool
aDXVAEnabled
Maybe
<
TrackingId
>
aTrackingId
)
;
~
WMFVideoMFTManager
(
)
;
MediaResult
Init
(
)
;
HRESULT
Input
(
MediaRawData
*
aSample
)
override
;
HRESULT
Output
(
int64_t
aStreamOffset
RefPtr
<
MediaData
>
&
aOutput
)
override
;
void
Flush
(
)
override
;
void
Shutdown
(
)
override
;
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
override
;
TrackInfo
:
:
TrackType
GetType
(
)
override
{
return
TrackInfo
:
:
kVideoTrack
;
}
nsCString
GetDescriptionName
(
)
const
override
;
nsCString
GetCodecName
(
)
const
override
;
MediaDataDecoder
:
:
ConversionRequired
NeedsConversion
(
)
const
override
{
return
mStreamType
=
=
WMFStreamType
:
:
H264
|
|
mStreamType
=
=
WMFStreamType
:
:
HEVC
?
MediaDataDecoder
:
:
ConversionRequired
:
:
kNeedAnnexB
:
MediaDataDecoder
:
:
ConversionRequired
:
:
kNeedNone
;
}
bool
UseZeroCopyVideoFrame
(
)
const
override
;
private
:
MediaResult
ValidateVideoInfo
(
)
;
bool
InitializeDXVA
(
)
;
MediaResult
InitInternal
(
)
;
HRESULT
CreateBasicVideoFrame
(
IMFSample
*
aSample
int64_t
aStreamOffset
VideoData
*
*
aOutVideoData
)
;
HRESULT
CreateD3DVideoFrame
(
IMFSample
*
aSample
int64_t
aStreamOffset
VideoData
*
*
aOutVideoData
)
;
HRESULT
SetDecoderMediaTypes
(
)
;
bool
CanUseDXVA
(
IMFMediaType
*
aInputType
IMFMediaType
*
aOutputType
)
;
media
:
:
TimeUnit
GetSampleDurationOrLastKnownDuration
(
IMFSample
*
aSample
)
const
;
const
VideoInfo
mVideoInfo
;
const
gfx
:
:
IntSize
mImageSize
;
const
WMFStreamType
mStreamType
;
gfx
:
:
IntSize
mSoftwareImageSize
;
gfx
:
:
IntSize
mSoftwarePictureSize
;
uint32_t
mVideoStride
;
Maybe
<
gfx
:
:
YUVColorSpace
>
mColorSpace
;
gfx
:
:
ColorRange
mColorRange
;
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
RefPtr
<
layers
:
:
KnowsCompositor
>
mKnowsCompositor
;
UniquePtr
<
DXVA2Manager
>
mDXVA2Manager
;
media
:
:
TimeUnit
mLastDuration
;
bool
mDXVAEnabled
;
bool
mUseHwAccel
;
bool
mZeroCopyNV12Texture
;
nsCString
mDXVAFailureReason
;
const
GUID
&
GetMediaSubtypeGUID
(
)
;
uint32_t
mNullOutputCount
=
0
;
bool
mGotValidOutputAfterNullOutput
=
false
;
bool
mGotExcessiveNullOutput
=
false
;
bool
mIsValid
=
true
;
bool
mIMFUsable
=
false
;
const
float
mFramerate
;
const
bool
mLowLatency
;
const
bool
mKeepOriginalPts
;
PerformanceRecorderMulti
<
DecodeStage
>
mPerformanceRecorder
;
const
Maybe
<
TrackingId
>
mTrackingId
;
nsTArray
<
int64_t
>
mPTSQueue
;
}
;
}
#
endif
