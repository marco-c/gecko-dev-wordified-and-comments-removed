#
if
!
defined
(
WMFVideoMFTManager_h_
)
#
define
WMFVideoMFTManager_h_
#
include
"
WMF
.
h
"
#
include
"
MFTDecoder
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
WMFMediaDataDecoder
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
namespace
mozilla
{
class
DXVA2Manager
;
class
WMFVideoMFTManager
:
public
MFTManager
{
public
:
WMFVideoMFTManager
(
const
VideoInfo
&
aConfig
mozilla
:
:
layers
:
:
LayersBackend
aLayersBackend
mozilla
:
:
layers
:
:
ImageContainer
*
aImageContainer
bool
aDXVAEnabled
)
;
~
WMFVideoMFTManager
(
)
;
bool
Init
(
)
;
HRESULT
Input
(
MediaRawData
*
aSample
)
override
;
HRESULT
Output
(
int64_t
aStreamOffset
RefPtr
<
MediaData
>
&
aOutput
)
override
;
void
Shutdown
(
)
override
;
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
override
;
TrackInfo
:
:
TrackType
GetType
(
)
override
{
return
TrackInfo
:
:
kVideoTrack
;
}
void
ConfigurationChanged
(
const
TrackInfo
&
aConfig
)
override
;
const
char
*
GetDescriptionName
(
)
const
override
;
private
:
bool
InitializeDXVA
(
bool
aForceD3D9
)
;
bool
InitInternal
(
bool
aForceD3D9
)
;
HRESULT
ConfigureVideoFrameGeometry
(
)
;
HRESULT
CreateBasicVideoFrame
(
IMFSample
*
aSample
int64_t
aStreamOffset
VideoData
*
*
aOutVideoData
)
;
HRESULT
CreateD3DVideoFrame
(
IMFSample
*
aSample
int64_t
aStreamOffset
VideoData
*
*
aOutVideoData
)
;
HRESULT
SetDecoderMediaTypes
(
)
;
bool
CanUseDXVA
(
IMFMediaType
*
aType
)
;
VideoInfo
mVideoInfo
;
uint32_t
mVideoStride
;
nsIntSize
mImageSize
;
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
nsAutoPtr
<
DXVA2Manager
>
mDXVA2Manager
;
RefPtr
<
IMFSample
>
mLastInput
;
float
mLastDuration
;
bool
mDXVAEnabled
;
const
layers
:
:
LayersBackend
mLayersBackend
;
bool
mUseHwAccel
;
nsCString
mDXVAFailureReason
;
enum
StreamType
{
Unknown
H264
VP8
VP9
}
;
StreamType
mStreamType
;
const
GUID
&
GetMFTGUID
(
)
;
const
GUID
&
GetMediaSubtypeGUID
(
)
;
uint32_t
mNullOutputCount
;
bool
mGotValidOutputAfterNullOutput
;
bool
mGotExcessiveNullOutput
;
}
;
}
#
endif
