#
ifndef
WMFMediaDataEncoder_h_
#
define
WMFMediaDataEncoder_h_
#
include
"
MFTEncoder
.
h
"
#
include
"
PlatformEncoderModule
.
h
"
#
include
"
WMFDataEncoderUtils
.
h
"
#
include
"
WMFUtils
.
h
"
#
include
<
comdef
.
h
>
#
include
"
mozilla
/
WindowsProcessMitigations
.
h
"
namespace
mozilla
{
class
WMFMediaDataEncoder
final
:
public
MediaDataEncoder
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
WMFMediaDataEncoder
final
)
;
WMFMediaDataEncoder
(
const
EncoderConfig
&
aConfig
const
RefPtr
<
TaskQueue
>
&
aTaskQueue
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
RefPtr
<
EncodePromise
>
Encode
(
const
MediaData
*
aSample
)
override
;
RefPtr
<
EncodePromise
>
Drain
(
)
override
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
RefPtr
<
GenericPromise
>
SetBitrate
(
uint32_t
aBitsPerSec
)
override
;
RefPtr
<
ReconfigurationPromise
>
Reconfigure
(
const
RefPtr
<
const
EncoderConfigurationChangeList
>
&
aConfigurationChanges
)
override
;
nsCString
GetDescriptionName
(
)
const
override
;
private
:
~
WMFMediaDataEncoder
(
)
=
default
;
class
LockBuffer
final
{
public
:
explicit
LockBuffer
(
RefPtr
<
IMFMediaBuffer
>
&
aBuffer
)
:
mBuffer
(
aBuffer
)
{
mResult
=
mBuffer
-
>
Lock
(
&
mBytes
&
mCapacity
&
mLength
)
;
}
~
LockBuffer
(
)
{
if
(
SUCCEEDED
(
mResult
)
)
{
mBuffer
-
>
Unlock
(
)
;
}
}
BYTE
*
Data
(
)
{
return
mBytes
;
}
DWORD
Capacity
(
)
{
return
mCapacity
;
}
DWORD
Length
(
)
{
return
mLength
;
}
HRESULT
Result
(
)
{
return
mResult
;
}
private
:
RefPtr
<
IMFMediaBuffer
>
mBuffer
;
BYTE
*
mBytes
{
}
;
DWORD
mCapacity
{
}
;
DWORD
mLength
{
}
;
HRESULT
mResult
{
}
;
}
;
RefPtr
<
InitPromise
>
ProcessInit
(
)
;
HRESULT
InitMFTEncoder
(
RefPtr
<
MFTEncoder
>
&
aEncoder
)
;
void
InitializeConfigData
(
)
;
void
SetConfigData
(
const
nsTArray
<
UINT8
>
&
aHeader
)
;
RefPtr
<
EncodePromise
>
ProcessEncode
(
RefPtr
<
const
VideoData
>
&
&
aSample
)
;
RefPtr
<
EncodePromise
>
ProcessDrain
(
)
;
already_AddRefed
<
IMFSample
>
ConvertToNV12InputSample
(
RefPtr
<
const
VideoData
>
&
&
aData
)
;
RefPtr
<
EncodePromise
>
ProcessOutputSamples
(
nsTArray
<
MFTEncoder
:
:
OutputSample
>
&
&
aSamples
)
;
already_AddRefed
<
MediaRawData
>
OutputSampleToMediaData
(
MFTEncoder
:
:
OutputSample
&
aSample
)
;
bool
WriteFrameData
(
RefPtr
<
MediaRawData
>
&
aDest
LockBuffer
&
aSrc
bool
aIsKeyframe
)
;
bool
IsAnnexB
(
)
const
;
void
AssertOnTaskQueue
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
}
EncoderConfig
mConfig
;
const
RefPtr
<
TaskQueue
>
mTaskQueue
;
const
bool
mHardwareNotAllowed
;
RefPtr
<
MFTEncoder
>
mEncoder
;
RefPtr
<
MediaByteBuffer
>
mConfigData
;
}
;
}
#
endif
