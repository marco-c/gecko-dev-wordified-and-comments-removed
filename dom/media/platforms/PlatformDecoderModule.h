#
if
!
defined
(
PlatformDecoderModule_h_
)
#
define
PlatformDecoderModule_h_
#
include
"
DecoderDoctorLogger
.
h
"
#
include
"
GMPCrashHelper
.
h
"
#
include
"
MediaCodecsSupport
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
MediaResult
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
EnumTypeTraits
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
layers
/
KnowsCompositor
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
ipc
/
UtilityAudioDecoder
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
PerformanceRecorder
.
h
"
namespace
mozilla
{
class
TrackInfo
;
class
AudioInfo
;
class
VideoInfo
;
class
MediaRawData
;
class
DecoderDoctorDiagnostics
;
namespace
layers
{
class
ImageContainer
;
}
class
MediaDataDecoder
;
class
RemoteDecoderModule
;
class
CDMProxy
;
static
LazyLogModule
sPDMLog
(
"
PlatformDecoderModule
"
)
;
namespace
media
{
MOZ_DEFINE_ENUM_CLASS_WITH_TOSTRING
(
Option
(
Default
LowLatency
HardwareDecoderNotAllowed
FullH264Parsing
ErrorIfNoInitializationData
DefaultPlaybackDeviceMono
KeepOriginalPts
SENTINEL
)
)
;
using
OptionSet
=
EnumSet
<
Option
>
;
static
nsCString
OptionSetToString
(
const
OptionSet
&
aOptions
)
{
nsCString
str
;
for
(
const
auto
option
:
aOptions
)
{
if
(
!
str
.
IsEmpty
(
)
)
{
str
.
AppendLiteral
(
"
|
"
)
;
}
str
.
AppendPrintf
(
"
%
s
"
EnumValueToString
(
option
)
)
;
}
if
(
str
.
IsEmpty
(
)
)
{
str
.
AppendLiteral
(
"
Empty
"
)
;
}
return
str
;
}
struct
UseNullDecoder
{
UseNullDecoder
(
)
=
default
;
explicit
UseNullDecoder
(
bool
aUseNullDecoder
)
:
mUse
(
aUseNullDecoder
)
{
}
bool
mUse
=
false
;
}
;
struct
NoWrapper
{
NoWrapper
(
)
=
default
;
explicit
NoWrapper
(
bool
aDontUseWrapper
)
:
mDontUseWrapper
(
aDontUseWrapper
)
{
}
bool
mDontUseWrapper
=
false
;
}
;
struct
VideoFrameRate
{
VideoFrameRate
(
)
=
default
;
explicit
VideoFrameRate
(
float
aFramerate
)
:
mValue
(
aFramerate
)
{
}
float
mValue
=
0
.
0f
;
}
;
}
struct
CreateDecoderParams
;
struct
CreateDecoderParamsForAsync
{
using
Option
=
media
:
:
Option
;
using
OptionSet
=
media
:
:
OptionSet
;
explicit
CreateDecoderParamsForAsync
(
const
CreateDecoderParams
&
aParams
)
;
CreateDecoderParamsForAsync
(
CreateDecoderParamsForAsync
&
&
aParams
)
;
const
VideoInfo
&
VideoConfig
(
)
const
{
MOZ_ASSERT
(
mConfig
-
>
IsVideo
(
)
)
;
return
*
mConfig
-
>
GetAsVideoInfo
(
)
;
}
const
AudioInfo
&
AudioConfig
(
)
const
{
MOZ_ASSERT
(
mConfig
-
>
IsAudio
(
)
)
;
return
*
mConfig
-
>
GetAsAudioInfo
(
)
;
}
UniquePtr
<
TrackInfo
>
mConfig
;
const
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
const
RefPtr
<
layers
:
:
KnowsCompositor
>
mKnowsCompositor
;
const
RefPtr
<
GMPCrashHelper
>
mCrashHelper
;
const
media
:
:
UseNullDecoder
mUseNullDecoder
;
const
media
:
:
NoWrapper
mNoWrapper
;
const
TrackInfo
:
:
TrackType
mType
=
TrackInfo
:
:
kUndefinedTrack
;
std
:
:
function
<
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
*
(
)
>
mOnWaitingForKeyEvent
;
const
OptionSet
mOptions
=
OptionSet
(
Option
:
:
Default
)
;
const
media
:
:
VideoFrameRate
mRate
;
const
Maybe
<
uint64_t
>
mMediaEngineId
;
const
Maybe
<
TrackingId
>
mTrackingId
;
}
;
struct
MOZ_STACK_CLASS
CreateDecoderParams
final
{
using
Option
=
media
:
:
Option
;
using
OptionSet
=
media
:
:
OptionSet
;
using
UseNullDecoder
=
media
:
:
UseNullDecoder
;
using
NoWrapper
=
media
:
:
NoWrapper
;
using
VideoFrameRate
=
media
:
:
VideoFrameRate
;
enum
class
EncryptedCustomIdent
:
bool
{
False
True
}
;
explicit
CreateDecoderParams
(
const
TrackInfo
&
aConfig
)
:
mConfig
(
aConfig
)
{
}
CreateDecoderParams
(
const
CreateDecoderParams
&
aParams
)
=
default
;
MOZ_IMPLICIT
CreateDecoderParams
(
const
CreateDecoderParamsForAsync
&
aParams
)
:
mConfig
(
*
aParams
.
mConfig
)
mImageContainer
(
aParams
.
mImageContainer
)
mKnowsCompositor
(
aParams
.
mKnowsCompositor
)
mCrashHelper
(
aParams
.
mCrashHelper
)
mUseNullDecoder
(
aParams
.
mUseNullDecoder
)
mNoWrapper
(
aParams
.
mNoWrapper
)
mType
(
aParams
.
mType
)
mOnWaitingForKeyEvent
(
aParams
.
mOnWaitingForKeyEvent
)
mOptions
(
aParams
.
mOptions
)
mRate
(
aParams
.
mRate
)
mMediaEngineId
(
aParams
.
mMediaEngineId
)
mTrackingId
(
aParams
.
mTrackingId
)
{
}
template
<
typename
T1
typename
.
.
.
Ts
>
CreateDecoderParams
(
const
TrackInfo
&
aConfig
T1
&
&
a1
Ts
&
&
.
.
.
args
)
:
mConfig
(
aConfig
)
{
Set
(
std
:
:
forward
<
T1
>
(
a1
)
std
:
:
forward
<
Ts
>
(
args
)
.
.
.
)
;
}
template
<
typename
T1
typename
.
.
.
Ts
>
CreateDecoderParams
(
const
CreateDecoderParams
&
aParams
T1
&
&
a1
Ts
&
&
.
.
.
args
)
:
CreateDecoderParams
(
aParams
)
{
Set
(
std
:
:
forward
<
T1
>
(
a1
)
std
:
:
forward
<
Ts
>
(
args
)
.
.
.
)
;
}
const
VideoInfo
&
VideoConfig
(
)
const
{
MOZ_ASSERT
(
mConfig
.
IsVideo
(
)
)
;
return
*
mConfig
.
GetAsVideoInfo
(
)
;
}
const
AudioInfo
&
AudioConfig
(
)
const
{
MOZ_ASSERT
(
mConfig
.
IsAudio
(
)
)
;
return
*
mConfig
.
GetAsAudioInfo
(
)
;
}
layers
:
:
LayersBackend
GetLayersBackend
(
)
const
{
if
(
mKnowsCompositor
)
{
return
mKnowsCompositor
-
>
GetCompositorBackendType
(
)
;
}
return
layers
:
:
LayersBackend
:
:
LAYERS_NONE
;
}
nsCString
ToString
(
)
const
{
nsPrintfCString
str
(
"
CreateDecoderParams
%
p
:
"
this
)
;
str
.
AppendPrintf
(
"
mConfig
=
%
s
"
mConfig
.
ToString
(
)
.
get
(
)
)
;
str
.
AppendPrintf
(
"
mImageContainer
=
%
p
"
mImageContainer
)
;
str
.
AppendPrintf
(
"
mError
=
%
s
"
mError
?
mError
-
>
Description
(
)
.
get
(
)
:
"
null
"
)
;
str
.
AppendPrintf
(
"
mKnowsCompositor
=
%
p
"
mKnowsCompositor
)
;
str
.
AppendPrintf
(
"
mCrashHelper
=
%
p
"
mCrashHelper
)
;
str
.
AppendPrintf
(
"
mUseNullDecoder
=
%
s
"
mUseNullDecoder
.
mUse
?
"
yes
"
:
"
no
"
)
;
str
.
AppendPrintf
(
"
mNoWrapper
=
%
s
"
mNoWrapper
.
mDontUseWrapper
?
"
no
wrapper
"
:
"
has
wrapper
"
)
;
str
.
AppendPrintf
(
"
mType
=
%
d
"
static_cast
<
int32_t
>
(
mType
)
)
;
str
.
AppendPrintf
(
"
mOnWaitingForKeyEvent
=
%
s
"
mOnWaitingForKeyEvent
?
"
yes
"
:
"
no
"
)
;
str
.
AppendPrintf
(
"
mOptions
=
%
s
"
OptionSetToString
(
mOptions
)
.
get
(
)
)
;
str
.
AppendPrintf
(
"
mRate
=
%
f
"
mRate
.
mValue
)
;
str
.
AppendPrintf
(
"
mMediaEngineId
=
%
s
"
mMediaEngineId
?
std
:
:
to_string
(
*
mMediaEngineId
)
.
c_str
(
)
:
"
None
"
)
;
str
.
AppendPrintf
(
"
mTrackingId
=
%
s
"
mTrackingId
?
mTrackingId
-
>
ToString
(
)
.
get
(
)
:
"
None
"
)
;
str
.
AppendPrintf
(
"
mEncryptedCustomIdent
=
%
s
"
mEncryptedCustomIdent
=
=
EncryptedCustomIdent
:
:
True
?
"
true
"
:
"
false
"
)
;
return
std
:
:
move
(
str
)
;
}
const
TrackInfo
&
mConfig
;
layers
:
:
ImageContainer
*
mImageContainer
=
nullptr
;
MediaResult
*
mError
=
nullptr
;
layers
:
:
KnowsCompositor
*
mKnowsCompositor
=
nullptr
;
GMPCrashHelper
*
mCrashHelper
=
nullptr
;
media
:
:
UseNullDecoder
mUseNullDecoder
;
media
:
:
NoWrapper
mNoWrapper
;
TrackInfo
:
:
TrackType
mType
=
TrackInfo
:
:
kUndefinedTrack
;
std
:
:
function
<
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
*
(
)
>
mOnWaitingForKeyEvent
;
OptionSet
mOptions
=
OptionSet
(
Option
:
:
Default
)
;
media
:
:
VideoFrameRate
mRate
;
Maybe
<
uint64_t
>
mMediaEngineId
;
Maybe
<
TrackingId
>
mTrackingId
;
EncryptedCustomIdent
mEncryptedCustomIdent
;
private
:
void
Set
(
layers
:
:
ImageContainer
*
aImageContainer
)
{
mImageContainer
=
aImageContainer
;
}
void
Set
(
MediaResult
*
aError
)
{
mError
=
aError
;
}
void
Set
(
GMPCrashHelper
*
aCrashHelper
)
{
mCrashHelper
=
aCrashHelper
;
}
void
Set
(
UseNullDecoder
aUseNullDecoder
)
{
mUseNullDecoder
=
aUseNullDecoder
;
}
void
Set
(
NoWrapper
aNoWrapper
)
{
mNoWrapper
=
aNoWrapper
;
}
void
Set
(
const
OptionSet
&
aOptions
)
{
mOptions
=
aOptions
;
}
void
Set
(
VideoFrameRate
aRate
)
{
mRate
=
aRate
;
}
void
Set
(
layers
:
:
KnowsCompositor
*
aKnowsCompositor
)
{
if
(
aKnowsCompositor
)
{
mKnowsCompositor
=
aKnowsCompositor
;
MOZ_ASSERT
(
aKnowsCompositor
-
>
IsThreadSafe
(
)
)
;
}
}
void
Set
(
TrackInfo
:
:
TrackType
aType
)
{
mType
=
aType
;
}
void
Set
(
std
:
:
function
<
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
*
(
)
>
&
&
aOnWaitingForKey
)
{
mOnWaitingForKeyEvent
=
std
:
:
move
(
aOnWaitingForKey
)
;
}
void
Set
(
const
std
:
:
function
<
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
*
(
)
>
&
aOnWaitingForKey
)
{
mOnWaitingForKeyEvent
=
aOnWaitingForKey
;
}
void
Set
(
const
Maybe
<
uint64_t
>
&
aMediaEngineId
)
{
mMediaEngineId
=
aMediaEngineId
;
}
void
Set
(
const
Maybe
<
TrackingId
>
&
aTrackingId
)
{
mTrackingId
=
aTrackingId
;
}
void
Set
(
const
EncryptedCustomIdent
aEncryptedCustomIdent
)
{
mEncryptedCustomIdent
=
aEncryptedCustomIdent
;
}
void
Set
(
const
CreateDecoderParams
&
aParams
)
{
mImageContainer
=
aParams
.
mImageContainer
;
mError
=
aParams
.
mError
;
mKnowsCompositor
=
aParams
.
mKnowsCompositor
;
mCrashHelper
=
aParams
.
mCrashHelper
;
mUseNullDecoder
=
aParams
.
mUseNullDecoder
;
mNoWrapper
=
aParams
.
mNoWrapper
;
mType
=
aParams
.
mType
;
mOnWaitingForKeyEvent
=
aParams
.
mOnWaitingForKeyEvent
;
mOptions
=
aParams
.
mOptions
;
mRate
=
aParams
.
mRate
;
mMediaEngineId
=
aParams
.
mMediaEngineId
;
mTrackingId
=
aParams
.
mTrackingId
;
}
template
<
typename
T1
typename
T2
typename
.
.
.
Ts
>
void
Set
(
T1
&
&
a1
T2
&
&
a2
Ts
&
&
.
.
.
args
)
{
Set
(
std
:
:
forward
<
T1
>
(
a1
)
)
;
Set
(
std
:
:
forward
<
T2
>
(
a2
)
std
:
:
forward
<
Ts
>
(
args
)
.
.
.
)
;
}
}
;
struct
MOZ_STACK_CLASS
SupportDecoderParams
final
{
using
Option
=
media
:
:
Option
;
using
OptionSet
=
media
:
:
OptionSet
;
using
UseNullDecoder
=
media
:
:
UseNullDecoder
;
using
NoWrapper
=
media
:
:
NoWrapper
;
using
VideoFrameRate
=
media
:
:
VideoFrameRate
;
explicit
SupportDecoderParams
(
const
TrackInfo
&
aConfig
)
:
mConfig
(
aConfig
)
{
}
explicit
SupportDecoderParams
(
const
CreateDecoderParams
&
aParams
)
:
mConfig
(
aParams
.
mConfig
)
mError
(
aParams
.
mError
)
mKnowsCompositor
(
aParams
.
mKnowsCompositor
)
mUseNullDecoder
(
aParams
.
mUseNullDecoder
)
mNoWrapper
(
aParams
.
mNoWrapper
)
mOptions
(
aParams
.
mOptions
)
mRate
(
aParams
.
mRate
)
mMediaEngineId
(
aParams
.
mMediaEngineId
)
{
}
template
<
typename
T1
typename
.
.
.
Ts
>
SupportDecoderParams
(
const
TrackInfo
&
aConfig
T1
&
&
a1
Ts
&
&
.
.
.
args
)
:
mConfig
(
aConfig
)
{
Set
(
std
:
:
forward
<
T1
>
(
a1
)
std
:
:
forward
<
Ts
>
(
args
)
.
.
.
)
;
}
const
nsCString
&
MimeType
(
)
const
{
return
mConfig
.
mMimeType
;
}
const
TrackInfo
&
mConfig
;
DecoderDoctorDiagnostics
*
mDiagnostics
=
nullptr
;
MediaResult
*
mError
=
nullptr
;
RefPtr
<
layers
:
:
KnowsCompositor
>
mKnowsCompositor
;
UseNullDecoder
mUseNullDecoder
;
NoWrapper
mNoWrapper
;
OptionSet
mOptions
=
OptionSet
(
Option
:
:
Default
)
;
VideoFrameRate
mRate
;
Maybe
<
uint64_t
>
mMediaEngineId
;
private
:
void
Set
(
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
mDiagnostics
=
aDiagnostics
;
}
void
Set
(
MediaResult
*
aError
)
{
mError
=
aError
;
}
void
Set
(
media
:
:
UseNullDecoder
aUseNullDecoder
)
{
mUseNullDecoder
=
aUseNullDecoder
;
}
void
Set
(
media
:
:
NoWrapper
aNoWrapper
)
{
mNoWrapper
=
aNoWrapper
;
}
void
Set
(
const
media
:
:
OptionSet
&
aOptions
)
{
mOptions
=
aOptions
;
}
void
Set
(
media
:
:
VideoFrameRate
aRate
)
{
mRate
=
aRate
;
}
void
Set
(
layers
:
:
KnowsCompositor
*
aKnowsCompositor
)
{
if
(
aKnowsCompositor
)
{
mKnowsCompositor
=
aKnowsCompositor
;
MOZ_ASSERT
(
aKnowsCompositor
-
>
IsThreadSafe
(
)
)
;
}
}
void
Set
(
const
Maybe
<
uint64_t
>
&
aMediaEngineId
)
{
mMediaEngineId
=
aMediaEngineId
;
}
template
<
typename
T1
typename
T2
typename
.
.
.
Ts
>
void
Set
(
T1
&
&
a1
T2
&
&
a2
Ts
&
&
.
.
.
args
)
{
Set
(
std
:
:
forward
<
T1
>
(
a1
)
)
;
Set
(
std
:
:
forward
<
T2
>
(
a2
)
std
:
:
forward
<
Ts
>
(
args
)
.
.
.
)
;
}
}
;
template
<
>
struct
MaxEnumValue
<
:
:
mozilla
:
:
CreateDecoderParams
:
:
Option
>
{
static
constexpr
unsigned
int
value
=
static_cast
<
unsigned
int
>
(
CreateDecoderParams
:
:
Option
:
:
SENTINEL
)
;
}
;
class
PlatformDecoderModule
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
PlatformDecoderModule
)
virtual
nsresult
Startup
(
)
{
return
NS_OK
;
}
virtual
media
:
:
DecodeSupportSet
SupportsMimeType
(
const
nsACString
&
aMimeType
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
=
0
;
virtual
media
:
:
DecodeSupportSet
Supports
(
const
SupportDecoderParams
&
aParams
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
const
TrackInfo
&
trackInfo
=
aParams
.
mConfig
;
const
media
:
:
DecodeSupportSet
support
=
SupportsMimeType
(
trackInfo
.
mMimeType
aDiagnostics
)
;
if
(
support
.
isEmpty
(
)
)
{
return
support
;
}
const
auto
*
videoInfo
=
trackInfo
.
GetAsVideoInfo
(
)
;
if
(
!
videoInfo
)
{
return
media
:
:
DecodeSupport
:
:
SoftwareDecode
;
}
if
(
!
SupportsColorDepth
(
videoInfo
-
>
mColorDepth
aDiagnostics
)
)
{
return
media
:
:
DecodeSupportSet
{
}
;
}
return
support
;
}
using
CreateDecoderPromise
=
MozPromise
<
RefPtr
<
MediaDataDecoder
>
MediaResult
true
>
;
protected
:
PlatformDecoderModule
(
)
=
default
;
virtual
~
PlatformDecoderModule
(
)
=
default
;
friend
class
MediaChangeMonitor
;
friend
class
PDMFactory
;
friend
class
EMEDecoderModule
;
friend
class
RemoteDecoderModule
;
virtual
bool
SupportsColorDepth
(
gfx
:
:
ColorDepth
aColorDepth
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
return
aColorDepth
=
=
gfx
:
:
ColorDepth
:
:
COLOR_8
;
}
virtual
already_AddRefed
<
MediaDataDecoder
>
CreateVideoDecoder
(
const
CreateDecoderParams
&
aParams
)
=
0
;
virtual
already_AddRefed
<
MediaDataDecoder
>
CreateAudioDecoder
(
const
CreateDecoderParams
&
aParams
)
=
0
;
virtual
RefPtr
<
CreateDecoderPromise
>
AsyncCreateDecoder
(
const
CreateDecoderParams
&
aParams
)
;
}
;
DDLoggedTypeDeclName
(
MediaDataDecoder
)
;
class
MediaDataDecoder
:
public
DecoderDoctorLifeLogger
<
MediaDataDecoder
>
{
protected
:
virtual
~
MediaDataDecoder
(
)
=
default
;
public
:
using
TrackType
=
TrackInfo
:
:
TrackType
;
using
DecodedData
=
nsTArray
<
RefPtr
<
MediaData
>
>
;
using
InitPromise
=
MozPromise
<
TrackType
MediaResult
true
>
;
using
DecodePromise
=
MozPromise
<
DecodedData
MediaResult
true
>
;
using
FlushPromise
=
MozPromise
<
bool
MediaResult
true
>
;
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
virtual
RefPtr
<
InitPromise
>
Init
(
)
=
0
;
virtual
RefPtr
<
DecodePromise
>
Decode
(
MediaRawData
*
aSample
)
=
0
;
virtual
bool
CanDecodeBatch
(
)
const
{
return
false
;
}
virtual
RefPtr
<
DecodePromise
>
DecodeBatch
(
nsTArray
<
RefPtr
<
MediaRawData
>
>
&
&
aSamples
)
{
MOZ_CRASH
(
"
DecodeBatch
not
implemented
yet
"
)
;
return
MediaDataDecoder
:
:
DecodePromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_DECODE_ERR
__func__
)
;
}
virtual
RefPtr
<
DecodePromise
>
Drain
(
)
=
0
;
virtual
RefPtr
<
FlushPromise
>
Flush
(
)
=
0
;
virtual
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
=
0
;
virtual
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
{
return
false
;
}
virtual
nsCString
GetDescriptionName
(
)
const
=
0
;
virtual
nsCString
GetProcessName
(
)
const
{
nsCString
rv
=
nsCString
(
XRE_GetProcessTypeString
(
)
)
;
if
(
XRE_IsUtilityProcess
(
)
)
{
rv
+
=
"
+
"
_ns
+
mozilla
:
:
ipc
:
:
GetChildAudioActorName
(
)
;
}
return
rv
;
}
;
virtual
nsCString
GetCodecName
(
)
const
=
0
;
virtual
void
SetSeekThreshold
(
const
media
:
:
TimeUnit
&
aTime
)
{
}
virtual
bool
SupportDecoderRecycling
(
)
const
{
return
false
;
}
virtual
bool
ShouldDecoderAlwaysBeRecycled
(
)
const
{
return
false
;
}
enum
class
ConversionRequired
{
kNeedNone
=
0
kNeedAVCC
=
1
kNeedAnnexB
=
2
}
;
virtual
ConversionRequired
NeedsConversion
(
)
const
{
return
ConversionRequired
:
:
kNeedNone
;
}
}
;
}
#
endif
