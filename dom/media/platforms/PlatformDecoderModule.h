#
if
!
defined
(
PlatformDecoderModule_h_
)
#
define
PlatformDecoderModule_h_
#
include
"
FlushableTaskQueue
.
h
"
#
include
"
MediaDecoderReader
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
nsRefPtr
.
h
"
#
include
<
queue
>
namespace
mozilla
{
class
TrackInfo
;
class
AudioInfo
;
class
VideoInfo
;
class
MediaRawData
;
namespace
layers
{
class
ImageContainer
;
}
class
MediaDataDecoder
;
class
MediaDataDecoderCallback
;
class
FlushableTaskQueue
;
class
CDMProxy
;
class
PlatformDecoderModule
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
PlatformDecoderModule
)
virtual
nsresult
Startup
(
)
{
return
NS_OK
;
}
;
virtual
bool
SupportsMimeType
(
const
nsACString
&
aMimeType
)
=
0
;
enum
ConversionRequired
{
kNeedNone
kNeedAVCC
kNeedAnnexB
}
;
virtual
ConversionRequired
DecoderNeedsConversion
(
const
TrackInfo
&
aConfig
)
const
=
0
;
protected
:
PlatformDecoderModule
(
)
{
}
virtual
~
PlatformDecoderModule
(
)
{
}
friend
class
H264Converter
;
friend
class
PDMFactory
;
virtual
already_AddRefed
<
MediaDataDecoder
>
CreateVideoDecoder
(
const
VideoInfo
&
aConfig
layers
:
:
LayersBackend
aLayersBackend
layers
:
:
ImageContainer
*
aImageContainer
FlushableTaskQueue
*
aVideoTaskQueue
MediaDataDecoderCallback
*
aCallback
)
=
0
;
virtual
already_AddRefed
<
MediaDataDecoder
>
CreateAudioDecoder
(
const
AudioInfo
&
aConfig
FlushableTaskQueue
*
aAudioTaskQueue
MediaDataDecoderCallback
*
aCallback
)
=
0
;
}
;
class
MediaDataDecoderCallback
{
public
:
virtual
~
MediaDataDecoderCallback
(
)
{
}
virtual
void
Output
(
MediaData
*
aData
)
=
0
;
virtual
void
Error
(
)
=
0
;
virtual
void
InputExhausted
(
)
=
0
;
virtual
void
DrainComplete
(
)
=
0
;
virtual
void
ReleaseMediaResources
(
)
{
}
;
virtual
bool
OnReaderTaskQueue
(
)
=
0
;
}
;
class
MediaDataDecoder
{
protected
:
virtual
~
MediaDataDecoder
(
)
{
}
;
public
:
enum
DecoderFailureReason
{
INIT_ERROR
CANCELED
}
;
typedef
TrackInfo
:
:
TrackType
TrackType
;
typedef
MozPromise
<
TrackType
DecoderFailureReason
true
>
InitPromise
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDataDecoder
)
virtual
nsRefPtr
<
InitPromise
>
Init
(
)
=
0
;
virtual
nsresult
Input
(
MediaRawData
*
aSample
)
=
0
;
virtual
nsresult
Flush
(
)
=
0
;
virtual
nsresult
Drain
(
)
=
0
;
virtual
nsresult
Shutdown
(
)
=
0
;
virtual
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
{
return
false
;
}
virtual
nsresult
ConfigurationChanged
(
const
TrackInfo
&
aConfig
)
{
return
NS_OK
;
}
}
;
}
#
endif
