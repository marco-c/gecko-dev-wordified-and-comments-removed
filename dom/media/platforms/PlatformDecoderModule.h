#
if
!
defined
(
PlatformDecoderModule_h_
)
#
define
PlatformDecoderModule_h_
#
include
"
MediaDecoderReader
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
<
queue
>
namespace
mozilla
{
class
TrackInfo
;
class
AudioInfo
;
class
VideoInfo
;
class
MediaRawData
;
class
DecoderDoctorDiagnostics
;
namespace
layers
{
class
ImageContainer
;
}
class
MediaDataDecoder
;
class
MediaDataDecoderCallback
;
class
TaskQueue
;
class
CDMProxy
;
static
LazyLogModule
sPDMLog
(
"
PlatformDecoderModule
"
)
;
struct
CreateDecoderParams
{
explicit
CreateDecoderParams
(
const
TrackInfo
&
aConfig
)
:
mConfig
(
aConfig
)
{
}
template
<
typename
T1
typename
.
.
.
Ts
>
CreateDecoderParams
(
const
TrackInfo
&
aConfig
T1
a1
Ts
.
.
.
as
)
:
mConfig
(
aConfig
)
{
Set
(
a1
as
.
.
.
)
;
}
const
VideoInfo
&
VideoConfig
(
)
const
{
MOZ_ASSERT
(
mConfig
.
IsVideo
(
)
)
;
return
*
mConfig
.
GetAsVideoInfo
(
)
;
}
const
AudioInfo
&
AudioConfig
(
)
const
{
MOZ_ASSERT
(
mConfig
.
IsAudio
(
)
)
;
return
*
mConfig
.
GetAsAudioInfo
(
)
;
}
const
TrackInfo
&
mConfig
;
TaskQueue
*
mTaskQueue
=
nullptr
;
MediaDataDecoderCallback
*
mCallback
=
nullptr
;
DecoderDoctorDiagnostics
*
mDiagnostics
=
nullptr
;
layers
:
:
ImageContainer
*
mImageContainer
=
nullptr
;
layers
:
:
LayersBackend
mLayersBackend
=
layers
:
:
LayersBackend
:
:
LAYERS_NONE
;
private
:
void
Set
(
TaskQueue
*
aTaskQueue
)
{
mTaskQueue
=
aTaskQueue
;
}
void
Set
(
MediaDataDecoderCallback
*
aCallback
)
{
mCallback
=
aCallback
;
}
void
Set
(
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
mDiagnostics
=
aDiagnostics
;
}
void
Set
(
layers
:
:
ImageContainer
*
aImageContainer
)
{
mImageContainer
=
aImageContainer
;
}
void
Set
(
layers
:
:
LayersBackend
aLayersBackend
)
{
mLayersBackend
=
aLayersBackend
;
}
template
<
typename
T1
typename
T2
typename
.
.
.
Ts
>
void
Set
(
T1
a1
T2
a2
Ts
.
.
.
as
)
{
using
expander
=
int
[
]
;
(
void
)
expander
{
(
Set
(
a1
)
0
)
(
Set
(
a2
)
0
)
(
Set
(
as
)
0
)
.
.
.
}
;
}
}
;
class
PlatformDecoderModule
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
PlatformDecoderModule
)
virtual
nsresult
Startup
(
)
{
return
NS_OK
;
}
;
virtual
bool
SupportsMimeType
(
const
nsACString
&
aMimeType
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
=
0
;
enum
ConversionRequired
{
kNeedNone
kNeedAVCC
kNeedAnnexB
}
;
virtual
ConversionRequired
DecoderNeedsConversion
(
const
TrackInfo
&
aConfig
)
const
=
0
;
protected
:
PlatformDecoderModule
(
)
{
}
virtual
~
PlatformDecoderModule
(
)
{
}
friend
class
H264Converter
;
friend
class
PDMFactory
;
virtual
already_AddRefed
<
MediaDataDecoder
>
CreateVideoDecoder
(
const
CreateDecoderParams
&
aParams
)
=
0
;
virtual
already_AddRefed
<
MediaDataDecoder
>
CreateAudioDecoder
(
const
CreateDecoderParams
&
aParams
)
=
0
;
}
;
enum
MediaDataDecoderError
{
FATAL_ERROR
DECODE_ERROR
}
;
class
MediaDataDecoderCallback
{
public
:
virtual
~
MediaDataDecoderCallback
(
)
{
}
virtual
void
Output
(
MediaData
*
aData
)
=
0
;
virtual
void
Error
(
MediaDataDecoderError
aError
)
=
0
;
virtual
void
InputExhausted
(
)
=
0
;
virtual
void
DrainComplete
(
)
=
0
;
virtual
void
ReleaseMediaResources
(
)
{
}
;
virtual
bool
OnReaderTaskQueue
(
)
=
0
;
}
;
class
MediaDataDecoder
{
protected
:
virtual
~
MediaDataDecoder
(
)
{
}
;
public
:
enum
DecoderFailureReason
{
INIT_ERROR
CANCELED
}
;
typedef
TrackInfo
:
:
TrackType
TrackType
;
typedef
MozPromise
<
TrackType
DecoderFailureReason
true
>
InitPromise
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDataDecoder
)
virtual
RefPtr
<
InitPromise
>
Init
(
)
=
0
;
virtual
nsresult
Input
(
MediaRawData
*
aSample
)
=
0
;
virtual
nsresult
Flush
(
)
=
0
;
virtual
nsresult
Drain
(
)
=
0
;
virtual
nsresult
Shutdown
(
)
=
0
;
virtual
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
{
return
false
;
}
virtual
nsresult
ConfigurationChanged
(
const
TrackInfo
&
aConfig
)
{
return
NS_OK
;
}
virtual
const
char
*
GetDescriptionName
(
)
const
=
0
;
virtual
void
SetSeekThreshold
(
const
media
:
:
TimeUnit
&
aTime
)
{
}
}
;
}
#
endif
