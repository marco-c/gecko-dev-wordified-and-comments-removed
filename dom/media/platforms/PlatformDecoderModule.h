#
if
!
defined
(
PlatformDecoderModule_h_
)
#
define
PlatformDecoderModule_h_
#
include
"
MediaDecoderReader
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
GMPService
.
h
"
#
include
<
queue
>
#
include
"
MediaResult
.
h
"
namespace
mozilla
{
class
TrackInfo
;
class
AudioInfo
;
class
VideoInfo
;
class
MediaRawData
;
class
DecoderDoctorDiagnostics
;
namespace
layers
{
class
ImageContainer
;
}
class
MediaDataDecoder
;
class
MediaDataDecoderCallback
;
class
TaskQueue
;
class
CDMProxy
;
static
LazyLogModule
sPDMLog
(
"
PlatformDecoderModule
"
)
;
struct
CreateDecoderParams
{
explicit
CreateDecoderParams
(
const
TrackInfo
&
aConfig
)
:
mConfig
(
aConfig
)
{
}
template
<
typename
T1
typename
.
.
.
Ts
>
CreateDecoderParams
(
const
TrackInfo
&
aConfig
T1
&
&
a1
Ts
&
&
.
.
.
args
)
:
mConfig
(
aConfig
)
{
Set
(
mozilla
:
:
Forward
<
T1
>
(
a1
)
mozilla
:
:
Forward
<
Ts
>
(
args
)
.
.
.
)
;
}
const
VideoInfo
&
VideoConfig
(
)
const
{
MOZ_ASSERT
(
mConfig
.
IsVideo
(
)
)
;
return
*
mConfig
.
GetAsVideoInfo
(
)
;
}
const
AudioInfo
&
AudioConfig
(
)
const
{
MOZ_ASSERT
(
mConfig
.
IsAudio
(
)
)
;
return
*
mConfig
.
GetAsAudioInfo
(
)
;
}
const
TrackInfo
&
mConfig
;
TaskQueue
*
mTaskQueue
=
nullptr
;
MediaDataDecoderCallback
*
mCallback
=
nullptr
;
DecoderDoctorDiagnostics
*
mDiagnostics
=
nullptr
;
layers
:
:
ImageContainer
*
mImageContainer
=
nullptr
;
layers
:
:
LayersBackend
mLayersBackend
=
layers
:
:
LayersBackend
:
:
LAYERS_NONE
;
RefPtr
<
GMPCrashHelper
>
mCrashHelper
;
bool
mUseBlankDecoder
=
false
;
private
:
void
Set
(
TaskQueue
*
aTaskQueue
)
{
mTaskQueue
=
aTaskQueue
;
}
void
Set
(
MediaDataDecoderCallback
*
aCallback
)
{
mCallback
=
aCallback
;
}
void
Set
(
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
mDiagnostics
=
aDiagnostics
;
}
void
Set
(
layers
:
:
ImageContainer
*
aImageContainer
)
{
mImageContainer
=
aImageContainer
;
}
void
Set
(
layers
:
:
LayersBackend
aLayersBackend
)
{
mLayersBackend
=
aLayersBackend
;
}
void
Set
(
GMPCrashHelper
*
aCrashHelper
)
{
mCrashHelper
=
aCrashHelper
;
}
void
Set
(
bool
aUseBlankDecoder
)
{
mUseBlankDecoder
=
aUseBlankDecoder
;
}
template
<
typename
T1
typename
T2
typename
.
.
.
Ts
>
void
Set
(
T1
&
&
a1
T2
&
&
a2
Ts
&
&
.
.
.
args
)
{
Set
(
mozilla
:
:
Forward
<
T1
>
(
a1
)
)
;
Set
(
mozilla
:
:
Forward
<
T2
>
(
a2
)
mozilla
:
:
Forward
<
Ts
>
(
args
)
.
.
.
)
;
}
}
;
class
PlatformDecoderModule
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
PlatformDecoderModule
)
virtual
nsresult
Startup
(
)
{
return
NS_OK
;
}
;
virtual
bool
SupportsMimeType
(
const
nsACString
&
aMimeType
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
=
0
;
enum
class
ConversionRequired
:
uint8_t
{
kNeedNone
kNeedAVCC
kNeedAnnexB
}
;
virtual
ConversionRequired
DecoderNeedsConversion
(
const
TrackInfo
&
aConfig
)
const
=
0
;
protected
:
PlatformDecoderModule
(
)
{
}
virtual
~
PlatformDecoderModule
(
)
{
}
friend
class
H264Converter
;
friend
class
PDMFactory
;
virtual
already_AddRefed
<
MediaDataDecoder
>
CreateVideoDecoder
(
const
CreateDecoderParams
&
aParams
)
=
0
;
virtual
already_AddRefed
<
MediaDataDecoder
>
CreateAudioDecoder
(
const
CreateDecoderParams
&
aParams
)
=
0
;
}
;
class
MediaDataDecoderCallback
{
public
:
virtual
~
MediaDataDecoderCallback
(
)
{
}
virtual
void
Output
(
MediaData
*
aData
)
=
0
;
virtual
void
Error
(
const
MediaResult
&
aError
)
=
0
;
virtual
void
InputExhausted
(
)
=
0
;
virtual
void
DrainComplete
(
)
=
0
;
virtual
void
ReleaseMediaResources
(
)
{
}
virtual
bool
OnReaderTaskQueue
(
)
=
0
;
virtual
void
WaitingForKey
(
)
{
}
}
;
class
MediaDataDecoder
{
protected
:
virtual
~
MediaDataDecoder
(
)
{
}
;
public
:
typedef
TrackInfo
:
:
TrackType
TrackType
;
typedef
MozPromise
<
TrackType
MediaResult
true
>
InitPromise
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDataDecoder
)
virtual
RefPtr
<
InitPromise
>
Init
(
)
=
0
;
virtual
void
Input
(
MediaRawData
*
aSample
)
=
0
;
virtual
void
Flush
(
)
=
0
;
virtual
void
Drain
(
)
=
0
;
virtual
void
Shutdown
(
)
=
0
;
virtual
bool
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
{
return
false
;
}
virtual
const
char
*
GetDescriptionName
(
)
const
=
0
;
virtual
void
SetSeekThreshold
(
const
media
:
:
TimeUnit
&
aTime
)
{
}
}
;
}
#
endif
