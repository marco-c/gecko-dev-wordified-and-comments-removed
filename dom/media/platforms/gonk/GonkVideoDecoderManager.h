#
if
!
defined
(
GonkVideoDecoderManager_h_
)
#
define
GonkVideoDecoderManager_h_
#
include
"
nsRect
.
h
"
#
include
"
GonkMediaDataDecoder
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
I420ColorConverterHelper
.
h
"
#
include
"
MediaCodecProxy
.
h
"
#
include
"
GonkNativeWindow
.
h
"
#
include
"
GonkNativeWindowClient
.
h
"
#
include
"
mozilla
/
layers
/
FenceUtils
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
ui
/
Fence
.
h
>
using
namespace
android
;
namespace
android
{
class
MediaBuffer
;
struct
MOZ_EXPORT
AString
;
class
GonkNativeWindow
;
}
namespace
mozilla
{
namespace
layers
{
class
TextureClient
;
class
TextureClientRecycleAllocator
;
}
class
GonkVideoDecoderManager
:
public
GonkDecoderManager
{
typedef
android
:
:
MediaCodecProxy
MediaCodecProxy
;
typedef
mozilla
:
:
layers
:
:
TextureClient
TextureClient
;
public
:
GonkVideoDecoderManager
(
mozilla
:
:
layers
:
:
ImageContainer
*
aImageContainer
const
VideoInfo
&
aConfig
)
;
virtual
~
GonkVideoDecoderManager
(
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
nsresult
Output
(
int64_t
aStreamOffset
RefPtr
<
MediaData
>
&
aOutput
)
override
;
nsresult
Shutdown
(
)
override
;
const
char
*
GetDescriptionName
(
)
const
override
{
return
"
gonk
video
decoder
"
;
}
static
void
RecycleCallback
(
TextureClient
*
aClient
void
*
aClosure
)
;
protected
:
void
ProcessFlush
(
)
override
{
mNeedsCopyBuffer
=
true
;
GonkDecoderManager
:
:
ProcessFlush
(
)
;
}
private
:
struct
FrameInfo
{
int32_t
mWidth
=
0
;
int32_t
mHeight
=
0
;
int32_t
mStride
=
0
;
int32_t
mSliceHeight
=
0
;
int32_t
mColorFormat
=
0
;
int32_t
mCropLeft
=
0
;
int32_t
mCropTop
=
0
;
int32_t
mCropRight
=
0
;
int32_t
mCropBottom
=
0
;
}
;
void
onMessageReceived
(
const
android
:
:
sp
<
android
:
:
AMessage
>
&
aMessage
)
override
;
bool
SetVideoFormat
(
)
;
nsresult
CreateVideoData
(
MediaBuffer
*
aBuffer
int64_t
aStreamOffset
VideoData
*
*
aOutData
)
;
already_AddRefed
<
VideoData
>
CreateVideoDataFromGraphicBuffer
(
android
:
:
MediaBuffer
*
aSource
gfx
:
:
IntRect
&
aPicture
)
;
already_AddRefed
<
VideoData
>
CreateVideoDataFromDataBuffer
(
android
:
:
MediaBuffer
*
aSource
gfx
:
:
IntRect
&
aPicture
)
;
uint8_t
*
GetColorConverterBuffer
(
int32_t
aWidth
int32_t
aHeight
)
;
void
codecReserved
(
)
;
void
codecCanceled
(
)
;
void
ReleaseAllPendingVideoBuffers
(
)
;
void
PostReleaseVideoBuffer
(
android
:
:
MediaBuffer
*
aBuffer
layers
:
:
FenceHandle
mReleaseFence
)
;
uint32_t
mVideoWidth
;
uint32_t
mVideoHeight
;
uint32_t
mDisplayWidth
;
uint32_t
mDisplayHeight
;
nsIntRect
mPicture
;
nsIntSize
mInitialFrame
;
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
RefPtr
<
layers
:
:
TextureClientRecycleAllocator
>
mCopyAllocator
;
MediaInfo
mInfo
;
MozPromiseRequestHolder
<
android
:
:
MediaCodecProxy
:
:
CodecPromise
>
mVideoCodecRequest
;
FrameInfo
mFrameInfo
;
android
:
:
I420ColorConverterHelper
mColorConverter
;
UniquePtr
<
uint8_t
[
]
>
mColorConverterBuffer
;
size_t
mColorConverterBufferSize
;
android
:
:
sp
<
android
:
:
GonkNativeWindow
>
mNativeWindow
;
#
if
ANDROID_VERSION
>
=
21
android
:
:
sp
<
android
:
:
IGraphicBufferProducer
>
mGraphicBufferProducer
;
#
endif
enum
{
kNotifyPostReleaseBuffer
=
'
nprb
'
}
;
struct
ReleaseItem
{
ReleaseItem
(
android
:
:
MediaBuffer
*
aBuffer
layers
:
:
FenceHandle
&
aFence
)
:
mBuffer
(
aBuffer
)
mReleaseFence
(
aFence
)
{
}
android
:
:
MediaBuffer
*
mBuffer
;
layers
:
:
FenceHandle
mReleaseFence
;
}
;
nsTArray
<
ReleaseItem
>
mPendingReleaseItems
;
Mutex
mPendingReleaseItemsLock
;
RefPtr
<
TaskQueue
>
mReaderTaskQueue
;
bool
mNeedsCopyBuffer
;
}
;
}
#
endif
