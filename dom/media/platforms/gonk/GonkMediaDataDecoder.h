#
if
!
defined
(
GonkMediaDataDecoder_h_
)
#
define
GonkMediaDataDecoder_h_
#
include
"
PlatformDecoderModule
.
h
"
#
include
<
stagefright
/
foundation
/
AHandler
.
h
>
namespace
android
{
struct
ALooper
;
class
MediaBuffer
;
class
MediaCodecProxy
;
}
namespace
mozilla
{
class
MediaRawData
;
class
GonkDecoderManager
:
public
android
:
:
AHandler
{
public
:
typedef
TrackInfo
:
:
TrackType
TrackType
;
typedef
MediaDataDecoder
:
:
InitPromise
InitPromise
;
typedef
MediaDataDecoder
:
:
DecoderFailureReason
DecoderFailureReason
;
virtual
~
GonkDecoderManager
(
)
{
}
virtual
RefPtr
<
InitPromise
>
Init
(
)
=
0
;
virtual
const
char
*
GetDescriptionName
(
)
const
=
0
;
nsresult
Input
(
MediaRawData
*
aSample
)
;
nsresult
Flush
(
)
;
virtual
nsresult
Shutdown
(
)
;
size_t
NumQueuedSamples
(
)
;
void
SetDecodeCallback
(
MediaDataDecoderCallback
*
aCallback
)
{
mDecodeCallback
=
aCallback
;
}
protected
:
GonkDecoderManager
(
)
:
mMutex
(
"
GonkDecoderManager
"
)
mLastTime
(
INT64_MIN
)
mFlushMonitor
(
"
GonkDecoderManager
:
:
Flush
"
)
mIsFlushing
(
false
)
mDecodeCallback
(
nullptr
)
{
}
bool
InitLoopers
(
MediaData
:
:
Type
aType
)
;
void
onMessageReceived
(
const
android
:
:
sp
<
android
:
:
AMessage
>
&
aMessage
)
override
;
virtual
nsresult
Output
(
int64_t
aStreamOffset
RefPtr
<
MediaData
>
&
aOutput
)
=
0
;
int32_t
ProcessQueuedSamples
(
)
;
void
ProcessInput
(
bool
aEndOfStream
)
;
virtual
void
ProcessFlush
(
)
;
void
ProcessToDo
(
bool
aEndOfStream
)
;
RefPtr
<
MediaByteBuffer
>
mCodecSpecificData
;
nsAutoCString
mMimeType
;
android
:
:
sp
<
android
:
:
MediaCodecProxy
>
mDecoder
;
android
:
:
sp
<
android
:
:
ALooper
>
mDecodeLooper
;
android
:
:
sp
<
android
:
:
ALooper
>
mTaskLooper
;
enum
{
kNotifyDecoderActivity
=
'
nda
'
kNotifyProcessFlush
=
'
npf
'
kNotifyProcessInput
=
'
npi
'
#
ifdef
DEBUG
kNotifyFindLooperId
=
'
nfli
'
#
endif
}
;
MozPromiseHolder
<
InitPromise
>
mInitPromise
;
Mutex
mMutex
;
nsTArray
<
RefPtr
<
MediaRawData
>
>
mQueuedSamples
;
int64_t
mLastTime
;
Monitor
mFlushMonitor
;
bool
mIsFlushing
;
android
:
:
sp
<
android
:
:
AMessage
>
mToDo
;
struct
WaitOutputInfo
{
WaitOutputInfo
(
int64_t
aOffset
int64_t
aTimestamp
bool
aEOS
)
:
mOffset
(
aOffset
)
mTimestamp
(
aTimestamp
)
mEOS
(
aEOS
)
{
}
const
int64_t
mOffset
;
const
int64_t
mTimestamp
;
const
bool
mEOS
;
}
;
nsTArray
<
WaitOutputInfo
>
mWaitOutput
;
MediaDataDecoderCallback
*
mDecodeCallback
;
private
:
void
UpdateWaitingList
(
int64_t
aForgetUpTo
)
;
#
ifdef
DEBUG
typedef
void
*
LooperId
;
bool
OnTaskLooper
(
)
;
LooperId
mTaskLooperId
;
#
endif
}
;
class
AutoReleaseMediaBuffer
{
public
:
AutoReleaseMediaBuffer
(
android
:
:
MediaBuffer
*
aBuffer
android
:
:
MediaCodecProxy
*
aCodec
)
:
mBuffer
(
aBuffer
)
mCodec
(
aCodec
)
{
}
~
AutoReleaseMediaBuffer
(
)
{
MOZ_ASSERT
(
mCodec
.
get
(
)
)
;
if
(
mBuffer
)
{
mCodec
-
>
ReleaseMediaBuffer
(
mBuffer
)
;
}
}
android
:
:
MediaBuffer
*
forget
(
)
{
android
:
:
MediaBuffer
*
tmp
=
mBuffer
;
mBuffer
=
nullptr
;
return
tmp
;
}
private
:
android
:
:
MediaBuffer
*
mBuffer
;
android
:
:
sp
<
android
:
:
MediaCodecProxy
>
mCodec
;
}
;
class
GonkMediaDataDecoder
:
public
MediaDataDecoder
{
public
:
GonkMediaDataDecoder
(
GonkDecoderManager
*
aDecoderManager
FlushableTaskQueue
*
aTaskQueue
MediaDataDecoderCallback
*
aCallback
)
;
~
GonkMediaDataDecoder
(
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
nsresult
Input
(
MediaRawData
*
aSample
)
override
;
nsresult
Flush
(
)
override
;
nsresult
Drain
(
)
override
;
nsresult
Shutdown
(
)
override
;
const
char
*
GetDescriptionName
(
)
const
override
{
return
"
gonk
decoder
"
;
}
private
:
android
:
:
sp
<
GonkDecoderManager
>
mManager
;
}
;
}
#
endif
