#
include
"
BlankDecoderModule
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
VideoUtils
.
h
"
namespace
mozilla
{
BlankVideoDataCreator
:
:
BlankVideoDataCreator
(
uint32_t
aFrameWidth
uint32_t
aFrameHeight
layers
:
:
ImageContainer
*
aImageContainer
)
:
mFrameWidth
(
aFrameWidth
)
mFrameHeight
(
aFrameHeight
)
mImageContainer
(
aImageContainer
)
{
mInfo
.
mDisplay
=
gfx
:
:
IntSize
(
mFrameWidth
mFrameHeight
)
;
mPicture
=
gfx
:
:
IntRect
(
0
0
mFrameWidth
mFrameHeight
)
;
}
already_AddRefed
<
MediaData
>
BlankVideoDataCreator
:
:
Create
(
MediaRawData
*
aSample
)
{
const
CheckedUint32
size
=
CheckedUint32
(
mFrameWidth
)
*
mFrameHeight
;
if
(
!
size
.
isValid
(
)
)
{
return
nullptr
;
}
auto
frame
=
MakeUniqueFallible
<
uint8_t
[
]
>
(
size
.
value
(
)
)
;
if
(
!
frame
)
{
return
nullptr
;
}
memset
(
frame
.
get
(
)
0
mFrameWidth
*
mFrameHeight
)
;
VideoData
:
:
YCbCrBuffer
buffer
;
buffer
.
mPlanes
[
0
]
.
mData
=
frame
.
get
(
)
;
buffer
.
mPlanes
[
0
]
.
mStride
=
mFrameWidth
;
buffer
.
mPlanes
[
0
]
.
mHeight
=
mFrameHeight
;
buffer
.
mPlanes
[
0
]
.
mWidth
=
mFrameWidth
;
buffer
.
mPlanes
[
0
]
.
mOffset
=
0
;
buffer
.
mPlanes
[
0
]
.
mSkip
=
0
;
buffer
.
mPlanes
[
1
]
.
mData
=
frame
.
get
(
)
;
buffer
.
mPlanes
[
1
]
.
mStride
=
(
mFrameWidth
+
1
)
/
2
;
buffer
.
mPlanes
[
1
]
.
mHeight
=
(
mFrameHeight
+
1
)
/
2
;
buffer
.
mPlanes
[
1
]
.
mWidth
=
(
mFrameWidth
+
1
)
/
2
;
buffer
.
mPlanes
[
1
]
.
mOffset
=
0
;
buffer
.
mPlanes
[
1
]
.
mSkip
=
0
;
buffer
.
mPlanes
[
2
]
.
mData
=
frame
.
get
(
)
;
buffer
.
mPlanes
[
2
]
.
mStride
=
(
mFrameWidth
+
1
)
/
2
;
buffer
.
mPlanes
[
2
]
.
mHeight
=
(
mFrameHeight
+
1
)
/
2
;
buffer
.
mPlanes
[
2
]
.
mWidth
=
(
mFrameWidth
+
1
)
/
2
;
buffer
.
mPlanes
[
2
]
.
mOffset
=
0
;
buffer
.
mPlanes
[
2
]
.
mSkip
=
0
;
return
VideoData
:
:
CreateAndCopyData
(
mInfo
mImageContainer
aSample
-
>
mOffset
aSample
-
>
mTime
aSample
-
>
mDuration
buffer
aSample
-
>
mKeyframe
aSample
-
>
mTime
mPicture
)
;
}
BlankAudioDataCreator
:
:
BlankAudioDataCreator
(
uint32_t
aChannelCount
uint32_t
aSampleRate
)
:
mFrameSum
(
0
)
mChannelCount
(
aChannelCount
)
mSampleRate
(
aSampleRate
)
{
}
already_AddRefed
<
MediaData
>
BlankAudioDataCreator
:
:
Create
(
MediaRawData
*
aSample
)
{
CheckedInt64
frames
=
UsecsToFrames
(
aSample
-
>
mDuration
.
ToMicroseconds
(
)
+
1
mSampleRate
)
;
if
(
!
frames
.
isValid
(
)
|
|
!
mChannelCount
|
|
!
mSampleRate
|
|
frames
.
value
(
)
>
(
UINT32_MAX
/
mChannelCount
)
)
{
return
nullptr
;
}
AlignedAudioBuffer
samples
(
frames
.
value
(
)
*
mChannelCount
)
;
if
(
!
samples
)
{
return
nullptr
;
}
static
const
float
pi
=
3
.
14159265f
;
static
const
float
noteHz
=
440
.
0f
;
for
(
int
i
=
0
;
i
<
frames
.
value
(
)
;
i
+
+
)
{
float
f
=
sin
(
2
*
pi
*
noteHz
*
mFrameSum
/
mSampleRate
)
;
for
(
unsigned
c
=
0
;
c
<
mChannelCount
;
c
+
+
)
{
samples
[
i
*
mChannelCount
+
c
]
=
AudioDataValue
(
f
)
;
}
mFrameSum
+
+
;
}
RefPtr
<
AudioData
>
data
(
new
AudioData
(
aSample
-
>
mOffset
aSample
-
>
mTime
aSample
-
>
mDuration
std
:
:
move
(
samples
)
mChannelCount
mSampleRate
)
)
;
return
data
.
forget
(
)
;
}
already_AddRefed
<
MediaDataDecoder
>
BlankDecoderModule
:
:
CreateVideoDecoder
(
const
CreateDecoderParams
&
aParams
)
{
const
VideoInfo
&
config
=
aParams
.
VideoConfig
(
)
;
UniquePtr
<
DummyDataCreator
>
creator
=
MakeUnique
<
BlankVideoDataCreator
>
(
config
.
mDisplay
.
width
config
.
mDisplay
.
height
aParams
.
mImageContainer
)
;
RefPtr
<
MediaDataDecoder
>
decoder
=
new
DummyMediaDataDecoder
(
std
:
:
move
(
creator
)
NS_LITERAL_CSTRING
(
"
blank
media
data
decoder
"
)
aParams
)
;
return
decoder
.
forget
(
)
;
}
already_AddRefed
<
MediaDataDecoder
>
BlankDecoderModule
:
:
CreateAudioDecoder
(
const
CreateDecoderParams
&
aParams
)
{
const
AudioInfo
&
config
=
aParams
.
AudioConfig
(
)
;
UniquePtr
<
DummyDataCreator
>
creator
=
MakeUnique
<
BlankAudioDataCreator
>
(
config
.
mChannels
config
.
mRate
)
;
RefPtr
<
MediaDataDecoder
>
decoder
=
new
DummyMediaDataDecoder
(
std
:
:
move
(
creator
)
NS_LITERAL_CSTRING
(
"
blank
media
data
decoder
"
)
aParams
)
;
return
decoder
.
forget
(
)
;
}
bool
BlankDecoderModule
:
:
SupportsMimeType
(
const
nsACString
&
aMimeType
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
return
true
;
}
already_AddRefed
<
PlatformDecoderModule
>
CreateBlankDecoderModule
(
)
{
RefPtr
<
PlatformDecoderModule
>
pdm
=
new
BlankDecoderModule
(
)
;
return
pdm
.
forget
(
)
;
}
}
