#
include
"
ImageContainer
.
h
"
#
include
"
MediaDecoderReader
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
VideoUtils
.
h
"
namespace
mozilla
{
template
<
class
BlankMediaDataCreator
>
class
BlankMediaDataDecoder
:
public
MediaDataDecoder
{
public
:
BlankMediaDataDecoder
(
BlankMediaDataCreator
*
aCreator
FlushableTaskQueue
*
aTaskQueue
MediaDataDecoderCallback
*
aCallback
TrackInfo
:
:
TrackType
aType
)
:
mCreator
(
aCreator
)
mTaskQueue
(
aTaskQueue
)
mCallback
(
aCallback
)
mType
(
aType
)
{
}
RefPtr
<
InitPromise
>
Init
(
)
override
{
return
InitPromise
:
:
CreateAndResolve
(
mType
__func__
)
;
}
nsresult
Shutdown
(
)
override
{
return
NS_OK
;
}
class
OutputEvent
:
public
nsRunnable
{
public
:
OutputEvent
(
MediaRawData
*
aSample
MediaDataDecoderCallback
*
aCallback
BlankMediaDataCreator
*
aCreator
)
:
mSample
(
aSample
)
mCreator
(
aCreator
)
mCallback
(
aCallback
)
{
}
NS_IMETHOD
Run
(
)
override
{
RefPtr
<
MediaData
>
data
=
mCreator
-
>
Create
(
media
:
:
TimeUnit
:
:
FromMicroseconds
(
mSample
-
>
mTime
)
media
:
:
TimeUnit
:
:
FromMicroseconds
(
mSample
-
>
mDuration
)
mSample
-
>
mOffset
)
;
if
(
!
data
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mCallback
-
>
Output
(
data
)
;
return
NS_OK
;
}
private
:
RefPtr
<
MediaRawData
>
mSample
;
BlankMediaDataCreator
*
mCreator
;
MediaDataDecoderCallback
*
mCallback
;
}
;
nsresult
Input
(
MediaRawData
*
aSample
)
override
{
RefPtr
<
nsIRunnable
>
r
(
new
OutputEvent
(
aSample
mCallback
mCreator
)
)
;
mTaskQueue
-
>
Dispatch
(
r
.
forget
(
)
)
;
return
NS_OK
;
}
nsresult
Flush
(
)
override
{
mTaskQueue
-
>
Flush
(
)
;
return
NS_OK
;
}
nsresult
Drain
(
)
override
{
mCallback
-
>
DrainComplete
(
)
;
return
NS_OK
;
}
const
char
*
GetDescriptionName
(
)
const
override
{
return
"
blank
media
data
decoder
"
;
}
private
:
nsAutoPtr
<
BlankMediaDataCreator
>
mCreator
;
RefPtr
<
FlushableTaskQueue
>
mTaskQueue
;
MediaDataDecoderCallback
*
mCallback
;
TrackInfo
:
:
TrackType
mType
;
}
;
class
BlankVideoDataCreator
{
public
:
BlankVideoDataCreator
(
uint32_t
aFrameWidth
uint32_t
aFrameHeight
layers
:
:
ImageContainer
*
aImageContainer
)
:
mFrameWidth
(
aFrameWidth
)
mFrameHeight
(
aFrameHeight
)
mImageContainer
(
aImageContainer
)
{
mInfo
.
mDisplay
=
nsIntSize
(
mFrameWidth
mFrameHeight
)
;
mPicture
=
gfx
:
:
IntRect
(
0
0
mFrameWidth
mFrameHeight
)
;
}
already_AddRefed
<
MediaData
>
Create
(
const
media
:
:
TimeUnit
&
aDTS
const
media
:
:
TimeUnit
&
aDuration
int64_t
aOffsetInStream
)
{
auto
frame
=
MakeUnique
<
uint8_t
[
]
>
(
mFrameWidth
*
mFrameHeight
)
;
memset
(
frame
.
get
(
)
0
mFrameWidth
*
mFrameHeight
)
;
VideoData
:
:
YCbCrBuffer
buffer
;
buffer
.
mPlanes
[
0
]
.
mData
=
frame
.
get
(
)
;
buffer
.
mPlanes
[
0
]
.
mStride
=
mFrameWidth
;
buffer
.
mPlanes
[
0
]
.
mHeight
=
mFrameHeight
;
buffer
.
mPlanes
[
0
]
.
mWidth
=
mFrameWidth
;
buffer
.
mPlanes
[
0
]
.
mOffset
=
0
;
buffer
.
mPlanes
[
0
]
.
mSkip
=
0
;
buffer
.
mPlanes
[
1
]
.
mData
=
frame
.
get
(
)
;
buffer
.
mPlanes
[
1
]
.
mStride
=
mFrameWidth
/
2
;
buffer
.
mPlanes
[
1
]
.
mHeight
=
mFrameHeight
/
2
;
buffer
.
mPlanes
[
1
]
.
mWidth
=
mFrameWidth
/
2
;
buffer
.
mPlanes
[
1
]
.
mOffset
=
0
;
buffer
.
mPlanes
[
1
]
.
mSkip
=
0
;
buffer
.
mPlanes
[
2
]
.
mData
=
frame
.
get
(
)
;
buffer
.
mPlanes
[
2
]
.
mStride
=
mFrameWidth
/
2
;
buffer
.
mPlanes
[
2
]
.
mHeight
=
mFrameHeight
/
2
;
buffer
.
mPlanes
[
2
]
.
mWidth
=
mFrameWidth
/
2
;
buffer
.
mPlanes
[
2
]
.
mOffset
=
0
;
buffer
.
mPlanes
[
2
]
.
mSkip
=
0
;
return
VideoData
:
:
Create
(
mInfo
mImageContainer
nullptr
aOffsetInStream
aDTS
.
ToMicroseconds
(
)
aDuration
.
ToMicroseconds
(
)
buffer
true
aDTS
.
ToMicroseconds
(
)
mPicture
)
;
}
private
:
VideoInfo
mInfo
;
gfx
:
:
IntRect
mPicture
;
uint32_t
mFrameWidth
;
uint32_t
mFrameHeight
;
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
}
;
class
BlankAudioDataCreator
{
public
:
BlankAudioDataCreator
(
uint32_t
aChannelCount
uint32_t
aSampleRate
)
:
mFrameSum
(
0
)
mChannelCount
(
aChannelCount
)
mSampleRate
(
aSampleRate
)
{
}
MediaData
*
Create
(
const
media
:
:
TimeUnit
&
aDTS
const
media
:
:
TimeUnit
&
aDuration
int64_t
aOffsetInStream
)
{
CheckedInt64
frames
=
UsecsToFrames
(
aDuration
.
ToMicroseconds
(
)
+
1
mSampleRate
)
;
if
(
!
frames
.
isValid
(
)
|
|
!
mChannelCount
|
|
!
mSampleRate
|
|
frames
.
value
(
)
>
(
UINT32_MAX
/
mChannelCount
)
)
{
return
nullptr
;
}
auto
samples
=
MakeUniqueFallible
<
AudioDataValue
[
]
>
(
frames
.
value
(
)
*
mChannelCount
)
;
if
(
!
samples
)
{
return
nullptr
;
}
static
const
float
pi
=
3
.
14159265f
;
static
const
float
noteHz
=
440
.
0f
;
for
(
int
i
=
0
;
i
<
frames
.
value
(
)
;
i
+
+
)
{
float
f
=
sin
(
2
*
pi
*
noteHz
*
mFrameSum
/
mSampleRate
)
;
for
(
unsigned
c
=
0
;
c
<
mChannelCount
;
c
+
+
)
{
samples
[
i
*
mChannelCount
+
c
]
=
AudioDataValue
(
f
)
;
}
mFrameSum
+
+
;
}
return
new
AudioData
(
aOffsetInStream
aDTS
.
ToMicroseconds
(
)
aDuration
.
ToMicroseconds
(
)
uint32_t
(
frames
.
value
(
)
)
Move
(
samples
)
mChannelCount
mSampleRate
)
;
}
private
:
int64_t
mFrameSum
;
uint32_t
mChannelCount
;
uint32_t
mSampleRate
;
}
;
class
BlankDecoderModule
:
public
PlatformDecoderModule
{
public
:
already_AddRefed
<
MediaDataDecoder
>
CreateVideoDecoder
(
const
VideoInfo
&
aConfig
layers
:
:
LayersBackend
aLayersBackend
layers
:
:
ImageContainer
*
aImageContainer
FlushableTaskQueue
*
aVideoTaskQueue
MediaDataDecoderCallback
*
aCallback
)
override
{
BlankVideoDataCreator
*
creator
=
new
BlankVideoDataCreator
(
aConfig
.
mDisplay
.
width
aConfig
.
mDisplay
.
height
aImageContainer
)
;
RefPtr
<
MediaDataDecoder
>
decoder
=
new
BlankMediaDataDecoder
<
BlankVideoDataCreator
>
(
creator
aVideoTaskQueue
aCallback
TrackInfo
:
:
kVideoTrack
)
;
return
decoder
.
forget
(
)
;
}
already_AddRefed
<
MediaDataDecoder
>
CreateAudioDecoder
(
const
AudioInfo
&
aConfig
FlushableTaskQueue
*
aAudioTaskQueue
MediaDataDecoderCallback
*
aCallback
)
override
{
BlankAudioDataCreator
*
creator
=
new
BlankAudioDataCreator
(
aConfig
.
mChannels
aConfig
.
mRate
)
;
RefPtr
<
MediaDataDecoder
>
decoder
=
new
BlankMediaDataDecoder
<
BlankAudioDataCreator
>
(
creator
aAudioTaskQueue
aCallback
TrackInfo
:
:
kAudioTrack
)
;
return
decoder
.
forget
(
)
;
}
bool
SupportsMimeType
(
const
nsACString
&
aMimeType
)
const
override
{
return
true
;
}
ConversionRequired
DecoderNeedsConversion
(
const
TrackInfo
&
aConfig
)
const
override
{
return
kNeedNone
;
}
}
;
already_AddRefed
<
PlatformDecoderModule
>
CreateBlankDecoderModule
(
)
{
RefPtr
<
PlatformDecoderModule
>
pdm
=
new
BlankDecoderModule
(
)
;
return
pdm
.
forget
(
)
;
}
}
