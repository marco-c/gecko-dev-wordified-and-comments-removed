#
include
"
mozilla
/
layers
/
KnowsCompositor
.
h
"
#
if
!
defined
(
GMPVideoDecoder_h_
)
#
define
GMPVideoDecoder_h_
#
include
"
GMPVideoDecoderProxy
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
MediaDataDecoderProxy
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
PerformanceRecorder
.
h
"
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
ReorderQueue
.
h
"
#
include
"
mozIGeckoMediaPluginService
.
h
"
#
include
"
nsClassHashtable
.
h
"
namespace
mozilla
{
struct
MOZ_STACK_CLASS
GMPVideoDecoderParams
{
explicit
GMPVideoDecoderParams
(
const
CreateDecoderParams
&
aParams
)
;
const
VideoInfo
&
mConfig
;
layers
:
:
ImageContainer
*
mImageContainer
;
GMPCrashHelper
*
mCrashHelper
;
layers
:
:
KnowsCompositor
*
mKnowsCompositor
;
const
Maybe
<
TrackingId
>
mTrackingId
;
}
;
DDLoggedTypeDeclNameAndBase
(
GMPVideoDecoder
MediaDataDecoder
)
;
class
GMPVideoDecoder
final
:
public
MediaDataDecoder
public
GMPVideoDecoderCallbackProxy
public
DecoderDoctorLifeLogger
<
GMPVideoDecoder
>
{
public
:
explicit
GMPVideoDecoder
(
const
GMPVideoDecoderParams
&
aParams
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
RefPtr
<
DecodePromise
>
Decode
(
MediaRawData
*
aSample
)
override
;
RefPtr
<
DecodePromise
>
Drain
(
)
override
;
RefPtr
<
FlushPromise
>
Flush
(
)
override
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
nsCString
GetDescriptionName
(
)
const
override
{
return
"
gmp
video
decoder
"
_ns
;
}
nsCString
GetCodecName
(
)
const
override
;
ConversionRequired
NeedsConversion
(
)
const
override
{
return
mConvertToAnnexB
?
ConversionRequired
:
:
kNeedAnnexB
:
ConversionRequired
:
:
kNeedAVCC
;
}
bool
CanDecodeBatch
(
)
const
override
{
return
mCanDecodeBatch
;
}
void
Decoded
(
GMPVideoi420Frame
*
aDecodedFrame
)
override
;
void
ReceivedDecodedReferenceFrame
(
const
uint64_t
aPictureId
)
override
;
void
ReceivedDecodedFrame
(
const
uint64_t
aPictureId
)
override
;
void
InputDataExhausted
(
)
override
;
void
DrainComplete
(
)
override
;
void
ResetComplete
(
)
override
;
void
Error
(
GMPErr
aErr
)
override
;
void
Terminated
(
)
override
;
protected
:
virtual
void
InitTags
(
nsTArray
<
nsCString
>
&
aTags
)
;
virtual
nsCString
GetNodeId
(
)
;
virtual
GMPUniquePtr
<
GMPVideoEncodedFrame
>
CreateFrame
(
MediaRawData
*
aSample
)
;
virtual
const
VideoInfo
&
GetConfig
(
)
const
;
void
ProcessReorderQueue
(
MozPromiseHolder
<
DecodePromise
>
&
aPromise
const
char
*
aMethodName
)
;
private
:
class
GMPInitDoneCallback
:
public
GetGMPVideoDecoderCallback
{
public
:
explicit
GMPInitDoneCallback
(
GMPVideoDecoder
*
aDecoder
)
:
mDecoder
(
aDecoder
)
{
}
void
Done
(
GMPVideoDecoderProxy
*
aGMP
GMPVideoHost
*
aHost
)
override
{
mDecoder
-
>
GMPInitDone
(
aGMP
aHost
)
;
}
private
:
RefPtr
<
GMPVideoDecoder
>
mDecoder
;
}
;
void
GMPInitDone
(
GMPVideoDecoderProxy
*
aGMP
GMPVideoHost
*
aHost
)
;
const
VideoInfo
mConfig
;
nsCOMPtr
<
mozIGeckoMediaPluginService
>
mMPS
;
GMPVideoDecoderProxy
*
mGMP
;
GMPVideoHost
*
mHost
;
bool
mConvertNALUnitLengths
;
MozPromiseHolder
<
InitPromise
>
mInitPromise
;
RefPtr
<
GMPCrashHelper
>
mCrashHelper
;
struct
SampleMetadata
{
explicit
SampleMetadata
(
MediaRawData
*
aSample
)
:
mOffset
(
aSample
-
>
mOffset
)
mKeyframe
(
aSample
-
>
mKeyframe
)
{
}
int64_t
mOffset
;
bool
mKeyframe
;
}
;
nsClassHashtable
<
nsUint64HashKey
SampleMetadata
>
mSamples
;
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
RefPtr
<
layers
:
:
KnowsCompositor
>
mKnowsCompositor
;
PerformanceRecorderMulti
<
DecodeStage
>
mPerformanceRecorder
;
const
Maybe
<
TrackingId
>
mTrackingId
;
uint32_t
mMaxRefFrames
=
0
;
ReorderQueue
mReorderQueue
;
MozPromiseHolder
<
DecodePromise
>
mDecodePromise
;
MozPromiseHolder
<
DecodePromise
>
mDrainPromise
;
MozPromiseHolder
<
FlushPromise
>
mFlushPromise
;
DecodedData
mDecodedData
;
bool
mConvertToAnnexB
=
false
;
bool
mCanDecodeBatch
=
false
;
}
;
}
#
endif
