#
if
!
defined
(
VPXDecoder_h_
)
#
define
VPXDecoder_h_
#
include
"
PlatformDecoderModule
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
stdint
.
h
>
#
define
VPX_DONT_DEFINE_STDINT_TYPES
#
include
"
vpx
/
vp8dx
.
h
"
#
include
"
vpx
/
vpx_codec
.
h
"
#
include
"
vpx
/
vpx_decoder
.
h
"
namespace
mozilla
{
class
VPXDecoder
:
public
MediaDataDecoder
{
public
:
explicit
VPXDecoder
(
const
CreateDecoderParams
&
aParams
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
RefPtr
<
DecodePromise
>
Decode
(
MediaRawData
*
aSample
)
override
;
RefPtr
<
DecodePromise
>
Drain
(
)
override
;
RefPtr
<
FlushPromise
>
Flush
(
)
override
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
const
char
*
GetDescriptionName
(
)
const
override
{
return
"
libvpx
video
decoder
"
;
}
enum
Codec
:
uint8_t
{
VP8
=
1
<
<
0
VP9
=
1
<
<
1
Unknown
=
1
<
<
7
}
;
static
bool
IsVPX
(
const
nsACString
&
aMimeType
uint8_t
aCodecMask
=
VP8
|
VP9
)
;
static
bool
IsVP8
(
const
nsACString
&
aMimeType
)
;
static
bool
IsVP9
(
const
nsACString
&
aMimeType
)
;
static
bool
IsKeyframe
(
Span
<
const
uint8_t
>
aBuffer
Codec
aCodec
)
;
static
gfx
:
:
IntSize
GetFrameSize
(
Span
<
const
uint8_t
>
aBuffer
Codec
aCodec
)
;
private
:
~
VPXDecoder
(
)
;
RefPtr
<
DecodePromise
>
ProcessDecode
(
MediaRawData
*
aSample
)
;
MediaResult
DecodeAlpha
(
vpx_image_t
*
*
aImgAlpha
const
MediaRawData
*
aSample
)
;
const
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
RefPtr
<
layers
:
:
KnowsCompositor
>
mImageAllocator
;
const
RefPtr
<
TaskQueue
>
mTaskQueue
;
vpx_codec_ctx_t
mVPX
;
vpx_codec_ctx_t
mVPXAlpha
;
const
VideoInfo
&
mInfo
;
const
Codec
mCodec
;
}
;
}
#
endif
