#
ifndef
SamplesWaitingForKey_h_
#
define
SamplesWaitingForKey_h_
#
include
<
functional
>
#
include
"
MediaInfo
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
namespace
mozilla
{
typedef
nsTArray
<
uint8_t
>
CencKeyId
;
class
CDMProxy
;
template
<
typename
.
.
.
Es
>
class
MediaEventProducer
;
class
MediaRawData
;
class
SamplesWaitingForKey
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SamplesWaitingForKey
)
typedef
MozPromise
<
RefPtr
<
MediaRawData
>
bool
true
>
WaitForKeyPromise
;
SamplesWaitingForKey
(
CDMProxy
*
aProxy
TrackInfo
:
:
TrackType
aType
const
std
:
:
function
<
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
*
(
)
>
&
aOnWaitingForKeyEvent
)
;
RefPtr
<
WaitForKeyPromise
>
WaitIfKeyNotUsable
(
MediaRawData
*
aSample
)
;
void
NotifyUsable
(
const
CencKeyId
&
aKeyId
)
;
void
Flush
(
)
;
void
BreakCycles
(
)
;
protected
:
~
SamplesWaitingForKey
(
)
;
private
:
Mutex
mMutex
MOZ_UNANNOTATED
;
RefPtr
<
CDMProxy
>
mProxy
;
struct
SampleEntry
{
RefPtr
<
MediaRawData
>
mSample
;
MozPromiseHolder
<
WaitForKeyPromise
>
mPromise
;
}
;
nsTArray
<
SampleEntry
>
mSamples
;
const
TrackInfo
:
:
TrackType
mType
;
const
std
:
:
function
<
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
*
(
)
>
mOnWaitingForKeyEvent
;
}
;
}
#
endif
