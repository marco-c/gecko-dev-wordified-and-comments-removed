#
include
"
mozilla
/
CDMProxy
.
h
"
#
include
"
mozilla
/
CDMCaps
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
SamplesWaitingForKey
.
h
"
namespace
mozilla
{
SamplesWaitingForKey
:
:
SamplesWaitingForKey
(
CDMProxy
*
aProxy
)
:
mMutex
(
"
SamplesWaitingForKey
"
)
mProxy
(
aProxy
)
{
}
SamplesWaitingForKey
:
:
~
SamplesWaitingForKey
(
)
{
Flush
(
)
;
}
RefPtr
<
SamplesWaitingForKey
:
:
WaitForKeyPromise
>
SamplesWaitingForKey
:
:
WaitIfKeyNotUsable
(
MediaRawData
*
aSample
)
{
if
(
!
aSample
|
|
!
aSample
-
>
mCrypto
.
mValid
|
|
!
mProxy
)
{
return
WaitForKeyPromise
:
:
CreateAndResolve
(
aSample
__func__
)
;
}
CDMCaps
:
:
AutoLock
caps
(
mProxy
-
>
Capabilites
(
)
)
;
const
auto
&
keyid
=
aSample
-
>
mCrypto
.
mKeyId
;
if
(
caps
.
IsKeyUsable
(
keyid
)
)
{
return
WaitForKeyPromise
:
:
CreateAndResolve
(
aSample
__func__
)
;
}
SampleEntry
entry
;
entry
.
mSample
=
aSample
;
RefPtr
<
WaitForKeyPromise
>
p
=
entry
.
mPromise
.
Ensure
(
__func__
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
mSamples
.
AppendElement
(
Move
(
entry
)
)
;
}
caps
.
NotifyWhenKeyIdUsable
(
aSample
-
>
mCrypto
.
mKeyId
this
)
;
return
p
;
}
void
SamplesWaitingForKey
:
:
NotifyUsable
(
const
CencKeyId
&
aKeyId
)
{
MutexAutoLock
lock
(
mMutex
)
;
size_t
i
=
0
;
while
(
i
<
mSamples
.
Length
(
)
)
{
auto
&
entry
=
mSamples
[
i
]
;
if
(
aKeyId
=
=
entry
.
mSample
-
>
mCrypto
.
mKeyId
)
{
entry
.
mPromise
.
Resolve
(
entry
.
mSample
__func__
)
;
mSamples
.
RemoveElementAt
(
i
)
;
}
else
{
i
+
+
;
}
}
}
void
SamplesWaitingForKey
:
:
Flush
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
for
(
auto
&
sample
:
mSamples
)
{
sample
.
mPromise
.
Reject
(
true
__func__
)
;
}
mSamples
.
Clear
(
)
;
}
}
