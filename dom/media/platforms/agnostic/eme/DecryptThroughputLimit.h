#
ifndef
DecryptThroughputLimit_h
#
define
DecryptThroughputLimit_h
#
include
<
deque
>
#
include
"
MediaTimer
.
h
"
#
include
"
PlatformDecoderModule
.
h
"
namespace
mozilla
{
class
DecryptThroughputLimit
{
public
:
explicit
DecryptThroughputLimit
(
nsISerialEventTarget
*
aTargetThread
uint32_t
aMaxThroughputMs
)
:
mThrottleScheduler
(
aTargetThread
)
mMaxThroughput
(
aMaxThroughputMs
/
1000
.
0
)
{
}
typedef
MozPromise
<
RefPtr
<
MediaRawData
>
MediaResult
true
>
ThrottlePromise
;
RefPtr
<
ThrottlePromise
>
Throttle
(
MediaRawData
*
aSample
)
{
MOZ_RELEASE_ASSERT
(
!
mThrottleScheduler
.
IsScheduled
(
)
)
;
const
TimeDuration
WindowSize
=
TimeDuration
:
:
FromSeconds
(
0
.
1
)
;
const
TimeDuration
MaxThroughput
=
TimeDuration
:
:
FromSeconds
(
mMaxThroughput
)
;
const
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
while
(
!
mDecrypts
.
empty
(
)
&
&
mDecrypts
.
front
(
)
.
mTimestamp
<
now
-
WindowSize
)
{
mDecrypts
.
pop_front
(
)
;
}
TimeDuration
sampleDuration
=
aSample
-
>
mDuration
.
ToTimeDuration
(
)
;
TimeDuration
durationDecrypted
=
sampleDuration
;
for
(
const
DecryptedJob
&
job
:
mDecrypts
)
{
durationDecrypted
+
=
job
.
mSampleDuration
;
}
if
(
durationDecrypted
<
MaxThroughput
)
{
mDecrypts
.
push_back
(
DecryptedJob
(
{
now
sampleDuration
}
)
)
;
return
ThrottlePromise
:
:
CreateAndResolve
(
aSample
__func__
)
;
}
RefPtr
<
ThrottlePromise
>
p
=
mPromiseHolder
.
Ensure
(
__func__
)
;
TimeDuration
delay
=
durationDecrypted
-
MaxThroughput
;
TimeStamp
target
=
now
+
delay
;
RefPtr
<
MediaRawData
>
sample
(
aSample
)
;
mThrottleScheduler
.
Ensure
(
target
[
this
sample
sampleDuration
]
(
)
{
mThrottleScheduler
.
CompleteRequest
(
)
;
mDecrypts
.
push_back
(
DecryptedJob
(
{
TimeStamp
:
:
Now
(
)
sampleDuration
}
)
)
;
mPromiseHolder
.
Resolve
(
sample
__func__
)
;
}
[
]
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
)
;
}
)
;
return
p
;
}
void
Flush
(
)
{
mThrottleScheduler
.
Reset
(
)
;
mPromiseHolder
.
RejectIfExists
(
NS_ERROR_DOM_MEDIA_CANCELED
__func__
)
;
}
private
:
DelayedScheduler
mThrottleScheduler
;
MozPromiseHolder
<
ThrottlePromise
>
mPromiseHolder
;
double
mMaxThroughput
;
struct
DecryptedJob
{
TimeStamp
mTimestamp
;
TimeDuration
mSampleDuration
;
}
;
std
:
:
deque
<
DecryptedJob
>
mDecrypts
;
}
;
}
#
endif
