#
include
"
EMEVideoDecoder
.
h
"
#
include
"
GMPVideoEncodedFrameImpl
.
h
"
#
include
"
mozilla
/
CDMProxy
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
MP4Decoder
.
h
"
#
include
"
VPXDecoder
.
h
"
namespace
mozilla
{
void
EMEVideoCallbackAdapter
:
:
Error
(
GMPErr
aErr
)
{
if
(
aErr
=
=
GMPNoKeyErr
)
{
NS_WARNING
(
"
GMP
failed
to
decrypt
due
to
lack
of
key
"
)
;
return
;
}
VideoCallbackAdapter
:
:
Error
(
aErr
)
;
}
EMEVideoDecoder
:
:
EMEVideoDecoder
(
CDMProxy
*
aProxy
const
GMPVideoDecoderParams
&
aParams
)
:
GMPVideoDecoder
(
GMPVideoDecoderParams
(
aParams
)
.
WithAdapter
(
new
EMEVideoCallbackAdapter
(
aParams
.
mCallback
VideoInfo
(
aParams
.
mConfig
.
mDisplay
)
aParams
.
mImageContainer
)
)
)
mProxy
(
aProxy
)
{
}
void
EMEVideoDecoder
:
:
InitTags
(
nsTArray
<
nsCString
>
&
aTags
)
{
VideoInfo
config
=
GetConfig
(
)
;
if
(
MP4Decoder
:
:
IsH264
(
config
.
mMimeType
)
)
{
aTags
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
h264
"
)
)
;
}
else
if
(
VPXDecoder
:
:
IsVP8
(
config
.
mMimeType
)
)
{
aTags
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
vp8
"
)
)
;
}
else
if
(
VPXDecoder
:
:
IsVP9
(
config
.
mMimeType
)
)
{
aTags
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
vp9
"
)
)
;
}
aTags
.
AppendElement
(
NS_ConvertUTF16toUTF8
(
mProxy
-
>
KeySystem
(
)
)
)
;
}
nsCString
EMEVideoDecoder
:
:
GetNodeId
(
)
{
return
mProxy
-
>
GetNodeId
(
)
;
}
GMPUniquePtr
<
GMPVideoEncodedFrame
>
EMEVideoDecoder
:
:
CreateFrame
(
MediaRawData
*
aSample
)
{
GMPUniquePtr
<
GMPVideoEncodedFrame
>
frame
=
GMPVideoDecoder
:
:
CreateFrame
(
aSample
)
;
if
(
frame
&
&
aSample
-
>
mCrypto
.
mValid
)
{
static_cast
<
gmp
:
:
GMPVideoEncodedFrameImpl
*
>
(
frame
.
get
(
)
)
-
>
InitCrypto
(
aSample
-
>
mCrypto
)
;
}
return
frame
;
}
}
