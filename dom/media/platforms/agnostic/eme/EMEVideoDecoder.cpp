#
include
"
EMEVideoDecoder
.
h
"
#
include
"
GMPVideoEncodedFrameImpl
.
h
"
#
include
"
mozilla
/
CDMProxy
.
h
"
#
include
"
MediaData
.
h
"
namespace
mozilla
{
void
EMEVideoCallbackAdapter
:
:
Error
(
GMPErr
aErr
)
{
if
(
aErr
=
=
GMPNoKeyErr
)
{
NS_WARNING
(
"
GMP
failed
to
decrypt
due
to
lack
of
key
"
)
;
return
;
}
VideoCallbackAdapter
:
:
Error
(
aErr
)
;
}
EMEVideoDecoder
:
:
EMEVideoDecoder
(
CDMProxy
*
aProxy
const
VideoInfo
&
aConfig
layers
:
:
LayersBackend
aLayersBackend
layers
:
:
ImageContainer
*
aImageContainer
TaskQueue
*
aTaskQueue
MediaDataDecoderCallbackProxy
*
aCallback
)
:
GMPVideoDecoder
(
aConfig
aLayersBackend
aImageContainer
aTaskQueue
aCallback
new
EMEVideoCallbackAdapter
(
aCallback
VideoInfo
(
aConfig
.
mDisplay
.
width
aConfig
.
mDisplay
.
height
)
aImageContainer
)
)
mProxy
(
aProxy
)
{
}
void
EMEVideoDecoder
:
:
InitTags
(
nsTArray
<
nsCString
>
&
aTags
)
{
aTags
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
h264
"
)
)
;
aTags
.
AppendElement
(
NS_ConvertUTF16toUTF8
(
mProxy
-
>
KeySystem
(
)
)
)
;
}
nsCString
EMEVideoDecoder
:
:
GetNodeId
(
)
{
return
mProxy
-
>
GetNodeId
(
)
;
}
GMPUniquePtr
<
GMPVideoEncodedFrame
>
EMEVideoDecoder
:
:
CreateFrame
(
MediaRawData
*
aSample
)
{
GMPUniquePtr
<
GMPVideoEncodedFrame
>
frame
=
GMPVideoDecoder
:
:
CreateFrame
(
aSample
)
;
if
(
frame
&
&
aSample
-
>
mCrypto
.
mValid
)
{
static_cast
<
gmp
:
:
GMPVideoEncodedFrameImpl
*
>
(
frame
.
get
(
)
)
-
>
InitCrypto
(
aSample
-
>
mCrypto
)
;
}
return
frame
;
}
}
