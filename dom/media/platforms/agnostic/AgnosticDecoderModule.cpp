#
include
"
AgnosticDecoderModule
.
h
"
#
include
"
VPXDecoder
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
VideoUtils
.
h
"
#
ifdef
MOZ_AV1
#
include
"
AOMDecoder
.
h
"
#
include
"
DAV1DDecoder
.
h
"
#
endif
namespace
mozilla
{
enum
class
DecoderType
{
#
ifdef
MOZ_AV1
AV1
#
endif
Opus
Vorbis
VPX
Wave
}
;
static
bool
IsAvailableInDefault
(
DecoderType
type
)
{
switch
(
type
)
{
#
ifdef
MOZ_AV1
case
DecoderType
:
:
AV1
:
return
StaticPrefs
:
:
media_av1_enabled
(
)
;
#
endif
case
DecoderType
:
:
Opus
:
case
DecoderType
:
:
Vorbis
:
case
DecoderType
:
:
VPX
:
case
DecoderType
:
:
Wave
:
return
true
;
default
:
return
false
;
}
}
static
bool
IsAvailableInRdd
(
DecoderType
type
)
{
switch
(
type
)
{
#
ifdef
MOZ_AV1
case
DecoderType
:
:
AV1
:
return
StaticPrefs
:
:
media_av1_enabled
(
)
;
#
endif
case
DecoderType
:
:
Opus
:
return
StaticPrefs
:
:
media_rdd_opus_enabled
(
)
;
case
DecoderType
:
:
Vorbis
:
#
if
defined
(
__MINGW32__
)
return
false
;
#
else
return
StaticPrefs
:
:
media_rdd_vorbis_enabled
(
)
;
#
endif
case
DecoderType
:
:
VPX
:
return
StaticPrefs
:
:
media_rdd_vpx_enabled
(
)
;
case
DecoderType
:
:
Wave
:
return
StaticPrefs
:
:
media_rdd_wav_enabled
(
)
;
default
:
return
false
;
}
}
static
bool
IsAvailableInUtility
(
DecoderType
type
)
{
switch
(
type
)
{
case
DecoderType
:
:
Opus
:
return
StaticPrefs
:
:
media_utility_opus_enabled
(
)
;
case
DecoderType
:
:
Vorbis
:
return
StaticPrefs
:
:
media_utility_vorbis_enabled
(
)
;
case
DecoderType
:
:
Wave
:
return
StaticPrefs
:
:
media_utility_wav_enabled
(
)
;
default
:
return
false
;
}
}
static
bool
IsAvailable
(
DecoderType
type
)
{
return
XRE_IsRDDProcess
(
)
?
IsAvailableInRdd
(
type
)
:
XRE_IsUtilityProcess
(
)
?
IsAvailableInUtility
(
type
)
:
IsAvailableInDefault
(
type
)
;
}
media
:
:
DecodeSupportSet
AgnosticDecoderModule
:
:
SupportsMimeType
(
const
nsACString
&
aMimeType
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
UniquePtr
<
TrackInfo
>
trackInfo
=
CreateTrackInfoWithMIMEType
(
aMimeType
)
;
if
(
!
trackInfo
)
{
return
media
:
:
DecodeSupportSet
{
}
;
}
return
Supports
(
SupportDecoderParams
(
*
trackInfo
)
aDiagnostics
)
;
}
media
:
:
DecodeSupportSet
AgnosticDecoderModule
:
:
Supports
(
const
SupportDecoderParams
&
aParams
DecoderDoctorDiagnostics
*
aDiagnostics
)
const
{
if
(
aParams
.
mMediaEngineId
)
{
return
media
:
:
DecodeSupportSet
{
}
;
}
const
auto
&
trackInfo
=
aParams
.
mConfig
;
const
nsACString
&
mimeType
=
trackInfo
.
mMimeType
;
bool
supports
=
#
ifdef
MOZ_AV1
(
AOMDecoder
:
:
IsAV1
(
mimeType
)
&
&
IsAvailable
(
DecoderType
:
:
AV1
)
)
|
|
#
endif
(
VPXDecoder
:
:
IsVPX
(
mimeType
)
&
&
IsAvailable
(
DecoderType
:
:
VPX
)
)
;
MOZ_LOG
(
sPDMLog
LogLevel
:
:
Debug
(
"
Agnostic
decoder
%
s
requested
type
'
%
s
'
"
supports
?
"
supports
"
:
"
rejects
"
mimeType
.
BeginReading
(
)
)
)
;
if
(
supports
)
{
return
media
:
:
DecodeSupport
:
:
SoftwareDecode
;
}
return
media
:
:
DecodeSupportSet
{
}
;
}
already_AddRefed
<
MediaDataDecoder
>
AgnosticDecoderModule
:
:
CreateVideoDecoder
(
const
CreateDecoderParams
&
aParams
)
{
if
(
Supports
(
SupportDecoderParams
(
aParams
)
nullptr
)
.
isEmpty
(
)
)
{
return
nullptr
;
}
RefPtr
<
MediaDataDecoder
>
m
;
if
(
VPXDecoder
:
:
IsVPX
(
aParams
.
mConfig
.
mMimeType
)
)
{
m
=
new
VPXDecoder
(
aParams
)
;
}
#
ifdef
MOZ_AV1
if
(
StaticPrefs
:
:
media_av1_enabled
(
)
&
&
(
!
StaticPrefs
:
:
media_rdd_process_enabled
(
)
|
|
XRE_IsRDDProcess
(
)
)
&
&
AOMDecoder
:
:
IsAV1
(
aParams
.
mConfig
.
mMimeType
)
)
{
if
(
StaticPrefs
:
:
media_av1_use_dav1d
(
)
)
{
m
=
new
DAV1DDecoder
(
aParams
)
;
}
else
{
m
=
new
AOMDecoder
(
aParams
)
;
}
}
#
endif
return
m
.
forget
(
)
;
}
already_AddRefed
<
MediaDataDecoder
>
AgnosticDecoderModule
:
:
CreateAudioDecoder
(
const
CreateDecoderParams
&
aParams
)
{
return
nullptr
;
}
already_AddRefed
<
PlatformDecoderModule
>
AgnosticDecoderModule
:
:
Create
(
)
{
RefPtr
<
PlatformDecoderModule
>
pdm
=
new
AgnosticDecoderModule
(
)
;
return
pdm
.
forget
(
)
;
}
}
