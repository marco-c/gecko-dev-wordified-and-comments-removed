#
include
"
DummyMediaDataDecoder
.
h
"
#
include
"
mp4_demuxer
/
AnnexB
.
h
"
#
include
"
mp4_demuxer
/
H264
.
h
"
namespace
mozilla
{
DummyDataCreator
:
:
~
DummyDataCreator
(
)
{
}
DummyMediaDataDecoder
:
:
DummyMediaDataDecoder
(
UniquePtr
<
DummyDataCreator
>
&
&
aCreator
const
char
*
aDescription
const
CreateDecoderParams
&
aParams
)
:
mCreator
(
Move
(
aCreator
)
)
mIsH264
(
MP4Decoder
:
:
IsH264
(
aParams
.
mConfig
.
mMimeType
)
)
mMaxRefFrames
(
mIsH264
?
mp4_demuxer
:
:
H264
:
:
HasSPS
(
aParams
.
VideoConfig
(
)
.
mExtraData
)
?
mp4_demuxer
:
:
H264
:
:
ComputeMaxRefFrames
(
aParams
.
VideoConfig
(
)
.
mExtraData
)
:
16
:
0
)
mType
(
aParams
.
mConfig
.
GetType
(
)
)
mDescription
(
aDescription
)
{
}
RefPtr
<
MediaDataDecoder
:
:
InitPromise
>
DummyMediaDataDecoder
:
:
Init
(
)
{
return
InitPromise
:
:
CreateAndResolve
(
mType
__func__
)
;
}
RefPtr
<
ShutdownPromise
>
DummyMediaDataDecoder
:
:
Shutdown
(
)
{
return
ShutdownPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
RefPtr
<
MediaDataDecoder
:
:
DecodePromise
>
DummyMediaDataDecoder
:
:
Decode
(
MediaRawData
*
aSample
)
{
RefPtr
<
MediaData
>
data
=
mCreator
-
>
Create
(
aSample
)
;
if
(
!
data
)
{
return
DecodePromise
:
:
CreateAndReject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
}
mReorderQueue
.
Push
(
data
)
;
if
(
mReorderQueue
.
Length
(
)
>
mMaxRefFrames
)
{
return
DecodePromise
:
:
CreateAndResolve
(
DecodedData
{
mReorderQueue
.
Pop
(
)
.
get
(
)
}
__func__
)
;
}
return
DecodePromise
:
:
CreateAndResolve
(
DecodedData
(
)
__func__
)
;
}
RefPtr
<
MediaDataDecoder
:
:
DecodePromise
>
DummyMediaDataDecoder
:
:
Drain
(
)
{
DecodedData
samples
;
while
(
!
mReorderQueue
.
IsEmpty
(
)
)
{
samples
.
AppendElement
(
mReorderQueue
.
Pop
(
)
.
get
(
)
)
;
}
return
DecodePromise
:
:
CreateAndResolve
(
samples
__func__
)
;
}
RefPtr
<
MediaDataDecoder
:
:
FlushPromise
>
DummyMediaDataDecoder
:
:
Flush
(
)
{
mReorderQueue
.
Clear
(
)
;
return
FlushPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
const
char
*
DummyMediaDataDecoder
:
:
GetDescriptionName
(
)
const
{
return
"
blank
media
data
decoder
"
;
}
MediaDataDecoder
:
:
ConversionRequired
DummyMediaDataDecoder
:
:
NeedsConversion
(
)
const
{
return
mIsH264
?
ConversionRequired
:
:
kNeedAVCC
:
ConversionRequired
:
:
kNeedNone
;
}
}
