#
include
"
gtest
/
gtest
.
h
"
#
include
"
AnnexB
.
h
"
#
include
"
BufferReader
.
h
"
#
include
"
ByteWriter
.
h
"
#
include
"
H264
.
h
"
#
include
"
H265
.
h
"
#
include
"
mozilla
/
Types
.
h
"
namespace
mozilla
{
static
already_AddRefed
<
MediaByteBuffer
>
GetExtraData
(
)
{
return
H264
:
:
CreateExtraData
(
0x42
0xc0
H264_LEVEL
{
0x28
}
{
1280
720
}
)
;
}
static
already_AddRefed
<
MediaRawData
>
GetAvccSample
(
uint32_t
aSampleSize
)
{
if
(
aSampleSize
<
4
)
{
EXPECT_FALSE
(
true
)
<
<
"
Samples
should
be
requested
with
sane
sizes
"
;
}
nsTArray
<
uint8_t
>
sampleData
;
ByteWriter
<
BigEndian
>
writer
(
sampleData
)
;
EXPECT_TRUE
(
writer
.
WriteU32
(
aSampleSize
-
4
)
)
;
sampleData
.
AppendElements
(
static_cast
<
size_t
>
(
aSampleSize
)
-
4
)
;
RefPtr
<
MediaRawData
>
rawData
=
new
MediaRawData
{
sampleData
.
Elements
(
)
sampleData
.
Length
(
)
}
;
EXPECT_NE
(
rawData
-
>
Data
(
)
nullptr
)
;
rawData
-
>
mExtraData
=
GetExtraData
(
)
;
return
rawData
.
forget
(
)
;
}
static
const
uint8_t
sHvccBytesBuffer
[
]
=
{
1
1
0x60
0
0
0
0x90
0
0
0
0
0
0x5A
0
0
0
1
0
0
0
0
0x0F
2
0x21
0
1
0
8
0x42
0
0
0
0
0
0
0
0x22
0
1
0
3
0x44
0
0
}
;
static
already_AddRefed
<
MediaRawData
>
GetHVCCSample
(
uint32_t
aSampleSize
)
{
if
(
aSampleSize
<
4
)
{
EXPECT_FALSE
(
true
)
<
<
"
Samples
should
be
requested
with
sane
sizes
"
;
}
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
extradata
-
>
AppendElements
(
sHvccBytesBuffer
std
:
:
size
(
sHvccBytesBuffer
)
)
;
nsTArray
<
uint8_t
>
sampleData
;
ByteWriter
<
BigEndian
>
writer
(
sampleData
)
;
EXPECT_TRUE
(
writer
.
WriteU32
(
aSampleSize
-
4
)
)
;
for
(
uint32_t
idx
=
0
;
idx
<
aSampleSize
-
4
;
idx
+
+
)
{
sampleData
.
AppendElement
(
0
)
;
}
RefPtr
<
MediaRawData
>
rawData
=
new
MediaRawData
{
sampleData
.
Elements
(
)
sampleData
.
Length
(
)
}
;
EXPECT_NE
(
rawData
-
>
Data
(
)
nullptr
)
;
EXPECT_EQ
(
rawData
-
>
Size
(
)
aSampleSize
)
;
rawData
-
>
mExtraData
=
extradata
;
return
rawData
.
forget
(
)
;
}
static
already_AddRefed
<
MediaRawData
>
GetHVCCSample
(
const
uint8_t
*
aData
const
uint32_t
aDataLength
)
{
if
(
aDataLength
<
4
)
{
EXPECT_FALSE
(
true
)
<
<
"
Samples
should
be
requested
with
sane
sizes
"
;
}
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
extradata
-
>
AppendElements
(
sHvccBytesBuffer
std
:
:
size
(
sHvccBytesBuffer
)
)
;
nsTArray
<
uint8_t
>
sampleData
;
ByteWriter
<
BigEndian
>
writer
(
sampleData
)
;
EXPECT_TRUE
(
writer
.
WriteU32
(
aDataLength
)
)
;
sampleData
.
AppendElements
(
aData
aDataLength
)
;
RefPtr
<
MediaRawData
>
rawData
=
new
MediaRawData
{
sampleData
.
Elements
(
)
sampleData
.
Length
(
)
}
;
EXPECT_NE
(
rawData
-
>
Data
(
)
nullptr
)
;
EXPECT_EQ
(
rawData
-
>
Size
(
)
aDataLength
+
4
)
;
rawData
-
>
mExtraData
=
extradata
;
return
rawData
.
forget
(
)
;
}
TEST
(
AnnexB
AVCCToAnnexBConversion
)
{
RefPtr
<
MediaRawData
>
rawData
{
GetAvccSample
(
128
)
}
;
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertAVCCSampleToAnnexB
(
rawDataClone
false
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_EQ
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
the
same
size
as
the
AVCC
sample
-
-
the
4
"
"
byte
NAL
length
data
(
AVCC
)
is
replaced
with
4
bytes
of
NAL
"
"
separator
(
AnnexB
)
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
rawDataClone
-
>
mKeyframe
=
false
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertAVCCSampleToAnnexB
(
rawDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_EQ
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
the
same
size
as
the
AVCC
sample
-
-
the
4
"
"
byte
NAL
length
data
(
AVCC
)
is
replaced
with
4
bytes
of
NAL
"
"
separator
(
AnnexB
)
and
SPS
data
is
not
added
as
the
frame
is
not
a
"
"
keyframe
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
rawDataClone
-
>
mKeyframe
=
true
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertAVCCSampleToAnnexB
(
rawDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_GT
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
larger
than
the
AVCC
sample
because
we
'
ve
"
"
added
SPS
data
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
const
uint32_t
sampleSize
=
UINT16_MAX
*
2
;
RefPtr
<
MediaRawData
>
rawCryptoData
{
GetAvccSample
(
sampleSize
)
}
;
rawCryptoData
-
>
mKeyframe
=
true
;
UniquePtr
<
MediaRawDataWriter
>
rawDataWriter
=
rawCryptoData
-
>
CreateWriter
(
)
;
rawDataWriter
-
>
mCrypto
.
mCryptoScheme
=
CryptoScheme
:
:
Cenc
;
const
uint16_t
clearSize
=
UINT16_MAX
-
10
;
rawDataWriter
-
>
mCrypto
.
mPlainSizes
.
AppendElement
(
clearSize
)
;
rawDataWriter
-
>
mCrypto
.
mEncryptedSizes
.
AppendElement
(
sampleSize
-
clearSize
)
;
RefPtr
<
MediaRawData
>
rawCryptoDataClone
=
rawCryptoData
-
>
Clone
(
)
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertAVCCSampleToAnnexB
(
rawCryptoDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_GT
(
rawCryptoDataClone
-
>
Size
(
)
rawCryptoData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
larger
than
the
AVCC
sample
because
we
'
ve
"
"
added
SPS
data
"
;
EXPECT_GT
(
rawCryptoDataClone
-
>
mCrypto
.
mPlainSizes
[
0
]
rawCryptoData
-
>
mCrypto
.
mPlainSizes
[
0
]
)
<
<
"
Conversion
should
have
increased
clear
data
sizes
without
overflow
"
;
EXPECT_EQ
(
rawCryptoDataClone
-
>
mCrypto
.
mEncryptedSizes
[
0
]
rawCryptoData
-
>
mCrypto
.
mEncryptedSizes
[
0
]
)
<
<
"
Conversion
should
not
affect
encrypted
sizes
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
rawCryptoDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
}
TEST
(
AnnexB
HVCCToAnnexBConversion
)
{
RefPtr
<
MediaRawData
>
rawData
{
GetHVCCSample
(
128
)
}
;
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertHVCCSampleToAnnexB
(
rawDataClone
false
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_EQ
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
the
same
size
as
the
HVCC
sample
-
-
the
4
"
"
byte
NAL
length
data
(
HVCC
)
is
replaced
with
4
bytes
of
NAL
"
"
separator
(
AnnexB
)
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
rawDataClone
-
>
mKeyframe
=
false
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertHVCCSampleToAnnexB
(
rawDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_EQ
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
the
same
size
as
the
HVCC
sample
-
-
the
4
"
"
byte
NAL
length
data
(
HVCC
)
is
replaced
with
4
bytes
of
NAL
"
"
separator
(
AnnexB
)
and
SPS
data
is
not
added
as
the
frame
is
not
a
"
"
keyframe
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
rawDataClone
-
>
mKeyframe
=
true
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertHVCCSampleToAnnexB
(
rawDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_GT
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
larger
than
the
HVCC
sample
because
we
'
ve
"
"
added
SPS
data
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
const
uint32_t
sampleSize
=
UINT16_MAX
*
2
;
RefPtr
<
MediaRawData
>
rawCryptoData
{
GetHVCCSample
(
sampleSize
)
}
;
rawCryptoData
-
>
mKeyframe
=
true
;
UniquePtr
<
MediaRawDataWriter
>
rawDataWriter
=
rawCryptoData
-
>
CreateWriter
(
)
;
rawDataWriter
-
>
mCrypto
.
mCryptoScheme
=
CryptoScheme
:
:
Cenc
;
const
uint16_t
clearSize
=
UINT16_MAX
-
10
;
rawDataWriter
-
>
mCrypto
.
mPlainSizes
.
AppendElement
(
clearSize
)
;
rawDataWriter
-
>
mCrypto
.
mEncryptedSizes
.
AppendElement
(
sampleSize
-
clearSize
)
;
RefPtr
<
MediaRawData
>
rawCryptoDataClone
=
rawCryptoData
-
>
Clone
(
)
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertHVCCSampleToAnnexB
(
rawCryptoDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_GT
(
rawCryptoDataClone
-
>
Size
(
)
rawCryptoData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
larger
than
the
HVCC
sample
because
we
'
ve
"
"
added
SPS
data
"
;
EXPECT_GT
(
rawCryptoDataClone
-
>
mCrypto
.
mPlainSizes
[
0
]
rawCryptoData
-
>
mCrypto
.
mPlainSizes
[
0
]
)
<
<
"
Conversion
should
have
increased
clear
data
sizes
without
overflow
"
;
EXPECT_EQ
(
rawCryptoDataClone
-
>
mCrypto
.
mEncryptedSizes
[
0
]
rawCryptoData
-
>
mCrypto
.
mEncryptedSizes
[
0
]
)
<
<
"
Conversion
should
not
affect
encrypted
sizes
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
rawCryptoDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
}
TEST
(
H264
AVCCParsingSuccess
)
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
avccBytesBuffer
[
]
=
{
1
0x64
0
40
0xfc
|
3
0xe0
0
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
rv
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
;
const
auto
avcc
=
rv
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
mConfigurationVersion
1
)
;
EXPECT_EQ
(
avcc
.
mAVCProfileIndication
0x64
)
;
EXPECT_EQ
(
avcc
.
mProfileCompatibility
0
)
;
EXPECT_EQ
(
avcc
.
mAVCLevelIndication
40
)
;
EXPECT_EQ
(
avcc
.
NALUSize
(
)
4
)
;
EXPECT_EQ
(
avcc
.
mNumSPS
0
)
;
}
TEST
(
H264
AVCCParsingFailure
)
{
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
avccBytesBuffer
[
]
=
{
2
0x64
0
40
0xfc
|
3
0xe0
0
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
avcc
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
avcc
.
isErr
(
)
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
avccBytesBuffer
[
]
=
{
1
0x64
0
40
0xfc
|
3
0xe0
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
avcc
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
avcc
.
isErr
(
)
)
;
}
}
TEST
(
H265
HVCCParsingSuccess
)
{
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
hvccBytesBuffer
[
]
=
{
1
1
0x60
0
0
0
0x90
0
0
0
0
0
0x5A
0
0
0
1
0
0
0
0
0x0F
0
}
;
extradata
-
>
AppendElements
(
hvccBytesBuffer
std
:
:
size
(
hvccBytesBuffer
)
)
;
auto
rv
=
HVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
;
auto
hvcc
=
rv
.
unwrap
(
)
;
EXPECT_EQ
(
hvcc
.
configurationVersion
1
)
;
EXPECT_EQ
(
hvcc
.
general_profile_space
0
)
;
EXPECT_EQ
(
hvcc
.
general_tier_flag
false
)
;
EXPECT_EQ
(
hvcc
.
general_profile_idc
1
)
;
EXPECT_EQ
(
hvcc
.
general_profile_compatibility_flags
(
uint32_t
)
0x60000000
)
;
EXPECT_EQ
(
hvcc
.
general_constraint_indicator_flags
(
uint64_t
)
0x900000000000
)
;
EXPECT_EQ
(
hvcc
.
general_level_idc
0x5A
)
;
EXPECT_EQ
(
hvcc
.
min_spatial_segmentation_idc
0
)
;
EXPECT_EQ
(
hvcc
.
parallelismType
0
)
;
EXPECT_EQ
(
hvcc
.
chroma_format_idc
1
)
;
EXPECT_EQ
(
hvcc
.
bit_depth_luma_minus8
0
)
;
EXPECT_EQ
(
hvcc
.
bit_depth_chroma_minus8
0
)
;
EXPECT_EQ
(
hvcc
.
avgFrameRate
0
)
;
EXPECT_EQ
(
hvcc
.
constantFrameRate
0
)
;
EXPECT_EQ
(
hvcc
.
numTemporalLayers
1
)
;
EXPECT_EQ
(
hvcc
.
temporalIdNested
true
)
;
EXPECT_EQ
(
hvcc
.
NALUSize
(
)
4
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
.
Length
(
)
uint32_t
(
0
)
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
hvccBytesBuffer
[
]
=
{
1
1
0x60
0
0
0
0x90
0
0
0
0
0
0x5A
0
0
0
1
0
0
0
0
0x0F
2
0x21
0
1
0
8
0x42
0
0
0
0
0
0
0
0x22
0
2
0
3
0x44
0
0
0
3
0x44
0
0
}
;
extradata
-
>
AppendElements
(
hvccBytesBuffer
std
:
:
size
(
hvccBytesBuffer
)
)
;
auto
rv
=
HVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
;
auto
hvcc
=
rv
.
unwrap
(
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
.
Length
(
)
uint32_t
(
3
)
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
SPS_NUT
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNuhLayerId
0
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNuhTemporalIdPlus1
0
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
IsSPS
(
)
true
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNALU
.
Length
(
)
8u
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
1
]
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
PPS_NUT
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
1
]
.
mNuhLayerId
0
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
1
]
.
mNuhTemporalIdPlus1
0
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
1
]
.
IsSPS
(
)
false
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
1
]
.
mNALU
.
Length
(
)
3u
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
2
]
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
PPS_NUT
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
2
]
.
mNuhLayerId
0
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
2
]
.
mNuhTemporalIdPlus1
0
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
2
]
.
IsSPS
(
)
false
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
2
]
.
mNALU
.
Length
(
)
3u
)
;
}
}
TEST
(
H265
HVCCParsingFailure
)
{
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
hvccBytesBuffer
[
]
=
{
2
1
0x60
0
0
0
0x90
0
0
0
0
0
0x5A
0
0
0
1
0
0
0
0
0x0F
0
}
;
extradata
-
>
AppendElements
(
hvccBytesBuffer
std
:
:
size
(
hvccBytesBuffer
)
)
;
auto
avcc
=
HVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
avcc
.
isErr
(
)
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
hvccBytesBuffer
[
]
=
{
1
1
0x60
0
0
0
0x90
0
0
0
0
0
0x5A
}
;
extradata
-
>
AppendElements
(
hvccBytesBuffer
std
:
:
size
(
hvccBytesBuffer
)
)
;
auto
avcc
=
HVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
avcc
.
isErr
(
)
)
;
}
}
TEST
(
H265
HVCCToAnnexB
)
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
hvccBytesBuffer
[
]
=
{
1
1
0x60
0
0
0
0x90
0
0
0
0
0
0x5A
0
0
0
1
0
0
0
0
0x0F
2
0x21
0
1
0
3
0x42
0
0
0x22
0
1
0
3
0x44
0
0
}
;
extradata
-
>
AppendElements
(
hvccBytesBuffer
std
:
:
size
(
hvccBytesBuffer
)
)
;
const
size_t
naluBytesSize
=
3
;
const
size_t
delimiterBytesSize
=
4
;
const
size_t
naluPlusDelimiterBytesSize
=
naluBytesSize
+
delimiterBytesSize
;
RefPtr
<
mozilla
:
:
MediaByteBuffer
>
annexBExtraData
=
AnnexB
:
:
ConvertHVCCExtraDataToAnnexB
(
extradata
)
;
EXPECT_EQ
(
annexBExtraData
-
>
Length
(
)
naluPlusDelimiterBytesSize
*
2
)
;
H265NALU
sps
(
static_cast
<
uint8_t
*
>
(
annexBExtraData
-
>
Elements
(
)
+
delimiterBytesSize
)
naluBytesSize
)
;
EXPECT_EQ
(
sps
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
SPS_NUT
)
;
EXPECT_EQ
(
sps
.
mNuhLayerId
0
)
;
EXPECT_EQ
(
sps
.
mNuhTemporalIdPlus1
0
)
;
EXPECT_EQ
(
sps
.
IsSPS
(
)
true
)
;
EXPECT_EQ
(
sps
.
mNALU
.
Length
(
)
3u
)
;
H265NALU
pps
(
static_cast
<
uint8_t
*
>
(
annexBExtraData
-
>
Elements
(
)
+
naluPlusDelimiterBytesSize
+
delimiterBytesSize
)
naluBytesSize
)
;
EXPECT_EQ
(
pps
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
PPS_NUT
)
;
EXPECT_EQ
(
pps
.
mNuhLayerId
0
)
;
EXPECT_EQ
(
pps
.
mNuhTemporalIdPlus1
0
)
;
EXPECT_EQ
(
pps
.
IsSPS
(
)
false
)
;
EXPECT_EQ
(
pps
.
mNALU
.
Length
(
)
3u
)
;
}
TEST
(
H265
AnnexBToHVCC
)
{
RefPtr
<
MediaRawData
>
rawData
{
GetHVCCSample
(
128
)
}
;
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertHVCCSampleToAnnexB
(
rawDataClone
false
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
HVCC
to
AnnexB
Conversion
should
succeed
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
auto
rv
=
AnnexB
:
:
ConvertSampleToHVCC
(
rawDataClone
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
<
<
"
AnnexB
to
HVCC
Conversion
should
succeed
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsHVCC
(
rawDataClone
)
)
<
<
"
The
sample
should
be
HVCC
following
conversion
"
;
}
static
const
uint8_t
sSps
[
]
=
{
0x42
0x01
0x01
0x01
0x60
0x00
0x00
0x03
0x00
0x90
0x00
0x00
0x03
0x00
0x00
0x03
0x00
0x5d
0xa0
0x02
0x00
0x80
0x30
0x16
0x59
0x59
0xa4
0x93
0x2b
0xc0
0x5a
0x02
0x00
0x00
0x03
0x00
0x02
0x00
0x00
0x03
0x00
0x3c
0x10
}
;
TEST
(
H265
ExtractHVCCExtraData
)
{
RefPtr
<
MediaRawData
>
rawData
{
GetHVCCSample
(
sSps
std
:
:
size
(
sSps
)
)
}
;
RefPtr
<
MediaByteBuffer
>
extradata
=
H265
:
:
ExtractHVCCExtraData
(
rawData
)
;
EXPECT_TRUE
(
extradata
)
;
auto
rv
=
HVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
;
auto
hvcc
=
rv
.
unwrap
(
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
.
Length
(
)
1u
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
SPS_NUT
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNuhLayerId
0u
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNuhTemporalIdPlus1
1
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
IsSPS
(
)
true
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNALU
.
Length
(
)
43u
)
;
}
TEST
(
H265
DecodeSPSFromSPSNALU
)
{
H265NALU
nalu
{
sSps
std
:
:
size
(
sSps
)
}
;
auto
rv
=
H265
:
:
DecodeSPSFromSPSNALU
(
nalu
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
;
auto
sps
=
rv
.
unwrap
(
)
;
EXPECT_EQ
(
sps
.
sps_video_parameter_set_id
0u
)
;
EXPECT_EQ
(
sps
.
sps_max_sub_layers_minus1
0u
)
;
EXPECT_EQ
(
sps
.
sps_temporal_id_nesting_flag
1
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_profile_space
0u
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_tier_flag
false
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_profile_idc
1u
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_profile_compatibility_flags
0x60000000u
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_progressive_source_flag
true
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_interlaced_source_flag
false
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_non_packed_constraint_flag
false
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_frame_only_constraint_flag
true
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_level_idc
93u
)
;
EXPECT_EQ
(
sps
.
sps_seq_parameter_set_id
0u
)
;
EXPECT_EQ
(
sps
.
chroma_format_idc
1u
)
;
EXPECT_EQ
(
sps
.
separate_colour_plane_flag
false
)
;
EXPECT_EQ
(
sps
.
pic_width_in_luma_samples
1024u
)
;
EXPECT_EQ
(
sps
.
pic_height_in_luma_samples
768u
)
;
EXPECT_EQ
(
sps
.
conformance_window_flag
false
)
;
EXPECT_EQ
(
sps
.
bit_depth_luma_minus8
0u
)
;
EXPECT_EQ
(
sps
.
bit_depth_chroma_minus8
0u
)
;
EXPECT_EQ
(
sps
.
log2_max_pic_order_cnt_lsb_minus4
4u
)
;
EXPECT_EQ
(
sps
.
sps_sub_layer_ordering_info_present_flag
true
)
;
EXPECT_EQ
(
sps
.
sps_max_dec_pic_buffering_minus1
[
0
]
4u
)
;
EXPECT_EQ
(
sps
.
sps_max_num_reorder_pics
[
0
]
2u
)
;
EXPECT_EQ
(
sps
.
sps_max_latency_increase_plus1
[
0
]
5u
)
;
EXPECT_EQ
(
sps
.
log2_min_luma_coding_block_size_minus3
0u
)
;
EXPECT_EQ
(
sps
.
log2_diff_max_min_luma_coding_block_size
3u
)
;
EXPECT_EQ
(
sps
.
log2_min_luma_transform_block_size_minus2
0u
)
;
EXPECT_EQ
(
sps
.
log2_diff_max_min_luma_transform_block_size
3u
)
;
EXPECT_EQ
(
sps
.
max_transform_hierarchy_depth_inter
0u
)
;
EXPECT_EQ
(
sps
.
max_transform_hierarchy_depth_inter
0u
)
;
EXPECT_EQ
(
sps
.
pcm_enabled_flag
false
)
;
EXPECT_EQ
(
sps
.
num_short_term_ref_pic_sets
0u
)
;
EXPECT_EQ
(
sps
.
sps_temporal_mvp_enabled_flag
true
)
;
EXPECT_EQ
(
sps
.
strong_intra_smoothing_enabled_flag
true
)
;
EXPECT_TRUE
(
sps
.
vui_parameters
)
;
EXPECT_EQ
(
sps
.
vui_parameters
-
>
video_full_range_flag
false
)
;
EXPECT_EQ
(
sps
.
BitDepthLuma
(
)
8u
)
;
EXPECT_EQ
(
sps
.
BitDepthChroma
(
)
8u
)
;
const
auto
imgSize
=
sps
.
GetImageSize
(
)
;
EXPECT_EQ
(
imgSize
.
Width
(
)
1024
)
;
EXPECT_EQ
(
imgSize
.
Height
(
)
768
)
;
const
auto
disSize
=
sps
.
GetDisplaySize
(
)
;
EXPECT_EQ
(
disSize
imgSize
)
;
EXPECT_EQ
(
sps
.
ColorDepth
(
)
gfx
:
:
ColorDepth
:
:
COLOR_8
)
;
EXPECT_EQ
(
sps
.
ColorSpace
(
)
gfx
:
:
YUVColorSpace
:
:
BT709
)
;
EXPECT_EQ
(
sps
.
IsFullColorRange
(
)
false
)
;
EXPECT_EQ
(
sps
.
ColorPrimaries
(
)
2u
)
;
EXPECT_EQ
(
sps
.
TransferFunction
(
)
2u
)
;
}
TEST
(
H265
SPSIteratorAndCreateNewExtraData
)
{
RefPtr
<
MediaByteBuffer
>
extradata
=
H265
:
:
CreateFakeExtraData
(
)
;
EXPECT_TRUE
(
extradata
)
;
auto
rv
=
HVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
;
auto
hvcc
=
rv
.
unwrap
(
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
.
Length
(
)
3u
)
;
EXPECT_EQ
(
hvcc
.
NumSPS
(
)
1u
)
;
SPSIterator
it
(
hvcc
)
;
auto
*
sps
=
*
it
;
EXPECT_TRUE
(
sps
)
;
auto
spsMaybe
=
hvcc
.
GetFirstAvaiableNALU
(
H265NALU
:
:
NAL_TYPES
:
:
SPS_NUT
)
;
EXPECT_TRUE
(
spsMaybe
)
;
auto
rv1
=
H265
:
:
DecodeSPSFromSPSNALU
(
*
sps
)
;
auto
rv2
=
H265
:
:
DecodeSPSFromSPSNALU
(
spsMaybe
.
ref
(
)
)
;
EXPECT_TRUE
(
rv1
.
isOk
(
)
)
;
EXPECT_TRUE
(
rv2
.
isOk
(
)
)
;
EXPECT_EQ
(
rv1
.
unwrap
(
)
rv2
.
unwrap
(
)
)
;
EXPECT_FALSE
(
*
(
+
+
it
)
)
;
auto
ppsMaybe
=
hvcc
.
GetFirstAvaiableNALU
(
H265NALU
:
:
NAL_TYPES
:
:
PPS_NUT
)
;
EXPECT_TRUE
(
ppsMaybe
)
;
auto
vpsMaybe
=
hvcc
.
GetFirstAvaiableNALU
(
H265NALU
:
:
NAL_TYPES
:
:
VPS_NUT
)
;
EXPECT_TRUE
(
vpsMaybe
)
;
RefPtr
<
MediaByteBuffer
>
newExtradata
=
H265
:
:
CreateNewExtraData
(
hvcc
spsMaybe
ppsMaybe
vpsMaybe
)
;
EXPECT_TRUE
(
newExtradata
)
;
auto
rv3
=
HVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
rv3
.
isOk
(
)
)
;
auto
hvcc2
=
rv3
.
unwrap
(
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
.
Length
(
)
hvcc2
.
mNALUs
.
Length
(
)
)
;
EXPECT_EQ
(
hvcc
.
NumSPS
(
)
hvcc2
.
NumSPS
(
)
)
;
}
}
