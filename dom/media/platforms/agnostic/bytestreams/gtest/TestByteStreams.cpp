#
include
"
AnnexB
.
h
"
#
include
"
BufferReader
.
h
"
#
include
"
ByteWriter
.
h
"
#
include
"
H264
.
h
"
#
include
"
H265
.
h
"
#
include
"
gtest
/
gtest
.
h
"
namespace
mozilla
{
static
already_AddRefed
<
MediaByteBuffer
>
GetExtraData
(
)
{
return
H264
:
:
CreateExtraData
(
0x42
0xc0
H264_LEVEL
{
0x28
}
{
1280
720
}
)
;
}
static
already_AddRefed
<
MediaRawData
>
GetAvccSample
(
uint32_t
aSampleSize
)
{
if
(
aSampleSize
<
4
)
{
EXPECT_FALSE
(
true
)
<
<
"
Samples
should
be
requested
with
sane
sizes
"
;
}
nsTArray
<
uint8_t
>
sampleData
;
ByteWriter
<
BigEndian
>
writer
(
sampleData
)
;
EXPECT_TRUE
(
writer
.
WriteU32
(
aSampleSize
-
4
)
)
;
sampleData
.
AppendElements
(
static_cast
<
size_t
>
(
aSampleSize
)
-
4
)
;
RefPtr
<
MediaRawData
>
rawData
=
new
MediaRawData
{
sampleData
.
Elements
(
)
sampleData
.
Length
(
)
}
;
EXPECT_NE
(
rawData
-
>
Data
(
)
nullptr
)
;
rawData
-
>
mExtraData
=
GetExtraData
(
)
;
return
rawData
.
forget
(
)
;
}
static
const
uint8_t
sHvccBytesBuffer
[
]
=
{
1
1
0x60
0
0
0
0x90
0
0
0
0
0
0x5A
0
0
0
1
0
0
0
0
0x0F
2
0x21
0
1
0
8
0x42
0
0
0
0
0
0
0
0x22
0
1
0
3
0x44
0
0
}
;
static
already_AddRefed
<
MediaRawData
>
GetHVCCSample
(
uint32_t
aSampleSize
)
{
if
(
aSampleSize
<
4
)
{
EXPECT_FALSE
(
true
)
<
<
"
Samples
should
be
requested
with
sane
sizes
"
;
}
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
extradata
-
>
AppendElements
(
sHvccBytesBuffer
std
:
:
size
(
sHvccBytesBuffer
)
)
;
nsTArray
<
uint8_t
>
sampleData
;
ByteWriter
<
BigEndian
>
writer
(
sampleData
)
;
EXPECT_TRUE
(
writer
.
WriteU32
(
aSampleSize
-
4
)
)
;
for
(
uint32_t
idx
=
0
;
idx
<
aSampleSize
-
4
;
idx
+
+
)
{
sampleData
.
AppendElement
(
0
)
;
}
RefPtr
<
MediaRawData
>
rawData
=
new
MediaRawData
{
sampleData
.
Elements
(
)
sampleData
.
Length
(
)
}
;
EXPECT_NE
(
rawData
-
>
Data
(
)
nullptr
)
;
EXPECT_EQ
(
rawData
-
>
Size
(
)
aSampleSize
)
;
rawData
-
>
mExtraData
=
extradata
;
return
rawData
.
forget
(
)
;
}
static
already_AddRefed
<
MediaRawData
>
GetHVCCSample
(
const
uint8_t
*
aData
const
uint32_t
aDataLength
)
{
if
(
aDataLength
<
4
)
{
EXPECT_FALSE
(
true
)
<
<
"
Samples
should
be
requested
with
sane
sizes
"
;
}
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
extradata
-
>
AppendElements
(
sHvccBytesBuffer
std
:
:
size
(
sHvccBytesBuffer
)
)
;
nsTArray
<
uint8_t
>
sampleData
;
ByteWriter
<
BigEndian
>
writer
(
sampleData
)
;
EXPECT_TRUE
(
writer
.
WriteU32
(
aDataLength
)
)
;
sampleData
.
AppendElements
(
aData
aDataLength
)
;
RefPtr
<
MediaRawData
>
rawData
=
new
MediaRawData
{
sampleData
.
Elements
(
)
sampleData
.
Length
(
)
}
;
EXPECT_NE
(
rawData
-
>
Data
(
)
nullptr
)
;
EXPECT_EQ
(
rawData
-
>
Size
(
)
aDataLength
+
4
)
;
rawData
-
>
mExtraData
=
extradata
;
return
rawData
.
forget
(
)
;
}
static
already_AddRefed
<
MediaRawData
>
GetHVCCSamples
(
const
nsTArray
<
Span
<
const
uint8_t
>
>
&
aNALUs
)
{
nsTArray
<
uint8_t
>
data
;
ByteWriter
<
BigEndian
>
writer
(
data
)
;
size_t
totalSize
=
0
;
for
(
const
auto
&
nalu
:
aNALUs
)
{
if
(
nalu
.
size
(
)
<
2
)
{
EXPECT_FALSE
(
true
)
<
<
"
Samples
should
be
requested
with
sane
sizes
"
;
return
nullptr
;
}
totalSize
+
=
nalu
.
size
(
)
;
EXPECT_TRUE
(
writer
.
WriteU32
(
nalu
.
size
(
)
)
)
;
data
.
AppendElements
(
nalu
.
data
(
)
nalu
.
size
(
)
)
;
}
RefPtr
<
MediaRawData
>
rawData
=
new
MediaRawData
{
data
.
Elements
(
)
data
.
Length
(
)
}
;
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
extradata
-
>
AppendElements
(
sHvccBytesBuffer
std
:
:
size
(
sHvccBytesBuffer
)
)
;
rawData
-
>
mExtraData
=
extradata
;
EXPECT_NE
(
rawData
-
>
Data
(
)
nullptr
)
;
EXPECT_EQ
(
rawData
-
>
Size
(
)
totalSize
+
4
*
aNALUs
.
Length
(
)
)
;
return
rawData
.
forget
(
)
;
}
TEST
(
AnnexB
AVCCToAnnexBConversion
)
{
RefPtr
<
MediaRawData
>
rawData
{
GetAvccSample
(
128
)
}
;
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertAVCCSampleToAnnexB
(
rawDataClone
false
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_EQ
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
the
same
size
as
the
AVCC
sample
-
-
the
4
"
"
byte
NAL
length
data
(
AVCC
)
is
replaced
with
4
bytes
of
NAL
"
"
separator
(
AnnexB
)
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
*
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
rawDataClone
-
>
mKeyframe
=
false
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertAVCCSampleToAnnexB
(
rawDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_EQ
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
the
same
size
as
the
AVCC
sample
-
-
the
4
"
"
byte
NAL
length
data
(
AVCC
)
is
replaced
with
4
bytes
of
NAL
"
"
separator
(
AnnexB
)
and
SPS
data
is
not
added
as
the
frame
is
not
a
"
"
keyframe
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
*
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
rawDataClone
-
>
mKeyframe
=
true
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertAVCCSampleToAnnexB
(
rawDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_GT
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
larger
than
the
AVCC
sample
because
we
'
ve
"
"
added
SPS
data
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
*
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
const
uint32_t
sampleSize
=
UINT16_MAX
*
2
;
RefPtr
<
MediaRawData
>
rawCryptoData
{
GetAvccSample
(
sampleSize
)
}
;
rawCryptoData
-
>
mKeyframe
=
true
;
UniquePtr
<
MediaRawDataWriter
>
rawDataWriter
=
rawCryptoData
-
>
CreateWriter
(
)
;
rawDataWriter
-
>
mCrypto
.
mCryptoScheme
=
CryptoScheme
:
:
Cenc
;
const
uint16_t
clearSize
=
UINT16_MAX
-
10
;
rawDataWriter
-
>
mCrypto
.
mPlainSizes
.
AppendElement
(
clearSize
)
;
rawDataWriter
-
>
mCrypto
.
mEncryptedSizes
.
AppendElement
(
sampleSize
-
clearSize
)
;
RefPtr
<
MediaRawData
>
rawCryptoDataClone
=
rawCryptoData
-
>
Clone
(
)
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertAVCCSampleToAnnexB
(
rawCryptoDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_GT
(
rawCryptoDataClone
-
>
Size
(
)
rawCryptoData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
larger
than
the
AVCC
sample
because
we
'
ve
"
"
added
SPS
data
"
;
EXPECT_GT
(
rawCryptoDataClone
-
>
mCrypto
.
mPlainSizes
[
0
]
rawCryptoData
-
>
mCrypto
.
mPlainSizes
[
0
]
)
<
<
"
Conversion
should
have
increased
clear
data
sizes
without
overflow
"
;
EXPECT_EQ
(
rawCryptoDataClone
-
>
mCrypto
.
mEncryptedSizes
[
0
]
rawCryptoData
-
>
mCrypto
.
mEncryptedSizes
[
0
]
)
<
<
"
Conversion
should
not
affect
encrypted
sizes
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
*
rawCryptoDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
}
TEST
(
AnnexB
HVCCToAnnexBConversion
)
{
RefPtr
<
MediaRawData
>
rawData
{
GetHVCCSample
(
128
)
}
;
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertHVCCSampleToAnnexB
(
rawDataClone
false
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_EQ
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
the
same
size
as
the
HVCC
sample
-
-
the
4
"
"
byte
NAL
length
data
(
HVCC
)
is
replaced
with
4
bytes
of
NAL
"
"
separator
(
AnnexB
)
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
*
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
rawDataClone
-
>
mKeyframe
=
false
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertHVCCSampleToAnnexB
(
rawDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_EQ
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
the
same
size
as
the
HVCC
sample
-
-
the
4
"
"
byte
NAL
length
data
(
HVCC
)
is
replaced
with
4
bytes
of
NAL
"
"
separator
(
AnnexB
)
and
SPS
data
is
not
added
as
the
frame
is
not
a
"
"
keyframe
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
*
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
rawDataClone
-
>
mKeyframe
=
true
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertHVCCSampleToAnnexB
(
rawDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_GT
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
larger
than
the
HVCC
sample
because
we
'
ve
"
"
added
SPS
data
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
*
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
const
uint32_t
sampleSize
=
UINT16_MAX
*
2
;
RefPtr
<
MediaRawData
>
rawCryptoData
{
GetHVCCSample
(
sampleSize
)
}
;
rawCryptoData
-
>
mKeyframe
=
true
;
UniquePtr
<
MediaRawDataWriter
>
rawDataWriter
=
rawCryptoData
-
>
CreateWriter
(
)
;
rawDataWriter
-
>
mCrypto
.
mCryptoScheme
=
CryptoScheme
:
:
Cenc
;
const
uint16_t
clearSize
=
UINT16_MAX
-
10
;
rawDataWriter
-
>
mCrypto
.
mPlainSizes
.
AppendElement
(
clearSize
)
;
rawDataWriter
-
>
mCrypto
.
mEncryptedSizes
.
AppendElement
(
sampleSize
-
clearSize
)
;
RefPtr
<
MediaRawData
>
rawCryptoDataClone
=
rawCryptoData
-
>
Clone
(
)
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertHVCCSampleToAnnexB
(
rawCryptoDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_GT
(
rawCryptoDataClone
-
>
Size
(
)
rawCryptoData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
larger
than
the
HVCC
sample
because
we
'
ve
"
"
added
SPS
data
"
;
EXPECT_GT
(
rawCryptoDataClone
-
>
mCrypto
.
mPlainSizes
[
0
]
rawCryptoData
-
>
mCrypto
.
mPlainSizes
[
0
]
)
<
<
"
Conversion
should
have
increased
clear
data
sizes
without
overflow
"
;
EXPECT_EQ
(
rawCryptoDataClone
-
>
mCrypto
.
mEncryptedSizes
[
0
]
rawCryptoData
-
>
mCrypto
.
mEncryptedSizes
[
0
]
)
<
<
"
Conversion
should
not
affect
encrypted
sizes
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
*
rawCryptoDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
}
TEST
(
H264
AVCCParsingSuccess
)
{
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
avccBytesBuffer
[
]
=
{
1
0x64
0
40
0xfc
|
3
0xe0
0
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isOk
(
)
)
;
const
auto
avcc
=
res
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
mConfigurationVersion
1
)
;
EXPECT_EQ
(
avcc
.
mAVCProfileIndication
0x64
)
;
EXPECT_EQ
(
avcc
.
mProfileCompatibility
0
)
;
EXPECT_EQ
(
avcc
.
mAVCLevelIndication
40
)
;
EXPECT_EQ
(
avcc
.
NALUSize
(
)
4
)
;
EXPECT_EQ
(
avcc
.
NumSPS
(
)
0u
)
;
EXPECT_EQ
(
avcc
.
NumPPS
(
)
0u
)
;
EXPECT_TRUE
(
avcc
.
mChromaFormat
.
isNothing
(
)
)
;
EXPECT_TRUE
(
avcc
.
mBitDepthLumaMinus8
.
isNothing
(
)
)
;
EXPECT_TRUE
(
avcc
.
mBitDepthChromaMinus8
.
isNothing
(
)
)
;
EXPECT_EQ
(
avcc
.
NumSPSExt
(
)
0u
)
;
EXPECT_EQ
(
avcc
.
mSPSExts
.
Length
(
)
0u
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
const
uint8_t
avccBytesBuffer
[
]
=
{
0x01
0x64
0x00
0x1E
0xFF
0xE1
0x00
0x04
0x67
0x64
0x00
0x1F
0x01
0x00
0x02
0x68
0xCE
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isOk
(
)
)
;
const
auto
avcc
=
res
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
mConfigurationVersion
1
)
;
EXPECT_EQ
(
avcc
.
mAVCProfileIndication
0x64
)
;
EXPECT_EQ
(
avcc
.
mProfileCompatibility
0
)
;
EXPECT_EQ
(
avcc
.
mAVCLevelIndication
0x1E
)
;
EXPECT_EQ
(
avcc
.
NALUSize
(
)
4
)
;
EXPECT_EQ
(
avcc
.
NumSPS
(
)
1u
)
;
EXPECT_EQ
(
avcc
.
NumPPS
(
)
1u
)
;
EXPECT_TRUE
(
avcc
.
mChromaFormat
.
isNothing
(
)
)
;
EXPECT_TRUE
(
avcc
.
mBitDepthLumaMinus8
.
isNothing
(
)
)
;
EXPECT_TRUE
(
avcc
.
mBitDepthChromaMinus8
.
isNothing
(
)
)
;
EXPECT_EQ
(
avcc
.
NumSPSExt
(
)
0u
)
;
EXPECT_EQ
(
avcc
.
mSPSExts
.
Length
(
)
0u
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
const
uint8_t
avccBytesBuffer
[
]
=
{
0x01
0x64
0x00
0x1E
0xFF
0xE1
0x00
0x04
0x67
0x64
0x00
0x1F
0x01
0x00
0x02
0x68
0xCE
0xFC
0xF8
0xF8
0x01
0x00
0x03
0x6D
0xB2
0x20
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isOk
(
)
)
;
const
auto
avcc
=
res
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
mConfigurationVersion
1
)
;
EXPECT_EQ
(
avcc
.
mAVCProfileIndication
0x64
)
;
EXPECT_EQ
(
avcc
.
mProfileCompatibility
0
)
;
EXPECT_EQ
(
avcc
.
mAVCLevelIndication
0x1E
)
;
EXPECT_EQ
(
avcc
.
NALUSize
(
)
4
)
;
EXPECT_EQ
(
avcc
.
NumSPS
(
)
1u
)
;
EXPECT_EQ
(
avcc
.
NumPPS
(
)
1u
)
;
EXPECT_EQ
(
*
avcc
.
mChromaFormat
0
)
;
EXPECT_EQ
(
*
avcc
.
mBitDepthLumaMinus8
0
)
;
EXPECT_EQ
(
*
avcc
.
mBitDepthChromaMinus8
0
)
;
EXPECT_EQ
(
avcc
.
NumSPSExt
(
)
1u
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
const
uint8_t
avccBytesBuffer
[
]
=
{
0x01
0x64
0x00
0x1E
0xFF
0xE1
0x00
0x01
0x67
0x01
0x00
0x01
0x68
0xFC
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isOk
(
)
)
;
const
auto
avcc
=
res
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
mConfigurationVersion
1
)
;
EXPECT_EQ
(
avcc
.
mAVCProfileIndication
0x64
)
;
EXPECT_EQ
(
avcc
.
mProfileCompatibility
0
)
;
EXPECT_EQ
(
avcc
.
mAVCLevelIndication
0x1E
)
;
EXPECT_EQ
(
avcc
.
NALUSize
(
)
4
)
;
EXPECT_EQ
(
avcc
.
NumSPS
(
)
1u
)
;
EXPECT_EQ
(
avcc
.
NumPPS
(
)
1u
)
;
EXPECT_TRUE
(
avcc
.
mChromaFormat
.
isNothing
(
)
)
;
EXPECT_TRUE
(
avcc
.
mBitDepthLumaMinus8
.
isNothing
(
)
)
;
EXPECT_TRUE
(
avcc
.
mBitDepthChromaMinus8
.
isNothing
(
)
)
;
EXPECT_EQ
(
avcc
.
NumSPSExt
(
)
0u
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
const
uint8_t
avccBytesBuffer
[
]
=
{
0x01
0x64
0x00
0x1E
0xFF
0xE1
0x00
0x01
0x67
0x01
0x00
0x01
0x68
0xFC
0xF8
0xF8
0x01
0x00
0x04
0x6A
0x01
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isOk
(
)
)
;
const
auto
avcc
=
res
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
mConfigurationVersion
1
)
;
EXPECT_EQ
(
avcc
.
mAVCProfileIndication
0x64
)
;
EXPECT_EQ
(
avcc
.
mProfileCompatibility
0
)
;
EXPECT_EQ
(
avcc
.
mAVCLevelIndication
0x1E
)
;
EXPECT_EQ
(
avcc
.
NALUSize
(
)
4
)
;
EXPECT_EQ
(
avcc
.
NumSPS
(
)
1u
)
;
EXPECT_EQ
(
avcc
.
NumPPS
(
)
1u
)
;
EXPECT_EQ
(
*
avcc
.
mChromaFormat
0
)
;
EXPECT_EQ
(
*
avcc
.
mBitDepthLumaMinus8
0
)
;
EXPECT_EQ
(
*
avcc
.
mBitDepthChromaMinus8
0
)
;
EXPECT_EQ
(
avcc
.
NumSPSExt
(
)
0u
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
const
uint8_t
avccBytesBuffer
[
]
=
{
0x01
0x64
0x00
0x1E
0xFF
0xE1
0x00
0x01
0x67
0x01
0x00
0x01
0x68
0xFC
0xF8
0xF8
0x01
0x00
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isOk
(
)
)
;
const
auto
avcc
=
res
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
mConfigurationVersion
1
)
;
EXPECT_EQ
(
avcc
.
mAVCProfileIndication
0x64
)
;
EXPECT_EQ
(
avcc
.
mProfileCompatibility
0
)
;
EXPECT_EQ
(
avcc
.
mAVCLevelIndication
0x1E
)
;
EXPECT_EQ
(
avcc
.
NALUSize
(
)
4
)
;
EXPECT_EQ
(
avcc
.
NumSPS
(
)
1u
)
;
EXPECT_EQ
(
avcc
.
NumPPS
(
)
1u
)
;
EXPECT_EQ
(
*
avcc
.
mChromaFormat
0
)
;
EXPECT_EQ
(
*
avcc
.
mBitDepthLumaMinus8
0
)
;
EXPECT_EQ
(
*
avcc
.
mBitDepthChromaMinus8
0
)
;
EXPECT_EQ
(
avcc
.
NumSPSExt
(
)
0u
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
const
uint8_t
avccBytesBuffer
[
]
=
{
0x01
0x64
0x00
0x1E
0xFF
0xE1
0x00
0x01
0x67
0x01
0x00
0x01
0x68
0xFC
0xF8
0xF8
0x01
0x00
0x03
0x77
0xB2
0x20
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isOk
(
)
)
;
const
auto
avcc
=
res
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
mConfigurationVersion
1
)
;
EXPECT_EQ
(
avcc
.
mAVCProfileIndication
0x64
)
;
EXPECT_EQ
(
avcc
.
mProfileCompatibility
0
)
;
EXPECT_EQ
(
avcc
.
mAVCLevelIndication
0x1E
)
;
EXPECT_EQ
(
avcc
.
NALUSize
(
)
4
)
;
EXPECT_EQ
(
avcc
.
NumSPS
(
)
1u
)
;
EXPECT_EQ
(
avcc
.
NumPPS
(
)
1u
)
;
EXPECT_EQ
(
*
avcc
.
mChromaFormat
0
)
;
EXPECT_EQ
(
*
avcc
.
mBitDepthLumaMinus8
0
)
;
EXPECT_EQ
(
*
avcc
.
mBitDepthChromaMinus8
0
)
;
EXPECT_EQ
(
avcc
.
NumSPSExt
(
)
0u
)
;
}
}
TEST
(
H264
AVCCParsingFailure
)
{
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
avccBytesBuffer
[
]
=
{
2
0x64
0
40
0xfc
|
3
0xe0
0
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
avcc
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
avcc
.
isErr
(
)
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
avccBytesBuffer
[
]
=
{
1
0x64
0
40
0xfc
|
3
0xe0
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
avcc
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
avcc
.
isErr
(
)
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
const
uint8_t
avccBytesBuffer
[
]
=
{
0x01
0x64
0x00
0x1E
0xFF
0xE1
0x00
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isErr
(
)
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
const
uint8_t
avccBytesBuffer
[
]
=
{
0x01
0x64
0x00
0x1E
0xFF
0xE1
0x00
0x04
0x67
0x42
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isErr
(
)
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
const
uint8_t
avccBytesBuffer
[
]
=
{
0x01
0x64
0x00
0x1E
0xFF
0xE1
0x00
0x02
0x55
0xCE
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isErr
(
)
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
const
uint8_t
avccBytesBuffer
[
]
=
{
0x01
0x64
0x00
0x1E
0xFF
0xE1
0x00
0x02
0x67
0x42
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isErr
(
)
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
const
uint8_t
avccBytesBuffer
[
]
=
{
0x01
0x64
0x00
0x1E
0xFF
0xE1
0x00
0x02
0x67
0x42
0x01
0x00
0x03
0x68
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isErr
(
)
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
const
uint8_t
avccBytesBuffer
[
]
=
{
0x01
0x64
0x00
0x1E
0xFF
0xE1
0x00
0x02
0x67
0x42
0x01
0x00
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isErr
(
)
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
const
uint8_t
avccBytesBuffer
[
]
=
{
0x01
0x64
0x00
0x1E
0xFF
0xE1
0x00
0x01
0x67
0x01
0x00
0x01
0x70
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isErr
(
)
)
;
}
}
TEST
(
H264
CreateNewExtraData
)
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
const
uint8_t
avccBytesBuffer
[
]
=
{
0x01
0x64
0x00
0x1E
0xFF
0xE0
0x00
0xFC
0xF8
0xF8
0x00
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
std
:
:
size
(
avccBytesBuffer
)
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isOk
(
)
)
;
auto
avcc
=
res
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
NumSPS
(
)
0u
)
;
EXPECT_EQ
(
avcc
.
NumPPS
(
)
0u
)
;
const
uint8_t
sps
[
]
=
{
0x67
0x64
0x00
0x1F
}
;
H264NALU
spsNALU
=
H264NALU
(
sps
std
:
:
size
(
sps
)
)
;
avcc
.
mSPSs
.
AppendElement
(
spsNALU
)
;
extradata
=
avcc
.
CreateNewExtraData
(
)
;
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isOk
(
)
)
;
avcc
=
res
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
NumSPS
(
)
1u
)
;
EXPECT_EQ
(
avcc
.
NumPPS
(
)
0u
)
;
const
uint8_t
pps
[
]
=
{
0x68
0xCE
}
;
H264NALU
ppsNALU
=
H264NALU
(
pps
std
:
:
size
(
pps
)
)
;
avcc
.
mPPSs
.
AppendElement
(
ppsNALU
)
;
extradata
=
avcc
.
CreateNewExtraData
(
)
;
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isOk
(
)
)
;
avcc
=
res
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
NumSPS
(
)
1u
)
;
EXPECT_EQ
(
avcc
.
NumPPS
(
)
1u
)
;
avcc
.
mSPSs
.
AppendElement
(
spsNALU
)
;
extradata
=
avcc
.
CreateNewExtraData
(
)
;
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isOk
(
)
)
;
avcc
=
res
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
NumSPS
(
)
2u
)
;
EXPECT_EQ
(
avcc
.
NumPPS
(
)
1u
)
;
avcc
.
mPPSs
.
AppendElement
(
ppsNALU
)
;
extradata
=
avcc
.
CreateNewExtraData
(
)
;
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isOk
(
)
)
;
avcc
=
res
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
NumSPS
(
)
2u
)
;
EXPECT_EQ
(
avcc
.
NumPPS
(
)
2u
)
;
EXPECT_EQ
(
*
avcc
.
mChromaFormat
0
)
;
EXPECT_EQ
(
*
avcc
.
mBitDepthLumaMinus8
0
)
;
EXPECT_EQ
(
*
avcc
.
mBitDepthChromaMinus8
0
)
;
avcc
.
mConfigurationVersion
=
5
;
extradata
=
avcc
.
CreateNewExtraData
(
)
;
res
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
res
.
isErr
(
)
)
;
}
TEST
(
H264
AnnexBExtractExtraDataForAVCC
)
{
const
uint8_t
annexBBytesBuffer
[
]
{
0x00
0x00
0x00
0x01
0x67
0x64
0x00
0x1F
0x00
0x00
0x00
0x01
0x68
0xCE
}
;
auto
annexBExtradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
annexBExtradata
-
>
AppendElements
(
annexBBytesBuffer
std
:
:
size
(
annexBBytesBuffer
)
)
;
auto
avccExtradata
=
AnnexB
:
:
ExtractExtraDataForAVCC
(
*
annexBExtradata
)
;
ASSERT_TRUE
(
!
!
avccExtradata
)
;
auto
res
=
AVCCConfig
:
:
Parse
(
avccExtradata
)
;
ASSERT_TRUE
(
res
.
isOk
(
)
)
;
auto
avcc
=
res
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
NumSPS
(
)
1u
)
;
EXPECT_EQ
(
avcc
.
NumSPSExt
(
)
0u
)
;
EXPECT_EQ
(
avcc
.
NumPPS
(
)
1u
)
;
EXPECT_EQ
(
avcc
.
NALUSize
(
)
4
)
;
EXPECT_EQ
(
avcc
.
mConfigurationVersion
1u
)
;
EXPECT_EQ
(
avcc
.
mAVCProfileIndication
100u
)
;
EXPECT_EQ
(
avcc
.
mProfileCompatibility
0u
)
;
EXPECT_EQ
(
avcc
.
mAVCLevelIndication
31u
)
;
}
TEST
(
H265
HVCCParsingSuccess
)
{
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
hvccBytesBuffer
[
]
=
{
1
1
0x60
0
0
0
0x90
0
0
0
0
0
0x5A
0
0
0
1
0
0
0
0
0x0F
0
}
;
extradata
-
>
AppendElements
(
hvccBytesBuffer
std
:
:
size
(
hvccBytesBuffer
)
)
;
auto
rv
=
HVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
;
auto
hvcc
=
rv
.
unwrap
(
)
;
EXPECT_EQ
(
hvcc
.
configurationVersion
1
)
;
EXPECT_EQ
(
hvcc
.
general_profile_space
0
)
;
EXPECT_EQ
(
hvcc
.
general_tier_flag
false
)
;
EXPECT_EQ
(
hvcc
.
general_profile_idc
1
)
;
EXPECT_EQ
(
hvcc
.
general_profile_compatibility_flags
(
uint32_t
)
0x60000000
)
;
EXPECT_EQ
(
hvcc
.
general_constraint_indicator_flags
(
uint64_t
)
0x900000000000
)
;
EXPECT_EQ
(
hvcc
.
general_level_idc
0x5A
)
;
EXPECT_EQ
(
hvcc
.
min_spatial_segmentation_idc
0
)
;
EXPECT_EQ
(
hvcc
.
parallelismType
0
)
;
EXPECT_EQ
(
hvcc
.
chroma_format_idc
1
)
;
EXPECT_EQ
(
hvcc
.
bit_depth_luma_minus8
0
)
;
EXPECT_EQ
(
hvcc
.
bit_depth_chroma_minus8
0
)
;
EXPECT_EQ
(
hvcc
.
avgFrameRate
0
)
;
EXPECT_EQ
(
hvcc
.
constantFrameRate
0
)
;
EXPECT_EQ
(
hvcc
.
numTemporalLayers
1
)
;
EXPECT_EQ
(
hvcc
.
temporalIdNested
true
)
;
EXPECT_EQ
(
hvcc
.
NALUSize
(
)
4
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
.
Length
(
)
uint32_t
(
0
)
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
hvccBytesBuffer
[
]
=
{
1
1
0x60
0
0
0
0x90
0
0
0
0
0
0x5A
0
0
0
1
0
0
0
0
0x0F
2
0x21
0
1
0
8
0x42
0
0
0
0
0
0
0
0x22
0
2
0
3
0x44
0
0
0
3
0x44
0
0
}
;
extradata
-
>
AppendElements
(
hvccBytesBuffer
std
:
:
size
(
hvccBytesBuffer
)
)
;
auto
rv
=
HVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
;
auto
hvcc
=
rv
.
unwrap
(
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
.
Length
(
)
uint32_t
(
3
)
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
SPS_NUT
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNuhLayerId
0
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNuhTemporalIdPlus1
0
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
IsSPS
(
)
true
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNALU
.
Length
(
)
8u
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
1
]
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
PPS_NUT
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
1
]
.
mNuhLayerId
0
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
1
]
.
mNuhTemporalIdPlus1
0
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
1
]
.
IsSPS
(
)
false
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
1
]
.
mNALU
.
Length
(
)
3u
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
2
]
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
PPS_NUT
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
2
]
.
mNuhLayerId
0
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
2
]
.
mNuhTemporalIdPlus1
0
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
2
]
.
IsSPS
(
)
false
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
2
]
.
mNALU
.
Length
(
)
3u
)
;
}
}
TEST
(
H265
HVCCParsingFailure
)
{
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
hvccBytesBuffer
[
]
=
{
2
1
0x60
0
0
0
0x90
0
0
0
0
0
0x5A
0
0
0
1
0
0
0
0
0x0F
0
}
;
extradata
-
>
AppendElements
(
hvccBytesBuffer
std
:
:
size
(
hvccBytesBuffer
)
)
;
auto
avcc
=
HVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
avcc
.
isErr
(
)
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
hvccBytesBuffer
[
]
=
{
1
1
0x60
0
0
0
0x90
0
0
0
0
0
0x5A
}
;
extradata
-
>
AppendElements
(
hvccBytesBuffer
std
:
:
size
(
hvccBytesBuffer
)
)
;
auto
avcc
=
HVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
avcc
.
isErr
(
)
)
;
}
}
TEST
(
H265
HVCCToAnnexB
)
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
hvccBytesBuffer
[
]
=
{
1
1
0x60
0
0
0
0x90
0
0
0
0
0
0x5A
0
0
0
1
0
0
0
0
0x0F
2
0x21
0
1
0
3
0x42
0
0
0x22
0
1
0
3
0x44
0
0
}
;
extradata
-
>
AppendElements
(
hvccBytesBuffer
std
:
:
size
(
hvccBytesBuffer
)
)
;
const
size_t
naluBytesSize
=
3
;
const
size_t
delimiterBytesSize
=
4
;
const
size_t
naluPlusDelimiterBytesSize
=
naluBytesSize
+
delimiterBytesSize
;
RefPtr
<
mozilla
:
:
MediaByteBuffer
>
annexBExtraData
=
AnnexB
:
:
ConvertHVCCExtraDataToAnnexB
(
extradata
)
;
EXPECT_EQ
(
annexBExtraData
-
>
Length
(
)
naluPlusDelimiterBytesSize
*
2
)
;
H265NALU
sps
(
static_cast
<
uint8_t
*
>
(
annexBExtraData
-
>
Elements
(
)
+
delimiterBytesSize
)
naluBytesSize
)
;
EXPECT_EQ
(
sps
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
SPS_NUT
)
;
EXPECT_EQ
(
sps
.
mNuhLayerId
0
)
;
EXPECT_EQ
(
sps
.
mNuhTemporalIdPlus1
0
)
;
EXPECT_EQ
(
sps
.
IsSPS
(
)
true
)
;
EXPECT_EQ
(
sps
.
mNALU
.
Length
(
)
3u
)
;
H265NALU
pps
(
static_cast
<
uint8_t
*
>
(
annexBExtraData
-
>
Elements
(
)
+
naluPlusDelimiterBytesSize
+
delimiterBytesSize
)
naluBytesSize
)
;
EXPECT_EQ
(
pps
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
PPS_NUT
)
;
EXPECT_EQ
(
pps
.
mNuhLayerId
0
)
;
EXPECT_EQ
(
pps
.
mNuhTemporalIdPlus1
0
)
;
EXPECT_EQ
(
pps
.
IsSPS
(
)
false
)
;
EXPECT_EQ
(
pps
.
mNALU
.
Length
(
)
3u
)
;
}
TEST
(
H265
AnnexBToHVCC
)
{
RefPtr
<
MediaRawData
>
rawData
{
GetHVCCSample
(
128
)
}
;
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertHVCCSampleToAnnexB
(
rawDataClone
false
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
HVCC
to
AnnexB
Conversion
should
succeed
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
*
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
auto
rv
=
AnnexB
:
:
ConvertSampleToHVCC
(
rawDataClone
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
<
<
"
AnnexB
to
HVCC
Conversion
should
succeed
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsHVCC
(
rawDataClone
)
)
<
<
"
The
sample
should
be
HVCC
following
conversion
"
;
}
static
const
uint8_t
sSps
[
]
=
{
0x42
0x01
0x01
0x01
0x60
0x00
0x00
0x03
0x00
0x90
0x00
0x00
0x03
0x00
0x00
0x03
0x00
0x5d
0xa0
0x02
0x00
0x80
0x30
0x16
0x59
0x59
0xa4
0x93
0x2b
0xc0
0x5a
0x02
0x00
0x00
0x03
0x00
0x02
0x00
0x00
0x03
0x00
0x3c
0x10
}
;
static
const
uint8_t
sVps
[
]
=
{
0x40
0x01
0x0C
0x01
0xFF
0xFF
0x01
0x60
0x00
0x00
0x03
0x00
0x90
0x00
0x00
0x03
0x00
0x00
0x03
0x00
0x3F
0x95
0x98
0x09
}
;
static
const
uint8_t
sPps
[
]
=
{
0x44
0x01
0xC1
0x72
0xB4
0x62
0x40
}
;
TEST
(
H265
ExtractHVCCExtraData
)
{
RefPtr
<
MediaRawData
>
rawData
{
GetHVCCSample
(
sSps
std
:
:
size
(
sSps
)
)
}
;
RefPtr
<
MediaByteBuffer
>
extradata
=
H265
:
:
ExtractHVCCExtraData
(
rawData
)
;
EXPECT_TRUE
(
extradata
)
;
auto
rv
=
HVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
;
auto
hvcc
=
rv
.
unwrap
(
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
.
Length
(
)
1u
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
SPS_NUT
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNuhLayerId
0u
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNuhTemporalIdPlus1
1
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
IsSPS
(
)
true
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
[
0
]
.
mNALU
.
Length
(
)
43u
)
;
nsTArray
<
Span
<
const
uint8_t
>
>
nalus
;
nalus
.
AppendElement
(
Span
<
const
uint8_t
>
{
sSps
std
:
:
size
(
sSps
)
}
)
;
nalus
.
AppendElement
(
Span
<
const
uint8_t
>
{
sVps
std
:
:
size
(
sVps
)
}
)
;
nalus
.
AppendElement
(
Span
<
const
uint8_t
>
{
sPps
std
:
:
size
(
sPps
)
}
)
;
RefPtr
<
MediaRawData
>
rawData2
{
GetHVCCSamples
(
nalus
)
}
;
RefPtr
<
MediaByteBuffer
>
extradata2
=
H265
:
:
ExtractHVCCExtraData
(
rawData2
)
;
EXPECT_TRUE
(
extradata2
)
;
auto
rv2
=
HVCCConfig
:
:
Parse
(
extradata2
)
;
EXPECT_TRUE
(
rv2
.
isOk
(
)
)
;
auto
hvcc2
=
rv2
.
unwrap
(
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
.
Length
(
)
3u
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
0
]
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
VPS_NUT
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
0
]
.
mNuhLayerId
0u
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
0
]
.
mNuhTemporalIdPlus1
1
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
0
]
.
IsVPS
(
)
true
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
0
]
.
mNALU
.
Length
(
)
std
:
:
size
(
sVps
)
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
1
]
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
SPS_NUT
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
1
]
.
mNuhLayerId
0u
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
1
]
.
mNuhTemporalIdPlus1
1
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
1
]
.
IsSPS
(
)
true
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
1
]
.
mNALU
.
Length
(
)
std
:
:
size
(
sSps
)
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
2
]
.
mNalUnitType
H265NALU
:
:
NAL_TYPES
:
:
PPS_NUT
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
2
]
.
mNuhLayerId
0u
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
2
]
.
mNuhTemporalIdPlus1
1
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
2
]
.
IsPPS
(
)
true
)
;
EXPECT_EQ
(
hvcc2
.
mNALUs
[
2
]
.
mNALU
.
Length
(
)
std
:
:
size
(
sPps
)
)
;
}
TEST
(
H265
DecodeSPSFromSPSNALU
)
{
H265NALU
nalu
{
sSps
std
:
:
size
(
sSps
)
}
;
auto
rv
=
H265
:
:
DecodeSPSFromSPSNALU
(
nalu
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
;
auto
sps
=
rv
.
unwrap
(
)
;
EXPECT_EQ
(
sps
.
sps_video_parameter_set_id
0u
)
;
EXPECT_EQ
(
sps
.
sps_max_sub_layers_minus1
0u
)
;
EXPECT_EQ
(
sps
.
sps_temporal_id_nesting_flag
1
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_profile_space
0u
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_tier_flag
false
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_profile_idc
1u
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_profile_compatibility_flags
0x60000000u
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_progressive_source_flag
true
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_interlaced_source_flag
false
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_non_packed_constraint_flag
false
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_frame_only_constraint_flag
true
)
;
EXPECT_EQ
(
sps
.
profile_tier_level
.
general_level_idc
93u
)
;
EXPECT_EQ
(
sps
.
sps_seq_parameter_set_id
0u
)
;
EXPECT_EQ
(
sps
.
chroma_format_idc
1u
)
;
EXPECT_EQ
(
sps
.
separate_colour_plane_flag
false
)
;
EXPECT_EQ
(
sps
.
pic_width_in_luma_samples
1024u
)
;
EXPECT_EQ
(
sps
.
pic_height_in_luma_samples
768u
)
;
EXPECT_EQ
(
sps
.
conformance_window_flag
false
)
;
EXPECT_EQ
(
sps
.
bit_depth_luma_minus8
0u
)
;
EXPECT_EQ
(
sps
.
bit_depth_chroma_minus8
0u
)
;
EXPECT_EQ
(
sps
.
log2_max_pic_order_cnt_lsb_minus4
4u
)
;
EXPECT_EQ
(
sps
.
sps_sub_layer_ordering_info_present_flag
true
)
;
EXPECT_EQ
(
sps
.
sps_max_dec_pic_buffering_minus1
[
0
]
4u
)
;
EXPECT_EQ
(
sps
.
sps_max_num_reorder_pics
[
0
]
2u
)
;
EXPECT_EQ
(
sps
.
sps_max_latency_increase_plus1
[
0
]
5u
)
;
EXPECT_EQ
(
sps
.
log2_min_luma_coding_block_size_minus3
0u
)
;
EXPECT_EQ
(
sps
.
log2_diff_max_min_luma_coding_block_size
3u
)
;
EXPECT_EQ
(
sps
.
log2_min_luma_transform_block_size_minus2
0u
)
;
EXPECT_EQ
(
sps
.
log2_diff_max_min_luma_transform_block_size
3u
)
;
EXPECT_EQ
(
sps
.
max_transform_hierarchy_depth_inter
0u
)
;
EXPECT_EQ
(
sps
.
max_transform_hierarchy_depth_inter
0u
)
;
EXPECT_EQ
(
sps
.
pcm_enabled_flag
false
)
;
EXPECT_EQ
(
sps
.
num_short_term_ref_pic_sets
0u
)
;
EXPECT_EQ
(
sps
.
sps_temporal_mvp_enabled_flag
true
)
;
EXPECT_EQ
(
sps
.
strong_intra_smoothing_enabled_flag
true
)
;
EXPECT_TRUE
(
sps
.
vui_parameters
)
;
EXPECT_EQ
(
sps
.
vui_parameters
-
>
video_full_range_flag
false
)
;
EXPECT_EQ
(
sps
.
BitDepthLuma
(
)
8u
)
;
EXPECT_EQ
(
sps
.
BitDepthChroma
(
)
8u
)
;
const
auto
imgSize
=
sps
.
GetImageSize
(
)
;
EXPECT_EQ
(
imgSize
.
Width
(
)
1024
)
;
EXPECT_EQ
(
imgSize
.
Height
(
)
768
)
;
const
auto
disSize
=
sps
.
GetDisplaySize
(
)
;
EXPECT_EQ
(
disSize
imgSize
)
;
EXPECT_EQ
(
sps
.
ColorDepth
(
)
gfx
:
:
ColorDepth
:
:
COLOR_8
)
;
EXPECT_EQ
(
sps
.
ColorSpace
(
)
gfx
:
:
YUVColorSpace
:
:
BT709
)
;
EXPECT_EQ
(
sps
.
IsFullColorRange
(
)
false
)
;
EXPECT_EQ
(
sps
.
ColorPrimaries
(
)
2u
)
;
EXPECT_EQ
(
sps
.
TransferFunction
(
)
2u
)
;
}
TEST
(
H265
SPSIteratorAndCreateNewExtraData
)
{
RefPtr
<
MediaByteBuffer
>
extradata
=
H265
:
:
CreateFakeExtraData
(
)
;
EXPECT_TRUE
(
extradata
)
;
auto
rv
=
HVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
;
auto
hvcc
=
rv
.
unwrap
(
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
.
Length
(
)
3u
)
;
EXPECT_EQ
(
hvcc
.
NumSPS
(
)
1u
)
;
SPSIterator
it
(
hvcc
)
;
auto
*
sps
=
*
it
;
EXPECT_TRUE
(
sps
)
;
auto
spsMaybe
=
hvcc
.
GetFirstAvaiableNALU
(
H265NALU
:
:
NAL_TYPES
:
:
SPS_NUT
)
;
EXPECT_TRUE
(
spsMaybe
)
;
auto
rv1
=
H265
:
:
DecodeSPSFromSPSNALU
(
*
sps
)
;
auto
rv2
=
H265
:
:
DecodeSPSFromSPSNALU
(
spsMaybe
.
ref
(
)
)
;
EXPECT_TRUE
(
rv1
.
isOk
(
)
)
;
EXPECT_TRUE
(
rv2
.
isOk
(
)
)
;
EXPECT_EQ
(
rv1
.
unwrap
(
)
rv2
.
unwrap
(
)
)
;
EXPECT_FALSE
(
*
(
+
+
it
)
)
;
auto
ppsMaybe
=
hvcc
.
GetFirstAvaiableNALU
(
H265NALU
:
:
NAL_TYPES
:
:
PPS_NUT
)
;
EXPECT_TRUE
(
ppsMaybe
)
;
auto
vpsMaybe
=
hvcc
.
GetFirstAvaiableNALU
(
H265NALU
:
:
NAL_TYPES
:
:
VPS_NUT
)
;
EXPECT_TRUE
(
vpsMaybe
)
;
nsTArray
<
H265NALU
>
nalus
;
nalus
.
AppendElement
(
*
spsMaybe
)
;
nalus
.
AppendElement
(
*
ppsMaybe
)
;
nalus
.
AppendElement
(
*
vpsMaybe
)
;
RefPtr
<
MediaByteBuffer
>
newExtradata
=
H265
:
:
CreateNewExtraData
(
hvcc
nalus
)
;
EXPECT_TRUE
(
newExtradata
)
;
auto
rv3
=
HVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
rv3
.
isOk
(
)
)
;
auto
hvcc2
=
rv3
.
unwrap
(
)
;
EXPECT_EQ
(
hvcc
.
mNALUs
.
Length
(
)
hvcc2
.
mNALUs
.
Length
(
)
)
;
EXPECT_EQ
(
hvcc
.
NumSPS
(
)
hvcc2
.
NumSPS
(
)
)
;
}
TEST
(
H265
ConfWindowTest
)
{
static
const
uint8_t
sSpsConfWindow
[
]
=
{
0x42
0x01
0x01
0x01
0x40
0x00
0x00
0x00
0x90
0x00
0x00
0x00
0x00
0x00
0x99
0xA0
0x01
0xE0
0x20
0x02
0x20
0x7C
0x4E
0x59
0x95
0x29
0x08
0x46
0x46
0xFF
0xC3
0x01
0x6A
0x02
0x02
0x02
0x08
0x00
0x00
0x00
0x08
0x00
0x00
0x01
0xE3
0x00
0x2E
0xF2
0x88
0x00
0x02
0x62
0x5A
0x00
0x00
0x13
0x12
0xD0
0x20
}
;
H265NALU
nalu
{
sSpsConfWindow
std
:
:
size
(
sSpsConfWindow
)
}
;
auto
rv
=
H265
:
:
DecodeSPSFromSPSNALU
(
nalu
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
;
auto
sps
=
rv
.
unwrap
(
)
;
EXPECT_EQ
(
sps
.
chroma_format_idc
1u
)
;
EXPECT_EQ
(
sps
.
pic_width_in_luma_samples
3840u
)
;
EXPECT_EQ
(
sps
.
pic_height_in_luma_samples
2176u
)
;
EXPECT_EQ
(
sps
.
conformance_window_flag
true
)
;
EXPECT_EQ
(
sps
.
conf_win_left_offset
0u
)
;
EXPECT_EQ
(
sps
.
conf_win_right_offset
0u
)
;
EXPECT_EQ
(
sps
.
conf_win_top_offset
0u
)
;
EXPECT_EQ
(
sps
.
conf_win_bottom_offset
8u
)
;
const
auto
imgSize
=
sps
.
GetImageSize
(
)
;
EXPECT_EQ
(
imgSize
.
Width
(
)
3840
)
;
EXPECT_EQ
(
imgSize
.
Height
(
)
2160
)
;
const
auto
disSize
=
sps
.
GetDisplaySize
(
)
;
EXPECT_EQ
(
disSize
imgSize
)
;
}
TEST
(
H265
ColorPrimariesTest
)
{
static
const
uint8_t
sSPSColorPrimariesBT2020
[
]
=
{
0x42
0x01
0x01
0x02
0x20
0x00
0x00
0x03
0x00
0xB0
0x00
0x00
0x03
0x00
0x00
0x03
0x00
0xB4
0xA0
0x01
0xF8
0x20
0x02
0xF4
0x4D
0x88
0x17
0xB9
0x16
0x55
0x35
0x09
0x10
0x09
0x00
0x80
}
;
H265NALU
nalu
{
sSPSColorPrimariesBT2020
std
:
:
size
(
sSPSColorPrimariesBT2020
)
}
;
auto
rv
=
H265
:
:
DecodeSPSFromSPSNALU
(
nalu
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
;
auto
sps
=
rv
.
unwrap
(
)
;
EXPECT_EQ
(
sps
.
ColorPrimaries
(
)
9
)
;
}
}
