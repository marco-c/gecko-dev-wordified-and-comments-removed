#
include
"
gtest
/
gtest
.
h
"
#
include
"
AnnexB
.
h
"
#
include
"
ByteWriter
.
h
"
#
include
"
H264
.
h
"
namespace
mozilla
{
static
already_AddRefed
<
MediaByteBuffer
>
GetExtraData
(
)
{
return
H264
:
:
CreateExtraData
(
0x42
0xc0
0x28
{
1280
720
}
)
;
}
static
already_AddRefed
<
MediaRawData
>
GetAvccSample
(
uint32_t
aSampleSize
)
{
if
(
aSampleSize
<
4
)
{
EXPECT_FALSE
(
true
)
<
<
"
Samples
should
be
requested
with
sane
sizes
"
;
}
nsTArray
<
uint8_t
>
sampleData
;
ByteWriter
<
BigEndian
>
writer
(
sampleData
)
;
EXPECT_TRUE
(
writer
.
WriteU32
(
aSampleSize
-
4
)
)
;
sampleData
.
AppendElements
(
static_cast
<
size_t
>
(
aSampleSize
)
-
4
)
;
RefPtr
<
MediaRawData
>
rawData
=
new
MediaRawData
{
sampleData
.
Elements
(
)
sampleData
.
Length
(
)
}
;
EXPECT_NE
(
rawData
-
>
Data
(
)
nullptr
)
;
rawData
-
>
mExtraData
=
GetExtraData
(
)
;
return
rawData
.
forget
(
)
;
}
TEST
(
AnnexB
AnnexBConversion
)
{
RefPtr
<
MediaRawData
>
rawData
{
GetAvccSample
(
128
)
}
;
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertSampleToAnnexB
(
rawDataClone
false
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_EQ
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
the
same
size
as
the
AVCC
sample
-
-
the
4
"
"
byte
NAL
length
data
(
AVCC
)
is
replaced
with
4
bytes
of
NAL
"
"
separator
(
AnnexB
)
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
rawDataClone
-
>
mKeyframe
=
false
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertSampleToAnnexB
(
rawDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_EQ
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
the
same
size
as
the
AVCC
sample
-
-
the
4
"
"
byte
NAL
length
data
(
AVCC
)
is
replaced
with
4
bytes
of
NAL
"
"
separator
(
AnnexB
)
and
SPS
data
is
not
added
as
the
frame
is
not
a
"
"
keyframe
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
RefPtr
<
MediaRawData
>
rawDataClone
=
rawData
-
>
Clone
(
)
;
rawDataClone
-
>
mKeyframe
=
true
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertSampleToAnnexB
(
rawDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_GT
(
rawDataClone
-
>
Size
(
)
rawData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
larger
than
the
AVCC
sample
because
we
'
ve
"
"
added
SPS
data
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
rawDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
{
const
uint32_t
sampleSize
=
UINT16_MAX
*
2
;
RefPtr
<
MediaRawData
>
rawCryptoData
{
GetAvccSample
(
sampleSize
)
}
;
rawCryptoData
-
>
mKeyframe
=
true
;
UniquePtr
<
MediaRawDataWriter
>
rawDataWriter
=
rawCryptoData
-
>
CreateWriter
(
)
;
rawDataWriter
-
>
mCrypto
.
mCryptoScheme
=
CryptoScheme
:
:
Cenc
;
const
uint16_t
clearSize
=
UINT16_MAX
-
10
;
rawDataWriter
-
>
mCrypto
.
mPlainSizes
.
AppendElement
(
clearSize
)
;
rawDataWriter
-
>
mCrypto
.
mEncryptedSizes
.
AppendElement
(
sampleSize
-
clearSize
)
;
RefPtr
<
MediaRawData
>
rawCryptoDataClone
=
rawCryptoData
-
>
Clone
(
)
;
Result
<
Ok
nsresult
>
result
=
AnnexB
:
:
ConvertSampleToAnnexB
(
rawCryptoDataClone
true
)
;
EXPECT_TRUE
(
result
.
isOk
(
)
)
<
<
"
Conversion
should
succeed
"
;
EXPECT_GT
(
rawCryptoDataClone
-
>
Size
(
)
rawCryptoData
-
>
Size
(
)
)
<
<
"
AnnexB
sample
should
be
larger
than
the
AVCC
sample
because
we
'
ve
"
"
added
SPS
data
"
;
EXPECT_GT
(
rawCryptoDataClone
-
>
mCrypto
.
mPlainSizes
[
0
]
rawCryptoData
-
>
mCrypto
.
mPlainSizes
[
0
]
)
<
<
"
Conversion
should
have
increased
clear
data
sizes
without
overflow
"
;
EXPECT_EQ
(
rawCryptoDataClone
-
>
mCrypto
.
mEncryptedSizes
[
0
]
rawCryptoData
-
>
mCrypto
.
mEncryptedSizes
[
0
]
)
<
<
"
Conversion
should
not
affect
encrypted
sizes
"
;
EXPECT_TRUE
(
AnnexB
:
:
IsAnnexB
(
rawCryptoDataClone
)
)
<
<
"
The
sample
should
be
AnnexB
following
conversion
"
;
}
}
TEST
(
H264
AVCCParsingSuccess
)
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
avccBytesBuffer
[
]
=
{
1
0x64
0
40
0xfc
|
3
0xe0
0
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
ArrayLength
(
avccBytesBuffer
)
)
;
auto
rv
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
rv
.
isOk
(
)
)
;
const
auto
avcc
=
rv
.
unwrap
(
)
;
EXPECT_EQ
(
avcc
.
mConfigurationVersion
1
)
;
EXPECT_EQ
(
avcc
.
mAVCProfileIndication
0x64
)
;
EXPECT_EQ
(
avcc
.
mProfileCompatibility
0
)
;
EXPECT_EQ
(
avcc
.
mAVCLevelIndication
40
)
;
EXPECT_EQ
(
avcc
.
NALUSize
(
)
4
)
;
EXPECT_EQ
(
avcc
.
mNumSPS
0
)
;
}
TEST
(
H264
AVCCParsingFailure
)
{
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
avccBytesBuffer
[
]
=
{
2
0x64
0
40
0xfc
|
3
0xe0
0
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
ArrayLength
(
avccBytesBuffer
)
)
;
auto
avcc
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
avcc
.
isErr
(
)
)
;
}
{
auto
extradata
=
MakeRefPtr
<
mozilla
:
:
MediaByteBuffer
>
(
)
;
uint8_t
avccBytesBuffer
[
]
=
{
1
0x64
0
40
0xfc
|
3
0xe0
}
;
extradata
-
>
AppendElements
(
avccBytesBuffer
ArrayLength
(
avccBytesBuffer
)
)
;
auto
avcc
=
AVCCConfig
:
:
Parse
(
extradata
)
;
EXPECT_TRUE
(
avcc
.
isErr
(
)
)
;
}
}
}
