#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
BitReader
.
h
"
#
include
"
BufferReader
.
h
"
#
include
"
ByteWriter
.
h
"
#
include
"
AnnexB
.
h
"
#
include
"
H264
.
h
"
#
include
<
limits
>
#
include
<
cmath
>
#
define
READSE
(
var
min
max
)
\
{
\
int32_t
val
=
br
.
ReadSE
(
)
;
\
if
(
val
<
min
|
|
val
>
max
)
{
\
return
false
;
\
}
\
aDest
.
var
=
val
;
\
}
#
define
READUE
(
var
max
)
\
{
\
uint32_t
uval
=
br
.
ReadUE
(
)
;
\
if
(
uval
>
max
)
{
\
return
false
;
\
}
\
aDest
.
var
=
uval
;
\
}
namespace
mozilla
{
static
const
uint8_t
Default_4x4_Intra
[
16
]
=
{
6
13
13
20
20
20
28
28
28
28
32
32
32
37
37
42
}
;
static
const
uint8_t
Default_4x4_Inter
[
16
]
=
{
10
14
14
20
20
20
24
24
24
24
27
27
27
30
30
34
}
;
static
const
uint8_t
Default_8x8_Intra
[
64
]
=
{
6
10
10
13
11
13
16
16
16
16
18
18
18
18
18
23
23
23
23
23
23
25
25
25
25
25
25
25
27
27
27
27
27
27
27
27
29
29
29
29
29
29
29
31
31
31
31
31
31
33
33
33
33
33
36
36
36
36
38
38
38
40
40
42
}
;
static
const
uint8_t
Default_8x8_Inter
[
64
]
=
{
9
13
13
15
13
15
17
17
17
17
19
19
19
19
19
21
21
21
21
21
21
22
22
22
22
22
22
22
24
24
24
24
24
24
24
24
25
25
25
25
25
25
25
27
27
27
27
27
27
28
28
28
28
28
30
30
30
30
32
32
32
33
33
35
}
;
namespace
detail
{
static
void
scaling_list
(
BitReader
&
aBr
uint8_t
*
aScalingList
int
aSizeOfScalingList
const
uint8_t
*
aDefaultList
const
uint8_t
*
aFallbackList
)
{
int32_t
lastScale
=
8
;
int32_t
nextScale
=
8
;
int32_t
deltaScale
;
if
(
!
aBr
.
ReadBit
(
)
)
{
if
(
aFallbackList
)
{
memcpy
(
aScalingList
aFallbackList
aSizeOfScalingList
)
;
}
return
;
}
for
(
int
i
=
0
;
i
<
aSizeOfScalingList
;
i
+
+
)
{
if
(
nextScale
!
=
0
)
{
deltaScale
=
aBr
.
ReadSE
(
)
;
nextScale
=
(
lastScale
+
deltaScale
+
256
)
%
256
;
if
(
!
i
&
&
!
nextScale
)
{
memcpy
(
aScalingList
aDefaultList
aSizeOfScalingList
)
;
return
;
}
}
aScalingList
[
i
]
=
(
nextScale
=
=
0
)
?
lastScale
:
nextScale
;
lastScale
=
aScalingList
[
i
]
;
}
}
}
template
<
size_t
N
>
static
void
scaling_list
(
BitReader
&
aBr
uint8_t
(
&
aScalingList
)
[
N
]
const
uint8_t
(
&
aDefaultList
)
[
N
]
const
uint8_t
(
&
aFallbackList
)
[
N
]
)
{
detail
:
:
scaling_list
(
aBr
aScalingList
N
aDefaultList
aFallbackList
)
;
}
template
<
size_t
N
>
static
void
scaling_list
(
BitReader
&
aBr
uint8_t
(
&
aScalingList
)
[
N
]
const
uint8_t
(
&
aDefaultList
)
[
N
]
)
{
detail
:
:
scaling_list
(
aBr
aScalingList
N
aDefaultList
nullptr
)
;
}
SPSData
:
:
SPSData
(
)
{
PodZero
(
this
)
;
chroma_format_idc
=
1
;
video_format
=
5
;
colour_primaries
=
2
;
transfer_characteristics
=
2
;
sample_ratio
=
1
.
0
;
memset
(
scaling_matrix4x4
16
sizeof
(
scaling_matrix4x4
)
)
;
memset
(
scaling_matrix8x8
16
sizeof
(
scaling_matrix8x8
)
)
;
}
bool
SPSData
:
:
operator
=
=
(
const
SPSData
&
aOther
)
const
{
return
this
-
>
valid
&
&
aOther
.
valid
&
&
!
memcmp
(
this
&
aOther
sizeof
(
SPSData
)
)
;
}
bool
SPSData
:
:
operator
!
=
(
const
SPSData
&
aOther
)
const
{
return
!
(
operator
=
=
(
aOther
)
)
;
}
class
SPSNAL
{
public
:
SPSNAL
(
const
uint8_t
*
aPtr
size_t
aLength
)
{
MOZ_ASSERT
(
aPtr
)
;
if
(
aLength
=
=
0
|
|
(
*
aPtr
&
0x1f
)
!
=
H264_NAL_SPS
)
{
return
;
}
mDecodedNAL
=
H264
:
:
DecodeNALUnit
(
aPtr
aLength
)
;
if
(
mDecodedNAL
)
{
mLength
=
BitReader
:
:
GetBitLength
(
mDecodedNAL
)
;
}
}
SPSNAL
(
)
{
}
bool
IsValid
(
)
const
{
return
mDecodedNAL
;
}
bool
operator
=
=
(
const
SPSNAL
&
aOther
)
const
{
if
(
!
mDecodedNAL
|
|
!
aOther
.
mDecodedNAL
)
{
return
false
;
}
SPSData
decodedSPS1
;
SPSData
decodedSPS2
;
if
(
!
GetSPSData
(
decodedSPS1
)
|
|
!
aOther
.
GetSPSData
(
decodedSPS2
)
)
{
if
(
mLength
!
=
aOther
.
mLength
)
{
return
false
;
}
MOZ_ASSERT
(
mLength
/
8
<
=
mDecodedNAL
-
>
Length
(
)
)
;
if
(
memcmp
(
mDecodedNAL
-
>
Elements
(
)
aOther
.
mDecodedNAL
-
>
Elements
(
)
mLength
/
8
)
)
{
return
false
;
}
uint32_t
remaining
=
mLength
-
(
mLength
&
~
7
)
;
BitReader
b1
(
mDecodedNAL
-
>
Elements
(
)
+
mLength
/
8
remaining
)
;
BitReader
b2
(
aOther
.
mDecodedNAL
-
>
Elements
(
)
+
mLength
/
8
remaining
)
;
for
(
uint32_t
i
=
0
;
i
<
remaining
;
i
+
+
)
{
if
(
b1
.
ReadBit
(
)
!
=
b2
.
ReadBit
(
)
)
{
return
false
;
}
}
return
true
;
}
return
decodedSPS1
=
=
decodedSPS2
;
}
bool
operator
!
=
(
const
SPSNAL
&
aOther
)
const
{
return
!
(
operator
=
=
(
aOther
)
)
;
}
bool
GetSPSData
(
SPSData
&
aDest
)
const
{
return
H264
:
:
DecodeSPS
(
mDecodedNAL
aDest
)
;
}
private
:
RefPtr
<
mozilla
:
:
MediaByteBuffer
>
mDecodedNAL
;
uint32_t
mLength
=
0
;
}
;
class
SPSNALIterator
{
public
:
explicit
SPSNALIterator
(
const
mozilla
:
:
MediaByteBuffer
*
aExtraData
)
:
mExtraDataPtr
(
aExtraData
-
>
Elements
(
)
)
mReader
(
aExtraData
)
{
if
(
!
mReader
.
Read
(
5
)
)
{
return
;
}
auto
res
=
mReader
.
ReadU8
(
)
;
mNumSPS
=
res
.
isOk
(
)
?
res
.
unwrap
(
)
&
0x1f
:
0
;
if
(
mNumSPS
=
=
0
)
{
return
;
}
mValid
=
true
;
}
SPSNALIterator
&
operator
+
+
(
)
{
if
(
mEOS
|
|
!
mValid
)
{
return
*
this
;
}
if
(
-
-
mNumSPS
=
=
0
)
{
mEOS
=
true
;
}
auto
res
=
mReader
.
ReadU16
(
)
;
uint16_t
length
=
res
.
isOk
(
)
?
res
.
unwrap
(
)
:
0
;
if
(
length
=
=
0
|
|
!
mReader
.
Read
(
length
)
)
{
mEOS
=
true
;
}
return
*
this
;
}
explicit
operator
bool
(
)
const
{
return
mValid
&
&
!
mEOS
;
}
SPSNAL
operator
*
(
)
const
{
MOZ_ASSERT
(
bool
(
*
this
)
)
;
BufferReader
reader
(
mExtraDataPtr
+
mReader
.
Offset
(
)
mReader
.
Remaining
(
)
)
;
auto
res
=
reader
.
ReadU16
(
)
;
uint16_t
length
=
res
.
isOk
(
)
?
res
.
unwrap
(
)
:
0
;
const
uint8_t
*
ptr
=
reader
.
Read
(
length
)
;
if
(
!
ptr
|
|
!
length
)
{
return
SPSNAL
(
)
;
}
return
SPSNAL
(
ptr
length
)
;
}
private
:
const
uint8_t
*
mExtraDataPtr
;
BufferReader
mReader
;
bool
mValid
=
false
;
bool
mEOS
=
false
;
uint8_t
mNumSPS
=
0
;
}
;
already_AddRefed
<
mozilla
:
:
MediaByteBuffer
>
H264
:
:
DecodeNALUnit
(
const
uint8_t
*
aNAL
size_t
aLength
)
{
MOZ_ASSERT
(
aNAL
)
;
if
(
aLength
<
4
)
{
return
nullptr
;
}
RefPtr
<
mozilla
:
:
MediaByteBuffer
>
rbsp
=
new
mozilla
:
:
MediaByteBuffer
;
BufferReader
reader
(
aNAL
aLength
)
;
auto
res
=
reader
.
ReadU8
(
)
;
if
(
res
.
isErr
(
)
)
{
return
nullptr
;
}
uint8_t
nal_unit_type
=
res
.
unwrap
(
)
&
0x1f
;
uint32_t
nalUnitHeaderBytes
=
1
;
if
(
nal_unit_type
=
=
H264_NAL_PREFIX
|
|
nal_unit_type
=
=
H264_NAL_SLICE_EXT
|
|
nal_unit_type
=
=
H264_NAL_SLICE_EXT_DVC
)
{
bool
svc_extension_flag
=
false
;
bool
avc_3d_extension_flag
=
false
;
if
(
nal_unit_type
!
=
H264_NAL_SLICE_EXT_DVC
)
{
res
=
reader
.
PeekU8
(
)
;
if
(
res
.
isErr
(
)
)
{
return
nullptr
;
}
svc_extension_flag
=
res
.
unwrap
(
)
&
0x80
;
}
else
{
res
=
reader
.
PeekU8
(
)
;
if
(
res
.
isErr
(
)
)
{
return
nullptr
;
}
avc_3d_extension_flag
=
res
.
unwrap
(
)
&
0x80
;
}
if
(
svc_extension_flag
)
{
nalUnitHeaderBytes
+
=
3
;
}
else
if
(
avc_3d_extension_flag
)
{
nalUnitHeaderBytes
+
=
2
;
}
else
{
nalUnitHeaderBytes
+
=
3
;
}
}
if
(
!
reader
.
Read
(
nalUnitHeaderBytes
-
1
)
)
{
return
nullptr
;
}
uint32_t
lastbytes
=
0xffff
;
while
(
reader
.
Remaining
(
)
)
{
auto
res
=
reader
.
ReadU8
(
)
;
if
(
res
.
isErr
(
)
)
{
return
nullptr
;
}
uint8_t
byte
=
res
.
unwrap
(
)
;
if
(
(
lastbytes
&
0xffff
)
=
=
0
&
&
byte
=
=
0x03
)
{
lastbytes
=
0xffff
;
}
else
{
rbsp
-
>
AppendElement
(
byte
)
;
}
lastbytes
=
(
lastbytes
<
<
8
)
|
byte
;
}
return
rbsp
.
forget
(
)
;
}
static
int32_t
ConditionDimension
(
float
aValue
)
{
if
(
aValue
>
1
.
0
&
&
aValue
<
=
INT32_MAX
)
return
int32_t
(
aValue
)
;
return
0
;
}
bool
H264
:
:
DecodeSPS
(
const
mozilla
:
:
MediaByteBuffer
*
aSPS
SPSData
&
aDest
)
{
if
(
!
aSPS
)
{
return
false
;
}
BitReader
br
(
aSPS
BitReader
:
:
GetBitLength
(
aSPS
)
)
;
aDest
.
profile_idc
=
br
.
ReadBits
(
8
)
;
aDest
.
constraint_set0_flag
=
br
.
ReadBit
(
)
;
aDest
.
constraint_set1_flag
=
br
.
ReadBit
(
)
;
aDest
.
constraint_set2_flag
=
br
.
ReadBit
(
)
;
aDest
.
constraint_set3_flag
=
br
.
ReadBit
(
)
;
aDest
.
constraint_set4_flag
=
br
.
ReadBit
(
)
;
aDest
.
constraint_set5_flag
=
br
.
ReadBit
(
)
;
br
.
ReadBits
(
2
)
;
aDest
.
level_idc
=
br
.
ReadBits
(
8
)
;
READUE
(
seq_parameter_set_id
MAX_SPS_COUNT
-
1
)
;
if
(
aDest
.
profile_idc
=
=
100
|
|
aDest
.
profile_idc
=
=
110
|
|
aDest
.
profile_idc
=
=
122
|
|
aDest
.
profile_idc
=
=
244
|
|
aDest
.
profile_idc
=
=
44
|
|
aDest
.
profile_idc
=
=
83
|
|
aDest
.
profile_idc
=
=
86
|
|
aDest
.
profile_idc
=
=
118
|
|
aDest
.
profile_idc
=
=
128
|
|
aDest
.
profile_idc
=
=
138
|
|
aDest
.
profile_idc
=
=
139
|
|
aDest
.
profile_idc
=
=
134
)
{
READUE
(
chroma_format_idc
3
)
;
if
(
aDest
.
chroma_format_idc
=
=
3
)
{
aDest
.
separate_colour_plane_flag
=
br
.
ReadBit
(
)
;
}
READUE
(
bit_depth_luma_minus8
6
)
;
READUE
(
bit_depth_chroma_minus8
6
)
;
br
.
ReadBit
(
)
;
aDest
.
seq_scaling_matrix_present_flag
=
br
.
ReadBit
(
)
;
if
(
aDest
.
seq_scaling_matrix_present_flag
)
{
scaling_list
(
br
aDest
.
scaling_matrix4x4
[
0
]
Default_4x4_Intra
Default_4x4_Intra
)
;
scaling_list
(
br
aDest
.
scaling_matrix4x4
[
1
]
Default_4x4_Intra
aDest
.
scaling_matrix4x4
[
0
]
)
;
scaling_list
(
br
aDest
.
scaling_matrix4x4
[
2
]
Default_4x4_Intra
aDest
.
scaling_matrix4x4
[
1
]
)
;
scaling_list
(
br
aDest
.
scaling_matrix4x4
[
3
]
Default_4x4_Inter
Default_4x4_Inter
)
;
scaling_list
(
br
aDest
.
scaling_matrix4x4
[
4
]
Default_4x4_Inter
aDest
.
scaling_matrix4x4
[
3
]
)
;
scaling_list
(
br
aDest
.
scaling_matrix4x4
[
5
]
Default_4x4_Inter
aDest
.
scaling_matrix4x4
[
4
]
)
;
scaling_list
(
br
aDest
.
scaling_matrix8x8
[
0
]
Default_8x8_Intra
Default_8x8_Intra
)
;
scaling_list
(
br
aDest
.
scaling_matrix8x8
[
1
]
Default_8x8_Inter
Default_8x8_Inter
)
;
if
(
aDest
.
chroma_format_idc
=
=
3
)
{
scaling_list
(
br
aDest
.
scaling_matrix8x8
[
2
]
Default_8x8_Intra
aDest
.
scaling_matrix8x8
[
0
]
)
;
scaling_list
(
br
aDest
.
scaling_matrix8x8
[
3
]
Default_8x8_Inter
aDest
.
scaling_matrix8x8
[
1
]
)
;
scaling_list
(
br
aDest
.
scaling_matrix8x8
[
4
]
Default_8x8_Intra
aDest
.
scaling_matrix8x8
[
2
]
)
;
scaling_list
(
br
aDest
.
scaling_matrix8x8
[
5
]
Default_8x8_Inter
aDest
.
scaling_matrix8x8
[
3
]
)
;
}
}
}
else
if
(
aDest
.
profile_idc
=
=
183
)
{
aDest
.
chroma_format_idc
=
0
;
}
else
{
aDest
.
chroma_format_idc
=
1
;
}
READUE
(
log2_max_frame_num
12
)
;
aDest
.
log2_max_frame_num
+
=
4
;
READUE
(
pic_order_cnt_type
2
)
;
if
(
aDest
.
pic_order_cnt_type
=
=
0
)
{
READUE
(
log2_max_pic_order_cnt_lsb
12
)
;
aDest
.
log2_max_pic_order_cnt_lsb
+
=
4
;
}
else
if
(
aDest
.
pic_order_cnt_type
=
=
1
)
{
aDest
.
delta_pic_order_always_zero_flag
=
br
.
ReadBit
(
)
;
READSE
(
offset_for_non_ref_pic
-
231
230
)
;
READSE
(
offset_for_top_to_bottom_field
-
231
230
)
;
uint32_t
num_ref_frames_in_pic_order_cnt_cycle
=
br
.
ReadUE
(
)
;
for
(
uint32_t
i
=
0
;
i
<
num_ref_frames_in_pic_order_cnt_cycle
;
i
+
+
)
{
br
.
ReadSE
(
)
;
}
}
aDest
.
max_num_ref_frames
=
br
.
ReadUE
(
)
;
aDest
.
gaps_in_frame_num_allowed_flag
=
br
.
ReadBit
(
)
;
aDest
.
pic_width_in_mbs
=
br
.
ReadUE
(
)
+
1
;
aDest
.
pic_height_in_map_units
=
br
.
ReadUE
(
)
+
1
;
aDest
.
frame_mbs_only_flag
=
br
.
ReadBit
(
)
;
if
(
!
aDest
.
frame_mbs_only_flag
)
{
aDest
.
pic_height_in_map_units
*
=
2
;
aDest
.
mb_adaptive_frame_field_flag
=
br
.
ReadBit
(
)
;
}
aDest
.
direct_8x8_inference_flag
=
br
.
ReadBit
(
)
;
aDest
.
frame_cropping_flag
=
br
.
ReadBit
(
)
;
if
(
aDest
.
frame_cropping_flag
)
{
aDest
.
frame_crop_left_offset
=
br
.
ReadUE
(
)
;
aDest
.
frame_crop_right_offset
=
br
.
ReadUE
(
)
;
aDest
.
frame_crop_top_offset
=
br
.
ReadUE
(
)
;
aDest
.
frame_crop_bottom_offset
=
br
.
ReadUE
(
)
;
}
aDest
.
sample_ratio
=
1
.
0f
;
aDest
.
vui_parameters_present_flag
=
br
.
ReadBit
(
)
;
if
(
aDest
.
vui_parameters_present_flag
)
{
if
(
!
vui_parameters
(
br
aDest
)
)
{
return
false
;
}
}
uint8_t
ChromaArrayType
=
aDest
.
separate_colour_plane_flag
?
0
:
aDest
.
chroma_format_idc
;
uint32_t
CropUnitX
=
1
;
uint32_t
SubWidthC
=
aDest
.
chroma_format_idc
=
=
3
?
1
:
2
;
if
(
ChromaArrayType
!
=
0
)
{
CropUnitX
=
SubWidthC
;
}
uint32_t
CropUnitY
=
2
-
aDest
.
frame_mbs_only_flag
;
uint32_t
SubHeightC
=
aDest
.
chroma_format_idc
<
=
1
?
2
:
1
;
if
(
ChromaArrayType
!
=
0
)
{
CropUnitY
*
=
SubHeightC
;
}
uint32_t
width
=
aDest
.
pic_width_in_mbs
*
16
;
uint32_t
height
=
aDest
.
pic_height_in_map_units
*
16
;
if
(
aDest
.
frame_crop_left_offset
<
=
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
/
4
/
CropUnitX
&
&
aDest
.
frame_crop_right_offset
<
=
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
/
4
/
CropUnitX
&
&
aDest
.
frame_crop_top_offset
<
=
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
/
4
/
CropUnitY
&
&
aDest
.
frame_crop_bottom_offset
<
=
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
/
4
/
CropUnitY
&
&
(
aDest
.
frame_crop_left_offset
+
aDest
.
frame_crop_right_offset
)
*
CropUnitX
<
width
&
&
(
aDest
.
frame_crop_top_offset
+
aDest
.
frame_crop_bottom_offset
)
*
CropUnitY
<
height
)
{
aDest
.
crop_left
=
aDest
.
frame_crop_left_offset
*
CropUnitX
;
aDest
.
crop_right
=
aDest
.
frame_crop_right_offset
*
CropUnitX
;
aDest
.
crop_top
=
aDest
.
frame_crop_top_offset
*
CropUnitY
;
aDest
.
crop_bottom
=
aDest
.
frame_crop_bottom_offset
*
CropUnitY
;
}
else
{
aDest
.
crop_left
=
aDest
.
crop_right
=
aDest
.
crop_top
=
aDest
.
crop_bottom
=
0
;
}
aDest
.
pic_width
=
width
-
aDest
.
crop_left
-
aDest
.
crop_right
;
aDest
.
pic_height
=
height
-
aDest
.
crop_top
-
aDest
.
crop_bottom
;
aDest
.
interlaced
=
!
aDest
.
frame_mbs_only_flag
;
if
(
aDest
.
sample_ratio
>
1
.
0
)
{
aDest
.
display_width
=
ConditionDimension
(
aDest
.
pic_width
*
aDest
.
sample_ratio
)
;
aDest
.
display_height
=
aDest
.
pic_height
;
}
else
{
aDest
.
display_width
=
aDest
.
pic_width
;
aDest
.
display_height
=
ConditionDimension
(
aDest
.
pic_height
/
aDest
.
sample_ratio
)
;
}
aDest
.
valid
=
true
;
return
true
;
}
bool
H264
:
:
vui_parameters
(
BitReader
&
aBr
SPSData
&
aDest
)
{
aDest
.
aspect_ratio_info_present_flag
=
aBr
.
ReadBit
(
)
;
if
(
aDest
.
aspect_ratio_info_present_flag
)
{
aDest
.
aspect_ratio_idc
=
aBr
.
ReadBits
(
8
)
;
aDest
.
sar_width
=
aDest
.
sar_height
=
0
;
switch
(
aDest
.
aspect_ratio_idc
)
{
case
0
:
break
;
case
1
:
aDest
.
sample_ratio
=
1
.
0f
;
break
;
case
2
:
aDest
.
sample_ratio
=
12
.
0
/
11
.
0
;
break
;
case
3
:
aDest
.
sample_ratio
=
10
.
0
/
11
.
0
;
break
;
case
4
:
aDest
.
sample_ratio
=
16
.
0
/
11
.
0
;
break
;
case
5
:
aDest
.
sample_ratio
=
40
.
0
/
33
.
0
;
break
;
case
6
:
aDest
.
sample_ratio
=
24
.
0
/
11
.
0
;
break
;
case
7
:
aDest
.
sample_ratio
=
20
.
0
/
11
.
0
;
break
;
case
8
:
aDest
.
sample_ratio
=
32
.
0
/
11
.
0
;
break
;
case
9
:
aDest
.
sample_ratio
=
80
.
0
/
33
.
0
;
break
;
case
10
:
aDest
.
sample_ratio
=
18
.
0
/
11
.
0
;
break
;
case
11
:
aDest
.
sample_ratio
=
15
.
0
/
11
.
0
;
break
;
case
12
:
aDest
.
sample_ratio
=
64
.
0
/
33
.
0
;
break
;
case
13
:
aDest
.
sample_ratio
=
160
.
0
/
99
.
0
;
break
;
case
14
:
aDest
.
sample_ratio
=
4
.
0
/
3
.
0
;
break
;
case
15
:
aDest
.
sample_ratio
=
3
.
2
/
2
.
0
;
break
;
case
16
:
aDest
.
sample_ratio
=
2
.
0
/
1
.
0
;
break
;
case
255
:
aDest
.
sar_width
=
aBr
.
ReadBits
(
16
)
;
aDest
.
sar_height
=
aBr
.
ReadBits
(
16
)
;
if
(
aDest
.
sar_width
&
&
aDest
.
sar_height
)
{
aDest
.
sample_ratio
=
float
(
aDest
.
sar_width
)
/
float
(
aDest
.
sar_height
)
;
}
break
;
default
:
break
;
}
}
if
(
aBr
.
ReadBit
(
)
)
{
aDest
.
overscan_appropriate_flag
=
aBr
.
ReadBit
(
)
;
}
if
(
aBr
.
ReadBit
(
)
)
{
aDest
.
video_format
=
aBr
.
ReadBits
(
3
)
;
aDest
.
video_full_range_flag
=
aBr
.
ReadBit
(
)
;
aDest
.
colour_description_present_flag
=
aBr
.
ReadBit
(
)
;
if
(
aDest
.
colour_description_present_flag
)
{
aDest
.
colour_primaries
=
aBr
.
ReadBits
(
8
)
;
aDest
.
transfer_characteristics
=
aBr
.
ReadBits
(
8
)
;
aDest
.
matrix_coefficients
=
aBr
.
ReadBits
(
8
)
;
}
}
aDest
.
chroma_loc_info_present_flag
=
aBr
.
ReadBit
(
)
;
if
(
aDest
.
chroma_loc_info_present_flag
)
{
BitReader
&
br
=
aBr
;
READUE
(
chroma_sample_loc_type_top_field
5
)
;
READUE
(
chroma_sample_loc_type_bottom_field
5
)
;
}
bool
timing_info_present_flag
=
aBr
.
ReadBit
(
)
;
if
(
timing_info_present_flag
)
{
aBr
.
ReadBits
(
32
)
;
aBr
.
ReadBits
(
32
)
;
aBr
.
ReadBit
(
)
;
}
return
true
;
}
bool
H264
:
:
DecodeSPSFromExtraData
(
const
mozilla
:
:
MediaByteBuffer
*
aExtraData
SPSData
&
aDest
)
{
SPSNALIterator
it
(
aExtraData
)
;
if
(
!
it
)
{
return
false
;
}
return
(
*
it
)
.
GetSPSData
(
aDest
)
;
}
bool
H264
:
:
EnsureSPSIsSane
(
SPSData
&
aSPS
)
{
bool
valid
=
true
;
static
const
float
default_aspect
=
4
.
0f
/
3
.
0f
;
if
(
aSPS
.
sample_ratio
<
=
0
.
0f
|
|
aSPS
.
sample_ratio
>
6
.
0f
)
{
if
(
aSPS
.
pic_width
&
&
aSPS
.
pic_height
)
{
aSPS
.
sample_ratio
=
(
float
)
aSPS
.
pic_width
/
(
float
)
aSPS
.
pic_height
;
}
else
{
aSPS
.
sample_ratio
=
default_aspect
;
}
aSPS
.
display_width
=
aSPS
.
pic_width
;
aSPS
.
display_height
=
aSPS
.
pic_height
;
valid
=
false
;
}
if
(
aSPS
.
max_num_ref_frames
>
16
)
{
aSPS
.
max_num_ref_frames
=
16
;
valid
=
false
;
}
return
valid
;
}
uint32_t
H264
:
:
ComputeMaxRefFrames
(
const
mozilla
:
:
MediaByteBuffer
*
aExtraData
)
{
uint32_t
maxRefFrames
=
4
;
SPSData
spsdata
;
if
(
DecodeSPSFromExtraData
(
aExtraData
spsdata
)
)
{
maxRefFrames
=
std
:
:
min
(
std
:
:
max
(
maxRefFrames
spsdata
.
max_num_ref_frames
+
1
)
16u
)
;
}
return
maxRefFrames
;
}
H264
:
:
FrameType
H264
:
:
GetFrameType
(
const
mozilla
:
:
MediaRawData
*
aSample
)
{
if
(
!
AnnexB
:
:
IsAVCC
(
aSample
)
)
{
return
FrameType
:
:
INVALID
;
}
MOZ_ASSERT
(
aSample
-
>
Data
(
)
)
;
int
nalLenSize
=
(
(
*
aSample
-
>
mExtraData
)
[
4
]
&
3
)
+
1
;
BufferReader
reader
(
aSample
-
>
Data
(
)
aSample
-
>
Size
(
)
)
;
while
(
reader
.
Remaining
(
)
>
=
nalLenSize
)
{
uint32_t
nalLen
=
0
;
switch
(
nalLenSize
)
{
case
1
:
nalLen
=
reader
.
ReadU8
(
)
.
unwrapOr
(
0
)
;
break
;
case
2
:
nalLen
=
reader
.
ReadU16
(
)
.
unwrapOr
(
0
)
;
break
;
case
3
:
nalLen
=
reader
.
ReadU24
(
)
.
unwrapOr
(
0
)
;
break
;
case
4
:
nalLen
=
reader
.
ReadU32
(
)
.
unwrapOr
(
0
)
;
break
;
}
if
(
!
nalLen
)
{
continue
;
}
const
uint8_t
*
p
=
reader
.
Read
(
nalLen
)
;
if
(
!
p
)
{
return
FrameType
:
:
INVALID
;
}
int8_t
nalType
=
*
p
&
0x1f
;
if
(
nalType
=
=
H264_NAL_IDR_SLICE
)
{
return
FrameType
:
:
I_FRAME
;
}
else
if
(
nalType
=
=
H264_NAL_SEI
)
{
RefPtr
<
mozilla
:
:
MediaByteBuffer
>
decodedNAL
=
DecodeNALUnit
(
p
nalLen
)
;
SEIRecoveryData
data
;
if
(
DecodeRecoverySEI
(
decodedNAL
data
)
)
{
return
FrameType
:
:
I_FRAME
;
}
}
}
return
FrameType
:
:
OTHER
;
}
already_AddRefed
<
mozilla
:
:
MediaByteBuffer
>
H264
:
:
ExtractExtraData
(
const
mozilla
:
:
MediaRawData
*
aSample
)
{
MOZ_ASSERT
(
AnnexB
:
:
IsAVCC
(
aSample
)
)
;
RefPtr
<
mozilla
:
:
MediaByteBuffer
>
extradata
=
new
mozilla
:
:
MediaByteBuffer
;
nsTArray
<
uint8_t
>
sps
;
ByteWriter
spsw
(
sps
)
;
int
numSps
=
0
;
nsTArray
<
uint8_t
>
pps
;
ByteWriter
ppsw
(
pps
)
;
int
numPps
=
0
;
int
nalLenSize
=
(
(
*
aSample
-
>
mExtraData
)
[
4
]
&
3
)
+
1
;
size_t
sampleSize
=
aSample
-
>
Size
(
)
;
if
(
aSample
-
>
mCrypto
.
mValid
)
{
MOZ_ASSERT
(
aSample
-
>
mCrypto
.
mPlainSizes
.
Length
(
)
>
0
)
;
if
(
aSample
-
>
mCrypto
.
mPlainSizes
.
Length
(
)
=
=
0
|
|
aSample
-
>
mCrypto
.
mPlainSizes
[
0
]
>
sampleSize
)
{
return
nullptr
;
}
sampleSize
=
aSample
-
>
mCrypto
.
mPlainSizes
[
0
]
;
}
BufferReader
reader
(
aSample
-
>
Data
(
)
sampleSize
)
;
nsTArray
<
SPSData
>
SPSTable
;
bool
checkDuplicate
=
true
;
while
(
reader
.
Remaining
(
)
>
nalLenSize
)
{
uint32_t
nalLen
=
0
;
switch
(
nalLenSize
)
{
case
1
:
Unused
<
<
reader
.
ReadU8
(
)
.
map
(
[
&
]
(
uint8_t
x
)
mutable
{
return
nalLen
=
x
;
}
)
;
break
;
case
2
:
Unused
<
<
reader
.
ReadU16
(
)
.
map
(
[
&
]
(
uint16_t
x
)
mutable
{
return
nalLen
=
x
;
}
)
;
break
;
case
3
:
Unused
<
<
reader
.
ReadU24
(
)
.
map
(
[
&
]
(
uint32_t
x
)
mutable
{
return
nalLen
=
x
;
}
)
;
break
;
case
4
:
Unused
<
<
reader
.
ReadU32
(
)
.
map
(
[
&
]
(
uint32_t
x
)
mutable
{
return
nalLen
=
x
;
}
)
;
break
;
}
const
uint8_t
*
p
=
reader
.
Read
(
nalLen
)
;
if
(
!
p
)
{
return
extradata
.
forget
(
)
;
}
uint8_t
nalType
=
*
p
&
0x1f
;
if
(
nalType
=
=
H264_NAL_SPS
)
{
RefPtr
<
mozilla
:
:
MediaByteBuffer
>
sps
=
DecodeNALUnit
(
p
nalLen
)
;
SPSData
data
;
if
(
!
DecodeSPS
(
sps
data
)
)
{
continue
;
}
uint8_t
spsId
=
data
.
seq_parameter_set_id
;
if
(
spsId
>
=
SPSTable
.
Length
(
)
)
{
if
(
!
SPSTable
.
SetLength
(
spsId
+
1
fallible
)
)
{
return
nullptr
;
}
}
if
(
checkDuplicate
&
&
SPSTable
[
spsId
]
.
valid
&
&
SPSTable
[
spsId
]
=
=
data
)
{
continue
;
}
if
(
SPSTable
[
spsId
]
.
valid
)
{
checkDuplicate
=
false
;
}
else
{
SPSTable
[
spsId
]
=
data
;
}
numSps
+
+
;
if
(
!
spsw
.
WriteU16
(
nalLen
)
|
|
!
spsw
.
Write
(
p
nalLen
)
)
{
return
extradata
.
forget
(
)
;
}
}
else
if
(
nalType
=
=
H264_NAL_PPS
)
{
numPps
+
+
;
if
(
!
ppsw
.
WriteU16
(
nalLen
)
|
|
!
ppsw
.
Write
(
p
nalLen
)
)
{
return
extradata
.
forget
(
)
;
}
}
}
numPps
=
numSps
?
numPps
:
0
;
if
(
numSps
&
&
sps
.
Length
(
)
>
5
)
{
extradata
-
>
AppendElement
(
1
)
;
extradata
-
>
AppendElement
(
sps
[
3
]
)
;
extradata
-
>
AppendElement
(
sps
[
4
]
)
;
extradata
-
>
AppendElement
(
sps
[
5
]
)
;
extradata
-
>
AppendElement
(
0xfc
|
3
)
;
extradata
-
>
AppendElement
(
0xe0
|
numSps
)
;
extradata
-
>
AppendElements
(
sps
.
Elements
(
)
sps
.
Length
(
)
)
;
extradata
-
>
AppendElement
(
numPps
)
;
if
(
numPps
)
{
extradata
-
>
AppendElements
(
pps
.
Elements
(
)
pps
.
Length
(
)
)
;
}
}
return
extradata
.
forget
(
)
;
}
bool
H264
:
:
HasSPS
(
const
mozilla
:
:
MediaByteBuffer
*
aExtraData
)
{
return
NumSPS
(
aExtraData
)
>
0
;
}
uint8_t
H264
:
:
NumSPS
(
const
mozilla
:
:
MediaByteBuffer
*
aExtraData
)
{
if
(
!
aExtraData
|
|
aExtraData
-
>
IsEmpty
(
)
)
{
return
0
;
}
BufferReader
reader
(
aExtraData
)
;
if
(
!
reader
.
Read
(
5
)
)
{
return
0
;
}
auto
res
=
reader
.
ReadU8
(
)
;
if
(
res
.
isErr
(
)
)
{
return
0
;
}
return
res
.
unwrap
(
)
&
0x1f
;
}
bool
H264
:
:
CompareExtraData
(
const
mozilla
:
:
MediaByteBuffer
*
aExtraData1
const
mozilla
:
:
MediaByteBuffer
*
aExtraData2
)
{
if
(
aExtraData1
=
=
aExtraData2
)
{
return
true
;
}
uint8_t
numSPS
=
NumSPS
(
aExtraData1
)
;
if
(
numSPS
=
=
0
|
|
numSPS
!
=
NumSPS
(
aExtraData2
)
)
{
return
false
;
}
SPSNALIterator
it1
(
aExtraData1
)
;
SPSNALIterator
it2
(
aExtraData2
)
;
while
(
it1
&
&
it2
)
{
if
(
*
it1
!
=
*
it2
)
{
return
false
;
}
+
+
it1
;
+
+
it2
;
}
return
true
;
}
static
inline
Result
<
Ok
nsresult
>
ReadSEIInt
(
BufferReader
&
aBr
uint32_t
&
aOutput
)
{
uint8_t
tmpByte
;
aOutput
=
0
;
MOZ_TRY_VAR
(
tmpByte
aBr
.
ReadU8
(
)
)
;
while
(
tmpByte
=
=
0xFF
)
{
aOutput
+
=
255
;
MOZ_TRY_VAR
(
tmpByte
aBr
.
ReadU8
(
)
)
;
}
aOutput
+
=
tmpByte
;
return
Ok
(
)
;
}
bool
H264
:
:
DecodeRecoverySEI
(
const
mozilla
:
:
MediaByteBuffer
*
aSEI
SEIRecoveryData
&
aDest
)
{
if
(
!
aSEI
)
{
return
false
;
}
BufferReader
br
(
aSEI
)
;
do
{
uint32_t
payloadType
=
0
;
if
(
ReadSEIInt
(
br
payloadType
)
.
isErr
(
)
)
{
return
false
;
}
uint32_t
payloadSize
=
0
;
if
(
ReadSEIInt
(
br
payloadSize
)
.
isErr
(
)
)
{
return
false
;
}
const
uint8_t
*
p
=
br
.
Read
(
payloadSize
)
;
if
(
!
p
)
{
return
false
;
}
if
(
payloadType
=
=
6
)
{
if
(
payloadSize
=
=
0
)
{
continue
;
}
BitReader
br
(
p
payloadSize
*
8
)
;
aDest
.
recovery_frame_cnt
=
br
.
ReadUE
(
)
;
aDest
.
exact_match_flag
=
br
.
ReadBit
(
)
;
aDest
.
broken_link_flag
=
br
.
ReadBit
(
)
;
aDest
.
changing_slice_group_idc
=
br
.
ReadBits
(
2
)
;
return
true
;
}
}
while
(
br
.
PeekU8
(
)
.
isOk
(
)
&
&
br
.
PeekU8
(
)
.
unwrap
(
)
!
=
0x80
)
;
return
false
;
}
#
undef
READUE
#
undef
READSE
}
