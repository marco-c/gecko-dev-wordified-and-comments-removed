#
ifndef
mozilla_dom_MPSCQueue_h
#
define
mozilla_dom_MPSCQueue_h
namespace
mozilla
{
const
size_t
MPSC_MSG_RESERVERD
=
sizeof
(
void
*
)
;
template
<
typename
T
>
class
MPSCQueue
{
public
:
struct
Message
{
Message
(
)
{
mNext
.
store
(
nullptr
std
:
:
memory_order_relaxed
)
;
}
Message
(
const
Message
&
aMessage
)
=
delete
;
void
operator
=
(
const
Message
&
aMessage
)
=
delete
;
T
data
;
std
:
:
atomic
<
Message
*
>
mNext
;
}
;
#
if
!
defined
(
XP_WIN
)
&
&
!
defined
(
MOZ_WIDGET_ANDROID
)
static_assert
(
IsPowerOfTwo
(
sizeof
(
MPSCQueue
<
T
>
:
:
Message
)
)
"
MPSCQueue
internal
allocations
must
have
a
size
that
is
a
"
"
power
of
two
"
)
;
#
endif
MPSCQueue
(
)
:
mHead
(
new
Message
(
)
)
mTail
(
mHead
.
load
(
std
:
:
memory_order_relaxed
)
)
{
}
~
MPSCQueue
(
)
{
Message
dummy
;
while
(
Pop
(
&
dummy
.
data
)
)
{
}
Message
*
front
=
mHead
.
load
(
std
:
:
memory_order_relaxed
)
;
delete
front
;
}
void
Push
(
MPSCQueue
<
T
>
:
:
Message
*
aMessage
)
{
Message
*
prev
=
mHead
.
exchange
(
aMessage
std
:
:
memory_order_acq_rel
)
;
prev
-
>
mNext
.
store
(
aMessage
std
:
:
memory_order_release
)
;
}
bool
Pop
(
T
*
aOutput
)
{
Message
*
tail
=
mTail
.
load
(
std
:
:
memory_order_relaxed
)
;
Message
*
next
=
tail
-
>
mNext
.
load
(
std
:
:
memory_order_acquire
)
;
if
(
next
=
=
nullptr
)
{
return
false
;
}
*
aOutput
=
next
-
>
data
;
mTail
.
store
(
next
std
:
:
memory_order_release
)
;
delete
tail
;
return
true
;
}
private
:
std
:
:
atomic
<
Message
*
>
mHead
;
std
:
:
atomic
<
Message
*
>
mTail
;
MPSCQueue
(
const
MPSCQueue
&
)
=
delete
;
void
operator
=
(
const
MPSCQueue
&
)
=
delete
;
}
;
}
#
endif
