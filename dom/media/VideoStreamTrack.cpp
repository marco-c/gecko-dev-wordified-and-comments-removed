#
include
"
VideoStreamTrack
.
h
"
#
include
"
MediaStreamGraph
.
h
"
#
include
"
MediaStreamListener
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
VideoFrameContainer
.
h
"
namespace
mozilla
{
using
layers
:
:
Image
;
using
layers
:
:
ImageContainer
;
using
layers
:
:
PlanarYCbCrData
;
using
layers
:
:
PlanarYCbCrImage
;
static
bool
SetImageToBlackPixel
(
PlanarYCbCrImage
*
aImage
)
{
uint8_t
blackPixel
[
]
=
{
0x10
0x80
0x80
}
;
PlanarYCbCrData
data
;
data
.
mYChannel
=
blackPixel
;
data
.
mCbChannel
=
blackPixel
+
1
;
data
.
mCrChannel
=
blackPixel
+
2
;
data
.
mYStride
=
data
.
mCbCrStride
=
1
;
data
.
mPicSize
=
data
.
mYSize
=
data
.
mCbCrSize
=
gfx
:
:
IntSize
(
1
1
)
;
return
aImage
-
>
CopyData
(
data
)
;
}
class
VideoOutput
:
public
DirectMediaStreamTrackListener
{
protected
:
virtual
~
VideoOutput
(
)
=
default
;
void
DropPastFrames
(
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
size_t
nrChunksInPast
=
0
;
for
(
const
auto
&
idChunkPair
:
mFrames
)
{
const
VideoChunk
&
chunk
=
idChunkPair
.
second
(
)
;
if
(
chunk
.
mTimeStamp
>
now
)
{
break
;
}
+
+
nrChunksInPast
;
}
if
(
nrChunksInPast
>
1
)
{
mFrames
.
RemoveElementsAt
(
0
nrChunksInPast
-
1
)
;
}
}
void
SendFrames
(
)
{
DropPastFrames
(
)
;
if
(
mFrames
.
IsEmpty
(
)
)
{
return
;
}
AutoTArray
<
ImageContainer
:
:
NonOwningImage
16
>
images
;
PrincipalHandle
lastPrincipalHandle
=
PRINCIPAL_HANDLE_NONE
;
for
(
const
auto
&
idChunkPair
:
mFrames
)
{
ImageContainer
:
:
FrameID
frameId
=
idChunkPair
.
first
(
)
;
const
VideoChunk
&
chunk
=
idChunkPair
.
second
(
)
;
const
VideoFrame
&
frame
=
chunk
.
mFrame
;
Image
*
image
=
frame
.
GetImage
(
)
;
if
(
frame
.
GetForceBlack
(
)
)
{
if
(
!
mBlackImage
)
{
RefPtr
<
Image
>
blackImage
=
mVideoFrameContainer
-
>
GetImageContainer
(
)
-
>
CreatePlanarYCbCrImage
(
)
;
if
(
blackImage
)
{
if
(
SetImageToBlackPixel
(
blackImage
-
>
AsPlanarYCbCrImage
(
)
)
)
{
mBlackImage
=
blackImage
;
}
}
}
if
(
mBlackImage
)
{
image
=
mBlackImage
;
}
}
if
(
!
image
)
{
continue
;
}
images
.
AppendElement
(
ImageContainer
:
:
NonOwningImage
(
image
chunk
.
mTimeStamp
frameId
)
)
;
lastPrincipalHandle
=
chunk
.
GetPrincipalHandle
(
)
;
}
if
(
images
.
IsEmpty
(
)
)
{
return
;
}
bool
principalHandleChanged
=
lastPrincipalHandle
!
=
PRINCIPAL_HANDLE_NONE
&
&
lastPrincipalHandle
!
=
mVideoFrameContainer
-
>
GetLastPrincipalHandle
(
)
;
if
(
principalHandleChanged
)
{
mVideoFrameContainer
-
>
UpdatePrincipalHandleForFrameID
(
lastPrincipalHandle
images
.
LastElement
(
)
.
mFrameID
)
;
}
mVideoFrameContainer
-
>
SetCurrentFrames
(
mFrames
[
0
]
.
second
(
)
.
mFrame
.
GetIntrinsicSize
(
)
images
)
;
mMainThread
-
>
Dispatch
(
NewRunnableMethod
(
"
VideoFrameContainer
:
:
Invalidate
"
mVideoFrameContainer
&
VideoFrameContainer
:
:
Invalidate
)
)
;
images
.
ClearAndRetainStorage
(
)
;
}
public
:
VideoOutput
(
VideoFrameContainer
*
aContainer
AbstractThread
*
aMainThread
)
:
mMutex
(
"
VideoOutput
:
:
mMutex
"
)
mVideoFrameContainer
(
aContainer
)
mMainThread
(
aMainThread
)
{
}
void
NotifyRealtimeTrackData
(
MediaStreamGraph
*
aGraph
StreamTime
aTrackOffset
const
MediaSegment
&
aMedia
)
override
{
MOZ_ASSERT
(
aMedia
.
GetType
(
)
=
=
MediaSegment
:
:
VIDEO
)
;
const
VideoSegment
&
video
=
static_cast
<
const
VideoSegment
&
>
(
aMedia
)
;
for
(
VideoSegment
:
:
ConstChunkIterator
i
(
video
)
;
!
i
.
IsEnded
(
)
;
i
.
Next
(
)
)
{
if
(
!
mLastFrameTime
.
IsNull
(
)
&
&
i
-
>
mTimeStamp
<
mLastFrameTime
)
{
mFrames
.
ClearAndRetainStorage
(
)
;
}
mFrames
.
AppendElement
(
MakePair
(
mVideoFrameContainer
-
>
NewFrameID
(
)
*
i
)
)
;
mLastFrameTime
=
i
-
>
mTimeStamp
;
}
SendFrames
(
)
;
}
void
NotifyRemoved
(
)
override
{
mFrames
.
ClearAndRetainStorage
(
)
;
mVideoFrameContainer
-
>
ClearFutureFrames
(
)
;
}
void
NotifyEnded
(
)
override
{
mFrames
.
ClearAndRetainStorage
(
)
;
}
TimeStamp
mLastFrameTime
;
RefPtr
<
Image
>
mBlackImage
;
bool
mEnabled
=
true
;
nsTArray
<
Pair
<
ImageContainer
:
:
FrameID
VideoChunk
>
>
mFrames
;
const
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
const
RefPtr
<
AbstractThread
>
mMainThread
;
}
;
namespace
dom
{
VideoStreamTrack
:
:
VideoStreamTrack
(
DOMMediaStream
*
aStream
TrackID
aTrackID
TrackID
aInputTrackID
MediaStreamTrackSource
*
aSource
const
MediaTrackConstraints
&
aConstraints
)
:
MediaStreamTrack
(
aStream
aTrackID
aInputTrackID
aSource
aConstraints
)
{
}
void
VideoStreamTrack
:
:
Destroy
(
)
{
mVideoOutputs
.
Clear
(
)
;
MediaStreamTrack
:
:
Destroy
(
)
;
}
void
VideoStreamTrack
:
:
AddVideoOutput
(
VideoFrameContainer
*
aSink
)
{
for
(
const
auto
&
output
:
mVideoOutputs
)
{
if
(
output
-
>
mVideoFrameContainer
=
=
aSink
)
{
MOZ_ASSERT_UNREACHABLE
(
"
A
VideoFrameContainer
was
already
added
"
)
;
return
;
}
}
RefPtr
<
VideoOutput
>
&
output
=
*
mVideoOutputs
.
AppendElement
(
MakeRefPtr
<
VideoOutput
>
(
aSink
nsGlobalWindowInner
:
:
Cast
(
GetParentObject
(
)
)
-
>
AbstractMainThreadFor
(
TaskCategory
:
:
Other
)
)
)
;
AddDirectListener
(
output
)
;
AddListener
(
output
)
;
}
void
VideoStreamTrack
:
:
RemoveVideoOutput
(
VideoFrameContainer
*
aSink
)
{
for
(
const
auto
&
output
:
nsTArray
<
RefPtr
<
VideoOutput
>
>
(
mVideoOutputs
)
)
{
if
(
output
-
>
mVideoFrameContainer
=
=
aSink
)
{
mVideoOutputs
.
RemoveElement
(
output
)
;
RemoveDirectListener
(
output
)
;
RemoveListener
(
output
)
;
}
}
}
void
VideoStreamTrack
:
:
GetLabel
(
nsAString
&
aLabel
CallerType
aCallerType
)
{
if
(
nsContentUtils
:
:
ResistFingerprinting
(
aCallerType
)
)
{
aLabel
.
AssignLiteral
(
"
Internal
Camera
"
)
;
return
;
}
MediaStreamTrack
:
:
GetLabel
(
aLabel
aCallerType
)
;
}
}
}
