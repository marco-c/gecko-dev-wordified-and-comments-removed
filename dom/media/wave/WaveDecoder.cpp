#
include
"
WaveDecoder
.
h
"
#
include
"
MediaContainerType
.
h
"
#
include
"
MediaDecoder
.
h
"
namespace
mozilla
{
bool
WaveDecoder
:
:
IsSupportedType
(
const
MediaContainerType
&
aContainerType
)
{
if
(
!
MediaDecoder
:
:
IsWaveEnabled
(
)
)
{
return
false
;
}
if
(
aContainerType
.
Type
(
)
=
=
MEDIAMIMETYPE
(
"
audio
/
wave
"
)
|
|
aContainerType
.
Type
(
)
=
=
MEDIAMIMETYPE
(
"
audio
/
x
-
wav
"
)
|
|
aContainerType
.
Type
(
)
=
=
MEDIAMIMETYPE
(
"
audio
/
wav
"
)
|
|
aContainerType
.
Type
(
)
=
=
MEDIAMIMETYPE
(
"
audio
/
x
-
pn
-
wav
"
)
)
{
return
(
aContainerType
.
ExtendedType
(
)
.
Codecs
(
)
.
IsEmpty
(
)
|
|
aContainerType
.
ExtendedType
(
)
.
Codecs
(
)
=
=
"
1
"
|
|
aContainerType
.
ExtendedType
(
)
.
Codecs
(
)
=
=
"
3
"
|
|
aContainerType
.
ExtendedType
(
)
.
Codecs
(
)
=
=
"
6
"
|
|
aContainerType
.
ExtendedType
(
)
.
Codecs
(
)
=
=
"
7
"
)
;
}
return
false
;
}
nsTArray
<
UniquePtr
<
TrackInfo
>
>
WaveDecoder
:
:
GetTracksInfo
(
const
MediaContainerType
&
aType
)
{
nsTArray
<
UniquePtr
<
TrackInfo
>
>
tracks
;
if
(
!
IsSupportedType
(
aType
)
)
{
return
tracks
;
}
const
MediaCodecs
&
codecs
=
aType
.
ExtendedType
(
)
.
Codecs
(
)
;
if
(
codecs
.
IsEmpty
(
)
)
{
tracks
.
AppendElement
(
CreateTrackInfoWithMIMETypeAndContainerTypeExtraParameters
(
"
audio
/
x
-
wav
"
_ns
aType
)
)
;
return
tracks
;
}
for
(
const
auto
&
codec
:
codecs
.
Range
(
)
)
{
tracks
.
AppendElement
(
CreateTrackInfoWithMIMETypeAndContainerTypeExtraParameters
(
"
audio
/
wave
;
codecs
=
"
_ns
+
NS_ConvertUTF16toUTF8
(
codec
)
aType
)
)
;
}
return
tracks
;
}
}
