#
include
"
MediaInfo
.
h
"
namespace
mozilla
{
typedef
AudioConfig
:
:
ChannelLayout
ChannelLayout
;
void
AudioConfig
:
:
ChannelLayout
:
:
UpdateChannelMap
(
)
{
mChannelMap
=
0
;
mValid
=
mChannels
.
Length
(
)
<
=
MAX_AUDIO_CHANNELS
;
for
(
size_t
i
=
0
;
i
<
mChannels
.
Length
(
)
&
&
i
<
=
MAX_AUDIO_CHANNELS
;
i
+
+
)
{
uint32_t
mask
=
1
<
<
mChannels
[
i
]
;
if
(
mChannels
[
i
]
=
=
CHANNEL_INVALID
|
|
(
mChannelMap
&
mask
)
)
{
mValid
=
false
;
}
mChannelMap
|
=
mask
;
}
}
const
AudioConfig
:
:
Channel
*
AudioConfig
:
:
ChannelLayout
:
:
SMPTEDefault
(
uint32_t
aChannels
)
const
{
switch
(
aChannels
)
{
case
1
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_MONO
}
;
return
config
;
}
case
2
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_LEFT
CHANNEL_RIGHT
}
;
return
config
;
}
case
3
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_LEFT
CHANNEL_RIGHT
CHANNEL_CENTER
}
;
return
config
;
}
case
4
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_LEFT
CHANNEL_RIGHT
CHANNEL_LS
CHANNEL_RS
}
;
return
config
;
}
case
5
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_LEFT
CHANNEL_RIGHT
CHANNEL_CENTER
CHANNEL_LS
CHANNEL_RS
}
;
return
config
;
}
case
6
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_LEFT
CHANNEL_RIGHT
CHANNEL_CENTER
CHANNEL_LFE
CHANNEL_LS
CHANNEL_RS
}
;
return
config
;
}
case
7
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_LEFT
CHANNEL_RIGHT
CHANNEL_CENTER
CHANNEL_LFE
CHANNEL_RCENTER
CHANNEL_LS
CHANNEL_RS
}
;
return
config
;
}
case
8
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_LEFT
CHANNEL_RIGHT
CHANNEL_CENTER
CHANNEL_LFE
CHANNEL_RLS
CHANNEL_RRS
CHANNEL_LS
CHANNEL_RS
}
;
return
config
;
}
default
:
return
nullptr
;
}
}
bool
AudioConfig
:
:
ChannelLayout
:
:
MappingTable
(
const
ChannelLayout
&
aOther
uint8_t
*
aMap
)
const
{
if
(
!
IsValid
(
)
|
|
!
aOther
.
IsValid
(
)
|
|
Map
(
)
!
=
aOther
.
Map
(
)
)
{
return
false
;
}
if
(
!
aMap
)
{
return
true
;
}
for
(
uint32_t
i
=
0
;
i
<
Count
(
)
;
i
+
+
)
{
for
(
uint32_t
j
=
0
;
j
<
Count
(
)
;
j
+
+
)
{
if
(
aOther
[
j
]
=
=
mChannels
[
i
]
)
{
aMap
[
j
]
=
i
;
break
;
}
}
}
return
true
;
}
const
char
*
AudioConfig
:
:
FormatToString
(
AudioConfig
:
:
SampleFormat
aFormat
)
{
switch
(
aFormat
)
{
case
FORMAT_U8
:
return
"
unsigned
8
bit
"
;
case
FORMAT_S16
:
return
"
signed
16
bit
"
;
case
FORMAT_S24
:
return
"
signed
24
bit
MSB
"
;
case
FORMAT_S24LSB
:
return
"
signed
24
bit
LSB
"
;
case
FORMAT_S32
:
return
"
signed
32
bit
"
;
case
FORMAT_FLT
:
return
"
32
bit
floating
point
"
;
case
FORMAT_NONE
:
return
"
none
"
;
default
:
return
"
unknown
"
;
}
}
uint32_t
AudioConfig
:
:
SampleSize
(
AudioConfig
:
:
SampleFormat
aFormat
)
{
switch
(
aFormat
)
{
case
FORMAT_U8
:
return
1
;
case
FORMAT_S16
:
return
2
;
case
FORMAT_S24
:
MOZ_FALLTHROUGH
;
case
FORMAT_S24LSB
:
MOZ_FALLTHROUGH
;
case
FORMAT_S32
:
MOZ_FALLTHROUGH
;
case
FORMAT_FLT
:
return
4
;
case
FORMAT_NONE
:
default
:
return
0
;
}
}
uint32_t
AudioConfig
:
:
FormatToBits
(
AudioConfig
:
:
SampleFormat
aFormat
)
{
switch
(
aFormat
)
{
case
FORMAT_U8
:
return
8
;
case
FORMAT_S16
:
return
16
;
case
FORMAT_S24LSB
:
MOZ_FALLTHROUGH
;
case
FORMAT_S24
:
return
24
;
case
FORMAT_S32
:
MOZ_FALLTHROUGH
;
case
FORMAT_FLT
:
return
32
;
case
FORMAT_NONE
:
MOZ_FALLTHROUGH
;
default
:
return
0
;
}
}
AudioConfig
:
:
AudioConfig
(
const
ChannelLayout
&
aChannelLayout
uint32_t
aRate
AudioConfig
:
:
SampleFormat
aFormat
bool
aInterleaved
)
:
mChannelLayout
(
aChannelLayout
)
mChannels
(
aChannelLayout
.
Count
(
)
)
mRate
(
aRate
)
mFormat
(
aFormat
)
mInterleaved
(
aInterleaved
)
{
}
AudioConfig
:
:
AudioConfig
(
uint32_t
aChannels
uint32_t
aRate
AudioConfig
:
:
SampleFormat
aFormat
bool
aInterleaved
)
:
mChannelLayout
(
aChannels
)
mChannels
(
aChannels
)
mRate
(
aRate
)
mFormat
(
aFormat
)
mInterleaved
(
aInterleaved
)
{
}
}
