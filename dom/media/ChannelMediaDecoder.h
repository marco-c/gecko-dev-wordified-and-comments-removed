#
ifndef
ChannelMediaDecoder_h_
#
define
ChannelMediaDecoder_h_
#
include
"
MediaDecoder
.
h
"
#
include
"
MediaResourceCallback
.
h
"
#
include
"
MediaChannelStatistics
.
h
"
class
nsIChannel
;
class
nsIStreamListener
;
namespace
mozilla
{
class
BaseMediaResource
;
DDLoggedTypeDeclNameAndBase
(
ChannelMediaDecoder
MediaDecoder
)
;
class
ChannelMediaDecoder
:
public
MediaDecoder
public
DecoderDoctorLifeLogger
<
ChannelMediaDecoder
>
{
class
ResourceCallback
:
public
MediaResourceCallback
{
static
const
uint32_t
sDelay
=
500
;
public
:
explicit
ResourceCallback
(
AbstractThread
*
aMainThread
)
;
void
Connect
(
ChannelMediaDecoder
*
aDecoder
)
;
void
Disconnect
(
)
;
private
:
~
ResourceCallback
(
)
;
AbstractThread
*
AbstractMainThread
(
)
const
override
;
MediaDecoderOwner
*
GetMediaOwner
(
)
const
override
;
void
NotifyNetworkError
(
const
MediaResult
&
aError
)
override
;
void
NotifyDataArrived
(
)
override
;
void
NotifyDataEnded
(
nsresult
aStatus
)
override
;
void
NotifyPrincipalChanged
(
)
override
;
void
NotifySuspendedStatusChanged
(
bool
aSuspendedByCache
)
override
;
static
void
TimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
ChannelMediaDecoder
*
mDecoder
=
nullptr
;
nsCOMPtr
<
nsITimer
>
mTimer
;
bool
mTimerArmed
=
false
;
const
RefPtr
<
AbstractThread
>
mAbstractMainThread
;
}
;
protected
:
void
ShutdownInternal
(
)
override
;
void
OnPlaybackEvent
(
MediaPlaybackEvent
&
&
aEvent
)
override
;
void
DurationChanged
(
)
override
;
void
MetadataLoaded
(
UniquePtr
<
MediaInfo
>
aInfo
UniquePtr
<
MetadataTags
>
aTags
MediaDecoderEventVisibility
aEventVisibility
)
override
;
void
NotifyPrincipalChanged
(
)
override
;
RefPtr
<
ResourceCallback
>
mResourceCallback
;
RefPtr
<
BaseMediaResource
>
mResource
;
explicit
ChannelMediaDecoder
(
MediaDecoderInit
&
aInit
)
;
void
GetDebugInfo
(
dom
:
:
MediaDecoderDebugInfo
&
aInfo
)
;
public
:
static
already_AddRefed
<
ChannelMediaDecoder
>
Create
(
MediaDecoderInit
&
aInit
DecoderDoctorDiagnostics
*
aDiagnostics
)
;
void
Shutdown
(
)
override
;
bool
CanClone
(
)
;
already_AddRefed
<
ChannelMediaDecoder
>
Clone
(
MediaDecoderInit
&
aInit
)
;
nsresult
Load
(
nsIChannel
*
aChannel
bool
aIsPrivateBrowsing
nsIStreamListener
*
*
aStreamListener
)
;
void
AddSizeOfResources
(
ResourceSizes
*
aSizes
)
override
;
already_AddRefed
<
nsIPrincipal
>
GetCurrentPrincipal
(
)
override
;
bool
HadCrossOriginRedirects
(
)
override
;
bool
IsTransportSeekable
(
)
override
;
void
SetLoadInBackground
(
bool
aLoadInBackground
)
override
;
void
Suspend
(
)
override
;
void
Resume
(
)
override
;
private
:
struct
MediaStatistics
{
double
mPlaybackRate
;
double
mDownloadRate
;
int64_t
mTotalBytes
;
int64_t
mDownloadPosition
;
int64_t
mPlaybackByteOffset
;
bool
mDownloadRateReliable
;
bool
mPlaybackRateReliable
;
bool
CanPlayThrough
(
)
const
;
nsCString
ToString
(
)
const
;
}
;
void
DownloadProgressed
(
)
;
MediaDecoderStateMachineBase
*
CreateStateMachine
(
bool
aDisableExternalEngine
)
override
;
nsresult
Load
(
BaseMediaResource
*
aOriginal
)
;
void
NotifyDownloadEnded
(
nsresult
aStatus
)
;
void
NotifyBytesConsumed
(
int64_t
aBytes
int64_t
aOffset
)
;
bool
CanPlayThroughImpl
(
)
final
;
struct
PlaybackRateInfo
{
uint32_t
mRate
;
bool
mReliable
;
}
;
static
PlaybackRateInfo
UpdateResourceOfPlaybackByteRate
(
const
MediaChannelStatistics
&
aStats
BaseMediaResource
*
aResource
const
media
:
:
TimeUnit
&
aDuration
)
;
static
MediaStatistics
GetStatistics
(
const
PlaybackRateInfo
&
aInfo
BaseMediaResource
*
aRes
int64_t
aPlaybackPosition
)
;
bool
ShouldThrottleDownload
(
const
MediaStatistics
&
aStats
)
;
MediaChannelStatistics
mPlaybackStatistics
;
int64_t
mPlaybackByteOffset
=
0
;
bool
mCanPlayThrough
=
false
;
bool
mInitialChannelPrincipalKnown
=
false
;
RefPtr
<
GenericPromise
>
mResourceClosePromise
;
}
;
}
#
endif
