#
include
"
MediaCapabilitiesValidation
.
h
"
#
include
<
algorithm
>
#
include
<
array
>
#
include
<
cmath
>
#
include
"
MediaMIMETypes
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
dom
/
MediaCapabilitiesBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
nsReadableUtils
.
h
"
extern
mozilla
:
:
LazyLogModule
sMediaCapabilitiesLog
;
#
define
LOG
(
args
)
MOZ_LOG
(
sMediaCapabilitiesLog
LogLevel
:
:
Debug
args
)
namespace
mozilla
:
:
mediacaps
{
using
dom
:
:
AudioConfiguration
;
using
dom
:
:
MediaConfiguration
;
using
dom
:
:
MediaDecodingConfiguration
;
using
dom
:
:
MediaDecodingType
;
using
dom
:
:
MediaEncodingConfiguration
;
using
dom
:
:
MediaEncodingType
;
using
dom
:
:
MSG_INVALID_MEDIA_AUDIO_CONFIGURATION
;
using
dom
:
:
MSG_INVALID_MEDIA_VIDEO_CONFIGURATION
;
using
dom
:
:
MSG_MISSING_REQUIRED_DICTIONARY_MEMBER
;
using
dom
:
:
Promise
;
using
dom
:
:
VideoConfiguration
;
static
nsAutoCString
GetMIMEDebugString
(
const
MediaConfiguration
&
aConfig
)
;
static
bool
IsContainerType
(
const
MediaExtendedMIMEType
&
aMime
)
;
static
bool
IsSingleCodecType
(
const
MediaExtendedMIMEType
&
aMime
)
;
static
const
std
:
:
array
kSingleWebRTCCodecTypes
=
{
"
audio
/
g711
-
alaw
"
_ns
"
audio
/
g711
-
mlaw
"
_ns
"
audio
/
g722
"
_ns
"
audio
/
opus
"
_ns
"
audio
/
pcma
"
_ns
"
audio
/
pcmu
"
_ns
"
video
/
av1
"
_ns
"
video
/
h264
"
_ns
"
video
/
vp8
"
_ns
"
video
/
vp9
"
_ns
}
;
static
const
std
:
:
array
kContainerTypes
=
{
"
video
/
mkv
"
_ns
"
video
/
mp4
"
_ns
"
video
/
webm
"
_ns
"
audio
/
ogg
"
_ns
"
audio
/
mp4
"
_ns
"
audio
/
webm
"
_ns
}
;
ValidationResult
CheckMIMETypeSupport
(
const
MediaExtendedMIMEType
&
aMime
const
AVType
&
aAVType
const
MediaType
&
aMediaType
)
{
return
Ok
(
)
;
}
static
ValidationResult
CheckMIMETypeValidity
(
const
MediaExtendedMIMEType
&
aMime
const
AVType
&
aAVType
const
MediaType
&
aMediaType
)
{
const
MediaMIMEType
&
mimetype
=
aMime
.
Type
(
)
;
if
(
!
mimetype
.
HasAudioMajorType
(
)
&
&
!
mimetype
.
HasVideoMajorType
(
)
&
&
!
mimetype
.
HasApplicationMajorType
(
)
)
{
ValidationResult
err
=
Err
(
aAVType
=
=
AVType
:
:
AUDIO
?
ValidationError
:
:
InvalidAudioType
:
ValidationError
:
:
InvalidVideoType
)
;
LOG
(
(
"
[
Invalid
MIME
Validity
#
1
%
s
]
Rejecting
-
not
media
not
"
"
application
%
s
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
aMime
.
OriginalString
(
)
.
get
(
)
)
)
;
return
err
;
}
if
(
aAVType
=
=
AVType
:
:
AUDIO
&
&
!
aMime
.
Type
(
)
.
HasAudioMajorType
(
)
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
InvalidAudioType
)
;
LOG
(
(
"
[
Invalid
MIME
Validity
#
1a
?
%
s
]
Rejecting
'
%
s
'
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
aMime
.
OriginalString
(
)
.
get
(
)
)
)
;
return
err
;
}
if
(
aAVType
=
=
AVType
:
:
VIDEO
&
&
!
aMime
.
Type
(
)
.
HasVideoMajorType
(
)
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
InvalidVideoType
)
;
LOG
(
(
"
[
Invalid
MIME
Validity
#
1b
?
%
s
]
Rejecting
'
%
s
'
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
aMime
.
OriginalString
(
)
.
get
(
)
)
)
;
return
err
;
}
const
size_t
numParams
=
aMime
.
GetParameterCount
(
)
;
if
(
IsSingleCodecType
(
aMime
)
&
&
numParams
!
=
0
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
SingleCodecHasParams
)
;
LOG
(
(
"
[
Invalid
MIME
Validity
#
2
%
s
]
Rejecting
'
%
s
'
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
aMime
.
OriginalString
(
)
.
get
(
)
)
)
;
return
err
;
}
if
(
IsContainerType
(
aMime
)
)
{
if
(
(
numParams
!
=
1
)
|
|
!
aMime
.
HaveCodecs
(
)
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
ContainerMissingCodecsParam
)
;
LOG
(
(
"
[
Invalid
MIME
Validity
#
3
.
1
%
s
]
Rejecting
'
%
s
'
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
aMime
.
OriginalString
(
)
.
get
(
)
)
)
;
return
err
;
}
const
auto
&
codecs
=
aMime
.
Codecs
(
)
;
if
(
!
aMime
.
HaveCodecs
(
)
|
|
codecs
.
IsEmpty
(
)
|
|
codecs
.
AsString
(
)
.
FindChar
(
'
'
)
!
=
kNotFound
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
ContainerCodecsNotSingle
)
;
LOG
(
(
"
[
Invalid
MIME
#
3
.
2
%
s
]
Rejecting
'
%
s
'
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
aMime
.
OriginalString
(
)
.
get
(
)
)
)
;
return
err
;
}
}
return
Ok
(
)
;
}
ValidationResult
IsValidAudioConfiguration
(
const
AudioConfiguration
&
aConfig
const
MediaType
&
aType
)
{
const
Maybe
<
MediaExtendedMIMEType
>
mime
=
MakeMediaExtendedMIMEType
(
aConfig
.
mContentType
)
;
if
(
!
mime
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
InvalidAudioType
)
;
LOG
(
(
"
[
Invalid
AudioConfiguration
#
2
%
s
]
Rejecting
'
%
s
'
\
n
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
NS_ConvertUTF16toUTF8
(
aConfig
.
mContentType
)
.
get
(
)
)
)
;
return
err
;
}
return
CheckMIMETypeValidity
(
mime
.
ref
(
)
AVType
:
:
AUDIO
aType
)
;
}
template
<
typename
CodingType
>
ValidationResult
IsValidVideoConfiguration
(
const
VideoConfiguration
&
aConfig
const
CodingType
&
aType
)
{
static_assert
(
std
:
:
is_same_v
<
std
:
:
decay_t
<
CodingType
>
MediaEncodingType
>
|
|
std
:
:
is_same_v
<
CodingType
MediaDecodingType
>
"
tType
must
be
MediaEncodingType
or
MediaDecodingType
"
)
;
if
(
!
isfinite
(
aConfig
.
mFramerate
)
|
|
!
(
aConfig
.
mFramerate
>
0
)
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
FramerateInvalid
)
;
LOG
(
(
"
[
Invalid
VideoConfiguration
(
Framerate
%
s
)
#
1
]
Rejecting
'
%
s
'
\
n
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
NS_ConvertUTF16toUTF8
(
aConfig
.
mContentType
)
.
get
(
)
)
)
;
return
err
;
}
if
constexpr
(
std
:
:
is_same_v
<
CodingType
MediaDecodingType
>
)
{
if
(
aConfig
.
mHdrMetadataType
.
WasPassed
(
)
&
&
aType
!
=
MediaDecodingType
:
:
File
&
&
aType
!
=
MediaDecodingType
:
:
Media_source
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
InapplicableMember
)
;
LOG
(
(
"
[
Invalid
VideoConfiguration
(
HDR
%
s
)
#
2
]
Rejecting
'
%
s
'
\
n
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
NS_ConvertUTF16toUTF8
(
aConfig
.
mContentType
)
.
get
(
)
)
)
;
return
err
;
}
if
(
aConfig
.
mColorGamut
.
WasPassed
(
)
&
&
aType
!
=
MediaDecodingType
:
:
File
&
&
aType
!
=
MediaDecodingType
:
:
Media_source
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
InapplicableMember
)
;
LOG
(
(
"
[
Invalid
VideoConfiguration
(
Color
Gamut
%
s
)
#
2
]
Rejecting
'
%
s
'
\
n
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
NS_ConvertUTF16toUTF8
(
aConfig
.
mContentType
)
.
get
(
)
)
)
;
return
err
;
}
if
(
aConfig
.
mTransferFunction
.
WasPassed
(
)
&
&
aType
!
=
MediaDecodingType
:
:
File
&
&
aType
!
=
MediaDecodingType
:
:
Media_source
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
InapplicableMember
)
;
LOG
(
(
"
[
Invalid
VideoConfiguration
(
Transfer
Function
%
s
)
#
2
]
Rejecting
"
"
'
%
s
'
\
n
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
NS_ConvertUTF16toUTF8
(
aConfig
.
mContentType
)
.
get
(
)
)
)
;
return
err
;
}
}
const
Maybe
<
MediaExtendedMIMEType
>
mime
=
MakeMediaExtendedMIMEType
(
aConfig
.
mContentType
)
;
if
(
!
mime
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
InvalidVideoType
)
;
LOG
(
(
"
[
Invalid
VideoConfiguration
(
MIME
failure
%
s
)
#
4
]
Rejecting
'
%
s
'
\
n
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
NS_ConvertUTF16toUTF8
(
aConfig
.
mContentType
)
.
get
(
)
)
)
;
return
err
;
}
return
CheckMIMETypeValidity
(
mime
.
ref
(
)
AVType
:
:
VIDEO
AsVariant
(
aType
)
)
;
}
template
ValidationResult
IsValidVideoConfiguration
<
MediaEncodingType
>
(
const
VideoConfiguration
&
const
MediaEncodingType
&
)
;
template
ValidationResult
IsValidVideoConfiguration
<
MediaDecodingType
>
(
const
VideoConfiguration
&
const
MediaDecodingType
&
)
;
ValidationResult
IsValidVideoConfiguration
(
const
VideoConfiguration
&
aConfig
const
MediaType
&
aType
)
{
return
aType
.
match
(
[
&
]
(
const
MediaEncodingType
&
t
)
{
return
IsValidVideoConfiguration
(
aConfig
t
)
;
}
[
&
]
(
const
MediaDecodingType
&
t
)
{
return
IsValidVideoConfiguration
(
aConfig
t
)
;
}
)
;
}
ValidationResult
IsValidMediaConfiguration
(
const
MediaConfiguration
&
aConfig
const
MediaType
&
aType
)
{
if
(
!
aConfig
.
mVideo
.
WasPassed
(
)
&
&
!
aConfig
.
mAudio
.
WasPassed
(
)
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
MissingType
)
;
LOG
(
(
"
[
Invalid
Media
Configuration
(
No
A
/
V
%
s
)
#
1
]
'
%
s
'
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
GetMIMEDebugString
(
aConfig
)
.
get
(
)
)
)
;
return
err
;
}
if
(
aConfig
.
mAudio
.
WasPassed
(
)
)
{
auto
rv
=
IsValidAudioConfiguration
(
aConfig
.
mAudio
.
Value
(
)
aType
)
;
if
(
rv
.
isErr
(
)
)
{
LOG
(
(
"
[
Invalid
Media
Configuration
(
Invalid
Audio
%
s
)
#
2
]
'
%
s
'
"
EnumValueToString
(
rv
.
unwrapErr
(
)
)
GetMIMEDebugString
(
aConfig
)
.
get
(
)
)
)
;
return
rv
;
}
}
if
(
aConfig
.
mVideo
.
WasPassed
(
)
)
{
auto
rv
=
IsValidVideoConfiguration
(
aConfig
.
mVideo
.
Value
(
)
aType
)
;
if
(
rv
.
isErr
(
)
)
{
LOG
(
(
"
[
Invalid
Media
Configuration
(
Invalid
Video
%
s
)
#
3
]
'
%
s
'
"
EnumValueToString
(
rv
.
unwrapErr
(
)
)
GetMIMEDebugString
(
aConfig
)
.
get
(
)
)
)
;
return
rv
;
}
}
return
Ok
(
)
;
}
ValidationResult
IsValidMediaEncodingConfiguration
(
const
MediaEncodingConfiguration
&
aConfig
)
{
return
IsValidMediaConfiguration
(
aConfig
AsVariant
(
aConfig
.
mType
)
)
;
}
ValidationResult
IsValidMediaDecodingConfiguration
(
const
MediaDecodingConfiguration
&
aConfig
)
{
auto
base
=
IsValidMediaConfiguration
(
aConfig
AsVariant
(
aConfig
.
mType
)
)
;
if
(
base
.
isErr
(
)
)
{
LOG
(
(
"
[
Invalid
MediaDecodingConfiguration
(
Invalid
MediaConfiguration
%
s
)
"
"
#
1
]
"
EnumValueToString
(
base
.
unwrapErr
(
)
)
)
)
;
return
base
;
}
if
(
aConfig
.
mKeySystemConfiguration
.
WasPassed
(
)
)
{
const
auto
&
keySystemConfig
=
aConfig
.
mKeySystemConfiguration
.
Value
(
)
;
if
(
aConfig
.
mType
!
=
MediaDecodingType
:
:
File
&
&
aConfig
.
mType
!
=
MediaDecodingType
:
:
Media_source
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
KeySystemWrongType
)
;
LOG
(
(
"
[
Invalid
MediaDecodingConfiguration
(
keysystem
%
s
)
#
2
.
1
]
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
)
)
;
return
err
;
}
if
(
keySystemConfig
.
mAudio
.
WasPassed
(
)
&
&
!
aConfig
.
mAudio
.
WasPassed
(
)
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
KeySystemAudioMissing
)
;
LOG
(
(
"
[
Invalid
MediaDecodingConfiguration
(
keysystem
%
s
)
#
2
.
2
]
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
)
)
;
return
err
;
}
if
(
keySystemConfig
.
mVideo
.
WasPassed
(
)
&
&
!
aConfig
.
mVideo
.
WasPassed
(
)
)
{
ValidationResult
err
=
Err
(
ValidationError
:
:
KeySystemVideoMissing
)
;
LOG
(
(
"
[
Invalid
MediaDecodingConfiguration
(
keysystem
%
s
)
#
2
.
3
]
"
EnumValueToString
(
err
.
unwrapErr
(
)
)
)
)
;
return
err
;
}
}
return
Ok
(
)
;
}
void
RejectWithValidationResult
(
Promise
*
aPromise
const
ValidationError
aErr
)
{
switch
(
aErr
)
{
case
ValidationError
:
:
MissingType
:
aPromise
-
>
MaybeRejectWithTypeError
(
"
'
audio
'
or
'
video
'
member
of
argument
of
MediaCapabilities
"
)
;
return
;
case
ValidationError
:
:
InvalidAudioConfiguration
:
aPromise
-
>
MaybeRejectWithTypeError
(
"
Invalid
AudioConfiguration
!
"
)
;
return
;
case
ValidationError
:
:
InvalidAudioType
:
aPromise
-
>
MaybeRejectWithTypeError
(
"
Invalid
AudioConfiguration
MIME
type
"
)
;
return
;
case
ValidationError
:
:
InvalidVideoConfiguration
:
aPromise
-
>
MaybeRejectWithTypeError
(
"
Invalid
VideoConfiguration
!
"
)
;
return
;
case
ValidationError
:
:
InvalidVideoType
:
aPromise
-
>
MaybeRejectWithTypeError
(
"
Invalid
Video
MIME
type
"
)
;
return
;
case
ValidationError
:
:
SingleCodecHasParams
:
aPromise
-
>
MaybeRejectWithTypeError
(
"
Single
codec
has
parameters
"
)
;
return
;
case
ValidationError
:
:
ContainerMissingCodecsParam
:
aPromise
-
>
MaybeRejectWithTypeError
(
"
Container
missing
codec
parameters
"
)
;
return
;
case
ValidationError
:
:
ContainerCodecsNotSingle
:
aPromise
-
>
MaybeRejectWithTypeError
(
"
Container
has
more
than
one
codec
"
)
;
return
;
case
ValidationError
:
:
FramerateInvalid
:
aPromise
-
>
MaybeRejectWithTypeError
(
"
Invalid
frame
rate
"
)
;
return
;
case
ValidationError
:
:
InapplicableMember
:
aPromise
-
>
MaybeRejectWithTypeError
(
"
Inapplicable
member
"
)
;
return
;
case
ValidationError
:
:
KeySystemWrongType
:
case
ValidationError
:
:
KeySystemAudioMissing
:
case
ValidationError
:
:
KeySystemVideoMissing
:
aPromise
-
>
MaybeRejectWithTypeError
(
"
Invalid
keysystem
configuration
"
)
;
return
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
MediaCapabilities
validation
error
!
"
)
;
return
;
}
}
void
ThrowWithValidationResult
(
ErrorResult
&
aRv
const
ValidationError
aErr
)
{
switch
(
aErr
)
{
case
ValidationError
:
:
MissingType
:
aRv
.
ThrowTypeError
<
MSG_MISSING_REQUIRED_DICTIONARY_MEMBER
>
(
"
'
audio
'
or
'
video
'
member
of
argument
of
MediaCapabilities
"
)
;
return
;
case
ValidationError
:
:
InvalidAudioConfiguration
:
aRv
.
ThrowTypeError
<
MSG_INVALID_MEDIA_AUDIO_CONFIGURATION
>
(
)
;
return
;
case
ValidationError
:
:
InvalidAudioType
:
case
ValidationError
:
:
KeySystemAudioMissing
:
aRv
.
ThrowTypeError
<
MSG_INVALID_MEDIA_AUDIO_CONFIGURATION
>
(
)
;
return
;
case
ValidationError
:
:
InvalidVideoConfiguration
:
case
ValidationError
:
:
InvalidVideoType
:
case
ValidationError
:
:
SingleCodecHasParams
:
case
ValidationError
:
:
ContainerMissingCodecsParam
:
case
ValidationError
:
:
ContainerCodecsNotSingle
:
case
ValidationError
:
:
FramerateInvalid
:
case
ValidationError
:
:
InapplicableMember
:
aRv
.
ThrowTypeError
<
MSG_INVALID_MEDIA_VIDEO_CONFIGURATION
>
(
)
;
return
;
case
ValidationError
:
:
KeySystemWrongType
:
case
ValidationError
:
:
KeySystemVideoMissing
:
aRv
.
ThrowTypeError
<
MSG_INVALID_MEDIA_VIDEO_CONFIGURATION
>
(
)
;
return
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
MediaCapabilities
validation
error
!
"
)
;
return
;
}
}
template
<
size_t
N
>
static
bool
MimePrefixStartsWith
(
const
MediaExtendedMIMEType
&
aMime
const
std
:
:
array
<
nsLiteralCString
N
>
&
aPrefixes
)
{
const
nsACString
&
s
=
aMime
.
OriginalString
(
)
;
return
std
:
:
any_of
(
aPrefixes
.
begin
(
)
aPrefixes
.
end
(
)
[
&
]
(
const
auto
&
p
)
{
return
StringBeginsWith
(
s
p
nsCaseInsensitiveCStringComparator
)
;
}
)
;
}
static
bool
IsContainerType
(
const
MediaExtendedMIMEType
&
aMime
)
{
return
MimePrefixStartsWith
(
aMime
kContainerTypes
)
;
}
static
bool
IsSingleCodecType
(
const
MediaExtendedMIMEType
&
aMime
)
{
return
MimePrefixStartsWith
(
aMime
kSingleWebRTCCodecTypes
)
;
}
static
nsAutoCString
GetMIMEDebugString
(
const
MediaConfiguration
&
aConfig
)
{
nsAutoCString
result
;
result
.
SetCapacity
(
64
)
;
result
.
AssignLiteral
(
"
Audio
MIME
:
"
)
;
if
(
aConfig
.
mAudio
.
WasPassed
(
)
)
{
result
.
Append
(
NS_ConvertUTF16toUTF8
(
aConfig
.
mAudio
.
Value
(
)
.
mContentType
)
)
;
}
else
{
result
.
AppendLiteral
(
"
(
none
)
"
)
;
}
result
.
AppendLiteral
(
"
Video
MIME
:
"
)
;
if
(
aConfig
.
mVideo
.
WasPassed
(
)
)
{
result
.
Append
(
NS_ConvertUTF16toUTF8
(
aConfig
.
mVideo
.
Value
(
)
.
mContentType
)
)
;
}
else
{
result
.
AppendLiteral
(
"
(
none
)
"
)
;
}
return
result
;
}
}
#
undef
LOG
