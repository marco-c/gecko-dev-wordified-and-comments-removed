#
include
"
DecoderBenchmark
.
h
"
#
include
"
mozilla
/
BenchmarkStorageChild
.
h
"
#
include
"
mozilla
/
media
/
MediaUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
namespace
mozilla
{
void
DecoderBenchmark
:
:
StoreScore
(
const
nsACString
&
aDecoderName
const
nsACString
&
aKey
RefPtr
<
FrameStatistics
>
aStats
)
{
uint64_t
totalFrames
=
aStats
-
>
GetTotalFrames
(
)
;
uint64_t
droppedFrames
=
aStats
-
>
GetDroppedFrames
(
)
;
MOZ_ASSERT
(
droppedFrames
<
=
totalFrames
)
;
MOZ_ASSERT
(
totalFrames
>
=
mLastTotalFrames
)
;
MOZ_ASSERT
(
droppedFrames
>
=
mLastDroppedFrames
)
;
uint64_t
diffTotalFrames
=
totalFrames
-
mLastTotalFrames
;
uint64_t
diffDroppedFrames
=
droppedFrames
-
mLastDroppedFrames
;
mLastTotalFrames
=
totalFrames
;
mLastDroppedFrames
=
droppedFrames
;
if
(
diffTotalFrames
<
10
)
{
return
;
}
int32_t
percentage
=
100
-
100
*
float
(
diffDroppedFrames
)
/
float
(
diffTotalFrames
)
;
MOZ_ASSERT
(
percentage
>
=
0
)
;
Put
(
aDecoderName
aKey
percentage
)
;
}
void
DecoderBenchmark
:
:
Put
(
const
nsACString
&
aDecoderName
const
nsACString
&
aKey
int32_t
aValue
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
const
nsCString
name
(
aDecoderName
)
;
const
nsCString
key
(
aKey
)
;
BenchmarkStorageChild
:
:
Instance
(
)
-
>
SendPut
(
name
key
aValue
)
;
}
RefPtr
<
BenchmarkScorePromise
>
DecoderBenchmark
:
:
GetScore
(
const
nsACString
&
aDecoderName
const
nsACString
&
aKey
)
{
if
(
NS_IsMainThread
(
)
)
{
return
Get
(
aDecoderName
aKey
)
;
}
RefPtr
<
DecoderBenchmark
>
self
=
this
;
const
nsCString
decoderName
(
aDecoderName
)
;
const
nsCString
key
(
aKey
)
;
return
InvokeAsync
(
GetMainThreadSerialEventTarget
(
)
__func__
[
self
decoderName
key
]
{
return
self
-
>
Get
(
decoderName
key
)
;
}
)
;
}
RefPtr
<
BenchmarkScorePromise
>
DecoderBenchmark
:
:
Get
(
const
nsACString
&
aDecoderName
const
nsACString
&
aKey
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
const
nsCString
name
(
aDecoderName
)
;
const
nsCString
key
(
aKey
)
;
return
BenchmarkStorageChild
:
:
Instance
(
)
-
>
SendGet
(
name
key
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
]
(
int32_t
aResult
)
{
return
BenchmarkScorePromise
:
:
CreateAndResolve
(
aResult
__func__
)
;
}
[
]
(
ipc
:
:
ResponseRejectReason
&
&
)
{
return
BenchmarkScorePromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
)
;
}
#
define
NELEMS
(
x
)
(
sizeof
(
x
)
/
sizeof
(
(
x
)
[
0
]
)
)
const
uint32_t
PixelLevels
[
]
=
{
36864
102240
230400
409920
921600
2073600
3686400
8294400
}
;
const
size_t
PixelLevelsSize
=
NELEMS
(
PixelLevels
)
;
const
uint32_t
FrameRateLevels
[
]
=
{
15
24
30
50
60
}
;
const
size_t
FrameRateLevelsSize
=
NELEMS
(
FrameRateLevels
)
;
nsCString
KeyUtil
:
:
FindLevel
(
const
uint32_t
aLevels
[
]
const
size_t
length
uint32_t
aValue
)
{
MOZ_ASSERT
(
aValue
)
;
if
(
aValue
<
=
aLevels
[
0
]
)
{
return
NS_LITERAL_CSTRING
(
"
Level0
"
)
;
}
nsAutoCString
level
(
"
Level
"
)
;
size_t
lastIndex
=
length
-
1
;
if
(
aValue
>
=
aLevels
[
lastIndex
]
)
{
level
.
AppendInt
(
static_cast
<
uint32_t
>
(
lastIndex
)
)
;
return
std
:
:
move
(
level
)
;
}
for
(
size_t
i
=
0
;
i
<
lastIndex
;
+
+
i
)
{
if
(
aValue
>
=
aLevels
[
i
+
1
]
)
{
continue
;
}
if
(
aValue
-
aLevels
[
i
]
<
aLevels
[
i
+
1
]
-
aValue
)
{
level
.
AppendInt
(
static_cast
<
uint32_t
>
(
i
)
)
;
return
std
:
:
move
(
level
)
;
}
level
.
AppendInt
(
static_cast
<
uint32_t
>
(
i
+
1
)
)
;
return
std
:
:
move
(
level
)
;
}
MOZ_CRASH
(
"
Array
is
not
sorted
"
)
;
return
NS_LITERAL_CSTRING
(
"
"
)
;
}
nsCString
KeyUtil
:
:
BitDepthToStr
(
uint8_t
aBitDepth
)
{
switch
(
aBitDepth
)
{
case
8
:
return
NS_LITERAL_CSTRING
(
"
-
8bit
"
)
;
case
10
:
case
12
:
case
16
:
return
NS_LITERAL_CSTRING
(
"
-
non8bit
"
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
invalid
color
depth
value
"
)
;
return
NS_LITERAL_CSTRING
(
"
"
)
;
}
nsCString
KeyUtil
:
:
CreateKey
(
const
DecoderBenchmarkInfo
&
aBenchInfo
)
{
nsAutoCString
key
(
"
Resolution
"
)
;
key
.
Append
(
FindLevel
(
PixelLevels
PixelLevelsSize
aBenchInfo
.
mWidth
*
aBenchInfo
.
mHeight
)
)
;
key
.
Append
(
"
-
FrameRate
"
)
;
key
.
Append
(
FindLevel
(
FrameRateLevels
FrameRateLevelsSize
aBenchInfo
.
mFrameRate
)
)
;
key
.
Append
(
BitDepthToStr
(
aBenchInfo
.
mBitDepth
)
)
;
return
std
:
:
move
(
key
)
;
}
void
DecoderBenchmark
:
:
Store
(
const
DecoderBenchmarkInfo
&
aBenchInfo
RefPtr
<
FrameStatistics
>
aStats
)
{
if
(
!
XRE_IsContentProcess
(
)
)
{
NS_WARNING
(
"
Storing
a
benchmark
is
only
allowed
only
from
the
content
process
.
"
)
;
return
;
}
StoreScore
(
aBenchInfo
.
mContentType
KeyUtil
:
:
CreateKey
(
aBenchInfo
)
aStats
)
;
}
RefPtr
<
BenchmarkScorePromise
>
DecoderBenchmark
:
:
Get
(
const
DecoderBenchmarkInfo
&
aBenchInfo
)
{
if
(
!
XRE_IsContentProcess
(
)
)
{
NS_WARNING
(
"
Getting
a
benchmark
is
only
allowed
only
from
the
content
process
.
"
)
;
return
BenchmarkScorePromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
auto
bench
=
MakeRefPtr
<
DecoderBenchmark
>
(
)
;
return
bench
-
>
GetScore
(
aBenchInfo
.
mContentType
KeyUtil
:
:
CreateKey
(
aBenchInfo
)
)
;
}
static
nsDataHashtable
<
nsCStringHashKey
int32_t
>
DecoderVersionTable
(
)
{
nsDataHashtable
<
nsCStringHashKey
int32_t
>
decoderVersionTable
;
return
decoderVersionTable
;
}
void
DecoderBenchmark
:
:
CheckVersion
(
const
nsACString
&
aDecoderName
)
{
if
(
!
XRE_IsContentProcess
(
)
)
{
NS_WARNING
(
"
Checking
version
is
only
allowed
only
from
the
content
process
.
"
)
;
return
;
}
if
(
!
StaticPrefs
:
:
media_mediacapabilities_from_database
(
)
)
{
return
;
}
nsCString
name
(
aDecoderName
)
;
int32_t
version
;
if
(
!
DecoderVersionTable
(
)
.
Get
(
name
&
version
)
)
{
return
;
}
if
(
NS_IsMainThread
(
)
)
{
BenchmarkStorageChild
:
:
Instance
(
)
-
>
SendCheckVersion
(
name
version
)
;
return
;
}
DebugOnly
<
nsresult
>
rv
=
GetMainThreadEventTarget
(
)
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
DecoderBenchmark
:
:
CheckVersion
"
[
name
version
]
(
)
{
BenchmarkStorageChild
:
:
Instance
(
)
-
>
SendCheckVersion
(
name
version
)
;
}
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
