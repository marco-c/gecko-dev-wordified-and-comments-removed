#
ifndef
DOM_MEDIA_MEDIADECODERSTATEMACHINEBASE_H_
#
define
DOM_MEDIA_MEDIADECODERSTATEMACHINEBASE_H_
#
include
"
DecoderDoctorDiagnostics
.
h
"
#
include
"
MediaDecoder
.
h
"
#
include
"
MediaDecoderOwner
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaPromiseDefs
.
h
"
#
include
"
ReaderProxy
.
h
"
#
include
"
VideoFrameContainer
.
h
"
#
include
"
mozilla
/
dom
/
MediaDebugInfoBinding
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
nsISupportsImpl
.
h
"
class
AudioDeviceInfo
;
namespace
mozilla
{
class
AbstractThread
;
class
CDMProxy
;
class
FrameStatistics
;
class
MediaFormatReader
;
class
TaskQueue
;
struct
MediaPlaybackEvent
{
enum
EventType
{
PlaybackStarted
PlaybackStopped
PlaybackProgressed
PlaybackEnded
SeekStarted
Invalidate
EnterVideoSuspend
ExitVideoSuspend
StartVideoSuspendTimer
CancelVideoSuspendTimer
VideoOnlySeekBegin
VideoOnlySeekCompleted
}
mType
;
using
DataType
=
Variant
<
Nothing
int64_t
>
;
DataType
mData
;
MOZ_IMPLICIT
MediaPlaybackEvent
(
EventType
aType
)
:
mType
(
aType
)
mData
(
Nothing
{
}
)
{
}
template
<
typename
T
>
MediaPlaybackEvent
(
EventType
aType
T
&
&
aArg
)
:
mType
(
aType
)
mData
(
std
:
:
forward
<
T
>
(
aArg
)
)
{
}
}
;
enum
class
VideoDecodeMode
:
uint8_t
{
Normal
Suspend
}
;
class
MediaDecoderStateMachineBase
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
using
FirstFrameEventSourceExc
=
MediaEventSourceExc
<
UniquePtr
<
MediaInfo
>
MediaDecoderEventVisibility
>
;
using
MetadataEventSourceExc
=
MediaEventSourceExc
<
UniquePtr
<
MediaInfo
>
UniquePtr
<
MetadataTags
>
MediaDecoderEventVisibility
>
;
using
NextFrameStatus
=
MediaDecoderOwner
:
:
NextFrameStatus
;
MediaDecoderStateMachineBase
(
MediaDecoder
*
aDecoder
MediaFormatReader
*
aReader
)
;
virtual
nsresult
Init
(
MediaDecoder
*
aDecoder
)
;
RefPtr
<
ShutdownPromise
>
BeginShutdown
(
)
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
InvokeSeek
(
const
SeekTarget
&
aTarget
)
;
virtual
size_t
SizeOfVideoQueue
(
)
const
=
0
;
virtual
size_t
SizeOfAudioQueue
(
)
const
=
0
;
virtual
void
SetVideoDecodeMode
(
VideoDecodeMode
aMode
)
=
0
;
virtual
RefPtr
<
GenericPromise
>
InvokeSetSink
(
const
RefPtr
<
AudioDeviceInfo
>
&
aSink
)
=
0
;
virtual
void
InvokeSuspendMediaSink
(
)
=
0
;
virtual
void
InvokeResumeMediaSink
(
)
=
0
;
virtual
RefPtr
<
GenericPromise
>
RequestDebugInfo
(
dom
:
:
MediaDecoderStateMachineDebugInfo
&
aInfo
)
=
0
;
TaskQueue
*
OwnerThread
(
)
const
{
return
mTaskQueue
;
}
MetadataEventSourceExc
&
MetadataLoadedEvent
(
)
{
return
mMetadataLoadedEvent
;
}
FirstFrameEventSourceExc
&
FirstFrameLoadedEvent
(
)
{
return
mFirstFrameLoadedEvent
;
}
MediaEventSourceExc
<
RefPtr
<
VideoFrameContainer
>
>
&
OnSecondaryVideoContainerInstalled
(
)
{
return
mOnSecondaryVideoContainerInstalled
;
}
TimedMetadataEventSource
&
TimedMetadataEvent
(
)
{
return
mMetadataManager
.
TimedMetadataEvent
(
)
;
}
MediaEventSource
<
MediaPlaybackEvent
>
&
OnPlaybackEvent
(
)
{
return
mOnPlaybackEvent
;
}
MediaEventSource
<
MediaResult
>
&
OnPlaybackErrorEvent
(
)
{
return
mOnPlaybackErrorEvent
;
}
MediaEventSource
<
DecoderDoctorEvent
>
&
OnDecoderDoctorEvent
(
)
{
return
mOnDecoderDoctorEvent
;
}
MediaEventSource
<
NextFrameStatus
>
&
OnNextFrameStatus
(
)
{
return
mOnNextFrameStatus
;
}
MediaEventProducer
<
VideoInfo
AudioInfo
>
&
OnTrackInfoUpdatedEvent
(
)
{
return
mReader
-
>
OnTrackInfoUpdatedEvent
(
)
;
}
MediaEventSource
<
void
>
&
OnMediaNotSeekable
(
)
const
;
AbstractCanonical
<
media
:
:
NullableTimeUnit
>
*
CanonicalDuration
(
)
{
return
&
mDuration
;
}
AbstractCanonical
<
media
:
:
TimeUnit
>
*
CanonicalCurrentPosition
(
)
{
return
&
mCurrentPosition
;
}
AbstractCanonical
<
bool
>
*
CanonicalIsAudioDataAudible
(
)
{
return
&
mIsAudioDataAudible
;
}
AbstractCanonical
<
media
:
:
TimeIntervals
>
*
CanonicalBuffered
(
)
const
;
void
DispatchSetFragmentEndTime
(
const
media
:
:
TimeUnit
&
aEndTime
)
;
void
DispatchCanPlayThrough
(
bool
aCanPlayThrough
)
;
void
DispatchIsLiveStream
(
bool
aIsLiveStream
)
;
void
DispatchSetPlaybackRate
(
double
aPlaybackRate
)
;
virtual
RefPtr
<
SetCDMPromise
>
SetCDMProxy
(
CDMProxy
*
aProxy
)
;
protected
:
virtual
~
MediaDecoderStateMachineBase
(
)
=
default
;
bool
HasAudio
(
)
const
{
return
mInfo
.
ref
(
)
.
HasAudio
(
)
;
}
bool
HasVideo
(
)
const
{
return
mInfo
.
ref
(
)
.
HasVideo
(
)
;
}
const
MediaInfo
&
Info
(
)
const
{
return
mInfo
.
ref
(
)
;
}
virtual
void
SetPlaybackRate
(
double
aPlaybackRate
)
=
0
;
virtual
void
SetIsLiveStream
(
bool
aIsLiveStream
)
=
0
;
virtual
void
SetCanPlayThrough
(
bool
aCanPlayThrough
)
=
0
;
virtual
void
SetFragmentEndTime
(
const
media
:
:
TimeUnit
&
aFragmentEndTime
)
=
0
;
virtual
void
BufferedRangeUpdated
(
)
=
0
;
virtual
void
VolumeChanged
(
)
=
0
;
virtual
void
PreservesPitchChanged
(
)
=
0
;
virtual
void
PlayStateChanged
(
)
=
0
;
virtual
void
LoopingChanged
(
)
=
0
;
virtual
void
UpdateSecondaryVideoContainer
(
)
=
0
;
virtual
void
InitializationTask
(
MediaDecoder
*
aDecoder
)
;
virtual
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
=
0
;
virtual
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
Seek
(
const
SeekTarget
&
aTarget
)
=
0
;
void
DecodeError
(
const
MediaResult
&
aError
)
;
bool
OnTaskQueue
(
)
const
;
bool
IsRequestingAudioData
(
)
const
{
return
mAudioDataRequest
.
Exists
(
)
;
}
bool
IsRequestingVideoData
(
)
const
{
return
mVideoDataRequest
.
Exists
(
)
;
}
bool
IsWaitingAudioData
(
)
const
{
return
mAudioWaitRequest
.
Exists
(
)
;
}
bool
IsWaitingVideoData
(
)
const
{
return
mVideoWaitRequest
.
Exists
(
)
;
}
void
*
const
mDecoderID
;
const
RefPtr
<
AbstractThread
>
mAbstractMainThread
;
const
RefPtr
<
FrameStatistics
>
mFrameStats
;
const
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
const
RefPtr
<
TaskQueue
>
mTaskQueue
;
const
RefPtr
<
ReaderProxy
>
mReader
;
mozilla
:
:
MediaMetadataManager
mMetadataManager
;
double
mPlaybackRate
;
MediaEventProducerExc
<
UniquePtr
<
MediaInfo
>
UniquePtr
<
MetadataTags
>
MediaDecoderEventVisibility
>
mMetadataLoadedEvent
;
MediaEventProducerExc
<
UniquePtr
<
MediaInfo
>
MediaDecoderEventVisibility
>
mFirstFrameLoadedEvent
;
MediaEventProducerExc
<
RefPtr
<
VideoFrameContainer
>
>
mOnSecondaryVideoContainerInstalled
;
MediaEventProducer
<
MediaPlaybackEvent
>
mOnPlaybackEvent
;
MediaEventProducer
<
MediaResult
>
mOnPlaybackErrorEvent
;
MediaEventProducer
<
DecoderDoctorEvent
>
mOnDecoderDoctorEvent
;
MediaEventProducer
<
NextFrameStatus
>
mOnNextFrameStatus
;
Mirror
<
media
:
:
TimeIntervals
>
mBuffered
;
Mirror
<
MediaDecoder
:
:
PlayState
>
mPlayState
;
Mirror
<
double
>
mVolume
;
Mirror
<
bool
>
mPreservesPitch
;
Mirror
<
bool
>
mLooping
;
Mirror
<
RefPtr
<
VideoFrameContainer
>
>
mSecondaryVideoContainer
;
Canonical
<
media
:
:
NullableTimeUnit
>
mDuration
;
Canonical
<
media
:
:
TimeUnit
>
mCurrentPosition
;
Canonical
<
bool
>
mIsAudioDataAudible
;
Maybe
<
MediaInfo
>
mInfo
;
bool
mMediaSeekable
=
true
;
bool
mMediaSeekableOnlyInBufferedRanges
=
false
;
bool
mSentFirstFrameLoadedEvent
=
false
;
bool
mMinimizePreroll
;
using
AudioDataPromise
=
MediaFormatReader
:
:
AudioDataPromise
;
using
VideoDataPromise
=
MediaFormatReader
:
:
VideoDataPromise
;
using
WaitForDataPromise
=
MediaFormatReader
:
:
WaitForDataPromise
;
MozPromiseRequestHolder
<
AudioDataPromise
>
mAudioDataRequest
;
MozPromiseRequestHolder
<
VideoDataPromise
>
mVideoDataRequest
;
MozPromiseRequestHolder
<
WaitForDataPromise
>
mAudioWaitRequest
;
MozPromiseRequestHolder
<
WaitForDataPromise
>
mVideoWaitRequest
;
private
:
WatchManager
<
MediaDecoderStateMachineBase
>
mWatchManager
;
}
;
}
#
endif
