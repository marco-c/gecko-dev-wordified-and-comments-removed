#
ifndef
MOZILLA_AUDIOSEGMENT_H_
#
define
MOZILLA_AUDIOSEGMENT_H_
#
include
<
speex
/
speex_resampler
.
h
>
#
include
"
AudioChannelFormat
.
h
"
#
include
"
AudioSampleFormat
.
h
"
#
include
"
MediaSegment
.
h
"
#
include
"
SharedBuffer
.
h
"
#
include
"
WebAudioUtils
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
nsAutoRef
.
h
"
#
ifdef
MOZILLA_INTERNAL_API
#
include
"
mozilla
/
TimeStamp
.
h
"
#
endif
#
include
<
float
.
h
>
namespace
mozilla
{
struct
AudioChunk
;
class
AudioSegment
;
}
MOZ_DECLARE_RELOCATE_USING_MOVE_CONSTRUCTOR
(
mozilla
:
:
AudioChunk
)
MOZ_DECLARE_RELOCATE_USING_MOVE_CONSTRUCTOR
(
mozilla
:
:
AudioSegment
)
namespace
mozilla
{
template
<
typename
T
>
class
SharedChannelArrayBuffer
:
public
ThreadSharedObject
{
public
:
explicit
SharedChannelArrayBuffer
(
nsTArray
<
nsTArray
<
T
>
>
&
&
aBuffers
)
:
mBuffers
(
std
:
:
move
(
aBuffers
)
)
{
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
size_t
amount
=
0
;
amount
+
=
mBuffers
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
size_t
i
=
0
;
i
<
mBuffers
.
Length
(
)
;
i
+
+
)
{
amount
+
=
mBuffers
[
i
]
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
return
amount
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
nsTArray
<
nsTArray
<
T
>
>
mBuffers
;
}
;
class
AudioMixer
;
const
int
GUESS_AUDIO_CHANNELS
=
2
;
const
uint32_t
WEBAUDIO_BLOCK_SIZE_BITS
=
7
;
const
uint32_t
WEBAUDIO_BLOCK_SIZE
=
1
<
<
WEBAUDIO_BLOCK_SIZE_BITS
;
template
<
typename
SrcT
typename
DestT
>
static
void
InterleaveAndConvertBuffer
(
const
SrcT
*
const
*
aSourceChannels
uint32_t
aLength
float
aVolume
uint32_t
aChannels
DestT
*
aOutput
)
{
DestT
*
output
=
aOutput
;
for
(
size_t
i
=
0
;
i
<
aLength
;
+
+
i
)
{
for
(
size_t
channel
=
0
;
channel
<
aChannels
;
+
+
channel
)
{
float
v
=
ConvertAudioSample
<
float
>
(
aSourceChannels
[
channel
]
[
i
]
)
*
aVolume
;
*
output
=
FloatToAudioSample
<
DestT
>
(
v
)
;
+
+
output
;
}
}
}
template
<
typename
SrcT
typename
DestT
>
static
void
DeinterleaveAndConvertBuffer
(
const
SrcT
*
aSourceBuffer
uint32_t
aFrames
uint32_t
aChannels
DestT
*
*
aOutput
)
{
for
(
size_t
i
=
0
;
i
<
aChannels
;
i
+
+
)
{
size_t
interleavedIndex
=
i
;
for
(
size_t
j
=
0
;
j
<
aFrames
;
j
+
+
)
{
aOutput
[
i
]
[
j
]
=
ConvertAudioSample
<
DestT
>
(
aSourceBuffer
[
interleavedIndex
]
)
;
interleavedIndex
+
=
aChannels
;
}
}
}
class
SilentChannel
{
public
:
static
const
int
AUDIO_PROCESSING_FRAMES
=
640
;
static
const
uint8_t
gZeroChannel
[
MAX_AUDIO_SAMPLE_SIZE
*
AUDIO_PROCESSING_FRAMES
]
;
template
<
typename
T
>
static
const
T
*
ZeroChannel
(
)
;
}
;
template
<
typename
SrcT
typename
DestT
>
void
DownmixAndInterleave
(
Span
<
const
SrcT
*
const
>
aChannelData
int32_t
aDuration
float
aVolume
uint32_t
aOutputChannels
DestT
*
aOutput
)
{
if
(
aChannelData
.
Length
(
)
=
=
aOutputChannels
)
{
InterleaveAndConvertBuffer
(
aChannelData
.
Elements
(
)
aDuration
aVolume
aOutputChannels
aOutput
)
;
}
else
{
AutoTArray
<
SrcT
*
GUESS_AUDIO_CHANNELS
>
outputChannelData
;
AutoTArray
<
SrcT
SilentChannel
:
:
AUDIO_PROCESSING_FRAMES
*
GUESS_AUDIO_CHANNELS
>
outputBuffers
;
outputChannelData
.
SetLength
(
aOutputChannels
)
;
outputBuffers
.
SetLength
(
aDuration
*
aOutputChannels
)
;
for
(
uint32_t
i
=
0
;
i
<
aOutputChannels
;
i
+
+
)
{
outputChannelData
[
i
]
=
outputBuffers
.
Elements
(
)
+
aDuration
*
i
;
}
AudioChannelsDownMix
<
SrcT
SrcT
>
(
aChannelData
outputChannelData
aDuration
)
;
InterleaveAndConvertBuffer
(
outputChannelData
.
Elements
(
)
aDuration
aVolume
aOutputChannels
aOutput
)
;
}
}
struct
AudioChunk
{
using
SampleFormat
=
mozilla
:
:
AudioSampleFormat
;
AudioChunk
(
)
=
default
;
template
<
typename
T
>
AudioChunk
(
already_AddRefed
<
ThreadSharedObject
>
aBuffer
const
nsTArray
<
const
T
*
>
&
aChannelData
TrackTime
aDuration
PrincipalHandle
aPrincipalHandle
)
:
mDuration
(
aDuration
)
mBuffer
(
aBuffer
)
mBufferFormat
(
AudioSampleTypeToFormat
<
T
>
:
:
Format
)
mPrincipalHandle
(
std
:
:
move
(
aPrincipalHandle
)
)
{
MOZ_ASSERT
(
!
mBuffer
=
=
aChannelData
.
IsEmpty
(
)
"
Appending
invalid
data
?
"
)
;
for
(
const
T
*
data
:
aChannelData
)
{
mChannelData
.
AppendElement
(
data
)
;
}
}
void
SliceTo
(
TrackTime
aStart
TrackTime
aEnd
)
{
MOZ_ASSERT
(
aStart
>
=
0
"
Slice
out
of
bounds
:
invalid
start
"
)
;
MOZ_ASSERT
(
aStart
<
aEnd
"
Slice
out
of
bounds
:
invalid
range
"
)
;
MOZ_ASSERT
(
aEnd
<
=
mDuration
"
Slice
out
of
bounds
:
invalid
end
"
)
;
if
(
mBuffer
)
{
MOZ_ASSERT
(
aStart
<
INT32_MAX
"
Can
'
t
slice
beyond
32
-
bit
sample
lengths
"
)
;
for
(
uint32_t
channel
=
0
;
channel
<
mChannelData
.
Length
(
)
;
+
+
channel
)
{
mChannelData
[
channel
]
=
AddAudioSampleOffset
(
mChannelData
[
channel
]
mBufferFormat
int32_t
(
aStart
)
)
;
}
}
mDuration
=
aEnd
-
aStart
;
}
TrackTime
GetDuration
(
)
const
{
return
mDuration
;
}
bool
CanCombineWithFollowing
(
const
AudioChunk
&
aOther
)
const
{
if
(
aOther
.
mBuffer
!
=
mBuffer
)
{
return
false
;
}
if
(
!
mBuffer
)
{
return
true
;
}
if
(
aOther
.
mVolume
!
=
mVolume
)
{
return
false
;
}
if
(
aOther
.
mPrincipalHandle
!
=
mPrincipalHandle
)
{
return
false
;
}
NS_ASSERTION
(
aOther
.
mBufferFormat
=
=
mBufferFormat
"
Wrong
metadata
about
buffer
"
)
;
NS_ASSERTION
(
aOther
.
mChannelData
.
Length
(
)
=
=
mChannelData
.
Length
(
)
"
Mismatched
channel
count
"
)
;
if
(
mDuration
>
INT32_MAX
)
{
return
false
;
}
for
(
uint32_t
channel
=
0
;
channel
<
mChannelData
.
Length
(
)
;
+
+
channel
)
{
if
(
aOther
.
mChannelData
[
channel
]
!
=
AddAudioSampleOffset
(
mChannelData
[
channel
]
mBufferFormat
int32_t
(
mDuration
)
)
)
{
return
false
;
}
}
return
true
;
}
bool
IsNull
(
)
const
{
return
mBuffer
=
=
nullptr
;
}
void
SetNull
(
TrackTime
aDuration
)
{
mBuffer
=
nullptr
;
mChannelData
.
Clear
(
)
;
mDuration
=
aDuration
;
mVolume
=
1
.
0f
;
mBufferFormat
=
AUDIO_FORMAT_SILENCE
;
mPrincipalHandle
=
PRINCIPAL_HANDLE_NONE
;
}
uint32_t
ChannelCount
(
)
const
{
return
mChannelData
.
Length
(
)
;
}
bool
IsMuted
(
)
const
{
return
mVolume
=
=
0
.
0f
;
}
size_t
SizeOfExcludingThisIfUnshared
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
SizeOfExcludingThis
(
aMallocSizeOf
true
)
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
bool
aUnshared
)
const
{
size_t
amount
=
0
;
if
(
mBuffer
&
&
(
!
aUnshared
|
|
!
mBuffer
-
>
IsShared
(
)
)
)
{
amount
+
=
mBuffer
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
amount
+
=
mChannelData
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
template
<
typename
T
>
Span
<
const
T
*
const
>
ChannelData
(
)
const
{
MOZ_ASSERT
(
AudioSampleTypeToFormat
<
T
>
:
:
Format
=
=
mBufferFormat
)
;
return
Span
(
reinterpret_cast
<
const
T
*
const
*
>
(
mChannelData
.
Elements
(
)
)
mChannelData
.
Length
(
)
)
;
}
template
<
typename
T
>
T
*
ChannelDataForWrite
(
size_t
aChannel
)
{
MOZ_ASSERT
(
AudioSampleTypeToFormat
<
T
>
:
:
Format
=
=
mBufferFormat
)
;
MOZ_ASSERT
(
!
mBuffer
-
>
IsShared
(
)
)
;
if
(
aChannel
>
=
mChannelData
.
Length
(
)
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Invalid
index
:
aChannel
:
%
zu
mChannelData
size
:
%
zu
\
n
"
aChannel
mChannelData
.
Length
(
)
)
;
}
return
static_cast
<
T
*
>
(
const_cast
<
void
*
>
(
mChannelData
[
aChannel
]
)
)
;
}
template
<
typename
T
>
static
AudioChunk
FromInterleavedBuffer
(
const
T
*
aBuffer
size_t
aFrames
uint32_t
aChannels
const
PrincipalHandle
&
aPrincipalHandle
)
{
CheckedInt
<
size_t
>
bufferSize
(
sizeof
(
T
)
)
;
bufferSize
*
=
aFrames
;
bufferSize
*
=
aChannels
;
RefPtr
<
SharedBuffer
>
buffer
=
SharedBuffer
:
:
Create
(
bufferSize
)
;
AutoTArray
<
T
*
8
>
deinterleaved
;
if
(
aChannels
=
=
1
)
{
PodCopy
(
static_cast
<
T
*
>
(
buffer
-
>
Data
(
)
)
aBuffer
aFrames
)
;
deinterleaved
.
AppendElement
(
static_cast
<
T
*
>
(
buffer
-
>
Data
(
)
)
)
;
}
else
{
deinterleaved
.
SetLength
(
aChannels
)
;
T
*
samples
=
static_cast
<
T
*
>
(
buffer
-
>
Data
(
)
)
;
size_t
offset
=
0
;
for
(
uint32_t
i
=
0
;
i
<
aChannels
;
+
+
i
)
{
deinterleaved
[
i
]
=
samples
+
offset
;
offset
+
=
aFrames
;
}
DeinterleaveAndConvertBuffer
(
aBuffer
static_cast
<
uint32_t
>
(
aFrames
)
aChannels
deinterleaved
.
Elements
(
)
)
;
}
AutoTArray
<
const
T
*
GUESS_AUDIO_CHANNELS
>
channelData
;
channelData
.
AppendElements
(
deinterleaved
)
;
return
AudioChunk
(
buffer
.
forget
(
)
channelData
static_cast
<
TrackTime
>
(
aFrames
)
aPrincipalHandle
)
;
}
const
PrincipalHandle
&
GetPrincipalHandle
(
)
const
{
return
mPrincipalHandle
;
}
void
DownMixTo
(
Span
<
AudioDataValue
*
const
>
aOutputChannels
)
const
;
TrackTime
mDuration
=
0
;
RefPtr
<
ThreadSharedObject
>
mBuffer
;
CopyableAutoTArray
<
const
void
*
GUESS_AUDIO_CHANNELS
>
mChannelData
;
float
mVolume
=
1
.
0f
;
SampleFormat
mBufferFormat
=
AUDIO_FORMAT_SILENCE
;
PrincipalHandle
mPrincipalHandle
=
PRINCIPAL_HANDLE_NONE
;
}
;
class
AudioSegment
final
:
public
MediaSegmentBase
<
AudioSegment
AudioChunk
>
{
uint32_t
mMemoizedMaxChannelCount
=
0
;
public
:
typedef
mozilla
:
:
AudioSampleFormat
SampleFormat
;
AudioSegment
(
)
:
MediaSegmentBase
<
AudioSegment
AudioChunk
>
(
AUDIO
)
{
}
AudioSegment
(
AudioSegment
&
&
aSegment
)
=
default
;
AudioSegment
(
const
AudioSegment
&
)
=
delete
;
AudioSegment
&
operator
=
(
const
AudioSegment
&
)
=
delete
;
~
AudioSegment
(
)
=
default
;
void
ResampleChunks
(
nsAutoRef
<
SpeexResamplerState
>
&
aResampler
uint32_t
*
aResamplerChannelCount
uint32_t
aInRate
uint32_t
aOutRate
)
;
template
<
typename
T
>
void
AppendFrames
(
already_AddRefed
<
ThreadSharedObject
>
aBuffer
const
nsTArray
<
const
T
*
>
&
aChannelData
TrackTime
aDuration
const
PrincipalHandle
&
aPrincipalHandle
)
{
AppendAndConsumeChunk
(
AudioChunk
(
std
:
:
move
(
aBuffer
)
aChannelData
aDuration
aPrincipalHandle
)
)
;
}
void
AppendSegment
(
const
AudioSegment
*
aSegment
)
{
MOZ_ASSERT
(
aSegment
)
;
for
(
const
AudioChunk
&
c
:
aSegment
-
>
mChunks
)
{
AudioChunk
*
chunk
=
AppendChunk
(
c
.
GetDuration
(
)
)
;
chunk
-
>
mBuffer
=
c
.
mBuffer
;
chunk
-
>
mChannelData
=
c
.
mChannelData
;
chunk
-
>
mBufferFormat
=
c
.
mBufferFormat
;
chunk
-
>
mPrincipalHandle
=
c
.
mPrincipalHandle
;
}
}
template
<
typename
T
>
void
AppendFromInterleavedBuffer
(
const
T
*
aBuffer
size_t
aFrames
uint32_t
aChannels
const
PrincipalHandle
&
aPrincipalHandle
)
{
AppendAndConsumeChunk
(
AudioChunk
:
:
FromInterleavedBuffer
<
T
>
(
aBuffer
aFrames
aChannels
aPrincipalHandle
)
)
;
}
size_t
WriteToInterleavedBuffer
(
nsTArray
<
AudioDataValue
>
&
aBuffer
uint32_t
aChannels
)
const
;
void
AppendAndConsumeChunk
(
AudioChunk
&
&
aChunk
)
{
AudioChunk
unused
;
AudioChunk
*
chunk
=
&
unused
;
auto
consume
=
MakeScopeExit
(
[
&
]
{
chunk
-
>
mBuffer
=
std
:
:
move
(
aChunk
.
mBuffer
)
;
chunk
-
>
mChannelData
=
std
:
:
move
(
aChunk
.
mChannelData
)
;
MOZ_ASSERT
(
chunk
-
>
mBuffer
|
|
chunk
-
>
mChannelData
.
IsEmpty
(
)
"
Appending
invalid
data
?
"
)
;
chunk
-
>
mVolume
=
aChunk
.
mVolume
;
chunk
-
>
mBufferFormat
=
aChunk
.
mBufferFormat
;
chunk
-
>
mPrincipalHandle
=
std
:
:
move
(
aChunk
.
mPrincipalHandle
)
;
}
)
;
if
(
aChunk
.
GetDuration
(
)
=
=
0
)
{
return
;
}
if
(
!
mChunks
.
IsEmpty
(
)
&
&
mChunks
.
LastElement
(
)
.
CanCombineWithFollowing
(
aChunk
)
)
{
mChunks
.
LastElement
(
)
.
mDuration
+
=
aChunk
.
GetDuration
(
)
;
mDuration
+
=
aChunk
.
GetDuration
(
)
;
return
;
}
chunk
=
AppendChunk
(
aChunk
.
mDuration
)
;
}
void
ApplyVolume
(
float
aVolume
)
;
void
Mix
(
AudioMixer
&
aMixer
uint32_t
aChannelCount
uint32_t
aSampleRate
)
;
uint32_t
MaxChannelCount
(
)
{
uint32_t
channelCount
=
0
;
for
(
ChunkIterator
ci
(
*
this
)
;
!
ci
.
IsEnded
(
)
;
ci
.
Next
(
)
)
{
if
(
ci
-
>
ChannelCount
(
)
)
{
channelCount
=
std
:
:
max
(
channelCount
ci
-
>
ChannelCount
(
)
)
;
}
}
if
(
channelCount
=
=
0
)
{
return
mMemoizedMaxChannelCount
;
}
return
mMemoizedMaxChannelCount
=
channelCount
;
}
static
Type
StaticType
(
)
{
return
AUDIO
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
PrincipalHandle
GetOldestPrinciple
(
)
const
{
const
AudioChunk
*
chunk
=
mChunks
.
IsEmpty
(
)
?
nullptr
:
&
mChunks
[
0
]
;
return
chunk
?
chunk
-
>
GetPrincipalHandle
(
)
:
PRINCIPAL_HANDLE_NONE
;
}
template
<
typename
Function
>
void
IterateOnChunks
(
const
Function
&
&
aFunction
)
{
for
(
uint32_t
idx
=
0
;
idx
<
mChunks
.
Length
(
)
;
idx
+
+
)
{
if
(
aFunction
(
&
mChunks
[
idx
]
)
)
{
return
;
}
}
}
private
:
template
<
typename
T
>
void
Resample
(
nsAutoRef
<
SpeexResamplerState
>
&
aResampler
uint32_t
*
aResamplerChannelCount
uint32_t
aInRate
uint32_t
aOutRate
)
;
}
;
template
<
typename
SrcT
>
void
WriteChunk
(
const
AudioChunk
&
aChunk
uint32_t
aOutputChannels
float
aVolume
AudioDataValue
*
aOutputBuffer
)
{
CopyableAutoTArray
<
const
SrcT
*
GUESS_AUDIO_CHANNELS
>
channelData
;
channelData
.
AppendElements
(
aChunk
.
ChannelData
<
SrcT
>
(
)
)
;
if
(
channelData
.
Length
(
)
<
aOutputChannels
)
{
AudioChannelsUpMix
(
&
channelData
aOutputChannels
SilentChannel
:
:
ZeroChannel
<
SrcT
>
(
)
)
;
}
if
(
channelData
.
Length
(
)
>
aOutputChannels
)
{
DownmixAndInterleave
<
SrcT
>
(
channelData
aChunk
.
mDuration
aVolume
aOutputChannels
aOutputBuffer
)
;
}
else
{
InterleaveAndConvertBuffer
(
channelData
.
Elements
(
)
aChunk
.
mDuration
aVolume
aOutputChannels
aOutputBuffer
)
;
}
}
}
#
endif
