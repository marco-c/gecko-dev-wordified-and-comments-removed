#
include
"
EncodedBufferCache
.
h
"
#
include
"
prio
.
h
"
#
include
"
nsAnonymousTemporaryFile
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
namespace
mozilla
{
void
EncodedBufferCache
:
:
AppendBuffer
(
nsTArray
<
uint8_t
>
&
aBuf
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
mDataSize
+
=
aBuf
.
Length
(
)
;
mEncodedBuffers
.
AppendElement
(
)
-
>
SwapElements
(
aBuf
)
;
if
(
!
mTempFileEnabled
&
&
mDataSize
>
mMaxMemoryStorage
)
{
nsresult
rv
;
PRFileDesc
*
tempFD
=
nullptr
;
{
MutexAutoUnlock
unlock
(
mMutex
)
;
if
(
XRE_IsParentProcess
(
)
)
{
rv
=
NS_OpenAnonymousTemporaryFile
(
&
tempFD
)
;
}
else
{
typedef
dom
:
:
ContentChild
:
:
AnonymousTemporaryFileCallback
AnonymousTemporaryFileCallback
;
bool
done
=
false
;
Monitor
monitor
(
"
EncodeBufferCache
:
:
AppendBuffer
"
)
;
RefPtr
<
dom
:
:
ContentChild
>
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
<
AnonymousTemporaryFileCallback
>
(
"
dom
:
:
ContentChild
:
:
AsyncOpenAnonymousTemporaryFile
"
cc
&
dom
:
:
ContentChild
:
:
AsyncOpenAnonymousTemporaryFile
[
&
]
(
PRFileDesc
*
aFile
)
{
rv
=
aFile
?
NS_OK
:
NS_ERROR_FAILURE
;
tempFD
=
aFile
;
MonitorAutoLock
lock
(
monitor
)
;
done
=
true
;
lock
.
Notify
(
)
;
}
)
;
MonitorAutoLock
lock
(
monitor
)
;
rv
=
NS_DispatchToMainThread
(
runnable
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
while
(
!
done
)
{
lock
.
Wait
(
)
;
}
}
}
}
if
(
!
NS_FAILED
(
rv
)
)
{
if
(
mDataSize
>
mMaxMemoryStorage
)
{
mFD
=
tempFD
;
mTempFileEnabled
=
true
;
}
else
{
PR_Close
(
tempFD
)
;
}
}
}
if
(
mTempFileEnabled
)
{
for
(
uint32_t
i
=
0
;
i
<
mEncodedBuffers
.
Length
(
)
;
i
+
+
)
{
int32_t
amount
=
PR_Write
(
mFD
mEncodedBuffers
.
ElementAt
(
i
)
.
Elements
(
)
mEncodedBuffers
.
ElementAt
(
i
)
.
Length
(
)
)
;
if
(
amount
<
0
|
|
size_t
(
amount
)
<
mEncodedBuffers
.
ElementAt
(
i
)
.
Length
(
)
)
{
NS_WARNING
(
"
Failed
to
write
media
cache
block
!
"
)
;
}
}
mEncodedBuffers
.
Clear
(
)
;
}
}
already_AddRefed
<
dom
:
:
Blob
>
EncodedBufferCache
:
:
ExtractBlob
(
nsISupports
*
aParent
const
nsAString
&
aContentType
)
{
MutexAutoLock
lock
(
mMutex
)
;
RefPtr
<
dom
:
:
Blob
>
blob
;
if
(
mTempFileEnabled
)
{
blob
=
dom
:
:
Blob
:
:
CreateTemporaryBlob
(
aParent
mFD
0
mDataSize
aContentType
)
;
mTempFileEnabled
=
false
;
mDataSize
=
0
;
mFD
=
nullptr
;
}
else
{
void
*
blobData
=
malloc
(
mDataSize
)
;
NS_ASSERTION
(
blobData
"
out
of
memory
!
!
"
)
;
if
(
blobData
)
{
for
(
uint32_t
i
=
0
offset
=
0
;
i
<
mEncodedBuffers
.
Length
(
)
;
i
+
+
)
{
memcpy
(
(
uint8_t
*
)
blobData
+
offset
mEncodedBuffers
.
ElementAt
(
i
)
.
Elements
(
)
mEncodedBuffers
.
ElementAt
(
i
)
.
Length
(
)
)
;
offset
+
=
mEncodedBuffers
.
ElementAt
(
i
)
.
Length
(
)
;
}
blob
=
dom
:
:
Blob
:
:
CreateMemoryBlob
(
aParent
blobData
mDataSize
aContentType
)
;
mEncodedBuffers
.
Clear
(
)
;
}
else
return
nullptr
;
}
mDataSize
=
0
;
return
blob
.
forget
(
)
;
}
size_t
EncodedBufferCache
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mEncodedBuffers
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
}
