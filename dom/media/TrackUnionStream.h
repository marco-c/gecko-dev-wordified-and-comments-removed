#
ifndef
MOZILLA_TRACKUNIONSTREAM_H_
#
define
MOZILLA_TRACKUNIONSTREAM_H_
#
include
"
MediaStreamGraph
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
class
TrackUnionStream
:
public
ProcessedMediaStream
{
public
:
explicit
TrackUnionStream
(
)
;
virtual
TrackUnionStream
*
AsTrackUnionStream
(
)
override
{
return
this
;
}
friend
class
DOMMediaStream
;
void
RemoveInput
(
MediaInputPort
*
aPort
)
override
;
void
ProcessInput
(
GraphTime
aFrom
GraphTime
aTo
uint32_t
aFlags
)
override
;
void
SetTrackEnabledImpl
(
TrackID
aTrackID
bool
aEnabled
)
override
;
MediaStream
*
GetInputStreamFor
(
TrackID
aTrackID
)
override
;
TrackID
GetInputTrackIDFor
(
TrackID
aTrackID
)
override
;
friend
class
MediaStreamGraphImpl
;
protected
:
struct
TrackMapEntry
{
StreamTime
mEndOfConsumedInputTicks
;
StreamTime
mEndOfLastInputIntervalInInputStream
;
StreamTime
mEndOfLastInputIntervalInOutputStream
;
MediaInputPort
*
mInputPort
;
TrackID
mInputTrackID
;
TrackID
mOutputTrackID
;
nsAutoPtr
<
MediaSegment
>
mSegment
;
nsTArray
<
RefPtr
<
DirectMediaStreamTrackListener
>
>
mOwnedDirectListeners
;
}
;
uint32_t
AddTrack
(
MediaInputPort
*
aPort
StreamTracks
:
:
Track
*
aTrack
GraphTime
aFrom
)
;
void
EndTrack
(
uint32_t
aIndex
)
;
void
CopyTrackData
(
StreamTracks
:
:
Track
*
aInputTrack
uint32_t
aMapIndex
GraphTime
aFrom
GraphTime
aTo
bool
*
aOutputTrackFinished
)
;
void
AddDirectTrackListenerImpl
(
already_AddRefed
<
DirectMediaStreamTrackListener
>
aListener
TrackID
aTrackID
)
override
;
void
RemoveDirectTrackListenerImpl
(
DirectMediaStreamTrackListener
*
aListener
TrackID
aTrackID
)
override
;
nsTArray
<
TrackMapEntry
>
mTrackMap
;
TrackID
mNextAvailableTrackID
;
nsTArray
<
TrackID
>
mUsedTracks
;
nsTArray
<
TrackBound
<
DirectMediaStreamTrackListener
>
>
mPendingDirectTrackListeners
;
}
;
}
#
endif
