#
include
"
XiphExtradata
.
h
"
namespace
mozilla
{
bool
XiphHeadersToExtradata
(
MediaByteBuffer
*
aCodecSpecificConfig
const
nsTArray
<
const
unsigned
char
*
>
&
aHeaders
const
nsTArray
<
size_t
>
&
aHeaderLens
)
{
size_t
nheaders
=
aHeaders
.
Length
(
)
;
if
(
!
nheaders
|
|
nheaders
>
255
)
return
false
;
aCodecSpecificConfig
-
>
AppendElement
(
nheaders
-
1
)
;
for
(
size_t
i
=
0
;
i
<
nheaders
-
1
;
i
+
+
)
{
size_t
headerLen
;
for
(
headerLen
=
aHeaderLens
[
i
]
;
headerLen
>
=
255
;
headerLen
-
=
255
)
{
aCodecSpecificConfig
-
>
AppendElement
(
255
)
;
}
aCodecSpecificConfig
-
>
AppendElement
(
headerLen
)
;
}
for
(
size_t
i
=
0
;
i
<
nheaders
;
i
+
+
)
{
aCodecSpecificConfig
-
>
AppendElements
(
aHeaders
[
i
]
aHeaderLens
[
i
]
)
;
}
return
true
;
}
bool
XiphExtradataToHeaders
(
nsTArray
<
unsigned
char
*
>
&
aHeaders
nsTArray
<
size_t
>
&
aHeaderLens
unsigned
char
*
aData
size_t
aAvailable
)
{
size_t
total
=
0
;
if
(
aAvailable
<
1
)
{
return
false
;
}
aAvailable
-
-
;
int
nHeaders
=
*
aData
+
+
+
1
;
for
(
int
i
=
0
;
i
<
nHeaders
-
1
;
i
+
+
)
{
size_t
headerLen
=
0
;
for
(
;
;
)
{
if
(
aAvailable
-
total
<
=
headerLen
)
{
return
false
;
}
headerLen
+
=
*
aData
;
aAvailable
-
-
;
if
(
*
aData
+
+
!
=
255
)
break
;
}
if
(
aAvailable
-
total
<
headerLen
)
{
return
false
;
}
aHeaderLens
.
AppendElement
(
headerLen
)
;
total
+
=
headerLen
;
}
aHeaderLens
.
AppendElement
(
aAvailable
-
total
)
;
for
(
int
i
=
0
;
i
<
nHeaders
;
i
+
+
)
{
aHeaders
.
AppendElement
(
aData
)
;
aData
+
=
aHeaderLens
[
i
]
;
}
return
true
;
}
}
