#
ifndef
CALLBACKTHREADREGISTRY_H
#
define
CALLBACKTHREADREGISTRY_H
#
include
<
cstdint
>
#
include
<
mozilla
/
DataMutex
.
h
>
#
include
<
nsTArray
.
h
>
#
include
<
thread
>
#
include
<
GeckoProfiler
.
h
>
namespace
mozilla
{
class
CallbackThreadRegistry
final
{
public
:
CallbackThreadRegistry
(
)
;
~
CallbackThreadRegistry
(
)
{
}
static
CallbackThreadRegistry
*
Get
(
)
;
void
Register
(
ProfilerThreadId
aThreadId
const
char
*
aName
)
{
if
(
!
aThreadId
.
IsSpecified
(
)
)
{
return
;
}
auto
threadIds
=
mThreadIds
.
Lock
(
)
;
for
(
uint32_t
i
=
0
;
i
<
threadIds
-
>
Length
(
)
;
i
+
+
)
{
if
(
(
*
threadIds
)
[
i
]
.
mId
=
=
aThreadId
)
{
(
*
threadIds
)
[
i
]
.
mUserCount
+
+
;
return
;
}
}
ThreadUserCount
tuc
;
tuc
.
mId
=
aThreadId
;
tuc
.
mUserCount
=
1
;
threadIds
-
>
AppendElement
(
tuc
)
;
PROFILER_REGISTER_THREAD
(
aName
)
;
}
void
Unregister
(
ProfilerThreadId
aThreadId
)
{
if
(
!
aThreadId
.
IsSpecified
(
)
)
{
return
;
}
auto
threadIds
=
mThreadIds
.
Lock
(
)
;
for
(
uint32_t
i
=
0
;
i
<
threadIds
-
>
Length
(
)
;
i
+
+
)
{
if
(
(
*
threadIds
)
[
i
]
.
mId
=
=
aThreadId
)
{
MOZ_ASSERT
(
(
*
threadIds
)
[
i
]
.
mUserCount
>
0
)
;
(
*
threadIds
)
[
i
]
.
mUserCount
-
-
;
if
(
(
*
threadIds
)
[
i
]
.
mUserCount
=
=
0
)
{
PROFILER_UNREGISTER_THREAD
(
)
;
threadIds
-
>
RemoveElementAt
(
i
)
;
}
return
;
}
}
MOZ_ASSERT
(
false
)
;
}
CallbackThreadRegistry
(
const
CallbackThreadRegistry
&
)
=
delete
;
CallbackThreadRegistry
&
operator
=
(
const
CallbackThreadRegistry
&
)
=
delete
;
CallbackThreadRegistry
(
CallbackThreadRegistry
&
&
)
=
delete
;
CallbackThreadRegistry
&
operator
=
(
CallbackThreadRegistry
&
&
)
=
delete
;
private
:
struct
ThreadUserCount
{
ProfilerThreadId
mId
;
int
mUserCount
=
0
;
}
;
DataMutex
<
nsTArray
<
ThreadUserCount
>
>
mThreadIds
;
}
;
}
#
endif
