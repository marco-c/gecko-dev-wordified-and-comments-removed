#
ifndef
TIME_UNITS_H
#
define
TIME_UNITS_H
#
include
<
type_traits
>
#
include
"
Intervals
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
namespace
mozilla
:
:
media
{
class
TimeIntervals
;
}
template
<
>
struct
nsTArray_RelocationStrategy
<
mozilla
:
:
media
:
:
TimeIntervals
>
{
using
Type
=
nsTArray_RelocateUsingMoveConstructor
<
mozilla
:
:
media
:
:
TimeIntervals
>
;
}
;
namespace
mozilla
{
static
const
int64_t
USECS_PER_S
=
1000000
;
static
const
int64_t
USECS_PER_MS
=
1000
;
namespace
media
{
static
const
int64_t
NSECS_PER_S
=
1000000000
;
#
ifndef
PROCESS_DECODE_LOG
#
define
PROCESS_DECODE_LOG
(
sample
)
\
MOZ_LOG
(
sPDMLog
mozilla
:
:
LogLevel
:
:
Verbose
\
(
"
ProcessDecode
:
mDuration
=
%
"
PRIu64
"
s
;
mTime
=
%
"
PRIu64
\
"
s
;
mTimecode
=
%
"
PRIu64
"
s
"
\
(
sample
)
-
>
mDuration
.
ToMicroseconds
(
)
\
(
sample
)
-
>
mTime
.
ToMicroseconds
(
)
\
(
sample
)
-
>
mTimecode
.
ToMicroseconds
(
)
)
)
#
endif
class
TimeUnit
final
{
public
:
static
TimeUnit
FromSeconds
(
double
aValue
)
{
MOZ_ASSERT
(
!
std
:
:
isnan
(
aValue
)
)
;
if
(
std
:
:
isinf
(
aValue
)
)
{
return
aValue
>
0
?
FromInfinity
(
)
:
FromNegativeInfinity
(
)
;
}
double
halfUsec
=
.
0000005
;
double
val
=
(
aValue
<
=
0
?
aValue
-
halfUsec
:
aValue
+
halfUsec
)
*
USECS_PER_S
;
if
(
val
>
=
double
(
INT64_MAX
)
)
{
return
FromMicroseconds
(
INT64_MAX
)
;
}
if
(
val
<
=
double
(
INT64_MIN
)
)
{
return
FromMicroseconds
(
INT64_MIN
)
;
}
return
FromMicroseconds
(
int64_t
(
val
)
)
;
}
static
constexpr
TimeUnit
FromMicroseconds
(
int64_t
aValue
)
{
return
TimeUnit
(
aValue
)
;
}
static
constexpr
TimeUnit
FromNanoseconds
(
int64_t
aValue
)
{
return
TimeUnit
(
aValue
/
1000
)
;
}
static
constexpr
TimeUnit
FromInfinity
(
)
{
return
TimeUnit
(
INT64_MAX
)
;
}
static
constexpr
TimeUnit
FromNegativeInfinity
(
)
{
return
TimeUnit
(
INT64_MIN
)
;
}
static
TimeUnit
FromTimeDuration
(
const
TimeDuration
&
aDuration
)
{
return
FromSeconds
(
aDuration
.
ToSeconds
(
)
)
;
}
static
constexpr
TimeUnit
Zero
(
)
{
return
TimeUnit
(
0
)
;
}
static
TimeUnit
Invalid
(
)
{
TimeUnit
ret
;
ret
.
mValue
=
CheckedInt64
(
INT64_MAX
)
;
ret
.
mValue
+
=
1
;
return
ret
;
}
int64_t
ToMicroseconds
(
)
const
{
return
mValue
.
value
(
)
;
}
int64_t
ToNanoseconds
(
)
const
{
return
mValue
.
value
(
)
*
1000
;
}
double
ToSeconds
(
)
const
{
if
(
IsPosInf
(
)
)
{
return
PositiveInfinity
<
double
>
(
)
;
}
if
(
IsNegInf
(
)
)
{
return
NegativeInfinity
<
double
>
(
)
;
}
return
double
(
mValue
.
value
(
)
)
/
USECS_PER_S
;
}
TimeDuration
ToTimeDuration
(
)
const
{
return
TimeDuration
:
:
FromMicroseconds
(
mValue
.
value
(
)
)
;
}
bool
IsInfinite
(
)
const
{
return
IsPosInf
(
)
|
|
IsNegInf
(
)
;
}
bool
IsPositive
(
)
const
{
return
mValue
.
value
(
)
>
0
;
}
bool
IsNegative
(
)
const
{
return
mValue
.
value
(
)
<
0
;
}
bool
operator
=
=
(
const
TimeUnit
&
aOther
)
const
{
MOZ_ASSERT
(
IsValid
(
)
&
&
aOther
.
IsValid
(
)
)
;
return
mValue
.
value
(
)
=
=
aOther
.
mValue
.
value
(
)
;
}
bool
operator
!
=
(
const
TimeUnit
&
aOther
)
const
{
MOZ_ASSERT
(
IsValid
(
)
&
&
aOther
.
IsValid
(
)
)
;
return
mValue
.
value
(
)
!
=
aOther
.
mValue
.
value
(
)
;
}
bool
operator
>
=
(
const
TimeUnit
&
aOther
)
const
{
MOZ_ASSERT
(
IsValid
(
)
&
&
aOther
.
IsValid
(
)
)
;
return
mValue
.
value
(
)
>
=
aOther
.
mValue
.
value
(
)
;
}
bool
operator
>
(
const
TimeUnit
&
aOther
)
const
{
return
!
(
*
this
<
=
aOther
)
;
}
bool
operator
<
=
(
const
TimeUnit
&
aOther
)
const
{
MOZ_ASSERT
(
IsValid
(
)
&
&
aOther
.
IsValid
(
)
)
;
return
mValue
.
value
(
)
<
=
aOther
.
mValue
.
value
(
)
;
}
bool
operator
<
(
const
TimeUnit
&
aOther
)
const
{
return
!
(
*
this
>
=
aOther
)
;
}
TimeUnit
operator
%
(
const
TimeUnit
&
aOther
)
const
{
MOZ_ASSERT
(
IsValid
(
)
&
&
aOther
.
IsValid
(
)
)
;
return
TimeUnit
(
mValue
%
aOther
.
mValue
)
;
}
TimeUnit
operator
+
(
const
TimeUnit
&
aOther
)
const
{
if
(
IsInfinite
(
)
|
|
aOther
.
IsInfinite
(
)
)
{
double
result
=
ToSeconds
(
)
+
aOther
.
ToSeconds
(
)
;
return
std
:
:
isnan
(
result
)
?
TimeUnit
:
:
Invalid
(
)
:
FromSeconds
(
result
)
;
}
return
TimeUnit
(
mValue
+
aOther
.
mValue
)
;
}
TimeUnit
operator
-
(
const
TimeUnit
&
aOther
)
const
{
if
(
IsInfinite
(
)
|
|
aOther
.
IsInfinite
(
)
)
{
double
result
=
ToSeconds
(
)
-
aOther
.
ToSeconds
(
)
;
return
std
:
:
isnan
(
result
)
?
TimeUnit
:
:
Invalid
(
)
:
FromSeconds
(
result
)
;
}
MOZ_ASSERT
(
!
IsInfinite
(
)
&
&
!
aOther
.
IsInfinite
(
)
)
;
return
TimeUnit
(
mValue
-
aOther
.
mValue
)
;
}
TimeUnit
&
operator
+
=
(
const
TimeUnit
&
aOther
)
{
*
this
=
*
this
+
aOther
;
return
*
this
;
}
TimeUnit
&
operator
-
=
(
const
TimeUnit
&
aOther
)
{
*
this
=
*
this
-
aOther
;
return
*
this
;
}
template
<
typename
T
>
TimeUnit
operator
*
(
T
aVal
)
const
{
static_assert
(
std
:
:
is_integral_v
<
T
>
"
Must
be
an
integral
type
"
)
;
return
TimeUnit
(
mValue
*
aVal
)
;
}
TimeUnit
MultDouble
(
double
aVal
)
const
{
return
TimeUnit
:
:
FromSeconds
(
ToSeconds
(
)
*
aVal
)
;
}
friend
TimeUnit
operator
/
(
const
TimeUnit
&
aUnit
int64_t
aVal
)
{
MOZ_DIAGNOSTIC_ASSERT
(
0
<
=
aVal
&
&
aVal
<
=
UINT32_MAX
)
;
return
TimeUnit
(
aUnit
.
mValue
/
aVal
)
;
}
friend
TimeUnit
operator
%
(
const
TimeUnit
&
aUnit
int64_t
aVal
)
{
MOZ_DIAGNOSTIC_ASSERT
(
0
<
=
aVal
&
&
aVal
<
=
UINT32_MAX
)
;
return
TimeUnit
(
aUnit
.
mValue
%
aVal
)
;
}
bool
IsValid
(
)
const
{
return
mValue
.
isValid
(
)
;
}
constexpr
TimeUnit
(
)
=
default
;
TimeUnit
(
const
TimeUnit
&
)
=
default
;
TimeUnit
&
operator
=
(
const
TimeUnit
&
)
=
default
;
bool
IsPosInf
(
)
const
{
return
mValue
.
isValid
(
)
&
&
mValue
.
value
(
)
=
=
INT64_MAX
;
}
bool
IsNegInf
(
)
const
{
return
mValue
.
isValid
(
)
&
&
mValue
.
value
(
)
=
=
INT64_MIN
;
}
private
:
explicit
constexpr
TimeUnit
(
CheckedInt64
aMicroseconds
)
:
mValue
(
aMicroseconds
)
{
}
CheckedInt64
mValue
{
0
}
;
}
;
typedef
Maybe
<
TimeUnit
>
NullableTimeUnit
;
typedef
Interval
<
TimeUnit
>
TimeInterval
;
class
TimeIntervals
:
public
IntervalSet
<
TimeUnit
>
{
public
:
typedef
IntervalSet
<
TimeUnit
>
BaseType
;
MOZ_IMPLICIT
TimeIntervals
(
const
BaseType
&
aOther
)
:
BaseType
(
aOther
)
{
}
MOZ_IMPLICIT
TimeIntervals
(
BaseType
&
&
aOther
)
:
BaseType
(
std
:
:
move
(
aOther
)
)
{
}
explicit
TimeIntervals
(
const
BaseType
:
:
ElemType
&
aOther
)
:
BaseType
(
aOther
)
{
}
explicit
TimeIntervals
(
BaseType
:
:
ElemType
&
&
aOther
)
:
BaseType
(
std
:
:
move
(
aOther
)
)
{
}
static
TimeIntervals
Invalid
(
)
{
return
TimeIntervals
(
TimeInterval
(
TimeUnit
:
:
FromNegativeInfinity
(
)
TimeUnit
:
:
FromNegativeInfinity
(
)
)
)
;
}
bool
IsInvalid
(
)
const
{
return
Length
(
)
=
=
1
&
&
Start
(
0
)
.
IsNegInf
(
)
&
&
End
(
0
)
.
IsNegInf
(
)
;
}
TimeIntervals
(
)
=
default
;
}
;
}
}
#
endif
