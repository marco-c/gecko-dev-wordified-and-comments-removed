#
ifndef
TIME_UNITS_H
#
define
TIME_UNITS_H
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
Intervals
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
nsPrintfCString
.
h
"
namespace
mozilla
:
:
media
{
class
TimeIntervals
;
}
template
<
>
struct
nsTArray_RelocationStrategy
<
mozilla
:
:
media
:
:
TimeIntervals
>
{
using
Type
=
nsTArray_RelocateUsingMoveConstructor
<
mozilla
:
:
media
:
:
TimeIntervals
>
;
}
;
namespace
mozilla
{
static
const
int64_t
MSECS_PER_S
=
1000
;
static
const
int64_t
USECS_PER_S
=
1000000
;
static
const
int64_t
NSECS_PER_S
=
1000000000
;
namespace
media
{
#
ifndef
PROCESS_DECODE_LOG
#
define
PROCESS_DECODE_LOG
(
sample
)
\
MOZ_LOG
(
sPDMLog
mozilla
:
:
LogLevel
:
:
Verbose
\
(
"
ProcessDecode
:
mDuration
=
%
"
PRIu64
"
s
;
mTime
=
%
"
PRIu64
\
"
s
;
mTimecode
=
%
"
PRIu64
"
s
"
\
(
sample
)
-
>
mDuration
.
ToMicroseconds
(
)
\
(
sample
)
-
>
mTime
.
ToMicroseconds
(
)
\
(
sample
)
-
>
mTimecode
.
ToMicroseconds
(
)
)
)
#
endif
class
TimeUnit
final
{
public
:
constexpr
TimeUnit
(
CheckedInt64
aTicks
int64_t
aBase
)
:
mTicks
(
aTicks
)
mBase
(
aBase
)
{
MOZ_RELEASE_ASSERT
(
mBase
>
0
)
;
}
explicit
constexpr
TimeUnit
(
CheckedInt64
aTicks
)
:
mTicks
(
aTicks
)
mBase
(
USECS_PER_S
)
{
}
static
TimeUnit
FromSeconds
(
double
aValue
int64_t
aBase
=
USECS_PER_S
)
;
static
constexpr
TimeUnit
FromMicroseconds
(
int64_t
aValue
)
{
return
TimeUnit
(
aValue
USECS_PER_S
)
;
}
static
constexpr
TimeUnit
FromNanoseconds
(
int64_t
aValue
)
{
return
TimeUnit
(
aValue
NSECS_PER_S
)
;
}
static
TimeUnit
FromInfinity
(
)
;
static
TimeUnit
FromNegativeInfinity
(
)
;
static
TimeUnit
FromTimeDuration
(
const
TimeDuration
&
aDuration
)
;
static
constexpr
TimeUnit
Zero
(
int64_t
aBase
=
USECS_PER_S
)
{
return
TimeUnit
(
0
aBase
)
;
}
static
TimeUnit
Invalid
(
)
;
int64_t
ToMilliseconds
(
)
const
;
int64_t
ToMicroseconds
(
)
const
;
int64_t
ToNanoseconds
(
)
const
;
int64_t
ToTicksAtRate
(
int64_t
aRate
)
const
;
double
ToSeconds
(
)
const
;
nsCString
ToString
(
)
const
;
TimeDuration
ToTimeDuration
(
)
const
;
bool
IsInfinite
(
)
const
;
bool
IsPositive
(
)
const
;
bool
IsPositiveOrZero
(
)
const
;
bool
IsZero
(
)
const
;
bool
IsNegative
(
)
const
;
bool
EqualsAtLowestResolution
(
const
TimeUnit
&
aOther
)
const
;
bool
operator
=
=
(
const
TimeUnit
&
aOther
)
const
;
bool
operator
!
=
(
const
TimeUnit
&
aOther
)
const
;
bool
operator
>
=
(
const
TimeUnit
&
aOther
)
const
;
bool
operator
>
(
const
TimeUnit
&
aOther
)
const
;
bool
operator
<
=
(
const
TimeUnit
&
aOther
)
const
;
bool
operator
<
(
const
TimeUnit
&
aOther
)
const
;
TimeUnit
operator
%
(
const
TimeUnit
&
aOther
)
const
;
TimeUnit
operator
+
(
const
TimeUnit
&
aOther
)
const
;
TimeUnit
operator
-
(
const
TimeUnit
&
aOther
)
const
;
TimeUnit
&
operator
+
=
(
const
TimeUnit
&
aOther
)
;
TimeUnit
&
operator
-
=
(
const
TimeUnit
&
aOther
)
;
template
<
typename
T
>
TimeUnit
operator
*
(
T
aVal
)
const
{
static_assert
(
std
:
:
is_integral_v
<
T
>
"
Must
be
an
integral
type
"
)
;
return
TimeUnit
(
mTicks
*
aVal
mBase
)
;
}
TimeUnit
MultDouble
(
double
aVal
)
const
;
friend
TimeUnit
operator
/
(
const
TimeUnit
&
aUnit
int64_t
aVal
)
{
MOZ_DIAGNOSTIC_ASSERT
(
0
<
=
aVal
&
&
aVal
<
=
UINT32_MAX
)
;
return
TimeUnit
(
aUnit
.
mTicks
/
aVal
aUnit
.
mBase
)
;
}
friend
TimeUnit
operator
%
(
const
TimeUnit
&
aUnit
int64_t
aVal
)
{
MOZ_DIAGNOSTIC_ASSERT
(
0
<
=
aVal
&
&
aVal
<
=
UINT32_MAX
)
;
return
TimeUnit
(
aUnit
.
mTicks
%
aVal
aUnit
.
mBase
)
;
}
TimeUnit
ToBase
(
int64_t
aTargetBase
)
const
;
TimeUnit
ToBase
(
const
TimeUnit
&
aTimeUnit
)
const
;
TimeUnit
ToBase
(
const
TimeUnit
&
aTimeUnit
double
&
aOutError
)
const
;
TimeUnit
ToBase
(
int64_t
aTargetBase
double
&
aOutError
)
const
;
bool
IsValid
(
)
const
;
constexpr
TimeUnit
(
)
=
default
;
TimeUnit
(
const
TimeUnit
&
)
=
default
;
TimeUnit
&
operator
=
(
const
TimeUnit
&
)
=
default
;
bool
IsPosInf
(
)
const
;
bool
IsNegInf
(
)
const
;
friend
IPC
:
:
ParamTraits
<
mozilla
:
:
media
:
:
TimeUnit
>
;
#
ifndef
VISIBLE_TIMEUNIT_INTERNALS
private
:
#
endif
int64_t
ToCommonUnit
(
int64_t
aRatio
)
const
;
TimeUnit
Reduced
(
)
const
;
CheckedInt64
mTicks
{
0
}
;
int64_t
mBase
{
USECS_PER_S
}
;
}
;
using
NullableTimeUnit
=
Maybe
<
TimeUnit
>
;
using
TimeInterval
=
Interval
<
TimeUnit
>
;
class
TimeIntervals
:
public
IntervalSet
<
TimeUnit
>
{
public
:
using
BaseType
=
IntervalSet
<
TimeUnit
>
;
using
InnerType
=
TimeUnit
;
MOZ_IMPLICIT
TimeIntervals
(
const
BaseType
&
aOther
)
:
BaseType
(
aOther
)
{
}
MOZ_IMPLICIT
TimeIntervals
(
BaseType
&
&
aOther
)
:
BaseType
(
std
:
:
move
(
aOther
)
)
{
}
explicit
TimeIntervals
(
const
BaseType
:
:
ElemType
&
aOther
)
:
BaseType
(
aOther
)
{
}
explicit
TimeIntervals
(
BaseType
:
:
ElemType
&
&
aOther
)
:
BaseType
(
std
:
:
move
(
aOther
)
)
{
}
static
TimeIntervals
Invalid
(
)
{
return
TimeIntervals
(
TimeInterval
(
TimeUnit
:
:
FromNegativeInfinity
(
)
TimeUnit
:
:
FromNegativeInfinity
(
)
)
)
;
}
bool
IsInvalid
(
)
const
{
return
Length
(
)
=
=
1
&
&
Start
(
0
)
.
IsNegInf
(
)
&
&
End
(
0
)
.
IsNegInf
(
)
;
}
TimeIntervals
ToMicrosecondResolution
(
)
const
{
TimeIntervals
output
;
for
(
const
auto
&
interval
:
mIntervals
)
{
TimeInterval
reducedPrecision
{
interval
.
mStart
.
ToBase
(
USECS_PER_S
)
interval
.
mEnd
.
ToBase
(
USECS_PER_S
)
interval
.
mFuzz
.
ToBase
(
USECS_PER_S
)
}
;
output
+
=
reducedPrecision
;
}
return
output
;
}
TimeIntervals
(
)
=
default
;
}
;
using
TimeRange
=
Interval
<
double
>
;
class
TimeRanges
:
public
IntervalSet
<
double
>
{
public
:
using
BaseType
=
IntervalSet
<
double
>
;
using
InnerType
=
double
;
using
nld
=
std
:
:
numeric_limits
<
double
>
;
MOZ_IMPLICIT
TimeRanges
(
const
BaseType
&
aOther
)
:
BaseType
(
aOther
)
{
}
MOZ_IMPLICIT
TimeRanges
(
BaseType
&
&
aOther
)
:
BaseType
(
std
:
:
move
(
aOther
)
)
{
}
explicit
TimeRanges
(
const
BaseType
:
:
ElemType
&
aOther
)
:
BaseType
(
aOther
)
{
}
explicit
TimeRanges
(
BaseType
:
:
ElemType
&
&
aOther
)
:
BaseType
(
std
:
:
move
(
aOther
)
)
{
}
static
TimeRanges
Invalid
(
)
{
return
TimeRanges
(
TimeRange
(
-
nld
:
:
infinity
(
)
nld
:
:
infinity
(
)
)
)
;
}
bool
IsInvalid
(
)
const
{
return
Length
(
)
=
=
1
&
&
Start
(
0
)
=
=
-
nld
:
:
infinity
(
)
&
&
End
(
0
)
=
=
nld
:
:
infinity
(
)
;
}
explicit
TimeRanges
(
const
TimeIntervals
&
aIntervals
)
{
for
(
const
auto
&
interval
:
aIntervals
)
{
Add
(
TimeRange
(
interval
.
mStart
.
ToSeconds
(
)
interval
.
mEnd
.
ToSeconds
(
)
)
)
;
}
}
TimeRanges
(
)
=
default
;
}
;
}
}
#
endif
