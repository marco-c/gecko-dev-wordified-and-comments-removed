#
ifndef
MOZILLA_MEDIATRACKGRAPHIMPL_H_
#
define
MOZILLA_MEDIATRACKGRAPHIMPL_H_
#
include
"
MediaTrackGraph
.
h
"
#
include
"
AudioMixer
.
h
"
#
include
"
GraphDriver
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIThreadInternal
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
AsyncLogger
.
h
"
namespace
mozilla
{
namespace
media
{
class
ShutdownBlocker
;
}
class
AudioContextOperationControlMessage
;
template
<
typename
T
>
class
LinkedList
;
class
GraphRunner
;
struct
TrackUpdate
{
RefPtr
<
MediaTrack
>
mTrack
;
TrackTime
mNextMainThreadCurrentTime
;
bool
mNextMainThreadEnded
;
}
;
class
ControlMessage
{
public
:
explicit
ControlMessage
(
MediaTrack
*
aTrack
)
:
mTrack
(
aTrack
)
{
MOZ_COUNT_CTOR
(
ControlMessage
)
;
}
MOZ_COUNTED_DTOR_VIRTUAL
(
ControlMessage
)
virtual
void
Run
(
)
=
0
;
virtual
void
RunDuringShutdown
(
)
{
}
MediaTrack
*
GetTrack
(
)
{
return
mTrack
;
}
protected
:
MediaTrack
*
mTrack
;
}
;
class
MessageBlock
{
public
:
nsTArray
<
UniquePtr
<
ControlMessage
>
>
mMessages
;
}
;
class
MediaTrackGraphImpl
:
public
MediaTrackGraph
public
GraphInterface
public
nsIMemoryReporter
public
nsIThreadObserver
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIMEMORYREPORTER
NS_DECL_NSITHREADOBSERVER
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
explicit
MediaTrackGraphImpl
(
GraphDriverType
aGraphDriverRequested
GraphRunType
aRunTypeRequested
TrackRate
aSampleRate
uint32_t
aChannelCount
CubebUtils
:
:
AudioDeviceID
aOutputDeviceID
AbstractThread
*
aWindow
)
;
bool
OnGraphThreadOrNotRunning
(
)
const
override
;
bool
OnGraphThread
(
)
const
override
;
bool
Destroyed
(
)
const
override
;
#
ifdef
DEBUG
bool
InDriverIteration
(
GraphDriver
*
aDriver
)
override
;
#
endif
void
Destroy
(
)
;
void
RunInStableState
(
bool
aSourceIsMTG
)
;
void
EnsureRunInStableState
(
)
;
void
ApplyTrackUpdate
(
TrackUpdate
*
aUpdate
)
;
void
AppendMessage
(
UniquePtr
<
ControlMessage
>
aMessage
)
;
void
Dispatch
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
void
ForceShutDown
(
)
;
void
AddShutdownBlocker
(
)
;
void
RemoveShutdownBlocker
(
)
;
void
Init
(
)
;
static
void
FinishCollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
const
nsTArray
<
AudioNodeSizes
>
&
aAudioTrackSizes
)
;
void
CollectSizesForMemoryReport
(
already_AddRefed
<
nsIHandleReportCallback
>
aHandleReport
already_AddRefed
<
nsISupports
>
aHandlerData
)
;
bool
UpdateMainThreadState
(
)
;
IterationResult
OneIteration
(
GraphTime
aStateEnd
GraphTime
aIterationEnd
AudioMixer
*
aMixer
)
override
;
IterationResult
OneIterationImpl
(
GraphTime
aStateEnd
GraphTime
aIterationEnd
AudioMixer
*
aMixer
)
;
void
SignalMainThreadCleanup
(
)
;
GraphTime
IterationEnd
(
)
const
;
void
EnsureStableStateEventPosted
(
)
;
void
PrepareUpdatesToMainThreadState
(
bool
aFinalUpdate
)
;
bool
ShouldUpdateMainThread
(
)
;
void
UpdateCurrentTimeForTracks
(
GraphTime
aPrevCurrentTime
)
;
void
ProcessChunkMetadata
(
GraphTime
aPrevCurrentTime
)
;
template
<
typename
C
typename
Chunk
>
void
ProcessChunkMetadataForInterval
(
MediaTrack
*
aTrack
C
&
aSegment
TrackTime
aStart
TrackTime
aEnd
)
;
void
RunMessagesInQueue
(
)
;
void
UpdateGraph
(
GraphTime
aEndBlockingDecisions
)
;
void
SwapMessageQueues
(
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
mFrontMessageQueue
.
IsEmpty
(
)
)
;
mFrontMessageQueue
.
SwapElements
(
mBackMessageQueue
)
;
if
(
!
mFrontMessageQueue
.
IsEmpty
(
)
)
{
EnsureNextIteration
(
)
;
}
}
void
Process
(
AudioMixer
*
aMixer
)
;
void
RunMessageAfterProcessing
(
UniquePtr
<
ControlMessage
>
aMessage
)
;
void
NotifyWhenGraphStarted
(
RefPtr
<
MediaTrack
>
aTrack
MozPromiseHolder
<
GraphStartedPromise
>
&
&
aHolder
)
;
void
ApplyAudioContextOperationImpl
(
MediaTrack
*
aDestinationTrack
const
nsTArray
<
RefPtr
<
MediaTrack
>
>
&
aTracks
dom
:
:
AudioContextOperation
aOperation
MozPromiseHolder
<
AudioContextOperationPromise
>
&
&
aHolder
)
;
void
SuspendOrResumeTracks
(
dom
:
:
AudioContextOperation
aAudioContextOperation
const
nsTArray
<
RefPtr
<
MediaTrack
>
>
&
aTrackSet
)
;
bool
AudioTrackPresent
(
)
;
void
CheckDriver
(
)
;
void
UpdateTrackOrder
(
)
;
static
GraphTime
RoundUpToEndOfAudioBlock
(
GraphTime
aTime
)
;
static
GraphTime
RoundUpToNextAudioBlock
(
GraphTime
aTime
)
;
void
ProduceDataForTracksBlockByBlock
(
uint32_t
aTrackIndex
TrackRate
aSampleRate
)
;
GraphTime
WillUnderrun
(
MediaTrack
*
aTrack
GraphTime
aEndBlockingDecisions
)
;
TrackTime
GraphTimeToTrackTimeWithBlocking
(
const
MediaTrack
*
aTrack
GraphTime
aTime
)
const
;
void
CreateOrDestroyAudioTracks
(
MediaTrack
*
aTrack
)
;
struct
TrackKeyAndVolume
{
MediaTrack
*
mTrack
;
void
*
mKey
;
float
mVolume
;
}
;
TrackTime
PlayAudio
(
AudioMixer
*
aMixer
const
TrackKeyAndVolume
&
aTkv
GraphTime
aPlayedTime
)
;
void
OpenAudioInputImpl
(
CubebUtils
:
:
AudioDeviceID
aID
AudioDataListener
*
aListener
)
;
virtual
nsresult
OpenAudioInput
(
CubebUtils
:
:
AudioDeviceID
aID
AudioDataListener
*
aListener
)
override
;
void
CloseAudioInputImpl
(
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
&
aID
AudioDataListener
*
aListener
)
;
virtual
void
CloseAudioInput
(
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
&
aID
AudioDataListener
*
aListener
)
override
;
void
RegisterAudioOutput
(
MediaTrack
*
aTrack
void
*
aKey
)
;
void
UnregisterAudioOutput
(
MediaTrack
*
aTrack
void
*
aKey
)
;
void
UnregisterAllAudioOutputs
(
MediaTrack
*
aTrack
)
;
void
SetAudioOutputVolume
(
MediaTrack
*
aTrack
void
*
aKey
float
aVolume
)
;
void
ReevaluateInputDevice
(
)
;
void
NotifyOutputData
(
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
override
;
void
NotifyStarted
(
)
override
;
void
NotifyInputData
(
const
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
override
;
void
DeviceChanged
(
)
override
;
void
DeviceChangedImpl
(
)
;
TrackTime
GetDesiredBufferEnd
(
MediaTrack
*
aTrack
)
;
bool
IsEmpty
(
)
const
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
|
|
(
NS_IsMainThread
(
)
&
&
LifecycleStateRef
(
)
>
=
LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP
)
)
;
return
mTracks
.
IsEmpty
(
)
&
&
mSuspendedTracks
.
IsEmpty
(
)
&
&
mPortCount
=
=
0
;
}
void
AddTrackGraphThread
(
MediaTrack
*
aTrack
)
;
void
RemoveTrackGraphThread
(
MediaTrack
*
aTrack
)
;
void
RemoveTrack
(
MediaTrack
*
aTrack
)
;
void
DestroyPort
(
MediaInputPort
*
aPort
)
;
void
SetTrackOrderDirty
(
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
mTrackOrderDirty
=
true
;
}
uint32_t
AudioOutputChannelCount
(
)
const
;
void
SetMaxOutputChannelCount
(
uint32_t
aMaxChannelCount
)
;
double
CachedAudioOutputLatency
(
)
;
double
CachedAudioInputLatency
(
)
;
void
UpdateAudioLatencies
(
)
;
double
AudioOutputLatencyGraphThread
(
)
;
double
AudioInputLatencyGraphThread
(
)
;
uint32_t
AudioInputChannelCount
(
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
#
ifdef
ANDROID
if
(
!
mInputDeviceUsers
.
GetValue
(
mInputDeviceID
)
)
{
return
0
;
}
#
else
if
(
!
mInputDeviceID
)
{
MOZ_ASSERT
(
mInputDeviceUsers
.
Count
(
)
=
=
0
"
If
running
on
a
platform
other
than
android
"
"
an
explicit
device
id
should
be
present
"
)
;
return
0
;
}
#
endif
uint32_t
maxInputChannels
=
0
;
nsTArray
<
RefPtr
<
AudioDataListener
>
>
*
listeners
=
mInputDeviceUsers
.
GetValue
(
mInputDeviceID
)
;
MOZ_ASSERT
(
listeners
)
;
for
(
const
auto
&
listener
:
*
listeners
)
{
maxInputChannels
=
std
:
:
max
(
maxInputChannels
listener
-
>
RequestedInputChannelCount
(
this
)
)
;
}
return
maxInputChannels
;
}
AudioInputType
AudioInputDevicePreference
(
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
if
(
!
mInputDeviceUsers
.
GetValue
(
mInputDeviceID
)
)
{
return
AudioInputType
:
:
Unknown
;
}
bool
voiceInput
=
false
;
nsTArray
<
RefPtr
<
AudioDataListener
>
>
*
listeners
=
mInputDeviceUsers
.
GetValue
(
mInputDeviceID
)
;
MOZ_ASSERT
(
listeners
)
;
for
(
const
auto
&
listener
:
*
listeners
)
{
voiceInput
|
=
listener
-
>
IsVoiceInput
(
this
)
;
}
if
(
voiceInput
)
{
return
AudioInputType
:
:
Voice
;
}
return
AudioInputType
:
:
Unknown
;
}
CubebUtils
:
:
AudioDeviceID
InputDeviceID
(
)
{
return
mInputDeviceID
;
}
double
MediaTimeToSeconds
(
GraphTime
aTime
)
const
{
NS_ASSERTION
(
aTime
>
-
TRACK_TIME_MAX
&
&
aTime
<
=
TRACK_TIME_MAX
"
Bad
time
"
)
;
return
static_cast
<
double
>
(
aTime
)
/
GraphRate
(
)
;
}
void
PausedIndefinitly
(
)
;
void
ResumedFromPaused
(
)
;
GraphDriver
*
CurrentDriver
(
)
const
{
#
ifdef
DEBUG
if
(
!
OnGraphThreadOrNotRunning
(
)
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
return
mDriver
;
}
void
SetCurrentDriver
(
GraphDriver
*
aDriver
)
{
MOZ_ASSERT_IF
(
mGraphDriverRunning
InDriverIteration
(
mDriver
)
)
;
MOZ_ASSERT_IF
(
!
mGraphDriverRunning
NS_IsMainThread
(
)
)
;
MonitorAutoLock
lock
(
GetMonitor
(
)
)
;
mDriver
=
aDriver
;
}
GraphDriver
*
NextDriver
(
)
const
{
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
return
mNextDriver
;
}
bool
Switching
(
)
const
{
return
NextDriver
(
)
;
}
void
SwitchAtNextIteration
(
GraphDriver
*
aNextDriver
)
;
Monitor
&
GetMonitor
(
)
{
return
mMonitor
;
}
void
EnsureNextIteration
(
)
{
CurrentDriver
(
)
-
>
EnsureNextIteration
(
)
;
}
void
RegisterCaptureTrackForWindow
(
uint64_t
aWindowId
ProcessedMediaTrack
*
aCaptureTrack
)
;
void
UnregisterCaptureTrackForWindow
(
uint64_t
aWindowId
)
;
already_AddRefed
<
MediaInputPort
>
ConnectToCaptureTrack
(
uint64_t
aWindowId
MediaTrack
*
aMediaTrack
)
;
Watchable
<
GraphTime
>
&
CurrentTime
(
)
override
;
void
InterruptJS
(
)
;
class
TrackSet
{
public
:
class
iterator
{
public
:
explicit
iterator
(
MediaTrackGraphImpl
&
aGraph
)
:
mGraph
(
&
aGraph
)
mArrayNum
(
-
1
)
mArrayIndex
(
0
)
{
+
+
(
*
this
)
;
}
iterator
(
)
:
mGraph
(
nullptr
)
mArrayNum
(
2
)
mArrayIndex
(
0
)
{
}
MediaTrack
*
operator
*
(
)
{
return
Array
(
)
-
>
ElementAt
(
mArrayIndex
)
;
}
iterator
operator
+
+
(
)
{
+
+
mArrayIndex
;
while
(
mArrayNum
<
2
&
&
(
mArrayNum
<
0
|
|
mArrayIndex
>
=
Array
(
)
-
>
Length
(
)
)
)
{
+
+
mArrayNum
;
mArrayIndex
=
0
;
}
return
*
this
;
}
bool
operator
=
=
(
const
iterator
&
aOther
)
const
{
return
mArrayNum
=
=
aOther
.
mArrayNum
&
&
mArrayIndex
=
=
aOther
.
mArrayIndex
;
}
bool
operator
!
=
(
const
iterator
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
nsTArray
<
MediaTrack
*
>
*
Array
(
)
{
return
mArrayNum
=
=
0
?
&
mGraph
-
>
mTracks
:
&
mGraph
-
>
mSuspendedTracks
;
}
MediaTrackGraphImpl
*
mGraph
;
int
mArrayNum
;
uint32_t
mArrayIndex
;
}
;
explicit
TrackSet
(
MediaTrackGraphImpl
&
aGraph
)
:
mGraph
(
aGraph
)
{
}
iterator
begin
(
)
{
return
iterator
(
mGraph
)
;
}
iterator
end
(
)
{
return
iterator
(
)
;
}
private
:
MediaTrackGraphImpl
&
mGraph
;
}
;
TrackSet
AllTracks
(
)
{
return
TrackSet
(
*
this
)
;
}
const
RefPtr
<
GraphRunner
>
mGraphRunner
;
size_t
mMainThreadTrackCount
=
0
;
size_t
mMainThreadPortCount
=
0
;
RefPtr
<
GraphDriver
>
mDriver
;
RefPtr
<
GraphDriver
>
mNextDriver
;
nsTArray
<
MediaTrack
*
>
mTracks
;
nsTArray
<
MediaTrack
*
>
mSuspendedTracks
;
uint32_t
mFirstCycleBreaker
;
GraphTime
mStateComputedTime
=
0
;
GraphTime
mProcessedTime
=
0
;
GraphTime
mIterationEndTime
=
0
;
GraphTime
mEndTime
;
TimeStamp
mLastMainThreadUpdate
;
int32_t
mPortCount
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mPendingUpdateRunnables
;
CubebUtils
:
:
AudioDeviceID
mInputDeviceID
;
CubebUtils
:
:
AudioDeviceID
mOutputDeviceID
;
nsDataHashtable
<
nsVoidPtrHashKey
nsTArray
<
RefPtr
<
AudioDataListener
>
>
>
mInputDeviceUsers
;
class
PendingResumeOperation
{
public
:
explicit
PendingResumeOperation
(
AudioContextOperationControlMessage
*
aMessage
)
;
MediaTrack
*
DestinationTrack
(
)
const
{
return
mDestinationTrack
;
}
private
:
RefPtr
<
MediaTrack
>
mDestinationTrack
;
nsTArray
<
RefPtr
<
MediaTrack
>
>
mTracks
;
MozPromiseHolder
<
AudioContextOperationPromise
>
mHolder
;
}
;
AutoTArray
<
PendingResumeOperation
1
>
mPendingResumeOperations
;
Monitor
mMonitor
;
nsTArray
<
TrackUpdate
>
mTrackUpdates
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mUpdateRunnables
;
nsTArray
<
MessageBlock
>
mFrontMessageQueue
;
nsTArray
<
MessageBlock
>
mBackMessageQueue
;
bool
MessagesQueued
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
return
!
mBackMessageQueue
.
IsEmpty
(
)
;
}
enum
LifecycleState
{
LIFECYCLE_THREAD_NOT_STARTED
LIFECYCLE_RUNNING
LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP
LIFECYCLE_WAITING_FOR_THREAD_SHUTDOWN
LIFECYCLE_WAITING_FOR_TRACK_DESTRUCTION
}
;
LifecycleState
mLifecycleState
;
LifecycleState
&
LifecycleStateRef
(
)
{
#
if
DEBUG
if
(
mGraphDriverRunning
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
}
else
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
#
endif
return
mLifecycleState
;
}
const
LifecycleState
&
LifecycleStateRef
(
)
const
{
#
if
DEBUG
if
(
mGraphDriverRunning
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
}
else
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
#
endif
return
mLifecycleState
;
}
bool
mForceShutDownReceived
=
false
;
bool
mInterruptJSCalled
=
false
;
RefPtr
<
media
:
:
ShutdownBlocker
>
mShutdownBlocker
;
bool
mPostedRunInStableStateEvent
;
JSContext
*
mJSContext
=
nullptr
;
nsTArray
<
UniquePtr
<
ControlMessage
>
>
mCurrentTaskMessageQueue
;
Atomic
<
bool
>
mGraphDriverRunning
;
bool
mPostedRunInStableState
;
const
bool
mRealtime
;
bool
mTrackOrderDirty
;
const
RefPtr
<
AbstractThread
>
mAbstractMainThread
;
nsCOMPtr
<
nsITimer
>
mShutdownTimer
;
private
:
virtual
~
MediaTrackGraphImpl
(
)
;
MOZ_DEFINE_MALLOC_SIZE_OF
(
MallocSizeOf
)
RefPtr
<
MediaTrackGraphImpl
>
mSelfRef
;
struct
WindowAndTrack
{
uint64_t
mWindowId
;
RefPtr
<
ProcessedMediaTrack
>
mCaptureTrackSink
;
}
;
nsTArray
<
WindowAndTrack
>
mWindowCaptureTracks
;
nsTArray
<
TrackKeyAndVolume
>
mAudioOutputs
;
const
float
mGlobalVolume
;
#
ifdef
DEBUG
bool
mCanRunMessagesSynchronously
;
#
endif
Watchable
<
GraphTime
>
mMainThreadGraphTime
;
GraphTime
mNextMainThreadGraphTime
=
0
;
std
:
:
atomic
<
double
>
mAudioOutputLatency
;
std
:
:
atomic
<
double
>
mAudioInputLatency
;
const
uint32_t
LATENCY_QUERYING_INTERVAL
=
100
;
uint32_t
mLatencyQueryCounter
=
0
;
uint32_t
mMaxOutputChannelCount
;
}
;
}
#
endif
