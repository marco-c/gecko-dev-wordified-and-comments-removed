#
include
"
AudioParam
.
h
"
#
include
"
mozilla
/
dom
/
AudioParamBinding
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeStream
.
h
"
#
include
"
AudioContext
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
AudioParam
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
AudioParam
)
tmp
-
>
DisconnectFromGraphAndDestroyStream
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mNode
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
AudioParam
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mNode
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE
(
AudioParam
)
NS_IMPL_CYCLE_COLLECTING_NATIVE_ADDREF
(
AudioParam
)
NS_IMETHODIMP_
(
MozExternalRefCountType
)
AudioParam
:
:
Release
(
)
{
if
(
mRefCnt
.
get
(
)
=
=
1
)
{
DisconnectFromGraphAndDestroyStream
(
)
;
}
NS_IMPL_CC_NATIVE_RELEASE_BODY
(
AudioParam
)
}
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
AudioParam
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
AudioParam
Release
)
AudioParam
:
:
AudioParam
(
AudioNode
*
aNode
uint32_t
aIndex
float
aDefaultValue
const
char
*
aName
)
:
AudioParamTimeline
(
aDefaultValue
)
mNode
(
aNode
)
mName
(
aName
)
mIndex
(
aIndex
)
mDefaultValue
(
aDefaultValue
)
{
}
AudioParam
:
:
~
AudioParam
(
)
{
MOZ_ASSERT
(
mInputNodes
.
IsEmpty
(
)
)
;
}
JSObject
*
AudioParam
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
AudioParamBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
AudioParam
:
:
DisconnectFromGraphAndDestroyStream
(
)
{
RefPtr
<
AudioParam
>
kungFuDeathGrip
=
this
;
while
(
!
mInputNodes
.
IsEmpty
(
)
)
{
uint32_t
i
=
mInputNodes
.
Length
(
)
-
1
;
RefPtr
<
AudioNode
>
input
=
mInputNodes
[
i
]
.
mInputNode
;
mInputNodes
.
RemoveElementAt
(
i
)
;
input
-
>
RemoveOutputParam
(
this
)
;
}
if
(
mNodeStreamPort
)
{
mNodeStreamPort
-
>
Destroy
(
)
;
mNodeStreamPort
=
nullptr
;
}
if
(
mStream
)
{
mStream
-
>
Destroy
(
)
;
mStream
=
nullptr
;
}
}
MediaStream
*
AudioParam
:
:
Stream
(
)
{
if
(
mStream
)
{
return
mStream
;
}
AudioNodeEngine
*
engine
=
new
AudioNodeEngine
(
nullptr
)
;
RefPtr
<
AudioNodeStream
>
stream
=
AudioNodeStream
:
:
Create
(
mNode
-
>
Context
(
)
engine
AudioNodeStream
:
:
NO_STREAM_FLAGS
)
;
stream
-
>
SetChannelMixingParametersImpl
(
1
ChannelCountMode
:
:
Explicit
ChannelInterpretation
:
:
Speakers
)
;
stream
-
>
SetAudioParamHelperStream
(
)
;
mStream
=
stream
.
forget
(
)
;
AudioNodeStream
*
nodeStream
=
mNode
-
>
GetStream
(
)
;
if
(
nodeStream
)
{
mNodeStreamPort
=
nodeStream
-
>
AllocateInputPort
(
mStream
AudioNodeStream
:
:
AUDIO_TRACK
)
;
}
AudioTimelineEvent
event
(
mStream
)
;
SendEventToEngine
(
event
)
;
return
mStream
;
}
void
AudioParam
:
:
SendEventToEngine
(
const
AudioTimelineEvent
&
aEvent
)
{
AudioNodeStream
*
stream
=
mNode
-
>
GetStream
(
)
;
if
(
stream
)
{
stream
-
>
SendTimelineEvent
(
mIndex
aEvent
)
;
}
}
float
AudioParamTimeline
:
:
AudioNodeInputValue
(
size_t
aCounter
)
const
{
MOZ_ASSERT
(
mStream
)
;
float
audioNodeInputValue
=
0
.
0f
;
const
AudioBlock
&
lastAudioNodeChunk
=
static_cast
<
AudioNodeStream
*
>
(
mStream
.
get
(
)
)
-
>
LastChunks
(
)
[
0
]
;
if
(
!
lastAudioNodeChunk
.
IsNull
(
)
)
{
MOZ_ASSERT
(
lastAudioNodeChunk
.
GetDuration
(
)
=
=
WEBAUDIO_BLOCK_SIZE
)
;
audioNodeInputValue
=
static_cast
<
const
float
*
>
(
lastAudioNodeChunk
.
mChannelData
[
0
]
)
[
aCounter
]
;
audioNodeInputValue
*
=
lastAudioNodeChunk
.
mVolume
;
}
return
audioNodeInputValue
;
}
}
}
