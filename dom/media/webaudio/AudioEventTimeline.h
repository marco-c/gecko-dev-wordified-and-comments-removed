#
ifndef
AudioEventTimeline_h_
#
define
AudioEventTimeline_h_
#
include
<
algorithm
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
math
.
h
"
#
include
"
WebAudioUtils
.
h
"
#
include
"
js
/
GCAPI
.
h
"
namespace
mozilla
{
class
AudioNodeTrack
;
namespace
dom
{
struct
AudioTimelineEvent
final
{
enum
Type
:
uint32_t
{
SetValue
SetValueAtTime
LinearRamp
ExponentialRamp
SetTarget
SetValueCurve
Track
Cancel
}
;
AudioTimelineEvent
(
Type
aType
double
aTime
float
aValue
double
aTimeConstant
=
0
.
0
double
aDuration
=
0
.
0
const
float
*
aCurve
=
nullptr
uint32_t
aCurveLength
=
0
)
;
explicit
AudioTimelineEvent
(
AudioNodeTrack
*
aTrack
)
;
AudioTimelineEvent
(
const
AudioTimelineEvent
&
rhs
)
;
~
AudioTimelineEvent
(
)
;
template
<
class
TimeType
>
TimeType
Time
(
)
const
;
void
SetTimeInTicks
(
int64_t
aTimeInTicks
)
{
mTimeInTicks
=
aTimeInTicks
;
#
ifdef
DEBUG
mTimeIsInTicks
=
true
;
#
endif
}
void
SetCurveParams
(
const
float
*
aCurve
uint32_t
aCurveLength
)
{
mCurveLength
=
aCurveLength
;
if
(
aCurveLength
)
{
mCurve
=
new
float
[
aCurveLength
]
;
PodCopy
(
mCurve
aCurve
aCurveLength
)
;
}
else
{
mCurve
=
nullptr
;
}
}
Type
mType
;
union
{
float
mValue
;
uint32_t
mCurveLength
;
}
;
float
*
mCurve
;
RefPtr
<
AudioNodeTrack
>
mTrack
;
double
mTimeConstant
;
double
mDuration
;
#
ifdef
DEBUG
bool
mTimeIsInTicks
;
#
endif
private
:
union
{
double
mTime
;
int64_t
mTimeInTicks
;
}
;
}
;
template
<
>
inline
double
AudioTimelineEvent
:
:
Time
<
double
>
(
)
const
{
MOZ_ASSERT
(
!
mTimeIsInTicks
)
;
return
mTime
;
}
template
<
>
inline
int64_t
AudioTimelineEvent
:
:
Time
<
int64_t
>
(
)
const
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mTimeIsInTicks
)
;
return
mTimeInTicks
;
}
class
AudioEventTimeline
{
public
:
explicit
AudioEventTimeline
(
float
aDefaultValue
)
:
mValue
(
aDefaultValue
)
mSetTargetStartValue
(
aDefaultValue
)
{
}
bool
ValidateEvent
(
const
AudioTimelineEvent
&
aEvent
ErrorResult
&
aRv
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
TimeOf
=
[
]
(
const
AudioTimelineEvent
&
aEvent
)
-
>
double
{
return
aEvent
.
Time
<
double
>
(
)
;
}
;
if
(
!
WebAudioUtils
:
:
IsTimeValid
(
TimeOf
(
aEvent
)
)
)
{
aRv
.
ThrowRangeError
<
MSG_INVALID_AUDIOPARAM_METHOD_START_TIME_ERROR
>
(
)
;
return
false
;
}
if
(
!
WebAudioUtils
:
:
IsTimeValid
(
aEvent
.
mTimeConstant
)
)
{
aRv
.
ThrowRangeError
(
"
The
exponential
constant
passed
to
setTargetAtTime
must
be
"
"
non
-
negative
.
"
)
;
return
false
;
}
if
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
if
(
!
aEvent
.
mCurve
|
|
aEvent
.
mCurveLength
<
2
)
{
aRv
.
ThrowInvalidStateError
(
"
Curve
length
must
be
at
least
2
"
)
;
return
false
;
}
if
(
aEvent
.
mDuration
<
=
0
)
{
aRv
.
ThrowRangeError
(
"
The
curve
duration
for
setValueCurveAtTime
must
be
strictly
"
"
positive
.
"
)
;
return
false
;
}
}
MOZ_ASSERT
(
IsValid
(
aEvent
.
mValue
)
&
&
IsValid
(
aEvent
.
mDuration
)
)
;
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
mEvents
[
i
]
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
&
&
TimeOf
(
mEvents
[
i
]
)
<
=
TimeOf
(
aEvent
)
&
&
TimeOf
(
mEvents
[
i
]
)
+
mEvents
[
i
]
.
mDuration
>
TimeOf
(
aEvent
)
)
{
aRv
.
ThrowNotSupportedError
(
"
Can
'
t
add
events
during
a
curve
event
"
)
;
return
false
;
}
}
if
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
TimeOf
(
aEvent
)
<
TimeOf
(
mEvents
[
i
]
)
&
&
TimeOf
(
aEvent
)
+
aEvent
.
mDuration
>
TimeOf
(
mEvents
[
i
]
)
)
{
aRv
.
ThrowNotSupportedError
(
"
Can
'
t
add
curve
events
that
overlap
other
events
"
)
;
return
false
;
}
}
}
if
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
ExponentialRamp
)
{
if
(
aEvent
.
mValue
<
=
0
.
f
)
{
aRv
.
ThrowRangeError
(
"
The
value
passed
to
exponentialRampToValueAtTime
must
be
"
"
positive
.
"
)
;
return
false
;
}
const
AudioTimelineEvent
*
previousEvent
=
GetPreviousEvent
(
TimeOf
(
aEvent
)
)
;
if
(
previousEvent
)
{
if
(
previousEvent
-
>
mValue
<
=
0
.
f
)
{
aRv
.
ThrowSyntaxError
(
"
Previous
event
value
must
be
positive
"
)
;
return
false
;
}
}
else
{
if
(
mValue
<
=
0
.
f
)
{
aRv
.
ThrowSyntaxError
(
"
Our
value
must
be
positive
"
)
;
return
false
;
}
}
}
return
true
;
}
template
<
typename
TimeType
>
void
InsertEvent
(
const
AudioTimelineEvent
&
aEvent
)
{
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
aEvent
.
Time
<
TimeType
>
(
)
=
=
mEvents
[
i
]
.
Time
<
TimeType
>
(
)
)
{
do
{
+
+
i
;
}
while
(
i
<
mEvents
.
Length
(
)
&
&
aEvent
.
Time
<
TimeType
>
(
)
=
=
mEvents
[
i
]
.
Time
<
TimeType
>
(
)
)
;
mEvents
.
InsertElementAt
(
i
aEvent
)
;
return
;
}
if
(
aEvent
.
Time
<
TimeType
>
(
)
<
mEvents
[
i
]
.
Time
<
TimeType
>
(
)
)
{
mEvents
.
InsertElementAt
(
i
aEvent
)
;
return
;
}
}
mEvents
.
AppendElement
(
aEvent
)
;
}
bool
HasSimpleValue
(
)
const
{
return
mEvents
.
IsEmpty
(
)
;
}
float
GetValue
(
)
const
{
MOZ_ASSERT
(
HasSimpleValue
(
)
)
;
return
mValue
;
}
void
SetValue
(
float
aValue
)
{
if
(
mEvents
.
IsEmpty
(
)
)
{
mSetTargetStartValue
=
mValue
=
aValue
;
}
}
void
SetValueAtTime
(
float
aValue
double
aStartTime
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
SetValueAtTime
aStartTime
aValue
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
void
LinearRampToValueAtTime
(
float
aValue
double
aEndTime
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
LinearRamp
aEndTime
aValue
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
void
ExponentialRampToValueAtTime
(
float
aValue
double
aEndTime
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
ExponentialRamp
aEndTime
aValue
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
void
SetTargetAtTime
(
float
aTarget
double
aStartTime
double
aTimeConstant
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
SetTarget
aStartTime
aTarget
aTimeConstant
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
void
SetValueCurveAtTime
(
const
float
*
aValues
uint32_t
aValuesLength
double
aStartTime
double
aDuration
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
SetValueCurve
aStartTime
0
.
0f
0
.
0f
aDuration
aValues
aValuesLength
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
template
<
typename
TimeType
>
void
CancelScheduledValues
(
TimeType
aStartTime
)
{
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
mEvents
[
i
]
.
Time
<
TimeType
>
(
)
>
=
aStartTime
)
{
#
ifdef
DEBUG
for
(
unsigned
j
=
i
+
1
;
j
<
mEvents
.
Length
(
)
;
+
+
j
)
{
MOZ_ASSERT
(
mEvents
[
j
]
.
Time
<
TimeType
>
(
)
>
=
aStartTime
)
;
}
#
endif
mEvents
.
TruncateLength
(
i
)
;
break
;
}
}
}
void
CancelAllEvents
(
)
{
mEvents
.
Clear
(
)
;
}
static
bool
TimesEqual
(
int64_t
aLhs
int64_t
aRhs
)
{
return
aLhs
=
=
aRhs
;
}
static
bool
TimesEqual
(
double
aLhs
double
aRhs
)
{
const
float
kEpsilon
=
0
.
0000000001f
;
return
fabs
(
aLhs
-
aRhs
)
<
kEpsilon
;
}
template
<
class
TimeType
>
float
GetValueAtTime
(
TimeType
aTime
)
{
float
result
;
GetValuesAtTimeHelper
(
aTime
&
result
1
)
;
return
result
;
}
void
GetValuesAtTime
(
int64_t
aTime
float
*
aBuffer
const
size_t
aSize
)
{
MOZ_ASSERT
(
aBuffer
)
;
GetValuesAtTimeHelper
(
aTime
aBuffer
aSize
)
;
}
void
GetValuesAtTime
(
double
aTime
float
*
aBuffer
const
size_t
aSize
)
=
delete
;
uint32_t
GetEventCount
(
)
const
{
return
mEvents
.
Length
(
)
;
}
template
<
class
TimeType
>
void
CleanupEventsOlderThan
(
TimeType
aTime
)
;
private
:
template
<
class
TimeType
>
void
GetValuesAtTimeHelper
(
TimeType
aTime
float
*
aBuffer
const
size_t
aSize
)
;
template
<
class
TimeType
>
float
GetValueAtTimeOfEvent
(
const
AudioTimelineEvent
*
aEvent
const
AudioTimelineEvent
*
aPrevious
)
;
template
<
class
TimeType
>
float
GetValuesAtTimeHelperInternal
(
TimeType
aTime
const
AudioTimelineEvent
*
aPrevious
const
AudioTimelineEvent
*
aNext
)
;
const
AudioTimelineEvent
*
GetPreviousEvent
(
double
aTime
)
const
;
static
bool
IsValid
(
double
value
)
{
return
std
:
:
isfinite
(
value
)
;
}
nsTArray
<
AudioTimelineEvent
>
mEvents
;
float
mValue
;
float
mSetTargetStartValue
;
}
;
}
}
#
endif
