#
ifndef
AudioEventTimeline_h_
#
define
AudioEventTimeline_h_
#
include
<
algorithm
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
math
.
h
"
#
include
"
WebAudioUtils
.
h
"
namespace
mozilla
{
class
MediaStream
;
namespace
dom
{
struct
AudioTimelineEvent
final
{
enum
Type
:
uint32_t
{
SetValue
SetValueAtTime
LinearRamp
ExponentialRamp
SetTarget
SetValueCurve
Stream
Cancel
}
;
AudioTimelineEvent
(
Type
aType
double
aTime
float
aValue
double
aTimeConstant
=
0
.
0
double
aDuration
=
0
.
0
const
float
*
aCurve
=
nullptr
uint32_t
aCurveLength
=
0
)
:
mType
(
aType
)
mCurve
(
nullptr
)
mTimeConstant
(
aTimeConstant
)
mDuration
(
aDuration
)
#
ifdef
DEBUG
mTimeIsInTicks
(
false
)
#
endif
{
mTime
=
aTime
;
if
(
aType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
SetCurveParams
(
aCurve
aCurveLength
)
;
}
else
{
mValue
=
aValue
;
}
}
explicit
AudioTimelineEvent
(
MediaStream
*
aStream
)
:
mType
(
Stream
)
mCurve
(
nullptr
)
mStream
(
aStream
)
mTimeConstant
(
0
.
0
)
mDuration
(
0
.
0
)
#
ifdef
DEBUG
mTimeIsInTicks
(
false
)
#
endif
{
}
AudioTimelineEvent
(
const
AudioTimelineEvent
&
rhs
)
{
PodCopy
(
this
&
rhs
1
)
;
if
(
rhs
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
SetCurveParams
(
rhs
.
mCurve
rhs
.
mCurveLength
)
;
}
else
if
(
rhs
.
mType
=
=
AudioTimelineEvent
:
:
Stream
)
{
new
(
&
mStream
)
decltype
(
mStream
)
(
rhs
.
mStream
)
;
}
}
~
AudioTimelineEvent
(
)
{
if
(
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
delete
[
]
mCurve
;
}
}
template
<
class
TimeType
>
TimeType
Time
(
)
const
;
void
SetTimeInTicks
(
int64_t
aTimeInTicks
)
{
mTimeInTicks
=
aTimeInTicks
;
#
ifdef
DEBUG
mTimeIsInTicks
=
true
;
#
endif
}
void
SetCurveParams
(
const
float
*
aCurve
uint32_t
aCurveLength
)
{
mCurveLength
=
aCurveLength
;
if
(
aCurveLength
)
{
mCurve
=
new
float
[
aCurveLength
]
;
PodCopy
(
mCurve
aCurve
aCurveLength
)
;
}
else
{
mCurve
=
nullptr
;
}
}
Type
mType
;
union
{
float
mValue
;
uint32_t
mCurveLength
;
}
;
float
*
mCurve
;
RefPtr
<
MediaStream
>
mStream
;
double
mTimeConstant
;
double
mDuration
;
#
ifdef
DEBUG
bool
mTimeIsInTicks
;
#
endif
private
:
union
{
double
mTime
;
int64_t
mTimeInTicks
;
}
;
}
;
template
<
>
inline
double
AudioTimelineEvent
:
:
Time
<
double
>
(
)
const
{
MOZ_ASSERT
(
!
mTimeIsInTicks
)
;
return
mTime
;
}
template
<
>
inline
int64_t
AudioTimelineEvent
:
:
Time
<
int64_t
>
(
)
const
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mTimeIsInTicks
)
;
return
mTimeInTicks
;
}
class
AudioEventTimeline
{
public
:
explicit
AudioEventTimeline
(
float
aDefaultValue
)
:
mValue
(
aDefaultValue
)
mComputedValue
(
aDefaultValue
)
mLastComputedValue
(
aDefaultValue
)
{
}
template
<
class
ErrorResult
>
bool
ValidateEvent
(
AudioTimelineEvent
&
aEvent
ErrorResult
&
aRv
)
;
template
<
typename
TimeType
>
void
InsertEvent
(
const
AudioTimelineEvent
&
aEvent
)
{
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
aEvent
.
template
Time
<
TimeType
>
(
)
=
=
mEvents
[
i
]
.
template
Time
<
TimeType
>
(
)
)
{
if
(
aEvent
.
mType
=
=
mEvents
[
i
]
.
mType
)
{
mEvents
.
ReplaceElementAt
(
i
aEvent
)
;
}
else
{
do
{
+
+
i
;
}
while
(
i
<
mEvents
.
Length
(
)
&
&
aEvent
.
mType
!
=
mEvents
[
i
]
.
mType
&
&
aEvent
.
template
Time
<
TimeType
>
(
)
=
=
mEvents
[
i
]
.
template
Time
<
TimeType
>
(
)
)
;
mEvents
.
InsertElementAt
(
i
aEvent
)
;
}
return
;
}
if
(
aEvent
.
template
Time
<
TimeType
>
(
)
<
mEvents
[
i
]
.
template
Time
<
TimeType
>
(
)
)
{
mEvents
.
InsertElementAt
(
i
aEvent
)
;
return
;
}
}
mEvents
.
AppendElement
(
aEvent
)
;
}
bool
HasSimpleValue
(
)
const
{
return
mEvents
.
IsEmpty
(
)
;
}
float
GetValue
(
)
const
{
MOZ_ASSERT
(
HasSimpleValue
(
)
)
;
return
mValue
;
}
float
Value
(
)
const
{
return
mValue
;
}
void
SetValue
(
float
aValue
)
{
if
(
mEvents
.
IsEmpty
(
)
)
{
mLastComputedValue
=
mComputedValue
=
mValue
=
aValue
;
}
}
template
<
class
ErrorResult
>
void
SetValueAtTime
(
float
aValue
double
aStartTime
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
SetValueAtTime
aStartTime
aValue
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
template
<
class
ErrorResult
>
void
LinearRampToValueAtTime
(
float
aValue
double
aEndTime
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
LinearRamp
aEndTime
aValue
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
template
<
class
ErrorResult
>
void
ExponentialRampToValueAtTime
(
float
aValue
double
aEndTime
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
ExponentialRamp
aEndTime
aValue
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
template
<
class
ErrorResult
>
void
SetTargetAtTime
(
float
aTarget
double
aStartTime
double
aTimeConstant
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
SetTarget
aStartTime
aTarget
aTimeConstant
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
template
<
class
ErrorResult
>
void
SetValueCurveAtTime
(
const
float
*
aValues
uint32_t
aValuesLength
double
aStartTime
double
aDuration
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
SetValueCurve
aStartTime
0
.
0f
0
.
0f
aDuration
aValues
aValuesLength
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
template
<
typename
TimeType
>
void
CancelScheduledValues
(
TimeType
aStartTime
)
{
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
mEvents
[
i
]
.
template
Time
<
TimeType
>
(
)
>
=
aStartTime
)
{
#
ifdef
DEBUG
for
(
unsigned
j
=
i
+
1
;
j
<
mEvents
.
Length
(
)
;
+
+
j
)
{
MOZ_ASSERT
(
mEvents
[
j
]
.
template
Time
<
TimeType
>
(
)
>
=
aStartTime
)
;
}
#
endif
mEvents
.
TruncateLength
(
i
)
;
break
;
}
}
}
void
CancelAllEvents
(
)
{
mEvents
.
Clear
(
)
;
}
static
bool
TimesEqual
(
int64_t
aLhs
int64_t
aRhs
)
{
return
aLhs
=
=
aRhs
;
}
static
bool
TimesEqual
(
double
aLhs
double
aRhs
)
{
const
float
kEpsilon
=
0
.
0000000001f
;
return
fabs
(
aLhs
-
aRhs
)
<
kEpsilon
;
}
template
<
class
TimeType
>
float
GetValueAtTime
(
TimeType
aTime
)
{
float
result
;
GetValuesAtTimeHelper
(
aTime
&
result
1
)
;
return
result
;
}
template
<
class
TimeType
>
void
GetValuesAtTime
(
TimeType
aTime
float
*
aBuffer
const
size_t
aSize
)
{
MOZ_ASSERT
(
aBuffer
)
;
GetValuesAtTimeHelper
(
aTime
aBuffer
aSize
)
;
}
uint32_t
GetEventCount
(
)
const
{
return
mEvents
.
Length
(
)
;
}
template
<
class
TimeType
>
void
CleanupEventsOlderThan
(
TimeType
aTime
)
{
while
(
mEvents
.
Length
(
)
>
1
&
&
aTime
>
mEvents
[
1
]
.
template
Time
<
TimeType
>
(
)
)
{
mEvents
.
RemoveElementAt
(
0
)
;
}
}
private
:
template
<
class
TimeType
>
void
GetValuesAtTimeHelper
(
TimeType
aTime
float
*
aBuffer
const
size_t
aSize
)
;
template
<
class
TimeType
>
float
GetValuesAtTimeHelperInternal
(
TimeType
aTime
const
AudioTimelineEvent
*
aPrevious
const
AudioTimelineEvent
*
aNext
)
;
const
AudioTimelineEvent
*
GetPreviousEvent
(
double
aTime
)
const
;
static
bool
IsValid
(
double
value
)
{
return
mozilla
:
:
IsFinite
(
value
)
;
}
nsTArray
<
AudioTimelineEvent
>
mEvents
;
float
mValue
;
float
mComputedValue
;
float
mLastComputedValue
;
}
;
}
}
#
endif
