#
ifndef
AudioEventTimeline_h_
#
define
AudioEventTimeline_h_
#
include
<
algorithm
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
math
.
h
"
#
include
"
WebAudioUtils
.
h
"
namespace
mozilla
{
class
MediaStream
;
namespace
dom
{
struct
AudioTimelineEvent
final
{
enum
Type
:
uint32_t
{
SetValue
SetValueAtTime
LinearRamp
ExponentialRamp
SetTarget
SetValueCurve
Stream
Cancel
}
;
AudioTimelineEvent
(
Type
aType
double
aTime
float
aValue
double
aTimeConstant
=
0
.
0
double
aDuration
=
0
.
0
const
float
*
aCurve
=
nullptr
uint32_t
aCurveLength
=
0
)
:
mType
(
aType
)
mTimeConstant
(
aTimeConstant
)
mDuration
(
aDuration
)
#
ifdef
DEBUG
mTimeIsInTicks
(
false
)
#
endif
{
mTime
=
aTime
;
if
(
aType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
SetCurveParams
(
aCurve
aCurveLength
)
;
}
else
{
mValue
=
aValue
;
}
}
explicit
AudioTimelineEvent
(
MediaStream
*
aStream
)
:
mType
(
Stream
)
mStream
(
aStream
)
#
ifdef
DEBUG
mTimeIsInTicks
(
false
)
#
endif
{
}
AudioTimelineEvent
(
const
AudioTimelineEvent
&
rhs
)
{
PodCopy
(
this
&
rhs
1
)
;
if
(
rhs
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
SetCurveParams
(
rhs
.
mCurve
rhs
.
mCurveLength
)
;
}
else
if
(
rhs
.
mType
=
=
AudioTimelineEvent
:
:
Stream
)
{
new
(
&
mStream
)
decltype
(
mStream
)
(
rhs
.
mStream
)
;
}
}
~
AudioTimelineEvent
(
)
{
if
(
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
delete
[
]
mCurve
;
}
}
template
<
class
TimeType
>
TimeType
Time
(
)
const
;
void
SetTimeInTicks
(
int64_t
aTimeInTicks
)
{
mTimeInTicks
=
aTimeInTicks
;
#
ifdef
DEBUG
mTimeIsInTicks
=
true
;
#
endif
}
void
SetCurveParams
(
const
float
*
aCurve
uint32_t
aCurveLength
)
{
mCurveLength
=
aCurveLength
;
if
(
aCurveLength
)
{
mCurve
=
new
float
[
aCurveLength
]
;
PodCopy
(
mCurve
aCurve
aCurveLength
)
;
}
else
{
mCurve
=
nullptr
;
}
}
Type
mType
;
union
{
float
mValue
;
uint32_t
mCurveLength
;
}
;
float
*
mCurve
;
nsRefPtr
<
MediaStream
>
mStream
;
double
mTimeConstant
;
double
mDuration
;
#
ifdef
DEBUG
bool
mTimeIsInTicks
;
#
endif
private
:
union
{
double
mTime
;
int64_t
mTimeInTicks
;
}
;
}
;
template
<
>
inline
double
AudioTimelineEvent
:
:
Time
<
double
>
(
)
const
{
MOZ_ASSERT
(
!
mTimeIsInTicks
)
;
return
mTime
;
}
template
<
>
inline
int64_t
AudioTimelineEvent
:
:
Time
<
int64_t
>
(
)
const
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mTimeIsInTicks
)
;
return
mTimeInTicks
;
}
template
<
class
ErrorResult
>
class
AudioEventTimeline
{
public
:
explicit
AudioEventTimeline
(
float
aDefaultValue
)
:
mValue
(
aDefaultValue
)
mComputedValue
(
aDefaultValue
)
mLastComputedValue
(
aDefaultValue
)
{
}
bool
ValidateEvent
(
AudioTimelineEvent
&
aEvent
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
WebAudioUtils
:
:
IsTimeValid
(
aEvent
.
template
Time
<
double
>
(
)
)
|
|
!
WebAudioUtils
:
:
IsTimeValid
(
aEvent
.
mTimeConstant
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
if
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
if
(
!
aEvent
.
mCurve
|
|
!
aEvent
.
mCurveLength
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
aEvent
.
mCurveLength
;
+
+
i
)
{
if
(
!
IsValid
(
aEvent
.
mCurve
[
i
]
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
}
}
if
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
SetTarget
&
&
WebAudioUtils
:
:
FuzzyEqual
(
aEvent
.
mTimeConstant
0
.
0
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
bool
timeAndValueValid
=
IsValid
(
aEvent
.
mValue
)
&
&
IsValid
(
aEvent
.
mDuration
)
;
if
(
!
timeAndValueValid
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
mEvents
[
i
]
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
&
&
!
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
&
&
aEvent
.
template
Time
<
double
>
(
)
=
=
mEvents
[
i
]
.
template
Time
<
double
>
(
)
)
&
&
mEvents
[
i
]
.
template
Time
<
double
>
(
)
<
=
aEvent
.
template
Time
<
double
>
(
)
&
&
(
mEvents
[
i
]
.
template
Time
<
double
>
(
)
+
mEvents
[
i
]
.
mDuration
)
>
=
aEvent
.
template
Time
<
double
>
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
}
if
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
mEvents
[
i
]
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
&
&
mEvents
[
i
]
.
template
Time
<
double
>
(
)
=
=
aEvent
.
template
Time
<
double
>
(
)
)
{
continue
;
}
if
(
mEvents
[
i
]
.
template
Time
<
double
>
(
)
>
aEvent
.
template
Time
<
double
>
(
)
&
&
mEvents
[
i
]
.
template
Time
<
double
>
(
)
<
(
aEvent
.
template
Time
<
double
>
(
)
+
aEvent
.
mDuration
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
}
}
if
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
ExponentialRamp
)
{
if
(
aEvent
.
mValue
<
=
0
.
f
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
const
AudioTimelineEvent
*
previousEvent
=
GetPreviousEvent
(
aEvent
.
template
Time
<
double
>
(
)
)
;
if
(
previousEvent
)
{
if
(
previousEvent
-
>
mValue
<
=
0
.
f
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
}
else
{
if
(
mValue
<
=
0
.
f
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
}
}
return
true
;
}
template
<
typename
TimeType
>
void
InsertEvent
(
const
AudioTimelineEvent
&
aEvent
)
{
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
aEvent
.
template
Time
<
TimeType
>
(
)
=
=
mEvents
[
i
]
.
template
Time
<
TimeType
>
(
)
)
{
if
(
aEvent
.
mType
=
=
mEvents
[
i
]
.
mType
)
{
mEvents
.
ReplaceElementAt
(
i
aEvent
)
;
}
else
{
do
{
+
+
i
;
}
while
(
i
<
mEvents
.
Length
(
)
&
&
aEvent
.
mType
!
=
mEvents
[
i
]
.
mType
&
&
aEvent
.
template
Time
<
TimeType
>
(
)
=
=
mEvents
[
i
]
.
template
Time
<
TimeType
>
(
)
)
;
mEvents
.
InsertElementAt
(
i
aEvent
)
;
}
return
;
}
if
(
aEvent
.
template
Time
<
TimeType
>
(
)
<
mEvents
[
i
]
.
template
Time
<
TimeType
>
(
)
)
{
mEvents
.
InsertElementAt
(
i
aEvent
)
;
return
;
}
}
mEvents
.
AppendElement
(
aEvent
)
;
}
bool
HasSimpleValue
(
)
const
{
return
mEvents
.
IsEmpty
(
)
;
}
float
GetValue
(
)
const
{
MOZ_ASSERT
(
HasSimpleValue
(
)
)
;
return
mValue
;
}
float
Value
(
)
const
{
return
mValue
;
}
void
SetValue
(
float
aValue
)
{
if
(
mEvents
.
IsEmpty
(
)
)
{
mLastComputedValue
=
mComputedValue
=
mValue
=
aValue
;
}
}
void
SetValueAtTime
(
float
aValue
double
aStartTime
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
SetValueAtTime
aStartTime
aValue
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
void
LinearRampToValueAtTime
(
float
aValue
double
aEndTime
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
LinearRamp
aEndTime
aValue
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
void
ExponentialRampToValueAtTime
(
float
aValue
double
aEndTime
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
ExponentialRamp
aEndTime
aValue
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
void
SetTargetAtTime
(
float
aTarget
double
aStartTime
double
aTimeConstant
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
SetTarget
aStartTime
aTarget
aTimeConstant
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
void
SetValueCurveAtTime
(
const
float
*
aValues
uint32_t
aValuesLength
double
aStartTime
double
aDuration
ErrorResult
&
aRv
)
{
AudioTimelineEvent
event
(
AudioTimelineEvent
:
:
SetValueCurve
aStartTime
0
.
0f
0
.
0f
aDuration
aValues
aValuesLength
)
;
if
(
ValidateEvent
(
event
aRv
)
)
{
InsertEvent
<
double
>
(
event
)
;
}
}
template
<
typename
TimeType
>
void
CancelScheduledValues
(
TimeType
aStartTime
)
{
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
mEvents
[
i
]
.
template
Time
<
TimeType
>
(
)
>
=
aStartTime
)
{
#
ifdef
DEBUG
for
(
unsigned
j
=
i
+
1
;
j
<
mEvents
.
Length
(
)
;
+
+
j
)
{
MOZ_ASSERT
(
mEvents
[
j
]
.
template
Time
<
TimeType
>
(
)
>
=
aStartTime
)
;
}
#
endif
mEvents
.
TruncateLength
(
i
)
;
break
;
}
}
}
void
CancelAllEvents
(
)
{
mEvents
.
Clear
(
)
;
}
static
bool
TimesEqual
(
int64_t
aLhs
int64_t
aRhs
)
{
return
aLhs
=
=
aRhs
;
}
static
bool
TimesEqual
(
double
aLhs
double
aRhs
)
{
const
float
kEpsilon
=
0
.
0000000001f
;
return
fabs
(
aLhs
-
aRhs
)
<
kEpsilon
;
}
template
<
class
TimeType
>
float
GetValueAtTime
(
TimeType
aTime
)
{
GetValuesAtTimeHelper
(
aTime
&
mComputedValue
1
)
;
return
mComputedValue
;
}
template
<
class
TimeType
>
void
GetValuesAtTime
(
TimeType
aTime
float
*
aBuffer
const
size_t
aSize
)
{
MOZ_ASSERT
(
aBuffer
)
;
GetValuesAtTimeHelper
(
aTime
aBuffer
aSize
)
;
mComputedValue
=
aBuffer
[
aSize
-
1
]
;
}
template
<
class
TimeType
>
void
GetValuesAtTimeHelper
(
TimeType
aTime
float
*
aBuffer
const
size_t
aSize
)
{
MOZ_ASSERT
(
aBuffer
)
;
MOZ_ASSERT
(
aSize
)
;
size_t
lastEventId
=
0
;
const
AudioTimelineEvent
*
previous
=
nullptr
;
const
AudioTimelineEvent
*
next
=
nullptr
;
bool
bailOut
=
false
;
while
(
mEvents
.
Length
(
)
>
1
&
&
aTime
>
mEvents
[
1
]
.
template
Time
<
TimeType
>
(
)
)
{
mEvents
.
RemoveElementAt
(
0
)
;
}
for
(
size_t
bufferIndex
=
0
;
bufferIndex
<
aSize
;
+
+
bufferIndex
+
+
aTime
)
{
for
(
;
!
bailOut
&
&
lastEventId
<
mEvents
.
Length
(
)
;
+
+
lastEventId
)
{
#
ifdef
DEBUG
const
AudioTimelineEvent
*
current
=
&
mEvents
[
lastEventId
]
;
MOZ_ASSERT
(
current
-
>
mType
=
=
AudioTimelineEvent
:
:
SetValueAtTime
|
|
current
-
>
mType
=
=
AudioTimelineEvent
:
:
SetTarget
|
|
current
-
>
mType
=
=
AudioTimelineEvent
:
:
LinearRamp
|
|
current
-
>
mType
=
=
AudioTimelineEvent
:
:
ExponentialRamp
|
|
current
-
>
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
;
#
endif
if
(
TimesEqual
(
aTime
mEvents
[
lastEventId
]
.
template
Time
<
TimeType
>
(
)
)
)
{
mLastComputedValue
=
mComputedValue
;
while
(
lastEventId
<
mEvents
.
Length
(
)
-
1
&
&
TimesEqual
(
aTime
mEvents
[
lastEventId
+
1
]
.
template
Time
<
TimeType
>
(
)
)
)
{
+
+
lastEventId
;
}
break
;
}
previous
=
next
;
next
=
&
mEvents
[
lastEventId
]
;
if
(
aTime
<
mEvents
[
lastEventId
]
.
template
Time
<
TimeType
>
(
)
)
{
bailOut
=
true
;
}
}
if
(
!
bailOut
&
&
lastEventId
<
mEvents
.
Length
(
)
)
{
MOZ_ASSERT
(
TimesEqual
(
aTime
mEvents
[
lastEventId
]
.
template
Time
<
TimeType
>
(
)
)
)
;
if
(
mEvents
[
lastEventId
]
.
mType
=
=
AudioTimelineEvent
:
:
SetTarget
)
{
aBuffer
[
bufferIndex
]
=
ExponentialApproach
(
mEvents
[
lastEventId
]
.
template
Time
<
TimeType
>
(
)
mLastComputedValue
mEvents
[
lastEventId
]
.
mValue
mEvents
[
lastEventId
]
.
mTimeConstant
aTime
)
;
continue
;
}
if
(
mEvents
[
lastEventId
]
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
aBuffer
[
bufferIndex
]
=
ExtractValueFromCurve
(
mEvents
[
lastEventId
]
.
template
Time
<
TimeType
>
(
)
mEvents
[
lastEventId
]
.
mCurve
mEvents
[
lastEventId
]
.
mCurveLength
mEvents
[
lastEventId
]
.
mDuration
aTime
)
;
continue
;
}
aBuffer
[
bufferIndex
]
=
mEvents
[
lastEventId
]
.
mValue
;
continue
;
}
if
(
!
bailOut
)
{
aBuffer
[
bufferIndex
]
=
GetValuesAtTimeHelperInternal
(
aTime
next
nullptr
)
;
}
else
{
aBuffer
[
bufferIndex
]
=
GetValuesAtTimeHelperInternal
(
aTime
previous
next
)
;
}
}
}
uint32_t
GetEventCount
(
)
const
{
return
mEvents
.
Length
(
)
;
}
static
float
LinearInterpolate
(
double
t0
float
v0
double
t1
float
v1
double
t
)
{
return
v0
+
(
v1
-
v0
)
*
(
(
t
-
t0
)
/
(
t1
-
t0
)
)
;
}
static
float
ExponentialInterpolate
(
double
t0
float
v0
double
t1
float
v1
double
t
)
{
return
v0
*
powf
(
v1
/
v0
(
t
-
t0
)
/
(
t1
-
t0
)
)
;
}
static
float
ExponentialApproach
(
double
t0
double
v0
float
v1
double
timeConstant
double
t
)
{
return
v1
+
(
v0
-
v1
)
*
expf
(
-
(
t
-
t0
)
/
timeConstant
)
;
}
static
float
ExtractValueFromCurve
(
double
startTime
float
*
aCurve
uint32_t
aCurveLength
double
duration
double
t
)
{
if
(
t
>
=
startTime
+
duration
)
{
return
aCurve
[
aCurveLength
-
1
]
;
}
double
ratio
=
std
:
:
max
(
(
t
-
startTime
)
/
duration
0
.
0
)
;
if
(
ratio
>
=
1
.
0
)
{
return
aCurve
[
aCurveLength
-
1
]
;
}
return
aCurve
[
uint32_t
(
aCurveLength
*
ratio
)
]
;
}
template
<
class
TimeType
>
float
GetValuesAtTimeHelperInternal
(
TimeType
aTime
const
AudioTimelineEvent
*
aPrevious
const
AudioTimelineEvent
*
aNext
)
{
if
(
!
aPrevious
)
{
return
mValue
;
}
if
(
aPrevious
-
>
mType
=
=
AudioTimelineEvent
:
:
SetTarget
)
{
return
ExponentialApproach
(
aPrevious
-
>
template
Time
<
TimeType
>
(
)
mLastComputedValue
aPrevious
-
>
mValue
aPrevious
-
>
mTimeConstant
aTime
)
;
}
if
(
aPrevious
-
>
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
return
ExtractValueFromCurve
(
aPrevious
-
>
template
Time
<
TimeType
>
(
)
aPrevious
-
>
mCurve
aPrevious
-
>
mCurveLength
aPrevious
-
>
mDuration
aTime
)
;
}
if
(
!
aNext
)
{
switch
(
aPrevious
-
>
mType
)
{
case
AudioTimelineEvent
:
:
SetValueAtTime
:
case
AudioTimelineEvent
:
:
LinearRamp
:
case
AudioTimelineEvent
:
:
ExponentialRamp
:
return
aPrevious
-
>
mValue
;
case
AudioTimelineEvent
:
:
SetValueCurve
:
return
ExtractValueFromCurve
(
aPrevious
-
>
template
Time
<
TimeType
>
(
)
aPrevious
-
>
mCurve
aPrevious
-
>
mCurveLength
aPrevious
-
>
mDuration
aTime
)
;
case
AudioTimelineEvent
:
:
SetTarget
:
MOZ_ASSERT
(
false
"
unreached
"
)
;
case
AudioTimelineEvent
:
:
SetValue
:
case
AudioTimelineEvent
:
:
Cancel
:
case
AudioTimelineEvent
:
:
Stream
:
MOZ_ASSERT
(
false
"
Should
have
been
handled
earlier
.
"
)
;
}
MOZ_ASSERT
(
false
"
unreached
"
)
;
}
switch
(
aNext
-
>
mType
)
{
case
AudioTimelineEvent
:
:
LinearRamp
:
return
LinearInterpolate
(
aPrevious
-
>
template
Time
<
TimeType
>
(
)
aPrevious
-
>
mValue
aNext
-
>
template
Time
<
TimeType
>
(
)
aNext
-
>
mValue
aTime
)
;
case
AudioTimelineEvent
:
:
ExponentialRamp
:
return
ExponentialInterpolate
(
aPrevious
-
>
template
Time
<
TimeType
>
(
)
aPrevious
-
>
mValue
aNext
-
>
template
Time
<
TimeType
>
(
)
aNext
-
>
mValue
aTime
)
;
case
AudioTimelineEvent
:
:
SetValueAtTime
:
case
AudioTimelineEvent
:
:
SetTarget
:
case
AudioTimelineEvent
:
:
SetValueCurve
:
break
;
case
AudioTimelineEvent
:
:
SetValue
:
case
AudioTimelineEvent
:
:
Cancel
:
case
AudioTimelineEvent
:
:
Stream
:
MOZ_ASSERT
(
false
"
Should
have
been
handled
earlier
.
"
)
;
}
switch
(
aPrevious
-
>
mType
)
{
case
AudioTimelineEvent
:
:
SetValueAtTime
:
case
AudioTimelineEvent
:
:
LinearRamp
:
case
AudioTimelineEvent
:
:
ExponentialRamp
:
return
aPrevious
-
>
mValue
;
case
AudioTimelineEvent
:
:
SetValueCurve
:
return
ExtractValueFromCurve
(
aPrevious
-
>
template
Time
<
TimeType
>
(
)
aPrevious
-
>
mCurve
aPrevious
-
>
mCurveLength
aPrevious
-
>
mDuration
aTime
)
;
case
AudioTimelineEvent
:
:
SetTarget
:
MOZ_ASSERT
(
false
"
unreached
"
)
;
case
AudioTimelineEvent
:
:
SetValue
:
case
AudioTimelineEvent
:
:
Cancel
:
case
AudioTimelineEvent
:
:
Stream
:
MOZ_ASSERT
(
false
"
Should
have
been
handled
earlier
.
"
)
;
}
MOZ_ASSERT
(
false
"
unreached
"
)
;
return
0
.
0f
;
}
const
AudioTimelineEvent
*
GetPreviousEvent
(
double
aTime
)
const
{
const
AudioTimelineEvent
*
previous
=
nullptr
;
const
AudioTimelineEvent
*
next
=
nullptr
;
bool
bailOut
=
false
;
for
(
unsigned
i
=
0
;
!
bailOut
&
&
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
switch
(
mEvents
[
i
]
.
mType
)
{
case
AudioTimelineEvent
:
:
SetValueAtTime
:
case
AudioTimelineEvent
:
:
SetTarget
:
case
AudioTimelineEvent
:
:
LinearRamp
:
case
AudioTimelineEvent
:
:
ExponentialRamp
:
case
AudioTimelineEvent
:
:
SetValueCurve
:
if
(
aTime
=
=
mEvents
[
i
]
.
template
Time
<
double
>
(
)
)
{
do
{
+
+
i
;
}
while
(
i
<
mEvents
.
Length
(
)
&
&
aTime
=
=
mEvents
[
i
]
.
template
Time
<
double
>
(
)
)
;
return
&
mEvents
[
i
-
1
]
;
}
previous
=
next
;
next
=
&
mEvents
[
i
]
;
if
(
aTime
<
mEvents
[
i
]
.
template
Time
<
double
>
(
)
)
{
bailOut
=
true
;
}
break
;
default
:
MOZ_ASSERT
(
false
"
unreached
"
)
;
}
}
if
(
!
bailOut
)
{
previous
=
next
;
}
return
previous
;
}
private
:
static
bool
IsValid
(
double
value
)
{
return
mozilla
:
:
IsFinite
(
value
)
;
}
nsTArray
<
AudioTimelineEvent
>
mEvents
;
float
mValue
;
float
mComputedValue
;
float
mLastComputedValue
;
}
;
}
}
#
endif
