#
ifndef
AudioEventTimeline_h_
#
define
AudioEventTimeline_h_
#
include
<
algorithm
>
#
include
"
MainThreadUtils
.
h
"
#
include
"
WebAudioUtils
.
h
"
#
include
"
math
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DefineEnum
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
js
/
GCAPI
.
h
"
namespace
mozilla
{
class
AudioNodeTrack
;
namespace
dom
{
struct
AudioTimelineEvent
{
MOZ_DEFINE_ENUM_WITH_BASE_AND_TOSTRING_AT_CLASS_SCOPE
(
Type
uint32_t
(
SetValueAtTime
LinearRamp
ExponentialRamp
SetTarget
SetValueCurve
Track
Cancel
)
)
;
class
TimeUnion
{
public
:
TimeUnion
(
)
:
mSeconds
(
)
#
if
DEBUG
mIsInSeconds
(
true
)
mIsInTicks
(
true
)
#
endif
{
}
explicit
TimeUnion
(
double
aTime
)
:
mSeconds
(
aTime
)
#
if
DEBUG
mIsInSeconds
(
true
)
mIsInTicks
(
false
)
#
endif
{
}
explicit
TimeUnion
(
int64_t
aTime
)
:
mTicks
(
aTime
)
#
if
DEBUG
mIsInSeconds
(
false
)
mIsInTicks
(
true
)
#
endif
{
}
double
operator
=
(
double
aTime
)
{
#
if
DEBUG
mIsInSeconds
=
true
;
mIsInTicks
=
true
;
#
endif
return
mSeconds
=
aTime
;
}
int64_t
operator
=
(
int64_t
aTime
)
{
#
if
DEBUG
mIsInSeconds
=
true
;
mIsInTicks
=
true
;
#
endif
return
mTicks
=
aTime
;
}
template
<
class
TimeType
>
TimeType
Get
(
)
const
;
private
:
union
{
double
mSeconds
;
int64_t
mTicks
;
}
;
#
ifdef
DEBUG
bool
mIsInSeconds
;
bool
mIsInTicks
;
public
:
bool
IsInTicks
(
)
const
{
return
mIsInTicks
;
}
;
#
endif
}
;
AudioTimelineEvent
(
Type
aType
double
aTime
float
aValue
double
aTimeConstant
=
0
.
0
)
;
AudioTimelineEvent
(
Type
aType
const
nsTArray
<
float
>
&
aValues
double
aStartTime
double
aDuration
)
;
AudioTimelineEvent
(
const
AudioTimelineEvent
&
rhs
)
;
~
AudioTimelineEvent
(
)
;
template
<
class
TimeType
>
TimeType
Time
(
)
const
{
return
mTime
.
Get
<
TimeType
>
(
)
;
}
template
<
class
TimeType
>
double
EndTime
(
)
const
;
float
NominalValue
(
)
const
{
MOZ_ASSERT
(
mType
!
=
SetValueCurve
)
;
return
mValue
;
}
float
StartValue
(
)
const
{
MOZ_ASSERT
(
mType
=
=
SetValueCurve
)
;
return
mCurve
[
0
]
;
}
float
EndValue
(
)
const
;
double
TimeConstant
(
)
const
{
MOZ_ASSERT
(
mType
=
=
SetTarget
)
;
return
mTimeConstant
;
}
uint32_t
CurveLength
(
)
const
{
MOZ_ASSERT
(
mType
=
=
SetValueCurve
)
;
return
mCurveLength
;
}
double
Duration
(
)
const
{
MOZ_ASSERT
(
mType
=
=
SetValueCurve
)
;
return
mDuration
;
}
void
ConvertToTicks
(
AudioNodeTrack
*
aDestination
)
;
template
<
class
TimeType
>
void
FillTargetApproach
(
TimeType
aBufferStartTime
Span
<
float
>
aBuffer
double
v0
)
const
;
template
<
class
TimeType
>
void
FillFromValueCurve
(
TimeType
aBufferStartTime
Span
<
float
>
aBuffer
)
const
;
const
Type
mType
;
private
:
union
{
float
mValue
;
uint32_t
mCurveLength
;
}
;
union
{
double
mTimeConstant
;
float
*
mCurve
;
}
;
union
{
double
mPerTickRatio
;
double
mDuration
;
}
;
TimeUnion
mTime
;
}
;
template
<
>
inline
double
AudioTimelineEvent
:
:
TimeUnion
:
:
Get
<
double
>
(
)
const
{
MOZ_ASSERT
(
mIsInSeconds
)
;
return
mSeconds
;
}
template
<
>
inline
int64_t
AudioTimelineEvent
:
:
TimeUnion
:
:
Get
<
int64_t
>
(
)
const
{
MOZ_ASSERT
(
mIsInTicks
)
;
return
mTicks
;
}
class
AudioEventTimeline
{
public
:
explicit
AudioEventTimeline
(
float
aDefaultValue
)
:
mDefaultValue
(
aDefaultValue
)
mSetTargetStartValue
(
aDefaultValue
)
mSimpleValue
(
Some
(
aDefaultValue
)
)
{
}
bool
ValidateEvent
(
const
AudioTimelineEvent
&
aEvent
ErrorResult
&
aRv
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
TimeOf
=
[
]
(
const
AudioTimelineEvent
&
aEvent
)
-
>
double
{
return
aEvent
.
Time
<
double
>
(
)
;
}
;
if
(
!
WebAudioUtils
:
:
IsTimeValid
(
TimeOf
(
aEvent
)
)
)
{
aRv
.
ThrowRangeError
<
MSG_INVALID_AUDIOPARAM_METHOD_START_TIME_ERROR
>
(
)
;
return
false
;
}
switch
(
aEvent
.
mType
)
{
case
AudioTimelineEvent
:
:
SetValueCurve
:
if
(
aEvent
.
CurveLength
(
)
<
2
)
{
aRv
.
ThrowInvalidStateError
(
"
Curve
length
must
be
at
least
2
"
)
;
return
false
;
}
if
(
aEvent
.
Duration
(
)
<
=
0
)
{
aRv
.
ThrowRangeError
(
"
The
curve
duration
for
setValueCurveAtTime
must
be
strictly
"
"
positive
.
"
)
;
return
false
;
}
MOZ_ASSERT
(
IsValid
(
aEvent
.
Duration
(
)
)
)
;
break
;
case
AudioTimelineEvent
:
:
SetTarget
:
if
(
!
WebAudioUtils
:
:
IsTimeValid
(
aEvent
.
TimeConstant
(
)
)
)
{
aRv
.
ThrowRangeError
(
"
The
exponential
constant
passed
to
setTargetAtTime
must
be
"
"
non
-
negative
.
"
)
;
return
false
;
}
[
[
fallthrough
]
]
;
default
:
MOZ_ASSERT
(
IsValid
(
aEvent
.
NominalValue
(
)
)
)
;
}
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
mEvents
[
i
]
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
&
&
TimeOf
(
mEvents
[
i
]
)
<
=
TimeOf
(
aEvent
)
&
&
TimeOf
(
mEvents
[
i
]
)
+
mEvents
[
i
]
.
Duration
(
)
>
TimeOf
(
aEvent
)
)
{
aRv
.
ThrowNotSupportedError
(
"
Can
'
t
add
events
during
a
curve
event
"
)
;
return
false
;
}
}
if
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
TimeOf
(
aEvent
)
<
TimeOf
(
mEvents
[
i
]
)
&
&
TimeOf
(
aEvent
)
+
aEvent
.
Duration
(
)
>
TimeOf
(
mEvents
[
i
]
)
)
{
aRv
.
ThrowNotSupportedError
(
"
Can
'
t
add
curve
events
that
overlap
other
events
"
)
;
return
false
;
}
}
}
if
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
ExponentialRamp
)
{
if
(
aEvent
.
NominalValue
(
)
=
=
0
.
f
)
{
aRv
.
ThrowRangeError
(
"
The
value
passed
to
exponentialRampToValueAtTime
must
be
"
"
non
-
zero
.
"
)
;
return
false
;
}
}
return
true
;
}
template
<
typename
TimeType
>
void
InsertEvent
(
const
AudioTimelineEvent
&
aEvent
)
{
mSimpleValue
.
reset
(
)
;
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
aEvent
.
Time
<
TimeType
>
(
)
=
=
mEvents
[
i
]
.
Time
<
TimeType
>
(
)
)
{
do
{
+
+
i
;
}
while
(
i
<
mEvents
.
Length
(
)
&
&
aEvent
.
Time
<
TimeType
>
(
)
=
=
mEvents
[
i
]
.
Time
<
TimeType
>
(
)
)
;
mEvents
.
InsertElementAt
(
i
aEvent
)
;
return
;
}
if
(
aEvent
.
Time
<
TimeType
>
(
)
<
mEvents
[
i
]
.
Time
<
TimeType
>
(
)
)
{
mEvents
.
InsertElementAt
(
i
aEvent
)
;
return
;
}
}
mEvents
.
AppendElement
(
aEvent
)
;
}
bool
HasSimpleValue
(
)
const
{
return
mSimpleValue
.
isSome
(
)
;
}
float
GetValue
(
)
const
{
MOZ_ASSERT
(
HasSimpleValue
(
)
)
;
return
mSimpleValue
.
value
(
)
;
}
template
<
typename
TimeType
>
void
CancelScheduledValues
(
TimeType
aStartTime
)
{
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
mEvents
[
i
]
.
Time
<
TimeType
>
(
)
>
=
aStartTime
)
{
#
ifdef
DEBUG
for
(
unsigned
j
=
i
+
1
;
j
<
mEvents
.
Length
(
)
;
+
+
j
)
{
MOZ_ASSERT
(
mEvents
[
j
]
.
Time
<
TimeType
>
(
)
>
=
aStartTime
)
;
}
#
endif
mEvents
.
TruncateLength
(
i
)
;
break
;
}
}
if
(
mEvents
.
IsEmpty
(
)
)
{
mSimpleValue
=
Some
(
mDefaultValue
)
;
}
}
static
bool
TimesEqual
(
int64_t
aLhs
int64_t
aRhs
)
{
return
aLhs
=
=
aRhs
;
}
static
bool
TimesEqual
(
double
aLhs
double
aRhs
)
{
const
float
kEpsilon
=
0
.
0000000001f
;
return
fabs
(
aLhs
-
aRhs
)
<
kEpsilon
;
}
template
<
class
TimeType
>
float
GetValueAtTime
(
TimeType
aTime
)
{
float
result
;
GetValuesAtTimeHelper
(
aTime
&
result
1
)
;
return
result
;
}
void
GetValuesAtTime
(
int64_t
aTime
float
*
aBuffer
const
size_t
aSize
)
{
MOZ_ASSERT
(
aBuffer
)
;
GetValuesAtTimeHelper
(
aTime
aBuffer
aSize
)
;
}
void
GetValuesAtTime
(
double
aTime
float
*
aBuffer
const
size_t
aSize
)
=
delete
;
uint32_t
GetEventCount
(
)
const
{
return
mEvents
.
Length
(
)
;
}
template
<
class
TimeType
>
void
CleanupEventsOlderThan
(
TimeType
aTime
)
;
private
:
template
<
class
TimeType
>
void
GetValuesAtTimeHelper
(
TimeType
aTime
float
*
aBuffer
const
size_t
aSize
)
;
template
<
class
TimeType
>
float
GetValueAtTimeOfEvent
(
const
AudioTimelineEvent
*
aEvent
const
AudioTimelineEvent
*
aPrevious
)
;
template
<
class
TimeType
>
void
GetValuesAtTimeHelperInternal
(
TimeType
aStartTime
Span
<
float
>
aBuffer
const
AudioTimelineEvent
*
aPrevious
const
AudioTimelineEvent
*
aNext
)
;
static
bool
IsValid
(
double
value
)
{
return
std
:
:
isfinite
(
value
)
;
}
template
<
class
TimeType
>
float
ComputeSetTargetStartValue
(
const
AudioTimelineEvent
*
aPreviousEvent
TimeType
aTime
)
;
nsTArray
<
AudioTimelineEvent
>
mEvents
;
float
mDefaultValue
;
float
mSetTargetStartValue
;
AudioTimelineEvent
:
:
TimeUnion
mSetTargetStartTime
;
Maybe
<
float
>
mSimpleValue
;
}
;
}
}
#
endif
