#
include
"
AudioNodeExternalInputTrack
.
h
"
#
include
"
AlignedTArray
.
h
"
#
include
"
AlignmentUtils
.
h
"
#
include
"
AudioChannelFormat
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamAudioSourceNode
.
h
"
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
AudioNodeExternalInputTrack
:
:
AudioNodeExternalInputTrack
(
AudioNodeEngine
*
aEngine
TrackRate
aSampleRate
)
:
AudioNodeTrack
(
aEngine
NO_TRACK_FLAGS
aSampleRate
)
{
MOZ_COUNT_CTOR
(
AudioNodeExternalInputTrack
)
;
}
AudioNodeExternalInputTrack
:
:
~
AudioNodeExternalInputTrack
(
)
{
MOZ_COUNT_DTOR
(
AudioNodeExternalInputTrack
)
;
}
already_AddRefed
<
AudioNodeExternalInputTrack
>
AudioNodeExternalInputTrack
:
:
Create
(
MediaTrackGraph
*
aGraph
AudioNodeEngine
*
aEngine
)
{
AudioContext
*
ctx
=
aEngine
-
>
NodeMainThread
(
)
-
>
Context
(
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aGraph
=
=
ctx
-
>
Graph
(
)
)
;
RefPtr
<
AudioNodeExternalInputTrack
>
track
=
new
AudioNodeExternalInputTrack
(
aEngine
aGraph
-
>
GraphRate
(
)
)
;
track
-
>
mSuspendedCount
+
=
ctx
-
>
ShouldSuspendNewTrack
(
)
;
aGraph
-
>
AddTrack
(
track
)
;
return
track
.
forget
(
)
;
}
template
<
typename
T
>
static
void
CopyChunkToBlock
(
AudioChunk
&
aInput
AudioBlock
*
aBlock
uint32_t
aOffsetInBlock
)
{
uint32_t
blockChannels
=
aBlock
-
>
ChannelCount
(
)
;
AutoTArray
<
const
T
*
2
>
channels
;
if
(
aInput
.
IsNull
(
)
)
{
channels
.
SetLength
(
blockChannels
)
;
PodZero
(
channels
.
Elements
(
)
blockChannels
)
;
}
else
{
Span
inputChannels
=
aInput
.
ChannelData
<
T
>
(
)
;
channels
.
SetLength
(
inputChannels
.
Length
(
)
)
;
PodCopy
(
channels
.
Elements
(
)
inputChannels
.
Elements
(
)
channels
.
Length
(
)
)
;
if
(
channels
.
Length
(
)
!
=
blockChannels
)
{
AudioChannelsUpMix
(
&
channels
blockChannels
static_cast
<
T
*
>
(
nullptr
)
)
;
}
}
for
(
uint32_t
c
=
0
;
c
<
blockChannels
;
+
+
c
)
{
float
*
outputData
=
aBlock
-
>
ChannelFloatsForWrite
(
c
)
+
aOffsetInBlock
;
if
(
channels
[
c
]
)
{
ConvertAudioSamplesWithScale
(
channels
[
c
]
outputData
aInput
.
GetDuration
(
)
aInput
.
mVolume
)
;
}
else
{
PodZero
(
outputData
aInput
.
GetDuration
(
)
)
;
}
}
}
static
void
ConvertSegmentToAudioBlock
(
AudioSegment
*
aSegment
AudioBlock
*
aBlock
int32_t
aFallbackChannelCount
)
{
NS_ASSERTION
(
aSegment
-
>
GetDuration
(
)
=
=
WEBAUDIO_BLOCK_SIZE
"
Bad
segment
duration
"
)
;
{
AudioSegment
:
:
ChunkIterator
ci
(
*
aSegment
)
;
NS_ASSERTION
(
!
ci
.
IsEnded
(
)
"
Should
be
at
least
one
chunk
!
"
)
;
if
(
ci
-
>
GetDuration
(
)
=
=
WEBAUDIO_BLOCK_SIZE
&
&
(
ci
-
>
IsNull
(
)
|
|
ci
-
>
mBufferFormat
=
=
AUDIO_FORMAT_FLOAT32
)
)
{
bool
aligned
=
true
;
for
(
size_t
i
=
0
;
i
<
ci
-
>
mChannelData
.
Length
(
)
;
+
+
i
)
{
if
(
!
IS_ALIGNED16
(
ci
-
>
mChannelData
[
i
]
)
)
{
aligned
=
false
;
break
;
}
}
if
(
aligned
)
{
*
aBlock
=
*
ci
;
return
;
}
}
}
aBlock
-
>
AllocateChannels
(
aFallbackChannelCount
)
;
uint32_t
duration
=
0
;
for
(
AudioSegment
:
:
ChunkIterator
ci
(
*
aSegment
)
;
!
ci
.
IsEnded
(
)
;
ci
.
Next
(
)
)
{
switch
(
ci
-
>
mBufferFormat
)
{
case
AUDIO_FORMAT_S16
:
{
CopyChunkToBlock
<
int16_t
>
(
*
ci
aBlock
duration
)
;
break
;
}
case
AUDIO_FORMAT_FLOAT32
:
{
CopyChunkToBlock
<
float
>
(
*
ci
aBlock
duration
)
;
break
;
}
case
AUDIO_FORMAT_SILENCE
:
{
CopyChunkToBlock
<
float
>
(
*
ci
aBlock
duration
)
;
break
;
}
}
duration
+
=
ci
-
>
GetDuration
(
)
;
}
}
void
AudioNodeExternalInputTrack
:
:
ProcessInput
(
GraphTime
aFrom
GraphTime
aTo
uint32_t
aFlags
)
{
MOZ_ASSERT
(
mLastChunks
.
Length
(
)
=
=
1
)
;
if
(
!
IsEnabled
(
)
|
|
mInputs
.
IsEmpty
(
)
|
|
mPassThrough
)
{
mLastChunks
[
0
]
.
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
return
;
}
MOZ_ASSERT
(
mInputs
.
Length
(
)
=
=
1
)
;
MediaTrack
*
source
=
mInputs
[
0
]
-
>
GetSource
(
)
;
AutoTArray
<
AudioSegment
1
>
audioSegments
;
uint32_t
inputChannels
=
0
;
MOZ_ASSERT
(
source
-
>
GetData
(
)
-
>
GetType
(
)
=
=
MediaSegment
:
:
AUDIO
"
AudioNodeExternalInputTrack
shouldn
'
t
have
a
video
input
"
)
;
const
AudioSegment
&
inputSegment
=
*
mInputs
[
0
]
-
>
GetSource
(
)
-
>
GetData
<
AudioSegment
>
(
)
;
if
(
!
inputSegment
.
IsNull
(
)
)
{
AudioSegment
&
segment
=
*
audioSegments
.
AppendElement
(
)
;
GraphTime
next
;
for
(
GraphTime
t
=
aFrom
;
t
<
aTo
;
t
=
next
)
{
MediaInputPort
:
:
InputInterval
interval
=
MediaInputPort
:
:
GetNextInputInterval
(
mInputs
[
0
]
t
)
;
interval
.
mEnd
=
std
:
:
min
(
interval
.
mEnd
aTo
)
;
if
(
interval
.
mStart
>
=
interval
.
mEnd
)
{
break
;
}
next
=
interval
.
mEnd
;
TrackTime
outputStart
=
GraphTimeToTrackTime
(
interval
.
mStart
)
;
TrackTime
outputEnd
=
GraphTimeToTrackTime
(
interval
.
mEnd
)
;
TrackTime
ticks
=
outputEnd
-
outputStart
;
if
(
interval
.
mInputIsBlocked
)
{
segment
.
AppendNullData
(
ticks
)
;
}
else
{
TrackTime
inputStart
=
std
:
:
min
(
inputSegment
.
GetDuration
(
)
source
-
>
GraphTimeToTrackTime
(
interval
.
mStart
)
)
;
TrackTime
inputEnd
=
std
:
:
min
(
inputSegment
.
GetDuration
(
)
source
-
>
GraphTimeToTrackTime
(
interval
.
mEnd
)
)
;
segment
.
AppendSlice
(
inputSegment
inputStart
inputEnd
)
;
segment
.
AppendNullData
(
ticks
-
(
inputEnd
-
inputStart
)
)
;
}
}
for
(
AudioSegment
:
:
ChunkIterator
iter
(
segment
)
;
!
iter
.
IsEnded
(
)
;
iter
.
Next
(
)
)
{
inputChannels
=
GetAudioChannelsSuperset
(
inputChannels
iter
-
>
ChannelCount
(
)
)
;
}
}
uint32_t
accumulateIndex
=
0
;
if
(
inputChannels
)
{
DownmixBufferType
downmixBuffer
;
ASSERT_ALIGNED16
(
downmixBuffer
.
Elements
(
)
)
;
for
(
auto
&
audioSegment
:
audioSegments
)
{
AudioBlock
tmpChunk
;
ConvertSegmentToAudioBlock
(
&
audioSegment
&
tmpChunk
inputChannels
)
;
if
(
!
tmpChunk
.
IsNull
(
)
)
{
if
(
accumulateIndex
=
=
0
)
{
mLastChunks
[
0
]
.
AllocateChannels
(
inputChannels
)
;
}
AccumulateInputChunk
(
accumulateIndex
tmpChunk
&
mLastChunks
[
0
]
&
downmixBuffer
)
;
accumulateIndex
+
+
;
}
}
}
if
(
accumulateIndex
=
=
0
)
{
mLastChunks
[
0
]
.
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
}
}
bool
AudioNodeExternalInputTrack
:
:
IsEnabled
(
)
{
return
(
(
MediaStreamAudioSourceNodeEngine
*
)
Engine
(
)
)
-
>
IsEnabled
(
)
;
}
}
