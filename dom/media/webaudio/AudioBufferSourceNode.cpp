#
include
"
AudioBufferSourceNode
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
mozilla
/
dom
/
AudioBufferSourceNodeBinding
.
h
"
#
include
"
mozilla
/
dom
/
AudioParam
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
AlignmentUtils
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeTrack
.
h
"
#
include
"
AudioDestinationNode
.
h
"
#
include
"
AudioParamTimeline
.
h
"
#
include
<
limits
>
#
include
<
algorithm
>
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
AudioBufferSourceNode
AudioScheduledSourceNode
mBuffer
mPlaybackRate
mDetune
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
AudioBufferSourceNode
)
NS_INTERFACE_MAP_END_INHERITING
(
AudioScheduledSourceNode
)
NS_IMPL_ADDREF_INHERITED
(
AudioBufferSourceNode
AudioScheduledSourceNode
)
NS_IMPL_RELEASE_INHERITED
(
AudioBufferSourceNode
AudioScheduledSourceNode
)
class
AudioBufferSourceNodeEngine
final
:
public
AudioNodeEngine
{
public
:
AudioBufferSourceNodeEngine
(
AudioNode
*
aNode
AudioDestinationNode
*
aDestination
)
:
AudioNodeEngine
(
aNode
)
mStart
(
0
.
0
)
mBeginProcessing
(
0
)
mStop
(
TRACK_TIME_MAX
)
mResampler
(
nullptr
)
mRemainingResamplerTail
(
0
)
mRemainingFrames
(
TRACK_TICKS_MAX
)
mLoopStart
(
0
)
mLoopEnd
(
0
)
mBufferPosition
(
0
)
mBufferSampleRate
(
0
)
mChannels
(
0
)
mDestination
(
aDestination
-
>
Track
(
)
)
mPlaybackRateTimeline
(
1
.
0f
)
mDetuneTimeline
(
0
.
0f
)
mLoop
(
false
)
{
}
~
AudioBufferSourceNodeEngine
(
)
{
if
(
mResampler
)
{
speex_resampler_destroy
(
mResampler
)
;
}
}
void
SetSourceTrack
(
AudioNodeTrack
*
aSource
)
{
mSource
=
aSource
;
}
void
RecvTimelineEvent
(
uint32_t
aIndex
dom
:
:
AudioTimelineEvent
&
aEvent
)
override
{
MOZ_ASSERT
(
mDestination
)
;
WebAudioUtils
:
:
ConvertAudioTimelineEventToTicks
(
aEvent
mDestination
)
;
switch
(
aIndex
)
{
case
AudioBufferSourceNode
:
:
PLAYBACKRATE
:
mPlaybackRateTimeline
.
InsertEvent
<
int64_t
>
(
aEvent
)
;
break
;
case
AudioBufferSourceNode
:
:
DETUNE
:
mDetuneTimeline
.
InsertEvent
<
int64_t
>
(
aEvent
)
;
break
;
default
:
NS_ERROR
(
"
Bad
AudioBufferSourceNodeEngine
TimelineParameter
"
)
;
}
}
void
SetTrackTimeParameter
(
uint32_t
aIndex
TrackTime
aParam
)
override
{
switch
(
aIndex
)
{
case
AudioBufferSourceNode
:
:
STOP
:
mStop
=
aParam
;
break
;
default
:
NS_ERROR
(
"
Bad
AudioBufferSourceNodeEngine
TrackTimeParameter
"
)
;
}
}
void
SetDoubleParameter
(
uint32_t
aIndex
double
aParam
)
override
{
switch
(
aIndex
)
{
case
AudioBufferSourceNode
:
:
START
:
MOZ_ASSERT
(
!
mStart
"
Another
START
?
"
)
;
mStart
=
aParam
*
mDestination
-
>
mSampleRate
;
mBeginProcessing
=
llround
(
mStart
)
;
break
;
case
AudioBufferSourceNode
:
:
DURATION
:
MOZ_ASSERT
(
aParam
>
=
0
)
;
mRemainingFrames
=
llround
(
aParam
*
mBufferSampleRate
)
;
break
;
default
:
NS_ERROR
(
"
Bad
AudioBufferSourceNodeEngine
double
parameter
.
"
)
;
}
;
}
void
SetInt32Parameter
(
uint32_t
aIndex
int32_t
aParam
)
override
{
switch
(
aIndex
)
{
case
AudioBufferSourceNode
:
:
SAMPLE_RATE
:
MOZ_ASSERT
(
aParam
>
0
)
;
mBufferSampleRate
=
aParam
;
mSource
-
>
SetActive
(
)
;
break
;
case
AudioBufferSourceNode
:
:
BUFFERSTART
:
MOZ_ASSERT
(
aParam
>
=
0
)
;
if
(
mBufferPosition
=
=
0
)
{
mBufferPosition
=
aParam
;
}
break
;
case
AudioBufferSourceNode
:
:
LOOP
:
mLoop
=
!
!
aParam
;
break
;
case
AudioBufferSourceNode
:
:
LOOPSTART
:
MOZ_ASSERT
(
aParam
>
=
0
)
;
mLoopStart
=
aParam
;
break
;
case
AudioBufferSourceNode
:
:
LOOPEND
:
MOZ_ASSERT
(
aParam
>
=
0
)
;
mLoopEnd
=
aParam
;
break
;
default
:
NS_ERROR
(
"
Bad
AudioBufferSourceNodeEngine
Int32Parameter
"
)
;
}
}
void
SetBuffer
(
AudioChunk
&
&
aBuffer
)
override
{
mBuffer
=
aBuffer
;
}
bool
BegunResampling
(
)
{
return
mBeginProcessing
=
=
-
TRACK_TIME_MAX
;
}
void
UpdateResampler
(
int32_t
aOutRate
uint32_t
aChannels
)
{
if
(
mResampler
&
&
(
aChannels
!
=
mChannels
|
|
(
aOutRate
=
=
mBufferSampleRate
&
&
!
BegunResampling
(
)
)
)
)
{
speex_resampler_destroy
(
mResampler
)
;
mResampler
=
nullptr
;
mRemainingResamplerTail
=
0
;
mBeginProcessing
=
llround
(
mStart
)
;
}
if
(
aChannels
=
=
0
|
|
(
aOutRate
=
=
mBufferSampleRate
&
&
!
mResampler
)
)
{
mResamplerOutRate
=
aOutRate
;
return
;
}
if
(
!
mResampler
)
{
mChannels
=
aChannels
;
mResampler
=
speex_resampler_init
(
mChannels
mBufferSampleRate
aOutRate
SPEEX_RESAMPLER_QUALITY_MIN
nullptr
)
;
}
else
{
if
(
mResamplerOutRate
=
=
aOutRate
)
{
return
;
}
if
(
speex_resampler_set_rate
(
mResampler
mBufferSampleRate
aOutRate
)
!
=
RESAMPLER_ERR_SUCCESS
)
{
NS_ASSERTION
(
false
"
speex_resampler_set_rate
failed
"
)
;
return
;
}
}
mResamplerOutRate
=
aOutRate
;
if
(
!
BegunResampling
(
)
)
{
int64_t
inputLatency
=
speex_resampler_get_input_latency
(
mResampler
)
;
uint32_t
ratioNum
ratioDen
;
speex_resampler_get_ratio
(
mResampler
&
ratioNum
&
ratioDen
)
;
int64_t
subsample
=
llround
(
mStart
*
ratioNum
)
;
mBeginProcessing
=
(
subsample
-
inputLatency
*
ratioDen
+
ratioNum
-
1
)
/
ratioNum
;
}
}
void
BorrowFromInputBuffer
(
AudioBlock
*
aOutput
uint32_t
aChannels
)
{
aOutput
-
>
SetBuffer
(
mBuffer
.
mBuffer
)
;
aOutput
-
>
mChannelData
.
SetLength
(
aChannels
)
;
for
(
uint32_t
i
=
0
;
i
<
aChannels
;
+
+
i
)
{
aOutput
-
>
mChannelData
[
i
]
=
mBuffer
.
ChannelData
<
float
>
(
)
[
i
]
+
mBufferPosition
;
}
aOutput
-
>
mVolume
=
mBuffer
.
mVolume
;
aOutput
-
>
mBufferFormat
=
AUDIO_FORMAT_FLOAT32
;
}
template
<
typename
T
>
void
CopyFromInputBuffer
(
AudioBlock
*
aOutput
uint32_t
aChannels
uintptr_t
aOffsetWithinBlock
uint32_t
aNumberOfFrames
)
{
MOZ_ASSERT
(
mBuffer
.
mVolume
=
=
1
.
0f
)
;
for
(
uint32_t
i
=
0
;
i
<
aChannels
;
+
+
i
)
{
float
*
baseChannelData
=
aOutput
-
>
ChannelFloatsForWrite
(
i
)
;
ConvertAudioSamples
(
mBuffer
.
ChannelData
<
T
>
(
)
[
i
]
+
mBufferPosition
baseChannelData
+
aOffsetWithinBlock
aNumberOfFrames
)
;
}
}
void
CopyFromInputBufferWithResampling
(
AudioBlock
*
aOutput
uint32_t
aChannels
uint32_t
*
aOffsetWithinBlock
uint32_t
aAvailableInOutput
TrackTime
*
aCurrentPosition
uint32_t
aBufferMax
)
{
if
(
*
aOffsetWithinBlock
=
=
0
)
{
aOutput
-
>
AllocateChannels
(
aChannels
)
;
}
SpeexResamplerState
*
resampler
=
mResampler
;
MOZ_ASSERT
(
aChannels
>
0
)
;
if
(
mBufferPosition
<
aBufferMax
)
{
uint32_t
availableInInputBuffer
=
aBufferMax
-
mBufferPosition
;
uint32_t
ratioNum
ratioDen
;
speex_resampler_get_ratio
(
resampler
&
ratioNum
&
ratioDen
)
;
uint32_t
inputLimit
=
aAvailableInOutput
*
ratioNum
/
ratioDen
+
10
;
if
(
!
BegunResampling
(
)
)
{
uint32_t
inputLatency
=
speex_resampler_get_input_latency
(
resampler
)
;
inputLimit
+
=
inputLatency
;
int64_t
skipFracNum
=
static_cast
<
int64_t
>
(
inputLatency
)
*
ratioDen
;
double
leadTicks
=
mStart
-
*
aCurrentPosition
;
if
(
leadTicks
>
0
.
0
)
{
int64_t
leadSubsamples
=
llround
(
leadTicks
*
ratioNum
)
;
MOZ_ASSERT
(
leadSubsamples
<
=
skipFracNum
"
mBeginProcessing
is
wrong
?
"
)
;
skipFracNum
-
=
leadSubsamples
;
}
speex_resampler_set_skip_frac_num
(
resampler
std
:
:
min
<
int64_t
>
(
skipFracNum
UINT32_MAX
)
)
;
mBeginProcessing
=
-
TRACK_TIME_MAX
;
}
inputLimit
=
std
:
:
min
(
inputLimit
availableInInputBuffer
)
;
MOZ_ASSERT
(
mBuffer
.
mVolume
=
=
1
.
0f
)
;
for
(
uint32_t
i
=
0
;
true
;
)
{
uint32_t
inSamples
=
inputLimit
;
uint32_t
outSamples
=
aAvailableInOutput
;
float
*
outputData
=
aOutput
-
>
ChannelFloatsForWrite
(
i
)
+
*
aOffsetWithinBlock
;
if
(
mBuffer
.
mBufferFormat
=
=
AUDIO_FORMAT_FLOAT32
)
{
const
float
*
inputData
=
mBuffer
.
ChannelData
<
float
>
(
)
[
i
]
+
mBufferPosition
;
WebAudioUtils
:
:
SpeexResamplerProcess
(
resampler
i
inputData
&
inSamples
outputData
&
outSamples
)
;
}
else
{
MOZ_ASSERT
(
mBuffer
.
mBufferFormat
=
=
AUDIO_FORMAT_S16
)
;
const
int16_t
*
inputData
=
mBuffer
.
ChannelData
<
int16_t
>
(
)
[
i
]
+
mBufferPosition
;
WebAudioUtils
:
:
SpeexResamplerProcess
(
resampler
i
inputData
&
inSamples
outputData
&
outSamples
)
;
}
if
(
+
+
i
=
=
aChannels
)
{
mBufferPosition
+
=
inSamples
;
mRemainingFrames
-
=
inSamples
;
MOZ_ASSERT
(
mBufferPosition
<
=
mBuffer
.
GetDuration
(
)
)
;
MOZ_ASSERT
(
mRemainingFrames
>
=
0
)
;
*
aOffsetWithinBlock
+
=
outSamples
;
*
aCurrentPosition
+
=
outSamples
;
if
(
(
!
mLoop
&
&
inSamples
=
=
availableInInputBuffer
)
|
|
mRemainingFrames
=
=
0
)
{
mRemainingResamplerTail
=
2
*
speex_resampler_get_input_latency
(
resampler
)
-
1
;
}
return
;
}
}
}
else
{
for
(
uint32_t
i
=
0
;
true
;
)
{
uint32_t
inSamples
=
mRemainingResamplerTail
;
uint32_t
outSamples
=
aAvailableInOutput
;
float
*
outputData
=
aOutput
-
>
ChannelFloatsForWrite
(
i
)
+
*
aOffsetWithinBlock
;
WebAudioUtils
:
:
SpeexResamplerProcess
(
resampler
i
static_cast
<
AudioDataValue
*
>
(
nullptr
)
&
inSamples
outputData
&
outSamples
)
;
if
(
+
+
i
=
=
aChannels
)
{
MOZ_ASSERT
(
inSamples
<
=
mRemainingResamplerTail
)
;
mRemainingResamplerTail
-
=
inSamples
;
*
aOffsetWithinBlock
+
=
outSamples
;
*
aCurrentPosition
+
=
outSamples
;
break
;
}
}
}
}
void
FillWithZeroes
(
AudioBlock
*
aOutput
uint32_t
aChannels
uint32_t
*
aOffsetWithinBlock
TrackTime
*
aCurrentPosition
TrackTime
aMaxPos
)
{
MOZ_ASSERT
(
*
aCurrentPosition
<
aMaxPos
)
;
uint32_t
numFrames
=
std
:
:
min
<
TrackTime
>
(
WEBAUDIO_BLOCK_SIZE
-
*
aOffsetWithinBlock
aMaxPos
-
*
aCurrentPosition
)
;
if
(
numFrames
=
=
WEBAUDIO_BLOCK_SIZE
|
|
!
aChannels
)
{
aOutput
-
>
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
}
else
{
if
(
*
aOffsetWithinBlock
=
=
0
)
{
aOutput
-
>
AllocateChannels
(
aChannels
)
;
}
WriteZeroesToAudioBlock
(
aOutput
*
aOffsetWithinBlock
numFrames
)
;
}
*
aOffsetWithinBlock
+
=
numFrames
;
*
aCurrentPosition
+
=
numFrames
;
}
void
CopyFromBuffer
(
AudioBlock
*
aOutput
uint32_t
aChannels
uint32_t
*
aOffsetWithinBlock
TrackTime
*
aCurrentPosition
uint32_t
aBufferMax
)
{
MOZ_ASSERT
(
*
aCurrentPosition
<
mStop
)
;
uint32_t
availableInOutput
=
std
:
:
min
<
TrackTime
>
(
WEBAUDIO_BLOCK_SIZE
-
*
aOffsetWithinBlock
mStop
-
*
aCurrentPosition
)
;
if
(
mResampler
)
{
CopyFromInputBufferWithResampling
(
aOutput
aChannels
aOffsetWithinBlock
availableInOutput
aCurrentPosition
aBufferMax
)
;
return
;
}
if
(
aChannels
=
=
0
)
{
aOutput
-
>
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
*
aOffsetWithinBlock
+
=
availableInOutput
;
*
aCurrentPosition
+
=
availableInOutput
;
TrackTicks
start
=
*
aCurrentPosition
*
mBufferSampleRate
/
mResamplerOutRate
;
TrackTicks
end
=
(
*
aCurrentPosition
+
availableInOutput
)
*
mBufferSampleRate
/
mResamplerOutRate
;
mBufferPosition
+
=
end
-
start
;
return
;
}
uint32_t
numFrames
=
std
:
:
min
(
aBufferMax
-
mBufferPosition
availableInOutput
)
;
bool
shouldBorrow
=
false
;
if
(
numFrames
=
=
WEBAUDIO_BLOCK_SIZE
&
&
mBuffer
.
mBufferFormat
=
=
AUDIO_FORMAT_FLOAT32
)
{
shouldBorrow
=
true
;
for
(
uint32_t
i
=
0
;
i
<
aChannels
;
+
+
i
)
{
if
(
!
IS_ALIGNED16
(
mBuffer
.
ChannelData
<
float
>
(
)
[
i
]
+
mBufferPosition
)
)
{
shouldBorrow
=
false
;
break
;
}
}
}
MOZ_ASSERT
(
mBufferPosition
<
aBufferMax
)
;
if
(
shouldBorrow
)
{
BorrowFromInputBuffer
(
aOutput
aChannels
)
;
}
else
{
if
(
*
aOffsetWithinBlock
=
=
0
)
{
aOutput
-
>
AllocateChannels
(
aChannels
)
;
}
if
(
mBuffer
.
mBufferFormat
=
=
AUDIO_FORMAT_FLOAT32
)
{
CopyFromInputBuffer
<
float
>
(
aOutput
aChannels
*
aOffsetWithinBlock
numFrames
)
;
}
else
{
MOZ_ASSERT
(
mBuffer
.
mBufferFormat
=
=
AUDIO_FORMAT_S16
)
;
CopyFromInputBuffer
<
int16_t
>
(
aOutput
aChannels
*
aOffsetWithinBlock
numFrames
)
;
}
}
*
aOffsetWithinBlock
+
=
numFrames
;
*
aCurrentPosition
+
=
numFrames
;
mBufferPosition
+
=
numFrames
;
mRemainingFrames
-
=
numFrames
;
}
int32_t
ComputeFinalOutSampleRate
(
float
aPlaybackRate
float
aDetune
)
{
float
computedPlaybackRate
=
aPlaybackRate
*
exp2
(
aDetune
/
1200
.
f
)
;
int32_t
rate
=
WebAudioUtils
:
:
TruncateFloatToInt
<
int32_t
>
(
mSource
-
>
mSampleRate
/
computedPlaybackRate
)
;
return
rate
?
rate
:
mBufferSampleRate
;
}
void
UpdateSampleRateIfNeeded
(
uint32_t
aChannels
TrackTime
aTrackPosition
)
{
float
playbackRate
;
float
detune
;
if
(
mPlaybackRateTimeline
.
HasSimpleValue
(
)
)
{
playbackRate
=
mPlaybackRateTimeline
.
GetValue
(
)
;
}
else
{
playbackRate
=
mPlaybackRateTimeline
.
GetValueAtTime
(
aTrackPosition
)
;
}
if
(
mDetuneTimeline
.
HasSimpleValue
(
)
)
{
detune
=
mDetuneTimeline
.
GetValue
(
)
;
}
else
{
detune
=
mDetuneTimeline
.
GetValueAtTime
(
aTrackPosition
)
;
}
if
(
playbackRate
<
=
0
|
|
mozilla
:
:
IsNaN
(
playbackRate
)
)
{
playbackRate
=
1
.
0f
;
}
detune
=
std
:
:
min
(
std
:
:
max
(
-
1200
.
f
detune
)
1200
.
f
)
;
int32_t
outRate
=
ComputeFinalOutSampleRate
(
playbackRate
detune
)
;
UpdateResampler
(
outRate
aChannels
)
;
}
void
ProcessBlock
(
AudioNodeTrack
*
aTrack
GraphTime
aFrom
const
AudioBlock
&
aInput
AudioBlock
*
aOutput
bool
*
aFinished
)
override
{
if
(
mBufferSampleRate
=
=
0
)
{
aOutput
-
>
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
return
;
}
TrackTime
streamPosition
=
mDestination
-
>
GraphTimeToTrackTime
(
aFrom
)
;
uint32_t
channels
=
mBuffer
.
ChannelCount
(
)
;
UpdateSampleRateIfNeeded
(
channels
streamPosition
)
;
uint32_t
written
=
0
;
while
(
true
)
{
if
(
(
mStop
!
=
TRACK_TIME_MAX
&
&
streamPosition
>
=
mStop
)
|
|
(
!
mRemainingResamplerTail
&
&
(
(
mBufferPosition
>
=
mBuffer
.
GetDuration
(
)
&
&
!
mLoop
)
|
|
mRemainingFrames
<
=
0
)
)
)
{
if
(
written
!
=
WEBAUDIO_BLOCK_SIZE
)
{
FillWithZeroes
(
aOutput
channels
&
written
&
streamPosition
TRACK_TIME_MAX
)
;
}
*
aFinished
=
true
;
break
;
}
if
(
written
=
=
WEBAUDIO_BLOCK_SIZE
)
{
break
;
}
if
(
streamPosition
<
mBeginProcessing
)
{
FillWithZeroes
(
aOutput
channels
&
written
&
streamPosition
mBeginProcessing
)
;
continue
;
}
TrackTicks
bufferLeft
;
if
(
mLoop
)
{
if
(
mBufferPosition
>
=
mLoopEnd
)
{
mBufferPosition
=
mLoopStart
;
}
bufferLeft
=
std
:
:
min
<
TrackTicks
>
(
mRemainingFrames
mLoopEnd
-
mBufferPosition
)
;
}
else
{
bufferLeft
=
std
:
:
min
(
mRemainingFrames
mBuffer
.
GetDuration
(
)
-
mBufferPosition
)
;
}
CopyFromBuffer
(
aOutput
channels
&
written
&
streamPosition
bufferLeft
+
mBufferPosition
)
;
}
}
bool
IsActive
(
)
const
override
{
return
mBufferSampleRate
!
=
0
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
size_t
amount
=
AudioNodeEngine
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
aMallocSizeOf
(
mResampler
)
;
return
amount
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
double
mStart
;
TrackTime
mBeginProcessing
;
TrackTime
mStop
;
AudioChunk
mBuffer
;
SpeexResamplerState
*
mResampler
;
uint32_t
mRemainingResamplerTail
;
TrackTicks
mRemainingFrames
;
uint32_t
mLoopStart
;
uint32_t
mLoopEnd
;
uint32_t
mBufferPosition
;
int32_t
mBufferSampleRate
;
int32_t
mResamplerOutRate
;
uint32_t
mChannels
;
RefPtr
<
AudioNodeTrack
>
mDestination
;
AudioNodeTrack
*
MOZ_NON_OWNING_REF
mSource
;
AudioParamTimeline
mPlaybackRateTimeline
;
AudioParamTimeline
mDetuneTimeline
;
bool
mLoop
;
}
;
AudioBufferSourceNode
:
:
AudioBufferSourceNode
(
AudioContext
*
aContext
)
:
AudioScheduledSourceNode
(
aContext
2
ChannelCountMode
:
:
Max
ChannelInterpretation
:
:
Speakers
)
mLoopStart
(
0
.
0
)
mLoopEnd
(
0
.
0
)
mLoop
(
false
)
mStartCalled
(
false
)
mBufferSet
(
false
)
{
mPlaybackRate
=
CreateAudioParam
(
PLAYBACKRATE
u
"
playbackRate
"
_ns
1
.
0f
)
;
mDetune
=
CreateAudioParam
(
DETUNE
u
"
detune
"
_ns
0
.
0f
)
;
AudioBufferSourceNodeEngine
*
engine
=
new
AudioBufferSourceNodeEngine
(
this
aContext
-
>
Destination
(
)
)
;
mTrack
=
AudioNodeTrack
:
:
Create
(
aContext
engine
AudioNodeTrack
:
:
NEED_MAIN_THREAD_ENDED
aContext
-
>
Graph
(
)
)
;
engine
-
>
SetSourceTrack
(
mTrack
)
;
mTrack
-
>
AddMainThreadListener
(
this
)
;
}
already_AddRefed
<
AudioBufferSourceNode
>
AudioBufferSourceNode
:
:
Create
(
JSContext
*
aCx
AudioContext
&
aAudioContext
const
AudioBufferSourceOptions
&
aOptions
)
{
RefPtr
<
AudioBufferSourceNode
>
audioNode
=
new
AudioBufferSourceNode
(
&
aAudioContext
)
;
if
(
aOptions
.
mBuffer
.
WasPassed
(
)
)
{
ErrorResult
ignored
;
MOZ_ASSERT
(
aCx
)
;
audioNode
-
>
SetBuffer
(
aCx
aOptions
.
mBuffer
.
Value
(
)
ignored
)
;
}
audioNode
-
>
Detune
(
)
-
>
SetInitialValue
(
aOptions
.
mDetune
)
;
audioNode
-
>
SetLoop
(
aOptions
.
mLoop
)
;
audioNode
-
>
SetLoopEnd
(
aOptions
.
mLoopEnd
)
;
audioNode
-
>
SetLoopStart
(
aOptions
.
mLoopStart
)
;
audioNode
-
>
PlaybackRate
(
)
-
>
SetInitialValue
(
aOptions
.
mPlaybackRate
)
;
return
audioNode
.
forget
(
)
;
}
void
AudioBufferSourceNode
:
:
DestroyMediaTrack
(
)
{
bool
hadTrack
=
mTrack
;
if
(
hadTrack
)
{
mTrack
-
>
RemoveMainThreadListener
(
this
)
;
}
AudioNode
:
:
DestroyMediaTrack
(
)
;
}
size_t
AudioBufferSourceNode
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
AudioNode
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
mPlaybackRate
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
amount
+
=
mDetune
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
size_t
AudioBufferSourceNode
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
JSObject
*
AudioBufferSourceNode
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
AudioBufferSourceNode_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
AudioBufferSourceNode
:
:
Start
(
double
aWhen
double
aOffset
const
Optional
<
double
>
&
aDuration
ErrorResult
&
aRv
)
{
if
(
!
WebAudioUtils
:
:
IsTimeValid
(
aWhen
)
)
{
aRv
.
ThrowRangeError
<
MSG_VALUE_OUT_OF_RANGE
>
(
"
start
time
"
)
;
return
;
}
if
(
aOffset
<
0
)
{
aRv
.
ThrowRangeError
<
MSG_VALUE_OUT_OF_RANGE
>
(
"
offset
"
)
;
return
;
}
if
(
aDuration
.
WasPassed
(
)
&
&
!
WebAudioUtils
:
:
IsTimeValid
(
aDuration
.
Value
(
)
)
)
{
aRv
.
ThrowRangeError
<
MSG_VALUE_OUT_OF_RANGE
>
(
"
duration
"
)
;
return
;
}
if
(
mStartCalled
)
{
aRv
.
ThrowInvalidStateError
(
"
Start
has
already
been
called
on
this
AudioBufferSourceNode
.
"
)
;
return
;
}
mStartCalled
=
true
;
AudioNodeTrack
*
ns
=
mTrack
;
if
(
!
ns
)
{
return
;
}
mOffset
=
aOffset
;
mDuration
=
aDuration
.
WasPassed
(
)
?
aDuration
.
Value
(
)
:
std
:
:
numeric_limits
<
double
>
:
:
min
(
)
;
WEB_AUDIO_API_LOG
(
"
%
f
:
%
s
%
u
Start
(
%
f
%
g
%
g
)
"
Context
(
)
-
>
CurrentTime
(
)
NodeType
(
)
Id
(
)
aWhen
aOffset
mDuration
)
;
if
(
mBuffer
)
{
SendOffsetAndDurationParametersToTrack
(
ns
)
;
}
if
(
aWhen
>
0
.
0
)
{
ns
-
>
SetDoubleParameter
(
START
aWhen
)
;
}
Context
(
)
-
>
StartBlockedAudioContextIfAllowed
(
)
;
}
void
AudioBufferSourceNode
:
:
Start
(
double
aWhen
ErrorResult
&
aRv
)
{
Start
(
aWhen
0
Optional
<
double
>
(
)
aRv
)
;
}
void
AudioBufferSourceNode
:
:
SendBufferParameterToTrack
(
JSContext
*
aCx
)
{
AudioNodeTrack
*
ns
=
mTrack
;
if
(
!
ns
)
{
return
;
}
if
(
mBuffer
)
{
AudioChunk
data
=
mBuffer
-
>
GetThreadSharedChannelsForRate
(
aCx
)
;
ns
-
>
SetBuffer
(
std
:
:
move
(
data
)
)
;
if
(
mStartCalled
)
{
SendOffsetAndDurationParametersToTrack
(
ns
)
;
}
}
else
{
ns
-
>
SetBuffer
(
AudioChunk
(
)
)
;
MarkInactive
(
)
;
}
}
void
AudioBufferSourceNode
:
:
SendOffsetAndDurationParametersToTrack
(
AudioNodeTrack
*
aTrack
)
{
NS_ASSERTION
(
mBuffer
&
&
mStartCalled
"
Only
call
this
when
we
have
a
buffer
and
start
(
)
has
been
called
"
)
;
float
rate
=
mBuffer
-
>
SampleRate
(
)
;
aTrack
-
>
SetInt32Parameter
(
SAMPLE_RATE
rate
)
;
int32_t
offsetSamples
=
std
:
:
max
(
0
NS_lround
(
mOffset
*
rate
)
)
;
if
(
offsetSamples
>
0
)
{
aTrack
-
>
SetInt32Parameter
(
BUFFERSTART
offsetSamples
)
;
}
if
(
mDuration
!
=
std
:
:
numeric_limits
<
double
>
:
:
min
(
)
)
{
MOZ_ASSERT
(
mDuration
>
=
0
.
0
)
;
MOZ_ASSERT
(
rate
>
=
0
.
0f
)
;
aTrack
-
>
SetDoubleParameter
(
DURATION
mDuration
)
;
}
MarkActive
(
)
;
}
void
AudioBufferSourceNode
:
:
Stop
(
double
aWhen
ErrorResult
&
aRv
)
{
if
(
!
WebAudioUtils
:
:
IsTimeValid
(
aWhen
)
)
{
aRv
.
ThrowRangeError
<
MSG_VALUE_OUT_OF_RANGE
>
(
"
stop
time
"
)
;
return
;
}
if
(
!
mStartCalled
)
{
aRv
.
ThrowInvalidStateError
(
"
Start
has
not
been
called
on
this
AudioBufferSourceNode
.
"
)
;
return
;
}
WEB_AUDIO_API_LOG
(
"
%
f
:
%
s
%
u
Stop
(
%
f
)
"
Context
(
)
-
>
CurrentTime
(
)
NodeType
(
)
Id
(
)
aWhen
)
;
AudioNodeTrack
*
ns
=
mTrack
;
if
(
!
ns
|
|
!
Context
(
)
)
{
return
;
}
ns
-
>
SetTrackTimeParameter
(
STOP
Context
(
)
std
:
:
max
(
0
.
0
aWhen
)
)
;
}
void
AudioBufferSourceNode
:
:
NotifyMainThreadTrackEnded
(
)
{
MOZ_ASSERT
(
mTrack
-
>
IsEnded
(
)
)
;
class
EndedEventDispatcher
final
:
public
Runnable
{
public
:
explicit
EndedEventDispatcher
(
AudioBufferSourceNode
*
aNode
)
:
mozilla
:
:
Runnable
(
"
EndedEventDispatcher
"
)
mNode
(
aNode
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
this
)
;
return
NS_OK
;
}
mNode
-
>
DispatchTrustedEvent
(
u
"
ended
"
_ns
)
;
mNode
-
>
DestroyMediaTrack
(
)
;
return
NS_OK
;
}
private
:
RefPtr
<
AudioBufferSourceNode
>
mNode
;
}
;
Context
(
)
-
>
Dispatch
(
do_AddRef
(
new
EndedEventDispatcher
(
this
)
)
)
;
MarkInactive
(
)
;
}
void
AudioBufferSourceNode
:
:
SendLoopParametersToTrack
(
)
{
if
(
!
mTrack
)
{
return
;
}
if
(
mLoop
&
&
mBuffer
)
{
float
rate
=
mBuffer
-
>
SampleRate
(
)
;
double
length
=
(
double
(
mBuffer
-
>
Length
(
)
)
/
mBuffer
-
>
SampleRate
(
)
)
;
double
actualLoopStart
actualLoopEnd
;
if
(
mLoopStart
>
=
0
.
0
&
&
mLoopEnd
>
0
.
0
&
&
mLoopStart
<
mLoopEnd
)
{
MOZ_ASSERT
(
mLoopStart
!
=
0
.
0
|
|
mLoopEnd
!
=
0
.
0
)
;
actualLoopStart
=
(
mLoopStart
>
length
)
?
0
.
0
:
mLoopStart
;
actualLoopEnd
=
std
:
:
min
(
mLoopEnd
length
)
;
}
else
{
actualLoopStart
=
0
.
0
;
actualLoopEnd
=
length
;
}
int32_t
loopStartTicks
=
NS_lround
(
actualLoopStart
*
rate
)
;
int32_t
loopEndTicks
=
NS_lround
(
actualLoopEnd
*
rate
)
;
if
(
loopStartTicks
<
loopEndTicks
)
{
SendInt32ParameterToTrack
(
LOOPSTART
loopStartTicks
)
;
SendInt32ParameterToTrack
(
LOOPEND
loopEndTicks
)
;
SendInt32ParameterToTrack
(
LOOP
1
)
;
}
else
{
SendInt32ParameterToTrack
(
LOOP
0
)
;
}
}
else
{
SendInt32ParameterToTrack
(
LOOP
0
)
;
}
}
}
