#
ifndef
MOZILLA_AUDIONODESTREAM_H_
#
define
MOZILLA_AUDIONODESTREAM_H_
#
include
"
MediaStreamGraph
.
h
"
#
include
"
mozilla
/
dom
/
AudioNodeBinding
.
h
"
#
include
"
AudioBlock
.
h
"
namespace
mozilla
{
namespace
dom
{
struct
ThreeDPoint
;
struct
AudioTimelineEvent
;
class
AudioContext
;
}
class
ThreadSharedFloatArrayBufferList
;
class
AudioNodeEngine
;
class
AudioNodeStream
:
public
ProcessedMediaStream
{
typedef
dom
:
:
ChannelCountMode
ChannelCountMode
;
typedef
dom
:
:
ChannelInterpretation
ChannelInterpretation
;
public
:
typedef
mozilla
:
:
dom
:
:
AudioContext
AudioContext
;
enum
{
AUDIO_TRACK
=
1
}
;
typedef
nsAutoTArray
<
AudioBlock
1
>
OutputChunks
;
typedef
unsigned
Flags
;
enum
:
Flags
{
NO_STREAM_FLAGS
=
0U
NEED_MAIN_THREAD_FINISHED
=
1U
<
<
0
NEED_MAIN_THREAD_CURRENT_TIME
=
1U
<
<
1
EXTERNAL_OUTPUT
=
1U
<
<
2
}
;
static
already_AddRefed
<
AudioNodeStream
>
Create
(
AudioContext
*
aCtx
AudioNodeEngine
*
aEngine
Flags
aKind
MediaStreamGraph
*
aGraph
=
nullptr
)
;
protected
:
AudioNodeStream
(
AudioNodeEngine
*
aEngine
Flags
aFlags
TrackRate
aSampleRate
)
;
~
AudioNodeStream
(
)
;
public
:
void
SetStreamTimeParameter
(
uint32_t
aIndex
AudioContext
*
aContext
double
aStreamTime
)
;
void
SetDoubleParameter
(
uint32_t
aIndex
double
aValue
)
;
void
SetInt32Parameter
(
uint32_t
aIndex
int32_t
aValue
)
;
void
SetThreeDPointParameter
(
uint32_t
aIndex
const
dom
:
:
ThreeDPoint
&
aValue
)
;
void
SetBuffer
(
already_AddRefed
<
ThreadSharedFloatArrayBufferList
>
&
&
aBuffer
)
;
void
SendTimelineEvent
(
uint32_t
aIndex
const
dom
:
:
AudioTimelineEvent
&
aEvent
)
;
void
SetRawArrayData
(
nsTArray
<
float
>
&
aData
)
;
void
SetChannelMixingParameters
(
uint32_t
aNumberOfChannels
ChannelCountMode
aChannelCountMoe
ChannelInterpretation
aChannelInterpretation
)
;
void
SetPassThrough
(
bool
aPassThrough
)
;
ChannelInterpretation
GetChannelInterpretation
(
)
{
return
mChannelInterpretation
;
}
void
SetAudioParamHelperStream
(
)
{
MOZ_ASSERT
(
!
mAudioParamStream
"
Can
only
do
this
once
"
)
;
mAudioParamStream
=
true
;
}
void
AdvanceAndResume
(
StreamTime
aAdvance
)
;
virtual
AudioNodeStream
*
AsAudioNodeStream
(
)
override
{
return
this
;
}
virtual
void
AddInput
(
MediaInputPort
*
aPort
)
override
;
virtual
void
RemoveInput
(
MediaInputPort
*
aPort
)
override
;
void
SetStreamTimeParameterImpl
(
uint32_t
aIndex
MediaStream
*
aRelativeToStream
double
aStreamTime
)
;
void
SetChannelMixingParametersImpl
(
uint32_t
aNumberOfChannels
ChannelCountMode
aChannelCountMoe
ChannelInterpretation
aChannelInterpretation
)
;
virtual
void
ProcessInput
(
GraphTime
aFrom
GraphTime
aTo
uint32_t
aFlags
)
override
;
void
ProduceOutputBeforeInput
(
GraphTime
aFrom
)
;
bool
IsAudioParamStream
(
)
const
{
return
mAudioParamStream
;
}
const
OutputChunks
&
LastChunks
(
)
const
{
return
mLastChunks
;
}
virtual
bool
MainThreadNeedsUpdates
(
)
const
override
{
return
(
(
mFlags
&
NEED_MAIN_THREAD_FINISHED
)
&
&
mFinished
)
|
|
(
mFlags
&
NEED_MAIN_THREAD_CURRENT_TIME
)
;
}
AudioNodeEngine
*
Engine
(
)
{
return
mEngine
;
}
TrackRate
SampleRate
(
)
const
{
return
mSampleRate
;
}
double
FractionalTicksFromDestinationTime
(
AudioNodeStream
*
aDestination
double
aSeconds
)
;
StreamTime
TicksFromDestinationTime
(
MediaStream
*
aDestination
double
aSeconds
)
;
double
DestinationTimeFromTicks
(
AudioNodeStream
*
aDestination
StreamTime
aPosition
)
;
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
;
void
SizeOfAudioNodesIncludingThis
(
MallocSizeOf
aMallocSizeOf
AudioNodeSizes
&
aUsage
)
const
;
void
SetActive
(
)
;
void
CheckForInactive
(
)
;
protected
:
class
AdvanceAndResumeMessage
;
virtual
void
DestroyImpl
(
)
override
;
void
AdvanceOutputSegment
(
)
;
void
FinishOutput
(
)
;
void
AccumulateInputChunk
(
uint32_t
aInputIndex
const
AudioBlock
&
aChunk
AudioBlock
*
aBlock
nsTArray
<
float
>
*
aDownmixBuffer
)
;
void
UpMixDownMixChunk
(
const
AudioBlock
*
aChunk
uint32_t
aOutputChannelCount
nsTArray
<
const
float
*
>
&
aOutputChannels
nsTArray
<
float
>
&
aDownmixBuffer
)
;
uint32_t
ComputedNumberOfChannels
(
uint32_t
aInputChannelCount
)
;
void
ObtainInputBlock
(
AudioBlock
&
aTmpChunk
uint32_t
aPortIndex
)
;
void
IncrementActiveInputCount
(
)
;
void
DecrementActiveInputCount
(
)
;
nsAutoPtr
<
AudioNodeEngine
>
mEngine
;
OutputChunks
mInputChunks
;
OutputChunks
mLastChunks
;
const
TrackRate
mSampleRate
;
const
Flags
mFlags
;
uint32_t
mActiveInputCount
=
0
;
uint32_t
mNumberOfInputChannels
;
ChannelCountMode
mChannelCountMode
;
ChannelInterpretation
mChannelInterpretation
;
bool
mIsActive
;
bool
mMarkAsFinishedAfterThisBlock
;
bool
mAudioParamStream
;
bool
mPassThrough
;
}
;
}
#
endif
