#
include
"
AudioWorkletGlobalScope
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeStream
.
h
"
#
include
"
AudioWorkletImpl
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
mozilla
/
dom
/
AudioWorkletGlobalScopeBinding
.
h
"
#
include
"
mozilla
/
dom
/
StructuredCloneHolder
.
h
"
#
include
"
mozilla
/
dom
/
WorkletPrincipal
.
h
"
#
include
"
mozilla
/
dom
/
AudioParamDescriptorBinding
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsTHashtable
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
AudioWorkletGlobalScope
WorkletGlobalScope
mNameToProcessorMap
)
;
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
AudioWorkletGlobalScope
)
NS_INTERFACE_MAP_END_INHERITING
(
WorkletGlobalScope
)
NS_IMPL_ADDREF_INHERITED
(
AudioWorkletGlobalScope
WorkletGlobalScope
)
NS_IMPL_RELEASE_INHERITED
(
AudioWorkletGlobalScope
WorkletGlobalScope
)
AudioWorkletGlobalScope
:
:
AudioWorkletGlobalScope
(
AudioWorkletImpl
*
aImpl
)
:
mImpl
(
aImpl
)
mCurrentFrame
(
0
)
mCurrentTime
(
0
)
mSampleRate
(
0
.
0
)
{
}
bool
AudioWorkletGlobalScope
:
:
WrapGlobalObject
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aReflector
)
{
JS
:
:
RealmOptions
options
;
return
AudioWorkletGlobalScope_Binding
:
:
Wrap
(
aCx
this
this
options
WorkletPrincipal
:
:
GetWorkletPrincipal
(
)
true
aReflector
)
;
}
void
AudioWorkletGlobalScope
:
:
RegisterProcessor
(
JSContext
*
aCx
const
nsAString
&
aName
AudioWorkletProcessorConstructor
&
aProcessorCtor
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JSObject
*
>
processorConstructor
(
aCx
aProcessorCtor
.
CallableOrNull
(
)
)
;
if
(
aName
.
IsEmpty
(
)
)
{
aRv
.
ThrowDOMException
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
NS_LITERAL_CSTRING
(
"
Argument
1
of
AudioWorkletGlobalScope
.
registerProcessor
"
"
should
not
be
an
empty
string
.
"
)
)
;
return
;
}
if
(
mNameToProcessorMap
.
GetWeak
(
aName
)
)
{
aRv
.
ThrowDOMException
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
NS_LITERAL_CSTRING
(
"
Argument
1
of
AudioWorkletGlobalScope
.
registerProcessor
"
"
is
invalid
:
a
class
with
the
same
name
is
already
registered
.
"
)
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
constructorUnwrapped
(
aCx
js
:
:
CheckedUnwrapStatic
(
processorConstructor
)
)
;
if
(
!
constructorUnwrapped
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
!
JS
:
:
IsConstructor
(
constructorUnwrapped
)
)
{
aRv
.
ThrowTypeError
<
MSG_NOT_CONSTRUCTOR
>
(
NS_LITERAL_STRING
(
"
Argument
2
of
AudioWorkletGlobalScope
.
registerProcessor
"
)
)
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
prototype
(
aCx
)
;
if
(
!
JS_GetProperty
(
aCx
processorConstructor
"
prototype
"
&
prototype
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
if
(
!
prototype
.
isObject
(
)
)
{
aRv
.
ThrowTypeError
<
MSG_NOT_OBJECT
>
(
NS_LITERAL_STRING
(
"
Argument
2
of
AudioWorkletGlobalScope
.
registerProcessor
"
"
processorCtor
.
prototype
"
)
)
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
process
(
aCx
)
;
JS
:
:
Rooted
<
JSObject
*
>
prototypeObject
(
aCx
&
prototype
.
toObject
(
)
)
;
if
(
!
JS_GetProperty
(
aCx
prototypeObject
"
process
"
&
process
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
if
(
!
process
.
isObjectOrNull
(
)
|
|
!
JS
:
:
IsCallable
(
process
.
toObjectOrNull
(
)
)
)
{
aRv
.
ThrowTypeError
<
MSG_NOT_CALLABLE
>
(
NS_LITERAL_STRING
(
"
Argument
2
of
AudioWorkletGlobalScope
.
registerProcessor
"
"
constructor
.
process
"
)
)
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
descriptors
(
aCx
)
;
if
(
!
JS_GetProperty
(
aCx
processorConstructor
"
parameterDescriptors
"
&
descriptors
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
bool
isArray
=
false
;
if
(
!
JS_IsArrayObject
(
aCx
descriptors
&
isArray
)
)
{
isArray
=
false
;
JS_ClearPendingException
(
aCx
)
;
}
if
(
!
descriptors
.
isUndefined
(
)
&
&
!
isArray
)
{
aRv
.
ThrowTypeError
<
MSG_NOT_ARRAY_NOR_UNDEFINED
>
(
NS_LITERAL_STRING
(
"
Argument
2
of
AudioWorkletGlobalScope
.
registerProcessor
"
"
constructor
.
parameterDescriptors
"
)
)
;
return
;
}
if
(
!
mNameToProcessorMap
.
Put
(
aName
&
aProcessorCtor
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
AudioParamDescriptorMap
map
=
DescriptorsFromJS
(
aCx
descriptors
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
AudioWorkletGlobalScope
:
parameter
descriptors
"
[
impl
=
mImpl
name
=
nsString
(
aName
)
map
=
std
:
:
move
(
map
)
]
(
)
mutable
{
AudioNode
*
destinationNode
=
impl
-
>
DestinationStream
(
)
-
>
Engine
(
)
-
>
NodeMainThread
(
)
;
if
(
!
destinationNode
)
{
return
;
}
destinationNode
-
>
Context
(
)
-
>
SetParamMapForWorkletName
(
name
&
map
)
;
}
)
)
;
}
WorkletImpl
*
AudioWorkletGlobalScope
:
:
Impl
(
)
const
{
return
mImpl
;
}
uint64_t
AudioWorkletGlobalScope
:
:
CurrentFrame
(
)
const
{
return
mCurrentFrame
;
}
double
AudioWorkletGlobalScope
:
:
CurrentTime
(
)
const
{
return
mCurrentTime
;
}
float
AudioWorkletGlobalScope
:
:
SampleRate
(
)
const
{
return
mSampleRate
;
}
AudioParamDescriptorMap
AudioWorkletGlobalScope
:
:
DescriptorsFromJS
(
JSContext
*
aCx
const
JS
:
:
Rooted
<
JS
:
:
Value
>
&
aDescriptors
ErrorResult
&
aRv
)
{
if
(
aDescriptors
.
isUndefined
(
)
)
{
return
AudioParamDescriptorMap
(
)
;
}
MOZ_ASSERT
(
aDescriptors
.
isObject
(
)
)
;
AudioParamDescriptorMap
res
;
nsTHashtable
<
nsStringHashKey
>
namesSet
;
JS
:
:
Rooted
<
JSObject
*
>
aDescriptorsArray
(
aCx
&
aDescriptors
.
toObject
(
)
)
;
uint32_t
length
=
0
;
if
(
!
JS_GetArrayLength
(
aCx
aDescriptorsArray
&
length
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
AudioParamDescriptorMap
(
)
;
}
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
descriptorElement
(
aCx
)
;
if
(
!
JS_GetElement
(
aCx
aDescriptorsArray
i
&
descriptorElement
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
AudioParamDescriptorMap
(
)
;
}
AudioParamDescriptor
descriptor
;
nsPrintfCString
sourceDescription
(
"
Element
%
u
in
parameterDescriptors
"
i
)
;
if
(
!
descriptor
.
Init
(
aCx
descriptorElement
sourceDescription
.
get
(
)
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
AudioParamDescriptorMap
(
)
;
}
if
(
namesSet
.
Contains
(
descriptor
.
mName
)
)
{
aRv
.
ThrowDOMException
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
NS_LITERAL_CSTRING
(
"
Duplicated
name
\
"
"
)
+
NS_ConvertUTF16toUTF8
(
descriptor
.
mName
)
+
NS_LITERAL_CSTRING
(
"
\
"
in
parameterDescriptors
.
"
)
)
;
return
AudioParamDescriptorMap
(
)
;
}
if
(
descriptor
.
mMinValue
>
descriptor
.
mMaxValue
)
{
aRv
.
ThrowDOMException
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
NS_LITERAL_CSTRING
(
"
In
parameterDescriptors
"
)
+
NS_ConvertUTF16toUTF8
(
descriptor
.
mName
)
+
NS_LITERAL_CSTRING
(
"
minValue
should
be
smaller
than
maxValue
.
"
)
)
;
return
AudioParamDescriptorMap
(
)
;
}
if
(
descriptor
.
mDefaultValue
<
descriptor
.
mMinValue
|
|
descriptor
.
mDefaultValue
>
descriptor
.
mMaxValue
)
{
aRv
.
ThrowDOMException
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
NS_LITERAL_CSTRING
(
"
In
parameterDescriptors
"
)
+
NS_ConvertUTF16toUTF8
(
descriptor
.
mName
)
+
NS_LITERAL_CSTRING
(
"
defaultValue
is
out
of
the
range
defined
by
"
"
minValue
and
maxValue
.
"
)
)
;
return
AudioParamDescriptorMap
(
)
;
}
if
(
!
res
.
AppendElement
(
descriptor
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
AudioParamDescriptorMap
(
)
;
}
if
(
!
namesSet
.
PutEntry
(
descriptor
.
mName
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
AudioParamDescriptorMap
(
)
;
}
}
return
res
;
}
bool
AudioWorkletGlobalScope
:
:
ConstructProcessor
(
const
nsAString
&
aName
NotNull
<
StructuredCloneHolder
*
>
aOptionsSerialization
JS
:
:
MutableHandle
<
JSObject
*
>
aRetProcessor
)
{
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
this
)
)
)
{
return
false
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
ErrorResult
rv
;
JS
:
:
Rooted
<
JS
:
:
Value
>
optionsVal
(
cx
)
;
aOptionsSerialization
-
>
Read
(
this
cx
&
optionsVal
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
)
)
{
return
false
;
}
RefPtr
<
AudioWorkletProcessorConstructor
>
processorConstructor
=
mNameToProcessorMap
.
Get
(
aName
)
;
MOZ_ASSERT
(
processorConstructor
)
;
JS
:
:
Rooted
<
JSObject
*
>
options
(
cx
&
optionsVal
.
toObject
(
)
)
;
RefPtr
<
AudioWorkletProcessor
>
processor
=
processorConstructor
-
>
Construct
(
options
rv
"
AudioWorkletProcessor
construction
"
CallbackFunction
:
:
eReportExceptions
)
;
if
(
rv
.
Failed
(
)
)
{
rv
.
SuppressException
(
)
;
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
processorVal
(
cx
)
;
if
(
NS_WARN_IF
(
!
ToJSValue
(
cx
processor
&
processorVal
)
)
)
{
return
false
;
}
MOZ_ASSERT
(
processorVal
.
isObject
(
)
)
;
aRetProcessor
.
set
(
&
processorVal
.
toObject
(
)
)
;
return
true
;
}
}
}
