#
include
"
AudioWorkletNode
.
h
"
#
include
"
AudioParamMap
.
h
"
#
include
"
mozilla
/
dom
/
AudioWorkletNodeBinding
.
h
"
#
include
"
mozilla
/
dom
/
MessagePort
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
AudioWorkletNode
AudioNode
)
class
WorkletNodeEngine
final
:
public
AudioNodeEngine
{
public
:
explicit
WorkletNodeEngine
(
AudioWorkletNode
*
aNode
)
:
AudioNodeEngine
(
aNode
)
{
}
void
ConstructProcessor
(
AudioWorkletImpl
*
aWorkletImpl
const
nsAString
&
aName
StructuredCloneHolder
*
aOptionsSerialization
)
;
void
NotifyForcedShutdown
(
)
override
{
}
}
;
void
WorkletNodeEngine
:
:
ConstructProcessor
(
AudioWorkletImpl
*
aWorkletImpl
const
nsAString
&
aName
StructuredCloneHolder
*
aOptionsSerialization
)
{
}
AudioWorkletNode
:
:
AudioWorkletNode
(
AudioContext
*
aAudioContext
const
nsAString
&
aName
const
AudioWorkletNodeOptions
&
aOptions
)
:
AudioNode
(
aAudioContext
2
ChannelCountMode
:
:
Max
ChannelInterpretation
:
:
Speakers
)
mNodeName
(
aName
)
mInputCount
(
aOptions
.
mNumberOfInputs
)
mOutputCount
(
aOptions
.
mNumberOfOutputs
)
{
}
already_AddRefed
<
AudioWorkletNode
>
AudioWorkletNode
:
:
Constructor
(
const
GlobalObject
&
aGlobal
AudioContext
&
aAudioContext
const
nsAString
&
aName
const
AudioWorkletNodeOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
aOptions
.
mNumberOfInputs
=
=
0
&
&
aOptions
.
mNumberOfOutputs
=
=
0
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
if
(
aOptions
.
mOutputChannelCount
.
WasPassed
(
)
)
{
if
(
aOptions
.
mOutputChannelCount
.
Value
(
)
.
Length
(
)
!
=
aOptions
.
mNumberOfOutputs
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
for
(
uint32_t
channelCount
:
aOptions
.
mOutputChannelCount
.
Value
(
)
)
{
if
(
channelCount
=
=
0
|
|
channelCount
>
WebAudioUtils
:
:
MaxChannelCount
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
}
}
const
AudioParamDescriptorMap
*
parameterDescriptors
=
aAudioContext
.
GetParamMapForWorkletName
(
aName
)
;
if
(
!
parameterDescriptors
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
if
(
aOptions
.
mNumberOfInputs
>
UINT16_MAX
)
{
aRv
.
ThrowRangeError
<
MSG_VALUE_OUT_OF_RANGE
>
(
NS_LITERAL_STRING
(
"
numberOfInputs
"
)
)
;
return
nullptr
;
}
if
(
aOptions
.
mNumberOfOutputs
>
UINT16_MAX
)
{
aRv
.
ThrowRangeError
<
MSG_VALUE_OUT_OF_RANGE
>
(
NS_LITERAL_STRING
(
"
numberOfOutputs
"
)
)
;
return
nullptr
;
}
RefPtr
<
AudioWorkletNode
>
audioWorkletNode
=
new
AudioWorkletNode
(
&
aAudioContext
aName
aOptions
)
;
audioWorkletNode
-
>
Initialize
(
aOptions
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
optionsVal
(
cx
)
;
if
(
NS_WARN_IF
(
!
ToJSValue
(
cx
aOptions
&
optionsVal
)
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
nullptr
;
}
UniquePtr
<
StructuredCloneHolder
>
optionsSerialization
=
MakeUnique
<
StructuredCloneHolder
>
(
StructuredCloneHolder
:
:
CloningSupported
StructuredCloneHolder
:
:
TransferringNotSupported
JS
:
:
StructuredCloneScope
:
:
SameProcessDifferentThread
)
;
optionsSerialization
-
>
Write
(
cx
optionsVal
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
audioWorkletNode
-
>
mStream
=
AudioNodeStream
:
:
Create
(
&
aAudioContext
new
WorkletNodeEngine
(
audioWorkletNode
)
AudioNodeStream
:
:
NO_STREAM_FLAGS
aAudioContext
.
Graph
(
)
)
;
Worklet
*
worklet
=
aAudioContext
.
GetAudioWorklet
(
aRv
)
;
MOZ_ASSERT
(
worklet
"
Worklet
already
existed
and
so
getter
shouldn
'
t
fail
.
"
)
;
auto
workletImpl
=
static_cast
<
AudioWorkletImpl
*
>
(
worklet
-
>
Impl
(
)
)
;
audioWorkletNode
-
>
mStream
-
>
SendRunnable
(
NS_NewRunnableFunction
(
"
WorkletNodeEngine
:
:
ConstructProcessor
"
[
stream
=
audioWorkletNode
-
>
mStream
workletImpl
=
RefPtr
<
AudioWorkletImpl
>
(
workletImpl
)
name
=
nsString
(
aName
)
options
=
std
:
:
move
(
optionsSerialization
)
]
(
)
{
auto
engine
=
static_cast
<
WorkletNodeEngine
*
>
(
stream
-
>
Engine
(
)
)
;
engine
-
>
ConstructProcessor
(
workletImpl
name
options
.
get
(
)
)
;
}
)
)
;
return
audioWorkletNode
.
forget
(
)
;
}
AudioParamMap
*
AudioWorkletNode
:
:
GetParameters
(
ErrorResult
&
aRv
)
const
{
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
MessagePort
*
AudioWorkletNode
:
:
GetPort
(
ErrorResult
&
aRv
)
const
{
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
JSObject
*
AudioWorkletNode
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
AudioWorkletNode_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
size_t
AudioWorkletNode
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
AudioNode
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
size_t
AudioWorkletNode
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
}
}
