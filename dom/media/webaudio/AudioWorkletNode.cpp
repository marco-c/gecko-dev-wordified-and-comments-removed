#
include
"
AudioWorkletNode
.
h
"
#
include
"
AudioParamMap
.
h
"
#
include
"
mozilla
/
dom
/
AudioWorkletNodeBinding
.
h
"
#
include
"
mozilla
/
dom
/
MessagePort
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
AudioWorkletNode
AudioNode
)
class
WorkletNodeEngine
final
:
public
AudioNodeEngine
{
public
:
WorkletNodeEngine
(
AudioWorkletNode
*
aNode
const
Optional
<
Sequence
<
uint32_t
>
>
&
aOutputChannelCount
)
:
AudioNodeEngine
(
aNode
)
{
if
(
aOutputChannelCount
.
WasPassed
(
)
)
{
mOutputChannelCount
=
aOutputChannelCount
.
Value
(
)
;
}
}
MOZ_CAN_RUN_SCRIPT
void
ConstructProcessor
(
AudioWorkletImpl
*
aWorkletImpl
const
nsAString
&
aName
NotNull
<
StructuredCloneHolder
*
>
aSerializedOptions
)
;
void
ProcessBlock
(
AudioNodeTrack
*
aTrack
GraphTime
aFrom
const
AudioBlock
&
aInput
AudioBlock
*
aOutput
bool
*
aFinished
)
override
{
MOZ_ASSERT
(
InputCount
(
)
<
=
1
)
;
MOZ_ASSERT
(
OutputCount
(
)
<
=
1
)
;
ProcessBlocksOnPorts
(
aTrack
MakeSpan
(
&
aInput
InputCount
(
)
)
MakeSpan
(
aOutput
OutputCount
(
)
)
aFinished
)
;
}
void
ProcessBlocksOnPorts
(
AudioNodeTrack
*
aTrack
Span
<
const
AudioBlock
>
aInput
Span
<
AudioBlock
>
aOutput
bool
*
aFinished
)
override
;
void
NotifyForcedShutdown
(
)
override
{
ReleaseJSResources
(
)
;
}
struct
Channels
{
Vector
<
JS
:
:
PersistentRooted
<
JSObject
*
>
GUESS_AUDIO_CHANNELS
>
mFloat32Arrays
;
JS
:
:
PersistentRooted
<
JSObject
*
>
mJSArray
;
operator
JS
:
:
Handle
<
JSObject
*
>
(
)
const
{
return
mJSArray
;
}
}
;
struct
Ports
{
Vector
<
Channels
1
>
mPorts
;
JS
:
:
PersistentRooted
<
JSObject
*
>
mJSArray
;
}
;
private
:
void
SendProcessorError
(
)
;
bool
CallProcess
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aCallable
bool
*
aActiveRet
)
;
void
ReleaseJSResources
(
)
{
mInputs
.
mPorts
.
clearAndFree
(
)
;
mOutputs
.
mPorts
.
clearAndFree
(
)
;
mInputs
.
mJSArray
.
reset
(
)
;
mOutputs
.
mJSArray
.
reset
(
)
;
mGlobal
=
nullptr
;
mProcessor
.
reset
(
)
;
}
nsTArray
<
uint32_t
>
mOutputChannelCount
;
Ports
mInputs
;
Ports
mOutputs
;
RefPtr
<
AudioWorkletGlobalScope
>
mGlobal
;
JS
:
:
PersistentRooted
<
JSObject
*
>
mProcessor
;
}
;
void
WorkletNodeEngine
:
:
SendProcessorError
(
)
{
ReleaseJSResources
(
)
;
}
void
WorkletNodeEngine
:
:
ConstructProcessor
(
AudioWorkletImpl
*
aWorkletImpl
const
nsAString
&
aName
NotNull
<
StructuredCloneHolder
*
>
aSerializedOptions
)
{
MOZ_ASSERT
(
mInputs
.
mPorts
.
empty
(
)
&
&
mOutputs
.
mPorts
.
empty
(
)
)
;
RefPtr
<
AudioWorkletGlobalScope
>
global
=
aWorkletImpl
-
>
GetGlobalScope
(
)
;
MOZ_ASSERT
(
global
)
;
JS
:
:
RootingContext
*
cx
=
RootingCx
(
)
;
mProcessor
.
init
(
cx
)
;
if
(
!
global
-
>
ConstructProcessor
(
aName
aSerializedOptions
&
mProcessor
)
|
|
NS_WARN_IF
(
!
mInputs
.
mPorts
.
growBy
(
InputCount
(
)
)
)
|
|
NS_WARN_IF
(
!
mOutputs
.
mPorts
.
growBy
(
OutputCount
(
)
)
)
)
{
SendProcessorError
(
)
;
return
;
}
mGlobal
=
std
:
:
move
(
global
)
;
mInputs
.
mJSArray
.
init
(
cx
)
;
mOutputs
.
mJSArray
.
init
(
cx
)
;
for
(
auto
&
port
:
mInputs
.
mPorts
)
{
port
.
mJSArray
.
init
(
cx
)
;
}
for
(
auto
&
port
:
mOutputs
.
mPorts
)
{
port
.
mJSArray
.
init
(
cx
)
;
}
}
template
<
typename
T
>
static
bool
SetArrayElements
(
JSContext
*
aCx
const
T
&
aElements
JS
:
:
Handle
<
JSObject
*
>
aArray
)
{
for
(
size_t
i
=
0
;
i
<
aElements
.
length
(
)
;
+
+
i
)
{
if
(
!
JS_DefineElement
(
aCx
aArray
i
aElements
[
i
]
JSPROP_ENUMERATE
)
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
T
>
static
bool
PrepareArray
(
JSContext
*
aCx
const
T
&
aElements
JS
:
:
MutableHandle
<
JSObject
*
>
aArray
)
{
size_t
length
=
aElements
.
length
(
)
;
if
(
aArray
)
{
uint32_t
oldLength
;
if
(
JS_GetArrayLength
(
aCx
aArray
&
oldLength
)
&
&
(
oldLength
=
=
length
|
|
JS_SetArrayLength
(
aCx
aArray
length
)
)
&
&
SetArrayElements
(
aCx
aElements
aArray
)
)
{
return
true
;
}
JS_ClearPendingException
(
aCx
)
;
}
JSObject
*
array
=
JS_NewArrayObject
(
aCx
length
)
;
if
(
NS_WARN_IF
(
!
array
)
)
{
return
false
;
}
aArray
.
set
(
array
)
;
return
SetArrayElements
(
aCx
aElements
aArray
)
;
}
enum
class
ArrayElementInit
{
None
Zero
}
;
static
bool
PrepareBufferArrays
(
JSContext
*
aCx
Span
<
const
AudioBlock
>
aBlocks
WorkletNodeEngine
:
:
Ports
*
aPorts
ArrayElementInit
aInit
)
{
MOZ_ASSERT
(
aBlocks
.
Length
(
)
=
=
aPorts
-
>
mPorts
.
length
(
)
)
;
for
(
size_t
i
=
0
;
i
<
aBlocks
.
Length
(
)
;
+
+
i
)
{
size_t
channelCount
=
aBlocks
[
i
]
.
ChannelCount
(
)
;
WorkletNodeEngine
:
:
Channels
&
portRef
=
aPorts
-
>
mPorts
[
i
]
;
auto
&
float32ArraysRef
=
portRef
.
mFloat32Arrays
;
for
(
auto
&
channelRef
:
float32ArraysRef
)
{
uint32_t
length
=
JS_GetTypedArrayLength
(
channelRef
)
;
if
(
length
!
=
WEBAUDIO_BLOCK_SIZE
)
{
JSObject
*
array
=
JS_NewFloat32Array
(
aCx
WEBAUDIO_BLOCK_SIZE
)
;
if
(
NS_WARN_IF
(
!
array
)
)
{
return
false
;
}
channelRef
=
array
;
}
else
if
(
aInit
=
=
ArrayElementInit
:
:
Zero
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
bool
isShared
;
float
*
elementData
=
JS_GetFloat32ArrayData
(
channelRef
&
isShared
nogc
)
;
MOZ_ASSERT
(
!
isShared
)
;
std
:
:
fill_n
(
elementData
WEBAUDIO_BLOCK_SIZE
0
.
0f
)
;
}
}
if
(
NS_WARN_IF
(
!
float32ArraysRef
.
reserve
(
channelCount
)
)
)
{
return
false
;
}
while
(
float32ArraysRef
.
length
(
)
<
channelCount
)
{
JSObject
*
array
=
JS_NewFloat32Array
(
aCx
WEBAUDIO_BLOCK_SIZE
)
;
if
(
NS_WARN_IF
(
!
array
)
)
{
return
false
;
}
float32ArraysRef
.
infallibleEmplaceBack
(
aCx
array
)
;
}
float32ArraysRef
.
shrinkTo
(
channelCount
)
;
if
(
NS_WARN_IF
(
!
PrepareArray
(
aCx
float32ArraysRef
&
portRef
.
mJSArray
)
)
)
{
return
false
;
}
}
return
!
(
NS_WARN_IF
(
!
PrepareArray
(
aCx
aPorts
-
>
mPorts
&
aPorts
-
>
mJSArray
)
)
)
;
}
bool
WorkletNodeEngine
:
:
CallProcess
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aCallable
bool
*
aActiveRet
)
{
JS
:
:
RootedVector
<
JS
:
:
Value
>
argv
(
aCx
)
;
if
(
NS_WARN_IF
(
!
argv
.
resize
(
3
)
)
)
{
return
false
;
}
argv
[
0
]
.
setObject
(
*
mInputs
.
mJSArray
)
;
argv
[
1
]
.
setObject
(
*
mOutputs
.
mJSArray
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
rval
(
aCx
)
;
if
(
!
JS
:
:
Call
(
aCx
mProcessor
aCallable
argv
&
rval
)
)
{
return
false
;
}
*
aActiveRet
=
JS
:
:
ToBoolean
(
rval
)
;
return
true
;
}
static
void
ProduceSilence
(
Span
<
AudioBlock
>
aOutput
)
{
for
(
AudioBlock
&
output
:
aOutput
)
{
output
.
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
}
}
void
WorkletNodeEngine
:
:
ProcessBlocksOnPorts
(
AudioNodeTrack
*
aTrack
Span
<
const
AudioBlock
>
aInput
Span
<
AudioBlock
>
aOutput
bool
*
aFinished
)
{
MOZ_ASSERT
(
aInput
.
Length
(
)
=
=
InputCount
(
)
)
;
MOZ_ASSERT
(
aOutput
.
Length
(
)
=
=
OutputCount
(
)
)
;
if
(
!
mProcessor
)
{
ProduceSilence
(
aOutput
)
;
return
;
}
if
(
!
mOutputChannelCount
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
mOutputChannelCount
.
Length
(
)
=
=
aOutput
.
Length
(
)
)
;
for
(
size_t
o
=
0
;
o
<
aOutput
.
Length
(
)
;
+
+
o
)
{
aOutput
[
o
]
.
AllocateChannels
(
mOutputChannelCount
[
o
]
)
;
}
}
else
if
(
aInput
.
Length
(
)
=
=
1
&
&
aOutput
.
Length
(
)
=
=
1
)
{
aOutput
[
0
]
.
AllocateChannels
(
aInput
[
0
]
.
ChannelCount
(
)
)
;
}
else
{
for
(
AudioBlock
&
output
:
aOutput
)
{
output
.
AllocateChannels
(
1
)
;
}
}
AutoEntryScript
aes
(
mGlobal
"
Worklet
Process
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
process
(
cx
)
;
if
(
!
JS_GetProperty
(
cx
mProcessor
"
process
"
&
process
)
|
|
!
process
.
isObject
(
)
|
|
!
JS
:
:
IsCallable
(
&
process
.
toObject
(
)
)
|
|
!
PrepareBufferArrays
(
cx
aInput
&
mInputs
ArrayElementInit
:
:
None
)
|
|
!
PrepareBufferArrays
(
cx
aOutput
&
mOutputs
ArrayElementInit
:
:
Zero
)
)
{
SendProcessorError
(
)
;
ProduceSilence
(
aOutput
)
;
return
;
}
for
(
size_t
i
=
0
;
i
<
aInput
.
Length
(
)
;
+
+
i
)
{
const
AudioBlock
&
input
=
aInput
[
i
]
;
size_t
channelCount
=
input
.
ChannelCount
(
)
;
if
(
channelCount
=
=
0
)
{
continue
;
}
float
volume
=
input
.
mVolume
;
const
auto
&
channelData
=
input
.
ChannelData
<
float
>
(
)
;
const
auto
&
float32Arrays
=
mInputs
.
mPorts
[
i
]
.
mFloat32Arrays
;
JS
:
:
AutoCheckCannotGC
nogc
;
for
(
size_t
c
=
0
;
c
<
channelCount
;
+
+
c
)
{
bool
isShared
;
float
*
dest
=
JS_GetFloat32ArrayData
(
float32Arrays
[
c
]
&
isShared
nogc
)
;
MOZ_ASSERT
(
!
isShared
)
;
AudioBlockCopyChannelWithScale
(
channelData
[
c
]
volume
dest
)
;
}
}
bool
active
;
if
(
!
CallProcess
(
cx
process
&
active
)
)
{
SendProcessorError
(
)
;
ProduceSilence
(
aOutput
)
;
return
;
}
for
(
size_t
o
=
0
;
o
<
aOutput
.
Length
(
)
;
+
+
o
)
{
AudioBlock
*
output
=
&
aOutput
[
o
]
;
size_t
channelCount
=
output
-
>
ChannelCount
(
)
;
const
auto
&
float32Arrays
=
mOutputs
.
mPorts
[
o
]
.
mFloat32Arrays
;
JS
:
:
AutoCheckCannotGC
nogc
;
for
(
size_t
c
=
0
;
c
<
channelCount
;
+
+
c
)
{
bool
isShared
;
const
float
*
src
=
JS_GetFloat32ArrayData
(
float32Arrays
[
c
]
&
isShared
nogc
)
;
MOZ_ASSERT
(
!
isShared
)
;
PodCopy
(
output
-
>
ChannelFloatsForWrite
(
c
)
src
WEBAUDIO_BLOCK_SIZE
)
;
}
}
}
AudioWorkletNode
:
:
AudioWorkletNode
(
AudioContext
*
aAudioContext
const
nsAString
&
aName
const
AudioWorkletNodeOptions
&
aOptions
)
:
AudioNode
(
aAudioContext
2
ChannelCountMode
:
:
Max
ChannelInterpretation
:
:
Speakers
)
mNodeName
(
aName
)
mInputCount
(
aOptions
.
mNumberOfInputs
)
mOutputCount
(
aOptions
.
mNumberOfOutputs
)
{
}
already_AddRefed
<
AudioWorkletNode
>
AudioWorkletNode
:
:
Constructor
(
const
GlobalObject
&
aGlobal
AudioContext
&
aAudioContext
const
nsAString
&
aName
const
AudioWorkletNodeOptions
&
aOptions
ErrorResult
&
aRv
)
{
const
AudioParamDescriptorMap
*
parameterDescriptors
=
aAudioContext
.
GetParamMapForWorkletName
(
aName
)
;
if
(
!
parameterDescriptors
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
RefPtr
<
AudioWorkletNode
>
audioWorkletNode
=
new
AudioWorkletNode
(
&
aAudioContext
aName
aOptions
)
;
audioWorkletNode
-
>
Initialize
(
aOptions
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
aOptions
.
mNumberOfInputs
=
=
0
&
&
aOptions
.
mNumberOfOutputs
=
=
0
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
if
(
aOptions
.
mOutputChannelCount
.
WasPassed
(
)
)
{
for
(
uint32_t
channelCount
:
aOptions
.
mOutputChannelCount
.
Value
(
)
)
{
if
(
channelCount
=
=
0
|
|
channelCount
>
WebAudioUtils
:
:
MaxChannelCount
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
}
if
(
aOptions
.
mOutputChannelCount
.
Value
(
)
.
Length
(
)
!
=
aOptions
.
mNumberOfOutputs
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
}
if
(
aOptions
.
mNumberOfInputs
>
UINT16_MAX
)
{
aRv
.
ThrowRangeError
<
MSG_VALUE_OUT_OF_RANGE
>
(
NS_LITERAL_STRING
(
"
numberOfInputs
"
)
)
;
return
nullptr
;
}
if
(
aOptions
.
mNumberOfOutputs
>
UINT16_MAX
)
{
aRv
.
ThrowRangeError
<
MSG_VALUE_OUT_OF_RANGE
>
(
NS_LITERAL_STRING
(
"
numberOfOutputs
"
)
)
;
return
nullptr
;
}
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
optionsVal
(
cx
)
;
if
(
NS_WARN_IF
(
!
ToJSValue
(
cx
aOptions
&
optionsVal
)
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
nullptr
;
}
UniquePtr
<
StructuredCloneHolder
>
serializedOptions
=
MakeUnique
<
StructuredCloneHolder
>
(
StructuredCloneHolder
:
:
CloningSupported
StructuredCloneHolder
:
:
TransferringNotSupported
JS
:
:
StructuredCloneScope
:
:
SameProcessDifferentThread
)
;
serializedOptions
-
>
Write
(
cx
optionsVal
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
auto
engine
=
new
WorkletNodeEngine
(
audioWorkletNode
aOptions
.
mOutputChannelCount
)
;
audioWorkletNode
-
>
mTrack
=
AudioNodeTrack
:
:
Create
(
&
aAudioContext
engine
AudioNodeTrack
:
:
NO_TRACK_FLAGS
aAudioContext
.
Graph
(
)
)
;
Worklet
*
worklet
=
aAudioContext
.
GetAudioWorklet
(
aRv
)
;
MOZ_ASSERT
(
worklet
"
Worklet
already
existed
and
so
getter
shouldn
'
t
fail
.
"
)
;
auto
workletImpl
=
static_cast
<
AudioWorkletImpl
*
>
(
worklet
-
>
Impl
(
)
)
;
audioWorkletNode
-
>
mTrack
-
>
SendRunnable
(
NS_NewRunnableFunction
(
"
WorkletNodeEngine
:
:
ConstructProcessor
"
[
track
=
audioWorkletNode
-
>
mTrack
workletImpl
=
RefPtr
<
AudioWorkletImpl
>
(
workletImpl
)
name
=
nsString
(
aName
)
options
=
std
:
:
move
(
serializedOptions
)
]
(
)
MOZ_CAN_RUN_SCRIPT_BOUNDARY
{
auto
engine
=
static_cast
<
WorkletNodeEngine
*
>
(
track
-
>
Engine
(
)
)
;
engine
-
>
ConstructProcessor
(
workletImpl
name
WrapNotNull
(
options
.
get
(
)
)
)
;
}
)
)
;
return
audioWorkletNode
.
forget
(
)
;
}
AudioParamMap
*
AudioWorkletNode
:
:
GetParameters
(
ErrorResult
&
aRv
)
const
{
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
MessagePort
*
AudioWorkletNode
:
:
GetPort
(
ErrorResult
&
aRv
)
const
{
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
JSObject
*
AudioWorkletNode
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
AudioWorkletNode_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
size_t
AudioWorkletNode
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
AudioNode
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
size_t
AudioWorkletNode
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
}
}
