#
include
"
AudioEventTimeline
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
static
float
LinearInterpolate
(
double
t0
float
v0
double
t1
float
v1
double
t
)
{
return
v0
+
(
v1
-
v0
)
*
(
(
t
-
t0
)
/
(
t1
-
t0
)
)
;
}
static
float
ExponentialInterpolate
(
double
t0
float
v0
double
t1
float
v1
double
t
)
{
return
v0
*
powf
(
v1
/
v0
(
t
-
t0
)
/
(
t1
-
t0
)
)
;
}
static
float
ExponentialApproach
(
double
t0
double
v0
float
v1
double
timeConstant
double
t
)
{
return
v1
+
(
v0
-
v1
)
*
expf
(
-
(
t
-
t0
)
/
timeConstant
)
;
}
static
float
ExtractValueFromCurve
(
double
startTime
float
*
aCurve
uint32_t
aCurveLength
double
duration
double
t
)
{
if
(
t
>
=
startTime
+
duration
)
{
return
aCurve
[
aCurveLength
-
1
]
;
}
double
ratio
=
std
:
:
max
(
(
t
-
startTime
)
/
duration
0
.
0
)
;
if
(
ratio
>
=
1
.
0
)
{
return
aCurve
[
aCurveLength
-
1
]
;
}
return
aCurve
[
uint32_t
(
aCurveLength
*
ratio
)
]
;
}
namespace
mozilla
{
namespace
dom
{
template
<
class
ErrorResult
>
bool
AudioEventTimeline
:
:
ValidateEvent
(
AudioTimelineEvent
&
aEvent
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
WebAudioUtils
:
:
IsTimeValid
(
aEvent
.
template
Time
<
double
>
(
)
)
|
|
!
WebAudioUtils
:
:
IsTimeValid
(
aEvent
.
mTimeConstant
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
if
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
if
(
!
aEvent
.
mCurve
|
|
!
aEvent
.
mCurveLength
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
aEvent
.
mCurveLength
;
+
+
i
)
{
if
(
!
IsValid
(
aEvent
.
mCurve
[
i
]
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
}
}
if
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
SetTarget
&
&
WebAudioUtils
:
:
FuzzyEqual
(
aEvent
.
mTimeConstant
0
.
0
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
bool
timeAndValueValid
=
IsValid
(
aEvent
.
mValue
)
&
&
IsValid
(
aEvent
.
mDuration
)
;
if
(
!
timeAndValueValid
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
mEvents
[
i
]
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
&
&
!
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
&
&
aEvent
.
template
Time
<
double
>
(
)
=
=
mEvents
[
i
]
.
template
Time
<
double
>
(
)
)
&
&
mEvents
[
i
]
.
template
Time
<
double
>
(
)
<
=
aEvent
.
template
Time
<
double
>
(
)
&
&
(
mEvents
[
i
]
.
template
Time
<
double
>
(
)
+
mEvents
[
i
]
.
mDuration
)
>
=
aEvent
.
template
Time
<
double
>
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
}
if
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
for
(
unsigned
i
=
0
;
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
if
(
mEvents
[
i
]
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
&
&
mEvents
[
i
]
.
template
Time
<
double
>
(
)
=
=
aEvent
.
template
Time
<
double
>
(
)
)
{
continue
;
}
if
(
mEvents
[
i
]
.
template
Time
<
double
>
(
)
>
aEvent
.
template
Time
<
double
>
(
)
&
&
mEvents
[
i
]
.
template
Time
<
double
>
(
)
<
(
aEvent
.
template
Time
<
double
>
(
)
+
aEvent
.
mDuration
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
}
}
if
(
aEvent
.
mType
=
=
AudioTimelineEvent
:
:
ExponentialRamp
)
{
if
(
aEvent
.
mValue
<
=
0
.
f
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
const
AudioTimelineEvent
*
previousEvent
=
GetPreviousEvent
(
aEvent
.
template
Time
<
double
>
(
)
)
;
if
(
previousEvent
)
{
if
(
previousEvent
-
>
mValue
<
=
0
.
f
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
}
else
{
if
(
mValue
<
=
0
.
f
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
}
}
return
true
;
}
template
bool
AudioEventTimeline
:
:
ValidateEvent
(
AudioTimelineEvent
&
aEvent
ErrorResult
&
aRv
)
;
template
<
class
TimeType
>
void
AudioEventTimeline
:
:
GetValuesAtTimeHelper
(
TimeType
aTime
float
*
aBuffer
const
size_t
aSize
)
{
MOZ_ASSERT
(
aBuffer
)
;
MOZ_ASSERT
(
aSize
)
;
size_t
lastEventId
=
0
;
const
AudioTimelineEvent
*
previous
=
nullptr
;
const
AudioTimelineEvent
*
next
=
nullptr
;
bool
bailOut
=
false
;
while
(
mEvents
.
Length
(
)
>
1
&
&
aTime
>
mEvents
[
1
]
.
template
Time
<
TimeType
>
(
)
)
{
mEvents
.
RemoveElementAt
(
0
)
;
}
for
(
size_t
bufferIndex
=
0
;
bufferIndex
<
aSize
;
+
+
bufferIndex
+
+
aTime
)
{
for
(
;
!
bailOut
&
&
lastEventId
<
mEvents
.
Length
(
)
;
+
+
lastEventId
)
{
#
ifdef
DEBUG
const
AudioTimelineEvent
*
current
=
&
mEvents
[
lastEventId
]
;
MOZ_ASSERT
(
current
-
>
mType
=
=
AudioTimelineEvent
:
:
SetValueAtTime
|
|
current
-
>
mType
=
=
AudioTimelineEvent
:
:
SetTarget
|
|
current
-
>
mType
=
=
AudioTimelineEvent
:
:
LinearRamp
|
|
current
-
>
mType
=
=
AudioTimelineEvent
:
:
ExponentialRamp
|
|
current
-
>
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
;
#
endif
if
(
TimesEqual
(
aTime
mEvents
[
lastEventId
]
.
template
Time
<
TimeType
>
(
)
)
)
{
mLastComputedValue
=
mComputedValue
;
while
(
lastEventId
<
mEvents
.
Length
(
)
-
1
&
&
TimesEqual
(
aTime
mEvents
[
lastEventId
+
1
]
.
template
Time
<
TimeType
>
(
)
)
)
{
+
+
lastEventId
;
}
break
;
}
previous
=
next
;
next
=
&
mEvents
[
lastEventId
]
;
if
(
aTime
<
mEvents
[
lastEventId
]
.
template
Time
<
TimeType
>
(
)
)
{
bailOut
=
true
;
}
}
if
(
!
bailOut
&
&
lastEventId
<
mEvents
.
Length
(
)
)
{
MOZ_ASSERT
(
TimesEqual
(
aTime
mEvents
[
lastEventId
]
.
template
Time
<
TimeType
>
(
)
)
)
;
if
(
mEvents
[
lastEventId
]
.
mType
=
=
AudioTimelineEvent
:
:
SetTarget
)
{
aBuffer
[
bufferIndex
]
=
ExponentialApproach
(
mEvents
[
lastEventId
]
.
template
Time
<
TimeType
>
(
)
mLastComputedValue
mEvents
[
lastEventId
]
.
mValue
mEvents
[
lastEventId
]
.
mTimeConstant
aTime
)
;
continue
;
}
if
(
mEvents
[
lastEventId
]
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
aBuffer
[
bufferIndex
]
=
ExtractValueFromCurve
(
mEvents
[
lastEventId
]
.
template
Time
<
TimeType
>
(
)
mEvents
[
lastEventId
]
.
mCurve
mEvents
[
lastEventId
]
.
mCurveLength
mEvents
[
lastEventId
]
.
mDuration
aTime
)
;
continue
;
}
aBuffer
[
bufferIndex
]
=
mEvents
[
lastEventId
]
.
mValue
;
continue
;
}
if
(
!
bailOut
)
{
aBuffer
[
bufferIndex
]
=
GetValuesAtTimeHelperInternal
(
aTime
next
nullptr
)
;
}
else
{
aBuffer
[
bufferIndex
]
=
GetValuesAtTimeHelperInternal
(
aTime
previous
next
)
;
}
}
}
template
void
AudioEventTimeline
:
:
GetValuesAtTimeHelper
(
double
aTime
float
*
aBuffer
const
size_t
aSize
)
;
template
void
AudioEventTimeline
:
:
GetValuesAtTimeHelper
(
int64_t
aTime
float
*
aBuffer
const
size_t
aSize
)
;
template
<
class
TimeType
>
float
AudioEventTimeline
:
:
GetValuesAtTimeHelperInternal
(
TimeType
aTime
const
AudioTimelineEvent
*
aPrevious
const
AudioTimelineEvent
*
aNext
)
{
if
(
!
aPrevious
)
{
return
mValue
;
}
if
(
aPrevious
-
>
mType
=
=
AudioTimelineEvent
:
:
SetTarget
)
{
return
ExponentialApproach
(
aPrevious
-
>
template
Time
<
TimeType
>
(
)
mLastComputedValue
aPrevious
-
>
mValue
aPrevious
-
>
mTimeConstant
aTime
)
;
}
if
(
aPrevious
-
>
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
return
ExtractValueFromCurve
(
aPrevious
-
>
template
Time
<
TimeType
>
(
)
aPrevious
-
>
mCurve
aPrevious
-
>
mCurveLength
aPrevious
-
>
mDuration
aTime
)
;
}
if
(
!
aNext
)
{
switch
(
aPrevious
-
>
mType
)
{
case
AudioTimelineEvent
:
:
SetValueAtTime
:
case
AudioTimelineEvent
:
:
LinearRamp
:
case
AudioTimelineEvent
:
:
ExponentialRamp
:
return
aPrevious
-
>
mValue
;
case
AudioTimelineEvent
:
:
SetValueCurve
:
return
ExtractValueFromCurve
(
aPrevious
-
>
template
Time
<
TimeType
>
(
)
aPrevious
-
>
mCurve
aPrevious
-
>
mCurveLength
aPrevious
-
>
mDuration
aTime
)
;
case
AudioTimelineEvent
:
:
SetTarget
:
MOZ_FALLTHROUGH_ASSERT
(
"
AudioTimelineEvent
:
:
SetTarget
"
)
;
case
AudioTimelineEvent
:
:
SetValue
:
case
AudioTimelineEvent
:
:
Cancel
:
case
AudioTimelineEvent
:
:
Stream
:
MOZ_ASSERT
(
false
"
Should
have
been
handled
earlier
.
"
)
;
}
MOZ_ASSERT
(
false
"
unreached
"
)
;
}
switch
(
aNext
-
>
mType
)
{
case
AudioTimelineEvent
:
:
LinearRamp
:
return
LinearInterpolate
(
aPrevious
-
>
template
Time
<
TimeType
>
(
)
aPrevious
-
>
mValue
aNext
-
>
template
Time
<
TimeType
>
(
)
aNext
-
>
mValue
aTime
)
;
case
AudioTimelineEvent
:
:
ExponentialRamp
:
return
ExponentialInterpolate
(
aPrevious
-
>
template
Time
<
TimeType
>
(
)
aPrevious
-
>
mValue
aNext
-
>
template
Time
<
TimeType
>
(
)
aNext
-
>
mValue
aTime
)
;
case
AudioTimelineEvent
:
:
SetValueAtTime
:
case
AudioTimelineEvent
:
:
SetTarget
:
case
AudioTimelineEvent
:
:
SetValueCurve
:
break
;
case
AudioTimelineEvent
:
:
SetValue
:
case
AudioTimelineEvent
:
:
Cancel
:
case
AudioTimelineEvent
:
:
Stream
:
MOZ_ASSERT
(
false
"
Should
have
been
handled
earlier
.
"
)
;
}
switch
(
aPrevious
-
>
mType
)
{
case
AudioTimelineEvent
:
:
SetValueAtTime
:
case
AudioTimelineEvent
:
:
LinearRamp
:
case
AudioTimelineEvent
:
:
ExponentialRamp
:
return
aPrevious
-
>
mValue
;
case
AudioTimelineEvent
:
:
SetValueCurve
:
return
ExtractValueFromCurve
(
aPrevious
-
>
template
Time
<
TimeType
>
(
)
aPrevious
-
>
mCurve
aPrevious
-
>
mCurveLength
aPrevious
-
>
mDuration
aTime
)
;
case
AudioTimelineEvent
:
:
SetTarget
:
MOZ_FALLTHROUGH_ASSERT
(
"
AudioTimelineEvent
:
:
SetTarget
"
)
;
case
AudioTimelineEvent
:
:
SetValue
:
case
AudioTimelineEvent
:
:
Cancel
:
case
AudioTimelineEvent
:
:
Stream
:
MOZ_ASSERT
(
false
"
Should
have
been
handled
earlier
.
"
)
;
}
MOZ_ASSERT
(
false
"
unreached
"
)
;
return
0
.
0f
;
}
template
float
AudioEventTimeline
:
:
GetValuesAtTimeHelperInternal
(
double
aTime
const
AudioTimelineEvent
*
aPrevious
const
AudioTimelineEvent
*
aNext
)
;
template
float
AudioEventTimeline
:
:
GetValuesAtTimeHelperInternal
(
int64_t
aTime
const
AudioTimelineEvent
*
aPrevious
const
AudioTimelineEvent
*
aNext
)
;
const
AudioTimelineEvent
*
AudioEventTimeline
:
:
GetPreviousEvent
(
double
aTime
)
const
{
const
AudioTimelineEvent
*
previous
=
nullptr
;
const
AudioTimelineEvent
*
next
=
nullptr
;
bool
bailOut
=
false
;
for
(
unsigned
i
=
0
;
!
bailOut
&
&
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
switch
(
mEvents
[
i
]
.
mType
)
{
case
AudioTimelineEvent
:
:
SetValueAtTime
:
case
AudioTimelineEvent
:
:
SetTarget
:
case
AudioTimelineEvent
:
:
LinearRamp
:
case
AudioTimelineEvent
:
:
ExponentialRamp
:
case
AudioTimelineEvent
:
:
SetValueCurve
:
if
(
aTime
=
=
mEvents
[
i
]
.
template
Time
<
double
>
(
)
)
{
do
{
+
+
i
;
}
while
(
i
<
mEvents
.
Length
(
)
&
&
aTime
=
=
mEvents
[
i
]
.
template
Time
<
double
>
(
)
)
;
return
&
mEvents
[
i
-
1
]
;
}
previous
=
next
;
next
=
&
mEvents
[
i
]
;
if
(
aTime
<
mEvents
[
i
]
.
template
Time
<
double
>
(
)
)
{
bailOut
=
true
;
}
break
;
default
:
MOZ_ASSERT
(
false
"
unreached
"
)
;
}
}
if
(
!
bailOut
)
{
previous
=
next
;
}
return
previous
;
}
}
}
