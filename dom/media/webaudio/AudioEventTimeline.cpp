#
include
"
AudioEventTimeline
.
h
"
#
include
"
AudioNodeTrack
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
static
float
LinearInterpolate
(
double
t0
float
v0
double
t1
float
v1
double
t
)
{
return
v0
+
(
v1
-
v0
)
*
(
(
t
-
t0
)
/
(
t1
-
t0
)
)
;
}
static
float
ExponentialInterpolate
(
double
t0
float
v0
double
t1
float
v1
double
t
)
{
return
v0
*
fdlibm_powf
(
v1
/
v0
(
t
-
t0
)
/
(
t1
-
t0
)
)
;
}
static
float
ExponentialApproach
(
double
t0
double
v0
float
v1
double
timeConstant
double
t
)
{
if
(
!
mozilla
:
:
dom
:
:
WebAudioUtils
:
:
FuzzyEqual
(
timeConstant
0
.
0
)
)
{
return
v1
+
(
v0
-
v1
)
*
fdlibm_expf
(
-
(
t
-
t0
)
/
timeConstant
)
;
}
else
{
return
v1
;
}
}
static
float
ExtractValueFromCurve
(
double
startTime
float
*
aCurve
uint32_t
aCurveLength
double
duration
double
t
)
{
if
(
t
>
=
startTime
+
duration
)
{
return
aCurve
[
aCurveLength
-
1
]
;
}
double
ratio
=
std
:
:
max
(
(
t
-
startTime
)
/
duration
0
.
0
)
;
if
(
ratio
>
=
1
.
0
)
{
return
aCurve
[
aCurveLength
-
1
]
;
}
uint32_t
current
=
uint32_t
(
floor
(
(
aCurveLength
-
1
)
*
ratio
)
)
;
uint32_t
next
=
current
+
1
;
double
step
=
duration
/
double
(
aCurveLength
-
1
)
;
if
(
next
<
aCurveLength
)
{
double
t0
=
current
*
step
;
double
t1
=
next
*
step
;
return
LinearInterpolate
(
t0
aCurve
[
current
]
t1
aCurve
[
next
]
t
-
startTime
)
;
}
else
{
return
aCurve
[
current
]
;
}
}
namespace
mozilla
:
:
dom
{
AudioTimelineEvent
:
:
AudioTimelineEvent
(
Type
aType
double
aTime
float
aValue
double
aTimeConstant
double
aDuration
const
float
*
aCurve
uint32_t
aCurveLength
)
:
mType
(
aType
)
mCurve
(
nullptr
)
mTimeConstant
(
aTimeConstant
)
mDuration
(
aDuration
)
mTime
(
aTime
)
{
if
(
aType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
SetCurveParams
(
aCurve
aCurveLength
)
;
}
else
{
mValue
=
aValue
;
}
}
AudioTimelineEvent
:
:
AudioTimelineEvent
(
AudioNodeTrack
*
aTrack
)
:
mType
(
Track
)
mCurve
(
nullptr
)
mTrack
(
aTrack
)
mTimeConstant
(
0
.
0
)
mDuration
(
0
.
0
)
mTime
(
0
.
0
)
{
}
AudioTimelineEvent
:
:
AudioTimelineEvent
(
const
AudioTimelineEvent
&
rhs
)
{
PodCopy
(
this
&
rhs
1
)
;
if
(
rhs
.
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
SetCurveParams
(
rhs
.
mCurve
rhs
.
mCurveLength
)
;
}
else
if
(
rhs
.
mType
=
=
AudioTimelineEvent
:
:
Track
)
{
new
(
&
mTrack
)
decltype
(
mTrack
)
(
rhs
.
mTrack
)
;
}
}
AudioTimelineEvent
:
:
~
AudioTimelineEvent
(
)
{
if
(
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
delete
[
]
mCurve
;
}
}
template
<
class
TimeType
>
float
AudioEventTimeline
:
:
ComputeSetTargetStartValue
(
const
AudioTimelineEvent
*
aPreviousEvent
TimeType
aTime
)
{
mSetTargetStartTime
=
aTime
;
mSetTargetStartValue
=
GetValuesAtTimeHelperInternal
(
aTime
aPreviousEvent
nullptr
)
;
return
mSetTargetStartValue
;
}
template
void
AudioEventTimeline
:
:
CleanupEventsOlderThan
(
double
)
;
template
void
AudioEventTimeline
:
:
CleanupEventsOlderThan
(
int64_t
)
;
template
<
class
TimeType
>
void
AudioEventTimeline
:
:
CleanupEventsOlderThan
(
TimeType
aTime
)
{
auto
TimeOf
=
[
]
(
const
decltype
(
mEvents
)
:
:
const_iterator
&
aEvent
)
-
>
TimeType
{
return
aEvent
-
>
Time
<
TimeType
>
(
)
;
}
;
auto
begin
=
mEvents
.
cbegin
(
)
;
auto
end
=
mEvents
.
cend
(
)
;
auto
event
=
begin
+
1
;
for
(
;
event
<
end
&
&
aTime
>
TimeOf
(
event
)
;
+
+
event
)
{
MOZ_ASSERT
(
!
(
event
-
1
)
-
>
mTrack
"
AudioParam
tracks
should
never
be
destroyed
on
the
real
-
time
"
"
thread
.
"
)
;
}
auto
firstToKeep
=
event
-
1
;
if
(
firstToKeep
=
=
begin
)
{
return
;
}
for
(
event
=
firstToKeep
;
event
>
begin
&
&
event
-
>
mType
=
=
AudioTimelineEvent
:
:
SetTarget
&
&
TimeOf
(
event
)
>
mSetTargetStartTime
.
Get
<
TimeType
>
(
)
;
-
-
event
)
{
}
for
(
;
event
<
firstToKeep
;
+
+
event
)
{
MOZ_ASSERT
(
(
event
+
1
)
-
>
mType
=
=
AudioTimelineEvent
:
:
SetTarget
)
;
ComputeSetTargetStartValue
(
&
*
event
TimeOf
(
event
+
1
)
)
;
}
JS
:
:
AutoSuppressGCAnalysis
suppress
;
mEvents
.
RemoveElementsRange
(
begin
firstToKeep
)
;
}
template
<
class
TimeType
>
void
AudioEventTimeline
:
:
GetValuesAtTimeHelper
(
TimeType
aTime
float
*
aBuffer
const
size_t
aSize
)
{
MOZ_ASSERT
(
aBuffer
)
;
MOZ_ASSERT
(
aSize
)
;
auto
TimeOf
=
[
]
(
const
AudioTimelineEvent
&
aEvent
)
-
>
TimeType
{
return
aEvent
.
Time
<
TimeType
>
(
)
;
}
;
size_t
eventIndex
=
0
;
const
AudioTimelineEvent
*
previous
=
nullptr
;
CleanupEventsOlderThan
(
aTime
)
;
for
(
size_t
bufferIndex
=
0
;
bufferIndex
<
aSize
;
+
+
bufferIndex
+
+
aTime
)
{
bool
timeMatchesEventIndex
=
false
;
const
AudioTimelineEvent
*
next
;
for
(
;
;
+
+
eventIndex
)
{
if
(
eventIndex
>
=
mEvents
.
Length
(
)
)
{
next
=
nullptr
;
break
;
}
next
=
&
mEvents
[
eventIndex
]
;
if
(
aTime
<
TimeOf
(
*
next
)
)
{
break
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
next
-
>
mType
=
=
AudioTimelineEvent
:
:
SetValueAtTime
|
|
next
-
>
mType
=
=
AudioTimelineEvent
:
:
SetTarget
|
|
next
-
>
mType
=
=
AudioTimelineEvent
:
:
LinearRamp
|
|
next
-
>
mType
=
=
AudioTimelineEvent
:
:
ExponentialRamp
|
|
next
-
>
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
;
#
endif
if
(
TimesEqual
(
aTime
TimeOf
(
*
next
)
)
)
{
timeMatchesEventIndex
=
true
;
aBuffer
[
bufferIndex
]
=
GetValueAtTimeOfEvent
<
TimeType
>
(
next
previous
)
;
}
previous
=
next
;
}
if
(
timeMatchesEventIndex
)
{
MOZ_ASSERT
(
TimesEqual
(
aTime
TimeOf
(
mEvents
[
eventIndex
-
1
]
)
)
)
;
}
else
{
aBuffer
[
bufferIndex
]
=
GetValuesAtTimeHelperInternal
(
aTime
previous
next
)
;
}
}
}
template
void
AudioEventTimeline
:
:
GetValuesAtTimeHelper
(
double
aTime
float
*
aBuffer
const
size_t
aSize
)
;
template
void
AudioEventTimeline
:
:
GetValuesAtTimeHelper
(
int64_t
aTime
float
*
aBuffer
const
size_t
aSize
)
;
template
<
class
TimeType
>
float
AudioEventTimeline
:
:
GetValueAtTimeOfEvent
(
const
AudioTimelineEvent
*
aEvent
const
AudioTimelineEvent
*
aPrevious
)
{
TimeType
time
=
aEvent
-
>
Time
<
TimeType
>
(
)
;
switch
(
aEvent
-
>
mType
)
{
case
AudioTimelineEvent
:
:
SetTarget
:
return
ComputeSetTargetStartValue
(
aPrevious
time
)
;
case
AudioTimelineEvent
:
:
SetValueCurve
:
return
ExtractValueFromCurve
(
time
aEvent
-
>
mCurve
aEvent
-
>
mCurveLength
aEvent
-
>
mDuration
time
)
;
break
;
default
:
return
aEvent
-
>
mValue
;
}
}
template
<
class
TimeType
>
float
AudioEventTimeline
:
:
GetValuesAtTimeHelperInternal
(
TimeType
aTime
const
AudioTimelineEvent
*
aPrevious
const
AudioTimelineEvent
*
aNext
)
{
if
(
!
aPrevious
)
{
return
mDefaultValue
;
}
auto
TimeOf
=
[
]
(
const
AudioTimelineEvent
*
aEvent
)
-
>
TimeType
{
if
(
aEvent
-
>
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
return
aEvent
-
>
Time
<
TimeType
>
(
)
+
aEvent
-
>
mDuration
;
}
return
aEvent
-
>
Time
<
TimeType
>
(
)
;
}
;
auto
ValueOf
=
[
]
(
const
AudioTimelineEvent
*
aEvent
)
-
>
float
{
if
(
aEvent
-
>
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
)
{
return
aEvent
-
>
mCurve
[
aEvent
-
>
mCurveLength
-
1
]
;
}
return
aEvent
-
>
mValue
;
}
;
if
(
aPrevious
-
>
mType
=
=
AudioTimelineEvent
:
:
SetTarget
)
{
return
ExponentialApproach
(
TimeOf
(
aPrevious
)
mSetTargetStartValue
ValueOf
(
aPrevious
)
aPrevious
-
>
mTimeConstant
aTime
)
;
}
if
(
aPrevious
-
>
mType
=
=
AudioTimelineEvent
:
:
SetValueCurve
&
&
aTime
<
=
aPrevious
-
>
Time
<
TimeType
>
(
)
+
aPrevious
-
>
mDuration
)
{
return
ExtractValueFromCurve
(
aPrevious
-
>
Time
<
TimeType
>
(
)
aPrevious
-
>
mCurve
aPrevious
-
>
mCurveLength
aPrevious
-
>
mDuration
aTime
)
;
}
if
(
!
aNext
)
{
switch
(
aPrevious
-
>
mType
)
{
case
AudioTimelineEvent
:
:
SetValueAtTime
:
case
AudioTimelineEvent
:
:
LinearRamp
:
case
AudioTimelineEvent
:
:
ExponentialRamp
:
return
aPrevious
-
>
mValue
;
case
AudioTimelineEvent
:
:
SetValueCurve
:
return
ExtractValueFromCurve
(
aPrevious
-
>
Time
<
TimeType
>
(
)
aPrevious
-
>
mCurve
aPrevious
-
>
mCurveLength
aPrevious
-
>
mDuration
aTime
)
;
case
AudioTimelineEvent
:
:
SetTarget
:
MOZ_FALLTHROUGH_ASSERT
(
"
AudioTimelineEvent
:
:
SetTarget
"
)
;
case
AudioTimelineEvent
:
:
SetValue
:
case
AudioTimelineEvent
:
:
Cancel
:
case
AudioTimelineEvent
:
:
Track
:
MOZ_ASSERT
(
false
"
Should
have
been
handled
earlier
.
"
)
;
}
MOZ_ASSERT
(
false
"
unreached
"
)
;
}
switch
(
aNext
-
>
mType
)
{
case
AudioTimelineEvent
:
:
LinearRamp
:
return
LinearInterpolate
(
TimeOf
(
aPrevious
)
ValueOf
(
aPrevious
)
TimeOf
(
aNext
)
ValueOf
(
aNext
)
aTime
)
;
case
AudioTimelineEvent
:
:
ExponentialRamp
:
return
ExponentialInterpolate
(
TimeOf
(
aPrevious
)
ValueOf
(
aPrevious
)
TimeOf
(
aNext
)
ValueOf
(
aNext
)
aTime
)
;
case
AudioTimelineEvent
:
:
SetValueAtTime
:
case
AudioTimelineEvent
:
:
SetTarget
:
case
AudioTimelineEvent
:
:
SetValueCurve
:
break
;
case
AudioTimelineEvent
:
:
SetValue
:
case
AudioTimelineEvent
:
:
Cancel
:
case
AudioTimelineEvent
:
:
Track
:
MOZ_ASSERT
(
false
"
Should
have
been
handled
earlier
.
"
)
;
}
switch
(
aPrevious
-
>
mType
)
{
case
AudioTimelineEvent
:
:
SetValueAtTime
:
case
AudioTimelineEvent
:
:
LinearRamp
:
case
AudioTimelineEvent
:
:
ExponentialRamp
:
return
aPrevious
-
>
mValue
;
case
AudioTimelineEvent
:
:
SetValueCurve
:
return
ExtractValueFromCurve
(
aPrevious
-
>
Time
<
TimeType
>
(
)
aPrevious
-
>
mCurve
aPrevious
-
>
mCurveLength
aPrevious
-
>
mDuration
aTime
)
;
case
AudioTimelineEvent
:
:
SetTarget
:
MOZ_FALLTHROUGH_ASSERT
(
"
AudioTimelineEvent
:
:
SetTarget
"
)
;
case
AudioTimelineEvent
:
:
SetValue
:
case
AudioTimelineEvent
:
:
Cancel
:
case
AudioTimelineEvent
:
:
Track
:
MOZ_ASSERT
(
false
"
Should
have
been
handled
earlier
.
"
)
;
}
MOZ_ASSERT
(
false
"
unreached
"
)
;
return
0
.
0f
;
}
template
float
AudioEventTimeline
:
:
GetValuesAtTimeHelperInternal
(
double
aTime
const
AudioTimelineEvent
*
aPrevious
const
AudioTimelineEvent
*
aNext
)
;
template
float
AudioEventTimeline
:
:
GetValuesAtTimeHelperInternal
(
int64_t
aTime
const
AudioTimelineEvent
*
aPrevious
const
AudioTimelineEvent
*
aNext
)
;
const
AudioTimelineEvent
*
AudioEventTimeline
:
:
GetPreviousEvent
(
double
aTime
)
const
{
const
AudioTimelineEvent
*
previous
=
nullptr
;
const
AudioTimelineEvent
*
next
=
nullptr
;
auto
TimeOf
=
[
]
(
const
AudioTimelineEvent
&
aEvent
)
-
>
double
{
return
aEvent
.
Time
<
double
>
(
)
;
}
;
bool
bailOut
=
false
;
for
(
unsigned
i
=
0
;
!
bailOut
&
&
i
<
mEvents
.
Length
(
)
;
+
+
i
)
{
switch
(
mEvents
[
i
]
.
mType
)
{
case
AudioTimelineEvent
:
:
SetValueAtTime
:
case
AudioTimelineEvent
:
:
SetTarget
:
case
AudioTimelineEvent
:
:
LinearRamp
:
case
AudioTimelineEvent
:
:
ExponentialRamp
:
case
AudioTimelineEvent
:
:
SetValueCurve
:
if
(
aTime
=
=
TimeOf
(
mEvents
[
i
]
)
)
{
do
{
+
+
i
;
}
while
(
i
<
mEvents
.
Length
(
)
&
&
aTime
=
=
TimeOf
(
mEvents
[
i
]
)
)
;
return
&
mEvents
[
i
-
1
]
;
}
previous
=
next
;
next
=
&
mEvents
[
i
]
;
if
(
aTime
<
TimeOf
(
mEvents
[
i
]
)
)
{
bailOut
=
true
;
}
break
;
default
:
MOZ_ASSERT
(
false
"
unreached
"
)
;
}
}
if
(
!
bailOut
)
{
previous
=
next
;
}
return
previous
;
}
}
