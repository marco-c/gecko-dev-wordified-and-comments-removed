var
context
;
var
filter
;
var
signal
;
var
renderedBuffer
;
var
renderedData
;
var
sampleRate
=
44100
.
0
;
var
pulseLengthFrames
=
.
1
*
sampleRate
;
var
maxAllowedError
=
5
.
9e
-
8
;
var
timeStep
=
.
1
;
var
maxFilters
=
5
;
var
renderLengthSeconds
=
timeStep
*
(
maxFilters
+
1
)
;
var
renderLengthSamples
=
Math
.
round
(
renderLengthSeconds
*
sampleRate
)
;
var
nFilters
;
function
createImpulseBuffer
(
context
length
)
{
var
impulse
=
context
.
createBuffer
(
1
length
context
.
sampleRate
)
;
var
data
=
impulse
.
getChannelData
(
0
)
;
for
(
var
k
=
1
;
k
<
data
.
length
;
+
+
k
)
{
data
[
k
]
=
0
;
}
data
[
0
]
=
1
;
return
impulse
;
}
function
createTestAndRun
(
context
filterType
filterParameters
)
{
nFilters
=
Math
.
min
(
filterParameters
.
length
maxFilters
)
;
signal
=
new
Array
(
nFilters
)
;
filter
=
new
Array
(
nFilters
)
;
impulse
=
createImpulseBuffer
(
context
pulseLengthFrames
)
;
for
(
var
k
=
0
;
k
<
nFilters
;
+
+
k
)
{
signal
[
k
]
=
context
.
createBufferSource
(
)
;
signal
[
k
]
.
buffer
=
impulse
;
filter
[
k
]
=
context
.
createBiquadFilter
(
)
;
filter
[
k
]
.
type
=
filterType
;
filter
[
k
]
.
frequency
.
value
=
context
.
sampleRate
/
2
*
filterParameters
[
k
]
.
cutoff
;
filter
[
k
]
.
detune
.
value
=
(
filterParameters
[
k
]
.
detune
=
=
=
undefined
)
?
0
:
filterParameters
[
k
]
.
detune
;
filter
[
k
]
.
Q
.
value
=
filterParameters
[
k
]
.
q
;
filter
[
k
]
.
gain
.
value
=
filterParameters
[
k
]
.
gain
;
signal
[
k
]
.
connect
(
filter
[
k
]
)
;
filter
[
k
]
.
connect
(
context
.
destination
)
;
signal
[
k
]
.
start
(
timeStep
*
k
)
;
}
context
.
oncomplete
=
checkFilterResponse
(
filterType
filterParameters
)
;
context
.
startRendering
(
)
;
}
function
addSignal
(
dest
src
destOffset
)
{
for
(
var
k
=
destOffset
j
=
0
;
k
<
dest
.
length
j
<
src
.
length
;
+
+
k
+
+
j
)
{
dest
[
k
]
+
=
src
[
j
]
;
}
}
function
generateReference
(
filterType
filterParameters
)
{
var
result
=
new
Array
(
renderLengthSamples
)
;
var
data
=
new
Array
(
renderLengthSamples
)
;
for
(
var
k
=
0
;
k
<
result
.
length
;
+
+
k
)
{
result
[
k
]
=
0
;
data
[
k
]
=
0
;
}
data
[
0
]
=
1
;
for
(
var
k
=
0
;
k
<
nFilters
;
+
+
k
)
{
var
detune
=
(
filterParameters
[
k
]
.
detune
=
=
=
undefined
)
?
0
:
filterParameters
[
k
]
.
detune
;
var
frequency
=
filterParameters
[
k
]
.
cutoff
*
Math
.
pow
(
2
detune
/
1200
)
;
var
filterCoef
=
createFilter
(
filterType
frequency
filterParameters
[
k
]
.
q
filterParameters
[
k
]
.
gain
)
;
var
y
=
filterData
(
filterCoef
data
renderLengthSamples
)
;
addSignal
(
result
y
timeToSampleFrame
(
timeStep
*
k
sampleRate
)
)
;
}
return
result
;
}
function
checkFilterResponse
(
filterType
filterParameters
)
{
return
function
(
event
)
{
renderedBuffer
=
event
.
renderedBuffer
;
renderedData
=
renderedBuffer
.
getChannelData
(
0
)
;
reference
=
generateReference
(
filterType
filterParameters
)
;
var
len
=
Math
.
min
(
renderedData
.
length
reference
.
length
)
;
var
success
=
true
;
var
maxError
=
0
;
var
maxPosition
=
0
;
var
invalidNumberCount
=
0
;
if
(
nFilters
!
=
filterParameters
.
length
)
{
testFailed
(
"
Test
wanted
"
+
filterParameters
.
length
+
"
filters
but
only
"
+
maxFilters
+
"
allowed
.
"
)
;
success
=
false
;
}
for
(
var
k
=
0
;
k
<
len
;
+
+
k
)
{
var
err
=
Math
.
abs
(
renderedData
[
k
]
-
reference
[
k
]
)
;
if
(
err
>
maxError
)
{
maxError
=
err
;
maxPosition
=
k
;
}
if
(
!
isValidNumber
(
renderedData
[
k
]
)
)
{
+
+
invalidNumberCount
;
}
}
if
(
invalidNumberCount
>
0
)
{
testFailed
(
"
Rendered
output
has
"
+
invalidNumberCount
+
"
infinities
or
NaNs
.
"
)
;
success
=
false
;
}
else
{
testPassed
(
"
Rendered
output
did
not
have
infinities
or
NaNs
.
"
)
;
}
if
(
maxError
<
=
maxAllowedError
)
{
testPassed
(
filterTypeName
[
filterType
]
+
"
response
is
correct
.
"
)
;
}
else
{
testFailed
(
filterTypeName
[
filterType
]
+
"
response
is
incorrect
.
Max
err
=
"
+
maxError
+
"
at
"
+
maxPosition
+
"
.
Threshold
=
"
+
maxAllowedError
)
;
success
=
false
;
}
if
(
success
)
{
testPassed
(
"
Test
signal
was
correctly
filtered
.
"
)
;
}
else
{
testFailed
(
"
Test
signal
was
not
correctly
filtered
.
"
)
;
}
finishJSTest
(
)
;
}
}
