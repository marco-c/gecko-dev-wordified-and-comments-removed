#
include
"
mozilla
/
dom
/
ChannelSplitterNode
.
h
"
#
include
"
mozilla
/
dom
/
ChannelSplitterNodeBinding
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeTrack
.
h
"
namespace
mozilla
{
namespace
dom
{
class
ChannelSplitterNodeEngine
final
:
public
AudioNodeEngine
{
public
:
explicit
ChannelSplitterNodeEngine
(
ChannelSplitterNode
*
aNode
)
:
AudioNodeEngine
(
aNode
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
ProcessBlocksOnPorts
(
AudioNodeTrack
*
aTrack
Span
<
const
AudioBlock
>
aInput
Span
<
AudioBlock
>
aOutput
bool
*
aFinished
)
override
{
MOZ_ASSERT
(
aInput
.
Length
(
)
=
=
1
"
Should
only
have
one
input
port
"
)
;
MOZ_ASSERT
(
aOutput
.
Length
(
)
=
=
OutputCount
(
)
)
;
for
(
uint16_t
i
=
0
;
i
<
OutputCount
(
)
;
+
+
i
)
{
if
(
i
<
aInput
[
0
]
.
ChannelCount
(
)
)
{
aOutput
[
i
]
.
AllocateChannels
(
1
)
;
AudioBlockCopyChannelWithScale
(
static_cast
<
const
float
*
>
(
aInput
[
0
]
.
mChannelData
[
i
]
)
aInput
[
0
]
.
mVolume
aOutput
[
i
]
.
ChannelFloatsForWrite
(
0
)
)
;
}
else
{
aOutput
[
i
]
.
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
}
}
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
}
;
ChannelSplitterNode
:
:
ChannelSplitterNode
(
AudioContext
*
aContext
uint16_t
aOutputCount
)
:
AudioNode
(
aContext
aOutputCount
ChannelCountMode
:
:
Explicit
ChannelInterpretation
:
:
Discrete
)
mOutputCount
(
aOutputCount
)
{
mTrack
=
AudioNodeTrack
:
:
Create
(
aContext
new
ChannelSplitterNodeEngine
(
this
)
AudioNodeTrack
:
:
NO_TRACK_FLAGS
aContext
-
>
Graph
(
)
)
;
}
already_AddRefed
<
ChannelSplitterNode
>
ChannelSplitterNode
:
:
Create
(
AudioContext
&
aAudioContext
const
ChannelSplitterOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
aOptions
.
mNumberOfOutputs
=
=
0
|
|
aOptions
.
mNumberOfOutputs
>
WebAudioUtils
:
:
MaxChannelCount
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
RefPtr
<
ChannelSplitterNode
>
audioNode
=
new
ChannelSplitterNode
(
&
aAudioContext
aOptions
.
mNumberOfOutputs
)
;
if
(
aOptions
.
mChannelCount
.
WasPassed
(
)
&
&
aOptions
.
mChannelCount
.
Value
(
)
!
=
audioNode
-
>
ChannelCount
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
if
(
aOptions
.
mChannelInterpretation
.
WasPassed
(
)
&
&
aOptions
.
mChannelInterpretation
.
Value
(
)
!
=
audioNode
-
>
ChannelInterpretationValue
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
if
(
aOptions
.
mChannelCountMode
.
WasPassed
(
)
&
&
aOptions
.
mChannelCountMode
.
Value
(
)
!
=
audioNode
-
>
ChannelCountModeValue
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
return
audioNode
.
forget
(
)
;
}
JSObject
*
ChannelSplitterNode
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ChannelSplitterNode_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
}
