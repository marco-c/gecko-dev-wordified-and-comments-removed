#
include
"
DelayBuffer
.
h
"
#
include
"
AudioChannelFormat
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
namespace
mozilla
{
size_t
DelayBuffer
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
0
;
amount
+
=
mChunks
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
size_t
i
=
0
;
i
<
mChunks
.
Length
(
)
;
i
+
+
)
{
amount
+
=
mChunks
[
i
]
.
SizeOfExcludingThis
(
aMallocSizeOf
false
)
;
}
amount
+
=
mUpmixChannels
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
void
DelayBuffer
:
:
Write
(
const
AudioBlock
&
aInputChunk
)
{
MOZ_ASSERT
(
aInputChunk
.
IsNull
(
)
=
=
!
aInputChunk
.
ChannelCount
(
)
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mHaveWrittenBlock
)
;
mHaveWrittenBlock
=
true
;
#
endif
if
(
!
EnsureBuffer
(
)
)
{
return
;
}
if
(
mCurrentChunk
=
=
mLastReadChunk
)
{
mLastReadChunk
=
-
1
;
}
mChunks
[
mCurrentChunk
]
=
aInputChunk
.
AsAudioChunk
(
)
;
}
void
DelayBuffer
:
:
Read
(
const
float
aPerFrameDelays
[
WEBAUDIO_BLOCK_SIZE
]
AudioBlock
*
aOutputChunk
ChannelInterpretation
aChannelInterpretation
)
{
int
chunkCount
=
mChunks
.
Length
(
)
;
if
(
!
chunkCount
)
{
aOutputChunk
-
>
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
return
;
}
float
minDelay
=
aPerFrameDelays
[
0
]
;
float
maxDelay
=
minDelay
;
for
(
unsigned
i
=
1
;
i
<
WEBAUDIO_BLOCK_SIZE
;
+
+
i
)
{
minDelay
=
std
:
:
min
(
minDelay
aPerFrameDelays
[
i
]
-
i
)
;
maxDelay
=
std
:
:
max
(
maxDelay
aPerFrameDelays
[
i
]
-
i
)
;
}
int
oldestChunk
=
ChunkForDelay
(
std
:
:
ceil
(
maxDelay
)
)
;
int
youngestChunk
=
ChunkForDelay
(
std
:
:
floor
(
minDelay
)
)
;
uint32_t
channelCount
=
0
;
for
(
int
i
=
oldestChunk
;
true
;
i
=
(
i
+
1
)
%
chunkCount
)
{
channelCount
=
GetAudioChannelsSuperset
(
channelCount
mChunks
[
i
]
.
ChannelCount
(
)
)
;
if
(
i
=
=
youngestChunk
)
{
break
;
}
}
if
(
channelCount
)
{
aOutputChunk
-
>
AllocateChannels
(
channelCount
)
;
ReadChannels
(
aPerFrameDelays
aOutputChunk
0
channelCount
aChannelInterpretation
)
;
}
else
{
aOutputChunk
-
>
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
}
}
void
DelayBuffer
:
:
ReadChannel
(
const
float
aPerFrameDelays
[
WEBAUDIO_BLOCK_SIZE
]
AudioBlock
*
aOutputChunk
uint32_t
aChannel
ChannelInterpretation
aChannelInterpretation
)
{
if
(
!
mChunks
.
Length
(
)
)
{
float
*
outputChannel
=
aOutputChunk
-
>
ChannelFloatsForWrite
(
aChannel
)
;
PodZero
(
outputChannel
WEBAUDIO_BLOCK_SIZE
)
;
return
;
}
ReadChannels
(
aPerFrameDelays
aOutputChunk
aChannel
1
aChannelInterpretation
)
;
}
void
DelayBuffer
:
:
ReadChannels
(
const
float
aPerFrameDelays
[
WEBAUDIO_BLOCK_SIZE
]
AudioBlock
*
aOutputChunk
uint32_t
aFirstChannel
uint32_t
aNumChannelsToRead
ChannelInterpretation
aChannelInterpretation
)
{
uint32_t
totalChannelCount
=
aOutputChunk
-
>
ChannelCount
(
)
;
uint32_t
readChannelsEnd
=
aFirstChannel
+
aNumChannelsToRead
;
MOZ_ASSERT
(
readChannelsEnd
<
=
totalChannelCount
)
;
if
(
mUpmixChannels
.
Length
(
)
!
=
totalChannelCount
)
{
mLastReadChunk
=
-
1
;
}
for
(
uint32_t
channel
=
aFirstChannel
;
channel
<
readChannelsEnd
;
+
+
channel
)
{
PodZero
(
aOutputChunk
-
>
ChannelFloatsForWrite
(
channel
)
WEBAUDIO_BLOCK_SIZE
)
;
}
for
(
unsigned
i
=
0
;
i
<
WEBAUDIO_BLOCK_SIZE
;
+
+
i
)
{
float
currentDelay
=
aPerFrameDelays
[
i
]
;
MOZ_ASSERT
(
currentDelay
>
=
0
.
0f
)
;
MOZ_ASSERT
(
currentDelay
<
=
(
mChunks
.
Length
(
)
-
1
)
*
WEBAUDIO_BLOCK_SIZE
)
;
int
floorDelay
=
int
(
currentDelay
)
;
float
interpolationFactor
=
currentDelay
-
floorDelay
;
int
positions
[
2
]
;
positions
[
1
]
=
PositionForDelay
(
floorDelay
)
+
i
;
positions
[
0
]
=
positions
[
1
]
-
1
;
for
(
unsigned
tick
=
0
;
tick
<
std
:
:
size
(
positions
)
;
+
+
tick
)
{
int
readChunk
=
ChunkForPosition
(
positions
[
tick
]
)
;
if
(
interpolationFactor
!
=
0
.
0f
&
&
!
mChunks
[
readChunk
]
.
IsNull
(
)
)
{
int
readOffset
=
OffsetForPosition
(
positions
[
tick
]
)
;
UpdateUpmixChannels
(
readChunk
totalChannelCount
aChannelInterpretation
)
;
float
multiplier
=
interpolationFactor
*
mChunks
[
readChunk
]
.
mVolume
;
for
(
uint32_t
channel
=
aFirstChannel
;
channel
<
readChannelsEnd
;
+
+
channel
)
{
aOutputChunk
-
>
ChannelFloatsForWrite
(
channel
)
[
i
]
+
=
multiplier
*
mUpmixChannels
[
channel
]
[
readOffset
]
;
}
}
interpolationFactor
=
1
.
0f
-
interpolationFactor
;
}
}
}
void
DelayBuffer
:
:
Read
(
float
aDelayTicks
AudioBlock
*
aOutputChunk
ChannelInterpretation
aChannelInterpretation
)
{
float
computedDelay
[
WEBAUDIO_BLOCK_SIZE
]
;
for
(
unsigned
i
=
0
;
i
<
WEBAUDIO_BLOCK_SIZE
;
+
+
i
)
{
computedDelay
[
i
]
=
aDelayTicks
;
}
Read
(
computedDelay
aOutputChunk
aChannelInterpretation
)
;
}
bool
DelayBuffer
:
:
EnsureBuffer
(
)
{
if
(
mChunks
.
Length
(
)
=
=
0
)
{
const
int
chunkCount
=
(
mMaxDelayTicks
+
2
*
WEBAUDIO_BLOCK_SIZE
-
1
)
>
>
WEBAUDIO_BLOCK_SIZE_BITS
;
if
(
!
mChunks
.
SetLength
(
chunkCount
fallible
)
)
{
return
false
;
}
mLastReadChunk
=
-
1
;
}
return
true
;
}
int
DelayBuffer
:
:
PositionForDelay
(
int
aDelay
)
{
return
(
(
mCurrentChunk
+
mChunks
.
Length
(
)
)
*
WEBAUDIO_BLOCK_SIZE
)
-
aDelay
;
}
int
DelayBuffer
:
:
ChunkForPosition
(
int
aPosition
)
{
MOZ_ASSERT
(
aPosition
>
=
0
)
;
return
(
aPosition
>
>
WEBAUDIO_BLOCK_SIZE_BITS
)
%
mChunks
.
Length
(
)
;
}
int
DelayBuffer
:
:
OffsetForPosition
(
int
aPosition
)
{
MOZ_ASSERT
(
aPosition
>
=
0
)
;
return
aPosition
&
(
WEBAUDIO_BLOCK_SIZE
-
1
)
;
}
int
DelayBuffer
:
:
ChunkForDelay
(
int
aDelay
)
{
return
ChunkForPosition
(
PositionForDelay
(
aDelay
)
)
;
}
void
DelayBuffer
:
:
UpdateUpmixChannels
(
int
aNewReadChunk
uint32_t
aChannelCount
ChannelInterpretation
aChannelInterpretation
)
{
if
(
aNewReadChunk
=
=
mLastReadChunk
)
{
MOZ_ASSERT
(
mUpmixChannels
.
Length
(
)
=
=
aChannelCount
)
;
return
;
}
NS_WARNING_ASSERTION
(
mHaveWrittenBlock
|
|
aNewReadChunk
!
=
mCurrentChunk
"
Smoothing
is
making
feedback
delay
too
small
.
"
)
;
mLastReadChunk
=
aNewReadChunk
;
mUpmixChannels
.
ClearAndRetainStorage
(
)
;
mUpmixChannels
.
AppendElements
(
mChunks
[
aNewReadChunk
]
.
ChannelData
<
float
>
(
)
)
;
MOZ_ASSERT
(
mUpmixChannels
.
Length
(
)
<
=
aChannelCount
)
;
if
(
mUpmixChannels
.
Length
(
)
<
aChannelCount
)
{
if
(
aChannelInterpretation
=
=
ChannelInterpretation
:
:
Speakers
)
{
AudioChannelsUpMix
(
&
mUpmixChannels
aChannelCount
SilentChannel
:
:
ZeroChannel
<
float
>
(
)
)
;
MOZ_ASSERT
(
mUpmixChannels
.
Length
(
)
=
=
aChannelCount
"
We
called
GetAudioChannelsSuperset
to
avoid
this
"
)
;
}
else
{
for
(
uint32_t
channel
=
mUpmixChannels
.
Length
(
)
;
channel
<
aChannelCount
;
+
+
channel
)
{
mUpmixChannels
.
AppendElement
(
SilentChannel
:
:
ZeroChannel
<
float
>
(
)
)
;
}
}
}
}
}
