#
include
"
AudioDestinationNode
.
h
"
#
include
"
AudioContext
.
h
"
#
include
"
AlignmentUtils
.
h
"
#
include
"
AudioContext
.
h
"
#
include
"
CubebUtils
.
h
"
#
include
"
mozilla
/
dom
/
AudioDestinationNodeBinding
.
h
"
#
include
"
mozilla
/
dom
/
OfflineAudioCompletionEvent
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
BaseAudioContextBinding
.
h
"
#
include
"
AudioChannelService
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeStream
.
h
"
#
include
"
MediaStreamGraph
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
extern
mozilla
:
:
LazyLogModule
gAudioChannelLog
;
#
define
AUDIO_CHANNEL_LOG
(
msg
.
.
.
)
\
MOZ_LOG
(
gAudioChannelLog
LogLevel
:
:
Debug
(
msg
#
#
__VA_ARGS__
)
)
namespace
mozilla
{
namespace
dom
{
static
uint8_t
gWebAudioOutputKey
;
class
OfflineDestinationNodeEngine
final
:
public
AudioNodeEngine
{
public
:
explicit
OfflineDestinationNodeEngine
(
AudioDestinationNode
*
aNode
)
:
AudioNodeEngine
(
aNode
)
mWriteIndex
(
0
)
mNumberOfChannels
(
aNode
-
>
ChannelCount
(
)
)
mLength
(
aNode
-
>
Length
(
)
)
mSampleRate
(
aNode
-
>
Context
(
)
-
>
SampleRate
(
)
)
mBufferAllocated
(
false
)
{
}
void
ProcessBlock
(
AudioNodeStream
*
aStream
GraphTime
aFrom
const
AudioBlock
&
aInput
AudioBlock
*
aOutput
bool
*
aFinished
)
override
{
*
aOutput
=
aInput
;
if
(
!
mBufferAllocated
&
&
!
aInput
.
IsNull
(
)
)
{
mBuffer
=
ThreadSharedFloatArrayBufferList
:
:
Create
(
mNumberOfChannels
mLength
fallible
)
;
if
(
mBuffer
&
&
mWriteIndex
)
{
for
(
uint32_t
i
=
0
;
i
<
mNumberOfChannels
;
+
+
i
)
{
float
*
channelData
=
mBuffer
-
>
GetDataForWrite
(
i
)
;
PodZero
(
channelData
mWriteIndex
)
;
}
}
mBufferAllocated
=
true
;
}
uint32_t
outputChannelCount
=
mBuffer
?
mNumberOfChannels
:
0
;
MOZ_ASSERT
(
mWriteIndex
<
mLength
"
How
did
this
happen
?
"
)
;
const
uint32_t
duration
=
std
:
:
min
(
WEBAUDIO_BLOCK_SIZE
mLength
-
mWriteIndex
)
;
const
uint32_t
inputChannelCount
=
aInput
.
ChannelCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
outputChannelCount
;
+
+
i
)
{
float
*
outputData
=
mBuffer
-
>
GetDataForWrite
(
i
)
+
mWriteIndex
;
if
(
aInput
.
IsNull
(
)
|
|
i
>
=
inputChannelCount
)
{
PodZero
(
outputData
duration
)
;
}
else
{
const
float
*
inputBuffer
=
static_cast
<
const
float
*
>
(
aInput
.
mChannelData
[
i
]
)
;
if
(
duration
=
=
WEBAUDIO_BLOCK_SIZE
&
&
IS_ALIGNED16
(
inputBuffer
)
)
{
AudioBlockCopyChannelWithScale
(
inputBuffer
aInput
.
mVolume
outputData
)
;
}
else
{
if
(
aInput
.
mVolume
=
=
1
.
0f
)
{
PodCopy
(
outputData
inputBuffer
duration
)
;
}
else
{
for
(
uint32_t
j
=
0
;
j
<
duration
;
+
+
j
)
{
outputData
[
j
]
=
aInput
.
mVolume
*
inputBuffer
[
j
]
;
}
}
}
}
}
mWriteIndex
+
=
duration
;
if
(
mWriteIndex
>
=
mLength
)
{
NS_ASSERTION
(
mWriteIndex
=
=
mLength
"
Overshot
length
"
)
;
*
aFinished
=
true
;
}
}
bool
IsActive
(
)
const
override
{
return
true
;
}
class
OnCompleteTask
final
:
public
Runnable
{
public
:
OnCompleteTask
(
AudioContext
*
aAudioContext
AudioBuffer
*
aRenderedBuffer
)
:
Runnable
(
"
dom
:
:
OfflineDestinationNodeEngine
:
:
OnCompleteTask
"
)
mAudioContext
(
aAudioContext
)
mRenderedBuffer
(
aRenderedBuffer
)
{
}
NS_IMETHOD
Run
(
)
override
{
OfflineAudioCompletionEventInit
param
;
param
.
mRenderedBuffer
=
mRenderedBuffer
;
RefPtr
<
OfflineAudioCompletionEvent
>
event
=
OfflineAudioCompletionEvent
:
:
Constructor
(
mAudioContext
NS_LITERAL_STRING
(
"
complete
"
)
param
)
;
mAudioContext
-
>
DispatchTrustedEvent
(
event
)
;
return
NS_OK
;
}
private
:
RefPtr
<
AudioContext
>
mAudioContext
;
RefPtr
<
AudioBuffer
>
mRenderedBuffer
;
}
;
void
FireOfflineCompletionEvent
(
AudioDestinationNode
*
aNode
)
{
AudioContext
*
context
=
aNode
-
>
Context
(
)
;
context
-
>
Shutdown
(
)
;
ErrorResult
rv
;
RefPtr
<
AudioBuffer
>
renderedBuffer
=
AudioBuffer
:
:
Create
(
context
-
>
GetOwner
(
)
mNumberOfChannels
mLength
mSampleRate
mBuffer
.
forget
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
rv
.
SuppressException
(
)
;
return
;
}
aNode
-
>
ResolvePromise
(
renderedBuffer
)
;
context
-
>
Dispatch
(
do_AddRef
(
new
OnCompleteTask
(
context
renderedBuffer
)
)
)
;
context
-
>
OnStateChanged
(
nullptr
AudioContextState
:
:
Closed
)
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
size_t
amount
=
AudioNodeEngine
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
if
(
mBuffer
)
{
amount
+
=
mBuffer
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
amount
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
private
:
RefPtr
<
ThreadSharedFloatArrayBufferList
>
mBuffer
;
uint32_t
mWriteIndex
;
uint32_t
mNumberOfChannels
;
uint32_t
mLength
;
float
mSampleRate
;
bool
mBufferAllocated
;
}
;
class
DestinationNodeEngine
final
:
public
AudioNodeEngine
{
public
:
explicit
DestinationNodeEngine
(
AudioDestinationNode
*
aNode
)
:
AudioNodeEngine
(
aNode
)
mVolume
(
1
.
0f
)
mLastInputAudible
(
false
)
mSuspended
(
false
)
mSampleRate
(
CubebUtils
:
:
PreferredSampleRate
(
)
)
{
MOZ_ASSERT
(
aNode
)
;
}
void
ProcessBlock
(
AudioNodeStream
*
aStream
GraphTime
aFrom
const
AudioBlock
&
aInput
AudioBlock
*
aOutput
bool
*
aFinished
)
override
{
*
aOutput
=
aInput
;
aOutput
-
>
mVolume
*
=
mVolume
;
if
(
mSuspended
)
{
return
;
}
bool
isInputAudible
=
!
aInput
.
IsNull
(
)
&
&
!
aInput
.
IsMuted
(
)
&
&
aInput
.
IsAudible
(
)
;
auto
shouldNotifyChanged
=
[
&
]
(
)
{
if
(
isInputAudible
&
&
!
mLastInputAudible
)
{
return
true
;
}
if
(
!
isInputAudible
&
&
mLastInputAudible
&
&
aFrom
-
mLastInputAudibleTime
>
=
mSampleRate
)
{
return
true
;
}
return
false
;
}
;
if
(
shouldNotifyChanged
(
)
)
{
mLastInputAudible
=
isInputAudible
;
RefPtr
<
AudioNodeStream
>
stream
=
aStream
;
auto
r
=
[
stream
isInputAudible
]
(
)
-
>
void
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
AudioNode
>
node
=
stream
-
>
Engine
(
)
-
>
NodeMainThread
(
)
;
if
(
node
)
{
RefPtr
<
AudioDestinationNode
>
destinationNode
=
static_cast
<
AudioDestinationNode
*
>
(
node
.
get
(
)
)
;
destinationNode
-
>
NotifyAudibleStateChanged
(
isInputAudible
)
;
}
}
;
aStream
-
>
Graph
(
)
-
>
DispatchToMainThreadStableState
(
NS_NewRunnableFunction
(
"
dom
:
:
WebAudioAudibleStateChangedRunnable
"
r
)
)
;
}
if
(
isInputAudible
)
{
mLastInputAudibleTime
=
aFrom
;
}
}
bool
IsActive
(
)
const
override
{
return
true
;
}
void
SetDoubleParameter
(
uint32_t
aIndex
double
aParam
)
override
{
if
(
aIndex
=
=
VOLUME
)
{
mVolume
=
aParam
;
}
}
void
SetInt32Parameter
(
uint32_t
aIndex
int32_t
aParam
)
override
{
if
(
aIndex
=
=
SUSPENDED
)
{
mSuspended
=
!
!
aParam
;
if
(
mSuspended
)
{
mLastInputAudible
=
false
;
}
}
}
enum
Parameters
{
VOLUME
SUSPENDED
}
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
private
:
float
mVolume
;
bool
mLastInputAudible
;
GraphTime
mLastInputAudibleTime
=
0
;
bool
mSuspended
;
int
mSampleRate
;
}
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
AudioDestinationNode
AudioNode
mAudioChannelAgent
mOfflineRenderingPromise
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
AudioDestinationNode
)
NS_INTERFACE_MAP_ENTRY
(
nsIAudioChannelAgentCallback
)
NS_INTERFACE_MAP_END_INHERITING
(
AudioNode
)
NS_IMPL_ADDREF_INHERITED
(
AudioDestinationNode
AudioNode
)
NS_IMPL_RELEASE_INHERITED
(
AudioDestinationNode
AudioNode
)
const
AudioNodeStream
:
:
Flags
kStreamFlags
=
AudioNodeStream
:
:
NEED_MAIN_THREAD_CURRENT_TIME
|
AudioNodeStream
:
:
NEED_MAIN_THREAD_FINISHED
|
AudioNodeStream
:
:
EXTERNAL_OUTPUT
;
AudioDestinationNode
:
:
AudioDestinationNode
(
AudioContext
*
aContext
bool
aIsOffline
bool
aAllowedToStart
uint32_t
aNumberOfChannels
uint32_t
aLength
)
:
AudioNode
(
aContext
aNumberOfChannels
ChannelCountMode
:
:
Explicit
ChannelInterpretation
:
:
Speakers
)
mFramesToProduce
(
aLength
)
mIsOffline
(
aIsOffline
)
mAudioChannelSuspended
(
false
)
mAudible
(
AudioChannelService
:
:
AudibleState
:
:
eAudible
)
mCreatedTime
(
TimeStamp
:
:
Now
(
)
)
{
if
(
aIsOffline
)
{
return
;
}
MediaStreamGraph
*
graph
=
MediaStreamGraph
:
:
GetInstance
(
MediaStreamGraph
:
:
AUDIO_THREAD_DRIVER
aContext
-
>
GetParentObject
(
)
aContext
-
>
SampleRate
(
)
)
;
AudioNodeEngine
*
engine
=
new
DestinationNodeEngine
(
this
)
;
mStream
=
AudioNodeStream
:
:
Create
(
aContext
engine
kStreamFlags
graph
)
;
mStream
-
>
AddMainThreadListener
(
this
)
;
mStream
-
>
AddAudioOutput
(
&
gWebAudioOutputKey
)
;
if
(
aAllowedToStart
)
{
graph
-
>
NotifyWhenGraphStarted
(
mStream
)
;
}
}
AudioDestinationNode
:
:
~
AudioDestinationNode
(
)
{
}
size_t
AudioDestinationNode
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
AudioNode
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
size_t
AudioDestinationNode
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
AudioNodeStream
*
AudioDestinationNode
:
:
Stream
(
)
{
if
(
mStream
)
{
return
mStream
;
}
AudioContext
*
context
=
Context
(
)
;
if
(
!
context
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mIsOffline
"
Realtime
streams
are
created
in
constructor
"
)
;
MediaStreamGraph
*
graph
=
MediaStreamGraph
:
:
CreateNonRealtimeInstance
(
context
-
>
SampleRate
(
)
context
-
>
GetParentObject
(
)
)
;
AudioNodeEngine
*
engine
=
new
OfflineDestinationNodeEngine
(
this
)
;
mStream
=
AudioNodeStream
:
:
Create
(
context
engine
kStreamFlags
graph
)
;
mStream
-
>
AddMainThreadListener
(
this
)
;
return
mStream
;
}
void
AudioDestinationNode
:
:
DestroyAudioChannelAgent
(
)
{
if
(
mAudioChannelAgent
&
&
!
Context
(
)
-
>
IsOffline
(
)
)
{
mAudioChannelAgent
-
>
NotifyStoppedPlaying
(
)
;
mAudioChannelAgent
=
nullptr
;
mAudible
=
AudioChannelService
:
:
AudibleState
:
:
eAudible
;
if
(
IsCapturingAudio
(
)
)
{
StopAudioCapturingStream
(
)
;
}
}
}
void
AudioDestinationNode
:
:
DestroyMediaStream
(
)
{
DestroyAudioChannelAgent
(
)
;
if
(
!
mStream
)
return
;
Context
(
)
-
>
ShutdownWorklet
(
)
;
mStream
-
>
RemoveMainThreadListener
(
this
)
;
MediaStreamGraph
*
graph
=
mStream
-
>
Graph
(
)
;
if
(
graph
-
>
IsNonRealtime
(
)
)
{
MediaStreamGraph
:
:
DestroyNonRealtimeInstance
(
graph
)
;
}
AudioNode
:
:
DestroyMediaStream
(
)
;
}
void
AudioDestinationNode
:
:
NotifyMainThreadStreamFinished
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mStream
-
>
IsFinished
(
)
)
;
if
(
mIsOffline
&
&
GetAbstractMainThread
(
)
)
{
GetAbstractMainThread
(
)
-
>
Dispatch
(
NewRunnableMethod
(
"
dom
:
:
AudioDestinationNode
:
:
FireOfflineCompletionEvent
"
this
&
AudioDestinationNode
:
:
FireOfflineCompletionEvent
)
)
;
}
}
void
AudioDestinationNode
:
:
FireOfflineCompletionEvent
(
)
{
OfflineDestinationNodeEngine
*
engine
=
static_cast
<
OfflineDestinationNodeEngine
*
>
(
Stream
(
)
-
>
Engine
(
)
)
;
engine
-
>
FireOfflineCompletionEvent
(
this
)
;
}
void
AudioDestinationNode
:
:
ResolvePromise
(
AudioBuffer
*
aRenderedBuffer
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mIsOffline
)
;
mOfflineRenderingPromise
-
>
MaybeResolve
(
aRenderedBuffer
)
;
}
uint32_t
AudioDestinationNode
:
:
MaxChannelCount
(
)
const
{
return
Context
(
)
-
>
MaxChannelCount
(
)
;
}
void
AudioDestinationNode
:
:
SetChannelCount
(
uint32_t
aChannelCount
ErrorResult
&
aRv
)
{
if
(
aChannelCount
>
MaxChannelCount
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
AudioNode
:
:
SetChannelCount
(
aChannelCount
aRv
)
;
}
void
AudioDestinationNode
:
:
Mute
(
)
{
MOZ_ASSERT
(
Context
(
)
&
&
!
Context
(
)
-
>
IsOffline
(
)
)
;
SendDoubleParameterToStream
(
DestinationNodeEngine
:
:
VOLUME
0
.
0f
)
;
}
void
AudioDestinationNode
:
:
Unmute
(
)
{
MOZ_ASSERT
(
Context
(
)
&
&
!
Context
(
)
-
>
IsOffline
(
)
)
;
SendDoubleParameterToStream
(
DestinationNodeEngine
:
:
VOLUME
1
.
0f
)
;
}
void
AudioDestinationNode
:
:
Suspend
(
)
{
DestroyAudioChannelAgent
(
)
;
SendInt32ParameterToStream
(
DestinationNodeEngine
:
:
SUSPENDED
1
)
;
}
void
AudioDestinationNode
:
:
Resume
(
)
{
CreateAudioChannelAgent
(
)
;
SendInt32ParameterToStream
(
DestinationNodeEngine
:
:
SUSPENDED
0
)
;
}
void
AudioDestinationNode
:
:
OfflineShutdown
(
)
{
MOZ_ASSERT
(
Context
(
)
&
&
Context
(
)
-
>
IsOffline
(
)
"
Should
only
be
called
on
a
valid
OfflineAudioContext
"
)
;
if
(
mStream
)
{
MediaStreamGraph
:
:
DestroyNonRealtimeInstance
(
mStream
-
>
Graph
(
)
)
;
mOfflineRenderingRef
.
Drop
(
this
)
;
}
}
JSObject
*
AudioDestinationNode
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
AudioDestinationNode_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
AudioDestinationNode
:
:
StartRendering
(
Promise
*
aPromise
)
{
mOfflineRenderingPromise
=
aPromise
;
mOfflineRenderingRef
.
Take
(
this
)
;
Stream
(
)
-
>
Graph
(
)
-
>
StartNonRealtimeProcessing
(
mFramesToProduce
)
;
}
NS_IMETHODIMP
AudioDestinationNode
:
:
WindowVolumeChanged
(
float
aVolume
bool
aMuted
)
{
if
(
!
mStream
)
{
return
NS_OK
;
}
AUDIO_CHANNEL_LOG
(
"
AudioDestinationNode
%
p
WindowVolumeChanged
"
"
aVolume
=
%
f
aMuted
=
%
s
\
n
"
this
aVolume
aMuted
?
"
true
"
:
"
false
"
)
;
float
volume
=
aMuted
?
0
.
0
:
aVolume
;
mStream
-
>
SetAudioOutputVolume
(
&
gWebAudioOutputKey
volume
)
;
AudioChannelService
:
:
AudibleState
audible
=
volume
>
0
.
0
?
AudioChannelService
:
:
AudibleState
:
:
eAudible
:
AudioChannelService
:
:
AudibleState
:
:
eNotAudible
;
if
(
mAudible
!
=
audible
)
{
mAudible
=
audible
;
mAudioChannelAgent
-
>
NotifyStartedAudible
(
mAudible
AudioChannelService
:
:
AudibleChangedReasons
:
:
eVolumeChanged
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AudioDestinationNode
:
:
WindowSuspendChanged
(
nsSuspendedTypes
aSuspend
)
{
if
(
!
mStream
)
{
return
NS_OK
;
}
bool
suspended
=
(
aSuspend
!
=
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
;
if
(
mAudioChannelSuspended
=
=
suspended
)
{
return
NS_OK
;
}
AUDIO_CHANNEL_LOG
(
"
AudioDestinationNode
%
p
WindowSuspendChanged
"
"
aSuspend
=
%
s
\
n
"
this
SuspendTypeToStr
(
aSuspend
)
)
;
mAudioChannelSuspended
=
suspended
;
DisabledTrackMode
disabledMode
=
suspended
?
DisabledTrackMode
:
:
SILENCE_BLACK
:
DisabledTrackMode
:
:
ENABLED
;
mStream
-
>
SetTrackEnabled
(
AudioNodeStream
:
:
AUDIO_TRACK
disabledMode
)
;
AudioChannelService
:
:
AudibleState
audible
=
aSuspend
=
=
nsISuspendedTypes
:
:
NONE_SUSPENDED
?
AudioChannelService
:
:
AudibleState
:
:
eAudible
:
AudioChannelService
:
:
AudibleState
:
:
eNotAudible
;
if
(
mAudible
!
=
audible
)
{
mAudible
=
audible
;
mAudioChannelAgent
-
>
NotifyStartedAudible
(
audible
AudioChannelService
:
:
AudibleChangedReasons
:
:
ePauseStateChanged
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AudioDestinationNode
:
:
WindowAudioCaptureChanged
(
bool
aCapture
)
{
MOZ_ASSERT
(
mAudioChannelAgent
)
;
if
(
!
mStream
|
|
Context
(
)
-
>
IsOffline
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
ownerWindow
=
GetOwner
(
)
;
if
(
!
ownerWindow
)
{
return
NS_OK
;
}
if
(
aCapture
=
=
IsCapturingAudio
(
)
)
{
return
NS_OK
;
}
if
(
aCapture
)
{
StartAudioCapturingStream
(
)
;
}
else
{
StopAudioCapturingStream
(
)
;
}
return
NS_OK
;
}
bool
AudioDestinationNode
:
:
IsCapturingAudio
(
)
const
{
return
mCaptureStreamPort
!
=
nullptr
;
}
void
AudioDestinationNode
:
:
StartAudioCapturingStream
(
)
{
MOZ_ASSERT
(
!
IsCapturingAudio
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
Context
(
)
-
>
GetParentObject
(
)
;
uint64_t
id
=
window
-
>
WindowID
(
)
;
mCaptureStreamPort
=
mStream
-
>
Graph
(
)
-
>
ConnectToCaptureStream
(
id
mStream
)
;
}
void
AudioDestinationNode
:
:
StopAudioCapturingStream
(
)
{
MOZ_ASSERT
(
IsCapturingAudio
(
)
)
;
mCaptureStreamPort
-
>
Destroy
(
)
;
mCaptureStreamPort
=
nullptr
;
}
nsresult
AudioDestinationNode
:
:
CreateAudioChannelAgent
(
)
{
if
(
mIsOffline
|
|
mAudioChannelAgent
)
{
return
NS_OK
;
}
mAudioChannelAgent
=
new
AudioChannelAgent
(
)
;
nsresult
rv
=
mAudioChannelAgent
-
>
InitWithWeakCallback
(
GetOwner
(
)
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
void
AudioDestinationNode
:
:
NotifyAudibleStateChanged
(
bool
aAudible
)
{
MOZ_ASSERT
(
Context
(
)
&
&
!
Context
(
)
-
>
IsOffline
(
)
)
;
if
(
!
mAudioChannelAgent
)
{
if
(
!
aAudible
)
{
return
;
}
CreateAudioChannelAgent
(
)
;
}
AUDIO_CHANNEL_LOG
(
"
AudioDestinationNode
%
p
NotifyAudibleStateChanged
audible
=
%
d
"
this
aAudible
)
;
if
(
!
aAudible
)
{
mAudioChannelAgent
-
>
NotifyStoppedPlaying
(
)
;
mAudible
=
AudioChannelService
:
:
AudibleState
:
:
eAudible
;
if
(
IsCapturingAudio
(
)
)
{
StopAudioCapturingStream
(
)
;
}
return
;
}
if
(
mDurationBeforeFirstTimeAudible
.
IsZero
(
)
)
{
MOZ_ASSERT
(
aAudible
)
;
mDurationBeforeFirstTimeAudible
=
TimeStamp
:
:
Now
(
)
-
mCreatedTime
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEB_AUDIO_BECOMES_AUDIBLE_TIME
mDurationBeforeFirstTimeAudible
.
ToSeconds
(
)
)
;
}
nsresult
rv
=
mAudioChannelAgent
-
>
NotifyStartedPlaying
(
mAudible
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
mAudioChannelAgent
-
>
PullInitialUpdate
(
)
;
}
}
}
