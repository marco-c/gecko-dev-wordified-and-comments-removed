#
ifndef
AudioContext_h_
#
define
AudioContext_h_
#
include
"
X11UndefineNone
.
h
"
#
include
"
AudioParamDescriptorMap
.
h
"
#
include
"
mozilla
/
dom
/
OfflineAudioContextBinding
.
h
"
#
include
"
mozilla
/
dom
/
AudioContextBinding
.
h
"
#
include
"
MediaBufferDecoder
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
RelativeTimeline
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsTHashSet
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
namespace
WebCore
{
class
PeriodicWave
;
}
class
nsPIDOMWindowInner
;
namespace
mozilla
{
class
DOMMediaStream
;
class
ErrorResult
;
class
MediaTrack
;
class
MediaTrackGraph
;
class
AudioNodeTrack
;
namespace
dom
{
enum
class
AudioContextState
:
uint8_t
;
class
AnalyserNode
;
class
AudioBuffer
;
class
AudioBufferSourceNode
;
class
AudioDestinationNode
;
class
AudioListener
;
class
AudioNode
;
class
BiquadFilterNode
;
class
BrowsingContext
;
class
ChannelMergerNode
;
class
ChannelSplitterNode
;
class
ConstantSourceNode
;
class
ConvolverNode
;
class
DelayNode
;
class
DynamicsCompressorNode
;
class
GainNode
;
class
GlobalObject
;
class
HTMLMediaElement
;
class
IIRFilterNode
;
class
MediaElementAudioSourceNode
;
class
MediaStreamAudioDestinationNode
;
class
MediaStreamAudioSourceNode
;
class
MediaStreamTrack
;
class
MediaStreamTrackAudioSourceNode
;
class
OscillatorNode
;
class
PannerNode
;
class
ScriptProcessorNode
;
class
StereoPannerNode
;
class
WaveShaperNode
;
class
Worklet
;
class
PeriodicWave
;
struct
PeriodicWaveConstraints
;
class
Promise
;
enum
class
OscillatorType
:
uint8_t
;
class
BasicWaveFormCache
{
public
:
explicit
BasicWaveFormCache
(
uint32_t
aSampleRate
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
BasicWaveFormCache
)
WebCore
:
:
PeriodicWave
*
GetBasicWaveForm
(
OscillatorType
aType
)
;
private
:
~
BasicWaveFormCache
(
)
;
RefPtr
<
WebCore
:
:
PeriodicWave
>
mSawtooth
;
RefPtr
<
WebCore
:
:
PeriodicWave
>
mSquare
;
RefPtr
<
WebCore
:
:
PeriodicWave
>
mTriangle
;
uint32_t
mSampleRate
;
}
;
class
StateChangeTask
final
:
public
Runnable
{
public
:
StateChangeTask
(
AudioContext
*
aAudioContext
void
*
aPromise
AudioContextState
aNewState
)
;
StateChangeTask
(
AudioNodeTrack
*
aTrack
void
*
aPromise
AudioContextState
aNewState
)
;
NS_IMETHOD
Run
(
)
override
;
private
:
RefPtr
<
AudioContext
>
mAudioContext
;
void
*
mPromise
;
RefPtr
<
AudioNodeTrack
>
mAudioNodeTrack
;
AudioContextState
mNewState
;
}
;
enum
class
AudioContextOperation
:
uint8_t
{
Suspend
Resume
Close
}
;
static
const
char
*
const
kAudioContextOptionsStrings
[
]
=
{
"
Suspend
"
"
Resume
"
"
Close
"
}
;
enum
class
AudioContextOperationFlags
{
None
SendStateChange
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
AudioContextOperationFlags
)
;
struct
AudioContextOptions
;
class
AudioContext
final
:
public
DOMEventTargetHelper
public
nsIMemoryReporter
public
RelativeTimeline
{
AudioContext
(
nsPIDOMWindowInner
*
aParentWindow
bool
aIsOffline
uint32_t
aNumberOfChannels
=
0
uint32_t
aLength
=
0
float
aSampleRate
=
0
.
0f
)
;
~
AudioContext
(
)
;
public
:
typedef
uint64_t
AudioContextId
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
AudioContext
DOMEventTargetHelper
)
MOZ_DEFINE_MALLOC_SIZE_OF
(
MallocSizeOf
)
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
GetOwnerGlobal
(
)
;
}
nsISerialEventTarget
*
GetMainThread
(
)
const
;
void
DisconnectFromOwner
(
)
override
;
void
OnWindowDestroy
(
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
using
DOMEventTargetHelper
:
:
DispatchTrustedEvent
;
static
already_AddRefed
<
AudioContext
>
Constructor
(
const
GlobalObject
&
aGlobal
const
AudioContextOptions
&
aOptions
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
AudioContext
>
Constructor
(
const
GlobalObject
&
aGlobal
const
OfflineAudioContextOptions
&
aOptions
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
AudioContext
>
Constructor
(
const
GlobalObject
&
aGlobal
uint32_t
aNumberOfChannels
uint32_t
aLength
float
aSampleRate
ErrorResult
&
aRv
)
;
AudioDestinationNode
*
Destination
(
)
const
{
return
mDestination
;
}
float
SampleRate
(
)
const
{
return
mSampleRate
;
}
bool
ShouldSuspendNewTrack
(
)
const
{
return
mTracksAreSuspended
|
|
mCloseCalled
;
}
double
CurrentTime
(
)
;
AudioListener
*
Listener
(
)
;
AudioContextState
State
(
)
const
{
return
mAudioContextState
;
}
double
BaseLatency
(
)
const
{
return
0
.
0
;
}
double
OutputLatency
(
)
;
void
GetOutputTimestamp
(
AudioTimestamp
&
aTimeStamp
)
;
Worklet
*
GetAudioWorklet
(
ErrorResult
&
aRv
)
;
bool
IsRunning
(
)
const
;
void
StartBlockedAudioContextIfAllowed
(
)
;
already_AddRefed
<
Promise
>
Suspend
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
Resume
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
Close
(
ErrorResult
&
aRv
)
;
IMPL_EVENT_HANDLER
(
statechange
)
void
SuspendFromChrome
(
)
;
void
ResumeFromChrome
(
)
;
void
OfflineClose
(
)
;
already_AddRefed
<
AudioBufferSourceNode
>
CreateBufferSource
(
)
;
already_AddRefed
<
ConstantSourceNode
>
CreateConstantSource
(
)
;
already_AddRefed
<
AudioBuffer
>
CreateBuffer
(
uint32_t
aNumberOfChannels
uint32_t
aLength
float
aSampleRate
ErrorResult
&
aRv
)
;
already_AddRefed
<
MediaStreamAudioDestinationNode
>
CreateMediaStreamDestination
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
ScriptProcessorNode
>
CreateScriptProcessor
(
uint32_t
aBufferSize
uint32_t
aNumberOfInputChannels
uint32_t
aNumberOfOutputChannels
ErrorResult
&
aRv
)
;
already_AddRefed
<
StereoPannerNode
>
CreateStereoPanner
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
AnalyserNode
>
CreateAnalyser
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
GainNode
>
CreateGain
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
WaveShaperNode
>
CreateWaveShaper
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
MediaElementAudioSourceNode
>
CreateMediaElementSource
(
HTMLMediaElement
&
aMediaElement
ErrorResult
&
aRv
)
;
already_AddRefed
<
MediaStreamAudioSourceNode
>
CreateMediaStreamSource
(
DOMMediaStream
&
aMediaStream
ErrorResult
&
aRv
)
;
already_AddRefed
<
MediaStreamTrackAudioSourceNode
>
CreateMediaStreamTrackSource
(
MediaStreamTrack
&
aMediaStreamTrack
ErrorResult
&
aRv
)
;
already_AddRefed
<
DelayNode
>
CreateDelay
(
double
aMaxDelayTime
ErrorResult
&
aRv
)
;
already_AddRefed
<
PannerNode
>
CreatePanner
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
ConvolverNode
>
CreateConvolver
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
ChannelSplitterNode
>
CreateChannelSplitter
(
uint32_t
aNumberOfOutputs
ErrorResult
&
aRv
)
;
already_AddRefed
<
ChannelMergerNode
>
CreateChannelMerger
(
uint32_t
aNumberOfInputs
ErrorResult
&
aRv
)
;
already_AddRefed
<
DynamicsCompressorNode
>
CreateDynamicsCompressor
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
BiquadFilterNode
>
CreateBiquadFilter
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
IIRFilterNode
>
CreateIIRFilter
(
const
Sequence
<
double
>
&
aFeedforward
const
Sequence
<
double
>
&
aFeedback
mozilla
:
:
ErrorResult
&
aRv
)
;
already_AddRefed
<
OscillatorNode
>
CreateOscillator
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
PeriodicWave
>
CreatePeriodicWave
(
const
Sequence
<
float
>
&
aRealData
const
Sequence
<
float
>
&
aImagData
const
PeriodicWaveConstraints
&
aConstraints
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
DecodeAudioData
(
const
ArrayBuffer
&
aBuffer
const
Optional
<
OwningNonNull
<
DecodeSuccessCallback
>
>
&
aSuccessCallback
const
Optional
<
OwningNonNull
<
DecodeErrorCallback
>
>
&
aFailureCallback
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
StartRendering
(
ErrorResult
&
aRv
)
;
IMPL_EVENT_HANDLER
(
complete
)
unsigned
long
Length
(
)
;
bool
IsOffline
(
)
const
{
return
mIsOffline
;
}
bool
ShouldResistFingerprinting
(
)
const
{
return
mShouldResistFingerprinting
;
}
MediaTrackGraph
*
Graph
(
)
const
;
AudioNodeTrack
*
DestinationTrack
(
)
const
;
void
RegisterActiveNode
(
AudioNode
*
aNode
)
;
void
UnregisterActiveNode
(
AudioNode
*
aNode
)
;
uint32_t
MaxChannelCount
(
)
const
;
uint32_t
ActiveNodeCount
(
)
const
;
void
Mute
(
)
const
;
void
Unmute
(
)
const
;
void
RegisterNode
(
AudioNode
*
aNode
)
;
void
UnregisterNode
(
AudioNode
*
aNode
)
;
void
OnStateChanged
(
void
*
aPromise
AudioContextState
aNewState
)
;
BasicWaveFormCache
*
GetBasicWaveFormCache
(
)
;
void
ShutdownWorklet
(
)
;
void
SetParamMapForWorkletName
(
const
nsAString
&
aName
AudioParamDescriptorMap
*
aParamMap
)
;
const
AudioParamDescriptorMap
*
GetParamMapForWorkletName
(
const
nsAString
&
aName
)
{
return
mWorkletParamDescriptors
.
Lookup
(
aName
)
.
DataPtrOrNull
(
)
;
}
void
Dispatch
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
private
:
void
DisconnectFromWindow
(
)
;
already_AddRefed
<
Promise
>
CreatePromise
(
ErrorResult
&
aRv
)
;
void
RemoveFromDecodeQueue
(
WebAudioDecodeJob
*
aDecodeJob
)
;
void
ShutdownDecoder
(
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
NS_DECL_NSIMEMORYREPORTER
friend
struct
:
:
mozilla
:
:
WebAudioDecodeJob
;
nsTArray
<
RefPtr
<
mozilla
:
:
MediaTrack
>
>
GetAllTracks
(
)
const
;
void
ResumeInternal
(
)
;
void
SuspendInternal
(
void
*
aPromise
AudioContextOperationFlags
aFlags
)
;
void
CloseInternal
(
void
*
aPromise
AudioContextOperationFlags
aFlags
)
;
void
ReportBlocked
(
)
;
void
ReportToConsole
(
uint32_t
aErrorFlags
const
char
*
aMsg
)
const
;
void
UpdateAutoplayAssumptionStatus
(
)
;
void
MaybeUpdateAutoplayTelemetry
(
)
;
void
MaybeUpdateAutoplayTelemetryWhenShutdown
(
)
;
void
MaybeUpdatePageAwakeRequest
(
)
;
void
MaybeClearPageAwakeRequest
(
)
;
void
SetPageAwakeRequest
(
bool
aShouldSet
)
;
BrowsingContext
*
GetTopLevelBrowsingContext
(
)
;
private
:
const
AudioContextId
mId
;
const
float
mSampleRate
;
AudioContextState
mAudioContextState
;
RefPtr
<
AudioDestinationNode
>
mDestination
;
RefPtr
<
AudioListener
>
mListener
;
RefPtr
<
Worklet
>
mWorklet
;
nsTArray
<
UniquePtr
<
WebAudioDecodeJob
>
>
mDecodeJobs
;
nsTArray
<
RefPtr
<
Promise
>
>
mPromiseGripArray
;
nsTArray
<
RefPtr
<
Promise
>
>
mPendingResumePromises
;
nsTHashSet
<
RefPtr
<
AudioNode
>
>
mActiveNodes
;
nsTHashSet
<
AudioNode
*
>
mAllNodes
;
nsTHashMap
<
nsStringHashKey
AudioParamDescriptorMap
>
mWorkletParamDescriptors
;
RefPtr
<
BasicWaveFormCache
>
mBasicWaveFormCache
;
uint32_t
mNumberOfChannels
;
const
RTPCallerType
mRTPCallerType
;
const
bool
mShouldResistFingerprinting
;
const
bool
mIsOffline
;
bool
mIsStarted
;
bool
mIsShutDown
;
bool
mIsDisconnecting
;
bool
mCloseCalled
;
bool
mTracksAreSuspended
;
bool
mWasAllowedToStart
;
bool
mSuspendedByContent
;
bool
mSuspendedByChrome
;
bool
mWasEverAllowedToStart
;
bool
mWasEverBlockedToStart
;
bool
mWouldBeAllowedToStart
;
bool
mSetPageAwakeRequest
=
false
;
}
;
static
const
dom
:
:
AudioContext
:
:
AudioContextId
NO_AUDIO_CONTEXT
=
0
;
}
}
inline
nsISupports
*
ToSupports
(
mozilla
:
:
dom
:
:
AudioContext
*
p
)
{
return
NS_CYCLE_COLLECTION_CLASSNAME
(
mozilla
:
:
dom
:
:
AudioContext
)
:
:
Upcast
(
p
)
;
}
#
endif
