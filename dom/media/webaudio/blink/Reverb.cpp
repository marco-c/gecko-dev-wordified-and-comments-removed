#
include
"
Reverb
.
h
"
#
include
"
ReverbConvolverStage
.
h
"
#
include
<
math
.
h
>
#
include
"
ReverbConvolver
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
using
namespace
mozilla
;
namespace
WebCore
{
const
float
GainCalibration
=
-
58
;
const
float
GainCalibrationSampleRate
=
44100
;
const
float
MinPower
=
0
.
000125f
;
static
float
calculateNormalizationScale
(
ThreadSharedFloatArrayBufferList
*
response
size_t
aLength
float
sampleRate
)
{
size_t
numberOfChannels
=
response
-
>
GetChannels
(
)
;
float
power
=
0
;
for
(
size_t
i
=
0
;
i
<
numberOfChannels
;
+
+
i
)
{
float
channelPower
=
AudioBufferSumOfSquares
(
static_cast
<
const
float
*
>
(
response
-
>
GetData
(
i
)
)
aLength
)
;
power
+
=
channelPower
;
}
power
=
sqrt
(
power
/
(
numberOfChannels
*
aLength
)
)
;
if
(
!
IsFinite
(
power
)
|
|
IsNaN
(
power
)
|
|
power
<
MinPower
)
power
=
MinPower
;
float
scale
=
1
/
power
;
scale
*
=
powf
(
10
GainCalibration
*
0
.
05f
)
;
if
(
sampleRate
)
scale
*
=
GainCalibrationSampleRate
/
sampleRate
;
if
(
response
-
>
GetChannels
(
)
=
=
4
)
scale
*
=
0
.
5f
;
return
scale
;
}
Reverb
:
:
Reverb
(
ThreadSharedFloatArrayBufferList
*
impulseResponse
size_t
impulseResponseBufferLength
size_t
maxFFTSize
size_t
numberOfChannels
bool
useBackgroundThreads
bool
normalize
float
sampleRate
)
{
float
scale
=
1
;
nsAutoTArray
<
const
float
*
4
>
irChannels
;
for
(
size_t
i
=
0
;
i
<
impulseResponse
-
>
GetChannels
(
)
;
+
+
i
)
{
irChannels
.
AppendElement
(
impulseResponse
-
>
GetData
(
i
)
)
;
}
nsAutoTArray
<
float
1024
>
tempBuf
;
if
(
normalize
)
{
scale
=
calculateNormalizationScale
(
impulseResponse
impulseResponseBufferLength
sampleRate
)
;
if
(
scale
)
{
tempBuf
.
SetLength
(
irChannels
.
Length
(
)
*
impulseResponseBufferLength
)
;
for
(
uint32_t
i
=
0
;
i
<
irChannels
.
Length
(
)
;
+
+
i
)
{
float
*
buf
=
&
tempBuf
[
i
*
impulseResponseBufferLength
]
;
AudioBufferCopyWithScale
(
irChannels
[
i
]
scale
buf
impulseResponseBufferLength
)
;
irChannels
[
i
]
=
buf
;
}
}
}
initialize
(
irChannels
impulseResponseBufferLength
maxFFTSize
numberOfChannels
useBackgroundThreads
)
;
}
size_t
Reverb
:
:
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
aMallocSizeOf
(
this
)
;
amount
+
=
m_convolvers
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
size_t
i
=
0
;
i
<
m_convolvers
.
Length
(
)
;
i
+
+
)
{
if
(
m_convolvers
[
i
]
)
{
amount
+
=
m_convolvers
[
i
]
-
>
sizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
amount
+
=
m_tempBuffer
.
SizeOfExcludingThis
(
aMallocSizeOf
false
)
;
return
amount
;
}
void
Reverb
:
:
initialize
(
const
nsTArray
<
const
float
*
>
&
impulseResponseBuffer
size_t
impulseResponseBufferLength
size_t
maxFFTSize
size_t
numberOfChannels
bool
useBackgroundThreads
)
{
m_impulseResponseLength
=
impulseResponseBufferLength
;
size_t
numResponseChannels
=
impulseResponseBuffer
.
Length
(
)
;
m_convolvers
.
SetCapacity
(
numberOfChannels
)
;
int
convolverRenderPhase
=
0
;
for
(
size_t
i
=
0
;
i
<
numResponseChannels
;
+
+
i
)
{
const
float
*
channel
=
impulseResponseBuffer
[
i
]
;
size_t
length
=
impulseResponseBufferLength
;
nsAutoPtr
<
ReverbConvolver
>
convolver
(
new
ReverbConvolver
(
channel
length
maxFFTSize
convolverRenderPhase
useBackgroundThreads
)
)
;
m_convolvers
.
AppendElement
(
convolver
.
forget
(
)
)
;
convolverRenderPhase
+
=
WEBAUDIO_BLOCK_SIZE
;
}
if
(
numResponseChannels
=
=
4
)
{
m_tempBuffer
.
AllocateChannels
(
2
)
;
WriteZeroesToAudioBlock
(
&
m_tempBuffer
0
WEBAUDIO_BLOCK_SIZE
)
;
}
}
void
Reverb
:
:
process
(
const
AudioBlock
*
sourceBus
AudioBlock
*
destinationBus
)
{
bool
isSafeToProcess
=
sourceBus
&
&
destinationBus
&
&
sourceBus
-
>
ChannelCount
(
)
>
0
&
&
destinationBus
-
>
mChannelData
.
Length
(
)
>
0
&
&
WEBAUDIO_BLOCK_SIZE
<
=
MaxFrameSize
&
&
WEBAUDIO_BLOCK_SIZE
<
=
size_t
(
sourceBus
-
>
GetDuration
(
)
)
&
&
WEBAUDIO_BLOCK_SIZE
<
=
size_t
(
destinationBus
-
>
GetDuration
(
)
)
;
MOZ_ASSERT
(
isSafeToProcess
)
;
if
(
!
isSafeToProcess
)
return
;
MOZ_ASSERT
(
destinationBus
-
>
ChannelCount
(
)
<
=
2
)
;
float
*
destinationChannelL
=
static_cast
<
float
*
>
(
const_cast
<
void
*
>
(
destinationBus
-
>
mChannelData
[
0
]
)
)
;
const
float
*
sourceBusL
=
static_cast
<
const
float
*
>
(
sourceBus
-
>
mChannelData
[
0
]
)
;
size_t
numInputChannels
=
sourceBus
-
>
ChannelCount
(
)
;
size_t
numOutputChannels
=
destinationBus
-
>
ChannelCount
(
)
;
size_t
numReverbChannels
=
m_convolvers
.
Length
(
)
;
if
(
numInputChannels
=
=
2
&
&
numReverbChannels
=
=
2
&
&
numOutputChannels
=
=
2
)
{
const
float
*
sourceBusR
=
static_cast
<
const
float
*
>
(
sourceBus
-
>
mChannelData
[
1
]
)
;
float
*
destinationChannelR
=
static_cast
<
float
*
>
(
const_cast
<
void
*
>
(
destinationBus
-
>
mChannelData
[
1
]
)
)
;
m_convolvers
[
0
]
-
>
process
(
sourceBusL
destinationChannelL
)
;
m_convolvers
[
1
]
-
>
process
(
sourceBusR
destinationChannelR
)
;
}
else
if
(
numInputChannels
=
=
1
&
&
numOutputChannels
=
=
2
&
&
numReverbChannels
=
=
2
)
{
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
float
*
destinationChannel
=
static_cast
<
float
*
>
(
const_cast
<
void
*
>
(
destinationBus
-
>
mChannelData
[
i
]
)
)
;
m_convolvers
[
i
]
-
>
process
(
sourceBusL
destinationChannel
)
;
}
}
else
if
(
numInputChannels
=
=
1
&
&
numReverbChannels
=
=
1
&
&
numOutputChannels
=
=
2
)
{
m_convolvers
[
0
]
-
>
process
(
sourceBusL
destinationChannelL
)
;
float
*
destinationChannelR
=
static_cast
<
float
*
>
(
const_cast
<
void
*
>
(
destinationBus
-
>
mChannelData
[
1
]
)
)
;
bool
isCopySafe
=
destinationChannelL
&
&
destinationChannelR
&
&
size_t
(
destinationBus
-
>
GetDuration
(
)
)
>
=
WEBAUDIO_BLOCK_SIZE
;
MOZ_ASSERT
(
isCopySafe
)
;
if
(
!
isCopySafe
)
return
;
PodCopy
(
destinationChannelR
destinationChannelL
WEBAUDIO_BLOCK_SIZE
)
;
}
else
if
(
numInputChannels
=
=
1
&
&
numReverbChannels
=
=
1
&
&
numOutputChannels
=
=
1
)
{
m_convolvers
[
0
]
-
>
process
(
sourceBusL
destinationChannelL
)
;
}
else
if
(
numInputChannels
=
=
2
&
&
numReverbChannels
=
=
4
&
&
numOutputChannels
=
=
2
)
{
const
float
*
sourceBusR
=
static_cast
<
const
float
*
>
(
sourceBus
-
>
mChannelData
[
1
]
)
;
float
*
destinationChannelR
=
static_cast
<
float
*
>
(
const_cast
<
void
*
>
(
destinationBus
-
>
mChannelData
[
1
]
)
)
;
float
*
tempChannelL
=
static_cast
<
float
*
>
(
const_cast
<
void
*
>
(
m_tempBuffer
.
mChannelData
[
0
]
)
)
;
float
*
tempChannelR
=
static_cast
<
float
*
>
(
const_cast
<
void
*
>
(
m_tempBuffer
.
mChannelData
[
1
]
)
)
;
m_convolvers
[
0
]
-
>
process
(
sourceBusL
destinationChannelL
)
;
m_convolvers
[
1
]
-
>
process
(
sourceBusL
destinationChannelR
)
;
m_convolvers
[
2
]
-
>
process
(
sourceBusR
tempChannelL
)
;
m_convolvers
[
3
]
-
>
process
(
sourceBusR
tempChannelR
)
;
AudioBufferAddWithScale
(
tempChannelL
1
.
0f
destinationChannelL
sourceBus
-
>
GetDuration
(
)
)
;
AudioBufferAddWithScale
(
tempChannelR
1
.
0f
destinationChannelR
sourceBus
-
>
GetDuration
(
)
)
;
}
else
if
(
numInputChannels
=
=
1
&
&
numReverbChannels
=
=
4
&
&
numOutputChannels
=
=
2
)
{
float
*
destinationChannelR
=
static_cast
<
float
*
>
(
const_cast
<
void
*
>
(
destinationBus
-
>
mChannelData
[
1
]
)
)
;
float
*
tempChannelL
=
static_cast
<
float
*
>
(
const_cast
<
void
*
>
(
m_tempBuffer
.
mChannelData
[
0
]
)
)
;
float
*
tempChannelR
=
static_cast
<
float
*
>
(
const_cast
<
void
*
>
(
m_tempBuffer
.
mChannelData
[
1
]
)
)
;
m_convolvers
[
0
]
-
>
process
(
sourceBusL
destinationChannelL
)
;
m_convolvers
[
1
]
-
>
process
(
sourceBusL
destinationChannelR
)
;
m_convolvers
[
2
]
-
>
process
(
sourceBusL
tempChannelL
)
;
m_convolvers
[
3
]
-
>
process
(
sourceBusL
tempChannelR
)
;
AudioBufferAddWithScale
(
tempChannelL
1
.
0f
destinationChannelL
sourceBus
-
>
GetDuration
(
)
)
;
AudioBufferAddWithScale
(
tempChannelR
1
.
0f
destinationChannelR
sourceBus
-
>
GetDuration
(
)
)
;
}
else
{
destinationBus
-
>
SetNull
(
destinationBus
-
>
GetDuration
(
)
)
;
}
}
}
