#
include
"
platform
/
audio
/
IIRFilter
.
h
"
#
include
"
wtf
/
MathExtras
.
h
"
#
include
<
complex
>
namespace
blink
{
const
int
kBufferLength
=
32
;
static_assert
(
kBufferLength
>
=
IIRFilter
:
:
kMaxOrder
+
1
"
Internal
IIR
buffer
length
must
be
greater
than
maximum
IIR
Filter
order
.
"
)
;
IIRFilter
:
:
IIRFilter
(
const
AudioDoubleArray
*
feedforward
const
AudioDoubleArray
*
feedback
)
:
m_bufferIndex
(
0
)
m_feedback
(
feedback
)
m_feedforward
(
feedforward
)
{
m_xBuffer
.
allocate
(
kBufferLength
)
;
m_yBuffer
.
allocate
(
kBufferLength
)
;
}
IIRFilter
:
:
~
IIRFilter
(
)
{
}
void
IIRFilter
:
:
reset
(
)
{
m_xBuffer
.
zero
(
)
;
m_yBuffer
.
zero
(
)
;
}
static
std
:
:
complex
<
double
>
evaluatePolynomial
(
const
double
*
coef
std
:
:
complex
<
double
>
z
int
order
)
{
std
:
:
complex
<
double
>
result
=
0
;
for
(
int
k
=
order
;
k
>
=
0
;
-
-
k
)
result
=
result
*
z
+
std
:
:
complex
<
double
>
(
coef
[
k
]
)
;
return
result
;
}
void
IIRFilter
:
:
process
(
const
float
*
sourceP
float
*
destP
size_t
framesToProcess
)
{
const
double
*
feedback
=
m_feedback
-
>
data
(
)
;
const
double
*
feedforward
=
m_feedforward
-
>
data
(
)
;
ASSERT
(
feedback
)
;
ASSERT
(
feedforward
)
;
ASSERT
(
feedback
[
0
]
=
=
1
)
;
int
feedbackLength
=
m_feedback
-
>
size
(
)
;
int
feedforwardLength
=
m_feedforward
-
>
size
(
)
;
int
minLength
=
std
:
:
min
(
feedbackLength
feedforwardLength
)
;
double
*
xBuffer
=
m_xBuffer
.
data
(
)
;
double
*
yBuffer
=
m_yBuffer
.
data
(
)
;
for
(
size_t
n
=
0
;
n
<
framesToProcess
;
+
+
n
)
{
double
yn
=
feedforward
[
0
]
*
sourceP
[
n
]
;
for
(
int
k
=
1
;
k
<
minLength
;
+
+
k
)
{
int
n
=
(
m_bufferIndex
-
k
)
&
(
kBufferLength
-
1
)
;
yn
+
=
feedforward
[
k
]
*
xBuffer
[
n
]
;
yn
-
=
feedback
[
k
]
*
yBuffer
[
n
]
;
}
for
(
int
k
=
minLength
;
k
<
feedforwardLength
;
+
+
k
)
yn
+
=
feedforward
[
k
]
*
xBuffer
[
(
m_bufferIndex
-
k
)
&
(
kBufferLength
-
1
)
]
;
for
(
int
k
=
minLength
;
k
<
feedbackLength
;
+
+
k
)
yn
-
=
feedback
[
k
]
*
yBuffer
[
(
m_bufferIndex
-
k
)
&
(
kBufferLength
-
1
)
]
;
m_xBuffer
[
m_bufferIndex
]
=
sourceP
[
n
]
;
m_yBuffer
[
m_bufferIndex
]
=
yn
;
m_bufferIndex
=
(
m_bufferIndex
+
1
)
&
(
kBufferLength
-
1
)
;
destP
[
n
]
=
yn
;
}
}
void
IIRFilter
:
:
getFrequencyResponse
(
int
nFrequencies
const
float
*
frequency
float
*
magResponse
float
*
phaseResponse
)
{
for
(
int
k
=
0
;
k
<
nFrequencies
;
+
+
k
)
{
double
omega
=
-
piDouble
*
frequency
[
k
]
;
std
:
:
complex
<
double
>
zRecip
=
std
:
:
complex
<
double
>
(
cos
(
omega
)
sin
(
omega
)
)
;
std
:
:
complex
<
double
>
numerator
=
evaluatePolynomial
(
m_feedforward
-
>
data
(
)
zRecip
m_feedforward
-
>
size
(
)
-
1
)
;
std
:
:
complex
<
double
>
denominator
=
evaluatePolynomial
(
m_feedback
-
>
data
(
)
zRecip
m_feedback
-
>
size
(
)
-
1
)
;
std
:
:
complex
<
double
>
response
=
numerator
/
denominator
;
magResponse
[
k
]
=
static_cast
<
float
>
(
abs
(
response
)
)
;
phaseResponse
[
k
]
=
static_cast
<
float
>
(
atan2
(
imag
(
response
)
real
(
response
)
)
)
;
}
}
}
