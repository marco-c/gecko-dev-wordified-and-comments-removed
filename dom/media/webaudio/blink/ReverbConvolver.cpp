#
include
"
ReverbConvolver
.
h
"
#
include
"
ReverbConvolverStage
.
h
"
using
namespace
mozilla
;
template
<
>
struct
RunnableMethodTraits
<
WebCore
:
:
ReverbConvolver
>
{
static
void
RetainCallee
(
WebCore
:
:
ReverbConvolver
*
obj
)
{
}
static
void
ReleaseCallee
(
WebCore
:
:
ReverbConvolver
*
obj
)
{
}
}
;
namespace
WebCore
{
const
int
InputBufferSize
=
8
*
16384
;
const
size_t
RealtimeFrameLimit
=
8192
+
4096
-
WEBAUDIO_BLOCK_SIZE
;
const
size_t
MinFFTSize
=
128
;
const
size_t
MaxRealtimeFFTSize
=
4096
;
ReverbConvolver
:
:
ReverbConvolver
(
const
float
*
impulseResponseData
size_t
impulseResponseLength
size_t
maxFFTSize
size_t
convolverRenderPhase
bool
useBackgroundThreads
)
:
m_impulseResponseLength
(
impulseResponseLength
)
m_accumulationBuffer
(
impulseResponseLength
+
WEBAUDIO_BLOCK_SIZE
)
m_inputBuffer
(
InputBufferSize
)
m_minFFTSize
(
MinFFTSize
)
m_maxFFTSize
(
maxFFTSize
)
m_backgroundThread
(
"
ConvolverWorker
"
)
m_backgroundThreadCondition
(
&
m_backgroundThreadLock
)
m_useBackgroundThreads
(
useBackgroundThreads
)
m_wantsToExit
(
false
)
m_moreInputBuffered
(
false
)
{
m_maxRealtimeFFTSize
=
MaxRealtimeFFTSize
;
bool
hasRealtimeConstraint
=
useBackgroundThreads
;
const
float
*
response
=
impulseResponseData
;
size_t
totalResponseLength
=
impulseResponseLength
;
size_t
reverbTotalLatency
=
0
;
size_t
stageOffset
=
0
;
size_t
stagePhase
=
0
;
size_t
fftSize
=
m_minFFTSize
;
while
(
stageOffset
<
totalResponseLength
)
{
size_t
stageSize
=
fftSize
/
2
;
if
(
stageSize
+
stageOffset
>
totalResponseLength
)
stageSize
=
totalResponseLength
-
stageOffset
;
int
renderPhase
=
convolverRenderPhase
+
stagePhase
;
bool
useDirectConvolver
=
!
stageOffset
;
nsAutoPtr
<
ReverbConvolverStage
>
stage
(
new
ReverbConvolverStage
(
response
totalResponseLength
reverbTotalLatency
stageOffset
stageSize
fftSize
renderPhase
&
m_accumulationBuffer
useDirectConvolver
)
)
;
bool
isBackgroundStage
=
false
;
if
(
this
-
>
useBackgroundThreads
(
)
&
&
stageOffset
>
RealtimeFrameLimit
)
{
m_backgroundStages
.
AppendElement
(
stage
.
forget
(
)
)
;
isBackgroundStage
=
true
;
}
else
m_stages
.
AppendElement
(
stage
.
forget
(
)
)
;
stageOffset
+
=
stageSize
;
if
(
!
useDirectConvolver
)
{
fftSize
*
=
2
;
}
if
(
hasRealtimeConstraint
&
&
!
isBackgroundStage
&
&
fftSize
>
m_maxRealtimeFFTSize
)
{
fftSize
=
m_maxRealtimeFFTSize
;
const
uint32_t
phaseLookup
[
]
=
{
10
4
14
0
}
;
stagePhase
=
WEBAUDIO_BLOCK_SIZE
*
phaseLookup
[
m_stages
.
Length
(
)
%
ArrayLength
(
phaseLookup
)
]
;
}
else
if
(
fftSize
>
m_maxFFTSize
)
{
fftSize
=
m_maxFFTSize
;
stagePhase
+
=
5
*
WEBAUDIO_BLOCK_SIZE
;
}
else
if
(
stageSize
>
WEBAUDIO_BLOCK_SIZE
)
{
stagePhase
=
stageSize
-
WEBAUDIO_BLOCK_SIZE
;
}
}
if
(
this
-
>
useBackgroundThreads
(
)
&
&
m_backgroundStages
.
Length
(
)
>
0
)
{
if
(
!
m_backgroundThread
.
Start
(
)
)
{
NS_WARNING
(
"
Cannot
start
convolver
thread
.
"
)
;
return
;
}
CancelableTask
*
task
=
NewRunnableMethod
(
this
&
ReverbConvolver
:
:
backgroundThreadEntry
)
;
m_backgroundThread
.
message_loop
(
)
-
>
PostTask
(
FROM_HERE
task
)
;
}
}
ReverbConvolver
:
:
~
ReverbConvolver
(
)
{
if
(
useBackgroundThreads
(
)
&
&
m_backgroundThread
.
IsRunning
(
)
)
{
m_wantsToExit
=
true
;
{
AutoLock
locker
(
m_backgroundThreadLock
)
;
m_moreInputBuffered
=
true
;
m_backgroundThreadCondition
.
Signal
(
)
;
}
m_backgroundThread
.
Stop
(
)
;
}
}
size_t
ReverbConvolver
:
:
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
aMallocSizeOf
(
this
)
;
amount
+
=
m_stages
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
size_t
i
=
0
;
i
<
m_stages
.
Length
(
)
;
i
+
+
)
{
if
(
m_stages
[
i
]
)
{
amount
+
=
m_stages
[
i
]
-
>
sizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
amount
+
=
m_backgroundStages
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
size_t
i
=
0
;
i
<
m_backgroundStages
.
Length
(
)
;
i
+
+
)
{
if
(
m_backgroundStages
[
i
]
)
{
amount
+
=
m_backgroundStages
[
i
]
-
>
sizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
amount
+
=
m_accumulationBuffer
.
sizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
m_inputBuffer
.
sizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
void
ReverbConvolver
:
:
backgroundThreadEntry
(
)
{
while
(
!
m_wantsToExit
)
{
m_moreInputBuffered
=
false
;
{
AutoLock
locker
(
m_backgroundThreadLock
)
;
while
(
!
m_moreInputBuffered
&
&
!
m_wantsToExit
)
m_backgroundThreadCondition
.
Wait
(
)
;
}
int
writeIndex
=
m_inputBuffer
.
writeIndex
(
)
;
int
readIndex
;
while
(
(
readIndex
=
m_backgroundStages
[
0
]
-
>
inputReadIndex
(
)
)
!
=
writeIndex
)
{
for
(
size_t
i
=
0
;
i
<
m_backgroundStages
.
Length
(
)
;
+
+
i
)
m_backgroundStages
[
i
]
-
>
processInBackground
(
this
)
;
}
}
}
void
ReverbConvolver
:
:
process
(
const
float
*
sourceChannelData
float
*
destinationChannelData
)
{
const
float
*
source
=
sourceChannelData
;
float
*
destination
=
destinationChannelData
;
bool
isDataSafe
=
source
&
&
destination
;
MOZ_ASSERT
(
isDataSafe
)
;
if
(
!
isDataSafe
)
return
;
m_inputBuffer
.
write
(
source
WEBAUDIO_BLOCK_SIZE
)
;
for
(
size_t
i
=
0
;
i
<
m_stages
.
Length
(
)
;
+
+
i
)
m_stages
[
i
]
-
>
process
(
source
)
;
m_accumulationBuffer
.
readAndClear
(
destination
WEBAUDIO_BLOCK_SIZE
)
;
if
(
m_backgroundThreadLock
.
Try
(
)
)
{
m_moreInputBuffered
=
true
;
m_backgroundThreadCondition
.
Signal
(
)
;
m_backgroundThreadLock
.
Release
(
)
;
}
}
}
