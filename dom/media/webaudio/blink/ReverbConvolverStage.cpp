#
include
"
ReverbConvolverStage
.
h
"
#
include
"
ReverbAccumulationBuffer
.
h
"
#
include
"
ReverbConvolver
.
h
"
#
include
"
ReverbInputBuffer
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
using
namespace
mozilla
;
namespace
WebCore
{
ReverbConvolverStage
:
:
ReverbConvolverStage
(
const
float
*
impulseResponse
size_t
size_t
reverbTotalLatency
size_t
stageOffset
size_t
stageLength
size_t
fftSize
size_t
renderPhase
size_t
renderSliceSize
ReverbAccumulationBuffer
*
accumulationBuffer
bool
directMode
)
:
m_accumulationBuffer
(
accumulationBuffer
)
m_accumulationReadIndex
(
0
)
m_inputReadIndex
(
0
)
m_directMode
(
directMode
)
{
MOZ_ASSERT
(
impulseResponse
)
;
MOZ_ASSERT
(
accumulationBuffer
)
;
if
(
!
m_directMode
)
{
m_fftKernel
=
new
FFTBlock
(
fftSize
)
;
m_fftKernel
-
>
PadAndMakeScaledDFT
(
impulseResponse
+
stageOffset
stageLength
)
;
m_fftConvolver
=
new
FFTConvolver
(
fftSize
renderPhase
)
;
}
else
{
m_directKernel
.
SetLength
(
fftSize
/
2
)
;
PodCopy
(
m_directKernel
.
Elements
(
)
impulseResponse
+
stageOffset
fftSize
/
2
)
;
m_directConvolver
=
new
DirectConvolver
(
renderSliceSize
)
;
}
m_temporaryBuffer
.
SetLength
(
renderSliceSize
)
;
PodZero
(
m_temporaryBuffer
.
Elements
(
)
m_temporaryBuffer
.
Length
(
)
)
;
size_t
totalDelay
=
stageOffset
+
reverbTotalLatency
;
size_t
halfSize
=
fftSize
/
2
;
if
(
!
m_directMode
)
{
MOZ_ASSERT
(
totalDelay
>
=
halfSize
)
;
if
(
totalDelay
>
=
halfSize
)
totalDelay
-
=
halfSize
;
}
m_postDelayLength
=
totalDelay
;
}
size_t
ReverbConvolverStage
:
:
sizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
aMallocSizeOf
(
this
)
;
if
(
m_fftKernel
)
{
amount
+
=
m_fftKernel
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
m_fftConvolver
)
{
amount
+
=
m_fftConvolver
-
>
sizeOfIncludingThis
(
aMallocSizeOf
)
;
}
amount
+
=
m_temporaryBuffer
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
m_directKernel
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
if
(
m_directConvolver
)
{
amount
+
=
m_directConvolver
-
>
sizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
amount
;
}
void
ReverbConvolverStage
:
:
processInBackground
(
ReverbConvolver
*
convolver
size_t
framesToProcess
)
{
ReverbInputBuffer
*
inputBuffer
=
convolver
-
>
inputBuffer
(
)
;
float
*
source
=
inputBuffer
-
>
directReadFrom
(
&
m_inputReadIndex
framesToProcess
)
;
process
(
source
framesToProcess
)
;
}
void
ReverbConvolverStage
:
:
process
(
const
float
*
source
size_t
framesToProcess
)
{
MOZ_ASSERT
(
source
)
;
if
(
!
source
)
return
;
float
*
temporaryBuffer
;
bool
isTemporaryBufferSafe
=
false
;
isTemporaryBufferSafe
=
framesToProcess
<
=
m_temporaryBuffer
.
Length
(
)
;
temporaryBuffer
=
m_temporaryBuffer
.
Elements
(
)
;
MOZ_ASSERT
(
isTemporaryBufferSafe
)
;
if
(
!
isTemporaryBufferSafe
)
return
;
if
(
!
m_directMode
)
m_fftConvolver
-
>
process
(
m_fftKernel
source
temporaryBuffer
framesToProcess
)
;
else
m_directConvolver
-
>
process
(
&
m_directKernel
source
temporaryBuffer
framesToProcess
)
;
m_accumulationBuffer
-
>
accumulate
(
temporaryBuffer
framesToProcess
&
m_accumulationReadIndex
m_postDelayLength
)
;
}
}
