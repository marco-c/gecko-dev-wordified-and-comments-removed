#
ifndef
FFTBlock_h_
#
define
FFTBlock_h_
#
include
"
AlignedTArray
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
FFVPXRuntimeLinker
.
h
"
#
include
"
ffvpx
/
tx
.
h
"
namespace
mozilla
{
class
FFTBlock
final
{
union
ComplexU
{
float
f
[
2
]
;
struct
{
float
r
;
float
i
;
}
;
}
;
public
:
static
void
MainThreadInit
(
)
{
FFVPXRuntimeLinker
:
:
Init
(
)
;
if
(
!
sFFTFuncs
.
init
)
{
FFVPXRuntimeLinker
:
:
GetFFTFuncs
(
&
sFFTFuncs
)
;
}
}
explicit
FFTBlock
(
uint32_t
aFFTSize
float
aInverseScaling
=
1
.
0f
)
:
mInverseScaling
(
aInverseScaling
)
{
MOZ_COUNT_CTOR
(
FFTBlock
)
;
SetFFTSize
(
aFFTSize
)
;
}
~
FFTBlock
(
)
{
MOZ_COUNT_DTOR
(
FFTBlock
)
;
Clear
(
)
;
}
static
FFTBlock
*
CreateInterpolatedBlock
(
const
FFTBlock
&
block0
const
FFTBlock
&
block1
double
interp
)
;
void
PerformFFT
(
const
float
*
aData
)
{
if
(
!
EnsureFFT
(
)
)
{
return
;
}
mFn
(
mTxCtx
mOutputBuffer
.
Elements
(
)
-
>
f
const_cast
<
float
*
>
(
aData
)
2
*
sizeof
(
float
)
)
;
#
ifdef
DEBUG
mInversePerformed
=
false
;
#
endif
}
void
GetInverse
(
float
*
aDataOut
)
{
if
(
!
EnsureIFFT
(
)
)
{
std
:
:
fill_n
(
aDataOut
mFFTSize
0
.
0f
)
;
return
;
}
;
MOZ_ASSERT
(
!
mInversePerformed
)
;
mIFn
(
mITxCtx
aDataOut
mOutputBuffer
.
Elements
(
)
-
>
f
2
*
sizeof
(
float
)
)
;
#
ifdef
DEBUG
mInversePerformed
=
true
;
#
endif
}
void
Multiply
(
const
FFTBlock
&
aFrame
)
{
MOZ_ASSERT
(
!
mInversePerformed
)
;
uint32_t
halfSize
=
mFFTSize
/
2
;
MOZ_ASSERT
(
mOutputBuffer
[
0
]
.
i
=
=
0
)
;
MOZ_ASSERT
(
aFrame
.
mOutputBuffer
[
0
]
.
i
=
=
0
)
;
BufferComplexMultiply
(
mOutputBuffer
.
Elements
(
)
-
>
f
aFrame
.
mOutputBuffer
.
Elements
(
)
-
>
f
mOutputBuffer
.
Elements
(
)
-
>
f
halfSize
)
;
mOutputBuffer
[
halfSize
]
.
r
*
=
aFrame
.
mOutputBuffer
[
halfSize
]
.
r
;
mOutputBuffer
[
0
]
.
i
=
0
.
0f
;
}
void
PadAndMakeScaledDFT
(
const
float
*
aData
size_t
dataSize
)
{
MOZ_ASSERT
(
dataSize
<
=
FFTSize
(
)
)
;
AlignedTArray
<
float
>
paddedData
;
paddedData
.
SetLength
(
FFTSize
(
)
)
;
AudioBufferCopyWithScale
(
aData
1
.
0f
/
AssertedCast
<
float
>
(
FFTSize
(
)
)
paddedData
.
Elements
(
)
dataSize
)
;
PodZero
(
paddedData
.
Elements
(
)
+
dataSize
mFFTSize
-
dataSize
)
;
PerformFFT
(
paddedData
.
Elements
(
)
)
;
}
void
SetFFTSize
(
uint32_t
aSize
)
{
MOZ_ASSERT
(
CountPopulation32
(
aSize
)
=
=
1
)
;
mFFTSize
=
aSize
;
mOutputBuffer
.
SetLength
(
aSize
/
2
+
1
)
;
PodZero
(
mOutputBuffer
.
Elements
(
)
aSize
/
2
+
1
)
;
Clear
(
)
;
}
double
ExtractAverageGroupDelay
(
)
;
uint32_t
FFTSize
(
)
const
{
return
mFFTSize
;
}
float
RealData
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
!
mInversePerformed
)
;
return
mOutputBuffer
[
aIndex
]
.
r
;
}
float
&
RealData
(
uint32_t
aIndex
)
{
MOZ_ASSERT
(
!
mInversePerformed
)
;
return
mOutputBuffer
[
aIndex
]
.
r
;
}
float
ImagData
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
!
mInversePerformed
)
;
return
mOutputBuffer
[
aIndex
]
.
i
;
}
float
&
ImagData
(
uint32_t
aIndex
)
{
MOZ_ASSERT
(
!
mInversePerformed
)
;
return
mOutputBuffer
[
aIndex
]
.
i
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
0
;
amount
+
=
aMallocSizeOf
(
mTxCtx
)
;
amount
+
=
aMallocSizeOf
(
mITxCtx
)
;
amount
+
=
mOutputBuffer
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
FFTBlock
(
const
FFTBlock
&
other
)
=
delete
;
void
operator
=
(
const
FFTBlock
&
other
)
=
delete
;
private
:
bool
EnsureFFT
(
)
{
if
(
!
mTxCtx
)
{
float
scale
=
1
.
0f
;
DebugOnly
<
int
>
rv
=
sFFTFuncs
.
init
(
&
mTxCtx
&
mFn
AV_TX_FLOAT_RDFT
0
AssertedCast
<
int
>
(
mFFTSize
)
&
scale
0
)
;
MOZ_ASSERT
(
!
rv
"
av_tx_init
:
invalid
parameters
(
forward
)
"
)
;
}
return
true
;
}
bool
EnsureIFFT
(
)
{
if
(
!
mITxCtx
)
{
DebugOnly
<
int
>
rv
=
sFFTFuncs
.
init
(
&
mITxCtx
&
mIFn
AV_TX_FLOAT_RDFT
1
AssertedCast
<
int
>
(
mFFTSize
)
&
mInverseScaling
0
)
;
MOZ_ASSERT
(
!
rv
"
av_tx_init
:
invalid
parameters
(
inverse
)
"
)
;
}
return
true
;
}
void
Clear
(
)
{
if
(
mTxCtx
)
{
sFFTFuncs
.
uninit
(
&
mTxCtx
)
;
mFn
=
nullptr
;
}
if
(
mITxCtx
)
{
sFFTFuncs
.
uninit
(
&
mITxCtx
)
;
mIFn
=
nullptr
;
}
}
void
AddConstantGroupDelay
(
double
sampleFrameDelay
)
;
void
InterpolateFrequencyComponents
(
const
FFTBlock
&
block0
const
FFTBlock
&
block1
double
interp
)
;
static
FFmpegFFTFuncs
sFFTFuncs
;
AVTXContext
*
mTxCtx
{
}
;
av_tx_fn
mFn
{
}
;
AVTXContext
*
mITxCtx
{
}
;
av_tx_fn
mIFn
{
}
;
AlignedTArray
<
ComplexU
>
mOutputBuffer
;
uint32_t
mFFTSize
{
}
;
float
mInverseScaling
;
#
ifdef
DEBUG
bool
mInversePerformed
=
false
;
#
endif
}
;
}
#
endif
