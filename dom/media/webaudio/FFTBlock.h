#
ifndef
FFTBlock_h_
#
define
FFTBlock_h_
#
include
"
AlignedTArray
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
FFmpegRDFTTypes
.
h
"
#
include
"
FFVPXRuntimeLinker
.
h
"
namespace
mozilla
{
class
FFTBlock
final
{
union
ComplexU
{
float
f
[
2
]
;
struct
{
float
r
;
float
i
;
}
;
}
;
public
:
static
void
MainThreadInit
(
)
{
FFVPXRuntimeLinker
:
:
Init
(
)
;
if
(
!
sRDFTFuncs
.
init
)
{
FFVPXRuntimeLinker
:
:
GetRDFTFuncs
(
&
sRDFTFuncs
)
;
}
}
explicit
FFTBlock
(
uint32_t
aFFTSize
)
:
mAvRDFT
(
nullptr
)
mAvIRDFT
(
nullptr
)
{
MOZ_COUNT_CTOR
(
FFTBlock
)
;
SetFFTSize
(
aFFTSize
)
;
}
~
FFTBlock
(
)
{
MOZ_COUNT_DTOR
(
FFTBlock
)
;
Clear
(
)
;
}
static
FFTBlock
*
CreateInterpolatedBlock
(
const
FFTBlock
&
block0
const
FFTBlock
&
block1
double
interp
)
;
void
PerformFFT
(
const
float
*
aData
)
{
if
(
!
EnsureFFT
(
)
)
{
return
;
}
PodCopy
(
mOutputBuffer
.
Elements
(
)
-
>
f
aData
mFFTSize
)
;
sRDFTFuncs
.
calc
(
mAvRDFT
mOutputBuffer
.
Elements
(
)
-
>
f
)
;
mOutputBuffer
[
mFFTSize
/
2
]
.
r
=
mOutputBuffer
[
0
]
.
i
;
mOutputBuffer
[
0
]
.
i
=
0
.
0f
;
}
void
GetInverse
(
float
*
aDataOut
)
{
GetInverseWithoutScaling
(
aDataOut
)
;
AudioBufferInPlaceScale
(
aDataOut
1
.
0f
/
mFFTSize
mFFTSize
)
;
}
void
GetInverseWithoutScaling
(
float
*
aDataOut
)
{
if
(
!
EnsureIFFT
(
)
)
{
std
:
:
fill_n
(
aDataOut
mFFTSize
0
.
0f
)
;
return
;
}
;
AudioBufferCopyWithScale
(
mOutputBuffer
.
Elements
(
)
-
>
f
2
.
0f
aDataOut
mFFTSize
)
;
aDataOut
[
1
]
=
2
.
0f
*
mOutputBuffer
[
mFFTSize
/
2
]
.
r
;
sRDFTFuncs
.
calc
(
mAvIRDFT
aDataOut
)
;
}
void
Multiply
(
const
FFTBlock
&
aFrame
)
{
uint32_t
halfSize
=
mFFTSize
/
2
;
MOZ_ASSERT
(
mOutputBuffer
[
0
]
.
i
=
=
0
)
;
MOZ_ASSERT
(
aFrame
.
mOutputBuffer
[
0
]
.
i
=
=
0
)
;
BufferComplexMultiply
(
mOutputBuffer
.
Elements
(
)
-
>
f
aFrame
.
mOutputBuffer
.
Elements
(
)
-
>
f
mOutputBuffer
.
Elements
(
)
-
>
f
halfSize
)
;
mOutputBuffer
[
halfSize
]
.
r
*
=
aFrame
.
mOutputBuffer
[
halfSize
]
.
r
;
mOutputBuffer
[
0
]
.
i
=
0
.
0f
;
}
void
PadAndMakeScaledDFT
(
const
float
*
aData
size_t
dataSize
)
{
MOZ_ASSERT
(
dataSize
<
=
FFTSize
(
)
)
;
AlignedTArray
<
float
>
paddedData
;
paddedData
.
SetLength
(
FFTSize
(
)
)
;
AudioBufferCopyWithScale
(
aData
1
.
0f
/
FFTSize
(
)
paddedData
.
Elements
(
)
dataSize
)
;
PodZero
(
paddedData
.
Elements
(
)
+
dataSize
mFFTSize
-
dataSize
)
;
PerformFFT
(
paddedData
.
Elements
(
)
)
;
}
void
SetFFTSize
(
uint32_t
aSize
)
{
MOZ_ASSERT
(
CountPopulation32
(
aSize
)
=
=
1
)
;
mFFTSize
=
aSize
;
mOutputBuffer
.
SetLength
(
aSize
/
2
+
1
)
;
PodZero
(
mOutputBuffer
.
Elements
(
)
aSize
/
2
+
1
)
;
Clear
(
)
;
}
double
ExtractAverageGroupDelay
(
)
;
uint32_t
FFTSize
(
)
const
{
return
mFFTSize
;
}
float
RealData
(
uint32_t
aIndex
)
const
{
return
mOutputBuffer
[
aIndex
]
.
r
;
}
float
&
RealData
(
uint32_t
aIndex
)
{
return
mOutputBuffer
[
aIndex
]
.
r
;
}
float
ImagData
(
uint32_t
aIndex
)
const
{
return
mOutputBuffer
[
aIndex
]
.
i
;
}
float
&
ImagData
(
uint32_t
aIndex
)
{
return
mOutputBuffer
[
aIndex
]
.
i
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
0
;
auto
ComputedSizeOfContextIfSet
=
[
this
]
(
void
*
aContext
)
-
>
size_t
{
if
(
!
aContext
)
{
return
0
;
}
size_t
amount
=
232
;
MOZ_ASSERT
(
mFFTSize
<
=
32768
)
;
amount
+
=
mFFTSize
*
(
sizeof
(
uint16_t
)
+
2
*
sizeof
(
float
)
)
;
return
amount
;
}
;
amount
+
=
ComputedSizeOfContextIfSet
(
mAvRDFT
)
;
amount
+
=
ComputedSizeOfContextIfSet
(
mAvIRDFT
)
;
amount
+
=
mOutputBuffer
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
private
:
FFTBlock
(
const
FFTBlock
&
other
)
=
delete
;
void
operator
=
(
const
FFTBlock
&
other
)
=
delete
;
bool
EnsureFFT
(
)
{
if
(
!
mAvRDFT
)
{
if
(
!
sRDFTFuncs
.
init
)
{
return
false
;
}
mAvRDFT
=
sRDFTFuncs
.
init
(
FloorLog2
(
mFFTSize
)
DFT_R2C
)
;
}
return
true
;
}
bool
EnsureIFFT
(
)
{
if
(
!
mAvIRDFT
)
{
if
(
!
sRDFTFuncs
.
init
)
{
return
false
;
}
mAvIRDFT
=
sRDFTFuncs
.
init
(
FloorLog2
(
mFFTSize
)
IDFT_C2R
)
;
}
return
true
;
}
void
Clear
(
)
{
if
(
mAvRDFT
)
{
sRDFTFuncs
.
end
(
mAvRDFT
)
;
mAvRDFT
=
nullptr
;
}
if
(
mAvIRDFT
)
{
sRDFTFuncs
.
end
(
mAvIRDFT
)
;
mAvIRDFT
=
nullptr
;
}
}
void
AddConstantGroupDelay
(
double
sampleFrameDelay
)
;
void
InterpolateFrequencyComponents
(
const
FFTBlock
&
block0
const
FFTBlock
&
block1
double
interp
)
;
static
FFmpegRDFTFuncs
sRDFTFuncs
;
RDFTContext
*
mAvRDFT
;
RDFTContext
*
mAvIRDFT
;
AlignedTArray
<
ComplexU
>
mOutputBuffer
;
uint32_t
mFFTSize
{
}
;
}
;
}
#
endif
