#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeExternalInputStream
.
h
"
#
include
"
AudioChannelFormat
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamAudioSourceNode
.
h
"
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
AudioNodeExternalInputStream
:
:
AudioNodeExternalInputStream
(
AudioNodeEngine
*
aEngine
TrackRate
aSampleRate
)
:
AudioNodeStream
(
aEngine
NO_STREAM_FLAGS
aSampleRate
)
{
MOZ_COUNT_CTOR
(
AudioNodeExternalInputStream
)
;
}
AudioNodeExternalInputStream
:
:
~
AudioNodeExternalInputStream
(
)
{
MOZ_COUNT_DTOR
(
AudioNodeExternalInputStream
)
;
}
already_AddRefed
<
AudioNodeExternalInputStream
>
AudioNodeExternalInputStream
:
:
Create
(
MediaStreamGraph
*
aGraph
AudioNodeEngine
*
aEngine
)
{
AudioContext
*
ctx
=
aEngine
-
>
NodeMainThread
(
)
-
>
Context
(
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aGraph
-
>
GraphRate
(
)
=
=
ctx
-
>
SampleRate
(
)
)
;
RefPtr
<
AudioNodeExternalInputStream
>
stream
=
new
AudioNodeExternalInputStream
(
aEngine
aGraph
-
>
GraphRate
(
)
)
;
stream
-
>
mSuspendedCount
+
=
ctx
-
>
ShouldSuspendNewStream
(
)
;
aGraph
-
>
AddStream
(
stream
)
;
return
stream
.
forget
(
)
;
}
template
<
typename
T
>
static
void
CopyChunkToBlock
(
AudioChunk
&
aInput
AudioBlock
*
aBlock
uint32_t
aOffsetInBlock
)
{
uint32_t
blockChannels
=
aBlock
-
>
ChannelCount
(
)
;
AutoTArray
<
const
T
*
2
>
channels
;
if
(
aInput
.
IsNull
(
)
)
{
channels
.
SetLength
(
blockChannels
)
;
PodZero
(
channels
.
Elements
(
)
blockChannels
)
;
}
else
{
const
nsTArray
<
const
T
*
>
&
inputChannels
=
aInput
.
ChannelData
<
T
>
(
)
;
channels
.
SetLength
(
inputChannels
.
Length
(
)
)
;
PodCopy
(
channels
.
Elements
(
)
inputChannels
.
Elements
(
)
channels
.
Length
(
)
)
;
if
(
channels
.
Length
(
)
!
=
blockChannels
)
{
AudioChannelsUpMix
(
&
channels
blockChannels
static_cast
<
T
*
>
(
nullptr
)
)
;
}
}
for
(
uint32_t
c
=
0
;
c
<
blockChannels
;
+
+
c
)
{
float
*
outputData
=
aBlock
-
>
ChannelFloatsForWrite
(
c
)
+
aOffsetInBlock
;
if
(
channels
[
c
]
)
{
ConvertAudioSamplesWithScale
(
channels
[
c
]
outputData
aInput
.
GetDuration
(
)
aInput
.
mVolume
)
;
}
else
{
PodZero
(
outputData
aInput
.
GetDuration
(
)
)
;
}
}
}
static
void
ConvertSegmentToAudioBlock
(
AudioSegment
*
aSegment
AudioBlock
*
aBlock
int32_t
aFallbackChannelCount
)
{
NS_ASSERTION
(
aSegment
-
>
GetDuration
(
)
=
=
WEBAUDIO_BLOCK_SIZE
"
Bad
segment
duration
"
)
;
{
AudioSegment
:
:
ChunkIterator
ci
(
*
aSegment
)
;
NS_ASSERTION
(
!
ci
.
IsEnded
(
)
"
Should
be
at
least
one
chunk
!
"
)
;
if
(
ci
-
>
GetDuration
(
)
=
=
WEBAUDIO_BLOCK_SIZE
&
&
(
ci
-
>
IsNull
(
)
|
|
ci
-
>
mBufferFormat
=
=
AUDIO_FORMAT_FLOAT32
)
)
{
*
aBlock
=
*
ci
;
return
;
}
}
aBlock
-
>
AllocateChannels
(
aFallbackChannelCount
)
;
uint32_t
duration
=
0
;
for
(
AudioSegment
:
:
ChunkIterator
ci
(
*
aSegment
)
;
!
ci
.
IsEnded
(
)
;
ci
.
Next
(
)
)
{
switch
(
ci
-
>
mBufferFormat
)
{
case
AUDIO_FORMAT_S16
:
{
CopyChunkToBlock
<
int16_t
>
(
*
ci
aBlock
duration
)
;
break
;
}
case
AUDIO_FORMAT_FLOAT32
:
{
CopyChunkToBlock
<
float
>
(
*
ci
aBlock
duration
)
;
break
;
}
case
AUDIO_FORMAT_SILENCE
:
{
CopyChunkToBlock
<
float
>
(
*
ci
aBlock
duration
)
;
break
;
}
}
duration
+
=
ci
-
>
GetDuration
(
)
;
}
}
void
AudioNodeExternalInputStream
:
:
ProcessInput
(
GraphTime
aFrom
GraphTime
aTo
uint32_t
aFlags
)
{
MOZ_ASSERT
(
mLastChunks
.
Length
(
)
=
=
1
)
;
if
(
!
IsEnabled
(
)
|
|
mInputs
.
IsEmpty
(
)
|
|
mPassThrough
)
{
mLastChunks
[
0
]
.
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
return
;
}
MOZ_ASSERT
(
mInputs
.
Length
(
)
=
=
1
)
;
MediaStream
*
source
=
mInputs
[
0
]
-
>
GetSource
(
)
;
AutoTArray
<
AudioSegment
1
>
audioSegments
;
uint32_t
inputChannels
=
0
;
for
(
StreamBuffer
:
:
TrackIter
tracks
(
source
-
>
mBuffer
MediaSegment
:
:
AUDIO
)
;
!
tracks
.
IsEnded
(
)
;
tracks
.
Next
(
)
)
{
const
StreamBuffer
:
:
Track
&
inputTrack
=
*
tracks
;
if
(
!
mInputs
[
0
]
-
>
PassTrackThrough
(
tracks
-
>
GetID
(
)
)
)
{
continue
;
}
const
AudioSegment
&
inputSegment
=
*
static_cast
<
AudioSegment
*
>
(
inputTrack
.
GetSegment
(
)
)
;
if
(
inputSegment
.
IsNull
(
)
)
{
continue
;
}
AudioSegment
&
segment
=
*
audioSegments
.
AppendElement
(
)
;
GraphTime
next
;
for
(
GraphTime
t
=
aFrom
;
t
<
aTo
;
t
=
next
)
{
MediaInputPort
:
:
InputInterval
interval
=
mInputs
[
0
]
-
>
GetNextInputInterval
(
t
)
;
interval
.
mEnd
=
std
:
:
min
(
interval
.
mEnd
aTo
)
;
if
(
interval
.
mStart
>
=
interval
.
mEnd
)
break
;
next
=
interval
.
mEnd
;
StreamTime
outputStart
=
GraphTimeToStreamTime
(
interval
.
mStart
)
;
StreamTime
outputEnd
=
GraphTimeToStreamTime
(
interval
.
mEnd
)
;
StreamTime
ticks
=
outputEnd
-
outputStart
;
if
(
interval
.
mInputIsBlocked
)
{
segment
.
AppendNullData
(
ticks
)
;
}
else
{
StreamTime
inputStart
=
std
:
:
min
(
inputSegment
.
GetDuration
(
)
source
-
>
GraphTimeToStreamTime
(
interval
.
mStart
)
)
;
StreamTime
inputEnd
=
std
:
:
min
(
inputSegment
.
GetDuration
(
)
source
-
>
GraphTimeToStreamTime
(
interval
.
mEnd
)
)
;
segment
.
AppendSlice
(
inputSegment
inputStart
inputEnd
)
;
segment
.
AppendNullData
(
ticks
-
(
inputEnd
-
inputStart
)
)
;
}
}
for
(
AudioSegment
:
:
ChunkIterator
iter
(
segment
)
;
!
iter
.
IsEnded
(
)
;
iter
.
Next
(
)
)
{
inputChannels
=
GetAudioChannelsSuperset
(
inputChannels
iter
-
>
ChannelCount
(
)
)
;
}
}
uint32_t
accumulateIndex
=
0
;
if
(
inputChannels
)
{
AutoTArray
<
float
GUESS_AUDIO_CHANNELS
*
WEBAUDIO_BLOCK_SIZE
>
downmixBuffer
;
for
(
uint32_t
i
=
0
;
i
<
audioSegments
.
Length
(
)
;
+
+
i
)
{
AudioBlock
tmpChunk
;
ConvertSegmentToAudioBlock
(
&
audioSegments
[
i
]
&
tmpChunk
inputChannels
)
;
if
(
!
tmpChunk
.
IsNull
(
)
)
{
if
(
accumulateIndex
=
=
0
)
{
mLastChunks
[
0
]
.
AllocateChannels
(
inputChannels
)
;
}
AccumulateInputChunk
(
accumulateIndex
tmpChunk
&
mLastChunks
[
0
]
&
downmixBuffer
)
;
accumulateIndex
+
+
;
}
}
}
if
(
accumulateIndex
=
=
0
)
{
mLastChunks
[
0
]
.
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
}
}
bool
AudioNodeExternalInputStream
:
:
IsEnabled
(
)
{
return
(
(
MediaStreamAudioSourceNodeEngine
*
)
Engine
(
)
)
-
>
IsEnabled
(
)
;
}
}
