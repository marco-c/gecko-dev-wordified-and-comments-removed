#
include
"
PannerNode
.
h
"
#
include
"
AlignmentUtils
.
h
"
#
include
"
AudioDestinationNode
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeStream
.
h
"
#
include
"
AudioListener
.
h
"
#
include
"
PanningUtils
.
h
"
#
include
"
AudioBufferSourceNode
.
h
"
#
include
"
PlayingRefChangeHandler
.
h
"
#
include
"
blink
/
HRTFPanner
.
h
"
#
include
"
blink
/
HRTFDatabaseLoader
.
h
"
#
include
"
nsAutoPtr
.
h
"
using
WebCore
:
:
HRTFDatabaseLoader
;
using
WebCore
:
:
HRTFPanner
;
namespace
mozilla
{
namespace
dom
{
using
namespace
std
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
PannerNode
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
PannerNode
AudioNode
)
if
(
tmp
-
>
Context
(
)
)
{
tmp
-
>
Context
(
)
-
>
UnregisterPannerNode
(
tmp
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPositionX
mPositionY
mPositionZ
mOrientationX
mOrientationY
mOrientationZ
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
PannerNode
AudioNode
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPositionX
mPositionY
mPositionZ
mOrientationX
mOrientationY
mOrientationZ
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
PannerNode
)
NS_INTERFACE_MAP_END_INHERITING
(
AudioNode
)
NS_IMPL_ADDREF_INHERITED
(
PannerNode
AudioNode
)
NS_IMPL_RELEASE_INHERITED
(
PannerNode
AudioNode
)
class
PannerNodeEngine
final
:
public
AudioNodeEngine
{
public
:
explicit
PannerNodeEngine
(
AudioNode
*
aNode
AudioDestinationNode
*
aDestination
)
:
AudioNodeEngine
(
aNode
)
mDestination
(
aDestination
-
>
Stream
(
)
)
mPanningModelFunction
(
&
PannerNodeEngine
:
:
EqualPowerPanningFunction
)
mDistanceModelFunction
(
&
PannerNodeEngine
:
:
InverseGainFunction
)
mPositionX
(
0
.
)
mPositionY
(
0
.
)
mPositionZ
(
0
.
)
mOrientationX
(
1
.
)
mOrientationY
(
0
.
)
mOrientationZ
(
0
.
)
mVelocity
(
)
mRefDistance
(
1
.
)
mMaxDistance
(
10000
.
)
mRolloffFactor
(
1
.
)
mConeInnerAngle
(
360
.
)
mConeOuterAngle
(
360
.
)
mConeOuterGain
(
0
.
)
mListenerDopplerFactor
(
0
.
)
mListenerSpeedOfSound
(
0
.
)
mLeftOverData
(
INT_MIN
)
{
}
void
RecvTimelineEvent
(
uint32_t
aIndex
AudioTimelineEvent
&
aEvent
)
override
{
MOZ_ASSERT
(
mDestination
)
;
WebAudioUtils
:
:
ConvertAudioTimelineEventToTicks
(
aEvent
mDestination
)
;
switch
(
aIndex
)
{
case
PannerNode
:
:
POSITIONX
:
mPositionX
.
InsertEvent
<
int64_t
>
(
aEvent
)
;
break
;
case
PannerNode
:
:
POSITIONY
:
mPositionY
.
InsertEvent
<
int64_t
>
(
aEvent
)
;
break
;
case
PannerNode
:
:
POSITIONZ
:
mPositionZ
.
InsertEvent
<
int64_t
>
(
aEvent
)
;
break
;
case
PannerNode
:
:
ORIENTATIONX
:
mOrientationX
.
InsertEvent
<
int64_t
>
(
aEvent
)
;
break
;
case
PannerNode
:
:
ORIENTATIONY
:
mOrientationY
.
InsertEvent
<
int64_t
>
(
aEvent
)
;
break
;
case
PannerNode
:
:
ORIENTATIONZ
:
mOrientationZ
.
InsertEvent
<
int64_t
>
(
aEvent
)
;
break
;
default
:
NS_ERROR
(
"
Bad
PannerNode
TimelineParameter
"
)
;
}
}
void
CreateHRTFPanner
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mHRTFPanner
)
{
return
;
}
already_AddRefed
<
HRTFDatabaseLoader
>
loader
=
HRTFDatabaseLoader
:
:
createAndLoadAsynchronouslyIfNecessary
(
NodeMainThread
(
)
-
>
Context
(
)
-
>
SampleRate
(
)
)
;
mHRTFPanner
=
new
HRTFPanner
(
NodeMainThread
(
)
-
>
Context
(
)
-
>
SampleRate
(
)
Move
(
loader
)
)
;
}
void
SetInt32Parameter
(
uint32_t
aIndex
int32_t
aParam
)
override
{
switch
(
aIndex
)
{
case
PannerNode
:
:
PANNING_MODEL
:
switch
(
PanningModelType
(
aParam
)
)
{
case
PanningModelType
:
:
Equalpower
:
mPanningModelFunction
=
&
PannerNodeEngine
:
:
EqualPowerPanningFunction
;
break
;
case
PanningModelType
:
:
HRTF
:
mPanningModelFunction
=
&
PannerNodeEngine
:
:
HRTFPanningFunction
;
break
;
default
:
NS_NOTREACHED
(
"
We
should
never
see
the
alternate
names
here
"
)
;
break
;
}
break
;
case
PannerNode
:
:
DISTANCE_MODEL
:
switch
(
DistanceModelType
(
aParam
)
)
{
case
DistanceModelType
:
:
Inverse
:
mDistanceModelFunction
=
&
PannerNodeEngine
:
:
InverseGainFunction
;
break
;
case
DistanceModelType
:
:
Linear
:
mDistanceModelFunction
=
&
PannerNodeEngine
:
:
LinearGainFunction
;
break
;
case
DistanceModelType
:
:
Exponential
:
mDistanceModelFunction
=
&
PannerNodeEngine
:
:
ExponentialGainFunction
;
break
;
default
:
NS_NOTREACHED
(
"
We
should
never
see
the
alternate
names
here
"
)
;
break
;
}
break
;
default
:
NS_ERROR
(
"
Bad
PannerNodeEngine
Int32Parameter
"
)
;
}
}
void
SetThreeDPointParameter
(
uint32_t
aIndex
const
ThreeDPoint
&
aParam
)
override
{
switch
(
aIndex
)
{
case
PannerNode
:
:
LISTENER_POSITION
:
mListenerPosition
=
aParam
;
break
;
case
PannerNode
:
:
LISTENER_FRONT_VECTOR
:
mListenerFrontVector
=
aParam
;
break
;
case
PannerNode
:
:
LISTENER_RIGHT_VECTOR
:
mListenerRightVector
=
aParam
;
break
;
case
PannerNode
:
:
LISTENER_VELOCITY
:
mListenerVelocity
=
aParam
;
break
;
case
PannerNode
:
:
POSITION
:
mPositionX
.
SetValue
(
aParam
.
x
)
;
mPositionY
.
SetValue
(
aParam
.
y
)
;
mPositionZ
.
SetValue
(
aParam
.
z
)
;
break
;
case
PannerNode
:
:
ORIENTATION
:
mOrientationX
.
SetValue
(
aParam
.
x
)
;
mOrientationY
.
SetValue
(
aParam
.
y
)
;
mOrientationZ
.
SetValue
(
aParam
.
z
)
;
break
;
case
PannerNode
:
:
VELOCITY
:
mVelocity
=
aParam
;
break
;
default
:
NS_ERROR
(
"
Bad
PannerNodeEngine
ThreeDPointParameter
"
)
;
}
}
void
SetDoubleParameter
(
uint32_t
aIndex
double
aParam
)
override
{
switch
(
aIndex
)
{
case
PannerNode
:
:
LISTENER_DOPPLER_FACTOR
:
mListenerDopplerFactor
=
aParam
;
break
;
case
PannerNode
:
:
LISTENER_SPEED_OF_SOUND
:
mListenerSpeedOfSound
=
aParam
;
break
;
case
PannerNode
:
:
REF_DISTANCE
:
mRefDistance
=
aParam
;
break
;
case
PannerNode
:
:
MAX_DISTANCE
:
mMaxDistance
=
aParam
;
break
;
case
PannerNode
:
:
ROLLOFF_FACTOR
:
mRolloffFactor
=
aParam
;
break
;
case
PannerNode
:
:
CONE_INNER_ANGLE
:
mConeInnerAngle
=
aParam
;
break
;
case
PannerNode
:
:
CONE_OUTER_ANGLE
:
mConeOuterAngle
=
aParam
;
break
;
case
PannerNode
:
:
CONE_OUTER_GAIN
:
mConeOuterGain
=
aParam
;
break
;
default
:
NS_ERROR
(
"
Bad
PannerNodeEngine
DoubleParameter
"
)
;
}
}
void
ProcessBlock
(
AudioNodeStream
*
aStream
GraphTime
aFrom
const
AudioBlock
&
aInput
AudioBlock
*
aOutput
bool
*
aFinished
)
override
{
if
(
aInput
.
IsNull
(
)
)
{
if
(
mLeftOverData
>
0
&
&
mPanningModelFunction
=
=
&
PannerNodeEngine
:
:
HRTFPanningFunction
)
{
mLeftOverData
-
=
WEBAUDIO_BLOCK_SIZE
;
}
else
{
if
(
mLeftOverData
!
=
INT_MIN
)
{
mLeftOverData
=
INT_MIN
;
aStream
-
>
ScheduleCheckForInactive
(
)
;
mHRTFPanner
-
>
reset
(
)
;
RefPtr
<
PlayingRefChangeHandler
>
refchanged
=
new
PlayingRefChangeHandler
(
aStream
PlayingRefChangeHandler
:
:
RELEASE
)
;
aStream
-
>
Graph
(
)
-
>
DispatchToMainThreadAfterStreamStateUpdate
(
refchanged
.
forget
(
)
)
;
}
aOutput
-
>
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
return
;
}
}
else
if
(
mPanningModelFunction
=
=
&
PannerNodeEngine
:
:
HRTFPanningFunction
)
{
if
(
mLeftOverData
=
=
INT_MIN
)
{
RefPtr
<
PlayingRefChangeHandler
>
refchanged
=
new
PlayingRefChangeHandler
(
aStream
PlayingRefChangeHandler
:
:
ADDREF
)
;
aStream
-
>
Graph
(
)
-
>
DispatchToMainThreadAfterStreamStateUpdate
(
refchanged
.
forget
(
)
)
;
}
mLeftOverData
=
mHRTFPanner
-
>
maxTailFrames
(
)
;
}
StreamTime
tick
=
mDestination
-
>
GraphTimeToStreamTime
(
aFrom
)
;
(
this
-
>
*
mPanningModelFunction
)
(
aInput
aOutput
tick
)
;
}
bool
IsActive
(
)
const
override
{
return
mLeftOverData
!
=
INT_MIN
;
}
void
ComputeAzimuthAndElevation
(
const
ThreeDPoint
&
position
float
&
aAzimuth
float
&
aElevation
)
;
float
ComputeConeGain
(
const
ThreeDPoint
&
position
const
ThreeDPoint
&
orientation
)
;
double
ComputeDistanceGain
(
const
ThreeDPoint
&
position
)
;
void
EqualPowerPanningFunction
(
const
AudioBlock
&
aInput
AudioBlock
*
aOutput
StreamTime
tick
)
;
void
HRTFPanningFunction
(
const
AudioBlock
&
aInput
AudioBlock
*
aOutput
StreamTime
tick
)
;
float
LinearGainFunction
(
double
aDistance
)
;
float
InverseGainFunction
(
double
aDistance
)
;
float
ExponentialGainFunction
(
double
aDistance
)
;
ThreeDPoint
ConvertAudioParamTimelineTo3DP
(
AudioParamTimeline
&
aX
AudioParamTimeline
&
aY
AudioParamTimeline
&
aZ
StreamTime
&
tick
)
;
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
size_t
amount
=
AudioNodeEngine
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
if
(
mHRTFPanner
)
{
amount
+
=
mHRTFPanner
-
>
sizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
amount
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
RefPtr
<
AudioNodeStream
>
mDestination
;
nsAutoPtr
<
HRTFPanner
>
mHRTFPanner
;
typedef
void
(
PannerNodeEngine
:
:
*
PanningModelFunction
)
(
const
AudioBlock
&
aInput
AudioBlock
*
aOutput
StreamTime
tick
)
;
PanningModelFunction
mPanningModelFunction
;
typedef
float
(
PannerNodeEngine
:
:
*
DistanceModelFunction
)
(
double
aDistance
)
;
DistanceModelFunction
mDistanceModelFunction
;
AudioParamTimeline
mPositionX
;
AudioParamTimeline
mPositionY
;
AudioParamTimeline
mPositionZ
;
AudioParamTimeline
mOrientationX
;
AudioParamTimeline
mOrientationY
;
AudioParamTimeline
mOrientationZ
;
ThreeDPoint
mVelocity
;
double
mRefDistance
;
double
mMaxDistance
;
double
mRolloffFactor
;
double
mConeInnerAngle
;
double
mConeOuterAngle
;
double
mConeOuterGain
;
ThreeDPoint
mListenerPosition
;
ThreeDPoint
mListenerFrontVector
;
ThreeDPoint
mListenerRightVector
;
ThreeDPoint
mListenerVelocity
;
double
mListenerDopplerFactor
;
double
mListenerSpeedOfSound
;
int
mLeftOverData
;
}
;
PannerNode
:
:
PannerNode
(
AudioContext
*
aContext
)
:
AudioNode
(
aContext
2
ChannelCountMode
:
:
Clamped_max
ChannelInterpretation
:
:
Speakers
)
mPanningModel
(
PanningModelType
:
:
Equalpower
)
mDistanceModel
(
DistanceModelType
:
:
Inverse
)
mPositionX
(
new
AudioParam
(
this
PannerNode
:
:
POSITIONX
this
-
>
NodeType
(
)
0
.
f
)
)
mPositionY
(
new
AudioParam
(
this
PannerNode
:
:
POSITIONY
this
-
>
NodeType
(
)
0
.
f
)
)
mPositionZ
(
new
AudioParam
(
this
PannerNode
:
:
POSITIONZ
this
-
>
NodeType
(
)
0
.
f
)
)
mOrientationX
(
new
AudioParam
(
this
PannerNode
:
:
ORIENTATIONX
this
-
>
NodeType
(
)
1
.
0f
)
)
mOrientationY
(
new
AudioParam
(
this
PannerNode
:
:
ORIENTATIONY
this
-
>
NodeType
(
)
0
.
f
)
)
mOrientationZ
(
new
AudioParam
(
this
PannerNode
:
:
ORIENTATIONZ
this
-
>
NodeType
(
)
0
.
f
)
)
mVelocity
(
)
mRefDistance
(
1
.
)
mMaxDistance
(
10000
.
)
mRolloffFactor
(
1
.
)
mConeInnerAngle
(
360
.
)
mConeOuterAngle
(
360
.
)
mConeOuterGain
(
0
.
)
{
mStream
=
AudioNodeStream
:
:
Create
(
aContext
new
PannerNodeEngine
(
this
aContext
-
>
Destination
(
)
)
AudioNodeStream
:
:
NO_STREAM_FLAGS
aContext
-
>
Graph
(
)
)
;
Context
(
)
-
>
Listener
(
)
-
>
RegisterPannerNode
(
this
)
;
}
PannerNode
:
:
~
PannerNode
(
)
{
if
(
Context
(
)
)
{
Context
(
)
-
>
UnregisterPannerNode
(
this
)
;
}
}
already_AddRefed
<
PannerNode
>
PannerNode
:
:
Create
(
AudioContext
&
aAudioContext
const
PannerOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
aAudioContext
.
CheckClosed
(
aRv
)
)
{
return
nullptr
;
}
RefPtr
<
PannerNode
>
audioNode
=
new
PannerNode
(
&
aAudioContext
)
;
audioNode
-
>
Initialize
(
aOptions
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
audioNode
-
>
SetPanningModel
(
aOptions
.
mPanningModel
)
;
audioNode
-
>
SetDistanceModel
(
aOptions
.
mDistanceModel
)
;
audioNode
-
>
SetPosition
(
aOptions
.
mPositionX
aOptions
.
mPositionY
aOptions
.
mPositionZ
)
;
audioNode
-
>
SetOrientation
(
aOptions
.
mOrientationX
aOptions
.
mOrientationY
aOptions
.
mOrientationZ
)
;
audioNode
-
>
SetRefDistance
(
aOptions
.
mRefDistance
)
;
audioNode
-
>
SetMaxDistance
(
aOptions
.
mMaxDistance
)
;
audioNode
-
>
SetRolloffFactor
(
aOptions
.
mRolloffFactor
)
;
audioNode
-
>
SetConeInnerAngle
(
aOptions
.
mConeInnerAngle
)
;
audioNode
-
>
SetConeOuterAngle
(
aOptions
.
mConeOuterAngle
)
;
audioNode
-
>
SetConeOuterGain
(
aOptions
.
mConeOuterGain
)
;
return
audioNode
.
forget
(
)
;
}
void
PannerNode
:
:
SetPanningModel
(
PanningModelType
aPanningModel
)
{
mPanningModel
=
aPanningModel
;
if
(
mPanningModel
=
=
PanningModelType
:
:
HRTF
)
{
static_cast
<
PannerNodeEngine
*
>
(
mStream
-
>
Engine
(
)
)
-
>
CreateHRTFPanner
(
)
;
}
SendInt32ParameterToStream
(
PANNING_MODEL
int32_t
(
mPanningModel
)
)
;
}
size_t
PannerNode
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
AudioNode
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
mSources
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
size_t
PannerNode
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
JSObject
*
PannerNode
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
PannerNodeBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
PannerNode
:
:
DestroyMediaStream
(
)
{
if
(
Context
(
)
)
{
Context
(
)
-
>
UnregisterPannerNode
(
this
)
;
}
AudioNode
:
:
DestroyMediaStream
(
)
;
}
float
PannerNodeEngine
:
:
LinearGainFunction
(
double
aDistance
)
{
return
1
-
mRolloffFactor
*
(
std
:
:
max
(
std
:
:
min
(
aDistance
mMaxDistance
)
mRefDistance
)
-
mRefDistance
)
/
(
mMaxDistance
-
mRefDistance
)
;
}
float
PannerNodeEngine
:
:
InverseGainFunction
(
double
aDistance
)
{
return
mRefDistance
/
(
mRefDistance
+
mRolloffFactor
*
(
std
:
:
max
(
aDistance
mRefDistance
)
-
mRefDistance
)
)
;
}
float
PannerNodeEngine
:
:
ExponentialGainFunction
(
double
aDistance
)
{
return
pow
(
std
:
:
max
(
aDistance
mRefDistance
)
/
mRefDistance
-
mRolloffFactor
)
;
}
void
PannerNodeEngine
:
:
HRTFPanningFunction
(
const
AudioBlock
&
aInput
AudioBlock
*
aOutput
StreamTime
tick
)
{
aOutput
-
>
AllocateChannels
(
2
)
;
float
azimuth
elevation
;
ThreeDPoint
position
=
ConvertAudioParamTimelineTo3DP
(
mPositionX
mPositionY
mPositionZ
tick
)
;
ThreeDPoint
orientation
=
ConvertAudioParamTimelineTo3DP
(
mOrientationX
mOrientationY
mOrientationZ
tick
)
;
if
(
!
orientation
.
IsZero
(
)
)
{
orientation
.
Normalize
(
)
;
}
ComputeAzimuthAndElevation
(
position
azimuth
elevation
)
;
AudioBlock
input
=
aInput
;
input
.
mVolume
*
=
ComputeConeGain
(
position
orientation
)
*
ComputeDistanceGain
(
position
)
;
mHRTFPanner
-
>
pan
(
azimuth
elevation
&
input
aOutput
)
;
}
ThreeDPoint
PannerNodeEngine
:
:
ConvertAudioParamTimelineTo3DP
(
AudioParamTimeline
&
aX
AudioParamTimeline
&
aY
AudioParamTimeline
&
aZ
StreamTime
&
tick
)
{
return
ThreeDPoint
(
aX
.
GetValueAtTime
(
tick
)
aY
.
GetValueAtTime
(
tick
)
aZ
.
GetValueAtTime
(
tick
)
)
;
}
void
PannerNodeEngine
:
:
EqualPowerPanningFunction
(
const
AudioBlock
&
aInput
AudioBlock
*
aOutput
StreamTime
tick
)
{
float
azimuth
elevation
gainL
gainR
normalizedAzimuth
distanceGain
coneGain
;
int
inputChannels
=
aInput
.
ChannelCount
(
)
;
if
(
mPositionX
.
HasSimpleValue
(
)
&
&
mPositionY
.
HasSimpleValue
(
)
&
&
mPositionZ
.
HasSimpleValue
(
)
&
&
mOrientationX
.
HasSimpleValue
(
)
&
&
mOrientationY
.
HasSimpleValue
(
)
&
&
mOrientationZ
.
HasSimpleValue
(
)
)
{
ThreeDPoint
position
=
ConvertAudioParamTimelineTo3DP
(
mPositionX
mPositionY
mPositionZ
tick
)
;
ThreeDPoint
orientation
=
ConvertAudioParamTimelineTo3DP
(
mOrientationX
mOrientationY
mOrientationZ
tick
)
;
if
(
!
orientation
.
IsZero
(
)
)
{
orientation
.
Normalize
(
)
;
}
if
(
mListenerPosition
=
=
position
&
&
mConeInnerAngle
=
=
360
&
&
mConeOuterAngle
=
=
360
)
{
*
aOutput
=
aInput
;
return
;
}
aOutput
-
>
AllocateChannels
(
2
)
;
ComputeAzimuthAndElevation
(
position
azimuth
elevation
)
;
coneGain
=
ComputeConeGain
(
position
orientation
)
;
azimuth
=
min
(
180
.
f
max
(
-
180
.
f
azimuth
)
)
;
if
(
azimuth
<
-
90
.
f
)
{
azimuth
=
-
180
.
f
-
azimuth
;
}
else
if
(
azimuth
>
90
)
{
azimuth
=
180
.
f
-
azimuth
;
}
if
(
inputChannels
=
=
1
)
{
normalizedAzimuth
=
(
azimuth
+
90
.
f
)
/
180
.
f
;
}
else
{
if
(
azimuth
<
=
0
)
{
normalizedAzimuth
=
(
azimuth
+
90
.
f
)
/
90
.
f
;
}
else
{
normalizedAzimuth
=
azimuth
/
90
.
f
;
}
}
distanceGain
=
ComputeDistanceGain
(
position
)
;
gainL
=
cos
(
0
.
5
*
M_PI
*
normalizedAzimuth
)
;
gainR
=
sin
(
0
.
5
*
M_PI
*
normalizedAzimuth
)
;
ApplyStereoPanning
(
aInput
aOutput
gainL
gainR
azimuth
<
=
0
)
;
aOutput
-
>
mVolume
=
aInput
.
mVolume
*
distanceGain
*
coneGain
;
}
else
{
float
positionX
[
WEBAUDIO_BLOCK_SIZE
]
;
float
positionY
[
WEBAUDIO_BLOCK_SIZE
]
;
float
positionZ
[
WEBAUDIO_BLOCK_SIZE
]
;
float
orientationX
[
WEBAUDIO_BLOCK_SIZE
]
;
float
orientationY
[
WEBAUDIO_BLOCK_SIZE
]
;
float
orientationZ
[
WEBAUDIO_BLOCK_SIZE
]
;
aOutput
-
>
AllocateChannels
(
2
)
;
if
(
!
mPositionX
.
HasSimpleValue
(
)
)
{
mPositionX
.
GetValuesAtTime
(
tick
positionX
WEBAUDIO_BLOCK_SIZE
)
;
}
else
{
positionX
[
0
]
=
mPositionX
.
GetValueAtTime
(
tick
)
;
}
if
(
!
mPositionY
.
HasSimpleValue
(
)
)
{
mPositionY
.
GetValuesAtTime
(
tick
positionY
WEBAUDIO_BLOCK_SIZE
)
;
}
else
{
positionY
[
0
]
=
mPositionY
.
GetValueAtTime
(
tick
)
;
}
if
(
!
mPositionZ
.
HasSimpleValue
(
)
)
{
mPositionZ
.
GetValuesAtTime
(
tick
positionZ
WEBAUDIO_BLOCK_SIZE
)
;
}
else
{
positionZ
[
0
]
=
mPositionZ
.
GetValueAtTime
(
tick
)
;
}
if
(
!
mOrientationX
.
HasSimpleValue
(
)
)
{
mOrientationX
.
GetValuesAtTime
(
tick
orientationX
WEBAUDIO_BLOCK_SIZE
)
;
}
else
{
orientationX
[
0
]
=
mOrientationX
.
GetValueAtTime
(
tick
)
;
}
if
(
!
mOrientationY
.
HasSimpleValue
(
)
)
{
mOrientationY
.
GetValuesAtTime
(
tick
orientationY
WEBAUDIO_BLOCK_SIZE
)
;
}
else
{
orientationY
[
0
]
=
mOrientationY
.
GetValueAtTime
(
tick
)
;
}
if
(
!
mOrientationZ
.
HasSimpleValue
(
)
)
{
mOrientationZ
.
GetValuesAtTime
(
tick
orientationZ
WEBAUDIO_BLOCK_SIZE
)
;
}
else
{
orientationZ
[
0
]
=
mOrientationZ
.
GetValueAtTime
(
tick
)
;
}
float
computedGain
[
2
*
WEBAUDIO_BLOCK_SIZE
+
4
]
;
bool
onLeft
[
WEBAUDIO_BLOCK_SIZE
]
;
float
*
alignedComputedGain
=
ALIGNED16
(
computedGain
)
;
ASSERT_ALIGNED16
(
alignedComputedGain
)
;
for
(
size_t
counter
=
0
;
counter
<
WEBAUDIO_BLOCK_SIZE
;
+
+
counter
)
{
ThreeDPoint
position
(
mPositionX
.
HasSimpleValue
(
)
?
positionX
[
0
]
:
positionX
[
counter
]
mPositionY
.
HasSimpleValue
(
)
?
positionY
[
0
]
:
positionY
[
counter
]
mPositionZ
.
HasSimpleValue
(
)
?
positionZ
[
0
]
:
positionZ
[
counter
]
)
;
ThreeDPoint
orientation
(
mOrientationX
.
HasSimpleValue
(
)
?
orientationX
[
0
]
:
orientationX
[
counter
]
mOrientationY
.
HasSimpleValue
(
)
?
orientationY
[
0
]
:
orientationY
[
counter
]
mOrientationZ
.
HasSimpleValue
(
)
?
orientationZ
[
0
]
:
orientationZ
[
counter
]
)
;
if
(
!
orientation
.
IsZero
(
)
)
{
orientation
.
Normalize
(
)
;
}
ComputeAzimuthAndElevation
(
position
azimuth
elevation
)
;
coneGain
=
ComputeConeGain
(
position
orientation
)
;
azimuth
=
min
(
180
.
f
max
(
-
180
.
f
azimuth
)
)
;
if
(
azimuth
<
-
90
.
f
)
{
azimuth
=
-
180
.
f
-
azimuth
;
}
else
if
(
azimuth
>
90
)
{
azimuth
=
180
.
f
-
azimuth
;
}
if
(
inputChannels
=
=
1
)
{
normalizedAzimuth
=
(
azimuth
+
90
.
f
)
/
180
.
f
;
}
else
{
if
(
azimuth
<
=
0
)
{
normalizedAzimuth
=
(
azimuth
+
90
.
f
)
/
90
.
f
;
}
else
{
normalizedAzimuth
=
azimuth
/
90
.
f
;
}
}
distanceGain
=
ComputeDistanceGain
(
position
)
;
float
gainL
=
cos
(
0
.
5
*
M_PI
*
normalizedAzimuth
)
*
aInput
.
mVolume
*
distanceGain
*
coneGain
;
float
gainR
=
sin
(
0
.
5
*
M_PI
*
normalizedAzimuth
)
*
aInput
.
mVolume
*
distanceGain
*
coneGain
;
alignedComputedGain
[
counter
]
=
gainL
;
alignedComputedGain
[
WEBAUDIO_BLOCK_SIZE
+
counter
]
=
gainR
;
onLeft
[
counter
]
=
azimuth
<
=
0
;
}
ApplyStereoPanning
(
aInput
aOutput
alignedComputedGain
&
alignedComputedGain
[
WEBAUDIO_BLOCK_SIZE
]
onLeft
)
;
}
}
void
PannerNodeEngine
:
:
ComputeAzimuthAndElevation
(
const
ThreeDPoint
&
position
float
&
aAzimuth
float
&
aElevation
)
{
ThreeDPoint
sourceListener
=
position
-
mListenerPosition
;
if
(
sourceListener
.
IsZero
(
)
)
{
aAzimuth
=
0
.
0
;
aElevation
=
0
.
0
;
return
;
}
sourceListener
.
Normalize
(
)
;
const
ThreeDPoint
&
listenerFront
=
mListenerFrontVector
;
const
ThreeDPoint
&
listenerRight
=
mListenerRightVector
;
ThreeDPoint
up
=
listenerRight
.
CrossProduct
(
listenerFront
)
;
double
upProjection
=
sourceListener
.
DotProduct
(
up
)
;
aElevation
=
90
-
180
*
acos
(
upProjection
)
/
M_PI
;
if
(
aElevation
>
90
)
{
aElevation
=
180
-
aElevation
;
}
else
if
(
aElevation
<
-
90
)
{
aElevation
=
-
180
-
aElevation
;
}
ThreeDPoint
projectedSource
=
sourceListener
-
up
*
upProjection
;
if
(
projectedSource
.
IsZero
(
)
)
{
aAzimuth
=
0
.
0
;
return
;
}
projectedSource
.
Normalize
(
)
;
double
projection
=
projectedSource
.
DotProduct
(
listenerRight
)
;
aAzimuth
=
180
*
acos
(
projection
)
/
M_PI
;
double
frontBack
=
projectedSource
.
DotProduct
(
listenerFront
)
;
if
(
frontBack
<
0
)
{
aAzimuth
=
360
-
aAzimuth
;
}
if
(
(
aAzimuth
>
=
0
)
&
&
(
aAzimuth
<
=
270
)
)
{
aAzimuth
=
90
-
aAzimuth
;
}
else
{
aAzimuth
=
450
-
aAzimuth
;
}
}
float
PannerNodeEngine
:
:
ComputeConeGain
(
const
ThreeDPoint
&
position
const
ThreeDPoint
&
orientation
)
{
if
(
orientation
.
IsZero
(
)
|
|
(
(
mConeInnerAngle
=
=
360
)
&
&
(
mConeOuterAngle
=
=
360
)
)
)
{
return
1
;
}
ThreeDPoint
sourceToListener
=
mListenerPosition
-
position
;
sourceToListener
.
Normalize
(
)
;
double
dotProduct
=
sourceToListener
.
DotProduct
(
orientation
)
;
double
angle
=
180
*
acos
(
dotProduct
)
/
M_PI
;
double
absAngle
=
fabs
(
angle
)
;
double
absInnerAngle
=
fabs
(
mConeInnerAngle
)
/
2
;
double
absOuterAngle
=
fabs
(
mConeOuterAngle
)
/
2
;
double
gain
=
1
;
if
(
absAngle
<
=
absInnerAngle
)
{
gain
=
1
;
}
else
if
(
absAngle
>
=
absOuterAngle
)
{
gain
=
mConeOuterGain
;
}
else
{
double
x
=
(
absAngle
-
absInnerAngle
)
/
(
absOuterAngle
-
absInnerAngle
)
;
gain
=
(
1
-
x
)
+
mConeOuterGain
*
x
;
}
return
gain
;
}
double
PannerNodeEngine
:
:
ComputeDistanceGain
(
const
ThreeDPoint
&
position
)
{
ThreeDPoint
distanceVec
=
position
-
mListenerPosition
;
float
distance
=
sqrt
(
distanceVec
.
DotProduct
(
distanceVec
)
)
;
return
std
:
:
max
(
0
.
0f
(
this
-
>
*
mDistanceModelFunction
)
(
distance
)
)
;
}
float
PannerNode
:
:
ComputeDopplerShift
(
)
{
double
dopplerShift
=
1
.
0
;
AudioListener
*
listener
=
Context
(
)
-
>
Listener
(
)
;
if
(
listener
-
>
DopplerFactor
(
)
>
0
)
{
if
(
!
mVelocity
.
IsZero
(
)
|
|
!
listener
-
>
Velocity
(
)
.
IsZero
(
)
)
{
ThreeDPoint
sourceToListener
=
ConvertAudioParamTo3DP
(
mPositionX
mPositionY
mPositionZ
)
-
listener
-
>
Velocity
(
)
;
double
sourceListenerMagnitude
=
sourceToListener
.
Magnitude
(
)
;
double
listenerProjection
=
sourceToListener
.
DotProduct
(
listener
-
>
Velocity
(
)
)
/
sourceListenerMagnitude
;
double
sourceProjection
=
sourceToListener
.
DotProduct
(
mVelocity
)
/
sourceListenerMagnitude
;
listenerProjection
=
-
listenerProjection
;
sourceProjection
=
-
sourceProjection
;
double
scaledSpeedOfSound
=
listener
-
>
SpeedOfSound
(
)
/
listener
-
>
DopplerFactor
(
)
;
listenerProjection
=
min
(
listenerProjection
scaledSpeedOfSound
)
;
sourceProjection
=
min
(
sourceProjection
scaledSpeedOfSound
)
;
dopplerShift
=
(
(
listener
-
>
SpeedOfSound
(
)
-
listener
-
>
DopplerFactor
(
)
*
listenerProjection
)
/
(
listener
-
>
SpeedOfSound
(
)
-
listener
-
>
DopplerFactor
(
)
*
sourceProjection
)
)
;
WebAudioUtils
:
:
FixNaN
(
dopplerShift
)
;
dopplerShift
=
min
(
dopplerShift
16
.
)
;
dopplerShift
=
max
(
dopplerShift
0
.
125
)
;
}
}
return
dopplerShift
;
}
void
PannerNode
:
:
FindConnectedSources
(
)
{
mSources
.
Clear
(
)
;
std
:
:
set
<
AudioNode
*
>
cycleSet
;
FindConnectedSources
(
this
mSources
cycleSet
)
;
}
void
PannerNode
:
:
FindConnectedSources
(
AudioNode
*
aNode
nsTArray
<
AudioBufferSourceNode
*
>
&
aSources
std
:
:
set
<
AudioNode
*
>
&
aNodesSeen
)
{
if
(
!
aNode
)
{
return
;
}
const
nsTArray
<
InputNode
>
&
inputNodes
=
aNode
-
>
InputNodes
(
)
;
for
(
unsigned
i
=
0
;
i
<
inputNodes
.
Length
(
)
;
i
+
+
)
{
if
(
aNodesSeen
.
find
(
inputNodes
[
i
]
.
mInputNode
)
!
=
aNodesSeen
.
end
(
)
)
{
return
;
}
aNodesSeen
.
insert
(
inputNodes
[
i
]
.
mInputNode
)
;
FindConnectedSources
(
inputNodes
[
i
]
.
mInputNode
aSources
aNodesSeen
)
;
AudioBufferSourceNode
*
node
=
inputNodes
[
i
]
.
mInputNode
-
>
AsAudioBufferSourceNode
(
)
;
if
(
node
&
&
node
-
>
GetStream
(
)
)
{
aSources
.
AppendElement
(
node
)
;
}
}
}
void
PannerNode
:
:
SendDopplerToSourcesIfNeeded
(
)
{
if
(
!
(
Context
(
)
-
>
Listener
(
)
-
>
Velocity
(
)
.
IsZero
(
)
&
&
mVelocity
.
IsZero
(
)
)
)
{
for
(
uint32_t
i
=
0
;
i
<
mSources
.
Length
(
)
;
i
+
+
)
{
mSources
[
i
]
-
>
SendDopplerShiftToStream
(
ComputeDopplerShift
(
)
)
;
}
}
}
}
}
