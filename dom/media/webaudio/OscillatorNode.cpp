#
include
"
OscillatorNode
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeStream
.
h
"
#
include
"
AudioDestinationNode
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
WebAudioUtils
.
h
"
#
include
"
blink
/
PeriodicWave
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
OscillatorNode
AudioScheduledSourceNode
mPeriodicWave
mFrequency
mDetune
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
OscillatorNode
)
NS_INTERFACE_MAP_END_INHERITING
(
AudioScheduledSourceNode
)
NS_IMPL_ADDREF_INHERITED
(
OscillatorNode
AudioScheduledSourceNode
)
NS_IMPL_RELEASE_INHERITED
(
OscillatorNode
AudioScheduledSourceNode
)
class
OscillatorNodeEngine
final
:
public
AudioNodeEngine
{
public
:
OscillatorNodeEngine
(
AudioNode
*
aNode
AudioDestinationNode
*
aDestination
)
:
AudioNodeEngine
(
aNode
)
mSource
(
nullptr
)
mDestination
(
aDestination
-
>
Stream
(
)
)
mStart
(
-
1
)
mStop
(
STREAM_TIME_MAX
)
mFrequency
(
440
.
f
)
mDetune
(
0
.
f
)
mType
(
OscillatorType
:
:
Sine
)
mPhase
(
0
.
)
mFinalFrequency
(
0
.
)
mPhaseIncrement
(
0
.
)
mRecomputeParameters
(
true
)
mCustomDisableNormalization
(
false
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mBasicWaveFormCache
=
aDestination
-
>
Context
(
)
-
>
GetBasicWaveFormCache
(
)
;
}
void
SetSourceStream
(
AudioNodeStream
*
aSource
)
{
mSource
=
aSource
;
}
enum
Parameters
{
FREQUENCY
DETUNE
TYPE
DISABLE_NORMALIZATION
START
STOP
}
;
void
RecvTimelineEvent
(
uint32_t
aIndex
AudioTimelineEvent
&
aEvent
)
override
{
mRecomputeParameters
=
true
;
MOZ_ASSERT
(
mDestination
)
;
WebAudioUtils
:
:
ConvertAudioTimelineEventToTicks
(
aEvent
mDestination
)
;
switch
(
aIndex
)
{
case
FREQUENCY
:
mFrequency
.
InsertEvent
<
int64_t
>
(
aEvent
)
;
break
;
case
DETUNE
:
mDetune
.
InsertEvent
<
int64_t
>
(
aEvent
)
;
break
;
default
:
NS_ERROR
(
"
Bad
OscillatorNodeEngine
TimelineParameter
"
)
;
}
}
void
SetStreamTimeParameter
(
uint32_t
aIndex
StreamTime
aParam
)
override
{
switch
(
aIndex
)
{
case
START
:
mStart
=
aParam
;
mSource
-
>
SetActive
(
)
;
break
;
case
STOP
:
mStop
=
aParam
;
break
;
default
:
NS_ERROR
(
"
Bad
OscillatorNodeEngine
StreamTimeParameter
"
)
;
}
}
void
SetInt32Parameter
(
uint32_t
aIndex
int32_t
aParam
)
override
{
switch
(
aIndex
)
{
case
TYPE
:
mType
=
static_cast
<
OscillatorType
>
(
aParam
)
;
if
(
mType
=
=
OscillatorType
:
:
Sine
)
{
mCustomDisableNormalization
=
false
;
mPeriodicWave
=
nullptr
;
mRecomputeParameters
=
true
;
}
switch
(
mType
)
{
case
OscillatorType
:
:
Sine
:
mPhase
=
0
.
0
;
break
;
case
OscillatorType
:
:
Square
:
case
OscillatorType
:
:
Triangle
:
case
OscillatorType
:
:
Sawtooth
:
mPeriodicWave
=
mBasicWaveFormCache
-
>
GetBasicWaveForm
(
mType
)
;
break
;
case
OscillatorType
:
:
Custom
:
break
;
default
:
NS_ERROR
(
"
Bad
OscillatorNodeEngine
type
parameter
.
"
)
;
}
break
;
case
DISABLE_NORMALIZATION
:
MOZ_ASSERT
(
aParam
>
=
0
"
negative
custom
array
length
"
)
;
mCustomDisableNormalization
=
static_cast
<
uint32_t
>
(
aParam
)
;
break
;
default
:
NS_ERROR
(
"
Bad
OscillatorNodeEngine
Int32Parameter
.
"
)
;
}
}
void
SetBuffer
(
AudioChunk
&
&
aBuffer
)
override
{
MOZ_ASSERT
(
aBuffer
.
ChannelCount
(
)
=
=
2
"
PeriodicWave
should
have
sent
two
channels
"
)
;
MOZ_ASSERT
(
aBuffer
.
mVolume
=
=
1
.
0f
)
;
mPeriodicWave
=
WebCore
:
:
PeriodicWave
:
:
create
(
mSource
-
>
SampleRate
(
)
aBuffer
.
ChannelData
<
float
>
(
)
[
0
]
aBuffer
.
ChannelData
<
float
>
(
)
[
1
]
aBuffer
.
mDuration
mCustomDisableNormalization
)
;
}
void
IncrementPhase
(
)
{
const
float
twoPiFloat
=
float
(
2
*
M_PI
)
;
mPhase
+
=
mPhaseIncrement
;
if
(
mPhase
>
twoPiFloat
)
{
mPhase
-
=
twoPiFloat
;
}
else
if
(
mPhase
<
-
twoPiFloat
)
{
mPhase
+
=
twoPiFloat
;
}
}
bool
UpdateParametersIfNeeded
(
StreamTime
ticks
size_t
count
)
{
double
frequency
detune
;
if
(
!
ParametersMayNeedUpdate
(
)
)
{
return
false
;
}
bool
simpleFrequency
=
mFrequency
.
HasSimpleValue
(
)
;
bool
simpleDetune
=
mDetune
.
HasSimpleValue
(
)
;
if
(
simpleFrequency
)
{
frequency
=
mFrequency
.
GetValue
(
)
;
}
else
{
frequency
=
mFrequency
.
GetValueAtTime
(
ticks
count
)
;
}
if
(
simpleDetune
)
{
detune
=
mDetune
.
GetValue
(
)
;
}
else
{
detune
=
mDetune
.
GetValueAtTime
(
ticks
count
)
;
}
float
finalFrequency
=
frequency
*
exp2
(
detune
/
1200
.
)
;
float
signalPeriod
=
mSource
-
>
SampleRate
(
)
/
finalFrequency
;
mRecomputeParameters
=
false
;
mPhaseIncrement
=
2
*
M_PI
/
signalPeriod
;
if
(
finalFrequency
!
=
mFinalFrequency
)
{
mFinalFrequency
=
finalFrequency
;
return
true
;
}
return
false
;
}
void
FillBounds
(
float
*
output
StreamTime
ticks
uint32_t
&
start
uint32_t
&
end
)
{
MOZ_ASSERT
(
output
)
;
static_assert
(
StreamTime
(
WEBAUDIO_BLOCK_SIZE
)
<
UINT_MAX
"
WEBAUDIO_BLOCK_SIZE
overflows
interator
bounds
.
"
)
;
start
=
0
;
if
(
ticks
<
mStart
)
{
start
=
mStart
-
ticks
;
for
(
uint32_t
i
=
0
;
i
<
start
;
+
+
i
)
{
output
[
i
]
=
0
.
0
;
}
}
end
=
WEBAUDIO_BLOCK_SIZE
;
if
(
ticks
+
end
>
mStop
)
{
end
=
mStop
-
ticks
;
for
(
uint32_t
i
=
end
;
i
<
WEBAUDIO_BLOCK_SIZE
;
+
+
i
)
{
output
[
i
]
=
0
.
0
;
}
}
}
void
ComputeSine
(
float
*
aOutput
StreamTime
ticks
uint32_t
aStart
uint32_t
aEnd
)
{
for
(
uint32_t
i
=
aStart
;
i
<
aEnd
;
+
+
i
)
{
UpdateParametersIfNeeded
(
ticks
i
)
;
aOutput
[
i
]
=
sin
(
mPhase
)
;
IncrementPhase
(
)
;
}
}
bool
ParametersMayNeedUpdate
(
)
{
return
!
mDetune
.
HasSimpleValue
(
)
|
|
!
mFrequency
.
HasSimpleValue
(
)
|
|
mRecomputeParameters
;
}
void
ComputeCustom
(
float
*
aOutput
StreamTime
ticks
uint32_t
aStart
uint32_t
aEnd
)
{
MOZ_ASSERT
(
mPeriodicWave
"
No
custom
waveform
data
"
)
;
uint32_t
periodicWaveSize
=
mPeriodicWave
-
>
periodicWaveSize
(
)
;
uint32_t
indexMask
=
periodicWaveSize
-
1
;
MOZ_ASSERT
(
periodicWaveSize
&
&
(
periodicWaveSize
&
indexMask
)
=
=
0
"
periodicWaveSize
must
be
power
of
2
"
)
;
float
*
higherWaveData
=
nullptr
;
float
*
lowerWaveData
=
nullptr
;
float
tableInterpolationFactor
;
float
basePhaseIncrement
=
mPeriodicWave
-
>
rateScale
(
)
;
bool
needToFetchWaveData
=
UpdateParametersIfNeeded
(
ticks
aStart
)
;
bool
parametersMayNeedUpdate
=
ParametersMayNeedUpdate
(
)
;
mPeriodicWave
-
>
waveDataForFundamentalFrequency
(
mFinalFrequency
lowerWaveData
higherWaveData
tableInterpolationFactor
)
;
for
(
uint32_t
i
=
aStart
;
i
<
aEnd
;
+
+
i
)
{
if
(
parametersMayNeedUpdate
)
{
if
(
needToFetchWaveData
)
{
mPeriodicWave
-
>
waveDataForFundamentalFrequency
(
mFinalFrequency
lowerWaveData
higherWaveData
tableInterpolationFactor
)
;
}
needToFetchWaveData
=
UpdateParametersIfNeeded
(
ticks
i
)
;
}
float
floorPhase
=
floorf
(
mPhase
)
;
int
j1Signed
=
static_cast
<
int
>
(
floorPhase
)
;
uint32_t
j1
=
j1Signed
&
indexMask
;
uint32_t
j2
=
j1
+
1
;
j2
&
=
indexMask
;
float
sampleInterpolationFactor
=
mPhase
-
floorPhase
;
float
lower
=
(
1
.
0f
-
sampleInterpolationFactor
)
*
lowerWaveData
[
j1
]
+
sampleInterpolationFactor
*
lowerWaveData
[
j2
]
;
float
higher
=
(
1
.
0f
-
sampleInterpolationFactor
)
*
higherWaveData
[
j1
]
+
sampleInterpolationFactor
*
higherWaveData
[
j2
]
;
aOutput
[
i
]
=
(
1
.
0f
-
tableInterpolationFactor
)
*
lower
+
tableInterpolationFactor
*
higher
;
mPhase
=
j1
+
sampleInterpolationFactor
+
basePhaseIncrement
*
mFinalFrequency
;
}
}
void
ComputeSilence
(
AudioBlock
*
aOutput
)
{
aOutput
-
>
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
}
void
ProcessBlock
(
AudioNodeStream
*
aStream
GraphTime
aFrom
const
AudioBlock
&
aInput
AudioBlock
*
aOutput
bool
*
aFinished
)
override
{
MOZ_ASSERT
(
mSource
=
=
aStream
"
Invalid
source
stream
"
)
;
StreamTime
ticks
=
mDestination
-
>
GraphTimeToStreamTime
(
aFrom
)
;
if
(
mStart
=
=
-
1
)
{
ComputeSilence
(
aOutput
)
;
return
;
}
if
(
ticks
+
WEBAUDIO_BLOCK_SIZE
<
=
mStart
|
|
ticks
>
=
mStop
)
{
ComputeSilence
(
aOutput
)
;
}
else
{
aOutput
-
>
AllocateChannels
(
1
)
;
float
*
output
=
aOutput
-
>
ChannelFloatsForWrite
(
0
)
;
uint32_t
start
end
;
FillBounds
(
output
ticks
start
end
)
;
switch
(
mType
)
{
case
OscillatorType
:
:
Sine
:
ComputeSine
(
output
ticks
start
end
)
;
break
;
case
OscillatorType
:
:
Square
:
case
OscillatorType
:
:
Triangle
:
case
OscillatorType
:
:
Sawtooth
:
case
OscillatorType
:
:
Custom
:
ComputeCustom
(
output
ticks
start
end
)
;
break
;
default
:
ComputeSilence
(
aOutput
)
;
}
;
}
if
(
ticks
+
WEBAUDIO_BLOCK_SIZE
>
=
mStop
)
{
*
aFinished
=
true
;
}
}
bool
IsActive
(
)
const
override
{
return
mStart
!
=
-
1
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
size_t
amount
=
AudioNodeEngine
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
if
(
mPeriodicWave
)
{
amount
+
=
mPeriodicWave
-
>
sizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
amount
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
AudioNodeStream
*
MOZ_NON_OWNING_REF
mSource
;
RefPtr
<
AudioNodeStream
>
mDestination
;
StreamTime
mStart
;
StreamTime
mStop
;
AudioParamTimeline
mFrequency
;
AudioParamTimeline
mDetune
;
OscillatorType
mType
;
float
mPhase
;
float
mFinalFrequency
;
float
mPhaseIncrement
;
bool
mRecomputeParameters
;
RefPtr
<
BasicWaveFormCache
>
mBasicWaveFormCache
;
bool
mCustomDisableNormalization
;
RefPtr
<
WebCore
:
:
PeriodicWave
>
mPeriodicWave
;
}
;
OscillatorNode
:
:
OscillatorNode
(
AudioContext
*
aContext
)
:
AudioScheduledSourceNode
(
aContext
2
ChannelCountMode
:
:
Max
ChannelInterpretation
:
:
Speakers
)
mType
(
OscillatorType
:
:
Sine
)
mFrequency
(
new
AudioParam
(
this
OscillatorNodeEngine
:
:
FREQUENCY
"
frequency
"
440
.
0f
-
(
aContext
-
>
SampleRate
(
)
/
2
)
aContext
-
>
SampleRate
(
)
/
2
)
)
mDetune
(
new
AudioParam
(
this
OscillatorNodeEngine
:
:
DETUNE
"
detune
"
0
.
0f
)
)
mStartCalled
(
false
)
{
OscillatorNodeEngine
*
engine
=
new
OscillatorNodeEngine
(
this
aContext
-
>
Destination
(
)
)
;
mStream
=
AudioNodeStream
:
:
Create
(
aContext
engine
AudioNodeStream
:
:
NEED_MAIN_THREAD_FINISHED
aContext
-
>
Graph
(
)
)
;
engine
-
>
SetSourceStream
(
mStream
)
;
mStream
-
>
AddMainThreadListener
(
this
)
;
}
already_AddRefed
<
OscillatorNode
>
OscillatorNode
:
:
Create
(
AudioContext
&
aAudioContext
const
OscillatorOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
aAudioContext
.
CheckClosed
(
aRv
)
)
{
return
nullptr
;
}
RefPtr
<
OscillatorNode
>
audioNode
=
new
OscillatorNode
(
&
aAudioContext
)
;
audioNode
-
>
Initialize
(
aOptions
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
audioNode
-
>
SetType
(
aOptions
.
mType
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
audioNode
-
>
Frequency
(
)
-
>
SetValue
(
aOptions
.
mFrequency
)
;
audioNode
-
>
Detune
(
)
-
>
SetValue
(
aOptions
.
mDetune
)
;
if
(
aOptions
.
mPeriodicWave
.
WasPassed
(
)
)
{
audioNode
-
>
SetPeriodicWave
(
aOptions
.
mPeriodicWave
.
Value
(
)
)
;
}
return
audioNode
.
forget
(
)
;
}
size_t
OscillatorNode
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
AudioNode
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
if
(
mPeriodicWave
)
{
amount
+
=
mPeriodicWave
-
>
SizeOfIncludingThisIfNotShared
(
aMallocSizeOf
)
;
}
amount
+
=
mFrequency
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
amount
+
=
mDetune
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
size_t
OscillatorNode
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
JSObject
*
OscillatorNode
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
OscillatorNode_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
OscillatorNode
:
:
DestroyMediaStream
(
)
{
if
(
mStream
)
{
mStream
-
>
RemoveMainThreadListener
(
this
)
;
}
AudioNode
:
:
DestroyMediaStream
(
)
;
}
void
OscillatorNode
:
:
SendTypeToStream
(
)
{
if
(
!
mStream
)
{
return
;
}
if
(
mType
=
=
OscillatorType
:
:
Custom
)
{
SendPeriodicWaveToStream
(
)
;
}
SendInt32ParameterToStream
(
OscillatorNodeEngine
:
:
TYPE
static_cast
<
int32_t
>
(
mType
)
)
;
}
void
OscillatorNode
:
:
SendPeriodicWaveToStream
(
)
{
NS_ASSERTION
(
mType
=
=
OscillatorType
:
:
Custom
"
Sending
custom
waveform
to
engine
thread
with
non
-
custom
type
"
)
;
MOZ_ASSERT
(
mStream
"
Missing
node
stream
.
"
)
;
MOZ_ASSERT
(
mPeriodicWave
"
Send
called
without
PeriodicWave
object
.
"
)
;
SendInt32ParameterToStream
(
OscillatorNodeEngine
:
:
DISABLE_NORMALIZATION
mPeriodicWave
-
>
DisableNormalization
(
)
)
;
AudioChunk
data
=
mPeriodicWave
-
>
GetThreadSharedBuffer
(
)
;
mStream
-
>
SetBuffer
(
std
:
:
move
(
data
)
)
;
}
void
OscillatorNode
:
:
Start
(
double
aWhen
ErrorResult
&
aRv
)
{
if
(
!
WebAudioUtils
:
:
IsTimeValid
(
aWhen
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
if
(
mStartCalled
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
mStartCalled
=
true
;
if
(
!
mStream
)
{
return
;
}
mStream
-
>
SetStreamTimeParameter
(
OscillatorNodeEngine
:
:
START
Context
(
)
aWhen
)
;
MarkActive
(
)
;
Context
(
)
-
>
StartBlockedAudioContextIfAllowed
(
)
;
}
void
OscillatorNode
:
:
Stop
(
double
aWhen
ErrorResult
&
aRv
)
{
if
(
!
WebAudioUtils
:
:
IsTimeValid
(
aWhen
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
if
(
!
mStartCalled
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
!
mStream
|
|
!
Context
(
)
)
{
return
;
}
mStream
-
>
SetStreamTimeParameter
(
OscillatorNodeEngine
:
:
STOP
Context
(
)
std
:
:
max
(
0
.
0
aWhen
)
)
;
}
void
OscillatorNode
:
:
NotifyMainThreadStreamFinished
(
)
{
MOZ_ASSERT
(
mStream
-
>
IsFinished
(
)
)
;
class
EndedEventDispatcher
final
:
public
Runnable
{
public
:
explicit
EndedEventDispatcher
(
OscillatorNode
*
aNode
)
:
mozilla
:
:
Runnable
(
"
EndedEventDispatcher
"
)
mNode
(
aNode
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
this
)
;
return
NS_OK
;
}
mNode
-
>
DispatchTrustedEvent
(
NS_LITERAL_STRING
(
"
ended
"
)
)
;
mNode
-
>
DestroyMediaStream
(
)
;
return
NS_OK
;
}
private
:
RefPtr
<
OscillatorNode
>
mNode
;
}
;
Context
(
)
-
>
Dispatch
(
do_AddRef
(
new
EndedEventDispatcher
(
this
)
)
)
;
MarkInactive
(
)
;
}
}
}
