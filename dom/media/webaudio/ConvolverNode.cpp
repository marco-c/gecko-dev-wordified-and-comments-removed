#
include
"
ConvolverNode
.
h
"
#
include
"
mozilla
/
dom
/
ConvolverNodeBinding
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
AlignmentUtils
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeStream
.
h
"
#
include
"
blink
/
Reverb
.
h
"
#
include
"
PlayingRefChangeHandler
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
ConvolverNode
AudioNode
mBuffer
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ConvolverNode
)
NS_INTERFACE_MAP_END_INHERITING
(
AudioNode
)
NS_IMPL_ADDREF_INHERITED
(
ConvolverNode
AudioNode
)
NS_IMPL_RELEASE_INHERITED
(
ConvolverNode
AudioNode
)
class
ConvolverNodeEngine
final
:
public
AudioNodeEngine
{
typedef
PlayingRefChangeHandler
PlayingRefChanged
;
public
:
ConvolverNodeEngine
(
AudioNode
*
aNode
bool
aNormalize
uint64_t
aWindowID
)
:
AudioNodeEngine
(
aNode
)
mWindowID
(
aWindowID
)
mUseBackgroundThreads
(
!
aNode
-
>
Context
(
)
-
>
IsOffline
(
)
)
mNormalize
(
aNormalize
)
{
}
enum
class
RightConvolverMode
{
Always
Direct
Difference
}
;
enum
Parameters
{
SAMPLE_RATE
NORMALIZE
}
;
void
SetInt32Parameter
(
uint32_t
aIndex
int32_t
aParam
)
override
{
switch
(
aIndex
)
{
case
NORMALIZE
:
mNormalize
=
!
!
aParam
;
break
;
default
:
NS_ERROR
(
"
Bad
ConvolverNodeEngine
Int32Parameter
"
)
;
}
}
void
SetDoubleParameter
(
uint32_t
aIndex
double
aParam
)
override
{
switch
(
aIndex
)
{
case
SAMPLE_RATE
:
mSampleRate
=
aParam
;
break
;
default
:
NS_ERROR
(
"
Bad
ConvolverNodeEngine
DoubleParameter
"
)
;
}
}
void
SetBuffer
(
AudioChunk
&
&
aBuffer
)
override
{
const
size_t
MaxFFTSize
=
32768
;
mRemainingLeftOutput
=
INT32_MIN
;
mRemainingRightOutput
=
0
;
mRemainingRightHistory
=
0
;
if
(
aBuffer
.
IsNull
(
)
|
|
!
mSampleRate
)
{
mReverb
=
nullptr
;
return
;
}
mRightConvolverMode
=
aBuffer
.
ChannelCount
(
)
=
=
1
?
RightConvolverMode
:
:
Direct
:
RightConvolverMode
:
:
Always
;
bool
allocationFailure
=
false
;
mReverb
=
new
WebCore
:
:
Reverb
(
aBuffer
MaxFFTSize
mUseBackgroundThreads
mNormalize
mSampleRate
&
allocationFailure
)
;
if
(
allocationFailure
)
{
mReverb
=
nullptr
;
WebAudioUtils
:
:
LogToDeveloperConsole
(
mWindowID
"
ConvolverNodeAllocationError
"
)
;
}
}
void
AllocateReverbInput
(
const
AudioBlock
&
aInput
uint32_t
aTotalChannelCount
)
{
uint32_t
inputChannelCount
=
aInput
.
ChannelCount
(
)
;
MOZ_ASSERT
(
inputChannelCount
<
=
aTotalChannelCount
)
;
mReverbInput
.
AllocateChannels
(
aTotalChannelCount
)
;
for
(
uint32_t
i
=
0
;
i
<
inputChannelCount
;
+
+
i
)
{
const
float
*
src
=
static_cast
<
const
float
*
>
(
aInput
.
mChannelData
[
i
]
)
;
float
*
dest
=
mReverbInput
.
ChannelFloatsForWrite
(
i
)
;
AudioBlockCopyChannelWithScale
(
src
aInput
.
mVolume
dest
)
;
}
for
(
uint32_t
i
=
inputChannelCount
;
i
<
aTotalChannelCount
;
+
+
i
)
{
float
*
dest
=
mReverbInput
.
ChannelFloatsForWrite
(
i
)
;
std
:
:
fill_n
(
dest
WEBAUDIO_BLOCK_SIZE
0
.
0f
)
;
}
}
void
ProcessBlock
(
AudioNodeStream
*
aStream
GraphTime
aFrom
const
AudioBlock
&
aInput
AudioBlock
*
aOutput
bool
*
aFinished
)
override
;
bool
IsActive
(
)
const
override
{
return
mRemainingLeftOutput
!
=
INT32_MIN
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
size_t
amount
=
AudioNodeEngine
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
mReverbInput
.
SizeOfExcludingThis
(
aMallocSizeOf
false
)
;
if
(
mReverb
)
{
amount
+
=
mReverb
-
>
sizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
amount
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
private
:
AudioBlock
mReverbInput
;
nsAutoPtr
<
WebCore
:
:
Reverb
>
mReverb
;
uint64_t
mWindowID
;
int32_t
mRemainingLeftOutput
=
INT32_MIN
;
int32_t
mRemainingRightOutput
=
0
;
int32_t
mRemainingRightHistory
=
0
;
float
mSampleRate
=
0
.
0f
;
RightConvolverMode
mRightConvolverMode
=
RightConvolverMode
:
:
Always
;
bool
mUseBackgroundThreads
;
bool
mNormalize
;
}
;
static
void
AddScaledLeftToRight
(
AudioBlock
*
aBlock
float
aScale
)
{
const
float
*
left
=
static_cast
<
const
float
*
>
(
aBlock
-
>
mChannelData
[
0
]
)
;
float
*
right
=
aBlock
-
>
ChannelFloatsForWrite
(
1
)
;
AudioBlockAddChannelWithScale
(
left
aScale
right
)
;
}
void
ConvolverNodeEngine
:
:
ProcessBlock
(
AudioNodeStream
*
aStream
GraphTime
aFrom
const
AudioBlock
&
aInput
AudioBlock
*
aOutput
bool
*
aFinished
)
{
if
(
!
mReverb
)
{
aOutput
-
>
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
return
;
}
uint32_t
inputChannelCount
=
aInput
.
ChannelCount
(
)
;
if
(
aInput
.
IsNull
(
)
)
{
if
(
mRemainingLeftOutput
>
0
)
{
mRemainingLeftOutput
-
=
WEBAUDIO_BLOCK_SIZE
;
AllocateReverbInput
(
aInput
1
)
;
}
else
{
if
(
mRemainingLeftOutput
!
=
INT32_MIN
)
{
mRemainingLeftOutput
=
INT32_MIN
;
MOZ_ASSERT
(
mRemainingRightOutput
<
=
0
)
;
MOZ_ASSERT
(
mRemainingRightHistory
<
=
0
)
;
aStream
-
>
ScheduleCheckForInactive
(
)
;
RefPtr
<
PlayingRefChanged
>
refchanged
=
new
PlayingRefChanged
(
aStream
PlayingRefChanged
:
:
RELEASE
)
;
aStream
-
>
Graph
(
)
-
>
DispatchToMainThreadStableState
(
refchanged
.
forget
(
)
)
;
}
aOutput
-
>
SetNull
(
WEBAUDIO_BLOCK_SIZE
)
;
return
;
}
}
else
{
if
(
mRemainingLeftOutput
<
=
0
)
{
RefPtr
<
PlayingRefChanged
>
refchanged
=
new
PlayingRefChanged
(
aStream
PlayingRefChanged
:
:
ADDREF
)
;
aStream
-
>
Graph
(
)
-
>
DispatchToMainThreadStableState
(
refchanged
.
forget
(
)
)
;
}
mReverbInput
.
mVolume
=
0
.
0f
;
if
(
mRightConvolverMode
!
=
RightConvolverMode
:
:
Always
)
{
ChannelInterpretation
channelInterpretation
=
aStream
-
>
GetChannelInterpretation
(
)
;
if
(
inputChannelCount
=
=
2
)
{
if
(
mRemainingRightHistory
<
=
0
)
{
mRightConvolverMode
=
(
mRemainingLeftOutput
<
=
0
|
|
channelInterpretation
=
=
ChannelInterpretation
:
:
Discrete
)
?
RightConvolverMode
:
:
Direct
:
RightConvolverMode
:
:
Difference
;
}
mRemainingRightOutput
=
mReverb
-
>
impulseResponseLength
(
)
+
WEBAUDIO_BLOCK_SIZE
;
mRemainingRightHistory
=
mRemainingRightOutput
;
if
(
mRightConvolverMode
=
=
RightConvolverMode
:
:
Difference
)
{
AllocateReverbInput
(
aInput
2
)
;
AddScaledLeftToRight
(
&
mReverbInput
-
1
.
0f
)
;
}
}
else
if
(
mRemainingRightHistory
>
0
)
{
if
(
(
mRightConvolverMode
=
=
RightConvolverMode
:
:
Difference
)
^
(
channelInterpretation
=
=
ChannelInterpretation
:
:
Discrete
)
)
{
MOZ_ASSERT
(
(
mRightConvolverMode
=
=
RightConvolverMode
:
:
Difference
&
&
channelInterpretation
=
=
ChannelInterpretation
:
:
Speakers
)
|
|
(
mRightConvolverMode
=
=
RightConvolverMode
:
:
Direct
&
&
channelInterpretation
=
=
ChannelInterpretation
:
:
Discrete
)
)
;
AllocateReverbInput
(
aInput
2
)
;
}
else
{
if
(
channelInterpretation
=
=
ChannelInterpretation
:
:
Discrete
)
{
MOZ_ASSERT
(
mRightConvolverMode
=
=
RightConvolverMode
:
:
Difference
)
;
AllocateReverbInput
(
aInput
2
)
;
AddScaledLeftToRight
(
&
mReverbInput
-
1
.
0f
)
;
}
else
{
MOZ_ASSERT
(
channelInterpretation
=
=
ChannelInterpretation
:
:
Speakers
)
;
MOZ_ASSERT
(
mRightConvolverMode
=
=
RightConvolverMode
:
:
Direct
)
;
}
mRemainingRightHistory
=
mReverb
-
>
impulseResponseLength
(
)
+
WEBAUDIO_BLOCK_SIZE
;
}
}
}
if
(
mReverbInput
.
mVolume
=
=
0
.
0f
)
{
if
(
aInput
.
mVolume
!
=
1
.
0f
)
{
AllocateReverbInput
(
aInput
inputChannelCount
)
;
}
else
{
mReverbInput
=
aInput
;
}
}
mRemainingLeftOutput
=
mReverb
-
>
impulseResponseLength
(
)
;
MOZ_ASSERT
(
mRemainingLeftOutput
>
0
)
;
}
uint32_t
outputChannelCount
=
2
;
uint32_t
reverbOutputChannelCount
=
2
;
if
(
mRightConvolverMode
!
=
RightConvolverMode
:
:
Always
)
{
if
(
mRemainingRightOutput
>
0
)
{
MOZ_ASSERT
(
mRemainingRightHistory
>
0
)
;
mRemainingRightOutput
-
=
WEBAUDIO_BLOCK_SIZE
;
}
else
{
outputChannelCount
=
1
;
}
if
(
mRemainingRightHistory
>
0
)
{
mRemainingRightHistory
-
=
WEBAUDIO_BLOCK_SIZE
;
}
else
{
reverbOutputChannelCount
=
1
;
}
}
aOutput
-
>
AllocateChannels
(
reverbOutputChannelCount
)
;
mReverb
-
>
process
(
&
mReverbInput
aOutput
)
;
if
(
mRightConvolverMode
=
=
RightConvolverMode
:
:
Difference
&
&
outputChannelCount
=
=
2
)
{
AddScaledLeftToRight
(
aOutput
1
.
0f
)
;
}
else
{
aOutput
-
>
mChannelData
.
TruncateLength
(
outputChannelCount
)
;
}
}
ConvolverNode
:
:
ConvolverNode
(
AudioContext
*
aContext
)
:
AudioNode
(
aContext
2
ChannelCountMode
:
:
Clamped_max
ChannelInterpretation
:
:
Speakers
)
mNormalize
(
true
)
{
uint64_t
windowID
=
aContext
-
>
GetParentObject
(
)
-
>
WindowID
(
)
;
ConvolverNodeEngine
*
engine
=
new
ConvolverNodeEngine
(
this
mNormalize
windowID
)
;
mStream
=
AudioNodeStream
:
:
Create
(
aContext
engine
AudioNodeStream
:
:
NO_STREAM_FLAGS
aContext
-
>
Graph
(
)
)
;
}
already_AddRefed
<
ConvolverNode
>
ConvolverNode
:
:
Create
(
JSContext
*
aCx
AudioContext
&
aAudioContext
const
ConvolverOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
aAudioContext
.
CheckClosed
(
aRv
)
)
{
return
nullptr
;
}
RefPtr
<
ConvolverNode
>
audioNode
=
new
ConvolverNode
(
&
aAudioContext
)
;
audioNode
-
>
Initialize
(
aOptions
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
audioNode
-
>
SetNormalize
(
!
aOptions
.
mDisableNormalization
)
;
if
(
aOptions
.
mBuffer
.
WasPassed
(
)
)
{
MOZ_ASSERT
(
aCx
)
;
audioNode
-
>
SetBuffer
(
aCx
aOptions
.
mBuffer
.
Value
(
)
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
}
return
audioNode
.
forget
(
)
;
}
size_t
ConvolverNode
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
AudioNode
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
if
(
mBuffer
)
{
amount
+
=
mBuffer
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
amount
;
}
size_t
ConvolverNode
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
JSObject
*
ConvolverNode
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ConvolverNode_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
ConvolverNode
:
:
SetBuffer
(
JSContext
*
aCx
AudioBuffer
*
aBuffer
ErrorResult
&
aRv
)
{
if
(
aBuffer
)
{
switch
(
aBuffer
-
>
NumberOfChannels
(
)
)
{
case
1
:
case
2
:
case
4
:
break
;
default
:
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
}
AudioNodeStream
*
ns
=
mStream
;
MOZ_ASSERT
(
ns
"
Why
don
'
t
we
have
a
stream
here
?
"
)
;
if
(
aBuffer
)
{
AudioChunk
data
=
aBuffer
-
>
GetThreadSharedChannelsForRate
(
aCx
)
;
if
(
data
.
mBufferFormat
=
=
AUDIO_FORMAT_S16
)
{
RefPtr
<
SharedBuffer
>
floatBuffer
=
SharedBuffer
:
:
Create
(
sizeof
(
float
)
*
data
.
mDuration
*
data
.
ChannelCount
(
)
)
;
if
(
!
floatBuffer
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
auto
floatData
=
static_cast
<
float
*
>
(
floatBuffer
-
>
Data
(
)
)
;
for
(
size_t
i
=
0
;
i
<
data
.
ChannelCount
(
)
;
+
+
i
)
{
ConvertAudioSamples
(
data
.
ChannelData
<
int16_t
>
(
)
[
i
]
floatData
data
.
mDuration
)
;
data
.
mChannelData
[
i
]
=
floatData
;
floatData
+
=
data
.
mDuration
;
}
data
.
mBuffer
=
std
:
:
move
(
floatBuffer
)
;
data
.
mBufferFormat
=
AUDIO_FORMAT_FLOAT32
;
}
SendDoubleParameterToStream
(
ConvolverNodeEngine
:
:
SAMPLE_RATE
aBuffer
-
>
SampleRate
(
)
)
;
ns
-
>
SetBuffer
(
std
:
:
move
(
data
)
)
;
}
else
{
ns
-
>
SetBuffer
(
AudioChunk
(
)
)
;
}
mBuffer
=
aBuffer
;
}
void
ConvolverNode
:
:
SetNormalize
(
bool
aNormalize
)
{
mNormalize
=
aNormalize
;
SendInt32ParameterToStream
(
ConvolverNodeEngine
:
:
NORMALIZE
aNormalize
)
;
}
}
}
