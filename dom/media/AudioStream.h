#
if
!
defined
(
AudioStream_h_
)
#
define
AudioStream_h_
#
include
"
AudioSampleFormat
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
dom
/
AudioChannelBinding
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
CubebUtils
.
h
"
#
include
"
soundtouch
/
SoundTouchFactory
.
h
"
namespace
mozilla
{
struct
CubebDestroyPolicy
{
void
operator
(
)
(
cubeb_stream
*
aStream
)
const
{
cubeb_stream_destroy
(
aStream
)
;
}
}
;
class
AudioStream
;
class
FrameHistory
;
class
AudioClock
{
public
:
explicit
AudioClock
(
AudioStream
*
aStream
)
;
void
Init
(
)
;
void
UpdateFrameHistory
(
uint32_t
aServiced
uint32_t
aUnderrun
)
;
int64_t
GetPositionUnlocked
(
)
const
;
int64_t
GetPositionInFrames
(
)
const
;
void
SetPlaybackRateUnlocked
(
double
aPlaybackRate
)
;
double
GetPlaybackRate
(
)
const
;
void
SetPreservesPitch
(
bool
aPreservesPitch
)
;
bool
GetPreservesPitch
(
)
const
;
private
:
AudioStream
*
const
mAudioStream
;
int
mOutRate
;
int
mInRate
;
bool
mPreservesPitch
;
const
nsAutoPtr
<
FrameHistory
>
mFrameHistory
;
}
;
class
CircularByteBuffer
{
public
:
CircularByteBuffer
(
)
:
mBuffer
(
nullptr
)
mCapacity
(
0
)
mStart
(
0
)
mCount
(
0
)
{
}
void
SetCapacity
(
uint32_t
aCapacity
)
{
MOZ_ASSERT
(
!
mBuffer
"
Buffer
allocated
.
"
)
;
mCapacity
=
aCapacity
;
mBuffer
=
MakeUnique
<
uint8_t
[
]
>
(
mCapacity
)
;
}
uint32_t
Length
(
)
{
return
mCount
;
}
uint32_t
Capacity
(
)
{
return
mCapacity
;
}
uint32_t
Available
(
)
{
return
Capacity
(
)
-
Length
(
)
;
}
void
AppendElements
(
const
uint8_t
*
aSrc
uint32_t
aLength
)
{
MOZ_ASSERT
(
mBuffer
&
&
mCapacity
"
Buffer
not
initialized
.
"
)
;
MOZ_ASSERT
(
aLength
<
=
Available
(
)
"
Buffer
full
.
"
)
;
uint32_t
end
=
(
mStart
+
mCount
)
%
mCapacity
;
uint32_t
toCopy
=
std
:
:
min
(
mCapacity
-
end
aLength
)
;
memcpy
(
&
mBuffer
[
end
]
aSrc
toCopy
)
;
memcpy
(
&
mBuffer
[
0
]
aSrc
+
toCopy
aLength
-
toCopy
)
;
mCount
+
=
aLength
;
}
void
PopElements
(
uint32_t
aSize
void
*
*
aData1
uint32_t
*
aSize1
void
*
*
aData2
uint32_t
*
aSize2
)
{
MOZ_ASSERT
(
mBuffer
&
&
mCapacity
"
Buffer
not
initialized
.
"
)
;
MOZ_ASSERT
(
aSize
<
=
Length
(
)
"
Request
too
large
.
"
)
;
*
aData1
=
&
mBuffer
[
mStart
]
;
*
aSize1
=
std
:
:
min
(
mCapacity
-
mStart
aSize
)
;
*
aData2
=
&
mBuffer
[
0
]
;
*
aSize2
=
aSize
-
*
aSize1
;
mCount
-
=
*
aSize1
+
*
aSize2
;
mStart
+
=
*
aSize1
+
*
aSize2
;
mStart
%
=
mCapacity
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
0
;
amount
+
=
aMallocSizeOf
(
mBuffer
.
get
(
)
)
;
return
amount
;
}
private
:
UniquePtr
<
uint8_t
[
]
>
mBuffer
;
uint32_t
mCapacity
;
uint32_t
mStart
;
uint32_t
mCount
;
}
;
class
AudioBufferCursor
{
public
:
AudioBufferCursor
(
AudioDataValue
*
aPtr
uint32_t
aChannels
uint32_t
aFrames
)
:
mPtr
(
aPtr
)
mChannels
(
aChannels
)
mFrames
(
aFrames
)
{
}
uint32_t
Advance
(
uint32_t
aFrames
)
{
MOZ_ASSERT
(
mFrames
>
=
aFrames
)
;
mFrames
-
=
aFrames
;
mPtr
+
=
mChannels
*
aFrames
;
return
aFrames
;
}
uint32_t
Available
(
)
const
{
return
mFrames
;
}
AudioDataValue
*
Ptr
(
)
const
{
return
mPtr
;
}
protected
:
AudioDataValue
*
mPtr
;
const
uint32_t
mChannels
;
uint32_t
mFrames
;
}
;
class
AudioBufferWriter
:
private
AudioBufferCursor
{
public
:
AudioBufferWriter
(
AudioDataValue
*
aPtr
uint32_t
aChannels
uint32_t
aFrames
)
:
AudioBufferCursor
(
aPtr
aChannels
aFrames
)
{
}
uint32_t
WriteZeros
(
uint32_t
aFrames
)
{
memset
(
mPtr
0
sizeof
(
AudioDataValue
)
*
mChannels
*
aFrames
)
;
return
Advance
(
aFrames
)
;
}
uint32_t
Write
(
const
AudioDataValue
*
aPtr
uint32_t
aFrames
)
{
memcpy
(
mPtr
aPtr
sizeof
(
AudioDataValue
)
*
mChannels
*
aFrames
)
;
return
Advance
(
aFrames
)
;
}
template
<
typename
Function
>
uint32_t
Write
(
const
Function
&
aFunction
uint32_t
aFrames
)
{
return
Advance
(
aFunction
(
mPtr
aFrames
)
)
;
}
using
AudioBufferCursor
:
:
Available
;
}
;
class
AudioStream
final
{
virtual
~
AudioStream
(
)
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AudioStream
)
class
Chunk
{
public
:
virtual
const
AudioDataValue
*
Data
(
)
const
=
0
;
virtual
uint32_t
Frames
(
)
const
=
0
;
virtual
AudioDataValue
*
GetWritable
(
)
const
=
0
;
virtual
~
Chunk
(
)
{
}
}
;
class
DataSource
{
public
:
virtual
UniquePtr
<
Chunk
>
PopFrames
(
uint32_t
aFrames
)
=
0
;
virtual
bool
Ended
(
)
const
=
0
;
virtual
void
Drained
(
)
=
0
;
protected
:
virtual
~
DataSource
(
)
{
}
}
;
explicit
AudioStream
(
DataSource
&
aSource
)
;
nsresult
Init
(
int32_t
aNumChannels
int32_t
aRate
const
dom
:
:
AudioChannel
aAudioStreamChannel
)
;
void
Shutdown
(
)
;
void
Reset
(
)
;
void
SetVolume
(
double
aVolume
)
;
void
Start
(
)
;
void
Pause
(
)
;
void
Resume
(
)
;
int64_t
GetPosition
(
)
;
int64_t
GetPositionInFrames
(
)
;
bool
IsPaused
(
)
;
int
GetRate
(
)
{
return
mOutRate
;
}
int
GetChannels
(
)
{
return
mChannels
;
}
int
GetOutChannels
(
)
{
return
mOutChannels
;
}
nsresult
SetPlaybackRate
(
double
aPlaybackRate
)
;
nsresult
SetPreservesPitch
(
bool
aPreservesPitch
)
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
protected
:
friend
class
AudioClock
;
int64_t
GetPositionInFramesUnlocked
(
)
;
private
:
nsresult
OpenCubeb
(
cubeb_stream_params
&
aParams
)
;
static
long
DataCallback_S
(
cubeb_stream
*
void
*
aThis
void
*
aBuffer
long
aFrames
)
{
return
static_cast
<
AudioStream
*
>
(
aThis
)
-
>
DataCallback
(
aBuffer
aFrames
)
;
}
static
void
StateCallback_S
(
cubeb_stream
*
void
*
aThis
cubeb_state
aState
)
{
static_cast
<
AudioStream
*
>
(
aThis
)
-
>
StateCallback
(
aState
)
;
}
long
DataCallback
(
void
*
aBuffer
long
aFrames
)
;
void
StateCallback
(
cubeb_state
aState
)
;
nsresult
EnsureTimeStretcherInitializedUnlocked
(
)
;
bool
Downmix
(
AudioDataValue
*
aBuffer
uint32_t
aFrames
)
;
void
GetUnprocessed
(
AudioBufferWriter
&
aWriter
)
;
void
GetTimeStretched
(
AudioBufferWriter
&
aWriter
)
;
void
StartUnlocked
(
)
;
Monitor
mMonitor
;
int
mInRate
;
int
mOutRate
;
int
mChannels
;
int
mOutChannels
;
#
if
defined
(
__ANDROID__
)
dom
:
:
AudioChannel
mAudioChannel
;
#
endif
AudioClock
mAudioClock
;
soundtouch
:
:
SoundTouch
*
mTimeStretcher
;
TimeStamp
mStartTime
;
FILE
*
mDumpFile
;
UniquePtr
<
cubeb_stream
CubebDestroyPolicy
>
mCubebStream
;
enum
StreamState
{
INITIALIZED
STARTED
RUNNING
STOPPED
DRAINED
ERRORED
SHUTDOWN
}
;
StreamState
mState
;
bool
mIsFirst
;
bool
mIsMonoAudioEnabled
;
DataSource
&
mDataSource
;
}
;
}
#
endif
