#
if
!
defined
(
AudioStream_h_
)
#
define
AudioStream_h_
#
include
"
AudioSampleFormat
.
h
"
#
include
"
CubebUtils
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
WavDumper
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
audio
/
AudioNotificationReceiver
.
h
"
#
endif
namespace
soundtouch
{
class
MOZ_EXPORT
SoundTouch
;
}
namespace
mozilla
{
struct
CubebDestroyPolicy
{
void
operator
(
)
(
cubeb_stream
*
aStream
)
const
{
cubeb_stream_destroy
(
aStream
)
;
}
}
;
class
AudioStream
;
class
FrameHistory
;
class
AudioConfig
;
class
AudioClock
{
public
:
AudioClock
(
)
;
void
Init
(
uint32_t
aRate
)
;
void
UpdateFrameHistory
(
uint32_t
aServiced
uint32_t
aUnderrun
)
;
int64_t
GetPositionInFrames
(
int64_t
aFrames
)
const
;
int64_t
GetPosition
(
int64_t
frames
)
const
;
void
SetPlaybackRate
(
double
aPlaybackRate
)
;
double
GetPlaybackRate
(
)
const
;
void
SetPreservesPitch
(
bool
aPreservesPitch
)
;
bool
GetPreservesPitch
(
)
const
;
uint32_t
GetInputRate
(
)
const
{
return
mInRate
;
}
uint32_t
GetOutputRate
(
)
const
{
return
mOutRate
;
}
private
:
uint32_t
mOutRate
;
uint32_t
mInRate
;
bool
mPreservesPitch
;
const
nsAutoPtr
<
FrameHistory
>
mFrameHistory
;
}
;
class
AudioBufferCursor
{
public
:
AudioBufferCursor
(
Span
<
AudioDataValue
>
aSpan
uint32_t
aChannels
uint32_t
aFrames
)
:
mChannels
(
aChannels
)
mSpan
(
aSpan
)
mFrames
(
aFrames
)
{
}
uint32_t
Advance
(
uint32_t
aFrames
)
{
MOZ_DIAGNOSTIC_ASSERT
(
Contains
(
aFrames
)
)
;
MOZ_ASSERT
(
mFrames
>
=
aFrames
)
;
mFrames
-
=
aFrames
;
mOffset
+
=
mChannels
*
aFrames
;
return
aFrames
;
}
uint32_t
Available
(
)
const
{
return
mFrames
;
}
AudioDataValue
*
Ptr
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mOffset
<
=
mSpan
.
Length
(
)
)
;
return
mSpan
.
Elements
(
)
+
mOffset
;
}
protected
:
bool
Contains
(
uint32_t
aFrames
)
const
{
return
mSpan
.
Length
(
)
>
=
mOffset
+
mChannels
*
aFrames
;
}
const
uint32_t
mChannels
;
private
:
const
Span
<
AudioDataValue
>
mSpan
;
size_t
mOffset
=
0
;
uint32_t
mFrames
;
}
;
class
AudioBufferWriter
:
private
AudioBufferCursor
{
public
:
AudioBufferWriter
(
Span
<
AudioDataValue
>
aSpan
uint32_t
aChannels
uint32_t
aFrames
)
:
AudioBufferCursor
(
aSpan
aChannels
aFrames
)
{
}
uint32_t
WriteZeros
(
uint32_t
aFrames
)
{
MOZ_DIAGNOSTIC_ASSERT
(
Contains
(
aFrames
)
)
;
memset
(
Ptr
(
)
0
sizeof
(
AudioDataValue
)
*
mChannels
*
aFrames
)
;
return
Advance
(
aFrames
)
;
}
uint32_t
Write
(
const
AudioDataValue
*
aPtr
uint32_t
aFrames
)
{
MOZ_DIAGNOSTIC_ASSERT
(
Contains
(
aFrames
)
)
;
memcpy
(
Ptr
(
)
aPtr
sizeof
(
AudioDataValue
)
*
mChannels
*
aFrames
)
;
return
Advance
(
aFrames
)
;
}
template
<
typename
Function
>
uint32_t
Write
(
const
Function
&
aFunction
uint32_t
aFrames
)
{
MOZ_DIAGNOSTIC_ASSERT
(
Contains
(
aFrames
)
)
;
return
Advance
(
aFunction
(
Ptr
(
)
aFrames
)
)
;
}
using
AudioBufferCursor
:
:
Available
;
}
;
class
AudioStream
final
#
if
defined
(
XP_WIN
)
:
public
audio
:
:
DeviceChangeListener
#
endif
{
virtual
~
AudioStream
(
)
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AudioStream
)
class
Chunk
{
public
:
virtual
const
AudioDataValue
*
Data
(
)
const
=
0
;
virtual
uint32_t
Frames
(
)
const
=
0
;
virtual
uint32_t
Channels
(
)
const
=
0
;
virtual
uint32_t
Rate
(
)
const
=
0
;
virtual
AudioDataValue
*
GetWritable
(
)
const
=
0
;
virtual
~
Chunk
(
)
{
}
}
;
class
DataSource
{
public
:
virtual
UniquePtr
<
Chunk
>
PopFrames
(
uint32_t
aFrames
)
=
0
;
virtual
bool
Ended
(
)
const
=
0
;
virtual
void
Drained
(
)
=
0
;
virtual
void
Errored
(
)
=
0
;
protected
:
virtual
~
DataSource
(
)
=
default
;
}
;
explicit
AudioStream
(
DataSource
&
aSource
)
;
nsresult
Init
(
uint32_t
aNumChannels
AudioConfig
:
:
ChannelLayout
:
:
ChannelMap
aChannelMap
uint32_t
aRate
AudioDeviceInfo
*
aSinkInfo
)
;
void
Shutdown
(
)
;
void
Reset
(
)
;
void
SetVolume
(
double
aVolume
)
;
nsresult
Start
(
)
;
void
Pause
(
)
;
void
Resume
(
)
;
#
if
defined
(
XP_WIN
)
void
ResetDefaultDevice
(
)
override
;
#
endif
int64_t
GetPosition
(
)
;
int64_t
GetPositionInFrames
(
)
;
static
uint32_t
GetPreferredRate
(
)
{
return
CubebUtils
:
:
PreferredSampleRate
(
)
;
}
uint32_t
GetOutChannels
(
)
{
return
mOutChannels
;
}
nsresult
SetPlaybackRate
(
double
aPlaybackRate
)
;
nsresult
SetPreservesPitch
(
bool
aPreservesPitch
)
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
protected
:
friend
class
AudioClock
;
int64_t
GetPositionInFramesUnlocked
(
)
;
private
:
nsresult
OpenCubeb
(
cubeb
*
aContext
cubeb_stream_params
&
aParams
TimeStamp
aStartTime
bool
aIsFirst
)
;
static
long
DataCallback_S
(
cubeb_stream
*
void
*
aThis
const
void
*
void
*
aOutputBuffer
long
aFrames
)
{
return
static_cast
<
AudioStream
*
>
(
aThis
)
-
>
DataCallback
(
aOutputBuffer
aFrames
)
;
}
static
void
StateCallback_S
(
cubeb_stream
*
void
*
aThis
cubeb_state
aState
)
{
static_cast
<
AudioStream
*
>
(
aThis
)
-
>
StateCallback
(
aState
)
;
}
long
DataCallback
(
void
*
aBuffer
long
aFrames
)
;
void
StateCallback
(
cubeb_state
aState
)
;
nsresult
EnsureTimeStretcherInitializedUnlocked
(
)
;
bool
IsValidAudioFormat
(
Chunk
*
aChunk
)
;
void
GetUnprocessed
(
AudioBufferWriter
&
aWriter
)
;
void
GetTimeStretched
(
AudioBufferWriter
&
aWriter
)
;
template
<
typename
Function
typename
.
.
.
Args
>
int
InvokeCubeb
(
Function
aFunction
Args
&
&
.
.
.
aArgs
)
;
Monitor
mMonitor
;
uint32_t
mChannels
;
uint32_t
mOutChannels
;
AudioClock
mAudioClock
;
soundtouch
:
:
SoundTouch
*
mTimeStretcher
;
WavDumper
mDumpFile
;
UniquePtr
<
cubeb_stream
CubebDestroyPolicy
>
mCubebStream
;
enum
StreamState
{
INITIALIZED
STARTED
STOPPED
DRAINED
ERRORED
SHUTDOWN
}
;
StreamState
mState
;
DataSource
&
mDataSource
;
bool
mPrefillQuirk
;
RefPtr
<
AudioDeviceInfo
>
mSinkInfo
;
}
;
}
#
endif
