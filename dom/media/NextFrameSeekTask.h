#
ifndef
NEXTFRAME_SEEK_TASK_H
#
define
NEXTFRAME_SEEK_TASK_H
#
include
"
SeekTask
.
h
"
#
include
"
MediaDecoderReader
.
h
"
namespace
mozilla
{
namespace
media
{
class
NextFrameSeekTask
final
:
public
SeekTask
{
public
:
NextFrameSeekTask
(
const
void
*
aDecoderID
AbstractThread
*
aThread
MediaDecoderReaderWrapper
*
aReader
const
SeekTarget
&
aTarget
const
MediaInfo
&
aInfo
const
media
:
:
TimeUnit
&
aDuration
int64_t
aCurrentTime
MediaQueue
<
MediaData
>
&
aAudioQueue
MediaQueue
<
MediaData
>
&
aVideoQueue
)
;
void
Discard
(
)
override
;
RefPtr
<
SeekTaskPromise
>
Seek
(
const
media
:
:
TimeUnit
&
aDuration
)
override
;
bool
NeedToResetMDSM
(
)
const
override
;
int64_t
CalculateNewCurrentTime
(
)
const
override
;
void
HandleAudioDecoded
(
MediaData
*
aAudio
)
override
;
void
HandleVideoDecoded
(
MediaData
*
aVideo
TimeStamp
aDecodeStart
)
override
;
void
HandleNotDecoded
(
MediaData
:
:
Type
aType
const
MediaResult
&
aError
)
override
;
void
HandleAudioWaited
(
MediaData
:
:
Type
aType
)
override
;
void
HandleVideoWaited
(
MediaData
:
:
Type
aType
)
override
;
void
HandleNotWaited
(
const
WaitForDataRejectValue
&
aRejection
)
override
;
private
:
~
NextFrameSeekTask
(
)
;
void
RequestVideoData
(
)
;
bool
NeedMoreVideo
(
)
const
;
bool
IsVideoRequestPending
(
)
const
;
bool
IsAudioSeekComplete
(
)
const
;
bool
IsVideoSeekComplete
(
)
const
;
void
MaybeFinishSeek
(
)
;
void
OnAudioDecoded
(
MediaData
*
aAudioSample
)
;
void
OnAudioNotDecoded
(
const
MediaResult
&
aError
)
;
void
OnVideoDecoded
(
MediaData
*
aVideoSample
)
;
void
OnVideoNotDecoded
(
const
MediaResult
&
aError
)
;
void
SetCallbacks
(
)
;
void
CancelCallbacks
(
)
;
void
UpdateSeekTargetTime
(
)
;
MediaQueue
<
MediaData
>
&
mAudioQueue
;
MediaQueue
<
MediaData
>
&
mVideoQueue
;
const
int64_t
mCurrentTime
;
media
:
:
TimeUnit
mDuration
;
MediaEventListener
mAudioCallback
;
MediaEventListener
mVideoCallback
;
MediaEventListener
mAudioWaitCallback
;
MediaEventListener
mVideoWaitCallback
;
}
;
}
}
#
endif
