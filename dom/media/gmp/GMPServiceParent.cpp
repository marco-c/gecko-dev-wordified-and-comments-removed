#
include
"
GMPServiceParent
.
h
"
#
include
"
GMPService
.
h
"
#
include
"
prio
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
GMPParent
.
h
"
#
include
"
GMPVideoDecoderParent
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
GeckoChildProcessHost
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
GMPDecryptorParent
.
h
"
#
include
"
GMPAudioDecoderParent
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
runnable_utils
.
h
"
#
include
"
VideoUtils
.
h
"
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_GMP_SANDBOX
)
#
include
"
mozilla
/
SandboxInfo
.
h
"
#
endif
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
if
defined
(
MOZ_CRASHREPORTER
)
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
endif
#
include
"
nsIXULRuntime
.
h
"
#
include
"
GMPDecoderModule
.
h
"
#
include
<
limits
>
#
include
"
MediaPrefs
.
h
"
using
mozilla
:
:
ipc
:
:
Transport
;
namespace
mozilla
{
#
ifdef
LOG
#
undef
LOG
#
endif
#
define
LOGD
(
msg
)
MOZ_LOG
(
GetGMPLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
msg
)
#
define
LOG
(
level
msg
)
MOZ_LOG
(
GetGMPLog
(
)
(
level
)
msg
)
#
ifdef
__CLASS__
#
undef
__CLASS__
#
endif
#
define
__CLASS__
"
GMPService
"
namespace
gmp
{
static
const
uint32_t
NodeIdSaltLength
=
32
;
already_AddRefed
<
GeckoMediaPluginServiceParent
>
GeckoMediaPluginServiceParent
:
:
GetSingleton
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
RefPtr
<
GeckoMediaPluginService
>
service
(
GeckoMediaPluginServiceParent
:
:
GetGeckoMediaPluginService
(
)
)
;
#
ifdef
DEBUG
if
(
service
)
{
nsCOMPtr
<
mozIGeckoMediaPluginChromeService
>
chromeService
;
CallQueryInterface
(
service
.
get
(
)
getter_AddRefs
(
chromeService
)
)
;
MOZ_ASSERT
(
chromeService
)
;
}
#
endif
return
service
.
forget
(
)
.
downcast
<
GeckoMediaPluginServiceParent
>
(
)
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
GeckoMediaPluginServiceParent
GeckoMediaPluginService
mozIGeckoMediaPluginChromeService
nsIAsyncShutdownBlocker
)
GeckoMediaPluginServiceParent
:
:
GeckoMediaPluginServiceParent
(
)
:
mShuttingDown
(
false
)
#
ifdef
MOZ_CRASHREPORTER
mAsyncShutdownPluginStatesMutex
(
"
GeckoMediaPluginService
:
:
mAsyncShutdownPluginStatesMutex
"
)
#
endif
mScannedPluginOnDisk
(
false
)
mWaitingForPluginsSyncShutdown
(
false
)
mInitPromiseMonitor
(
"
GeckoMediaPluginServiceParent
:
:
mInitPromiseMonitor
"
)
mLoadPluginsFromDiskComplete
(
false
)
mServiceUserCount
(
0
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mInitPromise
.
SetMonitor
(
&
mInitPromiseMonitor
)
;
}
GeckoMediaPluginServiceParent
:
:
~
GeckoMediaPluginServiceParent
(
)
{
MOZ_ASSERT
(
mPlugins
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mAsyncShutdownPlugins
.
IsEmpty
(
)
)
;
}
int32_t
GeckoMediaPluginServiceParent
:
:
AsyncShutdownTimeoutMs
(
)
{
return
MediaPrefs
:
:
GMPAsyncShutdownTimeout
(
)
;
}
nsresult
GeckoMediaPluginServiceParent
:
:
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
obsService
)
;
MOZ_ALWAYS_SUCCEEDS
(
obsService
-
>
AddObserver
(
this
"
profile
-
change
-
teardown
"
false
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
obsService
-
>
AddObserver
(
this
"
last
-
pb
-
context
-
exited
"
false
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
obsService
-
>
AddObserver
(
this
"
browser
:
purge
-
session
-
history
"
false
)
)
;
#
ifdef
DEBUG
MOZ_ALWAYS_SUCCEEDS
(
obsService
-
>
AddObserver
(
this
"
mediakeys
-
request
"
false
)
)
;
#
endif
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
prefs
)
{
prefs
-
>
AddObserver
(
"
media
.
gmp
.
plugin
.
crash
"
this
false
)
;
}
nsresult
rv
=
InitStorage
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIThread
>
thread
;
rv
=
GetThread
(
getter_AddRefs
(
thread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
int32_t
version
=
Preferences
:
:
GetInt
(
"
media
.
gmp
.
storage
.
version
.
observed
"
0
)
;
int32_t
expected
=
Preferences
:
:
GetInt
(
"
media
.
gmp
.
storage
.
version
.
expected
"
0
)
;
if
(
version
!
=
expected
)
{
Preferences
:
:
SetInt
(
"
media
.
gmp
.
storage
.
version
.
observed
"
expected
)
;
return
GMPDispatch
(
NewRunnableMethod
(
this
&
GeckoMediaPluginServiceParent
:
:
ClearStorage
)
)
;
}
return
NS_OK
;
}
already_AddRefed
<
nsIFile
>
CloneAndAppend
(
nsIFile
*
aFile
const
nsAString
&
aDir
)
{
nsCOMPtr
<
nsIFile
>
f
;
nsresult
rv
=
aFile
-
>
Clone
(
getter_AddRefs
(
f
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
rv
=
f
-
>
Append
(
aDir
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
return
f
.
forget
(
)
;
}
static
void
MoveAndOverwrite
(
nsIFile
*
aOldParentDir
nsIFile
*
aNewParentDir
const
nsAString
&
aSubDir
)
{
nsresult
rv
;
nsCOMPtr
<
nsIFile
>
srcDir
(
CloneAndAppend
(
aOldParentDir
aSubDir
)
)
;
if
(
NS_WARN_IF
(
!
srcDir
)
)
{
return
;
}
if
(
!
FileExists
(
srcDir
)
)
{
return
;
}
rv
=
aNewParentDir
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0700
)
;
if
(
rv
!
=
NS_ERROR_FILE_ALREADY_EXISTS
&
&
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
nsCOMPtr
<
nsIFile
>
dstDir
(
CloneAndAppend
(
aNewParentDir
aSubDir
)
)
;
if
(
FileExists
(
dstDir
)
)
{
rv
=
dstDir
-
>
Remove
(
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
rv
=
srcDir
-
>
MoveTo
(
aNewParentDir
EmptyString
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
static
void
MigratePreGecko42StorageDir
(
nsIFile
*
aOldStorageDir
nsIFile
*
aNewStorageDir
)
{
MoveAndOverwrite
(
aOldStorageDir
aNewStorageDir
NS_LITERAL_STRING
(
"
id
"
)
)
;
MoveAndOverwrite
(
aOldStorageDir
aNewStorageDir
NS_LITERAL_STRING
(
"
storage
"
)
)
;
}
static
void
MigratePreGecko45StorageDir
(
nsIFile
*
aStorageDirBase
)
{
nsCOMPtr
<
nsIFile
>
adobeStorageDir
(
CloneAndAppend
(
aStorageDirBase
NS_LITERAL_STRING
(
"
gmp
-
eme
-
adobe
"
)
)
)
;
if
(
NS_WARN_IF
(
!
adobeStorageDir
)
)
{
return
;
}
MoveAndOverwrite
(
aStorageDirBase
adobeStorageDir
NS_LITERAL_STRING
(
"
id
"
)
)
;
MoveAndOverwrite
(
aStorageDirBase
adobeStorageDir
NS_LITERAL_STRING
(
"
storage
"
)
)
;
}
static
nsresult
GMPPlatformString
(
nsAString
&
aOutPlatform
)
{
nsCOMPtr
<
nsIXULRuntime
>
runtime
=
do_GetService
(
"
mozilla
.
org
/
xre
/
runtime
;
1
"
)
;
if
(
!
runtime
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
OS
;
nsresult
rv
=
runtime
-
>
GetOS
(
OS
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoCString
arch
;
rv
=
runtime
-
>
GetXPCOMABI
(
arch
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCString
platform
;
platform
.
Append
(
OS
)
;
platform
.
AppendLiteral
(
"
_
"
)
;
platform
.
Append
(
arch
)
;
aOutPlatform
=
NS_ConvertUTF8toUTF16
(
platform
)
;
return
NS_OK
;
}
nsresult
GeckoMediaPluginServiceParent
:
:
InitStorage
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
NS_OK
;
}
#
ifdef
MOZ_WIDGET_GONK
nsresult
rv
=
NS_NewLocalFile
(
NS_LITERAL_STRING
(
"
/
data
/
b2g
/
mozilla
"
)
false
getter_AddRefs
(
mStorageBaseDir
)
)
;
#
else
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
mStorageBaseDir
)
)
;
#
endif
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mStorageBaseDir
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
gmp
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mStorageBaseDir
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0700
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_FILE_ALREADY_EXISTS
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIFile
>
gmpDirWithoutPlatform
;
rv
=
mStorageBaseDir
-
>
Clone
(
getter_AddRefs
(
gmpDirWithoutPlatform
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoString
platform
;
rv
=
GMPPlatformString
(
platform
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
mStorageBaseDir
-
>
Append
(
platform
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mStorageBaseDir
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0700
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_FILE_ALREADY_EXISTS
)
)
{
return
rv
;
}
MigratePreGecko42StorageDir
(
gmpDirWithoutPlatform
mStorageBaseDir
)
;
MigratePreGecko45StorageDir
(
mStorageBaseDir
)
;
return
GeckoMediaPluginService
:
:
Init
(
)
;
}
NS_IMETHODIMP
GeckoMediaPluginServiceParent
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aSomeData
)
{
LOGD
(
(
"
%
s
:
:
%
s
topic
=
'
%
s
'
data
=
'
%
s
'
"
__CLASS__
__FUNCTION__
aTopic
NS_ConvertUTF16toUTF8
(
aSomeData
)
.
get
(
)
)
)
;
if
(
!
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
)
{
nsCOMPtr
<
nsIPrefBranch
>
branch
(
do_QueryInterface
(
aSubject
)
)
;
if
(
branch
)
{
bool
crashNow
=
false
;
if
(
NS_LITERAL_STRING
(
"
media
.
gmp
.
plugin
.
crash
"
)
.
Equals
(
aSomeData
)
)
{
branch
-
>
GetBoolPref
(
"
media
.
gmp
.
plugin
.
crash
"
&
crashNow
)
;
}
if
(
crashNow
)
{
nsCOMPtr
<
nsIThread
>
gmpThread
;
{
MutexAutoLock
lock
(
mMutex
)
;
gmpThread
=
mGMPThread
;
}
if
(
gmpThread
)
{
gmpThread
-
>
Dispatch
(
WrapRunnable
(
this
&
GeckoMediaPluginServiceParent
:
:
CrashPlugins
)
NS_DISPATCH_NORMAL
)
;
}
}
}
}
else
if
(
!
strcmp
(
"
profile
-
change
-
teardown
"
aTopic
)
)
{
mWaitingForPluginsSyncShutdown
=
true
;
nsCOMPtr
<
nsIThread
>
gmpThread
;
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
!
mShuttingDown
)
;
mShuttingDown
=
true
;
gmpThread
=
mGMPThread
;
}
if
(
gmpThread
)
{
LOGD
(
(
"
%
s
:
:
%
s
Starting
to
unload
plugins
waiting
for
first
sync
shutdown
.
.
.
"
__CLASS__
__FUNCTION__
)
)
;
#
ifdef
MOZ_CRASHREPORTER
SetAsyncShutdownPluginState
(
nullptr
'
0
'
NS_LITERAL_CSTRING
(
"
Dispatching
UnloadPlugins
"
)
)
;
#
endif
gmpThread
-
>
Dispatch
(
NewRunnableMethod
(
this
&
GeckoMediaPluginServiceParent
:
:
UnloadPlugins
)
NS_DISPATCH_NORMAL
)
;
#
ifdef
MOZ_CRASHREPORTER
SetAsyncShutdownPluginState
(
nullptr
'
1
'
NS_LITERAL_CSTRING
(
"
Waiting
for
sync
shutdown
"
)
)
;
#
endif
while
(
mWaitingForPluginsSyncShutdown
)
{
NS_ProcessNextEvent
(
NS_GetCurrentThread
(
)
true
)
;
}
#
ifdef
MOZ_CRASHREPORTER
SetAsyncShutdownPluginState
(
nullptr
'
4
'
NS_LITERAL_CSTRING
(
"
Waiting
for
async
shutdown
"
)
)
;
#
endif
auto
syncShutdownPluginsRemaining
=
std
:
:
numeric_limits
<
decltype
(
mAsyncShutdownPlugins
.
Length
(
)
)
>
:
:
max
(
)
;
for
(
;
;
)
{
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mAsyncShutdownPlugins
.
IsEmpty
(
)
)
{
LOGD
(
(
"
%
s
:
:
%
s
Finished
unloading
all
plugins
"
__CLASS__
__FUNCTION__
)
)
;
#
if
defined
(
MOZ_CRASHREPORTER
)
CrashReporter
:
:
RemoveCrashReportAnnotation
(
NS_LITERAL_CSTRING
(
"
AsyncPluginShutdown
"
)
)
;
#
endif
break
;
}
else
if
(
mAsyncShutdownPlugins
.
Length
(
)
<
syncShutdownPluginsRemaining
)
{
syncShutdownPluginsRemaining
=
mAsyncShutdownPlugins
.
Length
(
)
;
LOGD
(
(
"
%
s
:
:
%
s
Still
waiting
for
%
d
plugins
to
shutdown
.
.
.
"
__CLASS__
__FUNCTION__
(
int
)
syncShutdownPluginsRemaining
)
)
;
#
if
defined
(
MOZ_CRASHREPORTER
)
nsAutoCString
names
;
for
(
const
auto
&
plugin
:
mAsyncShutdownPlugins
)
{
if
(
!
names
.
IsEmpty
(
)
)
{
names
.
Append
(
NS_LITERAL_CSTRING
(
"
"
)
)
;
}
names
.
Append
(
plugin
-
>
GetDisplayName
(
)
)
;
}
CrashReporter
:
:
AnnotateCrashReport
(
NS_LITERAL_CSTRING
(
"
AsyncPluginShutdown
"
)
names
)
;
#
endif
}
}
NS_ProcessNextEvent
(
NS_GetCurrentThread
(
)
true
)
;
}
#
ifdef
MOZ_CRASHREPORTER
SetAsyncShutdownPluginState
(
nullptr
'
5
'
NS_LITERAL_CSTRING
(
"
Async
shutdown
complete
"
)
)
;
#
endif
}
else
{
MOZ_ASSERT
(
mPlugins
.
IsEmpty
(
)
)
;
mWaitingForPluginsSyncShutdown
=
false
;
}
}
else
if
(
!
strcmp
(
NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID
aTopic
)
)
{
MOZ_ASSERT
(
mShuttingDown
)
;
ShutdownGMPThread
(
)
;
}
else
if
(
!
strcmp
(
"
last
-
pb
-
context
-
exited
"
aTopic
)
)
{
mTempNodeIds
.
Clear
(
)
;
}
else
if
(
!
strcmp
(
"
browser
:
purge
-
session
-
history
"
aTopic
)
)
{
if
(
!
aSomeData
|
|
nsDependentString
(
aSomeData
)
.
IsEmpty
(
)
)
{
return
GMPDispatch
(
NewRunnableMethod
(
this
&
GeckoMediaPluginServiceParent
:
:
ClearStorage
)
)
;
}
nsresult
rv
;
PRTime
t
=
nsDependentString
(
aSomeData
)
.
ToInteger64
(
&
rv
10
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
GMPDispatch
(
NewRunnableMethod
<
PRTime
>
(
this
&
GeckoMediaPluginServiceParent
:
:
ClearRecentHistoryOnGMPThread
t
)
)
;
}
return
NS_OK
;
}
RefPtr
<
GenericPromise
>
GeckoMediaPluginServiceParent
:
:
EnsureInitialized
(
)
{
MonitorAutoLock
lock
(
mInitPromiseMonitor
)
;
if
(
mLoadPluginsFromDiskComplete
)
{
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
MOZ_ASSERT
(
!
mInitPromise
.
IsEmpty
(
)
)
;
return
mInitPromise
.
Ensure
(
__func__
)
;
}
bool
GeckoMediaPluginServiceParent
:
:
GetContentParentFrom
(
GMPCrashHelper
*
aHelper
const
nsACString
&
aNodeId
const
nsCString
&
aAPI
const
nsTArray
<
nsCString
>
&
aTags
UniquePtr
<
GetGMPContentParentCallback
>
&
&
aCallback
)
{
RefPtr
<
AbstractThread
>
thread
(
GetAbstractGMPThread
(
)
)
;
if
(
!
thread
)
{
return
false
;
}
RefPtr
<
GeckoMediaPluginServiceParent
>
self
(
this
)
;
nsCString
nodeId
(
aNodeId
)
;
nsTArray
<
nsCString
>
tags
(
aTags
)
;
nsCString
api
(
aAPI
)
;
GetGMPContentParentCallback
*
rawCallback
=
aCallback
.
release
(
)
;
RefPtr
<
GMPCrashHelper
>
helper
(
aHelper
)
;
EnsureInitialized
(
)
-
>
Then
(
thread
__func__
[
self
tags
api
nodeId
rawCallback
helper
]
(
)
-
>
void
{
UniquePtr
<
GetGMPContentParentCallback
>
callback
(
rawCallback
)
;
RefPtr
<
GMPParent
>
gmp
=
self
-
>
SelectPluginForAPI
(
nodeId
api
tags
)
;
LOGD
(
(
"
%
s
:
%
p
returning
%
p
for
api
%
s
"
__FUNCTION__
(
void
*
)
self
(
void
*
)
gmp
api
.
get
(
)
)
)
;
if
(
!
gmp
)
{
NS_WARNING
(
"
GeckoMediaPluginServiceParent
:
:
GetContentParentFrom
failed
"
)
;
callback
-
>
Done
(
nullptr
)
;
return
;
}
self
-
>
ConnectCrashHelper
(
gmp
-
>
GetPluginId
(
)
helper
)
;
gmp
-
>
GetGMPContentParent
(
Move
(
callback
)
)
;
}
[
rawCallback
]
(
)
-
>
void
{
UniquePtr
<
GetGMPContentParentCallback
>
callback
(
rawCallback
)
;
NS_WARNING
(
"
GMPService
:
:
EnsureInitialized
failed
.
"
)
;
callback
-
>
Done
(
nullptr
)
;
}
)
;
return
true
;
}
void
GeckoMediaPluginServiceParent
:
:
InitializePlugins
(
AbstractThread
*
aAbstractGMPThread
)
{
MOZ_ASSERT
(
aAbstractGMPThread
)
;
MonitorAutoLock
lock
(
mInitPromiseMonitor
)
;
if
(
mLoadPluginsFromDiskComplete
)
{
return
;
}
RefPtr
<
GeckoMediaPluginServiceParent
>
self
(
this
)
;
RefPtr
<
GenericPromise
>
p
=
mInitPromise
.
Ensure
(
__func__
)
;
InvokeAsync
(
aAbstractGMPThread
this
__func__
&
GeckoMediaPluginServiceParent
:
:
LoadFromEnvironment
)
-
>
Then
(
aAbstractGMPThread
__func__
[
self
]
(
)
-
>
void
{
MonitorAutoLock
lock
(
self
-
>
mInitPromiseMonitor
)
;
self
-
>
mLoadPluginsFromDiskComplete
=
true
;
self
-
>
mInitPromise
.
Resolve
(
true
__func__
)
;
}
[
self
]
(
)
-
>
void
{
MonitorAutoLock
lock
(
self
-
>
mInitPromiseMonitor
)
;
self
-
>
mLoadPluginsFromDiskComplete
=
true
;
self
-
>
mInitPromise
.
Reject
(
NS_ERROR_FAILURE
__func__
)
;
}
)
;
}
void
GeckoMediaPluginServiceParent
:
:
AsyncShutdownNeeded
(
GMPParent
*
aParent
)
{
LOGD
(
(
"
%
s
:
:
%
s
%
p
"
__CLASS__
__FUNCTION__
aParent
)
)
;
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
!
mAsyncShutdownPlugins
.
Contains
(
aParent
)
)
;
mAsyncShutdownPlugins
.
AppendElement
(
aParent
)
;
}
void
GeckoMediaPluginServiceParent
:
:
AsyncShutdownComplete
(
GMPParent
*
aParent
)
{
LOGD
(
(
"
%
s
:
:
%
s
%
p
'
%
s
'
"
__CLASS__
__FUNCTION__
aParent
aParent
-
>
GetDisplayName
(
)
.
get
(
)
)
)
;
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
mAsyncShutdownPlugins
.
RemoveElement
(
aParent
)
;
}
if
(
mShuttingDownOnGMPThread
)
{
nsCOMPtr
<
nsIRunnable
>
task
(
NewRunnableMethod
(
this
&
GeckoMediaPluginServiceParent
:
:
NotifyAsyncShutdownComplete
)
)
;
NS_DispatchToMainThread
(
task
)
;
}
}
#
ifdef
MOZ_CRASHREPORTER
void
GeckoMediaPluginServiceParent
:
:
SetAsyncShutdownPluginState
(
GMPParent
*
aGMPParent
char
aId
const
nsCString
&
aState
)
{
MutexAutoLock
lock
(
mAsyncShutdownPluginStatesMutex
)
;
if
(
!
aGMPParent
)
{
mAsyncShutdownPluginStates
.
Update
(
NS_LITERAL_CSTRING
(
"
-
"
)
NS_LITERAL_CSTRING
(
"
-
"
)
aId
aState
)
;
return
;
}
mAsyncShutdownPluginStates
.
Update
(
aGMPParent
-
>
GetDisplayName
(
)
nsPrintfCString
(
"
%
p
"
aGMPParent
)
aId
aState
)
;
}
void
GeckoMediaPluginServiceParent
:
:
AsyncShutdownPluginStates
:
:
Update
(
const
nsCString
&
aPlugin
const
nsCString
&
aInstance
char
aId
const
nsCString
&
aState
)
{
nsCString
note
;
StatesByInstance
*
instances
=
mStates
.
LookupOrAdd
(
aPlugin
)
;
if
(
!
instances
)
{
return
;
}
State
*
state
=
instances
-
>
LookupOrAdd
(
aInstance
)
;
if
(
!
state
)
{
return
;
}
state
-
>
mStateSequence
+
=
aId
;
state
-
>
mLastStateDescription
=
aState
;
note
+
=
'
{
'
;
bool
firstPlugin
=
true
;
for
(
auto
pluginIt
=
mStates
.
ConstIter
(
)
;
!
pluginIt
.
Done
(
)
;
pluginIt
.
Next
(
)
)
{
if
(
!
firstPlugin
)
{
note
+
=
'
'
;
}
else
{
firstPlugin
=
false
;
}
note
+
=
pluginIt
.
Key
(
)
;
note
+
=
"
:
{
"
;
bool
firstInstance
=
true
;
for
(
auto
instanceIt
=
pluginIt
.
UserData
(
)
-
>
ConstIter
(
)
;
!
instanceIt
.
Done
(
)
;
instanceIt
.
Next
(
)
)
{
if
(
!
firstInstance
)
{
note
+
=
'
'
;
}
else
{
firstInstance
=
false
;
}
note
+
=
instanceIt
.
Key
(
)
;
note
+
=
"
:
\
"
"
;
note
+
=
instanceIt
.
UserData
(
)
-
>
mStateSequence
;
note
+
=
'
=
'
;
note
+
=
instanceIt
.
UserData
(
)
-
>
mLastStateDescription
;
note
+
=
'
"
'
;
}
note
+
=
'
}
'
;
}
note
+
=
'
}
'
;
LOGD
(
(
"
%
s
:
:
%
s
states
[
%
s
]
[
%
s
]
=
'
%
c
'
/
'
%
s
'
-
>
%
s
"
__CLASS__
__FUNCTION__
aPlugin
.
get
(
)
aInstance
.
get
(
)
aId
aState
.
get
(
)
note
.
get
(
)
)
)
;
CrashReporter
:
:
AnnotateCrashReport
(
NS_LITERAL_CSTRING
(
"
AsyncPluginShutdownStates
"
)
note
)
;
}
#
endif
void
GeckoMediaPluginServiceParent
:
:
NotifyAsyncShutdownComplete
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
GeckoMediaPluginServiceParent
:
:
NotifySyncShutdownComplete
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mWaitingForPluginsSyncShutdown
=
false
;
}
bool
GeckoMediaPluginServiceParent
:
:
IsShuttingDown
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
return
mShuttingDownOnGMPThread
;
}
void
GeckoMediaPluginServiceParent
:
:
UnloadPlugins
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
MOZ_ASSERT
(
!
mShuttingDownOnGMPThread
)
;
mShuttingDownOnGMPThread
=
true
;
#
ifdef
MOZ_CRASHREPORTER
SetAsyncShutdownPluginState
(
nullptr
'
2
'
NS_LITERAL_CSTRING
(
"
Starting
to
unload
plugins
"
)
)
;
#
endif
nsTArray
<
RefPtr
<
GMPParent
>
>
plugins
;
{
MutexAutoLock
lock
(
mMutex
)
;
Swap
(
plugins
mPlugins
)
;
}
LOGD
(
(
"
%
s
:
:
%
s
plugins
:
%
u
including
async
:
%
u
"
__CLASS__
__FUNCTION__
plugins
.
Length
(
)
mAsyncShutdownPlugins
.
Length
(
)
)
)
;
#
ifdef
DEBUG
for
(
const
auto
&
plugin
:
plugins
)
{
LOGD
(
(
"
%
s
:
:
%
s
plugin
:
'
%
s
'
"
__CLASS__
__FUNCTION__
plugin
-
>
GetDisplayName
(
)
.
get
(
)
)
)
;
}
for
(
const
auto
&
plugin
:
mAsyncShutdownPlugins
)
{
LOGD
(
(
"
%
s
:
:
%
s
async
plugin
:
'
%
s
'
"
__CLASS__
__FUNCTION__
plugin
-
>
GetDisplayName
(
)
.
get
(
)
)
)
;
}
#
endif
for
(
const
auto
&
plugin
:
plugins
)
{
#
ifdef
MOZ_CRASHREPORTER
SetAsyncShutdownPluginState
(
plugin
'
S
'
NS_LITERAL_CSTRING
(
"
CloseActive
"
)
)
;
#
endif
plugin
-
>
CloseActive
(
true
)
;
}
#
ifdef
MOZ_CRASHREPORTER
SetAsyncShutdownPluginState
(
nullptr
'
3
'
NS_LITERAL_CSTRING
(
"
Dispatching
sync
-
shutdown
-
complete
"
)
)
;
#
endif
nsCOMPtr
<
nsIRunnable
>
task
(
NewRunnableMethod
(
this
&
GeckoMediaPluginServiceParent
:
:
NotifySyncShutdownComplete
)
)
;
NS_DispatchToMainThread
(
task
)
;
}
void
GeckoMediaPluginServiceParent
:
:
CrashPlugins
(
)
{
LOGD
(
(
"
%
s
:
:
%
s
"
__CLASS__
__FUNCTION__
)
)
;
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
MutexAutoLock
lock
(
mMutex
)
;
for
(
size_t
i
=
0
;
i
<
mPlugins
.
Length
(
)
;
i
+
+
)
{
mPlugins
[
i
]
-
>
Crash
(
)
;
}
}
RefPtr
<
GenericPromise
:
:
AllPromiseType
>
GeckoMediaPluginServiceParent
:
:
LoadFromEnvironment
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
RefPtr
<
AbstractThread
>
thread
(
GetAbstractGMPThread
(
)
)
;
if
(
!
thread
)
{
return
GenericPromise
:
:
AllPromiseType
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
const
char
*
env
=
PR_GetEnv
(
"
MOZ_GMP_PATH
"
)
;
if
(
!
env
|
|
!
*
env
)
{
return
GenericPromise
:
:
AllPromiseType
:
:
CreateAndResolve
(
true
__func__
)
;
}
nsString
allpaths
;
if
(
NS_WARN_IF
(
NS_FAILED
(
NS_CopyNativeToUnicode
(
nsDependentCString
(
env
)
allpaths
)
)
)
)
{
return
GenericPromise
:
:
AllPromiseType
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
nsTArray
<
RefPtr
<
GenericPromise
>
>
promises
;
uint32_t
pos
=
0
;
while
(
pos
<
allpaths
.
Length
(
)
)
{
int32_t
next
=
allpaths
.
FindChar
(
XPCOM_ENV_PATH_SEPARATOR
[
0
]
pos
)
;
if
(
next
=
=
-
1
)
{
promises
.
AppendElement
(
AddOnGMPThread
(
nsString
(
Substring
(
allpaths
pos
)
)
)
)
;
break
;
}
else
{
promises
.
AppendElement
(
AddOnGMPThread
(
nsString
(
Substring
(
allpaths
pos
next
-
pos
)
)
)
)
;
pos
=
next
+
1
;
}
}
mScannedPluginOnDisk
=
true
;
return
GenericPromise
:
:
All
(
thread
promises
)
;
}
class
NotifyObserversTask
final
:
public
mozilla
:
:
Runnable
{
public
:
explicit
NotifyObserversTask
(
const
char
*
aTopic
nsString
aData
=
EmptyString
(
)
)
:
mTopic
(
aTopic
)
mData
(
aData
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
obsService
)
;
if
(
obsService
)
{
obsService
-
>
NotifyObservers
(
nullptr
mTopic
mData
.
get
(
)
)
;
}
return
NS_OK
;
}
private
:
~
NotifyObserversTask
(
)
{
}
const
char
*
mTopic
;
const
nsString
mData
;
}
;
NS_IMETHODIMP
GeckoMediaPluginServiceParent
:
:
PathRunnable
:
:
Run
(
)
{
mService
-
>
RemoveOnGMPThread
(
mPath
mOperation
=
=
REMOVE_AND_DELETE_FROM_DISK
mDefer
)
;
mService
-
>
UpdateContentProcessGMPCapabilities
(
)
;
#
ifndef
MOZ_WIDGET_GONK
NS_DispatchToMainThread
(
new
NotifyObserversTask
(
"
gmp
-
changed
"
)
NS_DISPATCH_NORMAL
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
[
]
(
)
-
>
void
{
GMPDecoderModule
:
:
UpdateUsableCodecs
(
)
;
}
)
)
;
#
endif
return
NS_OK
;
}
void
GeckoMediaPluginServiceParent
:
:
UpdateContentProcessGMPCapabilities
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
task
=
NewRunnableMethod
(
this
&
GeckoMediaPluginServiceParent
:
:
UpdateContentProcessGMPCapabilities
)
;
NS_DispatchToMainThread
(
task
)
;
return
;
}
typedef
mozilla
:
:
dom
:
:
GMPCapabilityData
GMPCapabilityData
;
typedef
mozilla
:
:
dom
:
:
GMPAPITags
GMPAPITags
;
typedef
mozilla
:
:
dom
:
:
ContentParent
ContentParent
;
nsTArray
<
GMPCapabilityData
>
caps
;
{
MutexAutoLock
lock
(
mMutex
)
;
for
(
const
RefPtr
<
GMPParent
>
&
gmp
:
mPlugins
)
{
NS_ConvertUTF16toUTF8
name
(
gmp
-
>
GetPluginBaseName
(
)
)
;
bool
found
=
false
;
for
(
const
GMPCapabilityData
&
cap
:
caps
)
{
if
(
cap
.
name
(
)
.
Equals
(
name
)
)
{
found
=
true
;
break
;
}
}
if
(
found
)
{
continue
;
}
GMPCapabilityData
x
;
x
.
name
(
)
=
name
;
x
.
version
(
)
=
gmp
-
>
GetVersion
(
)
;
for
(
const
GMPCapability
&
tag
:
gmp
-
>
GetCapabilities
(
)
)
{
x
.
capabilities
(
)
.
AppendElement
(
GMPAPITags
(
tag
.
mAPIName
tag
.
mAPITags
)
)
;
}
caps
.
AppendElement
(
Move
(
x
)
)
;
}
}
for
(
auto
*
cp
:
ContentParent
:
:
AllProcesses
(
ContentParent
:
:
eLive
)
)
{
Unused
<
<
cp
-
>
SendGMPsChanged
(
caps
)
;
}
}
RefPtr
<
GenericPromise
>
GeckoMediaPluginServiceParent
:
:
AsyncAddPluginDirectory
(
const
nsAString
&
aDirectory
)
{
RefPtr
<
AbstractThread
>
thread
(
GetAbstractGMPThread
(
)
)
;
if
(
!
thread
)
{
return
GenericPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
nsString
dir
(
aDirectory
)
;
RefPtr
<
GeckoMediaPluginServiceParent
>
self
=
this
;
return
InvokeAsync
(
thread
this
__func__
&
GeckoMediaPluginServiceParent
:
:
AddOnGMPThread
dir
)
-
>
Then
(
AbstractThread
:
:
MainThread
(
)
__func__
[
dir
self
]
(
)
-
>
void
{
LOGD
(
(
"
GeckoMediaPluginServiceParent
:
:
AsyncAddPluginDirectory
%
s
succeeded
"
NS_ConvertUTF16toUTF8
(
dir
)
.
get
(
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
obsService
)
;
if
(
obsService
)
{
obsService
-
>
NotifyObservers
(
nullptr
"
gmp
-
changed
"
nullptr
)
;
}
self
-
>
UpdateContentProcessGMPCapabilities
(
)
;
GMPDecoderModule
:
:
UpdateUsableCodecs
(
)
;
}
[
dir
]
(
)
-
>
void
{
LOGD
(
(
"
GeckoMediaPluginServiceParent
:
:
AsyncAddPluginDirectory
%
s
failed
"
NS_ConvertUTF16toUTF8
(
dir
)
.
get
(
)
)
)
;
}
)
-
>
CompletionPromise
(
)
;
}
NS_IMETHODIMP
GeckoMediaPluginServiceParent
:
:
AddPluginDirectory
(
const
nsAString
&
aDirectory
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
GenericPromise
>
p
=
AsyncAddPluginDirectory
(
aDirectory
)
;
Unused
<
<
p
;
return
NS_OK
;
}
NS_IMETHODIMP
GeckoMediaPluginServiceParent
:
:
RemovePluginDirectory
(
const
nsAString
&
aDirectory
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
GMPDispatch
(
new
PathRunnable
(
this
aDirectory
PathRunnable
:
:
EOperation
:
:
REMOVE
)
)
;
}
NS_IMETHODIMP
GeckoMediaPluginServiceParent
:
:
RemoveAndDeletePluginDirectory
(
const
nsAString
&
aDirectory
const
bool
aDefer
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
GMPDispatch
(
new
PathRunnable
(
this
aDirectory
PathRunnable
:
:
EOperation
:
:
REMOVE_AND_DELETE_FROM_DISK
aDefer
)
)
;
}
NS_IMETHODIMP
GeckoMediaPluginServiceParent
:
:
GetPluginVersionForAPI
(
const
nsACString
&
aAPI
nsTArray
<
nsCString
>
*
aTags
bool
*
aHasPlugin
nsACString
&
aOutVersion
)
{
NS_ENSURE_ARG
(
aTags
&
&
aTags
-
>
Length
(
)
>
0
)
;
NS_ENSURE_ARG
(
aHasPlugin
)
;
NS_ENSURE_ARG
(
aOutVersion
.
IsEmpty
(
)
)
;
nsresult
rv
=
EnsurePluginsOnDiskScanned
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
load
GMPs
from
disk
.
"
)
;
return
rv
;
}
{
MutexAutoLock
lock
(
mMutex
)
;
nsCString
api
(
aAPI
)
;
size_t
index
=
0
;
RefPtr
<
GMPParent
>
gmp
=
FindPluginForAPIFrom
(
index
api
*
aTags
&
index
)
;
if
(
gmp
)
{
*
aHasPlugin
=
true
;
aOutVersion
=
gmp
-
>
GetVersion
(
)
;
}
else
{
*
aHasPlugin
=
false
;
}
}
return
NS_OK
;
}
nsresult
GeckoMediaPluginServiceParent
:
:
EnsurePluginsOnDiskScanned
(
)
{
const
char
*
env
=
nullptr
;
if
(
!
mScannedPluginOnDisk
&
&
(
env
=
PR_GetEnv
(
"
MOZ_GMP_PATH
"
)
)
&
&
*
env
)
{
nsresult
rv
=
GMPDispatch
(
new
mozilla
:
:
Runnable
(
)
NS_DISPATCH_SYNC
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
mScannedPluginOnDisk
"
Should
have
scanned
MOZ_GMP_PATH
by
now
"
)
;
}
return
NS_OK
;
}
already_AddRefed
<
GMPParent
>
GeckoMediaPluginServiceParent
:
:
FindPluginForAPIFrom
(
size_t
aSearchStartIndex
const
nsCString
&
aAPI
const
nsTArray
<
nsCString
>
&
aTags
size_t
*
aOutPluginIndex
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
for
(
size_t
i
=
aSearchStartIndex
;
i
<
mPlugins
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
GMPParent
>
gmp
=
mPlugins
[
i
]
;
bool
supportsAllTags
=
true
;
for
(
size_t
t
=
0
;
t
<
aTags
.
Length
(
)
;
t
+
+
)
{
const
nsCString
&
tag
=
aTags
.
ElementAt
(
t
)
;
if
(
!
gmp
-
>
SupportsAPI
(
aAPI
tag
)
)
{
supportsAllTags
=
false
;
break
;
}
}
if
(
!
supportsAllTags
)
{
continue
;
}
if
(
aOutPluginIndex
)
{
*
aOutPluginIndex
=
i
;
}
return
gmp
.
forget
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
GMPParent
>
GeckoMediaPluginServiceParent
:
:
SelectPluginForAPI
(
const
nsACString
&
aNodeId
const
nsCString
&
aAPI
const
nsTArray
<
nsCString
>
&
aTags
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
"
Can
'
t
clone
GMP
plugins
on
non
-
GMP
threads
.
"
)
;
GMPParent
*
gmpToClone
=
nullptr
;
{
MutexAutoLock
lock
(
mMutex
)
;
size_t
index
=
0
;
RefPtr
<
GMPParent
>
gmp
;
while
(
(
gmp
=
FindPluginForAPIFrom
(
index
aAPI
aTags
&
index
)
)
)
{
if
(
aNodeId
.
IsEmpty
(
)
)
{
if
(
gmp
-
>
CanBeSharedCrossNodeIds
(
)
)
{
return
gmp
.
forget
(
)
;
}
}
else
if
(
gmp
-
>
CanBeUsedFrom
(
aNodeId
)
)
{
return
gmp
.
forget
(
)
;
}
if
(
!
gmpToClone
|
|
(
gmpToClone
-
>
IsMarkedForDeletion
(
)
&
&
!
gmp
-
>
IsMarkedForDeletion
(
)
)
)
{
gmpToClone
=
gmp
;
}
index
+
+
;
}
}
if
(
gmpToClone
)
{
RefPtr
<
GMPParent
>
clone
=
ClonePlugin
(
gmpToClone
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
mPlugins
.
AppendElement
(
clone
)
;
}
if
(
!
aNodeId
.
IsEmpty
(
)
)
{
clone
-
>
SetNodeId
(
aNodeId
)
;
}
return
clone
.
forget
(
)
;
}
return
nullptr
;
}
RefPtr
<
GMPParent
>
CreateGMPParent
(
)
{
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_GMP_SANDBOX
)
if
(
!
SandboxInfo
:
:
Get
(
)
.
CanSandboxMedia
(
)
)
{
if
(
!
MediaPrefs
:
:
GMPAllowInsecure
(
)
)
{
NS_WARNING
(
"
Denying
media
plugin
load
due
to
lack
of
sandboxing
.
"
)
;
return
nullptr
;
}
NS_WARNING
(
"
Loading
media
plugin
despite
lack
of
sandboxing
.
"
)
;
}
#
endif
return
new
GMPParent
(
)
;
}
already_AddRefed
<
GMPParent
>
GeckoMediaPluginServiceParent
:
:
ClonePlugin
(
const
GMPParent
*
aOriginal
)
{
MOZ_ASSERT
(
aOriginal
)
;
RefPtr
<
GMPParent
>
gmp
=
CreateGMPParent
(
)
;
nsresult
rv
=
gmp
?
gmp
-
>
CloneFrom
(
aOriginal
)
:
NS_ERROR_NOT_AVAILABLE
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Can
'
t
Create
GMPParent
"
)
;
return
nullptr
;
}
return
gmp
.
forget
(
)
;
}
RefPtr
<
GenericPromise
>
GeckoMediaPluginServiceParent
:
:
AddOnGMPThread
(
nsString
aDirectory
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
nsCString
dir
=
NS_ConvertUTF16toUTF8
(
aDirectory
)
;
RefPtr
<
AbstractThread
>
thread
(
GetAbstractGMPThread
(
)
)
;
if
(
!
thread
)
{
LOGD
(
(
"
%
s
:
:
%
s
:
%
s
No
GMP
Thread
"
__CLASS__
__FUNCTION__
dir
.
get
(
)
)
)
;
return
GenericPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
LOGD
(
(
"
%
s
:
:
%
s
:
%
s
"
__CLASS__
__FUNCTION__
dir
.
get
(
)
)
)
;
nsCOMPtr
<
nsIFile
>
directory
;
nsresult
rv
=
NS_NewLocalFile
(
aDirectory
false
getter_AddRefs
(
directory
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
GenericPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
RefPtr
<
GMPParent
>
gmp
=
CreateGMPParent
(
)
;
if
(
!
gmp
)
{
NS_WARNING
(
"
Can
'
t
Create
GMPParent
"
)
;
return
GenericPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
RefPtr
<
GeckoMediaPluginServiceParent
>
self
(
this
)
;
return
gmp
-
>
Init
(
this
directory
)
-
>
Then
(
thread
__func__
[
gmp
self
dir
]
(
)
-
>
void
{
LOGD
(
(
"
%
s
:
:
%
s
:
%
s
Succeeded
"
__CLASS__
__FUNCTION__
dir
.
get
(
)
)
)
;
{
MutexAutoLock
lock
(
self
-
>
mMutex
)
;
self
-
>
mPlugins
.
AppendElement
(
gmp
)
;
}
}
[
dir
]
(
)
-
>
void
{
LOGD
(
(
"
%
s
:
:
%
s
:
%
s
Failed
"
__CLASS__
__FUNCTION__
dir
.
get
(
)
)
)
;
}
)
-
>
CompletionPromise
(
)
;
}
void
GeckoMediaPluginServiceParent
:
:
RemoveOnGMPThread
(
const
nsAString
&
aDirectory
const
bool
aDeleteFromDisk
const
bool
aCanDefer
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
LOGD
(
(
"
%
s
:
:
%
s
:
%
s
"
__CLASS__
__FUNCTION__
NS_LossyConvertUTF16toASCII
(
aDirectory
)
.
get
(
)
)
)
;
nsCOMPtr
<
nsIFile
>
directory
;
nsresult
rv
=
NS_NewLocalFile
(
aDirectory
false
getter_AddRefs
(
directory
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
nsTArray
<
RefPtr
<
GMPParent
>
>
deadPlugins
;
bool
inUse
=
false
;
MutexAutoLock
lock
(
mMutex
)
;
for
(
size_t
i
=
mPlugins
.
Length
(
)
;
i
-
-
>
0
;
)
{
nsCOMPtr
<
nsIFile
>
pluginpath
=
mPlugins
[
i
]
-
>
GetDirectory
(
)
;
bool
equals
;
if
(
NS_FAILED
(
directory
-
>
Equals
(
pluginpath
&
equals
)
)
|
|
!
equals
)
{
continue
;
}
RefPtr
<
GMPParent
>
gmp
=
mPlugins
[
i
]
;
if
(
aDeleteFromDisk
&
&
gmp
-
>
State
(
)
!
=
GMPStateNotLoaded
)
{
inUse
=
true
;
gmp
-
>
MarkForDeletion
(
)
;
if
(
!
mPluginsWaitingForDeletion
.
Contains
(
aDirectory
)
)
{
mPluginsWaitingForDeletion
.
AppendElement
(
aDirectory
)
;
}
}
if
(
gmp
-
>
State
(
)
=
=
GMPStateNotLoaded
|
|
!
aCanDefer
)
{
deadPlugins
.
AppendElement
(
gmp
)
;
mPlugins
.
RemoveElementAt
(
i
)
;
}
}
{
MutexAutoUnlock
unlock
(
mMutex
)
;
for
(
auto
&
gmp
:
deadPlugins
)
{
gmp
-
>
AbortAsyncShutdown
(
)
;
gmp
-
>
CloseActive
(
true
)
;
}
}
if
(
aDeleteFromDisk
&
&
!
inUse
)
{
directory
-
>
SetPermissions
(
0700
)
;
DirectoryEnumerator
iter
(
directory
DirectoryEnumerator
:
:
FilesAndDirs
)
;
for
(
nsCOMPtr
<
nsIFile
>
dirEntry
;
(
dirEntry
=
iter
.
Next
(
)
)
!
=
nullptr
;
)
{
dirEntry
-
>
SetPermissions
(
0700
)
;
}
if
(
NS_SUCCEEDED
(
directory
-
>
Remove
(
true
)
)
)
{
mPluginsWaitingForDeletion
.
RemoveElement
(
aDirectory
)
;
NS_DispatchToMainThread
(
new
NotifyObserversTask
(
"
gmp
-
directory
-
deleted
"
nsString
(
aDirectory
)
)
NS_DISPATCH_NORMAL
)
;
}
}
}
static
void
Dummy
(
RefPtr
<
GMPParent
>
&
aOnDeathsDoor
)
{
}
void
GeckoMediaPluginServiceParent
:
:
PluginTerminated
(
const
RefPtr
<
GMPParent
>
&
aPlugin
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
if
(
aPlugin
-
>
IsMarkedForDeletion
(
)
)
{
nsCString
path8
;
RefPtr
<
nsIFile
>
dir
=
aPlugin
-
>
GetDirectory
(
)
;
nsresult
rv
=
dir
-
>
GetNativePath
(
path8
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsString
path
=
NS_ConvertUTF8toUTF16
(
path8
)
;
if
(
mPluginsWaitingForDeletion
.
Contains
(
path
)
)
{
RemoveOnGMPThread
(
path
true
true
)
;
}
}
}
void
GeckoMediaPluginServiceParent
:
:
ReAddOnGMPThread
(
const
RefPtr
<
GMPParent
>
&
aOld
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
LOGD
(
(
"
%
s
:
:
%
s
:
%
p
"
__CLASS__
__FUNCTION__
(
void
*
)
aOld
)
)
;
RefPtr
<
GMPParent
>
gmp
;
if
(
!
mShuttingDownOnGMPThread
)
{
gmp
=
ClonePlugin
(
aOld
)
;
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mPlugins
.
Contains
(
aOld
)
)
;
if
(
mPlugins
.
Contains
(
aOld
)
)
{
mPlugins
[
mPlugins
.
IndexOf
(
aOld
)
]
=
gmp
;
}
}
else
{
MutexAutoLock
lock
(
mMutex
)
;
mPlugins
.
RemoveElement
(
aOld
)
;
}
NS_DispatchToCurrentThread
(
WrapRunnableNM
(
&
Dummy
aOld
)
)
;
}
NS_IMETHODIMP
GeckoMediaPluginServiceParent
:
:
GetStorageDir
(
nsIFile
*
*
aOutFile
)
{
if
(
NS_WARN_IF
(
!
mStorageBaseDir
)
)
{
return
NS_ERROR_FAILURE
;
}
return
mStorageBaseDir
-
>
Clone
(
aOutFile
)
;
}
static
nsresult
WriteToFile
(
nsIFile
*
aPath
const
nsCString
&
aFileName
const
nsCString
&
aData
)
{
nsCOMPtr
<
nsIFile
>
path
;
nsresult
rv
=
aPath
-
>
Clone
(
getter_AddRefs
(
path
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
path
-
>
AppendNative
(
aFileName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
PRFileDesc
*
f
=
nullptr
;
rv
=
path
-
>
OpenNSPRFileDesc
(
PR_WRONLY
|
PR_CREATE_FILE
PR_IRWXU
&
f
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
int32_t
len
=
PR_Write
(
f
aData
.
get
(
)
aData
.
Length
(
)
)
;
PR_Close
(
f
)
;
if
(
NS_WARN_IF
(
len
<
0
|
|
(
size_t
)
len
!
=
aData
.
Length
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
static
nsresult
ReadFromFile
(
nsIFile
*
aPath
const
nsACString
&
aFileName
nsACString
&
aOutData
int32_t
aMaxLength
)
{
nsCOMPtr
<
nsIFile
>
path
;
nsresult
rv
=
aPath
-
>
Clone
(
getter_AddRefs
(
path
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
path
-
>
AppendNative
(
aFileName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
PRFileDesc
*
f
=
nullptr
;
rv
=
path
-
>
OpenNSPRFileDesc
(
PR_RDONLY
|
PR_CREATE_FILE
PR_IRWXU
&
f
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
auto
size
=
PR_Seek
(
f
0
PR_SEEK_END
)
;
PR_Seek
(
f
0
PR_SEEK_SET
)
;
if
(
size
>
aMaxLength
)
{
return
NS_ERROR_FAILURE
;
}
aOutData
.
SetLength
(
size
)
;
auto
len
=
PR_Read
(
f
aOutData
.
BeginWriting
(
)
size
)
;
PR_Close
(
f
)
;
if
(
NS_WARN_IF
(
len
!
=
size
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
ReadSalt
(
nsIFile
*
aPath
nsACString
&
aOutData
)
{
return
ReadFromFile
(
aPath
NS_LITERAL_CSTRING
(
"
salt
"
)
aOutData
NodeIdSaltLength
)
;
}
already_AddRefed
<
GMPStorage
>
GeckoMediaPluginServiceParent
:
:
GetMemoryStorageFor
(
const
nsACString
&
aNodeId
)
{
RefPtr
<
GMPStorage
>
s
;
if
(
!
mTempGMPStorage
.
Get
(
aNodeId
getter_AddRefs
(
s
)
)
)
{
s
=
CreateGMPMemoryStorage
(
)
;
mTempGMPStorage
.
Put
(
aNodeId
s
)
;
}
return
s
.
forget
(
)
;
}
NS_IMETHODIMP
GeckoMediaPluginServiceParent
:
:
IsPersistentStorageAllowed
(
const
nsACString
&
aNodeId
bool
*
aOutAllowed
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
NS_ENSURE_ARG
(
aOutAllowed
)
;
*
aOutAllowed
=
!
aNodeId
.
Equals
(
SHARED_GMP_DECODING_NODE_ID
)
&
&
mPersistentStorageAllowed
.
Get
(
aNodeId
)
;
return
NS_OK
;
}
nsresult
GeckoMediaPluginServiceParent
:
:
GetNodeId
(
const
nsAString
&
aOrigin
const
nsAString
&
aTopLevelOrigin
const
nsAString
&
aGMPName
bool
aInPrivateBrowsing
nsACString
&
aOutId
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
LOGD
(
(
"
%
s
:
:
%
s
:
(
%
s
%
s
)
%
s
"
__CLASS__
__FUNCTION__
NS_ConvertUTF16toUTF8
(
aOrigin
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aTopLevelOrigin
)
.
get
(
)
(
aInPrivateBrowsing
?
"
PrivateBrowsing
"
:
"
NonPrivateBrowsing
"
)
)
)
;
nsresult
rv
;
if
(
aGMPName
.
EqualsLiteral
(
"
gmp
-
widevinecdm
"
)
|
|
aOrigin
.
EqualsLiteral
(
"
null
"
)
|
|
aOrigin
.
IsEmpty
(
)
|
|
aTopLevelOrigin
.
EqualsLiteral
(
"
null
"
)
|
|
aTopLevelOrigin
.
IsEmpty
(
)
)
{
nsAutoCString
salt
;
rv
=
GenerateRandomPathName
(
salt
NodeIdSaltLength
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aOutId
=
salt
;
mPersistentStorageAllowed
.
Put
(
salt
false
)
;
return
NS_OK
;
}
const
uint32_t
hash
=
AddToHash
(
HashString
(
aOrigin
)
HashString
(
aTopLevelOrigin
)
)
;
if
(
aInPrivateBrowsing
)
{
const
uint32_t
pbHash
=
AddToHash
(
HashString
(
aGMPName
)
hash
)
;
nsCString
*
salt
=
nullptr
;
if
(
!
(
salt
=
mTempNodeIds
.
Get
(
pbHash
)
)
)
{
nsAutoCString
newSalt
;
rv
=
GenerateRandomPathName
(
newSalt
NodeIdSaltLength
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
salt
=
new
nsCString
(
newSalt
)
;
mTempNodeIds
.
Put
(
pbHash
salt
)
;
mPersistentStorageAllowed
.
Put
(
*
salt
false
)
;
}
aOutId
=
*
salt
;
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
path
;
rv
=
GetStorageDir
(
getter_AddRefs
(
path
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
path
-
>
Append
(
aGMPName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
path
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0700
)
;
if
(
rv
!
=
NS_ERROR_FILE_ALREADY_EXISTS
&
&
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
path
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
id
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
path
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0700
)
;
if
(
rv
!
=
NS_ERROR_FILE_ALREADY_EXISTS
&
&
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAutoCString
hashStr
;
hashStr
.
AppendInt
(
(
int64_t
)
hash
)
;
rv
=
path
-
>
AppendNative
(
hashStr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
path
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0700
)
;
if
(
rv
!
=
NS_ERROR_FILE_ALREADY_EXISTS
&
&
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIFile
>
saltFile
;
rv
=
path
-
>
Clone
(
getter_AddRefs
(
saltFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
saltFile
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
salt
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAutoCString
salt
;
bool
exists
=
false
;
rv
=
saltFile
-
>
Exists
(
&
exists
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
exists
)
{
nsresult
rv
=
GenerateRandomPathName
(
salt
NodeIdSaltLength
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
salt
.
Length
(
)
=
=
NodeIdSaltLength
)
;
rv
=
WriteToFile
(
path
NS_LITERAL_CSTRING
(
"
salt
"
)
salt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
WriteToFile
(
path
NS_LITERAL_CSTRING
(
"
origin
"
)
NS_ConvertUTF16toUTF8
(
aOrigin
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
WriteToFile
(
path
NS_LITERAL_CSTRING
(
"
topLevelOrigin
"
)
NS_ConvertUTF16toUTF8
(
aTopLevelOrigin
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
ReadSalt
(
path
salt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
aOutId
=
salt
;
mPersistentStorageAllowed
.
Put
(
salt
true
)
;
return
NS_OK
;
}
NS_IMETHODIMP
GeckoMediaPluginServiceParent
:
:
GetNodeId
(
const
nsAString
&
aOrigin
const
nsAString
&
aTopLevelOrigin
const
nsAString
&
aGMPName
bool
aInPrivateBrowsing
UniquePtr
<
GetNodeIdCallback
>
&
&
aCallback
)
{
nsCString
nodeId
;
nsresult
rv
=
GetNodeId
(
aOrigin
aTopLevelOrigin
aGMPName
aInPrivateBrowsing
nodeId
)
;
aCallback
-
>
Done
(
rv
nodeId
)
;
return
rv
;
}
static
bool
ExtractHostName
(
const
nsACString
&
aOrigin
nsACString
&
aOutData
)
{
nsCString
str
;
str
.
Assign
(
aOrigin
)
;
int
begin
=
str
.
Find
(
"
:
/
/
"
)
;
if
(
begin
=
=
-
1
)
{
return
false
;
}
int
end
=
str
.
RFind
(
"
:
"
)
;
if
(
end
!
=
begin
)
{
str
.
SetLength
(
end
)
;
}
nsDependentCSubstring
host
(
str
begin
+
3
)
;
aOutData
.
Assign
(
host
)
;
return
true
;
}
bool
MatchOrigin
(
nsIFile
*
aPath
const
nsACString
&
aSite
const
mozilla
:
:
OriginAttributesPattern
&
aPattern
)
{
static
const
uint32_t
MaxDomainLength
=
253
;
nsresult
rv
;
nsCString
str
;
nsCString
originNoSuffix
;
mozilla
:
:
PrincipalOriginAttributes
originAttributes
;
rv
=
ReadFromFile
(
aPath
NS_LITERAL_CSTRING
(
"
origin
"
)
str
MaxDomainLength
)
;
if
(
!
originAttributes
.
PopulateFromOrigin
(
str
originNoSuffix
)
)
{
return
false
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
ExtractHostName
(
originNoSuffix
str
)
&
&
str
.
Equals
(
aSite
)
&
&
aPattern
.
Matches
(
originAttributes
)
)
{
return
true
;
}
mozilla
:
:
PrincipalOriginAttributes
topLevelOriginAttributes
;
rv
=
ReadFromFile
(
aPath
NS_LITERAL_CSTRING
(
"
topLevelOrigin
"
)
str
MaxDomainLength
)
;
if
(
!
topLevelOriginAttributes
.
PopulateFromOrigin
(
str
originNoSuffix
)
)
{
return
false
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
ExtractHostName
(
originNoSuffix
str
)
&
&
str
.
Equals
(
aSite
)
&
&
aPattern
.
Matches
(
topLevelOriginAttributes
)
)
{
return
true
;
}
return
false
;
}
template
<
typename
T
>
static
void
KillPlugins
(
const
nsTArray
<
RefPtr
<
GMPParent
>
>
&
aPlugins
Mutex
&
aMutex
T
&
&
aFilter
)
{
nsTArray
<
RefPtr
<
GMPParent
>
>
pluginsToKill
;
{
MutexAutoLock
lock
(
aMutex
)
;
for
(
size_t
i
=
0
;
i
<
aPlugins
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
GMPParent
>
parent
(
aPlugins
[
i
]
)
;
if
(
aFilter
(
parent
)
)
{
pluginsToKill
.
AppendElement
(
parent
)
;
}
}
}
for
(
size_t
i
=
0
;
i
<
pluginsToKill
.
Length
(
)
;
i
+
+
)
{
pluginsToKill
[
i
]
-
>
CloseActive
(
false
)
;
pluginsToKill
[
i
]
-
>
AbortAsyncShutdown
(
)
;
}
}
static
nsresult
DeleteDir
(
nsIFile
*
aPath
)
{
bool
exists
=
false
;
nsresult
rv
=
aPath
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
exists
)
{
return
aPath
-
>
Remove
(
true
)
;
}
return
NS_OK
;
}
struct
NodeFilter
{
explicit
NodeFilter
(
const
nsTArray
<
nsCString
>
&
nodeIDs
)
:
mNodeIDs
(
nodeIDs
)
{
}
bool
operator
(
)
(
GMPParent
*
aParent
)
{
return
mNodeIDs
.
Contains
(
aParent
-
>
GetNodeId
(
)
)
;
}
private
:
const
nsTArray
<
nsCString
>
&
mNodeIDs
;
}
;
void
GeckoMediaPluginServiceParent
:
:
ClearNodeIdAndPlugin
(
DirectoryFilter
&
aFilter
)
{
nsCOMPtr
<
nsIFile
>
path
;
nsresult
rv
=
GetStorageDir
(
getter_AddRefs
(
path
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
DirectoryEnumerator
iter
(
path
DirectoryEnumerator
:
:
DirsOnly
)
;
for
(
nsCOMPtr
<
nsIFile
>
pluginDir
;
(
pluginDir
=
iter
.
Next
(
)
)
!
=
nullptr
;
)
{
ClearNodeIdAndPlugin
(
pluginDir
aFilter
)
;
}
}
void
GeckoMediaPluginServiceParent
:
:
ClearNodeIdAndPlugin
(
nsIFile
*
aPluginStorageDir
DirectoryFilter
&
aFilter
)
{
nsCOMPtr
<
nsIFile
>
path
=
CloneAndAppend
(
aPluginStorageDir
NS_LITERAL_STRING
(
"
id
"
)
)
;
if
(
!
path
)
{
return
;
}
nsTArray
<
nsCString
>
nodeIDsToClear
;
DirectoryEnumerator
iter
(
path
DirectoryEnumerator
:
:
DirsOnly
)
;
for
(
nsCOMPtr
<
nsIFile
>
dirEntry
;
(
dirEntry
=
iter
.
Next
(
)
)
!
=
nullptr
;
)
{
if
(
!
aFilter
(
dirEntry
)
)
{
continue
;
}
nsAutoCString
salt
;
if
(
NS_SUCCEEDED
(
ReadSalt
(
dirEntry
salt
)
)
)
{
nodeIDsToClear
.
AppendElement
(
salt
)
;
mPersistentStorageAllowed
.
Remove
(
salt
)
;
}
if
(
NS_FAILED
(
dirEntry
-
>
Remove
(
true
)
)
)
{
NS_WARNING
(
"
Failed
to
delete
the
directory
for
the
origin
pair
"
)
;
}
}
KillPlugins
(
mPlugins
mMutex
NodeFilter
(
nodeIDsToClear
)
)
;
path
=
CloneAndAppend
(
aPluginStorageDir
NS_LITERAL_STRING
(
"
storage
"
)
)
;
if
(
!
path
)
{
return
;
}
for
(
const
nsCString
&
nodeId
:
nodeIDsToClear
)
{
nsCOMPtr
<
nsIFile
>
dirEntry
;
nsresult
rv
=
path
-
>
Clone
(
getter_AddRefs
(
dirEntry
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
rv
=
dirEntry
-
>
AppendNative
(
nodeId
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
if
(
NS_FAILED
(
DeleteDir
(
dirEntry
)
)
)
{
NS_WARNING
(
"
Failed
to
delete
GMP
storage
directory
for
the
node
"
)
;
}
}
}
void
GeckoMediaPluginServiceParent
:
:
ForgetThisSiteOnGMPThread
(
const
nsACString
&
aSite
const
mozilla
:
:
OriginAttributesPattern
&
aPattern
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
LOGD
(
(
"
%
s
:
:
%
s
:
origin
=
%
s
"
__CLASS__
__FUNCTION__
aSite
.
Data
(
)
)
)
;
struct
OriginFilter
:
public
DirectoryFilter
{
explicit
OriginFilter
(
const
nsACString
&
aSite
const
mozilla
:
:
OriginAttributesPattern
&
aPattern
)
:
mSite
(
aSite
)
mPattern
(
aPattern
)
{
}
bool
operator
(
)
(
nsIFile
*
aPath
)
override
{
return
MatchOrigin
(
aPath
mSite
mPattern
)
;
}
private
:
const
nsACString
&
mSite
;
const
mozilla
:
:
OriginAttributesPattern
&
mPattern
;
}
filter
(
aSite
aPattern
)
;
ClearNodeIdAndPlugin
(
filter
)
;
}
void
GeckoMediaPluginServiceParent
:
:
ClearRecentHistoryOnGMPThread
(
PRTime
aSince
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
LOGD
(
(
"
%
s
:
:
%
s
:
since
=
%
lld
"
__CLASS__
__FUNCTION__
(
int64_t
)
aSince
)
)
;
struct
MTimeFilter
:
public
DirectoryFilter
{
explicit
MTimeFilter
(
PRTime
aSince
)
:
mSince
(
aSince
)
{
}
bool
IsModifiedAfter
(
nsIFile
*
aPath
)
{
PRTime
lastModified
;
nsresult
rv
=
aPath
-
>
GetLastModifiedTime
(
&
lastModified
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
lastModified
>
=
mSince
)
{
return
true
;
}
DirectoryEnumerator
iter
(
aPath
DirectoryEnumerator
:
:
FilesAndDirs
)
;
for
(
nsCOMPtr
<
nsIFile
>
dirEntry
;
(
dirEntry
=
iter
.
Next
(
)
)
!
=
nullptr
;
)
{
if
(
IsModifiedAfter
(
dirEntry
)
)
{
return
true
;
}
}
return
false
;
}
bool
operator
(
)
(
nsIFile
*
aPath
)
override
{
if
(
IsModifiedAfter
(
aPath
)
)
{
return
true
;
}
nsAutoCString
salt
;
if
(
NS_FAILED
(
ReadSalt
(
aPath
salt
)
)
)
{
return
false
;
}
nsCOMPtr
<
nsIFile
>
idDir
;
if
(
NS_FAILED
(
aPath
-
>
GetParent
(
getter_AddRefs
(
idDir
)
)
)
)
{
return
false
;
}
nsCOMPtr
<
nsIFile
>
temp
;
if
(
NS_FAILED
(
idDir
-
>
GetParent
(
getter_AddRefs
(
temp
)
)
)
)
{
return
false
;
}
if
(
NS_FAILED
(
temp
-
>
Append
(
NS_LITERAL_STRING
(
"
storage
"
)
)
)
)
{
return
false
;
}
return
NS_SUCCEEDED
(
temp
-
>
AppendNative
(
salt
)
)
&
&
IsModifiedAfter
(
temp
)
;
}
private
:
const
PRTime
mSince
;
}
filter
(
aSince
)
;
ClearNodeIdAndPlugin
(
filter
)
;
NS_DispatchToMainThread
(
new
NotifyObserversTask
(
"
gmp
-
clear
-
storage
-
complete
"
)
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
GeckoMediaPluginServiceParent
:
:
ForgetThisSite
(
const
nsAString
&
aSite
const
nsAString
&
aPattern
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mozilla
:
:
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aPattern
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
ForgetThisSiteNative
(
aSite
pattern
)
;
}
nsresult
GeckoMediaPluginServiceParent
:
:
ForgetThisSiteNative
(
const
nsAString
&
aSite
const
mozilla
:
:
OriginAttributesPattern
&
aPattern
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
GMPDispatch
(
NewRunnableMethod
<
nsCString
mozilla
:
:
OriginAttributesPattern
>
(
this
&
GeckoMediaPluginServiceParent
:
:
ForgetThisSiteOnGMPThread
NS_ConvertUTF16toUTF8
(
aSite
)
aPattern
)
)
;
}
static
bool
IsNodeIdValid
(
GMPParent
*
aParent
)
{
return
!
aParent
-
>
GetNodeId
(
)
.
IsEmpty
(
)
;
}
static
nsCOMPtr
<
nsIAsyncShutdownClient
>
GetShutdownBarrier
(
)
{
nsCOMPtr
<
nsIAsyncShutdownService
>
svc
=
services
:
:
GetAsyncShutdown
(
)
;
MOZ_RELEASE_ASSERT
(
svc
)
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
barrier
;
nsresult
rv
=
svc
-
>
GetXpcomWillShutdown
(
getter_AddRefs
(
barrier
)
)
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_RELEASE_ASSERT
(
barrier
)
;
return
barrier
.
forget
(
)
;
}
NS_IMETHODIMP
GeckoMediaPluginServiceParent
:
:
GetName
(
nsAString
&
aName
)
{
aName
=
NS_LITERAL_STRING
(
"
GeckoMediaPluginServiceParent
:
shutdown
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
GeckoMediaPluginServiceParent
:
:
GetState
(
nsIPropertyBag
*
*
)
{
return
NS_OK
;
}
NS_IMETHODIMP
GeckoMediaPluginServiceParent
:
:
BlockShutdown
(
nsIAsyncShutdownClient
*
)
{
return
NS_OK
;
}
void
GeckoMediaPluginServiceParent
:
:
ServiceUserCreated
(
)
{
MOZ_ASSERT
(
mServiceUserCount
>
=
0
)
;
if
(
+
+
mServiceUserCount
=
=
1
)
{
nsresult
rv
=
GetShutdownBarrier
(
)
-
>
AddBlocker
(
this
NS_LITERAL_STRING
(
__FILE__
)
__LINE__
NS_LITERAL_STRING
(
"
GeckoMediaPluginServiceParent
shutdown
"
)
)
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
void
GeckoMediaPluginServiceParent
:
:
ServiceUserDestroyed
(
)
{
MOZ_ASSERT
(
mServiceUserCount
>
0
)
;
if
(
-
-
mServiceUserCount
=
=
0
)
{
nsresult
rv
=
GetShutdownBarrier
(
)
-
>
RemoveBlocker
(
this
)
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
void
GeckoMediaPluginServiceParent
:
:
ClearStorage
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mGMPThread
)
;
LOGD
(
(
"
%
s
:
:
%
s
"
__CLASS__
__FUNCTION__
)
)
;
KillPlugins
(
mPlugins
mMutex
&
IsNodeIdValid
)
;
nsCOMPtr
<
nsIFile
>
path
;
nsresult
rv
=
GetStorageDir
(
getter_AddRefs
(
path
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
NS_FAILED
(
DeleteDir
(
path
)
)
)
{
NS_WARNING
(
"
Failed
to
delete
GMP
storage
directory
"
)
;
}
mTempGMPStorage
.
Clear
(
)
;
NS_DispatchToMainThread
(
new
NotifyObserversTask
(
"
gmp
-
clear
-
storage
-
complete
"
)
NS_DISPATCH_NORMAL
)
;
}
already_AddRefed
<
GMPParent
>
GeckoMediaPluginServiceParent
:
:
GetById
(
uint32_t
aPluginId
)
{
MutexAutoLock
lock
(
mMutex
)
;
for
(
const
RefPtr
<
GMPParent
>
&
gmp
:
mPlugins
)
{
if
(
gmp
-
>
GetPluginId
(
)
=
=
aPluginId
)
{
return
do_AddRef
(
gmp
)
;
}
}
return
nullptr
;
}
GMPServiceParent
:
:
~
GMPServiceParent
(
)
{
NS_DispatchToMainThread
(
NewRunnableMethod
(
mService
.
get
(
)
&
GeckoMediaPluginServiceParent
:
:
ServiceUserDestroyed
)
)
;
}
bool
GMPServiceParent
:
:
RecvSelectGMP
(
const
nsCString
&
aNodeId
const
nsCString
&
aAPI
nsTArray
<
nsCString
>
&
&
aTags
uint32_t
*
aOutPluginId
nsresult
*
aOutRv
)
{
if
(
mService
-
>
IsShuttingDown
(
)
)
{
*
aOutRv
=
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
;
return
true
;
}
RefPtr
<
GMPParent
>
gmp
=
mService
-
>
SelectPluginForAPI
(
aNodeId
aAPI
aTags
)
;
if
(
gmp
)
{
*
aOutPluginId
=
gmp
-
>
GetPluginId
(
)
;
*
aOutRv
=
NS_OK
;
}
else
{
*
aOutRv
=
NS_ERROR_FAILURE
;
}
nsCString
api
=
aTags
[
0
]
;
LOGD
(
(
"
%
s
:
%
p
returning
%
p
for
api
%
s
"
__FUNCTION__
(
void
*
)
this
(
void
*
)
gmp
api
.
get
(
)
)
)
;
return
true
;
}
bool
GMPServiceParent
:
:
RecvLaunchGMP
(
const
uint32_t
&
aPluginId
nsTArray
<
ProcessId
>
&
&
aAlreadyBridgedTo
ProcessId
*
aOutProcessId
nsCString
*
aOutDisplayName
nsresult
*
aOutRv
)
{
*
aOutRv
=
NS_OK
;
if
(
mService
-
>
IsShuttingDown
(
)
)
{
*
aOutRv
=
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
;
return
true
;
}
RefPtr
<
GMPParent
>
gmp
(
mService
-
>
GetById
(
aPluginId
)
)
;
if
(
!
gmp
)
{
*
aOutRv
=
NS_ERROR_FAILURE
;
return
true
;
}
if
(
!
gmp
-
>
EnsureProcessLoaded
(
aOutProcessId
)
)
{
return
false
;
}
*
aOutDisplayName
=
gmp
-
>
GetDisplayName
(
)
;
return
aAlreadyBridgedTo
.
Contains
(
*
aOutProcessId
)
|
|
gmp
-
>
Bridge
(
this
)
;
}
bool
GMPServiceParent
:
:
RecvGetGMPNodeId
(
const
nsString
&
aOrigin
const
nsString
&
aTopLevelOrigin
const
nsString
&
aGMPName
const
bool
&
aInPrivateBrowsing
nsCString
*
aID
)
{
nsresult
rv
=
mService
-
>
GetNodeId
(
aOrigin
aTopLevelOrigin
aGMPName
aInPrivateBrowsing
*
aID
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
bool
GMPServiceParent
:
:
RecvGetGMPPluginVersionForAPI
(
const
nsCString
&
aAPI
nsTArray
<
nsCString
>
&
&
aTags
bool
*
aHasPlugin
nsCString
*
aVersion
)
{
RefPtr
<
GeckoMediaPluginServiceParent
>
service
=
GeckoMediaPluginServiceParent
:
:
GetSingleton
(
)
;
return
service
&
&
NS_SUCCEEDED
(
service
-
>
GetPluginVersionForAPI
(
aAPI
&
aTags
aHasPlugin
*
aVersion
)
)
;
}
class
DeleteGMPServiceParent
:
public
mozilla
:
:
Runnable
{
public
:
explicit
DeleteGMPServiceParent
(
GMPServiceParent
*
aToDelete
)
:
mToDelete
(
aToDelete
)
{
}
NS_IMETHOD
Run
(
)
override
{
return
NS_OK
;
}
private
:
nsAutoPtr
<
GMPServiceParent
>
mToDelete
;
}
;
void
GMPServiceParent
:
:
CloseTransport
(
Monitor
*
aSyncMonitor
bool
*
aCompleted
)
{
MOZ_ASSERT
(
MessageLoop
:
:
current
(
)
=
=
XRE_GetIOMessageLoop
(
)
)
;
MonitorAutoLock
lock
(
*
aSyncMonitor
)
;
SetTransport
(
nullptr
)
;
*
aCompleted
=
true
;
lock
.
NotifyAll
(
)
;
}
void
GMPServiceParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
Monitor
monitor
(
"
DeleteGMPServiceParent
"
)
;
bool
completed
=
false
;
MonitorAutoLock
lock
(
monitor
)
;
RefPtr
<
Runnable
>
task
=
NewNonOwningRunnableMethod
<
Monitor
*
bool
*
>
(
this
&
GMPServiceParent
:
:
CloseTransport
&
monitor
&
completed
)
;
XRE_GetIOMessageLoop
(
)
-
>
PostTask
(
Move
(
task
.
forget
(
)
)
)
;
while
(
!
completed
)
{
lock
.
Wait
(
)
;
}
NS_DispatchToCurrentThread
(
new
DeleteGMPServiceParent
(
this
)
)
;
}
class
OpenPGMPServiceParent
:
public
mozilla
:
:
Runnable
{
public
:
OpenPGMPServiceParent
(
GMPServiceParent
*
aGMPServiceParent
mozilla
:
:
ipc
:
:
Transport
*
aTransport
base
:
:
ProcessId
aOtherPid
bool
*
aResult
)
:
mGMPServiceParent
(
aGMPServiceParent
)
mTransport
(
aTransport
)
mOtherPid
(
aOtherPid
)
mResult
(
aResult
)
{
}
NS_IMETHOD
Run
(
)
override
{
*
mResult
=
mGMPServiceParent
-
>
Open
(
mTransport
mOtherPid
XRE_GetIOMessageLoop
(
)
ipc
:
:
ParentSide
)
;
return
NS_OK
;
}
private
:
GMPServiceParent
*
mGMPServiceParent
;
mozilla
:
:
ipc
:
:
Transport
*
mTransport
;
base
:
:
ProcessId
mOtherPid
;
bool
*
mResult
;
}
;
PGMPServiceParent
*
GMPServiceParent
:
:
Create
(
Transport
*
aTransport
ProcessId
aOtherPid
)
{
RefPtr
<
GeckoMediaPluginServiceParent
>
gmp
=
GeckoMediaPluginServiceParent
:
:
GetSingleton
(
)
;
if
(
gmp
-
>
mShuttingDown
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIThread
>
gmpThread
;
nsresult
rv
=
gmp
-
>
GetThread
(
getter_AddRefs
(
gmpThread
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
nsAutoPtr
<
GMPServiceParent
>
serviceParent
(
new
GMPServiceParent
(
gmp
)
)
;
bool
ok
;
rv
=
gmpThread
-
>
Dispatch
(
new
OpenPGMPServiceParent
(
serviceParent
aTransport
aOtherPid
&
ok
)
NS_DISPATCH_SYNC
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
ok
)
{
return
nullptr
;
}
return
serviceParent
.
forget
(
)
;
}
}
}
