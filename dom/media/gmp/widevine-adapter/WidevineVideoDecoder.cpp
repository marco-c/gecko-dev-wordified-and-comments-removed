#
include
"
WidevineVideoDecoder
.
h
"
#
include
"
WidevineUtils
.
h
"
#
include
"
WidevineVideoFrame
.
h
"
#
include
"
mozilla
/
Move
.
h
"
using
namespace
cdm
;
namespace
mozilla
{
WidevineVideoDecoder
:
:
WidevineVideoDecoder
(
GMPVideoHost
*
aVideoHost
RefPtr
<
CDMWrapper
>
aCDMWrapper
)
:
mVideoHost
(
aVideoHost
)
mCDMWrapper
(
Move
(
aCDMWrapper
)
)
mSentInput
(
false
)
mCodecType
(
kGMPVideoCodecInvalid
)
mReturnOutputCallDepth
(
0
)
mDrainPending
(
false
)
mResetInProgress
(
false
)
{
MOZ_ASSERT
(
mCDMWrapper
)
;
Log
(
"
WidevineVideoDecoder
created
this
=
%
p
"
this
)
;
AddRef
(
)
;
}
WidevineVideoDecoder
:
:
~
WidevineVideoDecoder
(
)
{
Log
(
"
WidevineVideoDecoder
destroyed
this
=
%
p
"
this
)
;
}
static
VideoDecoderConfig
:
:
VideoCodecProfile
ToCDMH264Profile
(
uint8_t
aProfile
)
{
switch
(
aProfile
)
{
case
66
:
return
VideoDecoderConfig
:
:
kH264ProfileBaseline
;
case
77
:
return
VideoDecoderConfig
:
:
kH264ProfileMain
;
case
88
:
return
VideoDecoderConfig
:
:
kH264ProfileExtended
;
case
100
:
return
VideoDecoderConfig
:
:
kH264ProfileHigh
;
case
110
:
return
VideoDecoderConfig
:
:
kH264ProfileHigh10
;
case
122
:
return
VideoDecoderConfig
:
:
kH264ProfileHigh422
;
case
144
:
return
VideoDecoderConfig
:
:
kH264ProfileHigh444Predictive
;
}
return
VideoDecoderConfig
:
:
kUnknownVideoCodecProfile
;
}
void
WidevineVideoDecoder
:
:
InitDecode
(
const
GMPVideoCodec
&
aCodecSettings
const
uint8_t
*
aCodecSpecific
uint32_t
aCodecSpecificLength
GMPVideoDecoderCallback
*
aCallback
int32_t
aCoreCount
)
{
mCallback
=
aCallback
;
VideoDecoderConfig
config
;
mCodecType
=
aCodecSettings
.
mCodecType
;
if
(
mCodecType
=
=
kGMPVideoCodecH264
)
{
config
.
codec
=
VideoDecoderConfig
:
:
kCodecH264
;
const
GMPVideoCodecH264
*
h264
=
(
const
GMPVideoCodecH264
*
)
(
aCodecSpecific
)
;
config
.
profile
=
ToCDMH264Profile
(
h264
-
>
mAVCC
.
mProfile
)
;
}
else
if
(
mCodecType
=
=
kGMPVideoCodecVP8
)
{
config
.
codec
=
VideoDecoderConfig
:
:
kCodecVp8
;
config
.
profile
=
VideoDecoderConfig
:
:
kProfileNotNeeded
;
}
else
if
(
mCodecType
=
=
kGMPVideoCodecVP9
)
{
config
.
codec
=
VideoDecoderConfig
:
:
kCodecVp9
;
config
.
profile
=
VideoDecoderConfig
:
:
kProfileNotNeeded
;
}
else
{
mCallback
-
>
Error
(
GMPInvalidArgErr
)
;
return
;
}
config
.
format
=
kYv12
;
config
.
coded_size
=
Size
(
aCodecSettings
.
mWidth
aCodecSettings
.
mHeight
)
;
nsTArray
<
uint8_t
>
extraData
;
if
(
aCodecSpecificLength
)
{
extraData
.
AppendElements
(
aCodecSpecific
+
1
aCodecSpecificLength
-
1
)
;
config
.
extra_data
=
extraData
.
Elements
(
)
;
config
.
extra_data_size
=
extraData
.
Length
(
)
;
}
Status
rv
=
CDM
(
)
-
>
InitializeVideoDecoder
(
config
)
;
if
(
rv
!
=
kSuccess
)
{
mCallback
-
>
Error
(
ToGMPErr
(
rv
)
)
;
return
;
}
Log
(
"
WidevineVideoDecoder
:
:
InitDecode
(
)
rv
=
%
d
"
rv
)
;
}
void
WidevineVideoDecoder
:
:
Decode
(
GMPVideoEncodedFrame
*
aInputFrame
bool
aMissingFrames
const
uint8_t
*
aCodecSpecificInfo
uint32_t
aCodecSpecificInfoLength
int64_t
aRenderTimeMs
)
{
MOZ_ASSERT
(
!
mDrainPending
)
;
mFrameDurations
[
aInputFrame
-
>
TimeStamp
(
)
]
=
aInputFrame
-
>
Duration
(
)
;
mSentInput
=
true
;
InputBuffer
sample
;
nsTArray
<
SubsampleEntry
>
subsamples
;
InitInputBuffer
(
aInputFrame
-
>
GetDecryptionData
(
)
aInputFrame
-
>
TimeStamp
(
)
aInputFrame
-
>
Buffer
(
)
aInputFrame
-
>
Size
(
)
sample
subsamples
)
;
WidevineVideoFrame
frame
;
Status
rv
=
CDM
(
)
-
>
DecryptAndDecodeFrame
(
sample
&
frame
)
;
Log
(
"
WidevineVideoDecoder
:
:
Decode
(
timestamp
=
%
lld
)
rv
=
%
d
"
sample
.
timestamp
rv
)
;
aInputFrame
-
>
Destroy
(
)
;
aInputFrame
=
nullptr
;
if
(
rv
=
=
kSuccess
)
{
if
(
!
ReturnOutput
(
frame
)
)
{
Log
(
"
WidevineVideoDecoder
:
:
Decode
(
)
Failed
in
ReturnOutput
(
)
"
)
;
mCallback
-
>
Error
(
GMPDecodeErr
)
;
return
;
}
MOZ_ASSERT
(
!
mResetInProgress
)
;
if
(
mFrameAllocationQueue
.
empty
(
)
)
{
MOZ_ASSERT
(
mCDMWrapper
)
;
mCallback
-
>
InputDataExhausted
(
)
;
}
}
else
if
(
rv
=
=
kNeedMoreData
)
{
MOZ_ASSERT
(
mCDMWrapper
)
;
mCallback
-
>
InputDataExhausted
(
)
;
}
else
{
mCallback
-
>
Error
(
ToGMPErr
(
rv
)
)
;
}
if
(
mDrainPending
&
&
mReturnOutputCallDepth
=
=
0
)
{
Drain
(
)
;
}
}
class
CounterHelper
{
public
:
explicit
CounterHelper
(
int32_t
&
counter
)
:
mCounter
(
counter
)
{
mCounter
+
+
;
}
~
CounterHelper
(
)
{
mCounter
-
-
;
}
private
:
int32_t
&
mCounter
;
}
;
class
FrameDestroyerHelper
{
public
:
explicit
FrameDestroyerHelper
(
GMPVideoi420Frame
*
&
frame
)
:
frame
(
frame
)
{
}
~
FrameDestroyerHelper
(
)
{
if
(
frame
)
{
frame
-
>
Destroy
(
)
;
}
frame
=
nullptr
;
}
void
ForgetFrame
(
)
{
frame
=
nullptr
;
}
private
:
GMPVideoi420Frame
*
frame
;
}
;
bool
WidevineVideoDecoder
:
:
ReturnOutput
(
WidevineVideoFrame
&
aCDMFrame
)
{
MOZ_ASSERT
(
mReturnOutputCallDepth
>
=
0
)
;
CounterHelper
counterHelper
(
mReturnOutputCallDepth
)
;
mFrameAllocationQueue
.
push_back
(
Move
(
aCDMFrame
)
)
;
if
(
mReturnOutputCallDepth
>
1
)
{
return
true
;
}
while
(
!
mFrameAllocationQueue
.
empty
(
)
)
{
MOZ_ASSERT
(
mReturnOutputCallDepth
=
=
1
)
;
MOZ_ASSERT
(
!
mResetInProgress
)
;
WidevineVideoFrame
currentCDMFrame
=
Move
(
mFrameAllocationQueue
.
front
(
)
)
;
mFrameAllocationQueue
.
pop_front
(
)
;
GMPVideoFrame
*
f
=
nullptr
;
auto
err
=
mVideoHost
-
>
CreateFrame
(
kGMPI420VideoFrame
&
f
)
;
if
(
GMP_FAILED
(
err
)
|
|
!
f
)
{
Log
(
"
Failed
to
create
i420
frame
!
\
n
"
)
;
return
false
;
}
auto
gmpFrame
=
static_cast
<
GMPVideoi420Frame
*
>
(
f
)
;
FrameDestroyerHelper
frameDestroyerHelper
(
gmpFrame
)
;
Size
size
=
currentCDMFrame
.
Size
(
)
;
const
int32_t
yStride
=
currentCDMFrame
.
Stride
(
VideoFrame
:
:
kYPlane
)
;
const
int32_t
uStride
=
currentCDMFrame
.
Stride
(
VideoFrame
:
:
kUPlane
)
;
const
int32_t
vStride
=
currentCDMFrame
.
Stride
(
VideoFrame
:
:
kVPlane
)
;
const
int32_t
halfHeight
=
size
.
height
/
2
;
err
=
gmpFrame
-
>
CreateEmptyFrame
(
size
.
width
size
.
height
yStride
uStride
vStride
)
;
MOZ_ASSERT
(
mReturnOutputCallDepth
=
=
1
)
;
ENSURE_GMP_SUCCESS
(
err
false
)
;
if
(
mResetInProgress
)
{
MOZ_ASSERT
(
mCDMWrapper
)
;
MOZ_ASSERT
(
mFrameAllocationQueue
.
empty
(
)
)
;
CompleteReset
(
)
;
return
true
;
}
err
=
gmpFrame
-
>
SetWidth
(
size
.
width
)
;
ENSURE_GMP_SUCCESS
(
err
false
)
;
err
=
gmpFrame
-
>
SetHeight
(
size
.
height
)
;
ENSURE_GMP_SUCCESS
(
err
false
)
;
Buffer
*
buffer
=
currentCDMFrame
.
FrameBuffer
(
)
;
uint8_t
*
outBuffer
=
gmpFrame
-
>
Buffer
(
kGMPYPlane
)
;
ENSURE_TRUE
(
outBuffer
!
=
nullptr
false
)
;
MOZ_ASSERT
(
gmpFrame
-
>
AllocatedSize
(
kGMPYPlane
)
>
=
yStride
*
size
.
height
)
;
memcpy
(
outBuffer
buffer
-
>
Data
(
)
+
currentCDMFrame
.
PlaneOffset
(
VideoFrame
:
:
kYPlane
)
yStride
*
size
.
height
)
;
outBuffer
=
gmpFrame
-
>
Buffer
(
kGMPUPlane
)
;
ENSURE_TRUE
(
outBuffer
!
=
nullptr
false
)
;
MOZ_ASSERT
(
gmpFrame
-
>
AllocatedSize
(
kGMPUPlane
)
>
=
uStride
*
halfHeight
)
;
memcpy
(
outBuffer
buffer
-
>
Data
(
)
+
currentCDMFrame
.
PlaneOffset
(
VideoFrame
:
:
kUPlane
)
uStride
*
halfHeight
)
;
outBuffer
=
gmpFrame
-
>
Buffer
(
kGMPVPlane
)
;
ENSURE_TRUE
(
outBuffer
!
=
nullptr
false
)
;
MOZ_ASSERT
(
gmpFrame
-
>
AllocatedSize
(
kGMPVPlane
)
>
=
vStride
*
halfHeight
)
;
memcpy
(
outBuffer
buffer
-
>
Data
(
)
+
currentCDMFrame
.
PlaneOffset
(
VideoFrame
:
:
kVPlane
)
vStride
*
halfHeight
)
;
gmpFrame
-
>
SetTimestamp
(
currentCDMFrame
.
Timestamp
(
)
)
;
auto
d
=
mFrameDurations
.
find
(
currentCDMFrame
.
Timestamp
(
)
)
;
if
(
d
!
=
mFrameDurations
.
end
(
)
)
{
gmpFrame
-
>
SetDuration
(
d
-
>
second
)
;
mFrameDurations
.
erase
(
d
)
;
}
frameDestroyerHelper
.
ForgetFrame
(
)
;
mCallback
-
>
Decoded
(
gmpFrame
)
;
}
return
true
;
}
void
WidevineVideoDecoder
:
:
Reset
(
)
{
Log
(
"
WidevineVideoDecoder
:
:
Reset
(
)
mSentInput
=
%
d
"
mSentInput
)
;
MOZ_ASSERT
(
!
mDrainPending
)
;
mResetInProgress
=
true
;
if
(
mSentInput
)
{
CDM
(
)
-
>
ResetDecoder
(
kStreamTypeVideo
)
;
}
mFrameAllocationQueue
.
clear
(
)
;
mFrameDurations
.
clear
(
)
;
if
(
mReturnOutputCallDepth
=
=
0
)
{
CompleteReset
(
)
;
}
}
void
WidevineVideoDecoder
:
:
CompleteReset
(
)
{
mCallback
-
>
ResetComplete
(
)
;
mSentInput
=
false
;
mResetInProgress
=
false
;
}
void
WidevineVideoDecoder
:
:
Drain
(
)
{
Log
(
"
WidevineVideoDecoder
:
:
Drain
(
)
"
)
;
if
(
mReturnOutputCallDepth
>
0
)
{
Log
(
"
Drain
call
is
reentrant
postponing
drain
"
)
;
mDrainPending
=
true
;
return
;
}
Status
rv
=
kSuccess
;
while
(
rv
=
=
kSuccess
)
{
WidevineVideoFrame
frame
;
InputBuffer
sample
;
Status
rv
=
CDM
(
)
-
>
DecryptAndDecodeFrame
(
sample
&
frame
)
;
Log
(
"
WidevineVideoDecoder
:
:
Drain
(
)
;
DecryptAndDecodeFrame
(
)
rv
=
%
d
"
rv
)
;
if
(
frame
.
Format
(
)
=
=
kUnknownVideoFormat
)
{
break
;
}
if
(
rv
=
=
kSuccess
)
{
if
(
!
ReturnOutput
(
frame
)
)
{
Log
(
"
WidevineVideoDecoder
:
:
Decode
(
)
Failed
in
ReturnOutput
(
)
"
)
;
}
}
}
MOZ_ASSERT
(
!
mResetInProgress
)
;
CDM
(
)
-
>
ResetDecoder
(
kStreamTypeVideo
)
;
mDrainPending
=
false
;
mCallback
-
>
DrainComplete
(
)
;
}
void
WidevineVideoDecoder
:
:
DecodingComplete
(
)
{
Log
(
"
WidevineVideoDecoder
:
:
DecodingComplete
(
)
"
)
;
if
(
mCDMWrapper
)
{
if
(
mCallback
)
{
CDM
(
)
-
>
DeinitializeDecoder
(
kStreamTypeVideo
)
;
}
else
{
Log
(
"
WideVineDecoder
:
:
DecodingComplete
(
)
Decoder
was
not
fully
initialized
!
"
)
;
}
mCDMWrapper
=
nullptr
;
}
Release
(
)
;
}
}
