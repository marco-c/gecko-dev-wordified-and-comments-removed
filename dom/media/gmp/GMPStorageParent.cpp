#
include
"
GMPStorageParent
.
h
"
#
include
"
plhash
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
GMPParent
.
h
"
#
include
"
gmp
-
storage
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
include
"
mozilla
/
Endian
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
prio
.
h
"
#
include
"
mozIGeckoMediaPluginService
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
namespace
mozilla
{
#
ifdef
LOG
#
undef
LOG
#
endif
extern
PRLogModuleInfo
*
GetGMPLog
(
)
;
#
define
LOGD
(
msg
)
MOZ_LOG
(
GetGMPLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
msg
)
#
define
LOG
(
level
msg
)
MOZ_LOG
(
GetGMPLog
(
)
(
level
)
msg
)
namespace
gmp
{
static
nsresult
GetGMPStorageDir
(
nsIFile
*
*
aTempDir
const
nsCString
&
aNodeId
)
{
if
(
NS_WARN_IF
(
!
aTempDir
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
mozIGeckoMediaPluginChromeService
>
mps
=
do_GetService
(
"
mozilla
.
org
/
gecko
-
media
-
plugin
-
service
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mps
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIFile
>
tmpFile
;
nsresult
rv
=
mps
-
>
GetStorageDir
(
getter_AddRefs
(
tmpFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
tmpFile
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
storage
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
tmpFile
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0700
)
;
if
(
rv
!
=
NS_ERROR_FILE_ALREADY_EXISTS
&
&
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
tmpFile
-
>
AppendNative
(
aNodeId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
tmpFile
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0700
)
;
if
(
rv
!
=
NS_ERROR_FILE_ALREADY_EXISTS
&
&
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
tmpFile
.
forget
(
aTempDir
)
;
return
NS_OK
;
}
class
GMPDiskStorage
:
public
GMPStorage
{
public
:
explicit
GMPDiskStorage
(
const
nsCString
&
aNodeId
)
:
mNodeId
(
aNodeId
)
{
}
~
GMPDiskStorage
(
)
{
for
(
auto
iter
=
mRecords
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Record
*
record
=
iter
.
UserData
(
)
;
if
(
record
-
>
mFileDesc
)
{
PR_Close
(
record
-
>
mFileDesc
)
;
record
-
>
mFileDesc
=
nullptr
;
}
}
}
nsresult
Init
(
)
{
nsCOMPtr
<
nsIFile
>
storageDir
;
nsresult
rv
=
GetGMPStorageDir
(
getter_AddRefs
(
storageDir
)
mNodeId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISimpleEnumerator
>
iter
;
rv
=
storageDir
-
>
GetDirectoryEntries
(
getter_AddRefs
(
iter
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
hasMore
;
while
(
NS_SUCCEEDED
(
iter
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
supports
;
rv
=
iter
-
>
GetNext
(
getter_AddRefs
(
supports
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
nsCOMPtr
<
nsIFile
>
dirEntry
(
do_QueryInterface
(
supports
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
PRFileDesc
*
fd
=
nullptr
;
if
(
NS_FAILED
(
dirEntry
-
>
OpenNSPRFileDesc
(
PR_RDONLY
0
&
fd
)
)
)
{
continue
;
}
int32_t
recordLength
=
0
;
nsCString
recordName
;
nsresult
err
=
ReadRecordMetadata
(
fd
recordLength
recordName
)
;
PR_Close
(
fd
)
;
if
(
NS_FAILED
(
err
)
)
{
dirEntry
-
>
Remove
(
false
)
;
continue
;
}
nsAutoString
filename
;
rv
=
dirEntry
-
>
GetLeafName
(
filename
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
mRecords
.
Put
(
recordName
new
Record
(
filename
recordName
)
)
;
}
return
NS_OK
;
}
GMPErr
Open
(
const
nsCString
&
aRecordName
)
override
{
MOZ_ASSERT
(
!
IsOpen
(
aRecordName
)
)
;
nsresult
rv
;
Record
*
record
=
nullptr
;
if
(
!
mRecords
.
Get
(
aRecordName
&
record
)
)
{
nsAutoString
filename
;
rv
=
GetUnusedFilename
(
aRecordName
filename
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
GMPGenericErr
;
}
record
=
new
Record
(
filename
aRecordName
)
;
mRecords
.
Put
(
aRecordName
record
)
;
}
MOZ_ASSERT
(
record
)
;
if
(
record
-
>
mFileDesc
)
{
NS_WARNING
(
"
Tried
to
open
already
open
record
"
)
;
return
GMPRecordInUse
;
}
rv
=
OpenStorageFile
(
record
-
>
mFilename
ReadWrite
&
record
-
>
mFileDesc
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
GMPGenericErr
;
}
MOZ_ASSERT
(
IsOpen
(
aRecordName
)
)
;
return
GMPNoErr
;
}
bool
IsOpen
(
const
nsCString
&
aRecordName
)
override
{
Record
*
record
=
nullptr
;
return
mRecords
.
Get
(
aRecordName
&
record
)
&
&
!
!
record
-
>
mFileDesc
;
}
GMPErr
Read
(
const
nsCString
&
aRecordName
nsTArray
<
uint8_t
>
&
aOutBytes
)
override
{
if
(
!
IsOpen
(
aRecordName
)
)
{
return
GMPClosedErr
;
}
Record
*
record
=
nullptr
;
mRecords
.
Get
(
aRecordName
&
record
)
;
MOZ_ASSERT
(
record
&
&
!
!
record
-
>
mFileDesc
)
;
aOutBytes
.
SetLength
(
0
)
;
int32_t
recordLength
=
0
;
nsCString
recordName
;
nsresult
err
=
ReadRecordMetadata
(
record
-
>
mFileDesc
recordLength
recordName
)
;
if
(
NS_FAILED
(
err
)
|
|
recordLength
=
=
0
)
{
return
GMPNoErr
;
}
if
(
!
aRecordName
.
Equals
(
recordName
)
)
{
NS_WARNING
(
"
Record
file
contains
some
other
record
'
s
contents
!
"
)
;
return
GMPRecordCorrupted
;
}
if
(
PR_Available
(
record
-
>
mFileDesc
)
!
=
recordLength
)
{
NS_WARNING
(
"
Record
file
length
mismatch
!
"
)
;
return
GMPRecordCorrupted
;
}
aOutBytes
.
SetLength
(
recordLength
)
;
int32_t
bytesRead
=
PR_Read
(
record
-
>
mFileDesc
aOutBytes
.
Elements
(
)
recordLength
)
;
return
(
bytesRead
=
=
recordLength
)
?
GMPNoErr
:
GMPRecordCorrupted
;
}
GMPErr
Write
(
const
nsCString
&
aRecordName
const
nsTArray
<
uint8_t
>
&
aBytes
)
override
{
if
(
!
IsOpen
(
aRecordName
)
)
{
return
GMPClosedErr
;
}
Record
*
record
=
nullptr
;
mRecords
.
Get
(
aRecordName
&
record
)
;
MOZ_ASSERT
(
record
&
&
!
!
record
-
>
mFileDesc
)
;
PR_Close
(
record
-
>
mFileDesc
)
;
record
-
>
mFileDesc
=
nullptr
;
if
(
aBytes
.
Length
(
)
=
=
0
)
{
nsresult
rv
=
RemoveStorageFile
(
record
-
>
mFilename
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
}
else
{
return
GMPNoErr
;
}
}
if
(
NS_FAILED
(
OpenStorageFile
(
record
-
>
mFilename
Truncate
&
record
-
>
mFileDesc
)
)
)
{
return
GMPGenericErr
;
}
int32_t
bytesWritten
=
0
;
char
buf
[
sizeof
(
uint32_t
)
]
=
{
0
}
;
LittleEndian
:
:
writeUint32
(
buf
aRecordName
.
Length
(
)
)
;
bytesWritten
=
PR_Write
(
record
-
>
mFileDesc
buf
MOZ_ARRAY_LENGTH
(
buf
)
)
;
if
(
bytesWritten
!
=
MOZ_ARRAY_LENGTH
(
buf
)
)
{
NS_WARNING
(
"
Failed
to
write
GMPStorage
record
name
length
.
"
)
;
return
GMPRecordCorrupted
;
}
bytesWritten
=
PR_Write
(
record
-
>
mFileDesc
aRecordName
.
get
(
)
aRecordName
.
Length
(
)
)
;
if
(
bytesWritten
!
=
(
int32_t
)
aRecordName
.
Length
(
)
)
{
NS_WARNING
(
"
Failed
to
write
GMPStorage
record
name
.
"
)
;
return
GMPRecordCorrupted
;
}
bytesWritten
=
PR_Write
(
record
-
>
mFileDesc
aBytes
.
Elements
(
)
aBytes
.
Length
(
)
)
;
if
(
bytesWritten
!
=
(
int32_t
)
aBytes
.
Length
(
)
)
{
NS_WARNING
(
"
Failed
to
write
GMPStorage
record
data
.
"
)
;
return
GMPRecordCorrupted
;
}
PR_Sync
(
record
-
>
mFileDesc
)
;
return
GMPNoErr
;
}
GMPErr
GetRecordNames
(
nsTArray
<
nsCString
>
&
aOutRecordNames
)
override
{
for
(
auto
iter
=
mRecords
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aOutRecordNames
.
AppendElement
(
iter
.
UserData
(
)
-
>
mRecordName
)
;
}
return
GMPNoErr
;
}
void
Close
(
const
nsCString
&
aRecordName
)
override
{
Record
*
record
=
nullptr
;
mRecords
.
Get
(
aRecordName
&
record
)
;
if
(
record
&
&
!
!
record
-
>
mFileDesc
)
{
PR_Close
(
record
-
>
mFileDesc
)
;
record
-
>
mFileDesc
=
nullptr
;
}
MOZ_ASSERT
(
!
IsOpen
(
aRecordName
)
)
;
}
private
:
nsresult
GetUnusedFilename
(
const
nsACString
&
aRecordName
nsString
&
aOutFilename
)
{
nsCOMPtr
<
nsIFile
>
storageDir
;
nsresult
rv
=
GetGMPStorageDir
(
getter_AddRefs
(
storageDir
)
mNodeId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
uint64_t
recordNameHash
=
HashString
(
PromiseFlatCString
(
aRecordName
)
.
get
(
)
)
;
for
(
int
i
=
0
;
i
<
1000000
;
i
+
+
)
{
nsCOMPtr
<
nsIFile
>
f
;
rv
=
storageDir
-
>
Clone
(
getter_AddRefs
(
f
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAutoString
hashStr
;
hashStr
.
AppendInt
(
recordNameHash
)
;
rv
=
f
-
>
Append
(
hashStr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
exists
=
false
;
f
-
>
Exists
(
&
exists
)
;
if
(
!
exists
)
{
aOutFilename
=
hashStr
;
return
NS_OK
;
}
else
{
+
+
recordNameHash
;
continue
;
}
}
NS_WARNING
(
"
GetUnusedFilename
had
extreme
hash
collision
!
"
)
;
return
NS_ERROR_FAILURE
;
}
enum
OpenFileMode
{
ReadWrite
Truncate
}
;
nsresult
OpenStorageFile
(
const
nsAString
&
aFileLeafName
const
OpenFileMode
aMode
PRFileDesc
*
*
aOutFD
)
{
MOZ_ASSERT
(
aOutFD
)
;
nsCOMPtr
<
nsIFile
>
f
;
nsresult
rv
=
GetGMPStorageDir
(
getter_AddRefs
(
f
)
mNodeId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
f
-
>
Append
(
aFileLeafName
)
;
auto
mode
=
PR_RDWR
|
PR_CREATE_FILE
;
if
(
aMode
=
=
Truncate
)
{
mode
|
=
PR_TRUNCATE
;
}
return
f
-
>
OpenNSPRFileDesc
(
mode
PR_IRWXU
aOutFD
)
;
}
nsresult
ReadRecordMetadata
(
PRFileDesc
*
aFd
int32_t
&
aOutRecordLength
nsACString
&
aOutRecordName
)
{
int32_t
offset
=
PR_Seek
(
aFd
0
PR_SEEK_END
)
;
PR_Seek
(
aFd
0
PR_SEEK_SET
)
;
if
(
offset
<
0
|
|
offset
>
GMP_MAX_RECORD_SIZE
)
{
return
NS_ERROR_FAILURE
;
}
const
uint32_t
fileLength
=
static_cast
<
uint32_t
>
(
offset
)
;
if
(
fileLength
<
sizeof
(
uint32_t
)
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
recordNameLength
=
0
;
char
buf
[
sizeof
(
recordNameLength
)
]
=
{
0
}
;
int32_t
bytesRead
=
PR_Read
(
aFd
&
buf
sizeof
(
recordNameLength
)
)
;
recordNameLength
=
LittleEndian
:
:
readUint32
(
buf
)
;
if
(
sizeof
(
recordNameLength
)
!
=
bytesRead
|
|
recordNameLength
=
=
0
|
|
recordNameLength
+
sizeof
(
recordNameLength
)
>
fileLength
|
|
recordNameLength
>
GMP_MAX_RECORD_NAME_SIZE
)
{
return
NS_ERROR_FAILURE
;
}
nsCString
recordName
;
recordName
.
SetLength
(
recordNameLength
)
;
bytesRead
=
PR_Read
(
aFd
recordName
.
BeginWriting
(
)
recordNameLength
)
;
if
(
(
uint32_t
)
bytesRead
!
=
recordNameLength
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
fileLength
>
=
sizeof
(
recordNameLength
)
+
recordNameLength
)
;
int32_t
recordLength
=
fileLength
-
(
sizeof
(
recordNameLength
)
+
recordNameLength
)
;
aOutRecordLength
=
recordLength
;
aOutRecordName
=
recordName
;
if
(
PR_Seek
(
aFd
0
PR_SEEK_CUR
)
!
=
(
int32_t
)
(
sizeof
(
recordNameLength
)
+
recordNameLength
)
)
{
NS_WARNING
(
"
Read
cursor
mismatch
after
ReadRecordMetadata
(
)
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
RemoveStorageFile
(
const
nsString
&
aFilename
)
{
nsCOMPtr
<
nsIFile
>
f
;
nsresult
rv
=
GetGMPStorageDir
(
getter_AddRefs
(
f
)
mNodeId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
f
-
>
Append
(
aFilename
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
f
-
>
Remove
(
false
)
;
}
struct
Record
{
Record
(
const
nsAString
&
aFilename
const
nsACString
&
aRecordName
)
:
mFilename
(
aFilename
)
mRecordName
(
aRecordName
)
mFileDesc
(
0
)
{
}
~
Record
(
)
{
MOZ_ASSERT
(
!
mFileDesc
)
;
}
nsString
mFilename
;
nsCString
mRecordName
;
PRFileDesc
*
mFileDesc
;
}
;
nsClassHashtable
<
nsCStringHashKey
Record
>
mRecords
;
const
nsAutoCString
mNodeId
;
}
;
class
GMPMemoryStorage
:
public
GMPStorage
{
public
:
GMPErr
Open
(
const
nsCString
&
aRecordName
)
override
{
MOZ_ASSERT
(
!
IsOpen
(
aRecordName
)
)
;
Record
*
record
=
nullptr
;
if
(
!
mRecords
.
Get
(
aRecordName
&
record
)
)
{
record
=
new
Record
(
)
;
mRecords
.
Put
(
aRecordName
record
)
;
}
record
-
>
mIsOpen
=
true
;
return
GMPNoErr
;
}
bool
IsOpen
(
const
nsCString
&
aRecordName
)
override
{
Record
*
record
=
nullptr
;
if
(
!
mRecords
.
Get
(
aRecordName
&
record
)
)
{
return
false
;
}
return
record
-
>
mIsOpen
;
}
GMPErr
Read
(
const
nsCString
&
aRecordName
nsTArray
<
uint8_t
>
&
aOutBytes
)
override
{
Record
*
record
=
nullptr
;
if
(
!
mRecords
.
Get
(
aRecordName
&
record
)
)
{
return
GMPGenericErr
;
}
aOutBytes
=
record
-
>
mData
;
return
GMPNoErr
;
}
GMPErr
Write
(
const
nsCString
&
aRecordName
const
nsTArray
<
uint8_t
>
&
aBytes
)
override
{
Record
*
record
=
nullptr
;
if
(
!
mRecords
.
Get
(
aRecordName
&
record
)
)
{
return
GMPClosedErr
;
}
record
-
>
mData
=
aBytes
;
return
GMPNoErr
;
}
GMPErr
GetRecordNames
(
nsTArray
<
nsCString
>
&
aOutRecordNames
)
override
{
for
(
auto
iter
=
mRecords
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aOutRecordNames
.
AppendElement
(
iter
.
Key
(
)
)
;
}
return
GMPNoErr
;
}
void
Close
(
const
nsCString
&
aRecordName
)
override
{
Record
*
record
=
nullptr
;
if
(
!
mRecords
.
Get
(
aRecordName
&
record
)
)
{
return
;
}
if
(
!
record
-
>
mData
.
Length
(
)
)
{
mRecords
.
Remove
(
aRecordName
)
;
}
else
{
record
-
>
mIsOpen
=
false
;
}
}
private
:
struct
Record
{
Record
(
)
:
mIsOpen
(
false
)
{
}
nsTArray
<
uint8_t
>
mData
;
bool
mIsOpen
;
}
;
nsClassHashtable
<
nsCStringHashKey
Record
>
mRecords
;
}
;
GMPStorageParent
:
:
GMPStorageParent
(
const
nsCString
&
aNodeId
GMPParent
*
aPlugin
)
:
mNodeId
(
aNodeId
)
mPlugin
(
aPlugin
)
mShutdown
(
false
)
{
}
nsresult
GMPStorageParent
:
:
Init
(
)
{
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
Init
(
)
"
this
)
)
;
if
(
NS_WARN_IF
(
mNodeId
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
mozIGeckoMediaPluginChromeService
>
mps
=
do_GetService
(
"
mozilla
.
org
/
gecko
-
media
-
plugin
-
service
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mps
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
persistent
=
false
;
if
(
NS_WARN_IF
(
NS_FAILED
(
mps
-
>
IsPersistentStorageAllowed
(
mNodeId
&
persistent
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
persistent
)
{
UniquePtr
<
GMPDiskStorage
>
storage
=
MakeUnique
<
GMPDiskStorage
>
(
mNodeId
)
;
if
(
NS_FAILED
(
storage
-
>
Init
(
)
)
)
{
NS_WARNING
(
"
Failed
to
initialize
on
disk
GMP
storage
"
)
;
return
NS_ERROR_FAILURE
;
}
mStorage
=
Move
(
storage
)
;
}
else
{
mStorage
=
MakeUnique
<
GMPMemoryStorage
>
(
)
;
}
return
NS_OK
;
}
bool
GMPStorageParent
:
:
RecvOpen
(
const
nsCString
&
aRecordName
)
{
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
RecvOpen
(
record
=
'
%
s
'
)
"
this
aRecordName
.
get
(
)
)
)
;
if
(
mShutdown
)
{
return
false
;
}
if
(
mNodeId
.
EqualsLiteral
(
"
null
"
)
)
{
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
RecvOpen
(
record
=
'
%
s
'
)
failed
;
null
nodeId
"
this
aRecordName
.
get
(
)
)
)
;
Unused
<
<
SendOpenComplete
(
aRecordName
GMPGenericErr
)
;
return
true
;
}
if
(
aRecordName
.
IsEmpty
(
)
)
{
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
RecvOpen
(
record
=
'
%
s
'
)
failed
;
record
name
empty
"
this
aRecordName
.
get
(
)
)
)
;
Unused
<
<
SendOpenComplete
(
aRecordName
GMPGenericErr
)
;
return
true
;
}
if
(
mStorage
-
>
IsOpen
(
aRecordName
)
)
{
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
RecvOpen
(
record
=
'
%
s
'
)
failed
;
record
in
use
"
this
aRecordName
.
get
(
)
)
)
;
Unused
<
<
SendOpenComplete
(
aRecordName
GMPRecordInUse
)
;
return
true
;
}
auto
err
=
mStorage
-
>
Open
(
aRecordName
)
;
MOZ_ASSERT
(
GMP_FAILED
(
err
)
|
|
mStorage
-
>
IsOpen
(
aRecordName
)
)
;
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
RecvOpen
(
record
=
'
%
s
'
)
complete
;
rv
=
%
d
"
this
aRecordName
.
get
(
)
err
)
)
;
Unused
<
<
SendOpenComplete
(
aRecordName
err
)
;
return
true
;
}
bool
GMPStorageParent
:
:
RecvRead
(
const
nsCString
&
aRecordName
)
{
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
RecvRead
(
record
=
'
%
s
'
)
"
this
aRecordName
.
get
(
)
)
)
;
if
(
mShutdown
)
{
return
false
;
}
nsTArray
<
uint8_t
>
data
;
if
(
!
mStorage
-
>
IsOpen
(
aRecordName
)
)
{
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
RecvRead
(
record
=
'
%
s
'
)
failed
;
record
not
open
"
this
aRecordName
.
get
(
)
)
)
;
Unused
<
<
SendReadComplete
(
aRecordName
GMPClosedErr
data
)
;
}
else
{
GMPErr
rv
=
mStorage
-
>
Read
(
aRecordName
data
)
;
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
RecvRead
(
record
=
'
%
s
'
)
read
%
d
bytes
rv
=
%
d
"
this
aRecordName
.
get
(
)
data
.
Length
(
)
rv
)
)
;
Unused
<
<
SendReadComplete
(
aRecordName
rv
data
)
;
}
return
true
;
}
bool
GMPStorageParent
:
:
RecvWrite
(
const
nsCString
&
aRecordName
InfallibleTArray
<
uint8_t
>
&
&
aBytes
)
{
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
RecvWrite
(
record
=
'
%
s
'
)
%
d
bytes
"
this
aRecordName
.
get
(
)
aBytes
.
Length
(
)
)
)
;
if
(
mShutdown
)
{
return
false
;
}
if
(
!
mStorage
-
>
IsOpen
(
aRecordName
)
)
{
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
RecvWrite
(
record
=
'
%
s
'
)
failed
record
not
open
"
this
aRecordName
.
get
(
)
)
)
;
Unused
<
<
SendWriteComplete
(
aRecordName
GMPClosedErr
)
;
return
true
;
}
if
(
aBytes
.
Length
(
)
>
GMP_MAX_RECORD_SIZE
)
{
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
RecvWrite
(
record
=
'
%
s
'
)
failed
record
too
big
"
this
aRecordName
.
get
(
)
)
)
;
Unused
<
<
SendWriteComplete
(
aRecordName
GMPQuotaExceededErr
)
;
return
true
;
}
GMPErr
rv
=
mStorage
-
>
Write
(
aRecordName
aBytes
)
;
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
RecvWrite
(
record
=
'
%
s
'
)
write
complete
rv
=
%
d
"
this
aRecordName
.
get
(
)
rv
)
)
;
Unused
<
<
SendWriteComplete
(
aRecordName
rv
)
;
return
true
;
}
bool
GMPStorageParent
:
:
RecvGetRecordNames
(
)
{
if
(
mShutdown
)
{
return
true
;
}
nsTArray
<
nsCString
>
recordNames
;
GMPErr
status
=
mStorage
-
>
GetRecordNames
(
recordNames
)
;
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
RecvGetRecordNames
(
)
status
=
%
d
numRecords
=
%
d
"
this
status
recordNames
.
Length
(
)
)
)
;
Unused
<
<
SendRecordNames
(
recordNames
status
)
;
return
true
;
}
bool
GMPStorageParent
:
:
RecvClose
(
const
nsCString
&
aRecordName
)
{
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
RecvClose
(
record
=
'
%
s
'
)
"
this
aRecordName
.
get
(
)
)
)
;
if
(
mShutdown
)
{
return
true
;
}
mStorage
-
>
Close
(
aRecordName
)
;
return
true
;
}
void
GMPStorageParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
ActorDestroy
(
reason
=
%
d
)
"
this
aWhy
)
)
;
Shutdown
(
)
;
}
void
GMPStorageParent
:
:
Shutdown
(
)
{
LOGD
(
(
"
GMPStorageParent
[
%
p
]
:
:
Shutdown
(
)
"
this
)
)
;
if
(
mShutdown
)
{
return
;
}
mShutdown
=
true
;
Unused
<
<
SendShutdown
(
)
;
mStorage
=
nullptr
;
}
}
}
