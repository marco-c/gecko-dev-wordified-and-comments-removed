#
ifndef
GMPService_h_
#
define
GMPService_h_
#
include
"
GMPContentParent
.
h
"
#
include
"
GMPCrashHelper
.
h
"
#
include
"
mozIGeckoMediaPluginService
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
gmp
/
GMPTypes
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
class
nsIAsyncShutdownClient
;
class
nsIRunnable
;
class
nsISerialEventTarget
;
class
nsIThread
;
template
<
class
>
struct
already_AddRefed
;
namespace
mozilla
{
class
GMPCrashHelper
;
class
MediaResult
;
extern
LogModule
*
GetGMPLog
(
)
;
namespace
gmp
{
typedef
MozPromise
<
RefPtr
<
GMPContentParent
:
:
CloseBlocker
>
MediaResult
true
>
GetGMPContentParentPromise
;
typedef
MozPromise
<
RefPtr
<
ChromiumCDMParent
>
MediaResult
true
>
GetCDMParentPromise
;
class
GeckoMediaPluginService
:
public
mozIGeckoMediaPluginService
public
nsIObserver
{
public
:
static
already_AddRefed
<
GeckoMediaPluginService
>
GetGeckoMediaPluginService
(
)
;
virtual
nsresult
Init
(
)
;
NS_DECL_THREADSAFE_ISUPPORTS
RefPtr
<
GetCDMParentPromise
>
GetCDM
(
const
NodeIdParts
&
aNodeIdParts
nsTArray
<
nsCString
>
aTags
GMPCrashHelper
*
aHelper
)
;
#
if
defined
(
MOZ_SANDBOX
)
&
&
defined
(
MOZ_DEBUG
)
&
&
defined
(
ENABLE_TESTS
)
RefPtr
<
GetGMPContentParentPromise
>
GetContentParentForTest
(
)
;
#
endif
NS_IMETHOD
GetThread
(
nsIThread
*
*
aThread
)
override
;
NS_IMETHOD
GetDecryptingGMPVideoDecoder
(
GMPCrashHelper
*
aHelper
nsTArray
<
nsCString
>
*
aTags
const
nsACString
&
aNodeId
UniquePtr
<
GetGMPVideoDecoderCallback
>
&
&
aCallback
uint32_t
aDecryptorId
)
override
;
NS_IMETHOD
GetGMPVideoEncoder
(
GMPCrashHelper
*
aHelper
nsTArray
<
nsCString
>
*
aTags
const
nsACString
&
aNodeId
UniquePtr
<
GetGMPVideoEncoderCallback
>
&
&
aCallback
)
override
;
NS_IMETHOD
GetGMPVideoDecoder
(
GMPCrashHelper
*
aHelper
nsTArray
<
nsCString
>
*
aTags
const
nsACString
&
aNodeId
UniquePtr
<
GetGMPVideoDecoderCallback
>
&
&
aCallback
)
override
{
return
GetDecryptingGMPVideoDecoder
(
aHelper
aTags
aNodeId
std
:
:
move
(
aCallback
)
0
)
;
}
NS_IMETHOD
RunPluginCrashCallbacks
(
uint32_t
aPluginId
const
nsACString
&
aPluginName
)
override
;
already_AddRefed
<
nsISerialEventTarget
>
GetGMPThread
(
)
;
void
ConnectCrashHelper
(
uint32_t
aPluginId
GMPCrashHelper
*
aHelper
)
;
void
DisconnectCrashHelper
(
GMPCrashHelper
*
aHelper
)
;
bool
XPCOMWillShutdownReceived
(
)
const
{
return
mXPCOMWillShutdown
;
}
protected
:
GeckoMediaPluginService
(
)
;
virtual
~
GeckoMediaPluginService
(
)
;
virtual
void
InitializePlugins
(
nsISerialEventTarget
*
aGMPThread
)
=
0
;
virtual
RefPtr
<
GetGMPContentParentPromise
>
GetContentParent
(
GMPCrashHelper
*
aHelper
const
NodeIdVariant
&
aNodeIdVariant
const
nsCString
&
aAPI
const
nsTArray
<
nsCString
>
&
aTags
)
=
0
;
nsresult
GMPDispatch
(
nsIRunnable
*
event
uint32_t
flags
=
NS_DISPATCH_NORMAL
)
;
nsresult
GMPDispatch
(
already_AddRefed
<
nsIRunnable
>
event
uint32_t
flags
=
NS_DISPATCH_NORMAL
)
;
void
ShutdownGMPThread
(
)
;
static
nsCOMPtr
<
nsIAsyncShutdownClient
>
GetShutdownBarrier
(
)
;
Mutex
mMutex
;
const
nsCOMPtr
<
nsISerialEventTarget
>
mMainThread
;
nsCOMPtr
<
nsIThread
>
mGMPThread
;
bool
mGMPThreadShutdown
;
bool
mShuttingDownOnGMPThread
;
Atomic
<
bool
>
mXPCOMWillShutdown
;
nsClassHashtable
<
nsUint32HashKey
nsTArray
<
RefPtr
<
GMPCrashHelper
>
>
>
mPluginCrashHelpers
;
}
;
}
}
#
endif
