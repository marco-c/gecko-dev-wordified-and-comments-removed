#
include
"
GMPStorage
.
h
"
#
include
"
nsClassHashtable
.
h
"
namespace
mozilla
{
namespace
gmp
{
class
GMPMemoryStorage
:
public
GMPStorage
{
public
:
GMPErr
Open
(
const
nsCString
&
aRecordName
)
override
{
MOZ_ASSERT
(
!
IsOpen
(
aRecordName
)
)
;
Record
*
record
=
nullptr
;
if
(
!
mRecords
.
Get
(
aRecordName
&
record
)
)
{
record
=
new
Record
(
)
;
mRecords
.
Put
(
aRecordName
record
)
;
}
record
-
>
mIsOpen
=
true
;
return
GMPNoErr
;
}
bool
IsOpen
(
const
nsCString
&
aRecordName
)
const
override
{
const
Record
*
record
=
mRecords
.
Get
(
aRecordName
)
;
if
(
!
record
)
{
return
false
;
}
return
record
-
>
mIsOpen
;
}
GMPErr
Read
(
const
nsCString
&
aRecordName
nsTArray
<
uint8_t
>
&
aOutBytes
)
override
{
const
Record
*
record
=
mRecords
.
Get
(
aRecordName
)
;
if
(
!
record
)
{
return
GMPGenericErr
;
}
aOutBytes
=
record
-
>
mData
;
return
GMPNoErr
;
}
GMPErr
Write
(
const
nsCString
&
aRecordName
const
nsTArray
<
uint8_t
>
&
aBytes
)
override
{
Record
*
record
=
nullptr
;
if
(
!
mRecords
.
Get
(
aRecordName
&
record
)
)
{
return
GMPClosedErr
;
}
record
-
>
mData
=
aBytes
;
return
GMPNoErr
;
}
GMPErr
GetRecordNames
(
nsTArray
<
nsCString
>
&
aOutRecordNames
)
const
override
{
for
(
auto
iter
=
mRecords
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aOutRecordNames
.
AppendElement
(
iter
.
Key
(
)
)
;
}
return
GMPNoErr
;
}
void
Close
(
const
nsCString
&
aRecordName
)
override
{
Record
*
record
=
nullptr
;
if
(
!
mRecords
.
Get
(
aRecordName
&
record
)
)
{
return
;
}
if
(
!
record
-
>
mData
.
Length
(
)
)
{
mRecords
.
Remove
(
aRecordName
)
;
}
else
{
record
-
>
mIsOpen
=
false
;
}
}
private
:
struct
Record
{
nsTArray
<
uint8_t
>
mData
;
bool
mIsOpen
=
false
;
}
;
nsClassHashtable
<
nsCStringHashKey
Record
>
mRecords
;
}
;
already_AddRefed
<
GMPStorage
>
CreateGMPMemoryStorage
(
)
{
return
RefPtr
<
GMPStorage
>
(
new
GMPMemoryStorage
(
)
)
.
forget
(
)
;
}
}
}
