#
ifndef
GMPUtils_h_
#
define
GMPUtils_h_
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
class
nsIFile
;
class
nsCString
;
class
nsISimpleEnumerator
;
namespace
mozilla
{
template
<
typename
T
>
struct
DestroyPolicy
{
void
operator
(
)
(
T
*
aGMPObject
)
const
{
aGMPObject
-
>
Destroy
(
)
;
}
}
;
template
<
typename
T
>
using
GMPUniquePtr
=
mozilla
:
:
UniquePtr
<
T
DestroyPolicy
<
T
>
>
;
void
SplitAt
(
const
char
*
aDelims
const
nsACString
&
aInput
nsTArray
<
nsCString
>
&
aOutTokens
)
;
nsCString
ToHexString
(
const
nsTArray
<
uint8_t
>
&
aBytes
)
;
nsCString
ToHexString
(
const
uint8_t
*
aBytes
uint32_t
aLength
)
;
bool
FileExists
(
nsIFile
*
aFile
)
;
class
DirectoryEnumerator
{
public
:
enum
Mode
{
DirsOnly
FilesAndDirs
}
;
DirectoryEnumerator
(
nsIFile
*
aPath
Mode
aMode
)
;
already_AddRefed
<
nsIFile
>
Next
(
)
;
private
:
Mode
mMode
;
nsCOMPtr
<
nsISimpleEnumerator
>
mIter
;
}
;
class
GMPInfoFileParser
{
public
:
bool
Init
(
nsIFile
*
aFile
)
;
bool
Contains
(
const
nsCString
&
aKey
)
const
;
nsCString
Get
(
const
nsCString
&
aKey
)
const
;
private
:
nsClassHashtable
<
nsCStringHashKey
nsCString
>
mValues
;
}
;
bool
ReadIntoString
(
nsIFile
*
aFile
nsCString
&
aOutDst
size_t
aMaxLength
)
;
bool
HaveGMPFor
(
const
nsCString
&
aAPI
nsTArray
<
nsCString
>
&
&
aTags
)
;
void
LogToConsole
(
const
nsAString
&
aMsg
)
;
}
#
endif
