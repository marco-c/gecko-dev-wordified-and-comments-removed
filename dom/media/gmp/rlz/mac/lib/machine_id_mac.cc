#
include
<
CoreFoundation
/
CoreFoundation
.
h
>
#
include
<
IOKit
/
IOKitLib
.
h
>
#
include
<
IOKit
/
network
/
IOEthernetController
.
h
>
#
include
<
IOKit
/
network
/
IOEthernetInterface
.
h
>
#
include
<
IOKit
/
network
/
IONetworkInterface
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
vector
>
#
include
<
string
>
#
define
DCHECK
assert
namespace
base
{
template
<
typename
T
>
class
ScopedCFTypeRef
{
public
:
typedef
T
element_type
;
explicit
ScopedCFTypeRef
(
T
object
)
:
object_
(
object
)
{
}
ScopedCFTypeRef
(
const
ScopedCFTypeRef
<
T
>
&
that
)
=
delete
;
ScopedCFTypeRef
(
ScopedCFTypeRef
<
T
>
&
&
that
)
=
delete
;
~
ScopedCFTypeRef
(
)
{
if
(
object_
)
CFRelease
(
object_
)
;
}
ScopedCFTypeRef
&
operator
=
(
const
ScopedCFTypeRef
<
T
>
&
that
)
=
delete
;
ScopedCFTypeRef
&
operator
=
(
ScopedCFTypeRef
<
T
>
&
&
that
)
=
delete
;
operator
T
(
)
const
{
return
object_
;
}
T
release
(
)
{
T
temp
=
object_
;
object_
=
NULL
;
return
temp
;
}
private
:
T
object_
;
}
;
namespace
mac
{
template
<
typename
IOT
>
class
ScopedIOObject
{
public
:
typedef
IOT
element_type
;
explicit
ScopedIOObject
(
IOT
object
=
IO_OBJECT_NULL
)
:
object_
(
object
)
{
}
~
ScopedIOObject
(
)
{
if
(
object_
)
IOObjectRelease
(
object_
)
;
}
ScopedIOObject
(
const
ScopedIOObject
&
)
=
delete
;
void
operator
=
(
const
ScopedIOObject
&
)
=
delete
;
void
reset
(
IOT
object
=
IO_OBJECT_NULL
)
{
if
(
object_
)
IOObjectRelease
(
object_
)
;
object_
=
object
;
}
operator
IOT
(
)
const
{
return
object_
;
}
private
:
IOT
object_
;
}
;
template
<
typename
T
>
T
CFCast
(
const
CFTypeRef
&
cf_val
)
;
template
<
>
CFDataRef
CFCast
<
CFDataRef
>
(
const
CFTypeRef
&
cf_val
)
{
if
(
cf_val
=
=
NULL
)
{
return
NULL
;
}
if
(
CFGetTypeID
(
cf_val
)
=
=
CFDataGetTypeID
(
)
)
{
return
(
CFDataRef
)
(
cf_val
)
;
}
return
NULL
;
}
template
<
>
CFStringRef
CFCast
<
CFStringRef
>
(
const
CFTypeRef
&
cf_val
)
{
if
(
cf_val
=
=
NULL
)
{
return
NULL
;
}
if
(
CFGetTypeID
(
cf_val
)
=
=
CFStringGetTypeID
(
)
)
{
return
(
CFStringRef
)
(
cf_val
)
;
}
return
NULL
;
}
}
static
const
CFStringEncoding
kNarrowStringEncoding
=
kCFStringEncodingUTF8
;
template
<
typename
StringType
>
static
StringType
CFStringToSTLStringWithEncodingT
(
CFStringRef
cfstring
CFStringEncoding
encoding
)
{
CFIndex
length
=
CFStringGetLength
(
cfstring
)
;
if
(
length
=
=
0
)
return
StringType
(
)
;
CFRange
whole_string
=
CFRangeMake
(
0
length
)
;
CFIndex
out_size
;
CFIndex
converted
=
CFStringGetBytes
(
cfstring
whole_string
encoding
0
false
NULL
0
&
out_size
)
;
if
(
converted
=
=
0
|
|
out_size
=
=
0
)
return
StringType
(
)
;
typename
StringType
:
:
size_type
elements
=
out_size
*
sizeof
(
UInt8
)
/
sizeof
(
typename
StringType
:
:
value_type
)
+
1
;
std
:
:
vector
<
typename
StringType
:
:
value_type
>
out_buffer
(
elements
)
;
converted
=
CFStringGetBytes
(
cfstring
whole_string
encoding
0
false
reinterpret_cast
<
UInt8
*
>
(
&
out_buffer
[
0
]
)
out_size
NULL
)
;
if
(
converted
=
=
0
)
return
StringType
(
)
;
out_buffer
[
elements
-
1
]
=
'
\
0
'
;
return
StringType
(
&
out_buffer
[
0
]
elements
-
1
)
;
}
std
:
:
string
SysCFStringRefToUTF8
(
CFStringRef
ref
)
{
return
CFStringToSTLStringWithEncodingT
<
std
:
:
string
>
(
ref
kNarrowStringEncoding
)
;
}
}
namespace
rlz_lib
{
namespace
{
bool
FindEthernetInterfaces
(
io_iterator_t
*
matching_services
)
{
base
:
:
ScopedCFTypeRef
<
CFMutableDictionaryRef
>
matching_dict
(
IOServiceMatching
(
kIOEthernetInterfaceClass
)
)
;
if
(
!
matching_dict
)
return
false
;
base
:
:
ScopedCFTypeRef
<
CFMutableDictionaryRef
>
primary_interface
(
CFDictionaryCreateMutable
(
kCFAllocatorDefault
0
&
kCFTypeDictionaryKeyCallBacks
&
kCFTypeDictionaryValueCallBacks
)
)
;
if
(
!
primary_interface
)
return
false
;
CFDictionarySetValue
(
primary_interface
CFSTR
(
kIOPrimaryInterface
)
kCFBooleanTrue
)
;
CFDictionarySetValue
(
matching_dict
CFSTR
(
kIOPropertyMatchKey
)
primary_interface
)
;
kern_return_t
kern_result
=
IOServiceGetMatchingServices
(
kIOMasterPortDefault
matching_dict
.
release
(
)
matching_services
)
;
return
kern_result
=
=
KERN_SUCCESS
;
}
bool
GetMACAddressFromIterator
(
io_iterator_t
primary_interface_iterator
uint8_t
*
buffer
size_t
buffer_size
)
{
if
(
buffer_size
<
kIOEthernetAddressSize
)
return
false
;
bool
success
=
false
;
bzero
(
buffer
buffer_size
)
;
base
:
:
mac
:
:
ScopedIOObject
<
io_object_t
>
primary_interface
;
while
(
primary_interface
.
reset
(
IOIteratorNext
(
primary_interface_iterator
)
)
primary_interface
)
{
io_object_t
primary_interface_parent
;
kern_return_t
kern_result
=
IORegistryEntryGetParentEntry
(
primary_interface
kIOServicePlane
&
primary_interface_parent
)
;
base
:
:
mac
:
:
ScopedIOObject
<
io_object_t
>
primary_interface_parent_deleter
(
primary_interface_parent
)
;
success
=
kern_result
=
=
KERN_SUCCESS
;
if
(
!
success
)
continue
;
base
:
:
ScopedCFTypeRef
<
CFTypeRef
>
mac_data
(
IORegistryEntryCreateCFProperty
(
primary_interface_parent
CFSTR
(
kIOMACAddress
)
kCFAllocatorDefault
0
)
)
;
CFDataRef
mac_data_data
=
base
:
:
mac
:
:
CFCast
<
CFDataRef
>
(
mac_data
)
;
if
(
mac_data_data
)
{
CFDataGetBytes
(
mac_data_data
CFRangeMake
(
0
kIOEthernetAddressSize
)
buffer
)
;
}
}
return
success
;
}
bool
GetMacAddress
(
unsigned
char
*
buffer
size_t
size
)
{
io_iterator_t
primary_interface_iterator
;
if
(
!
FindEthernetInterfaces
(
&
primary_interface_iterator
)
)
return
false
;
bool
result
=
GetMACAddressFromIterator
(
primary_interface_iterator
buffer
size
)
;
IOObjectRelease
(
primary_interface_iterator
)
;
return
result
;
}
CFStringRef
CopySerialNumber
(
)
{
base
:
:
mac
:
:
ScopedIOObject
<
io_service_t
>
expert_device
(
IOServiceGetMatchingService
(
kIOMasterPortDefault
IOServiceMatching
(
"
IOPlatformExpertDevice
"
)
)
)
;
if
(
!
expert_device
)
return
NULL
;
base
:
:
ScopedCFTypeRef
<
CFTypeRef
>
serial_number
(
IORegistryEntryCreateCFProperty
(
expert_device
CFSTR
(
kIOPlatformSerialNumberKey
)
kCFAllocatorDefault
0
)
)
;
CFStringRef
serial_number_cfstring
=
base
:
:
mac
:
:
CFCast
<
CFStringRef
>
(
serial_number
.
release
(
)
)
;
if
(
!
serial_number_cfstring
)
return
NULL
;
return
serial_number_cfstring
;
}
}
bool
GetRawMachineId
(
std
:
:
vector
<
uint8_t
>
*
data
int
*
more_data
)
{
uint8_t
mac_address
[
kIOEthernetAddressSize
]
;
std
:
:
string
id
;
if
(
GetMacAddress
(
mac_address
sizeof
(
mac_address
)
)
)
{
id
+
=
"
mac
:
"
;
static
const
char
hex
[
]
=
{
'
0
'
'
1
'
'
2
'
'
3
'
'
4
'
'
5
'
'
6
'
'
7
'
'
8
'
'
9
'
'
a
'
'
b
'
'
c
'
'
d
'
'
e
'
'
f
'
}
;
for
(
int
i
=
0
;
i
<
kIOEthernetAddressSize
;
+
+
i
)
{
uint8_t
byte
=
mac_address
[
i
]
;
id
+
=
hex
[
byte
>
>
4
]
;
id
+
=
hex
[
byte
&
0xF
]
;
}
}
CFStringRef
serial
=
CopySerialNumber
(
)
;
if
(
serial
)
{
if
(
!
id
.
empty
(
)
)
{
id
+
=
'
'
;
}
id
+
=
"
serial
:
"
;
id
+
=
base
:
:
SysCFStringRefToUTF8
(
serial
)
;
CFRelease
(
serial
)
;
}
data
-
>
assign
(
&
id
[
0
]
&
id
[
id
.
size
(
)
]
)
;
*
more_data
=
1
;
return
true
;
}
}
