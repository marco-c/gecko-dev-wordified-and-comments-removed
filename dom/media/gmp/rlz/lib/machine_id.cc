#
include
"
rlz
/
lib
/
machine_id
.
h
"
#
include
<
stddef
.
h
>
#
include
"
rlz
/
lib
/
assert
.
h
"
#
include
"
rlz
/
lib
/
crc8
.
h
"
#
include
"
rlz
/
lib
/
string_utils
.
h
"
#
include
"
mozilla
/
SHA1
.
h
"
namespace
rlz_lib
{
bool
GetMachineId
(
std
:
:
string
*
machine_id
)
{
if
(
!
machine_id
)
return
false
;
static
std
:
:
string
calculated_id
;
static
bool
calculated
=
false
;
if
(
calculated
)
{
*
machine_id
=
calculated_id
;
return
true
;
}
std
:
:
vector
<
uint8_t
>
sid_bytes
;
int
volume_id
;
if
(
!
GetRawMachineId
(
&
sid_bytes
&
volume_id
)
)
return
false
;
if
(
!
testing
:
:
GetMachineIdImpl
(
sid_bytes
volume_id
machine_id
)
)
return
false
;
calculated
=
true
;
calculated_id
=
*
machine_id
;
return
true
;
}
namespace
testing
{
bool
GetMachineIdImpl
(
const
std
:
:
vector
<
uint8_t
>
&
sid_bytes
int
volume_id
std
:
:
string
*
machine_id
)
{
machine_id
-
>
clear
(
)
;
static
const
int
kSizeWithoutChecksum
=
mozilla
:
:
SHA1Sum
:
:
kHashSize
+
sizeof
(
int
)
;
std
:
:
vector
<
unsigned
char
>
id_binary
(
kSizeWithoutChecksum
+
1
0
)
;
if
(
!
sid_bytes
.
empty
(
)
)
{
size_t
byte_count
=
sid_bytes
.
size
(
)
*
sizeof
(
std
:
:
vector
<
uint8_t
>
:
:
value_type
)
;
const
char
*
buffer
=
reinterpret_cast
<
const
char
*
>
(
sid_bytes
.
data
(
)
)
;
mozilla
:
:
SHA1Sum
SHA1
;
mozilla
:
:
SHA1Sum
:
:
Hash
hash
;
SHA1
.
update
(
buffer
byte_count
)
;
SHA1
.
finish
(
hash
)
;
std
:
:
string
digest
(
reinterpret_cast
<
char
*
>
(
hash
)
mozilla
:
:
SHA1Sum
:
:
kHashSize
)
;
VERIFY
(
digest
.
size
(
)
=
=
mozilla
:
:
SHA1Sum
:
:
kHashSize
)
;
std
:
:
copy
(
digest
.
begin
(
)
digest
.
end
(
)
id_binary
.
begin
(
)
)
;
}
for
(
size_t
i
=
0
;
i
<
sizeof
(
int
)
;
i
+
+
)
{
int
shift_bits
=
8
*
(
sizeof
(
int
)
-
i
-
1
)
;
id_binary
[
mozilla
:
:
SHA1Sum
:
:
kHashSize
+
i
]
=
static_cast
<
unsigned
char
>
(
(
volume_id
>
>
shift_bits
)
&
0xFF
)
;
}
if
(
!
sid_bytes
.
empty
(
)
|
|
(
0
!
=
volume_id
)
)
rlz_lib
:
:
Crc8
:
:
Generate
(
id_binary
.
data
(
)
kSizeWithoutChecksum
&
id_binary
[
kSizeWithoutChecksum
]
)
;
return
rlz_lib
:
:
BytesToString
(
id_binary
.
data
(
)
kSizeWithoutChecksum
+
1
machine_id
)
;
}
}
}
