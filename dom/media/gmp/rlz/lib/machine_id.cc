#
include
"
rlz
/
lib
/
machine_id
.
h
"
#
include
<
stddef
.
h
>
#
include
"
base
/
sha1
.
h
"
#
include
"
rlz
/
lib
/
assert
.
h
"
#
include
"
rlz
/
lib
/
crc8
.
h
"
#
include
"
rlz
/
lib
/
string_utils
.
h
"
namespace
rlz_lib
{
bool
GetMachineId
(
std
:
:
string
*
machine_id
)
{
if
(
!
machine_id
)
return
false
;
static
std
:
:
string
calculated_id
;
static
bool
calculated
=
false
;
if
(
calculated
)
{
*
machine_id
=
calculated_id
;
return
true
;
}
base
:
:
string16
sid_string
;
int
volume_id
;
if
(
!
GetRawMachineId
(
&
sid_string
&
volume_id
)
)
return
false
;
if
(
!
testing
:
:
GetMachineIdImpl
(
sid_string
volume_id
machine_id
)
)
return
false
;
calculated
=
true
;
calculated_id
=
*
machine_id
;
return
true
;
}
namespace
testing
{
bool
GetMachineIdImpl
(
const
base
:
:
string16
&
sid_string
int
volume_id
std
:
:
string
*
machine_id
)
{
machine_id
-
>
clear
(
)
;
static
const
int
kSizeWithoutChecksum
=
base
:
:
kSHA1Length
+
sizeof
(
int
)
;
std
:
:
basic_string
<
unsigned
char
>
id_binary
(
kSizeWithoutChecksum
+
1
0
)
;
if
(
!
sid_string
.
empty
(
)
)
{
size_t
byte_count
=
sid_string
.
size
(
)
*
sizeof
(
base
:
:
string16
:
:
value_type
)
;
const
char
*
buffer
=
reinterpret_cast
<
const
char
*
>
(
sid_string
.
c_str
(
)
)
;
std
:
:
string
sid_string_buffer
(
buffer
byte_count
)
;
std
:
:
string
digest
(
base
:
:
SHA1HashString
(
sid_string_buffer
)
)
;
VERIFY
(
digest
.
size
(
)
=
=
base
:
:
kSHA1Length
)
;
std
:
:
copy
(
digest
.
begin
(
)
digest
.
end
(
)
id_binary
.
begin
(
)
)
;
}
for
(
size_t
i
=
0
;
i
<
sizeof
(
int
)
;
i
+
+
)
{
int
shift_bits
=
8
*
(
sizeof
(
int
)
-
i
-
1
)
;
id_binary
[
base
:
:
kSHA1Length
+
i
]
=
static_cast
<
unsigned
char
>
(
(
volume_id
>
>
shift_bits
)
&
0xFF
)
;
}
if
(
!
sid_string
.
empty
(
)
|
|
(
0
!
=
volume_id
)
)
rlz_lib
:
:
Crc8
:
:
Generate
(
id_binary
.
c_str
(
)
kSizeWithoutChecksum
&
id_binary
[
kSizeWithoutChecksum
]
)
;
return
rlz_lib
:
:
BytesToString
(
id_binary
.
c_str
(
)
kSizeWithoutChecksum
+
1
machine_id
)
;
}
}
}
