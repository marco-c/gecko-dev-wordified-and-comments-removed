#
if
!
defined
(
NesteggPacketHolder_h_
)
#
define
NesteggPacketHolder_h_
#
include
<
stdint
.
h
>
#
include
<
deque
>
#
include
"
nestegg
/
nestegg
.
h
"
#
include
"
nsAutoRef
.
h
"
namespace
mozilla
{
class
NesteggPacketHolder
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
NesteggPacketHolder
)
NesteggPacketHolder
(
)
:
mPacket
(
nullptr
)
mOffset
(
-
1
)
mTimestamp
(
-
1
)
mDuration
(
-
1
)
mTrack
(
0
)
mIsKeyframe
(
false
)
{
}
bool
Init
(
nestegg_packet
*
aPacket
int64_t
aOffset
unsigned
aTrack
bool
aIsKeyframe
)
{
uint64_t
timestamp_ns
;
if
(
nestegg_packet_tstamp
(
aPacket
&
timestamp_ns
)
=
=
-
1
)
{
return
false
;
}
mTimestamp
=
timestamp_ns
/
1000
;
mPacket
=
aPacket
;
mOffset
=
aOffset
;
mTrack
=
aTrack
;
mIsKeyframe
=
aIsKeyframe
;
uint64_t
duration_ns
;
if
(
!
nestegg_packet_duration
(
aPacket
&
duration_ns
)
)
{
mDuration
=
duration_ns
/
1000
;
}
return
true
;
}
nestegg_packet
*
Packet
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
return
mPacket
;
}
int64_t
Offset
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
return
mOffset
;
}
int64_t
Timestamp
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
return
mTimestamp
;
}
int64_t
Duration
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
return
mDuration
;
}
unsigned
Track
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
return
mTrack
;
}
bool
IsKeyframe
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
return
mIsKeyframe
;
}
int64_t
DiscardPaddingUs
(
)
const
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
int64_t
paddingNs
=
0
;
nestegg_packet_discard_padding
(
mPacket
&
paddingNs
)
;
return
paddingNs
/
1000
;
}
private
:
~
NesteggPacketHolder
(
)
{
nestegg_free_packet
(
mPacket
)
;
}
bool
IsInitialized
(
)
const
{
return
mOffset
>
=
0
;
}
nestegg_packet
*
mPacket
;
int64_t
mOffset
;
int64_t
mTimestamp
;
int64_t
mDuration
;
unsigned
mTrack
;
bool
mIsKeyframe
;
NesteggPacketHolder
(
const
NesteggPacketHolder
&
aOther
)
;
NesteggPacketHolder
&
operator
=
(
NesteggPacketHolder
const
&
aOther
)
;
}
;
class
WebMPacketQueue
{
public
:
int32_t
GetSize
(
)
{
return
mQueue
.
size
(
)
;
}
void
Push
(
NesteggPacketHolder
*
aItem
)
{
mQueue
.
push_back
(
aItem
)
;
}
void
PushFront
(
NesteggPacketHolder
*
aItem
)
{
mQueue
.
push_front
(
std
:
:
move
(
aItem
)
)
;
}
RefPtr
<
NesteggPacketHolder
>
PopFront
(
)
{
RefPtr
<
NesteggPacketHolder
>
result
=
std
:
:
move
(
mQueue
.
front
(
)
)
;
mQueue
.
pop_front
(
)
;
return
result
;
}
void
Reset
(
)
{
while
(
!
mQueue
.
empty
(
)
)
{
mQueue
.
pop_front
(
)
;
}
}
private
:
std
:
:
deque
<
RefPtr
<
NesteggPacketHolder
>
>
mQueue
;
}
;
}
#
endif
