#
if
!
defined
(
WebMReader_h_
)
#
define
WebMReader_h_
#
include
<
stdint
.
h
>
#
include
"
FlushableTaskQueue
.
h
"
#
include
"
MediaDecoderReader
.
h
"
#
include
"
MediaResource
.
h
"
#
include
"
nsAutoRef
.
h
"
#
include
"
nestegg
/
nestegg
.
h
"
#
define
VPX_DONT_DEFINE_STDINT_TYPES
#
include
"
vpx
/
vpx_codec
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
NesteggPacketHolder
.
h
"
namespace
mozilla
{
static
const
unsigned
NS_PER_USEC
=
1000
;
static
const
double
NS_PER_S
=
1e9
;
typedef
TrackInfo
:
:
TrackType
TrackType
;
class
WebMBufferedState
;
class
WebMPacketQueue
;
class
WebMReader
;
class
WebMVideoDecoder
{
public
:
virtual
nsresult
Init
(
unsigned
int
aWidth
=
0
unsigned
int
aHeight
=
0
)
=
0
;
virtual
nsresult
Flush
(
)
{
return
NS_OK
;
}
virtual
void
Shutdown
(
)
=
0
;
virtual
bool
DecodeVideoFrame
(
bool
&
aKeyframeSkip
int64_t
aTimeThreshold
)
=
0
;
WebMVideoDecoder
(
)
{
}
virtual
~
WebMVideoDecoder
(
)
{
}
}
;
class
WebMAudioDecoder
{
public
:
virtual
nsresult
Init
(
)
=
0
;
virtual
void
Shutdown
(
)
=
0
;
virtual
nsresult
ResetDecode
(
)
=
0
;
virtual
nsresult
DecodeHeader
(
const
unsigned
char
*
aData
size_t
aLength
)
=
0
;
virtual
nsresult
FinishInit
(
AudioInfo
&
aInfo
)
=
0
;
virtual
bool
Decode
(
const
unsigned
char
*
aData
size_t
aLength
int64_t
aOffset
uint64_t
aTstampUsecs
int64_t
aDiscardPadding
int32_t
*
aTotalFrames
)
=
0
;
virtual
~
WebMAudioDecoder
(
)
{
}
}
;
class
WebMReader
:
public
MediaDecoderReader
{
public
:
explicit
WebMReader
(
AbstractMediaDecoder
*
aDecoder
)
;
protected
:
~
WebMReader
(
)
;
public
:
AbstractMediaDecoder
*
GetDecoder
(
)
{
return
mDecoder
;
}
MediaInfo
GetMediaInfo
(
)
{
return
mInfo
;
}
virtual
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
virtual
nsresult
Init
(
)
override
;
virtual
nsresult
ResetDecode
(
)
override
;
virtual
bool
DecodeAudioData
(
)
override
;
virtual
bool
DecodeVideoFrame
(
bool
&
aKeyframeSkip
int64_t
aTimeThreshold
)
override
;
virtual
RefPtr
<
MetadataPromise
>
AsyncReadMetadata
(
)
override
;
virtual
RefPtr
<
SeekPromise
>
Seek
(
int64_t
aTime
int64_t
aEndTime
)
override
;
virtual
media
:
:
TimeIntervals
GetBuffered
(
)
override
;
virtual
bool
IsMediaSeekable
(
)
override
;
enum
TrackType
{
VIDEO
=
0
AUDIO
=
1
}
;
RefPtr
<
NesteggPacketHolder
>
NextPacket
(
TrackType
aTrackType
)
;
virtual
void
PushVideoPacket
(
NesteggPacketHolder
*
aItem
)
;
int
GetVideoCodec
(
)
;
nsIntRect
GetPicture
(
)
;
nsIntSize
GetInitialFrame
(
)
;
int64_t
GetLastVideoFrameTime
(
)
;
void
SetLastVideoFrameTime
(
int64_t
aFrameTime
)
;
layers
:
:
LayersBackend
GetLayersBackendType
(
)
{
return
mLayersBackendType
;
}
uint64_t
GetCodecDelay
(
)
{
return
mCodecDelay
;
}
protected
:
virtual
void
NotifyDataArrivedInternal
(
)
override
;
bool
DecodeAudioPacket
(
NesteggPacketHolder
*
aHolder
)
;
void
Cleanup
(
)
;
virtual
nsresult
SeekInternal
(
int64_t
aTime
)
;
void
InitLayersBackendType
(
)
;
bool
ShouldSkipVideoFrame
(
int64_t
aTimeThreshold
)
;
private
:
nsresult
RetrieveWebMMetadata
(
MediaInfo
*
aInfo
)
;
int64_t
GetNextKeyframeTime
(
int64_t
aTimeThreshold
)
;
bool
FilterPacketByTime
(
int64_t
aEndTime
WebMPacketQueue
&
aOutput
)
;
RefPtr
<
NesteggPacketHolder
>
DemuxPacket
(
)
;
nestegg
*
mContext
;
nsAutoPtr
<
WebMAudioDecoder
>
mAudioDecoder
;
nsAutoPtr
<
WebMVideoDecoder
>
mVideoDecoder
;
WebMPacketQueue
mVideoPackets
;
WebMPacketQueue
mAudioPackets
;
uint32_t
mVideoTrack
;
uint32_t
mAudioTrack
;
int64_t
mAudioStartUsec
;
uint64_t
mAudioFrames
;
uint64_t
mCodecDelay
;
uint64_t
mSeekPreroll
;
int64_t
mLastVideoFrameTime
;
RefPtr
<
WebMBufferedState
>
mBufferedState
;
nsIntSize
mInitialFrame
;
nsIntRect
mPicture
;
int
mAudioCodec
;
int
mVideoCodec
;
layers
:
:
LayersBackend
mLayersBackendType
;
bool
mHasVideo
;
bool
mHasAudio
;
MediaResourceIndex
mResource
;
}
;
}
#
endif
