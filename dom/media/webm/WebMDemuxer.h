#
if
!
defined
(
WebMDemuxer_h_
)
#
define
WebMDemuxer_h_
#
include
"
nsTArray
.
h
"
#
include
"
MediaDataDemuxer
.
h
"
#
include
"
MediaResource
.
h
"
#
include
"
NesteggPacketHolder
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
<
deque
>
#
include
<
stdint
.
h
>
typedef
struct
nestegg
nestegg
;
namespace
mozilla
{
class
WebMBufferedState
;
class
MediaRawDataQueue
{
typedef
std
:
:
deque
<
RefPtr
<
MediaRawData
>
>
ContainerType
;
public
:
uint32_t
GetSize
(
)
{
return
mQueue
.
size
(
)
;
}
void
Push
(
MediaRawData
*
aItem
)
{
mQueue
.
push_back
(
aItem
)
;
}
void
Push
(
already_AddRefed
<
MediaRawData
>
&
&
aItem
)
{
mQueue
.
push_back
(
std
:
:
move
(
aItem
)
)
;
}
void
PushFront
(
MediaRawData
*
aItem
)
{
mQueue
.
push_front
(
aItem
)
;
}
void
PushFront
(
already_AddRefed
<
MediaRawData
>
&
&
aItem
)
{
mQueue
.
push_front
(
std
:
:
move
(
aItem
)
)
;
}
void
PushFront
(
MediaRawDataQueue
&
&
aOther
)
{
while
(
!
aOther
.
mQueue
.
empty
(
)
)
{
PushFront
(
aOther
.
Pop
(
)
)
;
}
}
already_AddRefed
<
MediaRawData
>
PopFront
(
)
{
RefPtr
<
MediaRawData
>
result
=
mQueue
.
front
(
)
.
forget
(
)
;
mQueue
.
pop_front
(
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
MediaRawData
>
Pop
(
)
{
RefPtr
<
MediaRawData
>
result
=
mQueue
.
back
(
)
.
forget
(
)
;
mQueue
.
pop_back
(
)
;
return
result
.
forget
(
)
;
}
void
Reset
(
)
{
while
(
!
mQueue
.
empty
(
)
)
{
mQueue
.
pop_front
(
)
;
}
}
MediaRawDataQueue
&
operator
=
(
const
MediaRawDataQueue
&
aOther
)
{
mQueue
=
aOther
.
mQueue
;
return
*
this
;
}
const
RefPtr
<
MediaRawData
>
&
First
(
)
const
{
return
mQueue
.
front
(
)
;
}
const
RefPtr
<
MediaRawData
>
&
Last
(
)
const
{
return
mQueue
.
back
(
)
;
}
ContainerType
:
:
iterator
begin
(
)
{
return
mQueue
.
begin
(
)
;
}
ContainerType
:
:
const_iterator
begin
(
)
const
{
return
mQueue
.
begin
(
)
;
}
ContainerType
:
:
iterator
end
(
)
{
return
mQueue
.
end
(
)
;
}
ContainerType
:
:
const_iterator
end
(
)
const
{
return
mQueue
.
end
(
)
;
}
private
:
ContainerType
mQueue
;
}
;
class
WebMTrackDemuxer
;
DDLoggedTypeDeclNameAndBase
(
WebMDemuxer
MediaDataDemuxer
)
;
DDLoggedTypeNameAndBase
(
WebMTrackDemuxer
MediaTrackDemuxer
)
;
class
WebMDemuxer
:
public
MediaDataDemuxer
public
DecoderDoctorLifeLogger
<
WebMDemuxer
>
{
public
:
explicit
WebMDemuxer
(
MediaResource
*
aResource
)
;
WebMDemuxer
(
MediaResource
*
aResource
bool
aIsMediaSource
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
uint32_t
GetNumberTracks
(
TrackInfo
:
:
TrackType
aType
)
const
override
;
UniquePtr
<
TrackInfo
>
GetTrackInfo
(
TrackInfo
:
:
TrackType
aType
size_t
aTrackNumber
)
const
;
already_AddRefed
<
MediaTrackDemuxer
>
GetTrackDemuxer
(
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
override
;
bool
IsSeekable
(
)
const
override
;
bool
IsSeekableOnlyInBufferedRanges
(
)
const
override
;
UniquePtr
<
EncryptionInfo
>
GetCrypto
(
)
override
;
bool
GetOffsetForTime
(
uint64_t
aTime
int64_t
*
aOffset
)
;
nsresult
GetNextPacket
(
TrackInfo
:
:
TrackType
aType
MediaRawDataQueue
*
aSamples
)
;
void
Reset
(
TrackInfo
:
:
TrackType
aType
)
;
void
PushAudioPacket
(
NesteggPacketHolder
*
aItem
)
;
void
PushVideoPacket
(
NesteggPacketHolder
*
aItem
)
;
bool
IsMediaSource
(
)
const
{
return
mIsMediaSource
;
}
int64_t
LastWebMBlockOffset
(
)
const
{
return
mLastWebMBlockOffset
;
}
struct
NestEggContext
{
NestEggContext
(
WebMDemuxer
*
aParent
MediaResource
*
aResource
)
:
mParent
(
aParent
)
mResource
(
aResource
)
mContext
(
nullptr
)
{
}
~
NestEggContext
(
)
;
int
Init
(
)
;
bool
IsMediaSource
(
)
const
{
return
mParent
-
>
IsMediaSource
(
)
;
}
MediaResourceIndex
*
GetResource
(
)
{
return
&
mResource
;
}
int64_t
GetEndDataOffset
(
)
const
{
return
(
!
mParent
-
>
IsMediaSource
(
)
|
|
mParent
-
>
LastWebMBlockOffset
(
)
<
0
)
?
mResource
.
GetLength
(
)
:
mParent
-
>
LastWebMBlockOffset
(
)
;
}
WebMDemuxer
*
mParent
;
MediaResourceIndex
mResource
;
nestegg
*
mContext
;
}
;
private
:
friend
class
WebMTrackDemuxer
;
~
WebMDemuxer
(
)
;
void
InitBufferedState
(
)
;
nsresult
ReadMetadata
(
)
;
void
NotifyDataArrived
(
)
override
;
void
NotifyDataRemoved
(
)
override
;
void
EnsureUpToDateIndex
(
)
;
media
:
:
TimeIntervals
GetBuffered
(
)
;
nsresult
SeekInternal
(
TrackInfo
:
:
TrackType
aType
const
media
:
:
TimeUnit
&
aTarget
)
;
CryptoTrack
GetTrackCrypto
(
TrackInfo
:
:
TrackType
aType
size_t
aTrackNumber
)
;
nsresult
NextPacket
(
TrackInfo
:
:
TrackType
aType
RefPtr
<
NesteggPacketHolder
>
&
aPacket
)
;
nsresult
DemuxPacket
(
TrackInfo
:
:
TrackType
aType
RefPtr
<
NesteggPacketHolder
>
&
aPacket
)
;
NestEggContext
mVideoContext
;
NestEggContext
mAudioContext
;
MediaResourceIndex
&
Resource
(
TrackInfo
:
:
TrackType
aType
)
{
return
aType
=
=
TrackInfo
:
:
kVideoTrack
?
mVideoContext
.
mResource
:
mAudioContext
.
mResource
;
}
nestegg
*
Context
(
TrackInfo
:
:
TrackType
aType
)
const
{
return
aType
=
=
TrackInfo
:
:
kVideoTrack
?
mVideoContext
.
mContext
:
mAudioContext
.
mContext
;
}
MediaInfo
mInfo
;
nsTArray
<
RefPtr
<
WebMTrackDemuxer
>
>
mDemuxers
;
RefPtr
<
WebMBufferedState
>
mBufferedState
;
RefPtr
<
MediaByteBuffer
>
mInitData
;
WebMPacketQueue
mVideoPackets
;
WebMPacketQueue
mAudioPackets
;
uint32_t
mVideoTrack
;
uint32_t
mAudioTrack
;
uint64_t
mSeekPreroll
;
Maybe
<
int64_t
>
mLastAudioFrameTime
;
Maybe
<
int64_t
>
mLastVideoFrameTime
;
int
mAudioCodec
;
int
mVideoCodec
;
bool
mHasVideo
;
bool
mHasAudio
;
bool
mNeedReIndex
;
int64_t
mLastWebMBlockOffset
;
const
bool
mIsMediaSource
;
EncryptionInfo
mCrypto
;
}
;
class
WebMTrackDemuxer
:
public
MediaTrackDemuxer
public
DecoderDoctorLifeLogger
<
WebMTrackDemuxer
>
{
public
:
WebMTrackDemuxer
(
WebMDemuxer
*
aParent
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
;
UniquePtr
<
TrackInfo
>
GetInfo
(
)
const
override
;
RefPtr
<
SeekPromise
>
Seek
(
const
media
:
:
TimeUnit
&
aTime
)
override
;
RefPtr
<
SamplesPromise
>
GetSamples
(
int32_t
aNumSamples
=
1
)
override
;
void
Reset
(
)
override
;
nsresult
GetNextRandomAccessPoint
(
media
:
:
TimeUnit
*
aTime
)
override
;
RefPtr
<
SkipAccessPointPromise
>
SkipToNextRandomAccessPoint
(
const
media
:
:
TimeUnit
&
aTimeThreshold
)
override
;
media
:
:
TimeIntervals
GetBuffered
(
)
override
;
int64_t
GetEvictionOffset
(
const
media
:
:
TimeUnit
&
aTime
)
override
;
void
BreakCycles
(
)
override
;
private
:
friend
class
WebMDemuxer
;
~
WebMTrackDemuxer
(
)
;
void
UpdateSamples
(
const
nsTArray
<
RefPtr
<
MediaRawData
>
>
&
aSamples
)
;
void
SetNextKeyFrameTime
(
)
;
nsresult
NextSample
(
RefPtr
<
MediaRawData
>
&
aData
)
;
RefPtr
<
WebMDemuxer
>
mParent
;
TrackInfo
:
:
TrackType
mType
;
UniquePtr
<
TrackInfo
>
mInfo
;
Maybe
<
media
:
:
TimeUnit
>
mNextKeyframeTime
;
bool
mNeedKeyframe
;
MediaRawDataQueue
mSamples
;
}
;
}
#
endif
