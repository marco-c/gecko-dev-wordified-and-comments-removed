#
if
!
defined
(
WebMDemuxer_h_
)
#
define
WebMDemuxer_h_
#
include
"
nsTArray
.
h
"
#
include
"
MediaDataDemuxer
.
h
"
#
include
"
NesteggPacketHolder
.
h
"
#
include
"
mozilla
/
Move
.
h
"
typedef
struct
nestegg
nestegg
;
namespace
mozilla
{
class
WebMBufferedState
;
class
MediaRawDataQueue
{
public
:
uint32_t
GetSize
(
)
{
return
mQueue
.
size
(
)
;
}
void
Push
(
MediaRawData
*
aItem
)
{
mQueue
.
push_back
(
aItem
)
;
}
void
Push
(
already_AddRefed
<
MediaRawData
>
&
&
aItem
)
{
mQueue
.
push_back
(
Move
(
aItem
)
)
;
}
void
Push
(
const
MediaRawDataQueue
&
aOther
)
{
mQueue
.
insert
(
mQueue
.
end
(
)
aOther
.
mQueue
.
begin
(
)
aOther
.
mQueue
.
end
(
)
)
;
}
void
PushFront
(
MediaRawData
*
aItem
)
{
mQueue
.
push_front
(
aItem
)
;
}
void
PushFront
(
already_AddRefed
<
MediaRawData
>
&
&
aItem
)
{
mQueue
.
push_front
(
Move
(
aItem
)
)
;
}
void
PushFront
(
const
MediaRawDataQueue
&
aOther
)
{
mQueue
.
insert
(
mQueue
.
begin
(
)
aOther
.
mQueue
.
begin
(
)
aOther
.
mQueue
.
end
(
)
)
;
}
already_AddRefed
<
MediaRawData
>
PopFront
(
)
{
RefPtr
<
MediaRawData
>
result
=
mQueue
.
front
(
)
.
forget
(
)
;
mQueue
.
pop_front
(
)
;
return
result
.
forget
(
)
;
}
void
Reset
(
)
{
while
(
!
mQueue
.
empty
(
)
)
{
mQueue
.
pop_front
(
)
;
}
}
MediaRawDataQueue
&
operator
=
(
const
MediaRawDataQueue
&
aOther
)
{
mQueue
=
aOther
.
mQueue
;
return
*
this
;
}
const
RefPtr
<
MediaRawData
>
&
First
(
)
const
{
return
mQueue
.
front
(
)
;
}
const
RefPtr
<
MediaRawData
>
&
Last
(
)
const
{
return
mQueue
.
back
(
)
;
}
private
:
std
:
:
deque
<
RefPtr
<
MediaRawData
>
>
mQueue
;
}
;
class
WebMTrackDemuxer
;
class
WebMDemuxer
:
public
MediaDataDemuxer
{
public
:
explicit
WebMDemuxer
(
MediaResource
*
aResource
)
;
WebMDemuxer
(
MediaResource
*
aResource
bool
aIsMediaSource
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
bool
HasTrackType
(
TrackInfo
:
:
TrackType
aType
)
const
override
;
uint32_t
GetNumberTracks
(
TrackInfo
:
:
TrackType
aType
)
const
override
;
UniquePtr
<
TrackInfo
>
GetTrackInfo
(
TrackInfo
:
:
TrackType
aType
size_t
aTrackNumber
)
const
;
already_AddRefed
<
MediaTrackDemuxer
>
GetTrackDemuxer
(
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
override
;
bool
IsSeekable
(
)
const
override
;
UniquePtr
<
EncryptionInfo
>
GetCrypto
(
)
override
;
bool
GetOffsetForTime
(
uint64_t
aTime
int64_t
*
aOffset
)
;
bool
GetNextPacket
(
TrackInfo
:
:
TrackType
aType
MediaRawDataQueue
*
aSamples
)
;
nsresult
Reset
(
)
;
virtual
void
PushAudioPacket
(
NesteggPacketHolder
*
aItem
)
;
virtual
void
PushVideoPacket
(
NesteggPacketHolder
*
aItem
)
;
MediaResourceIndex
*
GetResource
(
)
{
return
&
mResource
;
}
int64_t
GetEndDataOffset
(
)
const
{
return
(
!
mIsMediaSource
|
|
mLastWebMBlockOffset
<
0
)
?
mResource
.
GetLength
(
)
:
mLastWebMBlockOffset
;
}
int64_t
IsMediaSource
(
)
const
{
return
mIsMediaSource
;
}
private
:
friend
class
WebMTrackDemuxer
;
~
WebMDemuxer
(
)
;
void
Cleanup
(
)
;
void
InitBufferedState
(
)
;
nsresult
ReadMetadata
(
)
;
void
NotifyDataArrived
(
)
override
;
void
NotifyDataRemoved
(
)
override
;
void
EnsureUpToDateIndex
(
)
;
media
:
:
TimeIntervals
GetBuffered
(
)
;
virtual
nsresult
SeekInternal
(
const
media
:
:
TimeUnit
&
aTarget
)
;
RefPtr
<
NesteggPacketHolder
>
NextPacket
(
TrackInfo
:
:
TrackType
aType
)
;
RefPtr
<
NesteggPacketHolder
>
DemuxPacket
(
)
;
MediaResourceIndex
mResource
;
MediaInfo
mInfo
;
nsTArray
<
RefPtr
<
WebMTrackDemuxer
>
>
mDemuxers
;
RefPtr
<
WebMBufferedState
>
mBufferedState
;
RefPtr
<
MediaByteBuffer
>
mInitData
;
nestegg
*
mContext
;
WebMPacketQueue
mVideoPackets
;
WebMPacketQueue
mAudioPackets
;
uint32_t
mVideoTrack
;
uint32_t
mAudioTrack
;
uint64_t
mCodecDelay
;
uint64_t
mSeekPreroll
;
Maybe
<
int64_t
>
mLastAudioFrameTime
;
Maybe
<
int64_t
>
mLastVideoFrameTime
;
int
mAudioCodec
;
int
mVideoCodec
;
bool
mHasVideo
;
bool
mHasAudio
;
bool
mNeedReIndex
;
int64_t
mLastWebMBlockOffset
;
const
bool
mIsMediaSource
;
}
;
class
WebMTrackDemuxer
:
public
MediaTrackDemuxer
{
public
:
WebMTrackDemuxer
(
WebMDemuxer
*
aParent
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
;
UniquePtr
<
TrackInfo
>
GetInfo
(
)
const
override
;
RefPtr
<
SeekPromise
>
Seek
(
media
:
:
TimeUnit
aTime
)
override
;
RefPtr
<
SamplesPromise
>
GetSamples
(
int32_t
aNumSamples
=
1
)
override
;
void
Reset
(
)
override
;
nsresult
GetNextRandomAccessPoint
(
media
:
:
TimeUnit
*
aTime
)
override
;
RefPtr
<
SkipAccessPointPromise
>
SkipToNextRandomAccessPoint
(
media
:
:
TimeUnit
aTimeThreshold
)
override
;
media
:
:
TimeIntervals
GetBuffered
(
)
override
;
void
BreakCycles
(
)
override
;
private
:
friend
class
WebMDemuxer
;
~
WebMTrackDemuxer
(
)
;
void
UpdateSamples
(
nsTArray
<
RefPtr
<
MediaRawData
>
>
&
aSamples
)
;
void
SetNextKeyFrameTime
(
)
;
RefPtr
<
MediaRawData
>
NextSample
(
)
;
RefPtr
<
WebMDemuxer
>
mParent
;
TrackInfo
:
:
TrackType
mType
;
UniquePtr
<
TrackInfo
>
mInfo
;
Maybe
<
media
:
:
TimeUnit
>
mNextKeyframeTime
;
MediaRawDataQueue
mSamples
;
}
;
}
#
endif
