#
include
"
MediaEventSource
.
h
"
#
include
"
MediaTimer
.
h
"
#
include
"
nsDeque
.
h
"
#
ifndef
DOM_MEDIA_PACER_H_
#
define
DOM_MEDIA_PACER_H_
extern
mozilla
:
:
LazyLogModule
gMediaPipelineLog
;
#
define
LOG
(
level
msg
.
.
.
)
\
MOZ_LOG
(
gMediaPipelineLog
level
(
msg
#
#
__VA_ARGS__
)
)
namespace
mozilla
{
template
<
typename
T
>
class
Pacer
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Pacer
)
Pacer
(
already_AddRefed
<
nsISerialEventTarget
>
aTarget
TimeDuration
aDuplicationInterval
)
:
mTarget
(
aTarget
)
mDuplicationInterval
(
aDuplicationInterval
)
mTimer
(
MakeAndAddRef
<
MediaTimer
<
TimeStamp
>
>
(
)
)
{
LOG
(
LogLevel
:
:
Info
"
Pacer
%
p
constructed
.
Duplication
interval
is
%
.
2fms
"
this
mDuplicationInterval
.
ToMilliseconds
(
)
)
;
}
void
Enqueue
(
T
aItem
TimeStamp
aTime
)
{
LOG
(
LogLevel
:
:
Verbose
"
Pacer
%
p
:
Enqueue
t
=
%
.
4fs
now
=
%
.
4fs
"
this
(
aTime
-
mStart
)
.
ToSeconds
(
)
(
TimeStamp
:
:
Now
(
)
-
mStart
)
.
ToSeconds
(
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
mTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
<
Pacer
>
(
this
)
aItem
=
std
:
:
move
(
aItem
)
aTime
]
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mIsShutdown
)
;
LOG
(
LogLevel
:
:
Verbose
"
Pacer
%
p
:
InnerEnqueue
t
=
%
.
4fs
now
=
%
.
4fs
"
self
.
get
(
)
(
aTime
-
mStart
)
.
ToSeconds
(
)
(
TimeStamp
:
:
Now
(
)
-
mStart
)
.
ToSeconds
(
)
)
;
while
(
const
auto
*
item
=
mQueue
.
Peek
(
)
)
{
if
(
item
-
>
mTime
<
aTime
)
{
break
;
}
RefPtr
<
QueueItem
>
dropping
=
mQueue
.
Pop
(
)
;
}
mQueue
.
Push
(
MakeAndAddRef
<
QueueItem
>
(
std
:
:
move
(
aItem
)
aTime
false
)
)
;
EnsureTimerScheduled
(
aTime
)
;
}
)
)
)
;
}
void
SetDuplicationInterval
(
TimeDuration
aInterval
)
{
LOG
(
LogLevel
:
:
Info
"
Pacer
%
p
:
SetDuplicationInterval
(
%
.
3fs
)
now
=
%
.
4fs
"
this
aInterval
.
ToSeconds
(
)
(
TimeStamp
:
:
Now
(
)
-
mStart
)
.
ToSeconds
(
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
mTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
(
this
)
aInterval
]
{
LOG
(
LogLevel
:
:
Debug
"
Pacer
%
p
:
InnerSetDuplicationInterval
(
%
.
3fs
)
now
=
%
.
4fs
"
self
.
get
(
)
aInterval
.
ToSeconds
(
)
(
TimeStamp
:
:
Now
(
)
-
mStart
)
.
ToSeconds
(
)
)
;
if
(
auto
*
next
=
mQueue
.
PeekFront
(
)
;
next
&
&
next
-
>
mIsDuplicate
)
{
next
-
>
mTime
=
std
:
:
max
(
TimeStamp
:
:
Now
(
)
next
-
>
mTime
-
mDuplicationInterval
+
aInterval
)
;
EnsureTimerScheduled
(
next
-
>
mTime
)
;
}
mDuplicationInterval
=
aInterval
;
}
)
)
)
;
}
RefPtr
<
GenericPromise
>
Shutdown
(
)
{
LOG
(
LogLevel
:
:
Info
"
Pacer
%
p
:
Shutdown
now
=
%
.
4fs
"
this
(
TimeStamp
:
:
Now
(
)
-
mStart
)
.
ToSeconds
(
)
)
;
return
InvokeAsync
(
mTarget
__func__
[
this
self
=
RefPtr
<
Pacer
>
(
this
)
]
{
LOG
(
LogLevel
:
:
Debug
"
Pacer
%
p
:
InnerShutdown
now
=
%
.
4fs
"
self
.
get
(
)
(
TimeStamp
:
:
Now
(
)
-
mStart
)
.
ToSeconds
(
)
)
;
mIsShutdown
=
true
;
mTimer
-
>
Cancel
(
)
;
mQueue
.
Erase
(
)
;
mCurrentTimerTarget
=
Nothing
(
)
;
return
GenericPromise
:
:
CreateAndResolve
(
true
"
Pacer
:
:
Shutdown
"
)
;
}
)
;
}
MediaEventSourceExc
<
T
TimeStamp
>
&
PacedItemEvent
(
)
{
return
mPacedItemEvent
;
}
protected
:
~
Pacer
(
)
=
default
;
void
EnsureTimerScheduled
(
TimeStamp
aTime
)
{
if
(
mCurrentTimerTarget
&
&
*
mCurrentTimerTarget
<
=
aTime
)
{
return
;
}
if
(
mCurrentTimerTarget
)
{
mTimer
-
>
Cancel
(
)
;
mCurrentTimerTarget
=
Nothing
(
)
;
}
LOG
(
LogLevel
:
:
Verbose
"
Pacer
%
p
:
Waiting
until
t
=
%
.
4fs
"
this
(
aTime
-
mStart
)
.
ToSeconds
(
)
)
;
mTimer
-
>
WaitUntil
(
aTime
__func__
)
-
>
Then
(
mTarget
__func__
[
this
self
=
RefPtr
<
Pacer
>
(
this
)
aTime
]
{
LOG
(
LogLevel
:
:
Verbose
"
Pacer
%
p
:
OnTimerTick
t
=
%
.
4fs
now
=
%
.
4fs
"
self
.
get
(
)
(
aTime
-
mStart
)
.
ToSeconds
(
)
(
TimeStamp
:
:
Now
(
)
-
mStart
)
.
ToSeconds
(
)
)
;
OnTimerTick
(
)
;
}
[
]
{
}
)
;
mCurrentTimerTarget
=
Some
(
aTime
)
;
}
void
OnTimerTick
(
)
{
MOZ_ASSERT
(
mTarget
-
>
IsOnCurrentThread
(
)
)
;
mCurrentTimerTarget
=
Nothing
(
)
;
while
(
RefPtr
<
QueueItem
>
item
=
mQueue
.
PopFront
(
)
)
{
auto
now
=
TimeStamp
:
:
Now
(
)
;
if
(
item
-
>
mTime
<
=
now
)
{
if
(
const
auto
&
next
=
mQueue
.
PeekFront
(
)
;
!
next
|
|
next
-
>
mTime
>
(
item
-
>
mTime
+
mDuplicationInterval
)
)
{
mQueue
.
PushFront
(
MakeAndAddRef
<
QueueItem
>
(
item
-
>
mItem
item
-
>
mTime
+
mDuplicationInterval
true
)
)
;
}
LOG
(
LogLevel
:
:
Verbose
"
Pacer
%
p
:
NotifyPacedItem
t
=
%
.
4fs
now
=
%
.
4fs
"
this
(
item
-
>
mTime
-
mStart
)
.
ToSeconds
(
)
(
TimeStamp
:
:
Now
(
)
-
mStart
)
.
ToSeconds
(
)
)
;
mPacedItemEvent
.
Notify
(
std
:
:
move
(
item
-
>
mItem
)
item
-
>
mTime
)
;
continue
;
}
mQueue
.
PushFront
(
item
.
forget
(
)
)
;
break
;
}
if
(
const
auto
&
next
=
mQueue
.
PeekFront
(
)
;
next
)
{
EnsureTimerScheduled
(
next
-
>
mTime
)
;
}
}
public
:
const
nsCOMPtr
<
nsISerialEventTarget
>
mTarget
;
#
ifdef
MOZ_LOGGING
const
TimeStamp
mStart
=
TimeStamp
:
:
Now
(
)
;
#
endif
protected
:
struct
QueueItem
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
QueueItem
)
QueueItem
(
T
aItem
TimeStamp
aTime
bool
aIsDuplicate
)
:
mItem
(
std
:
:
forward
<
T
>
(
aItem
)
)
mTime
(
aTime
)
mIsDuplicate
(
aIsDuplicate
)
{
MOZ_ASSERT
(
!
aTime
.
IsNull
(
)
)
;
}
T
mItem
;
TimeStamp
mTime
;
bool
mIsDuplicate
;
private
:
~
QueueItem
(
)
=
default
;
}
;
nsRefPtrDeque
<
QueueItem
>
mQueue
;
TimeDuration
mDuplicationInterval
;
RefPtr
<
MediaTimer
<
TimeStamp
>
>
mTimer
;
Maybe
<
TimeStamp
>
mCurrentTimerTarget
;
bool
mIsShutdown
=
false
;
MediaEventProducerExc
<
T
TimeStamp
>
mPacedItemEvent
;
}
;
}
#
undef
LOG
#
endif
