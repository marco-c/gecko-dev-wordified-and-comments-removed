#
include
"
MediaEventSource
.
h
"
#
include
"
MediaTimer
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
nsDeque
.
h
"
#
ifndef
DOM_MEDIA_PACER_H_
#
define
DOM_MEDIA_PACER_H_
namespace
mozilla
{
template
<
typename
T
>
class
Pacer
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Pacer
)
Pacer
(
RefPtr
<
TaskQueue
>
aTaskQueue
TimeDuration
aDuplicationInterval
)
:
mTaskQueue
(
std
:
:
move
(
aTaskQueue
)
)
mDuplicationInterval
(
aDuplicationInterval
)
mTimer
(
MakeAndAddRef
<
MediaTimer
<
TimeStamp
>
>
(
)
)
{
}
void
Enqueue
(
T
aItem
TimeStamp
aTime
)
{
MOZ_ALWAYS_SUCCEEDS
(
mTaskQueue
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
<
Pacer
>
(
this
)
aItem
=
std
:
:
move
(
aItem
)
aTime
]
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mIsShutdown
)
;
while
(
const
auto
*
item
=
mQueue
.
Peek
(
)
)
{
if
(
item
-
>
mTime
<
aTime
)
{
break
;
}
RefPtr
<
QueueItem
>
dropping
=
mQueue
.
Pop
(
)
;
}
mQueue
.
Push
(
MakeAndAddRef
<
QueueItem
>
(
std
:
:
move
(
aItem
)
aTime
false
)
)
;
EnsureTimerScheduled
(
aTime
)
;
}
)
)
)
;
}
void
SetDuplicationInterval
(
TimeDuration
aInterval
)
{
MOZ_ALWAYS_SUCCEEDS
(
mTaskQueue
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
(
this
)
aInterval
]
{
if
(
auto
*
next
=
mQueue
.
PeekFront
(
)
;
next
&
&
next
-
>
mIsDuplicate
)
{
next
-
>
mTime
=
std
:
:
max
(
TimeStamp
:
:
Now
(
)
next
-
>
mTime
-
mDuplicationInterval
+
aInterval
)
;
EnsureTimerScheduled
(
next
-
>
mTime
)
;
}
mDuplicationInterval
=
aInterval
;
}
)
)
)
;
}
RefPtr
<
GenericPromise
>
Shutdown
(
)
{
return
InvokeAsync
(
mTaskQueue
__func__
[
this
self
=
RefPtr
<
Pacer
>
(
this
)
]
{
mIsShutdown
=
true
;
mTimer
-
>
Cancel
(
)
;
mQueue
.
Erase
(
)
;
mCurrentTimerTarget
=
Nothing
(
)
;
return
GenericPromise
:
:
CreateAndResolve
(
true
"
Pacer
:
:
Shutdown
"
)
;
}
)
;
}
MediaEventSourceExc
<
T
TimeStamp
>
&
PacedItemEvent
(
)
{
return
mPacedItemEvent
;
}
protected
:
~
Pacer
(
)
=
default
;
void
EnsureTimerScheduled
(
TimeStamp
aTime
)
{
if
(
mCurrentTimerTarget
&
&
*
mCurrentTimerTarget
<
=
aTime
)
{
return
;
}
if
(
mCurrentTimerTarget
)
{
mTimer
-
>
Cancel
(
)
;
mCurrentTimerTarget
=
Nothing
(
)
;
}
mTimer
-
>
WaitUntil
(
aTime
__func__
)
-
>
Then
(
mTaskQueue
__func__
[
this
self
=
RefPtr
<
Pacer
>
(
this
)
]
{
OnTimerTick
(
)
;
}
[
]
{
}
)
;
mCurrentTimerTarget
=
Some
(
aTime
)
;
}
void
OnTimerTick
(
)
{
MOZ_ASSERT
(
mTaskQueue
-
>
IsOnCurrentThread
(
)
)
;
mCurrentTimerTarget
=
Nothing
(
)
;
while
(
RefPtr
<
QueueItem
>
item
=
mQueue
.
PopFront
(
)
)
{
auto
now
=
TimeStamp
:
:
Now
(
)
;
if
(
item
-
>
mTime
<
=
now
)
{
if
(
const
auto
&
next
=
mQueue
.
PeekFront
(
)
;
!
next
|
|
next
-
>
mTime
>
(
item
-
>
mTime
+
mDuplicationInterval
)
)
{
mQueue
.
PushFront
(
MakeAndAddRef
<
QueueItem
>
(
item
-
>
mItem
item
-
>
mTime
+
mDuplicationInterval
true
)
)
;
}
mPacedItemEvent
.
Notify
(
std
:
:
move
(
item
-
>
mItem
)
item
-
>
mTime
)
;
continue
;
}
mQueue
.
PushFront
(
item
.
forget
(
)
)
;
break
;
}
if
(
const
auto
&
next
=
mQueue
.
PeekFront
(
)
;
next
)
{
EnsureTimerScheduled
(
next
-
>
mTime
)
;
}
}
public
:
const
RefPtr
<
TaskQueue
>
mTaskQueue
;
protected
:
struct
QueueItem
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
QueueItem
)
QueueItem
(
T
aItem
TimeStamp
aTime
bool
aIsDuplicate
)
:
mItem
(
std
:
:
forward
<
T
>
(
aItem
)
)
mTime
(
aTime
)
mIsDuplicate
(
aIsDuplicate
)
{
MOZ_ASSERT
(
!
aTime
.
IsNull
(
)
)
;
}
T
mItem
;
TimeStamp
mTime
;
bool
mIsDuplicate
;
private
:
~
QueueItem
(
)
=
default
;
}
;
nsRefPtrDeque
<
QueueItem
>
mQueue
;
TimeDuration
mDuplicationInterval
;
RefPtr
<
MediaTimer
<
TimeStamp
>
>
mTimer
;
Maybe
<
TimeStamp
>
mCurrentTimerTarget
;
bool
mIsShutdown
=
false
;
MediaEventProducerExc
<
T
TimeStamp
>
mPacedItemEvent
;
}
;
}
#
endif
