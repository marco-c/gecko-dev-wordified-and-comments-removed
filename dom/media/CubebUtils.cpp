#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
CubebUtils
.
h
"
#
include
"
nsAutoRef
.
h
"
#
include
"
prdtoa
.
h
"
#
define
PREF_VOLUME_SCALE
"
media
.
volume_scale
"
#
define
PREF_CUBEB_LATENCY
"
media
.
cubeb_latency_ms
"
namespace
mozilla
{
namespace
{
StaticMutex
sMutex
;
enum
class
CubebState
{
Uninitialized
=
0
Initialized
Error
Shutdown
}
sCubebState
=
CubebState
:
:
Uninitialized
;
cubeb
*
sCubebContext
;
double
sVolumeScale
;
uint32_t
sCubebLatency
;
bool
sCubebLatencyPrefSet
;
bool
sAudioStreamInitEverSucceeded
=
false
;
StaticAutoPtr
<
char
>
sBrandName
;
const
char
kBrandBundleURL
[
]
=
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
;
const
char
*
AUDIOSTREAM_BACKEND_ID_STR
[
]
=
{
"
jack
"
"
pulse
"
"
alsa
"
"
audiounit
"
"
audioqueue
"
"
wasapi
"
"
winmm
"
"
directsound
"
"
sndio
"
"
opensl
"
"
audiotrack
"
"
kai
"
}
;
const
int
CUBEB_BACKEND_INIT_FAILURE_FIRST
=
ArrayLength
(
AUDIOSTREAM_BACKEND_ID_STR
)
;
const
int
CUBEB_BACKEND_INIT_FAILURE_OTHER
=
CUBEB_BACKEND_INIT_FAILURE_FIRST
+
1
;
const
int
CUBEB_BACKEND_UNKNOWN
=
CUBEB_BACKEND_INIT_FAILURE_FIRST
+
2
;
uint32_t
sPreferredSampleRate
;
}
extern
LazyLogModule
gAudioStreamLog
;
static
const
uint32_t
CUBEB_NORMAL_LATENCY_MS
=
100
;
namespace
CubebUtils
{
void
PrefChanged
(
const
char
*
aPref
void
*
aClosure
)
{
if
(
strcmp
(
aPref
PREF_VOLUME_SCALE
)
=
=
0
)
{
nsAdoptingString
value
=
Preferences
:
:
GetString
(
aPref
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
value
.
IsEmpty
(
)
)
{
sVolumeScale
=
1
.
0
;
}
else
{
NS_ConvertUTF16toUTF8
utf8
(
value
)
;
sVolumeScale
=
std
:
:
max
<
double
>
(
0
PR_strtod
(
utf8
.
get
(
)
nullptr
)
)
;
}
}
else
if
(
strcmp
(
aPref
PREF_CUBEB_LATENCY
)
=
=
0
)
{
sCubebLatencyPrefSet
=
Preferences
:
:
HasUserValue
(
aPref
)
;
uint32_t
value
=
Preferences
:
:
GetUint
(
aPref
CUBEB_NORMAL_LATENCY_MS
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
sCubebLatency
=
std
:
:
min
<
uint32_t
>
(
std
:
:
max
<
uint32_t
>
(
value
1
)
1000
)
;
}
}
bool
GetFirstStream
(
)
{
static
bool
sFirstStream
=
true
;
StaticMutexAutoLock
lock
(
sMutex
)
;
bool
result
=
sFirstStream
;
sFirstStream
=
false
;
return
result
;
}
double
GetVolumeScale
(
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
return
sVolumeScale
;
}
cubeb
*
GetCubebContext
(
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
return
GetCubebContextUnlocked
(
)
;
}
void
InitPreferredSampleRate
(
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
sPreferredSampleRate
=
=
0
)
{
cubeb
*
context
=
GetCubebContextUnlocked
(
)
;
if
(
context
)
{
if
(
cubeb_get_preferred_sample_rate
(
context
&
sPreferredSampleRate
)
!
=
CUBEB_OK
)
{
sPreferredSampleRate
=
44100
;
}
}
}
}
void
InitBrandName
(
)
{
if
(
sBrandName
)
{
return
;
}
nsXPIDLString
brandName
;
nsCOMPtr
<
nsIStringBundleService
>
stringBundleService
=
mozilla
:
:
services
:
:
GetStringBundleService
(
)
;
if
(
stringBundleService
)
{
nsCOMPtr
<
nsIStringBundle
>
brandBundle
;
nsresult
rv
=
stringBundleService
-
>
CreateBundle
(
kBrandBundleURL
getter_AddRefs
(
brandBundle
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
brandBundle
-
>
GetStringFromName
(
u
"
brandShortName
"
getter_Copies
(
brandName
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Could
not
get
the
program
name
for
a
cubeb
stream
.
"
)
;
}
}
const
char
*
ascii
=
NS_LossyConvertUTF16toASCII
(
brandName
)
.
get
(
)
;
sBrandName
=
new
char
[
brandName
.
Length
(
)
+
1
]
;
PodCopy
(
sBrandName
.
get
(
)
ascii
brandName
.
Length
(
)
)
;
sBrandName
[
brandName
.
Length
(
)
]
=
0
;
}
cubeb
*
GetCubebContextUnlocked
(
)
{
sMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
sCubebState
!
=
CubebState
:
:
Uninitialized
)
{
return
sCubebContext
;
}
if
(
!
sBrandName
&
&
NS_IsMainThread
(
)
)
{
InitBrandName
(
)
;
}
else
{
NS_WARNING_ASSERTION
(
sBrandName
"
Did
not
initialize
sbrandName
and
not
on
the
main
thread
?
"
)
;
}
int
rv
=
cubeb_init
(
&
sCubebContext
sBrandName
)
;
NS_WARNING_ASSERTION
(
rv
=
=
CUBEB_OK
"
Could
not
get
a
cubeb
context
.
"
)
;
sCubebState
=
(
rv
=
=
CUBEB_OK
)
?
CubebState
:
:
Initialized
:
CubebState
:
:
Error
;
return
sCubebContext
;
}
void
ReportCubebBackendUsed
(
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
sAudioStreamInitEverSucceeded
=
true
;
bool
foundBackend
=
false
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
AUDIOSTREAM_BACKEND_ID_STR
)
;
i
+
+
)
{
if
(
!
strcmp
(
cubeb_get_backend_id
(
sCubebContext
)
AUDIOSTREAM_BACKEND_ID_STR
[
i
]
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
AUDIOSTREAM_BACKEND_USED
i
)
;
foundBackend
=
true
;
}
}
if
(
!
foundBackend
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
AUDIOSTREAM_BACKEND_USED
CUBEB_BACKEND_UNKNOWN
)
;
}
}
void
ReportCubebStreamInitFailure
(
bool
aIsFirst
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
!
aIsFirst
&
&
!
sAudioStreamInitEverSucceeded
)
{
return
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
AUDIOSTREAM_BACKEND_USED
aIsFirst
?
CUBEB_BACKEND_INIT_FAILURE_FIRST
:
CUBEB_BACKEND_INIT_FAILURE_OTHER
)
;
}
uint32_t
GetCubebLatency
(
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
return
sCubebLatency
;
}
bool
CubebLatencyPrefSet
(
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
return
sCubebLatencyPrefSet
;
}
void
InitLibrary
(
)
{
PrefChanged
(
PREF_VOLUME_SCALE
nullptr
)
;
Preferences
:
:
RegisterCallback
(
PrefChanged
PREF_VOLUME_SCALE
)
;
PrefChanged
(
PREF_CUBEB_LATENCY
nullptr
)
;
Preferences
:
:
RegisterCallback
(
PrefChanged
PREF_CUBEB_LATENCY
)
;
#
ifndef
MOZ_WIDGET_ANDROID
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
&
InitBrandName
)
)
;
#
endif
}
void
ShutdownLibrary
(
)
{
Preferences
:
:
UnregisterCallback
(
PrefChanged
PREF_VOLUME_SCALE
)
;
Preferences
:
:
UnregisterCallback
(
PrefChanged
PREF_CUBEB_LATENCY
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
sCubebContext
)
{
cubeb_destroy
(
sCubebContext
)
;
sCubebContext
=
nullptr
;
}
sBrandName
=
nullptr
;
sCubebState
=
CubebState
:
:
Shutdown
;
}
uint32_t
MaxNumberOfChannels
(
)
{
cubeb
*
cubebContext
=
GetCubebContext
(
)
;
uint32_t
maxNumberOfChannels
;
if
(
cubebContext
&
&
cubeb_get_max_channel_count
(
cubebContext
&
maxNumberOfChannels
)
=
=
CUBEB_OK
)
{
return
maxNumberOfChannels
;
}
return
0
;
}
uint32_t
PreferredSampleRate
(
)
{
MOZ_ASSERT
(
sPreferredSampleRate
"
sPreferredSampleRate
has
not
been
initialized
!
"
)
;
return
sPreferredSampleRate
;
}
#
if
defined
(
__ANDROID__
)
&
&
defined
(
MOZ_B2G
)
cubeb_stream_type
ConvertChannelToCubebType
(
dom
:
:
AudioChannel
aChannel
)
{
switch
(
aChannel
)
{
case
dom
:
:
AudioChannel
:
:
Normal
:
case
dom
:
:
AudioChannel
:
:
Content
:
return
CUBEB_STREAM_TYPE_MUSIC
;
case
dom
:
:
AudioChannel
:
:
Notification
:
return
CUBEB_STREAM_TYPE_NOTIFICATION
;
case
dom
:
:
AudioChannel
:
:
Alarm
:
return
CUBEB_STREAM_TYPE_ALARM
;
case
dom
:
:
AudioChannel
:
:
Telephony
:
return
CUBEB_STREAM_TYPE_VOICE_CALL
;
case
dom
:
:
AudioChannel
:
:
Ringer
:
return
CUBEB_STREAM_TYPE_RING
;
case
dom
:
:
AudioChannel
:
:
System
:
return
CUBEB_STREAM_TYPE_SYSTEM
;
case
dom
:
:
AudioChannel
:
:
Publicnotification
:
return
CUBEB_STREAM_TYPE_SYSTEM_ENFORCED
;
default
:
NS_ERROR
(
"
The
value
of
AudioChannel
is
invalid
"
)
;
return
CUBEB_STREAM_TYPE_MAX
;
}
}
#
endif
void
GetCurrentBackend
(
nsAString
&
aBackend
)
{
const
char
*
backend
=
cubeb_get_backend_id
(
GetCubebContext
(
)
)
;
if
(
!
backend
)
{
aBackend
.
AssignLiteral
(
"
unknown
"
)
;
return
;
}
aBackend
.
AssignASCII
(
backend
)
;
}
}
}
