#
include
"
mozilla
/
dom
/
MediaDevices
.
h
"
#
include
"
AudioDeviceInfo
.
h
"
#
include
"
MediaEngine
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamBinding
.
h
"
#
include
"
mozilla
/
dom
/
MediaDeviceInfo
.
h
"
#
include
"
mozilla
/
dom
/
MediaDevicesBinding
.
h
"
#
include
"
mozilla
/
dom
/
NavigatorBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
WindowContext
.
h
"
#
include
"
mozilla
/
MediaManager
.
h
"
#
include
"
MediaTrackConstraints
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsQueryObject
.
h
"
namespace
mozilla
:
:
dom
{
using
EnumerationFlag
=
MediaManager
:
:
EnumerationFlag
;
using
LocalMediaDeviceSetRefCnt
=
MediaManager
:
:
LocalMediaDeviceSetRefCnt
;
MediaDevices
:
:
MediaDevices
(
nsPIDOMWindowInner
*
aWindow
)
:
DOMEventTargetHelper
(
aWindow
)
{
}
MediaDevices
:
:
~
MediaDevices
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mDeviceChangeListener
.
DisconnectIfExists
(
)
;
}
already_AddRefed
<
Promise
>
MediaDevices
:
:
GetUserMedia
(
const
MediaStreamConstraints
&
aConstraints
CallerType
aCallerType
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
xpc
:
:
NativeGlobal
(
GetWrapper
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
owner
=
do_QueryInterface
(
global
)
;
if
(
Document
*
doc
=
owner
-
>
GetExtantDoc
(
)
)
{
if
(
!
owner
-
>
IsSecureContext
(
)
)
{
doc
-
>
SetUseCounter
(
eUseCounter_custom_GetUserMediaInsec
)
;
}
Document
*
topDoc
=
doc
-
>
GetTopLevelContentDocumentIfSameProcess
(
)
;
IgnoredErrorResult
ignored
;
if
(
topDoc
&
&
!
topDoc
-
>
HasFocus
(
ignored
)
)
{
doc
-
>
SetUseCounter
(
eUseCounter_custom_GetUserMediaUnfocused
)
;
}
}
RefPtr
<
Promise
>
p
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
!
MediaManager
:
:
IsOn
(
aConstraints
.
mVideo
)
&
&
!
MediaManager
:
:
IsOn
(
aConstraints
.
mAudio
)
)
{
p
-
>
MaybeRejectWithTypeError
(
"
audio
and
/
or
video
is
required
"
)
;
return
p
.
forget
(
)
;
}
if
(
!
owner
-
>
IsFullyActive
(
)
)
{
p
-
>
MaybeRejectWithInvalidStateError
(
"
The
document
is
not
fully
active
.
"
)
;
return
p
.
forget
(
)
;
}
const
OwningBooleanOrMediaTrackConstraints
&
video
=
aConstraints
.
mVideo
;
if
(
aCallerType
!
=
CallerType
:
:
System
&
&
video
.
IsMediaTrackConstraints
(
)
)
{
const
Optional
<
nsString
>
&
mediaSource
=
video
.
GetAsMediaTrackConstraints
(
)
.
mMediaSource
;
if
(
mediaSource
.
WasPassed
(
)
&
&
!
mediaSource
.
Value
(
)
.
EqualsLiteral
(
"
camera
"
)
)
{
WindowContext
*
wc
=
owner
-
>
GetWindowContext
(
)
;
if
(
!
wc
|
|
!
wc
-
>
HasValidTransientUserGestureActivation
(
)
)
{
p
-
>
MaybeRejectWithInvalidStateError
(
"
Display
capture
requires
transient
activation
"
"
from
a
user
gesture
.
"
)
;
return
p
.
forget
(
)
;
}
}
}
bool
haveFake
=
aConstraints
.
mFake
.
WasPassed
(
)
&
&
aConstraints
.
mFake
.
Value
(
)
;
const
OwningBooleanOrMediaTrackConstraints
&
audio
=
aConstraints
.
mAudio
;
bool
isMicrophone
=
!
haveFake
&
&
(
audio
.
IsBoolean
(
)
?
audio
.
GetAsBoolean
(
)
:
!
audio
.
GetAsMediaTrackConstraints
(
)
.
mMediaSource
.
WasPassed
(
)
)
;
RefPtr
<
MediaDevices
>
self
(
this
)
;
MediaManager
:
:
Get
(
)
-
>
GetUserMedia
(
owner
aConstraints
aCallerType
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
this
self
p
isMicrophone
]
(
RefPtr
<
DOMMediaStream
>
&
&
aStream
)
{
if
(
!
GetWindowIfCurrent
(
)
)
{
return
;
}
if
(
isMicrophone
)
{
mCanExposeMicrophoneInfo
=
true
;
}
p
-
>
MaybeResolve
(
std
:
:
move
(
aStream
)
)
;
}
[
this
self
p
]
(
const
RefPtr
<
MediaMgrError
>
&
error
)
{
nsPIDOMWindowInner
*
window
=
GetWindowIfCurrent
(
)
;
if
(
!
window
)
{
return
;
}
error
-
>
Reject
(
p
)
;
}
)
;
return
p
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
MediaDevices
:
:
EnumerateDevices
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
xpc
:
:
NativeGlobal
(
GetWrapper
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
owner
=
do_QueryInterface
(
global
)
;
if
(
Document
*
doc
=
owner
-
>
GetExtantDoc
(
)
)
{
if
(
!
owner
-
>
IsSecureContext
(
)
)
{
doc
-
>
SetUseCounter
(
eUseCounter_custom_EnumerateDevicesInsec
)
;
}
Document
*
topDoc
=
doc
-
>
GetTopLevelContentDocumentIfSameProcess
(
)
;
IgnoredErrorResult
ignored
;
if
(
topDoc
&
&
!
topDoc
-
>
HasFocus
(
ignored
)
)
{
doc
-
>
SetUseCounter
(
eUseCounter_custom_EnumerateDevicesUnfocused
)
;
}
}
RefPtr
<
Promise
>
p
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
mPendingEnumerateDevicesPromises
.
AppendElement
(
p
)
;
MaybeResumeDeviceExposure
(
)
;
return
p
.
forget
(
)
;
}
void
MediaDevices
:
:
MaybeResumeDeviceExposure
(
)
{
if
(
mPendingEnumerateDevicesPromises
.
IsEmpty
(
)
)
{
return
;
}
nsPIDOMWindowInner
*
window
=
GetOwner
(
)
;
if
(
!
window
|
|
!
window
-
>
IsFullyActive
(
)
)
{
return
;
}
BrowsingContext
*
bc
=
window
-
>
GetBrowsingContext
(
)
;
if
(
!
bc
-
>
IsActive
(
)
|
|
!
bc
-
>
GetIsActiveBrowserWindow
(
)
)
{
return
;
}
auto
pending
=
std
:
:
move
(
mPendingEnumerateDevicesPromises
)
;
for
(
auto
&
promise
:
pending
)
{
ResumeEnumerateDevices
(
std
:
:
move
(
promise
)
)
;
}
}
void
MediaDevices
:
:
ResumeEnumerateDevices
(
RefPtr
<
Promise
>
aPromise
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetOwner
(
)
;
MOZ_ASSERT
(
window
"
Fully
active
document
should
have
window
"
)
;
RefPtr
<
MediaDevices
>
self
(
this
)
;
MediaManager
:
:
Get
(
)
-
>
EnumerateDevices
(
window
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
this
self
aPromise
]
(
RefPtr
<
LocalMediaDeviceSetRefCnt
>
&
&
aDevices
)
{
nsPIDOMWindowInner
*
window
=
GetWindowIfCurrent
(
)
;
if
(
!
window
)
{
return
;
}
auto
windowId
=
window
-
>
WindowID
(
)
;
nsTArray
<
RefPtr
<
MediaDeviceInfo
>
>
infos
;
bool
allowLabel
=
aDevices
-
>
Length
(
)
=
=
0
|
|
MediaManager
:
:
Get
(
)
-
>
IsActivelyCapturingOrHasAPermission
(
windowId
)
;
nsTHashSet
<
nsString
>
exposedMicrophoneGroupIds
;
for
(
auto
&
device
:
*
aDevices
)
{
nsString
label
;
MOZ_ASSERT
(
device
-
>
Kind
(
)
<
MediaDeviceKind
:
:
EndGuard_
)
;
switch
(
device
-
>
Kind
(
)
)
{
case
MediaDeviceKind
:
:
Audioinput
:
if
(
mCanExposeMicrophoneInfo
)
{
exposedMicrophoneGroupIds
.
Insert
(
device
-
>
mGroupID
)
;
}
[
[
fallthrough
]
]
;
case
MediaDeviceKind
:
:
Videoinput
:
if
(
allowLabel
|
|
Preferences
:
:
GetBool
(
"
media
.
navigator
.
permission
.
disabled
"
false
)
)
{
label
=
device
-
>
mName
;
}
break
;
case
MediaDeviceKind
:
:
Audiooutput
:
if
(
!
mExplicitlyGrantedAudioOutputIds
.
Contains
(
device
-
>
mID
)
&
&
!
exposedMicrophoneGroupIds
.
Contains
(
device
-
>
mGroupID
)
)
{
continue
;
}
label
=
device
-
>
mName
;
break
;
case
MediaDeviceKind
:
:
EndGuard_
:
break
;
}
infos
.
AppendElement
(
MakeRefPtr
<
MediaDeviceInfo
>
(
device
-
>
mID
device
-
>
Kind
(
)
label
device
-
>
mGroupID
)
)
;
}
aPromise
-
>
MaybeResolve
(
std
:
:
move
(
infos
)
)
;
}
[
this
self
aPromise
]
(
const
RefPtr
<
MediaMgrError
>
&
error
)
{
nsPIDOMWindowInner
*
window
=
GetWindowIfCurrent
(
)
;
if
(
!
window
)
{
return
;
}
error
-
>
Reject
(
aPromise
)
;
}
)
;
}
already_AddRefed
<
Promise
>
MediaDevices
:
:
GetDisplayMedia
(
const
DisplayMediaStreamConstraints
&
aConstraints
CallerType
aCallerType
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
xpc
:
:
NativeGlobal
(
GetWrapper
(
)
)
;
RefPtr
<
Promise
>
p
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
owner
=
do_QueryInterface
(
global
)
;
WindowContext
*
wc
=
owner
-
>
GetWindowContext
(
)
;
if
(
!
wc
|
|
!
wc
-
>
HasValidTransientUserGestureActivation
(
)
)
{
p
-
>
MaybeRejectWithInvalidStateError
(
"
getDisplayMedia
requires
transient
activation
from
a
user
gesture
.
"
)
;
return
p
.
forget
(
)
;
}
if
(
!
MediaManager
:
:
IsOn
(
aConstraints
.
mVideo
)
)
{
p
-
>
MaybeRejectWithTypeError
(
"
video
is
required
"
)
;
return
p
.
forget
(
)
;
}
MediaStreamConstraints
c
;
auto
&
vc
=
c
.
mVideo
.
SetAsMediaTrackConstraints
(
)
;
if
(
aConstraints
.
mVideo
.
IsMediaTrackConstraints
(
)
)
{
vc
=
aConstraints
.
mVideo
.
GetAsMediaTrackConstraints
(
)
;
if
(
vc
.
mAdvanced
.
WasPassed
(
)
)
{
p
-
>
MaybeRejectWithTypeError
(
"
advanced
not
allowed
"
)
;
return
p
.
forget
(
)
;
}
auto
getCLR
=
[
]
(
const
auto
&
aCon
)
-
>
const
ConstrainLongRange
&
{
static
ConstrainLongRange
empty
;
return
(
aCon
.
WasPassed
(
)
&
&
!
aCon
.
Value
(
)
.
IsLong
(
)
)
?
aCon
.
Value
(
)
.
GetAsConstrainLongRange
(
)
:
empty
;
}
;
auto
getCDR
=
[
]
(
auto
&
&
aCon
)
-
>
const
ConstrainDoubleRange
&
{
static
ConstrainDoubleRange
empty
;
return
(
aCon
.
WasPassed
(
)
&
&
!
aCon
.
Value
(
)
.
IsDouble
(
)
)
?
aCon
.
Value
(
)
.
GetAsConstrainDoubleRange
(
)
:
empty
;
}
;
const
auto
&
w
=
getCLR
(
vc
.
mWidth
)
;
const
auto
&
h
=
getCLR
(
vc
.
mHeight
)
;
const
auto
&
f
=
getCDR
(
vc
.
mFrameRate
)
;
if
(
w
.
mMin
.
WasPassed
(
)
|
|
h
.
mMin
.
WasPassed
(
)
|
|
f
.
mMin
.
WasPassed
(
)
)
{
p
-
>
MaybeRejectWithTypeError
(
"
min
not
allowed
"
)
;
return
p
.
forget
(
)
;
}
if
(
w
.
mExact
.
WasPassed
(
)
|
|
h
.
mExact
.
WasPassed
(
)
|
|
f
.
mExact
.
WasPassed
(
)
)
{
p
-
>
MaybeRejectWithTypeError
(
"
exact
not
allowed
"
)
;
return
p
.
forget
(
)
;
}
const
char
*
badConstraint
=
nullptr
;
if
(
w
.
mMax
.
WasPassed
(
)
&
&
w
.
mMax
.
Value
(
)
<
1
)
{
badConstraint
=
"
width
"
;
}
if
(
h
.
mMax
.
WasPassed
(
)
&
&
h
.
mMax
.
Value
(
)
<
1
)
{
badConstraint
=
"
height
"
;
}
if
(
f
.
mMax
.
WasPassed
(
)
&
&
f
.
mMax
.
Value
(
)
<
1
)
{
badConstraint
=
"
frameRate
"
;
}
if
(
badConstraint
)
{
p
-
>
MaybeReject
(
MakeRefPtr
<
dom
:
:
MediaStreamError
>
(
owner
*
MakeRefPtr
<
MediaMgrError
>
(
MediaMgrError
:
:
Name
:
:
OverconstrainedError
"
"
NS_ConvertASCIItoUTF16
(
badConstraint
)
)
)
)
;
return
p
.
forget
(
)
;
}
}
if
(
!
owner
-
>
IsFullyActive
(
)
)
{
p
-
>
MaybeRejectWithInvalidStateError
(
"
The
document
is
not
fully
active
.
"
)
;
return
p
.
forget
(
)
;
}
vc
.
mMediaSource
.
Reset
(
)
;
vc
.
mMediaSource
.
Construct
(
)
.
AssignASCII
(
dom
:
:
MediaSourceEnumValues
:
:
GetString
(
MediaSourceEnum
:
:
Screen
)
)
;
RefPtr
<
MediaDevices
>
self
(
this
)
;
MediaManager
:
:
Get
(
)
-
>
GetUserMedia
(
owner
c
aCallerType
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
this
self
p
]
(
RefPtr
<
DOMMediaStream
>
&
&
aStream
)
{
if
(
!
GetWindowIfCurrent
(
)
)
{
return
;
}
p
-
>
MaybeResolve
(
std
:
:
move
(
aStream
)
)
;
}
[
this
self
p
]
(
RefPtr
<
MediaMgrError
>
&
&
error
)
{
nsPIDOMWindowInner
*
window
=
GetWindowIfCurrent
(
)
;
if
(
!
window
)
{
return
;
}
error
-
>
Reject
(
p
)
;
}
)
;
return
p
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
MediaDevices
:
:
SelectAudioOutput
(
const
AudioOutputOptions
&
aOptions
CallerType
aCallerType
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
xpc
:
:
NativeGlobal
(
GetWrapper
(
)
)
;
RefPtr
<
Promise
>
p
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
owner
=
do_QueryInterface
(
global
)
;
WindowContext
*
wc
=
owner
-
>
GetWindowContext
(
)
;
if
(
!
wc
|
|
!
wc
-
>
HasValidTransientUserGestureActivation
(
)
)
{
p
-
>
MaybeRejectWithInvalidStateError
(
"
selectAudioOutput
requires
transient
user
activation
.
"
)
;
return
p
.
forget
(
)
;
}
RefPtr
<
MediaDevices
>
self
(
this
)
;
MediaManager
:
:
Get
(
)
-
>
SelectAudioOutput
(
owner
aOptions
aCallerType
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
this
self
p
]
(
RefPtr
<
LocalMediaDevice
>
aDevice
)
{
nsPIDOMWindowInner
*
window
=
GetWindowIfCurrent
(
)
;
if
(
!
window
)
{
return
;
}
MOZ_ASSERT
(
aDevice
-
>
Kind
(
)
=
=
dom
:
:
MediaDeviceKind
:
:
Audiooutput
)
;
mExplicitlyGrantedAudioOutputIds
.
Insert
(
aDevice
-
>
mID
)
;
p
-
>
MaybeResolve
(
MakeRefPtr
<
MediaDeviceInfo
>
(
aDevice
-
>
mID
aDevice
-
>
Kind
(
)
aDevice
-
>
mName
aDevice
-
>
mGroupID
)
)
;
}
[
this
self
p
]
(
const
RefPtr
<
MediaMgrError
>
&
error
)
{
nsPIDOMWindowInner
*
window
=
GetWindowIfCurrent
(
)
;
if
(
!
window
)
{
return
;
}
error
-
>
Reject
(
p
)
;
}
)
;
return
p
.
forget
(
)
;
}
static
RefPtr
<
AudioDeviceInfo
>
CopyWithNullDeviceId
(
AudioDeviceInfo
*
aDeviceInfo
)
{
MOZ_ASSERT
(
aDeviceInfo
-
>
Preferred
(
)
)
;
nsString
vendor
;
aDeviceInfo
-
>
GetVendor
(
vendor
)
;
uint16_t
type
;
aDeviceInfo
-
>
GetType
(
&
type
)
;
uint16_t
state
;
aDeviceInfo
-
>
GetState
(
&
state
)
;
uint16_t
pref
;
aDeviceInfo
-
>
GetPreferred
(
&
pref
)
;
uint16_t
supportedFormat
;
aDeviceInfo
-
>
GetSupportedFormat
(
&
supportedFormat
)
;
uint16_t
defaultFormat
;
aDeviceInfo
-
>
GetDefaultFormat
(
&
defaultFormat
)
;
uint32_t
maxChannels
;
aDeviceInfo
-
>
GetMaxChannels
(
&
maxChannels
)
;
uint32_t
defaultRate
;
aDeviceInfo
-
>
GetDefaultRate
(
&
defaultRate
)
;
uint32_t
maxRate
;
aDeviceInfo
-
>
GetMaxRate
(
&
maxRate
)
;
uint32_t
minRate
;
aDeviceInfo
-
>
GetMinRate
(
&
minRate
)
;
uint32_t
maxLatency
;
aDeviceInfo
-
>
GetMaxLatency
(
&
maxLatency
)
;
uint32_t
minLatency
;
aDeviceInfo
-
>
GetMinLatency
(
&
minLatency
)
;
return
MakeRefPtr
<
AudioDeviceInfo
>
(
nullptr
aDeviceInfo
-
>
Name
(
)
aDeviceInfo
-
>
GroupID
(
)
vendor
type
state
pref
supportedFormat
defaultFormat
maxChannels
defaultRate
maxRate
minRate
maxLatency
minLatency
)
;
}
RefPtr
<
MediaDevices
:
:
SinkInfoPromise
>
MediaDevices
:
:
GetSinkDevice
(
const
nsString
&
aDeviceId
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
isExposed
=
aDeviceId
.
IsEmpty
(
)
|
|
mExplicitlyGrantedAudioOutputIds
.
Contains
(
aDeviceId
)
;
MediaSourceEnum
audioInputType
=
isExposed
|
|
!
mCanExposeMicrophoneInfo
?
MediaSourceEnum
:
:
Other
:
MediaSourceEnum
:
:
Microphone
;
return
MediaManager
:
:
Get
(
)
-
>
EnumerateDevicesImpl
(
GetOwner
(
)
MediaSourceEnum
:
:
Other
audioInputType
EnumerationFlag
:
:
EnumerateAudioOutputs
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
aDeviceId
isExposed
]
(
RefPtr
<
LocalMediaDeviceSetRefCnt
>
aDevices
)
mutable
{
RefPtr
<
AudioDeviceInfo
>
outputInfo
;
nsString
groupId
;
for
(
const
RefPtr
<
LocalMediaDevice
>
&
device
:
*
aDevices
)
{
if
(
device
-
>
Kind
(
)
!
=
dom
:
:
MediaDeviceKind
:
:
Audiooutput
)
{
continue
;
}
if
(
aDeviceId
.
IsEmpty
(
)
)
{
if
(
device
-
>
GetAudioDeviceInfo
(
)
-
>
Preferred
(
)
)
{
outputInfo
=
CopyWithNullDeviceId
(
device
-
>
GetAudioDeviceInfo
(
)
)
;
break
;
}
}
else
if
(
aDeviceId
.
Equals
(
device
-
>
mID
)
)
{
outputInfo
=
device
-
>
GetAudioDeviceInfo
(
)
;
groupId
=
device
-
>
mGroupID
;
break
;
}
}
if
(
outputInfo
&
&
!
isExposed
)
{
MOZ_ASSERT
(
!
groupId
.
IsEmpty
(
)
)
;
for
(
const
RefPtr
<
LocalMediaDevice
>
&
device
:
*
aDevices
)
{
if
(
device
-
>
Kind
(
)
!
=
dom
:
:
MediaDeviceKind
:
:
Audioinput
)
{
continue
;
}
if
(
groupId
.
Equals
(
device
-
>
mGroupID
)
)
{
isExposed
=
true
;
break
;
}
}
}
if
(
!
outputInfo
|
|
!
isExposed
)
{
return
SinkInfoPromise
:
:
CreateAndReject
(
NS_ERROR_NOT_AVAILABLE
__func__
)
;
}
return
SinkInfoPromise
:
:
CreateAndResolve
(
outputInfo
__func__
)
;
}
[
]
(
RefPtr
<
MediaMgrError
>
&
&
aError
)
{
return
SinkInfoPromise
:
:
CreateAndReject
(
NS_ERROR_NOT_AVAILABLE
__func__
)
;
}
)
;
}
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
MediaDevices
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
MediaDevices
DOMEventTargetHelper
mPendingEnumerateDevicesPromises
)
void
MediaDevices
:
:
OnDeviceChange
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_FAILED
(
CheckCurrentGlobalCorrectness
(
)
)
)
{
return
;
}
if
(
!
(
MediaManager
:
:
Get
(
)
-
>
IsActivelyCapturingOrHasAPermission
(
GetOwner
(
)
-
>
WindowID
(
)
)
|
|
Preferences
:
:
GetBool
(
"
media
.
navigator
.
permission
.
disabled
"
false
)
)
)
{
return
;
}
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
)
{
return
;
}
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
"
devicechange
"
[
self
=
RefPtr
(
this
)
this
]
{
DispatchTrustedEvent
(
u
"
devicechange
"
_ns
)
;
}
)
)
;
}
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
MediaDevices
:
:
GetOndevicechange
(
)
{
return
GetEventHandler
(
nsGkAtoms
:
:
ondevicechange
)
;
}
void
MediaDevices
:
:
SetupDeviceChangeListener
(
)
{
if
(
mIsDeviceChangeListenerSetUp
)
{
return
;
}
nsPIDOMWindowInner
*
window
=
GetOwner
(
)
;
if
(
!
window
)
{
return
;
}
nsISerialEventTarget
*
mainThread
=
window
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
;
if
(
!
mainThread
)
{
return
;
}
mDeviceChangeListener
=
MediaManager
:
:
Get
(
)
-
>
DeviceListChangeEvent
(
)
.
Connect
(
mainThread
this
&
MediaDevices
:
:
OnDeviceChange
)
;
mIsDeviceChangeListenerSetUp
=
true
;
}
void
MediaDevices
:
:
SetOndevicechange
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
aCallback
)
{
SetEventHandler
(
nsGkAtoms
:
:
ondevicechange
aCallback
)
;
}
void
MediaDevices
:
:
EventListenerAdded
(
nsAtom
*
aType
)
{
DOMEventTargetHelper
:
:
EventListenerAdded
(
aType
)
;
SetupDeviceChangeListener
(
)
;
}
JSObject
*
MediaDevices
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MediaDevices_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
