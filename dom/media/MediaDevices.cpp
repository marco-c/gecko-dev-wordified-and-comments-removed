#
include
"
mozilla
/
dom
/
MediaDevices
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamBinding
.
h
"
#
include
"
mozilla
/
dom
/
MediaDeviceInfo
.
h
"
#
include
"
mozilla
/
dom
/
MediaDevicesBinding
.
h
"
#
include
"
mozilla
/
dom
/
NavigatorBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
WindowContext
.
h
"
#
include
"
mozilla
/
MediaManager
.
h
"
#
include
"
MediaTrackConstraints
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsQueryObject
.
h
"
#
define
DEVICECHANGE_HOLD_TIME_IN_MS
1000
namespace
mozilla
:
:
dom
{
MediaDevices
:
:
MediaDevices
(
nsPIDOMWindowInner
*
aWindow
)
:
DOMEventTargetHelper
(
aWindow
)
{
}
MediaDevices
:
:
~
MediaDevices
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mFuzzTimer
)
{
mFuzzTimer
-
>
Cancel
(
)
;
}
mDeviceChangeListener
.
DisconnectIfExists
(
)
;
}
already_AddRefed
<
Promise
>
MediaDevices
:
:
GetUserMedia
(
const
MediaStreamConstraints
&
aConstraints
CallerType
aCallerType
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
xpc
:
:
NativeGlobal
(
GetWrapper
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
owner
=
do_QueryInterface
(
global
)
;
if
(
Document
*
doc
=
owner
-
>
GetExtantDoc
(
)
)
{
if
(
!
owner
-
>
IsSecureContext
(
)
)
{
doc
-
>
SetUseCounter
(
eUseCounter_custom_GetUserMediaInsec
)
;
}
Document
*
topDoc
=
doc
-
>
GetTopLevelContentDocumentIfSameProcess
(
)
;
IgnoredErrorResult
ignored
;
if
(
topDoc
&
&
!
topDoc
-
>
HasFocus
(
ignored
)
)
{
doc
-
>
SetUseCounter
(
eUseCounter_custom_GetUserMediaUnfocused
)
;
}
}
RefPtr
<
Promise
>
p
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
!
MediaManager
:
:
IsOn
(
aConstraints
.
mVideo
)
&
&
!
MediaManager
:
:
IsOn
(
aConstraints
.
mAudio
)
)
{
p
-
>
MaybeRejectWithTypeError
(
"
audio
and
/
or
video
is
required
"
)
;
return
p
.
forget
(
)
;
}
if
(
!
owner
-
>
IsFullyActive
(
)
)
{
p
-
>
MaybeRejectWithInvalidStateError
(
"
The
document
is
not
fully
active
.
"
)
;
return
p
.
forget
(
)
;
}
const
OwningBooleanOrMediaTrackConstraints
&
audio
=
aConstraints
.
mAudio
;
bool
isMicrophone
=
audio
.
IsBoolean
(
)
?
audio
.
GetAsBoolean
(
)
:
!
audio
.
GetAsMediaTrackConstraints
(
)
.
mMediaSource
.
WasPassed
(
)
;
RefPtr
<
MediaDevices
>
self
(
this
)
;
MediaManager
:
:
Get
(
)
-
>
GetUserMedia
(
owner
aConstraints
aCallerType
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
this
self
p
isMicrophone
]
(
RefPtr
<
DOMMediaStream
>
&
&
aStream
)
{
if
(
!
GetWindowIfCurrent
(
)
)
{
return
;
}
if
(
isMicrophone
)
{
mCanExposeMicrophoneInfo
=
true
;
}
p
-
>
MaybeResolve
(
std
:
:
move
(
aStream
)
)
;
}
[
this
self
p
]
(
const
RefPtr
<
MediaMgrError
>
&
error
)
{
nsPIDOMWindowInner
*
window
=
GetWindowIfCurrent
(
)
;
if
(
!
window
)
{
return
;
}
error
-
>
Reject
(
p
)
;
}
)
;
return
p
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
MediaDevices
:
:
EnumerateDevices
(
CallerType
aCallerType
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
xpc
:
:
NativeGlobal
(
GetWrapper
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
owner
=
do_QueryInterface
(
global
)
;
if
(
Document
*
doc
=
owner
-
>
GetExtantDoc
(
)
)
{
if
(
!
owner
-
>
IsSecureContext
(
)
)
{
doc
-
>
SetUseCounter
(
eUseCounter_custom_EnumerateDevicesInsec
)
;
}
Document
*
topDoc
=
doc
-
>
GetTopLevelContentDocumentIfSameProcess
(
)
;
IgnoredErrorResult
ignored
;
if
(
topDoc
&
&
!
topDoc
-
>
HasFocus
(
ignored
)
)
{
doc
-
>
SetUseCounter
(
eUseCounter_custom_EnumerateDevicesUnfocused
)
;
}
}
RefPtr
<
Promise
>
p
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
RefPtr
<
MediaDevices
>
self
(
this
)
;
MediaManager
:
:
Get
(
)
-
>
EnumerateDevices
(
owner
aCallerType
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
this
self
p
]
(
RefPtr
<
MediaManager
:
:
MediaDeviceSetRefCnt
>
&
&
aDevices
)
{
nsPIDOMWindowInner
*
window
=
GetWindowIfCurrent
(
)
;
if
(
!
window
)
{
return
;
}
auto
windowId
=
window
-
>
WindowID
(
)
;
nsTArray
<
RefPtr
<
MediaDeviceInfo
>
>
infos
;
bool
allowLabel
=
aDevices
-
>
Length
(
)
=
=
0
|
|
MediaManager
:
:
Get
(
)
-
>
IsActivelyCapturingOrHasAPermission
(
windowId
)
;
nsTHashSet
<
nsString
>
exposedMicrophoneGroupIds
;
for
(
auto
&
device
:
*
aDevices
)
{
nsString
label
;
MOZ_ASSERT
(
device
-
>
mKind
<
MediaDeviceKind
:
:
EndGuard_
)
;
switch
(
device
-
>
mKind
)
{
case
MediaDeviceKind
:
:
Audioinput
:
if
(
mCanExposeMicrophoneInfo
)
{
exposedMicrophoneGroupIds
.
Insert
(
device
-
>
mGroupID
)
;
}
[
[
fallthrough
]
]
;
case
MediaDeviceKind
:
:
Videoinput
:
if
(
allowLabel
|
|
Preferences
:
:
GetBool
(
"
media
.
navigator
.
permission
.
disabled
"
false
)
)
{
label
=
device
-
>
mName
;
}
break
;
case
MediaDeviceKind
:
:
Audiooutput
:
if
(
!
mExplicitlyGrantedAudioOutputIds
.
Contains
(
device
-
>
mID
)
&
&
!
exposedMicrophoneGroupIds
.
Contains
(
device
-
>
mGroupID
)
)
{
continue
;
}
label
=
device
-
>
mName
;
break
;
case
MediaDeviceKind
:
:
EndGuard_
:
break
;
}
infos
.
AppendElement
(
MakeRefPtr
<
MediaDeviceInfo
>
(
device
-
>
mID
device
-
>
mKind
label
device
-
>
mGroupID
)
)
;
}
p
-
>
MaybeResolve
(
std
:
:
move
(
infos
)
)
;
}
[
this
self
p
]
(
const
RefPtr
<
MediaMgrError
>
&
error
)
{
nsPIDOMWindowInner
*
window
=
GetWindowIfCurrent
(
)
;
if
(
!
window
)
{
return
;
}
error
-
>
Reject
(
p
)
;
}
)
;
return
p
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
MediaDevices
:
:
GetDisplayMedia
(
const
DisplayMediaStreamConstraints
&
aConstraints
CallerType
aCallerType
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
xpc
:
:
NativeGlobal
(
GetWrapper
(
)
)
;
RefPtr
<
Promise
>
p
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
owner
=
do_QueryInterface
(
global
)
;
WindowContext
*
wc
=
owner
-
>
GetWindowContext
(
)
;
if
(
!
wc
|
|
!
wc
-
>
HasBeenUserGestureActivated
(
)
)
{
p
-
>
MaybeRejectWithInvalidStateError
(
"
getDisplayMedia
must
be
called
from
a
user
gesture
handler
.
"
)
;
return
p
.
forget
(
)
;
}
if
(
!
MediaManager
:
:
IsOn
(
aConstraints
.
mVideo
)
)
{
p
-
>
MaybeRejectWithTypeError
(
"
video
is
required
"
)
;
return
p
.
forget
(
)
;
}
MediaStreamConstraints
c
;
auto
&
vc
=
c
.
mVideo
.
SetAsMediaTrackConstraints
(
)
;
if
(
aConstraints
.
mVideo
.
IsMediaTrackConstraints
(
)
)
{
vc
=
aConstraints
.
mVideo
.
GetAsMediaTrackConstraints
(
)
;
if
(
vc
.
mAdvanced
.
WasPassed
(
)
)
{
p
-
>
MaybeRejectWithTypeError
(
"
advanced
not
allowed
"
)
;
return
p
.
forget
(
)
;
}
auto
getCLR
=
[
]
(
const
auto
&
aCon
)
-
>
const
ConstrainLongRange
&
{
static
ConstrainLongRange
empty
;
return
(
aCon
.
WasPassed
(
)
&
&
!
aCon
.
Value
(
)
.
IsLong
(
)
)
?
aCon
.
Value
(
)
.
GetAsConstrainLongRange
(
)
:
empty
;
}
;
auto
getCDR
=
[
]
(
auto
&
&
aCon
)
-
>
const
ConstrainDoubleRange
&
{
static
ConstrainDoubleRange
empty
;
return
(
aCon
.
WasPassed
(
)
&
&
!
aCon
.
Value
(
)
.
IsDouble
(
)
)
?
aCon
.
Value
(
)
.
GetAsConstrainDoubleRange
(
)
:
empty
;
}
;
const
auto
&
w
=
getCLR
(
vc
.
mWidth
)
;
const
auto
&
h
=
getCLR
(
vc
.
mHeight
)
;
const
auto
&
f
=
getCDR
(
vc
.
mFrameRate
)
;
if
(
w
.
mMin
.
WasPassed
(
)
|
|
h
.
mMin
.
WasPassed
(
)
|
|
f
.
mMin
.
WasPassed
(
)
)
{
p
-
>
MaybeRejectWithTypeError
(
"
min
not
allowed
"
)
;
return
p
.
forget
(
)
;
}
if
(
w
.
mExact
.
WasPassed
(
)
|
|
h
.
mExact
.
WasPassed
(
)
|
|
f
.
mExact
.
WasPassed
(
)
)
{
p
-
>
MaybeRejectWithTypeError
(
"
exact
not
allowed
"
)
;
return
p
.
forget
(
)
;
}
const
char
*
badConstraint
=
nullptr
;
if
(
w
.
mMax
.
WasPassed
(
)
&
&
w
.
mMax
.
Value
(
)
<
1
)
{
badConstraint
=
"
width
"
;
}
if
(
h
.
mMax
.
WasPassed
(
)
&
&
h
.
mMax
.
Value
(
)
<
1
)
{
badConstraint
=
"
height
"
;
}
if
(
f
.
mMax
.
WasPassed
(
)
&
&
f
.
mMax
.
Value
(
)
<
1
)
{
badConstraint
=
"
frameRate
"
;
}
if
(
badConstraint
)
{
p
-
>
MaybeReject
(
MakeRefPtr
<
dom
:
:
MediaStreamError
>
(
owner
*
MakeRefPtr
<
MediaMgrError
>
(
MediaMgrError
:
:
Name
:
:
OverconstrainedError
"
"
NS_ConvertASCIItoUTF16
(
badConstraint
)
)
)
)
;
return
p
.
forget
(
)
;
}
}
if
(
!
owner
-
>
IsFullyActive
(
)
)
{
p
-
>
MaybeRejectWithInvalidStateError
(
"
The
document
is
not
fully
active
.
"
)
;
return
p
.
forget
(
)
;
}
vc
.
mMediaSource
.
Reset
(
)
;
vc
.
mMediaSource
.
Construct
(
)
.
AssignASCII
(
dom
:
:
MediaSourceEnumValues
:
:
GetString
(
MediaSourceEnum
:
:
Screen
)
)
;
RefPtr
<
MediaDevices
>
self
(
this
)
;
MediaManager
:
:
Get
(
)
-
>
GetUserMedia
(
owner
c
aCallerType
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
this
self
p
]
(
RefPtr
<
DOMMediaStream
>
&
&
aStream
)
{
if
(
!
GetWindowIfCurrent
(
)
)
{
return
;
}
p
-
>
MaybeResolve
(
std
:
:
move
(
aStream
)
)
;
}
[
this
self
p
]
(
RefPtr
<
MediaMgrError
>
&
&
error
)
{
nsPIDOMWindowInner
*
window
=
GetWindowIfCurrent
(
)
;
if
(
!
window
)
{
return
;
}
error
-
>
Reject
(
p
)
;
}
)
;
return
p
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
MediaDevices
:
:
SelectAudioOutput
(
const
AudioOutputOptions
&
aOptions
CallerType
aCallerType
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
xpc
:
:
NativeGlobal
(
GetWrapper
(
)
)
;
RefPtr
<
Promise
>
p
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
owner
=
do_QueryInterface
(
global
)
;
WindowContext
*
wc
=
owner
-
>
GetWindowContext
(
)
;
if
(
!
wc
|
|
!
wc
-
>
HasValidTransientUserGestureActivation
(
)
)
{
p
-
>
MaybeRejectWithInvalidStateError
(
"
selectAudioOutput
requires
transient
user
activation
.
"
)
;
return
p
.
forget
(
)
;
}
RefPtr
<
MediaDevices
>
self
(
this
)
;
MediaManager
:
:
Get
(
)
-
>
SelectAudioOutput
(
owner
aOptions
aCallerType
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
this
self
p
]
(
RefPtr
<
MediaDevice
>
aDevice
)
{
nsPIDOMWindowInner
*
window
=
GetWindowIfCurrent
(
)
;
if
(
!
window
)
{
return
;
}
MOZ_ASSERT
(
aDevice
-
>
mKind
=
=
dom
:
:
MediaDeviceKind
:
:
Audiooutput
)
;
mExplicitlyGrantedAudioOutputIds
.
Insert
(
aDevice
-
>
mID
)
;
p
-
>
MaybeResolve
(
MakeRefPtr
<
MediaDeviceInfo
>
(
aDevice
-
>
mID
aDevice
-
>
mKind
aDevice
-
>
mName
aDevice
-
>
mGroupID
)
)
;
}
[
this
self
p
]
(
const
RefPtr
<
MediaMgrError
>
&
error
)
{
nsPIDOMWindowInner
*
window
=
GetWindowIfCurrent
(
)
;
if
(
!
window
)
{
return
;
}
error
-
>
Reject
(
p
)
;
}
)
;
return
p
.
forget
(
)
;
}
NS_IMPL_ADDREF_INHERITED
(
MediaDevices
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
MediaDevices
DOMEventTargetHelper
)
NS_INTERFACE_MAP_BEGIN
(
MediaDevices
)
NS_INTERFACE_MAP_ENTRY
(
MediaDevices
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
void
MediaDevices
:
:
OnDeviceChange
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_FAILED
(
CheckCurrentGlobalCorrectness
(
)
)
)
{
return
;
}
if
(
!
(
MediaManager
:
:
Get
(
)
-
>
IsActivelyCapturingOrHasAPermission
(
GetOwner
(
)
-
>
WindowID
(
)
)
|
|
Preferences
:
:
GetBool
(
"
media
.
navigator
.
permission
.
disabled
"
false
)
)
)
{
return
;
}
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
)
{
return
;
}
if
(
mFuzzTimer
)
{
return
;
}
mFuzzTimer
=
NS_NewTimer
(
)
;
if
(
!
mFuzzTimer
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
mFuzzTimer
-
>
InitWithNamedFuncCallback
(
[
]
(
nsITimer
*
void
*
aClosure
)
{
MediaDevices
*
md
=
static_cast
<
MediaDevices
*
>
(
aClosure
)
;
md
-
>
DispatchTrustedEvent
(
u
"
devicechange
"
_ns
)
;
md
-
>
mFuzzTimer
=
nullptr
;
}
this
DEVICECHANGE_HOLD_TIME_IN_MS
nsITimer
:
:
TYPE_ONE_SHOT
"
MediaDevices
:
:
mFuzzTimer
Callback
"
)
;
}
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
MediaDevices
:
:
GetOndevicechange
(
)
{
return
GetEventHandler
(
nsGkAtoms
:
:
ondevicechange
)
;
}
void
MediaDevices
:
:
SetupDeviceChangeListener
(
)
{
if
(
mIsDeviceChangeListenerSetUp
)
{
return
;
}
nsPIDOMWindowInner
*
window
=
GetOwner
(
)
;
if
(
!
window
)
{
return
;
}
nsISerialEventTarget
*
mainThread
=
window
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
;
if
(
!
mainThread
)
{
return
;
}
mDeviceChangeListener
=
MediaManager
:
:
Get
(
)
-
>
DeviceListChangeEvent
(
)
.
Connect
(
mainThread
this
&
MediaDevices
:
:
OnDeviceChange
)
;
mIsDeviceChangeListenerSetUp
=
true
;
}
void
MediaDevices
:
:
SetOndevicechange
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
aCallback
)
{
SetEventHandler
(
nsGkAtoms
:
:
ondevicechange
aCallback
)
;
SetupDeviceChangeListener
(
)
;
}
void
MediaDevices
:
:
EventListenerAdded
(
nsAtom
*
aType
)
{
DOMEventTargetHelper
:
:
EventListenerAdded
(
aType
)
;
SetupDeviceChangeListener
(
)
;
}
JSObject
*
MediaDevices
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MediaDevices_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
