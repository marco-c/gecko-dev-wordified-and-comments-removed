#
include
"
MediaTimer
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
<
math
.
h
>
namespace
mozilla
{
NS_IMPL_ADDREF
(
MediaTimer
)
NS_IMPL_RELEASE_WITH_DESTROY
(
MediaTimer
DispatchDestroy
(
)
)
MediaTimer
:
:
MediaTimer
(
)
:
mMonitor
(
"
MediaTimer
Monitor
"
)
mTimer
(
NS_NewTimer
(
)
)
mCreationTimeStamp
(
TimeStamp
:
:
Now
(
)
)
mUpdateScheduled
(
false
)
{
TIMER_LOG
(
"
MediaTimer
:
:
MediaTimer
"
)
;
RefPtr
<
SharedThreadPool
>
threadPool
(
SharedThreadPool
:
:
Get
(
NS_LITERAL_CSTRING
(
"
MediaTimer
"
)
1
)
)
;
mThread
=
threadPool
.
get
(
)
;
mTimer
-
>
SetTarget
(
mThread
)
;
}
void
MediaTimer
:
:
DispatchDestroy
(
)
{
nsCOMPtr
<
nsIEventTarget
>
thread
=
mThread
;
nsresult
rv
=
thread
-
>
Dispatch
(
NewNonOwningRunnableMethod
(
"
MediaTimer
:
:
Destroy
"
this
&
MediaTimer
:
:
Destroy
)
NS_DISPATCH_NORMAL
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
Unused
<
<
rv
;
(
void
)
rv
;
}
void
MediaTimer
:
:
Destroy
(
)
{
MOZ_ASSERT
(
OnMediaTimerThread
(
)
)
;
TIMER_LOG
(
"
MediaTimer
:
:
Destroy
"
)
;
while
(
!
mEntries
.
empty
(
)
)
{
mEntries
.
top
(
)
.
mPromise
-
>
Reject
(
false
__func__
)
;
mEntries
.
pop
(
)
;
}
CancelTimerIfArmed
(
)
;
delete
this
;
}
bool
MediaTimer
:
:
OnMediaTimerThread
(
)
{
bool
rv
=
false
;
mThread
-
>
IsOnCurrentThread
(
&
rv
)
;
return
rv
;
}
RefPtr
<
MediaTimerPromise
>
MediaTimer
:
:
WaitUntil
(
const
TimeStamp
&
aTimeStamp
const
char
*
aCallSite
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
TIMER_LOG
(
"
MediaTimer
:
:
WaitUntil
%
"
PRId64
RelativeMicroseconds
(
aTimeStamp
)
)
;
Entry
e
(
aTimeStamp
aCallSite
)
;
RefPtr
<
MediaTimerPromise
>
p
=
e
.
mPromise
.
get
(
)
;
mEntries
.
push
(
e
)
;
ScheduleUpdate
(
)
;
return
p
;
}
void
MediaTimer
:
:
ScheduleUpdate
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
mUpdateScheduled
)
{
return
;
}
mUpdateScheduled
=
true
;
nsresult
rv
=
mThread
-
>
Dispatch
(
NewRunnableMethod
(
"
MediaTimer
:
:
Update
"
this
&
MediaTimer
:
:
Update
)
NS_DISPATCH_NORMAL
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
Unused
<
<
rv
;
(
void
)
rv
;
}
void
MediaTimer
:
:
Update
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
UpdateLocked
(
)
;
}
void
MediaTimer
:
:
UpdateLocked
(
)
{
MOZ_ASSERT
(
OnMediaTimerThread
(
)
)
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
mUpdateScheduled
=
false
;
TIMER_LOG
(
"
MediaTimer
:
:
UpdateLocked
"
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
while
(
!
mEntries
.
empty
(
)
&
&
mEntries
.
top
(
)
.
mTimeStamp
<
=
now
)
{
mEntries
.
top
(
)
.
mPromise
-
>
Resolve
(
true
__func__
)
;
DebugOnly
<
TimeStamp
>
poppedTimeStamp
=
mEntries
.
top
(
)
.
mTimeStamp
;
mEntries
.
pop
(
)
;
MOZ_ASSERT_IF
(
!
mEntries
.
empty
(
)
*
&
poppedTimeStamp
<
=
mEntries
.
top
(
)
.
mTimeStamp
)
;
}
if
(
mEntries
.
empty
(
)
)
{
CancelTimerIfArmed
(
)
;
return
;
}
if
(
!
TimerIsArmed
(
)
|
|
mEntries
.
top
(
)
.
mTimeStamp
<
mCurrentTimerTarget
)
{
CancelTimerIfArmed
(
)
;
ArmTimer
(
mEntries
.
top
(
)
.
mTimeStamp
now
)
;
}
}
void
MediaTimer
:
:
TimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
static_cast
<
MediaTimer
*
>
(
aClosure
)
-
>
TimerFired
(
)
;
}
void
MediaTimer
:
:
TimerFired
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
MOZ_ASSERT
(
OnMediaTimerThread
(
)
)
;
mCurrentTimerTarget
=
TimeStamp
(
)
;
UpdateLocked
(
)
;
}
void
MediaTimer
:
:
ArmTimer
(
const
TimeStamp
&
aTarget
const
TimeStamp
&
aNow
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
TimerIsArmed
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aTarget
>
aNow
)
;
unsigned
long
delay
=
std
:
:
ceil
(
(
aTarget
-
aNow
)
.
ToMilliseconds
(
)
)
;
TIMER_LOG
(
"
MediaTimer
:
:
ArmTimer
delay
=
%
lu
"
delay
)
;
mCurrentTimerTarget
=
aTarget
;
nsresult
rv
=
mTimer
-
>
InitWithNamedFuncCallback
(
&
TimerCallback
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
"
MediaTimer
:
:
TimerCallback
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
Unused
<
<
rv
;
(
void
)
rv
;
}
}
