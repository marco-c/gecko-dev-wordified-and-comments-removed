#
include
"
AudioConfig
.
h
"
#
include
<
array
>
#
include
"
nsString
.
h
"
namespace
mozilla
{
using
ChannelLayout
=
AudioConfig
:
:
ChannelLayout
;
void
AudioConfig
:
:
ChannelLayout
:
:
UpdateChannelMap
(
)
{
mValid
=
mChannels
.
Length
(
)
<
=
MAX_CHANNELS
;
mChannelMap
=
UNKNOWN_MAP
;
if
(
mValid
)
{
mChannelMap
=
Map
(
)
;
mValid
=
mChannelMap
>
0
;
}
}
auto
AudioConfig
:
:
ChannelLayout
:
:
Map
(
)
const
-
>
ChannelMap
{
if
(
mChannelMap
!
=
UNKNOWN_MAP
)
{
return
mChannelMap
;
}
if
(
mChannels
.
Length
(
)
>
MAX_CHANNELS
)
{
return
UNKNOWN_MAP
;
}
ChannelMap
map
=
UNKNOWN_MAP
;
for
(
size_t
i
=
0
;
i
<
mChannels
.
Length
(
)
;
i
+
+
)
{
if
(
uint32_t
(
mChannels
[
i
]
)
>
sizeof
(
ChannelMap
)
*
8
)
{
return
UNKNOWN_MAP
;
}
ChannelMap
mask
=
1
<
<
mChannels
[
i
]
;
if
(
mChannels
[
i
]
=
=
CHANNEL_INVALID
|
|
(
mChannelMap
&
mask
)
)
{
return
UNKNOWN_MAP
;
}
map
|
=
mask
;
}
return
map
;
}
const
AudioConfig
:
:
Channel
*
AudioConfig
:
:
ChannelLayout
:
:
DefaultLayoutForChannels
(
uint32_t
aChannels
)
const
{
switch
(
aChannels
)
{
case
1
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_FRONT_CENTER
}
;
return
config
;
}
case
2
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
}
;
return
config
;
}
case
3
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
}
;
return
config
;
}
case
4
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_BACK_LEFT
CHANNEL_BACK_RIGHT
}
;
return
config
;
}
case
5
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
CHANNEL_SIDE_LEFT
CHANNEL_SIDE_RIGHT
}
;
return
config
;
}
case
6
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
CHANNEL_LFE
CHANNEL_SIDE_LEFT
CHANNEL_SIDE_RIGHT
}
;
return
config
;
}
case
7
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
CHANNEL_LFE
CHANNEL_BACK_CENTER
CHANNEL_SIDE_LEFT
CHANNEL_SIDE_RIGHT
}
;
return
config
;
}
case
8
:
{
static
const
Channel
config
[
]
=
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
CHANNEL_LFE
CHANNEL_BACK_LEFT
CHANNEL_BACK_RIGHT
CHANNEL_SIDE_LEFT
CHANNEL_SIDE_RIGHT
}
;
return
config
;
}
default
:
return
nullptr
;
}
}
AudioConfig
:
:
ChannelLayout
AudioConfig
:
:
ChannelLayout
:
:
SMPTEDefault
(
const
ChannelLayout
&
aChannelLayout
)
{
if
(
!
aChannelLayout
.
IsValid
(
)
)
{
return
aChannelLayout
;
}
return
SMPTEDefault
(
aChannelLayout
.
Map
(
)
)
;
}
ChannelLayout
AudioConfig
:
:
ChannelLayout
:
:
SMPTEDefault
(
ChannelMap
aMap
)
{
switch
(
aMap
)
{
case
LMONO_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_CENTER
}
;
case
LSTEREO_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
}
;
case
L3F_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
}
;
case
L3F_LFE_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
CHANNEL_LFE
}
;
case
L2F1_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_BACK_CENTER
}
;
case
L2F1_LFE_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_LFE
CHANNEL_BACK_CENTER
}
;
case
L3F1_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
CHANNEL_BACK_CENTER
}
;
case
L3F1_LFE_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
CHANNEL_LFE
CHANNEL_BACK_CENTER
}
;
case
L2F2_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_SIDE_LEFT
CHANNEL_SIDE_RIGHT
}
;
case
L2F2_LFE_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_LFE
CHANNEL_SIDE_LEFT
CHANNEL_SIDE_RIGHT
}
;
case
LQUAD_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_BACK_LEFT
CHANNEL_BACK_RIGHT
}
;
case
LQUAD_LFE_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_LFE
CHANNEL_BACK_LEFT
CHANNEL_BACK_RIGHT
}
;
case
L3F2_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
CHANNEL_SIDE_LEFT
CHANNEL_SIDE_RIGHT
}
;
case
L3F2_LFE_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
CHANNEL_LFE
CHANNEL_SIDE_LEFT
CHANNEL_SIDE_RIGHT
}
;
case
L3F2_BACK_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
CHANNEL_BACK_LEFT
CHANNEL_BACK_RIGHT
}
;
case
L3F2_BACK_LFE_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
CHANNEL_LFE
CHANNEL_BACK_LEFT
CHANNEL_BACK_RIGHT
}
;
case
L3F3R_LFE_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
CHANNEL_LFE
CHANNEL_BACK_CENTER
CHANNEL_SIDE_LEFT
CHANNEL_SIDE_RIGHT
}
;
case
L3F4_LFE_MAP
:
return
ChannelLayout
{
CHANNEL_FRONT_LEFT
CHANNEL_FRONT_RIGHT
CHANNEL_FRONT_CENTER
CHANNEL_LFE
CHANNEL_BACK_LEFT
CHANNEL_BACK_RIGHT
CHANNEL_SIDE_LEFT
CHANNEL_SIDE_RIGHT
}
;
default
:
break
;
}
static_assert
(
MAX_CHANNELS
<
=
sizeof
(
ChannelMap
)
*
8
"
Must
be
able
to
fit
channels
on
bit
mask
"
)
;
AutoTArray
<
Channel
MAX_CHANNELS
>
layout
;
uint32_t
channels
=
0
;
uint32_t
i
=
0
;
while
(
aMap
)
{
if
(
aMap
&
1
)
{
channels
+
+
;
if
(
channels
>
MAX_CHANNELS
)
{
return
ChannelLayout
(
)
;
}
layout
.
AppendElement
(
static_cast
<
Channel
>
(
i
)
)
;
}
aMap
>
>
=
1
;
i
+
+
;
}
return
ChannelLayout
(
channels
layout
.
Elements
(
)
)
;
}
nsCString
AudioConfig
:
:
ChannelLayout
:
:
ChannelMapToString
(
const
ChannelMap
aChannelMap
)
{
nsCString
rv
;
constexpr
const
std
:
:
array
CHANNEL_NAME
=
{
"
Front
left
"
"
Front
right
"
"
Front
center
"
"
Low
frequency
"
"
Back
left
"
"
Back
right
"
"
Front
left
of
center
"
"
Front
right
of
center
"
"
Back
center
"
"
Side
left
"
"
Side
right
"
"
Top
center
"
"
Top
front
left
"
"
Top
front
center
"
"
Top
front
right
"
"
Top
back
left
"
"
Top
back
center
"
"
Top
back
right
"
}
;
rv
.
AppendPrintf
(
"
0x
%
08x
"
aChannelMap
)
;
rv
.
Append
(
"
[
"
)
;
bool
empty
=
true
;
for
(
size_t
i
=
0
;
i
<
CHANNEL_NAME
.
size
(
)
;
i
+
+
)
{
if
(
aChannelMap
&
(
1
<
<
i
)
)
{
if
(
!
empty
)
{
rv
.
Append
(
"
|
"
)
;
}
empty
=
false
;
rv
.
Append
(
CHANNEL_NAME
[
i
]
)
;
}
}
rv
.
Append
(
"
]
"
)
;
return
rv
;
}
bool
AudioConfig
:
:
ChannelLayout
:
:
MappingTable
(
const
ChannelLayout
&
aOther
nsTArray
<
uint8_t
>
*
aMap
)
const
{
if
(
!
IsValid
(
)
|
|
!
aOther
.
IsValid
(
)
|
|
Map
(
)
!
=
aOther
.
Map
(
)
)
{
if
(
aMap
)
{
aMap
-
>
SetLength
(
0
)
;
}
return
false
;
}
if
(
!
aMap
)
{
return
true
;
}
aMap
-
>
SetLength
(
Count
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
Count
(
)
;
i
+
+
)
{
for
(
uint32_t
j
=
0
;
j
<
Count
(
)
;
j
+
+
)
{
if
(
aOther
[
j
]
=
=
mChannels
[
i
]
)
{
(
*
aMap
)
[
j
]
=
i
;
break
;
}
}
}
return
true
;
}
const
char
*
AudioConfig
:
:
FormatToString
(
AudioConfig
:
:
SampleFormat
aFormat
)
{
switch
(
aFormat
)
{
case
FORMAT_U8
:
return
"
unsigned
8
bit
"
;
case
FORMAT_S16
:
return
"
signed
16
bit
"
;
case
FORMAT_S24
:
return
"
signed
24
bit
MSB
"
;
case
FORMAT_S24LSB
:
return
"
signed
24
bit
LSB
"
;
case
FORMAT_S32
:
return
"
signed
32
bit
"
;
case
FORMAT_FLT
:
return
"
32
bit
floating
point
"
;
case
FORMAT_NONE
:
return
"
none
"
;
default
:
return
"
unknown
"
;
}
}
uint32_t
AudioConfig
:
:
SampleSize
(
AudioConfig
:
:
SampleFormat
aFormat
)
{
switch
(
aFormat
)
{
case
FORMAT_U8
:
return
1
;
case
FORMAT_S16
:
return
2
;
case
FORMAT_S24
:
[
[
fallthrough
]
]
;
case
FORMAT_S24LSB
:
[
[
fallthrough
]
]
;
case
FORMAT_S32
:
[
[
fallthrough
]
]
;
case
FORMAT_FLT
:
return
4
;
case
FORMAT_NONE
:
default
:
return
0
;
}
}
uint32_t
AudioConfig
:
:
FormatToBits
(
AudioConfig
:
:
SampleFormat
aFormat
)
{
switch
(
aFormat
)
{
case
FORMAT_U8
:
return
8
;
case
FORMAT_S16
:
return
16
;
case
FORMAT_S24LSB
:
[
[
fallthrough
]
]
;
case
FORMAT_S24
:
return
24
;
case
FORMAT_S32
:
[
[
fallthrough
]
]
;
case
FORMAT_FLT
:
return
32
;
case
FORMAT_NONE
:
[
[
fallthrough
]
]
;
default
:
return
0
;
}
}
AudioConfig
:
:
AudioConfig
(
const
ChannelLayout
&
aChannelLayout
uint32_t
aRate
AudioConfig
:
:
SampleFormat
aFormat
bool
aInterleaved
)
:
mChannelLayout
(
aChannelLayout
)
mChannels
(
aChannelLayout
.
Count
(
)
)
mRate
(
aRate
)
mFormat
(
aFormat
)
mInterleaved
(
aInterleaved
)
{
}
AudioConfig
:
:
AudioConfig
(
const
ChannelLayout
&
aChannelLayout
uint32_t
aChannels
uint32_t
aRate
AudioConfig
:
:
SampleFormat
aFormat
bool
aInterleaved
)
:
mChannelLayout
(
aChannelLayout
)
mChannels
(
aChannels
)
mRate
(
aRate
)
mFormat
(
aFormat
)
mInterleaved
(
aInterleaved
)
{
}
AudioConfig
:
:
AudioConfig
(
uint32_t
aChannels
uint32_t
aRate
AudioConfig
:
:
SampleFormat
aFormat
bool
aInterleaved
)
:
mChannelLayout
(
aChannels
)
mChannels
(
aChannels
)
mRate
(
aRate
)
mFormat
(
aFormat
)
mInterleaved
(
aInterleaved
)
{
}
}
