#
include
"
DynamicResampler
.
h
"
namespace
mozilla
{
DynamicResampler
:
:
DynamicResampler
(
uint32_t
aInRate
uint32_t
aOutRate
uint32_t
aInputPreBufferFrameCount
)
:
mOutRate
(
aOutRate
)
mInputPreBufferFrameCount
(
aInputPreBufferFrameCount
)
mInRate
(
aInRate
)
{
MOZ_ASSERT
(
aInRate
)
;
MOZ_ASSERT
(
aOutRate
)
;
UpdateResampler
(
mInRate
STEREO
)
;
mInputStreamFile
.
Open
(
"
DynamicResamplerInFirstChannel
"
1
mInRate
)
;
mOutputStreamFile
.
Open
(
"
DynamicResamplerOutFirstChannel
"
1
mOutRate
)
;
}
DynamicResampler
:
:
~
DynamicResampler
(
)
{
if
(
mResampler
)
{
speex_resampler_destroy
(
mResampler
)
;
}
}
void
DynamicResampler
:
:
SetSampleFormat
(
AudioSampleFormat
aFormat
)
{
MOZ_ASSERT
(
mSampleFormat
=
=
AUDIO_FORMAT_SILENCE
)
;
MOZ_ASSERT
(
aFormat
=
=
AUDIO_FORMAT_S16
|
|
aFormat
=
=
AUDIO_FORMAT_FLOAT32
)
;
mSampleFormat
=
aFormat
;
for
(
AudioRingBuffer
&
b
:
mInternalInBuffer
)
{
b
.
SetSampleFormat
(
mSampleFormat
)
;
}
EnsureInputBufferSizeInFrames
(
mInRate
/
20
)
;
}
void
DynamicResampler
:
:
EnsurePreBuffer
(
media
:
:
TimeUnit
aDuration
)
{
if
(
mIsPreBufferSet
)
{
return
;
}
uint32_t
buffered
=
mInternalInBuffer
[
0
]
.
AvailableRead
(
)
;
if
(
buffered
=
=
0
)
{
return
;
}
mIsPreBufferSet
=
true
;
uint32_t
needed
=
aDuration
.
ToTicksAtRate
(
mInRate
)
+
mInputPreBufferFrameCount
;
EnsureInputBufferSizeInFrames
(
needed
)
;
if
(
needed
>
buffered
)
{
for
(
auto
&
b
:
mInternalInBuffer
)
{
b
.
PrependSilence
(
needed
-
buffered
)
;
}
}
else
if
(
needed
<
buffered
)
{
for
(
auto
&
b
:
mInternalInBuffer
)
{
b
.
Discard
(
buffered
-
needed
)
;
}
}
}
void
DynamicResampler
:
:
SetInputPreBufferFrameCount
(
uint32_t
aInputPreBufferFrameCount
)
{
mInputPreBufferFrameCount
=
aInputPreBufferFrameCount
;
}
bool
DynamicResampler
:
:
Resample
(
float
*
aOutBuffer
uint32_t
aOutFrames
uint32_t
aChannelIndex
)
{
MOZ_ASSERT
(
mSampleFormat
=
=
AUDIO_FORMAT_FLOAT32
)
;
return
ResampleInternal
(
aOutBuffer
aOutFrames
aChannelIndex
)
;
}
bool
DynamicResampler
:
:
Resample
(
int16_t
*
aOutBuffer
uint32_t
aOutFrames
uint32_t
aChannelIndex
)
{
MOZ_ASSERT
(
mSampleFormat
=
=
AUDIO_FORMAT_S16
)
;
return
ResampleInternal
(
aOutBuffer
aOutFrames
aChannelIndex
)
;
}
void
DynamicResampler
:
:
ResampleInternal
(
const
float
*
aInBuffer
uint32_t
*
aInFrames
float
*
aOutBuffer
uint32_t
*
aOutFrames
uint32_t
aChannelIndex
)
{
MOZ_ASSERT
(
mResampler
)
;
MOZ_ASSERT
(
mChannels
)
;
MOZ_ASSERT
(
mInRate
)
;
MOZ_ASSERT
(
mOutRate
)
;
MOZ_ASSERT
(
aInFrames
)
;
MOZ_ASSERT
(
*
aInFrames
>
0
)
;
MOZ_ASSERT
(
aOutBuffer
)
;
MOZ_ASSERT
(
aOutFrames
)
;
MOZ_ASSERT
(
*
aOutFrames
>
0
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mChannels
)
;
#
ifdef
DEBUG
int
rv
=
#
endif
speex_resampler_process_float
(
mResampler
aChannelIndex
aInBuffer
aInFrames
aOutBuffer
aOutFrames
)
;
MOZ_ASSERT
(
rv
=
=
RESAMPLER_ERR_SUCCESS
)
;
if
(
aChannelIndex
=
=
0
&
&
!
mIsWarmingUp
)
{
mInputStreamFile
.
Write
(
aInBuffer
*
aInFrames
)
;
mOutputStreamFile
.
Write
(
aOutBuffer
*
aOutFrames
)
;
}
}
void
DynamicResampler
:
:
ResampleInternal
(
const
int16_t
*
aInBuffer
uint32_t
*
aInFrames
int16_t
*
aOutBuffer
uint32_t
*
aOutFrames
uint32_t
aChannelIndex
)
{
MOZ_ASSERT
(
mResampler
)
;
MOZ_ASSERT
(
mChannels
)
;
MOZ_ASSERT
(
mInRate
)
;
MOZ_ASSERT
(
mOutRate
)
;
MOZ_ASSERT
(
aInFrames
)
;
MOZ_ASSERT
(
*
aInFrames
>
0
)
;
MOZ_ASSERT
(
aOutBuffer
)
;
MOZ_ASSERT
(
aOutFrames
)
;
MOZ_ASSERT
(
*
aOutFrames
>
0
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mChannels
)
;
#
ifdef
DEBUG
int
rv
=
#
endif
speex_resampler_process_int
(
mResampler
aChannelIndex
aInBuffer
aInFrames
aOutBuffer
aOutFrames
)
;
MOZ_ASSERT
(
rv
=
=
RESAMPLER_ERR_SUCCESS
)
;
if
(
aChannelIndex
=
=
0
&
&
!
mIsWarmingUp
)
{
mInputStreamFile
.
Write
(
aInBuffer
*
aInFrames
)
;
mOutputStreamFile
.
Write
(
aOutBuffer
*
aOutFrames
)
;
}
}
void
DynamicResampler
:
:
UpdateResampler
(
uint32_t
aInRate
uint32_t
aChannels
)
{
MOZ_ASSERT
(
aInRate
)
;
MOZ_ASSERT
(
aChannels
)
;
if
(
mChannels
!
=
aChannels
)
{
uint32_t
bufferSizeInFrames
=
InFramesBufferSize
(
)
;
if
(
mResampler
)
{
speex_resampler_destroy
(
mResampler
)
;
}
mResampler
=
speex_resampler_init
(
aChannels
aInRate
mOutRate
SPEEX_RESAMPLER_QUALITY_MIN
nullptr
)
;
MOZ_ASSERT
(
mResampler
)
;
mChannels
=
aChannels
;
mInRate
=
aInRate
;
if
(
(
mChannels
=
=
STEREO
|
|
mChannels
=
=
1
)
&
&
mInternalInBuffer
.
Length
(
)
=
=
STEREO
)
{
if
(
(
mSampleFormat
=
=
AUDIO_FORMAT_S16
|
|
mSampleFormat
=
=
AUDIO_FORMAT_FLOAT32
)
&
&
mChannels
=
=
STEREO
)
{
uint32_t
bufferedDuration
=
mInternalInBuffer
[
0
]
.
AvailableRead
(
)
;
mInternalInBuffer
[
1
]
.
Clear
(
)
;
if
(
bufferedDuration
)
{
mInternalInBuffer
[
1
]
.
Write
(
mInternalInBuffer
[
0
]
bufferedDuration
)
;
}
}
mInputTail
.
SetLength
(
STEREO
)
;
WarmUpResampler
(
false
)
;
return
;
}
mInternalInBuffer
.
Clear
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mChannels
;
+
+
i
)
{
AudioRingBuffer
*
b
=
mInternalInBuffer
.
AppendElement
(
0
)
;
if
(
mSampleFormat
!
=
AUDIO_FORMAT_SILENCE
)
{
b
-
>
SetSampleFormat
(
mSampleFormat
)
;
}
}
EnsureInputBufferSizeInFrames
(
bufferSizeInFrames
)
;
mInputTail
.
SetLength
(
mChannels
)
;
return
;
}
if
(
mInRate
!
=
aInRate
)
{
if
(
mOutRate
=
=
mInRate
)
{
WarmUpResampler
(
true
)
;
}
#
ifdef
DEBUG
int
rv
=
#
endif
speex_resampler_set_rate
(
mResampler
aInRate
mOutRate
)
;
MOZ_ASSERT
(
rv
=
=
RESAMPLER_ERR_SUCCESS
)
;
mInRate
=
aInRate
;
}
}
void
DynamicResampler
:
:
WarmUpResampler
(
bool
aSkipLatency
)
{
MOZ_ASSERT
(
mInputTail
.
Length
(
)
)
;
mIsWarmingUp
=
true
;
for
(
uint32_t
i
=
0
;
i
<
mChannels
;
+
+
i
)
{
if
(
!
mInputTail
[
i
]
.
Length
(
)
)
{
continue
;
}
uint32_t
inFrames
=
mInputTail
[
i
]
.
Length
(
)
;
uint32_t
outFrames
=
5
*
TailBuffer
:
:
MAXSIZE
;
if
(
mSampleFormat
=
=
AUDIO_FORMAT_S16
)
{
short
outBuffer
[
5
*
TailBuffer
:
:
MAXSIZE
]
=
{
}
;
ResampleInternal
(
mInputTail
[
i
]
.
Buffer
<
short
>
(
)
&
inFrames
outBuffer
&
outFrames
i
)
;
MOZ_ASSERT
(
inFrames
=
=
(
uint32_t
)
mInputTail
[
i
]
.
Length
(
)
)
;
}
else
{
float
outBuffer
[
100
]
=
{
}
;
ResampleInternal
(
mInputTail
[
i
]
.
Buffer
<
float
>
(
)
&
inFrames
outBuffer
&
outFrames
i
)
;
MOZ_ASSERT
(
inFrames
=
=
(
uint32_t
)
mInputTail
[
i
]
.
Length
(
)
)
;
}
}
if
(
aSkipLatency
)
{
speex_resampler_skip_zeros
(
mResampler
)
;
}
mIsWarmingUp
=
false
;
}
void
DynamicResampler
:
:
AppendInput
(
Span
<
const
float
*
const
>
aInBuffer
uint32_t
aInFrames
)
{
MOZ_ASSERT
(
mSampleFormat
=
=
AUDIO_FORMAT_FLOAT32
)
;
AppendInputInternal
(
aInBuffer
aInFrames
)
;
}
void
DynamicResampler
:
:
AppendInput
(
Span
<
const
int16_t
*
const
>
aInBuffer
uint32_t
aInFrames
)
{
MOZ_ASSERT
(
mSampleFormat
=
=
AUDIO_FORMAT_S16
)
;
AppendInputInternal
(
aInBuffer
aInFrames
)
;
}
void
DynamicResampler
:
:
AppendInputSilence
(
const
uint32_t
aInFrames
)
{
MOZ_ASSERT
(
aInFrames
)
;
MOZ_ASSERT
(
mChannels
)
;
MOZ_ASSERT
(
mInternalInBuffer
.
Length
(
)
>
=
(
uint32_t
)
mChannels
)
;
for
(
uint32_t
i
=
0
;
i
<
mChannels
;
+
+
i
)
{
mInternalInBuffer
[
i
]
.
WriteSilence
(
aInFrames
)
;
}
}
uint32_t
DynamicResampler
:
:
InFramesBufferSize
(
)
const
{
if
(
mSampleFormat
=
=
AUDIO_FORMAT_SILENCE
)
{
return
0
;
}
MOZ_ASSERT
(
!
mInternalInBuffer
.
IsEmpty
(
)
)
;
uint32_t
min
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
for
(
const
auto
&
b
:
mInternalInBuffer
)
{
min
=
std
:
:
min
(
min
b
.
Capacity
(
)
)
;
}
return
min
;
}
uint32_t
DynamicResampler
:
:
InFramesBuffered
(
uint32_t
aChannelIndex
)
const
{
MOZ_ASSERT
(
mChannels
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mChannels
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mInternalInBuffer
.
Length
(
)
)
;
if
(
!
mIsPreBufferSet
)
{
return
mInputPreBufferFrameCount
;
}
return
mInternalInBuffer
[
aChannelIndex
]
.
AvailableRead
(
)
;
}
}
