#
include
"
AudioDriftCorrection
.
h
"
#
include
"
AudioGenerator
.
h
"
#
include
"
AudioVerifier
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
nsContentUtils
.
h
"
using
namespace
mozilla
;
template
<
class
T
>
AudioChunk
CreateAudioChunk
(
uint32_t
aFrames
uint32_t
aChannels
AudioSampleFormat
aSampleFormat
)
;
void
testAudioCorrection
(
int32_t
aSourceRate
int32_t
aTargetRate
bool
aTestMonoToStereoInput
=
false
)
{
const
uint32_t
frequency
=
100
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
aSourceRate
aTargetRate
testPrincipal
)
;
uint8_t
numChannels
=
1
;
AudioGenerator
<
AudioDataValue
>
tone
(
numChannels
aSourceRate
frequency
)
;
AudioVerifier
<
AudioDataValue
>
inToneVerifier
(
aSourceRate
frequency
)
;
AudioVerifier
<
AudioDataValue
>
outToneVerifier
(
aTargetRate
frequency
)
;
for
(
uint32_t
j
=
0
;
j
<
3
;
+
+
j
)
{
TrackTime
sourceFramesIteration
=
0
;
TrackTime
targetFramesIteration
=
0
;
const
int8_t
additionalDriftFrames
=
(
(
j
%
2
=
=
0
)
?
aSourceRate
:
-
aSourceRate
)
*
2
/
1000
;
const
uint32_t
numFramesBeforeChangingChannelCount
=
aSourceRate
;
uint32_t
numFramesAtCurrentChannelCount
=
0
;
for
(
uint32_t
n
=
0
;
n
<
5000
;
+
+
n
)
{
const
TrackTime
sourceFrames
=
(
n
+
1
)
*
(
aSourceRate
+
additionalDriftFrames
)
/
100
-
sourceFramesIteration
;
const
TrackTime
targetFrames
=
(
n
+
1
)
*
aTargetRate
/
100
-
targetFramesIteration
;
AudioSegment
inSegment
;
if
(
aTestMonoToStereoInput
)
{
const
TrackTime
sourceFramesPart1
=
std
:
:
min
<
TrackTime
>
(
sourceFrames
numFramesBeforeChangingChannelCount
-
numFramesAtCurrentChannelCount
)
;
tone
.
Generate
(
inSegment
sourceFramesPart1
)
;
numFramesAtCurrentChannelCount
+
=
sourceFramesPart1
;
if
(
numFramesBeforeChangingChannelCount
=
=
numFramesAtCurrentChannelCount
)
{
tone
.
SetChannelsCount
(
numChannels
=
(
numChannels
%
2
)
+
1
)
;
numFramesAtCurrentChannelCount
=
sourceFrames
-
sourceFramesPart1
;
tone
.
Generate
(
inSegment
numFramesAtCurrentChannelCount
)
;
}
}
else
{
tone
.
Generate
(
inSegment
sourceFrames
)
;
}
inToneVerifier
.
AppendData
(
inSegment
)
;
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
targetFrames
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
targetFrames
)
;
for
(
AudioSegment
:
:
ConstChunkIterator
ci
(
outSegment
)
;
!
ci
.
IsEnded
(
)
;
ci
.
Next
(
)
)
{
EXPECT_EQ
(
ci
-
>
mPrincipalHandle
testPrincipal
)
;
}
outToneVerifier
.
AppendData
(
outSegment
)
;
sourceFramesIteration
+
=
sourceFrames
;
targetFramesIteration
+
=
targetFrames
;
}
}
EXPECT_LT
(
ad
.
CurrentBuffering
(
)
aSourceRate
*
50U
/
1000
)
;
EXPECT_GT
(
ad
.
CurrentBuffering
(
)
aSourceRate
*
10U
/
1000
)
;
EXPECT_EQ
(
ad
.
NumUnderruns
(
)
0U
)
;
EXPECT_FLOAT_EQ
(
inToneVerifier
.
EstimatedFreq
(
)
tone
.
mFrequency
)
;
EXPECT_EQ
(
inToneVerifier
.
PreSilenceSamples
(
)
0U
)
;
EXPECT_EQ
(
inToneVerifier
.
CountDiscontinuities
(
)
0U
)
;
EXPECT_NEAR
(
outToneVerifier
.
EstimatedFreq
(
)
tone
.
mFrequency
1
.
0f
)
;
const
auto
buffering
=
media
:
:
TimeUnit
:
:
FromSeconds
(
0
.
05
)
;
const
auto
sourceStep
=
media
:
:
TimeUnit
(
aSourceRate
*
1002
/
1000
/
100
aSourceRate
)
;
const
auto
targetStep
=
media
:
:
TimeUnit
(
aTargetRate
/
100
aTargetRate
)
;
EXPECT_NEAR
(
static_cast
<
int64_t
>
(
outToneVerifier
.
PreSilenceSamples
(
)
)
(
targetStep
+
buffering
-
sourceStep
)
.
ToBase
(
aSourceRate
)
.
ToBase
<
media
:
:
TimeUnit
:
:
CeilingPolicy
>
(
aTargetRate
)
.
ToTicksAtRate
(
aTargetRate
)
1U
)
;
EXPECT_EQ
(
outToneVerifier
.
CountDiscontinuities
(
)
0U
)
;
}
TEST
(
TestAudioDriftCorrection
Basic
)
{
printf
(
"
Testing
AudioCorrection
48
-
>
48
\
n
"
)
;
testAudioCorrection
(
48000
48000
)
;
printf
(
"
Testing
AudioCorrection
48
-
>
44
.
1
\
n
"
)
;
testAudioCorrection
(
48000
44100
)
;
printf
(
"
Testing
AudioCorrection
44
.
1
-
>
48
\
n
"
)
;
testAudioCorrection
(
44100
48000
)
;
printf
(
"
Testing
AudioCorrection
23458
-
>
25113
\
n
"
)
;
testAudioCorrection
(
23458
25113
)
;
}
TEST
(
TestAudioDriftCorrection
MonoToStereoInput
)
{
constexpr
bool
testMonoToStereoInput
=
true
;
printf
(
"
Testing
MonoToStereoInput
48
-
>
48
\
n
"
)
;
testAudioCorrection
(
48000
48000
testMonoToStereoInput
)
;
printf
(
"
Testing
MonoToStereoInput
48
-
>
44
.
1
\
n
"
)
;
testAudioCorrection
(
48000
44100
testMonoToStereoInput
)
;
printf
(
"
Testing
MonoToStereoInput
44
.
1
-
>
48
\
n
"
)
;
testAudioCorrection
(
44100
48000
testMonoToStereoInput
)
;
}
TEST
(
TestAudioDriftCorrection
NotEnoughFrames
)
{
const
uint32_t
frequency
=
100
;
const
uint32_t
sampleRateTransmitter
=
48000
;
const
uint32_t
sampleRateReceiver
=
48000
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
sampleRateTransmitter
sampleRateReceiver
testPrincipal
)
;
const
uint32_t
targetFrames
=
sampleRateReceiver
/
100
;
AudioGenerator
<
AudioDataValue
>
tone
(
1
sampleRateTransmitter
frequency
)
;
AudioVerifier
<
AudioDataValue
>
outToneVerifier
(
sampleRateReceiver
frequency
)
;
for
(
uint32_t
i
=
0
;
i
<
7
;
+
+
i
)
{
AudioSegment
inSegment
;
tone
.
Generate
(
inSegment
10
)
;
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
targetFrames
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
targetFrames
)
;
EXPECT_FALSE
(
outSegment
.
IsNull
(
)
)
;
for
(
AudioSegment
:
:
ConstChunkIterator
ci
(
outSegment
)
;
!
ci
.
IsEnded
(
)
;
ci
.
Next
(
)
)
{
if
(
i
<
5
)
{
if
(
!
ci
-
>
IsNull
(
)
)
{
EXPECT_EQ
(
ci
-
>
mPrincipalHandle
testPrincipal
)
;
}
}
}
outToneVerifier
.
AppendData
(
outSegment
)
;
}
EXPECT_EQ
(
ad
.
BufferSize
(
)
4800U
)
;
EXPECT_EQ
(
ad
.
NumUnderruns
(
)
1u
)
;
EXPECT_EQ
(
outToneVerifier
.
CountDiscontinuities
(
)
1u
)
;
}
TEST
(
TestAudioDriftCorrection
CrashInAudioResampler
)
{
const
uint32_t
sampleRateTransmitter
=
48000
;
const
uint32_t
sampleRateReceiver
=
48000
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
sampleRateTransmitter
sampleRateReceiver
testPrincipal
)
;
const
uint32_t
targetFrames
=
sampleRateReceiver
/
100
;
for
(
uint32_t
i
=
0
;
i
<
100
;
+
+
i
)
{
AudioChunk
chunk
=
CreateAudioChunk
<
float
>
(
sampleRateTransmitter
/
1000
1
AUDIO_FORMAT_FLOAT32
)
;
AudioSegment
inSegment
;
inSegment
.
AppendAndConsumeChunk
(
std
:
:
move
(
chunk
)
)
;
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
targetFrames
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
targetFrames
)
;
for
(
AudioSegment
:
:
ConstChunkIterator
ci
(
outSegment
)
;
!
ci
.
IsEnded
(
)
;
ci
.
Next
(
)
)
{
if
(
!
ci
-
>
IsNull
(
)
)
{
EXPECT_EQ
(
ci
-
>
mPrincipalHandle
testPrincipal
)
;
}
}
}
}
TEST
(
TestAudioDriftCorrection
HighLatencyProducerLowLatencyConsumer
)
{
constexpr
uint32_t
transmitterBlockSize
=
2048
;
constexpr
uint32_t
receiverBlockSize
=
128
;
constexpr
uint32_t
sampleRate
=
48000
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
sampleRate
sampleRate
testPrincipal
)
;
uint32_t
numBlocksProduced
=
0
;
for
(
uint32_t
i
=
0
;
i
<
(
sampleRate
/
1000
)
*
500
;
i
+
=
receiverBlockSize
)
{
AudioSegment
inSegment
;
if
(
(
i
/
transmitterBlockSize
)
>
numBlocksProduced
)
{
AudioChunk
chunk
=
CreateAudioChunk
<
float
>
(
transmitterBlockSize
1
AUDIO_FORMAT_FLOAT32
)
;
inSegment
.
AppendAndConsumeChunk
(
std
:
:
move
(
chunk
)
)
;
+
+
numBlocksProduced
;
}
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
receiverBlockSize
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
receiverBlockSize
)
;
}
EXPECT_EQ
(
ad
.
NumCorrectionChanges
(
)
0U
)
;
}
TEST
(
TestAudioDriftCorrection
LargerTransmitterBlockSizeThanDesiredBuffering
)
{
constexpr
uint32_t
transmitterBlockSize
=
4096
;
constexpr
uint32_t
receiverBlockSize
=
128
;
constexpr
uint32_t
sampleRate
=
48000
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
sampleRate
sampleRate
testPrincipal
)
;
uint32_t
numBlocksTransmitted
=
0
;
for
(
uint32_t
i
=
0
;
i
<
(
sampleRate
/
1000
)
*
500
;
i
+
=
receiverBlockSize
)
{
AudioSegment
inSegment
;
if
(
uint32_t
currentBlock
=
i
/
transmitterBlockSize
;
currentBlock
>
numBlocksTransmitted
)
{
AudioChunk
chunk
=
CreateAudioChunk
<
float
>
(
transmitterBlockSize
1
AUDIO_FORMAT_FLOAT32
)
;
inSegment
.
AppendAndConsumeChunk
(
std
:
:
move
(
chunk
)
)
;
numBlocksTransmitted
=
currentBlock
;
}
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
receiverBlockSize
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
receiverBlockSize
)
;
if
(
numBlocksTransmitted
>
0
)
{
EXPECT_GT
(
ad
.
CurrentBuffering
(
)
0U
)
;
}
}
EXPECT_EQ
(
ad
.
NumCorrectionChanges
(
)
0U
)
;
EXPECT_EQ
(
ad
.
BufferSize
(
)
transmitterBlockSize
*
11
/
10
*
2
)
;
}
TEST
(
TestAudioDriftCorrection
LargerReceiverBlockSizeThanDesiredBuffering
)
{
constexpr
uint32_t
transmitterBlockSize
=
128
;
constexpr
uint32_t
receiverBlockSize
=
4096
;
constexpr
uint32_t
sampleRate
=
48000
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
sampleRate
sampleRate
testPrincipal
)
;
AudioSegment
inSegment
;
for
(
uint32_t
i
=
0
;
i
<
(
sampleRate
/
1000
)
*
500
;
i
+
=
transmitterBlockSize
)
{
AudioChunk
chunk
=
CreateAudioChunk
<
float
>
(
transmitterBlockSize
1
AUDIO_FORMAT_FLOAT32
)
;
inSegment
.
AppendAndConsumeChunk
(
std
:
:
move
(
chunk
)
)
;
if
(
i
%
receiverBlockSize
=
=
0
)
{
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
receiverBlockSize
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
receiverBlockSize
)
;
inSegment
.
Clear
(
)
;
}
if
(
i
>
=
receiverBlockSize
)
{
EXPECT_GT
(
ad
.
CurrentBuffering
(
)
0U
)
;
}
}
EXPECT_EQ
(
ad
.
NumCorrectionChanges
(
)
0U
)
;
EXPECT_EQ
(
ad
.
NumUnderruns
(
)
0U
)
;
EXPECT_EQ
(
ad
.
BufferSize
(
)
9600U
)
;
}
TEST
(
TestAudioDriftCorrection
DynamicInputBufferSizeChanges
)
{
constexpr
uint32_t
transmitterBlockSize1
=
2048
;
constexpr
uint32_t
transmitterBlockSize2
=
4096
;
constexpr
uint32_t
receiverBlockSize
=
128
;
constexpr
uint32_t
sampleRate
=
48000
;
constexpr
uint32_t
frequencyHz
=
100
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
sampleRate
sampleRate
testPrincipal
)
;
AudioGenerator
<
AudioDataValue
>
tone
(
1
sampleRate
frequencyHz
)
;
AudioVerifier
<
AudioDataValue
>
inToneVerifier
(
sampleRate
frequencyHz
)
;
AudioVerifier
<
AudioDataValue
>
outToneVerifier
(
sampleRate
frequencyHz
)
;
TrackTime
totalFramesTransmitted
=
0
;
TrackTime
totalFramesReceived
=
0
;
const
auto
produceSomeData
=
[
&
]
(
uint32_t
aTransmitterBlockSize
uint32_t
aDuration
)
{
TrackTime
transmittedFramesStart
=
totalFramesTransmitted
;
TrackTime
receivedFramesStart
=
totalFramesReceived
;
uint32_t
numBlocksTransmitted
=
0
;
for
(
uint32_t
i
=
0
;
i
<
aDuration
;
i
+
=
receiverBlockSize
)
{
AudioSegment
inSegment
;
if
(
(
(
receivedFramesStart
-
transmittedFramesStart
+
i
)
/
aTransmitterBlockSize
)
>
numBlocksTransmitted
)
{
tone
.
Generate
(
inSegment
aTransmitterBlockSize
)
;
MOZ_RELEASE_ASSERT
(
!
inSegment
.
IsNull
(
)
)
;
inToneVerifier
.
AppendData
(
inSegment
)
;
MOZ_RELEASE_ASSERT
(
!
inSegment
.
IsNull
(
)
)
;
+
+
numBlocksTransmitted
;
totalFramesTransmitted
+
=
aTransmitterBlockSize
;
}
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
receiverBlockSize
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
receiverBlockSize
)
;
outToneVerifier
.
AppendData
(
outSegment
)
;
totalFramesReceived
+
=
receiverBlockSize
;
}
}
;
produceSomeData
(
transmitterBlockSize1
5
*
sampleRate
)
;
EXPECT_EQ
(
ad
.
BufferSize
(
)
4800U
)
;
EXPECT_GT
(
ad
.
NumCorrectionChanges
(
)
0U
)
;
EXPECT_EQ
(
ad
.
NumUnderruns
(
)
0U
)
;
produceSomeData
(
transmitterBlockSize2
25
*
sampleRate
)
;
auto
numCorrectionChanges
=
ad
.
NumCorrectionChanges
(
)
;
EXPECT_EQ
(
ad
.
NumUnderruns
(
)
1U
)
;
EXPECT_GT
(
ad
.
BufferSize
(
)
transmitterBlockSize2
)
;
produceSomeData
(
transmitterBlockSize2
10
*
sampleRate
)
;
EXPECT_LE
(
ad
.
NumCorrectionChanges
(
)
numCorrectionChanges
+
1
)
;
EXPECT_EQ
(
ad
.
NumUnderruns
(
)
1U
)
;
produceSomeData
(
transmitterBlockSize1
100
*
sampleRate
)
;
numCorrectionChanges
=
ad
.
NumCorrectionChanges
(
)
;
EXPECT_EQ
(
ad
.
NumUnderruns
(
)
1U
)
;
EXPECT_EQ
(
ad
.
BufferSize
(
)
9600U
)
;
produceSomeData
(
transmitterBlockSize1
20
*
sampleRate
)
;
EXPECT_LE
(
ad
.
NumCorrectionChanges
(
)
numCorrectionChanges
+
2
)
;
EXPECT_EQ
(
ad
.
NumUnderruns
(
)
1U
)
;
EXPECT_NEAR
(
inToneVerifier
.
EstimatedFreq
(
)
tone
.
mFrequency
1
.
0f
)
;
EXPECT_EQ
(
inToneVerifier
.
PreSilenceSamples
(
)
0U
)
;
EXPECT_EQ
(
inToneVerifier
.
CountDiscontinuities
(
)
0U
)
;
EXPECT_NEAR
(
outToneVerifier
.
EstimatedFreq
(
)
tone
.
mFrequency
1
.
0f
)
;
EXPECT_EQ
(
outToneVerifier
.
PreSilenceSamples
(
)
2528U
)
;
EXPECT_NEAR
(
outToneVerifier
.
PreSilenceSamples
(
)
-
transmitterBlockSize1
media
:
:
TimeUnit
:
:
FromSeconds
(
0
.
05
)
.
ToTicksAtRate
(
sampleRate
)
+
receiverBlockSize
-
transmitterBlockSize1
1U
)
;
EXPECT_EQ
(
outToneVerifier
.
CountDiscontinuities
(
)
2U
)
;
}
TEST
(
TestAudioDriftCorrection
DriftStepResponse
)
{
constexpr
uint32_t
nominalRate
=
48000
;
constexpr
uint32_t
interval
=
nominalRate
;
constexpr
uint32_t
inputRate
=
nominalRate
*
1005
/
1000
;
constexpr
uint32_t
inputInterval
=
inputRate
;
constexpr
uint32_t
iterations
=
200
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioGenerator
<
AudioDataValue
>
tone
(
1
nominalRate
440
)
;
AudioDriftCorrection
ad
(
nominalRate
nominalRate
testPrincipal
)
;
for
(
uint32_t
i
=
0
;
i
<
interval
*
iterations
;
i
+
=
interval
/
100
)
{
AudioSegment
inSegment
;
tone
.
Generate
(
inSegment
inputInterval
/
100
)
;
ad
.
RequestFrames
(
inSegment
interval
/
100
)
;
}
EXPECT_EQ
(
ad
.
BufferSize
(
)
4800U
)
;
EXPECT_EQ
(
ad
.
NumUnderruns
(
)
0u
)
;
}
TEST
(
TestAudioDriftCorrection
DriftStepResponseUnderrun
)
{
constexpr
uint32_t
nominalRate
=
48000
;
constexpr
uint32_t
interval
=
nominalRate
;
constexpr
uint32_t
iterations
=
200
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
uint32_t
inputRate
=
nominalRate
*
1005
/
1000
;
uint32_t
inputInterval
=
inputRate
;
AudioGenerator
<
AudioDataValue
>
tone
(
1
nominalRate
440
)
;
AudioDriftCorrection
ad
(
nominalRate
nominalRate
testPrincipal
)
;
for
(
uint32_t
i
=
0
;
i
<
interval
*
iterations
;
i
+
=
interval
/
100
)
{
AudioSegment
inSegment
;
tone
.
Generate
(
inSegment
inputInterval
/
100
)
;
ad
.
RequestFrames
(
inSegment
interval
/
100
)
;
}
inputRate
=
nominalRate
*
997
/
1000
;
inputInterval
=
inputRate
;
for
(
uint32_t
i
=
0
;
i
<
interval
*
iterations
;
i
+
=
interval
/
100
)
{
AudioSegment
inSegment
;
tone
.
Generate
(
inSegment
inputInterval
/
100
)
;
ad
.
RequestFrames
(
inSegment
interval
/
100
)
;
}
EXPECT_EQ
(
ad
.
BufferSize
(
)
4800U
)
;
EXPECT_EQ
(
ad
.
NumUnderruns
(
)
1u
)
;
}
TEST
(
TestAudioDriftCorrection
DriftStepResponseUnderrunHighLatencyInput
)
{
constexpr
uint32_t
nominalRate
=
48000
;
constexpr
uint32_t
interval
=
nominalRate
;
constexpr
uint32_t
iterations
=
200
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
uint32_t
inputRate1
=
nominalRate
*
1005
/
1000
;
uint32_t
inputInterval1
=
inputRate1
;
AudioGenerator
<
AudioDataValue
>
tone
(
1
nominalRate
440
)
;
AudioDriftCorrection
ad
(
nominalRate
nominalRate
testPrincipal
)
;
for
(
uint32_t
i
=
0
;
i
<
interval
*
iterations
;
i
+
=
interval
/
100
)
{
AudioSegment
inSegment
;
if
(
i
>
0
&
&
i
%
interval
=
=
0
)
{
tone
.
Generate
(
inSegment
inputInterval1
)
;
}
ad
.
RequestFrames
(
inSegment
interval
/
100
)
;
}
uint32_t
inputRate2
=
nominalRate
*
995
/
1000
;
uint32_t
inputInterval2
=
inputRate2
;
for
(
uint32_t
i
=
0
;
i
<
interval
*
iterations
;
i
+
=
interval
/
100
)
{
AudioSegment
inSegment
;
if
(
i
>
0
&
&
i
%
interval
=
=
0
)
{
tone
.
Generate
(
inSegment
inputInterval2
)
;
}
ad
.
RequestFrames
(
inSegment
interval
/
100
)
;
if
(
i
>
=
interval
*
8
/
10
&
&
i
<
interval
)
{
EXPECT_EQ
(
ad
.
CurrentBuffering
(
)
inputInterval1
*
11
/
10
*
2
)
<
<
"
for
i
=
"
<
<
i
;
}
else
if
(
i
=
=
interval
)
{
EXPECT_NEAR
(
ad
.
CurrentBuffering
(
)
inputInterval1
*
11
/
10
*
2
1
)
<
<
"
after
first
input
after
underrun
"
;
}
}
EXPECT_EQ
(
ad
.
BufferSize
(
)
inputInterval1
*
11
/
10
*
2
*
2
)
;
EXPECT_EQ
(
ad
.
NumUnderruns
(
)
1u
)
;
}
TEST
(
TestAudioDriftCorrection
DriftStepResponseOverrun
)
{
constexpr
uint32_t
nominalRate
=
48000
;
constexpr
uint32_t
interval
=
nominalRate
;
constexpr
uint32_t
inputRate
=
nominalRate
*
1005
/
1000
;
constexpr
uint32_t
inputInterval
=
inputRate
;
constexpr
uint32_t
iterations
=
200
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioGenerator
<
AudioDataValue
>
tone
(
1
nominalRate
440
)
;
AudioDriftCorrection
ad
(
nominalRate
nominalRate
testPrincipal
)
;
for
(
uint32_t
i
=
0
;
i
<
interval
*
iterations
;
i
+
=
interval
/
100
)
{
AudioSegment
inSegment
;
tone
.
Generate
(
inSegment
inputInterval
/
100
)
;
ad
.
RequestFrames
(
inSegment
interval
/
100
)
;
}
for
(
uint32_t
i
=
0
;
i
<
interval
*
iterations
;
i
+
=
interval
/
100
)
{
AudioSegment
inSegment
;
if
(
i
>
0
&
&
i
%
interval
=
=
0
)
{
tone
.
Generate
(
inSegment
inputInterval
)
;
}
ad
.
RequestFrames
(
inSegment
interval
/
100
)
;
}
EXPECT_EQ
(
ad
.
BufferSize
(
)
inputInterval
*
11
/
10
*
2
)
;
EXPECT_EQ
(
ad
.
NumUnderruns
(
)
1u
)
;
}
