#
include
"
gtest
/
gtest
.
h
"
#
include
"
AudioDriftCorrection
.
h
"
#
include
"
AudioGenerator
.
h
"
#
include
"
AudioVerifier
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
nsContentUtils
.
h
"
using
namespace
mozilla
;
void
printAudioSegment
(
const
AudioSegment
&
segment
)
{
for
(
AudioSegment
:
:
ConstChunkIterator
iter
(
segment
)
;
!
iter
.
IsEnded
(
)
;
iter
.
Next
(
)
)
{
const
AudioChunk
&
c
=
*
iter
;
for
(
uint32_t
i
=
0
;
i
<
c
.
GetDuration
(
)
;
+
+
i
)
{
if
(
c
.
mBufferFormat
=
=
AUDIO_FORMAT_FLOAT32
)
{
printf
(
"
%
f
\
n
"
c
.
ChannelData
<
float
>
(
)
[
0
]
[
i
]
)
;
}
else
{
printf
(
"
%
d
\
n
"
c
.
ChannelData
<
int16_t
>
(
)
[
0
]
[
i
]
)
;
}
}
}
}
template
<
class
T
>
AudioChunk
CreateAudioChunk
(
uint32_t
aFrames
uint32_t
aChannels
AudioSampleFormat
aSampleFormat
)
;
void
testAudioCorrection
(
int32_t
aSourceRate
int32_t
aTargetRate
)
{
const
uint32_t
sampleRateTransmitter
=
aSourceRate
;
const
uint32_t
sampleRateReceiver
=
aTargetRate
;
const
uint32_t
frequency
=
100
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
sampleRateTransmitter
sampleRateReceiver
testPrincipal
)
;
AudioGenerator
<
AudioDataValue
>
tone
(
1
sampleRateTransmitter
frequency
)
;
AudioVerifier
<
AudioDataValue
>
inToneVerifier
(
sampleRateTransmitter
frequency
)
;
AudioVerifier
<
AudioDataValue
>
outToneVerifier
(
sampleRateReceiver
frequency
)
;
uint32_t
sourceFrames
;
const
uint32_t
targetFrames
=
sampleRateReceiver
/
100
;
for
(
uint32_t
j
=
0
;
j
<
3
;
+
+
j
)
{
if
(
j
%
2
=
=
0
)
{
sourceFrames
=
sampleRateTransmitter
*
1002
/
1000
/
100
;
}
else
{
sourceFrames
=
sampleRateTransmitter
*
998
/
1000
/
100
;
}
for
(
uint32_t
n
=
0
;
n
<
5000
;
+
+
n
)
{
AudioSegment
inSegment
;
tone
.
Generate
(
inSegment
sourceFrames
)
;
inToneVerifier
.
AppendData
(
inSegment
)
;
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
targetFrames
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
targetFrames
)
;
for
(
AudioSegment
:
:
ConstChunkIterator
ci
(
outSegment
)
;
!
ci
.
IsEnded
(
)
;
ci
.
Next
(
)
)
{
EXPECT_EQ
(
ci
-
>
mPrincipalHandle
testPrincipal
)
;
}
outToneVerifier
.
AppendData
(
outSegment
)
;
}
}
const
int32_t
expectedBuffering
=
StaticPrefs
:
:
media_clockdrift_buffering
(
)
*
aSourceRate
/
1000
-
sampleRateTransmitter
/
100
;
EXPECT_NEAR
(
ad
.
CurrentBuffering
(
)
expectedBuffering
512
)
;
EXPECT_NEAR
(
inToneVerifier
.
EstimatedFreq
(
)
tone
.
mFrequency
1
.
0f
)
;
EXPECT_EQ
(
inToneVerifier
.
PreSilenceSamples
(
)
0U
)
;
EXPECT_EQ
(
inToneVerifier
.
CountDiscontinuities
(
)
0U
)
;
EXPECT_NEAR
(
outToneVerifier
.
EstimatedFreq
(
)
tone
.
mFrequency
1
.
0f
)
;
EXPECT_GE
(
outToneVerifier
.
PreSilenceSamples
(
)
aTargetRate
*
50
/
1000U
-
aTargetRate
*
102
/
100
/
100
)
;
EXPECT_EQ
(
outToneVerifier
.
CountDiscontinuities
(
)
0U
)
;
}
TEST
(
TestAudioDriftCorrection
Basic
)
{
printf
(
"
Testing
AudioCorrection
48
-
>
48
\
n
"
)
;
testAudioCorrection
(
48000
48000
)
;
printf
(
"
Testing
AudioCorrection
48
-
>
44
.
1
\
n
"
)
;
testAudioCorrection
(
48000
44100
)
;
printf
(
"
Testing
AudioCorrection
44
.
1
-
>
48
\
n
"
)
;
testAudioCorrection
(
44100
48000
)
;
printf
(
"
Testing
AudioCorrection
23458
-
>
25113
\
n
"
)
;
testAudioCorrection
(
23458
25113
)
;
}
void
testMonoToStereoInput
(
uint32_t
aSourceRate
uint32_t
aTargetRate
)
{
const
uint32_t
frequency
=
100
;
const
uint32_t
sampleRateTransmitter
=
aSourceRate
;
const
uint32_t
sampleRateReceiver
=
aTargetRate
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
sampleRateTransmitter
sampleRateReceiver
testPrincipal
)
;
AudioGenerator
<
AudioDataValue
>
tone
(
1
sampleRateTransmitter
frequency
)
;
AudioVerifier
<
AudioDataValue
>
inToneVerify
(
sampleRateTransmitter
frequency
)
;
AudioVerifier
<
AudioDataValue
>
outToneVerify
(
sampleRateReceiver
frequency
)
;
uint32_t
sourceFrames
;
const
uint32_t
targetFrames
=
sampleRateReceiver
/
100
;
for
(
uint32_t
j
=
0
;
j
<
6
;
+
+
j
)
{
if
(
j
%
2
=
=
0
)
{
sourceFrames
=
sampleRateTransmitter
/
100
+
10
;
}
else
{
sourceFrames
=
sampleRateTransmitter
/
100
-
10
;
}
for
(
uint32_t
n
=
0
;
n
<
250
;
+
+
n
)
{
AudioSegment
inSegment
;
tone
.
Generate
(
inSegment
sourceFrames
/
2
)
;
tone
.
SetChannelsCount
(
2
)
;
tone
.
Generate
(
inSegment
sourceFrames
/
2
)
;
tone
.
SetChannelsCount
(
1
)
;
inToneVerify
.
AppendData
(
inSegment
)
;
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
targetFrames
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
targetFrames
)
;
for
(
AudioSegment
:
:
ConstChunkIterator
ci
(
outSegment
)
;
!
ci
.
IsEnded
(
)
;
ci
.
Next
(
)
)
{
EXPECT_EQ
(
ci
-
>
mPrincipalHandle
testPrincipal
)
;
}
outToneVerify
.
AppendData
(
outSegment
)
;
}
}
EXPECT_EQ
(
inToneVerify
.
EstimatedFreq
(
)
frequency
)
;
EXPECT_EQ
(
inToneVerify
.
PreSilenceSamples
(
)
0U
)
;
EXPECT_EQ
(
inToneVerify
.
CountDiscontinuities
(
)
0U
)
;
EXPECT_GT
(
outToneVerify
.
CountDiscontinuities
(
)
0U
)
<
<
"
Expect
discontinuities
"
;
EXPECT_NE
(
outToneVerify
.
EstimatedFreq
(
)
frequency
)
<
<
"
Estimation
is
not
accurate
due
to
discontinuities
"
;
EXPECT_GT
(
outToneVerify
.
PreSilenceSamples
(
)
400U
)
;
}
TEST
(
TestAudioDriftCorrection
MonoToStereoInput
)
{
testMonoToStereoInput
(
48000
48000
)
;
testMonoToStereoInput
(
48000
44100
)
;
testMonoToStereoInput
(
44100
48000
)
;
}
TEST
(
TestAudioDriftCorrection
NotEnoughFrames
)
{
const
uint32_t
frequency
=
100
;
const
uint32_t
sampleRateTransmitter
=
48000
;
const
uint32_t
sampleRateReceiver
=
48000
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
sampleRateTransmitter
sampleRateReceiver
testPrincipal
)
;
const
uint32_t
targetFrames
=
sampleRateReceiver
/
100
;
AudioGenerator
<
AudioDataValue
>
tone
(
1
sampleRateTransmitter
frequency
)
;
AudioVerifier
<
AudioDataValue
>
outToneVerifier
(
sampleRateReceiver
frequency
)
;
for
(
uint32_t
i
=
0
;
i
<
7
;
+
+
i
)
{
AudioSegment
inSegment
;
tone
.
Generate
(
inSegment
10
)
;
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
targetFrames
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
targetFrames
)
;
EXPECT_FALSE
(
outSegment
.
IsNull
(
)
)
;
for
(
AudioSegment
:
:
ConstChunkIterator
ci
(
outSegment
)
;
!
ci
.
IsEnded
(
)
;
ci
.
Next
(
)
)
{
if
(
i
<
5
)
{
if
(
!
ci
-
>
IsNull
(
)
)
{
EXPECT_EQ
(
ci
-
>
mPrincipalHandle
testPrincipal
)
;
}
}
}
outToneVerifier
.
AppendData
(
outSegment
)
;
}
EXPECT_EQ
(
ad
.
BufferSize
(
)
4800U
)
;
EXPECT_EQ
(
outToneVerifier
.
CountDiscontinuities
(
)
1u
)
;
}
TEST
(
TestAudioDriftCorrection
CrashInAudioResampler
)
{
const
uint32_t
sampleRateTransmitter
=
48000
;
const
uint32_t
sampleRateReceiver
=
48000
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
sampleRateTransmitter
sampleRateReceiver
testPrincipal
)
;
const
uint32_t
targetFrames
=
sampleRateReceiver
/
100
;
for
(
uint32_t
i
=
0
;
i
<
100
;
+
+
i
)
{
AudioChunk
chunk
=
CreateAudioChunk
<
float
>
(
sampleRateTransmitter
/
1000
1
AUDIO_FORMAT_FLOAT32
)
;
AudioSegment
inSegment
;
inSegment
.
AppendAndConsumeChunk
(
std
:
:
move
(
chunk
)
)
;
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
targetFrames
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
targetFrames
)
;
for
(
AudioSegment
:
:
ConstChunkIterator
ci
(
outSegment
)
;
!
ci
.
IsEnded
(
)
;
ci
.
Next
(
)
)
{
if
(
!
ci
-
>
IsNull
(
)
)
{
EXPECT_EQ
(
ci
-
>
mPrincipalHandle
testPrincipal
)
;
}
}
}
}
TEST
(
TestAudioDriftCorrection
HighLatencyProducerLowLatencyConsumer
)
{
constexpr
uint32_t
transmitterBlockSize
=
2048
;
constexpr
uint32_t
receiverBlockSize
=
128
;
constexpr
uint32_t
sampleRate
=
48000
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
sampleRate
sampleRate
testPrincipal
)
;
uint32_t
numBlocksProduced
=
0
;
for
(
uint32_t
i
=
0
;
i
<
(
sampleRate
/
1000
)
*
500
;
i
+
=
receiverBlockSize
)
{
AudioSegment
inSegment
;
if
(
(
i
/
transmitterBlockSize
)
>
numBlocksProduced
)
{
AudioChunk
chunk
=
CreateAudioChunk
<
float
>
(
transmitterBlockSize
1
AUDIO_FORMAT_FLOAT32
)
;
inSegment
.
AppendAndConsumeChunk
(
std
:
:
move
(
chunk
)
)
;
+
+
numBlocksProduced
;
}
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
receiverBlockSize
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
receiverBlockSize
)
;
}
EXPECT_EQ
(
ad
.
NumCorrectionChanges
(
)
0U
)
;
}
TEST
(
TestAudioDriftCorrection
LargerTransmitterBlockSizeThanDesiredBuffering
)
{
constexpr
uint32_t
transmitterBlockSize
=
4096
;
constexpr
uint32_t
receiverBlockSize
=
128
;
constexpr
uint32_t
sampleRate
=
48000
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
sampleRate
sampleRate
testPrincipal
)
;
uint32_t
numBlocksTransmitted
=
0
;
for
(
uint32_t
i
=
0
;
i
<
(
sampleRate
/
1000
)
*
500
;
i
+
=
receiverBlockSize
)
{
AudioSegment
inSegment
;
if
(
uint32_t
currentBlock
=
i
/
transmitterBlockSize
;
currentBlock
>
numBlocksTransmitted
)
{
AudioChunk
chunk
=
CreateAudioChunk
<
float
>
(
transmitterBlockSize
1
AUDIO_FORMAT_FLOAT32
)
;
inSegment
.
AppendAndConsumeChunk
(
std
:
:
move
(
chunk
)
)
;
numBlocksTransmitted
=
currentBlock
;
}
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
receiverBlockSize
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
receiverBlockSize
)
;
if
(
numBlocksTransmitted
>
0
)
{
EXPECT_GT
(
ad
.
CurrentBuffering
(
)
0U
)
;
}
}
EXPECT_EQ
(
ad
.
NumCorrectionChanges
(
)
0U
)
;
EXPECT_EQ
(
ad
.
BufferSize
(
)
9600U
)
;
}
TEST
(
TestAudioDriftCorrection
LargerReceiverBlockSizeThanDesiredBuffering
)
{
constexpr
uint32_t
transmitterBlockSize
=
128
;
constexpr
uint32_t
receiverBlockSize
=
4096
;
constexpr
uint32_t
sampleRate
=
48000
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
sampleRate
sampleRate
testPrincipal
)
;
for
(
uint32_t
i
=
0
;
i
<
(
sampleRate
/
1000
)
*
500
;
i
+
=
transmitterBlockSize
)
{
AudioSegment
inSegment
;
AudioChunk
chunk
=
CreateAudioChunk
<
float
>
(
transmitterBlockSize
1
AUDIO_FORMAT_FLOAT32
)
;
inSegment
.
AppendAndConsumeChunk
(
std
:
:
move
(
chunk
)
)
;
if
(
i
%
receiverBlockSize
=
=
0
)
{
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
receiverBlockSize
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
receiverBlockSize
)
;
}
if
(
i
>
=
receiverBlockSize
)
{
EXPECT_GT
(
ad
.
CurrentBuffering
(
)
0U
)
;
}
}
EXPECT_EQ
(
ad
.
NumCorrectionChanges
(
)
0U
)
;
EXPECT_EQ
(
ad
.
BufferSize
(
)
9600U
)
;
}
TEST
(
TestAudioDriftCorrection
DynamicInputBufferSizeChanges
)
{
constexpr
uint32_t
transmitterBlockSize1
=
2048
;
constexpr
uint32_t
transmitterBlockSize2
=
4096
;
constexpr
uint32_t
receiverBlockSize
=
128
;
constexpr
uint32_t
sampleRate
=
48000
;
constexpr
uint32_t
frequencyHz
=
100
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioDriftCorrection
ad
(
sampleRate
sampleRate
testPrincipal
)
;
AudioGenerator
<
AudioDataValue
>
tone
(
1
sampleRate
frequencyHz
)
;
AudioVerifier
<
AudioDataValue
>
inToneVerifier
(
sampleRate
frequencyHz
)
;
AudioVerifier
<
AudioDataValue
>
outToneVerifier
(
sampleRate
frequencyHz
)
;
TrackTime
totalFramesTransmitted
=
0
;
TrackTime
totalFramesReceived
=
0
;
const
auto
produceSomeData
=
[
&
]
(
uint32_t
aTransmitterBlockSize
)
{
TrackTime
transmittedFramesStart
=
totalFramesTransmitted
;
TrackTime
receivedFramesStart
=
totalFramesReceived
;
uint32_t
numBlocksTransmitted
=
0
;
for
(
uint32_t
i
=
0
;
i
<
10
*
sampleRate
;
i
+
=
receiverBlockSize
)
{
AudioSegment
inSegment
;
if
(
(
(
receivedFramesStart
-
transmittedFramesStart
+
i
)
/
aTransmitterBlockSize
)
>
numBlocksTransmitted
)
{
tone
.
Generate
(
inSegment
aTransmitterBlockSize
)
;
MOZ_ASSERT
(
!
inSegment
.
IsNull
(
)
)
;
inToneVerifier
.
AppendData
(
inSegment
)
;
MOZ_ASSERT
(
!
inSegment
.
IsNull
(
)
)
;
+
+
numBlocksTransmitted
;
totalFramesTransmitted
+
=
aTransmitterBlockSize
;
}
AudioSegment
outSegment
=
ad
.
RequestFrames
(
inSegment
receiverBlockSize
)
;
EXPECT_EQ
(
outSegment
.
GetDuration
(
)
receiverBlockSize
)
;
outToneVerifier
.
AppendData
(
outSegment
)
;
totalFramesReceived
+
=
receiverBlockSize
;
}
}
;
produceSomeData
(
transmitterBlockSize1
)
;
EXPECT_EQ
(
ad
.
BufferSize
(
)
4800U
)
;
EXPECT_EQ
(
ad
.
NumCorrectionChanges
(
)
0U
)
;
produceSomeData
(
transmitterBlockSize2
)
;
auto
numCorrectionChanges
=
ad
.
NumCorrectionChanges
(
)
;
EXPECT_GT
(
ad
.
BufferSize
(
)
4800U
)
;
produceSomeData
(
transmitterBlockSize2
)
;
EXPECT_EQ
(
ad
.
NumCorrectionChanges
(
)
numCorrectionChanges
)
;
produceSomeData
(
transmitterBlockSize1
)
;
numCorrectionChanges
=
ad
.
NumCorrectionChanges
(
)
;
EXPECT_GT
(
ad
.
BufferSize
(
)
4800U
)
;
produceSomeData
(
transmitterBlockSize1
)
;
EXPECT_EQ
(
ad
.
NumCorrectionChanges
(
)
numCorrectionChanges
)
;
EXPECT_NEAR
(
inToneVerifier
.
EstimatedFreq
(
)
tone
.
mFrequency
1
.
0f
)
;
EXPECT_EQ
(
inToneVerifier
.
PreSilenceSamples
(
)
0U
)
;
EXPECT_EQ
(
inToneVerifier
.
CountDiscontinuities
(
)
0U
)
;
EXPECT_NEAR
(
outToneVerifier
.
EstimatedFreq
(
)
tone
.
mFrequency
1
.
0f
)
;
EXPECT_EQ
(
outToneVerifier
.
PreSilenceSamples
(
)
2528U
)
;
EXPECT_EQ
(
outToneVerifier
.
CountDiscontinuities
(
)
2U
)
;
}
TEST
(
TestAudioDriftCorrection
DriftStepResponse
)
{
constexpr
uint32_t
nominalRate
=
48000
;
constexpr
uint32_t
interval
=
nominalRate
;
constexpr
uint32_t
inputRate
=
nominalRate
*
1005
/
1000
;
constexpr
uint32_t
inputInterval
=
inputRate
;
constexpr
uint32_t
iterations
=
200
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioGenerator
<
AudioDataValue
>
tone
(
1
nominalRate
440
)
;
AudioDriftCorrection
ad
(
nominalRate
nominalRate
testPrincipal
)
;
for
(
uint32_t
i
=
0
;
i
<
interval
*
iterations
;
i
+
=
interval
/
100
)
{
AudioSegment
inSegment
;
tone
.
Generate
(
inSegment
inputInterval
/
100
)
;
ad
.
RequestFrames
(
inSegment
interval
/
100
)
;
}
EXPECT_EQ
(
ad
.
BufferSize
(
)
4800U
)
;
}
TEST
(
TestAudioDriftCorrection
DriftStepResponseUnderrun
)
{
constexpr
uint32_t
nominalRate
=
48000
;
constexpr
uint32_t
interval
=
nominalRate
;
constexpr
uint32_t
iterations
=
200
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
uint32_t
inputRate
=
nominalRate
*
1005
/
1000
;
uint32_t
inputInterval
=
inputRate
;
Preferences
:
:
SetUint
(
"
media
.
clockdrift
.
buffering
"
10
)
;
AudioGenerator
<
AudioDataValue
>
tone
(
1
nominalRate
440
)
;
AudioDriftCorrection
ad
(
nominalRate
nominalRate
testPrincipal
)
;
for
(
uint32_t
i
=
0
;
i
<
interval
*
iterations
;
i
+
=
interval
/
100
)
{
AudioSegment
inSegment
;
tone
.
Generate
(
inSegment
inputInterval
/
100
)
;
ad
.
RequestFrames
(
inSegment
interval
/
100
)
;
}
inputRate
=
nominalRate
*
998
/
1000
;
inputInterval
=
inputRate
;
for
(
uint32_t
i
=
0
;
i
<
interval
*
iterations
;
i
+
=
interval
/
100
)
{
AudioSegment
inSegment
;
tone
.
Generate
(
inSegment
inputInterval
/
100
)
;
ad
.
RequestFrames
(
inSegment
interval
/
100
)
;
}
EXPECT_EQ
(
ad
.
BufferSize
(
)
4800U
)
;
Preferences
:
:
ClearUser
(
"
media
.
clockdrift
.
buffering
"
)
;
}
TEST
(
TestAudioDriftCorrection
DriftStepResponseUnderrunHighLatencyInput
)
{
constexpr
uint32_t
nominalRate
=
48000
;
constexpr
uint32_t
interval
=
nominalRate
;
constexpr
uint32_t
iterations
=
200
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
uint32_t
inputRate
=
nominalRate
*
1005
/
1000
;
uint32_t
inputInterval
=
inputRate
;
Preferences
:
:
SetUint
(
"
media
.
clockdrift
.
buffering
"
10
)
;
AudioGenerator
<
AudioDataValue
>
tone
(
1
nominalRate
440
)
;
AudioDriftCorrection
ad
(
nominalRate
nominalRate
testPrincipal
)
;
for
(
uint32_t
i
=
0
;
i
<
interval
*
iterations
;
i
+
=
interval
/
100
)
{
AudioSegment
inSegment
;
if
(
i
>
0
&
&
i
%
interval
=
=
0
)
{
tone
.
Generate
(
inSegment
inputInterval
)
;
}
ad
.
RequestFrames
(
inSegment
interval
/
100
)
;
}
inputRate
=
nominalRate
*
995
/
1000
;
inputInterval
=
inputRate
;
for
(
uint32_t
i
=
0
;
i
<
interval
*
iterations
;
i
+
=
interval
/
100
)
{
AudioSegment
inSegment
;
if
(
i
>
0
&
&
i
%
interval
=
=
0
)
{
tone
.
Generate
(
inSegment
inputInterval
)
;
}
ad
.
RequestFrames
(
inSegment
interval
/
100
)
;
}
EXPECT_EQ
(
ad
.
BufferSize
(
)
110400U
)
;
Preferences
:
:
ClearUser
(
"
media
.
clockdrift
.
buffering
"
)
;
}
TEST
(
TestAudioDriftCorrection
DriftStepResponseOverrun
)
{
constexpr
uint32_t
nominalRate
=
48000
;
constexpr
uint32_t
interval
=
nominalRate
;
constexpr
uint32_t
inputRate
=
nominalRate
*
1005
/
1000
;
constexpr
uint32_t
inputInterval
=
inputRate
;
constexpr
uint32_t
iterations
=
200
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
AudioGenerator
<
AudioDataValue
>
tone
(
1
nominalRate
440
)
;
AudioDriftCorrection
ad
(
nominalRate
nominalRate
testPrincipal
)
;
for
(
uint32_t
i
=
0
;
i
<
interval
*
iterations
;
i
+
=
interval
/
100
)
{
AudioSegment
inSegment
;
tone
.
Generate
(
inSegment
inputInterval
/
100
)
;
ad
.
RequestFrames
(
inSegment
interval
/
100
)
;
}
for
(
uint32_t
i
=
0
;
i
<
interval
*
iterations
;
i
+
=
interval
/
100
)
{
AudioSegment
inSegment
;
if
(
i
>
0
&
&
i
%
interval
=
=
0
)
{
tone
.
Generate
(
inSegment
inputInterval
)
;
}
ad
.
RequestFrames
(
inSegment
interval
/
100
)
;
}
EXPECT_EQ
(
ad
.
BufferSize
(
)
105600U
)
;
}
