#
ifndef
DOM_MEDIA_DRIFTCONTROL_DYNAMICRESAMPLER_H_
#
define
DOM_MEDIA_DRIFTCONTROL_DYNAMICRESAMPLER_H_
#
include
"
AudioRingBuffer
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
WavDumper
.
h
"
#
include
<
speex
/
speex_resampler
.
h
>
namespace
mozilla
{
const
uint32_t
STEREO
=
2
;
class
DynamicResampler
final
{
public
:
DynamicResampler
(
uint32_t
aInRate
uint32_t
aOutRate
uint32_t
aPreBufferFrames
=
0
)
;
~
DynamicResampler
(
)
;
void
SetSampleFormat
(
AudioSampleFormat
aFormat
)
;
uint32_t
GetOutRate
(
)
const
{
return
mOutRate
;
}
uint32_t
GetChannels
(
)
const
{
return
mChannels
;
}
void
AppendInput
(
const
nsTArray
<
const
float
*
>
&
aInBuffer
uint32_t
aInFrames
)
;
void
AppendInput
(
const
nsTArray
<
const
int16_t
*
>
&
aInBuffer
uint32_t
aInFrames
)
;
void
AppendInputSilence
(
const
uint32_t
aInFrames
)
;
uint32_t
InFramesBuffered
(
uint32_t
aChannelIndex
)
const
;
uint32_t
InFramesLeftToBuffer
(
uint32_t
aChannelIndex
)
const
;
bool
Resample
(
float
*
aOutBuffer
uint32_t
*
aOutFrames
uint32_t
aChannelIndex
)
;
bool
Resample
(
int16_t
*
aOutBuffer
uint32_t
*
aOutFrames
uint32_t
aChannelIndex
)
;
void
UpdateResampler
(
uint32_t
aOutRate
uint32_t
aChannels
)
;
bool
CanResample
(
uint32_t
aOutFrames
)
const
;
private
:
template
<
typename
T
>
void
AppendInputInternal
(
const
nsTArray
<
const
T
*
>
&
aInBuffer
uint32_t
aInFrames
)
{
MOZ_ASSERT
(
aInBuffer
.
Length
(
)
=
=
(
uint32_t
)
mChannels
)
;
for
(
uint32_t
i
=
0
;
i
<
mChannels
;
+
+
i
)
{
PushInFrames
(
aInBuffer
[
i
]
aInFrames
i
)
;
}
}
void
ResampleInternal
(
const
float
*
aInBuffer
uint32_t
*
aInFrames
float
*
aOutBuffer
uint32_t
*
aOutFrames
uint32_t
aChannelIndex
)
;
void
ResampleInternal
(
const
int16_t
*
aInBuffer
uint32_t
*
aInFrames
int16_t
*
aOutBuffer
uint32_t
*
aOutFrames
uint32_t
aChannelIndex
)
;
template
<
typename
T
>
bool
ResampleInternal
(
T
*
aOutBuffer
uint32_t
*
aOutFrames
uint32_t
aChannelIndex
)
{
MOZ_ASSERT
(
mInRate
)
;
MOZ_ASSERT
(
mOutRate
)
;
MOZ_ASSERT
(
mChannels
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mChannels
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mInternalInBuffer
.
Length
(
)
)
;
MOZ_ASSERT
(
aOutFrames
)
;
MOZ_ASSERT
(
*
aOutFrames
)
;
if
(
!
EnoughInFrames
(
*
aOutFrames
aChannelIndex
)
)
{
*
aOutFrames
=
0
;
return
false
;
}
if
(
mInRate
=
=
mOutRate
)
{
mInternalInBuffer
[
aChannelIndex
]
.
Read
(
Span
(
aOutBuffer
*
aOutFrames
)
)
;
mInputTail
[
aChannelIndex
]
.
StoreTail
<
T
>
(
aOutBuffer
*
aOutFrames
)
;
if
(
aChannelIndex
=
=
0
&
&
!
mIsWarmingUp
)
{
mInputStreamFile
.
Write
(
aOutBuffer
*
aOutFrames
)
;
mOutputStreamFile
.
Write
(
aOutBuffer
*
aOutFrames
)
;
}
return
true
;
}
uint32_t
totalOutFramesNeeded
=
*
aOutFrames
;
mInternalInBuffer
[
aChannelIndex
]
.
ReadNoCopy
(
[
this
&
aOutBuffer
&
totalOutFramesNeeded
aChannelIndex
]
(
const
Span
<
const
T
>
&
aInBuffer
)
-
>
uint32_t
{
if
(
!
totalOutFramesNeeded
)
{
return
0
;
}
uint32_t
outFramesResampled
=
totalOutFramesNeeded
;
uint32_t
inFrames
=
aInBuffer
.
Length
(
)
;
ResampleInternal
(
aInBuffer
.
data
(
)
&
inFrames
aOutBuffer
&
outFramesResampled
aChannelIndex
)
;
aOutBuffer
+
=
outFramesResampled
;
totalOutFramesNeeded
-
=
outFramesResampled
;
mInputTail
[
aChannelIndex
]
.
StoreTail
<
T
>
(
aInBuffer
)
;
return
inFrames
;
}
)
;
MOZ_ASSERT
(
totalOutFramesNeeded
=
=
0
)
;
return
true
;
}
bool
EnoughInFrames
(
uint32_t
aOutFrames
uint32_t
aChannelIndex
)
const
;
template
<
typename
T
>
void
PushInFrames
(
const
T
*
aInBuffer
const
uint32_t
aInFrames
uint32_t
aChannelIndex
)
{
MOZ_ASSERT
(
aInBuffer
)
;
MOZ_ASSERT
(
aInFrames
)
;
MOZ_ASSERT
(
mChannels
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mChannels
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mInternalInBuffer
.
Length
(
)
)
;
mInternalInBuffer
[
aChannelIndex
]
.
Write
(
Span
(
aInBuffer
aInFrames
)
)
;
}
void
WarmUpResampler
(
bool
aSkipLatency
)
;
public
:
const
uint32_t
mInRate
;
const
uint32_t
mPreBufferFrames
;
private
:
bool
mIsWarmingUp
=
false
;
uint32_t
mChannels
=
0
;
uint32_t
mOutRate
;
AutoTArray
<
AudioRingBuffer
STEREO
>
mInternalInBuffer
;
SpeexResamplerState
*
mResampler
=
nullptr
;
AudioSampleFormat
mSampleFormat
=
AUDIO_FORMAT_SILENCE
;
class
TailBuffer
{
public
:
template
<
typename
T
>
T
*
Buffer
(
)
{
return
reinterpret_cast
<
T
*
>
(
mBuffer
)
;
}
template
<
typename
T
>
void
StoreTail
(
const
Span
<
const
T
>
&
aInBuffer
)
{
StoreTail
(
aInBuffer
.
data
(
)
aInBuffer
.
size
(
)
)
;
}
template
<
typename
T
>
void
StoreTail
(
const
T
*
aInBuffer
uint32_t
aInFrames
)
{
if
(
aInFrames
>
=
MAXSIZE
)
{
PodCopy
(
Buffer
<
T
>
(
)
aInBuffer
+
aInFrames
-
MAXSIZE
MAXSIZE
)
;
mSize
=
MAXSIZE
;
}
else
{
PodCopy
(
Buffer
<
T
>
(
)
aInBuffer
aInFrames
)
;
mSize
=
aInFrames
;
}
}
uint32_t
Length
(
)
{
return
mSize
;
}
static
const
uint32_t
MAXSIZE
=
20
;
private
:
float
mBuffer
[
MAXSIZE
]
=
{
}
;
uint32_t
mSize
=
0
;
}
;
AutoTArray
<
TailBuffer
STEREO
>
mInputTail
;
WavDumper
mInputStreamFile
;
WavDumper
mOutputStreamFile
;
}
;
}
#
endif
