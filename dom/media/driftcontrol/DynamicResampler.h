#
ifndef
DOM_MEDIA_DRIFTCONTROL_DYNAMICRESAMPLER_H_
#
define
DOM_MEDIA_DRIFTCONTROL_DYNAMICRESAMPLER_H_
#
include
"
AudioRingBuffer
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
WavDumper
.
h
"
#
include
<
speex
/
speex_resampler
.
h
>
namespace
mozilla
{
const
uint32_t
STEREO
=
2
;
class
DynamicResampler
final
{
public
:
DynamicResampler
(
uint32_t
aInRate
uint32_t
aOutRate
media
:
:
TimeUnit
aPreBufferDuration
=
media
:
:
TimeUnit
:
:
Zero
(
)
)
;
~
DynamicResampler
(
)
;
void
SetSampleFormat
(
AudioSampleFormat
aFormat
)
;
uint32_t
GetOutRate
(
)
const
{
return
mOutRate
;
}
uint32_t
GetChannels
(
)
const
{
return
mChannels
;
}
void
AppendInput
(
const
nsTArray
<
const
float
*
>
&
aInBuffer
uint32_t
aInFrames
)
;
void
AppendInput
(
const
nsTArray
<
const
int16_t
*
>
&
aInBuffer
uint32_t
aInFrames
)
;
void
AppendInputSilence
(
const
uint32_t
aInFrames
)
;
uint32_t
InFramesBufferSize
(
)
const
;
uint32_t
InFramesBuffered
(
uint32_t
aChannelIndex
)
const
;
void
EnsurePreBuffer
(
media
:
:
TimeUnit
aDuration
)
;
void
SetPreBufferDuration
(
media
:
:
TimeUnit
aDuration
)
;
bool
Resample
(
float
*
aOutBuffer
uint32_t
aOutFrames
uint32_t
aChannelIndex
)
;
bool
Resample
(
int16_t
*
aOutBuffer
uint32_t
aOutFrames
uint32_t
aChannelIndex
)
;
void
UpdateResampler
(
uint32_t
aOutRate
uint32_t
aChannels
)
;
private
:
template
<
typename
T
>
void
AppendInputInternal
(
const
nsTArray
<
const
T
*
>
&
aInBuffer
uint32_t
aInFrames
)
{
MOZ_ASSERT
(
aInBuffer
.
Length
(
)
=
=
(
uint32_t
)
mChannels
)
;
for
(
uint32_t
i
=
0
;
i
<
mChannels
;
+
+
i
)
{
PushInFrames
(
aInBuffer
[
i
]
aInFrames
i
)
;
}
}
void
ResampleInternal
(
const
float
*
aInBuffer
uint32_t
*
aInFrames
float
*
aOutBuffer
uint32_t
*
aOutFrames
uint32_t
aChannelIndex
)
;
void
ResampleInternal
(
const
int16_t
*
aInBuffer
uint32_t
*
aInFrames
int16_t
*
aOutBuffer
uint32_t
*
aOutFrames
uint32_t
aChannelIndex
)
;
template
<
typename
T
>
bool
ResampleInternal
(
T
*
aOutBuffer
uint32_t
aOutFrames
uint32_t
aChannelIndex
)
{
MOZ_ASSERT
(
mInRate
)
;
MOZ_ASSERT
(
mOutRate
)
;
MOZ_ASSERT
(
mChannels
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mChannels
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mInternalInBuffer
.
Length
(
)
)
;
MOZ_ASSERT
(
aOutFrames
)
;
if
(
mInRate
=
=
mOutRate
)
{
bool
underrun
=
false
;
if
(
uint32_t
buffered
=
mInternalInBuffer
[
aChannelIndex
]
.
AvailableRead
(
)
;
buffered
<
aOutFrames
)
{
underrun
=
true
;
mIsPreBufferSet
=
false
;
mInternalInBuffer
[
aChannelIndex
]
.
WriteSilence
(
aOutFrames
-
buffered
)
;
}
mInternalInBuffer
[
aChannelIndex
]
.
Read
(
Span
(
aOutBuffer
aOutFrames
)
)
;
mInputTail
[
aChannelIndex
]
.
StoreTail
<
T
>
(
aOutBuffer
aOutFrames
)
;
if
(
aChannelIndex
=
=
0
&
&
!
mIsWarmingUp
)
{
mInputStreamFile
.
Write
(
aOutBuffer
aOutFrames
)
;
mOutputStreamFile
.
Write
(
aOutBuffer
aOutFrames
)
;
}
return
underrun
;
}
uint32_t
totalOutFramesNeeded
=
aOutFrames
;
auto
resample
=
[
&
]
{
mInternalInBuffer
[
aChannelIndex
]
.
ReadNoCopy
(
[
&
]
(
const
Span
<
const
T
>
&
aInBuffer
)
-
>
uint32_t
{
if
(
!
totalOutFramesNeeded
)
{
return
0
;
}
uint32_t
outFramesResampled
=
totalOutFramesNeeded
;
uint32_t
inFrames
=
aInBuffer
.
Length
(
)
;
ResampleInternal
(
aInBuffer
.
data
(
)
&
inFrames
aOutBuffer
&
outFramesResampled
aChannelIndex
)
;
aOutBuffer
+
=
outFramesResampled
;
totalOutFramesNeeded
-
=
outFramesResampled
;
mInputTail
[
aChannelIndex
]
.
StoreTail
<
T
>
(
aInBuffer
)
;
return
inFrames
;
}
)
;
}
;
resample
(
)
;
if
(
totalOutFramesNeeded
=
=
0
)
{
return
false
;
}
while
(
totalOutFramesNeeded
>
0
)
{
MOZ_ASSERT
(
mInternalInBuffer
[
aChannelIndex
]
.
AvailableRead
(
)
=
=
0
)
;
uint32_t
totalInFramesNeeded
=
(
(
CheckedUint32
(
totalOutFramesNeeded
)
*
mInRate
+
mOutRate
-
1
)
/
mOutRate
)
.
value
(
)
;
mInternalInBuffer
[
aChannelIndex
]
.
WriteSilence
(
totalInFramesNeeded
)
;
resample
(
)
;
}
mIsPreBufferSet
=
false
;
return
true
;
}
template
<
typename
T
>
void
PushInFrames
(
const
T
*
aInBuffer
const
uint32_t
aInFrames
uint32_t
aChannelIndex
)
{
MOZ_ASSERT
(
aInBuffer
)
;
MOZ_ASSERT
(
aInFrames
)
;
MOZ_ASSERT
(
mChannels
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mChannels
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mInternalInBuffer
.
Length
(
)
)
;
EnsureInputBufferDuration
(
media
:
:
TimeUnit
(
CheckedInt64
(
mInternalInBuffer
[
aChannelIndex
]
.
AvailableRead
(
)
)
+
aInFrames
mInRate
)
)
;
mInternalInBuffer
[
aChannelIndex
]
.
Write
(
Span
(
aInBuffer
aInFrames
)
)
;
}
void
WarmUpResampler
(
bool
aSkipLatency
)
;
media
:
:
TimeUnit
CalculateInputBufferDuration
(
)
const
{
return
std
:
:
max
(
mPreBufferDuration
*
2
media
:
:
TimeUnit
:
:
FromSeconds
(
0
.
1
)
)
;
}
bool
EnsureInputBufferDuration
(
media
:
:
TimeUnit
aDuration
)
{
if
(
aDuration
<
=
mSetBufferDuration
)
{
return
true
;
}
const
media
:
:
TimeUnit
cap
=
media
:
:
TimeUnit
:
:
FromSeconds
(
5
)
;
if
(
mSetBufferDuration
=
=
cap
)
{
return
false
;
}
uint32_t
sampleSize
=
0
;
if
(
mSampleFormat
=
=
AUDIO_FORMAT_FLOAT32
)
{
sampleSize
=
sizeof
(
float
)
;
}
else
if
(
mSampleFormat
=
=
AUDIO_FORMAT_S16
)
{
sampleSize
=
sizeof
(
short
)
;
}
if
(
sampleSize
=
=
0
)
{
return
true
;
}
media
:
:
TimeUnit
duration
=
mSetBufferDuration
*
2
;
if
(
aDuration
>
duration
)
{
duration
=
aDuration
.
ToBase
<
media
:
:
TimeUnit
:
:
CeilingPolicy
>
(
10
)
;
}
duration
=
std
:
:
min
(
cap
duration
)
;
bool
success
=
true
;
for
(
auto
&
b
:
mInternalInBuffer
)
{
success
=
success
&
&
b
.
SetLengthBytes
(
sampleSize
*
duration
.
ToTicksAtRate
(
mInRate
)
)
;
}
if
(
success
)
{
mSetBufferDuration
=
duration
;
return
true
;
}
const
uint32_t
sizeInFrames
=
static_cast
<
uint32_t
>
(
mSetBufferDuration
.
ToTicksAtRate
(
mInRate
)
)
;
NS_WARNING
(
nsPrintfCString
(
"
Failed
to
allocate
a
buffer
of
%
u
bytes
(
%
u
"
"
frames
)
.
Expect
glitches
.
"
sampleSize
*
sizeInFrames
sizeInFrames
)
.
get
(
)
)
;
for
(
auto
&
b
:
mInternalInBuffer
)
{
MOZ_ALWAYS_TRUE
(
b
.
SetLengthBytes
(
sampleSize
*
sizeInFrames
)
)
;
}
return
false
;
}
public
:
const
uint32_t
mInRate
;
private
:
bool
mIsPreBufferSet
=
false
;
bool
mIsWarmingUp
=
false
;
media
:
:
TimeUnit
mPreBufferDuration
;
media
:
:
TimeUnit
mSetBufferDuration
=
media
:
:
TimeUnit
:
:
Zero
(
)
;
uint32_t
mChannels
=
0
;
uint32_t
mOutRate
;
AutoTArray
<
AudioRingBuffer
STEREO
>
mInternalInBuffer
;
SpeexResamplerState
*
mResampler
=
nullptr
;
AudioSampleFormat
mSampleFormat
=
AUDIO_FORMAT_SILENCE
;
class
TailBuffer
{
public
:
template
<
typename
T
>
T
*
Buffer
(
)
{
return
reinterpret_cast
<
T
*
>
(
mBuffer
)
;
}
template
<
typename
T
>
void
StoreTail
(
const
Span
<
const
T
>
&
aInBuffer
)
{
StoreTail
(
aInBuffer
.
data
(
)
aInBuffer
.
size
(
)
)
;
}
template
<
typename
T
>
void
StoreTail
(
const
T
*
aInBuffer
uint32_t
aInFrames
)
{
if
(
aInFrames
>
=
MAXSIZE
)
{
PodCopy
(
Buffer
<
T
>
(
)
aInBuffer
+
aInFrames
-
MAXSIZE
MAXSIZE
)
;
mSize
=
MAXSIZE
;
}
else
{
PodCopy
(
Buffer
<
T
>
(
)
aInBuffer
aInFrames
)
;
mSize
=
aInFrames
;
}
}
uint32_t
Length
(
)
{
return
mSize
;
}
static
const
uint32_t
MAXSIZE
=
20
;
private
:
float
mBuffer
[
MAXSIZE
]
=
{
}
;
uint32_t
mSize
=
0
;
}
;
AutoTArray
<
TailBuffer
STEREO
>
mInputTail
;
WavDumper
mInputStreamFile
;
WavDumper
mOutputStreamFile
;
}
;
}
#
endif
