#
include
"
DriftController
.
h
"
#
include
<
atomic
>
#
include
<
cmath
>
#
include
<
mutex
>
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
namespace
mozilla
{
LazyLogModule
gDriftControllerGraphsLog
(
"
DriftControllerGraphs
"
)
;
extern
LazyLogModule
gMediaTrackGraphLog
;
#
define
LOG_CONTROLLER
(
level
controller
format
.
.
.
)
\
MOZ_LOG
(
gMediaTrackGraphLog
level
\
(
"
DriftController
%
p
:
(
plot
-
id
%
u
)
"
format
controller
\
(
controller
)
-
>
mPlotId
#
#
__VA_ARGS__
)
)
#
define
LOG_PLOT_NAMES
(
)
\
MOZ_LOG
(
\
gDriftControllerGraphsLog
LogLevel
:
:
Verbose
\
(
"
id
t
buffering
avgbuffered
desired
buffersize
inlatency
outlatency
"
\
"
inframesavg
outframesavg
inrate
outrate
steadystaterate
"
\
"
nearthreshold
corrected
hysteresiscorrected
configured
"
)
)
#
define
LOG_PLOT_VALUES
(
id
t
buffering
avgbuffered
desired
buffersize
\
inlatency
outlatency
inframesavg
outframesavg
\
inrate
outrate
steadystaterate
nearthreshold
\
corrected
hysteresiscorrected
configured
)
\
MOZ_LOG
(
gDriftControllerGraphsLog
LogLevel
:
:
Verbose
\
(
"
DriftController
%
u
%
.
3f
%
u
%
.
5f
%
"
PRId64
"
%
u
%
"
PRId64
"
"
\
"
%
"
PRId64
"
%
.
5f
%
.
5f
%
u
%
u
"
\
"
%
.
5f
%
"
PRId64
"
%
.
5f
%
.
5f
"
\
"
%
ld
"
\
id
t
buffering
avgbuffered
desired
buffersize
inlatency
\
outlatency
inframesavg
outframesavg
inrate
outrate
\
steadystaterate
nearthreshold
corrected
hysteresiscorrected
\
configured
)
)
static
uint8_t
GenerateId
(
)
{
static
std
:
:
atomic
<
uint8_t
>
id
{
0
}
;
return
+
+
id
;
}
DriftController
:
:
DriftController
(
uint32_t
aSourceRate
uint32_t
aTargetRate
media
:
:
TimeUnit
aDesiredBuffering
)
:
mPlotId
(
GenerateId
(
)
)
mSourceRate
(
aSourceRate
)
mTargetRate
(
aTargetRate
)
mDesiredBuffering
(
aDesiredBuffering
)
mCorrectedSourceRate
(
static_cast
<
float
>
(
aSourceRate
)
)
mMeasuredSourceLatency
(
5
)
mMeasuredTargetLatency
(
5
)
{
LOG_CONTROLLER
(
LogLevel
:
:
Info
this
"
Created
.
Resampling
%
uHz
-
>
%
uHz
.
Initial
desired
buffering
:
%
.
2fms
.
"
mSourceRate
mTargetRate
mDesiredBuffering
.
ToSeconds
(
)
*
1000
.
0
)
;
static
std
:
:
once_flag
sOnceFlag
;
std
:
:
call_once
(
sOnceFlag
[
]
{
LOG_PLOT_NAMES
(
)
;
}
)
;
}
void
DriftController
:
:
SetDesiredBuffering
(
media
:
:
TimeUnit
aDesiredBuffering
)
{
LOG_CONTROLLER
(
LogLevel
:
:
Debug
this
"
SetDesiredBuffering
%
.
2fms
-
>
%
.
2fms
"
mDesiredBuffering
.
ToSeconds
(
)
*
1000
.
0
aDesiredBuffering
.
ToSeconds
(
)
*
1000
.
0
)
;
mLastDesiredBufferingChangeTime
=
mTotalTargetClock
;
mDesiredBuffering
=
aDesiredBuffering
.
ToBase
(
mSourceRate
)
;
}
void
DriftController
:
:
ResetAfterUnderrun
(
)
{
mIsHandlingUnderrun
=
true
;
mTargetClock
=
mAdjustmentInterval
;
}
uint32_t
DriftController
:
:
GetCorrectedSourceRate
(
)
const
{
return
std
:
:
lround
(
mCorrectedSourceRate
)
;
}
void
DriftController
:
:
UpdateClock
(
media
:
:
TimeUnit
aSourceDuration
media
:
:
TimeUnit
aTargetDuration
uint32_t
aBufferedFrames
uint32_t
aBufferSize
)
{
MOZ_ASSERT
(
!
aTargetDuration
.
IsZero
(
)
)
;
mTargetClock
+
=
aTargetDuration
;
mTotalTargetClock
+
=
aTargetDuration
;
mMeasuredTargetLatency
.
insert
(
aTargetDuration
)
;
if
(
aSourceDuration
.
IsZero
(
)
)
{
return
;
}
media
:
:
TimeUnit
targetDuration
=
mTotalTargetClock
-
mTargetClockAfterLastSourcePacket
;
mTargetClockAfterLastSourcePacket
=
mTotalTargetClock
;
mMeasuredSourceLatency
.
insert
(
aSourceDuration
)
;
double
sourceDurationSecs
=
aSourceDuration
.
ToSeconds
(
)
;
double
targetDurationSecs
=
targetDuration
.
ToSeconds
(
)
;
if
(
mOutputDurationAvg
=
=
0
.
0
)
{
mInputDurationAvg
=
mOutputDurationAvg
=
std
:
:
max
(
sourceDurationSecs
targetDurationSecs
)
;
}
auto
UpdateAverageWithMeasurement
=
[
]
(
double
*
aAvg
double
aData
)
{
constexpr
double
kMovingAvgWeight
=
0
.
01
;
*
aAvg
+
=
kMovingAvgWeight
*
(
aData
-
*
aAvg
)
;
}
;
UpdateAverageWithMeasurement
(
&
mInputDurationAvg
sourceDurationSecs
)
;
UpdateAverageWithMeasurement
(
&
mOutputDurationAvg
targetDurationSecs
)
;
double
driftEstimate
=
mInputDurationAvg
/
mOutputDurationAvg
;
UpdateAverageWithMeasurement
(
&
mStage1Drift
driftEstimate
)
;
UpdateAverageWithMeasurement
(
&
mDriftEstimate
mStage1Drift
)
;
double
adjustment
=
targetDurationSecs
*
(
mSourceRate
*
mDriftEstimate
-
GetCorrectedSourceRate
(
)
)
;
mStage1Buffered
+
=
adjustment
;
mAvgBufferedFramesEst
+
=
adjustment
;
UpdateAverageWithMeasurement
(
&
mStage1Buffered
aBufferedFrames
)
;
UpdateAverageWithMeasurement
(
&
mAvgBufferedFramesEst
mStage1Buffered
)
;
if
(
mIsHandlingUnderrun
)
{
mIsHandlingUnderrun
=
false
;
mAvgBufferedFramesEst
=
static_cast
<
double
>
(
mDesiredBuffering
.
ToTicksAtRate
(
mSourceRate
)
)
;
mStage1Buffered
=
mAvgBufferedFramesEst
;
}
if
(
mTargetClock
>
=
mAdjustmentInterval
)
{
CalculateCorrection
(
aBufferedFrames
aBufferSize
)
;
}
}
void
DriftController
:
:
CalculateCorrection
(
uint32_t
aBufferedFrames
uint32_t
aBufferSize
)
{
const
float
cap
=
static_cast
<
float
>
(
mSourceRate
)
/
1000
.
0f
;
float
steadyStateRate
=
static_cast
<
float
>
(
mDriftEstimate
)
*
static_cast
<
float
>
(
mSourceRate
)
;
uint32_t
desiredBufferedFrames
=
mDesiredBuffering
.
ToTicksAtRate
(
mSourceRate
)
;
int32_t
error
=
(
CheckedInt32
(
aBufferedFrames
)
-
desiredBufferedFrames
)
.
value
(
)
;
float
avgError
=
static_cast
<
float
>
(
mAvgBufferedFramesEst
)
-
static_cast
<
float
>
(
desiredBufferedFrames
)
;
static
constexpr
uint32_t
kNearDenominator
=
5
;
const
media
:
:
TimeUnit
nearCap
=
media
:
:
TimeUnit
:
:
FromSeconds
(
0
.
01
)
;
const
auto
nearThreshold
=
std
:
:
min
(
nearCap
mDesiredBuffering
/
kNearDenominator
)
.
ToTicksAtRate
(
mSourceRate
)
;
if
(
std
:
:
abs
(
error
)
>
nearThreshold
)
{
mDurationNearDesired
=
media
:
:
TimeUnit
:
:
Zero
(
)
;
}
else
{
mDurationNearDesired
+
=
mTargetClock
;
}
;
float
rateError
=
(
mCorrectedSourceRate
-
steadyStateRate
)
*
std
:
:
copysign
(
1
.
f
avgError
)
;
float
absAvgError
=
std
:
:
abs
(
avgError
)
;
constexpr
float
slowConvergenceSecs
=
30
;
constexpr
float
resetConvergenceSecs
=
15
;
float
correctedRate
=
steadyStateRate
+
avgError
/
resetConvergenceSecs
;
float
hysteresisCorrectedRate
=
mCorrectedSourceRate
;
constexpr
float
slowHysteresis
=
1
.
f
;
if
(
(
rateError
+
slowHysteresis
)
*
slowConvergenceSecs
<
=
absAvgError
|
|
rateError
*
mAdjustmentInterval
.
ToSeconds
(
)
>
=
absAvgError
)
{
hysteresisCorrectedRate
=
correctedRate
;
float
cappedRate
=
std
:
:
clamp
(
correctedRate
mCorrectedSourceRate
-
cap
mCorrectedSourceRate
+
cap
)
;
if
(
std
:
:
lround
(
mCorrectedSourceRate
)
!
=
std
:
:
lround
(
cappedRate
)
)
{
LOG_CONTROLLER
(
LogLevel
:
:
Verbose
this
"
Updating
Correction
:
Nominal
:
%
uHz
-
>
%
uHz
Corrected
:
"
"
%
.
2fHz
-
>
%
uHz
(
diff
%
.
2fHz
)
error
:
%
.
2fms
(
nearThreshold
:
"
"
%
.
2fms
)
buffering
:
%
.
2fms
desired
buffering
:
%
.
2fms
"
mSourceRate
mTargetRate
cappedRate
mTargetRate
cappedRate
-
mCorrectedSourceRate
media
:
:
TimeUnit
(
error
mSourceRate
)
.
ToSeconds
(
)
*
1000
.
0
media
:
:
TimeUnit
(
nearThreshold
mSourceRate
)
.
ToSeconds
(
)
*
1000
.
0
media
:
:
TimeUnit
(
aBufferedFrames
mSourceRate
)
.
ToSeconds
(
)
*
1000
.
0
mDesiredBuffering
.
ToSeconds
(
)
*
1000
.
0
)
;
+
+
mNumCorrectionChanges
;
}
mCorrectedSourceRate
=
std
:
:
max
(
1
.
f
cappedRate
)
;
}
LOG_PLOT_VALUES
(
mPlotId
mTotalTargetClock
.
ToSeconds
(
)
aBufferedFrames
mAvgBufferedFramesEst
mDesiredBuffering
.
ToTicksAtRate
(
mSourceRate
)
aBufferSize
mMeasuredSourceLatency
.
mean
(
)
.
ToTicksAtRate
(
mSourceRate
)
mMeasuredTargetLatency
.
mean
(
)
.
ToTicksAtRate
(
mTargetRate
)
mInputDurationAvg
*
mSourceRate
mOutputDurationAvg
*
mTargetRate
mSourceRate
mTargetRate
steadyStateRate
nearThreshold
correctedRate
hysteresisCorrectedRate
std
:
:
lround
(
mCorrectedSourceRate
)
)
;
mTargetClock
=
media
:
:
TimeUnit
:
:
Zero
(
)
;
}
}
#
undef
LOG_PLOT_VALUES
#
undef
LOG_PLOT_NAMES
#
undef
LOG_CONTROLLER
