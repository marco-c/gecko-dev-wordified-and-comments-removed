#
include
"
AudioResampler
.
h
"
namespace
mozilla
{
AudioResampler
:
:
AudioResampler
(
uint32_t
aInRate
uint32_t
aOutRate
uint32_t
aPreBufferFrames
const
PrincipalHandle
&
aPrincipalHandle
)
:
mResampler
(
aInRate
aOutRate
aPreBufferFrames
)
mOutputChunks
(
aOutRate
/
10
STEREO
aPrincipalHandle
)
{
}
void
AudioResampler
:
:
AppendInput
(
const
AudioSegment
&
aInSegment
)
{
MOZ_ASSERT
(
aInSegment
.
GetDuration
(
)
)
;
for
(
AudioSegment
:
:
ConstChunkIterator
iter
(
aInSegment
)
;
!
iter
.
IsEnded
(
)
;
iter
.
Next
(
)
)
{
const
AudioChunk
&
chunk
=
*
iter
;
if
(
!
mIsSampleFormatSet
)
{
if
(
chunk
.
mBufferFormat
=
=
AUDIO_FORMAT_SILENCE
)
{
continue
;
}
mOutputChunks
.
SetSampleFormat
(
chunk
.
mBufferFormat
)
;
mResampler
.
SetSampleFormat
(
chunk
.
mBufferFormat
)
;
if
(
mResampler
.
mPreBufferFrames
)
{
TrackTime
formattedDuration
=
0
;
for
(
AudioSegment
:
:
ConstChunkIterator
nestedIter
(
iter
)
;
!
nestedIter
.
IsEnded
(
)
;
nestedIter
.
Next
(
)
)
{
formattedDuration
+
=
nestedIter
-
>
GetDuration
(
)
;
}
if
(
mResampler
.
mPreBufferFrames
>
formattedDuration
)
{
mResampler
.
AppendInputSilence
(
mResampler
.
mPreBufferFrames
-
formattedDuration
)
;
}
}
mIsSampleFormatSet
=
true
;
}
MOZ_ASSERT
(
mIsSampleFormatSet
)
;
if
(
chunk
.
IsNull
(
)
)
{
mResampler
.
AppendInputSilence
(
chunk
.
GetDuration
(
)
)
;
continue
;
}
UpdateChannels
(
chunk
.
mChannelData
.
Length
(
)
)
;
if
(
chunk
.
mBufferFormat
=
=
AUDIO_FORMAT_FLOAT32
)
{
mResampler
.
AppendInput
(
chunk
.
ChannelData
<
float
>
(
)
chunk
.
GetDuration
(
)
)
;
}
else
{
mResampler
.
AppendInput
(
chunk
.
ChannelData
<
int16_t
>
(
)
chunk
.
GetDuration
(
)
)
;
}
}
}
AudioSegment
AudioResampler
:
:
Resample
(
uint32_t
aOutFrames
)
{
AudioSegment
segment
;
if
(
!
mIsSampleFormatSet
)
{
segment
.
AppendNullData
(
aOutFrames
)
;
return
segment
;
}
if
(
!
mResampler
.
CanResample
(
aOutFrames
+
1
)
)
{
return
segment
;
}
uint32_t
totalFrames
=
aOutFrames
;
while
(
totalFrames
)
{
MOZ_ASSERT
(
totalFrames
>
0
)
;
AudioChunk
&
chunk
=
mOutputChunks
.
GetNext
(
)
;
uint32_t
outFrames
=
std
:
:
min
(
totalFrames
mOutputChunks
.
ChunkCapacity
(
)
)
;
totalFrames
-
=
outFrames
;
for
(
uint32_t
i
=
0
;
i
<
chunk
.
ChannelCount
(
)
;
+
+
i
)
{
uint32_t
outFramesUsed
=
outFrames
;
if
(
chunk
.
mBufferFormat
=
=
AUDIO_FORMAT_FLOAT32
)
{
#
ifdef
DEBUG
bool
rv
=
#
endif
mResampler
.
Resample
(
chunk
.
ChannelDataForWrite
<
float
>
(
i
)
&
outFramesUsed
i
)
;
MOZ_ASSERT
(
rv
)
;
}
else
{
#
ifdef
DEBUG
bool
rv
=
#
endif
mResampler
.
Resample
(
chunk
.
ChannelDataForWrite
<
int16_t
>
(
i
)
&
outFramesUsed
i
)
;
MOZ_ASSERT
(
rv
)
;
}
MOZ_ASSERT
(
outFramesUsed
=
=
outFrames
)
;
chunk
.
mDuration
=
outFrames
;
}
segment
.
AppendAndConsumeChunk
(
AudioChunk
(
chunk
)
)
;
}
return
segment
;
}
void
AudioResampler
:
:
Update
(
uint32_t
aOutRate
uint32_t
aChannels
)
{
mResampler
.
UpdateResampler
(
aOutRate
aChannels
)
;
mOutputChunks
.
Update
(
aChannels
)
;
}
uint32_t
AudioResampler
:
:
InputReadableFrames
(
)
const
{
if
(
!
mIsSampleFormatSet
)
{
return
mResampler
.
mPreBufferFrames
;
}
return
mResampler
.
InFramesBuffered
(
0
)
;
}
uint32_t
AudioResampler
:
:
InputWritableFrames
(
)
const
{
if
(
!
mIsSampleFormatSet
)
{
return
mResampler
.
mPreBufferFrames
;
}
return
mResampler
.
InFramesLeftToBuffer
(
0
)
;
}
}
