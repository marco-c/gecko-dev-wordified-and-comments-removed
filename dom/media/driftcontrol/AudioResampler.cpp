#
include
"
AudioResampler
.
h
"
#
include
"
TimeUnits
.
h
"
namespace
mozilla
{
AudioResampler
:
:
AudioResampler
(
uint32_t
aInRate
uint32_t
aOutRate
uint32_t
aInputPreBufferFrameCount
const
PrincipalHandle
&
aPrincipalHandle
)
:
mResampler
(
aInRate
aOutRate
aInputPreBufferFrameCount
)
mOutputChunks
(
aOutRate
/
10
STEREO
aPrincipalHandle
)
{
}
void
AudioResampler
:
:
AppendInput
(
const
AudioSegment
&
aInSegment
)
{
MOZ_ASSERT
(
aInSegment
.
GetDuration
(
)
)
;
for
(
AudioSegment
:
:
ConstChunkIterator
iter
(
aInSegment
)
;
!
iter
.
IsEnded
(
)
;
iter
.
Next
(
)
)
{
const
AudioChunk
&
chunk
=
*
iter
;
if
(
!
mIsSampleFormatSet
)
{
if
(
chunk
.
mBufferFormat
=
=
AUDIO_FORMAT_SILENCE
)
{
continue
;
}
mOutputChunks
.
SetSampleFormat
(
chunk
.
mBufferFormat
)
;
mResampler
.
SetSampleFormat
(
chunk
.
mBufferFormat
)
;
mIsSampleFormatSet
=
true
;
}
MOZ_ASSERT
(
mIsSampleFormatSet
)
;
if
(
chunk
.
IsNull
(
)
)
{
mResampler
.
AppendInputSilence
(
chunk
.
GetDuration
(
)
)
;
continue
;
}
UpdateChannels
(
chunk
.
mChannelData
.
Length
(
)
)
;
if
(
chunk
.
mBufferFormat
=
=
AUDIO_FORMAT_FLOAT32
)
{
mResampler
.
AppendInput
(
chunk
.
ChannelData
<
float
>
(
)
chunk
.
GetDuration
(
)
)
;
}
else
{
mResampler
.
AppendInput
(
chunk
.
ChannelData
<
int16_t
>
(
)
chunk
.
GetDuration
(
)
)
;
}
}
}
AudioSegment
AudioResampler
:
:
Resample
(
uint32_t
aOutFrames
bool
*
aHasUnderrun
)
{
MOZ_ASSERT
(
aHasUnderrun
)
;
AudioSegment
segment
;
if
(
!
mIsSampleFormatSet
)
{
segment
.
AppendNullData
(
aOutFrames
)
;
return
segment
;
}
media
:
:
TimeUnit
outDuration
(
aOutFrames
mResampler
.
mOutRate
)
;
mResampler
.
EnsurePreBuffer
(
outDuration
)
;
const
media
:
:
TimeUnit
chunkCapacity
(
mOutputChunks
.
ChunkCapacity
(
)
mResampler
.
mOutRate
)
;
while
(
!
outDuration
.
IsZero
(
)
)
{
MOZ_ASSERT
(
outDuration
.
IsPositive
(
)
)
;
AudioChunk
&
chunk
=
mOutputChunks
.
GetNext
(
)
;
const
media
:
:
TimeUnit
chunkDuration
=
std
:
:
min
(
outDuration
chunkCapacity
)
;
outDuration
-
=
chunkDuration
;
const
uint32_t
outFrames
=
chunkDuration
.
ToTicksAtRate
(
mResampler
.
mOutRate
)
;
for
(
uint32_t
i
=
0
;
i
<
chunk
.
ChannelCount
(
)
;
+
+
i
)
{
if
(
chunk
.
mBufferFormat
=
=
AUDIO_FORMAT_FLOAT32
)
{
*
aHasUnderrun
|
=
mResampler
.
Resample
(
chunk
.
ChannelDataForWrite
<
float
>
(
i
)
outFrames
i
)
;
}
else
{
*
aHasUnderrun
|
=
mResampler
.
Resample
(
chunk
.
ChannelDataForWrite
<
int16_t
>
(
i
)
outFrames
i
)
;
}
}
chunk
.
mDuration
=
outFrames
;
segment
.
AppendAndConsumeChunk
(
AudioChunk
(
chunk
)
)
;
}
return
segment
;
}
void
AudioResampler
:
:
Update
(
uint32_t
aInRate
uint32_t
aChannels
)
{
mResampler
.
UpdateResampler
(
aInRate
aChannels
)
;
mOutputChunks
.
Update
(
aChannels
)
;
}
uint32_t
AudioResampler
:
:
InputCapacityFrames
(
)
const
{
return
mResampler
.
InFramesBufferSize
(
)
;
}
uint32_t
AudioResampler
:
:
InputReadableFrames
(
)
const
{
return
mResampler
.
InFramesBuffered
(
0
)
;
}
}
