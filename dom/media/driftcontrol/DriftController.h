#
ifndef
DOM_MEDIA_DRIFTCONTROL_DRIFTCONTROLLER_H_
#
define
DOM_MEDIA_DRIFTCONTROL_DRIFTCONTROLLER_H_
#
include
"
mozilla
/
RollingMean
.
h
"
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
"
MediaSegment
.
h
"
namespace
mozilla
{
class
DriftController
final
{
public
:
DriftController
(
uint32_t
aSourceRate
uint32_t
aTargetRate
uint32_t
aDesiredBuffering
)
;
void
SetDesiredBuffering
(
uint32_t
aDesiredBuffering
)
;
void
ResetAfterUnderrun
(
)
;
uint32_t
GetCorrectedTargetRate
(
)
const
;
uint32_t
NumCorrectionChanges
(
)
const
{
return
mNumCorrectionChanges
;
}
void
UpdateClock
(
uint32_t
aSourceFrames
uint32_t
aTargetFrames
uint32_t
aBufferedFrames
uint32_t
aBufferSize
)
;
private
:
void
CalculateCorrection
(
uint32_t
aBufferedFrames
uint32_t
aBufferSize
)
;
public
:
const
uint8_t
mPlotId
;
const
uint32_t
mSourceRate
;
const
uint32_t
mTargetRate
;
const
uint32_t
mAdjustmentIntervalMs
=
1000
;
const
TrackTime
mIntegralCapFrameLimit
=
10
*
mTargetRate
;
private
:
uint32_t
mDesiredBuffering
;
int32_t
mPreviousError
=
0
;
float
mIntegral
=
0
.
0
;
Maybe
<
float
>
mIntegralCenterForCap
;
float
mCorrectedTargetRate
;
Maybe
<
int32_t
>
mLastHysteresisBoundaryCorrection
;
uint32_t
mTargetFramesWithinHysteresis
=
0
;
uint32_t
mNumCorrectionChanges
=
0
;
RollingMean
<
TrackTime
TrackTime
>
mMeasuredSourceLatency
;
RollingMean
<
TrackTime
TrackTime
>
mMeasuredTargetLatency
;
uint32_t
mTargetClock
=
0
;
TrackTime
mTotalTargetClock
=
0
;
}
;
}
#
endif
