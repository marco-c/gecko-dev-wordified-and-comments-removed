#
ifndef
mozilla_PerformanceRecorder_h
#
define
mozilla_PerformanceRecorder_h
#
include
<
type_traits
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BaseProfilerMarkersPrerequisites
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTPriorityQueue
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
namespace
mozilla
{
struct
TrackingId
{
enum
class
Source
:
uint8_t
{
Unimplemented
AudioDestinationNode
Camera
Canvas
MediaElementDecoder
MediaElementStream
RTCRtpReceiver
Screen
Tab
Window
LAST
}
;
enum
class
TrackAcrossProcesses
:
uint8_t
{
Yes
No
}
;
TrackingId
(
)
;
TrackingId
(
Source
aSource
uint32_t
aUniqueInProcId
TrackAcrossProcesses
aTrack
=
TrackAcrossProcesses
:
:
No
)
;
nsCString
ToString
(
)
const
;
Source
mSource
;
uint32_t
mUniqueInProcId
;
Maybe
<
uint32_t
>
mProcId
;
}
;
enum
class
MediaInfoFlag
:
uint16_t
{
None
=
(
0
<
<
0
)
NonKeyFrame
=
(
1
<
<
0
)
KeyFrame
=
(
1
<
<
1
)
SoftwareDecoding
=
(
1
<
<
2
)
HardwareDecoding
=
(
1
<
<
3
)
VIDEO_AV1
=
(
1
<
<
4
)
VIDEO_H264
=
(
1
<
<
5
)
VIDEO_VP8
=
(
1
<
<
6
)
VIDEO_VP9
=
(
1
<
<
7
)
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
MediaInfoFlag
)
enum
class
MediaStage
:
uint8_t
{
Invalid
RequestData
RequestDemux
CopyDemuxedData
RequestDecode
CopyDecodedVideo
}
;
class
PlaybackStage
{
public
:
explicit
PlaybackStage
(
MediaStage
aStage
int32_t
aHeight
=
0
MediaInfoFlag
aFlag
=
MediaInfoFlag
:
:
None
)
:
mStage
(
aStage
)
mHeight
(
aHeight
)
mFlag
(
aFlag
)
{
MOZ_ASSERT
(
aStage
!
=
MediaStage
:
:
Invalid
)
;
}
ProfilerString8View
Name
(
)
const
;
const
MarkerCategory
&
Category
(
)
const
{
return
baseprofiler
:
:
category
:
:
MEDIA_PLAYBACK
;
}
MediaStage
mStage
;
int32_t
mHeight
;
MediaInfoFlag
mFlag
;
private
:
mutable
Maybe
<
nsCString
>
mName
;
}
;
class
CopyVideoStage
{
public
:
CopyVideoStage
(
nsCString
aSource
TrackingId
aTrackingId
int32_t
aWidth
int32_t
aHeight
)
:
mSource
(
std
:
:
move
(
aSource
)
)
mTrackingId
(
std
:
:
move
(
aTrackingId
)
)
mWidth
(
aWidth
)
mHeight
(
aHeight
)
{
}
ProfilerString8View
Name
(
)
const
;
const
MarkerCategory
&
Category
(
)
const
{
return
baseprofiler
:
:
category
:
:
MEDIA_RT
;
}
nsCString
mSource
;
TrackingId
mTrackingId
;
int32_t
mWidth
;
int32_t
mHeight
;
private
:
mutable
Maybe
<
nsCString
>
mName
;
}
;
class
PerformanceRecorderBase
{
public
:
static
bool
IsMeasurementEnabled
(
)
;
static
TimeStamp
GetCurrentTimeForMeasurement
(
)
;
static
const
char
*
FindMediaResolution
(
int32_t
aHeight
)
;
protected
:
static
inline
bool
sEnableMeasurementForTesting
=
false
;
}
;
template
<
typename
StageType
>
class
PerformanceRecorderImpl
:
public
PerformanceRecorderBase
{
public
:
~
PerformanceRecorderImpl
(
)
=
default
;
PerformanceRecorderImpl
(
PerformanceRecorderImpl
&
&
aRhs
)
noexcept
:
mStages
(
std
:
:
move
(
aRhs
.
mStages
)
)
{
}
PerformanceRecorderImpl
&
operator
=
(
PerformanceRecorderImpl
&
&
)
=
delete
;
PerformanceRecorderImpl
(
const
PerformanceRecorderImpl
&
)
=
delete
;
PerformanceRecorderImpl
&
operator
=
(
const
PerformanceRecorderImpl
&
)
=
delete
;
protected
:
PerformanceRecorderImpl
(
)
=
default
;
template
<
typename
.
.
.
Args
>
void
Start
(
int64_t
aId
Args
.
.
.
aArgs
)
{
if
(
IsMeasurementEnabled
(
)
)
{
mStages
.
Push
(
MakeTuple
(
aId
GetCurrentTimeForMeasurement
(
)
StageType
(
std
:
:
move
(
aArgs
)
.
.
.
)
)
)
;
}
}
template
<
typename
F
>
float
Record
(
int64_t
aId
F
&
&
aStageMutator
)
{
while
(
!
mStages
.
IsEmpty
(
)
&
&
Get
<
0
>
(
mStages
.
Top
(
)
)
<
aId
)
{
mStages
.
Pop
(
)
;
}
if
(
mStages
.
IsEmpty
(
)
)
{
return
0
.
0
;
}
if
(
Get
<
0
>
(
mStages
.
Top
(
)
)
!
=
aId
)
{
return
0
.
0
;
}
Entry
entry
=
mStages
.
Pop
(
)
;
const
auto
&
startTime
=
Get
<
1
>
(
entry
)
;
auto
&
stage
=
Get
<
2
>
(
entry
)
;
MOZ_ASSERT
(
Get
<
0
>
(
entry
)
=
=
aId
)
;
double
elapsedTimeUs
=
0
.
0
;
if
(
!
startTime
.
IsNull
(
)
&
&
IsMeasurementEnabled
(
)
)
{
const
auto
now
=
TimeStamp
:
:
Now
(
)
;
elapsedTimeUs
=
(
now
-
startTime
)
.
ToMicroseconds
(
)
;
MOZ_ASSERT
(
elapsedTimeUs
>
=
0
"
Elapsed
time
can
'
t
be
less
than
0
!
"
)
;
aStageMutator
(
stage
)
;
AUTO_PROFILER_STATS
(
PROFILER_MARKER_UNTYPED
)
;
:
:
profiler_add_marker
(
stage
.
Name
(
)
stage
.
Category
(
)
MarkerOptions
(
MarkerTiming
:
:
Interval
(
startTime
now
)
)
)
;
}
return
static_cast
<
float
>
(
elapsedTimeUs
)
;
}
float
Record
(
int64_t
aId
)
{
return
Record
(
aId
[
]
(
auto
&
)
{
}
)
;
}
protected
:
using
Entry
=
Tuple
<
int64_t
TimeStamp
StageType
>
;
struct
IdComparator
{
bool
LessThan
(
const
Entry
&
aTupleA
const
Entry
&
aTupleB
)
{
return
Get
<
0
>
(
aTupleA
)
<
Get
<
0
>
(
aTupleB
)
;
}
}
;
nsTPriorityQueue
<
Entry
IdComparator
>
mStages
;
}
;
template
<
typename
StageType
>
class
PerformanceRecorder
:
public
PerformanceRecorderImpl
<
StageType
>
{
using
Super
=
PerformanceRecorderImpl
<
StageType
>
;
public
:
template
<
typename
.
.
.
Args
>
explicit
PerformanceRecorder
(
Args
.
.
.
aArgs
)
{
Start
(
std
:
:
move
(
aArgs
)
.
.
.
)
;
}
;
private
:
template
<
typename
.
.
.
Args
>
void
Start
(
Args
.
.
.
aArgs
)
{
Super
:
:
Start
(
0
std
:
:
move
(
aArgs
)
.
.
.
)
;
}
public
:
template
<
typename
F
>
float
Record
(
F
&
&
aStageMutator
)
{
return
Super
:
:
Record
(
0
std
:
:
forward
<
F
>
(
aStageMutator
)
)
;
}
float
Record
(
)
{
return
Super
:
:
Record
(
0
)
;
}
}
;
template
<
typename
StageType
>
class
PerformanceRecorderMulti
:
public
PerformanceRecorderImpl
<
StageType
>
{
using
Super
=
PerformanceRecorderImpl
<
StageType
>
;
public
:
PerformanceRecorderMulti
(
)
=
default
;
using
Super
:
:
Record
;
using
Super
:
:
Start
;
}
;
}
#
endif
