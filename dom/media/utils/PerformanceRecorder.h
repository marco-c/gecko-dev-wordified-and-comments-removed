#
ifndef
mozilla_PerformanceRecorder_h
#
define
mozilla_PerformanceRecorder_h
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BaseProfilerMarkersPrerequisites
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
ProfilerMarkerTypes
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTPriorityQueue
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
namespace
mozilla
{
namespace
gfx
{
enum
class
YUVColorSpace
:
uint8_t
;
enum
class
ColorDepth
:
uint8_t
;
enum
class
ColorRange
:
uint8_t
;
}
struct
TrackingId
{
enum
class
Source
:
uint8_t
{
Unimplemented
AudioDestinationNode
Camera
Canvas
ChannelDecoder
HLSDecoder
MediaCapabilities
MediaElementDecoder
MediaElementStream
MSEDecoder
RTCRtpReceiver
Screen
Tab
Window
LAST
}
;
enum
class
TrackAcrossProcesses
:
uint8_t
{
Yes
No
}
;
TrackingId
(
)
;
TrackingId
(
Source
aSource
uint32_t
aUniqueInProcId
TrackAcrossProcesses
aTrack
=
TrackAcrossProcesses
:
:
No
)
;
nsCString
ToString
(
)
const
;
Source
mSource
;
uint32_t
mUniqueInProcId
;
Maybe
<
uint32_t
>
mProcId
;
}
;
enum
class
MediaInfoFlag
:
uint16_t
{
None
=
(
0
<
<
0
)
NonKeyFrame
=
(
1
<
<
0
)
KeyFrame
=
(
1
<
<
1
)
SoftwareDecoding
=
(
1
<
<
2
)
HardwareDecoding
=
(
1
<
<
3
)
VIDEO_AV1
=
(
1
<
<
4
)
VIDEO_H264
=
(
1
<
<
5
)
VIDEO_VP8
=
(
1
<
<
6
)
VIDEO_VP9
=
(
1
<
<
7
)
VIDEO_THEORA
=
(
1
<
<
8
)
VIDEO_HEVC
=
(
1
<
<
9
)
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
MediaInfoFlag
)
enum
class
MediaStage
:
uint8_t
{
Invalid
RequestData
RequestDemux
CopyDemuxedData
RequestDecode
CopyDecodedVideo
}
;
class
StageBase
{
public
:
virtual
void
AddMarker
(
MarkerOptions
&
&
aOption
)
{
profiler_add_marker
(
Name
(
)
Category
(
)
std
:
:
forward
<
MarkerOptions
&
&
>
(
aOption
)
)
;
}
protected
:
virtual
ProfilerString8View
Name
(
)
const
=
0
;
virtual
const
MarkerCategory
&
Category
(
)
const
=
0
;
}
;
class
PlaybackStage
:
public
StageBase
{
public
:
explicit
PlaybackStage
(
MediaStage
aStage
int32_t
aHeight
=
0
MediaInfoFlag
aFlag
=
MediaInfoFlag
:
:
None
)
:
mStage
(
aStage
)
mHeight
(
aHeight
)
mFlag
(
aFlag
)
{
MOZ_ASSERT
(
aStage
!
=
MediaStage
:
:
Invalid
)
;
}
ProfilerString8View
Name
(
)
const
override
;
const
MarkerCategory
&
Category
(
)
const
override
{
return
baseprofiler
:
:
category
:
:
MEDIA_PLAYBACK
;
}
void
AddMarker
(
MarkerOptions
&
&
aOption
)
override
;
void
SetStartTimeAndEndTime
(
uint64_t
aStartTime
uint64_t
aEndTime
)
{
mStartAndEndTimeUs
=
Some
(
std
:
:
pair
<
uint64_t
uint64_t
>
{
aStartTime
aEndTime
}
)
;
}
MediaStage
mStage
;
int32_t
mHeight
;
MediaInfoFlag
mFlag
;
Maybe
<
std
:
:
pair
<
uint64_t
uint64_t
>
>
mStartAndEndTimeUs
;
private
:
mutable
Maybe
<
nsCString
>
mName
;
}
;
class
CaptureStage
:
public
StageBase
{
public
:
enum
class
ImageType
:
uint8_t
{
Unknown
I420
YUY2
YV12
UYVY
NV12
NV21
MJPEG
}
;
CaptureStage
(
nsCString
aSource
TrackingId
aTrackingId
int32_t
aWidth
int32_t
aHeight
ImageType
aImageType
)
:
mSource
(
std
:
:
move
(
aSource
)
)
mTrackingId
(
std
:
:
move
(
aTrackingId
)
)
mWidth
(
aWidth
)
mHeight
(
aHeight
)
mImageType
(
aImageType
)
{
}
ProfilerString8View
Name
(
)
const
override
;
const
MarkerCategory
&
Category
(
)
const
override
{
return
baseprofiler
:
:
category
:
:
MEDIA_RT
;
}
nsCString
mSource
;
TrackingId
mTrackingId
;
int32_t
mWidth
;
int32_t
mHeight
;
ImageType
mImageType
;
private
:
mutable
Maybe
<
nsCString
>
mName
;
}
;
class
CopyVideoStage
:
public
StageBase
{
public
:
CopyVideoStage
(
nsCString
aSource
TrackingId
aTrackingId
int32_t
aWidth
int32_t
aHeight
)
:
mSource
(
std
:
:
move
(
aSource
)
)
mTrackingId
(
std
:
:
move
(
aTrackingId
)
)
mWidth
(
aWidth
)
mHeight
(
aHeight
)
{
}
ProfilerString8View
Name
(
)
const
override
;
const
MarkerCategory
&
Category
(
)
const
override
{
return
baseprofiler
:
:
category
:
:
MEDIA_RT
;
}
nsCString
mSource
;
TrackingId
mTrackingId
;
int32_t
mWidth
;
int32_t
mHeight
;
private
:
mutable
Maybe
<
nsCString
>
mName
;
}
;
class
DecodeStage
:
public
StageBase
{
public
:
enum
ImageFormat
:
uint8_t
{
YUV420P
YUV422P
YUV444P
NV12
YV12
NV21
P010
P016
RGBA32
RGB24
GBRP
ANDROID_SURFACE
VAAPI_SURFACE
}
;
DecodeStage
(
nsCString
aSource
TrackingId
aTrackingId
MediaInfoFlag
aFlag
)
:
mSource
(
std
:
:
move
(
aSource
)
)
mTrackingId
(
std
:
:
move
(
aTrackingId
)
)
mFlag
(
aFlag
)
{
}
ProfilerString8View
Name
(
)
const
override
;
const
MarkerCategory
&
Category
(
)
const
override
{
return
baseprofiler
:
:
category
:
:
MEDIA_PLAYBACK
;
}
void
SetResolution
(
int
aWidth
int
aHeight
)
{
mWidth
=
Some
(
aWidth
)
;
mHeight
=
Some
(
aHeight
)
;
}
void
SetImageFormat
(
ImageFormat
aFormat
)
{
mImageFormat
=
Some
(
aFormat
)
;
}
void
SetYUVColorSpace
(
gfx
:
:
YUVColorSpace
aColorSpace
)
{
mYUVColorSpace
=
Some
(
aColorSpace
)
;
}
void
SetColorRange
(
gfx
:
:
ColorRange
aColorRange
)
{
mColorRange
=
Some
(
aColorRange
)
;
}
void
SetColorDepth
(
gfx
:
:
ColorDepth
aColorDepth
)
{
mColorDepth
=
Some
(
aColorDepth
)
;
}
void
SetStartTimeAndEndTime
(
uint64_t
aStartTime
uint64_t
aEndTime
)
{
mStartAndEndTimeUs
=
Some
(
std
:
:
pair
<
uint64_t
uint64_t
>
{
aStartTime
aEndTime
}
)
;
}
void
AddMarker
(
MarkerOptions
&
&
aOption
)
override
;
nsCString
mSource
;
TrackingId
mTrackingId
;
MediaInfoFlag
mFlag
;
Maybe
<
int
>
mWidth
;
Maybe
<
int
>
mHeight
;
Maybe
<
ImageFormat
>
mImageFormat
;
Maybe
<
gfx
:
:
YUVColorSpace
>
mYUVColorSpace
;
Maybe
<
gfx
:
:
ColorRange
>
mColorRange
;
Maybe
<
gfx
:
:
ColorDepth
>
mColorDepth
;
mutable
Maybe
<
nsCString
>
mName
;
Maybe
<
std
:
:
pair
<
uint64_t
uint64_t
>
>
mStartAndEndTimeUs
;
}
;
class
PerformanceRecorderBase
{
public
:
static
bool
IsMeasurementEnabled
(
)
;
static
TimeStamp
GetCurrentTimeForMeasurement
(
)
;
static
const
char
*
FindMediaResolution
(
int32_t
aHeight
)
;
protected
:
static
inline
bool
sEnableMeasurementForTesting
=
false
;
}
;
template
<
typename
StageType
>
class
PerformanceRecorderImpl
:
public
PerformanceRecorderBase
{
public
:
~
PerformanceRecorderImpl
(
)
=
default
;
PerformanceRecorderImpl
(
PerformanceRecorderImpl
&
&
aRhs
)
noexcept
:
mStages
(
std
:
:
move
(
aRhs
.
mStages
)
)
{
}
PerformanceRecorderImpl
&
operator
=
(
PerformanceRecorderImpl
&
&
)
=
delete
;
PerformanceRecorderImpl
(
const
PerformanceRecorderImpl
&
)
=
delete
;
PerformanceRecorderImpl
&
operator
=
(
const
PerformanceRecorderImpl
&
)
=
delete
;
protected
:
PerformanceRecorderImpl
(
)
=
default
;
template
<
typename
.
.
.
Args
>
void
Start
(
int64_t
aId
Args
.
.
.
aArgs
)
{
if
(
IsMeasurementEnabled
(
)
)
{
MutexAutoLock
lock
(
mMutex
)
;
mStages
.
Push
(
std
:
:
make_tuple
(
aId
GetCurrentTimeForMeasurement
(
)
StageType
(
std
:
:
move
(
aArgs
)
.
.
.
)
)
)
;
}
}
template
<
typename
F
>
float
Record
(
int64_t
aId
F
&
&
aStageMutator
)
{
Maybe
<
Entry
>
entry
;
{
MutexAutoLock
lock
(
mMutex
)
;
while
(
!
mStages
.
IsEmpty
(
)
&
&
std
:
:
get
<
0
>
(
mStages
.
Top
(
)
)
<
aId
)
{
mStages
.
Pop
(
)
;
}
if
(
mStages
.
IsEmpty
(
)
)
{
return
0
.
0
;
}
if
(
std
:
:
get
<
0
>
(
mStages
.
Top
(
)
)
!
=
aId
)
{
return
0
.
0
;
}
entry
=
Some
(
mStages
.
Pop
(
)
)
;
}
const
auto
&
startTime
=
std
:
:
get
<
1
>
(
*
entry
)
;
auto
&
stage
=
std
:
:
get
<
2
>
(
*
entry
)
;
MOZ_ASSERT
(
std
:
:
get
<
0
>
(
*
entry
)
=
=
aId
)
;
double
elapsedTimeUs
=
0
.
0
;
if
(
!
startTime
.
IsNull
(
)
&
&
IsMeasurementEnabled
(
)
)
{
const
auto
now
=
TimeStamp
:
:
Now
(
)
;
elapsedTimeUs
=
(
now
-
startTime
)
.
ToMicroseconds
(
)
;
MOZ_ASSERT
(
elapsedTimeUs
>
=
0
"
Elapsed
time
can
'
t
be
less
than
0
!
"
)
;
aStageMutator
(
stage
)
;
AUTO_PROFILER_STATS
(
PROFILER_MARKER_UNTYPED
)
;
stage
.
AddMarker
(
MarkerOptions
(
MarkerTiming
:
:
Interval
(
startTime
now
)
)
)
;
}
return
static_cast
<
float
>
(
elapsedTimeUs
)
;
}
float
Record
(
int64_t
aId
)
{
return
Record
(
aId
[
]
(
auto
&
)
{
}
)
;
}
protected
:
using
Entry
=
std
:
:
tuple
<
int64_t
TimeStamp
StageType
>
;
struct
IdComparator
{
bool
LessThan
(
const
Entry
&
aTupleA
const
Entry
&
aTupleB
)
{
return
std
:
:
get
<
0
>
(
aTupleA
)
<
std
:
:
get
<
0
>
(
aTupleB
)
;
}
}
;
Mutex
mMutex
{
"
PerformanceRecorder
:
:
mMutex
"
}
;
nsTPriorityQueue
<
Entry
IdComparator
>
mStages
MOZ_GUARDED_BY
(
mMutex
)
;
}
;
template
<
typename
StageType
>
class
PerformanceRecorder
:
public
PerformanceRecorderImpl
<
StageType
>
{
using
Super
=
PerformanceRecorderImpl
<
StageType
>
;
public
:
template
<
typename
.
.
.
Args
>
explicit
PerformanceRecorder
(
Args
.
.
.
aArgs
)
{
Start
(
std
:
:
move
(
aArgs
)
.
.
.
)
;
}
;
private
:
template
<
typename
.
.
.
Args
>
void
Start
(
Args
.
.
.
aArgs
)
{
Super
:
:
Start
(
0
std
:
:
move
(
aArgs
)
.
.
.
)
;
}
public
:
template
<
typename
F
>
float
Record
(
F
&
&
aStageMutator
)
{
return
Super
:
:
Record
(
0
std
:
:
forward
<
F
>
(
aStageMutator
)
)
;
}
float
Record
(
)
{
return
Super
:
:
Record
(
0
)
;
}
}
;
template
<
typename
StageType
>
class
PerformanceRecorderMulti
:
public
PerformanceRecorderImpl
<
StageType
>
{
using
Super
=
PerformanceRecorderImpl
<
StageType
>
;
public
:
PerformanceRecorderMulti
(
)
=
default
;
using
Super
:
:
Record
;
using
Super
:
:
Start
;
}
;
}
#
endif
