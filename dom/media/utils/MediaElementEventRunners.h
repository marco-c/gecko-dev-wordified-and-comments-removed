#
ifndef
mozilla_media_mediaelementeventrunners_h
#
define
mozilla_media_mediaelementeventrunners_h
#
include
"
mozilla
/
dom
/
PlayPromise
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTString
.
h
"
namespace
mozilla
:
:
dom
{
class
HTMLMediaElement
;
class
nsMediaEventRunner
:
public
nsIRunnable
public
nsINamed
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
nsMediaEventRunner
nsIRunnable
)
explicit
nsMediaEventRunner
(
const
nsAString
&
aName
HTMLMediaElement
*
aElement
const
nsAString
&
aEventName
=
u
"
unknown
"
_ns
)
;
void
Cancel
(
)
{
mElement
=
nullptr
;
}
NS_IMETHODIMP
GetName
(
nsACString
&
aName
)
override
{
aName
=
NS_ConvertUTF16toUTF8
(
mName
)
.
get
(
)
;
return
NS_OK
;
}
nsString
Name
(
)
const
{
return
mName
;
}
nsString
EventName
(
)
const
{
return
mEventName
;
}
protected
:
virtual
~
nsMediaEventRunner
(
)
=
default
;
bool
IsCancelled
(
)
const
;
nsresult
DispatchEvent
(
const
nsAString
&
aName
)
;
virtual
void
ReportProfilerMarker
(
)
;
uint64_t
GetElementDurationMs
(
)
const
;
RefPtr
<
HTMLMediaElement
>
mElement
;
nsString
mName
;
nsString
mEventName
;
uint32_t
mLoadID
;
}
;
class
nsAsyncEventRunner
:
public
nsMediaEventRunner
{
public
:
nsAsyncEventRunner
(
const
nsAString
&
aEventName
HTMLMediaElement
*
aElement
)
:
nsMediaEventRunner
(
u
"
nsAsyncEventRunner
"
_ns
aElement
aEventName
)
{
}
NS_IMETHOD
Run
(
)
override
;
}
;
class
nsResolveOrRejectPendingPlayPromisesRunner
:
public
nsMediaEventRunner
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
nsResolveOrRejectPendingPlayPromisesRunner
nsMediaEventRunner
)
nsResolveOrRejectPendingPlayPromisesRunner
(
HTMLMediaElement
*
aElement
nsTArray
<
RefPtr
<
PlayPromise
>
>
&
&
aPromises
nsresult
aError
=
NS_OK
)
;
void
ResolveOrReject
(
)
;
NS_IMETHOD
Run
(
)
override
;
protected
:
virtual
~
nsResolveOrRejectPendingPlayPromisesRunner
(
)
=
default
;
private
:
nsTArray
<
RefPtr
<
PlayPromise
>
>
mPromises
;
nsresult
mError
;
}
;
class
nsNotifyAboutPlayingRunner
:
public
nsResolveOrRejectPendingPlayPromisesRunner
{
public
:
nsNotifyAboutPlayingRunner
(
HTMLMediaElement
*
aElement
nsTArray
<
RefPtr
<
PlayPromise
>
>
&
&
aPendingPlayPromises
)
:
nsResolveOrRejectPendingPlayPromisesRunner
(
aElement
std
:
:
move
(
aPendingPlayPromises
)
)
{
}
NS_IMETHOD
Run
(
)
override
;
}
;
class
nsSourceErrorEventRunner
:
public
nsMediaEventRunner
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
nsSourceErrorEventRunner
nsMediaEventRunner
)
nsSourceErrorEventRunner
(
HTMLMediaElement
*
aElement
nsIContent
*
aSource
const
nsACString
&
aErrorDetails
)
:
nsMediaEventRunner
(
u
"
nsSourceErrorEventRunner
"
_ns
aElement
)
mSource
(
aSource
)
mErrorDetails
(
NS_ConvertUTF8toUTF16
(
aErrorDetails
)
)
{
}
NS_IMETHOD
Run
(
)
override
;
private
:
virtual
~
nsSourceErrorEventRunner
(
)
=
default
;
nsCOMPtr
<
nsIContent
>
mSource
;
const
nsString
mErrorDetails
;
}
;
class
nsTimeupdateRunner
:
public
nsMediaEventRunner
{
public
:
nsTimeupdateRunner
(
HTMLMediaElement
*
aElement
bool
aIsMandatory
)
:
nsMediaEventRunner
(
u
"
nsTimeupdateRunner
"
_ns
aElement
u
"
timeupdate
"
_ns
)
mIsMandatory
(
aIsMandatory
)
{
}
NS_IMETHOD
Run
(
)
override
;
private
:
void
ReportProfilerMarker
(
)
override
;
bool
ShouldDispatchTimeupdate
(
)
const
;
bool
mIsMandatory
;
}
;
}
#
endif
