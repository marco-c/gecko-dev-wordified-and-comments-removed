const
TEST_VIDEO_1
=
"
http
:
/
/
mochi
.
test
:
8888
/
tests
/
dom
/
media
/
test
/
bipbop_225w_175kbps
.
mp4
"
;
const
TEST_VIDEO_2
=
"
http
:
/
/
mochi
.
test
:
8888
/
tests
/
dom
/
media
/
test
/
pixel_aspect_ratio
.
mp4
"
;
const
LONG_VIDEO
=
"
http
:
/
/
mochi
.
test
:
8888
/
tests
/
dom
/
media
/
test
/
gizmo
.
mp4
"
;
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
media
.
test
.
video
-
suspend
"
true
]
[
"
media
.
suspend
-
bkgnd
-
video
.
enabled
"
true
]
[
"
media
.
suspend
-
bkgnd
-
video
.
delay
-
ms
"
500
]
[
"
media
.
dormant
-
on
-
pause
-
timeout
-
ms
"
0
]
[
"
media
.
cloneElementVisually
.
testing
"
true
]
]
}
)
;
let
originalVideo
=
document
.
getElementById
(
"
original
"
)
;
await
setVideoSrc
(
originalVideo
TEST_VIDEO_1
)
;
}
function
getWrappedScaledCanvasContext
(
canvas
width
height
)
{
let
devRatio
=
window
.
devicePixelRatio
|
|
1
;
let
ctx
=
SpecialPowers
.
wrap
(
canvas
.
getContext
(
"
2d
"
)
)
;
let
backingRatio
=
ctx
.
webkitBackingStorePixelRatio
|
|
1
;
let
ratio
=
1
;
ratio
=
devRatio
/
backingRatio
;
canvas
.
width
=
ratio
*
width
;
canvas
.
height
=
ratio
*
height
;
canvas
.
style
.
width
=
width
+
"
px
"
;
canvas
.
style
.
height
=
height
+
"
px
"
;
ctx
.
scale
(
ratio
ratio
)
;
return
ctx
;
}
function
captureFrameImageData
(
video
)
{
let
rect
=
video
.
getBoundingClientRect
(
)
;
let
width
=
video
.
videoWidth
;
let
height
=
video
.
videoHeight
;
let
canvas
=
document
.
createElement
(
"
canvas
"
)
;
let
ctx
=
getWrappedScaledCanvasContext
(
canvas
width
height
)
;
ctx
.
drawWindow
(
window
rect
.
left
rect
.
top
width
height
"
rgb
(
0
0
0
)
"
)
;
return
ctx
.
getImageData
(
0
0
width
height
)
;
}
async
function
assertVideosMatch
(
video1
video2
)
{
let
video1Frame
=
captureFrameImageData
(
video1
)
;
let
video2Frame
=
captureFrameImageData
(
video2
)
;
let
left
=
document
.
getElementById
(
"
left
"
)
;
let
leftCtx
=
getWrappedScaledCanvasContext
(
left
video1Frame
.
width
video1Frame
.
height
)
;
leftCtx
.
putImageData
(
video1Frame
0
0
)
;
let
right
=
document
.
getElementById
(
"
right
"
)
;
let
rightCtx
=
getWrappedScaledCanvasContext
(
right
video2Frame
.
width
video2Frame
.
height
)
;
rightCtx
.
putImageData
(
video2Frame
0
0
)
;
if
(
video1Frame
.
data
.
length
!
=
video2Frame
.
data
.
length
)
{
return
false
;
}
let
leftDataURL
=
left
.
toDataURL
(
)
;
let
rightDataURL
=
right
.
toDataURL
(
)
;
if
(
leftDataURL
!
=
rightDataURL
)
{
dump
(
"
Left
frame
:
"
+
leftDataURL
+
"
\
n
\
n
"
)
;
dump
(
"
Right
frame
:
"
+
rightDataURL
+
"
\
n
\
n
"
)
;
return
false
;
}
return
true
;
}
async
function
withNewClone
(
video
asyncFn
)
{
let
clone
=
video
.
cloneNode
(
)
;
clone
.
id
=
"
clone
"
;
clone
.
src
=
"
"
;
let
content
=
document
.
getElementById
(
"
content
"
)
;
content
.
appendChild
(
clone
)
;
try
{
await
asyncFn
(
clone
)
;
}
finally
{
clone
.
remove
(
)
;
}
}
async
function
setVideoSrc
(
video
src
)
{
let
promiseReady
=
waitForEventOnce
(
video
"
canplay
"
)
;
video
.
src
=
src
;
await
promiseReady
;
}
function
waitForEventOnce
(
target
event
)
{
return
new
Promise
(
resolve
=
>
{
target
.
addEventListener
(
event
resolve
{
once
:
true
}
)
;
}
)
;
}
function
waitForShutdownDecoder
(
video
)
{
return
SimpleTest
.
promiseWaitForCondition
(
async
(
)
=
>
{
let
readerData
=
await
SpecialPowers
.
wrap
(
video
)
.
mozRequestDebugInfo
(
)
;
return
readerData
.
decoder
.
reader
.
audioDecoderName
=
=
"
shutdown
"
;
}
"
Video
decoder
should
eventually
shut
down
.
"
)
;
}
async
function
ensureVideoSuspendable
(
video
)
{
video
=
SpecialPowers
.
wrap
(
video
)
;
ok
(
!
video
.
hasSuspendTaint
(
)
"
Should
be
suspendable
"
)
;
let
suspendPromise
=
waitForEventOnce
(
video
"
mozentervideosuspend
"
)
;
video
.
setVisible
(
false
)
;
await
suspendPromise
;
ok
(
true
"
Suspended
after
the
video
was
made
invisible
.
"
)
;
video
.
setVisible
(
true
)
;
ok
(
!
video
.
hasSuspendTaint
(
)
"
Should
still
be
suspendable
.
"
)
;
await
video
.
pause
(
)
;
await
waitForShutdownDecoder
(
video
)
;
ok
(
true
"
Shutdown
decoder
after
the
video
was
paused
.
"
)
;
await
video
.
play
(
)
;
}
