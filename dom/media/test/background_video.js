"
use
strict
"
;
function
startTest
(
test
)
{
info
(
test
.
desc
)
;
SimpleTest
.
waitForExplicitFinish
(
)
;
SpecialPowers
.
pushPrefEnv
(
{
set
:
test
.
prefs
}
(
)
=
>
{
manager
.
runTests
(
test
.
tests
test
.
runTest
)
;
}
)
;
}
function
nextVideoEnded
(
video
)
{
return
nextEvent
(
video
"
ended
"
)
;
}
function
nextVideoPlaying
(
video
)
{
return
nextEvent
(
video
"
playing
"
)
;
}
function
nextVideoResumes
(
video
)
{
return
nextEvent
(
video
"
mozexitvideosuspend
"
)
;
}
function
nextVideoSuspends
(
video
)
{
return
nextEvent
(
video
"
mozentervideosuspend
"
)
;
}
function
appendVideoToDoc
(
url
token
width
height
)
{
if
(
width
=
=
=
undefined
)
{
width
=
160
;
}
if
(
height
=
=
=
undefined
)
{
height
=
(
3
*
width
)
/
4
;
}
let
v
=
document
.
createElement
(
"
video
"
)
;
v
.
token
=
token
;
v
.
width
=
width
;
v
.
height
=
height
;
v
.
src
=
url
;
document
.
body
.
appendChild
(
v
)
;
return
v
;
}
function
appendVideoToDocWithoutLoad
(
token
width
height
)
{
if
(
width
=
=
=
undefined
)
{
width
=
160
;
}
if
(
height
=
=
=
undefined
)
{
height
=
(
3
*
width
)
/
4
;
}
let
v
=
document
.
createElement
(
"
video
"
)
;
v
.
token
=
token
;
document
.
body
.
appendChild
(
v
)
;
v
.
width
=
width
;
v
.
height
=
height
;
return
v
;
}
function
loadAndWaitUntilLoadedmetadata
(
video
url
preloadType
=
"
metadata
"
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
video
.
preload
=
preloadType
;
video
.
addEventListener
(
"
loadedmetadata
"
(
)
=
>
{
resolve
(
)
;
}
true
)
;
video
.
src
=
url
;
}
)
;
}
function
waitUntilVisible
(
video
)
{
let
videoChrome
=
SpecialPowers
.
wrap
(
video
)
;
if
(
videoChrome
.
isInViewPort
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
videoChrome
.
addEventListener
(
"
visibilitychanged
"
(
)
=
>
{
if
(
videoChrome
.
isInViewPort
)
{
ok
(
true
{
video
.
token
}
is
visible
.
)
;
videoChrome
.
removeEventListener
(
"
visibilitychanged
"
this
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
function
waitUntilPlaying
(
video
)
{
var
p
=
once
(
video
"
playing
"
(
)
=
>
{
ok
(
true
{
video
.
token
}
played
.
)
;
}
)
;
Log
(
video
.
token
"
Start
playing
"
)
;
video
.
play
(
)
;
return
p
;
}
function
waitUntilEnded
(
video
)
{
Log
(
video
.
token
"
Waiting
for
ended
"
)
;
if
(
video
.
ended
)
{
ok
(
true
video
.
token
+
"
already
ended
"
)
;
return
Promise
.
resolve
(
)
;
}
return
once
(
video
"
ended
"
(
)
=
>
{
ok
(
true
{
video
.
token
}
ended
)
;
}
)
;
}
function
testSuspendTimerStartedWhenHidden
(
video
)
{
var
p
=
once
(
video
"
mozstartvideosuspendtimer
"
)
.
then
(
(
)
=
>
{
ok
(
true
{
video
.
token
}
suspend
begins
)
;
}
)
;
Log
(
video
.
token
"
Set
Hidden
"
)
;
video
.
setVisible
(
false
)
;
return
p
;
}
function
testVideoSuspendsWhenHidden
(
video
)
{
let
p
=
once
(
video
"
mozentervideosuspend
"
)
.
then
(
(
)
=
>
{
ok
(
true
{
video
.
token
}
suspends
)
;
}
)
;
Log
(
video
.
token
"
Set
hidden
"
)
;
video
.
setVisible
(
false
)
;
return
p
;
}
function
testVideoResumesWhenShown
(
video
)
{
var
p
=
once
(
video
"
mozexitvideosuspend
"
)
.
then
(
(
)
=
>
{
ok
(
true
{
video
.
token
}
resumes
)
;
}
)
;
Log
(
video
.
token
"
Set
visible
"
)
;
video
.
setVisible
(
true
)
;
return
p
;
}
function
testVideoOnlySeekCompletedWhenShown
(
video
)
{
var
p
=
once
(
video
"
mozvideoonlyseekcompleted
"
)
.
then
(
(
)
=
>
{
ok
(
true
{
video
.
token
}
resumes
)
;
}
)
;
Log
(
video
.
token
"
Set
visible
"
)
;
video
.
setVisible
(
true
)
;
return
p
;
}
function
checkVideoDoesntSuspend
(
video
)
{
let
p
=
Promise
.
race
(
[
waitUntilEnded
(
video
)
.
then
(
(
)
=
>
{
ok
(
true
{
video
.
token
}
ended
before
decode
was
suspended
)
;
}
)
once
(
video
"
mozentervideosuspend
"
(
)
=
>
{
Promise
.
reject
(
new
Error
(
{
video
.
token
}
suspended
)
)
;
}
)
]
)
;
Log
(
video
.
token
"
Set
hidden
.
"
)
;
video
.
setVisible
(
false
)
;
return
p
;
}
function
waitTil
(
video
time
)
{
Log
(
video
.
token
Waiting
for
time
to
reach
{
time
}
s
)
;
return
new
Promise
(
resolve
=
>
{
video
.
addEventListener
(
"
timeupdate
"
function
timeUpdateEvent
(
)
{
if
(
video
.
currentTime
>
time
)
{
video
.
removeEventListener
(
name
timeUpdateEvent
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
