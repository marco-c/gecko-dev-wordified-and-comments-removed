"
use
strict
"
;
function
startTest
(
test
)
{
info
(
test
.
desc
)
;
SimpleTest
.
waitForExplicitFinish
(
)
;
SpecialPowers
.
pushPrefEnv
(
{
'
set
'
:
test
.
prefs
}
(
)
=
>
{
manager
.
runTests
(
test
.
tests
test
.
runTest
)
;
}
)
;
}
function
appendVideoToDoc
(
url
token
)
{
let
v
=
document
.
createElement
(
'
video
'
)
;
v
.
token
=
token
;
document
.
body
.
appendChild
(
v
)
;
v
.
src
=
url
;
return
v
;
}
function
waitUntilPlaying
(
video
)
{
var
p
=
once
(
video
'
playing
'
(
)
=
>
{
ok
(
true
video
.
token
+
"
played
.
"
)
;
}
)
;
Log
(
video
.
token
"
Start
playing
"
)
;
video
.
play
(
)
;
return
p
;
}
function
waitUntilEnded
(
video
)
{
Log
(
video
.
token
"
Waiting
for
ended
"
)
;
if
(
video
.
ended
)
{
ok
(
true
video
.
token
+
"
already
ended
"
)
;
return
Promise
.
success
(
)
;
}
return
once
(
video
'
ended
'
(
)
=
>
{
ok
(
true
video
.
token
+
"
ended
"
)
;
}
)
;
}
function
testVideoSuspendsWhenHidden
(
video
)
{
let
p
=
once
(
video
'
mozentervideosuspend
'
)
.
then
(
(
)
=
>
{
ok
(
true
video
.
token
+
"
suspends
"
)
;
}
)
;
Log
(
video
.
token
"
Set
hidden
"
)
;
video
.
setVisible
(
false
)
;
return
p
;
}
function
testVideoResumesWhenShown
(
video
)
{
var
p
=
once
(
video
'
mozexitvideosuspend
'
)
.
then
(
(
)
=
>
{
ok
(
true
video
.
token
+
"
resumes
"
)
;
}
)
;
Log
(
video
.
token
"
Set
visible
"
)
;
video
.
setVisible
(
true
)
;
return
p
;
}
function
checkVideoDoesntSuspend
(
video
)
{
let
p
=
Promise
.
race
(
[
waitUntilEnded
(
video
)
.
then
(
(
)
=
>
{
ok
(
true
video
.
token
+
'
ended
before
decode
was
suspended
'
)
}
)
once
(
video
'
mozentervideosuspend
'
(
)
=
>
{
Promise
.
reject
(
new
Error
(
video
.
token
+
'
suspended
'
)
)
}
)
]
)
;
Log
(
video
.
token
"
Set
hidden
.
"
)
;
video
.
setVisible
(
false
)
;
return
p
;
}
function
waitTil
(
video
time
)
{
Log
(
video
.
token
"
Waiting
for
time
to
reach
"
+
time
+
"
s
"
)
;
return
new
Promise
(
resolve
=
>
{
video
.
addEventListener
(
'
timeupdate
'
function
timeUpdateEvent
(
)
{
if
(
video
.
currentTime
>
time
)
{
video
.
removeEventListener
(
name
timeUpdateEvent
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
