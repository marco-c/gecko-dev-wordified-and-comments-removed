var
EmeHelper
=
class
EmeHelper
{
_keySystem
;
_initDataTypes
;
_audioCapabilities
=
[
]
;
_videoCapabilities
=
[
]
;
_keyMap
=
new
Map
(
)
;
onerror
;
static
GetClearkeyKeySystemString
(
)
{
return
"
org
.
w3
.
clearkey
"
;
}
static
Uint8ArrayToBase64
(
uint8Array
)
{
return
new
TextDecoder
(
)
.
decode
(
uint8Array
)
.
replace
(
/
\
+
/
g
"
-
"
)
.
replace
(
/
\
/
/
g
"
_
"
)
.
replace
(
/
=
*
/
"
"
)
;
}
static
HexToBase64
(
hexString
)
{
return
btoa
(
hexString
.
match
(
/
\
w
{
2
}
/
g
)
.
map
(
hexByte
=
>
String
.
fromCharCode
(
parseInt
(
hexByte
16
)
)
)
.
join
(
"
"
)
)
.
replace
(
/
\
+
/
g
"
-
"
)
.
replace
(
/
\
/
/
g
"
_
"
)
.
replace
(
/
=
*
/
"
"
)
;
}
static
Base64ToHex
(
base64String
)
{
let
binString
=
atob
(
base64String
.
replace
(
/
-
/
g
"
+
"
)
.
replace
(
/
_
/
g
"
/
"
)
)
;
let
hexString
=
"
"
;
for
(
let
i
=
0
;
i
<
binString
.
length
;
i
+
+
)
{
hexString
+
=
(
"
0
"
+
binString
.
charCodeAt
(
i
)
.
toString
(
16
)
)
.
substr
(
-
2
)
;
}
return
hexString
;
}
SetKeySystem
(
keySystem
)
{
this
.
_keySystem
=
keySystem
;
}
SetInitDataTypes
(
initDataTypes
)
{
this
.
_initDataTypes
=
initDataTypes
;
}
SetAudioCapabilities
(
audioCapabilities
)
{
this
.
_audioCapabilities
=
audioCapabilities
;
}
SetVideoCapabilities
(
videoCapabilities
)
{
this
.
_videoCapabilities
=
videoCapabilities
;
}
AddKeyIdAndKey
(
keyId
key
)
{
this
.
_keyMap
.
set
(
keyId
.
toLowerCase
(
)
key
.
toLowerCase
(
)
)
;
}
RemoveKeyIdAndKey
(
keyId
)
{
this
.
_keyMap
.
delete
(
keyId
)
;
}
_SessionMessageHandler
(
messageEvent
)
{
let
request
=
JSON
.
parse
(
new
TextDecoder
(
)
.
decode
(
messageEvent
.
message
)
)
;
let
keys
=
[
]
;
for
(
const
keyId
of
request
.
kids
)
{
let
id64
=
keyId
;
let
idHex
=
EmeHelper
.
Base64ToHex
(
keyId
)
;
let
key
=
this
.
_keyMap
.
get
(
idHex
)
;
if
(
key
)
{
keys
.
push
(
{
kty
:
"
oct
"
kid
:
id64
k
:
EmeHelper
.
HexToBase64
(
key
)
}
)
;
}
}
let
license
=
new
TextEncoder
(
)
.
encode
(
JSON
.
stringify
(
{
keys
type
:
request
.
type
|
|
"
temporary
"
}
)
)
;
let
session
=
messageEvent
.
target
;
session
.
update
(
license
)
.
catch
(
error
=
>
{
if
(
this
.
onerror
)
{
this
.
onerror
(
error
)
;
}
else
{
console
.
log
(
EmeHelper
got
an
error
but
no
onerror
handler
was
registered
!
Logging
to
console
error
:
{
error
}
)
;
}
}
)
;
}
async
ConfigureEme
(
htmlMediaElement
)
{
if
(
!
this
.
_keySystem
)
{
throw
new
Error
(
"
EmeHelper
needs
_keySystem
to
configure
media
"
)
;
}
if
(
!
this
.
_initDataTypes
)
{
throw
new
Error
(
"
EmeHelper
needs
_initDataTypes
to
configure
media
"
)
;
}
if
(
!
this
.
_audioCapabilities
.
length
&
&
!
this
.
_videoCapabilities
.
length
)
{
throw
new
Error
(
"
EmeHelper
needs
_audioCapabilities
or
_videoCapabilities
to
configure
media
"
)
;
}
const
options
=
[
{
initDataTypes
:
this
.
_initDataTypes
audioCapabilities
:
this
.
_audioCapabilities
videoCapabilities
:
this
.
_videoCapabilities
}
]
;
let
access
=
await
window
.
navigator
.
requestMediaKeySystemAccess
(
this
.
_keySystem
options
)
;
let
mediaKeys
=
await
access
.
createMediaKeys
(
)
;
await
htmlMediaElement
.
setMediaKeys
(
mediaKeys
)
;
htmlMediaElement
.
onencrypted
=
async
encryptedEvent
=
>
{
let
session
=
htmlMediaElement
.
mediaKeys
.
createSession
(
)
;
session
.
onmessage
=
messageEvent
=
>
this
.
_SessionMessageHandler
(
messageEvent
)
;
try
{
await
session
.
generateRequest
(
encryptedEvent
.
initDataType
encryptedEvent
.
initData
)
;
}
catch
(
error
)
{
if
(
this
.
onerror
)
{
this
.
onerror
(
error
)
;
}
else
{
console
.
log
(
EmeHelper
got
an
error
but
no
onerror
handler
was
registered
!
Logging
to
console
error
:
{
error
}
)
;
}
}
}
;
}
}
;
