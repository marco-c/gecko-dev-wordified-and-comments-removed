#
ifndef
MOZILLA_MEDIASTREAMGRAPH_H_
#
define
MOZILLA_MEDIASTREAMGRAPH_H_
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
dom
/
AudioChannelBinding
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
AudioStream
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
StreamTracks
.
h
"
#
include
"
VideoFrameContainer
.
h
"
#
include
"
VideoSegment
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsAutoRef
.
h
"
#
include
<
speex
/
speex_resampler
.
h
>
#
include
"
DOMMediaStream
.
h
"
class
nsIRunnable
;
template
<
>
class
nsAutoRefTraits
<
SpeexResamplerState
>
:
public
nsPointerRefTraits
<
SpeexResamplerState
>
{
public
:
static
void
Release
(
SpeexResamplerState
*
aState
)
{
speex_resampler_destroy
(
aState
)
;
}
}
;
namespace
mozilla
{
extern
LazyLogModule
gMediaStreamGraphLog
;
namespace
dom
{
enum
class
AudioContextOperation
;
}
namespace
media
{
template
<
typename
V
typename
E
>
class
Pledge
;
}
class
MediaStreamGraph
;
class
MediaStreamListener
{
protected
:
virtual
~
MediaStreamListener
(
)
{
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaStreamListener
)
virtual
void
NotifyPull
(
MediaStreamGraph
*
aGraph
StreamTime
aDesiredTime
)
{
}
enum
Blocking
{
BLOCKED
UNBLOCKED
}
;
virtual
void
NotifyBlockingChanged
(
MediaStreamGraph
*
aGraph
Blocking
aBlocked
)
{
}
virtual
void
NotifyHasCurrentData
(
MediaStreamGraph
*
aGraph
)
{
}
virtual
void
NotifyOutput
(
MediaStreamGraph
*
aGraph
GraphTime
aCurrentTime
)
{
}
enum
MediaStreamGraphEvent
{
EVENT_FINISHED
EVENT_REMOVED
EVENT_HAS_DIRECT_LISTENERS
EVENT_HAS_NO_DIRECT_LISTENERS
}
;
virtual
void
NotifyEvent
(
MediaStreamGraph
*
aGraph
MediaStreamGraphEvent
aEvent
)
{
}
enum
{
TRACK_EVENT_CREATED
=
0x01
TRACK_EVENT_ENDED
=
0x02
}
;
virtual
void
NotifyQueuedTrackChanges
(
MediaStreamGraph
*
aGraph
TrackID
aID
StreamTime
aTrackOffset
uint32_t
aTrackEvents
const
MediaSegment
&
aQueuedMedia
MediaStream
*
aInputStream
=
nullptr
TrackID
aInputTrackID
=
TRACK_INVALID
)
{
}
virtual
void
NotifyFinishedTrackCreation
(
MediaStreamGraph
*
aGraph
)
{
}
}
;
class
AudioDataListenerInterface
{
protected
:
virtual
~
AudioDataListenerInterface
(
)
{
}
public
:
virtual
void
NotifyOutputData
(
MediaStreamGraph
*
aGraph
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
=
0
;
virtual
void
NotifyInputData
(
MediaStreamGraph
*
aGraph
const
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
=
0
;
virtual
void
DeviceChanged
(
)
=
0
;
}
;
class
AudioDataListener
:
public
AudioDataListenerInterface
{
protected
:
virtual
~
AudioDataListener
(
)
{
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AudioDataListener
)
}
;
class
MediaStreamTrackListener
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaStreamTrackListener
)
public
:
virtual
void
NotifyQueuedChanges
(
MediaStreamGraph
*
aGraph
StreamTime
aTrackOffset
const
MediaSegment
&
aQueuedMedia
)
{
}
virtual
void
NotifyPrincipalHandleChanged
(
MediaStreamGraph
*
aGraph
const
PrincipalHandle
&
aNewPrincipalHandle
)
{
}
virtual
void
NotifyEnded
(
)
{
}
virtual
void
NotifyRemoved
(
)
{
}
protected
:
virtual
~
MediaStreamTrackListener
(
)
{
}
}
;
class
MediaStreamDirectListener
:
public
MediaStreamListener
{
public
:
virtual
~
MediaStreamDirectListener
(
)
{
}
virtual
void
NotifyRealtimeData
(
MediaStreamGraph
*
aGraph
TrackID
aID
StreamTime
aTrackOffset
uint32_t
aTrackEvents
const
MediaSegment
&
aMedia
)
{
}
}
;
class
MediaStreamTrackDirectListener
:
public
MediaStreamTrackListener
{
friend
class
SourceMediaStream
;
friend
class
TrackUnionStream
;
public
:
virtual
void
NotifyRealtimeTrackData
(
MediaStreamGraph
*
aGraph
StreamTime
aTrackOffset
const
MediaSegment
&
aMedia
)
{
}
enum
class
InstallationResult
{
TRACK_NOT_FOUND_AT_SOURCE
TRACK_TYPE_NOT_SUPPORTED
STREAM_NOT_SUPPORTED
SUCCESS
}
;
virtual
void
NotifyDirectListenerInstalled
(
InstallationResult
aResult
)
{
}
virtual
void
NotifyDirectListenerUninstalled
(
)
{
}
protected
:
virtual
~
MediaStreamTrackDirectListener
(
)
{
}
void
MirrorAndDisableSegment
(
AudioSegment
&
aFrom
AudioSegment
&
aTo
)
{
aTo
.
Clear
(
)
;
aTo
.
AppendNullData
(
aFrom
.
GetDuration
(
)
)
;
}
void
NotifyRealtimeTrackDataAndApplyTrackDisabling
(
MediaStreamGraph
*
aGraph
StreamTime
aTrackOffset
MediaSegment
&
aMedia
)
{
if
(
mDisabledCount
=
=
0
)
{
NotifyRealtimeTrackData
(
aGraph
aTrackOffset
aMedia
)
;
return
;
}
if
(
!
mMedia
)
{
mMedia
=
aMedia
.
CreateEmptyClone
(
)
;
}
if
(
aMedia
.
GetType
(
)
=
=
MediaSegment
:
:
AUDIO
)
{
MirrorAndDisableSegment
(
static_cast
<
AudioSegment
&
>
(
aMedia
)
static_cast
<
AudioSegment
&
>
(
*
mMedia
)
)
;
}
else
{
MOZ_CRASH
(
"
Unsupported
media
type
"
)
;
}
NotifyRealtimeTrackData
(
aGraph
aTrackOffset
*
mMedia
)
;
}
void
IncreaseDisabled
(
)
{
+
+
mDisabledCount
;
}
void
DecreaseDisabled
(
)
{
-
-
mDisabledCount
;
MOZ_ASSERT
(
mDisabledCount
>
=
0
"
Double
decrease
"
)
;
}
Atomic
<
int32_t
>
mDisabledCount
;
nsAutoPtr
<
MediaSegment
>
mMedia
;
}
;
class
MainThreadMediaStreamListener
{
public
:
virtual
void
NotifyMainThreadStreamFinished
(
)
=
0
;
}
;
struct
AudioNodeSizes
{
AudioNodeSizes
(
)
:
mDomNode
(
0
)
mStream
(
0
)
mEngine
(
0
)
mNodeType
(
)
{
}
size_t
mDomNode
;
size_t
mStream
;
size_t
mEngine
;
nsCString
mNodeType
;
}
;
class
MediaStreamGraphImpl
;
class
SourceMediaStream
;
class
ProcessedMediaStream
;
class
MediaInputPort
;
class
AudioNodeEngine
;
class
AudioNodeExternalInputStream
;
class
AudioNodeStream
;
class
CameraPreviewMediaStream
;
template
<
typename
Listener
>
struct
TrackBound
{
RefPtr
<
Listener
>
mListener
;
TrackID
mTrackID
;
}
;
class
MediaStream
:
public
mozilla
:
:
LinkedListElement
<
MediaStream
>
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaStream
)
explicit
MediaStream
(
DOMMediaStream
*
aWrapper
)
;
protected
:
virtual
~
MediaStream
(
)
{
MOZ_COUNT_DTOR
(
MediaStream
)
;
NS_ASSERTION
(
mMainThreadDestroyed
"
Should
have
been
destroyed
already
"
)
;
NS_ASSERTION
(
mMainThreadListeners
.
IsEmpty
(
)
"
All
main
thread
listeners
should
have
been
removed
"
)
;
}
public
:
MediaStreamGraphImpl
*
GraphImpl
(
)
;
MediaStreamGraph
*
Graph
(
)
;
void
SetGraphImpl
(
MediaStreamGraphImpl
*
aGraph
)
;
void
SetGraphImpl
(
MediaStreamGraph
*
aGraph
)
;
TrackRate
GraphRate
(
)
{
return
mTracks
.
GraphRate
(
)
;
}
virtual
void
AddAudioOutput
(
void
*
aKey
)
;
virtual
void
SetAudioOutputVolume
(
void
*
aKey
float
aVolume
)
;
virtual
void
RemoveAudioOutput
(
void
*
aKey
)
;
virtual
void
AddVideoOutput
(
VideoFrameContainer
*
aContainer
)
;
virtual
void
RemoveVideoOutput
(
VideoFrameContainer
*
aContainer
)
;
virtual
void
Suspend
(
)
;
virtual
void
Resume
(
)
;
virtual
void
AddListener
(
MediaStreamListener
*
aListener
)
;
virtual
void
RemoveListener
(
MediaStreamListener
*
aListener
)
;
virtual
void
AddTrackListener
(
MediaStreamTrackListener
*
aListener
TrackID
aTrackID
)
;
virtual
void
RemoveTrackListener
(
MediaStreamTrackListener
*
aListener
TrackID
aTrackID
)
;
virtual
void
AddDirectTrackListener
(
MediaStreamTrackDirectListener
*
aListener
TrackID
aTrackID
)
;
virtual
void
RemoveDirectTrackListener
(
MediaStreamTrackDirectListener
*
aListener
TrackID
aTrackID
)
;
void
SetTrackEnabled
(
TrackID
aTrackID
bool
aEnabled
)
;
void
AddMainThreadListener
(
MainThreadMediaStreamListener
*
aListener
)
;
void
RemoveMainThreadListener
(
MainThreadMediaStreamListener
*
aListener
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aListener
)
;
mMainThreadListeners
.
RemoveElement
(
aListener
)
;
}
void
RunAfterPendingUpdates
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
virtual
void
Destroy
(
)
;
void
RegisterUser
(
)
;
void
UnregisterUser
(
)
;
StreamTime
GetCurrentTime
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
return
mMainThreadCurrentTime
;
}
bool
IsFinished
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
return
mMainThreadFinished
;
}
bool
IsDestroyed
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
return
mMainThreadDestroyed
;
}
friend
class
MediaStreamGraphImpl
;
friend
class
MediaInputPort
;
friend
class
AudioNodeExternalInputStream
;
virtual
SourceMediaStream
*
AsSourceStream
(
)
{
return
nullptr
;
}
virtual
ProcessedMediaStream
*
AsProcessedStream
(
)
{
return
nullptr
;
}
virtual
AudioNodeStream
*
AsAudioNodeStream
(
)
{
return
nullptr
;
}
virtual
void
DestroyImpl
(
)
;
StreamTime
GetTracksEnd
(
)
{
return
mTracks
.
GetEnd
(
)
;
}
#
ifdef
DEBUG
void
DumpTrackInfo
(
)
{
return
mTracks
.
DumpTrackInfo
(
)
;
}
#
endif
void
SetAudioOutputVolumeImpl
(
void
*
aKey
float
aVolume
)
;
void
AddAudioOutputImpl
(
void
*
aKey
)
;
bool
HasAudioOutput
(
)
{
return
!
mAudioOutputs
.
IsEmpty
(
)
;
}
void
RemoveAudioOutputImpl
(
void
*
aKey
)
;
void
AddVideoOutputImpl
(
already_AddRefed
<
VideoFrameContainer
>
aContainer
)
;
void
RemoveVideoOutputImpl
(
VideoFrameContainer
*
aContainer
)
;
void
AddListenerImpl
(
already_AddRefed
<
MediaStreamListener
>
aListener
)
;
void
RemoveListenerImpl
(
MediaStreamListener
*
aListener
)
;
void
RemoveAllListenersImpl
(
)
;
virtual
void
AddTrackListenerImpl
(
already_AddRefed
<
MediaStreamTrackListener
>
aListener
TrackID
aTrackID
)
;
virtual
void
RemoveTrackListenerImpl
(
MediaStreamTrackListener
*
aListener
TrackID
aTrackID
)
;
virtual
void
AddDirectTrackListenerImpl
(
already_AddRefed
<
MediaStreamTrackDirectListener
>
aListener
TrackID
aTrackID
)
;
virtual
void
RemoveDirectTrackListenerImpl
(
MediaStreamTrackDirectListener
*
aListener
TrackID
aTrackID
)
;
virtual
void
SetTrackEnabledImpl
(
TrackID
aTrackID
bool
aEnabled
)
;
void
AddConsumer
(
MediaInputPort
*
aPort
)
{
mConsumers
.
AppendElement
(
aPort
)
;
}
void
RemoveConsumer
(
MediaInputPort
*
aPort
)
{
mConsumers
.
RemoveElement
(
aPort
)
;
}
uint32_t
ConsumerCount
(
)
{
return
mConsumers
.
Length
(
)
;
}
StreamTracks
&
GetStreamTracks
(
)
{
return
mTracks
;
}
GraphTime
GetStreamTracksStartTime
(
)
{
return
mTracksStartTime
;
}
double
StreamTimeToSeconds
(
StreamTime
aTime
)
{
NS_ASSERTION
(
0
<
=
aTime
&
&
aTime
<
=
STREAM_TIME_MAX
"
Bad
time
"
)
;
return
static_cast
<
double
>
(
aTime
)
/
mTracks
.
GraphRate
(
)
;
}
int64_t
StreamTimeToMicroseconds
(
StreamTime
aTime
)
{
NS_ASSERTION
(
0
<
=
aTime
&
&
aTime
<
=
STREAM_TIME_MAX
"
Bad
time
"
)
;
return
(
aTime
*
1000000
)
/
mTracks
.
GraphRate
(
)
;
}
StreamTime
SecondsToNearestStreamTime
(
double
aSeconds
)
{
NS_ASSERTION
(
0
<
=
aSeconds
&
&
aSeconds
<
=
TRACK_TICKS_MAX
/
TRACK_RATE_MAX
"
Bad
seconds
"
)
;
return
mTracks
.
GraphRate
(
)
*
aSeconds
+
0
.
5
;
}
StreamTime
MicrosecondsToStreamTimeRoundDown
(
int64_t
aMicroseconds
)
{
return
(
aMicroseconds
*
mTracks
.
GraphRate
(
)
)
/
1000000
;
}
TrackTicks
TimeToTicksRoundUp
(
TrackRate
aRate
StreamTime
aTime
)
{
return
RateConvertTicksRoundUp
(
aRate
mTracks
.
GraphRate
(
)
aTime
)
;
}
StreamTime
TicksToTimeRoundDown
(
TrackRate
aRate
TrackTicks
aTicks
)
{
return
RateConvertTicksRoundDown
(
mTracks
.
GraphRate
(
)
aRate
aTicks
)
;
}
StreamTime
GraphTimeToStreamTimeWithBlocking
(
GraphTime
aTime
)
;
StreamTime
GraphTimeToStreamTime
(
GraphTime
aTime
)
;
GraphTime
StreamTimeToGraphTime
(
StreamTime
aTime
)
;
bool
IsFinishedOnGraphThread
(
)
{
return
mFinished
;
}
void
FinishOnGraphThread
(
)
;
bool
HasCurrentData
(
)
{
return
mHasCurrentData
;
}
StreamTracks
:
:
Track
*
FindTrack
(
TrackID
aID
)
;
StreamTracks
:
:
Track
*
EnsureTrack
(
TrackID
aTrack
)
;
virtual
void
ApplyTrackDisabling
(
TrackID
aTrackID
MediaSegment
*
aSegment
MediaSegment
*
aRawSegment
=
nullptr
)
;
DOMMediaStream
*
GetWrapper
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
use
DOMMediaStream
on
main
thread
"
)
;
return
mWrapper
;
}
virtual
bool
MainThreadNeedsUpdates
(
)
const
{
return
true
;
}
virtual
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
virtual
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
void
SetAudioChannelType
(
dom
:
:
AudioChannel
aType
)
{
mAudioChannelType
=
aType
;
}
dom
:
:
AudioChannel
AudioChannelType
(
)
const
{
return
mAudioChannelType
;
}
bool
IsSuspended
(
)
{
return
mSuspendedCount
>
0
;
}
void
IncrementSuspendCount
(
)
{
+
+
mSuspendedCount
;
}
void
DecrementSuspendCount
(
)
{
NS_ASSERTION
(
mSuspendedCount
>
0
"
Suspend
count
underrun
"
)
;
-
-
mSuspendedCount
;
}
protected
:
void
AdvanceTimeVaryingValuesToCurrentTime
(
GraphTime
aCurrentTime
GraphTime
aBlockedTime
)
{
mTracksStartTime
+
=
aBlockedTime
;
mTracks
.
ForgetUpTo
(
aCurrentTime
-
mTracksStartTime
)
;
}
void
NotifyMainThreadListeners
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
for
(
int32_t
i
=
mMainThreadListeners
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
mMainThreadListeners
[
i
]
-
>
NotifyMainThreadStreamFinished
(
)
;
}
mMainThreadListeners
.
Clear
(
)
;
}
bool
ShouldNotifyStreamFinished
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
if
(
!
mMainThreadFinished
|
|
mFinishedNotificationSent
)
{
return
false
;
}
mFinishedNotificationSent
=
true
;
return
true
;
}
StreamTracks
mTracks
;
GraphTime
mTracksStartTime
;
struct
AudioOutput
{
explicit
AudioOutput
(
void
*
aKey
)
:
mKey
(
aKey
)
mVolume
(
1
.
0f
)
{
}
void
*
mKey
;
float
mVolume
;
}
;
nsTArray
<
AudioOutput
>
mAudioOutputs
;
nsTArray
<
RefPtr
<
VideoFrameContainer
>
>
mVideoOutputs
;
VideoFrame
mLastPlayedVideoFrame
;
nsTArray
<
RefPtr
<
MediaStreamListener
>
>
mListeners
;
nsTArray
<
TrackBound
<
MediaStreamTrackListener
>
>
mTrackListeners
;
nsTArray
<
MainThreadMediaStreamListener
*
>
mMainThreadListeners
;
nsTArray
<
TrackID
>
mDisabledTrackIDs
;
GraphTime
mStartBlocking
;
nsTArray
<
MediaInputPort
*
>
mConsumers
;
struct
AudioOutputStream
{
GraphTime
mAudioPlaybackStartTime
;
MediaTime
mBlockedAudioTime
;
StreamTime
mLastTickWritten
;
TrackID
mTrackID
;
}
;
nsTArray
<
AudioOutputStream
>
mAudioOutputStreams
;
int32_t
mSuspendedCount
;
bool
mFinished
;
bool
mNotifiedFinished
;
bool
mNotifiedBlocked
;
bool
mHasCurrentData
;
bool
mNotifiedHasCurrentData
;
DOMMediaStream
*
mWrapper
;
StreamTime
mMainThreadCurrentTime
;
bool
mMainThreadFinished
;
bool
mFinishedNotificationSent
;
bool
mMainThreadDestroyed
;
int
mNrOfMainThreadUsers
;
MediaStreamGraphImpl
*
mGraph
;
dom
:
:
AudioChannel
mAudioChannelType
;
}
;
class
SourceMediaStream
:
public
MediaStream
{
public
:
explicit
SourceMediaStream
(
DOMMediaStream
*
aWrapper
)
:
MediaStream
(
aWrapper
)
mMutex
(
"
mozilla
:
:
media
:
:
SourceMediaStream
"
)
mUpdateKnownTracksTime
(
0
)
mPullEnabled
(
false
)
mUpdateFinished
(
false
)
mNeedsMixing
(
false
)
{
}
SourceMediaStream
*
AsSourceStream
(
)
override
{
return
this
;
}
nsresult
OpenAudioInput
(
int
aID
AudioDataListener
*
aListener
)
;
void
CloseAudioInput
(
)
;
void
DestroyImpl
(
)
override
;
void
SetPullEnabled
(
bool
aEnabled
)
;
void
NotifyListenersEventImpl
(
MediaStreamListener
:
:
MediaStreamGraphEvent
aEvent
)
;
void
NotifyListenersEvent
(
MediaStreamListener
:
:
MediaStreamGraphEvent
aEvent
)
;
void
AddDirectListener
(
MediaStreamDirectListener
*
aListener
)
;
void
RemoveDirectListener
(
MediaStreamDirectListener
*
aListener
)
;
enum
{
ADDTRACK_QUEUED
=
0x01
}
;
void
AddTrack
(
TrackID
aID
StreamTime
aStart
MediaSegment
*
aSegment
uint32_t
aFlags
=
0
)
{
AddTrackInternal
(
aID
GraphRate
(
)
aStart
aSegment
aFlags
)
;
}
void
AddAudioTrack
(
TrackID
aID
TrackRate
aRate
StreamTime
aStart
AudioSegment
*
aSegment
uint32_t
aFlags
=
0
)
{
AddTrackInternal
(
aID
aRate
aStart
aSegment
aFlags
)
;
}
void
FinishAddTracks
(
)
;
bool
AppendToTrack
(
TrackID
aID
MediaSegment
*
aSegment
MediaSegment
*
aRawSegment
=
nullptr
)
;
StreamTime
GetEndOfAppendedData
(
TrackID
aID
)
;
void
EndTrack
(
TrackID
aID
)
;
void
AdvanceKnownTracksTime
(
StreamTime
aKnownTime
)
;
void
FinishWithLockHeld
(
)
;
void
Finish
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
FinishWithLockHeld
(
)
;
}
void
SetTrackEnabledImpl
(
TrackID
aTrackID
bool
aEnabled
)
override
;
void
ApplyTrackDisabling
(
TrackID
aTrackID
MediaSegment
*
aSegment
MediaSegment
*
aRawSegment
=
nullptr
)
override
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
MediaStream
:
:
ApplyTrackDisabling
(
aTrackID
aSegment
aRawSegment
)
;
}
void
EndAllTrackAndFinish
(
)
;
void
RegisterForAudioMixing
(
)
;
friend
class
MediaStreamGraphImpl
;
protected
:
enum
TrackCommands
{
TRACK_CREATE
=
MediaStreamListener
:
:
TRACK_EVENT_CREATED
TRACK_END
=
MediaStreamListener
:
:
TRACK_EVENT_ENDED
}
;
struct
TrackData
{
TrackID
mID
;
TrackRate
mInputRate
;
nsAutoRef
<
SpeexResamplerState
>
mResampler
;
int
mResamplerChannelCount
;
StreamTime
mStart
;
StreamTime
mEndOfFlushedData
;
nsAutoPtr
<
MediaSegment
>
mData
;
uint32_t
mCommands
;
}
;
bool
NeedsMixing
(
)
;
void
ResampleAudioToGraphSampleRate
(
TrackData
*
aTrackData
MediaSegment
*
aSegment
)
;
void
AddDirectTrackListenerImpl
(
already_AddRefed
<
MediaStreamTrackDirectListener
>
aListener
TrackID
aTrackID
)
override
;
void
RemoveDirectTrackListenerImpl
(
MediaStreamTrackDirectListener
*
aListener
TrackID
aTrackID
)
override
;
void
AddTrackInternal
(
TrackID
aID
TrackRate
aRate
StreamTime
aStart
MediaSegment
*
aSegment
uint32_t
aFlags
)
;
TrackData
*
FindDataForTrack
(
TrackID
aID
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mUpdateTracks
.
Length
(
)
;
+
+
i
)
{
if
(
mUpdateTracks
[
i
]
.
mID
=
=
aID
)
{
return
&
mUpdateTracks
[
i
]
;
}
}
return
nullptr
;
}
void
NotifyDirectConsumers
(
TrackData
*
aTrack
MediaSegment
*
aSegment
)
;
RefPtr
<
AudioDataListener
>
mInputListener
;
Mutex
mMutex
;
StreamTime
mUpdateKnownTracksTime
;
nsTArray
<
TrackData
>
mUpdateTracks
;
nsTArray
<
TrackData
>
mPendingTracks
;
nsTArray
<
RefPtr
<
MediaStreamDirectListener
>
>
mDirectListeners
;
nsTArray
<
TrackBound
<
MediaStreamTrackDirectListener
>
>
mDirectTrackListeners
;
bool
mPullEnabled
;
bool
mUpdateFinished
;
bool
mNeedsMixing
;
}
;
class
MediaInputPort
final
{
private
:
MediaInputPort
(
MediaStream
*
aSource
TrackID
&
aSourceTrack
ProcessedMediaStream
*
aDest
TrackID
&
aDestTrack
uint16_t
aInputNumber
uint16_t
aOutputNumber
)
:
mSource
(
aSource
)
mSourceTrack
(
aSourceTrack
)
mDest
(
aDest
)
mDestTrack
(
aDestTrack
)
mInputNumber
(
aInputNumber
)
mOutputNumber
(
aOutputNumber
)
mGraph
(
nullptr
)
{
MOZ_COUNT_CTOR
(
MediaInputPort
)
;
}
~
MediaInputPort
(
)
{
MOZ_COUNT_DTOR
(
MediaInputPort
)
;
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaInputPort
)
void
Init
(
)
;
void
Disconnect
(
)
;
void
Destroy
(
)
;
MediaStream
*
GetSource
(
)
{
return
mSource
;
}
TrackID
GetSourceTrackId
(
)
{
return
mSourceTrack
;
}
ProcessedMediaStream
*
GetDestination
(
)
{
return
mDest
;
}
TrackID
GetDestinationTrackId
(
)
{
return
mDestTrack
;
}
already_AddRefed
<
media
:
:
Pledge
<
bool
nsresult
>
>
BlockSourceTrackId
(
TrackID
aTrackId
)
;
private
:
void
BlockSourceTrackIdImpl
(
TrackID
aTrackId
)
;
public
:
bool
PassTrackThrough
(
TrackID
aTrackId
)
{
return
!
mBlockedTracks
.
Contains
(
aTrackId
)
&
&
(
mSourceTrack
=
=
TRACK_ANY
|
|
mSourceTrack
=
=
aTrackId
)
;
}
uint16_t
InputNumber
(
)
const
{
return
mInputNumber
;
}
uint16_t
OutputNumber
(
)
const
{
return
mOutputNumber
;
}
struct
InputInterval
{
GraphTime
mStart
;
GraphTime
mEnd
;
bool
mInputIsBlocked
;
}
;
InputInterval
GetNextInputInterval
(
GraphTime
aTime
)
;
MediaStreamGraphImpl
*
GraphImpl
(
)
;
MediaStreamGraph
*
Graph
(
)
;
void
SetGraphImpl
(
MediaStreamGraphImpl
*
aGraph
)
;
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
0
;
return
amount
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
private
:
friend
class
MediaStreamGraphImpl
;
friend
class
MediaStream
;
friend
class
ProcessedMediaStream
;
MediaStream
*
mSource
;
TrackID
mSourceTrack
;
ProcessedMediaStream
*
mDest
;
TrackID
mDestTrack
;
const
uint16_t
mInputNumber
;
const
uint16_t
mOutputNumber
;
nsTArray
<
TrackID
>
mBlockedTracks
;
MediaStreamGraphImpl
*
mGraph
;
}
;
class
ProcessedMediaStream
:
public
MediaStream
{
public
:
explicit
ProcessedMediaStream
(
DOMMediaStream
*
aWrapper
)
:
MediaStream
(
aWrapper
)
mAutofinish
(
false
)
mCycleMarker
(
0
)
{
}
already_AddRefed
<
MediaInputPort
>
AllocateInputPort
(
MediaStream
*
aStream
TrackID
aTrackID
=
TRACK_ANY
TrackID
aDestTrackID
=
TRACK_ANY
uint16_t
aInputNumber
=
0
uint16_t
aOutputNumber
=
0
nsTArray
<
TrackID
>
*
aBlockedTracks
=
nullptr
)
;
void
Finish
(
)
;
void
SetAutofinish
(
bool
aAutofinish
)
;
ProcessedMediaStream
*
AsProcessedStream
(
)
override
{
return
this
;
}
friend
class
MediaStreamGraphImpl
;
virtual
void
AddInput
(
MediaInputPort
*
aPort
)
;
virtual
void
RemoveInput
(
MediaInputPort
*
aPort
)
{
mInputs
.
RemoveElement
(
aPort
)
;
}
bool
HasInputPort
(
MediaInputPort
*
aPort
)
{
return
mInputs
.
Contains
(
aPort
)
;
}
uint32_t
InputPortCount
(
)
{
return
mInputs
.
Length
(
)
;
}
void
DestroyImpl
(
)
override
;
enum
{
ALLOW_FINISH
=
0x01
}
;
virtual
void
ProcessInput
(
GraphTime
aFrom
GraphTime
aTo
uint32_t
aFlags
)
=
0
;
void
SetAutofinishImpl
(
bool
aAutofinish
)
{
mAutofinish
=
aAutofinish
;
}
bool
InMutedCycle
(
)
const
{
return
mCycleMarker
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
size_t
amount
=
MediaStream
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
mInputs
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
protected
:
nsTArray
<
MediaInputPort
*
>
mInputs
;
bool
mAutofinish
;
uint32_t
mCycleMarker
;
}
;
class
MediaStreamGraph
{
public
:
enum
GraphDriverType
{
AUDIO_THREAD_DRIVER
SYSTEM_THREAD_DRIVER
OFFLINE_THREAD_DRIVER
}
;
static
MediaStreamGraph
*
GetInstance
(
GraphDriverType
aGraphDriverRequested
dom
:
:
AudioChannel
aChannel
)
;
static
MediaStreamGraph
*
CreateNonRealtimeInstance
(
TrackRate
aSampleRate
)
;
static
void
DestroyNonRealtimeInstance
(
MediaStreamGraph
*
aGraph
)
;
virtual
nsresult
OpenAudioInput
(
int
aID
AudioDataListener
*
aListener
)
{
return
NS_ERROR_FAILURE
;
}
virtual
void
CloseAudioInput
(
AudioDataListener
*
aListener
)
{
}
SourceMediaStream
*
CreateSourceStream
(
DOMMediaStream
*
aWrapper
)
;
ProcessedMediaStream
*
CreateTrackUnionStream
(
DOMMediaStream
*
aWrapper
)
;
ProcessedMediaStream
*
CreateAudioCaptureStream
(
DOMMediaStream
*
aWrapper
TrackID
aTrackId
)
;
void
AddStream
(
MediaStream
*
aStream
)
;
void
NotifyWhenGraphStarted
(
AudioNodeStream
*
aNodeStream
)
;
void
ApplyAudioContextOperation
(
MediaStream
*
aDestinationStream
const
nsTArray
<
MediaStream
*
>
&
aStreams
dom
:
:
AudioContextOperation
aState
void
*
aPromise
)
;
bool
IsNonRealtime
(
)
const
;
void
StartNonRealtimeProcessing
(
uint32_t
aTicksToProcess
)
;
virtual
void
DispatchToMainThreadAfterStreamStateUpdate
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
*
mPendingUpdateRunnables
.
AppendElement
(
)
=
aRunnable
;
}
TrackRate
GraphRate
(
)
const
{
return
mSampleRate
;
}
void
RegisterCaptureStreamForWindow
(
uint64_t
aWindowId
ProcessedMediaStream
*
aCaptureStream
)
;
void
UnregisterCaptureStreamForWindow
(
uint64_t
aWindowId
)
;
already_AddRefed
<
MediaInputPort
>
ConnectToCaptureStream
(
uint64_t
aWindowId
MediaStream
*
aMediaStream
)
;
void
NotifyOutputData
(
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
;
protected
:
explicit
MediaStreamGraph
(
TrackRate
aSampleRate
)
:
mSampleRate
(
aSampleRate
)
{
MOZ_COUNT_CTOR
(
MediaStreamGraph
)
;
}
virtual
~
MediaStreamGraph
(
)
{
MOZ_COUNT_DTOR
(
MediaStreamGraph
)
;
}
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mPendingUpdateRunnables
;
TrackRate
mSampleRate
;
nsTArray
<
AudioDataListener
*
>
mAudioInputs
;
}
;
}
#
endif
