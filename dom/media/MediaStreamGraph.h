#
ifndef
MOZILLA_MEDIASTREAMGRAPH_H_
#
define
MOZILLA_MEDIASTREAMGRAPH_H_
#
include
"
AudioStream
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
MediaSegment
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
StateWatching
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsAutoRef
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsTArray
.
h
"
#
include
<
speex
/
speex_resampler
.
h
>
class
nsIRunnable
;
class
nsIGlobalObject
;
class
nsPIDOMWindowInner
;
namespace
mozilla
{
class
AsyncLogger
;
class
AudioCaptureStream
;
}
;
extern
mozilla
:
:
AsyncLogger
gMSGTraceLogger
;
template
<
>
class
nsAutoRefTraits
<
SpeexResamplerState
>
:
public
nsPointerRefTraits
<
SpeexResamplerState
>
{
public
:
static
void
Release
(
SpeexResamplerState
*
aState
)
{
speex_resampler_destroy
(
aState
)
;
}
}
;
namespace
mozilla
{
extern
LazyLogModule
gMediaStreamGraphLog
;
namespace
dom
{
enum
class
AudioContextOperation
;
enum
class
AudioContextOperationFlags
;
}
inline
TrackTicks
RateConvertTicksRoundDown
(
TrackRate
aOutRate
TrackRate
aInRate
TrackTicks
aTicks
)
{
MOZ_ASSERT
(
0
<
aOutRate
&
&
aOutRate
<
=
TRACK_RATE_MAX
"
Bad
out
rate
"
)
;
MOZ_ASSERT
(
0
<
aInRate
&
&
aInRate
<
=
TRACK_RATE_MAX
"
Bad
in
rate
"
)
;
MOZ_ASSERT
(
0
<
=
aTicks
&
&
aTicks
<
=
TRACK_TICKS_MAX
"
Bad
ticks
"
)
;
return
(
aTicks
*
aOutRate
)
/
aInRate
;
}
inline
TrackTicks
RateConvertTicksRoundUp
(
TrackRate
aOutRate
TrackRate
aInRate
TrackTicks
aTicks
)
{
MOZ_ASSERT
(
0
<
aOutRate
&
&
aOutRate
<
=
TRACK_RATE_MAX
"
Bad
out
rate
"
)
;
MOZ_ASSERT
(
0
<
aInRate
&
&
aInRate
<
=
TRACK_RATE_MAX
"
Bad
in
rate
"
)
;
MOZ_ASSERT
(
0
<
=
aTicks
&
&
aTicks
<
=
TRACK_TICKS_MAX
"
Bad
ticks
"
)
;
return
(
aTicks
*
aOutRate
+
aInRate
-
1
)
/
aInRate
;
}
class
AudioNodeEngine
;
class
AudioNodeExternalInputStream
;
class
AudioNodeStream
;
class
MediaInputPort
;
class
MediaStream
;
class
MediaStreamGraph
;
class
MediaStreamGraphImpl
;
class
ProcessedMediaStream
;
class
SourceMediaStream
;
class
AudioDataListenerInterface
{
protected
:
virtual
~
AudioDataListenerInterface
(
)
=
default
;
public
:
virtual
void
NotifyOutputData
(
MediaStreamGraphImpl
*
aGraph
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
=
0
;
virtual
void
NotifyInputData
(
MediaStreamGraphImpl
*
aGraph
const
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
=
0
;
virtual
uint32_t
RequestedInputChannelCount
(
MediaStreamGraphImpl
*
aGraph
)
=
0
;
virtual
bool
IsVoiceInput
(
MediaStreamGraphImpl
*
aGraph
)
const
=
0
;
virtual
void
DeviceChanged
(
MediaStreamGraphImpl
*
aGraph
)
=
0
;
virtual
void
Disconnect
(
MediaStreamGraphImpl
*
aGraph
)
=
0
;
}
;
class
AudioDataListener
:
public
AudioDataListenerInterface
{
protected
:
virtual
~
AudioDataListener
(
)
=
default
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AudioDataListener
)
}
;
class
MainThreadMediaStreamListener
{
public
:
virtual
void
NotifyMainThreadTrackEnded
(
)
=
0
;
}
;
struct
AudioNodeSizes
{
AudioNodeSizes
(
)
:
mStream
(
0
)
mEngine
(
0
)
mNodeType
(
)
{
}
size_t
mStream
;
size_t
mEngine
;
const
char
*
mNodeType
;
}
;
enum
class
DisabledTrackMode
{
ENABLED
SILENCE_BLACK
SILENCE_FREEZE
}
;
class
AudioNodeEngine
;
class
AudioNodeExternalInputStream
;
class
AudioNodeStream
;
class
DirectMediaStreamTrackListener
;
class
MediaInputPort
;
class
MediaStreamGraphImpl
;
class
MediaStreamTrackListener
;
class
ProcessedMediaStream
;
class
SourceMediaStream
;
class
TrackUnionStream
;
class
MediaStream
:
public
mozilla
:
:
LinkedListElement
<
MediaStream
>
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaStream
)
MediaStream
(
TrackRate
aSampleRate
MediaSegment
:
:
Type
aType
MediaSegment
*
aSegment
)
;
const
TrackRate
mSampleRate
;
const
MediaSegment
:
:
Type
mType
;
protected
:
virtual
~
MediaStream
(
)
;
public
:
MediaStreamGraphImpl
*
GraphImpl
(
)
;
const
MediaStreamGraphImpl
*
GraphImpl
(
)
const
;
MediaStreamGraph
*
Graph
(
)
;
const
MediaStreamGraph
*
Graph
(
)
const
;
void
SetGraphImpl
(
MediaStreamGraphImpl
*
aGraph
)
;
void
SetGraphImpl
(
MediaStreamGraph
*
aGraph
)
;
virtual
void
AddAudioOutput
(
void
*
aKey
)
;
virtual
void
SetAudioOutputVolume
(
void
*
aKey
float
aVolume
)
;
virtual
void
RemoveAudioOutput
(
void
*
aKey
)
;
virtual
void
Suspend
(
)
;
virtual
void
Resume
(
)
;
virtual
void
AddListener
(
MediaStreamTrackListener
*
aListener
)
;
virtual
void
RemoveListener
(
MediaStreamTrackListener
*
aListener
)
;
virtual
void
AddDirectListener
(
DirectMediaStreamTrackListener
*
aListener
)
;
virtual
void
RemoveDirectListener
(
DirectMediaStreamTrackListener
*
aListener
)
;
void
SetEnabled
(
DisabledTrackMode
aMode
)
;
void
AddMainThreadListener
(
MainThreadMediaStreamListener
*
aListener
)
;
void
RemoveMainThreadListener
(
MainThreadMediaStreamListener
*
aListener
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aListener
)
;
mMainThreadListeners
.
RemoveElement
(
aListener
)
;
}
void
RunAfterPendingUpdates
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
virtual
void
Destroy
(
)
;
StreamTime
GetCurrentTime
(
)
const
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
return
mMainThreadCurrentTime
;
}
bool
IsEnded
(
)
const
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
return
mMainThreadEnded
;
}
bool
IsDestroyed
(
)
const
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
return
mMainThreadDestroyed
;
}
friend
class
MediaStreamGraphImpl
;
friend
class
MediaInputPort
;
friend
class
AudioNodeExternalInputStream
;
virtual
SourceMediaStream
*
AsSourceStream
(
)
{
return
nullptr
;
}
virtual
ProcessedMediaStream
*
AsProcessedStream
(
)
{
return
nullptr
;
}
virtual
AudioNodeStream
*
AsAudioNodeStream
(
)
{
return
nullptr
;
}
virtual
TrackUnionStream
*
AsTrackUnionStream
(
)
{
return
nullptr
;
}
virtual
void
DestroyImpl
(
)
;
StreamTime
GetEnd
(
)
const
;
void
SetAudioOutputVolumeImpl
(
void
*
aKey
float
aVolume
)
;
void
AddAudioOutputImpl
(
void
*
aKey
)
;
void
RemoveAudioOutputImpl
(
void
*
aKey
)
;
virtual
void
RemoveAllDirectListenersImpl
(
)
{
}
void
RemoveAllResourcesAndListenersImpl
(
)
;
virtual
void
AddListenerImpl
(
already_AddRefed
<
MediaStreamTrackListener
>
aListener
)
;
virtual
void
RemoveListenerImpl
(
MediaStreamTrackListener
*
aListener
)
;
virtual
void
AddDirectListenerImpl
(
already_AddRefed
<
DirectMediaStreamTrackListener
>
aListener
)
;
virtual
void
RemoveDirectListenerImpl
(
DirectMediaStreamTrackListener
*
aListener
)
;
virtual
void
SetEnabledImpl
(
DisabledTrackMode
aMode
)
;
void
AddConsumer
(
MediaInputPort
*
aPort
)
{
mConsumers
.
AppendElement
(
aPort
)
;
}
void
RemoveConsumer
(
MediaInputPort
*
aPort
)
{
mConsumers
.
RemoveElement
(
aPort
)
;
}
GraphTime
StartTime
(
)
const
{
return
mStartTime
;
}
bool
Ended
(
)
const
{
return
mEnded
;
}
template
<
class
SegmentType
>
SegmentType
*
GetData
(
)
const
{
if
(
!
mSegment
)
{
return
nullptr
;
}
if
(
mSegment
-
>
GetType
(
)
!
=
SegmentType
:
:
StaticType
(
)
)
{
return
nullptr
;
}
return
static_cast
<
SegmentType
*
>
(
mSegment
.
get
(
)
)
;
}
template
<
>
MediaSegment
*
GetData
<
MediaSegment
>
(
)
const
{
return
mSegment
.
get
(
)
;
}
double
StreamTimeToSeconds
(
StreamTime
aTime
)
const
{
NS_ASSERTION
(
0
<
=
aTime
&
&
aTime
<
=
STREAM_TIME_MAX
"
Bad
time
"
)
;
return
static_cast
<
double
>
(
aTime
)
/
mSampleRate
;
}
int64_t
StreamTimeToMicroseconds
(
StreamTime
aTime
)
const
{
NS_ASSERTION
(
0
<
=
aTime
&
&
aTime
<
=
STREAM_TIME_MAX
"
Bad
time
"
)
;
return
(
aTime
*
1000000
)
/
mSampleRate
;
}
StreamTime
SecondsToNearestStreamTime
(
double
aSeconds
)
const
{
NS_ASSERTION
(
0
<
=
aSeconds
&
&
aSeconds
<
=
TRACK_TICKS_MAX
/
TRACK_RATE_MAX
"
Bad
seconds
"
)
;
return
mSampleRate
*
aSeconds
+
0
.
5
;
}
StreamTime
MicrosecondsToStreamTimeRoundDown
(
int64_t
aMicroseconds
)
const
{
return
(
aMicroseconds
*
mSampleRate
)
/
1000000
;
}
TrackTicks
TimeToTicksRoundUp
(
TrackRate
aRate
StreamTime
aTime
)
const
{
return
RateConvertTicksRoundUp
(
aRate
mSampleRate
aTime
)
;
}
StreamTime
TicksToTimeRoundDown
(
TrackRate
aRate
TrackTicks
aTicks
)
const
{
return
RateConvertTicksRoundDown
(
mSampleRate
aRate
aTicks
)
;
}
StreamTime
GraphTimeToStreamTimeWithBlocking
(
GraphTime
aTime
)
const
;
StreamTime
GraphTimeToStreamTime
(
GraphTime
aTime
)
const
;
GraphTime
StreamTimeToGraphTime
(
StreamTime
aTime
)
const
;
virtual
void
ApplyTrackDisabling
(
MediaSegment
*
aSegment
MediaSegment
*
aRawSegment
=
nullptr
)
;
virtual
bool
MainThreadNeedsUpdates
(
)
const
{
return
true
;
}
virtual
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
virtual
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
bool
IsSuspended
(
)
const
{
return
mSuspendedCount
>
0
;
}
void
IncrementSuspendCount
(
)
;
void
DecrementSuspendCount
(
)
;
protected
:
virtual
void
NotifyForcedShutdown
(
)
{
}
virtual
void
AdvanceTimeVaryingValuesToCurrentTime
(
GraphTime
aCurrentTime
GraphTime
aBlockedTime
)
;
void
NotifyMainThreadListeners
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
for
(
int32_t
i
=
mMainThreadListeners
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
mMainThreadListeners
[
i
]
-
>
NotifyMainThreadTrackEnded
(
)
;
}
mMainThreadListeners
.
Clear
(
)
;
}
bool
ShouldNotifyTrackEnded
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
if
(
!
mMainThreadEnded
|
|
mEndedNotificationSent
)
{
return
false
;
}
mEndedNotificationSent
=
true
;
return
true
;
}
const
UniquePtr
<
MediaSegment
>
mSegment
;
GraphTime
mStartTime
;
StreamTime
mForgottenTime
;
bool
mEnded
;
bool
mNotifiedEnded
;
struct
AudioOutput
{
explicit
AudioOutput
(
void
*
aKey
)
:
mKey
(
aKey
)
mVolume
(
1
.
0f
)
{
}
void
*
mKey
;
float
mVolume
;
}
;
nsTArray
<
AudioOutput
>
mAudioOutputs
;
nsTArray
<
RefPtr
<
MediaStreamTrackListener
>
>
mTrackListeners
;
nsTArray
<
MainThreadMediaStreamListener
*
>
mMainThreadListeners
;
DisabledTrackMode
mDisabledMode
;
GraphTime
mStartBlocking
;
nsTArray
<
MediaInputPort
*
>
mConsumers
;
struct
AudioOutputStream
{
GraphTime
mAudioPlaybackStartTime
;
MediaTime
mBlockedAudioTime
;
StreamTime
mLastTickWritten
;
}
;
UniquePtr
<
AudioOutputStream
>
mAudioOutputStream
;
int32_t
mSuspendedCount
;
StreamTime
mMainThreadCurrentTime
;
bool
mMainThreadEnded
;
bool
mEndedNotificationSent
;
bool
mMainThreadDestroyed
;
MediaStreamGraphImpl
*
mGraph
;
}
;
class
SourceMediaStream
:
public
MediaStream
{
public
:
SourceMediaStream
(
MediaSegment
:
:
Type
aType
TrackRate
aSampleRate
)
;
SourceMediaStream
*
AsSourceStream
(
)
override
{
return
this
;
}
void
SetPullingEnabled
(
bool
aEnabled
)
;
nsresult
OpenAudioInput
(
CubebUtils
:
:
AudioDeviceID
aID
AudioDataListener
*
aListener
)
;
void
CloseAudioInput
(
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
&
aID
)
;
void
Destroy
(
)
override
;
void
DestroyImpl
(
)
override
;
bool
PullNewData
(
GraphTime
aDesiredUpToTime
)
;
void
ExtractPendingInput
(
GraphTime
aCurrentTime
GraphTime
aDesiredUpToTime
)
;
void
SetAppendDataSourceRate
(
TrackRate
aRate
)
;
virtual
StreamTime
AppendData
(
MediaSegment
*
aSegment
MediaSegment
*
aRawSegment
=
nullptr
)
;
void
End
(
)
;
void
SetEnabledImpl
(
DisabledTrackMode
aMode
)
override
;
void
ApplyTrackDisabling
(
MediaSegment
*
aSegment
MediaSegment
*
aRawSegment
=
nullptr
)
override
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
MediaStream
:
:
ApplyTrackDisabling
(
aSegment
aRawSegment
)
;
}
void
RemoveAllDirectListenersImpl
(
)
override
;
friend
class
MediaStreamGraphImpl
;
protected
:
enum
TrackCommands
:
uint32_t
;
virtual
~
SourceMediaStream
(
)
;
struct
TrackData
{
TrackRate
mInputRate
;
nsAutoRef
<
SpeexResamplerState
>
mResampler
;
int
mResamplerChannelCount
;
UniquePtr
<
MediaSegment
>
mData
;
bool
mEnded
;
bool
mPullingEnabled
;
}
;
bool
NeedsMixing
(
)
;
void
ResampleAudioToGraphSampleRate
(
MediaSegment
*
aSegment
)
;
void
AddDirectListenerImpl
(
already_AddRefed
<
DirectMediaStreamTrackListener
>
aListener
)
override
;
void
RemoveDirectListenerImpl
(
DirectMediaStreamTrackListener
*
aListener
)
override
;
void
NotifyDirectConsumers
(
MediaSegment
*
aSegment
)
;
virtual
void
AdvanceTimeVaryingValuesToCurrentTime
(
GraphTime
aCurrentTime
GraphTime
aBlockedTime
)
override
;
RefPtr
<
AudioDataListener
>
mInputListener
;
Mutex
mMutex
;
UniquePtr
<
TrackData
>
mUpdateTrack
;
nsTArray
<
RefPtr
<
DirectMediaStreamTrackListener
>
>
mDirectTrackListeners
;
}
;
struct
SharedDummyStream
{
NS_INLINE_DECL_REFCOUNTING
(
SharedDummyStream
)
explicit
SharedDummyStream
(
MediaStream
*
aStream
)
:
mStream
(
aStream
)
{
mStream
-
>
Suspend
(
)
;
}
const
RefPtr
<
MediaStream
>
mStream
;
private
:
~
SharedDummyStream
(
)
{
mStream
-
>
Destroy
(
)
;
}
}
;
class
MediaInputPort
final
{
private
:
MediaInputPort
(
MediaStream
*
aSource
ProcessedMediaStream
*
aDest
uint16_t
aInputNumber
uint16_t
aOutputNumber
)
:
mSource
(
aSource
)
mDest
(
aDest
)
mInputNumber
(
aInputNumber
)
mOutputNumber
(
aOutputNumber
)
mGraph
(
nullptr
)
{
MOZ_COUNT_CTOR
(
MediaInputPort
)
;
}
~
MediaInputPort
(
)
{
MOZ_COUNT_DTOR
(
MediaInputPort
)
;
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaInputPort
)
void
Init
(
)
;
void
Disconnect
(
)
;
void
Destroy
(
)
;
MediaStream
*
GetSource
(
)
const
{
return
mSource
;
}
ProcessedMediaStream
*
GetDestination
(
)
const
{
return
mDest
;
}
uint16_t
InputNumber
(
)
const
{
return
mInputNumber
;
}
uint16_t
OutputNumber
(
)
const
{
return
mOutputNumber
;
}
struct
InputInterval
{
GraphTime
mStart
;
GraphTime
mEnd
;
bool
mInputIsBlocked
;
}
;
static
InputInterval
GetNextInputInterval
(
MediaInputPort
const
*
aPort
GraphTime
aTime
)
;
MediaStreamGraphImpl
*
GraphImpl
(
)
;
MediaStreamGraph
*
Graph
(
)
;
void
SetGraphImpl
(
MediaStreamGraphImpl
*
aGraph
)
;
void
Suspended
(
)
;
void
Resumed
(
)
;
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
0
;
return
amount
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
private
:
friend
class
MediaStreamGraphImpl
;
friend
class
MediaStream
;
friend
class
ProcessedMediaStream
;
MediaStream
*
mSource
;
ProcessedMediaStream
*
mDest
;
const
uint16_t
mInputNumber
;
const
uint16_t
mOutputNumber
;
MediaStreamGraphImpl
*
mGraph
;
}
;
class
ProcessedMediaStream
:
public
MediaStream
{
public
:
ProcessedMediaStream
(
TrackRate
aSampleRate
MediaSegment
:
:
Type
aType
MediaSegment
*
aSegment
)
:
MediaStream
(
aSampleRate
aType
aSegment
)
mAutoend
(
true
)
mCycleMarker
(
0
)
{
}
already_AddRefed
<
MediaInputPort
>
AllocateInputPort
(
MediaStream
*
aStream
uint16_t
aInputNumber
=
0
uint16_t
aOutputNumber
=
0
)
;
void
QueueSetAutoend
(
bool
aAutoend
)
;
ProcessedMediaStream
*
AsProcessedStream
(
)
override
{
return
this
;
}
friend
class
MediaStreamGraphImpl
;
virtual
void
AddInput
(
MediaInputPort
*
aPort
)
;
virtual
void
RemoveInput
(
MediaInputPort
*
aPort
)
{
mInputs
.
RemoveElement
(
aPort
)
|
|
mSuspendedInputs
.
RemoveElement
(
aPort
)
;
}
bool
HasInputPort
(
MediaInputPort
*
aPort
)
const
{
return
mInputs
.
Contains
(
aPort
)
|
|
mSuspendedInputs
.
Contains
(
aPort
)
;
}
uint32_t
InputPortCount
(
)
const
{
return
mInputs
.
Length
(
)
+
mSuspendedInputs
.
Length
(
)
;
}
void
InputSuspended
(
MediaInputPort
*
aPort
)
;
void
InputResumed
(
MediaInputPort
*
aPort
)
;
void
DestroyImpl
(
)
override
;
enum
{
ALLOW_END
=
0x01
}
;
virtual
void
ProcessInput
(
GraphTime
aFrom
GraphTime
aTo
uint32_t
aFlags
)
=
0
;
void
SetAutoendImpl
(
bool
aAutoend
)
{
mAutoend
=
aAutoend
;
}
bool
InMutedCycle
(
)
const
{
return
mCycleMarker
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
size_t
amount
=
MediaStream
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
mInputs
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
mSuspendedInputs
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
protected
:
nsTArray
<
MediaInputPort
*
>
mInputs
;
nsTArray
<
MediaInputPort
*
>
mSuspendedInputs
;
bool
mAutoend
;
uint32_t
mCycleMarker
;
}
;
class
MediaStreamGraph
{
public
:
enum
GraphDriverType
{
AUDIO_THREAD_DRIVER
SYSTEM_THREAD_DRIVER
OFFLINE_THREAD_DRIVER
}
;
enum
GraphRunType
{
DIRECT_DRIVER
SINGLE_THREAD
}
;
static
const
uint32_t
AUDIO_CALLBACK_DRIVER_SHUTDOWN_TIMEOUT
=
20
*
1000
;
static
const
TrackRate
REQUEST_DEFAULT_SAMPLE_RATE
=
0
;
static
MediaStreamGraph
*
GetInstanceIfExists
(
nsPIDOMWindowInner
*
aWindow
TrackRate
aSampleRate
)
;
static
MediaStreamGraph
*
GetInstance
(
GraphDriverType
aGraphDriverRequested
nsPIDOMWindowInner
*
aWindow
TrackRate
aSampleRate
)
;
static
MediaStreamGraph
*
CreateNonRealtimeInstance
(
TrackRate
aSampleRate
nsPIDOMWindowInner
*
aWindowId
)
;
AbstractThread
*
AbstractMainThread
(
)
;
static
void
DestroyNonRealtimeInstance
(
MediaStreamGraph
*
aGraph
)
;
virtual
nsresult
OpenAudioInput
(
CubebUtils
:
:
AudioDeviceID
aID
AudioDataListener
*
aListener
)
=
0
;
virtual
void
CloseAudioInput
(
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
&
aID
AudioDataListener
*
aListener
)
=
0
;
SourceMediaStream
*
CreateSourceStream
(
MediaSegment
:
:
Type
aType
)
;
ProcessedMediaStream
*
CreateTrackUnionStream
(
MediaSegment
:
:
Type
aType
)
;
AudioCaptureStream
*
CreateAudioCaptureStream
(
)
;
void
AddStream
(
MediaStream
*
aStream
)
;
void
NotifyWhenGraphStarted
(
AudioNodeStream
*
aNodeStream
)
;
void
ApplyAudioContextOperation
(
MediaStream
*
aDestinationStream
const
nsTArray
<
MediaStream
*
>
&
aStreams
dom
:
:
AudioContextOperation
aState
void
*
aPromise
dom
:
:
AudioContextOperationFlags
aFlags
)
;
bool
IsNonRealtime
(
)
const
;
void
StartNonRealtimeProcessing
(
uint32_t
aTicksToProcess
)
;
void
DispatchToMainThreadStableState
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
TrackRate
GraphRate
(
)
const
{
return
mSampleRate
;
}
double
AudioOutputLatency
(
)
;
void
RegisterCaptureStreamForWindow
(
uint64_t
aWindowId
ProcessedMediaStream
*
aCaptureStream
)
;
void
UnregisterCaptureStreamForWindow
(
uint64_t
aWindowId
)
;
already_AddRefed
<
MediaInputPort
>
ConnectToCaptureStream
(
uint64_t
aWindowId
MediaStream
*
aMediaStream
)
;
void
AssertOnGraphThreadOrNotRunning
(
)
const
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
}
virtual
Watchable
<
GraphTime
>
&
CurrentTime
(
)
=
0
;
protected
:
explicit
MediaStreamGraph
(
TrackRate
aSampleRate
)
:
mSampleRate
(
aSampleRate
)
{
MOZ_COUNT_CTOR
(
MediaStreamGraph
)
;
}
virtual
~
MediaStreamGraph
(
)
{
MOZ_COUNT_DTOR
(
MediaStreamGraph
)
;
}
virtual
bool
OnGraphThreadOrNotRunning
(
)
const
=
0
;
virtual
bool
OnGraphThread
(
)
const
=
0
;
virtual
bool
Destroyed
(
)
const
=
0
;
const
TrackRate
mSampleRate
;
}
;
}
#
endif
