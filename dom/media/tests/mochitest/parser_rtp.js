"
use
strict
"
;
var
ParseRtpPacket
=
(
buffer
)
=
>
{
let
view
=
new
DataView
(
buffer
)
;
let
header
=
{
}
;
let
offset
=
0
;
let
byte
=
view
.
getUint8
(
offset
)
;
offset
+
+
;
header
.
version
=
(
0xC0
&
byte
)
>
>
6
;
header
.
padding
=
(
0x30
&
byte
)
>
>
5
header
.
extensionsPresent
=
(
(
0x10
&
byte
)
>
>
4
)
=
=
1
;
header
.
csrcCount
=
(
0xF
&
byte
)
;
byte
=
view
.
getUint8
(
offset
)
;
offset
+
+
;
header
.
marker
=
(
0x80
&
byte
)
>
>
7
;
header
.
payloadType
=
(
0x7F
&
byte
)
;
header
.
sequenceNumber
=
view
.
getUint16
(
offset
)
;
offset
+
=
2
;
header
.
timestamp
=
view
.
getUint32
(
offset
)
;
offset
+
=
4
;
header
.
ssrc
=
view
.
getUint32
(
offset
)
;
offset
+
=
4
;
header
.
csrcs
=
[
]
;
for
(
let
c
=
0
;
c
<
header
.
csrcCount
;
c
+
+
)
{
header
.
csrcs
.
push
(
view
.
getUint32
(
offset
)
)
;
offset
+
=
4
;
}
header
.
extensions
=
[
]
;
header
.
extensionPaddingBytes
=
0
;
header
.
extensionsTotalLength
=
0
;
if
(
header
.
extensionsPresent
)
{
let
addExtension
=
(
id
len
)
=
>
header
.
extensions
.
push
(
{
id
:
id
data
:
new
DataView
(
buffer
offset
len
)
}
)
;
let
extensionId
=
view
.
getUint16
(
offset
)
;
offset
+
=
2
;
header
.
extensionsTotalLength
=
view
.
getUint16
(
offset
)
*
4
;
offset
+
=
2
;
if
(
extensionId
!
=
0xBEDE
)
{
addExtension
(
extensionId
header
.
extensionsTotalLength
)
;
offset
+
=
header
.
extensionsTotalLength
;
}
else
{
let
expectedEnd
=
offset
+
header
.
extensionsTotalLength
;
while
(
offset
<
expectedEnd
)
{
byte
=
view
.
getUint8
(
offset
)
;
offset
+
+
;
if
(
byte
=
=
0
)
{
header
.
extensionPaddingBytes
+
+
;
continue
;
}
let
id
=
(
byte
&
0xF0
)
>
>
4
;
if
(
id
=
=
15
)
{
offset
=
expectedEnd
;
break
;
}
let
len
=
(
byte
&
0x0F
)
+
1
;
addExtension
(
id
len
)
;
offset
+
=
len
;
}
}
}
return
{
type
:
"
rtp
"
header
:
header
payload
:
new
DataView
(
buffer
offset
)
}
;
}
