"
use
strict
"
;
var
Cc
=
SpecialPowers
.
Cc
;
var
Ci
=
SpecialPowers
.
Ci
;
var
FAKE_ENABLED
=
true
;
try
{
var
audioDevice
=
SpecialPowers
.
getCharPref
(
'
media
.
audio_loopback_dev
'
)
;
var
videoDevice
=
SpecialPowers
.
getCharPref
(
'
media
.
video_loopback_dev
'
)
;
dump
(
'
TEST
DEVICES
:
Using
media
devices
:
\
n
'
)
;
dump
(
'
audio
:
'
+
audioDevice
+
'
\
nvideo
:
'
+
videoDevice
+
'
\
n
'
)
;
FAKE_ENABLED
=
false
;
}
catch
(
e
)
{
dump
(
'
TEST
DEVICES
:
No
test
devices
found
(
in
media
.
{
audio
video
}
_loopback_dev
using
fake
streams
.
\
n
'
)
;
FAKE_ENABLED
=
true
;
}
function
AudioStreamAnalyser
(
ac
stream
)
{
this
.
audioContext
=
ac
;
this
.
stream
=
stream
;
this
.
sourceNode
=
this
.
audioContext
.
createMediaStreamSource
(
this
.
stream
)
;
this
.
analyser
=
this
.
audioContext
.
createAnalyser
(
)
;
this
.
analyser
.
smoothingTimeConstant
=
0
.
2
;
this
.
analyser
.
fftSize
=
1024
;
this
.
sourceNode
.
connect
(
this
.
analyser
)
;
this
.
data
=
new
Uint8Array
(
this
.
analyser
.
frequencyBinCount
)
;
}
AudioStreamAnalyser
.
prototype
=
{
getByteFrequencyData
:
function
(
)
{
this
.
analyser
.
getByteFrequencyData
(
this
.
data
)
;
return
this
.
data
;
}
enableDebugCanvas
:
function
(
)
{
var
cvs
=
this
.
debugCanvas
=
document
.
createElement
(
"
canvas
"
)
;
document
.
getElementById
(
"
content
"
)
.
appendChild
(
cvs
)
;
cvs
.
width
=
this
.
analyser
.
frequencyBinCount
;
cvs
.
height
=
128
;
cvs
.
style
.
border
=
"
1px
solid
red
"
;
var
c
=
cvs
.
getContext
(
'
2d
'
)
;
c
.
fillStyle
=
'
black
'
;
var
self
=
this
;
function
render
(
)
{
c
.
clearRect
(
0
0
cvs
.
width
cvs
.
height
)
;
var
array
=
self
.
getByteFrequencyData
(
)
;
for
(
var
i
=
0
;
i
<
array
.
length
;
i
+
+
)
{
c
.
fillRect
(
i
(
cvs
.
height
-
(
array
[
i
]
)
)
1
cvs
.
height
)
;
}
if
(
!
cvs
.
stopDrawing
)
{
requestAnimationFrame
(
render
)
;
}
}
requestAnimationFrame
(
render
)
;
}
disableDebugCanvas
:
function
(
)
{
if
(
!
this
.
debugCanvas
|
|
!
this
.
debugCanvas
.
parentElement
)
{
return
;
}
this
.
debugCanvas
.
stopDrawing
=
true
;
this
.
debugCanvas
.
parentElement
.
removeChild
(
this
.
debugCanvas
)
;
}
waitForAnalysisSuccess
:
function
(
analysisFunction
)
{
var
self
=
this
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
function
analysisLoop
(
)
{
var
success
=
analysisFunction
(
self
.
getByteFrequencyData
(
)
)
;
if
(
success
)
{
resolve
(
)
;
return
;
}
requestAnimationFrame
(
analysisLoop
)
;
}
analysisLoop
(
)
;
}
)
;
}
binIndexForFrequency
:
function
(
frequency
)
{
return
1
+
Math
.
round
(
frequency
*
this
.
analyser
.
fftSize
/
this
.
audioContext
.
sampleRate
)
;
}
frequencyForBinIndex
:
function
(
index
)
{
return
(
index
-
1
)
*
this
.
audioContext
.
sampleRate
/
this
.
analyser
.
fftSize
;
}
}
;
function
createOscillatorStream
(
ac
frequency
)
{
var
osc
=
ac
.
createOscillator
(
)
;
osc
.
frequency
.
value
=
frequency
;
var
oscDest
=
ac
.
createMediaStreamDestination
(
)
;
osc
.
connect
(
oscDest
)
;
osc
.
start
(
)
;
return
oscDest
.
stream
;
}
function
realCreateHTML
(
meta
)
{
var
test
=
document
.
getElementById
(
'
test
'
)
;
var
elem
=
document
.
createElement
(
'
meta
'
)
;
elem
.
setAttribute
(
'
charset
'
'
utf
-
8
'
)
;
document
.
head
.
appendChild
(
elem
)
;
var
title
=
document
.
createElement
(
'
title
'
)
;
title
.
textContent
=
meta
.
title
;
document
.
head
.
appendChild
(
title
)
;
var
anchor
=
document
.
createElement
(
'
a
'
)
;
anchor
.
textContent
=
meta
.
title
;
if
(
meta
.
bug
)
{
anchor
.
setAttribute
(
'
href
'
'
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
'
+
meta
.
bug
)
;
}
else
{
anchor
.
setAttribute
(
'
target
'
'
_blank
'
)
;
}
document
.
body
.
insertBefore
(
anchor
test
)
;
var
display
=
document
.
createElement
(
'
p
'
)
;
display
.
setAttribute
(
'
id
'
'
display
'
)
;
document
.
body
.
insertBefore
(
display
test
)
;
var
content
=
document
.
createElement
(
'
div
'
)
;
content
.
setAttribute
(
'
id
'
'
content
'
)
;
content
.
style
.
display
=
meta
.
visible
?
'
block
'
:
"
none
"
;
document
.
body
.
appendChild
(
content
)
;
}
function
createMediaElement
(
type
label
)
{
var
id
=
label
+
'
_
'
+
type
;
var
element
=
document
.
getElementById
(
id
)
;
if
(
element
)
{
return
element
;
}
element
=
document
.
createElement
(
type
=
=
=
'
audio
'
?
'
audio
'
:
'
video
'
)
;
element
.
setAttribute
(
'
id
'
id
)
;
element
.
setAttribute
(
'
height
'
100
)
;
element
.
setAttribute
(
'
width
'
150
)
;
element
.
setAttribute
(
'
controls
'
'
controls
'
)
;
element
.
setAttribute
(
'
autoplay
'
'
autoplay
'
)
;
document
.
getElementById
(
'
content
'
)
.
appendChild
(
element
)
;
return
element
;
}
function
getUserMedia
(
constraints
)
{
info
(
"
Call
getUserMedia
for
"
+
JSON
.
stringify
(
constraints
)
)
;
return
navigator
.
mediaDevices
.
getUserMedia
(
constraints
)
.
then
(
stream
=
>
(
checkMediaStreamTracks
(
constraints
stream
)
stream
)
)
;
}
var
setTestOptions
;
var
testConfigured
=
new
Promise
(
r
=
>
setTestOptions
=
r
)
;
function
setupEnvironment
(
)
{
if
(
!
window
.
SimpleTest
)
{
return
;
}
SimpleTest
.
requestFlakyTimeout
(
"
WebRTC
inherently
depends
on
timeouts
"
)
;
window
.
finish
=
(
)
=
>
SimpleTest
.
finish
(
)
;
SpecialPowers
.
pushPrefEnv
(
{
'
set
'
:
[
[
'
media
.
peerconnection
.
enabled
'
true
]
[
'
media
.
peerconnection
.
identity
.
enabled
'
true
]
[
'
media
.
peerconnection
.
identity
.
timeout
'
120000
]
[
'
media
.
peerconnection
.
ice
.
stun_client_maximum_transmits
'
14
]
[
'
media
.
peerconnection
.
ice
.
trickle_grace_period
'
30000
]
[
'
media
.
navigator
.
permission
.
disabled
'
true
]
[
'
media
.
navigator
.
streams
.
fake
'
FAKE_ENABLED
]
[
'
media
.
getusermedia
.
screensharing
.
enabled
'
true
]
[
'
media
.
getusermedia
.
screensharing
.
allowed_domains
'
"
mochi
.
test
"
]
[
'
media
.
getusermedia
.
audiocapture
.
enabled
'
true
]
[
'
media
.
recorder
.
audio_node
.
enabled
'
true
]
]
}
setTestOptions
)
;
SpecialPowers
.
exactGC
(
window
)
;
}
function
run_test
(
is_initiator
timeout
)
{
var
options
=
{
is_local
:
is_initiator
is_remote
:
!
is_initiator
}
;
setTimeout
(
(
)
=
>
{
unexpectedEventArrived
(
new
Error
(
"
PeerConnectionTest
timed
out
after
"
+
timeout
+
"
s
"
)
)
;
}
timeout
)
;
var
s
=
document
.
createElement
(
"
script
"
)
;
s
.
src
=
"
/
test
.
js
"
;
s
.
onload
=
(
)
=
>
setTestOptions
(
options
)
;
document
.
head
.
appendChild
(
s
)
;
}
function
runTestWhenReady
(
testFunc
)
{
setupEnvironment
(
)
;
return
testConfigured
.
then
(
options
=
>
testFunc
(
options
)
)
.
catch
(
e
=
>
ok
(
false
'
Error
executing
test
:
'
+
e
+
(
(
typeof
e
.
stack
=
=
=
'
string
'
)
?
(
'
'
+
e
.
stack
.
split
(
'
\
n
'
)
.
join
(
'
.
.
.
'
)
)
:
'
'
)
)
)
;
}
function
checkMediaStreamTracksByType
(
constraints
type
mediaStreamTracks
)
{
if
(
constraints
[
type
]
)
{
is
(
mediaStreamTracks
.
length
1
'
One
'
+
type
+
'
track
shall
be
present
'
)
;
if
(
mediaStreamTracks
.
length
)
{
is
(
mediaStreamTracks
[
0
]
.
kind
type
'
Track
kind
should
be
'
+
type
)
;
ok
(
mediaStreamTracks
[
0
]
.
id
'
Track
id
should
be
defined
'
)
;
}
}
else
{
is
(
mediaStreamTracks
.
length
0
'
No
'
+
type
+
'
tracks
shall
be
present
'
)
;
}
}
function
checkMediaStreamTracks
(
constraints
mediaStream
)
{
checkMediaStreamTracksByType
(
constraints
'
audio
'
mediaStream
.
getAudioTracks
(
)
)
;
checkMediaStreamTracksByType
(
constraints
'
video
'
mediaStream
.
getVideoTracks
(
)
)
;
}
function
checkMediaStreamContains
(
mediaStream
tracks
message
)
{
message
=
message
?
(
message
+
"
:
"
)
:
"
"
;
tracks
.
forEach
(
t
=
>
ok
(
mediaStream
.
getTracks
(
)
.
includes
(
t
)
message
+
"
MediaStream
"
+
mediaStream
.
id
+
"
contains
track
"
+
t
.
id
)
)
;
is
(
mediaStream
.
getTracks
(
)
.
length
tracks
.
length
message
+
"
MediaStream
"
+
mediaStream
.
id
+
"
contains
no
extra
tracks
"
)
;
}
function
wait
(
time
)
{
return
new
Promise
(
r
=
>
setTimeout
(
r
time
)
)
;
}
function
waitUntil
(
func
time
)
{
return
new
Promise
(
resolve
=
>
{
var
interval
=
setInterval
(
(
)
=
>
{
if
(
func
(
)
)
{
clearInterval
(
interval
)
;
resolve
(
)
;
}
}
time
|
|
200
)
;
}
)
;
}
var
timeout
=
(
promise
time
msg
)
=
>
Promise
.
race
(
[
promise
wait
(
time
)
.
then
(
(
)
=
>
Promise
.
reject
(
new
Error
(
msg
)
)
)
]
)
;
var
listenUntil
=
(
target
eventName
onFire
)
=
>
{
return
new
Promise
(
resolve
=
>
target
.
addEventListener
(
eventName
function
callback
(
)
{
var
result
=
onFire
(
)
;
if
(
result
)
{
target
.
removeEventListener
(
eventName
callback
false
)
;
resolve
(
result
)
;
}
}
false
)
)
;
}
;
function
generateErrorCallback
(
message
)
{
var
stack
=
new
Error
(
)
.
stack
.
split
(
"
\
n
"
)
;
stack
.
shift
(
)
;
return
aObj
=
>
{
if
(
aObj
)
{
if
(
aObj
.
name
&
&
aObj
.
message
)
{
ok
(
false
"
Unexpected
callback
for
'
"
+
aObj
.
name
+
"
'
with
message
=
'
"
+
aObj
.
message
+
"
'
at
"
+
JSON
.
stringify
(
stack
)
)
;
}
else
{
ok
(
false
"
Unexpected
callback
with
=
'
"
+
aObj
+
"
'
at
:
"
+
JSON
.
stringify
(
stack
)
)
;
}
}
else
{
ok
(
false
"
Unexpected
callback
with
message
=
'
"
+
message
+
"
'
at
:
"
+
JSON
.
stringify
(
stack
)
)
;
}
throw
new
Error
(
"
Unexpected
callback
"
)
;
}
}
var
unexpectedEventArrived
;
var
rejectOnUnexpectedEvent
=
new
Promise
(
(
x
reject
)
=
>
{
unexpectedEventArrived
=
reject
;
}
)
;
function
unexpectedEvent
(
message
eventName
)
{
var
stack
=
new
Error
(
)
.
stack
.
split
(
"
\
n
"
)
;
stack
.
shift
(
)
;
return
e
=
>
{
var
details
=
"
Unexpected
event
'
"
+
eventName
+
"
'
fired
with
message
=
'
"
+
message
+
"
'
at
:
"
+
JSON
.
stringify
(
stack
)
;
ok
(
false
details
)
;
unexpectedEventArrived
(
new
Error
(
details
)
)
;
}
}
function
createOneShotEventWrapper
(
wrapper
obj
event
)
{
var
onx
=
'
on
'
+
event
;
var
unexpected
=
unexpectedEvent
(
wrapper
event
)
;
wrapper
[
onx
]
=
unexpected
;
obj
[
onx
]
=
e
=
>
{
info
(
wrapper
+
'
:
"
on
'
+
event
+
'
"
event
fired
'
)
;
e
.
wrapper
=
wrapper
;
wrapper
[
onx
]
(
e
)
;
wrapper
[
onx
]
=
unexpected
;
}
;
}
function
CommandChain
(
framework
commandList
)
{
this
.
_framework
=
framework
;
this
.
commands
=
commandList
|
|
[
]
;
}
CommandChain
.
prototype
=
{
execute
:
function
(
)
{
return
this
.
commands
.
reduce
(
(
prev
next
i
)
=
>
{
if
(
typeof
next
!
=
=
'
function
'
|
|
!
next
.
name
)
{
throw
new
Error
(
'
registered
non
-
function
'
+
next
)
;
}
return
prev
.
then
(
(
)
=
>
{
info
(
'
Run
step
'
+
(
i
+
1
)
+
'
:
'
+
next
.
name
)
;
return
Promise
.
race
(
[
next
(
this
.
_framework
)
rejectOnUnexpectedEvent
]
)
;
}
)
;
}
Promise
.
resolve
(
)
)
.
catch
(
e
=
>
ok
(
false
'
Error
in
test
execution
:
'
+
e
+
(
(
typeof
e
.
stack
=
=
=
'
string
'
)
?
(
'
'
+
e
.
stack
.
split
(
'
\
n
'
)
.
join
(
'
.
.
.
'
)
)
:
'
'
)
)
)
;
}
append
:
function
(
commands
)
{
this
.
commands
=
this
.
commands
.
concat
(
commands
)
;
}
indexOf
:
function
(
functionOrName
start
)
{
start
=
start
|
|
0
;
if
(
typeof
functionOrName
=
=
=
'
string
'
)
{
var
index
=
this
.
commands
.
slice
(
start
)
.
findIndex
(
f
=
>
f
.
name
=
=
=
functionOrName
)
;
if
(
index
!
=
=
-
1
)
{
index
+
=
start
;
}
return
index
;
}
return
this
.
commands
.
indexOf
(
functionOrName
start
)
;
}
mustHaveIndexOf
:
function
(
functionOrName
start
)
{
var
index
=
this
.
indexOf
(
functionOrName
start
)
;
if
(
index
=
=
-
1
)
{
throw
new
Error
(
"
Unknown
test
:
"
+
functionOrName
)
;
}
return
index
;
}
insertAfter
:
function
(
functionOrName
commands
all
start
)
{
this
.
_insertHelper
(
functionOrName
commands
1
all
start
)
;
}
insertAfterEach
:
function
(
functionOrName
commands
)
{
this
.
_insertHelper
(
functionOrName
commands
1
true
)
;
}
insertBefore
:
function
(
functionOrName
commands
all
start
)
{
this
.
_insertHelper
(
functionOrName
commands
0
all
start
)
;
}
_insertHelper
:
function
(
functionOrName
commands
delta
all
start
)
{
var
index
=
this
.
mustHaveIndexOf
(
functionOrName
)
;
start
=
start
|
|
0
;
for
(
;
index
!
=
=
-
1
;
index
=
this
.
indexOf
(
functionOrName
index
)
)
{
if
(
!
start
)
{
this
.
commands
=
[
]
.
concat
(
this
.
commands
.
slice
(
0
index
+
delta
)
commands
this
.
commands
.
slice
(
index
+
delta
)
)
;
if
(
!
all
)
{
break
;
}
}
else
{
start
-
=
1
;
}
index
+
=
(
commands
.
length
+
1
)
;
}
}
remove
:
function
(
functionOrName
)
{
return
this
.
commands
.
splice
(
this
.
mustHaveIndexOf
(
functionOrName
)
1
)
;
}
removeAfter
:
function
(
functionOrName
start
)
{
return
this
.
commands
.
splice
(
this
.
mustHaveIndexOf
(
functionOrName
start
)
+
1
)
;
}
removeBefore
:
function
(
functionOrName
)
{
return
this
.
commands
.
splice
(
0
this
.
mustHaveIndexOf
(
functionOrName
)
)
;
}
replace
:
function
(
functionOrName
commands
)
{
this
.
insertBefore
(
functionOrName
commands
)
;
return
this
.
remove
(
functionOrName
)
;
}
replaceAfter
:
function
(
functionOrName
commands
start
)
{
var
oldCommands
=
this
.
removeAfter
(
functionOrName
start
)
;
this
.
append
(
commands
)
;
return
oldCommands
;
}
replaceBefore
:
function
(
functionOrName
commands
)
{
var
oldCommands
=
this
.
removeBefore
(
functionOrName
)
;
this
.
insertBefore
(
functionOrName
commands
)
;
return
oldCommands
;
}
filterOut
:
function
(
id_match
)
{
this
.
commands
=
this
.
commands
.
filter
(
c
=
>
!
id_match
.
test
(
c
.
name
)
)
;
}
}
;
function
IsMacOSX10_6orOlder
(
)
{
if
(
navigator
.
platform
.
indexOf
(
"
Mac
"
)
!
=
=
0
)
{
return
false
;
}
var
version
=
Cc
[
"
mozilla
.
org
/
system
-
info
;
1
"
]
.
getService
(
Ci
.
nsIPropertyBag2
)
.
getProperty
(
"
version
"
)
;
return
(
parseFloat
(
version
)
<
11
.
0
)
;
}
(
function
(
)
{
var
el
=
document
.
createElement
(
"
link
"
)
;
el
.
rel
=
"
stylesheet
"
;
el
.
type
=
"
text
/
css
"
;
el
.
href
=
"
/
tests
/
SimpleTest
/
test
.
css
"
;
document
.
head
.
appendChild
(
el
)
;
}
(
)
)
;
