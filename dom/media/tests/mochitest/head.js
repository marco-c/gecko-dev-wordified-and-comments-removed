"
use
strict
"
;
var
Cc
=
SpecialPowers
.
Cc
;
var
Ci
=
SpecialPowers
.
Ci
;
let
WANT_FAKE_AUDIO
=
true
;
let
WANT_FAKE_VIDEO
=
true
;
let
TEST_AUDIO_FREQ
=
1000
;
function
updateConfigFromFakeAndLoopbackPrefs
(
)
{
let
audioDevice
=
SpecialPowers
.
getCharPref
(
"
media
.
audio_loopback_dev
"
"
"
)
;
if
(
audioDevice
)
{
WANT_FAKE_AUDIO
=
false
;
dump
(
"
TEST
DEVICES
:
Got
loopback
audio
:
"
+
audioDevice
+
"
\
n
"
)
;
}
else
{
WANT_FAKE_AUDIO
=
true
;
dump
(
"
TEST
DEVICES
:
No
test
device
found
in
media
.
audio_loopback_dev
using
fake
audio
streams
.
\
n
"
)
;
}
let
videoDevice
=
SpecialPowers
.
getCharPref
(
"
media
.
video_loopback_dev
"
"
"
)
;
if
(
videoDevice
)
{
WANT_FAKE_VIDEO
=
false
;
dump
(
"
TEST
DEVICES
:
Got
loopback
video
:
"
+
videoDevice
+
"
\
n
"
)
;
}
else
{
WANT_FAKE_VIDEO
=
true
;
dump
(
"
TEST
DEVICES
:
No
test
device
found
in
media
.
video_loopback_dev
using
fake
video
streams
.
\
n
"
)
;
}
}
updateConfigFromFakeAndLoopbackPrefs
(
)
;
let
DISABLE_LOOPBACK_TONE
=
false
;
class
LoopbackTone
{
constructor
(
audioContext
frequency
)
{
if
(
!
audioContext
)
{
throw
new
Error
(
"
You
must
provide
a
valid
AudioContext
"
)
;
}
this
.
oscNode
=
audioContext
.
createOscillator
(
)
;
var
gainNode
=
audioContext
.
createGain
(
)
;
gainNode
.
gain
.
value
=
0
.
5
;
this
.
oscNode
.
connect
(
gainNode
)
;
gainNode
.
connect
(
audioContext
.
destination
)
;
this
.
changeFrequency
(
frequency
)
;
}
start
(
)
{
if
(
!
this
.
oscNode
)
{
throw
new
Error
(
"
Attempt
to
start
a
stopped
LoopbackTone
"
)
;
}
info
(
Start
loopback
tone
at
{
this
.
oscNode
.
frequency
.
value
}
)
;
this
.
oscNode
.
start
(
)
;
}
changeFrequency
(
frequency
)
{
if
(
!
this
.
oscNode
)
{
throw
new
Error
(
"
Attempt
to
change
frequency
on
a
stopped
LoopbackTone
"
)
;
}
this
.
oscNode
.
frequency
.
value
=
frequency
;
}
stop
(
)
{
if
(
!
this
.
oscNode
)
{
throw
new
Error
(
"
Attempt
to
stop
a
stopped
LoopbackTone
"
)
;
}
this
.
oscNode
.
stop
(
)
;
this
.
oscNode
=
null
;
}
}
var
DefaultLoopbackTone
=
null
;
function
AudioStreamAnalyser
(
ac
stream
)
{
this
.
audioContext
=
ac
;
this
.
stream
=
stream
;
this
.
sourceNodes
=
[
]
;
this
.
analyser
=
this
.
audioContext
.
createAnalyser
(
)
;
this
.
analyser
.
smoothingTimeConstant
=
0
.
2
;
this
.
analyser
.
fftSize
=
1024
;
this
.
connectTrack
=
t
=
>
{
let
source
=
this
.
audioContext
.
createMediaStreamSource
(
new
MediaStream
(
[
t
]
)
)
;
this
.
sourceNodes
.
push
(
source
)
;
source
.
connect
(
this
.
analyser
)
;
}
;
this
.
stream
.
getAudioTracks
(
)
.
forEach
(
t
=
>
this
.
connectTrack
(
t
)
)
;
this
.
onaddtrack
=
ev
=
>
this
.
connectTrack
(
ev
.
track
)
;
this
.
stream
.
addEventListener
(
"
addtrack
"
this
.
onaddtrack
)
;
this
.
data
=
new
Uint8Array
(
this
.
analyser
.
frequencyBinCount
)
;
}
AudioStreamAnalyser
.
prototype
=
{
getByteFrequencyData
:
function
(
)
{
this
.
analyser
.
getByteFrequencyData
(
this
.
data
)
;
return
this
.
data
;
}
enableDebugCanvas
:
function
(
)
{
var
cvs
=
this
.
debugCanvas
=
document
.
createElement
(
"
canvas
"
)
;
const
content
=
document
.
getElementById
(
"
content
"
)
;
content
.
insertBefore
(
cvs
content
.
children
[
0
]
)
;
cvs
.
width
=
this
.
analyser
.
frequencyBinCount
;
cvs
.
height
=
128
;
cvs
.
style
.
border
=
"
1px
solid
red
"
;
var
c
=
cvs
.
getContext
(
'
2d
'
)
;
c
.
fillStyle
=
'
black
'
;
var
self
=
this
;
function
render
(
)
{
c
.
clearRect
(
0
0
cvs
.
width
cvs
.
height
)
;
var
array
=
self
.
getByteFrequencyData
(
)
;
for
(
var
i
=
0
;
i
<
array
.
length
;
i
+
+
)
{
c
.
fillRect
(
i
(
cvs
.
height
-
(
array
[
i
]
/
2
)
)
1
cvs
.
height
)
;
}
if
(
!
cvs
.
stopDrawing
)
{
requestAnimationFrame
(
render
)
;
}
}
requestAnimationFrame
(
render
)
;
}
disableDebugCanvas
:
function
(
)
{
if
(
!
this
.
debugCanvas
|
|
!
this
.
debugCanvas
.
parentElement
)
{
return
;
}
this
.
debugCanvas
.
stopDrawing
=
true
;
this
.
debugCanvas
.
parentElement
.
removeChild
(
this
.
debugCanvas
)
;
}
disconnect
:
function
(
)
{
this
.
disableDebugCanvas
(
)
;
this
.
sourceNodes
.
forEach
(
n
=
>
n
.
disconnect
(
)
)
;
this
.
sourceNodes
=
[
]
;
this
.
stream
.
removeEventListener
(
"
addtrack
"
this
.
onaddtrack
)
;
}
waitForAnalysisSuccess
:
async
function
(
analysisFunction
cancel
=
wait
(
60000
new
Error
(
"
Audio
analysis
timed
out
"
)
)
)
{
let
aborted
=
false
;
cancel
.
then
(
(
)
=
>
aborted
=
true
)
;
await
wait
(
200
)
;
do
{
await
new
Promise
(
resolve
=
>
requestAnimationFrame
(
resolve
)
)
;
if
(
aborted
)
{
throw
await
cancel
;
}
}
while
(
!
analysisFunction
(
this
.
getByteFrequencyData
(
)
)
)
;
}
binIndexForFrequency
:
function
(
frequency
)
{
return
1
+
Math
.
round
(
frequency
*
this
.
analyser
.
fftSize
/
this
.
audioContext
.
sampleRate
)
;
}
frequencyForBinIndex
:
function
(
index
)
{
return
(
index
-
1
)
*
this
.
audioContext
.
sampleRate
/
this
.
analyser
.
fftSize
;
}
}
;
function
createOscillatorStream
(
ac
frequency
)
{
var
osc
=
ac
.
createOscillator
(
)
;
osc
.
frequency
.
value
=
frequency
;
var
oscDest
=
ac
.
createMediaStreamDestination
(
)
;
osc
.
connect
(
oscDest
)
;
osc
.
start
(
)
;
return
oscDest
.
stream
;
}
function
realCreateHTML
(
meta
)
{
var
test
=
document
.
getElementById
(
'
test
'
)
;
var
elem
=
document
.
createElement
(
'
meta
'
)
;
elem
.
setAttribute
(
'
charset
'
'
utf
-
8
'
)
;
document
.
head
.
appendChild
(
elem
)
;
var
title
=
document
.
createElement
(
'
title
'
)
;
title
.
textContent
=
meta
.
title
;
document
.
head
.
appendChild
(
title
)
;
var
anchor
=
document
.
createElement
(
'
a
'
)
;
anchor
.
textContent
=
meta
.
title
;
if
(
meta
.
bug
)
{
anchor
.
setAttribute
(
'
href
'
'
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
'
+
meta
.
bug
)
;
}
else
{
anchor
.
setAttribute
(
'
target
'
'
_blank
'
)
;
}
document
.
body
.
insertBefore
(
anchor
test
)
;
var
display
=
document
.
createElement
(
'
p
'
)
;
display
.
setAttribute
(
'
id
'
'
display
'
)
;
document
.
body
.
insertBefore
(
display
test
)
;
var
content
=
document
.
createElement
(
'
div
'
)
;
content
.
setAttribute
(
'
id
'
'
content
'
)
;
content
.
style
.
display
=
meta
.
visible
?
'
block
'
:
"
none
"
;
document
.
body
.
appendChild
(
content
)
;
}
function
createMediaElement
(
type
id
)
{
const
element
=
document
.
createElement
(
type
)
;
element
.
setAttribute
(
'
id
'
id
)
;
element
.
setAttribute
(
'
height
'
100
)
;
element
.
setAttribute
(
'
width
'
150
)
;
element
.
setAttribute
(
'
controls
'
'
controls
'
)
;
element
.
setAttribute
(
'
autoplay
'
'
autoplay
'
)
;
element
.
setAttribute
(
'
muted
'
'
muted
'
)
;
element
.
muted
=
true
;
document
.
getElementById
(
'
content
'
)
.
appendChild
(
element
)
;
return
element
;
}
function
getMediaElementForTrack
(
track
idPrefix
)
{
return
document
.
getElementById
(
idPrefix
+
'
_
'
+
track
.
id
)
;
}
function
createMediaElementForTrack
(
track
idPrefix
)
{
const
id
=
idPrefix
+
'
_
'
+
track
.
id
;
const
element
=
createMediaElement
(
track
.
kind
id
)
;
element
.
srcObject
=
new
MediaStream
(
[
track
]
)
;
return
element
;
}
function
getUserMedia
(
constraints
)
{
updateConfigFromFakeAndLoopbackPrefs
(
)
;
if
(
!
WANT_FAKE_AUDIO
&
&
!
constraints
.
fake
&
&
constraints
.
audio
&
&
!
DISABLE_LOOPBACK_TONE
)
{
if
(
!
DefaultLoopbackTone
)
{
TEST_AUDIO_FREQ
=
440
;
DefaultLoopbackTone
=
new
LoopbackTone
(
new
AudioContext
TEST_AUDIO_FREQ
)
;
DefaultLoopbackTone
.
start
(
)
;
}
constraints
.
audio
=
Object
.
assign
(
{
}
{
autoGainControl
:
false
}
{
echoCancellation
:
false
}
{
noiseSuppression
:
false
}
constraints
.
audio
)
;
}
else
{
TEST_AUDIO_FREQ
=
1000
;
}
info
(
"
Call
getUserMedia
for
"
+
JSON
.
stringify
(
constraints
)
)
;
return
navigator
.
mediaDevices
.
getUserMedia
(
constraints
)
.
then
(
stream
=
>
(
checkMediaStreamTracks
(
constraints
stream
)
stream
)
)
;
}
var
setTestOptions
;
var
testConfigured
=
new
Promise
(
r
=
>
setTestOptions
=
r
)
;
function
pushPrefs
(
.
.
.
p
)
{
return
SpecialPowers
.
pushPrefEnv
(
{
set
:
p
}
)
;
}
function
setupEnvironment
(
)
{
if
(
!
window
.
SimpleTest
)
{
return
;
}
var
defaultMochitestPrefs
=
{
'
set
'
:
[
[
'
media
.
peerconnection
.
enabled
'
true
]
[
'
media
.
peerconnection
.
identity
.
enabled
'
true
]
[
'
media
.
peerconnection
.
identity
.
timeout
'
120000
]
[
'
media
.
peerconnection
.
ice
.
stun_client_maximum_transmits
'
14
]
[
'
media
.
peerconnection
.
ice
.
trickle_grace_period
'
30000
]
[
'
media
.
peerconnection
.
remoteTrackId
.
enabled
'
true
]
[
'
media
.
peerconnection
.
rtpsourcesapi
.
enabled
'
true
]
[
'
media
.
navigator
.
permission
.
disabled
'
true
]
[
'
media
.
navigator
.
streams
.
fake
'
WANT_FAKE_AUDIO
|
|
WANT_FAKE_VIDEO
]
[
'
media
.
getusermedia
.
screensharing
.
enabled
'
true
]
[
'
media
.
getusermedia
.
audiocapture
.
enabled
'
true
]
[
'
media
.
recorder
.
audio_node
.
enabled
'
true
]
]
}
;
if
(
!
WANT_FAKE_AUDIO
)
{
defaultMochitestPrefs
.
set
.
push
(
[
"
media
.
volume_scale
"
"
1
"
]
)
;
}
const
isAndroid
=
!
!
navigator
.
userAgent
.
includes
(
"
Android
"
)
;
if
(
isAndroid
)
{
defaultMochitestPrefs
.
set
.
push
(
[
"
media
.
navigator
.
video
.
default_width
"
320
]
[
"
media
.
navigator
.
video
.
default_height
"
240
]
[
"
media
.
navigator
.
video
.
max_fr
"
10
]
[
"
media
.
autoplay
.
enabled
"
true
]
)
;
}
SimpleTest
.
requestFlakyTimeout
(
"
WebRTC
inherently
depends
on
timeouts
"
)
;
window
.
finish
=
(
)
=
>
SimpleTest
.
finish
(
)
;
SpecialPowers
.
pushPrefEnv
(
defaultMochitestPrefs
setTestOptions
)
;
SpecialPowers
.
exactGC
(
)
;
}
function
run_test
(
is_initiator
timeout
)
{
var
options
=
{
is_local
:
is_initiator
is_remote
:
!
is_initiator
}
;
setTimeout
(
(
)
=
>
{
unexpectedEventArrived
(
new
Error
(
"
PeerConnectionTest
timed
out
after
"
+
timeout
+
"
s
"
)
)
;
}
timeout
)
;
var
s
=
document
.
createElement
(
"
script
"
)
;
s
.
src
=
"
/
test
.
js
"
;
s
.
onload
=
(
)
=
>
setTestOptions
(
options
)
;
document
.
head
.
appendChild
(
s
)
;
}
function
runTestWhenReady
(
testFunc
)
{
setupEnvironment
(
)
;
return
testConfigured
.
then
(
options
=
>
testFunc
(
options
)
)
.
catch
(
e
=
>
{
ok
(
false
'
Error
executing
test
:
'
+
e
+
(
(
typeof
e
.
stack
=
=
=
'
string
'
)
?
(
'
'
+
e
.
stack
.
split
(
'
\
n
'
)
.
join
(
'
.
.
.
'
)
)
:
'
'
)
)
;
SimpleTest
.
finish
(
)
;
}
)
;
}
function
checkMediaStreamTracksByType
(
constraints
type
mediaStreamTracks
)
{
if
(
constraints
[
type
]
)
{
is
(
mediaStreamTracks
.
length
1
'
One
'
+
type
+
'
track
shall
be
present
'
)
;
if
(
mediaStreamTracks
.
length
)
{
is
(
mediaStreamTracks
[
0
]
.
kind
type
'
Track
kind
should
be
'
+
type
)
;
ok
(
mediaStreamTracks
[
0
]
.
id
'
Track
id
should
be
defined
'
)
;
ok
(
!
mediaStreamTracks
[
0
]
.
muted
'
Track
should
not
be
muted
'
)
;
}
}
else
{
is
(
mediaStreamTracks
.
length
0
'
No
'
+
type
+
'
tracks
shall
be
present
'
)
;
}
}
function
checkMediaStreamTracks
(
constraints
mediaStream
)
{
checkMediaStreamTracksByType
(
constraints
'
audio
'
mediaStream
.
getAudioTracks
(
)
)
;
checkMediaStreamTracksByType
(
constraints
'
video
'
mediaStream
.
getVideoTracks
(
)
)
;
}
function
checkMediaStreamContains
(
mediaStream
tracks
message
)
{
message
=
message
?
(
message
+
"
:
"
)
:
"
"
;
tracks
.
forEach
(
t
=
>
ok
(
mediaStream
.
getTrackById
(
t
.
id
)
message
+
"
MediaStream
"
+
mediaStream
.
id
+
"
contains
track
"
+
t
.
id
)
)
;
is
(
mediaStream
.
getTracks
(
)
.
length
tracks
.
length
message
+
"
MediaStream
"
+
mediaStream
.
id
+
"
contains
no
extra
tracks
"
)
;
}
function
checkMediaStreamCloneAgainstOriginal
(
clone
original
)
{
isnot
(
clone
.
id
.
length
0
"
Stream
clone
should
have
an
id
string
"
)
;
isnot
(
clone
original
"
Stream
clone
should
be
different
from
the
original
"
)
;
isnot
(
clone
.
id
original
.
id
"
Stream
clone
'
s
id
should
be
different
from
the
original
'
s
"
)
;
is
(
clone
.
getAudioTracks
(
)
.
length
original
.
getAudioTracks
(
)
.
length
"
All
audio
tracks
should
get
cloned
"
)
;
is
(
clone
.
getVideoTracks
(
)
.
length
original
.
getVideoTracks
(
)
.
length
"
All
video
tracks
should
get
cloned
"
)
;
is
(
clone
.
active
original
.
active
"
Active
state
should
be
preserved
"
)
;
original
.
getTracks
(
)
.
forEach
(
t
=
>
ok
(
!
clone
.
getTrackById
(
t
.
id
)
"
The
clone
'
s
tracks
should
be
originals
"
)
)
;
}
function
checkMediaStreamTrackCloneAgainstOriginal
(
clone
original
)
{
isnot
(
clone
.
id
.
length
0
"
Track
clone
should
have
an
id
string
"
)
;
isnot
(
clone
original
"
Track
clone
should
be
different
from
the
original
"
)
;
isnot
(
clone
.
id
original
.
id
"
Track
clone
'
s
id
should
be
different
from
the
original
'
s
"
)
;
is
(
clone
.
kind
original
.
kind
"
Track
clone
'
s
kind
should
be
same
as
the
original
'
s
"
)
;
is
(
clone
.
enabled
original
.
enabled
"
Track
clone
'
s
kind
should
be
same
as
the
original
'
s
"
)
;
is
(
clone
.
readyState
original
.
readyState
"
Track
clone
'
s
readyState
should
be
same
as
the
original
'
s
"
)
;
is
(
clone
.
muted
original
.
muted
"
Track
clone
'
s
muted
state
should
be
same
as
the
original
'
s
"
)
;
}
function
wait
(
time
message
)
{
return
new
Promise
(
r
=
>
setTimeout
(
(
)
=
>
r
(
message
)
time
)
)
;
}
function
waitUntil
(
func
time
)
{
return
new
Promise
(
resolve
=
>
{
var
interval
=
setInterval
(
(
)
=
>
{
if
(
func
(
)
)
{
clearInterval
(
interval
)
;
resolve
(
)
;
}
}
time
|
|
200
)
;
}
)
;
}
var
timeout
=
(
promise
time
msg
)
=
>
Promise
.
race
(
[
promise
wait
(
time
)
.
then
(
(
)
=
>
Promise
.
reject
(
new
Error
(
msg
)
)
)
]
)
;
var
addFinallyToPromise
=
promise
=
>
{
promise
.
finally
=
func
=
>
{
return
promise
.
then
(
result
=
>
{
func
(
)
;
return
Promise
.
resolve
(
result
)
;
}
error
=
>
{
func
(
)
;
return
Promise
.
reject
(
error
)
;
}
)
;
}
return
promise
;
}
var
listenUntil
=
(
target
eventName
onFire
)
=
>
{
return
new
Promise
(
resolve
=
>
target
.
addEventListener
(
eventName
function
callback
(
event
)
{
var
result
=
onFire
(
event
)
;
if
(
result
)
{
target
.
removeEventListener
(
eventName
callback
)
;
resolve
(
result
)
;
}
}
)
)
;
}
;
function
mustThrowWith
(
msg
reason
f
)
{
try
{
f
(
)
;
ok
(
false
msg
+
"
must
throw
"
)
;
}
catch
(
e
)
{
is
(
e
.
name
reason
msg
+
"
must
throw
:
"
+
e
.
message
)
;
}
}
;
function
getSilentTrack
(
)
{
let
ctx
=
new
AudioContext
(
)
oscillator
=
ctx
.
createOscillator
(
)
;
let
dst
=
oscillator
.
connect
(
ctx
.
createMediaStreamDestination
(
)
)
;
oscillator
.
start
(
)
;
return
Object
.
assign
(
dst
.
stream
.
getAudioTracks
(
)
[
0
]
{
enabled
:
false
}
)
;
}
function
getBlackTrack
(
{
width
=
640
height
=
480
}
=
{
}
)
{
let
canvas
=
Object
.
assign
(
document
.
createElement
(
"
canvas
"
)
{
width
height
}
)
;
canvas
.
getContext
(
'
2d
'
)
.
fillRect
(
0
0
width
height
)
;
let
stream
=
canvas
.
captureStream
(
)
;
return
Object
.
assign
(
stream
.
getVideoTracks
(
)
[
0
]
{
enabled
:
false
}
)
;
}
function
generateErrorCallback
(
message
)
{
var
stack
=
new
Error
(
)
.
stack
.
split
(
"
\
n
"
)
;
stack
.
shift
(
)
;
return
aObj
=
>
{
if
(
aObj
)
{
if
(
aObj
.
name
&
&
aObj
.
message
)
{
ok
(
false
"
Unexpected
callback
for
'
"
+
aObj
.
name
+
"
'
with
message
=
'
"
+
aObj
.
message
+
"
'
at
"
+
JSON
.
stringify
(
stack
)
)
;
}
else
{
ok
(
false
"
Unexpected
callback
with
=
'
"
+
aObj
+
"
'
at
:
"
+
JSON
.
stringify
(
stack
)
)
;
}
}
else
{
ok
(
false
"
Unexpected
callback
with
message
=
'
"
+
message
+
"
'
at
:
"
+
JSON
.
stringify
(
stack
)
)
;
}
throw
new
Error
(
"
Unexpected
callback
"
)
;
}
}
var
unexpectedEventArrived
;
var
rejectOnUnexpectedEvent
=
new
Promise
(
(
x
reject
)
=
>
{
unexpectedEventArrived
=
reject
;
}
)
;
function
unexpectedEvent
(
message
eventName
)
{
var
stack
=
new
Error
(
)
.
stack
.
split
(
"
\
n
"
)
;
stack
.
shift
(
)
;
return
e
=
>
{
var
details
=
"
Unexpected
event
'
"
+
eventName
+
"
'
fired
with
message
=
'
"
+
message
+
"
'
at
:
"
+
JSON
.
stringify
(
stack
)
;
ok
(
false
details
)
;
unexpectedEventArrived
(
new
Error
(
details
)
)
;
}
}
function
createOneShotEventWrapper
(
wrapper
obj
event
)
{
var
onx
=
'
on
'
+
event
;
var
unexpected
=
unexpectedEvent
(
wrapper
event
)
;
wrapper
[
onx
]
=
unexpected
;
obj
[
onx
]
=
e
=
>
{
info
(
wrapper
+
'
:
"
on
'
+
event
+
'
"
event
fired
'
)
;
e
.
wrapper
=
wrapper
;
wrapper
[
onx
]
(
e
)
;
wrapper
[
onx
]
=
unexpected
;
}
;
}
function
haveEvents
(
target
name
count
cancel
)
{
var
listener
;
var
counter
=
count
|
|
1
;
return
Promise
.
race
(
[
(
cancel
|
|
new
Promise
(
(
)
=
>
{
}
)
)
.
then
(
e
=
>
Promise
.
reject
(
e
)
)
new
Promise
(
resolve
=
>
target
.
addEventListener
(
name
listener
=
e
=
>
(
-
-
counter
<
1
&
&
resolve
(
e
)
)
)
)
]
)
.
then
(
e
=
>
(
target
.
removeEventListener
(
name
listener
)
e
)
)
;
}
;
function
haveEvent
(
target
name
cancel
)
{
return
haveEvents
(
target
name
1
cancel
)
;
}
;
function
haveNoEvent
(
target
name
timeoutPromise
)
{
return
haveEvent
(
target
name
timeoutPromise
|
|
wait
(
0
)
)
.
then
(
(
)
=
>
Promise
.
reject
(
new
Error
(
"
Too
many
"
+
name
+
"
events
"
)
)
(
)
=
>
{
}
)
;
}
;
function
haveEventsButNoMore
(
target
name
count
cancel
)
{
return
haveEvents
(
target
name
count
cancel
)
.
then
(
e
=
>
haveNoEvent
(
target
name
)
.
then
(
(
)
=
>
e
)
)
;
}
;
function
CommandChain
(
framework
commandList
)
{
this
.
_framework
=
framework
;
this
.
commands
=
commandList
|
|
[
]
;
}
CommandChain
.
prototype
=
{
execute
:
function
(
)
{
return
this
.
commands
.
reduce
(
(
prev
next
i
)
=
>
{
if
(
typeof
next
!
=
=
'
function
'
|
|
!
next
.
name
)
{
throw
new
Error
(
'
registered
non
-
function
'
+
next
)
;
}
return
prev
.
then
(
(
)
=
>
{
info
(
'
Run
step
'
+
(
i
+
1
)
+
'
:
'
+
next
.
name
)
;
return
Promise
.
race
(
[
next
(
this
.
_framework
)
rejectOnUnexpectedEvent
]
)
;
}
)
;
}
Promise
.
resolve
(
)
)
.
catch
(
e
=
>
ok
(
false
'
Error
in
test
execution
:
'
+
e
+
(
(
typeof
e
.
stack
=
=
=
'
string
'
)
?
(
'
'
+
e
.
stack
.
split
(
'
\
n
'
)
.
join
(
'
.
.
.
'
)
)
:
'
'
)
)
)
;
}
append
:
function
(
commands
)
{
this
.
commands
=
this
.
commands
.
concat
(
commands
)
;
}
indexOf
:
function
(
functionOrName
occurrence
)
{
occurrence
=
occurrence
|
|
0
;
return
this
.
commands
.
findIndex
(
func
=
>
{
if
(
typeof
functionOrName
=
=
=
'
string
'
)
{
if
(
func
.
name
!
=
=
functionOrName
)
{
return
false
;
}
}
else
if
(
func
!
=
=
functionOrName
)
{
return
false
;
}
if
(
occurrence
)
{
-
-
occurrence
;
return
false
;
}
return
true
;
}
)
;
}
mustHaveIndexOf
:
function
(
functionOrName
occurrence
)
{
var
index
=
this
.
indexOf
(
functionOrName
occurrence
)
;
if
(
index
=
=
-
1
)
{
throw
new
Error
(
"
Unknown
test
:
"
+
functionOrName
)
;
}
return
index
;
}
insertAfter
:
function
(
functionOrName
commands
all
occurrence
)
{
this
.
_insertHelper
(
functionOrName
commands
1
all
occurrence
)
;
}
insertAfterEach
:
function
(
functionOrName
commands
)
{
this
.
_insertHelper
(
functionOrName
commands
1
true
)
;
}
insertBefore
:
function
(
functionOrName
commands
all
occurrence
)
{
this
.
_insertHelper
(
functionOrName
commands
0
all
occurrence
)
;
}
_insertHelper
:
function
(
functionOrName
commands
delta
all
occurrence
)
{
occurrence
=
occurrence
|
|
0
;
for
(
var
index
=
this
.
mustHaveIndexOf
(
functionOrName
occurrence
)
;
index
!
=
=
-
1
;
index
=
this
.
indexOf
(
functionOrName
+
+
occurrence
)
)
{
this
.
commands
=
[
]
.
concat
(
this
.
commands
.
slice
(
0
index
+
delta
)
commands
this
.
commands
.
slice
(
index
+
delta
)
)
;
if
(
!
all
)
{
break
;
}
}
}
remove
:
function
(
functionOrName
occurrence
)
{
return
this
.
commands
.
splice
(
this
.
mustHaveIndexOf
(
functionOrName
occurrence
)
1
)
;
}
removeAfter
:
function
(
functionOrName
occurrence
)
{
return
this
.
commands
.
splice
(
this
.
mustHaveIndexOf
(
functionOrName
occurrence
)
+
1
)
;
}
removeBefore
:
function
(
functionOrName
occurrence
)
{
return
this
.
commands
.
splice
(
0
this
.
mustHaveIndexOf
(
functionOrName
occurrence
)
)
;
}
replace
:
function
(
functionOrName
commands
)
{
this
.
insertBefore
(
functionOrName
commands
)
;
return
this
.
remove
(
functionOrName
)
;
}
replaceAfter
:
function
(
functionOrName
commands
occurrence
)
{
var
oldCommands
=
this
.
removeAfter
(
functionOrName
occurrence
)
;
this
.
append
(
commands
)
;
return
oldCommands
;
}
replaceBefore
:
function
(
functionOrName
commands
)
{
var
oldCommands
=
this
.
removeBefore
(
functionOrName
)
;
this
.
insertBefore
(
functionOrName
commands
)
;
return
oldCommands
;
}
filterOut
:
function
(
id_match
)
{
this
.
commands
=
this
.
commands
.
filter
(
c
=
>
!
id_match
.
test
(
c
.
name
)
)
;
}
}
;
function
AudioStreamHelper
(
)
{
this
.
_context
=
new
AudioContext
(
)
;
}
AudioStreamHelper
.
prototype
=
{
checkAudio
:
function
(
stream
analyser
fun
)
{
return
analyser
.
waitForAnalysisSuccess
(
fun
)
;
}
checkAudioFlowing
:
function
(
stream
)
{
var
analyser
=
new
AudioStreamAnalyser
(
this
.
_context
stream
)
;
var
freq
=
analyser
.
binIndexForFrequency
(
TEST_AUDIO_FREQ
)
;
return
this
.
checkAudio
(
stream
analyser
array
=
>
array
[
freq
]
>
200
)
;
}
checkAudioNotFlowing
:
function
(
stream
)
{
var
analyser
=
new
AudioStreamAnalyser
(
this
.
_context
stream
)
;
var
freq
=
analyser
.
binIndexForFrequency
(
TEST_AUDIO_FREQ
)
;
return
this
.
checkAudio
(
stream
analyser
array
=
>
array
[
freq
]
<
50
)
;
}
}
class
VideoFrameEmitter
{
constructor
(
color1
color2
width
height
)
{
if
(
!
width
)
{
width
=
50
;
}
if
(
!
height
)
{
height
=
width
;
}
this
.
_helper
=
new
CaptureStreamTestHelper2D
(
width
height
)
;
this
.
_canvas
=
this
.
_helper
.
createAndAppendElement
(
'
canvas
'
'
source_canvas
'
)
;
this
.
_color1
=
color1
?
color1
:
this
.
_helper
.
green
;
this
.
_color2
=
color2
?
color2
:
this
.
_helper
.
red
;
this
.
_helper
.
drawColor
(
this
.
_canvas
this
.
_color1
)
;
this
.
_stream
=
this
.
_canvas
.
captureStream
(
)
;
this
.
_started
=
false
;
}
stream
(
)
{
return
this
.
_stream
;
}
helper
(
)
{
return
this
.
_helper
;
}
colors
(
color1
color2
)
{
this
.
_color1
=
color1
?
color1
:
this
.
_helper
.
green
;
this
.
_color2
=
color2
?
color2
:
this
.
_helper
.
red
;
try
{
this
.
_helper
.
drawColor
(
this
.
_canvas
this
.
_color1
)
;
}
catch
(
e
)
{
}
}
start
(
)
{
if
(
this
.
_started
)
{
info
(
"
*
*
*
emitter
already
started
"
)
;
return
;
}
let
i
=
0
;
this
.
_started
=
true
;
this
.
_intervalId
=
setInterval
(
(
)
=
>
{
try
{
this
.
_helper
.
drawColor
(
this
.
_canvas
i
?
this
.
_color1
:
this
.
_color2
)
;
i
=
1
-
i
;
}
catch
(
e
)
{
}
}
500
)
;
}
stop
(
)
{
if
(
this
.
_started
)
{
clearInterval
(
this
.
_intervalId
)
;
this
.
_started
=
false
;
}
}
}
class
VideoStreamHelper
{
constructor
(
)
{
this
.
_helper
=
new
CaptureStreamTestHelper2D
(
50
50
)
;
}
async
checkHasFrame
(
video
{
offsetX
offsetY
threshold
}
=
{
}
)
{
const
h
=
this
.
_helper
;
await
h
.
waitForPixel
(
video
px
=
>
{
let
result
=
h
.
isOpaquePixelNot
(
px
h
.
black
threshold
)
;
info
(
"
Checking
that
we
have
a
frame
got
[
"
+
Array
.
slice
(
px
)
+
"
]
.
Ref
=
[
"
+
Array
.
slice
(
h
.
black
.
data
)
+
"
]
.
Threshold
=
"
+
threshold
+
"
.
Pass
=
"
+
result
)
;
return
result
;
}
{
offsetX
offsetY
}
)
;
}
async
checkVideoPlaying
(
video
{
offsetX
=
10
offsetY
=
10
threshold
=
16
}
=
{
}
)
{
const
h
=
this
.
_helper
;
await
this
.
checkHasFrame
(
video
{
offsetX
offsetY
threshold
}
)
;
let
startPixel
=
{
data
:
h
.
getPixel
(
video
offsetX
offsetY
)
name
:
"
startcolor
"
}
;
await
h
.
waitForPixel
(
video
px
=
>
{
let
result
=
h
.
isPixelNot
(
px
startPixel
threshold
)
;
info
(
"
Checking
playing
[
"
+
Array
.
slice
(
px
)
+
"
]
vs
[
"
+
Array
.
slice
(
startPixel
.
data
)
+
"
]
.
Threshold
=
"
+
threshold
+
"
Pass
=
"
+
result
)
;
return
result
;
}
{
offsetX
offsetY
}
)
;
}
async
checkVideoPaused
(
video
{
offsetX
=
10
offsetY
=
10
threshold
=
16
time
=
5000
}
=
{
}
)
{
const
h
=
this
.
_helper
;
await
this
.
checkHasFrame
(
video
{
offsetX
offsetY
threshold
}
)
;
let
startPixel
=
{
data
:
h
.
getPixel
(
video
offsetX
offsetY
)
name
:
"
startcolor
"
}
;
try
{
await
h
.
waitForPixel
(
video
px
=
>
{
let
result
=
h
.
isOpaquePixelNot
(
px
startPixel
threshold
)
;
info
(
"
Checking
paused
[
"
+
Array
.
slice
(
px
)
+
"
]
vs
[
"
+
Array
.
slice
(
startPixel
.
data
)
+
"
]
.
Threshold
=
"
+
threshold
+
"
Pass
=
"
+
result
)
;
return
result
;
}
{
offsetX
offsetY
cancel
:
wait
(
time
"
timeout
"
)
}
)
;
ok
(
false
"
Frame
changed
within
"
+
time
/
1000
+
"
seconds
"
)
;
}
catch
(
e
)
{
is
(
e
"
timeout
"
"
Frame
shouldn
'
t
change
for
"
+
time
/
1000
+
"
seconds
"
)
;
}
}
}
function
IsMacOSX10_6orOlder
(
)
{
if
(
navigator
.
platform
.
indexOf
(
"
Mac
"
)
!
=
=
0
)
{
return
false
;
}
var
version
=
Cc
[
"
mozilla
.
org
/
system
-
info
;
1
"
]
.
getService
(
Ci
.
nsIPropertyBag2
)
.
getProperty
(
"
version
"
)
;
return
(
parseFloat
(
version
)
<
11
.
0
)
;
}
(
function
(
)
{
var
el
=
document
.
createElement
(
"
link
"
)
;
el
.
rel
=
"
stylesheet
"
;
el
.
type
=
"
text
/
css
"
;
el
.
href
=
"
/
tests
/
SimpleTest
/
test
.
css
"
;
document
.
head
.
appendChild
(
el
)
;
}
(
)
)
;
