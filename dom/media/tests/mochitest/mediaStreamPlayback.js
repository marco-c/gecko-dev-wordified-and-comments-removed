const
ENDED_TIMEOUT_LENGTH
=
30000
;
const
VERIFYPLAYING_TIMEOUT_LENGTH
=
60000
;
function
MediaStreamPlayback
(
mediaElement
mediaStream
)
{
this
.
mediaElement
=
mediaElement
;
this
.
mediaStream
=
mediaStream
;
}
MediaStreamPlayback
.
prototype
=
{
playMedia
:
function
(
isResume
)
{
this
.
startMedia
(
isResume
)
;
return
this
.
verifyPlaying
(
)
.
then
(
(
)
=
>
this
.
stopTracksForStreamInMediaPlayback
(
)
)
.
then
(
(
)
=
>
this
.
detachFromMediaElement
(
)
)
;
}
stopTracksForStreamInMediaPlayback
:
function
(
)
{
var
elem
=
this
.
mediaElement
;
var
waitForEnded
=
(
)
=
>
new
Promise
(
resolve
=
>
{
elem
.
addEventListener
(
'
ended
'
function
ended
(
)
{
elem
.
removeEventListener
(
'
ended
'
ended
)
;
resolve
(
)
;
}
)
;
}
)
;
var
noTrackEnded
=
Promise
.
all
(
this
.
mediaStream
.
getTracks
(
)
.
map
(
t
=
>
{
let
onNextLoop
=
wait
(
0
)
;
let
p
=
Promise
.
race
(
[
onNextLoop
haveEvent
(
t
"
ended
"
onNextLoop
)
.
then
(
(
)
=
>
Promise
.
reject
(
"
Unexpected
ended
event
for
track
"
+
t
.
id
)
(
)
=
>
Promise
.
resolve
(
)
)
]
)
;
t
.
stop
(
)
;
return
p
;
}
)
)
;
if
(
!
this
.
mediaStream
.
stop
)
{
return
;
}
this
.
mediaStream
.
stop
(
)
;
return
timeout
(
waitForEnded
(
)
ENDED_TIMEOUT_LENGTH
"
ended
event
never
fired
"
)
.
then
(
(
)
=
>
ok
(
true
"
ended
event
successfully
fired
"
)
)
.
then
(
(
)
=
>
noTrackEnded
)
;
}
playMediaWithoutStoppingTracks
:
function
(
isResume
)
{
this
.
startMedia
(
isResume
)
;
return
this
.
verifyPlaying
(
)
.
then
(
(
)
=
>
this
.
detachFromMediaElement
(
)
)
;
}
startMedia
:
function
(
isResume
)
{
if
(
!
isResume
)
{
is
(
this
.
mediaElement
.
currentTime
0
"
Before
starting
the
media
element
currentTime
=
0
"
)
;
}
this
.
canPlayThroughFired
=
listenUntil
(
this
.
mediaElement
'
canplaythrough
'
(
)
=
>
true
)
;
this
.
mediaElement
.
srcObject
=
this
.
mediaStream
;
this
.
mediaElement
.
play
(
)
;
}
verifyPlaying
:
function
(
)
{
var
lastStreamTime
=
this
.
mediaStream
.
currentTime
;
var
lastElementTime
=
this
.
mediaElement
.
currentTime
;
var
mediaTimeProgressed
=
listenUntil
(
this
.
mediaElement
'
timeupdate
'
(
)
=
>
this
.
mediaStream
.
currentTime
>
lastStreamTime
&
&
this
.
mediaElement
.
currentTime
>
lastElementTime
)
;
return
timeout
(
Promise
.
all
(
[
this
.
canPlayThroughFired
mediaTimeProgressed
]
)
VERIFYPLAYING_TIMEOUT_LENGTH
"
verifyPlaying
timed
out
"
)
.
then
(
(
)
=
>
{
is
(
this
.
mediaElement
.
paused
false
"
Media
element
should
be
playing
"
)
;
is
(
this
.
mediaElement
.
duration
Number
.
POSITIVE_INFINITY
"
Duration
should
be
infinity
"
)
;
ok
(
this
.
mediaElement
.
readyState
=
=
=
HTMLMediaElement
.
HAVE_ENOUGH_DATA
|
|
this
.
mediaElement
.
readyState
=
=
=
HTMLMediaElement
.
HAVE_CURRENT_DATA
"
Ready
state
shall
be
HAVE_ENOUGH_DATA
or
HAVE_CURRENT_DATA
"
)
;
is
(
this
.
mediaElement
.
seekable
.
length
0
"
Seekable
length
shall
be
zero
"
)
;
is
(
this
.
mediaElement
.
buffered
.
length
0
"
Buffered
length
shall
be
zero
"
)
;
is
(
this
.
mediaElement
.
seeking
false
"
MediaElement
is
not
seekable
with
MediaStream
"
)
;
ok
(
isNaN
(
this
.
mediaElement
.
startOffsetTime
)
"
Start
offset
time
shall
not
be
a
number
"
)
;
is
(
this
.
mediaElement
.
loop
false
"
Loop
shall
be
false
"
)
;
is
(
this
.
mediaElement
.
preload
"
"
"
Preload
should
not
exist
"
)
;
is
(
this
.
mediaElement
.
src
"
"
"
No
src
should
be
defined
"
)
;
is
(
this
.
mediaElement
.
currentSrc
"
"
"
Current
src
should
still
be
an
empty
string
"
)
;
}
)
;
}
detachFromMediaElement
:
function
(
)
{
this
.
mediaElement
.
pause
(
)
;
this
.
mediaElement
.
srcObject
=
null
;
}
}
function
LocalMediaStreamPlayback
(
mediaElement
mediaStream
)
{
ok
(
mediaStream
instanceof
LocalMediaStream
"
Stream
should
be
a
LocalMediaStream
"
)
;
MediaStreamPlayback
.
call
(
this
mediaElement
mediaStream
)
;
}
LocalMediaStreamPlayback
.
prototype
=
Object
.
create
(
MediaStreamPlayback
.
prototype
{
playMediaWithDeprecatedStreamStop
:
{
value
:
function
(
isResume
)
{
this
.
startMedia
(
isResume
)
;
return
this
.
verifyPlaying
(
)
.
then
(
(
)
=
>
this
.
deprecatedStopStreamInMediaPlayback
(
)
)
.
then
(
(
)
=
>
this
.
detachFromMediaElement
(
)
)
;
}
}
deprecatedStopStreamInMediaPlayback
:
{
value
:
function
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
var
endedCallback
=
(
)
=
>
{
this
.
mediaElement
.
removeEventListener
(
'
ended
'
endedCallback
false
)
;
ok
(
true
"
ended
event
successfully
fired
"
)
;
resolve
(
)
;
}
;
this
.
mediaElement
.
addEventListener
(
'
ended
'
endedCallback
false
)
;
this
.
mediaStream
.
stop
(
)
;
setTimeout
(
(
)
=
>
{
reject
(
new
Error
(
"
ended
event
never
fired
"
)
)
;
}
ENDED_TIMEOUT_LENGTH
)
;
}
)
;
}
}
}
)
;
function
addLoadEvent
(
)
{
}
var
scriptsReady
=
Promise
.
all
(
[
"
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
"
head
.
js
"
]
.
map
(
script
=
>
{
var
el
=
document
.
createElement
(
"
script
"
)
;
el
.
src
=
script
;
document
.
head
.
appendChild
(
el
)
;
return
new
Promise
(
r
=
>
el
.
onload
=
r
)
;
}
)
)
;
function
createHTML
(
options
)
{
return
scriptsReady
.
then
(
(
)
=
>
realCreateHTML
(
options
)
)
;
}
var
pushPrefs
=
(
.
.
.
p
)
=
>
new
Promise
(
r
=
>
SpecialPowers
.
pushPrefEnv
(
{
set
:
p
}
r
)
)
;
var
noGum
=
(
)
=
>
pushPrefs
(
[
"
media
.
navigator
.
permission
.
disabled
"
false
]
[
"
media
.
navigator
.
permission
.
fake
"
true
]
)
.
then
(
(
)
=
>
navigator
.
mediaDevices
.
enumerateDevices
(
)
)
.
then
(
(
[
device
]
)
=
>
device
&
&
is
(
device
.
label
"
"
"
Test
must
leave
no
active
gUM
streams
behind
.
"
)
)
;
var
runTest
=
testFunction
=
>
scriptsReady
.
then
(
(
)
=
>
runTestWhenReady
(
testFunction
)
)
.
then
(
(
)
=
>
noGum
(
)
)
.
then
(
(
)
=
>
finish
(
)
)
;
