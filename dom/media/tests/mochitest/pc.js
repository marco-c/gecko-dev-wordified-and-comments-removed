"
use
strict
"
;
const
LOOPBACK_ADDR
=
"
127
.
0
.
0
.
"
;
const
iceStateTransitions
=
{
"
new
"
:
[
"
checking
"
"
closed
"
]
"
checking
"
:
[
"
new
"
"
connected
"
"
failed
"
"
closed
"
]
"
connected
"
:
[
"
new
"
"
completed
"
"
disconnected
"
"
closed
"
]
"
completed
"
:
[
"
new
"
"
disconnected
"
"
closed
"
]
"
disconnected
"
:
[
"
new
"
"
connected
"
"
completed
"
"
failed
"
"
closed
"
]
"
failed
"
:
[
"
new
"
"
disconnected
"
"
closed
"
]
"
closed
"
:
[
]
}
const
signalingStateTransitions
=
{
"
stable
"
:
[
"
have
-
local
-
offer
"
"
have
-
remote
-
offer
"
"
closed
"
]
"
have
-
local
-
offer
"
:
[
"
have
-
remote
-
pranswer
"
"
stable
"
"
closed
"
"
have
-
local
-
offer
"
]
"
have
-
remote
-
pranswer
"
:
[
"
stable
"
"
closed
"
"
have
-
remote
-
pranswer
"
]
"
have
-
remote
-
offer
"
:
[
"
have
-
local
-
pranswer
"
"
stable
"
"
closed
"
"
have
-
remote
-
offer
"
]
"
have
-
local
-
pranswer
"
:
[
"
stable
"
"
closed
"
"
have
-
local
-
pranswer
"
]
"
closed
"
:
[
]
}
var
makeDefaultCommands
=
(
)
=
>
{
return
[
]
.
concat
(
commandsPeerConnectionInitial
commandsGetUserMedia
commandsPeerConnectionOfferAnswer
)
;
}
;
function
PeerConnectionTest
(
options
)
{
options
=
options
|
|
{
}
;
options
.
commands
=
options
.
commands
|
|
makeDefaultCommands
(
)
;
options
.
is_local
=
"
is_local
"
in
options
?
options
.
is_local
:
true
;
options
.
is_remote
=
"
is_remote
"
in
options
?
options
.
is_remote
:
true
;
options
.
h264
=
"
h264
"
in
options
?
options
.
h264
:
false
;
options
.
bundle
=
"
bundle
"
in
options
?
options
.
bundle
:
true
;
options
.
rtcpmux
=
"
rtcpmux
"
in
options
?
options
.
rtcpmux
:
true
;
options
.
opus
=
"
opus
"
in
options
?
options
.
opus
:
true
;
options
.
ssrc
=
"
ssrc
"
in
options
?
options
.
ssrc
:
true
;
if
(
iceServersArray
.
length
)
{
if
(
!
options
.
turn_disabled_local
)
{
options
.
config_local
=
options
.
config_local
|
|
{
}
options
.
config_local
.
iceServers
=
iceServersArray
;
}
if
(
!
options
.
turn_disabled_remote
)
{
options
.
config_remote
=
options
.
config_remote
|
|
{
}
options
.
config_remote
.
iceServers
=
iceServersArray
;
}
}
else
if
(
typeof
turnServers
!
=
=
"
undefined
"
)
{
if
(
(
!
options
.
turn_disabled_local
)
&
&
(
turnServers
.
local
)
)
{
if
(
!
options
.
hasOwnProperty
(
"
config_local
"
)
)
{
options
.
config_local
=
{
}
;
}
if
(
!
options
.
config_local
.
hasOwnProperty
(
"
iceServers
"
)
)
{
options
.
config_local
.
iceServers
=
turnServers
.
local
.
iceServers
;
}
}
if
(
(
!
options
.
turn_disabled_remote
)
&
&
(
turnServers
.
remote
)
)
{
if
(
!
options
.
hasOwnProperty
(
"
config_remote
"
)
)
{
options
.
config_remote
=
{
}
;
}
if
(
!
options
.
config_remote
.
hasOwnProperty
(
"
iceServers
"
)
)
{
options
.
config_remote
.
iceServers
=
turnServers
.
remote
.
iceServers
;
}
}
}
if
(
options
.
is_local
)
{
this
.
pcLocal
=
new
PeerConnectionWrapper
(
'
pcLocal
'
options
.
config_local
)
;
}
else
{
this
.
pcLocal
=
null
;
}
if
(
options
.
is_remote
)
{
this
.
pcRemote
=
new
PeerConnectionWrapper
(
'
pcRemote
'
options
.
config_remote
|
|
options
.
config_local
)
;
}
else
{
this
.
pcRemote
=
null
;
}
options
.
steeplechase
=
!
options
.
is_local
|
|
!
options
.
is_remote
;
this
.
chain
=
new
CommandChain
(
this
options
.
commands
)
;
this
.
testOptions
=
options
;
}
function
timerGuard
(
p
time
message
)
{
return
Promise
.
race
(
[
p
wait
(
time
)
.
then
(
(
)
=
>
{
throw
new
Error
(
'
timeout
after
'
+
(
time
/
1000
)
+
'
s
:
'
+
message
)
;
}
)
]
)
;
}
PeerConnectionTest
.
prototype
.
closePC
=
function
(
)
{
info
(
"
Closing
peer
connections
"
)
;
var
closeIt
=
pc
=
>
{
if
(
!
pc
|
|
pc
.
signalingState
=
=
=
"
closed
"
)
{
return
Promise
.
resolve
(
)
;
}
var
promise
=
Promise
.
all
(
[
new
Promise
(
resolve
=
>
{
pc
.
onsignalingstatechange
=
e
=
>
{
is
(
e
.
target
.
signalingState
"
closed
"
"
signalingState
is
closed
"
)
;
resolve
(
)
;
}
;
}
)
Promise
.
all
(
pc
.
_pc
.
getReceivers
(
)
.
filter
(
receiver
=
>
receiver
.
track
.
readyState
=
=
"
live
"
)
.
map
(
receiver
=
>
{
info
(
"
Waiting
for
track
"
+
receiver
.
track
.
id
+
"
(
"
+
receiver
.
track
.
kind
+
"
)
to
end
.
"
)
;
return
haveEvent
(
receiver
.
track
"
ended
"
wait
(
50000
)
)
.
then
(
event
=
>
{
is
(
event
.
target
receiver
.
track
"
Event
target
should
be
the
correct
track
"
)
;
info
(
pc
+
"
ended
fired
for
track
"
+
receiver
.
track
.
id
)
;
}
e
=
>
e
?
Promise
.
reject
(
e
)
:
ok
(
false
"
ended
never
fired
for
track
"
+
receiver
.
track
.
id
)
)
;
}
)
)
]
)
;
pc
.
close
(
)
;
return
promise
;
}
;
return
timerGuard
(
Promise
.
all
(
[
closeIt
(
this
.
pcLocal
)
closeIt
(
this
.
pcRemote
)
]
)
60000
"
failed
to
close
peer
connection
"
)
;
}
;
PeerConnectionTest
.
prototype
.
close
=
function
(
)
{
var
allChannels
=
(
this
.
pcLocal
|
|
this
.
pcRemote
)
.
dataChannels
;
return
timerGuard
(
Promise
.
all
(
allChannels
.
map
(
(
channel
i
)
=
>
this
.
closeDataChannels
(
i
)
)
)
120000
"
failed
to
close
data
channels
"
)
.
then
(
(
)
=
>
this
.
closePC
(
)
)
;
}
;
PeerConnectionTest
.
prototype
.
closeDataChannels
=
function
(
index
)
{
info
(
"
closeDataChannels
called
with
index
:
"
+
index
)
;
var
localChannel
=
null
;
if
(
this
.
pcLocal
)
{
localChannel
=
this
.
pcLocal
.
dataChannels
[
index
]
;
}
var
remoteChannel
=
null
;
if
(
this
.
pcRemote
)
{
remoteChannel
=
this
.
pcRemote
.
dataChannels
[
index
]
;
}
var
setupClosePromise
=
channel
=
>
{
if
(
!
channel
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
channel
.
onclose
=
(
)
=
>
{
is
(
channel
.
readyState
"
closed
"
name
+
"
channel
"
+
index
+
"
closed
"
)
;
resolve
(
)
;
}
;
}
)
;
}
;
var
allClosed
=
Promise
.
all
(
[
setupClosePromise
(
localChannel
)
setupClosePromise
(
remoteChannel
)
]
)
;
var
complete
=
timerGuard
(
allClosed
120000
"
failed
to
close
data
channel
pair
"
)
;
if
(
remoteChannel
)
{
remoteChannel
.
close
(
)
;
}
else
if
(
localChannel
)
{
localChannel
.
close
(
)
;
}
return
complete
;
}
;
PeerConnectionTest
.
prototype
.
send
=
function
(
data
options
)
{
options
=
options
|
|
{
}
;
var
source
=
options
.
sourceChannel
|
|
this
.
pcLocal
.
dataChannels
[
this
.
pcLocal
.
dataChannels
.
length
-
1
]
;
var
target
=
options
.
targetChannel
|
|
this
.
pcRemote
.
dataChannels
[
this
.
pcRemote
.
dataChannels
.
length
-
1
]
;
var
bufferedamount
=
options
.
bufferedAmountLowThreshold
|
|
0
;
var
bufferlow_fired
=
true
;
if
(
bufferedamount
!
=
0
)
{
source
.
bufferedAmountLowThreshold
=
bufferedamount
;
bufferlow_fired
=
false
;
source
.
onbufferedamountlow
=
function
(
)
{
bufferlow_fired
=
true
;
}
;
}
return
new
Promise
(
resolve
=
>
{
target
.
onmessage
=
e
=
>
{
ok
(
bufferlow_fired
"
bufferedamountlow
event
fired
"
)
;
resolve
(
{
channel
:
target
data
:
e
.
data
}
)
;
}
;
source
.
send
(
data
)
;
}
)
;
}
;
PeerConnectionTest
.
prototype
.
createDataChannel
=
function
(
options
)
{
var
remotePromise
;
if
(
!
options
.
negotiated
)
{
this
.
pcRemote
.
expectDataChannel
(
"
pcRemote
expected
data
channel
"
)
;
remotePromise
=
this
.
pcRemote
.
nextDataChannel
;
}
var
localChannel
=
this
.
pcLocal
.
createDataChannel
(
options
)
var
localPromise
=
localChannel
.
opened
;
if
(
options
.
negotiated
)
{
remotePromise
=
localPromise
.
then
(
localChannel
=
>
{
options
.
id
=
options
.
id
|
|
channel
.
id
;
var
remoteChannel
=
this
.
pcRemote
.
createDataChannel
(
options
)
;
return
remoteChannel
.
opened
;
}
)
;
}
return
Promise
.
all
(
[
this
.
pcLocal
.
observedNegotiationNeeded
this
.
pcRemote
.
observedNegotiationNeeded
]
)
.
then
(
(
)
=
>
{
return
Promise
.
all
(
[
localPromise
remotePromise
]
)
.
then
(
result
=
>
{
return
{
local
:
result
[
0
]
remote
:
result
[
1
]
}
;
}
)
;
}
)
;
}
;
PeerConnectionTest
.
prototype
.
createAnswer
=
function
(
peer
)
{
return
peer
.
createAnswer
(
)
.
then
(
answer
=
>
{
this
.
originalAnswer
=
new
RTCSessionDescription
(
JSON
.
parse
(
JSON
.
stringify
(
answer
)
)
)
;
return
answer
;
}
)
;
}
;
PeerConnectionTest
.
prototype
.
createOffer
=
function
(
peer
)
{
return
peer
.
createOffer
(
)
.
then
(
offer
=
>
{
this
.
originalOffer
=
new
RTCSessionDescription
(
JSON
.
parse
(
JSON
.
stringify
(
offer
)
)
)
;
return
offer
;
}
)
;
}
;
PeerConnectionTest
.
prototype
.
setLocalDescription
=
function
(
peer
desc
stateExpected
)
{
var
eventFired
=
new
Promise
(
resolve
=
>
{
peer
.
onsignalingstatechange
=
e
=
>
{
info
(
peer
+
"
:
'
signalingstatechange
'
event
received
"
)
;
var
state
=
e
.
target
.
signalingState
;
if
(
stateExpected
=
=
=
state
)
{
peer
.
setLocalDescStableEventDate
=
new
Date
(
)
;
resolve
(
)
;
}
else
{
ok
(
false
"
This
event
has
either
already
fired
or
there
has
been
a
"
+
"
mismatch
between
event
received
"
+
state
+
"
and
event
expected
"
+
stateExpected
)
;
}
}
;
}
)
;
var
stateChanged
=
peer
.
setLocalDescription
(
desc
)
.
then
(
(
)
=
>
{
peer
.
setLocalDescDate
=
new
Date
(
)
;
}
)
;
peer
.
endOfTrickleSdp
=
peer
.
endOfTrickleIce
.
then
(
(
)
=
>
{
if
(
this
.
testOptions
.
steeplechase
)
{
send_message
(
{
"
type
"
:
"
end_of_trickle_ice
"
}
)
;
}
return
peer
.
_pc
.
localDescription
;
}
)
.
catch
(
e
=
>
ok
(
false
"
Sending
EOC
message
failed
:
"
+
e
)
)
;
return
Promise
.
all
(
[
eventFired
stateChanged
]
)
;
}
;
PeerConnectionTest
.
prototype
.
setMediaConstraints
=
function
(
constraintsLocal
constraintsRemote
)
{
if
(
this
.
pcLocal
)
{
this
.
pcLocal
.
constraints
=
constraintsLocal
;
}
if
(
this
.
pcRemote
)
{
this
.
pcRemote
.
constraints
=
constraintsRemote
;
}
}
;
PeerConnectionTest
.
prototype
.
setOfferOptions
=
function
(
options
)
{
if
(
this
.
pcLocal
)
{
this
.
pcLocal
.
offerOptions
=
options
;
}
}
;
PeerConnectionTest
.
prototype
.
setRemoteDescription
=
function
(
peer
desc
stateExpected
)
{
var
eventFired
=
new
Promise
(
resolve
=
>
{
peer
.
onsignalingstatechange
=
e
=
>
{
info
(
peer
+
"
:
'
signalingstatechange
'
event
received
"
)
;
var
state
=
e
.
target
.
signalingState
;
if
(
stateExpected
=
=
=
state
)
{
peer
.
setRemoteDescStableEventDate
=
new
Date
(
)
;
resolve
(
)
;
}
else
{
ok
(
false
"
This
event
has
either
already
fired
or
there
has
been
a
"
+
"
mismatch
between
event
received
"
+
state
+
"
and
event
expected
"
+
stateExpected
)
;
}
}
;
}
)
;
var
stateChanged
=
peer
.
setRemoteDescription
(
desc
)
.
then
(
(
)
=
>
{
peer
.
setRemoteDescDate
=
new
Date
(
)
;
peer
.
checkMediaTracks
(
)
;
}
)
;
return
Promise
.
all
(
[
eventFired
stateChanged
]
)
;
}
;
PeerConnectionTest
.
prototype
.
updateChainSteps
=
function
(
)
{
if
(
this
.
testOptions
.
h264
)
{
this
.
chain
.
insertAfterEach
(
'
PC_LOCAL_CREATE_OFFER
'
[
PC_LOCAL_REMOVE_ALL_BUT_H264_FROM_OFFER
]
)
;
}
if
(
!
this
.
testOptions
.
bundle
)
{
this
.
chain
.
insertAfterEach
(
'
PC_LOCAL_CREATE_OFFER
'
[
PC_LOCAL_REMOVE_BUNDLE_FROM_OFFER
]
)
;
}
if
(
!
this
.
testOptions
.
rtcpmux
)
{
this
.
chain
.
insertAfterEach
(
'
PC_LOCAL_CREATE_OFFER
'
[
PC_LOCAL_REMOVE_RTCPMUX_FROM_OFFER
]
)
;
}
if
(
!
this
.
testOptions
.
ssrc
)
{
this
.
chain
.
insertAfterEach
(
'
PC_LOCAL_CREATE_OFFER
'
[
PC_LOCAL_REMOVE_SSRC_FROM_OFFER
]
)
;
this
.
chain
.
insertAfterEach
(
'
PC_REMOTE_CREATE_ANSWER
'
[
PC_REMOTE_REMOVE_SSRC_FROM_ANSWER
]
)
;
}
if
(
!
this
.
testOptions
.
is_local
)
{
this
.
chain
.
filterOut
(
/
^
PC_LOCAL
/
)
;
}
if
(
!
this
.
testOptions
.
is_remote
)
{
this
.
chain
.
filterOut
(
/
^
PC_REMOTE
/
)
;
}
}
;
PeerConnectionTest
.
prototype
.
run
=
function
(
)
{
this
.
updateChainSteps
(
)
;
var
finished
=
(
)
=
>
{
if
(
window
.
SimpleTest
)
{
networkTestFinished
(
)
;
}
else
{
finish
(
)
;
}
}
;
return
this
.
chain
.
execute
(
)
.
then
(
(
)
=
>
this
.
close
(
)
)
.
catch
(
e
=
>
ok
(
false
'
Error
in
test
execution
:
'
+
e
+
(
(
typeof
e
.
stack
=
=
=
'
string
'
)
?
(
'
'
+
e
.
stack
.
split
(
'
\
n
'
)
.
join
(
'
.
.
.
'
)
)
:
'
'
)
)
)
.
then
(
(
)
=
>
finished
(
)
)
.
catch
(
e
=
>
ok
(
false
"
Error
in
finished
(
)
"
)
)
;
}
;
PeerConnectionTest
.
prototype
.
iceCandidateHandler
=
function
(
caller
candidate
)
{
info
(
"
Received
:
"
+
JSON
.
stringify
(
candidate
)
+
"
from
"
+
caller
)
;
var
target
=
null
;
if
(
caller
.
includes
(
"
pcLocal
"
)
)
{
if
(
this
.
pcRemote
)
{
target
=
this
.
pcRemote
;
}
}
else
if
(
caller
.
includes
(
"
pcRemote
"
)
)
{
if
(
this
.
pcLocal
)
{
target
=
this
.
pcLocal
;
}
}
else
{
ok
(
false
"
received
event
from
unknown
caller
:
"
+
caller
)
;
return
;
}
if
(
target
)
{
target
.
storeOrAddIceCandidate
(
candidate
)
;
}
else
{
info
(
"
sending
ice
candidate
to
signaling
server
"
)
;
send_message
(
{
"
type
"
:
"
ice_candidate
"
"
ice_candidate
"
:
candidate
}
)
;
}
}
;
PeerConnectionTest
.
prototype
.
setupSignalingClient
=
function
(
)
{
this
.
signalingMessageQueue
=
[
]
;
this
.
signalingCallbacks
=
{
}
;
this
.
signalingLoopRun
=
true
;
var
queueMessage
=
message
=
>
{
info
(
"
Received
signaling
message
:
"
+
JSON
.
stringify
(
message
)
)
;
var
fired
=
false
;
Object
.
keys
(
this
.
signalingCallbacks
)
.
forEach
(
name
=
>
{
if
(
name
=
=
=
message
.
type
)
{
info
(
"
Invoking
callback
for
message
type
:
"
+
name
)
;
this
.
signalingCallbacks
[
name
]
(
message
)
;
fired
=
true
;
}
}
)
;
if
(
!
fired
)
{
this
.
signalingMessageQueue
.
push
(
message
)
;
info
(
"
signalingMessageQueue
.
length
:
"
+
this
.
signalingMessageQueue
.
length
)
;
}
if
(
this
.
signalingLoopRun
)
{
wait_for_message
(
)
.
then
(
queueMessage
)
;
}
else
{
info
(
"
Exiting
signaling
message
event
loop
"
)
;
}
}
;
wait_for_message
(
)
.
then
(
queueMessage
)
;
}
PeerConnectionTest
.
prototype
.
signalingMessagesFinished
=
function
(
)
{
this
.
signalingLoopRun
=
false
;
}
PeerConnectionTest
.
prototype
.
registerSignalingCallback
=
function
(
messageType
onMessage
)
{
this
.
signalingCallbacks
[
messageType
]
=
onMessage
;
}
;
PeerConnectionTest
.
prototype
.
getSignalingMessage
=
function
(
messageType
)
{
var
i
=
this
.
signalingMessageQueue
.
findIndex
(
m
=
>
m
.
type
=
=
=
messageType
)
;
if
(
i
>
=
0
)
{
info
(
"
invoking
callback
on
message
"
+
i
+
"
from
message
queue
for
message
type
:
"
+
messageType
)
;
return
Promise
.
resolve
(
this
.
signalingMessageQueue
.
splice
(
i
1
)
[
0
]
)
;
}
return
new
Promise
(
resolve
=
>
this
.
registerSignalingCallback
(
messageType
resolve
)
)
;
}
;
function
DataChannelWrapper
(
dataChannel
peerConnectionWrapper
)
{
this
.
_channel
=
dataChannel
;
this
.
_pc
=
peerConnectionWrapper
;
info
(
"
Creating
"
+
this
)
;
createOneShotEventWrapper
(
this
this
.
_channel
'
close
'
)
;
createOneShotEventWrapper
(
this
this
.
_channel
'
error
'
)
;
createOneShotEventWrapper
(
this
this
.
_channel
'
message
'
)
;
createOneShotEventWrapper
(
this
this
.
_channel
'
bufferedamountlow
'
)
;
this
.
opened
=
timerGuard
(
new
Promise
(
resolve
=
>
{
this
.
_channel
.
onopen
=
(
)
=
>
{
this
.
_channel
.
onopen
=
unexpectedEvent
(
this
'
onopen
'
)
;
is
(
this
.
readyState
"
open
"
"
data
channel
is
'
open
'
after
'
onopen
'
"
)
;
resolve
(
this
)
;
}
;
}
)
180000
"
channel
didn
'
t
open
in
time
"
)
;
}
DataChannelWrapper
.
prototype
=
{
get
binaryType
(
)
{
return
this
.
_channel
.
binaryType
;
}
set
binaryType
(
type
)
{
this
.
_channel
.
binaryType
=
type
;
}
get
label
(
)
{
return
this
.
_channel
.
label
;
}
get
protocol
(
)
{
return
this
.
_channel
.
protocol
;
}
get
id
(
)
{
return
this
.
_channel
.
id
;
}
get
reliable
(
)
{
return
this
.
_channel
.
reliable
;
}
get
readyState
(
)
{
return
this
.
_channel
.
readyState
;
}
set
bufferedAmountLowThreshold
(
amount
)
{
this
.
_channel
.
bufferedAmountLowThreshold
=
amount
;
}
close
:
function
(
)
{
info
(
this
+
"
:
Closing
channel
"
)
;
this
.
_channel
.
close
(
)
;
}
send
:
function
(
data
)
{
info
(
this
+
"
:
Sending
data
'
"
+
data
+
"
'
"
)
;
this
.
_channel
.
send
(
data
)
;
}
toString
:
function
(
)
{
return
"
DataChannelWrapper
(
"
+
this
.
_pc
.
label
+
'
_
'
+
this
.
_channel
.
label
+
"
)
"
;
}
}
;
function
PeerConnectionWrapper
(
label
configuration
)
{
this
.
configuration
=
configuration
;
if
(
configuration
&
&
configuration
.
label_suffix
)
{
label
=
label
+
"
_
"
+
configuration
.
label_suffix
;
}
this
.
label
=
label
;
this
.
whenCreated
=
Date
.
now
(
)
;
this
.
constraints
=
[
]
;
this
.
offerOptions
=
{
}
;
this
.
dataChannels
=
[
]
;
this
.
_local_ice_candidates
=
[
]
;
this
.
_remote_ice_candidates
=
[
]
;
this
.
localRequiresTrickleIce
=
false
;
this
.
remoteRequiresTrickleIce
=
false
;
this
.
localMediaElements
=
[
]
;
this
.
remoteMediaElements
=
[
]
;
this
.
audioElementsOnly
=
false
;
this
.
_sendStreams
=
[
]
;
this
.
expectedLocalTrackInfoById
=
{
}
;
this
.
expectedSignalledTrackInfoById
=
{
}
;
this
.
observedRemoteTrackInfoById
=
{
}
;
this
.
disableRtpCountChecking
=
false
;
this
.
iceConnectedResolve
;
this
.
iceConnectedReject
;
this
.
iceConnected
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
iceConnectedResolve
=
resolve
;
this
.
iceConnectedReject
=
reject
;
}
)
;
this
.
iceCheckingRestartExpected
=
false
;
this
.
iceCheckingIceRollbackExpected
=
false
;
info
(
"
Creating
"
+
this
)
;
this
.
_pc
=
new
RTCPeerConnection
(
this
.
configuration
)
;
this
.
ice_connection_callbacks
=
{
}
;
this
.
_pc
.
oniceconnectionstatechange
=
e
=
>
{
isnot
(
typeof
this
.
_pc
.
iceConnectionState
"
undefined
"
"
iceConnectionState
should
not
be
undefined
"
)
;
var
iceState
=
this
.
_pc
.
iceConnectionState
;
info
(
this
+
"
:
oniceconnectionstatechange
fired
new
state
is
:
"
+
iceState
)
;
Object
.
keys
(
this
.
ice_connection_callbacks
)
.
forEach
(
name
=
>
{
this
.
ice_connection_callbacks
[
name
]
(
)
;
}
)
;
if
(
iceState
=
=
=
"
connected
"
)
{
this
.
iceConnectedResolve
(
)
;
}
else
if
(
iceState
=
=
=
"
failed
"
)
{
this
.
iceConnectedReject
(
)
;
}
}
;
this
.
_pc
.
onicegatheringstatechange
=
e
=
>
{
isnot
(
typeof
this
.
_pc
.
iceGatheringState
"
undefined
"
"
iceGetheringState
should
not
be
undefined
"
)
;
var
gatheringState
=
this
.
_pc
.
iceGatheringState
;
info
(
this
+
"
:
onicegatheringstatechange
fired
new
state
is
:
"
+
gatheringState
)
;
}
;
createOneShotEventWrapper
(
this
this
.
_pc
'
datachannel
'
)
;
this
.
_pc
.
addEventListener
(
'
datachannel
'
e
=
>
{
var
wrapper
=
new
DataChannelWrapper
(
e
.
channel
this
)
;
this
.
dataChannels
.
push
(
wrapper
)
;
}
)
;
createOneShotEventWrapper
(
this
this
.
_pc
'
signalingstatechange
'
)
;
createOneShotEventWrapper
(
this
this
.
_pc
'
negotiationneeded
'
)
;
}
PeerConnectionWrapper
.
prototype
=
{
getSenders
:
function
(
)
{
return
this
.
_pc
.
getSenders
(
)
;
}
getReceivers
:
function
(
)
{
return
this
.
_pc
.
getReceivers
(
)
;
}
get
localDescription
(
)
{
return
this
.
_pc
.
localDescription
;
}
get
remoteDescription
(
)
{
return
this
.
_pc
.
remoteDescription
;
}
get
signalingState
(
)
{
return
this
.
_pc
.
signalingState
;
}
get
iceConnectionState
(
)
{
return
this
.
_pc
.
iceConnectionState
;
}
setIdentityProvider
:
function
(
provider
protocol
identity
)
{
this
.
_pc
.
setIdentityProvider
(
provider
protocol
identity
)
;
}
elementPrefix
:
direction
=
>
{
return
[
this
.
label
direction
]
.
join
(
'
_
'
)
;
}
getMediaElementForTrack
:
function
(
track
direction
)
{
var
prefix
=
this
.
elementPrefix
(
direction
)
;
return
getMediaElementForTrack
(
track
prefix
)
;
}
createMediaElementForTrack
:
function
(
track
direction
)
{
var
prefix
=
this
.
elementPrefix
(
direction
)
;
return
createMediaElementForTrack
(
track
prefix
)
;
}
ensureMediaElement
:
function
(
track
direction
)
{
var
prefix
=
this
.
elementPrefix
(
direction
)
;
var
element
=
this
.
getMediaElementForTrack
(
track
direction
)
;
if
(
!
element
)
{
element
=
this
.
createMediaElementForTrack
(
track
direction
)
;
if
(
direction
=
=
"
local
"
)
{
this
.
localMediaElements
.
push
(
element
)
;
}
else
if
(
direction
=
=
"
remote
"
)
{
this
.
remoteMediaElements
.
push
(
element
)
;
}
}
element
.
srcObject
=
new
MediaStream
(
[
track
]
)
;
element
.
play
(
)
;
}
addSendStream
:
function
(
stream
)
{
this
.
_sendStreams
.
push
(
stream
)
;
}
getStreamForSendTrack
:
function
(
track
)
{
return
this
.
_sendStreams
.
find
(
str
=
>
str
.
getTrackById
(
track
.
id
)
)
;
}
getStreamForRecvTrack
:
function
(
track
)
{
return
this
.
_pc
.
getRemoteStreams
(
)
.
find
(
s
=
>
!
!
s
.
getTrackById
(
track
.
id
)
)
;
}
attachLocalTrack
:
function
(
track
stream
)
{
info
(
"
Got
a
local
"
+
track
.
kind
+
"
track
"
)
;
this
.
expectNegotiationNeeded
(
)
;
var
sender
=
this
.
_pc
.
addTrack
(
track
stream
)
;
is
(
sender
.
track
track
"
addTrack
returns
sender
"
)
;
ok
(
track
.
id
"
track
has
id
"
)
;
ok
(
track
.
kind
"
track
has
kind
"
)
;
ok
(
stream
.
id
"
stream
has
id
"
)
;
this
.
expectedLocalTrackInfoById
[
track
.
id
]
=
{
type
:
track
.
kind
streamId
:
stream
.
id
}
;
this
.
expectedSignalledTrackInfoById
[
track
.
id
]
=
this
.
expectedLocalTrackInfoById
[
track
.
id
]
;
this
.
addSendStream
(
stream
)
;
this
.
ensureMediaElement
(
track
"
local
"
)
;
return
this
.
observedNegotiationNeeded
;
}
attachLocalStream
:
function
(
stream
useAddTransceiver
)
{
info
(
"
Got
local
media
stream
:
(
"
+
stream
.
id
+
"
)
"
)
;
this
.
expectNegotiationNeeded
(
)
;
if
(
useAddTransceiver
)
{
info
(
"
Using
addTransceiver
(
on
PC
)
.
"
)
;
stream
.
getTracks
(
)
.
forEach
(
track
=
>
{
var
transceiver
=
this
.
_pc
.
addTransceiver
(
track
{
streams
:
[
stream
]
}
)
;
is
(
transceiver
.
sender
.
track
track
"
addTransceiver
returns
sender
"
)
;
}
)
;
}
else
if
(
Math
.
random
(
)
<
0
.
5
)
{
info
(
"
Using
addStream
.
"
)
;
this
.
_pc
.
addStream
(
stream
)
;
ok
(
this
.
_pc
.
getSenders
(
)
.
find
(
sender
=
>
sender
.
track
=
=
stream
.
getTracks
(
)
[
0
]
)
"
addStream
returns
sender
"
)
;
}
else
{
info
(
"
Using
addTrack
(
on
PC
)
.
"
)
;
stream
.
getTracks
(
)
.
forEach
(
track
=
>
{
var
sender
=
this
.
_pc
.
addTrack
(
track
stream
)
;
is
(
sender
.
track
track
"
addTrack
returns
sender
"
)
;
}
)
;
}
this
.
addSendStream
(
stream
)
;
stream
.
getTracks
(
)
.
forEach
(
track
=
>
{
ok
(
track
.
id
"
track
has
id
"
)
;
ok
(
track
.
kind
"
track
has
kind
"
)
;
this
.
expectedLocalTrackInfoById
[
track
.
id
]
=
{
type
:
track
.
kind
streamId
:
stream
.
id
}
;
this
.
expectedSignalledTrackInfoById
[
track
.
id
]
=
this
.
expectedLocalTrackInfoById
[
track
.
id
]
;
this
.
ensureMediaElement
(
track
"
local
"
)
;
}
)
;
return
this
.
observedNegotiationNeeded
;
}
removeSender
:
function
(
index
)
{
var
sender
=
this
.
_pc
.
getSenders
(
)
[
index
]
;
delete
this
.
expectedLocalTrackInfoById
[
sender
.
track
.
id
]
;
this
.
expectNegotiationNeeded
(
)
;
this
.
_pc
.
removeTrack
(
sender
)
;
return
this
.
observedNegotiationNeeded
;
}
senderReplaceTrack
:
function
(
sender
withTrack
stream
)
{
delete
this
.
expectedLocalTrackInfoById
[
sender
.
track
.
id
]
;
this
.
expectedLocalTrackInfoById
[
withTrack
.
id
]
=
{
type
:
withTrack
.
kind
streamId
:
stream
.
id
}
;
this
.
addSendStream
(
stream
)
;
this
.
ensureMediaElement
(
withTrack
'
local
'
)
;
return
sender
.
replaceTrack
(
withTrack
)
;
}
getUserMedia
:
async
function
(
constraints
)
{
var
stream
=
await
getUserMedia
(
constraints
)
;
if
(
constraints
.
audio
)
{
stream
.
getAudioTracks
(
)
.
forEach
(
track
=
>
{
info
(
this
+
"
gUM
local
stream
"
+
stream
.
id
+
"
with
audio
track
"
+
track
.
id
)
;
}
)
;
}
if
(
constraints
.
video
)
{
stream
.
getVideoTracks
(
)
.
forEach
(
track
=
>
{
info
(
this
+
"
gUM
local
stream
"
+
stream
.
id
+
"
with
video
track
"
+
track
.
id
)
;
}
)
;
}
return
stream
;
}
getAllUserMedia
:
function
(
constraintsList
)
{
if
(
constraintsList
.
length
=
=
=
0
)
{
info
(
"
Skipping
GUM
:
no
UserMedia
requested
"
)
;
return
Promise
.
resolve
(
)
;
}
info
(
"
Get
"
+
constraintsList
.
length
+
"
local
streams
"
)
;
return
Promise
.
all
(
constraintsList
.
map
(
constraints
=
>
this
.
getUserMedia
(
constraints
)
)
)
;
}
getAllUserMediaAndAddStreams
:
async
function
(
constraintsList
)
{
var
streams
=
await
this
.
getAllUserMedia
(
constraintsList
)
;
if
(
!
streams
)
{
return
;
}
return
Promise
.
all
(
streams
.
map
(
stream
=
>
this
.
attachLocalStream
(
stream
)
)
)
;
}
getAllUserMediaAndAddTransceivers
:
async
function
(
constraintsList
)
{
var
streams
=
await
this
.
getAllUserMedia
(
constraintsList
)
;
if
(
!
streams
)
{
return
;
}
return
Promise
.
all
(
streams
.
map
(
stream
=
>
this
.
attachLocalStream
(
stream
true
)
)
)
;
}
expectDataChannel
:
function
(
message
)
{
this
.
nextDataChannel
=
new
Promise
(
resolve
=
>
{
this
.
ondatachannel
=
e
=
>
{
ok
(
e
.
channel
message
)
;
is
(
e
.
channel
.
readyState
"
connecting
"
"
data
channel
in
'
connecting
after
'
ondatachannel
'
'
"
)
;
resolve
(
e
.
channel
)
;
}
;
}
)
;
}
createDataChannel
:
function
(
options
)
{
var
label
=
'
channel_
'
+
this
.
dataChannels
.
length
;
info
(
this
+
"
:
Create
data
channel
'
"
+
label
)
;
if
(
!
this
.
dataChannels
.
length
)
{
this
.
expectNegotiationNeeded
(
)
;
}
var
channel
=
this
.
_pc
.
createDataChannel
(
label
options
)
;
if
(
!
this
.
dataChannels
.
length
)
{
is
(
channel
.
readyState
"
connecting
"
"
initial
readyState
is
'
connecting
'
"
)
;
}
else
{
is
(
channel
.
readyState
"
open
"
"
subsequent
readyState
is
'
open
'
"
)
;
}
var
wrapper
=
new
DataChannelWrapper
(
channel
this
)
;
this
.
dataChannels
.
push
(
wrapper
)
;
return
wrapper
;
}
createOffer
:
function
(
)
{
return
this
.
_pc
.
createOffer
(
this
.
offerOptions
)
.
then
(
offer
=
>
{
info
(
"
Got
offer
:
"
+
JSON
.
stringify
(
offer
)
)
;
this
.
_latest_offer
=
offer
;
return
offer
;
}
)
;
}
createAnswer
:
function
(
)
{
return
this
.
_pc
.
createAnswer
(
)
.
then
(
answer
=
>
{
info
(
this
+
"
:
Got
answer
:
"
+
JSON
.
stringify
(
answer
)
)
;
this
.
_last_answer
=
answer
;
return
answer
;
}
)
;
}
setLocalDescription
:
function
(
desc
)
{
this
.
observedNegotiationNeeded
=
undefined
;
return
this
.
_pc
.
setLocalDescription
(
desc
)
.
then
(
(
)
=
>
{
info
(
this
+
"
:
Successfully
set
the
local
description
"
)
;
}
)
;
}
setLocalDescriptionAndFail
:
function
(
desc
)
{
return
this
.
_pc
.
setLocalDescription
(
desc
)
.
then
(
generateErrorCallback
(
"
setLocalDescription
should
have
failed
.
"
)
err
=
>
{
info
(
this
+
"
:
As
expected
failed
to
set
the
local
description
"
)
;
return
err
;
}
)
;
}
setRemoteDescription
:
function
(
desc
)
{
this
.
observedNegotiationNeeded
=
undefined
;
return
this
.
_pc
.
setRemoteDescription
(
desc
)
.
then
(
(
)
=
>
{
info
(
this
+
"
:
Successfully
set
remote
description
"
)
;
if
(
desc
.
type
=
=
"
rollback
"
)
{
this
.
holdIceCandidates
=
new
Promise
(
r
=
>
this
.
releaseIceCandidates
=
r
)
;
}
else
{
this
.
releaseIceCandidates
(
)
;
}
}
)
;
}
setRemoteDescriptionAndFail
:
function
(
desc
)
{
return
this
.
_pc
.
setRemoteDescription
(
desc
)
.
then
(
generateErrorCallback
(
"
setRemoteDescription
should
have
failed
.
"
)
err
=
>
{
info
(
this
+
"
:
As
expected
failed
to
set
the
remote
description
"
)
;
return
err
;
}
)
;
}
logSignalingState
:
function
(
)
{
this
.
signalingStateLog
=
[
this
.
_pc
.
signalingState
]
;
this
.
_pc
.
addEventListener
(
'
signalingstatechange
'
e
=
>
{
var
newstate
=
this
.
_pc
.
signalingState
;
var
oldstate
=
this
.
signalingStateLog
[
this
.
signalingStateLog
.
length
-
1
]
if
(
Object
.
keys
(
signalingStateTransitions
)
.
includes
(
oldstate
)
)
{
ok
(
signalingStateTransitions
[
oldstate
]
.
includes
(
newstate
)
this
+
"
:
legal
signaling
state
transition
from
"
+
oldstate
+
"
to
"
+
newstate
)
;
}
else
{
ok
(
false
this
+
"
:
old
signaling
state
"
+
oldstate
+
"
missing
in
signaling
transition
array
"
)
;
}
this
.
signalingStateLog
.
push
(
newstate
)
;
}
)
;
}
checkTrackIsExpected
:
function
(
trackId
kind
expectedTrackInfoById
observedTrackInfoById
)
{
ok
(
expectedTrackInfoById
[
trackId
]
"
track
id
"
+
trackId
+
"
was
expected
"
)
;
ok
(
!
observedTrackInfoById
[
trackId
]
"
track
id
"
+
trackId
+
"
was
not
yet
observed
"
)
;
var
observedKind
=
kind
;
var
expectedKind
=
expectedTrackInfoById
[
trackId
]
.
type
;
is
(
observedKind
expectedKind
"
track
id
"
+
trackId
+
"
was
of
kind
"
+
observedKind
+
"
which
matches
"
+
expectedKind
)
;
observedTrackInfoById
[
trackId
]
=
expectedTrackInfoById
[
trackId
]
;
}
isTrackOnPC
:
function
(
track
)
{
return
!
!
this
.
getStreamForRecvTrack
(
track
)
;
}
allExpectedTracksAreObserved
:
function
(
expected
observed
)
{
return
Object
.
keys
(
expected
)
.
every
(
trackId
=
>
observed
[
trackId
]
)
;
}
getWebrtcTrackId
:
function
(
receiveTrack
)
{
let
matchingTransceiver
=
this
.
_pc
.
getTransceivers
(
)
.
find
(
transceiver
=
>
transceiver
.
receiver
.
track
=
=
receiveTrack
)
;
if
(
!
matchingTransceiver
)
{
return
null
;
}
return
matchingTransceiver
.
getRemoteTrackId
(
)
;
}
setupTrackEventHandler
:
function
(
)
{
this
.
_pc
.
addEventListener
(
'
track
'
event
=
>
{
info
(
this
+
"
:
'
ontrack
'
event
fired
for
"
+
event
.
track
.
id
+
"
(
SDP
msid
is
"
+
this
.
getWebrtcTrackId
(
event
.
track
)
+
"
)
"
)
;
let
trackId
=
this
.
getWebrtcTrackId
(
event
.
track
)
;
ok
(
!
this
.
observedRemoteTrackInfoById
[
trackId
]
"
track
id
"
+
trackId
+
"
was
not
yet
observed
"
)
;
this
.
observedRemoteTrackInfoById
[
trackId
]
=
{
type
:
event
.
track
.
kind
}
;
ok
(
this
.
isTrackOnPC
(
event
.
track
)
"
Found
track
"
+
event
.
track
.
id
)
;
this
.
ensureMediaElement
(
event
.
track
'
remote
'
)
;
}
)
;
}
storeOrAddIceCandidate
:
function
(
candidate
)
{
this
.
_remote_ice_candidates
.
push
(
candidate
)
;
if
(
this
.
signalingState
=
=
=
'
closed
'
)
{
info
(
"
Received
ICE
candidate
for
closed
PeerConnection
-
discarding
"
)
;
return
;
}
this
.
holdIceCandidates
.
then
(
(
)
=
>
{
info
(
this
+
"
:
adding
ICE
candidate
"
+
JSON
.
stringify
(
candidate
)
)
;
return
this
.
_pc
.
addIceCandidate
(
candidate
)
;
}
)
.
then
(
(
)
=
>
ok
(
true
this
+
"
successfully
added
an
ICE
candidate
"
)
)
.
catch
(
e
=
>
ok
(
false
this
+
"
adding
ICE
candidate
failed
with
:
"
+
e
.
message
)
)
;
}
logIceConnectionState
:
function
(
)
{
this
.
iceConnectionLog
=
[
this
.
_pc
.
iceConnectionState
]
;
this
.
ice_connection_callbacks
.
logIceStatus
=
(
)
=
>
{
var
newstate
=
this
.
_pc
.
iceConnectionState
;
var
oldstate
=
this
.
iceConnectionLog
[
this
.
iceConnectionLog
.
length
-
1
]
if
(
Object
.
keys
(
iceStateTransitions
)
.
includes
(
oldstate
)
)
{
if
(
this
.
iceCheckingRestartExpected
)
{
is
(
newstate
"
checking
"
"
iceconnectionstate
event
\
'
"
+
newstate
+
"
\
'
matches
expected
state
\
'
checking
\
'
"
)
;
this
.
iceCheckingRestartExpected
=
false
;
}
else
if
(
this
.
iceCheckingIceRollbackExpected
)
{
is
(
newstate
"
connected
"
"
iceconnectionstate
event
\
'
"
+
newstate
+
"
\
'
matches
expected
state
\
'
connected
\
'
"
)
;
this
.
iceCheckingIceRollbackExpected
=
false
;
}
else
{
ok
(
iceStateTransitions
[
oldstate
]
.
includes
(
newstate
)
this
+
"
:
legal
ICE
state
transition
from
"
+
oldstate
+
"
to
"
+
newstate
)
;
}
}
else
{
ok
(
false
this
+
"
:
old
ICE
state
"
+
oldstate
+
"
missing
in
ICE
transition
array
"
)
;
}
this
.
iceConnectionLog
.
push
(
newstate
)
;
}
;
}
expectIceChecking
:
function
(
)
{
this
.
iceCheckingRestartExpected
=
true
;
this
.
iceConnected
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
iceConnectedResolve
=
resolve
;
this
.
iceConnectedReject
=
reject
;
}
)
;
}
waitForIceConnected
:
function
(
)
{
return
this
.
iceConnected
;
}
setupIceCandidateHandler
:
function
(
test
candidateHandler
)
{
candidateHandler
=
candidateHandler
|
|
test
.
iceCandidateHandler
.
bind
(
test
)
;
var
resolveEndOfTrickle
;
this
.
endOfTrickleIce
=
new
Promise
(
r
=
>
resolveEndOfTrickle
=
r
)
;
this
.
holdIceCandidates
=
new
Promise
(
r
=
>
this
.
releaseIceCandidates
=
r
)
;
this
.
_pc
.
onicecandidate
=
anEvent
=
>
{
if
(
!
anEvent
.
candidate
)
{
this
.
_pc
.
onicecandidate
=
(
)
=
>
ok
(
false
this
.
label
+
"
received
ICE
candidate
after
end
of
trickle
"
)
;
info
(
this
.
label
+
"
:
received
end
of
trickle
ICE
event
"
)
;
ok
(
this
.
_pc
.
iceGatheringState
=
=
=
'
complete
'
"
ICE
gathering
state
has
reached
complete
"
)
;
resolveEndOfTrickle
(
this
.
label
)
;
return
;
}
info
(
this
.
label
+
"
:
iceCandidate
=
"
+
JSON
.
stringify
(
anEvent
.
candidate
)
)
;
ok
(
anEvent
.
candidate
.
candidate
.
length
>
0
"
ICE
candidate
contains
candidate
"
)
;
ok
(
anEvent
.
candidate
.
sdpMid
.
length
>
0
"
SDP
mid
not
empty
"
)
;
var
mSections
=
this
.
localDescription
.
sdp
.
split
(
"
\
r
\
nm
=
"
)
;
sdputils
.
checkSdpCLineNotDefault
(
mSections
[
anEvent
.
candidate
.
sdpMLineIndex
+
1
]
this
.
label
)
;
ok
(
typeof
anEvent
.
candidate
.
sdpMLineIndex
=
=
=
'
number
'
"
SDP
MLine
Index
needs
to
exist
"
)
;
this
.
_local_ice_candidates
.
push
(
anEvent
.
candidate
)
;
candidateHandler
(
this
.
label
anEvent
.
candidate
)
;
}
;
}
checkLocalMediaTracks
:
function
(
)
{
var
observed
=
{
}
;
info
(
this
+
"
Checking
local
tracks
"
+
JSON
.
stringify
(
this
.
expectedLocalTrackInfoById
)
)
;
this
.
_pc
.
getSenders
(
)
.
forEach
(
sender
=
>
{
if
(
sender
.
track
)
{
this
.
checkTrackIsExpected
(
sender
.
track
.
id
sender
.
track
.
kind
this
.
expectedLocalTrackInfoById
observed
)
;
}
}
)
;
Object
.
keys
(
this
.
expectedLocalTrackInfoById
)
.
forEach
(
id
=
>
ok
(
observed
[
id
]
this
+
"
local
id
"
+
id
+
"
was
observed
"
)
)
;
}
checkMediaTracks
:
function
(
)
{
this
.
checkLocalMediaTracks
(
)
;
}
checkMsids
:
function
(
)
{
var
checkSdpForMsids
=
(
desc
expectedTrackInfo
side
)
=
>
{
Object
.
keys
(
expectedTrackInfo
)
.
forEach
(
trackId
=
>
{
var
streamId
=
expectedTrackInfo
[
trackId
]
.
streamId
;
ok
(
desc
.
sdp
.
match
(
new
RegExp
(
"
a
=
msid
:
"
+
streamId
+
"
"
+
trackId
)
)
this
+
"
:
"
+
side
+
"
SDP
contains
stream
"
+
streamId
+
"
and
track
"
+
trackId
)
;
}
)
;
}
;
checkSdpForMsids
(
this
.
localDescription
this
.
expectedSignalledTrackInfoById
"
local
"
)
;
}
markRemoteTracksAsNegotiated
:
function
(
)
{
Object
.
values
(
this
.
observedRemoteTrackInfoById
)
.
forEach
(
trackInfo
=
>
trackInfo
.
negotiated
=
true
)
;
}
rollbackRemoteTracksIfNotNegotiated
:
function
(
)
{
Object
.
keys
(
this
.
observedRemoteTrackInfoById
)
.
forEach
(
id
=
>
{
if
(
!
this
.
observedRemoteTrackInfoById
[
id
]
.
negotiated
)
{
delete
this
.
observedRemoteTrackInfoById
[
id
]
;
}
}
)
;
}
waitForMediaElementFlow
:
function
(
element
)
{
info
(
"
Checking
data
flow
for
element
:
"
+
element
.
id
)
;
is
(
element
.
ended
!
element
.
srcObject
.
active
"
Element
ended
should
be
the
inverse
of
the
MediaStream
'
s
active
state
"
)
;
if
(
element
.
ended
)
{
is
(
element
.
readyState
element
.
HAVE_CURRENT_DATA
"
Element
"
+
element
.
id
+
"
is
ended
and
should
have
had
data
"
)
;
return
Promise
.
resolve
(
)
;
}
const
haveEnoughData
=
(
element
.
readyState
=
=
element
.
HAVE_ENOUGH_DATA
?
Promise
.
resolve
(
)
:
haveEvent
(
element
"
canplay
"
wait
(
60000
new
Error
(
"
Timeout
for
element
"
+
element
.
id
)
)
)
)
.
then
(
_
=
>
info
(
"
Element
"
+
element
.
id
+
"
has
enough
data
.
"
)
)
;
const
startTime
=
element
.
currentTime
;
const
timeProgressed
=
timeout
(
listenUntil
(
element
"
timeupdate
"
_
=
>
element
.
currentTime
>
startTime
)
60000
"
Element
"
+
element
.
id
+
"
should
progress
currentTime
"
)
.
then
(
)
;
return
Promise
.
all
(
[
haveEnoughData
timeProgressed
]
)
;
}
async
waitForRtpFlow
(
track
)
{
info
(
"
waitForRtpFlow
(
"
+
track
.
id
+
"
)
"
)
;
let
hasFlow
=
(
stats
retries
)
=
>
{
info
(
"
Checking
for
stats
in
"
+
JSON
.
stringify
(
stats
)
+
"
for
"
+
track
.
kind
+
"
track
"
+
track
.
id
+
"
retry
number
"
+
retries
)
;
let
rtp
=
stats
.
get
(
[
.
.
.
Object
.
keys
(
stats
)
]
.
find
(
key
=
>
!
stats
.
get
(
key
)
.
isRemote
&
&
stats
.
get
(
key
)
.
type
.
endsWith
(
"
bound
-
rtp
"
)
)
)
;
if
(
!
rtp
)
{
return
false
;
}
info
(
"
Should
have
RTP
stats
for
track
"
+
track
.
id
)
;
info
(
"
RTP
stats
:
"
+
JSON
.
stringify
(
rtp
)
)
;
let
nrPackets
=
rtp
[
rtp
.
type
=
=
"
outbound
-
rtp
"
?
"
packetsSent
"
:
"
packetsReceived
"
]
;
info
(
"
Track
"
+
track
.
id
+
"
has
"
+
nrPackets
+
"
"
+
rtp
.
type
+
"
RTP
packets
.
"
)
;
return
nrPackets
>
0
;
}
;
const
retryInterval
=
500
;
const
timeout
=
30000
;
let
retry
=
0
;
for
(
let
remaining
=
timeout
;
remaining
>
=
0
;
remaining
-
=
retryInterval
)
{
let
stats
=
await
this
.
_pc
.
getStats
(
track
)
;
if
(
hasFlow
(
stats
retry
+
+
)
)
{
ok
(
true
"
RTP
flowing
for
"
+
track
.
kind
+
"
track
"
+
track
.
id
)
;
return
stats
;
}
await
wait
(
retryInterval
)
;
}
throw
new
Error
(
"
Timeout
checking
for
stats
for
track
"
+
track
.
id
+
"
after
at
least
"
+
timeout
+
"
ms
"
)
;
}
getExpectedActiveReceiveTracks
:
function
(
)
{
return
this
.
_pc
.
getTransceivers
(
)
.
filter
(
t
=
>
{
return
!
t
.
stopped
&
&
t
.
currentDirection
&
&
(
t
.
currentDirection
!
=
"
inactive
"
)
&
&
(
t
.
currentDirection
!
=
"
sendonly
"
)
;
}
)
.
map
(
t
=
>
{
info
(
"
Found
transceiver
that
should
be
receiving
RTP
:
mid
=
"
+
t
.
mid
+
"
currentDirection
=
"
+
t
.
currentDirection
+
"
kind
=
"
+
t
.
receiver
.
track
.
kind
+
"
track
-
id
=
"
+
t
.
receiver
.
track
.
id
)
;
return
t
.
receiver
.
track
;
}
)
;
}
getExpectedSendTracks
:
function
(
)
{
return
Object
.
keys
(
this
.
expectedLocalTrackInfoById
)
.
map
(
id
=
>
this
.
findSendTrackByWebrtcId
(
id
)
)
;
}
findReceiveTrackByWebrtcId
:
function
(
webrtcId
)
{
return
this
.
_pc
.
getReceivers
(
)
.
map
(
receiver
=
>
receiver
.
track
)
.
find
(
track
=
>
this
.
getWebrtcTrackId
(
track
)
=
=
webrtcId
)
;
}
findSendTrackByWebrtcId
:
function
(
webrtcId
)
{
return
this
.
_pc
.
getSenders
(
)
.
map
(
sender
=
>
sender
.
track
)
.
filter
(
track
=
>
track
)
.
find
(
track
=
>
track
.
id
=
=
webrtcId
)
;
}
waitForMediaFlow
:
function
(
)
{
return
Promise
.
all
(
[
]
.
concat
(
this
.
localMediaElements
.
map
(
element
=
>
this
.
waitForMediaElementFlow
(
element
)
)
this
.
remoteMediaElements
.
filter
(
elem
=
>
this
.
getExpectedActiveReceiveTracks
(
)
.
some
(
track
=
>
elem
.
srcObject
.
getTracks
(
)
.
some
(
t
=
>
t
=
=
track
)
)
)
.
map
(
elem
=
>
this
.
waitForMediaElementFlow
(
elem
)
)
this
.
getExpectedActiveReceiveTracks
(
)
.
map
(
track
=
>
this
.
waitForRtpFlow
(
track
)
)
this
.
getExpectedSendTracks
(
)
.
map
(
track
=
>
this
.
waitForRtpFlow
(
track
)
)
)
)
;
}
async
waitForSyncedRtcp
(
)
{
let
ensureSyncedRtcp
=
async
(
)
=
>
{
let
report
=
await
this
.
_pc
.
getStats
(
)
;
for
(
let
[
k
v
]
of
report
)
{
if
(
v
.
type
.
endsWith
(
"
bound
-
rtp
"
)
&
&
!
v
.
remoteId
)
{
info
(
v
.
id
+
"
is
missing
remoteId
:
"
+
JSON
.
stringify
(
v
)
)
;
return
null
;
}
if
(
v
.
type
=
=
"
inbound
-
rtp
"
&
&
v
.
isRemote
=
=
true
&
&
v
.
roundTripTime
=
=
=
undefined
)
{
info
(
v
.
id
+
"
is
missing
roundTripTime
:
"
+
JSON
.
stringify
(
v
)
)
;
return
null
;
}
}
return
report
;
}
let
attempts
=
0
;
const
waitPeriod
=
500
;
const
maxTime
=
15000
;
for
(
let
totalTime
=
maxTime
;
totalTime
>
0
;
totalTime
-
=
waitPeriod
)
{
try
{
let
syncedStats
=
await
ensureSyncedRtcp
(
)
;
if
(
syncedStats
)
{
return
syncedStats
;
}
}
catch
(
e
)
{
info
(
e
)
;
info
(
e
.
stack
)
;
throw
e
;
}
attempts
+
=
1
;
info
(
"
waitForSyncedRtcp
:
no
synced
RTCP
on
attempt
"
+
attempts
+
"
retrying
.
\
n
"
)
;
await
wait
(
waitPeriod
)
;
}
throw
Error
(
"
Waiting
for
synced
RTCP
timed
out
after
at
least
"
+
maxTime
+
"
ms
"
)
;
}
checkReceivingToneFrom
:
async
function
(
audiocontext
from
cancel
=
wait
(
60000
new
Error
(
"
Tone
not
detected
"
)
)
)
{
let
localTransceivers
=
this
.
_pc
.
getTransceivers
(
)
.
filter
(
t
=
>
t
.
mid
)
.
filter
(
t
=
>
t
.
receiver
.
track
.
kind
=
=
"
audio
"
)
.
sort
(
(
t1
t2
)
=
>
t1
.
mid
<
t2
.
mid
)
;
let
remoteTransceivers
=
from
.
_pc
.
getTransceivers
(
)
.
filter
(
t
=
>
t
.
mid
)
.
filter
(
t
=
>
t
.
receiver
.
track
.
kind
=
=
"
audio
"
)
.
sort
(
(
t1
t2
)
=
>
t1
.
mid
<
t2
.
mid
)
;
is
(
localTransceivers
.
length
remoteTransceivers
.
length
"
Same
number
of
associated
audio
transceivers
on
remote
and
local
.
"
)
;
for
(
let
i
=
0
;
i
<
localTransceivers
.
length
;
i
+
+
)
{
is
(
localTransceivers
[
i
]
.
mid
remoteTransceivers
[
i
]
.
mid
"
Transceivers
at
index
"
+
i
+
"
have
the
same
mid
.
"
)
;
if
(
!
remoteTransceivers
[
i
]
.
sender
.
track
)
{
continue
;
}
if
(
remoteTransceivers
[
i
]
.
currentDirection
=
=
"
recvonly
"
|
|
remoteTransceivers
[
i
]
.
currentDirection
=
=
"
inactive
"
)
{
continue
;
}
let
sendTrack
=
remoteTransceivers
[
i
]
.
sender
.
track
;
let
inputElem
=
from
.
getMediaElementForTrack
(
sendTrack
"
local
"
)
;
ok
(
inputElem
"
Remote
wrapper
should
have
a
media
element
for
track
id
"
+
sendTrack
.
id
)
;
let
inputAudioStream
=
from
.
getStreamForSendTrack
(
sendTrack
)
;
ok
(
inputAudioStream
"
Remote
wrapper
should
have
a
stream
for
track
id
"
+
sendTrack
.
id
)
;
let
inputAnalyser
=
new
AudioStreamAnalyser
(
audiocontext
inputAudioStream
)
;
let
recvTrack
=
localTransceivers
[
i
]
.
receiver
.
track
;
let
outputAudioStream
=
this
.
getStreamForRecvTrack
(
recvTrack
)
;
ok
(
outputAudioStream
"
Local
wrapper
should
have
a
stream
for
track
id
"
+
recvTrack
.
id
)
;
let
outputAnalyser
=
new
AudioStreamAnalyser
(
audiocontext
outputAudioStream
)
;
let
error
=
null
;
cancel
.
then
(
e
=
>
error
=
e
)
;
let
indexOfMax
=
data
=
>
data
.
reduce
(
(
max
val
i
)
=
>
(
val
>
=
data
[
max
]
)
?
i
:
max
0
)
;
await
outputAnalyser
.
waitForAnalysisSuccess
(
(
)
=
>
{
if
(
error
)
{
throw
error
;
}
let
inputData
=
inputAnalyser
.
getByteFrequencyData
(
)
;
let
outputData
=
outputAnalyser
.
getByteFrequencyData
(
)
;
let
inputMax
=
indexOfMax
(
inputData
)
;
let
outputMax
=
indexOfMax
(
outputData
)
;
info
(
Comparing
maxima
;
input
[
{
inputMax
}
]
=
{
inputData
[
inputMax
]
}
+
output
[
{
outputMax
}
]
=
{
outputData
[
outputMax
]
}
)
;
if
(
!
inputData
[
inputMax
]
|
|
!
outputData
[
outputMax
]
)
{
return
false
;
}
info
(
input
data
length
:
{
inputData
.
length
}
)
;
return
Math
.
abs
(
inputMax
-
outputMax
)
<
(
inputData
.
length
*
0
.
02
)
;
}
)
;
}
}
getStatsLegacy
:
function
(
selector
onSuccess
onFail
)
{
let
wrapper
=
stats
=
>
{
info
(
this
+
"
:
Got
legacy
stats
:
"
+
JSON
.
stringify
(
stats
)
)
;
onSuccess
(
stats
)
;
}
;
return
this
.
_pc
.
getStats
(
selector
wrapper
onFail
)
;
}
checkLegacyStatTypeNames
:
function
(
stats
)
{
let
types
=
[
]
;
stats
.
forEach
(
stat
=
>
types
.
push
(
stat
.
type
)
)
;
ok
(
types
.
filter
(
type
=
>
type
.
includes
(
"
-
"
)
)
.
length
=
=
0
"
legacy
getStats
API
is
not
returning
stats
with
hyphenated
types
.
"
)
;
}
getStats
:
function
(
selector
)
{
return
this
.
_pc
.
getStats
(
selector
)
.
then
(
stats
=
>
{
info
(
this
+
"
:
Got
stats
:
"
+
JSON
.
stringify
(
stats
)
)
;
this
.
_last_stats
=
stats
;
return
stats
;
}
)
;
}
checkStats
:
function
(
stats
twoMachines
)
{
const
isWinXP
=
navigator
.
userAgent
.
includes
(
"
Windows
NT
5
.
1
"
)
;
var
counters
=
{
}
;
for
(
let
[
key
res
]
of
stats
)
{
info
(
"
Checking
stats
for
"
+
key
+
"
:
"
+
res
)
;
ok
(
res
.
id
=
=
key
"
Coherent
stats
id
"
)
;
var
nowish
=
Date
.
now
(
)
+
1000
;
var
minimum
=
this
.
whenCreated
-
1000
;
if
(
isWinXP
)
{
todo
(
false
"
Can
'
t
reliably
test
rtcp
timestamps
on
WinXP
(
Bug
979649
)
"
)
;
}
else
if
(
false
)
{
if
(
res
.
timestamp
!
=
2085978496000
)
{
ok
(
res
.
timestamp
>
=
minimum
"
Valid
"
+
(
res
.
isRemote
?
"
rtcp
"
:
"
rtp
"
)
+
"
timestamp
"
+
res
.
timestamp
+
"
>
=
"
+
minimum
+
"
(
"
+
(
res
.
timestamp
-
minimum
)
+
"
ms
)
"
)
;
ok
(
res
.
timestamp
<
=
nowish
"
Valid
"
+
(
res
.
isRemote
?
"
rtcp
"
:
"
rtp
"
)
+
"
timestamp
"
+
res
.
timestamp
+
"
<
=
"
+
nowish
+
"
(
"
+
(
res
.
timestamp
-
nowish
)
+
"
ms
)
"
)
;
}
else
{
info
(
"
Bug
1225729
:
Uninitialized
timestamp
(
"
+
res
.
timestamp
+
"
)
should
be
>
=
"
+
minimum
+
"
and
<
=
"
+
nowish
)
;
}
}
if
(
res
.
isRemote
)
{
continue
;
}
counters
[
res
.
type
]
=
(
counters
[
res
.
type
]
|
|
0
)
+
1
;
switch
(
res
.
type
)
{
case
"
inbound
-
rtp
"
:
case
"
outbound
-
rtp
"
:
{
ok
(
res
.
ssrc
|
|
res
.
type
=
=
"
inbound
-
rtp
"
"
Outbound
RTP
stats
has
an
ssrc
.
"
)
;
if
(
res
.
ssrc
)
{
ok
(
res
.
ssrc
.
length
>
0
"
Ssrc
has
length
"
)
;
ok
(
res
.
ssrc
.
length
<
11
"
Ssrc
not
lengthy
"
)
;
ok
(
!
/
[
^
0
-
9
]
/
.
test
(
res
.
ssrc
)
"
Ssrc
numeric
"
)
;
ok
(
parseInt
(
res
.
ssrc
)
<
Math
.
pow
(
2
32
)
"
Ssrc
within
limits
"
)
;
}
if
(
res
.
type
=
=
"
outbound
-
rtp
"
)
{
ok
(
res
.
packetsSent
!
=
=
undefined
"
Rtp
packetsSent
"
)
;
ok
(
res
.
bytesSent
>
=
res
.
packetsSent
"
Rtp
bytesSent
"
)
;
}
else
{
ok
(
res
.
packetsReceived
!
=
=
undefined
"
Rtp
packetsReceived
"
)
;
ok
(
res
.
bytesReceived
>
=
res
.
packetsReceived
"
Rtp
bytesReceived
"
)
;
}
if
(
res
.
remoteId
)
{
var
rem
=
stats
.
get
(
res
.
remoteId
)
;
ok
(
rem
.
isRemote
"
Remote
is
rtcp
"
)
;
ok
(
rem
.
remoteId
=
=
res
.
id
"
Remote
backlink
match
"
)
;
if
(
res
.
type
=
=
"
outbound
-
rtp
"
)
{
ok
(
rem
.
type
=
=
"
inbound
-
rtp
"
"
Rtcp
is
inbound
"
)
;
ok
(
rem
.
packetsReceived
!
=
=
undefined
"
Rtcp
packetsReceived
"
)
;
ok
(
rem
.
packetsLost
!
=
=
undefined
"
Rtcp
packetsLost
"
)
;
ok
(
rem
.
bytesReceived
>
=
rem
.
packetsReceived
"
Rtcp
bytesReceived
"
)
;
if
(
false
)
{
if
(
res
.
timestamp
>
=
rem
.
timestamp
)
{
ok
(
rem
.
packetsReceived
<
=
res
.
packetsSent
"
No
more
than
sent
packets
"
)
;
}
else
{
info
(
"
REVERSED
timestamps
:
rec
:
"
+
rem
.
packetsReceived
+
"
time
:
"
+
rem
.
timestamp
+
"
sent
:
"
+
res
.
packetsSent
+
"
time
:
"
+
res
.
timestamp
)
;
}
ok
(
rem
.
bytesReceived
<
=
res
.
bytesSent
"
No
more
than
sent
bytes
"
)
;
}
ok
(
rem
.
jitter
!
=
=
undefined
"
Rtcp
jitter
"
)
;
if
(
rem
.
roundTripTime
)
{
ok
(
rem
.
roundTripTime
>
0
"
Rtcp
rtt
"
+
rem
.
roundTripTime
+
"
>
=
0
"
)
;
ok
(
rem
.
roundTripTime
<
60000
"
Rtcp
rtt
"
+
rem
.
roundTripTime
+
"
<
1
min
"
)
;
}
}
else
{
ok
(
rem
.
type
=
=
"
outbound
-
rtp
"
"
Rtcp
is
outbound
"
)
;
ok
(
rem
.
packetsSent
!
=
=
undefined
"
Rtcp
packetsSent
"
)
;
ok
(
rem
.
bytesSent
>
=
rem
.
packetsSent
"
Rtcp
bytesSent
"
)
;
}
ok
(
rem
.
ssrc
=
=
res
.
ssrc
"
Remote
ssrc
match
"
)
;
}
else
{
info
(
"
No
rtcp
info
received
yet
"
)
;
}
}
break
;
}
}
var
legacyToSpecMapping
=
{
'
inboundrtp
'
:
'
inbound
-
rtp
'
'
outboundrtp
'
:
'
outbound
-
rtp
'
'
candidatepair
'
:
'
candidate
-
pair
'
'
localcandidate
'
:
'
local
-
candidate
'
'
remotecandidate
'
:
'
remote
-
candidate
'
}
;
var
counters2
=
{
}
;
for
(
let
key
in
stats
)
{
if
(
!
stats
.
hasOwnProperty
(
key
)
)
{
continue
;
}
var
res
=
stats
[
key
]
;
var
type
=
legacyToSpecMapping
[
res
.
type
]
|
|
res
.
type
;
if
(
!
res
.
isRemote
)
{
counters2
[
type
]
=
(
counters2
[
type
]
|
|
0
)
+
1
;
}
}
is
(
JSON
.
stringify
(
counters
)
JSON
.
stringify
(
counters2
)
"
Spec
and
legacy
variant
of
RTCStatsReport
enumeration
agree
"
)
;
var
nin
=
this
.
_pc
.
getTransceivers
(
)
.
filter
(
t
=
>
{
return
!
t
.
stopped
&
&
(
t
.
currentDirection
!
=
"
inactive
"
)
&
&
(
t
.
currentDirection
!
=
"
sendonly
"
)
;
}
)
.
length
;
var
nout
=
Object
.
keys
(
this
.
expectedLocalTrackInfoById
)
.
length
;
var
ndata
=
this
.
dataChannels
.
length
;
ok
(
(
counters
[
"
inbound
-
rtp
"
]
|
|
0
)
>
=
nin
"
Have
at
least
"
+
nin
+
"
inbound
-
rtp
stat
(
s
)
*
"
)
;
is
(
counters
[
"
outbound
-
rtp
"
]
|
|
0
nout
"
Have
"
+
nout
+
"
outbound
-
rtp
stat
(
s
)
"
)
;
var
numLocalCandidates
=
counters
[
"
local
-
candidate
"
]
|
|
0
;
var
numRemoteCandidates
=
counters
[
"
remote
-
candidate
"
]
|
|
0
;
if
(
nin
+
nout
+
ndata
>
0
)
{
ok
(
numLocalCandidates
"
Have
local
-
candidate
stat
(
s
)
"
)
;
ok
(
numRemoteCandidates
"
Have
remote
-
candidate
stat
(
s
)
"
)
;
}
else
{
is
(
numLocalCandidates
0
"
Have
no
local
-
candidate
stats
"
)
;
is
(
numRemoteCandidates
0
"
Have
no
remote
-
candidate
stats
"
)
;
}
}
checkStatsIceConnectionType
:
function
(
stats
expectedLocalCandidateType
)
{
let
lId
;
let
rId
;
for
(
let
stat
of
stats
.
values
(
)
)
{
if
(
stat
.
type
=
=
"
candidate
-
pair
"
&
&
stat
.
selected
)
{
lId
=
stat
.
localCandidateId
;
rId
=
stat
.
remoteCandidateId
;
break
;
}
}
isnot
(
lId
undefined
"
Got
local
candidate
ID
"
+
lId
+
"
for
selected
pair
"
)
;
isnot
(
rId
undefined
"
Got
remote
candidate
ID
"
+
rId
+
"
for
selected
pair
"
)
;
let
lCand
=
stats
.
get
(
lId
)
;
let
rCand
=
stats
.
get
(
rId
)
;
if
(
!
lCand
|
|
!
rCand
)
{
ok
(
false
"
failed
to
find
candidatepair
IDs
or
stats
for
local
:
"
+
lId
+
"
remote
:
"
+
rId
)
;
return
;
}
info
(
"
checkStatsIceConnectionType
verifying
:
local
=
"
+
JSON
.
stringify
(
lCand
)
+
"
remote
=
"
+
JSON
.
stringify
(
rCand
)
)
;
expectedLocalCandidateType
=
expectedLocalCandidateType
|
|
"
host
"
;
var
candidateType
=
lCand
.
candidateType
;
if
(
(
lCand
.
mozLocalTransport
=
=
=
"
tcp
"
)
&
&
(
candidateType
=
=
=
"
relayed
"
)
)
{
candidateType
=
"
relayed
-
tcp
"
;
}
if
(
(
expectedLocalCandidateType
=
=
=
"
serverreflexive
"
)
&
&
(
candidateType
=
=
=
"
peerreflexive
"
)
)
{
candidateType
=
"
serverreflexive
"
;
}
is
(
candidateType
expectedLocalCandidateType
"
Local
candidate
type
is
what
we
expected
for
selected
pair
"
)
;
}
checkStatsIceConnections
:
function
(
stats
testOptions
)
{
var
numIceConnections
=
0
;
stats
.
forEach
(
stat
=
>
{
if
(
(
stat
.
type
=
=
=
"
candidate
-
pair
"
)
&
&
stat
.
selected
)
{
numIceConnections
+
=
1
;
}
}
)
;
info
(
"
ICE
connections
according
to
stats
:
"
+
numIceConnections
)
;
isnot
(
numIceConnections
0
"
Number
of
ICE
connections
according
to
stats
is
not
zero
"
)
;
if
(
testOptions
.
bundle
)
{
if
(
testOptions
.
rtcpmux
)
{
is
(
numIceConnections
1
"
stats
reports
exactly
1
ICE
connection
"
)
;
}
else
{
is
(
numIceConnections
2
"
stats
report
exactly
2
ICE
connections
for
media
and
RTCP
"
)
;
}
}
else
{
var
numAudioTransceivers
=
this
.
_pc
.
getTransceivers
(
)
.
filter
(
(
transceiver
)
=
>
{
return
(
!
transceiver
.
stopped
)
&
&
transceiver
.
receiver
.
track
.
kind
=
=
"
audio
"
;
}
)
.
length
;
var
numVideoTransceivers
=
this
.
_pc
.
getTransceivers
(
)
.
filter
(
(
transceiver
)
=
>
{
return
(
!
transceiver
.
stopped
)
&
&
transceiver
.
receiver
.
track
.
kind
=
=
"
video
"
;
}
)
.
length
;
var
numExpectedTransports
=
numAudioTransceivers
+
numVideoTransceivers
;
if
(
!
testOptions
.
rtcpmux
)
{
numExpectedTransports
*
=
2
;
}
if
(
this
.
dataChannels
.
length
)
{
+
+
numExpectedTransports
;
}
info
(
"
expected
audio
+
video
+
data
transports
:
"
+
numExpectedTransports
)
;
is
(
numIceConnections
numExpectedTransports
"
stats
ICE
connections
matches
expected
A
/
V
transports
"
)
;
}
}
expectNegotiationNeeded
:
function
(
)
{
if
(
!
this
.
observedNegotiationNeeded
)
{
this
.
observedNegotiationNeeded
=
new
Promise
(
(
resolve
)
=
>
{
this
.
onnegotiationneeded
=
resolve
;
}
)
;
}
}
hasStat
:
function
(
stats
props
)
{
for
(
let
res
of
stats
.
values
(
)
)
{
var
match
=
true
;
for
(
let
prop
in
props
)
{
if
(
res
[
prop
]
!
=
=
props
[
prop
]
)
{
match
=
false
;
break
;
}
}
if
(
match
)
{
return
true
;
}
}
return
false
;
}
close
:
function
(
)
{
this
.
_pc
.
close
(
)
;
this
.
localMediaElements
.
forEach
(
e
=
>
e
.
pause
(
)
)
;
info
(
this
+
"
:
Closed
connection
.
"
)
;
}
toString
:
function
(
)
{
return
"
PeerConnectionWrapper
(
"
+
this
.
label
+
"
)
"
;
}
}
;
function
addLoadEvent
(
)
{
}
function
loadScript
(
.
.
.
scripts
)
{
return
Promise
.
all
(
scripts
.
map
(
script
=
>
{
var
el
=
document
.
createElement
(
"
script
"
)
;
if
(
typeof
scriptRelativePath
=
=
=
'
string
'
&
&
script
.
charAt
(
0
)
!
=
=
'
/
'
)
{
script
=
scriptRelativePath
+
script
;
}
el
.
src
=
script
;
document
.
head
.
appendChild
(
el
)
;
return
new
Promise
(
r
=
>
{
el
.
onload
=
r
;
el
.
onerror
=
r
;
}
)
;
}
)
)
;
}
var
scriptsReady
=
loadScript
(
"
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
)
.
then
(
(
)
=
>
{
return
loadScript
(
"
.
.
/
.
.
/
test
/
manifest
.
js
"
"
head
.
js
"
"
templates
.
js
"
"
turnConfig
.
js
"
"
dataChannel
.
js
"
"
network
.
js
"
"
sdpUtils
.
js
"
)
;
}
)
;
function
createHTML
(
options
)
{
return
scriptsReady
.
then
(
(
)
=
>
realCreateHTML
(
options
)
)
;
}
var
iceServerWebsocket
;
var
iceServersArray
=
[
]
;
var
addTurnsSelfsignedCerts
=
(
)
=
>
{
var
gUrl
=
SimpleTest
.
getTestFileURL
(
'
addTurnsSelfsignedCert
.
js
'
)
;
var
gScript
=
SpecialPowers
.
loadChromeScript
(
gUrl
)
;
var
certs
=
[
]
;
iceServersArray
.
forEach
(
iceServer
=
>
{
if
(
iceServer
.
hasOwnProperty
(
"
cert
"
)
)
{
iceServer
.
urls
.
forEach
(
url
=
>
{
if
(
url
.
startsWith
(
"
turns
:
"
)
)
{
certs
.
push
(
{
"
cert
"
:
iceServer
.
cert
"
hostname
"
:
url
.
substr
(
6
)
}
)
;
}
}
)
;
}
}
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
gScript
.
addMessageListener
(
'
certs
-
added
'
(
)
=
>
{
resolve
(
)
;
}
)
;
gScript
.
sendAsyncMessage
(
'
add
-
turns
-
certs
'
certs
)
;
}
)
;
}
;
var
setupIceServerConfig
=
useIceServer
=
>
{
var
enableHttpProxy
=
enable
=
>
SpecialPowers
.
pushPrefEnv
(
{
'
set
'
:
[
[
'
media
.
peerconnection
.
disable_http_proxy
'
!
enable
]
]
}
)
;
var
spawnIceServer
=
(
)
=
>
new
Promise
(
(
resolve
reject
)
=
>
{
iceServerWebsocket
=
new
WebSocket
(
"
ws
:
/
/
localhost
:
8191
/
"
)
;
iceServerWebsocket
.
onopen
=
(
event
)
=
>
{
info
(
"
websocket
/
process
bridge
open
starting
ICE
Server
.
.
.
"
)
;
iceServerWebsocket
.
send
(
"
iceserver
"
)
;
}
iceServerWebsocket
.
onmessage
=
event
=
>
{
info
(
"
ICE
Server
:
"
+
event
.
data
)
;
resolve
(
event
.
data
)
;
}
iceServerWebsocket
.
onerror
=
(
)
=
>
{
reject
(
"
ICE
Server
error
:
Is
the
ICE
server
websocket
up
?
"
)
;
}
iceServerWebsocket
.
onclose
=
(
)
=
>
{
info
(
"
ICE
Server
websocket
closed
"
)
;
reject
(
"
ICE
Server
gone
before
getting
configuration
"
)
;
}
}
)
;
if
(
!
useIceServer
)
{
info
(
"
Skipping
ICE
Server
for
this
test
"
)
;
return
enableHttpProxy
(
true
)
;
}
return
enableHttpProxy
(
false
)
.
then
(
spawnIceServer
)
.
then
(
iceServersStr
=
>
{
iceServersArray
=
JSON
.
parse
(
iceServersStr
)
;
}
)
.
then
(
addTurnsSelfsignedCerts
)
;
}
;
async
function
runNetworkTest
(
testFunction
fixtureOptions
=
{
}
)
{
let
version
=
SpecialPowers
.
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
SpecialPowers
.
Ci
.
nsIXULAppInfo
)
.
version
;
let
isNightly
=
version
.
endsWith
(
"
a1
"
)
;
let
isAndroid
=
!
!
navigator
.
userAgent
.
includes
(
"
Android
"
)
;
await
scriptsReady
;
await
runTestWhenReady
(
async
options
=
>
{
await
startNetworkAndTest
(
)
;
await
setupIceServerConfig
(
fixtureOptions
.
useIceServer
)
;
if
(
isNightly
&
&
isAndroid
)
{
let
value
=
Math
.
random
(
)
>
=
0
.
5
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
'
media
.
navigator
.
hardware
.
vp8_encode
.
acceleration_enabled
'
value
]
[
'
media
.
navigator
.
hardware
.
vp8_encode
.
acceleration_remote_enabled
'
value
]
]
}
)
;
}
await
testFunction
(
options
)
;
}
)
;
}
