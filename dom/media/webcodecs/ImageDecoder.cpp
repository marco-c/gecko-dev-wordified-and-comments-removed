#
include
"
mozilla
/
dom
/
ImageDecoder
.
h
"
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
"
ImageContainer
.
h
"
#
include
"
ImageDecoderReadRequest
.
h
"
#
include
"
MediaResult
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
dom
/
ImageTrack
.
h
"
#
include
"
mozilla
/
dom
/
ImageTrackList
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
mozilla
/
dom
/
VideoFrame
.
h
"
#
include
"
mozilla
/
dom
/
VideoFrameBinding
.
h
"
#
include
"
mozilla
/
dom
/
WebCodecsUtils
.
h
"
#
include
"
mozilla
/
image
/
ImageUtils
.
h
"
#
include
"
mozilla
/
image
/
SourceBuffer
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsTHashSet
.
h
"
extern
mozilla
:
:
LazyLogModule
gWebCodecsLog
;
namespace
mozilla
:
:
dom
{
class
ImageDecoder
:
:
ControlMessage
{
public
:
ControlMessage
(
)
=
default
;
virtual
~
ControlMessage
(
)
=
default
;
virtual
ConfigureMessage
*
AsConfigureMessage
(
)
{
return
nullptr
;
}
virtual
DecodeMetadataMessage
*
AsDecodeMetadataMessage
(
)
{
return
nullptr
;
}
virtual
DecodeFrameMessage
*
AsDecodeFrameMessage
(
)
{
return
nullptr
;
}
virtual
SelectTrackMessage
*
AsSelectTrackMessage
(
)
{
return
nullptr
;
}
}
;
class
ImageDecoder
:
:
ConfigureMessage
final
:
public
ImageDecoder
:
:
ControlMessage
{
public
:
explicit
ConfigureMessage
(
const
Maybe
<
gfx
:
:
IntSize
>
&
aOutputSize
ColorSpaceConversion
aColorSpaceConversion
)
:
mOutputSize
(
aOutputSize
)
mColorSpaceConversion
(
aColorSpaceConversion
)
{
}
ConfigureMessage
*
AsConfigureMessage
(
)
override
{
return
this
;
}
const
Maybe
<
gfx
:
:
IntSize
>
mOutputSize
;
const
ColorSpaceConversion
mColorSpaceConversion
;
}
;
class
ImageDecoder
:
:
DecodeMetadataMessage
final
:
public
ImageDecoder
:
:
ControlMessage
{
public
:
DecodeMetadataMessage
*
AsDecodeMetadataMessage
(
)
override
{
return
this
;
}
}
;
class
ImageDecoder
:
:
DecodeFrameMessage
final
:
public
ImageDecoder
:
:
ControlMessage
{
public
:
DecodeFrameMessage
*
AsDecodeFrameMessage
(
)
override
{
return
this
;
}
}
;
class
ImageDecoder
:
:
SelectTrackMessage
final
:
public
ImageDecoder
:
:
ControlMessage
{
public
:
explicit
SelectTrackMessage
(
uint32_t
aSelectedTrack
)
:
mSelectedTrack
(
aSelectedTrack
)
{
}
SelectTrackMessage
*
AsSelectTrackMessage
(
)
override
{
return
this
;
}
const
uint32_t
mSelectedTrack
;
}
;
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
ImageDecoder
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
ImageDecoder
)
tmp
-
>
Destroy
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mParent
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTracks
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mReadRequest
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCompletePromise
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOutstandingDecodes
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
ImageDecoder
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mParent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTracks
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mReadRequest
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCompletePromise
)
for
(
uint32_t
i
=
0
;
i
<
tmp
-
>
mOutstandingDecodes
.
Length
(
)
;
+
+
i
)
{
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOutstandingDecodes
[
i
]
.
mPromise
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ImageDecoder
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ImageDecoder
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ImageDecoder
)
ImageDecoder
:
:
ImageDecoder
(
nsCOMPtr
<
nsIGlobalObject
>
&
&
aParent
const
nsAString
&
aType
)
:
mParent
(
std
:
:
move
(
aParent
)
)
mType
(
aType
)
mFramesTimestamp
(
image
:
:
FrameTimeout
:
:
Zero
(
)
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
ImageDecoder
"
this
)
)
;
}
ImageDecoder
:
:
~
ImageDecoder
(
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
~
ImageDecoder
"
this
)
)
;
Destroy
(
)
;
}
JSObject
*
ImageDecoder
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
AssertIsOnOwningThread
(
)
;
return
ImageDecoder_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
ImageDecoder
:
:
Destroy
(
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
Destroy
"
this
)
)
;
MOZ_ASSERT
(
mOutstandingDecodes
.
IsEmpty
(
)
)
;
if
(
mReadRequest
)
{
mReadRequest
-
>
Destroy
(
false
)
;
mReadRequest
=
nullptr
;
}
if
(
mDecoder
)
{
mDecoder
-
>
Destroy
(
)
;
}
if
(
mTracks
)
{
mTracks
-
>
Destroy
(
)
;
}
if
(
mShutdownWatcher
)
{
mShutdownWatcher
-
>
Destroy
(
)
;
mShutdownWatcher
=
nullptr
;
}
mSourceBuffer
=
nullptr
;
mDecoder
=
nullptr
;
mParent
=
nullptr
;
}
void
ImageDecoder
:
:
QueueConfigureMessage
(
const
Maybe
<
gfx
:
:
IntSize
>
&
aOutputSize
ColorSpaceConversion
aColorSpaceConversion
)
{
mControlMessageQueue
.
push
(
MakeUnique
<
ConfigureMessage
>
(
aOutputSize
aColorSpaceConversion
)
)
;
}
void
ImageDecoder
:
:
QueueDecodeMetadataMessage
(
)
{
mControlMessageQueue
.
push
(
MakeUnique
<
DecodeMetadataMessage
>
(
)
)
;
}
void
ImageDecoder
:
:
QueueDecodeFrameMessage
(
)
{
mControlMessageQueue
.
push
(
MakeUnique
<
DecodeFrameMessage
>
(
)
)
;
}
void
ImageDecoder
:
:
QueueSelectTrackMessage
(
uint32_t
aSelectedIndex
)
{
mControlMessageQueue
.
push
(
MakeUnique
<
SelectTrackMessage
>
(
aSelectedIndex
)
)
;
}
void
ImageDecoder
:
:
ResumeControlMessageQueue
(
)
{
MOZ_ASSERT
(
mMessageQueueBlocked
)
;
mMessageQueueBlocked
=
false
;
ProcessControlMessageQueue
(
)
;
}
void
ImageDecoder
:
:
ProcessControlMessageQueue
(
)
{
while
(
!
mMessageQueueBlocked
&
&
!
mControlMessageQueue
.
empty
(
)
)
{
auto
&
msg
=
mControlMessageQueue
.
front
(
)
;
auto
result
=
MessageProcessedResult
:
:
Processed
;
if
(
auto
*
submsg
=
msg
-
>
AsConfigureMessage
(
)
)
{
result
=
ProcessConfigureMessage
(
submsg
)
;
}
else
if
(
auto
*
submsg
=
msg
-
>
AsDecodeMetadataMessage
(
)
)
{
result
=
ProcessDecodeMetadataMessage
(
submsg
)
;
}
else
if
(
auto
*
submsg
=
msg
-
>
AsDecodeFrameMessage
(
)
)
{
result
=
ProcessDecodeFrameMessage
(
submsg
)
;
}
else
if
(
auto
*
submsg
=
msg
-
>
AsSelectTrackMessage
(
)
)
{
result
=
ProcessSelectTrackMessage
(
submsg
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
control
message
type
!
"
)
;
}
if
(
result
=
=
MessageProcessedResult
:
:
NotProcessed
)
{
break
;
}
mControlMessageQueue
.
pop
(
)
;
}
}
MessageProcessedResult
ImageDecoder
:
:
ProcessConfigureMessage
(
ConfigureMessage
*
aMsg
)
{
NS_ConvertUTF16toUTF8
mimeType
(
mType
)
;
image
:
:
DecoderType
type
=
image
:
:
ImageUtils
:
:
GetDecoderType
(
mimeType
)
;
if
(
NS_WARN_IF
(
type
=
=
image
:
:
DecoderType
:
:
UNKNOWN
)
|
|
NS_WARN_IF
(
type
=
=
image
:
:
DecoderType
:
:
ICON
)
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
Initialize
-
-
unsupported
mime
type
'
%
s
'
"
this
mimeType
.
get
(
)
)
)
;
Close
(
MediaResult
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
"
Unsupported
mime
type
"
_ns
)
)
;
return
MessageProcessedResult
:
:
Processed
;
}
image
:
:
SurfaceFlags
surfaceFlags
=
image
:
:
DefaultSurfaceFlags
(
)
;
switch
(
aMsg
-
>
mColorSpaceConversion
)
{
case
ColorSpaceConversion
:
:
None
:
surfaceFlags
|
=
image
:
:
SurfaceFlags
:
:
NO_COLORSPACE_CONVERSION
;
break
;
case
ColorSpaceConversion
:
:
Default
:
break
;
default
:
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
Initialize
-
-
unsupported
colorspace
conversion
"
this
)
)
;
Close
(
MediaResult
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
"
Unsupported
colorspace
conversion
"
_ns
)
)
;
return
MessageProcessedResult
:
:
Processed
;
}
mDecoder
=
image
:
:
ImageUtils
:
:
CreateDecoder
(
mSourceBuffer
type
aMsg
-
>
mOutputSize
surfaceFlags
)
;
if
(
NS_WARN_IF
(
!
mDecoder
)
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
Initialize
-
-
failed
to
create
platform
decoder
"
this
)
)
;
Close
(
MediaResult
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
"
Failed
to
create
platform
decoder
"
_ns
)
)
;
return
MessageProcessedResult
:
:
Processed
;
}
mMessageQueueBlocked
=
true
;
NS_DispatchToCurrentThread
(
NS_NewCancelableRunnableFunction
(
"
ImageDecoder
:
:
ProcessConfigureMessage
"
[
self
=
RefPtr
{
this
}
]
{
self
-
>
ResumeControlMessageQueue
(
)
;
}
)
)
;
return
MessageProcessedResult
:
:
Processed
;
}
MessageProcessedResult
ImageDecoder
:
:
ProcessDecodeMetadataMessage
(
DecodeMetadataMessage
*
aMsg
)
{
if
(
!
mDecoder
)
{
return
MessageProcessedResult
:
:
Processed
;
}
mDecoder
-
>
DecodeMetadata
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
self
=
RefPtr
{
this
}
]
(
const
image
:
:
DecodeMetadataResult
&
aMetadata
)
{
self
-
>
OnMetadataSuccess
(
aMetadata
)
;
}
[
self
=
RefPtr
{
this
}
]
(
const
nsresult
&
aErr
)
{
self
-
>
OnMetadataFailed
(
aErr
)
;
}
)
;
return
MessageProcessedResult
:
:
Processed
;
}
MessageProcessedResult
ImageDecoder
:
:
ProcessDecodeFrameMessage
(
DecodeFrameMessage
*
aMsg
)
{
NS_DispatchToCurrentThread
(
NS_NewCancelableRunnableFunction
(
"
ImageDecoder
:
:
ProcessDecodeFrameMessage
"
[
self
=
RefPtr
{
this
}
]
{
self
-
>
CheckOutstandingDecodes
(
)
;
}
)
)
;
return
MessageProcessedResult
:
:
Processed
;
}
MessageProcessedResult
ImageDecoder
:
:
ProcessSelectTrackMessage
(
SelectTrackMessage
*
aMsg
)
{
return
MessageProcessedResult
:
:
Processed
;
}
void
ImageDecoder
:
:
CheckOutstandingDecodes
(
)
{
if
(
mClosed
|
|
!
mTracks
)
{
return
;
}
ImageTrack
*
track
=
mTracks
-
>
GetDefaultTrack
(
)
;
if
(
!
track
)
{
return
;
}
const
uint32_t
decodedFrameCount
=
track
-
>
DecodedFrameCount
(
)
;
const
uint32_t
frameCount
=
track
-
>
FrameCount
(
)
;
const
bool
frameCountComplete
=
track
-
>
FrameCountComplete
(
)
;
const
bool
decodedFramesComplete
=
track
-
>
DecodedFramesComplete
(
)
;
AutoTArray
<
OutstandingDecode
4
>
resolved
;
AutoTArray
<
OutstandingDecode
4
>
rejectedRange
;
AutoTArray
<
OutstandingDecode
4
>
rejectedState
;
uint32_t
minFrameIndex
=
UINT32_MAX
;
for
(
uint32_t
i
=
0
;
i
<
mOutstandingDecodes
.
Length
(
)
;
)
{
auto
&
decode
=
mOutstandingDecodes
[
i
]
;
const
auto
frameIndex
=
decode
.
mFrameIndex
;
if
(
frameIndex
<
decodedFrameCount
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
CheckOutstandingDecodes
-
-
resolved
index
%
u
"
this
frameIndex
)
)
;
resolved
.
AppendElement
(
std
:
:
move
(
decode
)
)
;
mOutstandingDecodes
.
RemoveElementAt
(
i
)
;
}
else
if
(
frameCountComplete
&
&
frameCount
<
=
frameIndex
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Warning
(
"
ImageDecoder
%
p
CheckOutstandingDecodes
-
-
rejected
index
%
u
"
"
out
-
of
-
bounds
"
this
frameIndex
)
)
;
rejectedRange
.
AppendElement
(
std
:
:
move
(
decode
)
)
;
mOutstandingDecodes
.
RemoveElementAt
(
i
)
;
}
else
if
(
frameCountComplete
&
&
decodedFramesComplete
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Warning
(
"
ImageDecoder
%
p
CheckOutstandingDecodes
-
-
rejected
index
%
u
"
"
decode
error
"
this
frameIndex
)
)
;
rejectedState
.
AppendElement
(
std
:
:
move
(
decode
)
)
;
mOutstandingDecodes
.
RemoveElementAt
(
i
)
;
}
else
if
(
!
decodedFramesComplete
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
CheckOutstandingDecodes
-
-
pending
index
%
u
"
this
frameIndex
)
)
;
if
(
frameCount
>
frameIndex
)
{
minFrameIndex
=
std
:
:
min
(
minFrameIndex
frameIndex
)
;
}
+
+
i
;
}
else
{
MOZ_ASSERT
(
!
frameCountComplete
)
;
}
}
if
(
minFrameIndex
<
UINT32_MAX
)
{
RequestDecodeFrames
(
minFrameIndex
+
1
-
decodedFrameCount
)
;
}
for
(
const
auto
&
i
:
resolved
)
{
ImageDecodeResult
result
;
result
.
mImage
=
track
-
>
GetDecodedFrame
(
i
.
mFrameIndex
)
;
result
.
mComplete
=
true
;
i
.
mPromise
-
>
MaybeResolve
(
result
)
;
}
for
(
const
auto
&
i
:
rejectedRange
)
{
i
.
mPromise
-
>
MaybeRejectWithRangeError
(
"
No
more
frames
available
"
_ns
)
;
}
for
(
const
auto
&
i
:
rejectedState
)
{
i
.
mPromise
-
>
MaybeRejectWithInvalidStateError
(
"
Error
decoding
frame
"
_ns
)
;
}
}
already_AddRefed
<
ImageDecoder
>
ImageDecoder
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
ImageDecoderInit
&
aInit
ErrorResult
&
aRv
)
{
const
auto
mimeType
=
Substring
(
aInit
.
mType
0
6
)
;
if
(
!
mimeType
.
Equals
(
u
"
image
/
"
_ns
)
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
Constructor
-
-
bad
mime
type
"
)
)
;
aRv
.
ThrowTypeError
(
"
Invalid
MIME
type
must
be
'
image
'
"
)
;
return
nullptr
;
}
RefPtr
<
ImageDecoderReadRequest
>
readRequest
;
if
(
aInit
.
mData
.
IsReadableStream
(
)
)
{
const
auto
&
stream
=
aInit
.
mData
.
GetAsReadableStream
(
)
;
if
(
stream
-
>
Disturbed
(
)
|
|
stream
-
>
Locked
(
)
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
Constructor
-
-
bad
stream
"
)
)
;
aRv
.
ThrowTypeError
(
"
ReadableStream
data
is
disturbed
and
/
or
locked
"
)
;
return
nullptr
;
}
}
else
{
bool
empty
;
if
(
aInit
.
mData
.
IsArrayBufferView
(
)
)
{
const
auto
&
view
=
aInit
.
mData
.
GetAsArrayBufferView
(
)
;
empty
=
view
.
ProcessData
(
[
]
(
const
Span
<
uint8_t
>
&
aData
JS
:
:
AutoCheckCannotGC
&
&
)
{
return
aData
.
IsEmpty
(
)
;
}
)
;
}
else
if
(
aInit
.
mData
.
IsArrayBuffer
(
)
)
{
const
auto
&
buffer
=
aInit
.
mData
.
GetAsArrayBuffer
(
)
;
empty
=
buffer
.
ProcessData
(
[
]
(
const
Span
<
uint8_t
>
&
aData
JS
:
:
AutoCheckCannotGC
&
&
)
{
return
aData
.
IsEmpty
(
)
;
}
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
data
type
!
"
)
;
aRv
.
ThrowNotSupportedError
(
"
Unsupported
data
type
"
)
;
return
nullptr
;
}
if
(
empty
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
Constructor
-
-
detached
/
empty
BufferSource
"
)
)
;
aRv
.
ThrowTypeError
(
"
BufferSource
is
detached
/
empty
"
)
;
return
nullptr
;
}
}
if
(
aInit
.
mDesiredHeight
.
WasPassed
(
)
!
=
aInit
.
mDesiredWidth
.
WasPassed
(
)
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
Constructor
-
-
both
/
neither
desiredHeight
/
width
"
"
needed
"
)
)
;
aRv
.
ThrowTypeError
(
"
Both
or
neither
of
desiredHeight
and
desiredWidth
must
be
passed
"
)
;
return
nullptr
;
}
nsTHashSet
<
const
ArrayBuffer
*
>
transferSet
;
for
(
const
auto
&
buffer
:
aInit
.
mTransfer
)
{
if
(
transferSet
.
Contains
(
&
buffer
)
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
Constructor
-
-
duplicate
transferred
ArrayBuffer
"
)
)
;
aRv
.
ThrowDataCloneError
(
"
Transfer
contains
duplicate
ArrayBuffer
objects
"
)
;
return
nullptr
;
}
transferSet
.
Insert
(
&
buffer
)
;
bool
empty
=
buffer
.
ProcessData
(
[
&
]
(
const
Span
<
uint8_t
>
&
aData
JS
:
:
AutoCheckCannotGC
&
&
)
{
return
aData
.
IsEmpty
(
)
;
}
)
;
if
(
empty
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
Constructor
-
-
empty
/
detached
transferred
"
"
ArrayBuffer
"
)
)
;
aRv
.
ThrowDataCloneError
(
"
Transfer
contains
empty
/
detached
ArrayBuffer
objects
"
)
;
return
nullptr
;
}
}
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
auto
imageDecoder
=
MakeRefPtr
<
ImageDecoder
>
(
std
:
:
move
(
global
)
aInit
.
mType
)
;
imageDecoder
-
>
Initialize
(
aGlobal
aInit
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
Constructor
-
-
initialize
failed
"
)
)
;
return
nullptr
;
}
for
(
const
auto
&
buffer
:
aInit
.
mTransfer
)
{
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aGlobal
.
Context
(
)
buffer
.
Obj
(
)
)
;
JS
:
:
DetachArrayBuffer
(
aGlobal
.
Context
(
)
obj
)
;
}
return
imageDecoder
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
ImageDecoder
:
:
IsTypeSupported
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aType
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
const
auto
subType
=
Substring
(
aType
0
6
)
;
if
(
!
subType
.
Equals
(
u
"
image
/
"
_ns
)
)
{
promise
-
>
MaybeRejectWithTypeError
(
"
Invalid
MIME
type
must
be
'
image
'
"
_ns
)
;
return
promise
.
forget
(
)
;
}
NS_ConvertUTF16toUTF8
mimeType
(
aType
)
;
image
:
:
DecoderType
type
=
image
:
:
ImageUtils
:
:
GetDecoderType
(
mimeType
)
;
promise
-
>
MaybeResolve
(
type
!
=
image
:
:
DecoderType
:
:
UNKNOWN
)
;
return
promise
.
forget
(
)
;
}
void
ImageDecoder
:
:
Initialize
(
const
GlobalObject
&
aGlobal
const
ImageDecoderInit
&
aInit
ErrorResult
&
aRv
)
{
mShutdownWatcher
=
media
:
:
ShutdownWatcher
:
:
Create
(
this
)
;
if
(
!
mShutdownWatcher
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
Initialize
-
-
create
shutdown
watcher
failed
"
this
)
)
;
aRv
.
ThrowInvalidStateError
(
"
Could
not
create
shutdown
watcher
"
)
;
return
;
}
mCompletePromise
=
Promise
:
:
Create
(
mParent
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
Initialize
-
-
create
promise
failed
"
this
)
)
;
return
;
}
mTracks
=
MakeAndAddRef
<
ImageTrackList
>
(
mParent
this
)
;
mTracks
-
>
Initialize
(
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
Initialize
-
-
create
tracks
failed
"
this
)
)
;
return
;
}
mSourceBuffer
=
MakeRefPtr
<
image
:
:
SourceBuffer
>
(
)
;
const
auto
fnSourceBufferFromSpan
=
[
&
]
(
const
Span
<
uint8_t
>
&
aData
)
{
nsresult
rv
=
mSourceBuffer
-
>
ExpectLength
(
aData
.
Length
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
Initialize
-
-
failed
to
pre
-
allocate
source
buffer
"
this
)
)
;
aRv
.
ThrowRangeError
(
"
Could
not
allocate
for
encoded
source
buffer
"
)
;
return
;
}
rv
=
mSourceBuffer
-
>
Append
(
reinterpret_cast
<
const
char
*
>
(
aData
.
Elements
(
)
)
aData
.
Length
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
Initialize
-
-
failed
to
append
source
buffer
"
this
)
)
;
aRv
.
ThrowRangeError
(
"
Could
not
allocate
for
encoded
source
buffer
"
)
;
return
;
}
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
OnCompleteSuccess
(
)
;
}
;
if
(
aInit
.
mData
.
IsReadableStream
(
)
)
{
const
auto
&
stream
=
aInit
.
mData
.
GetAsReadableStream
(
)
;
MOZ_ASSERT
(
!
mComplete
)
;
mReadRequest
=
MakeAndAddRef
<
ImageDecoderReadRequest
>
(
mSourceBuffer
)
;
if
(
NS_WARN_IF
(
!
mReadRequest
-
>
Initialize
(
aGlobal
this
stream
)
)
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
Initialize
-
-
create
read
request
failed
"
this
)
)
;
aRv
.
ThrowInvalidStateError
(
"
Could
not
create
reader
for
ReadableStream
"
)
;
return
;
}
}
else
if
(
aInit
.
mData
.
IsArrayBufferView
(
)
)
{
const
auto
&
view
=
aInit
.
mData
.
GetAsArrayBufferView
(
)
;
view
.
ProcessFixedData
(
fnSourceBufferFromSpan
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
else
if
(
aInit
.
mData
.
IsArrayBuffer
(
)
)
{
const
auto
&
buffer
=
aInit
.
mData
.
GetAsArrayBuffer
(
)
;
buffer
.
ProcessFixedData
(
fnSourceBufferFromSpan
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
data
type
!
"
)
;
aRv
.
ThrowNotSupportedError
(
"
Unsupported
data
type
"
)
;
return
;
}
Maybe
<
gfx
:
:
IntSize
>
desiredSize
;
if
(
aInit
.
mDesiredWidth
.
WasPassed
(
)
&
&
aInit
.
mDesiredHeight
.
WasPassed
(
)
)
{
desiredSize
.
emplace
(
std
:
:
min
(
aInit
.
mDesiredWidth
.
Value
(
)
static_cast
<
uint32_t
>
(
INT32_MAX
)
)
std
:
:
min
(
aInit
.
mDesiredHeight
.
Value
(
)
static_cast
<
uint32_t
>
(
INT32_MAX
)
)
)
;
}
QueueConfigureMessage
(
desiredSize
aInit
.
mColorSpaceConversion
)
;
QueueDecodeMetadataMessage
(
)
;
ProcessControlMessageQueue
(
)
;
}
void
ImageDecoder
:
:
OnSourceBufferComplete
(
const
MediaResult
&
aResult
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
OnSourceBufferComplete
-
-
success
%
d
"
this
NS_SUCCEEDED
(
aResult
.
Code
(
)
)
)
)
;
MOZ_ASSERT
(
mSourceBuffer
-
>
IsComplete
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aResult
.
Code
(
)
)
)
)
{
OnCompleteFailed
(
aResult
)
;
return
;
}
OnCompleteSuccess
(
)
;
}
void
ImageDecoder
:
:
OnCompleteSuccess
(
)
{
if
(
mComplete
)
{
return
;
}
if
(
!
mSourceBuffer
-
>
IsComplete
(
)
|
|
!
mHasFrameCount
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
OnCompleteSuccess
-
-
not
complete
yet
;
"
"
sourceBuffer
%
d
hasFrameCount
%
d
"
this
mSourceBuffer
-
>
IsComplete
(
)
mHasFrameCount
)
)
;
return
;
}
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
OnCompleteSuccess
-
-
complete
"
this
)
)
;
mComplete
=
true
;
mCompletePromise
-
>
MaybeResolveWithUndefined
(
)
;
}
void
ImageDecoder
:
:
OnCompleteFailed
(
const
MediaResult
&
aResult
)
{
if
(
mComplete
)
{
return
;
}
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
OnCompleteFailed
-
-
complete
"
this
)
)
;
mComplete
=
true
;
aResult
.
RejectTo
(
mCompletePromise
)
;
}
void
ImageDecoder
:
:
OnMetadataSuccess
(
const
image
:
:
DecodeMetadataResult
&
aMetadata
)
{
if
(
mClosed
|
|
!
mTracks
)
{
return
;
}
MOZ_ASSERT
(
!
mTracksEstablished
)
;
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
OnMetadataSuccess
-
-
%
dx
%
d
repetitions
%
d
"
"
animated
%
d
frameCount
%
u
frameCountComplete
%
d
"
this
aMetadata
.
mWidth
aMetadata
.
mHeight
aMetadata
.
mRepetitions
aMetadata
.
mAnimated
aMetadata
.
mFrameCount
aMetadata
.
mFrameCountComplete
)
)
;
mTracks
-
>
OnMetadataSuccess
(
aMetadata
)
;
mTracksEstablished
=
true
;
OnFrameCountSuccess
(
image
:
:
DecodeFrameCountResult
{
aMetadata
.
mFrameCount
aMetadata
.
mFrameCountComplete
}
)
;
}
void
ImageDecoder
:
:
OnMetadataFailed
(
const
nsresult
&
aErr
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
OnMetadataFailed
0x
%
08x
"
this
static_cast
<
uint32_t
>
(
aErr
)
)
)
;
MOZ_ASSERT
(
!
mTracksEstablished
)
;
Close
(
MediaResult
(
NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR
"
Metadata
decoding
failed
"
_ns
)
)
;
}
void
ImageDecoder
:
:
RequestFrameCount
(
uint32_t
aKnownFrameCount
)
{
MOZ_ASSERT
(
!
mHasFrameCount
)
;
if
(
NS_WARN_IF
(
!
mDecoder
)
)
{
return
;
}
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
RequestFrameCount
-
-
knownFrameCount
%
u
"
this
aKnownFrameCount
)
)
;
mDecoder
-
>
DecodeFrameCount
(
aKnownFrameCount
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
self
=
RefPtr
{
this
}
]
(
const
image
:
:
DecodeFrameCountResult
&
aResult
)
{
self
-
>
OnFrameCountSuccess
(
aResult
)
;
}
[
self
=
RefPtr
{
this
}
]
(
const
nsresult
&
aErr
)
{
self
-
>
OnFrameCountFailed
(
aErr
)
;
}
)
;
}
void
ImageDecoder
:
:
RequestDecodeFrames
(
uint32_t
aFramesToDecode
)
{
if
(
!
mDecoder
|
|
mHasFramePending
)
{
return
;
}
mHasFramePending
=
true
;
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
RequestDecodeFrames
-
-
framesToDecode
%
u
"
this
aFramesToDecode
)
)
;
mDecoder
-
>
DecodeFrames
(
aFramesToDecode
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
self
=
RefPtr
{
this
}
]
(
const
image
:
:
DecodeFramesResult
&
aResult
)
{
self
-
>
OnDecodeFramesSuccess
(
aResult
)
;
}
[
self
=
RefPtr
{
this
}
]
(
const
nsresult
&
aErr
)
{
self
-
>
OnDecodeFramesFailed
(
aErr
)
;
}
)
;
}
void
ImageDecoder
:
:
OnFrameCountSuccess
(
const
image
:
:
DecodeFrameCountResult
&
aResult
)
{
if
(
mClosed
|
|
!
mTracks
)
{
return
;
}
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
OnFrameCountSuccess
-
-
frameCount
%
u
finished
%
d
"
this
aResult
.
mFrameCount
aResult
.
mFinished
)
)
;
MOZ_ASSERT
(
mTracksEstablished
)
;
mTracks
-
>
OnFrameCountSuccess
(
aResult
)
;
if
(
aResult
.
mFinished
)
{
mHasFrameCount
=
true
;
OnCompleteSuccess
(
)
;
}
else
{
RequestFrameCount
(
aResult
.
mFrameCount
)
;
}
CheckOutstandingDecodes
(
)
;
}
void
ImageDecoder
:
:
OnFrameCountFailed
(
const
nsresult
&
aErr
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
OnFrameCountFailed
"
this
)
)
;
Close
(
MediaResult
(
NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR
"
Frame
count
decoding
failed
"
_ns
)
)
;
}
void
ImageDecoder
:
:
GetType
(
nsAString
&
aType
)
const
{
aType
.
Assign
(
mType
)
;
}
already_AddRefed
<
Promise
>
ImageDecoder
:
:
Decode
(
const
ImageDecodeOptions
&
aOptions
ErrorResult
&
aRv
)
{
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
mParent
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
Decode
-
-
create
promise
failed
"
this
)
)
;
return
nullptr
;
}
if
(
mTypeNotSupported
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
Decode
-
-
not
supported
"
this
)
)
;
promise
-
>
MaybeRejectWithNotSupportedError
(
"
Unsupported
MIME
type
"
_ns
)
;
return
promise
.
forget
(
)
;
}
if
(
mClosed
|
|
!
mTracks
|
|
!
mDecoder
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
Decode
-
-
closed
"
this
)
)
;
promise
-
>
MaybeRejectWithInvalidStateError
(
"
Closed
decoder
"
_ns
)
;
return
promise
.
forget
(
)
;
}
ImageTrack
*
track
=
mTracks
-
>
GetSelectedTrack
(
)
;
if
(
mTracksEstablished
&
&
!
track
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
Decode
-
-
no
track
selected
"
this
)
)
;
promise
-
>
MaybeRejectWithInvalidStateError
(
"
No
track
selected
"
_ns
)
;
return
promise
.
forget
(
)
;
}
mOutstandingDecodes
.
AppendElement
(
OutstandingDecode
{
promise
aOptions
.
mFrameIndex
aOptions
.
mCompleteFramesOnly
}
)
;
QueueDecodeFrameMessage
(
)
;
ProcessControlMessageQueue
(
)
;
return
promise
.
forget
(
)
;
}
void
ImageDecoder
:
:
OnDecodeFramesSuccess
(
const
image
:
:
DecodeFramesResult
&
aResult
)
{
MOZ_ASSERT
(
mHasFramePending
)
;
mHasFramePending
=
false
;
MOZ_ASSERT
(
mTracksEstablished
)
;
if
(
mClosed
|
|
!
mTracks
)
{
return
;
}
ImageTrack
*
track
=
mTracks
-
>
GetDefaultTrack
(
)
;
if
(
NS_WARN_IF
(
!
track
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Must
have
default
track
!
"
)
;
return
;
}
track
-
>
OnDecodeFramesSuccess
(
aResult
)
;
CheckOutstandingDecodes
(
)
;
}
void
ImageDecoder
:
:
OnDecodeFramesFailed
(
const
nsresult
&
aErr
)
{
MOZ_ASSERT
(
mHasFramePending
)
;
mHasFramePending
=
false
;
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
OnDecodeFramesFailed
"
this
)
)
;
AutoTArray
<
OutstandingDecode
1
>
rejected
=
std
:
:
move
(
mOutstandingDecodes
)
;
for
(
const
auto
&
i
:
rejected
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Error
(
"
ImageDecoder
%
p
OnDecodeFramesFailed
-
-
reject
index
%
u
"
this
i
.
mFrameIndex
)
)
;
i
.
mPromise
-
>
MaybeRejectWithRangeError
(
"
No
more
frames
available
"
_ns
)
;
}
}
void
ImageDecoder
:
:
Reset
(
const
MediaResult
&
aResult
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
Reset
"
this
)
)
;
if
(
mDecoder
)
{
mDecoder
-
>
CancelDecodeFrames
(
)
;
}
AutoTArray
<
OutstandingDecode
1
>
rejected
=
std
:
:
move
(
mOutstandingDecodes
)
;
for
(
const
auto
&
i
:
rejected
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
Reset
-
-
reject
index
%
u
"
this
i
.
mFrameIndex
)
)
;
aResult
.
RejectTo
(
i
.
mPromise
)
;
}
}
void
ImageDecoder
:
:
Close
(
const
MediaResult
&
aResult
)
{
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
Debug
(
"
ImageDecoder
%
p
Close
"
this
)
)
;
mClosed
=
true
;
mTypeNotSupported
=
aResult
.
Code
(
)
=
=
NS_ERROR_DOM_NOT_SUPPORTED_ERR
;
Reset
(
aResult
)
;
if
(
mDecoder
)
{
mDecoder
-
>
Destroy
(
)
;
}
if
(
mReadRequest
)
{
mReadRequest
-
>
Destroy
(
true
)
;
mReadRequest
=
nullptr
;
}
mSourceBuffer
=
nullptr
;
mDecoder
=
nullptr
;
mType
=
u
"
"
_ns
;
if
(
mTracks
)
{
mTracks
-
>
MaybeRejectReady
(
aResult
)
;
mTracks
-
>
Destroy
(
)
;
}
if
(
!
mComplete
)
{
aResult
.
RejectTo
(
mCompletePromise
)
;
mComplete
=
true
;
}
if
(
mShutdownWatcher
)
{
mShutdownWatcher
-
>
Destroy
(
)
;
mShutdownWatcher
=
nullptr
;
}
}
void
ImageDecoder
:
:
Reset
(
)
{
Reset
(
MediaResult
(
NS_ERROR_DOM_ABORT_ERR
"
Reset
decoder
"
_ns
)
)
;
}
void
ImageDecoder
:
:
Close
(
)
{
Close
(
MediaResult
(
NS_ERROR_DOM_ABORT_ERR
"
Closed
decoder
"
_ns
)
)
;
}
void
ImageDecoder
:
:
OnShutdown
(
)
{
Close
(
MediaResult
(
NS_ERROR_DOM_ABORT_ERR
"
Shutdown
"
_ns
)
)
;
}
}
