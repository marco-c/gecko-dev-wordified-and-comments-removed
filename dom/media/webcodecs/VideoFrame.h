#
ifndef
mozilla_dom_VideoFrame_h
#
define
mozilla_dom_VideoFrame_h
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
RangedPtr
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
dom
/
VideoColorSpaceBinding
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsWrapperCache
.
h
"
class
nsIGlobalObject
;
class
nsIURI
;
namespace
mozilla
{
namespace
layers
{
class
Image
;
}
namespace
dom
{
class
DOMRectReadOnly
;
class
HTMLCanvasElement
;
class
HTMLImageElement
;
class
HTMLVideoElement
;
class
ImageBitmap
;
class
MaybeSharedArrayBufferViewOrMaybeSharedArrayBuffer
;
class
OffscreenCanvas
;
class
OwningMaybeSharedArrayBufferViewOrMaybeSharedArrayBuffer
;
class
Promise
;
class
SVGImageElement
;
class
StructuredCloneHolder
;
class
VideoColorSpace
;
class
VideoFrame
;
enum
class
VideoPixelFormat
:
uint8_t
;
struct
VideoFrameBufferInit
;
struct
VideoFrameInit
;
struct
VideoFrameCopyToOptions
;
}
}
namespace
mozilla
:
:
dom
{
struct
VideoFrameSerializedData
{
const
RefPtr
<
layers
:
:
Image
>
mImage
;
const
VideoPixelFormat
mFormat
;
const
gfx
:
:
IntSize
mCodedSize
;
const
gfx
:
:
IntRect
mVisibleRect
;
const
gfx
:
:
IntSize
mDisplaySize
;
const
Maybe
<
uint64_t
>
mDuration
;
const
int64_t
mTimestamp
;
const
VideoColorSpaceInit
mColorSpace
;
const
nsCOMPtr
<
nsIURI
>
mPrincipalURI
;
}
;
class
VideoFrame
final
:
public
nsISupports
public
nsWrapperCache
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
VideoFrame
)
public
:
VideoFrame
(
nsIGlobalObject
*
aParent
const
RefPtr
<
layers
:
:
Image
>
&
aImage
const
VideoPixelFormat
&
aFormat
gfx
:
:
IntSize
aCodedSize
gfx
:
:
IntRect
aVisibleRect
gfx
:
:
IntSize
aDisplaySize
const
Maybe
<
uint64_t
>
&
aDuration
int64_t
aTimestamp
const
VideoColorSpaceInit
&
aColorSpace
)
;
VideoFrame
(
const
VideoFrame
&
aOther
)
;
protected
:
~
VideoFrame
(
)
=
default
;
public
:
nsIGlobalObject
*
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
static
already_AddRefed
<
VideoFrame
>
Constructor
(
const
GlobalObject
&
aGlobal
HTMLImageElement
&
aImageElement
const
VideoFrameInit
&
aInit
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
VideoFrame
>
Constructor
(
const
GlobalObject
&
aGlobal
SVGImageElement
&
aSVGImageElement
const
VideoFrameInit
&
aInit
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
VideoFrame
>
Constructor
(
const
GlobalObject
&
aGlobal
HTMLCanvasElement
&
aCanvasElement
const
VideoFrameInit
&
aInit
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
VideoFrame
>
Constructor
(
const
GlobalObject
&
aGlobal
HTMLVideoElement
&
aVideoElement
const
VideoFrameInit
&
aInit
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
VideoFrame
>
Constructor
(
const
GlobalObject
&
aGlobal
OffscreenCanvas
&
aOffscreenCanvas
const
VideoFrameInit
&
aInit
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
VideoFrame
>
Constructor
(
const
GlobalObject
&
aGlobal
ImageBitmap
&
aImageBitmap
const
VideoFrameInit
&
aInit
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
VideoFrame
>
Constructor
(
const
GlobalObject
&
aGlobal
VideoFrame
&
aVideoFrame
const
VideoFrameInit
&
aInit
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
VideoFrame
>
Constructor
(
const
GlobalObject
&
aGlobal
const
ArrayBufferView
&
aBufferView
const
VideoFrameBufferInit
&
aInit
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
VideoFrame
>
Constructor
(
const
GlobalObject
&
aGlobal
const
ArrayBuffer
&
aBuffer
const
VideoFrameBufferInit
&
aInit
ErrorResult
&
aRv
)
;
Nullable
<
VideoPixelFormat
>
GetFormat
(
)
const
;
uint32_t
CodedWidth
(
)
const
;
uint32_t
CodedHeight
(
)
const
;
already_AddRefed
<
DOMRectReadOnly
>
GetCodedRect
(
)
const
;
already_AddRefed
<
DOMRectReadOnly
>
GetVisibleRect
(
)
const
;
uint32_t
DisplayWidth
(
)
const
;
uint32_t
DisplayHeight
(
)
const
;
Nullable
<
uint64_t
>
GetDuration
(
)
const
;
int64_t
Timestamp
(
)
const
;
already_AddRefed
<
VideoColorSpace
>
ColorSpace
(
)
const
;
uint32_t
AllocationSize
(
const
VideoFrameCopyToOptions
&
aOptions
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
CopyTo
(
const
MaybeSharedArrayBufferViewOrMaybeSharedArrayBuffer
&
aDestination
const
VideoFrameCopyToOptions
&
aOptions
ErrorResult
&
aRv
)
;
already_AddRefed
<
VideoFrame
>
Clone
(
ErrorResult
&
aRv
)
;
void
Close
(
)
;
static
JSObject
*
ReadStructuredClone
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
JSStructuredCloneReader
*
aReader
const
VideoFrameSerializedData
&
aData
)
;
bool
WriteStructuredClone
(
JSStructuredCloneWriter
*
aWriter
StructuredCloneHolder
*
aHolder
)
const
;
struct
TransferredData
;
UniquePtr
<
TransferredData
>
Transfer
(
)
;
static
already_AddRefed
<
VideoFrame
>
FromTransferred
(
nsIGlobalObject
*
aGlobal
TransferredData
*
aData
)
;
public
:
class
Format
final
{
public
:
explicit
Format
(
const
VideoPixelFormat
&
aFormat
)
;
~
Format
(
)
=
default
;
const
VideoPixelFormat
&
PixelFormat
(
)
const
;
gfx
:
:
SurfaceFormat
ToSurfaceFormat
(
)
const
;
void
MakeOpaque
(
)
;
enum
class
Plane
:
uint8_t
{
Y
=
0
RGBA
=
Y
U
=
1
UV
=
U
V
=
2
A
=
3
}
;
nsTArray
<
Plane
>
Planes
(
)
const
;
const
char
*
PlaneName
(
const
Plane
&
aPlane
)
const
;
uint32_t
SampleBytes
(
const
Plane
&
aPlane
)
const
;
gfx
:
:
IntSize
SampleSize
(
const
Plane
&
aPlane
)
const
;
bool
IsValidSize
(
const
gfx
:
:
IntSize
&
aSize
)
const
;
size_t
SampleCount
(
const
gfx
:
:
IntSize
&
aSize
)
const
;
private
:
bool
IsYUV
(
)
const
;
VideoPixelFormat
mFormat
;
}
;
struct
FrameData
{
FrameData
(
layers
:
:
Image
*
aImage
const
VideoPixelFormat
&
aFormat
gfx
:
:
IntRect
aVisibleRect
gfx
:
:
IntSize
aDisplaySize
Maybe
<
uint64_t
>
aDuration
int64_t
aTimestamp
const
VideoColorSpaceInit
&
aColorSpace
)
:
mImage
(
aImage
)
mFormat
(
aFormat
)
mVisibleRect
(
aVisibleRect
)
mDisplaySize
(
aDisplaySize
)
mDuration
(
aDuration
)
mTimestamp
(
aTimestamp
)
mColorSpace
(
aColorSpace
)
{
}
RefPtr
<
layers
:
:
Image
>
mImage
;
VideoFrame
:
:
Format
mFormat
;
const
gfx
:
:
IntRect
mVisibleRect
;
const
gfx
:
:
IntSize
mDisplaySize
;
Maybe
<
uint64_t
>
mDuration
;
int64_t
mTimestamp
;
const
VideoColorSpaceInit
mColorSpace
;
}
;
struct
TransferredData
:
FrameData
{
TransferredData
(
layers
:
:
Image
*
aImage
const
VideoPixelFormat
&
aFormat
gfx
:
:
IntRect
aVisibleRect
gfx
:
:
IntSize
aDisplaySize
Maybe
<
uint64_t
>
aDuration
int64_t
aTimestamp
const
VideoColorSpaceInit
&
aColorSpace
already_AddRefed
<
nsIURI
>
aPrincipalURI
)
:
FrameData
(
aImage
aFormat
aVisibleRect
aDisplaySize
aDuration
aTimestamp
aColorSpace
)
mPrincipalURI
(
aPrincipalURI
)
{
}
const
nsCOMPtr
<
nsIURI
>
mPrincipalURI
;
}
;
private
:
void
AssertIsOnOwningThread
(
)
const
{
NS_ASSERT_OWNINGTHREAD
(
VideoFrame
)
;
}
already_AddRefed
<
nsIURI
>
GetPrincipalURI
(
)
const
;
class
Resource
final
{
public
:
Resource
(
const
RefPtr
<
layers
:
:
Image
>
&
aImage
const
Format
&
aFormat
)
;
Resource
(
const
Resource
&
aOther
)
;
~
Resource
(
)
=
default
;
uint32_t
Stride
(
const
Format
:
:
Plane
&
aPlane
)
const
;
bool
CopyTo
(
const
Format
:
:
Plane
&
aPlane
const
gfx
:
:
IntRect
&
aRect
RangedPtr
<
uint8_t
>
&
&
aPlaneDest
size_t
aDestinationStride
)
const
;
const
RefPtr
<
layers
:
:
Image
>
mImage
;
const
Format
mFormat
;
}
;
nsCOMPtr
<
nsIGlobalObject
>
mParent
;
Maybe
<
const
Resource
>
mResource
;
gfx
:
:
IntSize
mCodedSize
;
gfx
:
:
IntRect
mVisibleRect
;
gfx
:
:
IntSize
mDisplaySize
;
Maybe
<
uint64_t
>
mDuration
;
int64_t
mTimestamp
;
VideoColorSpaceInit
mColorSpace
;
}
;
}
#
endif
