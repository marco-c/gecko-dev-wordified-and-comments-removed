#
include
"
DecoderAgent
.
h
"
#
include
<
atomic
>
#
include
"
ImageContainer
.
h
"
#
include
"
MediaDataDecoderProxy
.
h
"
#
include
"
PDMFactory
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
nsThreadUtils
.
h
"
extern
mozilla
:
:
LazyLogModule
gWebCodecsLog
;
namespace
mozilla
{
#
ifdef
LOG_INTERNAL
#
undef
LOG_INTERNAL
#
endif
#
define
LOG_INTERNAL
(
level
msg
.
.
.
)
\
MOZ_LOG
(
gWebCodecsLog
LogLevel
:
:
level
(
msg
#
#
__VA_ARGS__
)
)
#
ifdef
LOG
#
undef
LOG
#
endif
#
define
LOG
(
msg
.
.
.
)
LOG_INTERNAL
(
Debug
msg
#
#
__VA_ARGS__
)
#
ifdef
LOGW
#
undef
LOGW
#
endif
#
define
LOGW
(
msg
.
.
.
)
LOG_INTERNAL
(
Warning
msg
#
#
__VA_ARGS__
)
#
ifdef
LOGE
#
undef
LOGE
#
endif
#
define
LOGE
(
msg
.
.
.
)
LOG_INTERNAL
(
Error
msg
#
#
__VA_ARGS__
)
already_AddRefed
<
DecoderAgent
>
DecoderAgent
:
:
Create
(
UniquePtr
<
TrackInfo
>
&
&
aInfo
)
{
MOZ_ASSERT
(
aInfo
)
;
static
std
:
:
atomic
<
Id
>
sNextId
=
None
;
RefPtr
<
DecoderAgent
>
agent
=
new
DecoderAgent
(
+
+
sNextId
std
:
:
move
(
aInfo
)
)
;
return
agent
.
forget
(
)
;
}
DecoderAgent
:
:
DecoderAgent
(
Id
aId
UniquePtr
<
TrackInfo
>
&
&
aInfo
)
:
mId
(
aId
)
mInfo
(
std
:
:
move
(
aInfo
)
)
mOwnerThread
(
GetCurrentSerialEventTarget
(
)
)
mPDMFactory
(
MakeRefPtr
<
PDMFactory
>
(
)
)
mImageContainer
(
MakeAndAddRef
<
layers
:
:
ImageContainer
>
(
layers
:
:
ImageContainer
:
:
ASYNCHRONOUS
)
)
mDecoder
(
nullptr
)
mState
(
State
:
:
Unconfigured
)
{
MOZ_ASSERT
(
mInfo
)
;
MOZ_ASSERT
(
mOwnerThread
)
;
MOZ_ASSERT
(
mPDMFactory
)
;
MOZ_ASSERT
(
mImageContainer
)
;
LOG
(
"
DecoderAgent
#
%
d
(
%
p
)
ctor
"
mId
this
)
;
}
DecoderAgent
:
:
~
DecoderAgent
(
)
{
LOG
(
"
DecoderAgent
#
%
d
(
%
p
)
dtor
"
mId
this
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Unconfigured
"
decoder
release
in
wrong
state
"
)
;
MOZ_ASSERT
(
!
mDecoder
"
decoder
must
be
shutdown
"
)
;
}
RefPtr
<
DecoderAgent
:
:
ConfigurePromise
>
DecoderAgent
:
:
Configure
(
bool
aPreferSoftwareDecoder
bool
aLowLatency
)
{
MOZ_ASSERT
(
mOwnerThread
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Unconfigured
|
|
mState
=
=
State
:
:
Error
)
;
MOZ_ASSERT
(
mConfigurePromise
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
mCreateRequest
.
Exists
(
)
)
;
MOZ_ASSERT
(
!
mInitRequest
.
Exists
(
)
)
;
if
(
mState
=
=
State
:
:
Error
)
{
LOGE
(
"
DecoderAgent
#
%
d
(
%
p
)
tried
to
configure
in
error
state
"
mId
this
)
;
return
ConfigurePromise
:
:
CreateAndReject
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
"
Cannot
configure
in
error
state
"
)
__func__
)
;
}
MOZ_ASSERT
(
mState
=
=
State
:
:
Unconfigured
)
;
MOZ_ASSERT
(
!
mDecoder
)
;
SetState
(
State
:
:
Configuring
)
;
RefPtr
<
layers
:
:
KnowsCompositor
>
knowsCompositor
=
layers
:
:
ImageBridgeChild
:
:
GetSingleton
(
)
;
auto
params
=
CreateDecoderParams
{
*
mInfo
CreateDecoderParams
:
:
OptionSet
(
CreateDecoderParams
:
:
Option
:
:
LowLatency
aPreferSoftwareDecoder
?
CreateDecoderParams
:
:
Option
:
:
HardwareDecoderNotAllowed
:
CreateDecoderParams
:
:
Option
:
:
Default
)
mInfo
-
>
GetType
(
)
mImageContainer
knowsCompositor
}
;
LOG
(
"
DecoderAgent
#
%
d
(
%
p
)
is
creating
a
decoder
-
PreferSW
:
%
s
"
"
low
-
latency
:
%
syes
"
mId
this
aPreferSoftwareDecoder
?
"
yes
"
:
"
no
"
aLowLatency
?
"
"
:
"
forcibly
"
)
;
RefPtr
<
ConfigurePromise
>
p
=
mConfigurePromise
.
Ensure
(
__func__
)
;
mPDMFactory
-
>
CreateDecoder
(
params
)
-
>
Then
(
mOwnerThread
__func__
[
self
=
RefPtr
{
this
}
]
(
RefPtr
<
MediaDataDecoder
>
&
&
aDecoder
)
{
self
-
>
mCreateRequest
.
Complete
(
)
;
if
(
!
self
-
>
mShutdownWhileCreationPromise
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
self
-
>
mState
=
=
State
:
:
ShuttingDown
)
;
MOZ_ASSERT
(
self
-
>
mConfigurePromise
.
IsEmpty
(
)
"
configuration
should
have
been
rejected
"
)
;
LOGW
(
"
DecoderAgent
#
%
d
(
%
p
)
has
been
shut
down
.
We
need
to
shut
"
"
the
newly
created
decoder
down
"
self
-
>
mId
self
.
get
(
)
)
;
aDecoder
-
>
Shutdown
(
)
-
>
Then
(
self
-
>
mOwnerThread
__func__
[
self
]
(
const
ShutdownPromise
:
:
ResolveOrRejectValue
&
aValue
)
{
MOZ_ASSERT
(
self
-
>
mState
=
=
State
:
:
ShuttingDown
)
;
LOGW
(
"
DecoderAgent
#
%
d
(
%
p
)
newly
created
decoder
shutdown
"
"
has
been
%
s
"
self
-
>
mId
self
.
get
(
)
aValue
.
IsResolve
(
)
?
"
resolved
"
:
"
rejected
"
)
;
self
-
>
SetState
(
State
:
:
Unconfigured
)
;
self
-
>
mShutdownWhileCreationPromise
.
ResolveOrReject
(
aValue
__func__
)
;
}
)
;
return
;
}
self
-
>
mDecoder
=
new
MediaDataDecoderProxy
(
aDecoder
.
forget
(
)
CreateMediaDecodeTaskQueue
(
"
DecoderAgent
TaskQueue
"
)
)
;
LOG
(
"
DecoderAgent
#
%
d
(
%
p
)
has
created
a
decoder
now
initialize
"
"
it
"
self
-
>
mId
self
.
get
(
)
)
;
self
-
>
mDecoder
-
>
Init
(
)
-
>
Then
(
self
-
>
mOwnerThread
__func__
[
self
]
(
const
TrackInfo
:
:
TrackType
aTrackType
)
{
self
-
>
mInitRequest
.
Complete
(
)
;
LOG
(
"
DecoderAgent
#
%
d
(
%
p
)
has
initialized
the
decoder
"
self
-
>
mId
self
.
get
(
)
)
;
MOZ_ASSERT
(
aTrackType
=
=
self
-
>
mInfo
-
>
GetType
(
)
)
;
self
-
>
SetState
(
State
:
:
Configured
)
;
self
-
>
mConfigurePromise
.
Resolve
(
true
__func__
)
;
}
[
self
]
(
const
MediaResult
&
aError
)
{
self
-
>
mInitRequest
.
Complete
(
)
;
LOGE
(
"
DecoderAgent
#
%
d
(
%
p
)
failed
to
initialize
the
"
"
decoder
"
self
-
>
mId
self
.
get
(
)
)
;
self
-
>
SetState
(
State
:
:
Error
)
;
self
-
>
mConfigurePromise
.
Reject
(
aError
__func__
)
;
}
)
-
>
Track
(
self
-
>
mInitRequest
)
;
}
[
self
=
RefPtr
{
this
}
]
(
const
MediaResult
&
aError
)
{
self
-
>
mCreateRequest
.
Complete
(
)
;
LOGE
(
"
DecoderAgent
#
%
d
(
%
p
)
failed
to
create
a
decoder
"
self
-
>
mId
self
.
get
(
)
)
;
if
(
!
self
-
>
mShutdownWhileCreationPromise
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
self
-
>
mState
=
=
State
:
:
ShuttingDown
)
;
MOZ_ASSERT
(
self
-
>
mConfigurePromise
.
IsEmpty
(
)
"
configuration
should
have
been
rejected
"
)
;
LOGW
(
"
DecoderAgent
#
%
d
(
%
p
)
has
been
shut
down
.
Resolve
the
"
"
shutdown
promise
right
away
since
decoder
creation
failed
"
self
-
>
mId
self
.
get
(
)
)
;
self
-
>
SetState
(
State
:
:
Unconfigured
)
;
self
-
>
mShutdownWhileCreationPromise
.
Resolve
(
true
__func__
)
;
return
;
}
self
-
>
SetState
(
State
:
:
Error
)
;
self
-
>
mConfigurePromise
.
Reject
(
aError
__func__
)
;
}
)
-
>
Track
(
mCreateRequest
)
;
return
p
;
}
RefPtr
<
ShutdownPromise
>
DecoderAgent
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
mOwnerThread
-
>
IsOnCurrentThread
(
)
)
;
auto
r
=
MediaResult
(
NS_ERROR_DOM_MEDIA_CANCELED
"
Canceled
by
decoder
shutdown
"
)
;
if
(
mCreateRequest
.
Exists
(
)
)
{
MOZ_ASSERT
(
!
mInitRequest
.
Exists
(
)
)
;
MOZ_ASSERT
(
!
mConfigurePromise
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
mDecoder
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Configuring
)
;
MOZ_ASSERT
(
mShutdownWhileCreationPromise
.
IsEmpty
(
)
)
;
LOGW
(
"
DecoderAgent
#
%
d
(
%
p
)
shutdown
while
the
decoder
-
creation
for
"
"
configuration
is
in
flight
.
Reject
the
configuration
now
and
defer
"
"
the
shutdown
until
the
created
decoder
has
been
shut
down
"
mId
this
)
;
mConfigurePromise
.
Reject
(
r
__func__
)
;
SetState
(
State
:
:
ShuttingDown
)
;
return
mShutdownWhileCreationPromise
.
Ensure
(
__func__
)
;
}
MOZ_ASSERT
(
mDecoder
)
;
mInitRequest
.
DisconnectIfExists
(
)
;
mConfigurePromise
.
RejectIfExists
(
r
__func__
)
;
SetState
(
State
:
:
Unconfigured
)
;
RefPtr
<
MediaDataDecoder
>
decoder
=
std
:
:
move
(
mDecoder
)
;
return
decoder
-
>
Shutdown
(
)
;
}
void
DecoderAgent
:
:
SetState
(
State
aState
)
{
MOZ_ASSERT
(
mOwnerThread
-
>
IsOnCurrentThread
(
)
)
;
auto
validateStateTransition
=
[
]
(
State
aOldState
State
aNewState
)
{
switch
(
aOldState
)
{
case
State
:
:
Unconfigured
:
return
aNewState
=
=
State
:
:
Configuring
;
case
State
:
:
Configuring
:
return
aNewState
=
=
State
:
:
Configured
|
|
aNewState
=
=
State
:
:
Error
|
|
aNewState
=
=
State
:
:
Unconfigured
|
|
aNewState
=
=
State
:
:
ShuttingDown
;
case
State
:
:
Configured
:
return
aNewState
=
=
State
:
:
Unconfigured
;
case
State
:
:
ShuttingDown
:
return
aNewState
=
=
State
:
:
Unconfigured
;
case
State
:
:
Error
:
return
aNewState
=
=
State
:
:
Unconfigured
;
default
:
break
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
state
transition
"
)
;
return
false
;
}
;
auto
stateToString
=
[
]
(
State
aState
)
-
>
const
char
*
{
switch
(
aState
)
{
case
State
:
:
Unconfigured
:
return
"
Unconfigured
"
;
case
State
:
:
Configuring
:
return
"
Configuring
"
;
case
State
:
:
Configured
:
return
"
Configured
"
;
case
State
:
:
ShuttingDown
:
return
"
ShuttingDown
"
;
case
State
:
:
Error
:
return
"
Error
"
;
default
:
break
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
state
type
"
)
;
return
"
Unknown
"
;
}
;
DebugOnly
<
bool
>
isValid
=
validateStateTransition
(
mState
aState
)
;
MOZ_ASSERT
(
isValid
)
;
LOG
(
"
DecoderAgent
#
%
d
(
%
p
)
state
change
:
%
s
-
>
%
s
"
mId
this
stateToString
(
mState
)
stateToString
(
aState
)
)
;
mState
=
aState
;
}
#
undef
LOG
#
undef
LOGW
#
undef
LOGE
#
undef
LOG_INTERNAL
}
