#
include
"
AudioSink
.
h
"
#
include
"
AudioStream
.
h
"
#
include
"
MediaQueue
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
namespace
mozilla
{
extern
PRLogModuleInfo
*
gMediaDecoderLog
;
#
define
SINK_LOG
(
msg
.
.
.
)
\
MOZ_LOG
(
gMediaDecoderLog
LogLevel
:
:
Debug
(
"
AudioSink
=
%
p
"
msg
this
#
#
__VA_ARGS__
)
)
#
define
SINK_LOG_V
(
msg
.
.
.
)
\
MOZ_LOG
(
gMediaDecoderLog
LogLevel
:
:
Verbose
(
"
AudioSink
=
%
p
"
msg
this
#
#
__VA_ARGS__
)
)
static
const
int64_t
AUDIO_FUZZ_FRAMES
=
1
;
AudioSink
:
:
AudioSink
(
MediaQueue
<
AudioData
>
&
aAudioQueue
int64_t
aStartTime
const
AudioInfo
&
aInfo
dom
:
:
AudioChannel
aChannel
)
:
mAudioQueue
(
aAudioQueue
)
mMonitor
(
"
AudioSink
:
:
mMonitor
"
)
mState
(
AUDIOSINK_STATE_INIT
)
mAudioLoopScheduled
(
false
)
mStartTime
(
aStartTime
)
mWritten
(
0
)
mLastGoodPosition
(
0
)
mInfo
(
aInfo
)
mChannel
(
aChannel
)
mStopAudioThread
(
false
)
mPlaying
(
true
)
{
}
void
AudioSink
:
:
SetState
(
State
aState
)
{
AssertOnAudioThread
(
)
;
mPendingState
=
Some
(
aState
)
;
}
void
AudioSink
:
:
DispatchTask
(
already_AddRefed
<
nsIRunnable
>
&
&
event
)
{
DebugOnly
<
nsresult
>
rv
=
mThread
-
>
Dispatch
(
Move
(
event
)
NS_DISPATCH_NORMAL
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
void
AudioSink
:
:
ScheduleNextLoop
(
)
{
AssertOnAudioThread
(
)
;
if
(
mAudioLoopScheduled
)
{
return
;
}
mAudioLoopScheduled
=
true
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableMethod
(
this
&
AudioSink
:
:
AudioLoop
)
;
DispatchTask
(
r
.
forget
(
)
)
;
}
void
AudioSink
:
:
ScheduleNextLoopCrossThread
(
)
{
AssertNotOnAudioThread
(
)
;
nsRefPtr
<
AudioSink
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
self
]
(
)
{
if
(
!
self
-
>
mAudioLoopScheduled
)
{
self
-
>
AudioLoop
(
)
;
}
}
)
;
DispatchTask
(
r
.
forget
(
)
)
;
}
nsRefPtr
<
GenericPromise
>
AudioSink
:
:
Init
(
)
{
nsRefPtr
<
GenericPromise
>
p
=
mEndPromise
.
Ensure
(
__func__
)
;
nsresult
rv
=
NS_NewNamedThread
(
"
Media
Audio
"
getter_AddRefs
(
mThread
)
nullptr
MEDIA_THREAD_STACK_SIZE
)
;
if
(
NS_FAILED
(
rv
)
)
{
mEndPromise
.
Reject
(
rv
__func__
)
;
return
p
;
}
ScheduleNextLoopCrossThread
(
)
;
return
p
;
}
int64_t
AudioSink
:
:
GetPosition
(
)
{
ReentrantMonitorAutoEnter
mon
(
GetReentrantMonitor
(
)
)
;
int64_t
pos
;
if
(
mAudioStream
&
&
(
pos
=
mAudioStream
-
>
GetPosition
(
)
)
>
=
0
)
{
mLastGoodPosition
=
pos
;
}
return
mStartTime
+
mLastGoodPosition
;
}
bool
AudioSink
:
:
HasUnplayedFrames
(
)
{
ReentrantMonitorAutoEnter
mon
(
GetReentrantMonitor
(
)
)
;
return
mAudioStream
&
&
mAudioStream
-
>
GetPositionInFrames
(
)
+
1
<
mWritten
;
}
void
AudioSink
:
:
Shutdown
(
)
{
ReentrantMonitorAutoEnter
mon
(
GetReentrantMonitor
(
)
)
;
mStopAudioThread
=
true
;
if
(
mAudioStream
)
{
mAudioStream
-
>
Cancel
(
)
;
}
ScheduleNextLoopCrossThread
(
)
;
ReentrantMonitorAutoExit
exit
(
GetReentrantMonitor
(
)
)
;
mThread
-
>
Shutdown
(
)
;
mThread
=
nullptr
;
if
(
mAudioStream
)
{
mAudioStream
-
>
Shutdown
(
)
;
mAudioStream
=
nullptr
;
}
MOZ_ASSERT
(
mState
=
=
AUDIOSINK_STATE_SHUTDOWN
|
|
mState
=
=
AUDIOSINK_STATE_ERROR
)
;
MOZ_ASSERT
(
mPendingState
.
isNothing
(
)
)
;
}
void
AudioSink
:
:
SetVolume
(
double
aVolume
)
{
AssertNotOnAudioThread
(
)
;
nsRefPtr
<
AudioSink
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
=
]
(
)
{
if
(
self
-
>
mState
=
=
AUDIOSINK_STATE_PLAYING
)
{
self
-
>
mAudioStream
-
>
SetVolume
(
aVolume
)
;
}
}
)
;
DispatchTask
(
r
.
forget
(
)
)
;
}
void
AudioSink
:
:
SetPlaybackRate
(
double
aPlaybackRate
)
{
AssertNotOnAudioThread
(
)
;
MOZ_ASSERT
(
aPlaybackRate
!
=
0
"
Don
'
t
set
the
playbackRate
to
0
on
AudioStream
"
)
;
nsRefPtr
<
AudioSink
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
=
]
(
)
{
if
(
self
-
>
mState
=
=
AUDIOSINK_STATE_PLAYING
)
{
self
-
>
mAudioStream
-
>
SetPlaybackRate
(
aPlaybackRate
)
;
}
}
)
;
DispatchTask
(
r
.
forget
(
)
)
;
}
void
AudioSink
:
:
SetPreservesPitch
(
bool
aPreservesPitch
)
{
AssertNotOnAudioThread
(
)
;
nsRefPtr
<
AudioSink
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
=
]
(
)
{
if
(
self
-
>
mState
=
=
AUDIOSINK_STATE_PLAYING
)
{
self
-
>
mAudioStream
-
>
SetPreservesPitch
(
aPreservesPitch
)
;
}
}
)
;
DispatchTask
(
r
.
forget
(
)
)
;
}
void
AudioSink
:
:
SetPlaying
(
bool
aPlaying
)
{
AssertNotOnAudioThread
(
)
;
nsRefPtr
<
AudioSink
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
=
]
(
)
{
if
(
self
-
>
mState
!
=
AUDIOSINK_STATE_PLAYING
|
|
self
-
>
mPlaying
=
=
aPlaying
)
{
return
;
}
self
-
>
mPlaying
=
aPlaying
;
if
(
!
aPlaying
&
&
!
self
-
>
mAudioStream
-
>
IsPaused
(
)
)
{
self
-
>
mAudioStream
-
>
Pause
(
)
;
}
else
if
(
aPlaying
&
&
self
-
>
mAudioStream
-
>
IsPaused
(
)
)
{
self
-
>
mAudioStream
-
>
Resume
(
)
;
}
if
(
aPlaying
&
&
!
self
-
>
mAudioLoopScheduled
)
{
self
-
>
AudioLoop
(
)
;
}
}
)
;
DispatchTask
(
r
.
forget
(
)
)
;
}
void
AudioSink
:
:
NotifyData
(
)
{
ScheduleNextLoopCrossThread
(
)
;
}
nsresult
AudioSink
:
:
InitializeAudioStream
(
)
{
RefPtr
<
AudioStream
>
audioStream
(
new
AudioStream
(
)
)
;
nsresult
rv
=
audioStream
-
>
Init
(
mInfo
.
mChannels
mInfo
.
mRate
mChannel
AudioStream
:
:
HighLatency
)
;
if
(
NS_FAILED
(
rv
)
)
{
audioStream
-
>
Shutdown
(
)
;
return
rv
;
}
ReentrantMonitorAutoEnter
mon
(
GetReentrantMonitor
(
)
)
;
mAudioStream
=
audioStream
;
return
NS_OK
;
}
void
AudioSink
:
:
Drain
(
)
{
MOZ_ASSERT
(
mPlaying
&
&
!
mAudioStream
-
>
IsPaused
(
)
)
;
AssertCurrentThreadInMonitor
(
)
;
mAudioStream
-
>
Start
(
)
;
{
ReentrantMonitorAutoExit
exit
(
GetReentrantMonitor
(
)
)
;
mAudioStream
-
>
Drain
(
)
;
}
}
void
AudioSink
:
:
Cleanup
(
)
{
AssertCurrentThreadInMonitor
(
)
;
mEndPromise
.
Resolve
(
true
__func__
)
;
}
bool
AudioSink
:
:
ExpectMoreAudioData
(
)
{
return
AudioQueue
(
)
.
GetSize
(
)
=
=
0
&
&
!
AudioQueue
(
)
.
IsFinished
(
)
;
}
bool
AudioSink
:
:
WaitingForAudioToPlay
(
)
{
AssertCurrentThreadInMonitor
(
)
;
if
(
!
mStopAudioThread
&
&
(
!
mPlaying
|
|
ExpectMoreAudioData
(
)
)
)
{
return
true
;
}
return
false
;
}
bool
AudioSink
:
:
IsPlaybackContinuing
(
)
{
AssertCurrentThreadInMonitor
(
)
;
if
(
mStopAudioThread
|
|
AudioQueue
(
)
.
AtEndOfStream
(
)
)
{
return
false
;
}
return
true
;
}
void
AudioSink
:
:
AudioLoop
(
)
{
AssertOnAudioThread
(
)
;
mAudioLoopScheduled
=
false
;
switch
(
mState
)
{
case
AUDIOSINK_STATE_INIT
:
{
SINK_LOG
(
"
AudioLoop
started
"
)
;
nsresult
rv
=
InitializeAudioStream
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Initializing
AudioStream
failed
.
"
)
;
mEndPromise
.
Reject
(
rv
__func__
)
;
SetState
(
AUDIOSINK_STATE_ERROR
)
;
break
;
}
SetState
(
AUDIOSINK_STATE_PLAYING
)
;
break
;
}
case
AUDIOSINK_STATE_PLAYING
:
{
{
ReentrantMonitorAutoEnter
mon
(
GetReentrantMonitor
(
)
)
;
if
(
WaitingForAudioToPlay
(
)
)
{
break
;
}
if
(
!
IsPlaybackContinuing
(
)
)
{
SetState
(
AUDIOSINK_STATE_COMPLETE
)
;
break
;
}
}
if
(
!
PlayAudio
(
)
)
{
SetState
(
AUDIOSINK_STATE_COMPLETE
)
;
break
;
}
ScheduleNextLoop
(
)
;
break
;
}
case
AUDIOSINK_STATE_COMPLETE
:
{
FinishAudioLoop
(
)
;
SetState
(
AUDIOSINK_STATE_SHUTDOWN
)
;
break
;
}
case
AUDIOSINK_STATE_SHUTDOWN
:
break
;
case
AUDIOSINK_STATE_ERROR
:
break
;
}
if
(
mPendingState
.
isSome
(
)
)
{
MOZ_ASSERT
(
mState
!
=
mPendingState
.
ref
(
)
)
;
SINK_LOG
(
"
change
mState
%
d
-
>
%
d
"
mState
mPendingState
.
ref
(
)
)
;
mState
=
mPendingState
.
ref
(
)
;
mPendingState
.
reset
(
)
;
ScheduleNextLoop
(
)
;
}
}
bool
AudioSink
:
:
PlayAudio
(
)
{
NS_ASSERTION
(
AudioQueue
(
)
.
GetSize
(
)
>
0
"
Should
have
data
to
play
"
)
;
CheckedInt64
sampleTime
=
UsecsToFrames
(
AudioQueue
(
)
.
PeekFront
(
)
-
>
mTime
mInfo
.
mRate
)
;
CheckedInt64
playedFrames
=
UsecsToFrames
(
mStartTime
mInfo
.
mRate
)
+
static_cast
<
int64_t
>
(
mWritten
)
;
CheckedInt64
missingFrames
=
sampleTime
-
playedFrames
;
if
(
!
missingFrames
.
isValid
(
)
|
|
!
sampleTime
.
isValid
(
)
)
{
NS_WARNING
(
"
Int
overflow
adding
in
AudioLoop
"
)
;
return
false
;
}
if
(
missingFrames
.
value
(
)
>
AUDIO_FUZZ_FRAMES
)
{
missingFrames
=
std
:
:
min
<
int64_t
>
(
UINT32_MAX
missingFrames
.
value
(
)
)
;
mWritten
+
=
PlaySilence
(
static_cast
<
uint32_t
>
(
missingFrames
.
value
(
)
)
)
;
}
else
{
mWritten
+
=
PlayFromAudioQueue
(
)
;
}
return
true
;
}
void
AudioSink
:
:
FinishAudioLoop
(
)
{
ReentrantMonitorAutoEnter
mon
(
GetReentrantMonitor
(
)
)
;
MOZ_ASSERT
(
mStopAudioThread
|
|
AudioQueue
(
)
.
AtEndOfStream
(
)
)
;
if
(
!
mStopAudioThread
&
&
mPlaying
)
{
Drain
(
)
;
}
SINK_LOG
(
"
AudioLoop
complete
"
)
;
Cleanup
(
)
;
SINK_LOG
(
"
AudioLoop
exit
"
)
;
}
uint32_t
AudioSink
:
:
PlaySilence
(
uint32_t
aFrames
)
{
const
uint32_t
SILENCE_BYTES_CHUNK
=
32
*
1024
;
AssertOnAudioThread
(
)
;
NS_ASSERTION
(
!
mAudioStream
-
>
IsPaused
(
)
"
Don
'
t
play
when
paused
"
)
;
uint32_t
maxFrames
=
SILENCE_BYTES_CHUNK
/
mInfo
.
mChannels
/
sizeof
(
AudioDataValue
)
;
uint32_t
frames
=
std
:
:
min
(
aFrames
maxFrames
)
;
SINK_LOG_V
(
"
playing
%
u
frames
of
silence
"
aFrames
)
;
WriteSilence
(
frames
)
;
return
frames
;
}
uint32_t
AudioSink
:
:
PlayFromAudioQueue
(
)
{
AssertOnAudioThread
(
)
;
NS_ASSERTION
(
!
mAudioStream
-
>
IsPaused
(
)
"
Don
'
t
play
when
paused
"
)
;
nsRefPtr
<
AudioData
>
audio
(
AudioQueue
(
)
.
PopFront
(
)
)
;
SINK_LOG_V
(
"
playing
%
u
frames
of
audio
at
time
%
lld
"
audio
-
>
mFrames
audio
-
>
mTime
)
;
if
(
audio
-
>
mRate
=
=
mInfo
.
mRate
&
&
audio
-
>
mChannels
=
=
mInfo
.
mChannels
)
{
mAudioStream
-
>
Write
(
audio
-
>
mAudioData
audio
-
>
mFrames
)
;
}
else
{
SINK_LOG_V
(
"
mismatched
sample
format
mInfo
=
[
%
uHz
/
%
u
channels
]
audio
=
[
%
uHz
/
%
u
channels
]
"
mInfo
.
mRate
mInfo
.
mChannels
audio
-
>
mRate
audio
-
>
mChannels
)
;
PlaySilence
(
audio
-
>
mFrames
)
;
}
StartAudioStreamPlaybackIfNeeded
(
)
;
return
audio
-
>
mFrames
;
}
void
AudioSink
:
:
StartAudioStreamPlaybackIfNeeded
(
)
{
const
uint32_t
MIN_WRITE_BEFORE_START_USECS
=
200000
;
if
(
static_cast
<
double
>
(
mAudioStream
-
>
GetWritten
(
)
)
/
mAudioStream
-
>
GetRate
(
)
>
=
static_cast
<
double
>
(
MIN_WRITE_BEFORE_START_USECS
)
/
USECS_PER_S
)
{
mAudioStream
-
>
Start
(
)
;
}
}
void
AudioSink
:
:
WriteSilence
(
uint32_t
aFrames
)
{
uint32_t
numSamples
=
aFrames
*
mInfo
.
mChannels
;
nsAutoTArray
<
AudioDataValue
1000
>
buf
;
buf
.
SetLength
(
numSamples
)
;
memset
(
buf
.
Elements
(
)
0
numSamples
*
sizeof
(
AudioDataValue
)
)
;
mAudioStream
-
>
Write
(
buf
.
Elements
(
)
aFrames
)
;
StartAudioStreamPlaybackIfNeeded
(
)
;
}
int64_t
AudioSink
:
:
GetEndTime
(
)
const
{
CheckedInt64
playedUsecs
=
FramesToUsecs
(
mWritten
mInfo
.
mRate
)
+
mStartTime
;
if
(
!
playedUsecs
.
isValid
(
)
)
{
NS_WARNING
(
"
Int
overflow
calculating
audio
end
time
"
)
;
return
-
1
;
}
return
playedUsecs
.
value
(
)
;
}
void
AudioSink
:
:
AssertOnAudioThread
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mThread
)
;
}
void
AudioSink
:
:
AssertNotOnAudioThread
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
!
=
mThread
)
;
}
}
