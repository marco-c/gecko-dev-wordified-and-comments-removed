#
if
!
defined
(
OggDemuxer_h_
)
#
define
OggDemuxer_h_
#
include
<
memory
>
#
include
"
MediaDataDemuxer
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
OggCodecState
.
h
"
#
include
"
OggCodecStore
.
h
"
#
include
"
OggRLBoxTypes
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
class
OggTrackDemuxer
;
DDLoggedTypeDeclNameAndBase
(
OggDemuxer
MediaDataDemuxer
)
;
DDLoggedTypeNameAndBase
(
OggTrackDemuxer
MediaTrackDemuxer
)
;
class
OggDemuxer
:
public
MediaDataDemuxer
public
DecoderDoctorLifeLogger
<
OggDemuxer
>
{
public
:
explicit
OggDemuxer
(
MediaResource
*
aResource
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
uint32_t
GetNumberTracks
(
TrackInfo
:
:
TrackType
aType
)
const
override
;
already_AddRefed
<
MediaTrackDemuxer
>
GetTrackDemuxer
(
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
override
;
bool
IsSeekable
(
)
const
override
;
UniquePtr
<
EncryptionInfo
>
GetCrypto
(
)
override
;
void
SetChainingEvents
(
TimedMetadataEventProducer
*
aMetadataEvent
MediaEventProducer
<
void
>
*
aOnSeekableEvent
)
;
private
:
UniquePtr
<
TrackInfo
>
GetTrackInfo
(
TrackInfo
:
:
TrackType
aType
size_t
aTrackNumber
)
const
;
struct
nsAutoOggSyncState
{
explicit
nsAutoOggSyncState
(
rlbox_sandbox_ogg
*
aSandbox
)
;
~
nsAutoOggSyncState
(
)
;
rlbox_sandbox_ogg
*
mSandbox
;
tainted_opaque_ogg
<
ogg_sync_state
*
>
mState
;
}
;
media
:
:
TimeIntervals
GetBuffered
(
TrackInfo
:
:
TrackType
aType
)
;
void
FindStartTime
(
media
:
:
TimeUnit
&
aOutStartTime
)
;
void
FindStartTime
(
TrackInfo
:
:
TrackType
media
:
:
TimeUnit
&
aOutStartTime
)
;
nsresult
SeekInternal
(
TrackInfo
:
:
TrackType
aType
const
media
:
:
TimeUnit
&
aTarget
)
;
enum
IndexedSeekResult
{
SEEK_OK
SEEK_INDEX_FAIL
SEEK_FATAL_ERROR
}
;
IndexedSeekResult
SeekToKeyframeUsingIndex
(
TrackInfo
:
:
TrackType
aType
const
media
:
:
TimeUnit
&
aTarget
)
;
IndexedSeekResult
RollbackIndexedSeek
(
TrackInfo
:
:
TrackType
aType
int64_t
aOffset
)
;
class
SeekRange
{
public
:
SeekRange
(
)
:
mOffsetStart
(
0
)
mOffsetEnd
(
0
)
mTimeStart
(
media
:
:
TimeUnit
:
:
Zero
(
)
)
mTimeEnd
(
media
:
:
TimeUnit
:
:
Zero
(
)
)
{
}
SeekRange
(
int64_t
aOffsetStart
int64_t
aOffsetEnd
const
media
:
:
TimeUnit
&
aTimeStart
const
media
:
:
TimeUnit
&
aTimeEnd
)
:
mOffsetStart
(
aOffsetStart
)
mOffsetEnd
(
aOffsetEnd
)
mTimeStart
(
aTimeStart
)
mTimeEnd
(
aTimeEnd
)
{
}
bool
IsNull
(
)
const
{
return
mOffsetStart
=
=
0
&
&
mOffsetEnd
=
=
0
&
&
mTimeStart
.
IsZero
(
)
&
&
mTimeEnd
.
IsZero
(
)
;
}
int64_t
mOffsetStart
mOffsetEnd
;
media
:
:
TimeUnit
mTimeStart
mTimeEnd
;
}
;
nsresult
GetSeekRanges
(
TrackInfo
:
:
TrackType
aType
nsTArray
<
SeekRange
>
&
aRanges
)
;
SeekRange
SelectSeekRange
(
TrackInfo
:
:
TrackType
aType
const
nsTArray
<
SeekRange
>
&
ranges
const
media
:
:
TimeUnit
&
aTarget
const
media
:
:
TimeUnit
&
aStartTime
const
media
:
:
TimeUnit
&
aEndTime
bool
aExact
)
;
nsresult
SeekInBufferedRange
(
TrackInfo
:
:
TrackType
aType
const
media
:
:
TimeUnit
&
aTarget
media
:
:
TimeUnit
&
aAdjustedTarget
const
media
:
:
TimeUnit
&
aStartTime
const
media
:
:
TimeUnit
&
aEndTime
const
nsTArray
<
SeekRange
>
&
aRanges
const
SeekRange
&
aRange
)
;
nsresult
SeekInUnbuffered
(
TrackInfo
:
:
TrackType
aType
const
media
:
:
TimeUnit
&
aTarget
const
media
:
:
TimeUnit
&
aStartTime
const
media
:
:
TimeUnit
&
aEndTime
const
nsTArray
<
SeekRange
>
&
aRanges
)
;
nsresult
SeekBisection
(
TrackInfo
:
:
TrackType
aType
const
media
:
:
TimeUnit
&
aTarget
const
SeekRange
&
aRange
const
media
:
:
TimeUnit
&
aFuzz
)
;
static
const
int
PAGE_STEP
=
8192
;
enum
PageSyncResult
{
PAGE_SYNC_ERROR
=
1
PAGE_SYNC_END_OF_RANGE
=
2
PAGE_SYNC_OK
=
3
}
;
static
PageSyncResult
PageSync
(
rlbox_sandbox_ogg
*
aSandbox
MediaResourceIndex
*
aResource
tainted_opaque_ogg
<
ogg_sync_state
*
>
aState
bool
aCachedDataOnly
int64_t
aOffset
int64_t
aEndOffset
tainted_ogg
<
ogg_page
*
>
aPage
int
&
aSkippedBytes
)
;
ogg_packet
*
GetNextPacket
(
TrackInfo
:
:
TrackType
aType
)
;
nsresult
Reset
(
TrackInfo
:
:
TrackType
aType
)
;
static
nsString
GetKind
(
const
nsCString
&
aRole
)
;
static
void
InitTrack
(
MessageField
*
aMsgInfo
TrackInfo
*
aInfo
bool
aEnable
)
;
~
OggDemuxer
(
)
;
nsresult
ReadMetadata
(
)
;
bool
ReadOggPage
(
TrackInfo
:
:
TrackType
aType
tainted_opaque_ogg
<
ogg_page
*
>
aPage
)
;
nsresult
DemuxOggPage
(
TrackInfo
:
:
TrackType
aType
tainted_opaque_ogg
<
ogg_page
*
>
aPage
)
;
void
DemuxUntilPacketAvailable
(
TrackInfo
:
:
TrackType
aType
OggCodecState
*
aState
)
;
bool
ReadHeaders
(
TrackInfo
:
:
TrackType
aType
OggCodecState
*
aState
)
;
bool
ReadOggChain
(
const
media
:
:
TimeUnit
&
aLastEndTime
)
;
void
SetChained
(
)
;
void
BuildSerialList
(
nsTArray
<
uint32_t
>
&
aTracks
)
;
void
SetupTarget
(
OggCodecState
*
*
aSavedState
OggCodecState
*
aNewState
)
;
void
SetupTargetSkeleton
(
)
;
void
SetupMediaTracksInfo
(
const
nsTArray
<
uint32_t
>
&
aSerials
)
;
void
FillTags
(
TrackInfo
*
aInfo
UniquePtr
<
MetadataTags
>
&
&
aTags
)
;
tainted_opaque_ogg
<
ogg_uint32_t
>
GetPageChecksum
(
tainted_opaque_ogg
<
ogg_page
*
>
aPage
)
;
media
:
:
TimeUnit
RangeEndTime
(
TrackInfo
:
:
TrackType
aType
int64_t
aEndOffset
)
;
media
:
:
TimeUnit
RangeEndTime
(
TrackInfo
:
:
TrackType
aType
int64_t
aStartOffset
int64_t
aEndOffset
bool
aCachedDataOnly
)
;
media
:
:
TimeUnit
RangeStartTime
(
TrackInfo
:
:
TrackType
aType
int64_t
aOffset
)
;
static
rlbox_sandbox_ogg
*
CreateSandbox
(
)
;
struct
SandboxDestroy
{
void
operator
(
)
(
rlbox_sandbox_ogg
*
sandbox
)
;
}
;
std
:
:
unique_ptr
<
rlbox_sandbox_ogg
SandboxDestroy
>
mSandbox
;
MediaInfo
mInfo
;
nsTArray
<
RefPtr
<
OggTrackDemuxer
>
>
mDemuxers
;
OggCodecStore
mCodecStore
;
OggCodecState
*
mVorbisState
;
OggCodecState
*
mOpusState
;
OggCodecState
*
mFlacState
;
OggCodecState
*
GetTrackCodecState
(
TrackInfo
:
:
TrackType
aType
)
const
;
TrackInfo
:
:
TrackType
GetCodecStateType
(
OggCodecState
*
aState
)
const
;
bool
mOpusEnabled
;
SkeletonState
*
mSkeletonState
;
struct
OggStateContext
{
explicit
OggStateContext
(
MediaResource
*
aResource
rlbox_sandbox_ogg
*
aSandbox
)
:
mOggState
(
aSandbox
)
mResource
(
aResource
)
mNeedKeyframe
(
true
)
{
}
nsAutoOggSyncState
mOggState
;
MediaResourceIndex
mResource
;
Maybe
<
media
:
:
TimeUnit
>
mStartTime
;
bool
mNeedKeyframe
;
}
;
OggStateContext
&
OggState
(
TrackInfo
:
:
TrackType
aType
)
;
tainted_opaque_ogg
<
ogg_sync_state
*
>
OggSyncState
(
TrackInfo
:
:
TrackType
aType
)
;
MediaResourceIndex
*
Resource
(
TrackInfo
:
:
TrackType
aType
)
;
MediaResourceIndex
*
CommonResource
(
)
;
OggStateContext
mAudioOggState
;
Maybe
<
media
:
:
TimeUnit
>
mStartTime
;
bool
HasVideo
(
)
const
;
bool
HasAudio
(
)
const
;
bool
HasSkeleton
(
)
const
{
return
mSkeletonState
!
=
nullptr
&
&
mSkeletonState
-
>
mActive
;
}
bool
HaveStartTime
(
)
const
;
bool
HaveStartTime
(
TrackInfo
:
:
TrackType
aType
)
;
media
:
:
TimeUnit
StartTime
(
)
const
;
media
:
:
TimeUnit
StartTime
(
TrackInfo
:
:
TrackType
aType
)
;
bool
mIsChained
;
media
:
:
TimeUnit
mDecodedAudioDuration
;
TimedMetadataEventProducer
*
mTimedMetadataEvent
;
MediaEventProducer
<
void
>
*
mOnSeekableEvent
;
RefPtr
<
TrackInfoSharedPtr
>
mSharedAudioTrackInfo
;
friend
class
OggTrackDemuxer
;
}
;
class
OggTrackDemuxer
:
public
MediaTrackDemuxer
public
DecoderDoctorLifeLogger
<
OggTrackDemuxer
>
{
public
:
OggTrackDemuxer
(
OggDemuxer
*
aParent
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
;
UniquePtr
<
TrackInfo
>
GetInfo
(
)
const
override
;
RefPtr
<
SeekPromise
>
Seek
(
const
media
:
:
TimeUnit
&
aTime
)
override
;
RefPtr
<
SamplesPromise
>
GetSamples
(
int32_t
aNumSamples
=
1
)
override
;
void
Reset
(
)
override
;
RefPtr
<
SkipAccessPointPromise
>
SkipToNextRandomAccessPoint
(
const
media
:
:
TimeUnit
&
aTimeThreshold
)
override
;
media
:
:
TimeIntervals
GetBuffered
(
)
override
;
void
BreakCycles
(
)
override
;
private
:
~
OggTrackDemuxer
(
)
;
void
SetNextKeyFrameTime
(
)
;
RefPtr
<
MediaRawData
>
NextSample
(
)
;
RefPtr
<
OggDemuxer
>
mParent
;
TrackInfo
:
:
TrackType
mType
;
UniquePtr
<
TrackInfo
>
mInfo
;
RefPtr
<
MediaRawData
>
mQueuedSample
;
}
;
}
#
endif
