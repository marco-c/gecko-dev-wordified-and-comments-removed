#
if
!
defined
(
OggDemuxer_h_
)
#
define
OggDemuxer_h_
#
include
"
nsTArray
.
h
"
#
include
"
MediaDataDemuxer
.
h
"
#
include
"
OggCodecState
.
h
"
#
include
"
OggCodecStore
.
h
"
namespace
mozilla
{
class
OggTrackDemuxer
;
class
OggHeaders
;
class
OggDemuxer
:
public
MediaDataDemuxer
{
public
:
explicit
OggDemuxer
(
MediaResource
*
aResource
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
bool
HasTrackType
(
TrackInfo
:
:
TrackType
aType
)
const
override
;
uint32_t
GetNumberTracks
(
TrackInfo
:
:
TrackType
aType
)
const
override
;
already_AddRefed
<
MediaTrackDemuxer
>
GetTrackDemuxer
(
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
override
;
bool
IsSeekable
(
)
const
override
;
UniquePtr
<
EncryptionInfo
>
GetCrypto
(
)
override
;
private
:
UniquePtr
<
TrackInfo
>
GetTrackInfo
(
TrackInfo
:
:
TrackType
aType
size_t
aTrackNumber
)
const
;
struct
nsAutoOggSyncState
{
nsAutoOggSyncState
(
)
{
ogg_sync_init
(
&
mState
)
;
}
~
nsAutoOggSyncState
(
)
{
ogg_sync_clear
(
&
mState
)
;
}
ogg_sync_state
mState
;
}
;
media
:
:
TimeIntervals
GetBuffered
(
)
;
void
FindStartTime
(
int64_t
&
aOutStartTime
)
;
nsresult
SeekInternal
(
const
media
:
:
TimeUnit
&
aTarget
)
;
enum
IndexedSeekResult
{
SEEK_OK
SEEK_INDEX_FAIL
SEEK_FATAL_ERROR
}
;
IndexedSeekResult
SeekToKeyframeUsingIndex
(
int64_t
aTarget
)
;
IndexedSeekResult
RollbackIndexedSeek
(
int64_t
aOffset
)
;
class
SeekRange
{
public
:
SeekRange
(
)
:
mOffsetStart
(
0
)
mOffsetEnd
(
0
)
mTimeStart
(
0
)
mTimeEnd
(
0
)
{
}
SeekRange
(
int64_t
aOffsetStart
int64_t
aOffsetEnd
int64_t
aTimeStart
int64_t
aTimeEnd
)
:
mOffsetStart
(
aOffsetStart
)
mOffsetEnd
(
aOffsetEnd
)
mTimeStart
(
aTimeStart
)
mTimeEnd
(
aTimeEnd
)
{
}
bool
IsNull
(
)
const
{
return
mOffsetStart
=
=
0
&
&
mOffsetEnd
=
=
0
&
&
mTimeStart
=
=
0
&
&
mTimeEnd
=
=
0
;
}
int64_t
mOffsetStart
mOffsetEnd
;
int64_t
mTimeStart
mTimeEnd
;
}
;
nsresult
GetSeekRanges
(
nsTArray
<
SeekRange
>
&
aRanges
)
;
SeekRange
SelectSeekRange
(
const
nsTArray
<
SeekRange
>
&
ranges
int64_t
aTarget
int64_t
aStartTime
int64_t
aEndTime
bool
aExact
)
;
nsresult
SeekInBufferedRange
(
int64_t
aTarget
int64_t
aAdjustedTarget
int64_t
aStartTime
int64_t
aEndTime
const
nsTArray
<
SeekRange
>
&
aRanges
const
SeekRange
&
aRange
)
;
nsresult
SeekInUnbuffered
(
int64_t
aTarget
int64_t
aStartTime
int64_t
aEndTime
const
nsTArray
<
SeekRange
>
&
aRanges
)
;
nsresult
SeekBisection
(
int64_t
aTarget
const
SeekRange
&
aRange
uint32_t
aFuzz
)
;
static
const
int
PAGE_STEP
=
8192
;
enum
PageSyncResult
{
PAGE_SYNC_ERROR
=
1
PAGE_SYNC_END_OF_RANGE
=
2
PAGE_SYNC_OK
=
3
}
;
static
PageSyncResult
PageSync
(
MediaResourceIndex
*
aResource
ogg_sync_state
*
aState
bool
aCachedDataOnly
int64_t
aOffset
int64_t
aEndOffset
ogg_page
*
aPage
int
&
aSkippedBytes
)
;
ogg_packet
*
GetNextPacket
(
TrackInfo
:
:
TrackType
aType
)
;
nsresult
ResetTrackState
(
TrackInfo
:
:
TrackType
aType
)
;
nsresult
Reset
(
)
;
static
const
nsString
GetKind
(
const
nsCString
&
aRole
)
;
static
void
InitTrack
(
MessageField
*
aMsgInfo
TrackInfo
*
aInfo
bool
aEnable
)
;
~
OggDemuxer
(
)
;
void
Cleanup
(
)
;
nsresult
ReadMetadata
(
)
;
bool
ReadOggPage
(
ogg_page
*
aPage
)
;
nsresult
DemuxOggPage
(
ogg_page
*
aPage
)
;
void
DemuxUntilPacketAvailable
(
OggCodecState
*
aState
)
;
bool
ReadHeaders
(
OggCodecState
*
aState
OggHeaders
&
aHeaders
)
;
bool
ReadOggChain
(
)
;
void
SetChained
(
)
;
void
BuildSerialList
(
nsTArray
<
uint32_t
>
&
aTracks
)
;
void
SetupTargetTheora
(
TheoraState
*
aTheoraState
OggHeaders
&
aHeaders
)
;
void
SetupTargetVorbis
(
VorbisState
*
aVorbisState
OggHeaders
&
aHeaders
)
;
void
SetupTargetOpus
(
OpusState
*
aOpusState
OggHeaders
&
aHeaders
)
;
void
SetupTargetSkeleton
(
)
;
void
SetupMediaTracksInfo
(
const
nsTArray
<
uint32_t
>
&
aSerials
)
;
ogg_uint32_t
GetPageChecksum
(
ogg_page
*
aPage
)
;
int64_t
RangeEndTime
(
int64_t
aEndOffset
)
;
int64_t
RangeEndTime
(
int64_t
aStartOffset
int64_t
aEndOffset
bool
aCachedDataOnly
)
;
int64_t
RangeStartTime
(
int64_t
aOffset
)
;
MediaInfo
mInfo
;
nsTArray
<
RefPtr
<
OggTrackDemuxer
>
>
mDemuxers
;
OggCodecStore
mCodecStore
;
TheoraState
*
mTheoraState
;
VorbisState
*
mVorbisState
;
OpusState
*
mOpusState
;
OggCodecState
*
GetTrackCodecState
(
TrackInfo
:
:
TrackType
aType
)
const
;
bool
mOpusEnabled
;
SkeletonState
*
mSkeletonState
;
ogg_sync_state
mOggState
;
uint32_t
mVorbisSerial
;
uint32_t
mOpusSerial
;
uint32_t
mTheoraSerial
;
vorbis_info
mVorbisInfo
;
int
mOpusPreSkip
;
th_info
mTheoraInfo
;
Maybe
<
int64_t
>
mStartTime
;
bool
HasVideo
(
)
const
;
bool
HasAudio
(
)
const
;
bool
HasSkeleton
(
)
const
{
return
mSkeletonState
!
=
0
&
&
mSkeletonState
-
>
mActive
;
}
bool
HaveStartTime
(
)
const
;
int64_t
StartTime
(
)
const
;
nsIntRect
mPicture
;
bool
mIsChained
;
int64_t
mDecodedAudioFrames
;
MediaResourceIndex
mResource
;
friend
class
OggTrackDemuxer
;
}
;
class
OggTrackDemuxer
:
public
MediaTrackDemuxer
{
public
:
OggTrackDemuxer
(
OggDemuxer
*
aParent
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
;
UniquePtr
<
TrackInfo
>
GetInfo
(
)
const
override
;
RefPtr
<
SeekPromise
>
Seek
(
media
:
:
TimeUnit
aTime
)
override
;
RefPtr
<
SamplesPromise
>
GetSamples
(
int32_t
aNumSamples
=
1
)
override
;
void
Reset
(
)
override
;
RefPtr
<
SkipAccessPointPromise
>
SkipToNextRandomAccessPoint
(
media
:
:
TimeUnit
aTimeThreshold
)
override
;
media
:
:
TimeIntervals
GetBuffered
(
)
override
;
void
BreakCycles
(
)
override
;
private
:
~
OggTrackDemuxer
(
)
;
void
SetNextKeyFrameTime
(
)
;
RefPtr
<
MediaRawData
>
NextSample
(
)
;
RefPtr
<
OggDemuxer
>
mParent
;
TrackInfo
:
:
TrackType
mType
;
UniquePtr
<
TrackInfo
>
mInfo
;
RefPtr
<
MediaRawData
>
mQueuedSample
;
}
;
}
#
endif
