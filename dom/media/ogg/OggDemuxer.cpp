#
include
"
OggDemuxer
.
h
"
#
include
"
OggRLBox
.
h
"
#
include
"
MediaDataDemuxer
.
h
"
#
include
"
OggCodecState
.
h
"
#
include
"
XiphExtradata
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
ifdef
MOZ_WASM_SANDBOXING_OGG
#
include
"
mozilla
/
ipc
/
LibrarySandboxPreload
.
h
"
#
endif
#
include
"
nsAutoRef
.
h
"
#
include
"
nsError
.
h
"
#
include
<
algorithm
>
extern
mozilla
:
:
LazyLogModule
gMediaDemuxerLog
;
#
define
OGG_DEBUG
(
arg
.
.
.
)
\
DDMOZ_LOG
(
gMediaDemuxerLog
mozilla
:
:
LogLevel
:
:
Debug
"
:
:
%
s
:
"
arg
\
__func__
#
#
__VA_ARGS__
)
#
ifdef
SEEK_LOGGING
#
define
SEEK_LOG
(
type
msg
)
MOZ_LOG
(
gMediaDemuxerLog
type
msg
)
#
else
#
define
SEEK_LOG
(
type
msg
)
#
endif
#
define
CopyAndVerifyOrFail
(
t
cond
failed
)
\
(
t
)
.
copy_and_verify
(
[
&
]
(
auto
val
)
{
\
if
(
!
(
cond
)
)
{
\
*
(
failed
)
=
true
;
\
}
\
return
val
;
\
}
)
namespace
mozilla
{
using
media
:
:
TimeInterval
;
using
media
:
:
TimeIntervals
;
using
media
:
:
TimeUnit
;
static
const
uint32_t
OGG_SEEK_FUZZ_USECS
=
500000
;
static
const
TimeUnit
OGG_SEEK_OPUS_PREROLL
=
TimeUnit
:
:
FromMicroseconds
(
80000
)
;
static
Atomic
<
uint32_t
>
sStreamSourceID
(
0u
)
;
OggDemuxer
:
:
nsAutoOggSyncState
:
:
nsAutoOggSyncState
(
rlbox_sandbox_ogg
*
aSandbox
)
:
mSandbox
(
aSandbox
)
{
if
(
mSandbox
)
{
tainted_ogg
<
ogg_sync_state
*
>
state
=
mSandbox
-
>
malloc_in_sandbox
<
ogg_sync_state
>
(
)
;
MOZ_RELEASE_ASSERT
(
state
!
=
nullptr
)
;
mState
=
state
.
to_opaque
(
)
;
sandbox_invoke
(
*
mSandbox
ogg_sync_init
mState
)
;
}
}
OggDemuxer
:
:
nsAutoOggSyncState
:
:
~
nsAutoOggSyncState
(
)
{
if
(
mSandbox
)
{
sandbox_invoke
(
*
mSandbox
ogg_sync_clear
mState
)
;
mSandbox
-
>
free_in_sandbox
(
rlbox
:
:
from_opaque
(
mState
)
)
;
tainted_ogg
<
ogg_sync_state
*
>
null
=
nullptr
;
mState
=
null
.
to_opaque
(
)
;
}
}
rlbox_sandbox_ogg
*
OggDemuxer
:
:
CreateSandbox
(
)
{
rlbox_sandbox_ogg
*
sandbox
=
new
rlbox_sandbox_ogg
(
)
;
#
ifdef
MOZ_WASM_SANDBOXING_OGG
bool
success
=
sandbox
-
>
create_sandbox
(
false
)
;
#
else
bool
success
=
sandbox
-
>
create_sandbox
(
)
;
#
endif
if
(
!
success
)
{
delete
sandbox
;
sandbox
=
nullptr
;
}
return
sandbox
;
}
void
OggDemuxer
:
:
SandboxDestroy
:
:
operator
(
)
(
rlbox_sandbox_ogg
*
sandbox
)
{
if
(
sandbox
)
{
sandbox
-
>
destroy_sandbox
(
)
;
delete
sandbox
;
}
}
const
nsString
OggDemuxer
:
:
GetKind
(
const
nsCString
&
aRole
)
{
if
(
aRole
.
Find
(
"
audio
/
main
"
)
!
=
-
1
|
|
aRole
.
Find
(
"
video
/
main
"
)
!
=
-
1
)
{
return
u
"
main
"
_ns
;
}
else
if
(
aRole
.
Find
(
"
audio
/
alternate
"
)
!
=
-
1
|
|
aRole
.
Find
(
"
video
/
alternate
"
)
!
=
-
1
)
{
return
u
"
alternative
"
_ns
;
}
else
if
(
aRole
.
Find
(
"
audio
/
audiodesc
"
)
!
=
-
1
)
{
return
u
"
descriptions
"
_ns
;
}
else
if
(
aRole
.
Find
(
"
audio
/
described
"
)
!
=
-
1
)
{
return
u
"
main
-
desc
"
_ns
;
}
else
if
(
aRole
.
Find
(
"
audio
/
dub
"
)
!
=
-
1
)
{
return
u
"
translation
"
_ns
;
}
else
if
(
aRole
.
Find
(
"
audio
/
commentary
"
)
!
=
-
1
)
{
return
u
"
commentary
"
_ns
;
}
else
if
(
aRole
.
Find
(
"
video
/
sign
"
)
!
=
-
1
)
{
return
u
"
sign
"
_ns
;
}
else
if
(
aRole
.
Find
(
"
video
/
captioned
"
)
!
=
-
1
)
{
return
u
"
captions
"
_ns
;
}
else
if
(
aRole
.
Find
(
"
video
/
subtitled
"
)
!
=
-
1
)
{
return
u
"
subtitles
"
_ns
;
}
return
u
"
"
_ns
;
}
void
OggDemuxer
:
:
InitTrack
(
MessageField
*
aMsgInfo
TrackInfo
*
aInfo
bool
aEnable
)
{
MOZ_ASSERT
(
aMsgInfo
)
;
MOZ_ASSERT
(
aInfo
)
;
nsCString
*
sName
=
aMsgInfo
-
>
mValuesStore
.
Get
(
eName
)
;
nsCString
*
sRole
=
aMsgInfo
-
>
mValuesStore
.
Get
(
eRole
)
;
nsCString
*
sTitle
=
aMsgInfo
-
>
mValuesStore
.
Get
(
eTitle
)
;
nsCString
*
sLanguage
=
aMsgInfo
-
>
mValuesStore
.
Get
(
eLanguage
)
;
aInfo
-
>
Init
(
sName
?
NS_ConvertUTF8toUTF16
(
*
sName
)
:
EmptyString
(
)
sRole
?
GetKind
(
*
sRole
)
:
u
"
"
_ns
sTitle
?
NS_ConvertUTF8toUTF16
(
*
sTitle
)
:
EmptyString
(
)
sLanguage
?
NS_ConvertUTF8toUTF16
(
*
sLanguage
)
:
EmptyString
(
)
aEnable
)
;
}
OggDemuxer
:
:
OggDemuxer
(
MediaResource
*
aResource
)
:
mSandbox
(
CreateSandbox
(
)
)
mTheoraState
(
nullptr
)
mVorbisState
(
nullptr
)
mOpusState
(
nullptr
)
mFlacState
(
nullptr
)
mOpusEnabled
(
MediaDecoder
:
:
IsOpusEnabled
(
)
)
mSkeletonState
(
nullptr
)
mAudioOggState
(
aResource
mSandbox
.
get
(
)
)
mVideoOggState
(
aResource
mSandbox
.
get
(
)
)
mIsChained
(
false
)
mTimedMetadataEvent
(
nullptr
)
mOnSeekableEvent
(
nullptr
)
{
MOZ_COUNT_CTOR
(
OggDemuxer
)
;
DDLINKCHILD
(
"
resource
"
aResource
)
;
}
OggDemuxer
:
:
~
OggDemuxer
(
)
{
MOZ_COUNT_DTOR
(
OggDemuxer
)
;
Reset
(
TrackInfo
:
:
kAudioTrack
)
;
Reset
(
TrackInfo
:
:
kVideoTrack
)
;
}
void
OggDemuxer
:
:
SetChainingEvents
(
TimedMetadataEventProducer
*
aMetadataEvent
MediaEventProducer
<
void
>
*
aOnSeekableEvent
)
{
mTimedMetadataEvent
=
aMetadataEvent
;
mOnSeekableEvent
=
aOnSeekableEvent
;
}
bool
OggDemuxer
:
:
HasAudio
(
)
const
{
return
mVorbisState
|
|
mOpusState
|
|
mFlacState
;
}
bool
OggDemuxer
:
:
HasVideo
(
)
const
{
return
mTheoraState
;
}
bool
OggDemuxer
:
:
HaveStartTime
(
)
const
{
return
mStartTime
.
isSome
(
)
;
}
int64_t
OggDemuxer
:
:
StartTime
(
)
const
{
return
mStartTime
.
refOr
(
0
)
;
}
bool
OggDemuxer
:
:
HaveStartTime
(
TrackInfo
:
:
TrackType
aType
)
{
return
OggState
(
aType
)
.
mStartTime
.
isSome
(
)
;
}
int64_t
OggDemuxer
:
:
StartTime
(
TrackInfo
:
:
TrackType
aType
)
{
return
OggState
(
aType
)
.
mStartTime
.
refOr
(
TimeUnit
:
:
Zero
(
)
)
.
ToMicroseconds
(
)
;
}
RefPtr
<
OggDemuxer
:
:
InitPromise
>
OggDemuxer
:
:
Init
(
)
{
if
(
!
mSandbox
)
{
return
InitPromise
:
:
CreateAndReject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
}
const
char
RLBOX_OGG_RETURN_CODE_SAFE
[
]
=
"
Return
codes
only
control
whether
to
early
exit
.
Incorrect
return
codes
"
"
will
not
lead
to
memory
safety
issues
in
the
renderer
.
"
;
int
ret
=
sandbox_invoke
(
*
mSandbox
ogg_sync_init
OggSyncState
(
TrackInfo
:
:
kAudioTrack
)
)
.
unverified_safe_because
(
RLBOX_OGG_RETURN_CODE_SAFE
)
;
if
(
ret
!
=
0
)
{
return
InitPromise
:
:
CreateAndReject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
}
ret
=
sandbox_invoke
(
*
mSandbox
ogg_sync_init
OggSyncState
(
TrackInfo
:
:
kVideoTrack
)
)
.
unverified_safe_because
(
RLBOX_OGG_RETURN_CODE_SAFE
)
;
if
(
ret
!
=
0
)
{
return
InitPromise
:
:
CreateAndReject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
}
if
(
ReadMetadata
(
)
!
=
NS_OK
)
{
return
InitPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_METADATA_ERR
__func__
)
;
}
if
(
!
GetNumberTracks
(
TrackInfo
:
:
kAudioTrack
)
&
&
!
GetNumberTracks
(
TrackInfo
:
:
kVideoTrack
)
)
{
return
InitPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_METADATA_ERR
__func__
)
;
}
return
InitPromise
:
:
CreateAndResolve
(
NS_OK
__func__
)
;
}
OggCodecState
*
OggDemuxer
:
:
GetTrackCodecState
(
TrackInfo
:
:
TrackType
aType
)
const
{
switch
(
aType
)
{
case
TrackInfo
:
:
kAudioTrack
:
if
(
mVorbisState
)
{
return
mVorbisState
;
}
else
if
(
mOpusState
)
{
return
mOpusState
;
}
else
{
return
mFlacState
;
}
case
TrackInfo
:
:
kVideoTrack
:
return
mTheoraState
;
default
:
return
0
;
}
}
TrackInfo
:
:
TrackType
OggDemuxer
:
:
GetCodecStateType
(
OggCodecState
*
aState
)
const
{
switch
(
aState
-
>
GetType
(
)
)
{
case
OggCodecState
:
:
TYPE_THEORA
:
return
TrackInfo
:
:
kVideoTrack
;
case
OggCodecState
:
:
TYPE_OPUS
:
case
OggCodecState
:
:
TYPE_VORBIS
:
case
OggCodecState
:
:
TYPE_FLAC
:
return
TrackInfo
:
:
kAudioTrack
;
default
:
return
TrackInfo
:
:
kUndefinedTrack
;
}
}
uint32_t
OggDemuxer
:
:
GetNumberTracks
(
TrackInfo
:
:
TrackType
aType
)
const
{
switch
(
aType
)
{
case
TrackInfo
:
:
kAudioTrack
:
return
HasAudio
(
)
?
1
:
0
;
case
TrackInfo
:
:
kVideoTrack
:
return
HasVideo
(
)
?
1
:
0
;
default
:
return
0
;
}
}
UniquePtr
<
TrackInfo
>
OggDemuxer
:
:
GetTrackInfo
(
TrackInfo
:
:
TrackType
aType
size_t
aTrackNumber
)
const
{
switch
(
aType
)
{
case
TrackInfo
:
:
kAudioTrack
:
return
mInfo
.
mAudio
.
Clone
(
)
;
case
TrackInfo
:
:
kVideoTrack
:
return
mInfo
.
mVideo
.
Clone
(
)
;
default
:
return
nullptr
;
}
}
already_AddRefed
<
MediaTrackDemuxer
>
OggDemuxer
:
:
GetTrackDemuxer
(
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
{
if
(
GetNumberTracks
(
aType
)
<
=
aTrackNumber
)
{
return
nullptr
;
}
RefPtr
<
OggTrackDemuxer
>
e
=
new
OggTrackDemuxer
(
this
aType
aTrackNumber
)
;
DDLINKCHILD
(
"
track
demuxer
"
e
.
get
(
)
)
;
mDemuxers
.
AppendElement
(
e
)
;
return
e
.
forget
(
)
;
}
nsresult
OggDemuxer
:
:
Reset
(
TrackInfo
:
:
TrackType
aType
)
{
if
(
mSandbox
)
{
sandbox_invoke
(
*
mSandbox
ogg_sync_reset
OggSyncState
(
aType
)
)
;
}
OggCodecState
*
trackState
=
GetTrackCodecState
(
aType
)
;
if
(
trackState
)
{
return
trackState
-
>
Reset
(
)
;
}
OggState
(
aType
)
.
mNeedKeyframe
=
true
;
return
NS_OK
;
}
bool
OggDemuxer
:
:
ReadHeaders
(
TrackInfo
:
:
TrackType
aType
OggCodecState
*
aState
)
{
while
(
!
aState
-
>
DoneReadingHeaders
(
)
)
{
DemuxUntilPacketAvailable
(
aType
aState
)
;
OggPacketPtr
packet
=
aState
-
>
PacketOut
(
)
;
if
(
!
packet
)
{
OGG_DEBUG
(
"
Ran
out
of
header
packets
early
;
deactivating
stream
%
"
PRIu32
aState
-
>
mSerial
)
;
aState
-
>
Deactivate
(
)
;
return
false
;
}
if
(
!
aState
-
>
DecodeHeader
(
std
:
:
move
(
packet
)
)
)
{
OGG_DEBUG
(
"
Failed
to
decode
ogg
header
packet
;
deactivating
stream
%
"
PRIu32
aState
-
>
mSerial
)
;
aState
-
>
Deactivate
(
)
;
return
false
;
}
}
return
aState
-
>
Init
(
)
;
}
void
OggDemuxer
:
:
BuildSerialList
(
nsTArray
<
uint32_t
>
&
aTracks
)
{
if
(
HasVideo
(
)
)
{
aTracks
.
AppendElement
(
mTheoraState
-
>
mSerial
)
;
}
if
(
HasAudio
(
)
)
{
if
(
mVorbisState
)
{
aTracks
.
AppendElement
(
mVorbisState
-
>
mSerial
)
;
}
else
if
(
mOpusState
)
{
aTracks
.
AppendElement
(
mOpusState
-
>
mSerial
)
;
}
}
}
void
OggDemuxer
:
:
SetupTarget
(
OggCodecState
*
*
aSavedState
OggCodecState
*
aNewState
)
{
if
(
*
aSavedState
)
{
(
*
aSavedState
)
-
>
Reset
(
)
;
}
if
(
aNewState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
)
{
mInfo
.
mAudio
=
*
aNewState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
;
}
else
{
mInfo
.
mVideo
=
*
aNewState
-
>
GetInfo
(
)
-
>
GetAsVideoInfo
(
)
;
}
*
aSavedState
=
aNewState
;
}
void
OggDemuxer
:
:
SetupTargetSkeleton
(
)
{
if
(
mSkeletonState
)
{
if
(
!
HasAudio
(
)
&
&
!
HasVideo
(
)
)
{
OGG_DEBUG
(
"
Deactivating
skeleton
stream
%
"
PRIu32
mSkeletonState
-
>
mSerial
)
;
mSkeletonState
-
>
Deactivate
(
)
;
}
else
if
(
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
mSkeletonState
)
&
&
mSkeletonState
-
>
HasIndex
(
)
)
{
nsTArray
<
uint32_t
>
tracks
;
BuildSerialList
(
tracks
)
;
int64_t
duration
=
0
;
if
(
NS_SUCCEEDED
(
mSkeletonState
-
>
GetDuration
(
tracks
duration
)
)
)
{
OGG_DEBUG
(
"
Got
duration
from
Skeleton
index
%
"
PRId64
duration
)
;
mInfo
.
mMetadataDuration
.
emplace
(
TimeUnit
:
:
FromMicroseconds
(
duration
)
)
;
}
}
}
}
void
OggDemuxer
:
:
SetupMediaTracksInfo
(
const
nsTArray
<
uint32_t
>
&
aSerials
)
{
for
(
size_t
i
=
0
;
i
<
aSerials
.
Length
(
)
;
i
+
+
)
{
uint32_t
serial
=
aSerials
[
i
]
;
OggCodecState
*
codecState
=
mCodecStore
.
Get
(
serial
)
;
MessageField
*
msgInfo
=
nullptr
;
if
(
mSkeletonState
)
{
mSkeletonState
-
>
mMsgFieldStore
.
Get
(
serial
&
msgInfo
)
;
}
OggCodecState
*
primeState
=
nullptr
;
switch
(
codecState
-
>
GetType
(
)
)
{
case
OggCodecState
:
:
TYPE_THEORA
:
primeState
=
mTheoraState
;
break
;
case
OggCodecState
:
:
TYPE_VORBIS
:
primeState
=
mVorbisState
;
break
;
case
OggCodecState
:
:
TYPE_OPUS
:
primeState
=
mOpusState
;
break
;
case
OggCodecState
:
:
TYPE_FLAC
:
primeState
=
mFlacState
;
break
;
default
:
break
;
}
if
(
primeState
&
&
primeState
=
=
codecState
)
{
bool
isAudio
=
primeState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
;
if
(
msgInfo
)
{
InitTrack
(
msgInfo
isAudio
?
static_cast
<
TrackInfo
*
>
(
&
mInfo
.
mAudio
)
:
&
mInfo
.
mVideo
true
)
;
}
FillTags
(
isAudio
?
static_cast
<
TrackInfo
*
>
(
&
mInfo
.
mAudio
)
:
&
mInfo
.
mVideo
primeState
-
>
GetTags
(
)
)
;
}
}
}
void
OggDemuxer
:
:
FillTags
(
TrackInfo
*
aInfo
UniquePtr
<
MetadataTags
>
&
&
aTags
)
{
if
(
!
aTags
)
{
return
;
}
UniquePtr
<
MetadataTags
>
tags
(
std
:
:
move
(
aTags
)
)
;
for
(
const
auto
&
entry
:
*
tags
)
{
aInfo
-
>
mTags
.
AppendElement
(
MetadataTag
(
entry
.
GetKey
(
)
entry
.
GetData
(
)
)
)
;
}
}
nsresult
OggDemuxer
:
:
ReadMetadata
(
)
{
OGG_DEBUG
(
"
OggDemuxer
:
:
ReadMetadata
called
!
"
)
;
TrackInfo
:
:
TrackType
tracks
[
2
]
=
{
TrackInfo
:
:
kAudioTrack
TrackInfo
:
:
kVideoTrack
}
;
nsTArray
<
OggCodecState
*
>
bitstreams
;
nsTArray
<
uint32_t
>
serials
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
tracks
)
;
i
+
+
)
{
tainted_ogg
<
ogg_page
*
>
page
=
mSandbox
-
>
malloc_in_sandbox
<
ogg_page
>
(
)
;
if
(
!
page
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
auto
clean_page
=
MakeScopeExit
(
[
&
]
{
mSandbox
-
>
free_in_sandbox
(
page
)
;
}
)
;
bool
readAllBOS
=
false
;
while
(
!
readAllBOS
)
{
if
(
!
ReadOggPage
(
tracks
[
i
]
page
.
to_opaque
(
)
)
)
{
OGG_DEBUG
(
"
OggDemuxer
:
:
ReadOggPage
failed
?
leaving
ReadMetadata
.
.
.
"
)
;
return
NS_ERROR_FAILURE
;
}
uint32_t
serial
=
static_cast
<
uint32_t
>
(
sandbox_invoke
(
*
mSandbox
ogg_page_serialno
page
)
.
unverified_safe_because
(
RLBOX_OGG_PAGE_SERIAL_REASON
)
)
;
if
(
!
sandbox_invoke
(
*
mSandbox
ogg_page_bos
page
)
.
unverified_safe_because
(
"
If
this
value
is
incorrect
it
would
mean
not
all
"
"
bitstreams
are
read
.
This
does
not
affect
the
memory
"
"
safety
of
the
renderer
.
"
)
)
{
readAllBOS
=
true
;
}
else
if
(
!
mCodecStore
.
Contains
(
serial
)
)
{
OggCodecState
*
const
codecState
=
mCodecStore
.
Add
(
serial
OggCodecState
:
:
Create
(
mSandbox
.
get
(
)
page
.
to_opaque
(
)
serial
)
)
;
bitstreams
.
AppendElement
(
codecState
)
;
serials
.
AppendElement
(
serial
)
;
}
if
(
NS_FAILED
(
DemuxOggPage
(
tracks
[
i
]
page
.
to_opaque
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
for
(
uint32_t
i
=
0
;
i
<
bitstreams
.
Length
(
)
;
+
+
i
)
{
OggCodecState
*
s
=
bitstreams
[
i
]
;
if
(
s
)
{
if
(
s
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_THEORA
&
&
ReadHeaders
(
TrackInfo
:
:
kVideoTrack
s
)
)
{
if
(
!
mTheoraState
)
{
SetupTarget
(
&
mTheoraState
s
)
;
}
else
{
s
-
>
Deactivate
(
)
;
}
}
else
if
(
s
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_VORBIS
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
s
)
)
{
if
(
!
mVorbisState
)
{
SetupTarget
(
&
mVorbisState
s
)
;
}
else
{
s
-
>
Deactivate
(
)
;
}
}
else
if
(
s
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_OPUS
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
s
)
)
{
if
(
mOpusEnabled
)
{
if
(
!
mOpusState
)
{
SetupTarget
(
&
mOpusState
s
)
;
}
else
{
s
-
>
Deactivate
(
)
;
}
}
else
{
NS_WARNING
(
"
Opus
decoding
disabled
.
"
"
See
media
.
opus
.
enabled
in
about
:
config
"
)
;
}
}
else
if
(
s
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_FLAC
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
s
)
)
{
if
(
!
mFlacState
)
{
SetupTarget
(
&
mFlacState
s
)
;
}
else
{
s
-
>
Deactivate
(
)
;
}
}
else
if
(
s
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_SKELETON
&
&
!
mSkeletonState
)
{
mSkeletonState
=
static_cast
<
SkeletonState
*
>
(
s
)
;
}
else
{
s
-
>
Deactivate
(
)
;
}
}
}
SetupTargetSkeleton
(
)
;
SetupMediaTracksInfo
(
serials
)
;
if
(
HasAudio
(
)
|
|
HasVideo
(
)
)
{
int64_t
startTime
=
-
1
;
FindStartTime
(
startTime
)
;
if
(
startTime
>
=
0
)
{
OGG_DEBUG
(
"
Detected
stream
start
time
%
"
PRId64
startTime
)
;
mStartTime
.
emplace
(
startTime
)
;
}
if
(
mInfo
.
mMetadataDuration
.
isNothing
(
)
&
&
Resource
(
TrackInfo
:
:
kAudioTrack
)
-
>
GetLength
(
)
>
=
0
)
{
int64_t
length
=
Resource
(
TrackInfo
:
:
kAudioTrack
)
-
>
GetLength
(
)
;
MOZ_ASSERT
(
length
>
0
"
Must
have
a
content
length
to
get
end
time
"
)
;
int64_t
endTime
=
RangeEndTime
(
TrackInfo
:
:
kAudioTrack
length
)
;
if
(
endTime
!
=
-
1
)
{
mInfo
.
mUnadjustedMetadataEndTime
.
emplace
(
TimeUnit
:
:
FromMicroseconds
(
endTime
)
)
;
mInfo
.
mMetadataDuration
.
emplace
(
TimeUnit
:
:
FromMicroseconds
(
endTime
-
mStartTime
.
refOr
(
0
)
)
)
;
OGG_DEBUG
(
"
Got
Ogg
duration
from
seeking
to
end
%
"
PRId64
endTime
)
;
}
}
if
(
mInfo
.
mMetadataDuration
.
isNothing
(
)
)
{
mInfo
.
mMetadataDuration
.
emplace
(
TimeUnit
:
:
FromInfinity
(
)
)
;
}
if
(
HasAudio
(
)
)
{
mInfo
.
mAudio
.
mDuration
=
mInfo
.
mMetadataDuration
.
ref
(
)
;
}
if
(
HasVideo
(
)
)
{
mInfo
.
mVideo
.
mDuration
=
mInfo
.
mMetadataDuration
.
ref
(
)
;
}
}
else
{
OGG_DEBUG
(
"
no
audio
or
video
tracks
"
)
;
return
NS_ERROR_FAILURE
;
}
OGG_DEBUG
(
"
success
?
!
"
)
;
return
NS_OK
;
}
void
OggDemuxer
:
:
SetChained
(
)
{
{
if
(
mIsChained
)
{
return
;
}
mIsChained
=
true
;
}
if
(
mOnSeekableEvent
)
{
mOnSeekableEvent
-
>
Notify
(
)
;
}
}
bool
OggDemuxer
:
:
ReadOggChain
(
const
media
:
:
TimeUnit
&
aLastEndTime
)
{
bool
chained
=
false
;
OpusState
*
newOpusState
=
nullptr
;
VorbisState
*
newVorbisState
=
nullptr
;
FlacState
*
newFlacState
=
nullptr
;
UniquePtr
<
MetadataTags
>
tags
;
if
(
HasVideo
(
)
|
|
HasSkeleton
(
)
|
|
!
HasAudio
(
)
)
{
return
false
;
}
tainted_ogg
<
ogg_page
*
>
page
=
mSandbox
-
>
malloc_in_sandbox
<
ogg_page
>
(
)
;
if
(
!
page
)
{
return
false
;
}
auto
clean_page
=
MakeScopeExit
(
[
&
]
{
mSandbox
-
>
free_in_sandbox
(
page
)
;
}
)
;
if
(
!
ReadOggPage
(
TrackInfo
:
:
kAudioTrack
page
.
to_opaque
(
)
)
|
|
!
sandbox_invoke
(
*
mSandbox
ogg_page_bos
page
)
.
unverified_safe_because
(
RLBOX_OGG_STATE_ASSERT_REASON
)
)
{
return
false
;
}
uint32_t
serial
=
static_cast
<
uint32_t
>
(
sandbox_invoke
(
*
mSandbox
ogg_page_serialno
page
)
.
unverified_safe_because
(
"
We
are
reading
a
new
page
with
a
serial
number
for
the
first
"
"
time
and
will
check
if
we
have
seen
it
before
prior
to
use
.
"
)
)
;
if
(
mCodecStore
.
Contains
(
serial
)
)
{
return
false
;
}
UniquePtr
<
OggCodecState
>
codecState
(
OggCodecState
:
:
Create
(
mSandbox
.
get
(
)
page
.
to_opaque
(
)
serial
)
)
;
if
(
!
codecState
)
{
return
false
;
}
if
(
mVorbisState
&
&
(
codecState
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_VORBIS
)
)
{
newVorbisState
=
static_cast
<
VorbisState
*
>
(
codecState
.
get
(
)
)
;
}
else
if
(
mOpusState
&
&
(
codecState
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_OPUS
)
)
{
newOpusState
=
static_cast
<
OpusState
*
>
(
codecState
.
get
(
)
)
;
}
else
if
(
mFlacState
&
&
(
codecState
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_FLAC
)
)
{
newFlacState
=
static_cast
<
FlacState
*
>
(
codecState
.
get
(
)
)
;
}
else
{
return
false
;
}
OggCodecState
*
state
;
mCodecStore
.
Add
(
serial
std
:
:
move
(
codecState
)
)
;
state
=
mCodecStore
.
Get
(
serial
)
;
NS_ENSURE_TRUE
(
state
!
=
nullptr
false
)
;
if
(
NS_FAILED
(
state
-
>
PageIn
(
page
.
to_opaque
(
)
)
)
)
{
return
false
;
}
MessageField
*
msgInfo
=
nullptr
;
if
(
mSkeletonState
)
{
mSkeletonState
-
>
mMsgFieldStore
.
Get
(
serial
&
msgInfo
)
;
}
if
(
(
newVorbisState
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
newVorbisState
)
)
&
&
(
mVorbisState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mRate
=
=
newVorbisState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mRate
)
&
&
(
mVorbisState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mChannels
=
=
newVorbisState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mChannels
)
)
{
SetupTarget
(
&
mVorbisState
newVorbisState
)
;
OGG_DEBUG
(
"
New
vorbis
ogg
link
serial
=
%
d
\
n
"
mVorbisState
-
>
mSerial
)
;
if
(
msgInfo
)
{
InitTrack
(
msgInfo
&
mInfo
.
mAudio
true
)
;
}
chained
=
true
;
tags
=
newVorbisState
-
>
GetTags
(
)
;
}
if
(
(
newOpusState
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
newOpusState
)
)
&
&
(
mOpusState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mRate
=
=
newOpusState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mRate
)
&
&
(
mOpusState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mChannels
=
=
newOpusState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mChannels
)
)
{
SetupTarget
(
&
mOpusState
newOpusState
)
;
if
(
msgInfo
)
{
InitTrack
(
msgInfo
&
mInfo
.
mAudio
true
)
;
}
chained
=
true
;
tags
=
newOpusState
-
>
GetTags
(
)
;
}
if
(
(
newFlacState
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
newFlacState
)
)
&
&
(
mFlacState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mRate
=
=
newFlacState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mRate
)
&
&
(
mFlacState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mChannels
=
=
newFlacState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mChannels
)
)
{
SetupTarget
(
&
mFlacState
newFlacState
)
;
OGG_DEBUG
(
"
New
flac
ogg
link
serial
=
%
d
\
n
"
mFlacState
-
>
mSerial
)
;
if
(
msgInfo
)
{
InitTrack
(
msgInfo
&
mInfo
.
mAudio
true
)
;
}
chained
=
true
;
tags
=
newFlacState
-
>
GetTags
(
)
;
}
if
(
chained
)
{
SetChained
(
)
;
mInfo
.
mMediaSeekable
=
false
;
mDecodedAudioDuration
+
=
aLastEndTime
;
if
(
mTimedMetadataEvent
)
{
mTimedMetadataEvent
-
>
Notify
(
TimedMetadata
(
mDecodedAudioDuration
std
:
:
move
(
tags
)
UniquePtr
<
MediaInfo
>
(
new
MediaInfo
(
mInfo
)
)
)
)
;
}
mSharedAudioTrackInfo
=
new
TrackInfoSharedPtr
(
mInfo
.
mAudio
+
+
sStreamSourceID
)
;
return
true
;
}
return
false
;
}
OggDemuxer
:
:
OggStateContext
&
OggDemuxer
:
:
OggState
(
TrackInfo
:
:
TrackType
aType
)
{
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
)
{
return
mVideoOggState
;
}
return
mAudioOggState
;
}
tainted_opaque_ogg
<
ogg_sync_state
*
>
OggDemuxer
:
:
OggSyncState
(
TrackInfo
:
:
TrackType
aType
)
{
return
OggState
(
aType
)
.
mOggState
.
mState
;
}
MediaResourceIndex
*
OggDemuxer
:
:
Resource
(
TrackInfo
:
:
TrackType
aType
)
{
return
&
OggState
(
aType
)
.
mResource
;
}
MediaResourceIndex
*
OggDemuxer
:
:
CommonResource
(
)
{
return
&
mAudioOggState
.
mResource
;
}
bool
OggDemuxer
:
:
ReadOggPage
(
TrackInfo
:
:
TrackType
aType
tainted_opaque_ogg
<
ogg_page
*
>
aPage
)
{
int
ret
=
0
;
while
(
(
ret
=
sandbox_invoke
(
*
mSandbox
ogg_sync_pageseek
OggSyncState
(
aType
)
aPage
)
.
unverified_safe_because
(
RLBOX_OGG_STATE_ASSERT_REASON
)
)
<
=
0
)
{
if
(
ret
<
0
)
{
continue
;
}
const
uint32_t
MIN_BUFFER_SIZE
=
4096
;
tainted_ogg
<
char
*
>
buffer_tainted
=
sandbox_invoke
(
*
mSandbox
ogg_sync_buffer
OggSyncState
(
aType
)
MIN_BUFFER_SIZE
)
;
MOZ_ASSERT
(
buffer_tainted
!
=
nullptr
"
ogg_sync_buffer
failed
"
)
;
uint32_t
bytesRead
=
0
;
char
*
buffer
=
buffer_tainted
.
copy_and_verify_buffer_address
(
[
]
(
uintptr_t
val
)
{
return
reinterpret_cast
<
char
*
>
(
val
)
;
}
MIN_BUFFER_SIZE
)
;
nsresult
rv
=
Resource
(
aType
)
-
>
Read
(
buffer
MIN_BUFFER_SIZE
&
bytesRead
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
bytesRead
)
{
return
false
;
}
ret
=
sandbox_invoke
(
*
mSandbox
ogg_sync_wrote
OggSyncState
(
aType
)
bytesRead
)
.
unverified_safe_because
(
RLBOX_OGG_STATE_ASSERT_REASON
)
;
NS_ENSURE_TRUE
(
ret
=
=
0
false
)
;
}
return
true
;
}
nsresult
OggDemuxer
:
:
DemuxOggPage
(
TrackInfo
:
:
TrackType
aType
tainted_opaque_ogg
<
ogg_page
*
>
aPage
)
{
tainted_ogg
<
int
>
serial
=
sandbox_invoke
(
*
mSandbox
ogg_page_serialno
aPage
)
;
OggCodecState
*
codecState
=
mCodecStore
.
Get
(
static_cast
<
uint32_t
>
(
serial
.
unverified_safe_because
(
RLBOX_OGG_PAGE_SERIAL_REASON
)
)
)
;
if
(
codecState
=
=
nullptr
)
{
OGG_DEBUG
(
"
encountered
packet
for
unrecognized
codecState
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
GetCodecStateType
(
codecState
)
!
=
aType
&
&
codecState
-
>
GetType
(
)
!
=
OggCodecState
:
:
TYPE_SKELETON
)
{
return
NS_OK
;
}
if
(
NS_FAILED
(
codecState
-
>
PageIn
(
aPage
)
)
)
{
OGG_DEBUG
(
"
codecState
-
>
PageIn
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
bool
OggDemuxer
:
:
IsSeekable
(
)
const
{
if
(
mIsChained
)
{
return
false
;
}
return
true
;
}
UniquePtr
<
EncryptionInfo
>
OggDemuxer
:
:
GetCrypto
(
)
{
return
nullptr
;
}
ogg_packet
*
OggDemuxer
:
:
GetNextPacket
(
TrackInfo
:
:
TrackType
aType
)
{
OggCodecState
*
state
=
GetTrackCodecState
(
aType
)
;
ogg_packet
*
packet
=
nullptr
;
OggStateContext
&
context
=
OggState
(
aType
)
;
while
(
true
)
{
if
(
packet
)
{
Unused
<
<
state
-
>
PacketOut
(
)
;
}
DemuxUntilPacketAvailable
(
aType
state
)
;
packet
=
state
-
>
PacketPeek
(
)
;
if
(
!
packet
)
{
break
;
}
if
(
state
-
>
IsHeader
(
packet
)
)
{
continue
;
}
if
(
context
.
mNeedKeyframe
&
&
!
state
-
>
IsKeyframe
(
packet
)
)
{
continue
;
}
context
.
mNeedKeyframe
=
false
;
break
;
}
return
packet
;
}
void
OggDemuxer
:
:
DemuxUntilPacketAvailable
(
TrackInfo
:
:
TrackType
aType
OggCodecState
*
aState
)
{
while
(
!
aState
-
>
IsPacketReady
(
)
)
{
OGG_DEBUG
(
"
no
packet
yet
reading
some
more
"
)
;
tainted_ogg
<
ogg_page
*
>
page
=
mSandbox
-
>
malloc_in_sandbox
<
ogg_page
>
(
)
;
MOZ_RELEASE_ASSERT
(
page
!
=
nullptr
)
;
auto
clean_page
=
MakeScopeExit
(
[
&
]
{
mSandbox
-
>
free_in_sandbox
(
page
)
;
}
)
;
if
(
!
ReadOggPage
(
aType
page
.
to_opaque
(
)
)
)
{
OGG_DEBUG
(
"
no
more
pages
to
read
in
resource
?
"
)
;
return
;
}
DemuxOggPage
(
aType
page
.
to_opaque
(
)
)
;
}
}
TimeIntervals
OggDemuxer
:
:
GetBuffered
(
TrackInfo
:
:
TrackType
aType
)
{
if
(
!
HaveStartTime
(
aType
)
)
{
return
TimeIntervals
(
)
;
}
if
(
mIsChained
)
{
return
TimeIntervals
:
:
Invalid
(
)
;
}
TimeIntervals
buffered
;
if
(
!
mInfo
.
HasValidMedia
(
)
)
{
return
buffered
;
}
AutoPinned
<
MediaResource
>
resource
(
Resource
(
aType
)
-
>
GetResource
(
)
)
;
MediaByteRangeSet
ranges
;
nsresult
res
=
resource
-
>
GetCachedRanges
(
ranges
)
;
NS_ENSURE_SUCCESS
(
res
TimeIntervals
:
:
Invalid
(
)
)
;
const
char
time_interval_reason
[
]
=
"
Even
if
this
computation
is
incorrect
due
to
the
reliance
on
tainted
"
"
values
only
the
search
for
the
time
interval
or
the
time
interval
"
"
returned
will
be
affected
.
However
this
will
not
result
in
a
memory
"
"
safety
vulnerabilty
in
the
Firefox
renderer
.
"
;
nsAutoOggSyncState
sync
(
mSandbox
.
get
(
)
)
;
for
(
uint32_t
index
=
0
;
index
<
ranges
.
Length
(
)
;
index
+
+
)
{
int64_t
startOffset
=
ranges
[
index
]
.
mStart
;
int64_t
endOffset
=
ranges
[
index
]
.
mEnd
;
int64_t
startTime
=
(
startOffset
=
=
0
)
?
StartTime
(
)
:
-
1
;
sandbox_invoke
(
*
mSandbox
ogg_sync_reset
sync
.
mState
)
;
tainted_ogg
<
ogg_page
*
>
page
=
mSandbox
-
>
malloc_in_sandbox
<
ogg_page
>
(
)
;
if
(
!
page
)
{
return
TimeIntervals
:
:
Invalid
(
)
;
}
auto
clean_page
=
MakeScopeExit
(
[
&
]
{
mSandbox
-
>
free_in_sandbox
(
page
)
;
}
)
;
while
(
startTime
=
=
-
1
)
{
int32_t
discard
;
PageSyncResult
pageSyncResult
=
PageSync
(
mSandbox
.
get
(
)
Resource
(
aType
)
sync
.
mState
true
startOffset
endOffset
page
discard
)
;
if
(
pageSyncResult
=
=
PAGE_SYNC_ERROR
)
{
return
TimeIntervals
:
:
Invalid
(
)
;
}
else
if
(
pageSyncResult
=
=
PAGE_SYNC_END_OF_RANGE
)
{
break
;
}
int64_t
granulepos
=
sandbox_invoke
(
*
mSandbox
ogg_page_granulepos
page
)
.
unverified_safe_because
(
time_interval_reason
)
;
if
(
granulepos
=
=
-
1
)
{
bool
failedPageLenVerify
=
false
;
long
pageLength
=
CopyAndVerifyOrFail
(
page
-
>
header_len
+
page
-
>
body_len
val
<
=
64
*
1024
&
failedPageLenVerify
)
;
if
(
failedPageLenVerify
)
{
return
TimeIntervals
:
:
Invalid
(
)
;
}
startOffset
+
=
pageLength
;
continue
;
}
tainted_ogg
<
uint32_t
>
serial
=
rlbox
:
:
sandbox_static_cast
<
uint32_t
>
(
sandbox_invoke
(
*
mSandbox
ogg_page_serialno
page
)
)
;
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
mVorbisState
&
&
(
serial
=
=
mVorbisState
-
>
mSerial
)
.
unverified_safe_because
(
time_interval_reason
)
)
{
startTime
=
mVorbisState
-
>
Time
(
granulepos
)
;
MOZ_ASSERT
(
startTime
>
0
"
Must
have
positive
start
time
"
)
;
}
else
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
mOpusState
&
&
(
serial
=
=
mOpusState
-
>
mSerial
)
.
unverified_safe_because
(
time_interval_reason
)
)
{
startTime
=
mOpusState
-
>
Time
(
granulepos
)
;
MOZ_ASSERT
(
startTime
>
0
"
Must
have
positive
start
time
"
)
;
}
else
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
mFlacState
&
&
(
serial
=
=
mFlacState
-
>
mSerial
)
.
unverified_safe_because
(
time_interval_reason
)
)
{
startTime
=
mFlacState
-
>
Time
(
granulepos
)
;
MOZ_ASSERT
(
startTime
>
0
"
Must
have
positive
start
time
"
)
;
}
else
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
mTheoraState
&
&
(
serial
=
=
mTheoraState
-
>
mSerial
)
.
unverified_safe_because
(
time_interval_reason
)
)
{
startTime
=
mTheoraState
-
>
Time
(
granulepos
)
;
MOZ_ASSERT
(
startTime
>
0
"
Must
have
positive
start
time
"
)
;
}
else
if
(
mCodecStore
.
Contains
(
serial
.
unverified_safe_because
(
time_interval_reason
)
)
)
{
bool
failedPageLenVerify
=
false
;
long
pageLength
=
CopyAndVerifyOrFail
(
page
-
>
header_len
+
page
-
>
body_len
val
<
=
64
*
1024
&
failedPageLenVerify
)
;
if
(
failedPageLenVerify
)
{
return
TimeIntervals
:
:
Invalid
(
)
;
}
startOffset
+
=
pageLength
;
continue
;
}
else
{
SetChained
(
)
;
return
buffered
;
}
}
if
(
startTime
!
=
-
1
)
{
int64_t
endTime
=
RangeEndTime
(
aType
startOffset
endOffset
true
)
;
if
(
endTime
>
startTime
)
{
buffered
+
=
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
startTime
-
StartTime
(
)
)
TimeUnit
:
:
FromMicroseconds
(
endTime
-
StartTime
(
)
)
)
;
}
}
}
return
buffered
;
}
void
OggDemuxer
:
:
FindStartTime
(
int64_t
&
aOutStartTime
)
{
int64_t
videoStartTime
=
INT64_MAX
;
int64_t
audioStartTime
=
INT64_MAX
;
if
(
HasVideo
(
)
)
{
FindStartTime
(
TrackInfo
:
:
kVideoTrack
videoStartTime
)
;
if
(
videoStartTime
!
=
INT64_MAX
)
{
OGG_DEBUG
(
"
OggDemuxer
:
:
FindStartTime
(
)
video
=
%
"
PRId64
videoStartTime
)
;
mVideoOggState
.
mStartTime
=
Some
(
TimeUnit
:
:
FromMicroseconds
(
videoStartTime
)
)
;
}
}
if
(
HasAudio
(
)
)
{
FindStartTime
(
TrackInfo
:
:
kAudioTrack
audioStartTime
)
;
if
(
audioStartTime
!
=
INT64_MAX
)
{
OGG_DEBUG
(
"
OggDemuxer
:
:
FindStartTime
(
)
audio
=
%
"
PRId64
audioStartTime
)
;
mAudioOggState
.
mStartTime
=
Some
(
TimeUnit
:
:
FromMicroseconds
(
audioStartTime
)
)
;
}
}
int64_t
startTime
=
std
:
:
min
(
videoStartTime
audioStartTime
)
;
if
(
startTime
!
=
INT64_MAX
)
{
aOutStartTime
=
startTime
;
}
}
void
OggDemuxer
:
:
FindStartTime
(
TrackInfo
:
:
TrackType
aType
int64_t
&
aOutStartTime
)
{
int64_t
startTime
=
INT64_MAX
;
OggCodecState
*
state
=
GetTrackCodecState
(
aType
)
;
ogg_packet
*
pkt
=
GetNextPacket
(
aType
)
;
if
(
pkt
)
{
startTime
=
state
-
>
PacketStartTime
(
pkt
)
;
}
if
(
startTime
!
=
INT64_MAX
)
{
aOutStartTime
=
startTime
;
}
}
nsresult
OggDemuxer
:
:
SeekInternal
(
TrackInfo
:
:
TrackType
aType
const
TimeUnit
&
aTarget
)
{
int64_t
target
=
aTarget
.
ToMicroseconds
(
)
;
OGG_DEBUG
(
"
About
to
seek
to
%
"
PRId64
target
)
;
nsresult
res
;
int64_t
adjustedTarget
=
target
;
int64_t
startTime
=
StartTime
(
aType
)
;
int64_t
endTime
=
mInfo
.
mMetadataDuration
-
>
ToMicroseconds
(
)
+
startTime
;
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
mOpusState
)
{
adjustedTarget
=
std
:
:
max
(
startTime
target
-
OGG_SEEK_OPUS_PREROLL
.
ToMicroseconds
(
)
)
;
}
if
(
!
HaveStartTime
(
aType
)
|
|
adjustedTarget
=
=
startTime
)
{
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
0
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
res
=
Reset
(
aType
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
else
{
IndexedSeekResult
sres
=
SeekToKeyframeUsingIndex
(
aType
adjustedTarget
)
;
NS_ENSURE_TRUE
(
sres
!
=
SEEK_FATAL_ERROR
NS_ERROR_FAILURE
)
;
if
(
sres
=
=
SEEK_INDEX_FAIL
)
{
AutoTArray
<
SeekRange
16
>
ranges
;
res
=
GetSeekRanges
(
aType
ranges
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
SeekRange
r
=
SelectSeekRange
(
aType
ranges
target
startTime
endTime
true
)
;
if
(
!
r
.
IsNull
(
)
)
{
res
=
SeekInBufferedRange
(
aType
target
adjustedTarget
startTime
endTime
ranges
r
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
else
{
res
=
SeekInUnbuffered
(
aType
target
startTime
endTime
ranges
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
}
}
OggCodecState
*
state
=
GetTrackCodecState
(
aType
)
;
OggPacketQueue
tempPackets
;
bool
foundKeyframe
=
false
;
while
(
true
)
{
DemuxUntilPacketAvailable
(
aType
state
)
;
ogg_packet
*
packet
=
state
-
>
PacketPeek
(
)
;
if
(
packet
=
=
nullptr
)
{
OGG_DEBUG
(
"
End
of
stream
reached
before
keyframe
found
in
indexed
seek
"
)
;
break
;
}
int64_t
startTstamp
=
state
-
>
PacketStartTime
(
packet
)
;
if
(
foundKeyframe
&
&
startTstamp
>
adjustedTarget
)
{
break
;
}
if
(
state
-
>
IsKeyframe
(
packet
)
)
{
OGG_DEBUG
(
"
keyframe
found
after
seeking
at
%
"
PRId64
startTstamp
)
;
tempPackets
.
Erase
(
)
;
foundKeyframe
=
true
;
}
if
(
foundKeyframe
&
&
startTstamp
=
=
adjustedTarget
)
{
break
;
}
if
(
foundKeyframe
)
{
tempPackets
.
Append
(
state
-
>
PacketOut
(
)
)
;
}
else
{
Unused
<
<
state
-
>
PacketOut
(
)
;
}
}
state
-
>
PushFront
(
std
:
:
move
(
tempPackets
)
)
;
return
NS_OK
;
}
OggDemuxer
:
:
IndexedSeekResult
OggDemuxer
:
:
RollbackIndexedSeek
(
TrackInfo
:
:
TrackType
aType
int64_t
aOffset
)
{
if
(
mSkeletonState
)
{
mSkeletonState
-
>
Deactivate
(
)
;
}
nsresult
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
aOffset
)
;
NS_ENSURE_SUCCESS
(
res
SEEK_FATAL_ERROR
)
;
return
SEEK_INDEX_FAIL
;
}
OggDemuxer
:
:
IndexedSeekResult
OggDemuxer
:
:
SeekToKeyframeUsingIndex
(
TrackInfo
:
:
TrackType
aType
int64_t
aTarget
)
{
if
(
!
HasSkeleton
(
)
|
|
!
mSkeletonState
-
>
HasIndex
(
)
)
{
return
SEEK_INDEX_FAIL
;
}
AutoTArray
<
uint32_t
2
>
tracks
;
BuildSerialList
(
tracks
)
;
SkeletonState
:
:
nsSeekTarget
keyframe
;
if
(
NS_FAILED
(
mSkeletonState
-
>
IndexedSeekTarget
(
aTarget
tracks
keyframe
)
)
)
{
return
SEEK_INDEX_FAIL
;
}
int64_t
tell
=
Resource
(
aType
)
-
>
Tell
(
)
;
if
(
keyframe
.
mKeyPoint
.
mOffset
>
Resource
(
aType
)
-
>
GetLength
(
)
|
|
keyframe
.
mKeyPoint
.
mOffset
<
0
)
{
return
RollbackIndexedSeek
(
aType
tell
)
;
}
OGG_DEBUG
(
"
Seeking
using
index
to
keyframe
at
offset
%
"
PRId64
"
\
n
"
keyframe
.
mKeyPoint
.
mOffset
)
;
nsresult
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
keyframe
.
mKeyPoint
.
mOffset
)
;
NS_ENSURE_SUCCESS
(
res
SEEK_FATAL_ERROR
)
;
res
=
Reset
(
aType
)
;
NS_ENSURE_SUCCESS
(
res
SEEK_FATAL_ERROR
)
;
tainted_ogg
<
ogg_page
*
>
page
=
mSandbox
-
>
malloc_in_sandbox
<
ogg_page
>
(
)
;
if
(
!
page
)
{
return
SEEK_INDEX_FAIL
;
}
auto
clean_page
=
MakeScopeExit
(
[
&
]
{
mSandbox
-
>
free_in_sandbox
(
page
)
;
}
)
;
int
skippedBytes
=
0
;
PageSyncResult
syncres
=
PageSync
(
mSandbox
.
get
(
)
Resource
(
aType
)
OggSyncState
(
aType
)
false
keyframe
.
mKeyPoint
.
mOffset
Resource
(
aType
)
-
>
GetLength
(
)
page
skippedBytes
)
;
NS_ENSURE_TRUE
(
syncres
!
=
PAGE_SYNC_ERROR
SEEK_FATAL_ERROR
)
;
if
(
syncres
!
=
PAGE_SYNC_OK
|
|
skippedBytes
!
=
0
)
{
OGG_DEBUG
(
"
Indexed
-
seek
failure
:
Ogg
Skeleton
Index
is
invalid
"
"
or
sync
error
after
seek
"
)
;
return
RollbackIndexedSeek
(
aType
tell
)
;
}
uint32_t
serial
=
static_cast
<
uint32_t
>
(
sandbox_invoke
(
*
mSandbox
ogg_page_serialno
page
)
.
unverified_safe_because
(
"
Serial
is
only
used
to
locate
the
correct
page
.
If
the
serial
"
"
is
incorrect
the
the
renderer
would
just
fail
to
seek
with
an
"
"
error
code
.
This
would
not
lead
to
any
memory
safety
bugs
.
"
)
)
;
if
(
serial
!
=
keyframe
.
mSerial
)
{
return
RollbackIndexedSeek
(
aType
tell
)
;
}
OggCodecState
*
codecState
=
mCodecStore
.
Get
(
serial
)
;
if
(
codecState
&
&
codecState
-
>
mActive
&
&
sandbox_invoke
(
*
mSandbox
ogg_stream_pagein
codecState
-
>
mState
page
)
.
unverified_safe_because
(
RLBOX_OGG_STATE_ASSERT_REASON
)
!
=
0
)
{
return
RollbackIndexedSeek
(
aType
tell
)
;
}
return
SEEK_OK
;
}
OggDemuxer
:
:
PageSyncResult
OggDemuxer
:
:
PageSync
(
rlbox_sandbox_ogg
*
aSandbox
MediaResourceIndex
*
aResource
tainted_opaque_ogg
<
ogg_sync_state
*
>
aState
bool
aCachedDataOnly
int64_t
aOffset
int64_t
aEndOffset
tainted_ogg
<
ogg_page
*
>
aPage
int
&
aSkippedBytes
)
{
aSkippedBytes
=
0
;
tainted_ogg
<
int
>
ret
=
0
;
uint32_t
bytesRead
=
0
;
int64_t
readHead
=
aOffset
;
while
(
ret
.
unverified_safe_because
(
RLBOX_OGG_STATE_ASSERT_REASON
)
<
=
0
)
{
tainted_ogg
<
long
>
seek_ret
=
sandbox_invoke
(
*
aSandbox
ogg_sync_pageseek
aState
aPage
)
;
bool
failedVerify
=
false
;
CheckedInt
<
int
>
checker
;
ret
=
CopyAndVerifyOrFail
(
seek_ret
(
static_cast
<
void
>
(
checker
=
val
)
checker
.
isValid
(
)
)
&
failedVerify
)
;
if
(
failedVerify
)
{
return
PAGE_SYNC_ERROR
;
}
if
(
ret
.
unverified_safe_because
(
RLBOX_OGG_STATE_ASSERT_REASON
)
=
=
0
)
{
const
int
page_step_val
=
PAGE_STEP
;
tainted_ogg
<
char
*
>
buffer_tainted
=
sandbox_invoke
(
*
aSandbox
ogg_sync_buffer
aState
page_step_val
)
;
MOZ_ASSERT
(
buffer_tainted
!
=
nullptr
"
Must
have
a
buffer
"
)
;
int64_t
bytesToRead
=
std
:
:
min
(
static_cast
<
int64_t
>
(
PAGE_STEP
)
aEndOffset
-
readHead
)
;
MOZ_ASSERT
(
bytesToRead
<
=
UINT32_MAX
"
bytesToRead
range
check
"
)
;
if
(
bytesToRead
<
=
0
)
{
return
PAGE_SYNC_END_OF_RANGE
;
}
char
*
buffer
=
buffer_tainted
.
copy_and_verify_buffer_address
(
[
]
(
uintptr_t
val
)
{
return
reinterpret_cast
<
char
*
>
(
val
)
;
}
static_cast
<
size_t
>
(
bytesToRead
)
)
;
nsresult
rv
=
NS_OK
;
if
(
aCachedDataOnly
)
{
rv
=
aResource
-
>
GetResource
(
)
-
>
ReadFromCache
(
buffer
readHead
static_cast
<
uint32_t
>
(
bytesToRead
)
)
;
NS_ENSURE_SUCCESS
(
rv
PAGE_SYNC_ERROR
)
;
bytesRead
=
static_cast
<
uint32_t
>
(
bytesToRead
)
;
}
else
{
rv
=
aResource
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
readHead
)
;
NS_ENSURE_SUCCESS
(
rv
PAGE_SYNC_ERROR
)
;
rv
=
aResource
-
>
Read
(
buffer
static_cast
<
uint32_t
>
(
bytesToRead
)
&
bytesRead
)
;
NS_ENSURE_SUCCESS
(
rv
PAGE_SYNC_ERROR
)
;
}
if
(
bytesRead
=
=
0
&
&
NS_SUCCEEDED
(
rv
)
)
{
return
PAGE_SYNC_END_OF_RANGE
;
}
readHead
+
=
bytesRead
;
ret
=
sandbox_invoke
(
*
aSandbox
ogg_sync_wrote
aState
bytesRead
)
;
NS_ENSURE_TRUE
(
ret
.
unverified_safe_because
(
RLBOX_OGG_STATE_ASSERT_REASON
)
=
=
0
PAGE_SYNC_ERROR
)
;
continue
;
}
if
(
ret
.
unverified_safe_because
(
RLBOX_OGG_STATE_ASSERT_REASON
)
<
0
)
{
MOZ_ASSERT
(
aSkippedBytes
>
=
0
"
Offset
>
=
0
"
)
;
bool
failedSkippedBytesVerify
=
false
;
ret
.
copy_and_verify
(
[
&
]
(
int
val
)
{
int64_t
result
=
static_cast
<
int64_t
>
(
aSkippedBytes
)
-
val
;
if
(
result
>
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
|
|
result
>
(
aEndOffset
-
aOffset
)
|
|
result
<
0
)
{
failedSkippedBytesVerify
=
true
;
}
else
{
aSkippedBytes
=
result
;
}
}
)
;
if
(
failedSkippedBytesVerify
)
{
return
PAGE_SYNC_ERROR
;
}
continue
;
}
}
return
PAGE_SYNC_OK
;
}
OggTrackDemuxer
:
:
OggTrackDemuxer
(
OggDemuxer
*
aParent
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
:
mParent
(
aParent
)
mType
(
aType
)
{
mInfo
=
mParent
-
>
GetTrackInfo
(
aType
aTrackNumber
)
;
MOZ_ASSERT
(
mInfo
)
;
}
OggTrackDemuxer
:
:
~
OggTrackDemuxer
(
)
=
default
;
UniquePtr
<
TrackInfo
>
OggTrackDemuxer
:
:
GetInfo
(
)
const
{
return
mInfo
-
>
Clone
(
)
;
}
RefPtr
<
OggTrackDemuxer
:
:
SeekPromise
>
OggTrackDemuxer
:
:
Seek
(
const
TimeUnit
&
aTime
)
{
mQueuedSample
=
nullptr
;
TimeUnit
seekTime
=
aTime
;
if
(
mParent
-
>
SeekInternal
(
mType
aTime
)
=
=
NS_OK
)
{
RefPtr
<
MediaRawData
>
sample
(
NextSample
(
)
)
;
if
(
sample
!
=
nullptr
)
{
seekTime
=
sample
-
>
mTime
;
OGG_DEBUG
(
"
%
p
seeked
to
time
%
"
PRId64
this
seekTime
.
ToMicroseconds
(
)
)
;
}
mQueuedSample
=
sample
;
return
SeekPromise
:
:
CreateAndResolve
(
seekTime
__func__
)
;
}
else
{
return
SeekPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_DEMUXER_ERR
__func__
)
;
}
}
RefPtr
<
MediaRawData
>
OggTrackDemuxer
:
:
NextSample
(
)
{
if
(
mQueuedSample
)
{
RefPtr
<
MediaRawData
>
nextSample
=
mQueuedSample
;
mQueuedSample
=
nullptr
;
if
(
mType
=
=
TrackInfo
:
:
kAudioTrack
)
{
nextSample
-
>
mTrackInfo
=
mParent
-
>
mSharedAudioTrackInfo
;
}
return
nextSample
;
}
ogg_packet
*
packet
=
mParent
-
>
GetNextPacket
(
mType
)
;
if
(
!
packet
)
{
return
nullptr
;
}
bool
eos
=
packet
-
>
e_o_s
;
OggCodecState
*
state
=
mParent
-
>
GetTrackCodecState
(
mType
)
;
RefPtr
<
MediaRawData
>
data
=
state
-
>
PacketOutAsMediaRawData
(
)
;
if
(
!
data
|
|
(
data
-
>
mEOS
&
&
data
-
>
Size
(
)
=
=
0
)
)
{
return
nullptr
;
}
if
(
mType
=
=
TrackInfo
:
:
kAudioTrack
)
{
data
-
>
mTrackInfo
=
mParent
-
>
mSharedAudioTrackInfo
;
}
TimeUnit
totalDuration
=
mParent
-
>
mDecodedAudioDuration
;
if
(
eos
)
{
mParent
-
>
ReadOggChain
(
data
-
>
GetEndTime
(
)
)
;
}
data
-
>
mOffset
=
mParent
-
>
Resource
(
mType
)
-
>
Tell
(
)
;
data
-
>
mTime
+
=
totalDuration
;
if
(
!
data
-
>
mTime
.
IsValid
(
)
)
{
return
nullptr
;
}
return
data
;
}
RefPtr
<
OggTrackDemuxer
:
:
SamplesPromise
>
OggTrackDemuxer
:
:
GetSamples
(
int32_t
aNumSamples
)
{
RefPtr
<
SamplesHolder
>
samples
=
new
SamplesHolder
;
if
(
!
aNumSamples
)
{
return
SamplesPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_DEMUXER_ERR
__func__
)
;
}
while
(
aNumSamples
)
{
RefPtr
<
MediaRawData
>
sample
(
NextSample
(
)
)
;
if
(
!
sample
)
{
break
;
}
if
(
!
sample
-
>
HasValidTime
(
)
)
{
return
SamplesPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_DEMUXER_ERR
__func__
)
;
}
samples
-
>
AppendSample
(
sample
)
;
aNumSamples
-
-
;
}
if
(
samples
-
>
GetSamples
(
)
.
IsEmpty
(
)
)
{
return
SamplesPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_END_OF_STREAM
__func__
)
;
}
else
{
return
SamplesPromise
:
:
CreateAndResolve
(
samples
__func__
)
;
}
}
void
OggTrackDemuxer
:
:
Reset
(
)
{
mParent
-
>
Reset
(
mType
)
;
mQueuedSample
=
nullptr
;
}
RefPtr
<
OggTrackDemuxer
:
:
SkipAccessPointPromise
>
OggTrackDemuxer
:
:
SkipToNextRandomAccessPoint
(
const
TimeUnit
&
aTimeThreshold
)
{
uint32_t
parsed
=
0
;
bool
found
=
false
;
RefPtr
<
MediaRawData
>
sample
;
OGG_DEBUG
(
"
TimeThreshold
:
%
f
"
aTimeThreshold
.
ToSeconds
(
)
)
;
while
(
!
found
&
&
(
sample
=
NextSample
(
)
)
)
{
parsed
+
+
;
if
(
sample
-
>
mKeyframe
&
&
sample
-
>
mTime
>
=
aTimeThreshold
)
{
found
=
true
;
mQueuedSample
=
sample
;
}
}
if
(
found
)
{
OGG_DEBUG
(
"
next
sample
:
%
f
(
parsed
:
%
d
)
"
sample
-
>
mTime
.
ToSeconds
(
)
parsed
)
;
return
SkipAccessPointPromise
:
:
CreateAndResolve
(
parsed
__func__
)
;
}
else
{
SkipFailureHolder
failure
(
NS_ERROR_DOM_MEDIA_END_OF_STREAM
parsed
)
;
return
SkipAccessPointPromise
:
:
CreateAndReject
(
std
:
:
move
(
failure
)
__func__
)
;
}
}
TimeIntervals
OggTrackDemuxer
:
:
GetBuffered
(
)
{
return
mParent
-
>
GetBuffered
(
mType
)
;
}
void
OggTrackDemuxer
:
:
BreakCycles
(
)
{
mParent
=
nullptr
;
}
tainted_opaque_ogg
<
ogg_uint32_t
>
OggDemuxer
:
:
GetPageChecksum
(
tainted_opaque_ogg
<
ogg_page
*
>
aPage
)
{
tainted_ogg
<
ogg_page
*
>
page
=
rlbox
:
:
from_opaque
(
aPage
)
;
const
char
hint_reason
[
]
=
"
Early
bail
out
of
checksum
.
Even
if
this
is
wrong
the
renderer
'
s
"
"
security
is
not
compromised
.
"
;
if
(
page
=
=
nullptr
|
|
(
page
-
>
header
=
=
nullptr
)
.
unverified_safe_because
(
hint_reason
)
|
|
(
page
-
>
header_len
<
25
)
.
unverified_safe_because
(
hint_reason
)
)
{
tainted_ogg
<
ogg_uint32_t
>
ret
=
0
;
return
ret
.
to_opaque
(
)
;
}
const
int
CHECKSUM_BYTES_LENGTH
=
4
;
const
unsigned
char
*
p
=
(
page
-
>
header
+
22u
)
.
copy_and_verify_buffer_address
(
[
]
(
uintptr_t
val
)
{
return
reinterpret_cast
<
const
unsigned
char
*
>
(
val
)
;
}
CHECKSUM_BYTES_LENGTH
)
;
uint32_t
c
=
static_cast
<
uint32_t
>
(
p
[
0
]
+
(
p
[
1
]
<
<
8
)
+
(
p
[
2
]
<
<
16
)
+
(
p
[
3
]
<
<
24
)
)
;
tainted_ogg
<
uint32_t
>
ret
=
c
;
return
ret
.
to_opaque
(
)
;
}
int64_t
OggDemuxer
:
:
RangeStartTime
(
TrackInfo
:
:
TrackType
aType
int64_t
aOffset
)
{
int64_t
position
=
Resource
(
aType
)
-
>
Tell
(
)
;
nsresult
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
aOffset
)
;
NS_ENSURE_SUCCESS
(
res
0
)
;
int64_t
startTime
=
0
;
FindStartTime
(
aType
startTime
)
;
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
position
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
return
startTime
;
}
struct
nsDemuxerAutoOggSyncState
{
explicit
nsDemuxerAutoOggSyncState
(
rlbox_sandbox_ogg
&
aSandbox
)
:
mSandbox
(
aSandbox
)
{
mState
=
mSandbox
.
malloc_in_sandbox
<
ogg_sync_state
>
(
)
;
MOZ_RELEASE_ASSERT
(
mState
!
=
nullptr
)
;
sandbox_invoke
(
mSandbox
ogg_sync_init
mState
)
;
}
~
nsDemuxerAutoOggSyncState
(
)
{
sandbox_invoke
(
mSandbox
ogg_sync_clear
mState
)
;
mSandbox
.
free_in_sandbox
(
mState
)
;
}
rlbox_sandbox_ogg
&
mSandbox
;
tainted_ogg
<
ogg_sync_state
*
>
mState
;
}
;
int64_t
OggDemuxer
:
:
RangeEndTime
(
TrackInfo
:
:
TrackType
aType
int64_t
aEndOffset
)
{
int64_t
position
=
Resource
(
aType
)
-
>
Tell
(
)
;
int64_t
endTime
=
RangeEndTime
(
aType
0
aEndOffset
false
)
;
nsresult
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
position
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
return
endTime
;
}
int64_t
OggDemuxer
:
:
RangeEndTime
(
TrackInfo
:
:
TrackType
aType
int64_t
aStartOffset
int64_t
aEndOffset
bool
aCachedDataOnly
)
{
nsDemuxerAutoOggSyncState
sync
(
*
mSandbox
)
;
const
int
step
=
5000
;
const
int
maxOggPageSize
=
65306
;
int64_t
readStartOffset
=
aEndOffset
;
int64_t
readLimitOffset
=
aEndOffset
;
int64_t
readHead
=
aEndOffset
;
int64_t
endTime
=
-
1
;
uint32_t
checksumAfterSeek
=
0
;
uint32_t
prevChecksumAfterSeek
=
0
;
bool
mustBackOff
=
false
;
tainted_ogg
<
ogg_page
*
>
page
=
mSandbox
-
>
malloc_in_sandbox
<
ogg_page
>
(
)
;
if
(
!
page
)
{
return
-
1
;
}
auto
clean_page
=
MakeScopeExit
(
[
&
]
{
mSandbox
-
>
free_in_sandbox
(
page
)
;
}
)
;
while
(
true
)
{
tainted_ogg
<
long
>
seek_ret
=
sandbox_invoke
(
*
mSandbox
ogg_sync_pageseek
sync
.
mState
page
)
;
bool
failedVerify
=
false
;
CheckedInt
<
int
>
checker
;
tainted_ogg
<
int
>
ret
=
CopyAndVerifyOrFail
(
seek_ret
(
static_cast
<
void
>
(
checker
=
val
)
checker
.
isValid
(
)
)
&
failedVerify
)
;
if
(
failedVerify
)
{
return
-
1
;
}
if
(
ret
.
unverified_safe_because
(
RLBOX_OGG_STATE_ASSERT_REASON
)
=
=
0
)
{
if
(
mustBackOff
|
|
readHead
=
=
aEndOffset
|
|
readHead
=
=
aStartOffset
)
{
if
(
endTime
!
=
-
1
|
|
readStartOffset
=
=
0
)
{
break
;
}
mustBackOff
=
false
;
prevChecksumAfterSeek
=
checksumAfterSeek
;
checksumAfterSeek
=
0
;
sandbox_invoke
(
*
mSandbox
ogg_sync_reset
sync
.
mState
)
;
readStartOffset
=
std
:
:
max
(
static_cast
<
int64_t
>
(
0
)
readStartOffset
-
step
)
;
readLimitOffset
=
std
:
:
min
(
readLimitOffset
readStartOffset
+
maxOggPageSize
)
;
readHead
=
std
:
:
max
(
aStartOffset
readStartOffset
)
;
}
int64_t
limit
=
std
:
:
min
(
static_cast
<
int64_t
>
(
UINT32_MAX
)
aEndOffset
-
readHead
)
;
limit
=
std
:
:
max
(
static_cast
<
int64_t
>
(
0
)
limit
)
;
limit
=
std
:
:
min
(
limit
static_cast
<
int64_t
>
(
step
)
)
;
uint32_t
bytesToRead
=
static_cast
<
uint32_t
>
(
limit
)
;
uint32_t
bytesRead
=
0
;
tainted_ogg
<
char
*
>
buffer_tainted
=
sandbox_invoke
(
*
mSandbox
ogg_sync_buffer
sync
.
mState
bytesToRead
)
;
char
*
buffer
=
buffer_tainted
.
copy_and_verify_buffer_address
(
[
]
(
uintptr_t
val
)
{
return
reinterpret_cast
<
char
*
>
(
val
)
;
}
bytesToRead
)
;
MOZ_ASSERT
(
buffer
"
Must
have
buffer
"
)
;
nsresult
res
;
if
(
aCachedDataOnly
)
{
res
=
Resource
(
aType
)
-
>
GetResource
(
)
-
>
ReadFromCache
(
buffer
readHead
bytesToRead
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
bytesRead
=
bytesToRead
;
}
else
{
MOZ_ASSERT
(
readHead
<
aEndOffset
"
resource
pos
must
be
before
range
end
"
)
;
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
readHead
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
res
=
Resource
(
aType
)
-
>
Read
(
buffer
bytesToRead
&
bytesRead
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
}
readHead
+
=
bytesRead
;
if
(
readHead
>
readLimitOffset
)
{
mustBackOff
=
true
;
}
ret
=
sandbox_invoke
(
*
mSandbox
ogg_sync_wrote
sync
.
mState
bytesRead
)
;
bool
failedWroteVerify
=
false
;
int
wrote_success
=
CopyAndVerifyOrFail
(
ret
val
=
=
0
|
|
val
=
=
-
1
&
failedWroteVerify
)
;
if
(
failedWroteVerify
)
{
return
-
1
;
}
if
(
wrote_success
!
=
0
)
{
endTime
=
-
1
;
break
;
}
continue
;
}
if
(
ret
.
unverified_safe_because
(
RLBOX_OGG_STATE_ASSERT_REASON
)
<
0
|
|
sandbox_invoke
(
*
mSandbox
ogg_page_granulepos
page
)
.
unverified_safe_because
(
RLBOX_OGG_STATE_ASSERT_REASON
)
<
0
)
{
continue
;
}
tainted_ogg
<
uint32_t
>
checksum_tainted
=
rlbox
:
:
from_opaque
(
GetPageChecksum
(
page
.
to_opaque
(
)
)
)
;
uint32_t
checksum
=
checksum_tainted
.
unverified_safe_because
(
"
checksum
is
only
being
used
as
a
hint
as
part
of
search
for
end
time
.
"
"
Incorrect
values
will
not
affect
the
memory
safety
of
the
renderer
.
"
)
;
if
(
checksumAfterSeek
=
=
0
)
{
checksumAfterSeek
=
checksum
;
}
if
(
checksum
=
=
prevChecksumAfterSeek
)
{
mustBackOff
=
true
;
continue
;
}
int64_t
granulepos
=
sandbox_invoke
(
*
mSandbox
ogg_page_granulepos
page
)
.
unverified_safe_because
(
"
If
this
is
incorrect
it
may
lead
to
incorrect
seeking
"
"
behavior
in
the
stream
however
will
not
affect
the
memory
"
"
safety
of
the
Firefox
renderer
.
"
)
;
uint32_t
serial
=
static_cast
<
uint32_t
>
(
sandbox_invoke
(
*
mSandbox
ogg_page_serialno
page
)
.
unverified_safe_because
(
RLBOX_OGG_PAGE_SERIAL_REASON
)
)
;
OggCodecState
*
codecState
=
nullptr
;
codecState
=
mCodecStore
.
Get
(
serial
)
;
if
(
!
codecState
)
{
SetChained
(
)
;
endTime
=
-
1
;
break
;
}
int64_t
t
=
codecState
-
>
Time
(
granulepos
)
;
if
(
t
!
=
-
1
)
{
endTime
=
t
;
}
}
return
endTime
;
}
nsresult
OggDemuxer
:
:
GetSeekRanges
(
TrackInfo
:
:
TrackType
aType
nsTArray
<
SeekRange
>
&
aRanges
)
{
AutoPinned
<
MediaResource
>
resource
(
Resource
(
aType
)
-
>
GetResource
(
)
)
;
MediaByteRangeSet
cached
;
nsresult
res
=
resource
-
>
GetCachedRanges
(
cached
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
for
(
uint32_t
index
=
0
;
index
<
cached
.
Length
(
)
;
index
+
+
)
{
auto
&
range
=
cached
[
index
]
;
int64_t
startTime
=
-
1
;
int64_t
endTime
=
-
1
;
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
int64_t
startOffset
=
range
.
mStart
;
int64_t
endOffset
=
range
.
mEnd
;
startTime
=
RangeStartTime
(
aType
startOffset
)
;
if
(
startTime
!
=
-
1
&
&
(
(
endTime
=
RangeEndTime
(
aType
endOffset
)
)
!
=
-
1
)
)
{
NS_WARNING_ASSERTION
(
startTime
<
endTime
"
Start
time
must
be
before
end
time
"
)
;
aRanges
.
AppendElement
(
SeekRange
(
startOffset
endOffset
startTime
endTime
)
)
;
}
}
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
OggDemuxer
:
:
SeekRange
OggDemuxer
:
:
SelectSeekRange
(
TrackInfo
:
:
TrackType
aType
const
nsTArray
<
SeekRange
>
&
ranges
int64_t
aTarget
int64_t
aStartTime
int64_t
aEndTime
bool
aExact
)
{
int64_t
so
=
0
;
int64_t
eo
=
Resource
(
aType
)
-
>
GetLength
(
)
;
int64_t
st
=
aStartTime
;
int64_t
et
=
aEndTime
;
for
(
uint32_t
i
=
0
;
i
<
ranges
.
Length
(
)
;
i
+
+
)
{
const
SeekRange
&
r
=
ranges
[
i
]
;
if
(
r
.
mTimeStart
<
aTarget
)
{
so
=
r
.
mOffsetStart
;
st
=
r
.
mTimeStart
;
}
if
(
r
.
mTimeEnd
>
=
aTarget
&
&
r
.
mTimeEnd
<
et
)
{
eo
=
r
.
mOffsetEnd
;
et
=
r
.
mTimeEnd
;
}
if
(
r
.
mTimeStart
<
aTarget
&
&
aTarget
<
=
r
.
mTimeEnd
)
{
return
ranges
[
i
]
;
}
}
if
(
aExact
|
|
eo
=
=
-
1
)
{
return
SeekRange
(
)
;
}
return
SeekRange
(
so
eo
st
et
)
;
}
nsresult
OggDemuxer
:
:
SeekInBufferedRange
(
TrackInfo
:
:
TrackType
aType
int64_t
aTarget
int64_t
aAdjustedTarget
int64_t
aStartTime
int64_t
aEndTime
const
nsTArray
<
SeekRange
>
&
aRanges
const
SeekRange
&
aRange
)
{
OGG_DEBUG
(
"
Seeking
in
buffered
data
to
%
"
PRId64
"
using
bisection
search
"
aTarget
)
;
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
|
|
aAdjustedTarget
>
=
aTarget
)
{
nsresult
res
=
SeekBisection
(
aType
aTarget
aRange
0
)
;
if
(
NS_FAILED
(
res
)
|
|
aType
!
=
TrackInfo
:
:
kVideoTrack
)
{
return
res
;
}
DemuxUntilPacketAvailable
(
aType
mTheoraState
)
;
ogg_packet
*
packet
=
mTheoraState
-
>
PacketPeek
(
)
;
if
(
packet
&
&
!
mTheoraState
-
>
IsKeyframe
(
packet
)
)
{
MOZ_ASSERT
(
packet
-
>
granulepos
!
=
-
1
"
Must
have
a
granulepos
"
)
;
int
shift
=
mTheoraState
-
>
KeyFrameGranuleJobs
(
)
;
int64_t
keyframeGranulepos
=
(
packet
-
>
granulepos
>
>
shift
)
<
<
shift
;
int64_t
keyframeTime
=
mTheoraState
-
>
StartTime
(
keyframeGranulepos
)
;
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Keyframe
for
%
lld
is
at
%
lld
seeking
back
to
it
"
frameTime
keyframeTime
)
)
;
aAdjustedTarget
=
std
:
:
min
(
aAdjustedTarget
keyframeTime
)
;
}
}
nsresult
res
=
NS_OK
;
if
(
aAdjustedTarget
<
aTarget
)
{
SeekRange
k
=
SelectSeekRange
(
aType
aRanges
aAdjustedTarget
aStartTime
aEndTime
false
)
;
res
=
SeekBisection
(
aType
aAdjustedTarget
k
OGG_SEEK_FUZZ_USECS
)
;
}
return
res
;
}
nsresult
OggDemuxer
:
:
SeekInUnbuffered
(
TrackInfo
:
:
TrackType
aType
int64_t
aTarget
int64_t
aStartTime
int64_t
aEndTime
const
nsTArray
<
SeekRange
>
&
aRanges
)
{
OGG_DEBUG
(
"
Seeking
in
unbuffered
data
to
%
"
PRId64
"
using
bisection
search
"
aTarget
)
;
int64_t
keyframeOffsetMs
=
0
;
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
mTheoraState
)
{
keyframeOffsetMs
=
mTheoraState
-
>
MaxKeyframeOffset
(
)
;
}
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
mOpusState
)
{
keyframeOffsetMs
=
std
:
:
max
(
keyframeOffsetMs
OGG_SEEK_OPUS_PREROLL
.
ToMilliseconds
(
)
)
;
}
int64_t
seekTarget
=
std
:
:
max
(
aStartTime
aTarget
-
keyframeOffsetMs
)
;
SeekRange
k
=
SelectSeekRange
(
aType
aRanges
seekTarget
aStartTime
aEndTime
false
)
;
return
SeekBisection
(
aType
seekTarget
k
OGG_SEEK_FUZZ_USECS
)
;
}
nsresult
OggDemuxer
:
:
SeekBisection
(
TrackInfo
:
:
TrackType
aType
int64_t
aTarget
const
SeekRange
&
aRange
uint32_t
aFuzz
)
{
nsresult
res
;
if
(
aTarget
<
=
aRange
.
mTimeStart
)
{
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
0
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
return
NS_OK
;
}
ogg_int64_t
startOffset
=
aRange
.
mOffsetStart
;
ogg_int64_t
startTime
=
aRange
.
mTimeStart
;
ogg_int64_t
startLength
=
0
;
ogg_int64_t
endOffset
=
aRange
.
mOffsetEnd
;
ogg_int64_t
endTime
=
aRange
.
mTimeEnd
;
ogg_int64_t
seekTarget
=
aTarget
;
int64_t
seekLowerBound
=
std
:
:
max
(
static_cast
<
int64_t
>
(
0
)
aTarget
-
aFuzz
)
;
int
hops
=
0
;
DebugOnly
<
ogg_int64_t
>
previousGuess
=
-
1
;
int
backsteps
=
0
;
const
int
maxBackStep
=
10
;
MOZ_ASSERT
(
static_cast
<
uint64_t
>
(
PAGE_STEP
)
*
pow
(
2
.
0
maxBackStep
)
<
INT32_MAX
"
Backstep
calculation
must
not
overflow
"
)
;
tainted_ogg
<
ogg_page
*
>
page
=
mSandbox
-
>
malloc_in_sandbox
<
ogg_page
>
(
)
;
if
(
!
page
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
auto
clean_page
=
MakeScopeExit
(
[
&
]
{
mSandbox
-
>
free_in_sandbox
(
page
)
;
}
)
;
while
(
true
)
{
ogg_int64_t
duration
=
0
;
double
target
=
0
;
ogg_int64_t
interval
=
0
;
ogg_int64_t
guess
=
0
;
int
skippedBytes
=
0
;
ogg_int64_t
pageOffset
=
0
;
ogg_int64_t
pageLength
=
0
;
ogg_int64_t
granuleTime
=
-
1
;
bool
mustBackoff
=
false
;
while
(
true
)
{
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
interval
=
endOffset
-
startOffset
-
startLength
;
if
(
interval
=
=
0
)
{
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Interval
narrowed
terminating
bisection
.
"
)
)
;
break
;
}
duration
=
endTime
-
startTime
;
target
=
(
double
)
(
seekTarget
-
startTime
)
/
(
double
)
duration
;
guess
=
startOffset
+
startLength
+
static_cast
<
ogg_int64_t
>
(
(
double
)
interval
*
target
)
;
guess
=
std
:
:
min
(
guess
endOffset
-
PAGE_STEP
)
;
if
(
mustBackoff
)
{
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Backing
off
%
d
bytes
backsteps
=
%
d
"
static_cast
<
int32_t
>
(
PAGE_STEP
*
pow
(
2
.
0
backsteps
)
)
backsteps
)
)
;
guess
-
=
PAGE_STEP
*
static_cast
<
ogg_int64_t
>
(
pow
(
2
.
0
backsteps
)
)
;
if
(
guess
<
=
startOffset
)
{
interval
=
0
;
break
;
}
backsteps
=
std
:
:
min
(
backsteps
+
1
maxBackStep
)
;
mustBackoff
=
false
;
}
else
{
backsteps
=
0
;
}
guess
=
std
:
:
max
(
guess
startOffset
+
startLength
)
;
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Seek
loop
start
[
o
=
%
lld
.
.
%
lld
t
=
%
lld
]
"
"
end
[
o
=
%
lld
t
=
%
lld
]
"
"
interval
=
%
lld
target
=
%
lf
guess
=
%
lld
"
startOffset
(
startOffset
+
startLength
)
startTime
endOffset
endTime
interval
target
guess
)
)
;
MOZ_ASSERT
(
guess
>
=
startOffset
+
startLength
"
Guess
must
be
after
range
start
"
)
;
MOZ_ASSERT
(
guess
<
endOffset
"
Guess
must
be
before
range
end
"
)
;
MOZ_ASSERT
(
guess
!
=
previousGuess
"
Guess
should
be
different
to
previous
"
)
;
previousGuess
=
guess
;
hops
+
+
;
PageSyncResult
pageSyncResult
=
PageSync
(
mSandbox
.
get
(
)
Resource
(
aType
)
OggSyncState
(
aType
)
false
guess
endOffset
page
skippedBytes
)
;
NS_ENSURE_TRUE
(
pageSyncResult
!
=
PAGE_SYNC_ERROR
NS_ERROR_FAILURE
)
;
if
(
pageSyncResult
=
=
PAGE_SYNC_END_OF_RANGE
)
{
mustBackoff
=
true
;
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Hit
the
end
of
range
backing
off
"
)
)
;
continue
;
}
pageOffset
=
guess
+
skippedBytes
;
bool
failedPageLenVerify
=
false
;
pageLength
=
CopyAndVerifyOrFail
(
page
-
>
header_len
+
page
-
>
body_len
val
<
=
64
*
1024
&
failedPageLenVerify
)
;
if
(
failedPageLenVerify
)
{
return
NS_ERROR_FAILURE
;
}
ogg_int64_t
audioTime
=
-
1
;
ogg_int64_t
videoTime
=
-
1
;
do
{
uint32_t
serial
=
static_cast
<
uint32_t
>
(
sandbox_invoke
(
*
mSandbox
ogg_page_serialno
page
)
.
unverified_safe_because
(
RLBOX_OGG_PAGE_SERIAL_REASON
)
)
;
OggCodecState
*
codecState
=
mCodecStore
.
Get
(
serial
)
;
if
(
codecState
&
&
GetCodecStateType
(
codecState
)
=
=
aType
)
{
if
(
codecState
-
>
mActive
)
{
int
ret
=
sandbox_invoke
(
*
mSandbox
ogg_stream_pagein
codecState
-
>
mState
page
)
.
unverified_safe_because
(
RLBOX_OGG_STATE_ASSERT_REASON
)
;
NS_ENSURE_TRUE
(
ret
=
=
0
NS_ERROR_FAILURE
)
;
}
ogg_int64_t
granulepos
=
sandbox_invoke
(
*
mSandbox
ogg_page_granulepos
page
)
.
unverified_safe_because
(
"
If
this
is
incorrect
it
may
lead
to
incorrect
seeking
"
"
behavior
in
the
stream
however
will
not
affect
the
"
"
memory
safety
of
the
Firefox
renderer
.
"
)
;
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
granulepos
>
0
&
&
audioTime
=
=
-
1
)
{
if
(
mVorbisState
&
&
serial
=
=
mVorbisState
-
>
mSerial
)
{
audioTime
=
mVorbisState
-
>
Time
(
granulepos
)
;
}
else
if
(
mOpusState
&
&
serial
=
=
mOpusState
-
>
mSerial
)
{
audioTime
=
mOpusState
-
>
Time
(
granulepos
)
;
}
else
if
(
mFlacState
&
&
serial
=
=
mFlacState
-
>
mSerial
)
{
audioTime
=
mFlacState
-
>
Time
(
granulepos
)
;
}
}
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
granulepos
>
0
&
&
serial
=
=
mTheoraState
-
>
mSerial
&
&
videoTime
=
=
-
1
)
{
videoTime
=
mTheoraState
-
>
Time
(
granulepos
)
;
}
if
(
pageOffset
+
pageLength
>
=
endOffset
)
{
break
;
}
}
if
(
!
ReadOggPage
(
aType
page
.
to_opaque
(
)
)
)
{
break
;
}
}
while
(
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
audioTime
=
=
-
1
)
|
|
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
videoTime
=
=
-
1
)
)
;
if
(
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
audioTime
=
=
-
1
)
|
|
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
videoTime
=
=
-
1
)
)
{
if
(
pageOffset
=
=
startOffset
+
startLength
&
&
pageOffset
+
pageLength
>
=
endOffset
)
{
interval
=
0
;
break
;
}
mustBackoff
=
true
;
continue
;
}
granuleTime
=
aType
=
=
TrackInfo
:
:
kAudioTrack
?
audioTime
:
videoTime
;
MOZ_ASSERT
(
granuleTime
>
0
"
Must
get
a
granuletime
"
)
;
break
;
}
if
(
interval
=
=
0
)
{
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Terminating
seek
at
offset
=
%
lld
"
startOffset
)
)
;
MOZ_ASSERT
(
startTime
<
aTarget
"
Start
time
must
always
be
less
than
target
"
)
;
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
startOffset
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
break
;
}
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Time
at
offset
%
lld
is
%
lld
"
guess
granuleTime
)
)
;
if
(
granuleTime
<
seekTarget
&
&
granuleTime
>
seekLowerBound
)
{
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
pageOffset
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Terminating
seek
at
offset
=
%
lld
"
pageOffset
)
)
;
break
;
}
if
(
granuleTime
>
=
seekTarget
)
{
MOZ_ASSERT
(
pageOffset
<
endOffset
"
offset_end
must
decrease
"
)
;
endOffset
=
pageOffset
;
endTime
=
granuleTime
;
}
else
if
(
granuleTime
<
seekTarget
)
{
MOZ_ASSERT
(
pageOffset
>
=
startOffset
+
startLength
"
Bisection
point
should
be
at
or
after
end
of
first
page
in
"
"
interval
"
)
;
startOffset
=
pageOffset
;
startLength
=
pageLength
;
startTime
=
granuleTime
;
}
MOZ_ASSERT
(
startTime
<
=
seekTarget
"
Must
be
before
seek
target
"
)
;
MOZ_ASSERT
(
endTime
>
=
seekTarget
"
End
must
be
after
seek
target
"
)
;
}
(
void
)
hops
;
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Seek
complete
in
%
d
bisections
.
"
hops
)
)
;
return
NS_OK
;
}
#
undef
OGG_DEBUG
#
undef
SEEK_LOG
#
undef
CopyAndVerifyOrFail
}
