#
include
"
nsError
.
h
"
#
include
"
MediaDecoderStateMachine
.
h
"
#
include
"
OggDemuxer
.
h
"
#
include
"
OggCodecState
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
MediaDataDemuxer
.
h
"
#
include
"
nsAutoRef
.
h
"
#
include
"
XiphExtradata
.
h
"
#
include
"
MediaPrefs
.
h
"
#
include
<
algorithm
>
extern
mozilla
:
:
LazyLogModule
gMediaDemuxerLog
;
#
define
OGG_DEBUG
(
arg
.
.
.
)
\
DDMOZ_LOG
(
gMediaDemuxerLog
\
mozilla
:
:
LogLevel
:
:
Debug
\
"
:
:
%
s
:
"
arg
\
__func__
\
#
#
__VA_ARGS__
)
#
ifdef
SEEK_LOGGING
#
define
SEEK_LOG
(
type
msg
)
MOZ_LOG
(
gMediaDemuxerLog
type
msg
)
#
else
#
define
SEEK_LOG
(
type
msg
)
#
endif
namespace
mozilla
{
using
media
:
:
TimeUnit
;
using
media
:
:
TimeInterval
;
using
media
:
:
TimeIntervals
;
static
const
uint32_t
OGG_SEEK_FUZZ_USECS
=
500000
;
static
const
int64_t
OGG_SEEK_OPUS_PREROLL
=
80
*
USECS_PER_MS
;
static
Atomic
<
uint32_t
>
sStreamSourceID
(
0u
)
;
const
nsString
OggDemuxer
:
:
GetKind
(
const
nsCString
&
aRole
)
{
if
(
aRole
.
Find
(
"
audio
/
main
"
)
!
=
-
1
|
|
aRole
.
Find
(
"
video
/
main
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
main
"
)
;
}
else
if
(
aRole
.
Find
(
"
audio
/
alternate
"
)
!
=
-
1
|
|
aRole
.
Find
(
"
video
/
alternate
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
alternative
"
)
;
}
else
if
(
aRole
.
Find
(
"
audio
/
audiodesc
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
descriptions
"
)
;
}
else
if
(
aRole
.
Find
(
"
audio
/
described
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
main
-
desc
"
)
;
}
else
if
(
aRole
.
Find
(
"
audio
/
dub
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
translation
"
)
;
}
else
if
(
aRole
.
Find
(
"
audio
/
commentary
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
commentary
"
)
;
}
else
if
(
aRole
.
Find
(
"
video
/
sign
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
sign
"
)
;
}
else
if
(
aRole
.
Find
(
"
video
/
captioned
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
captions
"
)
;
}
else
if
(
aRole
.
Find
(
"
video
/
subtitled
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
subtitles
"
)
;
}
return
EmptyString
(
)
;
}
void
OggDemuxer
:
:
InitTrack
(
MessageField
*
aMsgInfo
TrackInfo
*
aInfo
bool
aEnable
)
{
MOZ_ASSERT
(
aMsgInfo
)
;
MOZ_ASSERT
(
aInfo
)
;
nsCString
*
sName
=
aMsgInfo
-
>
mValuesStore
.
Get
(
eName
)
;
nsCString
*
sRole
=
aMsgInfo
-
>
mValuesStore
.
Get
(
eRole
)
;
nsCString
*
sTitle
=
aMsgInfo
-
>
mValuesStore
.
Get
(
eTitle
)
;
nsCString
*
sLanguage
=
aMsgInfo
-
>
mValuesStore
.
Get
(
eLanguage
)
;
aInfo
-
>
Init
(
sName
?
NS_ConvertUTF8toUTF16
(
*
sName
)
:
EmptyString
(
)
sRole
?
GetKind
(
*
sRole
)
:
EmptyString
(
)
sTitle
?
NS_ConvertUTF8toUTF16
(
*
sTitle
)
:
EmptyString
(
)
sLanguage
?
NS_ConvertUTF8toUTF16
(
*
sLanguage
)
:
EmptyString
(
)
aEnable
)
;
}
OggDemuxer
:
:
OggDemuxer
(
MediaResource
*
aResource
)
:
mTheoraState
(
nullptr
)
mVorbisState
(
nullptr
)
mOpusState
(
nullptr
)
mFlacState
(
nullptr
)
mOpusEnabled
(
MediaDecoder
:
:
IsOpusEnabled
(
)
)
mSkeletonState
(
nullptr
)
mAudioOggState
(
aResource
)
mVideoOggState
(
aResource
)
mIsChained
(
false
)
mTimedMetadataEvent
(
nullptr
)
mOnSeekableEvent
(
nullptr
)
{
MOZ_COUNT_CTOR
(
OggDemuxer
)
;
DDLINKCHILD
(
"
resource
"
aResource
)
;
}
OggDemuxer
:
:
~
OggDemuxer
(
)
{
MOZ_COUNT_DTOR
(
OggDemuxer
)
;
Reset
(
TrackInfo
:
:
kAudioTrack
)
;
Reset
(
TrackInfo
:
:
kVideoTrack
)
;
if
(
HasAudio
(
)
|
|
HasVideo
(
)
)
{
bool
isChained
=
mIsChained
;
void
*
ptr
=
this
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
"
OggDemuxer
:
:
~
OggDemuxer
"
[
ptr
isChained
]
(
)
-
>
void
{
MOZ_LOG
(
gMediaDemuxerLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
OggDemuxer
(
%
p
)
:
:
%
s
:
Reporting
telemetry
"
"
MEDIA_OGG_LOADED_IS_CHAINED
=
%
d
"
ptr
__func__
isChained
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HistogramID
:
:
MEDIA_OGG_LOADED_IS_CHAINED
isChained
)
;
}
)
;
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
task
.
forget
(
)
)
;
}
}
void
OggDemuxer
:
:
SetChainingEvents
(
TimedMetadataEventProducer
*
aMetadataEvent
MediaEventProducer
<
void
>
*
aOnSeekableEvent
)
{
mTimedMetadataEvent
=
aMetadataEvent
;
mOnSeekableEvent
=
aOnSeekableEvent
;
}
bool
OggDemuxer
:
:
HasAudio
(
)
const
{
return
mVorbisState
|
|
mOpusState
|
|
mFlacState
;
}
bool
OggDemuxer
:
:
HasVideo
(
)
const
{
return
mTheoraState
;
}
bool
OggDemuxer
:
:
HaveStartTime
(
)
const
{
return
mStartTime
.
isSome
(
)
;
}
int64_t
OggDemuxer
:
:
StartTime
(
)
const
{
return
mStartTime
.
refOr
(
0
)
;
}
bool
OggDemuxer
:
:
HaveStartTime
(
TrackInfo
:
:
TrackType
aType
)
{
return
OggState
(
aType
)
.
mStartTime
.
isSome
(
)
;
}
int64_t
OggDemuxer
:
:
StartTime
(
TrackInfo
:
:
TrackType
aType
)
{
return
OggState
(
aType
)
.
mStartTime
.
refOr
(
TimeUnit
:
:
Zero
(
)
)
.
ToMicroseconds
(
)
;
}
RefPtr
<
OggDemuxer
:
:
InitPromise
>
OggDemuxer
:
:
Init
(
)
{
int
ret
=
ogg_sync_init
(
OggSyncState
(
TrackInfo
:
:
kAudioTrack
)
)
;
if
(
ret
!
=
0
)
{
return
InitPromise
:
:
CreateAndReject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
}
ret
=
ogg_sync_init
(
OggSyncState
(
TrackInfo
:
:
kVideoTrack
)
)
;
if
(
ret
!
=
0
)
{
return
InitPromise
:
:
CreateAndReject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
}
if
(
ReadMetadata
(
)
!
=
NS_OK
)
{
return
InitPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_METADATA_ERR
__func__
)
;
}
if
(
!
GetNumberTracks
(
TrackInfo
:
:
kAudioTrack
)
&
&
!
GetNumberTracks
(
TrackInfo
:
:
kVideoTrack
)
)
{
return
InitPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_METADATA_ERR
__func__
)
;
}
return
InitPromise
:
:
CreateAndResolve
(
NS_OK
__func__
)
;
}
OggCodecState
*
OggDemuxer
:
:
GetTrackCodecState
(
TrackInfo
:
:
TrackType
aType
)
const
{
switch
(
aType
)
{
case
TrackInfo
:
:
kAudioTrack
:
if
(
mVorbisState
)
{
return
mVorbisState
;
}
else
if
(
mOpusState
)
{
return
mOpusState
;
}
else
{
return
mFlacState
;
}
case
TrackInfo
:
:
kVideoTrack
:
return
mTheoraState
;
default
:
return
0
;
}
}
TrackInfo
:
:
TrackType
OggDemuxer
:
:
GetCodecStateType
(
OggCodecState
*
aState
)
const
{
switch
(
aState
-
>
GetType
(
)
)
{
case
OggCodecState
:
:
TYPE_THEORA
:
return
TrackInfo
:
:
kVideoTrack
;
case
OggCodecState
:
:
TYPE_OPUS
:
case
OggCodecState
:
:
TYPE_VORBIS
:
case
OggCodecState
:
:
TYPE_FLAC
:
return
TrackInfo
:
:
kAudioTrack
;
default
:
return
TrackInfo
:
:
kUndefinedTrack
;
}
}
uint32_t
OggDemuxer
:
:
GetNumberTracks
(
TrackInfo
:
:
TrackType
aType
)
const
{
switch
(
aType
)
{
case
TrackInfo
:
:
kAudioTrack
:
return
HasAudio
(
)
?
1
:
0
;
case
TrackInfo
:
:
kVideoTrack
:
return
HasVideo
(
)
?
1
:
0
;
default
:
return
0
;
}
}
UniquePtr
<
TrackInfo
>
OggDemuxer
:
:
GetTrackInfo
(
TrackInfo
:
:
TrackType
aType
size_t
aTrackNumber
)
const
{
switch
(
aType
)
{
case
TrackInfo
:
:
kAudioTrack
:
return
mInfo
.
mAudio
.
Clone
(
)
;
case
TrackInfo
:
:
kVideoTrack
:
return
mInfo
.
mVideo
.
Clone
(
)
;
default
:
return
nullptr
;
}
}
already_AddRefed
<
MediaTrackDemuxer
>
OggDemuxer
:
:
GetTrackDemuxer
(
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
{
if
(
GetNumberTracks
(
aType
)
<
=
aTrackNumber
)
{
return
nullptr
;
}
RefPtr
<
OggTrackDemuxer
>
e
=
new
OggTrackDemuxer
(
this
aType
aTrackNumber
)
;
DDLINKCHILD
(
"
track
demuxer
"
e
.
get
(
)
)
;
mDemuxers
.
AppendElement
(
e
)
;
return
e
.
forget
(
)
;
}
nsresult
OggDemuxer
:
:
Reset
(
TrackInfo
:
:
TrackType
aType
)
{
ogg_sync_reset
(
OggSyncState
(
aType
)
)
;
OggCodecState
*
trackState
=
GetTrackCodecState
(
aType
)
;
if
(
trackState
)
{
return
trackState
-
>
Reset
(
)
;
}
OggState
(
aType
)
.
mNeedKeyframe
=
true
;
return
NS_OK
;
}
bool
OggDemuxer
:
:
ReadHeaders
(
TrackInfo
:
:
TrackType
aType
OggCodecState
*
aState
)
{
while
(
!
aState
-
>
DoneReadingHeaders
(
)
)
{
DemuxUntilPacketAvailable
(
aType
aState
)
;
OggPacketPtr
packet
=
aState
-
>
PacketOut
(
)
;
if
(
!
packet
)
{
OGG_DEBUG
(
"
Ran
out
of
header
packets
early
;
deactivating
stream
%
"
PRIu32
aState
-
>
mSerial
)
;
aState
-
>
Deactivate
(
)
;
return
false
;
}
if
(
!
aState
-
>
DecodeHeader
(
Move
(
packet
)
)
)
{
OGG_DEBUG
(
"
Failed
to
decode
ogg
header
packet
;
deactivating
stream
%
"
PRIu32
aState
-
>
mSerial
)
;
aState
-
>
Deactivate
(
)
;
return
false
;
}
}
return
aState
-
>
Init
(
)
;
}
void
OggDemuxer
:
:
BuildSerialList
(
nsTArray
<
uint32_t
>
&
aTracks
)
{
if
(
HasVideo
(
)
)
{
aTracks
.
AppendElement
(
mTheoraState
-
>
mSerial
)
;
}
if
(
HasAudio
(
)
)
{
if
(
mVorbisState
)
{
aTracks
.
AppendElement
(
mVorbisState
-
>
mSerial
)
;
}
else
if
(
mOpusState
)
{
aTracks
.
AppendElement
(
mOpusState
-
>
mSerial
)
;
}
}
}
void
OggDemuxer
:
:
SetupTarget
(
OggCodecState
*
*
aSavedState
OggCodecState
*
aNewState
)
{
if
(
*
aSavedState
)
{
(
*
aSavedState
)
-
>
Reset
(
)
;
}
if
(
aNewState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
)
{
mInfo
.
mAudio
=
*
aNewState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
;
}
else
{
mInfo
.
mVideo
=
*
aNewState
-
>
GetInfo
(
)
-
>
GetAsVideoInfo
(
)
;
}
*
aSavedState
=
aNewState
;
}
void
OggDemuxer
:
:
SetupTargetSkeleton
(
)
{
if
(
mSkeletonState
)
{
if
(
!
HasAudio
(
)
&
&
!
HasVideo
(
)
)
{
OGG_DEBUG
(
"
Deactivating
skeleton
stream
%
"
PRIu32
mSkeletonState
-
>
mSerial
)
;
mSkeletonState
-
>
Deactivate
(
)
;
}
else
if
(
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
mSkeletonState
)
&
&
mSkeletonState
-
>
HasIndex
(
)
)
{
nsTArray
<
uint32_t
>
tracks
;
BuildSerialList
(
tracks
)
;
int64_t
duration
=
0
;
if
(
NS_SUCCEEDED
(
mSkeletonState
-
>
GetDuration
(
tracks
duration
)
)
)
{
OGG_DEBUG
(
"
Got
duration
from
Skeleton
index
%
"
PRId64
duration
)
;
mInfo
.
mMetadataDuration
.
emplace
(
TimeUnit
:
:
FromMicroseconds
(
duration
)
)
;
}
}
}
}
void
OggDemuxer
:
:
SetupMediaTracksInfo
(
const
nsTArray
<
uint32_t
>
&
aSerials
)
{
for
(
size_t
i
=
0
;
i
<
aSerials
.
Length
(
)
;
i
+
+
)
{
uint32_t
serial
=
aSerials
[
i
]
;
OggCodecState
*
codecState
=
mCodecStore
.
Get
(
serial
)
;
MessageField
*
msgInfo
=
nullptr
;
if
(
mSkeletonState
)
{
mSkeletonState
-
>
mMsgFieldStore
.
Get
(
serial
&
msgInfo
)
;
}
OggCodecState
*
primeState
=
nullptr
;
switch
(
codecState
-
>
GetType
(
)
)
{
case
OggCodecState
:
:
TYPE_THEORA
:
primeState
=
mTheoraState
;
break
;
case
OggCodecState
:
:
TYPE_VORBIS
:
primeState
=
mVorbisState
;
break
;
case
OggCodecState
:
:
TYPE_OPUS
:
primeState
=
mOpusState
;
break
;
case
OggCodecState
:
:
TYPE_FLAC
:
primeState
=
mFlacState
;
break
;
default
:
break
;
}
if
(
primeState
&
&
primeState
=
=
codecState
)
{
bool
isAudio
=
primeState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
;
if
(
msgInfo
)
{
InitTrack
(
msgInfo
isAudio
?
static_cast
<
TrackInfo
*
>
(
&
mInfo
.
mAudio
)
:
&
mInfo
.
mVideo
true
)
;
}
FillTags
(
isAudio
?
static_cast
<
TrackInfo
*
>
(
&
mInfo
.
mAudio
)
:
&
mInfo
.
mVideo
primeState
-
>
GetTags
(
)
)
;
}
}
}
void
OggDemuxer
:
:
FillTags
(
TrackInfo
*
aInfo
MetadataTags
*
aTags
)
{
if
(
!
aTags
)
{
return
;
}
nsAutoPtr
<
MetadataTags
>
tags
(
aTags
)
;
for
(
auto
iter
=
aTags
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aInfo
-
>
mTags
.
AppendElement
(
MetadataTag
(
iter
.
Key
(
)
iter
.
Data
(
)
)
)
;
}
}
nsresult
OggDemuxer
:
:
ReadMetadata
(
)
{
OGG_DEBUG
(
"
OggDemuxer
:
:
ReadMetadata
called
!
"
)
;
TrackInfo
:
:
TrackType
tracks
[
2
]
=
{
TrackInfo
:
:
kAudioTrack
TrackInfo
:
:
kVideoTrack
}
;
nsTArray
<
OggCodecState
*
>
bitstreams
;
nsTArray
<
uint32_t
>
serials
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
tracks
)
;
i
+
+
)
{
ogg_page
page
;
bool
readAllBOS
=
false
;
while
(
!
readAllBOS
)
{
if
(
!
ReadOggPage
(
tracks
[
i
]
&
page
)
)
{
OGG_DEBUG
(
"
OggDemuxer
:
:
ReadOggPage
failed
?
leaving
ReadMetadata
.
.
.
"
)
;
return
NS_ERROR_FAILURE
;
}
int
serial
=
ogg_page_serialno
(
&
page
)
;
if
(
!
ogg_page_bos
(
&
page
)
)
{
readAllBOS
=
true
;
}
else
if
(
!
mCodecStore
.
Contains
(
serial
)
)
{
OggCodecState
*
codecState
=
OggCodecState
:
:
Create
(
&
page
)
;
mCodecStore
.
Add
(
serial
codecState
)
;
bitstreams
.
AppendElement
(
codecState
)
;
serials
.
AppendElement
(
serial
)
;
}
if
(
NS_FAILED
(
DemuxOggPage
(
tracks
[
i
]
&
page
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
for
(
uint32_t
i
=
0
;
i
<
bitstreams
.
Length
(
)
;
+
+
i
)
{
OggCodecState
*
s
=
bitstreams
[
i
]
;
if
(
s
)
{
if
(
s
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_THEORA
&
&
ReadHeaders
(
TrackInfo
:
:
kVideoTrack
s
)
)
{
if
(
!
mTheoraState
)
{
SetupTarget
(
&
mTheoraState
s
)
;
}
else
{
s
-
>
Deactivate
(
)
;
}
}
else
if
(
s
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_VORBIS
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
s
)
)
{
if
(
!
mVorbisState
)
{
SetupTarget
(
&
mVorbisState
s
)
;
}
else
{
s
-
>
Deactivate
(
)
;
}
}
else
if
(
s
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_OPUS
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
s
)
)
{
if
(
mOpusEnabled
)
{
if
(
!
mOpusState
)
{
SetupTarget
(
&
mOpusState
s
)
;
}
else
{
s
-
>
Deactivate
(
)
;
}
}
else
{
NS_WARNING
(
"
Opus
decoding
disabled
.
"
"
See
media
.
opus
.
enabled
in
about
:
config
"
)
;
}
}
else
if
(
MediaPrefs
:
:
FlacInOgg
(
)
&
&
s
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_FLAC
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
s
)
)
{
if
(
!
mFlacState
)
{
SetupTarget
(
&
mFlacState
s
)
;
}
else
{
s
-
>
Deactivate
(
)
;
}
}
else
if
(
s
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_SKELETON
&
&
!
mSkeletonState
)
{
mSkeletonState
=
static_cast
<
SkeletonState
*
>
(
s
)
;
}
else
{
s
-
>
Deactivate
(
)
;
}
}
}
SetupTargetSkeleton
(
)
;
SetupMediaTracksInfo
(
serials
)
;
if
(
HasAudio
(
)
|
|
HasVideo
(
)
)
{
int64_t
startTime
=
-
1
;
FindStartTime
(
startTime
)
;
if
(
startTime
>
=
0
)
{
OGG_DEBUG
(
"
Detected
stream
start
time
%
"
PRId64
startTime
)
;
mStartTime
.
emplace
(
startTime
)
;
}
if
(
mInfo
.
mMetadataDuration
.
isNothing
(
)
&
&
Resource
(
TrackInfo
:
:
kAudioTrack
)
-
>
GetLength
(
)
>
=
0
)
{
int64_t
length
=
Resource
(
TrackInfo
:
:
kAudioTrack
)
-
>
GetLength
(
)
;
NS_ASSERTION
(
length
>
0
"
Must
have
a
content
length
to
get
end
time
"
)
;
int64_t
endTime
=
RangeEndTime
(
TrackInfo
:
:
kAudioTrack
length
)
;
if
(
endTime
!
=
-
1
)
{
mInfo
.
mUnadjustedMetadataEndTime
.
emplace
(
TimeUnit
:
:
FromMicroseconds
(
endTime
)
)
;
mInfo
.
mMetadataDuration
.
emplace
(
TimeUnit
:
:
FromMicroseconds
(
endTime
-
mStartTime
.
refOr
(
0
)
)
)
;
OGG_DEBUG
(
"
Got
Ogg
duration
from
seeking
to
end
%
"
PRId64
endTime
)
;
}
}
if
(
mInfo
.
mMetadataDuration
.
isNothing
(
)
)
{
mInfo
.
mMetadataDuration
.
emplace
(
TimeUnit
:
:
FromInfinity
(
)
)
;
}
if
(
HasAudio
(
)
)
{
mInfo
.
mAudio
.
mDuration
=
mInfo
.
mMetadataDuration
.
ref
(
)
;
}
if
(
HasVideo
(
)
)
{
mInfo
.
mVideo
.
mDuration
=
mInfo
.
mMetadataDuration
.
ref
(
)
;
}
}
else
{
OGG_DEBUG
(
"
no
audio
or
video
tracks
"
)
;
return
NS_ERROR_FAILURE
;
}
OGG_DEBUG
(
"
success
?
!
"
)
;
return
NS_OK
;
}
void
OggDemuxer
:
:
SetChained
(
)
{
{
if
(
mIsChained
)
{
return
;
}
mIsChained
=
true
;
}
if
(
mOnSeekableEvent
)
{
mOnSeekableEvent
-
>
Notify
(
)
;
}
}
bool
OggDemuxer
:
:
ReadOggChain
(
const
media
:
:
TimeUnit
&
aLastEndTime
)
{
bool
chained
=
false
;
OpusState
*
newOpusState
=
nullptr
;
VorbisState
*
newVorbisState
=
nullptr
;
FlacState
*
newFlacState
=
nullptr
;
nsAutoPtr
<
MetadataTags
>
tags
;
if
(
HasVideo
(
)
|
|
HasSkeleton
(
)
|
|
!
HasAudio
(
)
)
{
return
false
;
}
ogg_page
page
;
if
(
!
ReadOggPage
(
TrackInfo
:
:
kAudioTrack
&
page
)
|
|
!
ogg_page_bos
(
&
page
)
)
{
return
false
;
}
int
serial
=
ogg_page_serialno
(
&
page
)
;
if
(
mCodecStore
.
Contains
(
serial
)
)
{
return
false
;
}
nsAutoPtr
<
OggCodecState
>
codecState
;
codecState
=
OggCodecState
:
:
Create
(
&
page
)
;
if
(
!
codecState
)
{
return
false
;
}
if
(
mVorbisState
&
&
(
codecState
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_VORBIS
)
)
{
newVorbisState
=
static_cast
<
VorbisState
*
>
(
codecState
.
get
(
)
)
;
}
else
if
(
mOpusState
&
&
(
codecState
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_OPUS
)
)
{
newOpusState
=
static_cast
<
OpusState
*
>
(
codecState
.
get
(
)
)
;
}
else
if
(
mFlacState
&
&
(
codecState
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_FLAC
)
)
{
newFlacState
=
static_cast
<
FlacState
*
>
(
codecState
.
get
(
)
)
;
}
else
{
return
false
;
}
OggCodecState
*
state
;
mCodecStore
.
Add
(
serial
codecState
.
forget
(
)
)
;
state
=
mCodecStore
.
Get
(
serial
)
;
NS_ENSURE_TRUE
(
state
!
=
nullptr
false
)
;
if
(
NS_FAILED
(
state
-
>
PageIn
(
&
page
)
)
)
{
return
false
;
}
MessageField
*
msgInfo
=
nullptr
;
if
(
mSkeletonState
)
{
mSkeletonState
-
>
mMsgFieldStore
.
Get
(
serial
&
msgInfo
)
;
}
if
(
(
newVorbisState
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
newVorbisState
)
)
&
&
(
mVorbisState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mRate
=
=
newVorbisState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mRate
)
&
&
(
mVorbisState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mChannels
=
=
newVorbisState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mChannels
)
)
{
SetupTarget
(
&
mVorbisState
newVorbisState
)
;
OGG_DEBUG
(
"
New
vorbis
ogg
link
serial
=
%
d
\
n
"
mVorbisState
-
>
mSerial
)
;
if
(
msgInfo
)
{
InitTrack
(
msgInfo
&
mInfo
.
mAudio
true
)
;
}
chained
=
true
;
tags
=
newVorbisState
-
>
GetTags
(
)
;
}
if
(
(
newOpusState
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
newOpusState
)
)
&
&
(
mOpusState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mRate
=
=
newOpusState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mRate
)
&
&
(
mOpusState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mChannels
=
=
newOpusState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mChannels
)
)
{
SetupTarget
(
&
mOpusState
newOpusState
)
;
if
(
msgInfo
)
{
InitTrack
(
msgInfo
&
mInfo
.
mAudio
true
)
;
}
chained
=
true
;
tags
=
newOpusState
-
>
GetTags
(
)
;
}
if
(
(
newFlacState
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
newFlacState
)
)
&
&
(
mFlacState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mRate
=
=
newFlacState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mRate
)
&
&
(
mFlacState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mChannels
=
=
newFlacState
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
-
>
mChannels
)
)
{
SetupTarget
(
&
mFlacState
newFlacState
)
;
OGG_DEBUG
(
"
New
flac
ogg
link
serial
=
%
d
\
n
"
mFlacState
-
>
mSerial
)
;
if
(
msgInfo
)
{
InitTrack
(
msgInfo
&
mInfo
.
mAudio
true
)
;
}
chained
=
true
;
tags
=
newFlacState
-
>
GetTags
(
)
;
}
if
(
chained
)
{
SetChained
(
)
;
mInfo
.
mMediaSeekable
=
false
;
mDecodedAudioDuration
+
=
aLastEndTime
;
if
(
mTimedMetadataEvent
)
{
mTimedMetadataEvent
-
>
Notify
(
TimedMetadata
(
mDecodedAudioDuration
Move
(
tags
)
nsAutoPtr
<
MediaInfo
>
(
new
MediaInfo
(
mInfo
)
)
)
)
;
}
mSharedAudioTrackInfo
=
new
TrackInfoSharedPtr
(
mInfo
.
mAudio
+
+
sStreamSourceID
)
;
return
true
;
}
return
false
;
}
OggDemuxer
:
:
OggStateContext
&
OggDemuxer
:
:
OggState
(
TrackInfo
:
:
TrackType
aType
)
{
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
)
{
return
mVideoOggState
;
}
return
mAudioOggState
;
}
ogg_sync_state
*
OggDemuxer
:
:
OggSyncState
(
TrackInfo
:
:
TrackType
aType
)
{
return
&
OggState
(
aType
)
.
mOggState
.
mState
;
}
MediaResourceIndex
*
OggDemuxer
:
:
Resource
(
TrackInfo
:
:
TrackType
aType
)
{
return
&
OggState
(
aType
)
.
mResource
;
}
MediaResourceIndex
*
OggDemuxer
:
:
CommonResource
(
)
{
return
&
mAudioOggState
.
mResource
;
}
bool
OggDemuxer
:
:
ReadOggPage
(
TrackInfo
:
:
TrackType
aType
ogg_page
*
aPage
)
{
int
ret
=
0
;
while
(
(
ret
=
ogg_sync_pageseek
(
OggSyncState
(
aType
)
aPage
)
)
<
=
0
)
{
if
(
ret
<
0
)
{
continue
;
}
char
*
buffer
=
ogg_sync_buffer
(
OggSyncState
(
aType
)
4096
)
;
NS_ASSERTION
(
buffer
"
ogg_sync_buffer
failed
"
)
;
uint32_t
bytesRead
=
0
;
nsresult
rv
=
Resource
(
aType
)
-
>
Read
(
buffer
4096
&
bytesRead
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
bytesRead
)
{
return
false
;
}
ret
=
ogg_sync_wrote
(
OggSyncState
(
aType
)
bytesRead
)
;
NS_ENSURE_TRUE
(
ret
=
=
0
false
)
;
}
return
true
;
}
nsresult
OggDemuxer
:
:
DemuxOggPage
(
TrackInfo
:
:
TrackType
aType
ogg_page
*
aPage
)
{
int
serial
=
ogg_page_serialno
(
aPage
)
;
OggCodecState
*
codecState
=
mCodecStore
.
Get
(
serial
)
;
if
(
codecState
=
=
nullptr
)
{
OGG_DEBUG
(
"
encountered
packet
for
unrecognized
codecState
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
GetCodecStateType
(
codecState
)
!
=
aType
&
&
codecState
-
>
GetType
(
)
!
=
OggCodecState
:
:
TYPE_SKELETON
)
{
return
NS_OK
;
}
if
(
NS_FAILED
(
codecState
-
>
PageIn
(
aPage
)
)
)
{
OGG_DEBUG
(
"
codecState
-
>
PageIn
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
bool
OggDemuxer
:
:
IsSeekable
(
)
const
{
if
(
mIsChained
)
{
return
false
;
}
return
true
;
}
UniquePtr
<
EncryptionInfo
>
OggDemuxer
:
:
GetCrypto
(
)
{
return
nullptr
;
}
ogg_packet
*
OggDemuxer
:
:
GetNextPacket
(
TrackInfo
:
:
TrackType
aType
)
{
OggCodecState
*
state
=
GetTrackCodecState
(
aType
)
;
ogg_packet
*
packet
=
nullptr
;
OggStateContext
&
context
=
OggState
(
aType
)
;
while
(
true
)
{
if
(
packet
)
{
Unused
<
<
state
-
>
PacketOut
(
)
;
}
DemuxUntilPacketAvailable
(
aType
state
)
;
packet
=
state
-
>
PacketPeek
(
)
;
if
(
!
packet
)
{
break
;
}
if
(
state
-
>
IsHeader
(
packet
)
)
{
continue
;
}
if
(
context
.
mNeedKeyframe
&
&
!
state
-
>
IsKeyframe
(
packet
)
)
{
continue
;
}
context
.
mNeedKeyframe
=
false
;
break
;
}
return
packet
;
}
void
OggDemuxer
:
:
DemuxUntilPacketAvailable
(
TrackInfo
:
:
TrackType
aType
OggCodecState
*
aState
)
{
while
(
!
aState
-
>
IsPacketReady
(
)
)
{
OGG_DEBUG
(
"
no
packet
yet
reading
some
more
"
)
;
ogg_page
page
;
if
(
!
ReadOggPage
(
aType
&
page
)
)
{
OGG_DEBUG
(
"
no
more
pages
to
read
in
resource
?
"
)
;
return
;
}
DemuxOggPage
(
aType
&
page
)
;
}
}
TimeIntervals
OggDemuxer
:
:
GetBuffered
(
TrackInfo
:
:
TrackType
aType
)
{
if
(
!
HaveStartTime
(
aType
)
)
{
return
TimeIntervals
(
)
;
}
if
(
mIsChained
)
{
return
TimeIntervals
:
:
Invalid
(
)
;
}
TimeIntervals
buffered
;
if
(
!
mInfo
.
HasValidMedia
(
)
)
{
return
buffered
;
}
AutoPinned
<
MediaResource
>
resource
(
Resource
(
aType
)
-
>
GetResource
(
)
)
;
MediaByteRangeSet
ranges
;
nsresult
res
=
resource
-
>
GetCachedRanges
(
ranges
)
;
NS_ENSURE_SUCCESS
(
res
TimeIntervals
:
:
Invalid
(
)
)
;
nsAutoOggSyncState
sync
;
for
(
uint32_t
index
=
0
;
index
<
ranges
.
Length
(
)
;
index
+
+
)
{
int64_t
startOffset
=
ranges
[
index
]
.
mStart
;
int64_t
endOffset
=
ranges
[
index
]
.
mEnd
;
int64_t
startTime
=
(
startOffset
=
=
0
)
?
StartTime
(
)
:
-
1
;
ogg_sync_reset
(
&
sync
.
mState
)
;
while
(
startTime
=
=
-
1
)
{
ogg_page
page
;
int32_t
discard
;
PageSyncResult
pageSyncResult
=
PageSync
(
Resource
(
aType
)
&
sync
.
mState
true
startOffset
endOffset
&
page
discard
)
;
if
(
pageSyncResult
=
=
PAGE_SYNC_ERROR
)
{
return
TimeIntervals
:
:
Invalid
(
)
;
}
else
if
(
pageSyncResult
=
=
PAGE_SYNC_END_OF_RANGE
)
{
break
;
}
int64_t
granulepos
=
ogg_page_granulepos
(
&
page
)
;
if
(
granulepos
=
=
-
1
)
{
startOffset
+
=
page
.
header_len
+
page
.
body_len
;
continue
;
}
uint32_t
serial
=
ogg_page_serialno
(
&
page
)
;
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
mVorbisState
&
&
serial
=
=
mVorbisState
-
>
mSerial
)
{
startTime
=
mVorbisState
-
>
Time
(
granulepos
)
;
NS_ASSERTION
(
startTime
>
0
"
Must
have
positive
start
time
"
)
;
}
else
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
mOpusState
&
&
serial
=
=
mOpusState
-
>
mSerial
)
{
startTime
=
mOpusState
-
>
Time
(
granulepos
)
;
NS_ASSERTION
(
startTime
>
0
"
Must
have
positive
start
time
"
)
;
}
else
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
mFlacState
&
&
serial
=
=
mFlacState
-
>
mSerial
)
{
startTime
=
mFlacState
-
>
Time
(
granulepos
)
;
NS_ASSERTION
(
startTime
>
0
"
Must
have
positive
start
time
"
)
;
}
else
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
mTheoraState
&
&
serial
=
=
mTheoraState
-
>
mSerial
)
{
startTime
=
mTheoraState
-
>
Time
(
granulepos
)
;
NS_ASSERTION
(
startTime
>
0
"
Must
have
positive
start
time
"
)
;
}
else
if
(
mCodecStore
.
Contains
(
serial
)
)
{
startOffset
+
=
page
.
header_len
+
page
.
body_len
;
continue
;
}
else
{
SetChained
(
)
;
return
buffered
;
}
}
if
(
startTime
!
=
-
1
)
{
int64_t
endTime
=
RangeEndTime
(
aType
startOffset
endOffset
true
)
;
if
(
endTime
>
startTime
)
{
buffered
+
=
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
startTime
-
StartTime
(
)
)
TimeUnit
:
:
FromMicroseconds
(
endTime
-
StartTime
(
)
)
)
;
}
}
}
return
buffered
;
}
void
OggDemuxer
:
:
FindStartTime
(
int64_t
&
aOutStartTime
)
{
int64_t
videoStartTime
=
INT64_MAX
;
int64_t
audioStartTime
=
INT64_MAX
;
if
(
HasVideo
(
)
)
{
FindStartTime
(
TrackInfo
:
:
kVideoTrack
videoStartTime
)
;
if
(
videoStartTime
!
=
INT64_MAX
)
{
OGG_DEBUG
(
"
OggDemuxer
:
:
FindStartTime
(
)
video
=
%
"
PRId64
videoStartTime
)
;
mVideoOggState
.
mStartTime
=
Some
(
TimeUnit
:
:
FromMicroseconds
(
videoStartTime
)
)
;
}
}
if
(
HasAudio
(
)
)
{
FindStartTime
(
TrackInfo
:
:
kAudioTrack
audioStartTime
)
;
if
(
audioStartTime
!
=
INT64_MAX
)
{
OGG_DEBUG
(
"
OggDemuxer
:
:
FindStartTime
(
)
audio
=
%
"
PRId64
audioStartTime
)
;
mAudioOggState
.
mStartTime
=
Some
(
TimeUnit
:
:
FromMicroseconds
(
audioStartTime
)
)
;
}
}
int64_t
startTime
=
std
:
:
min
(
videoStartTime
audioStartTime
)
;
if
(
startTime
!
=
INT64_MAX
)
{
aOutStartTime
=
startTime
;
}
}
void
OggDemuxer
:
:
FindStartTime
(
TrackInfo
:
:
TrackType
aType
int64_t
&
aOutStartTime
)
{
int64_t
startTime
=
INT64_MAX
;
OggCodecState
*
state
=
GetTrackCodecState
(
aType
)
;
ogg_packet
*
pkt
=
GetNextPacket
(
aType
)
;
if
(
pkt
)
{
startTime
=
state
-
>
PacketStartTime
(
pkt
)
;
}
if
(
startTime
!
=
INT64_MAX
)
{
aOutStartTime
=
startTime
;
}
}
nsresult
OggDemuxer
:
:
SeekInternal
(
TrackInfo
:
:
TrackType
aType
const
TimeUnit
&
aTarget
)
{
int64_t
target
=
aTarget
.
ToMicroseconds
(
)
;
OGG_DEBUG
(
"
About
to
seek
to
%
"
PRId64
target
)
;
nsresult
res
;
int64_t
adjustedTarget
=
target
;
int64_t
startTime
=
StartTime
(
aType
)
;
int64_t
endTime
=
mInfo
.
mMetadataDuration
-
>
ToMicroseconds
(
)
;
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
mOpusState
)
{
adjustedTarget
=
std
:
:
max
(
startTime
target
-
OGG_SEEK_OPUS_PREROLL
)
;
}
if
(
!
HaveStartTime
(
aType
)
|
|
adjustedTarget
=
=
startTime
)
{
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
0
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
res
=
Reset
(
aType
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
else
{
IndexedSeekResult
sres
=
SeekToKeyframeUsingIndex
(
aType
adjustedTarget
)
;
NS_ENSURE_TRUE
(
sres
!
=
SEEK_FATAL_ERROR
NS_ERROR_FAILURE
)
;
if
(
sres
=
=
SEEK_INDEX_FAIL
)
{
AutoTArray
<
SeekRange
16
>
ranges
;
res
=
GetSeekRanges
(
aType
ranges
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
SeekRange
r
=
SelectSeekRange
(
aType
ranges
target
startTime
endTime
true
)
;
if
(
!
r
.
IsNull
(
)
)
{
res
=
SeekInBufferedRange
(
aType
target
adjustedTarget
startTime
endTime
ranges
r
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
else
{
res
=
SeekInUnbuffered
(
aType
target
startTime
endTime
ranges
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
}
}
OggCodecState
*
state
=
GetTrackCodecState
(
aType
)
;
OggPacketQueue
tempPackets
;
bool
foundKeyframe
=
false
;
while
(
true
)
{
DemuxUntilPacketAvailable
(
aType
state
)
;
ogg_packet
*
packet
=
state
-
>
PacketPeek
(
)
;
if
(
packet
=
=
nullptr
)
{
OGG_DEBUG
(
"
End
of
stream
reached
before
keyframe
found
in
indexed
seek
"
)
;
break
;
}
int64_t
startTstamp
=
state
-
>
PacketStartTime
(
packet
)
;
if
(
foundKeyframe
&
&
startTstamp
>
adjustedTarget
)
{
break
;
}
if
(
state
-
>
IsKeyframe
(
packet
)
)
{
OGG_DEBUG
(
"
keyframe
found
after
seeking
at
%
"
PRId64
startTstamp
)
;
tempPackets
.
Erase
(
)
;
foundKeyframe
=
true
;
}
if
(
foundKeyframe
&
&
startTstamp
=
=
adjustedTarget
)
{
break
;
}
if
(
foundKeyframe
)
{
tempPackets
.
Append
(
state
-
>
PacketOut
(
)
)
;
}
else
{
Unused
<
<
state
-
>
PacketOut
(
)
;
}
}
state
-
>
PushFront
(
Move
(
tempPackets
)
)
;
return
NS_OK
;
}
OggDemuxer
:
:
IndexedSeekResult
OggDemuxer
:
:
RollbackIndexedSeek
(
TrackInfo
:
:
TrackType
aType
int64_t
aOffset
)
{
if
(
mSkeletonState
)
{
mSkeletonState
-
>
Deactivate
(
)
;
}
nsresult
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
aOffset
)
;
NS_ENSURE_SUCCESS
(
res
SEEK_FATAL_ERROR
)
;
return
SEEK_INDEX_FAIL
;
}
OggDemuxer
:
:
IndexedSeekResult
OggDemuxer
:
:
SeekToKeyframeUsingIndex
(
TrackInfo
:
:
TrackType
aType
int64_t
aTarget
)
{
if
(
!
HasSkeleton
(
)
|
|
!
mSkeletonState
-
>
HasIndex
(
)
)
{
return
SEEK_INDEX_FAIL
;
}
AutoTArray
<
uint32_t
2
>
tracks
;
BuildSerialList
(
tracks
)
;
SkeletonState
:
:
nsSeekTarget
keyframe
;
if
(
NS_FAILED
(
mSkeletonState
-
>
IndexedSeekTarget
(
aTarget
tracks
keyframe
)
)
)
{
return
SEEK_INDEX_FAIL
;
}
int64_t
tell
=
Resource
(
aType
)
-
>
Tell
(
)
;
if
(
keyframe
.
mKeyPoint
.
mOffset
>
Resource
(
aType
)
-
>
GetLength
(
)
|
|
keyframe
.
mKeyPoint
.
mOffset
<
0
)
{
return
RollbackIndexedSeek
(
aType
tell
)
;
}
OGG_DEBUG
(
"
Seeking
using
index
to
keyframe
at
offset
%
"
PRId64
"
\
n
"
keyframe
.
mKeyPoint
.
mOffset
)
;
nsresult
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
keyframe
.
mKeyPoint
.
mOffset
)
;
NS_ENSURE_SUCCESS
(
res
SEEK_FATAL_ERROR
)
;
res
=
Reset
(
aType
)
;
NS_ENSURE_SUCCESS
(
res
SEEK_FATAL_ERROR
)
;
ogg_page
page
;
int
skippedBytes
=
0
;
PageSyncResult
syncres
=
PageSync
(
Resource
(
aType
)
OggSyncState
(
aType
)
false
keyframe
.
mKeyPoint
.
mOffset
Resource
(
aType
)
-
>
GetLength
(
)
&
page
skippedBytes
)
;
NS_ENSURE_TRUE
(
syncres
!
=
PAGE_SYNC_ERROR
SEEK_FATAL_ERROR
)
;
if
(
syncres
!
=
PAGE_SYNC_OK
|
|
skippedBytes
!
=
0
)
{
OGG_DEBUG
(
"
Indexed
-
seek
failure
:
Ogg
Skeleton
Index
is
invalid
"
"
or
sync
error
after
seek
"
)
;
return
RollbackIndexedSeek
(
aType
tell
)
;
}
uint32_t
serial
=
ogg_page_serialno
(
&
page
)
;
if
(
serial
!
=
keyframe
.
mSerial
)
{
return
RollbackIndexedSeek
(
aType
tell
)
;
}
OggCodecState
*
codecState
=
mCodecStore
.
Get
(
serial
)
;
if
(
codecState
&
&
codecState
-
>
mActive
&
&
ogg_stream_pagein
(
&
codecState
-
>
mState
&
page
)
!
=
0
)
{
return
RollbackIndexedSeek
(
aType
tell
)
;
}
return
SEEK_OK
;
}
OggDemuxer
:
:
PageSyncResult
OggDemuxer
:
:
PageSync
(
MediaResourceIndex
*
aResource
ogg_sync_state
*
aState
bool
aCachedDataOnly
int64_t
aOffset
int64_t
aEndOffset
ogg_page
*
aPage
int
&
aSkippedBytes
)
{
aSkippedBytes
=
0
;
int
ret
=
0
;
uint32_t
bytesRead
=
0
;
int64_t
readHead
=
aOffset
;
while
(
ret
<
=
0
)
{
ret
=
ogg_sync_pageseek
(
aState
aPage
)
;
if
(
ret
=
=
0
)
{
char
*
buffer
=
ogg_sync_buffer
(
aState
PAGE_STEP
)
;
NS_ASSERTION
(
buffer
"
Must
have
a
buffer
"
)
;
int64_t
bytesToRead
=
std
:
:
min
(
static_cast
<
int64_t
>
(
PAGE_STEP
)
aEndOffset
-
readHead
)
;
NS_ASSERTION
(
bytesToRead
<
=
UINT32_MAX
"
bytesToRead
range
check
"
)
;
if
(
bytesToRead
<
=
0
)
{
return
PAGE_SYNC_END_OF_RANGE
;
}
nsresult
rv
=
NS_OK
;
if
(
aCachedDataOnly
)
{
rv
=
aResource
-
>
GetResource
(
)
-
>
ReadFromCache
(
buffer
readHead
static_cast
<
uint32_t
>
(
bytesToRead
)
)
;
NS_ENSURE_SUCCESS
(
rv
PAGE_SYNC_ERROR
)
;
bytesRead
=
static_cast
<
uint32_t
>
(
bytesToRead
)
;
}
else
{
rv
=
aResource
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
readHead
)
;
NS_ENSURE_SUCCESS
(
rv
PAGE_SYNC_ERROR
)
;
rv
=
aResource
-
>
Read
(
buffer
static_cast
<
uint32_t
>
(
bytesToRead
)
&
bytesRead
)
;
NS_ENSURE_SUCCESS
(
rv
PAGE_SYNC_ERROR
)
;
}
if
(
bytesRead
=
=
0
&
&
NS_SUCCEEDED
(
rv
)
)
{
return
PAGE_SYNC_END_OF_RANGE
;
}
readHead
+
=
bytesRead
;
ret
=
ogg_sync_wrote
(
aState
bytesRead
)
;
NS_ENSURE_TRUE
(
ret
=
=
0
PAGE_SYNC_ERROR
)
;
continue
;
}
if
(
ret
<
0
)
{
NS_ASSERTION
(
aSkippedBytes
>
=
0
"
Offset
>
=
0
"
)
;
aSkippedBytes
+
=
-
ret
;
NS_ASSERTION
(
aSkippedBytes
>
=
0
"
Offset
>
=
0
"
)
;
continue
;
}
}
return
PAGE_SYNC_OK
;
}
OggTrackDemuxer
:
:
OggTrackDemuxer
(
OggDemuxer
*
aParent
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
:
mParent
(
aParent
)
mType
(
aType
)
{
mInfo
=
mParent
-
>
GetTrackInfo
(
aType
aTrackNumber
)
;
MOZ_ASSERT
(
mInfo
)
;
}
OggTrackDemuxer
:
:
~
OggTrackDemuxer
(
)
{
}
UniquePtr
<
TrackInfo
>
OggTrackDemuxer
:
:
GetInfo
(
)
const
{
return
mInfo
-
>
Clone
(
)
;
}
RefPtr
<
OggTrackDemuxer
:
:
SeekPromise
>
OggTrackDemuxer
:
:
Seek
(
const
TimeUnit
&
aTime
)
{
mQueuedSample
=
nullptr
;
TimeUnit
seekTime
=
aTime
;
if
(
mParent
-
>
SeekInternal
(
mType
aTime
)
=
=
NS_OK
)
{
RefPtr
<
MediaRawData
>
sample
(
NextSample
(
)
)
;
if
(
sample
!
=
nullptr
)
{
seekTime
=
sample
-
>
mTime
;
OGG_DEBUG
(
"
%
p
seeked
to
time
%
"
PRId64
this
seekTime
.
ToMicroseconds
(
)
)
;
}
mQueuedSample
=
sample
;
return
SeekPromise
:
:
CreateAndResolve
(
seekTime
__func__
)
;
}
else
{
return
SeekPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_DEMUXER_ERR
__func__
)
;
}
}
RefPtr
<
MediaRawData
>
OggTrackDemuxer
:
:
NextSample
(
)
{
if
(
mQueuedSample
)
{
RefPtr
<
MediaRawData
>
nextSample
=
mQueuedSample
;
mQueuedSample
=
nullptr
;
if
(
mType
=
=
TrackInfo
:
:
kAudioTrack
)
{
nextSample
-
>
mTrackInfo
=
mParent
-
>
mSharedAudioTrackInfo
;
}
return
nextSample
;
}
ogg_packet
*
packet
=
mParent
-
>
GetNextPacket
(
mType
)
;
if
(
!
packet
)
{
return
nullptr
;
}
bool
eos
=
packet
-
>
e_o_s
;
OggCodecState
*
state
=
mParent
-
>
GetTrackCodecState
(
mType
)
;
RefPtr
<
MediaRawData
>
data
=
state
-
>
PacketOutAsMediaRawData
(
)
;
if
(
!
data
)
{
return
nullptr
;
}
if
(
mType
=
=
TrackInfo
:
:
kAudioTrack
)
{
data
-
>
mTrackInfo
=
mParent
-
>
mSharedAudioTrackInfo
;
}
data
-
>
mTime
+
=
mParent
-
>
mDecodedAudioDuration
;
if
(
eos
)
{
mParent
-
>
ReadOggChain
(
data
-
>
GetEndTime
(
)
)
;
}
return
data
;
}
RefPtr
<
OggTrackDemuxer
:
:
SamplesPromise
>
OggTrackDemuxer
:
:
GetSamples
(
int32_t
aNumSamples
)
{
RefPtr
<
SamplesHolder
>
samples
=
new
SamplesHolder
;
if
(
!
aNumSamples
)
{
return
SamplesPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_DEMUXER_ERR
__func__
)
;
}
while
(
aNumSamples
)
{
RefPtr
<
MediaRawData
>
sample
(
NextSample
(
)
)
;
if
(
!
sample
)
{
break
;
}
samples
-
>
mSamples
.
AppendElement
(
sample
)
;
aNumSamples
-
-
;
}
if
(
samples
-
>
mSamples
.
IsEmpty
(
)
)
{
return
SamplesPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_END_OF_STREAM
__func__
)
;
}
else
{
return
SamplesPromise
:
:
CreateAndResolve
(
samples
__func__
)
;
}
}
void
OggTrackDemuxer
:
:
Reset
(
)
{
mParent
-
>
Reset
(
mType
)
;
mQueuedSample
=
nullptr
;
}
RefPtr
<
OggTrackDemuxer
:
:
SkipAccessPointPromise
>
OggTrackDemuxer
:
:
SkipToNextRandomAccessPoint
(
const
TimeUnit
&
aTimeThreshold
)
{
uint32_t
parsed
=
0
;
bool
found
=
false
;
RefPtr
<
MediaRawData
>
sample
;
OGG_DEBUG
(
"
TimeThreshold
:
%
f
"
aTimeThreshold
.
ToSeconds
(
)
)
;
while
(
!
found
&
&
(
sample
=
NextSample
(
)
)
)
{
parsed
+
+
;
if
(
sample
-
>
mKeyframe
&
&
sample
-
>
mTime
>
=
aTimeThreshold
)
{
found
=
true
;
mQueuedSample
=
sample
;
}
}
if
(
found
)
{
OGG_DEBUG
(
"
next
sample
:
%
f
(
parsed
:
%
d
)
"
sample
-
>
mTime
.
ToSeconds
(
)
parsed
)
;
return
SkipAccessPointPromise
:
:
CreateAndResolve
(
parsed
__func__
)
;
}
else
{
SkipFailureHolder
failure
(
NS_ERROR_DOM_MEDIA_END_OF_STREAM
parsed
)
;
return
SkipAccessPointPromise
:
:
CreateAndReject
(
Move
(
failure
)
__func__
)
;
}
}
TimeIntervals
OggTrackDemuxer
:
:
GetBuffered
(
)
{
return
mParent
-
>
GetBuffered
(
mType
)
;
}
void
OggTrackDemuxer
:
:
BreakCycles
(
)
{
mParent
=
nullptr
;
}
ogg_uint32_t
OggDemuxer
:
:
GetPageChecksum
(
ogg_page
*
page
)
{
if
(
page
=
=
0
|
|
page
-
>
header
=
=
0
|
|
page
-
>
header_len
<
25
)
{
return
0
;
}
const
unsigned
char
*
p
=
page
-
>
header
+
22
;
uint32_t
c
=
p
[
0
]
+
(
p
[
1
]
<
<
8
)
+
(
p
[
2
]
<
<
16
)
+
(
p
[
3
]
<
<
24
)
;
return
c
;
}
int64_t
OggDemuxer
:
:
RangeStartTime
(
TrackInfo
:
:
TrackType
aType
int64_t
aOffset
)
{
int64_t
position
=
Resource
(
aType
)
-
>
Tell
(
)
;
nsresult
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
aOffset
)
;
NS_ENSURE_SUCCESS
(
res
0
)
;
int64_t
startTime
=
0
;
FindStartTime
(
aType
startTime
)
;
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
position
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
return
startTime
;
}
struct
nsDemuxerAutoOggSyncState
{
nsDemuxerAutoOggSyncState
(
)
{
ogg_sync_init
(
&
mState
)
;
}
~
nsDemuxerAutoOggSyncState
(
)
{
ogg_sync_clear
(
&
mState
)
;
}
ogg_sync_state
mState
;
}
;
int64_t
OggDemuxer
:
:
RangeEndTime
(
TrackInfo
:
:
TrackType
aType
int64_t
aEndOffset
)
{
int64_t
position
=
Resource
(
aType
)
-
>
Tell
(
)
;
int64_t
endTime
=
RangeEndTime
(
aType
0
aEndOffset
false
)
;
nsresult
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
position
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
return
endTime
;
}
int64_t
OggDemuxer
:
:
RangeEndTime
(
TrackInfo
:
:
TrackType
aType
int64_t
aStartOffset
int64_t
aEndOffset
bool
aCachedDataOnly
)
{
nsDemuxerAutoOggSyncState
sync
;
const
int
step
=
5000
;
const
int
maxOggPageSize
=
65306
;
int64_t
readStartOffset
=
aEndOffset
;
int64_t
readLimitOffset
=
aEndOffset
;
int64_t
readHead
=
aEndOffset
;
int64_t
endTime
=
-
1
;
uint32_t
checksumAfterSeek
=
0
;
uint32_t
prevChecksumAfterSeek
=
0
;
bool
mustBackOff
=
false
;
while
(
true
)
{
ogg_page
page
;
int
ret
=
ogg_sync_pageseek
(
&
sync
.
mState
&
page
)
;
if
(
ret
=
=
0
)
{
if
(
mustBackOff
|
|
readHead
=
=
aEndOffset
|
|
readHead
=
=
aStartOffset
)
{
if
(
endTime
!
=
-
1
|
|
readStartOffset
=
=
0
)
{
break
;
}
mustBackOff
=
false
;
prevChecksumAfterSeek
=
checksumAfterSeek
;
checksumAfterSeek
=
0
;
ogg_sync_reset
(
&
sync
.
mState
)
;
readStartOffset
=
std
:
:
max
(
static_cast
<
int64_t
>
(
0
)
readStartOffset
-
step
)
;
readLimitOffset
=
std
:
:
min
(
readLimitOffset
readStartOffset
+
maxOggPageSize
)
;
readHead
=
std
:
:
max
(
aStartOffset
readStartOffset
)
;
}
int64_t
limit
=
std
:
:
min
(
static_cast
<
int64_t
>
(
UINT32_MAX
)
aEndOffset
-
readHead
)
;
limit
=
std
:
:
max
(
static_cast
<
int64_t
>
(
0
)
limit
)
;
limit
=
std
:
:
min
(
limit
static_cast
<
int64_t
>
(
step
)
)
;
uint32_t
bytesToRead
=
static_cast
<
uint32_t
>
(
limit
)
;
uint32_t
bytesRead
=
0
;
char
*
buffer
=
ogg_sync_buffer
(
&
sync
.
mState
bytesToRead
)
;
NS_ASSERTION
(
buffer
"
Must
have
buffer
"
)
;
nsresult
res
;
if
(
aCachedDataOnly
)
{
res
=
Resource
(
aType
)
-
>
GetResource
(
)
-
>
ReadFromCache
(
buffer
readHead
bytesToRead
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
bytesRead
=
bytesToRead
;
}
else
{
NS_ASSERTION
(
readHead
<
aEndOffset
"
resource
pos
must
be
before
range
end
"
)
;
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
readHead
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
res
=
Resource
(
aType
)
-
>
Read
(
buffer
bytesToRead
&
bytesRead
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
}
readHead
+
=
bytesRead
;
if
(
readHead
>
readLimitOffset
)
{
mustBackOff
=
true
;
}
ret
=
ogg_sync_wrote
(
&
sync
.
mState
bytesRead
)
;
if
(
ret
!
=
0
)
{
endTime
=
-
1
;
break
;
}
continue
;
}
if
(
ret
<
0
|
|
ogg_page_granulepos
(
&
page
)
<
0
)
{
continue
;
}
uint32_t
checksum
=
GetPageChecksum
(
&
page
)
;
if
(
checksumAfterSeek
=
=
0
)
{
checksumAfterSeek
=
checksum
;
}
if
(
checksum
=
=
prevChecksumAfterSeek
)
{
mustBackOff
=
true
;
continue
;
}
int64_t
granulepos
=
ogg_page_granulepos
(
&
page
)
;
int
serial
=
ogg_page_serialno
(
&
page
)
;
OggCodecState
*
codecState
=
nullptr
;
codecState
=
mCodecStore
.
Get
(
serial
)
;
if
(
!
codecState
)
{
SetChained
(
)
;
endTime
=
-
1
;
break
;
}
int64_t
t
=
codecState
-
>
Time
(
granulepos
)
;
if
(
t
!
=
-
1
)
{
endTime
=
t
;
}
}
return
endTime
;
}
nsresult
OggDemuxer
:
:
GetSeekRanges
(
TrackInfo
:
:
TrackType
aType
nsTArray
<
SeekRange
>
&
aRanges
)
{
AutoPinned
<
MediaResource
>
resource
(
Resource
(
aType
)
-
>
GetResource
(
)
)
;
MediaByteRangeSet
cached
;
nsresult
res
=
resource
-
>
GetCachedRanges
(
cached
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
for
(
uint32_t
index
=
0
;
index
<
cached
.
Length
(
)
;
index
+
+
)
{
auto
&
range
=
cached
[
index
]
;
int64_t
startTime
=
-
1
;
int64_t
endTime
=
-
1
;
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
int64_t
startOffset
=
range
.
mStart
;
int64_t
endOffset
=
range
.
mEnd
;
startTime
=
RangeStartTime
(
aType
startOffset
)
;
if
(
startTime
!
=
-
1
&
&
(
(
endTime
=
RangeEndTime
(
aType
endOffset
)
)
!
=
-
1
)
)
{
NS_WARNING_ASSERTION
(
startTime
<
endTime
"
Start
time
must
be
before
end
time
"
)
;
aRanges
.
AppendElement
(
SeekRange
(
startOffset
endOffset
startTime
endTime
)
)
;
}
}
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
OggDemuxer
:
:
SeekRange
OggDemuxer
:
:
SelectSeekRange
(
TrackInfo
:
:
TrackType
aType
const
nsTArray
<
SeekRange
>
&
ranges
int64_t
aTarget
int64_t
aStartTime
int64_t
aEndTime
bool
aExact
)
{
int64_t
so
=
0
;
int64_t
eo
=
Resource
(
aType
)
-
>
GetLength
(
)
;
int64_t
st
=
aStartTime
;
int64_t
et
=
aEndTime
;
for
(
uint32_t
i
=
0
;
i
<
ranges
.
Length
(
)
;
i
+
+
)
{
const
SeekRange
&
r
=
ranges
[
i
]
;
if
(
r
.
mTimeStart
<
aTarget
)
{
so
=
r
.
mOffsetStart
;
st
=
r
.
mTimeStart
;
}
if
(
r
.
mTimeEnd
>
=
aTarget
&
&
r
.
mTimeEnd
<
et
)
{
eo
=
r
.
mOffsetEnd
;
et
=
r
.
mTimeEnd
;
}
if
(
r
.
mTimeStart
<
aTarget
&
&
aTarget
<
=
r
.
mTimeEnd
)
{
return
ranges
[
i
]
;
}
}
if
(
aExact
|
|
eo
=
=
-
1
)
{
return
SeekRange
(
)
;
}
return
SeekRange
(
so
eo
st
et
)
;
}
nsresult
OggDemuxer
:
:
SeekInBufferedRange
(
TrackInfo
:
:
TrackType
aType
int64_t
aTarget
int64_t
aAdjustedTarget
int64_t
aStartTime
int64_t
aEndTime
const
nsTArray
<
SeekRange
>
&
aRanges
const
SeekRange
&
aRange
)
{
OGG_DEBUG
(
"
Seeking
in
buffered
data
to
%
"
PRId64
"
using
bisection
search
"
aTarget
)
;
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
|
|
aAdjustedTarget
>
=
aTarget
)
{
nsresult
res
=
SeekBisection
(
aType
aTarget
aRange
0
)
;
if
(
NS_FAILED
(
res
)
|
|
aType
!
=
TrackInfo
:
:
kVideoTrack
)
{
return
res
;
}
DemuxUntilPacketAvailable
(
aType
mTheoraState
)
;
ogg_packet
*
packet
=
mTheoraState
-
>
PacketPeek
(
)
;
if
(
packet
&
&
!
mTheoraState
-
>
IsKeyframe
(
packet
)
)
{
NS_ASSERTION
(
packet
-
>
granulepos
!
=
-
1
"
Must
have
a
granulepos
"
)
;
int
shift
=
mTheoraState
-
>
KeyFrameGranuleJobs
(
)
;
int64_t
keyframeGranulepos
=
(
packet
-
>
granulepos
>
>
shift
)
<
<
shift
;
int64_t
keyframeTime
=
mTheoraState
-
>
StartTime
(
keyframeGranulepos
)
;
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Keyframe
for
%
lld
is
at
%
lld
seeking
back
to
it
"
frameTime
keyframeTime
)
)
;
aAdjustedTarget
=
std
:
:
min
(
aAdjustedTarget
keyframeTime
)
;
}
}
nsresult
res
=
NS_OK
;
if
(
aAdjustedTarget
<
aTarget
)
{
SeekRange
k
=
SelectSeekRange
(
aType
aRanges
aAdjustedTarget
aStartTime
aEndTime
false
)
;
res
=
SeekBisection
(
aType
aAdjustedTarget
k
OGG_SEEK_FUZZ_USECS
)
;
}
return
res
;
}
nsresult
OggDemuxer
:
:
SeekInUnbuffered
(
TrackInfo
:
:
TrackType
aType
int64_t
aTarget
int64_t
aStartTime
int64_t
aEndTime
const
nsTArray
<
SeekRange
>
&
aRanges
)
{
OGG_DEBUG
(
"
Seeking
in
unbuffered
data
to
%
"
PRId64
"
using
bisection
search
"
aTarget
)
;
int64_t
keyframeOffsetMs
=
0
;
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
mTheoraState
)
{
keyframeOffsetMs
=
mTheoraState
-
>
MaxKeyframeOffset
(
)
;
}
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
mOpusState
)
{
keyframeOffsetMs
=
std
:
:
max
(
keyframeOffsetMs
OGG_SEEK_OPUS_PREROLL
)
;
}
int64_t
seekTarget
=
std
:
:
max
(
aStartTime
aTarget
-
keyframeOffsetMs
)
;
SeekRange
k
=
SelectSeekRange
(
aType
aRanges
seekTarget
aStartTime
aEndTime
false
)
;
return
SeekBisection
(
aType
seekTarget
k
OGG_SEEK_FUZZ_USECS
)
;
}
nsresult
OggDemuxer
:
:
SeekBisection
(
TrackInfo
:
:
TrackType
aType
int64_t
aTarget
const
SeekRange
&
aRange
uint32_t
aFuzz
)
{
nsresult
res
;
if
(
aTarget
<
=
aRange
.
mTimeStart
)
{
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
0
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
return
NS_OK
;
}
ogg_int64_t
startOffset
=
aRange
.
mOffsetStart
;
ogg_int64_t
startTime
=
aRange
.
mTimeStart
;
ogg_int64_t
startLength
=
0
;
ogg_int64_t
endOffset
=
aRange
.
mOffsetEnd
;
ogg_int64_t
endTime
=
aRange
.
mTimeEnd
;
ogg_int64_t
seekTarget
=
aTarget
;
int64_t
seekLowerBound
=
std
:
:
max
(
static_cast
<
int64_t
>
(
0
)
aTarget
-
aFuzz
)
;
int
hops
=
0
;
DebugOnly
<
ogg_int64_t
>
previousGuess
=
-
1
;
int
backsteps
=
0
;
const
int
maxBackStep
=
10
;
NS_ASSERTION
(
static_cast
<
uint64_t
>
(
PAGE_STEP
)
*
pow
(
2
.
0
maxBackStep
)
<
INT32_MAX
"
Backstep
calculation
must
not
overflow
"
)
;
while
(
true
)
{
ogg_int64_t
duration
=
0
;
double
target
=
0
;
ogg_int64_t
interval
=
0
;
ogg_int64_t
guess
=
0
;
ogg_page
page
;
int
skippedBytes
=
0
;
ogg_int64_t
pageOffset
=
0
;
ogg_int64_t
pageLength
=
0
;
ogg_int64_t
granuleTime
=
-
1
;
bool
mustBackoff
=
false
;
while
(
true
)
{
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
interval
=
endOffset
-
startOffset
-
startLength
;
if
(
interval
=
=
0
)
{
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Interval
narrowed
terminating
bisection
.
"
)
)
;
break
;
}
duration
=
endTime
-
startTime
;
target
=
(
double
)
(
seekTarget
-
startTime
)
/
(
double
)
duration
;
guess
=
startOffset
+
startLength
+
static_cast
<
ogg_int64_t
>
(
(
double
)
interval
*
target
)
;
guess
=
std
:
:
min
(
guess
endOffset
-
PAGE_STEP
)
;
if
(
mustBackoff
)
{
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Backing
off
%
d
bytes
backsteps
=
%
d
"
static_cast
<
int32_t
>
(
PAGE_STEP
*
pow
(
2
.
0
backsteps
)
)
backsteps
)
)
;
guess
-
=
PAGE_STEP
*
static_cast
<
ogg_int64_t
>
(
pow
(
2
.
0
backsteps
)
)
;
if
(
guess
<
=
startOffset
)
{
interval
=
0
;
break
;
}
backsteps
=
std
:
:
min
(
backsteps
+
1
maxBackStep
)
;
mustBackoff
=
false
;
}
else
{
backsteps
=
0
;
}
guess
=
std
:
:
max
(
guess
startOffset
+
startLength
)
;
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Seek
loop
start
[
o
=
%
lld
.
.
%
lld
t
=
%
lld
]
"
"
end
[
o
=
%
lld
t
=
%
lld
]
"
"
interval
=
%
lld
target
=
%
lf
guess
=
%
lld
"
startOffset
(
startOffset
+
startLength
)
startTime
endOffset
endTime
interval
target
guess
)
)
;
NS_ASSERTION
(
guess
>
=
startOffset
+
startLength
"
Guess
must
be
after
range
start
"
)
;
NS_ASSERTION
(
guess
<
endOffset
"
Guess
must
be
before
range
end
"
)
;
NS_ASSERTION
(
guess
!
=
previousGuess
"
Guess
should
be
different
to
previous
"
)
;
previousGuess
=
guess
;
hops
+
+
;
PageSyncResult
pageSyncResult
=
PageSync
(
Resource
(
aType
)
OggSyncState
(
aType
)
false
guess
endOffset
&
page
skippedBytes
)
;
NS_ENSURE_TRUE
(
pageSyncResult
!
=
PAGE_SYNC_ERROR
NS_ERROR_FAILURE
)
;
if
(
pageSyncResult
=
=
PAGE_SYNC_END_OF_RANGE
)
{
mustBackoff
=
true
;
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Hit
the
end
of
range
backing
off
"
)
)
;
continue
;
}
pageOffset
=
guess
+
skippedBytes
;
pageLength
=
page
.
header_len
+
page
.
body_len
;
ogg_int64_t
audioTime
=
-
1
;
ogg_int64_t
videoTime
=
-
1
;
do
{
uint32_t
serial
=
ogg_page_serialno
(
&
page
)
;
OggCodecState
*
codecState
=
mCodecStore
.
Get
(
serial
)
;
if
(
codecState
&
&
GetCodecStateType
(
codecState
)
=
=
aType
)
{
if
(
codecState
-
>
mActive
)
{
int
ret
=
ogg_stream_pagein
(
&
codecState
-
>
mState
&
page
)
;
NS_ENSURE_TRUE
(
ret
=
=
0
NS_ERROR_FAILURE
)
;
}
ogg_int64_t
granulepos
=
ogg_page_granulepos
(
&
page
)
;
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
granulepos
>
0
&
&
audioTime
=
=
-
1
)
{
if
(
mVorbisState
&
&
serial
=
=
mVorbisState
-
>
mSerial
)
{
audioTime
=
mVorbisState
-
>
Time
(
granulepos
)
;
}
else
if
(
mOpusState
&
&
serial
=
=
mOpusState
-
>
mSerial
)
{
audioTime
=
mOpusState
-
>
Time
(
granulepos
)
;
}
else
if
(
mFlacState
&
&
serial
=
=
mFlacState
-
>
mSerial
)
{
audioTime
=
mFlacState
-
>
Time
(
granulepos
)
;
}
}
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
granulepos
>
0
&
&
serial
=
=
mTheoraState
-
>
mSerial
&
&
videoTime
=
=
-
1
)
{
videoTime
=
mTheoraState
-
>
Time
(
granulepos
)
;
}
if
(
pageOffset
+
pageLength
>
=
endOffset
)
{
break
;
}
}
if
(
!
ReadOggPage
(
aType
&
page
)
)
{
break
;
}
}
while
(
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
audioTime
=
=
-
1
)
|
|
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
videoTime
=
=
-
1
)
)
;
if
(
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
audioTime
=
=
-
1
)
|
|
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
videoTime
=
=
-
1
)
)
{
if
(
pageOffset
=
=
startOffset
+
startLength
&
&
pageOffset
+
pageLength
>
=
endOffset
)
{
interval
=
0
;
break
;
}
mustBackoff
=
true
;
continue
;
}
granuleTime
=
aType
=
=
TrackInfo
:
:
kAudioTrack
?
audioTime
:
videoTime
;
NS_ASSERTION
(
granuleTime
>
0
"
Must
get
a
granuletime
"
)
;
break
;
}
if
(
interval
=
=
0
)
{
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Terminating
seek
at
offset
=
%
lld
"
startOffset
)
)
;
NS_ASSERTION
(
startTime
<
aTarget
"
Start
time
must
always
be
less
than
target
"
)
;
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
startOffset
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
break
;
}
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Time
at
offset
%
lld
is
%
lld
"
guess
granuleTime
)
)
;
if
(
granuleTime
<
seekTarget
&
&
granuleTime
>
seekLowerBound
)
{
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
pageOffset
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Terminating
seek
at
offset
=
%
lld
"
pageOffset
)
)
;
break
;
}
if
(
granuleTime
>
=
seekTarget
)
{
NS_ASSERTION
(
pageOffset
<
endOffset
"
offset_end
must
decrease
"
)
;
endOffset
=
pageOffset
;
endTime
=
granuleTime
;
}
else
if
(
granuleTime
<
seekTarget
)
{
NS_ASSERTION
(
pageOffset
>
=
startOffset
+
startLength
"
Bisection
point
should
be
at
or
after
end
of
first
page
in
interval
"
)
;
startOffset
=
pageOffset
;
startLength
=
pageLength
;
startTime
=
granuleTime
;
}
NS_ASSERTION
(
startTime
<
=
seekTarget
"
Must
be
before
seek
target
"
)
;
NS_ASSERTION
(
endTime
>
=
seekTarget
"
End
must
be
after
seek
target
"
)
;
}
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Seek
complete
in
%
d
bisections
.
"
hops
)
)
;
return
NS_OK
;
}
#
undef
OGG_DEBUG
#
undef
SEEK_DEBUG
}
