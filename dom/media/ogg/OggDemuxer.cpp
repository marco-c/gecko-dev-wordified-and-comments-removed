#
include
"
nsError
.
h
"
#
include
"
MediaDecoderStateMachine
.
h
"
#
include
"
AbstractMediaDecoder
.
h
"
#
include
"
OggDemuxer
.
h
"
#
include
"
OggCodecState
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
MediaDataDemuxer
.
h
"
#
include
"
nsAutoRef
.
h
"
#
include
"
XiphExtradata
.
h
"
#
include
<
algorithm
>
extern
mozilla
:
:
LazyLogModule
gMediaDemuxerLog
;
#
define
OGG_DEBUG
(
arg
.
.
.
)
MOZ_LOG
(
gMediaDemuxerLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
OggDemuxer
(
%
p
)
:
:
%
s
:
"
arg
this
__func__
#
#
__VA_ARGS__
)
)
#
ifdef
SEEK_LOGGING
#
define
SEEK_LOG
(
type
msg
)
MOZ_LOG
(
gMediaDemuxerLog
type
msg
)
#
else
#
define
SEEK_LOG
(
type
msg
)
#
endif
namespace
mozilla
{
using
media
:
:
TimeUnit
;
using
media
:
:
TimeInterval
;
using
media
:
:
TimeIntervals
;
static
const
uint32_t
OGG_SEEK_FUZZ_USECS
=
500000
;
static
const
int64_t
OGG_SEEK_OPUS_PREROLL
=
80
*
USECS_PER_MS
;
class
OggHeaders
{
public
:
OggHeaders
(
)
{
}
~
OggHeaders
(
)
{
for
(
size_t
i
=
0
;
i
<
mHeaders
.
Length
(
)
;
i
+
+
)
{
delete
[
]
mHeaders
[
i
]
;
}
}
void
AppendPacket
(
const
ogg_packet
*
aPacket
)
{
size_t
packetSize
=
aPacket
-
>
bytes
;
unsigned
char
*
packetData
=
new
unsigned
char
[
packetSize
]
;
memcpy
(
packetData
aPacket
-
>
packet
packetSize
)
;
mHeaders
.
AppendElement
(
packetData
)
;
mHeaderLens
.
AppendElement
(
packetSize
)
;
}
nsTArray
<
const
unsigned
char
*
>
mHeaders
;
nsTArray
<
size_t
>
mHeaderLens
;
}
;
const
nsString
OggDemuxer
:
:
GetKind
(
const
nsCString
&
aRole
)
{
if
(
aRole
.
Find
(
"
audio
/
main
"
)
!
=
-
1
|
|
aRole
.
Find
(
"
video
/
main
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
main
"
)
;
}
else
if
(
aRole
.
Find
(
"
audio
/
alternate
"
)
!
=
-
1
|
|
aRole
.
Find
(
"
video
/
alternate
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
alternative
"
)
;
}
else
if
(
aRole
.
Find
(
"
audio
/
audiodesc
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
descriptions
"
)
;
}
else
if
(
aRole
.
Find
(
"
audio
/
described
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
main
-
desc
"
)
;
}
else
if
(
aRole
.
Find
(
"
audio
/
dub
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
translation
"
)
;
}
else
if
(
aRole
.
Find
(
"
audio
/
commentary
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
commentary
"
)
;
}
else
if
(
aRole
.
Find
(
"
video
/
sign
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
sign
"
)
;
}
else
if
(
aRole
.
Find
(
"
video
/
captioned
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
captions
"
)
;
}
else
if
(
aRole
.
Find
(
"
video
/
subtitled
"
)
!
=
-
1
)
{
return
NS_LITERAL_STRING
(
"
subtitles
"
)
;
}
return
EmptyString
(
)
;
}
void
OggDemuxer
:
:
InitTrack
(
MessageField
*
aMsgInfo
TrackInfo
*
aInfo
bool
aEnable
)
{
MOZ_ASSERT
(
aMsgInfo
)
;
MOZ_ASSERT
(
aInfo
)
;
nsCString
*
sName
=
aMsgInfo
-
>
mValuesStore
.
Get
(
eName
)
;
nsCString
*
sRole
=
aMsgInfo
-
>
mValuesStore
.
Get
(
eRole
)
;
nsCString
*
sTitle
=
aMsgInfo
-
>
mValuesStore
.
Get
(
eTitle
)
;
nsCString
*
sLanguage
=
aMsgInfo
-
>
mValuesStore
.
Get
(
eLanguage
)
;
aInfo
-
>
Init
(
sName
?
NS_ConvertUTF8toUTF16
(
*
sName
)
:
EmptyString
(
)
sRole
?
GetKind
(
*
sRole
)
:
EmptyString
(
)
sTitle
?
NS_ConvertUTF8toUTF16
(
*
sTitle
)
:
EmptyString
(
)
sLanguage
?
NS_ConvertUTF8toUTF16
(
*
sLanguage
)
:
EmptyString
(
)
aEnable
)
;
}
OggDemuxer
:
:
OggDemuxer
(
MediaResource
*
aResource
)
:
mTheoraState
(
nullptr
)
mVorbisState
(
nullptr
)
mOpusState
(
nullptr
)
mOpusEnabled
(
MediaDecoder
:
:
IsOpusEnabled
(
)
)
mSkeletonState
(
nullptr
)
mAudioOggState
(
aResource
)
mVideoOggState
(
aResource
)
mVorbisSerial
(
0
)
mOpusSerial
(
0
)
mTheoraSerial
(
0
)
mOpusPreSkip
(
0
)
mIsChained
(
false
)
mDecodedAudioFrames
(
0
)
{
MOZ_COUNT_CTOR
(
OggDemuxer
)
;
PodZero
(
&
mTheoraInfo
)
;
}
OggDemuxer
:
:
~
OggDemuxer
(
)
{
MOZ_COUNT_DTOR
(
OggDemuxer
)
;
Reset
(
TrackInfo
:
:
kAudioTrack
)
;
Reset
(
TrackInfo
:
:
kVideoTrack
)
;
if
(
HasAudio
(
)
|
|
HasVideo
(
)
)
{
bool
isChained
=
mIsChained
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
[
=
]
(
)
-
>
void
{
OGG_DEBUG
(
"
Reporting
telemetry
MEDIA_OGG_LOADED_IS_CHAINED
=
%
d
"
isChained
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
ID
:
:
MEDIA_OGG_LOADED_IS_CHAINED
isChained
)
;
}
)
;
AbstractThread
:
:
MainThread
(
)
-
>
Dispatch
(
task
.
forget
(
)
)
;
}
}
bool
OggDemuxer
:
:
HasAudio
(
)
const
{
return
mVorbisState
|
|
mOpusState
;
}
bool
OggDemuxer
:
:
HasVideo
(
)
const
{
return
mTheoraState
;
}
bool
OggDemuxer
:
:
HaveStartTime
(
)
const
{
return
mStartTime
.
isSome
(
)
;
}
int64_t
OggDemuxer
:
:
StartTime
(
)
const
{
MOZ_ASSERT
(
HaveStartTime
(
)
)
;
return
mStartTime
.
ref
(
)
;
}
bool
OggDemuxer
:
:
HaveStartTime
(
TrackInfo
:
:
TrackType
aType
)
{
return
(
aType
=
=
TrackInfo
:
:
kAudioTrack
?
mAudioOggState
:
mVideoOggState
)
.
mStartTime
.
isSome
(
)
;
}
int64_t
OggDemuxer
:
:
StartTime
(
TrackInfo
:
:
TrackType
aType
)
{
return
(
aType
=
=
TrackInfo
:
:
kAudioTrack
?
mAudioOggState
:
mVideoOggState
)
.
mStartTime
.
refOr
(
TimeUnit
:
:
FromMicroseconds
(
0
)
)
.
ToMicroseconds
(
)
;
}
RefPtr
<
OggDemuxer
:
:
InitPromise
>
OggDemuxer
:
:
Init
(
)
{
int
ret
=
ogg_sync_init
(
OggState
(
TrackInfo
:
:
kAudioTrack
)
)
;
if
(
ret
!
=
0
)
{
return
InitPromise
:
:
CreateAndReject
(
DemuxerFailureReason
:
:
DEMUXER_ERROR
__func__
)
;
}
ret
=
ogg_sync_init
(
OggState
(
TrackInfo
:
:
kVideoTrack
)
)
;
if
(
ret
!
=
0
)
{
return
InitPromise
:
:
CreateAndReject
(
DemuxerFailureReason
:
:
DEMUXER_ERROR
__func__
)
;
}
if
(
ReadMetadata
(
)
!
=
NS_OK
)
{
return
InitPromise
:
:
CreateAndReject
(
DemuxerFailureReason
:
:
DEMUXER_ERROR
__func__
)
;
}
if
(
!
GetNumberTracks
(
TrackInfo
:
:
kAudioTrack
)
&
&
!
GetNumberTracks
(
TrackInfo
:
:
kVideoTrack
)
)
{
return
InitPromise
:
:
CreateAndReject
(
DemuxerFailureReason
:
:
DEMUXER_ERROR
__func__
)
;
}
return
InitPromise
:
:
CreateAndResolve
(
NS_OK
__func__
)
;
}
bool
OggDemuxer
:
:
HasTrackType
(
TrackInfo
:
:
TrackType
aType
)
const
{
return
!
!
GetNumberTracks
(
aType
)
;
}
OggCodecState
*
OggDemuxer
:
:
GetTrackCodecState
(
TrackInfo
:
:
TrackType
aType
)
const
{
switch
(
aType
)
{
case
TrackInfo
:
:
kAudioTrack
:
if
(
mVorbisState
)
{
return
mVorbisState
;
}
else
{
return
mOpusState
;
}
case
TrackInfo
:
:
kVideoTrack
:
return
mTheoraState
;
default
:
return
0
;
}
}
TrackInfo
:
:
TrackType
OggDemuxer
:
:
GetCodecStateType
(
OggCodecState
*
aState
)
const
{
switch
(
aState
-
>
GetType
(
)
)
{
case
OggCodecState
:
:
TYPE_THEORA
:
return
TrackInfo
:
:
kVideoTrack
;
case
OggCodecState
:
:
TYPE_OPUS
:
case
OggCodecState
:
:
TYPE_VORBIS
:
return
TrackInfo
:
:
kAudioTrack
;
default
:
return
TrackInfo
:
:
kUndefinedTrack
;
}
}
uint32_t
OggDemuxer
:
:
GetNumberTracks
(
TrackInfo
:
:
TrackType
aType
)
const
{
switch
(
aType
)
{
case
TrackInfo
:
:
kAudioTrack
:
return
HasAudio
(
)
?
1
:
0
;
case
TrackInfo
:
:
kVideoTrack
:
return
HasVideo
(
)
?
1
:
0
;
default
:
return
0
;
}
}
UniquePtr
<
TrackInfo
>
OggDemuxer
:
:
GetTrackInfo
(
TrackInfo
:
:
TrackType
aType
size_t
aTrackNumber
)
const
{
switch
(
aType
)
{
case
TrackInfo
:
:
kAudioTrack
:
return
mInfo
.
mAudio
.
Clone
(
)
;
case
TrackInfo
:
:
kVideoTrack
:
return
mInfo
.
mVideo
.
Clone
(
)
;
default
:
return
nullptr
;
}
}
already_AddRefed
<
MediaTrackDemuxer
>
OggDemuxer
:
:
GetTrackDemuxer
(
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
{
if
(
GetNumberTracks
(
aType
)
<
=
aTrackNumber
)
{
return
nullptr
;
}
RefPtr
<
OggTrackDemuxer
>
e
=
new
OggTrackDemuxer
(
this
aType
aTrackNumber
)
;
mDemuxers
.
AppendElement
(
e
)
;
return
e
.
forget
(
)
;
}
nsresult
OggDemuxer
:
:
Reset
(
TrackInfo
:
:
TrackType
aType
)
{
ogg_sync_reset
(
OggState
(
aType
)
)
;
OggCodecState
*
trackState
=
GetTrackCodecState
(
aType
)
;
if
(
trackState
)
{
return
trackState
-
>
Reset
(
)
;
}
return
NS_OK
;
}
bool
OggDemuxer
:
:
ReadHeaders
(
TrackInfo
:
:
TrackType
aType
OggCodecState
*
aState
OggHeaders
&
aHeaders
)
{
while
(
!
aState
-
>
DoneReadingHeaders
(
)
)
{
DemuxUntilPacketAvailable
(
aType
aState
)
;
ogg_packet
*
packet
=
aState
-
>
PacketOut
(
)
;
if
(
!
packet
)
{
OGG_DEBUG
(
"
Ran
out
of
header
packets
early
;
deactivating
stream
%
ld
"
aState
-
>
mSerial
)
;
aState
-
>
Deactivate
(
)
;
return
false
;
}
aHeaders
.
AppendPacket
(
packet
)
;
if
(
!
aState
-
>
DecodeHeader
(
packet
)
)
{
OGG_DEBUG
(
"
Failed
to
decode
ogg
header
packet
;
deactivating
stream
%
ld
"
aState
-
>
mSerial
)
;
aState
-
>
Deactivate
(
)
;
return
false
;
}
}
return
aState
-
>
Init
(
)
;
}
void
OggDemuxer
:
:
BuildSerialList
(
nsTArray
<
uint32_t
>
&
aTracks
)
{
if
(
HasVideo
(
)
)
{
aTracks
.
AppendElement
(
mTheoraState
-
>
mSerial
)
;
}
if
(
HasAudio
(
)
)
{
if
(
mVorbisState
)
{
aTracks
.
AppendElement
(
mVorbisState
-
>
mSerial
)
;
}
else
if
(
mOpusState
)
{
aTracks
.
AppendElement
(
mOpusState
-
>
mSerial
)
;
}
}
}
void
OggDemuxer
:
:
SetupTargetTheora
(
TheoraState
*
aTheoraState
OggHeaders
&
aHeaders
)
{
if
(
mTheoraState
)
{
mTheoraState
-
>
Reset
(
)
;
}
nsIntRect
picture
=
nsIntRect
(
aTheoraState
-
>
mInfo
.
pic_x
aTheoraState
-
>
mInfo
.
pic_y
aTheoraState
-
>
mInfo
.
pic_width
aTheoraState
-
>
mInfo
.
pic_height
)
;
nsIntSize
displaySize
=
nsIntSize
(
aTheoraState
-
>
mInfo
.
pic_width
aTheoraState
-
>
mInfo
.
pic_height
)
;
ScaleDisplayByAspectRatio
(
displaySize
aTheoraState
-
>
mPixelAspectRatio
)
;
nsIntSize
frameSize
(
aTheoraState
-
>
mInfo
.
frame_width
aTheoraState
-
>
mInfo
.
frame_height
)
;
if
(
IsValidVideoRegion
(
frameSize
picture
displaySize
)
)
{
mInfo
.
mVideo
.
mMimeType
=
"
video
/
ogg
;
codecs
=
theora
"
;
mInfo
.
mVideo
.
mDisplay
=
displaySize
;
mInfo
.
mVideo
.
mImage
=
frameSize
;
mInfo
.
mVideo
.
SetImageRect
(
picture
)
;
memcpy
(
&
mTheoraInfo
&
aTheoraState
-
>
mInfo
sizeof
(
mTheoraInfo
)
)
;
if
(
!
XiphHeadersToExtradata
(
mInfo
.
mVideo
.
mCodecSpecificConfig
aHeaders
.
mHeaders
aHeaders
.
mHeaderLens
)
)
{
return
;
}
mTheoraState
=
aTheoraState
;
mTheoraSerial
=
aTheoraState
-
>
mSerial
;
}
}
void
OggDemuxer
:
:
SetupTargetVorbis
(
VorbisState
*
aVorbisState
OggHeaders
&
aHeaders
)
{
if
(
mVorbisState
)
{
mVorbisState
-
>
Reset
(
)
;
}
memcpy
(
&
mVorbisInfo
&
aVorbisState
-
>
mInfo
sizeof
(
mVorbisInfo
)
)
;
mVorbisInfo
.
codec_setup
=
nullptr
;
mInfo
.
mAudio
.
mMimeType
=
"
audio
/
ogg
;
codecs
=
vorbis
"
;
mInfo
.
mAudio
.
mRate
=
aVorbisState
-
>
mInfo
.
rate
;
mInfo
.
mAudio
.
mChannels
=
aVorbisState
-
>
mInfo
.
channels
;
if
(
!
XiphHeadersToExtradata
(
mInfo
.
mAudio
.
mCodecSpecificConfig
aHeaders
.
mHeaders
aHeaders
.
mHeaderLens
)
)
{
return
;
}
mVorbisState
=
aVorbisState
;
mVorbisSerial
=
aVorbisState
-
>
mSerial
;
}
void
OggDemuxer
:
:
SetupTargetOpus
(
OpusState
*
aOpusState
OggHeaders
&
aHeaders
)
{
if
(
mOpusState
)
{
mOpusState
-
>
Reset
(
)
;
}
mInfo
.
mAudio
.
mMimeType
=
"
audio
/
ogg
;
codecs
=
opus
"
;
mInfo
.
mAudio
.
mRate
=
aOpusState
-
>
mRate
;
mInfo
.
mAudio
.
mChannels
=
aOpusState
-
>
mChannels
;
uint64_t
preSkip
=
aOpusState
-
>
Time
(
0
aOpusState
-
>
mPreSkip
)
;
uint8_t
c
[
sizeof
(
preSkip
)
]
;
BigEndian
:
:
writeUint64
(
&
c
[
0
]
preSkip
)
;
mInfo
.
mAudio
.
mCodecSpecificConfig
-
>
AppendElements
(
&
c
[
0
]
sizeof
(
preSkip
)
)
;
mInfo
.
mAudio
.
mCodecSpecificConfig
-
>
AppendElements
(
aHeaders
.
mHeaders
[
0
]
aHeaders
.
mHeaderLens
[
0
]
)
;
mOpusState
=
aOpusState
;
mOpusSerial
=
aOpusState
-
>
mSerial
;
mOpusPreSkip
=
aOpusState
-
>
mPreSkip
;
}
void
OggDemuxer
:
:
SetupTargetSkeleton
(
)
{
if
(
mSkeletonState
)
{
OggHeaders
headers
;
if
(
!
HasAudio
(
)
&
&
!
HasVideo
(
)
)
{
OGG_DEBUG
(
"
Deactivating
skeleton
stream
%
ld
"
mSkeletonState
-
>
mSerial
)
;
mSkeletonState
-
>
Deactivate
(
)
;
}
else
if
(
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
mSkeletonState
headers
)
&
&
mSkeletonState
-
>
HasIndex
(
)
)
{
nsTArray
<
uint32_t
>
tracks
;
BuildSerialList
(
tracks
)
;
int64_t
duration
=
0
;
if
(
NS_SUCCEEDED
(
mSkeletonState
-
>
GetDuration
(
tracks
duration
)
)
)
{
OGG_DEBUG
(
"
Got
duration
from
Skeleton
index
%
lld
"
duration
)
;
mInfo
.
mMetadataDuration
.
emplace
(
TimeUnit
:
:
FromMicroseconds
(
duration
)
)
;
}
}
}
}
void
OggDemuxer
:
:
SetupMediaTracksInfo
(
const
nsTArray
<
uint32_t
>
&
aSerials
)
{
for
(
size_t
i
=
0
;
i
<
aSerials
.
Length
(
)
;
i
+
+
)
{
uint32_t
serial
=
aSerials
[
i
]
;
OggCodecState
*
codecState
=
mCodecStore
.
Get
(
serial
)
;
MessageField
*
msgInfo
=
nullptr
;
if
(
mSkeletonState
&
&
mSkeletonState
-
>
mMsgFieldStore
.
Contains
(
serial
)
)
{
mSkeletonState
-
>
mMsgFieldStore
.
Get
(
serial
&
msgInfo
)
;
}
if
(
codecState
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_THEORA
)
{
TheoraState
*
theoraState
=
static_cast
<
TheoraState
*
>
(
codecState
)
;
if
(
!
(
mTheoraState
&
&
mTheoraState
-
>
mSerial
=
=
theoraState
-
>
mSerial
)
)
{
continue
;
}
if
(
msgInfo
)
{
InitTrack
(
msgInfo
&
mInfo
.
mVideo
mTheoraState
=
=
theoraState
)
;
}
nsIntRect
picture
=
nsIntRect
(
theoraState
-
>
mInfo
.
pic_x
theoraState
-
>
mInfo
.
pic_y
theoraState
-
>
mInfo
.
pic_width
theoraState
-
>
mInfo
.
pic_height
)
;
nsIntSize
displaySize
=
nsIntSize
(
theoraState
-
>
mInfo
.
pic_width
theoraState
-
>
mInfo
.
pic_height
)
;
nsIntSize
frameSize
(
theoraState
-
>
mInfo
.
frame_width
theoraState
-
>
mInfo
.
frame_height
)
;
ScaleDisplayByAspectRatio
(
displaySize
theoraState
-
>
mPixelAspectRatio
)
;
if
(
IsValidVideoRegion
(
frameSize
picture
displaySize
)
)
{
mInfo
.
mVideo
.
mDisplay
=
displaySize
;
}
}
else
if
(
codecState
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_VORBIS
)
{
VorbisState
*
vorbisState
=
static_cast
<
VorbisState
*
>
(
codecState
)
;
if
(
!
(
mVorbisState
&
&
mVorbisState
-
>
mSerial
=
=
vorbisState
-
>
mSerial
)
)
{
continue
;
}
if
(
msgInfo
)
{
InitTrack
(
msgInfo
&
mInfo
.
mAudio
mVorbisState
=
=
vorbisState
)
;
}
mInfo
.
mAudio
.
mRate
=
vorbisState
-
>
mInfo
.
rate
;
mInfo
.
mAudio
.
mChannels
=
vorbisState
-
>
mInfo
.
channels
;
FillTags
(
&
mInfo
.
mAudio
vorbisState
-
>
GetTags
(
)
)
;
}
else
if
(
codecState
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_OPUS
)
{
OpusState
*
opusState
=
static_cast
<
OpusState
*
>
(
codecState
)
;
if
(
!
(
mOpusState
&
&
mOpusState
-
>
mSerial
=
=
opusState
-
>
mSerial
)
)
{
continue
;
}
if
(
msgInfo
)
{
InitTrack
(
msgInfo
&
mInfo
.
mAudio
mOpusState
=
=
opusState
)
;
}
mInfo
.
mAudio
.
mRate
=
opusState
-
>
mRate
;
mInfo
.
mAudio
.
mChannels
=
opusState
-
>
mChannels
;
FillTags
(
&
mInfo
.
mAudio
opusState
-
>
GetTags
(
)
)
;
}
}
}
void
OggDemuxer
:
:
FillTags
(
TrackInfo
*
aInfo
MetadataTags
*
aTags
)
{
if
(
!
aTags
)
{
return
;
}
nsAutoPtr
<
MetadataTags
>
tags
(
aTags
)
;
for
(
auto
iter
=
aTags
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aInfo
-
>
mTags
.
AppendElement
(
MetadataTag
(
iter
.
Key
(
)
iter
.
Data
(
)
)
)
;
}
}
nsresult
OggDemuxer
:
:
ReadMetadata
(
)
{
OGG_DEBUG
(
"
OggDemuxer
:
:
ReadMetadata
called
!
"
)
;
TrackInfo
:
:
TrackType
tracks
[
2
]
=
{
TrackInfo
:
:
kAudioTrack
TrackInfo
:
:
kVideoTrack
}
;
nsTArray
<
OggCodecState
*
>
bitstreams
;
nsTArray
<
uint32_t
>
serials
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
tracks
)
;
i
+
+
)
{
ogg_page
page
;
bool
readAllBOS
=
false
;
while
(
!
readAllBOS
)
{
if
(
!
ReadOggPage
(
tracks
[
i
]
&
page
)
)
{
OGG_DEBUG
(
"
OggDemuxer
:
:
ReadOggPage
failed
?
leaving
ReadMetadata
.
.
.
"
)
;
return
NS_ERROR_FAILURE
;
}
int
serial
=
ogg_page_serialno
(
&
page
)
;
if
(
!
ogg_page_bos
(
&
page
)
)
{
readAllBOS
=
true
;
}
else
if
(
!
mCodecStore
.
Contains
(
serial
)
)
{
OggCodecState
*
codecState
=
OggCodecState
:
:
Create
(
&
page
)
;
mCodecStore
.
Add
(
serial
codecState
)
;
bitstreams
.
AppendElement
(
codecState
)
;
serials
.
AppendElement
(
serial
)
;
}
if
(
NS_FAILED
(
DemuxOggPage
(
tracks
[
i
]
&
page
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
for
(
uint32_t
i
=
0
;
i
<
bitstreams
.
Length
(
)
;
+
+
i
)
{
OggCodecState
*
s
=
bitstreams
[
i
]
;
if
(
s
)
{
OggHeaders
headers
;
if
(
s
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_THEORA
&
&
ReadHeaders
(
TrackInfo
:
:
kVideoTrack
s
headers
)
)
{
if
(
!
mTheoraState
)
{
TheoraState
*
theoraState
=
static_cast
<
TheoraState
*
>
(
s
)
;
SetupTargetTheora
(
theoraState
headers
)
;
}
else
{
s
-
>
Deactivate
(
)
;
}
}
else
if
(
s
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_VORBIS
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
s
headers
)
)
{
if
(
!
mVorbisState
)
{
VorbisState
*
vorbisState
=
static_cast
<
VorbisState
*
>
(
s
)
;
SetupTargetVorbis
(
vorbisState
headers
)
;
}
else
{
s
-
>
Deactivate
(
)
;
}
}
else
if
(
s
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_OPUS
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
s
headers
)
)
{
if
(
mOpusEnabled
)
{
if
(
!
mOpusState
)
{
OpusState
*
opusState
=
static_cast
<
OpusState
*
>
(
s
)
;
SetupTargetOpus
(
opusState
headers
)
;
}
else
{
s
-
>
Deactivate
(
)
;
}
}
else
{
NS_WARNING
(
"
Opus
decoding
disabled
.
"
"
See
media
.
opus
.
enabled
in
about
:
config
"
)
;
}
}
else
if
(
s
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_SKELETON
&
&
!
mSkeletonState
)
{
mSkeletonState
=
static_cast
<
SkeletonState
*
>
(
s
)
;
}
else
{
s
-
>
Deactivate
(
)
;
}
}
}
SetupTargetSkeleton
(
)
;
SetupMediaTracksInfo
(
serials
)
;
if
(
HasAudio
(
)
|
|
HasVideo
(
)
)
{
int64_t
startTime
=
-
1
;
FindStartTime
(
startTime
)
;
NS_ASSERTION
(
startTime
>
=
0
"
Must
have
a
non
-
negative
start
time
"
)
;
OGG_DEBUG
(
"
Detected
stream
start
time
%
lld
"
startTime
)
;
if
(
startTime
>
=
0
)
{
mStartTime
.
emplace
(
startTime
)
;
}
if
(
mInfo
.
mMetadataDuration
.
isNothing
(
)
&
&
Resource
(
TrackInfo
:
:
kAudioTrack
)
-
>
GetLength
(
)
>
=
0
&
&
Resource
(
TrackInfo
:
:
kAudioTrack
)
-
>
GetResource
(
)
-
>
IsTransportSeekable
(
)
)
{
int64_t
length
=
Resource
(
TrackInfo
:
:
kAudioTrack
)
-
>
GetLength
(
)
;
NS_ASSERTION
(
length
>
0
"
Must
have
a
content
length
to
get
end
time
"
)
;
int64_t
endTime
=
RangeEndTime
(
TrackInfo
:
:
kAudioTrack
length
)
;
if
(
endTime
!
=
-
1
)
{
mInfo
.
mUnadjustedMetadataEndTime
.
emplace
(
TimeUnit
:
:
FromMicroseconds
(
endTime
)
)
;
mInfo
.
mMetadataDuration
.
emplace
(
TimeUnit
:
:
FromMicroseconds
(
endTime
-
mStartTime
.
refOr
(
0
)
)
)
;
OGG_DEBUG
(
"
Got
Ogg
duration
from
seeking
to
end
%
lld
"
endTime
)
;
}
}
if
(
mInfo
.
mMetadataDuration
.
isNothing
(
)
)
{
mInfo
.
mMetadataDuration
.
emplace
(
TimeUnit
:
:
FromInfinity
(
)
)
;
}
if
(
HasAudio
(
)
)
{
mInfo
.
mAudio
.
mDuration
=
mInfo
.
mMetadataDuration
-
>
ToMicroseconds
(
)
;
}
if
(
HasVideo
(
)
)
{
mInfo
.
mVideo
.
mDuration
=
mInfo
.
mMetadataDuration
-
>
ToMicroseconds
(
)
;
}
}
else
{
OGG_DEBUG
(
"
no
audio
or
video
tracks
"
)
;
return
NS_ERROR_FAILURE
;
}
OGG_DEBUG
(
"
success
?
!
"
)
;
return
NS_OK
;
}
void
OggDemuxer
:
:
SetChained
(
)
{
{
if
(
mIsChained
)
{
return
;
}
mIsChained
=
true
;
}
}
bool
OggDemuxer
:
:
ReadOggChain
(
)
{
bool
chained
=
false
;
OpusState
*
newOpusState
=
nullptr
;
VorbisState
*
newVorbisState
=
nullptr
;
nsAutoPtr
<
MetadataTags
>
tags
;
if
(
HasVideo
(
)
|
|
HasSkeleton
(
)
|
|
!
HasAudio
(
)
)
{
return
false
;
}
ogg_page
page
;
if
(
!
ReadOggPage
(
TrackInfo
:
:
kAudioTrack
&
page
)
|
|
!
ogg_page_bos
(
&
page
)
)
{
return
false
;
}
int
serial
=
ogg_page_serialno
(
&
page
)
;
if
(
mCodecStore
.
Contains
(
serial
)
)
{
return
false
;
}
nsAutoPtr
<
OggCodecState
>
codecState
;
codecState
=
OggCodecState
:
:
Create
(
&
page
)
;
if
(
!
codecState
)
{
return
false
;
}
if
(
mVorbisState
&
&
(
codecState
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_VORBIS
)
)
{
newVorbisState
=
static_cast
<
VorbisState
*
>
(
codecState
.
get
(
)
)
;
}
else
if
(
mOpusState
&
&
(
codecState
-
>
GetType
(
)
=
=
OggCodecState
:
:
TYPE_OPUS
)
)
{
newOpusState
=
static_cast
<
OpusState
*
>
(
codecState
.
get
(
)
)
;
}
else
{
return
false
;
}
OggCodecState
*
state
;
mCodecStore
.
Add
(
serial
codecState
.
forget
(
)
)
;
state
=
mCodecStore
.
Get
(
serial
)
;
NS_ENSURE_TRUE
(
state
!
=
nullptr
false
)
;
if
(
NS_FAILED
(
state
-
>
PageIn
(
&
page
)
)
)
{
return
false
;
}
MessageField
*
msgInfo
=
nullptr
;
if
(
mSkeletonState
&
&
mSkeletonState
-
>
mMsgFieldStore
.
Contains
(
serial
)
)
{
mSkeletonState
-
>
mMsgFieldStore
.
Get
(
serial
&
msgInfo
)
;
}
OggHeaders
vorbisHeaders
;
if
(
(
newVorbisState
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
newVorbisState
vorbisHeaders
)
)
&
&
(
mVorbisState
-
>
mInfo
.
rate
=
=
newVorbisState
-
>
mInfo
.
rate
)
&
&
(
mVorbisState
-
>
mInfo
.
channels
=
=
newVorbisState
-
>
mInfo
.
channels
)
)
{
SetupTargetVorbis
(
newVorbisState
vorbisHeaders
)
;
LOG
(
LogLevel
:
:
Debug
(
"
New
vorbis
ogg
link
serial
=
%
d
\
n
"
mVorbisSerial
)
)
;
if
(
msgInfo
)
{
InitTrack
(
msgInfo
&
mInfo
.
mAudio
true
)
;
}
mInfo
.
mAudio
.
mMimeType
=
NS_LITERAL_CSTRING
(
"
audio
/
ogg
;
codec
=
vorbis
"
)
;
mInfo
.
mAudio
.
mRate
=
newVorbisState
-
>
mInfo
.
rate
;
mInfo
.
mAudio
.
mChannels
=
newVorbisState
-
>
mInfo
.
channels
;
chained
=
true
;
tags
=
newVorbisState
-
>
GetTags
(
)
;
}
OggHeaders
opusHeaders
;
if
(
(
newOpusState
&
&
ReadHeaders
(
TrackInfo
:
:
kAudioTrack
newOpusState
opusHeaders
)
)
&
&
(
mOpusState
-
>
mRate
=
=
newOpusState
-
>
mRate
)
&
&
(
mOpusState
-
>
mChannels
=
=
newOpusState
-
>
mChannels
)
)
{
SetupTargetOpus
(
newOpusState
opusHeaders
)
;
if
(
msgInfo
)
{
InitTrack
(
msgInfo
&
mInfo
.
mAudio
true
)
;
}
mInfo
.
mAudio
.
mMimeType
=
NS_LITERAL_CSTRING
(
"
audio
/
ogg
;
codec
=
opus
"
)
;
mInfo
.
mAudio
.
mRate
=
newOpusState
-
>
mRate
;
mInfo
.
mAudio
.
mChannels
=
newOpusState
-
>
mChannels
;
chained
=
true
;
tags
=
newOpusState
-
>
GetTags
(
)
;
}
if
(
chained
)
{
SetChained
(
)
;
{
}
return
true
;
}
return
false
;
}
ogg_sync_state
*
OggDemuxer
:
:
OggState
(
TrackInfo
:
:
TrackType
aType
)
{
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
)
{
return
&
mVideoOggState
.
mOggState
.
mState
;
}
return
&
mAudioOggState
.
mOggState
.
mState
;
}
MediaResourceIndex
*
OggDemuxer
:
:
Resource
(
TrackInfo
:
:
TrackType
aType
)
{
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
)
{
return
&
mVideoOggState
.
mResource
;
}
return
&
mAudioOggState
.
mResource
;
}
MediaResourceIndex
*
OggDemuxer
:
:
CommonResource
(
)
{
return
&
mAudioOggState
.
mResource
;
}
bool
OggDemuxer
:
:
ReadOggPage
(
TrackInfo
:
:
TrackType
aType
ogg_page
*
aPage
)
{
int
ret
=
0
;
while
(
(
ret
=
ogg_sync_pageseek
(
OggState
(
aType
)
aPage
)
)
<
=
0
)
{
if
(
ret
<
0
)
{
continue
;
}
char
*
buffer
=
ogg_sync_buffer
(
OggState
(
aType
)
4096
)
;
NS_ASSERTION
(
buffer
"
ogg_sync_buffer
failed
"
)
;
uint32_t
bytesRead
=
0
;
nsresult
rv
=
Resource
(
aType
)
-
>
Read
(
buffer
4096
&
bytesRead
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
bytesRead
)
{
return
false
;
}
ret
=
ogg_sync_wrote
(
OggState
(
aType
)
bytesRead
)
;
NS_ENSURE_TRUE
(
ret
=
=
0
false
)
;
}
return
true
;
}
nsresult
OggDemuxer
:
:
DemuxOggPage
(
TrackInfo
:
:
TrackType
aType
ogg_page
*
aPage
)
{
int
serial
=
ogg_page_serialno
(
aPage
)
;
OggCodecState
*
codecState
=
mCodecStore
.
Get
(
serial
)
;
if
(
codecState
=
=
nullptr
)
{
OGG_DEBUG
(
"
encountered
packet
for
unrecognized
codecState
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
GetCodecStateType
(
codecState
)
!
=
aType
&
&
codecState
-
>
GetType
(
)
!
=
OggCodecState
:
:
TYPE_SKELETON
)
{
return
NS_OK
;
}
if
(
NS_FAILED
(
codecState
-
>
PageIn
(
aPage
)
)
)
{
OGG_DEBUG
(
"
codecState
-
>
PageIn
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
bool
OggDemuxer
:
:
IsSeekable
(
)
const
{
if
(
mIsChained
)
{
return
false
;
}
return
true
;
}
UniquePtr
<
EncryptionInfo
>
OggDemuxer
:
:
GetCrypto
(
)
{
return
nullptr
;
}
ogg_packet
*
OggDemuxer
:
:
GetNextPacket
(
TrackInfo
:
:
TrackType
aType
)
{
OggCodecState
*
state
=
GetTrackCodecState
(
aType
)
;
ogg_packet
*
packet
=
nullptr
;
do
{
if
(
packet
)
{
OggCodecState
:
:
ReleasePacket
(
state
-
>
PacketOut
(
)
)
;
}
DemuxUntilPacketAvailable
(
aType
state
)
;
packet
=
state
-
>
PacketPeek
(
)
;
}
while
(
packet
&
&
state
-
>
IsHeader
(
packet
)
)
;
return
packet
;
}
void
OggDemuxer
:
:
DemuxUntilPacketAvailable
(
TrackInfo
:
:
TrackType
aType
OggCodecState
*
aState
)
{
while
(
!
aState
-
>
IsPacketReady
(
)
)
{
OGG_DEBUG
(
"
no
packet
yet
reading
some
more
"
)
;
ogg_page
page
;
if
(
!
ReadOggPage
(
aType
&
page
)
)
{
OGG_DEBUG
(
"
no
more
pages
to
read
in
resource
?
"
)
;
return
;
}
DemuxOggPage
(
aType
&
page
)
;
}
}
TimeIntervals
OggDemuxer
:
:
GetBuffered
(
TrackInfo
:
:
TrackType
aType
)
{
if
(
!
HaveStartTime
(
aType
)
)
{
return
TimeIntervals
(
)
;
}
if
(
mIsChained
)
{
return
TimeIntervals
:
:
Invalid
(
)
;
}
TimeIntervals
buffered
;
if
(
!
mInfo
.
HasValidMedia
(
)
)
{
return
buffered
;
}
AutoPinned
<
MediaResource
>
resource
(
Resource
(
aType
)
-
>
GetResource
(
)
)
;
MediaByteRangeSet
ranges
;
nsresult
res
=
resource
-
>
GetCachedRanges
(
ranges
)
;
NS_ENSURE_SUCCESS
(
res
TimeIntervals
:
:
Invalid
(
)
)
;
nsAutoOggSyncState
sync
;
for
(
uint32_t
index
=
0
;
index
<
ranges
.
Length
(
)
;
index
+
+
)
{
int64_t
startOffset
=
ranges
[
index
]
.
mStart
;
int64_t
endOffset
=
ranges
[
index
]
.
mEnd
;
int64_t
startTime
=
(
startOffset
=
=
0
)
?
StartTime
(
)
:
-
1
;
ogg_sync_reset
(
&
sync
.
mState
)
;
while
(
startTime
=
=
-
1
)
{
ogg_page
page
;
int32_t
discard
;
PageSyncResult
pageSyncResult
=
PageSync
(
Resource
(
aType
)
&
sync
.
mState
true
startOffset
endOffset
&
page
discard
)
;
if
(
pageSyncResult
=
=
PAGE_SYNC_ERROR
)
{
return
TimeIntervals
:
:
Invalid
(
)
;
}
else
if
(
pageSyncResult
=
=
PAGE_SYNC_END_OF_RANGE
)
{
break
;
}
int64_t
granulepos
=
ogg_page_granulepos
(
&
page
)
;
if
(
granulepos
=
=
-
1
)
{
startOffset
+
=
page
.
header_len
+
page
.
body_len
;
continue
;
}
uint32_t
serial
=
ogg_page_serialno
(
&
page
)
;
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
mVorbisState
&
&
serial
=
=
mVorbisSerial
)
{
startTime
=
VorbisState
:
:
Time
(
&
mVorbisInfo
granulepos
)
;
NS_ASSERTION
(
startTime
>
0
"
Must
have
positive
start
time
"
)
;
}
else
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
mOpusState
&
&
serial
=
=
mOpusSerial
)
{
startTime
=
OpusState
:
:
Time
(
mOpusPreSkip
granulepos
)
;
NS_ASSERTION
(
startTime
>
0
"
Must
have
positive
start
time
"
)
;
}
else
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
mTheoraState
&
&
serial
=
=
mTheoraSerial
)
{
startTime
=
TheoraState
:
:
Time
(
&
mTheoraInfo
granulepos
)
;
NS_ASSERTION
(
startTime
>
0
"
Must
have
positive
start
time
"
)
;
}
else
if
(
mCodecStore
.
Contains
(
serial
)
)
{
startOffset
+
=
page
.
header_len
+
page
.
body_len
;
continue
;
}
else
{
SetChained
(
)
;
return
buffered
;
}
}
if
(
startTime
!
=
-
1
)
{
int64_t
endTime
=
RangeEndTime
(
aType
startOffset
endOffset
true
)
;
if
(
endTime
>
startTime
)
{
buffered
+
=
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
startTime
-
StartTime
(
)
)
TimeUnit
:
:
FromMicroseconds
(
endTime
-
StartTime
(
)
)
)
;
}
}
}
return
buffered
;
}
void
OggDemuxer
:
:
FindStartTime
(
int64_t
&
aOutStartTime
)
{
int64_t
videoStartTime
=
INT64_MAX
;
int64_t
audioStartTime
=
INT64_MAX
;
if
(
HasVideo
(
)
)
{
FindStartTime
(
TrackInfo
:
:
kVideoTrack
videoStartTime
)
;
if
(
videoStartTime
!
=
INT64_MAX
)
{
OGG_DEBUG
(
"
OggDemuxer
:
:
FindStartTime
(
)
video
=
%
lld
"
videoStartTime
)
;
mVideoOggState
.
mStartTime
=
Some
(
TimeUnit
:
:
FromMicroseconds
(
videoStartTime
)
)
;
}
}
if
(
HasAudio
(
)
)
{
FindStartTime
(
TrackInfo
:
:
kAudioTrack
audioStartTime
)
;
if
(
audioStartTime
!
=
INT64_MAX
)
{
OGG_DEBUG
(
"
OggDemuxer
:
:
FindStartTime
(
)
audio
=
%
lld
"
audioStartTime
)
;
mAudioOggState
.
mStartTime
=
Some
(
TimeUnit
:
:
FromMicroseconds
(
audioStartTime
)
)
;
}
}
int64_t
startTime
=
std
:
:
min
(
videoStartTime
audioStartTime
)
;
if
(
startTime
!
=
INT64_MAX
)
{
aOutStartTime
=
startTime
;
}
}
void
OggDemuxer
:
:
FindStartTime
(
TrackInfo
:
:
TrackType
aType
int64_t
&
aOutStartTime
)
{
int64_t
startTime
=
INT64_MAX
;
OggCodecState
*
state
=
GetTrackCodecState
(
aType
)
;
ogg_packet
*
pkt
=
GetNextPacket
(
aType
)
;
if
(
pkt
)
{
startTime
=
state
-
>
PacketStartTime
(
pkt
)
;
}
if
(
startTime
!
=
INT64_MAX
)
{
aOutStartTime
=
startTime
;
}
}
nsresult
OggDemuxer
:
:
SeekInternal
(
TrackInfo
:
:
TrackType
aType
const
TimeUnit
&
aTarget
)
{
int64_t
target
=
aTarget
.
ToMicroseconds
(
)
;
OGG_DEBUG
(
"
About
to
seek
to
%
lld
"
target
)
;
nsresult
res
;
int64_t
adjustedTarget
=
target
;
int64_t
startTime
=
StartTime
(
aType
)
;
int64_t
endTime
=
mInfo
.
mMetadataDuration
-
>
ToMicroseconds
(
)
;
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
mOpusState
)
{
adjustedTarget
=
std
:
:
max
(
startTime
target
-
OGG_SEEK_OPUS_PREROLL
)
;
}
if
(
adjustedTarget
=
=
startTime
)
{
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
0
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
res
=
Reset
(
aType
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
else
{
IndexedSeekResult
sres
=
SeekToKeyframeUsingIndex
(
aType
adjustedTarget
)
;
NS_ENSURE_TRUE
(
sres
!
=
SEEK_FATAL_ERROR
NS_ERROR_FAILURE
)
;
if
(
sres
=
=
SEEK_INDEX_FAIL
)
{
AutoTArray
<
SeekRange
16
>
ranges
;
res
=
GetSeekRanges
(
aType
ranges
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
SeekRange
r
=
SelectSeekRange
(
aType
ranges
target
startTime
endTime
true
)
;
if
(
!
r
.
IsNull
(
)
)
{
res
=
SeekInBufferedRange
(
aType
target
adjustedTarget
startTime
endTime
ranges
r
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
else
{
res
=
SeekInUnbuffered
(
aType
target
startTime
endTime
ranges
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
}
}
}
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
)
{
while
(
true
)
{
DemuxUntilPacketAvailable
(
aType
mTheoraState
)
;
ogg_packet
*
packet
=
mTheoraState
-
>
PacketPeek
(
)
;
if
(
packet
=
=
nullptr
)
{
OGG_DEBUG
(
"
End
of
Theora
stream
reached
before
keyframe
found
in
indexed
seek
"
)
;
break
;
}
if
(
mTheoraState
-
>
IsKeyframe
(
packet
)
)
{
OGG_DEBUG
(
"
Theora
keyframe
found
after
seek
"
)
;
break
;
}
ogg_packet
*
releaseMe
=
mTheoraState
-
>
PacketOut
(
)
;
OggCodecState
:
:
ReleasePacket
(
releaseMe
)
;
}
}
return
NS_OK
;
}
OggDemuxer
:
:
IndexedSeekResult
OggDemuxer
:
:
RollbackIndexedSeek
(
TrackInfo
:
:
TrackType
aType
int64_t
aOffset
)
{
if
(
mSkeletonState
)
{
mSkeletonState
-
>
Deactivate
(
)
;
}
nsresult
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
aOffset
)
;
NS_ENSURE_SUCCESS
(
res
SEEK_FATAL_ERROR
)
;
return
SEEK_INDEX_FAIL
;
}
OggDemuxer
:
:
IndexedSeekResult
OggDemuxer
:
:
SeekToKeyframeUsingIndex
(
TrackInfo
:
:
TrackType
aType
int64_t
aTarget
)
{
if
(
!
HasSkeleton
(
)
|
|
!
mSkeletonState
-
>
HasIndex
(
)
)
{
return
SEEK_INDEX_FAIL
;
}
AutoTArray
<
uint32_t
2
>
tracks
;
BuildSerialList
(
tracks
)
;
SkeletonState
:
:
nsSeekTarget
keyframe
;
if
(
NS_FAILED
(
mSkeletonState
-
>
IndexedSeekTarget
(
aTarget
tracks
keyframe
)
)
)
{
return
SEEK_INDEX_FAIL
;
}
int64_t
tell
=
Resource
(
aType
)
-
>
Tell
(
)
;
if
(
keyframe
.
mKeyPoint
.
mOffset
>
Resource
(
aType
)
-
>
GetLength
(
)
|
|
keyframe
.
mKeyPoint
.
mOffset
<
0
)
{
return
RollbackIndexedSeek
(
aType
tell
)
;
}
LOG
(
LogLevel
:
:
Debug
(
"
Seeking
using
index
to
keyframe
at
offset
%
lld
\
n
"
keyframe
.
mKeyPoint
.
mOffset
)
)
;
nsresult
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
keyframe
.
mKeyPoint
.
mOffset
)
;
NS_ENSURE_SUCCESS
(
res
SEEK_FATAL_ERROR
)
;
res
=
Reset
(
aType
)
;
NS_ENSURE_SUCCESS
(
res
SEEK_FATAL_ERROR
)
;
ogg_page
page
;
int
skippedBytes
=
0
;
PageSyncResult
syncres
=
PageSync
(
Resource
(
aType
)
OggState
(
aType
)
false
keyframe
.
mKeyPoint
.
mOffset
Resource
(
aType
)
-
>
GetLength
(
)
&
page
skippedBytes
)
;
NS_ENSURE_TRUE
(
syncres
!
=
PAGE_SYNC_ERROR
SEEK_FATAL_ERROR
)
;
if
(
syncres
!
=
PAGE_SYNC_OK
|
|
skippedBytes
!
=
0
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Indexed
-
seek
failure
:
Ogg
Skeleton
Index
is
invalid
"
"
or
sync
error
after
seek
"
)
)
;
return
RollbackIndexedSeek
(
aType
tell
)
;
}
uint32_t
serial
=
ogg_page_serialno
(
&
page
)
;
if
(
serial
!
=
keyframe
.
mSerial
)
{
return
RollbackIndexedSeek
(
aType
tell
)
;
}
OggCodecState
*
codecState
=
mCodecStore
.
Get
(
serial
)
;
if
(
codecState
&
&
codecState
-
>
mActive
&
&
ogg_stream_pagein
(
&
codecState
-
>
mState
&
page
)
!
=
0
)
{
return
RollbackIndexedSeek
(
aType
tell
)
;
}
return
SEEK_OK
;
}
OggDemuxer
:
:
PageSyncResult
OggDemuxer
:
:
PageSync
(
MediaResourceIndex
*
aResource
ogg_sync_state
*
aState
bool
aCachedDataOnly
int64_t
aOffset
int64_t
aEndOffset
ogg_page
*
aPage
int
&
aSkippedBytes
)
{
aSkippedBytes
=
0
;
int
ret
=
0
;
uint32_t
bytesRead
=
0
;
int64_t
readHead
=
aOffset
;
while
(
ret
<
=
0
)
{
ret
=
ogg_sync_pageseek
(
aState
aPage
)
;
if
(
ret
=
=
0
)
{
char
*
buffer
=
ogg_sync_buffer
(
aState
PAGE_STEP
)
;
NS_ASSERTION
(
buffer
"
Must
have
a
buffer
"
)
;
int64_t
bytesToRead
=
std
:
:
min
(
static_cast
<
int64_t
>
(
PAGE_STEP
)
aEndOffset
-
readHead
)
;
NS_ASSERTION
(
bytesToRead
<
=
UINT32_MAX
"
bytesToRead
range
check
"
)
;
if
(
bytesToRead
<
=
0
)
{
return
PAGE_SYNC_END_OF_RANGE
;
}
nsresult
rv
=
NS_OK
;
if
(
aCachedDataOnly
)
{
rv
=
aResource
-
>
GetResource
(
)
-
>
ReadFromCache
(
buffer
readHead
static_cast
<
uint32_t
>
(
bytesToRead
)
)
;
NS_ENSURE_SUCCESS
(
rv
PAGE_SYNC_ERROR
)
;
bytesRead
=
static_cast
<
uint32_t
>
(
bytesToRead
)
;
}
else
{
rv
=
aResource
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
readHead
)
;
NS_ENSURE_SUCCESS
(
rv
PAGE_SYNC_ERROR
)
;
rv
=
aResource
-
>
Read
(
buffer
static_cast
<
uint32_t
>
(
bytesToRead
)
&
bytesRead
)
;
NS_ENSURE_SUCCESS
(
rv
PAGE_SYNC_ERROR
)
;
}
if
(
bytesRead
=
=
0
&
&
NS_SUCCEEDED
(
rv
)
)
{
return
PAGE_SYNC_END_OF_RANGE
;
}
readHead
+
=
bytesRead
;
ret
=
ogg_sync_wrote
(
aState
bytesRead
)
;
NS_ENSURE_TRUE
(
ret
=
=
0
PAGE_SYNC_ERROR
)
;
continue
;
}
if
(
ret
<
0
)
{
NS_ASSERTION
(
aSkippedBytes
>
=
0
"
Offset
>
=
0
"
)
;
aSkippedBytes
+
=
-
ret
;
NS_ASSERTION
(
aSkippedBytes
>
=
0
"
Offset
>
=
0
"
)
;
continue
;
}
}
return
PAGE_SYNC_OK
;
}
OggTrackDemuxer
:
:
OggTrackDemuxer
(
OggDemuxer
*
aParent
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
:
mParent
(
aParent
)
mType
(
aType
)
{
mInfo
=
mParent
-
>
GetTrackInfo
(
aType
aTrackNumber
)
;
MOZ_ASSERT
(
mInfo
)
;
}
OggTrackDemuxer
:
:
~
OggTrackDemuxer
(
)
{
}
UniquePtr
<
TrackInfo
>
OggTrackDemuxer
:
:
GetInfo
(
)
const
{
return
mInfo
-
>
Clone
(
)
;
}
RefPtr
<
OggTrackDemuxer
:
:
SeekPromise
>
OggTrackDemuxer
:
:
Seek
(
TimeUnit
aTime
)
{
mQueuedSample
=
nullptr
;
TimeUnit
seekTime
=
aTime
;
if
(
mParent
-
>
SeekInternal
(
mType
aTime
)
=
=
NS_OK
)
{
RefPtr
<
MediaRawData
>
sample
(
NextSample
(
)
)
;
if
(
sample
!
=
nullptr
)
{
seekTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
;
OGG_DEBUG
(
"
%
p
seeked
to
time
%
lld
"
this
seekTime
.
ToMicroseconds
(
)
)
;
}
mQueuedSample
=
sample
;
return
SeekPromise
:
:
CreateAndResolve
(
seekTime
__func__
)
;
}
else
{
return
SeekPromise
:
:
CreateAndReject
(
DemuxerFailureReason
:
:
DEMUXER_ERROR
__func__
)
;
}
}
RefPtr
<
MediaRawData
>
OggTrackDemuxer
:
:
NextSample
(
)
{
if
(
mQueuedSample
)
{
RefPtr
<
MediaRawData
>
nextSample
=
mQueuedSample
;
mQueuedSample
=
nullptr
;
return
nextSample
;
}
ogg_packet
*
packet
=
mParent
-
>
GetNextPacket
(
mType
)
;
if
(
!
packet
)
{
return
nullptr
;
}
bool
eos
=
packet
-
>
e_o_s
;
OggCodecState
*
state
=
mParent
-
>
GetTrackCodecState
(
mType
)
;
RefPtr
<
MediaRawData
>
data
=
state
-
>
PacketOutAsMediaRawData
(
)
;
;
if
(
eos
)
{
mParent
-
>
ReadOggChain
(
)
;
}
return
data
;
}
RefPtr
<
OggTrackDemuxer
:
:
SamplesPromise
>
OggTrackDemuxer
:
:
GetSamples
(
int32_t
aNumSamples
)
{
RefPtr
<
SamplesHolder
>
samples
=
new
SamplesHolder
;
if
(
!
aNumSamples
)
{
return
SamplesPromise
:
:
CreateAndReject
(
DemuxerFailureReason
:
:
DEMUXER_ERROR
__func__
)
;
}
while
(
aNumSamples
)
{
RefPtr
<
MediaRawData
>
sample
(
NextSample
(
)
)
;
if
(
!
sample
)
{
break
;
}
samples
-
>
mSamples
.
AppendElement
(
sample
)
;
aNumSamples
-
-
;
}
if
(
samples
-
>
mSamples
.
IsEmpty
(
)
)
{
return
SamplesPromise
:
:
CreateAndReject
(
DemuxerFailureReason
:
:
END_OF_STREAM
__func__
)
;
}
else
{
return
SamplesPromise
:
:
CreateAndResolve
(
samples
__func__
)
;
}
}
void
OggTrackDemuxer
:
:
Reset
(
)
{
mParent
-
>
Reset
(
mType
)
;
mQueuedSample
=
nullptr
;
TimeIntervals
buffered
=
GetBuffered
(
)
;
if
(
buffered
.
Length
(
)
)
{
OGG_DEBUG
(
"
Seek
to
start
point
:
%
f
"
buffered
.
Start
(
0
)
.
ToSeconds
(
)
)
;
mParent
-
>
SeekInternal
(
mType
buffered
.
Start
(
0
)
)
;
}
}
RefPtr
<
OggTrackDemuxer
:
:
SkipAccessPointPromise
>
OggTrackDemuxer
:
:
SkipToNextRandomAccessPoint
(
TimeUnit
aTimeThreshold
)
{
uint32_t
parsed
=
0
;
bool
found
=
false
;
RefPtr
<
MediaRawData
>
sample
;
OGG_DEBUG
(
"
TimeThreshold
:
%
f
"
aTimeThreshold
.
ToSeconds
(
)
)
;
while
(
!
found
&
&
(
sample
=
NextSample
(
)
)
)
{
parsed
+
+
;
if
(
sample
-
>
mKeyframe
&
&
sample
-
>
mTime
>
=
aTimeThreshold
.
ToMicroseconds
(
)
)
{
found
=
true
;
mQueuedSample
=
sample
;
}
}
if
(
found
)
{
OGG_DEBUG
(
"
next
sample
:
%
f
(
parsed
:
%
d
)
"
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
.
ToSeconds
(
)
parsed
)
;
return
SkipAccessPointPromise
:
:
CreateAndResolve
(
parsed
__func__
)
;
}
else
{
SkipFailureHolder
failure
(
DemuxerFailureReason
:
:
END_OF_STREAM
parsed
)
;
return
SkipAccessPointPromise
:
:
CreateAndReject
(
Move
(
failure
)
__func__
)
;
}
}
TimeIntervals
OggTrackDemuxer
:
:
GetBuffered
(
)
{
return
mParent
-
>
GetBuffered
(
mType
)
;
}
void
OggTrackDemuxer
:
:
BreakCycles
(
)
{
mParent
=
nullptr
;
}
ogg_uint32_t
OggDemuxer
:
:
GetPageChecksum
(
ogg_page
*
page
)
{
if
(
page
=
=
0
|
|
page
-
>
header
=
=
0
|
|
page
-
>
header_len
<
25
)
{
return
0
;
}
const
unsigned
char
*
p
=
page
-
>
header
+
22
;
uint32_t
c
=
p
[
0
]
+
(
p
[
1
]
<
<
8
)
+
(
p
[
2
]
<
<
16
)
+
(
p
[
3
]
<
<
24
)
;
return
c
;
}
int64_t
OggDemuxer
:
:
RangeStartTime
(
TrackInfo
:
:
TrackType
aType
int64_t
aOffset
)
{
int64_t
position
=
Resource
(
aType
)
-
>
Tell
(
)
;
nsresult
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
aOffset
)
;
NS_ENSURE_SUCCESS
(
res
0
)
;
int64_t
startTime
=
0
;
FindStartTime
(
aType
startTime
)
;
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
position
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
return
startTime
;
}
struct
nsDemuxerAutoOggSyncState
{
nsDemuxerAutoOggSyncState
(
)
{
ogg_sync_init
(
&
mState
)
;
}
~
nsDemuxerAutoOggSyncState
(
)
{
ogg_sync_clear
(
&
mState
)
;
}
ogg_sync_state
mState
;
}
;
int64_t
OggDemuxer
:
:
RangeEndTime
(
TrackInfo
:
:
TrackType
aType
int64_t
aEndOffset
)
{
int64_t
position
=
Resource
(
aType
)
-
>
Tell
(
)
;
int64_t
endTime
=
RangeEndTime
(
aType
0
aEndOffset
false
)
;
nsresult
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
position
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
return
endTime
;
}
int64_t
OggDemuxer
:
:
RangeEndTime
(
TrackInfo
:
:
TrackType
aType
int64_t
aStartOffset
int64_t
aEndOffset
bool
aCachedDataOnly
)
{
nsDemuxerAutoOggSyncState
sync
;
const
int
step
=
5000
;
const
int
maxOggPageSize
=
65306
;
int64_t
readStartOffset
=
aEndOffset
;
int64_t
readLimitOffset
=
aEndOffset
;
int64_t
readHead
=
aEndOffset
;
int64_t
endTime
=
-
1
;
uint32_t
checksumAfterSeek
=
0
;
uint32_t
prevChecksumAfterSeek
=
0
;
bool
mustBackOff
=
false
;
while
(
true
)
{
ogg_page
page
;
int
ret
=
ogg_sync_pageseek
(
&
sync
.
mState
&
page
)
;
if
(
ret
=
=
0
)
{
if
(
mustBackOff
|
|
readHead
=
=
aEndOffset
|
|
readHead
=
=
aStartOffset
)
{
if
(
endTime
!
=
-
1
|
|
readStartOffset
=
=
0
)
{
break
;
}
mustBackOff
=
false
;
prevChecksumAfterSeek
=
checksumAfterSeek
;
checksumAfterSeek
=
0
;
ogg_sync_reset
(
&
sync
.
mState
)
;
readStartOffset
=
std
:
:
max
(
static_cast
<
int64_t
>
(
0
)
readStartOffset
-
step
)
;
readLimitOffset
=
std
:
:
min
(
readLimitOffset
readStartOffset
+
maxOggPageSize
)
;
readHead
=
std
:
:
max
(
aStartOffset
readStartOffset
)
;
}
int64_t
limit
=
std
:
:
min
(
static_cast
<
int64_t
>
(
UINT32_MAX
)
aEndOffset
-
readHead
)
;
limit
=
std
:
:
max
(
static_cast
<
int64_t
>
(
0
)
limit
)
;
limit
=
std
:
:
min
(
limit
static_cast
<
int64_t
>
(
step
)
)
;
uint32_t
bytesToRead
=
static_cast
<
uint32_t
>
(
limit
)
;
uint32_t
bytesRead
=
0
;
char
*
buffer
=
ogg_sync_buffer
(
&
sync
.
mState
bytesToRead
)
;
NS_ASSERTION
(
buffer
"
Must
have
buffer
"
)
;
nsresult
res
;
if
(
aCachedDataOnly
)
{
res
=
Resource
(
aType
)
-
>
GetResource
(
)
-
>
ReadFromCache
(
buffer
readHead
bytesToRead
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
bytesRead
=
bytesToRead
;
}
else
{
NS_ASSERTION
(
readHead
<
aEndOffset
"
resource
pos
must
be
before
range
end
"
)
;
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
readHead
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
res
=
Resource
(
aType
)
-
>
Read
(
buffer
bytesToRead
&
bytesRead
)
;
NS_ENSURE_SUCCESS
(
res
-
1
)
;
}
readHead
+
=
bytesRead
;
if
(
readHead
>
readLimitOffset
)
{
mustBackOff
=
true
;
}
ret
=
ogg_sync_wrote
(
&
sync
.
mState
bytesRead
)
;
if
(
ret
!
=
0
)
{
endTime
=
-
1
;
break
;
}
continue
;
}
if
(
ret
<
0
|
|
ogg_page_granulepos
(
&
page
)
<
0
)
{
continue
;
}
uint32_t
checksum
=
GetPageChecksum
(
&
page
)
;
if
(
checksumAfterSeek
=
=
0
)
{
checksumAfterSeek
=
checksum
;
}
if
(
checksum
=
=
prevChecksumAfterSeek
)
{
mustBackOff
=
true
;
continue
;
}
int64_t
granulepos
=
ogg_page_granulepos
(
&
page
)
;
int
serial
=
ogg_page_serialno
(
&
page
)
;
OggCodecState
*
codecState
=
nullptr
;
codecState
=
mCodecStore
.
Get
(
serial
)
;
if
(
!
codecState
)
{
SetChained
(
)
;
endTime
=
-
1
;
break
;
}
int64_t
t
=
codecState
-
>
Time
(
granulepos
)
;
if
(
t
!
=
-
1
)
{
endTime
=
t
;
}
}
return
endTime
;
}
nsresult
OggDemuxer
:
:
GetSeekRanges
(
TrackInfo
:
:
TrackType
aType
nsTArray
<
SeekRange
>
&
aRanges
)
{
AutoPinned
<
MediaResource
>
resource
(
Resource
(
aType
)
-
>
GetResource
(
)
)
;
MediaByteRangeSet
cached
;
nsresult
res
=
resource
-
>
GetCachedRanges
(
cached
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
for
(
uint32_t
index
=
0
;
index
<
cached
.
Length
(
)
;
index
+
+
)
{
auto
&
range
=
cached
[
index
]
;
int64_t
startTime
=
-
1
;
int64_t
endTime
=
-
1
;
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
int64_t
startOffset
=
range
.
mStart
;
int64_t
endOffset
=
range
.
mEnd
;
startTime
=
RangeStartTime
(
aType
startOffset
)
;
if
(
startTime
!
=
-
1
&
&
(
(
endTime
=
RangeEndTime
(
aType
endOffset
)
)
!
=
-
1
)
)
{
NS_WARN_IF_FALSE
(
startTime
<
endTime
"
Start
time
must
be
before
end
time
"
)
;
aRanges
.
AppendElement
(
SeekRange
(
startOffset
endOffset
startTime
endTime
)
)
;
}
}
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
OggDemuxer
:
:
SeekRange
OggDemuxer
:
:
SelectSeekRange
(
TrackInfo
:
:
TrackType
aType
const
nsTArray
<
SeekRange
>
&
ranges
int64_t
aTarget
int64_t
aStartTime
int64_t
aEndTime
bool
aExact
)
{
int64_t
so
=
0
;
int64_t
eo
=
Resource
(
aType
)
-
>
GetLength
(
)
;
int64_t
st
=
aStartTime
;
int64_t
et
=
aEndTime
;
for
(
uint32_t
i
=
0
;
i
<
ranges
.
Length
(
)
;
i
+
+
)
{
const
SeekRange
&
r
=
ranges
[
i
]
;
if
(
r
.
mTimeStart
<
aTarget
)
{
so
=
r
.
mOffsetStart
;
st
=
r
.
mTimeStart
;
}
if
(
r
.
mTimeEnd
>
=
aTarget
&
&
r
.
mTimeEnd
<
et
)
{
eo
=
r
.
mOffsetEnd
;
et
=
r
.
mTimeEnd
;
}
if
(
r
.
mTimeStart
<
aTarget
&
&
aTarget
<
=
r
.
mTimeEnd
)
{
return
ranges
[
i
]
;
}
}
if
(
aExact
|
|
eo
=
=
-
1
)
{
return
SeekRange
(
)
;
}
return
SeekRange
(
so
eo
st
et
)
;
}
nsresult
OggDemuxer
:
:
SeekInBufferedRange
(
TrackInfo
:
:
TrackType
aType
int64_t
aTarget
int64_t
aAdjustedTarget
int64_t
aStartTime
int64_t
aEndTime
const
nsTArray
<
SeekRange
>
&
aRanges
const
SeekRange
&
aRange
)
{
OGG_DEBUG
(
"
Seeking
in
buffered
data
to
%
lld
using
bisection
search
"
aTarget
)
;
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
|
|
aAdjustedTarget
>
=
aTarget
)
{
nsresult
res
=
SeekBisection
(
aType
aTarget
aRange
0
)
;
if
(
NS_FAILED
(
res
)
|
|
aType
!
=
TrackInfo
:
:
kVideoTrack
)
{
return
res
;
}
DemuxUntilPacketAvailable
(
aType
mTheoraState
)
;
ogg_packet
*
packet
=
mTheoraState
-
>
PacketPeek
(
)
;
if
(
packet
&
&
!
mTheoraState
-
>
IsKeyframe
(
packet
)
)
{
NS_ASSERTION
(
packet
-
>
granulepos
!
=
-
1
"
Must
have
a
granulepos
"
)
;
int
shift
=
mTheoraState
-
>
mInfo
.
keyframe_granule_shift
;
int64_t
keyframeGranulepos
=
(
packet
-
>
granulepos
>
>
shift
)
<
<
shift
;
int64_t
keyframeTime
=
mTheoraState
-
>
StartTime
(
keyframeGranulepos
)
;
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Keyframe
for
%
lld
is
at
%
lld
seeking
back
to
it
"
frameTime
keyframeTime
)
)
;
aAdjustedTarget
=
std
:
:
min
(
aAdjustedTarget
keyframeTime
)
;
}
}
nsresult
res
=
NS_OK
;
if
(
aAdjustedTarget
<
aTarget
)
{
SeekRange
k
=
SelectSeekRange
(
aType
aRanges
aAdjustedTarget
aStartTime
aEndTime
false
)
;
res
=
SeekBisection
(
aType
aAdjustedTarget
k
OGG_SEEK_FUZZ_USECS
)
;
}
return
res
;
}
nsresult
OggDemuxer
:
:
SeekInUnbuffered
(
TrackInfo
:
:
TrackType
aType
int64_t
aTarget
int64_t
aStartTime
int64_t
aEndTime
const
nsTArray
<
SeekRange
>
&
aRanges
)
{
OGG_DEBUG
(
"
Seeking
in
unbuffered
data
to
%
lld
using
bisection
search
"
aTarget
)
;
int64_t
keyframeOffsetMs
=
0
;
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
mTheoraState
)
{
keyframeOffsetMs
=
mTheoraState
-
>
MaxKeyframeOffset
(
)
;
}
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
mOpusState
)
{
keyframeOffsetMs
=
std
:
:
max
(
keyframeOffsetMs
OGG_SEEK_OPUS_PREROLL
)
;
}
int64_t
seekTarget
=
std
:
:
max
(
aStartTime
aTarget
-
keyframeOffsetMs
)
;
SeekRange
k
=
SelectSeekRange
(
aType
aRanges
seekTarget
aStartTime
aEndTime
false
)
;
return
SeekBisection
(
aType
seekTarget
k
OGG_SEEK_FUZZ_USECS
)
;
}
nsresult
OggDemuxer
:
:
SeekBisection
(
TrackInfo
:
:
TrackType
aType
int64_t
aTarget
const
SeekRange
&
aRange
uint32_t
aFuzz
)
{
nsresult
res
;
if
(
aTarget
<
=
aRange
.
mTimeStart
)
{
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
0
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
return
NS_OK
;
}
ogg_int64_t
startOffset
=
aRange
.
mOffsetStart
;
ogg_int64_t
startTime
=
aRange
.
mTimeStart
;
ogg_int64_t
startLength
=
0
;
ogg_int64_t
endOffset
=
aRange
.
mOffsetEnd
;
ogg_int64_t
endTime
=
aRange
.
mTimeEnd
;
ogg_int64_t
seekTarget
=
aTarget
;
int64_t
seekLowerBound
=
std
:
:
max
(
static_cast
<
int64_t
>
(
0
)
aTarget
-
aFuzz
)
;
int
hops
=
0
;
DebugOnly
<
ogg_int64_t
>
previousGuess
=
-
1
;
int
backsteps
=
0
;
const
int
maxBackStep
=
10
;
NS_ASSERTION
(
static_cast
<
uint64_t
>
(
PAGE_STEP
)
*
pow
(
2
.
0
maxBackStep
)
<
INT32_MAX
"
Backstep
calculation
must
not
overflow
"
)
;
while
(
true
)
{
ogg_int64_t
duration
=
0
;
double
target
=
0
;
ogg_int64_t
interval
=
0
;
ogg_int64_t
guess
=
0
;
ogg_page
page
;
int
skippedBytes
=
0
;
ogg_int64_t
pageOffset
=
0
;
ogg_int64_t
pageLength
=
0
;
ogg_int64_t
granuleTime
=
-
1
;
bool
mustBackoff
=
false
;
while
(
true
)
{
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
interval
=
endOffset
-
startOffset
-
startLength
;
if
(
interval
=
=
0
)
{
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Interval
narrowed
terminating
bisection
.
"
)
)
;
break
;
}
duration
=
endTime
-
startTime
;
target
=
(
double
)
(
seekTarget
-
startTime
)
/
(
double
)
duration
;
guess
=
startOffset
+
startLength
+
static_cast
<
ogg_int64_t
>
(
(
double
)
interval
*
target
)
;
guess
=
std
:
:
min
(
guess
endOffset
-
PAGE_STEP
)
;
if
(
mustBackoff
)
{
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Backing
off
%
d
bytes
backsteps
=
%
d
"
static_cast
<
int32_t
>
(
PAGE_STEP
*
pow
(
2
.
0
backsteps
)
)
backsteps
)
)
;
guess
-
=
PAGE_STEP
*
static_cast
<
ogg_int64_t
>
(
pow
(
2
.
0
backsteps
)
)
;
if
(
guess
<
=
startOffset
)
{
interval
=
0
;
break
;
}
backsteps
=
std
:
:
min
(
backsteps
+
1
maxBackStep
)
;
mustBackoff
=
false
;
}
else
{
backsteps
=
0
;
}
guess
=
std
:
:
max
(
guess
startOffset
+
startLength
)
;
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Seek
loop
start
[
o
=
%
lld
.
.
%
lld
t
=
%
lld
]
"
"
end
[
o
=
%
lld
t
=
%
lld
]
"
"
interval
=
%
lld
target
=
%
lf
guess
=
%
lld
"
startOffset
(
startOffset
+
startLength
)
startTime
endOffset
endTime
interval
target
guess
)
)
;
NS_ASSERTION
(
guess
>
=
startOffset
+
startLength
"
Guess
must
be
after
range
start
"
)
;
NS_ASSERTION
(
guess
<
endOffset
"
Guess
must
be
before
range
end
"
)
;
NS_ASSERTION
(
guess
!
=
previousGuess
"
Guess
should
be
different
to
previous
"
)
;
previousGuess
=
guess
;
hops
+
+
;
PageSyncResult
pageSyncResult
=
PageSync
(
Resource
(
aType
)
OggState
(
aType
)
false
guess
endOffset
&
page
skippedBytes
)
;
NS_ENSURE_TRUE
(
pageSyncResult
!
=
PAGE_SYNC_ERROR
NS_ERROR_FAILURE
)
;
if
(
pageSyncResult
=
=
PAGE_SYNC_END_OF_RANGE
)
{
mustBackoff
=
true
;
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Hit
the
end
of
range
backing
off
"
)
)
;
continue
;
}
pageOffset
=
guess
+
skippedBytes
;
pageLength
=
page
.
header_len
+
page
.
body_len
;
ogg_int64_t
audioTime
=
-
1
;
ogg_int64_t
videoTime
=
-
1
;
do
{
uint32_t
serial
=
ogg_page_serialno
(
&
page
)
;
OggCodecState
*
codecState
=
mCodecStore
.
Get
(
serial
)
;
if
(
codecState
&
&
GetCodecStateType
(
codecState
)
=
=
aType
)
{
if
(
codecState
-
>
mActive
)
{
int
ret
=
ogg_stream_pagein
(
&
codecState
-
>
mState
&
page
)
;
NS_ENSURE_TRUE
(
ret
=
=
0
NS_ERROR_FAILURE
)
;
}
ogg_int64_t
granulepos
=
ogg_page_granulepos
(
&
page
)
;
if
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
granulepos
>
0
&
&
audioTime
=
=
-
1
)
{
if
(
mVorbisState
&
&
serial
=
=
mVorbisState
-
>
mSerial
)
{
audioTime
=
mVorbisState
-
>
Time
(
granulepos
)
;
}
else
if
(
mOpusState
&
&
serial
=
=
mOpusState
-
>
mSerial
)
{
audioTime
=
mOpusState
-
>
Time
(
granulepos
)
;
}
}
if
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
granulepos
>
0
&
&
serial
=
=
mTheoraState
-
>
mSerial
&
&
videoTime
=
=
-
1
)
{
videoTime
=
mTheoraState
-
>
Time
(
granulepos
)
;
}
if
(
pageOffset
+
pageLength
>
=
endOffset
)
{
break
;
}
}
if
(
!
ReadOggPage
(
aType
&
page
)
)
{
break
;
}
}
while
(
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
audioTime
=
=
-
1
)
|
|
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
videoTime
=
=
-
1
)
)
;
if
(
(
aType
=
=
TrackInfo
:
:
kAudioTrack
&
&
audioTime
=
=
-
1
)
|
|
(
aType
=
=
TrackInfo
:
:
kVideoTrack
&
&
videoTime
=
=
-
1
)
)
{
if
(
pageOffset
=
=
startOffset
+
startLength
&
&
pageOffset
+
pageLength
>
=
endOffset
)
{
interval
=
0
;
break
;
}
mustBackoff
=
true
;
continue
;
}
granuleTime
=
aType
=
=
TrackInfo
:
:
kAudioTrack
?
audioTime
:
videoTime
;
NS_ASSERTION
(
granuleTime
>
0
"
Must
get
a
granuletime
"
)
;
break
;
}
if
(
interval
=
=
0
)
{
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Terminating
seek
at
offset
=
%
lld
"
startOffset
)
)
;
NS_ASSERTION
(
startTime
<
aTarget
"
Start
time
must
always
be
less
than
target
"
)
;
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
startOffset
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
break
;
}
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Time
at
offset
%
lld
is
%
lld
"
guess
granuleTime
)
)
;
if
(
granuleTime
<
seekTarget
&
&
granuleTime
>
seekLowerBound
)
{
res
=
Resource
(
aType
)
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
pageOffset
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
NS_FAILED
(
Reset
(
aType
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Terminating
seek
at
offset
=
%
lld
"
pageOffset
)
)
;
break
;
}
if
(
granuleTime
>
=
seekTarget
)
{
NS_ASSERTION
(
pageOffset
<
endOffset
"
offset_end
must
decrease
"
)
;
endOffset
=
pageOffset
;
endTime
=
granuleTime
;
}
else
if
(
granuleTime
<
seekTarget
)
{
NS_ASSERTION
(
pageOffset
>
=
startOffset
+
startLength
"
Bisection
point
should
be
at
or
after
end
of
first
page
in
interval
"
)
;
startOffset
=
pageOffset
;
startLength
=
pageLength
;
startTime
=
granuleTime
;
}
NS_ASSERTION
(
startTime
<
=
seekTarget
"
Must
be
before
seek
target
"
)
;
NS_ASSERTION
(
endTime
>
=
seekTarget
"
End
must
be
after
seek
target
"
)
;
}
SEEK_LOG
(
LogLevel
:
:
Debug
(
"
Seek
complete
in
%
d
bisections
.
"
hops
)
)
;
return
NS_OK
;
}
#
undef
OGG_DEBUG
#
undef
SEEK_DEBUG
}
