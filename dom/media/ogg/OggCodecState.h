#
include
"
Intervals
.
h
"
#
if
!
defined
(
OggCodecState_h_
)
#
define
OggCodecState_h_
#
include
<
ogg
/
ogg
.
h
>
#
include
<
nsClassHashtable
.
h
>
#
include
<
nsDeque
.
h
>
#
include
<
nsTArray
.
h
>
#
include
<
vorbis
/
codec
.
h
>
#
include
"
FlacFrameParser
.
h
"
#
include
"
OggRLBoxTypes
.
h
"
#
include
"
VideoUtils
.
h
"
#
define
VALIDATE_VORBIS_SAMPLE_CALCULATION
#
ifdef
VALIDATE_VORBIS_SAMPLE_CALCULATION
#
include
<
map
>
#
endif
struct
OpusMSDecoder
;
namespace
mozilla
{
inline
constexpr
char
RLBOX_SAFE_DEBUG_ASSERTION
[
]
=
"
Tainted
data
is
being
inspected
only
for
debugging
purposes
.
This
is
not
"
"
a
condition
that
is
critical
for
safety
of
the
renderer
.
"
;
inline
constexpr
char
RLBOX_OGG_STATE_ASSERT_REASON
[
]
=
"
Tainted
data
is
being
inspected
only
to
check
the
internal
state
of
"
"
libogg
structures
.
This
is
not
a
condition
that
is
critical
for
safety
of
"
"
the
renderer
.
"
;
inline
constexpr
char
RLBOX_OGG_PAGE_SERIAL_REASON
[
]
=
"
We
are
checking
the
serial
of
the
page
.
If
libogg
is
operating
correctly
"
"
we
check
serial
numbers
to
make
sure
the
Firefox
renderer
is
correctly
"
"
passing
streams
to
the
correct
source
.
If
libogg
has
been
corrupted
it
"
"
could
return
an
incorrect
serial
however
this
would
mean
that
an
OGG
"
"
file
has
intentionally
corrupted
data
across
multiple
logical
streams
.
"
"
This
however
cannot
compromise
memory
safety
of
the
renderer
.
"
;
class
OpusParser
;
struct
OggPacketDeletePolicy
{
void
operator
(
)
(
ogg_packet
*
aPacket
)
const
{
delete
[
]
aPacket
-
>
packet
;
delete
aPacket
;
}
}
;
using
OggPacketPtr
=
UniquePtr
<
ogg_packet
OggPacketDeletePolicy
>
;
class
OggPacketDeallocator
:
public
nsDequeFunctor
<
ogg_packet
>
{
virtual
void
operator
(
)
(
ogg_packet
*
aPacket
)
override
{
OggPacketDeletePolicy
(
)
(
aPacket
)
;
}
}
;
class
OggPacketQueue
:
private
nsDeque
<
ogg_packet
>
{
public
:
OggPacketQueue
(
)
:
nsDeque
(
new
OggPacketDeallocator
(
)
)
{
}
~
OggPacketQueue
(
)
{
Erase
(
)
;
}
bool
IsEmpty
(
)
{
return
nsDeque
<
ogg_packet
>
:
:
GetSize
(
)
=
=
0
;
}
void
Append
(
OggPacketPtr
aPacket
)
;
OggPacketPtr
PopFront
(
)
{
return
OggPacketPtr
(
nsDeque
<
ogg_packet
>
:
:
PopFront
(
)
)
;
}
ogg_packet
*
PeekFront
(
)
{
return
nsDeque
<
ogg_packet
>
:
:
PeekFront
(
)
;
}
OggPacketPtr
Pop
(
)
{
return
OggPacketPtr
(
nsDeque
<
ogg_packet
>
:
:
Pop
(
)
)
;
}
ogg_packet
*
operator
[
]
(
size_t
aIndex
)
const
{
return
nsDeque
<
ogg_packet
>
:
:
ObjectAt
(
aIndex
)
;
}
size_t
Length
(
)
const
{
return
nsDeque
<
ogg_packet
>
:
:
GetSize
(
)
;
}
void
PushFront
(
OggPacketPtr
aPacket
)
{
nsDeque
<
ogg_packet
>
:
:
PushFront
(
aPacket
.
release
(
)
)
;
}
void
Erase
(
)
{
nsDeque
<
ogg_packet
>
:
:
Erase
(
)
;
}
}
;
class
OggCodecState
{
public
:
using
MetadataTags
=
mozilla
:
:
MetadataTags
;
enum
CodecType
{
TYPE_VORBIS
=
0
TYPE_OPUS
TYPE_SKELETON
TYPE_FLAC
TYPE_UNKNOWN
}
;
virtual
~
OggCodecState
(
)
;
static
UniquePtr
<
OggCodecState
>
Create
(
rlbox_sandbox_ogg
*
aSandbox
tainted_opaque_ogg
<
ogg_page
*
>
aPage
uint32_t
aSerial
)
;
virtual
CodecType
GetType
(
)
{
return
TYPE_UNKNOWN
;
}
virtual
bool
DecodeHeader
(
OggPacketPtr
aPacket
)
{
return
(
mDoneReadingHeaders
=
true
)
;
}
virtual
UniquePtr
<
MetadataTags
>
GetTags
(
)
{
return
nullptr
;
}
using
TimeUnit
=
media
:
:
TimeUnit
;
virtual
TimeUnit
Time
(
int64_t
aGranulepos
)
{
return
TimeUnit
:
:
Invalid
(
)
;
}
virtual
TimeUnit
StartTime
(
int64_t
aGranulepos
)
{
return
TimeUnit
:
:
Invalid
(
)
;
}
virtual
TimeUnit
PacketDuration
(
ogg_packet
*
aPacket
)
{
return
TimeUnit
:
:
Invalid
(
)
;
}
virtual
TimeUnit
PacketStartTime
(
ogg_packet
*
aPacket
)
{
if
(
aPacket
-
>
granulepos
<
0
)
{
return
TimeUnit
:
:
Invalid
(
)
;
}
TimeUnit
endTime
=
Time
(
aPacket
-
>
granulepos
)
;
TimeUnit
duration
=
PacketDuration
(
aPacket
)
;
if
(
!
duration
.
IsValid
(
)
)
{
return
TimeUnit
:
:
Invalid
(
)
;
}
if
(
duration
>
endTime
)
{
return
TimeUnit
:
:
Zero
(
)
;
}
return
endTime
-
duration
;
}
virtual
bool
Init
(
)
{
return
true
;
}
bool
DoneReadingHeaders
(
)
{
return
mDoneReadingHeaders
;
}
void
Deactivate
(
)
{
mActive
=
false
;
mDoneReadingHeaders
=
true
;
Reset
(
)
;
}
virtual
nsresult
Reset
(
)
;
virtual
bool
IsHeader
(
ogg_packet
*
aPacket
)
{
return
false
;
}
virtual
bool
IsKeyframe
(
ogg_packet
*
aPacket
)
{
return
true
;
}
bool
IsPacketReady
(
)
;
OggPacketPtr
PacketOut
(
)
;
ogg_packet
*
PacketPeek
(
)
;
void
PushFront
(
OggPacketQueue
&
&
aOther
)
;
virtual
already_AddRefed
<
MediaRawData
>
PacketOutAsMediaRawData
(
)
;
virtual
nsresult
PageIn
(
tainted_opaque_ogg
<
ogg_page
*
>
aPage
)
;
virtual
TimeUnit
MaxKeyframeOffset
(
)
{
return
TimeUnit
:
:
Zero
(
)
;
}
uint64_t
mPacketCount
;
uint32_t
mSerial
;
tainted_opaque_ogg
<
ogg_stream_state
*
>
mState
;
OggPacketQueue
mPackets
;
bool
mActive
;
bool
mDoneReadingHeaders
;
rlbox_sandbox_ogg
*
mSandbox
;
virtual
const
TrackInfo
*
GetInfo
(
)
const
{
MOZ_RELEASE_ASSERT
(
false
"
Can
'
t
be
called
directly
"
)
;
return
nullptr
;
}
static
bool
IsValidVorbisTagName
(
nsCString
&
aName
)
;
static
bool
AddVorbisComment
(
UniquePtr
<
MetadataTags
>
&
aTags
const
char
*
aComment
uint32_t
aLength
)
;
protected
:
OggCodecState
(
rlbox_sandbox_ogg
*
aSandbox
tainted_opaque_ogg
<
ogg_page
*
>
aBosPage
uint32_t
aSerial
bool
aActive
)
;
void
ClearUnstamped
(
)
;
nsresult
PacketOutUntilGranulepos
(
bool
&
aFoundGranulepos
)
;
nsTArray
<
OggPacketPtr
>
mUnstamped
;
bool
SetCodecSpecificConfig
(
MediaByteBuffer
*
aBuffer
OggPacketQueue
&
aHeaders
)
;
private
:
bool
InternalInit
(
)
;
}
;
class
VorbisState
:
public
OggCodecState
{
public
:
explicit
VorbisState
(
rlbox_sandbox_ogg
*
aSandbox
tainted_opaque_ogg
<
ogg_page
*
>
aBosPage
uint32_t
aSerial
)
;
virtual
~
VorbisState
(
)
;
CodecType
GetType
(
)
override
{
return
TYPE_VORBIS
;
}
bool
DecodeHeader
(
OggPacketPtr
aPacket
)
override
;
TimeUnit
Time
(
int64_t
aGranulepos
)
override
;
TimeUnit
PacketDuration
(
ogg_packet
*
aPacket
)
override
;
bool
Init
(
)
override
;
nsresult
Reset
(
)
override
;
bool
IsHeader
(
ogg_packet
*
aPacket
)
override
;
nsresult
PageIn
(
tainted_opaque_ogg
<
ogg_page
*
>
aPage
)
override
;
const
TrackInfo
*
GetInfo
(
)
const
override
{
return
&
mInfo
;
}
UniquePtr
<
MetadataTags
>
GetTags
(
)
override
;
private
:
AudioInfo
mInfo
;
vorbis_info
mVorbisInfo
=
{
}
;
vorbis_comment
mComment
=
{
}
;
vorbis_dsp_state
mDsp
=
{
}
;
vorbis_block
mBlock
=
{
}
;
OggPacketQueue
mHeaders
;
static
TimeUnit
Time
(
vorbis_info
*
aInfo
int64_t
aGranulePos
)
;
void
ReconstructVorbisGranulepos
(
)
;
long
mPrevVorbisBlockSize
;
int64_t
mGranulepos
;
#
ifdef
VALIDATE_VORBIS_SAMPLE_CALCULATION
std
:
:
map
<
ogg_packet
*
long
>
mVorbisPacketSamples
;
#
endif
void
RecordVorbisPacketSamples
(
ogg_packet
*
aPacket
long
aSamples
)
;
void
AssertHasRecordedPacketSamples
(
ogg_packet
*
aPacket
)
;
public
:
void
ValidateVorbisPacketSamples
(
ogg_packet
*
aPacket
long
aSamples
)
;
}
;
class
OpusState
:
public
OggCodecState
{
public
:
explicit
OpusState
(
rlbox_sandbox_ogg
*
aSandbox
tainted_opaque_ogg
<
ogg_page
*
>
aBosPage
uint32_t
aSerial
)
;
virtual
~
OpusState
(
)
;
CodecType
GetType
(
)
override
{
return
TYPE_OPUS
;
}
bool
DecodeHeader
(
OggPacketPtr
aPacket
)
override
;
TimeUnit
Time
(
int64_t
aGranulepos
)
override
;
TimeUnit
PacketDuration
(
ogg_packet
*
aPacket
)
override
;
bool
Init
(
)
override
;
nsresult
Reset
(
)
override
;
nsresult
Reset
(
bool
aStart
)
;
bool
IsHeader
(
ogg_packet
*
aPacket
)
override
;
nsresult
PageIn
(
tainted_opaque_ogg
<
ogg_page
*
>
aPage
)
override
;
already_AddRefed
<
MediaRawData
>
PacketOutAsMediaRawData
(
)
override
;
const
TrackInfo
*
GetInfo
(
)
const
override
{
return
&
mInfo
;
}
static
TimeUnit
Time
(
int
aPreSkip
int64_t
aGranulepos
)
;
UniquePtr
<
MetadataTags
>
GetTags
(
)
override
;
private
:
UniquePtr
<
OpusParser
>
mParser
;
OpusMSDecoder
*
mDecoder
;
int64_t
mPrevPacketGranulepos
;
bool
ReconstructOpusGranulepos
(
)
;
int64_t
mPrevPageGranulepos
;
AudioInfo
mInfo
;
OggPacketQueue
mHeaders
;
}
;
#
define
SKELETON_VERSION
(
major
minor
)
(
(
(
major
)
<
<
16
)
|
(
minor
)
)
enum
EMsgHeaderType
{
eContentType
eRole
eName
eLanguage
eTitle
eDisplayHint
eAltitude
eTrackOrder
eTrackDependencies
}
;
struct
FieldPatternType
{
const
char
*
mPatternToRecognize
;
EMsgHeaderType
mMsgHeaderType
;
}
;
struct
MessageField
{
nsClassHashtable
<
nsUint32HashKey
nsCString
>
mValuesStore
;
}
;
class
SkeletonState
:
public
OggCodecState
{
public
:
explicit
SkeletonState
(
rlbox_sandbox_ogg
*
aSandbox
tainted_opaque_ogg
<
ogg_page
*
>
aBosPage
uint32_t
aSerial
)
;
~
SkeletonState
(
)
;
nsClassHashtable
<
nsUint32HashKey
MessageField
>
mMsgFieldStore
;
CodecType
GetType
(
)
override
{
return
TYPE_SKELETON
;
}
bool
DecodeHeader
(
OggPacketPtr
aPacket
)
override
;
TimeUnit
Time
(
int64_t
aGranulepos
)
override
{
return
TimeUnit
:
:
Invalid
(
)
;
}
bool
IsHeader
(
ogg_packet
*
aPacket
)
override
{
return
true
;
}
bool
IsPresentable
(
int64_t
aTime
)
{
return
aTime
>
=
mPresentationTime
;
}
class
nsKeyPoint
{
public
:
nsKeyPoint
(
)
:
mOffset
(
INT64_MAX
)
mTime
(
TimeUnit
:
:
Invalid
(
)
)
{
}
nsKeyPoint
(
int64_t
aOffset
TimeUnit
aTime
)
:
mOffset
(
aOffset
)
mTime
(
aTime
)
{
}
int64_t
mOffset
;
TimeUnit
mTime
;
bool
IsNull
(
)
{
return
mOffset
=
=
INT64_MAX
&
&
!
mTime
.
IsValid
(
)
;
}
}
;
class
nsSeekTarget
{
public
:
nsSeekTarget
(
)
:
mSerial
(
0
)
{
}
nsKeyPoint
mKeyPoint
;
uint32_t
mSerial
;
bool
IsNull
(
)
{
return
mKeyPoint
.
IsNull
(
)
&
&
mSerial
=
=
0
;
}
}
;
nsresult
IndexedSeekTarget
(
const
TimeUnit
&
aTarget
nsTArray
<
uint32_t
>
&
aTracks
nsSeekTarget
&
aResult
)
;
bool
HasIndex
(
)
const
{
return
mIndex
.
Count
(
)
>
0
;
}
nsresult
GetDuration
(
const
nsTArray
<
uint32_t
>
&
aTracks
TimeUnit
&
aDuration
)
;
private
:
bool
DecodeIndex
(
ogg_packet
*
aPacket
)
;
bool
DecodeFisbone
(
ogg_packet
*
aPacket
)
;
nsresult
IndexedSeekTargetForTrack
(
uint32_t
aSerialno
const
TimeUnit
&
aTarget
nsKeyPoint
&
aResult
)
;
uint32_t
mVersion
;
int64_t
mPresentationTime
;
int64_t
mLength
;
class
nsKeyFrameIndex
{
public
:
nsKeyFrameIndex
(
const
TimeUnit
&
aStartTime
const
TimeUnit
&
aEndTime
)
:
mStartTime
(
aStartTime
)
mEndTime
(
aEndTime
)
{
MOZ_COUNT_CTOR
(
nsKeyFrameIndex
)
;
}
MOZ_COUNTED_DTOR
(
nsKeyFrameIndex
)
void
Add
(
int64_t
aOffset
const
TimeUnit
&
aTime
)
{
mKeyPoints
.
AppendElement
(
nsKeyPoint
(
aOffset
aTime
)
)
;
}
const
nsKeyPoint
&
Get
(
uint32_t
aIndex
)
const
{
return
mKeyPoints
[
aIndex
]
;
}
uint32_t
Length
(
)
const
{
return
mKeyPoints
.
Length
(
)
;
}
const
TimeUnit
mStartTime
;
const
TimeUnit
mEndTime
;
private
:
nsTArray
<
nsKeyPoint
>
mKeyPoints
;
}
;
nsClassHashtable
<
nsUint32HashKey
nsKeyFrameIndex
>
mIndex
;
}
;
class
FlacState
:
public
OggCodecState
{
public
:
explicit
FlacState
(
rlbox_sandbox_ogg
*
aSandbox
tainted_opaque_ogg
<
ogg_page
*
>
aBosPage
uint32_t
aSerial
)
;
CodecType
GetType
(
)
override
{
return
TYPE_FLAC
;
}
bool
DecodeHeader
(
OggPacketPtr
aPacket
)
override
;
TimeUnit
Time
(
int64_t
aGranulepos
)
override
;
TimeUnit
PacketDuration
(
ogg_packet
*
aPacket
)
override
;
bool
IsHeader
(
ogg_packet
*
aPacket
)
override
;
nsresult
PageIn
(
tainted_opaque_ogg
<
ogg_page
*
>
aPage
)
override
;
UniquePtr
<
MetadataTags
>
GetTags
(
)
override
;
const
TrackInfo
*
GetInfo
(
)
const
override
;
private
:
bool
ReconstructFlacGranulepos
(
void
)
;
FlacFrameParser
mParser
;
}
;
}
#
endif
