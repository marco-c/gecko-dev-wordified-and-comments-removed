#
ifndef
mozilla_GraphRunner_h
#
define
mozilla_GraphRunner_h
#
include
"
GraphDriver
.
h
"
#
include
"
MediaSegment
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
<
thread
>
struct
PRThread
;
namespace
mozilla
{
class
AudioMixer
;
class
MediaTrackGraphImpl
;
class
GraphRunner
final
:
public
Runnable
{
using
IterationResult
=
GraphInterface
:
:
IterationResult
;
public
:
static
already_AddRefed
<
GraphRunner
>
Create
(
MediaTrackGraphImpl
*
aGraph
)
;
MOZ_CAN_RUN_SCRIPT
void
Shutdown
(
)
;
IterationResult
OneIteration
(
GraphTime
aStateTime
GraphTime
aIterationEnd
AudioMixer
*
aMixer
)
;
NS_IMETHOD
Run
(
)
override
;
bool
OnThread
(
)
const
;
#
ifdef
DEBUG
bool
InDriverIteration
(
const
GraphDriver
*
aDriver
)
const
;
#
endif
private
:
explicit
GraphRunner
(
MediaTrackGraphImpl
*
aGraph
already_AddRefed
<
nsIThread
>
aThread
)
;
~
GraphRunner
(
)
;
class
IterationState
{
GraphTime
mStateTime
;
GraphTime
mIterationEnd
;
AudioMixer
*
MOZ_NON_OWNING_REF
mMixer
;
public
:
IterationState
(
GraphTime
aStateTime
GraphTime
aIterationEnd
AudioMixer
*
aMixer
)
:
mStateTime
(
aStateTime
)
mIterationEnd
(
aIterationEnd
)
mMixer
(
aMixer
)
{
}
IterationState
&
operator
=
(
const
IterationState
&
aOther
)
=
default
;
GraphTime
StateTime
(
)
const
{
return
mStateTime
;
}
GraphTime
IterationEnd
(
)
const
{
return
mIterationEnd
;
}
AudioMixer
*
Mixer
(
)
const
{
return
mMixer
;
}
}
;
Monitor
mMonitor
;
MediaTrackGraphImpl
*
const
mGraph
;
Maybe
<
IterationState
>
mIterationState
GUARDED_BY
(
mMonitor
)
;
IterationResult
mIterationResult
GUARDED_BY
(
mMonitor
)
;
enum
class
ThreadState
{
Wait
Run
Shutdown
}
;
ThreadState
mThreadState
GUARDED_BY
(
mMonitor
)
;
const
nsCOMPtr
<
nsIThread
>
mThread
;
#
ifdef
DEBUG
std
:
:
thread
:
:
id
mAudioDriverThreadId
=
std
:
:
thread
:
:
id
(
)
;
nsIThread
*
mClockDriverThread
=
nullptr
;
#
endif
}
;
}
#
endif
