#
ifndef
MediaEngineWebRTCAudio_h
#
define
MediaEngineWebRTCAudio_h
#
include
"
AudioPacketizer
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
AudioDeviceInfo
.
h
"
#
include
"
MediaEngineWebRTC
.
h
"
#
include
"
MediaTrackListener
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
audio_processing
.
h
"
namespace
mozilla
{
class
AudioInputProcessing
;
class
AudioProcessingTrack
;
class
MediaEngineWebRTCMicrophoneSource
:
public
MediaEngineSource
{
public
:
explicit
MediaEngineWebRTCMicrophoneSource
(
const
MediaDevice
*
aMediaDevice
)
;
nsresult
Allocate
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
uint64_t
aWindowID
const
char
*
*
aOutBadConstraint
)
override
;
nsresult
Deallocate
(
)
override
;
void
SetTrack
(
const
RefPtr
<
MediaTrack
>
&
aTrack
const
PrincipalHandle
&
aPrincipal
)
override
;
nsresult
Start
(
)
override
;
nsresult
Stop
(
)
override
;
nsresult
Reconfigure
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
char
*
*
aOutBadConstraint
)
override
;
void
GetSettings
(
dom
:
:
MediaTrackSettings
&
aOutSettings
)
const
override
;
nsresult
TakePhoto
(
MediaEnginePhotoCallback
*
aCallback
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
protected
:
~
MediaEngineWebRTCMicrophoneSource
(
)
=
default
;
private
:
nsresult
EvaluateSettings
(
const
NormalizedConstraints
&
aConstraintsUpdate
const
MediaEnginePrefs
&
aInPrefs
MediaEnginePrefs
*
aOutPrefs
const
char
*
*
aOutBadConstraint
)
;
void
ApplySettings
(
const
MediaEnginePrefs
&
aPrefs
)
;
PrincipalHandle
mPrincipal
=
PRINCIPAL_HANDLE_NONE
;
const
RefPtr
<
AudioDeviceInfo
>
mDeviceInfo
;
const
uint32_t
mDeviceMaxChannelCount
;
const
nsMainThreadPtrHandle
<
media
:
:
Refcountable
<
dom
:
:
MediaTrackSettings
>
>
mSettings
;
MediaEngineSourceState
mState
;
MediaEnginePrefs
mCurrentPrefs
;
RefPtr
<
AudioProcessingTrack
>
mTrack
;
RefPtr
<
AudioInputProcessing
>
mInputProcessing
;
webrtc
:
:
AudioProcessing
:
:
Config
mAudioProcessingConfig
;
}
;
class
AudioInputProcessing
:
public
AudioDataListener
{
public
:
explicit
AudioInputProcessing
(
uint32_t
aMaxChannelCount
)
;
void
Process
(
MediaTrackGraphImpl
*
aGraph
GraphTime
aFrom
GraphTime
aTo
AudioSegment
*
aInput
AudioSegment
*
aOutput
)
;
void
ProcessOutputData
(
MediaTrackGraphImpl
*
aGraph
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
;
bool
IsVoiceInput
(
MediaTrackGraphImpl
*
aGraph
)
const
override
{
return
!
PassThrough
(
aGraph
)
;
}
void
Start
(
MediaTrackGraphImpl
*
aGraph
)
;
void
Stop
(
MediaTrackGraphImpl
*
aGraph
)
;
void
DeviceChanged
(
MediaTrackGraphImpl
*
aGraph
)
override
;
uint32_t
RequestedInputChannelCount
(
MediaTrackGraphImpl
*
)
override
{
return
GetRequestedInputChannelCount
(
)
;
}
void
Disconnect
(
MediaTrackGraphImpl
*
aGraph
)
override
;
void
PacketizeAndProcess
(
MediaTrackGraphImpl
*
aGraph
const
AudioSegment
&
aSegment
)
;
void
SetPassThrough
(
MediaTrackGraphImpl
*
aGraph
bool
aPassThrough
)
;
uint32_t
GetRequestedInputChannelCount
(
)
;
void
SetRequestedInputChannelCount
(
MediaTrackGraphImpl
*
aGraph
uint32_t
aRequestedInputChannelCount
)
;
bool
PassThrough
(
MediaTrackGraphImpl
*
aGraphImpl
)
const
;
void
ApplyConfig
(
MediaTrackGraphImpl
*
aGraph
const
webrtc
:
:
AudioProcessing
:
:
Config
&
aConfig
)
;
void
End
(
)
;
TrackTime
NumBufferedFrames
(
MediaTrackGraphImpl
*
aGraph
)
const
;
constexpr
static
uint32_t
GetPacketSize
(
TrackRate
aRate
)
{
return
static_cast
<
uint32_t
>
(
aRate
)
/
100u
;
}
bool
IsEnded
(
)
const
{
return
mEnded
;
}
private
:
~
AudioInputProcessing
(
)
=
default
;
void
EnsureAudioProcessing
(
MediaTrackGraphImpl
*
aGraph
uint32_t
aChannels
)
;
void
ResetAudioProcessing
(
MediaTrackGraphImpl
*
aGraph
)
;
PrincipalHandle
GetCheckedPrincipal
(
const
AudioSegment
&
aSegment
)
;
const
UniquePtr
<
webrtc
:
:
AudioProcessing
>
mAudioProcessing
;
Maybe
<
AudioPacketizer
<
AudioDataValue
float
>
>
mPacketizerInput
;
Maybe
<
AudioPacketizer
<
AudioDataValue
float
>
>
mPacketizerOutput
;
uint32_t
mRequestedInputChannelCount
;
bool
mSkipProcessing
;
AlignedFloatBuffer
mOutputBuffer
;
AlignedFloatBuffer
mInputBuffer
;
AlignedFloatBuffer
mDeinterleavedBuffer
;
AlignedFloatBuffer
mInputDownmixBuffer
;
AudioSegment
mSegment
;
bool
mEnabled
;
bool
mEnded
;
uint64_t
mPacketCount
;
AutoTArray
<
AudioDataValue
SilentChannel
:
:
AUDIO_PROCESSING_FRAMES
*
GUESS_AUDIO_CHANNELS
>
mInterleavedBuffer
;
std
:
:
deque
<
std
:
:
pair
<
TrackTime
PrincipalHandle
>
>
mChunksInPacketizer
;
}
;
class
AudioProcessingTrack
:
public
ProcessedMediaTrack
{
RefPtr
<
AudioInputProcessing
>
mInputProcessing
;
RefPtr
<
MediaInputPort
>
mPort
;
RefPtr
<
AudioDataListener
>
mInputListener
;
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
mDeviceId
;
explicit
AudioProcessingTrack
(
TrackRate
aSampleRate
)
:
ProcessedMediaTrack
(
aSampleRate
MediaSegment
:
:
AUDIO
new
AudioSegment
(
)
)
{
}
~
AudioProcessingTrack
(
)
=
default
;
public
:
nsresult
ConnectDeviceInput
(
CubebUtils
:
:
AudioDeviceID
aId
AudioDataListener
*
aListener
const
PrincipalHandle
&
aPrincipal
)
;
void
DisconnectDeviceInput
(
)
;
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
DeviceId
(
)
const
;
void
Destroy
(
)
override
;
void
SetInputProcessing
(
RefPtr
<
AudioInputProcessing
>
aInputProcessing
)
;
static
AudioProcessingTrack
*
Create
(
MediaTrackGraph
*
aGraph
)
;
void
DestroyImpl
(
)
override
;
void
ProcessInput
(
GraphTime
aFrom
GraphTime
aTo
uint32_t
aFlags
)
override
;
uint32_t
NumberOfChannels
(
)
const
override
{
MOZ_DIAGNOSTIC_ASSERT
(
mInputProcessing
"
Must
set
mInputProcessing
before
exposing
to
content
"
)
;
return
mInputProcessing
-
>
GetRequestedInputChannelCount
(
)
;
}
void
GetInputSourceData
(
AudioSegment
&
aOutput
const
MediaInputPort
*
aPort
GraphTime
aFrom
GraphTime
aTo
)
const
;
void
NotifyOutputData
(
MediaTrackGraphImpl
*
aGraph
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
;
AudioProcessingTrack
*
AsAudioProcessingTrack
(
)
override
{
return
this
;
}
private
:
void
SetInputProcessingImpl
(
RefPtr
<
AudioInputProcessing
>
aInputProcessing
)
;
}
;
class
MediaEngineWebRTCAudioCaptureSource
:
public
MediaEngineSource
{
public
:
explicit
MediaEngineWebRTCAudioCaptureSource
(
const
MediaDevice
*
aMediaDevice
)
;
static
nsString
GetUUID
(
)
;
static
nsString
GetGroupId
(
)
;
nsresult
Allocate
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
uint64_t
aWindowID
const
char
*
*
aOutBadConstraint
)
override
{
return
NS_OK
;
}
nsresult
Deallocate
(
)
override
{
return
NS_OK
;
}
void
SetTrack
(
const
RefPtr
<
MediaTrack
>
&
aTrack
const
PrincipalHandle
&
aPrincipal
)
override
;
nsresult
Start
(
)
override
;
nsresult
Stop
(
)
override
;
nsresult
Reconfigure
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
char
*
*
aOutBadConstraint
)
override
;
nsresult
TakePhoto
(
MediaEnginePhotoCallback
*
aCallback
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
void
GetSettings
(
dom
:
:
MediaTrackSettings
&
aOutSettings
)
const
override
;
protected
:
virtual
~
MediaEngineWebRTCAudioCaptureSource
(
)
=
default
;
}
;
}
#
endif
