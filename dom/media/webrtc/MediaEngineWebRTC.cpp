#
include
"
MediaEngineWebRTC
.
h
"
#
include
"
CamerasChild
.
h
"
#
include
"
CSFLog
.
h
"
#
include
"
MediaEngineRemoteVideoSource
.
h
"
#
include
"
MediaEngineWebRTCAudio
.
h
"
#
include
"
MediaManager
.
h
"
#
include
"
MediaTrackConstraints
.
h
"
#
include
"
mozilla
/
dom
/
MediaDeviceInfo
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsIComponentRegistrar
.
h
"
#
include
"
prenv
.
h
"
#
define
FAKE_ONDEVICECHANGE_EVENT_PERIOD_IN_MS
500
static
mozilla
:
:
LazyLogModule
sGetUserMediaLog
(
"
GetUserMedia
"
)
;
#
undef
LOG
#
define
LOG
(
args
)
MOZ_LOG
(
sGetUserMediaLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
namespace
mozilla
{
using
camera
:
:
CamerasChild
;
using
camera
:
:
GetChildAndCall
;
using
dom
:
:
MediaSourceEnum
;
CubebDeviceEnumerator
*
GetEnumerator
(
)
{
return
CubebDeviceEnumerator
:
:
GetInstance
(
)
;
}
MediaEngineWebRTC
:
:
MediaEngineWebRTC
(
)
{
AssertIsOnOwningThread
(
)
;
GetChildAndCall
(
&
CamerasChild
:
:
ConnectDeviceListChangeListener
<
MediaEngineWebRTC
>
&
mCameraListChangeListener
AbstractThread
:
:
MainThread
(
)
this
&
MediaEngineWebRTC
:
:
DeviceListChanged
)
;
mMicrophoneListChangeListener
=
GetEnumerator
(
)
-
>
OnAudioInputDeviceListChange
(
)
.
Connect
(
AbstractThread
:
:
MainThread
(
)
this
&
MediaEngineWebRTC
:
:
DeviceListChanged
)
;
mSpeakerListChangeListener
=
GetEnumerator
(
)
-
>
OnAudioOutputDeviceListChange
(
)
.
Connect
(
AbstractThread
:
:
MainThread
(
)
this
&
MediaEngineWebRTC
:
:
DeviceListChanged
)
;
}
void
MediaEngineWebRTC
:
:
SetFakeDeviceChangeEventsEnabled
(
bool
aEnable
)
{
AssertIsOnOwningThread
(
)
;
if
(
aEnable
&
&
!
mFakeDeviceChangeEventTimer
)
{
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
mFakeDeviceChangeEventTimer
)
&
FakeDeviceChangeEventTimerTick
this
FAKE_ONDEVICECHANGE_EVENT_PERIOD_IN_MS
nsITimer
:
:
TYPE_REPEATING_SLACK
"
MediaEngineWebRTC
:
:
mFakeDeviceChangeEventTimer
"
GetCurrentSerialEventTarget
(
)
)
;
return
;
}
if
(
!
aEnable
&
&
mFakeDeviceChangeEventTimer
)
{
mFakeDeviceChangeEventTimer
-
>
Cancel
(
)
;
mFakeDeviceChangeEventTimer
=
nullptr
;
return
;
}
}
void
MediaEngineWebRTC
:
:
EnumerateVideoDevices
(
MediaSourceEnum
aMediaSource
nsTArray
<
RefPtr
<
MediaDevice
>
>
*
aDevices
)
{
AssertIsOnOwningThread
(
)
;
bool
scaryKind
=
(
aMediaSource
=
=
MediaSourceEnum
:
:
Screen
|
|
aMediaSource
=
=
MediaSourceEnum
:
:
Browser
)
;
int
num
;
#
if
defined
(
_ARM64_
)
&
&
defined
(
XP_WIN
)
if
(
aMediaSource
=
=
MediaSourceEnum
:
:
Camera
)
{
typedef
ULONG
(
*
RtlGetVersionFn
)
(
LPOSVERSIONINFOEXW
)
;
RtlGetVersionFn
RtlGetVersion
;
RtlGetVersion
=
(
RtlGetVersionFn
)
GetProcAddress
(
GetModuleHandleA
(
"
ntdll
"
)
"
RtlGetVersion
"
)
;
if
(
RtlGetVersion
)
{
OSVERSIONINFOEXW
info
;
info
.
dwOSVersionInfoSize
=
sizeof
(
info
)
;
RtlGetVersion
(
&
info
)
;
if
(
info
.
dwBuildNumber
<
18346
)
{
return
;
}
}
}
#
endif
camera
:
:
CaptureEngine
capEngine
=
MediaEngineRemoteVideoSource
:
:
CaptureEngine
(
aMediaSource
)
;
num
=
GetChildAndCall
(
&
CamerasChild
:
:
NumberOfCaptureDevices
capEngine
)
;
for
(
int
i
=
0
;
i
<
num
;
i
+
+
)
{
char
deviceName
[
MediaEngineSource
:
:
kMaxDeviceNameLength
]
;
char
uniqueId
[
MediaEngineSource
:
:
kMaxUniqueIdLength
]
;
bool
scarySource
=
false
;
deviceName
[
0
]
=
'
\
0
'
;
uniqueId
[
0
]
=
'
\
0
'
;
int
error
;
error
=
GetChildAndCall
(
&
CamerasChild
:
:
GetCaptureDevice
capEngine
i
deviceName
sizeof
(
deviceName
)
uniqueId
sizeof
(
uniqueId
)
&
scarySource
)
;
if
(
error
)
{
LOG
(
(
"
camera
:
GetCaptureDevice
:
Failed
%
d
"
error
)
)
;
continue
;
}
#
ifdef
DEBUG
LOG
(
(
"
Capture
Device
Index
%
d
Name
%
s
"
i
deviceName
)
)
;
webrtc
:
:
CaptureCapability
cap
;
int
numCaps
=
GetChildAndCall
(
&
CamerasChild
:
:
NumberOfCapabilities
capEngine
uniqueId
)
;
LOG
(
(
"
Number
of
Capabilities
%
d
"
numCaps
)
)
;
for
(
int
j
=
0
;
j
<
numCaps
;
j
+
+
)
{
if
(
GetChildAndCall
(
&
CamerasChild
:
:
GetCaptureCapability
capEngine
uniqueId
j
&
cap
)
!
=
0
)
{
break
;
}
LOG
(
(
"
type
=
%
d
width
=
%
d
height
=
%
d
maxFPS
=
%
d
"
static_cast
<
int
>
(
cap
.
videoType
)
cap
.
width
cap
.
height
cap
.
maxFPS
)
)
;
}
#
endif
NS_ConvertUTF8toUTF16
name
(
deviceName
)
;
NS_ConvertUTF8toUTF16
uuid
(
uniqueId
)
;
aDevices
-
>
EmplaceBack
(
new
MediaDevice
(
this
aMediaSource
name
uuid
uuid
MediaDevice
:
:
IsScary
(
scaryKind
|
|
scarySource
)
)
)
;
}
}
void
MediaEngineWebRTC
:
:
EnumerateMicrophoneDevices
(
nsTArray
<
RefPtr
<
MediaDevice
>
>
*
aDevices
)
{
AssertIsOnOwningThread
(
)
;
nsTArray
<
RefPtr
<
AudioDeviceInfo
>
>
devices
;
GetEnumerator
(
)
-
>
EnumerateAudioInputDevices
(
devices
)
;
DebugOnly
<
bool
>
foundPreferredDevice
=
false
;
for
(
uint32_t
i
=
0
;
i
<
devices
.
Length
(
)
;
i
+
+
)
{
#
ifndef
ANDROID
MOZ_ASSERT
(
devices
[
i
]
-
>
DeviceID
(
)
)
;
#
endif
LOG
(
(
"
Cubeb
device
%
u
:
type
0x
%
x
state
0x
%
x
name
%
s
id
%
p
"
i
devices
[
i
]
-
>
Type
(
)
devices
[
i
]
-
>
State
(
)
NS_ConvertUTF16toUTF8
(
devices
[
i
]
-
>
Name
(
)
)
.
get
(
)
devices
[
i
]
-
>
DeviceID
(
)
)
)
;
if
(
devices
[
i
]
-
>
State
(
)
=
=
CUBEB_DEVICE_STATE_ENABLED
)
{
MOZ_ASSERT
(
devices
[
i
]
-
>
Type
(
)
=
=
CUBEB_DEVICE_TYPE_INPUT
)
;
RefPtr
device
=
new
MediaDevice
(
this
devices
[
i
]
devices
[
i
]
-
>
Name
(
)
)
;
if
(
devices
[
i
]
-
>
Preferred
(
)
)
{
#
ifdef
DEBUG
if
(
!
foundPreferredDevice
)
{
foundPreferredDevice
=
true
;
}
else
{
#
ifndef
XP_WIN
MOZ_ASSERT
(
!
foundPreferredDevice
"
Found
more
than
one
preferred
audio
input
device
"
"
while
enumerating
"
)
;
#
endif
}
#
endif
aDevices
-
>
InsertElementAt
(
0
std
:
:
move
(
device
)
)
;
}
else
{
aDevices
-
>
AppendElement
(
std
:
:
move
(
device
)
)
;
}
}
}
}
void
MediaEngineWebRTC
:
:
EnumerateSpeakerDevices
(
nsTArray
<
RefPtr
<
MediaDevice
>
>
*
aDevices
)
{
AssertIsOnOwningThread
(
)
;
nsTArray
<
RefPtr
<
AudioDeviceInfo
>
>
devices
;
GetEnumerator
(
)
-
>
EnumerateAudioOutputDevices
(
devices
)
;
#
ifndef
XP_WIN
DebugOnly
<
bool
>
preferredDeviceFound
=
false
;
#
endif
for
(
const
auto
&
deviceInfo
:
devices
)
{
if
(
deviceInfo
-
>
State
(
)
=
=
CUBEB_DEVICE_STATE_ENABLED
)
{
MOZ_ASSERT
(
deviceInfo
-
>
Type
(
)
=
=
CUBEB_DEVICE_TYPE_OUTPUT
)
;
nsString
uuid
(
deviceInfo
-
>
Name
(
)
)
;
uuid
.
Append
(
u
"
_Speaker
"
_ns
)
;
RefPtr
device
=
new
MediaDevice
(
this
deviceInfo
uuid
)
;
if
(
deviceInfo
-
>
Preferred
(
)
)
{
#
if
defined
(
DEBUG
)
&
&
!
defined
(
XP_WIN
)
MOZ_ASSERT
(
!
preferredDeviceFound
"
More
than
one
preferred
device
"
)
;
preferredDeviceFound
=
true
;
#
endif
aDevices
-
>
InsertElementAt
(
0
std
:
:
move
(
device
)
)
;
}
else
{
aDevices
-
>
AppendElement
(
std
:
:
move
(
device
)
)
;
}
}
}
}
void
MediaEngineWebRTC
:
:
EnumerateDevices
(
MediaSourceEnum
aMediaSource
MediaSinkEnum
aMediaSink
nsTArray
<
RefPtr
<
MediaDevice
>
>
*
aDevices
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aMediaSource
!
=
MediaSourceEnum
:
:
Other
|
|
aMediaSink
!
=
MediaSinkEnum
:
:
Other
)
;
if
(
MediaEngineSource
:
:
IsVideo
(
aMediaSource
)
)
{
switch
(
aMediaSource
)
{
case
MediaSourceEnum
:
:
Window
:
EnumerateVideoDevices
(
MediaSourceEnum
:
:
Window
aDevices
)
;
EnumerateVideoDevices
(
MediaSourceEnum
:
:
Browser
aDevices
)
;
EnumerateVideoDevices
(
MediaSourceEnum
:
:
Screen
aDevices
)
;
break
;
case
MediaSourceEnum
:
:
Screen
:
case
MediaSourceEnum
:
:
Browser
:
case
MediaSourceEnum
:
:
Camera
:
EnumerateVideoDevices
(
aMediaSource
aDevices
)
;
break
;
default
:
MOZ_CRASH
(
"
No
valid
video
source
"
)
;
break
;
}
}
else
if
(
aMediaSource
=
=
MediaSourceEnum
:
:
AudioCapture
)
{
aDevices
-
>
EmplaceBack
(
new
MediaDevice
(
this
aMediaSource
u
"
AudioCapture
"
_ns
MediaEngineWebRTCAudioCaptureSource
:
:
GetUUID
(
)
MediaEngineWebRTCAudioCaptureSource
:
:
GetGroupId
(
)
MediaDevice
:
:
IsScary
:
:
No
)
)
;
}
else
if
(
aMediaSource
=
=
MediaSourceEnum
:
:
Microphone
)
{
EnumerateMicrophoneDevices
(
aDevices
)
;
}
if
(
aMediaSink
=
=
MediaSinkEnum
:
:
Speaker
)
{
EnumerateSpeakerDevices
(
aDevices
)
;
}
}
RefPtr
<
MediaEngineSource
>
MediaEngineWebRTC
:
:
CreateSource
(
const
MediaDevice
*
aMediaDevice
)
{
MOZ_ASSERT
(
aMediaDevice
-
>
mEngine
=
=
this
)
;
if
(
MediaEngineSource
:
:
IsVideo
(
aMediaDevice
-
>
mMediaSource
)
)
{
return
new
MediaEngineRemoteVideoSource
(
aMediaDevice
)
;
}
switch
(
aMediaDevice
-
>
mMediaSource
)
{
case
MediaSourceEnum
:
:
AudioCapture
:
return
new
MediaEngineWebRTCAudioCaptureSource
(
aMediaDevice
)
;
case
MediaSourceEnum
:
:
Microphone
:
return
new
MediaEngineWebRTCMicrophoneSource
(
aMediaDevice
)
;
default
:
MOZ_CRASH
(
"
Unsupported
source
type
"
)
;
return
nullptr
;
}
}
void
MediaEngineWebRTC
:
:
Shutdown
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mFakeDeviceChangeEventTimer
)
;
mCameraListChangeListener
.
DisconnectIfExists
(
)
;
mMicrophoneListChangeListener
.
DisconnectIfExists
(
)
;
mSpeakerListChangeListener
.
DisconnectIfExists
(
)
;
LOG
(
(
"
%
s
"
__FUNCTION__
)
)
;
mozilla
:
:
camera
:
:
Shutdown
(
)
;
}
void
MediaEngineWebRTC
:
:
FakeDeviceChangeEventTimerTick
(
nsITimer
*
aTimer
void
*
aClosure
)
{
MediaEngineWebRTC
*
self
=
static_cast
<
MediaEngineWebRTC
*
>
(
aClosure
)
;
self
-
>
AssertIsOnOwningThread
(
)
;
self
-
>
DeviceListChanged
(
)
;
}
}
