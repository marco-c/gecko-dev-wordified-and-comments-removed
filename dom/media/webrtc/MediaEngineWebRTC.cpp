#
include
"
MediaEngineWebRTC
.
h
"
#
include
"
AllocationHandle
.
h
"
#
include
"
CamerasChild
.
h
"
#
include
"
CSFLog
.
h
"
#
include
"
MediaEngineTabVideoSource
.
h
"
#
include
"
MediaEngineRemoteVideoSource
.
h
"
#
include
"
MediaTrackConstraints
.
h
"
#
include
"
mozilla
/
dom
/
MediaDeviceInfo
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsIComponentRegistrar
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsITabSource
.
h
"
#
include
"
prenv
.
h
"
static
mozilla
:
:
LazyLogModule
sGetUserMediaLog
(
"
GetUserMedia
"
)
;
#
undef
LOG
#
define
LOG
(
args
)
MOZ_LOG
(
sGetUserMediaLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
namespace
mozilla
{
nsTArray
<
int
>
*
AudioInputCubeb
:
:
mDeviceIndexes
;
int
AudioInputCubeb
:
:
mDefaultDevice
=
-
1
;
nsTArray
<
nsCString
>
*
AudioInputCubeb
:
:
mDeviceNames
;
cubeb_device_collection
AudioInputCubeb
:
:
mDevices
=
{
nullptr
0
}
;
bool
AudioInputCubeb
:
:
mAnyInUse
=
false
;
StaticMutex
AudioInputCubeb
:
:
sMutex
;
uint32_t
AudioInputCubeb
:
:
sUserChannelCount
=
0
;
void
AudioInputCubeb
:
:
UpdateDeviceList
(
)
{
for
(
auto
&
device_index
:
(
*
mDeviceIndexes
)
)
{
device_index
=
-
1
;
}
cubeb
*
cubebContext
=
CubebUtils
:
:
GetCubebContext
(
)
;
if
(
!
cubebContext
)
{
return
;
}
cubeb_device_collection
devices
=
{
nullptr
0
}
;
if
(
CUBEB_OK
!
=
cubeb_enumerate_devices
(
cubebContext
CUBEB_DEVICE_TYPE_INPUT
&
devices
)
)
{
return
;
}
mDefaultDevice
=
-
1
;
for
(
uint32_t
i
=
0
;
i
<
devices
.
count
;
i
+
+
)
{
LOG
(
(
"
Cubeb
device
%
u
:
type
0x
%
x
state
0x
%
x
name
%
s
id
%
p
"
i
devices
.
device
[
i
]
.
type
devices
.
device
[
i
]
.
state
devices
.
device
[
i
]
.
friendly_name
devices
.
device
[
i
]
.
device_id
)
)
;
if
(
devices
.
device
[
i
]
.
type
=
=
CUBEB_DEVICE_TYPE_INPUT
&
&
devices
.
device
[
i
]
.
state
=
=
CUBEB_DEVICE_STATE_ENABLED
)
{
auto
j
=
mDeviceNames
-
>
IndexOf
(
devices
.
device
[
i
]
.
device_id
)
;
if
(
j
!
=
nsTArray
<
nsCString
>
:
:
NoIndex
)
{
(
*
mDeviceIndexes
)
[
j
]
=
i
;
}
else
{
mDeviceIndexes
-
>
AppendElement
(
i
)
;
mDeviceNames
-
>
AppendElement
(
devices
.
device
[
i
]
.
device_id
)
;
j
=
mDeviceIndexes
-
>
Length
(
)
-
1
;
}
if
(
devices
.
device
[
i
]
.
preferred
&
CUBEB_DEVICE_PREF_VOICE
)
{
NS_ASSERTION
(
mDefaultDevice
=
=
-
1
"
multiple
default
cubeb
input
devices
!
"
)
;
mDefaultDevice
=
j
;
}
}
}
LOG
(
(
"
Cubeb
default
input
device
%
d
"
mDefaultDevice
)
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
cubeb_device_collection_destroy
(
cubebContext
&
mDevices
)
;
mDevices
=
devices
;
}
MediaEngineWebRTC
:
:
MediaEngineWebRTC
(
MediaEnginePrefs
&
aPrefs
)
:
mMutex
(
"
MediaEngineWebRTC
:
:
mMutex
"
)
mAudioInput
(
nullptr
)
mFullDuplex
(
aPrefs
.
mFullDuplex
)
mDelayAgnostic
(
aPrefs
.
mDelayAgnostic
)
mExtendedFilter
(
aPrefs
.
mExtendedFilter
)
mHasTabVideoSource
(
false
)
{
nsCOMPtr
<
nsIComponentRegistrar
>
compMgr
;
NS_GetComponentRegistrar
(
getter_AddRefs
(
compMgr
)
)
;
if
(
compMgr
)
{
compMgr
-
>
IsContractIDRegistered
(
NS_TABSOURCESERVICE_CONTRACTID
&
mHasTabVideoSource
)
;
}
camera
:
:
GetChildAndCall
(
&
camera
:
:
CamerasChild
:
:
AddDeviceChangeCallback
this
)
;
}
void
MediaEngineWebRTC
:
:
SetFakeDeviceChangeEvents
(
)
{
camera
:
:
GetChildAndCall
(
&
camera
:
:
CamerasChild
:
:
SetFakeDeviceChangeEvents
)
;
}
void
MediaEngineWebRTC
:
:
EnumerateVideoDevices
(
uint64_t
aWindowId
dom
:
:
MediaSourceEnum
aMediaSource
nsTArray
<
RefPtr
<
MediaDevice
>
>
*
aDevices
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
mozilla
:
:
camera
:
:
CaptureEngine
capEngine
=
mozilla
:
:
camera
:
:
InvalidEngine
;
bool
scaryKind
=
false
;
switch
(
aMediaSource
)
{
case
dom
:
:
MediaSourceEnum
:
:
Window
:
capEngine
=
mozilla
:
:
camera
:
:
WinEngine
;
break
;
case
dom
:
:
MediaSourceEnum
:
:
Application
:
capEngine
=
mozilla
:
:
camera
:
:
AppEngine
;
break
;
case
dom
:
:
MediaSourceEnum
:
:
Screen
:
capEngine
=
mozilla
:
:
camera
:
:
ScreenEngine
;
scaryKind
=
true
;
break
;
case
dom
:
:
MediaSourceEnum
:
:
Browser
:
capEngine
=
mozilla
:
:
camera
:
:
BrowserEngine
;
scaryKind
=
true
;
break
;
case
dom
:
:
MediaSourceEnum
:
:
Camera
:
capEngine
=
mozilla
:
:
camera
:
:
CameraEngine
;
break
;
default
:
MOZ_CRASH
(
"
No
valid
video
engine
"
)
;
break
;
}
int
num
;
num
=
mozilla
:
:
camera
:
:
GetChildAndCall
(
&
mozilla
:
:
camera
:
:
CamerasChild
:
:
NumberOfCaptureDevices
capEngine
)
;
for
(
int
i
=
0
;
i
<
num
;
i
+
+
)
{
char
deviceName
[
MediaEngineSource
:
:
kMaxDeviceNameLength
]
;
char
uniqueId
[
MediaEngineSource
:
:
kMaxUniqueIdLength
]
;
bool
scarySource
=
false
;
deviceName
[
0
]
=
'
\
0
'
;
uniqueId
[
0
]
=
'
\
0
'
;
int
error
;
error
=
mozilla
:
:
camera
:
:
GetChildAndCall
(
&
mozilla
:
:
camera
:
:
CamerasChild
:
:
GetCaptureDevice
capEngine
i
deviceName
sizeof
(
deviceName
)
uniqueId
sizeof
(
uniqueId
)
&
scarySource
)
;
if
(
error
)
{
LOG
(
(
"
camera
:
GetCaptureDevice
:
Failed
%
d
"
error
)
)
;
continue
;
}
#
ifdef
DEBUG
LOG
(
(
"
Capture
Device
Index
%
d
Name
%
s
"
i
deviceName
)
)
;
webrtc
:
:
CaptureCapability
cap
;
int
numCaps
=
mozilla
:
:
camera
:
:
GetChildAndCall
(
&
mozilla
:
:
camera
:
:
CamerasChild
:
:
NumberOfCapabilities
capEngine
uniqueId
)
;
LOG
(
(
"
Number
of
Capabilities
%
d
"
numCaps
)
)
;
for
(
int
j
=
0
;
j
<
numCaps
;
j
+
+
)
{
if
(
mozilla
:
:
camera
:
:
GetChildAndCall
(
&
mozilla
:
:
camera
:
:
CamerasChild
:
:
GetCaptureCapability
capEngine
uniqueId
j
cap
)
!
=
0
)
{
break
;
}
LOG
(
(
"
type
=
%
d
width
=
%
d
height
=
%
d
maxFPS
=
%
d
"
cap
.
rawType
cap
.
width
cap
.
height
cap
.
maxFPS
)
)
;
}
#
endif
if
(
uniqueId
[
0
]
=
=
'
\
0
'
)
{
strncpy
(
uniqueId
deviceName
sizeof
(
uniqueId
)
)
;
uniqueId
[
sizeof
(
uniqueId
)
-
1
]
=
'
\
0
'
;
}
NS_ConvertUTF8toUTF16
uuid
(
uniqueId
)
;
RefPtr
<
MediaEngineSource
>
vSource
;
nsRefPtrHashtable
<
nsStringHashKey
MediaEngineSource
>
*
devicesForThisWindow
=
mVideoSources
.
LookupOrAdd
(
aWindowId
)
;
if
(
devicesForThisWindow
-
>
Get
(
uuid
getter_AddRefs
(
vSource
)
)
&
&
vSource
-
>
RequiresSharing
(
)
)
{
static_cast
<
MediaEngineRemoteVideoSource
*
>
(
vSource
.
get
(
)
)
-
>
Refresh
(
i
)
;
}
else
{
vSource
=
new
MediaEngineRemoteVideoSource
(
i
capEngine
aMediaSource
scaryKind
|
|
scarySource
)
;
devicesForThisWindow
-
>
Put
(
uuid
vSource
)
;
}
aDevices
-
>
AppendElement
(
MakeRefPtr
<
MediaDevice
>
(
vSource
vSource
-
>
GetName
(
)
NS_ConvertUTF8toUTF16
(
vSource
-
>
GetUUID
(
)
)
)
)
;
}
if
(
mHasTabVideoSource
|
|
dom
:
:
MediaSourceEnum
:
:
Browser
=
=
aMediaSource
)
{
RefPtr
<
MediaEngineSource
>
tabVideoSource
=
new
MediaEngineTabVideoSource
(
)
;
aDevices
-
>
AppendElement
(
MakeRefPtr
<
MediaDevice
>
(
tabVideoSource
tabVideoSource
-
>
GetName
(
)
NS_ConvertUTF8toUTF16
(
tabVideoSource
-
>
GetUUID
(
)
)
)
)
;
}
}
void
MediaEngineWebRTC
:
:
EnumerateMicrophoneDevices
(
uint64_t
aWindowId
nsTArray
<
RefPtr
<
MediaDevice
>
>
*
aDevices
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
!
mAudioInput
)
{
if
(
!
SupportsDuplex
(
)
)
{
return
;
}
mAudioInput
=
new
mozilla
:
:
AudioInputCubeb
(
)
;
}
int
nDevices
=
0
;
mAudioInput
-
>
GetNumOfRecordingDevices
(
nDevices
)
;
int
i
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
i
=
0
;
#
else
i
=
-
1
;
#
endif
for
(
;
i
<
nDevices
;
i
+
+
)
{
char
deviceName
[
128
]
;
char
uniqueId
[
128
]
;
deviceName
[
0
]
=
'
\
0
'
;
uniqueId
[
0
]
=
'
\
0
'
;
int
error
=
mAudioInput
-
>
GetRecordingDeviceName
(
i
deviceName
uniqueId
)
;
if
(
error
)
{
LOG
(
(
"
AudioInput
:
:
GetRecordingDeviceName
:
Failed
%
d
"
error
)
)
;
continue
;
}
if
(
uniqueId
[
0
]
=
=
'
\
0
'
)
{
strcpy
(
uniqueId
deviceName
)
;
}
RefPtr
<
MediaEngineSource
>
micSource
;
NS_ConvertUTF8toUTF16
uuid
(
uniqueId
)
;
nsRefPtrHashtable
<
nsStringHashKey
MediaEngineSource
>
*
devicesForThisWindow
=
mAudioSources
.
LookupOrAdd
(
aWindowId
)
;
bool
alreadySeenThisDeviceBefore
=
devicesForThisWindow
-
>
Get
(
uuid
getter_AddRefs
(
micSource
)
)
&
&
micSource
-
>
RequiresSharing
(
)
;
if
(
!
alreadySeenThisDeviceBefore
)
{
micSource
=
new
MediaEngineWebRTCMicrophoneSource
(
new
mozilla
:
:
AudioInputCubeb
(
i
)
i
deviceName
uniqueId
mDelayAgnostic
mExtendedFilter
)
;
devicesForThisWindow
-
>
Put
(
uuid
micSource
)
;
}
aDevices
-
>
AppendElement
(
MakeRefPtr
<
MediaDevice
>
(
micSource
micSource
-
>
GetName
(
)
NS_ConvertUTF8toUTF16
(
micSource
-
>
GetUUID
(
)
)
)
)
;
}
}
void
MediaEngineWebRTC
:
:
EnumerateSpeakerDevices
(
uint64_t
aWindowId
nsTArray
<
RefPtr
<
MediaDevice
>
>
*
aDevices
)
{
nsTArray
<
RefPtr
<
AudioDeviceInfo
>
>
devices
;
CubebUtils
:
:
GetDeviceCollection
(
devices
CubebUtils
:
:
Output
)
;
for
(
auto
&
device
:
devices
)
{
MOZ_ASSERT
(
device
-
>
GetDeviceID
(
)
.
isSome
(
)
)
;
if
(
device
-
>
State
(
)
=
=
CUBEB_DEVICE_STATE_ENABLED
)
{
MOZ_ASSERT
(
device
-
>
Type
(
)
=
=
CUBEB_DEVICE_TYPE_OUTPUT
)
;
nsString
uuid
(
device
-
>
FriendlyName
(
)
)
;
uuid
.
Append
(
NS_LITERAL_STRING
(
"
_Speaker
"
)
)
;
aDevices
-
>
AppendElement
(
MakeRefPtr
<
MediaDevice
>
(
device
-
>
FriendlyName
(
)
dom
:
:
MediaDeviceKind
:
:
Audiooutput
uuid
)
)
;
}
}
}
void
MediaEngineWebRTC
:
:
EnumerateDevices
(
uint64_t
aWindowId
dom
:
:
MediaSourceEnum
aMediaSource
MediaSinkEnum
aMediaSink
nsTArray
<
RefPtr
<
MediaDevice
>
>
*
aDevices
)
{
MOZ_ASSERT
(
aMediaSource
!
=
dom
:
:
MediaSourceEnum
:
:
Other
|
|
aMediaSink
!
=
MediaSinkEnum
:
:
Other
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
MediaEngineSource
:
:
IsVideo
(
aMediaSource
)
)
{
EnumerateVideoDevices
(
aWindowId
aMediaSource
aDevices
)
;
}
else
if
(
aMediaSource
=
=
dom
:
:
MediaSourceEnum
:
:
AudioCapture
)
{
RefPtr
<
MediaEngineWebRTCAudioCaptureSource
>
audioCaptureSource
=
new
MediaEngineWebRTCAudioCaptureSource
(
nullptr
)
;
aDevices
-
>
AppendElement
(
MakeRefPtr
<
MediaDevice
>
(
audioCaptureSource
audioCaptureSource
-
>
GetName
(
)
NS_ConvertUTF8toUTF16
(
audioCaptureSource
-
>
GetUUID
(
)
)
)
)
;
}
else
if
(
aMediaSource
=
=
dom
:
:
MediaSourceEnum
:
:
Microphone
)
{
MOZ_ASSERT
(
aMediaSource
=
=
dom
:
:
MediaSourceEnum
:
:
Microphone
)
;
EnumerateMicrophoneDevices
(
aWindowId
aDevices
)
;
}
if
(
aMediaSink
=
=
MediaSinkEnum
:
:
Speaker
)
{
EnumerateSpeakerDevices
(
aWindowId
aDevices
)
;
}
}
bool
MediaEngineWebRTC
:
:
SupportsDuplex
(
)
{
return
mFullDuplex
;
}
void
MediaEngineWebRTC
:
:
ReleaseResourcesForWindow
(
uint64_t
aWindowId
)
{
{
nsRefPtrHashtable
<
nsStringHashKey
MediaEngineSource
>
*
audioDevicesForThisWindow
=
mAudioSources
.
Get
(
aWindowId
)
;
if
(
audioDevicesForThisWindow
)
{
for
(
auto
iter
=
audioDevicesForThisWindow
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
UserData
(
)
-
>
Shutdown
(
)
;
}
mAudioSources
.
Remove
(
aWindowId
)
;
}
}
{
nsRefPtrHashtable
<
nsStringHashKey
MediaEngineSource
>
*
videoDevicesForThisWindow
=
mVideoSources
.
Get
(
aWindowId
)
;
if
(
videoDevicesForThisWindow
)
{
for
(
auto
iter
=
videoDevicesForThisWindow
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
UserData
(
)
-
>
Shutdown
(
)
;
}
mVideoSources
.
Remove
(
aWindowId
)
;
}
}
}
namespace
{
template
<
typename
T
>
void
ShutdownSources
(
T
&
aHashTable
)
{
for
(
auto
iter
=
aHashTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
for
(
auto
iterInner
=
iter
.
UserData
(
)
-
>
Iter
(
)
;
!
iterInner
.
Done
(
)
;
iterInner
.
Next
(
)
)
{
MediaEngineSource
*
source
=
iterInner
.
UserData
(
)
;
source
-
>
Shutdown
(
)
;
}
}
}
}
void
MediaEngineWebRTC
:
:
Shutdown
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
camera
:
:
GetCamerasChildIfExists
(
)
)
{
camera
:
:
GetChildAndCall
(
&
camera
:
:
CamerasChild
:
:
RemoveDeviceChangeCallback
this
)
;
}
LOG
(
(
"
%
s
"
__FUNCTION__
)
)
;
ShutdownSources
(
mVideoSources
)
;
ShutdownSources
(
mAudioSources
)
;
mozilla
:
:
camera
:
:
Shutdown
(
)
;
AudioInputCubeb
:
:
CleanupGlobalData
(
)
;
}
}
