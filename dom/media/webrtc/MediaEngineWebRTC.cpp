#
include
"
nsIPrefService
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
CSFLog
.
h
"
#
include
"
prenv
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
endif
static
mozilla
:
:
LazyLogModule
sGetUserMediaLog
(
"
GetUserMedia
"
)
;
#
include
"
MediaEngineWebRTC
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
nsIComponentRegistrar
.
h
"
#
include
"
MediaEngineTabVideoSource
.
h
"
#
include
"
MediaEngineRemoteVideoSource
.
h
"
#
include
"
CamerasChild
.
h
"
#
include
"
nsITabSource
.
h
"
#
include
"
MediaTrackConstraints
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
AndroidJNIWrapper
.
h
"
#
include
"
AndroidBridge
.
h
"
#
endif
#
undef
LOG
#
define
LOG
(
args
)
MOZ_LOG
(
sGetUserMediaLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
namespace
mozilla
{
nsTArray
<
int
>
*
AudioInputCubeb
:
:
mDeviceIndexes
;
int
AudioInputCubeb
:
:
mDefaultDevice
=
-
1
;
nsTArray
<
nsCString
>
*
AudioInputCubeb
:
:
mDeviceNames
;
cubeb_device_collection
*
AudioInputCubeb
:
:
mDevices
=
nullptr
;
bool
AudioInputCubeb
:
:
mAnyInUse
=
false
;
StaticMutex
AudioInputCubeb
:
:
sMutex
;
void
AudioInputCubeb
:
:
UpdateDeviceList
(
)
{
cubeb
*
cubebContext
=
CubebUtils
:
:
GetCubebContext
(
)
;
if
(
!
cubebContext
)
{
return
;
}
cubeb_device_collection
*
devices
=
nullptr
;
if
(
CUBEB_OK
!
=
cubeb_enumerate_devices
(
cubebContext
CUBEB_DEVICE_TYPE_INPUT
&
devices
)
)
{
return
;
}
for
(
auto
&
device_index
:
(
*
mDeviceIndexes
)
)
{
device_index
=
-
1
;
}
mDefaultDevice
=
-
1
;
for
(
uint32_t
i
=
0
;
i
<
devices
-
>
count
;
i
+
+
)
{
LOG
(
(
"
Cubeb
device
%
u
:
type
0x
%
x
state
0x
%
x
name
%
s
id
%
p
"
i
devices
-
>
device
[
i
]
-
>
type
devices
-
>
device
[
i
]
-
>
state
devices
-
>
device
[
i
]
-
>
friendly_name
devices
-
>
device
[
i
]
-
>
device_id
)
)
;
if
(
devices
-
>
device
[
i
]
-
>
type
=
=
CUBEB_DEVICE_TYPE_INPUT
&
&
(
devices
-
>
device
[
i
]
-
>
state
=
=
CUBEB_DEVICE_STATE_ENABLED
|
|
(
devices
-
>
device
[
i
]
-
>
state
=
=
CUBEB_DEVICE_STATE_DISABLED
&
&
devices
-
>
device
[
i
]
-
>
friendly_name
&
&
strcmp
(
devices
-
>
device
[
i
]
-
>
friendly_name
"
Sine
source
at
440
Hz
"
)
=
=
0
)
)
)
{
auto
j
=
mDeviceNames
-
>
IndexOf
(
devices
-
>
device
[
i
]
-
>
device_id
)
;
if
(
j
!
=
nsTArray
<
nsCString
>
:
:
NoIndex
)
{
(
*
mDeviceIndexes
)
[
j
]
=
i
;
}
else
{
mDeviceIndexes
-
>
AppendElement
(
i
)
;
mDeviceNames
-
>
AppendElement
(
devices
-
>
device
[
i
]
-
>
device_id
)
;
}
if
(
devices
-
>
device
[
i
]
-
>
preferred
&
CUBEB_DEVICE_PREF_VOICE
)
{
NS_ASSERTION
(
mDefaultDevice
=
=
-
1
"
multiple
default
cubeb
input
devices
!
"
)
;
mDefaultDevice
=
i
;
}
}
}
LOG
(
(
"
Cubeb
default
input
device
%
d
"
mDefaultDevice
)
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
mDevices
)
{
cubeb_device_collection_destroy
(
mDevices
)
;
}
mDevices
=
devices
;
}
MediaEngineWebRTC
:
:
MediaEngineWebRTC
(
MediaEnginePrefs
&
aPrefs
)
:
mMutex
(
"
mozilla
:
:
MediaEngineWebRTC
"
)
mVoiceEngine
(
nullptr
)
mAudioInput
(
nullptr
)
mFullDuplex
(
aPrefs
.
mFullDuplex
)
mExtendedFilter
(
aPrefs
.
mExtendedFilter
)
mDelayAgnostic
(
aPrefs
.
mDelayAgnostic
)
mHasTabVideoSource
(
false
)
{
nsCOMPtr
<
nsIComponentRegistrar
>
compMgr
;
NS_GetComponentRegistrar
(
getter_AddRefs
(
compMgr
)
)
;
if
(
compMgr
)
{
compMgr
-
>
IsContractIDRegistered
(
NS_TABSOURCESERVICE_CONTRACTID
&
mHasTabVideoSource
)
;
}
gFarendObserver
=
new
AudioOutputObserver
(
)
;
camera
:
:
GetChildAndCall
(
&
camera
:
:
CamerasChild
:
:
AddDeviceChangeCallback
this
)
;
}
void
MediaEngineWebRTC
:
:
SetFakeDeviceChangeEvents
(
)
{
camera
:
:
GetChildAndCall
(
&
camera
:
:
CamerasChild
:
:
SetFakeDeviceChangeEvents
)
;
}
void
MediaEngineWebRTC
:
:
EnumerateVideoDevices
(
dom
:
:
MediaSourceEnum
aMediaSource
nsTArray
<
RefPtr
<
MediaEngineVideoSource
>
>
*
aVSources
)
{
MutexAutoLock
lock
(
mMutex
)
;
mozilla
:
:
camera
:
:
CaptureEngine
capEngine
=
mozilla
:
:
camera
:
:
InvalidEngine
;
#
ifdef
MOZ_WIDGET_ANDROID
JavaVM
*
jvm
;
JNIEnv
*
const
env
=
jni
:
:
GetEnvForThread
(
)
;
MOZ_ALWAYS_TRUE
(
!
env
-
>
GetJavaVM
(
&
jvm
)
)
;
if
(
webrtc
:
:
VideoEngine
:
:
SetAndroidObjects
(
jvm
)
!
=
0
)
{
LOG
(
(
"
VieCapture
:
SetAndroidObjects
Failed
"
)
)
;
return
;
}
#
endif
bool
scaryKind
=
false
;
switch
(
aMediaSource
)
{
case
dom
:
:
MediaSourceEnum
:
:
Window
:
capEngine
=
mozilla
:
:
camera
:
:
WinEngine
;
break
;
case
dom
:
:
MediaSourceEnum
:
:
Application
:
capEngine
=
mozilla
:
:
camera
:
:
AppEngine
;
break
;
case
dom
:
:
MediaSourceEnum
:
:
Screen
:
capEngine
=
mozilla
:
:
camera
:
:
ScreenEngine
;
scaryKind
=
true
;
break
;
case
dom
:
:
MediaSourceEnum
:
:
Browser
:
capEngine
=
mozilla
:
:
camera
:
:
BrowserEngine
;
scaryKind
=
true
;
break
;
case
dom
:
:
MediaSourceEnum
:
:
Camera
:
capEngine
=
mozilla
:
:
camera
:
:
CameraEngine
;
break
;
default
:
MOZ_CRASH
(
"
No
valid
video
engine
"
)
;
break
;
}
int
num
;
num
=
mozilla
:
:
camera
:
:
GetChildAndCall
(
&
mozilla
:
:
camera
:
:
CamerasChild
:
:
NumberOfCaptureDevices
capEngine
)
;
for
(
int
i
=
0
;
i
<
num
;
i
+
+
)
{
char
deviceName
[
MediaEngineSource
:
:
kMaxDeviceNameLength
]
;
char
uniqueId
[
MediaEngineSource
:
:
kMaxUniqueIdLength
]
;
bool
scaryWindow
=
false
;
deviceName
[
0
]
=
'
\
0
'
;
uniqueId
[
0
]
=
'
\
0
'
;
int
error
;
error
=
mozilla
:
:
camera
:
:
GetChildAndCall
(
&
mozilla
:
:
camera
:
:
CamerasChild
:
:
GetCaptureDevice
capEngine
i
deviceName
sizeof
(
deviceName
)
uniqueId
sizeof
(
uniqueId
)
)
;
if
(
error
)
{
LOG
(
(
"
camera
:
GetCaptureDevice
:
Failed
%
d
"
error
)
)
;
continue
;
}
#
ifdef
DEBUG
LOG
(
(
"
Capture
Device
Index
%
d
Name
%
s
"
i
deviceName
)
)
;
if
(
aMediaSource
=
=
dom
:
:
MediaSourceEnum
:
:
Window
)
{
}
if
(
aMediaSource
=
=
dom
:
:
MediaSourceEnum
:
:
Application
)
{
}
webrtc
:
:
CaptureCapability
cap
;
int
numCaps
=
mozilla
:
:
camera
:
:
GetChildAndCall
(
&
mozilla
:
:
camera
:
:
CamerasChild
:
:
NumberOfCapabilities
capEngine
uniqueId
)
;
LOG
(
(
"
Number
of
Capabilities
%
d
"
numCaps
)
)
;
for
(
int
j
=
0
;
j
<
numCaps
;
j
+
+
)
{
if
(
mozilla
:
:
camera
:
:
GetChildAndCall
(
&
mozilla
:
:
camera
:
:
CamerasChild
:
:
GetCaptureCapability
capEngine
uniqueId
j
cap
)
!
=
0
)
{
break
;
}
LOG
(
(
"
type
=
%
d
width
=
%
d
height
=
%
d
maxFPS
=
%
d
"
cap
.
rawType
cap
.
width
cap
.
height
cap
.
maxFPS
)
)
;
}
#
endif
if
(
uniqueId
[
0
]
=
=
'
\
0
'
)
{
strncpy
(
uniqueId
deviceName
sizeof
(
uniqueId
)
)
;
uniqueId
[
sizeof
(
uniqueId
)
-
1
]
=
'
\
0
'
;
}
RefPtr
<
MediaEngineVideoSource
>
vSource
;
NS_ConvertUTF8toUTF16
uuid
(
uniqueId
)
;
if
(
mVideoSources
.
Get
(
uuid
getter_AddRefs
(
vSource
)
)
)
{
static_cast
<
MediaEngineRemoteVideoSource
*
>
(
vSource
.
get
(
)
)
-
>
Refresh
(
i
)
;
aVSources
-
>
AppendElement
(
vSource
.
get
(
)
)
;
}
else
{
vSource
=
new
MediaEngineRemoteVideoSource
(
i
capEngine
aMediaSource
scaryKind
|
|
scaryWindow
)
;
mVideoSources
.
Put
(
uuid
vSource
)
;
aVSources
-
>
AppendElement
(
vSource
)
;
}
}
if
(
mHasTabVideoSource
|
|
dom
:
:
MediaSourceEnum
:
:
Browser
=
=
aMediaSource
)
{
aVSources
-
>
AppendElement
(
new
MediaEngineTabVideoSource
(
)
)
;
}
}
bool
MediaEngineWebRTC
:
:
SupportsDuplex
(
)
{
#
ifndef
XP_WIN
return
mFullDuplex
;
#
else
return
IsVistaOrLater
(
)
&
&
mFullDuplex
;
#
endif
}
void
MediaEngineWebRTC
:
:
EnumerateAudioDevices
(
dom
:
:
MediaSourceEnum
aMediaSource
nsTArray
<
RefPtr
<
MediaEngineAudioSource
>
>
*
aASources
)
{
ScopedCustomReleasePtr
<
webrtc
:
:
VoEBase
>
ptrVoEBase
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
aMediaSource
=
=
dom
:
:
MediaSourceEnum
:
:
AudioCapture
)
{
RefPtr
<
MediaEngineWebRTCAudioCaptureSource
>
audioCaptureSource
=
new
MediaEngineWebRTCAudioCaptureSource
(
nullptr
)
;
aASources
-
>
AppendElement
(
audioCaptureSource
)
;
return
;
}
#
ifdef
MOZ_WIDGET_ANDROID
jobject
context
=
mozilla
:
:
AndroidBridge
:
:
Bridge
(
)
-
>
GetGlobalContextRef
(
)
;
JavaVM
*
jvm
;
JNIEnv
*
const
env
=
jni
:
:
GetEnvForThread
(
)
;
MOZ_ALWAYS_TRUE
(
!
env
-
>
GetJavaVM
(
&
jvm
)
)
;
if
(
webrtc
:
:
VoiceEngine
:
:
SetAndroidObjects
(
jvm
(
void
*
)
context
)
!
=
0
)
{
LOG
(
(
"
VoiceEngine
:
SetAndroidObjects
Failed
"
)
)
;
return
;
}
#
endif
if
(
!
mVoiceEngine
)
{
mConfig
.
Set
<
webrtc
:
:
ExtendedFilter
>
(
new
webrtc
:
:
ExtendedFilter
(
mExtendedFilter
)
)
;
mConfig
.
Set
<
webrtc
:
:
DelayAgnostic
>
(
new
webrtc
:
:
DelayAgnostic
(
mDelayAgnostic
)
)
;
mVoiceEngine
=
webrtc
:
:
VoiceEngine
:
:
Create
(
mConfig
)
;
if
(
!
mVoiceEngine
)
{
return
;
}
}
ptrVoEBase
=
webrtc
:
:
VoEBase
:
:
GetInterface
(
mVoiceEngine
)
;
if
(
!
ptrVoEBase
)
{
return
;
}
if
(
ptrVoEBase
-
>
Init
(
)
<
0
)
{
return
;
}
if
(
!
mAudioInput
)
{
if
(
SupportsDuplex
(
)
)
{
mAudioInput
=
new
mozilla
:
:
AudioInputCubeb
(
mVoiceEngine
)
;
}
else
{
mAudioInput
=
new
mozilla
:
:
AudioInputWebRTC
(
mVoiceEngine
)
;
}
}
int
nDevices
=
0
;
mAudioInput
-
>
GetNumOfRecordingDevices
(
nDevices
)
;
int
i
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GONK
)
i
=
0
;
#
else
i
=
-
1
;
#
endif
for
(
;
i
<
nDevices
;
i
+
+
)
{
char
deviceName
[
128
]
;
char
uniqueId
[
128
]
;
deviceName
[
0
]
=
'
\
0
'
;
uniqueId
[
0
]
=
'
\
0
'
;
int
error
=
mAudioInput
-
>
GetRecordingDeviceName
(
i
deviceName
uniqueId
)
;
if
(
error
)
{
LOG
(
(
"
VoEHardware
:
GetRecordingDeviceName
:
Failed
%
d
"
error
)
)
;
continue
;
}
if
(
uniqueId
[
0
]
=
=
'
\
0
'
)
{
MOZ_ASSERT
(
sizeof
(
deviceName
)
=
=
sizeof
(
uniqueId
)
)
;
strcpy
(
uniqueId
deviceName
)
;
}
RefPtr
<
MediaEngineAudioSource
>
aSource
;
NS_ConvertUTF8toUTF16
uuid
(
uniqueId
)
;
if
(
mAudioSources
.
Get
(
uuid
getter_AddRefs
(
aSource
)
)
)
{
aASources
-
>
AppendElement
(
aSource
.
get
(
)
)
;
}
else
{
AudioInput
*
audioinput
=
mAudioInput
;
if
(
SupportsDuplex
(
)
)
{
audioinput
=
new
mozilla
:
:
AudioInputCubeb
(
mVoiceEngine
i
)
;
}
aSource
=
new
MediaEngineWebRTCMicrophoneSource
(
mVoiceEngine
audioinput
i
deviceName
uniqueId
)
;
mAudioSources
.
Put
(
uuid
aSource
)
;
aASources
-
>
AppendElement
(
aSource
)
;
}
}
}
void
MediaEngineWebRTC
:
:
Shutdown
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
camera
:
:
GetCamerasChildIfExists
(
)
)
{
camera
:
:
GetChildAndCall
(
&
camera
:
:
CamerasChild
:
:
RemoveDeviceChangeCallback
this
)
;
}
LOG
(
(
"
%
s
"
__FUNCTION__
)
)
;
for
(
auto
iter
=
mVideoSources
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
MediaEngineVideoSource
*
source
=
iter
.
UserData
(
)
;
if
(
source
)
{
source
-
>
Shutdown
(
)
;
}
}
for
(
auto
iter
=
mAudioSources
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
MediaEngineAudioSource
*
source
=
iter
.
UserData
(
)
;
if
(
source
)
{
source
-
>
Shutdown
(
)
;
}
}
mVideoSources
.
Clear
(
)
;
mAudioSources
.
Clear
(
)
;
if
(
mVoiceEngine
)
{
mVoiceEngine
-
>
SetTraceCallback
(
nullptr
)
;
webrtc
:
:
VoiceEngine
:
:
Delete
(
mVoiceEngine
)
;
}
mVoiceEngine
=
nullptr
;
mozilla
:
:
camera
:
:
Shutdown
(
)
;
AudioInputCubeb
:
:
CleanupGlobalData
(
)
;
}
}
