#
include
"
VideoStreamFactory
.
h
"
#
include
"
common
/
browser_logging
/
CSFLog
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
VideoConduit
.
h
"
namespace
mozilla
{
#
ifdef
LOGTAG
#
undef
LOGTAG
#
endif
#
define
LOGTAG
"
WebrtcVideoSessionConduit
"
#
define
DEFAULT_VIDEO_MAX_FRAMERATE
30u
#
define
MB_OF
(
w
h
)
\
(
(
unsigned
int
)
(
(
(
(
w
+
15
)
>
>
4
)
)
*
(
(
unsigned
int
)
(
(
h
+
15
)
>
>
4
)
)
)
)
static
VideoStreamFactory
:
:
ResolutionAndBitrateLimits
kResolutionAndBitrateLimits
[
]
=
{
{
MB_OF
(
1920
1200
)
KBPS
(
1500
)
KBPS
(
2000
)
KBPS
(
10000
)
}
{
MB_OF
(
1280
720
)
KBPS
(
1200
)
KBPS
(
1500
)
KBPS
(
5000
)
}
{
MB_OF
(
800
480
)
KBPS
(
200
)
KBPS
(
800
)
KBPS
(
2500
)
}
{
MB_OF
(
480
270
)
KBPS
(
150
)
KBPS
(
500
)
KBPS
(
2000
)
}
{
tl
:
:
Max
<
MB_OF
(
400
240
)
MB_OF
(
352
288
)
>
:
:
value
KBPS
(
125
)
KBPS
(
300
)
KBPS
(
1300
)
}
{
MB_OF
(
176
144
)
KBPS
(
100
)
KBPS
(
150
)
KBPS
(
500
)
}
{
0
KBPS
(
40
)
KBPS
(
80
)
KBPS
(
250
)
}
}
;
auto
VideoStreamFactory
:
:
GetLimitsFor
(
unsigned
int
aWidth
unsigned
int
aHeight
int
aCapBps
)
-
>
ResolutionAndBitrateLimits
{
int
fs
=
MB_OF
(
aWidth
aHeight
)
;
for
(
const
auto
&
resAndLimits
:
kResolutionAndBitrateLimits
)
{
if
(
fs
>
resAndLimits
.
resolution_in_mb
&
&
(
aCapBps
=
=
0
|
|
resAndLimits
.
start_bitrate_bps
<
=
aCapBps
|
|
resAndLimits
.
resolution_in_mb
=
=
0
)
)
{
return
resAndLimits
;
}
}
MOZ_CRASH
(
"
Loop
should
have
handled
fallback
"
)
;
}
static
void
SelectBitrates
(
unsigned
short
width
unsigned
short
height
int
min
int
start
int
cap
int
pref_cap
int
negotiated_cap
webrtc
:
:
VideoStream
&
aVideoStream
)
{
int
&
out_min
=
aVideoStream
.
min_bitrate_bps
;
int
&
out_start
=
aVideoStream
.
target_bitrate_bps
;
int
&
out_max
=
aVideoStream
.
max_bitrate_bps
;
VideoStreamFactory
:
:
ResolutionAndBitrateLimits
resAndLimits
=
VideoStreamFactory
:
:
GetLimitsFor
(
width
height
)
;
out_min
=
MinIgnoreZero
(
resAndLimits
.
min_bitrate_bps
cap
)
;
out_start
=
MinIgnoreZero
(
resAndLimits
.
start_bitrate_bps
cap
)
;
out_max
=
MinIgnoreZero
(
resAndLimits
.
max_bitrate_bps
cap
)
;
out_max
=
MinIgnoreZero
(
negotiated_cap
out_max
)
;
out_min
=
std
:
:
min
(
out_min
out_max
)
;
out_start
=
std
:
:
min
(
out_start
out_max
)
;
if
(
min
&
&
min
>
out_min
)
{
out_min
=
min
;
}
out_min
=
std
:
:
max
(
kViEMinCodecBitrate_bps
out_min
)
;
out_max
=
std
:
:
max
(
kViEMinCodecBitrate_bps
out_max
)
;
if
(
start
&
&
start
>
out_start
)
{
out_start
=
start
;
}
if
(
out_min
>
out_max
)
{
out_min
=
out_max
;
}
out_start
=
std
:
:
min
(
out_max
std
:
:
max
(
out_start
out_min
)
)
;
MOZ_ASSERT
(
pref_cap
=
=
0
|
|
out_max
<
=
pref_cap
)
;
}
void
VideoStreamFactory
:
:
SetCodecMode
(
webrtc
:
:
VideoCodecMode
aCodecMode
)
{
mCodecMode
=
aCodecMode
;
}
void
VideoStreamFactory
:
:
SetMaxFramerateForAllStreams
(
unsigned
int
aMaxFramerate
)
{
mMaxFramerateForAllStreams
=
aMaxFramerate
;
}
std
:
:
vector
<
webrtc
:
:
VideoStream
>
VideoStreamFactory
:
:
CreateEncoderStreams
(
int
width
int
height
const
webrtc
:
:
VideoEncoderConfig
&
config
)
{
const
size_t
streamCount
=
mCodecMode
=
=
webrtc
:
:
VideoCodecMode
:
:
kScreensharing
?
1
:
config
.
number_of_streams
;
MOZ_RELEASE_ASSERT
(
streamCount
>
=
1
"
Should
request
at
least
one
stream
"
)
;
std
:
:
vector
<
webrtc
:
:
VideoStream
>
streams
;
streams
.
reserve
(
streamCount
)
;
int
highestResolutionIndex
=
0
;
for
(
size_t
i
=
1
;
i
<
streamCount
;
+
+
i
)
{
if
(
mCodecConfig
.
mEncodings
[
i
]
.
constraints
.
scaleDownBy
<
mCodecConfig
.
mEncodings
[
highestResolutionIndex
]
.
constraints
.
scaleDownBy
)
{
highestResolutionIndex
=
i
;
}
}
mSimulcastAdapter
-
>
OnOutputFormatRequest
(
cricket
:
:
VideoFormat
(
width
height
0
0
)
)
;
for
(
int
idx
=
streamCount
-
1
;
idx
>
=
0
;
-
-
idx
)
{
webrtc
:
:
VideoStream
video_stream
;
auto
&
encoding
=
mCodecConfig
.
mEncodings
[
idx
]
;
MOZ_ASSERT
(
encoding
.
constraints
.
scaleDownBy
>
=
1
.
0
)
;
int
unusedCropWidth
unusedCropHeight
outWidth
outHeight
;
if
(
idx
=
=
highestResolutionIndex
)
{
outWidth
=
width
;
outHeight
=
height
;
}
else
{
float
effectiveScaleDownBy
=
encoding
.
constraints
.
scaleDownBy
/
mCodecConfig
.
mEncodings
[
highestResolutionIndex
]
.
constraints
.
scaleDownBy
;
MOZ_ASSERT
(
effectiveScaleDownBy
>
=
1
.
0
)
;
mSimulcastAdapter
-
>
OnScaleResolutionBy
(
effectiveScaleDownBy
>
1
.
0
?
absl
:
:
optional
<
float
>
(
effectiveScaleDownBy
)
:
absl
:
:
optional
<
float
>
(
)
)
;
bool
rv
=
mSimulcastAdapter
-
>
AdaptFrameResolution
(
width
height
0
&
unusedCropWidth
&
unusedCropHeight
&
outWidth
&
outHeight
)
;
if
(
!
rv
)
{
outWidth
=
0
;
outHeight
=
0
;
}
}
if
(
outWidth
=
=
0
|
|
outHeight
=
=
0
)
{
CSFLogInfo
(
LOGTAG
"
%
s
Stream
with
RID
%
s
ignored
because
of
no
resolution
.
"
__FUNCTION__
encoding
.
rid
.
c_str
(
)
)
;
continue
;
}
MOZ_ASSERT
(
outWidth
>
0
)
;
MOZ_ASSERT
(
outHeight
>
0
)
;
video_stream
.
width
=
outWidth
;
video_stream
.
height
=
outHeight
;
CSFLogInfo
(
LOGTAG
"
%
s
Input
frame
%
ux
%
u
RID
%
s
scaling
to
%
zux
%
zu
"
__FUNCTION__
width
height
encoding
.
rid
.
c_str
(
)
video_stream
.
width
video_stream
.
height
)
;
if
(
video_stream
.
width
*
height
!
=
width
*
video_stream
.
height
)
{
CSFLogInfo
(
LOGTAG
"
%
s
Stream
with
RID
%
s
ignored
because
of
bad
aspect
ratio
.
"
__FUNCTION__
encoding
.
rid
.
c_str
(
)
)
;
continue
;
}
unsigned
int
max_framerate
=
mMaxFramerateForAllStreams
;
max_framerate
=
std
:
:
min
(
WebrtcVideoConduit
:
:
ToLibwebrtcMaxFramerate
(
encoding
.
constraints
.
maxFps
)
max_framerate
)
;
if
(
max_framerate
>
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
{
max_framerate
=
DEFAULT_VIDEO_MAX_FRAMERATE
;
}
video_stream
.
max_framerate
=
static_cast
<
int
>
(
max_framerate
)
;
CSFLogInfo
(
LOGTAG
"
%
s
Stream
with
RID
%
s
maxFps
=
%
d
(
global
max
fps
=
%
u
)
"
__FUNCTION__
encoding
.
rid
.
c_str
(
)
video_stream
.
max_framerate
(
unsigned
)
mMaxFramerateForAllStreams
)
;
SelectBitrates
(
video_stream
.
width
video_stream
.
height
mMinBitrate
mStartBitrate
encoding
.
constraints
.
maxBr
mPrefMaxBitrate
mNegotiatedMaxBitrate
video_stream
)
;
video_stream
.
bitrate_priority
=
config
.
bitrate_priority
;
video_stream
.
max_qp
=
kQpMax
;
if
(
streamCount
>
1
)
{
if
(
mCodecMode
=
=
webrtc
:
:
VideoCodecMode
:
:
kScreensharing
)
{
video_stream
.
num_temporal_layers
=
1
;
}
else
{
video_stream
.
num_temporal_layers
=
2
;
}
}
if
(
mCodecConfig
.
mName
=
=
"
H264
"
)
{
if
(
mCodecConfig
.
mEncodingConstraints
.
maxMbps
>
0
)
{
CSFLogError
(
LOGTAG
"
%
s
H
.
264
max_mbps
not
supported
yet
"
__FUNCTION__
)
;
}
}
streams
.
push_back
(
video_stream
)
;
}
MOZ_RELEASE_ASSERT
(
streams
.
size
(
)
"
Should
configure
at
least
one
stream
"
)
;
return
streams
;
}
}
