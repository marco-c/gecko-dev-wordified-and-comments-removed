#
ifndef
MEDIA_CONDUIT_ABSTRACTION_
#
define
MEDIA_CONDUIT_ABSTRACTION_
#
include
<
vector
>
#
include
<
functional
>
#
include
<
map
>
#
include
"
CodecConfig
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
jsapi
/
RTCStatsReport
.
h
"
#
include
"
MediaConduitErrors
.
h
"
#
include
"
mozilla
/
media
/
MediaUtils
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
VideoTypes
.
h
"
#
include
"
WebrtcVideoCodecFactory
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpSourcesBinding
.
h
"
#
include
"
transport
/
mediapacket
.
h
"
#
include
"
api
/
audio
/
audio_frame
.
h
"
#
include
"
api
/
call
/
transport
.
h
"
#
include
"
api
/
rtp_headers
.
h
"
#
include
"
api
/
rtp_parameters
.
h
"
#
include
"
api
/
transport
/
rtp
/
rtp_source
.
h
"
#
include
"
api
/
video
/
video_frame_buffer
.
h
"
#
include
"
call
/
audio_receive_stream
.
h
"
#
include
"
call
/
audio_send_stream
.
h
"
#
include
"
call
/
call_basic_stats
.
h
"
#
include
"
call
/
video_receive_stream
.
h
"
#
include
"
call
/
video_send_stream
.
h
"
#
include
"
rtc_base
/
copy_on_write_buffer
.
h
"
namespace
webrtc
{
class
VideoFrame
;
}
namespace
mozilla
{
namespace
dom
{
struct
RTCRtpSourceEntry
;
}
namespace
dom
{
struct
RTCRtpSourceEntry
;
}
enum
class
MediaSessionConduitLocalDirection
:
int
{
kSend
kRecv
}
;
class
VideoConduitControlInterface
;
class
AudioConduitControlInterface
;
class
VideoSessionConduit
;
class
AudioSessionConduit
;
class
WebrtcCallWrapper
;
using
RtpExtList
=
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
;
using
Ssrc
=
uint32_t
;
using
Ssrcs
=
std
:
:
vector
<
uint32_t
>
;
class
VideoRenderer
{
protected
:
virtual
~
VideoRenderer
(
)
{
}
public
:
virtual
void
FrameSizeChange
(
unsigned
int
width
unsigned
int
height
)
=
0
;
virtual
void
RenderVideoFrame
(
const
webrtc
:
:
VideoFrameBuffer
&
buffer
uint32_t
time_stamp
int64_t
render_time
)
=
0
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
VideoRenderer
)
}
;
class
MediaSessionConduit
{
protected
:
virtual
~
MediaSessionConduit
(
)
{
}
public
:
enum
Type
{
AUDIO
VIDEO
}
;
enum
class
PacketType
{
RTP
RTCP
}
;
static
std
:
:
string
LocalDirectionToString
(
const
MediaSessionConduitLocalDirection
aDirection
)
{
return
aDirection
=
=
MediaSessionConduitLocalDirection
:
:
kSend
?
"
send
"
:
"
receive
"
;
}
virtual
Type
type
(
)
const
=
0
;
virtual
Maybe
<
int
>
ActiveSendPayloadType
(
)
const
=
0
;
virtual
Maybe
<
int
>
ActiveRecvPayloadType
(
)
const
=
0
;
virtual
void
SetTransportActive
(
bool
aActive
)
=
0
;
virtual
MediaEventSourceExc
<
MediaPacket
>
&
SenderRtpSendEvent
(
)
=
0
;
virtual
MediaEventSourceExc
<
MediaPacket
>
&
SenderRtcpSendEvent
(
)
=
0
;
virtual
MediaEventSourceExc
<
MediaPacket
>
&
ReceiverRtcpSendEvent
(
)
=
0
;
virtual
void
ConnectReceiverRtpEvent
(
MediaEventSourceExc
<
MediaPacket
webrtc
:
:
RTPHeader
>
&
aEvent
)
=
0
;
virtual
void
ConnectReceiverRtcpEvent
(
MediaEventSourceExc
<
MediaPacket
>
&
aEvent
)
=
0
;
virtual
void
ConnectSenderRtcpEvent
(
MediaEventSourceExc
<
MediaPacket
>
&
aEvent
)
=
0
;
virtual
Maybe
<
uint16_t
>
RtpSendBaseSeqFor
(
uint32_t
aSsrc
)
const
=
0
;
virtual
const
dom
:
:
RTCStatsTimestampMaker
&
GetTimestampMaker
(
)
const
=
0
;
virtual
Ssrcs
GetLocalSSRCs
(
)
const
=
0
;
virtual
Maybe
<
Ssrc
>
GetRemoteSSRC
(
)
const
=
0
;
virtual
void
UnsetRemoteSSRC
(
Ssrc
aSsrc
)
=
0
;
virtual
void
DisableSsrcChanges
(
)
=
0
;
virtual
bool
HasCodecPluginID
(
uint64_t
aPluginID
)
const
=
0
;
virtual
MediaEventSource
<
void
>
&
RtcpByeEvent
(
)
=
0
;
virtual
MediaEventSource
<
void
>
&
RtcpTimeoutEvent
(
)
=
0
;
virtual
bool
SendRtp
(
const
uint8_t
*
aData
size_t
aLength
const
webrtc
:
:
PacketOptions
&
aOptions
)
=
0
;
virtual
bool
SendSenderRtcp
(
const
uint8_t
*
aData
size_t
aLength
)
=
0
;
virtual
bool
SendReceiverRtcp
(
const
uint8_t
*
aData
size_t
aLength
)
=
0
;
virtual
void
DeliverPacket
(
rtc
:
:
CopyOnWriteBuffer
packet
PacketType
type
)
=
0
;
virtual
RefPtr
<
GenericPromise
>
Shutdown
(
)
=
0
;
virtual
Maybe
<
RefPtr
<
AudioSessionConduit
>
>
AsAudioSessionConduit
(
)
=
0
;
virtual
Maybe
<
RefPtr
<
VideoSessionConduit
>
>
AsVideoSessionConduit
(
)
=
0
;
virtual
Maybe
<
webrtc
:
:
CallBasicStats
>
GetCallStats
(
)
const
=
0
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaSessionConduit
)
void
GetRtpSources
(
nsTArray
<
dom
:
:
RTCRtpSourceEntry
>
&
outSources
)
const
;
void
InsertAudioLevelForContributingSource
(
const
uint32_t
aCsrcSource
const
int64_t
aTimestamp
const
uint32_t
aRtpTimestamp
const
bool
aHasAudioLevel
const
uint8_t
aAudioLevel
)
;
protected
:
virtual
std
:
:
vector
<
webrtc
:
:
RtpSource
>
GetUpstreamRtpSources
(
)
const
=
0
;
private
:
void
UpdateRtpSources
(
const
std
:
:
vector
<
webrtc
:
:
RtpSource
>
&
aSources
)
const
;
void
OnSourcesUpdated
(
)
const
;
class
SourceKey
{
public
:
explicit
SourceKey
(
const
webrtc
:
:
RtpSource
&
aSource
)
:
SourceKey
(
aSource
.
timestamp_ms
(
)
aSource
.
source_id
(
)
)
{
}
SourceKey
(
uint32_t
aTimestamp
uint32_t
aSrc
)
:
mLibwebrtcTimestampMs
(
aTimestamp
)
mSrc
(
aSrc
)
{
}
auto
operator
>
(
const
SourceKey
&
aRhs
)
const
{
if
(
mLibwebrtcTimestampMs
=
=
aRhs
.
mLibwebrtcTimestampMs
)
{
return
mSrc
>
aRhs
.
mSrc
;
}
return
mLibwebrtcTimestampMs
>
aRhs
.
mLibwebrtcTimestampMs
;
}
private
:
uint32_t
mLibwebrtcTimestampMs
;
uint32_t
mSrc
;
}
;
mutable
std
:
:
map
<
SourceKey
dom
:
:
RTCRtpSourceEntry
std
:
:
greater
<
SourceKey
>
>
mSourcesCache
;
mutable
bool
mSourcesUpdateNeeded
=
true
;
}
;
class
WebrtcSendTransport
:
public
webrtc
:
:
Transport
{
MediaSessionConduit
*
mConduit
;
public
:
explicit
WebrtcSendTransport
(
MediaSessionConduit
*
aConduit
)
:
mConduit
(
aConduit
)
{
}
bool
SendRtp
(
const
uint8_t
*
aPacket
size_t
aLength
const
webrtc
:
:
PacketOptions
&
aOptions
)
override
{
return
mConduit
-
>
SendRtp
(
aPacket
aLength
aOptions
)
;
}
bool
SendRtcp
(
const
uint8_t
*
aPacket
size_t
aLength
)
override
{
return
mConduit
-
>
SendSenderRtcp
(
aPacket
aLength
)
;
}
}
;
class
WebrtcReceiveTransport
:
public
webrtc
:
:
Transport
{
MediaSessionConduit
*
mConduit
;
public
:
explicit
WebrtcReceiveTransport
(
MediaSessionConduit
*
aConduit
)
:
mConduit
(
aConduit
)
{
}
bool
SendRtp
(
const
uint8_t
*
aPacket
size_t
aLength
const
webrtc
:
:
PacketOptions
&
aOptions
)
override
{
MOZ_CRASH
(
"
Unexpected
RTP
packet
"
)
;
}
bool
SendRtcp
(
const
uint8_t
*
aPacket
size_t
aLength
)
override
{
return
mConduit
-
>
SendReceiverRtcp
(
aPacket
aLength
)
;
}
}
;
class
CodecPluginID
{
public
:
virtual
MediaEventSource
<
uint64_t
>
*
InitPluginEvent
(
)
{
return
nullptr
;
}
virtual
MediaEventSource
<
uint64_t
>
*
ReleasePluginEvent
(
)
{
return
nullptr
;
}
virtual
~
CodecPluginID
(
)
{
}
}
;
class
VideoEncoder
:
public
CodecPluginID
{
public
:
virtual
~
VideoEncoder
(
)
{
}
}
;
class
VideoDecoder
:
public
CodecPluginID
{
public
:
virtual
~
VideoDecoder
(
)
{
}
}
;
class
VideoSessionConduit
:
public
MediaSessionConduit
{
public
:
struct
Options
{
bool
mVideoLatencyTestEnable
=
false
;
int
mMinBitrate
=
0
;
int
mStartBitrate
=
0
;
int
mPrefMaxBitrate
=
0
;
int
mMinBitrateEstimate
=
0
;
bool
mDenoising
=
false
;
bool
mLockScaling
=
false
;
uint8_t
mSpatialLayers
=
1
;
uint8_t
mTemporalLayers
=
1
;
}
;
static
RefPtr
<
VideoSessionConduit
>
Create
(
RefPtr
<
WebrtcCallWrapper
>
aCall
nsCOMPtr
<
nsISerialEventTarget
>
aStsThread
Options
aOptions
std
:
:
string
aPCHandle
)
;
enum
FrameRequestType
{
FrameRequestNone
FrameRequestFir
FrameRequestPli
FrameRequestUnknown
}
;
VideoSessionConduit
(
)
:
mFrameRequestMethod
(
FrameRequestNone
)
mUsingNackBasic
(
false
)
mUsingTmmbr
(
false
)
mUsingFEC
(
false
)
{
}
virtual
~
VideoSessionConduit
(
)
{
}
Type
type
(
)
const
override
{
return
VIDEO
;
}
Maybe
<
RefPtr
<
AudioSessionConduit
>
>
AsAudioSessionConduit
(
)
override
{
return
Nothing
(
)
;
}
Maybe
<
RefPtr
<
VideoSessionConduit
>
>
AsVideoSessionConduit
(
)
override
{
return
Some
(
RefPtr
<
VideoSessionConduit
>
(
this
)
)
;
}
virtual
void
InitControl
(
VideoConduitControlInterface
*
aControl
)
=
0
;
virtual
MediaConduitErrorCode
AttachRenderer
(
RefPtr
<
mozilla
:
:
VideoRenderer
>
aRenderer
)
=
0
;
virtual
void
DetachRenderer
(
)
=
0
;
virtual
MediaConduitErrorCode
SendVideoFrame
(
webrtc
:
:
VideoFrame
aFrame
)
=
0
;
FrameRequestType
FrameRequestMethod
(
)
const
{
return
mFrameRequestMethod
;
}
bool
UsingNackBasic
(
)
const
{
return
mUsingNackBasic
;
}
bool
UsingTmmbr
(
)
const
{
return
mUsingTmmbr
;
}
bool
UsingFEC
(
)
const
{
return
mUsingFEC
;
}
virtual
Maybe
<
webrtc
:
:
VideoReceiveStream
:
:
Stats
>
GetReceiverStats
(
)
const
=
0
;
virtual
Maybe
<
webrtc
:
:
VideoSendStream
:
:
Stats
>
GetSenderStats
(
)
const
=
0
;
virtual
void
CollectTelemetryData
(
)
=
0
;
virtual
bool
AddFrameHistory
(
dom
:
:
Sequence
<
dom
:
:
RTCVideoFrameHistoryInternal
>
*
outHistories
)
const
=
0
;
protected
:
FrameRequestType
mFrameRequestMethod
;
bool
mUsingNackBasic
;
bool
mUsingTmmbr
;
bool
mUsingFEC
;
}
;
class
AudioSessionConduit
:
public
MediaSessionConduit
{
public
:
static
RefPtr
<
AudioSessionConduit
>
Create
(
RefPtr
<
WebrtcCallWrapper
>
aCall
nsCOMPtr
<
nsISerialEventTarget
>
aStsThread
)
;
virtual
~
AudioSessionConduit
(
)
{
}
Type
type
(
)
const
override
{
return
AUDIO
;
}
Maybe
<
RefPtr
<
AudioSessionConduit
>
>
AsAudioSessionConduit
(
)
override
{
return
Some
(
this
)
;
}
Maybe
<
RefPtr
<
VideoSessionConduit
>
>
AsVideoSessionConduit
(
)
override
{
return
Nothing
(
)
;
}
virtual
void
InitControl
(
AudioConduitControlInterface
*
aControl
)
=
0
;
virtual
MediaConduitErrorCode
SendAudioFrame
(
std
:
:
unique_ptr
<
webrtc
:
:
AudioFrame
>
frame
)
=
0
;
virtual
MediaConduitErrorCode
GetAudioFrame
(
int32_t
samplingFreqHz
webrtc
:
:
AudioFrame
*
frame
)
=
0
;
virtual
bool
IsSamplingFreqSupported
(
int
freq
)
const
=
0
;
virtual
Maybe
<
webrtc
:
:
AudioReceiveStream
:
:
Stats
>
GetReceiverStats
(
)
const
=
0
;
virtual
Maybe
<
webrtc
:
:
AudioSendStream
:
:
Stats
>
GetSenderStats
(
)
const
=
0
;
}
;
}
#
endif
