#
include
"
VideoConduit
.
h
"
#
include
<
algorithm
>
#
include
<
cinttypes
>
#
include
<
cmath
>
#
include
"
common
/
browser_logging
/
CSFLog
.
h
"
#
include
"
common
/
YuvStamper
.
h
"
#
include
"
GmpVideoCodec
.
h
"
#
include
"
MediaDataCodec
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpSourcesBinding
.
h
"
#
include
"
mozilla
/
media
/
MediaUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
nsIGfxInfo
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
RtpRtcpConfig
.
h
"
#
include
"
VideoStreamFactory
.
h
"
#
include
"
WebrtcCallWrapper
.
h
"
#
include
"
WebrtcGmpVideoCodec
.
h
"
#
include
"
api
/
transport
/
bitrate_settings
.
h
"
#
include
"
api
/
video_codecs
/
sdp_video_format
.
h
"
#
include
"
api
/
video_codecs
/
video_codec
.
h
"
#
include
"
media
/
base
/
media_constants
.
h
"
#
include
"
media
/
engine
/
encoder_simulcast_proxy
.
h
"
#
include
"
modules
/
rtp_rtcp
/
include
/
rtp_rtcp_defines
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
vp8
/
include
/
vp8
.
h
"
#
include
"
modules
/
video_coding
/
codecs
/
vp9
/
include
/
vp9
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
VideoEngine
.
h
"
#
endif
#
ifdef
MOZ_WEBRTC_MEDIACODEC
#
include
"
MediaCodecVideoCodec
.
h
"
#
endif
#
ifdef
_MSC_VER
#
include
"
Winsock2
.
h
"
#
else
#
include
<
netinet
/
in
.
h
>
#
endif
#
define
DEFAULT_VIDEO_MAX_FRAMERATE
30
#
define
INVALID_RTP_PAYLOAD
255
/
/
valid
payload
types
are
0
to
127
namespace
mozilla
{
namespace
{
const
char
*
vcLogTag
=
"
WebrtcVideoSessionConduit
"
;
#
ifdef
LOGTAG
#
undef
LOGTAG
#
endif
#
define
LOGTAG
vcLogTag
using
LocalDirection
=
MediaSessionConduitLocalDirection
;
const
int
kNullPayloadType
=
-
1
;
const
char
*
kUlpFecPayloadName
=
"
ulpfec
"
;
const
char
*
kRedPayloadName
=
"
red
"
;
#
define
SCALER_BUFFER_POOL_SIZE
5
#
define
SIMULCAST_RESOLUTION_ALIGNMENT
16
template
<
class
t
>
void
ConstrainPreservingAspectRatioExact
(
uint32_t
max_fs
t
*
width
t
*
height
)
{
for
(
size_t
d
=
1
;
d
<
std
:
:
min
(
*
width
*
height
)
;
+
+
d
)
{
if
(
(
*
width
%
d
)
|
|
(
*
height
%
d
)
)
{
continue
;
}
if
(
(
(
*
width
)
*
(
*
height
)
)
/
(
d
*
d
)
<
=
max_fs
)
{
*
width
/
=
d
;
*
height
/
=
d
;
return
;
}
}
*
width
=
0
;
*
height
=
0
;
}
template
<
class
t
>
void
ConstrainPreservingAspectRatio
(
uint16_t
max_width
uint16_t
max_height
t
*
width
t
*
height
)
{
if
(
(
(
*
width
)
<
=
max_width
)
&
&
(
(
*
height
)
<
=
max_height
)
)
{
return
;
}
if
(
(
*
width
)
*
max_height
>
max_width
*
(
*
height
)
)
{
(
*
height
)
=
max_width
*
(
*
height
)
/
(
*
width
)
;
(
*
width
)
=
max_width
;
}
else
{
(
*
width
)
=
max_height
*
(
*
width
)
/
(
*
height
)
;
(
*
height
)
=
max_height
;
}
}
unsigned
int
SelectSendFrameRate
(
const
VideoCodecConfig
&
codecConfig
unsigned
int
old_framerate
unsigned
short
sending_width
unsigned
short
sending_height
)
{
unsigned
int
new_framerate
=
old_framerate
;
if
(
codecConfig
.
mEncodingConstraints
.
maxMbps
)
{
unsigned
int
cur_fs
mb_width
mb_height
;
mb_width
=
(
sending_width
+
15
)
>
>
4
;
mb_height
=
(
sending_height
+
15
)
>
>
4
;
cur_fs
=
mb_width
*
mb_height
;
if
(
cur_fs
>
0
)
{
new_framerate
=
codecConfig
.
mEncodingConstraints
.
maxMbps
/
cur_fs
;
new_framerate
=
MinIgnoreZero
(
new_framerate
codecConfig
.
mEncodingConstraints
.
maxFps
)
;
}
}
return
new_framerate
;
}
MediaConduitErrorCode
ValidateCodecConfig
(
const
VideoCodecConfig
&
codecInfo
)
{
if
(
codecInfo
.
mName
.
empty
(
)
)
{
CSFLogError
(
LOGTAG
"
%
s
Empty
Payload
Name
"
__FUNCTION__
)
;
return
kMediaConduitMalformedArgument
;
}
return
kMediaConduitNoError
;
}
webrtc
:
:
VideoCodecType
SupportedCodecType
(
webrtc
:
:
VideoCodecType
aType
)
{
switch
(
aType
)
{
case
webrtc
:
:
VideoCodecType
:
:
kVideoCodecVP8
:
case
webrtc
:
:
VideoCodecType
:
:
kVideoCodecVP9
:
case
webrtc
:
:
VideoCodecType
:
:
kVideoCodecH264
:
return
aType
;
default
:
return
webrtc
:
:
VideoCodecType
:
:
kVideoCodecGeneric
;
}
}
rtc
:
:
scoped_refptr
<
webrtc
:
:
VideoEncoderConfig
:
:
EncoderSpecificSettings
>
ConfigureVideoEncoderSettings
(
const
VideoCodecConfig
&
aConfig
const
WebrtcVideoConduit
*
aConduit
)
{
bool
is_screencast
=
aConduit
-
>
CodecMode
(
)
=
=
webrtc
:
:
VideoCodecMode
:
:
kScreensharing
;
bool
automatic_resize
=
!
is_screencast
&
&
aConfig
.
mEncodings
.
size
(
)
<
=
1
;
bool
frame_dropping
=
!
is_screencast
;
bool
denoising
;
bool
codec_default_denoising
=
false
;
if
(
is_screencast
)
{
denoising
=
false
;
}
else
{
denoising
=
aConduit
-
>
Denoising
(
)
;
codec_default_denoising
=
!
denoising
;
}
if
(
aConfig
.
mName
=
=
"
H264
"
)
{
webrtc
:
:
VideoCodecH264
h264_settings
=
webrtc
:
:
VideoEncoder
:
:
GetDefaultH264Settings
(
)
;
h264_settings
.
frameDroppingOn
=
frame_dropping
;
h264_settings
.
packetizationMode
=
aConfig
.
mPacketizationMode
;
return
new
rtc
:
:
RefCountedObject
<
webrtc
:
:
VideoEncoderConfig
:
:
H264EncoderSpecificSettings
>
(
h264_settings
)
;
}
if
(
aConfig
.
mName
=
=
"
VP8
"
)
{
webrtc
:
:
VideoCodecVP8
vp8_settings
=
webrtc
:
:
VideoEncoder
:
:
GetDefaultVp8Settings
(
)
;
vp8_settings
.
automaticResizeOn
=
automatic_resize
;
vp8_settings
.
denoisingOn
=
codec_default_denoising
?
true
:
denoising
;
vp8_settings
.
frameDroppingOn
=
frame_dropping
;
return
new
rtc
:
:
RefCountedObject
<
webrtc
:
:
VideoEncoderConfig
:
:
Vp8EncoderSpecificSettings
>
(
vp8_settings
)
;
}
if
(
aConfig
.
mName
=
=
"
VP9
"
)
{
webrtc
:
:
VideoCodecVP9
vp9_settings
=
webrtc
:
:
VideoEncoder
:
:
GetDefaultVp9Settings
(
)
;
if
(
is_screencast
)
{
vp9_settings
.
numberOfSpatialLayers
=
2
;
}
else
{
vp9_settings
.
numberOfSpatialLayers
=
aConduit
-
>
SpatialLayers
(
)
;
}
vp9_settings
.
denoisingOn
=
codec_default_denoising
?
false
:
denoising
;
vp9_settings
.
frameDroppingOn
=
true
;
return
new
rtc
:
:
RefCountedObject
<
webrtc
:
:
VideoEncoderConfig
:
:
Vp9EncoderSpecificSettings
>
(
vp9_settings
)
;
}
return
nullptr
;
}
bool
CodecsDifferent
(
const
std
:
:
vector
<
VideoCodecConfig
>
&
a
const
std
:
:
vector
<
VideoCodecConfig
>
&
b
)
{
return
a
!
=
b
;
}
uint32_t
GenerateRandomSSRC
(
)
{
uint32_t
ssrc
;
do
{
SECStatus
rv
=
PK11_GenerateRandom
(
reinterpret_cast
<
unsigned
char
*
>
(
&
ssrc
)
sizeof
(
ssrc
)
)
;
if
(
rv
!
=
SECSuccess
)
{
CSFLogError
(
LOGTAG
"
%
s
:
PK11_GenerateRandom
failed
with
error
%
d
"
__FUNCTION__
rv
)
;
return
0
;
}
}
while
(
ssrc
=
=
0
)
;
return
ssrc
;
}
bool
operator
=
=
(
const
rtc
:
:
VideoSinkWants
&
aThis
const
rtc
:
:
VideoSinkWants
&
aOther
)
{
return
aThis
.
max_pixel_count
=
=
aOther
.
max_pixel_count
;
}
bool
operator
!
=
(
const
rtc
:
:
VideoSinkWants
&
aThis
const
rtc
:
:
VideoSinkWants
&
aOther
)
{
return
!
(
aThis
=
=
aOther
)
;
}
}
RefPtr
<
VideoSessionConduit
>
VideoSessionConduit
:
:
Create
(
RefPtr
<
WebrtcCallWrapper
>
aCall
nsCOMPtr
<
nsISerialEventTarget
>
aStsThread
Options
aOptions
std
:
:
string
aPCHandle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aCall
"
missing
required
parameter
:
aCall
"
)
;
CSFLogVerbose
(
LOGTAG
"
%
s
"
__FUNCTION__
)
;
if
(
!
aCall
)
{
return
nullptr
;
}
auto
obj
=
MakeRefPtr
<
WebrtcVideoConduit
>
(
std
:
:
move
(
aCall
)
std
:
:
move
(
aStsThread
)
std
:
:
move
(
aOptions
)
std
:
:
move
(
aPCHandle
)
)
;
if
(
obj
-
>
Init
(
)
!
=
kMediaConduitNoError
)
{
CSFLogError
(
LOGTAG
"
%
s
VideoConduit
Init
Failed
"
__FUNCTION__
)
;
return
nullptr
;
}
CSFLogVerbose
(
LOGTAG
"
%
s
Successfully
created
VideoConduit
"
__FUNCTION__
)
;
return
obj
.
forget
(
)
;
}
WebrtcVideoConduit
:
:
WebrtcVideoConduit
(
RefPtr
<
WebrtcCallWrapper
>
aCall
nsCOMPtr
<
nsISerialEventTarget
>
aStsThread
Options
aOptions
std
:
:
string
aPCHandle
)
:
mTransportMonitor
(
"
WebrtcVideoConduit
"
)
mCallThread
(
aCall
-
>
mCallThread
)
mStsThread
(
std
:
:
move
(
aStsThread
)
)
mMutex
(
"
WebrtcVideoConduit
:
:
mMutex
"
)
mDecoderFactory
(
MakeUnique
<
WebrtcVideoDecoderFactory
>
(
mCallThread
.
get
(
)
aPCHandle
)
)
mEncoderFactory
(
MakeUnique
<
WebrtcVideoEncoderFactory
>
(
mCallThread
.
get
(
)
std
:
:
move
(
aPCHandle
)
)
)
mVideoAdapter
(
MakeUnique
<
cricket
:
:
VideoAdapter
>
(
)
)
mBufferPool
(
false
SCALER_BUFFER_POOL_SIZE
)
mEngineTransmitting
(
false
)
mEngineReceiving
(
false
)
mSendingFramerate
(
DEFAULT_VIDEO_MAX_FRAMERATE
)
mVideoLatencyTestEnable
(
aOptions
.
mVideoLatencyTestEnable
)
mMinBitrate
(
aOptions
.
mMinBitrate
)
mStartBitrate
(
aOptions
.
mStartBitrate
)
mPrefMaxBitrate
(
aOptions
.
mPrefMaxBitrate
)
mMinBitrateEstimate
(
aOptions
.
mMinBitrateEstimate
)
mDenoising
(
aOptions
.
mDenoising
)
mLockScaling
(
aOptions
.
mLockScaling
)
mSpatialLayers
(
aOptions
.
mSpatialLayers
)
mTemporalLayers
(
aOptions
.
mTemporalLayers
)
mActiveCodecMode
(
webrtc
:
:
VideoCodecMode
:
:
kRealtimeVideo
)
mCodecMode
(
webrtc
:
:
VideoCodecMode
:
:
kRealtimeVideo
)
mCall
(
std
:
:
move
(
aCall
)
)
mSendStreamConfig
(
this
)
mRecvStreamConfig
(
this
)
mRecvSSRC
(
0
)
mRemoteSSRC
(
0
)
{
}
WebrtcVideoConduit
:
:
~
WebrtcVideoConduit
(
)
{
CSFLogDebug
(
LOGTAG
"
%
s
"
__FUNCTION__
)
;
MOZ_ASSERT
(
!
mSendStream
&
&
!
mRecvStream
"
Call
DeleteStreams
prior
to
~
WebrtcVideoConduit
.
"
)
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
SetLocalRTPExtensions
(
LocalDirection
aDirection
const
RtpExtList
&
aExtensions
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
auto
&
extList
=
aDirection
=
=
LocalDirection
:
:
kSend
?
mSendStreamConfig
.
rtp
.
extensions
:
mRecvStreamConfig
.
rtp
.
extensions
;
extList
=
aExtensions
;
return
kMediaConduitNoError
;
}
bool
WebrtcVideoConduit
:
:
SetLocalSSRCs
(
const
std
:
:
vector
<
unsigned
int
>
&
aSSRCs
const
std
:
:
vector
<
unsigned
int
>
&
aRtxSSRCs
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
if
(
mSendStreamConfig
.
rtp
.
ssrcs
=
=
aSSRCs
&
&
mSendStreamConfig
.
rtp
.
rtx
.
ssrcs
=
=
aRtxSSRCs
)
{
return
true
;
}
{
MutexAutoLock
lock
(
mMutex
)
;
mSendStreamConfig
.
rtp
.
ssrcs
=
aSSRCs
;
mSendStreamConfig
.
rtp
.
rtx
.
ssrcs
=
aRtxSSRCs
;
bool
wasTransmitting
=
mEngineTransmitting
;
if
(
StopTransmittingLocked
(
)
!
=
kMediaConduitNoError
)
{
return
false
;
}
DeleteSendStream
(
)
;
if
(
wasTransmitting
)
{
if
(
StartTransmittingLocked
(
)
!
=
kMediaConduitNoError
)
{
return
false
;
}
}
}
return
true
;
}
std
:
:
vector
<
unsigned
int
>
WebrtcVideoConduit
:
:
GetLocalSSRCs
(
)
const
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
return
mSendStreamConfig
.
rtp
.
ssrcs
;
}
bool
WebrtcVideoConduit
:
:
SetLocalCNAME
(
const
char
*
cname
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
mSendStreamConfig
.
rtp
.
c_name
=
cname
;
return
true
;
}
bool
WebrtcVideoConduit
:
:
SetLocalMID
(
const
std
:
:
string
&
mid
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
mSendStreamConfig
.
rtp
.
mid
=
mid
;
return
true
;
}
void
WebrtcVideoConduit
:
:
SetSyncGroup
(
const
std
:
:
string
&
group
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
mRecvStreamConfig
.
sync_group
=
group
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
ConfigureCodecMode
(
webrtc
:
:
VideoCodecMode
mode
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
CSFLogVerbose
(
LOGTAG
"
%
s
"
__FUNCTION__
)
;
if
(
mode
=
=
webrtc
:
:
VideoCodecMode
:
:
kRealtimeVideo
|
|
mode
=
=
webrtc
:
:
VideoCodecMode
:
:
kScreensharing
)
{
mCodecMode
=
mode
;
if
(
mVideoStreamFactory
)
{
mVideoStreamFactory
-
>
SetCodecMode
(
mCodecMode
)
;
}
return
kMediaConduitNoError
;
}
return
kMediaConduitMalformedArgument
;
}
void
WebrtcVideoConduit
:
:
DeleteSendStream
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
mSendStream
)
{
mCall
-
>
Call
(
)
-
>
DestroyVideoSendStream
(
mSendStream
)
;
mSendStream
=
nullptr
;
}
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
CreateSendStream
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
nsAutoString
codecName
;
codecName
.
AssignASCII
(
mSendStreamConfig
.
rtp
.
payload_name
.
c_str
(
)
)
;
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
WEBRTC_VIDEO_SEND_CODEC_USED
codecName
1
)
;
mSendStreamConfig
.
encoder_settings
.
encoder_factory
=
mEncoderFactory
.
get
(
)
;
mSendStreamConfig
.
encoder_settings
.
bitrate_allocator_factory
=
mCall
-
>
mVideoBitrateAllocatorFactory
.
get
(
)
;
MOZ_ASSERT
(
mSendStreamConfig
.
rtp
.
ssrcs
.
size
(
)
=
=
mEncoderConfig
.
number_of_streams
"
Each
video
substream
must
have
a
corresponding
ssrc
.
"
)
;
mSendStream
=
mCall
-
>
Call
(
)
-
>
CreateVideoSendStream
(
mSendStreamConfig
.
Copy
(
)
mEncoderConfig
.
Copy
(
)
)
;
if
(
!
mSendStream
)
{
return
kMediaConduitVideoSendStreamError
;
}
mSendStream
-
>
SetSource
(
this
webrtc
:
:
DegradationPreference
:
:
BALANCED
)
;
mActiveCodecMode
=
mCodecMode
;
return
kMediaConduitNoError
;
}
void
WebrtcVideoConduit
:
:
DeleteRecvStream
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
mRecvStream
)
{
mCall
-
>
Call
(
)
-
>
DestroyVideoReceiveStream
(
mRecvStream
)
;
mRecvStream
=
nullptr
;
}
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
CreateRecvStream
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
mRecvStreamConfig
.
renderer
=
this
;
mRecvStreamConfig
.
decoders
.
clear
(
)
;
for
(
auto
&
config
:
mRecvCodecList
)
{
nsAutoString
codecName
;
codecName
.
AssignASCII
(
config
.
mName
.
c_str
(
)
)
;
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
WEBRTC_VIDEO_RECV_CODEC_USED
codecName
1
)
;
if
(
SupportedCodecType
(
webrtc
:
:
PayloadStringToCodecType
(
config
.
mName
)
)
=
=
webrtc
:
:
VideoCodecType
:
:
kVideoCodecGeneric
)
{
CSFLogError
(
LOGTAG
"
%
s
Unknown
decoder
type
:
%
s
"
__FUNCTION__
config
.
mName
.
c_str
(
)
)
;
continue
;
}
webrtc
:
:
VideoReceiveStream
:
:
Decoder
decoder
;
decoder
.
video_format
=
webrtc
:
:
SdpVideoFormat
(
config
.
mName
)
;
decoder
.
payload_type
=
config
.
mType
;
mRecvStreamConfig
.
decoders
.
push_back
(
std
:
:
move
(
decoder
)
)
;
}
mRecvStreamConfig
.
decoder_factory
=
mDecoderFactory
.
get
(
)
;
mRecvStreamConfig
.
rtp
.
rtcp_event_observer
=
this
;
mRecvStream
=
mCall
-
>
Call
(
)
-
>
CreateVideoReceiveStream
(
mRecvStreamConfig
.
Copy
(
)
)
;
if
(
!
mRecvStream
)
{
return
kMediaConduitUnknownError
;
}
CSFLogDebug
(
LOGTAG
"
Created
VideoReceiveStream
%
p
for
SSRC
%
u
(
0x
%
x
)
"
mRecvStream
mRecvStreamConfig
.
rtp
.
remote_ssrc
mRecvStreamConfig
.
rtp
.
remote_ssrc
)
;
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
ConfigureSendMediaCodec
(
const
VideoCodecConfig
&
codecConfig
const
RtpRtcpConfig
&
aRtpRtcpConfig
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
mUpdateSendResolution
=
true
;
CSFLogDebug
(
LOGTAG
"
%
s
for
%
s
"
__FUNCTION__
codecConfig
.
mName
.
c_str
(
)
)
;
MediaConduitErrorCode
condError
=
kMediaConduitNoError
;
if
(
(
condError
=
ValidateCodecConfig
(
codecConfig
)
)
!
=
kMediaConduitNoError
)
{
return
condError
;
}
size_t
streamCount
=
std
:
:
min
(
codecConfig
.
mEncodings
.
size
(
)
(
size_t
)
webrtc
:
:
kMaxSimulcastStreams
)
;
size_t
highestResolutionIndex
=
0
;
for
(
size_t
i
=
1
;
i
<
streamCount
;
+
+
i
)
{
if
(
codecConfig
.
mEncodings
[
i
]
.
constraints
.
scaleDownBy
<
codecConfig
.
mEncodings
[
highestResolutionIndex
]
.
constraints
.
scaleDownBy
)
{
highestResolutionIndex
=
i
;
}
}
MOZ_RELEASE_ASSERT
(
streamCount
>
=
1
"
streamCount
should
be
at
least
one
"
)
;
CSFLogDebug
(
LOGTAG
"
%
s
for
VideoConduit
:
%
p
stream
count
:
%
zu
"
__FUNCTION__
this
streamCount
)
;
mSendingFramerate
=
0
;
mSendStreamConfig
.
rtp
.
rids
.
clear
(
)
;
int
max_framerate
;
if
(
codecConfig
.
mEncodingConstraints
.
maxFps
>
0
)
{
max_framerate
=
codecConfig
.
mEncodingConstraints
.
maxFps
;
}
else
{
max_framerate
=
DEFAULT_VIDEO_MAX_FRAMERATE
;
}
mSendingFramerate
=
SelectSendFrameRate
(
codecConfig
max_framerate
mLastWidth
mLastHeight
)
;
mNegotiatedMaxBitrate
=
codecConfig
.
mTias
;
if
(
mLastWidth
=
=
0
&
&
mMinBitrateEstimate
!
=
0
)
{
webrtc
:
:
BitrateSettings
settings
;
settings
.
min_bitrate_bps
=
mMinBitrateEstimate
;
settings
.
start_bitrate_bps
=
mMinBitrateEstimate
;
mCall
-
>
Call
(
)
-
>
SetClientBitratePreferences
(
settings
)
;
}
mVideoStreamFactory
=
new
rtc
:
:
RefCountedObject
<
VideoStreamFactory
>
(
codecConfig
mCodecMode
mMinBitrate
mStartBitrate
mPrefMaxBitrate
mNegotiatedMaxBitrate
mSendingFramerate
)
;
mEncoderConfig
.
video_stream_factory
=
mVideoStreamFactory
.
get
(
)
;
mVideoAdapter
=
MakeUnique
<
cricket
:
:
VideoAdapter
>
(
streamCount
>
1
?
SIMULCAST_RESOLUTION_ALIGNMENT
:
1
)
;
mVideoAdapter
-
>
OnScaleResolutionBy
(
codecConfig
.
mEncodings
[
highestResolutionIndex
]
.
constraints
.
scaleDownBy
>
1
.
0
?
absl
:
:
optional
<
float
>
(
codecConfig
.
mEncodings
[
highestResolutionIndex
]
.
constraints
.
scaleDownBy
)
:
absl
:
:
optional
<
float
>
(
)
)
;
mEncoderConfig
.
encoder_specific_settings
=
ConfigureVideoEncoderSettings
(
codecConfig
this
)
;
mEncoderConfig
.
codec_type
=
SupportedCodecType
(
webrtc
:
:
PayloadStringToCodecType
(
codecConfig
.
mName
)
)
;
MOZ_RELEASE_ASSERT
(
mEncoderConfig
.
codec_type
!
=
webrtc
:
:
VideoCodecType
:
:
kVideoCodecGeneric
)
;
mEncoderConfig
.
video_format
=
webrtc
:
:
SdpVideoFormat
(
codecConfig
.
mName
)
;
mEncoderConfig
.
content_type
=
mCodecMode
=
=
webrtc
:
:
VideoCodecMode
:
:
kRealtimeVideo
?
webrtc
:
:
VideoEncoderConfig
:
:
ContentType
:
:
kRealtimeVideo
:
webrtc
:
:
VideoEncoderConfig
:
:
ContentType
:
:
kScreen
;
mEncoderConfig
.
min_transmit_bitrate_bps
=
mMinBitrate
;
int
maxBps
=
KBPS
(
10000
)
;
maxBps
=
MinIgnoreZero
(
maxBps
mPrefMaxBitrate
)
;
maxBps
=
MinIgnoreZero
(
maxBps
mNegotiatedMaxBitrate
)
;
maxBps
=
MinIgnoreZero
(
maxBps
static_cast
<
int
>
(
codecConfig
.
mEncodingConstraints
.
maxBr
)
)
;
if
(
codecConfig
.
mEncodings
.
size
(
)
=
=
1
)
{
maxBps
=
MinIgnoreZero
(
maxBps
static_cast
<
int
>
(
codecConfig
.
mEncodings
[
0
]
.
constraints
.
maxBr
)
)
;
}
mEncoderConfig
.
max_bitrate_bps
=
maxBps
;
mEncoderConfig
.
bitrate_priority
=
1
.
0
;
mEncoderConfig
.
number_of_streams
=
streamCount
;
if
(
mSendStream
)
{
if
(
!
RequiresNewSendStream
(
codecConfig
)
&
&
mActiveCodecMode
=
=
mCodecMode
)
{
mCurSendCodecConfig
-
>
mEncodingConstraints
=
codecConfig
.
mEncodingConstraints
;
mCurSendCodecConfig
-
>
mEncodings
=
codecConfig
.
mEncodings
;
mSendStream
-
>
ReconfigureVideoEncoder
(
mEncoderConfig
.
Copy
(
)
)
;
return
kMediaConduitNoError
;
}
condError
=
StopTransmittingLocked
(
)
;
if
(
condError
!
=
kMediaConduitNoError
)
{
return
condError
;
}
DeleteSendStream
(
)
;
}
mSendStreamConfig
.
suspend_below_min_bitrate
=
false
;
mSendStreamConfig
.
rtp
.
payload_name
=
codecConfig
.
mName
;
mSendStreamConfig
.
rtp
.
payload_type
=
codecConfig
.
mType
;
mSendStreamConfig
.
rtp
.
rtcp_mode
=
aRtpRtcpConfig
.
GetRtcpMode
(
)
;
mSendStreamConfig
.
rtp
.
max_packet_size
=
kVideoMtu
;
if
(
codecConfig
.
RtxPayloadTypeIsSet
(
)
)
{
mSendStreamConfig
.
rtp
.
rtx
.
payload_type
=
codecConfig
.
mRTXPayloadType
;
}
else
{
mSendStreamConfig
.
rtp
.
rtx
.
payload_type
=
-
1
;
mSendStreamConfig
.
rtp
.
rtx
.
ssrcs
.
clear
(
)
;
}
if
(
codecConfig
.
RtcpFbFECIsSet
(
)
&
&
!
(
codecConfig
.
mName
=
=
"
H264
"
&
&
codecConfig
.
RtcpFbNackIsSet
(
"
"
)
)
)
{
mSendStreamConfig
.
rtp
.
ulpfec
.
ulpfec_payload_type
=
codecConfig
.
mULPFECPayloadType
;
mSendStreamConfig
.
rtp
.
ulpfec
.
red_payload_type
=
codecConfig
.
mREDPayloadType
;
mSendStreamConfig
.
rtp
.
ulpfec
.
red_rtx_payload_type
=
codecConfig
.
mREDRTXPayloadType
;
}
else
{
mSendStreamConfig
.
rtp
.
ulpfec
.
ulpfec_payload_type
=
-
1
;
mSendStreamConfig
.
rtp
.
ulpfec
.
red_payload_type
=
-
1
;
mSendStreamConfig
.
rtp
.
ulpfec
.
red_rtx_payload_type
=
-
1
;
}
mSendStreamConfig
.
rtp
.
nack
.
rtp_history_ms
=
codecConfig
.
RtcpFbNackIsSet
(
"
"
)
?
1000
:
0
;
mCurSendCodecConfig
=
Some
(
codecConfig
)
;
mSendStreamConfig
.
rtp
.
rids
.
clear
(
)
;
bool
has_rid
=
false
;
for
(
size_t
idx
=
0
;
idx
<
streamCount
;
idx
+
+
)
{
auto
&
encoding
=
mCurSendCodecConfig
-
>
mEncodings
[
idx
]
;
if
(
encoding
.
rid
[
0
]
)
{
has_rid
=
true
;
break
;
}
}
if
(
has_rid
)
{
for
(
size_t
idx
=
streamCount
;
idx
>
0
;
idx
-
-
)
{
auto
&
encoding
=
mCurSendCodecConfig
-
>
mEncodings
[
idx
-
1
]
;
mSendStreamConfig
.
rtp
.
rids
.
push_back
(
encoding
.
rid
)
;
}
}
return
condError
;
}
bool
WebrtcVideoConduit
:
:
SetRemoteSSRC
(
uint32_t
ssrc
uint32_t
rtxSsrc
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
return
SetRemoteSSRCLocked
(
ssrc
rtxSsrc
)
;
}
bool
WebrtcVideoConduit
:
:
SetRemoteSSRCLocked
(
uint32_t
ssrc
uint32_t
rtxSsrc
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
mRecvStreamConfig
.
rtp
.
remote_ssrc
=
=
ssrc
&
&
mRecvStreamConfig
.
rtp
.
rtx_ssrc
=
=
rtxSsrc
)
{
return
true
;
}
bool
wasReceiving
=
mEngineReceiving
;
if
(
NS_WARN_IF
(
StopReceivingLocked
(
)
!
=
kMediaConduitNoError
)
)
{
return
false
;
}
{
CSFLogDebug
(
LOGTAG
"
%
s
:
SSRC
%
u
(
0x
%
x
)
"
__FUNCTION__
ssrc
ssrc
)
;
MutexAutoUnlock
unlock
(
mMutex
)
;
if
(
!
mCall
-
>
UnsetRemoteSSRC
(
ssrc
)
)
{
CSFLogError
(
LOGTAG
"
%
s
:
Failed
to
unset
SSRC
%
u
(
0x
%
x
)
on
other
conduits
"
"
bailing
"
__FUNCTION__
ssrc
ssrc
)
;
return
false
;
}
}
mCall
-
>
RegisterConduit
(
this
)
;
mRemoteSSRC
=
ssrc
;
mRecvStreamConfig
.
rtp
.
remote_ssrc
=
ssrc
;
mRecvStreamConfig
.
rtp
.
rtx_ssrc
=
rtxSsrc
;
mStsThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
WebrtcVideoConduit
:
:
WaitingForInitialSsrcNoMore
"
[
this
self
=
RefPtr
<
WebrtcVideoConduit
>
(
this
)
]
(
)
mutable
{
mWaitingForInitialSsrc
=
false
;
}
)
)
;
DeleteRecvStream
(
)
;
if
(
wasReceiving
)
{
if
(
StartReceivingLocked
(
)
!
=
kMediaConduitNoError
)
{
return
false
;
}
}
return
true
;
}
bool
WebrtcVideoConduit
:
:
UnsetRemoteSSRC
(
uint32_t
ssrc
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
mRecvStreamConfig
.
rtp
.
remote_ssrc
!
=
ssrc
&
&
mRecvStreamConfig
.
rtp
.
rtx_ssrc
!
=
ssrc
)
{
return
true
;
}
mRecvStreamConfig
.
rtp
.
rtx_ssrc
=
0
;
uint32_t
our_ssrc
=
0
;
do
{
our_ssrc
=
GenerateRandomSSRC
(
)
;
if
(
our_ssrc
=
=
0
)
{
return
false
;
}
}
while
(
our_ssrc
=
=
ssrc
)
;
SetRemoteSSRCLocked
(
our_ssrc
0
)
;
return
true
;
}
bool
WebrtcVideoConduit
:
:
GetRemoteSSRC
(
uint32_t
*
ssrc
)
const
{
if
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
{
if
(
!
mRecvStream
)
{
return
false
;
}
}
*
ssrc
=
mRemoteSSRC
;
return
true
;
}
Maybe
<
webrtc
:
:
VideoReceiveStream
:
:
Stats
>
WebrtcVideoConduit
:
:
GetReceiverStats
(
)
const
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
if
(
!
mRecvStream
)
{
return
Nothing
(
)
;
}
return
Some
(
mRecvStream
-
>
GetStats
(
)
)
;
}
Maybe
<
webrtc
:
:
VideoSendStream
:
:
Stats
>
WebrtcVideoConduit
:
:
GetSenderStats
(
)
const
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
if
(
!
mSendStream
)
{
return
Nothing
(
)
;
}
return
Some
(
mSendStream
-
>
GetStats
(
)
)
;
}
webrtc
:
:
Call
:
:
Stats
WebrtcVideoConduit
:
:
GetCallStats
(
)
const
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
return
mCall
-
>
Call
(
)
-
>
GetStats
(
)
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
CSFLogDebug
(
LOGTAG
"
%
s
this
=
%
p
"
__FUNCTION__
this
)
;
#
ifdef
MOZ_WIDGET_ANDROID
if
(
mozilla
:
:
camera
:
:
VideoEngine
:
:
SetAndroidObjects
(
)
!
=
0
)
{
CSFLogError
(
LOGTAG
"
%
s
:
could
not
set
Android
objects
"
__FUNCTION__
)
;
return
kMediaConduitSessionNotInited
;
}
#
endif
MOZ_ALWAYS_SUCCEEDS
(
mCallThread
-
>
Dispatch
(
NewRunnableMethod
(
__func__
this
&
WebrtcVideoConduit
:
:
InitCall
)
)
)
;
CSFLogDebug
(
LOGTAG
"
%
s
Initialization
Done
"
__FUNCTION__
)
;
return
kMediaConduitNoError
;
}
void
WebrtcVideoConduit
:
:
InitCall
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
mSendPluginCreated
=
mEncoderFactory
-
>
CreatedGmpPluginEvent
(
)
.
Connect
(
GetMainThreadSerialEventTarget
(
)
[
self
=
detail
:
:
RawPtr
(
this
)
]
(
uint64_t
aPluginID
)
{
self
.
get
(
)
-
>
mSendCodecPluginIDs
.
AppendElement
(
aPluginID
)
;
}
)
;
mSendPluginReleased
=
mEncoderFactory
-
>
ReleasedGmpPluginEvent
(
)
.
Connect
(
GetMainThreadSerialEventTarget
(
)
[
self
=
detail
:
:
RawPtr
(
this
)
]
(
uint64_t
aPluginID
)
{
self
.
get
(
)
-
>
mSendCodecPluginIDs
.
RemoveElement
(
aPluginID
)
;
}
)
;
mRecvPluginCreated
=
mDecoderFactory
-
>
CreatedGmpPluginEvent
(
)
.
Connect
(
GetMainThreadSerialEventTarget
(
)
[
self
=
detail
:
:
RawPtr
(
this
)
]
(
uint64_t
aPluginID
)
{
self
.
get
(
)
-
>
mRecvCodecPluginIDs
.
AppendElement
(
aPluginID
)
;
}
)
;
mRecvPluginReleased
=
mDecoderFactory
-
>
ReleasedGmpPluginEvent
(
)
.
Connect
(
GetMainThreadSerialEventTarget
(
)
[
self
=
detail
:
:
RawPtr
(
this
)
]
(
uint64_t
aPluginID
)
{
self
.
get
(
)
-
>
mRecvCodecPluginIDs
.
RemoveElement
(
aPluginID
)
;
}
)
;
}
void
WebrtcVideoConduit
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
using
namespace
Telemetry
;
if
(
mSendBitrate
.
NumDataValues
(
)
>
0
)
{
Accumulate
(
WEBRTC_VIDEO_ENCODER_BITRATE_AVG_PER_CALL_KBPS
mSendBitrate
.
Mean
(
)
/
1000
)
;
Accumulate
(
WEBRTC_VIDEO_ENCODER_BITRATE_STD_DEV_PER_CALL_KBPS
mSendBitrate
.
StandardDeviation
(
)
/
1000
)
;
mSendBitrate
.
Clear
(
)
;
}
if
(
mSendFramerate
.
NumDataValues
(
)
>
0
)
{
Accumulate
(
WEBRTC_VIDEO_ENCODER_FRAMERATE_AVG_PER_CALL
mSendFramerate
.
Mean
(
)
)
;
Accumulate
(
WEBRTC_VIDEO_ENCODER_FRAMERATE_10X_STD_DEV_PER_CALL
mSendFramerate
.
StandardDeviation
(
)
*
10
)
;
mSendFramerate
.
Clear
(
)
;
}
if
(
mRecvBitrate
.
NumDataValues
(
)
>
0
)
{
Accumulate
(
WEBRTC_VIDEO_DECODER_BITRATE_AVG_PER_CALL_KBPS
mRecvBitrate
.
Mean
(
)
/
1000
)
;
Accumulate
(
WEBRTC_VIDEO_DECODER_BITRATE_STD_DEV_PER_CALL_KBPS
mRecvBitrate
.
StandardDeviation
(
)
/
1000
)
;
mRecvBitrate
.
Clear
(
)
;
}
if
(
mRecvFramerate
.
NumDataValues
(
)
>
0
)
{
Accumulate
(
WEBRTC_VIDEO_DECODER_FRAMERATE_AVG_PER_CALL
mRecvFramerate
.
Mean
(
)
)
;
Accumulate
(
WEBRTC_VIDEO_DECODER_FRAMERATE_10X_STD_DEV_PER_CALL
mRecvFramerate
.
StandardDeviation
(
)
*
10
)
;
mRecvFramerate
.
Clear
(
)
;
}
mCall
-
>
UnregisterConduit
(
this
)
;
mSendPluginCreated
.
Disconnect
(
)
;
mSendPluginReleased
.
Disconnect
(
)
;
mRecvPluginCreated
.
Disconnect
(
)
;
mRecvPluginReleased
.
Disconnect
(
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
DeleteSendStream
(
)
;
DeleteRecvStream
(
)
;
}
}
webrtc
:
:
VideoCodecMode
WebrtcVideoConduit
:
:
CodecMode
(
)
const
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
return
mCodecMode
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
AttachRenderer
(
RefPtr
<
mozilla
:
:
VideoRenderer
>
aVideoRenderer
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
CSFLogDebug
(
LOGTAG
"
%
s
"
__FUNCTION__
)
;
if
(
!
aVideoRenderer
)
{
CSFLogError
(
LOGTAG
"
%
s
NULL
Renderer
"
__FUNCTION__
)
;
MOZ_ASSERT
(
false
)
;
return
kMediaConduitInvalidRenderer
;
}
{
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
mRenderer
=
aVideoRenderer
;
mRenderer
-
>
FrameSizeChange
(
mReceivingWidth
mReceivingHeight
)
;
}
return
kMediaConduitNoError
;
}
void
WebrtcVideoConduit
:
:
DetachRenderer
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
if
(
mRenderer
)
{
mRenderer
=
nullptr
;
}
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
SetTransmitterTransport
(
RefPtr
<
TransportInterface
>
aTransport
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
CSFLogDebug
(
LOGTAG
"
%
s
"
__FUNCTION__
)
;
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
mTransmitterTransport
=
aTransport
;
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
SetReceiverTransport
(
RefPtr
<
TransportInterface
>
aTransport
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
CSFLogDebug
(
LOGTAG
"
%
s
"
__FUNCTION__
)
;
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
mReceiverTransport
=
aTransport
;
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
ConfigureRecvMediaCodecs
(
const
std
:
:
vector
<
VideoCodecConfig
>
&
codecConfigList
const
RtpRtcpConfig
&
aRtpRtcpConfig
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
CSFLogDebug
(
LOGTAG
"
%
s
"
__FUNCTION__
)
;
MediaConduitErrorCode
condError
=
kMediaConduitNoError
;
std
:
:
string
payloadName
;
if
(
codecConfigList
.
empty
(
)
)
{
CSFLogError
(
LOGTAG
"
%
s
Zero
number
of
codecs
to
configure
"
__FUNCTION__
)
;
return
kMediaConduitMalformedArgument
;
}
webrtc
:
:
KeyFrameReqMethod
kf_request_method
=
webrtc
:
:
KeyFrameReqMethod
:
:
kNone
;
bool
use_nack_basic
=
false
;
bool
use_tmmbr
=
false
;
bool
use_remb
=
false
;
bool
use_fec
=
false
;
bool
use_transport_cc
=
false
;
int
ulpfec_payload_type
=
kNullPayloadType
;
int
red_payload_type
=
kNullPayloadType
;
bool
configuredH264
=
false
;
std
:
:
vector
<
VideoCodecConfig
>
recv_codecs
;
for
(
const
auto
&
codec_config
:
codecConfigList
)
{
if
(
(
condError
=
ValidateCodecConfig
(
codec_config
)
)
!
=
kMediaConduitNoError
)
{
CSFLogError
(
LOGTAG
"
%
s
Invalid
config
for
%
s
decoder
:
%
i
"
__FUNCTION__
codec_config
.
mName
.
c_str
(
)
condError
)
;
continue
;
}
if
(
codec_config
.
mName
=
=
"
H264
"
)
{
if
(
configuredH264
)
{
continue
;
}
configuredH264
=
true
;
}
if
(
codec_config
.
mName
=
=
kUlpFecPayloadName
)
{
ulpfec_payload_type
=
codec_config
.
mType
;
continue
;
}
if
(
codec_config
.
mName
=
=
kRedPayloadName
)
{
red_payload_type
=
codec_config
.
mType
;
continue
;
}
if
(
codec_config
.
RtcpFbNackIsSet
(
"
pli
"
)
)
{
kf_request_method
=
webrtc
:
:
KeyFrameReqMethod
:
:
kPliRtcp
;
}
else
if
(
codec_config
.
RtcpFbCcmIsSet
(
"
fir
"
)
)
{
kf_request_method
=
webrtc
:
:
KeyFrameReqMethod
:
:
kFirRtcp
;
}
use_nack_basic
|
=
codec_config
.
RtcpFbNackIsSet
(
"
"
)
;
use_tmmbr
|
=
codec_config
.
RtcpFbCcmIsSet
(
"
tmmbr
"
)
;
use_remb
|
=
codec_config
.
RtcpFbRembIsSet
(
)
;
use_fec
|
=
codec_config
.
RtcpFbFECIsSet
(
)
;
use_transport_cc
|
=
codec_config
.
RtcpFbTransportCCIsSet
(
)
;
recv_codecs
.
push_back
(
codec_config
)
;
}
if
(
recv_codecs
.
empty
(
)
)
{
CSFLogError
(
LOGTAG
"
%
s
Found
no
valid
receive
codecs
"
__FUNCTION__
)
;
return
kMediaConduitMalformedArgument
;
}
if
(
!
mRecvStream
|
|
CodecsDifferent
(
recv_codecs
mRecvCodecList
)
|
|
mRecvStreamConfig
.
rtp
.
nack
.
rtp_history_ms
!
=
(
use_nack_basic
?
1000
:
0
)
|
|
mRecvStreamConfig
.
rtp
.
remb
!
=
use_remb
|
|
mRecvStreamConfig
.
rtp
.
transport_cc
!
=
use_transport_cc
|
|
mRecvStreamConfig
.
rtp
.
tmmbr
!
=
use_tmmbr
|
|
mRecvStreamConfig
.
rtp
.
keyframe_method
!
=
kf_request_method
|
|
(
use_fec
&
&
(
mRecvStreamConfig
.
rtp
.
ulpfec_payload_type
!
=
ulpfec_payload_type
|
|
mRecvStreamConfig
.
rtp
.
red_payload_type
!
=
red_payload_type
)
)
)
{
MutexAutoLock
lock
(
mMutex
)
;
condError
=
StopReceivingLocked
(
)
;
if
(
condError
!
=
kMediaConduitNoError
)
{
return
condError
;
}
mRecvStreamConfig
.
rtp
.
rtcp_mode
=
aRtpRtcpConfig
.
GetRtcpMode
(
)
;
mRecvStreamConfig
.
rtp
.
nack
.
rtp_history_ms
=
use_nack_basic
?
1000
:
0
;
mRecvStreamConfig
.
rtp
.
remb
=
use_remb
;
mRecvStreamConfig
.
rtp
.
transport_cc
=
use_transport_cc
;
mRecvStreamConfig
.
rtp
.
tmmbr
=
use_tmmbr
;
mRecvStreamConfig
.
rtp
.
keyframe_method
=
kf_request_method
;
if
(
use_fec
)
{
mRecvStreamConfig
.
rtp
.
ulpfec_payload_type
=
ulpfec_payload_type
;
mRecvStreamConfig
.
rtp
.
red_payload_type
=
red_payload_type
;
}
else
{
mRecvStreamConfig
.
rtp
.
ulpfec_payload_type
=
-
1
;
mRecvStreamConfig
.
rtp
.
red_payload_type
=
-
1
;
}
mRecvStreamConfig
.
rtp
.
rtx_associated_payload_types
.
clear
(
)
;
for
(
auto
&
codec
:
recv_codecs
)
{
if
(
codec
.
RtxPayloadTypeIsSet
(
)
)
{
mRecvStreamConfig
.
rtp
.
rtx_associated_payload_types
[
codec
.
mRTXPayloadType
]
=
codec
.
mType
;
}
}
mRecvSSRC
=
mRecvStreamConfig
.
rtp
.
remote_ssrc
;
if
(
mRecvSSRC
=
=
0
)
{
uint32_t
ssrc
=
GenerateRandomSSRC
(
)
;
if
(
ssrc
=
=
0
)
{
return
kMediaConduitUnknownError
;
}
mCall
-
>
RegisterConduit
(
this
)
;
mRecvStreamConfig
.
rtp
.
remote_ssrc
=
ssrc
;
mRecvSSRC
=
ssrc
;
}
MOZ_ASSERT
(
!
mSendStreamConfig
.
rtp
.
ssrcs
.
empty
(
)
)
;
auto
ssrc
=
mSendStreamConfig
.
rtp
.
ssrcs
.
front
(
)
;
Unused
<
<
NS_WARN_IF
(
ssrc
=
=
mRecvStreamConfig
.
rtp
.
remote_ssrc
)
;
while
(
ssrc
=
=
mRecvStreamConfig
.
rtp
.
remote_ssrc
)
{
ssrc
=
GenerateRandomSSRC
(
)
;
if
(
ssrc
=
=
0
)
{
return
kMediaConduitUnknownError
;
}
}
mRecvStreamConfig
.
rtp
.
local_ssrc
=
ssrc
;
CSFLogDebug
(
LOGTAG
"
%
s
(
%
p
)
:
Local
SSRC
0x
%
08x
(
of
%
u
)
remote
SSRC
0x
%
08x
"
__FUNCTION__
(
void
*
)
this
ssrc
(
uint32_t
)
mSendStreamConfig
.
rtp
.
ssrcs
.
size
(
)
mRecvStreamConfig
.
rtp
.
remote_ssrc
)
;
mRecvCodecList
=
std
:
:
move
(
recv_codecs
)
;
DeleteRecvStream
(
)
;
return
StartReceivingLocked
(
)
;
}
return
kMediaConduitNoError
;
}
void
WebrtcVideoConduit
:
:
SelectSendResolution
(
unsigned
short
width
unsigned
short
height
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
mCurSendCodecConfig
)
{
uint16_t
max_width
=
mCurSendCodecConfig
-
>
mEncodingConstraints
.
maxWidth
;
uint16_t
max_height
=
mCurSendCodecConfig
-
>
mEncodingConstraints
.
maxHeight
;
if
(
max_width
|
|
max_height
)
{
max_width
=
max_width
?
max_width
:
UINT16_MAX
;
max_height
=
max_height
?
max_height
:
UINT16_MAX
;
ConstrainPreservingAspectRatio
(
max_width
max_height
&
width
&
height
)
;
}
int
max_fs
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
;
if
(
!
mLockScaling
)
{
max_fs
=
mVideoBroadcaster
.
wants
(
)
.
max_pixel_count
;
}
if
(
mCurSendCodecConfig
-
>
mEncodingConstraints
.
maxFs
)
{
max_fs
=
std
:
:
min
(
max_fs
static_cast
<
int
>
(
mCurSendCodecConfig
-
>
mEncodingConstraints
.
maxFs
*
(
16
*
16
)
)
)
;
}
mVideoAdapter
-
>
OnOutputFormatRequest
(
absl
:
:
optional
<
std
:
:
pair
<
int
int
>
>
(
)
max_fs
absl
:
:
optional
<
int
>
(
)
)
;
}
unsigned
int
framerate
=
SelectSendFrameRate
(
mCurSendCodecConfig
.
ref
(
)
mSendingFramerate
width
height
)
;
if
(
mSendingFramerate
!
=
framerate
)
{
CSFLogDebug
(
LOGTAG
"
%
s
:
framerate
changing
to
%
u
(
from
%
u
)
"
__FUNCTION__
framerate
mSendingFramerate
)
;
mSendingFramerate
=
framerate
;
mVideoStreamFactory
-
>
SetSendingFramerate
(
mSendingFramerate
)
;
}
}
void
WebrtcVideoConduit
:
:
AddOrUpdateSink
(
rtc
:
:
VideoSinkInterface
<
webrtc
:
:
VideoFrame
>
*
sink
const
rtc
:
:
VideoSinkWants
&
wants
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
if
(
!
mRegisteredSinks
.
Contains
(
sink
)
)
{
mRegisteredSinks
.
AppendElement
(
sink
)
;
}
auto
oldWants
=
mVideoBroadcaster
.
wants
(
)
;
mVideoBroadcaster
.
AddOrUpdateSink
(
sink
wants
)
;
if
(
oldWants
!
=
mVideoBroadcaster
.
wants
(
)
)
{
mUpdateSendResolution
=
true
;
}
}
void
WebrtcVideoConduit
:
:
RemoveSink
(
rtc
:
:
VideoSinkInterface
<
webrtc
:
:
VideoFrame
>
*
sink
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
mRegisteredSinks
.
RemoveElement
(
sink
)
;
auto
oldWants
=
mVideoBroadcaster
.
wants
(
)
;
mVideoBroadcaster
.
RemoveSink
(
sink
)
;
if
(
oldWants
!
=
mVideoBroadcaster
.
wants
(
)
)
{
mUpdateSendResolution
=
true
;
}
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
SendVideoFrame
(
const
webrtc
:
:
VideoFrame
&
frame
)
{
int
cropWidth
;
int
cropHeight
;
int
adaptedWidth
;
int
adaptedHeight
;
{
MutexAutoLock
lock
(
mMutex
)
;
CSFLogVerbose
(
LOGTAG
"
WebrtcVideoConduit
%
p
%
s
(
send
SSRC
%
u
(
0x
%
x
)
)
"
this
__FUNCTION__
mSendStreamConfig
.
rtp
.
ssrcs
.
front
(
)
mSendStreamConfig
.
rtp
.
ssrcs
.
front
(
)
)
;
bool
updateSendResolution
=
mUpdateSendResolution
.
exchange
(
false
)
;
if
(
updateSendResolution
|
|
frame
.
width
(
)
!
=
mLastWidth
|
|
frame
.
height
(
)
!
=
mLastHeight
)
{
CSFLogVerbose
(
LOGTAG
"
%
s
:
call
SelectSendResolution
with
%
ux
%
u
"
__FUNCTION__
frame
.
width
(
)
frame
.
height
(
)
)
;
MOZ_ASSERT
(
frame
.
width
(
)
!
=
0
&
&
frame
.
height
(
)
!
=
0
)
;
MOZ_ASSERT
(
mCurSendCodecConfig
)
;
mLastWidth
=
frame
.
width
(
)
;
mLastHeight
=
frame
.
height
(
)
;
SelectSendResolution
(
frame
.
width
(
)
frame
.
height
(
)
)
;
}
if
(
!
mVideoBroadcaster
.
frame_wanted
(
)
)
{
return
kMediaConduitNoError
;
}
if
(
!
mVideoAdapter
-
>
AdaptFrameResolution
(
frame
.
width
(
)
frame
.
height
(
)
frame
.
timestamp_us
(
)
*
rtc
:
:
kNumNanosecsPerMicrosec
&
cropWidth
&
cropHeight
&
adaptedWidth
&
adaptedHeight
)
)
{
return
kMediaConduitNoError
;
}
}
if
(
cropWidth
=
=
0
|
|
cropHeight
=
=
0
)
{
return
kMediaConduitNoError
;
}
int
cropX
=
(
frame
.
width
(
)
-
cropWidth
)
/
2
;
int
cropY
=
(
frame
.
height
(
)
-
cropHeight
)
/
2
;
rtc
:
:
scoped_refptr
<
webrtc
:
:
VideoFrameBuffer
>
buffer
;
if
(
adaptedWidth
=
=
frame
.
width
(
)
&
&
adaptedHeight
=
=
frame
.
height
(
)
)
{
buffer
=
frame
.
video_frame_buffer
(
)
;
}
else
{
rtc
:
:
scoped_refptr
<
webrtc
:
:
I420Buffer
>
i420Buffer
=
mBufferPool
.
CreateBuffer
(
adaptedWidth
adaptedHeight
)
;
if
(
!
i420Buffer
)
{
CSFLogWarn
(
LOGTAG
"
Creating
a
buffer
for
scaling
failed
pool
is
empty
"
)
;
return
kMediaConduitNoError
;
}
i420Buffer
-
>
CropAndScaleFrom
(
*
frame
.
video_frame_buffer
(
)
-
>
GetI420
(
)
cropX
cropY
cropWidth
cropHeight
)
;
buffer
=
i420Buffer
;
}
mVideoBroadcaster
.
OnFrame
(
webrtc
:
:
VideoFrame
(
buffer
frame
.
timestamp
(
)
frame
.
render_time_ms
(
)
frame
.
rotation
(
)
)
)
;
return
kMediaConduitNoError
;
}
void
WebrtcVideoConduit
:
:
DeliverPacket
(
rtc
:
:
CopyOnWriteBuffer
packet
PacketType
type
)
{
ASSERT_ON_THREAD
(
mStsThread
)
;
MOZ_ALWAYS_SUCCEEDS
(
mCallThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
<
WebrtcVideoConduit
>
(
this
)
packet
=
std
:
:
move
(
packet
)
type
]
{
if
(
!
mCall
-
>
Call
(
)
)
{
return
;
}
webrtc
:
:
PacketReceiver
:
:
DeliveryStatus
status
=
mCall
-
>
Call
(
)
-
>
Receiver
(
)
-
>
DeliverPacket
(
webrtc
:
:
MediaType
:
:
VIDEO
std
:
:
move
(
packet
)
-
1
)
;
if
(
status
!
=
webrtc
:
:
PacketReceiver
:
:
DELIVERY_OK
)
{
CSFLogError
(
LOGTAG
"
%
s
DeliverPacket
Failed
for
%
s
packet
%
d
"
__FUNCTION__
type
=
=
PacketType
:
:
RTP
?
"
RTP
"
:
"
RTCP
"
status
)
;
}
}
)
)
)
;
}
void
WebrtcVideoConduit
:
:
ReceivedRTPPacket
(
const
uint8_t
*
data
int
len
webrtc
:
:
RTPHeader
&
header
)
{
ASSERT_ON_THREAD
(
mStsThread
)
;
if
(
mAllowSsrcChange
|
|
mWaitingForInitialSsrc
)
{
if
(
mRtpPacketQueue
.
IsQueueActive
(
)
)
{
mRtpPacketQueue
.
Enqueue
(
rtc
:
:
CopyOnWriteBuffer
(
data
len
)
)
;
return
;
}
bool
switchRequired
=
mRecvSSRC
!
=
header
.
ssrc
;
if
(
switchRequired
)
{
MutexAutoLock
lock
(
mMutex
)
;
const
webrtc
:
:
VideoReceiveStream
:
:
Config
:
:
Rtp
&
rtp
=
mRecvStreamConfig
.
rtp
;
switchRequired
=
rtp
.
rtx_associated_payload_types
.
find
(
header
.
payloadType
)
=
=
rtp
.
rtx_associated_payload_types
.
end
(
)
&
&
rtp
.
ulpfec_payload_type
!
=
header
.
payloadType
;
}
if
(
switchRequired
)
{
mRtpPacketQueue
.
Clear
(
)
;
mRtpPacketQueue
.
Enqueue
(
rtc
:
:
CopyOnWriteBuffer
(
data
len
)
)
;
CSFLogDebug
(
LOGTAG
"
%
s
:
switching
from
SSRC
%
u
to
%
u
"
__FUNCTION__
static_cast
<
uint32_t
>
(
mRecvSSRC
)
header
.
ssrc
)
;
mRecvSSRC
=
header
.
ssrc
;
InvokeAsync
(
mCallThread
__func__
[
this
self
=
RefPtr
<
WebrtcVideoConduit
>
(
this
)
ssrc
=
header
.
ssrc
]
(
)
mutable
{
SetRemoteSSRC
(
ssrc
0
)
;
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
)
-
>
Then
(
mStsThread
__func__
[
this
self
=
RefPtr
<
WebrtcVideoConduit
>
(
this
)
ssrc
=
header
.
ssrc
]
(
)
mutable
{
if
(
ssrc
!
=
mRecvSSRC
)
{
return
;
}
mRtpPacketQueue
.
DequeueAll
(
this
)
;
}
)
;
return
;
}
}
CSFLogVerbose
(
LOGTAG
"
%
s
:
seq
#
%
u
Len
%
d
SSRC
%
u
(
0x
%
x
)
"
__FUNCTION__
(
uint16_t
)
ntohs
(
(
(
uint16_t
*
)
data
)
[
1
]
)
len
(
uint32_t
)
ntohl
(
(
(
uint32_t
*
)
data
)
[
2
]
)
(
uint32_t
)
ntohl
(
(
(
uint32_t
*
)
data
)
[
2
]
)
)
;
DeliverPacket
(
rtc
:
:
CopyOnWriteBuffer
(
data
len
)
PacketType
:
:
RTP
)
;
}
void
WebrtcVideoConduit
:
:
ReceivedRTCPPacket
(
const
uint8_t
*
data
int
len
)
{
ASSERT_ON_THREAD
(
mStsThread
)
;
CSFLogVerbose
(
LOGTAG
"
%
s
Len
%
d
"
__FUNCTION__
len
)
;
DeliverPacket
(
rtc
:
:
CopyOnWriteBuffer
(
data
len
)
PacketType
:
:
RTCP
)
;
mLastRtcpReceived
=
Some
(
GetNow
(
)
)
;
}
Maybe
<
DOMHighResTimeStamp
>
WebrtcVideoConduit
:
:
LastRtcpReceived
(
)
const
{
ASSERT_ON_THREAD
(
mStsThread
)
;
return
mLastRtcpReceived
;
}
DOMHighResTimeStamp
WebrtcVideoConduit
:
:
GetNow
(
)
const
{
return
mCall
-
>
GetNow
(
)
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
StopTransmitting
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
return
StopTransmittingLocked
(
)
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
StartTransmitting
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
return
StartTransmittingLocked
(
)
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
StopReceiving
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
return
StopReceivingLocked
(
)
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
StartReceiving
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
return
StartReceivingLocked
(
)
;
}
void
WebrtcVideoConduit
:
:
OnFrameDelivered
(
)
{
mCallThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
<
WebrtcVideoConduit
>
(
this
)
]
{
std
:
:
vector
<
webrtc
:
:
RtpSource
>
sources
;
if
(
mRecvStream
)
{
sources
=
mRecvStream
-
>
GetSources
(
)
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
WebrtcVideoConduit
:
:
OnFrameDelivered
(
call
thread
)
"
[
this
self
=
std
:
:
move
(
self
)
sources
=
std
:
:
move
(
sources
)
]
{
UpdateRtpSources
(
sources
)
;
}
)
)
;
}
)
)
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
StopTransmittingLocked
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
mEngineTransmitting
)
{
if
(
mSendStream
)
{
CSFLogDebug
(
LOGTAG
"
%
s
Engine
Already
Sending
.
Attemping
to
Stop
"
__FUNCTION__
)
;
mSendStream
-
>
Stop
(
)
;
}
mEngineTransmitting
=
false
;
}
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
StartTransmittingLocked
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
mEngineTransmitting
)
{
return
kMediaConduitNoError
;
}
CSFLogDebug
(
LOGTAG
"
%
s
Attemping
to
start
.
.
.
"
__FUNCTION__
)
;
if
(
!
mSendStream
)
{
MediaConduitErrorCode
rval
=
CreateSendStream
(
)
;
if
(
rval
!
=
kMediaConduitNoError
)
{
CSFLogError
(
LOGTAG
"
%
s
Start
Send
Error
%
d
"
__FUNCTION__
rval
)
;
return
rval
;
}
}
mSendStream
-
>
Start
(
)
;
mCall
-
>
Call
(
)
-
>
SignalChannelNetworkState
(
webrtc
:
:
MediaType
:
:
VIDEO
webrtc
:
:
kNetworkUp
)
;
mEngineTransmitting
=
true
;
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
StopReceivingLocked
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
mEngineReceiving
&
&
mRecvStream
)
{
CSFLogDebug
(
LOGTAG
"
%
s
Engine
Already
Receiving
.
Attemping
to
Stop
"
__FUNCTION__
)
;
mRecvStream
-
>
Stop
(
)
;
}
mEngineReceiving
=
false
;
return
kMediaConduitNoError
;
}
MediaConduitErrorCode
WebrtcVideoConduit
:
:
StartReceivingLocked
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
mEngineReceiving
)
{
return
kMediaConduitNoError
;
}
CSFLogDebug
(
LOGTAG
"
%
s
Attemping
to
start
.
.
.
(
SSRC
%
u
(
0x
%
x
)
)
"
__FUNCTION__
static_cast
<
uint32_t
>
(
mRecvSSRC
)
static_cast
<
uint32_t
>
(
mRecvSSRC
)
)
;
if
(
!
mRecvStream
)
{
MediaConduitErrorCode
rval
=
CreateRecvStream
(
)
;
if
(
rval
!
=
kMediaConduitNoError
)
{
CSFLogError
(
LOGTAG
"
%
s
Start
Receive
Error
%
d
"
__FUNCTION__
rval
)
;
return
rval
;
}
}
mRecvStream
-
>
Start
(
)
;
mCall
-
>
Call
(
)
-
>
SignalChannelNetworkState
(
webrtc
:
:
MediaType
:
:
VIDEO
webrtc
:
:
kNetworkUp
)
;
mEngineReceiving
=
true
;
return
kMediaConduitNoError
;
}
bool
WebrtcVideoConduit
:
:
SendRtp
(
const
uint8_t
*
packet
size_t
length
const
webrtc
:
:
PacketOptions
&
options
)
{
CSFLogVerbose
(
LOGTAG
"
%
s
Sent
RTP
Packet
seq
%
d
len
%
lu
SSRC
%
u
(
0x
%
x
)
"
__FUNCTION__
(
uint16_t
)
ntohs
(
*
(
(
uint16_t
*
)
&
packet
[
2
]
)
)
(
unsigned
long
)
length
(
uint32_t
)
ntohl
(
*
(
(
uint32_t
*
)
&
packet
[
8
]
)
)
(
uint32_t
)
ntohl
(
*
(
(
uint32_t
*
)
&
packet
[
8
]
)
)
)
;
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
if
(
!
mTransmitterTransport
|
|
NS_FAILED
(
mTransmitterTransport
-
>
SendRtpPacket
(
packet
length
)
)
)
{
CSFLogError
(
LOGTAG
"
%
s
RTP
Packet
Send
Failed
"
__FUNCTION__
)
;
return
false
;
}
if
(
options
.
packet_id
>
=
0
)
{
int64_t
now_ms
=
PR_Now
(
)
/
1000
;
MOZ_ALWAYS_SUCCEEDS
(
mCallThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
call
=
mCall
packet_id
=
options
.
packet_id
now_ms
]
{
if
(
call
-
>
Call
(
)
)
{
call
-
>
Call
(
)
-
>
OnSentPacket
(
{
packet_id
now_ms
}
)
;
}
}
)
)
)
;
}
return
true
;
}
bool
WebrtcVideoConduit
:
:
SendRtcp
(
const
uint8_t
*
packet
size_t
length
)
{
CSFLogVerbose
(
LOGTAG
"
%
s
:
len
%
lu
"
__FUNCTION__
(
unsigned
long
)
length
)
;
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
if
(
mReceiverTransport
&
&
NS_SUCCEEDED
(
mReceiverTransport
-
>
SendRtcpPacket
(
packet
length
)
)
)
{
CSFLogDebug
(
LOGTAG
"
%
s
Sent
RTCP
Packet
"
__FUNCTION__
)
;
return
true
;
}
if
(
mTransmitterTransport
&
&
NS_SUCCEEDED
(
mTransmitterTransport
-
>
SendRtcpPacket
(
packet
length
)
)
)
{
return
true
;
}
CSFLogError
(
LOGTAG
"
%
s
RTCP
Packet
Send
Failed
"
__FUNCTION__
)
;
return
false
;
}
void
WebrtcVideoConduit
:
:
OnFrame
(
const
webrtc
:
:
VideoFrame
&
video_frame
)
{
CSFLogVerbose
(
LOGTAG
"
%
s
:
recv
SSRC
%
u
(
0x
%
x
)
size
%
ux
%
u
"
__FUNCTION__
static_cast
<
uint32_t
>
(
mRecvSSRC
)
static_cast
<
uint32_t
>
(
mRecvSSRC
)
video_frame
.
width
(
)
video_frame
.
height
(
)
)
;
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
if
(
!
mRenderer
)
{
CSFLogError
(
LOGTAG
"
%
s
Renderer
is
NULL
"
__FUNCTION__
)
;
return
;
}
bool
needsNewHistoryElement
=
!
mReceivedFrameHistory
.
mEntries
.
Length
(
)
;
if
(
mReceivingWidth
!
=
video_frame
.
width
(
)
|
|
mReceivingHeight
!
=
video_frame
.
height
(
)
)
{
mReceivingWidth
=
video_frame
.
width
(
)
;
mReceivingHeight
=
video_frame
.
height
(
)
;
mRenderer
-
>
FrameSizeChange
(
mReceivingWidth
mReceivingHeight
)
;
needsNewHistoryElement
=
true
;
}
uint32_t
remoteSsrc
;
if
(
!
GetRemoteSSRC
(
&
remoteSsrc
)
&
&
needsNewHistoryElement
)
{
return
;
}
if
(
!
needsNewHistoryElement
)
{
auto
&
currentEntry
=
mReceivedFrameHistory
.
mEntries
.
LastElement
(
)
;
needsNewHistoryElement
=
currentEntry
.
mRotationAngle
!
=
static_cast
<
unsigned
long
>
(
video_frame
.
rotation
(
)
)
|
|
currentEntry
.
mLocalSsrc
!
=
mRecvSSRC
|
|
currentEntry
.
mRemoteSsrc
!
=
remoteSsrc
;
}
const
auto
historyNow
=
mCall
-
>
GetNow
(
)
;
if
(
needsNewHistoryElement
)
{
dom
:
:
RTCVideoFrameHistoryEntryInternal
frameHistoryElement
;
frameHistoryElement
.
mConsecutiveFrames
=
0
;
frameHistoryElement
.
mWidth
=
video_frame
.
width
(
)
;
frameHistoryElement
.
mHeight
=
video_frame
.
height
(
)
;
frameHistoryElement
.
mRotationAngle
=
static_cast
<
unsigned
long
>
(
video_frame
.
rotation
(
)
)
;
frameHistoryElement
.
mFirstFrameTimestamp
=
historyNow
;
frameHistoryElement
.
mLocalSsrc
=
mRecvSSRC
;
frameHistoryElement
.
mRemoteSsrc
=
remoteSsrc
;
if
(
!
mReceivedFrameHistory
.
mEntries
.
AppendElement
(
frameHistoryElement
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
auto
&
currentEntry
=
mReceivedFrameHistory
.
mEntries
.
LastElement
(
)
;
currentEntry
.
mConsecutiveFrames
+
+
;
currentEntry
.
mLastFrameTimestamp
=
historyNow
;
if
(
mVideoLatencyTestEnable
&
&
mReceivingWidth
&
&
mReceivingHeight
)
{
uint64_t
now
=
PR_Now
(
)
;
uint64_t
timestamp
=
0
;
uint8_t
*
data
=
const_cast
<
uint8_t
*
>
(
video_frame
.
video_frame_buffer
(
)
-
>
GetI420
(
)
-
>
DataY
(
)
)
;
bool
ok
=
YuvStamper
:
:
Decode
(
mReceivingWidth
mReceivingHeight
mReceivingWidth
data
reinterpret_cast
<
unsigned
char
*
>
(
&
timestamp
)
sizeof
(
timestamp
)
0
0
)
;
if
(
ok
)
{
VideoLatencyUpdate
(
now
-
timestamp
)
;
}
}
mRenderer
-
>
RenderVideoFrame
(
*
video_frame
.
video_frame_buffer
(
)
video_frame
.
timestamp
(
)
video_frame
.
render_time_ms
(
)
)
;
}
bool
WebrtcVideoConduit
:
:
AddFrameHistory
(
dom
:
:
Sequence
<
dom
:
:
RTCVideoFrameHistoryInternal
>
*
outHistories
)
const
{
ReentrantMonitorAutoEnter
enter
(
mTransportMonitor
)
;
if
(
!
outHistories
-
>
AppendElement
(
mReceivedFrameHistory
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
return
false
;
}
return
true
;
}
void
WebrtcVideoConduit
:
:
DumpCodecDB
(
)
const
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
for
(
auto
&
entry
:
mRecvCodecList
)
{
CSFLogDebug
(
LOGTAG
"
Payload
Name
:
%
s
"
entry
.
mName
.
c_str
(
)
)
;
CSFLogDebug
(
LOGTAG
"
Payload
Type
:
%
d
"
entry
.
mType
)
;
CSFLogDebug
(
LOGTAG
"
Payload
Max
Frame
Size
:
%
d
"
entry
.
mEncodingConstraints
.
maxFs
)
;
CSFLogDebug
(
LOGTAG
"
Payload
Max
Frame
Rate
:
%
d
"
entry
.
mEncodingConstraints
.
maxFps
)
;
}
}
void
WebrtcVideoConduit
:
:
VideoLatencyUpdate
(
uint64_t
newSample
)
{
mTransportMonitor
.
AssertCurrentThreadIn
(
)
;
mVideoLatencyAvg
=
(
sRoundingPadding
*
newSample
+
sAlphaNum
*
mVideoLatencyAvg
)
/
sAlphaDen
;
}
uint64_t
WebrtcVideoConduit
:
:
MozVideoLatencyAvg
(
)
{
mTransportMonitor
.
AssertCurrentThreadIn
(
)
;
return
mVideoLatencyAvg
/
sRoundingPadding
;
}
void
WebrtcVideoConduit
:
:
CollectTelemetryData
(
)
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
if
(
mEngineTransmitting
)
{
webrtc
:
:
VideoSendStream
:
:
Stats
stats
=
mSendStream
-
>
GetStats
(
)
;
mSendBitrate
.
Push
(
stats
.
media_bitrate_bps
)
;
mSendFramerate
.
Push
(
stats
.
encode_frame_rate
)
;
}
if
(
mEngineReceiving
)
{
webrtc
:
:
VideoReceiveStream
:
:
Stats
stats
=
mRecvStream
-
>
GetStats
(
)
;
mRecvBitrate
.
Push
(
stats
.
total_bitrate_bps
)
;
mRecvFramerate
.
Push
(
stats
.
decode_frame_rate
)
;
}
}
void
WebrtcVideoConduit
:
:
OnRtcpBye
(
)
{
RefPtr
<
WebrtcVideoConduit
>
self
=
this
;
NS_DispatchToMainThread
(
media
:
:
NewRunnableFrom
(
[
self
]
(
)
mutable
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
self
-
>
mRtcpEventObserver
)
{
self
-
>
mRtcpEventObserver
-
>
OnRtcpBye
(
)
;
}
return
NS_OK
;
}
)
)
;
}
void
WebrtcVideoConduit
:
:
OnRtcpTimeout
(
)
{
RefPtr
<
WebrtcVideoConduit
>
self
=
this
;
NS_DispatchToMainThread
(
media
:
:
NewRunnableFrom
(
[
self
]
(
)
mutable
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
self
-
>
mRtcpEventObserver
)
{
self
-
>
mRtcpEventObserver
-
>
OnRtcpTimeout
(
)
;
}
return
NS_OK
;
}
)
)
;
}
void
WebrtcVideoConduit
:
:
SetRtcpEventObserver
(
mozilla
:
:
RtcpEventObserver
*
observer
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mRtcpEventObserver
=
observer
;
}
bool
WebrtcVideoConduit
:
:
HasCodecPluginID
(
uint64_t
aPluginID
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mSendCodecPluginIDs
.
Contains
(
aPluginID
)
|
|
mRecvCodecPluginIDs
.
Contains
(
aPluginID
)
;
}
bool
WebrtcVideoConduit
:
:
RequiresNewSendStream
(
const
VideoCodecConfig
&
newConfig
)
const
{
MOZ_ASSERT
(
mCallThread
-
>
IsOnCurrentThread
(
)
)
;
return
!
mCurSendCodecConfig
|
|
mCurSendCodecConfig
-
>
mName
!
=
newConfig
.
mName
|
|
mCurSendCodecConfig
-
>
mType
!
=
newConfig
.
mType
|
|
mCurSendCodecConfig
-
>
RtcpFbNackIsSet
(
"
"
)
!
=
newConfig
.
RtcpFbNackIsSet
(
"
"
)
|
|
mCurSendCodecConfig
-
>
RtcpFbFECIsSet
(
)
!
=
newConfig
.
RtcpFbFECIsSet
(
)
#
if
0
|
|
(
newConfig
.
mName
=
=
"
H264
"
&
&
!
CompatibleH264Config
(
mEncoderSpecificH264
newConfig
)
)
#
endif
;
}
bool
WebrtcVideoConduit
:
:
HasH264Hardware
(
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
info
;
1
"
)
;
if
(
!
gfxInfo
)
{
return
false
;
}
int32_t
status
;
nsCString
discardFailureId
;
return
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_WEBRTC_HW_ACCELERATION_H264
discardFailureId
&
status
)
)
&
&
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
;
}
}
