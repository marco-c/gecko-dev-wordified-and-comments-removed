#
include
"
RtpSourceObserver
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
modules
/
include
/
module_common_types
.
h
"
#
include
"
system_wrappers
/
include
/
clock
.
h
"
namespace
mozilla
{
using
EntryType
=
dom
:
:
RTCRtpSourceEntryType
;
double
RtpSourceObserver
:
:
RtpSourceEntry
:
:
ToLinearAudioLevel
(
)
const
{
if
(
audioLevel
=
=
127
)
{
return
0
;
}
return
std
:
:
pow
(
10
-
static_cast
<
double
>
(
audioLevel
)
/
20
)
;
}
RtpSourceObserver
:
:
RtpSourceObserver
(
const
dom
:
:
RTCStatsTimestampMaker
&
aTimestampMaker
)
:
mMaxJitterWindow
(
0
)
mTimestampMaker
(
aTimestampMaker
)
{
}
void
RtpSourceObserver
:
:
OnRtpPacket
(
const
webrtc
:
:
RTPHeader
&
aHeader
const
uint32_t
aJitter
)
{
DOMHighResTimeStamp
jsNow
=
mTimestampMaker
.
GetNow
(
)
;
RefPtr
<
Runnable
>
runnable
=
NS_NewRunnableFunction
(
"
RtpSourceObserver
:
:
OnRtpPacket
"
[
this
self
=
RefPtr
<
RtpSourceObserver
>
(
this
)
aHeader
aJitter
jsNow
]
(
)
{
mMaxJitterWindow
=
std
:
:
max
(
mMaxJitterWindow
static_cast
<
int64_t
>
(
aJitter
)
*
2
)
;
const
auto
predictedPlayoutTime
=
jsNow
+
aJitter
;
auto
&
hist
=
mRtpSources
[
GetKey
(
aHeader
.
ssrc
EntryType
:
:
Synchronization
)
]
;
hist
.
Prune
(
jsNow
)
;
hist
.
Insert
(
jsNow
predictedPlayoutTime
aHeader
.
timestamp
aHeader
.
extension
.
hasAudioLevel
aHeader
.
extension
.
audioLevel
)
;
const
auto
&
list
=
aHeader
.
extension
.
csrcAudioLevels
;
for
(
uint8_t
i
=
0
;
i
<
aHeader
.
numCSRCs
;
i
+
+
)
{
const
uint32_t
&
csrc
=
aHeader
.
arrOfCSRCs
[
i
]
;
auto
&
hist
=
mRtpSources
[
GetKey
(
csrc
EntryType
:
:
Contributing
)
]
;
hist
.
Prune
(
jsNow
)
;
bool
hasLevel
=
i
<
list
.
numAudioLevels
;
uint8_t
level
=
hasLevel
?
list
.
arrOfAudioLevels
[
i
]
:
0
;
hist
.
Insert
(
jsNow
predictedPlayoutTime
aHeader
.
timestamp
hasLevel
level
)
;
}
}
)
;
if
(
NS_IsMainThread
(
)
)
{
runnable
-
>
Run
(
)
;
}
else
{
NS_DispatchToMainThread
(
runnable
)
;
}
}
void
RtpSourceObserver
:
:
GetRtpSources
(
nsTArray
<
dom
:
:
RTCRtpSourceEntry
>
&
outSources
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
outSources
.
Clear
(
)
;
for
(
const
auto
&
it
:
mRtpSources
)
{
const
RtpSourceEntry
*
entry
=
it
.
second
.
FindClosestNotAfter
(
mTimestampMaker
.
GetNow
(
)
)
;
if
(
entry
)
{
dom
:
:
RTCRtpSourceEntry
domEntry
;
domEntry
.
mSource
=
GetSourceFromKey
(
it
.
first
)
;
domEntry
.
mSourceType
=
GetTypeFromKey
(
it
.
first
)
;
domEntry
.
mTimestamp
=
entry
-
>
predictedPlayoutTime
;
domEntry
.
mRtpTimestamp
=
entry
-
>
rtpTimestamp
;
if
(
entry
-
>
hasAudioLevel
)
{
domEntry
.
mAudioLevel
.
Construct
(
entry
-
>
ToLinearAudioLevel
(
)
)
;
}
outSources
.
AppendElement
(
std
:
:
move
(
domEntry
)
)
;
}
}
}
const
RtpSourceObserver
:
:
RtpSourceEntry
*
RtpSourceObserver
:
:
RtpSourceHistory
:
:
FindClosestNotAfter
(
int64_t
aTime
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
lastFound
=
mDetailedHistory
.
cbegin
(
)
;
bool
found
=
false
;
for
(
const
auto
&
it
:
mDetailedHistory
)
{
if
(
it
.
second
.
predictedPlayoutTime
>
aTime
)
{
break
;
}
if
(
found
)
{
lastFound
+
+
;
}
found
=
true
;
}
if
(
found
)
{
return
&
lastFound
-
>
second
;
}
if
(
HasEvicted
(
)
&
&
aTime
>
=
mLatestEviction
.
predictedPlayoutTime
)
{
return
&
mLatestEviction
;
}
return
nullptr
;
}
void
RtpSourceObserver
:
:
RtpSourceHistory
:
:
Prune
(
const
int64_t
aTimeNow
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
const
auto
aTimeT
=
aTimeNow
-
mMaxJitterWindow
;
const
auto
aTimePrehistory
=
aTimeNow
-
kHistoryWindow
;
bool
found
=
false
;
auto
lower
=
mDetailedHistory
.
begin
(
)
;
for
(
auto
&
it
:
mDetailedHistory
)
{
if
(
it
.
second
.
predictedPlayoutTime
>
aTimeT
)
{
found
=
true
;
break
;
}
if
(
found
)
{
lower
+
+
;
}
found
=
true
;
}
if
(
found
)
{
if
(
lower
-
>
second
.
predictedPlayoutTime
>
aTimePrehistory
)
{
mLatestEviction
=
lower
-
>
second
;
mHasEvictedEntry
=
true
;
}
lower
+
+
;
mDetailedHistory
.
erase
(
mDetailedHistory
.
begin
(
)
lower
)
;
}
if
(
HasEvicted
(
)
&
&
(
mLatestEviction
.
predictedPlayoutTime
+
kHistoryWindow
)
<
aTimeNow
)
{
mHasEvictedEntry
=
false
;
}
}
void
RtpSourceObserver
:
:
RtpSourceHistory
:
:
Insert
(
const
int64_t
aTimeNow
const
int64_t
aTimestamp
const
uint32_t
aRtpTimestamp
const
bool
aHasAudioLevel
const
uint8_t
aAudioLevel
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Insert
(
aTimeNow
aTimestamp
)
.
Update
(
aTimestamp
aRtpTimestamp
aHasAudioLevel
aAudioLevel
)
;
}
RtpSourceObserver
:
:
RtpSourceEntry
&
RtpSourceObserver
:
:
RtpSourceHistory
:
:
Insert
(
const
int64_t
aTimeNow
const
int64_t
aTimestamp
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
(
aTimestamp
+
kHistoryWindow
)
<
aTimeNow
|
|
aTimestamp
<
mLatestEviction
.
predictedPlayoutTime
)
{
return
mPrehistory
;
}
mMaxJitterWindow
=
std
:
:
max
(
mMaxJitterWindow
(
aTimestamp
-
aTimeNow
)
*
2
)
;
const
int64_t
aTimeT
=
aTimeNow
-
mMaxJitterWindow
;
if
(
aTimestamp
<
aTimeT
)
{
mHasEvictedEntry
=
true
;
return
mLatestEviction
;
}
return
mDetailedHistory
[
aTimestamp
]
;
}
}
