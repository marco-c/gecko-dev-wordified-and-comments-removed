#
ifndef
WEBRTCGMPVIDEOCODEC_H_
#
define
WEBRTCGMPVIDEOCODEC_H_
#
include
<
string
>
#
include
"
GMPVideoDecoderProxy
.
h
"
#
include
"
GMPVideoEncoderProxy
.
h
"
#
include
"
MediaConduitInterface
.
h
"
#
include
"
PerformanceRecorder
.
h
"
#
include
"
VideoConduit
.
h
"
#
include
"
api
/
video
/
video_frame_type
.
h
"
#
include
"
common_video
/
h264
/
h264_bitstream_parser
.
h
"
#
include
"
gmp
-
video
-
host
.
h
"
#
include
"
jsapi
/
PeerConnectionImpl
.
h
"
#
include
"
modules
/
video_coding
/
include
/
video_error_codes
.
h
"
#
include
"
modules
/
video_coding
/
svc
/
scalable_video_controller
.
h
"
#
include
"
mozIGeckoMediaPluginService
.
h
"
#
include
"
mozilla
/
EventTargetCapability
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
glean
/
DomMediaWebrtcMetrics
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
:
:
detail
{
struct
InputImageData
{
uint64_t
gmp_timestamp_us
=
0
;
int64_t
ntp_timestamp_ms
=
0
;
int64_t
timestamp_us
=
0
;
uint32_t
rtp_timestamp
=
0
;
webrtc
:
:
ScalableVideoController
:
:
LayerFrameConfig
frame_config
;
}
;
}
template
<
>
struct
nsTArray_RelocationStrategy
<
mozilla
:
:
detail
:
:
InputImageData
>
{
using
IID
=
mozilla
:
:
detail
:
:
InputImageData
;
using
Type
=
std
:
:
conditional_t
<
(
std
:
:
is_trivially_move_constructible_v
<
IID
>
|
|
(
!
std
:
:
is_move_constructible_v
<
IID
>
&
&
std
:
:
is_trivially_copy_constructible_v
<
IID
>
)
)
&
&
std
:
:
is_trivially_destructible_v
<
IID
>
nsTArray_RelocateUsingMemutils
nsTArray_RelocateUsingMoveConstructor
<
IID
>
>
;
}
;
namespace
mozilla
{
static
void
NotifyGmpInitDone
(
const
std
:
:
string
&
aPCHandle
int32_t
aResult
const
std
:
:
string
&
aError
=
"
"
)
{
if
(
!
NS_IsMainThread
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
GetMainThreadSerialEventTarget
(
)
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
aPCHandle
aResult
aError
]
{
NotifyGmpInitDone
(
aPCHandle
aResult
aError
)
;
}
)
)
)
;
return
;
}
glean
:
:
webrtc
:
:
gmp_init_success
.
EnumGet
(
static_cast
<
glean
:
:
webrtc
:
:
GmpInitSuccessLabel
>
(
aResult
=
=
WEBRTC_VIDEO_CODEC_OK
)
)
.
Add
(
)
;
if
(
aResult
=
=
WEBRTC_VIDEO_CODEC_OK
)
{
return
;
}
PeerConnectionWrapper
wrapper
(
aPCHandle
)
;
if
(
wrapper
.
impl
(
)
)
{
wrapper
.
impl
(
)
-
>
OnMediaError
(
aError
)
;
}
}
class
GMPDecodeData
{
public
:
GMPDecodeData
(
const
webrtc
:
:
EncodedImage
&
aInputImage
bool
aMissingFrames
int64_t
aRenderTimeMs
)
:
mImage
(
aInputImage
)
mMissingFrames
(
aMissingFrames
)
mRenderTimeMs
(
aRenderTimeMs
)
{
MOZ_RELEASE_ASSERT
(
aInputImage
.
size
(
)
<
(
std
:
:
numeric_limits
<
size_t
>
:
:
max
(
)
>
>
1
)
)
;
}
~
GMPDecodeData
(
)
=
default
;
const
webrtc
:
:
EncodedImage
mImage
;
const
bool
mMissingFrames
;
const
int64_t
mRenderTimeMs
;
}
;
class
RefCountedWebrtcVideoEncoder
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
virtual
int32_t
InitEncode
(
const
webrtc
:
:
VideoCodec
*
aCodecSettings
const
webrtc
:
:
VideoEncoder
:
:
Settings
&
aSettings
)
=
0
;
virtual
int32_t
Encode
(
const
webrtc
:
:
VideoFrame
&
aInputImage
const
std
:
:
vector
<
webrtc
:
:
VideoFrameType
>
*
aFrameTypes
)
=
0
;
virtual
int32_t
RegisterEncodeCompleteCallback
(
webrtc
:
:
EncodedImageCallback
*
aCallback
)
=
0
;
virtual
int32_t
Shutdown
(
)
=
0
;
virtual
int32_t
SetRates
(
const
webrtc
:
:
VideoEncoder
:
:
RateControlParameters
&
aParameters
)
=
0
;
virtual
MediaEventSource
<
uint64_t
>
*
InitPluginEvent
(
)
=
0
;
virtual
MediaEventSource
<
uint64_t
>
*
ReleasePluginEvent
(
)
=
0
;
virtual
WebrtcVideoEncoder
:
:
EncoderInfo
GetEncoderInfo
(
)
const
=
0
;
protected
:
virtual
~
RefCountedWebrtcVideoEncoder
(
)
=
default
;
}
;
class
WebrtcGmpVideoEncoder
final
:
public
GMPVideoEncoderCallbackProxy
public
RefCountedWebrtcVideoEncoder
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
WebrtcGmpVideoEncoder
final
)
;
WebrtcGmpVideoEncoder
(
const
webrtc
:
:
SdpVideoFormat
&
aFormat
std
:
:
string
aPCHandle
)
;
int32_t
InitEncode
(
const
webrtc
:
:
VideoCodec
*
aCodecSettings
const
webrtc
:
:
VideoEncoder
:
:
Settings
&
aSettings
)
override
;
int32_t
Encode
(
const
webrtc
:
:
VideoFrame
&
aInputImage
const
std
:
:
vector
<
webrtc
:
:
VideoFrameType
>
*
aFrameTypes
)
override
;
int32_t
RegisterEncodeCompleteCallback
(
webrtc
:
:
EncodedImageCallback
*
aCallback
)
override
;
int32_t
Shutdown
(
)
override
;
int32_t
SetRates
(
const
webrtc
:
:
VideoEncoder
:
:
RateControlParameters
&
aParameters
)
override
;
WebrtcVideoEncoder
:
:
EncoderInfo
GetEncoderInfo
(
)
const
override
;
MediaEventSource
<
uint64_t
>
*
InitPluginEvent
(
)
override
{
return
&
mInitPluginEvent
;
}
MediaEventSource
<
uint64_t
>
*
ReleasePluginEvent
(
)
override
{
return
&
mReleasePluginEvent
;
}
void
Terminated
(
)
override
;
void
Encoded
(
GMPVideoEncodedFrame
*
aEncodedFrame
const
nsTArray
<
uint8_t
>
&
aCodecSpecificInfo
)
override
;
void
Error
(
GMPErr
aError
)
override
{
}
private
:
virtual
~
WebrtcGmpVideoEncoder
(
)
;
void
InitEncode_g
(
const
GMPVideoCodec
&
aCodecParams
int32_t
aNumberOfCores
uint32_t
aMaxPayloadSize
)
;
int32_t
GmpInitDone_g
(
GMPVideoEncoderProxy
*
aGMP
GMPVideoHost
*
aHost
const
GMPVideoCodec
&
aCodecParams
std
:
:
string
*
aErrorOut
)
;
int32_t
GmpInitDone_g
(
GMPVideoEncoderProxy
*
aGMP
GMPVideoHost
*
aHost
std
:
:
string
*
aErrorOut
)
;
int32_t
InitEncoderForSize
(
unsigned
short
aWidth
unsigned
short
aHeight
std
:
:
string
*
aErrorOut
)
;
void
Close_g
(
)
;
class
InitDoneCallback
final
:
public
GetGMPVideoEncoderCallback
{
public
:
InitDoneCallback
(
const
RefPtr
<
WebrtcGmpVideoEncoder
>
&
aEncoder
const
GMPVideoCodec
&
aCodecParams
)
:
mEncoder
(
aEncoder
)
mCodecParams
(
aCodecParams
)
{
}
void
Done
(
GMPVideoEncoderProxy
*
aGMP
GMPVideoHost
*
aHost
)
override
{
std
:
:
string
errorOut
;
int32_t
result
=
mEncoder
-
>
GmpInitDone_g
(
aGMP
aHost
mCodecParams
&
errorOut
)
;
NotifyGmpInitDone
(
mEncoder
-
>
mPCHandle
result
errorOut
)
;
}
private
:
const
RefPtr
<
WebrtcGmpVideoEncoder
>
mEncoder
;
const
GMPVideoCodec
mCodecParams
;
}
;
void
Encode_g
(
const
webrtc
:
:
VideoFrame
&
aInputImage
std
:
:
vector
<
webrtc
:
:
VideoFrameType
>
aFrameTypes
)
;
void
RegetEncoderForResolutionChange
(
uint32_t
aWidth
uint32_t
aHeight
)
;
class
InitDoneForResolutionChangeCallback
final
:
public
GetGMPVideoEncoderCallback
{
public
:
InitDoneForResolutionChangeCallback
(
const
RefPtr
<
WebrtcGmpVideoEncoder
>
&
aEncoder
uint32_t
aWidth
uint32_t
aHeight
)
:
mEncoder
(
aEncoder
)
mWidth
(
aWidth
)
mHeight
(
aHeight
)
{
}
void
Done
(
GMPVideoEncoderProxy
*
aGMP
GMPVideoHost
*
aHost
)
override
{
std
:
:
string
errorOut
;
int32_t
result
=
mEncoder
-
>
GmpInitDone_g
(
aGMP
aHost
&
errorOut
)
;
if
(
result
!
=
WEBRTC_VIDEO_CODEC_OK
)
{
NotifyGmpInitDone
(
mEncoder
-
>
mPCHandle
result
errorOut
)
;
return
;
}
result
=
mEncoder
-
>
InitEncoderForSize
(
mWidth
mHeight
&
errorOut
)
;
NotifyGmpInitDone
(
mEncoder
-
>
mPCHandle
result
errorOut
)
;
}
private
:
const
RefPtr
<
WebrtcGmpVideoEncoder
>
mEncoder
;
const
uint32_t
mWidth
;
const
uint32_t
mHeight
;
}
;
int32_t
SetRates_g
(
uint32_t
aOldBitRateKbps
uint32_t
aNewBitRateKbps
Maybe
<
double
>
aFrameRate
)
;
nsCOMPtr
<
mozIGeckoMediaPluginService
>
mMPS
;
nsCOMPtr
<
nsIThread
>
mGMPThread
;
GMPVideoEncoderProxy
*
mGMP
;
Maybe
<
EventTargetCapability
<
nsISerialEventTarget
>
>
mEncodeQueue
;
bool
mInitting
;
uint32_t
mConfiguredBitrateKbps
MOZ_GUARDED_BY
(
mEncodeQueue
)
;
GMPVideoHost
*
mHost
;
GMPVideoCodec
mCodecParams
{
}
;
uint32_t
mMaxPayloadSize
;
bool
mNeedKeyframe
;
int
mSyncLayerCap
;
const
webrtc
:
:
CodecParameterMap
mFormatParams
;
webrtc
:
:
H264BitstreamParser
mH264BitstreamParser
;
std
:
:
unique_ptr
<
webrtc
:
:
ScalableVideoController
>
mSvcController
;
Mutex
mCallbackMutex
;
webrtc
:
:
EncodedImageCallback
*
mCallback
MOZ_GUARDED_BY
(
mCallbackMutex
)
;
Maybe
<
uint64_t
>
mCachedPluginId
;
const
std
:
:
string
mPCHandle
;
static
constexpr
size_t
kMaxImagesInFlight
=
1
;
AutoTArray
<
detail
:
:
InputImageData
kMaxImagesInFlight
>
mInputImageMap
;
MediaEventProducer
<
uint64_t
>
mInitPluginEvent
;
MediaEventProducer
<
uint64_t
>
mReleasePluginEvent
;
}
;
class
WebrtcVideoEncoderProxy
final
:
public
WebrtcVideoEncoder
{
public
:
explicit
WebrtcVideoEncoderProxy
(
RefPtr
<
RefCountedWebrtcVideoEncoder
>
aEncoder
)
:
mEncoderImpl
(
std
:
:
move
(
aEncoder
)
)
{
}
virtual
~
WebrtcVideoEncoderProxy
(
)
{
RegisterEncodeCompleteCallback
(
nullptr
)
;
}
MediaEventSource
<
uint64_t
>
*
InitPluginEvent
(
)
override
{
return
mEncoderImpl
-
>
InitPluginEvent
(
)
;
}
MediaEventSource
<
uint64_t
>
*
ReleasePluginEvent
(
)
override
{
return
mEncoderImpl
-
>
ReleasePluginEvent
(
)
;
}
int32_t
InitEncode
(
const
webrtc
:
:
VideoCodec
*
aCodecSettings
const
WebrtcVideoEncoder
:
:
Settings
&
aSettings
)
override
{
return
mEncoderImpl
-
>
InitEncode
(
aCodecSettings
aSettings
)
;
}
int32_t
Encode
(
const
webrtc
:
:
VideoFrame
&
aInputImage
const
std
:
:
vector
<
webrtc
:
:
VideoFrameType
>
*
aFrameTypes
)
override
{
return
mEncoderImpl
-
>
Encode
(
aInputImage
aFrameTypes
)
;
}
int32_t
RegisterEncodeCompleteCallback
(
webrtc
:
:
EncodedImageCallback
*
aCallback
)
override
{
return
mEncoderImpl
-
>
RegisterEncodeCompleteCallback
(
aCallback
)
;
}
int32_t
Release
(
)
override
{
return
mEncoderImpl
-
>
Shutdown
(
)
;
}
void
SetRates
(
const
RateControlParameters
&
aParameters
)
override
{
mEncoderImpl
-
>
SetRates
(
aParameters
)
;
}
EncoderInfo
GetEncoderInfo
(
)
const
override
{
return
mEncoderImpl
-
>
GetEncoderInfo
(
)
;
}
private
:
const
RefPtr
<
RefCountedWebrtcVideoEncoder
>
mEncoderImpl
;
}
;
class
WebrtcGmpVideoDecoder
final
:
public
GMPVideoDecoderCallbackProxy
{
public
:
WebrtcGmpVideoDecoder
(
std
:
:
string
aPCHandle
TrackingId
aTrackingId
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
WebrtcGmpVideoDecoder
final
)
;
virtual
bool
Configure
(
const
webrtc
:
:
VideoDecoder
:
:
Settings
&
settings
)
;
virtual
int32_t
Decode
(
const
webrtc
:
:
EncodedImage
&
aInputImage
bool
aMissingFrames
int64_t
aRenderTimeMs
)
;
virtual
int32_t
RegisterDecodeCompleteCallback
(
webrtc
:
:
DecodedImageCallback
*
aCallback
)
;
virtual
int32_t
ReleaseGmp
(
)
;
MediaEventSource
<
uint64_t
>
*
InitPluginEvent
(
)
{
return
&
mInitPluginEvent
;
}
MediaEventSource
<
uint64_t
>
*
ReleasePluginEvent
(
)
{
return
&
mReleasePluginEvent
;
}
void
Terminated
(
)
override
;
void
Decoded
(
GMPVideoi420Frame
*
aDecodedFrame
)
override
;
void
ReceivedDecodedReferenceFrame
(
const
uint64_t
aPictureId
)
override
{
MOZ_CRASH
(
)
;
}
void
ReceivedDecodedFrame
(
const
uint64_t
aPictureId
)
override
{
MOZ_CRASH
(
)
;
}
void
InputDataExhausted
(
)
override
{
}
void
DrainComplete
(
)
override
{
}
void
ResetComplete
(
)
override
{
}
void
Error
(
GMPErr
aError
)
override
{
mDecoderStatus
=
aError
;
}
private
:
virtual
~
WebrtcGmpVideoDecoder
(
)
;
void
Configure_g
(
const
webrtc
:
:
VideoDecoder
:
:
Settings
&
settings
)
;
int32_t
GmpInitDone_g
(
GMPVideoDecoderProxy
*
aGMP
GMPVideoHost
*
aHost
std
:
:
string
*
aErrorOut
)
;
void
Close_g
(
)
;
class
InitDoneCallback
final
:
public
GetGMPVideoDecoderCallback
{
public
:
explicit
InitDoneCallback
(
const
RefPtr
<
WebrtcGmpVideoDecoder
>
&
aDecoder
)
:
mDecoder
(
aDecoder
)
{
}
void
Done
(
GMPVideoDecoderProxy
*
aGMP
GMPVideoHost
*
aHost
)
override
{
std
:
:
string
errorOut
;
int32_t
result
=
mDecoder
-
>
GmpInitDone_g
(
aGMP
aHost
&
errorOut
)
;
NotifyGmpInitDone
(
mDecoder
-
>
mPCHandle
result
errorOut
)
;
}
private
:
const
RefPtr
<
WebrtcGmpVideoDecoder
>
mDecoder
;
}
;
void
Decode_g
(
UniquePtr
<
GMPDecodeData
>
&
&
aDecodeData
)
;
nsCOMPtr
<
mozIGeckoMediaPluginService
>
mMPS
;
nsCOMPtr
<
nsIThread
>
mGMPThread
;
GMPVideoDecoderProxy
*
mGMP
;
bool
mInitting
;
nsTArray
<
UniquePtr
<
GMPDecodeData
>
>
mQueuedFrames
;
GMPVideoHost
*
mHost
;
Mutex
mCallbackMutex
;
webrtc
:
:
DecodedImageCallback
*
mCallback
MOZ_GUARDED_BY
(
mCallbackMutex
)
;
Maybe
<
uint64_t
>
mCachedPluginId
;
Atomic
<
GMPErr
ReleaseAcquire
>
mDecoderStatus
;
const
std
:
:
string
mPCHandle
;
const
TrackingId
mTrackingId
;
PerformanceRecorderMulti
<
DecodeStage
>
mPerformanceRecorder
;
MediaEventProducer
<
uint64_t
>
mInitPluginEvent
;
MediaEventProducer
<
uint64_t
>
mReleasePluginEvent
;
}
;
class
WebrtcVideoDecoderProxy
final
:
public
WebrtcVideoDecoder
{
public
:
explicit
WebrtcVideoDecoderProxy
(
std
:
:
string
aPCHandle
TrackingId
aTrackingId
)
:
mDecoderImpl
(
new
WebrtcGmpVideoDecoder
(
std
:
:
move
(
aPCHandle
)
std
:
:
move
(
aTrackingId
)
)
)
{
}
virtual
~
WebrtcVideoDecoderProxy
(
)
{
RegisterDecodeCompleteCallback
(
nullptr
)
;
}
MediaEventSource
<
uint64_t
>
*
InitPluginEvent
(
)
override
{
return
mDecoderImpl
-
>
InitPluginEvent
(
)
;
}
MediaEventSource
<
uint64_t
>
*
ReleasePluginEvent
(
)
override
{
return
mDecoderImpl
-
>
ReleasePluginEvent
(
)
;
}
bool
Configure
(
const
Settings
&
settings
)
override
{
return
mDecoderImpl
-
>
Configure
(
settings
)
;
}
int32_t
Decode
(
const
webrtc
:
:
EncodedImage
&
aInputImage
bool
aMissingFrames
int64_t
aRenderTimeMs
)
override
{
return
mDecoderImpl
-
>
Decode
(
aInputImage
aMissingFrames
aRenderTimeMs
)
;
}
int32_t
RegisterDecodeCompleteCallback
(
webrtc
:
:
DecodedImageCallback
*
aCallback
)
override
{
return
mDecoderImpl
-
>
RegisterDecodeCompleteCallback
(
aCallback
)
;
}
int32_t
Release
(
)
override
{
return
mDecoderImpl
-
>
ReleaseGmp
(
)
;
}
private
:
const
RefPtr
<
WebrtcGmpVideoDecoder
>
mDecoderImpl
;
}
;
}
#
endif
