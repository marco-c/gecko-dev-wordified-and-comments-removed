#
include
"
WebrtcGmpVideoCodec
.
h
"
#
include
<
utility
>
#
include
<
vector
>
#
include
"
GMPLog
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
VideoConduit
.
h
"
#
include
"
gmp
-
video
-
frame
-
encoded
.
h
"
#
include
"
gmp
-
video
-
frame
-
i420
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
transport
/
runnable_utils
.
h
"
#
include
"
api
/
video
/
video_frame_type
.
h
"
#
include
"
common_video
/
include
/
video_frame_buffer
.
h
"
namespace
mozilla
{
static
const
int
kLowH264QpThreshold
=
24
;
static
const
int
kHighH264QpThreshold
=
37
;
WebrtcGmpVideoEncoder
:
:
WebrtcGmpVideoEncoder
(
std
:
:
string
aPCHandle
)
:
mGMP
(
nullptr
)
mInitting
(
false
)
mHost
(
nullptr
)
mMaxPayloadSize
(
0
)
mCallbackMutex
(
"
WebrtcGmpVideoEncoder
encoded
callback
mutex
"
)
mCallback
(
nullptr
)
mPCHandle
(
std
:
:
move
(
aPCHandle
)
)
mInputImageMap
(
"
WebrtcGmpVideoEncoder
:
:
mInputImageMap
"
)
{
mCodecParams
.
mGMPApiVersion
=
0
;
mCodecParams
.
mCodecType
=
kGMPVideoCodecInvalid
;
mCodecParams
.
mPLType
=
0
;
mCodecParams
.
mWidth
=
0
;
mCodecParams
.
mHeight
=
0
;
mCodecParams
.
mStartBitrate
=
0
;
mCodecParams
.
mMaxBitrate
=
0
;
mCodecParams
.
mMinBitrate
=
0
;
mCodecParams
.
mMaxFramerate
=
0
;
mCodecParams
.
mFrameDroppingOn
=
false
;
mCodecParams
.
mKeyFrameInterval
=
0
;
mCodecParams
.
mQPMax
=
0
;
mCodecParams
.
mNumberOfSimulcastStreams
=
0
;
mCodecParams
.
mMode
=
kGMPCodecModeInvalid
;
MOZ_ASSERT
(
!
mPCHandle
.
empty
(
)
)
;
}
WebrtcGmpVideoEncoder
:
:
~
WebrtcGmpVideoEncoder
(
)
{
MOZ_ASSERT
(
!
mGMP
)
;
}
static
int
WebrtcFrameTypeToGmpFrameType
(
webrtc
:
:
VideoFrameType
aIn
GMPVideoFrameType
*
aOut
)
{
MOZ_ASSERT
(
aOut
)
;
switch
(
aIn
)
{
case
webrtc
:
:
VideoFrameType
:
:
kVideoFrameKey
:
*
aOut
=
kGMPKeyFrame
;
break
;
case
webrtc
:
:
VideoFrameType
:
:
kVideoFrameDelta
:
*
aOut
=
kGMPDeltaFrame
;
break
;
case
webrtc
:
:
VideoFrameType
:
:
kEmptyFrame
:
*
aOut
=
kGMPSkipFrame
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
webrtc
:
:
FrameType
"
)
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
static
int
GmpFrameTypeToWebrtcFrameType
(
GMPVideoFrameType
aIn
webrtc
:
:
VideoFrameType
*
aOut
)
{
MOZ_ASSERT
(
aOut
)
;
switch
(
aIn
)
{
case
kGMPKeyFrame
:
*
aOut
=
webrtc
:
:
VideoFrameType
:
:
kVideoFrameKey
;
break
;
case
kGMPDeltaFrame
:
*
aOut
=
webrtc
:
:
VideoFrameType
:
:
kVideoFrameDelta
;
break
;
case
kGMPSkipFrame
:
*
aOut
=
webrtc
:
:
VideoFrameType
:
:
kEmptyFrame
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
GMPVideoFrameType
"
)
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
static
int
SizeNumBytes
(
GMPBufferType
aBufferType
)
{
switch
(
aBufferType
)
{
case
GMP_BufferSingle
:
return
0
;
case
GMP_BufferLength8
:
return
1
;
case
GMP_BufferLength16
:
return
2
;
case
GMP_BufferLength24
:
return
3
;
case
GMP_BufferLength32
:
return
4
;
default
:
MOZ_CRASH
(
"
Unexpected
buffer
type
"
)
;
}
}
int32_t
WebrtcGmpVideoEncoder
:
:
InitEncode
(
const
webrtc
:
:
VideoCodec
*
aCodecSettings
const
webrtc
:
:
VideoEncoder
:
:
Settings
&
aSettings
)
{
if
(
!
mMPS
)
{
mMPS
=
do_GetService
(
"
mozilla
.
org
/
gecko
-
media
-
plugin
-
service
;
1
"
)
;
}
MOZ_ASSERT
(
mMPS
)
;
if
(
!
mGMPThread
)
{
if
(
NS_WARN_IF
(
NS_FAILED
(
mMPS
-
>
GetThread
(
getter_AddRefs
(
mGMPThread
)
)
)
)
)
{
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
}
MOZ_ASSERT
(
aCodecSettings
-
>
numberOfSimulcastStreams
=
=
1
"
Simulcast
not
implemented
for
GMP
-
H264
"
)
;
GMPVideoCodec
codecParams
;
memset
(
&
codecParams
0
sizeof
(
codecParams
)
)
;
codecParams
.
mGMPApiVersion
=
33
;
codecParams
.
mStartBitrate
=
aCodecSettings
-
>
startBitrate
;
codecParams
.
mMinBitrate
=
aCodecSettings
-
>
minBitrate
;
codecParams
.
mMaxBitrate
=
aCodecSettings
-
>
maxBitrate
;
codecParams
.
mMaxFramerate
=
aCodecSettings
-
>
maxFramerate
;
memset
(
&
mCodecSpecificInfo
.
codecSpecific
0
sizeof
(
mCodecSpecificInfo
.
codecSpecific
)
)
;
mCodecSpecificInfo
.
codecType
=
webrtc
:
:
kVideoCodecH264
;
mCodecSpecificInfo
.
codecSpecific
.
H264
.
packetization_mode
=
aCodecSettings
-
>
H264
(
)
.
packetizationMode
=
=
1
?
webrtc
:
:
H264PacketizationMode
:
:
NonInterleaved
:
webrtc
:
:
H264PacketizationMode
:
:
SingleNalUnit
;
uint32_t
maxPayloadSize
=
aSettings
.
max_payload_size
;
if
(
mCodecSpecificInfo
.
codecSpecific
.
H264
.
packetization_mode
=
=
webrtc
:
:
H264PacketizationMode
:
:
NonInterleaved
)
{
maxPayloadSize
=
0
;
}
if
(
aCodecSettings
-
>
mode
=
=
webrtc
:
:
VideoCodecMode
:
:
kScreensharing
)
{
codecParams
.
mMode
=
kGMPScreensharing
;
}
else
{
codecParams
.
mMode
=
kGMPRealtimeVideo
;
}
codecParams
.
mWidth
=
aCodecSettings
-
>
width
;
codecParams
.
mHeight
=
aCodecSettings
-
>
height
;
RefPtr
<
GmpInitDoneRunnable
>
initDone
(
new
GmpInitDoneRunnable
(
mPCHandle
)
)
;
mGMPThread
-
>
Dispatch
(
WrapRunnableNM
(
WebrtcGmpVideoEncoder
:
:
InitEncode_g
RefPtr
<
WebrtcGmpVideoEncoder
>
(
this
)
codecParams
aSettings
.
number_of_cores
maxPayloadSize
initDone
)
NS_DISPATCH_NORMAL
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
void
WebrtcGmpVideoEncoder
:
:
InitEncode_g
(
const
RefPtr
<
WebrtcGmpVideoEncoder
>
&
aThis
const
GMPVideoCodec
&
aCodecParams
int32_t
aNumberOfCores
uint32_t
aMaxPayloadSize
const
RefPtr
<
GmpInitDoneRunnable
>
&
aInitDone
)
{
nsTArray
<
nsCString
>
tags
;
tags
.
AppendElement
(
"
h264
"
_ns
)
;
UniquePtr
<
GetGMPVideoEncoderCallback
>
callback
(
new
InitDoneCallback
(
aThis
aInitDone
aCodecParams
)
)
;
aThis
-
>
mInitting
=
true
;
aThis
-
>
mMaxPayloadSize
=
aMaxPayloadSize
;
nsresult
rv
=
aThis
-
>
mMPS
-
>
GetGMPVideoEncoder
(
nullptr
&
tags
"
"
_ns
std
:
:
move
(
callback
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
GMP_LOG_DEBUG
(
"
GMP
Encode
:
GetGMPVideoEncoder
failed
"
)
;
aThis
-
>
Close_g
(
)
;
aInitDone
-
>
Dispatch
(
WEBRTC_VIDEO_CODEC_ERROR
"
GMP
Encode
:
GetGMPVideoEncoder
failed
"
)
;
}
}
int32_t
WebrtcGmpVideoEncoder
:
:
GmpInitDone
(
GMPVideoEncoderProxy
*
aGMP
GMPVideoHost
*
aHost
std
:
:
string
*
aErrorOut
)
{
if
(
!
mInitting
|
|
!
aGMP
|
|
!
aHost
)
{
*
aErrorOut
=
"
GMP
Encode
:
Either
init
was
aborted
"
"
or
init
failed
to
supply
either
a
GMP
Encoder
or
GMP
host
.
"
;
if
(
aGMP
)
{
aGMP
-
>
Close
(
)
;
}
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
mInitting
=
false
;
if
(
mGMP
&
&
mGMP
!
=
aGMP
)
{
Close_g
(
)
;
}
mGMP
=
aGMP
;
mHost
=
aHost
;
mCachedPluginId
=
Some
(
mGMP
-
>
GetPluginId
(
)
)
;
mInitPluginEvent
.
Notify
(
*
mCachedPluginId
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
int32_t
WebrtcGmpVideoEncoder
:
:
GmpInitDone
(
GMPVideoEncoderProxy
*
aGMP
GMPVideoHost
*
aHost
const
GMPVideoCodec
&
aCodecParams
std
:
:
string
*
aErrorOut
)
{
int32_t
r
=
GmpInitDone
(
aGMP
aHost
aErrorOut
)
;
if
(
r
!
=
WEBRTC_VIDEO_CODEC_OK
)
{
return
r
;
}
mCodecParams
=
aCodecParams
;
return
InitEncoderForSize
(
aCodecParams
.
mWidth
aCodecParams
.
mHeight
aErrorOut
)
;
}
void
WebrtcGmpVideoEncoder
:
:
Close_g
(
)
{
GMPVideoEncoderProxy
*
gmp
(
mGMP
)
;
mGMP
=
nullptr
;
mHost
=
nullptr
;
mInitting
=
false
;
if
(
mCachedPluginId
)
{
mReleasePluginEvent
.
Notify
(
*
mCachedPluginId
)
;
}
mCachedPluginId
=
Nothing
(
)
;
if
(
gmp
)
{
gmp
-
>
Close
(
)
;
}
}
int32_t
WebrtcGmpVideoEncoder
:
:
InitEncoderForSize
(
unsigned
short
aWidth
unsigned
short
aHeight
std
:
:
string
*
aErrorOut
)
{
mCodecParams
.
mWidth
=
aWidth
;
mCodecParams
.
mHeight
=
aHeight
;
nsTArray
<
uint8_t
>
codecSpecific
;
GMPErr
err
=
mGMP
-
>
InitEncode
(
mCodecParams
codecSpecific
this
1
mMaxPayloadSize
)
;
if
(
err
!
=
GMPNoErr
)
{
*
aErrorOut
=
"
GMP
Encode
:
InitEncode
failed
"
;
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
int32_t
WebrtcGmpVideoEncoder
:
:
Encode
(
const
webrtc
:
:
VideoFrame
&
aInputImage
const
std
:
:
vector
<
webrtc
:
:
VideoFrameType
>
*
aFrameTypes
)
{
MOZ_ASSERT
(
aInputImage
.
width
(
)
>
=
0
&
&
aInputImage
.
height
(
)
>
=
0
)
;
if
(
!
aFrameTypes
)
{
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
mGMPThread
-
>
Dispatch
(
WrapRunnableNM
(
&
WebrtcGmpVideoEncoder
:
:
Encode_g
RefPtr
<
WebrtcGmpVideoEncoder
>
(
this
)
aInputImage
*
aFrameTypes
)
NS_DISPATCH_NORMAL
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
void
WebrtcGmpVideoEncoder
:
:
RegetEncoderForResolutionChange
(
uint32_t
aWidth
uint32_t
aHeight
const
RefPtr
<
GmpInitDoneRunnable
>
&
aInitDone
)
{
Close_g
(
)
;
UniquePtr
<
GetGMPVideoEncoderCallback
>
callback
(
new
InitDoneForResolutionChangeCallback
(
this
aInitDone
aWidth
aHeight
)
)
;
nsTArray
<
nsCString
>
tags
;
tags
.
AppendElement
(
"
h264
"
_ns
)
;
mInitting
=
true
;
if
(
NS_WARN_IF
(
NS_FAILED
(
mMPS
-
>
GetGMPVideoEncoder
(
nullptr
&
tags
"
"
_ns
std
:
:
move
(
callback
)
)
)
)
)
{
aInitDone
-
>
Dispatch
(
WEBRTC_VIDEO_CODEC_ERROR
"
GMP
Encode
:
GetGMPVideoEncoder
failed
"
)
;
}
}
void
WebrtcGmpVideoEncoder
:
:
Encode_g
(
const
RefPtr
<
WebrtcGmpVideoEncoder
>
&
aEncoder
webrtc
:
:
VideoFrame
aInputImage
std
:
:
vector
<
webrtc
:
:
VideoFrameType
>
aFrameTypes
)
{
if
(
!
aEncoder
-
>
mGMP
)
{
GMP_LOG_DEBUG
(
"
GMP
Encode
:
not
initted
yet
"
)
;
return
;
}
MOZ_ASSERT
(
aEncoder
-
>
mHost
)
;
if
(
static_cast
<
uint32_t
>
(
aInputImage
.
width
(
)
)
!
=
aEncoder
-
>
mCodecParams
.
mWidth
|
|
static_cast
<
uint32_t
>
(
aInputImage
.
height
(
)
)
!
=
aEncoder
-
>
mCodecParams
.
mHeight
)
{
GMP_LOG_DEBUG
(
"
GMP
Encode
:
resolution
change
from
%
ux
%
u
to
%
dx
%
d
"
aEncoder
-
>
mCodecParams
.
mWidth
aEncoder
-
>
mCodecParams
.
mHeight
aInputImage
.
width
(
)
aInputImage
.
height
(
)
)
;
RefPtr
<
GmpInitDoneRunnable
>
initDone
(
new
GmpInitDoneRunnable
(
aEncoder
-
>
mPCHandle
)
)
;
aEncoder
-
>
RegetEncoderForResolutionChange
(
aInputImage
.
width
(
)
aInputImage
.
height
(
)
initDone
)
;
if
(
!
aEncoder
-
>
mGMP
)
{
return
;
}
}
GMPVideoFrame
*
ftmp
=
nullptr
;
GMPErr
err
=
aEncoder
-
>
mHost
-
>
CreateFrame
(
kGMPI420VideoFrame
&
ftmp
)
;
if
(
err
!
=
GMPNoErr
)
{
GMP_LOG_DEBUG
(
"
GMP
Encode
:
failed
to
create
frame
on
host
"
)
;
return
;
}
GMPUniquePtr
<
GMPVideoi420Frame
>
frame
(
static_cast
<
GMPVideoi420Frame
*
>
(
ftmp
)
)
;
const
webrtc
:
:
I420BufferInterface
*
input_image
=
aInputImage
.
video_frame_buffer
(
)
-
>
GetI420
(
)
;
CheckedInt32
ysize
=
CheckedInt32
(
input_image
-
>
StrideY
(
)
)
*
input_image
-
>
height
(
)
;
MOZ_RELEASE_ASSERT
(
ysize
.
isValid
(
)
)
;
err
=
frame
-
>
CreateFrame
(
ysize
.
value
(
)
input_image
-
>
DataY
(
)
input_image
-
>
StrideU
(
)
*
(
(
input_image
-
>
height
(
)
+
1
)
/
2
)
input_image
-
>
DataU
(
)
input_image
-
>
StrideV
(
)
*
(
(
input_image
-
>
height
(
)
+
1
)
/
2
)
input_image
-
>
DataV
(
)
input_image
-
>
width
(
)
input_image
-
>
height
(
)
input_image
-
>
StrideY
(
)
input_image
-
>
StrideU
(
)
input_image
-
>
StrideV
(
)
)
;
if
(
err
!
=
GMPNoErr
)
{
GMP_LOG_DEBUG
(
"
GMP
Encode
:
failed
to
create
frame
"
)
;
return
;
}
frame
-
>
SetTimestamp
(
(
aInputImage
.
timestamp
(
)
*
1000ll
)
/
90
)
;
GMPCodecSpecificInfo
info
;
memset
(
&
info
0
sizeof
(
info
)
)
;
info
.
mCodecType
=
kGMPVideoCodecH264
;
nsTArray
<
uint8_t
>
codecSpecificInfo
;
codecSpecificInfo
.
AppendElements
(
(
uint8_t
*
)
&
info
sizeof
(
GMPCodecSpecificInfo
)
)
;
nsTArray
<
GMPVideoFrameType
>
gmp_frame_types
;
for
(
auto
it
=
aFrameTypes
.
begin
(
)
;
it
!
=
aFrameTypes
.
end
(
)
;
+
+
it
)
{
GMPVideoFrameType
ft
;
int32_t
ret
=
WebrtcFrameTypeToGmpFrameType
(
*
it
&
ft
)
;
if
(
ret
!
=
WEBRTC_VIDEO_CODEC_OK
)
{
GMP_LOG_DEBUG
(
"
GMP
Encode
:
failed
to
map
webrtc
frame
type
to
gmp
frame
type
"
)
;
return
;
}
gmp_frame_types
.
AppendElement
(
ft
)
;
}
{
auto
inputImageMap
=
aEncoder
-
>
mInputImageMap
.
Lock
(
)
;
DebugOnly
<
bool
>
inserted
=
false
;
std
:
:
tie
(
std
:
:
ignore
inserted
)
=
inputImageMap
-
>
insert
(
{
frame
-
>
Timestamp
(
)
{
aInputImage
.
timestamp_us
(
)
}
}
)
;
MOZ_ASSERT
(
inserted
"
Duplicate
timestamp
"
)
;
}
GMP_LOG_DEBUG
(
"
GMP
Encode
:
%
"
PRIu64
(
frame
-
>
Timestamp
(
)
)
)
;
err
=
aEncoder
-
>
mGMP
-
>
Encode
(
std
:
:
move
(
frame
)
codecSpecificInfo
gmp_frame_types
)
;
if
(
err
!
=
GMPNoErr
)
{
GMP_LOG_DEBUG
(
"
GMP
Encode
:
failed
to
encode
frame
"
)
;
}
}
int32_t
WebrtcGmpVideoEncoder
:
:
RegisterEncodeCompleteCallback
(
webrtc
:
:
EncodedImageCallback
*
aCallback
)
{
MutexAutoLock
lock
(
mCallbackMutex
)
;
mCallback
=
aCallback
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
void
WebrtcGmpVideoEncoder
:
:
ReleaseGmp_g
(
const
RefPtr
<
WebrtcGmpVideoEncoder
>
&
aEncoder
)
{
aEncoder
-
>
Close_g
(
)
;
}
int32_t
WebrtcGmpVideoEncoder
:
:
Shutdown
(
)
{
GMP_LOG_DEBUG
(
"
GMP
Released
:
"
)
;
RegisterEncodeCompleteCallback
(
nullptr
)
;
if
(
mGMPThread
)
{
mGMPThread
-
>
Dispatch
(
WrapRunnableNM
(
&
WebrtcGmpVideoEncoder
:
:
ReleaseGmp_g
RefPtr
<
WebrtcGmpVideoEncoder
>
(
this
)
)
NS_DISPATCH_NORMAL
)
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
int32_t
WebrtcGmpVideoEncoder
:
:
SetRates
(
const
webrtc
:
:
VideoEncoder
:
:
RateControlParameters
&
aParameters
)
{
MOZ_ASSERT
(
mGMPThread
)
;
MOZ_ASSERT
(
aParameters
.
bitrate
.
IsSpatialLayerUsed
(
0
)
)
;
MOZ_ASSERT
(
!
aParameters
.
bitrate
.
HasBitrate
(
0
1
)
"
No
simulcast
support
for
H264
"
)
;
MOZ_ASSERT
(
!
aParameters
.
bitrate
.
IsSpatialLayerUsed
(
1
)
"
No
simulcast
support
for
H264
"
)
;
mGMPThread
-
>
Dispatch
(
WrapRunnableNM
(
&
WebrtcGmpVideoEncoder
:
:
SetRates_g
RefPtr
<
WebrtcGmpVideoEncoder
>
(
this
)
aParameters
.
bitrate
.
GetBitrate
(
0
0
)
/
1000
aParameters
.
framerate_fps
>
0
.
0
?
Some
(
aParameters
.
framerate_fps
)
:
Nothing
(
)
)
NS_DISPATCH_NORMAL
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
WebrtcVideoEncoder
:
:
EncoderInfo
WebrtcGmpVideoEncoder
:
:
GetEncoderInfo
(
)
const
{
WebrtcVideoEncoder
:
:
EncoderInfo
info
;
info
.
supports_native_handle
=
false
;
info
.
implementation_name
=
"
GMPOpenH264
"
;
info
.
scaling_settings
=
WebrtcVideoEncoder
:
:
ScalingSettings
(
kLowH264QpThreshold
kHighH264QpThreshold
)
;
info
.
is_hardware_accelerated
=
false
;
info
.
supports_simulcast
=
false
;
return
info
;
}
int32_t
WebrtcGmpVideoEncoder
:
:
SetRates_g
(
RefPtr
<
WebrtcGmpVideoEncoder
>
aThis
uint32_t
aNewBitRateKbps
Maybe
<
double
>
aFrameRate
)
{
if
(
!
aThis
-
>
mGMP
)
{
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
GMPErr
err
=
aThis
-
>
mGMP
-
>
SetRates
(
aNewBitRateKbps
aFrameRate
.
map
(
[
]
(
double
aFr
)
{
return
std
:
:
max
(
1U
static_cast
<
uint32_t
>
(
aFr
)
)
;
}
)
.
valueOr
(
aThis
-
>
mCodecParams
.
mMaxFramerate
)
)
;
if
(
err
!
=
GMPNoErr
)
{
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
void
WebrtcGmpVideoEncoder
:
:
Terminated
(
)
{
GMP_LOG_DEBUG
(
"
GMP
Encoder
Terminated
:
%
p
"
(
void
*
)
this
)
;
mGMP
-
>
Close
(
)
;
mGMP
=
nullptr
;
mHost
=
nullptr
;
mInitting
=
false
;
}
void
WebrtcGmpVideoEncoder
:
:
Encoded
(
GMPVideoEncodedFrame
*
aEncodedFrame
const
nsTArray
<
uint8_t
>
&
aCodecSpecificInfo
)
{
webrtc
:
:
Timestamp
capture_time
=
webrtc
:
:
Timestamp
:
:
Micros
(
0
)
;
{
auto
inputImageMap
=
mInputImageMap
.
Lock
(
)
;
auto
handle
=
inputImageMap
-
>
extract
(
aEncodedFrame
-
>
TimeStamp
(
)
)
;
MOZ_ASSERT
(
handle
)
;
if
(
handle
)
{
capture_time
=
webrtc
:
:
Timestamp
:
:
Micros
(
handle
.
mapped
(
)
.
timestamp_us
)
;
}
}
MutexAutoLock
lock
(
mCallbackMutex
)
;
if
(
!
mCallback
)
{
return
;
}
webrtc
:
:
VideoFrameType
ft
;
GmpFrameTypeToWebrtcFrameType
(
aEncodedFrame
-
>
FrameType
(
)
&
ft
)
;
uint32_t
timestamp
=
(
aEncodedFrame
-
>
TimeStamp
(
)
*
90ll
+
999
)
/
1000
;
GMP_LOG_DEBUG
(
"
GMP
Encoded
:
%
"
PRIu64
"
type
%
d
len
%
d
"
aEncodedFrame
-
>
TimeStamp
(
)
aEncodedFrame
-
>
BufferType
(
)
aEncodedFrame
-
>
Size
(
)
)
;
if
(
!
aEncodedFrame
-
>
Buffer
(
)
)
{
GMP_LOG_ERROR
(
"
GMP
plugin
returned
null
buffer
"
)
;
return
;
}
const
int
sizeNumBytes
=
SizeNumBytes
(
aEncodedFrame
-
>
BufferType
(
)
)
;
uint32_t
unitOffset
=
0
;
uint32_t
unitSize
=
0
;
while
(
unitOffset
+
sizeNumBytes
<
aEncodedFrame
-
>
Size
(
)
)
{
uint8_t
*
unitBuffer
=
aEncodedFrame
-
>
Buffer
(
)
+
unitOffset
;
switch
(
aEncodedFrame
-
>
BufferType
(
)
)
{
case
GMP_BufferLength24
:
{
#
if
MOZ_LITTLE_ENDIAN
(
)
unitSize
=
(
static_cast
<
uint32_t
>
(
*
unitBuffer
)
)
|
(
static_cast
<
uint32_t
>
(
*
(
unitBuffer
+
1
)
)
<
<
8
)
|
(
static_cast
<
uint32_t
>
(
*
(
unitBuffer
+
2
)
)
<
<
16
)
;
#
else
unitSize
=
(
static_cast
<
uint32_t
>
(
*
unitBuffer
)
<
<
16
)
|
(
static_cast
<
uint32_t
>
(
*
(
unitBuffer
+
1
)
)
<
<
8
)
|
(
static_cast
<
uint32_t
>
(
*
(
unitBuffer
+
2
)
)
)
;
#
endif
const
uint8_t
startSequence
[
]
=
{
0
0
1
}
;
if
(
memcmp
(
unitBuffer
startSequence
3
)
=
=
0
)
{
unitSize
=
aEncodedFrame
-
>
Size
(
)
-
3
;
break
;
}
memcpy
(
unitBuffer
startSequence
3
)
;
break
;
}
case
GMP_BufferLength32
:
{
#
if
MOZ_LITTLE_ENDIAN
(
)
unitSize
=
LittleEndian
:
:
readUint32
(
unitBuffer
)
;
#
else
unitSize
=
BigEndian
:
:
readUint32
(
unitBuffer
)
;
#
endif
const
uint8_t
startSequence
[
]
=
{
0
0
0
1
}
;
if
(
memcmp
(
unitBuffer
startSequence
4
)
=
=
0
)
{
unitSize
=
aEncodedFrame
-
>
Size
(
)
-
4
;
break
;
}
memcpy
(
unitBuffer
startSequence
4
)
;
break
;
}
default
:
GMP_LOG_ERROR
(
"
GMP
plugin
returned
type
we
cannot
handle
(
%
d
)
"
aEncodedFrame
-
>
BufferType
(
)
)
;
return
;
}
MOZ_ASSERT
(
unitSize
!
=
0
)
;
MOZ_ASSERT
(
unitOffset
+
sizeNumBytes
+
unitSize
<
=
aEncodedFrame
-
>
Size
(
)
)
;
if
(
unitSize
=
=
0
|
|
unitOffset
+
sizeNumBytes
+
unitSize
>
aEncodedFrame
-
>
Size
(
)
)
{
GMP_LOG_ERROR
(
"
GMP
plugin
returned
badly
formatted
encoded
data
:
"
"
unitOffset
=
%
u
sizeNumBytes
=
%
d
unitSize
=
%
u
size
=
%
u
"
unitOffset
sizeNumBytes
unitSize
aEncodedFrame
-
>
Size
(
)
)
;
return
;
}
unitOffset
+
=
sizeNumBytes
+
unitSize
;
}
if
(
unitOffset
!
=
aEncodedFrame
-
>
Size
(
)
)
{
GMP_LOG_DEBUG
(
"
GMP
plugin
returned
%
u
extra
bytes
"
aEncodedFrame
-
>
Size
(
)
-
unitOffset
)
;
}
webrtc
:
:
EncodedImage
unit
(
aEncodedFrame
-
>
Buffer
(
)
aEncodedFrame
-
>
Size
(
)
aEncodedFrame
-
>
Size
(
)
)
;
unit
.
_frameType
=
ft
;
unit
.
SetTimestamp
(
timestamp
)
;
unit
.
capture_time_ms_
=
capture_time
.
ms
(
)
;
unit
.
_encodedWidth
=
aEncodedFrame
-
>
EncodedWidth
(
)
;
unit
.
_encodedHeight
=
aEncodedFrame
-
>
EncodedHeight
(
)
;
mH264BitstreamParser
.
ParseBitstream
(
unit
)
;
unit
.
qp_
=
mH264BitstreamParser
.
GetLastSliceQp
(
)
.
value_or
(
-
1
)
;
mCallback
-
>
OnEncodedImage
(
unit
&
mCodecSpecificInfo
)
;
}
WebrtcGmpVideoDecoder
:
:
WebrtcGmpVideoDecoder
(
std
:
:
string
aPCHandle
)
:
mGMP
(
nullptr
)
mInitting
(
false
)
mHost
(
nullptr
)
mCallbackMutex
(
"
WebrtcGmpVideoDecoder
decoded
callback
mutex
"
)
mCallback
(
nullptr
)
mDecoderStatus
(
GMPNoErr
)
mPCHandle
(
std
:
:
move
(
aPCHandle
)
)
{
MOZ_ASSERT
(
!
mPCHandle
.
empty
(
)
)
;
}
WebrtcGmpVideoDecoder
:
:
~
WebrtcGmpVideoDecoder
(
)
{
MOZ_ASSERT
(
!
mGMP
)
;
}
int32_t
WebrtcGmpVideoDecoder
:
:
InitDecode
(
const
webrtc
:
:
VideoCodec
*
aCodecSettings
int32_t
aNumberOfCores
)
{
if
(
!
mMPS
)
{
mMPS
=
do_GetService
(
"
mozilla
.
org
/
gecko
-
media
-
plugin
-
service
;
1
"
)
;
}
MOZ_ASSERT
(
mMPS
)
;
if
(
!
mGMPThread
)
{
if
(
NS_WARN_IF
(
NS_FAILED
(
mMPS
-
>
GetThread
(
getter_AddRefs
(
mGMPThread
)
)
)
)
)
{
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
}
RefPtr
<
GmpInitDoneRunnable
>
initDone
(
new
GmpInitDoneRunnable
(
mPCHandle
)
)
;
mGMPThread
-
>
Dispatch
(
WrapRunnableNM
(
&
WebrtcGmpVideoDecoder
:
:
InitDecode_g
RefPtr
<
WebrtcGmpVideoDecoder
>
(
this
)
aCodecSettings
aNumberOfCores
initDone
)
NS_DISPATCH_NORMAL
)
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
void
WebrtcGmpVideoDecoder
:
:
InitDecode_g
(
const
RefPtr
<
WebrtcGmpVideoDecoder
>
&
aThis
const
webrtc
:
:
VideoCodec
*
aCodecSettings
int32_t
aNumberOfCores
const
RefPtr
<
GmpInitDoneRunnable
>
&
aInitDone
)
{
nsTArray
<
nsCString
>
tags
;
tags
.
AppendElement
(
"
h264
"
_ns
)
;
UniquePtr
<
GetGMPVideoDecoderCallback
>
callback
(
new
InitDoneCallback
(
aThis
aInitDone
)
)
;
aThis
-
>
mInitting
=
true
;
nsresult
rv
=
aThis
-
>
mMPS
-
>
GetGMPVideoDecoder
(
nullptr
&
tags
"
"
_ns
std
:
:
move
(
callback
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
GMP_LOG_DEBUG
(
"
GMP
Decode
:
GetGMPVideoDecoder
failed
"
)
;
aThis
-
>
Close_g
(
)
;
aInitDone
-
>
Dispatch
(
WEBRTC_VIDEO_CODEC_ERROR
"
GMP
Decode
:
GetGMPVideoDecoder
failed
.
"
)
;
}
}
int32_t
WebrtcGmpVideoDecoder
:
:
GmpInitDone
(
GMPVideoDecoderProxy
*
aGMP
GMPVideoHost
*
aHost
std
:
:
string
*
aErrorOut
)
{
if
(
!
mInitting
|
|
!
aGMP
|
|
!
aHost
)
{
*
aErrorOut
=
"
GMP
Decode
:
Either
init
was
aborted
"
"
or
init
failed
to
supply
either
a
GMP
decoder
or
GMP
host
.
"
;
if
(
aGMP
)
{
aGMP
-
>
Close
(
)
;
}
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
mInitting
=
false
;
if
(
mGMP
&
&
mGMP
!
=
aGMP
)
{
Close_g
(
)
;
}
mGMP
=
aGMP
;
mHost
=
aHost
;
mCachedPluginId
=
Some
(
mGMP
-
>
GetPluginId
(
)
)
;
mInitPluginEvent
.
Notify
(
*
mCachedPluginId
)
;
GMPVideoCodec
codec
;
memset
(
&
codec
0
sizeof
(
codec
)
)
;
codec
.
mGMPApiVersion
=
33
;
nsTArray
<
uint8_t
>
codecSpecific
;
nsresult
rv
=
mGMP
-
>
InitDecode
(
codec
codecSpecific
this
1
)
;
if
(
NS_FAILED
(
rv
)
)
{
*
aErrorOut
=
"
GMP
Decode
:
InitDecode
failed
"
;
mQueuedFrames
.
Clear
(
)
;
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
if
(
!
mQueuedFrames
.
IsEmpty
(
)
)
{
nsTArray
<
UniquePtr
<
GMPDecodeData
>
>
temp
=
std
:
:
move
(
mQueuedFrames
)
;
for
(
auto
&
queued
:
temp
)
{
Decode_g
(
RefPtr
<
WebrtcGmpVideoDecoder
>
(
this
)
std
:
:
move
(
queued
)
)
;
}
}
if
(
mDecoderStatus
!
=
GMPNoErr
)
{
GMP_LOG_ERROR
(
"
%
s
:
Decoder
status
is
bad
(
%
u
)
!
"
__PRETTY_FUNCTION__
static_cast
<
unsigned
>
(
mDecoderStatus
)
)
;
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
void
WebrtcGmpVideoDecoder
:
:
Close_g
(
)
{
GMPVideoDecoderProxy
*
gmp
(
mGMP
)
;
mGMP
=
nullptr
;
mHost
=
nullptr
;
mInitting
=
false
;
if
(
mCachedPluginId
)
{
mReleasePluginEvent
.
Notify
(
*
mCachedPluginId
)
;
}
mCachedPluginId
=
Nothing
(
)
;
if
(
gmp
)
{
gmp
-
>
Close
(
)
;
}
}
int32_t
WebrtcGmpVideoDecoder
:
:
Decode
(
const
webrtc
:
:
EncodedImage
&
aInputImage
bool
aMissingFrames
int64_t
aRenderTimeMs
)
{
MOZ_ASSERT
(
mGMPThread
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
!
aInputImage
.
size
(
)
)
{
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
auto
decodeData
=
MakeUnique
<
GMPDecodeData
>
(
aInputImage
aMissingFrames
aRenderTimeMs
)
;
mGMPThread
-
>
Dispatch
(
WrapRunnableNM
(
&
WebrtcGmpVideoDecoder
:
:
Decode_g
RefPtr
<
WebrtcGmpVideoDecoder
>
(
this
)
std
:
:
move
(
decodeData
)
)
NS_DISPATCH_NORMAL
)
;
if
(
mDecoderStatus
!
=
GMPNoErr
)
{
GMP_LOG_ERROR
(
"
%
s
:
Decoder
status
is
bad
(
%
u
)
!
"
__PRETTY_FUNCTION__
static_cast
<
unsigned
>
(
mDecoderStatus
)
)
;
return
WEBRTC_VIDEO_CODEC_ERROR
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
void
WebrtcGmpVideoDecoder
:
:
Decode_g
(
const
RefPtr
<
WebrtcGmpVideoDecoder
>
&
aThis
UniquePtr
<
GMPDecodeData
>
&
&
aDecodeData
)
{
if
(
!
aThis
-
>
mGMP
)
{
if
(
aThis
-
>
mInitting
)
{
aThis
-
>
mQueuedFrames
.
AppendElement
(
std
:
:
move
(
aDecodeData
)
)
;
return
;
}
GMP_LOG_DEBUG
(
"
GMP
Decode
:
not
initted
yet
"
)
;
aThis
-
>
mDecoderStatus
=
GMPDecodeErr
;
return
;
}
MOZ_ASSERT
(
aThis
-
>
mQueuedFrames
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aThis
-
>
mHost
)
;
GMPVideoFrame
*
ftmp
=
nullptr
;
GMPErr
err
=
aThis
-
>
mHost
-
>
CreateFrame
(
kGMPEncodedVideoFrame
&
ftmp
)
;
if
(
err
!
=
GMPNoErr
)
{
GMP_LOG_ERROR
(
"
%
s
:
CreateFrame
failed
(
%
u
)
!
"
__PRETTY_FUNCTION__
static_cast
<
unsigned
>
(
err
)
)
;
aThis
-
>
mDecoderStatus
=
err
;
return
;
}
GMPUniquePtr
<
GMPVideoEncodedFrame
>
frame
(
static_cast
<
GMPVideoEncodedFrame
*
>
(
ftmp
)
)
;
err
=
frame
-
>
CreateEmptyFrame
(
aDecodeData
-
>
mImage
.
size
(
)
)
;
if
(
err
!
=
GMPNoErr
)
{
GMP_LOG_ERROR
(
"
%
s
:
CreateEmptyFrame
failed
(
%
u
)
!
"
__PRETTY_FUNCTION__
static_cast
<
unsigned
>
(
err
)
)
;
aThis
-
>
mDecoderStatus
=
err
;
return
;
}
*
(
reinterpret_cast
<
uint32_t
*
>
(
frame
-
>
Buffer
(
)
)
)
=
frame
-
>
Size
(
)
;
memcpy
(
frame
-
>
Buffer
(
)
+
4
aDecodeData
-
>
mImage
.
data
(
)
+
4
frame
-
>
Size
(
)
-
4
)
;
frame
-
>
SetEncodedWidth
(
aDecodeData
-
>
mImage
.
_encodedWidth
)
;
frame
-
>
SetEncodedHeight
(
aDecodeData
-
>
mImage
.
_encodedHeight
)
;
frame
-
>
SetTimeStamp
(
(
aDecodeData
-
>
mImage
.
Timestamp
(
)
*
1000ll
)
/
90
)
;
frame
-
>
SetCompleteFrame
(
true
)
;
frame
-
>
SetBufferType
(
GMP_BufferLength32
)
;
GMPVideoFrameType
ft
;
int32_t
ret
=
WebrtcFrameTypeToGmpFrameType
(
aDecodeData
-
>
mImage
.
_frameType
&
ft
)
;
if
(
ret
!
=
WEBRTC_VIDEO_CODEC_OK
)
{
GMP_LOG_ERROR
(
"
%
s
:
WebrtcFrameTypeToGmpFrameType
failed
(
%
u
)
!
"
__PRETTY_FUNCTION__
static_cast
<
unsigned
>
(
ret
)
)
;
aThis
-
>
mDecoderStatus
=
GMPDecodeErr
;
return
;
}
GMPCodecSpecificInfo
info
;
memset
(
&
info
0
sizeof
(
info
)
)
;
info
.
mCodecType
=
kGMPVideoCodecH264
;
info
.
mCodecSpecific
.
mH264
.
mSimulcastIdx
=
0
;
nsTArray
<
uint8_t
>
codecSpecificInfo
;
codecSpecificInfo
.
AppendElements
(
(
uint8_t
*
)
&
info
sizeof
(
GMPCodecSpecificInfo
)
)
;
GMP_LOG_DEBUG
(
"
GMP
Decode
:
%
"
PRIu64
"
len
%
zu
%
s
"
frame
-
>
TimeStamp
(
)
aDecodeData
-
>
mImage
.
size
(
)
ft
=
=
kGMPKeyFrame
?
"
KeyFrame
"
:
"
"
)
;
nsresult
rv
=
aThis
-
>
mGMP
-
>
Decode
(
std
:
:
move
(
frame
)
aDecodeData
-
>
mMissingFrames
codecSpecificInfo
aDecodeData
-
>
mRenderTimeMs
)
;
if
(
NS_FAILED
(
rv
)
)
{
GMP_LOG_ERROR
(
"
%
s
:
Decode
failed
(
rv
=
%
u
)
!
"
__PRETTY_FUNCTION__
static_cast
<
unsigned
>
(
rv
)
)
;
aThis
-
>
mDecoderStatus
=
GMPDecodeErr
;
return
;
}
aThis
-
>
mDecoderStatus
=
GMPNoErr
;
}
int32_t
WebrtcGmpVideoDecoder
:
:
RegisterDecodeCompleteCallback
(
webrtc
:
:
DecodedImageCallback
*
aCallback
)
{
MutexAutoLock
lock
(
mCallbackMutex
)
;
mCallback
=
aCallback
;
return
WEBRTC_VIDEO_CODEC_OK
;
}
void
WebrtcGmpVideoDecoder
:
:
ReleaseGmp_g
(
const
RefPtr
<
WebrtcGmpVideoDecoder
>
&
aDecoder
)
{
aDecoder
-
>
Close_g
(
)
;
}
int32_t
WebrtcGmpVideoDecoder
:
:
ReleaseGmp
(
)
{
GMP_LOG_DEBUG
(
"
GMP
Released
:
"
)
;
RegisterDecodeCompleteCallback
(
nullptr
)
;
if
(
mGMPThread
)
{
mGMPThread
-
>
Dispatch
(
WrapRunnableNM
(
&
WebrtcGmpVideoDecoder
:
:
ReleaseGmp_g
RefPtr
<
WebrtcGmpVideoDecoder
>
(
this
)
)
NS_DISPATCH_NORMAL
)
;
}
return
WEBRTC_VIDEO_CODEC_OK
;
}
void
WebrtcGmpVideoDecoder
:
:
Terminated
(
)
{
GMP_LOG_DEBUG
(
"
GMP
Decoder
Terminated
:
%
p
"
(
void
*
)
this
)
;
mGMP
-
>
Close
(
)
;
mGMP
=
nullptr
;
mHost
=
nullptr
;
mInitting
=
false
;
}
static
void
DeleteBuffer
(
uint8_t
*
data
)
{
delete
[
]
data
;
}
void
WebrtcGmpVideoDecoder
:
:
Decoded
(
GMPVideoi420Frame
*
aDecodedFrame
)
{
CheckedInt32
length
=
(
CheckedInt32
(
aDecodedFrame
-
>
Stride
(
kGMPYPlane
)
)
*
aDecodedFrame
-
>
Height
(
)
)
+
(
aDecodedFrame
-
>
Stride
(
kGMPVPlane
)
+
aDecodedFrame
-
>
Stride
(
kGMPUPlane
)
)
*
(
(
aDecodedFrame
-
>
Height
(
)
+
1
)
/
2
)
;
int32_t
size
=
length
.
value
(
)
;
MOZ_RELEASE_ASSERT
(
length
.
isValid
(
)
&
&
size
>
0
)
;
auto
buffer
=
MakeUniqueFallible
<
uint8_t
[
]
>
(
size
)
;
if
(
buffer
)
{
uint8_t
*
buffer_y
=
buffer
.
get
(
)
;
memcpy
(
buffer_y
aDecodedFrame
-
>
Buffer
(
kGMPYPlane
)
aDecodedFrame
-
>
Stride
(
kGMPYPlane
)
*
aDecodedFrame
-
>
Height
(
)
)
;
uint8_t
*
buffer_u
=
buffer_y
+
aDecodedFrame
-
>
Stride
(
kGMPYPlane
)
*
aDecodedFrame
-
>
Height
(
)
;
memcpy
(
buffer_u
aDecodedFrame
-
>
Buffer
(
kGMPUPlane
)
aDecodedFrame
-
>
Stride
(
kGMPUPlane
)
*
(
(
aDecodedFrame
-
>
Height
(
)
+
1
)
/
2
)
)
;
uint8_t
*
buffer_v
=
buffer_u
+
aDecodedFrame
-
>
Stride
(
kGMPUPlane
)
*
(
(
aDecodedFrame
-
>
Height
(
)
+
1
)
/
2
)
;
memcpy
(
buffer_v
aDecodedFrame
-
>
Buffer
(
kGMPVPlane
)
aDecodedFrame
-
>
Stride
(
kGMPVPlane
)
*
(
(
aDecodedFrame
-
>
Height
(
)
+
1
)
/
2
)
)
;
MutexAutoLock
lock
(
mCallbackMutex
)
;
if
(
mCallback
)
{
rtc
:
:
scoped_refptr
<
webrtc
:
:
I420BufferInterface
>
video_frame_buffer
=
webrtc
:
:
WrapI420Buffer
(
aDecodedFrame
-
>
Width
(
)
aDecodedFrame
-
>
Height
(
)
buffer_y
aDecodedFrame
-
>
Stride
(
kGMPYPlane
)
buffer_u
aDecodedFrame
-
>
Stride
(
kGMPUPlane
)
buffer_v
aDecodedFrame
-
>
Stride
(
kGMPVPlane
)
[
&
buffer
]
{
DeleteBuffer
(
buffer
.
get
(
)
)
;
}
)
;
GMP_LOG_DEBUG
(
"
GMP
Decoded
:
%
"
PRIu64
aDecodedFrame
-
>
Timestamp
(
)
)
;
auto
videoFrame
=
webrtc
:
:
VideoFrame
:
:
Builder
(
)
.
set_video_frame_buffer
(
video_frame_buffer
)
.
set_timestamp_rtp
(
(
aDecodedFrame
-
>
Timestamp
(
)
*
90ll
+
999
)
/
1000
)
.
build
(
)
;
mCallback
-
>
Decoded
(
videoFrame
)
;
}
}
aDecodedFrame
-
>
Destroy
(
)
;
}
}
