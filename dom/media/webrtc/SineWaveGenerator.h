#
ifndef
SINEWAVEGENERATOR_H_
#
define
SINEWAVEGENERATOR_H_
#
include
"
MediaSegment
.
h
"
namespace
mozilla
{
template
<
typename
Sample
>
class
SineWaveGenerator
{
static_assert
(
std
:
:
is_same
<
Sample
int16_t
>
:
:
value
|
|
std
:
:
is_same
<
Sample
float
>
:
:
value
)
;
public
:
static
const
int
bytesPerSample
=
sizeof
(
Sample
)
;
static
const
int
millisecondsPerSecond
=
PR_MSEC_PER_SEC
;
SineWaveGenerator
(
uint32_t
aSampleRate
uint32_t
aFrequency
uint32_t
aChannels
=
1
)
:
mTotalLength
(
aSampleRate
*
aChannels
/
aFrequency
)
mReadLength
(
0
)
{
MOZ_ASSERT
(
aChannels
>
=
1
)
;
mAudioBuffer
=
MakeUnique
<
Sample
[
]
>
(
mTotalLength
)
;
for
(
uint32_t
i
=
0
;
i
<
aSampleRate
/
aFrequency
;
+
+
i
)
{
for
(
uint32_t
j
=
0
;
j
<
aChannels
;
+
+
j
)
{
mAudioBuffer
[
i
*
aChannels
+
j
]
=
Amplitude
(
)
*
sin
(
2
*
M_PI
*
i
*
aChannels
/
mTotalLength
)
;
}
}
}
void
generate
(
Sample
*
aBuffer
TrackTicks
aLengthInSamples
)
{
TrackTicks
remaining
=
aLengthInSamples
;
while
(
remaining
)
{
TrackTicks
processSamples
=
0
;
if
(
mTotalLength
-
mReadLength
>
=
remaining
)
{
processSamples
=
remaining
;
}
else
{
processSamples
=
mTotalLength
-
mReadLength
;
}
memcpy
(
aBuffer
&
mAudioBuffer
[
mReadLength
]
processSamples
*
bytesPerSample
)
;
aBuffer
+
=
processSamples
;
mReadLength
+
=
processSamples
;
remaining
-
=
processSamples
;
if
(
mReadLength
=
=
mTotalLength
)
{
mReadLength
=
0
;
}
}
}
void
SetOffset
(
TrackTicks
aFrames
)
{
mReadLength
=
aFrames
%
mTotalLength
;
}
TrackTicks
Offset
(
)
const
{
return
mReadLength
;
}
static
float
Amplitude
(
)
{
if
(
std
:
:
is_same
<
Sample
int16_t
>
:
:
value
)
{
return
3276
.
8
;
}
return
0
.
1f
;
}
private
:
UniquePtr
<
Sample
[
]
>
mAudioBuffer
;
TrackTicks
mTotalLength
;
TrackTicks
mReadLength
;
}
;
}
#
endif
