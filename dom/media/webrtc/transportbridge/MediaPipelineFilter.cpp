#
include
"
MediaPipelineFilter
.
h
"
#
include
"
api
/
rtp_headers
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
extern
mozilla
:
:
LazyLogModule
gMediaPipelineLog
;
#
define
DEBUG_LOG
(
x
)
MOZ_LOG
(
gMediaPipelineLog
LogLevel
:
:
Debug
x
)
namespace
mozilla
{
MediaPipelineFilter
:
:
MediaPipelineFilter
(
const
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
&
aExtMap
)
:
mExtMap
(
aExtMap
)
{
}
void
MediaPipelineFilter
:
:
SetRemoteMediaStreamId
(
const
Maybe
<
std
:
:
string
>
&
aMid
)
{
if
(
aMid
!
=
mRemoteMid
)
{
DEBUG_LOG
(
(
"
MediaPipelineFilter
added
new
remote
RTP
MID
:
'
%
s
'
.
"
aMid
.
valueOr
(
"
"
)
.
c_str
(
)
)
)
;
mRemoteMid
=
aMid
;
mRemoteMidBindings
.
clear
(
)
;
}
}
bool
MediaPipelineFilter
:
:
Filter
(
const
webrtc
:
:
RTPHeader
&
header
)
{
DEBUG_LOG
(
(
"
MediaPipelineFilter
inspecting
seq
#
%
u
SSRC
:
%
u
"
header
.
sequenceNumber
header
.
ssrc
)
)
;
auto
fromStreamId
=
[
]
(
const
std
:
:
string
&
aId
)
{
return
Maybe
<
std
:
:
string
>
(
aId
.
empty
(
)
?
Nothing
(
)
:
Some
(
aId
)
)
;
}
;
const
auto
mid
=
fromStreamId
(
header
.
extension
.
mid
)
;
if
(
mRemoteMidBindings
.
count
(
header
.
ssrc
)
=
=
1
&
&
mid
&
&
mRemoteMid
!
=
mid
)
{
mRemoteMidBindings
.
erase
(
header
.
ssrc
)
;
}
if
(
mid
&
&
mRemoteMid
=
=
mid
)
{
DEBUG_LOG
(
(
"
MediaPipelineFilter
learned
SSRC
:
%
u
for
MID
:
'
%
s
'
"
header
.
ssrc
mRemoteMid
.
value
(
)
.
c_str
(
)
)
)
;
mRemoteMidBindings
.
insert
(
header
.
ssrc
)
;
}
if
(
!
mRemoteMidBindings
.
empty
(
)
)
{
MOZ_ASSERT
(
mRemoteMid
!
=
Nothing
(
)
)
;
if
(
mRemoteMidBindings
.
count
(
header
.
ssrc
)
=
=
1
)
{
DEBUG_LOG
(
(
"
MediaPipelineFilter
SSRC
:
%
u
matched
for
MID
:
'
%
s
'
.
"
"
passing
packet
"
header
.
ssrc
mRemoteMid
.
value
(
)
.
c_str
(
)
)
)
;
return
true
;
}
DEBUG_LOG
(
(
"
MediaPipelineFilter
SSRC
:
%
u
did
not
match
bound
SSRC
(
s
)
for
"
"
MID
:
'
%
s
'
.
ignoring
packet
"
header
.
ssrc
mRemoteMid
.
value
(
)
.
c_str
(
)
)
)
;
for
(
const
uint32_t
ssrc
:
mRemoteMidBindings
)
{
DEBUG_LOG
(
(
"
MID
%
s
is
associated
with
SSRC
:
%
u
"
mRemoteMid
.
value
(
)
.
c_str
(
)
ssrc
)
)
;
}
return
false
;
}
if
(
remote_ssrc_set_
.
count
(
header
.
ssrc
)
)
{
DEBUG_LOG
(
(
"
MediaPipelineFilter
SSRC
:
%
u
matched
remote
SSRC
set
.
"
"
passing
packet
"
header
.
ssrc
)
)
;
return
true
;
}
DEBUG_LOG
(
(
"
MediaPipelineFilter
SSRC
:
%
u
did
not
match
any
of
%
zu
"
"
remote
SSRCS
.
"
header
.
ssrc
remote_ssrc_set_
.
size
(
)
)
)
;
if
(
receive_payload_type_set_
.
count
(
header
.
payloadType
)
)
{
DEBUG_LOG
(
(
"
MediaPipelineFilter
payload
-
type
:
%
u
matched
%
zu
"
"
unique
payload
type
.
learning
ssrc
.
passing
packet
"
header
.
ssrc
remote_ssrc_set_
.
size
(
)
)
)
;
AddRemoteSSRC
(
header
.
ssrc
)
;
return
true
;
}
DEBUG_LOG
(
(
"
MediaPipelineFilter
payload
-
type
:
%
u
did
not
match
any
of
%
zu
"
"
unique
payload
-
types
.
"
header
.
payloadType
receive_payload_type_set_
.
size
(
)
)
)
;
DEBUG_LOG
(
(
"
MediaPipelineFilter
packet
failed
to
match
any
criteria
.
"
"
ignoring
packet
"
)
)
;
return
false
;
}
void
MediaPipelineFilter
:
:
AddRemoteSSRC
(
uint32_t
ssrc
)
{
remote_ssrc_set_
.
insert
(
ssrc
)
;
}
void
MediaPipelineFilter
:
:
AddUniqueReceivePT
(
uint8_t
payload_type
)
{
receive_payload_type_set_
.
insert
(
payload_type
)
;
}
void
MediaPipelineFilter
:
:
AddDuplicateReceivePT
(
uint8_t
payload_type
)
{
duplicate_payload_type_set_
.
insert
(
payload_type
)
;
}
void
MediaPipelineFilter
:
:
Update
(
const
MediaPipelineFilter
&
filter_update
bool
signalingStable
)
{
if
(
!
filter_update
.
remote_ssrc_set_
.
empty
(
)
)
{
remote_ssrc_set_
=
filter_update
.
remote_ssrc_set_
;
}
if
(
!
filter_update
.
mRemoteMidBindings
.
empty
(
)
|
|
(
filter_update
.
mRemoteMid
&
&
filter_update
.
mRemoteMid
!
=
mRemoteMid
)
)
{
mRemoteMid
=
filter_update
.
mRemoteMid
;
mRemoteMidBindings
=
filter_update
.
mRemoteMidBindings
;
}
if
(
signalingStable
)
{
receive_payload_type_set_
=
filter_update
.
receive_payload_type_set_
;
duplicate_payload_type_set_
=
filter_update
.
duplicate_payload_type_set_
;
}
else
{
for
(
const
auto
&
uniquePT
:
filter_update
.
receive_payload_type_set_
)
{
if
(
!
receive_payload_type_set_
.
count
(
uniquePT
)
&
&
!
duplicate_payload_type_set_
.
count
(
uniquePT
)
)
{
AddUniqueReceivePT
(
uniquePT
)
;
}
}
}
mExtMap
=
filter_update
.
mExtMap
;
}
}
