#
ifndef
mediapipeline_h__
#
define
mediapipeline_h__
#
include
<
map
>
#
include
"
transport
/
sigslot
.
h
"
#
include
"
transport
/
transportlayer
.
h
"
#
include
"
libwebrtcglue
/
MediaConduitInterface
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
transport
/
SrtpFlow
.
h
"
#
include
"
transport
/
mediapacket
.
h
"
#
include
"
transport
/
runnable_utils
.
h
"
#
include
"
AudioPacketizer
.
h
"
#
include
"
MediaPipelineFilter
.
h
"
#
include
"
MediaSegment
.
h
"
#
include
"
jsapi
/
PacketDumper
.
h
"
#
include
"
test
/
rtp_header_parser
.
h
"
#
define
WEBRTC_MAX_SAMPLE_RATE
48000
class
nsIPrincipal
;
namespace
mozilla
{
class
AudioProxyThread
;
class
MediaInputPort
;
class
MediaPipelineFilter
;
class
MediaTransportHandler
;
class
PeerIdentity
;
class
ProcessedMediaTrack
;
class
SourceMediaTrack
;
class
VideoFrameConverter
;
namespace
dom
{
class
MediaStreamTrack
;
struct
RTCRTPContributingSourceStats
;
}
class
MediaPipeline
:
public
sigslot
:
:
has_slots
<
>
{
public
:
enum
class
DirectionType
{
TRANSMIT
RECEIVE
}
;
MediaPipeline
(
const
std
:
:
string
&
aPc
RefPtr
<
MediaTransportHandler
>
aTransportHandler
DirectionType
aDirection
RefPtr
<
nsISerialEventTarget
>
aMainThread
RefPtr
<
AbstractThread
>
aCallThread
RefPtr
<
nsISerialEventTarget
>
aStsThread
RefPtr
<
MediaSessionConduit
>
aConduit
)
;
void
Start
(
)
;
void
Stop
(
)
;
void
SetLevel
(
size_t
aLevel
)
{
mLevel
=
aLevel
;
}
virtual
void
Shutdown
(
)
;
void
UpdateTransport_m
(
const
std
:
:
string
&
aTransportId
UniquePtr
<
MediaPipelineFilter
>
&
&
aFilter
)
;
void
UpdateTransport_s
(
const
std
:
:
string
&
aTransportId
UniquePtr
<
MediaPipelineFilter
>
&
&
aFilter
)
;
virtual
DirectionType
Direction
(
)
const
{
return
mDirection
;
}
size_t
Level
(
)
const
{
return
mLevel
;
}
virtual
bool
IsVideo
(
)
const
=
0
;
class
RtpCSRCStats
{
public
:
static
DOMHighResTimeStamp
GetExpiryFromTime
(
const
DOMHighResTimeStamp
aTime
)
;
RtpCSRCStats
(
const
uint32_t
aCsrc
const
DOMHighResTimeStamp
aTime
)
;
~
RtpCSRCStats
(
)
=
default
;
void
GetWebidlInstance
(
dom
:
:
RTCRTPContributingSourceStats
&
aWebidlObj
const
nsString
&
aInboundRtpStreamId
)
const
;
void
SetTimestamp
(
const
DOMHighResTimeStamp
aTime
)
{
mTimestamp
=
aTime
;
}
bool
Expired
(
const
DOMHighResTimeStamp
aExpiry
)
const
{
return
mTimestamp
<
aExpiry
;
}
private
:
static
const
double
constexpr
EXPIRY_TIME_MILLISECONDS
=
10
*
1000
;
const
uint32_t
mCsrc
;
DOMHighResTimeStamp
mTimestamp
;
}
;
void
GetContributingSourceStats
(
const
nsString
&
aInboundRtpStreamId
FallibleTArray
<
dom
:
:
RTCRTPContributingSourceStats
>
&
aArr
)
const
;
int32_t
RtpPacketsSent
(
)
const
{
return
mRtpPacketsSent
;
}
int64_t
RtpBytesSent
(
)
const
{
return
mRtpBytesSent
;
}
int32_t
RtcpPacketsSent
(
)
const
{
return
mRtcpPacketsSent
;
}
int32_t
RtpPacketsReceived
(
)
const
{
return
mRtpPacketsReceived
;
}
int64_t
RtpBytesReceived
(
)
const
{
return
mRtpBytesReceived
;
}
int32_t
RtcpPacketsReceived
(
)
const
{
return
mRtcpPacketsReceived
;
}
Maybe
<
uint32_t
>
RtpSendBaseSeq
(
)
const
{
return
mRtpSendBaseSeq
;
}
DOMHighResTimeStamp
GetNow
(
)
const
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaPipeline
)
class
PipelineTransport
:
public
TransportInterface
{
public
:
explicit
PipelineTransport
(
RefPtr
<
nsISerialEventTarget
>
aStsThread
)
:
mPipeline
(
nullptr
)
mStsThread
(
std
:
:
move
(
aStsThread
)
)
{
}
void
Attach
(
MediaPipeline
*
pipeline
)
{
mPipeline
=
pipeline
;
}
void
Detach
(
)
{
mPipeline
=
nullptr
;
}
MediaPipeline
*
Pipeline
(
)
const
{
return
mPipeline
;
}
virtual
nsresult
SendRtpPacket
(
const
uint8_t
*
aData
size_t
aLen
)
override
;
virtual
nsresult
SendRtcpPacket
(
const
uint8_t
*
aData
size_t
aLen
)
override
;
private
:
void
SendRtpRtcpPacket_s
(
MediaPacket
&
&
aPacket
)
;
RefPtr
<
MediaPipeline
>
mPipeline
;
const
RefPtr
<
nsISerialEventTarget
>
mStsThread
;
}
;
protected
:
virtual
~
MediaPipeline
(
)
;
friend
class
PipelineTransport
;
virtual
void
TransportReady_s
(
)
{
}
void
IncrementRtpPacketsSent
(
const
MediaPacket
&
aPacket
)
;
void
IncrementRtcpPacketsSent
(
)
;
void
IncrementRtpPacketsReceived
(
int
aBytes
)
;
virtual
void
OnRtpPacketReceived
(
)
{
}
void
IncrementRtcpPacketsReceived
(
)
;
virtual
void
SendPacket
(
MediaPacket
&
&
packet
)
;
void
RtpStateChange
(
const
std
:
:
string
&
aTransportId
TransportLayer
:
:
State
)
;
void
RtcpStateChange
(
const
std
:
:
string
&
aTransportId
TransportLayer
:
:
State
)
;
virtual
void
CheckTransportStates
(
)
;
void
PacketReceived
(
const
std
:
:
string
&
aTransportId
const
MediaPacket
&
packet
)
;
void
AlpnNegotiated
(
const
std
:
:
string
&
aAlpn
bool
aPrivacyRequested
)
;
void
RtpPacketReceived
(
const
MediaPacket
&
packet
)
;
void
RtcpPacketReceived
(
const
MediaPacket
&
packet
)
;
void
EncryptedPacketSending
(
const
std
:
:
string
&
aTransportId
const
MediaPacket
&
aPacket
)
;
void
SetDescription_s
(
const
std
:
:
string
&
description
)
;
virtual
void
MakePrincipalPrivate_s
(
)
{
}
public
:
const
RefPtr
<
MediaSessionConduit
>
mConduit
;
const
DirectionType
mDirection
;
const
RefPtr
<
nsISerialEventTarget
>
mMainThread
;
const
RefPtr
<
AbstractThread
>
mCallThread
;
const
RefPtr
<
nsISerialEventTarget
>
mStsThread
;
protected
:
Watchable
<
bool
>
mActive
;
Atomic
<
size_t
>
mLevel
;
std
:
:
string
mTransportId
;
const
RefPtr
<
MediaTransportHandler
>
mTransportHandler
;
TransportLayer
:
:
State
mRtpState
=
TransportLayer
:
:
TS_NONE
;
TransportLayer
:
:
State
mRtcpState
=
TransportLayer
:
:
TS_NONE
;
bool
mSignalsConnected
=
false
;
const
RefPtr
<
PipelineTransport
>
mTransport
;
int32_t
mRtpPacketsSent
;
int32_t
mRtcpPacketsSent
;
int32_t
mRtpPacketsReceived
;
int32_t
mRtcpPacketsReceived
;
int64_t
mRtpBytesSent
;
int64_t
mRtpBytesReceived
;
Maybe
<
uint32_t
>
mRtpSendBaseSeq
;
std
:
:
map
<
uint32_t
RtpCSRCStats
>
mCsrcStats
;
const
std
:
:
string
mPc
;
std
:
:
string
mDescription
;
UniquePtr
<
MediaPipelineFilter
>
mFilter
;
const
UniquePtr
<
webrtc
:
:
RtpHeaderParser
>
mRtpParser
;
UniquePtr
<
PacketDumper
>
mPacketDumper
;
private
:
bool
IsRtp
(
const
unsigned
char
*
aData
size_t
aLen
)
const
;
void
DetachTransport_s
(
)
;
}
;
class
MediaPipelineTransmit
:
public
MediaPipeline
{
public
:
MediaPipelineTransmit
(
const
std
:
:
string
&
aPc
RefPtr
<
MediaTransportHandler
>
aTransportHandler
RefPtr
<
nsISerialEventTarget
>
aMainThread
RefPtr
<
AbstractThread
>
aCallThread
RefPtr
<
nsISerialEventTarget
>
aStsThread
bool
aIsVideo
RefPtr
<
MediaSessionConduit
>
aConduit
)
;
void
Shutdown
(
)
override
;
bool
Transmitting
(
)
const
;
bool
IsVideo
(
)
const
override
;
virtual
void
UpdateSinkIdentity_m
(
const
dom
:
:
MediaStreamTrack
*
aTrack
nsIPrincipal
*
aPrincipal
const
PeerIdentity
*
aSinkIdentity
)
;
void
TransportReady_s
(
)
override
;
nsresult
SetTrack
(
RefPtr
<
dom
:
:
MediaStreamTrack
>
aDomTrack
)
;
RefPtr
<
dom
:
:
MediaStreamTrack
>
GetTrack
(
)
const
;
void
SetSendTrackOverride
(
RefPtr
<
ProcessedMediaTrack
>
aSendTrack
)
;
class
PipelineListener
;
class
VideoFrameFeeder
;
protected
:
~
MediaPipelineTransmit
(
)
;
std
:
:
string
GenerateDescription
(
)
const
;
void
UpdateSendState
(
)
;
private
:
WatchManager
<
MediaPipelineTransmit
>
mWatchManager
;
const
bool
mIsVideo
;
const
RefPtr
<
PipelineListener
>
mListener
;
const
RefPtr
<
VideoFrameFeeder
>
mFeeder
;
RefPtr
<
AudioProxyThread
>
mAudioProcessing
;
RefPtr
<
VideoFrameConverter
>
mConverter
;
Watchable
<
RefPtr
<
dom
:
:
MediaStreamTrack
>
>
mDomTrack
;
RefPtr
<
MediaInputPort
>
mSendPort
;
bool
mDescriptionInvalidated
=
true
;
bool
mUnsettingSendTrack
=
false
;
RefPtr
<
ProcessedMediaTrack
>
mSendTrack
;
Watchable
<
RefPtr
<
ProcessedMediaTrack
>
>
mSendTrackOverride
;
bool
mTransmitting
=
false
;
}
;
class
MediaPipelineReceive
:
public
MediaPipeline
{
public
:
MediaPipelineReceive
(
const
std
:
:
string
&
aPc
RefPtr
<
MediaTransportHandler
>
aTransportHandler
RefPtr
<
nsISerialEventTarget
>
aMainThread
RefPtr
<
AbstractThread
>
aCallThread
RefPtr
<
nsISerialEventTarget
>
aStsThread
RefPtr
<
MediaSessionConduit
>
aConduit
)
;
protected
:
~
MediaPipelineReceive
(
)
;
}
;
class
MediaPipelineReceiveAudio
:
public
MediaPipelineReceive
{
public
:
MediaPipelineReceiveAudio
(
const
std
:
:
string
&
aPc
RefPtr
<
MediaTransportHandler
>
aTransportHandler
RefPtr
<
nsISerialEventTarget
>
aMainThread
RefPtr
<
AbstractThread
>
aCallThread
RefPtr
<
nsISerialEventTarget
>
aStsThread
RefPtr
<
AudioSessionConduit
>
aConduit
const
RefPtr
<
dom
:
:
MediaStreamTrack
>
&
aTrack
const
PrincipalHandle
&
aPrincipalHandle
)
;
void
Shutdown
(
)
override
;
bool
IsVideo
(
)
const
override
{
return
false
;
}
void
MakePrincipalPrivate_s
(
)
override
;
void
OnRtpPacketReceived
(
)
override
;
private
:
void
UpdateListener
(
)
;
class
PipelineListener
;
const
RefPtr
<
PipelineListener
>
mListener
;
WatchManager
<
MediaPipelineReceiveAudio
>
mWatchManager
;
}
;
class
MediaPipelineReceiveVideo
:
public
MediaPipelineReceive
{
public
:
MediaPipelineReceiveVideo
(
const
std
:
:
string
&
aPc
RefPtr
<
MediaTransportHandler
>
aTransportHandler
RefPtr
<
nsISerialEventTarget
>
aMainThread
RefPtr
<
AbstractThread
>
aCallThread
RefPtr
<
nsISerialEventTarget
>
aStsThread
RefPtr
<
VideoSessionConduit
>
aConduit
const
RefPtr
<
dom
:
:
MediaStreamTrack
>
&
aTrack
const
PrincipalHandle
&
aPrincipalHandle
)
;
void
Shutdown
(
)
override
;
bool
IsVideo
(
)
const
override
{
return
true
;
}
void
MakePrincipalPrivate_s
(
)
override
;
void
OnRtpPacketReceived
(
)
override
;
void
OnFrameDelivered
(
)
;
private
:
void
UpdateListener
(
)
;
class
PipelineRenderer
;
friend
class
PipelineRenderer
;
class
PipelineListener
;
const
RefPtr
<
PipelineRenderer
>
mRenderer
;
const
RefPtr
<
PipelineListener
>
mListener
;
WatchManager
<
MediaPipelineReceiveVideo
>
mWatchManager
;
}
;
}
#
endif
