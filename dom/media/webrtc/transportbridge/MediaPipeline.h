#
ifndef
mediapipeline_h__
#
define
mediapipeline_h__
#
include
<
map
>
#
include
"
transport
/
sigslot
.
h
"
#
include
"
transport
/
transportlayer
.
h
"
#
include
"
libwebrtcglue
/
MediaConduitControl
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
transport
/
mediapacket
.
h
"
#
include
"
transport
/
runnable_utils
.
h
"
#
include
"
AudioPacketizer
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaPipelineFilter
.
h
"
#
include
"
MediaSegment
.
h
"
#
include
"
PrincipalChangeObserver
.
h
"
#
include
"
jsapi
/
PacketDumper
.
h
"
#
include
"
PerformanceRecorder
.
h
"
#
define
WEBRTC_MAX_SAMPLE_RATE
48000
class
nsIPrincipal
;
namespace
webrtc
{
struct
RTPHeader
;
class
RtpHeaderExtensionMap
;
class
RtpPacketReceived
;
}
namespace
mozilla
{
class
AudioProxyThread
;
class
MediaInputPort
;
class
MediaPipelineFilter
;
class
MediaTransportHandler
;
class
PeerIdentity
;
class
ProcessedMediaTrack
;
class
SourceMediaTrack
;
class
VideoFrameConverter
;
class
MediaSessionConduit
;
class
AudioSessionConduit
;
class
VideoSessionConduit
;
namespace
dom
{
class
MediaStreamTrack
;
struct
RTCRTPContributingSourceStats
;
class
RTCStatsTimestampMaker
;
}
struct
MediaPipelineReceiveControlInterface
{
virtual
Canonical
<
bool
>
&
CanonicalReceiving
(
)
=
0
;
}
;
struct
MediaPipelineTransmitControlInterface
{
virtual
Canonical
<
bool
>
&
CanonicalTransmitting
(
)
=
0
;
}
;
class
MediaPipeline
:
public
sigslot
:
:
has_slots
<
>
{
public
:
enum
class
DirectionType
{
TRANSMIT
RECEIVE
}
;
MediaPipeline
(
const
std
:
:
string
&
aPc
RefPtr
<
MediaTransportHandler
>
aTransportHandler
DirectionType
aDirection
RefPtr
<
AbstractThread
>
aCallThread
RefPtr
<
nsISerialEventTarget
>
aStsThread
RefPtr
<
MediaSessionConduit
>
aConduit
)
;
void
SetLevel
(
size_t
aLevel
)
{
mLevel
=
aLevel
;
}
virtual
void
Shutdown
(
)
;
void
UpdateTransport_m
(
const
std
:
:
string
&
aTransportId
UniquePtr
<
MediaPipelineFilter
>
&
&
aFilter
)
;
void
UpdateTransport_s
(
const
std
:
:
string
&
aTransportId
UniquePtr
<
MediaPipelineFilter
>
&
&
aFilter
)
;
virtual
DirectionType
Direction
(
)
const
{
return
mDirection
;
}
size_t
Level
(
)
const
{
return
mLevel
;
}
virtual
bool
IsVideo
(
)
const
=
0
;
class
RtpCSRCStats
{
public
:
static
DOMHighResTimeStamp
GetExpiryFromTime
(
const
DOMHighResTimeStamp
aTime
)
;
RtpCSRCStats
(
const
uint32_t
aCsrc
const
DOMHighResTimeStamp
aTime
)
;
~
RtpCSRCStats
(
)
=
default
;
void
GetWebidlInstance
(
dom
:
:
RTCRTPContributingSourceStats
&
aWebidlObj
const
nsString
&
aInboundRtpStreamId
)
const
;
void
SetTimestamp
(
const
DOMHighResTimeStamp
aTime
)
{
mTimestamp
=
aTime
;
}
bool
Expired
(
const
DOMHighResTimeStamp
aExpiry
)
const
{
return
mTimestamp
<
aExpiry
;
}
private
:
static
const
double
constexpr
EXPIRY_TIME_MILLISECONDS
=
10
*
1000
;
const
uint32_t
mCsrc
;
DOMHighResTimeStamp
mTimestamp
;
}
;
void
GetContributingSourceStats
(
const
nsString
&
aInboundRtpStreamId
FallibleTArray
<
dom
:
:
RTCRTPContributingSourceStats
>
&
aArr
)
const
;
int32_t
RtpPacketsSent
(
)
const
{
return
mRtpPacketsSent
;
}
int64_t
RtpBytesSent
(
)
const
{
return
mRtpBytesSent
;
}
int32_t
RtcpPacketsSent
(
)
const
{
return
mRtcpPacketsSent
;
}
int32_t
RtpPacketsReceived
(
)
const
{
return
mRtpPacketsReceived
;
}
int64_t
RtpBytesReceived
(
)
const
{
return
mRtpBytesReceived
;
}
const
dom
:
:
RTCStatsTimestampMaker
&
GetTimestampMaker
(
)
const
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaPipeline
)
protected
:
virtual
~
MediaPipeline
(
)
;
virtual
void
TransportReady_s
(
)
{
}
void
IncrementRtpPacketsSent
(
const
MediaPacket
&
aPacket
)
;
void
IncrementRtcpPacketsSent
(
)
;
void
IncrementRtpPacketsReceived
(
int
aBytes
)
;
virtual
void
SendPacket
(
MediaPacket
&
&
packet
)
;
void
RtpStateChange
(
const
std
:
:
string
&
aTransportId
TransportLayer
:
:
State
)
;
void
RtcpStateChange
(
const
std
:
:
string
&
aTransportId
TransportLayer
:
:
State
)
;
virtual
void
CheckTransportStates
(
)
;
void
PacketReceived
(
const
std
:
:
string
&
aTransportId
const
MediaPacket
&
packet
)
;
void
AlpnNegotiated
(
const
std
:
:
string
&
aAlpn
bool
aPrivacyRequested
)
;
void
EncryptedPacketSending
(
const
std
:
:
string
&
aTransportId
const
MediaPacket
&
aPacket
)
;
void
SetDescription_s
(
const
std
:
:
string
&
description
)
;
public
:
const
RefPtr
<
MediaSessionConduit
>
mConduit
;
const
DirectionType
mDirection
;
const
RefPtr
<
AbstractThread
>
mCallThread
;
const
RefPtr
<
nsISerialEventTarget
>
mStsThread
;
protected
:
Mirror
<
bool
>
mActive
;
Atomic
<
size_t
>
mLevel
;
std
:
:
string
mTransportId
;
const
RefPtr
<
MediaTransportHandler
>
mTransportHandler
;
TransportLayer
:
:
State
mRtpState
=
TransportLayer
:
:
TS_NONE
;
TransportLayer
:
:
State
mRtcpState
=
TransportLayer
:
:
TS_NONE
;
bool
mSignalsConnected
=
false
;
int32_t
mRtpPacketsSent
;
int32_t
mRtcpPacketsSent
;
int32_t
mRtpPacketsReceived
;
int64_t
mRtpBytesSent
;
int64_t
mRtpBytesReceived
;
std
:
:
map
<
uint32_t
RtpCSRCStats
>
mCsrcStats
;
const
std
:
:
string
mPc
;
std
:
:
string
mDescription
;
UniquePtr
<
MediaPipelineFilter
>
mFilter
;
const
UniquePtr
<
webrtc
:
:
RtpHeaderExtensionMap
>
mRtpHeaderExtensionMap
;
RefPtr
<
PacketDumper
>
mPacketDumper
;
MediaEventProducerExc
<
webrtc
:
:
RtpPacketReceived
webrtc
:
:
RTPHeader
>
mRtpReceiveEvent
;
MediaEventListener
mRtpSendEventListener
;
MediaEventListener
mSenderRtcpSendEventListener
;
MediaEventListener
mReceiverRtcpSendEventListener
;
private
:
bool
IsRtp
(
const
unsigned
char
*
aData
size_t
aLen
)
const
;
void
DetachTransport_s
(
)
;
}
;
class
MediaPipelineTransmit
:
public
MediaPipeline
public
dom
:
:
PrincipalChangeObserver
<
dom
:
:
MediaStreamTrack
>
{
private
:
MediaPipelineTransmit
(
const
std
:
:
string
&
aPc
RefPtr
<
MediaTransportHandler
>
aTransportHandler
RefPtr
<
AbstractThread
>
aCallThread
RefPtr
<
nsISerialEventTarget
>
aStsThread
bool
aIsVideo
RefPtr
<
MediaSessionConduit
>
aConduit
)
;
void
RegisterListener
(
)
;
public
:
static
already_AddRefed
<
MediaPipelineTransmit
>
Create
(
const
std
:
:
string
&
aPc
RefPtr
<
MediaTransportHandler
>
aTransportHandler
RefPtr
<
AbstractThread
>
aCallThread
RefPtr
<
nsISerialEventTarget
>
aStsThread
bool
aIsVideo
RefPtr
<
MediaSessionConduit
>
aConduit
)
;
void
InitControl
(
MediaPipelineTransmitControlInterface
*
aControl
)
;
void
Shutdown
(
)
override
;
bool
Transmitting
(
)
const
;
bool
IsVideo
(
)
const
override
;
virtual
void
UpdateSinkIdentity
(
nsIPrincipal
*
aPrincipal
const
PeerIdentity
*
aSinkIdentity
)
;
void
PrincipalChanged
(
dom
:
:
MediaStreamTrack
*
aTrack
)
override
;
void
TransportReady_s
(
)
override
;
nsresult
SetTrack
(
const
RefPtr
<
dom
:
:
MediaStreamTrack
>
&
aDomTrack
)
;
RefPtr
<
dom
:
:
MediaStreamTrack
>
GetTrack
(
)
const
;
void
SetSendTrackOverride
(
const
RefPtr
<
ProcessedMediaTrack
>
&
aSendTrack
)
;
class
PipelineListener
;
class
VideoFrameFeeder
;
protected
:
~
MediaPipelineTransmit
(
)
;
std
:
:
string
GenerateDescription
(
)
const
;
void
UpdateSendState
(
)
;
private
:
WatchManager
<
MediaPipelineTransmit
>
mWatchManager
;
const
bool
mIsVideo
;
const
RefPtr
<
PipelineListener
>
mListener
;
RefPtr
<
AudioProxyThread
>
mAudioProcessing
;
RefPtr
<
VideoFrameConverter
>
mConverter
;
MediaEventListener
mFrameListener
;
Watchable
<
RefPtr
<
dom
:
:
MediaStreamTrack
>
>
mDomTrack
;
RefPtr
<
MediaInputPort
>
mSendPort
;
RefPtr
<
ProcessedMediaTrack
>
mSendPortSource
;
bool
mDescriptionInvalidated
=
true
;
bool
mUnsettingSendTrack
=
false
;
RefPtr
<
ProcessedMediaTrack
>
mSendTrack
;
Watchable
<
RefPtr
<
ProcessedMediaTrack
>
>
mSendTrackOverride
;
bool
mTransmitting
=
false
;
}
;
class
MediaPipelineReceive
:
public
MediaPipeline
{
public
:
MediaPipelineReceive
(
const
std
:
:
string
&
aPc
RefPtr
<
MediaTransportHandler
>
aTransportHandler
RefPtr
<
AbstractThread
>
aCallThread
RefPtr
<
nsISerialEventTarget
>
aStsThread
RefPtr
<
MediaSessionConduit
>
aConduit
)
;
void
InitControl
(
MediaPipelineReceiveControlInterface
*
aControl
)
;
virtual
void
OnPrivacyRequested_s
(
)
=
0
;
virtual
void
SetPrivatePrincipal
(
PrincipalHandle
aHandle
)
=
0
;
void
Shutdown
(
)
override
;
protected
:
~
MediaPipelineReceive
(
)
;
virtual
void
UpdateListener
(
)
=
0
;
private
:
WatchManager
<
MediaPipelineReceive
>
mWatchManager
;
}
;
class
MediaPipelineReceiveAudio
:
public
MediaPipelineReceive
{
public
:
MediaPipelineReceiveAudio
(
const
std
:
:
string
&
aPc
RefPtr
<
MediaTransportHandler
>
aTransportHandler
RefPtr
<
AbstractThread
>
aCallThread
RefPtr
<
nsISerialEventTarget
>
aStsThread
RefPtr
<
AudioSessionConduit
>
aConduit
RefPtr
<
SourceMediaTrack
>
aSource
TrackingId
aTrackingId
PrincipalHandle
aPrincipalHandle
PrincipalPrivacy
aPrivacy
)
;
void
Shutdown
(
)
override
;
bool
IsVideo
(
)
const
override
{
return
false
;
}
void
OnPrivacyRequested_s
(
)
override
;
void
SetPrivatePrincipal
(
PrincipalHandle
aHandle
)
override
;
private
:
void
UpdateListener
(
)
override
;
class
PipelineListener
;
const
RefPtr
<
PipelineListener
>
mListener
;
}
;
class
MediaPipelineReceiveVideo
:
public
MediaPipelineReceive
{
public
:
MediaPipelineReceiveVideo
(
const
std
:
:
string
&
aPc
RefPtr
<
MediaTransportHandler
>
aTransportHandler
RefPtr
<
AbstractThread
>
aCallThread
RefPtr
<
nsISerialEventTarget
>
aStsThread
RefPtr
<
VideoSessionConduit
>
aConduit
RefPtr
<
SourceMediaTrack
>
aSource
TrackingId
aTrackingId
PrincipalHandle
aPrincipalHandle
PrincipalPrivacy
aPrivacy
)
;
void
Shutdown
(
)
override
;
bool
IsVideo
(
)
const
override
{
return
true
;
}
void
OnPrivacyRequested_s
(
)
override
;
void
SetPrivatePrincipal
(
PrincipalHandle
aHandle
)
override
;
private
:
void
UpdateListener
(
)
override
;
class
PipelineRenderer
;
friend
class
PipelineRenderer
;
class
PipelineListener
;
const
RefPtr
<
PipelineRenderer
>
mRenderer
;
const
RefPtr
<
PipelineListener
>
mListener
;
}
;
}
#
endif
