#
ifndef
MEDIAENGINEWEBRTC_H_
#
define
MEDIAENGINEWEBRTC_H_
#
include
"
AudioPacketizer
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
AudioDeviceInfo
.
h
"
#
include
"
CamerasChild
.
h
"
#
include
"
cubeb
/
cubeb
.
h
"
#
include
"
CubebUtils
.
h
"
#
include
"
DOMMediaStream
.
h
"
#
include
"
ipc
/
IPCMessageUtils
.
h
"
#
include
"
MediaEngine
.
h
"
#
include
"
MediaEnginePrefs
.
h
"
#
include
"
MediaEngineSource
.
h
"
#
include
"
MediaEngineWrapper
.
h
"
#
include
"
MediaStreamGraph
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamTrackBinding
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
NullTransport
.
h
"
#
include
"
prcvar
.
h
"
#
include
"
prthread
.
h
"
#
include
"
StreamTracks
.
h
"
#
include
"
VideoSegment
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
webrtc
/
voice_engine
/
include
/
voe_base
.
h
"
#
include
"
webrtc
/
voice_engine
/
include
/
voe_codec
.
h
"
#
include
"
webrtc
/
voice_engine
/
include
/
voe_network
.
h
"
#
include
"
webrtc
/
voice_engine
/
include
/
voe_audio_processing
.
h
"
#
include
"
webrtc
/
voice_engine
/
include
/
voe_volume_control
.
h
"
#
include
"
webrtc
/
voice_engine
/
include
/
voe_external_media
.
h
"
#
include
"
webrtc
/
voice_engine
/
include
/
voe_audio_processing
.
h
"
#
include
"
webrtc
/
modules
/
audio_device
/
include
/
audio_device
.
h
"
#
include
"
webrtc
/
modules
/
audio_processing
/
include
/
audio_processing
.
h
"
#
undef
FF
#
include
"
webrtc
/
modules
/
video_capture
/
video_capture_defines
.
h
"
namespace
mozilla
{
class
MediaEngineWebRTCMicrophoneSource
;
class
MediaEngineWebRTCAudioCaptureSource
:
public
MediaEngineSource
{
public
:
explicit
MediaEngineWebRTCAudioCaptureSource
(
const
char
*
aUuid
)
{
}
nsString
GetName
(
)
const
override
;
nsCString
GetUUID
(
)
const
override
;
nsresult
Allocate
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
const
ipc
:
:
PrincipalInfo
&
aPrincipalInfo
AllocationHandle
*
*
aOutHandle
const
char
*
*
aOutBadConstraint
)
override
{
*
aOutHandle
=
nullptr
;
return
NS_OK
;
}
nsresult
Deallocate
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
)
override
{
MOZ_ASSERT
(
!
aHandle
)
;
return
NS_OK
;
}
nsresult
SetTrack
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
const
RefPtr
<
SourceMediaStream
>
&
aStream
TrackID
aTrackID
const
PrincipalHandle
&
aPrincipal
)
override
;
nsresult
Start
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
)
override
;
nsresult
Stop
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
)
override
;
nsresult
Reconfigure
(
const
RefPtr
<
AllocationHandle
>
&
aHandle
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
const
char
*
*
aOutBadConstraint
)
override
;
void
Pull
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
const
RefPtr
<
SourceMediaStream
>
&
aStream
TrackID
aTrackID
StreamTime
aDesiredTime
const
PrincipalHandle
&
aPrincipalHandle
)
override
{
}
dom
:
:
MediaSourceEnum
GetMediaSource
(
)
const
override
{
return
dom
:
:
MediaSourceEnum
:
:
AudioCapture
;
}
nsresult
TakePhoto
(
MediaEnginePhotoCallback
*
aCallback
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
uint32_t
GetBestFitnessDistance
(
const
nsTArray
<
const
NormalizedConstraintSet
*
>
&
aConstraintSets
const
nsString
&
aDeviceId
)
const
override
;
protected
:
virtual
~
MediaEngineWebRTCAudioCaptureSource
(
)
=
default
;
}
;
class
CubebDeviceEnumerator
final
{
public
:
CubebDeviceEnumerator
(
)
;
~
CubebDeviceEnumerator
(
)
;
void
EnumerateAudioInputDevices
(
nsTArray
<
RefPtr
<
AudioDeviceInfo
>
>
&
aOutDevices
)
;
already_AddRefed
<
AudioDeviceInfo
>
DeviceInfoFromID
(
CubebUtils
:
:
AudioDeviceID
aID
)
;
protected
:
static
void
AudioDeviceListChanged_s
(
cubeb
*
aContext
void
*
aUser
)
;
void
AudioDeviceListChanged
(
)
;
private
:
Mutex
mMutex
;
nsTArray
<
RefPtr
<
AudioDeviceInfo
>
>
mDevices
;
bool
mManualInvalidation
;
}
;
class
WebRTCAudioDataListener
:
public
AudioDataListener
{
protected
:
virtual
~
WebRTCAudioDataListener
(
)
{
}
public
:
explicit
WebRTCAudioDataListener
(
MediaEngineWebRTCMicrophoneSource
*
aAudioSource
)
:
mMutex
(
"
WebRTCAudioDataListener
:
:
mMutex
"
)
mAudioSource
(
aAudioSource
)
{
}
void
NotifyOutputData
(
MediaStreamGraph
*
aGraph
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
override
;
void
NotifyInputData
(
MediaStreamGraph
*
aGraph
const
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
override
;
uint32_t
InputChannelCount
(
)
override
;
void
DeviceChanged
(
)
override
;
void
Shutdown
(
)
;
private
:
Mutex
mMutex
;
RefPtr
<
MediaEngineWebRTCMicrophoneSource
>
mAudioSource
;
}
;
class
MediaEngineWebRTCMicrophoneSource
:
public
MediaEngineSource
public
AudioDataListenerInterface
{
public
:
MediaEngineWebRTCMicrophoneSource
(
RefPtr
<
AudioDeviceInfo
>
aInfo
const
nsString
&
name
const
nsCString
&
uuid
uint32_t
maxChannelCount
bool
aDelayAgnostic
bool
aExtendedFilter
)
;
bool
RequiresSharing
(
)
const
override
{
return
false
;
}
nsString
GetName
(
)
const
override
;
nsCString
GetUUID
(
)
const
override
;
nsresult
Allocate
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
const
ipc
:
:
PrincipalInfo
&
aPrincipalInfo
AllocationHandle
*
*
aOutHandle
const
char
*
*
aOutBadConstraint
)
override
;
nsresult
Deallocate
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
)
override
;
nsresult
SetTrack
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
const
RefPtr
<
SourceMediaStream
>
&
aStream
TrackID
aTrackID
const
PrincipalHandle
&
aPrincipal
)
override
;
nsresult
Start
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
)
override
;
nsresult
Stop
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
)
override
;
nsresult
Reconfigure
(
const
RefPtr
<
AllocationHandle
>
&
aHandle
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
const
char
*
*
aOutBadConstraint
)
override
;
void
GetSettings
(
dom
:
:
MediaTrackSettings
&
aOutSettings
)
const
override
;
void
Pull
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
const
RefPtr
<
SourceMediaStream
>
&
aStream
TrackID
aTrackID
StreamTime
aDesiredTime
const
PrincipalHandle
&
aPrincipalHandle
)
override
;
void
NotifyOutputData
(
MediaStreamGraph
*
aGraph
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
override
;
void
NotifyInputData
(
MediaStreamGraph
*
aGraph
const
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
override
;
void
DeviceChanged
(
)
override
;
uint32_t
RequestedInputChannelCount
(
MediaStreamGraphImpl
*
aGraph
)
override
{
return
GetRequestedInputChannelCount
(
aGraph
)
;
}
dom
:
:
MediaSourceEnum
GetMediaSource
(
)
const
override
{
return
dom
:
:
MediaSourceEnum
:
:
Microphone
;
}
nsresult
TakePhoto
(
MediaEnginePhotoCallback
*
aCallback
)
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
uint32_t
GetBestFitnessDistance
(
const
nsTArray
<
const
NormalizedConstraintSet
*
>
&
aConstraintSets
const
nsString
&
aDeviceId
)
const
override
;
void
Shutdown
(
)
override
;
protected
:
~
MediaEngineWebRTCMicrophoneSource
(
)
{
}
private
:
struct
Allocation
{
Allocation
(
)
=
delete
;
explicit
Allocation
(
const
RefPtr
<
AllocationHandle
>
&
aHandle
)
;
~
Allocation
(
)
;
#
ifdef
DEBUG
GraphTime
mLastCallbackAppendTime
=
0
;
#
endif
bool
mLiveFramesAppended
=
false
;
bool
mLiveSilenceAppended
=
false
;
const
RefPtr
<
AllocationHandle
>
mHandle
;
RefPtr
<
SourceMediaStream
>
mStream
;
TrackID
mTrackID
=
TRACK_NONE
;
PrincipalHandle
mPrincipal
=
PRINCIPAL_HANDLE_NONE
;
bool
mEnabled
=
false
;
}
;
class
AllocationHandleComparator
{
public
:
bool
Equals
(
const
Allocation
&
aAllocation
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
)
const
{
return
aHandle
=
=
aAllocation
.
mHandle
;
}
}
;
nsresult
ReevaluateAllocation
(
const
RefPtr
<
AllocationHandle
>
&
aHandle
const
NormalizedConstraints
*
aConstraintsUpdate
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
const
char
*
*
aOutBadConstraint
)
;
nsresult
UpdateSingleSource
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
const
NormalizedConstraints
&
aNetConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
const
char
*
*
aOutBadConstraint
)
;
void
UpdateAECSettingsIfNeeded
(
bool
aEnable
webrtc
:
:
EcModes
aMode
)
;
void
UpdateAGCSettingsIfNeeded
(
bool
aEnable
webrtc
:
:
AgcModes
aMode
)
;
void
UpdateNSSettingsIfNeeded
(
bool
aEnable
webrtc
:
:
NsModes
aMode
)
;
void
ApplySettings
(
const
MediaEnginePrefs
&
aPrefs
RefPtr
<
MediaStreamGraphImpl
>
aGraph
)
;
bool
HasEnabledTrack
(
)
const
;
template
<
typename
T
>
void
InsertInGraph
(
const
T
*
aBuffer
size_t
aFrames
uint32_t
aChannels
)
;
void
PacketizeAndProcess
(
MediaStreamGraph
*
aGraph
const
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
;
bool
PassThrough
(
MediaStreamGraphImpl
*
aGraphImpl
)
const
;
void
SetPassThrough
(
bool
aPassThrough
)
;
uint32_t
GetRequestedInputChannelCount
(
MediaStreamGraphImpl
*
aGraphImpl
)
;
void
SetRequestedInputChannelCount
(
uint32_t
aRequestedInputChannelCount
)
;
RefPtr
<
WebRTCAudioDataListener
>
mListener
;
const
RefPtr
<
AudioDeviceInfo
>
mDeviceInfo
;
const
UniquePtr
<
webrtc
:
:
AudioProcessing
>
mAudioProcessing
;
nsAutoPtr
<
AudioPacketizer
<
AudioDataValue
float
>
>
mPacketizerInput
;
nsAutoPtr
<
AudioPacketizer
<
AudioDataValue
float
>
>
mPacketizerOutput
;
Mutex
mMutex
;
nsTArray
<
Allocation
>
mAllocations
;
Atomic
<
MediaEngineSourceState
>
mState
;
bool
mDelayAgnostic
;
bool
mExtendedFilter
;
bool
mStarted
;
const
nsString
mDeviceName
;
const
nsCString
mDeviceUUID
;
const
nsMainThreadPtrHandle
<
media
:
:
Refcountable
<
dom
:
:
MediaTrackSettings
>
>
mSettings
;
uint32_t
mRequestedInputChannelCount
;
uint64_t
mTotalFrames
;
uint64_t
mLastLogFrames
;
bool
mSkipProcessing
;
MediaEnginePrefs
mNetPrefs
;
AlignedFloatBuffer
mOutputBuffer
;
AlignedFloatBuffer
mInputBuffer
;
AlignedFloatBuffer
mDeinterleavedBuffer
;
AlignedFloatBuffer
mInputDownmixBuffer
;
}
;
class
MediaEngineWebRTC
:
public
MediaEngine
{
typedef
MediaEngine
Super
;
public
:
explicit
MediaEngineWebRTC
(
MediaEnginePrefs
&
aPrefs
)
;
virtual
void
SetFakeDeviceChangeEvents
(
)
override
;
void
Shutdown
(
)
override
;
bool
SupportsDuplex
(
)
;
void
EnumerateDevices
(
uint64_t
aWindowId
dom
:
:
MediaSourceEnum
MediaSinkEnum
nsTArray
<
RefPtr
<
MediaDevice
>
>
*
)
override
;
void
ReleaseResourcesForWindow
(
uint64_t
aWindowId
)
override
;
private
:
~
MediaEngineWebRTC
(
)
=
default
;
void
EnumerateVideoDevices
(
uint64_t
aWindowId
dom
:
:
MediaSourceEnum
nsTArray
<
RefPtr
<
MediaDevice
>
>
*
)
;
void
EnumerateMicrophoneDevices
(
uint64_t
aWindowId
nsTArray
<
RefPtr
<
MediaDevice
>
>
*
)
;
void
EnumerateSpeakerDevices
(
uint64_t
aWindowId
nsTArray
<
RefPtr
<
MediaDevice
>
>
*
)
;
Mutex
mMutex
;
UniquePtr
<
mozilla
:
:
CubebDeviceEnumerator
>
mEnumerator
;
const
bool
mDelayAgnostic
;
const
bool
mExtendedFilter
;
bool
mHasTabVideoSource
;
nsClassHashtable
<
nsUint64HashKey
nsRefPtrHashtable
<
nsStringHashKey
MediaEngineSource
>
>
mVideoSources
;
nsClassHashtable
<
nsUint64HashKey
nsRefPtrHashtable
<
nsStringHashKey
MediaEngineSource
>
>
mAudioSources
;
}
;
}
#
endif
