#
ifndef
MediaEngineSource_h
#
define
MediaEngineSource_h
#
include
"
MediaSegment
.
h
"
#
include
"
MediaTrackConstraints
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamTrackBinding
.
h
"
#
include
"
mozilla
/
media
/
MediaUtils
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ThreadSafeWeakPtr
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
PerformanceRecorder
.
h
"
namespace
mozilla
{
namespace
dom
{
class
Blob
;
struct
MediaTrackSettings
;
}
namespace
ipc
{
class
PrincipalInfo
;
}
class
MediaEnginePhotoCallback
;
class
MediaEnginePrefs
;
class
MediaTrack
;
class
MediaEnginePhotoCallback
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaEnginePhotoCallback
)
virtual
nsresult
PhotoComplete
(
already_AddRefed
<
dom
:
:
Blob
>
aBlob
)
=
0
;
virtual
nsresult
PhotoError
(
nsresult
aRv
)
=
0
;
protected
:
virtual
~
MediaEnginePhotoCallback
(
)
=
default
;
}
;
enum
MediaEngineSourceState
{
kAllocated
kStarted
kStopped
kReleased
}
;
class
MediaEngineSourceInterface
{
public
:
virtual
bool
IsFake
(
)
const
=
0
;
virtual
RefPtr
<
GenericNonExclusivePromise
>
GetFirstFramePromise
(
)
const
{
return
nullptr
;
}
virtual
const
TrackingId
&
GetTrackingId
(
)
const
=
0
;
virtual
nsresult
Allocate
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
uint64_t
aWindowID
const
char
*
*
aOutBadConstraint
)
=
0
;
virtual
void
SetTrack
(
const
RefPtr
<
MediaTrack
>
&
aTrack
const
PrincipalHandle
&
aPrincipal
)
=
0
;
virtual
nsresult
Start
(
)
=
0
;
virtual
nsresult
FocusOnSelectedSource
(
)
=
0
;
virtual
nsresult
Reconfigure
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
char
*
*
aOutBadConstraint
)
=
0
;
virtual
nsresult
Stop
(
)
=
0
;
virtual
nsresult
Deallocate
(
)
=
0
;
virtual
nsresult
TakePhoto
(
MediaEnginePhotoCallback
*
aCallback
)
=
0
;
virtual
uint32_t
GetBestFitnessDistance
(
const
nsTArray
<
const
NormalizedConstraintSet
*
>
&
aConstraintSets
)
const
=
0
;
virtual
void
GetSettings
(
dom
:
:
MediaTrackSettings
&
aOutSettings
)
const
=
0
;
}
;
class
MediaEngineSource
:
public
MediaEngineSourceInterface
{
public
:
static
const
unsigned
int
kMaxDeviceNameLength
=
128
;
static
const
unsigned
int
kMaxUniqueIdLength
=
256
;
static
bool
IsVideo
(
dom
:
:
MediaSourceEnum
aSource
)
;
static
bool
IsAudio
(
dom
:
:
MediaSourceEnum
aSource
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaEngineSource
)
NS_DECL_OWNINGEVENTTARGET
void
AssertIsOnOwningThread
(
)
const
{
NS_ASSERT_OWNINGTHREAD
(
MediaEngineSource
)
;
}
const
TrackingId
&
GetTrackingId
(
)
const
override
{
static
auto
notImplementedId
=
TrackingId
(
)
;
return
notImplementedId
;
}
bool
IsFake
(
)
const
override
;
nsresult
FocusOnSelectedSource
(
)
override
;
nsresult
TakePhoto
(
MediaEnginePhotoCallback
*
aCallback
)
override
;
uint32_t
GetBestFitnessDistance
(
const
nsTArray
<
const
NormalizedConstraintSet
*
>
&
aConstraintSets
)
const
override
{
return
0
;
}
virtual
MediaEventSource
<
void
>
*
CaptureEndedEvent
(
)
{
return
nullptr
;
}
protected
:
virtual
~
MediaEngineSource
(
)
;
}
;
}
#
endif
