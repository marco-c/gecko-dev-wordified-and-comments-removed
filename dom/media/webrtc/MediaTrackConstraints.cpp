#
include
"
MediaTrackConstraints
.
h
"
#
include
<
limits
>
#
include
<
algorithm
>
#
include
<
iterator
>
namespace
mozilla
{
template
<
class
ValueType
>
template
<
class
ConstrainRange
>
void
NormalizedConstraintSet
:
:
Range
<
ValueType
>
:
:
SetFrom
(
const
ConstrainRange
&
aOther
)
{
if
(
aOther
.
mIdeal
.
WasPassed
(
)
)
{
mIdeal
.
emplace
(
aOther
.
mIdeal
.
Value
(
)
)
;
}
if
(
aOther
.
mExact
.
WasPassed
(
)
)
{
mMin
=
aOther
.
mExact
.
Value
(
)
;
mMax
=
aOther
.
mExact
.
Value
(
)
;
}
else
{
if
(
aOther
.
mMin
.
WasPassed
(
)
)
{
mMin
=
aOther
.
mMin
.
Value
(
)
;
}
if
(
aOther
.
mMax
.
WasPassed
(
)
)
{
mMax
=
aOther
.
mMax
.
Value
(
)
;
}
}
}
template
<
>
bool
NormalizedConstraintSet
:
:
Range
<
bool
>
:
:
Merge
(
const
Range
&
aOther
)
{
if
(
!
Intersects
(
aOther
)
)
{
return
false
;
}
Intersect
(
aOther
)
;
uint32_t
counter
=
mMergeDenominator
>
>
16
;
uint32_t
denominator
=
mMergeDenominator
&
0xffff
;
if
(
aOther
.
mIdeal
.
isSome
(
)
)
{
if
(
mIdeal
.
isNothing
(
)
)
{
mIdeal
.
emplace
(
aOther
.
mIdeal
.
value
(
)
)
;
counter
=
aOther
.
mIdeal
.
value
(
)
;
denominator
=
1
;
}
else
{
if
(
!
denominator
)
{
counter
=
mIdeal
.
value
(
)
;
}
counter
+
=
aOther
.
mIdeal
.
value
(
)
;
denominator
=
std
:
:
max
(
2U
denominator
+
1
)
;
}
}
mMergeDenominator
=
(
(
counter
&
0xffff
)
<
<
16
)
+
(
denominator
&
0xffff
)
;
return
true
;
}
template
<
>
void
NormalizedConstraintSet
:
:
Range
<
bool
>
:
:
FinalizeMerge
(
)
{
if
(
mMergeDenominator
)
{
uint32_t
counter
=
mMergeDenominator
>
>
16
;
uint32_t
denominator
=
mMergeDenominator
&
0xffff
;
*
mIdeal
=
!
!
(
counter
/
denominator
)
;
mMergeDenominator
=
0
;
}
}
NormalizedConstraintSet
:
:
LongRange
:
:
LongRange
(
LongPtrType
aMemberPtr
const
char
*
aName
const
dom
:
:
OwningLongOrConstrainLongRange
&
aOther
bool
advanced
nsTArray
<
MemberPtrType
>
*
aList
)
:
Range
<
int32_t
>
(
(
MemberPtrType
)
aMemberPtr
aName
1
+
INT32_MIN
INT32_MAX
aList
)
{
if
(
aOther
.
IsLong
(
)
)
{
if
(
advanced
)
{
mMin
=
mMax
=
aOther
.
GetAsLong
(
)
;
}
else
{
mIdeal
.
emplace
(
aOther
.
GetAsLong
(
)
)
;
}
}
else
{
SetFrom
(
aOther
.
GetAsConstrainLongRange
(
)
)
;
}
}
NormalizedConstraintSet
:
:
LongLongRange
:
:
LongLongRange
(
LongLongPtrType
aMemberPtr
const
char
*
aName
const
long
long
&
aOther
nsTArray
<
MemberPtrType
>
*
aList
)
:
Range
<
int64_t
>
(
(
MemberPtrType
)
aMemberPtr
aName
1
+
INT64_MIN
INT64_MAX
aList
)
{
mIdeal
.
emplace
(
aOther
)
;
}
NormalizedConstraintSet
:
:
DoubleRange
:
:
DoubleRange
(
DoublePtrType
aMemberPtr
const
char
*
aName
const
dom
:
:
OwningDoubleOrConstrainDoubleRange
&
aOther
bool
advanced
nsTArray
<
MemberPtrType
>
*
aList
)
:
Range
<
double
>
(
(
MemberPtrType
)
aMemberPtr
aName
-
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
aList
)
{
if
(
aOther
.
IsDouble
(
)
)
{
if
(
advanced
)
{
mMin
=
mMax
=
aOther
.
GetAsDouble
(
)
;
}
else
{
mIdeal
.
emplace
(
aOther
.
GetAsDouble
(
)
)
;
}
}
else
{
SetFrom
(
aOther
.
GetAsConstrainDoubleRange
(
)
)
;
}
}
NormalizedConstraintSet
:
:
BooleanRange
:
:
BooleanRange
(
BooleanPtrType
aMemberPtr
const
char
*
aName
const
dom
:
:
OwningBooleanOrConstrainBooleanParameters
&
aOther
bool
advanced
nsTArray
<
MemberPtrType
>
*
aList
)
:
Range
<
bool
>
(
(
MemberPtrType
)
aMemberPtr
aName
false
true
aList
)
{
if
(
aOther
.
IsBoolean
(
)
)
{
if
(
advanced
)
{
mMin
=
mMax
=
aOther
.
GetAsBoolean
(
)
;
}
else
{
mIdeal
.
emplace
(
aOther
.
GetAsBoolean
(
)
)
;
}
}
else
{
const
ConstrainBooleanParameters
&
r
=
aOther
.
GetAsConstrainBooleanParameters
(
)
;
if
(
r
.
mIdeal
.
WasPassed
(
)
)
{
mIdeal
.
emplace
(
r
.
mIdeal
.
Value
(
)
)
;
}
if
(
r
.
mExact
.
WasPassed
(
)
)
{
mMin
=
r
.
mExact
.
Value
(
)
;
mMax
=
r
.
mExact
.
Value
(
)
;
}
}
}
NormalizedConstraintSet
:
:
StringRange
:
:
StringRange
(
StringPtrType
aMemberPtr
const
char
*
aName
const
dom
:
:
OwningStringOrStringSequenceOrConstrainDOMStringParameters
&
aOther
bool
advanced
nsTArray
<
MemberPtrType
>
*
aList
)
:
BaseRange
(
(
MemberPtrType
)
aMemberPtr
aName
aList
)
{
if
(
aOther
.
IsString
(
)
)
{
if
(
advanced
)
{
mExact
.
insert
(
aOther
.
GetAsString
(
)
)
;
}
else
{
mIdeal
.
insert
(
aOther
.
GetAsString
(
)
)
;
}
}
else
if
(
aOther
.
IsStringSequence
(
)
)
{
if
(
advanced
)
{
mExact
.
clear
(
)
;
for
(
auto
&
str
:
aOther
.
GetAsStringSequence
(
)
)
{
mExact
.
insert
(
str
)
;
}
}
else
{
mIdeal
.
clear
(
)
;
for
(
auto
&
str
:
aOther
.
GetAsStringSequence
(
)
)
{
mIdeal
.
insert
(
str
)
;
}
}
}
else
{
SetFrom
(
aOther
.
GetAsConstrainDOMStringParameters
(
)
)
;
}
}
void
NormalizedConstraintSet
:
:
StringRange
:
:
SetFrom
(
const
ConstrainDOMStringParameters
&
aOther
)
{
if
(
aOther
.
mIdeal
.
WasPassed
(
)
)
{
mIdeal
.
clear
(
)
;
if
(
aOther
.
mIdeal
.
Value
(
)
.
IsString
(
)
)
{
mIdeal
.
insert
(
aOther
.
mIdeal
.
Value
(
)
.
GetAsString
(
)
)
;
}
else
{
for
(
auto
&
str
:
aOther
.
mIdeal
.
Value
(
)
.
GetAsStringSequence
(
)
)
{
mIdeal
.
insert
(
str
)
;
}
}
}
if
(
aOther
.
mExact
.
WasPassed
(
)
)
{
mExact
.
clear
(
)
;
if
(
aOther
.
mExact
.
Value
(
)
.
IsString
(
)
)
{
mExact
.
insert
(
aOther
.
mExact
.
Value
(
)
.
GetAsString
(
)
)
;
}
else
{
for
(
auto
&
str
:
aOther
.
mExact
.
Value
(
)
.
GetAsStringSequence
(
)
)
{
mIdeal
.
insert
(
str
)
;
}
}
}
}
auto
NormalizedConstraintSet
:
:
StringRange
:
:
Clamp
(
const
ValueType
&
n
)
const
-
>
ValueType
{
if
(
!
mExact
.
size
(
)
)
{
return
n
;
}
ValueType
result
;
for
(
auto
&
entry
:
n
)
{
if
(
mExact
.
find
(
entry
)
!
=
mExact
.
end
(
)
)
{
result
.
insert
(
entry
)
;
}
}
return
result
;
}
bool
NormalizedConstraintSet
:
:
StringRange
:
:
Intersects
(
const
StringRange
&
aOther
)
const
{
if
(
!
mExact
.
size
(
)
|
|
!
aOther
.
mExact
.
size
(
)
)
{
return
true
;
}
ValueType
intersection
;
set_intersection
(
mExact
.
begin
(
)
mExact
.
end
(
)
aOther
.
mExact
.
begin
(
)
aOther
.
mExact
.
end
(
)
std
:
:
inserter
(
intersection
intersection
.
begin
(
)
)
)
;
return
!
!
intersection
.
size
(
)
;
}
void
NormalizedConstraintSet
:
:
StringRange
:
:
Intersect
(
const
StringRange
&
aOther
)
{
if
(
!
aOther
.
mExact
.
size
(
)
)
{
return
;
}
ValueType
intersection
;
set_intersection
(
mExact
.
begin
(
)
mExact
.
end
(
)
aOther
.
mExact
.
begin
(
)
aOther
.
mExact
.
end
(
)
std
:
:
inserter
(
intersection
intersection
.
begin
(
)
)
)
;
mExact
=
intersection
;
}
bool
NormalizedConstraintSet
:
:
StringRange
:
:
Merge
(
const
StringRange
&
aOther
)
{
if
(
!
Intersects
(
aOther
)
)
{
return
false
;
}
Intersect
(
aOther
)
;
ValueType
unioned
;
set_union
(
mIdeal
.
begin
(
)
mIdeal
.
end
(
)
aOther
.
mIdeal
.
begin
(
)
aOther
.
mIdeal
.
end
(
)
std
:
:
inserter
(
unioned
unioned
.
begin
(
)
)
)
;
mIdeal
=
unioned
;
return
true
;
}
NormalizedConstraints
:
:
NormalizedConstraints
(
const
dom
:
:
MediaTrackConstraints
&
aOther
nsTArray
<
MemberPtrType
>
*
aList
)
:
NormalizedConstraintSet
(
aOther
false
aList
)
mBadConstraint
(
nullptr
)
{
if
(
aOther
.
mAdvanced
.
WasPassed
(
)
)
{
for
(
auto
&
entry
:
aOther
.
mAdvanced
.
Value
(
)
)
{
mAdvanced
.
AppendElement
(
NormalizedConstraintSet
(
entry
true
)
)
;
}
}
}
NormalizedConstraints
:
:
NormalizedConstraints
(
const
nsTArray
<
const
NormalizedConstraints
*
>
&
aOthers
)
:
NormalizedConstraintSet
(
*
aOthers
[
0
]
)
mBadConstraint
(
nullptr
)
{
nsTArray
<
MemberPtrType
>
list
;
NormalizedConstraints
dummy
(
MediaTrackConstraints
(
)
&
list
)
;
for
(
uint32_t
i
=
1
;
i
<
aOthers
.
Length
(
)
;
i
+
+
)
{
auto
&
other
=
*
aOthers
[
i
]
;
for
(
auto
&
memberPtr
:
list
)
{
auto
&
member
=
this
-
>
*
memberPtr
;
auto
&
otherMember
=
other
.
*
memberPtr
;
if
(
!
member
.
Merge
(
otherMember
)
)
{
mBadConstraint
=
member
.
mName
;
return
;
}
}
for
(
auto
&
entry
:
other
.
mAdvanced
)
{
mAdvanced
.
AppendElement
(
entry
)
;
}
}
for
(
auto
&
memberPtr
:
list
)
{
(
this
-
>
*
memberPtr
)
.
FinalizeMerge
(
)
;
}
}
FlattenedConstraints
:
:
FlattenedConstraints
(
const
NormalizedConstraints
&
aOther
)
:
NormalizedConstraintSet
(
aOther
)
{
for
(
auto
&
set
:
aOther
.
mAdvanced
)
{
if
(
mWidth
.
Intersects
(
set
.
mWidth
)
&
&
mHeight
.
Intersects
(
set
.
mHeight
)
&
&
mFrameRate
.
Intersects
(
set
.
mFrameRate
)
)
{
mWidth
.
Intersect
(
set
.
mWidth
)
;
mHeight
.
Intersect
(
set
.
mHeight
)
;
mFrameRate
.
Intersect
(
set
.
mFrameRate
)
;
}
if
(
mEchoCancellation
.
Intersects
(
set
.
mEchoCancellation
)
)
{
mEchoCancellation
.
Intersect
(
set
.
mEchoCancellation
)
;
}
if
(
mMozNoiseSuppression
.
Intersects
(
set
.
mMozNoiseSuppression
)
)
{
mMozNoiseSuppression
.
Intersect
(
set
.
mMozNoiseSuppression
)
;
}
if
(
mMozAutoGainControl
.
Intersects
(
set
.
mMozAutoGainControl
)
)
{
mMozAutoGainControl
.
Intersect
(
set
.
mMozAutoGainControl
)
;
}
}
}
uint32_t
MediaConstraintsHelper
:
:
GetMinimumFitnessDistance
(
const
NormalizedConstraintSet
&
aConstraints
const
nsString
&
aDeviceId
)
{
return
FitnessDistance
(
aDeviceId
aConstraints
.
mDeviceId
)
;
}
template
<
class
ValueType
class
NormalizedRange
>
uint32_t
MediaConstraintsHelper
:
:
FitnessDistance
(
ValueType
aN
const
NormalizedRange
&
aRange
)
{
if
(
aRange
.
mMin
>
aN
|
|
aRange
.
mMax
<
aN
)
{
return
UINT32_MAX
;
}
if
(
aN
=
=
aRange
.
mIdeal
.
valueOr
(
aN
)
)
{
return
0
;
}
return
uint32_t
(
ValueType
(
(
std
:
:
abs
(
aN
-
aRange
.
mIdeal
.
value
(
)
)
*
1000
)
/
std
:
:
max
(
std
:
:
abs
(
aN
)
std
:
:
abs
(
aRange
.
mIdeal
.
value
(
)
)
)
)
)
;
}
uint32_t
MediaConstraintsHelper
:
:
FitnessDistance
(
nsString
aN
const
NormalizedConstraintSet
:
:
StringRange
&
aParams
)
{
if
(
aParams
.
mExact
.
size
(
)
&
&
aParams
.
mExact
.
find
(
aN
)
=
=
aParams
.
mExact
.
end
(
)
)
{
return
UINT32_MAX
;
}
if
(
aParams
.
mIdeal
.
size
(
)
&
&
aParams
.
mIdeal
.
find
(
aN
)
=
=
aParams
.
mIdeal
.
end
(
)
)
{
return
1000
;
}
return
0
;
}
}
