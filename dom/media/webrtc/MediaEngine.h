#
ifndef
MEDIAENGINE_H_
#
define
MEDIAENGINE_H_
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
DOMMediaStream
.
h
"
#
include
"
MediaStreamGraph
.
h
"
#
include
"
MediaTrackConstraints
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamTrackBinding
.
h
"
#
include
"
mozilla
/
dom
/
VideoStreamTrack
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundSharedTypes
.
h
"
#
include
"
mozilla
/
media
/
DeviceChangeCallback
.
h
"
namespace
mozilla
{
namespace
dom
{
class
Blob
;
}
enum
{
kVideoTrack
=
1
kAudioTrack
=
2
kTrackCount
}
;
class
MediaEngineVideoSource
;
class
MediaEngineAudioSource
;
enum
MediaEngineState
{
kAllocated
kStarted
kStopped
kReleased
}
;
class
MediaEngine
:
public
DeviceChangeCallback
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaEngine
)
static
const
int
DEFAULT_VIDEO_FPS
=
30
;
static
const
int
DEFAULT_43_VIDEO_WIDTH
=
640
;
static
const
int
DEFAULT_43_VIDEO_HEIGHT
=
480
;
static
const
int
DEFAULT_169_VIDEO_WIDTH
=
1280
;
static
const
int
DEFAULT_169_VIDEO_HEIGHT
=
720
;
virtual
void
EnumerateVideoDevices
(
dom
:
:
MediaSourceEnum
nsTArray
<
RefPtr
<
MediaEngineVideoSource
>
>
*
)
=
0
;
virtual
void
EnumerateAudioDevices
(
dom
:
:
MediaSourceEnum
nsTArray
<
RefPtr
<
MediaEngineAudioSource
>
>
*
)
=
0
;
virtual
void
Shutdown
(
)
=
0
;
virtual
void
SetFakeDeviceChangeEvents
(
)
{
}
protected
:
virtual
~
MediaEngine
(
)
{
}
}
;
class
MediaEnginePrefs
{
public
:
MediaEnginePrefs
(
)
:
mWidth
(
0
)
mHeight
(
0
)
mFPS
(
0
)
mFreq
(
0
)
mAecOn
(
false
)
mAgcOn
(
false
)
mNoiseOn
(
false
)
mAec
(
0
)
mAgc
(
0
)
mNoise
(
0
)
mFullDuplex
(
false
)
mExtendedFilter
(
false
)
mDelayAgnostic
(
false
)
mFakeDeviceChangeEventOn
(
false
)
mChannels
(
0
)
{
}
int32_t
mWidth
;
int32_t
mHeight
;
int32_t
mFPS
;
int32_t
mFreq
;
bool
mAecOn
;
bool
mAgcOn
;
bool
mNoiseOn
;
int32_t
mAec
;
int32_t
mAgc
;
int32_t
mNoise
;
bool
mFullDuplex
;
bool
mExtendedFilter
;
bool
mDelayAgnostic
;
bool
mFakeDeviceChangeEventOn
;
int32_t
mChannels
;
int32_t
GetWidth
(
bool
aHD
=
false
)
const
{
return
mWidth
?
mWidth
:
(
mHeight
?
(
mHeight
*
GetDefWidth
(
aHD
)
)
/
GetDefHeight
(
aHD
)
:
GetDefWidth
(
aHD
)
)
;
}
int32_t
GetHeight
(
bool
aHD
=
false
)
const
{
return
mHeight
?
mHeight
:
(
mWidth
?
(
mWidth
*
GetDefHeight
(
aHD
)
)
/
GetDefWidth
(
aHD
)
:
GetDefHeight
(
aHD
)
)
;
}
private
:
static
int32_t
GetDefWidth
(
bool
aHD
=
false
)
{
if
(
aHD
)
{
return
MediaEngine
:
:
DEFAULT_169_VIDEO_WIDTH
;
}
return
MediaEngine
:
:
DEFAULT_43_VIDEO_WIDTH
;
}
static
int32_t
GetDefHeight
(
bool
aHD
=
false
)
{
if
(
aHD
)
{
return
MediaEngine
:
:
DEFAULT_169_VIDEO_HEIGHT
;
}
return
MediaEngine
:
:
DEFAULT_43_VIDEO_HEIGHT
;
}
}
;
class
MediaEnginePhotoCallback
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaEnginePhotoCallback
)
virtual
nsresult
PhotoComplete
(
already_AddRefed
<
dom
:
:
Blob
>
aBlob
)
=
0
;
virtual
nsresult
PhotoError
(
nsresult
aRv
)
=
0
;
protected
:
virtual
~
MediaEnginePhotoCallback
(
)
{
}
}
;
class
MediaEngineSource
:
public
nsISupports
protected
MediaConstraintsHelper
{
public
:
static
const
unsigned
int
kMaxDeviceNameLength
=
128
;
static
const
unsigned
int
kMaxUniqueIdLength
=
256
;
virtual
~
MediaEngineSource
(
)
{
if
(
!
mInShutdown
)
{
Shutdown
(
)
;
}
}
virtual
void
Shutdown
(
)
{
mInShutdown
=
true
;
}
;
virtual
void
GetName
(
nsAString
&
)
const
=
0
;
virtual
void
GetUUID
(
nsACString
&
)
const
=
0
;
virtual
bool
GetScary
(
)
const
{
return
false
;
}
;
class
AllocationHandle
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AllocationHandle
)
;
protected
:
~
AllocationHandle
(
)
{
}
static
uint64_t
sId
;
public
:
AllocationHandle
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
mozilla
:
:
ipc
:
:
PrincipalInfo
&
aPrincipalInfo
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
)
:
mConstraints
(
aConstraints
)
mPrincipalInfo
(
aPrincipalInfo
)
mPrefs
(
aPrefs
)
#
ifdef
MOZ_WEBRTC
mId
(
sId
+
+
)
#
endif
mDeviceId
(
aDeviceId
)
{
}
public
:
NormalizedConstraints
mConstraints
;
mozilla
:
:
ipc
:
:
PrincipalInfo
mPrincipalInfo
;
MediaEnginePrefs
mPrefs
;
uint64_t
mId
;
nsString
mDeviceId
;
}
;
virtual
nsresult
Deallocate
(
AllocationHandle
*
aHandle
)
{
MOZ_ASSERT
(
aHandle
)
;
RefPtr
<
AllocationHandle
>
handle
=
aHandle
;
class
Comparator
{
public
:
static
bool
Equals
(
const
RefPtr
<
AllocationHandle
>
&
a
const
RefPtr
<
AllocationHandle
>
&
b
)
{
return
a
.
get
(
)
=
=
b
.
get
(
)
;
}
}
;
auto
ix
=
mRegisteredHandles
.
IndexOf
(
handle
0
Comparator
(
)
)
;
if
(
ix
=
=
mRegisteredHandles
.
NoIndex
)
{
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_FAILURE
;
}
mRegisteredHandles
.
RemoveElementAt
(
ix
)
;
if
(
mRegisteredHandles
.
Length
(
)
&
&
!
mInShutdown
)
{
auto
&
first
=
mRegisteredHandles
[
0
]
;
const
char
*
badConstraint
=
nullptr
;
return
ReevaluateAllocation
(
nullptr
nullptr
first
-
>
mPrefs
first
-
>
mDeviceId
&
badConstraint
)
;
}
return
NS_OK
;
}
virtual
nsresult
Start
(
SourceMediaStream
*
TrackID
const
PrincipalHandle
&
)
=
0
;
virtual
void
NotifyPull
(
MediaStreamGraph
*
aGraph
SourceMediaStream
*
aSource
TrackID
aId
StreamTime
aDesiredTime
const
PrincipalHandle
&
aPrincipalHandle
)
=
0
;
virtual
nsresult
Stop
(
SourceMediaStream
*
aSource
TrackID
aID
)
=
0
;
virtual
nsresult
Restart
(
AllocationHandle
*
aHandle
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
const
char
*
*
aOutBadConstraint
)
=
0
;
virtual
bool
IsFake
(
)
=
0
;
virtual
dom
:
:
MediaSourceEnum
GetMediaSource
(
)
const
=
0
;
virtual
nsresult
TakePhoto
(
MediaEnginePhotoCallback
*
aCallback
)
=
0
;
bool
IsAvailable
(
)
{
if
(
mState
=
=
kAllocated
|
|
mState
=
=
kStarted
)
{
return
false
;
}
else
{
return
true
;
}
}
virtual
nsresult
Allocate
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
const
mozilla
:
:
ipc
:
:
PrincipalInfo
&
aPrincipalInfo
AllocationHandle
*
*
aOutHandle
const
char
*
*
aOutBadConstraint
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aOutHandle
)
;
RefPtr
<
AllocationHandle
>
handle
=
new
AllocationHandle
(
aConstraints
aPrincipalInfo
aPrefs
aDeviceId
)
;
nsresult
rv
=
ReevaluateAllocation
(
handle
nullptr
aPrefs
aDeviceId
aOutBadConstraint
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mRegisteredHandles
.
AppendElement
(
handle
)
;
handle
.
forget
(
aOutHandle
)
;
return
NS_OK
;
}
virtual
uint32_t
GetBestFitnessDistance
(
const
nsTArray
<
const
NormalizedConstraintSet
*
>
&
aConstraintSets
const
nsString
&
aDeviceId
)
const
=
0
;
void
GetSettings
(
dom
:
:
MediaTrackSettings
&
aOutSettings
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aOutSettings
=
*
mSettings
;
}
protected
:
explicit
MediaEngineSource
(
MediaEngineState
aState
)
:
mState
(
aState
)
mInShutdown
(
false
)
mSettings
(
MakeRefPtr
<
media
:
:
Refcountable
<
dom
:
:
MediaTrackSettings
>
>
(
)
)
{
}
virtual
nsresult
UpdateSingleSource
(
const
AllocationHandle
*
aHandle
const
NormalizedConstraints
&
aNetConstraints
const
NormalizedConstraints
&
aNewConstraint
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
const
char
*
*
aOutBadConstraint
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
;
nsresult
ReevaluateAllocation
(
AllocationHandle
*
aHandle
NormalizedConstraints
*
aConstraintsUpdate
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
const
char
*
*
aOutBadConstraint
)
{
AutoTArray
<
const
NormalizedConstraints
*
10
>
allConstraints
;
AutoTArray
<
const
NormalizedConstraints
*
1
>
updatedConstraint
;
for
(
auto
&
registered
:
mRegisteredHandles
)
{
if
(
aConstraintsUpdate
&
&
registered
.
get
(
)
=
=
aHandle
)
{
continue
;
}
allConstraints
.
AppendElement
(
&
registered
-
>
mConstraints
)
;
}
if
(
aConstraintsUpdate
)
{
allConstraints
.
AppendElement
(
aConstraintsUpdate
)
;
updatedConstraint
.
AppendElement
(
aConstraintsUpdate
)
;
}
else
if
(
aHandle
)
{
allConstraints
.
AppendElement
(
&
aHandle
-
>
mConstraints
)
;
updatedConstraint
.
AppendElement
(
&
aHandle
-
>
mConstraints
)
;
}
else
{
updatedConstraint
.
AppendElements
(
allConstraints
)
;
}
NormalizedConstraints
netConstraints
(
allConstraints
)
;
if
(
netConstraints
.
mBadConstraint
)
{
*
aOutBadConstraint
=
netConstraints
.
mBadConstraint
;
return
NS_ERROR_FAILURE
;
}
NormalizedConstraints
newConstraint
(
updatedConstraint
)
;
nsresult
rv
=
UpdateSingleSource
(
aHandle
netConstraints
newConstraint
aPrefs
aDeviceId
aOutBadConstraint
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aHandle
&
&
aConstraintsUpdate
)
{
aHandle
-
>
mConstraints
=
*
aConstraintsUpdate
;
}
return
NS_OK
;
}
void
AssertIsOnOwningThread
(
)
{
NS_ASSERT_OWNINGTHREAD
(
MediaEngineSource
)
;
}
MediaEngineState
mState
;
NS_DECL_OWNINGTHREAD
nsTArray
<
RefPtr
<
AllocationHandle
>
>
mRegisteredHandles
;
bool
mInShutdown
;
RefPtr
<
media
:
:
Refcountable
<
dom
:
:
MediaTrackSettings
>
>
mSettings
;
}
;
class
MediaEngineVideoSource
:
public
MediaEngineSource
{
public
:
virtual
~
MediaEngineVideoSource
(
)
{
}
protected
:
explicit
MediaEngineVideoSource
(
MediaEngineState
aState
)
:
MediaEngineSource
(
aState
)
{
}
MediaEngineVideoSource
(
)
:
MediaEngineSource
(
kReleased
)
{
}
}
;
class
MediaEngineAudioSource
:
public
MediaEngineSource
public
AudioDataListenerInterface
{
public
:
virtual
~
MediaEngineAudioSource
(
)
{
}
protected
:
explicit
MediaEngineAudioSource
(
MediaEngineState
aState
)
:
MediaEngineSource
(
aState
)
{
}
MediaEngineAudioSource
(
)
:
MediaEngineSource
(
kReleased
)
{
}
}
;
}
#
endif
