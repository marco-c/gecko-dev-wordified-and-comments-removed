const
ENDED_TIMEOUT_LENGTH
=
30000
;
const
VERIFYPLAYING_TIMEOUT_LENGTH
=
60000
;
function
MediaStreamPlayback
(
mediaElement
mediaStream
)
{
this
.
mediaElement
=
mediaElement
;
this
.
mediaStream
=
mediaStream
;
}
MediaStreamPlayback
.
prototype
=
{
playMedia
(
isResume
)
{
this
.
startMedia
(
isResume
)
;
return
this
.
verifyPlaying
(
)
.
then
(
(
)
=
>
this
.
stopTracksForStreamInMediaPlayback
(
)
)
.
then
(
(
)
=
>
this
.
detachFromMediaElement
(
)
)
;
}
stopTracksForStreamInMediaPlayback
(
)
{
var
elem
=
this
.
mediaElement
;
return
Promise
.
all
(
[
haveEvent
(
elem
"
ended
"
wait
(
ENDED_TIMEOUT_LENGTH
new
Error
(
"
Timeout
"
)
)
)
.
.
.
this
.
mediaStream
.
getTracks
(
)
.
map
(
t
=
>
(
t
.
stop
(
)
haveNoEvent
(
t
"
ended
"
)
)
)
]
)
;
}
playMediaWithoutStoppingTracks
(
isResume
)
{
this
.
startMedia
(
isResume
)
;
return
this
.
verifyPlaying
(
)
.
then
(
(
)
=
>
this
.
detachFromMediaElement
(
)
)
;
}
startMedia
(
isResume
)
{
if
(
!
isResume
)
{
is
(
this
.
mediaElement
.
currentTime
0
"
Before
starting
the
media
element
currentTime
=
0
"
)
;
}
this
.
canPlayThroughFired
=
listenUntil
(
this
.
mediaElement
"
canplaythrough
"
(
)
=
>
true
)
;
this
.
mediaElement
.
srcObject
=
this
.
mediaStream
;
this
.
mediaElement
.
play
(
)
;
}
verifyPlaying
(
)
{
var
lastElementTime
=
this
.
mediaElement
.
currentTime
;
var
mediaTimeProgressed
=
listenUntil
(
this
.
mediaElement
"
timeupdate
"
(
)
=
>
this
.
mediaElement
.
currentTime
>
lastElementTime
)
;
return
timeout
(
Promise
.
all
(
[
this
.
canPlayThroughFired
mediaTimeProgressed
]
)
VERIFYPLAYING_TIMEOUT_LENGTH
"
verifyPlaying
timed
out
"
)
.
then
(
(
)
=
>
{
is
(
this
.
mediaElement
.
paused
false
"
Media
element
should
be
playing
"
)
;
is
(
this
.
mediaElement
.
duration
Number
.
POSITIVE_INFINITY
"
Duration
should
be
infinity
"
)
;
ok
(
this
.
mediaElement
.
readyState
=
=
=
HTMLMediaElement
.
HAVE_ENOUGH_DATA
|
|
this
.
mediaElement
.
readyState
=
=
=
HTMLMediaElement
.
HAVE_CURRENT_DATA
"
Ready
state
shall
be
HAVE_ENOUGH_DATA
or
HAVE_CURRENT_DATA
"
)
;
is
(
this
.
mediaElement
.
seekable
.
length
0
"
Seekable
length
shall
be
zero
"
)
;
is
(
this
.
mediaElement
.
buffered
.
length
0
"
Buffered
length
shall
be
zero
"
)
;
is
(
this
.
mediaElement
.
seeking
false
"
MediaElement
is
not
seekable
with
MediaStream
"
)
;
ok
(
isNaN
(
this
.
mediaElement
.
startOffsetTime
)
"
Start
offset
time
shall
not
be
a
number
"
)
;
is
(
this
.
mediaElement
.
defaultPlaybackRate
1
"
DefaultPlaybackRate
should
be
1
"
)
;
is
(
this
.
mediaElement
.
playbackRate
1
"
PlaybackRate
should
be
1
"
)
;
is
(
this
.
mediaElement
.
preload
"
none
"
'
Preload
should
be
"
none
"
'
)
;
is
(
this
.
mediaElement
.
src
"
"
"
No
src
should
be
defined
"
)
;
is
(
this
.
mediaElement
.
currentSrc
"
"
"
Current
src
should
still
be
an
empty
string
"
)
;
}
)
;
}
detachFromMediaElement
(
)
{
this
.
mediaElement
.
pause
(
)
;
this
.
mediaElement
.
srcObject
=
null
;
}
}
;
function
addLoadEvent
(
)
{
}
var
scriptsReady
=
Promise
.
all
(
[
"
/
tests
/
SimpleTest
/
SimpleTest
.
js
"
"
head
.
js
"
]
.
map
(
script
=
>
{
var
el
=
document
.
createElement
(
"
script
"
)
;
el
.
src
=
script
;
document
.
head
.
appendChild
(
el
)
;
return
new
Promise
(
r
=
>
(
el
.
onload
=
r
)
)
;
}
)
)
;
function
createHTML
(
options
)
{
return
scriptsReady
.
then
(
(
)
=
>
realCreateHTML
(
options
)
)
;
}
async
function
runTest
(
testFunction
)
{
await
scriptsReady
;
await
runTestWhenReady
(
async
(
.
.
.
args
)
=
>
{
await
testFunction
(
.
.
.
args
)
;
await
noGum
(
)
;
}
)
;
}
async
function
noGum
(
)
{
await
pushPrefs
(
[
"
media
.
navigator
.
permission
.
disabled
"
false
]
[
"
media
.
navigator
.
permission
.
fake
"
true
]
)
;
if
(
!
navigator
.
mediaDevices
)
{
return
;
}
const
[
device
]
=
await
navigator
.
mediaDevices
.
enumerateDevices
(
)
;
if
(
device
)
{
is
(
device
.
label
"
"
"
Test
must
leave
no
active
gUM
streams
behind
.
"
)
;
}
}
