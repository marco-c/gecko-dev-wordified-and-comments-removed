"
use
strict
"
;
var
Cc
=
SpecialPowers
.
Cc
;
var
Ci
=
SpecialPowers
.
Ci
;
let
WANT_FAKE_AUDIO
=
true
;
let
WANT_FAKE_VIDEO
=
true
;
let
TEST_AUDIO_FREQ
=
1000
;
function
updateConfigFromFakeAndLoopbackPrefs
(
)
{
let
audioDevice
=
SpecialPowers
.
getCharPref
(
"
media
.
audio_loopback_dev
"
"
"
)
;
if
(
audioDevice
)
{
WANT_FAKE_AUDIO
=
false
;
dump
(
"
TEST
DEVICES
:
Got
loopback
audio
:
"
+
audioDevice
+
"
\
n
"
)
;
}
else
{
WANT_FAKE_AUDIO
=
true
;
dump
(
"
TEST
DEVICES
:
No
test
device
found
in
media
.
audio_loopback_dev
using
fake
audio
streams
.
\
n
"
)
;
}
let
videoDevice
=
SpecialPowers
.
getCharPref
(
"
media
.
video_loopback_dev
"
"
"
)
;
if
(
videoDevice
)
{
WANT_FAKE_VIDEO
=
false
;
dump
(
"
TEST
DEVICES
:
Got
loopback
video
:
"
+
videoDevice
+
"
\
n
"
)
;
}
else
{
WANT_FAKE_VIDEO
=
true
;
dump
(
"
TEST
DEVICES
:
No
test
device
found
in
media
.
video_loopback_dev
using
fake
video
streams
.
\
n
"
)
;
}
}
updateConfigFromFakeAndLoopbackPrefs
(
)
;
let
DISABLE_LOOPBACK_TONE
=
false
;
class
LoopbackTone
{
constructor
(
audioContext
frequency
)
{
if
(
!
audioContext
)
{
throw
new
Error
(
"
You
must
provide
a
valid
AudioContext
"
)
;
}
this
.
oscNode
=
audioContext
.
createOscillator
(
)
;
var
gainNode
=
audioContext
.
createGain
(
)
;
gainNode
.
gain
.
value
=
0
.
5
;
this
.
oscNode
.
connect
(
gainNode
)
;
gainNode
.
connect
(
audioContext
.
destination
)
;
this
.
changeFrequency
(
frequency
)
;
}
start
(
)
{
if
(
!
this
.
oscNode
)
{
throw
new
Error
(
"
Attempt
to
start
a
stopped
LoopbackTone
"
)
;
}
info
(
Start
loopback
tone
at
{
this
.
oscNode
.
frequency
.
value
}
)
;
this
.
oscNode
.
start
(
)
;
}
changeFrequency
(
frequency
)
{
if
(
!
this
.
oscNode
)
{
throw
new
Error
(
"
Attempt
to
change
frequency
on
a
stopped
LoopbackTone
"
)
;
}
this
.
oscNode
.
frequency
.
value
=
frequency
;
}
stop
(
)
{
if
(
!
this
.
oscNode
)
{
throw
new
Error
(
"
Attempt
to
stop
a
stopped
LoopbackTone
"
)
;
}
this
.
oscNode
.
stop
(
)
;
this
.
oscNode
=
null
;
}
}
var
DefaultLoopbackTone
=
null
;
function
AudioStreamAnalyser
(
ac
stream
)
{
this
.
audioContext
=
ac
;
this
.
stream
=
stream
;
this
.
sourceNodes
=
[
]
;
this
.
analyser
=
this
.
audioContext
.
createAnalyser
(
)
;
this
.
analyser
.
smoothingTimeConstant
=
0
.
2
;
this
.
analyser
.
fftSize
=
1024
;
this
.
connectTrack
=
t
=
>
{
let
source
=
this
.
audioContext
.
createMediaStreamSource
(
new
MediaStream
(
[
t
]
)
)
;
this
.
sourceNodes
.
push
(
source
)
;
source
.
connect
(
this
.
analyser
)
;
}
;
this
.
stream
.
getAudioTracks
(
)
.
forEach
(
t
=
>
this
.
connectTrack
(
t
)
)
;
this
.
onaddtrack
=
ev
=
>
this
.
connectTrack
(
ev
.
track
)
;
this
.
stream
.
addEventListener
(
"
addtrack
"
this
.
onaddtrack
)
;
this
.
data
=
new
Uint8Array
(
this
.
analyser
.
frequencyBinCount
)
;
}
AudioStreamAnalyser
.
prototype
=
{
getByteFrequencyData
(
)
{
this
.
analyser
.
getByteFrequencyData
(
this
.
data
)
;
return
this
.
data
;
}
enableDebugCanvas
(
)
{
var
cvs
=
(
this
.
debugCanvas
=
document
.
createElement
(
"
canvas
"
)
)
;
const
content
=
document
.
getElementById
(
"
content
"
)
;
content
.
insertBefore
(
cvs
content
.
children
[
0
]
)
;
cvs
.
width
=
this
.
analyser
.
frequencyBinCount
;
cvs
.
height
=
128
;
cvs
.
style
.
border
=
"
1px
solid
red
"
;
var
c
=
cvs
.
getContext
(
"
2d
"
)
;
c
.
fillStyle
=
"
black
"
;
var
self
=
this
;
function
render
(
)
{
c
.
clearRect
(
0
0
cvs
.
width
cvs
.
height
)
;
var
array
=
self
.
getByteFrequencyData
(
)
;
for
(
var
i
=
0
;
i
<
array
.
length
;
i
+
+
)
{
c
.
fillRect
(
i
cvs
.
height
-
array
[
i
]
/
2
1
cvs
.
height
)
;
}
if
(
!
cvs
.
stopDrawing
)
{
requestAnimationFrame
(
render
)
;
}
}
requestAnimationFrame
(
render
)
;
}
disableDebugCanvas
(
)
{
if
(
!
this
.
debugCanvas
|
|
!
this
.
debugCanvas
.
parentElement
)
{
return
;
}
this
.
debugCanvas
.
stopDrawing
=
true
;
this
.
debugCanvas
.
parentElement
.
removeChild
(
this
.
debugCanvas
)
;
}
disconnect
(
)
{
this
.
disableDebugCanvas
(
)
;
this
.
sourceNodes
.
forEach
(
n
=
>
n
.
disconnect
(
)
)
;
this
.
sourceNodes
=
[
]
;
this
.
stream
.
removeEventListener
(
"
addtrack
"
this
.
onaddtrack
)
;
}
async
waitForAnalysisSuccess
(
analysisFunction
cancel
=
wait
(
60000
new
Error
(
"
Audio
analysis
timed
out
"
)
)
)
{
let
aborted
=
false
;
cancel
.
then
(
(
)
=
>
(
aborted
=
true
)
)
;
await
wait
(
200
)
;
do
{
await
new
Promise
(
resolve
=
>
requestAnimationFrame
(
resolve
)
)
;
if
(
aborted
)
{
throw
await
cancel
;
}
}
while
(
!
analysisFunction
(
this
.
getByteFrequencyData
(
)
)
)
;
}
binIndexForFrequency
(
frequency
)
{
return
(
1
+
Math
.
round
(
(
frequency
*
this
.
analyser
.
fftSize
)
/
this
.
audioContext
.
sampleRate
)
)
;
}
frequencyForBinIndex
(
index
)
{
return
(
(
index
-
1
)
*
this
.
audioContext
.
sampleRate
)
/
this
.
analyser
.
fftSize
;
}
}
;
function
createOscillatorStream
(
ac
frequency
)
{
var
osc
=
ac
.
createOscillator
(
)
;
osc
.
frequency
.
value
=
frequency
;
var
oscDest
=
ac
.
createMediaStreamDestination
(
)
;
osc
.
connect
(
oscDest
)
;
osc
.
start
(
)
;
return
oscDest
.
stream
;
}
function
realCreateHTML
(
meta
)
{
var
test
=
document
.
getElementById
(
"
test
"
)
;
var
elem
=
document
.
createElement
(
"
meta
"
)
;
elem
.
setAttribute
(
"
charset
"
"
utf
-
8
"
)
;
document
.
head
.
appendChild
(
elem
)
;
var
title
=
document
.
createElement
(
"
title
"
)
;
title
.
textContent
=
meta
.
title
;
document
.
head
.
appendChild
(
title
)
;
var
anchor
=
document
.
createElement
(
"
a
"
)
;
anchor
.
textContent
=
meta
.
title
;
if
(
meta
.
bug
)
{
anchor
.
setAttribute
(
"
href
"
"
https
:
/
/
bugzilla
.
mozilla
.
org
/
show_bug
.
cgi
?
id
=
"
+
meta
.
bug
)
;
}
else
{
anchor
.
setAttribute
(
"
target
"
"
_blank
"
)
;
}
document
.
body
.
insertBefore
(
anchor
test
)
;
var
display
=
document
.
createElement
(
"
p
"
)
;
display
.
setAttribute
(
"
id
"
"
display
"
)
;
document
.
body
.
insertBefore
(
display
test
)
;
var
content
=
document
.
createElement
(
"
div
"
)
;
content
.
setAttribute
(
"
id
"
"
content
"
)
;
content
.
style
.
display
=
meta
.
visible
?
"
block
"
:
"
none
"
;
document
.
body
.
appendChild
(
content
)
;
}
function
createMediaElement
(
type
id
)
{
const
element
=
document
.
createElement
(
type
)
;
element
.
setAttribute
(
"
id
"
id
)
;
element
.
setAttribute
(
"
height
"
100
)
;
element
.
setAttribute
(
"
width
"
150
)
;
element
.
setAttribute
(
"
controls
"
"
controls
"
)
;
element
.
setAttribute
(
"
autoplay
"
"
autoplay
"
)
;
element
.
setAttribute
(
"
muted
"
"
muted
"
)
;
element
.
muted
=
true
;
document
.
getElementById
(
"
content
"
)
.
appendChild
(
element
)
;
return
element
;
}
function
getMediaElementForTrack
(
track
idPrefix
)
{
return
document
.
getElementById
(
idPrefix
+
"
_
"
+
track
.
id
)
;
}
function
createMediaElementForTrack
(
track
idPrefix
)
{
const
id
=
idPrefix
+
"
_
"
+
track
.
id
;
const
element
=
createMediaElement
(
track
.
kind
id
)
;
element
.
srcObject
=
new
MediaStream
(
[
track
]
)
;
return
element
;
}
function
getUserMedia
(
constraints
)
{
updateConfigFromFakeAndLoopbackPrefs
(
)
;
if
(
!
WANT_FAKE_AUDIO
&
&
!
constraints
.
fake
&
&
constraints
.
audio
&
&
!
DISABLE_LOOPBACK_TONE
)
{
if
(
!
DefaultLoopbackTone
)
{
DefaultLoopbackTone
=
new
LoopbackTone
(
new
AudioContext
(
)
TEST_AUDIO_FREQ
)
;
DefaultLoopbackTone
.
start
(
)
;
}
constraints
.
audio
=
Object
.
assign
(
{
}
{
autoGainControl
:
false
}
{
echoCancellation
:
false
}
{
noiseSuppression
:
false
}
constraints
.
audio
)
;
}
info
(
"
Call
getUserMedia
for
"
+
JSON
.
stringify
(
constraints
)
)
;
return
navigator
.
mediaDevices
.
getUserMedia
(
constraints
)
.
then
(
stream
=
>
(
checkMediaStreamTracks
(
constraints
stream
)
stream
)
)
;
}
var
setTestOptions
;
var
testConfigured
=
new
Promise
(
r
=
>
(
setTestOptions
=
r
)
)
;
function
pushPrefs
(
.
.
.
p
)
{
return
SpecialPowers
.
pushPrefEnv
(
{
set
:
p
}
)
;
}
async
function
withPrefs
(
prefs
func
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
prefs
}
)
;
try
{
return
await
func
(
)
;
}
finally
{
await
SpecialPowers
.
popPrefEnv
(
)
;
}
}
function
setupEnvironment
(
)
{
var
defaultMochitestPrefs
=
{
set
:
[
[
"
media
.
peerconnection
.
enabled
"
true
]
[
"
media
.
peerconnection
.
identity
.
timeout
"
120000
]
[
"
media
.
peerconnection
.
ice
.
stun_client_maximum_transmits
"
14
]
[
"
media
.
peerconnection
.
ice
.
trickle_grace_period
"
30000
]
[
"
media
.
navigator
.
permission
.
disabled
"
true
]
[
"
media
.
navigator
.
streams
.
fake
"
WANT_FAKE_AUDIO
|
|
WANT_FAKE_VIDEO
]
[
"
media
.
getusermedia
.
audiocapture
.
enabled
"
true
]
[
"
media
.
getusermedia
.
screensharing
.
enabled
"
true
]
[
"
media
.
getusermedia
.
window
.
focus_source
.
enabled
"
false
]
[
"
media
.
recorder
.
audio_node
.
enabled
"
true
]
[
"
media
.
peerconnection
.
ice
.
obfuscate_host_addresses
"
false
]
[
"
media
.
peerconnection
.
nat_simulator
.
filtering_type
"
"
"
]
[
"
media
.
peerconnection
.
nat_simulator
.
mapping_type
"
"
"
]
[
"
media
.
peerconnection
.
nat_simulator
.
block_tcp
"
false
]
[
"
media
.
peerconnection
.
nat_simulator
.
block_udp
"
false
]
[
"
media
.
peerconnection
.
nat_simulator
.
redirect_address
"
"
"
]
[
"
media
.
peerconnection
.
nat_simulator
.
redirect_targets
"
"
"
]
]
}
;
if
(
navigator
.
userAgent
.
includes
(
"
Android
"
)
)
{
defaultMochitestPrefs
.
set
.
push
(
[
"
media
.
navigator
.
video
.
default_width
"
320
]
[
"
media
.
navigator
.
video
.
default_height
"
240
]
[
"
media
.
navigator
.
video
.
max_fr
"
10
]
[
"
media
.
autoplay
.
default
"
Ci
.
nsIAutoplay
.
ALLOWED
]
)
;
}
const
platformEncoderEnabled
=
SpecialPowers
.
getBoolPref
(
"
media
.
webrtc
.
platformencoder
"
)
;
defaultMochitestPrefs
.
set
.
push
(
[
"
media
.
navigator
.
mediadatadecoder_h264_enabled
"
platformEncoderEnabled
]
)
;
SimpleTest
.
requestFlakyTimeout
(
"
WebRTC
inherently
depends
on
timeouts
"
)
;
window
.
finish
=
(
)
=
>
SimpleTest
.
finish
(
)
;
SpecialPowers
.
pushPrefEnv
(
defaultMochitestPrefs
setTestOptions
)
;
SpecialPowers
.
exactGC
(
)
;
}
async
function
matchPlatformH264CodecPrefs
(
)
{
const
hasHW264
=
SpecialPowers
.
getBoolPref
(
"
media
.
webrtc
.
platformencoder
"
)
&
&
!
SpecialPowers
.
getBoolPref
(
"
media
.
webrtc
.
platformencoder
.
sw_only
"
)
&
&
(
navigator
.
userAgent
.
includes
(
"
Android
"
)
|
|
navigator
.
userAgent
.
includes
(
"
Mac
OS
X
"
)
)
;
await
pushPrefs
(
[
"
media
.
webrtc
.
platformencoder
"
hasHW264
]
[
"
media
.
navigator
.
mediadatadecoder_h264_enabled
"
hasHW264
]
)
;
}
async
function
runTestWhenReady
(
testFunc
)
{
setupEnvironment
(
)
;
const
options
=
await
testConfigured
;
try
{
await
testFunc
(
options
)
;
}
catch
(
e
)
{
ok
(
false
Error
executing
test
:
{
e
}
{
e
.
stack
?
e
.
stack
:
"
"
}
)
;
}
finally
{
SimpleTest
.
finish
(
)
;
}
}
function
checkMediaStreamTracksByType
(
constraints
type
mediaStreamTracks
)
{
if
(
constraints
[
type
]
)
{
is
(
mediaStreamTracks
.
length
1
"
One
"
+
type
+
"
track
shall
be
present
"
)
;
if
(
mediaStreamTracks
.
length
)
{
is
(
mediaStreamTracks
[
0
]
.
kind
type
"
Track
kind
should
be
"
+
type
)
;
ok
(
mediaStreamTracks
[
0
]
.
id
"
Track
id
should
be
defined
"
)
;
ok
(
!
mediaStreamTracks
[
0
]
.
muted
"
Track
should
not
be
muted
"
)
;
}
}
else
{
is
(
mediaStreamTracks
.
length
0
"
No
"
+
type
+
"
tracks
shall
be
present
"
)
;
}
}
function
checkMediaStreamTracks
(
constraints
mediaStream
)
{
checkMediaStreamTracksByType
(
constraints
"
audio
"
mediaStream
.
getAudioTracks
(
)
)
;
checkMediaStreamTracksByType
(
constraints
"
video
"
mediaStream
.
getVideoTracks
(
)
)
;
}
function
checkMediaStreamContains
(
mediaStream
tracks
message
)
{
message
=
message
?
message
+
"
:
"
:
"
"
;
tracks
.
forEach
(
t
=
>
ok
(
mediaStream
.
getTrackById
(
t
.
id
)
message
+
"
MediaStream
"
+
mediaStream
.
id
+
"
contains
track
"
+
t
.
id
)
)
;
is
(
mediaStream
.
getTracks
(
)
.
length
tracks
.
length
message
+
"
MediaStream
"
+
mediaStream
.
id
+
"
contains
no
extra
tracks
"
)
;
}
function
checkMediaStreamCloneAgainstOriginal
(
clone
original
)
{
isnot
(
clone
.
id
.
length
0
"
Stream
clone
should
have
an
id
string
"
)
;
isnot
(
clone
original
"
Stream
clone
should
be
different
from
the
original
"
)
;
isnot
(
clone
.
id
original
.
id
"
Stream
clone
'
s
id
should
be
different
from
the
original
'
s
"
)
;
is
(
clone
.
getAudioTracks
(
)
.
length
original
.
getAudioTracks
(
)
.
length
"
All
audio
tracks
should
get
cloned
"
)
;
is
(
clone
.
getVideoTracks
(
)
.
length
original
.
getVideoTracks
(
)
.
length
"
All
video
tracks
should
get
cloned
"
)
;
is
(
clone
.
active
original
.
active
"
Active
state
should
be
preserved
"
)
;
original
.
getTracks
(
)
.
forEach
(
t
=
>
ok
(
!
clone
.
getTrackById
(
t
.
id
)
"
The
clone
'
s
tracks
should
be
originals
"
)
)
;
}
function
checkMediaStreamTrackCloneAgainstOriginal
(
clone
original
)
{
isnot
(
clone
.
id
.
length
0
"
Track
clone
should
have
an
id
string
"
)
;
isnot
(
clone
original
"
Track
clone
should
be
different
from
the
original
"
)
;
isnot
(
clone
.
id
original
.
id
"
Track
clone
'
s
id
should
be
different
from
the
original
'
s
"
)
;
is
(
clone
.
kind
original
.
kind
"
Track
clone
'
s
kind
should
be
same
as
the
original
'
s
"
)
;
is
(
clone
.
enabled
original
.
enabled
"
Track
clone
'
s
kind
should
be
same
as
the
original
'
s
"
)
;
is
(
clone
.
readyState
original
.
readyState
"
Track
clone
'
s
readyState
should
be
same
as
the
original
'
s
"
)
;
is
(
clone
.
muted
original
.
muted
"
Track
clone
'
s
muted
state
should
be
same
as
the
original
'
s
"
)
;
}
function
wait
(
time
message
)
{
return
new
Promise
(
r
=
>
setTimeout
(
(
)
=
>
r
(
message
)
time
)
)
;
}
function
waitUntil
(
func
time
)
{
return
new
Promise
(
resolve
=
>
{
var
interval
=
setInterval
(
(
)
=
>
{
if
(
func
(
)
)
{
clearInterval
(
interval
)
;
resolve
(
)
;
}
}
time
|
|
200
)
;
}
)
;
}
var
timeout
=
(
promise
time
msg
)
=
>
Promise
.
race
(
[
promise
wait
(
time
)
.
then
(
(
)
=
>
Promise
.
reject
(
new
Error
(
msg
)
)
)
]
)
;
var
addFinallyToPromise
=
promise
=
>
{
promise
.
finally
=
func
=
>
{
return
promise
.
then
(
result
=
>
{
func
(
)
;
return
Promise
.
resolve
(
result
)
;
}
error
=
>
{
func
(
)
;
return
Promise
.
reject
(
error
)
;
}
)
;
}
;
return
promise
;
}
;
var
listenUntil
=
(
target
eventName
onFire
)
=
>
{
return
new
Promise
(
resolve
=
>
target
.
addEventListener
(
eventName
function
callback
(
event
)
{
var
result
=
onFire
(
event
)
;
if
(
result
)
{
target
.
removeEventListener
(
eventName
callback
)
;
resolve
(
result
)
;
}
}
)
)
;
}
;
function
mustThrowWith
(
msg
reason
f
)
{
try
{
f
(
)
;
ok
(
false
msg
+
"
must
throw
"
)
;
}
catch
(
e
)
{
is
(
e
.
name
reason
msg
+
"
must
throw
:
"
+
e
.
message
)
;
}
}
function
getSilentTrack
(
)
{
let
ctx
=
new
AudioContext
(
)
oscillator
=
ctx
.
createOscillator
(
)
;
let
dst
=
oscillator
.
connect
(
ctx
.
createMediaStreamDestination
(
)
)
;
oscillator
.
start
(
)
;
return
Object
.
assign
(
dst
.
stream
.
getAudioTracks
(
)
[
0
]
{
enabled
:
false
}
)
;
}
function
getBlackTrack
(
{
width
=
640
height
=
480
}
=
{
}
)
{
let
canvas
=
Object
.
assign
(
document
.
createElement
(
"
canvas
"
)
{
width
height
}
)
;
canvas
.
getContext
(
"
2d
"
)
.
fillRect
(
0
0
width
height
)
;
let
stream
=
canvas
.
captureStream
(
)
;
return
Object
.
assign
(
stream
.
getVideoTracks
(
)
[
0
]
{
enabled
:
false
}
)
;
}
function
generateErrorCallback
(
message
)
{
var
stack
=
new
Error
(
)
.
stack
.
split
(
"
\
n
"
)
;
stack
.
shift
(
)
;
return
aObj
=
>
{
if
(
aObj
)
{
if
(
aObj
.
name
&
&
aObj
.
message
)
{
ok
(
false
"
Unexpected
callback
for
'
"
+
aObj
.
name
+
"
'
with
message
=
'
"
+
aObj
.
message
+
"
'
at
"
+
JSON
.
stringify
(
stack
)
)
;
}
else
{
ok
(
false
"
Unexpected
callback
with
=
'
"
+
aObj
+
"
'
at
:
"
+
JSON
.
stringify
(
stack
)
)
;
}
}
else
{
ok
(
false
"
Unexpected
callback
with
message
=
'
"
+
message
+
"
'
at
:
"
+
JSON
.
stringify
(
stack
)
)
;
}
throw
new
Error
(
"
Unexpected
callback
"
)
;
}
;
}
var
unexpectedEventArrived
;
var
rejectOnUnexpectedEvent
=
new
Promise
(
(
x
reject
)
=
>
{
unexpectedEventArrived
=
reject
;
}
)
;
function
unexpectedEvent
(
message
eventName
)
{
var
stack
=
new
Error
(
)
.
stack
.
split
(
"
\
n
"
)
;
stack
.
shift
(
)
;
return
e
=
>
{
var
details
=
"
Unexpected
event
'
"
+
eventName
+
"
'
fired
with
message
=
'
"
+
message
+
"
'
at
:
"
+
JSON
.
stringify
(
stack
)
;
ok
(
false
details
)
;
unexpectedEventArrived
(
new
Error
(
details
)
)
;
}
;
}
function
createOneShotEventWrapper
(
wrapper
obj
event
)
{
var
onx
=
"
on
"
+
event
;
var
unexpected
=
unexpectedEvent
(
wrapper
event
)
;
wrapper
[
onx
]
=
unexpected
;
obj
[
onx
]
=
e
=
>
{
info
(
wrapper
+
'
:
"
on
'
+
event
+
'
"
event
fired
'
)
;
e
.
wrapper
=
wrapper
;
wrapper
[
onx
]
(
e
)
;
wrapper
[
onx
]
=
unexpected
;
}
;
}
function
haveEvents
(
target
name
count
cancel
)
{
var
listener
;
var
counter
=
count
|
|
1
;
return
Promise
.
race
(
[
(
cancel
|
|
new
Promise
(
(
)
=
>
{
}
)
)
.
then
(
e
=
>
Promise
.
reject
(
e
)
)
new
Promise
(
resolve
=
>
target
.
addEventListener
(
name
(
listener
=
e
=
>
-
-
counter
<
1
&
&
resolve
(
e
)
)
)
)
]
)
.
then
(
e
=
>
(
target
.
removeEventListener
(
name
listener
)
e
)
)
;
}
function
haveEvent
(
target
name
cancel
)
{
return
haveEvents
(
target
name
1
cancel
)
;
}
function
haveNoEvent
(
target
name
timeoutPromise
)
{
return
haveEvent
(
target
name
timeoutPromise
|
|
wait
(
0
)
)
.
then
(
(
)
=
>
Promise
.
reject
(
new
Error
(
"
Too
many
"
+
name
+
"
events
"
)
)
(
)
=
>
{
}
)
;
}
function
haveEventsButNoMore
(
target
name
count
cancel
)
{
return
haveEvents
(
target
name
count
cancel
)
.
then
(
e
=
>
haveNoEvent
(
target
name
)
.
then
(
(
)
=
>
e
)
)
;
}
const
collectMemoryUsage
=
async
path
=
>
{
const
MemoryReporterManager
=
Cc
[
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIMemoryReporterManager
)
;
let
usage
=
0
;
let
reportCount
=
0
;
await
new
Promise
(
resolve
=
>
MemoryReporterManager
.
getReports
(
(
aProcess
aPath
aKind
aUnits
aAmount
aDesc
)
=
>
{
if
(
aPath
!
=
path
)
{
return
;
}
+
+
reportCount
;
usage
+
=
aAmount
;
}
null
resolve
null
false
)
)
;
return
{
usage
reportCount
}
;
}
;
const
dnsLookup
=
async
hostname
=
>
{
const
neckoDashboard
=
SpecialPowers
.
Cc
[
"
mozilla
.
org
/
network
/
dashboard
;
1
"
]
.
getService
(
Ci
.
nsIDashboard
)
;
const
results
=
await
new
Promise
(
r
=
>
{
neckoDashboard
.
requestDNSLookup
(
hostname
results
=
>
{
r
(
SpecialPowers
.
wrap
(
results
)
)
;
}
)
;
}
)
;
const
addresses
=
[
.
.
.
results
.
address
]
;
info
(
DNS
results
for
{
hostname
}
:
{
JSON
.
stringify
(
addresses
)
}
)
;
return
addresses
;
}
;
const
dnsLookupV4
=
async
hostname
=
>
{
const
addresses
=
await
dnsLookup
(
hostname
)
;
return
addresses
.
filter
(
address
=
>
!
address
.
includes
(
"
:
"
)
)
;
}
;
const
dnsLookupV6
=
async
hostname
=
>
{
const
addresses
=
await
dnsLookup
(
hostname
)
;
return
addresses
.
filter
(
address
=
>
address
.
includes
(
"
:
"
)
)
;
}
;
const
getTurnHostname
=
turnUrl
=
>
{
const
urlNoParams
=
turnUrl
.
split
(
"
?
"
)
[
0
]
;
const
hostAndMaybePort
=
urlNoParams
.
split
(
"
:
"
2
)
[
1
]
;
if
(
hostAndMaybePort
[
0
]
=
=
"
[
"
)
{
return
hostAndMaybePort
.
substring
(
1
)
.
split
(
"
]
"
)
[
0
]
;
}
return
hostAndMaybePort
.
split
(
"
:
"
)
[
0
]
;
}
;
const
GleanTest
=
new
Proxy
(
{
}
{
get
(
target
categoryName
receiver
)
{
return
new
Proxy
(
{
}
{
get
(
target
metricName
receiver
)
{
return
new
Proxy
(
{
async
testGetValue
(
)
{
return
SpecialPowers
.
spawnChrome
(
[
categoryName
metricName
]
async
(
categoryName
metricName
)
=
>
{
await
Services
.
fog
.
testFlushAllChildren
(
)
;
const
window
=
this
.
browsingContext
.
topChromeWindow
;
return
window
.
Glean
[
categoryName
]
[
metricName
]
.
testGetValue
(
)
;
}
)
;
}
}
{
get
(
target
prop
receiver
)
{
if
(
prop
in
target
)
{
return
target
[
prop
]
;
}
const
label
=
prop
;
return
{
async
testGetValue
(
)
{
return
SpecialPowers
.
spawnChrome
(
[
categoryName
metricName
label
]
async
(
categoryName
metricName
label
)
=
>
{
await
Services
.
fog
.
testFlushAllChildren
(
)
;
const
window
=
this
.
browsingContext
.
topChromeWindow
;
return
window
.
Glean
[
categoryName
]
[
metricName
]
[
label
]
.
testGetValue
(
)
;
}
)
;
}
}
;
}
}
)
;
}
}
)
;
}
}
)
;
function
CommandChain
(
framework
commandList
)
{
this
.
_framework
=
framework
;
this
.
commands
=
commandList
|
|
[
]
;
}
CommandChain
.
prototype
=
{
execute
(
)
{
return
this
.
commands
.
reduce
(
(
prev
next
i
)
=
>
{
if
(
typeof
next
!
=
=
"
function
"
|
|
!
next
.
name
)
{
throw
new
Error
(
"
registered
non
-
function
"
+
next
)
;
}
return
prev
.
then
(
(
)
=
>
{
info
(
"
Run
step
"
+
(
i
+
1
)
+
"
:
"
+
next
.
name
)
;
return
Promise
.
race
(
[
next
(
this
.
_framework
)
rejectOnUnexpectedEvent
]
)
;
}
)
;
}
Promise
.
resolve
(
)
)
.
catch
(
e
=
>
ok
(
false
"
Error
in
test
execution
:
"
+
e
+
(
typeof
e
.
stack
=
=
=
"
string
"
?
"
"
+
e
.
stack
.
split
(
"
\
n
"
)
.
join
(
"
.
.
.
"
)
:
"
"
)
)
)
;
}
append
(
commands
)
{
this
.
commands
=
this
.
commands
.
concat
(
commands
)
;
}
indexOf
(
functionOrName
occurrence
)
{
occurrence
=
occurrence
|
|
0
;
return
this
.
commands
.
findIndex
(
func
=
>
{
if
(
typeof
functionOrName
=
=
=
"
string
"
)
{
if
(
func
.
name
!
=
=
functionOrName
)
{
return
false
;
}
}
else
if
(
func
!
=
=
functionOrName
)
{
return
false
;
}
if
(
occurrence
)
{
-
-
occurrence
;
return
false
;
}
return
true
;
}
)
;
}
mustHaveIndexOf
(
functionOrName
occurrence
)
{
var
index
=
this
.
indexOf
(
functionOrName
occurrence
)
;
if
(
index
=
=
-
1
)
{
throw
new
Error
(
"
Unknown
test
:
"
+
functionOrName
)
;
}
return
index
;
}
insertAfter
(
functionOrName
commands
all
occurrence
)
{
this
.
_insertHelper
(
functionOrName
commands
1
all
occurrence
)
;
}
insertAfterEach
(
functionOrName
commands
)
{
this
.
_insertHelper
(
functionOrName
commands
1
true
)
;
}
insertBefore
(
functionOrName
commands
all
occurrence
)
{
this
.
_insertHelper
(
functionOrName
commands
0
all
occurrence
)
;
}
_insertHelper
(
functionOrName
commands
delta
all
occurrence
)
{
occurrence
=
occurrence
|
|
0
;
for
(
var
index
=
this
.
mustHaveIndexOf
(
functionOrName
occurrence
)
;
index
!
=
=
-
1
;
index
=
this
.
indexOf
(
functionOrName
+
+
occurrence
)
)
{
this
.
commands
=
[
]
.
concat
(
this
.
commands
.
slice
(
0
index
+
delta
)
commands
this
.
commands
.
slice
(
index
+
delta
)
)
;
if
(
!
all
)
{
break
;
}
}
}
remove
(
functionOrName
occurrence
)
{
return
this
.
commands
.
splice
(
this
.
mustHaveIndexOf
(
functionOrName
occurrence
)
1
)
;
}
removeAfter
(
functionOrName
occurrence
)
{
return
this
.
commands
.
splice
(
this
.
mustHaveIndexOf
(
functionOrName
occurrence
)
+
1
)
;
}
removeBefore
(
functionOrName
occurrence
)
{
return
this
.
commands
.
splice
(
0
this
.
mustHaveIndexOf
(
functionOrName
occurrence
)
)
;
}
replace
(
functionOrName
commands
)
{
this
.
insertBefore
(
functionOrName
commands
)
;
return
this
.
remove
(
functionOrName
)
;
}
replaceAfter
(
functionOrName
commands
occurrence
)
{
var
oldCommands
=
this
.
removeAfter
(
functionOrName
occurrence
)
;
this
.
append
(
commands
)
;
return
oldCommands
;
}
replaceBefore
(
functionOrName
commands
)
{
var
oldCommands
=
this
.
removeBefore
(
functionOrName
)
;
this
.
insertBefore
(
functionOrName
commands
)
;
return
oldCommands
;
}
filterOut
(
id_match
)
{
this
.
commands
=
this
.
commands
.
filter
(
c
=
>
!
id_match
.
test
(
c
.
name
)
)
;
}
}
;
function
AudioStreamHelper
(
)
{
this
.
_context
=
new
AudioContext
(
)
;
}
AudioStreamHelper
.
prototype
=
{
checkAudio
(
stream
analyser
fun
)
{
return
analyser
.
waitForAnalysisSuccess
(
fun
)
;
}
checkAudioFlowing
(
stream
)
{
var
analyser
=
new
AudioStreamAnalyser
(
this
.
_context
stream
)
;
var
freq
=
analyser
.
binIndexForFrequency
(
TEST_AUDIO_FREQ
)
;
return
this
.
checkAudio
(
stream
analyser
array
=
>
array
[
freq
]
>
200
)
;
}
checkAudioNotFlowing
(
stream
)
{
var
analyser
=
new
AudioStreamAnalyser
(
this
.
_context
stream
)
;
var
freq
=
analyser
.
binIndexForFrequency
(
TEST_AUDIO_FREQ
)
;
return
this
.
checkAudio
(
stream
analyser
array
=
>
array
[
freq
]
<
50
)
;
}
}
;
class
VideoFrameEmitter
{
constructor
(
color1
color2
width
height
)
{
if
(
!
width
)
{
width
=
50
;
}
if
(
!
height
)
{
height
=
width
;
}
this
.
_helper
=
new
CaptureStreamTestHelper2D
(
width
height
)
;
this
.
_canvas
=
this
.
_helper
.
createAndAppendElement
(
"
canvas
"
"
source_canvas
"
)
;
this
.
_canvas
.
width
=
width
;
this
.
_canvas
.
height
=
height
;
this
.
_color1
=
color1
?
color1
:
this
.
_helper
.
green
;
this
.
_color2
=
color2
?
color2
:
this
.
_helper
.
red
;
this
.
_helper
.
drawColor
(
this
.
_canvas
this
.
_color1
)
;
this
.
_stream
=
this
.
_canvas
.
captureStream
(
)
;
this
.
_started
=
false
;
}
stream
(
)
{
return
this
.
_stream
;
}
helper
(
)
{
return
this
.
_helper
;
}
colors
(
color1
color2
)
{
this
.
_color1
=
color1
?
color1
:
this
.
_helper
.
green
;
this
.
_color2
=
color2
?
color2
:
this
.
_helper
.
red
;
try
{
this
.
_helper
.
drawColor
(
this
.
_canvas
this
.
_color1
)
;
}
catch
(
e
)
{
}
}
size
(
width
height
)
{
this
.
_canvas
.
width
=
width
;
this
.
_canvas
.
height
=
height
;
}
start
(
)
{
if
(
this
.
_started
)
{
info
(
"
*
*
*
emitter
already
started
"
)
;
return
;
}
let
i
=
0
;
this
.
_started
=
true
;
this
.
_intervalId
=
setInterval
(
(
)
=
>
{
try
{
this
.
_helper
.
drawColor
(
this
.
_canvas
i
?
this
.
_color1
:
this
.
_color2
)
;
i
=
1
-
i
;
}
catch
(
e
)
{
}
}
500
)
;
}
stop
(
)
{
if
(
this
.
_started
)
{
clearInterval
(
this
.
_intervalId
)
;
this
.
_started
=
false
;
}
}
}
class
VideoStreamHelper
{
constructor
(
)
{
this
.
_helper
=
new
CaptureStreamTestHelper2D
(
50
50
)
;
}
async
checkHasFrame
(
video
{
offsetX
offsetY
threshold
}
=
{
}
)
{
const
h
=
this
.
_helper
;
await
h
.
waitForPixel
(
video
px
=
>
{
let
result
=
h
.
isOpaquePixelNot
(
px
h
.
black
threshold
)
;
info
(
"
Checking
that
we
have
a
frame
got
[
"
+
Array
.
from
(
px
)
+
"
]
.
Ref
=
[
"
+
Array
.
from
(
h
.
black
.
data
)
+
"
]
.
Threshold
=
"
+
threshold
+
"
.
Pass
=
"
+
result
)
;
return
result
;
}
{
offsetX
offsetY
}
)
;
}
async
checkVideoPlaying
(
video
{
offsetX
=
10
offsetY
=
10
threshold
=
16
}
=
{
}
)
{
const
h
=
this
.
_helper
;
await
this
.
checkHasFrame
(
video
{
offsetX
offsetY
threshold
}
)
;
let
startPixel
=
{
data
:
h
.
getPixel
(
video
offsetX
offsetY
)
name
:
"
startcolor
"
}
;
await
h
.
waitForPixel
(
video
px
=
>
{
let
result
=
h
.
isPixelNot
(
px
startPixel
threshold
)
;
info
(
"
Checking
playing
[
"
+
Array
.
from
(
px
)
+
"
]
vs
[
"
+
Array
.
from
(
startPixel
.
data
)
+
"
]
.
Threshold
=
"
+
threshold
+
"
Pass
=
"
+
result
)
;
return
result
;
}
{
offsetX
offsetY
}
)
;
}
async
checkVideoPaused
(
video
{
offsetX
=
10
offsetY
=
10
threshold
=
16
time
=
5000
}
=
{
}
)
{
const
h
=
this
.
_helper
;
await
this
.
checkHasFrame
(
video
{
offsetX
offsetY
threshold
}
)
;
let
startPixel
=
{
data
:
h
.
getPixel
(
video
offsetX
offsetY
)
name
:
"
startcolor
"
}
;
try
{
await
h
.
waitForPixel
(
video
px
=
>
{
let
result
=
h
.
isOpaquePixelNot
(
px
startPixel
threshold
)
;
info
(
"
Checking
paused
[
"
+
Array
.
from
(
px
)
+
"
]
vs
[
"
+
Array
.
from
(
startPixel
.
data
)
+
"
]
.
Threshold
=
"
+
threshold
+
"
Pass
=
"
+
result
)
;
return
result
;
}
{
offsetX
offsetY
cancel
:
wait
(
time
"
timeout
"
)
}
)
;
ok
(
false
"
Frame
changed
within
"
+
time
/
1000
+
"
seconds
"
)
;
}
catch
(
e
)
{
is
(
e
"
timeout
"
"
Frame
shouldn
'
t
change
for
"
+
time
/
1000
+
"
seconds
"
)
;
}
}
}
(
function
(
)
{
var
el
=
document
.
createElement
(
"
link
"
)
;
el
.
rel
=
"
stylesheet
"
;
el
.
type
=
"
text
/
css
"
;
el
.
href
=
"
/
tests
/
SimpleTest
/
test
.
css
"
;
document
.
head
.
appendChild
(
el
)
;
}
)
(
)
;
