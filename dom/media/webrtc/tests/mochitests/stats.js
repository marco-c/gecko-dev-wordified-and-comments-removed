"
use
strict
"
;
const
statsExpectedByType
=
{
"
inbound
-
rtp
"
:
{
expected
:
[
"
trackIdentifier
"
"
id
"
"
timestamp
"
"
type
"
"
ssrc
"
"
mediaType
"
"
kind
"
"
codecId
"
"
packetsReceived
"
"
packetsLost
"
"
packetsDiscarded
"
"
bytesReceived
"
"
jitter
"
"
lastPacketReceivedTimestamp
"
"
headerBytesReceived
"
"
jitterBufferDelay
"
"
jitterBufferEmittedCount
"
]
optional
:
[
"
remoteId
"
"
nackCount
"
"
qpSum
"
]
localVideoOnly
:
[
"
firCount
"
"
pliCount
"
"
framesDecoded
"
"
framesDropped
"
"
discardedPackets
"
"
framesPerSecond
"
"
frameWidth
"
"
frameHeight
"
"
framesReceived
"
"
totalDecodeTime
"
"
totalInterFrameDelay
"
"
totalProcessingDelay
"
"
totalSquaredInterFrameDelay
"
]
localAudioOnly
:
[
"
totalSamplesReceived
"
"
fecPacketsReceived
"
"
fecPacketsDiscarded
"
"
concealedSamples
"
"
silentConcealedSamples
"
"
concealmentEvents
"
"
insertedSamplesForDeceleration
"
"
removedSamplesForAcceleration
"
"
audioLevel
"
"
totalAudioEnergy
"
"
totalSamplesDuration
"
]
unimplemented
:
[
"
mediaTrackId
"
"
transportId
"
"
associateStatsId
"
"
sliCount
"
"
packetsRepaired
"
"
fractionLost
"
"
burstPacketsLost
"
"
burstLossCount
"
"
burstDiscardCount
"
"
gapDiscardRate
"
"
gapLossRate
"
]
deprecated
:
[
"
mozRtt
"
"
isRemote
"
]
}
"
outbound
-
rtp
"
:
{
expected
:
[
"
id
"
"
timestamp
"
"
type
"
"
ssrc
"
"
mediaType
"
"
kind
"
"
codecId
"
"
packetsSent
"
"
bytesSent
"
"
remoteId
"
"
headerBytesSent
"
"
retransmittedPacketsSent
"
"
retransmittedBytesSent
"
]
optional
:
[
"
nackCount
"
"
qpSum
"
]
localAudioOnly
:
[
]
localVideoOnly
:
[
"
framesEncoded
"
"
firCount
"
"
pliCount
"
"
frameWidth
"
"
frameHeight
"
"
framesPerSecond
"
"
framesSent
"
"
hugeFramesSent
"
"
totalEncodeTime
"
"
totalEncodedBytesTarget
"
]
unimplemented
:
[
"
mediaTrackId
"
"
transportId
"
"
sliCount
"
"
targetBitrate
"
]
deprecated
:
[
"
isRemote
"
]
}
"
remote
-
inbound
-
rtp
"
:
{
expected
:
[
"
id
"
"
timestamp
"
"
type
"
"
ssrc
"
"
mediaType
"
"
kind
"
"
codecId
"
"
packetsLost
"
"
jitter
"
"
localId
"
"
totalRoundTripTime
"
"
fractionLost
"
"
roundTripTimeMeasurements
"
]
optional
:
[
"
roundTripTime
"
"
nackCount
"
"
packetsReceived
"
]
unimplemented
:
[
"
mediaTrackId
"
"
transportId
"
"
packetsDiscarded
"
"
associateStatsId
"
"
sliCount
"
"
packetsRepaired
"
"
burstPacketsLost
"
"
burstLossCount
"
"
burstDiscardCount
"
"
gapDiscardRate
"
"
gapLossRate
"
]
deprecated
:
[
"
mozRtt
"
"
isRemote
"
]
}
"
remote
-
outbound
-
rtp
"
:
{
expected
:
[
"
id
"
"
timestamp
"
"
type
"
"
ssrc
"
"
mediaType
"
"
kind
"
"
codecId
"
"
packetsSent
"
"
bytesSent
"
"
localId
"
"
remoteTimestamp
"
]
optional
:
[
"
nackCount
"
]
unimplemented
:
[
"
mediaTrackId
"
"
transportId
"
"
sliCount
"
"
targetBitrate
"
]
deprecated
:
[
"
isRemote
"
]
}
"
media
-
source
"
:
{
expected
:
[
"
id
"
"
timestamp
"
"
type
"
"
trackIdentifier
"
"
kind
"
]
unimplemented
:
[
"
audioLevel
"
"
totalAudioEnergy
"
"
totalSamplesDuration
"
"
echoReturnLoss
"
"
echoReturnLossEnhancement
"
"
droppedSamplesDuration
"
"
droppedSamplesEvents
"
"
totalCaptureDelay
"
"
totalSamplesCaptured
"
]
localAudioOnly
:
[
]
localVideoOnly
:
[
"
frames
"
"
framesPerSecond
"
"
width
"
"
height
"
]
optional
:
[
]
deprecated
:
[
]
}
csrc
:
{
skip
:
true
}
codec
:
{
expected
:
[
"
timestamp
"
"
type
"
"
id
"
"
payloadType
"
"
transportId
"
"
mimeType
"
"
clockRate
"
"
sdpFmtpLine
"
]
optional
:
[
"
codecType
"
"
channels
"
]
unimplemented
:
[
]
deprecated
:
[
]
}
"
peer
-
connection
"
:
{
skip
:
true
}
"
data
-
channel
"
:
{
skip
:
true
}
track
:
{
skip
:
true
}
transport
:
{
skip
:
true
}
"
candidate
-
pair
"
:
{
expected
:
[
"
id
"
"
timestamp
"
"
type
"
"
transportId
"
"
localCandidateId
"
"
remoteCandidateId
"
"
state
"
"
priority
"
"
nominated
"
"
writable
"
"
readable
"
"
bytesSent
"
"
bytesReceived
"
"
lastPacketSentTimestamp
"
"
lastPacketReceivedTimestamp
"
]
optional
:
[
"
selected
"
]
unimplemented
:
[
"
totalRoundTripTime
"
"
currentRoundTripTime
"
"
availableOutgoingBitrate
"
"
availableIncomingBitrate
"
"
requestsReceived
"
"
requestsSent
"
"
responsesReceived
"
"
responsesSent
"
"
retransmissionsReceived
"
"
retransmissionsSent
"
"
consentRequestsSent
"
]
deprecated
:
[
]
}
"
local
-
candidate
"
:
{
expected
:
[
"
id
"
"
timestamp
"
"
type
"
"
address
"
"
protocol
"
"
port
"
"
candidateType
"
"
priority
"
]
optional
:
[
"
relayProtocol
"
"
proxied
"
]
unimplemented
:
[
"
networkType
"
"
url
"
"
transportId
"
]
deprecated
:
[
"
candidateId
"
"
portNumber
"
"
ipAddress
"
"
componentId
"
"
mozLocalTransport
"
"
transport
"
]
}
"
remote
-
candidate
"
:
{
expected
:
[
"
id
"
"
timestamp
"
"
type
"
"
address
"
"
protocol
"
"
port
"
"
candidateType
"
"
priority
"
]
optional
:
[
"
relayProtocol
"
"
proxied
"
]
unimplemented
:
[
"
networkType
"
"
url
"
"
transportId
"
]
deprecated
:
[
"
candidateId
"
"
portNumber
"
"
ipAddress
"
"
componentId
"
"
mozLocalTransport
"
"
transport
"
]
}
certificate
:
{
skip
:
true
}
}
;
[
"
inbound
-
rtp
"
"
outbound
-
rtp
"
"
media
-
source
"
]
.
forEach
(
type
=
>
{
let
s
=
statsExpectedByType
[
type
]
;
s
.
optional
=
[
.
.
.
s
.
optional
.
.
.
s
.
localVideoOnly
.
.
.
s
.
localAudioOnly
]
;
}
)
;
function
checkExpectedFields
(
report
)
{
report
.
forEach
(
stat
=
>
{
let
expectations
=
statsExpectedByType
[
stat
.
type
]
;
ok
(
expectations
"
Stats
type
"
+
stat
.
type
+
"
was
expected
"
)
;
if
(
!
expectations
|
|
expectations
.
skip
)
{
return
;
}
expectations
.
expected
.
forEach
(
field
=
>
{
ok
(
field
in
stat
"
Expected
stat
field
"
+
stat
.
type
+
"
.
"
+
field
+
"
exists
"
)
;
}
)
;
let
allowed
=
[
.
.
.
expectations
.
expected
.
.
.
expectations
.
optional
]
;
Object
.
keys
(
stat
)
.
forEach
(
field
=
>
{
ok
(
allowed
.
includes
(
field
)
"
Stat
field
"
+
stat
.
type
+
"
.
"
+
field
+
is
allowed
.
{
JSON
.
stringify
(
stat
)
}
)
;
}
)
;
expectations
.
unimplemented
.
forEach
(
field
=
>
{
ok
(
!
Object
.
keys
(
stat
)
.
includes
(
field
)
"
Unimplemented
field
"
+
stat
.
type
+
"
.
"
+
field
+
"
does
not
exist
.
"
)
;
}
)
;
expectations
.
deprecated
.
forEach
(
field
=
>
{
ok
(
!
Object
.
keys
(
stat
)
.
includes
(
field
)
"
Deprecated
field
"
+
stat
.
type
+
"
.
"
+
field
+
"
does
not
exist
.
"
)
;
}
)
;
}
)
;
}
function
pedanticChecks
(
report
)
{
[
.
.
.
report
.
keys
(
)
]
.
forEach
(
key
=
>
is
(
report
[
key
]
undefined
Report
is
not
dictionary
like
it
lacks
a
property
for
key
{
key
}
)
)
;
report
.
forEach
(
(
statObj
mapKey
)
=
>
{
info
(
"
{
mapKey
}
=
{
JSON
.
stringify
(
statObj
null
2
)
}
)
;
}
)
;
report
.
forEach
(
(
statObj
mapKey
)
=
>
{
let
tested
=
{
}
;
let
stat
=
new
Proxy
(
statObj
{
get
(
stat
key
)
{
if
(
key
=
=
"
inner
"
)
{
return
stat
;
}
tested
[
key
]
=
true
;
return
stat
[
key
]
;
}
}
)
;
let
expectations
=
statsExpectedByType
[
stat
.
type
]
;
if
(
expectations
.
skip
)
{
return
;
}
is
(
stat
.
id
mapKey
stat
.
type
+
"
.
id
is
the
same
as
the
report
key
.
"
)
;
ok
(
stat
.
timestamp
>
=
0
stat
.
type
+
"
.
timestamp
is
not
less
than
0
"
)
;
const
date
=
new
Date
(
stat
.
timestamp
)
;
ok
(
date
.
getFullYear
(
)
>
1970
{
stat
.
type
}
.
timestamp
is
relative
to
current
time
date
=
{
date
}
)
;
if
(
[
"
inbound
-
rtp
"
"
outbound
-
rtp
"
"
remote
-
inbound
-
rtp
"
"
remote
-
outbound
-
rtp
"
]
.
includes
(
stat
.
type
)
)
{
const
isRemote
=
stat
.
type
.
startsWith
(
"
remote
-
"
)
;
ok
(
stat
.
ssrc
stat
.
type
+
"
.
ssrc
has
a
value
"
)
;
ok
(
[
"
audio
"
"
video
"
]
.
includes
(
stat
.
kind
)
stat
.
type
+
"
.
kind
is
'
audio
'
or
'
video
'
"
)
;
ok
(
[
"
audio
"
"
video
"
]
.
includes
(
stat
.
mediaType
)
stat
.
type
+
"
.
mediaType
is
'
audio
'
or
'
video
'
"
)
;
ok
(
stat
.
kind
=
=
stat
.
mediaType
"
kind
equals
legacy
mediaType
"
)
;
ok
(
stat
.
codecId
{
stat
.
type
}
.
codecId
has
a
value
)
;
ok
(
report
.
has
(
stat
.
codecId
)
codecId
{
stat
.
codecId
}
exists
in
report
)
;
is
(
report
.
get
(
stat
.
codecId
)
.
type
"
codec
"
codecId
{
stat
.
codecId
}
in
report
is
codec
type
)
;
is
(
report
.
get
(
stat
.
codecId
)
.
mimeType
.
slice
(
0
5
)
stat
.
kind
codecId
{
stat
.
codecId
}
in
report
is
for
a
mimeType
of
the
same
+
media
type
as
the
referencing
rtp
stream
stat
)
;
if
(
isRemote
)
{
if
(
stat
.
localId
)
{
ok
(
report
.
has
(
stat
.
localId
)
localId
{
stat
.
localId
}
exists
in
report
.
)
;
is
(
report
.
get
(
stat
.
localId
)
.
ssrc
stat
.
ssrc
"
remote
ssrc
and
local
ssrc
match
.
"
)
;
is
(
report
.
get
(
stat
.
localId
)
.
remoteId
stat
.
id
"
local
object
has
remote
object
as
it
'
s
own
remote
object
.
"
)
;
}
}
else
{
if
(
stat
.
remoteId
)
{
ok
(
report
.
has
(
stat
.
remoteId
)
remoteId
{
stat
.
remoteId
}
exists
in
report
.
)
;
is
(
report
.
get
(
stat
.
remoteId
)
.
ssrc
stat
.
ssrc
"
remote
ssrc
and
local
ssrc
match
.
"
)
;
is
(
report
.
get
(
stat
.
remoteId
)
.
localId
stat
.
id
"
remote
object
has
local
object
as
it
'
s
own
local
object
.
"
)
;
}
}
if
(
stat
.
nackCount
)
{
ok
(
stat
.
nackCount
>
=
0
{
stat
.
type
}
.
nackCount
is
sane
(
{
stat
.
kind
}
)
.
)
;
}
if
(
!
isRemote
&
&
stat
.
inner
.
kind
=
=
"
video
"
)
{
ok
(
stat
.
firCount
>
=
0
&
&
stat
.
firCount
<
100
{
stat
.
type
}
.
firCount
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
firCount
}
)
;
ok
(
stat
.
pliCount
>
=
0
&
&
stat
.
pliCount
<
200
{
stat
.
type
}
.
pliCount
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
pliCount
}
)
;
if
(
stat
.
qpSum
!
=
=
undefined
)
{
ok
(
stat
.
qpSum
>
=
0
{
stat
.
type
}
.
qpSum
is
at
least
0
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
qpSum
}
)
;
}
}
else
{
is
(
stat
.
qpSum
undefined
{
stat
.
type
}
.
qpSum
does
not
exist
when
stat
.
kind
!
=
video
)
;
}
}
if
(
stat
.
type
=
=
"
inbound
-
rtp
"
)
{
is
(
typeof
stat
.
trackIdentifier
"
string
"
)
;
isnot
(
stat
.
trackIdentifier
"
"
)
;
ok
(
stat
.
packetsReceived
>
=
0
&
&
stat
.
packetsReceived
<
10
*
*
5
{
stat
.
type
}
.
packetsReceived
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
packetsReceived
}
)
;
ok
(
stat
.
packetsDiscarded
>
=
0
&
&
stat
.
packetsDiscarded
<
100
{
stat
.
type
}
.
packetsDiscarded
is
sane
number
for
a
short
test
.
+
value
=
{
stat
.
packetsDiscarded
}
)
;
ok
(
stat
.
bytesReceived
>
=
0
&
&
stat
.
bytesReceived
<
10
*
*
9
{
stat
.
type
}
.
bytesReceived
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
bytesReceived
}
)
;
ok
(
stat
.
packetsLost
<
100
{
stat
.
type
}
.
packetsLost
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
packetsLost
}
)
;
let
expectedJitter
=
stat
.
kind
=
=
"
video
"
?
0
.
5
:
1
;
ok
(
stat
.
jitter
<
expectedJitter
{
stat
.
type
}
.
jitter
is
sane
number
for
a
{
stat
.
kind
}
+
local
only
test
.
value
=
{
stat
.
jitter
}
)
;
ok
(
stat
.
lastPacketReceivedTimestamp
!
=
=
undefined
{
stat
.
type
}
.
lastPacketReceivedTimestamp
has
a
value
)
;
ok
(
stat
.
headerBytesReceived
>
=
0
&
&
stat
.
headerBytesReceived
<
50000
{
stat
.
type
}
.
headerBytesReceived
is
sane
for
a
short
test
.
+
value
=
{
stat
.
headerBytesReceived
}
)
;
let
expectedJitterBufferEmmitedCount
=
stat
.
kind
=
=
"
video
"
?
7
:
1000
;
ok
(
stat
.
jitterBufferEmittedCount
>
expectedJitterBufferEmmitedCount
{
stat
.
type
}
.
jitterBufferEmittedCount
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
jitterBufferEmittedCount
}
)
;
let
avgJitterBufferDelay
=
stat
.
jitterBufferDelay
/
stat
.
jitterBufferEmittedCount
;
ok
(
avgJitterBufferDelay
>
0
.
001
&
&
avgJitterBufferDelay
<
10
{
stat
.
type
}
.
jitterBufferDelay
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
jitterBufferDelay
}
/
{
stat
.
jitterBufferEmittedCount
}
=
{
avgJitterBufferDelay
}
)
;
if
(
stat
.
inner
.
kind
!
=
"
audio
"
)
{
expectations
.
localAudioOnly
.
forEach
(
field
=
>
{
ok
(
stat
[
field
]
=
=
=
undefined
{
stat
.
type
}
does
not
have
field
{
field
}
+
when
kind
is
not
'
audio
'
)
;
}
)
;
}
else
{
expectations
.
localAudioOnly
.
forEach
(
field
=
>
{
ok
(
stat
.
inner
[
field
]
!
=
=
undefined
stat
.
type
+
"
has
field
"
+
field
+
"
when
kind
is
video
"
)
;
}
)
;
ok
(
stat
.
totalSamplesReceived
>
1000
{
stat
.
type
}
.
totalSamplesReceived
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
totalSamplesReceived
}
)
;
ok
(
stat
.
fecPacketsReceived
>
=
0
&
&
stat
.
fecPacketsReceived
<
10
*
*
5
{
stat
.
type
}
.
fecPacketsReceived
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
fecPacketsReceived
}
)
;
ok
(
stat
.
fecPacketsDiscarded
>
=
0
&
&
stat
.
fecPacketsDiscarded
<
100
{
stat
.
type
}
.
fecPacketsDiscarded
is
sane
number
for
a
short
test
.
+
value
=
{
stat
.
fecPacketsDiscarded
}
)
;
ok
(
stat
.
concealedSamples
>
=
0
&
&
stat
.
concealedSamples
<
=
stat
.
totalSamplesReceived
{
stat
.
type
}
.
concealedSamples
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
concealedSamples
}
)
;
ok
(
stat
.
silentConcealedSamples
>
=
0
&
&
stat
.
silentConcealedSamples
<
=
stat
.
concealedSamples
{
stat
.
type
}
.
silentConcealedSamples
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
silentConcealedSamples
}
)
;
ok
(
stat
.
concealmentEvents
>
=
0
&
&
stat
.
concealmentEvents
<
=
stat
.
packetsReceived
{
stat
.
type
}
.
concealmentEvents
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
concealmentEvents
}
)
;
ok
(
stat
.
insertedSamplesForDeceleration
>
=
0
&
&
stat
.
insertedSamplesForDeceleration
<
=
stat
.
totalSamplesReceived
{
stat
.
type
}
.
insertedSamplesForDeceleration
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
insertedSamplesForDeceleration
}
)
;
ok
(
stat
.
removedSamplesForAcceleration
>
=
0
&
&
stat
.
removedSamplesForAcceleration
<
=
stat
.
totalSamplesReceived
{
stat
.
type
}
.
removedSamplesForAcceleration
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
removedSamplesForAcceleration
}
)
;
ok
(
stat
.
audioLevel
>
=
0
&
&
stat
.
audioLevel
<
=
128
{
stat
.
type
}
.
bytesReceived
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
audioLevel
}
)
;
ok
(
stat
.
totalAudioEnergy
>
=
0
&
&
stat
.
totalAudioEnergy
<
=
128
{
stat
.
type
}
.
totalAudioEnergy
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
totalAudioEnergy
}
)
;
ok
(
stat
.
totalSamplesDuration
>
=
0
&
&
stat
.
totalSamplesDuration
<
=
300
{
stat
.
type
}
.
totalSamplesDuration
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
totalSamplesDuration
}
)
;
}
if
(
stat
.
inner
.
kind
!
=
"
video
"
)
{
expectations
.
localVideoOnly
.
forEach
(
field
=
>
{
ok
(
stat
[
field
]
=
=
=
undefined
{
stat
.
type
}
does
not
have
field
{
field
}
+
when
kind
is
not
'
video
'
)
;
}
)
;
}
else
{
expectations
.
localVideoOnly
.
forEach
(
field
=
>
{
ok
(
stat
.
inner
[
field
]
!
=
=
undefined
stat
.
type
+
"
has
field
"
+
field
+
"
when
kind
is
video
"
)
;
}
)
;
ok
(
stat
.
discardedPackets
<
100
{
stat
.
type
}
.
discardedPackets
is
a
sane
number
for
a
short
test
.
+
value
=
{
stat
.
discardedPackets
}
)
;
ok
(
stat
.
framesPerSecond
>
0
&
&
stat
.
framesPerSecond
<
70
{
stat
.
type
}
.
framesPerSecond
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
framesPerSecond
}
)
;
ok
(
stat
.
framesDecoded
>
0
&
&
stat
.
framesDecoded
<
1000000
{
stat
.
type
}
.
framesDecoded
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
framesDecoded
}
)
;
ok
(
stat
.
framesDropped
>
=
0
&
&
stat
.
framesDropped
<
100
{
stat
.
type
}
.
framesDropped
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
framesDropped
}
)
;
ok
(
stat
.
frameWidth
>
0
&
&
stat
.
frameWidth
<
100000
{
stat
.
type
}
.
frameWidth
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
frameWidth
}
)
;
ok
(
stat
.
frameHeight
>
0
&
&
stat
.
frameHeight
<
100000
{
stat
.
type
}
.
frameHeight
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
frameHeight
}
)
;
ok
(
stat
.
totalDecodeTime
>
=
0
&
&
stat
.
totalDecodeTime
<
300
{
stat
.
type
}
.
totalDecodeTime
is
sane
for
a
short
test
.
+
value
=
{
stat
.
totalDecodeTime
}
)
;
ok
(
stat
.
totalProcessingDelay
<
100
{
stat
.
type
}
.
totalProcessingDelay
is
sane
number
for
a
short
test
+
local
only
test
.
value
=
{
stat
.
totalProcessingDelay
}
)
;
ok
(
stat
.
totalInterFrameDelay
>
=
0
&
&
stat
.
totalInterFrameDelay
<
100
{
stat
.
type
}
.
totalInterFrameDelay
is
sane
for
a
short
test
.
+
value
=
{
stat
.
totalInterFrameDelay
}
)
;
ok
(
stat
.
totalSquaredInterFrameDelay
>
=
0
&
&
stat
.
totalSquaredInterFrameDelay
<
100
{
stat
.
type
}
.
totalSquaredInterFrameDelay
is
sane
for
a
short
test
.
+
value
=
{
stat
.
totalSquaredInterFrameDelay
}
)
;
ok
(
stat
.
framesReceived
>
=
0
&
&
stat
.
framesReceived
<
100000
{
stat
.
type
}
.
framesReceived
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
framesReceived
}
)
;
}
}
else
if
(
stat
.
type
=
=
"
remote
-
inbound
-
rtp
"
)
{
ok
(
stat
.
roundTripTime
>
=
0
{
stat
.
type
}
.
roundTripTime
is
sane
with
+
value
of
:
{
stat
.
roundTripTime
}
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
packetsLost
<
100
{
stat
.
type
}
.
packetsLost
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
packetsLost
}
)
;
ok
(
stat
.
jitter
>
=
0
{
stat
.
type
}
.
jitter
is
sane
number
(
{
stat
.
kind
}
)
.
+
value
=
{
stat
.
jitter
}
)
;
if
(
stat
.
packetsReceived
)
{
ok
(
stat
.
packetsReceived
>
=
0
&
&
stat
.
packetsReceived
<
10
*
*
5
{
stat
.
type
}
.
packetsReceived
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
packetsReceived
}
)
;
}
ok
(
stat
.
totalRoundTripTime
<
50000
{
stat
.
type
}
.
totalRoundTripTime
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
totalRoundTripTime
}
)
;
ok
(
stat
.
fractionLost
<
0
.
2
{
stat
.
type
}
.
fractionLost
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
fractionLost
}
)
;
ok
(
stat
.
roundTripTimeMeasurements
>
=
1
&
&
stat
.
roundTripTimeMeasurements
<
500
{
stat
.
type
}
.
roundTripTimeMeasurements
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
roundTripTimeMeasurements
}
)
;
}
else
if
(
stat
.
type
=
=
"
outbound
-
rtp
"
)
{
ok
(
stat
.
packetsSent
>
0
&
&
stat
.
packetsSent
<
10000
{
stat
.
type
}
.
packetsSent
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
packetsSent
}
)
;
const
audio1Min
=
16000
*
60
;
const
video1Min
=
250000
*
60
;
ok
(
stat
.
bytesSent
>
0
&
&
stat
.
bytesSent
<
(
stat
.
kind
=
=
"
video
"
?
video1Min
:
audio1Min
)
{
stat
.
type
}
.
bytesSent
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
bytesSent
}
)
;
ok
(
stat
.
headerBytesSent
>
0
&
&
stat
.
headerBytesSent
<
(
stat
.
kind
=
=
"
video
"
?
video1Min
:
audio1Min
)
{
stat
.
type
}
.
headerBytesSent
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
headerBytesSent
}
)
;
ok
(
stat
.
retransmittedPacketsSent
>
=
0
&
&
stat
.
retransmittedPacketsSent
<
(
stat
.
kind
=
=
"
video
"
?
video1Min
:
audio1Min
)
{
stat
.
type
}
.
retransmittedPacketsSent
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
retransmittedPacketsSent
}
)
;
ok
(
stat
.
retransmittedBytesSent
>
=
0
&
&
stat
.
retransmittedBytesSent
<
(
stat
.
kind
=
=
"
video
"
?
video1Min
:
audio1Min
)
{
stat
.
type
}
.
retransmittedBytesSent
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
retransmittedBytesSent
}
)
;
const
mimeType
=
report
.
get
(
stat
.
codecId
)
.
mimeType
;
if
(
mimeType
.
includes
(
"
VP
"
)
)
{
ok
(
stat
.
qpSum
>
=
0
{
stat
.
type
}
.
qpSum
is
a
sane
number
(
{
stat
.
kind
}
)
+
for
{
report
.
get
(
stat
.
codecId
)
.
mimeType
}
.
value
=
{
stat
.
qpSum
}
)
;
}
else
if
(
mimeType
.
includes
(
"
H264
"
)
)
{
if
(
!
stat
.
qpSum
&
&
!
(
"
qpSum
"
in
stat
)
)
{
ok
(
!
stat
.
qpSum
&
&
!
(
"
qpSum
"
in
stat
)
{
stat
.
type
}
.
qpSum
absent
for
{
report
.
get
(
stat
.
codecId
)
.
mimeType
}
)
;
}
else
{
ok
(
stat
.
qpSum
>
=
0
{
stat
.
type
}
.
qpSum
is
a
sane
number
(
{
stat
.
kind
}
)
+
for
{
report
.
get
(
stat
.
codecId
)
.
mimeType
}
.
value
=
{
stat
.
qpSum
}
)
;
}
}
else
{
ok
(
!
stat
.
qpSum
&
&
!
(
"
qpSum
"
in
stat
)
{
stat
.
type
}
.
qpSum
absent
for
{
report
.
get
(
stat
.
codecId
)
.
mimeType
}
)
;
}
if
(
stat
.
inner
.
kind
!
=
"
video
"
)
{
expectations
.
localVideoOnly
.
forEach
(
field
=
>
{
ok
(
stat
[
field
]
=
=
=
undefined
{
stat
.
type
}
does
not
have
field
+
{
field
}
when
kind
is
not
'
video
'
)
;
}
)
;
}
else
{
expectations
.
localVideoOnly
.
forEach
(
field
=
>
{
ok
(
stat
.
inner
[
field
]
!
=
=
undefined
{
stat
.
type
}
has
field
+
{
field
}
when
kind
is
video
and
isRemote
is
false
)
;
}
)
;
ok
(
stat
.
framesEncoded
>
=
0
&
&
stat
.
framesEncoded
<
100000
{
stat
.
type
}
.
framesEncoded
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
framesEncoded
}
)
;
ok
(
stat
.
frameWidth
>
=
0
&
&
stat
.
frameWidth
<
100000
{
stat
.
type
}
.
frameWidth
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
frameWidth
}
)
;
ok
(
stat
.
frameHeight
>
=
0
&
&
stat
.
frameHeight
<
100000
{
stat
.
type
}
.
frameHeight
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
frameHeight
}
)
;
ok
(
stat
.
framesPerSecond
>
=
0
&
&
stat
.
framesPerSecond
<
60
{
stat
.
type
}
.
framesPerSecond
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
framesPerSecond
}
)
;
ok
(
stat
.
framesSent
>
=
0
&
&
stat
.
framesSent
<
100000
{
stat
.
type
}
.
framesSent
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
framesSent
}
)
;
ok
(
stat
.
hugeFramesSent
>
=
0
&
&
stat
.
hugeFramesSent
<
100000
{
stat
.
type
}
.
hugeFramesSent
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
hugeFramesSent
}
)
;
ok
(
stat
.
totalEncodeTime
>
=
0
{
stat
.
type
}
.
totalEncodeTime
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
totalEncodeTime
}
)
;
ok
(
stat
.
totalEncodedBytesTarget
>
1000
{
stat
.
type
}
.
totalEncodedBytesTarget
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
totalEncodedBytesTarget
}
)
;
}
}
else
if
(
stat
.
type
=
=
"
remote
-
outbound
-
rtp
"
)
{
ok
(
stat
.
packetsSent
>
0
&
&
stat
.
packetsSent
<
10000
{
stat
.
type
}
.
packetsSent
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
packetsSent
}
)
;
const
audio1Min
=
16000
*
60
;
const
video1Min
=
250000
*
60
;
ok
(
stat
.
bytesSent
>
0
&
&
stat
.
bytesSent
<
(
stat
.
kind
=
=
"
video
"
?
video1Min
:
audio1Min
)
{
stat
.
type
}
.
bytesSent
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
bytesSent
}
)
;
ok
(
stat
.
remoteTimestamp
!
=
=
undefined
{
stat
.
type
}
.
remoteTimestamp
+
is
not
undefined
(
{
stat
.
kind
}
)
)
;
const
ageSeconds
=
(
stat
.
timestamp
-
stat
.
remoteTimestamp
)
/
1000
;
ok
(
ageSeconds
>
=
-
0
.
002
&
&
ageSeconds
<
30
{
stat
.
type
}
.
remoteTimestamp
is
on
the
same
timeline
as
+
{
stat
.
type
}
.
timestamp
and
no
older
than
30
seconds
.
+
difference
=
{
ageSeconds
}
s
)
;
}
else
if
(
stat
.
type
=
=
"
media
-
source
"
)
{
is
(
typeof
stat
.
trackIdentifier
"
string
"
)
;
isnot
(
stat
.
trackIdentifier
"
"
)
;
is
(
typeof
stat
.
kind
"
string
"
)
;
ok
(
stat
.
kind
=
=
"
audio
"
|
|
stat
.
kind
=
=
"
video
"
)
;
if
(
stat
.
inner
.
kind
=
=
"
video
"
)
{
expectations
.
localVideoOnly
.
forEach
(
field
=
>
{
ok
(
stat
.
inner
[
field
]
!
=
=
undefined
{
stat
.
type
}
has
field
+
{
field
}
when
kind
is
video
and
isRemote
is
false
)
;
}
)
;
ok
(
stat
.
frames
>
=
0
&
&
stat
.
frames
<
100000
{
stat
.
type
}
.
frames
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
frames
}
)
;
ok
(
stat
.
framesPerSecond
>
=
0
&
&
stat
.
framesPerSecond
<
100
{
stat
.
type
}
.
framesPerSecond
is
a
sane
number
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
framesPerSecond
}
)
;
ok
(
stat
.
width
>
=
0
&
&
stat
.
width
<
1000000
{
stat
.
type
}
.
width
is
a
sane
number
for
a
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
width
}
)
;
ok
(
stat
.
height
>
=
0
&
&
stat
.
height
<
1000000
{
stat
.
type
}
.
height
is
a
sane
number
for
a
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
height
}
)
;
}
else
{
expectations
.
localVideoOnly
.
forEach
(
field
=
>
{
ok
(
stat
[
field
]
=
=
=
undefined
{
stat
.
type
}
does
not
have
field
+
{
field
}
when
kind
is
not
'
video
'
)
;
}
)
;
}
}
else
if
(
stat
.
type
=
=
"
codec
"
)
{
switch
(
stat
.
mimeType
)
{
case
"
audio
/
opus
"
:
is
(
stat
.
payloadType
109
"
codec
.
payloadType
for
opus
"
)
;
break
;
case
"
video
/
VP8
"
:
is
(
stat
.
payloadType
120
"
codec
.
payloadType
for
VP8
"
)
;
break
;
case
"
video
/
VP9
"
:
is
(
stat
.
payloadType
121
"
codec
.
payloadType
for
VP9
"
)
;
break
;
case
"
video
/
H264
"
:
ok
(
stat
.
payloadType
=
=
97
|
|
stat
.
payloadType
=
=
126
codec
.
payloadType
for
H264
was
{
stat
.
payloadType
}
exp
.
97
or
126
)
;
break
;
default
:
ok
(
false
Unexpected
codec
.
mimeType
{
stat
.
mimeType
}
for
payloadType
+
{
stat
.
payloadType
}
)
;
break
;
}
ok
(
stat
.
transportId
"
codec
.
transportId
is
set
"
)
;
if
(
stat
.
mimeType
.
startsWith
(
"
audio
"
)
)
{
is
(
stat
.
clockRate
48000
"
codec
.
clockRate
for
audio
/
opus
"
)
;
}
else
if
(
stat
.
mimeType
.
startsWith
(
"
video
"
)
)
{
is
(
stat
.
clockRate
90000
"
codec
.
clockRate
for
video
"
)
;
}
ok
(
stat
.
sdpFmtpLine
"
codec
.
sdpFmtpLine
is
set
"
)
;
const
opusParams
=
[
"
maxplaybackrate
"
"
maxaveragebitrate
"
"
usedtx
"
"
stereo
"
"
useinbandfec
"
"
cbr
"
"
ptime
"
"
minptime
"
"
maxptime
"
]
;
const
vpxParams
=
[
"
max
-
fs
"
"
max
-
fr
"
]
;
const
h264Params
=
[
"
packetization
-
mode
"
"
level
-
asymmetry
-
allowed
"
"
profile
-
level
-
id
"
"
max
-
fs
"
"
max
-
cpb
"
"
max
-
dpb
"
"
max
-
br
"
"
max
-
mbps
"
]
;
for
(
const
param
of
stat
.
sdpFmtpLine
.
split
(
"
;
"
)
)
{
const
[
key
value
]
=
param
.
split
(
"
=
"
)
;
if
(
stat
.
payloadType
=
=
109
)
{
ok
(
opusParams
.
includes
(
key
)
codec
.
sdpFmtpLine
param
{
key
}
=
{
value
}
for
opus
)
;
}
else
if
(
stat
.
payloadType
=
=
120
|
|
stat
.
payloadType
=
=
121
)
{
ok
(
vpxParams
.
includes
(
key
)
codec
.
sdpFmtpLine
param
{
key
}
=
{
value
}
for
VPx
)
;
}
else
if
(
stat
.
payloadType
=
=
97
|
|
stat
.
payloadType
=
=
126
)
{
ok
(
h264Params
.
includes
(
key
)
codec
.
sdpFmtpLine
param
{
key
}
=
{
value
}
for
H264
)
;
if
(
key
=
=
"
packetization
-
mode
"
)
{
if
(
stat
.
payloadType
=
=
97
)
{
is
(
value
"
0
"
"
codec
.
sdpFmtpLine
:
H264
(
97
)
packetization
-
mode
"
)
;
}
else
if
(
stat
.
payloadType
=
=
126
)
{
is
(
value
"
1
"
"
codec
.
sdpFmtpLine
:
H264
(
126
)
packetization
-
mode
"
)
;
}
}
if
(
key
=
=
"
profile
-
level
-
id
"
)
{
is
(
value
"
42e01f
"
"
codec
.
sdpFmtpLine
:
H264
profile
-
level
-
id
"
)
;
}
}
}
ok
(
!
Object
.
keys
(
stat
)
.
includes
(
"
codecType
"
)
|
|
stat
.
codecType
=
=
"
encode
"
|
|
stat
.
codecType
=
=
"
decode
"
"
codec
.
codecType
(
{
codec
.
codecType
}
)
is
an
expected
value
or
absent
"
)
;
let
numRecvStreams
=
0
;
let
numSendStreams
=
0
;
const
counts
=
{
"
inbound
-
rtp
"
:
0
"
outbound
-
rtp
"
:
0
"
remote
-
inbound
-
rtp
"
:
0
"
remote
-
outbound
-
rtp
"
:
0
}
;
const
[
kind
]
=
stat
.
mimeType
.
split
(
"
/
"
)
;
report
.
forEach
(
other
=
>
{
if
(
other
.
type
=
=
"
inbound
-
rtp
"
&
&
other
.
kind
=
=
kind
)
{
numRecvStreams
+
=
1
;
}
else
if
(
other
.
type
=
=
"
outbound
-
rtp
"
&
&
other
.
kind
=
=
kind
)
{
numSendStreams
+
=
1
;
}
if
(
other
.
codecId
=
=
stat
.
id
)
{
counts
[
other
.
type
]
+
=
1
;
}
}
)
;
const
expectedCounts
=
{
encode
:
{
"
inbound
-
rtp
"
:
0
"
outbound
-
rtp
"
:
numSendStreams
"
remote
-
inbound
-
rtp
"
:
numSendStreams
"
remote
-
outbound
-
rtp
"
:
0
}
decode
:
{
"
inbound
-
rtp
"
:
numRecvStreams
"
outbound
-
rtp
"
:
0
"
remote
-
inbound
-
rtp
"
:
0
"
remote
-
outbound
-
rtp
"
:
numRecvStreams
}
absent
:
{
"
inbound
-
rtp
"
:
numRecvStreams
"
outbound
-
rtp
"
:
numSendStreams
"
remote
-
inbound
-
rtp
"
:
numSendStreams
"
remote
-
outbound
-
rtp
"
:
numRecvStreams
}
}
;
for
(
const
[
key
value
]
of
Object
.
entries
(
counts
)
)
{
is
(
value
expectedCounts
[
stat
.
codecType
|
|
"
absent
"
]
[
key
]
codec
.
codecType
{
stat
.
codecType
|
|
"
absent
"
}
ref
from
{
key
}
stat
)
;
}
if
(
stat
.
mimeType
.
startsWith
(
"
audio
"
)
)
{
ok
(
stat
.
channels
"
codec
.
channels
should
exist
for
audio
"
)
;
if
(
stat
.
channels
)
{
if
(
stat
.
sdpFmtpLine
.
includes
(
"
stereo
=
1
"
)
)
{
is
(
stat
.
channels
2
"
codec
.
channels
for
stereo
audio
"
)
;
}
else
{
is
(
stat
.
channels
1
"
codec
.
channels
for
mono
audio
"
)
;
}
}
}
else
{
ok
(
!
stat
.
channels
"
codec
.
channels
should
not
exist
for
video
"
)
;
}
}
else
if
(
stat
.
type
=
=
"
candidate
-
pair
"
)
{
info
(
"
candidate
-
pair
is
:
"
+
JSON
.
stringify
(
stat
)
)
;
ok
(
stat
.
transportId
{
stat
.
type
}
.
transportId
has
a
value
.
value
=
+
{
stat
.
transportId
}
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
localCandidateId
{
stat
.
type
}
.
localCandidateId
has
a
value
.
value
=
+
{
stat
.
localCandidateId
}
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
remoteCandidateId
{
stat
.
type
}
.
remoteCandidateId
has
a
value
.
value
=
+
{
stat
.
remoteCandidateId
}
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
priority
{
stat
.
type
}
.
priority
has
a
value
.
value
=
+
{
stat
.
priority
}
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
readable
{
stat
.
type
}
.
readable
is
true
.
value
=
{
stat
.
readable
}
+
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
writable
{
stat
.
type
}
.
writable
is
true
.
value
=
{
stat
.
writable
}
+
(
{
stat
.
kind
}
)
)
;
if
(
stat
.
state
=
=
"
succeeded
"
&
&
stat
.
selected
!
=
=
undefined
&
&
stat
.
selected
)
{
info
(
"
candidate
-
pair
state
is
succeeded
and
selected
is
true
"
)
;
ok
(
stat
.
nominated
{
stat
.
type
}
.
nominated
is
true
.
value
=
{
stat
.
nominated
}
+
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
bytesSent
>
1000
{
stat
.
type
}
.
bytesSent
is
a
sane
number
(
>
1
000
)
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
bytesSent
}
)
;
ok
(
stat
.
bytesReceived
>
500
{
stat
.
type
}
.
bytesReceived
is
a
sane
number
(
>
500
)
for
a
short
+
{
stat
.
kind
}
test
.
value
=
{
stat
.
bytesReceived
}
)
;
ok
(
stat
.
lastPacketSentTimestamp
{
stat
.
type
}
.
lastPacketSentTimestamp
has
a
value
.
value
=
+
{
stat
.
lastPacketSentTimestamp
}
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
lastPacketReceivedTimestamp
{
stat
.
type
}
.
lastPacketReceivedTimestamp
has
a
value
.
value
=
+
{
stat
.
lastPacketReceivedTimestamp
}
(
{
stat
.
kind
}
)
)
;
}
else
{
info
(
"
candidate
-
pair
is
_not_
both
state
=
=
succeeded
and
selected
"
)
;
ok
(
stat
.
nominated
!
=
=
undefined
{
stat
.
type
}
.
nominated
exists
.
value
=
{
stat
.
nominated
}
+
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
bytesSent
!
=
=
undefined
{
stat
.
type
}
.
bytesSent
exists
.
value
=
{
stat
.
bytesSent
}
+
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
bytesReceived
!
=
=
undefined
{
stat
.
type
}
.
bytesReceived
exists
.
value
=
{
stat
.
bytesReceived
}
+
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
lastPacketSentTimestamp
!
=
=
undefined
{
stat
.
type
}
.
lastPacketSentTimestamp
exists
.
value
=
+
{
stat
.
lastPacketSentTimestamp
}
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
lastPacketReceivedTimestamp
!
=
=
undefined
{
stat
.
type
}
.
lastPacketReceivedTimestamp
exists
.
value
=
+
{
stat
.
lastPacketReceivedTimestamp
}
(
{
stat
.
kind
}
)
)
;
}
ok
(
stat
.
selected
=
=
=
undefined
|
|
(
stat
.
state
=
=
"
succeeded
"
&
&
stat
.
selected
)
|
|
!
stat
.
selected
{
stat
.
type
}
.
selected
is
undefined
true
when
state
is
succeeded
+
or
false
.
value
=
{
stat
.
selected
}
(
{
stat
.
kind
}
)
)
;
}
else
if
(
stat
.
type
=
=
"
local
-
candidate
"
|
|
stat
.
type
=
=
"
remote
-
candidate
"
)
{
info
(
candidate
is
{
JSON
.
stringify
(
stat
)
}
)
;
ok
(
stat
.
address
{
stat
.
type
}
has
address
.
value
=
{
stat
.
address
}
+
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
protocol
{
stat
.
type
}
has
protocol
.
value
=
{
stat
.
protocol
}
+
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
port
>
=
0
{
stat
.
type
}
has
port
>
=
0
.
value
=
{
stat
.
port
}
+
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
port
<
=
65535
{
stat
.
type
}
has
port
<
=
65535
.
value
=
{
stat
.
port
}
+
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
candidateType
{
stat
.
type
}
has
candidateType
.
value
=
{
stat
.
candidateType
}
+
(
{
stat
.
kind
}
)
)
;
ok
(
stat
.
priority
>
0
&
&
stat
.
priority
<
2
*
*
32
-
1
{
stat
.
type
}
has
priority
between
1
and
2
^
32
-
1
inc
.
+
value
=
{
stat
.
priority
}
(
{
stat
.
kind
}
)
)
;
if
(
stat
.
type
=
=
"
local
-
candidate
"
&
&
stat
.
candidateType
=
=
"
relay
"
)
{
ok
(
stat
.
relayProtocol
relay
{
stat
.
type
}
has
relayProtocol
.
value
=
{
stat
.
relayProtocol
}
+
(
{
stat
.
kind
}
)
)
;
}
else
{
is
(
stat
.
relayProtocol
undefined
relayProtocol
is
undefined
for
candidates
that
are
not
relay
and
+
local
.
value
=
{
stat
.
relayProtocol
}
(
{
stat
.
kind
}
)
)
;
}
if
(
stat
.
proxied
)
{
ok
(
stat
.
proxied
=
=
"
proxied
"
|
|
stat
.
proxied
=
=
"
non
-
proxied
"
{
stat
.
type
}
has
proxied
.
value
=
{
stat
.
proxied
}
(
{
stat
.
kind
}
)
)
;
}
}
[
.
.
.
expectations
.
expected
.
.
.
expectations
.
optional
]
.
forEach
(
field
=
>
{
ok
(
Object
.
keys
(
tested
)
.
includes
(
field
)
{
stat
.
type
}
.
{
field
}
was
tested
.
)
;
}
)
;
}
)
;
}
function
dumpStats
(
stats
)
{
const
dict
=
{
}
;
for
(
const
[
k
v
]
of
stats
.
entries
(
)
)
{
dict
[
k
]
=
v
;
}
info
(
Got
stats
:
{
JSON
.
stringify
(
dict
)
}
)
;
}
async
function
waitForSyncedRtcp
(
pc
)
{
let
ensureSyncedRtcp
=
async
(
)
=
>
{
let
report
=
await
pc
.
getStats
(
)
;
for
(
const
v
of
report
.
values
(
)
)
{
if
(
v
.
type
.
endsWith
(
"
bound
-
rtp
"
)
&
&
!
(
v
.
remoteId
|
|
v
.
localId
)
)
{
info
(
{
v
.
id
}
is
missing
remoteId
or
localId
:
{
JSON
.
stringify
(
v
)
}
)
;
return
null
;
}
if
(
v
.
type
=
=
"
remote
-
inbound
-
rtp
"
&
&
v
.
roundTripTime
=
=
=
undefined
)
{
info
(
{
v
.
id
}
is
missing
roundTripTime
:
{
JSON
.
stringify
(
v
)
}
)
;
return
null
;
}
}
return
report
;
}
;
const
hasAllRtcpUpdated
=
(
baseStats
stats
)
=
>
{
let
hasRtcpStats
=
false
;
for
(
const
v
of
stats
.
values
(
)
)
{
if
(
v
.
type
=
=
"
remote
-
outbound
-
rtp
"
)
{
hasRtcpStats
=
true
;
if
(
!
v
.
remoteTimestamp
)
{
return
false
;
}
if
(
v
.
remoteTimestamp
<
=
baseStats
.
get
(
v
.
id
)
?
.
remoteTimestamp
)
{
return
false
;
}
}
else
if
(
v
.
type
=
=
"
remote
-
inbound
-
rtp
"
)
{
hasRtcpStats
=
true
;
if
(
!
v
.
packetsReceived
)
{
return
false
;
}
if
(
v
.
packetsReceived
<
=
baseStats
.
get
(
v
.
id
)
?
.
packetsReceived
)
{
return
false
;
}
}
}
return
hasRtcpStats
;
}
;
let
attempts
=
0
;
const
baseStats
=
await
pc
.
getStats
(
)
;
const
waitPeriod
=
100
;
const
maxTime
=
20000
;
for
(
let
totalTime
=
maxTime
;
totalTime
>
0
;
totalTime
-
=
waitPeriod
)
{
try
{
let
syncedStats
=
await
ensureSyncedRtcp
(
)
;
if
(
syncedStats
&
&
hasAllRtcpUpdated
(
baseStats
syncedStats
)
)
{
dumpStats
(
syncedStats
)
;
return
syncedStats
;
}
}
catch
(
e
)
{
info
(
e
)
;
info
(
e
.
stack
)
;
throw
e
;
}
attempts
+
=
1
;
info
(
waitForSyncedRtcp
:
no
sync
on
attempt
{
attempts
}
retrying
.
)
;
await
wait
(
waitPeriod
)
;
}
throw
Error
(
"
Waiting
for
synced
RTCP
timed
out
after
at
least
"
+
maxTime
+
"
ms
"
)
;
}
function
checkSenderStats
(
senderStats
streamCount
)
{
const
outboundRtpReports
=
[
]
;
const
remoteInboundRtpReports
=
[
]
;
for
(
const
v
of
senderStats
.
values
(
)
)
{
if
(
v
.
type
=
=
"
outbound
-
rtp
"
)
{
outboundRtpReports
.
push
(
v
)
;
}
else
if
(
v
.
type
=
=
"
remote
-
inbound
-
rtp
"
)
{
remoteInboundRtpReports
.
push
(
v
)
;
}
}
is
(
outboundRtpReports
.
length
streamCount
Sender
with
{
streamCount
}
simulcast
streams
has
{
streamCount
}
outbound
-
rtp
reports
)
;
is
(
remoteInboundRtpReports
.
length
streamCount
Sender
with
{
streamCount
}
simulcast
streams
has
{
streamCount
}
remote
-
inbound
-
rtp
reports
)
;
for
(
const
outboundRtpReport
of
outboundRtpReports
)
{
is
(
outboundRtpReports
.
filter
(
r
=
>
r
.
ssrc
=
=
outboundRtpReport
.
ssrc
)
.
length
1
"
Simulcast
send
track
SSRCs
are
distinct
"
)
;
const
remoteReports
=
remoteInboundRtpReports
.
filter
(
r
=
>
r
.
id
=
=
outboundRtpReport
.
remoteId
)
;
is
(
remoteReports
.
length
1
"
Simulcast
send
tracks
have
exactly
one
remote
counterpart
"
)
;
const
remoteInboundRtpReport
=
remoteReports
[
0
]
;
is
(
outboundRtpReport
.
ssrc
remoteInboundRtpReport
.
ssrc
"
SSRC
matches
for
outbound
-
rtp
and
remote
-
inbound
-
rtp
"
)
;
}
}
function
PC_LOCAL_TEST_LOCAL_STATS
(
test
)
{
return
waitForSyncedRtcp
(
test
.
pcLocal
.
_pc
)
.
then
(
stats
=
>
{
checkExpectedFields
(
stats
)
;
pedanticChecks
(
stats
)
;
return
Promise
.
all
(
[
test
.
pcLocal
.
_pc
.
getSenders
(
)
.
map
(
async
s
=
>
{
checkSenderStats
(
await
s
.
getStats
(
)
Math
.
max
(
1
s
.
getParameters
(
)
?
.
encodings
?
.
length
?
?
0
)
)
;
}
)
]
)
;
}
)
;
}
function
PC_REMOTE_TEST_REMOTE_STATS
(
test
)
{
return
waitForSyncedRtcp
(
test
.
pcRemote
.
_pc
)
.
then
(
stats
=
>
{
checkExpectedFields
(
stats
)
;
pedanticChecks
(
stats
)
;
return
Promise
.
all
(
[
test
.
pcRemote
.
_pc
.
getSenders
(
)
.
map
(
async
s
=
>
{
checkSenderStats
(
await
s
.
getStats
(
)
s
.
track
?
Math
.
max
(
1
s
.
getParameters
(
)
?
.
encodings
?
.
length
?
?
0
)
:
0
)
;
}
)
]
)
;
}
)
;
}
