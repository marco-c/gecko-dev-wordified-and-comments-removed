"
use
strict
"
;
const
findStatsRelayCandidates
=
async
(
pc
protocol
)
=
>
{
const
stats
=
await
pc
.
getStats
(
)
;
return
[
.
.
.
stats
.
values
(
)
]
.
filter
(
v
=
>
v
.
type
=
=
"
local
-
candidate
"
&
&
v
.
candidateType
=
=
"
relay
"
&
&
v
.
relayProtocol
=
=
protocol
)
;
}
;
const
gather
=
async
pc
=
>
{
await
pc
.
setLocalDescription
(
await
pc
.
createOffer
(
{
offerToReceiveAudio
:
true
}
)
)
;
return
new
Promise
(
r
=
>
{
const
candidates
=
[
]
;
const
onCandidate
=
e
=
>
{
if
(
e
.
candidate
)
{
candidates
.
push
(
e
.
candidate
)
;
}
else
{
r
(
candidates
)
;
pc
.
removeEventListener
(
"
icecandidate
"
onCandidate
)
;
}
}
;
pc
.
addEventListener
(
"
icecandidate
"
onCandidate
)
;
}
)
;
}
;
const
gatherWithTimeout
=
async
(
pc
timeout
context
)
=
>
{
const
throwOnTimeout
=
async
(
)
=
>
{
await
wait
(
timeout
)
;
throw
Gathering
did
not
complete
within
{
timeout
}
ms
with
{
context
}
;
}
;
let
result
=
[
]
;
try
{
result
=
await
Promise
.
race
(
[
gather
(
pc
)
throwOnTimeout
(
)
]
)
;
}
catch
(
e
)
{
ok
(
false
e
)
;
}
return
result
;
}
;
const
isV6HostCandidate
=
candidate
=
>
{
const
fields
=
candidate
.
candidate
.
split
(
"
"
)
;
const
type
=
fields
[
7
]
;
const
ipAddress
=
fields
[
4
]
;
return
type
=
=
"
host
"
&
&
ipAddress
.
includes
(
"
:
"
)
;
}
;
const
ipv6Supported
=
async
(
)
=
>
{
const
pc
=
new
RTCPeerConnection
(
)
;
const
candidates
=
await
gatherWithTimeout
(
pc
8000
)
;
info
(
baseline
candidates
:
{
JSON
.
stringify
(
candidates
)
}
)
;
pc
.
close
(
)
;
return
candidates
.
some
(
isV6HostCandidate
)
;
}
;
const
makeContextString
=
iceServers
=
>
{
const
currentRedirectAddress
=
SpecialPowers
.
getCharPref
(
"
media
.
peerconnection
.
nat_simulator
.
redirect_address
"
"
"
)
;
const
currentRedirectTargets
=
SpecialPowers
.
getCharPref
(
"
media
.
peerconnection
.
nat_simulator
.
redirect_targets
"
"
"
)
;
return
redirect
rule
:
{
currentRedirectAddress
}
=
>
{
currentRedirectTargets
}
iceServers
:
{
JSON
.
stringify
(
iceServers
)
}
;
}
;
const
checkSrflx
=
async
iceServers
=
>
{
const
context
=
makeContextString
(
iceServers
)
;
info
(
checkSrflx
{
context
}
)
;
const
pc
=
new
RTCPeerConnection
(
{
iceServers
bundlePolicy
:
"
max
-
bundle
"
}
)
;
const
candidates
=
await
gatherWithTimeout
(
pc
8000
context
)
;
const
srflxCandidates
=
candidates
.
filter
(
c
=
>
c
.
candidate
.
includes
(
"
srflx
"
)
)
;
info
(
candidates
:
{
JSON
.
stringify
(
srflxCandidates
)
}
)
;
is
(
srflxCandidates
.
length
2
Should
have
two
srflx
candidates
with
{
context
}
)
;
pc
.
close
(
)
;
}
;
const
checkNoSrflx
=
async
iceServers
=
>
{
const
context
=
makeContextString
(
iceServers
)
;
info
(
checkNoSrflx
{
context
}
)
;
const
pc
=
new
RTCPeerConnection
(
{
iceServers
bundlePolicy
:
"
max
-
bundle
"
}
)
;
const
candidates
=
await
gatherWithTimeout
(
pc
8000
context
)
;
const
srflxCandidates
=
candidates
.
filter
(
c
=
>
c
.
candidate
.
includes
(
"
srflx
"
)
)
;
info
(
candidates
:
{
JSON
.
stringify
(
srflxCandidates
)
}
)
;
is
(
srflxCandidates
.
length
0
Should
have
no
srflx
candidates
with
{
context
}
)
;
pc
.
close
(
)
;
}
;
const
checkRelayUdp
=
async
iceServers
=
>
{
const
context
=
makeContextString
(
iceServers
)
;
info
(
checkRelayUdp
{
context
}
)
;
const
pc
=
new
RTCPeerConnection
(
{
iceServers
bundlePolicy
:
"
max
-
bundle
"
}
)
;
const
candidates
=
await
gatherWithTimeout
(
pc
8000
context
)
;
const
relayCandidates
=
candidates
.
filter
(
c
=
>
c
.
candidate
.
includes
(
"
relay
"
)
)
;
info
(
candidates
:
{
JSON
.
stringify
(
relayCandidates
)
}
)
;
is
(
relayCandidates
.
length
2
Should
have
two
relay
candidates
with
{
context
}
)
;
is
(
(
await
findStatsRelayCandidates
(
pc
"
tcp
"
)
)
.
length
0
No
TCP
relay
candidates
should
be
present
with
{
context
}
)
;
pc
.
close
(
)
;
}
;
const
checkRelayTcp
=
async
iceServers
=
>
{
const
context
=
makeContextString
(
iceServers
)
;
info
(
checkRelayTcp
{
context
}
)
;
const
pc
=
new
RTCPeerConnection
(
{
iceServers
bundlePolicy
:
"
max
-
bundle
"
}
)
;
const
candidates
=
await
gatherWithTimeout
(
pc
8000
context
)
;
const
relayCandidates
=
candidates
.
filter
(
c
=
>
c
.
candidate
.
includes
(
"
relay
"
)
)
;
info
(
candidates
:
{
JSON
.
stringify
(
relayCandidates
)
}
)
;
is
(
relayCandidates
.
length
2
Should
have
two
relay
candidates
with
{
context
}
)
;
is
(
(
await
findStatsRelayCandidates
(
pc
"
udp
"
)
)
.
length
0
No
UDP
relay
candidates
should
be
present
with
{
context
}
)
;
pc
.
close
(
)
;
}
;
const
checkRelayUdpTcp
=
async
iceServers
=
>
{
const
context
=
makeContextString
(
iceServers
)
;
info
(
checkRelayUdpTcp
{
context
}
)
;
const
pc
=
new
RTCPeerConnection
(
{
iceServers
bundlePolicy
:
"
max
-
bundle
"
}
)
;
const
candidates
=
await
gatherWithTimeout
(
pc
8000
context
)
;
const
relayCandidates
=
candidates
.
filter
(
c
=
>
c
.
candidate
.
includes
(
"
relay
"
)
)
;
info
(
candidates
:
{
JSON
.
stringify
(
relayCandidates
)
}
)
;
is
(
relayCandidates
.
length
4
Should
have
two
relay
candidates
for
each
protocol
with
{
context
}
)
;
is
(
(
await
findStatsRelayCandidates
(
pc
"
udp
"
)
)
.
length
2
Two
UDP
relay
candidates
should
be
present
with
{
context
}
)
;
is
(
(
await
findStatsRelayCandidates
(
pc
"
tcp
"
)
)
.
length
1
One
TCP
relay
candidates
should
be
present
with
{
context
}
)
;
pc
.
close
(
)
;
}
;
const
checkNoRelay
=
async
iceServers
=
>
{
const
context
=
makeContextString
(
iceServers
)
;
info
(
checkNoRelay
{
context
}
)
;
const
pc
=
new
RTCPeerConnection
(
{
iceServers
bundlePolicy
:
"
max
-
bundle
"
}
)
;
const
candidates
=
await
gatherWithTimeout
(
pc
8000
context
)
;
const
relayCandidates
=
candidates
.
filter
(
c
=
>
c
.
candidate
.
includes
(
"
relay
"
)
)
;
info
(
candidates
:
{
JSON
.
stringify
(
relayCandidates
)
}
)
;
is
(
relayCandidates
.
length
0
Should
have
no
relay
candidates
with
{
context
}
)
;
pc
.
close
(
)
;
}
;
