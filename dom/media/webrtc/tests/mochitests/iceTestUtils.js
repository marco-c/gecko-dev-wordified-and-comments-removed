"
use
strict
"
;
async
function
findStatsRelayCandidates
(
pc
protocol
)
{
const
stats
=
await
pc
.
getStats
(
)
;
return
[
.
.
.
stats
.
values
(
)
]
.
filter
(
v
=
>
v
.
type
=
=
"
local
-
candidate
"
&
&
v
.
candidateType
=
=
"
relay
"
&
&
v
.
relayProtocol
=
=
protocol
)
;
}
async
function
trickleIce
(
pc
pcDst
)
{
const
candidates
=
[
]
addCandidatePromises
=
[
]
;
while
(
true
)
{
const
{
candidate
}
=
await
new
Promise
(
r
=
>
pc
.
addEventListener
(
"
icecandidate
"
r
{
once
:
true
}
)
)
;
if
(
!
candidate
)
{
break
;
}
candidates
.
push
(
candidate
)
;
if
(
pcDst
)
{
addCandidatePromises
.
push
(
pcDst
.
addIceCandidate
(
candidate
)
)
;
}
}
await
Promise
.
all
(
addCandidatePromises
)
;
return
candidates
;
}
async
function
gather
(
pc
)
{
if
(
pc
.
signalingState
=
=
"
stable
"
)
{
await
pc
.
setLocalDescription
(
await
pc
.
createOffer
(
{
offerToReceiveAudio
:
true
}
)
)
;
}
else
if
(
pc
.
signalingState
=
=
"
have
-
remote
-
offer
"
)
{
await
pc
.
setLocalDescription
(
)
;
}
return
trickleIce
(
pc
)
;
}
async
function
gatherWithTimeout
(
pc
timeout
context
)
{
const
throwOnTimeout
=
async
(
)
=
>
{
await
wait
(
timeout
)
;
throw
new
Error
(
Gathering
did
not
complete
within
{
timeout
}
ms
with
{
context
}
)
;
}
;
return
Promise
.
race
(
[
gather
(
pc
)
throwOnTimeout
(
)
]
)
;
}
async
function
iceConnected
(
pc
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
pc
.
addEventListener
(
"
iceconnectionstatechange
"
(
)
=
>
{
if
(
[
"
connected
"
"
completed
"
]
.
includes
(
pc
.
iceConnectionState
)
)
{
resolve
(
)
;
}
else
if
(
pc
.
iceConnectionState
=
=
"
failed
"
)
{
reject
(
new
Error
(
ICE
failed
)
)
;
}
}
)
;
}
)
;
}
async
function
connectNoTrickleWait
(
offerer
answerer
timeout
context
)
{
return
connect
(
offerer
answerer
timeout
context
true
)
;
}
async
function
connect
(
offerer
answerer
timeout
context
noTrickleWait
=
false
)
{
const
trickle1
=
trickleIce
(
offerer
answerer
)
;
const
trickle2
=
trickleIce
(
answerer
offerer
)
;
try
{
const
offer
=
await
offerer
.
createOffer
(
{
offerToReceiveAudio
:
true
}
)
;
await
offerer
.
setLocalDescription
(
offer
)
;
await
answerer
.
setRemoteDescription
(
offer
)
;
const
answer
=
await
answerer
.
createAnswer
(
)
;
await
Promise
.
all
(
[
offerer
.
setRemoteDescription
(
answer
)
answerer
.
setLocalDescription
(
answer
)
]
)
;
const
throwOnTimeout
=
async
(
)
=
>
{
if
(
timeout
)
{
await
wait
(
timeout
)
;
throw
new
Error
(
ICE
did
not
complete
within
{
timeout
}
ms
with
{
context
}
)
;
}
}
;
await
Promise
.
race
(
[
Promise
.
all
(
[
iceConnected
(
offerer
)
iceConnected
(
answerer
)
]
)
throwOnTimeout
(
timeout
context
)
]
)
;
}
finally
{
if
(
!
noTrickleWait
)
{
await
Promise
.
all
(
[
trickle1
trickle2
]
)
;
}
}
}
function
isV6HostCandidate
(
candidate
)
{
const
fields
=
candidate
.
candidate
.
split
(
"
"
)
;
const
type
=
fields
[
7
]
;
const
ipAddress
=
fields
[
4
]
;
return
type
=
=
"
host
"
&
&
ipAddress
.
includes
(
"
:
"
)
;
}
async
function
ipv6Supported
(
)
{
const
pc
=
new
RTCPeerConnection
(
)
;
const
candidates
=
await
gatherWithTimeout
(
pc
8000
)
;
info
(
baseline
candidates
:
{
JSON
.
stringify
(
candidates
)
}
)
;
pc
.
close
(
)
;
return
candidates
.
some
(
isV6HostCandidate
)
;
}
function
makeContextString
(
iceServers
)
{
const
currentRedirectAddress
=
SpecialPowers
.
getCharPref
(
"
media
.
peerconnection
.
nat_simulator
.
redirect_address
"
"
"
)
;
const
currentRedirectTargets
=
SpecialPowers
.
getCharPref
(
"
media
.
peerconnection
.
nat_simulator
.
redirect_targets
"
"
"
)
;
return
redirect
rule
:
{
currentRedirectAddress
}
=
>
{
currentRedirectTargets
}
iceServers
:
{
JSON
.
stringify
(
iceServers
)
}
;
}
async
function
checkSrflx
(
iceServers
)
{
const
context
=
makeContextString
(
iceServers
)
;
info
(
checkSrflx
{
context
}
)
;
const
pc
=
new
RTCPeerConnection
(
{
iceServers
bundlePolicy
:
"
max
-
bundle
"
}
)
;
const
candidates
=
await
gatherWithTimeout
(
pc
8000
context
)
;
const
srflxCandidates
=
candidates
.
filter
(
c
=
>
c
.
candidate
.
includes
(
"
srflx
"
)
)
;
info
(
candidates
:
{
JSON
.
stringify
(
srflxCandidates
)
}
)
;
is
(
srflxCandidates
.
length
2
Should
have
two
srflx
candidates
with
{
context
}
)
;
pc
.
close
(
)
;
}
async
function
checkNoSrflx
(
iceServers
)
{
const
context
=
makeContextString
(
iceServers
)
;
info
(
checkNoSrflx
{
context
}
)
;
const
pc
=
new
RTCPeerConnection
(
{
iceServers
bundlePolicy
:
"
max
-
bundle
"
}
)
;
const
candidates
=
await
gatherWithTimeout
(
pc
8000
context
)
;
const
srflxCandidates
=
candidates
.
filter
(
c
=
>
c
.
candidate
.
includes
(
"
srflx
"
)
)
;
info
(
candidates
:
{
JSON
.
stringify
(
srflxCandidates
)
}
)
;
is
(
srflxCandidates
.
length
0
Should
have
no
srflx
candidates
with
{
context
}
)
;
pc
.
close
(
)
;
}
async
function
checkRelayUdp
(
iceServers
)
{
const
context
=
makeContextString
(
iceServers
)
;
info
(
checkRelayUdp
{
context
}
)
;
const
pc
=
new
RTCPeerConnection
(
{
iceServers
bundlePolicy
:
"
max
-
bundle
"
}
)
;
const
candidates
=
await
gatherWithTimeout
(
pc
8000
context
)
;
const
relayCandidates
=
candidates
.
filter
(
c
=
>
c
.
candidate
.
includes
(
"
relay
"
)
)
;
info
(
candidates
:
{
JSON
.
stringify
(
relayCandidates
)
}
)
;
is
(
relayCandidates
.
length
2
Should
have
two
relay
candidates
with
{
context
}
)
;
is
(
(
await
findStatsRelayCandidates
(
pc
"
tcp
"
)
)
.
length
0
No
TCP
relay
candidates
should
be
present
with
{
context
}
)
;
pc
.
close
(
)
;
}
async
function
checkRelayTcp
(
iceServers
)
{
const
context
=
makeContextString
(
iceServers
)
;
info
(
checkRelayTcp
{
context
}
)
;
const
pc
=
new
RTCPeerConnection
(
{
iceServers
bundlePolicy
:
"
max
-
bundle
"
}
)
;
const
candidates
=
await
gatherWithTimeout
(
pc
8000
context
)
;
const
relayCandidates
=
candidates
.
filter
(
c
=
>
c
.
candidate
.
includes
(
"
relay
"
)
)
;
info
(
candidates
:
{
JSON
.
stringify
(
relayCandidates
)
}
)
;
is
(
relayCandidates
.
length
2
Should
have
two
relay
candidates
with
{
context
}
)
;
is
(
(
await
findStatsRelayCandidates
(
pc
"
udp
"
)
)
.
length
0
No
UDP
relay
candidates
should
be
present
with
{
context
}
)
;
pc
.
close
(
)
;
}
async
function
checkRelayUdpTcp
(
iceServers
)
{
const
context
=
makeContextString
(
iceServers
)
;
info
(
checkRelayUdpTcp
{
context
}
)
;
const
pc
=
new
RTCPeerConnection
(
{
iceServers
bundlePolicy
:
"
max
-
bundle
"
}
)
;
const
candidates
=
await
gatherWithTimeout
(
pc
8000
context
)
;
const
relayCandidates
=
candidates
.
filter
(
c
=
>
c
.
candidate
.
includes
(
"
relay
"
)
)
;
info
(
candidates
:
{
JSON
.
stringify
(
relayCandidates
)
}
)
;
is
(
relayCandidates
.
length
4
Should
have
two
relay
candidates
for
each
protocol
with
{
context
}
)
;
is
(
(
await
findStatsRelayCandidates
(
pc
"
udp
"
)
)
.
length
2
Two
UDP
relay
candidates
should
be
present
with
{
context
}
)
;
is
(
(
await
findStatsRelayCandidates
(
pc
"
tcp
"
)
)
.
length
1
One
TCP
relay
candidates
should
be
present
with
{
context
}
)
;
pc
.
close
(
)
;
}
async
function
checkNoRelay
(
iceServers
)
{
const
context
=
makeContextString
(
iceServers
)
;
info
(
checkNoRelay
{
context
}
)
;
const
pc
=
new
RTCPeerConnection
(
{
iceServers
bundlePolicy
:
"
max
-
bundle
"
}
)
;
const
candidates
=
await
gatherWithTimeout
(
pc
8000
context
)
;
const
relayCandidates
=
candidates
.
filter
(
c
=
>
c
.
candidate
.
includes
(
"
relay
"
)
)
;
info
(
candidates
:
{
JSON
.
stringify
(
relayCandidates
)
}
)
;
is
(
relayCandidates
.
length
0
Should
have
no
relay
candidates
with
{
context
}
)
;
pc
.
close
(
)
;
}
