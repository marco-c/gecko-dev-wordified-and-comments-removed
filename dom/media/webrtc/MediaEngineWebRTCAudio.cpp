#
include
"
MediaEngineWebRTCAudio
.
h
"
#
include
<
stdio
.
h
>
#
include
<
algorithm
>
#
include
"
AudioConverter
.
h
"
#
include
"
MediaManager
.
h
"
#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
MediaTrackConstraints
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ErrorNames
.
h
"
#
include
"
nsIDUtils
.
h
"
#
include
"
transport
/
runnable_utils
.
h
"
#
include
"
Tracing
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
common_audio
/
include
/
audio_util
.
h
"
#
include
"
modules
/
audio_processing
/
include
/
audio_processing
.
h
"
using
namespace
webrtc
;
#
define
MAX_CHANNELS
2
#
define
MONO
1
#
define
MAX_SAMPLING_FREQ
48000
/
/
Hz
-
multiple
of
100
namespace
mozilla
{
using
dom
:
:
MediaSourceEnum
;
extern
LazyLogModule
gMediaManagerLog
;
#
define
LOG
(
.
.
.
)
MOZ_LOG
(
gMediaManagerLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
define
LOG_FRAME
(
.
.
.
)
\
MOZ_LOG
(
gMediaManagerLog
LogLevel
:
:
Verbose
(
__VA_ARGS__
)
)
#
define
LOG_ERROR
(
.
.
.
)
MOZ_LOG
(
gMediaManagerLog
LogLevel
:
:
Error
(
__VA_ARGS__
)
)
MediaEngineWebRTCMicrophoneSource
:
:
MediaEngineWebRTCMicrophoneSource
(
const
MediaDevice
*
aMediaDevice
)
:
mPrincipal
(
PRINCIPAL_HANDLE_NONE
)
mDeviceInfo
(
aMediaDevice
-
>
mAudioDeviceInfo
)
mDeviceMaxChannelCount
(
mDeviceInfo
-
>
MaxChannels
(
)
)
mSettings
(
new
nsMainThreadPtrHolder
<
media
:
:
Refcountable
<
dom
:
:
MediaTrackSettings
>
>
(
"
MediaEngineWebRTCMicrophoneSource
:
:
mSettings
"
new
media
:
:
Refcountable
<
dom
:
:
MediaTrackSettings
>
(
)
false
)
)
{
MOZ_ASSERT
(
aMediaDevice
-
>
mMediaSource
=
=
MediaSourceEnum
:
:
Microphone
)
;
#
ifndef
ANDROID
MOZ_ASSERT
(
mDeviceInfo
-
>
DeviceID
(
)
)
;
#
endif
mSettings
-
>
mEchoCancellation
.
Construct
(
0
)
;
mSettings
-
>
mAutoGainControl
.
Construct
(
0
)
;
mSettings
-
>
mNoiseSuppression
.
Construct
(
0
)
;
mSettings
-
>
mChannelCount
.
Construct
(
0
)
;
mState
=
kReleased
;
}
nsresult
MediaEngineWebRTCMicrophoneSource
:
:
EvaluateSettings
(
const
NormalizedConstraints
&
aConstraintsUpdate
const
MediaEnginePrefs
&
aInPrefs
MediaEnginePrefs
*
aOutPrefs
const
char
*
*
aOutBadConstraint
)
{
AssertIsOnOwningThread
(
)
;
FlattenedConstraints
c
(
aConstraintsUpdate
)
;
MediaEnginePrefs
prefs
=
aInPrefs
;
prefs
.
mAecOn
=
c
.
mEchoCancellation
.
Get
(
aInPrefs
.
mAecOn
)
;
prefs
.
mAgcOn
=
c
.
mAutoGainControl
.
Get
(
aInPrefs
.
mAgcOn
&
&
prefs
.
mAecOn
)
;
prefs
.
mNoiseOn
=
c
.
mNoiseSuppression
.
Get
(
aInPrefs
.
mNoiseOn
&
&
prefs
.
mAecOn
)
;
int32_t
maxChannels
=
static_cast
<
int32_t
>
(
mDeviceInfo
-
>
MaxChannels
(
)
)
;
if
(
c
.
mChannelCount
.
mMin
>
maxChannels
)
{
*
aOutBadConstraint
=
"
channelCount
"
;
return
NS_ERROR_FAILURE
;
}
if
(
aInPrefs
.
mChannels
<
=
0
)
{
prefs
.
mChannels
=
maxChannels
;
}
prefs
.
mChannels
=
c
.
mChannelCount
.
Get
(
std
:
:
min
(
prefs
.
mChannels
maxChannels
)
)
;
prefs
.
mChannels
=
std
:
:
max
(
1
std
:
:
min
(
prefs
.
mChannels
maxChannels
)
)
;
LOG
(
"
Audio
config
:
agc
:
%
d
noise
:
%
d
channels
:
%
d
"
prefs
.
mAgcOn
?
prefs
.
mAgc
:
-
1
prefs
.
mNoiseOn
?
prefs
.
mNoise
:
-
1
prefs
.
mChannels
)
;
*
aOutPrefs
=
prefs
;
return
NS_OK
;
}
nsresult
MediaEngineWebRTCMicrophoneSource
:
:
Reconfigure
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
char
*
*
aOutBadConstraint
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mTrack
)
;
LOG
(
"
Mic
source
%
p
Reconfigure
"
this
)
;
NormalizedConstraints
constraints
(
aConstraints
)
;
MediaEnginePrefs
outputPrefs
;
nsresult
rv
=
EvaluateSettings
(
constraints
aPrefs
&
outputPrefs
aOutBadConstraint
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
aOutBadConstraint
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
name
;
GetErrorName
(
rv
name
)
;
LOG
(
"
Mic
source
%
p
Reconfigure
(
)
failed
unexpectedly
.
rv
=
%
s
"
this
name
.
Data
(
)
)
;
Stop
(
)
;
return
NS_ERROR_UNEXPECTED
;
}
ApplySettings
(
outputPrefs
)
;
mCurrentPrefs
=
outputPrefs
;
return
NS_OK
;
}
void
MediaEngineWebRTCMicrophoneSource
:
:
ApplySettings
(
const
MediaEnginePrefs
&
aPrefs
)
{
AssertIsOnOwningThread
(
)
;
TRACE
(
"
ApplySettings
"
)
;
MOZ_ASSERT
(
mTrack
"
ApplySetting
is
to
be
called
only
after
SetTrack
has
been
called
"
)
;
mAudioProcessingConfig
.
pipeline
.
multi_channel_render
=
true
;
mAudioProcessingConfig
.
pipeline
.
multi_channel_capture
=
true
;
mAudioProcessingConfig
.
echo_canceller
.
enabled
=
aPrefs
.
mAecOn
;
mAudioProcessingConfig
.
echo_canceller
.
mobile_mode
=
aPrefs
.
mUseAecMobile
;
if
(
(
mAudioProcessingConfig
.
gain_controller1
.
enabled
=
aPrefs
.
mAgcOn
&
&
!
aPrefs
.
mAgc2Forced
)
)
{
auto
mode
=
static_cast
<
AudioProcessing
:
:
Config
:
:
GainController1
:
:
Mode
>
(
aPrefs
.
mAgc
)
;
if
(
mode
!
=
AudioProcessing
:
:
Config
:
:
GainController1
:
:
kAdaptiveAnalog
&
&
mode
!
=
AudioProcessing
:
:
Config
:
:
GainController1
:
:
kAdaptiveDigital
&
&
mode
!
=
AudioProcessing
:
:
Config
:
:
GainController1
:
:
kFixedDigital
)
{
LOG_ERROR
(
"
AudioInputProcessing
%
p
Attempt
to
set
invalid
AGC
mode
%
d
"
mInputProcessing
.
get
(
)
static_cast
<
int
>
(
mode
)
)
;
mode
=
AudioProcessing
:
:
Config
:
:
GainController1
:
:
kAdaptiveDigital
;
}
#
if
defined
(
WEBRTC_IOS
)
|
|
defined
(
ATA
)
|
|
defined
(
WEBRTC_ANDROID
)
if
(
mode
=
=
AudioProcessing
:
:
Config
:
:
GainController1
:
:
kAdaptiveAnalog
)
{
LOG_ERROR
(
"
AudioInputProcessing
%
p
Invalid
AGC
mode
kAdaptiveAnalog
on
"
"
mobile
"
mInputProcessing
.
get
(
)
)
;
MOZ_ASSERT_UNREACHABLE
(
"
Bad
pref
set
in
all
.
js
or
in
about
:
config
"
"
for
the
auto
gain
on
mobile
.
"
)
;
mode
=
AudioProcessing
:
:
Config
:
:
GainController1
:
:
kFixedDigital
;
}
#
endif
mAudioProcessingConfig
.
gain_controller1
.
mode
=
mode
;
}
mAudioProcessingConfig
.
gain_controller2
.
enabled
=
mAudioProcessingConfig
.
gain_controller2
.
adaptive_digital
.
enabled
=
aPrefs
.
mAgcOn
&
&
aPrefs
.
mAgc2Forced
;
if
(
(
mAudioProcessingConfig
.
noise_suppression
.
enabled
=
aPrefs
.
mNoiseOn
)
)
{
auto
level
=
static_cast
<
AudioProcessing
:
:
Config
:
:
NoiseSuppression
:
:
Level
>
(
aPrefs
.
mNoise
)
;
if
(
level
!
=
AudioProcessing
:
:
Config
:
:
NoiseSuppression
:
:
kLow
&
&
level
!
=
AudioProcessing
:
:
Config
:
:
NoiseSuppression
:
:
kModerate
&
&
level
!
=
AudioProcessing
:
:
Config
:
:
NoiseSuppression
:
:
kHigh
&
&
level
!
=
AudioProcessing
:
:
Config
:
:
NoiseSuppression
:
:
kVeryHigh
)
{
LOG_ERROR
(
"
AudioInputProcessing
%
p
Attempt
to
set
invalid
noise
suppression
"
"
level
%
d
"
mInputProcessing
.
get
(
)
static_cast
<
int
>
(
level
)
)
;
level
=
AudioProcessing
:
:
Config
:
:
NoiseSuppression
:
:
kModerate
;
}
mAudioProcessingConfig
.
noise_suppression
.
level
=
level
;
}
mAudioProcessingConfig
.
transient_suppression
.
enabled
=
aPrefs
.
mTransientOn
;
mAudioProcessingConfig
.
high_pass_filter
.
enabled
=
aPrefs
.
mHPFOn
;
mAudioProcessingConfig
.
residual_echo_detector
.
enabled
=
aPrefs
.
mResidualEchoOn
;
RefPtr
<
MediaEngineWebRTCMicrophoneSource
>
that
=
this
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
this
that
track
=
mTrack
prefs
=
aPrefs
audioProcessingConfig
=
mAudioProcessingConfig
]
{
mSettings
-
>
mEchoCancellation
.
Value
(
)
=
prefs
.
mAecOn
;
mSettings
-
>
mAutoGainControl
.
Value
(
)
=
prefs
.
mAgcOn
;
mSettings
-
>
mNoiseSuppression
.
Value
(
)
=
prefs
.
mNoiseOn
;
mSettings
-
>
mChannelCount
.
Value
(
)
=
prefs
.
mChannels
;
class
Message
:
public
ControlMessage
{
const
RefPtr
<
AudioInputProcessing
>
mInputProcessing
;
const
AudioProcessing
:
:
Config
mAudioProcessingConfig
;
const
bool
mPassThrough
;
const
uint32_t
mRequestedInputChannelCount
;
public
:
Message
(
MediaTrack
*
aTrack
AudioInputProcessing
*
aInputProcessing
const
AudioProcessing
:
:
Config
&
aAudioProcessingConfig
bool
aPassThrough
uint32_t
aRequestedInputChannelCount
)
:
ControlMessage
(
aTrack
)
mInputProcessing
(
aInputProcessing
)
mAudioProcessingConfig
(
aAudioProcessingConfig
)
mPassThrough
(
aPassThrough
)
mRequestedInputChannelCount
(
aRequestedInputChannelCount
)
{
}
void
Run
(
)
override
{
mInputProcessing
-
>
ApplyConfig
(
mTrack
-
>
GraphImpl
(
)
mAudioProcessingConfig
)
;
{
TRACE
(
"
SetRequestedInputChannelCount
"
)
;
mInputProcessing
-
>
SetRequestedInputChannelCount
(
mTrack
-
>
GraphImpl
(
)
mRequestedInputChannelCount
)
;
}
{
TRACE
(
"
SetPassThrough
"
)
mInputProcessing
-
>
SetPassThrough
(
mTrack
-
>
GraphImpl
(
)
mPassThrough
)
;
}
}
}
;
bool
passThrough
=
!
(
prefs
.
mAecOn
|
|
prefs
.
mAgcOn
|
|
prefs
.
mNoiseOn
)
;
if
(
track
-
>
IsDestroyed
(
)
)
{
return
;
}
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
track
mInputProcessing
audioProcessingConfig
passThrough
prefs
.
mChannels
)
)
;
}
)
)
;
}
nsresult
MediaEngineWebRTCMicrophoneSource
:
:
Allocate
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
uint64_t
aWindowID
const
char
*
*
aOutBadConstraint
)
{
AssertIsOnOwningThread
(
)
;
mState
=
kAllocated
;
NormalizedConstraints
normalized
(
aConstraints
)
;
MediaEnginePrefs
outputPrefs
;
nsresult
rv
=
EvaluateSettings
(
normalized
aPrefs
&
outputPrefs
aOutBadConstraint
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
settings
=
mSettings
prefs
=
outputPrefs
]
{
settings
-
>
mEchoCancellation
.
Value
(
)
=
prefs
.
mAecOn
;
settings
-
>
mAutoGainControl
.
Value
(
)
=
prefs
.
mAgcOn
;
settings
-
>
mNoiseSuppression
.
Value
(
)
=
prefs
.
mNoiseOn
;
settings
-
>
mChannelCount
.
Value
(
)
=
prefs
.
mChannels
;
}
)
)
;
mCurrentPrefs
=
outputPrefs
;
return
rv
;
}
nsresult
MediaEngineWebRTCMicrophoneSource
:
:
Deallocate
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
kStopped
|
|
mState
=
=
kAllocated
)
;
class
EndTrackMessage
:
public
ControlMessage
{
const
RefPtr
<
AudioInputProcessing
>
mInputProcessing
;
public
:
explicit
EndTrackMessage
(
AudioInputProcessing
*
aAudioInputProcessing
)
:
ControlMessage
(
nullptr
)
mInputProcessing
(
aAudioInputProcessing
)
{
}
void
Run
(
)
override
{
TRACE
(
"
mInputProcessing
:
:
End
"
)
;
mInputProcessing
-
>
End
(
)
;
}
}
;
if
(
mTrack
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
track
=
std
:
:
move
(
mTrack
)
inputProcessing
=
mInputProcessing
]
{
if
(
track
-
>
IsDestroyed
(
)
)
{
return
;
}
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
EndTrackMessage
>
(
inputProcessing
)
)
;
}
)
)
;
}
mTrack
=
nullptr
;
mPrincipal
=
PRINCIPAL_HANDLE_NONE
;
MOZ_ASSERT
(
mState
!
=
kReleased
"
Source
not
allocated
"
)
;
MOZ_ASSERT
(
mState
!
=
kStarted
"
Source
not
stopped
"
)
;
mState
=
kReleased
;
LOG
(
"
Mic
source
%
p
Audio
device
%
s
deallocated
"
this
NS_ConvertUTF16toUTF8
(
mDeviceInfo
-
>
Name
(
)
)
.
get
(
)
)
;
return
NS_OK
;
}
void
MediaEngineWebRTCMicrophoneSource
:
:
SetTrack
(
const
RefPtr
<
MediaTrack
>
&
aTrack
const
PrincipalHandle
&
aPrincipal
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aTrack
)
;
MOZ_ASSERT
(
aTrack
-
>
AsAudioProcessingTrack
(
)
)
;
MOZ_ASSERT
(
!
mTrack
)
;
MOZ_ASSERT
(
mPrincipal
=
=
PRINCIPAL_HANDLE_NONE
)
;
mTrack
=
aTrack
-
>
AsAudioProcessingTrack
(
)
;
mPrincipal
=
aPrincipal
;
mInputProcessing
=
MakeAndAddRef
<
AudioInputProcessing
>
(
mDeviceMaxChannelCount
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
track
=
mTrack
processing
=
mInputProcessing
]
(
)
mutable
{
track
-
>
SetInputProcessing
(
std
:
:
move
(
processing
)
)
;
track
-
>
Resume
(
)
;
}
)
)
;
LOG
(
"
Mic
source
%
p
Track
%
p
registered
for
microphone
capture
"
this
aTrack
.
get
(
)
)
;
}
class
StartStopMessage
:
public
ControlMessage
{
public
:
enum
StartStop
{
Start
Stop
}
;
StartStopMessage
(
MediaTrack
*
aTrack
AudioInputProcessing
*
aInputProcessing
StartStop
aAction
)
:
ControlMessage
(
aTrack
)
mInputProcessing
(
aInputProcessing
)
mAction
(
aAction
)
{
}
void
Run
(
)
override
{
if
(
mAction
=
=
StartStopMessage
:
:
Start
)
{
TRACE
(
"
InputProcessing
:
:
Start
"
)
mInputProcessing
-
>
Start
(
mTrack
-
>
GraphImpl
(
)
)
;
}
else
if
(
mAction
=
=
StartStopMessage
:
:
Stop
)
{
TRACE
(
"
InputProcessing
:
:
Stop
"
)
mInputProcessing
-
>
Stop
(
mTrack
-
>
GraphImpl
(
)
)
;
}
else
{
MOZ_CRASH
(
"
Invalid
enum
value
"
)
;
}
}
protected
:
const
RefPtr
<
AudioInputProcessing
>
mInputProcessing
;
const
StartStop
mAction
;
}
;
nsresult
MediaEngineWebRTCMicrophoneSource
:
:
Start
(
)
{
AssertIsOnOwningThread
(
)
;
if
(
mState
=
=
kStarted
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mState
=
=
kAllocated
|
|
mState
=
=
kStopped
)
;
CubebUtils
:
:
AudioDeviceID
deviceID
=
mDeviceInfo
-
>
DeviceID
(
)
;
if
(
mTrack
-
>
GraphImpl
(
)
-
>
InputDeviceID
(
)
&
&
mTrack
-
>
GraphImpl
(
)
-
>
InputDeviceID
(
)
!
=
deviceID
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
ApplySettings
(
mCurrentPrefs
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
inputProcessing
=
mInputProcessing
deviceID
track
=
mTrack
principal
=
mPrincipal
]
{
if
(
track
-
>
IsDestroyed
(
)
)
{
return
;
}
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartStopMessage
>
(
track
inputProcessing
StartStopMessage
:
:
Start
)
)
;
track
-
>
ConnectDeviceInput
(
deviceID
inputProcessing
principal
)
;
}
)
)
;
MOZ_ASSERT
(
mState
!
=
kReleased
)
;
mState
=
kStarted
;
return
NS_OK
;
}
nsresult
MediaEngineWebRTCMicrophoneSource
:
:
Stop
(
)
{
AssertIsOnOwningThread
(
)
;
LOG
(
"
Mic
source
%
p
Stop
(
)
"
this
)
;
MOZ_ASSERT
(
mTrack
"
SetTrack
must
have
been
called
before
:
:
Stop
"
)
;
if
(
mState
=
=
kStopped
)
{
return
NS_OK
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
inputProcessing
=
mInputProcessing
deviceInfo
=
mDeviceInfo
track
=
mTrack
]
{
if
(
track
-
>
IsDestroyed
(
)
)
{
return
;
}
MOZ_ASSERT
(
track
-
>
DeviceId
(
)
.
value
(
)
=
=
deviceInfo
-
>
DeviceID
(
)
)
;
track
-
>
DisconnectDeviceInput
(
)
;
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartStopMessage
>
(
track
inputProcessing
StartStopMessage
:
:
Stop
)
)
;
}
)
)
;
MOZ_ASSERT
(
mState
=
=
kStarted
"
Should
be
started
when
stopping
"
)
;
mState
=
kStopped
;
return
NS_OK
;
}
void
MediaEngineWebRTCMicrophoneSource
:
:
GetSettings
(
dom
:
:
MediaTrackSettings
&
aOutSettings
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aOutSettings
=
*
mSettings
;
}
AudioInputProcessing
:
:
AudioInputProcessing
(
uint32_t
aMaxChannelCount
)
:
mAudioProcessing
(
AudioProcessingBuilder
(
)
.
Create
(
)
)
mRequestedInputChannelCount
(
aMaxChannelCount
)
mSkipProcessing
(
false
)
mInputDownmixBuffer
(
MAX_SAMPLING_FREQ
*
MAX_CHANNELS
/
100
)
mEnabled
(
false
)
mEnded
(
false
)
mPacketCount
(
0
)
{
}
void
AudioInputProcessing
:
:
Disconnect
(
MediaTrackGraphImpl
*
aGraph
)
{
MOZ_ASSERT
(
aGraph
-
>
OnGraphThread
(
)
)
;
}
bool
AudioInputProcessing
:
:
PassThrough
(
MediaTrackGraphImpl
*
aGraph
)
const
{
MOZ_ASSERT
(
aGraph
-
>
OnGraphThread
(
)
)
;
return
mSkipProcessing
;
}
void
AudioInputProcessing
:
:
SetPassThrough
(
MediaTrackGraphImpl
*
aGraph
bool
aPassThrough
)
{
MOZ_ASSERT
(
aGraph
-
>
OnGraphThread
(
)
)
;
if
(
aPassThrough
=
=
mSkipProcessing
)
{
return
;
}
mSkipProcessing
=
aPassThrough
;
if
(
!
mEnabled
)
{
MOZ_ASSERT
(
!
mPacketizerInput
)
;
return
;
}
if
(
aPassThrough
)
{
ResetAudioProcessing
(
aGraph
)
;
}
else
{
MOZ_ASSERT
(
!
mPacketizerInput
)
;
EnsureAudioProcessing
(
aGraph
mRequestedInputChannelCount
)
;
}
}
uint32_t
AudioInputProcessing
:
:
GetRequestedInputChannelCount
(
)
{
return
mRequestedInputChannelCount
;
}
void
AudioInputProcessing
:
:
SetRequestedInputChannelCount
(
MediaTrackGraphImpl
*
aGraph
uint32_t
aRequestedInputChannelCount
)
{
mRequestedInputChannelCount
=
aRequestedInputChannelCount
;
aGraph
-
>
ReevaluateInputDevice
(
)
;
}
void
AudioInputProcessing
:
:
Start
(
MediaTrackGraphImpl
*
aGraph
)
{
MOZ_ASSERT
(
aGraph
-
>
OnGraphThread
(
)
)
;
if
(
mEnabled
)
{
return
;
}
mEnabled
=
true
;
if
(
mSkipProcessing
)
{
return
;
}
MOZ_ASSERT
(
!
mPacketizerInput
)
;
EnsureAudioProcessing
(
aGraph
mRequestedInputChannelCount
)
;
}
void
AudioInputProcessing
:
:
Stop
(
MediaTrackGraphImpl
*
aGraph
)
{
MOZ_ASSERT
(
aGraph
-
>
OnGraphThread
(
)
)
;
if
(
!
mEnabled
)
{
return
;
}
mEnabled
=
false
;
if
(
mSkipProcessing
)
{
return
;
}
ResetAudioProcessing
(
aGraph
)
;
}
void
AudioInputProcessing
:
:
Process
(
MediaTrackGraphImpl
*
aGraph
GraphTime
aFrom
GraphTime
aTo
AudioSegment
*
aInput
AudioSegment
*
aOutput
)
{
MOZ_ASSERT
(
aGraph
-
>
OnGraphThread
(
)
)
;
MOZ_ASSERT
(
aFrom
<
=
aTo
)
;
MOZ_ASSERT
(
!
mEnded
)
;
TrackTime
need
=
aTo
-
aFrom
;
if
(
need
=
=
0
)
{
return
;
}
if
(
!
mEnabled
)
{
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioInputProcessing
%
p
Filling
%
"
PRId64
"
frames
of
silence
to
output
(
disabled
)
"
aGraph
aGraph
-
>
CurrentDriver
(
)
this
need
)
;
aOutput
-
>
AppendNullData
(
need
)
;
return
;
}
MOZ_ASSERT
(
aInput
-
>
GetDuration
(
)
=
=
need
"
Wrong
data
length
from
input
port
source
"
)
;
if
(
PassThrough
(
aGraph
)
)
{
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioInputProcessing
%
p
Forwarding
%
"
PRId64
"
frames
of
input
data
to
output
directly
(
PassThrough
)
"
aGraph
aGraph
-
>
CurrentDriver
(
)
this
aInput
-
>
GetDuration
(
)
)
;
aOutput
-
>
AppendSegment
(
aInput
)
;
return
;
}
MOZ_ASSERT
(
mPacketizerInput
)
;
EnsureAudioProcessing
(
aGraph
mRequestedInputChannelCount
)
;
MOZ_ASSERT
(
static_cast
<
uint32_t
>
(
mSegment
.
GetDuration
(
)
)
+
mPacketizerInput
-
>
FramesAvailable
(
)
=
=
mPacketizerInput
-
>
mPacketSize
)
;
MOZ_ASSERT
(
mSegment
.
GetDuration
(
)
>
=
1
)
;
MOZ_ASSERT
(
mSegment
.
GetDuration
(
)
<
=
mPacketizerInput
-
>
mPacketSize
)
;
PacketizeAndProcess
(
aGraph
*
aInput
)
;
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioInputProcessing
%
p
Buffer
has
%
"
PRId64
"
frames
of
data
now
after
packetizing
and
processing
"
aGraph
aGraph
-
>
CurrentDriver
(
)
this
mSegment
.
GetDuration
(
)
)
;
MOZ_ASSERT
(
mSegment
.
GetDuration
(
)
>
need
)
;
aOutput
-
>
AppendSlice
(
mSegment
0
need
)
;
mSegment
.
RemoveLeading
(
need
)
;
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioInputProcessing
%
p
moving
%
"
PRId64
"
frames
of
data
to
output
leaving
%
"
PRId64
"
frames
in
buffer
"
aGraph
aGraph
-
>
CurrentDriver
(
)
this
need
mSegment
.
GetDuration
(
)
)
;
MOZ_ASSERT
(
static_cast
<
uint32_t
>
(
mSegment
.
GetDuration
(
)
)
+
mPacketizerInput
-
>
FramesAvailable
(
)
=
=
mPacketizerInput
-
>
mPacketSize
)
;
MOZ_ASSERT
(
mSegment
.
GetDuration
(
)
>
=
1
)
;
MOZ_ASSERT
(
mSegment
.
GetDuration
(
)
<
=
mPacketizerInput
-
>
mPacketSize
)
;
}
void
AudioInputProcessing
:
:
ProcessOutputData
(
MediaTrackGraphImpl
*
aGraph
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
{
MOZ_ASSERT
(
aGraph
-
>
OnGraphThread
(
)
)
;
if
(
!
mEnabled
|
|
PassThrough
(
aGraph
)
)
{
return
;
}
if
(
!
mPacketizerOutput
|
|
mPacketizerOutput
-
>
mPacketSize
!
=
GetPacketSize
(
aRate
)
|
|
mPacketizerOutput
-
>
mChannels
!
=
aChannels
)
{
mPacketizerOutput
=
Nothing
(
)
;
mPacketizerOutput
.
emplace
(
GetPacketSize
(
aRate
)
aChannels
)
;
}
mPacketizerOutput
-
>
Input
(
aBuffer
aFrames
)
;
while
(
mPacketizerOutput
-
>
PacketsAvailable
(
)
)
{
uint32_t
samplesPerPacket
=
mPacketizerOutput
-
>
mPacketSize
*
mPacketizerOutput
-
>
mChannels
;
if
(
mOutputBuffer
.
Length
(
)
<
samplesPerPacket
)
{
mOutputBuffer
.
SetLength
(
samplesPerPacket
)
;
}
if
(
mDeinterleavedBuffer
.
Length
(
)
<
samplesPerPacket
)
{
mDeinterleavedBuffer
.
SetLength
(
samplesPerPacket
)
;
}
float
*
packet
=
mOutputBuffer
.
Data
(
)
;
mPacketizerOutput
-
>
Output
(
packet
)
;
AutoTArray
<
float
*
MAX_CHANNELS
>
deinterleavedPacketDataChannelPointers
;
float
*
interleavedFarend
=
nullptr
;
uint32_t
channelCountFarend
=
0
;
uint32_t
framesPerPacketFarend
=
0
;
if
(
aChannels
>
MAX_CHANNELS
)
{
AudioConverter
converter
(
AudioConfig
(
aChannels
0
AudioConfig
:
:
FORMAT_FLT
)
AudioConfig
(
MAX_CHANNELS
0
AudioConfig
:
:
FORMAT_FLT
)
)
;
framesPerPacketFarend
=
mPacketizerOutput
-
>
mPacketSize
;
framesPerPacketFarend
=
converter
.
Process
(
mInputDownmixBuffer
packet
framesPerPacketFarend
)
;
interleavedFarend
=
mInputDownmixBuffer
.
Data
(
)
;
channelCountFarend
=
MAX_CHANNELS
;
deinterleavedPacketDataChannelPointers
.
SetLength
(
MAX_CHANNELS
)
;
}
else
{
interleavedFarend
=
packet
;
channelCountFarend
=
aChannels
;
framesPerPacketFarend
=
mPacketizerOutput
-
>
mPacketSize
;
deinterleavedPacketDataChannelPointers
.
SetLength
(
aChannels
)
;
}
MOZ_ASSERT
(
interleavedFarend
&
&
(
channelCountFarend
=
=
1
|
|
channelCountFarend
=
=
2
)
&
&
framesPerPacketFarend
)
;
if
(
mInputBuffer
.
Length
(
)
<
framesPerPacketFarend
*
channelCountFarend
)
{
mInputBuffer
.
SetLength
(
framesPerPacketFarend
*
channelCountFarend
)
;
}
size_t
offset
=
0
;
for
(
size_t
i
=
0
;
i
<
deinterleavedPacketDataChannelPointers
.
Length
(
)
;
+
+
i
)
{
deinterleavedPacketDataChannelPointers
[
i
]
=
mInputBuffer
.
Data
(
)
+
offset
;
offset
+
=
framesPerPacketFarend
;
}
DeinterleaveAndConvertBuffer
(
interleavedFarend
framesPerPacketFarend
channelCountFarend
deinterleavedPacketDataChannelPointers
.
Elements
(
)
)
;
StreamConfig
inputConfig
(
aRate
channelCountFarend
false
)
;
StreamConfig
outputConfig
=
inputConfig
;
DebugOnly
<
int
>
err
=
mAudioProcessing
-
>
ProcessReverseStream
(
deinterleavedPacketDataChannelPointers
.
Elements
(
)
inputConfig
outputConfig
deinterleavedPacketDataChannelPointers
.
Elements
(
)
)
;
MOZ_ASSERT
(
!
err
"
Could
not
process
the
reverse
stream
.
"
)
;
}
}
void
AudioInputProcessing
:
:
PacketizeAndProcess
(
MediaTrackGraphImpl
*
aGraph
const
AudioSegment
&
aSegment
)
{
MOZ_ASSERT
(
!
PassThrough
(
aGraph
)
"
This
should
be
bypassed
when
in
PassThrough
mode
.
"
)
;
MOZ_ASSERT
(
mEnabled
)
;
MOZ_ASSERT
(
mPacketizerInput
)
;
MOZ_ASSERT
(
mPacketizerInput
-
>
mPacketSize
=
=
GetPacketSize
(
aGraph
-
>
GraphRate
(
)
)
)
;
auto
pendingFrames
=
[
&
]
(
)
{
TrackTime
frames
=
0
;
for
(
const
auto
&
p
:
mChunksInPacketizer
)
{
frames
+
=
p
.
first
;
}
return
frames
;
}
;
MOZ_ASSERT
(
mPacketizerInput
-
>
FramesAvailable
(
)
=
=
static_cast
<
uint32_t
>
(
pendingFrames
(
)
)
)
;
size_t
sampleCount
=
aSegment
.
WriteToInterleavedBuffer
(
mInterleavedBuffer
mPacketizerInput
-
>
mChannels
)
;
size_t
frameCount
=
sampleCount
/
static_cast
<
size_t
>
(
mPacketizerInput
-
>
mChannels
)
;
mPacketizerInput
-
>
Input
(
mInterleavedBuffer
.
Elements
(
)
static_cast
<
uint32_t
>
(
frameCount
)
)
;
for
(
AudioSegment
:
:
ConstChunkIterator
iter
(
aSegment
)
;
!
iter
.
IsEnded
(
)
;
iter
.
Next
(
)
)
{
MOZ_ASSERT
(
iter
-
>
mDuration
>
0
)
;
mChunksInPacketizer
.
emplace_back
(
std
:
:
make_pair
(
iter
-
>
mDuration
iter
-
>
mPrincipalHandle
)
)
;
}
MOZ_ASSERT
(
mPacketizerInput
-
>
FramesAvailable
(
)
=
=
static_cast
<
uint32_t
>
(
pendingFrames
(
)
)
)
;
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioInputProcessing
%
p
Packetizing
%
zu
frames
.
"
"
Packetizer
has
%
u
frames
(
enough
for
%
u
packets
)
now
"
aGraph
aGraph
-
>
CurrentDriver
(
)
this
frameCount
mPacketizerInput
-
>
FramesAvailable
(
)
mPacketizerInput
-
>
PacketsAvailable
(
)
)
;
size_t
offset
=
0
;
while
(
mPacketizerInput
-
>
PacketsAvailable
(
)
)
{
mPacketCount
+
+
;
uint32_t
samplesPerPacket
=
mPacketizerInput
-
>
mPacketSize
*
mPacketizerInput
-
>
mChannels
;
if
(
mInputBuffer
.
Length
(
)
<
samplesPerPacket
)
{
mInputBuffer
.
SetLength
(
samplesPerPacket
)
;
}
if
(
mDeinterleavedBuffer
.
Length
(
)
<
samplesPerPacket
)
{
mDeinterleavedBuffer
.
SetLength
(
samplesPerPacket
)
;
}
float
*
packet
=
mInputBuffer
.
Data
(
)
;
mPacketizerInput
-
>
Output
(
packet
)
;
AutoTArray
<
float
*
8
>
deinterleavedPacketizedInputDataChannelPointers
;
uint32_t
channelCountInput
=
0
;
if
(
mPacketizerInput
-
>
mChannels
>
MAX_CHANNELS
)
{
channelCountInput
=
MONO
;
deinterleavedPacketizedInputDataChannelPointers
.
SetLength
(
channelCountInput
)
;
deinterleavedPacketizedInputDataChannelPointers
[
0
]
=
mDeinterleavedBuffer
.
Data
(
)
;
size_t
readIndex
=
0
;
for
(
size_t
i
=
0
;
i
<
mPacketizerInput
-
>
mPacketSize
;
i
+
+
)
{
mDeinterleavedBuffer
.
Data
(
)
[
i
]
=
0
.
;
for
(
size_t
j
=
0
;
j
<
mPacketizerInput
-
>
mChannels
;
j
+
+
)
{
mDeinterleavedBuffer
.
Data
(
)
[
i
]
+
=
packet
[
readIndex
+
+
]
;
}
}
}
else
{
channelCountInput
=
mPacketizerInput
-
>
mChannels
;
deinterleavedPacketizedInputDataChannelPointers
.
SetLength
(
channelCountInput
)
;
offset
=
0
;
for
(
size_t
i
=
0
;
i
<
deinterleavedPacketizedInputDataChannelPointers
.
Length
(
)
;
+
+
i
)
{
deinterleavedPacketizedInputDataChannelPointers
[
i
]
=
mDeinterleavedBuffer
.
Data
(
)
+
offset
;
offset
+
=
mPacketizerInput
-
>
mPacketSize
;
}
Deinterleave
(
packet
mPacketizerInput
-
>
mPacketSize
channelCountInput
deinterleavedPacketizedInputDataChannelPointers
.
Elements
(
)
)
;
}
StreamConfig
inputConfig
(
aGraph
-
>
GraphRate
(
)
channelCountInput
false
)
;
StreamConfig
outputConfig
=
inputConfig
;
mAudioProcessing
-
>
set_stream_delay_ms
(
0
)
;
CheckedInt
<
size_t
>
bufferSize
(
sizeof
(
float
)
)
;
bufferSize
*
=
mPacketizerInput
-
>
mPacketSize
;
bufferSize
*
=
channelCountInput
;
RefPtr
<
SharedBuffer
>
buffer
=
SharedBuffer
:
:
Create
(
bufferSize
)
;
AutoTArray
<
float
*
8
>
processedOutputChannelPointers
;
AutoTArray
<
const
float
*
8
>
processedOutputChannelPointersConst
;
processedOutputChannelPointers
.
SetLength
(
channelCountInput
)
;
processedOutputChannelPointersConst
.
SetLength
(
channelCountInput
)
;
offset
=
0
;
for
(
size_t
i
=
0
;
i
<
processedOutputChannelPointers
.
Length
(
)
;
+
+
i
)
{
processedOutputChannelPointers
[
i
]
=
static_cast
<
float
*
>
(
buffer
-
>
Data
(
)
)
+
offset
;
processedOutputChannelPointersConst
[
i
]
=
static_cast
<
float
*
>
(
buffer
-
>
Data
(
)
)
+
offset
;
offset
+
=
mPacketizerInput
-
>
mPacketSize
;
}
mAudioProcessing
-
>
ProcessStream
(
deinterleavedPacketizedInputDataChannelPointers
.
Elements
(
)
inputConfig
outputConfig
processedOutputChannelPointers
.
Elements
(
)
)
;
if
(
MOZ_LOG_TEST
(
gMediaManagerLog
LogLevel
:
:
Debug
)
&
&
!
(
mPacketCount
%
50
)
)
{
AudioProcessingStats
stats
=
mAudioProcessing
-
>
GetStatistics
(
)
;
char
msg
[
1024
]
;
size_t
offset
=
0
;
#
define
AddIfValue
(
format
member
)
\
if
(
stats
.
member
.
has_value
(
)
)
{
\
offset
+
=
SprintfBuf
(
msg
+
offset
sizeof
(
msg
)
-
offset
\
#
member
"
:
"
format
"
"
stats
.
member
.
value
(
)
)
;
\
}
AddIfValue
(
"
%
d
"
output_rms_dbfs
)
;
AddIfValue
(
"
%
d
"
voice_detected
)
;
AddIfValue
(
"
%
lf
"
echo_return_loss
)
;
AddIfValue
(
"
%
lf
"
echo_return_loss_enhancement
)
;
AddIfValue
(
"
%
lf
"
divergent_filter_fraction
)
;
AddIfValue
(
"
%
d
"
delay_median_ms
)
;
AddIfValue
(
"
%
d
"
delay_standard_deviation_ms
)
;
AddIfValue
(
"
%
lf
"
residual_echo_likelihood
)
;
AddIfValue
(
"
%
lf
"
residual_echo_likelihood_recent_max
)
;
AddIfValue
(
"
%
d
"
delay_ms
)
;
#
undef
AddIfValue
LOG
(
"
AudioProcessing
statistics
:
%
s
"
msg
)
;
}
if
(
mEnded
)
{
continue
;
}
MOZ_ASSERT
(
processedOutputChannelPointers
.
Length
(
)
=
=
channelCountInput
)
;
auto
getAudioChunk
=
[
&
]
(
TrackTime
aStart
TrackTime
aEnd
const
PrincipalHandle
&
aPrincipalHandle
)
{
if
(
aStart
=
=
aEnd
)
{
return
AudioChunk
(
)
;
}
RefPtr
<
SharedBuffer
>
other
=
buffer
;
AudioChunk
c
=
AudioChunk
(
other
.
forget
(
)
processedOutputChannelPointersConst
static_cast
<
TrackTime
>
(
mPacketizerInput
-
>
mPacketSize
)
aPrincipalHandle
)
;
c
.
SliceTo
(
aStart
aEnd
)
;
return
c
;
}
;
TrackTime
len
=
static_cast
<
TrackTime
>
(
mPacketizerInput
-
>
mPacketSize
)
;
TrackTime
start
=
0
;
while
(
!
mChunksInPacketizer
.
empty
(
)
)
{
auto
&
[
frames
principal
]
=
mChunksInPacketizer
.
front
(
)
;
const
TrackTime
end
=
start
+
frames
;
if
(
end
>
len
)
{
if
(
len
>
start
)
{
mSegment
.
AppendAndConsumeChunk
(
getAudioChunk
(
start
len
principal
)
)
;
frames
-
=
len
-
start
;
}
break
;
}
mSegment
.
AppendAndConsumeChunk
(
getAudioChunk
(
start
end
principal
)
)
;
start
=
end
;
mChunksInPacketizer
.
pop_front
(
)
;
}
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioInputProcessing
%
p
Appending
%
u
frames
of
"
"
packetized
audio
leaving
%
u
frames
in
packetizer
(
%
"
PRId64
"
frames
in
mChunksInPacketizer
)
"
aGraph
aGraph
-
>
CurrentDriver
(
)
this
mPacketizerInput
-
>
mPacketSize
mPacketizerInput
-
>
FramesAvailable
(
)
pendingFrames
(
)
)
;
MOZ_ASSERT
(
mPacketizerInput
-
>
FramesAvailable
(
)
=
=
static_cast
<
uint32_t
>
(
pendingFrames
(
)
)
)
;
}
}
void
AudioInputProcessing
:
:
DeviceChanged
(
MediaTrackGraphImpl
*
aGraph
)
{
MOZ_ASSERT
(
aGraph
-
>
OnGraphThread
(
)
)
;
mAudioProcessing
-
>
Initialize
(
)
;
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioInputProcessing
%
p
Reinitializing
audio
"
"
processing
"
aGraph
aGraph
-
>
CurrentDriver
(
)
this
)
;
}
void
AudioInputProcessing
:
:
ApplyConfig
(
MediaTrackGraphImpl
*
aGraph
const
AudioProcessing
:
:
Config
&
aConfig
)
{
MOZ_ASSERT
(
aGraph
-
>
OnGraphThread
(
)
)
;
mAudioProcessing
-
>
ApplyConfig
(
aConfig
)
;
}
void
AudioInputProcessing
:
:
End
(
)
{
mEnded
=
true
;
mSegment
.
Clear
(
)
;
}
TrackTime
AudioInputProcessing
:
:
NumBufferedFrames
(
MediaTrackGraphImpl
*
aGraph
)
const
{
MOZ_ASSERT
(
aGraph
-
>
OnGraphThread
(
)
)
;
return
mSegment
.
GetDuration
(
)
;
}
void
AudioInputProcessing
:
:
EnsureAudioProcessing
(
MediaTrackGraphImpl
*
aGraph
uint32_t
aChannels
)
{
MOZ_ASSERT
(
aGraph
-
>
OnGraphThread
(
)
)
;
MOZ_ASSERT
(
aChannels
>
0
)
;
MOZ_ASSERT
(
mEnabled
)
;
MOZ_ASSERT
(
!
mSkipProcessing
)
;
if
(
mPacketizerInput
&
&
mPacketizerInput
-
>
mChannels
=
=
aChannels
)
{
return
;
}
MOZ_ASSERT_IF
(
mPacketizerInput
mPacketizerInput
-
>
mPacketSize
=
=
GetPacketSize
(
aGraph
-
>
GraphRate
(
)
)
)
;
bool
needPreBuffering
=
!
mPacketizerInput
;
if
(
mPacketizerInput
)
{
const
TrackTime
numBufferedFrames
=
static_cast
<
TrackTime
>
(
mPacketizerInput
-
>
FramesAvailable
(
)
)
;
mSegment
.
AppendNullData
(
numBufferedFrames
)
;
mPacketizerInput
=
Nothing
(
)
;
mChunksInPacketizer
.
clear
(
)
;
}
mPacketizerInput
.
emplace
(
GetPacketSize
(
aGraph
-
>
GraphRate
(
)
)
aChannels
)
;
if
(
needPreBuffering
)
{
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioInputProcessing
%
p
:
Adding
%
u
frames
of
"
"
silence
as
pre
-
buffering
"
aGraph
aGraph
-
>
CurrentDriver
(
)
this
mPacketizerInput
-
>
mPacketSize
)
;
AudioSegment
buffering
;
buffering
.
AppendNullData
(
static_cast
<
TrackTime
>
(
mPacketizerInput
-
>
mPacketSize
)
)
;
PacketizeAndProcess
(
aGraph
buffering
)
;
}
}
void
AudioInputProcessing
:
:
ResetAudioProcessing
(
MediaTrackGraphImpl
*
aGraph
)
{
MOZ_ASSERT
(
aGraph
-
>
OnGraphThread
(
)
)
;
MOZ_ASSERT
(
mSkipProcessing
|
|
!
mEnabled
)
;
MOZ_ASSERT
(
mPacketizerInput
)
;
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioInputProcessing
%
p
Resetting
audio
"
"
processing
"
aGraph
aGraph
-
>
CurrentDriver
(
)
this
)
;
mAudioProcessing
-
>
Initialize
(
)
;
MOZ_ASSERT
(
static_cast
<
uint32_t
>
(
mSegment
.
GetDuration
(
)
)
+
mPacketizerInput
-
>
FramesAvailable
(
)
=
=
mPacketizerInput
-
>
mPacketSize
)
;
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioInputProcessing
%
p
Emptying
out
%
"
PRId64
"
frames
of
data
"
aGraph
aGraph
-
>
CurrentDriver
(
)
this
mSegment
.
GetDuration
(
)
)
;
mSegment
.
Clear
(
)
;
mPacketizerInput
=
Nothing
(
)
;
mChunksInPacketizer
.
clear
(
)
;
}
void
AudioProcessingTrack
:
:
Destroy
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
DisconnectDeviceInput
(
)
;
MediaTrack
:
:
Destroy
(
)
;
}
void
AudioProcessingTrack
:
:
SetInputProcessing
(
RefPtr
<
AudioInputProcessing
>
aInputProcessing
)
{
class
Message
:
public
ControlMessage
{
const
RefPtr
<
AudioProcessingTrack
>
mTrack
;
const
RefPtr
<
AudioInputProcessing
>
mProcessing
;
public
:
Message
(
RefPtr
<
AudioProcessingTrack
>
aTrack
RefPtr
<
AudioInputProcessing
>
aProcessing
)
:
ControlMessage
(
aTrack
)
mTrack
(
std
:
:
move
(
aTrack
)
)
mProcessing
(
std
:
:
move
(
aProcessing
)
)
{
}
void
Run
(
)
override
{
TRACE
(
"
AudioProcessingTrack
:
:
SetInputProcessingImpl
"
)
;
mTrack
-
>
SetInputProcessingImpl
(
mProcessing
)
;
}
}
;
if
(
IsDestroyed
(
)
)
{
return
;
}
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
std
:
:
move
(
this
)
std
:
:
move
(
aInputProcessing
)
)
)
;
}
AudioProcessingTrack
*
AudioProcessingTrack
:
:
Create
(
MediaTrackGraph
*
aGraph
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AudioProcessingTrack
*
track
=
new
AudioProcessingTrack
(
aGraph
-
>
GraphRate
(
)
)
;
aGraph
-
>
AddTrack
(
track
)
;
return
track
;
}
void
AudioProcessingTrack
:
:
DestroyImpl
(
)
{
ProcessedMediaTrack
:
:
DestroyImpl
(
)
;
if
(
mInputProcessing
)
{
mInputProcessing
-
>
End
(
)
;
}
}
void
AudioProcessingTrack
:
:
ProcessInput
(
GraphTime
aFrom
GraphTime
aTo
uint32_t
aFlags
)
{
TRACE_COMMENT
(
"
AudioProcessingTrack
:
:
ProcessInput
"
"
AudioProcessingTrack
%
p
"
this
)
;
MOZ_ASSERT
(
mInputProcessing
)
;
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioProcessingTrack
%
p
ProcessInput
from
%
"
PRId64
"
to
%
"
PRId64
"
needs
%
"
PRId64
"
frames
"
mGraph
mGraph
-
>
CurrentDriver
(
)
this
aFrom
aTo
aTo
-
aFrom
)
;
if
(
aFrom
>
=
aTo
)
{
return
;
}
if
(
!
mInputProcessing
-
>
IsEnded
(
)
)
{
MOZ_ASSERT
(
TrackTimeToGraphTime
(
GetEnd
(
)
)
=
=
aFrom
)
;
if
(
mInputs
.
IsEmpty
(
)
)
{
GetData
<
AudioSegment
>
(
)
-
>
AppendNullData
(
aTo
-
aFrom
)
;
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioProcessingTrack
%
p
Filling
%
"
PRId64
"
frames
of
null
data
(
no
input
source
)
"
mGraph
mGraph
-
>
CurrentDriver
(
)
this
aTo
-
aFrom
)
;
}
else
{
MOZ_ASSERT
(
mInputs
.
Length
(
)
=
=
1
)
;
AudioSegment
data
;
GetInputSourceData
(
data
mInputs
[
0
]
aFrom
aTo
)
;
mInputProcessing
-
>
Process
(
GraphImpl
(
)
aFrom
aTo
&
data
GetData
<
AudioSegment
>
(
)
)
;
}
MOZ_ASSERT
(
TrackTimeToGraphTime
(
GetEnd
(
)
)
=
=
aTo
)
;
ApplyTrackDisabling
(
mSegment
.
get
(
)
)
;
}
else
if
(
aFlags
&
ALLOW_END
)
{
mEnded
=
true
;
}
}
void
AudioProcessingTrack
:
:
GetInputSourceData
(
AudioSegment
&
aOutput
const
MediaInputPort
*
aPort
GraphTime
aFrom
GraphTime
aTo
)
const
{
MOZ_ASSERT
(
mGraph
-
>
OnGraphThread
(
)
)
;
MOZ_ASSERT
(
aOutput
.
IsEmpty
(
)
)
;
MediaTrack
*
source
=
aPort
-
>
GetSource
(
)
;
GraphTime
next
;
for
(
GraphTime
t
=
aFrom
;
t
<
aTo
;
t
=
next
)
{
MediaInputPort
:
:
InputInterval
interval
=
MediaInputPort
:
:
GetNextInputInterval
(
aPort
t
)
;
interval
.
mEnd
=
std
:
:
min
(
interval
.
mEnd
aTo
)
;
const
bool
inputEnded
=
source
-
>
Ended
(
)
&
&
source
-
>
GetEnd
(
)
<
=
source
-
>
GraphTimeToTrackTimeWithBlocking
(
interval
.
mStart
)
;
TrackTime
ticks
=
interval
.
mEnd
-
interval
.
mStart
;
next
=
interval
.
mEnd
;
if
(
interval
.
mStart
>
=
interval
.
mEnd
)
{
break
;
}
if
(
inputEnded
)
{
aOutput
.
AppendNullData
(
ticks
)
;
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioProcessingTrack
%
p
Getting
%
"
PRId64
"
ticks
of
null
data
from
input
port
source
(
ended
input
)
"
mGraph
mGraph
-
>
CurrentDriver
(
)
this
ticks
)
;
}
else
if
(
interval
.
mInputIsBlocked
)
{
aOutput
.
AppendNullData
(
ticks
)
;
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioProcessingTrack
%
p
Getting
%
"
PRId64
"
ticks
of
null
data
from
input
port
source
(
blocked
input
)
"
mGraph
mGraph
-
>
CurrentDriver
(
)
this
ticks
)
;
}
else
if
(
source
-
>
IsSuspended
(
)
)
{
aOutput
.
AppendNullData
(
ticks
)
;
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioProcessingTrack
%
p
Getting
%
"
PRId64
"
ticks
of
null
data
from
input
port
source
(
source
is
suspended
)
"
mGraph
mGraph
-
>
CurrentDriver
(
)
this
ticks
)
;
}
else
{
TrackTime
start
=
source
-
>
GraphTimeToTrackTimeWithBlocking
(
interval
.
mStart
)
;
TrackTime
end
=
source
-
>
GraphTimeToTrackTimeWithBlocking
(
interval
.
mEnd
)
;
MOZ_ASSERT
(
source
-
>
GetData
<
AudioSegment
>
(
)
-
>
GetDuration
(
)
>
=
end
)
;
aOutput
.
AppendSlice
(
*
source
-
>
GetData
<
AudioSegment
>
(
)
start
end
)
;
LOG_FRAME
(
"
(
Graph
%
p
Driver
%
p
)
AudioInputTrack
%
p
Getting
%
"
PRId64
"
ticks
of
real
data
from
input
port
source
%
p
"
mGraph
mGraph
-
>
CurrentDriver
(
)
this
end
-
start
source
)
;
}
}
}
void
AudioProcessingTrack
:
:
NotifyOutputData
(
MediaTrackGraphImpl
*
aGraph
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
{
MOZ_ASSERT
(
mGraph
=
=
aGraph
"
Cannot
feed
audio
output
to
another
graph
"
)
;
MOZ_ASSERT
(
mGraph
-
>
OnGraphThread
(
)
)
;
if
(
mInputProcessing
)
{
mInputProcessing
-
>
ProcessOutputData
(
aGraph
aBuffer
aFrames
aRate
aChannels
)
;
}
}
void
AudioProcessingTrack
:
:
SetInputProcessingImpl
(
RefPtr
<
AudioInputProcessing
>
aInputProcessing
)
{
MOZ_ASSERT
(
GraphImpl
(
)
-
>
OnGraphThread
(
)
)
;
mInputProcessing
=
std
:
:
move
(
aInputProcessing
)
;
}
nsresult
AudioProcessingTrack
:
:
ConnectDeviceInput
(
CubebUtils
:
:
AudioDeviceID
aId
AudioDataListener
*
aListener
const
PrincipalHandle
&
aPrincipal
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
GraphImpl
(
)
)
;
MOZ_ASSERT
(
!
mInputListener
)
;
MOZ_ASSERT
(
mDeviceId
.
isNothing
(
)
)
;
mInputListener
=
aListener
;
mDeviceId
.
emplace
(
aId
)
;
auto
r
=
NativeInputTrack
:
:
OpenAudio
(
GraphImpl
(
)
aId
aPrincipal
mInputListener
.
get
(
)
)
;
if
(
r
.
isErr
(
)
)
{
NS_WARNING
(
"
Failed
to
open
audio
device
.
"
)
;
return
r
.
unwrapErr
(
)
;
}
mDeviceInputTrack
=
r
.
unwrap
(
)
;
MOZ_ASSERT
(
mDeviceInputTrack
)
;
LOG
(
"
Open
device
%
p
(
InputTrack
=
%
p
)
for
Mic
source
%
p
"
aId
mDeviceInputTrack
.
get
(
)
this
)
;
mPort
=
AllocateInputPort
(
mDeviceInputTrack
.
get
(
)
)
;
return
NS_OK
;
}
void
AudioProcessingTrack
:
:
DisconnectDeviceInput
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
GraphImpl
(
)
)
;
if
(
!
mInputListener
)
{
return
;
}
MOZ_ASSERT
(
mPort
)
;
MOZ_ASSERT
(
mDeviceId
.
isSome
(
)
)
;
LOG
(
"
Close
device
%
p
(
InputTrack
=
%
p
)
for
Mic
source
%
p
"
*
mDeviceId
mDeviceInputTrack
.
get
(
)
this
)
;
mPort
-
>
Destroy
(
)
;
NativeInputTrack
:
:
CloseAudio
(
std
:
:
move
(
mDeviceInputTrack
)
mInputListener
.
get
(
)
)
;
mInputListener
=
nullptr
;
mDeviceId
=
Nothing
(
)
;
}
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
AudioProcessingTrack
:
:
DeviceId
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mDeviceId
;
}
MediaEngineWebRTCAudioCaptureSource
:
:
MediaEngineWebRTCAudioCaptureSource
(
const
MediaDevice
*
aMediaDevice
)
{
MOZ_ASSERT
(
aMediaDevice
-
>
mMediaSource
=
=
MediaSourceEnum
:
:
AudioCapture
)
;
}
nsString
MediaEngineWebRTCAudioCaptureSource
:
:
GetUUID
(
)
{
nsID
uuid
{
}
;
char
uuidBuffer
[
NSID_LENGTH
]
;
nsCString
asciiString
;
ErrorResult
rv
;
rv
=
nsID
:
:
GenerateUUIDInPlace
(
uuid
)
;
if
(
rv
.
Failed
(
)
)
{
return
u
"
"
_ns
;
}
uuid
.
ToProvidedString
(
uuidBuffer
)
;
asciiString
.
AssignASCII
(
uuidBuffer
)
;
return
NS_ConvertASCIItoUTF16
(
Substring
(
asciiString
1
NSID_LENGTH
-
3
)
)
;
}
nsString
MediaEngineWebRTCAudioCaptureSource
:
:
GetGroupId
(
)
{
return
u
"
AudioCaptureGroup
"
_ns
;
}
void
MediaEngineWebRTCAudioCaptureSource
:
:
SetTrack
(
const
RefPtr
<
MediaTrack
>
&
aTrack
const
PrincipalHandle
&
aPrincipalHandle
)
{
AssertIsOnOwningThread
(
)
;
}
nsresult
MediaEngineWebRTCAudioCaptureSource
:
:
Start
(
)
{
AssertIsOnOwningThread
(
)
;
return
NS_OK
;
}
nsresult
MediaEngineWebRTCAudioCaptureSource
:
:
Stop
(
)
{
AssertIsOnOwningThread
(
)
;
return
NS_OK
;
}
nsresult
MediaEngineWebRTCAudioCaptureSource
:
:
Reconfigure
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
char
*
*
aOutBadConstraint
)
{
return
NS_OK
;
}
void
MediaEngineWebRTCAudioCaptureSource
:
:
GetSettings
(
dom
:
:
MediaTrackSettings
&
aOutSettings
)
const
{
aOutSettings
.
mAutoGainControl
.
Construct
(
false
)
;
aOutSettings
.
mEchoCancellation
.
Construct
(
false
)
;
aOutSettings
.
mNoiseSuppression
.
Construct
(
false
)
;
aOutSettings
.
mChannelCount
.
Construct
(
1
)
;
}
}
#
undef
MAX_CHANNELS
#
undef
MONO
#
undef
MAX_SAMPLING_FREQ
