#
include
"
MediaEngineWebRTC
.
h
"
#
include
<
stdio
.
h
>
#
include
<
algorithm
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
MediaTrackConstraints
.
h
"
#
include
"
mtransport
/
runnable_utils
.
h
"
#
ifdef
FF
#
undef
FF
#
endif
#
include
"
webrtc
/
modules
/
audio_device
/
opensl
/
single_rw_fifo
.
h
"
#
define
CHANNELS
1
#
define
ENCODING
"
L16
"
#
define
DEFAULT_PORT
5555
#
define
SAMPLE_RATE
(
freq
)
(
(
freq
)
*
2
*
8
)
/
/
bps
16
-
bit
samples
#
define
SAMPLE_LENGTH
(
freq
)
(
(
(
freq
)
*
10
)
/
1000
)
#
define
MAX_CHANNELS
2
#
define
MAX_SAMPLING_FREQ
48000
/
/
Hz
-
multiple
of
100
#
define
MAX_AEC_FIFO_DEPTH
200
/
/
ms
-
multiple
of
10
static_assert
(
!
(
MAX_AEC_FIFO_DEPTH
%
10
)
"
Invalid
MAX_AEC_FIFO_DEPTH
"
)
;
namespace
mozilla
{
#
ifdef
LOG
#
undef
LOG
#
endif
extern
LogModule
*
GetMediaManagerLog
(
)
;
#
define
LOG
(
msg
)
MOZ_LOG
(
GetMediaManagerLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
msg
)
#
define
LOG_FRAMES
(
msg
)
MOZ_LOG
(
GetMediaManagerLog
(
)
mozilla
:
:
LogLevel
:
:
Verbose
msg
)
NS_IMPL_ISUPPORTS0
(
MediaEngineWebRTCMicrophoneSource
)
NS_IMPL_ISUPPORTS0
(
MediaEngineWebRTCAudioCaptureSource
)
StaticRefPtr
<
AudioOutputObserver
>
gFarendObserver
;
AudioOutputObserver
:
:
AudioOutputObserver
(
)
:
mPlayoutFreq
(
0
)
mPlayoutChannels
(
0
)
mChunkSize
(
0
)
mSaved
(
nullptr
)
mSamplesSaved
(
0
)
{
mPlayoutFifo
=
new
webrtc
:
:
SingleRwFifo
(
MAX_AEC_FIFO_DEPTH
/
10
)
;
}
AudioOutputObserver
:
:
~
AudioOutputObserver
(
)
{
Clear
(
)
;
free
(
mSaved
)
;
mSaved
=
nullptr
;
}
void
AudioOutputObserver
:
:
Clear
(
)
{
while
(
mPlayoutFifo
-
>
size
(
)
>
0
)
{
free
(
mPlayoutFifo
-
>
Pop
(
)
)
;
}
}
FarEndAudioChunk
*
AudioOutputObserver
:
:
Pop
(
)
{
return
(
FarEndAudioChunk
*
)
mPlayoutFifo
-
>
Pop
(
)
;
}
uint32_t
AudioOutputObserver
:
:
Size
(
)
{
return
mPlayoutFifo
-
>
size
(
)
;
}
void
AudioOutputObserver
:
:
MixerCallback
(
AudioDataValue
*
aMixedBuffer
AudioSampleFormat
aFormat
uint32_t
aChannels
uint32_t
aFrames
uint32_t
aSampleRate
)
{
if
(
gFarendObserver
)
{
gFarendObserver
-
>
InsertFarEnd
(
aMixedBuffer
aFrames
false
aSampleRate
aChannels
aFormat
)
;
}
}
void
AudioOutputObserver
:
:
InsertFarEnd
(
const
AudioDataValue
*
aBuffer
uint32_t
aFrames
bool
aOverran
int
aFreq
int
aChannels
AudioSampleFormat
aFormat
)
{
if
(
mPlayoutChannels
!
=
0
)
{
if
(
mPlayoutChannels
!
=
static_cast
<
uint32_t
>
(
aChannels
)
)
{
MOZ_CRASH
(
)
;
}
}
else
{
MOZ_ASSERT
(
aChannels
<
=
MAX_CHANNELS
)
;
mPlayoutChannels
=
static_cast
<
uint32_t
>
(
aChannels
)
;
}
if
(
mPlayoutFreq
!
=
0
)
{
if
(
mPlayoutFreq
!
=
static_cast
<
uint32_t
>
(
aFreq
)
)
{
MOZ_CRASH
(
)
;
}
}
else
{
MOZ_ASSERT
(
aFreq
<
=
MAX_SAMPLING_FREQ
)
;
MOZ_ASSERT
(
!
(
aFreq
%
100
)
"
Sampling
rate
for
far
end
data
should
be
multiple
of
100
.
"
)
;
mPlayoutFreq
=
aFreq
;
mChunkSize
=
aFreq
/
100
;
}
#
ifdef
LOG_FAREND_INSERTION
static
FILE
*
fp
=
fopen
(
"
insertfarend
.
pcm
"
"
wb
"
)
;
#
endif
if
(
mSaved
)
{
mSaved
-
>
mOverrun
=
aOverran
;
aOverran
=
false
;
}
while
(
aFrames
)
{
if
(
!
mSaved
)
{
mSaved
=
(
FarEndAudioChunk
*
)
moz_xmalloc
(
sizeof
(
FarEndAudioChunk
)
+
(
mChunkSize
*
aChannels
-
1
)
*
sizeof
(
int16_t
)
)
;
mSaved
-
>
mSamples
=
mChunkSize
;
mSaved
-
>
mOverrun
=
aOverran
;
aOverran
=
false
;
}
uint32_t
to_copy
=
mChunkSize
-
mSamplesSaved
;
if
(
to_copy
>
aFrames
)
{
to_copy
=
aFrames
;
}
int16_t
*
dest
=
&
(
mSaved
-
>
mData
[
mSamplesSaved
*
aChannels
]
)
;
ConvertAudioSamples
(
aBuffer
dest
to_copy
*
aChannels
)
;
#
ifdef
LOG_FAREND_INSERTION
if
(
fp
)
{
fwrite
(
&
(
mSaved
-
>
mData
[
mSamplesSaved
*
aChannels
]
)
to_copy
*
aChannels
sizeof
(
int16_t
)
fp
)
;
}
#
endif
aFrames
-
=
to_copy
;
mSamplesSaved
+
=
to_copy
;
aBuffer
+
=
to_copy
*
aChannels
;
if
(
mSamplesSaved
>
=
mChunkSize
)
{
int
free_slots
=
mPlayoutFifo
-
>
capacity
(
)
-
mPlayoutFifo
-
>
size
(
)
;
if
(
free_slots
<
=
0
)
{
break
;
}
else
{
mPlayoutFifo
-
>
Push
(
(
int8_t
*
)
mSaved
)
;
mSaved
=
nullptr
;
mSamplesSaved
=
0
;
}
}
}
}
void
MediaEngineWebRTCMicrophoneSource
:
:
GetName
(
nsAString
&
aName
)
{
if
(
mInitDone
)
{
aName
.
Assign
(
mDeviceName
)
;
}
return
;
}
void
MediaEngineWebRTCMicrophoneSource
:
:
GetUUID
(
nsACString
&
aUUID
)
{
if
(
mInitDone
)
{
aUUID
.
Assign
(
mDeviceUUID
)
;
}
return
;
}
uint32_t
MediaEngineWebRTCMicrophoneSource
:
:
GetBestFitnessDistance
(
const
nsTArray
<
const
dom
:
:
MediaTrackConstraintSet
*
>
&
aConstraintSets
const
nsString
&
aDeviceId
)
{
uint32_t
distance
=
0
;
for
(
const
MediaTrackConstraintSet
*
cs
:
aConstraintSets
)
{
distance
=
GetMinimumFitnessDistance
(
*
cs
false
aDeviceId
)
;
break
;
}
return
distance
;
}
nsresult
MediaEngineWebRTCMicrophoneSource
:
:
Allocate
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
)
{
AssertIsOnOwningThread
(
)
;
if
(
mState
=
=
kReleased
)
{
if
(
mInitDone
)
{
if
(
mAudioInput
-
>
SetRecordingDevice
(
mCapIndex
)
)
{
return
NS_ERROR_FAILURE
;
}
mState
=
kAllocated
;
LOG
(
(
"
Audio
device
%
d
allocated
"
mCapIndex
)
)
;
}
else
{
LOG
(
(
"
Audio
device
is
not
initalized
"
)
)
;
return
NS_ERROR_FAILURE
;
}
}
else
if
(
MOZ_LOG_TEST
(
GetMediaManagerLog
(
)
LogLevel
:
:
Debug
)
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
mSources
.
IsEmpty
(
)
)
{
LOG
(
(
"
Audio
device
%
d
reallocated
"
mCapIndex
)
)
;
}
else
{
LOG
(
(
"
Audio
device
%
d
allocated
shared
"
mCapIndex
)
)
;
}
}
+
+
mNrAllocations
;
return
Restart
(
aConstraints
aPrefs
aDeviceId
)
;
}
nsresult
MediaEngineWebRTCMicrophoneSource
:
:
Restart
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
)
{
FlattenedConstraints
c
(
aConstraints
)
;
bool
aec_on
=
c
.
mEchoCancellation
.
Get
(
aPrefs
.
mAecOn
)
;
bool
agc_on
=
c
.
mMozAutoGainControl
.
Get
(
aPrefs
.
mAgcOn
)
;
bool
noise_on
=
c
.
mMozNoiseSuppression
.
Get
(
aPrefs
.
mNoiseOn
)
;
LOG
(
(
"
Audio
config
:
aec
:
%
d
agc
:
%
d
noise
:
%
d
"
aec_on
?
aPrefs
.
mAec
:
-
1
agc_on
?
aPrefs
.
mAgc
:
-
1
noise_on
?
aPrefs
.
mNoise
:
-
1
)
)
;
bool
update_echo
=
(
mEchoOn
!
=
aec_on
)
;
bool
update_agc
=
(
mAgcOn
!
=
agc_on
)
;
bool
update_noise
=
(
mNoiseOn
!
=
noise_on
)
;
mEchoOn
=
aec_on
;
mAgcOn
=
agc_on
;
mNoiseOn
=
noise_on
;
mPlayoutDelay
=
aPrefs
.
mPlayoutDelay
;
if
(
(
webrtc
:
:
EcModes
)
aPrefs
.
mAec
!
=
webrtc
:
:
kEcUnchanged
)
{
if
(
mEchoCancel
!
=
(
webrtc
:
:
EcModes
)
aPrefs
.
mAec
)
{
update_echo
=
true
;
mEchoCancel
=
(
webrtc
:
:
EcModes
)
aPrefs
.
mAec
;
}
}
if
(
(
webrtc
:
:
AgcModes
)
aPrefs
.
mAgc
!
=
webrtc
:
:
kAgcUnchanged
)
{
if
(
mAGC
!
=
(
webrtc
:
:
AgcModes
)
aPrefs
.
mAgc
)
{
update_agc
=
true
;
mAGC
=
(
webrtc
:
:
AgcModes
)
aPrefs
.
mAgc
;
}
}
if
(
(
webrtc
:
:
NsModes
)
aPrefs
.
mNoise
!
=
webrtc
:
:
kNsUnchanged
)
{
if
(
mNoiseSuppress
!
=
(
webrtc
:
:
NsModes
)
aPrefs
.
mNoise
)
{
update_noise
=
true
;
mNoiseSuppress
=
(
webrtc
:
:
NsModes
)
aPrefs
.
mNoise
;
}
}
if
(
mInitDone
)
{
int
error
;
if
(
update_echo
&
&
0
!
=
(
error
=
mVoEProcessing
-
>
SetEcStatus
(
mEchoOn
(
webrtc
:
:
EcModes
)
aPrefs
.
mAec
)
)
)
{
LOG
(
(
"
%
s
Error
setting
Echo
Status
:
%
d
"
__FUNCTION__
error
)
)
;
if
(
mEchoOn
)
{
if
(
0
!
=
(
error
=
mVoEProcessing
-
>
SetEcMetricsStatus
(
true
)
)
)
{
LOG
(
(
"
%
s
Error
setting
Echo
Metrics
:
%
d
"
__FUNCTION__
error
)
)
;
}
}
}
if
(
update_agc
&
&
0
!
=
(
error
=
mVoEProcessing
-
>
SetAgcStatus
(
mAgcOn
(
webrtc
:
:
AgcModes
)
aPrefs
.
mAgc
)
)
)
{
LOG
(
(
"
%
s
Error
setting
AGC
Status
:
%
d
"
__FUNCTION__
error
)
)
;
}
if
(
update_noise
&
&
0
!
=
(
error
=
mVoEProcessing
-
>
SetNsStatus
(
mNoiseOn
(
webrtc
:
:
NsModes
)
aPrefs
.
mNoise
)
)
)
{
LOG
(
(
"
%
s
Error
setting
NoiseSuppression
Status
:
%
d
"
__FUNCTION__
error
)
)
;
}
}
return
NS_OK
;
}
nsresult
MediaEngineWebRTCMicrophoneSource
:
:
Deallocate
(
)
{
AssertIsOnOwningThread
(
)
;
-
-
mNrAllocations
;
MOZ_ASSERT
(
mNrAllocations
>
=
0
"
Double
-
deallocations
are
prohibited
"
)
;
if
(
mNrAllocations
=
=
0
)
{
if
(
mState
!
=
kStopped
&
&
mState
!
=
kAllocated
)
{
return
NS_ERROR_FAILURE
;
}
mState
=
kReleased
;
LOG
(
(
"
Audio
device
%
d
deallocated
"
mCapIndex
)
)
;
}
else
{
LOG
(
(
"
Audio
device
%
d
deallocated
but
still
in
use
"
mCapIndex
)
)
;
}
return
NS_OK
;
}
nsresult
MediaEngineWebRTCMicrophoneSource
:
:
Start
(
SourceMediaStream
*
aStream
TrackID
aID
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
mInitDone
|
|
!
aStream
)
{
return
NS_ERROR_FAILURE
;
}
{
MonitorAutoLock
lock
(
mMonitor
)
;
mSources
.
AppendElement
(
aStream
)
;
}
AudioSegment
*
segment
=
new
AudioSegment
(
)
;
aStream
-
>
AddAudioTrack
(
aID
mSampleFrequency
0
segment
SourceMediaStream
:
:
ADDTRACK_QUEUED
)
;
aStream
-
>
RegisterForAudioMixing
(
)
;
LOG
(
(
"
Start
audio
for
stream
%
p
"
aStream
)
)
;
if
(
mState
=
=
kStarted
)
{
MOZ_ASSERT
(
aID
=
=
mTrackID
)
;
return
NS_OK
;
}
mState
=
kStarted
;
mTrackID
=
aID
;
AsyncLatencyLogger
:
:
Get
(
true
)
;
MOZ_ASSERT
(
gFarendObserver
)
;
gFarendObserver
-
>
Clear
(
)
;
if
(
mVoEBase
-
>
StartReceive
(
mChannel
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mVoEBase
-
>
StartSend
(
mChannel
)
)
{
return
NS_ERROR_FAILURE
;
}
mVoERender
-
>
RegisterExternalMediaProcessing
(
mChannel
webrtc
:
:
kRecordingPerChannel
*
this
)
;
mAudioInput
-
>
StartRecording
(
aStream
-
>
Graph
(
)
mListener
)
;
return
NS_OK
;
}
nsresult
MediaEngineWebRTCMicrophoneSource
:
:
Stop
(
SourceMediaStream
*
aSource
TrackID
aID
)
{
AssertIsOnOwningThread
(
)
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
!
mSources
.
RemoveElement
(
aSource
)
)
{
return
NS_OK
;
}
aSource
-
>
EndTrack
(
aID
)
;
if
(
!
mSources
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
mState
!
=
kStarted
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mVoEBase
)
{
return
NS_ERROR_FAILURE
;
}
mState
=
kStopped
;
}
mAudioInput
-
>
StopRecording
(
aSource
-
>
Graph
(
)
mListener
)
;
mVoERender
-
>
DeRegisterExternalMediaProcessing
(
mChannel
webrtc
:
:
kRecordingPerChannel
)
;
if
(
mVoEBase
-
>
StopSend
(
mChannel
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mVoEBase
-
>
StopReceive
(
mChannel
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
MediaEngineWebRTCMicrophoneSource
:
:
NotifyPull
(
MediaStreamGraph
*
aGraph
SourceMediaStream
*
aSource
TrackID
aID
StreamTime
aDesiredTime
)
{
LOG_FRAMES
(
(
"
NotifyPull
desired
=
%
ld
"
(
int64_t
)
aDesiredTime
)
)
;
}
void
MediaEngineWebRTCMicrophoneSource
:
:
NotifyOutputData
(
MediaStreamGraph
*
aGraph
AudioDataValue
*
aBuffer
size_t
aFrames
uint32_t
aChannels
)
{
}
void
MediaEngineWebRTCMicrophoneSource
:
:
NotifyInputData
(
MediaStreamGraph
*
aGraph
const
AudioDataValue
*
aBuffer
size_t
aFrames
uint32_t
aChannels
)
{
if
(
!
mPacketizer
|
|
mPacketizer
-
>
PacketSize
(
)
!
=
mSampleFrequency
/
100
|
|
mPacketizer
-
>
Channels
(
)
!
=
aChannels
)
{
mPacketizer
=
new
AudioPacketizer
<
AudioDataValue
int16_t
>
(
mSampleFrequency
/
100
aChannels
)
;
}
mPacketizer
-
>
Input
(
aBuffer
static_cast
<
uint32_t
>
(
aFrames
)
)
;
while
(
mPacketizer
-
>
PacketsAvailable
(
)
)
{
uint32_t
samplesPerPacket
=
mPacketizer
-
>
PacketSize
(
)
*
mPacketizer
-
>
Channels
(
)
;
int16_t
*
packet
=
mPacketizer
-
>
Output
(
)
;
mVoERender
-
>
ExternalRecordingInsertData
(
packet
samplesPerPacket
mSampleFrequency
0
)
;
}
}
void
MediaEngineWebRTCMicrophoneSource
:
:
Init
(
)
{
mVoEBase
=
webrtc
:
:
VoEBase
:
:
GetInterface
(
mVoiceEngine
)
;
mVoEBase
-
>
Init
(
)
;
mVoERender
=
webrtc
:
:
VoEExternalMedia
:
:
GetInterface
(
mVoiceEngine
)
;
if
(
!
mVoERender
)
{
return
;
}
mVoENetwork
=
webrtc
:
:
VoENetwork
:
:
GetInterface
(
mVoiceEngine
)
;
if
(
!
mVoENetwork
)
{
return
;
}
mVoEProcessing
=
webrtc
:
:
VoEAudioProcessing
:
:
GetInterface
(
mVoiceEngine
)
;
if
(
!
mVoEProcessing
)
{
return
;
}
mChannel
=
mVoEBase
-
>
CreateChannel
(
)
;
if
(
mChannel
<
0
)
{
return
;
}
mNullTransport
=
new
NullTransport
(
)
;
if
(
mVoENetwork
-
>
RegisterExternalTransport
(
mChannel
*
mNullTransport
)
)
{
return
;
}
mSampleFrequency
=
MediaEngine
:
:
DEFAULT_SAMPLE_RATE
;
LOG
(
(
"
%
s
:
sampling
rate
%
u
"
__FUNCTION__
mSampleFrequency
)
)
;
if
(
mAudioInput
-
>
SetRecordingDevice
(
mCapIndex
)
)
{
return
;
}
#
ifndef
MOZ_B2G
bool
avail
=
false
;
mAudioInput
-
>
GetRecordingDeviceStatus
(
avail
)
;
if
(
!
avail
)
{
return
;
}
#
endif
ScopedCustomReleasePtr
<
webrtc
:
:
VoECodec
>
ptrVoECodec
(
webrtc
:
:
VoECodec
:
:
GetInterface
(
mVoiceEngine
)
)
;
if
(
!
ptrVoECodec
)
{
return
;
}
webrtc
:
:
CodecInst
codec
;
strcpy
(
codec
.
plname
ENCODING
)
;
codec
.
channels
=
CHANNELS
;
MOZ_ASSERT
(
mSampleFrequency
=
=
16000
|
|
mSampleFrequency
=
=
32000
)
;
codec
.
rate
=
SAMPLE_RATE
(
mSampleFrequency
)
;
codec
.
plfreq
=
mSampleFrequency
;
codec
.
pacsize
=
SAMPLE_LENGTH
(
mSampleFrequency
)
;
codec
.
pltype
=
0
;
if
(
!
ptrVoECodec
-
>
SetSendCodec
(
mChannel
codec
)
)
{
mInitDone
=
true
;
}
}
void
MediaEngineWebRTCMicrophoneSource
:
:
Shutdown
(
)
{
if
(
!
mInitDone
)
{
if
(
mChannel
!
=
-
1
&
&
mVoENetwork
)
{
mVoENetwork
-
>
DeRegisterExternalTransport
(
mChannel
)
;
}
delete
mNullTransport
;
mNullTransport
=
nullptr
;
return
;
}
if
(
mState
=
=
kStarted
)
{
SourceMediaStream
*
source
;
bool
empty
;
while
(
1
)
{
{
MonitorAutoLock
lock
(
mMonitor
)
;
empty
=
mSources
.
IsEmpty
(
)
;
if
(
empty
)
{
break
;
}
source
=
mSources
[
0
]
;
}
Stop
(
source
kAudioTrack
)
;
}
MOZ_ASSERT
(
mState
=
=
kStopped
)
;
}
if
(
mState
=
=
kAllocated
|
|
mState
=
=
kStopped
)
{
Deallocate
(
)
;
}
mVoEBase
-
>
Terminate
(
)
;
if
(
mChannel
!
=
-
1
)
{
mVoENetwork
-
>
DeRegisterExternalTransport
(
mChannel
)
;
}
delete
mNullTransport
;
mNullTransport
=
nullptr
;
mVoEProcessing
=
nullptr
;
mVoENetwork
=
nullptr
;
mVoERender
=
nullptr
;
mVoEBase
=
nullptr
;
mAudioInput
=
nullptr
;
mListener
=
nullptr
;
mState
=
kReleased
;
mInitDone
=
false
;
}
typedef
int16_t
sample
;
void
MediaEngineWebRTCMicrophoneSource
:
:
Process
(
int
channel
webrtc
:
:
ProcessingTypes
type
sample
*
audio10ms
int
length
int
samplingFreq
bool
isStereo
)
{
if
(
!
mStarted
)
{
mStarted
=
true
;
while
(
gFarendObserver
-
>
Size
(
)
>
1
)
{
free
(
gFarendObserver
-
>
Pop
(
)
)
;
}
}
while
(
gFarendObserver
-
>
Size
(
)
>
0
)
{
FarEndAudioChunk
*
buffer
=
gFarendObserver
-
>
Pop
(
)
;
if
(
buffer
)
{
int
length
=
buffer
-
>
mSamples
;
int
res
=
mVoERender
-
>
ExternalPlayoutData
(
buffer
-
>
mData
gFarendObserver
-
>
PlayoutFrequency
(
)
gFarendObserver
-
>
PlayoutChannels
(
)
mPlayoutDelay
length
)
;
free
(
buffer
)
;
if
(
res
=
=
-
1
)
{
return
;
}
}
}
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
mState
!
=
kStarted
)
return
;
uint32_t
len
=
mSources
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
RefPtr
<
SharedBuffer
>
buffer
=
SharedBuffer
:
:
Create
(
length
*
sizeof
(
sample
)
)
;
sample
*
dest
=
static_cast
<
sample
*
>
(
buffer
-
>
Data
(
)
)
;
memcpy
(
dest
audio10ms
length
*
sizeof
(
sample
)
)
;
nsAutoPtr
<
AudioSegment
>
segment
(
new
AudioSegment
(
)
)
;
nsAutoTArray
<
const
sample
*
1
>
channels
;
channels
.
AppendElement
(
dest
)
;
segment
-
>
AppendFrames
(
buffer
.
forget
(
)
channels
length
)
;
TimeStamp
insertTime
;
segment
-
>
GetStartTime
(
insertTime
)
;
if
(
mSources
[
i
]
)
{
LogTime
(
AsyncLatencyLogger
:
:
AudioTrackInsertion
LATENCY_STREAM_ID
(
mSources
[
i
]
.
get
(
)
mTrackID
)
(
i
+
1
<
len
)
?
0
:
1
insertTime
)
;
RUN_ON_THREAD
(
mThread
WrapRunnable
(
mSources
[
i
]
&
SourceMediaStream
:
:
AppendToTrack
mTrackID
segment
(
AudioSegment
*
)
nullptr
)
NS_DISPATCH_NORMAL
)
;
}
}
return
;
}
void
MediaEngineWebRTCAudioCaptureSource
:
:
GetName
(
nsAString
&
aName
)
{
aName
.
AssignLiteral
(
"
AudioCapture
"
)
;
}
void
MediaEngineWebRTCAudioCaptureSource
:
:
GetUUID
(
nsACString
&
aUUID
)
{
nsID
uuid
;
char
uuidBuffer
[
NSID_LENGTH
]
;
nsCString
asciiString
;
ErrorResult
rv
;
rv
=
nsContentUtils
:
:
GenerateUUIDInPlace
(
uuid
)
;
if
(
rv
.
Failed
(
)
)
{
aUUID
.
AssignLiteral
(
"
"
)
;
return
;
}
uuid
.
ToProvidedString
(
uuidBuffer
)
;
asciiString
.
AssignASCII
(
uuidBuffer
)
;
aUUID
.
Assign
(
Substring
(
asciiString
1
NSID_LENGTH
-
3
)
)
;
}
nsresult
MediaEngineWebRTCAudioCaptureSource
:
:
Start
(
SourceMediaStream
*
aMediaStream
TrackID
aId
)
{
AssertIsOnOwningThread
(
)
;
aMediaStream
-
>
AddTrack
(
aId
0
new
AudioSegment
(
)
)
;
return
NS_OK
;
}
nsresult
MediaEngineWebRTCAudioCaptureSource
:
:
Stop
(
SourceMediaStream
*
aMediaStream
TrackID
aId
)
{
AssertIsOnOwningThread
(
)
;
aMediaStream
-
>
EndAllTrackAndFinish
(
)
;
return
NS_OK
;
}
nsresult
MediaEngineWebRTCAudioCaptureSource
:
:
Restart
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
)
{
return
NS_OK
;
}
uint32_t
MediaEngineWebRTCAudioCaptureSource
:
:
GetBestFitnessDistance
(
const
nsTArray
<
const
dom
:
:
MediaTrackConstraintSet
*
>
&
aConstraintSets
const
nsString
&
aDeviceId
)
{
return
0
;
}
}
