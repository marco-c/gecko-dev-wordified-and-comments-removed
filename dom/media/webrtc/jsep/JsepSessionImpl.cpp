#
include
"
jsep
/
JsepSessionImpl
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
bitset
>
#
include
<
iterator
>
#
include
<
set
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
transport
/
logging
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
net
/
DataChannelProtocol
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nspr
.
h
"
#
include
"
nss
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
api
/
rtp_parameters
.
h
"
#
include
"
jsep
/
JsepTrack
.
h
"
#
include
"
jsep
/
JsepTransport
.
h
"
#
include
"
sdp
/
HybridSdpParser
.
h
"
#
include
"
sdp
/
SipccSdp
.
h
"
namespace
mozilla
{
MOZ_MTLOG_MODULE
(
"
jsep
"
)
#
define
JSEP_SET_ERROR
(
error
)
\
do
{
\
std
:
:
ostringstream
os
;
\
os
<
<
error
;
\
mLastError
=
os
.
str
(
)
;
\
MOZ_MTLOG
(
ML_ERROR
"
[
"
<
<
mName
<
<
"
]
:
"
<
<
mLastError
)
;
\
}
while
(
0
)
;
static
std
:
:
bitset
<
128
>
GetForbiddenSdpPayloadTypes
(
)
{
std
:
:
bitset
<
128
>
forbidden
(
0
)
;
forbidden
[
1
]
=
true
;
forbidden
[
2
]
=
true
;
forbidden
[
19
]
=
true
;
for
(
uint16_t
i
=
64
;
i
<
96
;
+
+
i
)
{
forbidden
[
i
]
=
true
;
}
return
forbidden
;
}
static
std
:
:
string
GetRandomHex
(
size_t
words
)
{
std
:
:
ostringstream
os
;
for
(
size_t
i
=
0
;
i
<
words
;
+
+
i
)
{
uint32_t
rand
;
SECStatus
rv
=
PK11_GenerateRandom
(
reinterpret_cast
<
unsigned
char
*
>
(
&
rand
)
sizeof
(
rand
)
)
;
if
(
rv
!
=
SECSuccess
)
{
MOZ_CRASH
(
)
;
return
"
"
;
}
os
<
<
std
:
:
hex
<
<
std
:
:
setfill
(
'
0
'
)
<
<
std
:
:
setw
(
8
)
<
<
rand
;
}
return
os
.
str
(
)
;
}
nsresult
JsepSessionImpl
:
:
Init
(
)
{
mLastError
.
clear
(
)
;
MOZ_ASSERT
(
!
mSessionId
"
Init
called
more
than
once
"
)
;
nsresult
rv
=
SetupIds
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SetupDefaultCodecs
(
)
;
SetupDefaultRtpExtensions
(
)
;
mEncodeTrackId
=
Preferences
:
:
GetBool
(
"
media
.
peerconnection
.
sdp
.
encode_track_id
"
true
)
;
mIceUfrag
=
GetRandomHex
(
1
)
;
mIcePwd
=
GetRandomHex
(
4
)
;
return
NS_OK
;
}
static
void
GetIceCredentials
(
const
Sdp
&
aSdp
std
:
:
set
<
std
:
:
pair
<
std
:
:
string
std
:
:
string
>
>
*
aCredentials
)
{
for
(
size_t
i
=
0
;
i
<
aSdp
.
GetMediaSectionCount
(
)
;
+
+
i
)
{
const
SdpAttributeList
&
attrs
=
aSdp
.
GetMediaSection
(
i
)
.
GetAttributeList
(
)
;
if
(
attrs
.
HasAttribute
(
SdpAttribute
:
:
kIceUfragAttribute
)
&
&
attrs
.
HasAttribute
(
SdpAttribute
:
:
kIcePwdAttribute
)
)
{
aCredentials
-
>
insert
(
std
:
:
make_pair
(
attrs
.
GetIceUfrag
(
)
attrs
.
GetIcePwd
(
)
)
)
;
}
}
}
std
:
:
set
<
std
:
:
pair
<
std
:
:
string
std
:
:
string
>
>
JsepSessionImpl
:
:
GetLocalIceCredentials
(
)
const
{
std
:
:
set
<
std
:
:
pair
<
std
:
:
string
std
:
:
string
>
>
result
;
if
(
mCurrentLocalDescription
)
{
GetIceCredentials
(
*
mCurrentLocalDescription
&
result
)
;
}
if
(
mPendingLocalDescription
)
{
GetIceCredentials
(
*
mPendingLocalDescription
&
result
)
;
}
return
result
;
}
nsresult
JsepSessionImpl
:
:
AddTransceiver
(
RefPtr
<
JsepTransceiver
>
transceiver
)
{
mLastError
.
clear
(
)
;
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
Adding
transceiver
"
<
<
transceiver
-
>
GetUuid
(
)
)
;
if
(
transceiver
-
>
GetMediaType
(
)
!
=
SdpMediaSection
:
:
kApplication
)
{
transceiver
-
>
mSendTrack
.
EnsureSsrcs
(
mSsrcGenerator
1U
)
;
transceiver
-
>
mSendTrack
.
SetCNAME
(
mCNAME
)
;
if
(
mEncodeTrackId
)
{
std
:
:
string
trackId
;
if
(
!
mUuidGen
-
>
Generate
(
&
trackId
)
)
{
JSEP_SET_ERROR
(
"
Failed
to
generate
UUID
for
JsepTrack
"
)
;
return
NS_ERROR_FAILURE
;
}
transceiver
-
>
mSendTrack
.
SetTrackId
(
trackId
)
;
}
}
else
{
transceiver
-
>
mJsDirection
=
SdpDirectionAttribute
:
:
kSendrecv
;
#
ifdef
DEBUG
for
(
const
auto
&
transceiver
:
mTransceivers
)
{
MOZ_ASSERT
(
transceiver
-
>
GetMediaType
(
)
!
=
SdpMediaSection
:
:
kApplication
)
;
}
#
endif
}
transceiver
-
>
mSendTrack
.
PopulateCodecs
(
mSupportedCodecs
)
;
transceiver
-
>
mRecvTrack
.
PopulateCodecs
(
mSupportedCodecs
)
;
mTransceivers
.
push_back
(
transceiver
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
SetBundlePolicy
(
JsepBundlePolicy
policy
)
{
mLastError
.
clear
(
)
;
if
(
mBundlePolicy
=
=
policy
)
{
return
NS_OK
;
}
if
(
mCurrentLocalDescription
)
{
JSEP_SET_ERROR
(
"
Changing
the
bundle
policy
is
only
supported
before
the
"
"
first
SetLocalDescription
.
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
mBundlePolicy
=
policy
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
AddDtlsFingerprint
(
const
std
:
:
string
&
algorithm
const
std
:
:
vector
<
uint8_t
>
&
value
)
{
mLastError
.
clear
(
)
;
JsepDtlsFingerprint
fp
;
fp
.
mAlgorithm
=
algorithm
;
fp
.
mValue
=
value
;
mDtlsFingerprints
.
push_back
(
fp
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
AddRtpExtension
(
JsepMediaType
mediaType
const
std
:
:
string
&
extensionName
SdpDirectionAttribute
:
:
Direction
direction
)
{
mLastError
.
clear
(
)
;
for
(
auto
&
ext
:
mRtpExtensions
)
{
if
(
ext
.
mExtmap
.
direction
=
=
direction
&
&
ext
.
mExtmap
.
extensionname
=
=
extensionName
)
{
if
(
ext
.
mMediaType
!
=
mediaType
)
{
ext
.
mMediaType
=
JsepMediaType
:
:
kAudioVideo
;
}
return
NS_OK
;
}
}
uint16_t
freeEntry
=
GetNeverUsedExtmapEntry
(
)
;
if
(
freeEntry
=
=
0
)
{
return
NS_ERROR_FAILURE
;
}
JsepExtmapMediaType
extMediaType
=
{
mediaType
{
freeEntry
direction
direction
!
=
SdpDirectionAttribute
:
:
kSendrecv
extensionName
"
"
}
}
;
mRtpExtensions
.
push_back
(
extMediaType
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
AddAudioRtpExtension
(
const
std
:
:
string
&
extensionName
SdpDirectionAttribute
:
:
Direction
direction
)
{
return
AddRtpExtension
(
JsepMediaType
:
:
kAudio
extensionName
direction
)
;
}
nsresult
JsepSessionImpl
:
:
AddVideoRtpExtension
(
const
std
:
:
string
&
extensionName
SdpDirectionAttribute
:
:
Direction
direction
)
{
return
AddRtpExtension
(
JsepMediaType
:
:
kVideo
extensionName
direction
)
;
}
nsresult
JsepSessionImpl
:
:
AddAudioVideoRtpExtension
(
const
std
:
:
string
&
extensionName
SdpDirectionAttribute
:
:
Direction
direction
)
{
return
AddRtpExtension
(
JsepMediaType
:
:
kAudioVideo
extensionName
direction
)
;
}
nsresult
JsepSessionImpl
:
:
CreateOfferMsection
(
const
JsepOfferOptions
&
options
JsepTransceiver
&
transceiver
Sdp
*
local
)
{
SdpMediaSection
:
:
Protocol
protocol
(
SdpHelper
:
:
GetProtocolForMediaType
(
transceiver
.
GetMediaType
(
)
)
)
;
const
Sdp
*
answer
(
GetAnswer
(
)
)
;
const
SdpMediaSection
*
lastAnswerMsection
=
nullptr
;
if
(
answer
&
&
(
local
-
>
GetMediaSectionCount
(
)
<
answer
-
>
GetMediaSectionCount
(
)
)
)
{
lastAnswerMsection
=
&
answer
-
>
GetMediaSection
(
local
-
>
GetMediaSectionCount
(
)
)
;
protocol
=
lastAnswerMsection
-
>
GetProtocol
(
)
;
}
SdpMediaSection
*
msection
=
&
local
-
>
AddMediaSection
(
transceiver
.
GetMediaType
(
)
transceiver
.
mJsDirection
0
protocol
sdp
:
:
kIPv4
"
0
.
0
.
0
.
0
"
)
;
if
(
lastAnswerMsection
)
{
MOZ_ASSERT
(
lastAnswerMsection
-
>
GetMediaType
(
)
=
=
transceiver
.
GetMediaType
(
)
)
;
nsresult
rv
=
mSdpHelper
.
CopyStickyParams
(
*
lastAnswerMsection
msection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
transceiver
.
IsStopped
(
)
)
{
SdpHelper
:
:
DisableMsection
(
local
msection
)
;
return
NS_OK
;
}
msection
-
>
SetPort
(
9
)
;
if
(
mSdpHelper
.
HasRtcp
(
msection
-
>
GetProtocol
(
)
)
)
{
msection
-
>
GetAttributeList
(
)
.
SetAttribute
(
new
SdpFlagAttribute
(
SdpAttribute
:
:
kRtcpMuxAttribute
)
)
;
if
(
msection
-
>
GetMediaType
(
)
=
=
SdpMediaSection
:
:
MediaType
:
:
kVideo
&
&
Preferences
:
:
GetBool
(
"
media
.
navigator
.
video
.
offer_rtcp_rsize
"
false
)
)
{
msection
-
>
GetAttributeList
(
)
.
SetAttribute
(
new
SdpFlagAttribute
(
SdpAttribute
:
:
kRtcpRsizeAttribute
)
)
;
}
}
nsresult
rv
=
AddTransportAttributes
(
msection
SdpSetupAttribute
:
:
kActpass
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
transceiver
.
mSendTrack
.
AddToOffer
(
mSsrcGenerator
msection
)
;
transceiver
.
mRecvTrack
.
AddToOffer
(
mSsrcGenerator
msection
)
;
AddExtmap
(
msection
)
;
std
:
:
string
mid
;
if
(
transceiver
.
IsAssociated
(
)
)
{
mid
=
transceiver
.
GetMid
(
)
;
}
else
{
mid
=
GetNewMid
(
)
;
}
msection
-
>
GetAttributeList
(
)
.
SetAttribute
(
new
SdpStringAttribute
(
SdpAttribute
:
:
kMidAttribute
mid
)
)
;
return
NS_OK
;
}
void
JsepSessionImpl
:
:
SetupBundle
(
Sdp
*
sdp
)
const
{
std
:
:
vector
<
std
:
:
string
>
mids
;
std
:
:
set
<
SdpMediaSection
:
:
MediaType
>
observedTypes
;
for
(
size_t
i
=
0
;
i
<
sdp
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
auto
&
attrs
=
sdp
-
>
GetMediaSection
(
i
)
.
GetAttributeList
(
)
;
if
(
(
sdp
-
>
GetMediaSection
(
i
)
.
GetPort
(
)
!
=
0
)
&
&
attrs
.
HasAttribute
(
SdpAttribute
:
:
kMidAttribute
)
)
{
bool
useBundleOnly
=
false
;
switch
(
mBundlePolicy
)
{
case
kBundleMaxCompat
:
break
;
case
kBundleBalanced
:
if
(
observedTypes
.
count
(
sdp
-
>
GetMediaSection
(
i
)
.
GetMediaType
(
)
)
)
{
useBundleOnly
=
true
;
}
observedTypes
.
insert
(
sdp
-
>
GetMediaSection
(
i
)
.
GetMediaType
(
)
)
;
break
;
case
kBundleMaxBundle
:
useBundleOnly
=
!
mids
.
empty
(
)
;
break
;
}
if
(
useBundleOnly
)
{
attrs
.
SetAttribute
(
new
SdpFlagAttribute
(
SdpAttribute
:
:
kBundleOnlyAttribute
)
)
;
sdp
-
>
GetMediaSection
(
i
)
.
SetPort
(
0
)
;
}
mids
.
push_back
(
attrs
.
GetMid
(
)
)
;
}
}
if
(
!
mids
.
empty
(
)
)
{
UniquePtr
<
SdpGroupAttributeList
>
groupAttr
(
new
SdpGroupAttributeList
)
;
groupAttr
-
>
PushEntry
(
SdpGroupAttributeList
:
:
kBundle
mids
)
;
sdp
-
>
GetAttributeList
(
)
.
SetAttribute
(
groupAttr
.
release
(
)
)
;
}
}
JsepSession
:
:
Result
JsepSessionImpl
:
:
CreateOffer
(
const
JsepOfferOptions
&
options
std
:
:
string
*
offer
)
{
mLastError
.
clear
(
)
;
if
(
mState
!
=
kJsepStateStable
&
&
mState
!
=
kJsepStateHaveLocalOffer
)
{
JSEP_SET_ERROR
(
"
Cannot
create
offer
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
dom
:
:
PCError
:
:
InvalidStateError
;
}
SetIceRestarting
(
options
.
mIceRestart
.
isSome
(
)
&
&
*
(
options
.
mIceRestart
)
)
;
UniquePtr
<
Sdp
>
sdp
;
nsresult
rv
=
CreateGenericSDP
(
&
sdp
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
for
(
size_t
level
=
0
;
JsepTransceiver
*
transceiver
=
GetTransceiverForLocal
(
level
)
;
+
+
level
)
{
rv
=
CreateOfferMsection
(
options
*
transceiver
sdp
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
}
SetupBundle
(
sdp
.
get
(
)
)
;
if
(
mCurrentLocalDescription
)
{
rv
=
CopyPreviousTransportParams
(
*
GetAnswer
(
)
*
mCurrentLocalDescription
*
sdp
sdp
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
}
*
offer
=
sdp
-
>
ToString
(
)
;
mGeneratedOffer
=
std
:
:
move
(
sdp
)
;
+
+
mSessionVersion
;
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
CreateOffer
\
nSDP
=
\
n
"
<
<
*
offer
)
;
return
Result
(
)
;
}
std
:
:
string
JsepSessionImpl
:
:
GetLocalDescription
(
JsepDescriptionPendingOrCurrent
type
)
const
{
std
:
:
ostringstream
os
;
mozilla
:
:
Sdp
*
sdp
=
GetParsedLocalDescription
(
type
)
;
if
(
sdp
)
{
sdp
-
>
Serialize
(
os
)
;
}
return
os
.
str
(
)
;
}
std
:
:
string
JsepSessionImpl
:
:
GetRemoteDescription
(
JsepDescriptionPendingOrCurrent
type
)
const
{
std
:
:
ostringstream
os
;
mozilla
:
:
Sdp
*
sdp
=
GetParsedRemoteDescription
(
type
)
;
if
(
sdp
)
{
sdp
-
>
Serialize
(
os
)
;
}
return
os
.
str
(
)
;
}
void
JsepSessionImpl
:
:
AddExtmap
(
SdpMediaSection
*
msection
)
{
auto
extensions
=
GetRtpExtensions
(
*
msection
)
;
if
(
!
extensions
.
empty
(
)
)
{
SdpExtmapAttributeList
*
extmap
=
new
SdpExtmapAttributeList
;
extmap
-
>
mExtmaps
=
extensions
;
msection
-
>
GetAttributeList
(
)
.
SetAttribute
(
extmap
)
;
}
}
std
:
:
vector
<
SdpExtmapAttributeList
:
:
Extmap
>
JsepSessionImpl
:
:
GetRtpExtensions
(
const
SdpMediaSection
&
msection
)
{
std
:
:
vector
<
SdpExtmapAttributeList
:
:
Extmap
>
result
;
JsepMediaType
mediaType
=
JsepMediaType
:
:
kNone
;
switch
(
msection
.
GetMediaType
(
)
)
{
case
SdpMediaSection
:
:
kAudio
:
mediaType
=
JsepMediaType
:
:
kAudio
;
break
;
case
SdpMediaSection
:
:
kVideo
:
mediaType
=
JsepMediaType
:
:
kVideo
;
if
(
msection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kRidAttribute
)
)
{
AddVideoRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kRidUri
SdpDirectionAttribute
:
:
kSendonly
)
;
if
(
mRtxIsAllowed
&
&
Preferences
:
:
GetBool
(
"
media
.
peerconnection
.
video
.
use_rtx
"
false
)
)
{
AddVideoRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kRepairedRidUri
SdpDirectionAttribute
:
:
kSendonly
)
;
}
}
break
;
default
:
;
}
if
(
mediaType
!
=
JsepMediaType
:
:
kNone
)
{
for
(
auto
ext
=
mRtpExtensions
.
begin
(
)
;
ext
!
=
mRtpExtensions
.
end
(
)
;
+
+
ext
)
{
if
(
ext
-
>
mMediaType
=
=
mediaType
|
|
ext
-
>
mMediaType
=
=
JsepMediaType
:
:
kAudioVideo
)
{
result
.
push_back
(
ext
-
>
mExtmap
)
;
}
}
}
return
result
;
}
std
:
:
string
JsepSessionImpl
:
:
GetNewMid
(
)
{
std
:
:
string
mid
;
do
{
std
:
:
ostringstream
osMid
;
osMid
<
<
mMidCounter
+
+
;
mid
=
osMid
.
str
(
)
;
}
while
(
mUsedMids
.
count
(
mid
)
)
;
mUsedMids
.
insert
(
mid
)
;
return
mid
;
}
void
JsepSessionImpl
:
:
AddCommonExtmaps
(
const
SdpMediaSection
&
remoteMsection
SdpMediaSection
*
msection
)
{
auto
negotiatedRtpExtensions
=
GetRtpExtensions
(
*
msection
)
;
mSdpHelper
.
NegotiateAndAddExtmaps
(
remoteMsection
negotiatedRtpExtensions
msection
)
;
for
(
const
auto
&
negotiatedExtension
:
negotiatedRtpExtensions
)
{
if
(
negotiatedExtension
.
entry
=
=
0
)
{
MOZ_ASSERT
(
false
"
This
should
have
been
caught
sooner
"
)
;
continue
;
}
for
(
auto
&
originalExtension
:
mRtpExtensions
)
{
if
(
negotiatedExtension
.
extensionname
=
=
originalExtension
.
mExtmap
.
extensionname
)
{
originalExtension
.
mExtmap
.
entry
=
negotiatedExtension
.
entry
;
mExtmapEntriesEverUsed
.
insert
(
negotiatedExtension
.
entry
)
;
}
else
if
(
originalExtension
.
mExtmap
.
entry
=
=
negotiatedExtension
.
entry
)
{
originalExtension
.
mExtmap
.
entry
=
GetNeverUsedExtmapEntry
(
)
;
}
}
}
}
uint16_t
JsepSessionImpl
:
:
GetNeverUsedExtmapEntry
(
)
{
uint16_t
result
=
1
;
for
(
const
auto
used
:
mExtmapEntriesEverUsed
)
{
if
(
result
!
=
used
)
{
MOZ_ASSERT
(
result
<
used
)
;
break
;
}
if
(
used
=
=
4095
)
{
JSEP_SET_ERROR
(
"
Too
many
rtp
extensions
have
been
added
.
"
"
That
'
s
4095
.
Who
_does_
that
?
"
)
;
return
0
;
}
result
=
used
+
1
;
}
mExtmapEntriesEverUsed
.
insert
(
result
)
;
return
result
;
}
JsepSession
:
:
Result
JsepSessionImpl
:
:
CreateAnswer
(
const
JsepAnswerOptions
&
options
std
:
:
string
*
answer
)
{
mLastError
.
clear
(
)
;
if
(
mState
!
=
kJsepStateHaveRemoteOffer
)
{
JSEP_SET_ERROR
(
"
Cannot
create
answer
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
dom
:
:
PCError
:
:
InvalidStateError
;
}
UniquePtr
<
Sdp
>
sdp
;
nsresult
rv
=
CreateGenericSDP
(
&
sdp
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
const
Sdp
&
offer
=
*
mPendingRemoteDescription
;
UniquePtr
<
SdpGroupAttributeList
>
groupAttr
(
new
SdpGroupAttributeList
)
;
mSdpHelper
.
GetBundleGroups
(
offer
&
groupAttr
-
>
mGroups
)
;
sdp
-
>
GetAttributeList
(
)
.
SetAttribute
(
groupAttr
.
release
(
)
)
;
for
(
size_t
i
=
0
;
i
<
offer
.
GetMediaSectionCount
(
)
;
+
+
i
)
{
JsepTransceiver
*
transceiver
(
GetTransceiverForLevel
(
i
)
)
;
if
(
!
transceiver
)
{
JSEP_SET_ERROR
(
"
No
transceiver
for
level
"
<
<
i
)
;
MOZ_ASSERT
(
false
)
;
return
dom
:
:
PCError
:
:
OperationError
;
}
rv
=
CreateAnswerMsection
(
options
*
transceiver
offer
.
GetMediaSection
(
i
)
sdp
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
}
groupAttr
.
reset
(
new
SdpGroupAttributeList
)
;
std
:
:
vector
<
SdpGroupAttributeList
:
:
Group
>
bundleGroups
;
mSdpHelper
.
GetBundleGroups
(
*
sdp
&
bundleGroups
)
;
for
(
auto
&
group
:
bundleGroups
)
{
for
(
auto
&
mid
:
group
.
tags
)
{
const
SdpMediaSection
*
msection
=
mSdpHelper
.
FindMsectionByMid
(
offer
mid
)
;
if
(
msection
&
&
!
msection
-
>
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kBundleOnlyAttribute
)
)
{
std
:
:
swap
(
group
.
tags
[
0
]
mid
)
;
groupAttr
-
>
mGroups
.
push_back
(
group
)
;
break
;
}
}
}
sdp
-
>
GetAttributeList
(
)
.
SetAttribute
(
groupAttr
.
release
(
)
)
;
if
(
mCurrentLocalDescription
)
{
rv
=
CopyPreviousTransportParams
(
*
GetAnswer
(
)
*
mCurrentRemoteDescription
offer
sdp
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
}
*
answer
=
sdp
-
>
ToString
(
)
;
mGeneratedAnswer
=
std
:
:
move
(
sdp
)
;
+
+
mSessionVersion
;
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
CreateAnswer
\
nSDP
=
\
n
"
<
<
*
answer
)
;
return
Result
(
)
;
}
nsresult
JsepSessionImpl
:
:
CreateAnswerMsection
(
const
JsepAnswerOptions
&
options
JsepTransceiver
&
transceiver
const
SdpMediaSection
&
remoteMsection
Sdp
*
sdp
)
{
MOZ_ASSERT
(
transceiver
.
GetMediaType
(
)
=
=
remoteMsection
.
GetMediaType
(
)
)
;
SdpDirectionAttribute
:
:
Direction
direction
=
reverse
(
remoteMsection
.
GetDirection
(
)
)
&
transceiver
.
mJsDirection
;
SdpMediaSection
&
msection
=
sdp
-
>
AddMediaSection
(
remoteMsection
.
GetMediaType
(
)
direction
9
remoteMsection
.
GetProtocol
(
)
sdp
:
:
kIPv4
"
0
.
0
.
0
.
0
"
)
;
nsresult
rv
=
mSdpHelper
.
CopyStickyParams
(
remoteMsection
&
msection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mSdpHelper
.
MsectionIsDisabled
(
remoteMsection
)
|
|
transceiver
.
IsStopped
(
)
)
{
SdpHelper
:
:
DisableMsection
(
sdp
&
msection
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
transceiver
.
IsAssociated
(
)
)
;
if
(
msection
.
GetAttributeList
(
)
.
GetMid
(
)
.
empty
(
)
)
{
msection
.
GetAttributeList
(
)
.
SetAttribute
(
new
SdpStringAttribute
(
SdpAttribute
:
:
kMidAttribute
transceiver
.
GetMid
(
)
)
)
;
}
MOZ_ASSERT
(
transceiver
.
GetMid
(
)
=
=
msection
.
GetAttributeList
(
)
.
GetMid
(
)
)
;
SdpSetupAttribute
:
:
Role
role
;
if
(
transceiver
.
mTransport
.
mDtls
&
&
!
IsIceRestarting
(
)
)
{
role
=
(
transceiver
.
mTransport
.
mDtls
-
>
mRole
=
=
JsepDtlsTransport
:
:
kJsepDtlsClient
)
?
SdpSetupAttribute
:
:
kActive
:
SdpSetupAttribute
:
:
kPassive
;
}
else
{
rv
=
DetermineAnswererSetupRole
(
remoteMsection
&
role
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
AddTransportAttributes
(
&
msection
role
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
transceiver
.
mSendTrack
.
AddToAnswer
(
remoteMsection
mSsrcGenerator
&
msection
)
;
transceiver
.
mRecvTrack
.
AddToAnswer
(
remoteMsection
mSsrcGenerator
&
msection
)
;
AddCommonExtmaps
(
remoteMsection
&
msection
)
;
if
(
msection
.
GetFormats
(
)
.
empty
(
)
)
{
SdpHelper
:
:
DisableMsection
(
sdp
&
msection
)
;
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
DetermineAnswererSetupRole
(
const
SdpMediaSection
&
remoteMsection
SdpSetupAttribute
:
:
Role
*
rolep
)
{
SdpSetupAttribute
:
:
Role
role
=
SdpSetupAttribute
:
:
kActive
;
if
(
remoteMsection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kSetupAttribute
)
)
{
switch
(
remoteMsection
.
GetAttributeList
(
)
.
GetSetup
(
)
.
mRole
)
{
case
SdpSetupAttribute
:
:
kActive
:
role
=
SdpSetupAttribute
:
:
kPassive
;
break
;
case
SdpSetupAttribute
:
:
kPassive
:
case
SdpSetupAttribute
:
:
kActpass
:
role
=
SdpSetupAttribute
:
:
kActive
;
break
;
case
SdpSetupAttribute
:
:
kHoldconn
:
MOZ_ASSERT
(
false
)
;
JSEP_SET_ERROR
(
"
The
other
side
used
an
illegal
setup
attribute
"
"
(
\
"
holdconn
\
"
)
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
*
rolep
=
role
;
return
NS_OK
;
}
JsepSession
:
:
Result
JsepSessionImpl
:
:
SetLocalDescription
(
JsepSdpType
type
const
std
:
:
string
&
constSdp
)
{
mLastError
.
clear
(
)
;
std
:
:
string
sdp
=
constSdp
;
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
SetLocalDescription
type
=
"
<
<
type
<
<
"
\
nSDP
=
\
n
"
<
<
sdp
)
;
switch
(
type
)
{
case
kJsepSdpOffer
:
if
(
!
mGeneratedOffer
)
{
JSEP_SET_ERROR
(
"
Cannot
set
local
offer
when
createOffer
has
not
been
called
.
"
)
;
return
dom
:
:
PCError
:
:
InvalidModificationError
;
}
if
(
sdp
.
empty
(
)
)
{
sdp
=
mGeneratedOffer
-
>
ToString
(
)
;
}
if
(
mState
=
=
kJsepStateHaveLocalOffer
)
{
SetLocalDescription
(
kJsepSdpRollback
"
"
)
;
MOZ_ASSERT
(
mState
=
=
kJsepStateStable
)
;
}
break
;
case
kJsepSdpAnswer
:
case
kJsepSdpPranswer
:
if
(
!
mGeneratedAnswer
)
{
JSEP_SET_ERROR
(
"
Cannot
set
local
answer
when
createAnswer
has
not
been
called
.
"
)
;
return
dom
:
:
PCError
:
:
InvalidModificationError
;
}
if
(
sdp
.
empty
(
)
)
{
sdp
=
mGeneratedAnswer
-
>
ToString
(
)
;
}
break
;
case
kJsepSdpRollback
:
if
(
mState
!
=
kJsepStateHaveLocalOffer
)
{
JSEP_SET_ERROR
(
"
Cannot
rollback
local
description
in
"
<
<
GetStateStr
(
mState
)
)
;
return
dom
:
:
PCError
:
:
InvalidStateError
;
}
mPendingLocalDescription
.
reset
(
)
;
SetState
(
kJsepStateStable
)
;
RollbackLocalOffer
(
)
;
return
Result
(
)
;
}
switch
(
mState
)
{
case
kJsepStateStable
:
if
(
type
!
=
kJsepSdpOffer
)
{
JSEP_SET_ERROR
(
"
Cannot
set
local
answer
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
dom
:
:
PCError
:
:
InvalidStateError
;
}
break
;
case
kJsepStateHaveRemoteOffer
:
if
(
type
!
=
kJsepSdpAnswer
&
&
type
!
=
kJsepSdpPranswer
)
{
JSEP_SET_ERROR
(
"
Cannot
set
local
offer
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
dom
:
:
PCError
:
:
InvalidStateError
;
}
break
;
default
:
JSEP_SET_ERROR
(
"
Cannot
set
local
offer
or
answer
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
dom
:
:
PCError
:
:
InvalidStateError
;
}
UniquePtr
<
Sdp
>
parsed
;
nsresult
rv
=
ParseSdp
(
sdp
&
parsed
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
rv
=
ValidateLocalDescription
(
*
parsed
type
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
InvalidModificationError
)
;
switch
(
type
)
{
case
kJsepSdpOffer
:
rv
=
ValidateOffer
(
*
parsed
)
;
break
;
case
kJsepSdpAnswer
:
case
kJsepSdpPranswer
:
rv
=
ValidateAnswer
(
*
mPendingRemoteDescription
*
parsed
)
;
break
;
case
kJsepSdpRollback
:
MOZ_CRASH
(
)
;
}
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
InvalidAccessError
)
;
if
(
type
=
=
kJsepSdpOffer
)
{
mOldTransceivers
.
clear
(
)
;
for
(
const
auto
&
transceiver
:
mTransceivers
)
{
mOldTransceivers
.
push_back
(
new
JsepTransceiver
(
*
transceiver
)
)
;
}
}
SdpHelper
:
:
BundledMids
bundledMids
;
rv
=
mSdpHelper
.
GetBundledMids
(
*
parsed
&
bundledMids
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
SdpHelper
:
:
BundledMids
remoteBundledMids
;
if
(
type
!
=
kJsepSdpOffer
)
{
rv
=
mSdpHelper
.
GetBundledMids
(
*
mPendingRemoteDescription
&
remoteBundledMids
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
}
for
(
size_t
i
=
0
;
i
<
parsed
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
JsepTransceiver
*
transceiver
(
GetTransceiverForLevel
(
i
)
)
;
if
(
!
transceiver
)
{
MOZ_ASSERT
(
false
)
;
JSEP_SET_ERROR
(
"
No
transceiver
for
level
"
<
<
i
)
;
return
dom
:
:
PCError
:
:
OperationError
;
}
const
auto
&
msection
=
parsed
-
>
GetMediaSection
(
i
)
;
transceiver
-
>
Associate
(
msection
.
GetAttributeList
(
)
.
GetMid
(
)
)
;
if
(
mSdpHelper
.
MsectionIsDisabled
(
msection
)
)
{
transceiver
-
>
mTransport
.
Close
(
)
;
continue
;
}
bool
hasOwnTransport
=
mSdpHelper
.
OwnsTransport
(
msection
bundledMids
(
type
=
=
kJsepSdpOffer
)
?
sdp
:
:
kOffer
:
sdp
:
:
kAnswer
)
;
if
(
type
!
=
kJsepSdpOffer
)
{
const
auto
&
remoteMsection
=
mPendingRemoteDescription
-
>
GetMediaSection
(
i
)
;
hasOwnTransport
&
=
mSdpHelper
.
OwnsTransport
(
remoteMsection
remoteBundledMids
sdp
:
:
kOffer
)
;
}
if
(
hasOwnTransport
)
{
EnsureHasOwnTransport
(
parsed
-
>
GetMediaSection
(
i
)
transceiver
)
;
}
if
(
type
=
=
kJsepSdpOffer
)
{
if
(
!
hasOwnTransport
)
{
auto
it
=
bundledMids
.
find
(
transceiver
-
>
GetMid
(
)
)
;
if
(
it
!
=
bundledMids
.
end
(
)
)
{
transceiver
-
>
SetBundleLevel
(
it
-
>
second
-
>
GetLevel
(
)
)
;
}
}
}
else
{
auto
it
=
remoteBundledMids
.
find
(
transceiver
-
>
GetMid
(
)
)
;
if
(
it
!
=
remoteBundledMids
.
end
(
)
)
{
transceiver
-
>
SetBundleLevel
(
it
-
>
second
-
>
GetLevel
(
)
)
;
}
}
}
CopyBundleTransports
(
)
;
switch
(
type
)
{
case
kJsepSdpOffer
:
rv
=
SetLocalDescriptionOffer
(
std
:
:
move
(
parsed
)
)
;
break
;
case
kJsepSdpAnswer
:
case
kJsepSdpPranswer
:
rv
=
SetLocalDescriptionAnswer
(
type
std
:
:
move
(
parsed
)
)
;
break
;
case
kJsepSdpRollback
:
MOZ_CRASH
(
)
;
}
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
return
Result
(
)
;
}
nsresult
JsepSessionImpl
:
:
SetLocalDescriptionOffer
(
UniquePtr
<
Sdp
>
offer
)
{
MOZ_ASSERT
(
mState
=
=
kJsepStateStable
)
;
mPendingLocalDescription
=
std
:
:
move
(
offer
)
;
mIsPendingOfferer
=
Some
(
true
)
;
SetState
(
kJsepStateHaveLocalOffer
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
SetLocalDescriptionAnswer
(
JsepSdpType
type
UniquePtr
<
Sdp
>
answer
)
{
MOZ_ASSERT
(
mState
=
=
kJsepStateHaveRemoteOffer
)
;
mPendingLocalDescription
=
std
:
:
move
(
answer
)
;
nsresult
rv
=
HandleNegotiatedSession
(
mPendingLocalDescription
mPendingRemoteDescription
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCurrentRemoteDescription
=
std
:
:
move
(
mPendingRemoteDescription
)
;
mCurrentLocalDescription
=
std
:
:
move
(
mPendingLocalDescription
)
;
MOZ_ASSERT
(
mIsPendingOfferer
.
isSome
(
)
&
&
!
*
mIsPendingOfferer
)
;
mIsPendingOfferer
.
reset
(
)
;
mIsCurrentOfferer
=
Some
(
false
)
;
SetState
(
kJsepStateStable
)
;
return
NS_OK
;
}
JsepSession
:
:
Result
JsepSessionImpl
:
:
SetRemoteDescription
(
JsepSdpType
type
const
std
:
:
string
&
sdp
)
{
mLastError
.
clear
(
)
;
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
SetRemoteDescription
type
=
"
<
<
type
<
<
"
\
nSDP
=
\
n
"
<
<
sdp
)
;
if
(
mState
=
=
kJsepStateHaveRemoteOffer
&
&
type
=
=
kJsepSdpOffer
)
{
SetRemoteDescription
(
kJsepSdpRollback
"
"
)
;
MOZ_ASSERT
(
mState
=
=
kJsepStateStable
)
;
}
if
(
type
=
=
kJsepSdpRollback
)
{
if
(
mState
!
=
kJsepStateHaveRemoteOffer
)
{
JSEP_SET_ERROR
(
"
Cannot
rollback
remote
description
in
"
<
<
GetStateStr
(
mState
)
)
;
return
dom
:
:
PCError
:
:
InvalidStateError
;
}
mPendingRemoteDescription
.
reset
(
)
;
SetState
(
kJsepStateStable
)
;
RollbackRemoteOffer
(
)
;
return
Result
(
)
;
}
switch
(
mState
)
{
case
kJsepStateStable
:
if
(
type
!
=
kJsepSdpOffer
)
{
JSEP_SET_ERROR
(
"
Cannot
set
remote
answer
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
dom
:
:
PCError
:
:
InvalidStateError
;
}
break
;
case
kJsepStateHaveLocalOffer
:
case
kJsepStateHaveRemotePranswer
:
if
(
type
!
=
kJsepSdpAnswer
&
&
type
!
=
kJsepSdpPranswer
)
{
JSEP_SET_ERROR
(
"
Cannot
set
remote
offer
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
dom
:
:
PCError
:
:
InvalidStateError
;
}
break
;
default
:
JSEP_SET_ERROR
(
"
Cannot
set
remote
offer
or
answer
in
current
state
"
<
<
GetStateStr
(
mState
)
)
;
return
dom
:
:
PCError
:
:
InvalidStateError
;
}
UniquePtr
<
Sdp
>
parsed
;
nsresult
rv
=
ParseSdp
(
sdp
&
parsed
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
rv
=
ValidateRemoteDescription
(
*
parsed
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
InvalidAccessError
)
;
switch
(
type
)
{
case
kJsepSdpOffer
:
rv
=
ValidateOffer
(
*
parsed
)
;
break
;
case
kJsepSdpAnswer
:
case
kJsepSdpPranswer
:
rv
=
ValidateAnswer
(
*
mPendingLocalDescription
*
parsed
)
;
break
;
case
kJsepSdpRollback
:
MOZ_CRASH
(
)
;
}
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
InvalidAccessError
)
;
bool
iceLite
=
parsed
-
>
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kIceLiteAttribute
)
;
bool
iceRestarting
=
false
;
if
(
mCurrentRemoteDescription
.
get
(
)
)
{
for
(
size_t
i
=
0
;
!
iceRestarting
&
&
i
<
mCurrentRemoteDescription
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
const
SdpMediaSection
&
newMsection
=
parsed
-
>
GetMediaSection
(
i
)
;
const
SdpMediaSection
&
oldMsection
=
mCurrentRemoteDescription
-
>
GetMediaSection
(
i
)
;
if
(
mSdpHelper
.
MsectionIsDisabled
(
newMsection
)
|
|
mSdpHelper
.
MsectionIsDisabled
(
oldMsection
)
)
{
continue
;
}
iceRestarting
=
mSdpHelper
.
IceCredentialsDiffer
(
newMsection
oldMsection
)
;
}
}
std
:
:
vector
<
std
:
:
string
>
iceOptions
;
if
(
parsed
-
>
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kIceOptionsAttribute
)
)
{
iceOptions
=
parsed
-
>
GetAttributeList
(
)
.
GetIceOptions
(
)
.
mValues
;
}
if
(
type
=
=
kJsepSdpOffer
)
{
mOldTransceivers
.
clear
(
)
;
for
(
const
auto
&
transceiver
:
mTransceivers
)
{
mOldTransceivers
.
push_back
(
new
JsepTransceiver
(
*
transceiver
)
)
;
if
(
!
transceiver
-
>
IsNegotiated
(
)
)
{
transceiver
-
>
ClearLevel
(
)
;
}
}
}
rv
=
UpdateTransceiversFromRemoteDescription
(
*
parsed
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
for
(
size_t
i
=
0
;
i
<
parsed
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
MOZ_ASSERT
(
GetTransceiverForLevel
(
i
)
)
;
}
switch
(
type
)
{
case
kJsepSdpOffer
:
rv
=
SetRemoteDescriptionOffer
(
std
:
:
move
(
parsed
)
)
;
break
;
case
kJsepSdpAnswer
:
case
kJsepSdpPranswer
:
rv
=
SetRemoteDescriptionAnswer
(
type
std
:
:
move
(
parsed
)
)
;
break
;
case
kJsepSdpRollback
:
MOZ_CRASH
(
)
;
}
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
mRemoteIsIceLite
=
iceLite
;
mIceOptions
=
iceOptions
;
SetIceRestarting
(
iceRestarting
)
;
return
Result
(
)
;
}
nsresult
JsepSessionImpl
:
:
HandleNegotiatedSession
(
const
UniquePtr
<
Sdp
>
&
local
const
UniquePtr
<
Sdp
>
&
remote
)
{
mOldIceUfrag
.
clear
(
)
;
mOldIcePwd
.
clear
(
)
;
bool
remoteIceLite
=
remote
-
>
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kIceLiteAttribute
)
;
mIceControlling
=
remoteIceLite
|
|
*
mIsPendingOfferer
;
const
Sdp
&
answer
=
*
mIsPendingOfferer
?
*
remote
:
*
local
;
SdpHelper
:
:
BundledMids
bundledMids
;
nsresult
rv
=
mSdpHelper
.
GetBundledMids
(
answer
&
bundledMids
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
auto
&
[
mid
transportOwner
]
:
bundledMids
)
{
JsepTransceiver
*
bundledTransceiver
=
GetTransceiverForMid
(
mid
)
;
if
(
!
bundledTransceiver
)
{
JSEP_SET_ERROR
(
"
No
transceiver
for
bundled
mid
"
<
<
mid
)
;
return
NS_ERROR_INVALID_ARG
;
}
bundledTransceiver
-
>
SetBundleLevel
(
transportOwner
-
>
GetLevel
(
)
)
;
}
for
(
size_t
i
=
0
;
i
<
local
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
JsepTransceiver
*
transceiver
(
GetTransceiverForLevel
(
i
)
)
;
if
(
!
transceiver
)
{
MOZ_ASSERT
(
false
)
;
JSEP_SET_ERROR
(
"
No
transceiver
for
level
"
<
<
i
)
;
return
NS_ERROR_FAILURE
;
}
if
(
answer
.
GetMediaSection
(
i
)
.
GetPort
(
)
=
=
0
)
{
transceiver
-
>
mTransport
.
Close
(
)
;
transceiver
-
>
Stop
(
)
;
transceiver
-
>
Disassociate
(
)
;
transceiver
-
>
ClearBundleLevel
(
)
;
transceiver
-
>
mSendTrack
.
SetActive
(
false
)
;
transceiver
-
>
mRecvTrack
.
SetActive
(
false
)
;
transceiver
-
>
SetCanRecycle
(
)
;
continue
;
}
rv
=
MakeNegotiatedTransceiver
(
remote
-
>
GetMediaSection
(
i
)
local
-
>
GetMediaSection
(
i
)
transceiver
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
CopyBundleTransports
(
)
;
std
:
:
vector
<
JsepTrack
*
>
remoteTracks
;
for
(
const
auto
&
transceiver
:
mTransceivers
)
{
remoteTracks
.
push_back
(
&
transceiver
-
>
mRecvTrack
)
;
}
JsepTrack
:
:
SetUniquePayloadTypes
(
remoteTracks
)
;
mNegotiations
+
+
;
mGeneratedAnswer
.
reset
(
)
;
mGeneratedOffer
.
reset
(
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
MakeNegotiatedTransceiver
(
const
SdpMediaSection
&
remote
const
SdpMediaSection
&
local
JsepTransceiver
*
transceiver
)
{
const
SdpMediaSection
&
answer
=
*
mIsPendingOfferer
?
remote
:
local
;
bool
sending
=
false
;
bool
receiving
=
false
;
if
(
!
transceiver
-
>
IsStopped
(
)
)
{
if
(
*
mIsPendingOfferer
)
{
receiving
=
answer
.
IsSending
(
)
;
sending
=
answer
.
IsReceiving
(
)
;
}
else
{
sending
=
answer
.
IsSending
(
)
;
receiving
=
answer
.
IsReceiving
(
)
;
}
}
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
Negotiated
m
=
line
"
<
<
"
index
=
"
<
<
local
.
GetLevel
(
)
<
<
"
type
=
"
<
<
local
.
GetMediaType
(
)
<
<
"
sending
=
"
<
<
sending
<
<
"
receiving
=
"
<
<
receiving
)
;
transceiver
-
>
SetNegotiated
(
)
;
nsresult
rv
=
FinalizeTransport
(
remote
.
GetAttributeList
(
)
answer
.
GetAttributeList
(
)
&
transceiver
-
>
mTransport
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
transceiver
-
>
mSendTrack
.
SetActive
(
sending
)
;
transceiver
-
>
mSendTrack
.
Negotiate
(
answer
remote
local
)
;
JsepTrack
&
recvTrack
=
transceiver
-
>
mRecvTrack
;
recvTrack
.
SetActive
(
receiving
)
;
recvTrack
.
Negotiate
(
answer
remote
local
)
;
if
(
transceiver
-
>
HasBundleLevel
(
)
&
&
recvTrack
.
GetSsrcs
(
)
.
empty
(
)
&
&
recvTrack
.
GetMediaType
(
)
!
=
SdpMediaSection
:
:
kApplication
)
{
MOZ_MTLOG
(
ML_ERROR
"
[
"
<
<
mName
<
<
"
]
:
Bundled
m
-
section
has
no
ssrc
"
"
attributes
.
This
may
cause
media
packets
to
be
"
"
dropped
.
"
)
;
}
if
(
transceiver
-
>
mTransport
.
mComponents
=
=
2
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
RTCP
-
MUX
is
off
"
)
;
}
return
NS_OK
;
}
void
JsepSessionImpl
:
:
EnsureHasOwnTransport
(
const
SdpMediaSection
&
msection
JsepTransceiver
*
transceiver
)
{
JsepTransport
&
transport
=
transceiver
-
>
mTransport
;
if
(
!
transceiver
-
>
HasOwnTransport
(
)
)
{
transport
.
Close
(
)
;
}
transport
.
mLocalUfrag
=
msection
.
GetAttributeList
(
)
.
GetIceUfrag
(
)
;
transport
.
mLocalPwd
=
msection
.
GetAttributeList
(
)
.
GetIcePwd
(
)
;
transceiver
-
>
ClearBundleLevel
(
)
;
if
(
!
transport
.
mComponents
)
{
if
(
mSdpHelper
.
HasRtcp
(
msection
.
GetProtocol
(
)
)
)
{
transport
.
mComponents
=
2
;
}
else
{
transport
.
mComponents
=
1
;
}
}
if
(
transport
.
mTransportId
.
empty
(
)
)
{
std
:
:
ostringstream
os
;
os
<
<
"
transport_
"
<
<
mTransportIdCounter
+
+
;
transport
.
mTransportId
=
os
.
str
(
)
;
}
}
void
JsepSessionImpl
:
:
CopyBundleTransports
(
)
{
for
(
auto
&
transceiver
:
mTransceivers
)
{
if
(
transceiver
-
>
HasBundleLevel
(
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
Transceiver
"
<
<
transceiver
-
>
GetLevel
(
)
<
<
"
is
in
a
bundle
;
transceiver
"
<
<
transceiver
-
>
BundleLevel
(
)
<
<
"
owns
the
transport
.
"
)
;
const
JsepTransceiver
*
transportOwner
=
GetTransceiverForLevel
(
transceiver
-
>
BundleLevel
(
)
)
;
MOZ_ASSERT
(
transportOwner
)
;
if
(
transportOwner
)
{
transceiver
-
>
mTransport
=
transportOwner
-
>
mTransport
;
}
}
else
if
(
transceiver
-
>
HasLevel
(
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
Transceiver
"
<
<
transceiver
-
>
GetLevel
(
)
<
<
"
is
not
necessarily
in
a
bundle
.
"
)
;
}
if
(
transceiver
-
>
HasLevel
(
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
Transceiver
"
<
<
transceiver
-
>
GetLevel
(
)
<
<
"
transport
-
id
:
"
<
<
transceiver
-
>
mTransport
.
mTransportId
<
<
"
components
:
"
<
<
transceiver
-
>
mTransport
.
mComponents
)
;
}
}
}
nsresult
JsepSessionImpl
:
:
FinalizeTransport
(
const
SdpAttributeList
&
remote
const
SdpAttributeList
&
answer
JsepTransport
*
transport
)
{
if
(
!
transport
-
>
mComponents
)
{
return
NS_OK
;
}
if
(
!
transport
-
>
mIce
|
|
transport
-
>
mIce
-
>
mUfrag
!
=
remote
.
GetIceUfrag
(
)
|
|
transport
-
>
mIce
-
>
mPwd
!
=
remote
.
GetIcePwd
(
)
)
{
UniquePtr
<
JsepIceTransport
>
ice
=
MakeUnique
<
JsepIceTransport
>
(
)
;
transport
-
>
mDtls
=
nullptr
;
ice
-
>
mUfrag
=
remote
.
GetIceUfrag
(
)
;
ice
-
>
mPwd
=
remote
.
GetIcePwd
(
)
;
transport
-
>
mIce
=
std
:
:
move
(
ice
)
;
}
if
(
remote
.
HasAttribute
(
SdpAttribute
:
:
kCandidateAttribute
)
)
{
transport
-
>
mIce
-
>
mCandidates
=
remote
.
GetCandidate
(
)
;
}
if
(
!
transport
-
>
mDtls
)
{
UniquePtr
<
JsepDtlsTransport
>
dtls
=
MakeUnique
<
JsepDtlsTransport
>
(
)
;
dtls
-
>
mFingerprints
=
remote
.
GetFingerprint
(
)
;
if
(
!
answer
.
HasAttribute
(
mozilla
:
:
SdpAttribute
:
:
kSetupAttribute
)
)
{
dtls
-
>
mRole
=
*
mIsPendingOfferer
?
JsepDtlsTransport
:
:
kJsepDtlsServer
:
JsepDtlsTransport
:
:
kJsepDtlsClient
;
}
else
{
if
(
*
mIsPendingOfferer
)
{
dtls
-
>
mRole
=
(
answer
.
GetSetup
(
)
.
mRole
=
=
SdpSetupAttribute
:
:
kActive
)
?
JsepDtlsTransport
:
:
kJsepDtlsServer
:
JsepDtlsTransport
:
:
kJsepDtlsClient
;
}
else
{
dtls
-
>
mRole
=
(
answer
.
GetSetup
(
)
.
mRole
=
=
SdpSetupAttribute
:
:
kActive
)
?
JsepDtlsTransport
:
:
kJsepDtlsClient
:
JsepDtlsTransport
:
:
kJsepDtlsServer
;
}
}
transport
-
>
mDtls
=
std
:
:
move
(
dtls
)
;
}
if
(
answer
.
HasAttribute
(
SdpAttribute
:
:
kRtcpMuxAttribute
)
)
{
transport
-
>
mComponents
=
1
;
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
AddTransportAttributes
(
SdpMediaSection
*
msection
SdpSetupAttribute
:
:
Role
dtlsRole
)
{
if
(
mIceUfrag
.
empty
(
)
|
|
mIcePwd
.
empty
(
)
)
{
JSEP_SET_ERROR
(
"
Missing
ICE
ufrag
or
password
"
)
;
return
NS_ERROR_FAILURE
;
}
SdpAttributeList
&
attrList
=
msection
-
>
GetAttributeList
(
)
;
attrList
.
SetAttribute
(
new
SdpStringAttribute
(
SdpAttribute
:
:
kIceUfragAttribute
mIceUfrag
)
)
;
attrList
.
SetAttribute
(
new
SdpStringAttribute
(
SdpAttribute
:
:
kIcePwdAttribute
mIcePwd
)
)
;
msection
-
>
GetAttributeList
(
)
.
SetAttribute
(
new
SdpSetupAttribute
(
dtlsRole
)
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
CopyPreviousTransportParams
(
const
Sdp
&
oldAnswer
const
Sdp
&
offerersPreviousSdp
const
Sdp
&
newOffer
Sdp
*
newLocal
)
{
for
(
size_t
i
=
0
;
i
<
oldAnswer
.
GetMediaSectionCount
(
)
;
+
+
i
)
{
if
(
!
mSdpHelper
.
MsectionIsDisabled
(
newLocal
-
>
GetMediaSection
(
i
)
)
&
&
mSdpHelper
.
AreOldTransportParamsValid
(
oldAnswer
offerersPreviousSdp
newOffer
i
)
)
{
JsepTransceiver
*
transceiver
(
GetTransceiverForLevel
(
i
)
)
;
if
(
!
transceiver
)
{
MOZ_ASSERT
(
false
)
;
JSEP_SET_ERROR
(
"
No
transceiver
for
level
"
<
<
i
)
;
return
NS_ERROR_FAILURE
;
}
size_t
numComponents
=
transceiver
-
>
mTransport
.
mComponents
;
nsresult
rv
=
mSdpHelper
.
CopyTransportParams
(
numComponents
mCurrentLocalDescription
-
>
GetMediaSection
(
i
)
&
newLocal
-
>
GetMediaSection
(
i
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
ParseSdp
(
const
std
:
:
string
&
sdp
UniquePtr
<
Sdp
>
*
parsedp
)
{
auto
results
=
mParser
-
>
Parse
(
sdp
)
;
auto
parsed
=
std
:
:
move
(
results
-
>
Sdp
(
)
)
;
mLastSdpParsingErrors
=
results
-
>
Errors
(
)
;
if
(
!
parsed
)
{
std
:
:
string
error
=
results
-
>
ParserName
(
)
+
"
Failed
to
parse
SDP
:
"
;
mSdpHelper
.
AppendSdpParseErrors
(
mLastSdpParsingErrors
&
error
)
;
JSEP_SET_ERROR
(
error
)
;
return
NS_ERROR_INVALID_ARG
;
}
for
(
size_t
i
=
0
;
i
<
parsed
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
if
(
mSdpHelper
.
MsectionIsDisabled
(
parsed
-
>
GetMediaSection
(
i
)
)
)
{
continue
;
}
const
SdpMediaSection
&
msection
(
parsed
-
>
GetMediaSection
(
i
)
)
;
auto
&
mediaAttrs
=
msection
.
GetAttributeList
(
)
;
if
(
mediaAttrs
.
HasAttribute
(
SdpAttribute
:
:
kMidAttribute
)
&
&
mediaAttrs
.
GetMid
(
)
.
length
(
)
>
16
)
{
JSEP_SET_ERROR
(
"
Invalid
description
mid
length
greater
than
16
"
"
unsupported
until
2
-
byte
rtp
header
extensions
are
"
"
supported
in
webrtc
.
org
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
mediaAttrs
.
GetIceUfrag
(
)
.
empty
(
)
)
{
JSEP_SET_ERROR
(
"
Invalid
description
no
ice
-
ufrag
attribute
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
mediaAttrs
.
GetIcePwd
(
)
.
empty
(
)
)
{
JSEP_SET_ERROR
(
"
Invalid
description
no
ice
-
pwd
attribute
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mediaAttrs
.
HasAttribute
(
SdpAttribute
:
:
kFingerprintAttribute
)
)
{
JSEP_SET_ERROR
(
"
Invalid
description
no
fingerprint
attribute
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
const
SdpFingerprintAttributeList
&
fingerprints
(
mediaAttrs
.
GetFingerprint
(
)
)
;
if
(
fingerprints
.
mFingerprints
.
empty
(
)
)
{
JSEP_SET_ERROR
(
"
Invalid
description
no
supported
fingerprint
algorithms
"
"
present
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
mediaAttrs
.
HasAttribute
(
SdpAttribute
:
:
kSetupAttribute
true
)
&
&
mediaAttrs
.
GetSetup
(
)
.
mRole
=
=
SdpSetupAttribute
:
:
kHoldconn
)
{
JSEP_SET_ERROR
(
"
Description
has
illegal
setup
attribute
"
"
\
"
holdconn
\
"
in
m
-
section
at
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
mediaAttrs
.
HasAttribute
(
SdpAttribute
:
:
kExtmapAttribute
)
)
{
std
:
:
set
<
uint16_t
>
extIds
;
for
(
const
auto
&
ext
:
mediaAttrs
.
GetExtmap
(
)
.
mExtmaps
)
{
uint16_t
id
=
ext
.
entry
;
if
(
id
<
1
|
|
id
>
14
)
{
JSEP_SET_ERROR
(
"
Description
contains
invalid
extension
id
"
<
<
id
<
<
"
on
level
"
<
<
i
<
<
"
which
is
unsupported
until
2
-
byte
rtp
"
"
header
extensions
are
supported
in
webrtc
.
org
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
extIds
.
find
(
id
)
!
=
extIds
.
end
(
)
)
{
JSEP_SET_ERROR
(
"
Description
contains
duplicate
extension
id
"
<
<
id
<
<
"
on
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
extIds
.
insert
(
id
)
;
}
}
static
const
std
:
:
bitset
<
128
>
forbidden
=
GetForbiddenSdpPayloadTypes
(
)
;
if
(
msection
.
GetMediaType
(
)
=
=
SdpMediaSection
:
:
kAudio
|
|
msection
.
GetMediaType
(
)
=
=
SdpMediaSection
:
:
kVideo
)
{
for
(
const
std
:
:
string
&
fmt
:
msection
.
GetFormats
(
)
)
{
uint16_t
payloadType
;
if
(
!
SdpHelper
:
:
GetPtAsInt
(
fmt
&
payloadType
)
)
{
JSEP_SET_ERROR
(
"
Payload
type
\
"
"
<
<
fmt
<
<
"
\
"
is
not
a
16
-
bit
unsigned
int
at
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
payloadType
>
127
)
{
JSEP_SET_ERROR
(
"
audio
/
video
payload
type
\
"
"
<
<
fmt
<
<
"
\
"
is
too
large
at
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
forbidden
.
test
(
payloadType
)
)
{
JSEP_SET_ERROR
(
"
Illegal
audio
/
video
payload
type
\
"
"
<
<
fmt
<
<
"
\
"
at
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
}
}
*
parsedp
=
std
:
:
move
(
parsed
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
SetRemoteDescriptionOffer
(
UniquePtr
<
Sdp
>
offer
)
{
MOZ_ASSERT
(
mState
=
=
kJsepStateStable
)
;
mPendingRemoteDescription
=
std
:
:
move
(
offer
)
;
mIsPendingOfferer
=
Some
(
false
)
;
SetState
(
kJsepStateHaveRemoteOffer
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
SetRemoteDescriptionAnswer
(
JsepSdpType
type
UniquePtr
<
Sdp
>
answer
)
{
MOZ_ASSERT
(
mState
=
=
kJsepStateHaveLocalOffer
|
|
mState
=
=
kJsepStateHaveRemotePranswer
)
;
mPendingRemoteDescription
=
std
:
:
move
(
answer
)
;
nsresult
rv
=
HandleNegotiatedSession
(
mPendingLocalDescription
mPendingRemoteDescription
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCurrentRemoteDescription
=
std
:
:
move
(
mPendingRemoteDescription
)
;
mCurrentLocalDescription
=
std
:
:
move
(
mPendingLocalDescription
)
;
MOZ_ASSERT
(
mIsPendingOfferer
.
isSome
(
)
&
&
*
mIsPendingOfferer
)
;
mIsPendingOfferer
.
reset
(
)
;
mIsCurrentOfferer
=
Some
(
true
)
;
SetState
(
kJsepStateStable
)
;
return
NS_OK
;
}
JsepTransceiver
*
JsepSessionImpl
:
:
GetTransceiverForLevel
(
size_t
level
)
const
{
for
(
const
auto
&
transceiver
:
mTransceivers
)
{
if
(
transceiver
-
>
HasLevel
(
)
&
&
(
transceiver
-
>
GetLevel
(
)
=
=
level
)
)
{
return
transceiver
.
get
(
)
;
}
}
return
nullptr
;
}
JsepTransceiver
*
JsepSessionImpl
:
:
GetTransceiverForMid
(
const
std
:
:
string
&
mid
)
const
{
for
(
const
auto
&
transceiver
:
mTransceivers
)
{
if
(
transceiver
-
>
IsAssociated
(
)
&
&
(
transceiver
-
>
GetMid
(
)
=
=
mid
)
)
{
return
transceiver
.
get
(
)
;
}
}
return
nullptr
;
}
JsepTransceiver
*
JsepSessionImpl
:
:
GetTransceiverForLocal
(
size_t
level
)
{
if
(
JsepTransceiver
*
transceiver
=
GetTransceiverForLevel
(
level
)
)
{
if
(
transceiver
-
>
CanRecycle
(
)
&
&
transceiver
-
>
GetMediaType
(
)
!
=
SdpMediaSection
:
:
kApplication
)
{
transceiver
-
>
Disassociate
(
)
;
JsepTransceiver
*
newTransceiver
=
FindUnassociatedTransceiver
(
transceiver
-
>
GetMediaType
(
)
false
)
;
if
(
newTransceiver
)
{
newTransceiver
-
>
SetLevel
(
level
)
;
transceiver
-
>
ClearLevel
(
)
;
return
newTransceiver
;
}
}
return
transceiver
;
}
for
(
auto
&
transceiver
:
mTransceivers
)
{
if
(
transceiver
-
>
GetMediaType
(
)
!
=
SdpMediaSection
:
:
kApplication
&
&
!
transceiver
-
>
IsStopped
(
)
&
&
!
transceiver
-
>
HasLevel
(
)
)
{
transceiver
-
>
SetLevel
(
level
)
;
return
transceiver
.
get
(
)
;
}
}
for
(
auto
&
transceiver
:
mTransceivers
)
{
if
(
!
transceiver
-
>
IsStopped
(
)
&
&
!
transceiver
-
>
HasLevel
(
)
)
{
transceiver
-
>
SetLevel
(
level
)
;
return
transceiver
.
get
(
)
;
}
}
return
nullptr
;
}
JsepTransceiver
*
JsepSessionImpl
:
:
GetTransceiverForRemote
(
const
SdpMediaSection
&
msection
)
{
size_t
level
=
msection
.
GetLevel
(
)
;
if
(
JsepTransceiver
*
transceiver
=
GetTransceiverForLevel
(
level
)
)
{
if
(
!
transceiver
-
>
CanRecycle
(
)
)
{
return
transceiver
;
}
transceiver
-
>
Disassociate
(
)
;
transceiver
-
>
ClearLevel
(
)
;
}
JsepTransceiver
*
transceiver
=
FindUnassociatedTransceiver
(
msection
.
GetMediaType
(
)
true
)
;
if
(
transceiver
)
{
transceiver
-
>
SetLevel
(
level
)
;
return
transceiver
;
}
RefPtr
<
JsepTransceiver
>
newTransceiver
(
new
JsepTransceiver
(
msection
.
GetMediaType
(
)
*
mUuidGen
SdpDirectionAttribute
:
:
kRecvonly
)
)
;
newTransceiver
-
>
SetLevel
(
level
)
;
newTransceiver
-
>
SetCreatedBySetRemote
(
)
;
nsresult
rv
=
AddTransceiver
(
newTransceiver
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
newTransceiver
.
get
(
)
;
}
JsepTransceiver
*
JsepSessionImpl
:
:
GetTransceiverWithTransport
(
const
std
:
:
string
&
transportId
)
const
{
for
(
const
auto
&
transceiver
:
mTransceivers
)
{
if
(
transceiver
-
>
HasOwnTransport
(
)
&
&
(
transceiver
-
>
mTransport
.
mTransportId
=
=
transportId
)
)
{
MOZ_ASSERT
(
transceiver
-
>
HasLevel
(
)
"
Transceiver
has
a
transport
but
no
level
!
"
)
;
return
transceiver
.
get
(
)
;
}
}
return
nullptr
;
}
nsresult
JsepSessionImpl
:
:
UpdateTransceiversFromRemoteDescription
(
const
Sdp
&
remote
)
{
for
(
size_t
i
=
0
;
i
<
remote
.
GetMediaSectionCount
(
)
;
+
+
i
)
{
const
SdpMediaSection
&
msection
=
remote
.
GetMediaSection
(
i
)
;
JsepTransceiver
*
transceiver
(
GetTransceiverForRemote
(
msection
)
)
;
if
(
!
transceiver
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mSdpHelper
.
MsectionIsDisabled
(
msection
)
)
{
if
(
msection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kMidAttribute
)
)
{
transceiver
-
>
Associate
(
msection
.
GetAttributeList
(
)
.
GetMid
(
)
)
;
}
if
(
!
transceiver
-
>
IsAssociated
(
)
)
{
transceiver
-
>
Associate
(
GetNewMid
(
)
)
;
}
else
{
mUsedMids
.
insert
(
transceiver
-
>
GetMid
(
)
)
;
}
}
else
{
transceiver
-
>
mTransport
.
Close
(
)
;
transceiver
-
>
Disassociate
(
)
;
transceiver
-
>
Stop
(
)
;
continue
;
}
if
(
msection
.
GetMediaType
(
)
=
=
SdpMediaSection
:
:
MediaType
:
:
kApplication
)
{
continue
;
}
transceiver
-
>
mRecvTrack
.
UpdateStreamIds
(
{
mDefaultRemoteStreamId
}
)
;
transceiver
-
>
mRecvTrack
.
UpdateRecvTrack
(
remote
msection
)
;
}
return
NS_OK
;
}
JsepTransceiver
*
JsepSessionImpl
:
:
FindUnassociatedTransceiver
(
SdpMediaSection
:
:
MediaType
type
bool
magic
)
{
for
(
auto
&
transceiver
:
mTransceivers
)
{
if
(
type
=
=
SdpMediaSection
:
:
kApplication
&
&
type
=
=
transceiver
-
>
GetMediaType
(
)
)
{
transceiver
-
>
RestartDatachannelTransceiver
(
)
;
return
transceiver
.
get
(
)
;
}
if
(
!
transceiver
-
>
IsStopped
(
)
&
&
!
transceiver
-
>
HasLevel
(
)
&
&
(
!
magic
|
|
transceiver
-
>
HasAddTrackMagic
(
)
)
&
&
(
transceiver
-
>
GetMediaType
(
)
=
=
type
)
)
{
return
transceiver
.
get
(
)
;
}
}
return
nullptr
;
}
void
JsepSessionImpl
:
:
RollbackLocalOffer
(
)
{
for
(
size_t
i
=
0
;
i
<
mTransceivers
.
size
(
)
;
+
+
i
)
{
auto
transceiver
=
mTransceivers
[
i
]
;
if
(
mOldTransceivers
.
size
(
)
>
i
)
{
transceiver
-
>
Rollback
(
*
mOldTransceivers
[
i
]
false
)
;
mOldTransceivers
[
i
]
=
transceiver
;
continue
;
}
RefPtr
<
JsepTransceiver
>
temp
(
new
JsepTransceiver
(
transceiver
-
>
GetMediaType
(
)
*
mUuidGen
)
)
;
temp
-
>
mSendTrack
.
PopulateCodecs
(
mSupportedCodecs
)
;
temp
-
>
mRecvTrack
.
PopulateCodecs
(
mSupportedCodecs
)
;
transceiver
-
>
Rollback
(
*
temp
false
)
;
mOldTransceivers
.
push_back
(
transceiver
)
;
}
mTransceivers
=
std
:
:
move
(
mOldTransceivers
)
;
}
void
JsepSessionImpl
:
:
RollbackRemoteOffer
(
)
{
for
(
size_t
i
=
0
;
i
<
mTransceivers
.
size
(
)
;
+
+
i
)
{
auto
transceiver
=
mTransceivers
[
i
]
;
if
(
mOldTransceivers
.
size
(
)
>
i
)
{
transceiver
-
>
Rollback
(
*
mOldTransceivers
[
i
]
true
)
;
mOldTransceivers
[
i
]
=
transceiver
;
continue
;
}
bool
shouldRemove
=
!
transceiver
-
>
HasAddTrackMagic
(
)
&
&
transceiver
-
>
WasCreatedBySetRemote
(
)
;
RefPtr
<
JsepTransceiver
>
temp
(
new
JsepTransceiver
(
transceiver
-
>
GetMediaType
(
)
*
mUuidGen
)
)
;
temp
-
>
mSendTrack
.
PopulateCodecs
(
mSupportedCodecs
)
;
temp
-
>
mRecvTrack
.
PopulateCodecs
(
mSupportedCodecs
)
;
transceiver
-
>
Rollback
(
*
temp
true
)
;
if
(
shouldRemove
)
{
transceiver
-
>
Stop
(
)
;
transceiver
-
>
SetRemoved
(
)
;
}
mOldTransceivers
.
push_back
(
transceiver
)
;
}
mTransceivers
=
std
:
:
move
(
mOldTransceivers
)
;
}
nsresult
JsepSessionImpl
:
:
ValidateLocalDescription
(
const
Sdp
&
description
JsepSdpType
type
)
{
Sdp
*
generated
=
nullptr
;
if
(
type
=
=
kJsepSdpOffer
)
{
generated
=
mGeneratedOffer
.
get
(
)
;
}
else
{
generated
=
mGeneratedAnswer
.
get
(
)
;
}
if
(
!
generated
)
{
JSEP_SET_ERROR
(
"
Calling
SetLocal
without
first
calling
CreateOffer
/
Answer
"
"
is
not
supported
.
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
description
.
GetMediaSectionCount
(
)
!
=
generated
-
>
GetMediaSectionCount
(
)
)
{
JSEP_SET_ERROR
(
"
Changing
the
number
of
m
-
sections
is
not
allowed
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
for
(
size_t
i
=
0
;
i
<
description
.
GetMediaSectionCount
(
)
;
+
+
i
)
{
auto
&
origMsection
=
generated
-
>
GetMediaSection
(
i
)
;
auto
&
finalMsection
=
description
.
GetMediaSection
(
i
)
;
if
(
origMsection
.
GetMediaType
(
)
!
=
finalMsection
.
GetMediaType
(
)
)
{
JSEP_SET_ERROR
(
"
Changing
the
media
-
type
of
m
-
sections
is
not
allowed
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mCurrentLocalDescription
)
{
if
(
finalMsection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kCandidateAttribute
)
)
{
JSEP_SET_ERROR
(
"
Adding
your
own
candidate
attributes
is
not
supported
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
finalMsection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kEndOfCandidatesAttribute
)
)
{
JSEP_SET_ERROR
(
"
Why
are
you
trying
to
set
a
=
end
-
of
-
candidates
?
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
if
(
mSdpHelper
.
MsectionIsDisabled
(
finalMsection
)
)
{
continue
;
}
if
(
!
finalMsection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kMidAttribute
)
)
{
JSEP_SET_ERROR
(
"
Local
descriptions
must
have
a
=
mid
attributes
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
finalMsection
.
GetAttributeList
(
)
.
GetMid
(
)
!
=
origMsection
.
GetAttributeList
(
)
.
GetMid
(
)
)
{
JSEP_SET_ERROR
(
"
Changing
the
mid
of
m
-
sections
is
not
allowed
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
if
(
description
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kIceLiteAttribute
)
)
{
JSEP_SET_ERROR
(
"
Running
ICE
in
lite
mode
is
unsupported
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
ValidateRemoteDescription
(
const
Sdp
&
description
)
{
if
(
!
mCurrentRemoteDescription
|
|
!
mCurrentLocalDescription
)
{
return
NS_OK
;
}
if
(
mCurrentRemoteDescription
-
>
GetMediaSectionCount
(
)
>
description
.
GetMediaSectionCount
(
)
)
{
JSEP_SET_ERROR
(
"
New
remote
description
has
fewer
m
-
sections
than
the
"
"
previous
remote
description
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
SdpHelper
:
:
BundledMids
bundledMids
;
nsresult
rv
=
GetNegotiatedBundledMids
(
&
bundledMids
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SdpHelper
:
:
BundledMids
newBundledMids
;
rv
=
mSdpHelper
.
GetBundledMids
(
description
&
newBundledMids
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Maybe
<
bool
>
iceCredsDiffer
;
for
(
size_t
i
=
0
;
i
<
mCurrentRemoteDescription
-
>
GetMediaSectionCount
(
)
;
+
+
i
)
{
const
SdpMediaSection
&
newMsection
=
description
.
GetMediaSection
(
i
)
;
const
SdpMediaSection
&
oldMsection
=
mCurrentRemoteDescription
-
>
GetMediaSection
(
i
)
;
if
(
mSdpHelper
.
MsectionIsDisabled
(
newMsection
)
|
|
mSdpHelper
.
MsectionIsDisabled
(
oldMsection
)
)
{
continue
;
}
if
(
oldMsection
.
GetMediaType
(
)
!
=
newMsection
.
GetMediaType
(
)
)
{
JSEP_SET_ERROR
(
"
Remote
description
changes
the
media
type
of
m
-
line
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
bool
differ
=
mSdpHelper
.
IceCredentialsDiffer
(
newMsection
oldMsection
)
;
if
(
mIsPendingOfferer
.
isSome
(
)
&
&
*
mIsPendingOfferer
&
&
differ
&
&
!
IsIceRestarting
(
)
)
{
JSEP_SET_ERROR
(
"
Remote
description
indicates
ICE
restart
but
offer
did
not
"
"
request
ICE
restart
(
new
remote
description
changes
either
"
"
the
ice
-
ufrag
or
ice
-
pwd
)
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
iceCredsDiffer
.
isSome
(
)
)
{
iceCredsDiffer
=
mozilla
:
:
Some
(
differ
)
;
}
else
if
(
iceCredsDiffer
.
isSome
(
)
&
&
*
iceCredsDiffer
!
=
differ
)
{
JSEP_SET_ERROR
(
"
Partial
ICE
restart
is
unsupported
at
this
time
"
"
(
new
remote
description
changes
either
the
ice
-
ufrag
"
"
or
ice
-
pwd
on
fewer
than
all
msections
)
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
ValidateOffer
(
const
Sdp
&
offer
)
{
for
(
size_t
i
=
0
;
i
<
offer
.
GetMediaSectionCount
(
)
;
+
+
i
)
{
const
SdpMediaSection
&
offerMsection
=
offer
.
GetMediaSection
(
i
)
;
if
(
mSdpHelper
.
MsectionIsDisabled
(
offerMsection
)
)
{
continue
;
}
const
SdpAttributeList
&
offerAttrs
(
offerMsection
.
GetAttributeList
(
)
)
;
if
(
!
offerAttrs
.
HasAttribute
(
SdpAttribute
:
:
kSetupAttribute
true
)
)
{
JSEP_SET_ERROR
(
"
Offer
is
missing
required
setup
attribute
"
"
at
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
ValidateAnswer
(
const
Sdp
&
offer
const
Sdp
&
answer
)
{
if
(
offer
.
GetMediaSectionCount
(
)
!
=
answer
.
GetMediaSectionCount
(
)
)
{
JSEP_SET_ERROR
(
"
Offer
and
answer
have
different
number
of
m
-
lines
"
<
<
"
(
"
<
<
offer
.
GetMediaSectionCount
(
)
<
<
"
vs
"
<
<
answer
.
GetMediaSectionCount
(
)
<
<
"
)
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
for
(
size_t
i
=
0
;
i
<
offer
.
GetMediaSectionCount
(
)
;
+
+
i
)
{
const
SdpMediaSection
&
offerMsection
=
offer
.
GetMediaSection
(
i
)
;
const
SdpMediaSection
&
answerMsection
=
answer
.
GetMediaSection
(
i
)
;
if
(
offerMsection
.
GetMediaType
(
)
!
=
answerMsection
.
GetMediaType
(
)
)
{
JSEP_SET_ERROR
(
"
Answer
and
offer
have
different
media
types
at
m
-
line
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
mSdpHelper
.
MsectionIsDisabled
(
answerMsection
)
)
{
continue
;
}
if
(
mSdpHelper
.
MsectionIsDisabled
(
offerMsection
)
)
{
JSEP_SET_ERROR
(
"
Answer
tried
to
enable
an
m
-
section
that
was
disabled
in
the
offer
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
offerMsection
.
IsSending
(
)
&
&
answerMsection
.
IsReceiving
(
)
)
{
JSEP_SET_ERROR
(
"
Answer
tried
to
set
recv
when
offer
did
not
set
send
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
offerMsection
.
IsReceiving
(
)
&
&
answerMsection
.
IsSending
(
)
)
{
JSEP_SET_ERROR
(
"
Answer
tried
to
set
send
when
offer
did
not
set
recv
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
const
SdpAttributeList
&
answerAttrs
(
answerMsection
.
GetAttributeList
(
)
)
;
const
SdpAttributeList
&
offerAttrs
(
offerMsection
.
GetAttributeList
(
)
)
;
if
(
answerAttrs
.
HasAttribute
(
SdpAttribute
:
:
kMidAttribute
)
&
&
offerAttrs
.
HasAttribute
(
SdpAttribute
:
:
kMidAttribute
)
&
&
offerAttrs
.
GetMid
(
)
!
=
answerAttrs
.
GetMid
(
)
)
{
JSEP_SET_ERROR
(
"
Answer
changes
mid
for
level
was
\
'
"
<
<
offerMsection
.
GetAttributeList
(
)
.
GetMid
(
)
<
<
"
\
'
now
\
'
"
<
<
answerMsection
.
GetAttributeList
(
)
.
GetMid
(
)
<
<
"
\
'
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
answerAttrs
.
HasAttribute
(
SdpAttribute
:
:
kSetupAttribute
true
)
&
&
answerAttrs
.
GetSetup
(
)
.
mRole
=
=
SdpSetupAttribute
:
:
kActpass
)
{
JSEP_SET_ERROR
(
"
Answer
contains
illegal
setup
attribute
\
"
actpass
\
"
"
"
at
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
answerAttrs
.
HasAttribute
(
SdpAttribute
:
:
kExtmapAttribute
)
)
{
if
(
!
offerAttrs
.
HasAttribute
(
SdpAttribute
:
:
kExtmapAttribute
)
)
{
JSEP_SET_ERROR
(
"
Answer
adds
extmap
attributes
to
level
"
<
<
i
)
;
return
NS_ERROR_INVALID_ARG
;
}
for
(
const
auto
&
ansExt
:
answerAttrs
.
GetExtmap
(
)
.
mExtmaps
)
{
bool
found
=
false
;
for
(
const
auto
&
offExt
:
offerAttrs
.
GetExtmap
(
)
.
mExtmaps
)
{
if
(
ansExt
.
extensionname
=
=
offExt
.
extensionname
)
{
if
(
(
ansExt
.
direction
&
reverse
(
offExt
.
direction
)
)
!
=
ansExt
.
direction
)
{
MOZ_MTLOG
(
ML_WARNING
"
[
"
<
<
mName
<
<
"
]
:
Answer
has
inconsistent
"
"
direction
on
extmap
attribute
at
level
"
<
<
i
<
<
"
(
"
<
<
ansExt
.
extensionname
<
<
"
)
.
Offer
had
"
<
<
offExt
.
direction
<
<
"
answer
had
"
<
<
ansExt
.
direction
<
<
"
.
"
)
;
}
if
(
offExt
.
entry
<
4096
&
&
(
offExt
.
entry
!
=
ansExt
.
entry
)
)
{
JSEP_SET_ERROR
(
"
Answer
changed
id
for
extmap
attribute
at
level
"
<
<
i
<
<
"
(
"
<
<
offExt
.
extensionname
<
<
"
)
from
"
<
<
offExt
.
entry
<
<
"
to
"
<
<
ansExt
.
entry
<
<
"
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
ansExt
.
entry
>
=
4096
)
{
JSEP_SET_ERROR
(
"
Answer
used
an
invalid
id
(
"
<
<
ansExt
.
entry
<
<
"
)
for
extmap
attribute
at
level
"
<
<
i
<
<
"
(
"
<
<
ansExt
.
extensionname
<
<
"
)
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
found
=
true
;
break
;
}
}
if
(
!
found
)
{
JSEP_SET_ERROR
(
"
Answer
has
extmap
"
<
<
ansExt
.
extensionname
<
<
"
at
"
"
level
"
<
<
i
<
<
"
that
was
not
present
in
offer
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
}
}
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
CreateGenericSDP
(
UniquePtr
<
Sdp
>
*
sdpp
)
{
auto
origin
=
SdpOrigin
(
"
mozilla
.
.
.
THIS_IS_SDPARTA
-
99
.
0
"
mSessionId
mSessionVersion
sdp
:
:
kIPv4
"
0
.
0
.
0
.
0
"
)
;
UniquePtr
<
Sdp
>
sdp
=
MakeUnique
<
SipccSdp
>
(
origin
)
;
if
(
mDtlsFingerprints
.
empty
(
)
)
{
JSEP_SET_ERROR
(
"
Missing
DTLS
fingerprint
"
)
;
return
NS_ERROR_FAILURE
;
}
UniquePtr
<
SdpFingerprintAttributeList
>
fpl
=
MakeUnique
<
SdpFingerprintAttributeList
>
(
)
;
for
(
auto
&
dtlsFingerprint
:
mDtlsFingerprints
)
{
fpl
-
>
PushEntry
(
dtlsFingerprint
.
mAlgorithm
dtlsFingerprint
.
mValue
)
;
}
sdp
-
>
GetAttributeList
(
)
.
SetAttribute
(
fpl
.
release
(
)
)
;
auto
*
iceOpts
=
new
SdpOptionsAttribute
(
SdpAttribute
:
:
kIceOptionsAttribute
)
;
iceOpts
-
>
PushEntry
(
"
trickle
"
)
;
sdp
-
>
GetAttributeList
(
)
.
SetAttribute
(
iceOpts
)
;
std
:
:
vector
<
std
:
:
string
>
msids
;
msids
.
push_back
(
"
*
"
)
;
mSdpHelper
.
SetupMsidSemantic
(
msids
sdp
.
get
(
)
)
;
*
sdpp
=
std
:
:
move
(
sdp
)
;
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
SetupIds
(
)
{
SECStatus
rv
=
PK11_GenerateRandom
(
reinterpret_cast
<
unsigned
char
*
>
(
&
mSessionId
)
sizeof
(
mSessionId
)
)
;
mSessionId
=
mSessionId
>
>
1
;
if
(
rv
!
=
SECSuccess
)
{
JSEP_SET_ERROR
(
"
Failed
to
generate
session
id
:
"
<
<
rv
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
mUuidGen
-
>
Generate
(
&
mDefaultRemoteStreamId
)
)
{
JSEP_SET_ERROR
(
"
Failed
to
generate
default
uuid
for
streams
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
mUuidGen
-
>
Generate
(
&
mCNAME
)
)
{
JSEP_SET_ERROR
(
"
Failed
to
generate
CNAME
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
JsepSessionImpl
:
:
SetupDefaultCodecs
(
)
{
mSupportedCodecs
.
emplace_back
(
JsepAudioCodecDescription
:
:
CreateDefaultOpus
(
)
)
;
mSupportedCodecs
.
emplace_back
(
JsepAudioCodecDescription
:
:
CreateDefaultG722
(
)
)
;
mSupportedCodecs
.
emplace_back
(
JsepAudioCodecDescription
:
:
CreateDefaultPCMU
(
)
)
;
mSupportedCodecs
.
emplace_back
(
JsepAudioCodecDescription
:
:
CreateDefaultPCMA
(
)
)
;
mSupportedCodecs
.
emplace_back
(
JsepAudioCodecDescription
:
:
CreateDefaultTelephoneEvent
(
)
)
;
bool
useRtx
=
mRtxIsAllowed
&
&
Preferences
:
:
GetBool
(
"
media
.
peerconnection
.
video
.
use_rtx
"
false
)
;
mSupportedCodecs
.
emplace_back
(
JsepVideoCodecDescription
:
:
CreateDefaultVP8
(
useRtx
)
)
;
mSupportedCodecs
.
emplace_back
(
JsepVideoCodecDescription
:
:
CreateDefaultVP9
(
useRtx
)
)
;
mSupportedCodecs
.
emplace_back
(
JsepVideoCodecDescription
:
:
CreateDefaultH264_1
(
useRtx
)
)
;
mSupportedCodecs
.
emplace_back
(
JsepVideoCodecDescription
:
:
CreateDefaultH264_0
(
useRtx
)
)
;
mSupportedCodecs
.
emplace_back
(
JsepVideoCodecDescription
:
:
CreateDefaultUlpFec
(
)
)
;
mSupportedCodecs
.
emplace_back
(
JsepApplicationCodecDescription
:
:
CreateDefault
(
)
)
;
auto
red
=
JsepVideoCodecDescription
:
:
CreateDefaultRed
(
)
;
red
-
>
UpdateRedundantEncodings
(
mSupportedCodecs
)
;
mSupportedCodecs
.
push_back
(
std
:
:
move
(
red
)
)
;
nsCString
filteredCodecsPref
;
if
(
NS_OK
=
=
Preferences
:
:
GetCString
(
"
media
.
peerconnection
.
default_codecs
.
blocklist
"
filteredCodecsPref
)
)
{
for
(
const
auto
&
codecName
:
filteredCodecsPref
.
Split
(
'
'
)
)
{
nsCString
blocked
(
codecName
.
BeginReading
(
)
codecName
.
Length
(
)
)
;
blocked
.
StripWhitespace
(
)
;
mSupportedCodecs
.
erase
(
std
:
:
remove_if
(
mSupportedCodecs
.
begin
(
)
mSupportedCodecs
.
end
(
)
[
&
]
(
const
UniquePtr
<
JsepCodecDescription
>
&
codec
)
{
return
blocked
.
EqualsASCII
(
codec
-
>
mName
.
c_str
(
)
)
;
}
)
mSupportedCodecs
.
end
(
)
)
;
}
}
}
void
JsepSessionImpl
:
:
SetupDefaultRtpExtensions
(
)
{
AddAudioRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kAudioLevelUri
SdpDirectionAttribute
:
:
Direction
:
:
kSendrecv
)
;
AddAudioRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kCsrcAudioLevelUri
SdpDirectionAttribute
:
:
Direction
:
:
kRecvonly
)
;
AddAudioVideoRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kMidUri
SdpDirectionAttribute
:
:
Direction
:
:
kSendrecv
)
;
AddVideoRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kAbsSendTimeUri
SdpDirectionAttribute
:
:
Direction
:
:
kSendrecv
)
;
AddVideoRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kTimestampOffsetUri
SdpDirectionAttribute
:
:
Direction
:
:
kSendrecv
)
;
AddVideoRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kPlayoutDelayUri
SdpDirectionAttribute
:
:
Direction
:
:
kRecvonly
)
;
if
(
Preferences
:
:
GetBool
(
"
media
.
navigator
.
video
.
use_transport_cc
"
false
)
)
{
AddVideoRtpExtension
(
webrtc
:
:
RtpExtension
:
:
kTransportSequenceNumberUri
SdpDirectionAttribute
:
:
Direction
:
:
kSendrecv
)
;
}
}
void
JsepSessionImpl
:
:
SetState
(
JsepSignalingState
state
)
{
if
(
state
=
=
mState
)
return
;
MOZ_MTLOG
(
ML_NOTICE
"
[
"
<
<
mName
<
<
"
]
:
"
<
<
GetStateStr
(
mState
)
<
<
"
-
>
"
<
<
GetStateStr
(
state
)
)
;
mState
=
state
;
}
JsepSession
:
:
Result
JsepSessionImpl
:
:
AddRemoteIceCandidate
(
const
std
:
:
string
&
candidate
const
std
:
:
string
&
mid
const
Maybe
<
uint16_t
>
&
level
const
std
:
:
string
&
ufrag
std
:
:
string
*
transportId
)
{
mLastError
.
clear
(
)
;
if
(
!
mCurrentRemoteDescription
&
&
!
mPendingRemoteDescription
)
{
JSEP_SET_ERROR
(
"
Cannot
add
ICE
candidate
when
there
is
no
remote
SDP
"
)
;
return
dom
:
:
PCError
:
:
InvalidStateError
;
}
if
(
mid
.
empty
(
)
&
&
!
level
.
isSome
(
)
&
&
candidate
.
empty
(
)
)
{
if
(
mCurrentRemoteDescription
)
{
nsresult
rv
=
mSdpHelper
.
SetIceGatheringComplete
(
mCurrentRemoteDescription
.
get
(
)
ufrag
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
}
if
(
mPendingRemoteDescription
)
{
nsresult
rv
=
mSdpHelper
.
SetIceGatheringComplete
(
mPendingRemoteDescription
.
get
(
)
ufrag
)
;
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
}
return
Result
(
)
;
}
JsepTransceiver
*
transceiver
=
nullptr
;
if
(
!
mid
.
empty
(
)
)
{
transceiver
=
GetTransceiverForMid
(
mid
)
;
}
else
if
(
level
.
isSome
(
)
)
{
transceiver
=
GetTransceiverForLevel
(
level
.
value
(
)
)
;
}
if
(
!
transceiver
)
{
JSEP_SET_ERROR
(
"
Cannot
set
ICE
candidate
for
level
=
"
<
<
level
<
<
"
mid
=
"
<
<
mid
<
<
"
:
No
such
transceiver
.
"
)
;
return
dom
:
:
PCError
:
:
OperationError
;
}
if
(
level
.
isSome
(
)
&
&
transceiver
-
>
GetLevel
(
)
!
=
level
.
value
(
)
)
{
MOZ_MTLOG
(
ML_WARNING
"
Mismatch
between
mid
and
level
-
\
"
"
<
<
mid
<
<
"
\
"
is
not
the
mid
for
level
"
<
<
level
)
;
}
*
transportId
=
transceiver
-
>
mTransport
.
mTransportId
;
nsresult
rv
=
NS_ERROR_UNEXPECTED
;
if
(
mCurrentRemoteDescription
)
{
rv
=
mSdpHelper
.
AddCandidateToSdp
(
mCurrentRemoteDescription
.
get
(
)
candidate
transceiver
-
>
GetLevel
(
)
ufrag
)
;
}
if
(
mPendingRemoteDescription
)
{
rv
=
mSdpHelper
.
AddCandidateToSdp
(
mPendingRemoteDescription
.
get
(
)
candidate
transceiver
-
>
GetLevel
(
)
ufrag
)
;
}
NS_ENSURE_SUCCESS
(
rv
dom
:
:
PCError
:
:
OperationError
)
;
return
Result
(
)
;
}
nsresult
JsepSessionImpl
:
:
AddLocalIceCandidate
(
const
std
:
:
string
&
candidate
const
std
:
:
string
&
transportId
const
std
:
:
string
&
ufrag
uint16_t
*
level
std
:
:
string
*
mid
bool
*
skipped
)
{
mLastError
.
clear
(
)
;
*
skipped
=
true
;
if
(
!
mCurrentLocalDescription
&
&
!
mPendingLocalDescription
)
{
JSEP_SET_ERROR
(
"
Cannot
add
ICE
candidate
when
there
is
no
local
SDP
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
JsepTransceiver
*
transceiver
=
GetTransceiverWithTransport
(
transportId
)
;
if
(
!
transceiver
|
|
!
transceiver
-
>
IsAssociated
(
)
)
{
return
NS_OK
;
}
*
level
=
transceiver
-
>
GetLevel
(
)
;
*
mid
=
transceiver
-
>
GetMid
(
)
;
nsresult
rv
=
NS_ERROR_INVALID_ARG
;
if
(
mCurrentLocalDescription
)
{
rv
=
mSdpHelper
.
AddCandidateToSdp
(
mCurrentLocalDescription
.
get
(
)
candidate
*
level
ufrag
)
;
}
if
(
mPendingLocalDescription
)
{
rv
=
mSdpHelper
.
AddCandidateToSdp
(
mPendingLocalDescription
.
get
(
)
candidate
*
level
ufrag
)
;
}
*
skipped
=
false
;
return
rv
;
}
nsresult
JsepSessionImpl
:
:
UpdateDefaultCandidate
(
const
std
:
:
string
&
defaultCandidateAddr
uint16_t
defaultCandidatePort
const
std
:
:
string
&
defaultRtcpCandidateAddr
uint16_t
defaultRtcpCandidatePort
const
std
:
:
string
&
transportId
)
{
mLastError
.
clear
(
)
;
mozilla
:
:
Sdp
*
sdp
=
GetParsedLocalDescription
(
kJsepDescriptionPendingOrCurrent
)
;
if
(
!
sdp
)
{
JSEP_SET_ERROR
(
"
Cannot
add
ICE
candidate
in
state
"
<
<
GetStateStr
(
mState
)
)
;
return
NS_ERROR_UNEXPECTED
;
}
for
(
const
auto
&
transceiver
:
mTransceivers
)
{
if
(
transceiver
-
>
mTransport
.
mTransportId
=
=
transportId
)
{
MOZ_ASSERT
(
transceiver
-
>
HasLevel
(
)
"
Transceiver
has
a
transport
but
no
level
!
"
"
This
should
never
happen
.
"
)
;
std
:
:
string
defaultRtcpCandidateAddrCopy
(
defaultRtcpCandidateAddr
)
;
if
(
mState
=
=
kJsepStateStable
)
{
if
(
transceiver
-
>
mTransport
.
mComponents
=
=
1
)
{
defaultRtcpCandidateAddrCopy
=
"
"
;
defaultRtcpCandidatePort
=
0
;
}
}
size_t
level
=
transceiver
-
>
GetLevel
(
)
;
if
(
level
>
=
sdp
-
>
GetMediaSectionCount
(
)
)
{
MOZ_ASSERT
(
false
"
Transceiver
'
s
level
is
too
large
!
"
)
;
JSEP_SET_ERROR
(
"
Transceiver
'
s
level
is
too
large
!
"
)
;
return
NS_ERROR_FAILURE
;
}
auto
&
msection
=
sdp
-
>
GetMediaSection
(
level
)
;
if
(
!
msection
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kBundleOnlyAttribute
)
)
{
mSdpHelper
.
SetDefaultAddresses
(
defaultCandidateAddr
defaultCandidatePort
defaultRtcpCandidateAddrCopy
defaultRtcpCandidatePort
&
msection
)
;
}
}
}
return
NS_OK
;
}
nsresult
JsepSessionImpl
:
:
GetNegotiatedBundledMids
(
SdpHelper
:
:
BundledMids
*
bundledMids
)
{
const
Sdp
*
answerSdp
=
GetAnswer
(
)
;
if
(
!
answerSdp
)
{
return
NS_OK
;
}
return
mSdpHelper
.
GetBundledMids
(
*
answerSdp
bundledMids
)
;
}
mozilla
:
:
Sdp
*
JsepSessionImpl
:
:
GetParsedLocalDescription
(
JsepDescriptionPendingOrCurrent
type
)
const
{
if
(
type
=
=
kJsepDescriptionPending
)
{
return
mPendingLocalDescription
.
get
(
)
;
}
else
if
(
mPendingLocalDescription
&
&
type
=
=
kJsepDescriptionPendingOrCurrent
)
{
return
mPendingLocalDescription
.
get
(
)
;
}
return
mCurrentLocalDescription
.
get
(
)
;
}
mozilla
:
:
Sdp
*
JsepSessionImpl
:
:
GetParsedRemoteDescription
(
JsepDescriptionPendingOrCurrent
type
)
const
{
if
(
type
=
=
kJsepDescriptionPending
)
{
return
mPendingRemoteDescription
.
get
(
)
;
}
else
if
(
mPendingRemoteDescription
&
&
type
=
=
kJsepDescriptionPendingOrCurrent
)
{
return
mPendingRemoteDescription
.
get
(
)
;
}
return
mCurrentRemoteDescription
.
get
(
)
;
}
const
Sdp
*
JsepSessionImpl
:
:
GetAnswer
(
)
const
{
return
(
mIsCurrentOfferer
.
isSome
(
)
&
&
*
mIsCurrentOfferer
)
?
mCurrentRemoteDescription
.
get
(
)
:
mCurrentLocalDescription
.
get
(
)
;
}
void
JsepSessionImpl
:
:
SetIceRestarting
(
bool
restarting
)
{
if
(
restarting
)
{
if
(
!
IsIceRestarting
(
)
)
{
mOldIceUfrag
=
mIceUfrag
;
mOldIcePwd
=
mIcePwd
;
}
mIceUfrag
=
GetRandomHex
(
1
)
;
mIcePwd
=
GetRandomHex
(
4
)
;
}
else
if
(
IsIceRestarting
(
)
)
{
mIceUfrag
=
mOldIceUfrag
;
mIcePwd
=
mOldIcePwd
;
mOldIceUfrag
.
clear
(
)
;
mOldIcePwd
.
clear
(
)
;
}
}
nsresult
JsepSessionImpl
:
:
Close
(
)
{
mLastError
.
clear
(
)
;
SetState
(
kJsepStateClosed
)
;
return
NS_OK
;
}
const
std
:
:
string
JsepSessionImpl
:
:
GetLastError
(
)
const
{
return
mLastError
;
}
const
std
:
:
vector
<
std
:
:
pair
<
size_t
std
:
:
string
>
>
&
JsepSessionImpl
:
:
GetLastSdpParsingErrors
(
)
const
{
return
mLastSdpParsingErrors
;
}
bool
JsepSessionImpl
:
:
CheckNegotiationNeeded
(
)
const
{
MOZ_ASSERT
(
mState
=
=
kJsepStateStable
)
;
for
(
const
auto
&
transceiver
:
mTransceivers
)
{
if
(
transceiver
-
>
IsStopped
(
)
)
{
if
(
transceiver
-
>
IsAssociated
(
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
Negotiation
needed
because
of
"
"
stopped
transceiver
that
still
has
a
mid
.
"
)
;
return
true
;
}
continue
;
}
if
(
!
transceiver
-
>
IsAssociated
(
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
Negotiation
needed
because
of
"
"
unassociated
(
but
not
stopped
)
transceiver
.
"
)
;
return
true
;
}
if
(
!
mCurrentLocalDescription
|
|
!
mCurrentRemoteDescription
)
{
MOZ_CRASH
(
"
Transceivers
should
not
be
associated
if
we
'
re
in
stable
"
"
before
the
first
negotiation
.
"
)
;
continue
;
}
if
(
!
transceiver
-
>
HasLevel
(
)
)
{
MOZ_CRASH
(
"
Associated
transceivers
should
always
have
a
level
.
"
)
;
continue
;
}
if
(
transceiver
-
>
GetMediaType
(
)
=
=
SdpMediaSection
:
:
kApplication
)
{
continue
;
}
size_t
level
=
transceiver
-
>
GetLevel
(
)
;
if
(
NS_WARN_IF
(
mCurrentLocalDescription
-
>
GetMediaSectionCount
(
)
<
=
level
)
|
|
NS_WARN_IF
(
mCurrentRemoteDescription
-
>
GetMediaSectionCount
(
)
<
=
level
)
)
{
MOZ_ASSERT
(
false
)
;
continue
;
}
const
SdpMediaSection
&
local
=
mCurrentLocalDescription
-
>
GetMediaSection
(
level
)
;
const
SdpMediaSection
&
remote
=
mCurrentRemoteDescription
-
>
GetMediaSection
(
level
)
;
if
(
!
local
.
GetAttributeList
(
)
.
HasAttribute
(
SdpAttribute
:
:
kMsidAttribute
)
&
&
(
transceiver
-
>
mJsDirection
&
sdp
:
:
kSend
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
Negotiation
needed
because
of
"
"
lack
of
a
=
msid
and
transceiver
is
sending
.
"
)
;
return
true
;
}
if
(
mIsCurrentOfferer
.
isSome
(
)
&
&
*
mIsCurrentOfferer
)
{
if
(
(
local
.
GetDirection
(
)
!
=
transceiver
-
>
mJsDirection
)
&
&
reverse
(
remote
.
GetDirection
(
)
)
!
=
transceiver
-
>
mJsDirection
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
Negotiation
needed
because
"
"
the
direction
on
our
offer
and
the
remote
"
"
answer
does
not
"
"
match
the
direction
on
a
transceiver
.
"
)
;
return
true
;
}
}
else
if
(
local
.
GetDirection
(
)
!
=
(
transceiver
-
>
mJsDirection
&
reverse
(
remote
.
GetDirection
(
)
)
)
)
{
MOZ_MTLOG
(
ML_DEBUG
"
[
"
<
<
mName
<
<
"
]
:
Negotiation
needed
because
"
"
the
direction
on
our
answer
doesn
'
t
match
the
direction
on
a
"
"
transceiver
even
though
the
remote
offer
would
have
allowed
"
"
it
.
"
)
;
return
true
;
}
}
return
false
;
}
}
