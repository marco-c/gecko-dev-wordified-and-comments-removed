#
ifndef
nr_socket_tcp_h__
#
define
nr_socket_tcp_h__
#
include
<
list
>
#
include
"
mozilla
/
net
/
WebrtcTCPSocketCallback
.
h
"
#
include
"
nsTArray
.
h
"
extern
"
C
"
{
#
include
"
nr_api
.
h
"
#
include
"
nr_socket
.
h
"
#
include
"
transport_addr
.
h
"
}
#
include
"
nr_socket_prsock
.
h
"
namespace
mozilla
{
using
namespace
net
;
namespace
net
{
class
WebrtcTCPSocketWrapper
;
}
class
NrTcpSocketData
;
class
NrSocketProxyConfig
;
class
NrTcpSocket
:
public
NrSocketBase
public
WebrtcTCPSocketCallback
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
NrTcpSocket
override
)
explicit
NrTcpSocket
(
const
std
:
:
shared_ptr
<
NrSocketProxyConfig
>
&
aConfig
)
;
int
create
(
nr_transport_addr
*
aAddr
)
override
;
int
connect
(
const
nr_transport_addr
*
aAddr
)
override
;
void
close
(
)
override
;
int
write
(
const
void
*
aBuffer
size_t
aCount
size_t
*
aWrote
)
override
;
int
read
(
void
*
aBuffer
size_t
aCount
size_t
*
aRead
)
override
;
int
getaddr
(
nr_transport_addr
*
aAddr
)
override
;
int
sendto
(
const
void
*
aBuffer
size_t
aCount
int
aFlags
const
nr_transport_addr
*
aAddr
)
override
;
int
recvfrom
(
void
*
aBuffer
size_t
aCount
size_t
*
aRead
int
aFlags
nr_transport_addr
*
aAddr
)
override
;
int
listen
(
int
aBacklog
)
override
;
int
accept
(
nr_transport_addr
*
aAddr
nr_socket
*
*
aSocket
)
override
;
void
OnClose
(
nsresult
aReason
)
override
;
void
OnConnected
(
const
nsACString
&
aProxyType
)
override
;
void
OnRead
(
nsTArray
<
uint8_t
>
&
&
aReadData
)
override
;
size_t
CountUnreadBytes
(
)
const
;
void
AssignChannel_DoNotUse
(
WebrtcTCPSocketWrapper
*
aWrapper
)
;
protected
:
virtual
~
NrTcpSocket
(
)
;
private
:
void
DoCallbacks
(
)
;
bool
mClosed
;
size_t
mReadOffset
;
std
:
:
list
<
NrTcpSocketData
>
mReadQueue
;
std
:
:
shared_ptr
<
NrSocketProxyConfig
>
mConfig
;
RefPtr
<
WebrtcTCPSocketWrapper
>
mWebrtcTCPSocket
;
}
;
}
#
endif
