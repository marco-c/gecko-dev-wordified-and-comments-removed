#
ifndef
WIN32
#
include
<
sys
/
uio
.
h
>
#
include
<
pwd
.
h
>
#
include
<
dirent
.
h
>
#
endif
#
include
<
string
.
h
>
#
include
<
errno
.
h
>
#
include
<
ctype
.
h
>
#
include
<
sys
/
stat
.
h
>
#
ifdef
OPENSSL
#
include
<
openssl
/
evp
.
h
>
#
endif
#
include
"
nr_common
.
h
"
#
include
"
r_common
.
h
"
#
include
"
registry
.
h
"
#
include
"
util
.
h
"
#
include
"
r_log
.
h
"
int
nr_util_default_log_facility
=
LOG_COMMON
;
int
nr_bin2hex
(
UCHAR
*
in
int
len
UCHAR
*
out
)
{
while
(
len
)
{
sprintf
(
(
char
*
)
out
"
%
.
2x
"
in
[
0
]
&
0xff
)
;
in
+
=
1
;
out
+
=
2
;
len
-
-
;
}
return
(
0
)
;
}
#
if
defined
(
LINUX
)
|
|
defined
(
WIN32
)
size_t
strlcat
(
char
*
dst
const
char
*
src
size_t
siz
)
{
char
*
d
=
dst
;
const
char
*
s
=
src
;
size_t
n
=
siz
;
size_t
dlen
;
while
(
n
-
-
!
=
0
&
&
*
d
!
=
'
\
0
'
)
d
+
+
;
dlen
=
d
-
dst
;
n
=
siz
-
dlen
;
if
(
n
=
=
0
)
return
(
dlen
+
strlen
(
s
)
)
;
while
(
*
s
!
=
'
\
0
'
)
{
if
(
n
!
=
1
)
{
*
d
+
+
=
*
s
;
n
-
-
;
}
s
+
+
;
}
*
d
=
'
\
0
'
;
return
(
dlen
+
(
s
-
src
)
)
;
}
#
endif
#
if
defined
(
USE_OWN_INET_NTOP
)
#
include
<
errno
.
h
>
#
ifdef
WIN32
#
include
<
Ws2ipdef
.
h
>
#
ifndef
EAFNOSUPPORT
#
define
EAFNOSUPPORT
WSAEAFNOSUPPORT
#
endif
#
else
#
include
<
sys
/
socket
.
h
>
#
endif
#
define
INET6
#
if
!
defined
(
NS_INADDRSZ
)
#
define
NS_INADDRSZ
4
#
endif
#
if
!
defined
(
NS_IN6ADDRSZ
)
#
define
NS_IN6ADDRSZ
16
#
endif
#
if
!
defined
(
NS_INT16SZ
)
#
define
NS_INT16SZ
2
#
endif
static
const
char
*
inet_ntop4
(
const
unsigned
char
*
src
char
*
dst
size_t
size
)
;
#
ifdef
INET6
static
const
char
*
inet_ntop6
(
const
unsigned
char
*
src
char
*
dst
size_t
size
)
;
#
endif
const
char
*
inet_ntop
(
int
af
const
void
*
src
char
*
dst
size_t
size
)
{
switch
(
af
)
{
case
AF_INET
:
return
(
inet_ntop4
(
src
dst
size
)
)
;
#
ifdef
INET6
case
AF_INET6
:
return
(
inet_ntop6
(
src
dst
size
)
)
;
#
endif
default
:
errno
=
EAFNOSUPPORT
;
return
(
NULL
)
;
}
}
static
const
char
*
inet_ntop4
(
const
unsigned
char
*
src
char
*
dst
size_t
size
)
{
char
tmp
[
sizeof
"
255
.
255
.
255
.
255
"
]
;
int
l
;
l
=
snprintf
(
tmp
sizeof
(
tmp
)
"
%
u
.
%
u
.
%
u
.
%
u
"
src
[
0
]
src
[
1
]
src
[
2
]
src
[
3
]
)
;
if
(
l
<
=
0
|
|
(
size_t
)
l
>
=
size
)
{
errno
=
ENOSPC
;
return
(
NULL
)
;
}
strlcpy
(
dst
tmp
size
)
;
return
(
dst
)
;
}
#
ifdef
INET6
static
const
char
*
inet_ntop6
(
const
unsigned
char
*
src
char
*
dst
size_t
size
)
{
char
tmp
[
sizeof
"
ffff
:
ffff
:
ffff
:
ffff
:
ffff
:
ffff
:
255
.
255
.
255
.
255
"
]
;
char
*
tp
=
0
*
ep
=
0
;
struct
{
int
base
len
;
}
best
cur
;
unsigned
int
words
[
NS_IN6ADDRSZ
/
NS_INT16SZ
]
;
int
i
;
int
advance
;
memset
(
words
'
\
0
'
sizeof
words
)
;
for
(
i
=
0
;
i
<
NS_IN6ADDRSZ
;
i
+
+
)
words
[
i
/
2
]
|
=
(
src
[
i
]
<
<
(
(
1
-
(
i
%
2
)
)
<
<
3
)
)
;
best
.
base
=
-
1
;
cur
.
base
=
-
1
;
best
.
len
=
-
1
;
cur
.
len
=
-
1
;
for
(
i
=
0
;
i
<
(
NS_IN6ADDRSZ
/
NS_INT16SZ
)
;
i
+
+
)
{
if
(
words
[
i
]
=
=
0
)
{
if
(
cur
.
base
=
=
-
1
)
cur
.
base
=
i
cur
.
len
=
1
;
else
cur
.
len
+
+
;
}
else
{
if
(
cur
.
base
!
=
-
1
)
{
if
(
best
.
base
=
=
-
1
|
|
cur
.
len
>
best
.
len
)
best
=
cur
;
cur
.
base
=
-
1
;
}
}
}
if
(
cur
.
base
!
=
-
1
)
{
if
(
best
.
base
=
=
-
1
|
|
cur
.
len
>
best
.
len
)
best
=
cur
;
}
if
(
best
.
base
!
=
-
1
&
&
best
.
len
<
2
)
best
.
base
=
-
1
;
tp
=
tmp
;
ep
=
tmp
+
sizeof
(
tmp
)
;
for
(
i
=
0
;
i
<
(
NS_IN6ADDRSZ
/
NS_INT16SZ
)
;
i
+
+
)
{
if
(
best
.
base
!
=
-
1
&
&
i
>
=
best
.
base
&
&
i
<
(
best
.
base
+
best
.
len
)
)
{
if
(
i
=
=
best
.
base
)
*
tp
+
+
=
'
:
'
;
continue
;
}
if
(
i
!
=
0
)
{
if
(
tp
+
1
>
=
ep
)
return
(
NULL
)
;
*
tp
+
+
=
'
:
'
;
}
if
(
i
=
=
6
&
&
best
.
base
=
=
0
&
&
(
best
.
len
=
=
6
|
|
(
best
.
len
=
=
7
&
&
words
[
7
]
!
=
0x0001
)
|
|
(
best
.
len
=
=
5
&
&
words
[
5
]
=
=
0xffff
)
)
)
{
if
(
!
inet_ntop4
(
src
+
12
tp
(
size_t
)
(
ep
-
tp
)
)
)
return
(
NULL
)
;
tp
+
=
strlen
(
tp
)
;
break
;
}
advance
=
snprintf
(
tp
(
size_t
)
(
ep
-
tp
)
"
%
x
"
words
[
i
]
)
;
if
(
advance
<
=
0
|
|
advance
>
=
ep
-
tp
)
return
(
NULL
)
;
tp
+
=
advance
;
}
if
(
best
.
base
!
=
-
1
&
&
(
best
.
base
+
best
.
len
)
=
=
(
NS_IN6ADDRSZ
/
NS_INT16SZ
)
)
{
if
(
tp
+
1
>
=
ep
)
return
(
NULL
)
;
*
tp
+
+
=
'
:
'
;
}
if
(
tp
+
1
>
=
ep
)
return
(
NULL
)
;
*
tp
+
+
=
'
\
0
'
;
if
(
(
size_t
)
(
tp
-
tmp
)
>
size
)
{
errno
=
ENOSPC
;
return
(
NULL
)
;
}
strlcpy
(
dst
tmp
size
)
;
return
(
dst
)
;
}
#
endif
#
ifdef
WIN32
int
inet_pton
(
int
af
const
char
*
src
void
*
dst
)
{
struct
sockaddr_storage
ss
;
int
addrlen
=
sizeof
(
ss
)
;
if
(
af
!
=
AF_INET
&
&
af
!
=
AF_INET6
)
{
return
-
1
;
}
if
(
!
WSAStringToAddressA
(
src
af
NULL
(
struct
sockaddr
*
)
&
ss
&
addrlen
)
)
{
if
(
af
=
=
AF_INET
)
{
struct
sockaddr_in
*
in
=
(
struct
sockaddr_in
*
)
&
ss
;
memcpy
(
dst
&
in
-
>
sin_addr
sizeof
(
struct
in_addr
)
)
;
}
else
{
struct
sockaddr_in6
*
in6
=
(
struct
sockaddr_in6
*
)
&
ss
;
memcpy
(
dst
&
in6
-
>
sin6_addr
sizeof
(
struct
in6_addr
)
)
;
}
return
1
;
}
return
0
;
}
#
endif
#
endif
#
ifdef
WIN32
#
include
<
time
.
h
>
int
gettimeofday
(
struct
timeval
*
tv
void
*
tz
)
{
SYSTEMTIME
st
;
FILETIME
ft
;
ULARGE_INTEGER
u
;
GetLocalTime
(
&
st
)
;
SystemTimeToFileTime
(
&
st
&
ft
)
;
u
.
HighPart
=
ft
.
dwHighDateTime
;
u
.
LowPart
=
ft
.
dwLowDateTime
;
tv
-
>
tv_sec
=
(
long
)
(
u
.
QuadPart
/
10000000L
)
;
tv
-
>
tv_usec
=
(
long
)
(
st
.
wMilliseconds
*
1000
)
;
;
return
0
;
}
#
endif
