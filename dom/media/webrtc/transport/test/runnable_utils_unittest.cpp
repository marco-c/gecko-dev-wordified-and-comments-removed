#
include
<
iostream
>
#
include
"
prio
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsASocketHandler
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
runnable_utils
.
h
"
#
define
GTEST_HAS_RTTI
0
#
include
"
gtest
/
gtest
.
h
"
#
include
"
gtest_utils
.
h
"
using
namespace
mozilla
;
namespace
{
struct
CtorDtorState
{
enum
class
State
{
Empty
Copy
Explicit
Move
Moved
}
;
static
const
char
*
ToStr
(
const
State
&
state
)
{
switch
(
state
)
{
case
State
:
:
Empty
:
return
"
empty
"
;
case
State
:
:
Copy
:
return
"
copy
"
;
case
State
:
:
Explicit
:
return
"
explicit
"
;
case
State
:
:
Move
:
return
"
move
"
;
case
State
:
:
Moved
:
return
"
moved
"
;
default
:
return
"
unknown
"
;
}
}
void
DumpState
(
)
const
{
std
:
:
cerr
<
<
ToStr
(
state_
)
<
<
std
:
:
endl
;
}
CtorDtorState
(
)
{
DumpState
(
)
;
}
explicit
CtorDtorState
(
int
*
destroyed
)
:
dtor_count_
(
destroyed
)
state_
(
State
:
:
Explicit
)
{
DumpState
(
)
;
}
CtorDtorState
(
const
CtorDtorState
&
other
)
:
dtor_count_
(
other
.
dtor_count_
)
state_
(
State
:
:
Copy
)
{
DumpState
(
)
;
}
CtorDtorState
(
CtorDtorState
&
&
other
)
:
dtor_count_
(
std
:
:
exchange
(
other
.
dtor_count_
nullptr
)
)
state_
(
State
:
:
Move
)
{
other
.
state_
=
State
:
:
Moved
;
DumpState
(
)
;
}
~
CtorDtorState
(
)
{
const
char
*
const
state
=
ToStr
(
state_
)
;
std
:
:
cerr
<
<
"
Destructor
called
with
end
state
:
"
<
<
state
<
<
std
:
:
endl
;
if
(
dtor_count_
)
{
+
+
*
dtor_count_
;
}
}
int
*
dtor_count_
=
nullptr
;
State
state_
=
State
:
:
Empty
;
}
;
class
Destructor
{
private
:
~
Destructor
(
)
{
std
:
:
cerr
<
<
"
Destructor
called
"
<
<
std
:
:
endl
;
*
destroyed_
=
true
;
}
public
:
explicit
Destructor
(
bool
*
destroyed
)
:
destroyed_
(
destroyed
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Destructor
)
private
:
bool
*
destroyed_
;
}
;
class
TargetClass
{
public
:
explicit
TargetClass
(
int
*
ran
)
:
ran_
(
ran
)
{
}
void
m1
(
int
x
)
{
std
:
:
cerr
<
<
__FUNCTION__
<
<
"
"
<
<
x
<
<
std
:
:
endl
;
*
ran_
=
1
;
}
void
m2
(
int
x
int
y
)
{
std
:
:
cerr
<
<
__FUNCTION__
<
<
"
"
<
<
x
<
<
"
"
<
<
y
<
<
std
:
:
endl
;
*
ran_
=
2
;
}
void
m1set
(
bool
*
z
)
{
std
:
:
cerr
<
<
__FUNCTION__
<
<
std
:
:
endl
;
*
z
=
true
;
}
int
return_int
(
int
x
)
{
std
:
:
cerr
<
<
__FUNCTION__
<
<
std
:
:
endl
;
return
x
;
}
void
destructor_target_ref
(
RefPtr
<
Destructor
>
destructor
)
{
}
int
*
ran_
;
}
;
class
RunnableArgsTest
:
public
MtransportTest
{
public
:
RunnableArgsTest
(
)
:
MtransportTest
(
)
ran_
(
0
)
cl_
(
&
ran_
)
{
}
void
Test1Arg
(
)
{
Runnable
*
r
=
WrapRunnable
(
&
cl_
&
TargetClass
:
:
m1
1
)
;
r
-
>
Run
(
)
;
ASSERT_EQ
(
1
ran_
)
;
}
void
Test2Args
(
)
{
Runnable
*
r
=
WrapRunnable
(
&
cl_
&
TargetClass
:
:
m2
1
2
)
;
r
-
>
Run
(
)
;
ASSERT_EQ
(
2
ran_
)
;
}
private
:
int
ran_
;
TargetClass
cl_
;
}
;
class
DispatchTest
:
public
MtransportTest
{
public
:
DispatchTest
(
)
:
MtransportTest
(
)
ran_
(
0
)
cl_
(
&
ran_
)
{
}
void
SetUp
(
)
{
MtransportTest
:
:
SetUp
(
)
;
nsresult
rv
;
target_
=
do_GetService
(
NS_SOCKETTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
}
void
Test1Arg
(
)
{
Runnable
*
r
=
WrapRunnable
(
&
cl_
&
TargetClass
:
:
m1
1
)
;
target_
-
>
Dispatch
(
r
NS_DISPATCH_SYNC
)
;
ASSERT_EQ
(
1
ran_
)
;
}
void
Test2Args
(
)
{
Runnable
*
r
=
WrapRunnable
(
&
cl_
&
TargetClass
:
:
m2
1
2
)
;
target_
-
>
Dispatch
(
r
NS_DISPATCH_SYNC
)
;
ASSERT_EQ
(
2
ran_
)
;
}
void
Test1Set
(
)
{
bool
x
=
false
;
target_
-
>
Dispatch
(
WrapRunnable
(
&
cl_
&
TargetClass
:
:
m1set
&
x
)
NS_DISPATCH_SYNC
)
;
ASSERT_TRUE
(
x
)
;
}
void
TestRet
(
)
{
int
z
;
int
x
=
10
;
target_
-
>
Dispatch
(
WrapRunnableRet
(
&
z
&
cl_
&
TargetClass
:
:
return_int
x
)
NS_DISPATCH_SYNC
)
;
ASSERT_EQ
(
10
z
)
;
}
protected
:
int
ran_
;
TargetClass
cl_
;
nsCOMPtr
<
nsIEventTarget
>
target_
;
}
;
TEST_F
(
RunnableArgsTest
OneArgument
)
{
Test1Arg
(
)
;
}
TEST_F
(
RunnableArgsTest
TwoArguments
)
{
Test2Args
(
)
;
}
TEST_F
(
DispatchTest
OneArgument
)
{
Test1Arg
(
)
;
}
TEST_F
(
DispatchTest
TwoArguments
)
{
Test2Args
(
)
;
}
TEST_F
(
DispatchTest
Test1Set
)
{
Test1Set
(
)
;
}
TEST_F
(
DispatchTest
TestRet
)
{
TestRet
(
)
;
}
void
SetNonMethod
(
TargetClass
*
cl
int
x
)
{
cl
-
>
m1
(
x
)
;
}
int
SetNonMethodRet
(
TargetClass
*
cl
int
x
)
{
cl
-
>
m1
(
x
)
;
return
x
;
}
TEST_F
(
DispatchTest
TestNonMethod
)
{
test_utils_
-
>
sts_target
(
)
-
>
Dispatch
(
WrapRunnableNM
(
SetNonMethod
&
cl_
10
)
NS_DISPATCH_SYNC
)
;
ASSERT_EQ
(
1
ran_
)
;
}
TEST_F
(
DispatchTest
TestNonMethodRet
)
{
int
z
;
test_utils_
-
>
sts_target
(
)
-
>
Dispatch
(
WrapRunnableNMRet
(
&
z
SetNonMethodRet
&
cl_
10
)
NS_DISPATCH_SYNC
)
;
ASSERT_EQ
(
1
ran_
)
;
ASSERT_EQ
(
10
z
)
;
}
TEST_F
(
DispatchTest
TestDestructorRef
)
{
bool
destroyed
=
false
;
{
RefPtr
<
Destructor
>
destructor
=
new
Destructor
(
&
destroyed
)
;
target_
-
>
Dispatch
(
WrapRunnable
(
&
cl_
&
TargetClass
:
:
destructor_target_ref
destructor
)
NS_DISPATCH_SYNC
)
;
ASSERT_FALSE
(
destroyed
)
;
}
ASSERT_TRUE
(
destroyed
)
;
destroyed
=
false
;
{
RefPtr
<
Destructor
>
destructor
=
new
Destructor
(
&
destroyed
)
;
target_
-
>
Dispatch
(
WrapRunnable
(
&
cl_
&
TargetClass
:
:
destructor_target_ref
std
:
:
move
(
destructor
)
)
NS_DISPATCH_SYNC
)
;
ASSERT_TRUE
(
destroyed
)
;
}
}
TEST_F
(
DispatchTest
TestMove
)
{
int
destroyed
=
0
;
{
CtorDtorState
state
(
&
destroyed
)
;
target_
-
>
Dispatch
(
WrapRunnableNM
(
[
]
(
CtorDtorState
s
)
{
}
std
:
:
move
(
state
)
)
NS_DISPATCH_SYNC
)
;
ASSERT_EQ
(
1
destroyed
)
;
}
ASSERT_EQ
(
1
destroyed
)
;
{
CtorDtorState
state
(
&
destroyed
)
;
target_
-
>
Dispatch
(
WrapRunnableNM
(
[
]
(
CtorDtorState
s
)
{
}
state
)
NS_DISPATCH_SYNC
)
;
ASSERT_EQ
(
2
destroyed
)
;
}
ASSERT_EQ
(
3
destroyed
)
;
{
CtorDtorState
state
(
&
destroyed
)
;
target_
-
>
Dispatch
(
WrapRunnableNM
(
[
]
(
const
CtorDtorState
&
s
)
{
}
std
:
:
move
(
state
)
)
NS_DISPATCH_SYNC
)
;
ASSERT_EQ
(
4
destroyed
)
;
}
ASSERT_EQ
(
4
destroyed
)
;
{
CtorDtorState
state
(
&
destroyed
)
;
target_
-
>
Dispatch
(
WrapRunnableNM
(
[
]
(
CtorDtorState
&
&
s
)
{
}
std
:
:
move
(
state
)
)
NS_DISPATCH_SYNC
)
;
ASSERT_EQ
(
5
destroyed
)
;
}
ASSERT_EQ
(
5
destroyed
)
;
}
TEST_F
(
DispatchTest
TestUniquePtr
)
{
int
ran
=
0
;
auto
cl
=
MakeUnique
<
TargetClass
>
(
&
ran
)
;
target_
-
>
Dispatch
(
WrapRunnable
(
std
:
:
move
(
cl
)
&
TargetClass
:
:
m1
1
)
NS_DISPATCH_SYNC
)
;
ASSERT_EQ
(
1
ran
)
;
int
destroyed
=
0
;
{
auto
state
=
MakeUnique
<
CtorDtorState
>
(
&
destroyed
)
;
target_
-
>
Dispatch
(
WrapRunnableNM
(
[
]
(
UniquePtr
<
CtorDtorState
>
s
)
{
}
std
:
:
move
(
state
)
)
NS_DISPATCH_SYNC
)
;
ASSERT_EQ
(
1
destroyed
)
;
}
ASSERT_EQ
(
1
destroyed
)
;
}
}
