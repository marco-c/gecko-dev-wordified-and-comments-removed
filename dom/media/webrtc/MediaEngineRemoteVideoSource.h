#
ifndef
MEDIAENGINE_REMOTE_VIDEO_SOURCE_H_
#
define
MEDIAENGINE_REMOTE_VIDEO_SOURCE_H_
#
include
"
prcvar
.
h
"
#
include
"
prthread
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
DOMMediaStream
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
ipc
/
IPCMessageUtils
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
MediaEngineSource
.
h
"
#
include
"
VideoSegment
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
StreamTracks
.
h
"
#
include
"
MediaStreamGraph
.
h
"
#
include
"
MediaEngineWrapper
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamTrackBinding
.
h
"
#
include
"
CamerasChild
.
h
"
#
include
"
NullTransport
.
h
"
#
include
"
webrtc
/
common_video
/
include
/
i420_buffer_pool
.
h
"
#
include
"
webrtc
/
modules
/
video_capture
/
video_capture_defines
.
h
"
namespace
webrtc
{
using
CaptureCapability
=
VideoCaptureCapability
;
}
namespace
mozilla
{
enum
DistanceCalculation
{
kFitness
kFeasibility
}
;
class
MediaEngineRemoteVideoSource
:
public
MediaEngineSource
public
camera
:
:
FrameRelay
{
~
MediaEngineRemoteVideoSource
(
)
=
default
;
struct
CapabilityCandidate
{
explicit
CapabilityCandidate
(
webrtc
:
:
CaptureCapability
&
&
aCapability
uint32_t
aDistance
=
0
)
:
mCapability
(
Forward
<
webrtc
:
:
CaptureCapability
>
(
aCapability
)
)
mDistance
(
aDistance
)
{
}
const
webrtc
:
:
CaptureCapability
mCapability
;
uint32_t
mDistance
;
}
;
class
CapabilityComparator
{
public
:
bool
Equals
(
const
CapabilityCandidate
&
aCandidate
const
webrtc
:
:
CaptureCapability
&
aCapability
)
const
{
return
aCandidate
.
mCapability
=
=
aCapability
;
}
}
;
bool
ChooseCapability
(
const
NormalizedConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
webrtc
:
:
CaptureCapability
&
aCapability
const
DistanceCalculation
aCalculate
)
;
uint32_t
GetDistance
(
const
webrtc
:
:
CaptureCapability
&
aCandidate
const
NormalizedConstraintSet
&
aConstraints
const
nsString
&
aDeviceId
const
DistanceCalculation
aCalculate
)
const
;
uint32_t
GetFitnessDistance
(
const
webrtc
:
:
CaptureCapability
&
aCandidate
const
NormalizedConstraintSet
&
aConstraints
const
nsString
&
aDeviceId
)
const
;
uint32_t
GetFeasibilityDistance
(
const
webrtc
:
:
CaptureCapability
&
aCandidate
const
NormalizedConstraintSet
&
aConstraints
const
nsString
&
aDeviceId
)
const
;
static
void
TrimLessFitCandidates
(
nsTArray
<
CapabilityCandidate
>
&
aSet
)
;
uint32_t
GetBestFitnessDistance
(
const
nsTArray
<
const
NormalizedConstraintSet
*
>
&
aConstraintSets
const
nsString
&
aDeviceId
)
const
override
;
public
:
MediaEngineRemoteVideoSource
(
int
aIndex
camera
:
:
CaptureEngine
aCapEngine
dom
:
:
MediaSourceEnum
aMediaSource
bool
aScary
)
;
int
DeliverFrame
(
uint8_t
*
buffer
const
camera
:
:
VideoFrameProperties
&
properties
)
override
;
dom
:
:
MediaSourceEnum
GetMediaSource
(
)
const
override
{
return
mMediaSource
;
}
nsresult
Allocate
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
const
ipc
:
:
PrincipalInfo
&
aPrincipalInfo
AllocationHandle
*
*
aOutHandle
const
char
*
*
aOutBadConstraint
)
override
;
nsresult
Deallocate
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
)
override
;
nsresult
SetTrack
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
const
RefPtr
<
SourceMediaStream
>
&
aStream
TrackID
aTrackID
const
PrincipalHandle
&
aPrincipal
)
override
;
nsresult
Start
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
)
override
;
nsresult
Reconfigure
(
const
RefPtr
<
AllocationHandle
>
&
aHandle
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsString
&
aDeviceId
const
char
*
*
aOutBadConstraint
)
override
;
nsresult
FocusOnSelectedSource
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
)
override
;
nsresult
Stop
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
)
override
;
void
Pull
(
const
RefPtr
<
const
AllocationHandle
>
&
aHandle
const
RefPtr
<
SourceMediaStream
>
&
aStream
TrackID
aTrackID
StreamTime
aDesiredTime
const
PrincipalHandle
&
aPrincipalHandle
)
override
;
void
GetSettings
(
dom
:
:
MediaTrackSettings
&
aOutSettings
)
const
override
;
void
Refresh
(
int
aIndex
)
;
void
Shutdown
(
)
override
;
nsString
GetName
(
)
const
override
;
void
SetName
(
nsString
aName
)
;
nsCString
GetUUID
(
)
const
override
;
void
SetUUID
(
const
char
*
aUUID
)
;
bool
GetScary
(
)
const
override
{
return
mScary
;
}
private
:
void
Init
(
)
;
size_t
NumCapabilities
(
)
const
;
webrtc
:
:
CaptureCapability
GetCapability
(
size_t
aIndex
)
const
;
int
mCaptureIndex
;
const
dom
:
:
MediaSourceEnum
mMediaSource
;
const
camera
:
:
CaptureEngine
mCapEngine
;
const
bool
mScary
;
Mutex
mMutex
;
MediaEngineSourceState
mState
=
kReleased
;
RefPtr
<
SourceMediaStream
>
mStream
;
TrackID
mTrackID
=
TRACK_NONE
;
PrincipalHandle
mPrincipal
=
PRINCIPAL_HANDLE_NONE
;
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
RefPtr
<
layers
:
:
Image
>
mImage
;
webrtc
:
:
I420BufferPool
mRescalingBufferPool
;
gfx
:
:
IntSize
mImageSize
=
gfx
:
:
IntSize
(
0
0
)
;
struct
AtomicBool
{
Atomic
<
bool
>
mValue
;
}
;
const
RefPtr
<
media
:
:
Refcountable
<
AtomicBool
>
>
mSettingsUpdatedByFrame
;
const
RefPtr
<
media
:
:
Refcountable
<
dom
:
:
MediaTrackSettings
>
>
mSettings
;
webrtc
:
:
CaptureCapability
mCapability
;
mutable
nsTArray
<
webrtc
:
:
CaptureCapability
>
mHardcodedCapabilities
;
nsString
mDeviceName
;
nsCString
mUniqueId
;
nsString
mFacingMode
;
bool
mInitDone
=
false
;
}
;
}
#
endif
