#
ifndef
MOZILLA_DOM_MEDIA_WEBRTC_JSAPI_RTCRTPSCRIPTTRANSFORMER_H_
#
define
MOZILLA_DOM_MEDIA_WEBRTC_JSAPI_RTCRTPSCRIPTTRANSFORMER_H_
#
include
"
nsISupports
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
mozilla
/
dom
/
WritableStream
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
<
memory
>
#
include
"
nsTHashSet
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
class
nsPIDOMWindowInner
;
namespace
webrtc
{
class
TransformableFrameInterface
;
}
namespace
mozilla
{
class
FrameTransformerProxy
;
namespace
dom
{
class
Worker
;
class
WorkerPrivate
;
class
nsISupportsStreamSource
final
:
public
UnderlyingSourceAlgorithmsWrapper
{
public
:
nsISupportsStreamSource
(
)
;
nsISupportsStreamSource
(
const
nsISupportsStreamSource
&
)
=
delete
;
nsISupportsStreamSource
(
nsISupportsStreamSource
&
&
)
=
delete
;
nsISupportsStreamSource
&
operator
=
(
const
nsISupportsStreamSource
&
)
=
delete
;
nsISupportsStreamSource
&
operator
=
(
nsISupportsStreamSource
&
&
)
=
delete
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
nsISupportsStreamSource
UnderlyingSourceAlgorithmsWrapper
)
void
Init
(
ReadableStream
*
aStream
)
;
void
Enqueue
(
nsISupports
*
aThing
)
;
already_AddRefed
<
Promise
>
PullCallbackImpl
(
JSContext
*
aCx
ReadableStreamControllerBase
&
aController
ErrorResult
&
aRv
)
override
;
void
EnqueueOneThingFromQueue
(
JSContext
*
aCx
)
;
private
:
virtual
~
nsISupportsStreamSource
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
EnqueueToStream
(
JSContext
*
aCx
nsISupports
*
aThing
)
;
RefPtr
<
ReadableStream
>
mStream
;
RefPtr
<
Promise
>
mThingQueuedPromise
;
nsCOMArray
<
nsISupports
>
mQueue
;
}
;
class
RTCRtpScriptTransformer
;
class
WritableStreamRTCFrameSink
final
:
public
UnderlyingSinkAlgorithmsWrapper
{
public
:
explicit
WritableStreamRTCFrameSink
(
RTCRtpScriptTransformer
*
aTransformer
)
;
WritableStreamRTCFrameSink
(
const
WritableStreamRTCFrameSink
&
)
=
delete
;
WritableStreamRTCFrameSink
(
WritableStreamRTCFrameSink
&
&
)
=
delete
;
WritableStreamRTCFrameSink
&
operator
=
(
const
WritableStreamRTCFrameSink
&
)
=
delete
;
WritableStreamRTCFrameSink
&
operator
=
(
WritableStreamRTCFrameSink
&
&
)
=
delete
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
WritableStreamRTCFrameSink
UnderlyingSinkAlgorithmsWrapper
)
already_AddRefed
<
Promise
>
WriteCallbackImpl
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
WritableStreamDefaultController
&
aController
ErrorResult
&
aError
)
override
;
private
:
virtual
~
WritableStreamRTCFrameSink
(
)
;
RefPtr
<
RTCRtpScriptTransformer
>
mTransformer
;
}
;
class
RTCEncodedFrameBase
;
class
RTCRtpScriptTransformer
final
:
public
nsISupports
public
nsWrapperCache
{
public
:
explicit
RTCRtpScriptTransformer
(
nsIGlobalObject
*
aGlobal
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
Init
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aOptions
WorkerPrivate
*
aWorkerPrivate
FrameTransformerProxy
*
aProxy
)
;
void
NotifyReleased
(
)
;
void
TransformFrame
(
std
:
:
unique_ptr
<
webrtc
:
:
TransformableFrameInterface
>
aFrame
)
;
already_AddRefed
<
Promise
>
OnTransformedFrame
(
RTCEncodedFrameBase
*
aFrame
ErrorResult
&
aError
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
RTCRtpScriptTransformer
)
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
mGlobal
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
ReadableStream
>
Readable
(
)
const
{
return
do_AddRef
(
mReadable
)
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
WritableStream
>
Writable
(
)
const
{
return
do_AddRef
(
mWritable
)
;
}
void
GetOptions
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
ErrorResult
&
aError
)
;
already_AddRefed
<
Promise
>
GenerateKeyFrame
(
const
Optional
<
nsAString
>
&
aRid
)
;
void
GenerateKeyFrameError
(
const
Maybe
<
std
:
:
string
>
&
aRid
const
CopyableErrorResult
&
aResult
)
;
already_AddRefed
<
Promise
>
SendKeyFrameRequest
(
)
;
void
KeyFrameRequestDone
(
bool
aSuccess
)
;
using
GenerateKeyFramePromises
=
nsTHashMap
<
nsCStringHashKey
nsTArray
<
RefPtr
<
Promise
>
>
>
;
private
:
virtual
~
RTCRtpScriptTransformer
(
)
;
void
RejectPendingPromises
(
)
;
void
ResolveGenerateKeyFramePromises
(
const
std
:
:
string
&
aRid
uint64_t
aTimestamp
)
;
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
RefPtr
<
FrameTransformerProxy
>
mProxy
;
RefPtr
<
nsISupportsStreamSource
>
mReadableSource
;
RefPtr
<
ReadableStream
>
mReadable
;
RefPtr
<
WritableStream
>
mWritable
;
RefPtr
<
WritableStreamRTCFrameSink
>
mWritableSink
;
JS
:
:
Heap
<
JS
:
:
Value
>
mOptions
;
uint64_t
mLastEnqueuedFrameCounter
=
0
;
uint64_t
mLastReceivedFrameCounter
=
0
;
nsTArray
<
RefPtr
<
Promise
>
>
mKeyFrameRequestPromises
;
GenerateKeyFramePromises
mGenerateKeyFramePromises
;
Maybe
<
bool
>
mVideo
;
RefPtr
<
StrongWorkerRef
>
mWorkerRef
;
}
;
}
}
#
endif
