#
include
"
RTCDataChannel
.
h
"
#
include
"
DataChannel
.
h
"
#
include
"
DataChannelLog
.
h
"
#
include
"
RTCDataChannelDeclarations
.
h
"
#
include
"
base
/
basictypes
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
dom
/
Blob
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
MessageEvent
.
h
"
#
include
"
mozilla
/
dom
/
MessageEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCStatsReportBinding
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRef
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsThreadManager
.
h
"
#
ifdef
GetBinaryType
#
undef
GetBinaryType
#
endif
namespace
mozilla
{
namespace
dom
{
static
constexpr
const
char
*
ToString
(
RTCDataChannelState
state
)
{
switch
(
state
)
{
case
RTCDataChannelState
:
:
Connecting
:
return
"
connecting
"
;
case
RTCDataChannelState
:
:
Open
:
return
"
open
"
;
case
RTCDataChannelState
:
:
Closing
:
return
"
closing
"
;
case
RTCDataChannelState
:
:
Closed
:
return
"
closed
"
;
}
return
"
"
;
}
;
RTCDataChannel
:
:
~
RTCDataChannel
(
)
{
if
(
NS_IsMainThread
(
)
)
{
mDataChannel
-
>
UnsetMainthreadDomDataChannel
(
)
;
}
else
{
mDataChannel
-
>
UnsetWorkerDomDataChannel
(
)
;
}
}
JSObject
*
RTCDataChannel
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
RTCDataChannel_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
RTCDataChannel
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
RTCDataChannel
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
RTCDataChannel
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_ADDREF_INHERITED
(
RTCDataChannel
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
RTCDataChannel
DOMEventTargetHelper
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
RTCDataChannel
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
RTCDataChannel
:
:
RTCDataChannel
(
const
nsACString
&
aLabel
const
nsAString
&
aOrigin
bool
aOrdered
Nullable
<
uint16_t
>
aMaxLifeTime
Nullable
<
uint16_t
>
aMaxRetransmits
const
nsACString
&
aProtocol
bool
aNegotiated
already_AddRefed
<
DataChannel
>
&
aDataChannel
nsPIDOMWindowInner
*
aWindow
)
:
DOMEventTargetHelper
(
aWindow
)
mUuid
(
nsID
:
:
GenerateUUID
(
)
)
mOrigin
(
aOrigin
)
mLabel
(
aLabel
)
mOrdered
(
aOrdered
)
mMaxPacketLifeTime
(
aMaxLifeTime
)
mMaxRetransmits
(
aMaxRetransmits
)
mDataChannelProtocol
(
aProtocol
)
mNegotiated
(
aNegotiated
)
mDataChannel
(
aDataChannel
)
mEventTarget
(
GetCurrentSerialEventTarget
(
)
)
{
DC_INFO
(
(
"
RTCDataChannel
created
on
main
"
)
)
;
mDataChannel
-
>
SetMainthreadDomDataChannel
(
this
)
;
}
nsresult
RTCDataChannel
:
:
Init
(
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
UpdateMustKeepAlive
(
)
;
if
(
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
)
{
RefPtr
<
StrongWorkerRef
>
strongWorkerRef
=
StrongWorkerRef
:
:
Create
(
workerPrivate
"
RTCDataChannel
:
:
Init
"
[
this
self
=
RefPtr
<
RTCDataChannel
>
(
this
)
]
(
)
{
mDataChannel
-
>
UnsetWorkerDomDataChannel
(
)
;
UnsetWorkerNeedsUs
(
)
;
mWorkerRef
=
nullptr
;
}
)
;
if
(
NS_WARN_IF
(
!
strongWorkerRef
)
)
{
mDataChannel
-
>
UnsetWorkerDomDataChannel
(
)
;
UnsetWorkerNeedsUs
(
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
mWorkerRef
)
;
mWorkerRef
=
std
:
:
move
(
strongWorkerRef
)
;
}
if
(
NS_IsMainThread
(
)
)
{
GetMainThreadSerialEventTarget
(
)
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
<
RTCDataChannel
>
(
this
)
]
(
)
{
DisableWorkerTransfer
(
)
;
}
)
)
;
}
nsresult
rv
=
CheckCurrentGlobalCorrectness
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
DC_DEBUG
(
(
"
%
s
:
origin
=
%
s
\
n
"
__FUNCTION__
NS_LossyConvertUTF16toASCII
(
mOrigin
)
.
get
(
)
)
)
;
return
NS_OK
;
}
void
RTCDataChannel
:
:
GetLabel
(
nsACString
&
aLabel
)
const
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
aLabel
=
mLabel
;
}
void
RTCDataChannel
:
:
GetProtocol
(
nsACString
&
aProtocol
)
const
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
aProtocol
=
mDataChannelProtocol
;
}
Nullable
<
uint16_t
>
RTCDataChannel
:
:
GetId
(
)
const
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
return
mDataChannelId
;
}
RTCDataChannel
:
:
DataHolder
:
:
DataHolder
(
const
RTCDataChannel
&
aValue
)
:
mReadyState
(
aValue
.
mReadyState
)
mLabel
(
aValue
.
mLabel
)
mOrdered
(
aValue
.
mOrdered
)
mMaxPacketLifeTime
(
aValue
.
mMaxPacketLifeTime
)
mMaxRetransmits
(
aValue
.
mMaxRetransmits
)
mDataChannelProtocol
(
aValue
.
mDataChannelProtocol
)
mNegotiated
(
aValue
.
mNegotiated
)
mDataChannelId
(
aValue
.
mDataChannelId
)
mDataChannel
(
aValue
.
mDataChannel
)
mMaxMessageSize
(
aValue
.
mMaxMessageSize
)
mOrigin
(
aValue
.
mOrigin
)
{
}
RTCDataChannel
:
:
DataHolder
:
:
~
DataHolder
(
)
=
default
;
UniquePtr
<
RTCDataChannel
:
:
DataHolder
>
RTCDataChannel
:
:
Transfer
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mIsTransferable
)
{
return
nullptr
;
}
UniquePtr
<
DataHolder
>
dataHolder
=
MakeUnique
<
DataHolder
>
(
*
this
)
;
mIsTransferable
=
false
;
mReadyState
=
RTCDataChannelState
:
:
Closed
;
mDataChannel
-
>
OnWorkerTransferStarted
(
)
;
return
dataHolder
;
}
RTCDataChannel
:
:
RTCDataChannel
(
nsIGlobalObject
*
aGlobal
const
DataHolder
&
aDataHolder
)
:
DOMEventTargetHelper
(
aGlobal
)
mUuid
(
nsID
:
:
GenerateUUID
(
)
)
mOrigin
(
aDataHolder
.
mOrigin
)
mLabel
(
aDataHolder
.
mLabel
)
mOrdered
(
aDataHolder
.
mOrdered
)
mMaxPacketLifeTime
(
aDataHolder
.
mMaxPacketLifeTime
)
mMaxRetransmits
(
aDataHolder
.
mMaxRetransmits
)
mDataChannelProtocol
(
aDataHolder
.
mDataChannelProtocol
)
mNegotiated
(
aDataHolder
.
mNegotiated
)
mDataChannel
(
aDataHolder
.
mDataChannel
)
mDataChannelId
(
aDataHolder
.
mDataChannelId
)
mReadyState
(
aDataHolder
.
mReadyState
)
mWorkerNeedsUs
(
true
)
mIsTransferable
(
false
)
mMaxMessageSize
(
aDataHolder
.
mMaxMessageSize
)
mEventTarget
(
GetCurrentSerialEventTarget
(
)
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
DC_INFO
(
(
"
RTCDataChannel
created
on
worker
"
)
)
;
mDataChannel
-
>
OnWorkerTransferComplete
(
this
)
;
}
void
RTCDataChannel
:
:
SetId
(
uint16_t
aId
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
mDataChannelId
.
SetValue
(
aId
)
;
}
void
RTCDataChannel
:
:
SetMaxMessageSize
(
double
aMaxMessageSize
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
DC_INFO
(
(
"
RTCDataChannel
updating
maximum
message
size
:
%
f
-
>
%
f
"
mMaxMessageSize
aMaxMessageSize
)
)
;
mMaxMessageSize
=
aMaxMessageSize
;
}
Nullable
<
uint16_t
>
RTCDataChannel
:
:
GetMaxPacketLifeTime
(
)
const
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
return
mMaxPacketLifeTime
;
}
Nullable
<
uint16_t
>
RTCDataChannel
:
:
GetMaxRetransmits
(
)
const
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
return
mMaxRetransmits
;
}
bool
RTCDataChannel
:
:
Negotiated
(
)
const
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
return
mNegotiated
;
}
bool
RTCDataChannel
:
:
Ordered
(
)
const
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
return
mOrdered
;
}
RTCDataChannelState
RTCDataChannel
:
:
ReadyState
(
)
const
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
return
mReadyState
;
}
void
RTCDataChannel
:
:
SetReadyState
(
const
RTCDataChannelState
aState
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
DC_DEBUG
(
(
"
RTCDataChannel
labeled
%
s
(
%
p
)
(
stream
%
d
)
changing
ready
"
"
state
"
"
%
s
-
>
%
s
"
mLabel
.
get
(
)
this
mDataChannelId
.
IsNull
(
)
?
INVALID_STREAM
:
mDataChannelId
.
Value
(
)
ToString
(
mReadyState
)
ToString
(
aState
)
)
)
;
mReadyState
=
aState
;
}
size_t
RTCDataChannel
:
:
BufferedAmount
(
)
const
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
return
mBufferedAmount
;
}
size_t
RTCDataChannel
:
:
BufferedAmountLowThreshold
(
)
const
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
return
mBufferedThreshold
;
}
void
RTCDataChannel
:
:
SetBufferedAmountLowThreshold
(
size_t
aThreshold
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
mBufferedThreshold
=
aThreshold
;
}
void
RTCDataChannel
:
:
Close
(
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
mReadyState
=
=
RTCDataChannelState
:
:
Closed
|
|
mReadyState
=
=
RTCDataChannelState
:
:
Closing
)
{
DC_DEBUG
(
(
"
Channel
already
closing
/
closed
(
%
s
)
"
ToString
(
mReadyState
)
)
)
;
return
;
}
SetReadyState
(
RTCDataChannelState
:
:
Closing
)
;
GracefulClose
(
)
;
UpdateMustKeepAlive
(
)
;
}
void
RTCDataChannel
:
:
Send
(
const
nsAString
&
aData
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
DisableWorkerTransfer
(
)
;
if
(
!
CheckReadyState
(
aRv
)
)
{
return
;
}
if
(
!
CheckSendSize
(
aData
.
Length
(
)
aRv
)
)
{
return
;
}
nsCString
msgString
;
if
(
!
AppendUTF16toUTF8
(
aData
msgString
fallible_t
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FILE_TOO_BIG
)
;
return
;
}
size_t
length
=
msgString
.
Length
(
)
;
if
(
!
mDataChannel
-
>
SendMsg
(
std
:
:
move
(
msgString
)
)
)
{
+
+
mMessagesSent
;
mBytesSent
+
=
length
;
IncrementBufferedAmount
(
length
)
;
}
else
{
aRv
.
ThrowOperationError
(
"
Failed
to
queue
message
"
)
;
}
}
void
RTCDataChannel
:
:
Send
(
Blob
&
aData
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
DisableWorkerTransfer
(
)
;
if
(
!
CheckReadyState
(
aRv
)
)
{
return
;
}
uint64_t
msgLength
=
aData
.
GetSize
(
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
if
(
!
CheckSendSize
(
msgLength
aRv
)
)
{
return
;
}
nsCOMPtr
<
nsIInputStream
>
msgStream
;
aData
.
CreateInputStream
(
getter_AddRefs
(
msgStream
)
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
if
(
msgLength
>
UINT32_MAX
)
{
aRv
.
Throw
(
NS_ERROR_FILE_TOO_BIG
)
;
return
;
}
if
(
!
mDataChannel
-
>
SendBinaryBlob
(
msgStream
)
)
{
+
+
mMessagesSent
;
mBytesSent
+
=
msgLength
;
IncrementBufferedAmount
(
msgLength
)
;
}
else
{
aRv
.
ThrowOperationError
(
"
Failed
to
queue
message
"
)
;
}
}
void
RTCDataChannel
:
:
Send
(
const
ArrayBuffer
&
aData
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
DisableWorkerTransfer
(
)
;
if
(
!
CheckReadyState
(
aRv
)
)
{
return
;
}
nsCString
msgString
;
if
(
!
aData
.
AppendDataTo
(
msgString
)
)
{
aRv
.
Throw
(
NS_ERROR_FILE_TOO_BIG
)
;
return
;
}
if
(
!
CheckSendSize
(
msgString
.
Length
(
)
aRv
)
)
{
return
;
}
size_t
length
=
msgString
.
Length
(
)
;
if
(
!
mDataChannel
-
>
SendBinaryMsg
(
std
:
:
move
(
msgString
)
)
)
{
+
+
mMessagesSent
;
mBytesSent
+
=
length
;
IncrementBufferedAmount
(
length
)
;
}
else
{
aRv
.
ThrowOperationError
(
"
Failed
to
queue
message
"
)
;
}
}
void
RTCDataChannel
:
:
Send
(
const
ArrayBufferView
&
aData
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
DisableWorkerTransfer
(
)
;
if
(
!
CheckReadyState
(
aRv
)
)
{
return
;
}
nsCString
msgString
;
if
(
!
aData
.
AppendDataTo
(
msgString
)
)
{
aRv
.
Throw
(
NS_ERROR_FILE_TOO_BIG
)
;
return
;
}
if
(
!
CheckSendSize
(
msgString
.
Length
(
)
aRv
)
)
{
return
;
}
size_t
length
=
msgString
.
Length
(
)
;
if
(
!
mDataChannel
-
>
SendBinaryMsg
(
std
:
:
move
(
msgString
)
)
)
{
+
+
mMessagesSent
;
mBytesSent
+
=
length
;
IncrementBufferedAmount
(
length
)
;
}
else
{
aRv
.
ThrowOperationError
(
"
Failed
to
queue
message
"
)
;
}
}
void
RTCDataChannel
:
:
GracefulClose
(
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
GetCurrentSerialEventTarget
(
)
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
<
RTCDataChannel
>
(
this
)
]
(
)
{
if
(
mReadyState
!
=
RTCDataChannelState
:
:
Closing
&
&
mReadyState
!
=
RTCDataChannelState
:
:
Closed
)
{
SetReadyState
(
RTCDataChannelState
:
:
Closing
)
;
OnSimpleEvent
(
u
"
closing
"
_ns
)
;
}
if
(
!
mBufferedAmount
&
&
mReadyState
!
=
RTCDataChannelState
:
:
Closed
&
&
mDataChannel
)
{
mDataChannel
-
>
FinishClose
(
)
;
}
}
)
)
;
}
void
RTCDataChannel
:
:
AnnounceOpen
(
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
mReadyState
!
=
RTCDataChannelState
:
:
Closing
&
&
mReadyState
!
=
RTCDataChannelState
:
:
Closed
)
{
SetReadyState
(
RTCDataChannelState
:
:
Open
)
;
DC_INFO
(
(
"
%
s
:
sending
open
for
%
s
/
%
s
:
%
u
"
__FUNCTION__
mLabel
.
get
(
)
mDataChannelProtocol
.
get
(
)
mDataChannelId
.
Value
(
)
)
)
;
OnSimpleEvent
(
u
"
open
"
_ns
)
;
}
}
void
RTCDataChannel
:
:
AnnounceClosed
(
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
mReadyState
=
=
RTCDataChannelState
:
:
Closed
)
{
return
;
}
SetReadyState
(
RTCDataChannelState
:
:
Closed
)
;
OnSimpleEvent
(
u
"
close
"
_ns
)
;
DontKeepAliveAnyMore
(
)
;
}
dom
:
:
RTCDataChannelStats
RTCDataChannel
:
:
GetStats
(
const
DOMHighResTimeStamp
aTimestamp
)
const
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
mozilla
:
:
dom
:
:
RTCDataChannelStats
stats
;
nsString
id
=
u
"
dc
"
_ns
;
id
.
Append
(
NS_ConvertASCIItoUTF16
(
mUuid
.
ToString
(
)
.
get
(
)
)
)
;
stats
.
mId
.
Construct
(
id
)
;
stats
.
mTimestamp
.
Construct
(
aTimestamp
)
;
stats
.
mType
.
Construct
(
mozilla
:
:
dom
:
:
RTCStatsType
:
:
Data_channel
)
;
stats
.
mLabel
.
Construct
(
NS_ConvertUTF8toUTF16
(
mLabel
)
)
;
stats
.
mProtocol
.
Construct
(
NS_ConvertUTF8toUTF16
(
mDataChannelProtocol
)
)
;
if
(
!
mDataChannelId
.
IsNull
(
)
)
{
stats
.
mDataChannelIdentifier
.
Construct
(
mDataChannelId
.
Value
(
)
)
;
}
stats
.
mState
.
Construct
(
mReadyState
)
;
stats
.
mMessagesSent
.
Construct
(
mMessagesSent
)
;
stats
.
mBytesSent
.
Construct
(
mBytesSent
)
;
stats
.
mMessagesReceived
.
Construct
(
mMessagesReceived
)
;
stats
.
mBytesReceived
.
Construct
(
mBytesReceived
)
;
return
stats
;
}
void
RTCDataChannel
:
:
IncrementBufferedAmount
(
size_t
aSize
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
mBufferedAmount
+
=
aSize
;
}
void
RTCDataChannel
:
:
DecrementBufferedAmount
(
size_t
aSize
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
aSize
<
=
mBufferedAmount
)
;
aSize
=
std
:
:
min
(
aSize
mBufferedAmount
)
;
bool
wasLow
=
mBufferedAmount
<
=
mBufferedThreshold
;
mBufferedAmount
-
=
aSize
;
if
(
!
wasLow
&
&
mBufferedAmount
<
=
mBufferedThreshold
)
{
DC_DEBUG
(
(
"
%
s
:
sending
bufferedamountlow
for
%
s
/
%
s
:
%
u
"
__FUNCTION__
mLabel
.
get
(
)
mDataChannelProtocol
.
get
(
)
mDataChannelId
.
Value
(
)
)
)
;
OnSimpleEvent
(
u
"
bufferedamountlow
"
_ns
)
;
}
if
(
mBufferedAmount
=
=
0
)
{
DC_DEBUG
(
(
"
%
s
:
no
queued
sends
for
%
s
/
%
s
:
%
u
"
__FUNCTION__
mLabel
.
get
(
)
mDataChannelProtocol
.
get
(
)
mDataChannelId
.
Value
(
)
)
)
;
UpdateMustKeepAlive
(
)
;
if
(
mReadyState
=
=
RTCDataChannelState
:
:
Closing
)
{
if
(
mDataChannel
)
{
mDataChannel
-
>
FinishClose
(
)
;
}
}
}
}
bool
RTCDataChannel
:
:
CheckSendSize
(
uint64_t
aSize
ErrorResult
&
aRv
)
const
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
aSize
>
mMaxMessageSize
)
{
nsPrintfCString
err
(
"
Message
size
(
%
"
PRIu64
"
)
exceeds
maxMessageSize
"
aSize
)
;
aRv
.
ThrowTypeError
(
err
)
;
return
false
;
}
return
true
;
}
void
RTCDataChannel
:
:
DisableWorkerTransfer
(
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
mIsTransferable
)
{
mIsTransferable
=
false
;
mDataChannel
-
>
OnWorkerTransferDisabled
(
)
;
}
}
bool
RTCDataChannel
:
:
CheckReadyState
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
mReadyState
=
=
RTCDataChannelState
:
:
Connecting
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
false
;
}
if
(
mReadyState
=
=
RTCDataChannelState
:
:
Closing
|
|
mReadyState
=
=
RTCDataChannelState
:
:
Closed
)
{
return
false
;
}
MOZ_ASSERT
(
mReadyState
=
=
RTCDataChannelState
:
:
Open
"
Unknown
state
in
RTCDataChannel
:
:
Send
"
)
;
return
true
;
}
nsresult
RTCDataChannel
:
:
DoOnMessageAvailable
(
const
nsACString
&
aData
bool
aBinary
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
mReadyState
=
=
RTCDataChannelState
:
:
Closed
|
|
mReadyState
=
=
RTCDataChannelState
:
:
Closing
)
{
return
NS_OK
;
}
DC_VERBOSE
(
(
"
DoOnMessageAvailable
%
s
\
n
"
aBinary
?
(
(
mBinaryType
=
=
RTCDataChannelType
:
:
Blob
)
?
"
(
blob
)
"
:
"
(
binary
)
"
)
:
"
"
)
)
;
nsresult
rv
=
CheckCurrentGlobalCorrectness
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
DC_ERROR
(
(
"
RTCDataChannel
:
:
%
s
:
CheckCurrentGlobalCorrectness
failed
"
__func__
)
)
;
return
NS_OK
;
}
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
GetParentObject
(
)
)
)
)
{
DC_ERROR
(
(
"
RTCDataChannel
:
:
%
s
:
jsapi
.
Init
failed
"
__func__
)
)
;
return
NS_ERROR_FAILURE
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
jsData
(
cx
)
;
if
(
aBinary
)
{
if
(
mBinaryType
=
=
RTCDataChannelType
:
:
Blob
)
{
RefPtr
<
Blob
>
blob
=
Blob
:
:
CreateStringBlob
(
GetOwnerGlobal
(
)
aData
u
"
"
_ns
)
;
if
(
NS_WARN_IF
(
!
blob
)
)
{
DC_ERROR
(
(
"
RTCDataChannel
:
:
%
s
:
CreateStringBlob
failed
"
__func__
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
ToJSValue
(
cx
blob
&
jsData
)
)
{
DC_ERROR
(
(
"
RTCDataChannel
:
:
%
s
:
ToJSValue
failed
"
__func__
)
)
;
return
NS_ERROR_FAILURE
;
}
}
else
if
(
mBinaryType
=
=
RTCDataChannelType
:
:
Arraybuffer
)
{
ErrorResult
error
;
JS
:
:
Rooted
<
JSObject
*
>
arrayBuf
(
cx
ArrayBuffer
:
:
Create
(
cx
aData
error
)
)
;
RETURN_NSRESULT_ON_FAILURE
(
error
)
;
jsData
.
setObject
(
*
arrayBuf
)
;
}
else
{
MOZ_CRASH
(
"
Unknown
binary
type
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
else
{
NS_ConvertUTF8toUTF16
utf16data
(
aData
)
;
JSString
*
jsString
=
JS_NewUCStringCopyN
(
cx
utf16data
.
get
(
)
utf16data
.
Length
(
)
)
;
NS_ENSURE_TRUE
(
jsString
NS_ERROR_FAILURE
)
;
jsData
.
setString
(
jsString
)
;
}
RefPtr
<
MessageEvent
>
event
=
new
MessageEvent
(
this
nullptr
nullptr
)
;
event
-
>
InitMessageEvent
(
nullptr
u
"
message
"
_ns
CanBubble
:
:
eNo
Cancelable
:
:
eNo
jsData
mOrigin
u
"
"
_ns
nullptr
Sequence
<
OwningNonNull
<
MessagePort
>
>
(
)
)
;
event
-
>
SetTrusted
(
true
)
;
+
+
mMessagesReceived
;
mBytesReceived
+
=
aData
.
Length
(
)
;
if
(
mMessagesReceived
<
5
)
{
DC_INFO
(
(
"
Firing
\
"
message
\
"
event
#
%
zu
"
mMessagesReceived
)
)
;
}
else
if
(
mMessagesReceived
=
=
5
)
{
DC_INFO
(
(
"
Firing
\
"
message
\
"
event
#
%
zu
will
not
log
more
message
events
"
mMessagesReceived
)
)
;
}
DC_DEBUG
(
(
"
%
p
(
%
p
)
:
%
s
-
Dispatching
\
n
"
this
(
void
*
)
mDataChannel
__FUNCTION__
)
)
;
ErrorResult
err
;
DispatchEvent
(
*
event
err
)
;
if
(
err
.
Failed
(
)
)
{
DC_ERROR
(
(
"
%
p
(
%
p
)
:
%
s
-
Failed
to
dispatch
message
"
this
(
void
*
)
mDataChannel
__FUNCTION__
)
)
;
NS_WARNING
(
"
Failed
to
dispatch
the
message
event
!
!
!
"
)
;
}
return
err
.
StealNSResult
(
)
;
}
nsresult
RTCDataChannel
:
:
OnSimpleEvent
(
const
nsAString
&
aName
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
nsresult
rv
=
CheckCurrentGlobalCorrectness
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
if
(
MOZ_LOG_TEST
(
mozilla
:
:
gDataChannelLog
mozilla
:
:
LogLevel
:
:
Info
)
)
{
DC_INFO
(
(
"
Firing
\
"
%
s
\
"
event
"
NS_ConvertUTF16toUTF8
(
aName
)
.
get
(
)
)
)
;
}
RefPtr
<
Event
>
event
=
NS_NewDOMEvent
(
this
nullptr
nullptr
)
;
event
-
>
InitEvent
(
aName
CanBubble
:
:
eNo
Cancelable
:
:
eNo
)
;
event
-
>
SetTrusted
(
true
)
;
ErrorResult
err
;
DispatchEvent
(
*
event
err
)
;
return
err
.
StealNSResult
(
)
;
}
void
RTCDataChannel
:
:
UpdateMustKeepAlive
(
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
!
mCheckMustKeepAlive
)
{
return
;
}
bool
shouldKeepAlive
=
mWorkerNeedsUs
;
if
(
!
shouldKeepAlive
)
{
switch
(
mReadyState
)
{
case
RTCDataChannelState
:
:
Connecting
:
{
if
(
mListenerManager
&
&
(
mListenerManager
-
>
HasListenersFor
(
nsGkAtoms
:
:
onopen
)
|
|
mListenerManager
-
>
HasListenersFor
(
nsGkAtoms
:
:
onmessage
)
|
|
mListenerManager
-
>
HasListenersFor
(
nsGkAtoms
:
:
onerror
)
|
|
mListenerManager
-
>
HasListenersFor
(
nsGkAtoms
:
:
onbufferedamountlow
)
|
|
mListenerManager
-
>
HasListenersFor
(
nsGkAtoms
:
:
onclose
)
)
)
{
shouldKeepAlive
=
true
;
}
}
break
;
case
RTCDataChannelState
:
:
Open
:
case
RTCDataChannelState
:
:
Closing
:
{
if
(
mBufferedAmount
!
=
0
|
|
(
mListenerManager
&
&
(
mListenerManager
-
>
HasListenersFor
(
nsGkAtoms
:
:
onmessage
)
|
|
mListenerManager
-
>
HasListenersFor
(
nsGkAtoms
:
:
onerror
)
|
|
mListenerManager
-
>
HasListenersFor
(
nsGkAtoms
:
:
onbufferedamountlow
)
|
|
mListenerManager
-
>
HasListenersFor
(
nsGkAtoms
:
:
onclose
)
)
)
)
{
shouldKeepAlive
=
true
;
}
}
break
;
case
RTCDataChannelState
:
:
Closed
:
;
}
}
if
(
mSelfRef
&
&
!
shouldKeepAlive
)
{
DC_INFO
(
(
"
RTCDataChannel
is
no
longer
protected
from
GC
.
"
)
)
;
ReleaseSelf
(
)
;
}
else
if
(
!
mSelfRef
&
&
shouldKeepAlive
)
{
DC_INFO
(
(
"
RTCDataChannel
is
protected
from
GC
.
"
)
)
;
mSelfRef
=
this
;
}
}
void
RTCDataChannel
:
:
DontKeepAliveAnyMore
(
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
mCheckMustKeepAlive
=
false
;
mWorkerRef
=
nullptr
;
if
(
mSelfRef
)
{
ReleaseSelf
(
)
;
}
}
void
RTCDataChannel
:
:
ReleaseSelf
(
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
NS_ProxyRelease
(
"
RTCDataChannel
:
:
mSelfRef
"
mEventTarget
mSelfRef
.
forget
(
)
)
;
}
void
RTCDataChannel
:
:
EventListenerAdded
(
nsAtom
*
aType
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
MOZ_LOG_TEST
(
mozilla
:
:
gDataChannelLog
mozilla
:
:
LogLevel
:
:
Info
)
)
{
nsString
name
;
aType
-
>
ToString
(
name
)
;
DC_INFO
(
(
"
RTCDataChannel
\
"
%
s
\
"
event
listener
added
calling
"
"
UpdateMustKeepAlive
.
"
NS_ConvertUTF16toUTF8
(
name
)
.
get
(
)
)
)
;
}
UpdateMustKeepAlive
(
)
;
}
void
RTCDataChannel
:
:
EventListenerRemoved
(
nsAtom
*
aType
)
{
MOZ_ASSERT
(
mEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
MOZ_LOG_TEST
(
mozilla
:
:
gDataChannelLog
mozilla
:
:
LogLevel
:
:
Info
)
)
{
nsString
name
;
aType
-
>
ToString
(
name
)
;
DC_INFO
(
(
"
RTCDataChannel
\
"
%
s
\
"
event
listener
removed
calling
"
"
UpdateMustKeepAlive
.
"
NS_ConvertUTF16toUTF8
(
name
)
.
get
(
)
)
)
;
}
UpdateMustKeepAlive
(
)
;
}
nsresult
NS_NewDOMDataChannel
(
already_AddRefed
<
DataChannel
>
&
&
aDataChannel
const
nsACString
&
aLabel
const
nsAString
&
aOrigin
bool
aOrdered
Nullable
<
uint16_t
>
aMaxLifeTime
Nullable
<
uint16_t
>
aMaxRetransmits
const
nsACString
&
aProtocol
bool
aNegotiated
nsPIDOMWindowInner
*
aWindow
RTCDataChannel
*
*
aDomDataChannel
)
{
RefPtr
<
RTCDataChannel
>
domdc
=
new
RTCDataChannel
(
aLabel
aOrigin
aOrdered
aMaxLifeTime
aMaxRetransmits
aProtocol
aNegotiated
aDataChannel
aWindow
)
;
nsresult
rv
=
domdc
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
domdc
.
forget
(
aDomDataChannel
)
;
return
NS_OK
;
}
}
}
