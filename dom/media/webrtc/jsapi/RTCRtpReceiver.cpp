#
include
"
RTCRtpReceiver
.
h
"
#
include
"
transport
/
logging
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamTrack
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
transportbridge
/
MediaPipeline
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
PrincipalHandle
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
MediaTrackGraph
.
h
"
#
include
"
RemoteTrackSource
.
h
"
#
include
"
libwebrtcglue
/
RtpRtcpConfig
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
dom
/
AudioStreamTrack
.
h
"
#
include
"
mozilla
/
dom
/
VideoStreamTrack
.
h
"
#
include
"
MediaTransportHandler
.
h
"
#
include
"
jsep
/
JsepTransceiver
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpReceiverBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpSourcesBinding
.
h
"
#
include
"
RTCStatsReport
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
TransceiverImpl
.
h
"
#
include
"
libwebrtcglue
/
AudioConduit
.
h
"
#
include
"
RTCStatsIdGenerator
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
RTCRtpReceiver
mWindow
mTrack
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
RTCRtpReceiver
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
RTCRtpReceiver
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
RTCRtpReceiver
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
LazyLogModule
gReceiverLog
(
"
RTCRtpReceiver
"
)
;
static
PrincipalHandle
GetPrincipalHandle
(
nsPIDOMWindowInner
*
aWindow
bool
aPrivacyNeeded
)
{
nsCOMPtr
<
nsIScriptObjectPrincipal
>
winPrincipal
=
do_QueryInterface
(
aWindow
)
;
RefPtr
<
nsIPrincipal
>
principal
=
winPrincipal
-
>
GetPrincipal
(
)
;
if
(
NS_WARN_IF
(
!
principal
)
)
{
principal
=
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
}
else
if
(
aPrivacyNeeded
)
{
principal
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
principal
)
;
}
return
MakePrincipalHandle
(
principal
)
;
}
static
already_AddRefed
<
dom
:
:
MediaStreamTrack
>
CreateTrack
(
nsPIDOMWindowInner
*
aWindow
bool
aAudio
const
nsCOMPtr
<
nsIPrincipal
>
&
aPrincipal
)
{
MediaTrackGraph
*
graph
=
MediaTrackGraph
:
:
GetInstance
(
aAudio
?
MediaTrackGraph
:
:
AUDIO_THREAD_DRIVER
:
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
aWindow
MediaTrackGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
MediaTrackGraph
:
:
DEFAULT_OUTPUT_DEVICE
)
;
RefPtr
<
MediaStreamTrack
>
track
;
RefPtr
<
RemoteTrackSource
>
trackSource
;
if
(
aAudio
)
{
RefPtr
<
SourceMediaTrack
>
source
=
graph
-
>
CreateSourceTrack
(
MediaSegment
:
:
AUDIO
)
;
trackSource
=
new
RemoteTrackSource
(
source
aPrincipal
u
"
remote
audio
"
_ns
)
;
track
=
new
AudioStreamTrack
(
aWindow
source
trackSource
)
;
}
else
{
RefPtr
<
SourceMediaTrack
>
source
=
graph
-
>
CreateSourceTrack
(
MediaSegment
:
:
VIDEO
)
;
trackSource
=
new
RemoteTrackSource
(
source
aPrincipal
u
"
remote
video
"
_ns
)
;
track
=
new
VideoStreamTrack
(
aWindow
source
trackSource
)
;
}
trackSource
-
>
SetMuted
(
true
)
;
return
track
.
forget
(
)
;
}
#
define
INIT_CANONICAL
(
name
val
)
\
name
(
AbstractThread
:
:
MainThread
(
)
val
\
"
RTCRtpReceiver
:
:
"
#
name
"
(
Canonical
)
"
)
RTCRtpReceiver
:
:
RTCRtpReceiver
(
nsPIDOMWindowInner
*
aWindow
bool
aPrivacyNeeded
const
std
:
:
string
&
aPCHandle
MediaTransportHandler
*
aTransportHandler
JsepTransceiver
*
aJsepTransceiver
nsISerialEventTarget
*
aMainThread
AbstractThread
*
aCallThread
nsISerialEventTarget
*
aStsThread
MediaSessionConduit
*
aConduit
RTCStatsIdGenerator
*
aIdGenerator
TransceiverImpl
*
aTransceiverImpl
)
:
mWindow
(
aWindow
)
mPCHandle
(
aPCHandle
)
mJsepTransceiver
(
aJsepTransceiver
)
mMainThread
(
aMainThread
)
mCallThread
(
aCallThread
)
mStsThread
(
aStsThread
)
mTransportHandler
(
aTransportHandler
)
mIdGenerator
(
aIdGenerator
)
mTransceiverImpl
(
aTransceiverImpl
)
INIT_CANONICAL
(
mSsrc
0
)
INIT_CANONICAL
(
mVideoRtxSsrc
0
)
INIT_CANONICAL
(
mLocalRtpExtensions
RtpExtList
(
)
)
INIT_CANONICAL
(
mAudioCodecs
std
:
:
vector
<
AudioCodecConfig
>
(
)
)
INIT_CANONICAL
(
mVideoCodecs
std
:
:
vector
<
VideoCodecConfig
>
(
)
)
INIT_CANONICAL
(
mVideoRtpRtcpConfig
Nothing
(
)
)
{
PrincipalHandle
principalHandle
=
GetPrincipalHandle
(
aWindow
aPrivacyNeeded
)
;
mTrack
=
CreateTrack
(
aWindow
aConduit
-
>
type
(
)
=
=
MediaSessionConduit
:
:
AUDIO
principalHandle
.
get
(
)
)
;
if
(
Preferences
:
:
GetBool
(
"
media
.
peerconnection
.
mute_on_bye_or_timeout
"
false
)
)
{
mRtcpByeListener
=
aConduit
-
>
RtcpByeEvent
(
)
.
Connect
(
mMainThread
this
&
RTCRtpReceiver
:
:
OnRtcpBye
)
;
mRtcpTimeoutListener
=
aConduit
-
>
RtcpTimeoutEvent
(
)
.
Connect
(
mMainThread
this
&
RTCRtpReceiver
:
:
OnRtcpTimeout
)
;
}
if
(
aConduit
-
>
type
(
)
=
=
MediaSessionConduit
:
:
AUDIO
)
{
mPipeline
=
new
MediaPipelineReceiveAudio
(
mPCHandle
aTransportHandler
mMainThread
.
get
(
)
aCallThread
mStsThread
.
get
(
)
*
aConduit
-
>
AsAudioSessionConduit
(
)
mTrack
principalHandle
)
;
}
else
{
mPipeline
=
new
MediaPipelineReceiveVideo
(
mPCHandle
aTransportHandler
mMainThread
.
get
(
)
aCallThread
mStsThread
.
get
(
)
*
aConduit
-
>
AsVideoSessionConduit
(
)
mTrack
principalHandle
)
;
}
}
#
undef
INIT_CANONICAL
RTCRtpReceiver
:
:
~
RTCRtpReceiver
(
)
{
MOZ_ASSERT
(
!
mPipeline
)
;
}
JSObject
*
RTCRtpReceiver
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
RTCRtpReceiver_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
RTCDtlsTransport
*
RTCRtpReceiver
:
:
GetTransport
(
)
const
{
if
(
!
mTransceiverImpl
)
{
return
nullptr
;
}
return
mTransceiverImpl
-
>
GetDtlsTransport
(
)
;
}
already_AddRefed
<
Promise
>
RTCRtpReceiver
:
:
GetStats
(
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
mWindow
)
;
ErrorResult
rv
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
rv
.
StealNSResult
(
)
;
return
nullptr
;
}
auto
promises
=
GetStatsInternal
(
)
;
RTCStatsPromise
:
:
All
(
mMainThread
promises
)
-
>
Then
(
mMainThread
__func__
[
promise
window
=
mWindow
idGen
=
mIdGenerator
]
(
const
nsTArray
<
UniquePtr
<
RTCStatsCollection
>
>
&
aStats
)
{
RTCStatsCollection
opaqueStats
;
idGen
-
>
RewriteIds
(
aStats
&
opaqueStats
)
;
RefPtr
<
RTCStatsReport
>
report
(
new
RTCStatsReport
(
window
)
)
;
report
-
>
Incorporate
(
opaqueStats
)
;
promise
-
>
MaybeResolve
(
std
:
:
move
(
report
)
)
;
}
[
promise
]
(
nsresult
aError
)
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
}
)
;
return
promise
.
forget
(
)
;
}
nsTArray
<
RefPtr
<
RTCStatsPromise
>
>
RTCRtpReceiver
:
:
GetStatsInternal
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
RefPtr
<
RTCStatsPromise
>
>
promises
(
3
)
;
if
(
!
mPipeline
)
{
return
promises
;
}
if
(
!
mHaveStartedReceiving
)
{
return
promises
;
}
nsString
recvTrackId
;
MOZ_ASSERT
(
mTrack
)
;
if
(
mTrack
)
{
mTrack
-
>
GetId
(
recvTrackId
)
;
}
{
promises
.
AppendElement
(
InvokeAsync
(
mCallThread
__func__
[
conduit
=
mPipeline
-
>
mConduit
recvTrackId
]
(
)
mutable
{
auto
report
=
MakeUnique
<
dom
:
:
RTCStatsCollection
>
(
)
;
const
Maybe
<
webrtc
:
:
Call
:
:
Stats
>
stats
=
conduit
-
>
GetCallStats
(
)
;
stats
.
apply
(
[
&
]
(
const
auto
&
aStats
)
{
dom
:
:
RTCBandwidthEstimationInternal
bw
;
bw
.
mTrackIdentifier
=
recvTrackId
;
bw
.
mSendBandwidthBps
.
Construct
(
aStats
.
send_bandwidth_bps
/
8
)
;
bw
.
mMaxPaddingBps
.
Construct
(
aStats
.
max_padding_bitrate_bps
/
8
)
;
bw
.
mReceiveBandwidthBps
.
Construct
(
aStats
.
recv_bandwidth_bps
/
8
)
;
bw
.
mPacerDelayMs
.
Construct
(
aStats
.
pacer_delay_ms
)
;
if
(
aStats
.
rtt_ms
>
=
0
)
{
bw
.
mRttMs
.
Construct
(
aStats
.
rtt_ms
)
;
}
if
(
!
report
-
>
mBandwidthEstimations
.
AppendElement
(
std
:
:
move
(
bw
)
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
)
;
return
RTCStatsPromise
:
:
CreateAndResolve
(
std
:
:
move
(
report
)
__func__
)
;
}
)
)
;
}
promises
.
AppendElement
(
InvokeAsync
(
mCallThread
__func__
[
pipeline
=
mPipeline
recvTrackId
]
{
auto
report
=
MakeUnique
<
dom
:
:
RTCStatsCollection
>
(
)
;
auto
asAudio
=
pipeline
-
>
mConduit
-
>
AsAudioSessionConduit
(
)
;
auto
asVideo
=
pipeline
-
>
mConduit
-
>
AsVideoSessionConduit
(
)
;
nsString
kind
=
asVideo
.
isNothing
(
)
?
u
"
audio
"
_ns
:
u
"
video
"
_ns
;
nsString
idstr
=
kind
+
u
"
_
"
_ns
;
idstr
.
AppendInt
(
static_cast
<
uint32_t
>
(
pipeline
-
>
Level
(
)
)
)
;
Maybe
<
uint32_t
>
ssrc
=
pipeline
-
>
mConduit
-
>
GetRemoteSSRC
(
)
;
asVideo
.
apply
(
[
&
]
(
const
auto
&
conduit
)
{
if
(
conduit
-
>
AddFrameHistory
(
&
report
-
>
mVideoFrameHistories
)
)
{
auto
&
history
=
report
-
>
mVideoFrameHistories
.
LastElement
(
)
;
history
.
mTrackIdentifier
=
recvTrackId
;
}
}
)
;
nsString
localId
=
u
"
inbound_rtp_
"
_ns
+
idstr
;
nsString
remoteId
;
auto
constructCommonRemoteOutboundRtpStats
=
[
&
]
(
RTCRemoteOutboundRtpStreamStats
&
aRemote
const
DOMHighResTimeStamp
&
aTimestamp
)
{
remoteId
=
u
"
inbound_rtcp_
"
_ns
+
idstr
;
aRemote
.
mTimestamp
.
Construct
(
aTimestamp
)
;
aRemote
.
mId
.
Construct
(
remoteId
)
;
aRemote
.
mType
.
Construct
(
RTCStatsType
:
:
Remote_outbound_rtp
)
;
ssrc
.
apply
(
[
&
]
(
uint32_t
aSsrc
)
{
aRemote
.
mSsrc
.
Construct
(
aSsrc
)
;
}
)
;
aRemote
.
mMediaType
.
Construct
(
kind
)
;
aRemote
.
mKind
.
Construct
(
kind
)
;
aRemote
.
mLocalId
.
Construct
(
localId
)
;
}
;
auto
constructCommonInboundRtpStats
=
[
&
]
(
RTCInboundRtpStreamStats
&
aLocal
)
{
aLocal
.
mTimestamp
.
Construct
(
pipeline
-
>
GetTimestampMaker
(
)
.
GetNow
(
)
)
;
aLocal
.
mId
.
Construct
(
localId
)
;
aLocal
.
mType
.
Construct
(
RTCStatsType
:
:
Inbound_rtp
)
;
ssrc
.
apply
(
[
&
]
(
uint32_t
aSsrc
)
{
aLocal
.
mSsrc
.
Construct
(
aSsrc
)
;
}
)
;
aLocal
.
mMediaType
.
Construct
(
kind
)
;
aLocal
.
mKind
.
Construct
(
kind
)
;
if
(
remoteId
.
Length
(
)
)
{
aLocal
.
mRemoteId
.
Construct
(
remoteId
)
;
}
}
;
asAudio
.
apply
(
[
&
]
(
auto
&
aConduit
)
{
Maybe
<
webrtc
:
:
AudioReceiveStream
:
:
Stats
>
audioStats
=
aConduit
-
>
GetReceiverStats
(
)
;
if
(
audioStats
.
isNothing
(
)
)
{
return
;
}
if
(
!
audioStats
-
>
last_packet_received_timestamp_ms
)
{
return
;
}
if
(
audioStats
-
>
last_sender_report_timestamp_ms
)
{
RTCRemoteOutboundRtpStreamStats
remote
;
constructCommonRemoteOutboundRtpStats
(
remote
aConduit
-
>
GetTimestampMaker
(
)
.
ConvertNtpToDomTime
(
webrtc
:
:
Timestamp
:
:
Millis
(
*
audioStats
-
>
last_sender_report_timestamp_ms
)
+
webrtc
:
:
TimeDelta
:
:
Seconds
(
webrtc
:
:
kNtpJan1970
)
)
)
;
remote
.
mPacketsSent
.
Construct
(
audioStats
-
>
sender_reports_packets_sent
)
;
remote
.
mBytesSent
.
Construct
(
audioStats
-
>
sender_reports_bytes_sent
)
;
remote
.
mRemoteTimestamp
.
Construct
(
*
audioStats
-
>
last_sender_report_remote_timestamp_ms
)
;
if
(
!
report
-
>
mRemoteOutboundRtpStreamStats
.
AppendElement
(
std
:
:
move
(
remote
)
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
RTCInboundRtpStreamStats
local
;
constructCommonInboundRtpStats
(
local
)
;
local
.
mJitter
.
Construct
(
audioStats
-
>
jitter_ms
/
1000
.
0
)
;
local
.
mPacketsLost
.
Construct
(
audioStats
-
>
packets_lost
)
;
local
.
mPacketsReceived
.
Construct
(
audioStats
-
>
packets_rcvd
)
;
local
.
mPacketsDiscarded
.
Construct
(
audioStats
-
>
packets_discarded
)
;
local
.
mBytesReceived
.
Construct
(
audioStats
-
>
payload_bytes_rcvd
)
;
if
(
!
report
-
>
mInboundRtpStreamStats
.
AppendElement
(
std
:
:
move
(
local
)
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
)
;
asVideo
.
apply
(
[
&
]
(
auto
&
aConduit
)
{
Maybe
<
webrtc
:
:
VideoReceiveStream
:
:
Stats
>
videoStats
=
aConduit
-
>
GetReceiverStats
(
)
;
if
(
videoStats
.
isNothing
(
)
)
{
return
;
}
if
(
!
videoStats
-
>
rtp_stats
.
last_packet_received_timestamp_ms
)
{
return
;
}
if
(
videoStats
-
>
rtcp_sender_ntp_timestamp_ms
)
{
RTCRemoteOutboundRtpStreamStats
remote
;
constructCommonRemoteOutboundRtpStats
(
remote
aConduit
-
>
GetTimestampMaker
(
)
.
ConvertNtpToDomTime
(
webrtc
:
:
Timestamp
:
:
Millis
(
videoStats
-
>
rtcp_sender_ntp_timestamp_ms
)
)
)
;
remote
.
mPacketsSent
.
Construct
(
videoStats
-
>
rtcp_sender_packets_sent
)
;
remote
.
mBytesSent
.
Construct
(
videoStats
-
>
rtcp_sender_octets_sent
)
;
remote
.
mRemoteTimestamp
.
Construct
(
(
webrtc
:
:
Timestamp
:
:
Millis
(
videoStats
-
>
rtcp_sender_remote_ntp_timestamp_ms
)
-
webrtc
:
:
TimeDelta
:
:
Seconds
(
webrtc
:
:
kNtpJan1970
)
)
.
ms
(
)
)
;
if
(
!
report
-
>
mRemoteOutboundRtpStreamStats
.
AppendElement
(
std
:
:
move
(
remote
)
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
RTCInboundRtpStreamStats
local
;
constructCommonInboundRtpStats
(
local
)
;
local
.
mJitter
.
Construct
(
static_cast
<
double
>
(
videoStats
-
>
rtp_stats
.
jitter
)
/
webrtc
:
:
kVideoPayloadTypeFrequency
)
;
local
.
mPacketsLost
.
Construct
(
videoStats
-
>
rtp_stats
.
packets_lost
)
;
local
.
mPacketsReceived
.
Construct
(
videoStats
-
>
rtp_stats
.
packet_counter
.
packets
)
;
local
.
mPacketsDiscarded
.
Construct
(
videoStats
-
>
packets_discarded
)
;
local
.
mDiscardedPackets
.
Construct
(
videoStats
-
>
packets_discarded
)
;
local
.
mBytesReceived
.
Construct
(
videoStats
-
>
rtp_stats
.
packet_counter
.
payload_bytes
)
;
local
.
mNackCount
.
Construct
(
videoStats
-
>
rtcp_packet_type_counts
.
nack_packets
)
;
local
.
mFirCount
.
Construct
(
videoStats
-
>
rtcp_packet_type_counts
.
fir_packets
)
;
local
.
mPliCount
.
Construct
(
videoStats
-
>
rtcp_packet_type_counts
.
pli_packets
)
;
local
.
mFramesDecoded
.
Construct
(
videoStats
-
>
frames_decoded
)
;
if
(
!
report
-
>
mInboundRtpStreamStats
.
AppendElement
(
std
:
:
move
(
local
)
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
)
;
return
RTCStatsPromise
:
:
CreateAndResolve
(
std
:
:
move
(
report
)
__func__
)
;
}
)
-
>
Then
(
mStsThread
__func__
[
pipeline
=
mPipeline
]
(
UniquePtr
<
RTCStatsCollection
>
aReport
)
{
if
(
!
aReport
-
>
mInboundRtpStreamStats
.
IsEmpty
(
)
&
&
aReport
-
>
mInboundRtpStreamStats
[
0
]
.
mId
.
WasPassed
(
)
)
{
pipeline
-
>
GetContributingSourceStats
(
aReport
-
>
mInboundRtpStreamStats
[
0
]
.
mId
.
Value
(
)
aReport
-
>
mRtpContributingSourceStats
)
;
}
return
RTCStatsPromise
:
:
CreateAndResolve
(
std
:
:
move
(
aReport
)
__func__
)
;
}
[
]
{
MOZ_CRASH
(
"
Unexpected
reject
"
)
;
return
RTCStatsPromise
:
:
CreateAndReject
(
NS_ERROR_UNEXPECTED
__func__
)
;
}
)
)
;
if
(
mJsepTransceiver
-
>
mTransport
.
mComponents
)
{
promises
.
AppendElement
(
mTransportHandler
-
>
GetIceStats
(
mJsepTransceiver
-
>
mTransport
.
mTransportId
mPipeline
-
>
GetTimestampMaker
(
)
.
GetNow
(
)
)
)
;
}
return
promises
;
}
void
RTCRtpReceiver
:
:
GetContributingSources
(
nsTArray
<
RTCRtpContributingSource
>
&
aSources
)
{
if
(
mPipeline
&
&
mPipeline
-
>
mConduit
)
{
nsTArray
<
dom
:
:
RTCRtpSourceEntry
>
sources
;
mPipeline
-
>
mConduit
-
>
GetRtpSources
(
sources
)
;
sources
.
RemoveElementsBy
(
[
]
(
const
dom
:
:
RTCRtpSourceEntry
&
aEntry
)
{
return
aEntry
.
mSourceType
!
=
dom
:
:
RTCRtpSourceEntryType
:
:
Contributing
;
}
)
;
aSources
.
ReplaceElementsAt
(
0
aSources
.
Length
(
)
sources
.
Elements
(
)
sources
.
Length
(
)
)
;
}
}
void
RTCRtpReceiver
:
:
GetSynchronizationSources
(
nsTArray
<
dom
:
:
RTCRtpSynchronizationSource
>
&
aSources
)
{
if
(
mPipeline
&
&
mPipeline
-
>
mConduit
)
{
nsTArray
<
dom
:
:
RTCRtpSourceEntry
>
sources
;
mPipeline
-
>
mConduit
-
>
GetRtpSources
(
sources
)
;
sources
.
RemoveElementsBy
(
[
]
(
const
dom
:
:
RTCRtpSourceEntry
&
aEntry
)
{
return
aEntry
.
mSourceType
!
=
dom
:
:
RTCRtpSourceEntryType
:
:
Synchronization
;
}
)
;
aSources
.
ReplaceElementsAt
(
0
aSources
.
Length
(
)
sources
.
Elements
(
)
sources
.
Length
(
)
)
;
}
}
nsPIDOMWindowInner
*
RTCRtpReceiver
:
:
GetParentObject
(
)
const
{
return
mWindow
;
}
void
RTCRtpReceiver
:
:
Shutdown
(
)
{
ASSERT_ON_THREAD
(
mMainThread
)
;
if
(
mPipeline
)
{
mPipeline
-
>
Shutdown
(
)
;
mPipeline
=
nullptr
;
}
mTransceiverImpl
=
nullptr
;
mCallThread
=
nullptr
;
mRtcpByeListener
.
DisconnectIfExists
(
)
;
mRtcpTimeoutListener
.
DisconnectIfExists
(
)
;
}
void
RTCRtpReceiver
:
:
UpdateTransport
(
)
{
ASSERT_ON_THREAD
(
mMainThread
)
;
if
(
!
mHaveSetupTransport
)
{
mPipeline
-
>
SetLevel
(
mJsepTransceiver
-
>
GetLevel
(
)
)
;
mHaveSetupTransport
=
true
;
}
UniquePtr
<
MediaPipelineFilter
>
filter
;
auto
const
&
details
=
mJsepTransceiver
-
>
mRecvTrack
.
GetNegotiatedDetails
(
)
;
if
(
mJsepTransceiver
-
>
HasBundleLevel
(
)
&
&
details
)
{
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
extmaps
;
details
-
>
ForEachRTPHeaderExtension
(
[
&
extmaps
]
(
const
SdpExtmapAttributeList
:
:
Extmap
&
extmap
)
{
extmaps
.
emplace_back
(
extmap
.
extensionname
extmap
.
entry
)
;
}
)
;
filter
=
MakeUnique
<
MediaPipelineFilter
>
(
extmaps
)
;
for
(
uint32_t
ssrc
:
mJsepTransceiver
-
>
mRecvTrack
.
GetSsrcs
(
)
)
{
filter
-
>
AddRemoteSSRC
(
ssrc
)
;
}
for
(
uint32_t
ssrc
:
mJsepTransceiver
-
>
mRecvTrack
.
GetRtxSsrcs
(
)
)
{
filter
-
>
AddRemoteSSRC
(
ssrc
)
;
}
auto
mid
=
Maybe
<
std
:
:
string
>
(
)
;
if
(
GetMid
(
)
!
=
"
"
)
{
mid
=
Some
(
GetMid
(
)
)
;
}
filter
-
>
SetRemoteMediaStreamId
(
mid
)
;
auto
uniquePts
=
mJsepTransceiver
-
>
mRecvTrack
.
GetNegotiatedDetails
(
)
-
>
GetUniquePayloadTypes
(
)
;
for
(
unsigned
char
&
uniquePt
:
uniquePts
)
{
filter
-
>
AddUniquePT
(
uniquePt
)
;
}
}
mPipeline
-
>
UpdateTransport_m
(
mJsepTransceiver
-
>
mTransport
.
mTransportId
std
:
:
move
(
filter
)
)
;
}
nsresult
RTCRtpReceiver
:
:
UpdateConduit
(
)
{
if
(
mPipeline
-
>
mConduit
-
>
type
(
)
=
=
MediaSessionConduit
:
:
VIDEO
)
{
return
UpdateVideoConduit
(
)
;
}
return
UpdateAudioConduit
(
)
;
}
nsresult
RTCRtpReceiver
:
:
UpdateVideoConduit
(
)
{
RefPtr
<
VideoSessionConduit
>
conduit
=
*
mPipeline
-
>
mConduit
-
>
AsVideoSessionConduit
(
)
;
if
(
!
mJsepTransceiver
-
>
mRecvTrack
.
GetSsrcs
(
)
.
empty
(
)
)
{
MOZ_LOG
(
gReceiverLog
LogLevel
:
:
Debug
(
"
%
s
[
%
s
]
:
%
s
Setting
remote
SSRC
%
u
"
mPCHandle
.
c_str
(
)
GetMid
(
)
.
c_str
(
)
__FUNCTION__
mJsepTransceiver
-
>
mRecvTrack
.
GetSsrcs
(
)
.
front
(
)
)
)
;
uint32_t
rtxSsrc
=
mJsepTransceiver
-
>
mRecvTrack
.
GetRtxSsrcs
(
)
.
empty
(
)
?
0
:
mJsepTransceiver
-
>
mRecvTrack
.
GetRtxSsrcs
(
)
.
front
(
)
;
mSsrc
=
mJsepTransceiver
-
>
mRecvTrack
.
GetSsrcs
(
)
.
front
(
)
;
mVideoRtxSsrc
=
rtxSsrc
;
}
if
(
mJsepTransceiver
-
>
HasBundleLevel
(
)
&
&
(
!
mJsepTransceiver
-
>
mRecvTrack
.
GetNegotiatedDetails
(
)
|
|
!
mJsepTransceiver
-
>
mRecvTrack
.
GetNegotiatedDetails
(
)
-
>
GetExt
(
webrtc
:
:
RtpExtension
:
:
kMidUri
)
)
)
{
mCallThread
-
>
Dispatch
(
NewRunnableMethod
(
"
VideoSessionConduit
:
:
DisableSsrcChanges
"
conduit
&
VideoSessionConduit
:
:
DisableSsrcChanges
)
)
;
}
if
(
mJsepTransceiver
-
>
mRecvTrack
.
GetNegotiatedDetails
(
)
&
&
mJsepTransceiver
-
>
mRecvTrack
.
GetActive
(
)
)
{
const
auto
&
details
(
*
mJsepTransceiver
-
>
mRecvTrack
.
GetNegotiatedDetails
(
)
)
;
{
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
extmaps
;
details
.
ForEachRTPHeaderExtension
(
[
&
extmaps
]
(
const
SdpExtmapAttributeList
:
:
Extmap
&
extmap
)
{
extmaps
.
emplace_back
(
extmap
.
extensionname
extmap
.
entry
)
;
}
)
;
mLocalRtpExtensions
=
extmaps
;
}
std
:
:
vector
<
VideoCodecConfig
>
configs
;
nsresult
rv
=
TransceiverImpl
:
:
NegotiatedDetailsToVideoCodecConfigs
(
details
&
configs
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gReceiverLog
LogLevel
:
:
Error
(
"
%
s
[
%
s
]
:
%
s
Failed
to
convert
"
"
JsepCodecDescriptions
to
VideoCodecConfigs
(
recv
)
.
"
mPCHandle
.
c_str
(
)
GetMid
(
)
.
c_str
(
)
__FUNCTION__
)
)
;
return
rv
;
}
mVideoCodecs
=
configs
;
mVideoRtpRtcpConfig
=
Some
(
details
.
GetRtpRtcpConfig
(
)
)
;
}
return
NS_OK
;
}
nsresult
RTCRtpReceiver
:
:
UpdateAudioConduit
(
)
{
RefPtr
<
AudioSessionConduit
>
conduit
=
*
mPipeline
-
>
mConduit
-
>
AsAudioSessionConduit
(
)
;
if
(
!
mJsepTransceiver
-
>
mRecvTrack
.
GetSsrcs
(
)
.
empty
(
)
)
{
MOZ_LOG
(
gReceiverLog
LogLevel
:
:
Debug
(
"
%
s
[
%
s
]
:
%
s
Setting
remote
SSRC
%
u
"
mPCHandle
.
c_str
(
)
GetMid
(
)
.
c_str
(
)
__FUNCTION__
mJsepTransceiver
-
>
mRecvTrack
.
GetSsrcs
(
)
.
front
(
)
)
)
;
mSsrc
=
mJsepTransceiver
-
>
mRecvTrack
.
GetSsrcs
(
)
.
front
(
)
;
}
if
(
mJsepTransceiver
-
>
mRecvTrack
.
GetNegotiatedDetails
(
)
&
&
mJsepTransceiver
-
>
mRecvTrack
.
GetActive
(
)
)
{
const
auto
&
details
(
*
mJsepTransceiver
-
>
mRecvTrack
.
GetNegotiatedDetails
(
)
)
;
std
:
:
vector
<
AudioCodecConfig
>
configs
;
nsresult
rv
=
TransceiverImpl
:
:
NegotiatedDetailsToAudioCodecConfigs
(
details
&
configs
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gReceiverLog
LogLevel
:
:
Error
(
"
%
s
[
%
s
]
:
%
s
Failed
to
convert
"
"
JsepCodecDescriptions
to
AudioCodecConfigs
(
recv
)
.
"
mPCHandle
.
c_str
(
)
GetMid
(
)
.
c_str
(
)
__FUNCTION__
)
)
;
return
rv
;
}
{
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
extmaps
;
details
.
ForEachRTPHeaderExtension
(
[
&
extmaps
]
(
const
SdpExtmapAttributeList
:
:
Extmap
&
extmap
)
{
extmaps
.
emplace_back
(
extmap
.
extensionname
extmap
.
entry
)
;
}
)
;
mLocalRtpExtensions
=
extmaps
;
}
mAudioCodecs
=
configs
;
}
return
NS_OK
;
}
void
RTCRtpReceiver
:
:
Stop
(
)
{
if
(
mPipeline
)
{
mPipeline
-
>
Stop
(
)
;
}
}
void
RTCRtpReceiver
:
:
Start
(
)
{
mPipeline
-
>
Start
(
)
;
mHaveStartedReceiving
=
true
;
}
bool
RTCRtpReceiver
:
:
HasTrack
(
const
dom
:
:
MediaStreamTrack
*
aTrack
)
const
{
return
!
aTrack
|
|
(
mTrack
=
=
aTrack
)
;
}
void
RTCRtpReceiver
:
:
UpdateStreams
(
StreamAssociationChanges
*
aChanges
)
{
std
:
:
set
<
std
:
:
string
>
newIds
(
mJsepTransceiver
-
>
mRecvTrack
.
GetStreamIds
(
)
.
begin
(
)
mJsepTransceiver
-
>
mRecvTrack
.
GetStreamIds
(
)
.
end
(
)
)
;
MOZ_ASSERT
(
mJsepTransceiver
-
>
mRecvTrack
.
GetRemoteSetSendBit
(
)
|
|
newIds
.
empty
(
)
)
;
bool
needsTrackEvent
=
false
;
for
(
const
auto
&
id
:
mStreamIds
)
{
if
(
!
newIds
.
count
(
id
)
)
{
aChanges
-
>
mStreamAssociationsRemoved
.
push_back
(
{
mTrack
id
}
)
;
}
}
std
:
:
set
<
std
:
:
string
>
oldIds
(
mStreamIds
.
begin
(
)
mStreamIds
.
end
(
)
)
;
for
(
const
auto
&
id
:
mJsepTransceiver
-
>
mRecvTrack
.
GetStreamIds
(
)
)
{
if
(
!
oldIds
.
count
(
id
)
)
{
needsTrackEvent
=
true
;
aChanges
-
>
mStreamAssociationsAdded
.
push_back
(
{
mTrack
id
}
)
;
}
}
mStreamIds
=
mJsepTransceiver
-
>
mRecvTrack
.
GetStreamIds
(
)
;
if
(
mRemoteSetSendBit
!
=
mJsepTransceiver
-
>
mRecvTrack
.
GetRemoteSetSendBit
(
)
)
{
mRemoteSetSendBit
=
mJsepTransceiver
-
>
mRecvTrack
.
GetRemoteSetSendBit
(
)
;
if
(
mRemoteSetSendBit
)
{
needsTrackEvent
=
true
;
}
else
{
aChanges
-
>
mTracksToMute
.
push_back
(
mTrack
)
;
}
}
if
(
needsTrackEvent
)
{
aChanges
-
>
mTrackEvents
.
push_back
(
{
this
mStreamIds
}
)
;
}
}
void
RTCRtpReceiver
:
:
MozInsertAudioLevelForContributingSource
(
const
uint32_t
aSource
const
DOMHighResTimeStamp
aTimestamp
const
uint32_t
aRtpTimestamp
const
bool
aHasLevel
const
uint8_t
aLevel
)
{
if
(
!
mPipeline
|
|
mPipeline
-
>
IsVideo
(
)
|
|
!
mPipeline
-
>
mConduit
)
{
return
;
}
mPipeline
-
>
mConduit
-
>
InsertAudioLevelForContributingSource
(
aSource
aTimestamp
aRtpTimestamp
aHasLevel
aLevel
)
;
}
void
RTCRtpReceiver
:
:
OnRtcpBye
(
)
{
SetReceiveTrackMuted
(
true
)
;
}
void
RTCRtpReceiver
:
:
OnRtcpTimeout
(
)
{
SetReceiveTrackMuted
(
true
)
;
}
void
RTCRtpReceiver
:
:
SetReceiveTrackMuted
(
bool
aMuted
)
{
if
(
mTrack
)
{
static_cast
<
RemoteTrackSource
&
>
(
mTrack
-
>
GetSource
(
)
)
.
SetMuted
(
aMuted
)
;
}
}
std
:
:
string
RTCRtpReceiver
:
:
GetMid
(
)
const
{
if
(
mJsepTransceiver
-
>
IsAssociated
(
)
)
{
return
mJsepTransceiver
-
>
GetMid
(
)
;
}
return
std
:
:
string
(
)
;
}
}
#
undef
LOGTAG
