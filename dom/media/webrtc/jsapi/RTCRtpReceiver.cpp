#
include
"
RTCRtpReceiver
.
h
"
#
include
"
PeerConnectionImpl
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpCapabilitiesBinding
.
h
"
#
include
"
transport
/
logging
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamTrack
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
PrincipalHandle
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
MediaTrackGraph
.
h
"
#
include
"
RemoteTrackSource
.
h
"
#
include
"
libwebrtcglue
/
RtpRtcpConfig
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
dom
/
AudioStreamTrack
.
h
"
#
include
"
mozilla
/
dom
/
VideoStreamTrack
.
h
"
#
include
"
MediaTransportHandler
.
h
"
#
include
"
jsep
/
JsepTransceiver
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpReceiverBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpSourcesBinding
.
h
"
#
include
"
RTCStatsReport
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
PeerConnectionCtx
.
h
"
#
include
"
RTCRtpTransceiver
.
h
"
#
include
"
libwebrtcglue
/
AudioConduit
.
h
"
#
include
"
call
/
call
.
h
"
namespace
mozilla
:
:
dom
{
LazyLogModule
gReceiverLog
(
"
RTCRtpReceiver
"
)
;
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
RTCRtpReceiver
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
RTCRtpReceiver
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
RTCRtpReceiver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mWindow
mPc
mTransceiver
mTrack
mTrackSource
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
RTCRtpReceiver
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
RTCRtpReceiver
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
RTCRtpReceiver
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
static
PrincipalHandle
GetPrincipalHandle
(
nsPIDOMWindowInner
*
aWindow
PrincipalPrivacy
aPrivacy
)
{
nsCOMPtr
<
nsIScriptObjectPrincipal
>
winPrincipal
=
do_QueryInterface
(
aWindow
)
;
RefPtr
<
nsIPrincipal
>
principal
=
winPrincipal
-
>
GetPrincipal
(
)
;
if
(
NS_WARN_IF
(
!
principal
)
)
{
principal
=
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
}
else
if
(
aPrivacy
=
=
PrincipalPrivacy
:
:
Private
)
{
principal
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
principal
)
;
}
return
MakePrincipalHandle
(
principal
)
;
}
#
define
INIT_CANONICAL
(
name
val
)
\
name
(
AbstractThread
:
:
MainThread
(
)
val
\
"
RTCRtpReceiver
:
:
"
#
name
"
(
Canonical
)
"
)
RTCRtpReceiver
:
:
RTCRtpReceiver
(
nsPIDOMWindowInner
*
aWindow
PrincipalPrivacy
aPrivacy
PeerConnectionImpl
*
aPc
MediaTransportHandler
*
aTransportHandler
AbstractThread
*
aCallThread
nsISerialEventTarget
*
aStsThread
MediaSessionConduit
*
aConduit
RTCRtpTransceiver
*
aTransceiver
const
TrackingId
&
aTrackingId
)
:
mWatchManager
(
this
AbstractThread
:
:
MainThread
(
)
)
mWindow
(
aWindow
)
mPc
(
aPc
)
mCallThread
(
aCallThread
)
mStsThread
(
aStsThread
)
mTransportHandler
(
aTransportHandler
)
mTransceiver
(
aTransceiver
)
INIT_CANONICAL
(
mSsrc
0
)
INIT_CANONICAL
(
mVideoRtxSsrc
0
)
INIT_CANONICAL
(
mLocalRtpExtensions
RtpExtList
(
)
)
INIT_CANONICAL
(
mAudioCodecs
std
:
:
vector
<
AudioCodecConfig
>
(
)
)
INIT_CANONICAL
(
mVideoCodecs
std
:
:
vector
<
VideoCodecConfig
>
(
)
)
INIT_CANONICAL
(
mVideoRtpRtcpConfig
Nothing
(
)
)
INIT_CANONICAL
(
mReceiving
false
)
{
PrincipalHandle
principalHandle
=
GetPrincipalHandle
(
aWindow
aPrivacy
)
;
const
bool
isAudio
=
aConduit
-
>
type
(
)
=
=
MediaSessionConduit
:
:
AUDIO
;
MediaTrackGraph
*
graph
=
MediaTrackGraph
:
:
GetInstance
(
isAudio
?
MediaTrackGraph
:
:
AUDIO_THREAD_DRIVER
:
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
aWindow
MediaTrackGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
MediaTrackGraph
:
:
DEFAULT_OUTPUT_DEVICE
)
;
if
(
isAudio
)
{
auto
*
source
=
graph
-
>
CreateSourceTrack
(
MediaSegment
:
:
AUDIO
)
;
mTrackSource
=
MakeAndAddRef
<
RemoteTrackSource
>
(
source
this
principalHandle
u
"
remote
audio
"
_ns
aTrackingId
)
;
mTrack
=
MakeAndAddRef
<
AudioStreamTrack
>
(
aWindow
source
mTrackSource
)
;
mPipeline
=
MakeAndAddRef
<
MediaPipelineReceiveAudio
>
(
mPc
-
>
GetHandle
(
)
aTransportHandler
aCallThread
mStsThread
.
get
(
)
*
aConduit
-
>
AsAudioSessionConduit
(
)
mTrackSource
-
>
Stream
(
)
aTrackingId
principalHandle
aPrivacy
)
;
}
else
{
auto
*
source
=
graph
-
>
CreateSourceTrack
(
MediaSegment
:
:
VIDEO
)
;
mTrackSource
=
MakeAndAddRef
<
RemoteTrackSource
>
(
source
this
principalHandle
u
"
remote
video
"
_ns
aTrackingId
)
;
mTrack
=
MakeAndAddRef
<
VideoStreamTrack
>
(
aWindow
source
mTrackSource
)
;
mPipeline
=
MakeAndAddRef
<
MediaPipelineReceiveVideo
>
(
mPc
-
>
GetHandle
(
)
aTransportHandler
aCallThread
mStsThread
.
get
(
)
*
aConduit
-
>
AsVideoSessionConduit
(
)
mTrackSource
-
>
Stream
(
)
aTrackingId
principalHandle
aPrivacy
)
;
}
mPipeline
-
>
InitControl
(
this
)
;
mTrackSource
-
>
SetMuted
(
true
)
;
if
(
Preferences
:
:
GetBool
(
"
media
.
peerconnection
.
mute_on_bye_or_timeout
"
false
)
)
{
mRtcpByeListener
=
aConduit
-
>
RtcpByeEvent
(
)
.
Connect
(
GetMainThreadSerialEventTarget
(
)
this
&
RTCRtpReceiver
:
:
OnRtcpBye
)
;
mRtcpTimeoutListener
=
aConduit
-
>
RtcpTimeoutEvent
(
)
.
Connect
(
GetMainThreadSerialEventTarget
(
)
this
&
RTCRtpReceiver
:
:
OnRtcpTimeout
)
;
}
mWatchManager
.
Watch
(
mReceiveTrackMute
&
RTCRtpReceiver
:
:
UpdateReceiveTrackMute
)
;
}
#
undef
INIT_CANONICAL
RTCRtpReceiver
:
:
~
RTCRtpReceiver
(
)
{
MOZ_ASSERT
(
!
mPipeline
)
;
}
JSObject
*
RTCRtpReceiver
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
RTCRtpReceiver_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
RTCDtlsTransport
*
RTCRtpReceiver
:
:
GetTransport
(
)
const
{
if
(
!
mTransceiver
)
{
return
nullptr
;
}
return
mTransceiver
-
>
GetDtlsTransport
(
)
;
}
void
RTCRtpReceiver
:
:
GetCapabilities
(
const
GlobalObject
&
const
nsAString
&
aKind
Nullable
<
dom
:
:
RTCRtpCapabilities
>
&
aResult
)
{
PeerConnectionImpl
:
:
GetCapabilities
(
aKind
aResult
sdp
:
:
Direction
:
:
kRecv
)
;
}
already_AddRefed
<
Promise
>
RTCRtpReceiver
:
:
GetStats
(
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
mWindow
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
aError
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
mTransceiver
)
)
{
promise
-
>
MaybeResolve
(
new
RTCStatsReport
(
mWindow
)
)
;
return
promise
.
forget
(
)
;
}
mTransceiver
-
>
ChainToDomPromiseWithCodecStats
(
GetStatsInternal
(
)
promise
)
;
return
promise
.
forget
(
)
;
}
nsTArray
<
RefPtr
<
RTCStatsPromise
>
>
RTCRtpReceiver
:
:
GetStatsInternal
(
bool
aSkipIceStats
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
RefPtr
<
RTCStatsPromise
>
>
promises
(
3
)
;
if
(
!
mPipeline
)
{
return
promises
;
}
if
(
!
mHaveStartedReceiving
)
{
return
promises
;
}
nsString
recvTrackId
;
MOZ_ASSERT
(
mTrack
)
;
if
(
mTrack
)
{
mTrack
-
>
GetId
(
recvTrackId
)
;
}
{
promises
.
AppendElement
(
InvokeAsync
(
mCallThread
__func__
[
conduit
=
mPipeline
-
>
mConduit
recvTrackId
]
(
)
mutable
{
auto
report
=
MakeUnique
<
dom
:
:
RTCStatsCollection
>
(
)
;
const
Maybe
<
webrtc
:
:
Call
:
:
Stats
>
stats
=
conduit
-
>
GetCallStats
(
)
;
stats
.
apply
(
[
&
]
(
const
auto
&
aStats
)
{
dom
:
:
RTCBandwidthEstimationInternal
bw
;
bw
.
mTrackIdentifier
=
recvTrackId
;
bw
.
mSendBandwidthBps
.
Construct
(
aStats
.
send_bandwidth_bps
/
8
)
;
bw
.
mMaxPaddingBps
.
Construct
(
aStats
.
max_padding_bitrate_bps
/
8
)
;
bw
.
mReceiveBandwidthBps
.
Construct
(
aStats
.
recv_bandwidth_bps
/
8
)
;
bw
.
mPacerDelayMs
.
Construct
(
aStats
.
pacer_delay_ms
)
;
if
(
aStats
.
rtt_ms
>
=
0
)
{
bw
.
mRttMs
.
Construct
(
aStats
.
rtt_ms
)
;
}
if
(
!
report
-
>
mBandwidthEstimations
.
AppendElement
(
std
:
:
move
(
bw
)
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
)
;
return
RTCStatsPromise
:
:
CreateAndResolve
(
std
:
:
move
(
report
)
__func__
)
;
}
)
)
;
}
promises
.
AppendElement
(
InvokeAsync
(
mCallThread
__func__
[
pipeline
=
mPipeline
recvTrackId
]
{
auto
report
=
MakeUnique
<
dom
:
:
RTCStatsCollection
>
(
)
;
auto
asAudio
=
pipeline
-
>
mConduit
-
>
AsAudioSessionConduit
(
)
;
auto
asVideo
=
pipeline
-
>
mConduit
-
>
AsVideoSessionConduit
(
)
;
nsString
kind
=
asVideo
.
isNothing
(
)
?
u
"
audio
"
_ns
:
u
"
video
"
_ns
;
nsString
idstr
=
kind
+
u
"
_
"
_ns
;
idstr
.
AppendInt
(
static_cast
<
uint32_t
>
(
pipeline
-
>
Level
(
)
)
)
;
Maybe
<
uint32_t
>
ssrc
=
pipeline
-
>
mConduit
-
>
GetRemoteSSRC
(
)
;
asVideo
.
apply
(
[
&
]
(
const
auto
&
conduit
)
{
if
(
conduit
-
>
AddFrameHistory
(
&
report
-
>
mVideoFrameHistories
)
)
{
auto
&
history
=
report
-
>
mVideoFrameHistories
.
LastElement
(
)
;
history
.
mTrackIdentifier
=
recvTrackId
;
}
}
)
;
nsString
localId
=
u
"
inbound_rtp_
"
_ns
+
idstr
;
nsString
remoteId
;
auto
constructCommonRemoteOutboundRtpStats
=
[
&
]
(
RTCRemoteOutboundRtpStreamStats
&
aRemote
const
DOMHighResTimeStamp
&
aTimestamp
)
{
remoteId
=
u
"
inbound_rtcp_
"
_ns
+
idstr
;
aRemote
.
mTimestamp
.
Construct
(
aTimestamp
)
;
aRemote
.
mId
.
Construct
(
remoteId
)
;
aRemote
.
mType
.
Construct
(
RTCStatsType
:
:
Remote_outbound_rtp
)
;
ssrc
.
apply
(
[
&
]
(
uint32_t
aSsrc
)
{
aRemote
.
mSsrc
=
aSsrc
;
}
)
;
aRemote
.
mKind
=
kind
;
aRemote
.
mMediaType
.
Construct
(
kind
)
;
aRemote
.
mLocalId
.
Construct
(
localId
)
;
}
;
auto
constructCommonInboundRtpStats
=
[
&
]
(
RTCInboundRtpStreamStats
&
aLocal
)
{
aLocal
.
mTrackIdentifier
=
recvTrackId
;
aLocal
.
mTimestamp
.
Construct
(
pipeline
-
>
GetTimestampMaker
(
)
.
GetNow
(
)
)
;
aLocal
.
mId
.
Construct
(
localId
)
;
aLocal
.
mType
.
Construct
(
RTCStatsType
:
:
Inbound_rtp
)
;
ssrc
.
apply
(
[
&
]
(
uint32_t
aSsrc
)
{
aLocal
.
mSsrc
=
aSsrc
;
}
)
;
aLocal
.
mKind
=
kind
;
aLocal
.
mMediaType
.
Construct
(
kind
)
;
if
(
remoteId
.
Length
(
)
)
{
aLocal
.
mRemoteId
.
Construct
(
remoteId
)
;
}
}
;
asAudio
.
apply
(
[
&
]
(
auto
&
aConduit
)
{
Maybe
<
webrtc
:
:
AudioReceiveStreamInterface
:
:
Stats
>
audioStats
=
aConduit
-
>
GetReceiverStats
(
)
;
if
(
audioStats
.
isNothing
(
)
)
{
return
;
}
if
(
!
audioStats
-
>
last_packet_received_timestamp_ms
)
{
return
;
}
if
(
audioStats
-
>
last_sender_report_timestamp_ms
)
{
RTCRemoteOutboundRtpStreamStats
remote
;
constructCommonRemoteOutboundRtpStats
(
remote
aConduit
-
>
GetTimestampMaker
(
)
.
ConvertNtpToDomTime
(
webrtc
:
:
Timestamp
:
:
Millis
(
*
audioStats
-
>
last_sender_report_timestamp_ms
)
+
webrtc
:
:
TimeDelta
:
:
Seconds
(
webrtc
:
:
kNtpJan1970
)
)
)
;
remote
.
mPacketsSent
.
Construct
(
audioStats
-
>
sender_reports_packets_sent
)
;
remote
.
mBytesSent
.
Construct
(
audioStats
-
>
sender_reports_bytes_sent
)
;
remote
.
mRemoteTimestamp
.
Construct
(
*
audioStats
-
>
last_sender_report_remote_timestamp_ms
)
;
if
(
!
report
-
>
mRemoteOutboundRtpStreamStats
.
AppendElement
(
std
:
:
move
(
remote
)
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
RTCInboundRtpStreamStats
local
;
constructCommonInboundRtpStats
(
local
)
;
local
.
mJitter
.
Construct
(
audioStats
-
>
jitter_ms
/
1000
.
0
)
;
local
.
mPacketsLost
.
Construct
(
audioStats
-
>
packets_lost
)
;
local
.
mPacketsReceived
.
Construct
(
audioStats
-
>
packets_rcvd
)
;
local
.
mPacketsDiscarded
.
Construct
(
audioStats
-
>
packets_discarded
)
;
local
.
mBytesReceived
.
Construct
(
audioStats
-
>
payload_bytes_rcvd
)
;
local
.
mJitterBufferDelay
.
Construct
(
audioStats
-
>
jitter_buffer_delay_seconds
)
;
local
.
mJitterBufferEmittedCount
.
Construct
(
audioStats
-
>
jitter_buffer_emitted_count
)
;
local
.
mTotalSamplesReceived
.
Construct
(
audioStats
-
>
total_samples_received
)
;
local
.
mConcealedSamples
.
Construct
(
audioStats
-
>
concealed_samples
)
;
local
.
mSilentConcealedSamples
.
Construct
(
audioStats
-
>
silent_concealed_samples
)
;
if
(
audioStats
-
>
last_packet_received_timestamp_ms
)
{
local
.
mLastPacketReceivedTimestamp
.
Construct
(
aConduit
-
>
GetTimestampMaker
(
)
.
ConvertNtpToDomTime
(
webrtc
:
:
Timestamp
:
:
Millis
(
*
audioStats
-
>
last_packet_received_timestamp_ms
)
+
webrtc
:
:
TimeDelta
:
:
Seconds
(
webrtc
:
:
kNtpJan1970
)
)
)
;
}
local
.
mHeaderBytesReceived
.
Construct
(
audioStats
-
>
header_and_padding_bytes_rcvd
)
;
local
.
mFecPacketsReceived
.
Construct
(
audioStats
-
>
fec_packets_received
)
;
local
.
mFecPacketsDiscarded
.
Construct
(
audioStats
-
>
fec_packets_discarded
)
;
local
.
mConcealmentEvents
.
Construct
(
audioStats
-
>
concealment_events
)
;
local
.
mInsertedSamplesForDeceleration
.
Construct
(
audioStats
-
>
inserted_samples_for_deceleration
)
;
local
.
mRemovedSamplesForAcceleration
.
Construct
(
audioStats
-
>
removed_samples_for_acceleration
)
;
if
(
audioStats
-
>
audio_level
>
=
0
&
&
audioStats
-
>
audio_level
<
=
32767
)
{
local
.
mAudioLevel
.
Construct
(
audioStats
-
>
audio_level
/
32767
.
0
)
;
}
local
.
mTotalAudioEnergy
.
Construct
(
audioStats
-
>
total_output_energy
)
;
local
.
mTotalSamplesDuration
.
Construct
(
audioStats
-
>
total_output_duration
)
;
if
(
!
report
-
>
mInboundRtpStreamStats
.
AppendElement
(
std
:
:
move
(
local
)
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
)
;
asVideo
.
apply
(
[
&
]
(
auto
&
aConduit
)
{
Maybe
<
webrtc
:
:
VideoReceiveStreamInterface
:
:
Stats
>
videoStats
=
aConduit
-
>
GetReceiverStats
(
)
;
if
(
videoStats
.
isNothing
(
)
)
{
return
;
}
if
(
!
videoStats
-
>
rtp_stats
.
last_packet_received_timestamp_ms
)
{
return
;
}
if
(
videoStats
-
>
rtcp_sender_ntp_timestamp_ms
)
{
RTCRemoteOutboundRtpStreamStats
remote
;
constructCommonRemoteOutboundRtpStats
(
remote
aConduit
-
>
GetTimestampMaker
(
)
.
ConvertNtpToDomTime
(
webrtc
:
:
Timestamp
:
:
Millis
(
videoStats
-
>
rtcp_sender_ntp_timestamp_ms
)
)
)
;
remote
.
mPacketsSent
.
Construct
(
videoStats
-
>
rtcp_sender_packets_sent
)
;
remote
.
mBytesSent
.
Construct
(
videoStats
-
>
rtcp_sender_octets_sent
)
;
remote
.
mRemoteTimestamp
.
Construct
(
(
webrtc
:
:
TimeDelta
:
:
Millis
(
videoStats
-
>
rtcp_sender_remote_ntp_timestamp_ms
)
-
webrtc
:
:
TimeDelta
:
:
Seconds
(
webrtc
:
:
kNtpJan1970
)
)
.
ms
(
)
)
;
if
(
!
report
-
>
mRemoteOutboundRtpStreamStats
.
AppendElement
(
std
:
:
move
(
remote
)
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
RTCInboundRtpStreamStats
local
;
constructCommonInboundRtpStats
(
local
)
;
local
.
mJitter
.
Construct
(
static_cast
<
double
>
(
videoStats
-
>
rtp_stats
.
jitter
)
/
webrtc
:
:
kVideoPayloadTypeFrequency
)
;
local
.
mPacketsLost
.
Construct
(
videoStats
-
>
rtp_stats
.
packets_lost
)
;
local
.
mPacketsReceived
.
Construct
(
videoStats
-
>
rtp_stats
.
packet_counter
.
packets
)
;
local
.
mPacketsDiscarded
.
Construct
(
videoStats
-
>
packets_discarded
)
;
local
.
mDiscardedPackets
.
Construct
(
videoStats
-
>
packets_discarded
)
;
local
.
mBytesReceived
.
Construct
(
videoStats
-
>
rtp_stats
.
packet_counter
.
payload_bytes
)
;
local
.
mNackCount
.
Construct
(
videoStats
-
>
rtcp_packet_type_counts
.
nack_packets
)
;
local
.
mFirCount
.
Construct
(
videoStats
-
>
rtcp_packet_type_counts
.
fir_packets
)
;
local
.
mPliCount
.
Construct
(
videoStats
-
>
rtcp_packet_type_counts
.
pli_packets
)
;
local
.
mFramesDecoded
.
Construct
(
videoStats
-
>
frames_decoded
)
;
local
.
mFramesPerSecond
.
Construct
(
videoStats
-
>
decode_frame_rate
)
;
local
.
mFrameWidth
.
Construct
(
videoStats
-
>
width
)
;
local
.
mFrameHeight
.
Construct
(
videoStats
-
>
height
)
;
local
.
mFramesReceived
.
Construct
(
videoStats
-
>
frame_counts
.
key_frames
+
videoStats
-
>
frame_counts
.
delta_frames
)
;
local
.
mJitterBufferDelay
.
Construct
(
videoStats
-
>
jitter_buffer_delay_seconds
)
;
local
.
mJitterBufferEmittedCount
.
Construct
(
videoStats
-
>
jitter_buffer_emitted_count
)
;
if
(
videoStats
-
>
qp_sum
)
{
local
.
mQpSum
.
Construct
(
videoStats
-
>
qp_sum
.
value
(
)
)
;
}
local
.
mTotalDecodeTime
.
Construct
(
double
(
videoStats
-
>
total_decode_time
.
ms
(
)
)
/
1000
)
;
local
.
mTotalInterFrameDelay
.
Construct
(
videoStats
-
>
total_inter_frame_delay
)
;
local
.
mTotalSquaredInterFrameDelay
.
Construct
(
videoStats
-
>
total_squared_inter_frame_delay
)
;
if
(
videoStats
-
>
rtp_stats
.
last_packet_received_timestamp_ms
)
{
local
.
mLastPacketReceivedTimestamp
.
Construct
(
aConduit
-
>
GetTimestampMaker
(
)
.
ConvertNtpToDomTime
(
webrtc
:
:
Timestamp
:
:
Millis
(
*
videoStats
-
>
rtp_stats
.
last_packet_received_timestamp_ms
)
+
webrtc
:
:
TimeDelta
:
:
Seconds
(
webrtc
:
:
kNtpJan1970
)
)
)
;
}
local
.
mHeaderBytesReceived
.
Construct
(
videoStats
-
>
rtp_stats
.
packet_counter
.
header_bytes
+
videoStats
-
>
rtp_stats
.
packet_counter
.
padding_bytes
)
;
local
.
mTotalProcessingDelay
.
Construct
(
videoStats
-
>
total_processing_delay
.
seconds
<
double
>
(
)
)
;
local
.
mFramesDropped
.
Construct
(
videoStats
-
>
frames_dropped
)
;
if
(
!
report
-
>
mInboundRtpStreamStats
.
AppendElement
(
std
:
:
move
(
local
)
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
)
;
return
RTCStatsPromise
:
:
CreateAndResolve
(
std
:
:
move
(
report
)
__func__
)
;
}
)
-
>
Then
(
mStsThread
__func__
[
pipeline
=
mPipeline
]
(
UniquePtr
<
RTCStatsCollection
>
aReport
)
{
if
(
!
aReport
-
>
mInboundRtpStreamStats
.
IsEmpty
(
)
&
&
aReport
-
>
mInboundRtpStreamStats
[
0
]
.
mId
.
WasPassed
(
)
)
{
pipeline
-
>
GetContributingSourceStats
(
aReport
-
>
mInboundRtpStreamStats
[
0
]
.
mId
.
Value
(
)
aReport
-
>
mRtpContributingSourceStats
)
;
}
return
RTCStatsPromise
:
:
CreateAndResolve
(
std
:
:
move
(
aReport
)
__func__
)
;
}
[
]
{
MOZ_CRASH
(
"
Unexpected
reject
"
)
;
return
RTCStatsPromise
:
:
CreateAndReject
(
NS_ERROR_UNEXPECTED
__func__
)
;
}
)
)
;
if
(
!
aSkipIceStats
&
&
GetJsepTransceiver
(
)
.
mTransport
.
mComponents
)
{
promises
.
AppendElement
(
mTransportHandler
-
>
GetIceStats
(
GetJsepTransceiver
(
)
.
mTransport
.
mTransportId
mPipeline
-
>
GetTimestampMaker
(
)
.
GetNow
(
)
)
)
;
}
return
promises
;
}
void
RTCRtpReceiver
:
:
GetContributingSources
(
nsTArray
<
RTCRtpContributingSource
>
&
aSources
)
{
if
(
mPipeline
&
&
mPipeline
-
>
mConduit
)
{
nsTArray
<
dom
:
:
RTCRtpSourceEntry
>
sources
;
mPipeline
-
>
mConduit
-
>
GetRtpSources
(
sources
)
;
sources
.
RemoveElementsBy
(
[
]
(
const
dom
:
:
RTCRtpSourceEntry
&
aEntry
)
{
return
aEntry
.
mSourceType
!
=
dom
:
:
RTCRtpSourceEntryType
:
:
Contributing
;
}
)
;
aSources
.
ReplaceElementsAt
(
0
aSources
.
Length
(
)
sources
.
Elements
(
)
sources
.
Length
(
)
)
;
}
}
void
RTCRtpReceiver
:
:
GetSynchronizationSources
(
nsTArray
<
dom
:
:
RTCRtpSynchronizationSource
>
&
aSources
)
{
if
(
mPipeline
&
&
mPipeline
-
>
mConduit
)
{
nsTArray
<
dom
:
:
RTCRtpSourceEntry
>
sources
;
mPipeline
-
>
mConduit
-
>
GetRtpSources
(
sources
)
;
sources
.
RemoveElementsBy
(
[
]
(
const
dom
:
:
RTCRtpSourceEntry
&
aEntry
)
{
return
aEntry
.
mSourceType
!
=
dom
:
:
RTCRtpSourceEntryType
:
:
Synchronization
;
}
)
;
aSources
.
ReplaceElementsAt
(
0
aSources
.
Length
(
)
sources
.
Elements
(
)
sources
.
Length
(
)
)
;
}
}
nsPIDOMWindowInner
*
RTCRtpReceiver
:
:
GetParentObject
(
)
const
{
return
mWindow
;
}
void
RTCRtpReceiver
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mWatchManager
.
Shutdown
(
)
;
if
(
mPipeline
)
{
mPipeline
-
>
Shutdown
(
)
;
mPipeline
=
nullptr
;
}
if
(
mTrackSource
)
{
mTrackSource
-
>
Destroy
(
)
;
}
mCallThread
=
nullptr
;
mRtcpByeListener
.
DisconnectIfExists
(
)
;
mRtcpTimeoutListener
.
DisconnectIfExists
(
)
;
mUnmuteListener
.
DisconnectIfExists
(
)
;
}
void
RTCRtpReceiver
:
:
BreakCycles
(
)
{
mWindow
=
nullptr
;
mPc
=
nullptr
;
mTrack
=
nullptr
;
mTrackSource
=
nullptr
;
}
void
RTCRtpReceiver
:
:
UpdateTransport
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mHaveSetupTransport
)
{
mPipeline
-
>
SetLevel
(
GetJsepTransceiver
(
)
.
GetLevel
(
)
)
;
mHaveSetupTransport
=
true
;
}
UniquePtr
<
MediaPipelineFilter
>
filter
;
auto
const
&
details
=
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetNegotiatedDetails
(
)
;
if
(
GetJsepTransceiver
(
)
.
HasBundleLevel
(
)
&
&
details
)
{
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
extmaps
;
details
-
>
ForEachRTPHeaderExtension
(
[
&
extmaps
]
(
const
SdpExtmapAttributeList
:
:
Extmap
&
extmap
)
{
extmaps
.
emplace_back
(
extmap
.
extensionname
extmap
.
entry
)
;
}
)
;
filter
=
MakeUnique
<
MediaPipelineFilter
>
(
extmaps
)
;
for
(
uint32_t
ssrc
:
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetSsrcs
(
)
)
{
filter
-
>
AddRemoteSSRC
(
ssrc
)
;
}
for
(
uint32_t
ssrc
:
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetRtxSsrcs
(
)
)
{
filter
-
>
AddRemoteSSRC
(
ssrc
)
;
}
auto
mid
=
Maybe
<
std
:
:
string
>
(
)
;
if
(
GetMid
(
)
!
=
"
"
)
{
mid
=
Some
(
GetMid
(
)
)
;
}
filter
-
>
SetRemoteMediaStreamId
(
mid
)
;
auto
uniquePts
=
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetNegotiatedDetails
(
)
-
>
GetUniquePayloadTypes
(
)
;
for
(
unsigned
char
&
uniquePt
:
uniquePts
)
{
filter
-
>
AddUniquePT
(
uniquePt
)
;
}
}
mPipeline
-
>
UpdateTransport_m
(
GetJsepTransceiver
(
)
.
mTransport
.
mTransportId
std
:
:
move
(
filter
)
)
;
}
void
RTCRtpReceiver
:
:
UpdateConduit
(
)
{
if
(
mPipeline
-
>
mConduit
-
>
type
(
)
=
=
MediaSessionConduit
:
:
VIDEO
)
{
UpdateVideoConduit
(
)
;
}
else
{
UpdateAudioConduit
(
)
;
}
if
(
(
mReceiving
=
mTransceiver
-
>
IsReceiving
(
)
)
)
{
mHaveStartedReceiving
=
true
;
}
}
void
RTCRtpReceiver
:
:
UpdateVideoConduit
(
)
{
RefPtr
<
VideoSessionConduit
>
conduit
=
*
mPipeline
-
>
mConduit
-
>
AsVideoSessionConduit
(
)
;
if
(
!
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetSsrcs
(
)
.
empty
(
)
)
{
MOZ_LOG
(
gReceiverLog
LogLevel
:
:
Debug
(
"
%
s
[
%
s
]
:
%
s
Setting
remote
SSRC
%
u
"
mPc
-
>
GetHandle
(
)
.
c_str
(
)
GetMid
(
)
.
c_str
(
)
__FUNCTION__
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetSsrcs
(
)
.
front
(
)
)
)
;
uint32_t
rtxSsrc
=
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetRtxSsrcs
(
)
.
empty
(
)
?
0
:
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetRtxSsrcs
(
)
.
front
(
)
;
mSsrc
=
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetSsrcs
(
)
.
front
(
)
;
mVideoRtxSsrc
=
rtxSsrc
;
if
(
GetJsepTransceiver
(
)
.
HasBundleLevel
(
)
&
&
(
!
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetNegotiatedDetails
(
)
|
|
!
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetNegotiatedDetails
(
)
-
>
GetExt
(
webrtc
:
:
RtpExtension
:
:
kMidUri
)
)
)
{
mCallThread
-
>
Dispatch
(
NewRunnableMethod
(
"
VideoSessionConduit
:
:
DisableSsrcChanges
"
conduit
&
VideoSessionConduit
:
:
DisableSsrcChanges
)
)
;
}
}
if
(
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetNegotiatedDetails
(
)
&
&
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetActive
(
)
)
{
const
auto
&
details
(
*
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetNegotiatedDetails
(
)
)
;
{
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
extmaps
;
details
.
ForEachRTPHeaderExtension
(
[
&
extmaps
]
(
const
SdpExtmapAttributeList
:
:
Extmap
&
extmap
)
{
extmaps
.
emplace_back
(
extmap
.
extensionname
extmap
.
entry
)
;
}
)
;
mLocalRtpExtensions
=
extmaps
;
}
std
:
:
vector
<
VideoCodecConfig
>
configs
;
RTCRtpTransceiver
:
:
NegotiatedDetailsToVideoCodecConfigs
(
details
&
configs
)
;
if
(
configs
.
empty
(
)
)
{
MOZ_LOG
(
gReceiverLog
LogLevel
:
:
Error
(
"
%
s
[
%
s
]
:
%
s
No
video
codecs
were
negotiated
(
recv
)
.
"
mPc
-
>
GetHandle
(
)
.
c_str
(
)
GetMid
(
)
.
c_str
(
)
__FUNCTION__
)
)
;
return
;
}
mVideoCodecs
=
configs
;
mVideoRtpRtcpConfig
=
Some
(
details
.
GetRtpRtcpConfig
(
)
)
;
}
}
void
RTCRtpReceiver
:
:
UpdateAudioConduit
(
)
{
RefPtr
<
AudioSessionConduit
>
conduit
=
*
mPipeline
-
>
mConduit
-
>
AsAudioSessionConduit
(
)
;
if
(
!
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetSsrcs
(
)
.
empty
(
)
)
{
MOZ_LOG
(
gReceiverLog
LogLevel
:
:
Debug
(
"
%
s
[
%
s
]
:
%
s
Setting
remote
SSRC
%
u
"
mPc
-
>
GetHandle
(
)
.
c_str
(
)
GetMid
(
)
.
c_str
(
)
__FUNCTION__
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetSsrcs
(
)
.
front
(
)
)
)
;
mSsrc
=
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetSsrcs
(
)
.
front
(
)
;
if
(
GetJsepTransceiver
(
)
.
HasBundleLevel
(
)
&
&
(
!
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetNegotiatedDetails
(
)
|
|
!
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetNegotiatedDetails
(
)
-
>
GetExt
(
webrtc
:
:
RtpExtension
:
:
kMidUri
)
)
)
{
mCallThread
-
>
Dispatch
(
NewRunnableMethod
(
"
AudioSessionConduit
:
:
DisableSsrcChanges
"
conduit
&
AudioSessionConduit
:
:
DisableSsrcChanges
)
)
;
}
}
if
(
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetNegotiatedDetails
(
)
&
&
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetActive
(
)
)
{
const
auto
&
details
(
*
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetNegotiatedDetails
(
)
)
;
std
:
:
vector
<
AudioCodecConfig
>
configs
;
RTCRtpTransceiver
:
:
NegotiatedDetailsToAudioCodecConfigs
(
details
&
configs
)
;
if
(
configs
.
empty
(
)
)
{
MOZ_LOG
(
gReceiverLog
LogLevel
:
:
Error
(
"
%
s
[
%
s
]
:
%
s
No
audio
codecs
were
negotiated
(
recv
)
"
mPc
-
>
GetHandle
(
)
.
c_str
(
)
GetMid
(
)
.
c_str
(
)
__FUNCTION__
)
)
;
return
;
}
{
std
:
:
vector
<
webrtc
:
:
RtpExtension
>
extmaps
;
details
.
ForEachRTPHeaderExtension
(
[
&
extmaps
]
(
const
SdpExtmapAttributeList
:
:
Extmap
&
extmap
)
{
extmaps
.
emplace_back
(
extmap
.
extensionname
extmap
.
entry
)
;
}
)
;
mLocalRtpExtensions
=
extmaps
;
}
mAudioCodecs
=
configs
;
}
}
void
RTCRtpReceiver
:
:
Stop
(
)
{
MOZ_ASSERT
(
mTransceiver
-
>
Stopped
(
)
)
;
mReceiving
=
false
;
}
bool
RTCRtpReceiver
:
:
HasTrack
(
const
dom
:
:
MediaStreamTrack
*
aTrack
)
const
{
return
!
aTrack
|
|
(
mTrack
=
=
aTrack
)
;
}
void
RTCRtpReceiver
:
:
SyncFromJsep
(
const
JsepTransceiver
&
aJsepTransceiver
)
{
if
(
!
mPipeline
)
{
return
;
}
bool
wasReceptive
=
mReceptive
;
mReceptive
=
aJsepTransceiver
.
mRecvTrack
.
GetReceptive
(
)
;
if
(
!
wasReceptive
&
&
mReceptive
)
{
mUnmuteListener
=
mPipeline
-
>
mConduit
-
>
RtpPacketEvent
(
)
.
Connect
(
GetMainThreadSerialEventTarget
(
)
this
&
RTCRtpReceiver
:
:
OnRtpPacket
)
;
}
else
if
(
wasReceptive
&
&
!
mReceptive
)
{
mUnmuteListener
.
DisconnectIfExists
(
)
;
}
}
void
RTCRtpReceiver
:
:
SyncToJsep
(
JsepTransceiver
&
aJsepTransceiver
)
const
{
}
void
RTCRtpReceiver
:
:
UpdateStreams
(
StreamAssociationChanges
*
aChanges
)
{
std
:
:
set
<
std
:
:
string
>
newIds
(
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetStreamIds
(
)
.
begin
(
)
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetStreamIds
(
)
.
end
(
)
)
;
MOZ_ASSERT
(
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetRemoteSetSendBit
(
)
|
|
newIds
.
empty
(
)
)
;
bool
needsTrackEvent
=
false
;
for
(
const
auto
&
id
:
mStreamIds
)
{
if
(
!
newIds
.
count
(
id
)
)
{
aChanges
-
>
mStreamAssociationsRemoved
.
push_back
(
{
mTrack
id
}
)
;
}
}
std
:
:
set
<
std
:
:
string
>
oldIds
(
mStreamIds
.
begin
(
)
mStreamIds
.
end
(
)
)
;
for
(
const
auto
&
id
:
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetStreamIds
(
)
)
{
if
(
!
oldIds
.
count
(
id
)
)
{
needsTrackEvent
=
true
;
aChanges
-
>
mStreamAssociationsAdded
.
push_back
(
{
mTrack
id
}
)
;
}
}
mStreamIds
=
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetStreamIds
(
)
;
if
(
mRemoteSetSendBit
!
=
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetRemoteSetSendBit
(
)
)
{
mRemoteSetSendBit
=
GetJsepTransceiver
(
)
.
mRecvTrack
.
GetRemoteSetSendBit
(
)
;
if
(
mRemoteSetSendBit
)
{
needsTrackEvent
=
true
;
}
else
{
aChanges
-
>
mReceiversToMute
.
push_back
(
this
)
;
}
}
if
(
needsTrackEvent
)
{
aChanges
-
>
mTrackEvents
.
push_back
(
{
this
mStreamIds
}
)
;
}
}
void
RTCRtpReceiver
:
:
UpdatePrincipalPrivacy
(
PrincipalPrivacy
aPrivacy
)
{
if
(
!
mPipeline
)
{
return
;
}
if
(
aPrivacy
!
=
PrincipalPrivacy
:
:
Private
)
{
return
;
}
mPipeline
-
>
SetPrivatePrincipal
(
GetPrincipalHandle
(
mWindow
aPrivacy
)
)
;
}
void
RTCRtpReceiver
:
:
MozInsertAudioLevelForContributingSource
(
const
uint32_t
aSource
const
DOMHighResTimeStamp
aTimestamp
const
uint32_t
aRtpTimestamp
const
bool
aHasLevel
const
uint8_t
aLevel
)
{
if
(
!
mPipeline
|
|
mPipeline
-
>
IsVideo
(
)
|
|
!
mPipeline
-
>
mConduit
)
{
return
;
}
mPipeline
-
>
mConduit
-
>
InsertAudioLevelForContributingSource
(
aSource
aTimestamp
aRtpTimestamp
aHasLevel
aLevel
)
;
}
void
RTCRtpReceiver
:
:
OnRtcpBye
(
)
{
mReceiveTrackMute
=
true
;
}
void
RTCRtpReceiver
:
:
OnRtcpTimeout
(
)
{
mReceiveTrackMute
=
true
;
}
void
RTCRtpReceiver
:
:
SetTrackMuteFromRemoteSdp
(
)
{
MOZ_ASSERT
(
!
mReceptive
"
PeerConnectionImpl
should
have
blocked
unmute
events
prior
to
"
"
firing
mute
"
)
;
mReceiveTrackMute
=
true
;
UpdateReceiveTrackMute
(
)
;
MOZ_ASSERT
(
mTrack
-
>
Muted
(
)
"
Muted
state
was
indeed
set
synchronously
"
)
;
}
void
RTCRtpReceiver
:
:
OnRtpPacket
(
)
{
MOZ_ASSERT
(
mReceptive
"
We
should
not
be
registered
unless
this
is
set
!
"
)
;
mUnmuteListener
.
Disconnect
(
)
;
if
(
mReceptive
)
{
mReceiveTrackMute
=
false
;
}
}
void
RTCRtpReceiver
:
:
UpdateReceiveTrackMute
(
)
{
if
(
!
mTrack
)
{
return
;
}
if
(
!
mTrackSource
)
{
return
;
}
mTrackSource
-
>
SetMuted
(
mReceiveTrackMute
)
;
}
std
:
:
string
RTCRtpReceiver
:
:
GetMid
(
)
const
{
return
mTransceiver
-
>
GetMidAscii
(
)
;
}
JsepTransceiver
&
RTCRtpReceiver
:
:
GetJsepTransceiver
(
)
{
MOZ_ASSERT
(
mTransceiver
)
;
return
mTransceiver
-
>
GetJsepTransceiver
(
)
;
}
const
JsepTransceiver
&
RTCRtpReceiver
:
:
GetJsepTransceiver
(
)
const
{
MOZ_ASSERT
(
mTransceiver
)
;
return
mTransceiver
-
>
GetJsepTransceiver
(
)
;
}
}
#
undef
LOGTAG
