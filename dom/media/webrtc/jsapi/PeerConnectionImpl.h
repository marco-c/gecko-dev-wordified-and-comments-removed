#
ifndef
_PEER_CONNECTION_IMPL_H_
#
define
_PEER_CONNECTION_IMPL_H_
#
include
<
cmath
>
#
include
<
map
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsIUUIDGenerator
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsTHashSet
.
h
"
#
include
"
prlock
.
h
"
#
ifdef
GetLastError
#
undef
GetLastError
#
endif
#
include
"
DefaultCodecPreferences
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaTransportHandler
.
h
"
#
include
"
PrincipalChangeObserver
.
h
"
#
include
"
RTCDtlsTransport
.
h
"
#
include
"
RTCRtpTransceiver
.
h
"
#
include
"
RTCStatsIdGenerator
.
h
"
#
include
"
RTCStatsReport
.
h
"
#
include
"
VideoSegment
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
jsapi
/
PacketDumper
.
h
"
#
include
"
jsep
/
JsepSession
.
h
"
#
include
"
jsep
/
JsepSessionImpl
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
PeerIdentity
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
PeerConnectionImplBinding
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
RTCConfigurationBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCPeerConnectionBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpCapabilitiesBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpTransceiverBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCStatsReportBinding
.
h
"
#
include
"
mozilla
/
net
/
DataChannel
.
h
"
#
include
"
mozilla
/
net
/
StunAddrsRequestChild
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
sdp
/
SdpMediaSection
.
h
"
namespace
test
{
#
ifdef
USE_FAKE_PCOBSERVER
class
AFakePCObserver
;
#
endif
}
class
nsIPrincipal
;
namespace
mozilla
{
struct
CandidateInfo
;
class
DataChannel
;
class
DtlsIdentity
;
class
MediaPipeline
;
class
MediaPipelineReceive
;
class
MediaPipelineTransmit
;
enum
class
PrincipalPrivacy
:
uint8_t
;
class
SharedWebrtcState
;
namespace
dom
{
class
RTCCertificate
;
struct
RTCConfiguration
;
class
RTCDataChannel
;
struct
RTCRtpSourceEntry
;
struct
RTCIceServer
;
struct
RTCOfferOptions
;
struct
RTCRtpParameters
;
class
RTCRtpSender
;
class
MediaStreamTrack
;
#
ifdef
USE_FAKE_PCOBSERVER
typedef
test
:
:
AFakePCObserver
PeerConnectionObserver
;
typedef
const
char
*
PCObserverString
;
#
else
class
PeerConnectionObserver
;
typedef
NS_ConvertUTF8toUTF16
PCObserverString
;
#
endif
}
}
#
if
defined
(
__cplusplus
)
&
&
__cplusplus
>
=
201103L
typedef
struct
Timecard
Timecard
;
#
else
#
include
"
common
/
time_profiling
/
timecard
.
h
"
#
endif
#
define
NS_IMETHODIMP_TO_ERRORRESULT
(
func
rv
.
.
.
)
\
NS_IMETHODIMP
func
(
__VA_ARGS__
)
;
\
void
func
(
__VA_ARGS__
rv
)
#
define
NS_IMETHODIMP_TO_ERRORRESULT_RETREF
(
resulttype
func
rv
.
.
.
)
\
NS_IMETHODIMP
func
(
__VA_ARGS__
resulttype
*
*
result
)
;
\
already_AddRefed
<
resulttype
>
func
(
__VA_ARGS__
rv
)
namespace
mozilla
{
using
dom
:
:
PeerConnectionObserver
;
using
dom
:
:
RTCConfiguration
;
using
dom
:
:
RTCDataChannel
;
using
dom
:
:
RTCIceServer
;
using
dom
:
:
RTCOfferOptions
;
class
PeerConnectionWrapper
;
class
RemoteSourceStreamInfo
;
class
PCUuidGenerator
:
public
JsepUuidGenerator
{
public
:
virtual
bool
Generate
(
std
:
:
string
*
idp
)
override
;
virtual
JsepUuidGenerator
*
Clone
(
)
const
override
{
return
new
PCUuidGenerator
(
*
this
)
;
}
private
:
nsCOMPtr
<
nsIUUIDGenerator
>
mGenerator
;
}
;
struct
PeerConnectionAutoTimer
{
PeerConnectionAutoTimer
(
)
:
mRefCnt
(
0
)
mStart
(
TimeStamp
:
:
Now
(
)
)
mUsedAV
(
false
)
{
}
;
void
RegisterConnection
(
)
;
void
UnregisterConnection
(
bool
aContainedAV
)
;
bool
IsStopped
(
)
;
private
:
int64_t
mRefCnt
;
TimeStamp
mStart
;
bool
mUsedAV
;
}
;
#
define
PC_AUTO_ENTER_API_CALL
(
assert_ice_ready
)
\
do
{
\
/
*
do
/
while
prevents
res
from
conflicting
with
locals
*
/
\
nsresult
res
=
CheckApiState
(
assert_ice_ready
)
;
\
if
(
NS_FAILED
(
res
)
)
return
res
;
\
}
while
(
0
)
#
define
PC_AUTO_ENTER_API_CALL_VOID_RETURN
(
assert_ice_ready
)
\
do
{
\
/
*
do
/
while
prevents
res
from
conflicting
with
locals
*
/
\
nsresult
res
=
CheckApiState
(
assert_ice_ready
)
;
\
if
(
NS_FAILED
(
res
)
)
return
;
\
}
while
(
0
)
#
define
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
CheckThread
(
)
class
PeerConnectionImpl
final
:
public
nsISupports
public
nsWrapperCache
public
DataChannelConnection
:
:
DataConnectionListener
{
struct
Internal
;
public
:
explicit
PeerConnectionImpl
(
const
dom
:
:
GlobalObject
*
aGlobal
=
nullptr
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
PeerConnectionImpl
)
struct
RtpExtensionHeader
{
JsepMediaType
mMediaType
;
SdpDirectionAttribute
:
:
Direction
direction
;
std
:
:
string
extensionname
;
}
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
nsPIDOMWindowInner
*
GetParentObject
(
)
const
;
static
already_AddRefed
<
PeerConnectionImpl
>
Constructor
(
const
dom
:
:
GlobalObject
&
aGlobal
)
;
static
DefaultCodecPreferences
GetDefaultCodecPreferences
(
const
OverrideRtxPreference
aOverrideRtxPreference
=
OverrideRtxPreference
:
:
NoOverride
)
{
return
DefaultCodecPreferences
(
aOverrideRtxPreference
)
;
}
void
NotifyDataChannel
(
already_AddRefed
<
DataChannel
>
aChannel
const
nsACString
&
aLabel
bool
aOrdered
dom
:
:
Nullable
<
uint16_t
>
aMaxLifeTime
dom
:
:
Nullable
<
uint16_t
>
aMaxRetransmits
const
nsACString
&
aProtocol
bool
aNegotiated
)
override
;
void
NotifyDataChannelOpen
(
DataChannel
*
)
override
;
void
NotifyDataChannelClosed
(
DataChannel
*
)
override
;
void
NotifySctpConnected
(
)
override
;
void
NotifySctpClosed
(
)
override
;
const
RefPtr
<
MediaTransportHandler
>
GetTransportHandler
(
)
const
;
virtual
const
std
:
:
string
&
GetHandle
(
)
;
virtual
const
std
:
:
string
&
GetName
(
)
;
void
IceConnectionStateChange
(
const
std
:
:
string
&
aTransportId
dom
:
:
RTCIceTransportState
state
)
;
void
IceGatheringStateChange
(
const
std
:
:
string
&
aTransportId
dom
:
:
RTCIceGathererState
state
)
;
void
OnCandidateFound
(
const
std
:
:
string
&
aTransportId
const
CandidateInfo
&
aCandidateInfo
)
;
void
UpdateDefaultCandidate
(
const
std
:
:
string
&
defaultAddr
uint16_t
defaultPort
const
std
:
:
string
&
defaultRtcpAddr
uint16_t
defaultRtcpPort
const
std
:
:
string
&
transportId
)
;
static
void
ListenThread
(
void
*
aData
)
;
static
void
ConnectThread
(
void
*
aData
)
;
nsISerialEventTarget
*
GetSTSThread
(
)
{
PC_AUTO_ENTER_API_CALL_NO_CHECK
(
)
;
return
mSTSThread
;
}
nsresult
Initialize
(
PeerConnectionObserver
&
aObserver
nsGlobalWindowInner
*
aWindow
)
;
void
Initialize
(
PeerConnectionObserver
&
aObserver
nsGlobalWindowInner
&
aWindow
ErrorResult
&
rv
)
;
void
SetCertificate
(
dom
:
:
RTCCertificate
&
aCertificate
)
;
const
RefPtr
<
dom
:
:
RTCCertificate
>
&
Certificate
(
)
const
;
RefPtr
<
DtlsIdentity
>
Identity
(
)
const
;
NS_IMETHODIMP_TO_ERRORRESULT
(
CreateOffer
ErrorResult
&
rv
const
RTCOfferOptions
&
aOptions
)
{
rv
=
CreateOffer
(
aOptions
)
;
}
NS_IMETHODIMP
CreateAnswer
(
)
;
void
CreateAnswer
(
ErrorResult
&
rv
)
{
rv
=
CreateAnswer
(
)
;
}
NS_IMETHODIMP
CreateOffer
(
const
JsepOfferOptions
&
aConstraints
)
;
NS_IMETHODIMP
SetLocalDescription
(
int32_t
aAction
const
char
*
aSDP
)
;
void
SetLocalDescription
(
int32_t
aAction
const
nsAString
&
aSDP
ErrorResult
&
rv
)
{
rv
=
SetLocalDescription
(
aAction
NS_ConvertUTF16toUTF8
(
aSDP
)
.
get
(
)
)
;
}
NS_IMETHODIMP
SetRemoteDescription
(
int32_t
aAction
const
char
*
aSDP
)
;
void
SetRemoteDescription
(
int32_t
aAction
const
nsAString
&
aSDP
ErrorResult
&
rv
)
{
rv
=
SetRemoteDescription
(
aAction
NS_ConvertUTF16toUTF8
(
aSDP
)
.
get
(
)
)
;
}
already_AddRefed
<
dom
:
:
Promise
>
GetStats
(
dom
:
:
MediaStreamTrack
*
aSelector
)
;
void
GetRemoteStreams
(
nsTArray
<
RefPtr
<
DOMMediaStream
>
>
&
aStreamsOut
)
const
;
NS_IMETHODIMP
AddIceCandidate
(
const
char
*
aCandidate
const
char
*
aMid
const
char
*
aUfrag
const
dom
:
:
Nullable
<
unsigned
short
>
&
aLevel
)
;
void
AddIceCandidate
(
const
nsAString
&
aCandidate
const
nsAString
&
aMid
const
nsAString
&
aUfrag
const
dom
:
:
Nullable
<
unsigned
short
>
&
aLevel
ErrorResult
&
rv
)
{
rv
=
AddIceCandidate
(
NS_ConvertUTF16toUTF8
(
aCandidate
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aMid
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aUfrag
)
.
get
(
)
aLevel
)
;
}
void
UpdateNetworkState
(
bool
online
)
;
NS_IMETHODIMP
CloseStreams
(
)
;
void
CloseStreams
(
ErrorResult
&
rv
)
{
rv
=
CloseStreams
(
)
;
}
already_AddRefed
<
dom
:
:
RTCRtpTransceiver
>
AddTransceiver
(
const
dom
:
:
RTCRtpTransceiverInit
&
aInit
const
nsAString
&
aKind
dom
:
:
MediaStreamTrack
*
aSendTrack
bool
aAddTrackMagic
ErrorResult
&
aRv
)
;
bool
CheckNegotiationNeeded
(
)
;
bool
CreatedSender
(
const
dom
:
:
RTCRtpSender
&
aSender
)
const
;
NS_IMETHODIMP_TO_ERRORRESULT
(
EnablePacketDump
ErrorResult
&
rv
unsigned
long
level
dom
:
:
mozPacketDumpType
type
bool
sending
)
{
rv
=
EnablePacketDump
(
level
type
sending
)
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
DisablePacketDump
ErrorResult
&
rv
unsigned
long
level
dom
:
:
mozPacketDumpType
type
bool
sending
)
{
rv
=
DisablePacketDump
(
level
type
sending
)
;
}
void
GetPeerIdentity
(
nsAString
&
peerIdentity
)
{
if
(
mPeerIdentity
)
{
peerIdentity
=
mPeerIdentity
-
>
ToString
(
)
;
return
;
}
peerIdentity
.
SetIsVoid
(
true
)
;
}
const
PeerIdentity
*
GetPeerIdentity
(
)
const
{
return
mPeerIdentity
;
}
NS_IMETHODIMP_TO_ERRORRESULT
(
SetPeerIdentity
ErrorResult
&
rv
const
nsAString
&
peerIdentity
)
{
rv
=
SetPeerIdentity
(
peerIdentity
)
;
}
const
std
:
:
string
&
GetIdAsAscii
(
)
const
{
return
mName
;
}
void
GetId
(
nsAString
&
id
)
{
id
=
NS_ConvertASCIItoUTF16
(
mName
.
c_str
(
)
)
;
}
void
SetId
(
const
nsAString
&
id
)
{
mName
=
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
;
}
bool
PrivacyRequested
(
)
const
{
return
mRequestedPrivacy
.
valueOr
(
PrincipalPrivacy
:
:
NonPrivate
)
=
=
PrincipalPrivacy
:
:
Private
;
}
bool
DuplicateFingerprintQuirk
(
)
{
return
mDuplicateFingerprintQuirk
;
}
NS_IMETHODIMP
GetFingerprint
(
char
*
*
fingerprint
)
;
void
GetFingerprint
(
nsAString
&
fingerprint
)
{
char
*
tmp
;
nsresult
rv
=
GetFingerprint
(
&
tmp
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
fingerprint
.
AssignASCII
(
tmp
)
;
delete
[
]
tmp
;
}
void
GetCurrentLocalDescription
(
nsAString
&
aSDP
)
const
;
void
GetPendingLocalDescription
(
nsAString
&
aSDP
)
const
;
void
GetCurrentRemoteDescription
(
nsAString
&
aSDP
)
const
;
void
GetPendingRemoteDescription
(
nsAString
&
aSDP
)
const
;
dom
:
:
Nullable
<
bool
>
GetCurrentOfferer
(
)
const
;
dom
:
:
Nullable
<
bool
>
GetPendingOfferer
(
)
const
;
NS_IMETHODIMP
SignalingState
(
dom
:
:
RTCSignalingState
*
aState
)
;
dom
:
:
RTCSignalingState
SignalingState
(
)
{
dom
:
:
RTCSignalingState
state
;
SignalingState
(
&
state
)
;
return
state
;
}
NS_IMETHODIMP
IceConnectionState
(
dom
:
:
RTCIceConnectionState
*
aState
)
;
dom
:
:
RTCIceConnectionState
IceConnectionState
(
)
{
dom
:
:
RTCIceConnectionState
state
;
IceConnectionState
(
&
state
)
;
return
state
;
}
NS_IMETHODIMP
IceGatheringState
(
dom
:
:
RTCIceGatheringState
*
aState
)
;
dom
:
:
RTCIceGatheringState
IceGatheringState
(
)
{
return
mIceGatheringState
;
}
NS_IMETHODIMP
ConnectionState
(
dom
:
:
RTCPeerConnectionState
*
aState
)
;
dom
:
:
RTCPeerConnectionState
ConnectionState
(
)
{
dom
:
:
RTCPeerConnectionState
state
;
ConnectionState
(
&
state
)
;
return
state
;
}
NS_IMETHODIMP
Close
(
)
;
void
Close
(
ErrorResult
&
rv
)
{
rv
=
Close
(
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
bool
PluginCrash
(
uint32_t
aPluginID
const
nsAString
&
aPluginName
)
;
NS_IMETHODIMP_TO_ERRORRESULT
(
SetConfiguration
ErrorResult
&
rv
const
RTCConfiguration
&
aConfiguration
)
{
rv
=
SetConfiguration
(
aConfiguration
)
;
}
dom
:
:
RTCSctpTransport
*
GetSctp
(
)
const
;
void
RestartIce
(
)
;
void
RestartIceNoRenegotiationNeeded
(
)
;
void
RecordEndOfCallTelemetry
(
)
;
void
RecordSignalingTelemetry
(
)
const
;
nsresult
MaybeInitializeDataChannel
(
)
;
NS_IMETHODIMP_TO_ERRORRESULT_RETREF
(
RTCDataChannel
CreateDataChannel
ErrorResult
&
rv
const
nsACString
&
aLabel
const
nsACString
&
aProtocol
uint16_t
aType
bool
outOfOrderAllowed
uint16_t
aMaxTime
uint16_t
aMaxNum
bool
aExternalNegotiated
uint16_t
aStream
)
;
class
Operation
:
public
dom
:
:
PromiseNativeHandler
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
Operation
)
Operation
(
PeerConnectionImpl
*
aPc
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
void
Call
(
ErrorResult
&
aError
)
;
dom
:
:
Promise
*
GetPromise
(
)
{
return
mPromise
;
}
MOZ_CAN_RUN_SCRIPT
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
;
MOZ_CAN_RUN_SCRIPT
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
;
protected
:
MOZ_CAN_RUN_SCRIPT
virtual
RefPtr
<
dom
:
:
Promise
>
CallImpl
(
ErrorResult
&
aError
)
=
0
;
virtual
~
Operation
(
)
;
RefPtr
<
dom
:
:
Promise
>
mPromise
;
RefPtr
<
PeerConnectionImpl
>
mPc
;
}
;
class
JSOperation
final
:
public
Operation
{
public
:
JSOperation
(
PeerConnectionImpl
*
aPc
dom
:
:
ChainedOperation
&
aOp
ErrorResult
&
aError
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
JSOperation
Operation
)
private
:
MOZ_CAN_RUN_SCRIPT
RefPtr
<
dom
:
:
Promise
>
CallImpl
(
ErrorResult
&
aError
)
override
;
~
JSOperation
(
)
=
default
;
RefPtr
<
dom
:
:
ChainedOperation
>
mOperation
;
}
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
dom
:
:
Promise
>
Chain
(
dom
:
:
ChainedOperation
&
aOperation
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
dom
:
:
Promise
>
Chain
(
const
RefPtr
<
Operation
>
&
aOperation
ErrorResult
&
aError
)
;
already_AddRefed
<
dom
:
:
Promise
>
MakePromise
(
ErrorResult
&
aError
)
const
;
void
UpdateNegotiationNeeded
(
)
;
void
GetTransceivers
(
nsTArray
<
RefPtr
<
dom
:
:
RTCRtpTransceiver
>
>
&
aTransceiversOut
)
{
aTransceiversOut
=
mTransceivers
.
Clone
(
)
;
}
RefPtr
<
dom
:
:
RTCRtpTransceiver
>
GetTransceiver
(
const
std
:
:
string
&
aTransceiverId
)
;
dom
:
:
RTCSignalingState
GetSignalingState
(
)
const
;
already_AddRefed
<
dom
:
:
Promise
>
OnSetDescriptionSuccess
(
dom
:
:
RTCSdpType
aSdpType
bool
aRemote
ErrorResult
&
aError
)
;
void
OnSetDescriptionError
(
)
;
bool
IsClosed
(
)
const
;
nsresult
OnAlpnNegotiated
(
const
std
:
:
string
&
aAlpn
bool
aPrivacyRequested
)
;
void
OnDtlsStateChange
(
const
std
:
:
string
&
aTransportId
TransportLayer
:
:
State
aState
)
;
dom
:
:
RTCPeerConnectionState
GetNewConnectionState
(
)
const
;
bool
UpdateConnectionState
(
)
;
dom
:
:
RTCIceConnectionState
GetNewIceConnectionState
(
)
const
;
bool
UpdateIceConnectionState
(
)
;
dom
:
:
RTCIceGatheringState
GetNewIceGatheringState
(
)
const
;
bool
UpdateIceGatheringState
(
)
;
void
StartCallTelem
(
)
;
nsTArray
<
dom
:
:
RTCCodecStats
>
GetCodecStats
(
DOMHighResTimeStamp
aNow
)
;
RefPtr
<
dom
:
:
RTCStatsReportPromise
>
GetStats
(
dom
:
:
MediaStreamTrack
*
aSelector
bool
aInternalStats
)
;
void
CollectConduitTelemetryData
(
)
;
void
OnMediaError
(
const
std
:
:
string
&
aError
)
;
void
DumpPacket_m
(
size_t
level
dom
:
:
mozPacketDumpType
type
bool
sending
UniquePtr
<
uint8_t
[
]
>
&
packet
size_t
size
)
;
const
dom
:
:
RTCStatsTimestampMaker
&
GetTimestampMaker
(
)
const
{
return
mTimestampMaker
;
}
void
StampTimecard
(
const
char
*
aEvent
)
;
bool
RelayOnly
(
)
const
{
return
mJsConfiguration
.
mIceTransportPolicy
.
WasPassed
(
)
&
&
mJsConfiguration
.
mIceTransportPolicy
.
Value
(
)
=
=
dom
:
:
RTCIceTransportPolicy
:
:
Relay
;
}
RefPtr
<
PacketDumper
>
GetPacketDumper
(
)
{
if
(
!
mPacketDumper
)
{
mPacketDumper
=
new
PacketDumper
(
mHandle
)
;
}
return
mPacketDumper
;
}
nsString
GenerateUUID
(
)
const
{
std
:
:
string
result
;
if
(
!
mUuidGen
-
>
Generate
(
&
result
)
)
{
MOZ_CRASH
(
)
;
}
return
NS_ConvertUTF8toUTF16
(
result
.
c_str
(
)
)
;
}
bool
ShouldAllowOldSetParameters
(
)
const
{
return
mAllowOldSetParameters
;
}
nsCString
GetHostname
(
)
const
{
return
mHostname
;
}
nsCString
GetEffectiveTLDPlus1
(
)
const
{
return
mEffectiveTLDPlus1
;
}
void
SendWarningToConsole
(
const
nsCString
&
aWarning
)
;
const
UniquePtr
<
dom
:
:
RTCStatsReportInternal
>
&
GetFinalStats
(
)
const
{
return
mFinalStats
;
}
void
DisableLongTermStats
(
)
{
mDisableLongTermStats
=
true
;
}
bool
LongTermStatsIsDisabled
(
)
const
{
return
mDisableLongTermStats
;
}
static
void
GetDefaultVideoCodecs
(
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
&
aSupportedCodecs
const
OverrideRtxPreference
aOverrideRtxPreference
)
;
static
void
GetDefaultAudioCodecs
(
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
&
aSupportedCodecs
)
;
static
void
GetDefaultRtpExtensions
(
std
:
:
vector
<
RtpExtensionHeader
>
&
aRtpExtensions
)
;
static
void
GetCapabilities
(
const
nsAString
&
aKind
dom
:
:
Nullable
<
dom
:
:
RTCRtpCapabilities
>
&
aResult
sdp
:
:
Direction
aDirection
)
;
static
void
SetupPreferredCodecs
(
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
&
aPreferredCodecs
)
;
static
void
SetupPreferredRtpExtensions
(
std
:
:
vector
<
RtpExtensionHeader
>
&
aPreferredheaders
)
;
void
BreakCycles
(
)
;
using
RTCDtlsTransportMap
=
nsTHashMap
<
nsCStringHashKey
RefPtr
<
dom
:
:
RTCDtlsTransport
>
>
;
private
:
virtual
~
PeerConnectionImpl
(
)
;
PeerConnectionImpl
(
const
PeerConnectionImpl
&
rhs
)
;
PeerConnectionImpl
&
operator
=
(
PeerConnectionImpl
)
;
RefPtr
<
dom
:
:
RTCStatsPromise
>
GetDataChannelStats
(
const
RefPtr
<
DataChannelConnection
>
&
aDataChannelConnection
const
DOMHighResTimeStamp
aTimestamp
)
;
nsresult
CalculateFingerprint
(
const
nsACString
&
algorithm
std
:
:
vector
<
uint8_t
>
*
fingerprint
)
const
;
NS_IMETHODIMP
EnsureDataConnection
(
uint16_t
aLocalPort
uint16_t
aNumstreams
)
;
nsresult
CheckApiState
(
bool
assert_ice_ready
)
const
;
void
StoreFinalStats
(
UniquePtr
<
dom
:
:
RTCStatsReportInternal
>
&
&
report
)
;
void
CheckThread
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Wrong
thread
"
)
;
}
RefPtr
<
MediaPipeline
>
GetMediaPipelineForTrack
(
dom
:
:
MediaStreamTrack
&
aRecvTrack
)
;
void
CandidateReady
(
const
std
:
:
string
&
candidate
const
std
:
:
string
&
transportId
const
std
:
:
string
&
ufrag
)
;
void
SendLocalIceCandidateToContent
(
uint16_t
level
const
std
:
:
string
&
mid
const
std
:
:
string
&
candidate
const
std
:
:
string
&
ufrag
)
;
nsresult
GetDatachannelParameters
(
uint32_t
*
channels
uint16_t
*
localport
uint16_t
*
remoteport
uint32_t
*
maxmessagesize
std
:
:
string
*
transportId
bool
*
client
)
const
;
nsresult
AddRtpTransceiverToJsepSession
(
JsepTransceiver
&
transceiver
)
;
void
RecordIceRestartStatistics
(
JsepSdpType
type
)
;
void
StoreConfigurationForAboutWebrtc
(
const
RTCConfiguration
&
aConfig
)
;
dom
:
:
Sequence
<
dom
:
:
RTCSdpParsingErrorInternal
>
GetLastSdpParsingErrors
(
)
const
;
MOZ_CAN_RUN_SCRIPT
void
RunNextOperation
(
ErrorResult
&
aError
)
;
void
SyncToJsep
(
)
;
void
SyncFromJsep
(
)
;
void
DoSetDescriptionSuccessPostProcessing
(
dom
:
:
RTCSdpType
aSdpType
bool
aRemote
const
RefPtr
<
dom
:
:
Promise
>
&
aP
)
;
Timecard
*
mTimeCard
;
dom
:
:
RTCConfigurationInternal
mJsConfiguration
;
dom
:
:
RTCSignalingState
mSignalingState
;
dom
:
:
RTCIceConnectionState
mIceConnectionState
;
dom
:
:
RTCIceGatheringState
mIceGatheringState
;
dom
:
:
RTCPeerConnectionState
mConnectionState
;
RefPtr
<
PeerConnectionObserver
>
mPCObserver
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mWindow
;
std
:
:
string
mLocalRequestedSDP
;
std
:
:
string
mRemoteRequestedSDP
;
dom
:
:
Sequence
<
dom
:
:
RTCSdpHistoryEntryInternal
>
mSdpHistory
;
std
:
:
string
mPendingLocalDescription
;
std
:
:
string
mPendingRemoteDescription
;
std
:
:
string
mCurrentLocalDescription
;
std
:
:
string
mCurrentRemoteDescription
;
Maybe
<
bool
>
mPendingOfferer
;
Maybe
<
bool
>
mCurrentOfferer
;
std
:
:
string
mFingerprint
;
std
:
:
string
mRemoteFingerprint
;
RefPtr
<
PeerIdentity
>
mPeerIdentity
;
RefPtr
<
dom
:
:
RTCCertificate
>
mCertificate
;
Maybe
<
PrincipalPrivacy
>
mRequestedPrivacy
;
std
:
:
string
mHandle
;
std
:
:
string
mName
;
nsCString
mHostname
;
nsCString
mEffectiveTLDPlus1
;
nsCOMPtr
<
nsISerialEventTarget
>
mSTSThread
;
RefPtr
<
DataChannelConnection
>
mDataConnection
;
unsigned
int
mDataChannelsOpened
=
0
;
unsigned
int
mDataChannelsClosed
=
0
;
bool
mForceIceTcp
;
RefPtr
<
MediaTransportHandler
>
mTransportHandler
;
UniquePtr
<
PCUuidGenerator
>
mUuidGen
;
UniquePtr
<
JsepSession
>
mJsepSession
;
UniquePtr
<
JsepSession
>
mUncommittedJsepSession
;
unsigned
long
mIceRestartCount
;
unsigned
long
mIceRollbackCount
;
bool
mCallTelemStarted
=
false
;
bool
mCallTelemEnded
=
false
;
RefPtr
<
GenericNonExclusivePromise
>
mFinalStatsQuery
;
UniquePtr
<
dom
:
:
RTCStatsReportInternal
>
mFinalStats
;
bool
mDisableLongTermStats
=
false
;
TimeStamp
mIceStartTime
;
static
std
:
:
map
<
uint64_t
PeerConnectionAutoTimer
>
sCallDurationTimers
;
bool
mTrickle
;
bool
mPrivateWindow
;
bool
mActiveOnWindow
;
uint16_t
mMaxReceiving
[
SdpMediaSection
:
:
kMediaTypes
]
;
uint16_t
mMaxSending
[
SdpMediaSection
:
:
kMediaTypes
]
;
std
:
:
vector
<
std
:
:
string
>
mRawTrickledCandidates
;
dom
:
:
RTCStatsTimestampMaker
mTimestampMaker
;
RefPtr
<
RTCStatsIdGenerator
>
mIdGenerator
;
nsTArray
<
RefPtr
<
DOMMediaStream
>
>
mReceiveStreams
;
DOMMediaStream
*
GetReceiveStream
(
const
std
:
:
string
&
aId
)
const
;
DOMMediaStream
*
CreateReceiveStream
(
const
std
:
:
string
&
aId
)
;
void
InitLocalAddrs
(
)
;
bool
ShouldForceProxy
(
)
const
;
std
:
:
unique_ptr
<
NrSocketProxyConfig
>
GetProxyConfig
(
)
const
;
class
StunAddrsHandler
:
public
net
:
:
StunAddrsListener
{
public
:
explicit
StunAddrsHandler
(
PeerConnectionImpl
*
aPc
)
:
mPcHandle
(
aPc
-
>
GetHandle
(
)
)
{
}
void
OnMDNSQueryComplete
(
const
nsCString
&
hostname
const
Maybe
<
nsCString
>
&
address
)
override
;
void
OnStunAddrsAvailable
(
const
net
:
:
NrIceStunAddrArray
&
addrs
)
override
;
private
:
const
std
:
:
string
mPcHandle
;
virtual
~
StunAddrsHandler
(
)
{
}
}
;
void
UpdateTransport
(
const
JsepTransceiver
&
aTransceiver
bool
aForceIceTcp
)
;
void
GatherIfReady
(
)
;
void
FlushIceCtxOperationQueueIfReady
(
)
;
void
PerformOrEnqueueIceCtxOperation
(
nsIRunnable
*
runnable
)
;
nsresult
SetTargetForDefaultLocalAddressLookup
(
)
;
void
EnsureIceGathering
(
bool
aDefaultRouteOnly
bool
aObfuscateHostAddresses
)
;
bool
GetPrefDefaultAddressOnly
(
)
const
;
bool
GetPrefObfuscateHostAddresses
(
)
const
;
bool
IsIceCtxReady
(
)
const
{
return
mLocalAddrsRequestState
=
=
STUN_ADDR_REQUEST_COMPLETE
;
}
void
EnsureTransports
(
const
JsepSession
&
aSession
)
;
void
UpdateRTCDtlsTransports
(
)
;
void
SaveStateForRollback
(
)
;
void
RestoreStateForRollback
(
)
;
std
:
:
set
<
RefPtr
<
dom
:
:
RTCDtlsTransport
>
>
GetActiveTransports
(
)
const
;
nsresult
UpdateTransports
(
const
JsepSession
&
aSession
const
bool
forceIceTcp
)
;
void
ResetStunAddrsForIceRestart
(
)
{
mStunAddrs
.
Clear
(
)
;
}
void
StartIceChecks
(
const
JsepSession
&
session
)
;
void
AddIceCandidate
(
const
std
:
:
string
&
candidate
const
std
:
:
string
&
aTransportId
const
std
:
:
string
&
aUFrag
)
;
nsresult
UpdateMediaPipelines
(
)
;
already_AddRefed
<
dom
:
:
RTCRtpTransceiver
>
CreateTransceiver
(
const
std
:
:
string
&
aId
bool
aIsVideo
const
dom
:
:
RTCRtpTransceiverInit
&
aInit
dom
:
:
MediaStreamTrack
*
aSendTrack
bool
aAddTrackMagic
ErrorResult
&
aRv
)
;
std
:
:
string
GetTransportIdMatchingSendTrack
(
const
dom
:
:
MediaStreamTrack
&
aTrack
)
const
;
bool
AnyLocalTrackHasPeerIdentity
(
)
const
;
bool
AnyCodecHasPluginID
(
uint64_t
aPluginID
)
;
already_AddRefed
<
nsIHttpChannelInternal
>
GetChannel
(
)
const
;
bool
HasPendingSetParameters
(
)
const
;
void
InvalidateLastReturnedParameters
(
)
;
RefPtr
<
WebrtcCallWrapper
>
mCall
;
bool
mRtxIsAllowed
=
true
;
bool
mDuplicateFingerprintQuirk
=
false
;
nsTArray
<
RefPtr
<
Operation
>
>
mOperations
;
bool
mChainingOperation
=
false
;
bool
mUpdateNegotiationNeededFlagOnEmptyChain
=
false
;
bool
mNegotiationNeeded
=
false
;
std
:
:
set
<
std
:
:
pair
<
std
:
:
string
std
:
:
string
>
>
mLocalIceCredentialsToReplace
;
nsTArray
<
RefPtr
<
dom
:
:
RTCRtpTransceiver
>
>
mTransceivers
;
RTCDtlsTransportMap
mTransportIdToRTCDtlsTransport
;
RefPtr
<
dom
:
:
RTCSctpTransport
>
mSctpTransport
;
RefPtr
<
dom
:
:
RTCSctpTransport
>
mLastStableSctpTransport
;
RefPtr
<
dom
:
:
RTCDtlsTransport
>
mLastStableSctpDtlsTransport
;
std
:
:
vector
<
nsCOMPtr
<
nsIRunnable
>
>
mQueuedIceCtxOperations
;
bool
mForceProxy
=
false
;
RefPtr
<
net
:
:
StunAddrsRequestChild
>
mStunAddrsRequest
;
enum
StunAddrRequestState
{
STUN_ADDR_REQUEST_NONE
STUN_ADDR_REQUEST_PENDING
STUN_ADDR_REQUEST_COMPLETE
}
;
StunAddrRequestState
mLocalAddrsRequestState
=
STUN_ADDR_REQUEST_NONE
;
nsTArray
<
NrIceStunAddr
>
mStunAddrs
;
bool
mTargetForDefaultLocalAddressLookupIsSet
=
false
;
std
:
:
map
<
std
:
:
string
std
:
:
string
>
mMDNSHostnamesToRegister
;
bool
mCanRegisterMDNSHostnamesDirectly
=
false
;
std
:
:
set
<
std
:
:
string
>
mRegisteredMDNSHostnames
;
bool
mAllowOldSetParameters
=
false
;
struct
PendingIceCandidate
{
std
:
:
vector
<
std
:
:
string
>
mTokenizedCandidate
;
std
:
:
string
mTransportId
;
std
:
:
string
mUfrag
;
}
;
std
:
:
map
<
std
:
:
string
std
:
:
list
<
PendingIceCandidate
>
>
mQueriedMDNSHostnames
;
MediaEventListener
mGatheringStateChangeListener
;
MediaEventListener
mConnectionStateChangeListener
;
MediaEventListener
mCandidateListener
;
MediaEventListener
mAlpnNegotiatedListener
;
MediaEventListener
mStateChangeListener
;
MediaEventListener
mRtcpStateChangeListener
;
RefPtr
<
PeerConnectionImpl
>
mKungFuDeathGrip
;
RefPtr
<
PacketDumper
>
mPacketDumper
;
public
:
unsigned
short
listenPort
;
unsigned
short
connectPort
;
char
*
connectStr
;
}
;
class
PeerConnectionWrapper
{
public
:
explicit
PeerConnectionWrapper
(
const
std
:
:
string
&
handle
)
;
PeerConnectionImpl
*
impl
(
)
{
return
impl_
;
}
private
:
RefPtr
<
PeerConnectionImpl
>
impl_
;
}
;
}
#
undef
NS_IMETHODIMP_TO_ERRORRESULT
#
undef
NS_IMETHODIMP_TO_ERRORRESULT_RETREF
#
endif
