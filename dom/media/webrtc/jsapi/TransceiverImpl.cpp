#
include
"
jsapi
/
TransceiverImpl
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
algorithm
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
libwebrtcglue
/
AudioConduit
.
h
"
#
include
"
libwebrtcglue
/
VideoConduit
.
h
"
#
include
"
MediaTrackGraph
.
h
"
#
include
"
transportbridge
/
MediaPipeline
.
h
"
#
include
"
transportbridge
/
MediaPipelineFilter
.
h
"
#
include
"
jsep
/
JsepTrack
.
h
"
#
include
"
sdp
/
SdpHelper
.
h
"
#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
transport
/
logging
.
h
"
#
include
"
MediaEngine
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
MediaSegment
.
h
"
#
include
"
RemoteTrackSource
.
h
"
#
include
"
libwebrtcglue
/
RtpRtcpConfig
.
h
"
#
include
"
MediaTransportHandler
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpReceiverBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpSenderBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpTransceiverBinding
.
h
"
#
include
"
mozilla
/
dom
/
TransceiverImplBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
RTCDtlsTransport
.
h
"
#
include
"
RTCRtpReceiver
.
h
"
#
include
"
RTCRtpSender
.
h
"
#
include
"
RTCDTMFSender
.
h
"
#
include
"
systemservices
/
MediaUtils
.
h
"
#
include
"
libwebrtcglue
/
WebrtcCallWrapper
.
h
"
#
include
"
libwebrtcglue
/
WebrtcGmpVideoCodec
.
h
"
namespace
mozilla
{
using
namespace
dom
;
namespace
{
struct
ConduitControlState
:
public
AudioConduitControlInterface
public
VideoConduitControlInterface
{
ConduitControlState
(
TransceiverImpl
*
aTransceiver
RTCRtpSender
*
aSender
RTCRtpReceiver
*
aReceiver
)
:
mTransceiver
(
new
nsMainThreadPtrHolder
<
TransceiverImpl
>
(
"
ConduitControlState
:
:
mTransceiver
"
aTransceiver
false
)
)
mSender
(
new
nsMainThreadPtrHolder
<
dom
:
:
RTCRtpSender
>
(
"
ConduitControlState
:
:
mSender
"
aSender
false
)
)
mReceiver
(
new
nsMainThreadPtrHolder
<
dom
:
:
RTCRtpReceiver
>
(
"
ConduitControlState
:
:
mReceiver
"
aReceiver
false
)
)
{
}
const
nsMainThreadPtrHandle
<
TransceiverImpl
>
mTransceiver
;
const
nsMainThreadPtrHandle
<
RTCRtpSender
>
mSender
;
const
nsMainThreadPtrHandle
<
RTCRtpReceiver
>
mReceiver
;
AbstractCanonical
<
bool
>
*
CanonicalReceiving
(
)
override
{
return
mReceiver
-
>
CanonicalReceiving
(
)
;
}
AbstractCanonical
<
bool
>
*
CanonicalTransmitting
(
)
override
{
return
mSender
-
>
CanonicalTransmitting
(
)
;
}
AbstractCanonical
<
Ssrcs
>
*
CanonicalLocalSsrcs
(
)
override
{
return
mSender
-
>
CanonicalSsrcs
(
)
;
}
AbstractCanonical
<
std
:
:
string
>
*
CanonicalLocalCname
(
)
override
{
return
mSender
-
>
CanonicalCname
(
)
;
}
AbstractCanonical
<
std
:
:
string
>
*
CanonicalMid
(
)
override
{
return
mTransceiver
-
>
CanonicalMid
(
)
;
}
AbstractCanonical
<
Ssrc
>
*
CanonicalRemoteSsrc
(
)
override
{
return
mReceiver
-
>
CanonicalSsrc
(
)
;
}
AbstractCanonical
<
std
:
:
string
>
*
CanonicalSyncGroup
(
)
override
{
return
mTransceiver
-
>
CanonicalSyncGroup
(
)
;
}
AbstractCanonical
<
RtpExtList
>
*
CanonicalLocalRecvRtpExtensions
(
)
override
{
return
mReceiver
-
>
CanonicalLocalRtpExtensions
(
)
;
}
AbstractCanonical
<
RtpExtList
>
*
CanonicalLocalSendRtpExtensions
(
)
override
{
return
mSender
-
>
CanonicalLocalRtpExtensions
(
)
;
}
AbstractCanonical
<
Maybe
<
AudioCodecConfig
>
>
*
CanonicalAudioSendCodec
(
)
override
{
return
mSender
-
>
CanonicalAudioCodec
(
)
;
}
AbstractCanonical
<
std
:
:
vector
<
AudioCodecConfig
>
>
*
CanonicalAudioRecvCodecs
(
)
override
{
return
mReceiver
-
>
CanonicalAudioCodecs
(
)
;
}
MediaEventSource
<
DtmfEvent
>
&
OnDtmfEvent
(
)
override
{
return
mSender
-
>
GetDtmf
(
)
-
>
OnDtmfEvent
(
)
;
}
AbstractCanonical
<
Ssrcs
>
*
CanonicalLocalVideoRtxSsrcs
(
)
override
{
return
mSender
-
>
CanonicalVideoRtxSsrcs
(
)
;
}
AbstractCanonical
<
Ssrc
>
*
CanonicalRemoteVideoRtxSsrc
(
)
override
{
return
mReceiver
-
>
CanonicalVideoRtxSsrc
(
)
;
}
AbstractCanonical
<
Maybe
<
VideoCodecConfig
>
>
*
CanonicalVideoSendCodec
(
)
override
{
return
mSender
-
>
CanonicalVideoCodec
(
)
;
}
AbstractCanonical
<
Maybe
<
RtpRtcpConfig
>
>
*
CanonicalVideoSendRtpRtcpConfig
(
)
override
{
return
mSender
-
>
CanonicalVideoRtpRtcpConfig
(
)
;
}
AbstractCanonical
<
std
:
:
vector
<
VideoCodecConfig
>
>
*
CanonicalVideoRecvCodecs
(
)
override
{
return
mReceiver
-
>
CanonicalVideoCodecs
(
)
;
}
AbstractCanonical
<
Maybe
<
RtpRtcpConfig
>
>
*
CanonicalVideoRecvRtpRtcpConfig
(
)
override
{
return
mReceiver
-
>
CanonicalVideoRtpRtcpConfig
(
)
;
}
AbstractCanonical
<
webrtc
:
:
VideoCodecMode
>
*
CanonicalVideoCodecMode
(
)
override
{
return
mSender
-
>
CanonicalVideoCodecMode
(
)
;
}
}
;
}
MOZ_MTLOG_MODULE
(
"
TransceiverImpl
"
)
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
TransceiverImpl
mWindow
mPc
mReceiver
mSender
mDtlsTransport
mLastStableDtlsTransport
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TransceiverImpl
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
TransceiverImpl
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
TransceiverImpl
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
#
define
INIT_CANONICAL
(
name
val
)
\
name
(
AbstractThread
:
:
MainThread
(
)
val
\
"
TransceiverImpl
:
:
"
#
name
"
(
Canonical
)
"
)
TransceiverImpl
:
:
TransceiverImpl
(
nsPIDOMWindowInner
*
aWindow
bool
aPrivacyNeeded
PeerConnectionImpl
*
aPc
MediaTransportHandler
*
aTransportHandler
JsepTransceiver
*
aJsepTransceiver
nsISerialEventTarget
*
aStsThread
dom
:
:
MediaStreamTrack
*
aSendTrack
WebrtcCallWrapper
*
aCallWrapper
RTCStatsIdGenerator
*
aIdGenerator
)
:
mWindow
(
aWindow
)
mPc
(
aPc
)
mTransportHandler
(
aTransportHandler
)
mJsepTransceiver
(
aJsepTransceiver
)
mStsThread
(
aStsThread
)
mCallWrapper
(
aCallWrapper
)
mIdGenerator
(
aIdGenerator
)
INIT_CANONICAL
(
mMid
std
:
:
string
(
)
)
INIT_CANONICAL
(
mSyncGroup
std
:
:
string
(
)
)
{
if
(
IsVideo
(
)
)
{
InitVideo
(
)
;
}
else
{
InitAudio
(
)
;
}
if
(
!
IsValid
(
)
)
{
return
;
}
mReceiver
=
new
RTCRtpReceiver
(
aWindow
aPrivacyNeeded
aPc
aTransportHandler
aJsepTransceiver
mCallWrapper
-
>
mCallThread
aStsThread
mConduit
this
)
;
mSender
=
new
RTCRtpSender
(
aWindow
aPc
aTransportHandler
aJsepTransceiver
mCallWrapper
-
>
mCallThread
aStsThread
mConduit
aSendTrack
this
)
;
if
(
mConduit
)
{
InitConduitControl
(
)
;
}
auto
self
=
nsMainThreadPtrHandle
<
TransceiverImpl
>
(
new
nsMainThreadPtrHolder
<
TransceiverImpl
>
(
"
TransceiverImpl
:
:
TransceiverImpl
:
:
self
"
this
false
)
)
;
mStsThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
TransceiverImpl
:
:
TransceiverImpl
"
[
self
]
{
self
-
>
mTransportHandler
-
>
SignalStateChange
.
connect
(
self
.
get
(
)
&
TransceiverImpl
:
:
UpdateDtlsTransportState
)
;
self
-
>
mTransportHandler
-
>
SignalRtcpStateChange
.
connect
(
self
.
get
(
)
&
TransceiverImpl
:
:
UpdateDtlsTransportState
)
;
}
)
)
;
}
#
undef
INIT_CANONICAL
TransceiverImpl
:
:
~
TransceiverImpl
(
)
=
default
;
void
TransceiverImpl
:
:
SetDtlsTransport
(
dom
:
:
RTCDtlsTransport
*
aDtlsTransport
bool
aStable
)
{
mDtlsTransport
=
aDtlsTransport
;
if
(
aStable
)
{
mLastStableDtlsTransport
=
mDtlsTransport
;
}
}
void
TransceiverImpl
:
:
RollbackToStableDtlsTransport
(
)
{
mDtlsTransport
=
mLastStableDtlsTransport
;
}
void
TransceiverImpl
:
:
UpdateDtlsTransportState
(
const
std
:
:
string
&
aTransportId
TransportLayer
:
:
State
aState
)
{
if
(
!
GetMainThreadEventTarget
(
)
-
>
IsOnCurrentThread
(
)
)
{
GetMainThreadEventTarget
(
)
-
>
Dispatch
(
WrapRunnable
(
this
&
TransceiverImpl
:
:
UpdateDtlsTransportState
aTransportId
aState
)
NS_DISPATCH_NORMAL
)
;
return
;
}
if
(
!
mDtlsTransport
)
{
return
;
}
mDtlsTransport
-
>
UpdateState
(
aState
)
;
}
void
TransceiverImpl
:
:
InitAudio
(
)
{
mConduit
=
AudioSessionConduit
:
:
Create
(
mCallWrapper
mStsThread
)
;
if
(
!
mConduit
)
{
MOZ_MTLOG
(
ML_ERROR
mPc
-
>
GetHandle
(
)
<
<
"
[
"
<
<
mMid
.
Ref
(
)
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
:
Failed
to
create
AudioSessionConduit
"
)
;
}
}
void
TransceiverImpl
:
:
InitVideo
(
)
{
VideoSessionConduit
:
:
Options
options
;
options
.
mVideoLatencyTestEnable
=
Preferences
:
:
GetBool
(
"
media
.
video
.
test_latency
"
false
)
;
options
.
mMinBitrate
=
std
:
:
max
(
0
Preferences
:
:
GetInt
(
"
media
.
peerconnection
.
video
.
min_bitrate
"
0
)
*
1000
)
;
options
.
mStartBitrate
=
std
:
:
max
(
0
Preferences
:
:
GetInt
(
"
media
.
peerconnection
.
video
.
start_bitrate
"
0
)
*
1000
)
;
options
.
mPrefMaxBitrate
=
std
:
:
max
(
0
Preferences
:
:
GetInt
(
"
media
.
peerconnection
.
video
.
max_bitrate
"
0
)
*
1000
)
;
if
(
options
.
mMinBitrate
!
=
0
&
&
options
.
mMinBitrate
<
kViEMinCodecBitrate_bps
)
{
options
.
mMinBitrate
=
kViEMinCodecBitrate_bps
;
}
if
(
options
.
mStartBitrate
<
options
.
mMinBitrate
)
{
options
.
mStartBitrate
=
options
.
mMinBitrate
;
}
if
(
options
.
mPrefMaxBitrate
&
&
options
.
mStartBitrate
>
options
.
mPrefMaxBitrate
)
{
options
.
mStartBitrate
=
options
.
mPrefMaxBitrate
;
}
options
.
mMinBitrateEstimate
=
std
:
:
max
(
0
Preferences
:
:
GetInt
(
"
media
.
peerconnection
.
video
.
min_bitrate_estimate
"
0
)
*
1000
)
;
options
.
mSpatialLayers
=
std
:
:
max
(
1
Preferences
:
:
GetInt
(
"
media
.
peerconnection
.
video
.
svc
.
spatial
"
0
)
)
;
options
.
mTemporalLayers
=
std
:
:
max
(
1
Preferences
:
:
GetInt
(
"
media
.
peerconnection
.
video
.
svc
.
temporal
"
0
)
)
;
options
.
mDenoising
=
Preferences
:
:
GetBool
(
"
media
.
peerconnection
.
video
.
denoising
"
false
)
;
options
.
mLockScaling
=
Preferences
:
:
GetBool
(
"
media
.
peerconnection
.
video
.
lock_scaling
"
false
)
;
mConduit
=
VideoSessionConduit
:
:
Create
(
mCallWrapper
mStsThread
std
:
:
move
(
options
)
mPc
-
>
GetHandle
(
)
)
;
if
(
!
mConduit
)
{
MOZ_MTLOG
(
ML_ERROR
mPc
-
>
GetHandle
(
)
<
<
"
[
"
<
<
mMid
.
Ref
(
)
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
:
Failed
to
create
VideoSessionConduit
"
)
;
}
}
void
TransceiverImpl
:
:
InitConduitControl
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mConduit
)
;
ConduitControlState
control
(
this
mSender
mReceiver
)
;
mCallWrapper
-
>
mCallThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
conduit
=
mConduit
control
=
std
:
:
move
(
control
)
]
(
)
mutable
{
conduit
-
>
AsVideoSessionConduit
(
)
.
apply
(
[
&
]
(
VideoSessionConduit
*
aConduit
)
{
aConduit
-
>
InitControl
(
&
control
)
;
}
)
;
conduit
-
>
AsAudioSessionConduit
(
)
.
apply
(
[
&
]
(
AudioSessionConduit
*
aConduit
)
{
aConduit
-
>
InitControl
(
&
control
)
;
}
)
;
}
)
)
;
}
void
TransceiverImpl
:
:
Shutdown_m
(
)
{
mShutdown
=
true
;
if
(
mDtlsTransport
)
{
mDtlsTransport
-
>
UpdateState
(
TransportLayer
:
:
TS_CLOSED
)
;
}
Stop
(
)
;
auto
self
=
nsMainThreadPtrHandle
<
TransceiverImpl
>
(
new
nsMainThreadPtrHolder
<
TransceiverImpl
>
(
"
TransceiverImpl
:
:
Shutdown_m
:
:
self
"
this
false
)
)
;
mStsThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
self
]
{
self
-
>
disconnect_all
(
)
;
self
-
>
mTransportHandler
=
nullptr
;
}
)
)
;
}
nsresult
TransceiverImpl
:
:
UpdateTransport
(
)
{
if
(
!
mJsepTransceiver
-
>
HasLevel
(
)
|
|
mJsepTransceiver
-
>
IsStopped
(
)
)
{
return
NS_OK
;
}
mReceiver
-
>
UpdateTransport
(
)
;
mSender
-
>
UpdateTransport
(
)
;
return
NS_OK
;
}
nsresult
TransceiverImpl
:
:
UpdateConduit
(
)
{
if
(
mJsepTransceiver
-
>
IsStopped
(
)
)
{
return
NS_OK
;
}
if
(
mJsepTransceiver
-
>
IsAssociated
(
)
)
{
mMid
=
mJsepTransceiver
-
>
GetMid
(
)
;
}
else
{
mMid
=
std
:
:
string
(
)
;
}
mReceiver
-
>
UpdateConduit
(
)
;
mSender
-
>
UpdateConduit
(
)
;
return
NS_OK
;
}
void
TransceiverImpl
:
:
ResetSync
(
)
{
mSyncGroup
=
std
:
:
string
(
)
;
}
nsresult
TransceiverImpl
:
:
SyncWithMatchingVideoConduits
(
nsTArray
<
RefPtr
<
TransceiverImpl
>
>
&
transceivers
)
{
if
(
mJsepTransceiver
-
>
IsStopped
(
)
)
{
return
NS_OK
;
}
if
(
IsVideo
(
)
)
{
MOZ_MTLOG
(
ML_ERROR
mPc
-
>
GetHandle
(
)
<
<
"
[
"
<
<
mMid
.
Ref
(
)
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
called
when
transceiver
is
not
"
"
video
!
This
should
never
happen
.
"
)
;
MOZ_CRASH
(
)
;
return
NS_ERROR_UNEXPECTED
;
}
std
:
:
set
<
std
:
:
string
>
myReceiveStreamIds
;
myReceiveStreamIds
.
insert
(
mJsepTransceiver
-
>
mRecvTrack
.
GetStreamIds
(
)
.
begin
(
)
mJsepTransceiver
-
>
mRecvTrack
.
GetStreamIds
(
)
.
end
(
)
)
;
for
(
RefPtr
<
TransceiverImpl
>
&
transceiver
:
transceivers
)
{
if
(
!
transceiver
-
>
IsValid
(
)
)
{
continue
;
}
if
(
!
transceiver
-
>
IsVideo
(
)
)
{
continue
;
}
for
(
const
std
:
:
string
&
streamId
:
transceiver
-
>
mJsepTransceiver
-
>
mRecvTrack
.
GetStreamIds
(
)
)
{
if
(
myReceiveStreamIds
.
count
(
streamId
)
)
{
mSyncGroup
=
streamId
;
transceiver
-
>
mSyncGroup
=
streamId
;
MOZ_MTLOG
(
ML_DEBUG
mPc
-
>
GetHandle
(
)
<
<
"
[
"
<
<
mMid
.
Ref
(
)
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
Syncing
"
<
<
mConduit
.
get
(
)
<
<
"
to
"
<
<
transceiver
-
>
mConduit
.
get
(
)
)
;
break
;
}
}
}
return
NS_OK
;
}
bool
TransceiverImpl
:
:
ConduitHasPluginID
(
uint64_t
aPluginID
)
{
return
mConduit
&
&
mConduit
-
>
HasCodecPluginID
(
aPluginID
)
;
}
void
TransceiverImpl
:
:
SyncWithJS
(
dom
:
:
RTCRtpTransceiver
&
aJsTransceiver
ErrorResult
&
aRv
)
{
MOZ_MTLOG
(
ML_DEBUG
mPc
-
>
GetHandle
(
)
<
<
"
[
"
<
<
mMid
.
Ref
(
)
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
Syncing
with
JS
transceiver
"
)
;
MOZ_ASSERT
(
!
mSyncing
)
;
mSyncing
=
true
;
if
(
mShutdown
)
{
mSyncing
=
false
;
return
;
}
if
(
mJsepTransceiver
-
>
IsStopped
(
)
)
{
aJsTransceiver
.
SetStopped
(
aRv
)
;
Stop
(
)
;
}
else
if
(
aJsTransceiver
.
GetStopped
(
aRv
)
)
{
mJsepTransceiver
-
>
Stop
(
)
;
Stop
(
)
;
}
if
(
aRv
.
Failed
(
)
)
{
mSyncing
=
false
;
return
;
}
dom
:
:
RTCRtpTransceiverDirection
direction
=
aJsTransceiver
.
GetDirection
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
mSyncing
=
false
;
return
;
}
switch
(
direction
)
{
case
dom
:
:
RTCRtpTransceiverDirection
:
:
Sendrecv
:
mJsepTransceiver
-
>
mJsDirection
=
SdpDirectionAttribute
:
:
Direction
:
:
kSendrecv
;
break
;
case
dom
:
:
RTCRtpTransceiverDirection
:
:
Sendonly
:
mJsepTransceiver
-
>
mJsDirection
=
SdpDirectionAttribute
:
:
Direction
:
:
kSendonly
;
break
;
case
dom
:
:
RTCRtpTransceiverDirection
:
:
Recvonly
:
mJsepTransceiver
-
>
mJsDirection
=
SdpDirectionAttribute
:
:
Direction
:
:
kRecvonly
;
break
;
case
dom
:
:
RTCRtpTransceiverDirection
:
:
Inactive
:
mJsepTransceiver
-
>
mJsDirection
=
SdpDirectionAttribute
:
:
Direction
:
:
kInactive
;
break
;
default
:
MOZ_ASSERT
(
false
)
;
aRv
=
NS_ERROR_INVALID_ARG
;
mSyncing
=
false
;
return
;
}
if
(
!
mJsepTransceiver
-
>
mRecvTrack
.
GetRemoteSetSendBit
(
)
|
|
!
mJsepTransceiver
-
>
mRecvTrack
.
GetActive
(
)
)
{
mReceiver
-
>
Stop
(
)
;
}
if
(
mJsepTransceiver
-
>
IsAssociated
(
)
)
{
aJsTransceiver
.
SetMid
(
NS_ConvertUTF8toUTF16
(
mJsepTransceiver
-
>
GetMid
(
)
.
c_str
(
)
)
aRv
)
;
}
else
{
aJsTransceiver
.
UnsetMid
(
aRv
)
;
}
if
(
aRv
.
Failed
(
)
)
{
mSyncing
=
false
;
return
;
}
if
(
mJsepTransceiver
-
>
HasLevel
(
)
&
&
mJsepTransceiver
-
>
IsNegotiated
(
)
)
{
if
(
IsReceiving
(
)
)
{
if
(
IsSending
(
)
)
{
aJsTransceiver
.
SetCurrentDirection
(
dom
:
:
RTCRtpTransceiverDirection
:
:
Sendrecv
aRv
)
;
}
else
{
aJsTransceiver
.
SetCurrentDirection
(
dom
:
:
RTCRtpTransceiverDirection
:
:
Recvonly
aRv
)
;
}
}
else
{
if
(
IsSending
(
)
)
{
aJsTransceiver
.
SetCurrentDirection
(
dom
:
:
RTCRtpTransceiverDirection
:
:
Sendonly
aRv
)
;
}
else
{
aJsTransceiver
.
SetCurrentDirection
(
dom
:
:
RTCRtpTransceiverDirection
:
:
Inactive
aRv
)
;
}
}
if
(
aRv
.
Failed
(
)
)
{
mSyncing
=
false
;
return
;
}
}
if
(
aJsTransceiver
.
GetAddTrackMagic
(
aRv
)
)
{
mJsepTransceiver
-
>
SetAddTrackMagic
(
)
;
}
if
(
aRv
.
Failed
(
)
)
{
mSyncing
=
false
;
return
;
}
if
(
mJsepTransceiver
-
>
IsRemoved
(
)
)
{
aJsTransceiver
.
SetShouldRemove
(
true
aRv
)
;
}
mSyncing
=
false
;
}
void
TransceiverImpl
:
:
GetKind
(
nsAString
&
aKind
)
const
{
mReceiver
-
>
Track
(
)
-
>
GetKind
(
aKind
)
;
}
bool
TransceiverImpl
:
:
CanSendDTMF
(
)
const
{
if
(
!
IsSending
(
)
|
|
!
mSender
-
>
GetTrack
(
)
)
{
return
false
;
}
JsepTrackNegotiatedDetails
*
details
=
mJsepTransceiver
-
>
mSendTrack
.
GetNegotiatedDetails
(
)
;
if
(
NS_WARN_IF
(
!
details
|
|
!
details
-
>
GetEncodingCount
(
)
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
details
-
>
GetEncodingCount
(
)
;
+
+
i
)
{
const
auto
&
encoding
=
details
-
>
GetEncoding
(
i
)
;
for
(
const
auto
&
codec
:
encoding
.
GetCodecs
(
)
)
{
if
(
codec
-
>
mName
=
=
"
telephone
-
event
"
)
{
return
true
;
}
}
}
return
false
;
}
JSObject
*
TransceiverImpl
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
TransceiverImpl_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsPIDOMWindowInner
*
TransceiverImpl
:
:
GetParentObject
(
)
const
{
return
mWindow
;
}
static
void
JsepCodecDescToAudioCodecConfig
(
const
JsepAudioCodecDescription
&
aCodec
Maybe
<
AudioCodecConfig
>
*
aConfig
)
{
uint16_t
pt
;
if
(
NS_WARN_IF
(
!
aCodec
.
GetPtAsInt
(
&
pt
)
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Invalid
payload
type
:
"
<
<
aCodec
.
mDefaultPt
)
;
MOZ_ASSERT
(
false
)
;
return
;
}
*
aConfig
=
Some
(
AudioCodecConfig
(
pt
aCodec
.
mName
aCodec
.
mClock
aCodec
.
mForceMono
?
1
:
aCodec
.
mChannels
aCodec
.
mFECEnabled
)
)
;
(
*
aConfig
)
-
>
mMaxPlaybackRate
=
aCodec
.
mMaxPlaybackRate
;
(
*
aConfig
)
-
>
mDtmfEnabled
=
aCodec
.
mDtmfEnabled
;
(
*
aConfig
)
-
>
mDTXEnabled
=
aCodec
.
mDTXEnabled
;
(
*
aConfig
)
-
>
mMaxAverageBitrate
=
aCodec
.
mMaxAverageBitrate
;
(
*
aConfig
)
-
>
mFrameSizeMs
=
aCodec
.
mFrameSizeMs
;
(
*
aConfig
)
-
>
mMinFrameSizeMs
=
aCodec
.
mMinFrameSizeMs
;
(
*
aConfig
)
-
>
mMaxFrameSizeMs
=
aCodec
.
mMaxFrameSizeMs
;
(
*
aConfig
)
-
>
mCbrEnabled
=
aCodec
.
mCbrEnabled
;
}
Maybe
<
const
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
&
>
TransceiverImpl
:
:
GetNegotiatedSendCodecs
(
)
const
{
if
(
!
IsSending
(
)
)
{
return
Nothing
(
)
;
}
const
auto
*
details
=
mJsepTransceiver
-
>
mSendTrack
.
GetNegotiatedDetails
(
)
;
if
(
!
details
)
{
return
Nothing
(
)
;
}
if
(
details
-
>
GetEncodingCount
(
)
=
=
0
)
{
return
Nothing
(
)
;
}
return
SomeRef
(
details
-
>
GetEncoding
(
0
)
.
GetCodecs
(
)
)
;
}
Maybe
<
const
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
&
>
TransceiverImpl
:
:
GetNegotiatedRecvCodecs
(
)
const
{
if
(
!
IsReceiving
(
)
)
{
return
Nothing
(
)
;
}
const
auto
*
details
=
mJsepTransceiver
-
>
mRecvTrack
.
GetNegotiatedDetails
(
)
;
if
(
!
details
)
{
return
Nothing
(
)
;
}
if
(
details
-
>
GetEncodingCount
(
)
=
=
0
)
{
return
Nothing
(
)
;
}
return
SomeRef
(
details
-
>
GetEncoding
(
0
)
.
GetCodecs
(
)
)
;
}
void
TransceiverImpl
:
:
NegotiatedDetailsToAudioCodecConfigs
(
const
JsepTrackNegotiatedDetails
&
aDetails
std
:
:
vector
<
AudioCodecConfig
>
*
aConfigs
)
{
Maybe
<
AudioCodecConfig
>
telephoneEvent
;
if
(
aDetails
.
GetEncodingCount
(
)
)
{
for
(
const
auto
&
codec
:
aDetails
.
GetEncoding
(
0
)
.
GetCodecs
(
)
)
{
if
(
NS_WARN_IF
(
codec
-
>
Type
(
)
!
=
SdpMediaSection
:
:
kAudio
)
)
{
MOZ_ASSERT
(
false
"
Codec
is
not
audio
!
This
is
a
JSEP
bug
.
"
)
;
return
;
}
Maybe
<
AudioCodecConfig
>
config
;
const
JsepAudioCodecDescription
&
audio
=
static_cast
<
const
JsepAudioCodecDescription
&
>
(
*
codec
)
;
JsepCodecDescToAudioCodecConfig
(
audio
&
config
)
;
if
(
config
-
>
mName
=
=
"
telephone
-
event
"
)
{
telephoneEvent
=
std
:
:
move
(
config
)
;
}
else
{
aConfigs
-
>
push_back
(
std
:
:
move
(
*
config
)
)
;
}
}
}
if
(
telephoneEvent
)
{
aConfigs
-
>
push_back
(
std
:
:
move
(
*
telephoneEvent
)
)
;
}
}
auto
TransceiverImpl
:
:
GetActivePayloadTypes
(
)
const
-
>
RefPtr
<
ActivePayloadTypesPromise
>
{
if
(
!
mConduit
)
{
return
ActivePayloadTypesPromise
:
:
CreateAndResolve
(
PayloadTypes
(
)
__func__
)
;
}
if
(
!
mCallWrapper
)
{
return
ActivePayloadTypesPromise
:
:
CreateAndResolve
(
PayloadTypes
(
)
__func__
)
;
}
return
InvokeAsync
(
mCallWrapper
-
>
mCallThread
__func__
[
conduit
=
mConduit
]
(
)
{
PayloadTypes
pts
;
pts
.
mSendPayloadType
=
conduit
-
>
ActiveSendPayloadType
(
)
;
pts
.
mRecvPayloadType
=
conduit
-
>
ActiveRecvPayloadType
(
)
;
return
ActivePayloadTypesPromise
:
:
CreateAndResolve
(
std
:
:
move
(
pts
)
__func__
)
;
}
)
;
}
static
void
JsepCodecDescToVideoCodecConfig
(
const
JsepVideoCodecDescription
&
aCodec
Maybe
<
VideoCodecConfig
>
*
aConfig
)
{
uint16_t
pt
;
if
(
NS_WARN_IF
(
!
aCodec
.
GetPtAsInt
(
&
pt
)
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Invalid
payload
type
:
"
<
<
aCodec
.
mDefaultPt
)
;
MOZ_ASSERT
(
false
)
;
return
;
}
UniquePtr
<
VideoCodecConfigH264
>
h264Config
;
if
(
aCodec
.
mName
=
=
"
H264
"
)
{
h264Config
=
MakeUnique
<
VideoCodecConfigH264
>
(
)
;
size_t
spropSize
=
sizeof
(
h264Config
-
>
sprop_parameter_sets
)
;
strncpy
(
h264Config
-
>
sprop_parameter_sets
aCodec
.
mSpropParameterSets
.
c_str
(
)
spropSize
)
;
h264Config
-
>
sprop_parameter_sets
[
spropSize
-
1
]
=
'
\
0
'
;
h264Config
-
>
packetization_mode
=
aCodec
.
mPacketizationMode
;
h264Config
-
>
profile_level_id
=
aCodec
.
mProfileLevelId
;
h264Config
-
>
tias_bw
=
0
;
}
*
aConfig
=
Some
(
VideoCodecConfig
(
pt
aCodec
.
mName
aCodec
.
mConstraints
h264Config
.
get
(
)
)
)
;
(
*
aConfig
)
-
>
mAckFbTypes
=
aCodec
.
mAckFbTypes
;
(
*
aConfig
)
-
>
mNackFbTypes
=
aCodec
.
mNackFbTypes
;
(
*
aConfig
)
-
>
mCcmFbTypes
=
aCodec
.
mCcmFbTypes
;
(
*
aConfig
)
-
>
mRembFbSet
=
aCodec
.
RtcpFbRembIsSet
(
)
;
(
*
aConfig
)
-
>
mFECFbSet
=
aCodec
.
mFECEnabled
;
(
*
aConfig
)
-
>
mTransportCCFbSet
=
aCodec
.
RtcpFbTransportCCIsSet
(
)
;
if
(
aCodec
.
mFECEnabled
)
{
uint16_t
pt
;
if
(
SdpHelper
:
:
GetPtAsInt
(
aCodec
.
mREDPayloadType
&
pt
)
)
{
(
*
aConfig
)
-
>
mREDPayloadType
=
pt
;
}
if
(
SdpHelper
:
:
GetPtAsInt
(
aCodec
.
mULPFECPayloadType
&
pt
)
)
{
(
*
aConfig
)
-
>
mULPFECPayloadType
=
pt
;
}
}
if
(
aCodec
.
mRtxEnabled
)
{
uint16_t
pt
;
if
(
SdpHelper
:
:
GetPtAsInt
(
aCodec
.
mRtxPayloadType
&
pt
)
)
{
(
*
aConfig
)
-
>
mRTXPayloadType
=
pt
;
}
}
}
void
TransceiverImpl
:
:
NegotiatedDetailsToVideoCodecConfigs
(
const
JsepTrackNegotiatedDetails
&
aDetails
std
:
:
vector
<
VideoCodecConfig
>
*
aConfigs
)
{
if
(
aDetails
.
GetEncodingCount
(
)
)
{
for
(
const
auto
&
codec
:
aDetails
.
GetEncoding
(
0
)
.
GetCodecs
(
)
)
{
if
(
NS_WARN_IF
(
codec
-
>
Type
(
)
!
=
SdpMediaSection
:
:
kVideo
)
)
{
MOZ_ASSERT
(
false
"
Codec
is
not
video
!
This
is
a
JSEP
bug
.
"
)
;
return
;
}
Maybe
<
VideoCodecConfig
>
config
;
const
JsepVideoCodecDescription
&
video
=
static_cast
<
const
JsepVideoCodecDescription
&
>
(
*
codec
)
;
JsepCodecDescToVideoCodecConfig
(
video
&
config
)
;
config
-
>
mTias
=
aDetails
.
GetTias
(
)
;
for
(
size_t
i
=
0
;
i
<
aDetails
.
GetEncodingCount
(
)
;
+
+
i
)
{
const
JsepTrackEncoding
&
jsepEncoding
(
aDetails
.
GetEncoding
(
i
)
)
;
if
(
jsepEncoding
.
HasFormat
(
video
.
mDefaultPt
)
)
{
VideoCodecConfig
:
:
Encoding
encoding
;
encoding
.
rid
=
jsepEncoding
.
mRid
;
encoding
.
constraints
=
jsepEncoding
.
mConstraints
;
config
-
>
mEncodings
.
push_back
(
encoding
)
;
}
}
aConfigs
-
>
push_back
(
std
:
:
move
(
*
config
)
)
;
}
}
}
void
TransceiverImpl
:
:
Stop
(
)
{
if
(
mStopped
)
{
return
;
}
mSender
-
>
Stop
(
)
;
mReceiver
-
>
Stop
(
)
;
if
(
mCallWrapper
)
{
auto
conduit
=
std
:
:
move
(
mConduit
)
;
(
conduit
?
conduit
-
>
Shutdown
(
)
:
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
sender
=
mSender
receiver
=
mReceiver
]
(
)
mutable
{
sender
-
>
Shutdown
(
)
;
receiver
-
>
Shutdown
(
)
;
}
)
;
mCallWrapper
=
nullptr
;
}
mStopped
=
true
;
}
bool
TransceiverImpl
:
:
IsVideo
(
)
const
{
return
mJsepTransceiver
-
>
GetMediaType
(
)
=
=
SdpMediaSection
:
:
MediaType
:
:
kVideo
;
}
void
TransceiverImpl
:
:
ChainToDomPromiseWithCodecStats
(
nsTArray
<
RefPtr
<
RTCStatsPromise
>
>
aStats
const
RefPtr
<
dom
:
:
Promise
>
&
aDomPromise
)
{
nsTArray
<
RTCCodecStats
>
codecStats
=
mPc
-
>
GetCodecStats
(
mPc
-
>
GetTimestampMaker
(
)
.
GetNow
(
)
)
;
AutoTArray
<
std
:
:
tuple
<
TransceiverImpl
*
RefPtr
<
RTCStatsPromise
:
:
AllPromiseType
>
>
1
>
statsPromises
;
statsPromises
.
AppendElement
(
std
:
:
make_tuple
(
this
RTCStatsPromise
:
:
All
(
GetMainThreadSerialEventTarget
(
)
aStats
)
)
)
;
ApplyCodecStats
(
std
:
:
move
(
codecStats
)
std
:
:
move
(
statsPromises
)
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
aDomPromise
window
=
mWindow
idGen
=
mIdGenerator
]
(
UniquePtr
<
RTCStatsCollection
>
aStats
)
mutable
{
AutoTArray
<
UniquePtr
<
RTCStatsCollection
>
1
>
stats
;
stats
.
AppendElement
(
std
:
:
move
(
aStats
)
)
;
RTCStatsCollection
opaqueStats
;
idGen
-
>
RewriteIds
(
std
:
:
move
(
stats
)
&
opaqueStats
)
;
RefPtr
<
RTCStatsReport
>
report
(
new
RTCStatsReport
(
window
)
)
;
report
-
>
Incorporate
(
opaqueStats
)
;
aDomPromise
-
>
MaybeResolve
(
std
:
:
move
(
report
)
)
;
}
[
aDomPromise
]
(
nsresult
aError
)
{
aDomPromise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
}
)
;
}
RefPtr
<
RTCStatsPromise
>
TransceiverImpl
:
:
ApplyCodecStats
(
nsTArray
<
RTCCodecStats
>
aCodecStats
nsTArray
<
std
:
:
tuple
<
TransceiverImpl
*
RefPtr
<
RTCStatsPromise
:
:
AllPromiseType
>
>
>
aTransceiverStatsPromises
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
codecStats
=
MakeRefPtr
<
media
:
:
Refcountable
<
nsTArray
<
RTCCodecStats
>
>
>
(
)
;
*
codecStats
=
std
:
:
move
(
aCodecStats
)
;
struct
IdComparator
{
bool
operator
(
)
(
const
RTCCodecStats
&
aA
const
RTCCodecStats
&
aB
)
const
{
return
aA
.
mId
.
Value
(
)
<
aB
.
mId
.
Value
(
)
;
}
}
;
auto
finalCodecStats
=
MakeRefPtr
<
media
:
:
Refcountable
<
std
:
:
set
<
RTCCodecStats
IdComparator
>
>
>
(
)
;
nsTArray
<
RefPtr
<
RTCStatsPromise
>
>
promises
(
aTransceiverStatsPromises
.
Length
(
)
)
;
for
(
const
auto
&
[
transceiver
allPromise
]
:
aTransceiverStatsPromises
)
{
auto
payloadTypes
=
MakeRefPtr
<
media
:
:
Refcountable
<
TransceiverImpl
:
:
PayloadTypes
>
>
(
)
;
promises
.
AppendElement
(
transceiver
-
>
GetActivePayloadTypes
(
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
payloadTypes
allPromise
=
allPromise
]
(
TransceiverImpl
:
:
PayloadTypes
aPayloadTypes
)
{
*
payloadTypes
=
std
:
:
move
(
aPayloadTypes
)
;
return
allPromise
;
}
[
]
{
MOZ_CRASH
(
"
Unexpected
reject
"
)
;
return
RTCStatsPromise
:
:
AllPromiseType
:
:
CreateAndReject
(
NS_ERROR_UNEXPECTED
__func__
)
;
}
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
codecStats
finalCodecStats
payloadTypes
transportId
=
NS_ConvertASCIItoUTF16
(
transceiver
-
>
GetTransportId
(
)
)
]
(
nsTArray
<
UniquePtr
<
RTCStatsCollection
>
>
aTransceiverStats
)
mutable
{
auto
report
=
MakeUnique
<
RTCStatsCollection
>
(
)
;
FlattenStats
(
std
:
:
move
(
aTransceiverStats
)
report
.
get
(
)
)
;
Maybe
<
RTCCodecStats
&
>
sendCodec
;
Maybe
<
RTCCodecStats
&
>
recvCodec
;
for
(
auto
&
codec
:
*
codecStats
)
{
if
(
payloadTypes
-
>
mSendPayloadType
.
isSome
(
)
=
=
sendCodec
.
isSome
(
)
&
&
payloadTypes
-
>
mRecvPayloadType
.
isSome
(
)
=
=
recvCodec
.
isSome
(
)
)
{
break
;
}
if
(
codec
.
mTransportId
!
=
transportId
)
{
continue
;
}
if
(
payloadTypes
-
>
mSendPayloadType
&
&
*
payloadTypes
-
>
mSendPayloadType
=
=
static_cast
<
int
>
(
codec
.
mPayloadType
)
&
&
(
!
codec
.
mCodecType
.
WasPassed
(
)
|
|
codec
.
mCodecType
.
Value
(
)
=
=
RTCCodecType
:
:
Encode
)
)
{
MOZ_ASSERT
(
!
sendCodec
"
At
most
one
send
codec
stat
per
transceiver
"
)
;
sendCodec
=
SomeRef
(
codec
)
;
}
if
(
payloadTypes
-
>
mRecvPayloadType
&
&
*
payloadTypes
-
>
mRecvPayloadType
=
=
static_cast
<
int
>
(
codec
.
mPayloadType
)
&
&
(
!
codec
.
mCodecType
.
WasPassed
(
)
|
|
codec
.
mCodecType
.
Value
(
)
=
=
RTCCodecType
:
:
Decode
)
)
{
MOZ_ASSERT
(
!
recvCodec
"
At
most
one
recv
codec
stat
per
transceiver
"
)
;
recvCodec
=
SomeRef
(
codec
)
;
}
}
if
(
sendCodec
)
{
finalCodecStats
-
>
insert
(
*
sendCodec
)
;
for
(
auto
&
stat
:
report
-
>
mOutboundRtpStreamStats
)
{
stat
.
mCodecId
.
Construct
(
sendCodec
-
>
mId
.
Value
(
)
)
;
}
for
(
auto
&
stat
:
report
-
>
mRemoteInboundRtpStreamStats
)
{
stat
.
mCodecId
.
Construct
(
sendCodec
-
>
mId
.
Value
(
)
)
;
}
}
if
(
recvCodec
)
{
finalCodecStats
-
>
insert
(
*
recvCodec
)
;
for
(
auto
&
stat
:
report
-
>
mInboundRtpStreamStats
)
{
stat
.
mCodecId
.
Construct
(
recvCodec
-
>
mId
.
Value
(
)
)
;
}
for
(
auto
&
stat
:
report
-
>
mRemoteOutboundRtpStreamStats
)
{
stat
.
mCodecId
.
Construct
(
recvCodec
-
>
mId
.
Value
(
)
)
;
}
}
return
RTCStatsPromise
:
:
CreateAndResolve
(
std
:
:
move
(
report
)
__func__
)
;
}
[
]
{
MOZ_CRASH
(
"
Unexpected
reject
"
)
;
return
RTCStatsPromise
:
:
CreateAndReject
(
NS_ERROR_UNEXPECTED
__func__
)
;
}
)
)
;
}
return
RTCStatsPromise
:
:
All
(
GetMainThreadSerialEventTarget
(
)
promises
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
finalCodecStats
=
std
:
:
move
(
finalCodecStats
)
]
(
nsTArray
<
UniquePtr
<
RTCStatsCollection
>
>
aStats
)
mutable
{
auto
finalStats
=
MakeUnique
<
RTCStatsCollection
>
(
)
;
FlattenStats
(
std
:
:
move
(
aStats
)
finalStats
.
get
(
)
)
;
MOZ_ASSERT
(
finalStats
-
>
mCodecStats
.
IsEmpty
(
)
)
;
if
(
!
finalStats
-
>
mCodecStats
.
SetCapacity
(
finalCodecStats
-
>
size
(
)
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
while
(
!
finalCodecStats
-
>
empty
(
)
)
{
auto
node
=
finalCodecStats
-
>
extract
(
finalCodecStats
-
>
begin
(
)
)
;
if
(
!
finalStats
-
>
mCodecStats
.
AppendElement
(
std
:
:
move
(
node
.
value
(
)
)
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
return
RTCStatsPromise
:
:
CreateAndResolve
(
std
:
:
move
(
finalStats
)
__func__
)
;
}
[
]
{
MOZ_CRASH
(
"
Unexpected
reject
"
)
;
return
RTCStatsPromise
:
:
CreateAndReject
(
NS_ERROR_UNEXPECTED
__func__
)
;
}
)
;
}
}
