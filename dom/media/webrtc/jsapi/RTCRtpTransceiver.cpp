#
include
"
jsapi
/
RTCRtpTransceiver
.
h
"
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
string
>
#
include
<
vector
>
#
include
<
utility
>
#
include
<
set
>
#
include
<
string
>
#
include
<
tuple
>
#
include
"
api
/
video_codecs
/
video_codec
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
PrincipalHandle
.
h
"
#
include
"
ErrorList
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
mozalloc_oom
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
dom
/
RTCStatsReportBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpReceiverBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpSenderBinding
.
h
"
#
include
"
mozilla
/
dom
/
RTCRtpTransceiverBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
utils
/
PerformanceRecorder
.
h
"
#
include
"
systemservices
/
MediaUtils
.
h
"
#
include
"
MediaTrackGraph
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
libwebrtcglue
/
AudioConduit
.
h
"
#
include
"
libwebrtcglue
/
VideoConduit
.
h
"
#
include
"
transportbridge
/
MediaPipeline
.
h
"
#
include
"
jsep
/
JsepTrack
.
h
"
#
include
"
sdp
/
SdpHelper
.
h
"
#
include
"
transport
/
logging
.
h
"
#
include
"
RemoteTrackSource
.
h
"
#
include
"
libwebrtcglue
/
RtpRtcpConfig
.
h
"
#
include
"
MediaTransportHandler
.
h
"
#
include
"
RTCDtlsTransport
.
h
"
#
include
"
RTCRtpReceiver
.
h
"
#
include
"
RTCRtpSender
.
h
"
#
include
"
RTCDTMFSender
.
h
"
#
include
"
PeerConnectionImpl
.
h
"
#
include
"
RTCStatsIdGenerator
.
h
"
#
include
"
libwebrtcglue
/
WebrtcCallWrapper
.
h
"
#
include
"
libwebrtcglue
/
FrameTransformerProxy
.
h
"
#
include
"
jsep
/
JsepCodecDescription
.
h
"
#
include
"
jsep
/
JsepSession
.
h
"
#
include
"
jsep
/
JsepTrackEncoding
.
h
"
#
include
"
libwebrtcglue
/
CodecConfig
.
h
"
#
include
"
libwebrtcglue
/
MediaConduitControl
.
h
"
#
include
"
libwebrtcglue
/
MediaConduitInterface
.
h
"
#
include
"
RTCStatsReport
.
h
"
#
include
"
sdp
/
SdpAttribute
.
h
"
#
include
"
sdp
/
SdpEnum
.
h
"
#
include
"
sdp
/
SdpMediaSection
.
h
"
#
include
"
transport
/
transportlayer
.
h
"
namespace
mozilla
{
using
namespace
dom
;
namespace
{
struct
ConduitControlState
:
public
AudioConduitControlInterface
public
VideoConduitControlInterface
{
ConduitControlState
(
RTCRtpTransceiver
*
aTransceiver
RTCRtpSender
*
aSender
RTCRtpReceiver
*
aReceiver
)
:
mTransceiver
(
new
nsMainThreadPtrHolder
<
RTCRtpTransceiver
>
(
"
ConduitControlState
:
:
mTransceiver
"
aTransceiver
false
)
)
mSender
(
new
nsMainThreadPtrHolder
<
dom
:
:
RTCRtpSender
>
(
"
ConduitControlState
:
:
mSender
"
aSender
false
)
)
mReceiver
(
new
nsMainThreadPtrHolder
<
dom
:
:
RTCRtpReceiver
>
(
"
ConduitControlState
:
:
mReceiver
"
aReceiver
false
)
)
{
}
const
nsMainThreadPtrHandle
<
RTCRtpTransceiver
>
mTransceiver
;
const
nsMainThreadPtrHandle
<
RTCRtpSender
>
mSender
;
const
nsMainThreadPtrHandle
<
RTCRtpReceiver
>
mReceiver
;
Canonical
<
bool
>
&
CanonicalReceiving
(
)
override
{
return
mReceiver
-
>
CanonicalReceiving
(
)
;
}
Canonical
<
bool
>
&
CanonicalTransmitting
(
)
override
{
return
mSender
-
>
CanonicalTransmitting
(
)
;
}
Canonical
<
Ssrcs
>
&
CanonicalLocalSsrcs
(
)
override
{
return
mSender
-
>
CanonicalSsrcs
(
)
;
}
Canonical
<
std
:
:
string
>
&
CanonicalLocalCname
(
)
override
{
return
mSender
-
>
CanonicalCname
(
)
;
}
Canonical
<
std
:
:
string
>
&
CanonicalMid
(
)
override
{
return
mTransceiver
-
>
CanonicalMid
(
)
;
}
Canonical
<
Ssrc
>
&
CanonicalRemoteSsrc
(
)
override
{
return
mReceiver
-
>
CanonicalSsrc
(
)
;
}
Canonical
<
std
:
:
string
>
&
CanonicalSyncGroup
(
)
override
{
return
mTransceiver
-
>
CanonicalSyncGroup
(
)
;
}
Canonical
<
RtpExtList
>
&
CanonicalLocalRecvRtpExtensions
(
)
override
{
return
mReceiver
-
>
CanonicalLocalRtpExtensions
(
)
;
}
Canonical
<
RtpExtList
>
&
CanonicalLocalSendRtpExtensions
(
)
override
{
return
mSender
-
>
CanonicalLocalRtpExtensions
(
)
;
}
Canonical
<
Maybe
<
AudioCodecConfig
>
>
&
CanonicalAudioSendCodec
(
)
override
{
return
mSender
-
>
CanonicalAudioCodec
(
)
;
}
Canonical
<
std
:
:
vector
<
AudioCodecConfig
>
>
&
CanonicalAudioRecvCodecs
(
)
override
{
return
mReceiver
-
>
CanonicalAudioCodecs
(
)
;
}
MediaEventSource
<
DtmfEvent
>
&
OnDtmfEvent
(
)
override
{
return
mSender
-
>
GetDtmf
(
)
-
>
OnDtmfEvent
(
)
;
}
Canonical
<
Ssrcs
>
&
CanonicalLocalVideoRtxSsrcs
(
)
override
{
return
mSender
-
>
CanonicalVideoRtxSsrcs
(
)
;
}
Canonical
<
Ssrc
>
&
CanonicalRemoteVideoRtxSsrc
(
)
override
{
return
mReceiver
-
>
CanonicalVideoRtxSsrc
(
)
;
}
Canonical
<
Maybe
<
VideoCodecConfig
>
>
&
CanonicalVideoSendCodec
(
)
override
{
return
mSender
-
>
CanonicalVideoCodec
(
)
;
}
Canonical
<
Maybe
<
RtpRtcpConfig
>
>
&
CanonicalVideoSendRtpRtcpConfig
(
)
override
{
return
mSender
-
>
CanonicalVideoRtpRtcpConfig
(
)
;
}
Canonical
<
std
:
:
vector
<
VideoCodecConfig
>
>
&
CanonicalVideoRecvCodecs
(
)
override
{
return
mReceiver
-
>
CanonicalVideoCodecs
(
)
;
}
Canonical
<
Maybe
<
RtpRtcpConfig
>
>
&
CanonicalVideoRecvRtpRtcpConfig
(
)
override
{
return
mReceiver
-
>
CanonicalVideoRtpRtcpConfig
(
)
;
}
Canonical
<
webrtc
:
:
VideoCodecMode
>
&
CanonicalVideoCodecMode
(
)
override
{
return
mSender
-
>
CanonicalVideoCodecMode
(
)
;
}
Canonical
<
RefPtr
<
FrameTransformerProxy
>
>
&
CanonicalFrameTransformerProxySend
(
)
override
{
return
mSender
-
>
CanonicalFrameTransformerProxy
(
)
;
}
Canonical
<
RefPtr
<
FrameTransformerProxy
>
>
&
CanonicalFrameTransformerProxyRecv
(
)
override
{
return
mReceiver
-
>
CanonicalFrameTransformerProxy
(
)
;
}
}
;
}
MOZ_MTLOG_MODULE
(
"
RTCRtpTransceiver
"
)
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
RTCRtpTransceiver
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
RTCRtpTransceiver
)
tmp
-
>
Unlink
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
RTCRtpTransceiver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mWindow
mPc
mSendTrack
mReceiver
mSender
mDtlsTransport
mLastStableDtlsTransport
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
RTCRtpTransceiver
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
RTCRtpTransceiver
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
RTCRtpTransceiver
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
#
define
INIT_CANONICAL
(
name
val
)
\
name
(
AbstractThread
:
:
MainThread
(
)
val
\
"
RTCRtpTransceiver
:
:
"
#
name
"
(
Canonical
)
"
)
RTCRtpTransceiver
:
:
RTCRtpTransceiver
(
nsPIDOMWindowInner
*
aWindow
bool
aPrivacyNeeded
PeerConnectionImpl
*
aPc
MediaTransportHandler
*
aTransportHandler
JsepSession
*
aJsepSession
const
std
:
:
string
&
aTransceiverId
bool
aIsVideo
nsISerialEventTarget
*
aStsThread
dom
:
:
MediaStreamTrack
*
aSendTrack
WebrtcCallWrapper
*
aCallWrapper
RTCStatsIdGenerator
*
aIdGenerator
)
:
mWindow
(
aWindow
)
mPc
(
aPc
)
mTransportHandler
(
aTransportHandler
)
mTransceiverId
(
aTransceiverId
)
mJsepTransceiver
(
*
aJsepSession
-
>
GetTransceiver
(
mTransceiverId
)
)
mStsThread
(
aStsThread
)
mCallWrapper
(
aCallWrapper
)
mSendTrack
(
aSendTrack
)
mIdGenerator
(
aIdGenerator
)
mPrincipalPrivacy
(
aPrivacyNeeded
?
PrincipalPrivacy
:
:
Private
:
PrincipalPrivacy
:
:
NonPrivate
)
mIsVideo
(
aIsVideo
)
INIT_CANONICAL
(
mMid
std
:
:
string
(
)
)
INIT_CANONICAL
(
mSyncGroup
std
:
:
string
(
)
)
{
}
#
undef
INIT_CANONICAL
RTCRtpTransceiver
:
:
~
RTCRtpTransceiver
(
)
=
default
;
SdpDirectionAttribute
:
:
Direction
ToSdpDirection
(
RTCRtpTransceiverDirection
aDirection
)
{
switch
(
aDirection
)
{
case
dom
:
:
RTCRtpTransceiverDirection
:
:
Sendrecv
:
return
SdpDirectionAttribute
:
:
Direction
:
:
kSendrecv
;
case
dom
:
:
RTCRtpTransceiverDirection
:
:
Sendonly
:
return
SdpDirectionAttribute
:
:
Direction
:
:
kSendonly
;
case
dom
:
:
RTCRtpTransceiverDirection
:
:
Recvonly
:
return
SdpDirectionAttribute
:
:
Direction
:
:
kRecvonly
;
case
dom
:
:
RTCRtpTransceiverDirection
:
:
Inactive
:
case
dom
:
:
RTCRtpTransceiverDirection
:
:
Stopped
:
return
SdpDirectionAttribute
:
:
Direction
:
:
kInactive
;
case
dom
:
:
RTCRtpTransceiverDirection
:
:
EndGuard_
:
;
}
MOZ_CRASH
(
"
Invalid
transceiver
direction
!
"
)
;
}
static
uint32_t
sRemoteSourceId
=
0
;
void
RTCRtpTransceiver
:
:
Init
(
const
RTCRtpTransceiverInit
&
aInit
ErrorResult
&
aRv
)
{
TrackingId
trackingId
(
TrackingId
:
:
Source
:
:
RTCRtpReceiver
sRemoteSourceId
+
+
TrackingId
:
:
TrackAcrossProcesses
:
:
Yes
)
;
if
(
IsVideo
(
)
)
{
InitVideo
(
trackingId
)
;
}
else
{
InitAudio
(
)
;
}
if
(
!
IsValid
(
)
)
{
aRv
=
NS_ERROR_UNEXPECTED
;
return
;
}
mReceiver
=
new
RTCRtpReceiver
(
mWindow
mPrincipalPrivacy
mPc
mTransportHandler
mCallWrapper
-
>
mCallThread
mStsThread
mConduit
this
trackingId
)
;
mSender
=
new
RTCRtpSender
(
mWindow
mPc
mTransportHandler
mCallWrapper
-
>
mCallThread
mStsThread
mConduit
mSendTrack
aInit
.
mSendEncodings
this
)
;
if
(
mConduit
)
{
InitConduitControl
(
)
;
}
mSender
-
>
SetStreamsImpl
(
aInit
.
mStreams
)
;
mDirection
=
aInit
.
mDirection
;
}
void
RTCRtpTransceiver
:
:
SetDtlsTransport
(
dom
:
:
RTCDtlsTransport
*
aDtlsTransport
)
{
mDtlsTransport
=
aDtlsTransport
;
}
void
RTCRtpTransceiver
:
:
SaveStateForRollback
(
)
{
mLastStableDtlsTransport
=
mDtlsTransport
;
}
void
RTCRtpTransceiver
:
:
RollbackToStableDtlsTransport
(
)
{
mDtlsTransport
=
mLastStableDtlsTransport
;
}
void
RTCRtpTransceiver
:
:
InitAudio
(
)
{
mConduit
=
AudioSessionConduit
:
:
Create
(
mCallWrapper
mStsThread
)
;
if
(
!
mConduit
)
{
MOZ_MTLOG
(
ML_ERROR
mPc
-
>
GetHandle
(
)
<
<
"
[
"
<
<
mMid
.
Ref
(
)
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
:
Failed
to
create
AudioSessionConduit
"
)
;
}
}
void
RTCRtpTransceiver
:
:
InitVideo
(
const
TrackingId
&
aRecvTrackingId
)
{
VideoSessionConduit
:
:
Options
options
;
options
.
mVideoLatencyTestEnable
=
Preferences
:
:
GetBool
(
"
media
.
video
.
test_latency
"
false
)
;
options
.
mMinBitrate
=
std
:
:
max
(
0
Preferences
:
:
GetInt
(
"
media
.
peerconnection
.
video
.
min_bitrate
"
0
)
*
1000
)
;
options
.
mStartBitrate
=
std
:
:
max
(
0
Preferences
:
:
GetInt
(
"
media
.
peerconnection
.
video
.
start_bitrate
"
0
)
*
1000
)
;
options
.
mPrefMaxBitrate
=
std
:
:
max
(
0
Preferences
:
:
GetInt
(
"
media
.
peerconnection
.
video
.
max_bitrate
"
0
)
*
1000
)
;
if
(
options
.
mMinBitrate
!
=
0
&
&
options
.
mMinBitrate
<
kViEMinCodecBitrate_bps
)
{
options
.
mMinBitrate
=
kViEMinCodecBitrate_bps
;
}
if
(
options
.
mStartBitrate
<
options
.
mMinBitrate
)
{
options
.
mStartBitrate
=
options
.
mMinBitrate
;
}
if
(
options
.
mPrefMaxBitrate
&
&
options
.
mStartBitrate
>
options
.
mPrefMaxBitrate
)
{
options
.
mStartBitrate
=
options
.
mPrefMaxBitrate
;
}
options
.
mMinBitrateEstimate
=
std
:
:
max
(
0
Preferences
:
:
GetInt
(
"
media
.
peerconnection
.
video
.
min_bitrate_estimate
"
0
)
*
1000
)
;
options
.
mSpatialLayers
=
std
:
:
max
(
1
Preferences
:
:
GetInt
(
"
media
.
peerconnection
.
video
.
svc
.
spatial
"
0
)
)
;
options
.
mTemporalLayers
=
std
:
:
max
(
1
Preferences
:
:
GetInt
(
"
media
.
peerconnection
.
video
.
svc
.
temporal
"
0
)
)
;
options
.
mDenoising
=
Preferences
:
:
GetBool
(
"
media
.
peerconnection
.
video
.
denoising
"
false
)
;
options
.
mLockScaling
=
Preferences
:
:
GetBool
(
"
media
.
peerconnection
.
video
.
lock_scaling
"
false
)
;
mConduit
=
VideoSessionConduit
:
:
Create
(
mCallWrapper
mStsThread
std
:
:
move
(
options
)
mPc
-
>
GetHandle
(
)
aRecvTrackingId
)
;
if
(
!
mConduit
)
{
MOZ_MTLOG
(
ML_ERROR
mPc
-
>
GetHandle
(
)
<
<
"
[
"
<
<
mMid
.
Ref
(
)
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
:
Failed
to
create
VideoSessionConduit
"
)
;
}
}
void
RTCRtpTransceiver
:
:
InitConduitControl
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mConduit
)
;
ConduitControlState
control
(
this
mSender
mReceiver
)
;
mConduit
-
>
AsVideoSessionConduit
(
)
.
apply
(
[
&
]
(
auto
aConduit
)
{
aConduit
-
>
InitControl
(
&
control
)
;
}
)
;
mConduit
-
>
AsAudioSessionConduit
(
)
.
apply
(
[
&
]
(
auto
aConduit
)
{
aConduit
-
>
InitControl
(
&
control
)
;
}
)
;
}
void
RTCRtpTransceiver
:
:
Close
(
)
{
mShutdown
=
true
;
if
(
mDtlsTransport
)
{
mDtlsTransport
-
>
UpdateStateNoEvent
(
TransportLayer
:
:
TS_CLOSED
)
;
if
(
mDtlsTransport
-
>
IceTransport
(
)
)
{
mDtlsTransport
-
>
IceTransport
(
)
-
>
SetState
(
RTCIceTransportState
:
:
Closed
)
;
}
}
StopImpl
(
)
;
}
void
RTCRtpTransceiver
:
:
BreakCycles
(
)
{
mSender
-
>
BreakCycles
(
)
;
mReceiver
-
>
BreakCycles
(
)
;
mWindow
=
nullptr
;
mSendTrack
=
nullptr
;
mSender
=
nullptr
;
mReceiver
=
nullptr
;
mDtlsTransport
=
nullptr
;
mLastStableDtlsTransport
=
nullptr
;
mPc
=
nullptr
;
}
void
RTCRtpTransceiver
:
:
Unlink
(
)
{
if
(
mHandlingUnlink
)
{
BreakCycles
(
)
;
mHandlingUnlink
=
false
;
}
else
if
(
mPc
)
{
mPc
-
>
Close
(
)
;
mPc
-
>
BreakCycles
(
)
;
}
}
nsresult
RTCRtpTransceiver
:
:
UpdateTransport
(
)
{
if
(
!
mHasTransport
)
{
return
NS_OK
;
}
mReceiver
-
>
UpdateTransport
(
)
;
mSender
-
>
UpdateTransport
(
)
;
return
NS_OK
;
}
nsresult
RTCRtpTransceiver
:
:
UpdateConduit
(
)
{
if
(
mStopped
)
{
return
NS_OK
;
}
mReceiver
-
>
UpdateConduit
(
)
;
mSender
-
>
MaybeUpdateConduit
(
)
;
return
NS_OK
;
}
void
RTCRtpTransceiver
:
:
UpdatePrincipalPrivacy
(
PrincipalPrivacy
aPrivacy
)
{
if
(
mPrincipalPrivacy
=
=
aPrivacy
)
{
return
;
}
mPrincipalPrivacy
=
aPrivacy
;
mReceiver
-
>
UpdatePrincipalPrivacy
(
mPrincipalPrivacy
)
;
}
void
RTCRtpTransceiver
:
:
ResetSync
(
)
{
mSyncGroup
=
std
:
:
string
(
)
;
}
nsresult
RTCRtpTransceiver
:
:
SyncWithMatchingVideoConduits
(
nsTArray
<
RefPtr
<
RTCRtpTransceiver
>
>
&
transceivers
)
{
if
(
mStopped
)
{
return
NS_OK
;
}
if
(
IsVideo
(
)
)
{
MOZ_MTLOG
(
ML_ERROR
mPc
-
>
GetHandle
(
)
<
<
"
[
"
<
<
mMid
.
Ref
(
)
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
called
when
transceiver
is
not
"
"
video
!
This
should
never
happen
.
"
)
;
MOZ_CRASH
(
)
;
return
NS_ERROR_UNEXPECTED
;
}
std
:
:
set
<
std
:
:
string
>
myReceiveStreamIds
;
myReceiveStreamIds
.
insert
(
mReceiver
-
>
GetStreamIds
(
)
.
begin
(
)
mReceiver
-
>
GetStreamIds
(
)
.
end
(
)
)
;
for
(
RefPtr
<
RTCRtpTransceiver
>
&
transceiver
:
transceivers
)
{
if
(
!
transceiver
-
>
IsValid
(
)
)
{
continue
;
}
if
(
!
transceiver
-
>
IsVideo
(
)
)
{
continue
;
}
for
(
const
std
:
:
string
&
streamId
:
transceiver
-
>
Receiver
(
)
-
>
GetStreamIds
(
)
)
{
if
(
myReceiveStreamIds
.
count
(
streamId
)
)
{
mSyncGroup
=
streamId
;
transceiver
-
>
mSyncGroup
=
streamId
;
MOZ_MTLOG
(
ML_DEBUG
mPc
-
>
GetHandle
(
)
<
<
"
[
"
<
<
mMid
.
Ref
(
)
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
Syncing
"
<
<
mConduit
.
get
(
)
<
<
"
to
"
<
<
transceiver
-
>
mConduit
.
get
(
)
)
;
break
;
}
}
}
return
NS_OK
;
}
bool
RTCRtpTransceiver
:
:
ConduitHasPluginID
(
uint64_t
aPluginID
)
{
return
mConduit
&
&
mConduit
-
>
HasCodecPluginID
(
aPluginID
)
;
}
void
RTCRtpTransceiver
:
:
SyncFromJsep
(
const
JsepSession
&
aSession
)
{
MOZ_MTLOG
(
ML_DEBUG
mPc
-
>
GetHandle
(
)
<
<
"
[
"
<
<
mMid
.
Ref
(
)
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
Syncing
from
JSEP
transceiver
"
)
;
if
(
mShutdown
)
{
return
;
}
mJsepTransceiver
=
*
aSession
.
GetTransceiver
(
mTransceiverId
)
;
if
(
!
mStopped
&
&
mJsepTransceiver
.
IsStopped
(
)
)
{
MOZ_MTLOG
(
ML_DEBUG
mPc
-
>
GetHandle
(
)
<
<
"
[
"
<
<
mMid
.
Ref
(
)
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
JSEP
transceiver
is
stopped
"
)
;
StopImpl
(
)
;
}
mReceiver
-
>
SyncFromJsep
(
mJsepTransceiver
)
;
mSender
-
>
SyncFromJsep
(
mJsepTransceiver
)
;
if
(
mJsepTransceiver
.
IsAssociated
(
)
)
{
mMid
=
mJsepTransceiver
.
GetMid
(
)
;
}
else
{
mMid
=
std
:
:
string
(
)
;
}
if
(
mJsepTransceiver
.
HasLevel
(
)
&
&
mJsepTransceiver
.
IsNegotiated
(
)
)
{
if
(
mJsepTransceiver
.
mRecvTrack
.
GetActive
(
)
)
{
if
(
mJsepTransceiver
.
mSendTrack
.
GetActive
(
)
)
{
mCurrentDirection
.
SetValue
(
dom
:
:
RTCRtpTransceiverDirection
:
:
Sendrecv
)
;
mHasBeenUsedToSend
=
true
;
}
else
{
mCurrentDirection
.
SetValue
(
dom
:
:
RTCRtpTransceiverDirection
:
:
Recvonly
)
;
}
}
else
{
if
(
mJsepTransceiver
.
mSendTrack
.
GetActive
(
)
)
{
mCurrentDirection
.
SetValue
(
dom
:
:
RTCRtpTransceiverDirection
:
:
Sendonly
)
;
mHasBeenUsedToSend
=
true
;
}
else
{
mCurrentDirection
.
SetValue
(
dom
:
:
RTCRtpTransceiverDirection
:
:
Inactive
)
;
}
}
}
mShouldRemove
=
mJsepTransceiver
.
IsRemoved
(
)
;
mHasTransport
=
!
mStopped
&
&
mJsepTransceiver
.
mTransport
.
mComponents
;
}
void
RTCRtpTransceiver
:
:
SyncToJsep
(
JsepSession
&
aSession
)
const
{
MOZ_MTLOG
(
ML_DEBUG
mPc
-
>
GetHandle
(
)
<
<
"
[
"
<
<
mMid
.
Ref
(
)
<
<
"
]
:
"
<
<
__FUNCTION__
<
<
"
Syncing
to
JSEP
transceiver
"
)
;
aSession
.
ApplyToTransceiver
(
mTransceiverId
[
this
self
=
RefPtr
<
const
RTCRtpTransceiver
>
(
this
)
]
(
JsepTransceiver
&
aTransceiver
)
{
mReceiver
-
>
SyncToJsep
(
aTransceiver
)
;
mSender
-
>
SyncToJsep
(
aTransceiver
)
;
aTransceiver
.
mJsDirection
=
ToSdpDirection
(
mDirection
)
;
if
(
mStopping
|
|
mStopped
)
{
aTransceiver
.
Stop
(
)
;
}
}
)
;
}
void
RTCRtpTransceiver
:
:
GetKind
(
nsAString
&
aKind
)
const
{
MOZ_ASSERT
(
mReceiver
&
&
mReceiver
-
>
Track
(
)
)
;
mReceiver
-
>
Track
(
)
-
>
GetKind
(
aKind
)
;
}
void
RTCRtpTransceiver
:
:
GetMid
(
nsAString
&
aMid
)
const
{
if
(
!
mMid
.
Ref
(
)
.
empty
(
)
)
{
aMid
=
NS_ConvertUTF8toUTF16
(
mMid
.
Ref
(
)
)
;
}
else
{
aMid
.
SetIsVoid
(
true
)
;
}
}
std
:
:
string
RTCRtpTransceiver
:
:
GetMidAscii
(
)
const
{
if
(
mMid
.
Ref
(
)
.
empty
(
)
)
{
return
std
:
:
string
(
)
;
}
return
mMid
.
Ref
(
)
;
}
void
RTCRtpTransceiver
:
:
SetDirection
(
RTCRtpTransceiverDirection
aDirection
ErrorResult
&
aRv
)
{
if
(
mStopping
)
{
aRv
.
ThrowInvalidStateError
(
"
Transceiver
is
stopping
/
stopped
!
"
)
;
return
;
}
if
(
aDirection
=
=
mDirection
)
{
return
;
}
if
(
aDirection
=
=
RTCRtpTransceiverDirection
:
:
Stopped
)
{
aRv
.
ThrowTypeError
(
"
Cannot
use
\
"
stopped
\
"
in
setDirection
!
"
)
;
return
;
}
SetDirectionInternal
(
aDirection
)
;
mPc
-
>
UpdateNegotiationNeeded
(
)
;
}
void
RTCRtpTransceiver
:
:
SetDirectionInternal
(
RTCRtpTransceiverDirection
aDirection
)
{
mDirection
=
aDirection
;
}
bool
RTCRtpTransceiver
:
:
ShouldRemove
(
)
const
{
return
mShouldRemove
;
}
bool
RTCRtpTransceiver
:
:
CanSendDTMF
(
)
const
{
if
(
!
IsSending
(
)
|
|
!
mSender
-
>
GetTrack
(
)
|
|
Stopping
(
)
)
{
return
false
;
}
const
JsepTrackNegotiatedDetails
*
details
=
mJsepTransceiver
.
mSendTrack
.
GetNegotiatedDetails
(
)
;
if
(
NS_WARN_IF
(
!
details
|
|
!
details
-
>
GetEncodingCount
(
)
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
details
-
>
GetEncodingCount
(
)
;
+
+
i
)
{
const
auto
&
encoding
=
details
-
>
GetEncoding
(
i
)
;
for
(
const
auto
&
codec
:
encoding
.
GetCodecs
(
)
)
{
if
(
codec
-
>
mName
=
=
"
telephone
-
event
"
)
{
return
true
;
}
}
}
return
false
;
}
JSObject
*
RTCRtpTransceiver
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
RTCRtpTransceiver_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsPIDOMWindowInner
*
RTCRtpTransceiver
:
:
GetParentObject
(
)
const
{
return
mWindow
;
}
static
void
JsepCodecDescToAudioCodecConfig
(
const
JsepAudioCodecDescription
&
aCodec
Maybe
<
AudioCodecConfig
>
*
aConfig
)
{
uint16_t
pt
;
if
(
NS_WARN_IF
(
!
aCodec
.
GetPtAsInt
(
&
pt
)
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Invalid
payload
type
:
"
<
<
aCodec
.
mDefaultPt
)
;
MOZ_ASSERT
(
false
)
;
return
;
}
bool
sendMono
=
aCodec
.
mForceMono
&
&
aCodec
.
mDirection
=
=
sdp
:
:
kSend
;
*
aConfig
=
Some
(
AudioCodecConfig
(
pt
aCodec
.
mName
static_cast
<
int
>
(
aCodec
.
mClock
)
sendMono
?
1
:
static_cast
<
int
>
(
aCodec
.
mChannels
)
aCodec
.
mFECEnabled
)
)
;
(
*
aConfig
)
-
>
mMaxPlaybackRate
=
static_cast
<
int
>
(
aCodec
.
mMaxPlaybackRate
)
;
(
*
aConfig
)
-
>
mDtmfEnabled
=
aCodec
.
mDtmfEnabled
;
(
*
aConfig
)
-
>
mDTXEnabled
=
aCodec
.
mDTXEnabled
;
(
*
aConfig
)
-
>
mMaxAverageBitrate
=
aCodec
.
mMaxAverageBitrate
;
(
*
aConfig
)
-
>
mFrameSizeMs
=
aCodec
.
mFrameSizeMs
;
(
*
aConfig
)
-
>
mMinFrameSizeMs
=
aCodec
.
mMinFrameSizeMs
;
(
*
aConfig
)
-
>
mMaxFrameSizeMs
=
aCodec
.
mMaxFrameSizeMs
;
(
*
aConfig
)
-
>
mCbrEnabled
=
aCodec
.
mCbrEnabled
;
}
Maybe
<
const
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
&
>
RTCRtpTransceiver
:
:
GetNegotiatedSendCodecs
(
)
const
{
if
(
!
mJsepTransceiver
.
mSendTrack
.
GetActive
(
)
)
{
return
Nothing
(
)
;
}
const
auto
*
details
=
mJsepTransceiver
.
mSendTrack
.
GetNegotiatedDetails
(
)
;
if
(
!
details
)
{
return
Nothing
(
)
;
}
if
(
details
-
>
GetEncodingCount
(
)
=
=
0
)
{
return
Nothing
(
)
;
}
return
SomeRef
(
details
-
>
GetEncoding
(
0
)
.
GetCodecs
(
)
)
;
}
Maybe
<
const
std
:
:
vector
<
UniquePtr
<
JsepCodecDescription
>
>
&
>
RTCRtpTransceiver
:
:
GetNegotiatedRecvCodecs
(
)
const
{
if
(
!
mJsepTransceiver
.
mRecvTrack
.
GetActive
(
)
)
{
return
Nothing
(
)
;
}
const
auto
*
details
=
mJsepTransceiver
.
mRecvTrack
.
GetNegotiatedDetails
(
)
;
if
(
!
details
)
{
return
Nothing
(
)
;
}
if
(
details
-
>
GetEncodingCount
(
)
=
=
0
)
{
return
Nothing
(
)
;
}
return
SomeRef
(
details
-
>
GetEncoding
(
0
)
.
GetCodecs
(
)
)
;
}
void
RTCRtpTransceiver
:
:
NegotiatedDetailsToAudioCodecConfigs
(
const
JsepTrackNegotiatedDetails
&
aDetails
std
:
:
vector
<
AudioCodecConfig
>
*
aConfigs
)
{
Maybe
<
AudioCodecConfig
>
telephoneEvent
;
if
(
aDetails
.
GetEncodingCount
(
)
)
{
for
(
const
auto
&
codec
:
aDetails
.
GetEncoding
(
0
)
.
GetCodecs
(
)
)
{
if
(
NS_WARN_IF
(
codec
-
>
Type
(
)
!
=
SdpMediaSection
:
:
kAudio
)
)
{
MOZ_ASSERT
(
false
"
Codec
is
not
audio
!
This
is
a
JSEP
bug
.
"
)
;
return
;
}
Maybe
<
AudioCodecConfig
>
config
;
const
JsepAudioCodecDescription
&
audio
=
static_cast
<
const
JsepAudioCodecDescription
&
>
(
*
codec
)
;
JsepCodecDescToAudioCodecConfig
(
audio
&
config
)
;
if
(
config
-
>
mName
=
=
"
telephone
-
event
"
)
{
telephoneEvent
=
std
:
:
move
(
config
)
;
}
else
{
aConfigs
-
>
push_back
(
std
:
:
move
(
*
config
)
)
;
}
}
}
if
(
telephoneEvent
)
{
aConfigs
-
>
push_back
(
std
:
:
move
(
*
telephoneEvent
)
)
;
}
}
auto
RTCRtpTransceiver
:
:
GetActivePayloadTypes
(
)
const
-
>
RefPtr
<
ActivePayloadTypesPromise
>
{
if
(
!
mConduit
)
{
return
ActivePayloadTypesPromise
:
:
CreateAndResolve
(
PayloadTypes
(
)
__func__
)
;
}
if
(
!
mCallWrapper
)
{
return
ActivePayloadTypesPromise
:
:
CreateAndResolve
(
PayloadTypes
(
)
__func__
)
;
}
return
InvokeAsync
(
mCallWrapper
-
>
mCallThread
__func__
[
conduit
=
mConduit
]
(
)
{
PayloadTypes
pts
;
pts
.
mSendPayloadType
=
conduit
-
>
ActiveSendPayloadType
(
)
;
pts
.
mRecvPayloadType
=
conduit
-
>
ActiveRecvPayloadType
(
)
;
return
ActivePayloadTypesPromise
:
:
CreateAndResolve
(
std
:
:
move
(
pts
)
__func__
)
;
}
)
;
}
static
void
JsepCodecDescToVideoCodecConfig
(
const
JsepVideoCodecDescription
&
aCodec
Maybe
<
VideoCodecConfig
>
*
aConfig
)
{
uint16_t
pt
;
if
(
NS_WARN_IF
(
!
aCodec
.
GetPtAsInt
(
&
pt
)
)
)
{
MOZ_MTLOG
(
ML_ERROR
"
Invalid
payload
type
:
"
<
<
aCodec
.
mDefaultPt
)
;
MOZ_ASSERT
(
false
)
;
return
;
}
UniquePtr
<
VideoCodecConfigH264
>
h264Config
;
if
(
aCodec
.
mName
=
=
"
H264
"
)
{
h264Config
=
MakeUnique
<
VideoCodecConfigH264
>
(
)
;
size_t
spropSize
=
sizeof
(
h264Config
-
>
sprop_parameter_sets
)
;
strncpy
(
h264Config
-
>
sprop_parameter_sets
aCodec
.
mSpropParameterSets
.
c_str
(
)
spropSize
)
;
h264Config
-
>
sprop_parameter_sets
[
spropSize
-
1
]
=
'
\
0
'
;
h264Config
-
>
packetization_mode
=
static_cast
<
int
>
(
aCodec
.
mPacketizationMode
)
;
h264Config
-
>
profile_level_id
=
static_cast
<
int
>
(
aCodec
.
mProfileLevelId
)
;
h264Config
-
>
tias_bw
=
0
;
}
*
aConfig
=
Some
(
VideoCodecConfig
(
pt
aCodec
.
mName
aCodec
.
mConstraints
h264Config
.
get
(
)
)
)
;
(
*
aConfig
)
-
>
mAckFbTypes
=
aCodec
.
mAckFbTypes
;
(
*
aConfig
)
-
>
mNackFbTypes
=
aCodec
.
mNackFbTypes
;
(
*
aConfig
)
-
>
mCcmFbTypes
=
aCodec
.
mCcmFbTypes
;
(
*
aConfig
)
-
>
mRembFbSet
=
aCodec
.
RtcpFbRembIsSet
(
)
;
(
*
aConfig
)
-
>
mFECFbSet
=
aCodec
.
mFECEnabled
;
(
*
aConfig
)
-
>
mTransportCCFbSet
=
aCodec
.
RtcpFbTransportCCIsSet
(
)
;
if
(
aCodec
.
mFECEnabled
)
{
uint16_t
pt
;
if
(
SdpHelper
:
:
GetPtAsInt
(
aCodec
.
mREDPayloadType
&
pt
)
)
{
(
*
aConfig
)
-
>
mREDPayloadType
=
pt
;
}
if
(
SdpHelper
:
:
GetPtAsInt
(
aCodec
.
mULPFECPayloadType
&
pt
)
)
{
(
*
aConfig
)
-
>
mULPFECPayloadType
=
pt
;
}
if
(
SdpHelper
:
:
GetPtAsInt
(
aCodec
.
mREDRTXPayloadType
&
pt
)
)
{
(
*
aConfig
)
-
>
mREDRTXPayloadType
=
pt
;
}
}
if
(
aCodec
.
mRtxEnabled
)
{
uint16_t
pt
;
if
(
SdpHelper
:
:
GetPtAsInt
(
aCodec
.
mRtxPayloadType
&
pt
)
)
{
(
*
aConfig
)
-
>
mRTXPayloadType
=
pt
;
}
}
}
void
RTCRtpTransceiver
:
:
NegotiatedDetailsToVideoCodecConfigs
(
const
JsepTrackNegotiatedDetails
&
aDetails
std
:
:
vector
<
VideoCodecConfig
>
*
aConfigs
)
{
if
(
aDetails
.
GetEncodingCount
(
)
)
{
for
(
const
auto
&
codec
:
aDetails
.
GetEncoding
(
0
)
.
GetCodecs
(
)
)
{
if
(
NS_WARN_IF
(
codec
-
>
Type
(
)
!
=
SdpMediaSection
:
:
kVideo
)
)
{
MOZ_ASSERT
(
false
"
Codec
is
not
video
!
This
is
a
JSEP
bug
.
"
)
;
return
;
}
Maybe
<
VideoCodecConfig
>
config
;
const
JsepVideoCodecDescription
&
video
=
static_cast
<
const
JsepVideoCodecDescription
&
>
(
*
codec
)
;
JsepCodecDescToVideoCodecConfig
(
video
&
config
)
;
config
-
>
mTias
=
aDetails
.
GetTias
(
)
;
for
(
size_t
i
=
0
;
i
<
aDetails
.
GetEncodingCount
(
)
;
+
+
i
)
{
const
JsepTrackEncoding
&
jsepEncoding
(
aDetails
.
GetEncoding
(
i
)
)
;
if
(
jsepEncoding
.
HasFormat
(
video
.
mDefaultPt
)
)
{
VideoCodecConfig
:
:
Encoding
encoding
;
encoding
.
rid
=
jsepEncoding
.
mRid
;
config
-
>
mEncodings
.
push_back
(
encoding
)
;
}
}
aConfigs
-
>
push_back
(
std
:
:
move
(
*
config
)
)
;
}
}
}
void
RTCRtpTransceiver
:
:
Stop
(
ErrorResult
&
aRv
)
{
if
(
mPc
-
>
IsClosed
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Peer
connection
is
closed
"
)
;
return
;
}
if
(
mStopping
)
{
return
;
}
StopTransceiving
(
)
;
mPc
-
>
UpdateNegotiationNeeded
(
)
;
}
void
RTCRtpTransceiver
:
:
StopTransceiving
(
)
{
if
(
mStopping
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
mStopping
=
true
;
mSender
-
>
Stop
(
)
;
mReceiver
-
>
Stop
(
)
;
mDirection
=
RTCRtpTransceiverDirection
:
:
Inactive
;
}
void
RTCRtpTransceiver
:
:
StopImpl
(
)
{
if
(
!
mStopping
)
{
StopTransceiving
(
)
;
}
if
(
mCallWrapper
)
{
auto
conduit
=
std
:
:
move
(
mConduit
)
;
(
conduit
?
conduit
-
>
Shutdown
(
)
:
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
sender
=
mSender
receiver
=
mReceiver
]
(
)
mutable
{
sender
-
>
Shutdown
(
)
;
receiver
-
>
Shutdown
(
)
;
}
)
;
mCallWrapper
=
nullptr
;
}
mStopped
=
true
;
mCurrentDirection
.
SetNull
(
)
;
mSender
-
>
Stop
(
)
;
mReceiver
-
>
Stop
(
)
;
mHasTransport
=
false
;
auto
self
=
nsMainThreadPtrHandle
<
RTCRtpTransceiver
>
(
new
nsMainThreadPtrHolder
<
RTCRtpTransceiver
>
(
"
RTCRtpTransceiver
:
:
StopImpl
:
:
self
"
this
false
)
)
;
mStsThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
self
]
{
self
-
>
mTransportHandler
=
nullptr
;
}
)
)
;
}
bool
RTCRtpTransceiver
:
:
IsVideo
(
)
const
{
return
mIsVideo
;
}
bool
RTCRtpTransceiver
:
:
IsSending
(
)
const
{
return
mCurrentDirection
=
=
Nullable
(
RTCRtpTransceiverDirection
:
:
Sendonly
)
|
|
mCurrentDirection
=
=
Nullable
(
RTCRtpTransceiverDirection
:
:
Sendrecv
)
;
}
bool
RTCRtpTransceiver
:
:
IsReceiving
(
)
const
{
return
mCurrentDirection
=
=
Nullable
(
RTCRtpTransceiverDirection
:
:
Recvonly
)
|
|
mCurrentDirection
=
=
Nullable
(
RTCRtpTransceiverDirection
:
:
Sendrecv
)
;
}
void
RTCRtpTransceiver
:
:
ChainToDomPromiseWithCodecStats
(
nsTArray
<
RefPtr
<
RTCStatsPromise
>
>
aStats
const
RefPtr
<
dom
:
:
Promise
>
&
aDomPromise
)
{
nsTArray
<
RTCCodecStats
>
codecStats
=
mPc
-
>
GetCodecStats
(
mPc
-
>
GetTimestampMaker
(
)
.
GetNow
(
)
.
ToDom
(
)
)
;
AutoTArray
<
std
:
:
tuple
<
RTCRtpTransceiver
*
RefPtr
<
RTCStatsPromise
:
:
AllPromiseType
>
>
1
>
statsPromises
;
statsPromises
.
AppendElement
(
std
:
:
make_tuple
(
this
RTCStatsPromise
:
:
All
(
GetMainThreadSerialEventTarget
(
)
aStats
)
)
)
;
ApplyCodecStats
(
std
:
:
move
(
codecStats
)
std
:
:
move
(
statsPromises
)
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
aDomPromise
window
=
mWindow
idGen
=
mIdGenerator
]
(
UniquePtr
<
RTCStatsCollection
>
aStats
)
mutable
{
AutoTArray
<
UniquePtr
<
RTCStatsCollection
>
1
>
stats
;
stats
.
AppendElement
(
std
:
:
move
(
aStats
)
)
;
RTCStatsCollection
opaqueStats
;
idGen
-
>
RewriteIds
(
std
:
:
move
(
stats
)
&
opaqueStats
)
;
RefPtr
<
RTCStatsReport
>
report
(
new
RTCStatsReport
(
window
)
)
;
report
-
>
Incorporate
(
opaqueStats
)
;
aDomPromise
-
>
MaybeResolve
(
std
:
:
move
(
report
)
)
;
}
[
aDomPromise
]
(
nsresult
aError
)
{
aDomPromise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
}
)
;
}
RefPtr
<
RTCStatsPromise
>
RTCRtpTransceiver
:
:
ApplyCodecStats
(
nsTArray
<
RTCCodecStats
>
aCodecStats
nsTArray
<
std
:
:
tuple
<
RTCRtpTransceiver
*
RefPtr
<
RTCStatsPromise
:
:
AllPromiseType
>
>
>
aTransceiverStatsPromises
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
codecStats
=
MakeRefPtr
<
media
:
:
Refcountable
<
nsTArray
<
RTCCodecStats
>
>
>
(
)
;
*
codecStats
=
std
:
:
move
(
aCodecStats
)
;
struct
IdComparator
{
bool
operator
(
)
(
const
RTCCodecStats
&
aA
const
RTCCodecStats
&
aB
)
const
{
return
aA
.
mId
.
Value
(
)
<
aB
.
mId
.
Value
(
)
;
}
}
;
auto
finalCodecStats
=
MakeRefPtr
<
media
:
:
Refcountable
<
std
:
:
set
<
RTCCodecStats
IdComparator
>
>
>
(
)
;
nsTArray
<
RefPtr
<
RTCStatsPromise
>
>
promises
(
aTransceiverStatsPromises
.
Length
(
)
)
;
for
(
const
auto
&
[
transceiver
allPromise
]
:
aTransceiverStatsPromises
)
{
auto
payloadTypes
=
MakeRefPtr
<
media
:
:
Refcountable
<
RTCRtpTransceiver
:
:
PayloadTypes
>
>
(
)
;
promises
.
AppendElement
(
transceiver
-
>
GetActivePayloadTypes
(
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
payloadTypes
allPromise
=
allPromise
]
(
RTCRtpTransceiver
:
:
PayloadTypes
aPayloadTypes
)
{
*
payloadTypes
=
std
:
:
move
(
aPayloadTypes
)
;
return
allPromise
;
}
[
]
{
MOZ_CRASH
(
"
Unexpected
reject
"
)
;
return
RTCStatsPromise
:
:
AllPromiseType
:
:
CreateAndReject
(
NS_ERROR_UNEXPECTED
__func__
)
;
}
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
codecStats
finalCodecStats
payloadTypes
transportId
=
NS_ConvertASCIItoUTF16
(
transceiver
-
>
GetTransportId
(
)
)
]
(
nsTArray
<
UniquePtr
<
RTCStatsCollection
>
>
aTransceiverStats
)
mutable
{
auto
report
=
MakeUnique
<
RTCStatsCollection
>
(
)
;
FlattenStats
(
std
:
:
move
(
aTransceiverStats
)
report
.
get
(
)
)
;
Maybe
<
RTCCodecStats
&
>
sendCodec
;
Maybe
<
RTCCodecStats
&
>
recvCodec
;
for
(
auto
&
codec
:
*
codecStats
)
{
if
(
payloadTypes
-
>
mSendPayloadType
.
isSome
(
)
=
=
sendCodec
.
isSome
(
)
&
&
payloadTypes
-
>
mRecvPayloadType
.
isSome
(
)
=
=
recvCodec
.
isSome
(
)
)
{
break
;
}
if
(
codec
.
mTransportId
!
=
transportId
)
{
continue
;
}
if
(
payloadTypes
-
>
mSendPayloadType
&
&
*
payloadTypes
-
>
mSendPayloadType
=
=
static_cast
<
int
>
(
codec
.
mPayloadType
)
&
&
(
!
codec
.
mCodecType
.
WasPassed
(
)
|
|
codec
.
mCodecType
.
Value
(
)
=
=
RTCCodecType
:
:
Encode
)
)
{
MOZ_ASSERT
(
!
sendCodec
"
At
most
one
send
codec
stat
per
transceiver
"
)
;
sendCodec
=
SomeRef
(
codec
)
;
}
if
(
payloadTypes
-
>
mRecvPayloadType
&
&
*
payloadTypes
-
>
mRecvPayloadType
=
=
static_cast
<
int
>
(
codec
.
mPayloadType
)
&
&
(
!
codec
.
mCodecType
.
WasPassed
(
)
|
|
codec
.
mCodecType
.
Value
(
)
=
=
RTCCodecType
:
:
Decode
)
)
{
MOZ_ASSERT
(
!
recvCodec
"
At
most
one
recv
codec
stat
per
transceiver
"
)
;
recvCodec
=
SomeRef
(
codec
)
;
}
}
if
(
sendCodec
)
{
finalCodecStats
-
>
insert
(
*
sendCodec
)
;
for
(
auto
&
stat
:
report
-
>
mOutboundRtpStreamStats
)
{
stat
.
mCodecId
.
Construct
(
sendCodec
-
>
mId
.
Value
(
)
)
;
}
for
(
auto
&
stat
:
report
-
>
mRemoteInboundRtpStreamStats
)
{
stat
.
mCodecId
.
Construct
(
sendCodec
-
>
mId
.
Value
(
)
)
;
}
}
if
(
recvCodec
)
{
finalCodecStats
-
>
insert
(
*
recvCodec
)
;
for
(
auto
&
stat
:
report
-
>
mInboundRtpStreamStats
)
{
stat
.
mCodecId
.
Construct
(
recvCodec
-
>
mId
.
Value
(
)
)
;
}
for
(
auto
&
stat
:
report
-
>
mRemoteOutboundRtpStreamStats
)
{
stat
.
mCodecId
.
Construct
(
recvCodec
-
>
mId
.
Value
(
)
)
;
}
}
return
RTCStatsPromise
:
:
CreateAndResolve
(
std
:
:
move
(
report
)
__func__
)
;
}
[
]
{
MOZ_CRASH
(
"
Unexpected
reject
"
)
;
return
RTCStatsPromise
:
:
CreateAndReject
(
NS_ERROR_UNEXPECTED
__func__
)
;
}
)
)
;
}
return
RTCStatsPromise
:
:
All
(
GetMainThreadSerialEventTarget
(
)
promises
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
finalCodecStats
=
std
:
:
move
(
finalCodecStats
)
]
(
nsTArray
<
UniquePtr
<
RTCStatsCollection
>
>
aStats
)
mutable
{
auto
finalStats
=
MakeUnique
<
RTCStatsCollection
>
(
)
;
FlattenStats
(
std
:
:
move
(
aStats
)
finalStats
.
get
(
)
)
;
MOZ_ASSERT
(
finalStats
-
>
mCodecStats
.
IsEmpty
(
)
)
;
if
(
!
finalStats
-
>
mCodecStats
.
SetCapacity
(
finalCodecStats
-
>
size
(
)
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
while
(
!
finalCodecStats
-
>
empty
(
)
)
{
auto
node
=
finalCodecStats
-
>
extract
(
finalCodecStats
-
>
begin
(
)
)
;
if
(
!
finalStats
-
>
mCodecStats
.
AppendElement
(
std
:
:
move
(
node
.
value
(
)
)
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
return
RTCStatsPromise
:
:
CreateAndResolve
(
std
:
:
move
(
finalStats
)
__func__
)
;
}
[
]
{
MOZ_CRASH
(
"
Unexpected
reject
"
)
;
return
RTCStatsPromise
:
:
CreateAndReject
(
NS_ERROR_UNEXPECTED
__func__
)
;
}
)
;
}
}
