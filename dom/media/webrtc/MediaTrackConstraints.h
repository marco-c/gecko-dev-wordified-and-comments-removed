#
ifndef
MEDIATRACKCONSTRAINTS_H_
#
define
MEDIATRACKCONSTRAINTS_H_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamTrackBinding
.
h
"
#
include
"
mozilla
/
dom
/
MediaTrackConstraintSetBinding
.
h
"
#
include
"
mozilla
/
dom
/
MediaTrackSupportedConstraintsBinding
.
h
"
#
include
<
map
>
namespace
mozilla
{
template
<
class
EnumValuesStrings
class
Enum
>
static
const
char
*
EnumToASCII
(
const
EnumValuesStrings
&
aStrings
Enum
aValue
)
{
return
aStrings
[
uint32_t
(
aValue
)
]
.
value
;
}
template
<
class
EnumValuesStrings
class
Enum
>
static
Enum
StringToEnum
(
const
EnumValuesStrings
&
aStrings
const
nsAString
&
aValue
Enum
aDefaultValue
)
{
for
(
size_t
i
=
0
;
aStrings
[
i
]
.
value
;
i
+
+
)
{
if
(
aValue
.
EqualsASCII
(
aStrings
[
i
]
.
value
)
)
{
return
Enum
(
i
)
;
}
}
return
aDefaultValue
;
}
struct
NormalizedConstraintSet
{
template
<
class
ValueType
>
struct
Range
{
ValueType
mMin
mMax
;
dom
:
:
Optional
<
ValueType
>
mIdeal
;
Range
(
ValueType
aMin
ValueType
aMax
)
:
mMin
(
aMin
)
mMax
(
aMax
)
{
}
template
<
class
ConstrainRange
>
void
SetFrom
(
const
ConstrainRange
&
aOther
)
;
ValueType
Clamp
(
ValueType
n
)
const
{
return
std
:
:
max
(
mMin
std
:
:
min
(
n
mMax
)
)
;
}
bool
Intersects
(
const
Range
&
aOther
)
const
{
return
mMax
>
=
aOther
.
mMin
&
&
mMin
<
=
aOther
.
mMax
;
}
void
Intersect
(
const
Range
&
aOther
)
{
MOZ_ASSERT
(
Intersects
(
aOther
)
)
;
mMin
=
std
:
:
max
(
mMin
aOther
.
mMin
)
;
mMax
=
std
:
:
min
(
mMax
aOther
.
mMax
)
;
}
}
;
struct
LongRange
:
public
Range
<
int32_t
>
{
LongRange
(
const
dom
:
:
OwningLongOrConstrainLongRange
&
aOther
bool
advanced
)
;
}
;
struct
DoubleRange
:
public
Range
<
double
>
{
DoubleRange
(
const
dom
:
:
OwningDoubleOrConstrainDoubleRange
&
aOther
bool
advanced
)
;
}
;
LongRange
mWidth
mHeight
;
DoubleRange
mFrameRate
;
NormalizedConstraintSet
(
const
dom
:
:
MediaTrackConstraintSet
&
aOther
bool
advanced
)
:
mWidth
(
aOther
.
mWidth
advanced
)
mHeight
(
aOther
.
mHeight
advanced
)
mFrameRate
(
aOther
.
mFrameRate
advanced
)
{
}
}
;
struct
FlattenedConstraints
:
public
NormalizedConstraintSet
{
explicit
FlattenedConstraints
(
const
dom
:
:
MediaTrackConstraints
&
aOther
)
;
}
;
class
MediaConstraintsHelper
{
protected
:
template
<
class
ValueType
class
ConstrainRange
>
static
uint32_t
FitnessDistance
(
ValueType
aN
const
ConstrainRange
&
aRange
)
;
static
uint32_t
FitnessDistance
(
int32_t
aN
const
dom
:
:
OwningLongOrConstrainLongRange
&
aConstraint
bool
aAdvanced
)
;
static
uint32_t
FitnessDistance
(
double
aN
const
dom
:
:
OwningDoubleOrConstrainDoubleRange
&
aConstraint
bool
aAdvanced
)
;
static
uint32_t
FitnessDistance
(
nsString
aN
const
dom
:
:
OwningStringOrStringSequenceOrConstrainDOMStringParameters
&
aConstraint
bool
aAdvanced
)
;
static
uint32_t
FitnessDistance
(
nsString
aN
const
dom
:
:
ConstrainDOMStringParameters
&
aParams
)
;
static
uint32_t
GetMinimumFitnessDistance
(
const
dom
:
:
MediaTrackConstraintSet
&
aConstraints
bool
aAdvanced
const
nsString
&
aDeviceId
)
;
template
<
class
DeviceType
>
static
bool
AreUnfitSettings
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
nsTArray
<
nsRefPtr
<
DeviceType
>
>
&
aSources
)
{
nsTArray
<
const
dom
:
:
MediaTrackConstraintSet
*
>
aggregateConstraints
;
aggregateConstraints
.
AppendElement
(
&
aConstraints
)
;
for
(
auto
&
source
:
aSources
)
{
if
(
source
-
>
GetBestFitnessDistance
(
aggregateConstraints
)
!
=
UINT32_MAX
)
{
return
false
;
}
}
return
true
;
}
public
:
template
<
class
DeviceType
>
static
const
char
*
SelectSettings
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
nsTArray
<
nsRefPtr
<
DeviceType
>
>
&
aSources
)
{
auto
&
c
=
aConstraints
;
nsTArray
<
nsRefPtr
<
DeviceType
>
>
unsatisfactory
;
nsTArray
<
const
dom
:
:
MediaTrackConstraintSet
*
>
aggregateConstraints
;
aggregateConstraints
.
AppendElement
(
&
c
)
;
std
:
:
multimap
<
uint32_t
nsRefPtr
<
DeviceType
>
>
ordered
;
for
(
uint32_t
i
=
0
;
i
<
aSources
.
Length
(
)
;
)
{
uint32_t
distance
=
aSources
[
i
]
-
>
GetBestFitnessDistance
(
aggregateConstraints
)
;
if
(
distance
=
=
UINT32_MAX
)
{
unsatisfactory
.
AppendElement
(
aSources
[
i
]
)
;
aSources
.
RemoveElementAt
(
i
)
;
}
else
{
ordered
.
insert
(
std
:
:
pair
<
uint32_t
nsRefPtr
<
DeviceType
>
>
(
distance
aSources
[
i
]
)
)
;
+
+
i
;
}
}
if
(
!
aSources
.
Length
(
)
)
{
if
(
c
.
mDeviceId
.
IsConstrainDOMStringParameters
(
)
)
{
dom
:
:
MediaTrackConstraints
fresh
;
fresh
.
mDeviceId
=
c
.
mDeviceId
;
if
(
AreUnfitSettings
(
fresh
unsatisfactory
)
)
{
return
"
deviceId
"
;
}
}
if
(
c
.
mWidth
.
IsConstrainLongRange
(
)
)
{
dom
:
:
MediaTrackConstraints
fresh
;
fresh
.
mWidth
=
c
.
mWidth
;
if
(
AreUnfitSettings
(
fresh
unsatisfactory
)
)
{
return
"
width
"
;
}
}
if
(
c
.
mHeight
.
IsConstrainLongRange
(
)
)
{
dom
:
:
MediaTrackConstraints
fresh
;
fresh
.
mHeight
=
c
.
mHeight
;
if
(
AreUnfitSettings
(
fresh
unsatisfactory
)
)
{
return
"
height
"
;
}
}
if
(
c
.
mFrameRate
.
IsConstrainDoubleRange
(
)
)
{
dom
:
:
MediaTrackConstraints
fresh
;
fresh
.
mFrameRate
=
c
.
mFrameRate
;
if
(
AreUnfitSettings
(
fresh
unsatisfactory
)
)
{
return
"
frameRate
"
;
}
}
if
(
c
.
mFacingMode
.
IsConstrainDOMStringParameters
(
)
)
{
dom
:
:
MediaTrackConstraints
fresh
;
fresh
.
mFacingMode
=
c
.
mFacingMode
;
if
(
AreUnfitSettings
(
fresh
unsatisfactory
)
)
{
return
"
facingMode
"
;
}
}
return
"
"
;
}
for
(
auto
&
ordinal
:
ordered
)
{
aSources
.
RemoveElement
(
ordinal
.
second
)
;
aSources
.
AppendElement
(
ordinal
.
second
)
;
}
if
(
c
.
mAdvanced
.
WasPassed
(
)
)
{
auto
&
array
=
c
.
mAdvanced
.
Value
(
)
;
for
(
int
i
=
0
;
i
<
int
(
array
.
Length
(
)
)
;
i
+
+
)
{
aggregateConstraints
.
AppendElement
(
&
array
[
i
]
)
;
nsTArray
<
nsRefPtr
<
DeviceType
>
>
rejects
;
for
(
uint32_t
j
=
0
;
j
<
aSources
.
Length
(
)
;
)
{
if
(
aSources
[
j
]
-
>
GetBestFitnessDistance
(
aggregateConstraints
)
=
=
UINT32_MAX
)
{
rejects
.
AppendElement
(
aSources
[
j
]
)
;
aSources
.
RemoveElementAt
(
j
)
;
}
else
{
+
+
j
;
}
}
if
(
!
aSources
.
Length
(
)
)
{
aSources
.
AppendElements
(
Move
(
rejects
)
)
;
aggregateConstraints
.
RemoveElementAt
(
aggregateConstraints
.
Length
(
)
-
1
)
;
}
}
}
return
nullptr
;
}
}
;
}
#
endif
