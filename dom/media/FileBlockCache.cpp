#
include
"
FileBlockCache
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
prio
.
h
"
#
include
<
algorithm
>
#
include
"
nsAnonymousTemporaryFile
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
nsXULAppAPI
.
h
"
namespace
mozilla
{
LazyLogModule
gFileBlockCacheLog
(
"
FileBlockCache
"
)
;
#
define
FBC_LOG
(
type
msg
)
MOZ_LOG
(
gFileBlockCacheLog
type
msg
)
void
FileBlockCache
:
:
SetCacheFile
(
PRFileDesc
*
aFD
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
FBC_LOG
(
LogLevel
:
:
Debug
(
"
FileBlockCache
:
:
SetFD
(
aFD
=
%
p
)
mIsOpen
=
%
d
"
aFD
mIsOpen
)
)
;
if
(
!
aFD
)
{
Close
(
)
;
return
;
}
{
MonitorAutoLock
lock
(
mFileMonitor
)
;
mFD
=
aFD
;
}
{
MonitorAutoLock
lock
(
mDataMonitor
)
;
if
(
!
mIsOpen
)
{
return
;
}
mInitialized
=
true
;
if
(
mIsWriteScheduled
)
{
mThread
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
}
}
}
nsresult
FileBlockCache
:
:
Init
(
)
{
FBC_LOG
(
LogLevel
:
:
Debug
(
"
FileBlockCache
:
:
Init
(
)
"
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MonitorAutoLock
mon
(
mDataMonitor
)
;
nsresult
rv
=
NS_NewNamedThread
(
"
FileBlockCache
"
getter_AddRefs
(
mThread
)
nullptr
SharedThreadPool
:
:
kStackSize
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mIsOpen
=
true
;
if
(
XRE_IsParentProcess
(
)
)
{
rv
=
NS_OpenAnonymousTemporaryFile
(
&
mFD
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mInitialized
=
true
;
}
}
else
{
RefPtr
<
FileBlockCache
>
self
=
this
;
rv
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
AsyncOpenAnonymousTemporaryFile
(
[
self
]
(
PRFileDesc
*
aFD
)
{
self
-
>
SetCacheFile
(
aFD
)
;
}
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
Close
(
)
;
}
return
rv
;
}
FileBlockCache
:
:
FileBlockCache
(
)
:
mFileMonitor
(
"
MediaCache
.
Writer
.
IO
.
Monitor
"
)
mFD
(
nullptr
)
mFDCurrentPos
(
0
)
mDataMonitor
(
"
MediaCache
.
Writer
.
Data
.
Monitor
"
)
mIsWriteScheduled
(
false
)
mIsOpen
(
false
)
{
}
FileBlockCache
:
:
~
FileBlockCache
(
)
{
NS_ASSERTION
(
!
mIsOpen
"
Should
Close
(
)
FileBlockCache
before
destroying
"
)
;
{
MonitorAutoLock
mon
(
mFileMonitor
)
;
if
(
mFD
)
{
PRStatus
prrc
;
prrc
=
PR_Close
(
mFD
)
;
if
(
prrc
!
=
PR_SUCCESS
)
{
NS_WARNING
(
"
PR_Close
(
)
failed
.
"
)
;
}
mFD
=
nullptr
;
}
}
}
void
FileBlockCache
:
:
Close
(
)
{
FBC_LOG
(
LogLevel
:
:
Debug
(
"
FileBlockCache
:
:
Close
"
)
)
;
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
MonitorAutoLock
mon
(
mDataMonitor
)
;
if
(
!
mIsOpen
)
{
return
;
}
mIsOpen
=
false
;
if
(
!
mThread
)
{
return
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
ShutdownThreadEvent
(
mThread
)
;
SystemGroup
:
:
Dispatch
(
"
ShutdownThreadEvent
"
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
mThread
=
nullptr
;
}
template
<
typename
Container
typename
Value
>
bool
ContainerContains
(
const
Container
&
aContainer
const
Value
&
value
)
{
return
std
:
:
find
(
aContainer
.
begin
(
)
aContainer
.
end
(
)
value
)
!
=
aContainer
.
end
(
)
;
}
nsresult
FileBlockCache
:
:
WriteBlock
(
uint32_t
aBlockIndex
const
uint8_t
*
aData
)
{
MonitorAutoLock
mon
(
mDataMonitor
)
;
if
(
!
mIsOpen
)
return
NS_ERROR_FAILURE
;
mBlockChanges
.
EnsureLengthAtLeast
(
aBlockIndex
+
1
)
;
bool
blockAlreadyHadPendingChange
=
mBlockChanges
[
aBlockIndex
]
!
=
nullptr
;
mBlockChanges
[
aBlockIndex
]
=
new
BlockChange
(
aData
)
;
if
(
!
blockAlreadyHadPendingChange
|
|
!
ContainerContains
(
mChangeIndexList
aBlockIndex
)
)
{
mChangeIndexList
.
push_back
(
aBlockIndex
)
;
}
NS_ASSERTION
(
ContainerContains
(
mChangeIndexList
aBlockIndex
)
"
Must
have
entry
for
new
block
"
)
;
EnsureWriteScheduled
(
)
;
return
NS_OK
;
}
void
FileBlockCache
:
:
EnsureWriteScheduled
(
)
{
mDataMonitor
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
mIsOpen
)
;
if
(
mIsWriteScheduled
)
{
return
;
}
mIsWriteScheduled
=
true
;
if
(
!
mInitialized
)
{
return
;
}
mThread
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
}
nsresult
FileBlockCache
:
:
Seek
(
int64_t
aOffset
)
{
mFileMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
mFDCurrentPos
!
=
aOffset
)
{
MOZ_ASSERT
(
mFD
)
;
int64_t
result
=
PR_Seek64
(
mFD
aOffset
PR_SEEK_SET
)
;
if
(
result
!
=
aOffset
)
{
NS_WARNING
(
"
Failed
to
seek
media
cache
file
"
)
;
return
NS_ERROR_FAILURE
;
}
mFDCurrentPos
=
result
;
}
return
NS_OK
;
}
nsresult
FileBlockCache
:
:
ReadFromFile
(
int64_t
aOffset
uint8_t
*
aDest
int32_t
aBytesToRead
int32_t
&
aBytesRead
)
{
FBC_LOG
(
LogLevel
:
:
Debug
(
"
FileBlockCache
:
:
ReadFromFile
(
offset
=
%
"
PRIu64
"
len
=
%
u
)
"
aOffset
aBytesToRead
)
)
;
mFileMonitor
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
mFD
)
;
nsresult
res
=
Seek
(
aOffset
)
;
if
(
NS_FAILED
(
res
)
)
return
res
;
aBytesRead
=
PR_Read
(
mFD
aDest
aBytesToRead
)
;
if
(
aBytesRead
<
=
0
)
return
NS_ERROR_FAILURE
;
mFDCurrentPos
+
=
aBytesRead
;
return
NS_OK
;
}
nsresult
FileBlockCache
:
:
WriteBlockToFile
(
int32_t
aBlockIndex
const
uint8_t
*
aBlockData
)
{
FBC_LOG
(
LogLevel
:
:
Debug
(
"
FileBlockCache
:
:
WriteBlockToFile
(
index
=
%
u
)
"
aBlockIndex
)
)
;
mFileMonitor
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
mFD
)
;
nsresult
rv
=
Seek
(
BlockIndexToOffset
(
aBlockIndex
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
int32_t
amount
=
PR_Write
(
mFD
aBlockData
BLOCK_SIZE
)
;
if
(
amount
<
BLOCK_SIZE
)
{
NS_WARNING
(
"
Failed
to
write
media
cache
block
!
"
)
;
return
NS_ERROR_FAILURE
;
}
mFDCurrentPos
+
=
BLOCK_SIZE
;
return
NS_OK
;
}
nsresult
FileBlockCache
:
:
MoveBlockInFile
(
int32_t
aSourceBlockIndex
int32_t
aDestBlockIndex
)
{
FBC_LOG
(
LogLevel
:
:
Debug
(
"
FileBlockCache
:
:
MoveBlockInFile
(
src
=
%
u
dest
=
%
u
)
"
aSourceBlockIndex
aDestBlockIndex
)
)
;
mFileMonitor
.
AssertCurrentThreadOwns
(
)
;
uint8_t
buf
[
BLOCK_SIZE
]
;
int32_t
bytesRead
=
0
;
if
(
NS_FAILED
(
ReadFromFile
(
BlockIndexToOffset
(
aSourceBlockIndex
)
buf
BLOCK_SIZE
bytesRead
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
WriteBlockToFile
(
aDestBlockIndex
buf
)
;
}
nsresult
FileBlockCache
:
:
Run
(
)
{
NS_ASSERTION
(
!
NS_IsMainThread
(
)
"
Don
'
t
call
on
main
thread
"
)
;
MonitorAutoLock
mon
(
mDataMonitor
)
;
NS_ASSERTION
(
!
mChangeIndexList
.
empty
(
)
"
Only
dispatch
when
there
'
s
work
to
do
"
)
;
NS_ASSERTION
(
mIsWriteScheduled
"
Should
report
write
running
or
scheduled
.
"
)
;
MOZ_ASSERT
(
mFD
)
;
FBC_LOG
(
LogLevel
:
:
Debug
(
"
FileBlockCache
:
:
Run
mFD
=
%
p
mIsOpen
=
%
d
"
mFD
mIsOpen
)
)
;
while
(
!
mChangeIndexList
.
empty
(
)
)
{
if
(
!
mIsOpen
)
{
mIsWriteScheduled
=
false
;
return
NS_ERROR_FAILURE
;
}
int32_t
blockIndex
=
mChangeIndexList
.
front
(
)
;
mChangeIndexList
.
pop_front
(
)
;
RefPtr
<
BlockChange
>
change
=
mBlockChanges
[
blockIndex
]
;
MOZ_ASSERT
(
change
"
Change
index
list
should
only
contain
entries
for
blocks
"
"
with
changes
"
)
;
{
MonitorAutoUnlock
unlock
(
mDataMonitor
)
;
MonitorAutoLock
lock
(
mFileMonitor
)
;
if
(
change
-
>
IsWrite
(
)
)
{
WriteBlockToFile
(
blockIndex
change
-
>
mData
.
get
(
)
)
;
}
else
if
(
change
-
>
IsMove
(
)
)
{
MoveBlockInFile
(
change
-
>
mSourceBlockIndex
blockIndex
)
;
}
}
if
(
mBlockChanges
[
blockIndex
]
=
=
change
)
{
mBlockChanges
[
blockIndex
]
=
nullptr
;
}
}
mIsWriteScheduled
=
false
;
return
NS_OK
;
}
nsresult
FileBlockCache
:
:
Read
(
int64_t
aOffset
uint8_t
*
aData
int32_t
aLength
int32_t
*
aBytes
)
{
MonitorAutoLock
mon
(
mDataMonitor
)
;
if
(
!
mIsOpen
|
|
(
aOffset
/
BLOCK_SIZE
)
>
INT32_MAX
)
return
NS_ERROR_FAILURE
;
int32_t
bytesToRead
=
aLength
;
int64_t
offset
=
aOffset
;
uint8_t
*
dst
=
aData
;
while
(
bytesToRead
>
0
)
{
int32_t
blockIndex
=
static_cast
<
int32_t
>
(
offset
/
BLOCK_SIZE
)
;
int32_t
start
=
offset
%
BLOCK_SIZE
;
int32_t
amount
=
std
:
:
min
(
BLOCK_SIZE
-
start
bytesToRead
)
;
int32_t
bytesRead
=
0
;
RefPtr
<
BlockChange
>
change
=
mBlockChanges
[
blockIndex
]
;
if
(
change
&
&
change
-
>
IsWrite
(
)
)
{
const
uint8_t
*
blockData
=
change
-
>
mData
.
get
(
)
;
memcpy
(
dst
blockData
+
start
amount
)
;
bytesRead
=
amount
;
}
else
{
if
(
change
&
&
change
-
>
IsMove
(
)
)
{
blockIndex
=
mBlockChanges
[
blockIndex
]
-
>
mSourceBlockIndex
;
}
nsresult
res
;
{
MonitorAutoUnlock
unlock
(
mDataMonitor
)
;
MonitorAutoLock
lock
(
mFileMonitor
)
;
res
=
ReadFromFile
(
BlockIndexToOffset
(
blockIndex
)
+
start
dst
amount
bytesRead
)
;
}
NS_ENSURE_SUCCESS
(
res
res
)
;
}
dst
+
=
bytesRead
;
offset
+
=
bytesRead
;
bytesToRead
-
=
bytesRead
;
}
*
aBytes
=
aLength
-
bytesToRead
;
return
NS_OK
;
}
nsresult
FileBlockCache
:
:
MoveBlock
(
int32_t
aSourceBlockIndex
int32_t
aDestBlockIndex
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
MonitorAutoLock
mon
(
mDataMonitor
)
;
if
(
!
mIsOpen
)
return
NS_ERROR_FAILURE
;
mBlockChanges
.
EnsureLengthAtLeast
(
std
:
:
max
(
aSourceBlockIndex
aDestBlockIndex
)
+
1
)
;
int32_t
sourceIndex
=
aSourceBlockIndex
;
BlockChange
*
sourceBlock
=
nullptr
;
while
(
(
sourceBlock
=
mBlockChanges
[
sourceIndex
]
)
&
&
sourceBlock
-
>
IsMove
(
)
)
{
sourceIndex
=
sourceBlock
-
>
mSourceBlockIndex
;
}
if
(
mBlockChanges
[
aDestBlockIndex
]
=
=
nullptr
|
|
!
ContainerContains
(
mChangeIndexList
aDestBlockIndex
)
)
{
mChangeIndexList
.
push_back
(
aDestBlockIndex
)
;
}
if
(
sourceBlock
&
&
sourceBlock
-
>
IsWrite
(
)
)
{
mBlockChanges
[
aDestBlockIndex
]
=
new
BlockChange
(
sourceBlock
-
>
mData
.
get
(
)
)
;
}
else
{
mBlockChanges
[
aDestBlockIndex
]
=
new
BlockChange
(
sourceIndex
)
;
}
EnsureWriteScheduled
(
)
;
NS_ASSERTION
(
ContainerContains
(
mChangeIndexList
aDestBlockIndex
)
"
Should
have
scheduled
block
for
change
"
)
;
return
NS_OK
;
}
}
