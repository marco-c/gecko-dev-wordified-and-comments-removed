#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
VideoSegment
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
prerror
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
ForwardedInputTrack
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
AudioCaptureTrack
.
h
"
#
include
"
AudioNodeTrack
.
h
"
#
include
"
AudioNodeExternalInputTrack
.
h
"
#
include
"
MediaTrackListener
.
h
"
#
include
"
mozilla
/
dom
/
BaseAudioContextBinding
.
h
"
#
include
"
mozilla
/
media
/
MediaUtils
.
h
"
#
include
<
algorithm
>
#
include
"
GeckoProfiler
.
h
"
#
include
"
VideoFrameContainer
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mtransport
/
runnable_utils
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
GraphRunner
.
h
"
#
include
"
Tracing
.
h
"
#
include
"
UnderrunHandler
.
h
"
#
include
"
webaudio
/
blink
/
DenormalDisabler
.
h
"
#
include
"
webaudio
/
blink
/
HRTFDatabaseLoader
.
h
"
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
media
;
namespace
mozilla
{
LazyLogModule
gMediaTrackGraphLog
(
"
MediaTrackGraph
"
)
;
#
ifdef
LOG
#
undef
LOG
#
endif
#
define
LOG
(
type
msg
)
MOZ_LOG
(
gMediaTrackGraphLog
type
msg
)
static
nsDataHashtable
<
nsUint32HashKey
MediaTrackGraphImpl
*
>
gGraphs
;
MediaTrackGraphImpl
:
:
~
MediaTrackGraphImpl
(
)
{
MOZ_ASSERT
(
mTracks
.
IsEmpty
(
)
&
&
mSuspendedTracks
.
IsEmpty
(
)
"
All
tracks
should
have
been
destroyed
by
messages
from
the
main
"
"
thread
"
)
;
LOG
(
LogLevel
:
:
Debug
(
"
MediaTrackGraph
%
p
destroyed
"
this
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
MediaTrackGraphImpl
:
:
~
MediaTrackGraphImpl
"
)
)
;
}
void
MediaTrackGraphImpl
:
:
AddTrackGraphThread
(
MediaTrack
*
aTrack
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
aTrack
-
>
mStartTime
=
mProcessedTime
;
if
(
aTrack
-
>
IsSuspended
(
)
)
{
mSuspendedTracks
.
AppendElement
(
aTrack
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
Adding
media
track
%
p
in
the
suspended
track
array
"
this
aTrack
)
)
;
}
else
{
mTracks
.
AppendElement
(
aTrack
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
Adding
media
track
%
p
count
%
zu
"
this
aTrack
mTracks
.
Length
(
)
)
)
;
}
SetTrackOrderDirty
(
)
;
}
void
MediaTrackGraphImpl
:
:
RemoveTrackGraphThread
(
MediaTrack
*
aTrack
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
for
(
uint32_t
i
=
0
;
i
<
mTrackUpdates
.
Length
(
)
;
+
+
i
)
{
if
(
mTrackUpdates
[
i
]
.
mTrack
=
=
aTrack
)
{
mTrackUpdates
[
i
]
.
mTrack
=
nullptr
;
}
}
}
SetTrackOrderDirty
(
)
;
UnregisterAllAudioOutputs
(
aTrack
)
;
if
(
aTrack
-
>
IsSuspended
(
)
)
{
mSuspendedTracks
.
RemoveElement
(
aTrack
)
;
}
else
{
mTracks
.
RemoveElement
(
aTrack
)
;
}
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
Removed
media
track
%
p
count
%
zu
"
this
aTrack
mTracks
.
Length
(
)
)
)
;
NS_RELEASE
(
aTrack
)
;
}
TrackTime
MediaTrackGraphImpl
:
:
GraphTimeToTrackTimeWithBlocking
(
const
MediaTrack
*
aTrack
GraphTime
aTime
)
const
{
MOZ_ASSERT
(
aTime
<
=
mStateComputedTime
"
Don
'
t
ask
about
times
where
we
haven
'
t
made
blocking
decisions
yet
"
)
;
return
std
:
:
max
<
TrackTime
>
(
0
std
:
:
min
(
aTime
aTrack
-
>
mStartBlocking
)
-
aTrack
-
>
mStartTime
)
;
}
GraphTime
MediaTrackGraphImpl
:
:
IterationEnd
(
)
const
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
return
CurrentDriver
(
)
-
>
IterationEnd
(
)
;
}
void
MediaTrackGraphImpl
:
:
UpdateCurrentTimeForTracks
(
GraphTime
aPrevCurrentTime
)
{
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
for
(
MediaTrack
*
track
:
AllTracks
(
)
)
{
MOZ_ASSERT_IF
(
track
-
>
mStartBlocking
>
aPrevCurrentTime
!
track
-
>
mNotifiedEnded
)
;
GraphTime
blockedTime
=
mStateComputedTime
-
track
-
>
mStartBlocking
;
NS_ASSERTION
(
blockedTime
>
=
0
"
Error
in
blocking
time
"
)
;
track
-
>
AdvanceTimeVaryingValuesToCurrentTime
(
mStateComputedTime
blockedTime
)
;
LOG
(
LogLevel
:
:
Verbose
(
"
%
p
:
MediaTrack
%
p
bufferStartTime
=
%
f
blockedTime
=
%
f
"
this
track
MediaTimeToSeconds
(
track
-
>
mStartTime
)
MediaTimeToSeconds
(
blockedTime
)
)
)
;
track
-
>
mStartBlocking
=
mStateComputedTime
;
TrackTime
trackCurrentTime
=
track
-
>
GraphTimeToTrackTime
(
mStateComputedTime
)
;
if
(
track
-
>
mEnded
)
{
MOZ_ASSERT
(
track
-
>
GetEnd
(
)
<
=
trackCurrentTime
)
;
if
(
!
track
-
>
mNotifiedEnded
)
{
track
-
>
mNotifiedEnded
=
true
;
SetTrackOrderDirty
(
)
;
for
(
const
auto
&
listener
:
track
-
>
mTrackListeners
)
{
listener
-
>
NotifyOutput
(
this
track
-
>
GetEnd
(
)
)
;
listener
-
>
NotifyEnded
(
this
)
;
}
}
}
else
{
for
(
const
auto
&
listener
:
track
-
>
mTrackListeners
)
{
listener
-
>
NotifyOutput
(
this
trackCurrentTime
)
;
}
}
}
}
template
<
typename
C
typename
Chunk
>
void
MediaTrackGraphImpl
:
:
ProcessChunkMetadataForInterval
(
MediaTrack
*
aTrack
C
&
aSegment
TrackTime
aStart
TrackTime
aEnd
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
MOZ_ASSERT
(
aTrack
)
;
TrackTime
offset
=
0
;
for
(
typename
C
:
:
ConstChunkIterator
chunk
(
aSegment
)
;
!
chunk
.
IsEnded
(
)
;
chunk
.
Next
(
)
)
{
if
(
offset
>
=
aEnd
)
{
break
;
}
offset
+
=
chunk
-
>
GetDuration
(
)
;
if
(
chunk
-
>
IsNull
(
)
|
|
offset
<
aStart
)
{
continue
;
}
const
PrincipalHandle
&
principalHandle
=
chunk
-
>
GetPrincipalHandle
(
)
;
if
(
principalHandle
!
=
aSegment
.
GetLastPrincipalHandle
(
)
)
{
aSegment
.
SetLastPrincipalHandle
(
principalHandle
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
MediaTrack
%
p
principalHandle
"
"
changed
in
%
sChunk
with
duration
%
lld
"
this
aTrack
aSegment
.
GetType
(
)
=
=
MediaSegment
:
:
AUDIO
?
"
Audio
"
:
"
Video
"
(
long
long
)
chunk
-
>
GetDuration
(
)
)
)
;
for
(
const
auto
&
listener
:
aTrack
-
>
mTrackListeners
)
{
listener
-
>
NotifyPrincipalHandleChanged
(
this
principalHandle
)
;
}
}
}
}
void
MediaTrackGraphImpl
:
:
ProcessChunkMetadata
(
GraphTime
aPrevCurrentTime
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
for
(
MediaTrack
*
track
:
AllTracks
(
)
)
{
TrackTime
iterationStart
=
track
-
>
GraphTimeToTrackTime
(
aPrevCurrentTime
)
;
TrackTime
iterationEnd
=
track
-
>
GraphTimeToTrackTime
(
mProcessedTime
)
;
if
(
!
track
-
>
mSegment
)
{
continue
;
}
if
(
track
-
>
mType
=
=
MediaSegment
:
:
AUDIO
)
{
ProcessChunkMetadataForInterval
<
AudioSegment
AudioChunk
>
(
track
*
track
-
>
GetData
<
AudioSegment
>
(
)
iterationStart
iterationEnd
)
;
}
else
if
(
track
-
>
mType
=
=
MediaSegment
:
:
VIDEO
)
{
ProcessChunkMetadataForInterval
<
VideoSegment
VideoChunk
>
(
track
*
track
-
>
GetData
<
VideoSegment
>
(
)
iterationStart
iterationEnd
)
;
}
else
{
MOZ_CRASH
(
"
Unknown
track
type
"
)
;
}
}
}
GraphTime
MediaTrackGraphImpl
:
:
WillUnderrun
(
MediaTrack
*
aTrack
GraphTime
aEndBlockingDecisions
)
{
if
(
aTrack
-
>
mEnded
|
|
aTrack
-
>
AsProcessedTrack
(
)
)
{
return
aEndBlockingDecisions
;
}
GraphTime
bufferEnd
=
aTrack
-
>
GetEnd
(
)
+
aTrack
-
>
mStartTime
;
#
ifdef
DEBUG
if
(
bufferEnd
<
mProcessedTime
)
{
LOG
(
LogLevel
:
:
Error
(
"
%
p
:
MediaTrack
%
p
underrun
"
"
bufferEnd
%
f
<
mProcessedTime
%
f
(
%
"
PRId64
"
<
%
"
PRId64
"
)
TrackTime
%
"
PRId64
this
aTrack
MediaTimeToSeconds
(
bufferEnd
)
MediaTimeToSeconds
(
mProcessedTime
)
bufferEnd
mProcessedTime
aTrack
-
>
GetEnd
(
)
)
)
;
NS_ASSERTION
(
bufferEnd
>
=
mProcessedTime
"
Buffer
underran
"
)
;
}
#
endif
return
std
:
:
min
(
bufferEnd
aEndBlockingDecisions
)
;
}
namespace
{
const
uint32_t
NOT_VISITED
=
UINT32_MAX
;
const
uint32_t
IN_MUTED_CYCLE
=
1
;
}
bool
MediaTrackGraphImpl
:
:
AudioTrackPresent
(
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
bool
audioTrackPresent
=
false
;
for
(
MediaTrack
*
track
:
mTracks
)
{
if
(
track
-
>
AsAudioNodeTrack
(
)
)
{
audioTrackPresent
=
true
;
break
;
}
if
(
track
-
>
mType
=
=
MediaSegment
:
:
AUDIO
&
&
!
track
-
>
mNotifiedEnded
)
{
audioTrackPresent
=
true
;
break
;
}
}
if
(
!
audioTrackPresent
&
&
mInputDeviceUsers
.
Count
(
)
!
=
0
)
{
NS_WARNING
(
"
No
audio
tracks
but
full
-
duplex
audio
is
enabled
!
!
!
!
!
"
)
;
audioTrackPresent
=
true
;
}
return
audioTrackPresent
;
}
void
MediaTrackGraphImpl
:
:
UpdateTrackOrder
(
)
{
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
bool
audioTrackPresent
=
AudioTrackPresent
(
)
;
uint32_t
graphOutputChannelCount
=
AudioOutputChannelCount
(
)
;
if
(
!
audioTrackPresent
&
&
mRealtime
&
&
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
if
(
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
-
>
IsStarted
(
)
&
&
!
(
CurrentDriver
(
)
-
>
Switching
(
)
)
)
{
if
(
LifecycleStateRef
(
)
=
=
LIFECYCLE_RUNNING
)
{
SystemClockDriver
*
driver
=
new
SystemClockDriver
(
this
)
;
CurrentDriver
(
)
-
>
SwitchAtNextIteration
(
driver
)
;
}
}
}
bool
switching
=
false
;
{
MonitorAutoLock
mon
(
mMonitor
)
;
switching
=
CurrentDriver
(
)
-
>
Switching
(
)
;
}
if
(
audioTrackPresent
&
&
mRealtime
&
&
!
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
&
&
!
switching
&
&
graphOutputChannelCount
>
0
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
if
(
LifecycleStateRef
(
)
=
=
LIFECYCLE_RUNNING
)
{
AudioCallbackDriver
*
driver
=
new
AudioCallbackDriver
(
this
graphOutputChannelCount
AudioInputChannelCount
(
)
AudioInputDevicePreference
(
)
)
;
CurrentDriver
(
)
-
>
SwitchAtNextIteration
(
driver
)
;
}
}
if
(
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
&
&
!
switching
)
{
if
(
graphOutputChannelCount
!
=
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
-
>
OutputChannelCount
(
)
)
{
AudioCallbackDriver
*
driver
=
new
AudioCallbackDriver
(
this
graphOutputChannelCount
AudioInputChannelCount
(
)
AudioInputDevicePreference
(
)
)
;
MonitorAutoLock
mon
(
mMonitor
)
;
CurrentDriver
(
)
-
>
SwitchAtNextIteration
(
driver
)
;
}
}
if
(
!
mTrackOrderDirty
)
{
return
;
}
mTrackOrderDirty
=
false
;
mozilla
:
:
LinkedList
<
MediaTrack
>
dfsStack
;
mozilla
:
:
LinkedList
<
MediaTrack
>
sccStack
;
uint32_t
orderedTrackCount
=
0
;
for
(
uint32_t
i
=
0
;
i
<
mTracks
.
Length
(
)
;
+
+
i
)
{
MediaTrack
*
t
=
mTracks
[
i
]
;
ProcessedMediaTrack
*
pt
=
t
-
>
AsProcessedTrack
(
)
;
if
(
pt
)
{
dfsStack
.
insertBack
(
t
)
;
pt
-
>
mCycleMarker
=
NOT_VISITED
;
}
else
{
mTracks
[
orderedTrackCount
]
=
t
;
+
+
orderedTrackCount
;
}
}
uint32_t
nextStackMarker
=
NOT_VISITED
-
1
;
mFirstCycleBreaker
=
mTracks
.
Length
(
)
;
while
(
auto
pt
=
static_cast
<
ProcessedMediaTrack
*
>
(
dfsStack
.
getFirst
(
)
)
)
{
const
auto
&
inputs
=
pt
-
>
mInputs
;
MOZ_ASSERT
(
pt
-
>
AsProcessedTrack
(
)
)
;
if
(
pt
-
>
mCycleMarker
=
=
NOT_VISITED
)
{
pt
-
>
mCycleMarker
=
nextStackMarker
;
-
-
nextStackMarker
;
for
(
uint32_t
i
=
inputs
.
Length
(
)
;
i
-
-
;
)
{
if
(
inputs
[
i
]
-
>
mSource
-
>
IsSuspended
(
)
)
{
continue
;
}
auto
input
=
inputs
[
i
]
-
>
mSource
-
>
AsProcessedTrack
(
)
;
if
(
input
&
&
input
-
>
mCycleMarker
=
=
NOT_VISITED
)
{
if
(
input
-
>
isInList
(
)
)
{
input
-
>
remove
(
)
;
dfsStack
.
insertFront
(
input
)
;
}
}
}
continue
;
}
pt
-
>
remove
(
)
;
uint32_t
cycleStackMarker
=
0
;
for
(
uint32_t
i
=
inputs
.
Length
(
)
;
i
-
-
;
)
{
if
(
inputs
[
i
]
-
>
mSource
-
>
IsSuspended
(
)
)
{
continue
;
}
auto
input
=
inputs
[
i
]
-
>
mSource
-
>
AsProcessedTrack
(
)
;
if
(
input
)
{
cycleStackMarker
=
std
:
:
max
(
cycleStackMarker
input
-
>
mCycleMarker
)
;
}
}
if
(
cycleStackMarker
<
=
IN_MUTED_CYCLE
)
{
pt
-
>
mCycleMarker
=
0
;
mTracks
[
orderedTrackCount
]
=
pt
;
+
+
orderedTrackCount
;
continue
;
}
sccStack
.
insertFront
(
pt
)
;
if
(
cycleStackMarker
>
pt
-
>
mCycleMarker
)
{
pt
-
>
mCycleMarker
=
cycleStackMarker
;
continue
;
}
MOZ_ASSERT
(
cycleStackMarker
=
=
pt
-
>
mCycleMarker
)
;
bool
haveDelayNode
=
false
;
auto
next
=
sccStack
.
getFirst
(
)
;
while
(
next
&
&
static_cast
<
ProcessedMediaTrack
*
>
(
next
)
-
>
mCycleMarker
<
=
cycleStackMarker
)
{
auto
nt
=
next
-
>
AsAudioNodeTrack
(
)
;
next
=
next
-
>
getNext
(
)
;
if
(
nt
&
&
nt
-
>
Engine
(
)
-
>
AsDelayNodeEngine
(
)
)
{
haveDelayNode
=
true
;
nt
-
>
remove
(
)
;
nt
-
>
mCycleMarker
=
0
;
-
-
mFirstCycleBreaker
;
mTracks
[
mFirstCycleBreaker
]
=
nt
;
}
}
auto
after_scc
=
next
;
while
(
(
next
=
sccStack
.
getFirst
(
)
)
!
=
after_scc
)
{
next
-
>
remove
(
)
;
auto
removed
=
static_cast
<
ProcessedMediaTrack
*
>
(
next
)
;
if
(
haveDelayNode
)
{
removed
-
>
mCycleMarker
=
NOT_VISITED
;
dfsStack
.
insertFront
(
removed
)
;
}
else
{
removed
-
>
mCycleMarker
=
IN_MUTED_CYCLE
;
mTracks
[
orderedTrackCount
]
=
removed
;
+
+
orderedTrackCount
;
}
}
}
MOZ_ASSERT
(
orderedTrackCount
=
=
mFirstCycleBreaker
)
;
}
TrackTime
MediaTrackGraphImpl
:
:
PlayAudio
(
const
TrackKeyAndVolume
&
aTkv
GraphTime
aPlayedTime
)
{
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
MOZ_ASSERT
(
mRealtime
"
Should
only
attempt
to
play
audio
in
realtime
mode
"
)
;
TrackTime
ticksWritten
=
0
;
ticksWritten
=
0
;
MediaTrack
*
track
=
aTkv
.
mTrack
;
AudioSegment
*
audio
=
track
-
>
GetData
<
AudioSegment
>
(
)
;
AudioSegment
output
;
TrackTime
offset
=
track
-
>
GraphTimeToTrackTime
(
aPlayedTime
)
;
GraphTime
t
=
aPlayedTime
;
while
(
t
<
mStateComputedTime
)
{
bool
blocked
=
t
>
=
track
-
>
mStartBlocking
;
GraphTime
end
=
blocked
?
mStateComputedTime
:
track
-
>
mStartBlocking
;
NS_ASSERTION
(
end
<
=
mStateComputedTime
"
mStartBlocking
is
wrong
!
"
)
;
TrackTime
toWrite
=
end
-
t
;
if
(
blocked
)
{
output
.
InsertNullDataAtStart
(
toWrite
)
;
ticksWritten
+
=
toWrite
;
LOG
(
LogLevel
:
:
Verbose
(
"
%
p
:
MediaTrack
%
p
writing
%
"
PRId64
"
blocking
-
silence
samples
for
"
"
%
f
to
%
f
(
%
"
PRId64
"
to
%
"
PRId64
"
)
"
this
track
toWrite
MediaTimeToSeconds
(
t
)
MediaTimeToSeconds
(
end
)
offset
offset
+
toWrite
)
)
;
}
else
{
TrackTime
endTicksNeeded
=
offset
+
toWrite
;
TrackTime
endTicksAvailable
=
audio
-
>
GetDuration
(
)
;
if
(
endTicksNeeded
<
=
endTicksAvailable
)
{
LOG
(
LogLevel
:
:
Verbose
(
"
%
p
:
MediaTrack
%
p
writing
%
"
PRId64
"
samples
for
%
f
to
%
f
"
"
(
samples
%
"
PRId64
"
to
%
"
PRId64
"
)
"
this
track
toWrite
MediaTimeToSeconds
(
t
)
MediaTimeToSeconds
(
end
)
offset
endTicksNeeded
)
)
;
output
.
AppendSlice
(
*
audio
offset
endTicksNeeded
)
;
ticksWritten
+
=
toWrite
;
offset
=
endTicksNeeded
;
}
else
{
if
(
endTicksNeeded
>
endTicksAvailable
&
&
offset
<
endTicksAvailable
)
{
output
.
AppendSlice
(
*
audio
offset
endTicksAvailable
)
;
LOG
(
LogLevel
:
:
Verbose
(
"
%
p
:
MediaTrack
%
p
writing
%
"
PRId64
"
samples
for
%
f
to
%
f
"
"
(
samples
%
"
PRId64
"
to
%
"
PRId64
"
)
"
this
track
toWrite
MediaTimeToSeconds
(
t
)
MediaTimeToSeconds
(
end
)
offset
endTicksNeeded
)
)
;
uint32_t
available
=
endTicksAvailable
-
offset
;
ticksWritten
+
=
available
;
toWrite
-
=
available
;
offset
=
endTicksAvailable
;
}
output
.
AppendNullData
(
toWrite
)
;
LOG
(
LogLevel
:
:
Verbose
(
"
%
p
MediaTrack
%
p
writing
%
"
PRId64
"
padding
slsamples
for
%
f
to
"
"
%
f
(
samples
%
"
PRId64
"
to
%
"
PRId64
"
)
"
this
track
toWrite
MediaTimeToSeconds
(
t
)
MediaTimeToSeconds
(
end
)
offset
endTicksNeeded
)
)
;
ticksWritten
+
=
toWrite
;
}
output
.
ApplyVolume
(
mGlobalVolume
*
aTkv
.
mVolume
)
;
}
t
=
end
;
uint32_t
outputChannels
;
if
(
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
{
outputChannels
=
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
-
>
OutputChannelCount
(
)
;
}
else
{
outputChannels
=
AudioOutputChannelCount
(
)
;
}
output
.
WriteTo
(
mMixer
outputChannels
mSampleRate
)
;
}
return
ticksWritten
;
}
void
MediaTrackGraphImpl
:
:
OpenAudioInputImpl
(
CubebUtils
:
:
AudioDeviceID
aID
AudioDataListener
*
aListener
)
{
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
nsTArray
<
RefPtr
<
AudioDataListener
>
>
&
listeners
=
mInputDeviceUsers
.
GetOrInsert
(
aID
)
;
if
(
listeners
.
IsEmpty
(
)
&
&
mInputDeviceUsers
.
Count
(
)
>
1
)
{
listeners
.
RemoveElement
(
aID
)
;
return
;
}
MOZ_ASSERT
(
!
listeners
.
Contains
(
aListener
)
"
Don
'
t
add
a
listener
twice
.
"
)
;
listeners
.
AppendElement
(
aListener
)
;
if
(
listeners
.
Length
(
)
=
=
1
)
{
mInputDeviceID
=
aID
;
MonitorAutoLock
mon
(
mMonitor
)
;
if
(
LifecycleStateRef
(
)
=
=
LIFECYCLE_RUNNING
)
{
AudioCallbackDriver
*
driver
=
new
AudioCallbackDriver
(
this
AudioOutputChannelCount
(
)
AudioInputChannelCount
(
)
AudioInputDevicePreference
(
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
OpenAudioInput
:
starting
new
AudioCallbackDriver
(
input
)
%
p
"
this
driver
)
)
;
CurrentDriver
(
)
-
>
SwitchAtNextIteration
(
driver
)
;
}
else
{
LOG
(
LogLevel
:
:
Error
(
"
OpenAudioInput
in
shutdown
!
"
)
)
;
MOZ_ASSERT_UNREACHABLE
(
"
Can
'
t
open
cubeb
inputs
in
shutdown
"
)
;
}
}
}
nsresult
MediaTrackGraphImpl
:
:
OpenAudioInput
(
CubebUtils
:
:
AudioDeviceID
aID
AudioDataListener
*
aListener
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
class
Message
:
public
ControlMessage
{
public
:
Message
(
MediaTrackGraphImpl
*
aGraph
CubebUtils
:
:
AudioDeviceID
aID
AudioDataListener
*
aListener
)
:
ControlMessage
(
nullptr
)
mGraph
(
aGraph
)
mID
(
aID
)
mListener
(
aListener
)
{
}
void
Run
(
)
override
{
mGraph
-
>
OpenAudioInputImpl
(
mID
mListener
)
;
}
MediaTrackGraphImpl
*
mGraph
;
CubebUtils
:
:
AudioDeviceID
mID
;
RefPtr
<
AudioDataListener
>
mListener
;
}
;
this
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
aID
aListener
)
)
;
return
NS_OK
;
}
void
MediaTrackGraphImpl
:
:
CloseAudioInputImpl
(
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
&
aID
AudioDataListener
*
aListener
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
if
(
aID
.
isNothing
(
)
)
{
for
(
auto
iter
=
mInputDeviceUsers
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
Data
(
)
.
Contains
(
aListener
)
)
{
aID
=
Some
(
iter
.
Key
(
)
)
;
}
}
MOZ_ASSERT
(
aID
.
isSome
(
)
"
Closing
an
audio
input
that
was
not
opened
.
"
)
;
}
nsTArray
<
RefPtr
<
AudioDataListener
>
>
*
listeners
=
mInputDeviceUsers
.
GetValue
(
aID
.
value
(
)
)
;
MOZ_ASSERT
(
listeners
)
;
DebugOnly
<
bool
>
wasPresent
=
listeners
-
>
RemoveElement
(
aListener
)
;
MOZ_ASSERT
(
wasPresent
)
;
aListener
-
>
Disconnect
(
this
)
;
if
(
!
listeners
-
>
IsEmpty
(
)
)
{
return
;
}
mInputDeviceID
=
nullptr
;
mInputDeviceUsers
.
Remove
(
aID
.
value
(
)
)
;
bool
audioTrackPresent
=
AudioTrackPresent
(
)
;
MonitorAutoLock
mon
(
mMonitor
)
;
if
(
LifecycleStateRef
(
)
=
=
LIFECYCLE_RUNNING
)
{
GraphDriver
*
driver
;
if
(
audioTrackPresent
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
CloseInput
:
output
present
(
AudioCallback
)
"
this
)
)
;
driver
=
new
AudioCallbackDriver
(
this
AudioOutputChannelCount
(
)
AudioInputChannelCount
(
)
AudioInputDevicePreference
(
)
)
;
CurrentDriver
(
)
-
>
SwitchAtNextIteration
(
driver
)
;
}
else
if
(
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
CloseInput
:
no
output
present
(
SystemClockCallback
)
"
this
)
)
;
driver
=
new
SystemClockDriver
(
this
)
;
CurrentDriver
(
)
-
>
SwitchAtNextIteration
(
driver
)
;
}
}
}
void
MediaTrackGraphImpl
:
:
RegisterAudioOutput
(
MediaTrack
*
aTrack
void
*
aKey
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
TrackKeyAndVolume
*
tkv
=
mAudioOutputs
.
AppendElement
(
)
;
tkv
-
>
mTrack
=
aTrack
;
tkv
-
>
mKey
=
aKey
;
tkv
-
>
mVolume
=
1
.
0
;
bool
switching
=
false
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
switching
=
CurrentDriver
(
)
-
>
Switching
(
)
;
}
if
(
!
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
&
&
!
switching
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
if
(
LifecycleStateRef
(
)
=
=
LIFECYCLE_RUNNING
)
{
AudioCallbackDriver
*
driver
=
new
AudioCallbackDriver
(
this
AudioOutputChannelCount
(
)
AudioInputChannelCount
(
)
AudioInputDevicePreference
(
)
)
;
CurrentDriver
(
)
-
>
SwitchAtNextIteration
(
driver
)
;
}
}
}
void
MediaTrackGraphImpl
:
:
UnregisterAllAudioOutputs
(
MediaTrack
*
aTrack
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
for
(
int32_t
i
=
mAudioOutputs
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
mAudioOutputs
[
i
]
.
mTrack
=
=
aTrack
)
{
mAudioOutputs
.
RemoveElementAt
(
i
)
;
}
}
}
void
MediaTrackGraphImpl
:
:
UnregisterAudioOutput
(
MediaTrack
*
aTrack
void
*
aKey
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
mAudioOutputs
.
RemoveElementsBy
(
[
&
aKey
&
aTrack
]
(
const
TrackKeyAndVolume
&
aTkv
)
{
return
aTkv
.
mKey
=
=
aKey
&
&
aTkv
.
mTrack
=
=
aTrack
;
}
)
;
}
void
MediaTrackGraphImpl
:
:
CloseAudioInput
(
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
&
aID
AudioDataListener
*
aListener
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
class
Message
:
public
ControlMessage
{
public
:
Message
(
MediaTrackGraphImpl
*
aGraph
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
&
aID
AudioDataListener
*
aListener
)
:
ControlMessage
(
nullptr
)
mGraph
(
aGraph
)
mID
(
aID
)
mListener
(
aListener
)
{
}
void
Run
(
)
override
{
mGraph
-
>
CloseAudioInputImpl
(
mID
mListener
)
;
}
MediaTrackGraphImpl
*
mGraph
;
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
mID
;
RefPtr
<
AudioDataListener
>
mListener
;
}
;
this
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
aID
aListener
)
)
;
}
void
MediaTrackGraphImpl
:
:
NotifyOutputData
(
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
{
#
ifdef
ANDROID
if
(
!
mInputDeviceUsers
.
GetValue
(
mInputDeviceID
)
)
{
return
;
}
#
else
if
(
!
mInputDeviceID
)
{
return
;
}
#
endif
nsTArray
<
RefPtr
<
AudioDataListener
>
>
*
listeners
=
mInputDeviceUsers
.
GetValue
(
mInputDeviceID
)
;
MOZ_ASSERT
(
listeners
)
;
for
(
auto
&
listener
:
*
listeners
)
{
listener
-
>
NotifyOutputData
(
this
aBuffer
aFrames
aRate
aChannels
)
;
}
}
void
MediaTrackGraphImpl
:
:
NotifyInputData
(
const
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
{
#
ifdef
ANDROID
if
(
!
mInputDeviceUsers
.
GetValue
(
mInputDeviceID
)
)
{
return
;
}
#
else
#
ifdef
DEBUG
{
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
mInputDeviceID
|
|
CurrentDriver
(
)
-
>
Switching
(
)
)
;
}
#
endif
if
(
!
mInputDeviceID
)
{
return
;
}
#
endif
nsTArray
<
RefPtr
<
AudioDataListener
>
>
*
listeners
=
mInputDeviceUsers
.
GetValue
(
mInputDeviceID
)
;
MOZ_ASSERT
(
listeners
)
;
for
(
auto
&
listener
:
*
listeners
)
{
listener
-
>
NotifyInputData
(
this
aBuffer
aFrames
aRate
aChannels
)
;
}
}
void
MediaTrackGraphImpl
:
:
DeviceChangedImpl
(
)
{
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
#
ifdef
ANDROID
if
(
!
mInputDeviceUsers
.
GetValue
(
mInputDeviceID
)
)
{
return
;
}
#
else
if
(
!
mInputDeviceID
)
{
return
;
}
#
endif
nsTArray
<
RefPtr
<
AudioDataListener
>
>
*
listeners
=
mInputDeviceUsers
.
GetValue
(
mInputDeviceID
)
;
for
(
auto
&
listener
:
*
listeners
)
{
listener
-
>
DeviceChanged
(
this
)
;
}
}
void
MediaTrackGraphImpl
:
:
DeviceChanged
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
RefPtr
<
nsIRunnable
>
runnable
=
WrapRunnable
(
RefPtr
<
MediaTrackGraphImpl
>
(
this
)
&
MediaTrackGraphImpl
:
:
DeviceChanged
)
;
mAbstractMainThread
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
return
;
}
class
Message
:
public
ControlMessage
{
public
:
explicit
Message
(
MediaTrackGraph
*
aGraph
)
:
ControlMessage
(
nullptr
)
mGraphImpl
(
static_cast
<
MediaTrackGraphImpl
*
>
(
aGraph
)
)
{
}
void
Run
(
)
override
{
mGraphImpl
-
>
DeviceChangedImpl
(
)
;
}
MediaTrackGraphImpl
*
mGraphImpl
;
}
;
if
(
mMainThreadTrackCount
=
=
0
&
&
mMainThreadPortCount
=
=
0
)
{
return
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mAudioOutputLatency
=
0
.
0
;
AppendMessage
(
MakeUnique
<
Message
>
(
this
)
)
;
}
void
MediaTrackGraphImpl
:
:
ReevaluateInputDevice
(
)
{
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
bool
needToSwitch
=
false
;
if
(
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
{
AudioCallbackDriver
*
audioCallbackDriver
=
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
;
if
(
audioCallbackDriver
-
>
InputChannelCount
(
)
!
=
AudioInputChannelCount
(
)
)
{
needToSwitch
=
true
;
}
if
(
audioCallbackDriver
-
>
InputDevicePreference
(
)
!
=
AudioInputDevicePreference
(
)
)
{
needToSwitch
=
true
;
}
}
else
{
#
ifdef
DEBUG
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
CurrentDriver
(
)
-
>
Switching
(
)
)
;
#
endif
needToSwitch
=
true
;
}
if
(
needToSwitch
)
{
AudioCallbackDriver
*
newDriver
=
new
AudioCallbackDriver
(
this
AudioOutputChannelCount
(
)
AudioInputChannelCount
(
)
AudioInputDevicePreference
(
)
)
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
CurrentDriver
(
)
-
>
SwitchAtNextIteration
(
newDriver
)
;
}
}
}
bool
MediaTrackGraphImpl
:
:
OnGraphThreadOrNotRunning
(
)
const
{
return
mDetectedNotRunning
?
NS_IsMainThread
(
)
:
OnGraphThread
(
)
;
}
bool
MediaTrackGraphImpl
:
:
OnGraphThread
(
)
const
{
MOZ_ASSERT
(
mDriver
)
;
if
(
mGraphRunner
&
&
mGraphRunner
-
>
OnThread
(
)
)
{
return
true
;
}
return
mDriver
-
>
OnThread
(
)
;
}
bool
MediaTrackGraphImpl
:
:
Destroyed
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
!
mSelfRef
;
}
bool
MediaTrackGraphImpl
:
:
ShouldUpdateMainThread
(
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
if
(
mRealtime
)
{
return
true
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
!
mNeedAnotherIteration
|
|
(
(
now
-
mLastMainThreadUpdate
)
.
ToMilliseconds
(
)
>
CurrentDriver
(
)
-
>
IterationDuration
(
)
)
)
{
mLastMainThreadUpdate
=
now
;
return
true
;
}
return
false
;
}
void
MediaTrackGraphImpl
:
:
PrepareUpdatesToMainThreadState
(
bool
aFinalUpdate
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
aFinalUpdate
|
|
ShouldUpdateMainThread
(
)
)
{
size_t
keptUpdateCount
=
0
;
for
(
size_t
i
=
0
;
i
<
mTrackUpdates
.
Length
(
)
;
+
+
i
)
{
MediaTrack
*
track
=
mTrackUpdates
[
i
]
.
mTrack
;
MOZ_ASSERT
(
!
track
|
|
track
-
>
GraphImpl
(
)
=
=
this
)
;
if
(
!
track
|
|
track
-
>
MainThreadNeedsUpdates
(
)
)
{
continue
;
}
if
(
keptUpdateCount
!
=
i
)
{
mTrackUpdates
[
keptUpdateCount
]
=
std
:
:
move
(
mTrackUpdates
[
i
]
)
;
MOZ_ASSERT
(
!
mTrackUpdates
[
i
]
.
mTrack
)
;
}
+
+
keptUpdateCount
;
}
mTrackUpdates
.
TruncateLength
(
keptUpdateCount
)
;
mTrackUpdates
.
SetCapacity
(
mTrackUpdates
.
Length
(
)
+
mTracks
.
Length
(
)
+
mSuspendedTracks
.
Length
(
)
)
;
for
(
MediaTrack
*
track
:
AllTracks
(
)
)
{
if
(
!
track
-
>
MainThreadNeedsUpdates
(
)
)
{
continue
;
}
TrackUpdate
*
update
=
mTrackUpdates
.
AppendElement
(
)
;
update
-
>
mTrack
=
track
;
update
-
>
mNextMainThreadCurrentTime
=
track
-
>
GraphTimeToTrackTime
(
mProcessedTime
)
;
update
-
>
mNextMainThreadEnded
=
track
-
>
mNotifiedEnded
;
}
mNextMainThreadGraphTime
=
mProcessedTime
;
if
(
!
mPendingUpdateRunnables
.
IsEmpty
(
)
)
{
mUpdateRunnables
.
AppendElements
(
std
:
:
move
(
mPendingUpdateRunnables
)
)
;
}
}
if
(
!
aFinalUpdate
&
&
!
(
mUpdateRunnables
.
IsEmpty
(
)
&
&
mTrackUpdates
.
IsEmpty
(
)
)
)
{
EnsureStableStateEventPosted
(
)
;
}
}
GraphTime
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
GraphTime
aTime
)
{
if
(
aTime
%
WEBAUDIO_BLOCK_SIZE
=
=
0
)
{
return
aTime
;
}
return
RoundUpToNextAudioBlock
(
aTime
)
;
}
GraphTime
MediaTrackGraphImpl
:
:
RoundUpToNextAudioBlock
(
GraphTime
aTime
)
{
uint64_t
block
=
aTime
>
>
WEBAUDIO_BLOCK_SIZE_BITS
;
uint64_t
nextBlock
=
block
+
1
;
GraphTime
nextTime
=
nextBlock
<
<
WEBAUDIO_BLOCK_SIZE_BITS
;
return
nextTime
;
}
void
MediaTrackGraphImpl
:
:
ProduceDataForTracksBlockByBlock
(
uint32_t
aTrackIndex
TrackRate
aSampleRate
)
{
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
MOZ_ASSERT
(
aTrackIndex
<
=
mFirstCycleBreaker
"
Cycle
breaker
is
not
AudioNodeTrack
?
"
)
;
while
(
mProcessedTime
<
mStateComputedTime
)
{
GraphTime
next
=
RoundUpToNextAudioBlock
(
mProcessedTime
)
;
for
(
uint32_t
i
=
mFirstCycleBreaker
;
i
<
mTracks
.
Length
(
)
;
+
+
i
)
{
auto
nt
=
static_cast
<
AudioNodeTrack
*
>
(
mTracks
[
i
]
)
;
MOZ_ASSERT
(
nt
-
>
AsAudioNodeTrack
(
)
)
;
nt
-
>
ProduceOutputBeforeInput
(
mProcessedTime
)
;
}
for
(
uint32_t
i
=
aTrackIndex
;
i
<
mTracks
.
Length
(
)
;
+
+
i
)
{
ProcessedMediaTrack
*
pt
=
mTracks
[
i
]
-
>
AsProcessedTrack
(
)
;
if
(
pt
)
{
pt
-
>
ProcessInput
(
mProcessedTime
next
(
next
=
=
mStateComputedTime
)
?
ProcessedMediaTrack
:
:
ALLOW_END
:
0
)
;
}
}
mProcessedTime
=
next
;
}
NS_ASSERTION
(
mProcessedTime
=
=
mStateComputedTime
"
Something
went
wrong
with
rounding
to
block
boundaries
"
)
;
}
void
MediaTrackGraphImpl
:
:
RunMessageAfterProcessing
(
UniquePtr
<
ControlMessage
>
aMessage
)
{
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
if
(
mFrontMessageQueue
.
IsEmpty
(
)
)
{
mFrontMessageQueue
.
AppendElement
(
)
;
}
MOZ_ASSERT
(
mFrontMessageQueue
.
Length
(
)
=
=
1
)
;
mFrontMessageQueue
[
0
]
.
mMessages
.
AppendElement
(
std
:
:
move
(
aMessage
)
)
;
}
void
MediaTrackGraphImpl
:
:
RunMessagesInQueue
(
)
{
TRACE_AUDIO_CALLBACK
(
)
;
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mFrontMessageQueue
.
Length
(
)
;
+
+
i
)
{
nsTArray
<
UniquePtr
<
ControlMessage
>
>
&
messages
=
mFrontMessageQueue
[
i
]
.
mMessages
;
for
(
uint32_t
j
=
0
;
j
<
messages
.
Length
(
)
;
+
+
j
)
{
messages
[
j
]
-
>
Run
(
)
;
}
}
mFrontMessageQueue
.
Clear
(
)
;
}
void
MediaTrackGraphImpl
:
:
UpdateGraph
(
GraphTime
aEndBlockingDecisions
)
{
TRACE_AUDIO_CALLBACK
(
)
;
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
MOZ_ASSERT
(
aEndBlockingDecisions
>
=
mProcessedTime
)
;
MOZ_ASSERT
(
aEndBlockingDecisions
>
=
mStateComputedTime
)
;
UpdateTrackOrder
(
)
;
bool
ensureNextIteration
=
false
;
for
(
MediaTrack
*
track
:
mTracks
)
{
if
(
SourceMediaTrack
*
is
=
track
-
>
AsSourceTrack
(
)
)
{
ensureNextIteration
|
=
is
-
>
PullNewData
(
aEndBlockingDecisions
)
;
is
-
>
ExtractPendingInput
(
mStateComputedTime
aEndBlockingDecisions
)
;
}
if
(
track
-
>
mEnded
)
{
GraphTime
endTime
=
track
-
>
GetEnd
(
)
+
track
-
>
mStartTime
;
if
(
endTime
<
=
mStateComputedTime
)
{
LOG
(
LogLevel
:
:
Verbose
(
"
%
p
:
MediaTrack
%
p
is
blocked
due
to
being
ended
"
this
track
)
)
;
track
-
>
mStartBlocking
=
mStateComputedTime
;
}
else
{
LOG
(
LogLevel
:
:
Verbose
(
"
%
p
:
MediaTrack
%
p
has
ended
but
is
not
blocked
yet
(
current
"
"
time
%
f
end
at
%
f
)
"
this
track
MediaTimeToSeconds
(
mStateComputedTime
)
MediaTimeToSeconds
(
endTime
)
)
)
;
MOZ_ASSERT
(
endTime
<
=
aEndBlockingDecisions
)
;
track
-
>
mStartBlocking
=
endTime
;
}
}
else
{
track
-
>
mStartBlocking
=
WillUnderrun
(
track
aEndBlockingDecisions
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
if
(
SourceMediaTrack
*
s
=
track
-
>
AsSourceTrack
(
)
)
{
if
(
s
-
>
Ended
(
)
)
{
continue
;
}
{
MutexAutoLock
lock
(
s
-
>
mMutex
)
;
if
(
!
s
-
>
mUpdateTrack
-
>
mPullingEnabled
)
{
continue
;
}
}
if
(
track
-
>
GetEnd
(
)
<
track
-
>
GraphTimeToTrackTime
(
aEndBlockingDecisions
)
)
{
LOG
(
LogLevel
:
:
Error
(
"
%
p
:
SourceMediaTrack
%
p
(
%
s
)
is
live
and
pulled
"
"
but
wasn
'
t
fed
"
"
enough
data
.
TrackListeners
=
%
zu
.
Track
-
end
=
%
f
"
"
Iteration
-
end
=
%
f
"
this
track
(
track
-
>
mType
=
=
MediaSegment
:
:
AUDIO
?
"
audio
"
:
"
video
"
)
track
-
>
mTrackListeners
.
Length
(
)
MediaTimeToSeconds
(
track
-
>
GetEnd
(
)
)
MediaTimeToSeconds
(
track
-
>
GraphTimeToTrackTime
(
aEndBlockingDecisions
)
)
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
false
"
A
non
-
ended
SourceMediaTrack
wasn
'
t
fed
"
"
enough
data
by
NotifyPull
"
)
;
}
}
#
endif
}
}
for
(
MediaTrack
*
track
:
mSuspendedTracks
)
{
track
-
>
mStartBlocking
=
mStateComputedTime
;
}
if
(
ensureNextIteration
|
|
(
aEndBlockingDecisions
=
=
mStateComputedTime
&
&
mStateComputedTime
<
mEndTime
)
)
{
EnsureNextIteration
(
)
;
}
}
void
MediaTrackGraphImpl
:
:
Process
(
)
{
TRACE_AUDIO_CALLBACK
(
)
;
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
bool
allBlockedForever
=
true
;
bool
doneAllProducing
=
false
;
const
GraphTime
oldProcessedTime
=
mProcessedTime
;
mMixer
.
StartMixing
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mTracks
.
Length
(
)
;
+
+
i
)
{
MediaTrack
*
track
=
mTracks
[
i
]
;
if
(
!
doneAllProducing
)
{
ProcessedMediaTrack
*
pt
=
track
-
>
AsProcessedTrack
(
)
;
if
(
pt
)
{
AudioNodeTrack
*
n
=
track
-
>
AsAudioNodeTrack
(
)
;
if
(
n
)
{
#
ifdef
DEBUG
for
(
uint32_t
j
=
i
+
1
;
j
<
mTracks
.
Length
(
)
;
+
+
j
)
{
AudioNodeTrack
*
nextTrack
=
mTracks
[
j
]
-
>
AsAudioNodeTrack
(
)
;
if
(
nextTrack
)
{
MOZ_ASSERT
(
n
-
>
mSampleRate
=
=
nextTrack
-
>
mSampleRate
"
All
AudioNodeTracks
in
the
graph
must
have
the
same
"
"
sampling
rate
"
)
;
}
}
#
endif
ProduceDataForTracksBlockByBlock
(
i
n
-
>
mSampleRate
)
;
doneAllProducing
=
true
;
}
else
{
pt
-
>
ProcessInput
(
mProcessedTime
mStateComputedTime
ProcessedMediaTrack
:
:
ALLOW_END
)
;
MOZ_ASSERT_IF
(
!
track
-
>
mEnded
track
-
>
GetEnd
(
)
>
=
GraphTimeToTrackTimeWithBlocking
(
track
mStateComputedTime
)
)
;
}
}
}
if
(
track
-
>
mStartBlocking
>
oldProcessedTime
)
{
allBlockedForever
=
false
;
}
}
mProcessedTime
=
mStateComputedTime
;
TrackTime
ticksPlayed
=
0
;
if
(
mRealtime
)
{
if
(
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
{
for
(
auto
&
t
:
mAudioOutputs
)
{
TrackTime
ticksPlayedForThisTrack
=
PlayAudio
(
t
oldProcessedTime
)
;
if
(
ticksPlayed
=
=
0
)
{
ticksPlayed
=
ticksPlayedForThisTrack
;
}
else
{
MOZ_ASSERT
(
!
ticksPlayedForThisTrack
|
|
ticksPlayedForThisTrack
=
=
ticksPlayed
"
Each
track
should
have
the
same
number
of
frames
.
"
)
;
}
}
}
}
if
(
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
{
if
(
!
ticksPlayed
)
{
mMixer
.
Mix
(
nullptr
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
-
>
OutputChannelCount
(
)
mStateComputedTime
-
oldProcessedTime
mSampleRate
)
;
}
mMixer
.
FinishMixing
(
)
;
}
if
(
!
allBlockedForever
)
{
EnsureNextIteration
(
)
;
}
}
bool
MediaTrackGraphImpl
:
:
UpdateMainThreadState
(
)
{
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
if
(
mForceShutDown
)
{
for
(
MediaTrack
*
track
:
AllTracks
(
)
)
{
track
-
>
NotifyForcedShutdown
(
)
;
}
}
MonitorAutoLock
lock
(
mMonitor
)
;
bool
finalUpdate
=
mForceShutDown
|
|
(
IsEmpty
(
)
&
&
mBackMessageQueue
.
IsEmpty
(
)
)
;
PrepareUpdatesToMainThreadState
(
finalUpdate
)
;
if
(
finalUpdate
)
{
return
false
;
}
CurrentDriver
(
)
-
>
WaitForNextIteration
(
)
;
SwapMessageQueues
(
)
;
return
true
;
}
bool
MediaTrackGraphImpl
:
:
OneIteration
(
GraphTime
aStateEnd
)
{
if
(
mGraphRunner
)
{
return
mGraphRunner
-
>
OneIteration
(
aStateEnd
)
;
}
return
OneIterationImpl
(
aStateEnd
)
;
}
bool
MediaTrackGraphImpl
:
:
OneIterationImpl
(
GraphTime
aStateEnd
)
{
TRACE_AUDIO_CALLBACK
(
)
;
if
(
SoftRealTimeLimitReached
(
)
)
{
DemoteThreadFromRealTime
(
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mLifecycleState
<
=
LIFECYCLE_RUNNING
)
;
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
WebCore
:
:
DenormalDisabler
disabler
;
RunMessagesInQueue
(
)
;
if
(
mGraphRunner
|
|
!
mRealtime
)
{
NS_ProcessPendingEvents
(
nullptr
)
;
}
GraphTime
stateEnd
=
std
:
:
min
(
aStateEnd
GraphTime
(
mEndTime
)
)
;
UpdateGraph
(
stateEnd
)
;
mStateComputedTime
=
stateEnd
;
GraphTime
oldProcessedTime
=
mProcessedTime
;
Process
(
)
;
MOZ_ASSERT
(
mProcessedTime
=
=
stateEnd
)
;
UpdateCurrentTimeForTracks
(
oldProcessedTime
)
;
ProcessChunkMetadata
(
oldProcessedTime
)
;
RunMessagesInQueue
(
)
;
return
UpdateMainThreadState
(
)
;
}
void
MediaTrackGraphImpl
:
:
ApplyTrackUpdate
(
TrackUpdate
*
aUpdate
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
MediaTrack
*
track
=
aUpdate
-
>
mTrack
;
if
(
!
track
)
return
;
track
-
>
mMainThreadCurrentTime
=
aUpdate
-
>
mNextMainThreadCurrentTime
;
track
-
>
mMainThreadEnded
=
aUpdate
-
>
mNextMainThreadEnded
;
if
(
track
-
>
ShouldNotifyTrackEnded
(
)
)
{
track
-
>
NotifyMainThreadListeners
(
)
;
}
}
void
MediaTrackGraphImpl
:
:
ForceShutDown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
called
on
main
thread
"
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
MediaTrackGraph
:
:
ForceShutdown
"
this
)
)
;
if
(
mShutdownBlocker
)
{
NS_NewTimerWithCallback
(
getter_AddRefs
(
mShutdownTimer
)
this
MediaTrackGraph
:
:
AUDIO_CALLBACK_DRIVER_SHUTDOWN_TIMEOUT
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
class
Message
final
:
public
ControlMessage
{
public
:
explicit
Message
(
MediaTrackGraphImpl
*
aGraph
)
:
ControlMessage
(
nullptr
)
mGraph
(
aGraph
)
{
}
void
Run
(
)
override
{
mGraph
-
>
mForceShutDown
=
true
;
}
MediaTrackGraphImpl
*
MOZ_NON_OWNING_REF
mGraph
;
}
;
if
(
mMainThreadTrackCount
>
0
|
|
mMainThreadPortCount
>
0
)
{
AppendMessage
(
MakeUnique
<
Message
>
(
this
)
)
;
}
}
NS_IMETHODIMP
MediaTrackGraphImpl
:
:
Notify
(
nsITimer
*
aTimer
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ASSERTION
(
!
mShutdownBlocker
"
MediaTrackGraph
took
too
long
to
shut
down
!
"
)
;
RemoveShutdownBlocker
(
)
;
return
NS_OK
;
}
void
MediaTrackGraphImpl
:
:
AddShutdownBlocker
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mShutdownBlocker
)
;
class
Blocker
:
public
media
:
:
ShutdownBlocker
{
const
RefPtr
<
MediaTrackGraphImpl
>
mGraph
;
public
:
Blocker
(
MediaTrackGraphImpl
*
aGraph
const
nsString
&
aName
)
:
media
:
:
ShutdownBlocker
(
aName
)
mGraph
(
aGraph
)
{
}
NS_IMETHOD
BlockShutdown
(
nsIAsyncShutdownClient
*
aProfileBeforeChange
)
override
{
mGraph
-
>
ForceShutDown
(
)
;
return
NS_OK
;
}
}
;
nsString
blockerName
;
blockerName
.
AppendPrintf
(
"
MediaTrackGraph
%
p
shutdown
"
this
)
;
mShutdownBlocker
=
MakeAndAddRef
<
Blocker
>
(
this
blockerName
)
;
nsresult
rv
=
media
:
:
GetShutdownBarrier
(
)
-
>
AddBlocker
(
mShutdownBlocker
NS_LITERAL_STRING
(
__FILE__
)
__LINE__
NS_LITERAL_STRING
(
"
MediaTrackGraph
shutdown
"
)
)
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
void
MediaTrackGraphImpl
:
:
RemoveShutdownBlocker
(
)
{
if
(
!
mShutdownBlocker
)
{
return
;
}
media
:
:
GetShutdownBarrier
(
)
-
>
RemoveBlocker
(
mShutdownBlocker
)
;
mShutdownBlocker
=
nullptr
;
}
NS_IMETHODIMP
MediaTrackGraphImpl
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
MediaTrackGraphImpl
"
)
;
return
NS_OK
;
}
namespace
{
class
MediaTrackGraphShutDownRunnable
:
public
Runnable
{
public
:
explicit
MediaTrackGraphShutDownRunnable
(
MediaTrackGraphImpl
*
aGraph
)
:
Runnable
(
"
MediaTrackGraphShutDownRunnable
"
)
mGraph
(
aGraph
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mGraph
-
>
mDetectedNotRunning
&
&
mGraph
-
>
mDriver
"
We
should
know
the
graph
thread
control
loop
isn
'
t
running
!
"
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
Shutting
down
graph
"
mGraph
.
get
(
)
)
)
;
#
if
0
if
(
mGraph
-
>
mDriver
-
>
AsAudioCallbackDriver
(
)
)
{
MOZ_ASSERT
(
!
mGraph
-
>
mDriver
-
>
AsAudioCallbackDriver
(
)
-
>
InCallback
(
)
)
;
}
#
endif
if
(
mGraph
-
>
mGraphRunner
)
{
RefPtr
<
GraphRunner
>
(
mGraph
-
>
mGraphRunner
)
-
>
Shutdown
(
)
;
}
RefPtr
<
GraphDriver
>
(
mGraph
-
>
mDriver
)
-
>
Shutdown
(
)
;
{
MonitorAutoLock
mon
(
mGraph
-
>
mMonitor
)
;
mGraph
-
>
SetCurrentDriver
(
nullptr
)
;
}
if
(
mGraph
-
>
mShutdownTimer
&
&
!
mGraph
-
>
mShutdownBlocker
)
{
MOZ_ASSERT
(
false
"
AudioCallbackDriver
took
too
long
to
shut
down
and
we
let
shutdown
"
"
continue
-
freezing
and
leaking
"
)
;
return
NS_OK
;
}
for
(
MediaTrack
*
track
:
mGraph
-
>
AllTracks
(
)
)
{
track
-
>
RemoveAllResourcesAndListenersImpl
(
)
;
}
MOZ_ASSERT
(
mGraph
-
>
mUpdateRunnables
.
IsEmpty
(
)
)
;
mGraph
-
>
mPendingUpdateRunnables
.
Clear
(
)
;
mGraph
-
>
RemoveShutdownBlocker
(
)
;
if
(
mGraph
-
>
IsEmpty
(
)
)
{
mGraph
-
>
Destroy
(
)
;
}
else
{
NS_ASSERTION
(
mGraph
-
>
mForceShutDown
"
Not
in
forced
shutdown
?
"
)
;
mGraph
-
>
LifecycleStateRef
(
)
=
MediaTrackGraphImpl
:
:
LIFECYCLE_WAITING_FOR_TRACK_DESTRUCTION
;
}
return
NS_OK
;
}
private
:
RefPtr
<
MediaTrackGraphImpl
>
mGraph
;
}
;
class
MediaTrackGraphStableStateRunnable
:
public
Runnable
{
public
:
explicit
MediaTrackGraphStableStateRunnable
(
MediaTrackGraphImpl
*
aGraph
bool
aSourceIsMTG
)
:
Runnable
(
"
MediaTrackGraphStableStateRunnable
"
)
mGraph
(
aGraph
)
mSourceIsMTG
(
aSourceIsMTG
)
{
}
NS_IMETHOD
Run
(
)
override
{
TRACE
(
)
;
if
(
mGraph
)
{
mGraph
-
>
RunInStableState
(
mSourceIsMTG
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
MediaTrackGraphImpl
>
mGraph
;
bool
mSourceIsMTG
;
}
;
class
CreateMessage
:
public
ControlMessage
{
public
:
explicit
CreateMessage
(
MediaTrack
*
aTrack
)
:
ControlMessage
(
aTrack
)
{
}
void
Run
(
)
override
{
mTrack
-
>
GraphImpl
(
)
-
>
AddTrackGraphThread
(
mTrack
)
;
}
void
RunDuringShutdown
(
)
override
{
Run
(
)
;
}
}
;
}
void
MediaTrackGraphImpl
:
:
RunInStableState
(
bool
aSourceIsMTG
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
called
on
main
thread
"
)
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
runnables
;
nsTArray
<
UniquePtr
<
ControlMessage
>
>
controlMessagesToRunDuringShutdown
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
aSourceIsMTG
)
{
MOZ_ASSERT
(
mPostedRunInStableStateEvent
)
;
mPostedRunInStableStateEvent
=
false
;
}
const
char
*
LifecycleState_str
[
]
=
{
"
LIFECYCLE_THREAD_NOT_STARTED
"
"
LIFECYCLE_RUNNING
"
"
LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP
"
"
LIFECYCLE_WAITING_FOR_THREAD_SHUTDOWN
"
"
LIFECYCLE_WAITING_FOR_TRACK_DESTRUCTION
"
}
;
if
(
LifecycleStateRef
(
)
!
=
LIFECYCLE_RUNNING
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
Running
stable
state
callback
.
Current
state
:
%
s
"
this
LifecycleState_str
[
LifecycleStateRef
(
)
]
)
)
;
}
runnables
.
SwapElements
(
mUpdateRunnables
)
;
for
(
uint32_t
i
=
0
;
i
<
mTrackUpdates
.
Length
(
)
;
+
+
i
)
{
TrackUpdate
*
update
=
&
mTrackUpdates
[
i
]
;
if
(
update
-
>
mTrack
)
{
ApplyTrackUpdate
(
update
)
;
}
}
mTrackUpdates
.
Clear
(
)
;
mMainThreadGraphTime
=
mNextMainThreadGraphTime
;
if
(
mCurrentTaskMessageQueue
.
IsEmpty
(
)
)
{
if
(
LifecycleStateRef
(
)
=
=
LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP
&
&
IsEmpty
(
)
)
{
LifecycleStateRef
(
)
=
LIFECYCLE_WAITING_FOR_THREAD_SHUTDOWN
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
Sending
MediaTrackGraphShutDownRunnable
"
this
)
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
MediaTrackGraphShutDownRunnable
(
this
)
;
mAbstractMainThread
-
>
Dispatch
(
event
.
forget
(
)
)
;
}
}
else
{
if
(
LifecycleStateRef
(
)
<
=
LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP
)
{
MessageBlock
*
block
=
mBackMessageQueue
.
AppendElement
(
)
;
block
-
>
mMessages
.
SwapElements
(
mCurrentTaskMessageQueue
)
;
EnsureNextIterationLocked
(
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mForceShutDown
|
|
LifecycleStateRef
(
)
<
LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP
)
;
}
if
(
LifecycleStateRef
(
)
=
=
LIFECYCLE_THREAD_NOT_STARTED
)
{
LifecycleStateRef
(
)
=
LIFECYCLE_RUNNING
;
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
Starting
a
graph
with
a
%
s
"
this
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
?
"
AudioCallbackDriver
"
:
"
SystemClockDriver
"
)
)
;
RefPtr
<
GraphDriver
>
driver
=
CurrentDriver
(
)
;
MonitorAutoUnlock
unlock
(
mMonitor
)
;
driver
-
>
Start
(
)
;
NS_ReleaseOnMainThreadSystemGroup
(
"
MediaTrackGraphImpl
:
:
CurrentDriver
"
driver
.
forget
(
)
true
)
;
}
}
if
(
LifecycleStateRef
(
)
=
=
LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP
&
&
mForceShutDown
)
{
for
(
uint32_t
i
=
0
;
i
<
mBackMessageQueue
.
Length
(
)
;
+
+
i
)
{
MessageBlock
&
mb
=
mBackMessageQueue
[
i
]
;
controlMessagesToRunDuringShutdown
.
AppendElements
(
std
:
:
move
(
mb
.
mMessages
)
)
;
}
mBackMessageQueue
.
Clear
(
)
;
MOZ_ASSERT
(
mCurrentTaskMessageQueue
.
IsEmpty
(
)
)
;
LifecycleStateRef
(
)
=
LIFECYCLE_WAITING_FOR_THREAD_SHUTDOWN
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
MediaTrackGraphShutDownRunnable
(
this
)
;
mAbstractMainThread
-
>
Dispatch
(
event
.
forget
(
)
)
;
}
mDetectedNotRunning
=
LifecycleStateRef
(
)
>
LIFECYCLE_RUNNING
;
}
if
(
!
aSourceIsMTG
)
{
MOZ_ASSERT
(
mPostedRunInStableState
)
;
mPostedRunInStableState
=
false
;
}
for
(
uint32_t
i
=
0
;
i
<
controlMessagesToRunDuringShutdown
.
Length
(
)
;
+
+
i
)
{
controlMessagesToRunDuringShutdown
[
i
]
-
>
RunDuringShutdown
(
)
;
}
#
ifdef
DEBUG
mCanRunMessagesSynchronously
=
mDetectedNotRunning
&
&
LifecycleStateRef
(
)
>
=
LIFECYCLE_WAITING_FOR_THREAD_SHUTDOWN
;
#
endif
for
(
uint32_t
i
=
0
;
i
<
runnables
.
Length
(
)
;
+
+
i
)
{
runnables
[
i
]
-
>
Run
(
)
;
}
}
void
MediaTrackGraphImpl
:
:
EnsureRunInStableState
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
main
thread
only
"
)
;
if
(
mPostedRunInStableState
)
return
;
mPostedRunInStableState
=
true
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
MediaTrackGraphStableStateRunnable
(
this
false
)
;
nsContentUtils
:
:
RunInStableState
(
event
.
forget
(
)
)
;
}
void
MediaTrackGraphImpl
:
:
EnsureStableStateEventPosted
(
)
{
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
mPostedRunInStableStateEvent
)
return
;
mPostedRunInStableStateEvent
=
true
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
MediaTrackGraphStableStateRunnable
(
this
true
)
;
mAbstractMainThread
-
>
Dispatch
(
event
.
forget
(
)
)
;
}
void
MediaTrackGraphImpl
:
:
SignalMainThreadCleanup
(
)
{
MOZ_ASSERT
(
mDriver
-
>
OnThread
(
)
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mLifecycleState
<
=
LIFECYCLE_RUNNING
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
MediaTrackGraph
waiting
for
main
thread
cleanup
"
this
)
)
;
LifecycleStateRef
(
)
=
MediaTrackGraphImpl
:
:
LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP
;
EnsureStableStateEventPosted
(
)
;
}
void
MediaTrackGraphImpl
:
:
AppendMessage
(
UniquePtr
<
ControlMessage
>
aMessage
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
main
thread
only
"
)
;
MOZ_ASSERT_IF
(
aMessage
-
>
GetTrack
(
)
!
aMessage
-
>
GetTrack
(
)
-
>
IsDestroyed
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mMainThreadTrackCount
>
0
|
|
mMainThreadPortCount
>
0
)
;
if
(
mDetectedNotRunning
&
&
LifecycleStateRef
(
)
>
LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
mCanRunMessagesSynchronously
)
;
mCanRunMessagesSynchronously
=
false
;
#
endif
aMessage
-
>
RunDuringShutdown
(
)
;
#
ifdef
DEBUG
mCanRunMessagesSynchronously
=
true
;
#
endif
if
(
IsEmpty
(
)
&
&
LifecycleStateRef
(
)
>
=
LIFECYCLE_WAITING_FOR_TRACK_DESTRUCTION
)
{
Destroy
(
)
;
}
return
;
}
mCurrentTaskMessageQueue
.
AppendElement
(
std
:
:
move
(
aMessage
)
)
;
EnsureRunInStableState
(
)
;
}
void
MediaTrackGraphImpl
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
mAbstractMainThread
-
>
Dispatch
(
std
:
:
move
(
aRunnable
)
)
;
}
MediaTrack
:
:
MediaTrack
(
TrackRate
aSampleRate
MediaSegment
:
:
Type
aType
MediaSegment
*
aSegment
)
:
mSampleRate
(
aSampleRate
)
mType
(
aType
)
mSegment
(
aSegment
)
mStartTime
(
0
)
mForgottenTime
(
0
)
mEnded
(
false
)
mNotifiedEnded
(
false
)
mDisabledMode
(
DisabledTrackMode
:
:
ENABLED
)
mStartBlocking
(
GRAPH_TIME_MAX
)
mSuspendedCount
(
0
)
mMainThreadCurrentTime
(
0
)
mMainThreadEnded
(
false
)
mEndedNotificationSent
(
false
)
mMainThreadDestroyed
(
false
)
mGraph
(
nullptr
)
{
MOZ_COUNT_CTOR
(
MediaTrack
)
;
MOZ_ASSERT_IF
(
mSegment
mSegment
-
>
GetType
(
)
=
=
aType
)
;
}
MediaTrack
:
:
~
MediaTrack
(
)
{
MOZ_COUNT_DTOR
(
MediaTrack
)
;
NS_ASSERTION
(
mMainThreadDestroyed
"
Should
have
been
destroyed
already
"
)
;
NS_ASSERTION
(
mMainThreadListeners
.
IsEmpty
(
)
"
All
main
thread
listeners
should
have
been
removed
"
)
;
}
size_t
MediaTrack
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
0
;
amount
+
=
mTrackListeners
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
mMainThreadListeners
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
mConsumers
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
size_t
MediaTrack
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
void
MediaTrack
:
:
IncrementSuspendCount
(
)
{
+
+
mSuspendedCount
;
if
(
mSuspendedCount
=
=
1
)
{
for
(
uint32_t
i
=
0
;
i
<
mConsumers
.
Length
(
)
;
+
+
i
)
{
mConsumers
[
i
]
-
>
Suspended
(
)
;
}
}
}
void
MediaTrack
:
:
DecrementSuspendCount
(
)
{
NS_ASSERTION
(
mSuspendedCount
>
0
"
Suspend
count
underrun
"
)
;
-
-
mSuspendedCount
;
if
(
mSuspendedCount
=
=
0
)
{
for
(
uint32_t
i
=
0
;
i
<
mConsumers
.
Length
(
)
;
+
+
i
)
{
mConsumers
[
i
]
-
>
Resumed
(
)
;
}
}
}
MediaTrackGraphImpl
*
MediaTrack
:
:
GraphImpl
(
)
{
return
mGraph
;
}
const
MediaTrackGraphImpl
*
MediaTrack
:
:
GraphImpl
(
)
const
{
return
mGraph
;
}
MediaTrackGraph
*
MediaTrack
:
:
Graph
(
)
{
return
mGraph
;
}
const
MediaTrackGraph
*
MediaTrack
:
:
Graph
(
)
const
{
return
mGraph
;
}
void
MediaTrack
:
:
SetGraphImpl
(
MediaTrackGraphImpl
*
aGraph
)
{
MOZ_ASSERT
(
!
mGraph
"
Should
only
be
called
once
"
)
;
MOZ_ASSERT
(
mSampleRate
=
=
aGraph
-
>
GraphRate
(
)
)
;
mGraph
=
aGraph
;
}
void
MediaTrack
:
:
SetGraphImpl
(
MediaTrackGraph
*
aGraph
)
{
MediaTrackGraphImpl
*
graph
=
static_cast
<
MediaTrackGraphImpl
*
>
(
aGraph
)
;
SetGraphImpl
(
graph
)
;
}
TrackTime
MediaTrack
:
:
GraphTimeToTrackTime
(
GraphTime
aTime
)
const
{
NS_ASSERTION
(
mStartBlocking
=
=
GraphImpl
(
)
-
>
mStateComputedTime
|
|
aTime
<
=
mStartBlocking
"
Incorrectly
ignoring
blocking
!
"
)
;
return
aTime
-
mStartTime
;
}
GraphTime
MediaTrack
:
:
TrackTimeToGraphTime
(
TrackTime
aTime
)
const
{
NS_ASSERTION
(
mStartBlocking
=
=
GraphImpl
(
)
-
>
mStateComputedTime
|
|
aTime
+
mStartTime
<
=
mStartBlocking
"
Incorrectly
ignoring
blocking
!
"
)
;
return
aTime
+
mStartTime
;
}
TrackTime
MediaTrack
:
:
GraphTimeToTrackTimeWithBlocking
(
GraphTime
aTime
)
const
{
return
GraphImpl
(
)
-
>
GraphTimeToTrackTimeWithBlocking
(
this
aTime
)
;
}
void
MediaTrack
:
:
RemoveAllResourcesAndListenersImpl
(
)
{
GraphImpl
(
)
-
>
AssertOnGraphThreadOrNotRunning
(
)
;
auto
trackListeners
(
mTrackListeners
)
;
for
(
auto
&
l
:
trackListeners
)
{
l
-
>
NotifyRemoved
(
Graph
(
)
)
;
}
mTrackListeners
.
Clear
(
)
;
RemoveAllDirectListenersImpl
(
)
;
if
(
mSegment
)
{
mSegment
-
>
Clear
(
)
;
}
}
void
MediaTrack
:
:
DestroyImpl
(
)
{
for
(
int32_t
i
=
mConsumers
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
mConsumers
[
i
]
-
>
Disconnect
(
)
;
}
if
(
mSegment
)
{
mSegment
-
>
Clear
(
)
;
}
mGraph
=
nullptr
;
}
void
MediaTrack
:
:
Destroy
(
)
{
RefPtr
<
MediaTrack
>
kungFuDeathGrip
=
this
;
class
Message
:
public
ControlMessage
{
public
:
explicit
Message
(
MediaTrack
*
aTrack
)
:
ControlMessage
(
aTrack
)
{
}
void
Run
(
)
override
{
mTrack
-
>
RemoveAllResourcesAndListenersImpl
(
)
;
auto
graph
=
mTrack
-
>
GraphImpl
(
)
;
mTrack
-
>
DestroyImpl
(
)
;
graph
-
>
RemoveTrackGraphThread
(
mTrack
)
;
}
void
RunDuringShutdown
(
)
override
{
Run
(
)
;
}
}
;
RefPtr
<
MediaTrackGraphImpl
>
graph
=
GraphImpl
(
)
;
graph
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
)
)
;
graph
-
>
RemoveTrack
(
this
)
;
mMainThreadDestroyed
=
true
;
}
TrackTime
MediaTrack
:
:
GetEnd
(
)
const
{
return
mSegment
?
mSegment
-
>
GetDuration
(
)
:
0
;
}
void
MediaTrack
:
:
AddAudioOutput
(
void
*
aKey
)
{
class
Message
:
public
ControlMessage
{
public
:
Message
(
MediaTrack
*
aTrack
void
*
aKey
)
:
ControlMessage
(
aTrack
)
mKey
(
aKey
)
{
}
void
Run
(
)
override
{
mTrack
-
>
AddAudioOutputImpl
(
mKey
)
;
}
void
*
mKey
;
}
;
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
aKey
)
)
;
}
void
MediaTrackGraphImpl
:
:
SetAudioOutputVolume
(
MediaTrack
*
aTrack
void
*
aKey
float
aVolume
)
{
for
(
auto
&
tkv
:
mAudioOutputs
)
{
if
(
tkv
.
mKey
=
=
aKey
&
&
aTrack
=
=
tkv
.
mTrack
)
{
tkv
.
mVolume
=
aVolume
;
return
;
}
}
MOZ_CRASH
(
"
Audio
stream
key
not
found
when
setting
the
volume
.
"
)
;
}
void
MediaTrack
:
:
SetAudioOutputVolumeImpl
(
void
*
aKey
float
aVolume
)
{
MOZ_ASSERT
(
GraphImpl
(
)
-
>
OnGraphThread
(
)
)
;
GraphImpl
(
)
-
>
SetAudioOutputVolume
(
this
aKey
aVolume
)
;
}
void
MediaTrack
:
:
SetAudioOutputVolume
(
void
*
aKey
float
aVolume
)
{
class
Message
:
public
ControlMessage
{
public
:
Message
(
MediaTrack
*
aTrack
void
*
aKey
float
aVolume
)
:
ControlMessage
(
aTrack
)
mKey
(
aKey
)
mVolume
(
aVolume
)
{
}
void
Run
(
)
override
{
mTrack
-
>
SetAudioOutputVolumeImpl
(
mKey
mVolume
)
;
}
void
*
mKey
;
float
mVolume
;
}
;
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
aKey
aVolume
)
)
;
}
void
MediaTrack
:
:
AddAudioOutputImpl
(
void
*
aKey
)
{
LOG
(
LogLevel
:
:
Info
(
"
MediaTrack
%
p
adding
AudioOutput
"
this
)
)
;
GraphImpl
(
)
-
>
RegisterAudioOutput
(
this
aKey
)
;
}
void
MediaTrack
:
:
RemoveAudioOutputImpl
(
void
*
aKey
)
{
LOG
(
LogLevel
:
:
Info
(
"
MediaTrack
%
p
removing
AudioOutput
"
this
)
)
;
GraphImpl
(
)
-
>
UnregisterAudioOutput
(
this
aKey
)
;
}
void
MediaTrack
:
:
RemoveAudioOutput
(
void
*
aKey
)
{
class
Message
:
public
ControlMessage
{
public
:
explicit
Message
(
MediaTrack
*
aTrack
void
*
aKey
)
:
ControlMessage
(
aTrack
)
mKey
(
aKey
)
{
}
void
Run
(
)
override
{
mTrack
-
>
RemoveAudioOutputImpl
(
mKey
)
;
}
void
*
mKey
;
}
;
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
aKey
)
)
;
}
void
MediaTrack
:
:
Suspend
(
)
{
class
Message
:
public
ControlMessage
{
public
:
explicit
Message
(
MediaTrack
*
aTrack
)
:
ControlMessage
(
aTrack
)
{
}
void
Run
(
)
override
{
mTrack
-
>
GraphImpl
(
)
-
>
IncrementSuspendCount
(
mTrack
)
;
}
}
;
if
(
mMainThreadDestroyed
)
{
return
;
}
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
)
)
;
}
void
MediaTrack
:
:
Resume
(
)
{
class
Message
:
public
ControlMessage
{
public
:
explicit
Message
(
MediaTrack
*
aTrack
)
:
ControlMessage
(
aTrack
)
{
}
void
Run
(
)
override
{
mTrack
-
>
GraphImpl
(
)
-
>
DecrementSuspendCount
(
mTrack
)
;
}
}
;
if
(
mMainThreadDestroyed
)
{
return
;
}
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
)
)
;
}
void
MediaTrack
:
:
AddListenerImpl
(
already_AddRefed
<
MediaTrackListener
>
aListener
)
{
RefPtr
<
MediaTrackListener
>
l
(
aListener
)
;
mTrackListeners
.
AppendElement
(
std
:
:
move
(
l
)
)
;
PrincipalHandle
lastPrincipalHandle
=
mSegment
-
>
GetLastPrincipalHandle
(
)
;
mTrackListeners
.
LastElement
(
)
-
>
NotifyPrincipalHandleChanged
(
Graph
(
)
lastPrincipalHandle
)
;
if
(
mNotifiedEnded
)
{
mTrackListeners
.
LastElement
(
)
-
>
NotifyEnded
(
Graph
(
)
)
;
}
if
(
mDisabledMode
=
=
DisabledTrackMode
:
:
SILENCE_BLACK
)
{
mTrackListeners
.
LastElement
(
)
-
>
NotifyEnabledStateChanged
(
Graph
(
)
false
)
;
}
}
void
MediaTrack
:
:
AddListener
(
MediaTrackListener
*
aListener
)
{
class
Message
:
public
ControlMessage
{
public
:
Message
(
MediaTrack
*
aTrack
MediaTrackListener
*
aListener
)
:
ControlMessage
(
aTrack
)
mListener
(
aListener
)
{
}
void
Run
(
)
override
{
mTrack
-
>
AddListenerImpl
(
mListener
.
forget
(
)
)
;
}
RefPtr
<
MediaTrackListener
>
mListener
;
}
;
MOZ_ASSERT
(
mSegment
"
Segment
-
less
tracks
do
not
support
listeners
"
)
;
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
aListener
)
)
;
}
void
MediaTrack
:
:
RemoveListenerImpl
(
MediaTrackListener
*
aListener
)
{
for
(
size_t
i
=
0
;
i
<
mTrackListeners
.
Length
(
)
;
+
+
i
)
{
if
(
mTrackListeners
[
i
]
=
=
aListener
)
{
mTrackListeners
[
i
]
-
>
NotifyRemoved
(
Graph
(
)
)
;
mTrackListeners
.
RemoveElementAt
(
i
)
;
return
;
}
}
}
void
MediaTrack
:
:
RemoveListener
(
MediaTrackListener
*
aListener
)
{
class
Message
:
public
ControlMessage
{
public
:
Message
(
MediaTrack
*
aTrack
MediaTrackListener
*
aListener
)
:
ControlMessage
(
aTrack
)
mListener
(
aListener
)
{
}
void
Run
(
)
override
{
mTrack
-
>
RemoveListenerImpl
(
mListener
)
;
}
void
RunDuringShutdown
(
)
override
{
Run
(
)
;
}
RefPtr
<
MediaTrackListener
>
mListener
;
}
;
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
aListener
)
)
;
}
void
MediaTrack
:
:
AddDirectListenerImpl
(
already_AddRefed
<
DirectMediaTrackListener
>
aListener
)
{
RefPtr
<
DirectMediaTrackListener
>
listener
=
aListener
;
listener
-
>
NotifyDirectListenerInstalled
(
DirectMediaTrackListener
:
:
InstallationResult
:
:
TRACK_NOT_SUPPORTED
)
;
}
void
MediaTrack
:
:
AddDirectListener
(
DirectMediaTrackListener
*
aListener
)
{
class
Message
:
public
ControlMessage
{
public
:
Message
(
MediaTrack
*
aTrack
DirectMediaTrackListener
*
aListener
)
:
ControlMessage
(
aTrack
)
mListener
(
aListener
)
{
}
void
Run
(
)
override
{
mTrack
-
>
AddDirectListenerImpl
(
mListener
.
forget
(
)
)
;
}
RefPtr
<
DirectMediaTrackListener
>
mListener
;
}
;
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
aListener
)
)
;
}
void
MediaTrack
:
:
RemoveDirectListenerImpl
(
DirectMediaTrackListener
*
aListener
)
{
}
void
MediaTrack
:
:
RemoveDirectListener
(
DirectMediaTrackListener
*
aListener
)
{
class
Message
:
public
ControlMessage
{
public
:
Message
(
MediaTrack
*
aTrack
DirectMediaTrackListener
*
aListener
)
:
ControlMessage
(
aTrack
)
mListener
(
aListener
)
{
}
void
Run
(
)
override
{
mTrack
-
>
RemoveDirectListenerImpl
(
mListener
)
;
}
void
RunDuringShutdown
(
)
override
{
Run
(
)
;
}
RefPtr
<
DirectMediaTrackListener
>
mListener
;
}
;
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
aListener
)
)
;
}
void
MediaTrack
:
:
RunAfterPendingUpdates
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MediaTrackGraphImpl
*
graph
=
GraphImpl
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
class
Message
:
public
ControlMessage
{
public
:
Message
(
MediaTrack
*
aTrack
already_AddRefed
<
nsIRunnable
>
aRunnable
)
:
ControlMessage
(
aTrack
)
mRunnable
(
aRunnable
)
{
}
void
Run
(
)
override
{
mTrack
-
>
Graph
(
)
-
>
DispatchToMainThreadStableState
(
mRunnable
.
forget
(
)
)
;
}
void
RunDuringShutdown
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mTrack
-
>
GraphImpl
(
)
-
>
Dispatch
(
mRunnable
.
forget
(
)
)
;
}
private
:
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
}
;
graph
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
runnable
.
forget
(
)
)
)
;
}
void
MediaTrack
:
:
SetEnabledImpl
(
DisabledTrackMode
aMode
)
{
if
(
aMode
=
=
DisabledTrackMode
:
:
ENABLED
)
{
mDisabledMode
=
DisabledTrackMode
:
:
ENABLED
;
for
(
const
auto
&
l
:
mTrackListeners
)
{
l
-
>
NotifyEnabledStateChanged
(
Graph
(
)
true
)
;
}
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
mDisabledMode
=
=
DisabledTrackMode
:
:
ENABLED
"
Changing
disabled
track
mode
for
a
track
is
not
allowed
"
)
;
mDisabledMode
=
aMode
;
if
(
aMode
=
=
DisabledTrackMode
:
:
SILENCE_BLACK
)
{
for
(
const
auto
&
l
:
mTrackListeners
)
{
l
-
>
NotifyEnabledStateChanged
(
Graph
(
)
false
)
;
}
}
}
}
void
MediaTrack
:
:
SetEnabled
(
DisabledTrackMode
aMode
)
{
class
Message
:
public
ControlMessage
{
public
:
Message
(
MediaTrack
*
aTrack
DisabledTrackMode
aMode
)
:
ControlMessage
(
aTrack
)
mMode
(
aMode
)
{
}
void
Run
(
)
override
{
mTrack
-
>
SetEnabledImpl
(
mMode
)
;
}
DisabledTrackMode
mMode
;
}
;
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
aMode
)
)
;
}
void
MediaTrack
:
:
ApplyTrackDisabling
(
MediaSegment
*
aSegment
MediaSegment
*
aRawSegment
)
{
if
(
mDisabledMode
=
=
DisabledTrackMode
:
:
ENABLED
)
{
return
;
}
if
(
mDisabledMode
=
=
DisabledTrackMode
:
:
SILENCE_BLACK
)
{
aSegment
-
>
ReplaceWithDisabled
(
)
;
if
(
aRawSegment
)
{
aRawSegment
-
>
ReplaceWithDisabled
(
)
;
}
}
else
if
(
mDisabledMode
=
=
DisabledTrackMode
:
:
SILENCE_FREEZE
)
{
aSegment
-
>
ReplaceWithNull
(
)
;
if
(
aRawSegment
)
{
aRawSegment
-
>
ReplaceWithNull
(
)
;
}
}
else
{
MOZ_CRASH
(
"
Unsupported
mode
"
)
;
}
}
void
MediaTrack
:
:
AddMainThreadListener
(
MainThreadMediaTrackListener
*
aListener
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aListener
)
;
MOZ_ASSERT
(
!
mMainThreadListeners
.
Contains
(
aListener
)
)
;
mMainThreadListeners
.
AppendElement
(
aListener
)
;
if
(
!
mEndedNotificationSent
)
{
return
;
}
class
NotifyRunnable
final
:
public
Runnable
{
public
:
explicit
NotifyRunnable
(
MediaTrack
*
aTrack
)
:
Runnable
(
"
MediaTrack
:
:
NotifyRunnable
"
)
mTrack
(
aTrack
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mTrack
-
>
NotifyMainThreadListeners
(
)
;
return
NS_OK
;
}
private
:
~
NotifyRunnable
(
)
{
}
RefPtr
<
MediaTrack
>
mTrack
;
}
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
NotifyRunnable
(
this
)
;
GraphImpl
(
)
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
}
void
MediaTrack
:
:
AdvanceTimeVaryingValuesToCurrentTime
(
GraphTime
aCurrentTime
GraphTime
aBlockedTime
)
{
mStartTime
+
=
aBlockedTime
;
if
(
!
mSegment
)
{
return
;
}
TrackTime
time
=
aCurrentTime
-
mStartTime
;
const
TrackTime
minChunkSize
=
2400
;
if
(
time
<
mForgottenTime
+
minChunkSize
)
{
return
;
}
mForgottenTime
=
std
:
:
min
(
GetEnd
(
)
-
1
time
)
;
mSegment
-
>
ForgetUpTo
(
mForgottenTime
)
;
}
SourceMediaTrack
:
:
SourceMediaTrack
(
MediaSegment
:
:
Type
aType
TrackRate
aSampleRate
)
:
MediaTrack
(
aSampleRate
aType
aType
=
=
MediaSegment
:
:
AUDIO
?
static_cast
<
MediaSegment
*
>
(
new
AudioSegment
(
)
)
:
static_cast
<
MediaSegment
*
>
(
new
VideoSegment
(
)
)
)
mMutex
(
"
mozilla
:
:
media
:
:
SourceMediaTrack
"
)
{
mUpdateTrack
=
MakeUnique
<
TrackData
>
(
)
;
mUpdateTrack
-
>
mInputRate
=
aSampleRate
;
mUpdateTrack
-
>
mResamplerChannelCount
=
0
;
mUpdateTrack
-
>
mData
=
UniquePtr
<
MediaSegment
>
(
mSegment
-
>
CreateEmptyClone
(
)
)
;
mUpdateTrack
-
>
mEnded
=
false
;
mUpdateTrack
-
>
mPullingEnabled
=
false
;
}
nsresult
SourceMediaTrack
:
:
OpenAudioInput
(
CubebUtils
:
:
AudioDeviceID
aID
AudioDataListener
*
aListener
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
GraphImpl
(
)
)
;
MOZ_ASSERT
(
!
mInputListener
)
;
mInputListener
=
aListener
;
return
GraphImpl
(
)
-
>
OpenAudioInput
(
aID
aListener
)
;
}
void
SourceMediaTrack
:
:
CloseAudioInput
(
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
&
aID
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
GraphImpl
(
)
)
;
if
(
!
mInputListener
)
{
return
;
}
GraphImpl
(
)
-
>
CloseAudioInput
(
aID
mInputListener
)
;
mInputListener
=
nullptr
;
}
void
SourceMediaTrack
:
:
Destroy
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
id
=
Nothing
(
)
;
CloseAudioInput
(
id
)
;
MediaTrack
:
:
Destroy
(
)
;
}
void
SourceMediaTrack
:
:
DestroyImpl
(
)
{
GraphImpl
(
)
-
>
AssertOnGraphThreadOrNotRunning
(
)
;
for
(
int32_t
i
=
mConsumers
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
mConsumers
[
i
]
-
>
Disconnect
(
)
;
}
MutexAutoLock
lock
(
mMutex
)
;
mUpdateTrack
=
nullptr
;
MediaTrack
:
:
DestroyImpl
(
)
;
}
void
SourceMediaTrack
:
:
SetPullingEnabled
(
bool
aEnabled
)
{
class
Message
:
public
ControlMessage
{
public
:
Message
(
SourceMediaTrack
*
aTrack
bool
aEnabled
)
:
ControlMessage
(
nullptr
)
mTrack
(
aTrack
)
mEnabled
(
aEnabled
)
{
}
void
Run
(
)
override
{
MutexAutoLock
lock
(
mTrack
-
>
mMutex
)
;
if
(
!
mTrack
-
>
mUpdateTrack
)
{
MOZ_ASSERT_IF
(
mEnabled
mTrack
-
>
mEnded
)
;
return
;
}
MOZ_ASSERT
(
mTrack
-
>
mType
=
=
MediaSegment
:
:
AUDIO
"
Pulling
is
not
allowed
for
video
"
)
;
mTrack
-
>
mUpdateTrack
-
>
mPullingEnabled
=
mEnabled
;
}
SourceMediaTrack
*
mTrack
;
bool
mEnabled
;
}
;
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
aEnabled
)
)
;
}
bool
SourceMediaTrack
:
:
PullNewData
(
GraphTime
aDesiredUpToTime
)
{
TRACE_AUDIO_CALLBACK_COMMENT
(
"
SourceMediaTrack
%
p
"
this
)
;
TrackTime
t
;
TrackTime
current
;
{
if
(
mEnded
)
{
return
false
;
}
MutexAutoLock
lock
(
mMutex
)
;
if
(
mUpdateTrack
-
>
mEnded
)
{
return
false
;
}
if
(
!
mUpdateTrack
-
>
mPullingEnabled
)
{
return
false
;
}
t
=
GraphTimeToTrackTime
(
aDesiredUpToTime
)
;
current
=
GetEnd
(
)
+
mUpdateTrack
-
>
mData
-
>
GetDuration
(
)
;
}
if
(
t
<
=
current
)
{
return
false
;
}
LOG
(
LogLevel
:
:
Verbose
(
"
%
p
:
Calling
NotifyPull
track
=
%
p
t
=
%
f
current
end
=
%
f
"
GraphImpl
(
)
this
GraphImpl
(
)
-
>
MediaTimeToSeconds
(
t
)
GraphImpl
(
)
-
>
MediaTimeToSeconds
(
current
)
)
)
;
for
(
auto
&
l
:
mTrackListeners
)
{
l
-
>
NotifyPull
(
Graph
(
)
current
t
)
;
}
return
true
;
}
static
void
MoveToSegment
(
SourceMediaTrack
*
aTrack
MediaSegment
*
aIn
MediaSegment
*
aOut
TrackTime
aCurrentTime
TrackTime
aDesiredUpToTime
)
{
MOZ_ASSERT
(
aIn
-
>
GetType
(
)
=
=
aOut
-
>
GetType
(
)
)
;
MOZ_ASSERT
(
aOut
-
>
GetDuration
(
)
>
=
aCurrentTime
)
;
if
(
aIn
-
>
GetType
(
)
=
=
MediaSegment
:
:
AUDIO
)
{
aOut
-
>
AppendFrom
(
aIn
)
;
}
else
{
VideoSegment
*
in
=
static_cast
<
VideoSegment
*
>
(
aIn
)
;
VideoSegment
*
out
=
static_cast
<
VideoSegment
*
>
(
aOut
)
;
for
(
VideoSegment
:
:
ConstChunkIterator
c
(
*
in
)
;
!
c
.
IsEnded
(
)
;
c
.
Next
(
)
)
{
MOZ_ASSERT
(
!
c
-
>
mTimeStamp
.
IsNull
(
)
)
;
VideoChunk
*
last
=
out
-
>
GetLastChunk
(
)
;
if
(
!
last
|
|
last
-
>
mTimeStamp
.
IsNull
(
)
)
{
out
-
>
AppendFrame
(
do_AddRef
(
c
-
>
mFrame
.
GetImage
(
)
)
c
-
>
mFrame
.
GetIntrinsicSize
(
)
c
-
>
mFrame
.
GetPrincipalHandle
(
)
c
-
>
mFrame
.
GetForceBlack
(
)
c
-
>
mTimeStamp
)
;
if
(
c
-
>
GetDuration
(
)
>
0
)
{
out
-
>
ExtendLastFrameBy
(
c
-
>
GetDuration
(
)
)
;
}
continue
;
}
if
(
c
-
>
mTimeStamp
<
last
-
>
mTimeStamp
)
{
out
-
>
Clear
(
)
;
out
-
>
AppendNullData
(
aCurrentTime
)
;
}
out
-
>
AppendFrame
(
do_AddRef
(
c
-
>
mFrame
.
GetImage
(
)
)
c
-
>
mFrame
.
GetIntrinsicSize
(
)
c
-
>
mFrame
.
GetPrincipalHandle
(
)
c
-
>
mFrame
.
GetForceBlack
(
)
c
-
>
mTimeStamp
)
;
if
(
c
-
>
GetDuration
(
)
>
0
)
{
out
-
>
ExtendLastFrameBy
(
c
-
>
GetDuration
(
)
)
;
}
}
if
(
out
-
>
GetDuration
(
)
<
aDesiredUpToTime
)
{
out
-
>
ExtendLastFrameBy
(
aDesiredUpToTime
-
out
-
>
GetDuration
(
)
)
;
}
in
-
>
Clear
(
)
;
}
MOZ_ASSERT
(
aIn
-
>
GetDuration
(
)
=
=
0
"
aIn
must
be
consumed
"
)
;
}
void
SourceMediaTrack
:
:
ExtractPendingInput
(
GraphTime
aCurrentTime
GraphTime
aDesiredUpToTime
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mUpdateTrack
)
{
MOZ_ASSERT
(
mEnded
)
;
return
;
}
TrackTime
trackCurrentTime
=
GraphTimeToTrackTime
(
aCurrentTime
)
;
ApplyTrackDisabling
(
mUpdateTrack
-
>
mData
.
get
(
)
)
;
if
(
!
mUpdateTrack
-
>
mData
-
>
IsEmpty
(
)
)
{
for
(
const
auto
&
l
:
mTrackListeners
)
{
l
-
>
NotifyQueuedChanges
(
GraphImpl
(
)
GetEnd
(
)
*
mUpdateTrack
-
>
mData
)
;
}
}
TrackTime
trackDesiredUpToTime
=
GraphTimeToTrackTime
(
aDesiredUpToTime
)
;
TrackTime
endTime
=
trackDesiredUpToTime
;
if
(
mUpdateTrack
-
>
mEnded
)
{
endTime
=
std
:
:
min
(
trackDesiredUpToTime
GetEnd
(
)
+
mUpdateTrack
-
>
mData
-
>
GetDuration
(
)
)
;
}
LOG
(
LogLevel
:
:
Verbose
(
"
%
p
:
SourceMediaTrack
%
p
advancing
end
from
%
"
PRId64
"
to
%
"
PRId64
GraphImpl
(
)
this
int64_t
(
trackCurrentTime
)
int64_t
(
endTime
)
)
)
;
MoveToSegment
(
this
mUpdateTrack
-
>
mData
.
get
(
)
mSegment
.
get
(
)
trackCurrentTime
endTime
)
;
if
(
mUpdateTrack
-
>
mEnded
&
&
GetEnd
(
)
<
trackDesiredUpToTime
)
{
mEnded
=
true
;
mUpdateTrack
=
nullptr
;
}
}
void
SourceMediaTrack
:
:
ResampleAudioToGraphSampleRate
(
MediaSegment
*
aSegment
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
aSegment
-
>
GetType
(
)
!
=
MediaSegment
:
:
AUDIO
|
|
mUpdateTrack
-
>
mInputRate
=
=
GraphImpl
(
)
-
>
GraphRate
(
)
)
{
return
;
}
AudioSegment
*
segment
=
static_cast
<
AudioSegment
*
>
(
aSegment
)
;
segment
-
>
ResampleChunks
(
mUpdateTrack
-
>
mResampler
&
mUpdateTrack
-
>
mResamplerChannelCount
mUpdateTrack
-
>
mInputRate
GraphImpl
(
)
-
>
GraphRate
(
)
)
;
}
void
SourceMediaTrack
:
:
AdvanceTimeVaryingValuesToCurrentTime
(
GraphTime
aCurrentTime
GraphTime
aBlockedTime
)
{
MutexAutoLock
lock
(
mMutex
)
;
MediaTrack
:
:
AdvanceTimeVaryingValuesToCurrentTime
(
aCurrentTime
aBlockedTime
)
;
}
void
SourceMediaTrack
:
:
SetAppendDataSourceRate
(
TrackRate
aRate
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mUpdateTrack
)
{
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mSegment
-
>
GetType
(
)
=
=
MediaSegment
:
:
AUDIO
)
;
mUpdateTrack
-
>
mInputRate
=
aRate
;
mUpdateTrack
-
>
mResampler
.
own
(
nullptr
)
;
mUpdateTrack
-
>
mResamplerChannelCount
=
0
;
}
TrackTime
SourceMediaTrack
:
:
AppendData
(
MediaSegment
*
aSegment
MediaSegment
*
aRawSegment
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aSegment
-
>
GetType
(
)
=
=
mType
)
;
TrackTime
appended
=
0
;
auto
graph
=
GraphImpl
(
)
;
if
(
!
mUpdateTrack
|
|
mUpdateTrack
-
>
mEnded
|
|
!
graph
)
{
aSegment
-
>
Clear
(
)
;
return
appended
;
}
ApplyTrackDisabling
(
aSegment
aRawSegment
)
;
ResampleAudioToGraphSampleRate
(
aSegment
)
;
NotifyDirectConsumers
(
aRawSegment
?
aRawSegment
:
aSegment
)
;
appended
=
aSegment
-
>
GetDuration
(
)
;
mUpdateTrack
-
>
mData
-
>
AppendFrom
(
aSegment
)
;
graph
-
>
EnsureNextIteration
(
)
;
return
appended
;
}
void
SourceMediaTrack
:
:
NotifyDirectConsumers
(
MediaSegment
*
aSegment
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
for
(
const
auto
&
l
:
mDirectTrackListeners
)
{
TrackTime
offset
=
0
;
l
-
>
NotifyRealtimeTrackDataAndApplyTrackDisabling
(
Graph
(
)
offset
*
aSegment
)
;
}
}
void
SourceMediaTrack
:
:
AddDirectListenerImpl
(
already_AddRefed
<
DirectMediaTrackListener
>
aListener
)
{
MutexAutoLock
lock
(
mMutex
)
;
RefPtr
<
DirectMediaTrackListener
>
listener
=
aListener
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
Adding
direct
track
listener
%
p
to
source
track
%
p
"
GraphImpl
(
)
listener
.
get
(
)
this
)
)
;
MOZ_ASSERT
(
mType
=
=
MediaSegment
:
:
VIDEO
)
;
for
(
const
auto
&
l
:
mDirectTrackListeners
)
{
if
(
l
=
=
listener
)
{
listener
-
>
NotifyDirectListenerInstalled
(
DirectMediaTrackListener
:
:
InstallationResult
:
:
ALREADY_EXISTS
)
;
return
;
}
}
mDirectTrackListeners
.
AppendElement
(
listener
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
Added
direct
track
listener
%
p
"
GraphImpl
(
)
listener
.
get
(
)
)
)
;
listener
-
>
NotifyDirectListenerInstalled
(
DirectMediaTrackListener
:
:
InstallationResult
:
:
SUCCESS
)
;
if
(
mEnded
)
{
return
;
}
VideoSegment
bufferedData
;
size_t
videoFrames
=
0
;
VideoSegment
&
segment
=
*
GetData
<
VideoSegment
>
(
)
;
for
(
VideoSegment
:
:
ConstChunkIterator
iter
(
segment
)
;
!
iter
.
IsEnded
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
-
>
mTimeStamp
.
IsNull
(
)
)
{
continue
;
}
+
+
videoFrames
;
bufferedData
.
AppendFrame
(
do_AddRef
(
iter
-
>
mFrame
.
GetImage
(
)
)
iter
-
>
mFrame
.
GetIntrinsicSize
(
)
iter
-
>
mFrame
.
GetPrincipalHandle
(
)
iter
-
>
mFrame
.
GetForceBlack
(
)
iter
-
>
mTimeStamp
)
;
}
VideoSegment
&
video
=
static_cast
<
VideoSegment
&
>
(
*
mUpdateTrack
-
>
mData
)
;
for
(
VideoSegment
:
:
ConstChunkIterator
iter
(
video
)
;
!
iter
.
IsEnded
(
)
;
iter
.
Next
(
)
)
{
+
+
videoFrames
;
MOZ_ASSERT
(
!
iter
-
>
mTimeStamp
.
IsNull
(
)
)
;
bufferedData
.
AppendFrame
(
do_AddRef
(
iter
-
>
mFrame
.
GetImage
(
)
)
iter
-
>
mFrame
.
GetIntrinsicSize
(
)
iter
-
>
mFrame
.
GetPrincipalHandle
(
)
iter
-
>
mFrame
.
GetForceBlack
(
)
iter
-
>
mTimeStamp
)
;
}
LOG
(
LogLevel
:
:
Info
(
"
%
p
:
Notifying
direct
listener
%
p
of
%
zu
video
frames
and
duration
"
"
%
"
PRId64
GraphImpl
(
)
listener
.
get
(
)
videoFrames
bufferedData
.
GetDuration
(
)
)
)
;
listener
-
>
NotifyRealtimeTrackData
(
Graph
(
)
0
bufferedData
)
;
}
void
SourceMediaTrack
:
:
RemoveDirectListenerImpl
(
DirectMediaTrackListener
*
aListener
)
{
MutexAutoLock
lock
(
mMutex
)
;
for
(
int32_t
i
=
mDirectTrackListeners
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
const
RefPtr
<
DirectMediaTrackListener
>
&
l
=
mDirectTrackListeners
[
i
]
;
if
(
l
=
=
aListener
)
{
aListener
-
>
NotifyDirectListenerUninstalled
(
)
;
mDirectTrackListeners
.
RemoveElementAt
(
i
)
;
}
}
}
void
SourceMediaTrack
:
:
End
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mUpdateTrack
)
{
return
;
}
mUpdateTrack
-
>
mEnded
=
true
;
if
(
auto
graph
=
GraphImpl
(
)
)
{
graph
-
>
EnsureNextIteration
(
)
;
}
}
void
SourceMediaTrack
:
:
SetEnabledImpl
(
DisabledTrackMode
aMode
)
{
{
MutexAutoLock
lock
(
mMutex
)
;
for
(
const
auto
&
l
:
mDirectTrackListeners
)
{
DisabledTrackMode
oldMode
=
mDisabledMode
;
bool
oldEnabled
=
oldMode
=
=
DisabledTrackMode
:
:
ENABLED
;
if
(
!
oldEnabled
&
&
aMode
=
=
DisabledTrackMode
:
:
ENABLED
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
SourceMediaTrack
%
p
setting
"
"
direct
listener
enabled
"
GraphImpl
(
)
this
)
)
;
l
-
>
DecreaseDisabled
(
oldMode
)
;
}
else
if
(
oldEnabled
&
&
aMode
!
=
DisabledTrackMode
:
:
ENABLED
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
SourceMediaTrack
%
p
setting
"
"
direct
listener
disabled
"
GraphImpl
(
)
this
)
)
;
l
-
>
IncreaseDisabled
(
aMode
)
;
}
}
}
MediaTrack
:
:
SetEnabledImpl
(
aMode
)
;
}
void
SourceMediaTrack
:
:
RemoveAllDirectListenersImpl
(
)
{
GraphImpl
(
)
-
>
AssertOnGraphThreadOrNotRunning
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
auto
directListeners
(
mDirectTrackListeners
)
;
for
(
auto
&
l
:
directListeners
)
{
l
-
>
NotifyDirectListenerUninstalled
(
)
;
}
mDirectTrackListeners
.
Clear
(
)
;
}
SourceMediaTrack
:
:
~
SourceMediaTrack
(
)
{
}
void
MediaInputPort
:
:
Init
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
:
Adding
MediaInputPort
%
p
(
from
%
p
to
%
p
)
"
mSource
-
>
GraphImpl
(
)
this
mSource
mDest
)
)
;
if
(
mSource
)
{
mSource
-
>
AddConsumer
(
this
)
;
mDest
-
>
AddInput
(
this
)
;
}
+
+
mGraph
-
>
mPortCount
;
}
void
MediaInputPort
:
:
Disconnect
(
)
{
GraphImpl
(
)
-
>
AssertOnGraphThreadOrNotRunning
(
)
;
NS_ASSERTION
(
!
mSource
=
=
!
mDest
"
mSource
must
either
both
be
null
or
both
non
-
null
"
)
;
if
(
!
mSource
)
return
;
mSource
-
>
RemoveConsumer
(
this
)
;
mDest
-
>
RemoveInput
(
this
)
;
mSource
=
nullptr
;
mDest
=
nullptr
;
GraphImpl
(
)
-
>
SetTrackOrderDirty
(
)
;
}
MediaInputPort
:
:
InputInterval
MediaInputPort
:
:
GetNextInputInterval
(
MediaInputPort
const
*
aPort
GraphTime
aTime
)
{
InputInterval
result
=
{
GRAPH_TIME_MAX
GRAPH_TIME_MAX
false
}
;
if
(
!
aPort
)
{
result
.
mStart
=
aTime
;
result
.
mInputIsBlocked
=
true
;
return
result
;
}
if
(
aTime
>
=
aPort
-
>
mDest
-
>
mStartBlocking
)
{
return
result
;
}
result
.
mStart
=
aTime
;
result
.
mEnd
=
aPort
-
>
mDest
-
>
mStartBlocking
;
result
.
mInputIsBlocked
=
aTime
>
=
aPort
-
>
mSource
-
>
mStartBlocking
;
if
(
!
result
.
mInputIsBlocked
)
{
result
.
mEnd
=
std
:
:
min
(
result
.
mEnd
aPort
-
>
mSource
-
>
mStartBlocking
)
;
}
return
result
;
}
void
MediaInputPort
:
:
Suspended
(
)
{
mDest
-
>
InputSuspended
(
this
)
;
}
void
MediaInputPort
:
:
Resumed
(
)
{
mDest
-
>
InputResumed
(
this
)
;
}
void
MediaInputPort
:
:
Destroy
(
)
{
class
Message
:
public
ControlMessage
{
public
:
explicit
Message
(
MediaInputPort
*
aPort
)
:
ControlMessage
(
nullptr
)
mPort
(
aPort
)
{
}
void
Run
(
)
override
{
mPort
-
>
Disconnect
(
)
;
-
-
mPort
-
>
GraphImpl
(
)
-
>
mPortCount
;
mPort
-
>
SetGraphImpl
(
nullptr
)
;
NS_RELEASE
(
mPort
)
;
}
void
RunDuringShutdown
(
)
override
{
Run
(
)
;
}
MediaInputPort
*
mPort
;
}
;
RefPtr
<
MediaTrackGraphImpl
>
graph
=
GraphImpl
(
)
;
graph
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
)
)
;
-
-
graph
-
>
mMainThreadPortCount
;
}
MediaTrackGraphImpl
*
MediaInputPort
:
:
GraphImpl
(
)
{
return
mGraph
;
}
MediaTrackGraph
*
MediaInputPort
:
:
Graph
(
)
{
return
mGraph
;
}
void
MediaInputPort
:
:
SetGraphImpl
(
MediaTrackGraphImpl
*
aGraph
)
{
MOZ_ASSERT
(
!
mGraph
|
|
!
aGraph
"
Should
only
be
set
once
"
)
;
mGraph
=
aGraph
;
}
already_AddRefed
<
MediaInputPort
>
ProcessedMediaTrack
:
:
AllocateInputPort
(
MediaTrack
*
aTrack
uint16_t
aInputNumber
uint16_t
aOutputNumber
)
{
class
Message
:
public
ControlMessage
{
public
:
explicit
Message
(
MediaInputPort
*
aPort
)
:
ControlMessage
(
aPort
-
>
GetDestination
(
)
)
mPort
(
aPort
)
{
}
void
Run
(
)
override
{
mPort
-
>
Init
(
)
;
mPort
-
>
GraphImpl
(
)
-
>
SetTrackOrderDirty
(
)
;
Unused
<
<
mPort
.
forget
(
)
;
}
void
RunDuringShutdown
(
)
override
{
Run
(
)
;
}
RefPtr
<
MediaInputPort
>
mPort
;
}
;
MOZ_DIAGNOSTIC_ASSERT
(
aTrack
-
>
mType
=
=
mType
)
;
RefPtr
<
MediaInputPort
>
port
;
if
(
aTrack
-
>
IsDestroyed
(
)
)
{
port
=
new
MediaInputPort
(
nullptr
nullptr
aInputNumber
aOutputNumber
)
;
}
else
{
MOZ_ASSERT
(
aTrack
-
>
GraphImpl
(
)
=
=
GraphImpl
(
)
)
;
port
=
new
MediaInputPort
(
aTrack
this
aInputNumber
aOutputNumber
)
;
}
port
-
>
SetGraphImpl
(
GraphImpl
(
)
)
;
+
+
GraphImpl
(
)
-
>
mMainThreadPortCount
;
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
port
)
)
;
return
port
.
forget
(
)
;
}
void
ProcessedMediaTrack
:
:
QueueSetAutoend
(
bool
aAutoend
)
{
class
Message
:
public
ControlMessage
{
public
:
Message
(
ProcessedMediaTrack
*
aTrack
bool
aAutoend
)
:
ControlMessage
(
aTrack
)
mAutoend
(
aAutoend
)
{
}
void
Run
(
)
override
{
static_cast
<
ProcessedMediaTrack
*
>
(
mTrack
)
-
>
SetAutoendImpl
(
mAutoend
)
;
}
bool
mAutoend
;
}
;
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
aAutoend
)
)
;
}
void
ProcessedMediaTrack
:
:
DestroyImpl
(
)
{
for
(
int32_t
i
=
mInputs
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
mInputs
[
i
]
-
>
Disconnect
(
)
;
}
for
(
int32_t
i
=
mSuspendedInputs
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
mSuspendedInputs
[
i
]
-
>
Disconnect
(
)
;
}
MediaTrack
:
:
DestroyImpl
(
)
;
}
MediaTrackGraphImpl
:
:
MediaTrackGraphImpl
(
GraphDriverType
aDriverRequested
GraphRunType
aRunTypeRequested
TrackRate
aSampleRate
uint32_t
aChannelCount
AbstractThread
*
aMainThread
)
:
MediaTrackGraph
(
aSampleRate
)
mGraphRunner
(
aRunTypeRequested
=
=
SINGLE_THREAD
?
GraphRunner
:
:
Create
(
this
)
:
already_AddRefed
<
GraphRunner
>
(
nullptr
)
)
mFirstCycleBreaker
(
0
)
mEndTime
(
aDriverRequested
=
=
OFFLINE_THREAD_DRIVER
?
0
:
GRAPH_TIME_MAX
)
mPortCount
(
0
)
mInputDeviceID
(
nullptr
)
mOutputDeviceID
(
nullptr
)
mNeedAnotherIteration
(
false
)
mGraphDriverAsleep
(
false
)
mMonitor
(
"
MediaTrackGraphImpl
"
)
mLifecycleState
(
LIFECYCLE_THREAD_NOT_STARTED
)
mForceShutDown
(
false
)
mPostedRunInStableStateEvent
(
false
)
mDetectedNotRunning
(
false
)
mPostedRunInStableState
(
false
)
mRealtime
(
aDriverRequested
!
=
OFFLINE_THREAD_DRIVER
)
mTrackOrderDirty
(
false
)
mAbstractMainThread
(
aMainThread
)
mSelfRef
(
this
)
mGlobalVolume
(
CubebUtils
:
:
GetVolumeScale
(
)
)
#
ifdef
DEBUG
mCanRunMessagesSynchronously
(
false
)
#
endif
mMainThreadGraphTime
(
0
"
MediaTrackGraphImpl
:
:
mMainThreadGraphTime
"
)
mAudioOutputLatency
(
0
.
0
)
{
if
(
aRunTypeRequested
=
=
SINGLE_THREAD
&
&
!
mGraphRunner
)
{
mDetectedNotRunning
=
true
;
mLifecycleState
=
LIFECYCLE_WAITING_FOR_TRACK_DESTRUCTION
;
#
ifdef
DEBUG
mCanRunMessagesSynchronously
=
true
;
#
endif
return
;
}
if
(
mRealtime
)
{
if
(
aDriverRequested
=
=
AUDIO_THREAD_DRIVER
)
{
mDriver
=
new
AudioCallbackDriver
(
this
aChannelCount
0
AudioInputType
:
:
Unknown
)
;
}
else
{
mDriver
=
new
SystemClockDriver
(
this
)
;
}
}
else
{
mDriver
=
new
OfflineClockDriver
(
this
MEDIA_GRAPH_TARGET_PERIOD_MS
)
;
}
mLastMainThreadUpdate
=
TimeStamp
:
:
Now
(
)
;
StartAudioCallbackTracing
(
)
;
RegisterWeakAsyncMemoryReporter
(
this
)
;
if
(
!
IsNonRealtime
(
)
)
{
AddShutdownBlocker
(
)
;
}
}
AbstractThread
*
MediaTrackGraph
:
:
AbstractMainThread
(
)
{
MOZ_ASSERT
(
static_cast
<
MediaTrackGraphImpl
*
>
(
this
)
-
>
mAbstractMainThread
)
;
return
static_cast
<
MediaTrackGraphImpl
*
>
(
this
)
-
>
mAbstractMainThread
;
}
#
ifdef
DEBUG
bool
MediaTrackGraphImpl
:
:
RunByGraphDriver
(
GraphDriver
*
aDriver
)
{
return
aDriver
-
>
OnThread
(
)
|
|
(
mGraphRunner
&
&
mGraphRunner
-
>
RunByGraphDriver
(
aDriver
)
)
;
}
#
endif
void
MediaTrackGraphImpl
:
:
Destroy
(
)
{
UnregisterWeakMemoryReporter
(
this
)
;
mSelfRef
=
nullptr
;
}
static
uint32_t
WindowToHash
(
nsPIDOMWindowInner
*
aWindow
TrackRate
aSampleRate
)
{
uint32_t
hashkey
=
0
;
hashkey
=
AddToHash
(
hashkey
aWindow
)
;
hashkey
=
AddToHash
(
hashkey
aSampleRate
)
;
return
hashkey
;
}
MediaTrackGraph
*
MediaTrackGraph
:
:
GetInstanceIfExists
(
nsPIDOMWindowInner
*
aWindow
TrackRate
aSampleRate
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Main
thread
only
"
)
;
TrackRate
sampleRate
=
aSampleRate
?
aSampleRate
:
CubebUtils
:
:
PreferredSampleRate
(
)
;
uint32_t
hashkey
=
WindowToHash
(
aWindow
sampleRate
)
;
MediaTrackGraphImpl
*
graph
=
nullptr
;
gGraphs
.
Get
(
hashkey
&
graph
)
;
return
graph
;
}
MediaTrackGraph
*
MediaTrackGraph
:
:
GetInstance
(
MediaTrackGraph
:
:
GraphDriverType
aGraphDriverRequested
nsPIDOMWindowInner
*
aWindow
TrackRate
aSampleRate
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Main
thread
only
"
)
;
TrackRate
sampleRate
=
aSampleRate
?
aSampleRate
:
CubebUtils
:
:
PreferredSampleRate
(
)
;
MediaTrackGraphImpl
*
graph
=
static_cast
<
MediaTrackGraphImpl
*
>
(
GetInstanceIfExists
(
aWindow
sampleRate
)
)
;
if
(
!
graph
)
{
AbstractThread
*
mainThread
;
if
(
aWindow
)
{
mainThread
=
aWindow
-
>
AsGlobal
(
)
-
>
AbstractMainThreadFor
(
TaskCategory
:
:
Other
)
;
}
else
{
mainThread
=
AbstractThread
:
:
MainThread
(
)
;
}
GraphRunType
runType
=
DIRECT_DRIVER
;
if
(
aGraphDriverRequested
!
=
OFFLINE_THREAD_DRIVER
&
&
(
StaticPrefs
:
:
dom_audioworklet_enabled
(
)
|
|
Preferences
:
:
GetBool
(
"
media
.
audiograph
.
single_thread
.
enabled
"
false
)
)
)
{
runType
=
SINGLE_THREAD
;
}
uint32_t
channelCount
=
std
:
:
min
<
uint32_t
>
(
8
CubebUtils
:
:
MaxNumberOfChannels
(
)
)
;
graph
=
new
MediaTrackGraphImpl
(
aGraphDriverRequested
runType
sampleRate
channelCount
mainThread
)
;
uint32_t
hashkey
=
WindowToHash
(
aWindow
sampleRate
)
;
gGraphs
.
Put
(
hashkey
graph
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Starting
up
MediaTrackGraph
%
p
for
window
%
p
"
graph
aWindow
)
)
;
}
return
graph
;
}
MediaTrackGraph
*
MediaTrackGraph
:
:
CreateNonRealtimeInstance
(
TrackRate
aSampleRate
nsPIDOMWindowInner
*
aWindow
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Main
thread
only
"
)
;
AbstractThread
*
mainThread
=
AbstractThread
:
:
MainThread
(
)
;
if
(
aWindow
)
{
mainThread
=
aWindow
-
>
AsGlobal
(
)
-
>
AbstractMainThreadFor
(
TaskCategory
:
:
Other
)
;
}
MediaTrackGraphImpl
*
graph
=
new
MediaTrackGraphImpl
(
OFFLINE_THREAD_DRIVER
DIRECT_DRIVER
aSampleRate
0
mainThread
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Starting
up
Offline
MediaTrackGraph
%
p
"
graph
)
)
;
return
graph
;
}
void
MediaTrackGraph
:
:
DestroyNonRealtimeInstance
(
MediaTrackGraph
*
aGraph
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Main
thread
only
"
)
;
MOZ_ASSERT
(
aGraph
-
>
IsNonRealtime
(
)
"
Should
not
destroy
the
global
graph
here
"
)
;
MediaTrackGraphImpl
*
graph
=
static_cast
<
MediaTrackGraphImpl
*
>
(
aGraph
)
;
graph
-
>
ForceShutDown
(
)
;
}
NS_IMPL_ISUPPORTS
(
MediaTrackGraphImpl
nsIMemoryReporter
nsITimerCallback
nsINamed
)
NS_IMETHODIMP
MediaTrackGraphImpl
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mMainThreadTrackCount
=
=
0
)
{
FinishCollectReports
(
aHandleReport
aData
nsTArray
<
AudioNodeSizes
>
(
)
)
;
return
NS_OK
;
}
class
Message
final
:
public
ControlMessage
{
public
:
Message
(
MediaTrackGraphImpl
*
aGraph
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aHandlerData
)
:
ControlMessage
(
nullptr
)
mGraph
(
aGraph
)
mHandleReport
(
aHandleReport
)
mHandlerData
(
aHandlerData
)
{
}
void
Run
(
)
override
{
mGraph
-
>
CollectSizesForMemoryReport
(
mHandleReport
.
forget
(
)
mHandlerData
.
forget
(
)
)
;
}
void
RunDuringShutdown
(
)
override
{
Run
(
)
;
}
MediaTrackGraphImpl
*
mGraph
;
nsCOMPtr
<
nsIHandleReportCallback
>
mHandleReport
;
nsCOMPtr
<
nsISupports
>
mHandlerData
;
}
;
AppendMessage
(
MakeUnique
<
Message
>
(
this
aHandleReport
aData
)
)
;
return
NS_OK
;
}
void
MediaTrackGraphImpl
:
:
CollectSizesForMemoryReport
(
already_AddRefed
<
nsIHandleReportCallback
>
aHandleReport
already_AddRefed
<
nsISupports
>
aHandlerData
)
{
class
FinishCollectRunnable
final
:
public
Runnable
{
public
:
explicit
FinishCollectRunnable
(
already_AddRefed
<
nsIHandleReportCallback
>
aHandleReport
already_AddRefed
<
nsISupports
>
aHandlerData
)
:
mozilla
:
:
Runnable
(
"
FinishCollectRunnable
"
)
mHandleReport
(
aHandleReport
)
mHandlerData
(
aHandlerData
)
{
}
NS_IMETHOD
Run
(
)
override
{
MediaTrackGraphImpl
:
:
FinishCollectReports
(
mHandleReport
mHandlerData
std
:
:
move
(
mAudioTrackSizes
)
)
;
return
NS_OK
;
}
nsTArray
<
AudioNodeSizes
>
mAudioTrackSizes
;
private
:
~
FinishCollectRunnable
(
)
{
}
RefPtr
<
nsIHandleReportCallback
>
mHandleReport
;
RefPtr
<
nsISupports
>
mHandlerData
;
}
;
RefPtr
<
FinishCollectRunnable
>
runnable
=
new
FinishCollectRunnable
(
std
:
:
move
(
aHandleReport
)
std
:
:
move
(
aHandlerData
)
)
;
auto
audioTrackSizes
=
&
runnable
-
>
mAudioTrackSizes
;
for
(
MediaTrack
*
t
:
AllTracks
(
)
)
{
AudioNodeTrack
*
track
=
t
-
>
AsAudioNodeTrack
(
)
;
if
(
track
)
{
AudioNodeSizes
*
usage
=
audioTrackSizes
-
>
AppendElement
(
)
;
track
-
>
SizeOfAudioNodesIncludingThis
(
MallocSizeOf
*
usage
)
;
}
}
mAbstractMainThread
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
}
void
MediaTrackGraphImpl
:
:
FinishCollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
const
nsTArray
<
AudioNodeSizes
>
&
aAudioTrackSizes
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIMemoryReporterManager
>
manager
=
do_GetService
(
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
)
;
if
(
!
manager
)
return
;
#
define
REPORT
(
_path
_amount
_desc
)
\
aHandleReport
-
>
Callback
(
EmptyCString
(
)
_path
KIND_HEAP
UNITS_BYTES
\
_amount
NS_LITERAL_CSTRING
(
_desc
)
aData
)
;
for
(
size_t
i
=
0
;
i
<
aAudioTrackSizes
.
Length
(
)
;
i
+
+
)
{
const
AudioNodeSizes
&
usage
=
aAudioTrackSizes
[
i
]
;
const
char
*
const
nodeType
=
usage
.
mNodeType
?
usage
.
mNodeType
:
"
<
unknown
>
"
;
nsPrintfCString
enginePath
(
"
explicit
/
webaudio
/
audio
-
node
/
%
s
/
engine
-
objects
"
nodeType
)
;
REPORT
(
enginePath
usage
.
mEngine
"
Memory
used
by
AudioNode
engine
objects
(
Web
Audio
)
.
"
)
;
nsPrintfCString
trackPath
(
"
explicit
/
webaudio
/
audio
-
node
/
%
s
/
track
-
objects
"
nodeType
)
;
REPORT
(
trackPath
usage
.
mTrack
"
Memory
used
by
AudioNode
track
objects
(
Web
Audio
)
.
"
)
;
}
size_t
hrtfLoaders
=
WebCore
:
:
HRTFDatabaseLoader
:
:
sizeOfLoaders
(
MallocSizeOf
)
;
if
(
hrtfLoaders
)
{
REPORT
(
NS_LITERAL_CSTRING
(
"
explicit
/
webaudio
/
audio
-
node
/
PannerNode
/
hrtf
-
databases
"
)
hrtfLoaders
"
Memory
used
by
PannerNode
databases
(
Web
Audio
)
.
"
)
;
}
#
undef
REPORT
manager
-
>
EndReport
(
)
;
}
SourceMediaTrack
*
MediaTrackGraph
:
:
CreateSourceTrack
(
MediaSegment
:
:
Type
aType
)
{
SourceMediaTrack
*
track
=
new
SourceMediaTrack
(
aType
GraphRate
(
)
)
;
AddTrack
(
track
)
;
return
track
;
}
ProcessedMediaTrack
*
MediaTrackGraph
:
:
CreateForwardedInputTrack
(
MediaSegment
:
:
Type
aType
)
{
ForwardedInputTrack
*
track
=
new
ForwardedInputTrack
(
GraphRate
(
)
aType
)
;
AddTrack
(
track
)
;
return
track
;
}
AudioCaptureTrack
*
MediaTrackGraph
:
:
CreateAudioCaptureTrack
(
)
{
AudioCaptureTrack
*
track
=
new
AudioCaptureTrack
(
GraphRate
(
)
)
;
AddTrack
(
track
)
;
return
track
;
}
void
MediaTrackGraph
:
:
AddTrack
(
MediaTrack
*
aTrack
)
{
MediaTrackGraphImpl
*
graph
=
static_cast
<
MediaTrackGraphImpl
*
>
(
this
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
if
(
graph
-
>
mRealtime
)
{
bool
found
=
false
;
for
(
auto
iter
=
gGraphs
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
UserData
(
)
=
=
graph
)
{
found
=
true
;
break
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
found
"
Graph
must
not
be
shutting
down
"
)
;
}
#
endif
NS_ADDREF
(
aTrack
)
;
aTrack
-
>
SetGraphImpl
(
graph
)
;
+
+
graph
-
>
mMainThreadTrackCount
;
graph
-
>
AppendMessage
(
MakeUnique
<
CreateMessage
>
(
aTrack
)
)
;
}
void
MediaTrackGraphImpl
:
:
RemoveTrack
(
MediaTrack
*
aTrack
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mMainThreadTrackCount
>
0
)
;
if
(
-
-
mMainThreadTrackCount
=
=
0
)
{
LOG
(
LogLevel
:
:
Info
(
"
MediaTrackGraph
%
p
last
track
%
p
removed
from
"
"
main
thread
.
Graph
will
shut
down
.
"
this
aTrack
)
)
;
for
(
auto
iter
=
gGraphs
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
UserData
(
)
=
=
this
)
{
iter
.
Remove
(
)
;
break
;
}
}
}
}
class
GraphStartedRunnable
final
:
public
Runnable
{
public
:
GraphStartedRunnable
(
AudioNodeTrack
*
aTrack
MediaTrackGraph
*
aGraph
)
:
Runnable
(
"
GraphStartedRunnable
"
)
mTrack
(
aTrack
)
mGraph
(
aGraph
)
{
}
NS_IMETHOD
Run
(
)
override
{
mGraph
-
>
NotifyWhenGraphStarted
(
mTrack
)
;
return
NS_OK
;
}
private
:
RefPtr
<
AudioNodeTrack
>
mTrack
;
MediaTrackGraph
*
mGraph
;
}
;
void
MediaTrackGraph
:
:
NotifyWhenGraphStarted
(
AudioNodeTrack
*
aTrack
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
class
GraphStartedNotificationControlMessage
:
public
ControlMessage
{
public
:
explicit
GraphStartedNotificationControlMessage
(
AudioNodeTrack
*
aTrack
)
:
ControlMessage
(
aTrack
)
{
}
void
Run
(
)
override
{
MediaTrackGraphImpl
*
graphImpl
=
mTrack
-
>
GraphImpl
(
)
;
if
(
graphImpl
-
>
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
dom
:
:
StateChangeTask
(
mTrack
-
>
AsAudioNodeTrack
(
)
nullptr
AudioContextState
:
:
Running
)
;
graphImpl
-
>
Dispatch
(
event
.
forget
(
)
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
GraphStartedRunnable
(
mTrack
-
>
AsAudioNodeTrack
(
)
mTrack
-
>
Graph
(
)
)
;
graphImpl
-
>
Dispatch
(
event
.
forget
(
)
)
;
}
}
void
RunDuringShutdown
(
)
override
{
}
}
;
if
(
!
aTrack
-
>
IsDestroyed
(
)
)
{
MediaTrackGraphImpl
*
graphImpl
=
static_cast
<
MediaTrackGraphImpl
*
>
(
this
)
;
graphImpl
-
>
AppendMessage
(
MakeUnique
<
GraphStartedNotificationControlMessage
>
(
aTrack
)
)
;
}
}
void
MediaTrackGraphImpl
:
:
IncrementSuspendCount
(
MediaTrack
*
aTrack
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
bool
wasSuspended
=
aTrack
-
>
IsSuspended
(
)
;
aTrack
-
>
IncrementSuspendCount
(
)
;
if
(
!
wasSuspended
&
&
aTrack
-
>
IsSuspended
(
)
)
{
MOZ_ASSERT
(
mTracks
.
Contains
(
aTrack
)
)
;
mTracks
.
RemoveElement
(
aTrack
)
;
mSuspendedTracks
.
AppendElement
(
aTrack
)
;
SetTrackOrderDirty
(
)
;
}
}
void
MediaTrackGraphImpl
:
:
DecrementSuspendCount
(
MediaTrack
*
aTrack
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
bool
wasSuspended
=
aTrack
-
>
IsSuspended
(
)
;
aTrack
-
>
DecrementSuspendCount
(
)
;
if
(
wasSuspended
&
&
!
aTrack
-
>
IsSuspended
(
)
)
{
MOZ_ASSERT
(
mSuspendedTracks
.
Contains
(
aTrack
)
)
;
mSuspendedTracks
.
RemoveElement
(
aTrack
)
;
mTracks
.
AppendElement
(
aTrack
)
;
ProcessedMediaTrack
*
pt
=
aTrack
-
>
AsProcessedTrack
(
)
;
if
(
pt
)
{
pt
-
>
mCycleMarker
=
NOT_VISITED
;
}
SetTrackOrderDirty
(
)
;
}
}
void
MediaTrackGraphImpl
:
:
SuspendOrResumeTracks
(
AudioContextOperation
aAudioContextOperation
const
nsTArray
<
MediaTrack
*
>
&
aTrackSet
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
for
(
MediaTrack
*
track
:
aTrackSet
)
{
if
(
aAudioContextOperation
=
=
AudioContextOperation
:
:
Resume
)
{
DecrementSuspendCount
(
track
)
;
}
else
{
IncrementSuspendCount
(
track
)
;
}
}
LOG
(
LogLevel
:
:
Debug
(
"
Moving
tracks
between
suspended
and
running
"
"
state
:
mTracks
:
%
zu
mSuspendedTracks
:
%
zu
"
mTracks
.
Length
(
)
mSuspendedTracks
.
Length
(
)
)
)
;
#
ifdef
DEBUG
for
(
uint32_t
i
=
0
;
i
<
mTracks
.
Length
(
)
;
i
+
+
)
{
for
(
uint32_t
j
=
0
;
j
<
mSuspendedTracks
.
Length
(
)
;
j
+
+
)
{
MOZ_ASSERT
(
mTracks
[
i
]
!
=
mSuspendedTracks
[
j
]
"
The
suspended
track
set
and
running
track
set
are
not
disjoint
.
"
)
;
}
}
#
endif
}
void
MediaTrackGraphImpl
:
:
AudioContextOperationCompleted
(
MediaTrack
*
aTrack
void
*
aPromise
AudioContextOperation
aOperation
AudioContextOperationFlags
aFlags
)
{
if
(
aFlags
!
=
AudioContextOperationFlags
:
:
SendStateChange
)
{
MOZ_ASSERT
(
!
aPromise
)
;
return
;
}
AudioContextState
state
;
switch
(
aOperation
)
{
case
AudioContextOperation
:
:
Suspend
:
state
=
AudioContextState
:
:
Suspended
;
break
;
case
AudioContextOperation
:
:
Resume
:
state
=
AudioContextState
:
:
Running
;
break
;
case
AudioContextOperation
:
:
Close
:
state
=
AudioContextState
:
:
Closed
;
break
;
default
:
MOZ_CRASH
(
"
Not
handled
.
"
)
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
dom
:
:
StateChangeTask
(
aTrack
-
>
AsAudioNodeTrack
(
)
aPromise
state
)
;
mAbstractMainThread
-
>
Dispatch
(
event
.
forget
(
)
)
;
}
void
MediaTrackGraphImpl
:
:
ApplyAudioContextOperationImpl
(
MediaTrack
*
aDestinationTrack
const
nsTArray
<
MediaTrack
*
>
&
aTracks
AudioContextOperation
aOperation
void
*
aPromise
AudioContextOperationFlags
aFlags
)
{
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
SuspendOrResumeTracks
(
aOperation
aTracks
)
;
bool
switching
=
false
;
GraphDriver
*
nextDriver
=
nullptr
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
switching
=
CurrentDriver
(
)
-
>
Switching
(
)
;
if
(
switching
)
{
nextDriver
=
CurrentDriver
(
)
-
>
NextDriver
(
)
;
}
}
if
(
aOperation
=
=
AudioContextOperation
:
:
Resume
)
{
if
(
!
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
{
AudioCallbackDriver
*
driver
;
if
(
switching
)
{
MOZ_ASSERT
(
nextDriver
-
>
AsAudioCallbackDriver
(
)
)
;
driver
=
nextDriver
-
>
AsAudioCallbackDriver
(
)
;
}
else
{
driver
=
new
AudioCallbackDriver
(
this
AudioOutputChannelCount
(
)
AudioInputChannelCount
(
)
AudioInputDevicePreference
(
)
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
CurrentDriver
(
)
-
>
SwitchAtNextIteration
(
driver
)
;
}
driver
-
>
EnqueueTrackAndPromiseForOperation
(
aDestinationTrack
aPromise
aOperation
aFlags
)
;
}
else
{
AudioContextOperationCompleted
(
aDestinationTrack
aPromise
aOperation
aFlags
)
;
}
}
if
(
aOperation
!
=
AudioContextOperation
:
:
Resume
)
{
bool
audioTrackPresent
=
AudioTrackPresent
(
)
;
if
(
!
audioTrackPresent
&
&
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
{
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
-
>
EnqueueTrackAndPromiseForOperation
(
aDestinationTrack
aPromise
aOperation
aFlags
)
;
SystemClockDriver
*
driver
;
if
(
!
nextDriver
)
{
driver
=
new
SystemClockDriver
(
this
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
CurrentDriver
(
)
-
>
SwitchAtNextIteration
(
driver
)
;
}
}
else
if
(
!
audioTrackPresent
&
&
switching
)
{
MOZ_ASSERT
(
nextDriver
-
>
AsAudioCallbackDriver
(
)
|
|
nextDriver
-
>
AsSystemClockDriver
(
)
-
>
IsFallback
(
)
)
;
if
(
nextDriver
-
>
AsAudioCallbackDriver
(
)
)
{
nextDriver
-
>
AsAudioCallbackDriver
(
)
-
>
EnqueueTrackAndPromiseForOperation
(
aDestinationTrack
aPromise
aOperation
aFlags
)
;
}
else
{
AudioContextOperationCompleted
(
aDestinationTrack
aPromise
aOperation
aFlags
)
;
}
}
else
{
AudioContextOperationCompleted
(
aDestinationTrack
aPromise
aOperation
aFlags
)
;
}
}
}
void
MediaTrackGraph
:
:
ApplyAudioContextOperation
(
MediaTrack
*
aDestinationTrack
const
nsTArray
<
MediaTrack
*
>
&
aTracks
AudioContextOperation
aOperation
void
*
aPromise
AudioContextOperationFlags
aFlags
)
{
class
AudioContextOperationControlMessage
:
public
ControlMessage
{
public
:
AudioContextOperationControlMessage
(
MediaTrack
*
aDestinationTrack
const
nsTArray
<
MediaTrack
*
>
&
aTracks
AudioContextOperation
aOperation
void
*
aPromise
AudioContextOperationFlags
aFlags
)
:
ControlMessage
(
aDestinationTrack
)
mTracks
(
aTracks
)
mAudioContextOperation
(
aOperation
)
mPromise
(
aPromise
)
mFlags
(
aFlags
)
{
}
void
Run
(
)
override
{
mTrack
-
>
GraphImpl
(
)
-
>
ApplyAudioContextOperationImpl
(
mTrack
mTracks
mAudioContextOperation
mPromise
mFlags
)
;
}
void
RunDuringShutdown
(
)
override
{
MOZ_ASSERT
(
mAudioContextOperation
=
=
AudioContextOperation
:
:
Close
"
We
should
be
reviving
the
graph
?
"
)
;
}
private
:
nsTArray
<
MediaTrack
*
>
mTracks
;
AudioContextOperation
mAudioContextOperation
;
void
*
mPromise
;
AudioContextOperationFlags
mFlags
;
}
;
MediaTrackGraphImpl
*
graphImpl
=
static_cast
<
MediaTrackGraphImpl
*
>
(
this
)
;
graphImpl
-
>
AppendMessage
(
MakeUnique
<
AudioContextOperationControlMessage
>
(
aDestinationTrack
aTracks
aOperation
aPromise
aFlags
)
)
;
}
uint32_t
MediaTrackGraphImpl
:
:
AudioOutputChannelCount
(
)
const
{
MOZ_ASSERT
(
OnGraphThread
(
)
)
;
uint32_t
channelCount
=
0
;
for
(
auto
&
tkv
:
mAudioOutputs
)
{
MediaTrack
*
t
=
tkv
.
mTrack
;
if
(
t
-
>
AsAudioNodeTrack
(
)
)
{
channelCount
=
std
:
:
max
<
uint32_t
>
(
channelCount
t
-
>
AsAudioNodeTrack
(
)
-
>
NumberOfChannels
(
)
)
;
}
else
if
(
t
-
>
GetData
<
AudioSegment
>
(
)
)
{
AudioSegment
*
segment
=
t
-
>
GetData
<
AudioSegment
>
(
)
;
channelCount
=
std
:
:
max
<
uint32_t
>
(
channelCount
segment
-
>
MaxChannelCount
(
)
)
;
}
}
if
(
channelCount
)
{
return
channelCount
;
}
else
{
if
(
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
{
return
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
-
>
OutputChannelCount
(
)
;
}
return
2
;
}
}
double
MediaTrackGraph
:
:
AudioOutputLatency
(
)
{
return
static_cast
<
MediaTrackGraphImpl
*
>
(
this
)
-
>
AudioOutputLatency
(
)
;
}
double
MediaTrackGraphImpl
:
:
AudioOutputLatency
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mAudioOutputLatency
!
=
0
.
0
)
{
return
mAudioOutputLatency
;
}
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
{
mAudioOutputLatency
=
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
-
>
AudioOutputLatency
(
)
.
ToSeconds
(
)
;
}
else
{
mAudioOutputLatency
=
0
.
0
;
}
return
mAudioOutputLatency
;
}
bool
MediaTrackGraph
:
:
IsNonRealtime
(
)
const
{
return
!
static_cast
<
const
MediaTrackGraphImpl
*
>
(
this
)
-
>
mRealtime
;
}
void
MediaTrackGraph
:
:
StartNonRealtimeProcessing
(
uint32_t
aTicksToProcess
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
main
thread
only
"
)
;
MediaTrackGraphImpl
*
graph
=
static_cast
<
MediaTrackGraphImpl
*
>
(
this
)
;
NS_ASSERTION
(
!
graph
-
>
mRealtime
"
non
-
realtime
only
"
)
;
class
Message
:
public
ControlMessage
{
public
:
explicit
Message
(
MediaTrackGraphImpl
*
aGraph
uint32_t
aTicksToProcess
)
:
ControlMessage
(
nullptr
)
mGraph
(
aGraph
)
mTicksToProcess
(
aTicksToProcess
)
{
}
void
Run
(
)
override
{
MOZ_ASSERT
(
mGraph
-
>
mEndTime
=
=
0
"
StartNonRealtimeProcessing
should
be
called
only
once
"
)
;
mGraph
-
>
mEndTime
=
mGraph
-
>
RoundUpToEndOfAudioBlock
(
mGraph
-
>
mStateComputedTime
+
mTicksToProcess
)
;
}
MediaTrackGraphImpl
*
MOZ_NON_OWNING_REF
mGraph
;
uint32_t
mTicksToProcess
;
}
;
graph
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
graph
aTicksToProcess
)
)
;
}
void
ProcessedMediaTrack
:
:
AddInput
(
MediaInputPort
*
aPort
)
{
MediaTrack
*
t
=
aPort
-
>
GetSource
(
)
;
if
(
!
t
-
>
IsSuspended
(
)
)
{
mInputs
.
AppendElement
(
aPort
)
;
}
else
{
mSuspendedInputs
.
AppendElement
(
aPort
)
;
}
GraphImpl
(
)
-
>
SetTrackOrderDirty
(
)
;
}
void
ProcessedMediaTrack
:
:
InputSuspended
(
MediaInputPort
*
aPort
)
{
GraphImpl
(
)
-
>
AssertOnGraphThreadOrNotRunning
(
)
;
mInputs
.
RemoveElement
(
aPort
)
;
mSuspendedInputs
.
AppendElement
(
aPort
)
;
GraphImpl
(
)
-
>
SetTrackOrderDirty
(
)
;
}
void
ProcessedMediaTrack
:
:
InputResumed
(
MediaInputPort
*
aPort
)
{
GraphImpl
(
)
-
>
AssertOnGraphThreadOrNotRunning
(
)
;
mSuspendedInputs
.
RemoveElement
(
aPort
)
;
mInputs
.
AppendElement
(
aPort
)
;
GraphImpl
(
)
-
>
SetTrackOrderDirty
(
)
;
}
void
MediaTrackGraph
:
:
RegisterCaptureTrackForWindow
(
uint64_t
aWindowId
ProcessedMediaTrack
*
aCaptureTrack
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MediaTrackGraphImpl
*
graphImpl
=
static_cast
<
MediaTrackGraphImpl
*
>
(
this
)
;
graphImpl
-
>
RegisterCaptureTrackForWindow
(
aWindowId
aCaptureTrack
)
;
}
void
MediaTrackGraphImpl
:
:
RegisterCaptureTrackForWindow
(
uint64_t
aWindowId
ProcessedMediaTrack
*
aCaptureTrack
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
WindowAndTrack
winAndTrack
;
winAndTrack
.
mWindowId
=
aWindowId
;
winAndTrack
.
mCaptureTrackSink
=
aCaptureTrack
;
mWindowCaptureTracks
.
AppendElement
(
winAndTrack
)
;
}
void
MediaTrackGraph
:
:
UnregisterCaptureTrackForWindow
(
uint64_t
aWindowId
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MediaTrackGraphImpl
*
graphImpl
=
static_cast
<
MediaTrackGraphImpl
*
>
(
this
)
;
graphImpl
-
>
UnregisterCaptureTrackForWindow
(
aWindowId
)
;
}
void
MediaTrackGraphImpl
:
:
UnregisterCaptureTrackForWindow
(
uint64_t
aWindowId
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
int32_t
i
=
mWindowCaptureTracks
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
mWindowCaptureTracks
[
i
]
.
mWindowId
=
=
aWindowId
)
{
mWindowCaptureTracks
.
RemoveElementAt
(
i
)
;
}
}
}
already_AddRefed
<
MediaInputPort
>
MediaTrackGraph
:
:
ConnectToCaptureTrack
(
uint64_t
aWindowId
MediaTrack
*
aMediaTrack
)
{
return
aMediaTrack
-
>
GraphImpl
(
)
-
>
ConnectToCaptureTrack
(
aWindowId
aMediaTrack
)
;
}
already_AddRefed
<
MediaInputPort
>
MediaTrackGraphImpl
:
:
ConnectToCaptureTrack
(
uint64_t
aWindowId
MediaTrack
*
aMediaTrack
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mWindowCaptureTracks
.
Length
(
)
;
i
+
+
)
{
if
(
mWindowCaptureTracks
[
i
]
.
mWindowId
=
=
aWindowId
)
{
ProcessedMediaTrack
*
sink
=
mWindowCaptureTracks
[
i
]
.
mCaptureTrackSink
;
return
sink
-
>
AllocateInputPort
(
aMediaTrack
)
;
}
}
return
nullptr
;
}
void
MediaTrackGraph
:
:
DispatchToMainThreadStableState
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
AssertOnGraphThreadOrNotRunning
(
)
;
static_cast
<
MediaTrackGraphImpl
*
>
(
this
)
-
>
mPendingUpdateRunnables
.
AppendElement
(
std
:
:
move
(
aRunnable
)
)
;
}
Watchable
<
mozilla
:
:
GraphTime
>
&
MediaTrackGraphImpl
:
:
CurrentTime
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mMainThreadGraphTime
;
}
GraphTime
MediaTrackGraph
:
:
ProcessedTime
(
)
const
{
AssertOnGraphThreadOrNotRunning
(
)
;
return
static_cast
<
const
MediaTrackGraphImpl
*
>
(
this
)
-
>
mProcessedTime
;
}
}
