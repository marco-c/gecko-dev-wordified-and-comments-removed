#
include
"
MediaResource
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
ErrorNames
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
using
mozilla
:
:
media
:
:
TimeUnit
;
#
undef
ILOG
mozilla
:
:
LazyLogModule
gMediaResourceIndexLog
(
"
MediaResourceIndex
"
)
;
#
define
ILOG
(
msg
.
.
.
)
\
DDMOZ_LOG
(
gMediaResourceIndexLog
mozilla
:
:
LogLevel
:
:
Debug
msg
\
#
#
__VA_ARGS__
)
namespace
mozilla
{
void
MediaResource
:
:
Destroy
(
)
{
if
(
NS_IsMainThread
(
)
)
{
delete
this
;
return
;
}
nsresult
rv
=
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
NewNonOwningRunnableMethod
(
"
MediaResource
:
:
Destroy
"
this
&
MediaResource
:
:
Destroy
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
rv
)
;
}
NS_IMPL_ADDREF
(
MediaResource
)
NS_IMPL_RELEASE_WITH_DESTROY
(
MediaResource
Destroy
(
)
)
static
const
uint32_t
kMediaResourceIndexCacheSize
=
8192
;
static_assert
(
IsPowerOfTwo
(
kMediaResourceIndexCacheSize
)
"
kMediaResourceIndexCacheSize
cache
size
must
be
a
power
of
2
"
)
;
MediaResourceIndex
:
:
MediaResourceIndex
(
MediaResource
*
aResource
)
:
mResource
(
aResource
)
mOffset
(
0
)
mCacheBlockSize
(
aResource
-
>
ShouldCacheReads
(
)
?
kMediaResourceIndexCacheSize
:
0
)
mCachedOffset
(
0
)
mCachedBytes
(
0
)
mCachedBlock
(
MakeUnique
<
char
[
]
>
(
mCacheBlockSize
)
)
{
DDLINKCHILD
(
"
resource
"
aResource
)
;
}
nsresult
MediaResourceIndex
:
:
Read
(
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
{
NS_ASSERTION
(
!
NS_IsMainThread
(
)
"
Don
'
t
call
on
main
thread
"
)
;
nsresult
rv
=
ReadAt
(
mOffset
aBuffer
aCount
aBytes
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mOffset
+
=
*
aBytes
;
if
(
mOffset
<
0
)
{
mOffset
=
0
;
}
return
NS_OK
;
}
static
nsCString
ResultName
(
nsresult
aResult
)
{
nsCString
name
;
GetErrorName
(
aResult
name
)
;
return
name
;
}
nsresult
MediaResourceIndex
:
:
ReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
{
if
(
mCacheBlockSize
=
=
0
)
{
return
UncachedReadAt
(
aOffset
aBuffer
aCount
aBytes
)
;
}
*
aBytes
=
0
;
if
(
aCount
=
=
0
)
{
return
NS_OK
;
}
const
int64_t
endOffset
=
aOffset
+
aCount
;
if
(
aOffset
<
0
|
|
endOffset
<
aOffset
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
const
int64_t
lastBlockOffset
=
CacheOffsetContaining
(
endOffset
-
1
)
;
if
(
mCachedBytes
!
=
0
&
&
mCachedOffset
+
mCachedBytes
>
=
aOffset
&
&
mCachedOffset
<
endOffset
)
{
if
(
aOffset
<
mCachedOffset
)
{
const
uint32_t
toRead
=
uint32_t
(
mCachedOffset
-
aOffset
)
;
MOZ_ASSERT
(
toRead
>
0
)
;
MOZ_ASSERT
(
toRead
<
aCount
)
;
uint32_t
read
=
0
;
nsresult
rv
=
UncachedReadAt
(
aOffset
aBuffer
toRead
&
read
)
;
if
(
NS_FAILED
(
rv
)
)
{
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
uncached
read
before
cache
-
>
%
s
%
"
PRIu32
aCount
aOffset
ResultName
(
rv
)
.
get
(
)
*
aBytes
)
;
return
rv
;
}
*
aBytes
=
read
;
if
(
read
<
toRead
)
{
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
uncached
read
before
cache
incomplete
-
>
OK
%
"
PRIu32
aCount
aOffset
*
aBytes
)
;
return
NS_OK
;
}
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
uncached
read
before
cache
:
%
"
PRIu32
"
remaining
:
%
"
PRIu32
"
%
"
PRId64
"
.
.
.
"
aCount
aOffset
read
aCount
-
read
aOffset
+
read
)
;
aOffset
+
=
read
;
aBuffer
+
=
read
;
aCount
-
=
read
;
MOZ_ASSERT
(
aOffset
=
=
mCachedOffset
)
;
}
MOZ_ASSERT
(
aOffset
>
=
mCachedOffset
)
;
const
uint32_t
toCopy
=
std
:
:
min
(
aCount
uint32_t
(
mCachedOffset
+
mCachedBytes
-
aOffset
)
)
;
if
(
toCopy
!
=
0
)
{
memcpy
(
aBuffer
&
mCachedBlock
[
IndexInCache
(
aOffset
)
]
toCopy
)
;
*
aBytes
+
=
toCopy
;
aCount
-
=
toCopy
;
if
(
aCount
=
=
0
)
{
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
copied
everything
(
%
"
PRIu32
"
)
from
cache
(
%
"
PRIu32
"
%
"
PRId64
"
)
:
-
D
-
>
OK
%
"
PRIu32
aCount
aOffset
toCopy
mCachedBytes
mCachedOffset
*
aBytes
)
;
return
NS_OK
;
}
aOffset
+
=
toCopy
;
aBuffer
+
=
toCopy
;
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
copied
%
"
PRIu32
"
from
cache
(
%
"
PRIu32
"
%
"
PRId64
"
)
:
-
)
remaining
:
%
"
PRIu32
"
%
"
PRId64
"
.
.
.
"
aCount
+
toCopy
aOffset
-
toCopy
toCopy
mCachedBytes
mCachedOffset
aCount
aOffset
)
;
}
if
(
aOffset
-
1
>
=
lastBlockOffset
)
{
MOZ_ASSERT
(
aOffset
=
=
mCachedOffset
+
mCachedBytes
)
;
MOZ_ASSERT
(
endOffset
<
=
lastBlockOffset
+
mCacheBlockSize
)
;
return
CacheOrReadAt
(
aOffset
aBuffer
aCount
aBytes
)
;
}
MOZ_ASSERT
(
aOffset
<
=
lastBlockOffset
)
;
}
else
if
(
aOffset
>
=
lastBlockOffset
)
{
mCachedBytes
=
0
;
return
CacheOrReadAt
(
aOffset
aBuffer
aCount
aBytes
)
;
}
if
(
aOffset
<
lastBlockOffset
)
{
const
uint32_t
toRead
=
uint32_t
(
lastBlockOffset
-
aOffset
)
;
MOZ_ASSERT
(
toRead
>
0
)
;
MOZ_ASSERT
(
toRead
<
aCount
)
;
uint32_t
read
=
0
;
nsresult
rv
=
UncachedReadAt
(
aOffset
aBuffer
toRead
&
read
)
;
if
(
NS_FAILED
(
rv
)
)
{
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
uncached
read
before
last
block
failed
-
>
%
s
%
"
PRIu32
aCount
aOffset
ResultName
(
rv
)
.
get
(
)
*
aBytes
)
;
return
rv
;
}
if
(
read
=
=
0
)
{
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
uncached
read
0
before
last
block
-
>
OK
%
"
PRIu32
aCount
aOffset
*
aBytes
)
;
return
NS_OK
;
}
*
aBytes
+
=
read
;
if
(
read
<
toRead
)
{
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
uncached
read
before
last
block
incomplete
-
>
OK
%
"
PRIu32
aCount
aOffset
*
aBytes
)
;
return
NS_OK
;
}
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
read
%
"
PRIu32
"
before
last
block
remaining
:
%
"
PRIu32
"
%
"
PRId64
"
.
.
.
"
aCount
aOffset
read
aCount
-
read
aOffset
+
read
)
;
aOffset
+
=
read
;
aBuffer
+
=
read
;
aCount
-
=
read
;
}
MOZ_ASSERT
(
aOffset
=
=
lastBlockOffset
)
;
MOZ_ASSERT
(
aCount
<
=
mCacheBlockSize
)
;
mCachedBytes
=
0
;
return
CacheOrReadAt
(
aOffset
aBuffer
aCount
aBytes
)
;
}
nsresult
MediaResourceIndex
:
:
CacheOrReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
{
MOZ_ASSERT
(
aCount
>
0
)
;
MOZ_ASSERT
(
IndexInCache
(
aOffset
)
+
aCount
<
=
mCacheBlockSize
)
;
const
int64_t
length
=
GetLength
(
)
;
if
(
length
<
0
|
|
length
>
=
aOffset
+
aCount
)
{
const
int64_t
cachedDataEnd
=
mResource
-
>
GetCachedDataEnd
(
aOffset
)
;
if
(
cachedDataEnd
>
=
aOffset
+
aCount
)
{
const
uint32_t
cacheIndex
=
IndexInCache
(
aOffset
)
;
const
uint32_t
toRead
=
uint32_t
(
std
:
:
min
(
cachedDataEnd
-
aOffset
int64_t
(
mCacheBlockSize
-
cacheIndex
)
)
)
;
MOZ_ASSERT
(
toRead
>
=
aCount
)
;
uint32_t
read
=
0
;
nsresult
rv
=
UncachedRangedReadAt
(
aOffset
&
mCachedBlock
[
cacheIndex
]
aCount
toRead
-
aCount
&
read
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
read
=
=
0
)
{
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
-
UncachedRangedReadAt
(
%
"
PRIu32
"
.
.
%
"
PRIu32
"
%
"
PRId64
"
)
to
top
-
up
succeeded
but
read
nothing
-
>
OK
anyway
"
aCount
aOffset
aCount
toRead
aOffset
)
;
return
NS_OK
;
}
if
(
mCachedOffset
+
mCachedBytes
=
=
aOffset
)
{
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
-
UncachedRangedReadAt
(
%
"
PRIu32
"
.
.
%
"
PRIu32
"
%
"
PRId64
"
)
to
top
-
up
succeeded
to
read
%
"
PRIu32
"
.
.
.
"
aCount
aOffset
aCount
toRead
aOffset
read
)
;
mCachedBytes
+
=
read
;
}
else
{
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
-
UncachedRangedReadAt
(
%
"
PRIu32
"
.
.
%
"
PRIu32
"
%
"
PRId64
"
)
to
fill
cache
succeeded
to
read
%
"
PRIu32
"
.
.
.
"
aCount
aOffset
aCount
toRead
aOffset
read
)
;
mCachedOffset
=
aOffset
;
mCachedBytes
=
read
;
}
uint32_t
toCopy
=
std
:
:
min
(
aCount
read
)
;
memcpy
(
aBuffer
&
mCachedBlock
[
cacheIndex
]
toCopy
)
;
*
aBytes
+
=
toCopy
;
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
-
copied
%
"
PRIu32
"
%
"
PRId64
"
-
>
OK
%
"
PRIu32
aCount
aOffset
toCopy
aOffset
*
aBytes
)
;
return
NS_OK
;
}
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
-
UncachedRangedReadAt
(
%
"
PRIu32
"
.
.
%
"
PRIu32
"
%
"
PRId64
"
)
failed
:
%
s
will
fallback
to
blocking
read
.
.
.
"
aCount
aOffset
aCount
toRead
aOffset
ResultName
(
rv
)
.
get
(
)
)
;
if
(
mCachedOffset
+
mCachedBytes
=
=
aOffset
)
{
}
else
{
mCachedBytes
=
0
;
}
}
else
{
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
-
no
cached
data
will
fallback
to
blocking
read
.
.
.
"
aCount
aOffset
)
;
}
}
else
{
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
-
length
is
%
"
PRId64
"
(
%
s
)
will
fallback
to
blocking
read
as
the
caller
requested
.
.
.
"
aCount
aOffset
length
length
<
0
?
"
unknown
"
:
"
too
short
!
"
)
;
}
uint32_t
read
=
0
;
nsresult
rv
=
UncachedReadAt
(
aOffset
aBuffer
aCount
&
read
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aBytes
+
=
read
;
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
-
fallback
uncached
read
got
%
"
PRIu32
"
bytes
-
>
%
s
%
"
PRIu32
aCount
aOffset
read
ResultName
(
rv
)
.
get
(
)
*
aBytes
)
;
}
else
{
ILOG
(
"
ReadAt
(
%
"
PRIu32
"
%
"
PRId64
"
)
-
fallback
uncached
read
failed
-
>
%
s
%
"
PRIu32
aCount
aOffset
ResultName
(
rv
)
.
get
(
)
*
aBytes
)
;
}
return
rv
;
}
nsresult
MediaResourceIndex
:
:
UncachedReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
const
{
if
(
aOffset
<
0
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
aCount
=
=
0
)
{
*
aBytes
=
0
;
return
NS_OK
;
}
return
mResource
-
>
ReadAt
(
aOffset
aBuffer
aCount
aBytes
)
;
}
nsresult
MediaResourceIndex
:
:
UncachedRangedReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aRequestedCount
uint32_t
aExtraCount
uint32_t
*
aBytes
)
const
{
uint32_t
count
=
aRequestedCount
+
aExtraCount
;
if
(
aOffset
<
0
|
|
count
<
aRequestedCount
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
count
=
=
0
)
{
*
aBytes
=
0
;
return
NS_OK
;
}
return
mResource
-
>
ReadAt
(
aOffset
aBuffer
count
aBytes
)
;
}
nsresult
MediaResourceIndex
:
:
Seek
(
int32_t
aWhence
int64_t
aOffset
)
{
switch
(
aWhence
)
{
case
SEEK_SET
:
break
;
case
SEEK_CUR
:
aOffset
+
=
mOffset
;
break
;
case
SEEK_END
:
{
int64_t
length
=
mResource
-
>
GetLength
(
)
;
if
(
length
=
=
-
1
|
|
length
-
aOffset
<
0
)
{
return
NS_ERROR_FAILURE
;
}
aOffset
=
mResource
-
>
GetLength
(
)
-
aOffset
;
}
break
;
default
:
return
NS_ERROR_FAILURE
;
}
if
(
aOffset
<
0
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
mOffset
=
aOffset
;
return
NS_OK
;
}
already_AddRefed
<
MediaByteBuffer
>
MediaResourceIndex
:
:
MediaReadAt
(
int64_t
aOffset
uint32_t
aCount
)
const
{
NS_ENSURE_TRUE
(
aOffset
>
=
0
nullptr
)
;
RefPtr
<
MediaByteBuffer
>
bytes
=
new
MediaByteBuffer
(
)
;
bool
ok
=
bytes
-
>
SetLength
(
aCount
fallible
)
;
NS_ENSURE_TRUE
(
ok
nullptr
)
;
uint32_t
bytesRead
=
0
;
nsresult
rv
=
mResource
-
>
ReadAt
(
aOffset
reinterpret_cast
<
char
*
>
(
bytes
-
>
Elements
(
)
)
aCount
&
bytesRead
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
bytes
-
>
SetLength
(
bytesRead
)
;
return
bytes
.
forget
(
)
;
}
already_AddRefed
<
MediaByteBuffer
>
MediaResourceIndex
:
:
CachedMediaReadAt
(
int64_t
aOffset
uint32_t
aCount
)
const
{
RefPtr
<
MediaByteBuffer
>
bytes
=
new
MediaByteBuffer
(
)
;
bool
ok
=
bytes
-
>
SetLength
(
aCount
fallible
)
;
NS_ENSURE_TRUE
(
ok
nullptr
)
;
char
*
curr
=
reinterpret_cast
<
char
*
>
(
bytes
-
>
Elements
(
)
)
;
nsresult
rv
=
mResource
-
>
ReadFromCache
(
curr
aOffset
aCount
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
bytes
.
forget
(
)
;
}
int64_t
MediaResourceIndex
:
:
GetLength
(
)
const
{
return
mResource
-
>
GetLength
(
)
;
}
uint32_t
MediaResourceIndex
:
:
IndexInCache
(
int64_t
aOffsetInFile
)
const
{
const
uint32_t
index
=
uint32_t
(
aOffsetInFile
)
&
(
mCacheBlockSize
-
1
)
;
MOZ_ASSERT
(
index
=
=
aOffsetInFile
%
mCacheBlockSize
)
;
return
index
;
}
int64_t
MediaResourceIndex
:
:
CacheOffsetContaining
(
int64_t
aOffsetInFile
)
const
{
const
int64_t
offset
=
aOffsetInFile
&
~
(
int64_t
(
mCacheBlockSize
)
-
1
)
;
MOZ_ASSERT
(
offset
=
=
aOffsetInFile
-
IndexInCache
(
aOffsetInFile
)
)
;
return
offset
;
}
}
#
undef
ILOG
