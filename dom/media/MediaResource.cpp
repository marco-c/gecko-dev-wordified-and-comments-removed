#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
MediaResource
.
h
"
#
include
"
MediaResourceCallback
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIFileChannel
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIRequestObserver
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMediaElement
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsHostObjectProtocolHandler
.
h
"
#
include
<
algorithm
>
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsIContentPolicy
.
h
"
using
mozilla
:
:
media
:
:
TimeUnit
;
#
undef
LOG
mozilla
:
:
LazyLogModule
gMediaResourceLog
(
"
MediaResource
"
)
;
#
define
LOG
(
msg
.
.
.
)
MOZ_LOG
(
gMediaResourceLog
mozilla
:
:
LogLevel
:
:
Debug
\
(
"
%
p
"
msg
this
#
#
__VA_ARGS__
)
)
static
const
uint32_t
HTTP_OK_CODE
=
200
;
static
const
uint32_t
HTTP_PARTIAL_RESPONSE_CODE
=
206
;
namespace
mozilla
{
void
MediaResource
:
:
Destroy
(
)
{
if
(
NS_IsMainThread
(
)
)
{
delete
this
;
return
;
}
nsresult
rv
=
SystemGroup
:
:
Dispatch
(
"
MediaResource
:
:
Destroy
"
TaskCategory
:
:
Other
NewNonOwningRunnableMethod
(
this
&
MediaResource
:
:
Destroy
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
rv
)
;
}
NS_IMPL_ADDREF
(
MediaResource
)
NS_IMPL_RELEASE_WITH_DESTROY
(
MediaResource
Destroy
(
)
)
NS_IMPL_QUERY_INTERFACE0
(
MediaResource
)
ChannelMediaResource
:
:
ChannelMediaResource
(
MediaResourceCallback
*
aCallback
nsIChannel
*
aChannel
nsIURI
*
aURI
const
MediaContainerType
&
aContainerType
)
:
BaseMediaResource
(
aCallback
aChannel
aURI
aContainerType
)
mOffset
(
0
)
mReopenOnError
(
false
)
mIgnoreClose
(
false
)
mCacheStream
(
this
)
mLock
(
"
ChannelMediaResource
.
mLock
"
)
mIgnoreResume
(
false
)
mSuspendAgent
(
mChannel
)
{
}
ChannelMediaResource
:
:
~
ChannelMediaResource
(
)
{
if
(
mListener
)
{
mListener
-
>
Revoke
(
)
;
}
}
NS_IMPL_ISUPPORTS
(
ChannelMediaResource
:
:
Listener
nsIRequestObserver
nsIStreamListener
nsIChannelEventSink
nsIInterfaceRequestor
)
nsresult
ChannelMediaResource
:
:
Listener
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
if
(
!
mResource
)
return
NS_OK
;
return
mResource
-
>
OnStartRequest
(
aRequest
)
;
}
nsresult
ChannelMediaResource
:
:
Listener
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatus
)
{
if
(
!
mResource
)
return
NS_OK
;
return
mResource
-
>
OnStopRequest
(
aRequest
aStatus
)
;
}
nsresult
ChannelMediaResource
:
:
Listener
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aStream
uint64_t
aOffset
uint32_t
aCount
)
{
if
(
!
mResource
)
return
NS_OK
;
return
mResource
-
>
OnDataAvailable
(
aRequest
aStream
aCount
)
;
}
nsresult
ChannelMediaResource
:
:
Listener
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
cb
)
{
nsresult
rv
=
NS_OK
;
if
(
mResource
)
rv
=
mResource
-
>
OnChannelRedirect
(
aOldChannel
aNewChannel
aFlags
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
cb
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
nsresult
ChannelMediaResource
:
:
Listener
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
return
QueryInterface
(
aIID
aResult
)
;
}
nsresult
ChannelMediaResource
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
NS_ASSERTION
(
mChannel
.
get
(
)
=
=
aRequest
"
Wrong
channel
!
"
)
;
MediaDecoderOwner
*
owner
=
mCallback
-
>
GetMediaOwner
(
)
;
NS_ENSURE_TRUE
(
owner
NS_ERROR_FAILURE
)
;
dom
:
:
HTMLMediaElement
*
element
=
owner
-
>
GetMediaElement
(
)
;
NS_ENSURE_TRUE
(
element
NS_ERROR_FAILURE
)
;
nsresult
status
;
nsresult
rv
=
aRequest
-
>
GetStatus
(
&
status
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
status
=
=
NS_BINDING_ABORTED
)
{
CloseChannel
(
)
;
return
status
;
}
if
(
element
-
>
ShouldCheckAllowOrigin
(
)
)
{
if
(
status
=
=
NS_ERROR_DOM_BAD_URI
)
{
mCallback
-
>
NotifyNetworkError
(
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
}
nsCOMPtr
<
nsIHttpChannel
>
hc
=
do_QueryInterface
(
aRequest
)
;
bool
seekable
=
false
;
if
(
hc
)
{
uint32_t
responseStatus
=
0
;
Unused
<
<
hc
-
>
GetResponseStatus
(
&
responseStatus
)
;
bool
succeeded
=
false
;
Unused
<
<
hc
-
>
GetRequestSucceeded
(
&
succeeded
)
;
if
(
!
succeeded
&
&
NS_SUCCEEDED
(
status
)
)
{
if
(
responseStatus
=
=
HTTP_REQUESTED_RANGE_NOT_SATISFIABLE_CODE
)
{
mCacheStream
.
NotifyDataEnded
(
status
)
;
}
else
{
mCallback
-
>
NotifyNetworkError
(
)
;
}
CloseChannel
(
)
;
return
NS_OK
;
}
nsAutoCString
ranges
;
Unused
<
<
hc
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
Accept
-
Ranges
"
)
ranges
)
;
bool
acceptsRanges
=
ranges
.
EqualsLiteral
(
"
bytes
"
)
;
bool
dataIsBounded
=
false
;
int64_t
contentLength
=
-
1
;
hc
-
>
GetContentLength
(
&
contentLength
)
;
if
(
contentLength
>
=
0
&
&
(
responseStatus
=
=
HTTP_OK_CODE
|
|
responseStatus
=
=
HTTP_PARTIAL_RESPONSE_CODE
)
)
{
dataIsBounded
=
true
;
}
bool
boundedSeekLimit
=
true
;
if
(
responseStatus
=
=
HTTP_PARTIAL_RESPONSE_CODE
)
{
int64_t
rangeStart
=
0
;
int64_t
rangeEnd
=
0
;
int64_t
rangeTotal
=
0
;
rv
=
ParseContentRangeHeader
(
hc
rangeStart
rangeEnd
rangeTotal
)
;
bool
gotRangeHeader
=
NS_SUCCEEDED
(
rv
)
;
if
(
gotRangeHeader
)
{
if
(
rangeTotal
=
=
-
1
)
{
boundedSeekLimit
=
false
;
}
else
{
contentLength
=
std
:
:
max
(
contentLength
rangeTotal
)
;
}
NS_WARNING_ASSERTION
(
mOffset
=
=
rangeStart
"
response
range
start
does
not
match
current
offset
"
)
;
mOffset
=
rangeStart
;
mCacheStream
.
NotifyDataStarted
(
rangeStart
)
;
}
acceptsRanges
=
gotRangeHeader
;
}
else
if
(
mOffset
>
0
&
&
responseStatus
=
=
HTTP_OK_CODE
)
{
mCacheStream
.
NotifyDataStarted
(
0
)
;
mOffset
=
0
;
acceptsRanges
=
false
;
}
if
(
mOffset
=
=
0
&
&
contentLength
>
=
0
&
&
(
responseStatus
=
=
HTTP_OK_CODE
|
|
responseStatus
=
=
HTTP_PARTIAL_RESPONSE_CODE
)
)
{
mCacheStream
.
NotifyDataLength
(
contentLength
)
;
}
seekable
=
acceptsRanges
;
if
(
seekable
&
&
boundedSeekLimit
)
{
dataIsBounded
=
true
;
}
mCallback
-
>
SetInfinite
(
!
dataIsBounded
)
;
}
mCacheStream
.
SetTransportSeekable
(
seekable
)
;
{
MutexAutoLock
lock
(
mLock
)
;
mChannelStatistics
-
>
Start
(
)
;
}
mReopenOnError
=
false
;
mIgnoreClose
=
false
;
mSuspendAgent
.
UpdateSuspendedStatusIfNeeded
(
)
;
owner
-
>
DownloadProgressed
(
)
;
return
NS_OK
;
}
bool
ChannelMediaResource
:
:
IsTransportSeekable
(
)
{
return
mCacheStream
.
IsTransportSeekable
(
)
;
}
nsresult
ChannelMediaResource
:
:
ParseContentRangeHeader
(
nsIHttpChannel
*
aHttpChan
int64_t
&
aRangeStart
int64_t
&
aRangeEnd
int64_t
&
aRangeTotal
)
{
NS_ENSURE_ARG
(
aHttpChan
)
;
nsAutoCString
rangeStr
;
nsresult
rv
=
aHttpChan
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
Content
-
Range
"
)
rangeStr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_FALSE
(
rangeStr
.
IsEmpty
(
)
NS_ERROR_ILLEGAL_VALUE
)
;
int32_t
spacePos
=
rangeStr
.
Find
(
NS_LITERAL_CSTRING
(
"
"
)
)
;
int32_t
dashPos
=
rangeStr
.
Find
(
NS_LITERAL_CSTRING
(
"
-
"
)
true
spacePos
)
;
int32_t
slashPos
=
rangeStr
.
Find
(
NS_LITERAL_CSTRING
(
"
/
"
)
true
dashPos
)
;
nsAutoCString
aRangeStartText
;
rangeStr
.
Mid
(
aRangeStartText
spacePos
+
1
dashPos
-
(
spacePos
+
1
)
)
;
aRangeStart
=
aRangeStartText
.
ToInteger64
(
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
0
<
=
aRangeStart
NS_ERROR_ILLEGAL_VALUE
)
;
nsAutoCString
aRangeEndText
;
rangeStr
.
Mid
(
aRangeEndText
dashPos
+
1
slashPos
-
(
dashPos
+
1
)
)
;
aRangeEnd
=
aRangeEndText
.
ToInteger64
(
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
aRangeStart
<
aRangeEnd
NS_ERROR_ILLEGAL_VALUE
)
;
nsAutoCString
aRangeTotalText
;
rangeStr
.
Right
(
aRangeTotalText
rangeStr
.
Length
(
)
-
(
slashPos
+
1
)
)
;
if
(
aRangeTotalText
[
0
]
=
=
'
*
'
)
{
aRangeTotal
=
-
1
;
}
else
{
aRangeTotal
=
aRangeTotalText
.
ToInteger64
(
&
rv
)
;
NS_ENSURE_TRUE
(
aRangeEnd
<
aRangeTotal
NS_ERROR_ILLEGAL_VALUE
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
LOG
(
"
Received
bytes
[
%
"
PRId64
"
]
to
[
%
"
PRId64
"
]
of
[
%
"
PRId64
"
]
for
decoder
[
%
p
]
"
aRangeStart
aRangeEnd
aRangeTotal
mCallback
.
get
(
)
)
;
return
NS_OK
;
}
nsresult
ChannelMediaResource
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
aStatus
)
{
NS_ASSERTION
(
mChannel
.
get
(
)
=
=
aRequest
"
Wrong
channel
!
"
)
;
NS_ASSERTION
(
!
mSuspendAgent
.
IsSuspended
(
)
"
How
can
OnStopRequest
fire
while
we
'
re
suspended
?
"
)
;
{
MutexAutoLock
lock
(
mLock
)
;
mChannelStatistics
-
>
Stop
(
)
;
}
if
(
mReopenOnError
&
&
aStatus
!
=
NS_ERROR_PARSED_DATA_CACHED
&
&
aStatus
!
=
NS_BINDING_ABORTED
&
&
(
mOffset
=
=
0
|
|
mCacheStream
.
IsTransportSeekable
(
)
)
)
{
nsresult
rv
=
CacheClientSeek
(
mOffset
false
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
return
rv
;
}
if
(
!
mIgnoreClose
)
{
mCacheStream
.
NotifyDataEnded
(
aStatus
)
;
nsLoadFlags
loadFlags
;
DebugOnly
<
nsresult
>
rv
=
mChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
GetLoadFlags
(
)
failed
!
"
)
;
if
(
loadFlags
&
nsIRequest
:
:
LOAD_BACKGROUND
)
{
ModifyLoadFlags
(
loadFlags
&
~
nsIRequest
:
:
LOAD_BACKGROUND
)
;
}
}
return
NS_OK
;
}
nsresult
ChannelMediaResource
:
:
OnChannelRedirect
(
nsIChannel
*
aOld
nsIChannel
*
aNew
uint32_t
aFlags
)
{
mChannel
=
aNew
;
mSuspendAgent
.
NotifyChannelOpened
(
mChannel
)
;
return
SetupChannelHeaders
(
)
;
}
nsresult
ChannelMediaResource
:
:
CopySegmentToCache
(
nsIPrincipal
*
aPrincipal
const
char
*
aFromSegment
uint32_t
aCount
uint32_t
*
aWriteCount
)
{
mCallback
-
>
NotifyDataArrived
(
)
;
LOG
(
"
CopySegmentToCache
at
mOffset
[
%
"
PRId64
"
]
add
"
"
[
%
d
]
bytes
for
decoder
[
%
p
]
"
mOffset
aCount
mCallback
.
get
(
)
)
;
mOffset
+
=
aCount
;
mCacheStream
.
NotifyDataReceived
(
aCount
aFromSegment
aPrincipal
)
;
*
aWriteCount
=
aCount
;
return
NS_OK
;
}
struct
CopySegmentClosure
{
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
ChannelMediaResource
*
mResource
;
}
;
nsresult
ChannelMediaResource
:
:
CopySegmentToCache
(
nsIInputStream
*
aInStream
void
*
aClosure
const
char
*
aFromSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
aWriteCount
)
{
CopySegmentClosure
*
closure
=
static_cast
<
CopySegmentClosure
*
>
(
aClosure
)
;
return
closure
-
>
mResource
-
>
CopySegmentToCache
(
closure
-
>
mPrincipal
aFromSegment
aCount
aWriteCount
)
;
}
nsresult
ChannelMediaResource
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aStream
uint32_t
aCount
)
{
NS_ASSERTION
(
mChannel
.
get
(
)
=
=
aRequest
"
Wrong
channel
!
"
)
;
{
MutexAutoLock
lock
(
mLock
)
;
mChannelStatistics
-
>
AddBytes
(
aCount
)
;
}
CopySegmentClosure
closure
;
nsIScriptSecurityManager
*
secMan
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
if
(
secMan
&
&
mChannel
)
{
secMan
-
>
GetChannelResultPrincipal
(
mChannel
getter_AddRefs
(
closure
.
mPrincipal
)
)
;
}
closure
.
mResource
=
this
;
uint32_t
count
=
aCount
;
while
(
count
>
0
)
{
uint32_t
read
;
nsresult
rv
=
aStream
-
>
ReadSegments
(
CopySegmentToCache
&
closure
count
&
read
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
NS_ASSERTION
(
read
>
0
"
Read
0
bytes
while
data
was
available
?
"
)
;
count
-
=
read
;
}
return
NS_OK
;
}
nsresult
ChannelMediaResource
:
:
Open
(
nsIStreamListener
*
*
aStreamListener
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
!
mChannelStatistics
)
{
mChannelStatistics
=
new
MediaChannelStatistics
(
)
;
}
nsresult
rv
=
mCacheStream
.
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
NS_ASSERTION
(
mOffset
=
=
0
"
Who
set
mOffset
already
?
"
)
;
if
(
!
mChannel
)
{
NS_ASSERTION
(
!
aStreamListener
"
Should
have
already
been
given
a
channel
if
we
'
re
to
return
a
stream
listener
"
)
;
return
NS_OK
;
}
return
OpenChannel
(
aStreamListener
)
;
}
nsresult
ChannelMediaResource
:
:
OpenChannel
(
nsIStreamListener
*
*
aStreamListener
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
NS_ENSURE_TRUE
(
mChannel
NS_ERROR_NULL_POINTER
)
;
NS_ASSERTION
(
!
mListener
"
Listener
should
have
been
removed
by
now
"
)
;
if
(
aStreamListener
)
{
*
aStreamListener
=
nullptr
;
}
nsCOMPtr
<
nsIHttpChannel
>
hc
=
do_QueryInterface
(
mChannel
)
;
if
(
hc
)
{
int64_t
cl
=
-
1
;
if
(
NS_SUCCEEDED
(
hc
-
>
GetContentLength
(
&
cl
)
)
&
&
cl
!
=
-
1
)
{
mCacheStream
.
NotifyDataLength
(
cl
)
;
}
}
mListener
=
new
Listener
(
this
)
;
if
(
aStreamListener
)
{
*
aStreamListener
=
mListener
;
NS_ADDREF
(
*
aStreamListener
)
;
}
else
{
nsresult
rv
=
mChannel
-
>
SetNotificationCallbacks
(
mListener
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SetupChannelHeaders
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mChannel
-
>
AsyncOpen2
(
mListener
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MediaDecoderOwner
*
owner
=
mCallback
-
>
GetMediaOwner
(
)
;
NS_ENSURE_TRUE
(
owner
NS_ERROR_FAILURE
)
;
dom
:
:
HTMLMediaElement
*
element
=
owner
-
>
GetMediaElement
(
)
;
element
-
>
DownloadResumed
(
true
)
;
}
return
NS_OK
;
}
nsresult
ChannelMediaResource
:
:
SetupChannelHeaders
(
)
{
nsCOMPtr
<
nsIHttpChannel
>
hc
=
do_QueryInterface
(
mChannel
)
;
if
(
hc
)
{
nsAutoCString
rangeString
(
"
bytes
=
"
)
;
rangeString
.
AppendInt
(
mOffset
)
;
rangeString
.
Append
(
'
-
'
)
;
nsresult
rv
=
hc
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Range
"
)
rangeString
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Don
'
t
call
on
non
-
main
thread
"
)
;
MediaDecoderOwner
*
owner
=
mCallback
-
>
GetMediaOwner
(
)
;
NS_ENSURE_TRUE
(
owner
NS_ERROR_FAILURE
)
;
dom
:
:
HTMLMediaElement
*
element
=
owner
-
>
GetMediaElement
(
)
;
NS_ENSURE_TRUE
(
element
NS_ERROR_FAILURE
)
;
element
-
>
SetRequestHeaders
(
hc
)
;
}
else
{
NS_ASSERTION
(
mOffset
=
=
0
"
Don
'
t
know
how
to
seek
on
this
channel
type
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
ChannelMediaResource
:
:
Close
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
mCacheStream
.
Close
(
)
;
CloseChannel
(
)
;
return
NS_OK
;
}
already_AddRefed
<
nsIPrincipal
>
ChannelMediaResource
:
:
GetCurrentPrincipal
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
mCacheStream
.
GetCurrentPrincipal
(
)
;
return
principal
.
forget
(
)
;
}
bool
ChannelMediaResource
:
:
CanClone
(
)
{
return
mCacheStream
.
IsAvailableForSharing
(
)
;
}
already_AddRefed
<
MediaResource
>
ChannelMediaResource
:
:
CloneData
(
MediaResourceCallback
*
aCallback
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
NS_ASSERTION
(
mCacheStream
.
IsAvailableForSharing
(
)
"
Stream
can
'
t
be
cloned
"
)
;
RefPtr
<
ChannelMediaResource
>
resource
=
new
ChannelMediaResource
(
aCallback
nullptr
mURI
GetContentType
(
)
)
;
if
(
resource
)
{
resource
-
>
mSuspendAgent
.
Suspend
(
)
;
resource
-
>
mCacheStream
.
InitAsClone
(
&
mCacheStream
)
;
resource
-
>
mChannelStatistics
=
new
MediaChannelStatistics
(
mChannelStatistics
)
;
resource
-
>
mChannelStatistics
-
>
Stop
(
)
;
}
return
resource
.
forget
(
)
;
}
void
ChannelMediaResource
:
:
CloseChannel
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
{
MutexAutoLock
lock
(
mLock
)
;
mChannelStatistics
-
>
Stop
(
)
;
}
if
(
mListener
)
{
mListener
-
>
Revoke
(
)
;
mListener
=
nullptr
;
}
if
(
mChannel
)
{
mSuspendAgent
.
NotifyChannelClosing
(
)
;
mChannel
-
>
Cancel
(
NS_ERROR_PARSED_DATA_CACHED
)
;
mChannel
=
nullptr
;
}
}
nsresult
ChannelMediaResource
:
:
ReadFromCache
(
char
*
aBuffer
int64_t
aOffset
uint32_t
aCount
)
{
return
mCacheStream
.
ReadFromCache
(
aBuffer
aOffset
aCount
)
;
}
nsresult
ChannelMediaResource
:
:
ReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
{
NS_ASSERTION
(
!
NS_IsMainThread
(
)
"
Don
'
t
call
on
main
thread
"
)
;
nsresult
rv
=
mCacheStream
.
ReadAt
(
aOffset
aBuffer
aCount
aBytes
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
DispatchBytesConsumed
(
*
aBytes
aOffset
)
;
}
return
rv
;
}
already_AddRefed
<
MediaByteBuffer
>
ChannelMediaResource
:
:
MediaReadAt
(
int64_t
aOffset
uint32_t
aCount
)
{
NS_ASSERTION
(
!
NS_IsMainThread
(
)
"
Don
'
t
call
on
main
thread
"
)
;
RefPtr
<
MediaByteBuffer
>
bytes
=
new
MediaByteBuffer
(
)
;
bool
ok
=
bytes
-
>
SetLength
(
aCount
fallible
)
;
NS_ENSURE_TRUE
(
ok
nullptr
)
;
char
*
curr
=
reinterpret_cast
<
char
*
>
(
bytes
-
>
Elements
(
)
)
;
const
char
*
start
=
curr
;
while
(
aCount
>
0
)
{
uint32_t
bytesRead
;
nsresult
rv
=
mCacheStream
.
ReadAt
(
aOffset
curr
aCount
&
bytesRead
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
if
(
!
bytesRead
)
{
break
;
}
aOffset
+
=
bytesRead
;
aCount
-
=
bytesRead
;
curr
+
=
bytesRead
;
}
bytes
-
>
SetLength
(
curr
-
start
)
;
return
bytes
.
forget
(
)
;
}
int64_t
ChannelMediaResource
:
:
Tell
(
)
{
return
mCacheStream
.
Tell
(
)
;
}
nsresult
ChannelMediaResource
:
:
GetCachedRanges
(
MediaByteRangeSet
&
aRanges
)
{
return
mCacheStream
.
GetCachedRanges
(
aRanges
)
;
}
void
ChannelMediaResource
:
:
Suspend
(
bool
aCloseImmediately
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Don
'
t
call
on
non
-
main
thread
"
)
;
MediaDecoderOwner
*
owner
=
mCallback
-
>
GetMediaOwner
(
)
;
if
(
!
owner
)
{
return
;
}
dom
:
:
HTMLMediaElement
*
element
=
owner
-
>
GetMediaElement
(
)
;
if
(
!
element
)
{
return
;
}
if
(
mChannel
&
&
aCloseImmediately
&
&
mCacheStream
.
IsTransportSeekable
(
)
)
{
mIgnoreClose
=
true
;
CloseChannel
(
)
;
element
-
>
DownloadSuspended
(
)
;
}
if
(
mSuspendAgent
.
Suspend
(
)
)
{
if
(
mChannel
)
{
{
MutexAutoLock
lock
(
mLock
)
;
mChannelStatistics
-
>
Stop
(
)
;
}
element
-
>
DownloadSuspended
(
)
;
}
}
}
void
ChannelMediaResource
:
:
Resume
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Don
'
t
call
on
non
-
main
thread
"
)
;
MediaDecoderOwner
*
owner
=
mCallback
-
>
GetMediaOwner
(
)
;
if
(
!
owner
)
{
return
;
}
dom
:
:
HTMLMediaElement
*
element
=
owner
-
>
GetMediaElement
(
)
;
if
(
!
element
)
{
return
;
}
if
(
mSuspendAgent
.
Resume
(
)
)
{
if
(
mChannel
)
{
{
MutexAutoLock
lock
(
mLock
)
;
mChannelStatistics
-
>
Start
(
)
;
}
mReopenOnError
=
true
;
element
-
>
DownloadResumed
(
)
;
}
else
{
int64_t
totalLength
=
mCacheStream
.
GetLength
(
)
;
if
(
totalLength
<
0
|
|
mOffset
<
totalLength
)
{
CacheClientSeek
(
mOffset
false
)
;
element
-
>
DownloadResumed
(
)
;
}
else
{
}
}
}
}
nsresult
ChannelMediaResource
:
:
RecreateChannel
(
)
{
nsLoadFlags
loadFlags
=
nsICachingChannel
:
:
LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
|
nsIChannel
:
:
LOAD_CLASSIFY_URI
|
(
mLoadInBackground
?
nsIRequest
:
:
LOAD_BACKGROUND
:
0
)
;
MediaDecoderOwner
*
owner
=
mCallback
-
>
GetMediaOwner
(
)
;
if
(
!
owner
)
{
return
NS_OK
;
}
dom
:
:
HTMLMediaElement
*
element
=
owner
-
>
GetMediaElement
(
)
;
if
(
!
element
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
element
-
>
GetDocumentLoadGroup
(
)
;
NS_ENSURE_TRUE
(
loadGroup
NS_ERROR_NULL_POINTER
)
;
nsSecurityFlags
securityFlags
=
element
-
>
ShouldCheckAllowOrigin
(
)
?
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
:
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
;
MOZ_ASSERT
(
element
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
audio
nsGkAtoms
:
:
video
)
)
;
nsContentPolicyType
contentPolicyType
=
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
audio
)
?
nsIContentPolicy
:
:
TYPE_INTERNAL_AUDIO
:
nsIContentPolicy
:
:
TYPE_INTERNAL_VIDEO
;
nsresult
rv
=
NS_NewChannel
(
getter_AddRefs
(
mChannel
)
mURI
element
securityFlags
contentPolicyType
loadGroup
nullptr
loadFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mChannel
-
>
SetContentType
(
GetContentType
(
)
.
OriginalString
(
)
)
;
mSuspendAgent
.
NotifyChannelOpened
(
mChannel
)
;
mCacheStream
.
NotifyChannelRecreated
(
)
;
return
rv
;
}
void
ChannelMediaResource
:
:
DoNotifyDataReceived
(
)
{
mDataReceivedEvent
.
Revoke
(
)
;
mCallback
-
>
NotifyBytesDownloaded
(
)
;
}
void
ChannelMediaResource
:
:
CacheClientNotifyDataReceived
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Don
'
t
call
on
non
-
main
thread
"
)
;
if
(
mDataReceivedEvent
.
IsPending
(
)
)
return
;
mDataReceivedEvent
=
NewNonOwningRunnableMethod
(
"
ChannelMediaResource
:
:
DoNotifyDataReceived
"
this
&
ChannelMediaResource
:
:
DoNotifyDataReceived
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
mDataReceivedEvent
.
get
(
)
;
SystemGroup
:
:
AbstractMainThreadFor
(
TaskCategory
:
:
Other
)
-
>
Dispatch
(
event
.
forget
(
)
)
;
}
void
ChannelMediaResource
:
:
CacheClientNotifyDataEnded
(
nsresult
aStatus
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mCallback
-
>
NotifyDataEnded
(
aStatus
)
;
}
void
ChannelMediaResource
:
:
CacheClientNotifyPrincipalChanged
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Don
'
t
call
on
non
-
main
thread
"
)
;
mCallback
-
>
NotifyPrincipalChanged
(
)
;
}
void
ChannelMediaResource
:
:
CacheClientNotifySuspendedStatusChanged
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Don
'
t
call
on
non
-
main
thread
"
)
;
mCallback
-
>
NotifySuspendedStatusChanged
(
)
;
}
nsresult
ChannelMediaResource
:
:
CacheClientSeek
(
int64_t
aOffset
bool
aResume
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Don
'
t
call
on
non
-
main
thread
"
)
;
LOG
(
"
CacheClientSeek
requested
for
aOffset
[
%
"
PRId64
"
]
for
decoder
[
%
p
]
"
aOffset
mCallback
.
get
(
)
)
;
CloseChannel
(
)
;
mOffset
=
aOffset
;
mIgnoreClose
=
true
;
if
(
aResume
)
{
mSuspendAgent
.
Resume
(
)
;
}
if
(
mSuspendAgent
.
IsSuspended
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
RecreateChannel
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
OpenChannel
(
nullptr
)
;
}
void
ChannelMediaResource
:
:
FlushCache
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
main
thread
.
"
)
;
mCacheStream
.
FlushPartialBlock
(
)
;
}
void
ChannelMediaResource
:
:
NotifyLastByteRange
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
main
thread
.
"
)
;
mCacheStream
.
NotifyDataEnded
(
NS_OK
)
;
}
nsresult
ChannelMediaResource
:
:
CacheClientSuspend
(
)
{
Suspend
(
false
)
;
return
NS_OK
;
}
nsresult
ChannelMediaResource
:
:
CacheClientResume
(
)
{
Resume
(
)
;
return
NS_OK
;
}
int64_t
ChannelMediaResource
:
:
GetNextCachedData
(
int64_t
aOffset
)
{
return
mCacheStream
.
GetNextCachedData
(
aOffset
)
;
}
int64_t
ChannelMediaResource
:
:
GetCachedDataEnd
(
int64_t
aOffset
)
{
return
mCacheStream
.
GetCachedDataEnd
(
aOffset
)
;
}
bool
ChannelMediaResource
:
:
IsDataCachedToEndOfResource
(
int64_t
aOffset
)
{
return
mCacheStream
.
IsDataCachedToEndOfStream
(
aOffset
)
;
}
void
ChannelMediaResource
:
:
EnsureCacheUpToDate
(
)
{
mCacheStream
.
EnsureCacheUpdate
(
)
;
}
bool
ChannelMediaResource
:
:
IsSuspendedByCache
(
)
{
return
mCacheStream
.
AreAllStreamsForResourceSuspended
(
)
;
}
bool
ChannelMediaResource
:
:
IsSuspended
(
)
{
return
mSuspendAgent
.
IsSuspended
(
)
;
}
void
ChannelMediaResource
:
:
SetReadMode
(
MediaCacheStream
:
:
ReadMode
aMode
)
{
mCacheStream
.
SetReadMode
(
aMode
)
;
}
void
ChannelMediaResource
:
:
SetPlaybackRate
(
uint32_t
aBytesPerSecond
)
{
mCacheStream
.
SetPlaybackRate
(
aBytesPerSecond
)
;
}
void
ChannelMediaResource
:
:
Pin
(
)
{
mCacheStream
.
Pin
(
)
;
}
void
ChannelMediaResource
:
:
Unpin
(
)
{
mCacheStream
.
Unpin
(
)
;
}
double
ChannelMediaResource
:
:
GetDownloadRate
(
bool
*
aIsReliable
)
{
MutexAutoLock
lock
(
mLock
)
;
return
mChannelStatistics
-
>
GetRate
(
aIsReliable
)
;
}
int64_t
ChannelMediaResource
:
:
GetLength
(
)
{
return
mCacheStream
.
GetLength
(
)
;
}
bool
ChannelSuspendAgent
:
:
Suspend
(
)
{
SuspendInternal
(
)
;
return
(
+
+
mSuspendCount
=
=
1
)
;
}
void
ChannelSuspendAgent
:
:
SuspendInternal
(
)
{
if
(
mChannel
)
{
bool
isPending
=
false
;
nsresult
rv
=
mChannel
-
>
IsPending
(
&
isPending
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isPending
&
&
!
mIsChannelSuspended
)
{
mChannel
-
>
Suspend
(
)
;
mIsChannelSuspended
=
true
;
}
}
}
bool
ChannelSuspendAgent
:
:
Resume
(
)
{
MOZ_ASSERT
(
IsSuspended
(
)
"
Resume
without
suspend
!
"
)
;
-
-
mSuspendCount
;
if
(
mSuspendCount
=
=
0
)
{
if
(
mChannel
&
&
mIsChannelSuspended
)
{
mChannel
-
>
Resume
(
)
;
mIsChannelSuspended
=
false
;
}
return
true
;
}
return
false
;
}
void
ChannelSuspendAgent
:
:
UpdateSuspendedStatusIfNeeded
(
)
{
if
(
!
mIsChannelSuspended
&
&
IsSuspended
(
)
)
{
SuspendInternal
(
)
;
}
}
void
ChannelSuspendAgent
:
:
NotifyChannelOpened
(
nsIChannel
*
aChannel
)
{
MOZ_ASSERT
(
aChannel
)
;
mChannel
=
aChannel
;
}
void
ChannelSuspendAgent
:
:
NotifyChannelClosing
(
)
{
MOZ_ASSERT
(
mChannel
)
;
if
(
mIsChannelSuspended
)
{
mChannel
-
>
Resume
(
)
;
mIsChannelSuspended
=
false
;
}
mChannel
=
nullptr
;
}
bool
ChannelSuspendAgent
:
:
IsSuspended
(
)
{
return
(
mSuspendCount
>
0
)
;
}
class
FileMediaResource
:
public
BaseMediaResource
{
public
:
FileMediaResource
(
MediaResourceCallback
*
aCallback
nsIChannel
*
aChannel
nsIURI
*
aURI
const
MediaContainerType
&
aContainerType
)
:
BaseMediaResource
(
aCallback
aChannel
aURI
aContainerType
)
mSize
(
-
1
)
mLock
(
"
FileMediaResource
.
mLock
"
)
mSizeInitialized
(
false
)
{
}
~
FileMediaResource
(
)
{
}
nsresult
Open
(
nsIStreamListener
*
*
aStreamListener
)
override
;
nsresult
Close
(
)
override
;
void
Suspend
(
bool
aCloseImmediately
)
override
{
}
void
Resume
(
)
override
{
}
already_AddRefed
<
nsIPrincipal
>
GetCurrentPrincipal
(
)
override
;
bool
CanClone
(
)
override
;
already_AddRefed
<
MediaResource
>
CloneData
(
MediaResourceCallback
*
aCallback
)
override
;
nsresult
ReadFromCache
(
char
*
aBuffer
int64_t
aOffset
uint32_t
aCount
)
override
;
void
SetReadMode
(
MediaCacheStream
:
:
ReadMode
aMode
)
override
{
}
void
SetPlaybackRate
(
uint32_t
aBytesPerSecond
)
override
{
}
nsresult
ReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
override
;
already_AddRefed
<
MediaByteBuffer
>
MediaReadAt
(
int64_t
aOffset
uint32_t
aCount
)
override
;
int64_t
Tell
(
)
override
;
void
Pin
(
)
override
{
}
void
Unpin
(
)
override
{
}
double
GetDownloadRate
(
bool
*
aIsReliable
)
override
{
*
aIsReliable
=
true
;
return
100
*
1024
*
1024
;
}
int64_t
GetLength
(
)
override
{
MutexAutoLock
lock
(
mLock
)
;
EnsureSizeInitialized
(
)
;
return
mSizeInitialized
?
mSize
:
0
;
}
int64_t
GetNextCachedData
(
int64_t
aOffset
)
override
{
MutexAutoLock
lock
(
mLock
)
;
EnsureSizeInitialized
(
)
;
return
(
aOffset
<
mSize
)
?
aOffset
:
-
1
;
}
int64_t
GetCachedDataEnd
(
int64_t
aOffset
)
override
{
MutexAutoLock
lock
(
mLock
)
;
EnsureSizeInitialized
(
)
;
return
std
:
:
max
(
aOffset
mSize
)
;
}
bool
IsDataCachedToEndOfResource
(
int64_t
aOffset
)
override
{
return
true
;
}
bool
IsSuspendedByCache
(
)
override
{
return
true
;
}
bool
IsSuspended
(
)
override
{
return
true
;
}
bool
IsTransportSeekable
(
)
override
{
return
true
;
}
nsresult
GetCachedRanges
(
MediaByteRangeSet
&
aRanges
)
override
;
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
BaseMediaResource
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
protected
:
nsresult
UnsafeRead
(
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
;
nsresult
UnsafeSeek
(
int32_t
aWhence
int64_t
aOffset
)
;
private
:
void
EnsureSizeInitialized
(
)
;
already_AddRefed
<
MediaByteBuffer
>
UnsafeMediaReadAt
(
int64_t
aOffset
uint32_t
aCount
)
;
int64_t
mSize
;
Mutex
mLock
;
nsCOMPtr
<
nsISeekableStream
>
mSeekable
;
nsCOMPtr
<
nsIInputStream
>
mInput
;
bool
mSizeInitialized
;
}
;
void
FileMediaResource
:
:
EnsureSizeInitialized
(
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
NS_ASSERTION
(
mInput
"
Must
have
file
input
stream
"
)
;
if
(
mSizeInitialized
)
{
return
;
}
mSizeInitialized
=
true
;
uint64_t
size
;
nsresult
res
=
mInput
-
>
Available
(
&
size
)
;
if
(
NS_SUCCEEDED
(
res
)
&
&
size
<
=
INT64_MAX
)
{
mSize
=
(
int64_t
)
size
;
mCallback
-
>
NotifyDataEnded
(
NS_OK
)
;
}
}
nsresult
FileMediaResource
:
:
GetCachedRanges
(
MediaByteRangeSet
&
aRanges
)
{
MutexAutoLock
lock
(
mLock
)
;
EnsureSizeInitialized
(
)
;
if
(
mSize
=
=
-
1
)
{
return
NS_ERROR_FAILURE
;
}
aRanges
+
=
MediaByteRange
(
0
mSize
)
;
return
NS_OK
;
}
nsresult
FileMediaResource
:
:
Open
(
nsIStreamListener
*
*
aStreamListener
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
aStreamListener
)
{
*
aStreamListener
=
nullptr
;
}
nsresult
rv
=
NS_OK
;
if
(
aStreamListener
)
{
nsCOMPtr
<
nsIFileChannel
>
fc
(
do_QueryInterface
(
mChannel
)
)
;
if
(
fc
)
{
nsCOMPtr
<
nsIFile
>
file
;
rv
=
fc
-
>
GetFile
(
getter_AddRefs
(
file
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
mInput
)
file
-
1
-
1
nsIFileInputStream
:
:
SHARE_DELETE
)
;
}
else
if
(
IsBlobURI
(
mURI
)
)
{
rv
=
NS_GetStreamForBlobURI
(
mURI
getter_AddRefs
(
mInput
)
)
;
}
}
else
{
rv
=
mChannel
-
>
Open2
(
getter_AddRefs
(
mInput
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mSeekable
=
do_QueryInterface
(
mInput
)
;
if
(
!
mSeekable
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
FileMediaResource
:
:
Close
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
mChannel
)
{
mChannel
-
>
Cancel
(
NS_ERROR_PARSED_DATA_CACHED
)
;
mChannel
=
nullptr
;
}
return
NS_OK
;
}
already_AddRefed
<
nsIPrincipal
>
FileMediaResource
:
:
GetCurrentPrincipal
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsIScriptSecurityManager
*
secMan
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
if
(
!
secMan
|
|
!
mChannel
)
return
nullptr
;
secMan
-
>
GetChannelResultPrincipal
(
mChannel
getter_AddRefs
(
principal
)
)
;
return
principal
.
forget
(
)
;
}
bool
FileMediaResource
:
:
CanClone
(
)
{
return
true
;
}
already_AddRefed
<
MediaResource
>
FileMediaResource
:
:
CloneData
(
MediaResourceCallback
*
aCallback
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
MediaDecoderOwner
*
owner
=
mCallback
-
>
GetMediaOwner
(
)
;
if
(
!
owner
)
{
return
nullptr
;
}
dom
:
:
HTMLMediaElement
*
element
=
owner
-
>
GetMediaElement
(
)
;
if
(
!
element
)
{
return
nullptr
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
element
-
>
GetDocumentLoadGroup
(
)
;
NS_ENSURE_TRUE
(
loadGroup
nullptr
)
;
MOZ_ASSERT
(
element
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
audio
nsGkAtoms
:
:
video
)
)
;
nsContentPolicyType
contentPolicyType
=
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
audio
)
?
nsIContentPolicy
:
:
TYPE_INTERNAL_AUDIO
:
nsIContentPolicy
:
:
TYPE_INTERNAL_VIDEO
;
nsLoadFlags
loadFlags
=
nsIRequest
:
:
LOAD_NORMAL
|
nsIChannel
:
:
LOAD_CLASSIFY_URI
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
mURI
element
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
contentPolicyType
loadGroup
nullptr
loadFlags
)
;
if
(
NS_FAILED
(
rv
)
)
return
nullptr
;
RefPtr
<
MediaResource
>
resource
(
new
FileMediaResource
(
aCallback
channel
mURI
GetContentType
(
)
)
)
;
return
resource
.
forget
(
)
;
}
nsresult
FileMediaResource
:
:
ReadFromCache
(
char
*
aBuffer
int64_t
aOffset
uint32_t
aCount
)
{
MutexAutoLock
lock
(
mLock
)
;
EnsureSizeInitialized
(
)
;
if
(
!
aCount
)
{
return
NS_OK
;
}
int64_t
offset
=
0
;
nsresult
res
=
mSeekable
-
>
Tell
(
&
offset
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
res
=
mSeekable
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
aOffset
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
uint32_t
bytesRead
=
0
;
do
{
uint32_t
x
=
0
;
uint32_t
bytesToRead
=
aCount
-
bytesRead
;
res
=
mInput
-
>
Read
(
aBuffer
bytesToRead
&
x
)
;
bytesRead
+
=
x
;
if
(
!
x
)
{
res
=
NS_ERROR_FAILURE
;
}
}
while
(
bytesRead
!
=
aCount
&
&
res
=
=
NS_OK
)
;
nsresult
seekres
=
mSeekable
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
offset
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
return
seekres
;
}
nsresult
FileMediaResource
:
:
UnsafeRead
(
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
{
EnsureSizeInitialized
(
)
;
return
mInput
-
>
Read
(
aBuffer
aCount
aBytes
)
;
}
nsresult
FileMediaResource
:
:
ReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
{
NS_ASSERTION
(
!
NS_IsMainThread
(
)
"
Don
'
t
call
on
main
thread
"
)
;
nsresult
rv
;
{
MutexAutoLock
lock
(
mLock
)
;
rv
=
UnsafeSeek
(
nsISeekableStream
:
:
NS_SEEK_SET
aOffset
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
UnsafeRead
(
aBuffer
aCount
aBytes
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
DispatchBytesConsumed
(
*
aBytes
aOffset
)
;
}
return
rv
;
}
already_AddRefed
<
MediaByteBuffer
>
FileMediaResource
:
:
MediaReadAt
(
int64_t
aOffset
uint32_t
aCount
)
{
NS_ASSERTION
(
!
NS_IsMainThread
(
)
"
Don
'
t
call
on
main
thread
"
)
;
MutexAutoLock
lock
(
mLock
)
;
return
UnsafeMediaReadAt
(
aOffset
aCount
)
;
}
already_AddRefed
<
MediaByteBuffer
>
FileMediaResource
:
:
UnsafeMediaReadAt
(
int64_t
aOffset
uint32_t
aCount
)
{
RefPtr
<
MediaByteBuffer
>
bytes
=
new
MediaByteBuffer
(
)
;
bool
ok
=
bytes
-
>
SetLength
(
aCount
fallible
)
;
NS_ENSURE_TRUE
(
ok
nullptr
)
;
nsresult
rv
=
UnsafeSeek
(
nsISeekableStream
:
:
NS_SEEK_SET
aOffset
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
char
*
curr
=
reinterpret_cast
<
char
*
>
(
bytes
-
>
Elements
(
)
)
;
const
char
*
start
=
curr
;
while
(
aCount
>
0
)
{
uint32_t
bytesRead
;
rv
=
UnsafeRead
(
curr
aCount
&
bytesRead
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
if
(
!
bytesRead
)
{
break
;
}
aCount
-
=
bytesRead
;
curr
+
=
bytesRead
;
}
bytes
-
>
SetLength
(
curr
-
start
)
;
return
bytes
.
forget
(
)
;
}
nsresult
FileMediaResource
:
:
UnsafeSeek
(
int32_t
aWhence
int64_t
aOffset
)
{
NS_ASSERTION
(
!
NS_IsMainThread
(
)
"
Don
'
t
call
on
main
thread
"
)
;
if
(
!
mSeekable
)
return
NS_ERROR_FAILURE
;
EnsureSizeInitialized
(
)
;
return
mSeekable
-
>
Seek
(
aWhence
aOffset
)
;
}
int64_t
FileMediaResource
:
:
Tell
(
)
{
MutexAutoLock
lock
(
mLock
)
;
EnsureSizeInitialized
(
)
;
int64_t
offset
=
0
;
if
(
!
mSeekable
|
|
NS_FAILED
(
mSeekable
-
>
Tell
(
&
offset
)
)
)
return
mSize
;
return
offset
;
}
already_AddRefed
<
MediaResource
>
MediaResource
:
:
Create
(
MediaResourceCallback
*
aCallback
nsIChannel
*
aChannel
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
MediaResource
:
:
Open
called
on
non
-
main
thread
"
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
nsAutoCString
contentTypeString
;
aChannel
-
>
GetContentType
(
contentTypeString
)
;
Maybe
<
MediaContainerType
>
containerType
=
MakeMediaContainerType
(
contentTypeString
)
;
if
(
!
containerType
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIFileChannel
>
fc
=
do_QueryInterface
(
aChannel
)
;
RefPtr
<
MediaResource
>
resource
;
if
(
fc
|
|
IsBlobURI
(
uri
)
)
{
resource
=
new
FileMediaResource
(
aCallback
aChannel
uri
*
containerType
)
;
}
else
{
resource
=
new
ChannelMediaResource
(
aCallback
aChannel
uri
*
containerType
)
;
}
return
resource
.
forget
(
)
;
}
void
BaseMediaResource
:
:
SetLoadInBackground
(
bool
aLoadInBackground
)
{
if
(
aLoadInBackground
=
=
mLoadInBackground
)
{
return
;
}
mLoadInBackground
=
aLoadInBackground
;
if
(
!
mChannel
)
{
return
;
}
MediaDecoderOwner
*
owner
=
mCallback
-
>
GetMediaOwner
(
)
;
if
(
!
owner
)
{
NS_WARNING
(
"
Null
owner
in
MediaResource
:
:
SetLoadInBackground
(
)
"
)
;
return
;
}
dom
:
:
HTMLMediaElement
*
element
=
owner
-
>
GetMediaElement
(
)
;
if
(
!
element
)
{
NS_WARNING
(
"
Null
element
in
MediaResource
:
:
SetLoadInBackground
(
)
"
)
;
return
;
}
bool
isPending
=
false
;
if
(
NS_SUCCEEDED
(
mChannel
-
>
IsPending
(
&
isPending
)
)
&
&
isPending
)
{
nsLoadFlags
loadFlags
;
DebugOnly
<
nsresult
>
rv
=
mChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
GetLoadFlags
(
)
failed
!
"
)
;
if
(
aLoadInBackground
)
{
loadFlags
|
=
nsIRequest
:
:
LOAD_BACKGROUND
;
}
else
{
loadFlags
&
=
~
nsIRequest
:
:
LOAD_BACKGROUND
;
}
ModifyLoadFlags
(
loadFlags
)
;
}
}
void
BaseMediaResource
:
:
ModifyLoadFlags
(
nsLoadFlags
aFlags
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
nsresult
rv
=
mChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
GetLoadGroup
(
)
failed
!
"
)
;
nsresult
status
;
mChannel
-
>
GetStatus
(
&
status
)
;
bool
inLoadGroup
=
false
;
if
(
loadGroup
)
{
rv
=
loadGroup
-
>
RemoveRequest
(
mChannel
nullptr
status
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
inLoadGroup
=
true
;
}
}
rv
=
mChannel
-
>
SetLoadFlags
(
aFlags
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
SetLoadFlags
(
)
failed
!
"
)
;
if
(
inLoadGroup
)
{
rv
=
loadGroup
-
>
AddRequest
(
mChannel
nullptr
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
AddRequest
(
)
failed
!
"
)
;
}
}
void
BaseMediaResource
:
:
DispatchBytesConsumed
(
int64_t
aNumBytes
int64_t
aOffset
)
{
if
(
aNumBytes
<
=
0
)
{
return
;
}
mCallback
-
>
NotifyBytesConsumed
(
aNumBytes
aOffset
)
;
}
nsresult
MediaResourceIndex
:
:
Read
(
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
{
NS_ASSERTION
(
!
NS_IsMainThread
(
)
"
Don
'
t
call
on
main
thread
"
)
;
nsresult
rv
=
ReadAt
(
mOffset
aBuffer
aCount
aBytes
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mOffset
+
=
*
aBytes
;
return
NS_OK
;
}
nsresult
MediaResourceIndex
:
:
ReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
const
{
*
aBytes
=
0
;
while
(
aCount
>
0
)
{
uint32_t
bytesRead
=
0
;
nsresult
rv
=
mResource
-
>
ReadAt
(
aOffset
aBuffer
aCount
&
bytesRead
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
bytesRead
)
{
break
;
}
*
aBytes
+
=
bytesRead
;
aOffset
+
=
bytesRead
;
aBuffer
+
=
bytesRead
;
aCount
-
=
bytesRead
;
}
return
NS_OK
;
}
nsresult
MediaResourceIndex
:
:
Seek
(
int32_t
aWhence
int64_t
aOffset
)
{
switch
(
aWhence
)
{
case
SEEK_SET
:
break
;
case
SEEK_CUR
:
aOffset
+
=
mOffset
;
break
;
case
SEEK_END
:
{
int64_t
length
=
mResource
-
>
GetLength
(
)
;
if
(
length
=
=
-
1
|
|
length
-
aOffset
<
0
)
{
return
NS_ERROR_FAILURE
;
}
aOffset
=
mResource
-
>
GetLength
(
)
-
aOffset
;
}
break
;
default
:
return
NS_ERROR_FAILURE
;
}
mOffset
=
aOffset
;
return
NS_OK
;
}
}
#
undef
LOG
