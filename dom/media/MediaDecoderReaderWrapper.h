#
ifndef
MediaDecoderReaderWrapper_h_
#
define
MediaDecoderReaderWrapper_h_
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
MediaDecoderReader
.
h
"
namespace
mozilla
{
class
StartTimeRendezvous
;
typedef
MozPromise
<
bool
bool
false
>
HaveStartTimePromise
;
class
MediaDecoderReaderWrapper
{
typedef
MediaDecoderReader
:
:
MetadataPromise
MetadataPromise
;
typedef
MediaDecoderReader
:
:
AudioDataPromise
AudioDataPromise
;
typedef
MediaDecoderReader
:
:
VideoDataPromise
VideoDataPromise
;
typedef
MediaDecoderReader
:
:
SeekPromise
SeekPromise
;
typedef
MediaDecoderReader
:
:
WaitForDataPromise
WaitForDataPromise
;
typedef
MediaDecoderReader
:
:
BufferedUpdatePromise
BufferedUpdatePromise
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDecoderReaderWrapper
)
;
public
:
MediaDecoderReaderWrapper
(
bool
aIsRealTime
AbstractThread
*
aOwnerThread
MediaDecoderReader
*
aReader
)
;
media
:
:
TimeUnit
StartTime
(
)
const
;
RefPtr
<
MetadataPromise
>
ReadMetadata
(
)
;
RefPtr
<
HaveStartTimePromise
>
AwaitStartTime
(
)
;
RefPtr
<
AudioDataPromise
>
RequestAudioData
(
)
;
RefPtr
<
VideoDataPromise
>
RequestVideoData
(
bool
aSkipToNextKeyframe
media
:
:
TimeUnit
aTimeThreshold
)
;
RefPtr
<
SeekPromise
>
Seek
(
SeekTarget
aTarget
media
:
:
TimeUnit
aEndTime
)
;
RefPtr
<
WaitForDataPromise
>
WaitForData
(
MediaData
:
:
Type
aType
)
;
RefPtr
<
BufferedUpdatePromise
>
UpdateBufferedWithPromise
(
)
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
;
void
ReleaseMediaResources
(
)
;
void
SetIdle
(
)
;
void
ResetDecode
(
)
;
nsresult
Init
(
)
{
return
mReader
-
>
Init
(
)
;
}
bool
IsWaitForDataSupported
(
)
const
{
return
mReader
-
>
IsWaitForDataSupported
(
)
;
}
bool
IsAsync
(
)
const
{
return
mReader
-
>
IsAsync
(
)
;
}
bool
UseBufferingHeuristics
(
)
const
{
return
mReader
-
>
UseBufferingHeuristics
(
)
;
}
bool
ForceZeroStartTime
(
)
const
{
return
mReader
-
>
ForceZeroStartTime
(
)
;
}
bool
VideoIsHardwareAccelerated
(
)
const
{
return
mReader
-
>
VideoIsHardwareAccelerated
(
)
;
}
TimedMetadataEventSource
&
TimedMetadataEvent
(
)
{
return
mReader
-
>
TimedMetadataEvent
(
)
;
}
size_t
SizeOfAudioQueueInFrames
(
)
const
{
return
mReader
-
>
SizeOfAudioQueueInFrames
(
)
;
}
size_t
SizeOfVideoQueueInFrames
(
)
const
{
return
mReader
-
>
SizeOfVideoQueueInFrames
(
)
;
}
void
ReadUpdatedMetadata
(
MediaInfo
*
aInfo
)
{
mReader
-
>
ReadUpdatedMetadata
(
aInfo
)
;
}
AbstractCanonical
<
media
:
:
TimeIntervals
>
*
CanonicalBuffered
(
)
{
return
mReader
-
>
CanonicalBuffered
(
)
;
}
#
ifdef
MOZ_EME
void
SetCDMProxy
(
CDMProxy
*
aProxy
)
{
mReader
-
>
SetCDMProxy
(
aProxy
)
;
}
#
endif
private
:
~
MediaDecoderReaderWrapper
(
)
;
void
OnMetadataRead
(
MetadataHolder
*
aMetadata
)
;
void
OnMetadataNotRead
(
)
{
}
void
OnSampleDecoded
(
MediaData
*
aSample
)
;
void
OnNotDecoded
(
)
{
}
const
bool
mForceZeroStartTime
;
const
RefPtr
<
AbstractThread
>
mOwnerThread
;
const
RefPtr
<
MediaDecoderReader
>
mReader
;
bool
mShutdown
=
false
;
RefPtr
<
StartTimeRendezvous
>
mStartTimeRendezvous
;
}
;
}
#
endif
