#
ifndef
mozilla_dom_media_RemoteImageHolder_h
#
define
mozilla_dom_media_RemoteImageHolder_h
#
include
"
MediaData
.
h
"
#
include
"
ipc
/
IPCMessageUtils
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
include
"
mozilla
/
layers
/
VideoBridgeUtils
.
h
"
namespace
mozilla
{
namespace
layers
{
class
BufferRecycleBin
;
class
IGPUVideoSurfaceManager
;
class
SurfaceDescriptor
;
}
class
RemoteImageHolder
final
{
friend
struct
ipc
:
:
IPDLParamTraits
<
RemoteImageHolder
>
;
public
:
RemoteImageHolder
(
)
;
RemoteImageHolder
(
layers
:
:
IGPUVideoSurfaceManager
*
aManager
layers
:
:
VideoBridgeSource
aSource
const
gfx
:
:
IntSize
&
aSize
const
layers
:
:
SurfaceDescriptor
&
aSD
)
;
RemoteImageHolder
(
RemoteImageHolder
&
&
aOther
)
;
RemoteImageHolder
(
const
RemoteImageHolder
&
aOther
)
=
delete
;
RemoteImageHolder
&
operator
=
(
const
RemoteImageHolder
&
aOther
)
=
delete
;
~
RemoteImageHolder
(
)
;
bool
IsEmpty
(
)
const
{
return
mSD
.
isNothing
(
)
;
}
already_AddRefed
<
layers
:
:
Image
>
TransferToImage
(
layers
:
:
BufferRecycleBin
*
aBufferRecycleBin
=
nullptr
)
;
private
:
already_AddRefed
<
layers
:
:
Image
>
DeserializeImage
(
layers
:
:
BufferRecycleBin
*
aBufferRecycleBin
)
;
layers
:
:
VideoBridgeSource
mSource
=
layers
:
:
VideoBridgeSource
:
:
GpuProcess
;
gfx
:
:
IntSize
mSize
;
Maybe
<
layers
:
:
SurfaceDescriptor
>
mSD
;
RefPtr
<
layers
:
:
IGPUVideoSurfaceManager
>
mManager
;
}
;
template
<
>
struct
ipc
:
:
IPDLParamTraits
<
RemoteImageHolder
>
{
static
void
Write
(
IPC
:
:
MessageWriter
*
aWriter
IProtocol
*
aActor
RemoteImageHolder
&
&
aParam
)
;
static
bool
Read
(
IPC
:
:
MessageReader
*
aReader
IProtocol
*
aActor
RemoteImageHolder
*
aResult
)
;
}
;
}
#
endif
