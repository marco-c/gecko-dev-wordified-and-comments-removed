#
ifndef
include_dom_media_ipc_ShmemRecycleAllocator_h
#
define
include_dom_media_ipc_ShmemRecycleAllocator_h
#
include
"
mozilla
/
ShmemPool
.
h
"
namespace
mozilla
{
class
ShmemRecycleTicket
{
public
:
NS_INLINE_DECL_REFCOUNTING_ONEVENTTARGET
(
ShmemRecycleTicket
)
ShmemRecycleTicket
(
)
=
default
;
private
:
template
<
class
T
>
friend
class
ShmemRecycleAllocator
;
~
ShmemRecycleTicket
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mUsedShmems
.
IsEmpty
(
)
)
;
}
AutoTArray
<
ShmemBuffer
4
>
mUsedShmems
;
}
;
template
<
class
T
>
class
ShmemRecycleAllocator
{
public
:
explicit
ShmemRecycleAllocator
(
T
*
aActor
)
:
mActor
(
aActor
)
mPool
(
1
ShmemPool
:
:
PoolType
:
:
DynamicPool
)
{
}
ShmemBuffer
AllocateBuffer
(
size_t
aSize
ShmemRecycleTicket
*
aTicket
=
nullptr
ShmemPool
:
:
AllocationPolicy
aPolicy
=
ShmemPool
:
:
AllocationPolicy
:
:
Unsafe
)
{
ShmemBuffer
buffer
=
mPool
.
Get
(
mActor
aSize
aPolicy
)
;
if
(
!
buffer
.
Valid
(
)
)
{
return
buffer
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aSize
<
=
buffer
.
Get
(
)
.
Size
<
uint8_t
>
(
)
)
;
if
(
aTicket
)
{
aTicket
-
>
mUsedShmems
.
AppendElement
(
buffer
.
Get
(
)
)
;
}
else
{
mUsedShmems
.
AppendElement
(
buffer
.
Get
(
)
)
;
}
mNeedCleanup
=
true
;
return
buffer
;
}
void
ReleaseBuffer
(
ShmemBuffer
&
&
aBuffer
)
{
mPool
.
Put
(
std
:
:
move
(
aBuffer
)
)
;
}
void
ReleaseAllBuffers
(
)
{
for
(
auto
&
&
mem
:
mUsedShmems
)
{
ReleaseBuffer
(
ShmemBuffer
(
mem
.
Get
(
)
)
)
;
}
mUsedShmems
.
Clear
(
)
;
}
void
ReleaseTicket
(
ShmemRecycleTicket
*
aTicket
)
{
for
(
auto
&
&
mem
:
aTicket
-
>
mUsedShmems
)
{
ReleaseBuffer
(
ShmemBuffer
(
mem
.
Get
(
)
)
)
;
}
aTicket
-
>
mUsedShmems
.
Clear
(
)
;
}
void
CleanupShmemRecycleAllocator
(
)
{
ReleaseAllBuffers
(
)
;
mPool
.
Cleanup
(
mActor
)
;
mNeedCleanup
=
false
;
}
~
ShmemRecycleAllocator
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mUsedShmems
.
IsEmpty
(
)
&
&
!
mNeedCleanup
"
Shmems
not
all
deallocated
"
)
;
}
private
:
T
*
const
mActor
;
ShmemPool
mPool
;
AutoTArray
<
ShmemBuffer
4
>
mUsedShmems
;
bool
mNeedCleanup
=
false
;
}
;
}
#
endif
