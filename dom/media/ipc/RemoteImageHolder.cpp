#
include
"
RemoteImageHolder
.
h
"
#
include
"
GPUVideoImage
.
h
"
#
include
"
mozilla
/
PRemoteDecoderChild
.
h
"
#
include
"
mozilla
/
RemoteDecoderManagerChild
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
using
namespace
layers
;
already_AddRefed
<
Image
>
RemoteImageHolder
:
:
DeserializeImage
(
layers
:
:
BufferRecycleBin
*
aBufferRecycleBin
)
{
MOZ_ASSERT
(
mSD
.
type
(
)
=
=
SurfaceDescriptor
:
:
TSurfaceDescriptorBuffer
)
;
const
SurfaceDescriptorBuffer
&
sdBuffer
=
mSD
.
get_SurfaceDescriptorBuffer
(
)
;
MOZ_ASSERT
(
sdBuffer
.
desc
(
)
.
type
(
)
=
=
BufferDescriptor
:
:
TYCbCrDescriptor
)
;
if
(
sdBuffer
.
desc
(
)
.
type
(
)
!
=
BufferDescriptor
:
:
TYCbCrDescriptor
|
|
!
aBufferRecycleBin
)
{
return
nullptr
;
}
const
YCbCrDescriptor
&
descriptor
=
sdBuffer
.
desc
(
)
.
get_YCbCrDescriptor
(
)
;
uint8_t
*
buffer
=
nullptr
;
const
MemoryOrShmem
&
memOrShmem
=
sdBuffer
.
data
(
)
;
switch
(
memOrShmem
.
type
(
)
)
{
case
MemoryOrShmem
:
:
Tuintptr_t
:
buffer
=
reinterpret_cast
<
uint8_t
*
>
(
memOrShmem
.
get_uintptr_t
(
)
)
;
break
;
case
MemoryOrShmem
:
:
TShmem
:
buffer
=
memOrShmem
.
get_Shmem
(
)
.
get
<
uint8_t
>
(
)
;
break
;
default
:
MOZ_ASSERT
(
false
"
Unknown
MemoryOrShmem
type
"
)
;
}
if
(
!
buffer
)
{
return
nullptr
;
}
PlanarYCbCrData
pData
;
pData
.
mYSize
=
descriptor
.
ySize
(
)
;
pData
.
mYStride
=
descriptor
.
yStride
(
)
;
pData
.
mCbCrSize
=
descriptor
.
cbCrSize
(
)
;
pData
.
mCbCrStride
=
descriptor
.
cbCrStride
(
)
;
pData
.
mYSkip
=
pData
.
mCbSkip
=
pData
.
mCrSkip
=
0
;
pData
.
mPicX
=
pData
.
mPicY
=
0
;
pData
.
mPicSize
=
mSize
;
pData
.
mStereoMode
=
descriptor
.
stereoMode
(
)
;
pData
.
mColorDepth
=
descriptor
.
colorDepth
(
)
;
pData
.
mYUVColorSpace
=
descriptor
.
yUVColorSpace
(
)
;
pData
.
mYChannel
=
ImageDataSerializer
:
:
GetYChannel
(
buffer
descriptor
)
;
pData
.
mCbChannel
=
ImageDataSerializer
:
:
GetCbChannel
(
buffer
descriptor
)
;
pData
.
mCrChannel
=
ImageDataSerializer
:
:
GetCrChannel
(
buffer
descriptor
)
;
RefPtr
<
RecyclingPlanarYCbCrImage
>
image
=
new
RecyclingPlanarYCbCrImage
(
aBufferRecycleBin
)
;
bool
setData
=
image
-
>
CopyData
(
pData
)
;
MOZ_ASSERT
(
setData
)
;
switch
(
memOrShmem
.
type
(
)
)
{
case
MemoryOrShmem
:
:
Tuintptr_t
:
delete
[
]
reinterpret_cast
<
uint8_t
*
>
(
memOrShmem
.
get_uintptr_t
(
)
)
;
break
;
case
MemoryOrShmem
:
:
TShmem
:
break
;
default
:
MOZ_ASSERT
(
false
"
Unknown
MemoryOrShmem
type
"
)
;
}
if
(
!
setData
)
{
return
nullptr
;
}
return
image
.
forget
(
)
;
}
already_AddRefed
<
layers
:
:
Image
>
RemoteImageHolder
:
:
TransferToImage
(
layers
:
:
BufferRecycleBin
*
aBufferRecycleBin
)
{
if
(
mEmpty
)
{
return
nullptr
;
}
RefPtr
<
Image
>
image
;
if
(
mSD
.
type
(
)
=
=
SurfaceDescriptor
:
:
TSurfaceDescriptorBuffer
)
{
image
=
DeserializeImage
(
aBufferRecycleBin
)
;
}
else
{
RemoteDecoderManagerChild
*
manager
=
mSource
=
=
VideoBridgeSource
:
:
GpuProcess
?
RemoteDecoderManagerChild
:
:
GetGPUProcessSingleton
(
)
:
RemoteDecoderManagerChild
:
:
GetRDDProcessSingleton
(
)
;
SurfaceDescriptorRemoteDecoder
remoteSD
=
static_cast
<
const
SurfaceDescriptorGPUVideo
&
>
(
mSD
)
;
remoteSD
.
source
(
)
=
Some
(
mSource
)
;
image
=
new
GPUVideoImage
(
manager
remoteSD
mSize
)
;
}
mEmpty
=
true
;
return
image
.
forget
(
)
;
}
RemoteImageHolder
:
:
~
RemoteImageHolder
(
)
{
if
(
!
mEmpty
&
&
!
XRE_IsGPUProcess
(
)
&
&
!
XRE_IsRDDProcess
(
)
&
&
mSD
.
type
(
)
!
=
SurfaceDescriptor
:
:
TSurfaceDescriptorBuffer
)
{
RefPtr
<
Image
>
image
=
TransferToImage
(
)
;
}
}
}
