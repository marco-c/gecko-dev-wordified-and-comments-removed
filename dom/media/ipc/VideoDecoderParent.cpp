#
include
"
VideoDecoderParent
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
base
/
thread
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
mozilla
/
layers
/
VideoBridgeChild
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
VideoDecoderManagerParent
.
h
"
#
ifdef
XP_WIN
#
include
"
WMFDecoderModule
.
h
"
#
endif
namespace
mozilla
{
namespace
dom
{
using
base
:
:
Thread
;
using
namespace
ipc
;
using
namespace
layers
;
using
namespace
gfx
;
VideoDecoderParent
:
:
VideoDecoderParent
(
VideoDecoderManagerParent
*
aParent
TaskQueue
*
aManagerTaskQueue
TaskQueue
*
aDecodeTaskQueue
)
:
mParent
(
aParent
)
mManagerTaskQueue
(
aManagerTaskQueue
)
mDecodeTaskQueue
(
aDecodeTaskQueue
)
mDestroyed
(
false
)
{
MOZ_COUNT_CTOR
(
VideoDecoderParent
)
;
mIPDLSelfRef
=
this
;
}
VideoDecoderParent
:
:
~
VideoDecoderParent
(
)
{
MOZ_COUNT_DTOR
(
VideoDecoderParent
)
;
}
void
VideoDecoderParent
:
:
Destroy
(
)
{
mDecodeTaskQueue
-
>
AwaitShutdownAndIdle
(
)
;
mDestroyed
=
true
;
mIPDLSelfRef
=
nullptr
;
}
bool
VideoDecoderParent
:
:
RecvInit
(
const
VideoInfo
&
aInfo
const
layers
:
:
LayersBackend
&
aBackend
)
{
CreateDecoderParams
params
(
aInfo
)
;
params
.
mTaskQueue
=
mDecodeTaskQueue
;
params
.
mCallback
=
this
;
params
.
mLayersBackend
=
aBackend
;
params
.
mImageContainer
=
new
layers
:
:
ImageContainer
(
)
;
#
ifdef
XP_WIN
WMFDecoderModule
:
:
Init
(
)
;
RefPtr
<
WMFDecoderModule
>
pdm
(
new
WMFDecoderModule
(
)
)
;
pdm
-
>
Startup
(
)
;
mDecoder
=
pdm
-
>
CreateVideoDecoder
(
params
)
;
if
(
!
mDecoder
)
{
Unused
<
<
SendInitFailed
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
)
;
return
true
;
}
#
else
MOZ_ASSERT
(
false
"
Can
'
t
use
RemoteVideoDecoder
on
non
-
Windows
platforms
yet
"
)
;
#
endif
RefPtr
<
VideoDecoderParent
>
self
=
this
;
mDecoder
-
>
Init
(
)
-
>
Then
(
mManagerTaskQueue
__func__
[
self
]
(
TrackInfo
:
:
TrackType
aTrack
)
{
if
(
!
self
-
>
mDestroyed
)
{
nsCString
hardwareReason
;
bool
hardwareAccelerated
=
self
-
>
mDecoder
-
>
IsHardwareAccelerated
(
hardwareReason
)
;
Unused
<
<
self
-
>
SendInitComplete
(
hardwareAccelerated
hardwareReason
)
;
}
}
[
self
]
(
MediaResult
aReason
)
{
if
(
!
self
-
>
mDestroyed
)
{
Unused
<
<
self
-
>
SendInitFailed
(
aReason
)
;
}
}
)
;
return
true
;
}
bool
VideoDecoderParent
:
:
RecvInput
(
const
MediaRawDataIPDL
&
aData
)
{
RefPtr
<
MediaRawData
>
data
=
new
MediaRawData
(
aData
.
buffer
(
)
.
get
<
uint8_t
>
(
)
aData
.
buffer
(
)
.
Size
<
uint8_t
>
(
)
)
;
data
-
>
mOffset
=
aData
.
base
(
)
.
offset
(
)
;
data
-
>
mTime
=
aData
.
base
(
)
.
time
(
)
;
data
-
>
mTimecode
=
aData
.
base
(
)
.
timecode
(
)
;
data
-
>
mDuration
=
aData
.
base
(
)
.
duration
(
)
;
data
-
>
mKeyframe
=
aData
.
base
(
)
.
keyframe
(
)
;
DeallocShmem
(
aData
.
buffer
(
)
)
;
mDecoder
-
>
Input
(
data
)
;
return
true
;
}
bool
VideoDecoderParent
:
:
RecvFlush
(
)
{
MOZ_ASSERT
(
!
mDestroyed
)
;
mDecoder
-
>
Flush
(
)
;
return
true
;
}
bool
VideoDecoderParent
:
:
RecvDrain
(
)
{
MOZ_ASSERT
(
!
mDestroyed
)
;
mDecoder
-
>
Drain
(
)
;
return
true
;
}
bool
VideoDecoderParent
:
:
RecvShutdown
(
)
{
MOZ_ASSERT
(
!
mDestroyed
)
;
mDecoder
-
>
Shutdown
(
)
;
mDecoder
=
nullptr
;
return
true
;
}
bool
VideoDecoderParent
:
:
RecvSetSeekThreshold
(
const
int64_t
&
aTime
)
{
MOZ_ASSERT
(
!
mDestroyed
)
;
mDecoder
-
>
SetSeekThreshold
(
media
:
:
TimeUnit
:
:
FromMicroseconds
(
aTime
)
)
;
return
true
;
}
void
VideoDecoderParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
MOZ_ASSERT
(
!
mDestroyed
)
;
if
(
mDecoder
)
{
mDecoder
-
>
Shutdown
(
)
;
mDecoder
=
nullptr
;
}
if
(
mDecodeTaskQueue
)
{
mDecodeTaskQueue
-
>
BeginShutdown
(
)
;
}
}
void
VideoDecoderParent
:
:
Output
(
MediaData
*
aData
)
{
MOZ_ASSERT
(
mDecodeTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
RefPtr
<
VideoDecoderParent
>
self
=
this
;
RefPtr
<
MediaData
>
data
=
aData
;
mManagerTaskQueue
-
>
Dispatch
(
NS_NewRunnableFunction
(
[
self
data
]
(
)
{
if
(
self
-
>
mDestroyed
)
{
return
;
}
MOZ_ASSERT
(
data
-
>
mType
=
=
MediaData
:
:
VIDEO_DATA
"
Can
only
decode
videos
using
VideoDecoderParent
!
"
)
;
VideoData
*
video
=
static_cast
<
VideoData
*
>
(
data
.
get
(
)
)
;
MOZ_ASSERT
(
video
-
>
mImage
"
Decoded
video
must
output
a
layer
:
:
Image
to
be
used
with
VideoDecoderParent
"
)
;
RefPtr
<
TextureClient
>
texture
=
video
-
>
mImage
-
>
GetTextureClient
(
VideoBridgeChild
:
:
GetSingleton
(
)
)
;
if
(
texture
&
&
!
texture
-
>
IsAddedToCompositableClient
(
)
)
{
texture
-
>
InitIPDLActor
(
VideoBridgeChild
:
:
GetSingleton
(
)
)
;
texture
-
>
SetAddedToCompositableClient
(
)
;
}
VideoDataIPDL
output
(
MediaDataIPDL
(
data
-
>
mOffset
data
-
>
mTime
data
-
>
mTimecode
data
-
>
mDuration
data
-
>
mFrames
data
-
>
mKeyframe
)
video
-
>
mDisplay
texture
?
self
-
>
mParent
-
>
StoreImage
(
texture
)
:
SurfaceDescriptorGPUVideo
(
0
)
video
-
>
mFrameID
)
;
Unused
<
<
self
-
>
SendOutput
(
output
)
;
}
)
)
;
}
void
VideoDecoderParent
:
:
Error
(
const
MediaResult
&
aError
)
{
MOZ_ASSERT
(
mDecodeTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
RefPtr
<
VideoDecoderParent
>
self
=
this
;
MediaResult
error
=
aError
;
mManagerTaskQueue
-
>
Dispatch
(
NS_NewRunnableFunction
(
[
self
error
]
(
)
{
if
(
!
self
-
>
mDestroyed
)
{
Unused
<
<
self
-
>
SendError
(
error
)
;
}
}
)
)
;
}
void
VideoDecoderParent
:
:
InputExhausted
(
)
{
MOZ_ASSERT
(
mDecodeTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
RefPtr
<
VideoDecoderParent
>
self
=
this
;
mManagerTaskQueue
-
>
Dispatch
(
NS_NewRunnableFunction
(
[
self
]
(
)
{
if
(
!
self
-
>
mDestroyed
)
{
Unused
<
<
self
-
>
SendInputExhausted
(
)
;
}
}
)
)
;
}
void
VideoDecoderParent
:
:
DrainComplete
(
)
{
MOZ_ASSERT
(
mDecodeTaskQueue
-
>
IsCurrentThreadIn
(
)
)
;
RefPtr
<
VideoDecoderParent
>
self
=
this
;
mManagerTaskQueue
-
>
Dispatch
(
NS_NewRunnableFunction
(
[
self
]
(
)
{
if
(
!
self
-
>
mDestroyed
)
{
Unused
<
<
self
-
>
SendDrainComplete
(
)
;
}
}
)
)
;
}
bool
VideoDecoderParent
:
:
OnReaderTaskQueue
(
)
{
return
mParent
-
>
OnManagerThread
(
)
;
}
}
}
