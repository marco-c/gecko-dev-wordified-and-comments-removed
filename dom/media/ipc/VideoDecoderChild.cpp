#
include
"
VideoDecoderChild
.
h
"
#
include
"
VideoDecoderManagerChild
.
h
"
#
include
"
mozilla
/
layers
/
TextureClient
.
h
"
#
include
"
base
/
thread
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
GPUVideoImage
.
h
"
namespace
mozilla
{
namespace
dom
{
using
base
:
:
Thread
;
using
namespace
ipc
;
using
namespace
layers
;
using
namespace
gfx
;
VideoDecoderChild
:
:
VideoDecoderChild
(
)
:
mThread
(
VideoDecoderManagerChild
:
:
GetManagerThread
(
)
)
mCanSend
(
false
)
mInitialized
(
false
)
mIsHardwareAccelerated
(
false
)
mNeedNewDecoder
(
false
)
{
}
VideoDecoderChild
:
:
~
VideoDecoderChild
(
)
{
AssertOnManagerThread
(
)
;
mInitPromise
.
RejectIfExists
(
NS_ERROR_DOM_MEDIA_CANCELED
__func__
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
VideoDecoderChild
:
:
RecvOutput
(
const
VideoDataIPDL
&
aData
)
{
AssertOnManagerThread
(
)
;
VideoInfo
info
(
aData
.
display
(
)
.
width
aData
.
display
(
)
.
height
)
;
RefPtr
<
Image
>
image
=
new
GPUVideoImage
(
GetManager
(
)
aData
.
sd
(
)
aData
.
display
(
)
)
;
RefPtr
<
VideoData
>
video
=
VideoData
:
:
CreateFromImage
(
info
aData
.
base
(
)
.
offset
(
)
aData
.
base
(
)
.
time
(
)
aData
.
base
(
)
.
duration
(
)
image
aData
.
base
(
)
.
keyframe
(
)
aData
.
base
(
)
.
timecode
(
)
IntRect
(
)
)
;
mDecodedData
.
AppendElement
(
Move
(
video
)
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
VideoDecoderChild
:
:
RecvInputExhausted
(
)
{
AssertOnManagerThread
(
)
;
mDecodePromise
.
ResolveIfExists
(
mDecodedData
__func__
)
;
mDecodedData
.
Clear
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
VideoDecoderChild
:
:
RecvDrainComplete
(
)
{
AssertOnManagerThread
(
)
;
mDrainPromise
.
ResolveIfExists
(
mDecodedData
__func__
)
;
mDecodedData
.
Clear
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
VideoDecoderChild
:
:
RecvError
(
const
nsresult
&
aError
)
{
AssertOnManagerThread
(
)
;
mDecodedData
.
Clear
(
)
;
mDecodePromise
.
RejectIfExists
(
aError
__func__
)
;
mDrainPromise
.
RejectIfExists
(
aError
__func__
)
;
mFlushPromise
.
RejectIfExists
(
aError
__func__
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
VideoDecoderChild
:
:
RecvInitComplete
(
const
bool
&
aHardware
const
nsCString
&
aHardwareReason
)
{
AssertOnManagerThread
(
)
;
mInitPromise
.
ResolveIfExists
(
TrackInfo
:
:
kVideoTrack
__func__
)
;
mInitialized
=
true
;
mIsHardwareAccelerated
=
aHardware
;
mHardwareAcceleratedReason
=
aHardwareReason
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
VideoDecoderChild
:
:
RecvInitFailed
(
const
nsresult
&
aReason
)
{
AssertOnManagerThread
(
)
;
mInitPromise
.
RejectIfExists
(
aReason
__func__
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
VideoDecoderChild
:
:
RecvFlushComplete
(
)
{
AssertOnManagerThread
(
)
;
mFlushPromise
.
ResolveIfExists
(
true
__func__
)
;
return
IPC_OK
(
)
;
}
void
VideoDecoderChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
if
(
aWhy
=
=
AbnormalShutdown
)
{
RefPtr
<
VideoDecoderChild
>
ref
=
this
;
GetManager
(
)
-
>
RunWhenRecreated
(
NS_NewRunnableFunction
(
[
=
]
(
)
{
if
(
ref
-
>
mInitialized
)
{
mDecodedData
.
Clear
(
)
;
mDecodePromise
.
RejectIfExists
(
NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER
__func__
)
;
mDrainPromise
.
RejectIfExists
(
NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER
__func__
)
;
mFlushPromise
.
RejectIfExists
(
NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER
__func__
)
;
mNeedNewDecoder
=
true
;
}
else
{
ref
-
>
mInitPromise
.
RejectIfExists
(
NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER
__func__
)
;
}
}
)
)
;
}
mCanSend
=
false
;
}
bool
VideoDecoderChild
:
:
InitIPDL
(
const
VideoInfo
&
aVideoInfo
const
layers
:
:
TextureFactoryIdentifier
&
aIdentifier
)
{
RefPtr
<
VideoDecoderManagerChild
>
manager
=
VideoDecoderManagerChild
:
:
GetSingleton
(
)
;
if
(
!
manager
|
|
!
manager
-
>
CanSend
(
)
)
{
return
true
;
}
mIPDLSelfRef
=
this
;
bool
success
=
false
;
if
(
manager
-
>
SendPVideoDecoderConstructor
(
this
aVideoInfo
aIdentifier
&
success
)
)
{
mCanSend
=
true
;
}
return
success
;
}
void
VideoDecoderChild
:
:
DestroyIPDL
(
)
{
if
(
mCanSend
)
{
PVideoDecoderChild
:
:
Send__delete__
(
this
)
;
}
}
void
VideoDecoderChild
:
:
IPDLActorDestroyed
(
)
{
mIPDLSelfRef
=
nullptr
;
}
RefPtr
<
MediaDataDecoder
:
:
InitPromise
>
VideoDecoderChild
:
:
Init
(
)
{
AssertOnManagerThread
(
)
;
if
(
!
mIPDLSelfRef
)
{
return
MediaDataDecoder
:
:
InitPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_DECODE_ERR
__func__
)
;
}
if
(
mCanSend
)
{
SendInit
(
)
;
}
return
mInitPromise
.
Ensure
(
__func__
)
;
}
RefPtr
<
MediaDataDecoder
:
:
DecodePromise
>
VideoDecoderChild
:
:
Decode
(
MediaRawData
*
aSample
)
{
AssertOnManagerThread
(
)
;
if
(
mNeedNewDecoder
)
{
return
MediaDataDecoder
:
:
DecodePromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER
__func__
)
;
}
if
(
!
mCanSend
)
{
return
mDecodePromise
.
Ensure
(
__func__
)
;
}
Shmem
buffer
;
if
(
!
AllocShmem
(
aSample
-
>
Size
(
)
Shmem
:
:
SharedMemory
:
:
TYPE_BASIC
&
buffer
)
)
{
return
MediaDataDecoder
:
:
DecodePromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_DECODE_ERR
__func__
)
;
}
memcpy
(
buffer
.
get
<
uint8_t
>
(
)
aSample
-
>
Data
(
)
aSample
-
>
Size
(
)
)
;
MediaRawDataIPDL
sample
(
MediaDataIPDL
(
aSample
-
>
mOffset
aSample
-
>
mTime
aSample
-
>
mTimecode
aSample
-
>
mDuration
aSample
-
>
mFrames
aSample
-
>
mKeyframe
)
buffer
)
;
SendInput
(
sample
)
;
return
mDecodePromise
.
Ensure
(
__func__
)
;
}
RefPtr
<
MediaDataDecoder
:
:
FlushPromise
>
VideoDecoderChild
:
:
Flush
(
)
{
AssertOnManagerThread
(
)
;
mDecodePromise
.
RejectIfExists
(
NS_ERROR_DOM_MEDIA_CANCELED
__func__
)
;
mDrainPromise
.
RejectIfExists
(
NS_ERROR_DOM_MEDIA_CANCELED
__func__
)
;
if
(
mNeedNewDecoder
)
{
return
MediaDataDecoder
:
:
FlushPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER
__func__
)
;
}
if
(
mCanSend
)
{
SendFlush
(
)
;
}
return
mFlushPromise
.
Ensure
(
__func__
)
;
}
RefPtr
<
MediaDataDecoder
:
:
DecodePromise
>
VideoDecoderChild
:
:
Drain
(
)
{
AssertOnManagerThread
(
)
;
if
(
mNeedNewDecoder
)
{
return
MediaDataDecoder
:
:
DecodePromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER
__func__
)
;
}
if
(
mCanSend
)
{
SendDrain
(
)
;
}
return
mDrainPromise
.
Ensure
(
__func__
)
;
}
void
VideoDecoderChild
:
:
Shutdown
(
)
{
AssertOnManagerThread
(
)
;
mInitPromise
.
RejectIfExists
(
NS_ERROR_DOM_MEDIA_CANCELED
__func__
)
;
if
(
mCanSend
)
{
SendShutdown
(
)
;
}
mInitialized
=
false
;
}
bool
VideoDecoderChild
:
:
IsHardwareAccelerated
(
nsACString
&
aFailureReason
)
const
{
aFailureReason
=
mHardwareAcceleratedReason
;
return
mIsHardwareAccelerated
;
}
void
VideoDecoderChild
:
:
SetSeekThreshold
(
const
media
:
:
TimeUnit
&
aTime
)
{
AssertOnManagerThread
(
)
;
if
(
mCanSend
)
{
SendSetSeekThreshold
(
aTime
.
ToMicroseconds
(
)
)
;
}
}
void
VideoDecoderChild
:
:
AssertOnManagerThread
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mThread
)
;
}
VideoDecoderManagerChild
*
VideoDecoderChild
:
:
GetManager
(
)
{
if
(
!
mCanSend
)
{
return
nullptr
;
}
return
static_cast
<
VideoDecoderManagerChild
*
>
(
Manager
(
)
)
;
}
}
}
