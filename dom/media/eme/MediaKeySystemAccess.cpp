#
include
"
mozilla
/
dom
/
MediaKeySystemAccess
.
h
"
#
include
"
mozilla
/
dom
/
MediaKeySystemAccessBinding
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
MediaPrefs
.
h
"
#
include
"
nsContentTypeParser
.
h
"
#
ifdef
MOZ_FMP4
#
include
"
MP4Decoder
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
WMFDecoderModule
.
h
"
#
endif
#
include
"
nsContentCID
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
mozIGeckoMediaPluginService
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
EMEUtils
.
h
"
#
include
"
GMPUtils
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
gmp
-
audio
-
decode
.
h
"
#
include
"
gmp
-
video
-
decode
.
h
"
#
include
"
DecoderDoctorDiagnostics
.
h
"
#
include
"
WebMDecoder
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
mozilla
/
dom
/
MediaSource
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
FennecJNIWrappers
.
h
"
#
endif
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
MediaKeySystemAccess
mParent
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
MediaKeySystemAccess
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
MediaKeySystemAccess
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
MediaKeySystemAccess
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
MediaKeySystemAccess
:
:
MediaKeySystemAccess
(
nsPIDOMWindowInner
*
aParent
const
nsAString
&
aKeySystem
const
MediaKeySystemConfiguration
&
aConfig
)
:
mParent
(
aParent
)
mKeySystem
(
aKeySystem
)
mConfig
(
aConfig
)
{
}
MediaKeySystemAccess
:
:
~
MediaKeySystemAccess
(
)
{
}
JSObject
*
MediaKeySystemAccess
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MediaKeySystemAccessBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsPIDOMWindowInner
*
MediaKeySystemAccess
:
:
GetParentObject
(
)
const
{
return
mParent
;
}
void
MediaKeySystemAccess
:
:
GetKeySystem
(
nsString
&
aOutKeySystem
)
const
{
aOutKeySystem
.
Assign
(
mKeySystem
)
;
}
void
MediaKeySystemAccess
:
:
GetConfiguration
(
MediaKeySystemConfiguration
&
aConfig
)
{
aConfig
=
mConfig
;
}
already_AddRefed
<
Promise
>
MediaKeySystemAccess
:
:
CreateMediaKeys
(
ErrorResult
&
aRv
)
{
RefPtr
<
MediaKeys
>
keys
(
new
MediaKeys
(
mParent
mKeySystem
mConfig
)
)
;
return
keys
-
>
Init
(
aRv
)
;
}
static
bool
HavePluginForKeySystem
(
const
nsCString
&
aKeySystem
)
{
bool
havePlugin
=
HaveGMPFor
(
NS_LITERAL_CSTRING
(
GMP_API_DECRYPTOR
)
{
aKeySystem
}
)
;
#
ifdef
MOZ_WIDGET_ANDROID
if
(
!
havePlugin
)
{
havePlugin
=
mozilla
:
:
java
:
:
MediaDrmProxy
:
:
IsSchemeSupported
(
aKeySystem
)
;
}
#
endif
return
havePlugin
;
}
static
MediaKeySystemStatus
EnsureCDMInstalled
(
const
nsAString
&
aKeySystem
nsACString
&
aOutMessage
)
{
if
(
!
HavePluginForKeySystem
(
NS_ConvertUTF16toUTF8
(
aKeySystem
)
)
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
CDM
is
not
installed
"
)
;
return
MediaKeySystemStatus
:
:
Cdm_not_installed
;
}
return
MediaKeySystemStatus
:
:
Available
;
}
MediaKeySystemStatus
MediaKeySystemAccess
:
:
GetKeySystemStatus
(
const
nsAString
&
aKeySystem
nsACString
&
aOutMessage
)
{
MOZ_ASSERT
(
MediaPrefs
:
:
EMEEnabled
(
)
|
|
IsClearkeyKeySystem
(
aKeySystem
)
)
;
if
(
IsClearkeyKeySystem
(
aKeySystem
)
)
{
return
EnsureCDMInstalled
(
aKeySystem
aOutMessage
)
;
}
if
(
Preferences
:
:
GetBool
(
"
media
.
gmp
-
eme
-
adobe
.
visible
"
false
)
)
{
if
(
IsPrimetimeKeySystem
(
aKeySystem
)
)
{
if
(
!
Preferences
:
:
GetBool
(
"
media
.
gmp
-
eme
-
adobe
.
enabled
"
false
)
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
Adobe
EME
disabled
"
)
;
return
MediaKeySystemStatus
:
:
Cdm_disabled
;
}
#
ifdef
XP_WIN
if
(
!
IsVistaOrLater
(
)
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
Minimum
Windows
version
(
Vista
)
not
met
for
Adobe
EME
"
)
;
return
MediaKeySystemStatus
:
:
Cdm_not_supported
;
}
#
endif
return
EnsureCDMInstalled
(
aKeySystem
aOutMessage
)
;
}
}
if
(
IsWidevineKeySystem
(
aKeySystem
)
)
{
if
(
Preferences
:
:
GetBool
(
"
media
.
gmp
-
widevinecdm
.
visible
"
false
)
)
{
#
ifdef
XP_WIN
if
(
!
IsVistaOrLater
(
)
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
Minimum
Windows
version
(
Vista
)
not
met
for
Widevine
EME
"
)
;
return
MediaKeySystemStatus
:
:
Cdm_not_supported
;
}
#
endif
if
(
!
Preferences
:
:
GetBool
(
"
media
.
gmp
-
widevinecdm
.
enabled
"
false
)
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
Widevine
EME
disabled
"
)
;
return
MediaKeySystemStatus
:
:
Cdm_disabled
;
}
return
EnsureCDMInstalled
(
aKeySystem
aOutMessage
)
;
#
ifdef
MOZ_WIDGET_ANDROID
}
else
if
(
Preferences
:
:
GetBool
(
"
media
.
mediadrm
-
widevinecdm
.
visible
"
false
)
)
{
nsCString
keySystem
=
NS_ConvertUTF16toUTF8
(
aKeySystem
)
;
bool
supported
=
mozilla
:
:
java
:
:
MediaDrmProxy
:
:
IsSchemeSupported
(
keySystem
)
;
if
(
!
supported
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
KeySystem
or
Minimum
API
level
not
met
for
Widevine
EME
"
)
;
return
MediaKeySystemStatus
:
:
Cdm_not_supported
;
}
return
MediaKeySystemStatus
:
:
Available
;
#
endif
}
}
return
MediaKeySystemStatus
:
:
Cdm_not_supported
;
}
typedef
nsCString
EMECodecString
;
static
NS_NAMED_LITERAL_CSTRING
(
EME_CODEC_AAC
"
aac
"
)
;
static
NS_NAMED_LITERAL_CSTRING
(
EME_CODEC_OPUS
"
opus
"
)
;
static
NS_NAMED_LITERAL_CSTRING
(
EME_CODEC_VORBIS
"
vorbis
"
)
;
static
NS_NAMED_LITERAL_CSTRING
(
EME_CODEC_H264
"
h264
"
)
;
static
NS_NAMED_LITERAL_CSTRING
(
EME_CODEC_VP8
"
vp8
"
)
;
static
NS_NAMED_LITERAL_CSTRING
(
EME_CODEC_VP9
"
vp9
"
)
;
EMECodecString
ToEMEAPICodecString
(
const
nsString
&
aCodec
)
{
if
(
IsAACCodecString
(
aCodec
)
)
{
return
EME_CODEC_AAC
;
}
if
(
aCodec
.
EqualsLiteral
(
"
opus
"
)
)
{
return
EME_CODEC_OPUS
;
}
if
(
aCodec
.
EqualsLiteral
(
"
vorbis
"
)
)
{
return
EME_CODEC_VORBIS
;
}
if
(
IsH264CodecString
(
aCodec
)
)
{
return
EME_CODEC_H264
;
}
if
(
IsVP8CodecString
(
aCodec
)
)
{
return
EME_CODEC_VP8
;
}
if
(
IsVP9CodecString
(
aCodec
)
)
{
return
EME_CODEC_VP9
;
}
return
EmptyCString
(
)
;
}
struct
KeySystemContainerSupport
{
bool
IsSupported
(
)
const
{
return
!
mCodecsDecoded
.
IsEmpty
(
)
|
|
!
mCodecsDecrypted
.
IsEmpty
(
)
;
}
bool
DecryptsAndDecodes
(
EMECodecString
aCodec
)
const
{
return
mCodecsDecoded
.
Contains
(
aCodec
)
;
}
bool
Decrypts
(
EMECodecString
aCodec
)
const
{
return
mCodecsDecrypted
.
Contains
(
aCodec
)
;
}
void
SetCanDecryptAndDecode
(
EMECodecString
aCodec
)
{
MOZ_ASSERT
(
!
Decrypts
(
aCodec
)
)
;
MOZ_ASSERT
(
!
DecryptsAndDecodes
(
aCodec
)
)
;
mCodecsDecoded
.
AppendElement
(
aCodec
)
;
}
void
SetCanDecrypt
(
EMECodecString
aCodec
)
{
MOZ_ASSERT
(
!
Decrypts
(
aCodec
)
)
;
MOZ_ASSERT
(
!
DecryptsAndDecodes
(
aCodec
)
)
;
mCodecsDecrypted
.
AppendElement
(
aCodec
)
;
}
private
:
nsTArray
<
EMECodecString
>
mCodecsDecoded
;
nsTArray
<
EMECodecString
>
mCodecsDecrypted
;
}
;
enum
class
KeySystemFeatureSupport
{
Prohibited
=
1
Requestable
=
2
Required
=
3
}
;
struct
KeySystemConfig
{
nsString
mKeySystem
;
nsTArray
<
nsString
>
mInitDataTypes
;
KeySystemFeatureSupport
mPersistentState
=
KeySystemFeatureSupport
:
:
Prohibited
;
KeySystemFeatureSupport
mDistinctiveIdentifier
=
KeySystemFeatureSupport
:
:
Prohibited
;
nsTArray
<
MediaKeySessionType
>
mSessionTypes
;
nsTArray
<
nsString
>
mVideoRobustness
;
nsTArray
<
nsString
>
mAudioRobustness
;
KeySystemContainerSupport
mMP4
;
KeySystemContainerSupport
mWebM
;
}
;
static
nsTArray
<
KeySystemConfig
>
GetSupportedKeySystems
(
)
{
nsTArray
<
KeySystemConfig
>
keySystemConfigs
;
{
if
(
HavePluginForKeySystem
(
kEMEKeySystemClearkey
)
)
{
KeySystemConfig
clearkey
;
clearkey
.
mKeySystem
=
NS_ConvertUTF8toUTF16
(
kEMEKeySystemClearkey
)
;
clearkey
.
mInitDataTypes
.
AppendElement
(
NS_LITERAL_STRING
(
"
cenc
"
)
)
;
clearkey
.
mInitDataTypes
.
AppendElement
(
NS_LITERAL_STRING
(
"
keyids
"
)
)
;
clearkey
.
mInitDataTypes
.
AppendElement
(
NS_LITERAL_STRING
(
"
webm
"
)
)
;
clearkey
.
mPersistentState
=
KeySystemFeatureSupport
:
:
Requestable
;
clearkey
.
mDistinctiveIdentifier
=
KeySystemFeatureSupport
:
:
Prohibited
;
clearkey
.
mSessionTypes
.
AppendElement
(
MediaKeySessionType
:
:
Temporary
)
;
if
(
MediaPrefs
:
:
ClearKeyPersistentLicenseEnabled
(
)
)
{
clearkey
.
mSessionTypes
.
AppendElement
(
MediaKeySessionType
:
:
Persistent_license
)
;
}
#
if
defined
(
XP_WIN
)
if
(
WMFDecoderModule
:
:
HasAAC
(
)
)
{
clearkey
.
mMP4
.
SetCanDecryptAndDecode
(
EME_CODEC_AAC
)
;
}
else
{
clearkey
.
mMP4
.
SetCanDecrypt
(
EME_CODEC_AAC
)
;
}
if
(
WMFDecoderModule
:
:
HasH264
(
)
)
{
clearkey
.
mMP4
.
SetCanDecryptAndDecode
(
EME_CODEC_H264
)
;
}
else
{
clearkey
.
mMP4
.
SetCanDecrypt
(
EME_CODEC_H264
)
;
}
#
else
clearkey
.
mMP4
.
SetCanDecrypt
(
EME_CODEC_AAC
)
;
clearkey
.
mMP4
.
SetCanDecrypt
(
EME_CODEC_H264
)
;
#
endif
clearkey
.
mWebM
.
SetCanDecrypt
(
EME_CODEC_VORBIS
)
;
clearkey
.
mWebM
.
SetCanDecrypt
(
EME_CODEC_OPUS
)
;
clearkey
.
mWebM
.
SetCanDecrypt
(
EME_CODEC_VP8
)
;
clearkey
.
mWebM
.
SetCanDecrypt
(
EME_CODEC_VP9
)
;
keySystemConfigs
.
AppendElement
(
Move
(
clearkey
)
)
;
}
}
{
if
(
HavePluginForKeySystem
(
kEMEKeySystemWidevine
)
)
{
KeySystemConfig
widevine
;
widevine
.
mKeySystem
=
NS_ConvertUTF8toUTF16
(
kEMEKeySystemWidevine
)
;
widevine
.
mInitDataTypes
.
AppendElement
(
NS_LITERAL_STRING
(
"
cenc
"
)
)
;
widevine
.
mInitDataTypes
.
AppendElement
(
NS_LITERAL_STRING
(
"
keyids
"
)
)
;
widevine
.
mInitDataTypes
.
AppendElement
(
NS_LITERAL_STRING
(
"
webm
"
)
)
;
widevine
.
mPersistentState
=
KeySystemFeatureSupport
:
:
Requestable
;
widevine
.
mDistinctiveIdentifier
=
KeySystemFeatureSupport
:
:
Prohibited
;
widevine
.
mSessionTypes
.
AppendElement
(
MediaKeySessionType
:
:
Temporary
)
;
#
ifdef
MOZ_WIDGET_ANDROID
widevine
.
mSessionTypes
.
AppendElement
(
MediaKeySessionType
:
:
Persistent_license
)
;
#
endif
widevine
.
mAudioRobustness
.
AppendElement
(
NS_LITERAL_STRING
(
"
SW_SECURE_CRYPTO
"
)
)
;
widevine
.
mVideoRobustness
.
AppendElement
(
NS_LITERAL_STRING
(
"
SW_SECURE_DECODE
"
)
)
;
#
if
defined
(
XP_WIN
)
if
(
WMFDecoderModule
:
:
HasAAC
(
)
)
{
widevine
.
mMP4
.
SetCanDecrypt
(
EME_CODEC_AAC
)
;
}
#
elif
!
defined
(
MOZ_WIDGET_ANDROID
)
widevine
.
mMP4
.
SetCanDecrypt
(
EME_CODEC_AAC
)
;
#
endif
#
if
defined
(
MOZ_WIDGET_ANDROID
)
using
namespace
mozilla
:
:
java
;
typedef
struct
{
const
nsCString
&
mMimeType
;
const
nsCString
&
mEMECodecType
;
const
char16_t
*
mCodecType
;
KeySystemContainerSupport
*
mSupportType
;
}
DataForValidation
;
DataForValidation
validationList
[
]
=
{
{
nsCString
(
"
video
/
mp4
"
)
EME_CODEC_H264
MediaDrmProxy
:
:
AVC
&
widevine
.
mMP4
}
{
nsCString
(
"
audio
/
mp4
"
)
EME_CODEC_AAC
MediaDrmProxy
:
:
AAC
&
widevine
.
mMP4
}
{
nsCString
(
"
video
/
webm
"
)
EME_CODEC_VP8
MediaDrmProxy
:
:
VP8
&
widevine
.
mWebM
}
{
nsCString
(
"
video
/
webm
"
)
EME_CODEC_VP9
MediaDrmProxy
:
:
VP9
&
widevine
.
mWebM
}
{
nsCString
(
"
audio
/
webm
"
)
EME_CODEC_VORBIS
MediaDrmProxy
:
:
VORBIS
&
widevine
.
mWebM
}
{
nsCString
(
"
audio
/
webm
"
)
EME_CODEC_OPUS
MediaDrmProxy
:
:
OPUS
&
widevine
.
mWebM
}
}
;
for
(
const
auto
&
data
:
validationList
)
{
if
(
MediaDrmProxy
:
:
IsCryptoSchemeSupported
(
kEMEKeySystemWidevine
data
.
mMimeType
)
)
{
if
(
MediaDrmProxy
:
:
CanDecode
(
data
.
mCodecType
)
)
{
data
.
mSupportType
-
>
SetCanDecryptAndDecode
(
data
.
mEMECodecType
)
;
}
else
{
data
.
mSupportType
-
>
SetCanDecrypt
(
data
.
mEMECodecType
)
;
}
}
}
#
else
widevine
.
mMP4
.
SetCanDecryptAndDecode
(
EME_CODEC_H264
)
;
widevine
.
mWebM
.
SetCanDecrypt
(
EME_CODEC_VORBIS
)
;
widevine
.
mWebM
.
SetCanDecrypt
(
EME_CODEC_OPUS
)
;
widevine
.
mWebM
.
SetCanDecryptAndDecode
(
EME_CODEC_VP8
)
;
widevine
.
mWebM
.
SetCanDecryptAndDecode
(
EME_CODEC_VP9
)
;
#
endif
keySystemConfigs
.
AppendElement
(
Move
(
widevine
)
)
;
}
}
{
if
(
HavePluginForKeySystem
(
kEMEKeySystemPrimetime
)
)
{
KeySystemConfig
primetime
;
primetime
.
mKeySystem
=
NS_ConvertUTF8toUTF16
(
kEMEKeySystemPrimetime
)
;
primetime
.
mInitDataTypes
.
AppendElement
(
NS_LITERAL_STRING
(
"
cenc
"
)
)
;
primetime
.
mPersistentState
=
KeySystemFeatureSupport
:
:
Required
;
primetime
.
mDistinctiveIdentifier
=
KeySystemFeatureSupport
:
:
Required
;
primetime
.
mSessionTypes
.
AppendElement
(
MediaKeySessionType
:
:
Temporary
)
;
primetime
.
mMP4
.
SetCanDecryptAndDecode
(
EME_CODEC_AAC
)
;
primetime
.
mMP4
.
SetCanDecryptAndDecode
(
EME_CODEC_H264
)
;
keySystemConfigs
.
AppendElement
(
Move
(
primetime
)
)
;
}
}
return
keySystemConfigs
;
}
static
bool
GetKeySystemConfig
(
const
nsAString
&
aKeySystem
KeySystemConfig
&
aOutKeySystemConfig
)
{
for
(
auto
&
&
config
:
GetSupportedKeySystems
(
)
)
{
if
(
config
.
mKeySystem
.
Equals
(
aKeySystem
)
)
{
aOutKeySystemConfig
=
mozilla
:
:
Move
(
config
)
;
return
true
;
}
}
return
false
;
}
bool
MediaKeySystemAccess
:
:
KeySystemSupportsInitDataType
(
const
nsAString
&
aKeySystem
const
nsAString
&
aInitDataType
)
{
KeySystemConfig
implementation
;
return
GetKeySystemConfig
(
aKeySystem
implementation
)
&
&
implementation
.
mInitDataTypes
.
Contains
(
aInitDataType
)
;
}
enum
CodecType
{
Audio
Video
Invalid
}
;
static
bool
CanDecryptAndDecode
(
const
nsString
&
aKeySystem
const
nsString
&
aContentType
CodecType
aCodecType
const
KeySystemContainerSupport
&
aContainerSupport
const
nsTArray
<
EMECodecString
>
&
aCodecs
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
MOZ_ASSERT
(
aCodecType
!
=
Invalid
)
;
for
(
const
EMECodecString
&
codec
:
aCodecs
)
{
MOZ_ASSERT
(
!
codec
.
IsEmpty
(
)
)
;
if
(
aContainerSupport
.
DecryptsAndDecodes
(
codec
)
)
{
continue
;
}
if
(
aContainerSupport
.
Decrypts
(
codec
)
&
&
NS_SUCCEEDED
(
MediaSource
:
:
IsTypeSupported
(
aContentType
aDiagnostics
)
)
)
{
continue
;
}
#
if
defined
(
XP_WIN
)
if
(
codec
=
=
EME_CODEC_AAC
&
&
IsWidevineKeySystem
(
aKeySystem
)
&
&
!
WMFDecoderModule
:
:
HasAAC
(
)
)
{
if
(
aDiagnostics
)
{
aDiagnostics
-
>
SetKeySystemIssue
(
DecoderDoctorDiagnostics
:
:
eWidevineWithNoWMF
)
;
}
}
#
endif
return
false
;
}
return
true
;
}
static
bool
ToSessionType
(
const
nsAString
&
aSessionType
MediaKeySessionType
&
aOutType
)
{
using
MediaKeySessionTypeValues
:
:
strings
;
const
char
*
temporary
=
strings
[
static_cast
<
uint32_t
>
(
MediaKeySessionType
:
:
Temporary
)
]
.
value
;
if
(
aSessionType
.
EqualsASCII
(
temporary
)
)
{
aOutType
=
MediaKeySessionType
:
:
Temporary
;
return
true
;
}
const
char
*
persistentLicense
=
strings
[
static_cast
<
uint32_t
>
(
MediaKeySessionType
:
:
Persistent_license
)
]
.
value
;
if
(
aSessionType
.
EqualsASCII
(
persistentLicense
)
)
{
aOutType
=
MediaKeySessionType
:
:
Persistent_license
;
return
true
;
}
return
false
;
}
static
bool
IsPersistentSessionType
(
MediaKeySessionType
aSessionType
)
{
return
aSessionType
=
=
MediaKeySessionType
:
:
Persistent_license
;
}
CodecType
GetMajorType
(
const
nsAString
&
aContentType
)
{
if
(
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
audio
/
"
)
aContentType
)
)
{
return
Audio
;
}
if
(
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
video
/
"
)
aContentType
)
)
{
return
Video
;
}
return
Invalid
;
}
static
CodecType
GetCodecType
(
const
EMECodecString
&
aCodec
)
{
if
(
aCodec
.
Equals
(
EME_CODEC_AAC
)
|
|
aCodec
.
Equals
(
EME_CODEC_OPUS
)
|
|
aCodec
.
Equals
(
EME_CODEC_VORBIS
)
)
{
return
Audio
;
}
if
(
aCodec
.
Equals
(
EME_CODEC_H264
)
|
|
aCodec
.
Equals
(
EME_CODEC_VP8
)
|
|
aCodec
.
Equals
(
EME_CODEC_VP9
)
)
{
return
Video
;
}
return
Invalid
;
}
static
bool
AllCodecsOfType
(
const
nsTArray
<
EMECodecString
>
&
aCodecs
const
CodecType
aCodecType
)
{
for
(
const
EMECodecString
&
codec
:
aCodecs
)
{
if
(
GetCodecType
(
codec
)
!
=
aCodecType
)
{
return
false
;
}
}
return
true
;
}
static
bool
IsParameterUnrecognized
(
const
nsAString
&
aContentType
)
{
nsAutoString
contentType
(
aContentType
)
;
contentType
.
StripWhitespace
(
)
;
nsTArray
<
nsString
>
params
;
nsAString
:
:
const_iterator
start
end
semicolon
equalSign
;
contentType
.
BeginReading
(
start
)
;
contentType
.
EndReading
(
end
)
;
semicolon
=
start
;
while
(
semicolon
!
=
end
)
{
if
(
FindCharInReadable
(
'
;
'
semicolon
end
)
)
{
equalSign
=
+
+
semicolon
;
if
(
FindCharInReadable
(
'
=
'
equalSign
end
)
)
{
params
.
AppendElement
(
Substring
(
semicolon
equalSign
)
)
;
semicolon
=
equalSign
;
}
}
}
for
(
auto
param
:
params
)
{
if
(
!
param
.
LowerCaseEqualsLiteral
(
"
codecs
"
)
&
&
!
param
.
LowerCaseEqualsLiteral
(
"
profiles
"
)
)
{
return
true
;
}
}
return
false
;
}
static
Sequence
<
MediaKeySystemMediaCapability
>
GetSupportedCapabilities
(
const
CodecType
aCodecType
const
nsTArray
<
MediaKeySystemMediaCapability
>
&
aRequestedCapabilities
const
MediaKeySystemConfiguration
&
aPartialConfig
const
KeySystemConfig
&
aKeySystem
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
Sequence
<
MediaKeySystemMediaCapability
>
supportedCapabilities
;
for
(
const
MediaKeySystemMediaCapability
&
capabilities
:
aRequestedCapabilities
)
{
const
nsString
&
contentType
=
capabilities
.
mContentType
;
const
nsString
&
robustness
=
capabilities
.
mRobustness
;
if
(
contentType
.
IsEmpty
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
rejected
;
"
"
audio
or
video
capability
has
empty
contentType
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
return
Sequence
<
MediaKeySystemMediaCapability
>
(
)
;
}
nsAutoString
container
;
nsTArray
<
nsString
>
codecStrings
;
if
(
!
ParseMIMETypeString
(
contentType
container
codecStrings
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
failed
to
parse
contentType
as
MIME
type
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
bool
invalid
=
false
;
nsTArray
<
EMECodecString
>
codecs
;
for
(
const
nsString
&
codecString
:
codecStrings
)
{
EMECodecString
emeCodec
=
ToEMEAPICodecString
(
codecString
)
;
if
(
emeCodec
.
IsEmpty
(
)
)
{
invalid
=
true
;
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
'
%
s
'
is
an
invalid
codec
string
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
codecString
)
.
get
(
)
)
;
break
;
}
codecs
.
AppendElement
(
emeCodec
)
;
}
if
(
invalid
)
{
continue
;
}
NS_ConvertUTF16toUTF8
container_utf8
(
container
)
;
const
bool
isMP4
=
DecoderTraits
:
:
IsMP4TypeAndEnabled
(
container_utf8
aDiagnostics
)
;
if
(
isMP4
&
&
!
aKeySystem
.
mMP4
.
IsSupported
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
MP4
requested
but
unsupported
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
const
bool
isWebM
=
DecoderTraits
:
:
IsWebMTypeAndEnabled
(
container_utf8
)
;
if
(
isWebM
&
&
!
aKeySystem
.
mWebM
.
IsSupported
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
WebM
requested
but
unsupported
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
if
(
!
isMP4
&
&
!
isWebM
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
Unsupported
or
unrecognized
container
requested
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
if
(
IsParameterUnrecognized
(
contentType
)
)
{
continue
;
}
if
(
codecs
.
IsEmpty
(
)
)
{
if
(
isMP4
)
{
if
(
aCodecType
=
=
Audio
)
{
codecs
.
AppendElement
(
EME_CODEC_AAC
)
;
}
else
if
(
aCodecType
=
=
Video
)
{
codecs
.
AppendElement
(
EME_CODEC_H264
)
;
}
}
else
if
(
isWebM
)
{
if
(
aCodecType
=
=
Audio
)
{
codecs
.
AppendElement
(
EME_CODEC_VORBIS
)
;
}
else
if
(
aCodecType
=
=
Video
)
{
codecs
.
AppendElement
(
EME_CODEC_VP8
)
;
}
}
}
const
auto
majorType
=
GetMajorType
(
container
)
;
if
(
majorType
=
=
Invalid
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
MIME
type
is
not
an
audio
or
video
MIME
type
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
if
(
majorType
!
=
aCodecType
|
|
!
AllCodecsOfType
(
codecs
aCodecType
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
MIME
type
mixes
audio
codecs
in
video
capabilities
"
"
or
video
codecs
in
audio
capabilities
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
if
(
!
robustness
.
IsEmpty
(
)
)
{
if
(
majorType
=
=
Audio
&
&
!
aKeySystem
.
mAudioRobustness
.
Contains
(
robustness
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
unsupported
robustness
string
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
if
(
majorType
=
=
Video
&
&
!
aKeySystem
.
mVideoRobustness
.
Contains
(
robustness
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
unsupported
robustness
string
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
}
const
auto
&
containerSupport
=
isMP4
?
aKeySystem
.
mMP4
:
aKeySystem
.
mWebM
;
if
(
!
CanDecryptAndDecode
(
aKeySystem
.
mKeySystem
contentType
majorType
containerSupport
codecs
aDiagnostics
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
codec
unsupported
by
CDM
requested
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
if
(
!
supportedCapabilities
.
AppendElement
(
capabilities
mozilla
:
:
fallible
)
)
{
NS_WARNING
(
"
GetSupportedCapabilities
:
Malloc
failure
"
)
;
return
Sequence
<
MediaKeySystemMediaCapability
>
(
)
;
}
}
return
Move
(
supportedCapabilities
)
;
}
static
bool
CheckRequirement
(
const
MediaKeysRequirement
aRequirement
const
KeySystemFeatureSupport
aFeatureSupport
MediaKeysRequirement
&
aOutRequirement
)
{
MediaKeysRequirement
requirement
=
aRequirement
;
if
(
aRequirement
=
=
MediaKeysRequirement
:
:
Optional
&
&
aFeatureSupport
=
=
KeySystemFeatureSupport
:
:
Prohibited
)
{
requirement
=
MediaKeysRequirement
:
:
Not_allowed
;
}
switch
(
requirement
)
{
case
MediaKeysRequirement
:
:
Required
:
{
if
(
aFeatureSupport
=
=
KeySystemFeatureSupport
:
:
Prohibited
)
{
return
false
;
}
break
;
}
case
MediaKeysRequirement
:
:
Optional
:
{
break
;
}
case
MediaKeysRequirement
:
:
Not_allowed
:
{
if
(
aFeatureSupport
=
=
KeySystemFeatureSupport
:
:
Required
)
{
return
false
;
}
break
;
}
default
:
{
return
false
;
}
}
aOutRequirement
=
requirement
;
return
true
;
}
static
Sequence
<
nsString
>
UnboxSessionTypes
(
const
Optional
<
Sequence
<
nsString
>
>
&
aSessionTypes
)
{
Sequence
<
nsString
>
sessionTypes
;
if
(
aSessionTypes
.
WasPassed
(
)
)
{
sessionTypes
=
aSessionTypes
.
Value
(
)
;
}
else
{
using
MediaKeySessionTypeValues
:
:
strings
;
const
char
*
temporary
=
strings
[
static_cast
<
uint32_t
>
(
MediaKeySessionType
:
:
Temporary
)
]
.
value
;
sessionTypes
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
nsDependentCString
(
temporary
)
)
mozilla
:
:
fallible
)
;
}
return
sessionTypes
;
}
static
bool
GetSupportedConfig
(
const
KeySystemConfig
&
aKeySystem
const
MediaKeySystemConfiguration
&
aCandidate
MediaKeySystemConfiguration
&
aOutConfig
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
MediaKeySystemConfiguration
config
;
config
.
mLabel
=
aCandidate
.
mLabel
;
if
(
!
aCandidate
.
mInitDataTypes
.
IsEmpty
(
)
)
{
nsTArray
<
nsString
>
supportedTypes
;
for
(
const
nsString
&
initDataType
:
aCandidate
.
mInitDataTypes
)
{
if
(
aKeySystem
.
mInitDataTypes
.
Contains
(
initDataType
)
)
{
supportedTypes
.
AppendElement
(
initDataType
)
;
}
}
if
(
supportedTypes
.
IsEmpty
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
no
supported
initDataTypes
provided
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
if
(
!
config
.
mInitDataTypes
.
Assign
(
supportedTypes
)
)
{
return
false
;
}
}
if
(
!
CheckRequirement
(
aCandidate
.
mDistinctiveIdentifier
aKeySystem
.
mDistinctiveIdentifier
config
.
mDistinctiveIdentifier
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
distinctiveIdentifier
requirement
not
satisfied
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
if
(
!
CheckRequirement
(
aCandidate
.
mPersistentState
aKeySystem
.
mPersistentState
config
.
mPersistentState
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
persistentState
requirement
not
satisfied
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
Sequence
<
nsString
>
sessionTypes
(
UnboxSessionTypes
(
aCandidate
.
mSessionTypes
)
)
;
if
(
sessionTypes
.
IsEmpty
(
)
)
{
return
false
;
}
for
(
const
auto
&
sessionTypeString
:
sessionTypes
)
{
MediaKeySessionType
sessionType
;
if
(
!
ToSessionType
(
sessionTypeString
sessionType
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
invalid
session
type
specified
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
if
(
config
.
mPersistentState
=
=
MediaKeysRequirement
:
:
Not_allowed
&
&
IsPersistentSessionType
(
sessionType
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
persistent
session
requested
but
keysystem
doesn
'
t
"
"
support
persistent
state
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
if
(
!
aKeySystem
.
mSessionTypes
.
Contains
(
sessionType
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
session
type
'
%
s
'
unsupported
by
keySystem
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
sessionTypeString
)
.
get
(
)
)
;
return
false
;
}
if
(
config
.
mPersistentState
=
=
MediaKeysRequirement
:
:
Optional
&
&
IsPersistentSessionType
(
sessionType
)
)
{
config
.
mPersistentState
=
MediaKeysRequirement
:
:
Required
;
}
}
config
.
mSessionTypes
.
Construct
(
Move
(
sessionTypes
)
)
;
if
(
!
aCandidate
.
mVideoCapabilities
.
IsEmpty
(
)
)
{
Sequence
<
MediaKeySystemMediaCapability
>
caps
=
GetSupportedCapabilities
(
Video
aCandidate
.
mVideoCapabilities
config
aKeySystem
aDiagnostics
)
;
if
(
caps
.
IsEmpty
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
no
supported
video
capabilities
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
config
.
mVideoCapabilities
=
Move
(
caps
)
;
}
else
{
}
if
(
!
aCandidate
.
mAudioCapabilities
.
IsEmpty
(
)
)
{
Sequence
<
MediaKeySystemMediaCapability
>
caps
=
GetSupportedCapabilities
(
Audio
aCandidate
.
mAudioCapabilities
config
aKeySystem
aDiagnostics
)
;
if
(
caps
.
IsEmpty
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
no
supported
audio
capabilities
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
config
.
mAudioCapabilities
=
Move
(
caps
)
;
}
else
{
}
if
(
config
.
mDistinctiveIdentifier
=
=
MediaKeysRequirement
:
:
Optional
)
{
if
(
aKeySystem
.
mDistinctiveIdentifier
=
=
KeySystemFeatureSupport
:
:
Required
)
{
config
.
mDistinctiveIdentifier
=
MediaKeysRequirement
:
:
Required
;
}
else
{
config
.
mDistinctiveIdentifier
=
MediaKeysRequirement
:
:
Not_allowed
;
}
}
if
(
config
.
mPersistentState
=
=
MediaKeysRequirement
:
:
Optional
)
{
if
(
aKeySystem
.
mPersistentState
=
=
KeySystemFeatureSupport
:
:
Required
)
{
config
.
mPersistentState
=
MediaKeysRequirement
:
:
Required
;
}
else
{
config
.
mPersistentState
=
MediaKeysRequirement
:
:
Not_allowed
;
}
}
#
if
defined
(
XP_WIN
)
if
(
IsWidevineKeySystem
(
aKeySystem
.
mKeySystem
)
&
&
(
aCandidate
.
mAudioCapabilities
.
IsEmpty
(
)
|
|
aCandidate
.
mVideoCapabilities
.
IsEmpty
(
)
)
&
&
!
WMFDecoderModule
:
:
HasAAC
(
)
)
{
if
(
aDiagnostics
)
{
aDiagnostics
-
>
SetKeySystemIssue
(
DecoderDoctorDiagnostics
:
:
eWidevineWithNoWMF
)
;
}
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
WMF
required
for
Widevine
decoding
but
it
'
s
not
available
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
#
endif
aOutConfig
=
config
;
return
true
;
}
bool
MediaKeySystemAccess
:
:
GetSupportedConfig
(
const
nsAString
&
aKeySystem
const
Sequence
<
MediaKeySystemConfiguration
>
&
aConfigs
MediaKeySystemConfiguration
&
aOutConfig
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
KeySystemConfig
implementation
;
if
(
!
GetKeySystemConfig
(
aKeySystem
implementation
)
)
{
return
false
;
}
for
(
const
MediaKeySystemConfiguration
&
candidate
:
aConfigs
)
{
if
(
mozilla
:
:
dom
:
:
GetSupportedConfig
(
implementation
candidate
aOutConfig
aDiagnostics
)
)
{
return
true
;
}
}
return
false
;
}
void
MediaKeySystemAccess
:
:
NotifyObservers
(
nsPIDOMWindowInner
*
aWindow
const
nsAString
&
aKeySystem
MediaKeySystemStatus
aStatus
)
{
RequestMediaKeySystemAccessNotification
data
;
data
.
mKeySystem
=
aKeySystem
;
data
.
mStatus
=
aStatus
;
nsAutoString
json
;
data
.
ToJSON
(
json
)
;
EME_LOG
(
"
MediaKeySystemAccess
:
:
NotifyObservers
(
)
%
s
"
NS_ConvertUTF16toUTF8
(
json
)
.
get
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
aWindow
"
mediakeys
-
request
"
json
.
get
(
)
)
;
}
}
}
}
