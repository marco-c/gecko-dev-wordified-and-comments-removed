#
include
"
mozilla
/
dom
/
MediaKeySystemAccess
.
h
"
#
include
<
functional
>
#
include
"
DecoderDoctorDiagnostics
.
h
"
#
include
"
DecoderTraits
.
h
"
#
include
"
KeySystemConfig
.
h
"
#
include
"
MediaContainerType
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
KeySystemNames
.
h
"
#
include
"
mozilla
/
dom
/
MediaKeySystemAccessBinding
.
h
"
#
include
"
mozilla
/
dom
/
MediaKeySession
.
h
"
#
include
"
mozilla
/
dom
/
MediaSource
.
h
"
#
include
"
mozilla
/
EMEUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
nsDOMString
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
WebMDecoder
.
h
"
#
ifdef
XP_WIN
#
include
"
WMFDecoderModule
.
h
"
#
endif
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
MediaKeySystemAccess
mParent
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
MediaKeySystemAccess
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
MediaKeySystemAccess
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
MediaKeySystemAccess
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
static
nsCString
ToCString
(
const
MediaKeySystemConfiguration
&
aConfig
)
;
MediaKeySystemAccess
:
:
MediaKeySystemAccess
(
nsPIDOMWindowInner
*
aParent
const
nsAString
&
aKeySystem
const
MediaKeySystemConfiguration
&
aConfig
)
:
mParent
(
aParent
)
mKeySystem
(
aKeySystem
)
mConfig
(
aConfig
)
{
EME_LOG
(
"
Created
MediaKeySystemAccess
for
keysystem
=
%
s
config
=
%
s
"
NS_ConvertUTF16toUTF8
(
mKeySystem
)
.
get
(
)
mozilla
:
:
dom
:
:
ToCString
(
mConfig
)
.
get
(
)
)
;
}
MediaKeySystemAccess
:
:
~
MediaKeySystemAccess
(
)
=
default
;
JSObject
*
MediaKeySystemAccess
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MediaKeySystemAccess_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsPIDOMWindowInner
*
MediaKeySystemAccess
:
:
GetParentObject
(
)
const
{
return
mParent
;
}
void
MediaKeySystemAccess
:
:
GetKeySystem
(
nsString
&
aOutKeySystem
)
const
{
aOutKeySystem
.
Assign
(
mKeySystem
)
;
}
void
MediaKeySystemAccess
:
:
GetConfiguration
(
MediaKeySystemConfiguration
&
aConfig
)
{
aConfig
=
mConfig
;
}
already_AddRefed
<
Promise
>
MediaKeySystemAccess
:
:
CreateMediaKeys
(
ErrorResult
&
aRv
)
{
RefPtr
<
MediaKeys
>
keys
(
new
MediaKeys
(
mParent
mKeySystem
mConfig
)
)
;
return
keys
-
>
Init
(
aRv
)
;
}
static
MediaKeySystemStatus
EnsureCDMInstalled
(
const
nsAString
&
aKeySystem
nsACString
&
aOutMessage
)
{
if
(
!
KeySystemConfig
:
:
Supports
(
aKeySystem
)
)
{
aOutMessage
=
"
CDM
is
not
installed
"
_ns
;
return
MediaKeySystemStatus
:
:
Cdm_not_installed
;
}
return
MediaKeySystemStatus
:
:
Available
;
}
MediaKeySystemStatus
MediaKeySystemAccess
:
:
GetKeySystemStatus
(
const
nsAString
&
aKeySystem
nsACString
&
aOutMessage
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
media_eme_enabled
(
)
|
|
IsClearkeyKeySystem
(
aKeySystem
)
)
;
if
(
IsClearkeyKeySystem
(
aKeySystem
)
)
{
return
EnsureCDMInstalled
(
aKeySystem
aOutMessage
)
;
}
if
(
IsWidevineKeySystem
(
aKeySystem
)
)
{
if
(
Preferences
:
:
GetBool
(
"
media
.
gmp
-
widevinecdm
.
visible
"
false
)
)
{
if
(
!
Preferences
:
:
GetBool
(
"
media
.
gmp
-
widevinecdm
.
enabled
"
false
)
)
{
aOutMessage
=
"
Widevine
EME
disabled
"
_ns
;
return
MediaKeySystemStatus
:
:
Cdm_disabled
;
}
return
EnsureCDMInstalled
(
aKeySystem
aOutMessage
)
;
#
ifdef
MOZ_WIDGET_ANDROID
}
else
if
(
Preferences
:
:
GetBool
(
"
media
.
mediadrm
-
widevinecdm
.
visible
"
false
)
)
{
nsCString
keySystem
=
NS_ConvertUTF16toUTF8
(
aKeySystem
)
;
bool
supported
=
mozilla
:
:
java
:
:
MediaDrmProxy
:
:
IsSchemeSupported
(
keySystem
)
;
if
(
!
supported
)
{
aOutMessage
=
nsLiteralCString
(
"
KeySystem
or
Minimum
API
level
not
met
for
Widevine
EME
"
)
;
return
MediaKeySystemStatus
:
:
Cdm_not_supported
;
}
return
MediaKeySystemStatus
:
:
Available
;
#
endif
}
}
#
ifdef
MOZ_WMF_CDM
if
(
IsPlayReadyKeySystemAndSupported
(
aKeySystem
)
&
&
KeySystemConfig
:
:
Supports
(
aKeySystem
)
)
{
return
MediaKeySystemStatus
:
:
Available
;
}
#
endif
return
MediaKeySystemStatus
:
:
Cdm_not_supported
;
}
static
KeySystemConfig
:
:
EMECodecString
ToEMEAPICodecString
(
const
nsString
&
aCodec
)
{
if
(
IsAACCodecString
(
aCodec
)
)
{
return
KeySystemConfig
:
:
EME_CODEC_AAC
;
}
if
(
aCodec
.
EqualsLiteral
(
"
opus
"
)
)
{
return
KeySystemConfig
:
:
EME_CODEC_OPUS
;
}
if
(
aCodec
.
EqualsLiteral
(
"
vorbis
"
)
)
{
return
KeySystemConfig
:
:
EME_CODEC_VORBIS
;
}
if
(
aCodec
.
EqualsLiteral
(
"
flac
"
)
)
{
return
KeySystemConfig
:
:
EME_CODEC_FLAC
;
}
if
(
IsH264CodecString
(
aCodec
)
)
{
return
KeySystemConfig
:
:
EME_CODEC_H264
;
}
if
(
IsVP8CodecString
(
aCodec
)
)
{
return
KeySystemConfig
:
:
EME_CODEC_VP8
;
}
if
(
IsVP9CodecString
(
aCodec
)
)
{
return
KeySystemConfig
:
:
EME_CODEC_VP9
;
}
return
"
"
_ns
;
}
static
nsTArray
<
KeySystemConfig
>
GetSupportedKeySystems
(
)
{
nsTArray
<
KeySystemConfig
>
keySystemConfigs
;
const
nsTArray
<
nsString
>
keySystemNames
{
NS_ConvertUTF8toUTF16
(
kClearKeyKeySystemName
)
NS_ConvertUTF8toUTF16
(
kWidevineKeySystemName
)
#
ifdef
MOZ_WMF_CDM
NS_ConvertUTF8toUTF16
(
kPlayReadyKeySystemName
)
NS_ConvertUTF8toUTF16
(
kPlayReadyKeySystemHardware
)
#
endif
}
;
for
(
const
auto
&
name
:
keySystemNames
)
{
KeySystemConfig
config
;
if
(
KeySystemConfig
:
:
GetConfig
(
name
config
)
)
{
if
(
IsClearkeyKeySystem
(
name
)
&
&
StaticPrefs
:
:
media_clearkey_test_key_systems_enabled
(
)
)
{
KeySystemConfig
clearkeyWithProtectionQuery
{
config
}
;
clearkeyWithProtectionQuery
.
mKeySystem
.
AssignLiteral
(
kClearKeyWithProtectionQueryKeySystemName
)
;
keySystemConfigs
.
AppendElement
(
std
:
:
move
(
clearkeyWithProtectionQuery
)
)
;
}
keySystemConfigs
.
AppendElement
(
std
:
:
move
(
config
)
)
;
}
}
return
keySystemConfigs
;
}
static
bool
GetKeySystemConfig
(
const
nsAString
&
aKeySystem
KeySystemConfig
&
aOutKeySystemConfig
)
{
for
(
auto
&
&
config
:
GetSupportedKeySystems
(
)
)
{
if
(
config
.
mKeySystem
.
Equals
(
aKeySystem
)
)
{
aOutKeySystemConfig
=
std
:
:
move
(
config
)
;
return
true
;
}
}
return
false
;
}
bool
MediaKeySystemAccess
:
:
KeySystemSupportsInitDataType
(
const
nsAString
&
aKeySystem
const
nsAString
&
aInitDataType
)
{
KeySystemConfig
implementation
;
return
GetKeySystemConfig
(
aKeySystem
implementation
)
&
&
implementation
.
mInitDataTypes
.
Contains
(
aInitDataType
)
;
}
enum
CodecType
{
Audio
Video
Invalid
}
;
static
bool
CanDecryptAndDecode
(
const
nsString
&
aKeySystem
const
nsString
&
aContentType
CodecType
aCodecType
const
KeySystemConfig
:
:
ContainerSupport
&
aContainerSupport
const
nsTArray
<
KeySystemConfig
:
:
EMECodecString
>
&
aCodecs
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
MOZ_ASSERT
(
aCodecType
!
=
Invalid
)
;
for
(
const
KeySystemConfig
:
:
EMECodecString
&
codec
:
aCodecs
)
{
MOZ_ASSERT
(
!
codec
.
IsEmpty
(
)
)
;
if
(
aContainerSupport
.
DecryptsAndDecodes
(
codec
)
)
{
continue
;
}
if
(
aContainerSupport
.
Decrypts
(
codec
)
)
{
IgnoredErrorResult
rv
;
MediaSource
:
:
IsTypeSupported
(
aContentType
aDiagnostics
rv
)
;
if
(
!
rv
.
Failed
(
)
)
{
continue
;
}
}
#
if
defined
(
XP_WIN
)
if
(
codec
=
=
KeySystemConfig
:
:
EME_CODEC_AAC
&
&
IsWidevineKeySystem
(
aKeySystem
)
&
&
!
WMFDecoderModule
:
:
CanCreateMFTDecoder
(
WMFStreamType
:
:
AAC
)
)
{
if
(
aDiagnostics
)
{
aDiagnostics
-
>
SetKeySystemIssue
(
DecoderDoctorDiagnostics
:
:
eWidevineWithNoWMF
)
;
}
}
#
endif
return
false
;
}
return
true
;
}
static
bool
SupportsEncryptionScheme
(
const
nsString
&
aEncryptionScheme
const
nsTArray
<
nsString
>
&
aSupportedEncryptionSchemes
)
{
MOZ_ASSERT
(
DOMStringIsNull
(
aEncryptionScheme
)
|
|
StaticPrefs
:
:
media_eme_encrypted_media_encryption_scheme_enabled
(
)
"
Encryption
scheme
checking
support
must
be
preffed
on
for
"
"
encryptionScheme
to
be
a
non
-
null
string
"
)
;
if
(
DOMStringIsNull
(
aEncryptionScheme
)
)
{
return
true
;
}
return
aSupportedEncryptionSchemes
.
Contains
(
aEncryptionScheme
)
;
}
static
bool
ToSessionType
(
const
nsAString
&
aSessionType
MediaKeySessionType
&
aOutType
)
{
if
(
aSessionType
.
Equals
(
ToString
(
MediaKeySessionType
:
:
Temporary
)
)
)
{
aOutType
=
MediaKeySessionType
:
:
Temporary
;
return
true
;
}
if
(
aSessionType
.
Equals
(
ToString
(
MediaKeySessionType
:
:
Persistent_license
)
)
)
{
aOutType
=
MediaKeySessionType
:
:
Persistent_license
;
return
true
;
}
return
false
;
}
static
bool
IsPersistentSessionType
(
MediaKeySessionType
aSessionType
)
{
return
aSessionType
=
=
MediaKeySessionType
:
:
Persistent_license
;
}
static
bool
ContainsSessionType
(
const
nsTArray
<
KeySystemConfig
:
:
SessionType
>
&
aTypes
const
MediaKeySessionType
&
aSessionType
)
{
return
(
aSessionType
=
=
MediaKeySessionType
:
:
Persistent_license
&
&
aTypes
.
Contains
(
KeySystemConfig
:
:
SessionType
:
:
PersistentLicense
)
)
|
|
(
aSessionType
=
=
MediaKeySessionType
:
:
Temporary
&
&
aTypes
.
Contains
(
KeySystemConfig
:
:
SessionType
:
:
Temporary
)
)
;
}
CodecType
GetMajorType
(
const
MediaMIMEType
&
aMIMEType
)
{
if
(
aMIMEType
.
HasAudioMajorType
(
)
)
{
return
Audio
;
}
if
(
aMIMEType
.
HasVideoMajorType
(
)
)
{
return
Video
;
}
return
Invalid
;
}
static
CodecType
GetCodecType
(
const
KeySystemConfig
:
:
EMECodecString
&
aCodec
)
{
if
(
aCodec
.
Equals
(
KeySystemConfig
:
:
EME_CODEC_AAC
)
|
|
aCodec
.
Equals
(
KeySystemConfig
:
:
EME_CODEC_OPUS
)
|
|
aCodec
.
Equals
(
KeySystemConfig
:
:
EME_CODEC_VORBIS
)
|
|
aCodec
.
Equals
(
KeySystemConfig
:
:
EME_CODEC_FLAC
)
)
{
return
Audio
;
}
if
(
aCodec
.
Equals
(
KeySystemConfig
:
:
EME_CODEC_H264
)
|
|
aCodec
.
Equals
(
KeySystemConfig
:
:
EME_CODEC_VP8
)
|
|
aCodec
.
Equals
(
KeySystemConfig
:
:
EME_CODEC_VP9
)
)
{
return
Video
;
}
return
Invalid
;
}
static
bool
AllCodecsOfType
(
const
nsTArray
<
KeySystemConfig
:
:
EMECodecString
>
&
aCodecs
const
CodecType
aCodecType
)
{
for
(
const
KeySystemConfig
:
:
EMECodecString
&
codec
:
aCodecs
)
{
if
(
GetCodecType
(
codec
)
!
=
aCodecType
)
{
return
false
;
}
}
return
true
;
}
static
bool
IsParameterUnrecognized
(
const
nsAString
&
aContentType
)
{
nsAutoString
contentType
(
aContentType
)
;
contentType
.
StripWhitespace
(
)
;
nsTArray
<
nsString
>
params
;
nsAString
:
:
const_iterator
start
end
semicolon
equalSign
;
contentType
.
BeginReading
(
start
)
;
contentType
.
EndReading
(
end
)
;
semicolon
=
start
;
while
(
semicolon
!
=
end
)
{
if
(
FindCharInReadable
(
'
;
'
semicolon
end
)
)
{
equalSign
=
+
+
semicolon
;
if
(
FindCharInReadable
(
'
=
'
equalSign
end
)
)
{
params
.
AppendElement
(
Substring
(
semicolon
equalSign
)
)
;
semicolon
=
equalSign
;
}
}
}
for
(
auto
param
:
params
)
{
if
(
!
param
.
LowerCaseEqualsLiteral
(
"
codecs
"
)
&
&
!
param
.
LowerCaseEqualsLiteral
(
"
profiles
"
)
)
{
return
true
;
}
}
return
false
;
}
static
Sequence
<
MediaKeySystemMediaCapability
>
GetSupportedCapabilities
(
const
CodecType
aCodecType
const
nsTArray
<
MediaKeySystemMediaCapability
>
&
aRequestedCapabilities
const
MediaKeySystemConfiguration
&
aPartialConfig
const
KeySystemConfig
&
aKeySystem
DecoderDoctorDiagnostics
*
aDiagnostics
const
std
:
:
function
<
void
(
const
char
*
)
>
&
aDeprecationLogFn
)
{
Sequence
<
MediaKeySystemMediaCapability
>
supportedCapabilities
;
for
(
const
MediaKeySystemMediaCapability
&
capabilities
:
aRequestedCapabilities
)
{
const
nsString
&
contentTypeString
=
capabilities
.
mContentType
;
const
nsString
&
robustness
=
capabilities
.
mRobustness
;
const
nsString
encryptionScheme
=
capabilities
.
mEncryptionScheme
;
if
(
contentTypeString
.
IsEmpty
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
'
%
s
'
)
rejected
;
"
"
audio
or
video
capability
has
empty
contentType
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentTypeString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
encryptionScheme
)
.
get
(
)
)
;
return
Sequence
<
MediaKeySystemMediaCapability
>
(
)
;
}
Maybe
<
MediaContainerType
>
maybeContainerType
=
MakeMediaContainerType
(
contentTypeString
)
;
if
(
!
maybeContainerType
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
failed
to
parse
contentTypeString
as
MIME
type
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentTypeString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
encryptionScheme
)
.
get
(
)
)
;
continue
;
}
const
MediaContainerType
&
containerType
=
*
maybeContainerType
;
bool
invalid
=
false
;
nsTArray
<
KeySystemConfig
:
:
EMECodecString
>
codecs
;
for
(
const
auto
&
codecString
:
containerType
.
ExtendedType
(
)
.
Codecs
(
)
.
Range
(
)
)
{
KeySystemConfig
:
:
EMECodecString
emeCodec
=
ToEMEAPICodecString
(
nsString
(
codecString
)
)
;
if
(
emeCodec
.
IsEmpty
(
)
)
{
invalid
=
true
;
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
'
%
s
'
is
an
invalid
codec
string
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentTypeString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
encryptionScheme
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
codecString
)
.
get
(
)
)
;
break
;
}
codecs
.
AppendElement
(
emeCodec
)
;
}
if
(
invalid
)
{
continue
;
}
const
bool
isMP4
=
DecoderTraits
:
:
IsMP4SupportedType
(
containerType
aDiagnostics
)
;
if
(
isMP4
&
&
!
aKeySystem
.
mMP4
.
IsSupported
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
MP4
requested
but
unsupported
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentTypeString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
encryptionScheme
)
.
get
(
)
)
;
continue
;
}
const
bool
isWebM
=
WebMDecoder
:
:
IsSupportedType
(
containerType
)
;
if
(
isWebM
&
&
!
aKeySystem
.
mWebM
.
IsSupported
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
%
s
'
)
unsupported
;
"
"
WebM
requested
but
unsupported
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentTypeString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
encryptionScheme
)
.
get
(
)
)
;
continue
;
}
if
(
!
isMP4
&
&
!
isWebM
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
Unsupported
or
unrecognized
container
requested
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentTypeString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
encryptionScheme
)
.
get
(
)
)
;
continue
;
}
if
(
IsParameterUnrecognized
(
contentTypeString
)
)
{
continue
;
}
if
(
codecs
.
IsEmpty
(
)
)
{
aDeprecationLogFn
(
"
MediaEMENoCodecsDeprecatedWarning
"
)
;
if
(
isMP4
)
{
if
(
aCodecType
=
=
Audio
)
{
codecs
.
AppendElement
(
KeySystemConfig
:
:
EME_CODEC_AAC
)
;
}
else
if
(
aCodecType
=
=
Video
)
{
codecs
.
AppendElement
(
KeySystemConfig
:
:
EME_CODEC_H264
)
;
}
}
else
if
(
isWebM
)
{
if
(
aCodecType
=
=
Audio
)
{
codecs
.
AppendElement
(
KeySystemConfig
:
:
EME_CODEC_VORBIS
)
;
}
else
if
(
aCodecType
=
=
Video
)
{
codecs
.
AppendElement
(
KeySystemConfig
:
:
EME_CODEC_VP8
)
;
}
}
}
const
auto
majorType
=
GetMajorType
(
containerType
.
Type
(
)
)
;
if
(
majorType
=
=
Invalid
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
MIME
type
is
not
an
audio
or
video
MIME
type
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentTypeString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
encryptionScheme
)
.
get
(
)
)
;
continue
;
}
if
(
majorType
!
=
aCodecType
|
|
!
AllCodecsOfType
(
codecs
aCodecType
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
MIME
type
mixes
audio
codecs
in
video
capabilities
"
"
or
video
codecs
in
audio
capabilities
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentTypeString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
encryptionScheme
)
.
get
(
)
)
;
continue
;
}
if
(
!
robustness
.
IsEmpty
(
)
)
{
if
(
majorType
=
=
Audio
&
&
!
aKeySystem
.
mAudioRobustness
.
Contains
(
robustness
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
unsupported
robustness
string
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentTypeString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
encryptionScheme
)
.
get
(
)
)
;
continue
;
}
if
(
majorType
=
=
Video
&
&
!
aKeySystem
.
mVideoRobustness
.
Contains
(
robustness
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
unsupported
robustness
string
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentTypeString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
encryptionScheme
)
.
get
(
)
)
;
continue
;
}
}
if
(
!
SupportsEncryptionScheme
(
encryptionScheme
aKeySystem
.
mEncryptionSchemes
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
encryption
scheme
unsupported
by
CDM
requested
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentTypeString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
encryptionScheme
)
.
get
(
)
)
;
continue
;
}
const
auto
&
containerSupport
=
isMP4
?
aKeySystem
.
mMP4
:
aKeySystem
.
mWebM
;
if
(
!
CanDecryptAndDecode
(
aKeySystem
.
mKeySystem
contentTypeString
majorType
containerSupport
codecs
aDiagnostics
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
codec
unsupported
by
CDM
requested
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentTypeString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
encryptionScheme
)
.
get
(
)
)
;
continue
;
}
if
(
!
supportedCapabilities
.
AppendElement
(
capabilities
mozilla
:
:
fallible
)
)
{
NS_WARNING
(
"
GetSupportedCapabilities
:
Malloc
failure
"
)
;
return
Sequence
<
MediaKeySystemMediaCapability
>
(
)
;
}
}
return
supportedCapabilities
;
}
static
bool
CheckRequirement
(
const
MediaKeysRequirement
aRequirement
const
KeySystemConfig
:
:
Requirement
aKeySystemRequirement
MediaKeysRequirement
&
aOutRequirement
)
{
MediaKeysRequirement
requirement
=
aRequirement
;
if
(
aRequirement
=
=
MediaKeysRequirement
:
:
Optional
&
&
aKeySystemRequirement
=
=
KeySystemConfig
:
:
Requirement
:
:
NotAllowed
)
{
requirement
=
MediaKeysRequirement
:
:
Not_allowed
;
}
switch
(
requirement
)
{
case
MediaKeysRequirement
:
:
Required
:
{
if
(
aKeySystemRequirement
=
=
KeySystemConfig
:
:
Requirement
:
:
NotAllowed
)
{
return
false
;
}
break
;
}
case
MediaKeysRequirement
:
:
Optional
:
{
break
;
}
case
MediaKeysRequirement
:
:
Not_allowed
:
{
if
(
aKeySystemRequirement
=
=
KeySystemConfig
:
:
Requirement
:
:
Required
)
{
return
false
;
}
break
;
}
default
:
{
return
false
;
}
}
aOutRequirement
=
requirement
;
return
true
;
}
static
Sequence
<
nsString
>
UnboxSessionTypes
(
const
Optional
<
Sequence
<
nsString
>
>
&
aSessionTypes
)
{
Sequence
<
nsString
>
sessionTypes
;
if
(
aSessionTypes
.
WasPassed
(
)
)
{
sessionTypes
=
aSessionTypes
.
Value
(
)
;
}
else
{
(
void
)
sessionTypes
.
AppendElement
(
ToString
(
MediaKeySessionType
:
:
Temporary
)
mozilla
:
:
fallible
)
;
}
return
sessionTypes
;
}
static
bool
GetSupportedConfig
(
const
KeySystemConfig
&
aKeySystem
const
MediaKeySystemConfiguration
&
aCandidate
MediaKeySystemConfiguration
&
aOutConfig
DecoderDoctorDiagnostics
*
aDiagnostics
bool
aInPrivateBrowsing
const
std
:
:
function
<
void
(
const
char
*
)
>
&
aDeprecationLogFn
)
{
MediaKeySystemConfiguration
config
;
config
.
mLabel
=
aCandidate
.
mLabel
;
if
(
!
aCandidate
.
mInitDataTypes
.
IsEmpty
(
)
)
{
nsTArray
<
nsString
>
supportedTypes
;
for
(
const
nsString
&
initDataType
:
aCandidate
.
mInitDataTypes
)
{
if
(
aKeySystem
.
mInitDataTypes
.
Contains
(
initDataType
)
)
{
supportedTypes
.
AppendElement
(
initDataType
)
;
}
}
if
(
supportedTypes
.
IsEmpty
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
no
supported
initDataTypes
provided
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
if
(
!
config
.
mInitDataTypes
.
Assign
(
supportedTypes
)
)
{
return
false
;
}
}
if
(
!
CheckRequirement
(
aCandidate
.
mDistinctiveIdentifier
aKeySystem
.
mDistinctiveIdentifier
config
.
mDistinctiveIdentifier
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
distinctiveIdentifier
requirement
not
satisfied
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
if
(
!
CheckRequirement
(
aCandidate
.
mPersistentState
aKeySystem
.
mPersistentState
config
.
mPersistentState
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
persistentState
requirement
not
satisfied
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
if
(
config
.
mPersistentState
=
=
MediaKeysRequirement
:
:
Required
&
&
aInPrivateBrowsing
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
persistentState
requested
in
Private
Browsing
window
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
Sequence
<
nsString
>
sessionTypes
(
UnboxSessionTypes
(
aCandidate
.
mSessionTypes
)
)
;
if
(
sessionTypes
.
IsEmpty
(
)
)
{
return
false
;
}
for
(
const
auto
&
sessionTypeString
:
sessionTypes
)
{
MediaKeySessionType
sessionType
;
if
(
!
ToSessionType
(
sessionTypeString
sessionType
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
invalid
session
type
specified
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
if
(
config
.
mPersistentState
=
=
MediaKeysRequirement
:
:
Not_allowed
&
&
IsPersistentSessionType
(
sessionType
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
persistent
session
requested
but
keysystem
doesn
'
t
"
"
support
persistent
state
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
if
(
!
ContainsSessionType
(
aKeySystem
.
mSessionTypes
sessionType
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
session
type
'
%
s
'
unsupported
by
keySystem
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
sessionTypeString
)
.
get
(
)
)
;
return
false
;
}
if
(
config
.
mPersistentState
=
=
MediaKeysRequirement
:
:
Optional
&
&
IsPersistentSessionType
(
sessionType
)
)
{
config
.
mPersistentState
=
MediaKeysRequirement
:
:
Required
;
}
}
config
.
mSessionTypes
.
Construct
(
std
:
:
move
(
sessionTypes
)
)
;
if
(
aCandidate
.
mAudioCapabilities
.
IsEmpty
(
)
&
&
aCandidate
.
mVideoCapabilities
.
IsEmpty
(
)
)
{
aDeprecationLogFn
(
"
MediaEMENoCapabilitiesDeprecatedWarning
"
)
;
}
if
(
!
aCandidate
.
mVideoCapabilities
.
IsEmpty
(
)
)
{
Sequence
<
MediaKeySystemMediaCapability
>
caps
=
GetSupportedCapabilities
(
Video
aCandidate
.
mVideoCapabilities
config
aKeySystem
aDiagnostics
aDeprecationLogFn
)
;
if
(
caps
.
IsEmpty
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
no
supported
video
capabilities
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
config
.
mVideoCapabilities
=
std
:
:
move
(
caps
)
;
}
else
{
}
if
(
!
aCandidate
.
mAudioCapabilities
.
IsEmpty
(
)
)
{
Sequence
<
MediaKeySystemMediaCapability
>
caps
=
GetSupportedCapabilities
(
Audio
aCandidate
.
mAudioCapabilities
config
aKeySystem
aDiagnostics
aDeprecationLogFn
)
;
if
(
caps
.
IsEmpty
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
no
supported
audio
capabilities
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
config
.
mAudioCapabilities
=
std
:
:
move
(
caps
)
;
}
else
{
}
if
(
config
.
mDistinctiveIdentifier
=
=
MediaKeysRequirement
:
:
Optional
)
{
if
(
aKeySystem
.
mDistinctiveIdentifier
=
=
KeySystemConfig
:
:
Requirement
:
:
Required
)
{
config
.
mDistinctiveIdentifier
=
MediaKeysRequirement
:
:
Required
;
}
else
{
config
.
mDistinctiveIdentifier
=
MediaKeysRequirement
:
:
Not_allowed
;
}
}
if
(
config
.
mPersistentState
=
=
MediaKeysRequirement
:
:
Optional
)
{
if
(
aKeySystem
.
mPersistentState
=
=
KeySystemConfig
:
:
Requirement
:
:
Required
)
{
config
.
mPersistentState
=
MediaKeysRequirement
:
:
Required
;
}
else
{
config
.
mPersistentState
=
MediaKeysRequirement
:
:
Not_allowed
;
}
}
#
if
defined
(
XP_WIN
)
if
(
IsWidevineKeySystem
(
aKeySystem
.
mKeySystem
)
&
&
(
aCandidate
.
mAudioCapabilities
.
IsEmpty
(
)
|
|
aCandidate
.
mVideoCapabilities
.
IsEmpty
(
)
)
&
&
!
WMFDecoderModule
:
:
CanCreateMFTDecoder
(
WMFStreamType
:
:
AAC
)
)
{
if
(
aDiagnostics
)
{
aDiagnostics
-
>
SetKeySystemIssue
(
DecoderDoctorDiagnostics
:
:
eWidevineWithNoWMF
)
;
}
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
WMF
required
for
Widevine
decoding
but
it
'
s
not
available
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
#
endif
aOutConfig
=
config
;
return
true
;
}
bool
MediaKeySystemAccess
:
:
GetSupportedConfig
(
const
nsAString
&
aKeySystem
const
Sequence
<
MediaKeySystemConfiguration
>
&
aConfigs
MediaKeySystemConfiguration
&
aOutConfig
DecoderDoctorDiagnostics
*
aDiagnostics
bool
aIsPrivateBrowsing
const
std
:
:
function
<
void
(
const
char
*
)
>
&
aDeprecationLogFn
)
{
KeySystemConfig
implementation
;
if
(
!
GetKeySystemConfig
(
aKeySystem
implementation
)
)
{
return
false
;
}
for
(
const
MediaKeySystemConfiguration
&
candidate
:
aConfigs
)
{
if
(
mozilla
:
:
dom
:
:
GetSupportedConfig
(
implementation
candidate
aOutConfig
aDiagnostics
aIsPrivateBrowsing
aDeprecationLogFn
)
)
{
return
true
;
}
}
return
false
;
}
void
MediaKeySystemAccess
:
:
NotifyObservers
(
nsPIDOMWindowInner
*
aWindow
const
nsAString
&
aKeySystem
MediaKeySystemStatus
aStatus
)
{
RequestMediaKeySystemAccessNotification
data
;
data
.
mKeySystem
=
aKeySystem
;
data
.
mStatus
=
aStatus
;
nsAutoString
json
;
data
.
ToJSON
(
json
)
;
EME_LOG
(
"
MediaKeySystemAccess
:
:
NotifyObservers
(
)
%
s
"
NS_ConvertUTF16toUTF8
(
json
)
.
get
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
aWindow
MediaKeys
:
:
kMediaKeysRequestTopic
json
.
get
(
)
)
;
}
}
static
nsCString
ToCString
(
const
nsString
&
aString
)
{
nsCString
str
(
"
'
"
)
;
str
.
Append
(
NS_ConvertUTF16toUTF8
(
aString
)
)
;
str
.
AppendLiteral
(
"
'
"
)
;
return
str
;
}
static
nsCString
ToCString
(
const
MediaKeysRequirement
aValue
)
{
nsCString
str
(
"
'
"
)
;
str
.
AppendASCII
(
MediaKeysRequirementValues
:
:
GetString
(
aValue
)
)
;
str
.
AppendLiteral
(
"
'
"
)
;
return
str
;
}
static
nsCString
ToCString
(
const
MediaKeySystemMediaCapability
&
aValue
)
{
nsCString
str
;
str
.
AppendLiteral
(
"
{
contentType
=
"
)
;
str
.
Append
(
ToCString
(
aValue
.
mContentType
)
)
;
str
.
AppendLiteral
(
"
robustness
=
"
)
;
str
.
Append
(
ToCString
(
aValue
.
mRobustness
)
)
;
str
.
AppendLiteral
(
"
encryptionScheme
=
"
)
;
str
.
Append
(
ToCString
(
aValue
.
mEncryptionScheme
)
)
;
str
.
AppendLiteral
(
"
}
"
)
;
return
str
;
}
template
<
class
Type
>
static
nsCString
ToCString
(
const
Sequence
<
Type
>
&
aSequence
)
{
nsCString
str
;
str
.
AppendLiteral
(
"
[
"
)
;
StringJoinAppend
(
str
"
"
_ns
aSequence
[
]
(
nsACString
&
dest
const
Type
&
element
)
{
dest
.
Append
(
ToCString
(
element
)
)
;
}
)
;
str
.
AppendLiteral
(
"
]
"
)
;
return
str
;
}
template
<
class
Type
>
static
nsCString
ToCString
(
const
Optional
<
Sequence
<
Type
>
>
&
aOptional
)
{
nsCString
str
;
if
(
aOptional
.
WasPassed
(
)
)
{
str
.
Append
(
ToCString
(
aOptional
.
Value
(
)
)
)
;
}
else
{
str
.
AppendLiteral
(
"
[
]
"
)
;
}
return
str
;
}
static
nsCString
ToCString
(
const
MediaKeySystemConfiguration
&
aConfig
)
{
nsCString
str
;
str
.
AppendLiteral
(
"
{
label
=
"
)
;
str
.
Append
(
ToCString
(
aConfig
.
mLabel
)
)
;
str
.
AppendLiteral
(
"
initDataTypes
=
"
)
;
str
.
Append
(
ToCString
(
aConfig
.
mInitDataTypes
)
)
;
str
.
AppendLiteral
(
"
audioCapabilities
=
"
)
;
str
.
Append
(
ToCString
(
aConfig
.
mAudioCapabilities
)
)
;
str
.
AppendLiteral
(
"
videoCapabilities
=
"
)
;
str
.
Append
(
ToCString
(
aConfig
.
mVideoCapabilities
)
)
;
str
.
AppendLiteral
(
"
distinctiveIdentifier
=
"
)
;
str
.
Append
(
ToCString
(
aConfig
.
mDistinctiveIdentifier
)
)
;
str
.
AppendLiteral
(
"
persistentState
=
"
)
;
str
.
Append
(
ToCString
(
aConfig
.
mPersistentState
)
)
;
str
.
AppendLiteral
(
"
sessionTypes
=
"
)
;
str
.
Append
(
ToCString
(
aConfig
.
mSessionTypes
)
)
;
str
.
AppendLiteral
(
"
}
"
)
;
return
str
;
}
nsCString
MediaKeySystemAccess
:
:
ToCString
(
const
Sequence
<
MediaKeySystemConfiguration
>
&
aConfig
)
{
return
mozilla
:
:
dom
:
:
ToCString
(
aConfig
)
;
}
}
