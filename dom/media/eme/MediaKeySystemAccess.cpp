#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
MediaKeySystemAccess
.
h
"
#
include
"
mozilla
/
dom
/
MediaKeySystemAccessBinding
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
MediaPrefs
.
h
"
#
include
"
nsContentTypeParser
.
h
"
#
ifdef
MOZ_FMP4
#
include
"
MP4Decoder
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
WMFDecoderModule
.
h
"
#
endif
#
include
"
nsContentCID
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
mozIGeckoMediaPluginService
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
EMEUtils
.
h
"
#
include
"
GMPUtils
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
gmp
-
audio
-
decode
.
h
"
#
include
"
gmp
-
video
-
decode
.
h
"
#
include
"
DecoderDoctorDiagnostics
.
h
"
#
include
"
WebMDecoder
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
mozilla
/
dom
/
MediaSource
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
MediaKeySystemAccess
mParent
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
MediaKeySystemAccess
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
MediaKeySystemAccess
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
MediaKeySystemAccess
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
MediaKeySystemAccess
:
:
MediaKeySystemAccess
(
nsPIDOMWindowInner
*
aParent
const
nsAString
&
aKeySystem
const
nsAString
&
aCDMVersion
const
MediaKeySystemConfiguration
&
aConfig
)
:
mParent
(
aParent
)
mKeySystem
(
aKeySystem
)
mCDMVersion
(
aCDMVersion
)
mConfig
(
aConfig
)
{
}
MediaKeySystemAccess
:
:
~
MediaKeySystemAccess
(
)
{
}
JSObject
*
MediaKeySystemAccess
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MediaKeySystemAccessBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsPIDOMWindowInner
*
MediaKeySystemAccess
:
:
GetParentObject
(
)
const
{
return
mParent
;
}
void
MediaKeySystemAccess
:
:
GetKeySystem
(
nsString
&
aOutKeySystem
)
const
{
aOutKeySystem
.
Assign
(
mKeySystem
)
;
}
void
MediaKeySystemAccess
:
:
GetConfiguration
(
MediaKeySystemConfiguration
&
aConfig
)
{
aConfig
=
mConfig
;
}
already_AddRefed
<
Promise
>
MediaKeySystemAccess
:
:
CreateMediaKeys
(
ErrorResult
&
aRv
)
{
RefPtr
<
MediaKeys
>
keys
(
new
MediaKeys
(
mParent
mKeySystem
mCDMVersion
mConfig
.
mDistinctiveIdentifier
=
=
MediaKeysRequirement
:
:
Required
mConfig
.
mPersistentState
=
=
MediaKeysRequirement
:
:
Required
)
)
;
return
keys
-
>
Init
(
aRv
)
;
}
static
bool
HaveGMPFor
(
mozIGeckoMediaPluginService
*
aGMPService
const
nsCString
&
aKeySystem
const
nsCString
&
aAPI
const
nsCString
&
aTag
=
EmptyCString
(
)
)
{
nsTArray
<
nsCString
>
tags
;
tags
.
AppendElement
(
aKeySystem
)
;
if
(
!
aTag
.
IsEmpty
(
)
)
{
tags
.
AppendElement
(
aTag
)
;
}
bool
hasPlugin
=
false
;
if
(
NS_FAILED
(
aGMPService
-
>
HasPluginForAPI
(
aAPI
&
tags
&
hasPlugin
)
)
)
{
return
false
;
}
return
hasPlugin
;
}
#
ifdef
XP_WIN
static
bool
AdobePluginFileExists
(
const
nsACString
&
aVersionStr
const
nsAString
&
aFilename
)
{
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Default
)
;
nsCOMPtr
<
nsIFile
>
path
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
path
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
rv
=
path
-
>
Append
(
NS_LITERAL_STRING
(
"
gmp
-
eme
-
adobe
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
rv
=
path
-
>
AppendNative
(
aVersionStr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
rv
=
path
-
>
Append
(
aFilename
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
bool
exists
=
false
;
return
NS_SUCCEEDED
(
path
-
>
Exists
(
&
exists
)
)
&
&
exists
;
}
static
bool
AdobePluginDLLExists
(
const
nsACString
&
aVersionStr
)
{
return
AdobePluginFileExists
(
aVersionStr
NS_LITERAL_STRING
(
"
eme
-
adobe
.
dll
"
)
)
;
}
static
bool
AdobePluginVoucherExists
(
const
nsACString
&
aVersionStr
)
{
return
AdobePluginFileExists
(
aVersionStr
NS_LITERAL_STRING
(
"
eme
-
adobe
.
voucher
"
)
)
;
}
#
endif
bool
MediaKeySystemAccess
:
:
IsGMPPresentOnDisk
(
const
nsAString
&
aKeySystem
const
nsACString
&
aVersion
nsACString
&
aOutMessage
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Default
)
{
ContentChild
*
contentChild
=
ContentChild
:
:
GetSingleton
(
)
;
if
(
NS_WARN_IF
(
!
contentChild
)
)
{
return
false
;
}
nsCString
message
;
bool
result
=
false
;
bool
ok
=
contentChild
-
>
SendIsGMPPresentOnDisk
(
nsString
(
aKeySystem
)
nsCString
(
aVersion
)
&
result
&
message
)
;
aOutMessage
=
message
;
return
ok
&
&
result
;
}
bool
isPresent
=
true
;
#
if
XP_WIN
if
(
IsPrimetimeKeySystem
(
aKeySystem
)
)
{
if
(
!
AdobePluginDLLExists
(
aVersion
)
)
{
NS_WARNING
(
"
Adobe
EME
plugin
disappeared
from
disk
!
"
)
;
aOutMessage
=
NS_LITERAL_CSTRING
(
"
Adobe
DLL
was
expected
to
be
on
disk
but
was
not
"
)
;
isPresent
=
false
;
}
if
(
!
AdobePluginVoucherExists
(
aVersion
)
)
{
NS_WARNING
(
"
Adobe
EME
voucher
disappeared
from
disk
!
"
)
;
aOutMessage
=
NS_LITERAL_CSTRING
(
"
Adobe
plugin
voucher
was
expected
to
be
on
disk
but
was
not
"
)
;
isPresent
=
false
;
}
if
(
!
isPresent
)
{
Preferences
:
:
ClearUser
(
"
media
.
gmp
-
eme
-
adobe
.
lastUpdate
"
)
;
Preferences
:
:
ClearUser
(
"
media
.
gmp
-
eme
-
adobe
.
version
"
)
;
}
else
if
(
!
EMEVoucherFileExists
(
)
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
Plugin
-
container
voucher
not
present
"
)
;
isPresent
=
false
;
}
}
#
endif
return
isPresent
;
}
static
MediaKeySystemStatus
EnsureMinCDMVersion
(
mozIGeckoMediaPluginService
*
aGMPService
const
nsAString
&
aKeySystem
int32_t
aMinCdmVersion
nsACString
&
aOutMessage
nsACString
&
aOutCdmVersion
)
{
nsTArray
<
nsCString
>
tags
;
tags
.
AppendElement
(
NS_ConvertUTF16toUTF8
(
aKeySystem
)
)
;
bool
hasPlugin
;
nsAutoCString
versionStr
;
if
(
NS_FAILED
(
aGMPService
-
>
GetPluginVersionForAPI
(
NS_LITERAL_CSTRING
(
GMP_API_DECRYPTOR
)
&
tags
&
hasPlugin
versionStr
)
)
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
GetPluginVersionForAPI
failed
"
)
;
return
MediaKeySystemStatus
:
:
Error
;
}
aOutCdmVersion
=
versionStr
;
if
(
!
hasPlugin
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
CDM
is
not
installed
"
)
;
return
MediaKeySystemStatus
:
:
Cdm_not_installed
;
}
if
(
!
MediaKeySystemAccess
:
:
IsGMPPresentOnDisk
(
aKeySystem
versionStr
aOutMessage
)
)
{
return
MediaKeySystemStatus
:
:
Cdm_not_installed
;
}
nsresult
rv
;
int32_t
version
=
versionStr
.
ToInteger
(
&
rv
)
;
if
(
aMinCdmVersion
!
=
NO_CDM_VERSION
&
&
(
NS_FAILED
(
rv
)
|
|
version
<
0
|
|
aMinCdmVersion
>
version
)
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
Installed
CDM
version
insufficient
"
)
;
return
MediaKeySystemStatus
:
:
Cdm_insufficient_version
;
}
return
MediaKeySystemStatus
:
:
Available
;
}
MediaKeySystemStatus
MediaKeySystemAccess
:
:
GetKeySystemStatus
(
const
nsAString
&
aKeySystem
int32_t
aMinCdmVersion
nsACString
&
aOutMessage
nsACString
&
aOutCdmVersion
)
{
MOZ_ASSERT
(
MediaPrefs
:
:
EMEEnabled
(
)
|
|
IsClearkeyKeySystem
(
aKeySystem
)
)
;
nsCOMPtr
<
mozIGeckoMediaPluginService
>
mps
=
do_GetService
(
"
mozilla
.
org
/
gecko
-
media
-
plugin
-
service
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mps
)
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
Failed
to
get
GMP
service
"
)
;
return
MediaKeySystemStatus
:
:
Error
;
}
if
(
IsClearkeyKeySystem
(
aKeySystem
)
)
{
return
EnsureMinCDMVersion
(
mps
aKeySystem
aMinCdmVersion
aOutMessage
aOutCdmVersion
)
;
}
if
(
Preferences
:
:
GetBool
(
"
media
.
gmp
-
eme
-
adobe
.
visible
"
false
)
)
{
if
(
IsPrimetimeKeySystem
(
aKeySystem
)
)
{
if
(
!
Preferences
:
:
GetBool
(
"
media
.
gmp
-
eme
-
adobe
.
enabled
"
false
)
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
Adobe
EME
disabled
"
)
;
return
MediaKeySystemStatus
:
:
Cdm_disabled
;
}
#
ifdef
XP_WIN
if
(
!
IsVistaOrLater
(
)
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
Minimum
Windows
version
(
Vista
)
not
met
for
Adobe
EME
"
)
;
return
MediaKeySystemStatus
:
:
Cdm_not_supported
;
}
#
endif
return
EnsureMinCDMVersion
(
mps
aKeySystem
aMinCdmVersion
aOutMessage
aOutCdmVersion
)
;
}
}
if
(
Preferences
:
:
GetBool
(
"
media
.
gmp
-
widevinecdm
.
visible
"
false
)
)
{
if
(
IsWidevineKeySystem
(
aKeySystem
)
)
{
#
ifdef
XP_WIN
if
(
!
IsVistaOrLater
(
)
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
Minimum
Windows
version
(
Vista
)
not
met
for
Widevine
EME
"
)
;
return
MediaKeySystemStatus
:
:
Cdm_not_supported
;
}
#
endif
if
(
!
Preferences
:
:
GetBool
(
"
media
.
gmp
-
widevinecdm
.
enabled
"
false
)
)
{
aOutMessage
=
NS_LITERAL_CSTRING
(
"
Widevine
EME
disabled
"
)
;
return
MediaKeySystemStatus
:
:
Cdm_disabled
;
}
return
EnsureMinCDMVersion
(
mps
aKeySystem
aMinCdmVersion
aOutMessage
aOutCdmVersion
)
;
}
}
return
MediaKeySystemStatus
:
:
Cdm_not_supported
;
}
typedef
nsCString
GMPCodecString
;
#
define
GMP_CODEC_AAC
NS_LITERAL_CSTRING
(
"
aac
"
)
#
define
GMP_CODEC_OPUS
NS_LITERAL_CSTRING
(
"
opus
"
)
#
define
GMP_CODEC_VORBIS
NS_LITERAL_CSTRING
(
"
vorbis
"
)
#
define
GMP_CODEC_H264
NS_LITERAL_CSTRING
(
"
h264
"
)
#
define
GMP_CODEC_VP8
NS_LITERAL_CSTRING
(
"
vp8
"
)
#
define
GMP_CODEC_VP9
NS_LITERAL_CSTRING
(
"
vp9
"
)
GMPCodecString
ToGMPAPICodecString
(
const
nsString
&
aCodec
)
{
if
(
IsAACCodecString
(
aCodec
)
)
{
return
GMP_CODEC_AAC
;
}
if
(
aCodec
.
EqualsLiteral
(
"
opus
"
)
)
{
return
GMP_CODEC_OPUS
;
}
if
(
aCodec
.
EqualsLiteral
(
"
vorbis
"
)
)
{
return
GMP_CODEC_VORBIS
;
}
if
(
IsH264CodecString
(
aCodec
)
)
{
return
GMP_CODEC_H264
;
}
if
(
IsVP8CodecString
(
aCodec
)
)
{
return
GMP_CODEC_VP8
;
}
if
(
IsVP9CodecString
(
aCodec
)
)
{
return
GMP_CODEC_VP9
;
}
return
EmptyCString
(
)
;
}
struct
KeySystemContainerSupport
{
bool
IsSupported
(
)
const
{
return
!
mCodecsDecoded
.
IsEmpty
(
)
|
|
!
mCodecsDecrypted
.
IsEmpty
(
)
;
}
bool
DecryptsAndDecodes
(
GMPCodecString
aCodec
)
const
{
return
mCodecsDecoded
.
Contains
(
aCodec
)
;
}
bool
Decrypts
(
GMPCodecString
aCodec
)
const
{
return
mCodecsDecrypted
.
Contains
(
aCodec
)
;
}
void
SetCanDecryptAndDecode
(
GMPCodecString
aCodec
)
{
MOZ_ASSERT
(
!
Decrypts
(
aCodec
)
)
;
MOZ_ASSERT
(
!
DecryptsAndDecodes
(
aCodec
)
)
;
mCodecsDecoded
.
AppendElement
(
aCodec
)
;
}
void
SetCanDecrypt
(
GMPCodecString
aCodec
)
{
MOZ_ASSERT
(
!
Decrypts
(
aCodec
)
)
;
MOZ_ASSERT
(
!
DecryptsAndDecodes
(
aCodec
)
)
;
mCodecsDecrypted
.
AppendElement
(
aCodec
)
;
}
private
:
nsTArray
<
GMPCodecString
>
mCodecsDecoded
;
nsTArray
<
GMPCodecString
>
mCodecsDecrypted
;
}
;
enum
class
KeySystemFeatureSupport
{
Prohibited
=
1
Requestable
=
2
Required
=
3
}
;
struct
KeySystemConfig
{
nsString
mKeySystem
;
nsTArray
<
nsString
>
mInitDataTypes
;
KeySystemFeatureSupport
mPersistentState
=
KeySystemFeatureSupport
:
:
Prohibited
;
KeySystemFeatureSupport
mDistinctiveIdentifier
=
KeySystemFeatureSupport
:
:
Prohibited
;
nsTArray
<
MediaKeySessionType
>
mSessionTypes
;
nsTArray
<
nsString
>
mVideoRobustness
;
nsTArray
<
nsString
>
mAudioRobustness
;
KeySystemContainerSupport
mMP4
;
KeySystemContainerSupport
mWebM
;
}
;
StaticAutoPtr
<
nsTArray
<
KeySystemConfig
>
>
sKeySystemConfigs
;
static
const
nsTArray
<
KeySystemConfig
>
&
GetSupportedKeySystems
(
)
{
if
(
!
sKeySystemConfigs
)
{
sKeySystemConfigs
=
new
nsTArray
<
KeySystemConfig
>
(
)
;
ClearOnShutdown
(
&
sKeySystemConfigs
)
;
{
KeySystemConfig
clearkey
;
clearkey
.
mKeySystem
=
NS_ConvertUTF8toUTF16
(
kEMEKeySystemClearkey
)
;
clearkey
.
mInitDataTypes
.
AppendElement
(
NS_LITERAL_STRING
(
"
cenc
"
)
)
;
clearkey
.
mInitDataTypes
.
AppendElement
(
NS_LITERAL_STRING
(
"
keyids
"
)
)
;
clearkey
.
mInitDataTypes
.
AppendElement
(
NS_LITERAL_STRING
(
"
webm
"
)
)
;
clearkey
.
mPersistentState
=
KeySystemFeatureSupport
:
:
Requestable
;
clearkey
.
mDistinctiveIdentifier
=
KeySystemFeatureSupport
:
:
Prohibited
;
clearkey
.
mSessionTypes
.
AppendElement
(
MediaKeySessionType
:
:
Temporary
)
;
clearkey
.
mSessionTypes
.
AppendElement
(
MediaKeySessionType
:
:
Persistent_license
)
;
#
if
defined
(
XP_WIN
)
if
(
WMFDecoderModule
:
:
HasAAC
(
)
)
{
clearkey
.
mMP4
.
SetCanDecryptAndDecode
(
GMP_CODEC_AAC
)
;
}
else
{
clearkey
.
mMP4
.
SetCanDecrypt
(
GMP_CODEC_AAC
)
;
}
if
(
WMFDecoderModule
:
:
HasH264
(
)
)
{
clearkey
.
mMP4
.
SetCanDecryptAndDecode
(
GMP_CODEC_H264
)
;
}
else
{
clearkey
.
mMP4
.
SetCanDecrypt
(
GMP_CODEC_H264
)
;
}
#
else
clearkey
.
mMP4
.
SetCanDecrypt
(
GMP_CODEC_AAC
)
;
clearkey
.
mMP4
.
SetCanDecrypt
(
GMP_CODEC_H264
)
;
#
endif
clearkey
.
mWebM
.
SetCanDecrypt
(
GMP_CODEC_VORBIS
)
;
clearkey
.
mWebM
.
SetCanDecrypt
(
GMP_CODEC_OPUS
)
;
clearkey
.
mWebM
.
SetCanDecrypt
(
GMP_CODEC_VP8
)
;
clearkey
.
mWebM
.
SetCanDecrypt
(
GMP_CODEC_VP9
)
;
sKeySystemConfigs
-
>
AppendElement
(
Move
(
clearkey
)
)
;
}
{
KeySystemConfig
widevine
;
widevine
.
mKeySystem
=
NS_ConvertUTF8toUTF16
(
kEMEKeySystemWidevine
)
;
widevine
.
mInitDataTypes
.
AppendElement
(
NS_LITERAL_STRING
(
"
cenc
"
)
)
;
widevine
.
mInitDataTypes
.
AppendElement
(
NS_LITERAL_STRING
(
"
keyids
"
)
)
;
widevine
.
mInitDataTypes
.
AppendElement
(
NS_LITERAL_STRING
(
"
webm
"
)
)
;
widevine
.
mPersistentState
=
KeySystemFeatureSupport
:
:
Requestable
;
widevine
.
mDistinctiveIdentifier
=
KeySystemFeatureSupport
:
:
Prohibited
;
widevine
.
mSessionTypes
.
AppendElement
(
MediaKeySessionType
:
:
Temporary
)
;
widevine
.
mAudioRobustness
.
AppendElement
(
NS_LITERAL_STRING
(
"
SW_SECURE_CRYPTO
"
)
)
;
widevine
.
mVideoRobustness
.
AppendElement
(
NS_LITERAL_STRING
(
"
SW_SECURE_DECODE
"
)
)
;
#
if
defined
(
XP_WIN
)
if
(
WMFDecoderModule
:
:
HasAAC
(
)
)
{
widevine
.
mMP4
.
SetCanDecrypt
(
GMP_CODEC_AAC
)
;
}
#
else
widevine
.
mMP4
.
SetCanDecrypt
(
GMP_CODEC_AAC
)
;
#
endif
widevine
.
mMP4
.
SetCanDecryptAndDecode
(
GMP_CODEC_H264
)
;
widevine
.
mWebM
.
SetCanDecrypt
(
GMP_CODEC_VORBIS
)
;
widevine
.
mWebM
.
SetCanDecrypt
(
GMP_CODEC_OPUS
)
;
widevine
.
mWebM
.
SetCanDecryptAndDecode
(
GMP_CODEC_VP8
)
;
widevine
.
mWebM
.
SetCanDecryptAndDecode
(
GMP_CODEC_VP9
)
;
sKeySystemConfigs
-
>
AppendElement
(
Move
(
widevine
)
)
;
}
{
KeySystemConfig
primetime
;
primetime
.
mKeySystem
=
NS_ConvertUTF8toUTF16
(
kEMEKeySystemPrimetime
)
;
primetime
.
mInitDataTypes
.
AppendElement
(
NS_LITERAL_STRING
(
"
cenc
"
)
)
;
primetime
.
mPersistentState
=
KeySystemFeatureSupport
:
:
Required
;
primetime
.
mDistinctiveIdentifier
=
KeySystemFeatureSupport
:
:
Required
;
primetime
.
mSessionTypes
.
AppendElement
(
MediaKeySessionType
:
:
Temporary
)
;
primetime
.
mMP4
.
SetCanDecryptAndDecode
(
GMP_CODEC_AAC
)
;
primetime
.
mMP4
.
SetCanDecryptAndDecode
(
GMP_CODEC_H264
)
;
sKeySystemConfigs
-
>
AppendElement
(
Move
(
primetime
)
)
;
}
}
return
*
sKeySystemConfigs
;
}
static
const
KeySystemConfig
*
GetKeySystemConfig
(
const
nsAString
&
aKeySystem
)
{
for
(
const
KeySystemConfig
&
config
:
GetSupportedKeySystems
(
)
)
{
if
(
config
.
mKeySystem
.
Equals
(
aKeySystem
)
)
{
return
&
config
;
}
}
return
nullptr
;
}
enum
CodecType
{
Audio
Video
Invalid
}
;
static
bool
CanDecryptAndDecode
(
mozIGeckoMediaPluginService
*
aGMPService
const
nsString
&
aKeySystem
const
nsString
&
aContentType
CodecType
aCodecType
const
KeySystemContainerSupport
&
aContainerSupport
const
nsTArray
<
GMPCodecString
>
&
aCodecs
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
MOZ_ASSERT
(
aCodecType
!
=
Invalid
)
;
MOZ_ASSERT
(
HaveGMPFor
(
aGMPService
NS_ConvertUTF16toUTF8
(
aKeySystem
)
NS_LITERAL_CSTRING
(
GMP_API_DECRYPTOR
)
)
)
;
for
(
const
GMPCodecString
&
codec
:
aCodecs
)
{
MOZ_ASSERT
(
!
codec
.
IsEmpty
(
)
)
;
nsCString
api
=
(
aCodecType
=
=
Audio
)
?
NS_LITERAL_CSTRING
(
GMP_API_AUDIO_DECODER
)
:
NS_LITERAL_CSTRING
(
GMP_API_VIDEO_DECODER
)
;
if
(
aContainerSupport
.
DecryptsAndDecodes
(
codec
)
&
&
HaveGMPFor
(
aGMPService
NS_ConvertUTF16toUTF8
(
aKeySystem
)
api
codec
)
)
{
continue
;
}
if
(
aContainerSupport
.
Decrypts
(
codec
)
&
&
NS_SUCCEEDED
(
MediaSource
:
:
IsTypeSupported
(
aContentType
aDiagnostics
)
)
)
{
continue
;
}
#
if
defined
(
XP_WIN
)
if
(
codec
=
=
GMP_CODEC_AAC
&
&
IsWidevineKeySystem
(
aKeySystem
)
&
&
!
WMFDecoderModule
:
:
HasAAC
(
)
)
{
if
(
aDiagnostics
)
{
aDiagnostics
-
>
SetKeySystemIssue
(
DecoderDoctorDiagnostics
:
:
eWidevineWithNoWMF
)
;
}
}
#
endif
return
false
;
}
return
true
;
}
static
bool
ToSessionType
(
const
nsAString
&
aSessionType
MediaKeySessionType
&
aOutType
)
{
using
MediaKeySessionTypeValues
:
:
strings
;
const
char
*
temporary
=
strings
[
static_cast
<
uint32_t
>
(
MediaKeySessionType
:
:
Temporary
)
]
.
value
;
if
(
aSessionType
.
EqualsASCII
(
temporary
)
)
{
aOutType
=
MediaKeySessionType
:
:
Temporary
;
return
true
;
}
const
char
*
persistentLicense
=
strings
[
static_cast
<
uint32_t
>
(
MediaKeySessionType
:
:
Persistent_license
)
]
.
value
;
if
(
aSessionType
.
EqualsASCII
(
persistentLicense
)
)
{
aOutType
=
MediaKeySessionType
:
:
Persistent_license
;
return
true
;
}
return
false
;
}
static
bool
IsPersistentSessionType
(
MediaKeySessionType
aSessionType
)
{
return
aSessionType
=
=
MediaKeySessionType
:
:
Persistent_license
;
}
CodecType
GetMajorType
(
const
nsAString
&
aContentType
)
{
if
(
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
audio
/
"
)
aContentType
)
)
{
return
Audio
;
}
if
(
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
video
/
"
)
aContentType
)
)
{
return
Video
;
}
return
Invalid
;
}
static
CodecType
GetCodecType
(
const
GMPCodecString
&
aCodec
)
{
if
(
aCodec
.
Equals
(
GMP_CODEC_AAC
)
|
|
aCodec
.
Equals
(
GMP_CODEC_OPUS
)
|
|
aCodec
.
Equals
(
GMP_CODEC_VORBIS
)
)
{
return
Audio
;
}
if
(
aCodec
.
Equals
(
GMP_CODEC_H264
)
|
|
aCodec
.
Equals
(
GMP_CODEC_VP8
)
|
|
aCodec
.
Equals
(
GMP_CODEC_VP9
)
)
{
return
Video
;
}
return
Invalid
;
}
static
bool
AllCodecsOfType
(
const
nsTArray
<
GMPCodecString
>
&
aCodecs
const
CodecType
aCodecType
)
{
for
(
const
GMPCodecString
&
codec
:
aCodecs
)
{
if
(
GetCodecType
(
codec
)
!
=
aCodecType
)
{
return
false
;
}
}
return
true
;
}
static
bool
IsParameterUnrecognized
(
const
nsAString
&
aContentType
)
{
nsAutoString
contentType
(
aContentType
)
;
contentType
.
StripWhitespace
(
)
;
nsTArray
<
nsString
>
params
;
nsAString
:
:
const_iterator
start
end
semicolon
equalSign
;
contentType
.
BeginReading
(
start
)
;
contentType
.
EndReading
(
end
)
;
semicolon
=
start
;
while
(
semicolon
!
=
end
)
{
if
(
FindCharInReadable
(
'
;
'
semicolon
end
)
)
{
equalSign
=
+
+
semicolon
;
if
(
FindCharInReadable
(
'
=
'
equalSign
end
)
)
{
params
.
AppendElement
(
Substring
(
semicolon
equalSign
)
)
;
semicolon
=
equalSign
;
}
}
}
for
(
auto
param
:
params
)
{
if
(
!
param
.
LowerCaseEqualsLiteral
(
"
codecs
"
)
&
&
!
param
.
LowerCaseEqualsLiteral
(
"
profiles
"
)
)
{
return
true
;
}
}
return
false
;
}
static
Sequence
<
MediaKeySystemMediaCapability
>
GetSupportedCapabilities
(
const
CodecType
aCodecType
mozIGeckoMediaPluginService
*
aGMPService
const
nsTArray
<
MediaKeySystemMediaCapability
>
&
aRequestedCapabilities
const
MediaKeySystemConfiguration
&
aPartialConfig
const
KeySystemConfig
&
aKeySystem
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
Sequence
<
MediaKeySystemMediaCapability
>
supportedCapabilities
;
for
(
const
MediaKeySystemMediaCapability
&
capabilities
:
aRequestedCapabilities
)
{
const
nsString
&
contentType
=
capabilities
.
mContentType
;
const
nsString
&
robustness
=
capabilities
.
mRobustness
;
if
(
contentType
.
IsEmpty
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
rejected
;
"
"
audio
or
video
capability
has
empty
contentType
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
return
Sequence
<
MediaKeySystemMediaCapability
>
(
)
;
}
nsAutoString
container
;
nsTArray
<
nsString
>
codecStrings
;
if
(
!
ParseMIMETypeString
(
contentType
container
codecStrings
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
failed
to
parse
contentType
as
MIME
type
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
bool
invalid
=
false
;
nsTArray
<
GMPCodecString
>
codecs
;
for
(
const
nsString
&
codecString
:
codecStrings
)
{
GMPCodecString
gmpCodec
=
ToGMPAPICodecString
(
codecString
)
;
if
(
gmpCodec
.
IsEmpty
(
)
)
{
invalid
=
true
;
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
'
%
s
'
is
an
invalid
codec
string
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
codecString
)
.
get
(
)
)
;
break
;
}
codecs
.
AppendElement
(
gmpCodec
)
;
}
if
(
invalid
)
{
continue
;
}
NS_ConvertUTF16toUTF8
container_utf8
(
container
)
;
const
bool
isMP4
=
DecoderTraits
:
:
IsMP4TypeAndEnabled
(
container_utf8
aDiagnostics
)
;
if
(
isMP4
&
&
!
aKeySystem
.
mMP4
.
IsSupported
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
MP4
requested
but
unsupported
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
const
bool
isWebM
=
DecoderTraits
:
:
IsWebMTypeAndEnabled
(
container_utf8
)
;
if
(
isWebM
&
&
!
aKeySystem
.
mWebM
.
IsSupported
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
WebM
requested
but
unsupported
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
if
(
!
isMP4
&
&
!
isWebM
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
Unsupported
or
unrecognized
container
requested
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
if
(
IsParameterUnrecognized
(
contentType
)
)
{
continue
;
}
if
(
codecs
.
IsEmpty
(
)
)
{
if
(
isMP4
)
{
if
(
aCodecType
=
=
Audio
)
{
codecs
.
AppendElement
(
GMP_CODEC_AAC
)
;
}
else
if
(
aCodecType
=
=
Video
)
{
codecs
.
AppendElement
(
GMP_CODEC_H264
)
;
}
}
else
if
(
isWebM
)
{
if
(
aCodecType
=
=
Audio
)
{
codecs
.
AppendElement
(
GMP_CODEC_VORBIS
)
;
}
else
if
(
aCodecType
=
=
Video
)
{
codecs
.
AppendElement
(
GMP_CODEC_VP8
)
;
}
}
}
const
auto
majorType
=
GetMajorType
(
container
)
;
if
(
majorType
=
=
Invalid
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
MIME
type
is
not
an
audio
or
video
MIME
type
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
if
(
majorType
!
=
aCodecType
|
|
!
AllCodecsOfType
(
codecs
aCodecType
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
MIME
type
mixes
audio
codecs
in
video
capabilities
"
"
or
video
codecs
in
audio
capabilities
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
if
(
!
robustness
.
IsEmpty
(
)
)
{
if
(
majorType
=
=
Audio
&
&
!
aKeySystem
.
mAudioRobustness
.
Contains
(
robustness
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
unsupported
robustness
string
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
if
(
majorType
=
=
Video
&
&
!
aKeySystem
.
mVideoRobustness
.
Contains
(
robustness
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
unsupported
robustness
string
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
}
const
auto
&
containerSupport
=
isMP4
?
aKeySystem
.
mMP4
:
aKeySystem
.
mWebM
;
if
(
!
CanDecryptAndDecode
(
aGMPService
aKeySystem
.
mKeySystem
contentType
majorType
containerSupport
codecs
aDiagnostics
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
"
"
MediaKeySystemMediaCapability
(
'
%
s
'
'
%
s
'
)
unsupported
;
"
"
codec
unsupported
by
CDM
requested
.
"
NS_ConvertUTF16toUTF8
(
aPartialConfig
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
contentType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
robustness
)
.
get
(
)
)
;
continue
;
}
if
(
!
supportedCapabilities
.
AppendElement
(
capabilities
mozilla
:
:
fallible
)
)
{
NS_WARNING
(
"
GetSupportedCapabilities
:
Malloc
failure
"
)
;
return
Sequence
<
MediaKeySystemMediaCapability
>
(
)
;
}
}
return
Move
(
supportedCapabilities
)
;
}
static
bool
CheckRequirement
(
const
MediaKeysRequirement
aRequirement
const
KeySystemFeatureSupport
aFeatureSupport
MediaKeysRequirement
&
aOutRequirement
)
{
MediaKeysRequirement
requirement
=
aRequirement
;
if
(
aRequirement
=
=
MediaKeysRequirement
:
:
Optional
&
&
aFeatureSupport
=
=
KeySystemFeatureSupport
:
:
Prohibited
)
{
requirement
=
MediaKeysRequirement
:
:
Not_allowed
;
}
switch
(
requirement
)
{
case
MediaKeysRequirement
:
:
Required
:
{
if
(
aFeatureSupport
=
=
KeySystemFeatureSupport
:
:
Prohibited
)
{
return
false
;
}
break
;
}
case
MediaKeysRequirement
:
:
Optional
:
{
break
;
}
case
MediaKeysRequirement
:
:
Not_allowed
:
{
if
(
aFeatureSupport
=
=
KeySystemFeatureSupport
:
:
Required
)
{
return
false
;
}
break
;
}
default
:
{
return
false
;
}
}
aOutRequirement
=
requirement
;
return
true
;
}
static
Sequence
<
nsString
>
UnboxSessionTypes
(
const
Optional
<
Sequence
<
nsString
>
>
&
aSessionTypes
)
{
Sequence
<
nsString
>
sessionTypes
;
if
(
aSessionTypes
.
WasPassed
(
)
)
{
sessionTypes
=
aSessionTypes
.
Value
(
)
;
}
else
{
using
MediaKeySessionTypeValues
:
:
strings
;
const
char
*
temporary
=
strings
[
static_cast
<
uint32_t
>
(
MediaKeySessionType
:
:
Temporary
)
]
.
value
;
sessionTypes
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
nsDependentCString
(
temporary
)
)
mozilla
:
:
fallible
)
;
}
return
sessionTypes
;
}
static
bool
GetSupportedConfig
(
mozIGeckoMediaPluginService
*
aGMPService
const
KeySystemConfig
&
aKeySystem
const
MediaKeySystemConfiguration
&
aCandidate
MediaKeySystemConfiguration
&
aOutConfig
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
MediaKeySystemConfiguration
config
;
config
.
mLabel
=
aCandidate
.
mLabel
;
if
(
!
aCandidate
.
mInitDataTypes
.
IsEmpty
(
)
)
{
nsTArray
<
nsString
>
supportedTypes
;
for
(
const
nsString
&
initDataType
:
aCandidate
.
mInitDataTypes
)
{
if
(
aKeySystem
.
mInitDataTypes
.
Contains
(
initDataType
)
)
{
supportedTypes
.
AppendElement
(
initDataType
)
;
}
}
if
(
supportedTypes
.
IsEmpty
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
no
supported
initDataTypes
provided
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
if
(
!
config
.
mInitDataTypes
.
Assign
(
supportedTypes
)
)
{
return
false
;
}
}
if
(
!
CheckRequirement
(
aCandidate
.
mDistinctiveIdentifier
aKeySystem
.
mDistinctiveIdentifier
config
.
mDistinctiveIdentifier
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
distinctiveIdentifier
requirement
not
satisfied
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
if
(
!
CheckRequirement
(
aCandidate
.
mPersistentState
aKeySystem
.
mPersistentState
config
.
mPersistentState
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
persistentState
requirement
not
satisfied
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
Sequence
<
nsString
>
sessionTypes
(
UnboxSessionTypes
(
aCandidate
.
mSessionTypes
)
)
;
if
(
sessionTypes
.
IsEmpty
(
)
)
{
return
false
;
}
for
(
const
auto
&
sessionTypeString
:
sessionTypes
)
{
MediaKeySessionType
sessionType
;
if
(
!
ToSessionType
(
sessionTypeString
sessionType
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
invalid
session
type
specified
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
if
(
config
.
mPersistentState
=
=
MediaKeysRequirement
:
:
Not_allowed
&
&
IsPersistentSessionType
(
sessionType
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
persistent
session
requested
but
keysystem
doesn
'
t
"
"
support
persistent
state
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
if
(
!
aKeySystem
.
mSessionTypes
.
Contains
(
sessionType
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
session
type
'
%
s
'
unsupported
by
keySystem
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
sessionTypeString
)
.
get
(
)
)
;
return
false
;
}
if
(
config
.
mPersistentState
=
=
MediaKeysRequirement
:
:
Optional
&
&
IsPersistentSessionType
(
sessionType
)
)
{
config
.
mPersistentState
=
MediaKeysRequirement
:
:
Required
;
}
}
config
.
mSessionTypes
.
Construct
(
Move
(
sessionTypes
)
)
;
if
(
!
aCandidate
.
mVideoCapabilities
.
IsEmpty
(
)
)
{
Sequence
<
MediaKeySystemMediaCapability
>
caps
=
GetSupportedCapabilities
(
Video
aGMPService
aCandidate
.
mVideoCapabilities
config
aKeySystem
aDiagnostics
)
;
if
(
caps
.
IsEmpty
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
no
supported
video
capabilities
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
config
.
mVideoCapabilities
=
Move
(
caps
)
;
}
else
{
}
if
(
!
aCandidate
.
mAudioCapabilities
.
IsEmpty
(
)
)
{
Sequence
<
MediaKeySystemMediaCapability
>
caps
=
GetSupportedCapabilities
(
Audio
aGMPService
aCandidate
.
mAudioCapabilities
config
aKeySystem
aDiagnostics
)
;
if
(
caps
.
IsEmpty
(
)
)
{
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
no
supported
audio
capabilities
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
config
.
mAudioCapabilities
=
Move
(
caps
)
;
}
else
{
}
if
(
config
.
mDistinctiveIdentifier
=
=
MediaKeysRequirement
:
:
Optional
)
{
if
(
aKeySystem
.
mDistinctiveIdentifier
=
=
KeySystemFeatureSupport
:
:
Required
)
{
config
.
mDistinctiveIdentifier
=
MediaKeysRequirement
:
:
Required
;
}
else
{
config
.
mDistinctiveIdentifier
=
MediaKeysRequirement
:
:
Not_allowed
;
}
}
if
(
config
.
mPersistentState
=
=
MediaKeysRequirement
:
:
Optional
)
{
if
(
aKeySystem
.
mPersistentState
=
=
KeySystemFeatureSupport
:
:
Required
)
{
config
.
mPersistentState
=
MediaKeysRequirement
:
:
Required
;
}
else
{
config
.
mPersistentState
=
MediaKeysRequirement
:
:
Not_allowed
;
}
}
#
if
defined
(
XP_WIN
)
if
(
IsWidevineKeySystem
(
aKeySystem
.
mKeySystem
)
&
&
(
aCandidate
.
mAudioCapabilities
.
IsEmpty
(
)
|
|
aCandidate
.
mVideoCapabilities
.
IsEmpty
(
)
)
&
&
!
WMFDecoderModule
:
:
HasAAC
(
)
)
{
if
(
aDiagnostics
)
{
aDiagnostics
-
>
SetKeySystemIssue
(
DecoderDoctorDiagnostics
:
:
eWidevineWithNoWMF
)
;
}
EME_LOG
(
"
MediaKeySystemConfiguration
(
label
=
'
%
s
'
)
rejected
;
"
"
WMF
required
for
Widevine
decoding
but
it
'
s
not
available
.
"
NS_ConvertUTF16toUTF8
(
aCandidate
.
mLabel
)
.
get
(
)
)
;
return
false
;
}
#
endif
aOutConfig
=
config
;
return
true
;
}
bool
MediaKeySystemAccess
:
:
GetSupportedConfig
(
const
nsAString
&
aKeySystem
const
Sequence
<
MediaKeySystemConfiguration
>
&
aConfigs
MediaKeySystemConfiguration
&
aOutConfig
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
nsCOMPtr
<
mozIGeckoMediaPluginService
>
mps
=
do_GetService
(
"
mozilla
.
org
/
gecko
-
media
-
plugin
-
service
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mps
)
)
{
return
false
;
}
const
KeySystemConfig
*
implementation
=
nullptr
;
if
(
!
HaveGMPFor
(
mps
NS_ConvertUTF16toUTF8
(
aKeySystem
)
NS_LITERAL_CSTRING
(
GMP_API_DECRYPTOR
)
)
|
|
!
(
implementation
=
GetKeySystemConfig
(
aKeySystem
)
)
)
{
return
false
;
}
for
(
const
MediaKeySystemConfiguration
&
candidate
:
aConfigs
)
{
if
(
mozilla
:
:
dom
:
:
GetSupportedConfig
(
mps
*
implementation
candidate
aOutConfig
aDiagnostics
)
)
{
return
true
;
}
}
return
false
;
}
void
MediaKeySystemAccess
:
:
NotifyObservers
(
nsPIDOMWindowInner
*
aWindow
const
nsAString
&
aKeySystem
MediaKeySystemStatus
aStatus
)
{
RequestMediaKeySystemAccessNotification
data
;
data
.
mKeySystem
=
aKeySystem
;
data
.
mStatus
=
aStatus
;
nsAutoString
json
;
data
.
ToJSON
(
json
)
;
EME_LOG
(
"
MediaKeySystemAccess
:
:
NotifyObservers
(
)
%
s
"
NS_ConvertUTF16toUTF8
(
json
)
.
get
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
aWindow
"
mediakeys
-
request
"
json
.
get
(
)
)
;
}
}
}
}
