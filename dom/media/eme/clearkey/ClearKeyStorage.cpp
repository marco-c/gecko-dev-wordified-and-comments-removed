#
include
"
ClearKeyStorage
.
h
"
#
include
<
assert
.
h
>
#
include
<
stddef
.
h
>
#
include
<
vector
>
#
include
"
ClearKeyUtils
.
h
"
#
include
"
content_decryption_module
.
h
"
using
namespace
cdm
;
using
std
:
:
function
;
using
std
:
:
string
;
using
std
:
:
vector
;
class
WriteRecordClient
:
public
FileIOClient
{
public
:
static
void
Write
(
Host_11
*
aHost
string
&
aRecordName
const
vector
<
uint8_t
>
&
aData
function
<
void
(
)
>
&
&
aOnSuccess
function
<
void
(
)
>
&
&
aOnFailure
)
{
WriteRecordClient
*
client
=
new
WriteRecordClient
(
aData
std
:
:
move
(
aOnSuccess
)
std
:
:
move
(
aOnFailure
)
)
;
client
-
>
Do
(
aRecordName
aHost
)
;
}
void
OnOpenComplete
(
Status
aStatus
)
override
{
if
(
aStatus
!
=
Status
:
:
kSuccess
)
{
Done
(
aStatus
)
;
}
else
if
(
mFileIO
)
{
mFileIO
-
>
Write
(
mData
.
data
(
)
mData
.
size
(
)
)
;
}
}
void
OnReadComplete
(
Status
aStatus
const
uint8_t
*
aData
uint32_t
aDataSize
)
override
{
assert
(
false
)
;
}
void
OnWriteComplete
(
Status
aStatus
)
override
{
Done
(
aStatus
)
;
}
private
:
explicit
WriteRecordClient
(
const
vector
<
uint8_t
>
&
aData
function
<
void
(
)
>
&
&
aOnSuccess
function
<
void
(
)
>
&
&
aOnFailure
)
:
mFileIO
(
nullptr
)
mOnSuccess
(
std
:
:
move
(
aOnSuccess
)
)
mOnFailure
(
std
:
:
move
(
aOnFailure
)
)
mData
(
aData
)
{
}
void
Do
(
const
string
&
aName
Host_11
*
aHost
)
{
mFileIO
=
aHost
-
>
CreateFileIO
(
this
)
;
mFileIO
-
>
Open
(
aName
.
c_str
(
)
aName
.
size
(
)
)
;
}
void
Done
(
cdm
:
:
FileIOClient
:
:
Status
aStatus
)
{
if
(
mFileIO
)
{
mFileIO
-
>
Close
(
)
;
}
if
(
IO_SUCCEEDED
(
aStatus
)
)
{
mOnSuccess
(
)
;
}
else
{
mOnFailure
(
)
;
}
delete
this
;
}
FileIO
*
mFileIO
=
nullptr
;
function
<
void
(
)
>
mOnSuccess
;
function
<
void
(
)
>
mOnFailure
;
const
vector
<
uint8_t
>
mData
;
}
;
void
WriteData
(
Host_11
*
aHost
string
&
aRecordName
const
vector
<
uint8_t
>
&
aData
function
<
void
(
)
>
&
&
aOnSuccess
function
<
void
(
)
>
&
&
aOnFailure
)
{
WriteRecordClient
:
:
Write
(
aHost
aRecordName
aData
std
:
:
move
(
aOnSuccess
)
std
:
:
move
(
aOnFailure
)
)
;
}
class
ReadRecordClient
:
public
FileIOClient
{
public
:
static
void
Read
(
Host_11
*
aHost
string
&
aRecordName
function
<
void
(
const
uint8_t
*
uint32_t
)
>
&
&
aOnSuccess
function
<
void
(
)
>
&
&
aOnFailure
)
{
(
new
ReadRecordClient
(
std
:
:
move
(
aOnSuccess
)
std
:
:
move
(
aOnFailure
)
)
)
-
>
Do
(
aRecordName
aHost
)
;
}
void
OnOpenComplete
(
Status
aStatus
)
override
{
auto
err
=
aStatus
;
if
(
aStatus
!
=
Status
:
:
kSuccess
)
{
Done
(
err
nullptr
0
)
;
}
else
{
mFileIO
-
>
Read
(
)
;
}
}
void
OnReadComplete
(
Status
aStatus
const
uint8_t
*
aData
uint32_t
aDataSize
)
override
{
Done
(
aStatus
aData
aDataSize
)
;
}
void
OnWriteComplete
(
Status
aStatus
)
override
{
assert
(
false
)
;
}
private
:
explicit
ReadRecordClient
(
function
<
void
(
const
uint8_t
*
uint32_t
)
>
&
&
aOnSuccess
function
<
void
(
)
>
&
&
aOnFailure
)
:
mFileIO
(
nullptr
)
mOnSuccess
(
std
:
:
move
(
aOnSuccess
)
)
mOnFailure
(
std
:
:
move
(
aOnFailure
)
)
{
}
void
Do
(
const
string
&
aName
Host_11
*
aHost
)
{
mFileIO
=
aHost
-
>
CreateFileIO
(
this
)
;
mFileIO
-
>
Open
(
aName
.
c_str
(
)
aName
.
size
(
)
)
;
}
void
Done
(
cdm
:
:
FileIOClient
:
:
Status
aStatus
const
uint8_t
*
aData
uint32_t
aDataSize
)
{
if
(
mFileIO
)
{
mFileIO
-
>
Close
(
)
;
}
if
(
IO_SUCCEEDED
(
aStatus
)
)
{
mOnSuccess
(
aData
aDataSize
)
;
}
else
{
mOnFailure
(
)
;
}
delete
this
;
}
FileIO
*
mFileIO
=
nullptr
;
function
<
void
(
const
uint8_t
*
uint32_t
)
>
mOnSuccess
;
function
<
void
(
)
>
mOnFailure
;
}
;
void
ReadData
(
Host_11
*
aHost
string
&
aRecordName
function
<
void
(
const
uint8_t
*
uint32_t
)
>
&
&
aOnSuccess
function
<
void
(
)
>
&
&
aOnFailure
)
{
ReadRecordClient
:
:
Read
(
aHost
aRecordName
std
:
:
move
(
aOnSuccess
)
std
:
:
move
(
aOnFailure
)
)
;
}
