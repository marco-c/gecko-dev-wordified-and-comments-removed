#
include
"
ClearKeyPersistence
.
h
"
#
include
<
assert
.
h
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
<
sstream
>
#
include
"
ClearKeySessionManager
.
h
"
#
include
"
ClearKeyStorage
.
h
"
#
include
"
ClearKeyUtils
.
h
"
#
include
"
RefCounted
.
h
"
using
namespace
cdm
;
using
std
:
:
function
;
using
std
:
:
string
;
using
std
:
:
stringstream
;
using
std
:
:
vector
;
void
ClearKeyPersistence
:
:
ReadAllRecordsFromIndex
(
function
<
void
(
)
>
&
&
aOnComplete
)
{
mPersistentSessionIds
.
clear
(
)
;
RefPtr
<
ClearKeyPersistence
>
self
(
this
)
;
function
<
void
(
const
uint8_t
*
uint32_t
)
>
onIndexSuccess
=
[
self
aOnComplete
]
(
const
uint8_t
*
data
uint32_t
size
)
{
CK_LOGD
(
"
ClearKeyPersistence
:
Loaded
index
file
!
"
)
;
const
char
*
charData
=
(
const
char
*
)
data
;
stringstream
ss
(
string
(
charData
charData
+
size
)
)
;
string
name
;
while
(
getline
(
ss
name
)
)
{
if
(
ClearKeyUtils
:
:
IsValidSessionId
(
name
.
data
(
)
name
.
size
(
)
)
)
{
self
-
>
mPersistentSessionIds
.
insert
(
atoi
(
name
.
c_str
(
)
)
)
;
}
}
self
-
>
mPersistentKeyState
=
PersistentKeyState
:
:
LOADED
;
aOnComplete
(
)
;
}
;
function
<
void
(
)
>
onIndexFailed
=
[
self
aOnComplete
]
(
)
{
CK_LOGD
(
"
ClearKeyPersistence
:
Failed
to
load
index
file
(
it
might
not
exist
"
)
;
self
-
>
mPersistentKeyState
=
PersistentKeyState
:
:
LOADED
;
aOnComplete
(
)
;
}
;
string
filename
=
"
index
"
;
ReadData
(
mHost
filename
std
:
:
move
(
onIndexSuccess
)
std
:
:
move
(
onIndexFailed
)
)
;
}
void
ClearKeyPersistence
:
:
WriteIndex
(
)
{
function
<
void
(
)
>
onIndexSuccess
=
[
]
(
)
{
CK_LOGD
(
"
ClearKeyPersistence
:
Wrote
index
file
"
)
;
}
;
function
<
void
(
)
>
onIndexFail
=
[
]
(
)
{
CK_LOGD
(
"
ClearKeyPersistence
:
Failed
to
write
index
file
(
this
is
bad
)
"
)
;
}
;
stringstream
ss
;
for
(
const
uint32_t
&
sessionId
:
mPersistentSessionIds
)
{
ss
<
<
sessionId
;
ss
<
<
'
\
n
'
;
}
string
dataString
=
ss
.
str
(
)
;
uint8_t
*
dataArray
=
(
uint8_t
*
)
dataString
.
data
(
)
;
vector
<
uint8_t
>
data
(
dataArray
dataArray
+
dataString
.
size
(
)
)
;
string
filename
=
"
index
"
;
WriteData
(
mHost
filename
data
std
:
:
move
(
onIndexSuccess
)
std
:
:
move
(
onIndexFail
)
)
;
}
ClearKeyPersistence
:
:
ClearKeyPersistence
(
Host_11
*
aHost
)
:
mHost
(
aHost
)
{
}
void
ClearKeyPersistence
:
:
EnsureInitialized
(
bool
aPersistentStateAllowed
function
<
void
(
)
>
&
&
aOnInitialized
)
{
if
(
aPersistentStateAllowed
&
&
mPersistentKeyState
=
=
PersistentKeyState
:
:
UNINITIALIZED
)
{
mPersistentKeyState
=
LOADING
;
ReadAllRecordsFromIndex
(
std
:
:
move
(
aOnInitialized
)
)
;
}
else
{
mPersistentKeyState
=
PersistentKeyState
:
:
LOADED
;
aOnInitialized
(
)
;
}
}
bool
ClearKeyPersistence
:
:
IsLoaded
(
)
const
{
return
mPersistentKeyState
=
=
PersistentKeyState
:
:
LOADED
;
}
string
ClearKeyPersistence
:
:
GetNewSessionId
(
SessionType
aSessionType
)
{
static
uint32_t
sNextSessionId
=
1
;
while
(
Contains
(
mPersistentSessionIds
sNextSessionId
)
)
{
sNextSessionId
+
+
;
}
string
sessionId
;
stringstream
ss
;
ss
<
<
sNextSessionId
;
ss
>
>
sessionId
;
if
(
aSessionType
=
=
SessionType
:
:
kPersistentLicense
)
{
mPersistentSessionIds
.
insert
(
sNextSessionId
)
;
WriteIndex
(
)
;
}
sNextSessionId
+
+
;
return
sessionId
;
}
bool
ClearKeyPersistence
:
:
IsPersistentSessionId
(
const
string
&
aSessionId
)
{
return
Contains
(
mPersistentSessionIds
atoi
(
aSessionId
.
c_str
(
)
)
)
;
}
void
ClearKeyPersistence
:
:
PersistentSessionRemoved
(
string
&
aSessionId
)
{
mPersistentSessionIds
.
erase
(
atoi
(
aSessionId
.
c_str
(
)
)
)
;
WriteIndex
(
)
;
}
