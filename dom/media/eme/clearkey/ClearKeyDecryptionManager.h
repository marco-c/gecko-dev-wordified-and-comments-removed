#
ifndef
__ClearKeyDecryptionManager_h__
#
define
__ClearKeyDecryptionManager_h__
#
include
<
stddef
.
h
>
#
include
<
map
>
#
include
"
ClearKeyUtils
.
h
"
#
include
"
RefCounted
.
h
"
#
include
"
content_decryption_module
.
h
"
class
ClearKeyDecryptor
;
class
CryptoMetaData
{
public
:
CryptoMetaData
(
)
=
default
;
explicit
CryptoMetaData
(
const
cdm
:
:
InputBuffer_2
*
aInputBuffer
)
{
Init
(
aInputBuffer
)
;
}
void
Init
(
const
cdm
:
:
InputBuffer_2
*
aInputBuffer
)
{
if
(
!
aInputBuffer
)
{
assert
(
!
IsValid
(
)
)
;
return
;
}
mEncryptionScheme
=
aInputBuffer
-
>
encryption_scheme
;
Assign
(
mKeyId
aInputBuffer
-
>
key_id
aInputBuffer
-
>
key_id_size
)
;
Assign
(
mIV
aInputBuffer
-
>
iv
aInputBuffer
-
>
iv_size
)
;
mCryptByteBlock
=
aInputBuffer
-
>
pattern
.
crypt_byte_block
;
mSkipByteBlock
=
aInputBuffer
-
>
pattern
.
skip_byte_block
;
for
(
uint32_t
i
=
0
;
i
<
aInputBuffer
-
>
num_subsamples
;
+
+
i
)
{
const
cdm
:
:
SubsampleEntry
&
subsample
=
aInputBuffer
-
>
subsamples
[
i
]
;
mClearBytes
.
push_back
(
subsample
.
clear_bytes
)
;
mCipherBytes
.
push_back
(
subsample
.
cipher_bytes
)
;
}
}
bool
IsValid
(
)
const
{
return
!
mKeyId
.
empty
(
)
&
&
!
mIV
.
empty
(
)
&
&
!
mCipherBytes
.
empty
(
)
&
&
!
mClearBytes
.
empty
(
)
;
}
size_t
NumSubsamples
(
)
const
{
assert
(
mClearBytes
.
size
(
)
=
=
mCipherBytes
.
size
(
)
)
;
return
mClearBytes
.
size
(
)
;
}
cdm
:
:
EncryptionScheme
mEncryptionScheme
;
std
:
:
vector
<
uint8_t
>
mKeyId
;
std
:
:
vector
<
uint8_t
>
mIV
;
uint32_t
mCryptByteBlock
;
uint32_t
mSkipByteBlock
;
std
:
:
vector
<
uint32_t
>
mClearBytes
;
std
:
:
vector
<
uint32_t
>
mCipherBytes
;
}
;
class
ClearKeyDecryptionManager
:
public
RefCounted
{
private
:
ClearKeyDecryptionManager
(
)
;
~
ClearKeyDecryptionManager
(
)
;
static
ClearKeyDecryptionManager
*
sInstance
;
public
:
static
ClearKeyDecryptionManager
*
Get
(
)
;
bool
HasSeenKeyId
(
const
KeyId
&
aKeyId
)
const
;
bool
HasKeyForKeyId
(
const
KeyId
&
aKeyId
)
const
;
const
Key
&
GetDecryptionKey
(
const
KeyId
&
aKeyId
)
;
void
InitKey
(
KeyId
aKeyId
Key
aKey
)
;
void
ExpectKeyId
(
KeyId
aKeyId
)
;
void
ReleaseKeyId
(
KeyId
aKeyId
)
;
cdm
:
:
Status
Decrypt
(
uint8_t
*
aBuffer
uint32_t
aBufferSize
const
CryptoMetaData
&
aMetadata
)
;
cdm
:
:
Status
Decrypt
(
std
:
:
vector
<
uint8_t
>
&
aBuffer
const
CryptoMetaData
&
aMetadata
)
;
private
:
bool
IsExpectingKeyForKeyId
(
const
KeyId
&
aKeyId
)
const
;
std
:
:
map
<
KeyId
ClearKeyDecryptor
*
>
mDecryptors
;
}
;
#
endif
