#
include
"
MediaKeySystemAccessManager
.
h
"
#
include
"
DecoderDoctorDiagnostics
.
h
"
#
include
"
mozilla
/
EMEUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
mozilla
/
DetailedPromise
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
endif
#
ifdef
XP_MACOSX
#
include
"
nsCocoaFeatures
.
h
"
#
endif
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
MediaKeySystemAccessManager
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
MediaKeySystemAccessManager
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
MediaKeySystemAccessManager
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
MediaKeySystemAccessManager
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
MediaKeySystemAccessManager
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mWindow
)
for
(
size_t
i
=
0
;
i
<
tmp
-
>
mRequests
.
Length
(
)
;
i
+
+
)
{
tmp
-
>
mRequests
[
i
]
.
RejectPromise
(
NS_LITERAL_CSTRING
(
"
Promise
still
outstanding
at
MediaKeySystemAccessManager
GC
"
)
)
;
tmp
-
>
mRequests
[
i
]
.
CancelTimer
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mRequests
[
i
]
.
mPromise
)
}
tmp
-
>
mRequests
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
MediaKeySystemAccessManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mWindow
)
for
(
size_t
i
=
0
;
i
<
tmp
-
>
mRequests
.
Length
(
)
;
i
+
+
)
{
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRequests
[
i
]
.
mPromise
)
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
MediaKeySystemAccessManager
:
:
MediaKeySystemAccessManager
(
nsPIDOMWindowInner
*
aWindow
)
:
mWindow
(
aWindow
)
mAddedObservers
(
false
)
{
}
MediaKeySystemAccessManager
:
:
~
MediaKeySystemAccessManager
(
)
{
Shutdown
(
)
;
}
void
MediaKeySystemAccessManager
:
:
Request
(
DetailedPromise
*
aPromise
const
nsAString
&
aKeySystem
const
Sequence
<
MediaKeySystemConfiguration
>
&
aConfigs
)
{
Request
(
aPromise
aKeySystem
aConfigs
RequestType
:
:
Initial
)
;
}
void
MediaKeySystemAccessManager
:
:
Request
(
DetailedPromise
*
aPromise
const
nsAString
&
aKeySystem
const
Sequence
<
MediaKeySystemConfiguration
>
&
aConfigs
RequestType
aType
)
{
EME_LOG
(
"
MediaKeySystemAccessManager
:
:
Request
%
s
"
NS_ConvertUTF16toUTF8
(
aKeySystem
)
.
get
(
)
)
;
#
ifdef
XP_WIN
RefPtr
<
BrowserChild
>
browser
(
BrowserChild
:
:
GetFrom
(
mWindow
)
)
;
RefPtr
<
MediaKeySystemAccessManager
>
self
(
this
)
;
nsString
keySystem
(
aKeySystem
)
;
RefPtr
<
DetailedPromise
>
promise
(
aPromise
)
;
Sequence
<
MediaKeySystemConfiguration
>
configs
(
aConfigs
)
;
browser
-
>
DoesWindowSupportProtectedMedia
(
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
self
promise
keySystem
configs
aType
]
(
bool
isSupported
)
{
self
-
>
RequestCallback
(
isSupported
promise
keySystem
configs
aType
)
;
}
[
self
promise
keySystem
configs
aType
]
(
const
mozilla
:
:
ipc
:
:
ResponseRejectReason
reason
)
{
EME_LOG
(
"
Failed
to
make
IPC
call
to
IsWindowSupportingProtectedMedia
:
"
"
reason
=
%
d
"
static_cast
<
int
>
(
reason
)
)
;
self
-
>
RequestCallback
(
false
promise
keySystem
configs
aType
)
;
}
)
;
#
else
RequestCallback
(
true
aPromise
aKeySystem
aConfigs
aType
)
;
#
endif
}
void
MediaKeySystemAccessManager
:
:
RequestCallback
(
bool
aIsSupportedInWindow
DetailedPromise
*
aPromise
const
nsAString
&
aKeySystem
const
Sequence
<
MediaKeySystemConfiguration
>
&
aConfigs
RequestType
aType
)
{
if
(
!
aIsSupportedInWindow
)
{
aPromise
-
>
MaybeReject
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
NS_LITERAL_CSTRING
(
"
EME
is
not
supported
in
this
window
"
)
)
;
return
;
}
if
(
aKeySystem
.
IsEmpty
(
)
)
{
aPromise
-
>
MaybeRejectWithTypeError
(
u
"
Key
system
string
is
empty
"
)
;
return
;
}
if
(
aConfigs
.
IsEmpty
(
)
)
{
aPromise
-
>
MaybeRejectWithTypeError
(
u
"
Candidate
MediaKeySystemConfigs
is
empty
"
)
;
return
;
}
DecoderDoctorDiagnostics
diagnostics
;
if
(
!
IsWidevineKeySystem
(
aKeySystem
)
&
&
!
IsClearkeyKeySystem
(
aKeySystem
)
)
{
aPromise
-
>
MaybeReject
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
NS_LITERAL_CSTRING
(
"
Key
system
is
unsupported
"
)
)
;
diagnostics
.
StoreMediaKeySystemAccess
(
mWindow
-
>
GetExtantDoc
(
)
aKeySystem
false
__func__
)
;
return
;
}
if
(
!
StaticPrefs
:
:
media_eme_enabled
(
)
&
&
!
IsClearkeyKeySystem
(
aKeySystem
)
)
{
MediaKeySystemAccess
:
:
NotifyObservers
(
mWindow
aKeySystem
MediaKeySystemStatus
:
:
Api_disabled
)
;
aPromise
-
>
MaybeReject
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
NS_LITERAL_CSTRING
(
"
EME
has
been
preffed
off
"
)
)
;
diagnostics
.
StoreMediaKeySystemAccess
(
mWindow
-
>
GetExtantDoc
(
)
aKeySystem
false
__func__
)
;
return
;
}
nsAutoCString
message
;
MediaKeySystemStatus
status
=
MediaKeySystemAccess
:
:
GetKeySystemStatus
(
aKeySystem
message
)
;
nsPrintfCString
msg
(
"
MediaKeySystemAccess
:
:
GetKeySystemStatus
(
%
s
)
"
"
result
=
%
s
msg
=
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
aKeySystem
)
.
get
(
)
MediaKeySystemStatusValues
:
:
strings
[
(
size_t
)
status
]
.
value
message
.
get
(
)
)
;
LogToBrowserConsole
(
NS_ConvertUTF8toUTF16
(
msg
)
)
;
if
(
status
=
=
MediaKeySystemStatus
:
:
Cdm_not_installed
&
&
IsWidevineKeySystem
(
aKeySystem
)
)
{
if
(
aType
=
=
RequestType
:
:
Initial
&
&
AwaitInstall
(
aPromise
aKeySystem
aConfigs
)
)
{
MediaKeySystemAccess
:
:
NotifyObservers
(
mWindow
aKeySystem
status
)
;
}
else
{
aPromise
-
>
MaybeReject
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
NS_LITERAL_CSTRING
(
"
Gave
up
while
waiting
for
a
CDM
update
"
)
)
;
}
diagnostics
.
StoreMediaKeySystemAccess
(
mWindow
-
>
GetExtantDoc
(
)
aKeySystem
false
__func__
)
;
return
;
}
if
(
status
!
=
MediaKeySystemStatus
:
:
Available
)
{
MediaKeySystemAccess
:
:
NotifyObservers
(
mWindow
aKeySystem
status
)
;
aPromise
-
>
MaybeReject
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
message
)
;
return
;
}
nsCOMPtr
<
Document
>
doc
=
mWindow
-
>
GetExtantDoc
(
)
;
nsDataHashtable
<
nsCharPtrHashKey
bool
>
warnings
;
std
:
:
function
<
void
(
const
char
*
)
>
deprecationWarningLogFn
=
[
&
]
(
const
char
*
aMsgName
)
{
EME_LOG
(
"
Logging
deprecation
warning
'
%
s
'
to
WebConsole
.
"
aMsgName
)
;
warnings
.
Put
(
aMsgName
true
)
;
AutoTArray
<
nsString
1
>
params
;
nsString
&
uri
=
*
params
.
AppendElement
(
)
;
if
(
doc
)
{
Unused
<
<
doc
-
>
GetDocumentURI
(
uri
)
;
}
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Media
"
)
doc
nsContentUtils
:
:
eDOM_PROPERTIES
aMsgName
params
)
;
}
;
bool
isPrivateBrowsing
=
mWindow
-
>
GetExtantDoc
(
)
&
&
mWindow
-
>
GetExtantDoc
(
)
-
>
NodePrincipal
(
)
-
>
GetPrivateBrowsingId
(
)
>
0
;
MediaKeySystemConfiguration
config
;
if
(
MediaKeySystemAccess
:
:
GetSupportedConfig
(
aKeySystem
aConfigs
config
&
diagnostics
isPrivateBrowsing
deprecationWarningLogFn
)
)
{
RefPtr
<
MediaKeySystemAccess
>
access
(
new
MediaKeySystemAccess
(
mWindow
aKeySystem
config
)
)
;
aPromise
-
>
MaybeResolve
(
access
)
;
diagnostics
.
StoreMediaKeySystemAccess
(
mWindow
-
>
GetExtantDoc
(
)
aKeySystem
true
__func__
)
;
return
;
}
aPromise
-
>
MaybeReject
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
NS_LITERAL_CSTRING
(
"
Key
system
configuration
is
not
supported
"
)
)
;
diagnostics
.
StoreMediaKeySystemAccess
(
mWindow
-
>
GetExtantDoc
(
)
aKeySystem
false
__func__
)
;
}
MediaKeySystemAccessManager
:
:
PendingRequest
:
:
PendingRequest
(
DetailedPromise
*
aPromise
const
nsAString
&
aKeySystem
const
Sequence
<
MediaKeySystemConfiguration
>
&
aConfigs
nsITimer
*
aTimer
)
:
mPromise
(
aPromise
)
mKeySystem
(
aKeySystem
)
mConfigs
(
aConfigs
)
mTimer
(
aTimer
)
{
MOZ_COUNT_CTOR
(
MediaKeySystemAccessManager
:
:
PendingRequest
)
;
}
MediaKeySystemAccessManager
:
:
PendingRequest
:
:
PendingRequest
(
const
PendingRequest
&
aOther
)
:
mPromise
(
aOther
.
mPromise
)
mKeySystem
(
aOther
.
mKeySystem
)
mConfigs
(
aOther
.
mConfigs
)
mTimer
(
aOther
.
mTimer
)
{
MOZ_COUNT_CTOR
(
MediaKeySystemAccessManager
:
:
PendingRequest
)
;
}
MediaKeySystemAccessManager
:
:
PendingRequest
:
:
~
PendingRequest
(
)
{
MOZ_COUNT_DTOR
(
MediaKeySystemAccessManager
:
:
PendingRequest
)
;
}
void
MediaKeySystemAccessManager
:
:
PendingRequest
:
:
CancelTimer
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
}
void
MediaKeySystemAccessManager
:
:
PendingRequest
:
:
RejectPromise
(
const
nsCString
&
aReason
)
{
if
(
mPromise
)
{
mPromise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_ACCESS_ERR
aReason
)
;
}
}
bool
MediaKeySystemAccessManager
:
:
AwaitInstall
(
DetailedPromise
*
aPromise
const
nsAString
&
aKeySystem
const
Sequence
<
MediaKeySystemConfiguration
>
&
aConfigs
)
{
EME_LOG
(
"
MediaKeySystemAccessManager
:
:
AwaitInstall
%
s
"
NS_ConvertUTF16toUTF8
(
aKeySystem
)
.
get
(
)
)
;
if
(
!
EnsureObserversAdded
(
)
)
{
NS_WARNING
(
"
Failed
to
add
pref
observer
"
)
;
return
false
;
}
nsCOMPtr
<
nsITimer
>
timer
;
NS_NewTimerWithObserver
(
getter_AddRefs
(
timer
)
this
60
*
1000
nsITimer
:
:
TYPE_ONE_SHOT
)
;
if
(
!
timer
)
{
NS_WARNING
(
"
Failed
to
create
timer
to
await
CDM
install
.
"
)
;
return
false
;
}
mRequests
.
AppendElement
(
PendingRequest
(
aPromise
aKeySystem
aConfigs
timer
)
)
;
return
true
;
}
void
MediaKeySystemAccessManager
:
:
RetryRequest
(
PendingRequest
&
aRequest
)
{
aRequest
.
CancelTimer
(
)
;
Request
(
aRequest
.
mPromise
aRequest
.
mKeySystem
aRequest
.
mConfigs
RequestType
:
:
Subsequent
)
;
}
nsresult
MediaKeySystemAccessManager
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
EME_LOG
(
"
MediaKeySystemAccessManager
:
:
Observe
%
s
"
aTopic
)
;
if
(
!
strcmp
(
aTopic
"
gmp
-
changed
"
)
)
{
nsTArray
<
PendingRequest
>
requests
;
for
(
size_t
i
=
mRequests
.
Length
(
)
;
i
-
-
>
0
;
)
{
PendingRequest
&
request
=
mRequests
[
i
]
;
nsAutoCString
message
;
MediaKeySystemStatus
status
=
MediaKeySystemAccess
:
:
GetKeySystemStatus
(
request
.
mKeySystem
message
)
;
if
(
status
=
=
MediaKeySystemStatus
:
:
Cdm_not_installed
)
{
continue
;
}
requests
.
AppendElement
(
std
:
:
move
(
request
)
)
;
mRequests
.
RemoveElementAt
(
i
)
;
}
for
(
PendingRequest
&
request
:
requests
)
{
RetryRequest
(
request
)
;
}
}
else
if
(
!
strcmp
(
aTopic
"
timer
-
callback
"
)
)
{
nsCOMPtr
<
nsITimer
>
timer
(
do_QueryInterface
(
aSubject
)
)
;
for
(
size_t
i
=
0
;
i
<
mRequests
.
Length
(
)
;
i
+
+
)
{
if
(
mRequests
[
i
]
.
mTimer
=
=
timer
)
{
EME_LOG
(
"
MediaKeySystemAccessManager
:
:
AwaitInstall
resuming
request
"
)
;
PendingRequest
request
=
mRequests
[
i
]
;
mRequests
.
RemoveElementAt
(
i
)
;
RetryRequest
(
request
)
;
break
;
}
}
}
return
NS_OK
;
}
bool
MediaKeySystemAccessManager
:
:
EnsureObserversAdded
(
)
{
if
(
mAddedObservers
)
{
return
true
;
}
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obsService
)
)
{
return
false
;
}
mAddedObservers
=
NS_SUCCEEDED
(
obsService
-
>
AddObserver
(
this
"
gmp
-
changed
"
false
)
)
;
return
mAddedObservers
;
}
void
MediaKeySystemAccessManager
:
:
Shutdown
(
)
{
EME_LOG
(
"
MediaKeySystemAccessManager
:
:
Shutdown
"
)
;
nsTArray
<
PendingRequest
>
requests
(
std
:
:
move
(
mRequests
)
)
;
for
(
PendingRequest
&
request
:
requests
)
{
request
.
CancelTimer
(
)
;
request
.
RejectPromise
(
NS_LITERAL_CSTRING
(
"
Promise
still
outstanding
at
MediaKeySystemAccessManager
shutdown
"
)
)
;
}
if
(
mAddedObservers
)
{
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsService
)
{
obsService
-
>
RemoveObserver
(
this
"
gmp
-
changed
"
)
;
mAddedObservers
=
false
;
}
}
}
}
}
