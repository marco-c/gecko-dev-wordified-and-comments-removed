#
if
!
defined
(
AudioConverter_h
)
#
define
AudioConverter_h
#
include
"
MediaInfo
.
h
"
namespace
mozilla
{
template
<
AudioConfig
:
:
SampleFormat
T
>
struct
AudioDataBufferTypeChooser
;
template
<
>
struct
AudioDataBufferTypeChooser
<
AudioConfig
:
:
FORMAT_U8
>
{
typedef
uint8_t
Type
;
}
;
template
<
>
struct
AudioDataBufferTypeChooser
<
AudioConfig
:
:
FORMAT_S16
>
{
typedef
int16_t
Type
;
}
;
template
<
>
struct
AudioDataBufferTypeChooser
<
AudioConfig
:
:
FORMAT_S24LSB
>
{
typedef
int32_t
Type
;
}
;
template
<
>
struct
AudioDataBufferTypeChooser
<
AudioConfig
:
:
FORMAT_S24
>
{
typedef
int32_t
Type
;
}
;
template
<
>
struct
AudioDataBufferTypeChooser
<
AudioConfig
:
:
FORMAT_S32
>
{
typedef
int32_t
Type
;
}
;
template
<
>
struct
AudioDataBufferTypeChooser
<
AudioConfig
:
:
FORMAT_FLT
>
{
typedef
float
Type
;
}
;
template
<
AudioConfig
:
:
SampleFormat
Format
typename
Value
=
typename
AudioDataBufferTypeChooser
<
Format
>
:
:
Type
>
class
AudioDataBuffer
{
public
:
AudioDataBuffer
(
)
{
}
AudioDataBuffer
(
Value
*
aBuffer
size_t
aLength
)
:
mBuffer
(
aBuffer
aLength
)
{
}
explicit
AudioDataBuffer
(
const
AudioDataBuffer
&
aOther
)
:
mBuffer
(
aOther
.
mBuffer
)
{
}
AudioDataBuffer
(
AudioDataBuffer
&
&
aOther
)
:
mBuffer
(
Move
(
aOther
.
mBuffer
)
)
{
}
template
<
AudioConfig
:
:
SampleFormat
OtherFormat
typename
OtherValue
>
explicit
AudioDataBuffer
(
const
AudioDataBuffer
<
OtherFormat
OtherValue
>
&
other
)
{
MOZ_CRASH
(
"
Conversion
not
implemented
yet
"
)
;
}
explicit
AudioDataBuffer
(
const
AlignedByteBuffer
&
aBuffer
)
:
mBuffer
(
aBuffer
)
{
static_assert
(
Format
=
=
AudioConfig
:
:
FORMAT_U8
"
Conversion
not
implemented
yet
"
)
;
}
explicit
AudioDataBuffer
(
const
AlignedShortBuffer
&
aBuffer
)
:
mBuffer
(
aBuffer
)
{
static_assert
(
Format
=
=
AudioConfig
:
:
FORMAT_S16
"
Conversion
not
implemented
yet
"
)
;
}
explicit
AudioDataBuffer
(
const
AlignedFloatBuffer
&
aBuffer
)
:
mBuffer
(
aBuffer
)
{
static_assert
(
Format
=
=
AudioConfig
:
:
FORMAT_FLT
"
Conversion
not
implemented
yet
"
)
;
}
explicit
AudioDataBuffer
(
AlignedByteBuffer
&
&
aBuffer
)
:
mBuffer
(
Move
(
aBuffer
)
)
{
static_assert
(
Format
=
=
AudioConfig
:
:
FORMAT_U8
"
Conversion
not
implemented
yet
"
)
;
}
explicit
AudioDataBuffer
(
AlignedShortBuffer
&
&
aBuffer
)
:
mBuffer
(
Move
(
aBuffer
)
)
{
static_assert
(
Format
=
=
AudioConfig
:
:
FORMAT_S16
"
Conversion
not
implemented
yet
"
)
;
}
explicit
AudioDataBuffer
(
const
AlignedFloatBuffer
&
&
aBuffer
)
:
mBuffer
(
Move
(
aBuffer
)
)
{
static_assert
(
Format
=
=
AudioConfig
:
:
FORMAT_FLT
"
Conversion
not
implemented
yet
"
)
;
}
Value
*
Data
(
)
const
{
return
mBuffer
.
Data
(
)
;
}
size_t
Length
(
)
const
{
return
mBuffer
.
Length
(
)
;
}
size_t
Size
(
)
const
{
return
mBuffer
.
Size
(
)
;
}
AlignedBuffer
<
Value
>
Forget
(
)
{
return
Move
(
mBuffer
)
;
}
private
:
AlignedBuffer
<
Value
>
mBuffer
;
}
;
typedef
AudioDataBuffer
<
AudioConfig
:
:
FORMAT_DEFAULT
>
AudioSampleBuffer
;
class
AudioConverter
{
public
:
AudioConverter
(
const
AudioConfig
&
aIn
const
AudioConfig
&
aOut
)
;
template
<
AudioConfig
:
:
SampleFormat
Type
typename
Value
>
size_t
Process
(
AudioDataBuffer
<
Type
Value
>
&
aBuffer
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mIn
.
Format
(
)
=
=
mOut
.
Format
(
)
&
&
mIn
.
Format
(
)
=
=
Type
)
;
return
Process
(
aBuffer
.
Data
(
)
aBuffer
.
Data
(
)
aBuffer
.
Size
(
)
)
;
}
bool
CanWorkInPlace
(
)
const
;
bool
CanReorderAudio
(
)
const
{
return
mIn
.
Layout
(
)
.
MappingTable
(
mOut
.
Layout
(
)
)
;
}
private
:
const
AudioConfig
mIn
;
const
AudioConfig
mOut
;
uint8_t
mChannelOrderMap
[
MAX_AUDIO_CHANNELS
]
;
size_t
Process
(
void
*
aOut
const
void
*
aIn
size_t
aBytes
)
;
void
ReOrderInterleavedChannels
(
void
*
aOut
const
void
*
aIn
size_t
aDataSize
)
const
;
}
;
}
#
endif
