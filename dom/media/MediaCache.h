#
ifndef
MediaCache_h_
#
define
MediaCache_h_
#
include
"
DecoderDoctorLogger
.
h
"
#
include
"
Intervals
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
MediaChannelStatistics
.
h
"
class
nsIEventTarget
;
class
nsIPrincipal
;
namespace
mozilla
{
class
ChannelMediaResource
;
typedef
media
:
:
IntervalSet
<
int64_t
>
MediaByteRangeSet
;
class
MediaResource
;
class
ReentrantMonitorAutoEnter
;
class
MediaCache
;
DDLoggedTypeDeclName
(
MediaCacheStream
)
;
class
MediaCacheStream
:
public
DecoderDoctorLifeLogger
<
MediaCacheStream
>
{
using
AutoLock
=
ReentrantMonitorAutoEnter
;
public
:
static
const
int64_t
BLOCK_SIZE
=
32768
;
enum
ReadMode
{
MODE_METADATA
MODE_PLAYBACK
}
;
MediaCacheStream
(
ChannelMediaResource
*
aClient
bool
aIsPrivateBrowsing
)
;
~
MediaCacheStream
(
)
;
nsresult
Init
(
int64_t
aContentLength
)
;
void
InitAsClone
(
MediaCacheStream
*
aOriginal
)
;
nsIEventTarget
*
OwnerThread
(
)
const
;
void
Close
(
)
;
bool
IsClosed
(
AutoLock
&
)
const
{
return
mClosed
;
}
bool
IsAvailableForSharing
(
)
const
{
return
!
mIsPrivateBrowsing
;
}
void
NotifyDataStarted
(
uint32_t
aLoadID
int64_t
aOffset
bool
aSeekable
int64_t
aLength
)
;
void
NotifyDataReceived
(
uint32_t
aLoadID
uint32_t
aCount
const
uint8_t
*
aData
)
;
void
NotifyLoadID
(
uint32_t
aLoadID
)
;
void
NotifyDataEnded
(
uint32_t
aLoadID
nsresult
aStatus
bool
aReopenOnError
=
false
)
;
void
NotifyClientSuspended
(
bool
aSuspended
)
;
void
NotifyResume
(
)
;
void
Pin
(
)
;
void
Unpin
(
)
;
int64_t
GetLength
(
)
;
int64_t
GetResourceID
(
)
{
return
mResourceID
;
}
int64_t
GetCachedDataEnd
(
int64_t
aOffset
)
;
int64_t
GetNextCachedData
(
int64_t
aOffset
)
;
nsresult
GetCachedRanges
(
MediaByteRangeSet
&
aRanges
)
;
double
GetDownloadRate
(
bool
*
aIsReliable
)
;
nsresult
ReadFromCache
(
char
*
aBuffer
int64_t
aOffset
uint32_t
aCount
)
;
bool
IsDataCachedToEndOfStream
(
int64_t
aOffset
)
;
void
SetReadMode
(
ReadMode
aMode
)
;
void
SetPlaybackRate
(
uint32_t
aBytesPerSecond
)
;
bool
AreAllStreamsForResourceSuspended
(
AutoLock
&
)
;
nsresult
Read
(
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
;
nsresult
ReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
;
void
ThrottleReadahead
(
bool
bThrottle
)
;
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
nsCString
GetDebugInfo
(
)
;
private
:
friend
class
MediaCache
;
class
BlockList
{
public
:
BlockList
(
)
:
mFirstBlock
(
-
1
)
mCount
(
0
)
{
}
~
BlockList
(
)
{
NS_ASSERTION
(
mFirstBlock
=
=
-
1
&
&
mCount
=
=
0
"
Destroying
non
-
empty
block
list
"
)
;
}
void
AddFirstBlock
(
int32_t
aBlock
)
;
void
AddAfter
(
int32_t
aBlock
int32_t
aBefore
)
;
void
RemoveBlock
(
int32_t
aBlock
)
;
int32_t
GetFirstBlock
(
)
const
{
return
mFirstBlock
;
}
int32_t
GetLastBlock
(
)
const
;
int32_t
GetNextBlock
(
int32_t
aBlock
)
const
;
int32_t
GetPrevBlock
(
int32_t
aBlock
)
const
;
bool
IsEmpty
(
)
const
{
return
mFirstBlock
<
0
;
}
int32_t
GetCount
(
)
const
{
return
mCount
;
}
void
NotifyBlockSwapped
(
int32_t
aBlockIndex1
int32_t
aBlockIndex2
)
;
#
ifdef
DEBUG
void
Verify
(
)
;
#
else
void
Verify
(
)
{
}
#
endif
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
struct
Entry
:
public
nsUint32HashKey
{
explicit
Entry
(
KeyTypePointer
aKey
)
:
nsUint32HashKey
(
aKey
)
{
}
Entry
(
const
Entry
&
toCopy
)
:
nsUint32HashKey
(
&
toCopy
.
GetKey
(
)
)
mNextBlock
(
toCopy
.
mNextBlock
)
mPrevBlock
(
toCopy
.
mPrevBlock
)
{
}
int32_t
mNextBlock
;
int32_t
mPrevBlock
;
}
;
nsTHashtable
<
Entry
>
mEntries
;
int32_t
mFirstBlock
;
int32_t
mCount
;
}
;
uint32_t
ReadPartialBlock
(
AutoLock
&
int64_t
aOffset
Span
<
char
>
aBuffer
)
;
Result
<
uint32_t
nsresult
>
ReadBlockFromCache
(
AutoLock
&
int64_t
aOffset
Span
<
char
>
aBuffer
bool
aNoteBlockUsage
=
false
)
;
nsresult
Seek
(
AutoLock
&
int64_t
aOffset
)
;
int64_t
GetCachedDataEndInternal
(
AutoLock
&
int64_t
aOffset
)
;
int64_t
GetNextCachedDataInternal
(
AutoLock
&
int64_t
aOffset
)
;
void
FlushPartialBlockInternal
(
AutoLock
&
bool
aNotify
)
;
void
NotifyDataStartedInternal
(
uint32_t
aLoadID
int64_t
aOffset
bool
aSeekable
int64_t
aLength
)
;
void
NotifyDataEndedInternal
(
uint32_t
aLoadID
nsresult
aStatus
bool
aReopenOnError
)
;
void
UpdateDownloadStatistics
(
AutoLock
&
)
;
void
CloseInternal
(
AutoLock
&
)
;
void
InitAsCloneInternal
(
MediaCacheStream
*
aOriginal
)
;
RefPtr
<
MediaCache
>
mMediaCache
;
ChannelMediaResource
*
const
mClient
;
bool
mClosed
=
false
;
int64_t
mResourceID
=
0
;
bool
mIsTransportSeekable
;
bool
mCacheSuspended
;
bool
mChannelEnded
;
int64_t
mStreamLength
=
-
1
;
int64_t
mChannelOffset
=
0
;
int64_t
mStreamOffset
;
nsTArray
<
int32_t
>
mBlocks
;
BlockList
mReadaheadBlocks
;
BlockList
mMetadataBlocks
;
BlockList
mPlayedBlocks
;
uint32_t
mPlaybackBytesPerSecond
;
uint32_t
mPinCount
;
bool
mDidNotifyDataEnded
=
false
;
nsresult
mNotifyDataEndedStatus
;
ReadMode
mCurrentMode
=
MODE_METADATA
;
bool
mMetadataInPartialBlockBuffer
;
uint32_t
mLoadID
=
0
;
int64_t
mSeekTarget
=
-
1
;
bool
mThrottleReadahead
=
false
;
const
UniquePtr
<
uint8_t
[
]
>
mPartialBlockBuffer
=
MakeUnique
<
uint8_t
[
]
>
(
BLOCK_SIZE
)
;
const
bool
mIsPrivateBrowsing
;
bool
mClientSuspended
=
false
;
MediaChannelStatistics
mDownloadStatistics
;
}
;
}
#
endif
