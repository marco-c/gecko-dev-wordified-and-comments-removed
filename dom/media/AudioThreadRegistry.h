#
ifndef
AUDIOTHREADREGISTRY_H
#
define
AUDIOTHREADREGISTRY_H
#
include
<
cstdint
>
#
include
<
mozilla
/
DataMutex
.
h
>
#
include
<
nsTArray
.
h
>
#
include
<
thread
>
#
include
<
GeckoProfiler
.
h
>
namespace
mozilla
{
class
AudioThreadRegistry
final
{
public
:
AudioThreadRegistry
(
)
#
ifdef
MOZ_GECKO_PROFILER
:
mThreadIds
(
"
AudioThreadId
"
)
#
endif
{
}
#
ifdef
MOZ_GECKO_PROFILER
~
AudioThreadRegistry
(
)
{
}
#
endif
void
Register
(
int
aThreadId
)
{
#
ifdef
MOZ_GECKO_PROFILER
auto
threadIds
=
mThreadIds
.
Lock
(
)
;
for
(
uint32_t
i
=
0
;
i
<
threadIds
-
>
Length
(
)
;
i
+
+
)
{
if
(
(
*
threadIds
)
[
i
]
.
mId
=
=
aThreadId
)
{
(
*
threadIds
)
[
i
]
.
mUserCount
+
+
;
return
;
}
}
ThreadUserCount
tuc
;
tuc
.
mId
=
aThreadId
;
tuc
.
mUserCount
=
1
;
threadIds
-
>
AppendElement
(
tuc
)
;
PROFILER_REGISTER_THREAD
(
"
NativeAudioCallback
"
)
;
#
endif
}
void
Unregister
(
int
aThreadId
)
{
#
ifdef
MOZ_GECKO_PROFILER
auto
threadIds
=
mThreadIds
.
Lock
(
)
;
for
(
uint32_t
i
=
0
;
i
<
threadIds
-
>
Length
(
)
;
i
+
+
)
{
if
(
(
*
threadIds
)
[
i
]
.
mId
=
=
aThreadId
)
{
MOZ_ASSERT
(
(
*
threadIds
)
[
i
]
.
mUserCount
>
0
)
;
(
*
threadIds
)
[
i
]
.
mUserCount
-
-
;
if
(
(
*
threadIds
)
[
i
]
.
mUserCount
=
=
0
)
{
PROFILER_UNREGISTER_THREAD
(
)
;
threadIds
-
>
RemoveElementAt
(
i
)
;
}
return
;
}
}
MOZ_ASSERT
(
false
)
;
#
endif
}
private
:
AudioThreadRegistry
(
const
AudioThreadRegistry
&
)
=
delete
;
AudioThreadRegistry
&
operator
=
(
const
AudioThreadRegistry
&
)
=
delete
;
AudioThreadRegistry
(
AudioThreadRegistry
&
&
)
=
delete
;
AudioThreadRegistry
&
operator
=
(
AudioThreadRegistry
&
&
)
=
delete
;
#
ifdef
MOZ_GECKO_PROFILER
struct
ThreadUserCount
{
int
mId
;
int
mUserCount
;
}
;
DataMutex
<
nsTArray
<
ThreadUserCount
>
>
mThreadIds
;
#
endif
}
;
}
#
endif
