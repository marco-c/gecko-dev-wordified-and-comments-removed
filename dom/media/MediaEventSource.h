#
ifndef
MediaEventSource_h_
#
define
MediaEventSource_h_
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
class
RevocableToken
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RevocableToken
)
;
public
:
RevocableToken
(
)
=
default
;
virtual
void
Revoke
(
)
=
0
;
virtual
bool
IsRevoked
(
)
const
=
0
;
protected
:
virtual
~
RevocableToken
(
)
=
default
;
}
;
enum
class
ListenerPolicy
:
int8_t
{
Exclusive
NonExclusive
}
;
namespace
detail
{
template
<
typename
T
>
struct
EventTypeTraits
{
typedef
T
ArgType
;
}
;
template
<
>
struct
EventTypeTraits
<
void
>
{
typedef
bool
ArgType
;
}
;
template
<
typename
T
>
class
TakeArgsHelper
{
template
<
typename
C
>
static
std
:
:
false_type
test
(
void
(
C
:
:
*
)
(
)
int
)
;
template
<
typename
C
>
static
std
:
:
false_type
test
(
void
(
C
:
:
*
)
(
)
const
int
)
;
template
<
typename
C
>
static
std
:
:
false_type
test
(
void
(
C
:
:
*
)
(
)
volatile
int
)
;
template
<
typename
C
>
static
std
:
:
false_type
test
(
void
(
C
:
:
*
)
(
)
const
volatile
int
)
;
template
<
typename
F
>
static
std
:
:
false_type
test
(
F
&
&
decltype
(
std
:
:
declval
<
F
>
(
)
(
)
0
)
)
;
static
std
:
:
true_type
test
(
.
.
.
)
;
public
:
typedef
decltype
(
test
(
std
:
:
declval
<
T
>
(
)
0
)
)
type
;
}
;
template
<
typename
T
>
struct
TakeArgs
:
public
TakeArgsHelper
<
T
>
:
:
type
{
}
;
template
<
typename
T
>
class
RawPtr
{
public
:
explicit
RawPtr
(
T
*
aPtr
)
:
mPtr
(
aPtr
)
{
}
T
*
get
(
)
const
{
return
mPtr
;
}
private
:
T
*
const
mPtr
;
}
;
template
<
typename
.
.
.
As
>
class
Listener
:
public
RevocableToken
{
public
:
template
<
typename
.
.
.
Ts
>
void
Dispatch
(
Ts
&
&
.
.
.
aEvents
)
{
if
(
CanTakeArgs
(
)
)
{
DispatchTask
(
NewRunnableMethod
<
std
:
:
decay_t
<
Ts
>
&
&
.
.
.
>
(
"
detail
:
:
Listener
:
:
ApplyWithArgs
"
this
&
Listener
:
:
ApplyWithArgs
std
:
:
forward
<
Ts
>
(
aEvents
)
.
.
.
)
)
;
}
else
{
DispatchTask
(
NewRunnableMethod
(
"
detail
:
:
Listener
:
:
ApplyWithNoArgs
"
this
&
Listener
:
:
ApplyWithNoArgs
)
)
;
}
}
private
:
virtual
void
DispatchTask
(
already_AddRefed
<
nsIRunnable
>
aTask
)
=
0
;
virtual
bool
CanTakeArgs
(
)
const
=
0
;
virtual
void
ApplyWithArgs
(
As
&
&
.
.
.
aEvents
)
=
0
;
virtual
void
ApplyWithNoArgs
(
)
=
0
;
}
;
template
<
typename
Function
typename
.
.
.
As
>
class
ListenerImpl
:
public
Listener
<
As
.
.
.
>
{
using
FunctionStorage
=
std
:
:
decay_t
<
Function
>
;
using
SelfType
=
ListenerImpl
<
Function
As
.
.
.
>
;
public
:
ListenerImpl
(
nsCOMPtr
<
nsIEventTarget
>
&
&
aTarget
Function
&
&
aFunction
)
:
mData
(
MakeRefPtr
<
Data
>
(
std
:
:
move
(
aTarget
)
std
:
:
forward
<
Function
>
(
aFunction
)
)
"
MediaEvent
ListenerImpl
:
:
mData
"
)
{
}
protected
:
virtual
~
ListenerImpl
(
)
{
MOZ_ASSERT
(
IsRevoked
(
)
"
Must
disconnect
the
listener
.
"
)
;
}
private
:
void
DispatchTask
(
already_AddRefed
<
nsIRunnable
>
aTask
)
override
{
RefPtr
<
Data
>
data
;
{
auto
d
=
mData
.
Lock
(
)
;
data
=
*
d
;
}
if
(
NS_WARN_IF
(
!
data
)
)
{
RefPtr
<
nsIRunnable
>
temp
(
aTask
)
;
return
;
}
data
-
>
mTarget
-
>
Dispatch
(
std
:
:
move
(
aTask
)
)
;
}
bool
CanTakeArgs
(
)
const
override
{
return
TakeArgs
<
FunctionStorage
>
:
:
value
;
}
template
<
typename
F
>
std
:
:
enable_if_t
<
TakeArgs
<
F
>
:
:
value
void
>
ApplyWithArgsImpl
(
nsIEventTarget
*
aTarget
const
F
&
aFunc
As
&
&
.
.
.
aEvents
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aTarget
-
>
IsOnCurrentThread
(
)
)
;
aFunc
(
std
:
:
move
(
aEvents
)
.
.
.
)
;
}
template
<
typename
F
>
std
:
:
enable_if_t
<
!
TakeArgs
<
F
>
:
:
value
void
>
ApplyWithArgsImpl
(
nsIEventTarget
*
aTarget
const
F
&
aFunc
As
&
&
.
.
.
aEvents
)
{
MOZ_CRASH
(
"
Call
ApplyWithNoArgs
instead
.
"
)
;
}
void
ApplyWithArgs
(
As
&
&
.
.
.
aEvents
)
override
{
MOZ_RELEASE_ASSERT
(
TakeArgs
<
Function
>
:
:
value
)
;
RefPtr
<
Data
>
data
;
{
auto
d
=
mData
.
Lock
(
)
;
data
=
*
d
;
}
if
(
!
data
)
{
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
data
-
>
mTarget
-
>
IsOnCurrentThread
(
)
)
;
ApplyWithArgsImpl
(
data
-
>
mTarget
data
-
>
mFunction
std
:
:
move
(
aEvents
)
.
.
.
)
;
}
template
<
typename
F
>
std
:
:
enable_if_t
<
TakeArgs
<
F
>
:
:
value
void
>
ApplyWithNoArgsImpl
(
nsIEventTarget
*
aTarget
const
F
&
aFunc
)
{
MOZ_CRASH
(
"
Call
ApplyWithArgs
instead
.
"
)
;
}
template
<
typename
F
>
std
:
:
enable_if_t
<
!
TakeArgs
<
F
>
:
:
value
void
>
ApplyWithNoArgsImpl
(
nsIEventTarget
*
aTarget
const
F
&
aFunc
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aTarget
-
>
IsOnCurrentThread
(
)
)
;
aFunc
(
)
;
}
void
ApplyWithNoArgs
(
)
override
{
MOZ_RELEASE_ASSERT
(
!
TakeArgs
<
Function
>
:
:
value
)
;
RefPtr
<
Data
>
data
;
{
auto
d
=
mData
.
Lock
(
)
;
data
=
*
d
;
}
if
(
!
data
)
{
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
data
-
>
mTarget
-
>
IsOnCurrentThread
(
)
)
;
ApplyWithNoArgsImpl
(
data
-
>
mTarget
data
-
>
mFunction
)
;
}
void
Revoke
(
)
override
{
{
auto
data
=
mData
.
Lock
(
)
;
*
data
=
nullptr
;
}
}
bool
IsRevoked
(
)
const
override
{
auto
data
=
mData
.
Lock
(
)
;
return
!
*
data
;
}
struct
RefCountedMediaEventListenerData
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RefCountedMediaEventListenerData
)
protected
:
virtual
~
RefCountedMediaEventListenerData
(
)
=
default
;
}
;
struct
Data
:
public
RefCountedMediaEventListenerData
{
Data
(
nsCOMPtr
<
nsIEventTarget
>
&
&
aTarget
Function
&
&
aFunction
)
:
mTarget
(
std
:
:
move
(
aTarget
)
)
mFunction
(
std
:
:
forward
<
Function
>
(
aFunction
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mTarget
)
;
}
const
nsCOMPtr
<
nsIEventTarget
>
mTarget
;
FunctionStorage
mFunction
;
}
;
mutable
DataMutex
<
RefPtr
<
Data
>
>
mData
;
}
;
template
<
typename
Head
typename
.
.
.
Tails
>
struct
IsAnyReference
{
static
const
bool
value
=
std
:
:
is_reference_v
<
Head
>
|
|
IsAnyReference
<
Tails
.
.
.
>
:
:
value
;
}
;
template
<
typename
T
>
struct
IsAnyReference
<
T
>
{
static
const
bool
value
=
std
:
:
is_reference_v
<
T
>
;
}
;
}
template
<
ListenerPolicy
typename
.
.
.
Ts
>
class
MediaEventSourceImpl
;
class
MediaEventListener
{
template
<
ListenerPolicy
typename
.
.
.
Ts
>
friend
class
MediaEventSourceImpl
;
public
:
MediaEventListener
(
)
=
default
;
MediaEventListener
(
MediaEventListener
&
&
aOther
)
:
mToken
(
std
:
:
move
(
aOther
.
mToken
)
)
{
}
MediaEventListener
&
operator
=
(
MediaEventListener
&
&
aOther
)
{
MOZ_ASSERT
(
!
mToken
"
Must
disconnect
the
listener
.
"
)
;
mToken
=
std
:
:
move
(
aOther
.
mToken
)
;
return
*
this
;
}
~
MediaEventListener
(
)
{
MOZ_ASSERT
(
!
mToken
"
Must
disconnect
the
listener
.
"
)
;
}
void
Disconnect
(
)
{
mToken
-
>
Revoke
(
)
;
mToken
=
nullptr
;
}
void
DisconnectIfExists
(
)
{
if
(
mToken
)
{
Disconnect
(
)
;
}
}
private
:
explicit
MediaEventListener
(
RevocableToken
*
aToken
)
:
mToken
(
aToken
)
{
}
RefPtr
<
RevocableToken
>
mToken
;
}
;
template
<
ListenerPolicy
Lp
typename
.
.
.
Es
>
class
MediaEventSourceImpl
{
static_assert
(
!
detail
:
:
IsAnyReference
<
Es
.
.
.
>
:
:
value
"
Ref
-
type
not
supported
!
"
)
;
template
<
typename
T
>
using
ArgType
=
typename
detail
:
:
EventTypeTraits
<
T
>
:
:
ArgType
;
typedef
detail
:
:
Listener
<
ArgType
<
Es
>
.
.
.
>
Listener
;
template
<
typename
Func
>
using
ListenerImpl
=
detail
:
:
ListenerImpl
<
Func
ArgType
<
Es
>
.
.
.
>
;
template
<
typename
Method
>
using
TakeArgs
=
detail
:
:
TakeArgs
<
Method
>
;
void
PruneListeners
(
)
{
mListeners
.
RemoveElementsBy
(
[
]
(
const
auto
&
listener
)
{
return
listener
-
>
IsRevoked
(
)
;
}
)
;
}
template
<
typename
Function
>
MediaEventListener
ConnectInternal
(
nsIEventTarget
*
aTarget
Function
&
&
aFunction
)
{
MutexAutoLock
lock
(
mMutex
)
;
PruneListeners
(
)
;
MOZ_ASSERT
(
Lp
=
=
ListenerPolicy
:
:
NonExclusive
|
|
mListeners
.
IsEmpty
(
)
)
;
auto
l
=
mListeners
.
AppendElement
(
)
;
*
l
=
new
ListenerImpl
<
Function
>
(
aTarget
std
:
:
forward
<
Function
>
(
aFunction
)
)
;
return
MediaEventListener
(
*
l
)
;
}
public
:
template
<
typename
Function
>
MediaEventListener
Connect
(
nsIEventTarget
*
aTarget
Function
&
&
aFunction
)
{
return
ConnectInternal
(
aTarget
std
:
:
forward
<
Function
>
(
aFunction
)
)
;
}
template
<
typename
This
typename
Method
>
MediaEventListener
Connect
(
nsIEventTarget
*
aTarget
This
*
aThis
Method
aMethod
)
{
if
constexpr
(
TakeArgs
<
Method
>
:
:
value
)
{
detail
:
:
RawPtr
<
This
>
thiz
(
aThis
)
;
return
ConnectInternal
(
aTarget
[
=
]
(
ArgType
<
Es
>
&
&
.
.
.
aEvents
)
{
(
thiz
.
get
(
)
-
>
*
aMethod
)
(
std
:
:
move
(
aEvents
)
.
.
.
)
;
}
)
;
}
else
{
detail
:
:
RawPtr
<
This
>
thiz
(
aThis
)
;
return
ConnectInternal
(
aTarget
[
=
]
(
)
{
(
thiz
.
get
(
)
-
>
*
aMethod
)
(
)
;
}
)
;
}
}
protected
:
MediaEventSourceImpl
(
)
:
mMutex
(
"
MediaEventSourceImpl
:
:
mMutex
"
)
{
}
template
<
typename
.
.
.
Ts
>
void
NotifyInternal
(
Ts
&
&
.
.
.
aEvents
)
{
MutexAutoLock
lock
(
mMutex
)
;
int32_t
last
=
static_cast
<
int32_t
>
(
mListeners
.
Length
(
)
)
-
1
;
for
(
int32_t
i
=
last
;
i
>
=
0
;
-
-
i
)
{
auto
&
&
l
=
mListeners
[
i
]
;
if
(
l
-
>
IsRevoked
(
)
)
{
mListeners
.
RemoveElementAt
(
i
)
;
continue
;
}
l
-
>
Dispatch
(
std
:
:
forward
<
Ts
>
(
aEvents
)
.
.
.
)
;
}
}
private
:
Mutex
mMutex
MOZ_UNANNOTATED
;
nsTArray
<
RefPtr
<
Listener
>
>
mListeners
;
}
;
template
<
typename
.
.
.
Es
>
using
MediaEventSource
=
MediaEventSourceImpl
<
ListenerPolicy
:
:
NonExclusive
Es
.
.
.
>
;
template
<
typename
.
.
.
Es
>
using
MediaEventSourceExc
=
MediaEventSourceImpl
<
ListenerPolicy
:
:
Exclusive
Es
.
.
.
>
;
template
<
typename
.
.
.
Es
>
class
MediaEventProducer
:
public
MediaEventSource
<
Es
.
.
.
>
{
public
:
template
<
typename
.
.
.
Ts
>
void
Notify
(
Ts
&
&
.
.
.
aEvents
)
{
this
-
>
NotifyInternal
(
aEvents
.
.
.
)
;
}
}
;
template
<
>
class
MediaEventProducer
<
void
>
:
public
MediaEventSource
<
void
>
{
public
:
void
Notify
(
)
{
this
-
>
NotifyInternal
(
true
)
;
}
}
;
template
<
typename
.
.
.
Es
>
class
MediaEventProducerExc
:
public
MediaEventSourceExc
<
Es
.
.
.
>
{
public
:
template
<
typename
.
.
.
Ts
>
void
Notify
(
Ts
&
&
.
.
.
aEvents
)
{
this
-
>
NotifyInternal
(
std
:
:
forward
<
Ts
>
(
aEvents
)
.
.
.
)
;
}
}
;
template
<
typename
.
.
.
Es
>
class
MediaEventForwarder
:
public
MediaEventSource
<
Es
.
.
.
>
{
public
:
template
<
typename
T
>
using
ArgType
=
typename
detail
:
:
EventTypeTraits
<
T
>
:
:
ArgType
;
explicit
MediaEventForwarder
(
nsCOMPtr
<
nsISerialEventTarget
>
aEventTarget
)
:
mEventTarget
(
std
:
:
move
(
aEventTarget
)
)
{
}
MediaEventForwarder
(
MediaEventForwarder
&
&
aOther
)
:
mEventTarget
(
aOther
.
mEventTarget
)
mListeners
(
std
:
:
move
(
aOther
.
mListeners
)
)
{
}
~
MediaEventForwarder
(
)
{
MOZ_ASSERT
(
mListeners
.
IsEmpty
(
)
)
;
}
MediaEventForwarder
&
operator
=
(
MediaEventForwarder
&
&
aOther
)
{
MOZ_RELEASE_ASSERT
(
mEventTarget
=
=
aOther
.
mEventTarget
)
;
MOZ_ASSERT
(
mListeners
.
IsEmpty
(
)
)
;
mListeners
=
std
:
:
move
(
aOther
.
mListeners
)
;
}
void
Forward
(
MediaEventSource
<
Es
.
.
.
>
&
aSource
)
{
mListeners
.
AppendElement
(
aSource
.
Connect
(
mEventTarget
[
this
]
(
ArgType
<
Es
>
&
&
.
.
.
aEvents
)
{
this
-
>
NotifyInternal
(
std
:
:
forward
<
ArgType
<
Es
>
.
.
.
>
(
aEvents
)
.
.
.
)
;
}
)
)
;
}
template
<
typename
Function
>
void
ForwardIf
(
MediaEventSource
<
Es
.
.
.
>
&
aSource
Function
&
&
aFunction
)
{
mListeners
.
AppendElement
(
aSource
.
Connect
(
mEventTarget
[
this
func
=
aFunction
]
(
ArgType
<
Es
>
&
&
.
.
.
aEvents
)
{
if
(
!
func
(
)
)
{
return
;
}
this
-
>
NotifyInternal
(
std
:
:
forward
<
ArgType
<
Es
>
.
.
.
>
(
aEvents
)
.
.
.
)
;
}
)
)
;
}
void
DisconnectAll
(
)
{
for
(
auto
&
l
:
mListeners
)
{
l
.
Disconnect
(
)
;
}
mListeners
.
Clear
(
)
;
}
private
:
const
nsCOMPtr
<
nsISerialEventTarget
>
mEventTarget
;
nsTArray
<
MediaEventListener
>
mListeners
;
}
;
}
#
endif
