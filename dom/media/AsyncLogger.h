#
ifndef
mozilla_dom_AsyncLogger_h
#
define
mozilla_dom_AsyncLogger_h
#
include
<
atomic
>
#
include
<
thread
>
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
namespace
mozilla
{
namespace
detail
{
template
<
size_t
MESSAGE_LENGTH
>
class
MPSCQueue
{
public
:
struct
Message
{
Message
(
)
{
mNext
.
store
(
nullptr
std
:
:
memory_order_relaxed
)
;
}
Message
(
const
Message
&
aMessage
)
=
delete
;
void
operator
=
(
const
Message
&
aMessage
)
=
delete
;
char
data
[
MESSAGE_LENGTH
]
;
std
:
:
atomic
<
Message
*
>
mNext
;
}
;
MPSCQueue
(
)
:
mHead
(
new
Message
(
)
)
mTail
(
mHead
.
load
(
std
:
:
memory_order_relaxed
)
)
{
}
~
MPSCQueue
(
)
{
Message
dummy
;
while
(
this
-
>
Pop
(
dummy
.
data
)
)
{
}
Message
*
front
=
mHead
.
load
(
std
:
:
memory_order_relaxed
)
;
delete
front
;
}
void
Push
(
MPSCQueue
<
MESSAGE_LENGTH
>
:
:
Message
*
aMessage
)
{
Message
*
prev
=
mHead
.
exchange
(
aMessage
std
:
:
memory_order_acq_rel
)
;
prev
-
>
mNext
.
store
(
aMessage
std
:
:
memory_order_release
)
;
}
void
Push
(
const
char
aInput
[
MESSAGE_LENGTH
]
)
{
Message
*
msg
=
new
Message
(
)
;
strncpy
(
msg
-
>
data
aInput
MESSAGE_LENGTH
)
;
Push
(
msg
)
;
}
bool
Pop
(
char
aOutput
[
MESSAGE_LENGTH
]
)
{
Message
*
tail
=
mTail
.
load
(
std
:
:
memory_order_relaxed
)
;
Message
*
next
=
tail
-
>
mNext
.
load
(
std
:
:
memory_order_acquire
)
;
if
(
next
=
=
nullptr
)
{
return
false
;
}
strncpy
(
aOutput
next
-
>
data
MESSAGE_LENGTH
)
;
mTail
.
store
(
next
std
:
:
memory_order_release
)
;
delete
tail
;
return
true
;
}
private
:
std
:
:
atomic
<
Message
*
>
mHead
;
std
:
:
atomic
<
Message
*
>
mTail
;
MPSCQueue
(
const
MPSCQueue
&
)
=
delete
;
void
operator
=
(
const
MPSCQueue
&
)
=
delete
;
public
:
static
const
size_t
MESSAGE_PADDING
=
sizeof
(
Message
:
:
mNext
)
;
private
:
static_assert
(
IsPowerOfTwo
(
MESSAGE_LENGTH
+
MESSAGE_PADDING
)
"
MPSCQueue
internal
allocations
must
have
a
size
that
is
a
"
"
power
of
two
"
)
;
}
;
}
class
AsyncLogger
{
public
:
enum
class
TracingPhase
:
uint8_t
{
BEGIN
END
COMPLETE
}
;
const
char
TRACING_PHASE_STRINGS
[
3
]
=
{
'
B
'
'
E
'
'
X
'
}
;
enum
AsyncLoggerOutputMode
{
MOZLOG
PROFILER
}
;
typedef
char
TextPayload
[
504
]
;
explicit
AsyncLogger
(
const
char
*
aLogModuleName
AsyncLogger
:
:
AsyncLoggerOutputMode
aMode
=
AsyncLogger
:
:
AsyncLoggerOutputMode
:
:
PROFILER
)
:
mThread
(
nullptr
)
mLogModule
(
aLogModuleName
)
mRunning
(
false
)
{
}
void
Start
(
)
{
MOZ_ASSERT
(
!
mRunning
"
Double
calls
to
AsyncLogger
:
:
Start
"
)
;
if
(
mMode
=
=
AsyncLogger
:
:
AsyncLoggerOutputMode
:
:
MOZLOG
)
{
LogMozLog
(
"
[
"
)
;
}
if
(
Enabled
(
)
)
{
mRunning
=
true
;
Run
(
)
;
}
}
void
Stop
(
)
{
if
(
Enabled
(
)
)
{
if
(
mRunning
)
{
mRunning
=
false
;
mThread
-
>
join
(
)
;
}
}
else
{
MOZ_ASSERT
(
!
mRunning
&
&
!
mThread
)
;
}
}
void
Log
(
const
char
*
aName
const
char
*
aCategory
const
char
*
aComment
TracingPhase
aPhase
uint64_t
aPID
uint64_t
aThread
)
{
if
(
Enabled
(
)
)
{
auto
*
msg
=
new
detail
:
:
MPSCQueue
<
MAX_MESSAGE_LENGTH
>
:
:
Message
(
)
;
va_list
args
;
va_start
(
args
format
)
;
VsprintfLiteral
(
msg
-
>
data
format
args
)
;
va_end
(
args
)
;
mMessageQueue
.
Push
(
msg
)
;
if
(
mMode
=
=
AsyncLogger
:
:
AsyncLoggerOutputMode
:
:
MOZLOG
)
{
LogMozLog
(
"
{
\
"
name
\
"
:
\
"
%
s
\
"
\
"
cat
\
"
:
\
"
%
s
\
"
\
"
ph
\
"
:
\
"
%
c
\
"
"
"
\
"
ts
\
"
:
%
"
PRIu64
"
\
"
pid
\
"
:
%
"
PRIu64
"
\
"
tid
\
"
:
"
"
%
"
PRIu64
"
\
"
args
\
"
:
{
\
"
comment
\
"
:
\
"
%
s
\
"
}
}
"
aName
aCategory
TRACING_PHASE_STRINGS
[
static_cast
<
int
>
(
aPhase
)
]
NowInUs
(
)
aPID
aThread
aComment
)
;
}
else
{
}
}
}
void
LogDuration
(
const
char
*
aName
const
char
*
aCategory
uint64_t
aDuration
uint64_t
aPID
uint64_t
aThread
uint64_t
aFrames
uint64_t
aSampleRate
)
{
if
(
Enabled
(
)
)
{
if
(
mMode
=
=
AsyncLogger
:
:
AsyncLoggerOutputMode
:
:
MOZLOG
)
{
LogMozLog
(
"
{
\
"
name
\
"
:
\
"
%
s
\
"
\
"
cat
\
"
:
\
"
%
s
\
"
\
"
ph
\
"
:
\
"
X
\
"
"
"
\
"
ts
\
"
:
%
"
PRIu64
"
\
"
dur
\
"
:
%
"
PRIu64
"
\
"
pid
\
"
:
%
"
PRIu64
"
"
"
\
"
tid
\
"
:
%
"
PRIu64
"
\
"
args
\
"
:
{
\
"
comment
\
"
:
\
"
%
"
PRIu64
"
/
%
"
PRIu64
"
\
"
}
}
"
aName
aCategory
NowInUs
(
)
aDuration
aPID
aThread
aFrames
aSampleRate
)
;
}
else
{
}
}
}
void
LogMozLog
(
const
char
*
format
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
{
auto
*
msg
=
new
MPSCQueue
<
TextPayload
>
:
:
Message
(
)
;
va_list
args
;
va_start
(
args
format
)
;
VsprintfLiteral
(
msg
-
>
data
format
args
)
;
va_end
(
args
)
;
mMessageQueue
.
Push
(
msg
)
;
}
bool
Enabled
(
)
{
return
MOZ_LOG_TEST
(
mLogModule
mozilla
:
:
LogLevel
:
:
Verbose
)
;
}
private
:
void
Run
(
)
{
MOZ_ASSERT
(
Enabled
(
)
)
;
mThread
.
reset
(
new
std
:
:
thread
(
[
this
]
(
)
{
while
(
mRunning
)
{
char
message
[
MAX_MESSAGE_LENGTH
]
;
while
(
mMessageQueue
.
Pop
(
message
)
&
&
mRunning
)
{
MOZ_LOG
(
mLogModule
mozilla
:
:
LogLevel
:
:
Verbose
(
"
%
s
"
message
)
)
;
}
Sleep
(
)
;
}
}
)
)
;
}
uint64_t
NowInUs
(
)
{
static
TimeStamp
base
=
TimeStamp
:
:
NowUnfuzzed
(
)
;
return
(
TimeStamp
:
:
NowUnfuzzed
(
)
-
base
)
.
ToMicroseconds
(
)
;
}
void
Sleep
(
)
{
std
:
:
this_thread
:
:
sleep_for
(
std
:
:
chrono
:
:
milliseconds
(
10
)
)
;
}
std
:
:
unique_ptr
<
std
:
:
thread
>
mThread
;
mozilla
:
:
LazyLogModule
mLogModule
;
detail
:
:
MPSCQueue
<
MAX_MESSAGE_LENGTH
>
mMessageQueue
;
std
:
:
atomic
<
bool
>
mRunning
;
std
:
:
atomic
<
AsyncLoggerOutputMode
>
mMode
;
}
;
}
#
endif
