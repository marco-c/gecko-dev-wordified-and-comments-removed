#
ifndef
mozilla_dom_AsyncLogger_h
#
define
mozilla_dom_AsyncLogger_h
#
include
<
atomic
>
#
include
<
thread
>
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
namespace
mozilla
{
namespace
detail
{
template
<
size_t
MESSAGE_LENGTH
>
class
MPSCQueue
{
public
:
struct
Message
{
Message
(
)
{
mNext
.
store
(
nullptr
std
:
:
memory_order_relaxed
)
;
}
Message
(
const
Message
&
aMessage
)
=
delete
;
void
operator
=
(
const
Message
&
aMessage
)
=
delete
;
char
data
[
MESSAGE_LENGTH
]
;
std
:
:
atomic
<
Message
*
>
mNext
;
}
;
MPSCQueue
(
)
:
mHead
(
new
Message
(
)
)
mTail
(
mHead
.
load
(
std
:
:
memory_order_relaxed
)
)
{
}
~
MPSCQueue
(
)
{
Message
dummy
;
while
(
this
-
>
Pop
(
dummy
.
data
)
)
{
}
Message
*
front
=
mHead
.
load
(
std
:
:
memory_order_relaxed
)
;
delete
front
;
}
void
Push
(
MPSCQueue
<
MESSAGE_LENGTH
>
:
:
Message
*
aMessage
)
{
Message
*
prev
=
mHead
.
exchange
(
aMessage
std
:
:
memory_order_acq_rel
)
;
prev
-
>
mNext
.
store
(
aMessage
std
:
:
memory_order_release
)
;
}
void
Push
(
const
char
aInput
[
MESSAGE_LENGTH
]
)
{
Message
*
msg
=
new
Message
(
)
;
strncpy
(
msg
-
>
data
aInput
MESSAGE_LENGTH
)
;
Push
(
msg
)
;
}
bool
Pop
(
char
aOutput
[
MESSAGE_LENGTH
]
)
{
Message
*
tail
=
mTail
.
load
(
std
:
:
memory_order_relaxed
)
;
Message
*
next
=
tail
-
>
mNext
.
load
(
std
:
:
memory_order_acquire
)
;
if
(
next
=
=
nullptr
)
{
return
false
;
}
strncpy
(
aOutput
next
-
>
data
MESSAGE_LENGTH
)
;
mTail
.
store
(
next
std
:
:
memory_order_release
)
;
delete
tail
;
return
true
;
}
private
:
std
:
:
atomic
<
Message
*
>
mHead
;
std
:
:
atomic
<
Message
*
>
mTail
;
MPSCQueue
(
const
MPSCQueue
&
)
=
delete
;
void
operator
=
(
const
MPSCQueue
&
)
=
delete
;
public
:
static
const
size_t
MESSAGE_PADDING
=
sizeof
(
Message
:
:
mNext
)
;
private
:
static_assert
(
IsPowerOfTwo
(
MESSAGE_LENGTH
+
MESSAGE_PADDING
)
"
MPSCQueue
internal
allocations
must
have
a
size
that
is
a
"
"
power
of
two
"
)
;
}
;
}
class
AsyncLogger
{
public
:
static
const
uint32_t
MAX_MESSAGE_LENGTH
=
512
-
detail
:
:
MPSCQueue
<
sizeof
(
void
*
)
>
:
:
MESSAGE_PADDING
;
explicit
AsyncLogger
(
const
char
*
aLogModuleName
)
:
mThread
(
nullptr
)
mLogModule
(
aLogModuleName
)
mRunning
(
false
)
{
}
~
AsyncLogger
(
)
{
if
(
Enabled
(
)
)
{
Stop
(
)
;
}
}
void
Start
(
)
{
MOZ_ASSERT
(
!
mRunning
"
Double
calls
to
AsyncLogger
:
:
Start
"
)
;
if
(
Enabled
(
)
)
{
mRunning
=
true
;
Run
(
)
;
}
}
void
Stop
(
)
{
if
(
Enabled
(
)
)
{
if
(
mRunning
)
{
mRunning
=
false
;
mThread
-
>
join
(
)
;
}
}
else
{
MOZ_ASSERT
(
!
mRunning
&
&
!
mThread
)
;
}
}
void
Log
(
const
char
*
format
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
{
if
(
Enabled
(
)
)
{
auto
*
msg
=
new
detail
:
:
MPSCQueue
<
MAX_MESSAGE_LENGTH
>
:
:
Message
(
)
;
va_list
args
;
va_start
(
args
format
)
;
VsprintfLiteral
(
msg
-
>
data
format
args
)
;
va_end
(
args
)
;
mMessageQueue
.
Push
(
msg
)
;
}
}
bool
Enabled
(
)
{
return
MOZ_LOG_TEST
(
mLogModule
mozilla
:
:
LogLevel
:
:
Verbose
)
;
}
private
:
void
Run
(
)
{
MOZ_ASSERT
(
Enabled
(
)
)
;
mThread
.
reset
(
new
std
:
:
thread
(
[
this
]
(
)
{
while
(
mRunning
)
{
char
message
[
MAX_MESSAGE_LENGTH
]
;
while
(
mMessageQueue
.
Pop
(
message
)
&
&
mRunning
)
{
MOZ_LOG
(
mLogModule
mozilla
:
:
LogLevel
:
:
Verbose
(
"
%
s
"
message
)
)
;
}
Sleep
(
)
;
}
}
)
)
;
}
void
Sleep
(
)
{
std
:
:
this_thread
:
:
sleep_for
(
std
:
:
chrono
:
:
milliseconds
(
10
)
)
;
}
std
:
:
unique_ptr
<
std
:
:
thread
>
mThread
;
mozilla
:
:
LazyLogModule
mLogModule
;
detail
:
:
MPSCQueue
<
MAX_MESSAGE_LENGTH
>
mMessageQueue
;
std
:
:
atomic
<
bool
>
mRunning
;
}
;
}
#
endif
