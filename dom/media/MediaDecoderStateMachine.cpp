#
ifdef
XP_WIN
#
include
"
windows
.
h
"
#
include
"
mmsystem
.
h
"
#
endif
#
include
<
algorithm
>
#
include
<
stdint
.
h
>
#
include
"
gfx2DGlue
.
h
"
#
include
"
mediasink
/
AudioSinkWrapper
.
h
"
#
include
"
mediasink
/
DecodedAudioDataSink
.
h
"
#
include
"
mediasink
/
DecodedStream
.
h
"
#
include
"
mediasink
/
OutputStreamManager
.
h
"
#
include
"
mediasink
/
VideoSink
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsDeque
.
h
"
#
include
"
prenv
.
h
"
#
include
"
AccurateSeekTask
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
DOMMediaStream
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
MediaDecoder
.
h
"
#
include
"
MediaDecoderReader
.
h
"
#
include
"
MediaDecoderReaderWrapper
.
h
"
#
include
"
MediaDecoderStateMachine
.
h
"
#
include
"
MediaShutdownManager
.
h
"
#
include
"
MediaPrefs
.
h
"
#
include
"
MediaTimer
.
h
"
#
include
"
NextFrameSeekTask
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
VideoSegment
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
gfxPrefs
.
h
"
namespace
mozilla
{
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
media
;
#
define
NS_DispatchToMainThread
(
.
.
.
)
CompileError_UseAbstractThreadDispatchInstead
#
undef
FMT
#
undef
DECODER_LOG
#
undef
VERBOSE_LOG
#
undef
SAMPLE_LOG
#
undef
DECODER_WARN
#
undef
DUMP_LOG
#
undef
SFMT
#
undef
SLOG
#
undef
SWARN
#
define
FMT
(
x
.
.
.
)
"
Decoder
=
%
p
"
x
mDecoderID
#
#
__VA_ARGS__
#
define
DECODER_LOG
(
.
.
.
)
MOZ_LOG
(
gMediaDecoderLog
LogLevel
:
:
Debug
(
FMT
(
__VA_ARGS__
)
)
)
#
define
VERBOSE_LOG
(
.
.
.
)
MOZ_LOG
(
gMediaDecoderLog
LogLevel
:
:
Verbose
(
FMT
(
__VA_ARGS__
)
)
)
#
define
SAMPLE_LOG
(
.
.
.
)
MOZ_LOG
(
gMediaSampleLog
LogLevel
:
:
Debug
(
FMT
(
__VA_ARGS__
)
)
)
#
define
DECODER_WARN
(
.
.
.
)
NS_WARNING
(
nsPrintfCString
(
FMT
(
__VA_ARGS__
)
)
.
get
(
)
)
#
define
DUMP_LOG
(
.
.
.
)
NS_DebugBreak
(
NS_DEBUG_WARNING
nsPrintfCString
(
FMT
(
__VA_ARGS__
)
)
.
get
(
)
nullptr
nullptr
-
1
)
#
define
SFMT
(
x
.
.
.
)
"
Decoder
=
%
p
state
=
%
s
"
x
mMaster
-
>
mDecoderID
ToStateStr
(
GetState
(
)
)
#
#
__VA_ARGS__
#
define
SLOG
(
.
.
.
)
MOZ_LOG
(
gMediaDecoderLog
LogLevel
:
:
Debug
(
SFMT
(
__VA_ARGS__
)
)
)
#
define
SWARN
(
.
.
.
)
NS_WARNING
(
nsPrintfCString
(
SFMT
(
__VA_ARGS__
)
)
.
get
(
)
)
namespace
detail
{
static
const
uint32_t
LOW_AUDIO_USECS
=
300000
;
static
const
int64_t
AMPLE_AUDIO_USECS
=
2000000
;
}
static
const
uint32_t
LOW_VIDEO_FRAMES
=
2
;
static
const
int32_t
LOW_VIDEO_THRESHOLD_USECS
=
60000
;
static
const
int
AUDIO_DURATION_USECS
=
40000
;
static
const
int
THRESHOLD_FACTOR
=
2
;
namespace
detail
{
static
const
int64_t
LOW_DATA_THRESHOLD_USECS
=
5000000
;
static_assert
(
LOW_DATA_THRESHOLD_USECS
>
AMPLE_AUDIO_USECS
"
LOW_DATA_THRESHOLD_USECS
is
too
small
"
)
;
}
static
const
uint32_t
EXHAUSTED_DATA_MARGIN_USECS
=
100000
;
static
int64_t
DurationToUsecs
(
TimeDuration
aDuration
)
{
return
static_cast
<
int64_t
>
(
aDuration
.
ToSeconds
(
)
*
USECS_PER_S
)
;
}
static
const
uint32_t
MIN_VIDEO_QUEUE_SIZE
=
3
;
static
const
uint32_t
MAX_VIDEO_QUEUE_SIZE
=
10
;
#
ifdef
MOZ_APPLEMEDIA
static
const
uint32_t
HW_VIDEO_QUEUE_SIZE
=
10
;
#
else
static
const
uint32_t
HW_VIDEO_QUEUE_SIZE
=
3
;
#
endif
static
const
uint32_t
VIDEO_QUEUE_SEND_TO_COMPOSITOR_SIZE
=
9999
;
static
uint32_t
sVideoQueueDefaultSize
=
MAX_VIDEO_QUEUE_SIZE
;
static
uint32_t
sVideoQueueHWAccelSize
=
HW_VIDEO_QUEUE_SIZE
;
static
uint32_t
sVideoQueueSendToCompositorSize
=
VIDEO_QUEUE_SEND_TO_COMPOSITOR_SIZE
;
static
void
InitVideoQueuePrefs
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
static
bool
sPrefInit
=
false
;
if
(
!
sPrefInit
)
{
sPrefInit
=
true
;
sVideoQueueDefaultSize
=
Preferences
:
:
GetUint
(
"
media
.
video
-
queue
.
default
-
size
"
MAX_VIDEO_QUEUE_SIZE
)
;
sVideoQueueHWAccelSize
=
Preferences
:
:
GetUint
(
"
media
.
video
-
queue
.
hw
-
accel
-
size
"
HW_VIDEO_QUEUE_SIZE
)
;
sVideoQueueSendToCompositorSize
=
Preferences
:
:
GetUint
(
"
media
.
video
-
queue
.
send
-
to
-
compositor
-
size
"
VIDEO_QUEUE_SEND_TO_COMPOSITOR_SIZE
)
;
}
}
static
TimeDuration
SuspendBackgroundVideoDelay
(
)
{
return
TimeDuration
:
:
FromMilliseconds
(
MediaPrefs
:
:
MDSMSuspendBackgroundVideoDelay
(
)
)
;
}
class
MediaDecoderStateMachine
:
:
StateObject
{
public
:
virtual
~
StateObject
(
)
{
}
virtual
void
Enter
(
)
{
}
;
virtual
void
Exit
(
)
{
}
;
virtual
void
Step
(
)
{
}
virtual
State
GetState
(
)
const
=
0
;
virtual
bool
HandleDormant
(
bool
aDormant
)
{
if
(
!
aDormant
)
{
return
true
;
}
mMaster
-
>
mQueuedSeek
.
mTarget
=
SeekTarget
(
mMaster
-
>
mCurrentPosition
SeekTarget
:
:
Accurate
MediaDecoderEventVisibility
:
:
Suppressed
)
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
unused
=
mMaster
-
>
mQueuedSeek
.
mPromise
.
Ensure
(
__func__
)
;
SetState
(
DECODER_STATE_DORMANT
)
;
return
true
;
}
virtual
bool
HandleCDMProxyReady
(
)
{
return
false
;
}
virtual
bool
HandleAudioDecoded
(
MediaData
*
aAudio
)
{
return
false
;
}
virtual
bool
HandleVideoDecoded
(
MediaData
*
aVideo
TimeStamp
aDecodeStart
)
{
return
false
;
}
virtual
bool
HandleEndOfStream
(
)
{
return
false
;
}
virtual
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
HandleSeek
(
SeekTarget
aTarget
)
{
MOZ_ASSERT
(
false
"
Can
'
t
seek
in
this
state
"
)
;
return
nullptr
;
}
protected
:
using
Master
=
MediaDecoderStateMachine
;
explicit
StateObject
(
Master
*
aPtr
)
:
mMaster
(
aPtr
)
{
}
TaskQueue
*
OwnerThread
(
)
const
{
return
mMaster
-
>
mTaskQueue
;
}
MediaResource
*
Resource
(
)
const
{
return
mMaster
-
>
mResource
;
}
MediaDecoderReaderWrapper
*
Reader
(
)
const
{
return
mMaster
-
>
mReader
;
}
void
SetState
(
State
aState
)
{
mMaster
-
>
SetState
(
aState
)
;
}
Master
*
mMaster
;
}
;
class
MediaDecoderStateMachine
:
:
DecodeMetadataState
:
public
MediaDecoderStateMachine
:
:
StateObject
{
public
:
explicit
DecodeMetadataState
(
Master
*
aPtr
)
:
StateObject
(
aPtr
)
{
}
void
Enter
(
)
override
{
MOZ_ASSERT
(
!
mMetadataRequest
.
Exists
(
)
)
;
SLOG
(
"
Dispatching
AsyncReadMetadata
"
)
;
Resource
(
)
-
>
SetReadMode
(
MediaCacheStream
:
:
MODE_METADATA
)
;
mMetadataRequest
.
Begin
(
Reader
(
)
-
>
ReadMetadata
(
)
-
>
Then
(
OwnerThread
(
)
__func__
[
this
]
(
MetadataHolder
*
aMetadata
)
{
OnMetadataRead
(
aMetadata
)
;
}
[
this
]
(
const
MediaResult
&
aError
)
{
OnMetadataNotRead
(
aError
)
;
}
)
)
;
}
void
Exit
(
)
override
{
mMetadataRequest
.
DisconnectIfExists
(
)
;
}
State
GetState
(
)
const
override
{
return
DECODER_STATE_DECODING_METADATA
;
}
bool
HandleDormant
(
bool
aDormant
)
override
{
mPendingDormant
=
aDormant
;
return
true
;
}
private
:
void
OnMetadataRead
(
MetadataHolder
*
aMetadata
)
{
mMetadataRequest
.
Complete
(
)
;
if
(
mPendingDormant
)
{
SetState
(
DECODER_STATE_DORMANT
)
;
return
;
}
Resource
(
)
-
>
SetReadMode
(
MediaCacheStream
:
:
MODE_PLAYBACK
)
;
mMaster
-
>
mInfo
=
aMetadata
-
>
mInfo
;
mMaster
-
>
mMetadataTags
=
aMetadata
-
>
mTags
.
forget
(
)
;
if
(
mMaster
-
>
mInfo
.
mMetadataDuration
.
isSome
(
)
)
{
mMaster
-
>
RecomputeDuration
(
)
;
}
else
if
(
mMaster
-
>
mInfo
.
mUnadjustedMetadataEndTime
.
isSome
(
)
)
{
RefPtr
<
Master
>
master
=
mMaster
;
Reader
(
)
-
>
AwaitStartTime
(
)
-
>
Then
(
OwnerThread
(
)
__func__
[
master
]
(
)
{
NS_ENSURE_TRUE_VOID
(
!
master
-
>
IsShutdown
(
)
)
;
TimeUnit
unadjusted
=
master
-
>
mInfo
.
mUnadjustedMetadataEndTime
.
ref
(
)
;
TimeUnit
adjustment
=
master
-
>
mReader
-
>
StartTime
(
)
;
master
-
>
mInfo
.
mMetadataDuration
.
emplace
(
unadjusted
-
adjustment
)
;
master
-
>
RecomputeDuration
(
)
;
}
[
master
this
]
(
)
{
SWARN
(
"
Adjusting
metadata
end
time
failed
"
)
;
}
)
;
}
if
(
mMaster
-
>
HasVideo
(
)
)
{
SLOG
(
"
Video
decode
isAsync
=
%
d
HWAccel
=
%
d
videoQueueSize
=
%
d
"
Reader
(
)
-
>
IsAsync
(
)
Reader
(
)
-
>
VideoIsHardwareAccelerated
(
)
mMaster
-
>
GetAmpleVideoFrames
(
)
)
;
}
bool
waitingForCDM
=
mMaster
-
>
mInfo
.
IsEncrypted
(
)
&
&
!
mMaster
-
>
mCDMProxy
;
mMaster
-
>
mNotifyMetadataBeforeFirstFrame
=
mMaster
-
>
mDuration
.
Ref
(
)
.
isSome
(
)
|
|
waitingForCDM
;
if
(
mMaster
-
>
mNotifyMetadataBeforeFirstFrame
)
{
mMaster
-
>
EnqueueLoadedMetadataEvent
(
)
;
}
if
(
waitingForCDM
)
{
SetState
(
DECODER_STATE_WAIT_FOR_CDM
)
;
return
;
}
SetState
(
DECODER_STATE_DECODING_FIRSTFRAME
)
;
}
void
OnMetadataNotRead
(
const
MediaResult
&
aError
)
{
mMetadataRequest
.
Complete
(
)
;
SWARN
(
"
Decode
metadata
failed
shutting
down
decoder
"
)
;
mMaster
-
>
DecodeError
(
aError
)
;
}
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
MetadataPromise
>
mMetadataRequest
;
bool
mPendingDormant
=
false
;
}
;
class
MediaDecoderStateMachine
:
:
WaitForCDMState
:
public
MediaDecoderStateMachine
:
:
StateObject
{
public
:
explicit
WaitForCDMState
(
Master
*
aPtr
)
:
StateObject
(
aPtr
)
{
}
State
GetState
(
)
const
override
{
return
DECODER_STATE_WAIT_FOR_CDM
;
}
bool
HandleCDMProxyReady
(
)
override
{
SetState
(
DECODER_STATE_DECODING_FIRSTFRAME
)
;
return
true
;
}
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
HandleSeek
(
SeekTarget
aTarget
)
override
{
SLOG
(
"
Not
Enough
Data
to
seek
at
this
stage
queuing
seek
"
)
;
mMaster
-
>
mQueuedSeek
.
RejectIfExists
(
__func__
)
;
mMaster
-
>
mQueuedSeek
.
mTarget
=
aTarget
;
return
mMaster
-
>
mQueuedSeek
.
mPromise
.
Ensure
(
__func__
)
;
}
}
;
class
MediaDecoderStateMachine
:
:
DormantState
:
public
MediaDecoderStateMachine
:
:
StateObject
{
public
:
explicit
DormantState
(
Master
*
aPtr
)
:
StateObject
(
aPtr
)
{
}
void
Enter
(
)
override
{
if
(
mMaster
-
>
IsPlaying
(
)
)
{
mMaster
-
>
StopPlayback
(
)
;
}
mMaster
-
>
Reset
(
)
;
mMaster
-
>
mReader
-
>
ReleaseResources
(
)
;
}
State
GetState
(
)
const
override
{
return
DECODER_STATE_DORMANT
;
}
bool
HandleDormant
(
bool
aDormant
)
override
{
if
(
!
aDormant
)
{
SetState
(
DECODER_STATE_DECODING_METADATA
)
;
}
return
true
;
}
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
HandleSeek
(
SeekTarget
aTarget
)
override
{
SLOG
(
"
Not
Enough
Data
to
seek
at
this
stage
queuing
seek
"
)
;
mMaster
-
>
mQueuedSeek
.
RejectIfExists
(
__func__
)
;
mMaster
-
>
mQueuedSeek
.
mTarget
=
aTarget
;
return
mMaster
-
>
mQueuedSeek
.
mPromise
.
Ensure
(
__func__
)
;
}
}
;
class
MediaDecoderStateMachine
:
:
DecodingFirstFrameState
:
public
MediaDecoderStateMachine
:
:
StateObject
{
public
:
explicit
DecodingFirstFrameState
(
Master
*
aPtr
)
:
StateObject
(
aPtr
)
{
}
void
Enter
(
)
override
{
if
(
mMaster
-
>
mQueuedSeek
.
Exists
(
)
&
&
(
mMaster
-
>
mSentFirstFrameLoadedEvent
|
|
Reader
(
)
-
>
ForceZeroStartTime
(
)
)
)
{
mMaster
-
>
InitiateSeek
(
Move
(
mMaster
-
>
mQueuedSeek
)
)
;
return
;
}
if
(
mMaster
-
>
mSentFirstFrameLoadedEvent
)
{
SetState
(
DECODER_STATE_DECODING
)
;
return
;
}
mMaster
-
>
DispatchDecodeTasksIfNeeded
(
)
;
}
State
GetState
(
)
const
override
{
return
DECODER_STATE_DECODING_FIRSTFRAME
;
}
bool
HandleAudioDecoded
(
MediaData
*
aAudio
)
override
{
mMaster
-
>
Push
(
aAudio
MediaData
:
:
AUDIO_DATA
)
;
MaybeFinishDecodeFirstFrame
(
)
;
return
true
;
}
bool
HandleVideoDecoded
(
MediaData
*
aVideo
TimeStamp
aDecodeStart
)
override
{
mMaster
-
>
Push
(
aVideo
MediaData
:
:
VIDEO_DATA
)
;
MaybeFinishDecodeFirstFrame
(
)
;
return
true
;
}
bool
HandleEndOfStream
(
)
override
{
MaybeFinishDecodeFirstFrame
(
)
;
return
true
;
}
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
HandleSeek
(
SeekTarget
aTarget
)
override
{
MOZ_ASSERT
(
!
mMaster
-
>
mSentFirstFrameLoadedEvent
)
;
if
(
!
Reader
(
)
-
>
ForceZeroStartTime
(
)
)
{
SLOG
(
"
Not
Enough
Data
to
seek
at
this
stage
queuing
seek
"
)
;
mMaster
-
>
mQueuedSeek
.
RejectIfExists
(
__func__
)
;
mMaster
-
>
mQueuedSeek
.
mTarget
=
aTarget
;
return
mMaster
-
>
mQueuedSeek
.
mPromise
.
Ensure
(
__func__
)
;
}
MOZ_ASSERT
(
!
mMaster
-
>
mQueuedSeek
.
Exists
(
)
)
;
SLOG
(
"
Changed
state
to
SEEKING
(
to
%
lld
)
"
aTarget
.
GetTime
(
)
.
ToMicroseconds
(
)
)
;
SeekJob
seekJob
;
seekJob
.
mTarget
=
aTarget
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
p
=
seekJob
.
mPromise
.
Ensure
(
__func__
)
;
mMaster
-
>
InitiateSeek
(
Move
(
seekJob
)
)
;
return
p
.
forget
(
)
;
}
private
:
void
MaybeFinishDecodeFirstFrame
(
)
{
MOZ_ASSERT
(
!
mMaster
-
>
mSentFirstFrameLoadedEvent
)
;
if
(
(
mMaster
-
>
IsAudioDecoding
(
)
&
&
mMaster
-
>
AudioQueue
(
)
.
GetSize
(
)
=
=
0
)
|
|
(
mMaster
-
>
IsVideoDecoding
(
)
&
&
mMaster
-
>
VideoQueue
(
)
.
GetSize
(
)
=
=
0
)
)
{
return
;
}
mMaster
-
>
FinishDecodeFirstFrame
(
)
;
if
(
mMaster
-
>
mQueuedSeek
.
Exists
(
)
)
{
mMaster
-
>
InitiateSeek
(
Move
(
mMaster
-
>
mQueuedSeek
)
)
;
}
else
{
SetState
(
DECODER_STATE_DECODING
)
;
}
}
}
;
class
MediaDecoderStateMachine
:
:
DecodingState
:
public
MediaDecoderStateMachine
:
:
StateObject
{
public
:
explicit
DecodingState
(
Master
*
aPtr
)
:
StateObject
(
aPtr
)
{
}
void
Enter
(
)
override
{
MOZ_ASSERT
(
mMaster
-
>
mSentFirstFrameLoadedEvent
)
;
MOZ_ASSERT
(
!
mMaster
-
>
mQueuedSeek
.
Exists
(
)
)
;
if
(
mMaster
-
>
CheckIfDecodeComplete
(
)
)
{
SetState
(
DECODER_STATE_COMPLETED
)
;
return
;
}
mDecodeStartTime
=
TimeStamp
:
:
Now
(
)
;
mMaster
-
>
mIsPrerolling
=
true
;
mMaster
-
>
MaybeStopPrerolling
(
)
;
mMaster
-
>
DispatchDecodeTasksIfNeeded
(
)
;
mMaster
-
>
ScheduleStateMachine
(
)
;
}
void
Exit
(
)
override
{
if
(
!
mDecodeStartTime
.
IsNull
(
)
)
{
TimeDuration
decodeDuration
=
TimeStamp
:
:
Now
(
)
-
mDecodeStartTime
;
SLOG
(
"
Exiting
DECODING
decoded
for
%
.
3lfs
"
decodeDuration
.
ToSeconds
(
)
)
;
}
mMaster
-
>
mIsPrerolling
=
false
;
}
void
Step
(
)
override
{
if
(
mMaster
-
>
mPlayState
!
=
MediaDecoder
:
:
PLAY_STATE_PLAYING
&
&
mMaster
-
>
IsPlaying
(
)
)
{
mMaster
-
>
StopPlayback
(
)
;
}
mMaster
-
>
MaybeStartPlayback
(
)
;
mMaster
-
>
UpdatePlaybackPositionPeriodically
(
)
;
MOZ_ASSERT
(
!
mMaster
-
>
IsPlaying
(
)
|
|
mMaster
-
>
IsStateMachineScheduled
(
)
"
Must
have
timer
scheduled
"
)
;
mMaster
-
>
MaybeStartBuffering
(
)
;
}
State
GetState
(
)
const
override
{
return
DECODER_STATE_DECODING
;
}
bool
HandleAudioDecoded
(
MediaData
*
aAudio
)
override
{
mMaster
-
>
Push
(
aAudio
MediaData
:
:
AUDIO_DATA
)
;
mMaster
-
>
MaybeStopPrerolling
(
)
;
return
true
;
}
bool
HandleVideoDecoded
(
MediaData
*
aVideo
TimeStamp
aDecodeStart
)
override
{
mMaster
-
>
Push
(
aVideo
MediaData
:
:
VIDEO_DATA
)
;
mMaster
-
>
MaybeStopPrerolling
(
)
;
CheckSlowDecoding
(
aDecodeStart
)
;
return
true
;
}
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
HandleSeek
(
SeekTarget
aTarget
)
override
{
mMaster
-
>
mQueuedSeek
.
RejectIfExists
(
__func__
)
;
SLOG
(
"
Changed
state
to
SEEKING
(
to
%
lld
)
"
aTarget
.
GetTime
(
)
.
ToMicroseconds
(
)
)
;
SeekJob
seekJob
;
seekJob
.
mTarget
=
aTarget
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
p
=
seekJob
.
mPromise
.
Ensure
(
__func__
)
;
mMaster
-
>
InitiateSeek
(
Move
(
seekJob
)
)
;
return
p
.
forget
(
)
;
}
private
:
void
CheckSlowDecoding
(
TimeStamp
aDecodeStart
)
{
if
(
Reader
(
)
-
>
IsAsync
(
)
)
{
return
;
}
TimeDuration
decodeTime
=
TimeStamp
:
:
Now
(
)
-
aDecodeStart
;
int64_t
adjustedTime
=
THRESHOLD_FACTOR
*
DurationToUsecs
(
decodeTime
)
;
if
(
adjustedTime
>
mMaster
-
>
mLowAudioThresholdUsecs
&
&
!
mMaster
-
>
HasLowBufferedData
(
)
)
{
mMaster
-
>
mLowAudioThresholdUsecs
=
std
:
:
min
(
adjustedTime
mMaster
-
>
mAmpleAudioThresholdUsecs
)
;
mMaster
-
>
mAmpleAudioThresholdUsecs
=
std
:
:
max
(
THRESHOLD_FACTOR
*
mMaster
-
>
mLowAudioThresholdUsecs
mMaster
-
>
mAmpleAudioThresholdUsecs
)
;
SLOG
(
"
Slow
video
decode
set
"
"
mLowAudioThresholdUsecs
=
%
lld
"
"
mAmpleAudioThresholdUsecs
=
%
lld
"
mMaster
-
>
mLowAudioThresholdUsecs
mMaster
-
>
mAmpleAudioThresholdUsecs
)
;
}
}
bool
HandleEndOfStream
(
)
override
{
if
(
mMaster
-
>
CheckIfDecodeComplete
(
)
)
{
SetState
(
DECODER_STATE_COMPLETED
)
;
}
return
true
;
}
TimeStamp
mDecodeStartTime
;
}
;
class
MediaDecoderStateMachine
:
:
SeekingState
:
public
MediaDecoderStateMachine
:
:
StateObject
{
public
:
explicit
SeekingState
(
Master
*
aPtr
SeekJob
aSeekJob
)
:
StateObject
(
aPtr
)
mSeekJob
(
Move
(
aSeekJob
)
)
{
}
void
Enter
(
)
override
{
mMaster
-
>
CancelMediaDecoderReaderWrapperCallback
(
)
;
if
(
mSeekJob
.
mTarget
.
IsAccurate
(
)
|
|
mSeekJob
.
mTarget
.
IsFast
(
)
)
{
mSeekTask
=
new
AccurateSeekTask
(
mMaster
-
>
mDecoderID
OwnerThread
(
)
Reader
(
)
mSeekJob
.
mTarget
mMaster
-
>
mInfo
mMaster
-
>
Duration
(
)
mMaster
-
>
GetMediaTime
(
)
)
;
}
else
if
(
mSeekJob
.
mTarget
.
IsNextFrame
(
)
)
{
mSeekTask
=
new
NextFrameSeekTask
(
mMaster
-
>
mDecoderID
OwnerThread
(
)
Reader
(
)
mSeekJob
.
mTarget
mMaster
-
>
mInfo
mMaster
-
>
Duration
(
)
mMaster
-
>
GetMediaTime
(
)
mMaster
-
>
AudioQueue
(
)
mMaster
-
>
VideoQueue
(
)
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
Cannot
handle
this
seek
task
.
"
)
;
}
if
(
!
mSeekJob
.
mTarget
.
IsVideoOnly
(
)
)
{
mMaster
-
>
StopPlayback
(
)
;
}
mMaster
-
>
UpdatePlaybackPositionInternal
(
mSeekTask
-
>
GetSeekTarget
(
)
.
GetTime
(
)
.
ToMicroseconds
(
)
)
;
if
(
mSeekJob
.
mTarget
.
mEventVisibility
=
=
MediaDecoderEventVisibility
:
:
Observable
)
{
mMaster
-
>
mOnPlaybackEvent
.
Notify
(
MediaEventType
:
:
SeekStarted
)
;
}
if
(
mSeekTask
-
>
NeedToResetMDSM
(
)
)
{
if
(
mSeekJob
.
mTarget
.
IsVideoOnly
(
)
)
{
mMaster
-
>
Reset
(
TrackInfo
:
:
kVideoTrack
)
;
}
else
{
mMaster
-
>
Reset
(
)
;
}
}
mSeekTaskRequest
.
Begin
(
mSeekTask
-
>
Seek
(
mMaster
-
>
Duration
(
)
)
-
>
Then
(
OwnerThread
(
)
__func__
[
this
]
(
const
SeekTaskResolveValue
&
aValue
)
{
OnSeekTaskResolved
(
aValue
)
;
}
[
this
]
(
const
SeekTaskRejectValue
&
aValue
)
{
OnSeekTaskRejected
(
aValue
)
;
}
)
)
;
MOZ_ASSERT
(
!
mMaster
-
>
mQueuedSeek
.
Exists
(
)
)
;
MOZ_ASSERT
(
!
mMaster
-
>
mCurrentSeek
.
Exists
(
)
)
;
mMaster
-
>
mCurrentSeek
=
Move
(
mSeekJob
)
;
}
void
Exit
(
)
override
{
mSeekTaskRequest
.
DisconnectIfExists
(
)
;
if
(
mSeekTask
)
{
mMaster
-
>
mCurrentSeek
.
RejectIfExists
(
__func__
)
;
mSeekTask
-
>
Discard
(
)
;
mSeekTask
=
nullptr
;
mMaster
-
>
SetMediaDecoderReaderWrapperCallback
(
)
;
}
}
State
GetState
(
)
const
override
{
return
DECODER_STATE_SEEKING
;
}
bool
HandleDormant
(
bool
aDormant
)
override
{
if
(
!
aDormant
)
{
return
true
;
}
MOZ_ASSERT
(
!
mMaster
-
>
mQueuedSeek
.
Exists
(
)
)
;
MOZ_ASSERT
(
mMaster
-
>
mCurrentSeek
.
Exists
(
)
)
;
if
(
mMaster
-
>
mCurrentSeek
.
mTarget
.
IsVideoOnly
(
)
)
{
mMaster
-
>
mCurrentSeek
.
mTarget
.
SetType
(
SeekTarget
:
:
Accurate
)
;
mMaster
-
>
mCurrentSeek
.
mTarget
.
SetVideoOnly
(
false
)
;
}
mMaster
-
>
mQueuedSeek
=
Move
(
mMaster
-
>
mCurrentSeek
)
;
SetState
(
DECODER_STATE_DORMANT
)
;
return
true
;
}
bool
HandleAudioDecoded
(
MediaData
*
aAudio
)
override
{
MOZ_ASSERT
(
false
)
;
return
true
;
}
bool
HandleVideoDecoded
(
MediaData
*
aVideo
TimeStamp
aDecodeStart
)
override
{
MOZ_ASSERT
(
false
)
;
return
true
;
}
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
HandleSeek
(
SeekTarget
aTarget
)
override
{
mMaster
-
>
mQueuedSeek
.
RejectIfExists
(
__func__
)
;
SLOG
(
"
Changed
state
to
SEEKING
(
to
%
lld
)
"
aTarget
.
GetTime
(
)
.
ToMicroseconds
(
)
)
;
SeekJob
seekJob
;
seekJob
.
mTarget
=
aTarget
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
p
=
seekJob
.
mPromise
.
Ensure
(
__func__
)
;
mMaster
-
>
InitiateSeek
(
Move
(
seekJob
)
)
;
return
p
.
forget
(
)
;
}
private
:
void
OnSeekTaskResolved
(
const
SeekTaskResolveValue
&
aValue
)
{
mSeekTaskRequest
.
Complete
(
)
;
if
(
aValue
.
mSeekedAudioData
)
{
mMaster
-
>
Push
(
aValue
.
mSeekedAudioData
MediaData
:
:
AUDIO_DATA
)
;
mMaster
-
>
mDecodedAudioEndTime
=
std
:
:
max
(
aValue
.
mSeekedAudioData
-
>
GetEndTime
(
)
mMaster
-
>
mDecodedAudioEndTime
)
;
}
if
(
aValue
.
mSeekedVideoData
)
{
mMaster
-
>
Push
(
aValue
.
mSeekedVideoData
MediaData
:
:
VIDEO_DATA
)
;
mMaster
-
>
mDecodedVideoEndTime
=
std
:
:
max
(
aValue
.
mSeekedVideoData
-
>
GetEndTime
(
)
mMaster
-
>
mDecodedVideoEndTime
)
;
}
if
(
aValue
.
mIsAudioQueueFinished
)
{
mMaster
-
>
AudioQueue
(
)
.
Finish
(
)
;
}
if
(
aValue
.
mIsVideoQueueFinished
)
{
mMaster
-
>
VideoQueue
(
)
.
Finish
(
)
;
}
SeekCompleted
(
)
;
}
void
OnSeekTaskRejected
(
const
SeekTaskRejectValue
&
aValue
)
{
mSeekTaskRequest
.
Complete
(
)
;
if
(
aValue
.
mIsAudioQueueFinished
)
{
mMaster
-
>
AudioQueue
(
)
.
Finish
(
)
;
}
if
(
aValue
.
mIsVideoQueueFinished
)
{
mMaster
-
>
VideoQueue
(
)
.
Finish
(
)
;
}
mMaster
-
>
DecodeError
(
aValue
.
mError
)
;
}
void
SeekCompleted
(
)
{
int64_t
seekTime
=
mSeekTask
-
>
GetSeekTarget
(
)
.
GetTime
(
)
.
ToMicroseconds
(
)
;
int64_t
newCurrentTime
=
seekTime
;
RefPtr
<
MediaData
>
video
=
mMaster
-
>
VideoQueue
(
)
.
PeekFront
(
)
;
if
(
seekTime
=
=
mMaster
-
>
Duration
(
)
.
ToMicroseconds
(
)
)
{
newCurrentTime
=
seekTime
;
}
else
if
(
mMaster
-
>
HasAudio
(
)
)
{
RefPtr
<
MediaData
>
audio
=
mMaster
-
>
AudioQueue
(
)
.
PeekFront
(
)
;
int64_t
audioStart
=
audio
?
audio
-
>
mTime
:
seekTime
;
if
(
video
&
&
video
-
>
mTime
<
=
seekTime
&
&
video
-
>
GetEndTime
(
)
>
seekTime
)
{
newCurrentTime
=
std
:
:
min
(
audioStart
video
-
>
mTime
)
;
}
else
{
newCurrentTime
=
audioStart
;
}
}
else
{
newCurrentTime
=
video
?
video
-
>
mTime
:
seekTime
;
}
bool
isLiveStream
=
Resource
(
)
-
>
IsLiveStream
(
)
;
State
nextState
;
if
(
newCurrentTime
=
=
mMaster
-
>
Duration
(
)
.
ToMicroseconds
(
)
&
&
!
isLiveStream
)
{
nextState
=
DECODER_STATE_COMPLETED
;
}
else
{
nextState
=
DECODER_STATE_DECODING
;
}
mMaster
-
>
mCurrentSeek
.
Resolve
(
nextState
=
=
DECODER_STATE_COMPLETED
__func__
)
;
if
(
!
mMaster
-
>
mSentFirstFrameLoadedEvent
)
{
MOZ_ASSERT
(
Reader
(
)
-
>
ForceZeroStartTime
(
)
)
;
mMaster
-
>
FinishDecodeFirstFrame
(
)
;
}
mMaster
-
>
UpdatePlaybackPositionInternal
(
newCurrentTime
)
;
SLOG
(
"
Seek
completed
mCurrentPosition
=
%
lld
"
mMaster
-
>
mCurrentPosition
.
Ref
(
)
)
;
if
(
video
)
{
mMaster
-
>
mMediaSink
-
>
Redraw
(
mMaster
-
>
mInfo
.
mVideo
)
;
mMaster
-
>
mOnPlaybackEvent
.
Notify
(
MediaEventType
:
:
Invalidate
)
;
}
SetState
(
nextState
)
;
}
SeekJob
mSeekJob
;
MozPromiseRequestHolder
<
SeekTask
:
:
SeekTaskPromise
>
mSeekTaskRequest
;
RefPtr
<
SeekTask
>
mSeekTask
;
}
;
class
MediaDecoderStateMachine
:
:
BufferingState
:
public
MediaDecoderStateMachine
:
:
StateObject
{
public
:
explicit
BufferingState
(
Master
*
aPtr
)
:
StateObject
(
aPtr
)
{
}
void
Enter
(
)
override
{
if
(
mMaster
-
>
IsPlaying
(
)
)
{
mMaster
-
>
StopPlayback
(
)
;
}
mBufferingStart
=
TimeStamp
:
:
Now
(
)
;
MediaStatistics
stats
=
mMaster
-
>
GetStatistics
(
)
;
SLOG
(
"
Playback
rate
:
%
.
1lfKB
/
s
%
s
download
rate
:
%
.
1lfKB
/
s
%
s
"
stats
.
mPlaybackRate
/
1024
stats
.
mPlaybackRateReliable
?
"
"
:
"
(
unreliable
)
"
stats
.
mDownloadRate
/
1024
stats
.
mDownloadRateReliable
?
"
"
:
"
(
unreliable
)
"
)
;
mMaster
-
>
ScheduleStateMachineIn
(
USECS_PER_S
)
;
}
void
Step
(
)
override
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
MOZ_ASSERT
(
!
mBufferingStart
.
IsNull
(
)
"
Must
know
buffering
start
time
.
"
)
;
if
(
Reader
(
)
-
>
UseBufferingHeuristics
(
)
)
{
TimeDuration
elapsed
=
now
-
mBufferingStart
;
bool
isLiveStream
=
Resource
(
)
-
>
IsLiveStream
(
)
;
if
(
(
isLiveStream
|
|
!
mMaster
-
>
CanPlayThrough
(
)
)
&
&
elapsed
<
TimeDuration
:
:
FromSeconds
(
mMaster
-
>
mBufferingWait
*
mMaster
-
>
mPlaybackRate
)
&
&
mMaster
-
>
HasLowBufferedData
(
mMaster
-
>
mBufferingWait
*
USECS_PER_S
)
&
&
Resource
(
)
-
>
IsExpectingMoreData
(
)
)
{
SLOG
(
"
Buffering
:
wait
%
ds
timeout
in
%
.
3lfs
"
mMaster
-
>
mBufferingWait
mMaster
-
>
mBufferingWait
-
elapsed
.
ToSeconds
(
)
)
;
mMaster
-
>
ScheduleStateMachineIn
(
USECS_PER_S
)
;
return
;
}
}
else
if
(
mMaster
-
>
OutOfDecodedAudio
(
)
|
|
mMaster
-
>
OutOfDecodedVideo
(
)
)
{
MOZ_ASSERT
(
Reader
(
)
-
>
IsWaitForDataSupported
(
)
"
Don
'
t
yet
have
a
strategy
for
non
-
heuristic
+
non
-
WaitForData
"
)
;
mMaster
-
>
DispatchDecodeTasksIfNeeded
(
)
;
MOZ_ASSERT
(
mMaster
-
>
mMinimizePreroll
|
|
!
mMaster
-
>
OutOfDecodedAudio
(
)
|
|
Reader
(
)
-
>
IsRequestingAudioData
(
)
|
|
Reader
(
)
-
>
IsWaitingAudioData
(
)
)
;
MOZ_ASSERT
(
mMaster
-
>
mMinimizePreroll
|
|
!
mMaster
-
>
OutOfDecodedVideo
(
)
|
|
Reader
(
)
-
>
IsRequestingVideoData
(
)
|
|
Reader
(
)
-
>
IsWaitingVideoData
(
)
)
;
SLOG
(
"
In
buffering
mode
waiting
to
be
notified
:
outOfAudio
:
%
d
"
"
mAudioStatus
:
%
s
outOfVideo
:
%
d
mVideoStatus
:
%
s
"
mMaster
-
>
OutOfDecodedAudio
(
)
mMaster
-
>
AudioRequestStatus
(
)
mMaster
-
>
OutOfDecodedVideo
(
)
mMaster
-
>
VideoRequestStatus
(
)
)
;
return
;
}
SLOG
(
"
Buffered
for
%
.
3lfs
"
(
now
-
mBufferingStart
)
.
ToSeconds
(
)
)
;
SetState
(
DECODER_STATE_DECODING
)
;
}
State
GetState
(
)
const
override
{
return
DECODER_STATE_BUFFERING
;
}
bool
HandleAudioDecoded
(
MediaData
*
aAudio
)
override
{
mMaster
-
>
Push
(
aAudio
MediaData
:
:
AUDIO_DATA
)
;
mMaster
-
>
ScheduleStateMachine
(
)
;
return
true
;
}
bool
HandleVideoDecoded
(
MediaData
*
aVideo
TimeStamp
aDecodeStart
)
override
{
mMaster
-
>
Push
(
aVideo
MediaData
:
:
VIDEO_DATA
)
;
mMaster
-
>
ScheduleStateMachine
(
)
;
return
true
;
}
bool
HandleEndOfStream
(
)
override
{
if
(
mMaster
-
>
CheckIfDecodeComplete
(
)
)
{
SetState
(
DECODER_STATE_COMPLETED
)
;
}
else
{
mMaster
-
>
ScheduleStateMachine
(
)
;
}
return
true
;
}
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
HandleSeek
(
SeekTarget
aTarget
)
override
{
mMaster
-
>
mQueuedSeek
.
RejectIfExists
(
__func__
)
;
SLOG
(
"
Changed
state
to
SEEKING
(
to
%
lld
)
"
aTarget
.
GetTime
(
)
.
ToMicroseconds
(
)
)
;
SeekJob
seekJob
;
seekJob
.
mTarget
=
aTarget
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
p
=
seekJob
.
mPromise
.
Ensure
(
__func__
)
;
mMaster
-
>
InitiateSeek
(
Move
(
seekJob
)
)
;
return
p
.
forget
(
)
;
}
private
:
TimeStamp
mBufferingStart
;
}
;
class
MediaDecoderStateMachine
:
:
CompletedState
:
public
MediaDecoderStateMachine
:
:
StateObject
{
public
:
explicit
CompletedState
(
Master
*
aPtr
)
:
StateObject
(
aPtr
)
{
}
void
Enter
(
)
override
{
mMaster
-
>
ScheduleStateMachine
(
)
;
}
void
Exit
(
)
override
{
mSentPlaybackEndedEvent
=
false
;
}
void
Step
(
)
override
{
if
(
mMaster
-
>
mPlayState
!
=
MediaDecoder
:
:
PLAY_STATE_PLAYING
&
&
mMaster
-
>
IsPlaying
(
)
)
{
mMaster
-
>
StopPlayback
(
)
;
}
if
(
(
mMaster
-
>
HasVideo
(
)
&
&
!
mMaster
-
>
mVideoCompleted
)
|
|
(
mMaster
-
>
HasAudio
(
)
&
&
!
mMaster
-
>
mAudioCompleted
)
)
{
mMaster
-
>
MaybeStartPlayback
(
)
;
mMaster
-
>
UpdatePlaybackPositionPeriodically
(
)
;
MOZ_ASSERT
(
!
mMaster
-
>
IsPlaying
(
)
|
|
mMaster
-
>
IsStateMachineScheduled
(
)
"
Must
have
timer
scheduled
"
)
;
return
;
}
mMaster
-
>
StopPlayback
(
)
;
if
(
mMaster
-
>
mPlayState
=
=
MediaDecoder
:
:
PLAY_STATE_PLAYING
&
&
!
mSentPlaybackEndedEvent
)
{
int64_t
clockTime
=
std
:
:
max
(
mMaster
-
>
AudioEndTime
(
)
mMaster
-
>
VideoEndTime
(
)
)
;
clockTime
=
std
:
:
max
(
int64_t
(
0
)
std
:
:
max
(
clockTime
mMaster
-
>
Duration
(
)
.
ToMicroseconds
(
)
)
)
;
mMaster
-
>
UpdatePlaybackPosition
(
clockTime
)
;
mMaster
-
>
UpdateNextFrameStatus
(
)
;
mMaster
-
>
mOnPlaybackEvent
.
Notify
(
MediaEventType
:
:
PlaybackEnded
)
;
mSentPlaybackEndedEvent
=
true
;
mMaster
-
>
StopMediaSink
(
)
;
}
}
State
GetState
(
)
const
override
{
return
DECODER_STATE_COMPLETED
;
}
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
HandleSeek
(
SeekTarget
aTarget
)
override
{
mMaster
-
>
mQueuedSeek
.
RejectIfExists
(
__func__
)
;
SLOG
(
"
Changed
state
to
SEEKING
(
to
%
lld
)
"
aTarget
.
GetTime
(
)
.
ToMicroseconds
(
)
)
;
SeekJob
seekJob
;
seekJob
.
mTarget
=
aTarget
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
p
=
seekJob
.
mPromise
.
Ensure
(
__func__
)
;
mMaster
-
>
InitiateSeek
(
Move
(
seekJob
)
)
;
return
p
.
forget
(
)
;
}
private
:
bool
mSentPlaybackEndedEvent
=
false
;
}
;
class
MediaDecoderStateMachine
:
:
ShutdownState
:
public
MediaDecoderStateMachine
:
:
StateObject
{
public
:
explicit
ShutdownState
(
Master
*
aPtr
)
:
StateObject
(
aPtr
)
{
}
void
Enter
(
)
override
{
mMaster
-
>
mIsShutdown
=
true
;
}
void
Exit
(
)
override
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
Shouldn
'
t
escape
the
SHUTDOWN
state
.
"
)
;
}
State
GetState
(
)
const
override
{
return
DECODER_STATE_SHUTDOWN
;
}
bool
HandleDormant
(
bool
aDormant
)
override
{
return
true
;
}
}
;
#
define
INIT_WATCHABLE
(
name
val
)
\
name
(
val
"
MediaDecoderStateMachine
:
:
"
#
name
)
#
define
INIT_MIRROR
(
name
val
)
\
name
(
mTaskQueue
val
"
MediaDecoderStateMachine
:
:
"
#
name
"
(
Mirror
)
"
)
#
define
INIT_CANONICAL
(
name
val
)
\
name
(
mTaskQueue
val
"
MediaDecoderStateMachine
:
:
"
#
name
"
(
Canonical
)
"
)
MediaDecoderStateMachine
:
:
MediaDecoderStateMachine
(
MediaDecoder
*
aDecoder
MediaDecoderReader
*
aReader
)
:
mDecoderID
(
aDecoder
)
mFrameStats
(
&
aDecoder
-
>
GetFrameStatistics
(
)
)
mVideoFrameContainer
(
aDecoder
-
>
GetVideoFrameContainer
(
)
)
mAudioChannel
(
aDecoder
-
>
GetAudioChannel
(
)
)
mTaskQueue
(
new
TaskQueue
(
GetMediaThreadPool
(
MediaThreadType
:
:
PLAYBACK
)
true
)
)
mWatchManager
(
this
mTaskQueue
)
mDispatchedStateMachine
(
false
)
mDelayedScheduler
(
mTaskQueue
)
INIT_WATCHABLE
(
mState
DECODER_STATE_DECODING_METADATA
)
mStateObj
(
new
DecodeMetadataState
(
this
)
)
mCurrentFrameID
(
0
)
INIT_WATCHABLE
(
mObservedDuration
TimeUnit
(
)
)
mFragmentEndTime
(
-
1
)
mReader
(
new
MediaDecoderReaderWrapper
(
mTaskQueue
aReader
)
)
mDecodedAudioEndTime
(
0
)
mDecodedVideoEndTime
(
0
)
mPlaybackRate
(
1
.
0
)
mLowAudioThresholdUsecs
(
detail
:
:
LOW_AUDIO_USECS
)
mAmpleAudioThresholdUsecs
(
detail
:
:
AMPLE_AUDIO_USECS
)
mAudioCaptured
(
false
)
INIT_WATCHABLE
(
mAudioCompleted
false
)
INIT_WATCHABLE
(
mVideoCompleted
false
)
mNotifyMetadataBeforeFirstFrame
(
false
)
mMinimizePreroll
(
false
)
mDecodeThreadWaiting
(
false
)
mSentLoadedMetadataEvent
(
false
)
mSentFirstFrameLoadedEvent
(
false
)
mVideoDecodeSuspended
(
false
)
mVideoDecodeSuspendTimer
(
mTaskQueue
)
mOutputStreamManager
(
new
OutputStreamManager
(
)
)
mResource
(
aDecoder
-
>
GetResource
(
)
)
mAudioOffloading
(
false
)
INIT_MIRROR
(
mBuffered
TimeIntervals
(
)
)
INIT_MIRROR
(
mIsReaderSuspended
true
)
INIT_MIRROR
(
mEstimatedDuration
NullableTimeUnit
(
)
)
INIT_MIRROR
(
mExplicitDuration
Maybe
<
double
>
(
)
)
INIT_MIRROR
(
mPlayState
MediaDecoder
:
:
PLAY_STATE_LOADING
)
INIT_MIRROR
(
mNextPlayState
MediaDecoder
:
:
PLAY_STATE_PAUSED
)
INIT_MIRROR
(
mVolume
1
.
0
)
INIT_MIRROR
(
mPreservesPitch
true
)
INIT_MIRROR
(
mSameOriginMedia
false
)
INIT_MIRROR
(
mMediaPrincipalHandle
PRINCIPAL_HANDLE_NONE
)
INIT_MIRROR
(
mPlaybackBytesPerSecond
0
.
0
)
INIT_MIRROR
(
mPlaybackRateReliable
true
)
INIT_MIRROR
(
mDecoderPosition
0
)
INIT_MIRROR
(
mMediaSeekable
true
)
INIT_MIRROR
(
mMediaSeekableOnlyInBufferedRanges
false
)
INIT_MIRROR
(
mIsVisible
true
)
INIT_CANONICAL
(
mDuration
NullableTimeUnit
(
)
)
INIT_CANONICAL
(
mIsShutdown
false
)
INIT_CANONICAL
(
mNextFrameStatus
MediaDecoderOwner
:
:
NEXT_FRAME_UNINITIALIZED
)
INIT_CANONICAL
(
mCurrentPosition
0
)
INIT_CANONICAL
(
mPlaybackOffset
0
)
INIT_CANONICAL
(
mIsAudioDataAudible
false
)
{
MOZ_COUNT_CTOR
(
MediaDecoderStateMachine
)
;
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
main
thread
.
"
)
;
InitVideoQueuePrefs
(
)
;
mBufferingWait
=
15
;
mLowDataThresholdUsecs
=
detail
:
:
LOW_DATA_THRESHOLD_USECS
;
#
ifdef
XP_WIN
timeBeginPeriod
(
1
)
;
#
endif
}
#
undef
INIT_WATCHABLE
#
undef
INIT_MIRROR
#
undef
INIT_CANONICAL
MediaDecoderStateMachine
:
:
~
MediaDecoderStateMachine
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Should
be
on
main
thread
.
"
)
;
MOZ_COUNT_DTOR
(
MediaDecoderStateMachine
)
;
#
ifdef
XP_WIN
timeEndPeriod
(
1
)
;
#
endif
}
void
MediaDecoderStateMachine
:
:
InitializationTask
(
MediaDecoder
*
aDecoder
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mBuffered
.
Connect
(
mReader
-
>
CanonicalBuffered
(
)
)
;
mIsReaderSuspended
.
Connect
(
mReader
-
>
CanonicalIsSuspended
(
)
)
;
mEstimatedDuration
.
Connect
(
aDecoder
-
>
CanonicalEstimatedDuration
(
)
)
;
mExplicitDuration
.
Connect
(
aDecoder
-
>
CanonicalExplicitDuration
(
)
)
;
mPlayState
.
Connect
(
aDecoder
-
>
CanonicalPlayState
(
)
)
;
mNextPlayState
.
Connect
(
aDecoder
-
>
CanonicalNextPlayState
(
)
)
;
mVolume
.
Connect
(
aDecoder
-
>
CanonicalVolume
(
)
)
;
mPreservesPitch
.
Connect
(
aDecoder
-
>
CanonicalPreservesPitch
(
)
)
;
mSameOriginMedia
.
Connect
(
aDecoder
-
>
CanonicalSameOriginMedia
(
)
)
;
mMediaPrincipalHandle
.
Connect
(
aDecoder
-
>
CanonicalMediaPrincipalHandle
(
)
)
;
mPlaybackBytesPerSecond
.
Connect
(
aDecoder
-
>
CanonicalPlaybackBytesPerSecond
(
)
)
;
mPlaybackRateReliable
.
Connect
(
aDecoder
-
>
CanonicalPlaybackRateReliable
(
)
)
;
mDecoderPosition
.
Connect
(
aDecoder
-
>
CanonicalDecoderPosition
(
)
)
;
mMediaSeekable
.
Connect
(
aDecoder
-
>
CanonicalMediaSeekable
(
)
)
;
mMediaSeekableOnlyInBufferedRanges
.
Connect
(
aDecoder
-
>
CanonicalMediaSeekableOnlyInBufferedRanges
(
)
)
;
mWatchManager
.
Watch
(
mBuffered
&
MediaDecoderStateMachine
:
:
BufferedRangeUpdated
)
;
mWatchManager
.
Watch
(
mIsReaderSuspended
&
MediaDecoderStateMachine
:
:
ReaderSuspendedChanged
)
;
mWatchManager
.
Watch
(
mState
&
MediaDecoderStateMachine
:
:
UpdateNextFrameStatus
)
;
mWatchManager
.
Watch
(
mAudioCompleted
&
MediaDecoderStateMachine
:
:
UpdateNextFrameStatus
)
;
mWatchManager
.
Watch
(
mVideoCompleted
&
MediaDecoderStateMachine
:
:
UpdateNextFrameStatus
)
;
mWatchManager
.
Watch
(
mVolume
&
MediaDecoderStateMachine
:
:
VolumeChanged
)
;
mWatchManager
.
Watch
(
mPreservesPitch
&
MediaDecoderStateMachine
:
:
PreservesPitchChanged
)
;
mWatchManager
.
Watch
(
mEstimatedDuration
&
MediaDecoderStateMachine
:
:
RecomputeDuration
)
;
mWatchManager
.
Watch
(
mExplicitDuration
&
MediaDecoderStateMachine
:
:
RecomputeDuration
)
;
mWatchManager
.
Watch
(
mObservedDuration
&
MediaDecoderStateMachine
:
:
RecomputeDuration
)
;
mWatchManager
.
Watch
(
mPlayState
&
MediaDecoderStateMachine
:
:
PlayStateChanged
)
;
if
(
MediaPrefs
:
:
MDSMSuspendBackgroundVideoEnabled
(
)
)
{
mIsVisible
.
Connect
(
aDecoder
-
>
CanonicalIsVisible
(
)
)
;
mWatchManager
.
Watch
(
mIsVisible
&
MediaDecoderStateMachine
:
:
VisibilityChanged
)
;
}
SetMediaDecoderReaderWrapperCallback
(
)
;
}
void
MediaDecoderStateMachine
:
:
AudioAudibleChanged
(
bool
aAudible
)
{
mIsAudioDataAudible
=
aAudible
;
}
media
:
:
MediaSink
*
MediaDecoderStateMachine
:
:
CreateAudioSink
(
)
{
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
auto
audioSinkCreator
=
[
self
]
(
)
{
MOZ_ASSERT
(
self
-
>
OnTaskQueue
(
)
)
;
DecodedAudioDataSink
*
audioSink
=
new
DecodedAudioDataSink
(
self
-
>
mTaskQueue
self
-
>
mAudioQueue
self
-
>
GetMediaTime
(
)
self
-
>
mInfo
.
mAudio
self
-
>
mAudioChannel
)
;
self
-
>
mAudibleListener
=
audioSink
-
>
AudibleEvent
(
)
.
Connect
(
self
-
>
mTaskQueue
self
.
get
(
)
&
MediaDecoderStateMachine
:
:
AudioAudibleChanged
)
;
return
audioSink
;
}
;
return
new
AudioSinkWrapper
(
mTaskQueue
audioSinkCreator
)
;
}
already_AddRefed
<
media
:
:
MediaSink
>
MediaDecoderStateMachine
:
:
CreateMediaSink
(
bool
aAudioCaptured
)
{
RefPtr
<
media
:
:
MediaSink
>
audioSink
=
aAudioCaptured
?
new
DecodedStream
(
mTaskQueue
mAudioQueue
mVideoQueue
mOutputStreamManager
mSameOriginMedia
.
Ref
(
)
mMediaPrincipalHandle
.
Ref
(
)
)
:
CreateAudioSink
(
)
;
RefPtr
<
media
:
:
MediaSink
>
mediaSink
=
new
VideoSink
(
mTaskQueue
audioSink
mVideoQueue
mVideoFrameContainer
*
mFrameStats
sVideoQueueSendToCompositorSize
)
;
return
mediaSink
.
forget
(
)
;
}
bool
MediaDecoderStateMachine
:
:
HasFutureAudio
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
NS_ASSERTION
(
HasAudio
(
)
"
Should
only
call
HasFutureAudio
(
)
when
we
have
audio
"
)
;
return
!
mAudioCompleted
&
&
(
GetDecodedAudioDuration
(
)
>
mLowAudioThresholdUsecs
*
mPlaybackRate
|
|
AudioQueue
(
)
.
IsFinished
(
)
)
;
}
bool
MediaDecoderStateMachine
:
:
HaveNextFrameData
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
(
!
HasAudio
(
)
|
|
HasFutureAudio
(
)
)
&
&
(
!
HasVideo
(
)
|
|
VideoQueue
(
)
.
GetSize
(
)
>
1
)
;
}
int64_t
MediaDecoderStateMachine
:
:
GetDecodedAudioDuration
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mMediaSink
-
>
IsStarted
(
)
)
{
return
std
:
:
max
<
int64_t
>
(
mDecodedAudioEndTime
-
GetClock
(
)
0
)
;
}
return
AudioQueue
(
)
.
Duration
(
)
;
}
bool
MediaDecoderStateMachine
:
:
HaveEnoughDecodedAudio
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
int64_t
ampleAudioUSecs
=
mAmpleAudioThresholdUsecs
*
mPlaybackRate
;
if
(
AudioQueue
(
)
.
GetSize
(
)
=
=
0
|
|
GetDecodedAudioDuration
(
)
<
ampleAudioUSecs
)
{
return
false
;
}
return
true
;
}
bool
MediaDecoderStateMachine
:
:
HaveEnoughDecodedVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
VideoQueue
(
)
.
GetSize
(
)
=
=
0
)
{
return
false
;
}
if
(
VideoQueue
(
)
.
GetSize
(
)
-
1
<
GetAmpleVideoFrames
(
)
*
mPlaybackRate
)
{
return
false
;
}
return
true
;
}
bool
MediaDecoderStateMachine
:
:
NeedToDecodeVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
SAMPLE_LOG
(
"
NeedToDecodeVideo
(
)
isDec
=
%
d
minPrl
=
%
d
enufVid
=
%
d
"
IsVideoDecoding
(
)
mMinimizePreroll
HaveEnoughDecodedVideo
(
)
)
;
return
IsVideoDecoding
(
)
&
&
mState
!
=
DECODER_STATE_SEEKING
&
&
(
(
!
mSentFirstFrameLoadedEvent
&
&
VideoQueue
(
)
.
GetSize
(
)
=
=
0
)
|
|
(
!
mMinimizePreroll
&
&
!
HaveEnoughDecodedVideo
(
)
)
)
;
}
bool
MediaDecoderStateMachine
:
:
NeedToSkipToNextKeyframe
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
!
mSentFirstFrameLoadedEvent
)
{
return
false
;
}
MOZ_ASSERT
(
mState
=
=
DECODER_STATE_DECODING
|
|
mState
=
=
DECODER_STATE_BUFFERING
|
|
mState
=
=
DECODER_STATE_SEEKING
)
;
if
(
!
mMediaSink
-
>
IsStarted
(
)
)
{
return
false
;
}
if
(
!
IsVideoDecoding
(
)
|
|
mState
=
=
DECODER_STATE_BUFFERING
|
|
mState
=
=
DECODER_STATE_SEEKING
)
{
return
false
;
}
if
(
mAudioCaptured
&
&
!
HasAudio
(
)
)
{
return
false
;
}
bool
isLowOnDecodedAudio
=
!
mReader
-
>
IsAsync
(
)
&
&
IsAudioDecoding
(
)
&
&
(
GetDecodedAudioDuration
(
)
<
mLowAudioThresholdUsecs
*
mPlaybackRate
)
;
bool
isLowOnDecodedVideo
=
(
GetClock
(
)
-
mDecodedVideoEndTime
)
*
mPlaybackRate
>
LOW_VIDEO_THRESHOLD_USECS
;
bool
lowBuffered
=
HasLowBufferedData
(
)
;
if
(
(
isLowOnDecodedAudio
|
|
isLowOnDecodedVideo
)
&
&
!
lowBuffered
)
{
DECODER_LOG
(
"
Skipping
video
decode
to
the
next
keyframe
lowAudio
=
%
d
lowVideo
=
%
d
lowUndecoded
=
%
d
async
=
%
d
"
isLowOnDecodedAudio
isLowOnDecodedVideo
lowBuffered
mReader
-
>
IsAsync
(
)
)
;
return
true
;
}
return
false
;
}
bool
MediaDecoderStateMachine
:
:
NeedToDecodeAudio
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
SAMPLE_LOG
(
"
NeedToDecodeAudio
(
)
isDec
=
%
d
minPrl
=
%
d
enufAud
=
%
d
"
IsAudioDecoding
(
)
mMinimizePreroll
HaveEnoughDecodedAudio
(
)
)
;
return
IsAudioDecoding
(
)
&
&
mState
!
=
DECODER_STATE_SEEKING
&
&
(
(
!
mSentFirstFrameLoadedEvent
&
&
AudioQueue
(
)
.
GetSize
(
)
=
=
0
)
|
|
(
!
mMinimizePreroll
&
&
!
HaveEnoughDecodedAudio
(
)
)
)
;
}
void
MediaDecoderStateMachine
:
:
OnAudioDecoded
(
MediaData
*
aAudio
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
aAudio
)
;
mDecodedAudioEndTime
=
std
:
:
max
(
aAudio
-
>
GetEndTime
(
)
mDecodedAudioEndTime
)
;
SAMPLE_LOG
(
"
OnAudioDecoded
[
%
lld
%
lld
]
"
aAudio
-
>
mTime
aAudio
-
>
GetEndTime
(
)
)
;
mStateObj
-
>
HandleAudioDecoded
(
aAudio
)
;
}
void
MediaDecoderStateMachine
:
:
Push
(
MediaData
*
aSample
MediaData
:
:
Type
aSampleType
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
aSample
)
;
if
(
aSample
-
>
mType
=
=
MediaData
:
:
AUDIO_DATA
)
{
AudioQueue
(
)
.
Push
(
aSample
)
;
}
else
if
(
aSample
-
>
mType
=
=
MediaData
:
:
VIDEO_DATA
)
{
aSample
-
>
As
<
VideoData
>
(
)
-
>
mFrameID
=
+
+
mCurrentFrameID
;
VideoQueue
(
)
.
Push
(
aSample
)
;
}
else
{
}
UpdateNextFrameStatus
(
)
;
DispatchDecodeTasksIfNeeded
(
)
;
}
void
MediaDecoderStateMachine
:
:
OnAudioPopped
(
const
RefPtr
<
MediaData
>
&
aSample
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mPlaybackOffset
=
std
:
:
max
(
mPlaybackOffset
.
Ref
(
)
aSample
-
>
mOffset
)
;
UpdateNextFrameStatus
(
)
;
DispatchAudioDecodeTaskIfNeeded
(
)
;
}
void
MediaDecoderStateMachine
:
:
OnVideoPopped
(
const
RefPtr
<
MediaData
>
&
aSample
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mPlaybackOffset
=
std
:
:
max
(
mPlaybackOffset
.
Ref
(
)
aSample
-
>
mOffset
)
;
UpdateNextFrameStatus
(
)
;
DispatchVideoDecodeTaskIfNeeded
(
)
;
}
void
MediaDecoderStateMachine
:
:
OnNotDecoded
(
MediaData
:
:
Type
aType
const
MediaResult
&
aError
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mState
!
=
DECODER_STATE_SEEKING
)
;
SAMPLE_LOG
(
"
OnNotDecoded
(
aType
=
%
u
aError
=
%
u
)
"
aType
aError
.
Code
(
)
)
;
bool
isAudio
=
aType
=
=
MediaData
:
:
AUDIO_DATA
;
MOZ_ASSERT_IF
(
!
isAudio
aType
=
=
MediaData
:
:
VIDEO_DATA
)
;
if
(
IsShutdown
(
)
)
{
return
;
}
if
(
aError
=
=
NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA
)
{
MOZ_ASSERT
(
mReader
-
>
IsWaitForDataSupported
(
)
"
Readers
that
send
WAITING_FOR_DATA
need
to
implement
WaitForData
"
)
;
mReader
-
>
WaitForData
(
aType
)
;
MaybeStopPrerolling
(
)
;
return
;
}
if
(
aError
=
=
NS_ERROR_DOM_MEDIA_CANCELED
)
{
if
(
isAudio
)
{
EnsureAudioDecodeTaskQueued
(
)
;
}
else
{
EnsureVideoDecodeTaskQueued
(
)
;
}
return
;
}
if
(
aError
!
=
NS_ERROR_DOM_MEDIA_END_OF_STREAM
)
{
DecodeError
(
aError
)
;
return
;
}
if
(
isAudio
)
{
AudioQueue
(
)
.
Finish
(
)
;
}
else
{
VideoQueue
(
)
.
Finish
(
)
;
}
MaybeStopPrerolling
(
)
;
mStateObj
-
>
HandleEndOfStream
(
)
;
}
void
MediaDecoderStateMachine
:
:
OnVideoDecoded
(
MediaData
*
aVideo
TimeStamp
aDecodeStartTime
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
aVideo
)
;
mDecodedVideoEndTime
=
std
:
:
max
(
mDecodedVideoEndTime
aVideo
-
>
GetEndTime
(
)
)
;
SAMPLE_LOG
(
"
OnVideoDecoded
[
%
lld
%
lld
]
"
aVideo
-
>
mTime
aVideo
-
>
GetEndTime
(
)
)
;
mStateObj
-
>
HandleVideoDecoded
(
aVideo
aDecodeStartTime
)
;
}
bool
MediaDecoderStateMachine
:
:
IsAudioDecoding
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
HasAudio
(
)
&
&
!
AudioQueue
(
)
.
IsFinished
(
)
;
}
bool
MediaDecoderStateMachine
:
:
IsVideoDecoding
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
HasVideo
(
)
&
&
!
VideoQueue
(
)
.
IsFinished
(
)
;
}
bool
MediaDecoderStateMachine
:
:
CheckIfDecodeComplete
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mSentFirstFrameLoadedEvent
)
;
MOZ_ASSERT
(
mState
=
=
DECODER_STATE_DECODING
|
|
mState
=
=
DECODER_STATE_BUFFERING
)
;
return
!
IsVideoDecoding
(
)
&
&
!
IsAudioDecoding
(
)
;
}
bool
MediaDecoderStateMachine
:
:
IsPlaying
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mMediaSink
-
>
IsPlaying
(
)
;
}
nsresult
MediaDecoderStateMachine
:
:
Init
(
MediaDecoder
*
aDecoder
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NewRunnableMethod
<
RefPtr
<
MediaDecoder
>
>
(
this
&
MediaDecoderStateMachine
:
:
InitializationTask
aDecoder
)
;
mTaskQueue
-
>
Dispatch
(
r
.
forget
(
)
)
;
mAudioQueueListener
=
AudioQueue
(
)
.
PopEvent
(
)
.
Connect
(
mTaskQueue
this
&
MediaDecoderStateMachine
:
:
OnAudioPopped
)
;
mVideoQueueListener
=
VideoQueue
(
)
.
PopEvent
(
)
.
Connect
(
mTaskQueue
this
&
MediaDecoderStateMachine
:
:
OnVideoPopped
)
;
mMetadataManager
.
Connect
(
mReader
-
>
TimedMetadataEvent
(
)
OwnerThread
(
)
)
;
mMediaSink
=
CreateMediaSink
(
mAudioCaptured
)
;
mCDMProxyPromise
.
Begin
(
aDecoder
-
>
RequestCDMProxy
(
)
-
>
Then
(
OwnerThread
(
)
__func__
this
&
MediaDecoderStateMachine
:
:
OnCDMProxyReady
&
MediaDecoderStateMachine
:
:
OnCDMProxyNotReady
)
)
;
nsresult
rv
=
mReader
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
OwnerThread
(
)
-
>
Dispatch
(
NS_NewRunnableFunction
(
[
self
]
(
)
{
self
-
>
mStateObj
-
>
Enter
(
)
;
}
)
)
;
return
NS_OK
;
}
void
MediaDecoderStateMachine
:
:
SetMediaDecoderReaderWrapperCallback
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mAudioCallback
=
mReader
-
>
AudioCallback
(
)
.
Connect
(
mTaskQueue
[
this
]
(
AudioCallbackData
aData
)
{
if
(
aData
.
is
<
MediaData
*
>
(
)
)
{
OnAudioDecoded
(
aData
.
as
<
MediaData
*
>
(
)
)
;
}
else
{
OnNotDecoded
(
MediaData
:
:
AUDIO_DATA
aData
.
as
<
MediaResult
>
(
)
)
;
}
}
)
;
mVideoCallback
=
mReader
-
>
VideoCallback
(
)
.
Connect
(
mTaskQueue
[
this
]
(
VideoCallbackData
aData
)
{
typedef
Tuple
<
MediaData
*
TimeStamp
>
Type
;
if
(
aData
.
is
<
Type
>
(
)
)
{
auto
&
&
v
=
aData
.
as
<
Type
>
(
)
;
OnVideoDecoded
(
Get
<
0
>
(
v
)
Get
<
1
>
(
v
)
)
;
}
else
{
OnNotDecoded
(
MediaData
:
:
VIDEO_DATA
aData
.
as
<
MediaResult
>
(
)
)
;
}
}
)
;
mAudioWaitCallback
=
mReader
-
>
AudioWaitCallback
(
)
.
Connect
(
mTaskQueue
[
this
]
(
WaitCallbackData
aData
)
{
if
(
aData
.
is
<
MediaData
:
:
Type
>
(
)
)
{
EnsureAudioDecodeTaskQueued
(
)
;
}
}
)
;
mVideoWaitCallback
=
mReader
-
>
VideoWaitCallback
(
)
.
Connect
(
mTaskQueue
[
this
]
(
WaitCallbackData
aData
)
{
if
(
aData
.
is
<
MediaData
:
:
Type
>
(
)
)
{
EnsureVideoDecodeTaskQueued
(
)
;
}
}
)
;
}
void
MediaDecoderStateMachine
:
:
CancelMediaDecoderReaderWrapperCallback
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mAudioCallback
.
Disconnect
(
)
;
mVideoCallback
.
Disconnect
(
)
;
mAudioWaitCallback
.
Disconnect
(
)
;
mVideoWaitCallback
.
Disconnect
(
)
;
}
void
MediaDecoderStateMachine
:
:
StopPlayback
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
DECODER_LOG
(
"
StopPlayback
(
)
"
)
;
mOnPlaybackEvent
.
Notify
(
MediaEventType
:
:
PlaybackStopped
)
;
if
(
IsPlaying
(
)
)
{
mMediaSink
-
>
SetPlaying
(
false
)
;
MOZ_ASSERT
(
!
IsPlaying
(
)
)
;
}
DispatchDecodeTasksIfNeeded
(
)
;
}
void
MediaDecoderStateMachine
:
:
MaybeStopPrerolling
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mIsPrerolling
&
&
(
DonePrerollingAudio
(
)
|
|
mReader
-
>
IsWaitingAudioData
(
)
)
&
&
(
DonePrerollingVideo
(
)
|
|
mReader
-
>
IsWaitingVideoData
(
)
)
)
{
mIsPrerolling
=
false
;
ScheduleStateMachine
(
)
;
}
}
void
MediaDecoderStateMachine
:
:
MaybeStartPlayback
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mSentFirstFrameLoadedEvent
)
;
MOZ_ASSERT
(
mState
=
=
DECODER_STATE_DECODING
|
|
mState
=
=
DECODER_STATE_COMPLETED
)
;
if
(
IsPlaying
(
)
)
{
return
;
}
bool
playStatePermits
=
mPlayState
=
=
MediaDecoder
:
:
PLAY_STATE_PLAYING
;
if
(
!
playStatePermits
|
|
mIsPrerolling
|
|
mAudioOffloading
)
{
DECODER_LOG
(
"
Not
starting
playback
[
playStatePermits
:
%
d
"
"
mIsPrerolling
:
%
d
mAudioOffloading
:
%
d
]
"
playStatePermits
mIsPrerolling
mAudioOffloading
)
;
return
;
}
DECODER_LOG
(
"
MaybeStartPlayback
(
)
starting
playback
"
)
;
mOnPlaybackEvent
.
Notify
(
MediaEventType
:
:
PlaybackStarted
)
;
StartMediaSink
(
)
;
if
(
!
IsPlaying
(
)
)
{
mMediaSink
-
>
SetPlaying
(
true
)
;
MOZ_ASSERT
(
IsPlaying
(
)
)
;
}
DispatchDecodeTasksIfNeeded
(
)
;
}
void
MediaDecoderStateMachine
:
:
MaybeStartBuffering
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mSentFirstFrameLoadedEvent
)
;
MOZ_ASSERT
(
mState
=
=
DECODER_STATE_DECODING
)
;
if
(
mPlayState
!
=
MediaDecoder
:
:
PLAY_STATE_PLAYING
)
{
return
;
}
if
(
!
IsPlaying
(
)
)
{
return
;
}
if
(
!
mResource
-
>
IsExpectingMoreData
(
)
)
{
return
;
}
bool
shouldBuffer
;
if
(
mReader
-
>
UseBufferingHeuristics
(
)
)
{
shouldBuffer
=
HasLowDecodedData
(
)
&
&
HasLowBufferedData
(
)
;
}
else
{
MOZ_ASSERT
(
mReader
-
>
IsWaitForDataSupported
(
)
)
;
shouldBuffer
=
(
OutOfDecodedAudio
(
)
&
&
mReader
-
>
IsWaitingAudioData
(
)
)
|
|
(
OutOfDecodedVideo
(
)
&
&
mReader
-
>
IsWaitingVideoData
(
)
)
;
}
if
(
shouldBuffer
)
{
SetState
(
DECODER_STATE_BUFFERING
)
;
}
}
void
MediaDecoderStateMachine
:
:
UpdatePlaybackPositionInternal
(
int64_t
aTime
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
SAMPLE_LOG
(
"
UpdatePlaybackPositionInternal
(
%
lld
)
"
aTime
)
;
mCurrentPosition
=
aTime
;
NS_ASSERTION
(
mCurrentPosition
>
=
0
"
CurrentTime
should
be
positive
!
"
)
;
mObservedDuration
=
std
:
:
max
(
mObservedDuration
.
Ref
(
)
TimeUnit
:
:
FromMicroseconds
(
mCurrentPosition
.
Ref
(
)
)
)
;
}
void
MediaDecoderStateMachine
:
:
UpdatePlaybackPosition
(
int64_t
aTime
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
UpdatePlaybackPositionInternal
(
aTime
)
;
bool
fragmentEnded
=
mFragmentEndTime
>
=
0
&
&
GetMediaTime
(
)
>
=
mFragmentEndTime
;
mMetadataManager
.
DispatchMetadataIfNeeded
(
TimeUnit
:
:
FromMicroseconds
(
aTime
)
)
;
if
(
fragmentEnded
)
{
StopPlayback
(
)
;
}
}
const
char
*
MediaDecoderStateMachine
:
:
ToStateStr
(
State
aState
)
{
switch
(
aState
)
{
case
DECODER_STATE_DECODING_METADATA
:
return
"
DECODING_METADATA
"
;
case
DECODER_STATE_WAIT_FOR_CDM
:
return
"
WAIT_FOR_CDM
"
;
case
DECODER_STATE_DORMANT
:
return
"
DORMANT
"
;
case
DECODER_STATE_DECODING_FIRSTFRAME
:
return
"
DECODING_FIRSTFRAME
"
;
case
DECODER_STATE_DECODING
:
return
"
DECODING
"
;
case
DECODER_STATE_SEEKING
:
return
"
SEEKING
"
;
case
DECODER_STATE_BUFFERING
:
return
"
BUFFERING
"
;
case
DECODER_STATE_COMPLETED
:
return
"
COMPLETED
"
;
case
DECODER_STATE_SHUTDOWN
:
return
"
SHUTDOWN
"
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
state
.
"
)
;
}
return
"
UNKNOWN
"
;
}
const
char
*
MediaDecoderStateMachine
:
:
ToStateStr
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
ToStateStr
(
mState
)
;
}
void
MediaDecoderStateMachine
:
:
SetState
(
State
aState
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mState
=
=
aState
)
{
return
;
}
DECODER_LOG
(
"
MDSM
state
:
%
s
-
>
%
s
"
ToStateStr
(
)
ToStateStr
(
aState
)
)
;
MOZ_ASSERT
(
mState
=
=
mStateObj
-
>
GetState
(
)
)
;
mStateObj
-
>
Exit
(
)
;
mState
=
aState
;
switch
(
mState
)
{
case
DECODER_STATE_DECODING_METADATA
:
mStateObj
=
MakeUnique
<
DecodeMetadataState
>
(
this
)
;
break
;
case
DECODER_STATE_WAIT_FOR_CDM
:
mStateObj
=
MakeUnique
<
WaitForCDMState
>
(
this
)
;
break
;
case
DECODER_STATE_DORMANT
:
mStateObj
=
MakeUnique
<
DormantState
>
(
this
)
;
break
;
case
DECODER_STATE_DECODING_FIRSTFRAME
:
mStateObj
=
MakeUnique
<
DecodingFirstFrameState
>
(
this
)
;
break
;
case
DECODER_STATE_DECODING
:
mStateObj
=
MakeUnique
<
DecodingState
>
(
this
)
;
break
;
case
DECODER_STATE_BUFFERING
:
mStateObj
=
MakeUnique
<
BufferingState
>
(
this
)
;
break
;
case
DECODER_STATE_COMPLETED
:
mStateObj
=
MakeUnique
<
CompletedState
>
(
this
)
;
break
;
case
DECODER_STATE_SHUTDOWN
:
mStateObj
=
MakeUnique
<
ShutdownState
>
(
this
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
state
.
"
)
;
break
;
}
MOZ_ASSERT
(
mState
=
=
mStateObj
-
>
GetState
(
)
)
;
mStateObj
-
>
Enter
(
)
;
}
void
MediaDecoderStateMachine
:
:
VolumeChanged
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mMediaSink
-
>
SetVolume
(
mVolume
)
;
}
void
MediaDecoderStateMachine
:
:
RecomputeDuration
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
TimeUnit
duration
;
if
(
mExplicitDuration
.
Ref
(
)
.
isSome
(
)
)
{
double
d
=
mExplicitDuration
.
Ref
(
)
.
ref
(
)
;
if
(
IsNaN
(
d
)
)
{
return
;
}
duration
=
TimeUnit
:
:
FromSeconds
(
d
)
;
}
else
if
(
mEstimatedDuration
.
Ref
(
)
.
isSome
(
)
)
{
duration
=
mEstimatedDuration
.
Ref
(
)
.
ref
(
)
;
}
else
if
(
mInfo
.
mMetadataDuration
.
isSome
(
)
)
{
duration
=
mInfo
.
mMetadataDuration
.
ref
(
)
;
}
else
{
return
;
}
if
(
mExplicitDuration
.
Ref
(
)
.
isNothing
(
)
&
&
duration
<
mObservedDuration
.
Ref
(
)
)
{
duration
=
mObservedDuration
;
}
MOZ_ASSERT
(
duration
.
ToMicroseconds
(
)
>
=
0
)
;
mDuration
=
Some
(
duration
)
;
}
void
MediaDecoderStateMachine
:
:
DispatchSetDormant
(
bool
aDormant
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
NewRunnableMethod
<
bool
>
(
this
&
MediaDecoderStateMachine
:
:
SetDormant
aDormant
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
MediaDecoderStateMachine
:
:
SetDormant
(
bool
aDormant
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mStateObj
-
>
HandleDormant
(
aDormant
)
;
}
RefPtr
<
ShutdownPromise
>
MediaDecoderStateMachine
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
SetState
(
DECODER_STATE_SHUTDOWN
)
;
mDelayedScheduler
.
Reset
(
)
;
mBufferedUpdateRequest
.
DisconnectIfExists
(
)
;
mQueuedSeek
.
RejectIfExists
(
__func__
)
;
mVideoDecodeSuspendTimer
.
Reset
(
)
;
mCDMProxyPromise
.
DisconnectIfExists
(
)
;
if
(
IsPlaying
(
)
)
{
StopPlayback
(
)
;
}
CancelMediaDecoderReaderWrapperCallback
(
)
;
Reset
(
)
;
mMediaSink
-
>
Shutdown
(
)
;
mAudioQueueListener
.
Disconnect
(
)
;
mVideoQueueListener
.
Disconnect
(
)
;
mMetadataManager
.
Disconnect
(
)
;
mBuffered
.
DisconnectIfConnected
(
)
;
mIsReaderSuspended
.
DisconnectIfConnected
(
)
;
mEstimatedDuration
.
DisconnectIfConnected
(
)
;
mExplicitDuration
.
DisconnectIfConnected
(
)
;
mPlayState
.
DisconnectIfConnected
(
)
;
mNextPlayState
.
DisconnectIfConnected
(
)
;
mVolume
.
DisconnectIfConnected
(
)
;
mPreservesPitch
.
DisconnectIfConnected
(
)
;
mSameOriginMedia
.
DisconnectIfConnected
(
)
;
mMediaPrincipalHandle
.
DisconnectIfConnected
(
)
;
mPlaybackBytesPerSecond
.
DisconnectIfConnected
(
)
;
mPlaybackRateReliable
.
DisconnectIfConnected
(
)
;
mDecoderPosition
.
DisconnectIfConnected
(
)
;
mMediaSeekable
.
DisconnectIfConnected
(
)
;
mMediaSeekableOnlyInBufferedRanges
.
DisconnectIfConnected
(
)
;
mIsVisible
.
DisconnectIfConnected
(
)
;
mDuration
.
DisconnectAll
(
)
;
mIsShutdown
.
DisconnectAll
(
)
;
mNextFrameStatus
.
DisconnectAll
(
)
;
mCurrentPosition
.
DisconnectAll
(
)
;
mPlaybackOffset
.
DisconnectAll
(
)
;
mIsAudioDataAudible
.
DisconnectAll
(
)
;
mWatchManager
.
Shutdown
(
)
;
DECODER_LOG
(
"
Shutdown
started
"
)
;
return
mReader
-
>
Shutdown
(
)
-
>
Then
(
OwnerThread
(
)
__func__
this
&
MediaDecoderStateMachine
:
:
FinishShutdown
&
MediaDecoderStateMachine
:
:
FinishShutdown
)
-
>
CompletionPromise
(
)
;
}
void
MediaDecoderStateMachine
:
:
PlayStateChanged
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mPlayState
!
=
MediaDecoder
:
:
PLAY_STATE_PLAYING
)
{
mVideoDecodeSuspendTimer
.
Reset
(
)
;
return
;
}
if
(
mMinimizePreroll
)
{
mMinimizePreroll
=
false
;
DispatchDecodeTasksIfNeeded
(
)
;
}
if
(
mState
!
=
DECODER_STATE_DECODING
&
&
mState
!
=
DECODER_STATE_DECODING_FIRSTFRAME
&
&
mState
!
=
DECODER_STATE_BUFFERING
&
&
mState
!
=
DECODER_STATE_COMPLETED
)
{
DECODER_LOG
(
"
Unexpected
state
-
Bailing
out
of
PlayInternal
(
)
"
)
;
return
;
}
ScheduleStateMachine
(
)
;
}
static
void
ReportRecoveryTelemetry
(
const
TimeStamp
&
aRecoveryStart
const
MediaInfo
&
aMediaInfo
bool
aIsHardwareAccelerated
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
aMediaInfo
.
HasVideo
(
)
)
{
return
;
}
nsCString
key
(
aMediaInfo
.
HasAudio
(
)
?
"
AV
"
:
"
V
"
)
;
key
.
AppendASCII
(
aIsHardwareAccelerated
?
"
(
hw
)
"
:
"
"
)
;
static
const
struct
{
int32_t
mH
;
const
char
*
mRes
;
}
sResolutions
[
]
=
{
{
240
"
0
-
240
"
}
{
480
"
241
-
480
"
}
{
720
"
481
-
720
"
}
{
1080
"
721
-
1080
"
}
{
2160
"
1081
-
2160
"
}
}
;
const
char
*
resolution
=
"
2161
+
"
;
int32_t
height
=
aMediaInfo
.
mVideo
.
mImage
.
height
;
for
(
const
auto
&
res
:
sResolutions
)
{
if
(
height
<
=
res
.
mH
)
{
resolution
=
res
.
mRes
;
break
;
}
}
key
.
AppendASCII
(
resolution
)
;
TimeDuration
duration
=
TimeStamp
:
:
Now
(
)
-
aRecoveryStart
;
double
duration_ms
=
duration
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_SUSPEND_RECOVERY_TIME_MS
key
uint32_t
(
duration_ms
+
0
.
5
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_SUSPEND_RECOVERY_TIME_MS
NS_LITERAL_CSTRING
(
"
All
"
)
uint32_t
(
duration_ms
+
0
.
5
)
)
;
}
void
MediaDecoderStateMachine
:
:
VisibilityChanged
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
DECODER_LOG
(
"
VisibilityChanged
:
mIsVisible
=
%
d
"
"
mVideoDecodeSuspended
=
%
c
mIsReaderSuspended
=
%
d
"
mIsVisible
.
Ref
(
)
mVideoDecodeSuspended
?
'
T
'
:
'
F
'
mIsReaderSuspended
.
Ref
(
)
)
;
if
(
!
HasVideo
(
)
)
{
return
;
}
if
(
!
mIsVisible
)
{
TimeStamp
target
=
TimeStamp
:
:
Now
(
)
+
SuspendBackgroundVideoDelay
(
)
;
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
mVideoDecodeSuspendTimer
.
Ensure
(
target
[
=
]
(
)
{
self
-
>
OnSuspendTimerResolved
(
)
;
}
[
=
]
(
)
{
self
-
>
OnSuspendTimerRejected
(
)
;
}
)
;
return
;
}
mVideoDecodeSuspendTimer
.
Reset
(
)
;
if
(
mVideoDecodeSuspended
)
{
mVideoDecodeSuspended
=
false
;
mOnPlaybackEvent
.
Notify
(
MediaEventType
:
:
ExitVideoSuspend
)
;
mReader
-
>
SetVideoBlankDecode
(
false
)
;
if
(
mIsReaderSuspended
)
{
return
;
}
if
(
mState
=
=
DECODER_STATE_SEEKING
|
|
mQueuedSeek
.
Exists
(
)
)
{
return
;
}
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
MediaInfo
&
info
=
mInfo
;
bool
hw
=
mReader
-
>
VideoIsHardwareAccelerated
(
)
;
SeekJob
seekJob
;
const
SeekTarget
:
:
Type
type
=
HasAudio
(
)
?
SeekTarget
:
:
Type
:
:
Accurate
:
SeekTarget
:
:
Type
:
:
PrevSyncPoint
;
seekJob
.
mTarget
=
SeekTarget
(
GetMediaTime
(
)
type
MediaDecoderEventVisibility
:
:
Suppressed
true
)
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
p
=
seekJob
.
mPromise
.
Ensure
(
__func__
)
;
p
-
>
Then
(
AbstractThread
:
:
MainThread
(
)
__func__
[
start
info
hw
]
(
)
{
ReportRecoveryTelemetry
(
start
info
hw
)
;
}
[
]
(
)
{
}
)
;
InitiateSeek
(
Move
(
seekJob
)
)
;
}
}
void
MediaDecoderStateMachine
:
:
BufferedRangeUpdated
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
!
mBuffered
.
Ref
(
)
.
IsInvalid
(
)
)
{
bool
exists
;
media
:
:
TimeUnit
end
{
mBuffered
.
Ref
(
)
.
GetEnd
(
&
exists
)
}
;
if
(
exists
)
{
mObservedDuration
=
std
:
:
max
(
mObservedDuration
.
Ref
(
)
end
)
;
}
}
}
void
MediaDecoderStateMachine
:
:
ReaderSuspendedChanged
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
DECODER_LOG
(
"
ReaderSuspendedChanged
:
%
d
"
mIsReaderSuspended
.
Ref
(
)
)
;
SetDormant
(
mIsReaderSuspended
)
;
}
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
MediaDecoderStateMachine
:
:
Seek
(
SeekTarget
aTarget
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
IsShutdown
(
)
)
{
return
MediaDecoder
:
:
SeekPromise
:
:
CreateAndReject
(
true
__func__
)
;
}
if
(
!
mMediaSeekable
&
&
!
mMediaSeekableOnlyInBufferedRanges
)
{
DECODER_WARN
(
"
Seek
(
)
function
should
not
be
called
on
a
non
-
seekable
state
machine
"
)
;
return
MediaDecoder
:
:
SeekPromise
:
:
CreateAndReject
(
true
__func__
)
;
}
if
(
aTarget
.
IsNextFrame
(
)
&
&
!
HasVideo
(
)
)
{
DECODER_WARN
(
"
Ignore
a
NextFrameSeekTask
on
a
media
file
without
video
track
.
"
)
;
return
MediaDecoder
:
:
SeekPromise
:
:
CreateAndReject
(
true
__func__
)
;
}
MOZ_ASSERT
(
mDuration
.
Ref
(
)
.
isSome
(
)
"
We
should
have
got
duration
already
"
)
;
return
mStateObj
-
>
HandleSeek
(
aTarget
)
;
}
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
MediaDecoderStateMachine
:
:
InvokeSeek
(
SeekTarget
aTarget
)
{
return
InvokeAsync
(
OwnerThread
(
)
this
__func__
&
MediaDecoderStateMachine
:
:
Seek
aTarget
)
;
}
void
MediaDecoderStateMachine
:
:
StopMediaSink
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mMediaSink
-
>
IsStarted
(
)
)
{
DECODER_LOG
(
"
Stop
MediaSink
"
)
;
mAudibleListener
.
DisconnectIfExists
(
)
;
mMediaSink
-
>
Stop
(
)
;
mMediaSinkAudioPromise
.
DisconnectIfExists
(
)
;
mMediaSinkVideoPromise
.
DisconnectIfExists
(
)
;
}
}
void
MediaDecoderStateMachine
:
:
DispatchDecodeTasksIfNeeded
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mState
!
=
DECODER_STATE_DECODING
&
&
mState
!
=
DECODER_STATE_DECODING_FIRSTFRAME
&
&
mState
!
=
DECODER_STATE_BUFFERING
&
&
mState
!
=
DECODER_STATE_SEEKING
)
{
return
;
}
const
bool
needToDecodeAudio
=
NeedToDecodeAudio
(
)
;
const
bool
needToDecodeVideo
=
NeedToDecodeVideo
(
)
;
MOZ_ASSERT
(
mState
!
=
DECODER_STATE_COMPLETED
|
|
(
!
needToDecodeAudio
&
&
!
needToDecodeVideo
)
)
;
bool
needIdle
=
!
IsLogicallyPlaying
(
)
&
&
mState
!
=
DECODER_STATE_SEEKING
&
&
!
needToDecodeAudio
&
&
!
needToDecodeVideo
&
&
!
IsPlaying
(
)
;
SAMPLE_LOG
(
"
DispatchDecodeTasksIfNeeded
needAudio
=
%
d
audioStatus
=
%
s
needVideo
=
%
d
videoStatus
=
%
s
needIdle
=
%
d
"
needToDecodeAudio
AudioRequestStatus
(
)
needToDecodeVideo
VideoRequestStatus
(
)
needIdle
)
;
if
(
needToDecodeAudio
)
{
EnsureAudioDecodeTaskQueued
(
)
;
}
if
(
needToDecodeVideo
)
{
EnsureVideoDecodeTaskQueued
(
)
;
}
if
(
needIdle
)
{
DECODER_LOG
(
"
Dispatching
SetIdle
(
)
audioQueue
=
%
lld
videoQueue
=
%
lld
"
GetDecodedAudioDuration
(
)
VideoQueue
(
)
.
Duration
(
)
)
;
mReader
-
>
SetIdle
(
)
;
}
}
void
MediaDecoderStateMachine
:
:
InitiateSeek
(
SeekJob
aSeekJob
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mStateObj
-
>
Exit
(
)
;
mState
=
DECODER_STATE_SEEKING
;
mStateObj
=
MakeUnique
<
SeekingState
>
(
this
Move
(
aSeekJob
)
)
;
mStateObj
-
>
Enter
(
)
;
}
void
MediaDecoderStateMachine
:
:
DispatchAudioDecodeTaskIfNeeded
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
!
IsShutdown
(
)
&
&
NeedToDecodeAudio
(
)
)
{
EnsureAudioDecodeTaskQueued
(
)
;
}
}
void
MediaDecoderStateMachine
:
:
EnsureAudioDecodeTaskQueued
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mState
!
=
DECODER_STATE_SEEKING
)
;
SAMPLE_LOG
(
"
EnsureAudioDecodeTaskQueued
isDecoding
=
%
d
status
=
%
s
"
IsAudioDecoding
(
)
AudioRequestStatus
(
)
)
;
if
(
mState
!
=
DECODER_STATE_DECODING
&
&
mState
!
=
DECODER_STATE_DECODING_FIRSTFRAME
&
&
mState
!
=
DECODER_STATE_BUFFERING
)
{
return
;
}
if
(
!
IsAudioDecoding
(
)
|
|
mReader
-
>
IsRequestingAudioData
(
)
|
|
mReader
-
>
IsWaitingAudioData
(
)
)
{
return
;
}
RequestAudioData
(
)
;
}
void
MediaDecoderStateMachine
:
:
RequestAudioData
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mState
!
=
DECODER_STATE_SEEKING
)
;
SAMPLE_LOG
(
"
Queueing
audio
task
-
queued
=
%
i
decoder
-
queued
=
%
o
"
AudioQueue
(
)
.
GetSize
(
)
mReader
-
>
SizeOfAudioQueueInFrames
(
)
)
;
mReader
-
>
RequestAudioData
(
)
;
}
void
MediaDecoderStateMachine
:
:
DispatchVideoDecodeTaskIfNeeded
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
!
IsShutdown
(
)
&
&
NeedToDecodeVideo
(
)
)
{
EnsureVideoDecodeTaskQueued
(
)
;
}
}
void
MediaDecoderStateMachine
:
:
EnsureVideoDecodeTaskQueued
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mState
!
=
DECODER_STATE_SEEKING
)
;
SAMPLE_LOG
(
"
EnsureVideoDecodeTaskQueued
isDecoding
=
%
d
status
=
%
s
"
IsVideoDecoding
(
)
VideoRequestStatus
(
)
)
;
if
(
mState
!
=
DECODER_STATE_DECODING
&
&
mState
!
=
DECODER_STATE_DECODING_FIRSTFRAME
&
&
mState
!
=
DECODER_STATE_BUFFERING
)
{
return
;
}
if
(
!
IsVideoDecoding
(
)
|
|
mReader
-
>
IsRequestingVideoData
(
)
|
|
mReader
-
>
IsWaitingVideoData
(
)
)
{
return
;
}
RequestVideoData
(
)
;
}
void
MediaDecoderStateMachine
:
:
RequestVideoData
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mState
!
=
DECODER_STATE_SEEKING
)
;
bool
skipToNextKeyFrame
=
NeedToSkipToNextKeyframe
(
)
;
media
:
:
TimeUnit
currentTime
=
media
:
:
TimeUnit
:
:
FromMicroseconds
(
GetMediaTime
(
)
)
;
SAMPLE_LOG
(
"
Queueing
video
task
-
queued
=
%
i
decoder
-
queued
=
%
o
skip
=
%
i
time
=
%
lld
"
VideoQueue
(
)
.
GetSize
(
)
mReader
-
>
SizeOfVideoQueueInFrames
(
)
skipToNextKeyFrame
currentTime
.
ToMicroseconds
(
)
)
;
mReader
-
>
RequestVideoData
(
skipToNextKeyFrame
currentTime
)
;
}
void
MediaDecoderStateMachine
:
:
StartMediaSink
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
!
mMediaSink
-
>
IsStarted
(
)
)
{
mAudioCompleted
=
false
;
mMediaSink
-
>
Start
(
GetMediaTime
(
)
mInfo
)
;
auto
videoPromise
=
mMediaSink
-
>
OnEnded
(
TrackInfo
:
:
kVideoTrack
)
;
auto
audioPromise
=
mMediaSink
-
>
OnEnded
(
TrackInfo
:
:
kAudioTrack
)
;
if
(
audioPromise
)
{
mMediaSinkAudioPromise
.
Begin
(
audioPromise
-
>
Then
(
OwnerThread
(
)
__func__
this
&
MediaDecoderStateMachine
:
:
OnMediaSinkAudioComplete
&
MediaDecoderStateMachine
:
:
OnMediaSinkAudioError
)
)
;
}
if
(
videoPromise
)
{
mMediaSinkVideoPromise
.
Begin
(
videoPromise
-
>
Then
(
OwnerThread
(
)
__func__
this
&
MediaDecoderStateMachine
:
:
OnMediaSinkVideoComplete
&
MediaDecoderStateMachine
:
:
OnMediaSinkVideoError
)
)
;
}
}
}
bool
MediaDecoderStateMachine
:
:
HasLowDecodedAudio
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
IsAudioDecoding
(
)
&
&
GetDecodedAudioDuration
(
)
<
EXHAUSTED_DATA_MARGIN_USECS
*
mPlaybackRate
;
}
bool
MediaDecoderStateMachine
:
:
HasLowDecodedVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
IsVideoDecoding
(
)
&
&
VideoQueue
(
)
.
GetSize
(
)
<
LOW_VIDEO_FRAMES
*
mPlaybackRate
;
}
bool
MediaDecoderStateMachine
:
:
HasLowDecodedData
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mReader
-
>
UseBufferingHeuristics
(
)
)
;
return
HasLowDecodedAudio
(
)
|
|
HasLowDecodedVideo
(
)
;
}
bool
MediaDecoderStateMachine
:
:
OutOfDecodedAudio
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
IsAudioDecoding
(
)
&
&
!
AudioQueue
(
)
.
IsFinished
(
)
&
&
AudioQueue
(
)
.
GetSize
(
)
=
=
0
&
&
!
mMediaSink
-
>
HasUnplayedFrames
(
TrackInfo
:
:
kAudioTrack
)
;
}
bool
MediaDecoderStateMachine
:
:
HasLowBufferedData
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
HasLowBufferedData
(
mLowDataThresholdUsecs
)
;
}
bool
MediaDecoderStateMachine
:
:
HasLowBufferedData
(
int64_t
aUsecs
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mState
>
=
DECODER_STATE_DECODING
"
Must
have
loaded
first
frame
for
mBuffered
to
be
valid
"
)
;
if
(
Duration
(
)
.
IsInfinite
(
)
)
{
return
false
;
}
if
(
mBuffered
.
Ref
(
)
.
IsInvalid
(
)
)
{
return
false
;
}
int64_t
endOfDecodedVideoData
=
(
HasVideo
(
)
&
&
!
VideoQueue
(
)
.
IsFinished
(
)
)
?
mDecodedVideoEndTime
:
INT64_MAX
;
int64_t
endOfDecodedAudioData
=
(
HasAudio
(
)
&
&
!
AudioQueue
(
)
.
IsFinished
(
)
)
?
mDecodedAudioEndTime
:
INT64_MAX
;
int64_t
endOfDecodedData
=
std
:
:
min
(
endOfDecodedVideoData
endOfDecodedAudioData
)
;
if
(
Duration
(
)
.
ToMicroseconds
(
)
<
endOfDecodedData
)
{
return
false
;
}
if
(
endOfDecodedData
=
=
INT64_MAX
)
{
return
false
;
}
int64_t
start
=
endOfDecodedData
;
int64_t
end
=
std
:
:
min
(
GetMediaTime
(
)
+
aUsecs
Duration
(
)
.
ToMicroseconds
(
)
)
;
if
(
start
>
=
end
)
{
return
false
;
}
media
:
:
TimeInterval
interval
(
media
:
:
TimeUnit
:
:
FromMicroseconds
(
start
)
media
:
:
TimeUnit
:
:
FromMicroseconds
(
end
)
)
;
return
!
mBuffered
.
Ref
(
)
.
Contains
(
interval
)
;
}
void
MediaDecoderStateMachine
:
:
DecodeError
(
const
MediaResult
&
aError
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
!
IsShutdown
(
)
)
;
DECODER_WARN
(
"
Decode
error
"
)
;
mOnPlaybackErrorEvent
.
Notify
(
aError
)
;
}
void
MediaDecoderStateMachine
:
:
EnqueueLoadedMetadataEvent
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MediaDecoderEventVisibility
visibility
=
mSentLoadedMetadataEvent
?
MediaDecoderEventVisibility
:
:
Suppressed
:
MediaDecoderEventVisibility
:
:
Observable
;
mMetadataLoadedEvent
.
Notify
(
nsAutoPtr
<
MediaInfo
>
(
new
MediaInfo
(
mInfo
)
)
Move
(
mMetadataTags
)
visibility
)
;
mSentLoadedMetadataEvent
=
true
;
}
void
MediaDecoderStateMachine
:
:
EnqueueFirstFrameLoadedEvent
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
bool
firstFrameBeenLoaded
=
mSentFirstFrameLoadedEvent
;
mSentFirstFrameLoadedEvent
=
true
;
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
mBufferedUpdateRequest
.
Begin
(
mReader
-
>
UpdateBufferedWithPromise
(
)
-
>
Then
(
OwnerThread
(
)
__func__
[
self
firstFrameBeenLoaded
]
(
)
{
self
-
>
mBufferedUpdateRequest
.
Complete
(
)
;
MediaDecoderEventVisibility
visibility
=
firstFrameBeenLoaded
?
MediaDecoderEventVisibility
:
:
Suppressed
:
MediaDecoderEventVisibility
:
:
Observable
;
self
-
>
mFirstFrameLoadedEvent
.
Notify
(
nsAutoPtr
<
MediaInfo
>
(
new
MediaInfo
(
self
-
>
mInfo
)
)
visibility
)
;
}
[
]
(
)
{
MOZ_CRASH
(
"
Should
not
reach
"
)
;
}
)
)
;
}
void
MediaDecoderStateMachine
:
:
FinishDecodeFirstFrame
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
!
mSentFirstFrameLoadedEvent
)
;
DECODER_LOG
(
"
FinishDecodeFirstFrame
"
)
;
mMediaSink
-
>
Redraw
(
mInfo
.
mVideo
)
;
if
(
mDuration
.
Ref
(
)
.
isNothing
(
)
)
{
mDuration
=
Some
(
TimeUnit
:
:
FromInfinity
(
)
)
;
}
DECODER_LOG
(
"
Media
duration
%
lld
"
"
transportSeekable
=
%
d
mediaSeekable
=
%
d
"
Duration
(
)
.
ToMicroseconds
(
)
mResource
-
>
IsTransportSeekable
(
)
mMediaSeekable
.
Ref
(
)
)
;
mReader
-
>
ReadUpdatedMetadata
(
&
mInfo
)
;
if
(
!
mNotifyMetadataBeforeFirstFrame
)
{
EnqueueLoadedMetadataEvent
(
)
;
}
EnqueueFirstFrameLoadedEvent
(
)
;
}
RefPtr
<
ShutdownPromise
>
MediaDecoderStateMachine
:
:
BeginShutdown
(
)
{
return
InvokeAsync
(
OwnerThread
(
)
this
__func__
&
MediaDecoderStateMachine
:
:
Shutdown
)
;
}
RefPtr
<
ShutdownPromise
>
MediaDecoderStateMachine
:
:
FinishShutdown
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mState
=
=
DECODER_STATE_SHUTDOWN
"
How
did
we
escape
from
the
shutdown
state
?
"
)
;
DECODER_LOG
(
"
Shutting
down
state
machine
task
queue
"
)
;
return
OwnerThread
(
)
-
>
BeginShutdown
(
)
;
}
void
MediaDecoderStateMachine
:
:
RunStateMachine
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mDelayedScheduler
.
Reset
(
)
;
mDispatchedStateMachine
=
false
;
mStateObj
-
>
Step
(
)
;
}
void
MediaDecoderStateMachine
:
:
Reset
(
TrackSet
aTracks
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
DECODER_LOG
(
"
MediaDecoderStateMachine
:
:
Reset
"
)
;
MOZ_ASSERT
(
IsShutdown
(
)
|
|
mState
=
=
DECODER_STATE_SEEKING
|
|
mState
=
=
DECODER_STATE_DORMANT
)
;
MOZ_ASSERT
(
aTracks
.
contains
(
TrackInfo
:
:
kVideoTrack
)
)
;
if
(
aTracks
.
contains
(
TrackInfo
:
:
kAudioTrack
)
&
&
aTracks
.
contains
(
TrackInfo
:
:
kVideoTrack
)
)
{
StopMediaSink
(
)
;
}
if
(
aTracks
.
contains
(
TrackInfo
:
:
kVideoTrack
)
)
{
mDecodedVideoEndTime
=
0
;
mVideoCompleted
=
false
;
VideoQueue
(
)
.
Reset
(
)
;
}
if
(
aTracks
.
contains
(
TrackInfo
:
:
kAudioTrack
)
)
{
mDecodedAudioEndTime
=
0
;
mAudioCompleted
=
false
;
AudioQueue
(
)
.
Reset
(
)
;
}
mPlaybackOffset
=
0
;
mReader
-
>
ResetDecode
(
aTracks
)
;
}
int64_t
MediaDecoderStateMachine
:
:
GetClock
(
TimeStamp
*
aTimeStamp
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
int64_t
clockTime
=
mMediaSink
-
>
GetPosition
(
aTimeStamp
)
;
NS_ASSERTION
(
GetMediaTime
(
)
<
=
clockTime
"
Clock
should
go
forwards
.
"
)
;
return
clockTime
;
}
void
MediaDecoderStateMachine
:
:
UpdatePlaybackPositionPeriodically
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
!
IsPlaying
(
)
)
{
return
;
}
if
(
VideoEndTime
(
)
!
=
-
1
|
|
AudioEndTime
(
)
!
=
-
1
)
{
const
int64_t
clockTime
=
GetClock
(
)
;
NS_ASSERTION
(
clockTime
>
=
0
"
Should
have
positive
clock
time
.
"
)
;
int64_t
t
=
std
:
:
min
(
clockTime
std
:
:
max
(
VideoEndTime
(
)
AudioEndTime
(
)
)
)
;
if
(
t
>
GetMediaTime
(
)
)
{
UpdatePlaybackPosition
(
t
)
;
}
}
int64_t
delay
=
std
:
:
max
<
int64_t
>
(
1
AUDIO_DURATION_USECS
/
mPlaybackRate
)
;
ScheduleStateMachineIn
(
delay
)
;
}
void
MediaDecoderStateMachine
:
:
UpdateNextFrameStatus
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MediaDecoderOwner
:
:
NextFrameStatus
status
;
const
char
*
statusString
;
switch
(
mState
.
Ref
(
)
)
{
case
DECODER_STATE_BUFFERING
:
status
=
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE_BUFFERING
;
statusString
=
"
NEXT_FRAME_UNAVAILABLE_BUFFERING
"
;
break
;
case
DECODER_STATE_SEEKING
:
status
=
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE_SEEKING
;
statusString
=
"
NEXT_FRAME_UNAVAILABLE_SEEKING
"
;
break
;
default
:
bool
b
=
HaveNextFrameData
(
)
;
status
=
b
?
MediaDecoderOwner
:
:
NEXT_FRAME_AVAILABLE
:
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE
;
statusString
=
b
?
"
NEXT_FRAME_AVAILABLE
"
:
"
NEXT_FRAME_UNAVAILABLE
"
;
break
;
}
if
(
status
!
=
mNextFrameStatus
)
{
DECODER_LOG
(
"
Changed
mNextFrameStatus
to
%
s
"
statusString
)
;
if
(
status
=
=
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE_BUFFERING
|
|
status
=
=
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE
)
{
UpdatePlaybackPositionPeriodically
(
)
;
}
}
mNextFrameStatus
=
status
;
}
bool
MediaDecoderStateMachine
:
:
CanPlayThrough
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
GetStatistics
(
)
.
CanPlayThrough
(
)
;
}
MediaStatistics
MediaDecoderStateMachine
:
:
GetStatistics
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MediaStatistics
result
;
result
.
mDownloadRate
=
mResource
-
>
GetDownloadRate
(
&
result
.
mDownloadRateReliable
)
;
result
.
mDownloadPosition
=
mResource
-
>
GetCachedDataEnd
(
mDecoderPosition
)
;
result
.
mTotalBytes
=
mResource
-
>
GetLength
(
)
;
result
.
mPlaybackRate
=
mPlaybackBytesPerSecond
;
result
.
mPlaybackRateReliable
=
mPlaybackRateReliable
;
result
.
mDecoderPosition
=
mDecoderPosition
;
result
.
mPlaybackPosition
=
mPlaybackOffset
;
return
result
;
}
void
MediaDecoderStateMachine
:
:
ScheduleStateMachine
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mDispatchedStateMachine
)
{
return
;
}
mDispatchedStateMachine
=
true
;
OwnerThread
(
)
-
>
Dispatch
(
NewRunnableMethod
(
this
&
MediaDecoderStateMachine
:
:
RunStateMachine
)
)
;
}
void
MediaDecoderStateMachine
:
:
ScheduleStateMachineIn
(
int64_t
aMicroseconds
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
aMicroseconds
>
0
)
;
if
(
mDispatchedStateMachine
)
{
return
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
TimeStamp
target
=
now
+
TimeDuration
:
:
FromMicroseconds
(
aMicroseconds
)
;
mDelayedScheduler
.
Ensure
(
target
[
this
]
(
)
{
mDelayedScheduler
.
CompleteRequest
(
)
;
RunStateMachine
(
)
;
}
[
]
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
)
;
}
)
;
}
bool
MediaDecoderStateMachine
:
:
OnTaskQueue
(
)
const
{
return
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
;
}
bool
MediaDecoderStateMachine
:
:
IsStateMachineScheduled
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mDispatchedStateMachine
|
|
mDelayedScheduler
.
IsScheduled
(
)
;
}
void
MediaDecoderStateMachine
:
:
SetPlaybackRate
(
double
aPlaybackRate
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
aPlaybackRate
!
=
0
"
Should
be
handled
by
MediaDecoder
:
:
Pause
(
)
"
)
;
mPlaybackRate
=
aPlaybackRate
;
mMediaSink
-
>
SetPlaybackRate
(
mPlaybackRate
)
;
ScheduleStateMachine
(
)
;
}
void
MediaDecoderStateMachine
:
:
PreservesPitchChanged
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mMediaSink
-
>
SetPreservesPitch
(
mPreservesPitch
)
;
}
bool
MediaDecoderStateMachine
:
:
IsShutdown
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mIsShutdown
;
}
int64_t
MediaDecoderStateMachine
:
:
AudioEndTime
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mMediaSink
-
>
IsStarted
(
)
)
{
return
mMediaSink
-
>
GetEndTime
(
TrackInfo
:
:
kAudioTrack
)
;
}
MOZ_ASSERT
(
!
HasAudio
(
)
)
;
return
-
1
;
}
int64_t
MediaDecoderStateMachine
:
:
VideoEndTime
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mMediaSink
-
>
IsStarted
(
)
)
{
return
mMediaSink
-
>
GetEndTime
(
TrackInfo
:
:
kVideoTrack
)
;
}
return
-
1
;
}
void
MediaDecoderStateMachine
:
:
OnMediaSinkVideoComplete
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mInfo
.
HasVideo
(
)
)
;
VERBOSE_LOG
(
"
[
%
s
]
"
__func__
)
;
mMediaSinkVideoPromise
.
Complete
(
)
;
mVideoCompleted
=
true
;
ScheduleStateMachine
(
)
;
}
void
MediaDecoderStateMachine
:
:
OnMediaSinkVideoError
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mInfo
.
HasVideo
(
)
)
;
VERBOSE_LOG
(
"
[
%
s
]
"
__func__
)
;
mMediaSinkVideoPromise
.
Complete
(
)
;
mVideoCompleted
=
true
;
if
(
HasAudio
(
)
)
{
return
;
}
DecodeError
(
MediaResult
(
NS_ERROR_DOM_MEDIA_MEDIASINK_ERR
__func__
)
)
;
}
void
MediaDecoderStateMachine
:
:
OnMediaSinkAudioComplete
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mInfo
.
HasAudio
(
)
)
;
VERBOSE_LOG
(
"
[
%
s
]
"
__func__
)
;
mMediaSinkAudioPromise
.
Complete
(
)
;
mAudioCompleted
=
true
;
ScheduleStateMachine
(
)
;
mOnDecoderDoctorEvent
.
Notify
(
DecoderDoctorEvent
{
DecoderDoctorEvent
:
:
eAudioSinkStartup
NS_OK
}
)
;
}
void
MediaDecoderStateMachine
:
:
OnMediaSinkAudioError
(
nsresult
aResult
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mInfo
.
HasAudio
(
)
)
;
VERBOSE_LOG
(
"
[
%
s
]
"
__func__
)
;
mMediaSinkAudioPromise
.
Complete
(
)
;
mAudioCompleted
=
true
;
MOZ_ASSERT
(
NS_FAILED
(
aResult
)
)
;
mOnDecoderDoctorEvent
.
Notify
(
DecoderDoctorEvent
{
DecoderDoctorEvent
:
:
eAudioSinkStartup
aResult
}
)
;
if
(
HasVideo
(
)
)
{
return
;
}
DecodeError
(
MediaResult
(
NS_ERROR_DOM_MEDIA_MEDIASINK_ERR
__func__
)
)
;
}
void
MediaDecoderStateMachine
:
:
OnCDMProxyReady
(
RefPtr
<
CDMProxy
>
aProxy
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mCDMProxyPromise
.
Complete
(
)
;
mCDMProxy
=
aProxy
;
mReader
-
>
SetCDMProxy
(
aProxy
)
;
mStateObj
-
>
HandleCDMProxyReady
(
)
;
}
void
MediaDecoderStateMachine
:
:
OnCDMProxyNotReady
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mCDMProxyPromise
.
Complete
(
)
;
}
void
MediaDecoderStateMachine
:
:
SetAudioCaptured
(
bool
aCaptured
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
aCaptured
=
=
mAudioCaptured
)
{
return
;
}
mAudioCompleted
=
false
;
mVideoCompleted
=
false
;
MediaSink
:
:
PlaybackParams
params
=
mMediaSink
-
>
GetPlaybackParams
(
)
;
StopMediaSink
(
)
;
mMediaSink
-
>
Shutdown
(
)
;
mMediaSink
=
CreateMediaSink
(
aCaptured
)
;
mMediaSink
-
>
SetPlaybackParams
(
params
)
;
mAudioCaptured
=
aCaptured
;
ScheduleStateMachine
(
)
;
mAmpleAudioThresholdUsecs
=
mAudioCaptured
?
detail
:
:
AMPLE_AUDIO_USECS
/
2
:
detail
:
:
AMPLE_AUDIO_USECS
;
MaybeStopPrerolling
(
)
;
}
uint32_t
MediaDecoderStateMachine
:
:
GetAmpleVideoFrames
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
(
mReader
-
>
IsAsync
(
)
&
&
mReader
-
>
VideoIsHardwareAccelerated
(
)
)
?
std
:
:
max
<
uint32_t
>
(
sVideoQueueHWAccelSize
MIN_VIDEO_QUEUE_SIZE
)
:
std
:
:
max
<
uint32_t
>
(
sVideoQueueDefaultSize
MIN_VIDEO_QUEUE_SIZE
)
;
}
void
MediaDecoderStateMachine
:
:
DumpDebugInfo
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
this
]
(
)
{
mMediaSink
-
>
DumpDebugInfo
(
)
;
DUMP_LOG
(
"
GetMediaTime
=
%
lld
GetClock
=
%
lld
mMediaSink
=
%
p
"
"
mState
=
%
s
mPlayState
=
%
d
mSentFirstFrameLoadedEvent
=
%
d
IsPlaying
=
%
d
"
"
mAudioStatus
=
%
s
mVideoStatus
=
%
s
mDecodedAudioEndTime
=
%
lld
mDecodedVideoEndTime
=
%
lld
"
"
mIsPrerolling
=
%
d
mAudioCompleted
=
%
d
mVideoCompleted
=
%
d
"
GetMediaTime
(
)
mMediaSink
-
>
IsStarted
(
)
?
GetClock
(
)
:
-
1
mMediaSink
.
get
(
)
ToStateStr
(
)
mPlayState
.
Ref
(
)
mSentFirstFrameLoadedEvent
IsPlaying
(
)
AudioRequestStatus
(
)
VideoRequestStatus
(
)
mDecodedAudioEndTime
mDecodedVideoEndTime
mIsPrerolling
mAudioCompleted
.
Ref
(
)
mVideoCompleted
.
Ref
(
)
)
;
}
)
;
OwnerThread
(
)
-
>
DispatchStateChange
(
r
.
forget
(
)
)
;
}
void
MediaDecoderStateMachine
:
:
AddOutputStream
(
ProcessedMediaStream
*
aStream
bool
aFinishWhenEnded
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
DECODER_LOG
(
"
AddOutputStream
aStream
=
%
p
!
"
aStream
)
;
mOutputStreamManager
-
>
Add
(
aStream
aFinishWhenEnded
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NewRunnableMethod
<
bool
>
(
this
&
MediaDecoderStateMachine
:
:
SetAudioCaptured
true
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
MediaDecoderStateMachine
:
:
RemoveOutputStream
(
MediaStream
*
aStream
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
DECODER_LOG
(
"
RemoveOutputStream
=
%
p
!
"
aStream
)
;
mOutputStreamManager
-
>
Remove
(
aStream
)
;
if
(
mOutputStreamManager
-
>
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
NewRunnableMethod
<
bool
>
(
this
&
MediaDecoderStateMachine
:
:
SetAudioCaptured
false
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
}
size_t
MediaDecoderStateMachine
:
:
SizeOfVideoQueue
(
)
const
{
return
mReader
-
>
SizeOfVideoQueueInBytes
(
)
;
}
size_t
MediaDecoderStateMachine
:
:
SizeOfAudioQueue
(
)
const
{
return
mReader
-
>
SizeOfAudioQueueInBytes
(
)
;
}
AbstractCanonical
<
media
:
:
TimeIntervals
>
*
MediaDecoderStateMachine
:
:
CanonicalBuffered
(
)
const
{
return
mReader
-
>
CanonicalBuffered
(
)
;
}
MediaEventSource
<
void
>
&
MediaDecoderStateMachine
:
:
OnMediaNotSeekable
(
)
const
{
return
mReader
-
>
OnMediaNotSeekable
(
)
;
}
const
char
*
MediaDecoderStateMachine
:
:
AudioRequestStatus
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mReader
-
>
IsRequestingAudioData
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mReader
-
>
IsWaitingAudioData
(
)
)
;
return
"
pending
"
;
}
else
if
(
mReader
-
>
IsWaitingAudioData
(
)
)
{
return
"
waiting
"
;
}
return
"
idle
"
;
}
const
char
*
MediaDecoderStateMachine
:
:
VideoRequestStatus
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mReader
-
>
IsRequestingVideoData
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mReader
-
>
IsWaitingVideoData
(
)
)
;
return
"
pending
"
;
}
else
if
(
mReader
-
>
IsWaitingVideoData
(
)
)
{
return
"
waiting
"
;
}
return
"
idle
"
;
}
void
MediaDecoderStateMachine
:
:
OnSuspendTimerResolved
(
)
{
DECODER_LOG
(
"
OnSuspendTimerResolved
"
)
;
mVideoDecodeSuspendTimer
.
CompleteRequest
(
)
;
mVideoDecodeSuspended
=
true
;
mOnPlaybackEvent
.
Notify
(
MediaEventType
:
:
EnterVideoSuspend
)
;
mReader
-
>
SetVideoBlankDecode
(
true
)
;
}
void
MediaDecoderStateMachine
:
:
OnSuspendTimerRejected
(
)
{
DECODER_LOG
(
"
OnSuspendTimerRejected
"
)
;
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
!
mVideoDecodeSuspended
)
;
mVideoDecodeSuspendTimer
.
CompleteRequest
(
)
;
}
}
#
undef
NS_DispatchToMainThread
