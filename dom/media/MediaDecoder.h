#
if
!
defined
(
MediaDecoder_h_
)
#
define
MediaDecoder_h_
#
include
"
DecoderDoctorDiagnostics
.
h
"
#
include
"
MediaDecoderOwner
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaResource
.
h
"
#
include
"
MediaStatistics
.
h
"
#
include
"
MediaStreamGraph
.
h
"
#
include
"
SeekTarget
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
CDMProxy
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
mozilla
/
StateWatching
.
h
"
#
include
"
mozilla
/
dom
/
AudioChannelBinding
.
h
"
#
include
"
necko
-
config
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsITimer
.
h
"
class
nsIPrincipal
;
namespace
mozilla
{
class
AbstractThread
;
class
FrameStatistics
;
class
VideoFrameContainer
;
class
MediaFormatReader
;
class
MediaDecoderStateMachine
;
enum
class
MediaEventType
:
int8_t
;
enum
class
Visibility
:
uint8_t
;
#
ifdef
GetCurrentTime
#
undef
GetCurrentTime
#
endif
struct
MOZ_STACK_CLASS
MediaDecoderInit
{
MediaDecoderOwner
*
const
mOwner
;
const
dom
:
:
AudioChannel
mAudioChannel
;
const
double
mVolume
;
const
bool
mPreservesPitch
;
const
double
mPlaybackRate
;
const
bool
mMinimizePreroll
;
const
bool
mHasSuspendTaint
;
const
bool
mLooping
;
const
MediaContainerType
mContainerType
;
MediaDecoderInit
(
MediaDecoderOwner
*
aOwner
dom
:
:
AudioChannel
aAudioChannel
double
aVolume
bool
aPreservesPitch
double
aPlaybackRate
bool
aMinimizePreroll
bool
aHasSuspendTaint
bool
aLooping
const
MediaContainerType
&
aContainerType
)
:
mOwner
(
aOwner
)
mAudioChannel
(
aAudioChannel
)
mVolume
(
aVolume
)
mPreservesPitch
(
aPreservesPitch
)
mPlaybackRate
(
aPlaybackRate
)
mMinimizePreroll
(
aMinimizePreroll
)
mHasSuspendTaint
(
aHasSuspendTaint
)
mLooping
(
aLooping
)
mContainerType
(
aContainerType
)
{
}
}
;
class
MediaDecoder
{
public
:
typedef
MozPromise
<
bool
bool
true
>
SeekPromise
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDecoder
)
enum
PlayState
{
PLAY_STATE_START
PLAY_STATE_LOADING
PLAY_STATE_PAUSED
PLAY_STATE_PLAYING
PLAY_STATE_ENDED
PLAY_STATE_SHUTDOWN
}
;
static
void
InitStatics
(
)
;
explicit
MediaDecoder
(
MediaDecoderInit
&
aInit
)
;
const
MediaContainerType
&
ContainerType
(
)
const
{
return
mContainerType
;
}
virtual
MediaDecoderStateMachine
*
CreateStateMachine
(
)
=
0
;
virtual
void
Shutdown
(
)
;
void
NotifyXPCOMShutdown
(
)
;
void
NetworkError
(
)
;
MediaResource
*
GetResource
(
)
const
{
return
mResource
;
}
virtual
already_AddRefed
<
nsIPrincipal
>
GetCurrentPrincipal
(
)
;
virtual
double
GetCurrentTime
(
)
;
virtual
nsresult
Seek
(
double
aTime
SeekTarget
:
:
Type
aSeekType
)
;
nsresult
InitializeStateMachine
(
)
;
virtual
nsresult
Play
(
)
;
virtual
void
NotifyOwnerActivityChanged
(
bool
aIsDocumentVisible
Visibility
aElementVisibility
bool
aIsElementInTree
)
;
virtual
void
Pause
(
)
;
void
SetVolume
(
double
aVolume
)
;
void
SetPlaybackRate
(
double
aPlaybackRate
)
;
void
SetPreservesPitch
(
bool
aPreservesPitch
)
;
void
SetLooping
(
bool
aLooping
)
;
bool
GetMinimizePreroll
(
)
const
{
return
mMinimizePreroll
;
}
virtual
void
AddOutputStream
(
ProcessedMediaStream
*
aStream
bool
aFinishWhenEnded
)
;
virtual
void
RemoveOutputStream
(
MediaStream
*
aStream
)
;
virtual
double
GetDuration
(
)
;
bool
IsInfinite
(
)
const
;
void
NotifyDataArrived
(
)
;
bool
IsSeeking
(
)
const
;
bool
IsEnded
(
)
const
;
virtual
bool
IsMSE
(
)
const
{
return
false
;
}
bool
OwnerHasError
(
)
const
;
public
:
bool
IsMediaSeekable
(
)
;
bool
IsTransportSeekable
(
)
;
virtual
media
:
:
TimeIntervals
GetSeekable
(
)
;
virtual
void
SetFragmentEndTime
(
double
aTime
)
;
void
Invalidate
(
)
;
void
InvalidateWithFlags
(
uint32_t
aFlags
)
;
virtual
void
Suspend
(
)
;
virtual
void
Resume
(
)
;
void
SetLoadInBackground
(
bool
aLoadInBackground
)
;
MediaDecoderStateMachine
*
GetStateMachine
(
)
const
;
void
SetStateMachine
(
MediaDecoderStateMachine
*
aStateMachine
)
;
virtual
media
:
:
TimeIntervals
GetBuffered
(
)
;
size_t
SizeOfVideoQueue
(
)
;
size_t
SizeOfAudioQueue
(
)
;
struct
ResourceSizes
{
typedef
MozPromise
<
size_t
size_t
true
>
SizeOfPromise
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ResourceSizes
)
explicit
ResourceSizes
(
MallocSizeOf
aMallocSizeOf
)
:
mMallocSizeOf
(
aMallocSizeOf
)
mByteSize
(
0
)
mCallback
(
)
{
}
mozilla
:
:
MallocSizeOf
mMallocSizeOf
;
mozilla
:
:
Atomic
<
size_t
>
mByteSize
;
RefPtr
<
SizeOfPromise
>
Promise
(
)
{
return
mCallback
.
Ensure
(
__func__
)
;
}
private
:
~
ResourceSizes
(
)
{
mCallback
.
ResolveIfExists
(
mByteSize
__func__
)
;
}
MozPromiseHolder
<
SizeOfPromise
>
mCallback
;
}
;
virtual
void
AddSizeOfResources
(
ResourceSizes
*
aSizes
)
;
VideoFrameContainer
*
GetVideoFrameContainer
(
)
{
return
mVideoFrameContainer
;
}
layers
:
:
ImageContainer
*
GetImageContainer
(
)
;
void
FireTimeUpdate
(
)
;
virtual
void
UpdatePlaybackRate
(
)
;
void
ComputePlaybackRate
(
)
;
virtual
bool
CanPlayThrough
(
)
;
dom
:
:
AudioChannel
GetAudioChannel
(
)
{
return
mAudioChannel
;
}
virtual
void
SetElementVisibility
(
bool
aIsDocumentVisible
Visibility
aElementVisibility
bool
aIsElementInTree
)
;
void
SetForcedHidden
(
bool
aForcedHidden
)
;
void
SetSuspendTaint
(
bool
aTaint
)
;
bool
HasSuspendTaint
(
)
const
;
void
UpdateVideoDecodeMode
(
)
;
virtual
void
ChangeState
(
PlayState
aState
)
;
void
PlaybackEnded
(
)
;
void
OnSeekRejected
(
)
;
void
OnSeekResolved
(
)
;
void
SeekingChanged
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mIgnoreProgressData
=
mLogicallySeeking
;
}
void
SeekingStarted
(
)
;
void
UpdateLogicalPositionInternal
(
)
;
void
UpdateLogicalPosition
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsShutdown
(
)
)
;
if
(
mPlayState
=
=
PLAY_STATE_PAUSED
|
|
IsSeeking
(
)
)
{
return
;
}
UpdateLogicalPositionInternal
(
)
;
}
int64_t
GetDownloadPosition
(
)
;
void
DecodeError
(
const
MediaResult
&
aError
)
;
void
UpdateSameOriginStatus
(
bool
aSameOrigin
)
;
MediaDecoderOwner
*
GetOwner
(
)
const
;
AbstractThread
*
AbstractMainThread
(
)
const
{
return
mAbstractMainThread
;
}
typedef
MozPromise
<
RefPtr
<
CDMProxy
>
bool
true
>
CDMProxyPromise
;
RefPtr
<
CDMProxyPromise
>
RequestCDMProxy
(
)
const
;
void
SetCDMProxy
(
CDMProxy
*
aProxy
)
;
void
EnsureTelemetryReported
(
)
;
static
bool
IsOggEnabled
(
)
;
static
bool
IsOpusEnabled
(
)
;
static
bool
IsWaveEnabled
(
)
;
static
bool
IsWebMEnabled
(
)
;
#
ifdef
MOZ_WMF
static
bool
IsWMFEnabled
(
)
;
#
endif
MediaStatistics
GetStatistics
(
)
;
FrameStatistics
&
GetFrameStatistics
(
)
{
return
*
mFrameStats
;
}
void
UpdateReadyState
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsShutdown
(
)
)
;
GetOwner
(
)
-
>
UpdateReadyState
(
)
;
}
virtual
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameStatus
(
)
{
return
mNextFrameStatus
;
}
virtual
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameBufferedStatus
(
)
;
virtual
void
GetMozDebugReaderData
(
nsACString
&
aString
)
{
}
virtual
void
DumpDebugInfo
(
)
;
using
DebugInfoPromise
=
MozPromise
<
nsCString
bool
true
>
;
RefPtr
<
DebugInfoPromise
>
RequestDebugInfo
(
)
;
protected
:
virtual
~
MediaDecoder
(
)
;
virtual
void
FirstFrameLoaded
(
nsAutoPtr
<
MediaInfo
>
aInfo
MediaDecoderEventVisibility
aEventVisibility
)
;
void
SetStateMachineParameters
(
)
;
bool
IsShutdown
(
)
const
;
void
DurationChanged
(
)
;
WatchManager
<
MediaDecoder
>
mWatchManager
;
double
ExplicitDuration
(
)
{
return
mExplicitDuration
.
Ref
(
)
.
ref
(
)
;
}
void
SetExplicitDuration
(
double
aValue
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsShutdown
(
)
)
;
mExplicitDuration
.
Set
(
Some
(
aValue
)
)
;
DurationChanged
(
)
;
}
double
mLogicalPosition
;
virtual
media
:
:
TimeUnit
CurrentPosition
(
)
{
return
mCurrentPosition
.
Ref
(
)
;
}
already_AddRefed
<
layers
:
:
KnowsCompositor
>
GetCompositor
(
)
;
double
mDuration
;
RefPtr
<
MediaResource
>
mResource
;
RefPtr
<
MediaFormatReader
>
mReader
;
static
constexpr
auto
DEFAULT_NEXT_FRAME_AVAILABLE_BUFFERED
=
media
:
:
TimeUnit
:
:
FromMicroseconds
(
250000
)
;
private
:
nsCString
GetDebugInfo
(
)
;
void
MetadataLoaded
(
UniquePtr
<
MediaInfo
>
aInfo
UniquePtr
<
MetadataTags
>
aTags
MediaDecoderEventVisibility
aEventVisibility
)
;
void
NotifyCompositor
(
)
;
void
OnPlaybackEvent
(
MediaEventType
aEvent
)
;
void
OnPlaybackErrorEvent
(
const
MediaResult
&
aError
)
;
void
OnDecoderDoctorEvent
(
DecoderDoctorEvent
aEvent
)
;
void
OnMediaNotSeekable
(
)
{
mMediaSeekable
=
false
;
}
void
FinishShutdown
(
)
;
void
ConnectMirrors
(
MediaDecoderStateMachine
*
aObject
)
;
void
DisconnectMirrors
(
)
;
RefPtr
<
MediaDecoderStateMachine
>
mDecoderStateMachine
;
MozPromiseHolder
<
CDMProxyPromise
>
mCDMProxyPromiseHolder
;
RefPtr
<
CDMProxyPromise
>
mCDMProxyPromise
;
protected
:
void
NotifyDataArrivedInternal
(
)
;
void
DiscardOngoingSeekIfExists
(
)
;
virtual
void
CallSeek
(
const
SeekTarget
&
aTarget
)
;
void
DownloadProgressed
(
)
;
void
SetInfinite
(
bool
aInfinite
)
;
void
NotifySuspendedStatusChanged
(
)
;
void
NotifyPrincipalChanged
(
)
;
void
NotifyBytesConsumed
(
int64_t
aBytes
int64_t
aOffset
)
;
void
NotifyDownloadEnded
(
nsresult
aStatus
)
;
MozPromiseRequestHolder
<
SeekPromise
>
mSeekRequest
;
bool
mIgnoreProgressData
;
bool
mInfiniteStream
;
void
PinForSeek
(
)
;
void
UnpinForSeek
(
)
;
const
char
*
PlayStateStr
(
)
;
void
OnMetadataUpdate
(
TimedMetadata
&
&
aMetadata
)
;
bool
ShouldThrottleDownload
(
)
;
MediaDecoderOwner
*
mOwner
;
const
RefPtr
<
AbstractThread
>
mAbstractMainThread
;
const
RefPtr
<
FrameStatistics
>
mFrameStats
;
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
MediaChannelStatistics
mPlaybackStatistics
;
bool
mPinnedForSeek
;
const
dom
:
:
AudioChannel
mAudioChannel
;
const
bool
mMinimizePreroll
;
bool
mFiredMetadataLoaded
;
bool
mMediaSeekable
=
true
;
bool
mMediaSeekableOnlyInBufferedRanges
=
false
;
nsAutoPtr
<
MediaInfo
>
mInfo
;
bool
mIsDocumentVisible
;
Visibility
mElementVisibility
;
bool
mIsElementInTree
;
bool
mForcedHidden
;
bool
mHasSuspendTaint
;
MediaEventListener
mTimedMetadataListener
;
MediaEventListener
mMetadataLoadedListener
;
MediaEventListener
mFirstFrameLoadedListener
;
MediaEventListener
mOnPlaybackEvent
;
MediaEventListener
mOnPlaybackErrorEvent
;
MediaEventListener
mOnDecoderDoctorEvent
;
MediaEventListener
mOnMediaNotSeekable
;
MediaEventListener
mOnEncrypted
;
MediaEventListener
mOnWaitingForKey
;
MediaEventListener
mOnDecodeWarning
;
protected
:
double
mPlaybackRate
;
Mirror
<
media
:
:
TimeIntervals
>
mBuffered
;
Mirror
<
MediaDecoderOwner
:
:
NextFrameStatus
>
mNextFrameStatus
;
Mirror
<
media
:
:
TimeUnit
>
mCurrentPosition
;
Mirror
<
media
:
:
NullableTimeUnit
>
mStateMachineDuration
;
Mirror
<
int64_t
>
mPlaybackPosition
;
Mirror
<
bool
>
mIsAudioDataAudible
;
Canonical
<
double
>
mVolume
;
Canonical
<
bool
>
mPreservesPitch
;
Canonical
<
bool
>
mLooping
;
Canonical
<
Maybe
<
double
>
>
mExplicitDuration
;
Canonical
<
PlayState
>
mPlayState
;
Canonical
<
PlayState
>
mNextState
;
Canonical
<
bool
>
mLogicallySeeking
;
Canonical
<
bool
>
mSameOriginMedia
;
Canonical
<
PrincipalHandle
>
mMediaPrincipalHandle
;
Canonical
<
double
>
mPlaybackBytesPerSecond
;
Canonical
<
bool
>
mPlaybackRateReliable
;
Canonical
<
int64_t
>
mDecoderPosition
;
class
BackgroundVideoDecodingPermissionObserver
;
RefPtr
<
BackgroundVideoDecodingPermissionObserver
>
mVideoDecodingOberver
;
bool
mIsBackgroundVideoDecodingAllowed
;
public
:
AbstractCanonical
<
double
>
*
CanonicalVolume
(
)
{
return
&
mVolume
;
}
AbstractCanonical
<
bool
>
*
CanonicalPreservesPitch
(
)
{
return
&
mPreservesPitch
;
}
AbstractCanonical
<
bool
>
*
CanonicalLooping
(
)
{
return
&
mLooping
;
}
AbstractCanonical
<
Maybe
<
double
>
>
*
CanonicalExplicitDuration
(
)
{
return
&
mExplicitDuration
;
}
AbstractCanonical
<
PlayState
>
*
CanonicalPlayState
(
)
{
return
&
mPlayState
;
}
AbstractCanonical
<
PlayState
>
*
CanonicalNextPlayState
(
)
{
return
&
mNextState
;
}
AbstractCanonical
<
bool
>
*
CanonicalLogicallySeeking
(
)
{
return
&
mLogicallySeeking
;
}
AbstractCanonical
<
bool
>
*
CanonicalSameOriginMedia
(
)
{
return
&
mSameOriginMedia
;
}
AbstractCanonical
<
PrincipalHandle
>
*
CanonicalMediaPrincipalHandle
(
)
{
return
&
mMediaPrincipalHandle
;
}
AbstractCanonical
<
double
>
*
CanonicalPlaybackBytesPerSecond
(
)
{
return
&
mPlaybackBytesPerSecond
;
}
AbstractCanonical
<
bool
>
*
CanonicalPlaybackRateReliable
(
)
{
return
&
mPlaybackRateReliable
;
}
AbstractCanonical
<
int64_t
>
*
CanonicalDecoderPosition
(
)
{
return
&
mDecoderPosition
;
}
private
:
void
NotifyAudibleStateChanged
(
)
;
bool
mTelemetryReported
;
const
MediaContainerType
mContainerType
;
}
;
}
#
endif
