#
if
!
defined
(
MediaDecoder_h_
)
#
define
MediaDecoder_h_
#
include
"
BackgroundVideoDecodingPermissionObserver
.
h
"
#
include
"
DecoderDoctorDiagnostics
.
h
"
#
include
"
MediaContainerType
.
h
"
#
include
"
MediaDecoderOwner
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaPromiseDefs
.
h
"
#
include
"
MediaResource
.
h
"
#
include
"
MediaStatistics
.
h
"
#
include
"
SeekTarget
.
h
"
#
include
"
TelemetryProbesReporter
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
CDMProxy
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
mozilla
/
StateWatching
.
h
"
#
include
"
mozilla
/
dom
/
MediaDebugInfoBinding
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsITimer
.
h
"
class
AudioDeviceInfo
;
class
nsIPrincipal
;
namespace
mozilla
{
class
AbstractThread
;
class
DOMMediaStream
;
class
DecoderBenchmark
;
class
ProcessedMediaTrack
;
class
FrameStatistics
;
class
VideoFrameContainer
;
class
MediaFormatReader
;
class
MediaDecoderStateMachineBase
;
struct
MediaPlaybackEvent
;
struct
SharedDummyTrack
;
template
<
typename
T
>
struct
DurationToType
{
double
operator
(
)
(
double
aDouble
)
;
double
operator
(
)
(
const
media
:
:
TimeUnit
&
aTimeUnit
)
;
}
;
template
<
>
struct
DurationToType
<
double
>
{
double
operator
(
)
(
double
aDouble
)
{
return
aDouble
;
}
double
operator
(
)
(
const
media
:
:
TimeUnit
&
aTimeUnit
)
{
if
(
aTimeUnit
.
IsValid
(
)
)
{
if
(
aTimeUnit
.
IsPosInf
(
)
)
{
return
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
if
(
aTimeUnit
.
IsNegInf
(
)
)
{
return
-
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
return
aTimeUnit
.
ToSeconds
(
)
;
}
return
std
:
:
numeric_limits
<
double
>
:
:
quiet_NaN
(
)
;
}
}
;
using
DurationToDouble
=
DurationToType
<
double
>
;
template
<
>
struct
DurationToType
<
media
:
:
TimeUnit
>
{
media
:
:
TimeUnit
operator
(
)
(
double
aDouble
)
{
return
media
:
:
TimeUnit
:
:
FromSeconds
(
aDouble
)
;
}
media
:
:
TimeUnit
operator
(
)
(
const
media
:
:
TimeUnit
&
aTimeUnit
)
{
return
aTimeUnit
;
}
}
;
using
DurationToTimeUnit
=
DurationToType
<
media
:
:
TimeUnit
>
;
struct
MOZ_STACK_CLASS
MediaDecoderInit
{
MediaDecoderOwner
*
const
mOwner
;
TelemetryProbesReporterOwner
*
const
mReporterOwner
;
const
double
mVolume
;
const
bool
mPreservesPitch
;
const
double
mPlaybackRate
;
const
bool
mMinimizePreroll
;
const
bool
mHasSuspendTaint
;
const
bool
mLooping
;
const
MediaContainerType
mContainerType
;
const
nsAutoString
mStreamName
;
MediaDecoderInit
(
MediaDecoderOwner
*
aOwner
TelemetryProbesReporterOwner
*
aReporterOwner
double
aVolume
bool
aPreservesPitch
double
aPlaybackRate
bool
aMinimizePreroll
bool
aHasSuspendTaint
bool
aLooping
const
MediaContainerType
&
aContainerType
)
:
mOwner
(
aOwner
)
mReporterOwner
(
aReporterOwner
)
mVolume
(
aVolume
)
mPreservesPitch
(
aPreservesPitch
)
mPlaybackRate
(
aPlaybackRate
)
mMinimizePreroll
(
aMinimizePreroll
)
mHasSuspendTaint
(
aHasSuspendTaint
)
mLooping
(
aLooping
)
mContainerType
(
aContainerType
)
{
}
}
;
DDLoggedTypeDeclName
(
MediaDecoder
)
;
class
MediaDecoder
:
public
DecoderDoctorLifeLogger
<
MediaDecoder
>
{
public
:
typedef
MozPromise
<
bool
bool
true
>
SeekPromise
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDecoder
)
enum
PlayState
{
PLAY_STATE_LOADING
PLAY_STATE_PAUSED
PLAY_STATE_PLAYING
PLAY_STATE_ENDED
PLAY_STATE_SHUTDOWN
}
;
static
void
InitStatics
(
)
;
explicit
MediaDecoder
(
MediaDecoderInit
&
aInit
)
;
const
MediaContainerType
&
ContainerType
(
)
const
{
return
mContainerType
;
}
virtual
void
Shutdown
(
)
;
void
NotifyXPCOMShutdown
(
)
;
void
NetworkError
(
const
MediaResult
&
aError
)
;
virtual
already_AddRefed
<
nsIPrincipal
>
GetCurrentPrincipal
(
)
=
0
;
virtual
bool
HadCrossOriginRedirects
(
)
=
0
;
virtual
double
GetCurrentTime
(
)
;
void
Seek
(
double
aTime
SeekTarget
:
:
Type
aSeekType
)
;
virtual
void
Play
(
)
;
virtual
void
NotifyOwnerActivityChanged
(
bool
aIsOwnerInvisible
bool
aIsOwnerConnected
)
;
virtual
void
Pause
(
)
;
void
SetVolume
(
double
aVolume
)
;
void
SetPlaybackRate
(
double
aPlaybackRate
)
;
void
SetPreservesPitch
(
bool
aPreservesPitch
)
;
void
SetLooping
(
bool
aLooping
)
;
void
SetStreamName
(
const
nsAutoString
&
aStreamName
)
;
RefPtr
<
GenericPromise
>
SetSink
(
AudioDeviceInfo
*
aSinkDevice
)
;
bool
GetMinimizePreroll
(
)
const
{
return
mMinimizePreroll
;
}
void
SetDelaySeekMode
(
bool
aShouldDelaySeek
)
;
enum
class
OutputCaptureState
{
Capture
Halt
None
}
;
const
char
*
OutputCaptureStateToStr
(
OutputCaptureState
aState
)
const
{
switch
(
aState
)
{
case
OutputCaptureState
:
:
Capture
:
return
"
Capture
"
;
case
OutputCaptureState
:
:
Halt
:
return
"
Halt
"
;
case
OutputCaptureState
:
:
None
:
return
"
None
"
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Not
defined
state
!
"
)
;
return
"
Not
-
defined
"
;
}
}
void
SetOutputCaptureState
(
OutputCaptureState
aState
SharedDummyTrack
*
aDummyTrack
=
nullptr
)
;
void
AddOutputTrack
(
RefPtr
<
ProcessedMediaTrack
>
aTrack
)
;
void
RemoveOutputTrack
(
const
RefPtr
<
ProcessedMediaTrack
>
&
aTrack
)
;
void
SetOutputTracksPrincipal
(
const
RefPtr
<
nsIPrincipal
>
&
aPrincipal
)
;
virtual
double
GetDuration
(
)
;
bool
IsInfinite
(
)
const
;
bool
IsSeeking
(
)
const
;
bool
IsEnded
(
)
const
;
virtual
bool
IsMSE
(
)
const
{
return
false
;
}
bool
OwnerHasError
(
)
const
;
bool
IsMediaSeekable
(
)
;
virtual
bool
IsTransportSeekable
(
)
=
0
;
virtual
media
:
:
TimeIntervals
GetSeekable
(
)
;
virtual
media
:
:
TimeRanges
GetSeekableTimeRanges
(
)
;
template
<
typename
T
>
T
GetSeekableImpl
(
)
;
virtual
void
SetFragmentEndTime
(
double
aTime
)
;
void
Invalidate
(
)
;
void
InvalidateWithFlags
(
uint32_t
aFlags
)
;
virtual
void
Suspend
(
)
;
virtual
void
Resume
(
)
;
virtual
void
SetLoadInBackground
(
bool
aLoadInBackground
)
{
}
MediaDecoderStateMachineBase
*
GetStateMachine
(
)
const
;
void
SetStateMachine
(
MediaDecoderStateMachineBase
*
aStateMachine
)
;
virtual
media
:
:
TimeIntervals
GetBuffered
(
)
;
size_t
SizeOfVideoQueue
(
)
;
size_t
SizeOfAudioQueue
(
)
;
struct
ResourceSizes
{
typedef
MozPromise
<
size_t
size_t
true
>
SizeOfPromise
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ResourceSizes
)
explicit
ResourceSizes
(
MallocSizeOf
aMallocSizeOf
)
:
mMallocSizeOf
(
aMallocSizeOf
)
mByteSize
(
0
)
mCallback
(
)
{
}
mozilla
:
:
MallocSizeOf
mMallocSizeOf
;
mozilla
:
:
Atomic
<
size_t
>
mByteSize
;
RefPtr
<
SizeOfPromise
>
Promise
(
)
{
return
mCallback
.
Ensure
(
__func__
)
;
}
private
:
~
ResourceSizes
(
)
{
mCallback
.
ResolveIfExists
(
mByteSize
__func__
)
;
}
MozPromiseHolder
<
SizeOfPromise
>
mCallback
;
}
;
virtual
void
AddSizeOfResources
(
ResourceSizes
*
aSizes
)
=
0
;
VideoFrameContainer
*
GetVideoFrameContainer
(
)
{
return
mVideoFrameContainer
;
}
layers
:
:
ImageContainer
*
GetImageContainer
(
)
;
bool
CanPlayThrough
(
)
;
virtual
void
SetElementVisibility
(
bool
aIsOwnerInvisible
bool
aIsOwnerConnected
)
;
void
SetForcedHidden
(
bool
aForcedHidden
)
;
void
SetSuspendTaint
(
bool
aTaint
)
;
bool
HasSuspendTaint
(
)
const
;
void
UpdateVideoDecodeMode
(
)
;
void
SetSecondaryVideoContainer
(
const
RefPtr
<
VideoFrameContainer
>
&
aSecondaryVideoContainer
)
;
void
SetIsBackgroundVideoDecodingAllowed
(
bool
aAllowed
)
;
bool
IsVideoDecodingSuspended
(
)
const
;
bool
ShouldResistFingerprinting
(
)
const
{
return
mShouldResistFingerprinting
;
}
virtual
void
ChangeState
(
PlayState
aState
)
;
void
PlaybackEnded
(
)
;
void
OnSeekRejected
(
)
;
void
OnSeekResolved
(
)
;
void
SeekingStarted
(
)
;
void
UpdateLogicalPositionInternal
(
)
;
void
UpdateLogicalPosition
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsShutdown
(
)
)
;
if
(
mPlayState
=
=
PLAY_STATE_PAUSED
|
|
IsSeeking
(
)
)
{
return
;
}
UpdateLogicalPositionInternal
(
)
;
}
int64_t
GetDownloadPosition
(
)
;
void
DecodeError
(
const
MediaResult
&
aError
)
;
void
UpdateSameOriginStatus
(
bool
aSameOrigin
)
;
MediaDecoderOwner
*
GetOwner
(
)
const
;
AbstractThread
*
AbstractMainThread
(
)
const
{
return
mAbstractMainThread
;
}
RefPtr
<
SetCDMPromise
>
SetCDMProxy
(
CDMProxy
*
aProxy
)
;
void
EnsureTelemetryReported
(
)
;
static
bool
IsOggEnabled
(
)
;
static
bool
IsOpusEnabled
(
)
;
static
bool
IsWaveEnabled
(
)
;
static
bool
IsWebMEnabled
(
)
;
FrameStatistics
&
GetFrameStatistics
(
)
{
return
*
mFrameStats
;
}
void
UpdateReadyState
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsShutdown
(
)
)
;
GetOwner
(
)
-
>
UpdateReadyState
(
)
;
}
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameStatus
(
)
const
{
return
mNextFrameStatus
;
}
virtual
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameBufferedStatus
(
)
;
RefPtr
<
GenericPromise
>
RequestDebugInfo
(
dom
:
:
MediaDecoderDebugInfo
&
aInfo
)
;
void
GetDebugInfo
(
dom
:
:
MediaDecoderDebugInfo
&
aInfo
)
;
virtual
bool
IsHLSDecoder
(
)
const
{
return
false
;
}
protected
:
virtual
~
MediaDecoder
(
)
;
virtual
void
FirstFrameLoaded
(
UniquePtr
<
MediaInfo
>
aInfo
MediaDecoderEventVisibility
aEventVisibility
)
;
nsresult
CreateAndInitStateMachine
(
bool
aIsLiveStream
bool
aDisableExternalEngine
=
false
)
;
virtual
MediaDecoderStateMachineBase
*
CreateStateMachine
(
bool
aDisableExternalEngine
)
MOZ_NONNULL_RETURN
=
0
;
void
SetStateMachineParameters
(
)
;
void
DisconnectEvents
(
)
;
RefPtr
<
ShutdownPromise
>
ShutdownStateMachine
(
)
;
virtual
void
ShutdownInternal
(
)
;
bool
IsShutdown
(
)
const
;
virtual
void
DurationChanged
(
)
;
WatchManager
<
MediaDecoder
>
mWatchManager
;
double
ExplicitDuration
(
)
{
return
mExplicitDuration
.
ref
(
)
;
}
void
SetExplicitDuration
(
double
aValue
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsShutdown
(
)
)
;
mExplicitDuration
=
Some
(
aValue
)
;
DurationChanged
(
)
;
}
virtual
void
OnPlaybackEvent
(
MediaPlaybackEvent
&
&
aEvent
)
;
virtual
void
MetadataLoaded
(
UniquePtr
<
MediaInfo
>
aInfo
UniquePtr
<
MetadataTags
>
aTags
MediaDecoderEventVisibility
aEventVisibility
)
;
void
SetLogicalPosition
(
const
media
:
:
TimeUnit
&
aNewPosition
)
;
double
mLogicalPosition
;
virtual
media
:
:
TimeUnit
CurrentPosition
(
)
{
return
mCurrentPosition
.
Ref
(
)
;
}
already_AddRefed
<
layers
:
:
KnowsCompositor
>
GetCompositor
(
)
;
Variant
<
media
:
:
TimeUnit
double
>
mDuration
;
RefPtr
<
MediaFormatReader
>
mReader
;
static
constexpr
auto
DEFAULT_NEXT_FRAME_AVAILABLE_BUFFERED
=
media
:
:
TimeUnit
:
:
FromMicroseconds
(
250000
)
;
private
:
void
NotifyCompositor
(
)
;
void
OnPlaybackErrorEvent
(
const
MediaResult
&
aError
)
;
void
OnDecoderDoctorEvent
(
DecoderDoctorEvent
aEvent
)
;
void
OnMediaNotSeekable
(
)
{
mMediaSeekable
=
false
;
}
void
OnNextFrameStatus
(
MediaDecoderOwner
:
:
NextFrameStatus
)
;
void
OnTrackInfoUpdated
(
const
VideoInfo
&
aVideoInfo
const
AudioInfo
&
aAudioInfo
)
;
void
OnSecondaryVideoContainerInstalled
(
const
RefPtr
<
VideoFrameContainer
>
&
aSecondaryVideoContainer
)
;
void
OnStoreDecoderBenchmark
(
const
VideoInfo
&
aInfo
)
;
void
FinishShutdown
(
)
;
void
ConnectMirrors
(
MediaDecoderStateMachineBase
*
aObject
)
;
void
DisconnectMirrors
(
)
;
virtual
bool
CanPlayThroughImpl
(
)
=
0
;
RefPtr
<
MediaDecoderStateMachineBase
>
mDecoderStateMachine
;
protected
:
void
NotifyReaderDataArrived
(
)
;
void
DiscardOngoingSeekIfExists
(
)
;
void
CallSeek
(
const
SeekTarget
&
aTarget
)
;
virtual
void
NotifyPrincipalChanged
(
)
;
MozPromiseRequestHolder
<
SeekPromise
>
mSeekRequest
;
const
char
*
PlayStateStr
(
)
;
void
OnMetadataUpdate
(
TimedMetadata
&
&
aMetadata
)
;
MediaDecoderOwner
*
mOwner
;
const
RefPtr
<
AbstractThread
>
mAbstractMainThread
;
const
RefPtr
<
FrameStatistics
>
mFrameStats
;
RefPtr
<
DecoderBenchmark
>
mDecoderBenchmark
;
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
const
bool
mMinimizePreroll
;
bool
mFiredMetadataLoaded
;
bool
mMediaSeekable
=
true
;
bool
mMediaSeekableOnlyInBufferedRanges
=
false
;
UniquePtr
<
MediaInfo
>
mInfo
;
bool
mIsOwnerInvisible
;
bool
mIsOwnerConnected
;
bool
mForcedHidden
;
bool
mHasSuspendTaint
;
const
bool
mShouldResistFingerprinting
;
MediaDecoderOwner
:
:
NextFrameStatus
mNextFrameStatus
=
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE
;
MediaEventListener
mTimedMetadataListener
;
MediaEventListener
mMetadataLoadedListener
;
MediaEventListener
mFirstFrameLoadedListener
;
MediaEventListener
mOnPlaybackEvent
;
MediaEventListener
mOnPlaybackErrorEvent
;
MediaEventListener
mOnDecoderDoctorEvent
;
MediaEventListener
mOnMediaNotSeekable
;
MediaEventListener
mOnEncrypted
;
MediaEventListener
mOnWaitingForKey
;
MediaEventListener
mOnDecodeWarning
;
MediaEventListener
mOnNextFrameStatus
;
MediaEventListener
mOnTrackInfoUpdated
;
MediaEventListener
mOnSecondaryVideoContainerInstalled
;
MediaEventListener
mOnStoreDecoderBenchmark
;
bool
mIsVideoDecodingSuspended
=
false
;
protected
:
double
mPlaybackRate
;
Watchable
<
bool
>
mLogicallySeeking
;
Mirror
<
media
:
:
TimeIntervals
>
mBuffered
;
Mirror
<
media
:
:
TimeUnit
>
mCurrentPosition
;
Mirror
<
media
:
:
NullableTimeUnit
>
mStateMachineDuration
;
Mirror
<
bool
>
mIsAudioDataAudible
;
Canonical
<
double
>
mVolume
;
Canonical
<
bool
>
mPreservesPitch
;
Canonical
<
bool
>
mLooping
;
Canonical
<
nsAutoString
>
mStreamName
;
Canonical
<
RefPtr
<
AudioDeviceInfo
>
>
mSinkDevice
;
Canonical
<
RefPtr
<
VideoFrameContainer
>
>
mSecondaryVideoContainer
;
Canonical
<
OutputCaptureState
>
mOutputCaptureState
;
Canonical
<
nsMainThreadPtrHandle
<
SharedDummyTrack
>
>
mOutputDummyTrack
;
Canonical
<
CopyableTArray
<
RefPtr
<
ProcessedMediaTrack
>
>
>
mOutputTracks
;
Canonical
<
PrincipalHandle
>
mOutputPrincipal
;
Maybe
<
double
>
mExplicitDuration
;
Canonical
<
PlayState
>
mPlayState
;
PlayState
mNextState
=
PLAY_STATE_PAUSED
;
bool
mSameOriginMedia
;
RefPtr
<
BackgroundVideoDecodingPermissionObserver
>
mVideoDecodingOberver
;
bool
mIsBackgroundVideoDecodingAllowed
;
bool
mShouldDelaySeek
=
false
;
Maybe
<
SeekTarget
>
mDelayedSeekTarget
;
#
ifdef
MOZ_WMF_MEDIA_ENGINE
bool
mStateMachineRecreated
=
false
;
#
endif
public
:
Canonical
<
double
>
&
CanonicalVolume
(
)
{
return
mVolume
;
}
Canonical
<
bool
>
&
CanonicalPreservesPitch
(
)
{
return
mPreservesPitch
;
}
Canonical
<
bool
>
&
CanonicalLooping
(
)
{
return
mLooping
;
}
Canonical
<
nsAutoString
>
&
CanonicalStreamName
(
)
{
return
mStreamName
;
}
Canonical
<
RefPtr
<
AudioDeviceInfo
>
>
&
CanonicalSinkDevice
(
)
{
return
mSinkDevice
;
}
Canonical
<
RefPtr
<
VideoFrameContainer
>
>
&
CanonicalSecondaryVideoContainer
(
)
{
return
mSecondaryVideoContainer
;
}
Canonical
<
OutputCaptureState
>
&
CanonicalOutputCaptureState
(
)
{
return
mOutputCaptureState
;
}
Canonical
<
nsMainThreadPtrHandle
<
SharedDummyTrack
>
>
&
CanonicalOutputDummyTrack
(
)
{
return
mOutputDummyTrack
;
}
Canonical
<
CopyableTArray
<
RefPtr
<
ProcessedMediaTrack
>
>
>
&
CanonicalOutputTracks
(
)
{
return
mOutputTracks
;
}
Canonical
<
PrincipalHandle
>
&
CanonicalOutputPrincipal
(
)
{
return
mOutputPrincipal
;
}
Canonical
<
PlayState
>
&
CanonicalPlayState
(
)
{
return
mPlayState
;
}
void
UpdateTelemetryHelperBasedOnPlayState
(
PlayState
aState
)
const
;
TelemetryProbesReporter
:
:
Visibility
OwnerVisibility
(
)
const
;
double
GetTotalVideoPlayTimeInSeconds
(
)
const
;
double
GetTotalVideoHDRPlayTimeInSeconds
(
)
const
;
double
GetVisibleVideoPlayTimeInSeconds
(
)
const
;
double
GetInvisibleVideoPlayTimeInSeconds
(
)
const
;
double
GetVideoDecodeSuspendedTimeInSeconds
(
)
const
;
double
GetTotalAudioPlayTimeInSeconds
(
)
const
;
double
GetAudiblePlayTimeInSeconds
(
)
const
;
double
GetInaudiblePlayTimeInSeconds
(
)
const
;
double
GetMutedPlayTimeInSeconds
(
)
const
;
private
:
enum
class
PositionUpdate
{
ePeriodicUpdate
eSeamlessLoopingSeeking
eOther
}
;
PositionUpdate
GetPositionUpdateReason
(
double
aPrevPos
const
media
:
:
TimeUnit
&
aCurPos
)
const
;
void
NotifyAudibleStateChanged
(
)
;
void
NotifyVolumeChanged
(
)
;
bool
mTelemetryReported
;
const
MediaContainerType
mContainerType
;
bool
mCanPlayThrough
=
false
;
UniquePtr
<
TelemetryProbesReporter
>
mTelemetryProbesReporter
;
#
ifdef
MOZ_WMF_MEDIA_ENGINE
bool
mPendingStatusUpdateForNewlyCreatedStateMachine
=
false
;
#
endif
Maybe
<
TimeStamp
>
mMDSMCreationTime
;
}
;
}
#
endif
