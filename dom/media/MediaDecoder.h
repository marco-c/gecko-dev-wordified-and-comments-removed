#
if
!
defined
(
MediaDecoder_h_
)
#
define
MediaDecoder_h_
#
ifdef
MOZ_EME
#
include
"
mozilla
/
CDMProxy
.
h
"
#
endif
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
mozilla
/
StateWatching
.
h
"
#
include
"
mozilla
/
dom
/
AudioChannelBinding
.
h
"
#
include
"
necko
-
config
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
AbstractMediaDecoder
.
h
"
#
include
"
MediaDecoderOwner
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaResource
.
h
"
#
include
"
MediaResourceCallback
.
h
"
#
include
"
MediaStatistics
.
h
"
#
include
"
MediaStreamGraph
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
SeekTarget
.
h
"
class
nsIStreamListener
;
class
nsIPrincipal
;
namespace
mozilla
{
namespace
dom
{
class
Promise
;
}
class
VideoFrameContainer
;
class
MediaDecoderStateMachine
;
enum
class
MediaEventType
:
int8_t
;
#
ifdef
GetCurrentTime
#
undef
GetCurrentTime
#
endif
class
MediaDecoder
:
public
AbstractMediaDecoder
{
public
:
struct
SeekResolveValue
{
SeekResolveValue
(
bool
aAtEnd
MediaDecoderEventVisibility
aEventVisibility
)
:
mAtEnd
(
aAtEnd
)
mEventVisibility
(
aEventVisibility
)
{
}
bool
mAtEnd
;
MediaDecoderEventVisibility
mEventVisibility
;
}
;
class
ResourceCallback
:
public
MediaResourceCallback
{
static
const
uint32_t
sDelay
=
500
;
public
:
void
Connect
(
MediaDecoder
*
aDecoder
)
;
void
Disconnect
(
)
;
private
:
MediaDecoderOwner
*
GetMediaOwner
(
)
const
override
;
void
SetInfinite
(
bool
aInfinite
)
override
;
void
SetMediaSeekable
(
bool
aMediaSeekable
)
override
;
void
NotifyNetworkError
(
)
override
;
void
NotifyDecodeError
(
)
override
;
void
NotifyDataArrived
(
)
override
;
void
NotifyBytesDownloaded
(
)
override
;
void
NotifyDataEnded
(
nsresult
aStatus
)
override
;
void
NotifyPrincipalChanged
(
)
override
;
void
NotifySuspendedStatusChanged
(
)
override
;
void
NotifyBytesConsumed
(
int64_t
aBytes
int64_t
aOffset
)
override
;
static
void
TimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
MediaDecoder
*
mDecoder
=
nullptr
;
nsCOMPtr
<
nsITimer
>
mTimer
;
bool
mTimerArmed
=
false
;
}
;
typedef
MozPromise
<
SeekResolveValue
bool
true
>
SeekPromise
;
NS_DECL_THREADSAFE_ISUPPORTS
enum
PlayState
{
PLAY_STATE_START
PLAY_STATE_LOADING
PLAY_STATE_PAUSED
PLAY_STATE_PLAYING
PLAY_STATE_ENDED
PLAY_STATE_SHUTDOWN
}
;
static
void
InitStatics
(
)
;
explicit
MediaDecoder
(
MediaDecoderOwner
*
aOwner
)
;
MediaResourceCallback
*
GetResourceCallback
(
)
const
;
virtual
MediaDecoder
*
Clone
(
MediaDecoderOwner
*
aOwner
)
=
0
;
virtual
MediaDecoderStateMachine
*
CreateStateMachine
(
)
=
0
;
virtual
void
Shutdown
(
)
;
virtual
nsresult
Load
(
nsIStreamListener
*
*
aListener
)
;
nsresult
OpenResource
(
nsIStreamListener
*
*
aStreamListener
)
;
void
NetworkError
(
)
;
MediaResource
*
GetResource
(
)
const
final
override
{
return
mResource
;
}
void
SetResource
(
MediaResource
*
aResource
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mResource
=
aResource
;
}
virtual
already_AddRefed
<
nsIPrincipal
>
GetCurrentPrincipal
(
)
;
virtual
double
GetCurrentTime
(
)
;
virtual
nsresult
Seek
(
double
aTime
SeekTarget
:
:
Type
aSeekType
dom
:
:
Promise
*
aPromise
=
nullptr
)
;
nsresult
InitializeStateMachine
(
)
;
virtual
nsresult
Play
(
)
;
virtual
void
NotifyOwnerActivityChanged
(
bool
aIsVisible
)
;
void
UpdateDormantState
(
bool
aDormantTimeout
bool
aActivity
)
;
virtual
void
Pause
(
)
;
virtual
void
SetVolume
(
double
aVolume
)
;
virtual
void
SetPlaybackRate
(
double
aPlaybackRate
)
;
void
SetPreservesPitch
(
bool
aPreservesPitch
)
;
void
SetMinimizePrerollUntilPlaybackStarts
(
)
;
virtual
void
AddOutputStream
(
ProcessedMediaStream
*
aStream
bool
aFinishWhenEnded
)
;
virtual
void
RemoveOutputStream
(
MediaStream
*
aStream
)
;
virtual
double
GetDuration
(
)
;
bool
IsInfinite
(
)
const
;
virtual
void
NotifyBytesDownloaded
(
)
;
void
NotifyDataArrived
(
)
;
bool
IsSeeking
(
)
const
;
bool
IsEnded
(
)
const
;
bool
OwnerHasError
(
)
const
;
already_AddRefed
<
GMPCrashHelper
>
GetCrashHelper
(
)
override
;
protected
:
void
UpdateEstimatedMediaDuration
(
int64_t
aDuration
)
override
;
public
:
void
SetMediaSeekable
(
bool
aMediaSeekable
)
;
void
SetMediaSeekableOnlyInBufferedRanges
(
bool
aMediaSeekableOnlyInBufferedRanges
)
;
bool
IsMediaSeekable
(
)
;
bool
IsMediaSeekableOnlyInBufferedRanges
(
)
;
bool
IsTransportSeekable
(
)
;
virtual
media
:
:
TimeIntervals
GetSeekable
(
)
;
virtual
void
SetFragmentEndTime
(
double
aTime
)
;
void
Invalidate
(
)
;
void
InvalidateWithFlags
(
uint32_t
aFlags
)
;
virtual
void
Suspend
(
)
;
virtual
void
Resume
(
)
;
void
SetLoadInBackground
(
bool
aLoadInBackground
)
;
MediaDecoderStateMachine
*
GetStateMachine
(
)
const
;
void
SetStateMachine
(
MediaDecoderStateMachine
*
aStateMachine
)
;
virtual
media
:
:
TimeIntervals
GetBuffered
(
)
;
size_t
SizeOfVideoQueue
(
)
;
size_t
SizeOfAudioQueue
(
)
;
struct
ResourceSizes
{
typedef
MozPromise
<
size_t
size_t
true
>
SizeOfPromise
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ResourceSizes
)
explicit
ResourceSizes
(
MallocSizeOf
aMallocSizeOf
)
:
mMallocSizeOf
(
aMallocSizeOf
)
mByteSize
(
0
)
mCallback
(
)
{
}
mozilla
:
:
MallocSizeOf
mMallocSizeOf
;
mozilla
:
:
Atomic
<
size_t
>
mByteSize
;
RefPtr
<
SizeOfPromise
>
Promise
(
)
{
return
mCallback
.
Ensure
(
__func__
)
;
}
private
:
~
ResourceSizes
(
)
{
mCallback
.
ResolveIfExists
(
mByteSize
__func__
)
;
}
MozPromiseHolder
<
SizeOfPromise
>
mCallback
;
}
;
virtual
void
AddSizeOfResources
(
ResourceSizes
*
aSizes
)
;
VideoFrameContainer
*
GetVideoFrameContainer
(
)
final
override
{
return
mVideoFrameContainer
;
}
layers
:
:
ImageContainer
*
GetImageContainer
(
)
override
;
void
FireTimeUpdate
(
)
;
virtual
void
UpdatePlaybackRate
(
)
;
void
ComputePlaybackRate
(
)
;
virtual
bool
CanPlayThrough
(
)
;
void
SetAudioChannel
(
dom
:
:
AudioChannel
aChannel
)
{
mAudioChannel
=
aChannel
;
}
dom
:
:
AudioChannel
GetAudioChannel
(
)
{
return
mAudioChannel
;
}
virtual
void
SetElementVisibility
(
bool
aIsVisible
)
;
void
SetForcedHidden
(
bool
aForcedHidden
)
;
virtual
void
ChangeState
(
PlayState
aState
)
;
void
ConstructMediaTracks
(
)
;
void
RemoveMediaTracks
(
)
;
void
PlaybackEnded
(
)
;
void
OnSeekRejected
(
)
;
void
OnSeekResolved
(
SeekResolveValue
aVal
)
;
void
SeekingChanged
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mIgnoreProgressData
=
mLogicallySeeking
;
}
void
SeekingStarted
(
)
;
void
UpdateLogicalPositionInternal
(
MediaDecoderEventVisibility
aEventVisibility
)
;
void
UpdateLogicalPosition
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
IsShutdown
(
)
)
;
if
(
mPlayState
=
=
PLAY_STATE_PAUSED
|
|
IsSeeking
(
)
)
{
return
;
}
UpdateLogicalPositionInternal
(
MediaDecoderEventVisibility
:
:
Observable
)
;
}
int64_t
GetDownloadPosition
(
)
;
void
DecodeError
(
const
MediaResult
&
aError
)
;
void
UpdateSameOriginStatus
(
bool
aSameOrigin
)
;
MediaDecoderOwner
*
GetOwner
(
)
const
override
;
#
ifdef
MOZ_EME
typedef
MozPromise
<
RefPtr
<
CDMProxy
>
bool
true
>
CDMProxyPromise
;
RefPtr
<
CDMProxyPromise
>
RequestCDMProxy
(
)
const
;
void
SetCDMProxy
(
CDMProxy
*
aProxy
)
;
#
endif
void
EnsureTelemetryReported
(
)
;
static
bool
IsOggEnabled
(
)
;
static
bool
IsOpusEnabled
(
)
;
static
bool
IsWaveEnabled
(
)
;
static
bool
IsWebMEnabled
(
)
;
#
ifdef
MOZ_OMX_DECODER
static
bool
IsOmxEnabled
(
)
;
#
endif
#
ifdef
MOZ_ANDROID_OMX
static
bool
IsAndroidMediaPluginEnabled
(
)
;
#
endif
#
ifdef
MOZ_WMF
static
bool
IsWMFEnabled
(
)
;
#
endif
MediaStatistics
GetStatistics
(
)
;
FrameStatistics
&
GetFrameStatistics
(
)
{
return
*
mFrameStats
;
}
virtual
void
NotifyDecodedFrames
(
const
FrameStatisticsData
&
aStats
)
override
{
GetFrameStatistics
(
)
.
NotifyDecodedFrames
(
aStats
)
;
}
void
UpdateReadyState
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
IsShutdown
(
)
)
;
mOwner
-
>
UpdateReadyState
(
)
;
}
virtual
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameStatus
(
)
{
return
mNextFrameStatus
;
}
virtual
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameBufferedStatus
(
)
;
virtual
void
GetMozDebugReaderData
(
nsAString
&
aString
)
{
}
virtual
void
DumpDebugInfo
(
)
;
protected
:
virtual
~
MediaDecoder
(
)
;
virtual
void
FirstFrameLoaded
(
nsAutoPtr
<
MediaInfo
>
aInfo
MediaDecoderEventVisibility
aEventVisibility
)
;
void
SetStateMachineParameters
(
)
;
static
void
DormantTimerExpired
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
StartDormantTimer
(
)
;
void
CancelDormantTimer
(
)
;
bool
IsShutdown
(
)
const
;
void
DurationChanged
(
)
;
WatchManager
<
MediaDecoder
>
mWatchManager
;
virtual
void
ShutdownBitChanged
(
)
{
}
double
ExplicitDuration
(
)
{
return
mExplicitDuration
.
Ref
(
)
.
ref
(
)
;
}
void
SetExplicitDuration
(
double
aValue
)
{
MOZ_ASSERT
(
!
IsShutdown
(
)
)
;
mExplicitDuration
.
Set
(
Some
(
aValue
)
)
;
DurationChanged
(
)
;
}
bool
mDormantSupported
;
double
mLogicalPosition
;
virtual
int64_t
CurrentPosition
(
)
{
return
mCurrentPosition
;
}
double
mDuration
;
RefPtr
<
MediaResource
>
mResource
;
static
const
int
DEFAULT_NEXT_FRAME_AVAILABLE_BUFFERED
=
250000
;
private
:
void
MetadataLoaded
(
nsAutoPtr
<
MediaInfo
>
aInfo
nsAutoPtr
<
MetadataTags
>
aTags
MediaDecoderEventVisibility
aEventVisibility
)
;
MediaEventSource
<
void
>
*
DataArrivedEvent
(
)
override
{
return
&
mDataArrivedEvent
;
}
void
OnPlaybackEvent
(
MediaEventType
aEvent
)
;
void
OnPlaybackErrorEvent
(
const
MediaResult
&
aError
)
;
void
OnMediaNotSeekable
(
)
{
SetMediaSeekable
(
false
)
;
}
void
FinishShutdown
(
)
;
void
ConnectMirrors
(
MediaDecoderStateMachine
*
aObject
)
;
void
DisconnectMirrors
(
)
;
MediaEventProducer
<
void
>
mDataArrivedEvent
;
RefPtr
<
MediaDecoderStateMachine
>
mDecoderStateMachine
;
RefPtr
<
ResourceCallback
>
mResourceCallback
;
#
ifdef
MOZ_EME
MozPromiseHolder
<
CDMProxyPromise
>
mCDMProxyPromiseHolder
;
RefPtr
<
CDMProxyPromise
>
mCDMProxyPromise
;
#
endif
protected
:
void
AsyncResolveSeekDOMPromiseIfExists
(
)
;
void
AsyncRejectSeekDOMPromiseIfExists
(
)
;
void
DiscardOngoingSeekIfExists
(
)
;
virtual
void
CallSeek
(
const
SeekTarget
&
aTarget
dom
:
:
Promise
*
aPromise
)
;
bool
IsHeuristicDormantSupported
(
)
const
;
MozPromiseRequestHolder
<
SeekPromise
>
mSeekRequest
;
RefPtr
<
dom
:
:
Promise
>
mSeekDOMPromise
;
bool
mIgnoreProgressData
;
bool
mInfiniteStream
;
void
PinForSeek
(
)
;
void
UnpinForSeek
(
)
;
const
char
*
PlayStateStr
(
)
;
void
OnMetadataUpdate
(
TimedMetadata
&
&
aMetadata
)
;
MediaDecoderOwner
*
mOwner
;
const
RefPtr
<
FrameStatistics
>
mFrameStats
;
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
RefPtr
<
MediaChannelStatistics
>
mPlaybackStatistics
;
bool
mPinnedForSeek
;
bool
mPausedForPlaybackRateNull
;
dom
:
:
AudioChannel
mAudioChannel
;
bool
mMinimizePreroll
;
bool
mMediaTracksConstructed
;
bool
mFiredMetadataLoaded
;
nsAutoPtr
<
MediaInfo
>
mInfo
;
bool
mElementVisible
;
bool
mForcedHidden
;
bool
mIsDormant
;
const
bool
mIsHeuristicDormantSupported
;
const
int
mHeuristicDormantTimeout
;
bool
mIsHeuristicDormant
;
nsCOMPtr
<
nsITimer
>
mDormantTimer
;
MediaEventListener
mTimedMetadataListener
;
MediaEventListener
mMetadataLoadedListener
;
MediaEventListener
mFirstFrameLoadedListener
;
MediaEventListener
mOnPlaybackEvent
;
MediaEventListener
mOnPlaybackErrorEvent
;
MediaEventListener
mOnMediaNotSeekable
;
protected
:
Mirror
<
bool
>
mStateMachineIsShutdown
;
Mirror
<
media
:
:
TimeIntervals
>
mBuffered
;
Mirror
<
MediaDecoderOwner
:
:
NextFrameStatus
>
mNextFrameStatus
;
Mirror
<
int64_t
>
mCurrentPosition
;
Mirror
<
media
:
:
NullableTimeUnit
>
mStateMachineDuration
;
Mirror
<
int64_t
>
mPlaybackPosition
;
Mirror
<
bool
>
mIsAudioDataAudible
;
Canonical
<
double
>
mVolume
;
Canonical
<
double
>
mPlaybackRate
;
Canonical
<
bool
>
mPreservesPitch
;
Canonical
<
media
:
:
NullableTimeUnit
>
mEstimatedDuration
;
Canonical
<
Maybe
<
double
>
>
mExplicitDuration
;
Canonical
<
PlayState
>
mPlayState
;
Canonical
<
PlayState
>
mNextState
;
Canonical
<
bool
>
mLogicallySeeking
;
Canonical
<
bool
>
mSameOriginMedia
;
Canonical
<
PrincipalHandle
>
mMediaPrincipalHandle
;
Canonical
<
double
>
mPlaybackBytesPerSecond
;
Canonical
<
bool
>
mPlaybackRateReliable
;
Canonical
<
int64_t
>
mDecoderPosition
;
Canonical
<
bool
>
mMediaSeekable
;
Canonical
<
bool
>
mMediaSeekableOnlyInBufferedRanges
;
Canonical
<
bool
>
mIsVisible
;
public
:
AbstractCanonical
<
media
:
:
NullableTimeUnit
>
*
CanonicalDurationOrNull
(
)
override
;
AbstractCanonical
<
double
>
*
CanonicalVolume
(
)
{
return
&
mVolume
;
}
AbstractCanonical
<
double
>
*
CanonicalPlaybackRate
(
)
{
return
&
mPlaybackRate
;
}
AbstractCanonical
<
bool
>
*
CanonicalPreservesPitch
(
)
{
return
&
mPreservesPitch
;
}
AbstractCanonical
<
media
:
:
NullableTimeUnit
>
*
CanonicalEstimatedDuration
(
)
{
return
&
mEstimatedDuration
;
}
AbstractCanonical
<
Maybe
<
double
>
>
*
CanonicalExplicitDuration
(
)
{
return
&
mExplicitDuration
;
}
AbstractCanonical
<
PlayState
>
*
CanonicalPlayState
(
)
{
return
&
mPlayState
;
}
AbstractCanonical
<
PlayState
>
*
CanonicalNextPlayState
(
)
{
return
&
mNextState
;
}
AbstractCanonical
<
bool
>
*
CanonicalLogicallySeeking
(
)
{
return
&
mLogicallySeeking
;
}
AbstractCanonical
<
bool
>
*
CanonicalSameOriginMedia
(
)
{
return
&
mSameOriginMedia
;
}
AbstractCanonical
<
PrincipalHandle
>
*
CanonicalMediaPrincipalHandle
(
)
{
return
&
mMediaPrincipalHandle
;
}
AbstractCanonical
<
double
>
*
CanonicalPlaybackBytesPerSecond
(
)
{
return
&
mPlaybackBytesPerSecond
;
}
AbstractCanonical
<
bool
>
*
CanonicalPlaybackRateReliable
(
)
{
return
&
mPlaybackRateReliable
;
}
AbstractCanonical
<
int64_t
>
*
CanonicalDecoderPosition
(
)
{
return
&
mDecoderPosition
;
}
AbstractCanonical
<
bool
>
*
CanonicalMediaSeekable
(
)
{
return
&
mMediaSeekable
;
}
AbstractCanonical
<
bool
>
*
CanonicalMediaSeekableOnlyInBufferedRanges
(
)
{
return
&
mMediaSeekableOnlyInBufferedRanges
;
}
AbstractCanonical
<
bool
>
*
CanonicalIsVisible
(
)
{
return
&
mIsVisible
;
}
private
:
void
NotifyAudibleStateChanged
(
)
;
void
SetInfinite
(
bool
aInfinite
)
;
void
NotifyPrincipalChanged
(
)
;
void
NotifySuspendedStatusChanged
(
)
;
void
NotifyBytesConsumed
(
int64_t
aBytes
int64_t
aOffset
)
;
void
NotifyDownloadEnded
(
nsresult
aStatus
)
;
bool
mTelemetryReported
;
}
;
}
#
endif
