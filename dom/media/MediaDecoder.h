#
if
!
defined
(
MediaDecoder_h_
)
#
define
MediaDecoder_h_
#
ifdef
MOZ_EME
#
include
"
mozilla
/
CDMProxy
.
h
"
#
endif
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
mozilla
/
StateWatching
.
h
"
#
include
"
mozilla
/
dom
/
AudioChannelBinding
.
h
"
#
include
"
necko
-
config
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
AbstractMediaDecoder
.
h
"
#
include
"
FrameStatistics
.
h
"
#
include
"
MediaDecoderOwner
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaResource
.
h
"
#
include
"
MediaResourceCallback
.
h
"
#
include
"
MediaStatistics
.
h
"
#
include
"
MediaStreamGraph
.
h
"
#
include
"
TimeUnits
.
h
"
class
nsIStreamListener
;
class
nsIPrincipal
;
namespace
mozilla
{
class
VideoFrameContainer
;
class
MediaDecoderStateMachine
;
enum
class
MediaEventType
:
int8_t
;
#
ifdef
GetCurrentTime
#
undef
GetCurrentTime
#
endif
struct
SeekTarget
{
enum
Type
{
Invalid
PrevSyncPoint
Accurate
}
;
SeekTarget
(
)
:
mTime
(
-
1
.
0
)
mType
(
SeekTarget
:
:
Invalid
)
mEventVisibility
(
MediaDecoderEventVisibility
:
:
Observable
)
{
}
SeekTarget
(
int64_t
aTimeUsecs
Type
aType
MediaDecoderEventVisibility
aEventVisibility
=
MediaDecoderEventVisibility
:
:
Observable
)
:
mTime
(
aTimeUsecs
)
mType
(
aType
)
mEventVisibility
(
aEventVisibility
)
{
}
SeekTarget
(
const
SeekTarget
&
aOther
)
:
mTime
(
aOther
.
mTime
)
mType
(
aOther
.
mType
)
mEventVisibility
(
aOther
.
mEventVisibility
)
{
}
bool
IsValid
(
)
const
{
return
mType
!
=
SeekTarget
:
:
Invalid
;
}
void
Reset
(
)
{
mTime
=
-
1
;
mType
=
SeekTarget
:
:
Invalid
;
}
int64_t
mTime
;
Type
mType
;
MediaDecoderEventVisibility
mEventVisibility
;
}
;
class
MediaDecoder
:
public
AbstractMediaDecoder
{
public
:
struct
SeekResolveValue
{
SeekResolveValue
(
bool
aAtEnd
MediaDecoderEventVisibility
aEventVisibility
)
:
mAtEnd
(
aAtEnd
)
mEventVisibility
(
aEventVisibility
)
{
}
bool
mAtEnd
;
MediaDecoderEventVisibility
mEventVisibility
;
}
;
class
ResourceCallback
:
public
MediaResourceCallback
{
public
:
void
Connect
(
MediaDecoder
*
aDecoder
)
;
void
Disconnect
(
)
;
private
:
MediaDecoderOwner
*
GetMediaOwner
(
)
const
override
;
void
SetInfinite
(
bool
aInfinite
)
override
;
void
SetMediaSeekable
(
bool
aMediaSeekable
)
override
;
void
ResetConnectionState
(
)
override
;
nsresult
FinishDecoderSetup
(
MediaResource
*
aResource
)
override
;
void
NotifyNetworkError
(
)
override
;
void
NotifyDecodeError
(
)
override
;
void
NotifyDataArrived
(
)
override
;
void
NotifyBytesDownloaded
(
)
override
;
void
NotifyDataEnded
(
nsresult
aStatus
)
override
;
void
NotifyPrincipalChanged
(
)
override
;
void
NotifySuspendedStatusChanged
(
)
override
;
void
NotifyBytesConsumed
(
int64_t
aBytes
int64_t
aOffset
)
override
;
MediaDecoder
*
mDecoder
=
nullptr
;
}
;
typedef
MozPromise
<
SeekResolveValue
bool
true
>
SeekPromise
;
NS_DECL_THREADSAFE_ISUPPORTS
enum
PlayState
{
PLAY_STATE_START
PLAY_STATE_LOADING
PLAY_STATE_PAUSED
PLAY_STATE_PLAYING
PLAY_STATE_ENDED
PLAY_STATE_SHUTDOWN
}
;
static
void
InitStatics
(
)
;
explicit
MediaDecoder
(
MediaDecoderOwner
*
aOwner
)
;
MediaResourceCallback
*
GetResourceCallback
(
)
const
;
virtual
MediaDecoder
*
Clone
(
MediaDecoderOwner
*
aOwner
)
=
0
;
virtual
MediaDecoderStateMachine
*
CreateStateMachine
(
)
=
0
;
virtual
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
;
virtual
nsresult
Load
(
nsIStreamListener
*
*
aListener
)
;
nsresult
OpenResource
(
nsIStreamListener
*
*
aStreamListener
)
;
void
NetworkError
(
)
;
MediaResource
*
GetResource
(
)
const
final
override
{
return
mResource
;
}
void
SetResource
(
MediaResource
*
aResource
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mResource
=
aResource
;
}
virtual
already_AddRefed
<
nsIPrincipal
>
GetCurrentPrincipal
(
)
;
virtual
double
GetCurrentTime
(
)
;
virtual
nsresult
Seek
(
double
aTime
SeekTarget
:
:
Type
aSeekType
)
;
nsresult
InitializeStateMachine
(
)
;
virtual
nsresult
Play
(
)
;
virtual
void
NotifyOwnerActivityChanged
(
)
;
void
UpdateDormantState
(
bool
aDormantTimeout
bool
aActivity
)
;
virtual
void
Pause
(
)
;
virtual
void
SetVolume
(
double
aVolume
)
;
virtual
void
SetPlaybackRate
(
double
aPlaybackRate
)
;
void
SetPreservesPitch
(
bool
aPreservesPitch
)
;
void
SetMinimizePrerollUntilPlaybackStarts
(
)
;
virtual
void
AddOutputStream
(
ProcessedMediaStream
*
aStream
bool
aFinishWhenEnded
)
;
virtual
void
RemoveOutputStream
(
MediaStream
*
aStream
)
;
virtual
double
GetDuration
(
)
;
virtual
bool
IsInfinite
(
)
;
virtual
void
NotifyBytesDownloaded
(
)
;
void
NotifyDataArrived
(
)
;
virtual
bool
IsSeeking
(
)
const
;
virtual
bool
IsEndedOrShutdown
(
)
const
;
protected
:
void
UpdateEstimatedMediaDuration
(
int64_t
aDuration
)
override
;
public
:
virtual
void
SetElementVisibility
(
bool
aIsVisible
)
{
}
void
SetMediaSeekable
(
bool
aMediaSeekable
)
;
bool
IsMediaSeekable
(
)
;
bool
IsTransportSeekable
(
)
;
virtual
media
:
:
TimeIntervals
GetSeekable
(
)
;
virtual
void
SetFragmentEndTime
(
double
aTime
)
;
void
Invalidate
(
)
;
void
InvalidateWithFlags
(
uint32_t
aFlags
)
;
virtual
void
Suspend
(
)
;
virtual
void
Resume
(
)
;
void
SetLoadInBackground
(
bool
aLoadInBackground
)
;
MediaDecoderStateMachine
*
GetStateMachine
(
)
const
;
void
SetStateMachine
(
MediaDecoderStateMachine
*
aStateMachine
)
;
virtual
media
:
:
TimeIntervals
GetBuffered
(
)
;
size_t
SizeOfVideoQueue
(
)
;
size_t
SizeOfAudioQueue
(
)
;
struct
ResourceSizes
{
typedef
MozPromise
<
size_t
size_t
true
>
SizeOfPromise
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ResourceSizes
)
explicit
ResourceSizes
(
MallocSizeOf
aMallocSizeOf
)
:
mMallocSizeOf
(
aMallocSizeOf
)
mByteSize
(
0
)
mCallback
(
)
{
}
mozilla
:
:
MallocSizeOf
mMallocSizeOf
;
mozilla
:
:
Atomic
<
size_t
>
mByteSize
;
RefPtr
<
SizeOfPromise
>
Promise
(
)
{
return
mCallback
.
Ensure
(
__func__
)
;
}
private
:
~
ResourceSizes
(
)
{
mCallback
.
ResolveIfExists
(
mByteSize
__func__
)
;
}
MozPromiseHolder
<
SizeOfPromise
>
mCallback
;
}
;
virtual
void
AddSizeOfResources
(
ResourceSizes
*
aSizes
)
;
VideoFrameContainer
*
GetVideoFrameContainer
(
)
final
override
{
return
mVideoFrameContainer
;
}
layers
:
:
ImageContainer
*
GetImageContainer
(
)
override
;
void
FireTimeUpdate
(
)
;
virtual
void
UpdatePlaybackRate
(
)
;
void
ComputePlaybackRate
(
)
;
virtual
bool
CanPlayThrough
(
)
;
void
SetAudioChannel
(
dom
:
:
AudioChannel
aChannel
)
{
mAudioChannel
=
aChannel
;
}
dom
:
:
AudioChannel
GetAudioChannel
(
)
{
return
mAudioChannel
;
}
virtual
void
ChangeState
(
PlayState
aState
)
;
void
ConstructMediaTracks
(
)
;
void
RemoveMediaTracks
(
)
;
void
PlaybackEnded
(
)
;
void
OnSeekRejected
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mSeekRequest
.
Complete
(
)
;
mLogicallySeeking
=
false
;
}
void
OnSeekResolved
(
SeekResolveValue
aVal
)
;
void
SeekingChanged
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mIgnoreProgressData
=
mLogicallySeeking
;
}
void
SeekingStarted
(
MediaDecoderEventVisibility
aEventVisibility
=
MediaDecoderEventVisibility
:
:
Observable
)
;
void
UpdateLogicalPosition
(
MediaDecoderEventVisibility
aEventVisibility
)
;
void
UpdateLogicalPosition
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
UpdateLogicalPosition
(
MediaDecoderEventVisibility
:
:
Observable
)
;
}
int64_t
GetDownloadPosition
(
)
;
void
DecodeError
(
)
;
void
UpdateSameOriginStatus
(
bool
aSameOrigin
)
;
MediaDecoderOwner
*
GetOwner
(
)
override
;
#
ifdef
MOZ_EME
typedef
MozPromise
<
RefPtr
<
CDMProxy
>
bool
true
>
CDMProxyPromise
;
RefPtr
<
CDMProxyPromise
>
RequestCDMProxy
(
)
const
;
void
SetCDMProxy
(
CDMProxy
*
aProxy
)
;
#
endif
void
EnsureTelemetryReported
(
)
;
#
ifdef
MOZ_RAW
static
bool
IsRawEnabled
(
)
;
#
endif
static
bool
IsOggEnabled
(
)
;
static
bool
IsOpusEnabled
(
)
;
static
bool
IsWaveEnabled
(
)
;
static
bool
IsWebMEnabled
(
)
;
#
ifdef
NECKO_PROTOCOL_rtsp
static
bool
IsRtspEnabled
(
)
;
#
endif
#
ifdef
MOZ_OMX_DECODER
static
bool
IsOmxEnabled
(
)
;
#
endif
#
ifdef
MOZ_ANDROID_OMX
static
bool
IsAndroidMediaEnabled
(
)
;
#
endif
#
ifdef
MOZ_WMF
static
bool
IsWMFEnabled
(
)
;
#
endif
MediaStatistics
GetStatistics
(
)
;
FrameStatistics
&
GetFrameStatistics
(
)
{
return
*
mFrameStats
;
}
virtual
void
NotifyDecodedFrames
(
uint32_t
aParsed
uint32_t
aDecoded
uint32_t
aDropped
)
override
{
GetFrameStatistics
(
)
.
NotifyDecodedFrames
(
aParsed
aDecoded
aDropped
)
;
}
void
UpdateReadyState
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mShuttingDown
)
{
mOwner
-
>
UpdateReadyState
(
)
;
}
}
virtual
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameStatus
(
)
{
return
mNextFrameStatus
;
}
virtual
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameBufferedStatus
(
)
;
virtual
void
GetMozDebugReaderData
(
nsAString
&
aString
)
{
}
protected
:
virtual
~
MediaDecoder
(
)
;
virtual
void
FirstFrameLoaded
(
nsAutoPtr
<
MediaInfo
>
aInfo
MediaDecoderEventVisibility
aEventVisibility
)
;
void
SetStateMachineParameters
(
)
;
static
void
DormantTimerExpired
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
StartDormantTimer
(
)
;
void
CancelDormantTimer
(
)
;
bool
IsEnded
(
)
const
;
void
DurationChanged
(
)
;
WatchManager
<
MediaDecoder
>
mWatchManager
;
virtual
void
ShutdownBitChanged
(
)
{
}
double
ExplicitDuration
(
)
{
return
mExplicitDuration
.
Ref
(
)
.
ref
(
)
;
}
void
SetExplicitDuration
(
double
aValue
)
{
mExplicitDuration
.
Set
(
Some
(
aValue
)
)
;
DurationChanged
(
)
;
}
bool
mDormantSupported
;
double
mLogicalPosition
;
virtual
int64_t
CurrentPosition
(
)
{
return
mCurrentPosition
;
}
double
mDuration
;
RefPtr
<
MediaResource
>
mResource
;
static
const
int
DEFAULT_NEXT_FRAME_AVAILABLE_BUFFERED
=
250000
;
private
:
void
MetadataLoaded
(
nsAutoPtr
<
MediaInfo
>
aInfo
nsAutoPtr
<
MetadataTags
>
aTags
MediaDecoderEventVisibility
aEventVisibility
)
;
MediaEventSource
<
void
>
*
DataArrivedEvent
(
)
override
{
return
&
mDataArrivedEvent
;
}
void
OnPlaybackEvent
(
MediaEventType
aEvent
)
;
void
OnMediaNotSeekable
(
)
{
SetMediaSeekable
(
false
)
;
}
RefPtr
<
ShutdownPromise
>
FinishShutdown
(
)
;
MediaEventProducer
<
void
>
mDataArrivedEvent
;
RefPtr
<
MediaDecoderStateMachine
>
mDecoderStateMachine
;
RefPtr
<
ResourceCallback
>
mResourceCallback
;
#
ifdef
MOZ_EME
MozPromiseHolder
<
CDMProxyPromise
>
mCDMProxyPromiseHolder
;
RefPtr
<
CDMProxyPromise
>
mCDMProxyPromise
;
#
endif
protected
:
virtual
void
CallSeek
(
const
SeekTarget
&
aTarget
)
;
bool
IsHeuristicDormantSupported
(
)
const
;
MozPromiseRequestHolder
<
SeekPromise
>
mSeekRequest
;
bool
mIgnoreProgressData
;
bool
mInfiniteStream
;
void
PinForSeek
(
)
;
void
UnpinForSeek
(
)
;
const
char
*
PlayStateStr
(
)
;
void
OnMetadataUpdate
(
TimedMetadata
&
&
aMetadata
)
;
MediaDecoderOwner
*
const
mOwner
;
const
RefPtr
<
FrameStatistics
>
mFrameStats
;
const
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
RefPtr
<
MediaChannelStatistics
>
mPlaybackStatistics
;
bool
mPinnedForSeek
;
bool
mShuttingDown
;
bool
mPausedForPlaybackRateNull
;
dom
:
:
AudioChannel
mAudioChannel
;
bool
mMinimizePreroll
;
bool
mMediaTracksConstructed
;
bool
mFiredMetadataLoaded
;
nsAutoPtr
<
MediaInfo
>
mInfo
;
bool
mIsDormant
;
bool
mWasEndedWhenEnteredDormant
;
const
bool
mIsHeuristicDormantSupported
;
const
int
mHeuristicDormantTimeout
;
bool
mIsHeuristicDormant
;
nsCOMPtr
<
nsITimer
>
mDormantTimer
;
MediaEventListener
mTimedMetadataListener
;
MediaEventListener
mMetadataLoadedListener
;
MediaEventListener
mFirstFrameLoadedListener
;
MediaEventListener
mOnPlaybackEvent
;
MediaEventListener
mOnSeekingStart
;
MediaEventListener
mOnMediaNotSeekable
;
protected
:
Mirror
<
bool
>
mStateMachineIsShutdown
;
Mirror
<
media
:
:
TimeIntervals
>
mBuffered
;
Mirror
<
MediaDecoderOwner
:
:
NextFrameStatus
>
mNextFrameStatus
;
Mirror
<
int64_t
>
mCurrentPosition
;
Mirror
<
media
:
:
NullableTimeUnit
>
mStateMachineDuration
;
Mirror
<
int64_t
>
mPlaybackPosition
;
Mirror
<
bool
>
mIsAudioDataAudible
;
Canonical
<
double
>
mVolume
;
Canonical
<
double
>
mPlaybackRate
;
Canonical
<
bool
>
mPreservesPitch
;
Canonical
<
media
:
:
NullableTimeUnit
>
mEstimatedDuration
;
Canonical
<
Maybe
<
double
>
>
mExplicitDuration
;
Canonical
<
PlayState
>
mPlayState
;
Canonical
<
PlayState
>
mNextState
;
Canonical
<
bool
>
mLogicallySeeking
;
Canonical
<
bool
>
mSameOriginMedia
;
Canonical
<
double
>
mPlaybackBytesPerSecond
;
Canonical
<
bool
>
mPlaybackRateReliable
;
Canonical
<
int64_t
>
mDecoderPosition
;
Canonical
<
bool
>
mMediaSeekable
;
public
:
AbstractCanonical
<
media
:
:
NullableTimeUnit
>
*
CanonicalDurationOrNull
(
)
override
;
AbstractCanonical
<
double
>
*
CanonicalVolume
(
)
{
return
&
mVolume
;
}
AbstractCanonical
<
double
>
*
CanonicalPlaybackRate
(
)
{
return
&
mPlaybackRate
;
}
AbstractCanonical
<
bool
>
*
CanonicalPreservesPitch
(
)
{
return
&
mPreservesPitch
;
}
AbstractCanonical
<
media
:
:
NullableTimeUnit
>
*
CanonicalEstimatedDuration
(
)
{
return
&
mEstimatedDuration
;
}
AbstractCanonical
<
Maybe
<
double
>
>
*
CanonicalExplicitDuration
(
)
{
return
&
mExplicitDuration
;
}
AbstractCanonical
<
PlayState
>
*
CanonicalPlayState
(
)
{
return
&
mPlayState
;
}
AbstractCanonical
<
PlayState
>
*
CanonicalNextPlayState
(
)
{
return
&
mNextState
;
}
AbstractCanonical
<
bool
>
*
CanonicalLogicallySeeking
(
)
{
return
&
mLogicallySeeking
;
}
AbstractCanonical
<
bool
>
*
CanonicalSameOriginMedia
(
)
{
return
&
mSameOriginMedia
;
}
AbstractCanonical
<
double
>
*
CanonicalPlaybackBytesPerSecond
(
)
{
return
&
mPlaybackBytesPerSecond
;
}
AbstractCanonical
<
bool
>
*
CanonicalPlaybackRateReliable
(
)
{
return
&
mPlaybackRateReliable
;
}
AbstractCanonical
<
int64_t
>
*
CanonicalDecoderPosition
(
)
{
return
&
mDecoderPosition
;
}
AbstractCanonical
<
bool
>
*
CanonicalMediaSeekable
(
)
{
return
&
mMediaSeekable
;
}
private
:
void
NotifyAudibleStateChanged
(
)
;
void
SetInfinite
(
bool
aInfinite
)
;
void
ResetConnectionState
(
)
;
nsresult
FinishDecoderSetup
(
MediaResource
*
aResource
)
;
void
NotifyPrincipalChanged
(
)
;
void
NotifySuspendedStatusChanged
(
)
;
void
NotifyBytesConsumed
(
int64_t
aBytes
int64_t
aOffset
)
;
void
NotifyDownloadEnded
(
nsresult
aStatus
)
;
bool
mTelemetryReported
;
}
;
}
#
endif
