#
ifndef
VideoUtils_h
#
define
VideoUtils_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
prtime
.
h
"
#
include
"
AudioSampleFormat
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsCOMPtr
.
h
"
using
mozilla
:
:
CheckedInt64
;
using
mozilla
:
:
CheckedUint64
;
using
mozilla
:
:
CheckedInt32
;
using
mozilla
:
:
CheckedUint32
;
namespace
mozilla
{
extern
const
nsLiteralCString
kEMEKeySystemClearkey
;
extern
const
nsLiteralCString
kEMEKeySystemWidevine
;
extern
const
nsLiteralCString
kEMEKeySystemPrimetime
;
class
MOZ_STACK_CLASS
ReentrantMonitorConditionallyEnter
{
public
:
ReentrantMonitorConditionallyEnter
(
bool
aEnter
ReentrantMonitor
&
aReentrantMonitor
)
:
mReentrantMonitor
(
nullptr
)
{
MOZ_COUNT_CTOR
(
ReentrantMonitorConditionallyEnter
)
;
if
(
aEnter
)
{
mReentrantMonitor
=
&
aReentrantMonitor
;
NS_ASSERTION
(
mReentrantMonitor
"
null
monitor
"
)
;
mReentrantMonitor
-
>
Enter
(
)
;
}
}
~
ReentrantMonitorConditionallyEnter
(
void
)
{
if
(
mReentrantMonitor
)
{
mReentrantMonitor
-
>
Exit
(
)
;
}
MOZ_COUNT_DTOR
(
ReentrantMonitorConditionallyEnter
)
;
}
private
:
ReentrantMonitorConditionallyEnter
(
)
;
ReentrantMonitorConditionallyEnter
(
const
ReentrantMonitorConditionallyEnter
&
)
;
ReentrantMonitorConditionallyEnter
&
operator
=
(
const
ReentrantMonitorConditionallyEnter
&
)
;
static
void
*
operator
new
(
size_t
)
CPP_THROW_NEW
;
static
void
operator
delete
(
void
*
)
;
ReentrantMonitor
*
mReentrantMonitor
;
}
;
class
ShutdownThreadEvent
:
public
Runnable
{
public
:
explicit
ShutdownThreadEvent
(
nsIThread
*
aThread
)
:
mThread
(
aThread
)
{
}
~
ShutdownThreadEvent
(
)
{
}
NS_IMETHOD
Run
(
)
override
{
mThread
-
>
Shutdown
(
)
;
mThread
=
nullptr
;
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIThread
>
mThread
;
}
;
template
<
class
T
>
class
DeleteObjectTask
:
public
Runnable
{
public
:
explicit
DeleteObjectTask
(
nsAutoPtr
<
T
>
&
aObject
)
:
mObject
(
aObject
)
{
}
NS_IMETHOD
Run
(
)
override
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Must
be
on
main
thread
.
"
)
;
mObject
=
nullptr
;
return
NS_OK
;
}
private
:
nsAutoPtr
<
T
>
mObject
;
}
;
template
<
class
T
>
void
DeleteOnMainThread
(
nsAutoPtr
<
T
>
&
aObject
)
{
NS_DispatchToMainThread
(
new
DeleteObjectTask
<
T
>
(
aObject
)
)
;
}
class
MediaResource
;
media
:
:
TimeIntervals
GetEstimatedBufferedTimeRanges
(
mozilla
:
:
MediaResource
*
aStream
int64_t
aDurationUsecs
)
;
CheckedInt64
FramesToUsecs
(
int64_t
aFrames
uint32_t
aRate
)
;
media
:
:
TimeUnit
FramesToTimeUnit
(
int64_t
aFrames
uint32_t
aRate
)
;
CheckedInt64
SaferMultDiv
(
int64_t
aValue
uint32_t
aMul
uint32_t
aDiv
)
;
CheckedInt64
UsecsToFrames
(
int64_t
aUsecs
uint32_t
aRate
)
;
CheckedInt64
TimeUnitToFrames
(
const
media
:
:
TimeUnit
&
aTime
uint32_t
aRate
)
;
#
define
MS_TO_SECONDS
(
ms
)
(
(
double
)
(
ms
)
/
(
PR_MSEC_PER_SEC
)
)
#
define
SECONDS_TO_MS
(
s
)
(
(
int
)
(
(
s
)
*
(
PR_MSEC_PER_SEC
)
)
)
nsresult
SecondsToUsecs
(
double
aSeconds
int64_t
&
aOutUsecs
)
;
static
const
int32_t
MAX_VIDEO_WIDTH
=
8192
;
static
const
int32_t
MAX_VIDEO_HEIGHT
=
4608
;
void
ScaleDisplayByAspectRatio
(
nsIntSize
&
aDisplay
float
aAspectRatio
)
;
void
DownmixStereoToMono
(
mozilla
:
:
AudioDataValue
*
aBuffer
uint32_t
aFrames
)
;
bool
IsVideoContentType
(
const
nsCString
&
aContentType
)
;
bool
IsValidVideoRegion
(
const
nsIntSize
&
aFrame
const
nsIntRect
&
aPicture
const
nsIntSize
&
aDisplay
)
;
template
<
typename
T
>
class
AutoSetOnScopeExit
{
public
:
AutoSetOnScopeExit
(
T
&
aVar
T
aValue
)
:
mVar
(
aVar
)
mValue
(
aValue
)
{
}
~
AutoSetOnScopeExit
(
)
{
mVar
=
mValue
;
}
private
:
T
&
mVar
;
const
T
mValue
;
}
;
class
SharedThreadPool
;
enum
class
MediaThreadType
{
PLAYBACK
PLATFORM_DECODER
}
;
already_AddRefed
<
SharedThreadPool
>
GetMediaThreadPool
(
MediaThreadType
aType
)
;
enum
H264_PROFILE
{
H264_PROFILE_UNKNOWN
=
0
H264_PROFILE_BASE
=
0x42
H264_PROFILE_MAIN
=
0x4D
H264_PROFILE_EXTENDED
=
0x58
H264_PROFILE_HIGH
=
0x64
}
;
enum
H264_LEVEL
{
H264_LEVEL_1
=
10
H264_LEVEL_1_b
=
11
H264_LEVEL_1_1
=
11
H264_LEVEL_1_2
=
12
H264_LEVEL_1_3
=
13
H264_LEVEL_2
=
20
H264_LEVEL_2_1
=
21
H264_LEVEL_2_2
=
22
H264_LEVEL_3
=
30
H264_LEVEL_3_1
=
31
H264_LEVEL_3_2
=
32
H264_LEVEL_4
=
40
H264_LEVEL_4_1
=
41
H264_LEVEL_4_2
=
42
H264_LEVEL_5
=
50
H264_LEVEL_5_1
=
51
H264_LEVEL_5_2
=
52
}
;
bool
ExtractH264CodecDetails
(
const
nsAString
&
aCodecs
int16_t
&
aProfile
int16_t
&
aLevel
)
;
nsresult
GenerateRandomName
(
nsCString
&
aOutSalt
uint32_t
aLength
)
;
nsresult
GenerateRandomPathName
(
nsCString
&
aOutSalt
uint32_t
aLength
)
;
already_AddRefed
<
TaskQueue
>
CreateMediaDecodeTaskQueue
(
)
;
template
<
class
Work
class
Condition
>
RefPtr
<
GenericPromise
>
InvokeUntil
(
Work
aWork
Condition
aCondition
)
{
RefPtr
<
GenericPromise
:
:
Private
>
p
=
new
GenericPromise
:
:
Private
(
__func__
)
;
if
(
aCondition
(
)
)
{
p
-
>
Resolve
(
true
__func__
)
;
}
struct
Helper
{
static
void
Iteration
(
RefPtr
<
GenericPromise
:
:
Private
>
aPromise
Work
aLocalWork
Condition
aLocalCondition
)
{
if
(
!
aLocalWork
(
)
)
{
aPromise
-
>
Reject
(
NS_ERROR_FAILURE
__func__
)
;
}
else
if
(
aLocalCondition
(
)
)
{
aPromise
-
>
Resolve
(
true
__func__
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
aPromise
aLocalWork
aLocalCondition
]
(
)
{
Iteration
(
aPromise
aLocalWork
aLocalCondition
)
;
}
)
;
AbstractThread
:
:
GetCurrent
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
}
}
;
Helper
:
:
Iteration
(
p
aWork
aCondition
)
;
return
p
.
forget
(
)
;
}
class
SimpleTimer
:
public
nsITimerCallback
{
public
:
NS_DECL_ISUPPORTS
static
already_AddRefed
<
SimpleTimer
>
Create
(
nsIRunnable
*
aTask
uint32_t
aTimeoutMs
nsIThread
*
aTarget
=
nullptr
)
;
void
Cancel
(
)
;
NS_IMETHOD
Notify
(
nsITimer
*
timer
)
override
;
private
:
virtual
~
SimpleTimer
(
)
{
}
nsresult
Init
(
nsIRunnable
*
aTask
uint32_t
aTimeoutMs
nsIThread
*
aTarget
)
;
RefPtr
<
nsIRunnable
>
mTask
;
nsCOMPtr
<
nsITimer
>
mTimer
;
}
;
void
LogToBrowserConsole
(
const
nsAString
&
aMsg
)
;
bool
ParseMIMETypeString
(
const
nsAString
&
aMIMEType
nsString
&
aOutContainerType
nsTArray
<
nsString
>
&
aOutCodecs
)
;
bool
ParseCodecsString
(
const
nsAString
&
aCodecs
nsTArray
<
nsString
>
&
aOutCodecs
)
;
bool
IsH264CodecString
(
const
nsAString
&
aCodec
)
;
bool
IsAACCodecString
(
const
nsAString
&
aCodec
)
;
bool
IsVP8CodecString
(
const
nsAString
&
aCodec
)
;
bool
IsVP9CodecString
(
const
nsAString
&
aCodec
)
;
template
<
typename
String
>
class
StringListRange
{
typedef
typename
String
:
:
char_type
CharType
;
typedef
const
CharType
*
Pointer
;
public
:
class
Iterator
{
public
:
bool
operator
!
=
(
const
Iterator
&
a
)
const
{
return
mStart
!
=
a
.
mStart
|
|
mEnd
!
=
a
.
mEnd
;
}
Iterator
&
operator
+
+
(
)
{
SearchItemAt
(
mComma
+
1
)
;
return
*
this
;
}
typedef
decltype
(
Substring
(
Pointer
(
)
Pointer
(
)
)
)
DereferencedType
;
DereferencedType
operator
*
(
)
{
return
Substring
(
mStart
mEnd
)
;
}
private
:
friend
class
StringListRange
;
Iterator
(
const
CharType
*
aRangeStart
uint32_t
aLength
)
:
mRangeEnd
(
aRangeStart
+
aLength
)
{
SearchItemAt
(
aRangeStart
)
;
}
void
SearchItemAt
(
Pointer
start
)
{
for
(
Pointer
p
=
start
;
;
+
+
p
)
{
if
(
p
>
=
mRangeEnd
)
{
mStart
=
mEnd
=
mComma
=
mRangeEnd
;
return
;
}
auto
c
=
*
p
;
if
(
c
=
=
CharType
(
'
'
)
)
{
}
else
if
(
c
!
=
CharType
(
'
'
)
)
{
mStart
=
p
;
break
;
}
}
Pointer
trailingWhitespace
=
nullptr
;
for
(
Pointer
p
=
mStart
+
1
;
;
+
+
p
)
{
if
(
p
>
=
mRangeEnd
)
{
mEnd
=
trailingWhitespace
?
trailingWhitespace
:
p
;
mComma
=
p
;
return
;
}
auto
c
=
*
p
;
if
(
c
=
=
CharType
(
'
'
)
)
{
mEnd
=
trailingWhitespace
?
trailingWhitespace
:
p
;
mComma
=
p
;
return
;
}
if
(
c
=
=
CharType
(
'
'
)
)
{
if
(
!
trailingWhitespace
)
{
trailingWhitespace
=
p
;
}
}
else
{
if
(
trailingWhitespace
)
{
trailingWhitespace
=
nullptr
;
}
}
}
}
const
Pointer
mRangeEnd
;
Pointer
mStart
;
Pointer
mEnd
;
Pointer
mComma
;
}
;
explicit
StringListRange
(
const
String
&
aList
)
:
mList
(
aList
)
{
}
Iterator
begin
(
)
{
return
Iterator
(
mList
.
Data
(
)
mList
.
Length
(
)
)
;
}
Iterator
end
(
)
{
return
Iterator
(
mList
.
Data
(
)
+
mList
.
Length
(
)
0
)
;
}
private
:
const
String
&
mList
;
}
;
template
<
typename
String
>
StringListRange
<
String
>
MakeStringListRange
(
const
String
&
aList
)
{
return
StringListRange
<
String
>
(
aList
)
;
}
template
<
typename
ListString
typename
ItemString
>
static
bool
StringListContains
(
const
ListString
&
aList
const
ItemString
&
aItem
)
{
for
(
const
auto
&
listItem
:
MakeStringListRange
(
aList
)
)
{
if
(
listItem
.
Equals
(
aItem
)
)
{
return
true
;
}
}
return
false
;
}
}
#
endif
