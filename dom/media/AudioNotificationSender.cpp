#
include
"
AudioNotificationSender
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsTArray
.
h
"
#
include
<
mmdeviceapi
.
h
>
static
mozilla
:
:
LazyLogModule
sLogger
(
"
AudioNotificationSender
"
)
;
#
undef
ANS_LOG
#
define
ANS_LOG
(
.
.
.
)
MOZ_LOG
(
sLogger
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
undef
ANS_LOGW
#
define
ANS_LOGW
(
.
.
.
)
MOZ_LOG
(
sLogger
mozilla
:
:
LogLevel
:
:
Warning
(
__VA_ARGS__
)
)
namespace
mozilla
{
namespace
audio
{
class
AudioDeviceChangedRunnable
final
:
public
Runnable
{
public
:
explicit
AudioDeviceChangedRunnable
(
)
:
Runnable
(
"
AudioDeviceChangedRunnable
"
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
dom
:
:
ContentParent
*
>
parents
;
dom
:
:
ContentParent
:
:
GetAll
(
parents
)
;
for
(
dom
:
:
ContentParent
*
p
:
parents
)
{
Unused
<
<
p
-
>
SendAudioDefaultDeviceChange
(
)
;
}
return
NS_OK
;
}
}
;
typedef
void
(
*
DefaultDeviceChangedCallback
)
(
)
;
class
AudioNotification
final
:
public
IMMNotificationClient
{
public
:
explicit
AudioNotification
(
DefaultDeviceChangedCallback
aCallback
)
:
mCallback
(
aCallback
)
mRefCt
(
0
)
mIsRegistered
(
false
)
{
MOZ_COUNT_CTOR
(
AudioNotification
)
;
MOZ_ASSERT
(
mCallback
)
;
const
CLSID
CLSID_MMDeviceEnumerator
=
__uuidof
(
MMDeviceEnumerator
)
;
const
IID
IID_IMMDeviceEnumerator
=
__uuidof
(
IMMDeviceEnumerator
)
;
HRESULT
hr
=
CoCreateInstance
(
CLSID_MMDeviceEnumerator
nullptr
CLSCTX_INPROC_SERVER
IID_IMMDeviceEnumerator
getter_AddRefs
(
mDeviceEnumerator
)
)
;
if
(
FAILED
(
hr
)
)
{
ANS_LOGW
(
"
Cannot
create
an
IMMDeviceEnumerator
instance
.
"
)
;
return
;
}
hr
=
mDeviceEnumerator
-
>
RegisterEndpointNotificationCallback
(
this
)
;
if
(
FAILED
(
hr
)
)
{
ANS_LOGW
(
"
Cannot
register
notification
callback
.
"
)
;
return
;
}
ANS_LOG
(
"
Register
notification
callback
successfully
.
"
)
;
mIsRegistered
=
true
;
}
~
AudioNotification
(
)
{
MOZ_COUNT_DTOR
(
AudioNotification
)
;
MOZ_ASSERT
(
!
mDeviceEnumerator
|
|
mIsRegistered
)
;
if
(
!
mDeviceEnumerator
)
{
ANS_LOG
(
"
No
device
enumerator
in
use
.
"
)
;
return
;
}
HRESULT
hr
=
mDeviceEnumerator
-
>
UnregisterEndpointNotificationCallback
(
this
)
;
if
(
FAILED
(
hr
)
)
{
ANS_LOGW
(
"
Unregister
notification
failed
.
"
)
;
}
else
{
ANS_LOG
(
"
Unregister
notification
callback
successfully
.
"
)
;
}
mIsRegistered
=
false
;
}
bool
IsRegistered
(
)
const
{
return
mIsRegistered
;
}
HRESULT
STDMETHODCALLTYPE
OnDefaultDeviceChanged
(
EDataFlow
aFlow
ERole
aRole
LPCWSTR
aDeviceId
)
override
{
ANS_LOG
(
"
Default
device
has
changed
:
flow
%
d
role
:
%
d
\
n
"
aFlow
aRole
)
;
mCallback
(
)
;
return
S_OK
;
}
HRESULT
STDMETHODCALLTYPE
OnDeviceAdded
(
LPCWSTR
aDeviceId
)
override
{
ANS_LOG
(
"
Audio
device
added
.
"
)
;
return
S_OK
;
}
;
HRESULT
STDMETHODCALLTYPE
OnDeviceRemoved
(
LPCWSTR
aDeviceId
)
override
{
ANS_LOG
(
"
Audio
device
removed
.
"
)
;
return
S_OK
;
}
HRESULT
STDMETHODCALLTYPE
OnDeviceStateChanged
(
LPCWSTR
aDeviceId
DWORD
aNewState
)
override
{
ANS_LOG
(
"
Audio
device
state
changed
.
"
)
;
return
S_OK
;
}
HRESULT
STDMETHODCALLTYPE
OnPropertyValueChanged
(
LPCWSTR
aDeviceId
const
PROPERTYKEY
aKey
)
override
{
ANS_LOG
(
"
Audio
device
property
value
changed
.
"
)
;
return
S_OK
;
}
ULONG
STDMETHODCALLTYPE
AddRef
(
)
override
{
return
InterlockedIncrement
(
&
mRefCt
)
;
}
ULONG
STDMETHODCALLTYPE
Release
(
)
override
{
ULONG
ulRef
=
InterlockedDecrement
(
&
mRefCt
)
;
if
(
0
=
=
ulRef
)
{
delete
this
;
}
return
ulRef
;
}
HRESULT
STDMETHODCALLTYPE
QueryInterface
(
REFIID
riid
VOID
*
*
ppvInterface
)
override
{
if
(
__uuidof
(
IUnknown
)
=
=
riid
)
{
AddRef
(
)
;
*
ppvInterface
=
static_cast
<
IUnknown
*
>
(
this
)
;
}
else
if
(
__uuidof
(
IMMNotificationClient
)
=
=
riid
)
{
AddRef
(
)
;
*
ppvInterface
=
static_cast
<
IMMNotificationClient
*
>
(
this
)
;
}
else
{
*
ppvInterface
=
NULL
;
return
E_NOINTERFACE
;
}
return
S_OK
;
}
private
:
RefPtr
<
IMMDeviceEnumerator
>
mDeviceEnumerator
;
DefaultDeviceChangedCallback
mCallback
;
LONG
mRefCt
;
bool
mIsRegistered
;
}
;
static
StaticAutoPtr
<
AudioNotification
>
sAudioNotification
;
nsresult
AudioNotificationSender
:
:
Init
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sAudioNotification
)
{
sAudioNotification
=
new
AudioNotification
(
NotifyDefaultDeviceChanged
)
;
ClearOnShutdown
(
&
sAudioNotification
)
;
if
(
!
sAudioNotification
-
>
IsRegistered
(
)
)
{
ANS_LOGW
(
"
The
notification
sender
cannot
be
initialized
.
"
)
;
return
NS_ERROR_FAILURE
;
}
ANS_LOG
(
"
The
notification
sender
is
initailized
successfully
.
"
)
;
}
return
NS_OK
;
}
void
AudioNotificationSender
:
:
NotifyDefaultDeviceChanged
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
ANS_LOG
(
"
Notify
the
default
device
-
changed
event
.
"
)
;
RefPtr
<
AudioDeviceChangedRunnable
>
runnable
=
new
AudioDeviceChangedRunnable
(
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
}
}
