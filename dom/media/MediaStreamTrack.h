#
ifndef
MEDIASTREAMTRACK_H_
#
define
MEDIASTREAMTRACK_H_
#
include
"
MediaTrackConstraints
.
h
"
#
include
"
PrincipalChangeObserver
.
h
"
#
include
"
StreamTracks
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamTrackBinding
.
h
"
#
include
"
mozilla
/
dom
/
MediaTrackSettingsBinding
.
h
"
#
include
"
mozilla
/
media
/
MediaUtils
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIPrincipal
.
h
"
namespace
mozilla
{
class
DOMMediaStream
;
class
MediaEnginePhotoCallback
;
class
MediaInputPort
;
class
MediaStream
;
class
MediaStreamGraph
;
class
MediaStreamGraphImpl
;
class
MediaStreamTrackListener
;
class
DirectMediaStreamTrackListener
;
class
PeerConnectionImpl
;
class
PeerConnectionMedia
;
class
PeerIdentity
;
class
ProcessedMediaStream
;
class
RemoteSourceStreamInfo
;
class
SourceStreamInfo
;
class
MediaMgrError
;
namespace
dom
{
class
AudioStreamTrack
;
class
VideoStreamTrack
;
class
TrackSink
;
enum
class
CallerType
:
uint32_t
;
class
MediaStreamTrackSource
:
public
nsISupports
{
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
MediaStreamTrackSource
)
public
:
class
Sink
:
public
SupportsWeakPtr
<
Sink
>
{
public
:
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
MediaStreamTrackSource
:
:
Sink
)
virtual
bool
KeepsSourceAlive
(
)
const
=
0
;
virtual
bool
Enabled
(
)
const
=
0
;
virtual
void
PrincipalChanged
(
)
=
0
;
virtual
void
MutedChanged
(
bool
aNewState
)
=
0
;
protected
:
virtual
~
Sink
(
)
=
default
;
}
;
MediaStreamTrackSource
(
nsIPrincipal
*
aPrincipal
const
nsString
&
aLabel
)
:
mPrincipal
(
aPrincipal
)
mLabel
(
aLabel
)
mStopped
(
false
)
{
}
virtual
void
Destroy
(
)
{
}
virtual
MediaSourceEnum
GetMediaSource
(
)
const
=
0
;
nsIPrincipal
*
GetPrincipal
(
)
const
{
return
mPrincipal
;
}
virtual
const
PeerIdentity
*
GetPeerIdentity
(
)
const
{
return
nullptr
;
}
void
GetLabel
(
nsAString
&
aLabel
)
{
aLabel
.
Assign
(
mLabel
)
;
}
virtual
nsresult
TakePhoto
(
MediaEnginePhotoCallback
*
)
const
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
typedef
MozPromise
<
bool
RefPtr
<
MediaMgrError
>
true
>
ApplyConstraintsPromise
;
virtual
RefPtr
<
ApplyConstraintsPromise
>
ApplyConstraints
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
CallerType
aCallerType
)
;
virtual
void
GetSettings
(
dom
:
:
MediaTrackSettings
&
aResult
)
{
}
;
virtual
void
Stop
(
)
=
0
;
virtual
void
Disable
(
)
=
0
;
virtual
void
Enable
(
)
=
0
;
void
SinkEnabledStateChanged
(
)
{
if
(
IsEnabled
(
)
)
{
Enable
(
)
;
}
else
{
Disable
(
)
;
}
}
void
RegisterSink
(
Sink
*
aSink
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mStopped
)
{
return
;
}
mSinks
.
AppendElement
(
aSink
)
;
while
(
mSinks
.
RemoveElement
(
nullptr
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Sink
was
not
explicitly
removed
"
)
;
}
}
void
UnregisterSink
(
Sink
*
aSink
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
while
(
mSinks
.
RemoveElement
(
nullptr
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Sink
was
not
explicitly
removed
"
)
;
}
if
(
mSinks
.
RemoveElement
(
aSink
)
&
&
!
IsActive
(
)
)
{
MOZ_ASSERT
(
!
aSink
-
>
KeepsSourceAlive
(
)
|
|
!
mStopped
"
When
the
last
sink
keeping
the
source
alive
is
removed
"
"
we
should
still
be
live
"
)
;
Stop
(
)
;
mStopped
=
true
;
}
if
(
!
mStopped
)
{
SinkEnabledStateChanged
(
)
;
}
}
protected
:
virtual
~
MediaStreamTrackSource
(
)
{
}
bool
IsActive
(
)
{
for
(
const
WeakPtr
<
Sink
>
&
sink
:
mSinks
)
{
if
(
sink
&
&
sink
-
>
KeepsSourceAlive
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
IsEnabled
(
)
{
for
(
const
WeakPtr
<
Sink
>
&
sink
:
mSinks
)
{
if
(
sink
&
&
sink
-
>
KeepsSourceAlive
(
)
&
&
sink
-
>
Enabled
(
)
)
{
return
true
;
}
}
return
false
;
}
void
PrincipalChanged
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
WeakPtr
<
Sink
>
>
sinks
(
mSinks
)
;
for
(
auto
&
sink
:
sinks
)
{
if
(
!
sink
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Sink
was
not
explicitly
removed
"
)
;
mSinks
.
RemoveElement
(
sink
)
;
continue
;
}
sink
-
>
PrincipalChanged
(
)
;
}
}
void
MutedChanged
(
bool
aNewState
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
WeakPtr
<
Sink
>
>
sinks
(
mSinks
)
;
for
(
auto
&
sink
:
sinks
)
{
if
(
!
sink
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Sink
was
not
explicitly
removed
"
)
;
mSinks
.
RemoveElement
(
sink
)
;
continue
;
}
sink
-
>
MutedChanged
(
aNewState
)
;
}
}
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsTArray
<
WeakPtr
<
Sink
>
>
mSinks
;
const
nsString
mLabel
;
bool
mStopped
;
}
;
class
BasicTrackSource
:
public
MediaStreamTrackSource
{
public
:
explicit
BasicTrackSource
(
nsIPrincipal
*
aPrincipal
const
MediaSourceEnum
aMediaSource
=
MediaSourceEnum
:
:
Other
)
:
MediaStreamTrackSource
(
aPrincipal
nsString
(
)
)
mMediaSource
(
aMediaSource
)
{
}
MediaSourceEnum
GetMediaSource
(
)
const
override
{
return
mMediaSource
;
}
void
Stop
(
)
override
{
}
void
Disable
(
)
override
{
}
void
Enable
(
)
override
{
}
protected
:
~
BasicTrackSource
(
)
{
}
const
MediaSourceEnum
mMediaSource
;
}
;
class
MediaStreamTrackConsumer
:
public
SupportsWeakPtr
<
MediaStreamTrackConsumer
>
{
public
:
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
MediaStreamTrackConsumer
)
virtual
void
NotifyEnded
(
MediaStreamTrack
*
aTrack
)
{
}
;
}
;
class
MediaStreamTrack
:
public
DOMEventTargetHelper
public
SupportsWeakPtr
<
MediaStreamTrack
>
{
friend
class
mozilla
:
:
DOMMediaStream
;
friend
class
mozilla
:
:
PeerConnectionImpl
;
friend
class
mozilla
:
:
PeerConnectionMedia
;
friend
class
mozilla
:
:
SourceStreamInfo
;
friend
class
mozilla
:
:
RemoteSourceStreamInfo
;
class
MSGListener
;
public
:
MediaStreamTrack
(
DOMMediaStream
*
aStream
TrackID
aTrackID
TrackID
aInputTrackID
MediaStreamTrackSource
*
aSource
const
MediaTrackConstraints
&
aConstraints
=
MediaTrackConstraints
(
)
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
MediaStreamTrack
DOMEventTargetHelper
)
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
MediaStreamTrack
)
nsPIDOMWindowInner
*
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
virtual
AudioStreamTrack
*
AsAudioStreamTrack
(
)
{
return
nullptr
;
}
virtual
VideoStreamTrack
*
AsVideoStreamTrack
(
)
{
return
nullptr
;
}
virtual
const
AudioStreamTrack
*
AsAudioStreamTrack
(
)
const
{
return
nullptr
;
}
virtual
const
VideoStreamTrack
*
AsVideoStreamTrack
(
)
const
{
return
nullptr
;
}
virtual
void
GetKind
(
nsAString
&
aKind
)
=
0
;
void
GetId
(
nsAString
&
aID
)
const
;
virtual
void
GetLabel
(
nsAString
&
aLabel
CallerType
)
{
GetSource
(
)
.
GetLabel
(
aLabel
)
;
}
bool
Enabled
(
)
const
{
return
mEnabled
;
}
void
SetEnabled
(
bool
aEnabled
)
;
bool
Muted
(
)
{
return
mMuted
;
}
void
Stop
(
)
;
void
GetConstraints
(
dom
:
:
MediaTrackConstraints
&
aResult
)
;
void
GetSettings
(
dom
:
:
MediaTrackSettings
&
aResult
CallerType
aCallerType
)
;
already_AddRefed
<
Promise
>
ApplyConstraints
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
CallerType
aCallerType
ErrorResult
&
aRv
)
;
already_AddRefed
<
MediaStreamTrack
>
Clone
(
)
;
MediaStreamTrackState
ReadyState
(
)
{
return
mReadyState
;
}
IMPL_EVENT_HANDLER
(
mute
)
IMPL_EVENT_HANDLER
(
unmute
)
IMPL_EVENT_HANDLER
(
ended
)
bool
Ended
(
)
const
{
return
mReadyState
=
=
MediaStreamTrackState
:
:
Ended
;
}
void
SetReadyState
(
MediaStreamTrackState
aState
)
;
void
OverrideEnded
(
)
;
nsIPrincipal
*
GetPrincipal
(
)
const
{
return
mPrincipal
;
}
void
NotifyPrincipalHandleChanged
(
const
PrincipalHandle
&
aPrincipalHandle
)
;
void
NotifyEnded
(
)
;
const
PeerIdentity
*
GetPeerIdentity
(
)
const
{
return
GetSource
(
)
.
GetPeerIdentity
(
)
;
}
MediaStreamGraph
*
Graph
(
)
;
MediaStreamGraphImpl
*
GraphImpl
(
)
;
MediaStreamTrackSource
&
GetSource
(
)
const
{
MOZ_RELEASE_ASSERT
(
mSource
"
The
track
source
is
only
removed
on
destruction
"
)
;
return
*
mSource
;
}
void
AssignId
(
const
nsAString
&
aID
)
{
mID
=
aID
;
}
void
PrincipalChanged
(
)
;
void
MutedChanged
(
bool
aNewState
)
;
bool
AddPrincipalChangeObserver
(
PrincipalChangeObserver
<
MediaStreamTrack
>
*
aObserver
)
;
bool
RemovePrincipalChangeObserver
(
PrincipalChangeObserver
<
MediaStreamTrack
>
*
aObserver
)
;
void
AddConsumer
(
MediaStreamTrackConsumer
*
aConsumer
)
;
void
RemoveConsumer
(
MediaStreamTrackConsumer
*
aConsumer
)
;
virtual
void
AddListener
(
MediaStreamTrackListener
*
aListener
)
;
void
RemoveListener
(
MediaStreamTrackListener
*
aListener
)
;
virtual
void
AddDirectListener
(
DirectMediaStreamTrackListener
*
aListener
)
;
void
RemoveDirectListener
(
DirectMediaStreamTrackListener
*
aListener
)
;
already_AddRefed
<
MediaInputPort
>
ForwardTrackContentsTo
(
ProcessedMediaStream
*
aStream
TrackID
aDestinationTrackID
=
TRACK_ANY
)
;
bool
IsForwardedThrough
(
MediaInputPort
*
aPort
)
;
void
SetMediaStreamSizeListener
(
DirectMediaStreamTrackListener
*
aListener
)
;
MediaStream
*
GetInputStream
(
)
;
TrackID
GetInputTrackId
(
)
const
{
return
mInputTrackID
;
}
protected
:
virtual
~
MediaStreamTrack
(
)
;
void
SetMuted
(
bool
aMuted
)
{
mMuted
=
aMuted
;
}
virtual
void
Destroy
(
)
;
ProcessedMediaStream
*
GetOwnedStream
(
)
;
DOMMediaStream
*
GetInputDOMStream
(
)
;
void
SetPrincipal
(
nsIPrincipal
*
aPrincipal
)
;
virtual
already_AddRefed
<
MediaStreamTrack
>
CloneInternal
(
DOMMediaStream
*
aOwningStream
TrackID
aTrackID
)
=
0
;
nsTArray
<
PrincipalChangeObserver
<
MediaStreamTrack
>
*
>
mPrincipalChangeObservers
;
nsTArray
<
WeakPtr
<
MediaStreamTrackConsumer
>
>
mConsumers
;
RefPtr
<
DOMMediaStream
>
mOwningStream
;
TrackID
mTrackID
;
TrackID
mInputTrackID
;
RefPtr
<
MediaStreamTrackSource
>
mSource
;
const
UniquePtr
<
TrackSink
>
mSink
;
RefPtr
<
MediaStreamTrack
>
mOriginalTrack
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsCOMPtr
<
nsIPrincipal
>
mPendingPrincipal
;
RefPtr
<
MSGListener
>
mMSGListener
;
nsTArray
<
RefPtr
<
MediaStreamTrackListener
>
>
mTrackListeners
;
nsTArray
<
RefPtr
<
DirectMediaStreamTrackListener
>
>
mDirectTrackListeners
;
nsString
mID
;
MediaStreamTrackState
mReadyState
;
bool
mEnabled
;
bool
mMuted
;
dom
:
:
MediaTrackConstraints
mConstraints
;
}
;
}
}
#
endif
