#
ifndef
MEDIASTREAMTRACK_H_
#
define
MEDIASTREAMTRACK_H_
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsID
.
h
"
#
include
"
StreamBuffer
.
h
"
#
include
"
MediaTrackConstraints
.
h
"
namespace
mozilla
{
class
DOMMediaStream
;
class
MediaEnginePhotoCallback
;
class
MediaStream
;
class
ProcessedMediaStream
;
namespace
dom
{
class
AudioStreamTrack
;
class
VideoStreamTrack
;
class
MediaStreamTrackSource
:
public
nsISupports
{
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
MediaStreamTrackSource
)
public
:
explicit
MediaStreamTrackSource
(
const
bool
aIsRemote
)
:
mNrSinks
(
0
)
mIsRemote
(
aIsRemote
)
mStopped
(
false
)
{
MOZ_COUNT_CTOR
(
MediaStreamTrackSource
)
;
}
virtual
MediaSourceEnum
GetMediaSource
(
)
const
=
0
;
virtual
bool
IsRemote
(
)
const
{
return
mIsRemote
;
}
virtual
nsresult
TakePhoto
(
MediaEnginePhotoCallback
*
)
const
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
virtual
void
Stop
(
)
=
0
;
void
RegisterSink
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mStopped
)
{
return
;
}
+
+
mNrSinks
;
}
void
UnregisterSink
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ASSERTION
(
mNrSinks
>
0
"
Unmatched
UnregisterSink
(
)
"
)
;
-
-
mNrSinks
;
if
(
mNrSinks
=
=
0
&
&
!
IsRemote
(
)
)
{
Stop
(
)
;
mStopped
=
true
;
}
}
protected
:
virtual
~
MediaStreamTrackSource
(
)
{
MOZ_COUNT_DTOR
(
MediaStreamTrackSource
)
;
NS_ASSERTION
(
mNrSinks
=
=
0
"
Some
sinks
did
not
unregister
"
)
;
}
size_t
mNrSinks
;
const
bool
mIsRemote
;
bool
mStopped
;
}
;
class
BasicUnstoppableTrackSource
:
public
MediaStreamTrackSource
{
public
:
explicit
BasicUnstoppableTrackSource
(
const
MediaSourceEnum
aMediaSource
=
MediaSourceEnum
:
:
Other
)
:
MediaStreamTrackSource
(
true
)
mMediaSource
(
aMediaSource
)
{
}
MediaSourceEnum
GetMediaSource
(
)
const
override
{
return
mMediaSource
;
}
void
Stop
(
)
override
{
}
protected
:
~
BasicUnstoppableTrackSource
(
)
{
}
const
MediaSourceEnum
mMediaSource
;
}
;
class
MediaStreamTrack
:
public
DOMEventTargetHelper
{
public
:
MediaStreamTrack
(
DOMMediaStream
*
aStream
TrackID
aTrackID
TrackID
aInputTrackID
const
nsString
&
aLabel
MediaStreamTrackSource
*
aSource
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
MediaStreamTrack
DOMEventTargetHelper
)
DOMMediaStream
*
GetParentObject
(
)
const
{
return
mOwningStream
;
}
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
=
0
;
DOMMediaStream
*
GetStream
(
)
const
{
return
mOwningStream
;
}
TrackID
GetTrackID
(
)
const
{
return
mTrackID
;
}
TrackID
GetInputTrackID
(
)
const
{
return
mInputTrackID
;
}
virtual
AudioStreamTrack
*
AsAudioStreamTrack
(
)
{
return
nullptr
;
}
virtual
VideoStreamTrack
*
AsVideoStreamTrack
(
)
{
return
nullptr
;
}
virtual
void
GetKind
(
nsAString
&
aKind
)
=
0
;
void
GetId
(
nsAString
&
aID
)
const
;
void
GetLabel
(
nsAString
&
aLabel
)
{
aLabel
.
Assign
(
mLabel
)
;
}
bool
Enabled
(
)
{
return
mEnabled
;
}
void
SetEnabled
(
bool
aEnabled
)
;
void
Stop
(
)
;
already_AddRefed
<
Promise
>
ApplyConstraints
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
ErrorResult
&
aRv
)
;
bool
Ended
(
)
const
{
return
mEnded
;
}
void
NotifyEnded
(
)
{
mEnded
=
true
;
}
MediaStreamTrackSource
&
GetSource
(
)
const
{
MOZ_RELEASE_ASSERT
(
mSource
"
The
track
source
is
only
removed
on
destruction
"
)
;
return
*
mSource
;
}
void
AssignId
(
const
nsAString
&
aID
)
{
mID
=
aID
;
}
protected
:
virtual
~
MediaStreamTrack
(
)
;
MediaStream
*
GetInputStream
(
)
;
ProcessedMediaStream
*
GetOwnedStream
(
)
;
DOMMediaStream
*
GetInputDOMStream
(
)
;
RefPtr
<
DOMMediaStream
>
mOwningStream
;
TrackID
mTrackID
;
TrackID
mInputTrackID
;
RefPtr
<
MediaStreamTrackSource
>
mSource
;
RefPtr
<
MediaStreamTrack
>
mOriginalTrack
;
nsString
mID
;
nsString
mLabel
;
bool
mEnded
;
bool
mEnabled
;
const
bool
mRemote
;
bool
mStopped
;
}
;
}
}
#
endif
