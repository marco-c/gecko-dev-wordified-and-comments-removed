#
include
"
MP4Decoder
.
h
"
#
include
"
MediaDecoderStateMachine
.
h
"
#
include
"
MP4Demuxer
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
ifdef
MOZ_EME
#
include
"
mozilla
/
CDMProxy
.
h
"
#
endif
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsContentTypeParser
.
h
"
#
include
"
VideoUtils
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
nsIGfxInfo
.
h
"
#
include
"
AndroidBridge
.
h
"
#
endif
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
PDMFactory
.
h
"
namespace
mozilla
{
#
if
defined
(
MOZ_GONK_MEDIACODEC
)
|
|
defined
(
XP_WIN
)
|
|
defined
(
MOZ_APPLEMEDIA
)
|
|
defined
(
MOZ_FFMPEG
)
#
define
MP4_READER_DORMANT_HEURISTIC
#
else
#
undef
MP4_READER_DORMANT_HEURISTIC
#
endif
MP4Decoder
:
:
MP4Decoder
(
MediaDecoderOwner
*
aOwner
)
:
MediaDecoder
(
aOwner
)
{
#
if
defined
(
MP4_READER_DORMANT_HEURISTIC
)
mDormantSupported
=
Preferences
:
:
GetBool
(
"
media
.
decoder
.
heuristic
.
dormant
.
enabled
"
false
)
;
#
endif
}
MediaDecoderStateMachine
*
MP4Decoder
:
:
CreateStateMachine
(
)
{
mReader
=
new
MediaFormatReader
(
this
new
MP4Demuxer
(
GetResource
(
)
)
GetVideoFrameContainer
(
)
)
;
return
new
MediaDecoderStateMachine
(
this
mReader
)
;
}
static
bool
IsWhitelistedH264Codec
(
const
nsAString
&
aCodec
)
{
int16_t
profile
=
0
level
=
0
;
if
(
!
ExtractH264CodecDetails
(
aCodec
profile
level
)
)
{
return
false
;
}
#
ifdef
XP_WIN
if
(
!
IsWin7OrLater
(
)
&
&
level
>
=
H264_LEVEL_5
)
{
return
false
;
}
#
endif
return
level
>
=
H264_LEVEL_1
&
&
level
<
=
H264_LEVEL_5_1
&
&
(
profile
=
=
H264_PROFILE_BASE
|
|
profile
=
=
H264_PROFILE_MAIN
|
|
profile
=
=
H264_PROFILE_EXTENDED
|
|
profile
=
=
H264_PROFILE_HIGH
)
;
}
bool
MP4Decoder
:
:
CanHandleMediaType
(
const
nsACString
&
aMIMETypeExcludingCodecs
const
nsAString
&
aCodecs
)
{
if
(
!
IsEnabled
(
)
)
{
return
false
;
}
const
bool
isMP4Audio
=
aMIMETypeExcludingCodecs
.
EqualsASCII
(
"
audio
/
mp4
"
)
|
|
aMIMETypeExcludingCodecs
.
EqualsASCII
(
"
audio
/
x
-
m4a
"
)
;
const
bool
isMP4Video
=
#
ifdef
MOZ_GONK_MEDIACODEC
aMIMETypeExcludingCodecs
.
EqualsASCII
(
VIDEO_3GPP
)
|
|
#
endif
aMIMETypeExcludingCodecs
.
EqualsASCII
(
"
video
/
mp4
"
)
|
|
aMIMETypeExcludingCodecs
.
EqualsASCII
(
"
video
/
x
-
m4v
"
)
;
if
(
!
isMP4Audio
&
&
!
isMP4Video
)
{
return
false
;
}
nsTArray
<
nsCString
>
codecMimes
;
if
(
aCodecs
.
IsEmpty
(
)
)
{
if
(
isMP4Audio
)
{
codecMimes
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
audio
/
mp4a
-
latm
"
)
)
;
}
else
{
MOZ_ASSERT
(
isMP4Video
)
;
codecMimes
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
video
/
avc
"
)
)
;
}
}
else
{
nsTArray
<
nsString
>
codecs
;
if
(
!
ParseCodecsString
(
aCodecs
codecs
)
)
{
return
false
;
}
for
(
const
nsString
&
codec
:
codecs
)
{
if
(
IsAACCodecString
(
codec
)
)
{
codecMimes
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
audio
/
mp4a
-
latm
"
)
)
;
continue
;
}
if
(
codec
.
EqualsLiteral
(
"
mp3
"
)
)
{
codecMimes
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
audio
/
mpeg
"
)
)
;
continue
;
}
if
(
IsWhitelistedH264Codec
(
codec
)
&
&
isMP4Video
)
{
codecMimes
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
video
/
avc
"
)
)
;
continue
;
}
return
false
;
}
}
PDMFactory
:
:
Init
(
)
;
RefPtr
<
PDMFactory
>
platform
=
new
PDMFactory
(
)
;
for
(
const
nsCString
&
codecMime
:
codecMimes
)
{
if
(
!
platform
-
>
SupportsMimeType
(
codecMime
)
)
{
return
false
;
}
}
return
true
;
}
bool
MP4Decoder
:
:
CanHandleMediaType
(
const
nsAString
&
aContentType
)
{
nsContentTypeParser
parser
(
aContentType
)
;
nsAutoString
mimeType
;
nsresult
rv
=
parser
.
GetType
(
mimeType
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
nsString
codecs
;
parser
.
GetParameter
(
"
codecs
"
codecs
)
;
return
CanHandleMediaType
(
NS_ConvertUTF16toUTF8
(
mimeType
)
codecs
)
;
}
bool
MP4Decoder
:
:
IsEnabled
(
)
{
return
Preferences
:
:
GetBool
(
"
media
.
mp4
.
enabled
"
)
;
}
static
const
uint8_t
sTestH264ExtraData
[
]
=
{
0x01
0x42
0xc0
0x1e
0xff
0xe1
0x00
0x17
0x67
0x42
0xc0
0x1e
0xbb
0x40
0x50
0x17
0xfc
0xb8
0x08
0x80
0x00
0x00
0x32
0x00
0x00
0x0b
0xb5
0x07
0x8b
0x17
0x50
0x01
0x00
0x04
0x68
0xce
0x32
0xc8
}
;
static
already_AddRefed
<
MediaDataDecoder
>
CreateTestH264Decoder
(
layers
:
:
LayersBackend
aBackend
VideoInfo
&
aConfig
FlushableTaskQueue
*
aTaskQueue
)
{
aConfig
.
mMimeType
=
"
video
/
avc
"
;
aConfig
.
mId
=
1
;
aConfig
.
mDuration
=
40000
;
aConfig
.
mMediaTime
=
0
;
aConfig
.
mDisplay
=
nsIntSize
(
640
360
)
;
aConfig
.
mImage
=
nsIntRect
(
0
0
640
360
)
;
aConfig
.
mExtraData
=
new
MediaByteBuffer
(
)
;
aConfig
.
mExtraData
-
>
AppendElements
(
sTestH264ExtraData
MOZ_ARRAY_LENGTH
(
sTestH264ExtraData
)
)
;
PDMFactory
:
:
Init
(
)
;
RefPtr
<
PDMFactory
>
platform
=
new
PDMFactory
(
)
;
RefPtr
<
MediaDataDecoder
>
decoder
(
platform
-
>
CreateDecoder
(
aConfig
aTaskQueue
nullptr
aBackend
nullptr
)
)
;
return
decoder
.
forget
(
)
;
}
already_AddRefed
<
dom
:
:
Promise
>
MP4Decoder
:
:
IsVideoAccelerated
(
layers
:
:
LayersBackend
aBackend
nsIGlobalObject
*
aParent
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
;
promise
=
dom
:
:
Promise
:
:
Create
(
aParent
rv
)
;
if
(
rv
.
Failed
(
)
)
{
rv
.
SuppressException
(
)
;
return
nullptr
;
}
RefPtr
<
FlushableTaskQueue
>
taskQueue
=
new
FlushableTaskQueue
(
GetMediaThreadPool
(
MediaThreadType
:
:
PLATFORM_DECODER
)
)
;
VideoInfo
config
;
RefPtr
<
MediaDataDecoder
>
decoder
(
CreateTestH264Decoder
(
aBackend
config
taskQueue
)
)
;
if
(
!
decoder
)
{
promise
-
>
MaybeResolve
(
NS_LITERAL_STRING
(
"
No
;
Failed
to
create
H264
decoder
"
)
)
;
return
promise
.
forget
(
)
;
}
decoder
-
>
Init
(
)
-
>
Then
(
AbstractThread
:
:
MainThread
(
)
__func__
[
promise
decoder
taskQueue
]
(
TrackInfo
:
:
TrackType
aTrack
)
{
nsCString
failureReason
;
bool
ok
=
decoder
-
>
IsHardwareAccelerated
(
failureReason
)
;
nsAutoString
result
;
if
(
ok
)
{
result
.
AssignLiteral
(
"
Yes
"
)
;
}
else
{
result
.
AssignLiteral
(
"
No
"
)
;
if
(
failureReason
.
Length
(
)
)
{
result
.
AppendLiteral
(
"
;
"
)
;
AppendUTF8toUTF16
(
failureReason
result
)
;
}
}
promise
-
>
MaybeResolve
(
result
)
;
decoder
-
>
Shutdown
(
)
;
taskQueue
-
>
BeginShutdown
(
)
;
taskQueue
-
>
AwaitShutdownAndIdle
(
)
;
}
[
promise
decoder
taskQueue
]
(
MediaDataDecoder
:
:
DecoderFailureReason
aResult
)
{
promise
-
>
MaybeResolve
(
NS_LITERAL_STRING
(
"
No
;
Failed
to
initialize
H264
decoder
"
)
)
;
decoder
-
>
Shutdown
(
)
;
taskQueue
-
>
BeginShutdown
(
)
;
taskQueue
-
>
AwaitShutdownAndIdle
(
)
;
}
)
;
return
promise
.
forget
(
)
;
}
void
MP4Decoder
:
:
GetMozDebugReaderData
(
nsAString
&
aString
)
{
if
(
mReader
)
{
mReader
-
>
GetMozDebugReaderData
(
aString
)
;
}
}
}
