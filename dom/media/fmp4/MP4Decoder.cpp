#
include
"
MP4Decoder
.
h
"
#
include
"
MediaDecoderStateMachine
.
h
"
#
include
"
MP4Demuxer
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
mozilla
/
CDMProxy
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsContentTypeParser
.
h
"
#
include
"
VideoUtils
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
nsIGfxInfo
.
h
"
#
endif
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
PDMFactory
.
h
"
namespace
mozilla
{
MP4Decoder
:
:
MP4Decoder
(
MediaDecoderOwner
*
aOwner
)
:
MediaDecoder
(
aOwner
)
{
mDormantSupported
=
Preferences
:
:
GetBool
(
"
media
.
decoder
.
heuristic
.
dormant
.
enabled
"
false
)
;
}
MediaDecoderStateMachine
*
MP4Decoder
:
:
CreateStateMachine
(
)
{
mReader
=
new
MediaFormatReader
(
this
new
MP4Demuxer
(
GetResource
(
)
)
GetVideoFrameContainer
(
)
)
;
return
new
MediaDecoderStateMachine
(
this
mReader
)
;
}
static
bool
IsWhitelistedH264Codec
(
const
nsAString
&
aCodec
)
{
int16_t
profile
=
0
level
=
0
;
if
(
!
ExtractH264CodecDetails
(
aCodec
profile
level
)
)
{
return
false
;
}
#
ifdef
XP_WIN
if
(
!
IsWin7OrLater
(
)
&
&
level
>
=
H264_LEVEL_5
)
{
return
false
;
}
#
endif
return
level
>
=
H264_LEVEL_1
&
&
level
<
=
H264_LEVEL_5_1
&
&
(
profile
=
=
H264_PROFILE_BASE
|
|
profile
=
=
H264_PROFILE_MAIN
|
|
profile
=
=
H264_PROFILE_EXTENDED
|
|
profile
=
=
H264_PROFILE_HIGH
)
;
}
bool
MP4Decoder
:
:
CanHandleMediaType
(
const
nsACString
&
aMIMETypeExcludingCodecs
const
nsAString
&
aCodecs
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
if
(
!
IsEnabled
(
)
)
{
return
false
;
}
const
bool
isMP4Audio
=
aMIMETypeExcludingCodecs
.
EqualsASCII
(
"
audio
/
mp4
"
)
|
|
aMIMETypeExcludingCodecs
.
EqualsASCII
(
"
audio
/
x
-
m4a
"
)
|
|
aMIMETypeExcludingCodecs
.
EqualsASCII
(
"
audio
/
opus
"
)
;
const
bool
isMP4Video
=
#
ifdef
MOZ_GONK_MEDIACODEC
aMIMETypeExcludingCodecs
.
EqualsASCII
(
VIDEO_3GPP
)
|
|
#
endif
aMIMETypeExcludingCodecs
.
EqualsASCII
(
"
video
/
mp4
"
)
|
|
aMIMETypeExcludingCodecs
.
EqualsASCII
(
"
video
/
quicktime
"
)
|
|
aMIMETypeExcludingCodecs
.
EqualsASCII
(
"
video
/
x
-
m4v
"
)
;
if
(
!
isMP4Audio
&
&
!
isMP4Video
)
{
return
false
;
}
nsTArray
<
nsCString
>
codecMimes
;
if
(
aCodecs
.
IsEmpty
(
)
)
{
if
(
isMP4Audio
)
{
codecMimes
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
audio
/
mp4a
-
latm
"
)
)
;
}
else
{
MOZ_ASSERT
(
isMP4Video
)
;
codecMimes
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
video
/
avc
"
)
)
;
}
}
else
{
nsTArray
<
nsString
>
codecs
;
if
(
!
ParseCodecsString
(
aCodecs
codecs
)
)
{
return
false
;
}
for
(
const
nsString
&
codec
:
codecs
)
{
if
(
IsAACCodecString
(
codec
)
)
{
codecMimes
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
audio
/
mp4a
-
latm
"
)
)
;
continue
;
}
if
(
codec
.
EqualsLiteral
(
"
mp3
"
)
)
{
codecMimes
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
audio
/
mpeg
"
)
)
;
continue
;
}
if
(
IsWhitelistedH264Codec
(
codec
)
&
&
isMP4Video
)
{
codecMimes
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
video
/
avc
"
)
)
;
continue
;
}
return
false
;
}
}
RefPtr
<
PDMFactory
>
platform
=
new
PDMFactory
(
)
;
for
(
const
nsCString
&
codecMime
:
codecMimes
)
{
if
(
!
platform
-
>
SupportsMimeType
(
codecMime
aDiagnostics
)
)
{
return
false
;
}
}
return
true
;
}
bool
MP4Decoder
:
:
CanHandleMediaType
(
const
nsAString
&
aContentType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
nsContentTypeParser
parser
(
aContentType
)
;
nsAutoString
mimeType
;
nsresult
rv
=
parser
.
GetType
(
mimeType
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
nsString
codecs
;
parser
.
GetParameter
(
"
codecs
"
codecs
)
;
return
CanHandleMediaType
(
NS_ConvertUTF16toUTF8
(
mimeType
)
codecs
aDiagnostics
)
;
}
bool
MP4Decoder
:
:
IsH264
(
const
nsACString
&
aMimeType
)
{
return
aMimeType
.
EqualsLiteral
(
"
video
/
mp4
"
)
|
|
aMimeType
.
EqualsLiteral
(
"
video
/
avc
"
)
;
}
bool
MP4Decoder
:
:
IsEnabled
(
)
{
return
Preferences
:
:
GetBool
(
"
media
.
mp4
.
enabled
"
true
)
;
}
static
const
uint8_t
sTestH264ExtraData
[
]
=
{
0x01
0x42
0xc0
0x1e
0xff
0xe1
0x00
0x17
0x67
0x42
0xc0
0x1e
0xbb
0x40
0x50
0x17
0xfc
0xb8
0x08
0x80
0x00
0x00
0x32
0x00
0x00
0x0b
0xb5
0x07
0x8b
0x17
0x50
0x01
0x00
0x04
0x68
0xce
0x32
0xc8
}
;
static
already_AddRefed
<
MediaDataDecoder
>
CreateTestH264Decoder
(
layers
:
:
KnowsCompositor
*
aKnowsCompositor
VideoInfo
&
aConfig
TaskQueue
*
aTaskQueue
)
{
aConfig
.
mMimeType
=
"
video
/
avc
"
;
aConfig
.
mId
=
1
;
aConfig
.
mDuration
=
40000
;
aConfig
.
mMediaTime
=
0
;
aConfig
.
mImage
=
aConfig
.
mDisplay
=
nsIntSize
(
640
360
)
;
aConfig
.
mExtraData
=
new
MediaByteBuffer
(
)
;
aConfig
.
mExtraData
-
>
AppendElements
(
sTestH264ExtraData
MOZ_ARRAY_LENGTH
(
sTestH264ExtraData
)
)
;
RefPtr
<
PDMFactory
>
platform
=
new
PDMFactory
(
)
;
RefPtr
<
MediaDataDecoder
>
decoder
(
platform
-
>
CreateDecoder
(
{
aConfig
aTaskQueue
aKnowsCompositor
}
)
)
;
return
decoder
.
forget
(
)
;
}
already_AddRefed
<
dom
:
:
Promise
>
MP4Decoder
:
:
IsVideoAccelerated
(
layers
:
:
KnowsCompositor
*
aKnowsCompositor
nsIGlobalObject
*
aParent
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
;
promise
=
dom
:
:
Promise
:
:
Create
(
aParent
rv
)
;
if
(
rv
.
Failed
(
)
)
{
rv
.
SuppressException
(
)
;
return
nullptr
;
}
RefPtr
<
TaskQueue
>
taskQueue
=
new
TaskQueue
(
GetMediaThreadPool
(
MediaThreadType
:
:
PLATFORM_DECODER
)
)
;
VideoInfo
config
;
RefPtr
<
MediaDataDecoder
>
decoder
(
CreateTestH264Decoder
(
aKnowsCompositor
config
taskQueue
)
)
;
if
(
!
decoder
)
{
taskQueue
-
>
BeginShutdown
(
)
;
taskQueue
-
>
AwaitShutdownAndIdle
(
)
;
promise
-
>
MaybeResolve
(
NS_LITERAL_STRING
(
"
No
;
Failed
to
create
H264
decoder
"
)
)
;
return
promise
.
forget
(
)
;
}
decoder
-
>
Init
(
)
-
>
Then
(
AbstractThread
:
:
MainThread
(
)
__func__
[
promise
decoder
taskQueue
]
(
TrackInfo
:
:
TrackType
aTrack
)
{
nsCString
failureReason
;
bool
ok
=
decoder
-
>
IsHardwareAccelerated
(
failureReason
)
;
nsAutoString
result
;
if
(
ok
)
{
result
.
AssignLiteral
(
"
Yes
"
)
;
}
else
{
result
.
AssignLiteral
(
"
No
"
)
;
}
if
(
failureReason
.
Length
(
)
)
{
result
.
AppendLiteral
(
"
;
"
)
;
AppendUTF8toUTF16
(
failureReason
result
)
;
}
decoder
-
>
Shutdown
(
)
;
taskQueue
-
>
BeginShutdown
(
)
;
taskQueue
-
>
AwaitShutdownAndIdle
(
)
;
promise
-
>
MaybeResolve
(
result
)
;
}
[
promise
decoder
taskQueue
]
(
MediaResult
aError
)
{
decoder
-
>
Shutdown
(
)
;
taskQueue
-
>
BeginShutdown
(
)
;
taskQueue
-
>
AwaitShutdownAndIdle
(
)
;
promise
-
>
MaybeResolve
(
NS_LITERAL_STRING
(
"
No
;
Failed
to
initialize
H264
decoder
"
)
)
;
}
)
;
return
promise
.
forget
(
)
;
}
void
MP4Decoder
:
:
GetMozDebugReaderData
(
nsAString
&
aString
)
{
if
(
mReader
)
{
mReader
-
>
GetMozDebugReaderData
(
aString
)
;
}
}
}
