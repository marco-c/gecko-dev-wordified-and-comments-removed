#
include
"
MP4Decoder
.
h
"
#
include
"
MediaContainerType
.
h
"
#
include
"
MediaDecoderStateMachine
.
h
"
#
include
"
MP4Demuxer
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
mozilla
/
CDMProxy
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
VideoUtils
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
nsIGfxInfo
.
h
"
#
endif
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
PDMFactory
.
h
"
namespace
mozilla
{
MP4Decoder
:
:
MP4Decoder
(
MediaDecoderInit
&
aInit
)
:
ChannelMediaDecoder
(
aInit
)
{
}
MediaDecoderStateMachine
*
MP4Decoder
:
:
CreateStateMachine
(
)
{
MediaDecoderReaderInit
init
(
this
)
;
init
.
mVideoFrameContainer
=
GetVideoFrameContainer
(
)
;
init
.
mKnowsCompositor
=
GetCompositor
(
)
;
init
.
mCrashHelper
=
GetOwner
(
)
-
>
CreateGMPCrashHelper
(
)
;
mReader
=
new
MediaFormatReader
(
init
new
MP4Demuxer
(
mResource
)
)
;
return
new
MediaDecoderStateMachine
(
this
mReader
)
;
}
static
bool
IsWhitelistedH264Codec
(
const
nsAString
&
aCodec
)
{
int16_t
profile
=
0
level
=
0
;
if
(
!
ExtractH264CodecDetails
(
aCodec
profile
level
)
)
{
return
false
;
}
return
level
>
=
H264_LEVEL_1
&
&
level
<
=
H264_LEVEL_5_1
&
&
(
profile
=
=
H264_PROFILE_BASE
|
|
profile
=
=
H264_PROFILE_MAIN
|
|
profile
=
=
H264_PROFILE_EXTENDED
|
|
profile
=
=
H264_PROFILE_HIGH
)
;
}
bool
MP4Decoder
:
:
IsSupportedType
(
const
MediaContainerType
&
aType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
if
(
!
IsEnabled
(
)
)
{
return
false
;
}
const
bool
isAudio
=
aType
.
Type
(
)
=
=
MEDIAMIMETYPE
(
"
audio
/
mp4
"
)
|
|
aType
.
Type
(
)
=
=
MEDIAMIMETYPE
(
"
audio
/
x
-
m4a
"
)
;
const
bool
isVideo
=
aType
.
Type
(
)
=
=
MEDIAMIMETYPE
(
"
video
/
mp4
"
)
|
|
aType
.
Type
(
)
=
=
MEDIAMIMETYPE
(
"
video
/
quicktime
"
)
#
ifdef
MOZ_GONK_MEDIACODEC
|
|
aType
.
Type
(
)
=
=
MEDIAMIMETYPE
(
VIDEO_3GPP
)
#
endif
|
|
aType
.
Type
(
)
=
=
MEDIAMIMETYPE
(
"
video
/
x
-
m4v
"
)
;
if
(
!
isAudio
&
&
!
isVideo
)
{
return
false
;
}
nsTArray
<
UniquePtr
<
TrackInfo
>
>
trackInfos
;
if
(
aType
.
ExtendedType
(
)
.
Codecs
(
)
.
IsEmpty
(
)
)
{
if
(
isAudio
)
{
trackInfos
.
AppendElement
(
CreateTrackInfoWithMIMETypeAndContainerTypeExtraParameters
(
NS_LITERAL_CSTRING
(
"
audio
/
mp4a
-
latm
"
)
aType
)
)
;
}
else
{
MOZ_ASSERT
(
isVideo
)
;
trackInfos
.
AppendElement
(
CreateTrackInfoWithMIMETypeAndContainerTypeExtraParameters
(
NS_LITERAL_CSTRING
(
"
video
/
avc
"
)
aType
)
)
;
}
}
else
{
for
(
const
auto
&
codec
:
aType
.
ExtendedType
(
)
.
Codecs
(
)
.
Range
(
)
)
{
if
(
IsAACCodecString
(
codec
)
)
{
trackInfos
.
AppendElement
(
CreateTrackInfoWithMIMETypeAndContainerTypeExtraParameters
(
NS_LITERAL_CSTRING
(
"
audio
/
mp4a
-
latm
"
)
aType
)
)
;
continue
;
}
if
(
codec
.
EqualsLiteral
(
"
mp3
"
)
)
{
trackInfos
.
AppendElement
(
CreateTrackInfoWithMIMETypeAndContainerTypeExtraParameters
(
NS_LITERAL_CSTRING
(
"
audio
/
mpeg
"
)
aType
)
)
;
continue
;
}
if
(
codec
.
EqualsLiteral
(
"
opus
"
)
)
{
trackInfos
.
AppendElement
(
CreateTrackInfoWithMIMETypeAndContainerTypeExtraParameters
(
NS_LITERAL_CSTRING
(
"
audio
/
opus
"
)
aType
)
)
;
continue
;
}
if
(
codec
.
EqualsLiteral
(
"
flac
"
)
)
{
trackInfos
.
AppendElement
(
CreateTrackInfoWithMIMETypeAndContainerTypeExtraParameters
(
NS_LITERAL_CSTRING
(
"
audio
/
flac
"
)
aType
)
)
;
continue
;
}
if
(
codec
.
EqualsLiteral
(
"
vp9
"
)
|
|
codec
.
EqualsLiteral
(
"
vp9
.
0
"
)
)
{
trackInfos
.
AppendElement
(
CreateTrackInfoWithMIMETypeAndContainerTypeExtraParameters
(
NS_LITERAL_CSTRING
(
"
video
/
vp9
"
)
aType
)
)
;
continue
;
}
if
(
IsWhitelistedH264Codec
(
codec
)
&
&
isVideo
)
{
trackInfos
.
AppendElement
(
CreateTrackInfoWithMIMETypeAndContainerTypeExtraParameters
(
NS_LITERAL_CSTRING
(
"
video
/
avc
"
)
aType
)
)
;
continue
;
}
return
false
;
}
}
RefPtr
<
PDMFactory
>
platform
=
new
PDMFactory
(
)
;
for
(
const
auto
&
trackInfo
:
trackInfos
)
{
if
(
!
trackInfo
|
|
!
platform
-
>
Supports
(
*
trackInfo
aDiagnostics
)
)
{
return
false
;
}
}
return
true
;
}
bool
MP4Decoder
:
:
IsH264
(
const
nsACString
&
aMimeType
)
{
return
aMimeType
.
EqualsLiteral
(
"
video
/
mp4
"
)
|
|
aMimeType
.
EqualsLiteral
(
"
video
/
avc
"
)
;
}
bool
MP4Decoder
:
:
IsAAC
(
const
nsACString
&
aMimeType
)
{
return
aMimeType
.
EqualsLiteral
(
"
audio
/
mp4a
-
latm
"
)
;
}
bool
MP4Decoder
:
:
IsEnabled
(
)
{
return
MediaPrefs
:
:
MP4Enabled
(
)
;
}
static
const
uint8_t
sTestH264ExtraData
[
]
=
{
0x01
0x42
0xc0
0x1e
0xff
0xe1
0x00
0x17
0x67
0x42
0xc0
0x1e
0xbb
0x40
0x50
0x17
0xfc
0xb8
0x08
0x80
0x00
0x00
0x32
0x00
0x00
0x0b
0xb5
0x07
0x8b
0x17
0x50
0x01
0x00
0x04
0x68
0xce
0x32
0xc8
}
;
static
already_AddRefed
<
MediaDataDecoder
>
CreateTestH264Decoder
(
layers
:
:
KnowsCompositor
*
aKnowsCompositor
VideoInfo
&
aConfig
TaskQueue
*
aTaskQueue
)
{
aConfig
.
mMimeType
=
"
video
/
avc
"
;
aConfig
.
mId
=
1
;
aConfig
.
mDuration
=
media
:
:
TimeUnit
:
:
FromMicroseconds
(
40000
)
;
aConfig
.
mImage
=
aConfig
.
mDisplay
=
nsIntSize
(
640
360
)
;
aConfig
.
mExtraData
=
new
MediaByteBuffer
(
)
;
aConfig
.
mExtraData
-
>
AppendElements
(
sTestH264ExtraData
MOZ_ARRAY_LENGTH
(
sTestH264ExtraData
)
)
;
RefPtr
<
PDMFactory
>
platform
=
new
PDMFactory
(
)
;
RefPtr
<
MediaDataDecoder
>
decoder
(
platform
-
>
CreateDecoder
(
{
aConfig
aTaskQueue
aKnowsCompositor
}
)
)
;
return
decoder
.
forget
(
)
;
}
already_AddRefed
<
dom
:
:
Promise
>
MP4Decoder
:
:
IsVideoAccelerated
(
layers
:
:
KnowsCompositor
*
aKnowsCompositor
nsIGlobalObject
*
aParent
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
;
promise
=
dom
:
:
Promise
:
:
Create
(
aParent
rv
)
;
if
(
rv
.
Failed
(
)
)
{
rv
.
SuppressException
(
)
;
return
nullptr
;
}
RefPtr
<
TaskQueue
>
taskQueue
=
new
TaskQueue
(
GetMediaThreadPool
(
MediaThreadType
:
:
PLATFORM_DECODER
)
"
MP4Decoder
:
:
IsVideoAccelerated
:
:
taskQueue
"
)
;
VideoInfo
config
;
RefPtr
<
MediaDataDecoder
>
decoder
(
CreateTestH264Decoder
(
aKnowsCompositor
config
taskQueue
)
)
;
if
(
!
decoder
)
{
taskQueue
-
>
BeginShutdown
(
)
;
taskQueue
-
>
AwaitShutdownAndIdle
(
)
;
promise
-
>
MaybeResolve
(
NS_LITERAL_STRING
(
"
No
;
Failed
to
create
H264
decoder
"
)
)
;
return
promise
.
forget
(
)
;
}
decoder
-
>
Init
(
)
-
>
Then
(
aParent
-
>
AbstractMainThreadFor
(
TaskCategory
:
:
Other
)
__func__
[
promise
decoder
taskQueue
]
(
TrackInfo
:
:
TrackType
aTrack
)
{
nsCString
failureReason
;
bool
ok
=
decoder
-
>
IsHardwareAccelerated
(
failureReason
)
;
nsAutoString
result
;
if
(
ok
)
{
result
.
AssignLiteral
(
"
Yes
"
)
;
}
else
{
result
.
AssignLiteral
(
"
No
"
)
;
}
if
(
failureReason
.
Length
(
)
)
{
result
.
AppendLiteral
(
"
;
"
)
;
AppendUTF8toUTF16
(
failureReason
result
)
;
}
decoder
-
>
Shutdown
(
)
;
taskQueue
-
>
BeginShutdown
(
)
;
taskQueue
-
>
AwaitShutdownAndIdle
(
)
;
promise
-
>
MaybeResolve
(
result
)
;
}
[
promise
decoder
taskQueue
]
(
MediaResult
aError
)
{
decoder
-
>
Shutdown
(
)
;
taskQueue
-
>
BeginShutdown
(
)
;
taskQueue
-
>
AwaitShutdownAndIdle
(
)
;
promise
-
>
MaybeResolve
(
NS_LITERAL_STRING
(
"
No
;
Failed
to
initialize
H264
decoder
"
)
)
;
}
)
;
return
promise
.
forget
(
)
;
}
void
MP4Decoder
:
:
GetMozDebugReaderData
(
nsACString
&
aString
)
{
if
(
mReader
)
{
mReader
-
>
GetMozDebugReaderData
(
aString
)
;
}
}
}
