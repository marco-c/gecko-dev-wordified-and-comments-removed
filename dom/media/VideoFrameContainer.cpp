#
include
"
VideoFrameContainer
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
GLImages
.
h
"
#
endif
#
include
"
MediaDecoderOwner
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
using
namespace
mozilla
:
:
layers
;
namespace
mozilla
{
#
define
NS_DispatchToMainThread
(
.
.
.
)
CompileError_UseAbstractMainThreadInstead
VideoFrameContainer
:
:
VideoFrameContainer
(
MediaDecoderOwner
*
aOwner
already_AddRefed
<
ImageContainer
>
aContainer
)
:
mOwner
(
aOwner
)
mImageContainer
(
aContainer
)
mMutex
(
"
nsVideoFrameContainer
"
)
mFrameID
(
0
)
mPendingPrincipalHandle
(
PRINCIPAL_HANDLE_NONE
)
mFrameIDForPendingPrincipalHandle
(
0
)
mMainThread
(
aOwner
-
>
AbstractMainThread
(
)
)
{
NS_ASSERTION
(
aOwner
"
aOwner
must
not
be
null
"
)
;
NS_ASSERTION
(
mImageContainer
"
aContainer
must
not
be
null
"
)
;
}
VideoFrameContainer
:
:
~
VideoFrameContainer
(
)
=
default
;
PrincipalHandle
VideoFrameContainer
:
:
GetLastPrincipalHandle
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
GetLastPrincipalHandleLocked
(
)
;
}
PrincipalHandle
VideoFrameContainer
:
:
GetLastPrincipalHandleLocked
(
)
{
return
mLastPrincipalHandle
;
}
void
VideoFrameContainer
:
:
UpdatePrincipalHandleForFrameID
(
const
PrincipalHandle
&
aPrincipalHandle
const
ImageContainer
:
:
FrameID
&
aFrameID
)
{
MutexAutoLock
lock
(
mMutex
)
;
UpdatePrincipalHandleForFrameIDLocked
(
aPrincipalHandle
aFrameID
)
;
}
void
VideoFrameContainer
:
:
UpdatePrincipalHandleForFrameIDLocked
(
const
PrincipalHandle
&
aPrincipalHandle
const
ImageContainer
:
:
FrameID
&
aFrameID
)
{
if
(
mPendingPrincipalHandle
=
=
aPrincipalHandle
)
{
return
;
}
mPendingPrincipalHandle
=
aPrincipalHandle
;
mFrameIDForPendingPrincipalHandle
=
aFrameID
;
}
#
ifdef
MOZ_WIDGET_ANDROID
static
void
NotifySetCurrent
(
Image
*
aImage
)
{
if
(
aImage
=
=
nullptr
)
{
return
;
}
SurfaceTextureImage
*
image
=
aImage
-
>
AsSurfaceTextureImage
(
)
;
if
(
image
=
=
nullptr
)
{
return
;
}
image
-
>
OnSetCurrent
(
)
;
}
#
endif
void
VideoFrameContainer
:
:
SetCurrentFrame
(
const
gfx
:
:
IntSize
&
aIntrinsicSize
Image
*
aImage
const
TimeStamp
&
aTargetTime
const
media
:
:
TimeUnit
&
aProcessingDuration
const
media
:
:
TimeUnit
&
aMediaTime
)
{
#
ifdef
MOZ_WIDGET_ANDROID
NotifySetCurrent
(
aImage
)
;
#
endif
AutoTArray
<
ImageContainer
:
:
NonOwningImage
1
>
imageList
;
if
(
aImage
)
{
imageList
.
AppendElement
(
ImageContainer
:
:
NonOwningImage
(
aImage
aTargetTime
+
+
mFrameID
0
aProcessingDuration
aMediaTime
)
)
;
}
MutexAutoLock
lock
(
mMutex
)
;
SetCurrentFramesLocked
(
aIntrinsicSize
imageList
)
;
}
void
VideoFrameContainer
:
:
SetCurrentFrames
(
const
gfx
:
:
IntSize
&
aIntrinsicSize
const
nsTArray
<
ImageContainer
:
:
NonOwningImage
>
&
aImages
)
{
#
ifdef
MOZ_WIDGET_ANDROID
Unused
<
<
NS_WARN_IF
(
aImages
.
Length
(
)
>
1
)
;
for
(
auto
&
image
:
aImages
)
{
NotifySetCurrent
(
image
.
mImage
)
;
}
#
endif
MutexAutoLock
lock
(
mMutex
)
;
SetCurrentFramesLocked
(
aIntrinsicSize
aImages
)
;
}
void
VideoFrameContainer
:
:
SetCurrentFramesLocked
(
const
gfx
:
:
IntSize
&
aIntrinsicSize
const
nsTArray
<
ImageContainer
:
:
NonOwningImage
>
&
aImages
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
auto
size
=
Some
(
aIntrinsicSize
)
;
size
!
=
mIntrinsicSize
)
{
mIntrinsicSize
=
size
;
mMainThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
IntrinsicSizeChanged
"
[
this
self
=
RefPtr
(
this
)
size
]
(
)
{
mMainThreadState
.
mNewIntrinsicSize
=
size
;
}
)
)
;
}
gfx
:
:
IntSize
oldFrameSize
=
mImageContainer
-
>
GetCurrentSize
(
)
;
nsTArray
<
ImageContainer
:
:
OwningImage
>
oldImages
;
mImageContainer
-
>
GetCurrentImages
(
&
oldImages
)
;
PrincipalHandle
principalHandle
=
PRINCIPAL_HANDLE_NONE
;
if
(
mPendingPrincipalHandle
!
=
PRINCIPAL_HANDLE_NONE
&
&
(
aImages
.
IsEmpty
(
)
|
|
aImages
[
0
]
.
mFrameID
>
=
mFrameIDForPendingPrincipalHandle
)
)
{
principalHandle
=
mPendingPrincipalHandle
;
mLastPrincipalHandle
=
mPendingPrincipalHandle
;
mPendingPrincipalHandle
=
PRINCIPAL_HANDLE_NONE
;
mFrameIDForPendingPrincipalHandle
=
0
;
}
if
(
aImages
.
IsEmpty
(
)
)
{
mImageContainer
-
>
ClearAllImages
(
)
;
}
else
{
mImageContainer
-
>
SetCurrentImages
(
aImages
)
;
}
gfx
:
:
IntSize
newFrameSize
=
mImageContainer
-
>
GetCurrentSize
(
)
;
bool
imageSizeChanged
=
(
oldFrameSize
!
=
newFrameSize
)
;
if
(
principalHandle
!
=
PRINCIPAL_HANDLE_NONE
|
|
imageSizeChanged
)
{
RefPtr
<
VideoFrameContainer
>
self
=
this
;
mMainThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
PrincipalHandleOrImageSizeChanged
"
[
this
self
principalHandle
imageSizeChanged
]
(
)
{
mMainThreadState
.
mImageSizeChanged
=
imageSizeChanged
;
if
(
mOwner
&
&
principalHandle
!
=
PRINCIPAL_HANDLE_NONE
)
{
mOwner
-
>
PrincipalHandleChangedForVideoFrameContainer
(
this
principalHandle
)
;
}
}
)
)
;
}
}
void
VideoFrameContainer
:
:
ClearFutureFrames
(
TimeStamp
aNow
)
{
MutexAutoLock
lock
(
mMutex
)
;
AutoTArray
<
ImageContainer
:
:
OwningImage
10
>
kungFuDeathGrip
;
mImageContainer
-
>
GetCurrentImages
(
&
kungFuDeathGrip
)
;
if
(
!
kungFuDeathGrip
.
IsEmpty
(
)
)
{
AutoTArray
<
ImageContainer
:
:
NonOwningImage
1
>
currentFrame
;
const
ImageContainer
:
:
OwningImage
*
img
=
&
kungFuDeathGrip
[
0
]
;
for
(
const
auto
&
image
:
kungFuDeathGrip
)
{
if
(
image
.
mTimeStamp
>
aNow
)
{
break
;
}
img
=
&
image
;
}
currentFrame
.
AppendElement
(
ImageContainer
:
:
NonOwningImage
(
img
-
>
mImage
img
-
>
mTimeStamp
img
-
>
mFrameID
img
-
>
mProducerID
img
-
>
mProcessingDuration
img
-
>
mMediaTime
img
-
>
mWebrtcCaptureTime
img
-
>
mWebrtcReceiveTime
img
-
>
mRtpTimestamp
)
)
;
mImageContainer
-
>
SetCurrentImages
(
currentFrame
)
;
}
}
void
VideoFrameContainer
:
:
ClearCachedResources
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
mImageContainer
-
>
ClearCachedResources
(
)
;
}
ImageContainer
*
VideoFrameContainer
:
:
GetImageContainer
(
)
{
return
mImageContainer
;
}
double
VideoFrameContainer
:
:
GetFrameDelay
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mImageContainer
-
>
GetPaintDelay
(
)
.
ToSeconds
(
)
;
}
void
VideoFrameContainer
:
:
InvalidateWithFlags
(
uint32_t
aFlags
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Must
call
on
main
thread
"
)
;
if
(
!
mOwner
)
{
return
;
}
MediaDecoderOwner
:
:
ImageSizeChanged
imageSizeChanged
{
mMainThreadState
.
mImageSizeChanged
}
;
mMainThreadState
.
mImageSizeChanged
=
false
;
auto
newIntrinsicSize
=
std
:
:
move
(
mMainThreadState
.
mNewIntrinsicSize
)
;
MediaDecoderOwner
:
:
ForceInvalidate
forceInvalidate
{
(
aFlags
&
INVALIDATE_FORCE
)
!
=
0
}
;
mOwner
-
>
Invalidate
(
imageSizeChanged
newIntrinsicSize
forceInvalidate
)
;
}
}
#
undef
NS_DispatchToMainThread
