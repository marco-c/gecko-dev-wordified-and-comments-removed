#
if
!
defined
(
MediaDecoderStateMachine_h__
)
#
define
MediaDecoderStateMachine_h__
#
include
"
ImageContainer
.
h
"
#
include
"
MediaDecoder
.
h
"
#
include
"
MediaDecoderOwner
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaFormatReader
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaQueue
.
h
"
#
include
"
MediaSink
.
h
"
#
include
"
MediaStatistics
.
h
"
#
include
"
MediaTimer
.
h
"
#
include
"
SeekJob
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
mozilla
/
dom
/
MediaDebugInfoBinding
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
class
AbstractThread
;
class
AudioSegment
;
class
DecodedStream
;
class
DOMMediaStream
;
class
ReaderProxy
;
class
TaskQueue
;
extern
LazyLogModule
gMediaDecoderLog
;
struct
MediaPlaybackEvent
{
enum
EventType
{
PlaybackStarted
PlaybackStopped
PlaybackProgressed
PlaybackEnded
SeekStarted
Invalidate
EnterVideoSuspend
ExitVideoSuspend
StartVideoSuspendTimer
CancelVideoSuspendTimer
VideoOnlySeekBegin
VideoOnlySeekCompleted
}
mType
;
using
DataType
=
Variant
<
Nothing
int64_t
>
;
DataType
mData
;
MOZ_IMPLICIT
MediaPlaybackEvent
(
EventType
aType
)
:
mType
(
aType
)
mData
(
Nothing
{
}
)
{
}
template
<
typename
T
>
MediaPlaybackEvent
(
EventType
aType
T
&
&
aArg
)
:
mType
(
aType
)
mData
(
std
:
:
forward
<
T
>
(
aArg
)
)
{
}
}
;
enum
class
VideoDecodeMode
:
uint8_t
{
Normal
Suspend
}
;
DDLoggedTypeDeclName
(
MediaDecoderStateMachine
)
;
class
MediaDecoderStateMachine
:
public
DecoderDoctorLifeLogger
<
MediaDecoderStateMachine
>
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDecoderStateMachine
)
using
TrackSet
=
MediaFormatReader
:
:
TrackSet
;
public
:
typedef
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameStatus
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
:
:
FrameID
FrameID
;
MediaDecoderStateMachine
(
MediaDecoder
*
aDecoder
MediaFormatReader
*
aReader
)
;
nsresult
Init
(
MediaDecoder
*
aDecoder
)
;
enum
State
{
DECODER_STATE_DECODING_METADATA
DECODER_STATE_DORMANT
DECODER_STATE_DECODING_FIRSTFRAME
DECODER_STATE_DECODING
DECODER_STATE_LOOPING_DECODING
DECODER_STATE_SEEKING
DECODER_STATE_BUFFERING
DECODER_STATE_COMPLETED
DECODER_STATE_SHUTDOWN
}
;
TaskQueue
*
OwnerThread
(
)
const
{
return
mTaskQueue
;
}
RefPtr
<
GenericPromise
>
RequestDebugInfo
(
dom
:
:
MediaDecoderStateMachineDebugInfo
&
aInfo
)
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
InvokeSeek
(
const
SeekTarget
&
aTarget
)
;
void
DispatchSetPlaybackRate
(
double
aPlaybackRate
)
{
OwnerThread
(
)
-
>
DispatchStateChange
(
NewRunnableMethod
<
double
>
(
"
MediaDecoderStateMachine
:
:
SetPlaybackRate
"
this
&
MediaDecoderStateMachine
:
:
SetPlaybackRate
aPlaybackRate
)
)
;
}
RefPtr
<
ShutdownPromise
>
BeginShutdown
(
)
;
void
DispatchSetFragmentEndTime
(
const
media
:
:
TimeUnit
&
aEndTime
)
{
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
MediaDecoderStateMachine
:
:
DispatchSetFragmentEndTime
"
[
self
aEndTime
]
(
)
{
self
-
>
mFragmentEndTime
=
aEndTime
>
=
media
:
:
TimeUnit
:
:
Zero
(
)
?
aEndTime
:
media
:
:
TimeUnit
:
:
Invalid
(
)
;
}
)
;
nsresult
rv
=
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
Unused
<
<
rv
;
}
void
DispatchCanPlayThrough
(
bool
aCanPlayThrough
)
{
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
MediaDecoderStateMachine
:
:
DispatchCanPlayThrough
"
[
self
aCanPlayThrough
]
(
)
{
self
-
>
mCanPlayThrough
=
aCanPlayThrough
;
}
)
;
OwnerThread
(
)
-
>
DispatchStateChange
(
r
.
forget
(
)
)
;
}
void
DispatchIsLiveStream
(
bool
aIsLiveStream
)
{
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
MediaDecoderStateMachine
:
:
DispatchIsLiveStream
"
[
self
aIsLiveStream
]
(
)
{
self
-
>
mIsLiveStream
=
aIsLiveStream
;
}
)
;
OwnerThread
(
)
-
>
DispatchStateChange
(
r
.
forget
(
)
)
;
}
TimedMetadataEventSource
&
TimedMetadataEvent
(
)
{
return
mMetadataManager
.
TimedMetadataEvent
(
)
;
}
MediaEventSource
<
void
>
&
OnMediaNotSeekable
(
)
const
;
MediaEventSourceExc
<
UniquePtr
<
MediaInfo
>
UniquePtr
<
MetadataTags
>
MediaDecoderEventVisibility
>
&
MetadataLoadedEvent
(
)
{
return
mMetadataLoadedEvent
;
}
MediaEventSourceExc
<
nsAutoPtr
<
MediaInfo
>
MediaDecoderEventVisibility
>
&
FirstFrameLoadedEvent
(
)
{
return
mFirstFrameLoadedEvent
;
}
MediaEventSource
<
MediaPlaybackEvent
>
&
OnPlaybackEvent
(
)
{
return
mOnPlaybackEvent
;
}
MediaEventSource
<
MediaResult
>
&
OnPlaybackErrorEvent
(
)
{
return
mOnPlaybackErrorEvent
;
}
MediaEventSource
<
DecoderDoctorEvent
>
&
OnDecoderDoctorEvent
(
)
{
return
mOnDecoderDoctorEvent
;
}
MediaEventSource
<
NextFrameStatus
>
&
OnNextFrameStatus
(
)
{
return
mOnNextFrameStatus
;
}
size_t
SizeOfVideoQueue
(
)
const
;
size_t
SizeOfAudioQueue
(
)
const
;
void
SetVideoDecodeMode
(
VideoDecodeMode
aMode
)
;
RefPtr
<
GenericPromise
>
InvokeSetSink
(
RefPtr
<
AudioDeviceInfo
>
aSink
)
;
void
SetSecondaryVideoContainer
(
const
RefPtr
<
VideoFrameContainer
>
&
aSecondary
)
;
private
:
class
StateObject
;
class
DecodeMetadataState
;
class
DormantState
;
class
DecodingFirstFrameState
;
class
DecodingState
;
class
LoopingDecodingState
;
class
SeekingState
;
class
AccurateSeekingState
;
class
NextFrameSeekingState
;
class
NextFrameSeekingFromDormantState
;
class
VideoOnlySeekingState
;
class
BufferingState
;
class
CompletedState
;
class
ShutdownState
;
static
const
char
*
ToStateStr
(
State
aState
)
;
const
char
*
ToStateStr
(
)
;
void
GetDebugInfo
(
dom
:
:
MediaDecoderStateMachineDebugInfo
&
aInfo
)
;
bool
OnTaskQueue
(
)
const
;
void
InitializationTask
(
MediaDecoder
*
aDecoder
)
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
Seek
(
const
SeekTarget
&
aTarget
)
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
;
RefPtr
<
ShutdownPromise
>
FinishShutdown
(
)
;
void
UpdatePlaybackPosition
(
const
media
:
:
TimeUnit
&
aTime
)
;
bool
HasAudio
(
)
const
{
return
mInfo
.
ref
(
)
.
HasAudio
(
)
;
}
bool
HasVideo
(
)
const
{
return
mInfo
.
ref
(
)
.
HasVideo
(
)
;
}
const
MediaInfo
&
Info
(
)
const
{
return
mInfo
.
ref
(
)
;
}
void
ScheduleStateMachine
(
)
;
void
ScheduleStateMachineIn
(
const
media
:
:
TimeUnit
&
aTime
)
;
bool
HaveEnoughDecodedAudio
(
)
;
bool
HaveEnoughDecodedVideo
(
)
;
bool
IsPlaying
(
)
const
;
void
SetMediaNotSeekable
(
)
;
void
ResetDecode
(
TrackSet
aTracks
=
TrackSet
(
TrackInfo
:
:
kAudioTrack
TrackInfo
:
:
kVideoTrack
)
)
;
void
SetVideoDecodeModeInternal
(
VideoDecodeMode
aMode
)
;
RefPtr
<
GenericPromise
>
SetSink
(
RefPtr
<
AudioDeviceInfo
>
aSink
)
;
protected
:
virtual
~
MediaDecoderStateMachine
(
)
;
void
BufferedRangeUpdated
(
)
;
void
ReaderSuspendedChanged
(
)
;
void
PushAudio
(
AudioData
*
aSample
)
;
void
PushVideo
(
VideoData
*
aSample
)
;
void
OnAudioPopped
(
const
RefPtr
<
AudioData
>
&
aSample
)
;
void
OnVideoPopped
(
const
RefPtr
<
VideoData
>
&
aSample
)
;
void
AudioAudibleChanged
(
bool
aAudible
)
;
void
VolumeChanged
(
)
;
void
SetPlaybackRate
(
double
aPlaybackRate
)
;
void
PreservesPitchChanged
(
)
;
void
LoopingChanged
(
)
;
void
UpdateOutputCaptured
(
)
;
void
OutputTracksChanged
(
)
;
void
OutputPrincipalChanged
(
)
;
MediaQueue
<
AudioData
>
&
AudioQueue
(
)
{
return
mAudioQueue
;
}
MediaQueue
<
VideoData
>
&
VideoQueue
(
)
{
return
mVideoQueue
;
}
bool
HasLowDecodedData
(
)
;
bool
HasLowDecodedAudio
(
)
;
bool
HasLowDecodedVideo
(
)
;
bool
OutOfDecodedAudio
(
)
;
bool
OutOfDecodedVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
IsVideoDecoding
(
)
&
&
VideoQueue
(
)
.
GetSize
(
)
<
=
1
;
}
bool
HasLowBufferedData
(
)
;
bool
HasLowBufferedData
(
const
media
:
:
TimeUnit
&
aThreshold
)
;
media
:
:
TimeUnit
GetClock
(
TimeStamp
*
aTimeStamp
=
nullptr
)
const
;
void
UpdatePlaybackPositionInternal
(
const
media
:
:
TimeUnit
&
aTime
)
;
void
UpdatePlaybackPositionPeriodically
(
)
;
MediaSink
*
CreateAudioSink
(
)
;
already_AddRefed
<
MediaSink
>
CreateMediaSink
(
)
;
void
StopMediaSink
(
)
;
nsresult
StartMediaSink
(
)
;
void
PlayStateChanged
(
)
;
void
VisibilityChanged
(
)
;
void
StopPlayback
(
)
;
void
MaybeStartPlayback
(
)
;
void
DecodeError
(
const
MediaResult
&
aError
)
;
void
EnqueueFirstFrameLoadedEvent
(
)
;
void
RequestAudioData
(
)
;
void
RequestVideoData
(
const
media
:
:
TimeUnit
&
aCurrentTime
)
;
void
WaitForData
(
MediaData
:
:
Type
aType
)
;
bool
IsRequestingAudioData
(
)
const
{
return
mAudioDataRequest
.
Exists
(
)
;
}
bool
IsRequestingVideoData
(
)
const
{
return
mVideoDataRequest
.
Exists
(
)
;
}
bool
IsWaitingAudioData
(
)
const
{
return
mAudioWaitRequest
.
Exists
(
)
;
}
bool
IsWaitingVideoData
(
)
const
{
return
mVideoWaitRequest
.
Exists
(
)
;
}
media
:
:
TimeUnit
GetMediaTime
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mCurrentPosition
;
}
media
:
:
TimeUnit
GetDecodedAudioDuration
(
)
;
void
FinishDecodeFirstFrame
(
)
;
void
RunStateMachine
(
)
;
bool
IsStateMachineScheduled
(
)
const
;
bool
IsAudioDecoding
(
)
;
bool
IsVideoDecoding
(
)
;
private
:
void
OnMediaSinkAudioComplete
(
)
;
void
OnMediaSinkVideoComplete
(
)
;
void
OnMediaSinkAudioError
(
nsresult
aResult
)
;
void
OnMediaSinkVideoError
(
)
;
void
*
const
mDecoderID
;
const
RefPtr
<
AbstractThread
>
mAbstractMainThread
;
const
RefPtr
<
FrameStatistics
>
mFrameStats
;
const
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
WatchManager
<
MediaDecoderStateMachine
>
mWatchManager
;
bool
mDispatchedStateMachine
;
DelayedScheduler
mDelayedScheduler
;
MediaQueue
<
AudioData
>
mAudioQueue
;
MediaQueue
<
VideoData
>
mVideoQueue
;
UniquePtr
<
StateObject
>
mStateObj
;
media
:
:
TimeUnit
Duration
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mDuration
.
Ref
(
)
.
ref
(
)
;
}
FrameID
mCurrentFrameID
;
media
:
:
TimeUnit
mFragmentEndTime
=
media
:
:
TimeUnit
:
:
Invalid
(
)
;
RefPtr
<
MediaSink
>
mMediaSink
;
const
RefPtr
<
ReaderProxy
>
mReader
;
media
:
:
TimeUnit
AudioEndTime
(
)
const
;
media
:
:
TimeUnit
VideoEndTime
(
)
const
;
media
:
:
TimeUnit
mDecodedAudioEndTime
;
media
:
:
TimeUnit
mDecodedVideoEndTime
;
double
mPlaybackRate
;
uint32_t
GetAmpleVideoFrames
(
)
const
;
media
:
:
TimeUnit
mAmpleAudioThreshold
;
using
AudioDataPromise
=
MediaFormatReader
:
:
AudioDataPromise
;
using
VideoDataPromise
=
MediaFormatReader
:
:
VideoDataPromise
;
using
WaitForDataPromise
=
MediaFormatReader
:
:
WaitForDataPromise
;
MozPromiseRequestHolder
<
AudioDataPromise
>
mAudioDataRequest
;
MozPromiseRequestHolder
<
VideoDataPromise
>
mVideoDataRequest
;
MozPromiseRequestHolder
<
WaitForDataPromise
>
mAudioWaitRequest
;
MozPromiseRequestHolder
<
WaitForDataPromise
>
mVideoWaitRequest
;
const
char
*
AudioRequestStatus
(
)
const
;
const
char
*
VideoRequestStatus
(
)
const
;
void
OnSuspendTimerResolved
(
)
;
void
CancelSuspendTimer
(
)
;
bool
IsInSeamlessLooping
(
)
const
;
bool
mCanPlayThrough
=
false
;
bool
mIsLiveStream
=
false
;
bool
mAudioCompleted
=
false
;
bool
mVideoCompleted
=
false
;
bool
mMinimizePreroll
;
Maybe
<
MediaInfo
>
mInfo
;
mozilla
:
:
MediaMetadataManager
mMetadataManager
;
bool
mSentFirstFrameLoadedEvent
;
bool
mVideoDecodeSuspended
;
bool
mMediaSeekable
=
true
;
bool
mMediaSeekableOnlyInBufferedRanges
=
false
;
DelayedScheduler
mVideoDecodeSuspendTimer
;
VideoDecodeMode
mVideoDecodeMode
;
MozPromiseRequestHolder
<
MediaSink
:
:
EndedPromise
>
mMediaSinkAudioEndedPromise
;
MozPromiseRequestHolder
<
MediaSink
:
:
EndedPromise
>
mMediaSinkVideoEndedPromise
;
MediaEventListener
mAudioQueueListener
;
MediaEventListener
mVideoQueueListener
;
MediaEventListener
mAudibleListener
;
MediaEventListener
mOnMediaNotSeekable
;
MediaEventProducerExc
<
UniquePtr
<
MediaInfo
>
UniquePtr
<
MetadataTags
>
MediaDecoderEventVisibility
>
mMetadataLoadedEvent
;
MediaEventProducerExc
<
nsAutoPtr
<
MediaInfo
>
MediaDecoderEventVisibility
>
mFirstFrameLoadedEvent
;
MediaEventProducer
<
MediaPlaybackEvent
>
mOnPlaybackEvent
;
MediaEventProducer
<
MediaResult
>
mOnPlaybackErrorEvent
;
MediaEventProducer
<
DecoderDoctorEvent
>
mOnDecoderDoctorEvent
;
MediaEventProducer
<
NextFrameStatus
>
mOnNextFrameStatus
;
const
bool
mIsMSE
;
bool
mSeamlessLoopingAllowed
;
void
AdjustByLooping
(
media
:
:
TimeUnit
&
aTime
)
const
;
Maybe
<
media
:
:
TimeUnit
>
mAudioDecodedDuration
;
int64_t
mPlaybackOffset
=
0
;
private
:
Mirror
<
media
:
:
TimeIntervals
>
mBuffered
;
Mirror
<
MediaDecoder
:
:
PlayState
>
mPlayState
;
Mirror
<
double
>
mVolume
;
Mirror
<
bool
>
mPreservesPitch
;
Mirror
<
bool
>
mLooping
;
Mirror
<
RefPtr
<
AudioDeviceInfo
>
>
mSinkDevice
;
Mirror
<
bool
>
mOutputCaptured
;
Mirror
<
nsTArray
<
RefPtr
<
ProcessedMediaTrack
>
>
>
mOutputTracks
;
Mirror
<
PrincipalHandle
>
mOutputPrincipal
;
Canonical
<
nsTArray
<
RefPtr
<
ProcessedMediaTrack
>
>
>
mCanonicalOutputTracks
;
Canonical
<
PrincipalHandle
>
mCanonicalOutputPrincipal
;
Canonical
<
media
:
:
NullableTimeUnit
>
mDuration
;
Canonical
<
media
:
:
TimeUnit
>
mCurrentPosition
;
Canonical
<
bool
>
mIsAudioDataAudible
;
public
:
AbstractCanonical
<
media
:
:
TimeIntervals
>
*
CanonicalBuffered
(
)
const
;
AbstractCanonical
<
nsTArray
<
RefPtr
<
ProcessedMediaTrack
>
>
>
*
CanonicalOutputTracks
(
)
{
return
&
mCanonicalOutputTracks
;
}
AbstractCanonical
<
PrincipalHandle
>
*
CanonicalOutputPrincipal
(
)
{
return
&
mCanonicalOutputPrincipal
;
}
AbstractCanonical
<
media
:
:
NullableTimeUnit
>
*
CanonicalDuration
(
)
{
return
&
mDuration
;
}
AbstractCanonical
<
media
:
:
TimeUnit
>
*
CanonicalCurrentPosition
(
)
{
return
&
mCurrentPosition
;
}
AbstractCanonical
<
bool
>
*
CanonicalIsAudioDataAudible
(
)
{
return
&
mIsAudioDataAudible
;
}
}
;
}
#
endif
