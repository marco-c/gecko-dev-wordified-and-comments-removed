#
if
!
defined
(
MediaDecoderStateMachine_h__
)
#
define
MediaDecoderStateMachine_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
MediaDecoder
.
h
"
#
include
"
MediaDecoderOwner
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaFormatReader
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaQueue
.
h
"
#
include
"
MediaStatistics
.
h
"
#
include
"
MediaTimer
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
SeekJob
.
h
"
namespace
mozilla
{
namespace
media
{
class
MediaSink
;
}
class
AbstractThread
;
class
AudioSegment
;
class
DecodedStream
;
class
OutputStreamManager
;
class
ReaderProxy
;
class
TaskQueue
;
extern
LazyLogModule
gMediaDecoderLog
;
enum
class
MediaEventType
:
int8_t
{
PlaybackStarted
PlaybackStopped
PlaybackEnded
SeekStarted
Invalidate
EnterVideoSuspend
ExitVideoSuspend
StartVideoSuspendTimer
CancelVideoSuspendTimer
VideoOnlySeekBegin
VideoOnlySeekCompleted
}
;
enum
class
VideoDecodeMode
:
uint8_t
{
Normal
Suspend
}
;
class
MediaDecoderStateMachine
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDecoderStateMachine
)
using
TrackSet
=
MediaFormatReader
:
:
TrackSet
;
public
:
typedef
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameStatus
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
:
:
FrameID
FrameID
;
MediaDecoderStateMachine
(
MediaDecoder
*
aDecoder
MediaFormatReader
*
aReader
)
;
nsresult
Init
(
MediaDecoder
*
aDecoder
)
;
enum
State
{
DECODER_STATE_DECODING_METADATA
DECODER_STATE_WAIT_FOR_CDM
DECODER_STATE_DORMANT
DECODER_STATE_DECODING_FIRSTFRAME
DECODER_STATE_DECODING
DECODER_STATE_SEEKING
DECODER_STATE_BUFFERING
DECODER_STATE_COMPLETED
DECODER_STATE_SHUTDOWN
}
;
RefPtr
<
MediaDecoder
:
:
DebugInfoPromise
>
RequestDebugInfo
(
)
;
void
AddOutputStream
(
ProcessedMediaStream
*
aStream
bool
aFinishWhenEnded
)
;
void
RemoveOutputStream
(
MediaStream
*
aStream
)
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
InvokeSeek
(
const
SeekTarget
&
aTarget
)
;
void
DispatchSetPlaybackRate
(
double
aPlaybackRate
)
{
OwnerThread
(
)
-
>
DispatchStateChange
(
NewRunnableMethod
<
double
>
(
"
MediaDecoderStateMachine
:
:
SetPlaybackRate
"
this
&
MediaDecoderStateMachine
:
:
SetPlaybackRate
aPlaybackRate
)
)
;
}
RefPtr
<
ShutdownPromise
>
BeginShutdown
(
)
;
void
DispatchSetFragmentEndTime
(
const
media
:
:
TimeUnit
&
aEndTime
)
{
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
MediaDecoderStateMachine
:
:
DispatchSetFragmentEndTime
"
[
self
aEndTime
]
(
)
{
self
-
>
mFragmentEndTime
=
aEndTime
>
=
media
:
:
TimeUnit
:
:
Zero
(
)
?
aEndTime
:
media
:
:
TimeUnit
:
:
Invalid
(
)
;
}
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
BreakCycles
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mResource
=
nullptr
;
}
TimedMetadataEventSource
&
TimedMetadataEvent
(
)
{
return
mMetadataManager
.
TimedMetadataEvent
(
)
;
}
MediaEventSource
<
void
>
&
OnMediaNotSeekable
(
)
const
;
MediaEventSourceExc
<
UniquePtr
<
MediaInfo
>
UniquePtr
<
MetadataTags
>
MediaDecoderEventVisibility
>
&
MetadataLoadedEvent
(
)
{
return
mMetadataLoadedEvent
;
}
MediaEventSourceExc
<
nsAutoPtr
<
MediaInfo
>
MediaDecoderEventVisibility
>
&
FirstFrameLoadedEvent
(
)
{
return
mFirstFrameLoadedEvent
;
}
MediaEventSource
<
MediaEventType
>
&
OnPlaybackEvent
(
)
{
return
mOnPlaybackEvent
;
}
MediaEventSource
<
MediaResult
>
&
OnPlaybackErrorEvent
(
)
{
return
mOnPlaybackErrorEvent
;
}
MediaEventSource
<
DecoderDoctorEvent
>
&
OnDecoderDoctorEvent
(
)
{
return
mOnDecoderDoctorEvent
;
}
size_t
SizeOfVideoQueue
(
)
const
;
size_t
SizeOfAudioQueue
(
)
const
;
void
SetVideoDecodeMode
(
VideoDecodeMode
aMode
)
;
private
:
class
StateObject
;
class
DecodeMetadataState
;
class
WaitForCDMState
;
class
DormantState
;
class
DecodingFirstFrameState
;
class
DecodingState
;
class
SeekingState
;
class
AccurateSeekingState
;
class
NextFrameSeekingState
;
class
NextFrameSeekingFromDormantState
;
class
VideoOnlySeekingState
;
class
BufferingState
;
class
CompletedState
;
class
ShutdownState
;
static
const
char
*
ToStateStr
(
State
aState
)
;
static
const
char
*
ToStr
(
NextFrameStatus
aStatus
)
;
const
char
*
ToStateStr
(
)
;
nsCString
GetDebugInfo
(
)
;
bool
OnTaskQueue
(
)
const
;
void
InitializationTask
(
MediaDecoder
*
aDecoder
)
;
void
SetAudioCaptured
(
bool
aCaptured
)
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
Seek
(
const
SeekTarget
&
aTarget
)
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
;
RefPtr
<
ShutdownPromise
>
FinishShutdown
(
)
;
void
UpdatePlaybackPosition
(
const
media
:
:
TimeUnit
&
aTime
)
;
bool
CanPlayThrough
(
)
;
MediaStatistics
GetStatistics
(
)
;
bool
HasAudio
(
)
const
{
return
mInfo
.
ref
(
)
.
HasAudio
(
)
;
}
bool
HasVideo
(
)
const
{
return
mInfo
.
ref
(
)
.
HasVideo
(
)
;
}
const
MediaInfo
&
Info
(
)
const
{
return
mInfo
.
ref
(
)
;
}
TaskQueue
*
OwnerThread
(
)
const
{
return
mTaskQueue
;
}
void
ScheduleStateMachine
(
)
;
void
ScheduleStateMachineIn
(
const
media
:
:
TimeUnit
&
aTime
)
;
bool
HaveEnoughDecodedAudio
(
)
;
bool
HaveEnoughDecodedVideo
(
)
;
bool
IsPlaying
(
)
const
;
void
SetMediaNotSeekable
(
)
;
void
ResetDecode
(
TrackSet
aTracks
=
TrackSet
(
TrackInfo
:
:
kAudioTrack
TrackInfo
:
:
kVideoTrack
)
)
;
void
SetVideoDecodeModeInternal
(
VideoDecodeMode
aMode
)
;
protected
:
virtual
~
MediaDecoderStateMachine
(
)
;
void
BufferedRangeUpdated
(
)
;
void
ReaderSuspendedChanged
(
)
;
void
PushAudio
(
AudioData
*
aSample
)
;
void
PushVideo
(
VideoData
*
aSample
)
;
void
OnAudioPopped
(
const
RefPtr
<
AudioData
>
&
aSample
)
;
void
OnVideoPopped
(
const
RefPtr
<
VideoData
>
&
aSample
)
;
void
AudioAudibleChanged
(
bool
aAudible
)
;
void
VolumeChanged
(
)
;
void
SetPlaybackRate
(
double
aPlaybackRate
)
;
void
PreservesPitchChanged
(
)
;
MediaQueue
<
AudioData
>
&
AudioQueue
(
)
{
return
mAudioQueue
;
}
MediaQueue
<
VideoData
>
&
VideoQueue
(
)
{
return
mVideoQueue
;
}
bool
HasLowDecodedData
(
)
;
bool
HasLowDecodedAudio
(
)
;
bool
HasLowDecodedVideo
(
)
;
bool
OutOfDecodedAudio
(
)
;
bool
OutOfDecodedVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
IsVideoDecoding
(
)
&
&
VideoQueue
(
)
.
GetSize
(
)
<
=
1
;
}
bool
HasLowBufferedData
(
)
;
bool
HasLowBufferedData
(
const
media
:
:
TimeUnit
&
aThreshold
)
;
void
UpdateNextFrameStatus
(
NextFrameStatus
aStatus
)
;
media
:
:
TimeUnit
GetClock
(
TimeStamp
*
aTimeStamp
=
nullptr
)
const
;
void
UpdatePlaybackPositionInternal
(
const
media
:
:
TimeUnit
&
aTime
)
;
void
UpdatePlaybackPositionPeriodically
(
)
;
media
:
:
MediaSink
*
CreateAudioSink
(
)
;
already_AddRefed
<
media
:
:
MediaSink
>
CreateMediaSink
(
bool
aAudioCaptured
)
;
void
StopMediaSink
(
)
;
void
StartMediaSink
(
)
;
void
PlayStateChanged
(
)
;
void
VisibilityChanged
(
)
;
void
StopPlayback
(
)
;
void
MaybeStartPlayback
(
)
;
void
DecodeError
(
const
MediaResult
&
aError
)
;
void
EnqueueFirstFrameLoadedEvent
(
)
;
void
RequestAudioData
(
)
;
void
RequestVideoData
(
const
media
:
:
TimeUnit
&
aCurrentTime
)
;
void
WaitForData
(
MediaData
:
:
Type
aType
)
;
bool
IsRequestingAudioData
(
)
const
{
return
mAudioDataRequest
.
Exists
(
)
;
}
bool
IsRequestingVideoData
(
)
const
{
return
mVideoDataRequest
.
Exists
(
)
;
}
bool
IsWaitingAudioData
(
)
const
{
return
mAudioWaitRequest
.
Exists
(
)
;
}
bool
IsWaitingVideoData
(
)
const
{
return
mVideoWaitRequest
.
Exists
(
)
;
}
media
:
:
TimeUnit
GetMediaTime
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mCurrentPosition
;
}
media
:
:
TimeUnit
GetDecodedAudioDuration
(
)
;
void
FinishDecodeFirstFrame
(
)
;
void
RunStateMachine
(
)
;
bool
IsStateMachineScheduled
(
)
const
;
bool
IsAudioDecoding
(
)
;
bool
IsVideoDecoding
(
)
;
private
:
void
OnMediaSinkAudioComplete
(
)
;
void
OnMediaSinkVideoComplete
(
)
;
void
OnMediaSinkAudioError
(
nsresult
aResult
)
;
void
OnMediaSinkVideoError
(
)
;
void
*
const
mDecoderID
;
const
RefPtr
<
AbstractThread
>
mAbstractMainThread
;
const
RefPtr
<
FrameStatistics
>
mFrameStats
;
const
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
const
dom
:
:
AudioChannel
mAudioChannel
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
WatchManager
<
MediaDecoderStateMachine
>
mWatchManager
;
bool
mDispatchedStateMachine
;
DelayedScheduler
mDelayedScheduler
;
MediaQueue
<
AudioData
>
mAudioQueue
;
MediaQueue
<
VideoData
>
mVideoQueue
;
UniquePtr
<
StateObject
>
mStateObj
;
media
:
:
TimeUnit
Duration
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mDuration
.
Ref
(
)
.
ref
(
)
;
}
void
RecomputeDuration
(
)
;
FrameID
mCurrentFrameID
;
Watchable
<
media
:
:
TimeUnit
>
mObservedDuration
;
bool
IsLogicallyPlaying
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mPlayState
=
=
MediaDecoder
:
:
PLAY_STATE_PLAYING
|
|
mNextPlayState
=
=
MediaDecoder
:
:
PLAY_STATE_PLAYING
;
}
media
:
:
TimeUnit
mFragmentEndTime
=
media
:
:
TimeUnit
:
:
Invalid
(
)
;
RefPtr
<
media
:
:
MediaSink
>
mMediaSink
;
const
RefPtr
<
ReaderProxy
>
mReader
;
media
:
:
TimeUnit
AudioEndTime
(
)
const
;
media
:
:
TimeUnit
VideoEndTime
(
)
const
;
media
:
:
TimeUnit
mDecodedAudioEndTime
;
media
:
:
TimeUnit
mDecodedVideoEndTime
;
double
mPlaybackRate
;
uint32_t
GetAmpleVideoFrames
(
)
const
;
media
:
:
TimeUnit
mAmpleAudioThreshold
;
using
AudioDataPromise
=
MediaFormatReader
:
:
AudioDataPromise
;
using
VideoDataPromise
=
MediaFormatReader
:
:
VideoDataPromise
;
using
WaitForDataPromise
=
MediaFormatReader
:
:
WaitForDataPromise
;
MozPromiseRequestHolder
<
AudioDataPromise
>
mAudioDataRequest
;
MozPromiseRequestHolder
<
VideoDataPromise
>
mVideoDataRequest
;
MozPromiseRequestHolder
<
WaitForDataPromise
>
mAudioWaitRequest
;
MozPromiseRequestHolder
<
WaitForDataPromise
>
mVideoWaitRequest
;
const
char
*
AudioRequestStatus
(
)
const
;
const
char
*
VideoRequestStatus
(
)
const
;
void
OnSuspendTimerResolved
(
)
;
void
CancelSuspendTimer
(
)
;
bool
mAudioCaptured
;
bool
mAudioCompleted
=
false
;
bool
mVideoCompleted
=
false
;
bool
mMinimizePreroll
;
Maybe
<
MediaInfo
>
mInfo
;
mozilla
:
:
MediaMetadataManager
mMetadataManager
;
bool
mSentFirstFrameLoadedEvent
;
bool
mVideoDecodeSuspended
;
bool
mMediaSeekable
=
true
;
bool
mMediaSeekableOnlyInBufferedRanges
=
false
;
DelayedScheduler
mVideoDecodeSuspendTimer
;
const
RefPtr
<
OutputStreamManager
>
mOutputStreamManager
;
RefPtr
<
MediaResource
>
mResource
;
VideoDecodeMode
mVideoDecodeMode
;
MozPromiseRequestHolder
<
GenericPromise
>
mMediaSinkAudioPromise
;
MozPromiseRequestHolder
<
GenericPromise
>
mMediaSinkVideoPromise
;
MediaEventListener
mAudioQueueListener
;
MediaEventListener
mVideoQueueListener
;
MediaEventListener
mAudibleListener
;
MediaEventListener
mOnMediaNotSeekable
;
MediaEventProducerExc
<
UniquePtr
<
MediaInfo
>
UniquePtr
<
MetadataTags
>
MediaDecoderEventVisibility
>
mMetadataLoadedEvent
;
MediaEventProducerExc
<
nsAutoPtr
<
MediaInfo
>
MediaDecoderEventVisibility
>
mFirstFrameLoadedEvent
;
MediaEventProducer
<
MediaEventType
>
mOnPlaybackEvent
;
MediaEventProducer
<
MediaResult
>
mOnPlaybackErrorEvent
;
MediaEventProducer
<
DecoderDoctorEvent
>
mOnDecoderDoctorEvent
;
void
OnCDMProxyReady
(
RefPtr
<
CDMProxy
>
aProxy
)
;
void
OnCDMProxyNotReady
(
)
;
RefPtr
<
CDMProxy
>
mCDMProxy
;
MozPromiseRequestHolder
<
MediaDecoder
:
:
CDMProxyPromise
>
mCDMProxyPromise
;
const
bool
mIsMSE
;
private
:
Mirror
<
media
:
:
TimeIntervals
>
mBuffered
;
Mirror
<
Maybe
<
double
>
>
mExplicitDuration
;
Mirror
<
MediaDecoder
:
:
PlayState
>
mPlayState
;
Mirror
<
MediaDecoder
:
:
PlayState
>
mNextPlayState
;
Mirror
<
double
>
mVolume
;
Mirror
<
bool
>
mPreservesPitch
;
Mirror
<
bool
>
mLooping
;
Mirror
<
bool
>
mSameOriginMedia
;
Mirror
<
PrincipalHandle
>
mMediaPrincipalHandle
;
Mirror
<
double
>
mPlaybackBytesPerSecond
;
Mirror
<
bool
>
mPlaybackRateReliable
;
Mirror
<
int64_t
>
mDecoderPosition
;
Canonical
<
media
:
:
NullableTimeUnit
>
mDuration
;
Canonical
<
NextFrameStatus
>
mNextFrameStatus
;
Canonical
<
media
:
:
TimeUnit
>
mCurrentPosition
;
Canonical
<
int64_t
>
mPlaybackOffset
;
Canonical
<
bool
>
mIsAudioDataAudible
;
public
:
AbstractCanonical
<
media
:
:
TimeIntervals
>
*
CanonicalBuffered
(
)
const
;
AbstractCanonical
<
media
:
:
NullableTimeUnit
>
*
CanonicalDuration
(
)
{
return
&
mDuration
;
}
AbstractCanonical
<
NextFrameStatus
>
*
CanonicalNextFrameStatus
(
)
{
return
&
mNextFrameStatus
;
}
AbstractCanonical
<
media
:
:
TimeUnit
>
*
CanonicalCurrentPosition
(
)
{
return
&
mCurrentPosition
;
}
AbstractCanonical
<
int64_t
>
*
CanonicalPlaybackOffset
(
)
{
return
&
mPlaybackOffset
;
}
AbstractCanonical
<
bool
>
*
CanonicalIsAudioDataAudible
(
)
{
return
&
mIsAudioDataAudible
;
}
#
ifdef
XP_WIN
bool
mHiResTimersRequested
=
false
;
const
bool
mShouldUseHiResTimers
;
#
endif
}
;
}
#
endif
