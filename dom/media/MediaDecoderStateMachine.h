#
if
!
defined
(
MediaDecoderStateMachine_h__
)
#
define
MediaDecoderStateMachine_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
MediaDecoder
.
h
"
#
include
"
MediaDecoderReader
.
h
"
#
include
"
MediaDecoderOwner
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaStatistics
.
h
"
#
include
"
MediaTimer
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
SeekJob
.
h
"
#
include
"
SeekTask
.
h
"
namespace
mozilla
{
namespace
media
{
class
MediaSink
;
}
class
AudioSegment
;
class
DecodedStream
;
class
MediaDecoderReaderWrapper
;
class
OutputStreamManager
;
class
TaskQueue
;
extern
LazyLogModule
gMediaDecoderLog
;
extern
LazyLogModule
gMediaSampleLog
;
enum
class
MediaEventType
:
int8_t
{
PlaybackStarted
PlaybackStopped
PlaybackEnded
SeekStarted
Invalidate
EnterVideoSuspend
ExitVideoSuspend
}
;
class
MediaDecoderStateMachine
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDecoderStateMachine
)
using
TrackSet
=
MediaDecoderReader
:
:
TrackSet
;
public
:
typedef
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameStatus
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
:
:
FrameID
FrameID
;
MediaDecoderStateMachine
(
MediaDecoder
*
aDecoder
MediaDecoderReader
*
aReader
)
;
nsresult
Init
(
MediaDecoder
*
aDecoder
)
;
void
SetMediaDecoderReaderWrapperCallback
(
)
;
void
CancelMediaDecoderReaderWrapperCallback
(
)
;
enum
State
{
DECODER_STATE_DECODING_METADATA
DECODER_STATE_WAIT_FOR_CDM
DECODER_STATE_DORMANT
DECODER_STATE_DECODING_FIRSTFRAME
DECODER_STATE_DECODING
DECODER_STATE_SEEKING
DECODER_STATE_BUFFERING
DECODER_STATE_COMPLETED
DECODER_STATE_SHUTDOWN
}
;
void
DumpDebugInfo
(
)
;
void
AddOutputStream
(
ProcessedMediaStream
*
aStream
bool
aFinishWhenEnded
)
;
void
RemoveOutputStream
(
MediaStream
*
aStream
)
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
InvokeSeek
(
SeekTarget
aTarget
)
;
void
DispatchSetPlaybackRate
(
double
aPlaybackRate
)
{
OwnerThread
(
)
-
>
DispatchStateChange
(
NewRunnableMethod
<
double
>
(
this
&
MediaDecoderStateMachine
:
:
SetPlaybackRate
aPlaybackRate
)
)
;
}
void
DispatchSetDormant
(
bool
aDormant
)
;
RefPtr
<
ShutdownPromise
>
BeginShutdown
(
)
;
void
DispatchMinimizePrerollUntilPlaybackStarts
(
)
{
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
self
]
(
)
-
>
void
{
MOZ_ASSERT
(
self
-
>
OnTaskQueue
(
)
)
;
self
-
>
mMinimizePreroll
=
true
;
MOZ_DIAGNOSTIC_ASSERT
(
self
-
>
mPlayState
=
=
MediaDecoder
:
:
PLAY_STATE_LOADING
)
;
}
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
DispatchSetFragmentEndTime
(
int64_t
aEndTime
)
{
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
self
aEndTime
]
(
)
{
self
-
>
mFragmentEndTime
=
aEndTime
;
}
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
DispatchAudioOffloading
(
bool
aAudioOffloading
)
{
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
=
]
(
)
{
if
(
self
-
>
mAudioOffloading
!
=
aAudioOffloading
)
{
self
-
>
mAudioOffloading
=
aAudioOffloading
;
self
-
>
ScheduleStateMachine
(
)
;
}
}
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
BreakCycles
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mResource
=
nullptr
;
}
TimedMetadataEventSource
&
TimedMetadataEvent
(
)
{
return
mMetadataManager
.
TimedMetadataEvent
(
)
;
}
MediaEventSource
<
void
>
&
OnMediaNotSeekable
(
)
const
;
MediaEventSourceExc
<
nsAutoPtr
<
MediaInfo
>
nsAutoPtr
<
MetadataTags
>
MediaDecoderEventVisibility
>
&
MetadataLoadedEvent
(
)
{
return
mMetadataLoadedEvent
;
}
MediaEventSourceExc
<
nsAutoPtr
<
MediaInfo
>
MediaDecoderEventVisibility
>
&
FirstFrameLoadedEvent
(
)
{
return
mFirstFrameLoadedEvent
;
}
MediaEventSource
<
MediaEventType
>
&
OnPlaybackEvent
(
)
{
return
mOnPlaybackEvent
;
}
MediaEventSource
<
MediaResult
>
&
OnPlaybackErrorEvent
(
)
{
return
mOnPlaybackErrorEvent
;
}
MediaEventSource
<
DecoderDoctorEvent
>
&
OnDecoderDoctorEvent
(
)
{
return
mOnDecoderDoctorEvent
;
}
size_t
SizeOfVideoQueue
(
)
const
;
size_t
SizeOfAudioQueue
(
)
const
;
private
:
class
StateObject
;
class
DecodeMetadataState
;
class
WaitForCDMState
;
class
DormantState
;
class
DecodingFirstFrameState
;
class
DecodingState
;
class
SeekingState
;
class
BufferingState
;
class
CompletedState
;
class
ShutdownState
;
static
const
char
*
ToStateStr
(
State
aState
)
;
const
char
*
ToStateStr
(
)
;
bool
OnTaskQueue
(
)
const
;
void
InitializationTask
(
MediaDecoder
*
aDecoder
)
;
void
SetDormant
(
bool
aDormant
)
;
void
SetAudioCaptured
(
bool
aCaptured
)
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
Seek
(
SeekTarget
aTarget
)
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
;
RefPtr
<
ShutdownPromise
>
FinishShutdown
(
)
;
void
UpdatePlaybackPosition
(
int64_t
aTime
)
;
bool
CanPlayThrough
(
)
;
MediaStatistics
GetStatistics
(
)
;
bool
HasAudio
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mInfo
.
HasAudio
(
)
;
}
bool
HasVideo
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mInfo
.
HasVideo
(
)
;
}
bool
HaveNextFrameData
(
)
;
TaskQueue
*
OwnerThread
(
)
const
{
return
mTaskQueue
;
}
void
ScheduleStateMachine
(
)
;
void
ScheduleStateMachineIn
(
int64_t
aMicroseconds
)
;
bool
HaveEnoughDecodedAudio
(
)
;
bool
HaveEnoughDecodedVideo
(
)
;
bool
IsShutdown
(
)
const
;
bool
IsPlaying
(
)
const
;
void
OnAudioDecoded
(
MediaData
*
aAudio
)
;
void
OnVideoDecoded
(
MediaData
*
aVideo
TimeStamp
aDecodeStartTime
)
;
void
OnNotDecoded
(
MediaData
:
:
Type
aType
const
MediaResult
&
aError
)
;
void
Reset
(
TrackSet
aTracks
=
TrackSet
(
TrackInfo
:
:
kAudioTrack
TrackInfo
:
:
kVideoTrack
)
)
;
protected
:
virtual
~
MediaDecoderStateMachine
(
)
;
void
SetState
(
State
aState
)
;
void
BufferedRangeUpdated
(
)
;
void
ReaderSuspendedChanged
(
)
;
void
Push
(
MediaData
*
aSample
MediaData
:
:
Type
aSampleType
)
;
void
OnAudioPopped
(
const
RefPtr
<
MediaData
>
&
aSample
)
;
void
OnVideoPopped
(
const
RefPtr
<
MediaData
>
&
aSample
)
;
void
AudioAudibleChanged
(
bool
aAudible
)
;
void
VolumeChanged
(
)
;
void
SetPlaybackRate
(
double
aPlaybackRate
)
;
void
PreservesPitchChanged
(
)
;
MediaQueue
<
MediaData
>
&
AudioQueue
(
)
{
return
mAudioQueue
;
}
MediaQueue
<
MediaData
>
&
VideoQueue
(
)
{
return
mVideoQueue
;
}
bool
NeedToDecodeAudio
(
)
;
bool
NeedToDecodeVideo
(
)
;
bool
HasLowDecodedData
(
)
;
bool
HasLowDecodedAudio
(
)
;
bool
HasLowDecodedVideo
(
)
;
bool
OutOfDecodedAudio
(
)
;
bool
OutOfDecodedVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
IsVideoDecoding
(
)
&
&
VideoQueue
(
)
.
GetSize
(
)
<
=
1
;
}
bool
HasLowBufferedData
(
)
;
bool
HasLowBufferedData
(
int64_t
aUsecs
)
;
bool
HasFutureAudio
(
)
;
void
UpdateNextFrameStatus
(
)
;
int64_t
GetClock
(
TimeStamp
*
aTimeStamp
=
nullptr
)
const
;
void
SetStartTime
(
int64_t
aStartTimeUsecs
)
;
void
UpdatePlaybackPositionInternal
(
int64_t
aTime
)
;
void
UpdatePlaybackPositionPeriodically
(
)
;
media
:
:
MediaSink
*
CreateAudioSink
(
)
;
already_AddRefed
<
media
:
:
MediaSink
>
CreateMediaSink
(
bool
aAudioCaptured
)
;
void
StopMediaSink
(
)
;
void
StartMediaSink
(
)
;
void
PlayStateChanged
(
)
;
void
VisibilityChanged
(
)
;
void
StopPlayback
(
)
;
void
MaybeStartPlayback
(
)
;
void
MaybeStartBuffering
(
)
;
void
DecodeError
(
const
MediaResult
&
aError
)
;
void
EnqueueLoadedMetadataEvent
(
)
;
void
EnqueueFirstFrameLoadedEvent
(
)
;
void
InitiateSeek
(
SeekJob
aSeekJob
)
;
void
DispatchAudioDecodeTaskIfNeeded
(
)
;
void
DispatchVideoDecodeTaskIfNeeded
(
)
;
void
EnsureAudioDecodeTaskQueued
(
)
;
void
EnsureVideoDecodeTaskQueued
(
)
;
void
RequestAudioData
(
)
;
void
RequestVideoData
(
)
;
void
DispatchDecodeTasksIfNeeded
(
)
;
int64_t
GetMediaTime
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mCurrentPosition
;
}
int64_t
GetDecodedAudioDuration
(
)
;
void
FinishDecodeFirstFrame
(
)
;
void
SeekCompleted
(
)
;
bool
CheckIfDecodeComplete
(
)
;
void
RunStateMachine
(
)
;
bool
IsStateMachineScheduled
(
)
const
;
bool
IsAudioDecoding
(
)
;
bool
IsVideoDecoding
(
)
;
private
:
void
OnMediaSinkAudioComplete
(
)
;
void
OnMediaSinkVideoComplete
(
)
;
void
OnMediaSinkAudioError
(
nsresult
aResult
)
;
void
OnMediaSinkVideoError
(
)
;
bool
NeedToSkipToNextKeyframe
(
)
;
void
*
const
mDecoderID
;
const
RefPtr
<
FrameStatistics
>
mFrameStats
;
const
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
const
dom
:
:
AudioChannel
mAudioChannel
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
WatchManager
<
MediaDecoderStateMachine
>
mWatchManager
;
bool
mDispatchedStateMachine
;
DelayedScheduler
mDelayedScheduler
;
MediaQueue
<
MediaData
>
mAudioQueue
;
MediaQueue
<
MediaData
>
mVideoQueue
;
Watchable
<
State
>
mState
;
UniquePtr
<
StateObject
>
mStateObj
;
media
:
:
TimeUnit
Duration
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mDuration
.
Ref
(
)
.
ref
(
)
;
}
void
RecomputeDuration
(
)
;
FrameID
mCurrentFrameID
;
Watchable
<
media
:
:
TimeUnit
>
mObservedDuration
;
bool
IsLogicallyPlaying
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mPlayState
=
=
MediaDecoder
:
:
PLAY_STATE_PLAYING
|
|
mNextPlayState
=
=
MediaDecoder
:
:
PLAY_STATE_PLAYING
;
}
SeekJob
mQueuedSeek
;
SeekJob
mCurrentSeek
;
RefPtr
<
SeekTask
>
mSeekTask
;
void
DiscardSeekTaskIfExist
(
)
;
int64_t
mFragmentEndTime
;
RefPtr
<
media
:
:
MediaSink
>
mMediaSink
;
const
RefPtr
<
MediaDecoderReaderWrapper
>
mReader
;
int64_t
AudioEndTime
(
)
const
;
int64_t
VideoEndTime
(
)
const
;
int64_t
mDecodedAudioEndTime
;
int64_t
mDecodedVideoEndTime
;
double
mPlaybackRate
;
uint32_t
mBufferingWait
;
int64_t
mLowDataThresholdUsecs
;
uint32_t
GetAmpleVideoFrames
(
)
const
;
int64_t
mLowAudioThresholdUsecs
;
int64_t
mAmpleAudioThresholdUsecs
;
uint32_t
AudioPrerollUsecs
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mAmpleAudioThresholdUsecs
/
2
;
}
uint32_t
VideoPrerollFrames
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
GetAmpleVideoFrames
(
)
/
2
;
}
bool
DonePrerollingAudio
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
!
IsAudioDecoding
(
)
|
|
GetDecodedAudioDuration
(
)
>
=
AudioPrerollUsecs
(
)
*
mPlaybackRate
;
}
bool
DonePrerollingVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
!
IsVideoDecoding
(
)
|
|
static_cast
<
uint32_t
>
(
VideoQueue
(
)
.
GetSize
(
)
)
>
=
VideoPrerollFrames
(
)
*
mPlaybackRate
+
1
;
}
void
MaybeStopPrerolling
(
)
;
bool
mIsPrerolling
=
false
;
MediaEventListener
mAudioCallback
;
MediaEventListener
mVideoCallback
;
MediaEventListener
mAudioWaitCallback
;
MediaEventListener
mVideoWaitCallback
;
const
char
*
AudioRequestStatus
(
)
const
;
const
char
*
VideoRequestStatus
(
)
const
;
void
OnSuspendTimerResolved
(
)
;
void
OnSuspendTimerRejected
(
)
;
bool
mAudioCaptured
;
Watchable
<
bool
>
mAudioCompleted
;
Watchable
<
bool
>
mVideoCompleted
;
bool
mNotifyMetadataBeforeFirstFrame
;
bool
mMinimizePreroll
;
bool
mDecodeThreadWaiting
;
MediaInfo
mInfo
;
nsAutoPtr
<
MetadataTags
>
mMetadataTags
;
mozilla
:
:
MediaMetadataManager
mMetadataManager
;
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
BufferedUpdatePromise
>
mBufferedUpdateRequest
;
bool
mSentLoadedMetadataEvent
;
bool
mSentFirstFrameLoadedEvent
;
bool
mVideoDecodeSuspended
;
DelayedScheduler
mVideoDecodeSuspendTimer
;
const
RefPtr
<
OutputStreamManager
>
mOutputStreamManager
;
RefPtr
<
MediaResource
>
mResource
;
MozPromiseRequestHolder
<
GenericPromise
>
mMediaSinkAudioPromise
;
MozPromiseRequestHolder
<
GenericPromise
>
mMediaSinkVideoPromise
;
MediaEventListener
mAudioQueueListener
;
MediaEventListener
mVideoQueueListener
;
MediaEventListener
mAudibleListener
;
MediaEventProducerExc
<
nsAutoPtr
<
MediaInfo
>
nsAutoPtr
<
MetadataTags
>
MediaDecoderEventVisibility
>
mMetadataLoadedEvent
;
MediaEventProducerExc
<
nsAutoPtr
<
MediaInfo
>
MediaDecoderEventVisibility
>
mFirstFrameLoadedEvent
;
MediaEventProducer
<
MediaEventType
>
mOnPlaybackEvent
;
MediaEventProducer
<
MediaResult
>
mOnPlaybackErrorEvent
;
MediaEventProducer
<
DecoderDoctorEvent
>
mOnDecoderDoctorEvent
;
bool
mAudioOffloading
;
void
OnCDMProxyReady
(
RefPtr
<
CDMProxy
>
aProxy
)
;
void
OnCDMProxyNotReady
(
)
;
RefPtr
<
CDMProxy
>
mCDMProxy
;
MozPromiseRequestHolder
<
MediaDecoder
:
:
CDMProxyPromise
>
mCDMProxyPromise
;
private
:
Mirror
<
media
:
:
TimeIntervals
>
mBuffered
;
Mirror
<
bool
>
mIsReaderSuspended
;
Mirror
<
media
:
:
NullableTimeUnit
>
mEstimatedDuration
;
Mirror
<
Maybe
<
double
>
>
mExplicitDuration
;
Mirror
<
MediaDecoder
:
:
PlayState
>
mPlayState
;
Mirror
<
MediaDecoder
:
:
PlayState
>
mNextPlayState
;
Mirror
<
double
>
mVolume
;
Mirror
<
bool
>
mPreservesPitch
;
Mirror
<
bool
>
mSameOriginMedia
;
Mirror
<
PrincipalHandle
>
mMediaPrincipalHandle
;
Mirror
<
double
>
mPlaybackBytesPerSecond
;
Mirror
<
bool
>
mPlaybackRateReliable
;
Mirror
<
int64_t
>
mDecoderPosition
;
Mirror
<
bool
>
mMediaSeekable
;
Mirror
<
bool
>
mMediaSeekableOnlyInBufferedRanges
;
Mirror
<
bool
>
mIsVisible
;
Canonical
<
media
:
:
NullableTimeUnit
>
mDuration
;
Canonical
<
bool
>
mIsShutdown
;
Canonical
<
NextFrameStatus
>
mNextFrameStatus
;
Canonical
<
int64_t
>
mCurrentPosition
;
Canonical
<
int64_t
>
mPlaybackOffset
;
Canonical
<
bool
>
mIsAudioDataAudible
;
public
:
AbstractCanonical
<
media
:
:
TimeIntervals
>
*
CanonicalBuffered
(
)
const
;
AbstractCanonical
<
media
:
:
NullableTimeUnit
>
*
CanonicalDuration
(
)
{
return
&
mDuration
;
}
AbstractCanonical
<
bool
>
*
CanonicalIsShutdown
(
)
{
return
&
mIsShutdown
;
}
AbstractCanonical
<
NextFrameStatus
>
*
CanonicalNextFrameStatus
(
)
{
return
&
mNextFrameStatus
;
}
AbstractCanonical
<
int64_t
>
*
CanonicalCurrentPosition
(
)
{
return
&
mCurrentPosition
;
}
AbstractCanonical
<
int64_t
>
*
CanonicalPlaybackOffset
(
)
{
return
&
mPlaybackOffset
;
}
AbstractCanonical
<
bool
>
*
CanonicalIsAudioDataAudible
(
)
{
return
&
mIsAudioDataAudible
;
}
}
;
}
#
endif
