#
if
!
defined
(
MediaDecoderStateMachine_h__
)
#
define
MediaDecoderStateMachine_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
MediaDecoder
.
h
"
#
include
"
MediaDecoderReader
.
h
"
#
include
"
MediaDecoderOwner
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaStatistics
.
h
"
#
include
"
MediaTimer
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
SeekTask
.
h
"
namespace
mozilla
{
namespace
media
{
class
MediaSink
;
}
class
AudioSegment
;
class
DecodedStream
;
class
MediaDecoderReaderWrapper
;
class
OutputStreamManager
;
class
TaskQueue
;
extern
LazyLogModule
gMediaDecoderLog
;
extern
LazyLogModule
gMediaSampleLog
;
enum
class
MediaEventType
:
int8_t
{
PlaybackStarted
PlaybackStopped
PlaybackEnded
DecodeError
Invalidate
}
;
class
MediaDecoderStateMachine
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDecoderStateMachine
)
public
:
typedef
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameStatus
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
:
:
FrameID
FrameID
;
MediaDecoderStateMachine
(
MediaDecoder
*
aDecoder
MediaDecoderReader
*
aReader
bool
aRealTime
=
false
)
;
nsresult
Init
(
MediaDecoder
*
aDecoder
)
;
enum
State
{
DECODER_STATE_DECODING_METADATA
DECODER_STATE_WAIT_FOR_CDM
DECODER_STATE_DORMANT
DECODER_STATE_DECODING
DECODER_STATE_SEEKING
DECODER_STATE_BUFFERING
DECODER_STATE_COMPLETED
DECODER_STATE_SHUTDOWN
DECODER_STATE_ERROR
}
;
void
DumpDebugInfo
(
)
;
void
AddOutputStream
(
ProcessedMediaStream
*
aStream
bool
aFinishWhenEnded
)
;
void
RemoveOutputStream
(
MediaStream
*
aStream
)
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
InvokeSeek
(
SeekTarget
aTarget
)
;
void
DispatchSetDormant
(
bool
aDormant
)
;
RefPtr
<
ShutdownPromise
>
BeginShutdown
(
)
;
void
DispatchMinimizePrerollUntilPlaybackStarts
(
)
{
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
self
]
(
)
-
>
void
{
MOZ_ASSERT
(
self
-
>
OnTaskQueue
(
)
)
;
self
-
>
mMinimizePreroll
=
true
;
MOZ_DIAGNOSTIC_ASSERT
(
self
-
>
mPlayState
=
=
MediaDecoder
:
:
PLAY_STATE_LOADING
)
;
}
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
DispatchSetFragmentEndTime
(
int64_t
aEndTime
)
{
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
self
aEndTime
]
(
)
{
self
-
>
mFragmentEndTime
=
aEndTime
;
}
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
DispatchAudioOffloading
(
bool
aAudioOffloading
)
{
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
=
]
(
)
{
if
(
self
-
>
mAudioOffloading
!
=
aAudioOffloading
)
{
self
-
>
mAudioOffloading
=
aAudioOffloading
;
self
-
>
ScheduleStateMachine
(
)
;
}
}
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
BreakCycles
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mResource
=
nullptr
;
}
TimedMetadataEventSource
&
TimedMetadataEvent
(
)
{
return
mMetadataManager
.
TimedMetadataEvent
(
)
;
}
MediaEventSource
<
void
>
&
OnMediaNotSeekable
(
)
const
;
MediaEventSourceExc
<
nsAutoPtr
<
MediaInfo
>
nsAutoPtr
<
MetadataTags
>
MediaDecoderEventVisibility
>
&
MetadataLoadedEvent
(
)
{
return
mMetadataLoadedEvent
;
}
MediaEventSourceExc
<
nsAutoPtr
<
MediaInfo
>
MediaDecoderEventVisibility
>
&
FirstFrameLoadedEvent
(
)
{
return
mFirstFrameLoadedEvent
;
}
MediaEventSource
<
MediaEventType
>
&
OnPlaybackEvent
(
)
{
return
mOnPlaybackEvent
;
}
MediaEventSource
<
MediaDecoderEventVisibility
>
&
OnSeekingStart
(
)
{
return
mOnSeekingStart
;
}
bool
IsRealTime
(
)
const
{
return
mRealTime
;
}
size_t
SizeOfVideoQueue
(
)
const
;
size_t
SizeOfAudioQueue
(
)
const
;
private
:
bool
OnTaskQueue
(
)
const
;
void
InitializationTask
(
MediaDecoder
*
aDecoder
)
;
void
SetDormant
(
bool
aDormant
)
;
void
SetAudioCaptured
(
bool
aCaptured
)
;
void
ReadMetadata
(
)
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
Seek
(
SeekTarget
aTarget
)
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
;
RefPtr
<
ShutdownPromise
>
FinishShutdown
(
)
;
void
UpdatePlaybackPosition
(
int64_t
aTime
)
;
void
StartBuffering
(
)
;
bool
CanPlayThrough
(
)
;
MediaStatistics
GetStatistics
(
)
;
bool
HasAudio
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mInfo
.
HasAudio
(
)
;
}
bool
HasVideo
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mInfo
.
HasVideo
(
)
;
}
bool
HaveNextFrameData
(
)
;
bool
IsBuffering
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mState
=
=
DECODER_STATE_BUFFERING
;
}
bool
IsSeeking
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mState
=
=
DECODER_STATE_SEEKING
;
}
TaskQueue
*
OwnerThread
(
)
const
{
return
mTaskQueue
;
}
void
ScheduleStateMachine
(
)
;
void
ScheduleStateMachineIn
(
int64_t
aMicroseconds
)
;
void
OnDelayedSchedule
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mDelayedScheduler
.
CompleteRequest
(
)
;
ScheduleStateMachine
(
)
;
}
void
NotReached
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
)
;
}
void
DiscardStreamData
(
)
;
bool
HaveEnoughDecodedAudio
(
)
;
bool
HaveEnoughDecodedVideo
(
)
;
bool
IsShutdown
(
)
;
bool
IsPlaying
(
)
const
;
void
OnAudioDecoded
(
MediaData
*
aAudioSample
)
;
void
OnVideoDecoded
(
MediaData
*
aVideoSample
TimeStamp
aDecodeStartTime
)
;
void
OnNotDecoded
(
MediaData
:
:
Type
aType
MediaDecoderReader
:
:
NotDecodedReason
aReason
)
;
void
OnAudioNotDecoded
(
MediaDecoderReader
:
:
NotDecodedReason
aReason
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
OnNotDecoded
(
MediaData
:
:
AUDIO_DATA
aReason
)
;
}
void
OnVideoNotDecoded
(
MediaDecoderReader
:
:
NotDecodedReason
aReason
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
OnNotDecoded
(
MediaData
:
:
VIDEO_DATA
aReason
)
;
}
void
Reset
(
)
;
protected
:
virtual
~
MediaDecoderStateMachine
(
)
;
void
SetState
(
State
aState
)
;
void
BufferedRangeUpdated
(
)
;
void
Push
(
MediaData
*
aSample
MediaData
:
:
Type
aSampleType
)
;
void
OnAudioPopped
(
const
RefPtr
<
MediaData
>
&
aSample
)
;
void
OnVideoPopped
(
const
RefPtr
<
MediaData
>
&
aSample
)
;
void
CheckIsAudible
(
const
MediaData
*
aSample
)
;
void
VolumeChanged
(
)
;
void
LogicalPlaybackRateChanged
(
)
;
void
PreservesPitchChanged
(
)
;
MediaQueue
<
MediaData
>
&
AudioQueue
(
)
{
return
mAudioQueue
;
}
MediaQueue
<
MediaData
>
&
VideoQueue
(
)
{
return
mVideoQueue
;
}
bool
NeedToDecodeAudio
(
)
;
bool
NeedToDecodeVideo
(
)
;
bool
HasLowDecodedData
(
int64_t
aAudioUsecs
)
;
bool
OutOfDecodedAudio
(
)
;
bool
OutOfDecodedVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
IsVideoDecoding
(
)
&
&
!
VideoQueue
(
)
.
IsFinished
(
)
&
&
VideoQueue
(
)
.
GetSize
(
)
<
=
1
;
}
bool
HasLowUndecodedData
(
)
;
bool
HasLowUndecodedData
(
int64_t
aUsecs
)
;
bool
HasFutureAudio
(
)
;
bool
JustExitedQuickBuffering
(
)
;
void
UpdateNextFrameStatus
(
)
;
int64_t
GetClock
(
TimeStamp
*
aTimeStamp
=
nullptr
)
const
;
void
SetStartTime
(
int64_t
aStartTimeUsecs
)
;
void
UpdatePlaybackPositionInternal
(
int64_t
aTime
)
;
void
UpdatePlaybackPositionPeriodically
(
)
;
media
:
:
MediaSink
*
CreateAudioSink
(
)
;
already_AddRefed
<
media
:
:
MediaSink
>
CreateMediaSink
(
bool
aAudioCaptured
)
;
void
StopMediaSink
(
)
;
void
StartMediaSink
(
)
;
void
PlayStateChanged
(
)
;
void
StopPlayback
(
)
;
void
MaybeStartPlayback
(
)
;
void
MaybeStartBuffering
(
)
;
void
StartDecoding
(
)
;
void
DecodeError
(
)
;
nsresult
EnqueueDecodeMetadataTask
(
)
;
void
EnqueueLoadedMetadataEvent
(
)
;
void
EnqueueFirstFrameLoadedEvent
(
)
;
void
InitiateSeek
(
SeekJob
aSeekJob
)
;
nsresult
DispatchAudioDecodeTaskIfNeeded
(
)
;
nsresult
EnsureAudioDecodeTaskQueued
(
)
;
void
RequestAudioData
(
)
;
nsresult
DispatchVideoDecodeTaskIfNeeded
(
)
;
nsresult
EnsureVideoDecodeTaskQueued
(
)
;
void
RequestVideoData
(
)
;
void
DispatchDecodeTasksIfNeeded
(
)
;
int64_t
GetMediaTime
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mCurrentPosition
;
}
int64_t
GetDecodedAudioDuration
(
)
;
void
OnMetadataRead
(
MetadataHolder
*
aMetadata
)
;
void
OnMetadataNotRead
(
ReadMetadataFailureReason
aReason
)
;
bool
MaybeFinishDecodeFirstFrame
(
)
;
bool
IsDecodingFirstFrame
(
)
;
void
FinishDecodeFirstFrame
(
)
;
void
SeekCompleted
(
)
;
void
CheckIfDecodeComplete
(
)
;
nsresult
RunStateMachine
(
)
;
bool
IsStateMachineScheduled
(
)
const
;
bool
IsPausedAndDecoderWaiting
(
)
;
bool
IsAudioDecoding
(
)
;
bool
IsVideoDecoding
(
)
;
private
:
void
OnMediaSinkAudioComplete
(
)
;
void
OnMediaSinkVideoComplete
(
)
;
void
OnMediaSinkAudioError
(
)
;
void
OnMediaSinkVideoError
(
)
;
bool
NeedToSkipToNextKeyframe
(
)
;
void
*
const
mDecoderID
;
const
RefPtr
<
FrameStatistics
>
mFrameStats
;
const
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
const
dom
:
:
AudioChannel
mAudioChannel
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
WatchManager
<
MediaDecoderStateMachine
>
mWatchManager
;
const
bool
mRealTime
;
bool
mDispatchedStateMachine
;
DelayedScheduler
mDelayedScheduler
;
MediaQueue
<
MediaData
>
mAudioQueue
;
MediaQueue
<
MediaData
>
mVideoQueue
;
Watchable
<
State
>
mState
;
TimeStamp
mBufferingStart
;
media
:
:
TimeUnit
Duration
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mDuration
.
Ref
(
)
.
ref
(
)
;
}
void
RecomputeDuration
(
)
;
FrameID
mCurrentFrameID
;
Watchable
<
media
:
:
TimeUnit
>
mObservedDuration
;
bool
IsLogicallyPlaying
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mPlayState
=
=
MediaDecoder
:
:
PLAY_STATE_PLAYING
|
|
mNextPlayState
=
=
MediaDecoder
:
:
PLAY_STATE_PLAYING
;
}
SeekJob
mQueuedSeek
;
RefPtr
<
SeekTask
>
mSeekTask
;
MozPromiseRequestHolder
<
SeekTask
:
:
SeekTaskPromise
>
mSeekTaskRequest
;
void
OnSeekTaskResolved
(
SeekTaskResolveValue
aValue
)
;
void
OnSeekTaskRejected
(
SeekTaskRejectValue
aValue
)
;
int64_t
mFragmentEndTime
;
RefPtr
<
media
:
:
MediaSink
>
mMediaSink
;
const
RefPtr
<
MediaDecoderReaderWrapper
>
mReader
;
int64_t
AudioEndTime
(
)
const
;
int64_t
VideoEndTime
(
)
const
;
int64_t
mDecodedAudioEndTime
;
int64_t
mDecodedVideoEndTime
;
double
mPlaybackRate
;
TimeStamp
mDecodeStartTime
;
uint32_t
mBufferingWait
;
int64_t
mLowDataThresholdUsecs
;
uint32_t
GetAmpleVideoFrames
(
)
const
;
int64_t
mLowAudioThresholdUsecs
;
int64_t
mAmpleAudioThresholdUsecs
;
int64_t
mQuickBufferingLowDataThresholdUsecs
;
uint32_t
AudioPrerollUsecs
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
IsRealTime
(
)
?
0
:
mAmpleAudioThresholdUsecs
/
2
;
}
uint32_t
VideoPrerollFrames
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
IsRealTime
(
)
?
0
:
GetAmpleVideoFrames
(
)
/
2
;
}
bool
DonePrerollingAudio
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
!
IsAudioDecoding
(
)
|
|
GetDecodedAudioDuration
(
)
>
=
AudioPrerollUsecs
(
)
*
mPlaybackRate
;
}
bool
DonePrerollingVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
!
IsVideoDecoding
(
)
|
|
static_cast
<
uint32_t
>
(
VideoQueue
(
)
.
GetSize
(
)
)
>
=
VideoPrerollFrames
(
)
*
mPlaybackRate
+
1
;
}
void
StopPrerollingAudio
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mIsAudioPrerolling
)
{
mIsAudioPrerolling
=
false
;
ScheduleStateMachine
(
)
;
}
}
void
StopPrerollingVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mIsVideoPrerolling
)
{
mIsVideoPrerolling
=
false
;
ScheduleStateMachine
(
)
;
}
}
bool
mIsAudioPrerolling
;
bool
mIsVideoPrerolling
;
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
MediaDataPromise
>
mAudioDataRequest
;
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
WaitForDataPromise
>
mAudioWaitRequest
;
const
char
*
AudioRequestStatus
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mAudioDataRequest
.
Exists
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mAudioWaitRequest
.
Exists
(
)
)
;
return
"
pending
"
;
}
else
if
(
mAudioWaitRequest
.
Exists
(
)
)
{
return
"
waiting
"
;
}
return
"
idle
"
;
}
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
WaitForDataPromise
>
mVideoWaitRequest
;
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
MediaDataPromise
>
mVideoDataRequest
;
const
char
*
VideoRequestStatus
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mVideoDataRequest
.
Exists
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mVideoWaitRequest
.
Exists
(
)
)
;
return
"
pending
"
;
}
else
if
(
mVideoWaitRequest
.
Exists
(
)
)
{
return
"
waiting
"
;
}
return
"
idle
"
;
}
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
WaitForDataPromise
>
&
WaitRequestRef
(
MediaData
:
:
Type
aType
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
aType
=
=
MediaData
:
:
AUDIO_DATA
?
mAudioWaitRequest
:
mVideoWaitRequest
;
}
bool
mAudioCaptured
;
Watchable
<
bool
>
mAudioCompleted
;
Watchable
<
bool
>
mVideoCompleted
;
Maybe
<
bool
>
mPendingDormant
;
bool
mNotifyMetadataBeforeFirstFrame
;
bool
mDispatchedEventToDecode
;
bool
mQuickBuffering
;
bool
mMinimizePreroll
;
bool
mDecodeThreadWaiting
;
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
MetadataPromise
>
mMetadataRequest
;
MediaInfo
mInfo
;
nsAutoPtr
<
MetadataTags
>
mMetadataTags
;
mozilla
:
:
MediaMetadataManager
mMetadataManager
;
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
BufferedUpdatePromise
>
mBufferedUpdateRequest
;
bool
mDecodingFirstFrame
;
bool
mSentLoadedMetadataEvent
;
bool
mSentFirstFrameLoadedEvent
;
bool
mSentPlaybackEndedEvent
;
const
RefPtr
<
OutputStreamManager
>
mOutputStreamManager
;
RefPtr
<
MediaResource
>
mResource
;
MozPromiseRequestHolder
<
GenericPromise
>
mMediaSinkAudioPromise
;
MozPromiseRequestHolder
<
GenericPromise
>
mMediaSinkVideoPromise
;
MediaEventListener
mAudioQueueListener
;
MediaEventListener
mVideoQueueListener
;
MediaEventProducerExc
<
nsAutoPtr
<
MediaInfo
>
nsAutoPtr
<
MetadataTags
>
MediaDecoderEventVisibility
>
mMetadataLoadedEvent
;
MediaEventProducerExc
<
nsAutoPtr
<
MediaInfo
>
MediaDecoderEventVisibility
>
mFirstFrameLoadedEvent
;
MediaEventProducer
<
MediaEventType
>
mOnPlaybackEvent
;
MediaEventProducer
<
MediaDecoderEventVisibility
>
mOnSeekingStart
;
bool
mAudioOffloading
;
uint32_t
mSilentDataDuration
;
#
ifdef
MOZ_EME
void
OnCDMProxyReady
(
RefPtr
<
CDMProxy
>
aProxy
)
;
void
OnCDMProxyNotReady
(
)
;
RefPtr
<
CDMProxy
>
mCDMProxy
;
MozPromiseRequestHolder
<
MediaDecoder
:
:
CDMProxyPromise
>
mCDMProxyPromise
;
#
endif
private
:
Mirror
<
media
:
:
TimeIntervals
>
mBuffered
;
Mirror
<
media
:
:
NullableTimeUnit
>
mEstimatedDuration
;
Mirror
<
Maybe
<
double
>
>
mExplicitDuration
;
Mirror
<
MediaDecoder
:
:
PlayState
>
mPlayState
;
Mirror
<
MediaDecoder
:
:
PlayState
>
mNextPlayState
;
Mirror
<
double
>
mVolume
;
Mirror
<
double
>
mLogicalPlaybackRate
;
Mirror
<
bool
>
mPreservesPitch
;
Mirror
<
bool
>
mSameOriginMedia
;
Mirror
<
PrincipalHandle
>
mMediaPrincipalHandle
;
Mirror
<
double
>
mPlaybackBytesPerSecond
;
Mirror
<
bool
>
mPlaybackRateReliable
;
Mirror
<
int64_t
>
mDecoderPosition
;
Mirror
<
bool
>
mMediaSeekable
;
Mirror
<
bool
>
mMediaSeekableOnlyInBufferedRanges
;
Canonical
<
media
:
:
NullableTimeUnit
>
mDuration
;
Canonical
<
bool
>
mIsShutdown
;
Canonical
<
NextFrameStatus
>
mNextFrameStatus
;
Canonical
<
int64_t
>
mCurrentPosition
;
Canonical
<
int64_t
>
mPlaybackOffset
;
Canonical
<
bool
>
mIsAudioDataAudible
;
public
:
AbstractCanonical
<
media
:
:
TimeIntervals
>
*
CanonicalBuffered
(
)
const
;
AbstractCanonical
<
media
:
:
NullableTimeUnit
>
*
CanonicalDuration
(
)
{
return
&
mDuration
;
}
AbstractCanonical
<
bool
>
*
CanonicalIsShutdown
(
)
{
return
&
mIsShutdown
;
}
AbstractCanonical
<
NextFrameStatus
>
*
CanonicalNextFrameStatus
(
)
{
return
&
mNextFrameStatus
;
}
AbstractCanonical
<
int64_t
>
*
CanonicalCurrentPosition
(
)
{
return
&
mCurrentPosition
;
}
AbstractCanonical
<
int64_t
>
*
CanonicalPlaybackOffset
(
)
{
return
&
mPlaybackOffset
;
}
AbstractCanonical
<
bool
>
*
CanonicalIsAudioDataAudible
(
)
{
return
&
mIsAudioDataAudible
;
}
}
;
}
#
endif
