#
if
!
defined
(
MediaDecoderStateMachine_h__
)
#
define
MediaDecoderStateMachine_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
RollingMean
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
MediaDecoder
.
h
"
#
include
"
MediaDecoderReader
.
h
"
#
include
"
MediaDecoderOwner
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaStatistics
.
h
"
#
include
"
MediaTimer
.
h
"
#
include
"
ImageContainer
.
h
"
namespace
mozilla
{
namespace
media
{
class
MediaSink
;
}
class
AudioSegment
;
class
DecodedStream
;
class
OutputStreamManager
;
class
TaskQueue
;
extern
LazyLogModule
gMediaDecoderLog
;
extern
LazyLogModule
gMediaSampleLog
;
enum
class
MediaEventType
:
int8_t
{
PlaybackStarted
PlaybackStopped
PlaybackEnded
DecodeError
Invalidate
}
;
class
MediaDecoderStateMachine
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDecoderStateMachine
)
public
:
typedef
MediaDecoderReader
:
:
AudioDataPromise
AudioDataPromise
;
typedef
MediaDecoderReader
:
:
VideoDataPromise
VideoDataPromise
;
typedef
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameStatus
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
:
:
FrameID
FrameID
;
MediaDecoderStateMachine
(
MediaDecoder
*
aDecoder
MediaDecoderReader
*
aReader
bool
aRealTime
=
false
)
;
nsresult
Init
(
)
;
enum
State
{
DECODER_STATE_DECODING_NONE
DECODER_STATE_DECODING_METADATA
DECODER_STATE_WAIT_FOR_CDM
DECODER_STATE_DORMANT
DECODER_STATE_DECODING
DECODER_STATE_SEEKING
DECODER_STATE_BUFFERING
DECODER_STATE_COMPLETED
DECODER_STATE_SHUTDOWN
DECODER_STATE_ERROR
}
;
void
AddOutputStream
(
ProcessedMediaStream
*
aStream
bool
aFinishWhenEnded
)
;
void
RemoveOutputStream
(
MediaStream
*
aStream
)
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
InvokeSeek
(
SeekTarget
aTarget
)
;
void
DispatchSetDormant
(
bool
aDormant
)
;
RefPtr
<
ShutdownPromise
>
BeginShutdown
(
)
;
void
DispatchStartBuffering
(
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableMethod
(
this
&
MediaDecoderStateMachine
:
:
StartBuffering
)
;
OwnerThread
(
)
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
}
void
DispatchMinimizePrerollUntilPlaybackStarts
(
)
{
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
self
]
(
)
-
>
void
{
MOZ_ASSERT
(
self
-
>
OnTaskQueue
(
)
)
;
self
-
>
mMinimizePreroll
=
true
;
MOZ_DIAGNOSTIC_ASSERT
(
self
-
>
mPlayState
=
=
MediaDecoder
:
:
PLAY_STATE_LOADING
)
;
}
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
DispatchSetFragmentEndTime
(
int64_t
aEndTime
)
{
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
self
aEndTime
]
(
)
{
self
-
>
mFragmentEndTime
=
aEndTime
;
}
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
DispatchAudioOffloading
(
bool
aAudioOffloading
)
{
RefPtr
<
MediaDecoderStateMachine
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
=
]
(
)
{
if
(
self
-
>
mAudioOffloading
!
=
aAudioOffloading
)
{
self
-
>
mAudioOffloading
=
aAudioOffloading
;
self
-
>
ScheduleStateMachine
(
)
;
}
}
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
BreakCycles
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mReader
)
{
mReader
-
>
BreakCycles
(
)
;
}
mResource
=
nullptr
;
}
TimedMetadataEventSource
&
TimedMetadataEvent
(
)
{
return
mMetadataManager
.
TimedMetadataEvent
(
)
;
}
MediaEventSource
<
void
>
&
OnMediaNotSeekable
(
)
{
return
mReader
-
>
OnMediaNotSeekable
(
)
;
}
MediaEventSourceExc
<
nsAutoPtr
<
MediaInfo
>
nsAutoPtr
<
MetadataTags
>
MediaDecoderEventVisibility
>
&
MetadataLoadedEvent
(
)
{
return
mMetadataLoadedEvent
;
}
MediaEventSourceExc
<
nsAutoPtr
<
MediaInfo
>
MediaDecoderEventVisibility
>
&
FirstFrameLoadedEvent
(
)
{
return
mFirstFrameLoadedEvent
;
}
MediaEventSource
<
MediaEventType
>
&
OnPlaybackEvent
(
)
{
return
mOnPlaybackEvent
;
}
MediaEventSource
<
MediaDecoderEventVisibility
>
&
OnSeekingStart
(
)
{
return
mOnSeekingStart
;
}
bool
IsRealTime
(
)
const
{
return
mRealTime
;
}
size_t
SizeOfVideoQueue
(
)
{
if
(
mReader
)
{
return
mReader
-
>
SizeOfVideoQueueInBytes
(
)
;
}
return
0
;
}
size_t
SizeOfAudioQueue
(
)
{
if
(
mReader
)
{
return
mReader
-
>
SizeOfAudioQueueInBytes
(
)
;
}
return
0
;
}
private
:
bool
OnTaskQueue
(
)
const
;
void
InitializationTask
(
MediaDecoder
*
aDecoder
)
;
void
SetDormant
(
bool
aDormant
)
;
void
SetAudioCaptured
(
bool
aCaptured
)
;
RefPtr
<
MediaDecoder
:
:
SeekPromise
>
Seek
(
SeekTarget
aTarget
)
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
;
RefPtr
<
ShutdownPromise
>
FinishShutdown
(
)
;
void
UpdatePlaybackPosition
(
int64_t
aTime
)
;
void
StartBuffering
(
)
;
bool
CanPlayThrough
(
)
;
MediaStatistics
GetStatistics
(
)
;
bool
HasAudio
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mInfo
.
HasAudio
(
)
;
}
bool
HasVideo
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mInfo
.
HasVideo
(
)
;
}
bool
HaveNextFrameData
(
)
;
bool
IsBuffering
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mState
=
=
DECODER_STATE_BUFFERING
;
}
bool
IsSeeking
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mState
=
=
DECODER_STATE_SEEKING
;
}
TaskQueue
*
OwnerThread
(
)
const
{
return
mTaskQueue
;
}
void
ScheduleStateMachine
(
)
;
void
ScheduleStateMachineCrossThread
(
)
{
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableMethod
(
this
&
MediaDecoderStateMachine
:
:
RunStateMachine
)
;
OwnerThread
(
)
-
>
Dispatch
(
task
.
forget
(
)
)
;
}
void
ScheduleStateMachineIn
(
int64_t
aMicroseconds
)
;
void
OnDelayedSchedule
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mDelayedScheduler
.
CompleteRequest
(
)
;
ScheduleStateMachine
(
)
;
}
void
NotReached
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
)
;
}
void
DiscardStreamData
(
)
;
bool
HaveEnoughDecodedAudio
(
int64_t
aAmpleAudioUSecs
)
;
bool
HaveEnoughDecodedVideo
(
)
;
bool
IsShutdown
(
)
;
bool
IsPlaying
(
)
const
;
void
OnAudioDecoded
(
MediaData
*
aAudioSample
)
;
void
OnVideoDecoded
(
MediaData
*
aVideoSample
)
;
void
OnNotDecoded
(
MediaData
:
:
Type
aType
MediaDecoderReader
:
:
NotDecodedReason
aReason
)
;
void
OnAudioNotDecoded
(
MediaDecoderReader
:
:
NotDecodedReason
aReason
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
OnNotDecoded
(
MediaData
:
:
AUDIO_DATA
aReason
)
;
}
void
OnVideoNotDecoded
(
MediaDecoderReader
:
:
NotDecodedReason
aReason
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
OnNotDecoded
(
MediaData
:
:
VIDEO_DATA
aReason
)
;
}
void
Reset
(
)
;
protected
:
virtual
~
MediaDecoderStateMachine
(
)
;
void
SetState
(
State
aState
)
;
void
BufferedRangeUpdated
(
)
;
void
Push
(
MediaData
*
aSample
MediaData
:
:
Type
aSampleType
)
;
void
PushFront
(
MediaData
*
aSample
MediaData
:
:
Type
aSampleType
)
;
void
OnAudioPopped
(
const
RefPtr
<
MediaData
>
&
aSample
)
;
void
OnVideoPopped
(
const
RefPtr
<
MediaData
>
&
aSample
)
;
void
VolumeChanged
(
)
;
void
LogicalPlaybackRateChanged
(
)
;
void
PreservesPitchChanged
(
)
;
MediaQueue
<
MediaData
>
&
AudioQueue
(
)
{
return
mAudioQueue
;
}
MediaQueue
<
MediaData
>
&
VideoQueue
(
)
{
return
mVideoQueue
;
}
bool
NeedToDecodeAudio
(
)
;
bool
NeedToDecodeVideo
(
)
;
bool
HasLowDecodedData
(
int64_t
aAudioUsecs
)
;
bool
OutOfDecodedAudio
(
)
;
bool
OutOfDecodedVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
IsVideoDecoding
(
)
&
&
!
VideoQueue
(
)
.
IsFinished
(
)
&
&
VideoQueue
(
)
.
GetSize
(
)
<
=
1
;
}
bool
HasLowUndecodedData
(
)
;
bool
HasLowUndecodedData
(
int64_t
aUsecs
)
;
bool
HasFutureAudio
(
)
;
bool
JustExitedQuickBuffering
(
)
;
void
UpdateNextFrameStatus
(
)
;
int64_t
GetClock
(
TimeStamp
*
aTimeStamp
=
nullptr
)
const
;
nsresult
DropAudioUpToSeekTarget
(
MediaData
*
aSample
)
;
nsresult
DropVideoUpToSeekTarget
(
MediaData
*
aSample
)
;
void
SetStartTime
(
int64_t
aStartTimeUsecs
)
;
void
UpdatePlaybackPositionInternal
(
int64_t
aTime
)
;
void
CheckFrameValidity
(
VideoData
*
aData
)
;
void
UpdatePlaybackPositionPeriodically
(
)
;
media
:
:
MediaSink
*
CreateAudioSink
(
)
;
already_AddRefed
<
media
:
:
MediaSink
>
CreateMediaSink
(
bool
aAudioCaptured
)
;
void
StopMediaSink
(
)
;
void
StartMediaSink
(
)
;
void
PlayStateChanged
(
)
;
void
LogicallySeekingChanged
(
)
;
void
StopPlayback
(
)
;
void
MaybeStartPlayback
(
)
;
void
MaybeStartBuffering
(
)
;
void
StartDecoding
(
)
;
void
DecodeError
(
)
;
nsresult
EnqueueDecodeMetadataTask
(
)
;
void
EnqueueLoadedMetadataEvent
(
)
;
void
EnqueueFirstFrameLoadedEvent
(
)
;
void
InitiateSeek
(
)
;
nsresult
DispatchAudioDecodeTaskIfNeeded
(
)
;
nsresult
EnsureAudioDecodeTaskQueued
(
)
;
void
RequestAudioData
(
)
;
nsresult
DispatchVideoDecodeTaskIfNeeded
(
)
;
nsresult
EnsureVideoDecodeTaskQueued
(
)
;
void
RequestVideoData
(
)
;
void
DispatchDecodeTasksIfNeeded
(
)
;
int64_t
GetMediaTime
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mCurrentPosition
;
}
int64_t
GetDecodedAudioDuration
(
)
;
void
OnMetadataRead
(
MetadataHolder
*
aMetadata
)
;
void
OnMetadataNotRead
(
ReadMetadataFailureReason
aReason
)
;
bool
MaybeFinishDecodeFirstFrame
(
)
;
bool
IsDecodingFirstFrame
(
)
;
void
FinishDecodeFirstFrame
(
)
;
void
DecodeSeek
(
)
;
void
CheckIfSeekComplete
(
)
;
bool
IsAudioSeekComplete
(
)
;
bool
IsVideoSeekComplete
(
)
;
void
SeekCompleted
(
)
;
void
CheckIfDecodeComplete
(
)
;
nsresult
RunStateMachine
(
)
;
bool
IsStateMachineScheduled
(
)
const
;
bool
IsPausedAndDecoderWaiting
(
)
;
bool
IsAudioDecoding
(
)
;
bool
IsVideoDecoding
(
)
;
private
:
void
OnMediaSinkAudioComplete
(
)
;
void
OnMediaSinkVideoComplete
(
)
;
void
OnMediaSinkAudioError
(
)
;
void
OnMediaSinkVideoError
(
)
;
bool
NeedToSkipToNextKeyframe
(
)
;
void
AdjustAudioThresholds
(
)
;
void
*
const
mDecoderID
;
const
RefPtr
<
FrameStatistics
>
mFrameStats
;
const
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
const
dom
:
:
AudioChannel
mAudioChannel
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
WatchManager
<
MediaDecoderStateMachine
>
mWatchManager
;
const
bool
mRealTime
;
bool
mDispatchedStateMachine
;
DelayedScheduler
mDelayedScheduler
;
class
StartTimeRendezvous
{
public
:
typedef
MediaDecoderReader
:
:
AudioDataPromise
AudioDataPromise
;
typedef
MediaDecoderReader
:
:
VideoDataPromise
VideoDataPromise
;
typedef
MozPromise
<
bool
bool
false
>
HaveStartTimePromise
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
StartTimeRendezvous
)
;
StartTimeRendezvous
(
AbstractThread
*
aOwnerThread
bool
aHasAudio
bool
aHasVideo
bool
aForceZeroStartTime
)
:
mOwnerThread
(
aOwnerThread
)
{
if
(
aForceZeroStartTime
)
{
mAudioStartTime
.
emplace
(
0
)
;
mVideoStartTime
.
emplace
(
0
)
;
return
;
}
if
(
!
aHasAudio
)
{
mAudioStartTime
.
emplace
(
INT64_MAX
)
;
}
if
(
!
aHasVideo
)
{
mVideoStartTime
.
emplace
(
INT64_MAX
)
;
}
}
void
Destroy
(
)
{
mAudioStartTime
=
Some
(
mAudioStartTime
.
refOr
(
INT64_MAX
)
)
;
mVideoStartTime
=
Some
(
mVideoStartTime
.
refOr
(
INT64_MAX
)
)
;
mHaveStartTimePromise
.
RejectIfExists
(
false
__func__
)
;
}
RefPtr
<
HaveStartTimePromise
>
AwaitStartTime
(
)
{
if
(
HaveStartTime
(
)
)
{
return
HaveStartTimePromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
return
mHaveStartTimePromise
.
Ensure
(
__func__
)
;
}
template
<
typename
PromiseType
>
struct
PromiseSampleType
{
typedef
typename
PromiseType
:
:
ResolveValueType
:
:
element_type
Type
;
}
;
template
<
typename
PromiseType
MediaData
:
:
Type
SampleType
>
RefPtr
<
PromiseType
>
ProcessFirstSample
(
typename
PromiseSampleType
<
PromiseType
>
:
:
Type
*
aData
)
{
typedef
typename
PromiseSampleType
<
PromiseType
>
:
:
Type
DataType
;
typedef
typename
PromiseType
:
:
Private
PromisePrivate
;
MOZ_ASSERT
(
mOwnerThread
-
>
IsCurrentThreadIn
(
)
)
;
MaybeSetChannelStartTime
<
SampleType
>
(
aData
-
>
mTime
)
;
RefPtr
<
PromisePrivate
>
p
=
new
PromisePrivate
(
__func__
)
;
RefPtr
<
DataType
>
data
=
aData
;
RefPtr
<
StartTimeRendezvous
>
self
=
this
;
AwaitStartTime
(
)
-
>
Then
(
mOwnerThread
__func__
[
p
data
self
]
(
)
-
>
void
{
MOZ_ASSERT
(
self
-
>
mOwnerThread
-
>
IsCurrentThreadIn
(
)
)
;
p
-
>
Resolve
(
data
__func__
)
;
}
[
p
]
(
)
-
>
void
{
p
-
>
Reject
(
MediaDecoderReader
:
:
CANCELED
__func__
)
;
}
)
;
return
p
.
forget
(
)
;
}
template
<
MediaData
:
:
Type
SampleType
>
void
FirstSampleRejected
(
MediaDecoderReader
:
:
NotDecodedReason
aReason
)
{
MOZ_ASSERT
(
mOwnerThread
-
>
IsCurrentThreadIn
(
)
)
;
if
(
aReason
=
=
MediaDecoderReader
:
:
DECODE_ERROR
)
{
mHaveStartTimePromise
.
RejectIfExists
(
false
__func__
)
;
}
else
if
(
aReason
=
=
MediaDecoderReader
:
:
END_OF_STREAM
)
{
MOZ_LOG
(
gMediaDecoderLog
LogLevel
:
:
Debug
(
"
StartTimeRendezvous
=
%
p
SampleType
(
%
d
)
Has
no
samples
.
"
this
SampleType
)
)
;
MaybeSetChannelStartTime
<
SampleType
>
(
INT64_MAX
)
;
}
}
bool
HaveStartTime
(
)
{
return
mAudioStartTime
.
isSome
(
)
&
&
mVideoStartTime
.
isSome
(
)
;
}
int64_t
StartTime
(
)
{
int64_t
time
=
std
:
:
min
(
mAudioStartTime
.
ref
(
)
mVideoStartTime
.
ref
(
)
)
;
return
time
=
=
INT64_MAX
?
0
:
time
;
}
private
:
virtual
~
StartTimeRendezvous
(
)
{
}
template
<
MediaData
:
:
Type
SampleType
>
void
MaybeSetChannelStartTime
(
int64_t
aStartTime
)
{
if
(
ChannelStartTime
(
SampleType
)
.
isSome
(
)
)
{
return
;
}
MOZ_LOG
(
gMediaDecoderLog
LogLevel
:
:
Debug
(
"
StartTimeRendezvous
=
%
p
Setting
SampleType
(
%
d
)
start
time
to
%
lld
"
this
SampleType
aStartTime
)
)
;
ChannelStartTime
(
SampleType
)
.
emplace
(
aStartTime
)
;
if
(
HaveStartTime
(
)
)
{
mHaveStartTimePromise
.
ResolveIfExists
(
true
__func__
)
;
}
}
Maybe
<
int64_t
>
&
ChannelStartTime
(
MediaData
:
:
Type
aType
)
{
return
aType
=
=
MediaData
:
:
AUDIO_DATA
?
mAudioStartTime
:
mVideoStartTime
;
}
MozPromiseHolder
<
HaveStartTimePromise
>
mHaveStartTimePromise
;
RefPtr
<
AbstractThread
>
mOwnerThread
;
Maybe
<
int64_t
>
mAudioStartTime
;
Maybe
<
int64_t
>
mVideoStartTime
;
}
;
RefPtr
<
StartTimeRendezvous
>
mStartTimeRendezvous
;
bool
HaveStartTime
(
)
{
return
mStartTimeRendezvous
&
&
mStartTimeRendezvous
-
>
HaveStartTime
(
)
;
}
int64_t
StartTime
(
)
{
return
mStartTimeRendezvous
-
>
StartTime
(
)
;
}
TimeStamp
mVideoDecodeStartTime
;
MediaQueue
<
MediaData
>
mAudioQueue
;
MediaQueue
<
MediaData
>
mVideoQueue
;
Watchable
<
State
>
mState
;
TaskQueue
*
DecodeTaskQueue
(
)
const
{
return
mReader
-
>
OwnerThread
(
)
;
}
TimeStamp
mBufferingStart
;
media
:
:
TimeUnit
Duration
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mDuration
.
Ref
(
)
.
ref
(
)
;
}
void
RecomputeDuration
(
)
;
FrameID
mCurrentFrameID
;
Watchable
<
media
:
:
TimeUnit
>
mObservedDuration
;
bool
IsLogicallyPlaying
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mPlayState
=
=
MediaDecoder
:
:
PLAY_STATE_PLAYING
|
|
mNextPlayState
=
=
MediaDecoder
:
:
PLAY_STATE_PLAYING
;
}
struct
SeekJob
{
void
Steal
(
SeekJob
&
aOther
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
Exists
(
)
)
;
mTarget
=
aOther
.
mTarget
;
aOther
.
mTarget
.
Reset
(
)
;
mPromise
=
Move
(
aOther
.
mPromise
)
;
}
bool
Exists
(
)
{
MOZ_ASSERT
(
mTarget
.
IsValid
(
)
=
=
!
mPromise
.
IsEmpty
(
)
)
;
return
mTarget
.
IsValid
(
)
;
}
void
Resolve
(
bool
aAtEnd
const
char
*
aCallSite
)
{
mTarget
.
Reset
(
)
;
MediaDecoder
:
:
SeekResolveValue
val
(
aAtEnd
mTarget
.
mEventVisibility
)
;
mPromise
.
Resolve
(
val
aCallSite
)
;
}
void
RejectIfExists
(
const
char
*
aCallSite
)
{
mTarget
.
Reset
(
)
;
mPromise
.
RejectIfExists
(
true
aCallSite
)
;
}
~
SeekJob
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mTarget
.
IsValid
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mPromise
.
IsEmpty
(
)
)
;
}
SeekTarget
mTarget
;
MozPromiseHolder
<
MediaDecoder
:
:
SeekPromise
>
mPromise
;
}
;
SeekJob
mQueuedSeek
;
SeekJob
mPendingSeek
;
SeekJob
mCurrentSeek
;
int64_t
mFragmentEndTime
;
RefPtr
<
media
:
:
MediaSink
>
mMediaSink
;
RefPtr
<
MediaDecoderReader
>
mReader
;
int64_t
AudioEndTime
(
)
const
;
int64_t
VideoEndTime
(
)
const
;
int64_t
mDecodedAudioEndTime
;
int64_t
mDecodedVideoEndTime
;
double
mPlaybackRate
;
TimeStamp
mDecodeStartTime
;
uint32_t
mBufferingWait
;
int64_t
mLowDataThresholdUsecs
;
uint32_t
GetAmpleVideoFrames
(
)
const
;
int64_t
mLowAudioThresholdUsecs
;
int64_t
mAmpleAudioThresholdUsecs
;
int64_t
mQuickBufferingLowDataThresholdUsecs
;
uint32_t
AudioPrerollUsecs
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
IsRealTime
(
)
)
{
return
0
;
}
uint32_t
result
=
mLowAudioThresholdUsecs
*
2
;
MOZ_ASSERT
(
result
<
=
mAmpleAudioThresholdUsecs
"
Prerolling
will
never
finish
"
)
;
return
result
;
}
uint32_t
VideoPrerollFrames
(
)
const
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
IsRealTime
(
)
?
0
:
GetAmpleVideoFrames
(
)
/
2
;
}
bool
DonePrerollingAudio
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
!
IsAudioDecoding
(
)
|
|
GetDecodedAudioDuration
(
)
>
=
AudioPrerollUsecs
(
)
*
mPlaybackRate
;
}
bool
DonePrerollingVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
!
IsVideoDecoding
(
)
|
|
static_cast
<
uint32_t
>
(
VideoQueue
(
)
.
GetSize
(
)
)
>
=
VideoPrerollFrames
(
)
*
mPlaybackRate
+
1
;
}
void
StopPrerollingAudio
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mIsAudioPrerolling
)
{
mIsAudioPrerolling
=
false
;
ScheduleStateMachine
(
)
;
}
}
void
StopPrerollingVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mIsVideoPrerolling
)
{
mIsVideoPrerolling
=
false
;
ScheduleStateMachine
(
)
;
}
}
RefPtr
<
MediaData
>
mFirstVideoFrameAfterSeek
;
bool
mIsAudioPrerolling
;
bool
mIsVideoPrerolling
;
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
AudioDataPromise
>
mAudioDataRequest
;
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
WaitForDataPromise
>
mAudioWaitRequest
;
const
char
*
AudioRequestStatus
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mAudioDataRequest
.
Exists
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mAudioWaitRequest
.
Exists
(
)
)
;
return
"
pending
"
;
}
else
if
(
mAudioWaitRequest
.
Exists
(
)
)
{
return
"
waiting
"
;
}
return
"
idle
"
;
}
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
WaitForDataPromise
>
mVideoWaitRequest
;
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
VideoDataPromise
>
mVideoDataRequest
;
const
char
*
VideoRequestStatus
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mVideoDataRequest
.
Exists
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mVideoWaitRequest
.
Exists
(
)
)
;
return
"
pending
"
;
}
else
if
(
mVideoWaitRequest
.
Exists
(
)
)
{
return
"
waiting
"
;
}
return
"
idle
"
;
}
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
WaitForDataPromise
>
&
WaitRequestRef
(
MediaData
:
:
Type
aType
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
aType
=
=
MediaData
:
:
AUDIO_DATA
?
mAudioWaitRequest
:
mVideoWaitRequest
;
}
Watchable
<
bool
>
mAudioCaptured
;
Watchable
<
bool
>
mAudioCompleted
;
Watchable
<
bool
>
mVideoCompleted
;
Maybe
<
bool
>
mPendingDormant
;
bool
mNotifyMetadataBeforeFirstFrame
;
bool
mDispatchedEventToDecode
;
bool
mQuickBuffering
;
bool
mMinimizePreroll
;
bool
mDecodeThreadWaiting
;
bool
mDropAudioUntilNextDiscontinuity
;
bool
mDropVideoUntilNextDiscontinuity
;
bool
mDecodeToSeekTarget
;
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
SeekPromise
>
mSeekRequest
;
int64_t
mCurrentTimeBeforeSeek
;
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
MetadataPromise
>
mMetadataRequest
;
MediaInfo
mInfo
;
nsAutoPtr
<
MetadataTags
>
mMetadataTags
;
mozilla
:
:
MediaMetadataManager
mMetadataManager
;
mozilla
:
:
RollingMean
<
uint32_t
uint32_t
>
mCorruptFrames
;
bool
mDecodingFirstFrame
;
bool
mSentLoadedMetadataEvent
;
Watchable
<
bool
>
mSentFirstFrameLoadedEvent
;
bool
mSentPlaybackEndedEvent
;
const
RefPtr
<
OutputStreamManager
>
mOutputStreamManager
;
RefPtr
<
MediaResource
>
mResource
;
MozPromiseRequestHolder
<
GenericPromise
>
mMediaSinkAudioPromise
;
MozPromiseRequestHolder
<
GenericPromise
>
mMediaSinkVideoPromise
;
MediaEventListener
mAudioQueueListener
;
MediaEventListener
mVideoQueueListener
;
MediaEventProducerExc
<
nsAutoPtr
<
MediaInfo
>
nsAutoPtr
<
MetadataTags
>
MediaDecoderEventVisibility
>
mMetadataLoadedEvent
;
MediaEventProducerExc
<
nsAutoPtr
<
MediaInfo
>
MediaDecoderEventVisibility
>
mFirstFrameLoadedEvent
;
MediaEventProducer
<
MediaEventType
>
mOnPlaybackEvent
;
MediaEventProducer
<
MediaDecoderEventVisibility
>
mOnSeekingStart
;
bool
mAudioOffloading
;
#
ifdef
MOZ_EME
void
OnCDMProxyReady
(
RefPtr
<
CDMProxy
>
aProxy
)
;
void
OnCDMProxyNotReady
(
)
;
RefPtr
<
CDMProxy
>
mCDMProxy
;
MozPromiseRequestHolder
<
MediaDecoder
:
:
CDMProxyPromise
>
mCDMProxyPromise
;
#
endif
private
:
Mirror
<
media
:
:
TimeIntervals
>
mBuffered
;
Mirror
<
media
:
:
NullableTimeUnit
>
mEstimatedDuration
;
Mirror
<
Maybe
<
double
>
>
mExplicitDuration
;
Mirror
<
MediaDecoder
:
:
PlayState
>
mPlayState
;
Mirror
<
MediaDecoder
:
:
PlayState
>
mNextPlayState
;
Mirror
<
bool
>
mLogicallySeeking
;
Mirror
<
double
>
mVolume
;
Mirror
<
double
>
mLogicalPlaybackRate
;
Mirror
<
bool
>
mPreservesPitch
;
Mirror
<
bool
>
mSameOriginMedia
;
Mirror
<
double
>
mPlaybackBytesPerSecond
;
Mirror
<
bool
>
mPlaybackRateReliable
;
Mirror
<
int64_t
>
mDecoderPosition
;
Mirror
<
bool
>
mMediaSeekable
;
Canonical
<
media
:
:
NullableTimeUnit
>
mDuration
;
Canonical
<
bool
>
mIsShutdown
;
Canonical
<
NextFrameStatus
>
mNextFrameStatus
;
Canonical
<
int64_t
>
mCurrentPosition
;
Canonical
<
int64_t
>
mPlaybackOffset
;
public
:
AbstractCanonical
<
media
:
:
TimeIntervals
>
*
CanonicalBuffered
(
)
{
return
mReader
-
>
CanonicalBuffered
(
)
;
}
AbstractCanonical
<
media
:
:
NullableTimeUnit
>
*
CanonicalDuration
(
)
{
return
&
mDuration
;
}
AbstractCanonical
<
bool
>
*
CanonicalIsShutdown
(
)
{
return
&
mIsShutdown
;
}
AbstractCanonical
<
NextFrameStatus
>
*
CanonicalNextFrameStatus
(
)
{
return
&
mNextFrameStatus
;
}
AbstractCanonical
<
int64_t
>
*
CanonicalCurrentPosition
(
)
{
return
&
mCurrentPosition
;
}
AbstractCanonical
<
int64_t
>
*
CanonicalPlaybackOffset
(
)
{
return
&
mPlaybackOffset
;
}
}
;
}
#
endif
