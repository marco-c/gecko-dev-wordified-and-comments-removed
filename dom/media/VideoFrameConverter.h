#
ifndef
VideoFrameConverter_h
#
define
VideoFrameConverter_h
#
include
"
ImageContainer
.
h
"
#
include
"
ImageConversion
.
h
"
#
include
"
Pacer
.
h
"
#
include
"
PerformanceRecorder
.
h
"
#
include
"
VideoSegment
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
jsapi
/
RTCStatsReport
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmapBinding
.
h
"
#
include
"
mozilla
/
dom
/
ImageUtils
.
h
"
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
common_video
/
include
/
video_frame_buffer_pool
.
h
"
#
include
"
common_video
/
include
/
video_frame_buffer
.
h
"
#
define
CONVERTER_BUFFER_POOL_SIZE
5
extern
mozilla
:
:
LazyLogModule
gMediaPipelineLog
;
#
define
LOG
(
level
msg
.
.
.
)
\
MOZ_LOG
(
gMediaPipelineLog
level
(
msg
#
#
__VA_ARGS__
)
)
namespace
mozilla
{
enum
class
FrameDroppingPolicy
{
Allowed
Disabled
}
;
template
<
FrameDroppingPolicy
DropPolicy
=
FrameDroppingPolicy
:
:
Allowed
>
class
VideoFrameConverterImpl
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
VideoFrameConverterImpl
)
protected
:
explicit
VideoFrameConverterImpl
(
already_AddRefed
<
nsISerialEventTarget
>
aTarget
const
dom
:
:
RTCStatsTimestampMaker
&
aTimestampMaker
)
:
mTimestampMaker
(
aTimestampMaker
)
mTarget
(
aTarget
)
mPacer
(
MakeAndAddRef
<
Pacer
<
FrameToProcess
>
>
(
do_AddRef
(
mTarget
)
mIdleFrameDuplicationInterval
)
)
mBufferPool
(
false
CONVERTER_BUFFER_POOL_SIZE
)
{
MOZ_COUNT_CTOR
(
VideoFrameConverterImpl
)
;
}
void
RegisterListener
(
)
{
mPacingListener
=
mPacer
-
>
PacedItemEvent
(
)
.
Connect
(
mTarget
[
self
=
RefPtr
(
this
)
]
(
FrameToProcess
&
&
aFrame
TimeStamp
aTime
)
{
self
-
>
QueueForProcessing
(
std
:
:
move
(
aFrame
.
mImage
)
aTime
aFrame
.
mSize
aFrame
.
mForceBlack
)
;
}
)
;
}
public
:
void
QueueVideoChunk
(
const
VideoChunk
&
aChunk
bool
aForceBlack
)
{
gfx
:
:
IntSize
size
=
aChunk
.
mFrame
.
GetIntrinsicSize
(
)
;
if
(
size
.
width
=
=
0
|
|
size
.
height
=
=
0
)
{
return
;
}
TimeStamp
t
=
aChunk
.
mTimeStamp
;
MOZ_ASSERT
(
!
t
.
IsNull
(
)
)
;
mPacer
-
>
Enqueue
(
FrameToProcess
(
aChunk
.
mFrame
.
GetImage
(
)
t
size
aForceBlack
)
t
)
;
}
void
SetActive
(
bool
aActive
)
{
MOZ_ALWAYS_SUCCEEDS
(
mTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
self
=
RefPtr
<
VideoFrameConverterImpl
>
(
this
)
this
aActive
time
=
TimeStamp
:
:
Now
(
)
]
{
if
(
mActive
=
=
aActive
)
{
return
;
}
LOG
(
LogLevel
:
:
Debug
"
VideoFrameConverter
%
p
is
now
%
s
"
this
aActive
?
"
active
"
:
"
inactive
"
)
;
mActive
=
aActive
;
if
(
aActive
&
&
mLastFrameQueuedForProcessing
.
Serial
(
)
!
=
-
2
)
{
QueueForProcessing
(
std
:
:
move
(
mLastFrameQueuedForProcessing
.
mImage
)
std
:
:
max
(
mLastFrameQueuedForProcessing
.
mTime
+
TimeDuration
:
:
FromMicroseconds
(
1
)
time
)
mLastFrameQueuedForProcessing
.
mSize
mLastFrameQueuedForProcessing
.
mForceBlack
)
;
}
}
)
)
)
;
}
void
SetTrackEnabled
(
bool
aTrackEnabled
)
{
MOZ_ALWAYS_SUCCEEDS
(
mTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
self
=
RefPtr
<
VideoFrameConverterImpl
>
(
this
)
this
aTrackEnabled
time
=
TimeStamp
:
:
Now
(
)
]
{
if
(
mTrackEnabled
=
=
aTrackEnabled
)
{
return
;
}
LOG
(
LogLevel
:
:
Debug
"
VideoFrameConverterImpl
%
p
Track
is
now
%
s
"
this
aTrackEnabled
?
"
enabled
"
:
"
disabled
"
)
;
mTrackEnabled
=
aTrackEnabled
;
if
(
!
aTrackEnabled
)
{
QueueForProcessing
(
nullptr
std
:
:
max
(
mLastFrameQueuedForProcessing
.
mTime
+
TimeDuration
:
:
FromMicroseconds
(
1
)
time
)
mLastFrameQueuedForProcessing
.
mSize
true
)
;
}
}
)
)
)
;
}
void
SetTrackingId
(
TrackingId
aTrackingId
)
{
MOZ_ALWAYS_SUCCEEDS
(
mTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
self
=
RefPtr
<
VideoFrameConverterImpl
>
(
this
)
this
id
=
std
:
:
move
(
aTrackingId
)
]
(
)
mutable
{
mTrackingId
=
Some
(
std
:
:
move
(
id
)
)
;
}
)
)
)
;
}
void
SetIdleFrameDuplicationInterval
(
TimeDuration
aInterval
)
{
MOZ_ALWAYS_SUCCEEDS
(
mTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
self
=
RefPtr
(
this
)
this
aInterval
]
{
mIdleFrameDuplicationInterval
=
aInterval
;
}
)
)
)
;
mPacer
-
>
SetDuplicationInterval
(
aInterval
)
;
}
void
Shutdown
(
)
{
mPacer
-
>
Shutdown
(
)
-
>
Then
(
mTarget
__func__
[
self
=
RefPtr
<
VideoFrameConverterImpl
>
(
this
)
this
]
{
mPacingListener
.
DisconnectIfExists
(
)
;
mBufferPool
.
Release
(
)
;
mLastFrameQueuedForProcessing
=
FrameToProcess
(
)
;
mLastFrameConverted
=
Nothing
(
)
;
}
)
;
}
MediaEventSourceExc
<
webrtc
:
:
VideoFrame
>
&
VideoFrameConvertedEvent
(
)
{
return
mVideoFrameConvertedEvent
;
}
protected
:
struct
FrameToProcess
{
FrameToProcess
(
)
=
default
;
FrameToProcess
(
RefPtr
<
layers
:
:
Image
>
aImage
TimeStamp
aTime
gfx
:
:
IntSize
aSize
bool
aForceBlack
)
:
mImage
(
std
:
:
move
(
aImage
)
)
mTime
(
aTime
)
mSize
(
aSize
)
mForceBlack
(
aForceBlack
)
{
}
RefPtr
<
layers
:
:
Image
>
mImage
;
TimeStamp
mTime
=
TimeStamp
:
:
Now
(
)
;
gfx
:
:
IntSize
mSize
=
gfx
:
:
IntSize
(
640
480
)
;
bool
mForceBlack
=
false
;
int32_t
Serial
(
)
const
{
if
(
mForceBlack
)
{
return
-
1
;
}
if
(
!
mImage
)
{
return
-
2
;
}
return
mImage
-
>
GetSerial
(
)
;
}
}
;
struct
FrameConverted
{
FrameConverted
(
webrtc
:
:
VideoFrame
aFrame
int32_t
aSerial
)
:
mFrame
(
std
:
:
move
(
aFrame
)
)
mSerial
(
aSerial
)
{
}
webrtc
:
:
VideoFrame
mFrame
;
int32_t
mSerial
;
}
;
MOZ_COUNTED_DTOR_VIRTUAL
(
VideoFrameConverterImpl
)
void
VideoFrameConverted
(
webrtc
:
:
VideoFrame
aVideoFrame
int32_t
aSerial
)
{
MOZ_ASSERT
(
mTarget
-
>
IsOnCurrentThread
(
)
)
;
LOG
(
LogLevel
:
:
Verbose
"
VideoFrameConverterImpl
%
p
:
Converted
a
frame
.
Diff
from
last
:
%
.
3fms
"
this
static_cast
<
double
>
(
aVideoFrame
.
timestamp_us
(
)
-
(
mLastFrameConverted
?
mLastFrameConverted
-
>
mFrame
.
timestamp_us
(
)
:
aVideoFrame
.
timestamp_us
(
)
)
)
/
1000
)
;
MOZ_ASSERT_IF
(
mLastFrameConverted
aVideoFrame
.
timestamp_us
(
)
>
mLastFrameConverted
-
>
mFrame
.
timestamp_us
(
)
)
;
mLastFrameConverted
=
Some
(
FrameConverted
(
aVideoFrame
aSerial
)
)
;
mVideoFrameConvertedEvent
.
Notify
(
std
:
:
move
(
aVideoFrame
)
)
;
}
void
QueueForProcessing
(
RefPtr
<
layers
:
:
Image
>
aImage
TimeStamp
aTime
gfx
:
:
IntSize
aSize
bool
aForceBlack
)
{
MOZ_ASSERT
(
mTarget
-
>
IsOnCurrentThread
(
)
)
;
FrameToProcess
frame
{
std
:
:
move
(
aImage
)
aTime
aSize
aForceBlack
|
|
!
mTrackEnabled
}
;
if
(
frame
.
mTime
<
=
mLastFrameQueuedForProcessing
.
mTime
)
{
LOG
(
LogLevel
:
:
Debug
"
VideoFrameConverterImpl
%
p
:
Dropping
a
frame
because
time
did
not
"
"
progress
(
%
.
3fs
)
"
this
(
mLastFrameQueuedForProcessing
.
mTime
-
frame
.
mTime
)
.
ToSeconds
(
)
)
;
return
;
}
if
(
frame
.
Serial
(
)
=
=
mLastFrameQueuedForProcessing
.
Serial
(
)
)
{
if
(
auto
diff
=
frame
.
mTime
-
mLastFrameQueuedForProcessing
.
mTime
;
diff
>
=
mIdleFrameDuplicationInterval
)
{
auto
diff_us
=
static_cast
<
int64_t
>
(
diff
.
ToMicroseconds
(
)
)
;
auto
idle_interval_us
=
static_cast
<
int64_t
>
(
mIdleFrameDuplicationInterval
.
ToMicroseconds
(
)
)
;
auto
multiples
=
diff_us
/
idle_interval_us
;
MOZ_ASSERT
(
multiples
>
0
)
;
LOG
(
LogLevel
:
:
Verbose
"
VideoFrameConverterImpl
%
p
:
Rewrote
time
interval
for
a
duplicate
"
"
frame
from
%
.
3fs
to
%
.
3fs
"
this
(
frame
.
mTime
-
mLastFrameQueuedForProcessing
.
mTime
)
.
ToSeconds
(
)
(
mIdleFrameDuplicationInterval
*
multiples
)
.
ToSeconds
(
)
)
;
frame
.
mTime
=
mLastFrameQueuedForProcessing
.
mTime
+
(
mIdleFrameDuplicationInterval
*
multiples
)
;
}
else
{
LOG
(
LogLevel
:
:
Verbose
"
VideoFrameConverterImpl
%
p
:
Dropping
a
duplicate
frame
because
"
"
the
"
"
duplication
interval
(
%
.
3fs
)
hasn
'
t
passed
(
%
.
3fs
)
"
this
mIdleFrameDuplicationInterval
.
ToSeconds
(
)
(
frame
.
mTime
-
mLastFrameQueuedForProcessing
.
mTime
)
.
ToSeconds
(
)
)
;
return
;
}
}
mLastFrameQueuedForProcessing
=
std
:
:
move
(
frame
)
;
if
(
!
mActive
)
{
LOG
(
LogLevel
:
:
Debug
"
VideoFrameConverterImpl
%
p
:
Ignoring
a
frame
because
we
'
re
inactive
"
this
)
;
return
;
}
MOZ_ALWAYS_SUCCEEDS
(
mTarget
-
>
Dispatch
(
NewRunnableMethod
<
FrameToProcess
>
(
"
VideoFrameConverterImpl
:
:
ProcessVideoFrame
"
this
&
VideoFrameConverterImpl
:
:
ProcessVideoFrame
mLastFrameQueuedForProcessing
)
)
)
;
}
void
ProcessVideoFrame
(
const
FrameToProcess
&
aFrame
)
{
MOZ_ASSERT
(
mTarget
-
>
IsOnCurrentThread
(
)
)
;
if
constexpr
(
DropPolicy
=
=
FrameDroppingPolicy
:
:
Allowed
)
{
if
(
aFrame
.
mTime
<
mLastFrameQueuedForProcessing
.
mTime
)
{
LOG
(
LogLevel
:
:
Debug
"
VideoFrameConverterImpl
%
p
:
Dropping
a
frame
that
is
%
.
3f
seconds
"
"
before
latest
"
this
(
mLastFrameQueuedForProcessing
.
mTime
-
aFrame
.
mTime
)
.
ToSeconds
(
)
)
;
return
;
}
}
const
webrtc
:
:
Timestamp
time
=
dom
:
:
RTCStatsTimestamp
:
:
FromMozTime
(
mTimestampMaker
aFrame
.
mTime
)
.
ToRealtime
(
)
;
if
(
mLastFrameConverted
&
&
aFrame
.
Serial
(
)
=
=
mLastFrameConverted
-
>
mSerial
)
{
webrtc
:
:
VideoFrame
frame
=
mLastFrameConverted
-
>
mFrame
;
frame
.
set_timestamp_us
(
time
.
us
(
)
)
;
VideoFrameConverted
(
std
:
:
move
(
frame
)
mLastFrameConverted
-
>
mSerial
)
;
return
;
}
if
(
aFrame
.
mForceBlack
)
{
rtc
:
:
scoped_refptr
<
webrtc
:
:
I420Buffer
>
buffer
=
mBufferPool
.
CreateI420Buffer
(
aFrame
.
mSize
.
width
aFrame
.
mSize
.
height
)
;
if
(
!
buffer
)
{
MOZ_DIAGNOSTIC_CRASH
(
"
Buffers
not
leaving
scope
except
for
"
"
reconfig
should
never
leak
"
)
;
LOG
(
LogLevel
:
:
Warning
"
VideoFrameConverterImpl
%
p
:
Creating
a
buffer
for
a
black
video
"
"
frame
failed
"
this
)
;
return
;
}
LOG
(
LogLevel
:
:
Verbose
"
VideoFrameConverterImpl
%
p
:
Sending
a
black
video
frame
"
this
)
;
webrtc
:
:
I420Buffer
:
:
SetBlack
(
buffer
.
get
(
)
)
;
VideoFrameConverted
(
webrtc
:
:
VideoFrame
:
:
Builder
(
)
.
set_video_frame_buffer
(
buffer
)
.
set_timestamp_us
(
time
.
us
(
)
)
.
build
(
)
aFrame
.
Serial
(
)
)
;
return
;
}
if
(
!
aFrame
.
mImage
)
{
return
;
}
MOZ_ASSERT
(
aFrame
.
mImage
-
>
GetSize
(
)
=
=
aFrame
.
mSize
)
;
RefPtr
<
layers
:
:
PlanarYCbCrImage
>
image
=
aFrame
.
mImage
-
>
AsPlanarYCbCrImage
(
)
;
if
(
image
)
{
dom
:
:
ImageUtils
utils
(
image
)
;
Maybe
<
dom
:
:
ImageBitmapFormat
>
format
=
utils
.
GetFormat
(
)
;
if
(
format
.
isSome
(
)
&
&
format
.
value
(
)
=
=
dom
:
:
ImageBitmapFormat
:
:
YUV420P
&
&
image
-
>
GetData
(
)
)
{
const
layers
:
:
PlanarYCbCrData
*
data
=
image
-
>
GetData
(
)
;
rtc
:
:
scoped_refptr
<
webrtc
:
:
I420BufferInterface
>
video_frame_buffer
=
webrtc
:
:
WrapI420Buffer
(
aFrame
.
mImage
-
>
GetSize
(
)
.
width
aFrame
.
mImage
-
>
GetSize
(
)
.
height
data
-
>
mYChannel
data
-
>
mYStride
data
-
>
mCbChannel
data
-
>
mCbCrStride
data
-
>
mCrChannel
data
-
>
mCbCrStride
[
image
]
{
}
)
;
LOG
(
LogLevel
:
:
Verbose
"
VideoFrameConverterImpl
%
p
:
Sending
an
I420
video
frame
"
this
)
;
VideoFrameConverted
(
webrtc
:
:
VideoFrame
:
:
Builder
(
)
.
set_video_frame_buffer
(
video_frame_buffer
)
.
set_timestamp_us
(
time
.
us
(
)
)
.
build
(
)
aFrame
.
Serial
(
)
)
;
return
;
}
}
rtc
:
:
scoped_refptr
<
webrtc
:
:
I420Buffer
>
buffer
=
mBufferPool
.
CreateI420Buffer
(
aFrame
.
mSize
.
width
aFrame
.
mSize
.
height
)
;
if
(
!
buffer
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
+
+
mFramesDropped
;
#
endif
MOZ_DIAGNOSTIC_ASSERT
(
mFramesDropped
<
=
100
"
Buffers
must
be
leaking
"
)
;
LOG
(
LogLevel
:
:
Warning
"
VideoFrameConverterImpl
%
p
:
Creating
a
buffer
failed
"
this
)
;
return
;
}
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mFramesDropped
=
0
;
#
endif
PerformanceRecorder
<
CopyVideoStage
>
rec
(
"
VideoFrameConverterImpl
:
:
ConvertToI420
"
_ns
*
mTrackingId
buffer
-
>
width
(
)
buffer
-
>
height
(
)
)
;
nsresult
rv
=
ConvertToI420
(
aFrame
.
mImage
buffer
-
>
MutableDataY
(
)
buffer
-
>
StrideY
(
)
buffer
-
>
MutableDataU
(
)
buffer
-
>
StrideU
(
)
buffer
-
>
MutableDataV
(
)
buffer
-
>
StrideV
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
LogLevel
:
:
Warning
"
VideoFrameConverterImpl
%
p
:
Image
conversion
failed
"
this
)
;
return
;
}
rec
.
Record
(
)
;
VideoFrameConverted
(
webrtc
:
:
VideoFrame
:
:
Builder
(
)
.
set_video_frame_buffer
(
buffer
)
.
set_timestamp_us
(
time
.
us
(
)
)
.
build
(
)
aFrame
.
Serial
(
)
)
;
}
public
:
const
dom
:
:
RTCStatsTimestampMaker
mTimestampMaker
;
const
nsCOMPtr
<
nsISerialEventTarget
>
mTarget
;
protected
:
TimeDuration
mIdleFrameDuplicationInterval
=
TimeDuration
:
:
Forever
(
)
;
const
RefPtr
<
Pacer
<
FrameToProcess
>
>
mPacer
;
MediaEventProducerExc
<
webrtc
:
:
VideoFrame
>
mVideoFrameConvertedEvent
;
MediaEventListener
mPacingListener
;
webrtc
:
:
VideoFrameBufferPool
mBufferPool
;
FrameToProcess
mLastFrameQueuedForProcessing
;
Maybe
<
FrameConverted
>
mLastFrameConverted
;
bool
mActive
=
false
;
bool
mTrackEnabled
=
true
;
Maybe
<
TrackingId
>
mTrackingId
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
size_t
mFramesDropped
=
0
;
#
endif
}
;
class
VideoFrameConverter
final
:
public
VideoFrameConverterImpl
<
FrameDroppingPolicy
:
:
Allowed
>
{
protected
:
VideoFrameConverter
(
already_AddRefed
<
nsISerialEventTarget
>
aTarget
const
dom
:
:
RTCStatsTimestampMaker
&
aTimestampMaker
)
:
VideoFrameConverterImpl
(
std
:
:
move
(
aTarget
)
aTimestampMaker
)
{
}
public
:
static
already_AddRefed
<
VideoFrameConverter
>
Create
(
already_AddRefed
<
nsISerialEventTarget
>
aTarget
const
dom
:
:
RTCStatsTimestampMaker
&
aTimestampMaker
)
{
RefPtr
<
VideoFrameConverter
>
converter
=
new
VideoFrameConverter
(
std
:
:
move
(
aTarget
)
aTimestampMaker
)
;
converter
-
>
RegisterListener
(
)
;
return
converter
.
forget
(
)
;
}
}
;
}
#
undef
LOG
#
endif
