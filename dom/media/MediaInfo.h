#
if
!
defined
(
MediaInfo_h
)
#
define
MediaInfo_h
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
StreamBuffer
.
h
"
#
include
"
TimeUnits
.
h
"
namespace
mozilla
{
class
AudioInfo
;
class
VideoInfo
;
class
TextInfo
;
class
MetadataTag
{
public
:
MetadataTag
(
const
nsACString
&
aKey
const
nsACString
&
aValue
)
:
mKey
(
aKey
)
mValue
(
aValue
)
{
}
nsCString
mKey
;
nsCString
mValue
;
}
;
class
TrackInfo
{
public
:
enum
TrackType
{
kUndefinedTrack
kAudioTrack
kVideoTrack
kTextTrack
}
;
TrackInfo
(
TrackType
aType
const
nsAString
&
aId
const
nsAString
&
aKind
const
nsAString
&
aLabel
const
nsAString
&
aLanguage
bool
aEnabled
TrackID
aTrackId
)
:
mId
(
aId
)
mKind
(
aKind
)
mLabel
(
aLabel
)
mLanguage
(
aLanguage
)
mEnabled
(
aEnabled
)
mTrackId
(
aTrackId
)
mDuration
(
0
)
mMediaTime
(
0
)
mIsRenderedExternally
(
false
)
mType
(
aType
)
{
MOZ_COUNT_CTOR
(
TrackInfo
)
;
}
void
Init
(
const
nsAString
&
aId
const
nsAString
&
aKind
const
nsAString
&
aLabel
const
nsAString
&
aLanguage
bool
aEnabled
)
{
mId
=
aId
;
mKind
=
aKind
;
mLabel
=
aLabel
;
mLanguage
=
aLanguage
;
mEnabled
=
aEnabled
;
}
nsString
mId
;
nsString
mKind
;
nsString
mLabel
;
nsString
mLanguage
;
bool
mEnabled
;
TrackID
mTrackId
;
nsCString
mMimeType
;
int64_t
mDuration
;
int64_t
mMediaTime
;
CryptoTrack
mCrypto
;
nsTArray
<
MetadataTag
>
mTags
;
bool
mIsRenderedExternally
;
virtual
AudioInfo
*
GetAsAudioInfo
(
)
{
return
nullptr
;
}
virtual
VideoInfo
*
GetAsVideoInfo
(
)
{
return
nullptr
;
}
virtual
TextInfo
*
GetAsTextInfo
(
)
{
return
nullptr
;
}
virtual
const
AudioInfo
*
GetAsAudioInfo
(
)
const
{
return
nullptr
;
}
virtual
const
VideoInfo
*
GetAsVideoInfo
(
)
const
{
return
nullptr
;
}
virtual
const
TextInfo
*
GetAsTextInfo
(
)
const
{
return
nullptr
;
}
bool
IsAudio
(
)
const
{
return
!
!
GetAsAudioInfo
(
)
;
}
bool
IsVideo
(
)
const
{
return
!
!
GetAsVideoInfo
(
)
;
}
bool
IsText
(
)
const
{
return
!
!
GetAsTextInfo
(
)
;
}
TrackType
GetType
(
)
const
{
return
mType
;
}
bool
virtual
IsValid
(
)
const
=
0
;
virtual
UniquePtr
<
TrackInfo
>
Clone
(
)
const
=
0
;
virtual
~
TrackInfo
(
)
{
MOZ_COUNT_DTOR
(
TrackInfo
)
;
}
protected
:
TrackInfo
(
const
TrackInfo
&
aOther
)
{
mId
=
aOther
.
mId
;
mKind
=
aOther
.
mKind
;
mLabel
=
aOther
.
mLabel
;
mLanguage
=
aOther
.
mLanguage
;
mEnabled
=
aOther
.
mEnabled
;
mTrackId
=
aOther
.
mTrackId
;
mMimeType
=
aOther
.
mMimeType
;
mDuration
=
aOther
.
mDuration
;
mMediaTime
=
aOther
.
mMediaTime
;
mCrypto
=
aOther
.
mCrypto
;
mIsRenderedExternally
=
aOther
.
mIsRenderedExternally
;
mType
=
aOther
.
mType
;
mTags
=
aOther
.
mTags
;
MOZ_COUNT_CTOR
(
TrackInfo
)
;
}
private
:
TrackType
mType
;
}
;
class
VideoInfo
:
public
TrackInfo
{
public
:
VideoInfo
(
)
:
VideoInfo
(
-
1
-
1
)
{
}
VideoInfo
(
int32_t
aWidth
int32_t
aHeight
)
:
TrackInfo
(
kVideoTrack
NS_LITERAL_STRING
(
"
2
"
)
NS_LITERAL_STRING
(
"
main
"
)
EmptyString
(
)
EmptyString
(
)
true
2
)
mDisplay
(
nsIntSize
(
aWidth
aHeight
)
)
mStereoMode
(
StereoMode
:
:
MONO
)
mImage
(
nsIntRect
(
0
0
aWidth
aHeight
)
)
mCodecSpecificConfig
(
new
MediaByteBuffer
)
mExtraData
(
new
MediaByteBuffer
)
{
}
VideoInfo
(
const
VideoInfo
&
aOther
)
:
TrackInfo
(
aOther
)
mDisplay
(
aOther
.
mDisplay
)
mStereoMode
(
aOther
.
mStereoMode
)
mImage
(
aOther
.
mImage
)
mCodecSpecificConfig
(
aOther
.
mCodecSpecificConfig
)
mExtraData
(
aOther
.
mExtraData
)
{
}
bool
IsValid
(
)
const
override
{
return
mDisplay
.
width
>
0
&
&
mDisplay
.
height
>
0
;
}
VideoInfo
*
GetAsVideoInfo
(
)
override
{
return
this
;
}
const
VideoInfo
*
GetAsVideoInfo
(
)
const
override
{
return
this
;
}
UniquePtr
<
TrackInfo
>
Clone
(
)
const
override
{
return
MakeUnique
<
VideoInfo
>
(
*
this
)
;
}
nsIntSize
mDisplay
;
StereoMode
mStereoMode
;
nsIntRect
mImage
;
RefPtr
<
MediaByteBuffer
>
mCodecSpecificConfig
;
RefPtr
<
MediaByteBuffer
>
mExtraData
;
}
;
class
AudioInfo
:
public
TrackInfo
{
public
:
AudioInfo
(
)
:
TrackInfo
(
kAudioTrack
NS_LITERAL_STRING
(
"
1
"
)
NS_LITERAL_STRING
(
"
main
"
)
EmptyString
(
)
EmptyString
(
)
true
1
)
mRate
(
0
)
mChannels
(
0
)
mBitDepth
(
0
)
mProfile
(
0
)
mExtendedProfile
(
0
)
mCodecSpecificConfig
(
new
MediaByteBuffer
)
mExtraData
(
new
MediaByteBuffer
)
{
}
AudioInfo
(
const
AudioInfo
&
aOther
)
:
TrackInfo
(
aOther
)
mRate
(
aOther
.
mRate
)
mChannels
(
aOther
.
mChannels
)
mBitDepth
(
aOther
.
mBitDepth
)
mProfile
(
aOther
.
mProfile
)
mExtendedProfile
(
aOther
.
mExtendedProfile
)
mCodecSpecificConfig
(
aOther
.
mCodecSpecificConfig
)
mExtraData
(
aOther
.
mExtraData
)
{
}
bool
IsValid
(
)
const
override
{
return
mChannels
>
0
&
&
mRate
>
0
;
}
AudioInfo
*
GetAsAudioInfo
(
)
override
{
return
this
;
}
const
AudioInfo
*
GetAsAudioInfo
(
)
const
override
{
return
this
;
}
UniquePtr
<
TrackInfo
>
Clone
(
)
const
override
{
return
MakeUnique
<
AudioInfo
>
(
*
this
)
;
}
uint32_t
mRate
;
uint32_t
mChannels
;
uint32_t
mBitDepth
;
int8_t
mProfile
;
int8_t
mExtendedProfile
;
RefPtr
<
MediaByteBuffer
>
mCodecSpecificConfig
;
RefPtr
<
MediaByteBuffer
>
mExtraData
;
}
;
class
EncryptionInfo
{
public
:
EncryptionInfo
(
)
:
mEncrypted
(
false
)
{
}
struct
InitData
{
template
<
typename
AInitDatas
>
InitData
(
const
nsAString
&
aType
AInitDatas
&
&
aInitData
)
:
mType
(
aType
)
mInitData
(
Forward
<
AInitDatas
>
(
aInitData
)
)
{
}
nsString
mType
;
nsTArray
<
uint8_t
>
mInitData
;
}
;
typedef
nsTArray
<
InitData
>
InitDatas
;
bool
IsEncrypted
(
)
const
{
return
mEncrypted
;
}
template
<
typename
AInitDatas
>
void
AddInitData
(
const
nsAString
&
aType
AInitDatas
&
&
aInitData
)
{
mInitDatas
.
AppendElement
(
InitData
(
aType
Forward
<
AInitDatas
>
(
aInitData
)
)
)
;
mEncrypted
=
true
;
}
void
AddInitData
(
const
EncryptionInfo
&
aInfo
)
{
mInitDatas
.
AppendElements
(
aInfo
.
mInitDatas
)
;
mEncrypted
=
!
!
mInitDatas
.
Length
(
)
;
}
InitDatas
mInitDatas
;
private
:
bool
mEncrypted
;
}
;
class
MediaInfo
{
public
:
bool
HasVideo
(
)
const
{
return
mVideo
.
IsValid
(
)
;
}
void
EnableVideo
(
)
{
if
(
HasVideo
(
)
)
{
return
;
}
mVideo
.
mDisplay
=
nsIntSize
(
1
1
)
;
}
bool
HasAudio
(
)
const
{
return
mAudio
.
IsValid
(
)
;
}
void
EnableAudio
(
)
{
if
(
HasAudio
(
)
)
{
return
;
}
mAudio
.
mChannels
=
2
;
mAudio
.
mRate
=
44100
;
}
bool
IsEncrypted
(
)
const
{
return
mCrypto
.
IsEncrypted
(
)
;
}
bool
HasValidMedia
(
)
const
{
return
HasVideo
(
)
|
|
HasAudio
(
)
;
}
void
AssertValid
(
)
const
{
NS_ASSERTION
(
!
HasAudio
(
)
|
|
mAudio
.
mTrackId
!
=
TRACK_INVALID
"
Audio
track
ID
must
be
valid
"
)
;
NS_ASSERTION
(
!
HasVideo
(
)
|
|
mVideo
.
mTrackId
!
=
TRACK_INVALID
"
Audio
track
ID
must
be
valid
"
)
;
NS_ASSERTION
(
!
HasAudio
(
)
|
|
!
HasVideo
(
)
|
|
mAudio
.
mTrackId
!
=
mVideo
.
mTrackId
"
Duplicate
track
IDs
"
)
;
}
VideoInfo
mVideo
;
AudioInfo
mAudio
;
media
:
:
NullableTimeUnit
mMetadataDuration
;
media
:
:
NullableTimeUnit
mUnadjustedMetadataEndTime
;
bool
mMediaSeekable
=
true
;
EncryptionInfo
mCrypto
;
}
;
class
SharedTrackInfo
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SharedTrackInfo
)
public
:
SharedTrackInfo
(
const
TrackInfo
&
aOriginal
uint32_t
aStreamID
)
:
mInfo
(
aOriginal
.
Clone
(
)
)
mStreamSourceID
(
aStreamID
)
mMimeType
(
mInfo
-
>
mMimeType
)
{
}
uint32_t
GetID
(
)
const
{
return
mStreamSourceID
;
}
const
TrackInfo
*
operator
*
(
)
const
{
return
mInfo
.
get
(
)
;
}
const
TrackInfo
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mInfo
.
get
(
)
"
dereferencing
a
UniquePtr
containing
nullptr
"
)
;
return
mInfo
.
get
(
)
;
}
const
AudioInfo
*
GetAsAudioInfo
(
)
const
{
return
mInfo
?
mInfo
-
>
GetAsAudioInfo
(
)
:
nullptr
;
}
const
VideoInfo
*
GetAsVideoInfo
(
)
const
{
return
mInfo
?
mInfo
-
>
GetAsVideoInfo
(
)
:
nullptr
;
}
const
TextInfo
*
GetAsTextInfo
(
)
const
{
return
mInfo
?
mInfo
-
>
GetAsTextInfo
(
)
:
nullptr
;
}
private
:
~
SharedTrackInfo
(
)
{
}
;
UniquePtr
<
TrackInfo
>
mInfo
;
uint32_t
mStreamSourceID
;
public
:
const
nsCString
&
mMimeType
;
}
;
}
#
endif
