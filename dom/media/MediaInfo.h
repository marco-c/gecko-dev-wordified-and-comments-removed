#
if
!
defined
(
MediaInfo_h
)
#
define
MediaInfo_h
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
AudioConfig
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
TrackID
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
namespace
mozilla
{
class
AudioInfo
;
class
VideoInfo
;
class
TextInfo
;
class
MetadataTag
{
public
:
MetadataTag
(
const
nsACString
&
aKey
const
nsACString
&
aValue
)
:
mKey
(
aKey
)
mValue
(
aValue
)
{
}
nsCString
mKey
;
nsCString
mValue
;
bool
operator
=
=
(
const
MetadataTag
&
rhs
)
const
{
return
mKey
=
=
rhs
.
mKey
&
&
mValue
=
=
rhs
.
mValue
;
}
}
;
typedef
nsDataHashtable
<
nsCStringHashKey
nsCString
>
MetadataTags
;
class
TrackInfo
{
public
:
enum
TrackType
{
kUndefinedTrack
kAudioTrack
kVideoTrack
kTextTrack
}
;
TrackInfo
(
TrackType
aType
const
nsAString
&
aId
const
nsAString
&
aKind
const
nsAString
&
aLabel
const
nsAString
&
aLanguage
bool
aEnabled
TrackID
aTrackId
)
:
mId
(
aId
)
mKind
(
aKind
)
mLabel
(
aLabel
)
mLanguage
(
aLanguage
)
mEnabled
(
aEnabled
)
mTrackId
(
aTrackId
)
mIsRenderedExternally
(
false
)
mType
(
aType
)
{
MOZ_COUNT_CTOR
(
TrackInfo
)
;
}
void
Init
(
const
nsAString
&
aId
const
nsAString
&
aKind
const
nsAString
&
aLabel
const
nsAString
&
aLanguage
bool
aEnabled
)
{
mId
=
aId
;
mKind
=
aKind
;
mLabel
=
aLabel
;
mLanguage
=
aLanguage
;
mEnabled
=
aEnabled
;
}
nsString
mId
;
nsString
mKind
;
nsString
mLabel
;
nsString
mLanguage
;
bool
mEnabled
;
TrackID
mTrackId
;
nsCString
mMimeType
;
media
:
:
TimeUnit
mDuration
;
media
:
:
TimeUnit
mMediaTime
;
CryptoTrack
mCrypto
;
nsTArray
<
MetadataTag
>
mTags
;
bool
mIsRenderedExternally
;
virtual
AudioInfo
*
GetAsAudioInfo
(
)
{
return
nullptr
;
}
virtual
VideoInfo
*
GetAsVideoInfo
(
)
{
return
nullptr
;
}
virtual
TextInfo
*
GetAsTextInfo
(
)
{
return
nullptr
;
}
virtual
const
AudioInfo
*
GetAsAudioInfo
(
)
const
{
return
nullptr
;
}
virtual
const
VideoInfo
*
GetAsVideoInfo
(
)
const
{
return
nullptr
;
}
virtual
const
TextInfo
*
GetAsTextInfo
(
)
const
{
return
nullptr
;
}
bool
IsAudio
(
)
const
{
return
!
!
GetAsAudioInfo
(
)
;
}
bool
IsVideo
(
)
const
{
return
!
!
GetAsVideoInfo
(
)
;
}
bool
IsText
(
)
const
{
return
!
!
GetAsTextInfo
(
)
;
}
TrackType
GetType
(
)
const
{
return
mType
;
}
bool
virtual
IsValid
(
)
const
=
0
;
virtual
UniquePtr
<
TrackInfo
>
Clone
(
)
const
=
0
;
virtual
~
TrackInfo
(
)
{
MOZ_COUNT_DTOR
(
TrackInfo
)
;
}
protected
:
TrackInfo
(
const
TrackInfo
&
aOther
)
{
mId
=
aOther
.
mId
;
mKind
=
aOther
.
mKind
;
mLabel
=
aOther
.
mLabel
;
mLanguage
=
aOther
.
mLanguage
;
mEnabled
=
aOther
.
mEnabled
;
mTrackId
=
aOther
.
mTrackId
;
mMimeType
=
aOther
.
mMimeType
;
mDuration
=
aOther
.
mDuration
;
mMediaTime
=
aOther
.
mMediaTime
;
mCrypto
=
aOther
.
mCrypto
;
mIsRenderedExternally
=
aOther
.
mIsRenderedExternally
;
mType
=
aOther
.
mType
;
mTags
=
aOther
.
mTags
;
MOZ_COUNT_CTOR
(
TrackInfo
)
;
}
bool
IsEqualTo
(
const
TrackInfo
&
rhs
)
const
;
private
:
TrackType
mType
;
}
;
const
char
*
TrackTypeToStr
(
TrackInfo
:
:
TrackType
aTrack
)
;
class
VideoInfo
:
public
TrackInfo
{
public
:
enum
Rotation
{
kDegree_0
=
0
kDegree_90
=
90
kDegree_180
=
180
kDegree_270
=
270
}
;
VideoInfo
(
)
:
VideoInfo
(
-
1
-
1
)
{
}
explicit
VideoInfo
(
int32_t
aWidth
int32_t
aHeight
)
:
VideoInfo
(
gfx
:
:
IntSize
(
aWidth
aHeight
)
)
{
}
explicit
VideoInfo
(
const
gfx
:
:
IntSize
&
aSize
)
:
TrackInfo
(
kVideoTrack
NS_LITERAL_STRING
(
"
2
"
)
NS_LITERAL_STRING
(
"
main
"
)
EmptyString
(
)
EmptyString
(
)
true
2
)
mDisplay
(
aSize
)
mStereoMode
(
StereoMode
:
:
MONO
)
mImage
(
aSize
)
mCodecSpecificConfig
(
new
MediaByteBuffer
)
mExtraData
(
new
MediaByteBuffer
)
mRotation
(
kDegree_0
)
mImageRect
(
gfx
:
:
IntRect
(
gfx
:
:
IntPoint
(
)
aSize
)
)
{
}
VideoInfo
(
const
VideoInfo
&
aOther
)
:
TrackInfo
(
aOther
)
mDisplay
(
aOther
.
mDisplay
)
mStereoMode
(
aOther
.
mStereoMode
)
mImage
(
aOther
.
mImage
)
mCodecSpecificConfig
(
aOther
.
mCodecSpecificConfig
)
mExtraData
(
aOther
.
mExtraData
)
mRotation
(
aOther
.
mRotation
)
mColorDepth
(
aOther
.
mColorDepth
)
mImageRect
(
aOther
.
mImageRect
)
mAlphaPresent
(
aOther
.
mAlphaPresent
)
{
}
bool
operator
=
=
(
const
VideoInfo
&
rhs
)
const
;
bool
IsValid
(
)
const
override
{
return
mDisplay
.
width
>
0
&
&
mDisplay
.
height
>
0
;
}
VideoInfo
*
GetAsVideoInfo
(
)
override
{
return
this
;
}
const
VideoInfo
*
GetAsVideoInfo
(
)
const
override
{
return
this
;
}
UniquePtr
<
TrackInfo
>
Clone
(
)
const
override
{
return
MakeUnique
<
VideoInfo
>
(
*
this
)
;
}
void
SetAlpha
(
bool
aAlphaPresent
)
{
mAlphaPresent
=
aAlphaPresent
;
}
bool
HasAlpha
(
)
const
{
return
mAlphaPresent
;
}
gfx
:
:
IntRect
ImageRect
(
)
const
{
if
(
mImageRect
.
Width
(
)
<
0
|
|
mImageRect
.
Height
(
)
<
0
)
{
return
gfx
:
:
IntRect
(
0
0
mImage
.
width
mImage
.
height
)
;
}
return
mImageRect
;
}
void
SetImageRect
(
const
gfx
:
:
IntRect
&
aRect
)
{
mImageRect
=
aRect
;
}
gfx
:
:
IntRect
ScaledImageRect
(
int64_t
aWidth
int64_t
aHeight
)
const
{
if
(
(
aWidth
=
=
mImage
.
width
&
&
aHeight
=
=
mImage
.
height
)
|
|
!
mImage
.
width
|
|
!
mImage
.
height
)
{
return
ImageRect
(
)
;
}
gfx
:
:
IntRect
imageRect
=
ImageRect
(
)
;
int64_t
w
=
(
aWidth
*
imageRect
.
Width
(
)
)
/
mImage
.
width
;
int64_t
h
=
(
aHeight
*
imageRect
.
Height
(
)
)
/
mImage
.
height
;
if
(
!
w
|
|
!
h
)
{
return
imageRect
;
}
imageRect
.
x
=
(
imageRect
.
x
*
aWidth
)
/
mImage
.
width
;
imageRect
.
y
=
(
imageRect
.
y
*
aHeight
)
/
mImage
.
height
;
imageRect
.
SetWidth
(
w
)
;
imageRect
.
SetHeight
(
h
)
;
return
imageRect
;
}
Rotation
ToSupportedRotation
(
int32_t
aDegree
)
const
{
switch
(
aDegree
)
{
case
90
:
return
kDegree_90
;
case
180
:
return
kDegree_180
;
case
270
:
return
kDegree_270
;
default
:
NS_WARNING_ASSERTION
(
aDegree
=
=
0
"
Invalid
rotation
degree
ignored
"
)
;
return
kDegree_0
;
}
}
gfx
:
:
IntSize
mDisplay
;
StereoMode
mStereoMode
;
gfx
:
:
IntSize
mImage
;
RefPtr
<
MediaByteBuffer
>
mCodecSpecificConfig
;
RefPtr
<
MediaByteBuffer
>
mExtraData
;
Rotation
mRotation
;
gfx
:
:
ColorDepth
mColorDepth
=
gfx
:
:
ColorDepth
:
:
COLOR_8
;
private
:
gfx
:
:
IntRect
mImageRect
;
bool
mAlphaPresent
=
false
;
}
;
class
AudioInfo
:
public
TrackInfo
{
public
:
AudioInfo
(
)
:
TrackInfo
(
kAudioTrack
NS_LITERAL_STRING
(
"
1
"
)
NS_LITERAL_STRING
(
"
main
"
)
EmptyString
(
)
EmptyString
(
)
true
1
)
mRate
(
0
)
mChannels
(
0
)
mChannelMap
(
AudioConfig
:
:
ChannelLayout
:
:
UNKNOWN_MAP
)
mBitDepth
(
0
)
mProfile
(
0
)
mExtendedProfile
(
0
)
mCodecSpecificConfig
(
new
MediaByteBuffer
)
mExtraData
(
new
MediaByteBuffer
)
{
}
AudioInfo
(
const
AudioInfo
&
aOther
)
:
TrackInfo
(
aOther
)
mRate
(
aOther
.
mRate
)
mChannels
(
aOther
.
mChannels
)
mChannelMap
(
aOther
.
mChannelMap
)
mBitDepth
(
aOther
.
mBitDepth
)
mProfile
(
aOther
.
mProfile
)
mExtendedProfile
(
aOther
.
mExtendedProfile
)
mCodecSpecificConfig
(
aOther
.
mCodecSpecificConfig
)
mExtraData
(
aOther
.
mExtraData
)
{
}
bool
operator
=
=
(
const
AudioInfo
&
rhs
)
const
;
static
const
uint32_t
MAX_RATE
=
640000
;
bool
IsValid
(
)
const
override
{
return
mChannels
>
0
&
&
mRate
>
0
&
&
mRate
<
=
MAX_RATE
;
}
AudioInfo
*
GetAsAudioInfo
(
)
override
{
return
this
;
}
const
AudioInfo
*
GetAsAudioInfo
(
)
const
override
{
return
this
;
}
UniquePtr
<
TrackInfo
>
Clone
(
)
const
override
{
return
MakeUnique
<
AudioInfo
>
(
*
this
)
;
}
uint32_t
mRate
;
uint32_t
mChannels
;
AudioConfig
:
:
ChannelLayout
:
:
ChannelMap
mChannelMap
;
uint32_t
mBitDepth
;
int8_t
mProfile
;
int8_t
mExtendedProfile
;
RefPtr
<
MediaByteBuffer
>
mCodecSpecificConfig
;
RefPtr
<
MediaByteBuffer
>
mExtraData
;
}
;
class
EncryptionInfo
{
public
:
EncryptionInfo
(
)
:
mEncrypted
(
false
)
{
}
struct
InitData
{
template
<
typename
AInitDatas
>
InitData
(
const
nsAString
&
aType
AInitDatas
&
&
aInitData
)
:
mType
(
aType
)
mInitData
(
std
:
:
forward
<
AInitDatas
>
(
aInitData
)
)
{
}
nsString
mType
;
nsTArray
<
uint8_t
>
mInitData
;
}
;
typedef
nsTArray
<
InitData
>
InitDatas
;
bool
IsEncrypted
(
)
const
{
return
mEncrypted
;
}
void
Reset
(
)
{
mEncrypted
=
false
;
mInitDatas
.
Clear
(
)
;
}
template
<
typename
AInitDatas
>
void
AddInitData
(
const
nsAString
&
aType
AInitDatas
&
&
aInitData
)
{
mInitDatas
.
AppendElement
(
InitData
(
aType
std
:
:
forward
<
AInitDatas
>
(
aInitData
)
)
)
;
mEncrypted
=
true
;
}
void
AddInitData
(
const
EncryptionInfo
&
aInfo
)
{
mInitDatas
.
AppendElements
(
aInfo
.
mInitDatas
)
;
mEncrypted
=
!
!
mInitDatas
.
Length
(
)
;
}
InitDatas
mInitDatas
;
private
:
bool
mEncrypted
;
}
;
class
MediaInfo
{
public
:
bool
HasVideo
(
)
const
{
return
mVideo
.
IsValid
(
)
;
}
void
EnableVideo
(
)
{
if
(
HasVideo
(
)
)
{
return
;
}
mVideo
.
mDisplay
=
gfx
:
:
IntSize
(
1
1
)
;
}
bool
HasAudio
(
)
const
{
return
mAudio
.
IsValid
(
)
;
}
void
EnableAudio
(
)
{
if
(
HasAudio
(
)
)
{
return
;
}
mAudio
.
mChannels
=
2
;
mAudio
.
mRate
=
44100
;
}
bool
IsEncrypted
(
)
const
{
return
(
HasAudio
(
)
&
&
mAudio
.
mCrypto
.
IsEncrypted
(
)
)
|
|
(
HasVideo
(
)
&
&
mVideo
.
mCrypto
.
IsEncrypted
(
)
)
;
}
bool
HasValidMedia
(
)
const
{
return
HasVideo
(
)
|
|
HasAudio
(
)
;
}
void
AssertValid
(
)
const
{
NS_ASSERTION
(
!
HasAudio
(
)
|
|
mAudio
.
mTrackId
!
=
TRACK_INVALID
"
Audio
track
ID
must
be
valid
"
)
;
NS_ASSERTION
(
!
HasVideo
(
)
|
|
mVideo
.
mTrackId
!
=
TRACK_INVALID
"
Audio
track
ID
must
be
valid
"
)
;
NS_ASSERTION
(
!
HasAudio
(
)
|
|
!
HasVideo
(
)
|
|
mAudio
.
mTrackId
!
=
mVideo
.
mTrackId
"
Duplicate
track
IDs
"
)
;
}
VideoInfo
mVideo
;
AudioInfo
mAudio
;
media
:
:
NullableTimeUnit
mMetadataDuration
;
media
:
:
NullableTimeUnit
mUnadjustedMetadataEndTime
;
bool
mMediaSeekable
=
true
;
bool
mMediaSeekableOnlyInBufferedRanges
=
false
;
EncryptionInfo
mCrypto
;
media
:
:
TimeUnit
mStartTime
;
}
;
class
TrackInfoSharedPtr
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
TrackInfoSharedPtr
)
public
:
TrackInfoSharedPtr
(
const
TrackInfo
&
aOriginal
uint32_t
aStreamID
)
:
mInfo
(
aOriginal
.
Clone
(
)
)
mStreamSourceID
(
aStreamID
)
mMimeType
(
mInfo
-
>
mMimeType
)
{
}
uint32_t
GetID
(
)
const
{
return
mStreamSourceID
;
}
operator
const
TrackInfo
*
(
)
const
{
return
mInfo
.
get
(
)
;
}
const
TrackInfo
*
operator
*
(
)
const
{
return
mInfo
.
get
(
)
;
}
const
TrackInfo
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mInfo
.
get
(
)
"
dereferencing
a
UniquePtr
containing
nullptr
"
)
;
return
mInfo
.
get
(
)
;
}
const
AudioInfo
*
GetAsAudioInfo
(
)
const
{
return
mInfo
?
mInfo
-
>
GetAsAudioInfo
(
)
:
nullptr
;
}
const
VideoInfo
*
GetAsVideoInfo
(
)
const
{
return
mInfo
?
mInfo
-
>
GetAsVideoInfo
(
)
:
nullptr
;
}
const
TextInfo
*
GetAsTextInfo
(
)
const
{
return
mInfo
?
mInfo
-
>
GetAsTextInfo
(
)
:
nullptr
;
}
private
:
~
TrackInfoSharedPtr
(
)
{
}
UniquePtr
<
TrackInfo
>
mInfo
;
uint32_t
mStreamSourceID
;
public
:
const
nsCString
&
mMimeType
;
}
;
}
#
endif
