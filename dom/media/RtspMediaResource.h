#
if
!
defined
(
RtspMediaResource_h_
)
#
define
RtspMediaResource_h_
#
include
"
MediaResource
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
VideoUtils
.
h
"
namespace
mozilla
{
class
RtspTrackBuffer
;
class
RtspMediaResource
:
public
BaseMediaResource
{
public
:
RtspMediaResource
(
MediaResourceCallback
*
aCallback
nsIChannel
*
aChannel
nsIURI
*
aURI
const
nsACString
&
aContentType
)
;
virtual
~
RtspMediaResource
(
)
;
RtspMediaResource
*
GetRtspPointer
(
)
override
final
{
return
this
;
}
nsIStreamingProtocolController
*
GetMediaStreamController
(
)
{
return
mMediaStreamController
;
}
bool
IsRealTime
(
)
override
{
return
!
mHasTimestamp
;
}
void
SetSuspend
(
bool
aIsSuspend
)
;
nsresult
ReadFrameFromTrack
(
uint8_t
*
aBuffer
uint32_t
aBufferSize
uint32_t
aTrackIdx
uint32_t
&
aBytes
uint64_t
&
aTime
uint32_t
&
aFrameSize
)
;
nsresult
SeekTime
(
int64_t
aOffset
)
;
void
EnablePlayoutDelay
(
)
;
void
DisablePlayoutDelay
(
)
;
nsresult
ReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
override
{
return
NS_ERROR_FAILURE
;
}
void
SetReadMode
(
MediaCacheStream
:
:
ReadMode
aMode
)
override
{
}
void
SetPlaybackRate
(
uint32_t
aBytesPerSecond
)
override
{
}
int64_t
Tell
(
)
override
{
return
0
;
}
void
Pin
(
)
override
{
}
void
Unpin
(
)
override
{
}
bool
IsSuspendedByCache
(
)
override
{
return
mIsSuspend
;
}
bool
IsSuspended
(
)
override
{
return
false
;
}
bool
IsTransportSeekable
(
)
override
{
return
true
;
}
double
GetDownloadRate
(
bool
*
aIsReliable
)
override
{
*
aIsReliable
=
false
;
return
0
;
}
int64_t
GetLength
(
)
override
{
if
(
mIsLiveStream
)
{
return
-
1
;
}
return
0
;
}
int64_t
GetNextCachedData
(
int64_t
aOffset
)
override
{
return
0
;
}
int64_t
GetCachedDataEnd
(
int64_t
aOffset
)
override
{
return
0
;
}
bool
IsDataCachedToEndOfResource
(
int64_t
aOffset
)
override
{
return
false
;
}
nsresult
GetCachedRanges
(
MediaByteRangeSet
&
aRanges
)
override
{
return
NS_ERROR_FAILURE
;
}
nsresult
Open
(
nsIStreamListener
*
*
aStreamListener
)
override
;
nsresult
Close
(
)
override
;
void
Suspend
(
bool
aCloseImmediately
)
override
;
void
Resume
(
)
override
;
already_AddRefed
<
nsIPrincipal
>
GetCurrentPrincipal
(
)
override
;
bool
CanClone
(
)
override
{
return
false
;
}
already_AddRefed
<
MediaResource
>
CloneData
(
MediaResourceCallback
*
)
override
{
return
nullptr
;
}
nsresult
ReadFromCache
(
char
*
aBuffer
int64_t
aOffset
uint32_t
aCount
)
override
{
return
NS_ERROR_FAILURE
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
class
Listener
final
:
public
nsIInterfaceRequestor
public
nsIStreamingProtocolListener
{
~
Listener
(
)
{
}
public
:
explicit
Listener
(
RtspMediaResource
*
aResource
)
:
mResource
(
aResource
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSISTREAMINGPROTOCOLLISTENER
void
Revoke
(
)
;
private
:
RefPtr
<
RtspMediaResource
>
mResource
;
}
;
friend
class
Listener
;
protected
:
nsresult
OnMediaDataAvailable
(
uint8_t
aIndex
const
nsACString
&
aData
uint32_t
aLength
uint32_t
aOffset
nsIStreamingProtocolMetaData
*
aMeta
)
;
nsresult
OnConnected
(
uint8_t
aIndex
nsIStreamingProtocolMetaData
*
aMeta
)
;
nsresult
OnDisconnected
(
uint8_t
aIndex
nsresult
aReason
)
;
RefPtr
<
Listener
>
mListener
;
private
:
void
NotifySuspend
(
bool
aIsSuspend
)
;
bool
IsVideoEnabled
(
)
;
bool
IsVideo
(
uint8_t
tracks
nsIStreamingProtocolMetaData
*
meta
)
;
nsCOMPtr
<
nsIStreamingProtocolController
>
mMediaStreamController
;
nsTArray
<
nsAutoPtr
<
RtspTrackBuffer
>
>
mTrackBuffer
;
bool
mIsConnected
;
bool
mIsLiveStream
;
bool
mHasTimestamp
;
bool
mIsSuspend
;
}
;
}
#
endif
