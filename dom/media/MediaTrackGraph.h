#
ifndef
MOZILLA_MEDIATRACKGRAPH_H_
#
define
MOZILLA_MEDIATRACKGRAPH_H_
#
include
"
AudioStream
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
MediaSegment
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
StateWatching
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsAutoRef
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsTArray
.
h
"
#
include
<
speex
/
speex_resampler
.
h
>
class
nsIRunnable
;
class
nsIGlobalObject
;
class
nsPIDOMWindowInner
;
namespace
mozilla
{
class
AsyncLogger
;
class
AudioCaptureTrack
;
}
;
extern
mozilla
:
:
AsyncLogger
gMTGTraceLogger
;
template
<
>
class
nsAutoRefTraits
<
SpeexResamplerState
>
:
public
nsPointerRefTraits
<
SpeexResamplerState
>
{
public
:
static
void
Release
(
SpeexResamplerState
*
aState
)
{
speex_resampler_destroy
(
aState
)
;
}
}
;
namespace
mozilla
{
extern
LazyLogModule
gMediaTrackGraphLog
;
namespace
dom
{
enum
class
AudioContextOperation
;
enum
class
AudioContextOperationFlags
;
}
inline
TrackTicks
RateConvertTicksRoundDown
(
TrackRate
aOutRate
TrackRate
aInRate
TrackTicks
aTicks
)
{
MOZ_ASSERT
(
0
<
aOutRate
&
&
aOutRate
<
=
TRACK_RATE_MAX
"
Bad
out
rate
"
)
;
MOZ_ASSERT
(
0
<
aInRate
&
&
aInRate
<
=
TRACK_RATE_MAX
"
Bad
in
rate
"
)
;
MOZ_ASSERT
(
0
<
=
aTicks
&
&
aTicks
<
=
TRACK_TICKS_MAX
"
Bad
ticks
"
)
;
return
(
aTicks
*
aOutRate
)
/
aInRate
;
}
inline
TrackTicks
RateConvertTicksRoundUp
(
TrackRate
aOutRate
TrackRate
aInRate
TrackTicks
aTicks
)
{
MOZ_ASSERT
(
0
<
aOutRate
&
&
aOutRate
<
=
TRACK_RATE_MAX
"
Bad
out
rate
"
)
;
MOZ_ASSERT
(
0
<
aInRate
&
&
aInRate
<
=
TRACK_RATE_MAX
"
Bad
in
rate
"
)
;
MOZ_ASSERT
(
0
<
=
aTicks
&
&
aTicks
<
=
TRACK_TICKS_MAX
"
Bad
ticks
"
)
;
return
(
aTicks
*
aOutRate
+
aInRate
-
1
)
/
aInRate
;
}
class
AudioNodeEngine
;
class
AudioNodeExternalInputTrack
;
class
AudioNodeTrack
;
class
MediaInputPort
;
class
MediaTrack
;
class
MediaTrackGraph
;
class
MediaTrackGraphImpl
;
class
ProcessedMediaTrack
;
class
SourceMediaTrack
;
class
AudioDataListenerInterface
{
protected
:
virtual
~
AudioDataListenerInterface
(
)
=
default
;
public
:
virtual
void
NotifyOutputData
(
MediaTrackGraphImpl
*
aGraph
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
=
0
;
virtual
void
NotifyInputData
(
MediaTrackGraphImpl
*
aGraph
const
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
=
0
;
virtual
uint32_t
RequestedInputChannelCount
(
MediaTrackGraphImpl
*
aGraph
)
=
0
;
virtual
bool
IsVoiceInput
(
MediaTrackGraphImpl
*
aGraph
)
const
=
0
;
virtual
void
DeviceChanged
(
MediaTrackGraphImpl
*
aGraph
)
=
0
;
virtual
void
Disconnect
(
MediaTrackGraphImpl
*
aGraph
)
=
0
;
}
;
class
AudioDataListener
:
public
AudioDataListenerInterface
{
protected
:
virtual
~
AudioDataListener
(
)
=
default
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AudioDataListener
)
}
;
class
MainThreadMediaTrackListener
{
public
:
virtual
void
NotifyMainThreadTrackEnded
(
)
=
0
;
}
;
struct
AudioNodeSizes
{
AudioNodeSizes
(
)
:
mTrack
(
0
)
mEngine
(
0
)
mNodeType
(
)
{
}
size_t
mTrack
;
size_t
mEngine
;
const
char
*
mNodeType
;
}
;
enum
class
DisabledTrackMode
{
ENABLED
SILENCE_BLACK
SILENCE_FREEZE
}
;
class
AudioNodeEngine
;
class
AudioNodeExternalInputTrack
;
class
AudioNodeTrack
;
class
DirectMediaTrackListener
;
class
MediaInputPort
;
class
MediaTrackGraphImpl
;
class
MediaTrackListener
;
class
ProcessedMediaTrack
;
class
SourceMediaTrack
;
class
ForwardedInputTrack
;
class
MediaTrack
:
public
mozilla
:
:
LinkedListElement
<
MediaTrack
>
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaTrack
)
MediaTrack
(
TrackRate
aSampleRate
MediaSegment
:
:
Type
aType
MediaSegment
*
aSegment
)
;
const
TrackRate
mSampleRate
;
const
MediaSegment
:
:
Type
mType
;
protected
:
virtual
~
MediaTrack
(
)
;
public
:
MediaTrackGraphImpl
*
GraphImpl
(
)
;
const
MediaTrackGraphImpl
*
GraphImpl
(
)
const
;
MediaTrackGraph
*
Graph
(
)
;
const
MediaTrackGraph
*
Graph
(
)
const
;
void
SetGraphImpl
(
MediaTrackGraphImpl
*
aGraph
)
;
void
SetGraphImpl
(
MediaTrackGraph
*
aGraph
)
;
virtual
void
AddAudioOutput
(
void
*
aKey
)
;
virtual
void
SetAudioOutputVolume
(
void
*
aKey
float
aVolume
)
;
virtual
void
RemoveAudioOutput
(
void
*
aKey
)
;
virtual
void
Suspend
(
)
;
virtual
void
Resume
(
)
;
virtual
void
AddListener
(
MediaTrackListener
*
aListener
)
;
virtual
void
RemoveListener
(
MediaTrackListener
*
aListener
)
;
virtual
void
AddDirectListener
(
DirectMediaTrackListener
*
aListener
)
;
virtual
void
RemoveDirectListener
(
DirectMediaTrackListener
*
aListener
)
;
void
SetEnabled
(
DisabledTrackMode
aMode
)
;
void
AddMainThreadListener
(
MainThreadMediaTrackListener
*
aListener
)
;
void
RemoveMainThreadListener
(
MainThreadMediaTrackListener
*
aListener
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aListener
)
;
mMainThreadListeners
.
RemoveElement
(
aListener
)
;
}
void
RunAfterPendingUpdates
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
virtual
void
Destroy
(
)
;
TrackTime
GetCurrentTime
(
)
const
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
return
mMainThreadCurrentTime
;
}
bool
IsEnded
(
)
const
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
return
mMainThreadEnded
;
}
bool
IsDestroyed
(
)
const
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
return
mMainThreadDestroyed
;
}
friend
class
MediaTrackGraphImpl
;
friend
class
MediaInputPort
;
friend
class
AudioNodeExternalInputTrack
;
virtual
SourceMediaTrack
*
AsSourceTrack
(
)
{
return
nullptr
;
}
virtual
ProcessedMediaTrack
*
AsProcessedTrack
(
)
{
return
nullptr
;
}
virtual
AudioNodeTrack
*
AsAudioNodeTrack
(
)
{
return
nullptr
;
}
virtual
ForwardedInputTrack
*
AsForwardedInputTrack
(
)
{
return
nullptr
;
}
virtual
void
DestroyImpl
(
)
;
TrackTime
GetEnd
(
)
const
;
void
SetAudioOutputVolumeImpl
(
void
*
aKey
float
aVolume
)
;
void
AddAudioOutputImpl
(
void
*
aKey
)
;
void
RemoveAudioOutputImpl
(
void
*
aKey
)
;
virtual
void
RemoveAllDirectListenersImpl
(
)
{
}
void
RemoveAllResourcesAndListenersImpl
(
)
;
virtual
void
AddListenerImpl
(
already_AddRefed
<
MediaTrackListener
>
aListener
)
;
virtual
void
RemoveListenerImpl
(
MediaTrackListener
*
aListener
)
;
virtual
void
AddDirectListenerImpl
(
already_AddRefed
<
DirectMediaTrackListener
>
aListener
)
;
virtual
void
RemoveDirectListenerImpl
(
DirectMediaTrackListener
*
aListener
)
;
virtual
void
SetEnabledImpl
(
DisabledTrackMode
aMode
)
;
void
AddConsumer
(
MediaInputPort
*
aPort
)
{
mConsumers
.
AppendElement
(
aPort
)
;
}
void
RemoveConsumer
(
MediaInputPort
*
aPort
)
{
mConsumers
.
RemoveElement
(
aPort
)
;
}
GraphTime
StartTime
(
)
const
{
return
mStartTime
;
}
bool
Ended
(
)
const
{
return
mEnded
;
}
template
<
class
SegmentType
>
SegmentType
*
GetData
(
)
const
{
if
(
!
mSegment
)
{
return
nullptr
;
}
if
(
mSegment
-
>
GetType
(
)
!
=
SegmentType
:
:
StaticType
(
)
)
{
return
nullptr
;
}
return
static_cast
<
SegmentType
*
>
(
mSegment
.
get
(
)
)
;
}
MediaSegment
*
GetData
(
)
const
{
return
mSegment
.
get
(
)
;
}
double
TrackTimeToSeconds
(
TrackTime
aTime
)
const
{
NS_ASSERTION
(
0
<
=
aTime
&
&
aTime
<
=
TRACK_TIME_MAX
"
Bad
time
"
)
;
return
static_cast
<
double
>
(
aTime
)
/
mSampleRate
;
}
int64_t
TrackTimeToMicroseconds
(
TrackTime
aTime
)
const
{
NS_ASSERTION
(
0
<
=
aTime
&
&
aTime
<
=
TRACK_TIME_MAX
"
Bad
time
"
)
;
return
(
aTime
*
1000000
)
/
mSampleRate
;
}
TrackTime
SecondsToNearestTrackTime
(
double
aSeconds
)
const
{
NS_ASSERTION
(
0
<
=
aSeconds
&
&
aSeconds
<
=
TRACK_TICKS_MAX
/
TRACK_RATE_MAX
"
Bad
seconds
"
)
;
return
mSampleRate
*
aSeconds
+
0
.
5
;
}
TrackTime
MicrosecondsToTrackTimeRoundDown
(
int64_t
aMicroseconds
)
const
{
return
(
aMicroseconds
*
mSampleRate
)
/
1000000
;
}
TrackTicks
TimeToTicksRoundUp
(
TrackRate
aRate
TrackTime
aTime
)
const
{
return
RateConvertTicksRoundUp
(
aRate
mSampleRate
aTime
)
;
}
TrackTime
TicksToTimeRoundDown
(
TrackRate
aRate
TrackTicks
aTicks
)
const
{
return
RateConvertTicksRoundDown
(
mSampleRate
aRate
aTicks
)
;
}
TrackTime
GraphTimeToTrackTimeWithBlocking
(
GraphTime
aTime
)
const
;
TrackTime
GraphTimeToTrackTime
(
GraphTime
aTime
)
const
;
GraphTime
TrackTimeToGraphTime
(
TrackTime
aTime
)
const
;
virtual
void
ApplyTrackDisabling
(
MediaSegment
*
aSegment
MediaSegment
*
aRawSegment
=
nullptr
)
;
virtual
bool
MainThreadNeedsUpdates
(
)
const
{
return
true
;
}
virtual
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
virtual
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
bool
IsSuspended
(
)
const
{
return
mSuspendedCount
>
0
;
}
void
IncrementSuspendCount
(
)
;
void
DecrementSuspendCount
(
)
;
protected
:
virtual
void
NotifyForcedShutdown
(
)
{
}
virtual
void
AdvanceTimeVaryingValuesToCurrentTime
(
GraphTime
aCurrentTime
GraphTime
aBlockedTime
)
;
void
NotifyMainThreadListeners
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
for
(
int32_t
i
=
mMainThreadListeners
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
mMainThreadListeners
[
i
]
-
>
NotifyMainThreadTrackEnded
(
)
;
}
mMainThreadListeners
.
Clear
(
)
;
}
bool
ShouldNotifyTrackEnded
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Call
only
on
main
thread
"
)
;
if
(
!
mMainThreadEnded
|
|
mEndedNotificationSent
)
{
return
false
;
}
mEndedNotificationSent
=
true
;
return
true
;
}
const
UniquePtr
<
MediaSegment
>
mSegment
;
GraphTime
mStartTime
;
TrackTime
mForgottenTime
;
bool
mEnded
;
bool
mNotifiedEnded
;
struct
AudioOutput
{
explicit
AudioOutput
(
void
*
aKey
)
:
mKey
(
aKey
)
mVolume
(
1
.
0f
)
{
}
void
*
mKey
;
float
mVolume
;
}
;
nsTArray
<
AudioOutput
>
mAudioOutputs
;
nsTArray
<
RefPtr
<
MediaTrackListener
>
>
mTrackListeners
;
nsTArray
<
MainThreadMediaTrackListener
*
>
mMainThreadListeners
;
DisabledTrackMode
mDisabledMode
;
GraphTime
mStartBlocking
;
nsTArray
<
MediaInputPort
*
>
mConsumers
;
struct
AudioOutputStream
{
GraphTime
mAudioPlaybackStartTime
;
MediaTime
mBlockedAudioTime
;
TrackTime
mLastTickWritten
;
}
;
UniquePtr
<
AudioOutputStream
>
mAudioOutputStream
;
int32_t
mSuspendedCount
;
TrackTime
mMainThreadCurrentTime
;
bool
mMainThreadEnded
;
bool
mEndedNotificationSent
;
bool
mMainThreadDestroyed
;
MediaTrackGraphImpl
*
mGraph
;
}
;
class
SourceMediaTrack
:
public
MediaTrack
{
public
:
SourceMediaTrack
(
MediaSegment
:
:
Type
aType
TrackRate
aSampleRate
)
;
SourceMediaTrack
*
AsSourceTrack
(
)
override
{
return
this
;
}
void
SetPullingEnabled
(
bool
aEnabled
)
;
nsresult
OpenAudioInput
(
CubebUtils
:
:
AudioDeviceID
aID
AudioDataListener
*
aListener
)
;
void
CloseAudioInput
(
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
&
aID
)
;
void
Destroy
(
)
override
;
void
DestroyImpl
(
)
override
;
bool
PullNewData
(
GraphTime
aDesiredUpToTime
)
;
void
ExtractPendingInput
(
GraphTime
aCurrentTime
GraphTime
aDesiredUpToTime
)
;
void
SetAppendDataSourceRate
(
TrackRate
aRate
)
;
virtual
TrackTime
AppendData
(
MediaSegment
*
aSegment
MediaSegment
*
aRawSegment
=
nullptr
)
;
void
End
(
)
;
void
SetEnabledImpl
(
DisabledTrackMode
aMode
)
override
;
void
ApplyTrackDisabling
(
MediaSegment
*
aSegment
MediaSegment
*
aRawSegment
=
nullptr
)
override
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
MediaTrack
:
:
ApplyTrackDisabling
(
aSegment
aRawSegment
)
;
}
void
RemoveAllDirectListenersImpl
(
)
override
;
friend
class
MediaTrackGraphImpl
;
protected
:
enum
TrackCommands
:
uint32_t
;
virtual
~
SourceMediaTrack
(
)
;
struct
TrackData
{
TrackRate
mInputRate
;
nsAutoRef
<
SpeexResamplerState
>
mResampler
;
uint32_t
mResamplerChannelCount
;
UniquePtr
<
MediaSegment
>
mData
;
bool
mEnded
;
bool
mPullingEnabled
;
}
;
bool
NeedsMixing
(
)
;
void
ResampleAudioToGraphSampleRate
(
MediaSegment
*
aSegment
)
;
void
AddDirectListenerImpl
(
already_AddRefed
<
DirectMediaTrackListener
>
aListener
)
override
;
void
RemoveDirectListenerImpl
(
DirectMediaTrackListener
*
aListener
)
override
;
void
NotifyDirectConsumers
(
MediaSegment
*
aSegment
)
;
virtual
void
AdvanceTimeVaryingValuesToCurrentTime
(
GraphTime
aCurrentTime
GraphTime
aBlockedTime
)
override
;
RefPtr
<
AudioDataListener
>
mInputListener
;
Mutex
mMutex
;
UniquePtr
<
TrackData
>
mUpdateTrack
;
nsTArray
<
RefPtr
<
DirectMediaTrackListener
>
>
mDirectTrackListeners
;
}
;
struct
SharedDummyTrack
{
NS_INLINE_DECL_REFCOUNTING
(
SharedDummyTrack
)
explicit
SharedDummyTrack
(
MediaTrack
*
aTrack
)
:
mTrack
(
aTrack
)
{
mTrack
-
>
Suspend
(
)
;
}
const
RefPtr
<
MediaTrack
>
mTrack
;
private
:
~
SharedDummyTrack
(
)
{
mTrack
-
>
Destroy
(
)
;
}
}
;
class
MediaInputPort
final
{
private
:
MediaInputPort
(
MediaTrack
*
aSource
ProcessedMediaTrack
*
aDest
uint16_t
aInputNumber
uint16_t
aOutputNumber
)
:
mSource
(
aSource
)
mDest
(
aDest
)
mInputNumber
(
aInputNumber
)
mOutputNumber
(
aOutputNumber
)
mGraph
(
nullptr
)
{
MOZ_COUNT_CTOR
(
MediaInputPort
)
;
}
~
MediaInputPort
(
)
{
MOZ_COUNT_DTOR
(
MediaInputPort
)
;
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaInputPort
)
void
Init
(
)
;
void
Disconnect
(
)
;
void
Destroy
(
)
;
MediaTrack
*
GetSource
(
)
const
{
return
mSource
;
}
ProcessedMediaTrack
*
GetDestination
(
)
const
{
return
mDest
;
}
uint16_t
InputNumber
(
)
const
{
return
mInputNumber
;
}
uint16_t
OutputNumber
(
)
const
{
return
mOutputNumber
;
}
struct
InputInterval
{
GraphTime
mStart
;
GraphTime
mEnd
;
bool
mInputIsBlocked
;
}
;
static
InputInterval
GetNextInputInterval
(
MediaInputPort
const
*
aPort
GraphTime
aTime
)
;
MediaTrackGraphImpl
*
GraphImpl
(
)
;
MediaTrackGraph
*
Graph
(
)
;
void
SetGraphImpl
(
MediaTrackGraphImpl
*
aGraph
)
;
void
Suspended
(
)
;
void
Resumed
(
)
;
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
0
;
return
amount
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
private
:
friend
class
MediaTrackGraphImpl
;
friend
class
MediaTrack
;
friend
class
ProcessedMediaTrack
;
MediaTrack
*
mSource
;
ProcessedMediaTrack
*
mDest
;
const
uint16_t
mInputNumber
;
const
uint16_t
mOutputNumber
;
MediaTrackGraphImpl
*
mGraph
;
}
;
class
ProcessedMediaTrack
:
public
MediaTrack
{
public
:
ProcessedMediaTrack
(
TrackRate
aSampleRate
MediaSegment
:
:
Type
aType
MediaSegment
*
aSegment
)
:
MediaTrack
(
aSampleRate
aType
aSegment
)
mAutoend
(
true
)
mCycleMarker
(
0
)
{
}
already_AddRefed
<
MediaInputPort
>
AllocateInputPort
(
MediaTrack
*
aTrack
uint16_t
aInputNumber
=
0
uint16_t
aOutputNumber
=
0
)
;
void
QueueSetAutoend
(
bool
aAutoend
)
;
ProcessedMediaTrack
*
AsProcessedTrack
(
)
override
{
return
this
;
}
friend
class
MediaTrackGraphImpl
;
virtual
void
AddInput
(
MediaInputPort
*
aPort
)
;
virtual
void
RemoveInput
(
MediaInputPort
*
aPort
)
{
mInputs
.
RemoveElement
(
aPort
)
|
|
mSuspendedInputs
.
RemoveElement
(
aPort
)
;
}
bool
HasInputPort
(
MediaInputPort
*
aPort
)
const
{
return
mInputs
.
Contains
(
aPort
)
|
|
mSuspendedInputs
.
Contains
(
aPort
)
;
}
uint32_t
InputPortCount
(
)
const
{
return
mInputs
.
Length
(
)
+
mSuspendedInputs
.
Length
(
)
;
}
void
InputSuspended
(
MediaInputPort
*
aPort
)
;
void
InputResumed
(
MediaInputPort
*
aPort
)
;
void
DestroyImpl
(
)
override
;
enum
{
ALLOW_END
=
0x01
}
;
virtual
void
ProcessInput
(
GraphTime
aFrom
GraphTime
aTo
uint32_t
aFlags
)
=
0
;
void
SetAutoendImpl
(
bool
aAutoend
)
{
mAutoend
=
aAutoend
;
}
bool
InMutedCycle
(
)
const
{
return
mCycleMarker
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
size_t
amount
=
MediaTrack
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
mInputs
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
amount
+
=
mSuspendedInputs
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
amount
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
protected
:
nsTArray
<
MediaInputPort
*
>
mInputs
;
nsTArray
<
MediaInputPort
*
>
mSuspendedInputs
;
bool
mAutoend
;
uint32_t
mCycleMarker
;
}
;
class
MediaTrackGraph
{
public
:
enum
GraphDriverType
{
AUDIO_THREAD_DRIVER
SYSTEM_THREAD_DRIVER
OFFLINE_THREAD_DRIVER
}
;
enum
GraphRunType
{
DIRECT_DRIVER
SINGLE_THREAD
}
;
static
const
uint32_t
AUDIO_CALLBACK_DRIVER_SHUTDOWN_TIMEOUT
=
20
*
1000
;
static
const
TrackRate
REQUEST_DEFAULT_SAMPLE_RATE
=
0
;
static
MediaTrackGraph
*
GetInstanceIfExists
(
nsPIDOMWindowInner
*
aWindow
TrackRate
aSampleRate
)
;
static
MediaTrackGraph
*
GetInstance
(
GraphDriverType
aGraphDriverRequested
nsPIDOMWindowInner
*
aWindow
TrackRate
aSampleRate
)
;
static
MediaTrackGraph
*
CreateNonRealtimeInstance
(
TrackRate
aSampleRate
nsPIDOMWindowInner
*
aWindowId
)
;
AbstractThread
*
AbstractMainThread
(
)
;
static
void
DestroyNonRealtimeInstance
(
MediaTrackGraph
*
aGraph
)
;
virtual
nsresult
OpenAudioInput
(
CubebUtils
:
:
AudioDeviceID
aID
AudioDataListener
*
aListener
)
=
0
;
virtual
void
CloseAudioInput
(
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
&
aID
AudioDataListener
*
aListener
)
=
0
;
SourceMediaTrack
*
CreateSourceTrack
(
MediaSegment
:
:
Type
aType
)
;
ProcessedMediaTrack
*
CreateForwardedInputTrack
(
MediaSegment
:
:
Type
aType
)
;
AudioCaptureTrack
*
CreateAudioCaptureTrack
(
)
;
void
AddTrack
(
MediaTrack
*
aTrack
)
;
void
NotifyWhenGraphStarted
(
AudioNodeTrack
*
aNodeTrack
)
;
void
ApplyAudioContextOperation
(
MediaTrack
*
aDestinationTrack
const
nsTArray
<
MediaTrack
*
>
&
aTracks
dom
:
:
AudioContextOperation
aState
void
*
aPromise
dom
:
:
AudioContextOperationFlags
aFlags
)
;
bool
IsNonRealtime
(
)
const
;
void
StartNonRealtimeProcessing
(
uint32_t
aTicksToProcess
)
;
void
DispatchToMainThreadStableState
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
TrackRate
GraphRate
(
)
const
{
return
mSampleRate
;
}
double
AudioOutputLatency
(
)
;
void
RegisterCaptureTrackForWindow
(
uint64_t
aWindowId
ProcessedMediaTrack
*
aCaptureTrack
)
;
void
UnregisterCaptureTrackForWindow
(
uint64_t
aWindowId
)
;
already_AddRefed
<
MediaInputPort
>
ConnectToCaptureTrack
(
uint64_t
aWindowId
MediaTrack
*
aMediaTrack
)
;
void
AssertOnGraphThreadOrNotRunning
(
)
const
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
}
virtual
Watchable
<
GraphTime
>
&
CurrentTime
(
)
=
0
;
protected
:
explicit
MediaTrackGraph
(
TrackRate
aSampleRate
)
:
mSampleRate
(
aSampleRate
)
{
MOZ_COUNT_CTOR
(
MediaTrackGraph
)
;
}
virtual
~
MediaTrackGraph
(
)
{
MOZ_COUNT_DTOR
(
MediaTrackGraph
)
;
}
virtual
bool
OnGraphThreadOrNotRunning
(
)
const
=
0
;
virtual
bool
OnGraphThread
(
)
const
=
0
;
virtual
bool
Destroyed
(
)
const
=
0
;
const
TrackRate
mSampleRate
;
}
;
}
#
endif
