#
include
"
ImageContainer
.
h
"
#
include
"
MediaFormatReader
.
h
"
#
include
"
MockDecoderModule
.
h
"
#
include
"
MockMediaDataDemuxer
.
h
"
#
include
"
MockMediaDecoderOwner
.
h
"
#
include
"
PDMFactory
.
h
"
#
include
"
ReaderProxy
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
VideoFrameContainer
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
gtest
/
MozAssertions
.
h
"
#
include
"
mozilla
/
gtest
/
WaitFor
.
h
"
#
include
"
nsQueryObject
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layers
;
using
DecodePromise
=
MediaDataDecoder
:
:
DecodePromise
;
using
SamplesHolder
=
MediaTrackDemuxer
:
:
SamplesHolder
;
using
SamplesPromise
=
MediaTrackDemuxer
:
:
SamplesPromise
;
using
SeekPromise
=
MediaTrackDemuxer
:
:
SeekPromise
;
using
TrackType
=
TrackInfo
:
:
TrackType
;
using
media
:
:
TimeIntervals
;
using
media
:
:
TimeUnit
;
using
testing
:
:
InSequence
;
using
testing
:
:
MockFunction
;
using
testing
:
:
Return
;
using
testing
:
:
StrEq
;
TEST
(
TestMediaFormatReader
WaitingForDemuxAfterInternalSeek
)
{
RefPtr
<
MediaFormatReader
>
reader
;
RefPtr
<
TaskQueue
>
demuxerThread
;
RefPtr
<
TaskQueue
>
decoderThread
;
auto
WaitForReaderOperations
=
[
&
]
(
int
aCount
)
{
MOZ_ASSERT
(
!
demuxerThread
-
>
SupportsTailDispatch
(
)
)
;
MOZ_ASSERT
(
!
decoderThread
-
>
SupportsTailDispatch
(
)
)
;
reader
-
>
OwnerThread
(
)
-
>
AwaitIdle
(
)
;
for
(
int
i
=
0
;
i
<
aCount
;
+
+
i
)
{
demuxerThread
-
>
AwaitIdle
(
)
;
decoderThread
-
>
AwaitIdle
(
)
;
reader
-
>
OwnerThread
(
)
-
>
AwaitIdle
(
)
;
}
}
;
RefPtr
dataDemuxer
=
new
MockMediaDataDemuxer
(
)
;
RefPtr
trackDemuxer
=
new
MockMediaTrackDemuxer
(
"
video
/
x
-
test
;
width
=
640
;
height
=
360
"
)
;
ON_CALL
(
*
dataDemuxer
GetNumberTracks
(
TrackType
:
:
kVideoTrack
)
)
.
WillByDefault
(
Return
(
1
)
)
;
ON_CALL
(
*
dataDemuxer
GetTrackDemuxer
)
.
WillByDefault
(
[
&
]
(
TrackType
aType
uint32_t
aTrackNumber
)
{
EXPECT_EQ
(
aTrackNumber
0u
)
;
EXPECT_EQ
(
aType
TrackType
:
:
kVideoTrack
)
;
if
(
!
demuxerThread
)
{
demuxerThread
=
do_QueryObject
(
AbstractThread
:
:
GetCurrent
(
)
)
;
}
return
do_AddRef
(
trackDemuxer
)
;
}
)
;
RefPtr
pdm
=
new
MockDecoderModule
(
)
;
PDMFactory
:
:
AutoForcePDM
autoForcePDM
(
pdm
)
;
RefPtr
<
MockVideoDataDecoder
>
decoder
;
MozPromiseHolder
<
DecodePromise
>
drainPromise
;
EXPECT_CALL
(
*
pdm
CreateVideoDecoder
)
.
WillOnce
(
[
&
]
(
const
CreateDecoderParams
&
aParams
)
{
decoder
=
new
MockVideoDataDecoder
(
aParams
)
;
InSequence
s
;
EXPECT_CALL
(
*
decoder
Drain
)
.
WillOnce
(
[
&
]
{
MOZ_ASSERT
(
!
decoderThread
)
;
decoderThread
=
do_QueryObject
(
AbstractThread
:
:
GetCurrent
(
)
)
;
return
decoder
-
>
DummyMediaDataDecoder
:
:
Drain
(
)
;
}
)
;
EXPECT_CALL
(
*
decoder
Drain
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
decoder
Drain
)
.
WillOnce
(
[
&
]
{
return
drainPromise
.
Ensure
(
__func__
)
;
}
)
;
decoder
-
>
SetLatencyFrameCount
(
8
)
;
return
do_AddRef
(
decoder
)
;
}
)
;
MockFunction
<
void
(
const
char
*
name
)
>
checkpoint
;
{
InSequence
s
;
EXPECT_CALL
(
*
trackDemuxer
MockGetSamples
)
.
Times
(
2
)
.
WillRepeatedly
(
[
]
(
)
{
static
int
count
=
0
;
RefPtr
sample
=
new
MediaRawData
;
sample
-
>
mTime
=
TimeUnit
(
count
30
)
;
+
+
count
;
RefPtr
<
SamplesHolder
>
samples
=
new
SamplesHolder
;
samples
-
>
AppendSample
(
std
:
:
move
(
sample
)
)
;
return
SamplesPromise
:
:
CreateAndResolve
(
samples
__func__
)
;
}
)
;
EXPECT_CALL
(
*
trackDemuxer
MockGetSamples
)
.
WillOnce
(
[
]
(
)
{
return
SamplesPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA
__func__
)
;
}
)
;
EXPECT_CALL
(
*
trackDemuxer
Seek
)
.
WillOnce
(
[
&
]
(
const
TimeUnit
&
aTime
)
{
EXPECT_NS_SUCCEEDED
(
reader
-
>
OwnerThread
(
)
-
>
Dispatch
(
NewRunnableMethod
(
"
NotifyDataArrived
"
reader
.
get
(
)
&
MediaFormatReader
:
:
NotifyDataArrived
)
)
)
;
return
SeekPromise
:
:
CreateAndResolve
(
TimeUnit
:
:
Zero
(
)
__func__
)
;
}
)
;
EXPECT_CALL
(
*
trackDemuxer
MockGetSamples
)
.
WillOnce
(
[
]
(
)
{
RefPtr
sample
=
new
MediaRawData
;
sample
-
>
mTime
=
TimeUnit
(
0
30
)
;
RefPtr
<
SamplesHolder
>
samples
=
new
SamplesHolder
;
samples
-
>
AppendSample
(
std
:
:
move
(
sample
)
)
;
return
SamplesPromise
:
:
CreateAndResolve
(
samples
__func__
)
;
}
)
;
EXPECT_CALL
(
*
trackDemuxer
MockGetSamples
)
.
WillOnce
(
[
]
(
)
{
return
SamplesPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA
__func__
)
;
}
)
;
EXPECT_CALL
(
checkpoint
Call
(
StrEq
(
"
Internal
seek
waiting
for
data
"
)
)
)
;
EXPECT_CALL
(
*
trackDemuxer
MockGetSamples
)
.
WillRepeatedly
(
[
]
(
)
{
return
SamplesPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA
__func__
)
;
}
)
;
}
auto
owner
=
std
:
:
make_unique
<
MockMediaDecoderOwner
>
(
)
;
RefPtr
container
=
new
VideoFrameContainer
(
owner
.
get
(
)
MakeAndAddRef
<
ImageContainer
>
(
ImageUsageType
:
:
VideoFrameContainer
#
ifdef
MOZ_WIDGET_ANDROID
ImageContainer
:
:
SYNCHRONOUS
#
else
ImageContainer
:
:
ASYNCHRONOUS
#
endif
)
)
;
MediaFormatReaderInit
init
;
init
.
mVideoFrameContainer
=
container
;
reader
=
new
MediaFormatReader
(
init
dataDemuxer
)
;
RefPtr
proxy
=
new
ReaderProxy
(
AbstractThread
:
:
MainThread
(
)
reader
)
;
EXPECT_NS_SUCCEEDED
(
reader
-
>
Init
(
)
)
;
(
void
)
WaitForResolve
(
proxy
-
>
ReadMetadata
(
)
)
;
for
(
int
i
=
0
;
i
<
2
;
+
+
i
)
{
(
void
)
WaitForResolve
(
proxy
-
>
RequestVideoData
(
TimeUnit
(
)
false
)
)
;
}
MediaResult
result
=
WaitForReject
(
proxy
-
>
RequestVideoData
(
TimeUnit
(
)
false
)
)
;
EXPECT_EQ
(
result
.
Code
(
)
NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA
)
;
WaitForReaderOperations
(
5
)
;
checkpoint
.
Call
(
"
Internal
seek
waiting
for
data
"
)
;
MOZ_ASSERT
(
!
drainPromise
.
IsEmpty
(
)
)
;
(
void
)
proxy
-
>
RequestVideoData
(
TimeUnit
(
)
false
)
;
EXPECT_NS_SUCCEEDED
(
reader
-
>
OwnerThread
(
)
-
>
Dispatch
(
NewRunnableMethod
(
"
NotifyDataArrived
"
reader
.
get
(
)
&
MediaFormatReader
:
:
NotifyDataArrived
)
)
)
;
WaitForReaderOperations
(
2
)
;
WaitForResolve
(
proxy
-
>
Shutdown
(
)
)
;
drainPromise
.
Reject
(
NS_ERROR_ILLEGAL_DURING_SHUTDOWN
__func__
)
;
}
