#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
AudioGenerator
.
h
"
#
include
"
MediaEngineWebRTCAudio
.
h
"
#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
PrincipalHandle
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsTArray
.
h
"
using
namespace
mozilla
;
using
testing
:
:
NiceMock
;
using
testing
:
:
Return
;
class
MockGraph
:
public
MediaTrackGraphImpl
{
public
:
MockGraph
(
TrackRate
aRate
uint32_t
aChannels
)
:
MediaTrackGraphImpl
(
OFFLINE_THREAD_DRIVER
DIRECT_DRIVER
aRate
aChannels
nullptr
AbstractThread
:
:
MainThread
(
)
)
{
ON_CALL
(
*
this
OnGraphThread
)
.
WillByDefault
(
Return
(
true
)
)
;
SetCurrentDriver
(
nullptr
)
;
}
MOCK_CONST_METHOD0
(
OnGraphThread
bool
(
)
)
;
protected
:
~
MockGraph
(
)
=
default
;
}
;
TEST
(
TestAudioInputProcessing
Buffering
)
{
const
TrackRate
rate
=
8000
;
const
uint32_t
channels
=
1
;
auto
graph
=
MakeRefPtr
<
NiceMock
<
MockGraph
>
>
(
rate
channels
)
;
auto
aip
=
MakeRefPtr
<
AudioInputProcessing
>
(
channels
)
;
const
size_t
frames
=
72
;
AudioGenerator
<
AudioDataValue
>
generator
(
channels
rate
)
;
GraphTime
processedTime
;
GraphTime
nextTime
;
AudioSegment
output
;
{
EXPECT_EQ
(
aip
-
>
PassThrough
(
graph
)
false
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
aip
-
>
SetPassThrough
(
graph
true
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
aip
-
>
SetPassThrough
(
graph
false
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
aip
-
>
SetPassThrough
(
graph
true
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
}
{
processedTime
=
0
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
graph
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
}
aip
-
>
SetPassThrough
(
graph
false
)
;
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
2
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
graph
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
}
aip
-
>
Start
(
graph
)
;
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
3
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
graph
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
80
)
;
}
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
4
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
graph
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
32
)
;
}
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
5
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
graph
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
32
)
;
}
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
6
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
graph
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
64
)
;
}
aip
-
>
SetPassThrough
(
graph
true
)
;
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
7
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
graph
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
processedTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
}
aip
-
>
Stop
(
graph
)
;
graph
-
>
Destroy
(
)
;
}
TEST
(
TestAudioInputProcessing
ProcessDataWithDifferentPrincipals
)
{
const
TrackRate
rate
=
48000
;
const
uint32_t
channels
=
2
;
auto
graph
=
MakeRefPtr
<
NiceMock
<
MockGraph
>
>
(
rate
channels
)
;
auto
aip
=
MakeRefPtr
<
AudioInputProcessing
>
(
channels
)
;
AudioGenerator
<
AudioDataValue
>
generator
(
channels
rate
)
;
RefPtr
<
nsIPrincipal
>
dummy_principal
=
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
const
PrincipalHandle
principal1
=
MakePrincipalHandle
(
dummy_principal
.
get
(
)
)
;
const
PrincipalHandle
principal2
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
nsTArray
<
std
:
:
pair
<
TrackTime
PrincipalHandle
>
>
framesWithPrincipal
=
{
{
100
principal1
}
{
200
PRINCIPAL_HANDLE_NONE
}
{
300
principal2
}
{
400
principal1
}
{
440
PRINCIPAL_HANDLE_NONE
}
{
480
principal1
}
{
480
principal2
}
{
480
PRINCIPAL_HANDLE_NONE
}
{
500
principal2
}
{
490
principal1
}
{
600
principal1
}
{
330
principal1
}
}
;
AudioSegment
input
;
{
for
(
const
auto
&
[
duration
principal
]
:
framesWithPrincipal
)
{
AudioSegment
data
;
generator
.
Generate
(
data
duration
)
;
for
(
AudioSegment
:
:
ChunkIterator
it
(
data
)
;
!
it
.
IsEnded
(
)
;
it
.
Next
(
)
)
{
it
-
>
mPrincipalHandle
=
principal
;
}
input
.
AppendFrom
(
&
data
)
;
}
}
auto
verifyPrincipals
=
[
&
]
(
const
AudioSegment
&
data
)
{
TrackTime
start
=
0
;
for
(
const
auto
&
[
duration
principal
]
:
framesWithPrincipal
)
{
const
TrackTime
end
=
start
+
duration
;
AudioSegment
slice
;
slice
.
AppendSlice
(
data
start
end
)
;
start
=
end
;
for
(
AudioSegment
:
:
ChunkIterator
it
(
slice
)
;
!
it
.
IsEnded
(
)
;
it
.
Next
(
)
)
{
EXPECT_EQ
(
it
-
>
mPrincipalHandle
principal
)
;
}
}
}
;
EXPECT_EQ
(
aip
-
>
PassThrough
(
graph
)
false
)
;
aip
-
>
Start
(
graph
)
;
{
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
480
)
;
AudioSegment
output
;
{
AudioSegment
data
;
aip
-
>
Process
(
graph
0
4800
&
input
&
data
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
4800
)
;
EXPECT_EQ
(
data
.
GetDuration
(
)
4800
)
;
AudioSegment
dummy
;
dummy
.
AppendNullData
(
480
)
;
aip
-
>
Process
(
graph
0
480
&
dummy
&
data
)
;
EXPECT_EQ
(
dummy
.
GetDuration
(
)
480
)
;
EXPECT_EQ
(
data
.
GetDuration
(
)
480
+
4800
)
;
output
.
AppendSlice
(
data
480
480
+
4800
)
;
}
verifyPrincipals
(
output
)
;
}
aip
-
>
SetPassThrough
(
graph
true
)
;
{
AudioSegment
output
;
aip
-
>
Process
(
graph
0
4800
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
4800
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
4800
)
;
verifyPrincipals
(
output
)
;
}
aip
-
>
Stop
(
graph
)
;
graph
-
>
Destroy
(
)
;
}
