#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
AudioGenerator
.
h
"
#
include
"
MediaEngineWebRTCAudio
.
h
"
#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsTArray
.
h
"
using
namespace
mozilla
;
using
testing
:
:
NiceMock
;
using
testing
:
:
Return
;
class
MockGraph
:
public
MediaTrackGraphImpl
{
public
:
MockGraph
(
TrackRate
aRate
uint32_t
aChannels
)
:
MediaTrackGraphImpl
(
OFFLINE_THREAD_DRIVER
DIRECT_DRIVER
aRate
aChannels
nullptr
AbstractThread
:
:
MainThread
(
)
)
{
ON_CALL
(
*
this
OnGraphThread
)
.
WillByDefault
(
Return
(
true
)
)
;
SetCurrentDriver
(
nullptr
)
;
}
MOCK_CONST_METHOD0
(
OnGraphThread
bool
(
)
)
;
protected
:
~
MockGraph
(
)
=
default
;
}
;
TEST
(
TestAudioInputProcessing
UnaccountedPacketizerBuffering
)
{
const
TrackRate
rate
=
48000
;
const
uint32_t
channels
=
2
;
auto
graph
=
MakeRefPtr
<
NiceMock
<
MockGraph
>
>
(
48000
2
)
;
auto
aip
=
MakeRefPtr
<
AudioInputProcessing
>
(
channels
PRINCIPAL_HANDLE_NONE
)
;
AudioGenerator
<
AudioDataValue
>
generator
(
channels
rate
)
;
const
size_t
nrFrames
=
440
;
const
size_t
bufferSize
=
nrFrames
*
channels
;
GraphTime
processedTime
;
GraphTime
nextTime
;
nsTArray
<
AudioDataValue
>
buffer
(
bufferSize
)
;
buffer
.
AppendElements
(
bufferSize
)
;
AudioSegment
segment
;
bool
ended
;
aip
-
>
Start
(
)
;
{
processedTime
=
0
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
nrFrames
)
;
generator
.
GenerateInterleaved
(
buffer
.
Elements
(
)
nrFrames
)
;
aip
-
>
NotifyInputData
(
graph
AudioInputProcessing
:
:
BufferInfo
{
buffer
.
Elements
(
)
nrFrames
channels
rate
}
nextTime
-
nrFrames
)
;
aip
-
>
Pull
(
graph
processedTime
nextTime
segment
.
GetDuration
(
)
&
segment
true
&
ended
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
24U
)
;
}
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
2
*
nrFrames
)
;
generator
.
GenerateInterleaved
(
buffer
.
Elements
(
)
nrFrames
)
;
aip
-
>
NotifyInputData
(
graph
AudioInputProcessing
:
:
BufferInfo
{
buffer
.
Elements
(
)
nrFrames
channels
rate
}
nextTime
-
(
2
*
nrFrames
)
)
;
aip
-
>
Pull
(
graph
processedTime
nextTime
segment
.
GetDuration
(
)
&
segment
true
&
ended
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
120U
)
;
}
graph
-
>
Destroy
(
)
;
}
