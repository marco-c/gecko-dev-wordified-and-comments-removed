#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
AudioGenerator
.
h
"
#
include
"
MediaEngineWebRTCAudio
.
h
"
#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsTArray
.
h
"
using
namespace
mozilla
;
using
testing
:
:
NiceMock
;
using
testing
:
:
Return
;
class
MockGraph
:
public
MediaTrackGraphImpl
{
public
:
MockGraph
(
TrackRate
aRate
uint32_t
aChannels
)
:
MediaTrackGraphImpl
(
OFFLINE_THREAD_DRIVER
DIRECT_DRIVER
aRate
aChannels
nullptr
AbstractThread
:
:
MainThread
(
)
)
{
ON_CALL
(
*
this
OnGraphThread
)
.
WillByDefault
(
Return
(
true
)
)
;
SetCurrentDriver
(
nullptr
)
;
}
MOCK_CONST_METHOD0
(
OnGraphThread
bool
(
)
)
;
protected
:
~
MockGraph
(
)
=
default
;
}
;
TEST
(
TestAudioInputProcessing
Buffering
)
{
const
TrackRate
rate
=
8000
;
const
uint32_t
channels
=
1
;
auto
graph
=
MakeRefPtr
<
NiceMock
<
MockGraph
>
>
(
rate
channels
)
;
auto
aip
=
MakeRefPtr
<
AudioInputProcessing
>
(
channels
PRINCIPAL_HANDLE_NONE
)
;
const
size_t
frames
=
72
;
AudioGenerator
<
AudioDataValue
>
generator
(
channels
rate
)
;
GraphTime
processedTime
;
GraphTime
nextTime
;
AudioSegment
output
;
{
EXPECT_EQ
(
aip
-
>
PassThrough
(
graph
)
false
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
aip
-
>
SetPassThrough
(
graph
true
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
aip
-
>
SetPassThrough
(
graph
false
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
aip
-
>
SetPassThrough
(
graph
true
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
}
{
processedTime
=
0
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
graph
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
}
aip
-
>
SetPassThrough
(
graph
false
)
;
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
2
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
graph
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
}
aip
-
>
Start
(
graph
)
;
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
3
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
graph
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
80
)
;
}
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
4
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
graph
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
32
)
;
}
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
5
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
graph
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
32
)
;
}
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
6
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
graph
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
64
)
;
}
aip
-
>
SetPassThrough
(
graph
true
)
;
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
7
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
graph
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
processedTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
}
aip
-
>
Stop
(
graph
)
;
graph
-
>
Destroy
(
)
;
}
