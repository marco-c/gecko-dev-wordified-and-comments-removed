#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
AudioGenerator
.
h
"
#
include
"
MediaEngineWebRTCAudio
.
h
"
#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsTArray
.
h
"
using
namespace
mozilla
;
using
testing
:
:
NiceMock
;
using
testing
:
:
Return
;
class
MockGraph
:
public
MediaTrackGraphImpl
{
public
:
MockGraph
(
TrackRate
aRate
uint32_t
aChannels
)
:
MediaTrackGraphImpl
(
OFFLINE_THREAD_DRIVER
DIRECT_DRIVER
aRate
aChannels
nullptr
AbstractThread
:
:
MainThread
(
)
)
{
ON_CALL
(
*
this
OnGraphThread
)
.
WillByDefault
(
Return
(
true
)
)
;
SetCurrentDriver
(
nullptr
)
;
}
MOCK_CONST_METHOD0
(
OnGraphThread
bool
(
)
)
;
protected
:
~
MockGraph
(
)
=
default
;
}
;
TEST
(
TestAudioInputProcessing
UnaccountedPacketizerBuffering
)
{
const
TrackRate
rate
=
48000
;
const
uint32_t
channels
=
2
;
auto
graph
=
MakeRefPtr
<
NiceMock
<
MockGraph
>
>
(
48000
2
)
;
auto
aip
=
MakeRefPtr
<
AudioInputProcessing
>
(
channels
PRINCIPAL_HANDLE_NONE
)
;
AudioGenerator
<
AudioDataValue
>
generator
(
channels
rate
)
;
const
size_t
nrFrames
=
440
;
const
size_t
bufferSize
=
nrFrames
*
channels
;
GraphTime
processedTime
;
GraphTime
nextTime
;
nsTArray
<
AudioDataValue
>
buffer
(
bufferSize
)
;
buffer
.
AppendElements
(
bufferSize
)
;
AudioSegment
segment
;
bool
ended
;
aip
-
>
Start
(
)
;
{
processedTime
=
0
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
nrFrames
)
;
generator
.
GenerateInterleaved
(
buffer
.
Elements
(
)
nrFrames
)
;
aip
-
>
NotifyInputData
(
graph
buffer
.
Elements
(
)
nrFrames
rate
channels
nextTime
-
nrFrames
)
;
aip
-
>
ProcessInput
(
graph
nullptr
)
;
aip
-
>
Pull
(
graph
processedTime
nextTime
segment
.
GetDuration
(
)
&
segment
true
&
ended
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
24U
)
;
}
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
2
*
nrFrames
)
;
generator
.
GenerateInterleaved
(
buffer
.
Elements
(
)
nrFrames
)
;
aip
-
>
NotifyInputData
(
graph
buffer
.
Elements
(
)
nrFrames
rate
channels
nextTime
-
(
2
*
nrFrames
)
)
;
aip
-
>
ProcessInput
(
graph
nullptr
)
;
aip
-
>
Pull
(
graph
processedTime
nextTime
segment
.
GetDuration
(
)
&
segment
true
&
ended
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
120U
)
;
}
graph
-
>
Destroy
(
)
;
}
TEST
(
TestAudioInputProcessing
InputDataCapture
)
{
const
TrackRate
rate
=
8000
;
const
uint32_t
channels
=
1
;
auto
graph
=
MakeRefPtr
<
NiceMock
<
MockGraph
>
>
(
rate
channels
)
;
auto
aip
=
MakeRefPtr
<
AudioInputProcessing
>
(
channels
PRINCIPAL_HANDLE_NONE
)
;
AudioGenerator
<
AudioDataValue
>
generator
(
channels
rate
)
;
const
size_t
frames
=
72
;
const
size_t
bufferSize
=
frames
*
channels
;
nsTArray
<
AudioDataValue
>
buffer
(
bufferSize
)
;
buffer
.
AppendElements
(
bufferSize
)
;
GraphTime
processedTime
;
GraphTime
nextTime
;
AudioSegment
segment
;
bool
ended
;
aip
-
>
Start
(
)
;
{
const
TrackTime
bufferedFrames
=
80U
;
processedTime
=
0
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
frames
)
;
generator
.
GenerateInterleaved
(
buffer
.
Elements
(
)
frames
)
;
aip
-
>
NotifyInputData
(
graph
buffer
.
Elements
(
)
frames
rate
channels
0
)
;
buffer
.
ClearAndRetainStorage
(
)
;
aip
-
>
ProcessInput
(
graph
nullptr
)
;
aip
-
>
Pull
(
graph
processedTime
nextTime
segment
.
GetDuration
(
)
&
segment
true
&
ended
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
bufferedFrames
)
;
}
{
const
TrackTime
bufferedFrames
=
32U
;
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
2
*
frames
)
;
generator
.
GenerateInterleaved
(
buffer
.
Elements
(
)
frames
)
;
aip
-
>
NotifyInputData
(
graph
buffer
.
Elements
(
)
frames
rate
channels
0
)
;
buffer
.
ClearAndRetainStorage
(
)
;
aip
-
>
ProcessInput
(
graph
nullptr
)
;
aip
-
>
Pull
(
graph
processedTime
nextTime
segment
.
GetDuration
(
)
&
segment
true
&
ended
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
bufferedFrames
)
;
}
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
3
*
frames
)
;
generator
.
GenerateInterleaved
(
buffer
.
Elements
(
)
frames
)
;
aip
-
>
NotifyInputData
(
graph
buffer
.
Elements
(
)
frames
rate
channels
0
)
;
Unused
<
<
processedTime
;
buffer
.
ClearAndRetainStorage
(
)
;
}
{
const
TrackTime
bufferedFrames
=
64U
;
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
4
*
frames
)
;
generator
.
GenerateInterleaved
(
buffer
.
Elements
(
)
frames
)
;
aip
-
>
NotifyInputData
(
graph
buffer
.
Elements
(
)
frames
rate
channels
0
)
;
buffer
.
ClearAndRetainStorage
(
)
;
aip
-
>
ProcessInput
(
graph
nullptr
)
;
aip
-
>
Pull
(
graph
processedTime
nextTime
segment
.
GetDuration
(
)
&
segment
true
&
ended
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
bufferedFrames
)
;
}
graph
-
>
Destroy
(
)
;
}
TEST
(
TestAudioInputProcessing
InputDataCapturePassThrough
)
{
const
TrackRate
rate
=
8000
;
const
uint32_t
channels
=
1
;
auto
graph
=
MakeRefPtr
<
NiceMock
<
MockGraph
>
>
(
rate
channels
)
;
auto
aip
=
MakeRefPtr
<
AudioInputProcessing
>
(
channels
PRINCIPAL_HANDLE_NONE
)
;
AudioGenerator
<
AudioDataValue
>
generator
(
channels
rate
)
;
const
size_t
frames
=
72
;
const
size_t
bufferSize
=
frames
*
channels
;
nsTArray
<
AudioDataValue
>
buffer
(
bufferSize
)
;
buffer
.
AppendElements
(
bufferSize
)
;
GraphTime
processedTime
;
GraphTime
nextTime
;
AudioSegment
segment
;
AudioSegment
source
;
bool
ended
;
aip
-
>
SetPassThrough
(
graph
true
)
;
aip
-
>
Start
(
)
;
{
const
TrackTime
bufferedFrames
=
72U
;
processedTime
=
0
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
frames
)
;
generator
.
GenerateInterleaved
(
buffer
.
Elements
(
)
frames
)
;
source
.
AppendFromInterleavedBuffer
(
buffer
.
Elements
(
)
frames
channels
PRINCIPAL_HANDLE_NONE
)
;
aip
-
>
NotifyInputData
(
graph
buffer
.
Elements
(
)
frames
rate
channels
0
)
;
buffer
.
ClearAndRetainStorage
(
)
;
aip
-
>
ProcessInput
(
graph
&
source
)
;
aip
-
>
Pull
(
graph
processedTime
nextTime
segment
.
GetDuration
(
)
&
segment
true
&
ended
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
bufferedFrames
)
;
source
.
Clear
(
)
;
}
{
const
TrackTime
bufferedFrames
=
16U
;
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
2
*
frames
)
;
generator
.
GenerateInterleaved
(
buffer
.
Elements
(
)
frames
)
;
source
.
AppendFromInterleavedBuffer
(
buffer
.
Elements
(
)
frames
channels
PRINCIPAL_HANDLE_NONE
)
;
aip
-
>
NotifyInputData
(
graph
buffer
.
Elements
(
)
frames
rate
channels
0
)
;
buffer
.
ClearAndRetainStorage
(
)
;
aip
-
>
ProcessInput
(
graph
&
source
)
;
aip
-
>
Pull
(
graph
processedTime
nextTime
segment
.
GetDuration
(
)
&
segment
true
&
ended
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
bufferedFrames
)
;
source
.
Clear
(
)
;
}
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
3
*
frames
)
;
generator
.
GenerateInterleaved
(
buffer
.
Elements
(
)
frames
)
;
source
.
AppendFromInterleavedBuffer
(
buffer
.
Elements
(
)
frames
channels
PRINCIPAL_HANDLE_NONE
)
;
aip
-
>
NotifyInputData
(
graph
buffer
.
Elements
(
)
frames
rate
channels
0
)
;
Unused
<
<
processedTime
;
buffer
.
ClearAndRetainStorage
(
)
;
}
{
const
TrackTime
bufferedFrames
=
32U
;
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
4
*
frames
)
;
generator
.
GenerateInterleaved
(
buffer
.
Elements
(
)
frames
)
;
source
.
AppendFromInterleavedBuffer
(
buffer
.
Elements
(
)
frames
channels
PRINCIPAL_HANDLE_NONE
)
;
aip
-
>
NotifyInputData
(
graph
buffer
.
Elements
(
)
frames
rate
channels
0
)
;
buffer
.
ClearAndRetainStorage
(
)
;
aip
-
>
ProcessInput
(
graph
&
source
)
;
aip
-
>
Pull
(
graph
processedTime
nextTime
segment
.
GetDuration
(
)
&
segment
true
&
ended
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
bufferedFrames
)
;
source
.
Clear
(
)
;
}
graph
-
>
Destroy
(
)
;
}
