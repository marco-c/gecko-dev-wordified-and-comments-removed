#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
AudioGenerator
.
h
"
#
include
"
MediaEngineWebRTCAudio
.
h
"
#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
PrincipalHandle
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsTArray
.
h
"
using
namespace
mozilla
;
using
testing
:
:
NiceMock
;
using
testing
:
:
Return
;
class
MockGraph
:
public
MediaTrackGraphImpl
{
public
:
explicit
MockGraph
(
TrackRate
aRate
)
:
MediaTrackGraphImpl
(
0
aRate
nullptr
AbstractThread
:
:
MainThread
(
)
)
{
ON_CALL
(
*
this
OnGraphThread
)
.
WillByDefault
(
Return
(
true
)
)
;
}
void
Init
(
uint32_t
aChannels
)
{
MediaTrackGraphImpl
:
:
Init
(
OFFLINE_THREAD_DRIVER
DIRECT_DRIVER
aChannels
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
mLifecycleState
=
LIFECYCLE_WAITING_FOR_TRACK_DESTRUCTION
;
#
ifdef
DEBUG
mCanRunMessagesSynchronously
=
true
;
#
endif
mDriver
=
nullptr
;
}
MOCK_CONST_METHOD0
(
OnGraphThread
bool
(
)
)
;
protected
:
~
MockGraph
(
)
=
default
;
}
;
TEST
(
TestAudioInputProcessing
Buffering
)
{
const
TrackRate
rate
=
8000
;
const
uint32_t
channels
=
1
;
auto
graph
=
MakeRefPtr
<
NiceMock
<
MockGraph
>
>
(
rate
)
;
graph
-
>
Init
(
channels
)
;
RefPtr
track
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
auto
aip
=
MakeRefPtr
<
AudioInputProcessing
>
(
channels
)
;
const
size_t
frames
=
72
;
AudioGenerator
<
AudioDataValue
>
generator
(
channels
rate
)
;
GraphTime
processedTime
;
GraphTime
nextTime
;
AudioSegment
output
;
MediaEnginePrefs
settings
;
settings
.
mChannels
=
channels
;
settings
.
mAgc2Forced
=
true
;
{
EXPECT_EQ
(
aip
-
>
IsPassThrough
(
graph
)
true
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
settings
.
mAgcOn
=
true
;
aip
-
>
ApplySettings
(
graph
nullptr
settings
)
;
EXPECT_EQ
(
aip
-
>
IsPassThrough
(
graph
)
false
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
settings
.
mAgcOn
=
false
;
aip
-
>
ApplySettings
(
graph
nullptr
settings
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
}
{
processedTime
=
0
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
track
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
}
settings
.
mAgcOn
=
true
;
aip
-
>
ApplySettings
(
graph
nullptr
settings
)
;
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
2
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
track
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
}
aip
-
>
Start
(
graph
)
;
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
3
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
track
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
}
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
4
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
track
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
32
)
;
}
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
5
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
track
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
32
)
;
}
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
6
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
track
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
64
)
;
}
settings
.
mAgcOn
=
false
;
aip
-
>
ApplySettings
(
graph
nullptr
settings
)
;
{
processedTime
=
nextTime
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
7
*
frames
)
;
AudioSegment
input
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
track
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
processedTime
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
0
)
;
}
aip
-
>
Stop
(
graph
)
;
track
-
>
Destroy
(
)
;
}
TEST
(
TestAudioInputProcessing
ProcessDataWithDifferentPrincipals
)
{
const
TrackRate
rate
=
48000
;
const
uint32_t
channels
=
2
;
auto
graph
=
MakeRefPtr
<
NiceMock
<
MockGraph
>
>
(
rate
)
;
graph
-
>
Init
(
channels
)
;
RefPtr
track
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
auto
aip
=
MakeRefPtr
<
AudioInputProcessing
>
(
channels
)
;
AudioGenerator
<
AudioDataValue
>
generator
(
channels
rate
)
;
RefPtr
<
nsIPrincipal
>
dummy_principal
=
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
const
PrincipalHandle
principal1
=
MakePrincipalHandle
(
dummy_principal
.
get
(
)
)
;
const
PrincipalHandle
principal2
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
nsTArray
<
std
:
:
pair
<
TrackTime
PrincipalHandle
>
>
framesWithPrincipal
=
{
{
100
principal1
}
{
200
PRINCIPAL_HANDLE_NONE
}
{
300
principal2
}
{
400
principal1
}
{
440
PRINCIPAL_HANDLE_NONE
}
{
480
principal1
}
{
480
principal2
}
{
480
PRINCIPAL_HANDLE_NONE
}
{
500
principal2
}
{
490
principal1
}
{
600
principal1
}
{
330
principal1
}
}
;
AudioSegment
input
;
{
for
(
const
auto
&
[
duration
principal
]
:
framesWithPrincipal
)
{
AudioSegment
data
;
generator
.
Generate
(
data
duration
)
;
for
(
AudioSegment
:
:
ChunkIterator
it
(
data
)
;
!
it
.
IsEnded
(
)
;
it
.
Next
(
)
)
{
it
-
>
mPrincipalHandle
=
principal
;
}
input
.
AppendFrom
(
&
data
)
;
}
}
auto
verifyPrincipals
=
[
&
]
(
const
AudioSegment
&
data
)
{
TrackTime
start
=
0
;
for
(
const
auto
&
[
duration
principal
]
:
framesWithPrincipal
)
{
const
TrackTime
end
=
start
+
duration
;
AudioSegment
slice
;
slice
.
AppendSlice
(
data
start
end
)
;
start
=
end
;
for
(
AudioSegment
:
:
ChunkIterator
it
(
slice
)
;
!
it
.
IsEnded
(
)
;
it
.
Next
(
)
)
{
EXPECT_EQ
(
it
-
>
mPrincipalHandle
principal
)
;
}
}
}
;
MediaEnginePrefs
settings
;
settings
.
mChannels
=
channels
;
settings
.
mAgcOn
=
true
;
settings
.
mAgc2Forced
=
true
;
aip
-
>
ApplySettings
(
graph
nullptr
settings
)
;
EXPECT_EQ
(
aip
-
>
IsPassThrough
(
graph
)
false
)
;
aip
-
>
Start
(
graph
)
;
{
AudioSegment
output
;
{
AudioSegment
data
;
aip
-
>
Process
(
track
0
4800
&
input
&
data
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
4800
)
;
EXPECT_EQ
(
data
.
GetDuration
(
)
4800
)
;
EXPECT_EQ
(
aip
-
>
NumBufferedFrames
(
graph
)
480
)
;
AudioSegment
dummy
;
dummy
.
AppendNullData
(
480
)
;
aip
-
>
Process
(
track
0
480
&
dummy
&
data
)
;
EXPECT_EQ
(
dummy
.
GetDuration
(
)
480
)
;
EXPECT_EQ
(
data
.
GetDuration
(
)
480
+
4800
)
;
output
.
AppendSlice
(
data
480
480
+
4800
)
;
}
verifyPrincipals
(
output
)
;
}
settings
.
mAgcOn
=
false
;
aip
-
>
ApplySettings
(
graph
nullptr
settings
)
;
EXPECT_EQ
(
aip
-
>
IsPassThrough
(
graph
)
true
)
;
{
AudioSegment
output
;
aip
-
>
Process
(
track
0
4800
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
4800
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
4800
)
;
verifyPrincipals
(
output
)
;
}
aip
-
>
Stop
(
graph
)
;
track
-
>
Destroy
(
)
;
}
TEST
(
TestAudioInputProcessing
Downmixing
)
{
const
TrackRate
rate
=
44100
;
const
uint32_t
channels
=
4
;
auto
graph
=
MakeRefPtr
<
NiceMock
<
MockGraph
>
>
(
rate
)
;
graph
-
>
Init
(
channels
)
;
RefPtr
track
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
auto
aip
=
MakeRefPtr
<
AudioInputProcessing
>
(
channels
)
;
const
size_t
frames
=
44100
;
AudioGenerator
<
AudioDataValue
>
generator
(
channels
rate
)
;
GraphTime
processedTime
;
GraphTime
nextTime
;
MediaEnginePrefs
settings
;
settings
.
mChannels
=
channels
;
settings
.
mAgcOn
=
true
;
settings
.
mAgc2Forced
=
true
;
aip
-
>
ApplySettings
(
graph
nullptr
settings
)
;
EXPECT_EQ
(
aip
-
>
IsPassThrough
(
graph
)
false
)
;
aip
-
>
Start
(
graph
)
;
processedTime
=
0
;
nextTime
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
frames
)
;
{
AudioSegment
input
;
AudioSegment
output
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
input
.
ApplyVolume
(
0
.
9
)
;
aip
-
>
Process
(
track
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
)
;
EXPECT_EQ
(
output
.
MaxChannelCount
(
)
1u
)
;
for
(
AudioSegment
:
:
ChunkIterator
iterOutput
(
output
)
;
!
iterOutput
.
IsEnded
(
)
;
iterOutput
.
Next
(
)
)
{
const
float
*
const
output
=
iterOutput
-
>
ChannelData
<
float
>
(
)
[
0
]
;
for
(
uint32_t
i
=
0
;
i
<
iterOutput
-
>
GetDuration
(
)
;
i
+
+
)
{
EXPECT_LE
(
std
:
:
abs
(
output
[
i
]
)
0
.
95
)
;
}
}
}
settings
.
mAgcOn
=
false
;
aip
-
>
ApplySettings
(
graph
nullptr
settings
)
;
EXPECT_EQ
(
aip
-
>
IsPassThrough
(
graph
)
true
)
;
AudioSegment
input
output
;
processedTime
=
nextTime
;
nextTime
+
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
frames
)
;
generator
.
Generate
(
input
nextTime
-
processedTime
)
;
aip
-
>
Process
(
track
processedTime
nextTime
&
input
&
output
)
;
EXPECT_EQ
(
input
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
GetDuration
(
)
nextTime
-
processedTime
)
;
EXPECT_EQ
(
output
.
MaxChannelCount
(
)
4u
)
;
nsTArray
<
AudioDataValue
>
inputLinearized
outputLinearized
;
input
.
WriteToInterleavedBuffer
(
inputLinearized
input
.
MaxChannelCount
(
)
)
;
output
.
WriteToInterleavedBuffer
(
outputLinearized
output
.
MaxChannelCount
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
frames
*
channels
;
i
+
+
)
{
EXPECT_EQ
(
inputLinearized
[
i
]
outputLinearized
[
i
]
)
;
}
aip
-
>
Stop
(
graph
)
;
track
-
>
Destroy
(
)
;
}
TEST
(
TestAudioInputProcessing
DisabledPlatformProcessing
)
{
const
TrackRate
rate
=
44100
;
const
uint32_t
channels
=
1
;
auto
graph
=
MakeRefPtr
<
NiceMock
<
MockGraph
>
>
(
rate
)
;
graph
-
>
Init
(
channels
)
;
auto
aip
=
MakeRefPtr
<
AudioInputProcessing
>
(
channels
)
;
MediaEnginePrefs
settings
;
settings
.
mUsePlatformProcessing
=
false
;
settings
.
mAecOn
=
true
;
aip
-
>
ApplySettings
(
graph
nullptr
settings
)
;
aip
-
>
Start
(
graph
)
;
EXPECT_EQ
(
aip
-
>
RequestedInputProcessingParams
(
graph
)
CUBEB_INPUT_PROCESSING_PARAM_NONE
)
;
aip
-
>
Stop
(
graph
)
;
graph
-
>
Destroy
(
)
;
}
TEST
(
TestAudioInputProcessing
EnabledPlatformProcessing
)
{
const
TrackRate
rate
=
44100
;
const
uint32_t
channels
=
1
;
auto
graph
=
MakeRefPtr
<
NiceMock
<
MockGraph
>
>
(
rate
)
;
graph
-
>
Init
(
channels
)
;
auto
aip
=
MakeRefPtr
<
AudioInputProcessing
>
(
channels
)
;
MediaEnginePrefs
settings
;
settings
.
mUsePlatformProcessing
=
true
;
settings
.
mAecOn
=
true
;
aip
-
>
ApplySettings
(
graph
nullptr
settings
)
;
aip
-
>
Start
(
graph
)
;
EXPECT_EQ
(
aip
-
>
RequestedInputProcessingParams
(
graph
)
CUBEB_INPUT_PROCESSING_PARAM_ECHO_CANCELLATION
)
;
aip
-
>
Stop
(
graph
)
;
graph
-
>
Destroy
(
)
;
}
namespace
webrtc
{
bool
operator
=
=
(
const
AudioProcessing
:
:
Config
&
aLhs
const
AudioProcessing
:
:
Config
&
aRhs
)
{
return
aLhs
.
echo_canceller
.
enabled
=
=
aRhs
.
echo_canceller
.
enabled
&
&
(
aLhs
.
gain_controller1
.
enabled
=
=
aRhs
.
gain_controller1
.
enabled
|
|
aLhs
.
gain_controller2
.
enabled
=
=
aRhs
.
gain_controller2
.
enabled
)
&
&
aLhs
.
noise_suppression
.
enabled
=
=
aRhs
.
noise_suppression
.
enabled
;
}
static
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
webrtc
:
:
AudioProcessing
:
:
Config
&
aConfig
)
{
aStream
<
<
"
webrtc
:
:
AudioProcessing
:
:
Config
[
"
;
bool
hadPrior
=
false
;
if
(
aConfig
.
echo_canceller
.
enabled
)
{
aStream
<
<
"
AEC
"
;
hadPrior
=
true
;
}
if
(
aConfig
.
gain_controller1
.
enabled
|
|
aConfig
.
gain_controller2
.
enabled
)
{
if
(
hadPrior
)
{
aStream
<
<
"
"
;
}
aStream
<
<
"
AGC
"
;
}
if
(
aConfig
.
noise_suppression
.
enabled
)
{
if
(
hadPrior
)
{
aStream
<
<
"
"
;
}
aStream
<
<
"
NS
"
;
}
aStream
<
<
"
]
"
;
return
aStream
;
}
}
TEST
(
TestAudioInputProcessing
PlatformProcessing
)
{
const
TrackRate
rate
=
44100
;
const
uint32_t
channels
=
1
;
auto
graph
=
MakeRefPtr
<
NiceMock
<
MockGraph
>
>
(
rate
)
;
graph
-
>
Init
(
channels
)
;
auto
aip
=
MakeRefPtr
<
AudioInputProcessing
>
(
channels
)
;
MediaEnginePrefs
settings
;
settings
.
mUsePlatformProcessing
=
true
;
settings
.
mAecOn
=
true
;
aip
-
>
ApplySettings
(
graph
nullptr
settings
)
;
aip
-
>
Start
(
graph
)
;
webrtc
:
:
AudioProcessing
:
:
Config
echoOnlyConfig
;
echoOnlyConfig
.
echo_canceller
.
enabled
=
true
;
webrtc
:
:
AudioProcessing
:
:
Config
echoNoiseConfig
=
echoOnlyConfig
;
echoNoiseConfig
.
noise_suppression
.
enabled
=
true
;
EXPECT_EQ
(
aip
-
>
RequestedInputProcessingParams
(
graph
)
CUBEB_INPUT_PROCESSING_PARAM_ECHO_CANCELLATION
)
;
EXPECT_EQ
(
aip
-
>
AppliedConfig
(
graph
)
echoOnlyConfig
)
;
EXPECT_FALSE
(
aip
-
>
IsPassThrough
(
graph
)
)
;
aip
-
>
NotifySetRequestedInputProcessingParamsResult
(
graph
CUBEB_INPUT_PROCESSING_PARAM_ECHO_CANCELLATION
CUBEB_INPUT_PROCESSING_PARAM_ECHO_CANCELLATION
)
;
EXPECT_EQ
(
aip
-
>
AppliedConfig
(
graph
)
webrtc
:
:
AudioProcessing
:
:
Config
(
)
)
;
EXPECT_TRUE
(
aip
-
>
IsPassThrough
(
graph
)
)
;
aip
-
>
NotifySetRequestedInputProcessingParamsResult
(
graph
CUBEB_INPUT_PROCESSING_PARAM_ECHO_CANCELLATION
Err
(
CUBEB_ERROR
)
)
;
EXPECT_EQ
(
aip
-
>
RequestedInputProcessingParams
(
graph
)
CUBEB_INPUT_PROCESSING_PARAM_NONE
)
;
EXPECT_EQ
(
aip
-
>
AppliedConfig
(
graph
)
echoOnlyConfig
)
;
EXPECT_FALSE
(
aip
-
>
IsPassThrough
(
graph
)
)
;
aip
-
>
NotifySetRequestedInputProcessingParamsResult
(
graph
CUBEB_INPUT_PROCESSING_PARAM_ECHO_CANCELLATION
CUBEB_INPUT_PROCESSING_PARAM_ECHO_CANCELLATION
)
;
EXPECT_EQ
(
aip
-
>
RequestedInputProcessingParams
(
graph
)
CUBEB_INPUT_PROCESSING_PARAM_NONE
)
;
EXPECT_EQ
(
aip
-
>
AppliedConfig
(
graph
)
echoOnlyConfig
)
;
EXPECT_FALSE
(
aip
-
>
IsPassThrough
(
graph
)
)
;
aip
-
>
NotifySetRequestedInputProcessingParamsResult
(
graph
CUBEB_INPUT_PROCESSING_PARAM_NONE
CUBEB_INPUT_PROCESSING_PARAM_NONE
)
;
EXPECT_EQ
(
aip
-
>
RequestedInputProcessingParams
(
graph
)
CUBEB_INPUT_PROCESSING_PARAM_NONE
)
;
EXPECT_EQ
(
aip
-
>
AppliedConfig
(
graph
)
echoOnlyConfig
)
;
EXPECT_FALSE
(
aip
-
>
IsPassThrough
(
graph
)
)
;
settings
.
mNoiseOn
=
true
;
aip
-
>
ApplySettings
(
graph
nullptr
settings
)
;
EXPECT_EQ
(
aip
-
>
RequestedInputProcessingParams
(
graph
)
CUBEB_INPUT_PROCESSING_PARAM_ECHO_CANCELLATION
|
CUBEB_INPUT_PROCESSING_PARAM_NOISE_SUPPRESSION
)
;
EXPECT_EQ
(
aip
-
>
AppliedConfig
(
graph
)
echoNoiseConfig
)
;
EXPECT_FALSE
(
aip
-
>
IsPassThrough
(
graph
)
)
;
aip
-
>
NotifySetRequestedInputProcessingParamsResult
(
graph
CUBEB_INPUT_PROCESSING_PARAM_ECHO_CANCELLATION
|
CUBEB_INPUT_PROCESSING_PARAM_NOISE_SUPPRESSION
CUBEB_INPUT_PROCESSING_PARAM_NOISE_SUPPRESSION
)
;
EXPECT_EQ
(
aip
-
>
AppliedConfig
(
graph
)
echoOnlyConfig
)
;
EXPECT_FALSE
(
aip
-
>
IsPassThrough
(
graph
)
)
;
aip
-
>
NotifySetRequestedInputProcessingParamsResult
(
graph
CUBEB_INPUT_PROCESSING_PARAM_ECHO_CANCELLATION
|
CUBEB_INPUT_PROCESSING_PARAM_NOISE_SUPPRESSION
Err
(
CUBEB_ERROR
)
)
;
EXPECT_EQ
(
aip
-
>
RequestedInputProcessingParams
(
graph
)
CUBEB_INPUT_PROCESSING_PARAM_NONE
)
;
EXPECT_EQ
(
aip
-
>
AppliedConfig
(
graph
)
echoNoiseConfig
)
;
EXPECT_FALSE
(
aip
-
>
IsPassThrough
(
graph
)
)
;
aip
-
>
Stop
(
graph
)
;
graph
-
>
Destroy
(
)
;
}
