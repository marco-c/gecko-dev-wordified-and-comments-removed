#
include
"
AudioSink
.
h
"
#
include
"
AudioSinkWrapper
.
h
"
#
include
"
CubebUtils
.
h
"
#
include
"
MockCubeb
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
-
printers
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
gtest
/
WaitFor
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
namespace
mozilla
;
TEST
(
TestAudioSinkWrapper
AsyncInitFailureWithSyncInitSuccess
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaQueue
<
AudioData
>
audioQueue
;
MediaInfo
info
;
info
.
EnableAudio
(
)
;
auto
audioSinkCreator
=
[
&
]
(
)
{
return
UniquePtr
<
AudioSink
>
{
new
AudioSink
(
AbstractThread
:
:
GetCurrent
(
)
audioQueue
info
.
mAudio
false
)
}
;
}
;
const
double
initialVolume
=
0
.
0
;
RefPtr
wrapper
=
new
AudioSinkWrapper
(
AbstractThread
:
:
GetCurrent
(
)
audioQueue
std
:
:
move
(
audioSinkCreator
)
initialVolume
1
.
0
true
nullptr
)
;
wrapper
-
>
Start
(
media
:
:
TimeUnit
:
:
Zero
(
)
info
)
;
RefPtr
backgroundQueue
=
nsThreadManager
:
:
get
(
)
.
CreateBackgroundTaskQueue
(
__func__
)
;
Monitor
monitor
(
__func__
)
;
bool
initDone
=
false
;
MediaEventListener
initListener
=
cubeb
-
>
StreamInitEvent
(
)
.
Connect
(
backgroundQueue
[
&
]
(
RefPtr
<
SmartMockCubebStream
>
aStream
)
{
EXPECT_EQ
(
aStream
nullptr
)
;
MonitorAutoLock
lock
(
monitor
)
;
initDone
=
true
;
lock
.
Notify
(
)
;
}
)
;
cubeb
-
>
ForceStreamInitError
(
)
;
wrapper
-
>
SetVolume
(
0
.
5
)
;
{
MonitorAutoLock
lock
(
monitor
)
;
while
(
!
initDone
)
{
lock
.
Wait
(
)
;
}
}
initListener
.
Disconnect
(
)
;
wrapper
-
>
SetPlaying
(
false
)
;
nsIThread
*
currentThread
=
NS_GetCurrentThread
(
)
;
RefPtr
<
SmartMockCubebStream
>
stream
;
initListener
=
cubeb
-
>
StreamInitEvent
(
)
.
Connect
(
currentThread
[
&
]
(
RefPtr
<
SmartMockCubebStream
>
aStream
)
{
stream
=
std
:
:
move
(
aStream
)
;
}
)
;
wrapper
-
>
SetPlaying
(
true
)
;
NS_ProcessPendingEvents
(
currentThread
)
;
initListener
.
Disconnect
(
)
;
cubeb_state
state
=
CUBEB_STATE_STARTED
;
MediaEventListener
stateListener
=
stream
-
>
StateEvent
(
)
.
Connect
(
currentThread
[
&
]
(
cubeb_state
aState
)
{
state
=
aState
;
}
)
;
audioQueue
.
Finish
(
)
;
SpinEventLoopUntil
(
"
stream
state
change
"
_ns
[
&
]
{
return
state
!
=
CUBEB_STATE_STARTED
;
}
)
;
stateListener
.
Disconnect
(
)
;
EXPECT_EQ
(
state
CUBEB_STATE_DRAINED
)
;
wrapper
-
>
Stop
(
)
;
wrapper
-
>
Shutdown
(
)
;
}
TEST
(
TestAudioSinkWrapper
AsyncInitWithEndOfAudio
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaQueue
<
AudioData
>
audioQueue
;
MediaInfo
info
;
info
.
EnableAudio
(
)
;
auto
audioSinkCreator
=
[
&
]
(
)
{
return
UniquePtr
<
AudioSink
>
{
new
AudioSink
(
AbstractThread
:
:
GetCurrent
(
)
audioQueue
info
.
mAudio
false
)
}
;
}
;
const
double
initialVolume
=
0
.
0
;
RefPtr
wrapper
=
new
AudioSinkWrapper
(
AbstractThread
:
:
GetCurrent
(
)
audioQueue
std
:
:
move
(
audioSinkCreator
)
initialVolume
1
.
0
true
nullptr
)
;
wrapper
-
>
Start
(
media
:
:
TimeUnit
:
:
Zero
(
)
info
)
;
RefPtr
backgroundQueue
=
nsThreadManager
:
:
get
(
)
.
CreateBackgroundTaskQueue
(
__func__
)
;
Monitor
monitor
(
__func__
)
;
RefPtr
<
SmartMockCubebStream
>
stream
;
MediaEventListener
initListener
=
cubeb
-
>
StreamInitEvent
(
)
.
Connect
(
backgroundQueue
[
&
]
(
RefPtr
<
SmartMockCubebStream
>
aStream
)
{
EXPECT_NE
(
aStream
nullptr
)
;
MonitorAutoLock
lock
(
monitor
)
;
stream
=
std
:
:
move
(
aStream
)
;
lock
.
Notify
(
)
;
}
)
;
wrapper
-
>
SetVolume
(
0
.
5
)
;
{
MonitorAutoLock
lock
(
monitor
)
;
while
(
!
stream
)
{
lock
.
Wait
(
)
;
}
}
initListener
.
Disconnect
(
)
;
audioQueue
.
Finish
(
)
;
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
wrapper
-
>
Stop
(
)
;
wrapper
-
>
Shutdown
(
)
;
}
