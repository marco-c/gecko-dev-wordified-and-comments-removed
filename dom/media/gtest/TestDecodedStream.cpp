#
include
"
BlankDecoderModule
.
h
"
#
include
"
DecodedStream
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
MediaQueue
.
h
"
#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
MediaTrackListener
.
h
"
#
include
"
MockCubeb
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
gtest
/
WaitFor
.
h
"
#
include
"
nsJSEnvironment
.
h
"
using
mozilla
:
:
media
:
:
TimeUnit
;
using
testing
:
:
Test
;
namespace
mozilla
{
#
define
DispatchFunction
(
f
)
\
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
__func__
f
)
)
enum
MediaType
{
Audio
=
1
Video
=
2
AudioVideo
=
Audio
|
Video
}
;
template
<
MediaType
Type
>
CopyableTArray
<
RefPtr
<
ProcessedMediaTrack
>
>
CreateOutputTracks
(
MediaTrackGraphImpl
*
aGraph
)
{
CopyableTArray
<
RefPtr
<
ProcessedMediaTrack
>
>
outputTracks
;
if
constexpr
(
Type
&
Audio
)
{
outputTracks
.
AppendElement
(
aGraph
-
>
CreateForwardedInputTrack
(
MediaSegment
:
:
AUDIO
)
)
;
}
if
constexpr
(
Type
&
Video
)
{
outputTracks
.
AppendElement
(
aGraph
-
>
CreateForwardedInputTrack
(
MediaSegment
:
:
VIDEO
)
)
;
}
return
outputTracks
;
}
template
<
MediaType
Type
>
MediaInfo
CreateMediaInfo
(
)
{
MediaInfo
info
;
info
.
mStartTime
=
TimeUnit
:
:
Zero
(
)
;
if
constexpr
(
Type
&
Audio
)
{
info
.
EnableAudio
(
)
;
}
if
constexpr
(
Type
&
Video
)
{
info
.
EnableVideo
(
)
;
}
return
info
;
}
class
OnFallbackListener
:
public
MediaTrackListener
{
const
RefPtr
<
MediaTrack
>
mTrack
;
Atomic
<
bool
>
mOnFallback
{
true
}
;
public
:
explicit
OnFallbackListener
(
MediaTrack
*
aTrack
)
:
mTrack
(
aTrack
)
{
}
void
Reset
(
)
{
mOnFallback
=
true
;
}
bool
OnFallback
(
)
{
return
mOnFallback
;
}
void
NotifyOutput
(
MediaTrackGraph
*
TrackTime
)
override
{
if
(
auto
*
ad
=
mTrack
-
>
GraphImpl
(
)
-
>
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
{
mOnFallback
=
ad
-
>
OnFallback
(
)
;
}
}
}
;
class
TestableDecodedStream
:
public
DecodedStream
{
public
:
TestableDecodedStream
(
AbstractThread
*
aOwnerThread
nsMainThreadPtrHandle
<
SharedDummyTrack
>
aDummyTrack
CopyableTArray
<
RefPtr
<
ProcessedMediaTrack
>
>
aOutputTracks
AbstractCanonical
<
PrincipalHandle
>
*
aCanonicalOutputPrincipal
double
aVolume
double
aPlaybackRate
bool
aPreservesPitch
MediaQueue
<
AudioData
>
&
aAudioQueue
MediaQueue
<
VideoData
>
&
aVideoQueue
)
:
DecodedStream
(
aOwnerThread
std
:
:
move
(
aDummyTrack
)
std
:
:
move
(
aOutputTracks
)
aCanonicalOutputPrincipal
aVolume
aPlaybackRate
aPreservesPitch
aAudioQueue
aVideoQueue
)
{
}
using
DecodedStream
:
:
GetPositionImpl
;
using
DecodedStream
:
:
LastOutputSystemTime
;
}
;
template
<
MediaType
Type
>
class
TestDecodedStream
:
public
Test
{
public
:
static
constexpr
TrackRate
kRate
=
48000
;
static
constexpr
uint32_t
kChannels
=
2
;
const
RefPtr
<
MockCubeb
>
mMockCubeb
;
RefPtr
<
SmartMockCubebStream
>
mMockCubebStream
;
MediaQueue
<
AudioData
>
mAudioQueue
;
MediaQueue
<
VideoData
>
mVideoQueue
;
RefPtr
<
MediaTrackGraphImpl
>
mGraph
;
nsMainThreadPtrHandle
<
SharedDummyTrack
>
mDummyTrack
;
CopyableTArray
<
RefPtr
<
ProcessedMediaTrack
>
>
mOutputTracks
;
Canonical
<
PrincipalHandle
>
mCanonicalOutputPrincipal
;
RefPtr
<
TestableDecodedStream
>
mDecodedStream
;
TestDecodedStream
(
)
:
mMockCubeb
(
MakeRefPtr
<
MockCubeb
>
(
MockCubeb
:
:
RunningMode
:
:
Manual
)
)
mGraph
(
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
kRate
nullptr
GetMainThreadSerialEventTarget
(
)
)
)
mDummyTrack
(
new
nsMainThreadPtrHolder
<
SharedDummyTrack
>
(
__func__
new
SharedDummyTrack
(
mGraph
-
>
CreateSourceTrack
(
MediaSegment
:
:
AUDIO
)
)
)
)
mOutputTracks
(
CreateOutputTracks
<
Type
>
(
mGraph
)
)
mCanonicalOutputPrincipal
(
AbstractThread
:
:
GetCurrent
(
)
PRINCIPAL_HANDLE_NONE
"
TestDecodedStream
:
:
mCanonicalOutputPrincipal
"
)
mDecodedStream
(
MakeRefPtr
<
TestableDecodedStream
>
(
AbstractThread
:
:
GetCurrent
(
)
mDummyTrack
mOutputTracks
&
mCanonicalOutputPrincipal
1
.
0
1
.
0
true
mAudioQueue
mVideoQueue
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
;
void
SetUp
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
CubebUtils
:
:
ForceSetCubebContext
(
mMockCubeb
-
>
AsCubebContext
(
)
)
;
for
(
const
auto
&
track
:
mOutputTracks
)
{
track
-
>
QueueSetAutoend
(
false
)
;
}
mDummyTrack
-
>
mTrack
-
>
Resume
(
)
;
RefPtr
fallbackListener
=
new
OnFallbackListener
(
mDummyTrack
-
>
mTrack
)
;
mDummyTrack
-
>
mTrack
-
>
AddListener
(
fallbackListener
)
;
mMockCubebStream
=
WaitFor
(
mMockCubeb
-
>
StreamInitEvent
(
)
)
;
while
(
mMockCubebStream
-
>
State
(
)
.
isNothing
(
)
)
{
std
:
:
this_thread
:
:
sleep_for
(
std
:
:
chrono
:
:
milliseconds
(
1
)
)
;
}
ASSERT_EQ
(
*
mMockCubebStream
-
>
State
(
)
CUBEB_STATE_STARTED
)
;
while
(
fallbackListener
-
>
OnFallback
(
)
)
{
ASSERT_EQ
(
mMockCubebStream
-
>
ManualDataCallback
(
1
)
MockCubebStream
:
:
KeepProcessing
:
:
Yes
)
;
std
:
:
this_thread
:
:
sleep_for
(
std
:
:
chrono
:
:
milliseconds
(
1
)
)
;
}
}
void
TearDown
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mDecodedStream
-
>
Shutdown
(
)
;
for
(
const
auto
&
t
:
mOutputTracks
)
{
t
-
>
Destroy
(
)
;
}
mDummyTrack
=
nullptr
;
mDecodedStream
=
nullptr
;
MockCubebStream
:
:
KeepProcessing
keepProcessing
{
}
;
while
(
(
keepProcessing
=
mMockCubebStream
-
>
ManualDataCallback
(
0
)
)
=
=
MockCubebStream
:
:
KeepProcessing
:
:
Yes
)
{
NS_ProcessPendingEvents
(
nullptr
)
;
}
ASSERT_EQ
(
keepProcessing
MockCubebStream
:
:
KeepProcessing
:
:
No
)
;
NS_ProcessPendingEvents
(
nullptr
)
;
NS_ProcessPendingEvents
(
nullptr
)
;
ASSERT_TRUE
(
mGraph
-
>
OnGraphThreadOrNotRunning
(
)
)
<
<
"
Not
on
graph
thread
so
graph
must
still
be
running
!
"
;
ASSERT_EQ
(
mGraph
-
>
LifecycleStateRef
(
)
MediaTrackGraphImpl
:
:
LIFECYCLE_WAITING_FOR_THREAD_SHUTDOWN
)
<
<
"
The
graph
should
be
in
its
final
state
.
Note
it
does
not
advance
"
"
the
state
any
further
on
thread
shutdown
.
"
;
CubebUtils
:
:
ForceSetCubebContext
(
nullptr
)
;
MediaTrackGraphImpl
*
graph
{
}
;
mGraph
.
forget
(
&
graph
)
;
int32_t
refcnt
=
static_cast
<
int32_t
>
(
graph
-
>
Release
(
)
)
;
EXPECT_LE
(
refcnt
1
)
;
nsJSContext
:
:
CycleCollectNow
(
CCReason
:
:
API
)
;
nsJSContext
:
:
GarbageCollectNow
(
JS
:
:
GCReason
:
:
API
)
;
NS_ProcessPendingEvents
(
nullptr
)
;
}
MediaInfo
CreateMediaInfo
(
)
{
return
mozilla
:
:
CreateMediaInfo
<
Type
>
(
)
;
}
}
;
using
TestDecodedStreamA
=
TestDecodedStream
<
Audio
>
;
using
TestDecodedStreamV
=
TestDecodedStream
<
Video
>
;
using
TestDecodedStreamAV
=
TestDecodedStream
<
AudioVideo
>
;
TEST_F
(
TestDecodedStreamAV
StartStop
)
{
mDecodedStream
-
>
Start
(
TimeUnit
:
:
Zero
(
)
CreateMediaInfo
(
)
)
;
mDecodedStream
-
>
SetPlaying
(
true
)
;
mDecodedStream
-
>
Stop
(
)
;
}
TEST_F
(
TestDecodedStreamA
LastOutputSystemTime
)
{
auto
start
=
AwakeTimeStamp
:
:
Now
(
)
;
BlankAudioDataCreator
creator
(
2
kRate
)
;
auto
raw
=
MakeRefPtr
<
MediaRawData
>
(
)
;
raw
-
>
mDuration
=
TimeUnit
(
kRate
kRate
)
;
mAudioQueue
.
Push
(
RefPtr
(
creator
.
Create
(
raw
)
)
-
>
As
<
AudioData
>
(
)
)
;
mDecodedStream
-
>
Start
(
TimeUnit
:
:
Zero
(
)
CreateMediaInfo
(
)
)
;
mDecodedStream
-
>
SetPlaying
(
true
)
;
NS_ProcessPendingEvents
(
nullptr
)
;
mMockCubebStream
-
>
ManualDataCallback
(
0
)
;
auto
before
=
AwakeTimeStamp
:
:
Now
(
)
;
mMockCubebStream
-
>
ManualDataCallback
(
512
)
;
auto
after
=
AwakeTimeStamp
:
:
Now
(
)
;
NS_ProcessPendingEvents
(
nullptr
)
;
EXPECT_GE
(
mDecodedStream
-
>
LastOutputSystemTime
(
)
-
start
before
-
start
)
;
EXPECT_LE
(
mDecodedStream
-
>
LastOutputSystemTime
(
)
-
start
after
-
start
)
;
mDecodedStream
-
>
Stop
(
)
;
}
TEST_F
(
TestDecodedStreamA
InterpolatedPosition
)
{
BlankAudioDataCreator
creator
(
2
kRate
)
;
auto
raw
=
MakeRefPtr
<
MediaRawData
>
(
)
;
raw
-
>
mDuration
=
TimeUnit
(
kRate
kRate
)
;
mAudioQueue
.
Push
(
RefPtr
(
creator
.
Create
(
raw
)
)
-
>
As
<
AudioData
>
(
)
)
;
mDecodedStream
-
>
Start
(
TimeUnit
:
:
Zero
(
)
CreateMediaInfo
(
)
)
;
mDecodedStream
-
>
SetPlaying
(
true
)
;
NS_ProcessPendingEvents
(
nullptr
)
;
mMockCubebStream
-
>
ManualDataCallback
(
0
)
;
auto
now
=
TimeStamp
:
:
Now
(
)
;
auto
awakeNow
=
AwakeTimeStamp
:
:
Now
(
)
;
TimeStamp
outNow
;
TimeUnit
pos
=
mDecodedStream
-
>
GetPositionImpl
(
now
awakeNow
&
outNow
)
;
EXPECT_EQ
(
now
outNow
)
;
EXPECT_EQ
(
pos
TimeUnit
:
:
Zero
(
)
)
<
<
pos
.
ToMilliseconds
(
)
;
mMockCubebStream
-
>
ManualDataCallback
(
512
)
;
NS_ProcessPendingEvents
(
nullptr
)
;
now
+
=
TimeDuration
:
:
FromSeconds
(
(
mDecodedStream
-
>
LastOutputSystemTime
(
)
-
awakeNow
)
.
ToSeconds
(
)
)
;
awakeNow
=
mDecodedStream
-
>
LastOutputSystemTime
(
)
;
pos
=
mDecodedStream
-
>
GetPositionImpl
(
now
awakeNow
)
;
EXPECT_EQ
(
pos
.
ToMicroseconds
(
)
TimeUnit
(
512
kRate
)
.
ToMicroseconds
(
)
)
;
now
+
=
TimeDuration
:
:
FromSeconds
(
(
mDecodedStream
-
>
LastOutputSystemTime
(
)
-
awakeNow
)
.
ToSeconds
(
)
)
+
TimeDuration
:
:
FromMilliseconds
(
10
)
;
awakeNow
=
mDecodedStream
-
>
LastOutputSystemTime
(
)
+
AwakeTimeDuration
:
:
FromMilliseconds
(
10
)
;
pos
=
mDecodedStream
-
>
GetPositionImpl
(
now
awakeNow
)
;
EXPECT_EQ
(
pos
.
ToMicroseconds
(
)
(
TimeUnit
(
512
kRate
)
+
TimeUnit
(
10
1000
)
)
.
ToMicroseconds
(
)
)
;
mDecodedStream
-
>
Stop
(
)
;
}
}
