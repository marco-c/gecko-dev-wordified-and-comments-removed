#
include
"
BlankDecoderModule
.
h
"
#
include
"
DecodedStream
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
MediaQueue
.
h
"
#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
MediaTrackListener
.
h
"
#
include
"
MockCubeb
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
gtest
/
WaitFor
.
h
"
#
include
"
nsJSEnvironment
.
h
"
using
mozilla
:
:
media
:
:
TimeUnit
;
using
testing
:
:
Test
;
namespace
mozilla
{
#
define
DispatchFunction
(
f
)
\
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
__func__
f
)
)
enum
MediaType
{
Audio
=
1
Video
=
2
AudioVideo
=
Audio
|
Video
}
;
template
<
MediaType
Type
>
CopyableTArray
<
RefPtr
<
ProcessedMediaTrack
>
>
CreateOutputTracks
(
MediaTrackGraphImpl
*
aGraph
)
{
CopyableTArray
<
RefPtr
<
ProcessedMediaTrack
>
>
outputTracks
;
if
constexpr
(
Type
&
Audio
)
{
outputTracks
.
AppendElement
(
aGraph
-
>
CreateForwardedInputTrack
(
MediaSegment
:
:
AUDIO
)
)
;
}
if
constexpr
(
Type
&
Video
)
{
outputTracks
.
AppendElement
(
aGraph
-
>
CreateForwardedInputTrack
(
MediaSegment
:
:
VIDEO
)
)
;
}
return
outputTracks
;
}
template
<
MediaType
Type
>
MediaInfo
CreateMediaInfo
(
)
{
MediaInfo
info
;
info
.
mStartTime
=
TimeUnit
:
:
Zero
(
)
;
if
constexpr
(
Type
&
Audio
)
{
info
.
EnableAudio
(
)
;
}
if
constexpr
(
Type
&
Video
)
{
info
.
EnableVideo
(
)
;
}
return
info
;
}
class
OnFallbackListener
:
public
MediaTrackListener
{
const
RefPtr
<
MediaTrack
>
mTrack
;
Atomic
<
bool
>
mOnFallback
{
true
}
;
public
:
explicit
OnFallbackListener
(
MediaTrack
*
aTrack
)
:
mTrack
(
aTrack
)
{
}
void
Reset
(
)
{
mOnFallback
=
true
;
}
bool
OnFallback
(
)
{
return
mOnFallback
;
}
void
NotifyOutput
(
MediaTrackGraph
*
TrackTime
)
override
{
if
(
auto
*
ad
=
mTrack
-
>
GraphImpl
(
)
-
>
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
{
mOnFallback
=
ad
-
>
OnFallback
(
)
;
}
}
}
;
template
<
MediaType
Type
>
class
TestDecodedStream
:
public
Test
{
public
:
static
constexpr
TrackRate
kRate
=
48000
;
static
constexpr
uint32_t
kChannels
=
2
;
const
RefPtr
<
MockCubeb
>
mMockCubeb
;
RefPtr
<
SmartMockCubebStream
>
mMockCubebStream
;
MediaQueue
<
AudioData
>
mAudioQueue
;
MediaQueue
<
VideoData
>
mVideoQueue
;
RefPtr
<
MediaTrackGraphImpl
>
mGraph
;
nsMainThreadPtrHandle
<
SharedDummyTrack
>
mDummyTrack
;
CopyableTArray
<
RefPtr
<
ProcessedMediaTrack
>
>
mOutputTracks
;
Canonical
<
PrincipalHandle
>
mCanonicalOutputPrincipal
;
RefPtr
<
DecodedStream
>
mDecodedStream
;
TestDecodedStream
(
)
:
mMockCubeb
(
MakeRefPtr
<
MockCubeb
>
(
MockCubeb
:
:
RunningMode
:
:
Manual
)
)
mGraph
(
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
kRate
nullptr
GetMainThreadSerialEventTarget
(
)
)
)
mDummyTrack
(
new
nsMainThreadPtrHolder
<
SharedDummyTrack
>
(
__func__
new
SharedDummyTrack
(
mGraph
-
>
CreateSourceTrack
(
MediaSegment
:
:
AUDIO
)
)
)
)
mOutputTracks
(
CreateOutputTracks
<
Type
>
(
mGraph
)
)
mCanonicalOutputPrincipal
(
AbstractThread
:
:
GetCurrent
(
)
PRINCIPAL_HANDLE_NONE
"
TestDecodedStream
:
:
mCanonicalOutputPrincipal
"
)
mDecodedStream
(
MakeRefPtr
<
DecodedStream
>
(
AbstractThread
:
:
GetCurrent
(
)
mDummyTrack
mOutputTracks
&
mCanonicalOutputPrincipal
1
.
0
1
.
0
true
mAudioQueue
mVideoQueue
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
;
void
SetUp
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
CubebUtils
:
:
ForceSetCubebContext
(
mMockCubeb
-
>
AsCubebContext
(
)
)
;
for
(
const
auto
&
track
:
mOutputTracks
)
{
track
-
>
QueueSetAutoend
(
false
)
;
}
mDummyTrack
-
>
mTrack
-
>
Resume
(
)
;
RefPtr
fallbackListener
=
new
OnFallbackListener
(
mDummyTrack
-
>
mTrack
)
;
mDummyTrack
-
>
mTrack
-
>
AddListener
(
fallbackListener
)
;
mMockCubebStream
=
WaitFor
(
mMockCubeb
-
>
StreamInitEvent
(
)
)
;
while
(
mMockCubebStream
-
>
State
(
)
.
isNothing
(
)
)
{
std
:
:
this_thread
:
:
sleep_for
(
std
:
:
chrono
:
:
milliseconds
(
1
)
)
;
}
ASSERT_EQ
(
*
mMockCubebStream
-
>
State
(
)
CUBEB_STATE_STARTED
)
;
while
(
fallbackListener
-
>
OnFallback
(
)
)
{
ASSERT_EQ
(
mMockCubebStream
-
>
ManualDataCallback
(
1
)
MockCubebStream
:
:
KeepProcessing
:
:
Yes
)
;
std
:
:
this_thread
:
:
sleep_for
(
std
:
:
chrono
:
:
milliseconds
(
1
)
)
;
}
}
void
TearDown
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mDecodedStream
-
>
Shutdown
(
)
;
for
(
const
auto
&
t
:
mOutputTracks
)
{
t
-
>
Destroy
(
)
;
}
mDummyTrack
=
nullptr
;
mDecodedStream
=
nullptr
;
MockCubebStream
:
:
KeepProcessing
keepProcessing
{
}
;
while
(
(
keepProcessing
=
mMockCubebStream
-
>
ManualDataCallback
(
0
)
)
=
=
MockCubebStream
:
:
KeepProcessing
:
:
Yes
)
{
NS_ProcessPendingEvents
(
nullptr
)
;
}
ASSERT_EQ
(
keepProcessing
MockCubebStream
:
:
KeepProcessing
:
:
No
)
;
NS_ProcessPendingEvents
(
nullptr
)
;
NS_ProcessPendingEvents
(
nullptr
)
;
ASSERT_TRUE
(
mGraph
-
>
OnGraphThreadOrNotRunning
(
)
)
<
<
"
Not
on
graph
thread
so
graph
must
still
be
running
!
"
;
ASSERT_EQ
(
mGraph
-
>
LifecycleStateRef
(
)
MediaTrackGraphImpl
:
:
LIFECYCLE_WAITING_FOR_THREAD_SHUTDOWN
)
<
<
"
The
graph
should
be
in
its
final
state
.
Note
it
does
not
advance
"
"
the
state
any
further
on
thread
shutdown
.
"
;
CubebUtils
:
:
ForceSetCubebContext
(
nullptr
)
;
MediaTrackGraphImpl
*
graph
{
}
;
mGraph
.
forget
(
&
graph
)
;
int32_t
refcnt
=
static_cast
<
int32_t
>
(
graph
-
>
Release
(
)
)
;
EXPECT_LE
(
refcnt
1
)
;
nsJSContext
:
:
CycleCollectNow
(
CCReason
:
:
API
)
;
nsJSContext
:
:
GarbageCollectNow
(
JS
:
:
GCReason
:
:
API
)
;
NS_ProcessPendingEvents
(
nullptr
)
;
}
MediaInfo
CreateMediaInfo
(
)
{
return
mozilla
:
:
CreateMediaInfo
<
Type
>
(
)
;
}
}
;
using
TestDecodedStreamA
=
TestDecodedStream
<
Audio
>
;
using
TestDecodedStreamV
=
TestDecodedStream
<
Video
>
;
using
TestDecodedStreamAV
=
TestDecodedStream
<
AudioVideo
>
;
TEST_F
(
TestDecodedStreamAV
StartStop
)
{
mDecodedStream
-
>
Start
(
TimeUnit
:
:
Zero
(
)
CreateMediaInfo
(
)
)
;
mDecodedStream
-
>
SetPlaying
(
true
)
;
mDecodedStream
-
>
Stop
(
)
;
}
}
