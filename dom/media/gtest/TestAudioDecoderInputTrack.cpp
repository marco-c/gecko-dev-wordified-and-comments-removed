#
include
<
utility
>
#
include
"
AudioDecoderInputTrack
.
h
"
#
include
"
GraphDriver
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
gtest
/
WaitFor
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
media
;
using
testing
:
:
AssertionResult
;
using
testing
:
:
NiceMock
;
using
testing
:
:
Return
;
using
ControlMessageInterface
=
MediaTrack
:
:
ControlMessageInterface
;
constexpr
uint32_t
kNoFlags
=
0
;
constexpr
TrackRate
kRate
=
44100
;
constexpr
uint32_t
kChannels
=
2
;
class
MockTestGraph
:
public
MediaTrackGraphImpl
{
public
:
explicit
MockTestGraph
(
TrackRate
aRate
)
:
MediaTrackGraphImpl
(
0
aRate
nullptr
NS_GetCurrentThread
(
)
)
{
ON_CALL
(
*
this
OnGraphThread
)
.
WillByDefault
(
Return
(
true
)
)
;
}
void
Init
(
uint32_t
aChannels
)
{
MediaTrackGraphImpl
:
:
Init
(
OFFLINE_THREAD_DRIVER
DIRECT_DRIVER
aChannels
)
;
SetCurrentDriver
(
new
NiceMock
<
MockDriver
>
(
)
)
;
}
MOCK_CONST_METHOD0
(
OnGraphThread
bool
(
)
)
;
MOCK_METHOD1
(
AppendMessage
void
(
UniquePtr
<
ControlMessageInterface
>
)
)
;
protected
:
~
MockTestGraph
(
)
=
default
;
class
MockDriver
:
public
GraphDriver
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MockDriver
override
)
;
MockDriver
(
)
:
GraphDriver
(
nullptr
nullptr
0
)
{
ON_CALL
(
*
this
OnThread
)
.
WillByDefault
(
Return
(
true
)
)
;
ON_CALL
(
*
this
ThreadRunning
)
.
WillByDefault
(
Return
(
true
)
)
;
}
MOCK_METHOD0
(
Start
void
(
)
)
;
MOCK_METHOD0
(
Shutdown
void
(
)
)
;
MOCK_METHOD0
(
IterationDuration
uint32_t
(
)
)
;
MOCK_METHOD0
(
EnsureNextIteration
void
(
)
)
;
MOCK_CONST_METHOD0
(
OnThread
bool
(
)
)
;
MOCK_CONST_METHOD0
(
ThreadRunning
bool
(
)
)
;
protected
:
~
MockDriver
(
)
=
default
;
}
;
bool
mEnableFakeAppend
=
false
;
}
;
AudioData
*
CreateAudioDataFromInfo
(
uint32_t
aFrames
const
AudioInfo
&
aInfo
)
{
AlignedAudioBuffer
samples
(
aFrames
*
aInfo
.
mChannels
)
;
return
new
AudioData
(
0
TimeUnit
:
:
Zero
(
)
std
:
:
move
(
samples
)
aInfo
.
mChannels
aInfo
.
mRate
)
;
}
AudioDecoderInputTrack
*
CreateTrack
(
MediaTrackGraph
*
aGraph
nsISerialEventTarget
*
aThread
const
AudioInfo
&
aInfo
float
aPlaybackRate
=
1
.
0
float
aVolume
=
1
.
0
bool
aPreservesPitch
=
true
)
{
return
AudioDecoderInputTrack
:
:
Create
(
aGraph
aThread
aInfo
aPlaybackRate
aVolume
aPreservesPitch
)
;
}
class
TestAudioDecoderInputTrack
:
public
testing
:
:
Test
{
protected
:
void
SetUp
(
)
override
{
mGraph
=
MakeRefPtr
<
NiceMock
<
MockTestGraph
>
>
(
kRate
)
;
mGraph
-
>
Init
(
kChannels
)
;
mInfo
.
mRate
=
kRate
;
mInfo
.
mChannels
=
kChannels
;
mTrack
=
CreateTrack
(
mGraph
NS_GetCurrentThread
(
)
mInfo
)
;
EXPECT_FALSE
(
mTrack
-
>
Ended
(
)
)
;
}
void
TearDown
(
)
override
{
mTrack
-
>
Close
(
)
;
mTrack
-
>
Destroy
(
)
;
mGraph
-
>
RemoveTrackGraphThread
(
mTrack
)
;
mGraph
-
>
Destroy
(
)
;
}
AudioData
*
CreateAudioData
(
uint32_t
aFrames
)
{
return
CreateAudioDataFromInfo
(
aFrames
mInfo
)
;
}
AudioSegment
*
GetTrackSegment
(
)
{
return
mTrack
-
>
GetData
<
AudioSegment
>
(
)
;
}
AssertionResult
ExpectSegmentNonSilence
(
const
char
*
aStartExpr
const
char
*
aEndExpr
TrackTime
aStart
TrackTime
aEnd
)
{
AudioSegment
checkedRange
;
checkedRange
.
AppendSlice
(
*
mTrack
-
>
GetData
(
)
aStart
aEnd
)
;
if
(
!
checkedRange
.
IsNull
(
)
)
{
return
testing
:
:
AssertionSuccess
(
)
;
}
return
testing
:
:
AssertionFailure
(
)
<
<
"
segment
[
"
<
<
aStart
<
<
"
:
"
<
<
aEnd
<
<
"
]
should
be
non
-
silence
"
;
}
AssertionResult
ExpectSegmentSilence
(
const
char
*
aStartExpr
const
char
*
aEndExpr
TrackTime
aStart
TrackTime
aEnd
)
{
AudioSegment
checkedRange
;
checkedRange
.
AppendSlice
(
*
mTrack
-
>
GetData
(
)
aStart
aEnd
)
;
if
(
checkedRange
.
IsNull
(
)
)
{
return
testing
:
:
AssertionSuccess
(
)
;
}
return
testing
:
:
AssertionFailure
(
)
<
<
"
segment
[
"
<
<
aStart
<
<
"
:
"
<
<
aEnd
<
<
"
]
should
be
silence
"
;
}
RefPtr
<
MockTestGraph
>
mGraph
;
RefPtr
<
AudioDecoderInputTrack
>
mTrack
;
AudioInfo
mInfo
;
}
;
TEST_F
(
TestAudioDecoderInputTrack
BasicAppendData
)
{
TrackTime
start
=
0
;
TrackTime
end
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_EQ
(
mTrack
-
>
GetEnd
(
)
end
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentSilence
start
end
)
;
RefPtr
<
AudioData
>
audio1
=
CreateAudioData
(
5
)
;
mTrack
-
>
AppendData
(
audio1
nullptr
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_EQ
(
mTrack
-
>
GetEnd
(
)
end
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
start
+
audio1
-
>
Frames
(
)
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentSilence
start
+
audio1
-
>
Frames
(
)
end
)
;
RefPtr
<
AudioData
>
audio2
=
CreateAudioData
(
10
)
;
mTrack
-
>
AppendData
(
audio2
nullptr
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
end
)
;
EXPECT_EQ
(
mTrack
-
>
GetEnd
(
)
end
)
;
mTrack
-
>
NotifyEndOfStream
(
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
ProcessedMediaTrack
:
:
ALLOW_END
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentSilence
start
end
)
;
EXPECT_EQ
(
mTrack
-
>
GetEnd
(
)
end
)
;
EXPECT_FALSE
(
mTrack
-
>
Ended
(
)
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
ProcessedMediaTrack
:
:
ALLOW_END
)
;
EXPECT_EQ
(
mTrack
-
>
WrittenFrames
(
)
audio1
-
>
Frames
(
)
+
audio2
-
>
Frames
(
)
)
;
}
TEST_F
(
TestAudioDecoderInputTrack
ClearFuture
)
{
RefPtr
<
AudioData
>
audio1
=
CreateAudioData
(
30
)
;
mTrack
-
>
AppendData
(
audio1
nullptr
)
;
TrackTime
start
=
0
;
TrackTime
end
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
end
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
end
)
;
mTrack
-
>
ClearFutureData
(
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentSilence
start
end
)
;
RefPtr
<
AudioData
>
audio2
=
CreateAudioData
(
10
)
;
mTrack
-
>
AppendData
(
audio2
nullptr
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
end
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentSilence
start
end
)
;
mTrack
-
>
NotifyEndOfStream
(
)
;
mTrack
-
>
ClearFutureData
(
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
ProcessedMediaTrack
:
:
ALLOW_END
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentSilence
start
end
)
;
EXPECT_FALSE
(
mTrack
-
>
Ended
(
)
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
ProcessedMediaTrack
:
:
ALLOW_END
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentSilence
start
end
)
;
EXPECT_FALSE
(
mTrack
-
>
Ended
(
)
)
;
EXPECT_EQ
(
mTrack
-
>
WrittenFrames
(
)
(
audio1
-
>
Frames
(
)
-
10
)
+
audio2
-
>
Frames
(
)
)
;
}
TEST_F
(
TestAudioDecoderInputTrack
InputRateChange
)
{
RefPtr
<
AudioData
>
audio1
=
CreateAudioData
(
10
)
;
mTrack
-
>
AppendData
(
audio1
nullptr
)
;
TrackTime
start
=
0
;
TrackTime
end
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
end
)
;
mInfo
.
mRate
=
kRate
/
2
;
RefPtr
<
AudioData
>
audioHalfSampleRate
=
CreateAudioData
(
5
)
;
mTrack
-
>
AppendData
(
audioHalfSampleRate
nullptr
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
end
)
;
mInfo
.
mRate
=
kRate
*
2
;
RefPtr
<
AudioData
>
audioDoubleSampleRate
=
CreateAudioData
(
10
)
;
TrackTime
expectedDuration
=
audioDoubleSampleRate
-
>
Frames
(
)
/
2
;
mTrack
-
>
AppendData
(
audioDoubleSampleRate
nullptr
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
start
+
expectedDuration
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentSilence
start
+
expectedDuration
end
)
;
EXPECT_EQ
(
mTrack
-
>
WrittenFrames
(
)
audio1
-
>
Frames
(
)
+
audioHalfSampleRate
-
>
Frames
(
)
*
2
+
audioDoubleSampleRate
-
>
Frames
(
)
/
2
)
;
}
TEST_F
(
TestAudioDecoderInputTrack
ChannelChange
)
{
EXPECT_EQ
(
mTrack
-
>
NumberOfChannels
(
)
uint32_t
(
2
)
)
;
mInfo
.
mChannels
=
1
;
RefPtr
<
AudioData
>
audioMono
=
CreateAudioData
(
10
)
;
mTrack
-
>
AppendData
(
audioMono
nullptr
)
;
TrackTime
start
=
0
;
TrackTime
end
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
end
)
;
EXPECT_EQ
(
mTrack
-
>
NumberOfChannels
(
)
audioMono
-
>
mChannels
)
;
mInfo
.
mChannels
=
5
;
RefPtr
<
AudioData
>
audioWithFiveChannels
=
CreateAudioData
(
10
)
;
mTrack
-
>
AppendData
(
audioWithFiveChannels
nullptr
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
end
)
;
EXPECT_EQ
(
mTrack
-
>
NumberOfChannels
(
)
audioWithFiveChannels
-
>
mChannels
)
;
EXPECT_EQ
(
mTrack
-
>
WrittenFrames
(
)
audioMono
-
>
Frames
(
)
+
audioWithFiveChannels
-
>
Frames
(
)
)
;
}
TEST_F
(
TestAudioDecoderInputTrack
VolumeChange
)
{
EXPECT_CALL
(
*
mGraph
AppendMessage
)
.
Times
(
2
)
.
WillOnce
(
[
]
(
UniquePtr
<
ControlMessageInterface
>
aMessage
)
{
aMessage
-
>
Run
(
)
;
}
)
.
WillOnce
(
[
]
(
UniquePtr
<
ControlMessageInterface
>
aMessage
)
{
}
)
;
float
expectedVolume
=
1
.
0
;
RefPtr
<
AudioData
>
audio
=
CreateAudioData
(
20
)
;
TrackTime
start
=
0
;
TrackTime
end
=
10
;
mTrack
-
>
AppendData
(
audio
nullptr
)
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
end
)
;
EXPECT_TRUE
(
GetTrackSegment
(
)
-
>
GetLastChunk
(
)
-
>
mVolume
=
=
expectedVolume
)
;
expectedVolume
=
0
.
1
;
mTrack
-
>
SetVolume
(
expectedVolume
)
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
TEST_F
(
TestAudioDecoderInputTrack
VolumeChange
)
"
_ns
[
&
]
{
return
mTrack
-
>
Volume
(
)
=
=
expectedVolume
;
}
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
end
)
;
EXPECT_TRUE
(
GetTrackSegment
(
)
-
>
GetLastChunk
(
)
-
>
mVolume
=
=
expectedVolume
)
;
}
TEST_F
(
TestAudioDecoderInputTrack
BatchedData
)
{
uint32_t
appendedFrames
=
0
;
RefPtr
<
AudioData
>
audio
=
CreateAudioData
(
10
)
;
for
(
size_t
idx
=
0
;
idx
<
50
;
idx
+
+
)
{
mTrack
-
>
AppendData
(
audio
nullptr
)
;
appendedFrames
+
=
audio
-
>
Frames
(
)
;
}
TrackTime
start
=
0
;
TrackTime
end
=
10
;
uint32_t
expectedFrames
=
end
-
start
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
end
)
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
TEST_F
(
TestAudioDecoderInputTrack
BatchedData
)
"
_ns
[
&
]
{
return
!
mTrack
-
>
HasBatchedData
(
)
;
}
)
;
start
=
end
;
end
=
start
+
(
appendedFrames
-
expectedFrames
)
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
end
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentSilence
start
end
)
;
EXPECT_EQ
(
mTrack
-
>
WrittenFrames
(
)
appendedFrames
)
;
}
TEST_F
(
TestAudioDecoderInputTrack
OutputAndEndEvent
)
{
RefPtr
<
AudioData
>
audio
=
CreateAudioData
(
10
)
;
MozPromiseHolder
<
GenericPromise
>
holder
;
RefPtr
<
GenericPromise
>
p
=
holder
.
Ensure
(
__func__
)
;
MediaEventListener
outputListener
=
mTrack
-
>
OnOutput
(
)
.
Connect
(
NS_GetCurrentThread
(
)
[
&
]
(
TrackTime
aFrame
)
{
EXPECT_EQ
(
aFrame
audio
-
>
Frames
(
)
)
;
holder
.
Resolve
(
true
__func__
)
;
}
)
;
mTrack
-
>
AppendData
(
audio
nullptr
)
;
mTrack
-
>
NotifyEndOfStream
(
)
;
TrackTime
start
=
0
;
TrackTime
end
=
10
;
mTrack
-
>
ProcessInput
(
start
end
ProcessedMediaTrack
:
:
ALLOW_END
)
;
Unused
<
<
WaitFor
(
p
)
;
p
=
holder
.
Ensure
(
__func__
)
;
MediaEventListener
endListener
=
mTrack
-
>
OnEnd
(
)
.
Connect
(
NS_GetCurrentThread
(
)
[
&
]
(
)
{
holder
.
Resolve
(
true
__func__
)
;
}
)
;
start
=
end
;
end
+
=
10
;
mTrack
-
>
ProcessInput
(
start
end
ProcessedMediaTrack
:
:
ALLOW_END
)
;
Unused
<
<
WaitFor
(
p
)
;
outputListener
.
Disconnect
(
)
;
endListener
.
Disconnect
(
)
;
}
TEST_F
(
TestAudioDecoderInputTrack
PlaybackRateChange
)
{
EXPECT_CALL
(
*
mGraph
AppendMessage
)
.
Times
(
2
)
.
WillOnce
(
[
]
(
UniquePtr
<
ControlMessageInterface
>
aMessage
)
{
aMessage
-
>
Run
(
)
;
}
)
.
WillOnce
(
[
]
(
UniquePtr
<
ControlMessageInterface
>
aMessage
)
{
}
)
;
float
expectedPlaybackRate
=
2
.
0
;
mTrack
-
>
SetPlaybackRate
(
expectedPlaybackRate
)
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
TEST_F
(
TestAudioDecoderInputTrack
PlaybackRateChange
)
"
_ns
[
&
]
{
return
mTrack
-
>
PlaybackRate
(
)
=
=
expectedPlaybackRate
;
}
)
;
RefPtr
<
AudioData
>
audio
=
CreateAudioData
(
100
)
;
mTrack
-
>
AppendData
(
audio
nullptr
)
;
mTrack
-
>
NotifyEndOfStream
(
)
;
TrackTime
start
=
0
;
TrackTime
end
=
audio
-
>
Frames
(
)
;
mTrack
-
>
ProcessInput
(
start
end
kNoFlags
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentNonSilence
start
audio
-
>
Frames
(
)
/
2
)
;
EXPECT_PRED_FORMAT2
(
ExpectSegmentSilence
start
+
audio
-
>
Frames
(
)
/
2
end
)
;
}
