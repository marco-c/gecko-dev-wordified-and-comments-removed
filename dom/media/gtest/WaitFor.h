#
ifndef
WAITFOR_H_
#
define
WAITFOR_H_
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaUtils
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
namespace
mozilla
{
template
<
typename
T
>
T
WaitFor
(
MediaEventSource
<
T
>
&
aEvent
)
{
Maybe
<
T
>
value
;
MediaEventListener
listener
=
aEvent
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
T
aValue
)
{
value
=
Some
(
aValue
)
;
}
)
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
WaitFor
(
MediaEventSource
<
T
>
&
aEvent
)
"
_ns
[
&
]
{
return
value
.
isSome
(
)
;
}
)
;
listener
.
Disconnect
(
)
;
return
value
.
value
(
)
;
}
void
WaitFor
(
MediaEventSource
<
void
>
&
aEvent
)
;
template
<
typename
R
typename
E
bool
Exc
>
Result
<
R
E
>
WaitFor
(
const
RefPtr
<
MozPromise
<
R
E
Exc
>
>
&
aPromise
)
{
Maybe
<
R
>
success
;
Maybe
<
E
>
error
;
aPromise
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
&
]
(
R
aResult
)
{
success
=
Some
(
aResult
)
;
}
[
&
]
(
E
aError
)
{
error
=
Some
(
aError
)
;
}
)
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
WaitFor
(
const
RefPtr
<
MozPromise
<
R
E
Exc
>
>
&
aPromise
)
"
_ns
[
&
]
{
return
success
.
isSome
(
)
|
|
error
.
isSome
(
)
;
}
)
;
if
(
success
.
isSome
(
)
)
{
return
success
.
extract
(
)
;
}
return
Err
(
error
.
extract
(
)
)
;
}
template
<
typename
.
.
.
Args
typename
CallbackFunction
>
void
WaitUntil
(
MediaEventSource
<
Args
.
.
.
>
&
aEvent
CallbackFunction
&
&
aF
)
{
bool
done
=
false
;
MediaEventListener
listener
=
aEvent
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
Args
.
.
.
aValue
)
{
if
(
!
done
)
{
done
=
aF
(
std
:
:
forward
<
Args
>
(
aValue
)
.
.
.
)
;
}
}
)
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
WaitUntil
(
MediaEventSource
<
Args
.
.
.
>
&
aEvent
CallbackFunction
&
&
aF
)
"
_ns
[
&
]
{
return
done
;
}
)
;
listener
.
Disconnect
(
)
;
}
template
<
typename
.
.
.
Args
>
using
TakeNPromise
=
MozPromise
<
std
:
:
vector
<
std
:
:
tuple
<
Args
.
.
.
>
>
bool
true
>
;
template
<
ListenerPolicy
Lp
typename
.
.
.
Args
>
auto
TakeN
(
MediaEventSourceImpl
<
Lp
Args
.
.
.
>
&
aEvent
size_t
aN
)
-
>
RefPtr
<
TakeNPromise
<
Args
.
.
.
>
>
{
using
Storage
=
std
:
:
vector
<
std
:
:
tuple
<
Args
.
.
.
>
>
;
using
Promise
=
TakeNPromise
<
Args
.
.
.
>
;
using
Values
=
media
:
:
Refcountable
<
Storage
>
;
using
Listener
=
media
:
:
Refcountable
<
MediaEventListener
>
;
RefPtr
<
Values
>
values
=
MakeRefPtr
<
Values
>
(
)
;
values
-
>
reserve
(
aN
)
;
RefPtr
<
Listener
>
listener
=
MakeRefPtr
<
Listener
>
(
)
;
auto
promise
=
InvokeAsync
(
AbstractThread
:
:
GetCurrent
(
)
__func__
[
values
aN
]
(
)
mutable
{
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
TakeN
(
MediaEventSourceImpl
<
Lp
Args
.
.
.
>
&
aEvent
size_t
aN
)
"
_ns
[
&
]
{
return
values
-
>
size
(
)
=
=
aN
;
}
)
;
return
Promise
:
:
CreateAndResolve
(
std
:
:
move
(
*
values
)
__func__
)
;
}
)
;
*
listener
=
aEvent
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
values
listener
aN
]
(
Args
.
.
.
aValue
)
{
values
-
>
push_back
(
{
aValue
.
.
.
}
)
;
if
(
values
-
>
size
(
)
=
=
aN
)
{
listener
-
>
Disconnect
(
)
;
}
}
)
;
return
promise
;
}
inline
void
WaitForMirrors
(
const
RefPtr
<
nsISerialEventTarget
>
&
aTarget
)
{
Unused
<
<
WaitFor
(
InvokeAsync
(
aTarget
__func__
[
]
{
return
GenericPromise
:
:
CreateAndResolve
(
true
"
WaitForMirrors
resolver
"
)
;
}
)
)
;
}
inline
void
WaitForMirrors
(
)
{
WaitForMirrors
(
GetCurrentSerialEventTarget
(
)
)
;
}
}
#
endif
