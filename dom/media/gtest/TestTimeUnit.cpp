#
include
<
algorithm
>
#
include
<
vector
>
#
include
"
TimeUnits
.
h
"
#
include
"
gtest
/
gtest
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
media
;
using
TimeUnit
=
mozilla
:
:
media
:
:
TimeUnit
;
TEST
(
TimeUnit
BasicArithmetic
)
{
const
TimeUnit
a
(
1000
44100
)
;
{
TimeUnit
b
=
a
*
10
;
EXPECT_EQ
(
b
.
mBase
44100
)
;
EXPECT_EQ
(
b
.
mTicks
.
value
(
)
a
.
mTicks
.
value
(
)
*
10
)
;
EXPECT_EQ
(
a
*
10
b
)
;
}
{
TimeUnit
b
=
a
/
10
;
EXPECT_EQ
(
b
.
mBase
44100
)
;
EXPECT_EQ
(
b
.
mTicks
.
value
(
)
a
.
mTicks
.
value
(
)
/
10
)
;
EXPECT_EQ
(
a
/
10
b
)
;
}
{
TimeUnit
b
=
TimeUnit
(
10
44100
)
;
b
+
=
a
;
EXPECT_EQ
(
b
.
mBase
44100
)
;
EXPECT_EQ
(
b
.
mTicks
.
value
(
)
a
.
mTicks
.
value
(
)
+
10
)
;
EXPECT_EQ
(
b
-
a
TimeUnit
(
10
44100
)
)
;
}
{
TimeUnit
b
=
TimeUnit
(
1010
44100
)
;
b
-
=
a
;
EXPECT_EQ
(
b
.
mBase
44100
)
;
EXPECT_EQ
(
b
.
mTicks
.
value
(
)
10
)
;
EXPECT_EQ
(
a
+
b
TimeUnit
(
1010
44100
)
)
;
}
{
TimeUnit
b
=
TimeUnit
(
4010
44100
)
;
TimeUnit
c
=
b
%
a
;
EXPECT_EQ
(
c
.
mBase
44100
)
;
EXPECT_EQ
(
c
.
mTicks
.
value
(
)
10
)
;
}
{
TimeUnit
b
=
TimeUnit
(
6000000000
1000000000
)
;
TimeUnit
c
=
TimeUnit
(
9001
90000
)
;
TimeUnit
d
=
c
+
b
;
EXPECT_EQ
(
d
.
mBase
90000
)
;
EXPECT_EQ
(
d
.
mTicks
.
value
(
)
549001
)
;
}
{
TimeUnit
b
=
TimeUnit
(
6000000000
1000000000
)
;
TimeUnit
c
=
TimeUnit
(
9001
90000
)
;
TimeUnit
d
=
(
b
-
c
)
.
ToBase
(
90000
)
;
EXPECT_EQ
(
d
.
mBase
90000
)
;
EXPECT_EQ
(
d
.
mTicks
.
value
(
)
530999
)
;
}
}
TEST
(
TimeUnit
Base
)
{
{
TimeUnit
a
=
TimeUnit
:
:
FromSeconds
(
1
)
;
EXPECT_EQ
(
a
.
mTicks
.
value
(
)
1000000
)
;
EXPECT_EQ
(
a
.
mBase
1000000
)
;
}
{
TimeUnit
a
=
TimeUnit
:
:
FromMicroseconds
(
44100000000
)
;
EXPECT_EQ
(
a
.
mTicks
.
value
(
)
44100000000
)
;
EXPECT_EQ
(
a
.
mBase
1000000
)
;
}
{
TimeUnit
a
=
TimeUnit
:
:
FromSeconds
(
6
.
0
)
;
EXPECT_EQ
(
a
.
mTicks
.
value
(
)
6000000
)
;
EXPECT_EQ
(
a
.
mBase
1000000
)
;
double
error
;
TimeUnit
b
=
a
.
ToBase
(
90000
error
)
;
EXPECT_EQ
(
error
0
)
;
EXPECT_EQ
(
b
.
mTicks
.
value
(
)
540000
)
;
EXPECT_EQ
(
b
.
mBase
90000
)
;
}
}
TEST
(
TimeUnit
Rounding
)
{
int64_t
usecs
=
662617
;
double
seconds
=
TimeUnit
:
:
FromMicroseconds
(
usecs
)
.
ToSeconds
(
)
;
TimeUnit
fromSeconds
=
TimeUnit
:
:
FromSeconds
(
seconds
)
;
EXPECT_EQ
(
fromSeconds
.
mTicks
.
value
(
)
usecs
)
;
EXPECT_EQ
(
fromSeconds
.
mBase
1000000
)
;
EXPECT_EQ
(
fromSeconds
.
ToMicroseconds
(
)
usecs
)
;
seconds
=
4
.
169470123
;
int64_t
nsecs
=
4169470123
;
EXPECT_EQ
(
TimeUnit
:
:
FromSeconds
(
seconds
1e9
)
.
ToNanoseconds
(
)
nsecs
)
;
EXPECT_EQ
(
TimeUnit
:
:
FromSeconds
(
seconds
1e9
)
.
ToMicroseconds
(
)
nsecs
/
1000
)
;
seconds
=
2312312
.
16947012
;
nsecs
=
2312312169470120
;
EXPECT_EQ
(
TimeUnit
:
:
FromSeconds
(
seconds
1e9
)
.
ToNanoseconds
(
)
nsecs
)
;
EXPECT_EQ
(
TimeUnit
:
:
FromSeconds
(
seconds
1e9
)
.
ToMicroseconds
(
)
nsecs
/
1000
)
;
seconds
=
2312312
.
169470123
;
nsecs
=
2312312169470123
;
EXPECT_EQ
(
TimeUnit
:
:
FromSeconds
(
seconds
1e9
)
.
ToMicroseconds
(
)
nsecs
/
1000
)
;
}
TEST
(
TimeUnit
Comparisons
)
{
TimeUnit
a
(
0
1e9
)
;
TimeUnit
b
(
1
1e9
)
;
TimeUnit
c
(
1
1e6
)
;
EXPECT_GE
(
b
a
)
;
EXPECT_GE
(
c
a
)
;
EXPECT_GE
(
c
b
)
;
EXPECT_GT
(
b
a
)
;
EXPECT_GT
(
c
a
)
;
EXPECT_GT
(
c
b
)
;
EXPECT_LE
(
a
b
)
;
EXPECT_LE
(
a
c
)
;
EXPECT_LE
(
b
c
)
;
EXPECT_LT
(
a
b
)
;
EXPECT_LT
(
a
c
)
;
EXPECT_LT
(
b
c
)
;
TimeUnit
d
(
0
1
)
;
TimeUnit
e
(
0
1000
)
;
EXPECT_EQ
(
a
d
)
;
EXPECT_EQ
(
a
e
)
;
TimeUnit
f
(
1000
1e9
)
;
TimeUnit
g
(
1
1e6
)
;
EXPECT_EQ
(
f
g
)
;
TimeUnit
h
=
TimeUnit
:
:
FromInfinity
(
)
;
TimeUnit
i
=
TimeUnit
:
:
Zero
(
)
;
EXPECT_LE
(
i
h
)
;
EXPECT_LT
(
i
h
)
;
EXPECT_GE
(
h
i
)
;
EXPECT_GT
(
h
i
)
;
TimeUnit
j
=
TimeUnit
:
:
FromInfinity
(
)
;
TimeUnit
k
=
TimeUnit
:
:
Zero
(
1000000
)
;
EXPECT_LE
(
k
j
)
;
EXPECT_LT
(
k
j
)
;
EXPECT_GE
(
j
k
)
;
EXPECT_GT
(
j
k
)
;
TimeUnit
l
=
TimeUnit
(
123123120000000
1000000000
)
;
TimeUnit
m
=
TimeUnit
(
123123120000000
1000
)
;
EXPECT_LE
(
l
m
)
;
EXPECT_LT
(
l
m
)
;
EXPECT_GE
(
m
l
)
;
EXPECT_GT
(
m
l
)
;
TimeUnit
n
=
TimeUnit
(
123123123123123
1000000000
)
;
TimeUnit
o
=
TimeUnit
(
123123123123123
1000000001
)
;
EXPECT_LE
(
o
n
)
;
EXPECT_LT
(
o
n
)
;
EXPECT_GE
(
n
o
)
;
EXPECT_GT
(
n
o
)
;
TimeUnit
p
(
12312312312312312
100000000
)
;
TimeUnit
q
(
123123123123123119
1000000000
)
;
TimeUnit
r
(
123123123123123120
1000000000
)
;
TimeUnit
s
(
123123123123123121
1000000000
)
;
EXPECT_LE
(
q
p
)
;
EXPECT_LT
(
q
p
)
;
EXPECT_NE
(
q
p
)
;
EXPECT_EQ
(
p
r
)
;
EXPECT_GE
(
s
p
)
;
EXPECT_GT
(
s
p
)
;
EXPECT_NE
(
s
p
)
;
TimeUnit
t
=
TimeUnit
(
123123123123124
100000000
*
3
)
;
TimeUnit
u
=
TimeUnit
(
123123123123124
*
3
100000000
)
;
EXPECT_NE
(
t
u
)
;
TimeUnit
leftBound
(
74332508253360
44100
)
;
TimeUnit
rightBound
(
74332508297392
44100
)
;
TimeUnit
fuzz
(
250000
1000000
)
;
TimeUnit
time
(
1685544404790205
1000000
)
;
EXPECT_LT
(
leftBound
-
fuzz
time
)
;
EXPECT_GT
(
time
leftBound
-
fuzz
)
;
EXPECT_GE
(
rightBound
+
fuzz
time
)
;
EXPECT_LT
(
time
rightBound
+
fuzz
)
;
TimeUnit
zero
=
TimeUnit
:
:
Zero
(
)
;
TimeUnit
datenow
(
151737439364679
90000
)
;
EXPECT_NE
(
zero
datenow
)
;
}
TEST
(
TimeUnit
InfinityMath
)
{
const
TimeUnit
posInf
=
TimeUnit
:
:
FromInfinity
(
)
;
EXPECT_EQ
(
TimeUnit
:
:
FromSeconds
(
mozilla
:
:
PositiveInfinity
<
double
>
(
)
)
posInf
)
;
const
TimeUnit
negInf
=
TimeUnit
:
:
FromNegativeInfinity
(
)
;
EXPECT_EQ
(
TimeUnit
:
:
FromSeconds
(
mozilla
:
:
NegativeInfinity
<
double
>
(
)
)
negInf
)
;
EXPECT_EQ
(
posInf
+
posInf
posInf
)
;
EXPECT_FALSE
(
(
posInf
+
negInf
)
.
IsValid
(
)
)
;
EXPECT_FALSE
(
(
posInf
-
posInf
)
.
IsValid
(
)
)
;
EXPECT_EQ
(
posInf
-
negInf
posInf
)
;
EXPECT_EQ
(
negInf
+
negInf
negInf
)
;
EXPECT_FALSE
(
(
negInf
+
posInf
)
.
IsValid
(
)
)
;
EXPECT_FALSE
(
(
negInf
-
negInf
)
.
IsValid
(
)
)
;
EXPECT_EQ
(
negInf
-
posInf
negInf
)
;
const
TimeUnit
finite
=
TimeUnit
:
:
FromSeconds
(
42
.
0
)
;
EXPECT_EQ
(
posInf
-
finite
posInf
)
;
EXPECT_EQ
(
posInf
+
finite
posInf
)
;
EXPECT_EQ
(
negInf
-
finite
negInf
)
;
EXPECT_EQ
(
negInf
+
finite
negInf
)
;
EXPECT_EQ
(
finite
+
posInf
posInf
)
;
EXPECT_EQ
(
finite
-
posInf
negInf
)
;
EXPECT_EQ
(
finite
+
negInf
negInf
)
;
EXPECT_EQ
(
finite
-
negInf
posInf
)
;
}
TEST
(
TimeUnit
BaseConversion
)
{
const
int64_t
packetSize
=
1024
;
int64_t
sampleRates
[
]
=
{
16000
44100
48000
88200
96000
}
;
const
double
hnsPerSeconds
=
10000000
.
;
for
(
auto
sampleRate
:
sampleRates
)
{
int64_t
frameCount
=
0
;
TimeUnit
pts
;
do
{
int64_t
hns
=
AssertedCast
<
int64_t
>
(
std
:
:
round
(
hnsPerSeconds
*
static_cast
<
double
>
(
frameCount
)
/
static_cast
<
double
>
(
sampleRate
)
)
)
;
pts
=
TimeUnit
:
:
FromHns
(
hns
sampleRate
)
;
EXPECT_EQ
(
AssertedCast
<
int64_t
>
(
std
:
:
round
(
pts
.
ToSeconds
(
)
*
hnsPerSeconds
)
)
hns
)
;
frameCount
+
=
packetSize
;
}
while
(
pts
.
ToSeconds
(
)
<
36000
)
;
}
}
TEST
(
TimeUnit
MinimumRoundingError
)
{
TimeUnit
a
(
448
48000
)
;
TimeUnit
b
(
1
1000000
)
;
TimeUnit
rv
=
a
-
b
;
EXPECT_EQ
(
rv
.
mTicks
.
value
(
)
448
)
;
EXPECT_EQ
(
rv
.
mBase
48000
)
;
TimeUnit
c
(
11
1000000
)
;
rv
=
a
-
c
;
EXPECT_EQ
(
rv
.
mTicks
.
value
(
)
447
)
;
EXPECT_EQ
(
rv
.
mBase
48000
)
;
}
