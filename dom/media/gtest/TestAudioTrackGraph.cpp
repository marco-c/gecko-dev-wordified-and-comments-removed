#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
-
printers
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
CrossGraphPort
.
h
"
#
include
"
DeviceInputTrack
.
h
"
#
ifdef
MOZ_WEBRTC
#
include
"
MediaEngineWebRTCAudio
.
h
"
#
endif
#
include
"
MockCubeb
.
h
"
#
include
"
mozilla
/
gtest
/
WaitFor
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
WavDumper
.
h
"
using
namespace
mozilla
;
#
define
Invoke
(
f
)
InvokeAsync
(
GetCurrentSerialEventTarget
(
)
__func__
f
)
#
define
DispatchFunction
(
f
)
\
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
__func__
f
)
)
#
define
DispatchMethod
(
t
m
args
.
.
.
)
\
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
__func__
t
m
#
#
args
)
)
namespace
{
#
ifdef
MOZ_WEBRTC
struct
StartInputProcessing
:
public
ControlMessage
{
const
RefPtr
<
AudioProcessingTrack
>
mProcessingTrack
;
const
RefPtr
<
AudioInputProcessing
>
mInputProcessing
;
StartInputProcessing
(
AudioProcessingTrack
*
aTrack
AudioInputProcessing
*
aInputProcessing
)
:
ControlMessage
(
aTrack
)
mProcessingTrack
(
aTrack
)
mInputProcessing
(
aInputProcessing
)
{
}
void
Run
(
)
override
{
mInputProcessing
-
>
Start
(
mTrack
-
>
Graph
(
)
)
;
}
}
;
struct
StopInputProcessing
:
public
ControlMessage
{
const
RefPtr
<
AudioInputProcessing
>
mInputProcessing
;
explicit
StopInputProcessing
(
AudioProcessingTrack
*
aTrack
AudioInputProcessing
*
aInputProcessing
)
:
ControlMessage
(
aTrack
)
mInputProcessing
(
aInputProcessing
)
{
}
void
Run
(
)
override
{
mInputProcessing
-
>
Stop
(
mTrack
-
>
Graph
(
)
)
;
}
}
;
struct
SetPassThrough
:
public
ControlMessage
{
const
RefPtr
<
AudioInputProcessing
>
mInputProcessing
;
const
bool
mPassThrough
;
SetPassThrough
(
MediaTrack
*
aTrack
AudioInputProcessing
*
aInputProcessing
bool
aPassThrough
)
:
ControlMessage
(
aTrack
)
mInputProcessing
(
aInputProcessing
)
mPassThrough
(
aPassThrough
)
{
}
void
Run
(
)
override
{
EXPECT_EQ
(
mInputProcessing
-
>
PassThrough
(
mTrack
-
>
Graph
(
)
)
!
mPassThrough
)
;
mInputProcessing
-
>
SetPassThrough
(
mTrack
-
>
Graph
(
)
mPassThrough
)
;
}
}
;
struct
SetRequestedInputChannelCount
:
public
ControlMessage
{
const
CubebUtils
:
:
AudioDeviceID
mDeviceId
;
const
RefPtr
<
AudioInputProcessing
>
mInputProcessing
;
const
uint32_t
mChannelCount
;
SetRequestedInputChannelCount
(
MediaTrack
*
aTrack
CubebUtils
:
:
AudioDeviceID
aDeviceId
AudioInputProcessing
*
aInputProcessing
uint32_t
aChannelCount
)
:
ControlMessage
(
aTrack
)
mDeviceId
(
aDeviceId
)
mInputProcessing
(
aInputProcessing
)
mChannelCount
(
aChannelCount
)
{
}
void
Run
(
)
override
{
mInputProcessing
-
>
SetRequestedInputChannelCount
(
mTrack
-
>
Graph
(
)
mDeviceId
mChannelCount
)
;
}
}
;
#
endif
class
GoFaster
:
public
ControlMessage
{
MockCubeb
*
mCubeb
;
public
:
explicit
GoFaster
(
MockCubeb
*
aCubeb
)
:
ControlMessage
(
nullptr
)
mCubeb
(
aCubeb
)
{
}
void
Run
(
)
override
{
mCubeb
-
>
GoFaster
(
)
;
}
}
;
struct
StartNonNativeInput
:
public
ControlMessage
{
const
RefPtr
<
NonNativeInputTrack
>
mInputTrack
;
RefPtr
<
AudioInputSource
>
mInputSource
;
StartNonNativeInput
(
NonNativeInputTrack
*
aInputTrack
RefPtr
<
AudioInputSource
>
&
&
aInputSource
)
:
ControlMessage
(
aInputTrack
)
mInputTrack
(
aInputTrack
)
mInputSource
(
std
:
:
move
(
aInputSource
)
)
{
}
void
Run
(
)
override
{
mInputTrack
-
>
StartAudio
(
std
:
:
move
(
mInputSource
)
)
;
}
}
;
struct
StopNonNativeInput
:
public
ControlMessage
{
const
RefPtr
<
NonNativeInputTrack
>
mInputTrack
;
explicit
StopNonNativeInput
(
NonNativeInputTrack
*
aInputTrack
)
:
ControlMessage
(
aInputTrack
)
mInputTrack
(
aInputTrack
)
{
}
void
Run
(
)
override
{
mInputTrack
-
>
StopAudio
(
)
;
}
}
;
}
TEST
(
TestAudioTrackGraph
DifferentDeviceIDs
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
g1
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
AUDIO_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
MediaTrackGraph
*
g2
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
AUDIO_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
reinterpret_cast
<
cubeb_devid
>
(
1
)
GetMainThreadSerialEventTarget
(
)
)
;
MediaTrackGraph
*
g1_2
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
AUDIO_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
MediaTrackGraph
*
g2_2
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
AUDIO_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
reinterpret_cast
<
cubeb_devid
>
(
1
)
GetMainThreadSerialEventTarget
(
)
)
;
EXPECT_NE
(
g1
g2
)
<
<
"
Different
graphs
due
to
different
device
ids
"
;
EXPECT_EQ
(
g1
g1_2
)
<
<
"
Same
graphs
for
same
device
ids
"
;
EXPECT_EQ
(
g2
g2_2
)
<
<
"
Same
graphs
for
same
device
ids
"
;
for
(
MediaTrackGraph
*
g
:
{
g1
g2
}
)
{
using
SourceTrackPromise
=
MozPromise
<
SourceMediaTrack
*
nsresult
true
>
;
auto
p
=
Invoke
(
[
g
]
{
return
SourceTrackPromise
:
:
CreateAndResolve
(
g
-
>
CreateSourceTrack
(
MediaSegment
:
:
AUDIO
)
__func__
)
;
}
)
;
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
RefPtr
<
SourceMediaTrack
>
dummySource
=
WaitFor
(
p
)
.
unwrap
(
)
;
DispatchMethod
(
dummySource
&
SourceMediaTrack
:
:
Destroy
)
;
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
}
}
TEST
(
TestAudioTrackGraph
SetOutputDeviceID
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
AUDIO_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
reinterpret_cast
<
cubeb_devid
>
(
2
)
GetMainThreadSerialEventTarget
(
)
)
;
RefPtr
<
SourceMediaTrack
>
dummySource
;
DispatchFunction
(
[
&
]
{
dummySource
=
graph
-
>
CreateSourceTrack
(
MediaSegment
:
:
AUDIO
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_EQ
(
stream
-
>
GetOutputDeviceID
(
)
reinterpret_cast
<
cubeb_devid
>
(
2
)
)
<
<
"
After
init
confirm
the
expected
output
device
id
"
;
DispatchMethod
(
dummySource
&
SourceMediaTrack
:
:
Destroy
)
;
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
}
TEST
(
TestAudioTrackGraph
StreamName
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraphImpl
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
reinterpret_cast
<
cubeb_devid
>
(
1
)
GetMainThreadSerialEventTarget
(
)
)
;
nsLiteralCString
name1
(
"
name1
"
)
;
graph
-
>
CurrentDriver
(
)
-
>
SetStreamName
(
name1
)
;
RefPtr
<
SourceMediaTrack
>
dummySource
;
DispatchFunction
(
[
&
]
{
dummySource
=
graph
-
>
CreateSourceTrack
(
MediaSegment
:
:
AUDIO
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_STREQ
(
stream
-
>
StreamName
(
)
name1
.
get
(
)
)
;
nsLiteralCString
name2
(
"
name2
"
)
;
DispatchFunction
(
[
&
]
{
graph
-
>
QueueControlMessageWithNoShutdown
(
[
&
]
{
graph
-
>
CurrentDriver
(
)
-
>
SetStreamName
(
name2
)
;
}
)
;
}
)
;
nsCString
name
=
WaitFor
(
stream
-
>
NameSetEvent
(
)
)
;
EXPECT_EQ
(
name
name2
)
;
DispatchMethod
(
dummySource
&
SourceMediaTrack
:
:
Destroy
)
;
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
}
TEST
(
TestAudioTrackGraph
NotifyDeviceStarted
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
AUDIO_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
RefPtr
<
SourceMediaTrack
>
dummySource
;
Unused
<
<
WaitFor
(
Invoke
(
[
&
]
{
dummySource
=
graph
-
>
CreateSourceTrack
(
MediaSegment
:
:
AUDIO
)
;
return
graph
-
>
NotifyWhenDeviceStarted
(
nullptr
)
;
}
)
)
;
{
MediaTrackGraphImpl
*
graph
=
dummySource
-
>
GraphImpl
(
)
;
MonitorAutoLock
lock
(
graph
-
>
GetMonitor
(
)
)
;
EXPECT_TRUE
(
graph
-
>
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
;
EXPECT_TRUE
(
graph
-
>
CurrentDriver
(
)
-
>
ThreadRunning
(
)
)
;
}
DispatchMethod
(
dummySource
&
SourceMediaTrack
:
:
Destroy
)
;
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
}
TEST
(
TestAudioTrackGraph
NonNativeInputTrackStartAndStop
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
NonNativeInputTrack
>
track
;
DispatchFunction
(
[
&
]
{
track
=
new
NonNativeInputTrack
(
graph
-
>
GraphRate
(
)
deviceId
PRINCIPAL_HANDLE_NONE
)
;
graph
-
>
AddTrack
(
track
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
driverStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_FALSE
(
driverStream
-
>
mHasInput
)
;
EXPECT_TRUE
(
driverStream
-
>
mHasOutput
)
;
{
const
AudioInputSource
:
:
Id
sourceId
=
1
;
const
uint32_t
channels
=
2
;
const
TrackRate
rate
=
48000
;
{
struct
DeviceInfo
{
uint32_t
mChannelCount
;
AudioInputType
mType
;
}
;
using
DeviceQueryPromise
=
MozPromise
<
DeviceInfo
nsresult
true
>
;
struct
DeviceQueryMessage
:
public
ControlMessage
{
const
NonNativeInputTrack
*
mInputTrack
;
MozPromiseHolder
<
DeviceQueryPromise
>
mHolder
;
DeviceQueryMessage
(
NonNativeInputTrack
*
aInputTrack
MozPromiseHolder
<
DeviceQueryPromise
>
&
&
aHolder
)
:
ControlMessage
(
aInputTrack
)
mInputTrack
(
aInputTrack
)
mHolder
(
std
:
:
move
(
aHolder
)
)
{
}
void
Run
(
)
override
{
DeviceInfo
info
=
{
mInputTrack
-
>
NumberOfChannels
(
)
mInputTrack
-
>
DevicePreference
(
)
}
;
mTrack
-
>
GraphImpl
(
)
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
TestAudioTrackGraph
:
:
DeviceQueryMessage
"
[
holder
=
std
:
:
move
(
mHolder
)
devInfo
=
info
]
(
)
mutable
{
holder
.
Resolve
(
devInfo
__func__
)
;
}
)
)
;
}
}
;
{
MozPromiseHolder
<
DeviceQueryPromise
>
h
;
RefPtr
<
DeviceQueryPromise
>
p
=
h
.
Ensure
(
__func__
)
;
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
DeviceQueryMessage
>
(
track
.
get
(
)
std
:
:
move
(
h
)
)
)
;
}
)
;
Result
<
DeviceInfo
nsresult
>
r
=
WaitFor
(
p
)
;
ASSERT_TRUE
(
r
.
isOk
(
)
)
;
DeviceInfo
info
=
r
.
unwrap
(
)
;
EXPECT_EQ
(
info
.
mChannelCount
0U
)
;
EXPECT_EQ
(
info
.
mType
AudioInputType
:
:
Unknown
)
;
}
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartNonNativeInput
>
(
track
.
get
(
)
MakeRefPtr
<
AudioInputSource
>
(
MakeRefPtr
<
AudioInputSourceListener
>
(
track
.
get
(
)
)
sourceId
deviceId
channels
true
PRINCIPAL_HANDLE_NONE
rate
graph
-
>
GraphRate
(
)
)
)
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
nonNativeStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
nonNativeStream
-
>
mHasInput
)
;
EXPECT_FALSE
(
nonNativeStream
-
>
mHasOutput
)
;
EXPECT_EQ
(
nonNativeStream
-
>
GetInputDeviceID
(
)
deviceId
)
;
EXPECT_EQ
(
nonNativeStream
-
>
InputChannels
(
)
channels
)
;
EXPECT_EQ
(
nonNativeStream
-
>
SampleRate
(
)
static_cast
<
uint32_t
>
(
rate
)
)
;
{
MozPromiseHolder
<
DeviceQueryPromise
>
h
;
RefPtr
<
DeviceQueryPromise
>
p
=
h
.
Ensure
(
__func__
)
;
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
DeviceQueryMessage
>
(
track
.
get
(
)
std
:
:
move
(
h
)
)
)
;
}
)
;
Result
<
DeviceInfo
nsresult
>
r
=
WaitFor
(
p
)
;
ASSERT_TRUE
(
r
.
isOk
(
)
)
;
DeviceInfo
info
=
r
.
unwrap
(
)
;
EXPECT_EQ
(
info
.
mChannelCount
channels
)
;
EXPECT_EQ
(
info
.
mType
AudioInputType
:
:
Voice
)
;
}
Unused
<
<
WaitFor
(
nonNativeStream
-
>
FramesProcessedEvent
(
)
)
;
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopNonNativeInput
>
(
track
.
get
(
)
)
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
destroyedStream
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyedStream
.
get
(
)
nonNativeStream
.
get
(
)
)
;
{
MozPromiseHolder
<
DeviceQueryPromise
>
h
;
RefPtr
<
DeviceQueryPromise
>
p
=
h
.
Ensure
(
__func__
)
;
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
DeviceQueryMessage
>
(
track
.
get
(
)
std
:
:
move
(
h
)
)
)
;
}
)
;
Result
<
DeviceInfo
nsresult
>
r
=
WaitFor
(
p
)
;
ASSERT_TRUE
(
r
.
isOk
(
)
)
;
DeviceInfo
info
=
r
.
unwrap
(
)
;
EXPECT_EQ
(
info
.
mChannelCount
0U
)
;
EXPECT_EQ
(
info
.
mType
AudioInputType
:
:
Unknown
)
;
}
}
{
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartNonNativeInput
>
(
track
.
get
(
)
MakeRefPtr
<
AudioInputSource
>
(
MakeRefPtr
<
AudioInputSourceListener
>
(
track
.
get
(
)
)
sourceId
deviceId
channels
true
PRINCIPAL_HANDLE_NONE
rate
graph
-
>
GraphRate
(
)
)
)
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
nonNativeStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
nonNativeStream
-
>
mHasInput
)
;
EXPECT_FALSE
(
nonNativeStream
-
>
mHasOutput
)
;
EXPECT_EQ
(
nonNativeStream
-
>
GetInputDeviceID
(
)
deviceId
)
;
EXPECT_EQ
(
nonNativeStream
-
>
InputChannels
(
)
channels
)
;
EXPECT_EQ
(
nonNativeStream
-
>
SampleRate
(
)
static_cast
<
uint32_t
>
(
rate
)
)
;
Unused
<
<
WaitFor
(
nonNativeStream
-
>
FramesProcessedEvent
(
)
)
;
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopNonNativeInput
>
(
track
.
get
(
)
)
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
destroyedStream
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyedStream
.
get
(
)
nonNativeStream
.
get
(
)
)
;
}
}
DispatchFunction
(
[
&
]
{
track
-
>
Destroy
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
destroyedStream
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyedStream
.
get
(
)
driverStream
.
get
(
)
)
;
}
TEST
(
TestAudioTrackGraph
NonNativeInputTrackErrorCallback
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
NonNativeInputTrack
>
track
;
DispatchFunction
(
[
&
]
{
track
=
new
NonNativeInputTrack
(
graph
-
>
GraphRate
(
)
deviceId
PRINCIPAL_HANDLE_NONE
)
;
graph
-
>
AddTrack
(
track
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
driverStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_FALSE
(
driverStream
-
>
mHasInput
)
;
EXPECT_TRUE
(
driverStream
-
>
mHasOutput
)
;
{
const
AudioInputSource
:
:
Id
sourceId
=
1
;
const
uint32_t
channels
=
2
;
const
TrackRate
rate
=
48000
;
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartNonNativeInput
>
(
track
.
get
(
)
MakeRefPtr
<
AudioInputSource
>
(
MakeRefPtr
<
AudioInputSourceListener
>
(
track
.
get
(
)
)
sourceId
deviceId
channels
true
PRINCIPAL_HANDLE_NONE
rate
graph
-
>
GraphRate
(
)
)
)
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
nonNativeStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
nonNativeStream
-
>
mHasInput
)
;
EXPECT_FALSE
(
nonNativeStream
-
>
mHasOutput
)
;
EXPECT_EQ
(
nonNativeStream
-
>
GetInputDeviceID
(
)
deviceId
)
;
EXPECT_EQ
(
nonNativeStream
-
>
InputChannels
(
)
channels
)
;
EXPECT_EQ
(
nonNativeStream
-
>
SampleRate
(
)
static_cast
<
uint32_t
>
(
rate
)
)
;
Unused
<
<
WaitFor
(
nonNativeStream
-
>
FramesProcessedEvent
(
)
)
;
DispatchFunction
(
[
&
]
{
nonNativeStream
-
>
ForceError
(
)
;
}
)
;
WaitFor
(
nonNativeStream
-
>
ErrorForcedEvent
(
)
)
;
RefPtr
<
SmartMockCubebStream
>
destroyedStream
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyedStream
.
get
(
)
nonNativeStream
.
get
(
)
)
;
}
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopNonNativeInput
>
(
track
.
get
(
)
)
)
;
}
)
;
DispatchFunction
(
[
&
]
{
track
-
>
Destroy
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
destroyedStream
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyedStream
.
get
(
)
driverStream
.
get
(
)
)
;
}
class
TestDeviceInputConsumerTrack
:
public
DeviceInputConsumerTrack
{
public
:
static
TestDeviceInputConsumerTrack
*
Create
(
MediaTrackGraph
*
aGraph
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
TestDeviceInputConsumerTrack
*
track
=
new
TestDeviceInputConsumerTrack
(
aGraph
-
>
GraphRate
(
)
)
;
aGraph
-
>
AddTrack
(
track
)
;
return
track
;
}
void
Destroy
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
DisconnectDeviceInput
(
)
;
DeviceInputConsumerTrack
:
:
Destroy
(
)
;
}
void
ProcessInput
(
GraphTime
aFrom
GraphTime
aTo
uint32_t
aFlags
)
override
{
if
(
aFrom
>
=
aTo
)
{
return
;
}
if
(
mInputs
.
IsEmpty
(
)
)
{
GetData
<
AudioSegment
>
(
)
-
>
AppendNullData
(
aTo
-
aFrom
)
;
}
else
{
MOZ_ASSERT
(
mInputs
.
Length
(
)
=
=
1
)
;
AudioSegment
data
;
DeviceInputConsumerTrack
:
:
GetInputSourceData
(
data
mInputs
[
0
]
aFrom
aTo
)
;
GetData
<
AudioSegment
>
(
)
-
>
AppendFrom
(
&
data
)
;
}
}
;
uint32_t
NumberOfChannels
(
)
const
override
{
if
(
mInputs
.
IsEmpty
(
)
)
{
return
0
;
}
DeviceInputTrack
*
t
=
mInputs
[
0
]
-
>
GetSource
(
)
-
>
AsDeviceInputTrack
(
)
;
MOZ_ASSERT
(
t
)
;
return
t
-
>
NumberOfChannels
(
)
;
}
private
:
explicit
TestDeviceInputConsumerTrack
(
TrackRate
aSampleRate
)
:
DeviceInputConsumerTrack
(
aSampleRate
)
{
}
}
;
TEST
(
TestAudioTrackGraph
DeviceChangedCallback
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graphImpl
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
class
TestAudioDataListener
:
public
AudioDataListener
{
public
:
TestAudioDataListener
(
uint32_t
aChannelCount
bool
aIsVoice
)
:
mChannelCount
(
aChannelCount
)
mIsVoice
(
aIsVoice
)
mDeviceChangedCount
(
0
)
{
}
uint32_t
RequestedInputChannelCount
(
MediaTrackGraph
*
aGraph
)
override
{
return
mChannelCount
;
}
bool
IsVoiceInput
(
MediaTrackGraph
*
aGraph
)
const
override
{
return
mIsVoice
;
}
;
void
DeviceChanged
(
MediaTrackGraph
*
aGraph
)
override
{
+
+
mDeviceChangedCount
;
}
void
Disconnect
(
MediaTrackGraph
*
aGraph
)
override
{
}
;
uint32_t
DeviceChangedCount
(
)
{
return
mDeviceChangedCount
;
}
private
:
~
TestAudioDataListener
(
)
=
default
;
const
uint32_t
mChannelCount
;
const
bool
mIsVoice
;
std
:
:
atomic
<
uint32_t
>
mDeviceChangedCount
;
}
;
const
CubebUtils
:
:
AudioDeviceID
device1
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
TestAudioDataListener
>
listener1
=
new
TestAudioDataListener
(
1
false
)
;
RefPtr
<
TestDeviceInputConsumerTrack
>
track1
=
TestDeviceInputConsumerTrack
:
:
Create
(
graphImpl
)
;
track1
-
>
ConnectDeviceInput
(
device1
listener1
.
get
(
)
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_TRUE
(
track1
-
>
ConnectToNativeDevice
(
)
)
;
EXPECT_FALSE
(
track1
-
>
ConnectToNonNativeDevice
(
)
)
;
auto
started
=
Invoke
(
[
&
]
{
return
graphImpl
-
>
NotifyWhenDeviceStarted
(
nullptr
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream1
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream1
-
>
mHasInput
)
;
EXPECT_TRUE
(
stream1
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream1
-
>
GetInputDeviceID
(
)
device1
)
;
Unused
<
<
WaitFor
(
started
)
;
const
CubebUtils
:
:
AudioDeviceID
device2
=
(
CubebUtils
:
:
AudioDeviceID
)
2
;
RefPtr
<
TestAudioDataListener
>
listener2
=
new
TestAudioDataListener
(
2
true
)
;
RefPtr
<
TestDeviceInputConsumerTrack
>
track2
=
TestDeviceInputConsumerTrack
:
:
Create
(
graphImpl
)
;
track2
-
>
ConnectDeviceInput
(
device2
listener2
.
get
(
)
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_FALSE
(
track2
-
>
ConnectToNativeDevice
(
)
)
;
EXPECT_TRUE
(
track2
-
>
ConnectToNonNativeDevice
(
)
)
;
RefPtr
<
SmartMockCubebStream
>
stream2
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream2
-
>
mHasInput
)
;
EXPECT_FALSE
(
stream2
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream2
-
>
GetInputDeviceID
(
)
device2
)
;
DispatchFunction
(
[
&
]
{
stream2
-
>
ForceDeviceChanged
(
)
;
}
)
;
WaitFor
(
stream2
-
>
DeviceChangeForcedEvent
(
)
)
;
DispatchFunction
(
[
&
]
{
stream1
-
>
ForceDeviceChanged
(
)
;
}
)
;
WaitFor
(
stream1
-
>
DeviceChangeForcedEvent
(
)
)
;
DispatchFunction
(
[
&
]
{
track2
-
>
DisconnectDeviceInput
(
)
;
track2
-
>
Destroy
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
destroyedStream
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyedStream
.
get
(
)
stream2
.
get
(
)
)
;
EXPECT_EQ
(
listener2
-
>
DeviceChangedCount
(
)
1U
)
;
DispatchFunction
(
[
&
]
{
track1
-
>
DisconnectDeviceInput
(
)
;
track1
-
>
Destroy
(
)
;
}
)
;
destroyedStream
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyedStream
.
get
(
)
stream1
.
get
(
)
)
;
EXPECT_EQ
(
listener1
-
>
DeviceChangedCount
(
)
1U
)
;
}
TEST
(
TestAudioTrackGraph
RestartAudioIfMaxChannelCountChanged
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
auto
unforcer
=
WaitFor
(
cubeb
-
>
ForceAudioThread
(
)
)
.
unwrap
(
)
;
Unused
<
<
unforcer
;
MediaTrackGraph
*
graphImpl
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
class
TestAudioDataListener
:
public
AudioDataListener
{
public
:
TestAudioDataListener
(
uint32_t
aChannelCount
bool
aIsVoice
)
:
mChannelCount
(
aChannelCount
)
mIsVoice
(
aIsVoice
)
{
}
void
SetInputChannelCount
(
MediaTrackGraph
*
aGraph
CubebUtils
:
:
AudioDeviceID
aDevice
uint32_t
aChannelCount
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
struct
Message
:
public
ControlMessage
{
MediaTrackGraph
*
mGraph
;
TestAudioDataListener
*
mListener
;
CubebUtils
:
:
AudioDeviceID
mDevice
;
uint32_t
mChannelCount
;
Message
(
MediaTrackGraph
*
aGraph
TestAudioDataListener
*
aListener
CubebUtils
:
:
AudioDeviceID
aDevice
uint32_t
aChannelCount
)
:
ControlMessage
(
nullptr
)
mGraph
(
aGraph
)
mListener
(
aListener
)
mDevice
(
aDevice
)
mChannelCount
(
aChannelCount
)
{
}
void
Run
(
)
override
{
mListener
-
>
mChannelCount
=
mChannelCount
;
mGraph
-
>
ReevaluateInputDevice
(
mDevice
)
;
}
}
;
static_cast
<
MediaTrackGraphImpl
*
>
(
aGraph
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
aGraph
this
aDevice
aChannelCount
)
)
;
}
uint32_t
RequestedInputChannelCount
(
MediaTrackGraph
*
aGraph
)
override
{
aGraph
-
>
AssertOnGraphThread
(
)
;
return
mChannelCount
;
}
bool
IsVoiceInput
(
MediaTrackGraph
*
aGraph
)
const
override
{
return
mIsVoice
;
}
;
void
DeviceChanged
(
MediaTrackGraph
*
aGraph
)
override
{
}
void
Disconnect
(
MediaTrackGraph
*
aGraph
)
override
{
}
;
private
:
~
TestAudioDataListener
(
)
=
default
;
uint32_t
mChannelCount
;
const
bool
mIsVoice
;
}
;
auto
setNewChannelCount
=
[
&
]
(
const
RefPtr
<
TestAudioDataListener
>
&
aListener
RefPtr
<
SmartMockCubebStream
>
&
aStream
uint32_t
aChannelCount
)
{
ASSERT_TRUE
(
!
!
aListener
)
;
ASSERT_TRUE
(
!
!
aStream
)
;
ASSERT_TRUE
(
aStream
-
>
mHasInput
)
;
ASSERT_NE
(
aChannelCount
0U
)
;
const
CubebUtils
:
:
AudioDeviceID
device
=
aStream
-
>
GetInputDeviceID
(
)
;
bool
destroyed
=
false
;
MediaEventListener
destroyListener
=
cubeb
-
>
StreamDestroyEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aDestroyed
)
{
destroyed
=
aDestroyed
.
get
(
)
=
=
aStream
.
get
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
newStream
;
MediaEventListener
restartListener
=
cubeb
-
>
StreamInitEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aCreated
)
{
newStream
=
aCreated
;
}
)
;
DispatchFunction
(
[
&
]
{
aListener
-
>
SetInputChannelCount
(
graphImpl
device
aChannelCount
)
;
}
)
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
TEST
(
TestAudioTrackGraph
RestartAudioIfMaxChannelCountChanged
)
#
1
"
_ns
[
&
]
{
return
destroyed
&
&
newStream
;
}
)
;
destroyListener
.
Disconnect
(
)
;
restartListener
.
Disconnect
(
)
;
aStream
=
newStream
;
}
;
auto
openTrack
=
[
&
]
(
RefPtr
<
SmartMockCubebStream
>
&
aCurrentStream
RefPtr
<
TestDeviceInputConsumerTrack
>
&
aTrack
const
RefPtr
<
TestAudioDataListener
>
&
aListener
CubebUtils
:
:
AudioDeviceID
aDevice
)
{
ASSERT_TRUE
(
!
!
aCurrentStream
)
;
ASSERT_TRUE
(
aCurrentStream
-
>
mHasInput
)
;
ASSERT_TRUE
(
!
aTrack
)
;
ASSERT_TRUE
(
!
!
aListener
)
;
bool
destroyed
=
false
;
MediaEventListener
destroyListener
=
cubeb
-
>
StreamDestroyEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aDestroyed
)
{
destroyed
=
aDestroyed
.
get
(
)
=
=
aCurrentStream
.
get
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
newStream
;
MediaEventListener
restartListener
=
cubeb
-
>
StreamInitEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aCreated
)
{
newStream
=
aCreated
;
}
)
;
aTrack
=
TestDeviceInputConsumerTrack
:
:
Create
(
graphImpl
)
;
aTrack
-
>
ConnectDeviceInput
(
aDevice
aListener
.
get
(
)
PRINCIPAL_HANDLE_NONE
)
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
TEST
(
TestAudioTrackGraph
RestartAudioIfMaxChannelCountChanged
)
#
2
"
_ns
[
&
]
{
return
destroyed
&
&
newStream
;
}
)
;
destroyListener
.
Disconnect
(
)
;
restartListener
.
Disconnect
(
)
;
aCurrentStream
=
newStream
;
}
;
const
CubebUtils
:
:
AudioDeviceID
nativeDevice
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
TestDeviceInputConsumerTrack
>
track1
;
RefPtr
<
TestAudioDataListener
>
listener1
;
RefPtr
<
SmartMockCubebStream
>
nativeStream
;
RefPtr
<
TestDeviceInputConsumerTrack
>
track2
;
RefPtr
<
TestAudioDataListener
>
listener2
;
{
listener1
=
new
TestAudioDataListener
(
1
false
)
;
track1
=
TestDeviceInputConsumerTrack
:
:
Create
(
graphImpl
)
;
track1
-
>
ConnectDeviceInput
(
nativeDevice
listener1
.
get
(
)
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_TRUE
(
track1
-
>
ConnectToNativeDevice
(
)
)
;
EXPECT_FALSE
(
track1
-
>
ConnectToNonNativeDevice
(
)
)
;
auto
started
=
Invoke
(
[
&
]
{
return
graphImpl
-
>
NotifyWhenDeviceStarted
(
nullptr
)
;
}
)
;
nativeStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
nativeStream
-
>
mHasInput
)
;
EXPECT_TRUE
(
nativeStream
-
>
mHasOutput
)
;
EXPECT_EQ
(
nativeStream
-
>
GetInputDeviceID
(
)
nativeDevice
)
;
Unused
<
<
WaitFor
(
started
)
;
listener2
=
new
TestAudioDataListener
(
2
false
)
;
openTrack
(
nativeStream
track2
listener2
nativeDevice
)
;
EXPECT_EQ
(
nativeStream
-
>
InputChannels
(
)
2U
)
;
setNewChannelCount
(
listener2
nativeStream
1
)
;
EXPECT_EQ
(
nativeStream
-
>
InputChannels
(
)
1U
)
;
setNewChannelCount
(
listener1
nativeStream
2
)
;
EXPECT_EQ
(
nativeStream
-
>
InputChannels
(
)
2U
)
;
}
{
const
CubebUtils
:
:
AudioDeviceID
nonNativeDevice
=
(
CubebUtils
:
:
AudioDeviceID
)
2
;
RefPtr
<
TestAudioDataListener
>
listener3
=
new
TestAudioDataListener
(
1
false
)
;
RefPtr
<
TestDeviceInputConsumerTrack
>
track3
=
TestDeviceInputConsumerTrack
:
:
Create
(
graphImpl
)
;
track3
-
>
ConnectDeviceInput
(
nonNativeDevice
listener3
.
get
(
)
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_FALSE
(
track3
-
>
ConnectToNativeDevice
(
)
)
;
EXPECT_TRUE
(
track3
-
>
ConnectToNonNativeDevice
(
)
)
;
RefPtr
<
SmartMockCubebStream
>
nonNativeStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
nonNativeStream
-
>
mHasInput
)
;
EXPECT_FALSE
(
nonNativeStream
-
>
mHasOutput
)
;
EXPECT_EQ
(
nonNativeStream
-
>
GetInputDeviceID
(
)
nonNativeDevice
)
;
EXPECT_EQ
(
nonNativeStream
-
>
InputChannels
(
)
1U
)
;
RefPtr
<
TestAudioDataListener
>
listener4
=
new
TestAudioDataListener
(
2
false
)
;
RefPtr
<
TestDeviceInputConsumerTrack
>
track4
;
openTrack
(
nonNativeStream
track4
listener4
nonNativeDevice
)
;
EXPECT_EQ
(
nonNativeStream
-
>
InputChannels
(
)
2U
)
;
EXPECT_EQ
(
nonNativeStream
-
>
GetInputDeviceID
(
)
nonNativeDevice
)
;
setNewChannelCount
(
listener4
nonNativeStream
1
)
;
EXPECT_EQ
(
nonNativeStream
-
>
InputChannels
(
)
1U
)
;
setNewChannelCount
(
listener3
nonNativeStream
2
)
;
EXPECT_EQ
(
nonNativeStream
-
>
InputChannels
(
)
2U
)
;
DispatchFunction
(
[
&
]
{
track4
-
>
DisconnectDeviceInput
(
)
;
track4
-
>
Destroy
(
)
;
}
)
;
DispatchFunction
(
[
&
]
{
track3
-
>
DisconnectDeviceInput
(
)
;
track3
-
>
Destroy
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
destroyedStream
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyedStream
.
get
(
)
nonNativeStream
.
get
(
)
)
;
}
{
DispatchFunction
(
[
&
]
{
track2
-
>
DisconnectDeviceInput
(
)
;
track2
-
>
Destroy
(
)
;
}
)
;
DispatchFunction
(
[
&
]
{
track1
-
>
DisconnectDeviceInput
(
)
;
track1
-
>
Destroy
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
destroyedStream
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyedStream
.
get
(
)
nativeStream
.
get
(
)
)
;
}
}
TEST
(
TestAudioTrackGraph
SwitchNativeInputDevice
)
{
class
TestAudioDataListener
:
public
AudioDataListener
{
public
:
TestAudioDataListener
(
uint32_t
aChannelCount
bool
aIsVoice
)
:
mChannelCount
(
aChannelCount
)
mIsVoice
(
aIsVoice
)
mDeviceChangedCount
(
0
)
{
}
uint32_t
RequestedInputChannelCount
(
MediaTrackGraph
*
aGraph
)
override
{
return
mChannelCount
;
}
bool
IsVoiceInput
(
MediaTrackGraph
*
aGraph
)
const
override
{
return
mIsVoice
;
}
;
void
DeviceChanged
(
MediaTrackGraph
*
aGraph
)
override
{
+
+
mDeviceChangedCount
;
}
void
Disconnect
(
MediaTrackGraph
*
aGraph
)
override
{
}
;
uint32_t
DeviceChangedCount
(
)
{
return
mDeviceChangedCount
;
}
private
:
~
TestAudioDataListener
(
)
=
default
;
const
uint32_t
mChannelCount
;
const
bool
mIsVoice
;
std
:
:
atomic
<
uint32_t
>
mDeviceChangedCount
;
}
;
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
auto
switchNativeDevice
=
[
&
]
(
RefPtr
<
SmartMockCubebStream
>
&
&
aCurrentNativeStream
RefPtr
<
TestDeviceInputConsumerTrack
>
&
aCurrentNativeTrack
RefPtr
<
SmartMockCubebStream
>
&
aNextNativeStream
RefPtr
<
TestDeviceInputConsumerTrack
>
&
aNextNativeTrack
)
{
ASSERT_TRUE
(
aCurrentNativeStream
-
>
mHasInput
)
;
ASSERT_TRUE
(
aCurrentNativeStream
-
>
mHasOutput
)
;
ASSERT_TRUE
(
aNextNativeStream
-
>
mHasInput
)
;
ASSERT_FALSE
(
aNextNativeStream
-
>
mHasOutput
)
;
std
:
:
cerr
<
<
"
Switching
native
input
from
device
"
<
<
aCurrentNativeStream
-
>
GetInputDeviceID
(
)
<
<
"
to
"
<
<
aNextNativeStream
-
>
GetInputDeviceID
(
)
<
<
std
:
:
endl
;
uint32_t
destroyed
=
0
;
MediaEventListener
destroyListener
=
cubeb
-
>
StreamDestroyEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aDestroyed
)
{
if
(
aDestroyed
.
get
(
)
=
=
aCurrentNativeStream
.
get
(
)
|
|
aDestroyed
.
get
(
)
=
=
aNextNativeStream
.
get
(
)
)
{
std
:
:
cerr
<
<
"
cubeb
stream
"
<
<
aDestroyed
.
get
(
)
<
<
"
(
device
"
<
<
aDestroyed
-
>
GetInputDeviceID
(
)
<
<
"
)
has
been
destroyed
"
<
<
std
:
:
endl
;
destroyed
+
=
1
;
}
}
)
;
RefPtr
<
SmartMockCubebStream
>
newStream
;
MediaEventListener
restartListener
=
cubeb
-
>
StreamInitEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aCreated
)
{
if
(
aCreated
-
>
mHasInput
)
{
ASSERT_TRUE
(
aCreated
-
>
mHasOutput
)
;
newStream
=
aCreated
;
}
}
)
;
std
:
:
cerr
<
<
"
Close
device
"
<
<
aCurrentNativeStream
-
>
GetInputDeviceID
(
)
<
<
std
:
:
endl
;
DispatchFunction
(
[
&
]
{
aCurrentNativeTrack
-
>
DisconnectDeviceInput
(
)
;
aCurrentNativeTrack
-
>
Destroy
(
)
;
}
)
;
std
:
:
cerr
<
<
"
Wait
for
the
switching
"
<
<
std
:
:
endl
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
TEST
(
TestAudioTrackGraph
SwitchNativeInputDevice
)
"
_ns
[
&
]
{
return
destroyed
>
=
2
&
&
newStream
;
}
)
;
destroyListener
.
Disconnect
(
)
;
restartListener
.
Disconnect
(
)
;
aCurrentNativeStream
=
nullptr
;
aNextNativeStream
=
newStream
;
std
:
:
cerr
<
<
"
Now
the
native
input
is
device
"
<
<
aNextNativeStream
-
>
GetInputDeviceID
(
)
<
<
std
:
:
endl
;
}
;
const
CubebUtils
:
:
AudioDeviceID
device1
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
TestDeviceInputConsumerTrack
>
track1
=
TestDeviceInputConsumerTrack
:
:
Create
(
graph
)
;
RefPtr
<
TestAudioDataListener
>
listener1
=
new
TestAudioDataListener
(
1
false
)
;
track1
-
>
ConnectDeviceInput
(
device1
listener1
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_EQ
(
track1
-
>
DeviceId
(
)
.
value
(
)
device1
)
;
auto
started
=
Invoke
(
[
&
]
{
return
graph
-
>
NotifyWhenDeviceStarted
(
nullptr
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream1
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream1
-
>
mHasInput
)
;
EXPECT_TRUE
(
stream1
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream1
-
>
InputChannels
(
)
1U
)
;
EXPECT_EQ
(
stream1
-
>
GetInputDeviceID
(
)
device1
)
;
Unused
<
<
WaitFor
(
started
)
;
std
:
:
cerr
<
<
"
Device
"
<
<
device1
<
<
"
is
opened
(
stream
"
<
<
stream1
.
get
(
)
<
<
"
)
"
<
<
std
:
:
endl
;
const
CubebUtils
:
:
AudioDeviceID
device2
=
(
CubebUtils
:
:
AudioDeviceID
)
2
;
RefPtr
<
TestDeviceInputConsumerTrack
>
track2
=
TestDeviceInputConsumerTrack
:
:
Create
(
graph
)
;
RefPtr
<
TestAudioDataListener
>
listener2
=
new
TestAudioDataListener
(
2
false
)
;
track2
-
>
ConnectDeviceInput
(
device2
listener2
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_EQ
(
track2
-
>
DeviceId
(
)
.
value
(
)
device2
)
;
RefPtr
<
SmartMockCubebStream
>
stream2
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream2
-
>
mHasInput
)
;
EXPECT_FALSE
(
stream2
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream2
-
>
InputChannels
(
)
2U
)
;
EXPECT_EQ
(
stream2
-
>
GetInputDeviceID
(
)
device2
)
;
std
:
:
cerr
<
<
"
Device
"
<
<
device2
<
<
"
is
opened
(
stream
"
<
<
stream2
.
get
(
)
<
<
"
)
"
<
<
std
:
:
endl
;
const
CubebUtils
:
:
AudioDeviceID
device3
=
(
CubebUtils
:
:
AudioDeviceID
)
3
;
RefPtr
<
TestDeviceInputConsumerTrack
>
track3
=
TestDeviceInputConsumerTrack
:
:
Create
(
graph
)
;
RefPtr
<
TestAudioDataListener
>
listener3
=
new
TestAudioDataListener
(
1
false
)
;
track3
-
>
ConnectDeviceInput
(
device3
listener3
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_EQ
(
track3
-
>
DeviceId
(
)
.
value
(
)
device3
)
;
RefPtr
<
SmartMockCubebStream
>
stream3
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream3
-
>
mHasInput
)
;
EXPECT_FALSE
(
stream3
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream3
-
>
InputChannels
(
)
1U
)
;
EXPECT_EQ
(
stream3
-
>
GetInputDeviceID
(
)
device3
)
;
std
:
:
cerr
<
<
"
Device
"
<
<
device3
<
<
"
is
opened
(
stream
"
<
<
stream3
.
get
(
)
<
<
"
)
"
<
<
std
:
:
endl
;
switchNativeDevice
(
std
:
:
move
(
stream1
)
track1
stream2
track2
)
;
EXPECT_TRUE
(
stream2
-
>
mHasInput
)
;
EXPECT_TRUE
(
stream2
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream2
-
>
InputChannels
(
)
2U
)
;
EXPECT_EQ
(
stream2
-
>
GetInputDeviceID
(
)
device2
)
;
{
NativeInputTrack
*
native
=
track2
-
>
Graph
(
)
-
>
GetNativeInputTrackMainThread
(
)
;
ASSERT_TRUE
(
!
!
native
)
;
EXPECT_EQ
(
native
-
>
mDeviceId
device2
)
;
}
switchNativeDevice
(
std
:
:
move
(
stream2
)
track2
stream3
track3
)
;
EXPECT_TRUE
(
stream3
-
>
mHasInput
)
;
EXPECT_TRUE
(
stream3
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream3
-
>
InputChannels
(
)
1U
)
;
EXPECT_EQ
(
stream3
-
>
GetInputDeviceID
(
)
device3
)
;
{
NativeInputTrack
*
native
=
track3
-
>
Graph
(
)
-
>
GetNativeInputTrackMainThread
(
)
;
ASSERT_TRUE
(
!
!
native
)
;
EXPECT_EQ
(
native
-
>
mDeviceId
device3
)
;
}
std
:
:
cerr
<
<
"
Close
device
"
<
<
device3
<
<
std
:
:
endl
;
DispatchFunction
(
[
&
]
{
track3
-
>
DisconnectDeviceInput
(
)
;
track3
-
>
Destroy
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
destroyedStream
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyedStream
.
get
(
)
stream3
.
get
(
)
)
;
{
NativeInputTrack
*
native
=
graph
-
>
GetNativeInputTrackMainThread
(
)
;
ASSERT_TRUE
(
!
native
)
;
}
std
:
:
cerr
<
<
"
No
native
input
now
"
<
<
std
:
:
endl
;
}
#
ifdef
MOZ_WEBRTC
TEST
(
TestAudioTrackGraph
ErrorCallback
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
AudioProcessingTrack
>
processingTrack
;
RefPtr
<
AudioInputProcessing
>
listener
;
auto
started
=
Invoke
(
[
&
]
{
processingTrack
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
listener
=
new
AudioInputProcessing
(
2
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
processingTrack
listener
true
)
)
;
processingTrack
-
>
SetInputProcessing
(
listener
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
processingTrack
listener
)
)
;
processingTrack
-
>
ConnectDeviceInput
(
deviceId
listener
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_EQ
(
processingTrack
-
>
DeviceId
(
)
.
value
(
)
deviceId
)
;
processingTrack
-
>
AddAudioOutput
(
reinterpret_cast
<
void
*
>
(
1
)
nullptr
)
;
return
graph
-
>
NotifyWhenDeviceStarted
(
nullptr
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
Result
<
bool
nsresult
>
rv
=
WaitFor
(
started
)
;
EXPECT_TRUE
(
rv
.
unwrapOr
(
false
)
)
;
DispatchFunction
(
[
&
]
{
stream
-
>
ForceError
(
)
;
}
)
;
bool
errored
=
false
;
MediaEventListener
errorListener
=
stream
-
>
ErrorForcedEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
{
errored
=
true
;
}
)
;
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
WaitFor
(
stream
-
>
FramesVerifiedEvent
(
)
)
;
errorListener
.
Disconnect
(
)
;
EXPECT_TRUE
(
errored
)
;
DispatchFunction
(
[
&
]
{
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
processingTrack
listener
)
)
;
processingTrack
-
>
DisconnectDeviceInput
(
)
;
processingTrack
-
>
Destroy
(
)
;
}
)
;
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
}
TEST
(
TestAudioTrackGraph
AudioProcessingTrack
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
auto
unforcer
=
WaitFor
(
cubeb
-
>
ForceAudioThread
(
)
)
.
unwrap
(
)
;
Unused
<
<
unforcer
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
AudioProcessingTrack
>
processingTrack
;
RefPtr
<
ProcessedMediaTrack
>
outputTrack
;
RefPtr
<
MediaInputPort
>
port
;
RefPtr
<
AudioInputProcessing
>
listener
;
auto
p
=
Invoke
(
[
&
]
{
processingTrack
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
outputTrack
=
graph
-
>
CreateForwardedInputTrack
(
MediaSegment
:
:
AUDIO
)
;
outputTrack
-
>
QueueSetAutoend
(
false
)
;
outputTrack
-
>
AddAudioOutput
(
reinterpret_cast
<
void
*
>
(
1
)
nullptr
)
;
port
=
outputTrack
-
>
AllocateInputPort
(
processingTrack
)
;
listener
=
new
AudioInputProcessing
(
2
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
processingTrack
listener
true
)
)
;
processingTrack
-
>
SetInputProcessing
(
listener
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
processingTrack
listener
)
)
;
processingTrack
-
>
ConnectDeviceInput
(
deviceId
listener
PRINCIPAL_HANDLE_NONE
)
;
return
graph
-
>
NotifyWhenDeviceStarted
(
nullptr
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
Unused
<
<
WaitFor
(
p
)
;
DispatchFunction
(
[
&
]
{
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
uint32_t
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesVerifiedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
cubeb
-
>
DontGoFaster
(
)
;
DispatchFunction
(
[
&
]
{
outputTrack
-
>
RemoveAudioOutput
(
(
void
*
)
1
)
;
outputTrack
-
>
Destroy
(
)
;
port
-
>
Destroy
(
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
processingTrack
listener
)
)
;
processingTrack
-
>
DisconnectDeviceInput
(
)
;
processingTrack
-
>
Destroy
(
)
;
}
)
;
uint32_t
inputRate
=
stream
-
>
SampleRate
(
)
;
uint32_t
inputFrequency
=
stream
-
>
InputFrequency
(
)
;
uint64_t
preSilenceSamples
;
uint32_t
estimatedFreq
;
uint32_t
nrDiscontinuities
;
std
:
:
tie
(
preSilenceSamples
estimatedFreq
nrDiscontinuities
)
=
WaitFor
(
stream
-
>
OutputVerificationEvent
(
)
)
;
EXPECT_EQ
(
estimatedFreq
inputFrequency
)
;
std
:
:
cerr
<
<
"
PreSilence
:
"
<
<
preSilenceSamples
<
<
std
:
:
endl
;
EXPECT_GE
(
preSilenceSamples
128U
)
;
EXPECT_LE
(
preSilenceSamples
128U
+
2
*
inputRate
/
100
)
;
EXPECT_LE
(
nrDiscontinuities
1U
)
;
}
TEST
(
TestAudioTrackGraph
ReConnectDeviceInput
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
const
TrackRate
rate
=
48000
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
rate
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
AudioProcessingTrack
>
processingTrack
;
RefPtr
<
ProcessedMediaTrack
>
outputTrack
;
RefPtr
<
MediaInputPort
>
port
;
RefPtr
<
AudioInputProcessing
>
listener
;
auto
p
=
Invoke
(
[
&
]
{
processingTrack
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
outputTrack
=
graph
-
>
CreateForwardedInputTrack
(
MediaSegment
:
:
AUDIO
)
;
outputTrack
-
>
QueueSetAutoend
(
false
)
;
outputTrack
-
>
AddAudioOutput
(
reinterpret_cast
<
void
*
>
(
1
)
nullptr
)
;
port
=
outputTrack
-
>
AllocateInputPort
(
processingTrack
)
;
listener
=
new
AudioInputProcessing
(
2
)
;
processingTrack
-
>
SetInputProcessing
(
listener
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
processingTrack
listener
)
)
;
processingTrack
-
>
ConnectDeviceInput
(
deviceId
listener
PRINCIPAL_HANDLE_NONE
)
;
return
graph
-
>
NotifyWhenDeviceStarted
(
nullptr
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
Unused
<
<
WaitFor
(
p
)
;
stream
-
>
SetDriftFactor
(
1
.
111
)
;
DispatchFunction
(
[
&
]
{
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
{
uint32_t
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesProcessedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
}
cubeb
-
>
DontGoFaster
(
)
;
DispatchFunction
(
[
&
]
{
processingTrack
-
>
DisconnectDeviceInput
(
)
;
}
)
;
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_FALSE
(
stream
-
>
mHasInput
)
;
Unused
<
<
WaitFor
(
Invoke
(
[
&
]
{
return
graph
-
>
NotifyWhenDeviceStarted
(
nullptr
)
;
}
)
)
;
DispatchFunction
(
[
&
]
{
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
{
uint32_t
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesProcessedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
}
cubeb
-
>
DontGoFaster
(
)
;
DispatchFunction
(
[
&
]
{
processingTrack
-
>
ConnectDeviceInput
(
deviceId
listener
PRINCIPAL_HANDLE_NONE
)
;
}
)
;
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
Unused
<
<
WaitFor
(
Invoke
(
[
&
]
{
return
graph
-
>
NotifyWhenDeviceStarted
(
nullptr
)
;
}
)
)
;
DispatchFunction
(
[
&
]
{
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
{
uint32_t
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesProcessedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
}
cubeb
-
>
DontGoFaster
(
)
;
DispatchFunction
(
[
&
]
{
outputTrack
-
>
RemoveAudioOutput
(
(
void
*
)
1
)
;
outputTrack
-
>
Destroy
(
)
;
port
-
>
Destroy
(
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
processingTrack
listener
)
)
;
processingTrack
-
>
DisconnectDeviceInput
(
)
;
processingTrack
-
>
Destroy
(
)
;
}
)
;
uint32_t
inputRate
=
stream
-
>
SampleRate
(
)
;
uint32_t
inputFrequency
=
stream
-
>
InputFrequency
(
)
;
uint64_t
preSilenceSamples
;
uint32_t
estimatedFreq
;
uint32_t
nrDiscontinuities
;
std
:
:
tie
(
preSilenceSamples
estimatedFreq
nrDiscontinuities
)
=
WaitFor
(
stream
-
>
OutputVerificationEvent
(
)
)
;
EXPECT_EQ
(
estimatedFreq
inputFrequency
)
;
std
:
:
cerr
<
<
"
PreSilence
:
"
<
<
preSilenceSamples
<
<
std
:
:
endl
;
EXPECT_GE
(
preSilenceSamples
128U
+
inputRate
/
100
)
;
EXPECT_LE
(
preSilenceSamples
128U
+
3
*
inputRate
/
100
)
;
EXPECT_LE
(
nrDiscontinuities
1U
)
;
}
float
rmsf32
(
AudioDataValue
*
aSamples
uint32_t
aChannels
uint32_t
aFrames
)
{
float
downmixed
;
float
rms
=
0
.
;
uint32_t
readIdx
=
0
;
for
(
uint32_t
i
=
0
;
i
<
aFrames
;
i
+
+
)
{
downmixed
=
0
.
;
for
(
uint32_t
j
=
0
;
j
<
aChannels
;
j
+
+
)
{
downmixed
+
=
ConvertAudioSample
<
float
>
(
aSamples
[
readIdx
+
+
]
)
;
}
rms
+
=
downmixed
*
downmixed
;
}
rms
=
rms
/
aFrames
;
return
sqrt
(
rms
)
;
}
TEST
(
TestAudioTrackGraph
AudioProcessingTrackDisabling
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
AudioProcessingTrack
>
processingTrack
;
RefPtr
<
ProcessedMediaTrack
>
outputTrack
;
RefPtr
<
MediaInputPort
>
port
;
RefPtr
<
AudioInputProcessing
>
listener
;
auto
p
=
Invoke
(
[
&
]
{
processingTrack
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
outputTrack
=
graph
-
>
CreateForwardedInputTrack
(
MediaSegment
:
:
AUDIO
)
;
outputTrack
-
>
QueueSetAutoend
(
false
)
;
outputTrack
-
>
AddAudioOutput
(
reinterpret_cast
<
void
*
>
(
1
)
nullptr
)
;
port
=
outputTrack
-
>
AllocateInputPort
(
processingTrack
)
;
listener
=
new
AudioInputProcessing
(
2
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
processingTrack
listener
true
)
)
;
processingTrack
-
>
SetInputProcessing
(
listener
)
;
processingTrack
-
>
ConnectDeviceInput
(
deviceId
listener
PRINCIPAL_HANDLE_NONE
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
processingTrack
listener
)
)
;
return
graph
-
>
NotifyWhenDeviceStarted
(
nullptr
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
Unused
<
<
WaitFor
(
p
)
;
stream
-
>
SetOutputRecordingEnabled
(
true
)
;
uint64_t
targetPosition
=
graph
-
>
GraphRate
(
)
;
auto
AdvanceToTargetPosition
=
[
&
]
{
DispatchFunction
(
[
&
]
{
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
WaitUntil
(
stream
-
>
FramesProcessedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
if
(
stream
-
>
Position
(
)
<
targetPosition
)
{
return
false
;
}
cubeb
-
>
DontGoFaster
(
)
;
return
true
;
}
)
;
}
;
AdvanceToTargetPosition
(
)
;
const
uint32_t
ITERATION_COUNT
=
5
;
uint32_t
iterations
=
ITERATION_COUNT
;
DisabledTrackMode
nextMode
=
DisabledTrackMode
:
:
SILENCE_BLACK
;
while
(
iterations
-
-
)
{
DispatchFunction
(
[
&
]
{
processingTrack
-
>
SetDisabledTrackMode
(
nextMode
)
;
if
(
nextMode
=
=
DisabledTrackMode
:
:
SILENCE_BLACK
)
{
nextMode
=
DisabledTrackMode
:
:
ENABLED
;
}
else
{
nextMode
=
DisabledTrackMode
:
:
SILENCE_BLACK
;
}
}
)
;
targetPosition
+
=
graph
-
>
GraphRate
(
)
;
AdvanceToTargetPosition
(
)
;
}
DispatchFunction
(
[
&
]
{
outputTrack
-
>
RemoveAudioOutput
(
(
void
*
)
1
)
;
outputTrack
-
>
Destroy
(
)
;
port
-
>
Destroy
(
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
processingTrack
listener
)
)
;
processingTrack
-
>
DisconnectDeviceInput
(
)
;
processingTrack
-
>
Destroy
(
)
;
}
)
;
uint64_t
preSilenceSamples
;
uint32_t
estimatedFreq
;
uint32_t
nrDiscontinuities
;
std
:
:
tie
(
preSilenceSamples
estimatedFreq
nrDiscontinuities
)
=
WaitFor
(
stream
-
>
OutputVerificationEvent
(
)
)
;
auto
data
=
stream
-
>
TakeRecordedOutput
(
)
;
float
noisyTime_s
[
]
=
{
0
.
5
2
.
5
4
.
5
}
;
float
silenceTime_s
[
]
=
{
1
.
5
3
.
5
5
.
5
}
;
uint32_t
rate
=
graph
-
>
GraphRate
(
)
;
for
(
float
&
time
:
noisyTime_s
)
{
uint32_t
startIdx
=
time
*
rate
*
2
;
EXPECT_NE
(
rmsf32
(
&
(
data
[
startIdx
]
)
2
rate
/
10
)
0
.
0
)
;
}
for
(
float
&
time
:
silenceTime_s
)
{
uint32_t
startIdx
=
time
*
rate
*
2
;
EXPECT_EQ
(
rmsf32
(
&
(
data
[
startIdx
]
)
2
rate
/
10
)
0
.
0
)
;
}
}
TEST
(
TestAudioTrackGraph
SetRequestedInputChannelCount
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
const
CubebUtils
:
:
AudioDeviceID
device1
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
AudioProcessingTrack
>
track1
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
RefPtr
<
AudioInputProcessing
>
listener1
=
new
AudioInputProcessing
(
2
)
;
track1
-
>
SetInputProcessing
(
listener1
)
;
track1
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
track1
listener1
true
)
)
;
track1
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
track1
listener1
)
)
;
track1
-
>
ConnectDeviceInput
(
device1
listener1
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_EQ
(
track1
-
>
DeviceId
(
)
.
value
(
)
device1
)
;
auto
started
=
Invoke
(
[
&
]
{
return
graph
-
>
NotifyWhenDeviceStarted
(
nullptr
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream1
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream1
-
>
mHasInput
)
;
EXPECT_TRUE
(
stream1
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream1
-
>
InputChannels
(
)
2U
)
;
EXPECT_EQ
(
stream1
-
>
GetInputDeviceID
(
)
device1
)
;
Unused
<
<
WaitFor
(
started
)
;
const
CubebUtils
:
:
AudioDeviceID
device2
=
(
CubebUtils
:
:
AudioDeviceID
)
2
;
RefPtr
<
AudioProcessingTrack
>
track2
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
RefPtr
<
AudioInputProcessing
>
listener2
=
new
AudioInputProcessing
(
1
)
;
track2
-
>
SetInputProcessing
(
listener2
)
;
track2
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
track2
listener2
true
)
)
;
track2
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
track2
listener2
)
)
;
track2
-
>
ConnectDeviceInput
(
device2
listener2
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_EQ
(
track2
-
>
DeviceId
(
)
.
value
(
)
device2
)
;
RefPtr
<
SmartMockCubebStream
>
stream2
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream2
-
>
mHasInput
)
;
EXPECT_FALSE
(
stream2
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream2
-
>
InputChannels
(
)
1U
)
;
EXPECT_EQ
(
stream2
-
>
GetInputDeviceID
(
)
device2
)
;
auto
setNewChannelCount
=
[
&
]
(
const
RefPtr
<
AudioProcessingTrack
>
aTrack
const
RefPtr
<
AudioInputProcessing
>
&
aListener
RefPtr
<
SmartMockCubebStream
>
&
aStream
uint32_t
aChannelCount
)
{
bool
destroyed
=
false
;
MediaEventListener
destroyListener
=
cubeb
-
>
StreamDestroyEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aDestroyed
)
{
destroyed
=
aDestroyed
.
get
(
)
=
=
aStream
.
get
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
newStream
;
MediaEventListener
restartListener
=
cubeb
-
>
StreamInitEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aCreated
)
{
newStream
=
aCreated
;
}
)
;
DispatchFunction
(
[
&
]
{
aTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetRequestedInputChannelCount
>
(
aTrack
*
aTrack
-
>
DeviceId
(
)
aListener
aChannelCount
)
)
;
}
)
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
TEST
(
TestAudioTrackGraph
SetRequestedInputChannelCount
)
"
_ns
[
&
]
{
return
destroyed
&
&
newStream
;
}
)
;
destroyListener
.
Disconnect
(
)
;
restartListener
.
Disconnect
(
)
;
aStream
=
newStream
;
}
;
setNewChannelCount
(
track1
listener1
stream1
1
)
;
EXPECT_TRUE
(
stream1
-
>
mHasInput
)
;
EXPECT_TRUE
(
stream1
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream1
-
>
InputChannels
(
)
1U
)
;
EXPECT_EQ
(
stream1
-
>
GetInputDeviceID
(
)
device1
)
;
setNewChannelCount
(
track2
listener2
stream2
2
)
;
EXPECT_TRUE
(
stream2
-
>
mHasInput
)
;
EXPECT_FALSE
(
stream2
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream2
-
>
InputChannels
(
)
2U
)
;
EXPECT_EQ
(
stream2
-
>
GetInputDeviceID
(
)
device2
)
;
DispatchFunction
(
[
&
]
{
track2
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
track2
listener2
)
)
;
track2
-
>
DisconnectDeviceInput
(
)
;
track2
-
>
Destroy
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
destroyed
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyed
.
get
(
)
stream2
.
get
(
)
)
;
DispatchFunction
(
[
&
]
{
track1
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
track1
listener1
)
)
;
track1
-
>
DisconnectDeviceInput
(
)
;
track1
-
>
Destroy
(
)
;
}
)
;
destroyed
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyed
.
get
(
)
stream1
.
get
(
)
)
;
}
TEST
(
TestAudioTrackGraph
RestartAudioIfProcessingMaxChannelCountChanged
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
auto
unforcer
=
WaitFor
(
cubeb
-
>
ForceAudioThread
(
)
)
.
unwrap
(
)
;
Unused
<
<
unforcer
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
auto
setNewChannelCount
=
[
&
]
(
const
RefPtr
<
AudioProcessingTrack
>
&
aTrack
const
RefPtr
<
AudioInputProcessing
>
&
aListener
RefPtr
<
SmartMockCubebStream
>
&
aStream
uint32_t
aChannelCount
)
{
ASSERT_TRUE
(
!
!
aTrack
)
;
ASSERT_TRUE
(
!
!
aListener
)
;
ASSERT_TRUE
(
!
!
aStream
)
;
ASSERT_TRUE
(
aStream
-
>
mHasInput
)
;
ASSERT_NE
(
aChannelCount
0U
)
;
const
CubebUtils
:
:
AudioDeviceID
device
=
*
aTrack
-
>
DeviceId
(
)
;
bool
destroyed
=
false
;
MediaEventListener
destroyListener
=
cubeb
-
>
StreamDestroyEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aDestroyed
)
{
destroyed
=
aDestroyed
.
get
(
)
=
=
aStream
.
get
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
newStream
;
MediaEventListener
restartListener
=
cubeb
-
>
StreamInitEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aCreated
)
{
newStream
=
aCreated
;
}
)
;
DispatchFunction
(
[
&
]
{
aTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetRequestedInputChannelCount
>
(
aTrack
device
aListener
aChannelCount
)
)
;
}
)
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
TEST
(
TestAudioTrackGraph
RestartAudioIfProcessingMaxChannelCountChanged
)
#
1
"
_ns
[
&
]
{
return
destroyed
&
&
newStream
;
}
)
;
destroyListener
.
Disconnect
(
)
;
restartListener
.
Disconnect
(
)
;
aStream
=
newStream
;
}
;
auto
openTrack
=
[
&
]
(
RefPtr
<
SmartMockCubebStream
>
&
aCurrentStream
RefPtr
<
AudioProcessingTrack
>
&
aTrack
RefPtr
<
AudioInputProcessing
>
&
aListener
CubebUtils
:
:
AudioDeviceID
aDevice
uint32_t
aChannelCount
)
{
ASSERT_TRUE
(
!
!
aCurrentStream
)
;
ASSERT_TRUE
(
aCurrentStream
-
>
mHasInput
)
;
ASSERT_TRUE
(
aChannelCount
>
aCurrentStream
-
>
InputChannels
(
)
)
;
ASSERT_TRUE
(
!
aTrack
)
;
ASSERT_TRUE
(
!
aListener
)
;
bool
destroyed
=
false
;
MediaEventListener
destroyListener
=
cubeb
-
>
StreamDestroyEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aDestroyed
)
{
destroyed
=
aDestroyed
.
get
(
)
=
=
aCurrentStream
.
get
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
newStream
;
MediaEventListener
restartListener
=
cubeb
-
>
StreamInitEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aCreated
)
{
newStream
=
aCreated
;
}
)
;
aTrack
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
aListener
=
new
AudioInputProcessing
(
aChannelCount
)
;
aTrack
-
>
SetInputProcessing
(
aListener
)
;
aTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
aTrack
aListener
true
)
)
;
aTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
aTrack
aListener
)
)
;
DispatchFunction
(
[
&
]
{
aTrack
-
>
ConnectDeviceInput
(
aDevice
aListener
PRINCIPAL_HANDLE_NONE
)
;
}
)
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
TEST
(
TestAudioTrackGraph
RestartAudioIfProcessingMaxChannelCountChanged
)
#
2
"
_ns
[
&
]
{
return
destroyed
&
&
newStream
;
}
)
;
destroyListener
.
Disconnect
(
)
;
restartListener
.
Disconnect
(
)
;
aCurrentStream
=
newStream
;
}
;
const
CubebUtils
:
:
AudioDeviceID
nativeDevice
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
AudioProcessingTrack
>
track1
;
RefPtr
<
AudioInputProcessing
>
listener1
;
RefPtr
<
SmartMockCubebStream
>
nativeStream
;
RefPtr
<
AudioProcessingTrack
>
track2
;
RefPtr
<
AudioInputProcessing
>
listener2
;
{
track1
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
listener1
=
new
AudioInputProcessing
(
1
)
;
track1
-
>
SetInputProcessing
(
listener1
)
;
track1
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
track1
listener1
true
)
)
;
track1
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
track1
listener1
)
)
;
track1
-
>
ConnectDeviceInput
(
nativeDevice
listener1
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_EQ
(
track1
-
>
DeviceId
(
)
.
value
(
)
nativeDevice
)
;
auto
started
=
Invoke
(
[
&
]
{
return
graph
-
>
NotifyWhenDeviceStarted
(
nullptr
)
;
}
)
;
nativeStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
nativeStream
-
>
mHasInput
)
;
EXPECT_TRUE
(
nativeStream
-
>
mHasOutput
)
;
EXPECT_EQ
(
nativeStream
-
>
InputChannels
(
)
1U
)
;
EXPECT_EQ
(
nativeStream
-
>
GetInputDeviceID
(
)
nativeDevice
)
;
Unused
<
<
WaitFor
(
started
)
;
openTrack
(
nativeStream
track2
listener2
nativeDevice
2
)
;
EXPECT_EQ
(
nativeStream
-
>
InputChannels
(
)
2U
)
;
setNewChannelCount
(
track2
listener2
nativeStream
1
)
;
EXPECT_EQ
(
nativeStream
-
>
InputChannels
(
)
1U
)
;
setNewChannelCount
(
track1
listener1
nativeStream
2
)
;
EXPECT_EQ
(
nativeStream
-
>
InputChannels
(
)
2U
)
;
}
{
const
CubebUtils
:
:
AudioDeviceID
nonNativeDevice
=
(
CubebUtils
:
:
AudioDeviceID
)
2
;
RefPtr
<
AudioProcessingTrack
>
track3
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
RefPtr
<
AudioInputProcessing
>
listener3
=
new
AudioInputProcessing
(
1
)
;
track3
-
>
SetInputProcessing
(
listener3
)
;
track3
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
track3
listener3
true
)
)
;
track3
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
track3
listener3
)
)
;
track3
-
>
ConnectDeviceInput
(
nonNativeDevice
listener3
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_EQ
(
track3
-
>
DeviceId
(
)
.
value
(
)
nonNativeDevice
)
;
RefPtr
<
SmartMockCubebStream
>
nonNativeStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
nonNativeStream
-
>
mHasInput
)
;
EXPECT_FALSE
(
nonNativeStream
-
>
mHasOutput
)
;
EXPECT_EQ
(
nonNativeStream
-
>
InputChannels
(
)
1U
)
;
EXPECT_EQ
(
nonNativeStream
-
>
GetInputDeviceID
(
)
nonNativeDevice
)
;
RefPtr
<
AudioProcessingTrack
>
track4
;
RefPtr
<
AudioInputProcessing
>
listener4
;
openTrack
(
nonNativeStream
track4
listener4
nonNativeDevice
2
)
;
EXPECT_EQ
(
nonNativeStream
-
>
InputChannels
(
)
2U
)
;
EXPECT_EQ
(
nonNativeStream
-
>
GetInputDeviceID
(
)
nonNativeDevice
)
;
setNewChannelCount
(
track4
listener4
nonNativeStream
1
)
;
EXPECT_EQ
(
nonNativeStream
-
>
InputChannels
(
)
1U
)
;
EXPECT_EQ
(
nonNativeStream
-
>
GetInputDeviceID
(
)
nonNativeDevice
)
;
setNewChannelCount
(
track3
listener3
nonNativeStream
2
)
;
EXPECT_EQ
(
nonNativeStream
-
>
InputChannels
(
)
2U
)
;
EXPECT_EQ
(
nonNativeStream
-
>
GetInputDeviceID
(
)
nonNativeDevice
)
;
DispatchFunction
(
[
&
]
{
track4
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
track4
listener4
)
)
;
track4
-
>
DisconnectDeviceInput
(
)
;
track4
-
>
Destroy
(
)
;
}
)
;
DispatchFunction
(
[
&
]
{
track3
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
track3
listener3
)
)
;
track3
-
>
DisconnectDeviceInput
(
)
;
track3
-
>
Destroy
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
destroyedStream
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyedStream
.
get
(
)
nonNativeStream
.
get
(
)
)
;
}
{
DispatchFunction
(
[
&
]
{
track2
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
track2
listener2
)
)
;
track2
-
>
DisconnectDeviceInput
(
)
;
track2
-
>
Destroy
(
)
;
}
)
;
DispatchFunction
(
[
&
]
{
track1
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
track1
listener1
)
)
;
track1
-
>
DisconnectDeviceInput
(
)
;
track1
-
>
Destroy
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
destroyedStream
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyedStream
.
get
(
)
nativeStream
.
get
(
)
)
;
}
}
TEST
(
TestAudioTrackGraph
SetInputChannelCountBeforeAudioCallbackDriver
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
AudioProcessingTrack
>
track
;
RefPtr
<
AudioInputProcessing
>
listener
;
{
MozPromiseHolder
<
GenericPromise
>
h
;
RefPtr
<
GenericPromise
>
p
=
h
.
Ensure
(
__func__
)
;
struct
GuardMessage
:
public
ControlMessage
{
MozPromiseHolder
<
GenericPromise
>
mHolder
;
GuardMessage
(
MediaTrack
*
aTrack
MozPromiseHolder
<
GenericPromise
>
&
&
aHolder
)
:
ControlMessage
(
aTrack
)
mHolder
(
std
:
:
move
(
aHolder
)
)
{
}
void
Run
(
)
override
{
mTrack
-
>
GraphImpl
(
)
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
TestAudioTrackGraph
:
:
SetInputChannel
:
:
Message
:
:
Resolver
"
[
holder
=
std
:
:
move
(
mHolder
)
]
(
)
mutable
{
holder
.
Resolve
(
true
__func__
)
;
}
)
)
;
}
}
;
DispatchFunction
(
[
&
]
{
track
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
listener
=
new
AudioInputProcessing
(
2
)
;
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
track
listener
true
)
)
;
track
-
>
SetInputProcessing
(
listener
)
;
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetRequestedInputChannelCount
>
(
track
deviceId
listener
1
)
)
;
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GuardMessage
>
(
track
std
:
:
move
(
h
)
)
)
;
}
)
;
Unused
<
<
WaitFor
(
p
)
;
}
RefPtr
<
MediaInputPort
>
port
;
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
track
listener
)
)
;
track
-
>
ConnectDeviceInput
(
deviceId
listener
PRINCIPAL_HANDLE_NONE
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
TEST
(
TestAudioTrackGraph
SetInputChannelCountBeforeAudioCallbackDriver
)
"
_ns
[
&
]
{
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasOutput
)
;
return
stream
-
>
mHasInput
;
}
)
;
EXPECT_EQ
(
stream
-
>
InputChannels
(
)
1U
)
;
Unused
<
<
WaitFor
(
Invoke
(
[
&
]
{
return
graph
-
>
NotifyWhenDeviceStarted
(
nullptr
)
;
}
)
)
;
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
track
listener
)
)
;
track
-
>
DisconnectDeviceInput
(
)
;
track
-
>
Destroy
(
)
;
}
)
;
Unused
<
<
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
}
TEST
(
TestAudioTrackGraph
StartAudioDeviceBeforeStartingAudioProcessing
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
AudioProcessingTrack
>
track
;
RefPtr
<
AudioInputProcessing
>
listener
;
DispatchFunction
(
[
&
]
{
track
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
listener
=
new
AudioInputProcessing
(
2
)
;
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
track
listener
true
)
)
;
track
-
>
SetInputProcessing
(
listener
)
;
track
-
>
ConnectDeviceInput
(
deviceId
listener
PRINCIPAL_HANDLE_NONE
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
EXPECT_TRUE
(
stream
-
>
mHasOutput
)
;
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
{
uint32_t
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesProcessedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
}
cubeb
-
>
DontGoFaster
(
)
;
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
track
listener
)
)
;
}
)
;
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
{
uint32_t
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesProcessedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
}
cubeb
-
>
DontGoFaster
(
)
;
DispatchFunction
(
[
&
]
{
track
-
>
DisconnectDeviceInput
(
)
;
track
-
>
Destroy
(
)
;
}
)
;
Unused
<
<
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
}
TEST
(
TestAudioTrackGraph
StopAudioProcessingBeforeStoppingAudioDevice
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
AudioProcessingTrack
>
track
;
RefPtr
<
AudioInputProcessing
>
listener
;
DispatchFunction
(
[
&
]
{
track
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
listener
=
new
AudioInputProcessing
(
2
)
;
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
track
listener
true
)
)
;
track
-
>
SetInputProcessing
(
listener
)
;
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
track
listener
)
)
;
track
-
>
ConnectDeviceInput
(
deviceId
listener
PRINCIPAL_HANDLE_NONE
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
EXPECT_TRUE
(
stream
-
>
mHasOutput
)
;
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
{
uint32_t
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesProcessedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
}
cubeb
-
>
DontGoFaster
(
)
;
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
track
listener
)
)
;
}
)
;
DispatchFunction
(
[
&
]
{
track
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
{
uint32_t
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesProcessedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
}
cubeb
-
>
DontGoFaster
(
)
;
DispatchFunction
(
[
&
]
{
track
-
>
DisconnectDeviceInput
(
)
;
track
-
>
Destroy
(
)
;
}
)
;
Unused
<
<
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
}
TEST
(
TestAudioTrackGraph
SwitchNativeAudioProcessingTrack
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
CubebUtils
:
:
PreferredSampleRate
(
false
)
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
auto
switchNativeDevice
=
[
&
]
(
RefPtr
<
SmartMockCubebStream
>
&
&
aCurrentNativeStream
RefPtr
<
AudioProcessingTrack
>
&
aCurrentNativeTrack
RefPtr
<
AudioInputProcessing
>
&
aCurrentNativeListener
RefPtr
<
SmartMockCubebStream
>
&
aNextNativeStream
RefPtr
<
AudioProcessingTrack
>
&
aNextNativeTrack
)
{
ASSERT_TRUE
(
aCurrentNativeStream
-
>
mHasInput
)
;
ASSERT_TRUE
(
aCurrentNativeStream
-
>
mHasOutput
)
;
ASSERT_TRUE
(
aNextNativeStream
-
>
mHasInput
)
;
ASSERT_FALSE
(
aNextNativeStream
-
>
mHasOutput
)
;
std
:
:
cerr
<
<
"
Switching
native
input
from
device
"
<
<
aCurrentNativeStream
-
>
GetInputDeviceID
(
)
<
<
"
to
"
<
<
aNextNativeStream
-
>
GetInputDeviceID
(
)
<
<
std
:
:
endl
;
uint32_t
destroyed
=
0
;
MediaEventListener
destroyListener
=
cubeb
-
>
StreamDestroyEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aDestroyed
)
{
if
(
aDestroyed
.
get
(
)
=
=
aCurrentNativeStream
.
get
(
)
|
|
aDestroyed
.
get
(
)
=
=
aNextNativeStream
.
get
(
)
)
{
std
:
:
cerr
<
<
"
cubeb
stream
"
<
<
aDestroyed
.
get
(
)
<
<
"
(
device
"
<
<
aDestroyed
-
>
GetInputDeviceID
(
)
<
<
"
)
has
been
destroyed
"
<
<
std
:
:
endl
;
destroyed
+
=
1
;
}
}
)
;
RefPtr
<
SmartMockCubebStream
>
newStream
;
MediaEventListener
restartListener
=
cubeb
-
>
StreamInitEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aCreated
)
{
if
(
aCreated
-
>
mHasInput
)
{
ASSERT_TRUE
(
aCreated
-
>
mHasOutput
)
;
newStream
=
aCreated
;
}
}
)
;
std
:
:
cerr
<
<
"
Close
device
"
<
<
aCurrentNativeStream
-
>
GetInputDeviceID
(
)
<
<
std
:
:
endl
;
DispatchFunction
(
[
&
]
{
aCurrentNativeTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
aCurrentNativeTrack
aCurrentNativeListener
)
)
;
aCurrentNativeTrack
-
>
DisconnectDeviceInput
(
)
;
aCurrentNativeTrack
-
>
Destroy
(
)
;
}
)
;
std
:
:
cerr
<
<
"
Wait
for
the
switching
"
<
<
std
:
:
endl
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
TEST
(
TestAudioTrackGraph
SwitchNativeAudioProcessingTrack
)
"
_ns
[
&
]
{
return
destroyed
>
=
2
&
&
newStream
;
}
)
;
destroyListener
.
Disconnect
(
)
;
restartListener
.
Disconnect
(
)
;
aCurrentNativeStream
=
nullptr
;
aNextNativeStream
=
newStream
;
std
:
:
cerr
<
<
"
Now
the
native
input
is
device
"
<
<
aNextNativeStream
-
>
GetInputDeviceID
(
)
<
<
std
:
:
endl
;
}
;
const
CubebUtils
:
:
AudioDeviceID
device1
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
AudioProcessingTrack
>
track1
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
RefPtr
<
AudioInputProcessing
>
listener1
=
new
AudioInputProcessing
(
1
)
;
track1
-
>
SetInputProcessing
(
listener1
)
;
track1
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
track1
listener1
true
)
)
;
track1
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
track1
listener1
)
)
;
track1
-
>
ConnectDeviceInput
(
device1
listener1
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_EQ
(
track1
-
>
DeviceId
(
)
.
value
(
)
device1
)
;
auto
started
=
Invoke
(
[
&
]
{
return
graph
-
>
NotifyWhenDeviceStarted
(
nullptr
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream1
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream1
-
>
mHasInput
)
;
EXPECT_TRUE
(
stream1
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream1
-
>
InputChannels
(
)
1U
)
;
EXPECT_EQ
(
stream1
-
>
GetInputDeviceID
(
)
device1
)
;
Unused
<
<
WaitFor
(
started
)
;
std
:
:
cerr
<
<
"
Device
"
<
<
device1
<
<
"
is
opened
(
stream
"
<
<
stream1
.
get
(
)
<
<
"
)
"
<
<
std
:
:
endl
;
const
CubebUtils
:
:
AudioDeviceID
device2
=
(
CubebUtils
:
:
AudioDeviceID
)
2
;
RefPtr
<
AudioProcessingTrack
>
track2
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
RefPtr
<
AudioInputProcessing
>
listener2
=
new
AudioInputProcessing
(
2
)
;
track2
-
>
SetInputProcessing
(
listener2
)
;
track2
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
track2
listener2
true
)
)
;
track2
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
track2
listener2
)
)
;
track2
-
>
ConnectDeviceInput
(
device2
listener2
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_EQ
(
track2
-
>
DeviceId
(
)
.
value
(
)
device2
)
;
RefPtr
<
SmartMockCubebStream
>
stream2
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream2
-
>
mHasInput
)
;
EXPECT_FALSE
(
stream2
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream2
-
>
InputChannels
(
)
2U
)
;
EXPECT_EQ
(
stream2
-
>
GetInputDeviceID
(
)
device2
)
;
std
:
:
cerr
<
<
"
Device
"
<
<
device2
<
<
"
is
opened
(
stream
"
<
<
stream2
.
get
(
)
<
<
"
)
"
<
<
std
:
:
endl
;
const
CubebUtils
:
:
AudioDeviceID
device3
=
(
CubebUtils
:
:
AudioDeviceID
)
3
;
RefPtr
<
AudioProcessingTrack
>
track3
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
RefPtr
<
AudioInputProcessing
>
listener3
=
new
AudioInputProcessing
(
1
)
;
track3
-
>
SetInputProcessing
(
listener3
)
;
track3
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
track3
listener3
true
)
)
;
track3
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
track3
listener3
)
)
;
track3
-
>
ConnectDeviceInput
(
device3
listener3
PRINCIPAL_HANDLE_NONE
)
;
EXPECT_EQ
(
track3
-
>
DeviceId
(
)
.
value
(
)
device3
)
;
RefPtr
<
SmartMockCubebStream
>
stream3
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream3
-
>
mHasInput
)
;
EXPECT_FALSE
(
stream3
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream3
-
>
InputChannels
(
)
1U
)
;
EXPECT_EQ
(
stream3
-
>
GetInputDeviceID
(
)
device3
)
;
std
:
:
cerr
<
<
"
Device
"
<
<
device3
<
<
"
is
opened
(
stream
"
<
<
stream3
.
get
(
)
<
<
"
)
"
<
<
std
:
:
endl
;
switchNativeDevice
(
std
:
:
move
(
stream1
)
track1
listener1
stream2
track2
)
;
EXPECT_TRUE
(
stream2
-
>
mHasInput
)
;
EXPECT_TRUE
(
stream2
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream2
-
>
InputChannels
(
)
2U
)
;
EXPECT_EQ
(
stream2
-
>
GetInputDeviceID
(
)
device2
)
;
{
NativeInputTrack
*
native
=
track2
-
>
Graph
(
)
-
>
GetNativeInputTrackMainThread
(
)
;
ASSERT_TRUE
(
!
!
native
)
;
EXPECT_EQ
(
native
-
>
mDeviceId
device2
)
;
}
switchNativeDevice
(
std
:
:
move
(
stream2
)
track2
listener2
stream3
track3
)
;
EXPECT_TRUE
(
stream3
-
>
mHasInput
)
;
EXPECT_TRUE
(
stream3
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream3
-
>
InputChannels
(
)
1U
)
;
EXPECT_EQ
(
stream3
-
>
GetInputDeviceID
(
)
device3
)
;
{
NativeInputTrack
*
native
=
track3
-
>
Graph
(
)
-
>
GetNativeInputTrackMainThread
(
)
;
ASSERT_TRUE
(
!
!
native
)
;
EXPECT_EQ
(
native
-
>
mDeviceId
device3
)
;
}
std
:
:
cerr
<
<
"
Close
device
"
<
<
device3
<
<
std
:
:
endl
;
DispatchFunction
(
[
&
]
{
track3
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
track3
listener3
)
)
;
track3
-
>
DisconnectDeviceInput
(
)
;
track3
-
>
Destroy
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
destroyedStream
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyedStream
.
get
(
)
stream3
.
get
(
)
)
;
{
NativeInputTrack
*
native
=
graph
-
>
GetNativeInputTrackMainThread
(
)
;
ASSERT_TRUE
(
!
native
)
;
}
std
:
:
cerr
<
<
"
No
native
input
now
"
<
<
std
:
:
endl
;
}
class
OnFallbackListener
:
public
MediaTrackListener
{
const
RefPtr
<
MediaTrack
>
mTrack
;
Atomic
<
bool
>
mOnFallback
{
true
}
;
public
:
explicit
OnFallbackListener
(
MediaTrack
*
aTrack
)
:
mTrack
(
aTrack
)
{
}
bool
OnFallback
(
)
{
return
mOnFallback
;
}
void
NotifyOutput
(
MediaTrackGraph
*
TrackTime
)
override
{
if
(
auto
*
ad
=
mTrack
-
>
GraphImpl
(
)
-
>
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
{
mOnFallback
=
ad
-
>
OnFallback
(
)
;
}
}
}
;
void
TestCrossGraphPort
(
uint32_t
aInputRate
uint32_t
aOutputRate
float
aDriftFactor
uint32_t
aRunTimeSeconds
=
10
uint32_t
aNumExpectedUnderruns
=
0
)
{
std
:
:
cerr
<
<
"
TestCrossGraphPort
input
:
"
<
<
aInputRate
<
<
"
output
:
"
<
<
aOutputRate
<
<
"
driftFactor
:
"
<
<
aDriftFactor
<
<
std
:
:
endl
;
MockCubeb
*
cubeb
=
new
MockCubeb
(
MockCubeb
:
:
RunningMode
:
:
Manual
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
primary
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
aInputRate
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
MediaTrackGraph
*
partner
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
aOutputRate
reinterpret_cast
<
cubeb_devid
>
(
1
)
GetMainThreadSerialEventTarget
(
)
)
;
const
CubebUtils
:
:
AudioDeviceID
inputDeviceId
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
RefPtr
<
AudioProcessingTrack
>
processingTrack
;
RefPtr
<
AudioInputProcessing
>
listener
;
RefPtr
<
OnFallbackListener
>
primaryFallbackListener
;
DispatchFunction
(
[
&
]
{
processingTrack
=
AudioProcessingTrack
:
:
Create
(
primary
)
;
listener
=
new
AudioInputProcessing
(
2
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
processingTrack
listener
true
)
)
;
processingTrack
-
>
SetInputProcessing
(
listener
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
processingTrack
listener
)
)
;
processingTrack
-
>
ConnectDeviceInput
(
inputDeviceId
listener
PRINCIPAL_HANDLE_NONE
)
;
primaryFallbackListener
=
new
OnFallbackListener
(
processingTrack
)
;
processingTrack
-
>
AddListener
(
primaryFallbackListener
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
inputStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
while
(
primaryFallbackListener
-
>
OnFallback
(
)
)
{
EXPECT_EQ
(
inputStream
-
>
ManualDataCallback
(
0
)
MockCubebStream
:
:
KeepProcessing
:
:
Yes
)
;
std
:
:
this_thread
:
:
sleep_for
(
std
:
:
chrono
:
:
milliseconds
(
1
)
)
;
}
RefPtr
<
CrossGraphTransmitter
>
transmitter
;
RefPtr
<
MediaInputPort
>
port
;
RefPtr
<
CrossGraphReceiver
>
receiver
;
RefPtr
<
OnFallbackListener
>
partnerFallbackListener
;
DispatchFunction
(
[
&
]
{
processingTrack
-
>
RemoveListener
(
primaryFallbackListener
)
;
receiver
=
partner
-
>
CreateCrossGraphReceiver
(
primary
-
>
GraphRate
(
)
)
;
transmitter
=
primary
-
>
CreateCrossGraphTransmitter
(
receiver
)
;
port
=
transmitter
-
>
AllocateInputPort
(
processingTrack
)
;
receiver
-
>
AddAudioOutput
(
(
void
*
)
1
partner
-
>
PrimaryOutputDeviceID
(
)
0
)
;
partnerFallbackListener
=
new
OnFallbackListener
(
receiver
)
;
receiver
-
>
AddListener
(
partnerFallbackListener
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
partnerStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_EQ
(
inputStream
-
>
ManualDataCallback
(
0
)
MockCubebStream
:
:
KeepProcessing
:
:
Yes
)
;
while
(
partnerFallbackListener
-
>
OnFallback
(
)
)
{
EXPECT_EQ
(
partnerStream
-
>
ManualDataCallback
(
0
)
MockCubebStream
:
:
KeepProcessing
:
:
Yes
)
;
std
:
:
this_thread
:
:
sleep_for
(
std
:
:
chrono
:
:
milliseconds
(
1
)
)
;
}
DispatchFunction
(
[
&
]
{
receiver
-
>
RemoveListener
(
partnerFallbackListener
)
;
}
)
;
while
(
NS_ProcessNextEvent
(
nullptr
false
)
)
{
}
nsIThread
*
currentThread
=
NS_GetCurrentThread
(
)
;
cubeb_state
inputState
=
CUBEB_STATE_STARTED
;
MediaEventListener
inputStateListener
=
inputStream
-
>
StateEvent
(
)
.
Connect
(
currentThread
[
&
]
(
cubeb_state
aState
)
{
inputState
=
aState
;
}
)
;
cubeb_state
partnerState
=
CUBEB_STATE_STARTED
;
MediaEventListener
partnerStateListener
=
partnerStream
-
>
StateEvent
(
)
.
Connect
(
currentThread
[
&
]
(
cubeb_state
aState
)
{
partnerState
=
aState
;
}
)
;
const
media
:
:
TimeUnit
runtime
=
media
:
:
TimeUnit
:
:
FromSeconds
(
aRunTimeSeconds
)
;
const
media
:
:
TimeUnit
step
=
media
:
:
TimeUnit
:
:
FromSeconds
(
0
.
01
)
;
{
media
:
:
TimeUnit
pos
=
media
:
:
TimeUnit
:
:
Zero
(
)
;
long
inputFrames
=
0
;
long
outputFrames
=
0
;
while
(
pos
<
runtime
)
{
pos
+
=
step
;
const
long
newInputFrames
=
pos
.
ToTicksAtRate
(
aInputRate
)
;
const
long
newOutputFrames
=
(
pos
.
MultDouble
(
aDriftFactor
)
)
.
ToTicksAtRate
(
aOutputRate
)
;
EXPECT_EQ
(
inputStream
-
>
ManualDataCallback
(
newInputFrames
-
inputFrames
)
MockCubebStream
:
:
KeepProcessing
:
:
Yes
)
;
EXPECT_EQ
(
partnerStream
-
>
ManualDataCallback
(
newOutputFrames
-
outputFrames
)
MockCubebStream
:
:
KeepProcessing
:
:
Yes
)
;
inputFrames
=
newInputFrames
;
outputFrames
=
newOutputFrames
;
}
}
DispatchFunction
(
[
&
]
{
receiver
-
>
RemoveAudioOutput
(
(
void
*
)
1
)
;
receiver
-
>
Destroy
(
)
;
transmitter
-
>
Destroy
(
)
;
port
-
>
Destroy
(
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
processingTrack
listener
)
)
;
processingTrack
-
>
DisconnectDeviceInput
(
)
;
processingTrack
-
>
Destroy
(
)
;
}
)
;
while
(
NS_ProcessNextEvent
(
nullptr
false
)
)
{
}
EXPECT_EQ
(
inputStream
-
>
ManualDataCallback
(
0
)
MockCubebStream
:
:
KeepProcessing
:
:
Yes
)
;
EXPECT_EQ
(
partnerStream
-
>
ManualDataCallback
(
0
)
MockCubebStream
:
:
KeepProcessing
:
:
Yes
)
;
EXPECT_EQ
(
inputStream
-
>
ManualDataCallback
(
128
)
MockCubebStream
:
:
KeepProcessing
:
:
No
)
;
EXPECT_EQ
(
partnerStream
-
>
ManualDataCallback
(
128
)
MockCubebStream
:
:
KeepProcessing
:
:
No
)
;
uint32_t
inputFrequency
=
inputStream
-
>
InputFrequency
(
)
;
uint64_t
preSilenceSamples
;
float
estimatedFreq
;
uint32_t
nrDiscontinuities
;
std
:
:
tie
(
preSilenceSamples
estimatedFreq
nrDiscontinuities
)
=
WaitFor
(
partnerStream
-
>
OutputVerificationEvent
(
)
)
;
EXPECT_NEAR
(
estimatedFreq
inputFrequency
/
aDriftFactor
5
)
;
const
media
:
:
TimeUnit
inputBuffering
(
WEBAUDIO_BLOCK_SIZE
aInputRate
)
;
const
media
:
:
TimeUnit
buffering
=
media
:
:
TimeUnit
:
:
FromSeconds
(
0
.
05
)
.
ToBase
(
aInputRate
)
;
const
media
:
:
TimeUnit
inputStepSize
(
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
step
.
ToTicksAtRate
(
aInputRate
)
)
aInputRate
)
;
const
media
:
:
TimeUnit
outputStepSize
=
media
:
:
TimeUnit
(
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
step
.
ToBase
(
aOutputRate
)
.
MultDouble
(
aDriftFactor
)
.
ToTicksAtRate
(
aOutputRate
)
)
aOutputRate
)
.
ToBase
(
aInputRate
)
;
const
uint32_t
expectedPreSilence
=
(
outputStepSize
+
inputBuffering
+
buffering
-
inputStepSize
)
.
ToBase
(
aInputRate
)
.
ToBase
<
media
:
:
TimeUnit
:
:
CeilingPolicy
>
(
aOutputRate
)
.
ToTicksAtRate
(
aOutputRate
)
;
const
uint32_t
margin
=
std
:
:
max
(
1U
expectedPreSilence
/
1000
)
;
EXPECT_NEAR
(
preSilenceSamples
expectedPreSilence
margin
)
;
EXPECT_LE
(
nrDiscontinuities
1U
+
2
*
aNumExpectedUnderruns
)
;
SpinEventLoopUntil
(
"
streams
have
stopped
"
_ns
[
&
]
{
return
inputState
=
=
CUBEB_STATE_STOPPED
&
&
partnerState
=
=
CUBEB_STATE_STOPPED
;
}
)
;
inputStateListener
.
Disconnect
(
)
;
partnerStateListener
.
Disconnect
(
)
;
}
TEST
(
TestAudioTrackGraph
CrossGraphPort
)
{
TestCrossGraphPort
(
44100
44100
1
)
;
TestCrossGraphPort
(
44100
44100
1
.
006
)
;
TestCrossGraphPort
(
44100
44100
0
.
994
)
;
TestCrossGraphPort
(
48000
44100
1
)
;
TestCrossGraphPort
(
48000
44100
1
.
006
)
;
TestCrossGraphPort
(
48000
44100
0
.
994
)
;
TestCrossGraphPort
(
44100
48000
1
)
;
TestCrossGraphPort
(
44100
48000
1
.
006
)
;
TestCrossGraphPort
(
44100
48000
0
.
994
)
;
TestCrossGraphPort
(
52110
17781
1
)
;
TestCrossGraphPort
(
52110
17781
1
.
006
)
;
TestCrossGraphPort
(
52110
17781
0
.
994
)
;
}
TEST
(
TestAudioTrackGraph
CrossGraphPortUnderrun
)
{
TestCrossGraphPort
(
44100
44100
1
.
01
30
1
)
;
TestCrossGraphPort
(
44100
44100
1
.
03
40
3
)
;
TestCrossGraphPort
(
48000
44100
1
.
01
30
1
)
;
TestCrossGraphPort
(
48000
44100
1
.
03
40
3
)
;
TestCrossGraphPort
(
44100
48000
1
.
01
30
1
)
;
TestCrossGraphPort
(
44100
48000
1
.
03
40
3
)
;
TestCrossGraphPort
(
52110
17781
1
.
01
30
1
)
;
TestCrossGraphPort
(
52110
17781
1
.
03
40
3
)
;
}
TEST
(
TestAudioTrackGraph
SecondaryOutputDevice
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
const
TrackRate
primaryRate
=
48000
;
const
TrackRate
secondaryRate
=
44100
;
MediaTrackGraph
*
graph
=
MediaTrackGraphImpl
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
1
primaryRate
nullptr
GetMainThreadSerialEventTarget
(
)
)
;
RefPtr
<
AudioProcessingTrack
>
processingTrack
;
RefPtr
<
AudioInputProcessing
>
listener
;
DispatchFunction
(
[
&
]
{
processingTrack
=
AudioProcessingTrack
:
:
Create
(
graph
)
;
listener
=
new
AudioInputProcessing
(
2
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
processingTrack
listener
true
)
)
;
processingTrack
-
>
SetInputProcessing
(
listener
)
;
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
processingTrack
listener
)
)
;
processingTrack
-
>
ConnectDeviceInput
(
nullptr
listener
PRINCIPAL_HANDLE_NONE
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
primaryStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
const
void
*
secondaryDeviceID
=
CubebUtils
:
:
AudioDeviceID
(
2
)
;
DispatchFunction
(
[
&
]
{
processingTrack
-
>
AddAudioOutput
(
nullptr
secondaryDeviceID
secondaryRate
)
;
processingTrack
-
>
SetAudioOutputVolume
(
nullptr
0
.
f
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
secondaryStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_EQ
(
secondaryStream
-
>
GetOutputDeviceID
(
)
secondaryDeviceID
)
;
EXPECT_EQ
(
static_cast
<
TrackRate
>
(
secondaryStream
-
>
SampleRate
(
)
)
secondaryRate
)
;
nsIThread
*
currentThread
=
NS_GetCurrentThread
(
)
;
uint32_t
audioFrames
=
0
;
MediaEventListener
audioListener
=
secondaryStream
-
>
FramesVerifiedEvent
(
)
.
Connect
(
currentThread
[
&
]
(
uint32_t
aFrames
)
{
audioFrames
+
=
aFrames
;
}
)
;
uint32_t
processedFrames
=
0
;
WaitUntil
(
secondaryStream
-
>
FramesProcessedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
processedFrames
+
=
aFrames
;
return
processedFrames
>
static_cast
<
uint32_t
>
(
secondaryRate
/
10
)
;
}
)
;
EXPECT_EQ
(
audioFrames
0U
)
<
<
"
audio
frames
at
zero
volume
"
;
secondaryStream
-
>
SetOutputRecordingEnabled
(
true
)
;
DispatchFunction
(
[
&
]
{
processingTrack
-
>
SetAudioOutputVolume
(
nullptr
1
.
f
)
;
}
)
;
SpinEventLoopUntil
(
"
200ms
of
audio
"
_ns
[
&
]
{
return
audioFrames
>
static_cast
<
uint32_t
>
(
secondaryRate
/
5
)
;
}
)
;
audioListener
.
Disconnect
(
)
;
secondaryStream
-
>
SetOutputRecordingEnabled
(
false
)
;
DispatchFunction
(
[
&
]
{
processingTrack
-
>
RemoveAudioOutput
(
nullptr
)
;
}
)
;
WaitFor
(
secondaryStream
-
>
OutputVerificationEvent
(
)
)
;
uint32_t
channelCount
=
secondaryStream
-
>
OutputChannels
(
)
;
nsTArray
<
AudioDataValue
>
output
=
secondaryStream
-
>
TakeRecordedOutput
(
)
;
size_t
leadingIndex
=
0
;
for
(
;
leadingIndex
<
output
.
Length
(
)
&
&
output
[
leadingIndex
]
=
=
0
.
f
;
leadingIndex
+
=
channelCount
)
{
}
;
leadingIndex
+
=
10
*
channelCount
;
EXPECT_LT
(
leadingIndex
output
.
Length
(
)
)
;
auto
trimmed
=
Span
(
output
)
.
From
(
std
:
:
min
(
leadingIndex
output
.
Length
(
)
)
)
;
size_t
frameCount
=
trimmed
.
Length
(
)
/
channelCount
;
uint32_t
inputFrequency
=
primaryStream
-
>
InputFrequency
(
)
;
AudioVerifier
<
AudioDataValue
>
verifier
(
secondaryRate
inputFrequency
)
;
verifier
.
AppendDataInterleaved
(
trimmed
.
Elements
(
)
frameCount
channelCount
)
;
EXPECT_EQ
(
verifier
.
EstimatedFreq
(
)
inputFrequency
)
;
EXPECT_EQ
(
verifier
.
CountDiscontinuities
(
)
1U
)
;
DispatchFunction
(
[
&
]
{
processingTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
processingTrack
listener
)
)
;
processingTrack
-
>
DisconnectDeviceInput
(
)
;
processingTrack
-
>
Destroy
(
)
;
}
)
;
WaitFor
(
primaryStream
-
>
OutputVerificationEvent
(
)
)
;
}
#
endif
#
undef
Invoke
#
undef
DispatchFunction
#
undef
DispatchMethod
