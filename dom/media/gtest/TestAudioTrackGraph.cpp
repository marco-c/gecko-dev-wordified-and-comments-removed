#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
-
printers
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
CrossGraphPort
.
h
"
#
ifdef
MOZ_WEBRTC
#
include
"
MediaEngineWebRTCAudio
.
h
"
#
endif
#
include
"
MockCubeb
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
WaitFor
.
h
"
#
include
"
WavDumper
.
h
"
#
define
DRIFT_BUFFERING_PREF
"
media
.
clockdrift
.
buffering
"
using
namespace
mozilla
;
namespace
{
#
define
Invoke
(
f
)
InvokeAsync
(
GetCurrentSerialEventTarget
(
)
__func__
f
)
#
define
DispatchFunction
(
f
)
\
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
__func__
f
)
)
#
define
DispatchMethod
(
t
m
args
.
.
.
)
\
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
__func__
t
m
#
#
args
)
)
#
ifdef
MOZ_WEBRTC
struct
StartInputProcessing
:
public
ControlMessage
{
const
RefPtr
<
AudioInputTrack
>
mInputTrack
;
const
RefPtr
<
AudioInputProcessing
>
mInputProcessing
;
StartInputProcessing
(
AudioInputTrack
*
aTrack
AudioInputProcessing
*
aInputProcessing
)
:
ControlMessage
(
aTrack
)
mInputTrack
(
aTrack
)
mInputProcessing
(
aInputProcessing
)
{
}
void
Run
(
)
override
{
mInputProcessing
-
>
Start
(
)
;
}
}
;
struct
StopInputProcessing
:
public
ControlMessage
{
const
RefPtr
<
AudioInputProcessing
>
mInputProcessing
;
explicit
StopInputProcessing
(
AudioInputProcessing
*
aInputProcessing
)
:
ControlMessage
(
nullptr
)
mInputProcessing
(
aInputProcessing
)
{
}
void
Run
(
)
override
{
mInputProcessing
-
>
Stop
(
)
;
}
}
;
struct
SetPassThrough
:
public
ControlMessage
{
const
RefPtr
<
AudioInputProcessing
>
mInputProcessing
;
const
bool
mPassThrough
;
SetPassThrough
(
MediaTrack
*
aTrack
AudioInputProcessing
*
aInputProcessing
bool
aPassThrough
)
:
ControlMessage
(
aTrack
)
mInputProcessing
(
aInputProcessing
)
mPassThrough
(
aPassThrough
)
{
}
void
Run
(
)
override
{
EXPECT_EQ
(
mInputProcessing
-
>
PassThrough
(
mTrack
-
>
GraphImpl
(
)
)
!
mPassThrough
)
;
mInputProcessing
-
>
SetPassThrough
(
mTrack
-
>
GraphImpl
(
)
mPassThrough
)
;
}
}
;
struct
SetRequestedInputChannelCount
:
public
ControlMessage
{
const
RefPtr
<
AudioInputProcessing
>
mInputProcessing
;
const
uint32_t
mChannelCount
;
SetRequestedInputChannelCount
(
MediaTrack
*
aTrack
AudioInputProcessing
*
aInputProcessing
uint32_t
aChannelCount
)
:
ControlMessage
(
aTrack
)
mInputProcessing
(
aInputProcessing
)
mChannelCount
(
aChannelCount
)
{
}
void
Run
(
)
override
{
mInputProcessing
-
>
SetRequestedInputChannelCount
(
mTrack
-
>
GraphImpl
(
)
mChannelCount
)
;
}
}
;
#
endif
class
GoFaster
:
public
ControlMessage
{
MockCubeb
*
mCubeb
;
public
:
explicit
GoFaster
(
MockCubeb
*
aCubeb
)
:
ControlMessage
(
nullptr
)
mCubeb
(
aCubeb
)
{
}
void
Run
(
)
override
{
mCubeb
-
>
GoFaster
(
)
;
}
}
;
}
TEST
(
TestAudioTrackGraph
DifferentDeviceIDs
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
g1
=
MediaTrackGraph
:
:
GetInstance
(
MediaTrackGraph
:
:
AUDIO_THREAD_DRIVER
nullptr
MediaTrackGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
nullptr
)
;
MediaTrackGraph
*
g2
=
MediaTrackGraph
:
:
GetInstance
(
MediaTrackGraph
:
:
AUDIO_THREAD_DRIVER
nullptr
MediaTrackGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
reinterpret_cast
<
cubeb_devid
>
(
1
)
)
;
MediaTrackGraph
*
g1_2
=
MediaTrackGraph
:
:
GetInstance
(
MediaTrackGraph
:
:
AUDIO_THREAD_DRIVER
nullptr
MediaTrackGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
nullptr
)
;
MediaTrackGraph
*
g2_2
=
MediaTrackGraph
:
:
GetInstance
(
MediaTrackGraph
:
:
AUDIO_THREAD_DRIVER
nullptr
MediaTrackGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
reinterpret_cast
<
cubeb_devid
>
(
1
)
)
;
EXPECT_NE
(
g1
g2
)
<
<
"
Different
graphs
due
to
different
device
ids
"
;
EXPECT_EQ
(
g1
g1_2
)
<
<
"
Same
graphs
for
same
device
ids
"
;
EXPECT_EQ
(
g2
g2_2
)
<
<
"
Same
graphs
for
same
device
ids
"
;
for
(
MediaTrackGraph
*
g
:
{
g1
g2
}
)
{
using
SourceTrackPromise
=
MozPromise
<
SourceMediaTrack
*
nsresult
true
>
;
auto
p
=
Invoke
(
[
g
]
{
return
SourceTrackPromise
:
:
CreateAndResolve
(
g
-
>
CreateSourceTrack
(
MediaSegment
:
:
AUDIO
)
__func__
)
;
}
)
;
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
RefPtr
<
SourceMediaTrack
>
dummySource
=
WaitFor
(
p
)
.
unwrap
(
)
;
DispatchMethod
(
dummySource
&
SourceMediaTrack
:
:
Destroy
)
;
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
}
}
TEST
(
TestAudioTrackGraph
SetOutputDeviceID
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraph
:
:
GetInstance
(
MediaTrackGraph
:
:
AUDIO_THREAD_DRIVER
nullptr
MediaTrackGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
reinterpret_cast
<
cubeb_devid
>
(
2
)
)
;
RefPtr
<
SourceMediaTrack
>
dummySource
;
DispatchFunction
(
[
&
]
{
dummySource
=
graph
-
>
CreateSourceTrack
(
MediaSegment
:
:
AUDIO
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_EQ
(
stream
-
>
GetOutputDeviceID
(
)
reinterpret_cast
<
cubeb_devid
>
(
2
)
)
<
<
"
After
init
confirm
the
expected
output
device
id
"
;
DispatchMethod
(
dummySource
&
SourceMediaTrack
:
:
Destroy
)
;
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
}
TEST
(
TestAudioTrackGraph
NotifyDeviceStarted
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraph
:
:
GetInstance
(
MediaTrackGraph
:
:
AUDIO_THREAD_DRIVER
nullptr
MediaTrackGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
nullptr
)
;
RefPtr
<
SourceMediaTrack
>
dummySource
;
Unused
<
<
WaitFor
(
Invoke
(
[
&
]
{
dummySource
=
graph
-
>
CreateSourceTrack
(
MediaSegment
:
:
AUDIO
)
;
return
graph
-
>
NotifyWhenDeviceStarted
(
dummySource
)
;
}
)
)
;
{
MediaTrackGraphImpl
*
graph
=
dummySource
-
>
GraphImpl
(
)
;
MonitorAutoLock
lock
(
graph
-
>
GetMonitor
(
)
)
;
EXPECT_TRUE
(
graph
-
>
CurrentDriver
(
)
-
>
AsAudioCallbackDriver
(
)
)
;
EXPECT_TRUE
(
graph
-
>
CurrentDriver
(
)
-
>
ThreadRunning
(
)
)
;
}
DispatchMethod
(
dummySource
&
SourceMediaTrack
:
:
Destroy
)
;
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
}
#
ifdef
MOZ_WEBRTC
TEST
(
TestAudioTrackGraph
ErrorCallback
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraph
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
nullptr
MediaTrackGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
nullptr
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
void
*
)
1
;
RefPtr
<
AudioInputTrack
>
inputTrack
;
RefPtr
<
AudioInputProcessing
>
listener
;
auto
started
=
Invoke
(
[
&
]
{
inputTrack
=
AudioInputTrack
:
:
Create
(
graph
)
;
listener
=
new
AudioInputProcessing
(
2
PRINCIPAL_HANDLE_NONE
)
;
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
inputTrack
listener
true
)
)
;
inputTrack
-
>
SetInputProcessing
(
listener
)
;
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
inputTrack
listener
)
)
;
inputTrack
-
>
OpenAudioInput
(
deviceId
listener
)
;
EXPECT_EQ
(
inputTrack
-
>
DeviceId
(
)
.
value
(
)
deviceId
)
;
return
graph
-
>
NotifyWhenDeviceStarted
(
inputTrack
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
Result
<
bool
nsresult
>
rv
=
WaitFor
(
started
)
;
EXPECT_TRUE
(
rv
.
unwrapOr
(
false
)
)
;
DispatchFunction
(
[
&
]
{
stream
-
>
ForceError
(
)
;
}
)
;
bool
errored
=
false
init
=
false
;
MediaEventListener
errorListener
=
stream
-
>
ErrorForcedEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
{
errored
=
true
;
}
)
;
MediaEventListener
initListener
=
cubeb
-
>
StreamInitEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
{
init
=
true
;
}
)
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
TEST
(
TestAudioTrackGraph
ErrorCallback
)
"
_ns
[
&
]
{
return
errored
&
&
init
;
}
)
;
errorListener
.
Disconnect
(
)
;
initListener
.
Disconnect
(
)
;
DispatchFunction
(
[
&
]
{
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
listener
)
)
;
inputTrack
-
>
CloseAudioInput
(
)
;
inputTrack
-
>
Destroy
(
)
;
}
)
;
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
}
TEST
(
TestAudioTrackGraph
AudioInputTrack
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
auto
unforcer
=
WaitFor
(
cubeb
-
>
ForceAudioThread
(
)
)
.
unwrap
(
)
;
Unused
<
<
unforcer
;
MediaTrackGraph
*
graph
=
MediaTrackGraph
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
nullptr
MediaTrackGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
nullptr
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
void
*
)
1
;
RefPtr
<
AudioInputTrack
>
inputTrack
;
RefPtr
<
ProcessedMediaTrack
>
outputTrack
;
RefPtr
<
MediaInputPort
>
port
;
RefPtr
<
AudioInputProcessing
>
listener
;
auto
p
=
Invoke
(
[
&
]
{
inputTrack
=
AudioInputTrack
:
:
Create
(
graph
)
;
outputTrack
=
graph
-
>
CreateForwardedInputTrack
(
MediaSegment
:
:
AUDIO
)
;
outputTrack
-
>
QueueSetAutoend
(
false
)
;
outputTrack
-
>
AddAudioOutput
(
reinterpret_cast
<
void
*
>
(
1
)
)
;
port
=
outputTrack
-
>
AllocateInputPort
(
inputTrack
)
;
listener
=
new
AudioInputProcessing
(
2
PRINCIPAL_HANDLE_NONE
)
;
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
inputTrack
listener
true
)
)
;
inputTrack
-
>
SetInputProcessing
(
listener
)
;
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
inputTrack
listener
)
)
;
inputTrack
-
>
OpenAudioInput
(
deviceId
listener
)
;
return
graph
-
>
NotifyWhenDeviceStarted
(
inputTrack
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
Unused
<
<
WaitFor
(
p
)
;
DispatchFunction
(
[
&
]
{
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
uint32_t
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesVerifiedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
cubeb
-
>
DontGoFaster
(
)
;
DispatchFunction
(
[
&
]
{
outputTrack
-
>
RemoveAudioOutput
(
(
void
*
)
1
)
;
outputTrack
-
>
Destroy
(
)
;
port
-
>
Destroy
(
)
;
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
listener
)
)
;
inputTrack
-
>
CloseAudioInput
(
)
;
inputTrack
-
>
Destroy
(
)
;
}
)
;
uint32_t
inputRate
=
stream
-
>
InputSampleRate
(
)
;
uint32_t
inputFrequency
=
stream
-
>
InputFrequency
(
)
;
uint64_t
preSilenceSamples
;
uint32_t
estimatedFreq
;
uint32_t
nrDiscontinuities
;
Tie
(
preSilenceSamples
estimatedFreq
nrDiscontinuities
)
=
WaitFor
(
stream
-
>
OutputVerificationEvent
(
)
)
;
EXPECT_EQ
(
estimatedFreq
inputFrequency
)
;
std
:
:
cerr
<
<
"
PreSilence
:
"
<
<
preSilenceSamples
<
<
std
:
:
endl
;
EXPECT_GE
(
preSilenceSamples
128U
)
;
EXPECT_LE
(
preSilenceSamples
128U
+
2
*
inputRate
/
100
)
;
EXPECT_LE
(
nrDiscontinuities
1U
)
;
}
TEST
(
TestAudioTrackGraph
ReOpenAudioInput
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
const
TrackRate
rate
=
48000
;
MediaTrackGraph
*
graph
=
MediaTrackGraph
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
nullptr
rate
nullptr
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
void
*
)
1
;
RefPtr
<
AudioInputTrack
>
inputTrack
;
RefPtr
<
ProcessedMediaTrack
>
outputTrack
;
RefPtr
<
MediaInputPort
>
port
;
RefPtr
<
AudioInputProcessing
>
listener
;
auto
p
=
Invoke
(
[
&
]
{
inputTrack
=
AudioInputTrack
:
:
Create
(
graph
)
;
outputTrack
=
graph
-
>
CreateForwardedInputTrack
(
MediaSegment
:
:
AUDIO
)
;
outputTrack
-
>
QueueSetAutoend
(
false
)
;
outputTrack
-
>
AddAudioOutput
(
reinterpret_cast
<
void
*
>
(
1
)
)
;
port
=
outputTrack
-
>
AllocateInputPort
(
inputTrack
)
;
listener
=
new
AudioInputProcessing
(
2
PRINCIPAL_HANDLE_NONE
)
;
inputTrack
-
>
SetInputProcessing
(
listener
)
;
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
inputTrack
listener
)
)
;
inputTrack
-
>
OpenAudioInput
(
deviceId
listener
)
;
return
graph
-
>
NotifyWhenDeviceStarted
(
inputTrack
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
Unused
<
<
WaitFor
(
p
)
;
stream
-
>
SetDriftFactor
(
1
.
111
)
;
DispatchFunction
(
[
&
]
{
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
{
uint32_t
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesProcessedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
}
cubeb
-
>
DontGoFaster
(
)
;
DispatchFunction
(
[
&
]
{
inputTrack
-
>
CloseAudioInput
(
)
;
}
)
;
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_FALSE
(
stream
-
>
mHasInput
)
;
Unused
<
<
WaitFor
(
Invoke
(
[
&
]
{
return
graph
-
>
NotifyWhenDeviceStarted
(
inputTrack
)
;
}
)
)
;
DispatchFunction
(
[
&
]
{
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
{
uint32_t
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesProcessedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
}
cubeb
-
>
DontGoFaster
(
)
;
DispatchFunction
(
[
&
]
{
inputTrack
-
>
OpenAudioInput
(
deviceId
listener
)
;
}
)
;
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
Unused
<
<
WaitFor
(
Invoke
(
[
&
]
{
return
graph
-
>
NotifyWhenDeviceStarted
(
inputTrack
)
;
}
)
)
;
DispatchFunction
(
[
&
]
{
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
{
uint32_t
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesProcessedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
}
cubeb
-
>
DontGoFaster
(
)
;
DispatchFunction
(
[
&
]
{
outputTrack
-
>
RemoveAudioOutput
(
(
void
*
)
1
)
;
outputTrack
-
>
Destroy
(
)
;
port
-
>
Destroy
(
)
;
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
listener
)
)
;
inputTrack
-
>
CloseAudioInput
(
)
;
inputTrack
-
>
Destroy
(
)
;
}
)
;
uint32_t
inputRate
=
stream
-
>
InputSampleRate
(
)
;
uint32_t
inputFrequency
=
stream
-
>
InputFrequency
(
)
;
uint64_t
preSilenceSamples
;
uint32_t
estimatedFreq
;
uint32_t
nrDiscontinuities
;
Tie
(
preSilenceSamples
estimatedFreq
nrDiscontinuities
)
=
WaitFor
(
stream
-
>
OutputVerificationEvent
(
)
)
;
EXPECT_EQ
(
estimatedFreq
inputFrequency
)
;
std
:
:
cerr
<
<
"
PreSilence
:
"
<
<
preSilenceSamples
<
<
std
:
:
endl
;
EXPECT_GE
(
preSilenceSamples
128U
+
inputRate
/
100
)
;
EXPECT_LE
(
preSilenceSamples
128U
+
3
*
inputRate
/
100
)
;
EXPECT_LE
(
nrDiscontinuities
1U
)
;
}
float
rmsf32
(
AudioDataValue
*
aSamples
uint32_t
aChannels
uint32_t
aFrames
)
{
float
downmixed
;
float
rms
=
0
.
;
uint32_t
readIdx
=
0
;
for
(
uint32_t
i
=
0
;
i
<
aFrames
;
i
+
+
)
{
downmixed
=
0
.
;
for
(
uint32_t
j
=
0
;
j
<
aChannels
;
j
+
+
)
{
downmixed
+
=
AudioSampleToFloat
(
aSamples
[
readIdx
+
+
]
)
;
}
rms
+
=
downmixed
*
downmixed
;
}
rms
=
rms
/
aFrames
;
return
sqrt
(
rms
)
;
}
TEST
(
TestAudioTrackGraph
AudioInputTrackDisabling
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
MediaTrackGraph
*
graph
=
MediaTrackGraph
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
nullptr
MediaTrackGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
nullptr
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
void
*
)
1
;
RefPtr
<
AudioInputTrack
>
inputTrack
;
RefPtr
<
ProcessedMediaTrack
>
outputTrack
;
RefPtr
<
MediaInputPort
>
port
;
RefPtr
<
AudioInputProcessing
>
listener
;
auto
p
=
Invoke
(
[
&
]
{
inputTrack
=
AudioInputTrack
:
:
Create
(
graph
)
;
outputTrack
=
graph
-
>
CreateForwardedInputTrack
(
MediaSegment
:
:
AUDIO
)
;
outputTrack
-
>
QueueSetAutoend
(
false
)
;
outputTrack
-
>
AddAudioOutput
(
reinterpret_cast
<
void
*
>
(
1
)
)
;
port
=
outputTrack
-
>
AllocateInputPort
(
inputTrack
)
;
listener
=
new
AudioInputProcessing
(
2
PRINCIPAL_HANDLE_NONE
)
;
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
inputTrack
listener
true
)
)
;
inputTrack
-
>
SetInputProcessing
(
listener
)
;
inputTrack
-
>
OpenAudioInput
(
deviceId
listener
)
;
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
inputTrack
listener
)
)
;
return
graph
-
>
NotifyWhenDeviceStarted
(
inputTrack
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
Unused
<
<
WaitFor
(
p
)
;
stream
-
>
SetOutputRecordingEnabled
(
true
)
;
uint32_t
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesProcessedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
const
uint32_t
ITERATION_COUNT
=
5
;
uint32_t
iterations
=
ITERATION_COUNT
;
DisabledTrackMode
currentMode
=
DisabledTrackMode
:
:
SILENCE_BLACK
;
while
(
iterations
-
-
)
{
DispatchFunction
(
[
&
]
{
inputTrack
-
>
SetDisabledTrackMode
(
currentMode
)
;
if
(
currentMode
=
=
DisabledTrackMode
:
:
SILENCE_BLACK
)
{
currentMode
=
DisabledTrackMode
:
:
ENABLED
;
}
else
{
currentMode
=
DisabledTrackMode
:
:
SILENCE_BLACK
;
}
}
)
;
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesProcessedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
}
DispatchFunction
(
[
&
]
{
outputTrack
-
>
RemoveAudioOutput
(
(
void
*
)
1
)
;
outputTrack
-
>
Destroy
(
)
;
port
-
>
Destroy
(
)
;
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
listener
)
)
;
inputTrack
-
>
CloseAudioInput
(
)
;
inputTrack
-
>
Destroy
(
)
;
}
)
;
uint64_t
preSilenceSamples
;
uint32_t
estimatedFreq
;
uint32_t
nrDiscontinuities
;
Tie
(
preSilenceSamples
estimatedFreq
nrDiscontinuities
)
=
WaitFor
(
stream
-
>
OutputVerificationEvent
(
)
)
;
auto
data
=
stream
-
>
TakeRecordedOutput
(
)
;
float
noisyTime_s
[
]
=
{
0
.
5
2
.
5
4
.
5
}
;
float
silenceTime_s
[
]
=
{
1
.
5
3
.
5
5
.
5
}
;
uint32_t
rate
=
graph
-
>
GraphRate
(
)
;
for
(
float
&
time
:
noisyTime_s
)
{
uint32_t
startIdx
=
time
*
rate
*
2
;
EXPECT_NE
(
rmsf32
(
&
(
data
[
startIdx
]
)
2
rate
/
10
)
0
.
0
)
;
}
for
(
float
&
time
:
silenceTime_s
)
{
uint32_t
startIdx
=
time
*
rate
*
2
;
EXPECT_EQ
(
rmsf32
(
&
(
data
[
startIdx
]
)
2
rate
/
10
)
0
.
0
)
;
}
}
struct
AudioTrackSet
{
public
:
explicit
AudioTrackSet
(
CubebUtils
:
:
AudioDeviceID
aInputDeviceId
)
:
mInputDeviceID
(
aInputDeviceId
)
mOutputTrackKey
(
nullptr
)
{
}
~
AudioTrackSet
(
)
=
default
;
void
Init
(
MediaTrackGraph
*
aGraph
uint32_t
aInputChannelCount
)
{
mInputTrack
=
AudioInputTrack
:
:
Create
(
aGraph
)
;
mOutputTrack
=
aGraph
-
>
CreateForwardedInputTrack
(
MediaSegment
:
:
AUDIO
)
;
mOutputTrack
-
>
QueueSetAutoend
(
false
)
;
mOutputTrack
-
>
AddAudioOutput
(
OutputTrackKey
(
)
)
;
mPort
=
mOutputTrack
-
>
AllocateInputPort
(
mInputTrack
)
;
mListener
=
new
AudioInputProcessing
(
aInputChannelCount
PRINCIPAL_HANDLE_NONE
)
;
mInputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
mInputTrack
mListener
true
)
)
;
mInputTrack
-
>
SetInputProcessing
(
mListener
)
;
mInputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
mInputTrack
mListener
)
)
;
mInputTrack
-
>
OpenAudioInput
(
mInputDeviceID
mListener
)
;
mInputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetRequestedInputChannelCount
>
(
mInputTrack
mListener
aInputChannelCount
)
)
;
}
void
Uninit
(
)
{
mOutputTrack
-
>
RemoveAudioOutput
(
OutputTrackKey
(
)
)
;
mOutputTrack
-
>
Destroy
(
)
;
mPort
-
>
Destroy
(
)
;
mInputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
mListener
)
)
;
mInputTrack
-
>
CloseAudioInput
(
)
;
mInputTrack
-
>
Destroy
(
)
;
mPort
=
nullptr
;
mOutputTrack
=
nullptr
;
mListener
=
nullptr
;
mInputTrack
=
nullptr
;
}
void
AppendMessage
(
UniquePtr
<
ControlMessage
>
&
&
aMessage
)
{
mInputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
std
:
:
move
(
aMessage
)
)
;
}
RefPtr
<
MediaTrackGraph
:
:
GraphStartedPromise
>
NotifyWhenDeviceStarted
(
)
{
return
mInputTrack
-
>
GraphImpl
(
)
-
>
NotifyWhenDeviceStarted
(
mInputTrack
)
;
}
private
:
void
*
OutputTrackKey
(
)
{
return
const_cast
<
void
*
>
(
mOutputTrackKey
)
;
}
const
CubebUtils
:
:
AudioDeviceID
mInputDeviceID
;
const
void
*
mOutputTrackKey
;
RefPtr
<
AudioInputTrack
>
mInputTrack
;
RefPtr
<
AudioInputProcessing
>
mListener
;
RefPtr
<
ProcessedMediaTrack
>
mOutputTrack
;
RefPtr
<
MediaInputPort
>
mPort
;
}
;
TEST
(
TestAudioTrackGraph
SwitchingDriverIfMaxChannelCountChanged
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
auto
unforcer
=
WaitFor
(
cubeb
-
>
ForceAudioThread
(
)
)
.
unwrap
(
)
;
Unused
<
<
unforcer
;
MediaTrackGraph
*
graph
=
MediaTrackGraph
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
nullptr
MediaTrackGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
nullptr
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
void
*
)
1
;
RefPtr
<
SmartMockCubebStream
>
stream
;
AudioTrackSet
set1
(
deviceId
)
;
{
auto
started
=
Invoke
(
[
&
]
{
set1
.
Init
(
graph
2
)
;
return
set1
.
NotifyWhenDeviceStarted
(
)
;
}
)
;
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
Unused
<
<
WaitFor
(
started
)
;
}
AudioTrackSet
set2
(
deviceId
)
;
{
bool
destroyed
=
false
;
MediaEventListener
destroyListener
=
cubeb
-
>
StreamDestroyEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
)
{
destroyed
=
true
;
}
)
;
bool
created
=
false
;
MediaEventListener
restartListener
=
cubeb
-
>
StreamInitEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
)
{
created
=
true
;
}
)
;
Unused
<
<
WaitFor
(
Invoke
(
[
&
]
{
set2
.
Init
(
graph
1
)
;
return
set2
.
NotifyWhenDeviceStarted
(
)
;
}
)
)
;
DispatchFunction
(
[
&
]
{
set2
.
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
uint32_t
totalFrames
=
0
;
WaitUntil
(
stream
-
>
FramesVerifiedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
graph
-
>
GraphRate
(
)
)
;
}
)
;
cubeb
-
>
DontGoFaster
(
)
;
destroyListener
.
Disconnect
(
)
;
restartListener
.
Disconnect
(
)
;
EXPECT_FALSE
(
destroyed
)
;
EXPECT_FALSE
(
created
)
;
}
{
bool
destroyed
=
false
;
MediaEventListener
destroyListener
=
cubeb
-
>
StreamDestroyEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aDestroyed
)
{
destroyed
=
aDestroyed
.
get
(
)
=
=
stream
.
get
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
newStream
;
MediaEventListener
restartListener
=
cubeb
-
>
StreamInitEvent
(
)
.
Connect
(
AbstractThread
:
:
GetCurrent
(
)
[
&
]
(
const
RefPtr
<
SmartMockCubebStream
>
&
aCreated
)
{
newStream
=
aCreated
;
}
)
;
DispatchFunction
(
[
&
]
{
set1
.
Uninit
(
)
;
}
)
;
SpinEventLoopUntil
<
ProcessFailureBehavior
:
:
IgnoreAndContinue
>
(
"
TEST
(
TestAudioTrackGraph
SwitchingDriverIfMaxChannelChanged
)
"
_ns
[
&
]
{
return
destroyed
&
&
newStream
;
}
)
;
destroyListener
.
Disconnect
(
)
;
restartListener
.
Disconnect
(
)
;
stream
=
newStream
;
}
DispatchFunction
(
[
&
]
{
set2
.
Uninit
(
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
destroyedStream
=
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
destroyedStream
.
get
(
)
stream
.
get
(
)
)
;
}
void
TestCrossGraphPort
(
uint32_t
aInputRate
uint32_t
aOutputRate
float
aDriftFactor
uint32_t
aBufferMs
=
50
)
{
std
:
:
cerr
<
<
"
TestCrossGraphPort
input
:
"
<
<
aInputRate
<
<
"
output
:
"
<
<
aOutputRate
<
<
"
driftFactor
:
"
<
<
aDriftFactor
<
<
std
:
:
endl
;
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
auto
unforcer
=
WaitFor
(
cubeb
-
>
ForceAudioThread
(
)
)
.
unwrap
(
)
;
Unused
<
<
unforcer
;
cubeb
-
>
SetStreamStartFreezeEnabled
(
true
)
;
MediaTrackGraph
*
primary
=
MediaTrackGraph
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
nullptr
aInputRate
nullptr
)
;
MediaTrackGraph
*
partner
=
MediaTrackGraph
:
:
GetInstance
(
MediaTrackGraph
:
:
SYSTEM_THREAD_DRIVER
nullptr
aOutputRate
reinterpret_cast
<
cubeb_devid
>
(
1
)
)
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
void
*
)
1
;
RefPtr
<
AudioInputTrack
>
inputTrack
;
RefPtr
<
AudioInputProcessing
>
listener
;
auto
primaryStarted
=
Invoke
(
[
&
]
{
inputTrack
=
AudioInputTrack
:
:
Create
(
primary
)
;
listener
=
new
AudioInputProcessing
(
2
PRINCIPAL_HANDLE_NONE
)
;
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
SetPassThrough
>
(
inputTrack
listener
true
)
)
;
inputTrack
-
>
SetInputProcessing
(
listener
)
;
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StartInputProcessing
>
(
inputTrack
listener
)
)
;
inputTrack
-
>
OpenAudioInput
(
deviceId
listener
)
;
return
primary
-
>
NotifyWhenDeviceStarted
(
inputTrack
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
inputStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
RefPtr
<
CrossGraphTransmitter
>
transmitter
;
RefPtr
<
MediaInputPort
>
port
;
RefPtr
<
CrossGraphReceiver
>
receiver
;
auto
partnerStarted
=
Invoke
(
[
&
]
{
receiver
=
partner
-
>
CreateCrossGraphReceiver
(
primary
-
>
GraphRate
(
)
)
;
transmitter
=
primary
-
>
CreateCrossGraphTransmitter
(
receiver
)
;
port
=
transmitter
-
>
AllocateInputPort
(
inputTrack
)
;
receiver
-
>
AddAudioOutput
(
(
void
*
)
1
)
;
return
partner
-
>
NotifyWhenDeviceStarted
(
receiver
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
partnerStream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
partnerStream
-
>
SetDriftFactor
(
aDriftFactor
)
;
cubeb
-
>
SetStreamStartFreezeEnabled
(
false
)
;
inputStream
-
>
Thaw
(
)
;
partnerStream
-
>
Thaw
(
)
;
Unused
<
<
WaitFor
(
primaryStarted
)
;
Unused
<
<
WaitFor
(
partnerStarted
)
;
DispatchFunction
(
[
&
]
{
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
GoFaster
>
(
cubeb
)
)
;
}
)
;
uint32_t
totalFrames
=
0
;
WaitUntil
(
partnerStream
-
>
FramesVerifiedEvent
(
)
[
&
]
(
uint32_t
aFrames
)
{
totalFrames
+
=
aFrames
;
return
totalFrames
>
static_cast
<
uint32_t
>
(
partner
-
>
GraphRate
(
)
*
3
)
;
}
)
;
cubeb
-
>
DontGoFaster
(
)
;
DispatchFunction
(
[
&
]
{
receiver
-
>
RemoveAudioOutput
(
(
void
*
)
1
)
;
receiver
-
>
Destroy
(
)
;
transmitter
-
>
Destroy
(
)
;
port
-
>
Destroy
(
)
;
inputTrack
-
>
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
StopInputProcessing
>
(
listener
)
)
;
inputTrack
-
>
CloseAudioInput
(
)
;
inputTrack
-
>
Destroy
(
)
;
}
)
;
uint32_t
inputFrequency
=
inputStream
-
>
InputFrequency
(
)
;
uint32_t
partnerRate
=
partnerStream
-
>
InputSampleRate
(
)
;
uint64_t
preSilenceSamples
;
float
estimatedFreq
;
uint32_t
nrDiscontinuities
;
Tie
(
preSilenceSamples
estimatedFreq
nrDiscontinuities
)
=
WaitFor
(
partnerStream
-
>
OutputVerificationEvent
(
)
)
;
EXPECT_NEAR
(
estimatedFreq
inputFrequency
/
aDriftFactor
5
)
;
uint32_t
expectedPreSilence
=
static_cast
<
uint32_t
>
(
partnerRate
*
aDriftFactor
/
1000
*
aBufferMs
)
;
uint32_t
margin
=
partnerRate
/
20
;
EXPECT_NEAR
(
preSilenceSamples
expectedPreSilence
margin
)
;
EXPECT_LE
(
nrDiscontinuities
1U
)
;
}
TEST
(
TestAudioTrackGraph
CrossGraphPort
)
{
TestCrossGraphPort
(
44100
44100
1
)
;
TestCrossGraphPort
(
44100
44100
1
.
08
)
;
TestCrossGraphPort
(
44100
44100
0
.
92
)
;
TestCrossGraphPort
(
48000
44100
1
)
;
TestCrossGraphPort
(
48000
44100
1
.
08
)
;
TestCrossGraphPort
(
48000
44100
0
.
92
)
;
TestCrossGraphPort
(
44100
48000
1
)
;
TestCrossGraphPort
(
44100
48000
1
.
08
)
;
TestCrossGraphPort
(
44100
48000
0
.
92
)
;
TestCrossGraphPort
(
52110
17781
1
)
;
TestCrossGraphPort
(
52110
17781
1
.
08
)
;
TestCrossGraphPort
(
52110
17781
0
.
92
)
;
}
TEST
(
TestAudioTrackGraph
CrossGraphPortLargeBuffer
)
{
const
int32_t
oldBuffering
=
Preferences
:
:
GetInt
(
DRIFT_BUFFERING_PREF
)
;
const
int32_t
longBuffering
=
5000
;
Preferences
:
:
SetInt
(
DRIFT_BUFFERING_PREF
longBuffering
)
;
TestCrossGraphPort
(
44100
44100
1
.
02
longBuffering
)
;
TestCrossGraphPort
(
48000
44100
1
.
08
longBuffering
)
;
TestCrossGraphPort
(
44100
48000
0
.
95
longBuffering
)
;
TestCrossGraphPort
(
52110
17781
0
.
92
longBuffering
)
;
Preferences
:
:
SetInt
(
DRIFT_BUFFERING_PREF
oldBuffering
)
;
}
#
endif
