#
include
<
stdio
.
h
>
#
include
"
WebMBufferedParser
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
nsTArray
.
h
"
using
namespace
mozilla
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
nsresult
aResult
)
{
return
aStream
<
<
GetStaticErrorName
(
aResult
)
;
}
namespace
mozilla
{
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
MediaResult
&
aResult
)
{
aStream
<
<
aResult
.
Code
(
)
;
if
(
!
aResult
.
Message
(
)
.
IsEmpty
(
)
)
{
aStream
<
<
"
(
"
<
<
aResult
.
Message
(
)
<
<
"
)
"
;
}
return
aStream
;
}
}
static
const
uint64_t
gTimecodes
[
]
=
{
66000000
160000000
166000000
200000000
233000000
320000000
}
;
static
const
int64_t
gEndOffsets
[
]
=
{
466
737
1209
1345
1508
1980
}
;
TEST
(
WebMBuffered
BasicTests
)
{
WebMBufferedParser
parser
(
0
)
;
nsTArray
<
WebMTimeDataOffset
>
mapping
;
EXPECT_EQ
(
parser
.
Append
(
nullptr
0
mapping
)
NS_OK
)
;
EXPECT_TRUE
(
mapping
.
IsEmpty
(
)
)
;
EXPECT_EQ
(
parser
.
mStartOffset
0
)
;
EXPECT_EQ
(
parser
.
mCurrentOffset
0
)
;
unsigned
char
buf
[
]
=
{
0x1a
0x45
0xdf
0xa3
}
;
EXPECT_EQ
(
parser
.
Append
(
buf
std
:
:
size
(
buf
)
mapping
)
NS_OK
)
;
EXPECT_TRUE
(
mapping
.
IsEmpty
(
)
)
;
EXPECT_EQ
(
parser
.
mStartOffset
0
)
;
EXPECT_EQ
(
parser
.
mCurrentOffset
4
)
;
}
static
void
ReadFile
(
const
char
*
aPath
nsTArray
<
uint8_t
>
&
aBuffer
)
{
FILE
*
f
=
fopen
(
aPath
"
rb
"
)
;
ASSERT_NE
(
f
(
FILE
*
)
nullptr
)
;
int
r
=
fseek
(
f
0
SEEK_END
)
;
ASSERT_EQ
(
r
0
)
;
long
size
=
ftell
(
f
)
;
ASSERT_NE
(
size
-
1
)
;
aBuffer
.
SetLength
(
size
)
;
r
=
fseek
(
f
0
SEEK_SET
)
;
ASSERT_EQ
(
r
0
)
;
size_t
got
=
fread
(
aBuffer
.
Elements
(
)
1
size
f
)
;
ASSERT_EQ
(
got
size_t
(
size
)
)
;
r
=
fclose
(
f
)
;
ASSERT_EQ
(
r
0
)
;
}
TEST
(
WebMBuffered
RealData
)
{
WebMBufferedParser
parser
(
0
)
;
nsTArray
<
uint8_t
>
webmData
;
ReadFile
(
"
test
.
webm
"
webmData
)
;
nsTArray
<
WebMTimeDataOffset
>
mapping
;
EXPECT_EQ
(
parser
.
Append
(
webmData
.
Elements
(
)
webmData
.
Length
(
)
mapping
)
NS_OK
)
;
EXPECT_EQ
(
mapping
.
Length
(
)
6u
)
;
EXPECT_EQ
(
parser
.
mStartOffset
0
)
;
EXPECT_EQ
(
parser
.
mCurrentOffset
int64_t
(
webmData
.
Length
(
)
)
)
;
EXPECT_EQ
(
parser
.
GetTimecodeScale
(
)
500000u
)
;
for
(
uint32_t
i
=
0
;
i
<
mapping
.
Length
(
)
;
+
+
i
)
{
EXPECT_EQ
(
mapping
[
i
]
.
mEndOffset
gEndOffsets
[
i
]
)
;
EXPECT_EQ
(
mapping
[
i
]
.
mSyncOffset
326
)
;
EXPECT_EQ
(
mapping
[
i
]
.
mTimecode
gTimecodes
[
i
]
)
;
}
}
TEST
(
WebMBuffered
RealDataAppend
)
{
WebMBufferedParser
parser
(
0
)
;
nsTArray
<
WebMTimeDataOffset
>
mapping
;
nsTArray
<
uint8_t
>
webmData
;
ReadFile
(
"
test
.
webm
"
webmData
)
;
uint32_t
arrayEntries
=
mapping
.
Length
(
)
;
size_t
offset
=
0
;
while
(
offset
<
webmData
.
Length
(
)
)
{
EXPECT_EQ
(
parser
.
Append
(
webmData
.
Elements
(
)
+
offset
1
mapping
)
NS_OK
)
;
offset
+
=
1
;
EXPECT_EQ
(
parser
.
mCurrentOffset
int64_t
(
offset
)
)
;
if
(
mapping
.
Length
(
)
!
=
arrayEntries
)
{
arrayEntries
=
mapping
.
Length
(
)
;
ASSERT_LE
(
arrayEntries
6u
)
;
uint32_t
i
=
arrayEntries
-
1
;
EXPECT_EQ
(
mapping
[
i
]
.
mEndOffset
gEndOffsets
[
i
]
)
;
EXPECT_EQ
(
mapping
[
i
]
.
mSyncOffset
326
)
;
EXPECT_EQ
(
mapping
[
i
]
.
mTimecode
gTimecodes
[
i
]
)
;
EXPECT_EQ
(
parser
.
GetTimecodeScale
(
)
500000u
)
;
}
}
EXPECT_EQ
(
mapping
.
Length
(
)
6u
)
;
EXPECT_EQ
(
parser
.
mStartOffset
0
)
;
EXPECT_EQ
(
parser
.
mCurrentOffset
int64_t
(
webmData
.
Length
(
)
)
)
;
EXPECT_EQ
(
parser
.
GetTimecodeScale
(
)
500000u
)
;
for
(
uint32_t
i
=
0
;
i
<
mapping
.
Length
(
)
;
+
+
i
)
{
EXPECT_EQ
(
mapping
[
i
]
.
mEndOffset
gEndOffsets
[
i
]
)
;
EXPECT_EQ
(
mapping
[
i
]
.
mSyncOffset
326
)
;
EXPECT_EQ
(
mapping
[
i
]
.
mTimecode
gTimecodes
[
i
]
)
;
}
}
TEST
(
WebMBuffered
InvalidEBMLMaxIdLength
)
{
WebMBufferedParser
parser
(
0
)
;
nsTArray
<
uint8_t
>
webmData
;
ReadFile
(
"
test_InvalidElementId
.
webm
"
webmData
)
;
nsTArray
<
WebMTimeDataOffset
>
mapping
;
EXPECT_EQ
(
parser
.
Append
(
webmData
.
Elements
(
)
webmData
.
Length
(
)
mapping
)
NS_ERROR_FAILURE
)
;
}
TEST
(
WebMBuffered
InvalidLargeElementIdLength
)
{
WebMBufferedParser
parser
(
0
)
;
nsTArray
<
uint8_t
>
webmData
;
ReadFile
(
"
test_InvalidLargeElementId
.
webm
"
webmData
)
;
nsTArray
<
WebMTimeDataOffset
>
mapping
;
EXPECT_EQ
(
parser
.
Append
(
webmData
.
Elements
(
)
webmData
.
Length
(
)
mapping
)
NS_ERROR_FAILURE
)
;
}
TEST
(
WebMBuffered
InvalidSmallEBMLMaxIdLength
)
{
WebMBufferedParser
parser
(
0
)
;
nsTArray
<
uint8_t
>
webmData
;
ReadFile
(
"
test_InvalidSmallEBMLMaxIdLength
.
webm
"
webmData
)
;
nsTArray
<
WebMTimeDataOffset
>
mapping
;
EXPECT_EQ
(
parser
.
Append
(
webmData
.
Elements
(
)
webmData
.
Length
(
)
mapping
)
NS_ERROR_FAILURE
)
;
}
TEST
(
WebMBuffered
ValidLargeEBMLMaxIdLength
)
{
WebMBufferedParser
parser
(
0
)
;
nsTArray
<
uint8_t
>
webmData
;
ReadFile
(
"
test_ValidLargeEBMLMaxIdLength
.
webm
"
webmData
)
;
nsTArray
<
WebMTimeDataOffset
>
mapping
;
EXPECT_EQ
(
parser
.
Append
(
webmData
.
Elements
(
)
webmData
.
Length
(
)
mapping
)
NS_OK
)
;
}
TEST
(
WebMBuffered
InvalidLargeEBMLMaxIdLength
)
{
WebMBufferedParser
parser
(
0
)
;
nsTArray
<
uint8_t
>
webmData
;
ReadFile
(
"
test_InvalidLargeEBMLMaxIdLength
.
webm
"
webmData
)
;
nsTArray
<
WebMTimeDataOffset
>
mapping
;
EXPECT_EQ
(
parser
.
Append
(
webmData
.
Elements
(
)
webmData
.
Length
(
)
mapping
)
NS_ERROR_FAILURE
)
;
}
TEST
(
WebMBuffered
ValidSmallEBMLMaxSizeLength
)
{
WebMBufferedParser
parser
(
0
)
;
nsTArray
<
uint8_t
>
webmData
;
ReadFile
(
"
test_ValidSmallEBMLMaxSizeLength
.
webm
"
webmData
)
;
nsTArray
<
WebMTimeDataOffset
>
mapping
;
EXPECT_EQ
(
parser
.
Append
(
webmData
.
Elements
(
)
webmData
.
Length
(
)
mapping
)
NS_OK
)
;
}
TEST
(
WebMBuffered
InvalidEBMLMaxSizeLength
)
{
WebMBufferedParser
parser
(
0
)
;
nsTArray
<
uint8_t
>
webmData
;
ReadFile
(
"
test_InvalidElementSize
.
webm
"
webmData
)
;
nsTArray
<
WebMTimeDataOffset
>
mapping
;
EXPECT_EQ
(
parser
.
Append
(
webmData
.
Elements
(
)
webmData
.
Length
(
)
mapping
)
NS_ERROR_FAILURE
)
;
}
