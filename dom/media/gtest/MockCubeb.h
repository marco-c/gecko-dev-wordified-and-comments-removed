#
ifndef
MOCKCUBEB_H_
#
define
MOCKCUBEB_H_
#
include
<
atomic
>
#
include
<
chrono
>
#
include
<
thread
>
#
include
<
utility
>
#
include
"
AudioDeviceInfo
.
h
"
#
include
"
AudioGenerator
.
h
"
#
include
"
AudioVerifier
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
ThreadSafeWeakPtr
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
const
uint32_t
MAX_OUTPUT_CHANNELS
=
2
;
const
uint32_t
MAX_INPUT_CHANNELS
=
2
;
struct
cubeb_ops
{
int
(
*
init
)
(
cubeb
*
*
context
char
const
*
context_name
)
;
char
const
*
(
*
get_backend_id
)
(
cubeb
*
context
)
;
int
(
*
get_max_channel_count
)
(
cubeb
*
context
uint32_t
*
max_channels
)
;
int
(
*
get_min_latency
)
(
cubeb
*
context
cubeb_stream_params
params
uint32_t
*
latency_ms
)
;
int
(
*
get_preferred_sample_rate
)
(
cubeb
*
context
uint32_t
*
rate
)
;
int
(
*
get_supported_input_processing_params
)
(
cubeb
*
context
cubeb_input_processing_params
*
params
)
;
int
(
*
enumerate_devices
)
(
cubeb
*
context
cubeb_device_type
type
cubeb_device_collection
*
collection
)
;
int
(
*
device_collection_destroy
)
(
cubeb
*
context
cubeb_device_collection
*
collection
)
;
void
(
*
destroy
)
(
cubeb
*
context
)
;
int
(
*
stream_init
)
(
cubeb
*
context
cubeb_stream
*
*
stream
char
const
*
stream_name
cubeb_devid
input_device
cubeb_stream_params
*
input_stream_params
cubeb_devid
output_device
cubeb_stream_params
*
output_stream_params
unsigned
int
latency
cubeb_data_callback
data_callback
cubeb_state_callback
state_callback
void
*
user_ptr
)
;
void
(
*
stream_destroy
)
(
cubeb_stream
*
stream
)
;
int
(
*
stream_start
)
(
cubeb_stream
*
stream
)
;
int
(
*
stream_stop
)
(
cubeb_stream
*
stream
)
;
int
(
*
stream_get_position
)
(
cubeb_stream
*
stream
uint64_t
*
position
)
;
int
(
*
stream_get_latency
)
(
cubeb_stream
*
stream
uint32_t
*
latency
)
;
int
(
*
stream_get_input_latency
)
(
cubeb_stream
*
stream
uint32_t
*
latency
)
;
int
(
*
stream_set_volume
)
(
cubeb_stream
*
stream
float
volumes
)
;
int
(
*
stream_set_name
)
(
cubeb_stream
*
stream
char
const
*
stream_name
)
;
int
(
*
stream_get_current_device
)
(
cubeb_stream
*
stream
cubeb_device
*
*
const
device
)
;
int
(
*
stream_set_input_mute
)
(
cubeb_stream
*
stream
int
mute
)
;
int
(
*
stream_set_input_processing_params
)
(
cubeb_stream
*
stream
cubeb_input_processing_params
params
)
;
int
(
*
stream_device_destroy
)
(
cubeb_stream
*
stream
cubeb_device
*
device
)
;
int
(
*
stream_register_device_changed_callback
)
(
cubeb_stream
*
stream
cubeb_device_changed_callback
device_changed_callback
)
;
int
(
*
register_device_collection_changed
)
(
cubeb
*
context
cubeb_device_type
devtype
cubeb_device_collection_changed_callback
callback
void
*
user_ptr
)
;
}
;
void
cubeb_mock_destroy
(
cubeb
*
context
)
;
static
int
cubeb_mock_get_supported_input_processing_params
(
cubeb
*
context
cubeb_input_processing_params
*
params
)
;
static
int
cubeb_mock_enumerate_devices
(
cubeb
*
context
cubeb_device_type
type
cubeb_device_collection
*
out
)
;
static
int
cubeb_mock_device_collection_destroy
(
cubeb
*
context
cubeb_device_collection
*
collection
)
;
static
int
cubeb_mock_register_device_collection_changed
(
cubeb
*
context
cubeb_device_type
devtype
cubeb_device_collection_changed_callback
callback
void
*
user_ptr
)
;
static
int
cubeb_mock_stream_init
(
cubeb
*
context
cubeb_stream
*
*
stream
char
const
*
stream_name
cubeb_devid
input_device
cubeb_stream_params
*
input_stream_params
cubeb_devid
output_device
cubeb_stream_params
*
output_stream_params
unsigned
int
latency
cubeb_data_callback
data_callback
cubeb_state_callback
state_callback
void
*
user_ptr
)
;
static
int
cubeb_mock_stream_start
(
cubeb_stream
*
stream
)
;
static
int
cubeb_mock_stream_stop
(
cubeb_stream
*
stream
)
;
static
int
cubeb_mock_stream_get_position
(
cubeb_stream
*
stream
uint64_t
*
position
)
;
static
void
cubeb_mock_stream_destroy
(
cubeb_stream
*
stream
)
;
static
char
const
*
cubeb_mock_get_backend_id
(
cubeb
*
context
)
;
static
int
cubeb_mock_stream_set_volume
(
cubeb_stream
*
stream
float
volume
)
;
static
int
cubeb_mock_stream_set_name
(
cubeb_stream
*
stream
char
const
*
stream_name
)
;
static
int
cubeb_mock_stream_set_input_processing_params
(
cubeb_stream
*
stream
cubeb_input_processing_params
)
;
static
int
cubeb_mock_stream_register_device_changed_callback
(
cubeb_stream
*
stream
cubeb_device_changed_callback
device_changed_callback
)
;
static
int
cubeb_mock_get_min_latency
(
cubeb
*
context
cubeb_stream_params
params
uint32_t
*
latency_ms
)
;
static
int
cubeb_mock_get_preferred_sample_rate
(
cubeb
*
context
uint32_t
*
rate
)
;
static
int
cubeb_mock_get_max_channel_count
(
cubeb
*
context
uint32_t
*
max_channels
)
;
cubeb_ops
const
mock_ops
=
{
NULL
cubeb_mock_get_backend_id
cubeb_mock_get_max_channel_count
cubeb_mock_get_min_latency
cubeb_mock_get_preferred_sample_rate
cubeb_mock_get_supported_input_processing_params
cubeb_mock_enumerate_devices
cubeb_mock_device_collection_destroy
cubeb_mock_destroy
cubeb_mock_stream_init
cubeb_mock_stream_destroy
cubeb_mock_stream_start
cubeb_mock_stream_stop
cubeb_mock_stream_get_position
NULL
NULL
cubeb_mock_stream_set_volume
cubeb_mock_stream_set_name
NULL
NULL
cubeb_mock_stream_set_input_processing_params
NULL
cubeb_mock_stream_register_device_changed_callback
cubeb_mock_register_device_collection_changed
}
;
class
SmartMockCubebStream
;
class
MockCubebStream
{
friend
class
MockCubeb
;
cubeb
*
context
;
void
*
mUserPtr
;
public
:
enum
class
KeepProcessing
{
No
Yes
InvalidState
}
;
enum
class
RunningMode
{
Automatic
Manual
}
;
MockCubebStream
(
cubeb
*
aContext
char
const
*
aStreamName
cubeb_devid
aInputDevice
cubeb_stream_params
*
aInputStreamParams
cubeb_devid
aOutputDevice
cubeb_stream_params
*
aOutputStreamParams
cubeb_data_callback
aDataCallback
cubeb_state_callback
aStateCallback
void
*
aUserPtr
SmartMockCubebStream
*
aSelf
RunningMode
aRunningMode
bool
aFrozenStart
)
;
~
MockCubebStream
(
)
;
int
Start
(
)
MOZ_EXCLUDES
(
mMutex
)
;
int
Stop
(
)
MOZ_EXCLUDES
(
mMutex
)
;
uint64_t
Position
(
)
MOZ_EXCLUDES
(
mMutex
)
;
void
Destroy
(
)
MOZ_EXCLUDES
(
mMutex
)
;
int
SetName
(
char
const
*
aName
)
MOZ_EXCLUDES
(
mMutex
)
;
int
RegisterDeviceChangedCallback
(
cubeb_device_changed_callback
aDeviceChangedCallback
)
MOZ_EXCLUDES
(
mMutex
)
;
int
SetInputProcessingParams
(
cubeb_input_processing_params
aParams
)
;
cubeb_stream
*
AsCubebStream
(
)
MOZ_EXCLUDES
(
mMutex
)
;
static
MockCubebStream
*
AsMock
(
cubeb_stream
*
aStream
)
;
char
const
*
StreamName
(
)
const
MOZ_EXCLUDES
(
mMutex
)
{
MutexAutoLock
l
(
mMutex
)
;
return
mName
.
get
(
)
;
}
cubeb_devid
GetInputDeviceID
(
)
const
;
cubeb_devid
GetOutputDeviceID
(
)
const
;
uint32_t
InputChannels
(
)
const
MOZ_EXCLUDES
(
mMutex
)
;
uint32_t
OutputChannels
(
)
const
MOZ_EXCLUDES
(
mMutex
)
;
uint32_t
SampleRate
(
)
const
MOZ_EXCLUDES
(
mMutex
)
;
uint32_t
InputFrequency
(
)
const
MOZ_EXCLUDES
(
mMutex
)
;
Maybe
<
cubeb_state
>
State
(
)
const
MOZ_EXCLUDES
(
mMutex
)
;
void
SetDriftFactor
(
float
aDriftFactor
)
MOZ_EXCLUDES
(
mMutex
)
;
void
ForceError
(
)
MOZ_EXCLUDES
(
mMutex
)
;
void
ForceDeviceChanged
(
)
MOZ_EXCLUDES
(
mMutex
)
;
void
Thaw
(
)
MOZ_EXCLUDES
(
mMutex
)
;
KeepProcessing
ManualDataCallback
(
long
aNrFrames
)
MOZ_EXCLUDES
(
mMutex
)
;
void
NotifyDeviceChangedNow
(
)
MOZ_EXCLUDES
(
mMutex
)
;
void
SetOutputRecordingEnabled
(
bool
aEnabled
)
MOZ_EXCLUDES
(
mMutex
)
;
void
SetInputRecordingEnabled
(
bool
aEnabled
)
MOZ_EXCLUDES
(
mMutex
)
;
nsTArray
<
AudioDataValue
>
&
&
TakeRecordedOutput
(
)
MOZ_EXCLUDES
(
mMutex
)
;
nsTArray
<
AudioDataValue
>
&
&
TakeRecordedInput
(
)
MOZ_EXCLUDES
(
mMutex
)
;
MediaEventSource
<
nsCString
>
&
NameSetEvent
(
)
;
MediaEventSource
<
cubeb_state
>
&
StateEvent
(
)
;
MediaEventSource
<
uint32_t
>
&
FramesProcessedEvent
(
)
;
MediaEventSource
<
uint32_t
>
&
FramesVerifiedEvent
(
)
;
MediaEventSource
<
std
:
:
tuple
<
uint64_t
float
uint32_t
>
>
&
OutputVerificationEvent
(
)
;
MediaEventSource
<
void
>
&
ErrorForcedEvent
(
)
;
MediaEventSource
<
void
>
&
DeviceChangeForcedEvent
(
)
;
private
:
cubeb_stream
*
AsCubebStreamLocked
(
)
MOZ_REQUIRES
(
mMutex
)
;
static
MockCubebStream
*
AsMockLocked
(
cubeb_stream
*
aStream
)
;
uint32_t
InputChannelsLocked
(
)
const
MOZ_REQUIRES
(
mMutex
)
;
uint32_t
OutputChannelsLocked
(
)
const
MOZ_REQUIRES
(
mMutex
)
;
uint32_t
SampleRateLocked
(
)
const
MOZ_REQUIRES
(
mMutex
)
;
uint32_t
InputFrequencyLocked
(
)
const
MOZ_REQUIRES
(
mMutex
)
;
KeepProcessing
Process
(
long
aNrFrames
)
MOZ_REQUIRES
(
mMutex
)
;
KeepProcessing
Process10Ms
(
)
;
public
:
const
RunningMode
mRunningMode
;
const
bool
mHasInput
;
const
bool
mHasOutput
;
SmartMockCubebStream
*
const
mSelf
;
private
:
void
NotifyState
(
cubeb_state
aState
)
MOZ_REQUIRES
(
mMutex
)
;
void
NotifyDeviceChanged
(
)
MOZ_EXCLUDES
(
mMutex
)
;
static
constexpr
long
kMaxNrFrames
=
1920
;
mutable
Mutex
mMutex
{
"
MockCubebStream
:
:
mMutex
"
}
;
Monitor
mFrozenStartMonitor
MOZ_ACQUIRED_BEFORE
(
mMutex
)
;
bool
mFrozenStart
MOZ_GUARDED_BY
(
mFrozenStartMonitor
)
;
Maybe
<
cubeb_state
>
mState
MOZ_GUARDED_BY
(
mMutex
)
;
bool
mOutputRecordingEnabled
MOZ_GUARDED_BY
(
mMutex
)
=
false
;
bool
mInputRecordingEnabled
MOZ_GUARDED_BY
(
mMutex
)
=
false
;
AudioDataValue
mOutputBuffer
[
MAX_OUTPUT_CHANNELS
*
kMaxNrFrames
]
MOZ_GUARDED_BY
(
mMutex
)
=
{
}
;
AudioDataValue
mInputBuffer
[
MAX_INPUT_CHANNELS
*
kMaxNrFrames
]
MOZ_GUARDED_BY
(
mMutex
)
=
{
}
;
const
cubeb_data_callback
mDataCallback
=
nullptr
;
const
cubeb_state_callback
mStateCallback
=
nullptr
;
cubeb_device_changed_callback
mDeviceChangedCallback
MOZ_GUARDED_BY
(
mMutex
)
=
nullptr
;
nsCString
mName
MOZ_GUARDED_BY
(
mMutex
)
;
cubeb_stream_params
mOutputParams
MOZ_GUARDED_BY
(
mMutex
)
=
{
}
;
cubeb_stream_params
mInputParams
MOZ_GUARDED_BY
(
mMutex
)
=
{
}
;
const
cubeb_devid
mInputDeviceID
;
const
cubeb_devid
mOutputDeviceID
;
float
mDriftFactor
MOZ_GUARDED_BY
(
mMutex
)
=
1
.
0
;
bool
mFastMode
MOZ_GUARDED_BY
(
mMutex
)
=
false
;
bool
mForceErrorState
MOZ_GUARDED_BY
(
mMutex
)
=
false
;
bool
mForceDeviceChanged
MOZ_GUARDED_BY
(
mMutex
)
=
false
;
bool
mDestroyed
MOZ_GUARDED_BY
(
mMutex
)
=
false
;
uint64_t
mPosition
MOZ_GUARDED_BY
(
mMutex
)
=
0
;
AudioGenerator
<
AudioDataValue
>
mAudioGenerator
MOZ_GUARDED_BY
(
mMutex
)
;
AudioVerifier
<
AudioDataValue
>
mAudioVerifier
MOZ_GUARDED_BY
(
mMutex
)
;
MediaEventProducer
<
nsCString
>
mNameSetEvent
;
MediaEventProducer
<
cubeb_state
>
mStateEvent
;
MediaEventProducer
<
uint32_t
>
mFramesProcessedEvent
;
MediaEventProducer
<
uint32_t
>
mFramesVerifiedEvent
;
MediaEventProducer
<
std
:
:
tuple
<
uint64_t
float
uint32_t
>
>
mOutputVerificationEvent
;
MediaEventProducer
<
void
>
mErrorForcedEvent
;
MediaEventProducer
<
void
>
mDeviceChangedForcedEvent
;
nsTArray
<
AudioDataValue
>
mRecordedOutput
MOZ_GUARDED_BY
(
mMutex
)
;
nsTArray
<
AudioDataValue
>
mRecordedInput
MOZ_GUARDED_BY
(
mMutex
)
;
}
;
inline
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
MockCubebStream
:
:
KeepProcessing
&
aVal
)
{
switch
(
aVal
)
{
case
MockCubebStream
:
:
KeepProcessing
:
:
Yes
:
aStream
<
<
"
KeepProcessing
:
:
Yes
"
;
return
aStream
;
case
MockCubebStream
:
:
KeepProcessing
:
:
No
:
aStream
<
<
"
KeepProcessing
:
:
No
"
;
return
aStream
;
case
MockCubebStream
:
:
KeepProcessing
:
:
InvalidState
:
aStream
<
<
"
KeepProcessing
:
:
InvalidState
"
;
return
aStream
;
}
aStream
<
<
"
KeepProcessing
(
invalid
"
<
<
static_cast
<
uint32_t
>
(
aVal
)
<
<
"
)
"
;
return
aStream
;
}
class
SmartMockCubebStream
:
public
MockCubebStream
public
SupportsThreadSafeWeakPtr
<
SmartMockCubebStream
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
SmartMockCubebStream
)
SmartMockCubebStream
(
cubeb
*
aContext
char
const
*
aStreamName
cubeb_devid
aInputDevice
cubeb_stream_params
*
aInputStreamParams
cubeb_devid
aOutputDevice
cubeb_stream_params
*
aOutputStreamParams
cubeb_data_callback
aDataCallback
cubeb_state_callback
aStateCallback
void
*
aUserPtr
RunningMode
aRunningMode
bool
aFrozenStart
)
:
MockCubebStream
(
aContext
aStreamName
aInputDevice
aInputStreamParams
aOutputDevice
aOutputStreamParams
aDataCallback
aStateCallback
aUserPtr
this
aRunningMode
aFrozenStart
)
{
}
}
;
class
MockCubeb
{
const
cubeb_ops
*
ops
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MockCubeb
)
;
public
:
using
RunningMode
=
MockCubebStream
:
:
RunningMode
;
MockCubeb
(
)
;
explicit
MockCubeb
(
RunningMode
aRunningMode
)
;
cubeb
*
AsCubebContext
(
)
;
static
MockCubeb
*
AsMock
(
cubeb
*
aContext
)
;
void
Destroy
(
)
;
int
EnumerateDevices
(
cubeb_device_type
aType
cubeb_device_collection
*
aCollection
)
;
int
DestroyDeviceCollection
(
cubeb_device_collection
*
aCollection
)
;
int
RegisterDeviceCollectionChangeCallback
(
cubeb_device_type
aDevType
cubeb_device_collection_changed_callback
aCallback
void
*
aUserPtr
)
;
Result
<
cubeb_input_processing_params
int
>
SupportedInputProcessingParams
(
)
const
;
void
SetSupportedInputProcessingParams
(
cubeb_input_processing_params
aParams
int
aRv
)
;
void
SetInputProcessingApplyRv
(
int
aRv
)
;
int
InputProcessingApplyRv
(
)
const
;
void
AddDevice
(
cubeb_device_info
aDevice
)
;
bool
RemoveDevice
(
cubeb_devid
aId
)
;
void
ClearDevices
(
cubeb_device_type
aType
)
;
void
SetSupportDeviceChangeCallback
(
bool
aSupports
)
;
void
ForceStreamInitError
(
)
;
void
SetStreamStartFreezeEnabled
(
bool
aEnabled
)
;
class
AudioThreadAutoUnforcer
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AudioThreadAutoUnforcer
)
public
:
explicit
AudioThreadAutoUnforcer
(
MockCubeb
*
aContext
)
:
mContext
(
aContext
)
{
}
protected
:
virtual
~
AudioThreadAutoUnforcer
(
)
{
mContext
-
>
UnforceAudioThread
(
)
;
}
MockCubeb
*
mContext
;
}
;
using
ForcedAudioThreadPromise
=
MozPromise
<
RefPtr
<
AudioThreadAutoUnforcer
>
nsresult
false
>
;
RefPtr
<
ForcedAudioThreadPromise
>
ForceAudioThread
(
)
;
void
UnforceAudioThread
(
)
;
int
StreamInit
(
cubeb
*
aContext
cubeb_stream
*
*
aStream
char
const
*
aStreamName
cubeb_devid
aInputDevice
cubeb_stream_params
*
aInputStreamParams
cubeb_devid
aOutputDevice
cubeb_stream_params
*
aOutputStreamParams
cubeb_data_callback
aDataCallback
cubeb_state_callback
aStateCallback
void
*
aUserPtr
)
;
void
StreamDestroy
(
MockCubebStream
*
aStream
)
;
void
GoFaster
(
)
;
void
DontGoFaster
(
)
;
MediaEventSource
<
RefPtr
<
SmartMockCubebStream
>
>
&
StreamInitEvent
(
)
;
MediaEventSource
<
RefPtr
<
SmartMockCubebStream
>
>
&
StreamDestroyEvent
(
)
;
void
StartStream
(
MockCubebStream
*
aStream
)
;
void
StopStream
(
MockCubebStream
*
aStream
)
;
static
void
ThreadFunction_s
(
MockCubeb
*
aContext
)
{
aContext
-
>
ThreadFunction
(
)
;
}
void
ThreadFunction
(
)
;
private
:
~
MockCubeb
(
)
;
cubeb_device_collection_changed_callback
mInputDeviceCollectionChangeCallback
=
nullptr
;
cubeb_device_collection_changed_callback
mOutputDeviceCollectionChangeCallback
=
nullptr
;
void
*
mInputDeviceCollectionChangeUserPtr
=
nullptr
;
void
*
mOutputDeviceCollectionChangeUserPtr
=
nullptr
;
void
*
mUserPtr
=
nullptr
;
bool
mSupportsDeviceCollectionChangedCallback
=
true
;
std
:
:
pair
<
cubeb_input_processing_params
int
>
mSupportedInputProcessingParams
=
std
:
:
make_pair
(
CUBEB_INPUT_PROCESSING_PARAM_NONE
CUBEB_ERROR_NOT_SUPPORTED
)
;
int
mInputProcessingParamsApplyRv
=
CUBEB_OK
;
const
RunningMode
mRunningMode
;
Atomic
<
bool
>
mStreamInitErrorState
;
Atomic
<
bool
>
mStreamStartFreezeEnabled
{
false
}
;
Atomic
<
bool
>
mForcedAudioThread
{
false
}
;
Atomic
<
bool
>
mHasCubebContext
{
false
}
;
Atomic
<
bool
>
mDestroyed
{
false
}
;
MozPromiseHolder
<
ForcedAudioThreadPromise
>
mForcedAudioThreadPromise
;
nsTArray
<
cubeb_device_info
>
mInputDevices
;
nsTArray
<
cubeb_device_info
>
mOutputDevices
;
DataMutex
<
nsTArray
<
RefPtr
<
SmartMockCubebStream
>
>
>
mLiveStreams
{
"
MockCubeb
:
:
mLiveStreams
"
}
;
UniquePtr
<
std
:
:
thread
>
mFakeAudioThread
;
std
:
:
atomic
<
bool
>
mFastMode
{
false
}
;
MediaEventProducer
<
RefPtr
<
SmartMockCubebStream
>
>
mStreamInitEvent
;
MediaEventProducer
<
RefPtr
<
SmartMockCubebStream
>
>
mStreamDestroyEvent
;
}
;
int
cubeb_mock_enumerate_devices
(
cubeb
*
context
cubeb_device_type
type
cubeb_device_collection
*
out
)
{
return
MockCubeb
:
:
AsMock
(
context
)
-
>
EnumerateDevices
(
type
out
)
;
}
int
cubeb_mock_device_collection_destroy
(
cubeb
*
context
cubeb_device_collection
*
collection
)
{
return
MockCubeb
:
:
AsMock
(
context
)
-
>
DestroyDeviceCollection
(
collection
)
;
}
int
cubeb_mock_register_device_collection_changed
(
cubeb
*
context
cubeb_device_type
devtype
cubeb_device_collection_changed_callback
callback
void
*
user_ptr
)
{
return
MockCubeb
:
:
AsMock
(
context
)
-
>
RegisterDeviceCollectionChangeCallback
(
devtype
callback
user_ptr
)
;
}
int
cubeb_mock_get_supported_input_processing_params
(
cubeb
*
context
cubeb_input_processing_params
*
params
)
{
Result
<
cubeb_input_processing_params
int
>
res
=
MockCubeb
:
:
AsMock
(
context
)
-
>
SupportedInputProcessingParams
(
)
;
if
(
res
.
isErr
(
)
)
{
*
params
=
CUBEB_INPUT_PROCESSING_PARAM_NONE
;
return
res
.
unwrapErr
(
)
;
}
*
params
=
res
.
unwrap
(
)
;
return
CUBEB_OK
;
}
int
cubeb_mock_stream_init
(
cubeb
*
context
cubeb_stream
*
*
stream
char
const
*
stream_name
cubeb_devid
input_device
cubeb_stream_params
*
input_stream_params
cubeb_devid
output_device
cubeb_stream_params
*
output_stream_params
unsigned
int
latency
cubeb_data_callback
data_callback
cubeb_state_callback
state_callback
void
*
user_ptr
)
{
return
MockCubeb
:
:
AsMock
(
context
)
-
>
StreamInit
(
context
stream
stream_name
input_device
input_stream_params
output_device
output_stream_params
data_callback
state_callback
user_ptr
)
;
}
int
cubeb_mock_stream_start
(
cubeb_stream
*
stream
)
{
return
MockCubebStream
:
:
AsMock
(
stream
)
-
>
Start
(
)
;
}
int
cubeb_mock_stream_stop
(
cubeb_stream
*
stream
)
{
return
MockCubebStream
:
:
AsMock
(
stream
)
-
>
Stop
(
)
;
}
int
cubeb_mock_stream_get_position
(
cubeb_stream
*
stream
uint64_t
*
position
)
{
*
position
=
MockCubebStream
:
:
AsMock
(
stream
)
-
>
Position
(
)
;
return
CUBEB_OK
;
}
void
cubeb_mock_stream_destroy
(
cubeb_stream
*
stream
)
{
MockCubebStream
:
:
AsMock
(
stream
)
-
>
Destroy
(
)
;
}
static
char
const
*
cubeb_mock_get_backend_id
(
cubeb
*
context
)
{
#
if
defined
(
XP_MACOSX
)
return
"
audiounit
"
;
#
elif
defined
(
XP_WIN
)
return
"
wasapi
"
;
#
elif
defined
(
ANDROID
)
return
"
opensl
"
;
#
elif
defined
(
__OpenBSD__
)
return
"
sndio
"
;
#
else
return
"
pulse
"
;
#
endif
}
static
int
cubeb_mock_stream_set_volume
(
cubeb_stream
*
stream
float
volume
)
{
return
CUBEB_OK
;
}
static
int
cubeb_mock_stream_set_name
(
cubeb_stream
*
stream
char
const
*
stream_name
)
{
return
MockCubebStream
:
:
AsMock
(
stream
)
-
>
SetName
(
stream_name
)
;
return
CUBEB_OK
;
}
int
cubeb_mock_stream_register_device_changed_callback
(
cubeb_stream
*
stream
cubeb_device_changed_callback
device_changed_callback
)
{
return
MockCubebStream
:
:
AsMock
(
stream
)
-
>
RegisterDeviceChangedCallback
(
device_changed_callback
)
;
}
static
int
cubeb_mock_stream_set_input_processing_params
(
cubeb_stream
*
stream
cubeb_input_processing_params
params
)
{
return
MockCubebStream
:
:
AsMock
(
stream
)
-
>
SetInputProcessingParams
(
params
)
;
}
int
cubeb_mock_get_min_latency
(
cubeb
*
context
cubeb_stream_params
params
uint32_t
*
latency_ms
)
{
*
latency_ms
=
10
;
return
CUBEB_OK
;
}
int
cubeb_mock_get_preferred_sample_rate
(
cubeb
*
context
uint32_t
*
rate
)
{
*
rate
=
44100
;
return
CUBEB_OK
;
}
int
cubeb_mock_get_max_channel_count
(
cubeb
*
context
uint32_t
*
max_channels
)
{
*
max_channels
=
MAX_OUTPUT_CHANNELS
;
return
CUBEB_OK
;
}
void
PrintDevice
(
cubeb_device_info
aInfo
)
;
void
PrintDevice
(
AudioDeviceInfo
*
aInfo
)
;
cubeb_device_info
DeviceTemplate
(
cubeb_devid
aId
cubeb_device_type
aType
const
char
*
name
)
;
cubeb_device_info
DeviceTemplate
(
cubeb_devid
aId
cubeb_device_type
aType
)
;
void
AddDevices
(
MockCubeb
*
mock
uint32_t
device_count
cubeb_device_type
deviceType
)
;
}
#
endif
