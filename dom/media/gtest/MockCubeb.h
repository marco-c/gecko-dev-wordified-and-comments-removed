#
ifndef
MOCKCUBEB_H_
#
define
MOCKCUBEB_H_
#
include
"
AudioDeviceInfo
.
h
"
#
include
"
AudioGenerator
.
h
"
#
include
"
AudioVerifier
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
ThreadSafeWeakPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
<
thread
>
#
include
<
atomic
>
#
include
<
chrono
>
namespace
mozilla
{
const
uint32_t
MAX_OUTPUT_CHANNELS
=
2
;
const
uint32_t
MAX_INPUT_CHANNELS
=
2
;
struct
cubeb_ops
{
int
(
*
init
)
(
cubeb
*
*
context
char
const
*
context_name
)
;
char
const
*
(
*
get_backend_id
)
(
cubeb
*
context
)
;
int
(
*
get_max_channel_count
)
(
cubeb
*
context
uint32_t
*
max_channels
)
;
int
(
*
get_min_latency
)
(
cubeb
*
context
cubeb_stream_params
params
uint32_t
*
latency_ms
)
;
int
(
*
get_preferred_sample_rate
)
(
cubeb
*
context
uint32_t
*
rate
)
;
int
(
*
enumerate_devices
)
(
cubeb
*
context
cubeb_device_type
type
cubeb_device_collection
*
collection
)
;
int
(
*
device_collection_destroy
)
(
cubeb
*
context
cubeb_device_collection
*
collection
)
;
void
(
*
destroy
)
(
cubeb
*
context
)
;
int
(
*
stream_init
)
(
cubeb
*
context
cubeb_stream
*
*
stream
char
const
*
stream_name
cubeb_devid
input_device
cubeb_stream_params
*
input_stream_params
cubeb_devid
output_device
cubeb_stream_params
*
output_stream_params
unsigned
int
latency
cubeb_data_callback
data_callback
cubeb_state_callback
state_callback
void
*
user_ptr
)
;
void
(
*
stream_destroy
)
(
cubeb_stream
*
stream
)
;
int
(
*
stream_start
)
(
cubeb_stream
*
stream
)
;
int
(
*
stream_stop
)
(
cubeb_stream
*
stream
)
;
int
(
*
stream_get_position
)
(
cubeb_stream
*
stream
uint64_t
*
position
)
;
int
(
*
stream_get_latency
)
(
cubeb_stream
*
stream
uint32_t
*
latency
)
;
int
(
*
stream_get_input_latency
)
(
cubeb_stream
*
stream
uint32_t
*
latency
)
;
int
(
*
stream_set_volume
)
(
cubeb_stream
*
stream
float
volumes
)
;
int
(
*
stream_set_name
)
(
cubeb_stream
*
stream
char
const
*
stream_name
)
;
int
(
*
stream_get_current_device
)
(
cubeb_stream
*
stream
cubeb_device
*
*
const
device
)
;
int
(
*
stream_device_destroy
)
(
cubeb_stream
*
stream
cubeb_device
*
device
)
;
int
(
*
stream_register_device_changed_callback
)
(
cubeb_stream
*
stream
cubeb_device_changed_callback
device_changed_callback
)
;
int
(
*
register_device_collection_changed
)
(
cubeb
*
context
cubeb_device_type
devtype
cubeb_device_collection_changed_callback
callback
void
*
user_ptr
)
;
}
;
void
cubeb_mock_destroy
(
cubeb
*
context
)
;
static
int
cubeb_mock_enumerate_devices
(
cubeb
*
context
cubeb_device_type
type
cubeb_device_collection
*
out
)
;
static
int
cubeb_mock_device_collection_destroy
(
cubeb
*
context
cubeb_device_collection
*
collection
)
;
static
int
cubeb_mock_register_device_collection_changed
(
cubeb
*
context
cubeb_device_type
devtype
cubeb_device_collection_changed_callback
callback
void
*
user_ptr
)
;
static
int
cubeb_mock_stream_init
(
cubeb
*
context
cubeb_stream
*
*
stream
char
const
*
stream_name
cubeb_devid
input_device
cubeb_stream_params
*
input_stream_params
cubeb_devid
output_device
cubeb_stream_params
*
output_stream_params
unsigned
int
latency
cubeb_data_callback
data_callback
cubeb_state_callback
state_callback
void
*
user_ptr
)
;
static
int
cubeb_mock_stream_start
(
cubeb_stream
*
stream
)
;
static
int
cubeb_mock_stream_stop
(
cubeb_stream
*
stream
)
;
static
void
cubeb_mock_stream_destroy
(
cubeb_stream
*
stream
)
;
static
char
const
*
cubeb_mock_get_backend_id
(
cubeb
*
context
)
;
static
int
cubeb_mock_stream_set_volume
(
cubeb_stream
*
stream
float
volume
)
;
static
int
cubeb_mock_stream_set_name
(
cubeb_stream
*
stream
char
const
*
stream_name
)
;
static
int
cubeb_mock_get_min_latency
(
cubeb
*
context
cubeb_stream_params
params
uint32_t
*
latency_ms
)
;
static
int
cubeb_mock_get_max_channel_count
(
cubeb
*
context
uint32_t
*
max_channels
)
;
cubeb_ops
const
mock_ops
=
{
NULL
cubeb_mock_get_backend_id
cubeb_mock_get_max_channel_count
cubeb_mock_get_min_latency
NULL
cubeb_mock_enumerate_devices
cubeb_mock_device_collection_destroy
cubeb_mock_destroy
cubeb_mock_stream_init
cubeb_mock_stream_destroy
cubeb_mock_stream_start
cubeb_mock_stream_stop
NULL
NULL
NULL
cubeb_mock_stream_set_volume
cubeb_mock_stream_set_name
NULL
NULL
NULL
cubeb_mock_register_device_collection_changed
}
;
class
SmartMockCubebStream
;
class
MockCubebStream
{
public
:
MockCubebStream
(
cubeb
*
aContext
cubeb_devid
aInputDevice
cubeb_stream_params
*
aInputStreamParams
cubeb_devid
aOutputDevice
cubeb_stream_params
*
aOutputStreamParams
cubeb_data_callback
aDataCallback
cubeb_state_callback
aStateCallback
void
*
aUserPtr
SmartMockCubebStream
*
aSelf
bool
aFrozenStart
)
;
~
MockCubebStream
(
)
;
int
Start
(
)
;
int
Stop
(
)
;
cubeb_stream
*
AsCubebStream
(
)
;
static
MockCubebStream
*
AsMock
(
cubeb_stream
*
aStream
)
;
cubeb_devid
GetInputDeviceID
(
)
const
;
cubeb_devid
GetOutputDeviceID
(
)
const
;
uint32_t
InputChannels
(
)
const
;
uint32_t
OutputChannels
(
)
const
;
uint32_t
InputSampleRate
(
)
const
;
uint32_t
InputFrequency
(
)
const
;
void
SetDriftFactor
(
float
aDriftFactor
)
;
void
ForceError
(
)
;
void
Thaw
(
)
;
void
SetOutputRecordingEnabled
(
bool
aEnabled
)
;
nsTArray
<
AudioDataValue
>
&
&
TakeRecordedOutput
(
)
;
MediaEventSource
<
uint32_t
>
&
FramesProcessedEvent
(
)
;
MediaEventSource
<
uint32_t
>
&
FramesVerifiedEvent
(
)
;
MediaEventSource
<
Tuple
<
uint64_t
float
uint32_t
>
>
&
OutputVerificationEvent
(
)
;
MediaEventSource
<
void
>
&
ErrorForcedEvent
(
)
;
void
Process10Ms
(
)
;
public
:
cubeb
*
context
=
nullptr
;
const
bool
mHasInput
;
const
bool
mHasOutput
;
SmartMockCubebStream
*
const
mSelf
;
private
:
Monitor
mFrozenStartMonitor
MOZ_UNANNOTATED
;
bool
mFrozenStart
;
std
:
:
atomic_bool
mStreamStop
{
true
}
;
std
:
:
atomic_bool
mOutputRecordingEnabled
{
false
}
;
AudioDataValue
mOutputBuffer
[
MAX_OUTPUT_CHANNELS
*
1920
]
=
{
}
;
AudioDataValue
mInputBuffer
[
MAX_INPUT_CHANNELS
*
1920
]
=
{
}
;
cubeb_data_callback
mDataCallback
=
nullptr
;
cubeb_state_callback
mStateCallback
=
nullptr
;
void
*
mUserPtr
=
nullptr
;
cubeb_stream_params
mOutputParams
=
{
}
;
cubeb_stream_params
mInputParams
=
{
}
;
cubeb_devid
mInputDeviceID
;
cubeb_devid
mOutputDeviceID
;
std
:
:
atomic
<
float
>
mDriftFactor
{
1
.
0
}
;
std
:
:
atomic_bool
mFastMode
{
false
}
;
std
:
:
atomic_bool
mForceErrorState
{
false
}
;
AudioGenerator
<
AudioDataValue
>
mAudioGenerator
;
AudioVerifier
<
AudioDataValue
>
mAudioVerifier
;
MediaEventProducer
<
uint32_t
>
mFramesProcessedEvent
;
MediaEventProducer
<
uint32_t
>
mFramesVerifiedEvent
;
MediaEventProducer
<
Tuple
<
uint64_t
float
uint32_t
>
>
mOutputVerificationEvent
;
MediaEventProducer
<
void
>
mErrorForcedEvent
;
nsTArray
<
AudioDataValue
>
mRecordedOutput
;
}
;
class
SmartMockCubebStream
:
public
MockCubebStream
public
SupportsThreadSafeWeakPtr
<
SmartMockCubebStream
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
SmartMockCubebStream
)
SmartMockCubebStream
(
cubeb
*
aContext
cubeb_devid
aInputDevice
cubeb_stream_params
*
aInputStreamParams
cubeb_devid
aOutputDevice
cubeb_stream_params
*
aOutputStreamParams
cubeb_data_callback
aDataCallback
cubeb_state_callback
aStateCallback
void
*
aUserPtr
bool
aFrozenStart
)
:
MockCubebStream
(
aContext
aInputDevice
aInputStreamParams
aOutputDevice
aOutputStreamParams
aDataCallback
aStateCallback
aUserPtr
this
aFrozenStart
)
{
}
}
;
class
MockCubeb
{
public
:
MockCubeb
(
)
;
~
MockCubeb
(
)
;
cubeb
*
AsCubebContext
(
)
;
static
MockCubeb
*
AsMock
(
cubeb
*
aContext
)
;
int
EnumerateDevices
(
cubeb_device_type
aType
cubeb_device_collection
*
aCollection
)
;
int
DestroyDeviceCollection
(
cubeb_device_collection
*
aCollection
)
;
int
RegisterDeviceCollectionChangeCallback
(
cubeb_device_type
aDevType
cubeb_device_collection_changed_callback
aCallback
void
*
aUserPtr
)
;
void
AddDevice
(
cubeb_device_info
aDevice
)
;
bool
RemoveDevice
(
cubeb_devid
aId
)
;
void
ClearDevices
(
cubeb_device_type
aType
)
;
void
SetSupportDeviceChangeCallback
(
bool
aSupports
)
;
void
SetStreamStartFreezeEnabled
(
bool
aEnabled
)
;
class
AudioThreadAutoUnforcer
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AudioThreadAutoUnforcer
)
public
:
explicit
AudioThreadAutoUnforcer
(
MockCubeb
*
aContext
)
:
mContext
(
aContext
)
{
}
protected
:
virtual
~
AudioThreadAutoUnforcer
(
)
{
mContext
-
>
UnforceAudioThread
(
)
;
}
MockCubeb
*
mContext
;
}
;
using
ForcedAudioThreadPromise
=
MozPromise
<
RefPtr
<
AudioThreadAutoUnforcer
>
nsresult
false
>
;
RefPtr
<
ForcedAudioThreadPromise
>
ForceAudioThread
(
)
;
void
UnforceAudioThread
(
)
;
int
StreamInit
(
cubeb
*
aContext
cubeb_stream
*
*
aStream
cubeb_devid
aInputDevice
cubeb_stream_params
*
aInputStreamParams
cubeb_devid
aOutputDevice
cubeb_stream_params
*
aOutputStreamParams
cubeb_data_callback
aDataCallback
cubeb_state_callback
aStateCallback
void
*
aUserPtr
)
;
void
StreamDestroy
(
cubeb_stream
*
aStream
)
;
void
GoFaster
(
)
;
void
DontGoFaster
(
)
;
MediaEventSource
<
RefPtr
<
SmartMockCubebStream
>
>
&
StreamInitEvent
(
)
;
MediaEventSource
<
RefPtr
<
SmartMockCubebStream
>
>
&
StreamDestroyEvent
(
)
;
void
StartStream
(
MockCubebStream
*
aStream
)
;
int
StopStream
(
MockCubebStream
*
aStream
)
;
static
void
ThreadFunction_s
(
MockCubeb
*
aContext
)
{
aContext
-
>
ThreadFunction
(
)
;
}
void
ThreadFunction
(
)
;
private
:
const
cubeb_ops
*
ops
;
cubeb_device_collection_changed_callback
mInputDeviceCollectionChangeCallback
=
nullptr
;
cubeb_device_collection_changed_callback
mOutputDeviceCollectionChangeCallback
=
nullptr
;
void
*
mInputDeviceCollectionChangeUserPtr
=
nullptr
;
void
*
mOutputDeviceCollectionChangeUserPtr
=
nullptr
;
void
*
mUserPtr
=
nullptr
;
bool
mSupportsDeviceCollectionChangedCallback
=
true
;
Atomic
<
bool
>
mStreamStartFreezeEnabled
{
false
}
;
Atomic
<
bool
>
mForcedAudioThread
{
false
}
;
MozPromiseHolder
<
ForcedAudioThreadPromise
>
mForcedAudioThreadPromise
;
nsTArray
<
cubeb_device_info
>
mInputDevices
;
nsTArray
<
cubeb_device_info
>
mOutputDevices
;
DataMutex
<
nsTArray
<
RefPtr
<
SmartMockCubebStream
>
>
>
mLiveStreams
{
"
MockCubeb
:
:
mLiveStreams
"
}
;
UniquePtr
<
std
:
:
thread
>
mFakeAudioThread
;
std
:
:
atomic
<
bool
>
mFastMode
{
false
}
;
MediaEventProducer
<
RefPtr
<
SmartMockCubebStream
>
>
mStreamInitEvent
;
MediaEventProducer
<
RefPtr
<
SmartMockCubebStream
>
>
mStreamDestroyEvent
;
}
;
int
cubeb_mock_enumerate_devices
(
cubeb
*
context
cubeb_device_type
type
cubeb_device_collection
*
out
)
{
return
MockCubeb
:
:
AsMock
(
context
)
-
>
EnumerateDevices
(
type
out
)
;
}
int
cubeb_mock_device_collection_destroy
(
cubeb
*
context
cubeb_device_collection
*
collection
)
{
return
MockCubeb
:
:
AsMock
(
context
)
-
>
DestroyDeviceCollection
(
collection
)
;
}
int
cubeb_mock_register_device_collection_changed
(
cubeb
*
context
cubeb_device_type
devtype
cubeb_device_collection_changed_callback
callback
void
*
user_ptr
)
{
return
MockCubeb
:
:
AsMock
(
context
)
-
>
RegisterDeviceCollectionChangeCallback
(
devtype
callback
user_ptr
)
;
}
int
cubeb_mock_stream_init
(
cubeb
*
context
cubeb_stream
*
*
stream
char
const
*
stream_name
cubeb_devid
input_device
cubeb_stream_params
*
input_stream_params
cubeb_devid
output_device
cubeb_stream_params
*
output_stream_params
unsigned
int
latency
cubeb_data_callback
data_callback
cubeb_state_callback
state_callback
void
*
user_ptr
)
{
return
MockCubeb
:
:
AsMock
(
context
)
-
>
StreamInit
(
context
stream
input_device
input_stream_params
output_device
output_stream_params
data_callback
state_callback
user_ptr
)
;
}
int
cubeb_mock_stream_start
(
cubeb_stream
*
stream
)
{
return
MockCubebStream
:
:
AsMock
(
stream
)
-
>
Start
(
)
;
}
int
cubeb_mock_stream_stop
(
cubeb_stream
*
stream
)
{
return
MockCubebStream
:
:
AsMock
(
stream
)
-
>
Stop
(
)
;
}
void
cubeb_mock_stream_destroy
(
cubeb_stream
*
stream
)
{
MockCubebStream
*
mockStream
=
MockCubebStream
:
:
AsMock
(
stream
)
;
MockCubeb
*
mock
=
MockCubeb
:
:
AsMock
(
mockStream
-
>
context
)
;
return
mock
-
>
StreamDestroy
(
stream
)
;
}
static
char
const
*
cubeb_mock_get_backend_id
(
cubeb
*
context
)
{
#
if
defined
(
XP_MACOSX
)
return
"
audiounit
"
;
#
elif
defined
(
XP_WIN
)
return
"
wasapi
"
;
#
elif
defined
(
ANDROID
)
return
"
opensl
"
;
#
elif
defined
(
__OpenBSD__
)
return
"
sndio
"
;
#
else
return
"
pulse
"
;
#
endif
}
static
int
cubeb_mock_stream_set_volume
(
cubeb_stream
*
stream
float
volume
)
{
return
CUBEB_OK
;
}
static
int
cubeb_mock_stream_set_name
(
cubeb_stream
*
stream
char
const
*
stream_name
)
{
return
CUBEB_OK
;
}
int
cubeb_mock_get_min_latency
(
cubeb
*
context
cubeb_stream_params
params
uint32_t
*
latency_ms
)
{
*
latency_ms
=
10
;
return
CUBEB_OK
;
}
int
cubeb_mock_get_max_channel_count
(
cubeb
*
context
uint32_t
*
max_channels
)
{
*
max_channels
=
MAX_OUTPUT_CHANNELS
;
return
CUBEB_OK
;
}
void
PrintDevice
(
cubeb_device_info
aInfo
)
;
void
PrintDevice
(
AudioDeviceInfo
*
aInfo
)
;
cubeb_device_info
DeviceTemplate
(
cubeb_devid
aId
cubeb_device_type
aType
const
char
*
name
)
;
cubeb_device_info
DeviceTemplate
(
cubeb_devid
aId
cubeb_device_type
aType
)
;
void
AddDevices
(
MockCubeb
*
mock
uint32_t
device_count
cubeb_device_type
deviceType
)
;
}
#
endif
