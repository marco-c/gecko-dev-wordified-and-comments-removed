#
ifndef
MOCKCUBEB_H_
#
define
MOCKCUBEB_H_
#
include
"
AudioDeviceInfo
.
h
"
#
include
"
AudioGenerator
.
h
"
#
include
"
AudioVerifier
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
ThreadSafeWeakPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
<
thread
>
#
include
<
atomic
>
#
include
<
chrono
>
namespace
mozilla
{
const
uint32_t
NUM_OF_CHANNELS
=
2
;
struct
cubeb_ops
{
int
(
*
init
)
(
cubeb
*
*
context
char
const
*
context_name
)
;
char
const
*
(
*
get_backend_id
)
(
cubeb
*
context
)
;
int
(
*
get_max_channel_count
)
(
cubeb
*
context
uint32_t
*
max_channels
)
;
int
(
*
get_min_latency
)
(
cubeb
*
context
cubeb_stream_params
params
uint32_t
*
latency_ms
)
;
int
(
*
get_preferred_sample_rate
)
(
cubeb
*
context
uint32_t
*
rate
)
;
int
(
*
enumerate_devices
)
(
cubeb
*
context
cubeb_device_type
type
cubeb_device_collection
*
collection
)
;
int
(
*
device_collection_destroy
)
(
cubeb
*
context
cubeb_device_collection
*
collection
)
;
void
(
*
destroy
)
(
cubeb
*
context
)
;
int
(
*
stream_init
)
(
cubeb
*
context
cubeb_stream
*
*
stream
char
const
*
stream_name
cubeb_devid
input_device
cubeb_stream_params
*
input_stream_params
cubeb_devid
output_device
cubeb_stream_params
*
output_stream_params
unsigned
int
latency
cubeb_data_callback
data_callback
cubeb_state_callback
state_callback
void
*
user_ptr
)
;
void
(
*
stream_destroy
)
(
cubeb_stream
*
stream
)
;
int
(
*
stream_start
)
(
cubeb_stream
*
stream
)
;
int
(
*
stream_stop
)
(
cubeb_stream
*
stream
)
;
int
(
*
stream_get_position
)
(
cubeb_stream
*
stream
uint64_t
*
position
)
;
int
(
*
stream_get_latency
)
(
cubeb_stream
*
stream
uint32_t
*
latency
)
;
int
(
*
stream_get_input_latency
)
(
cubeb_stream
*
stream
uint32_t
*
latency
)
;
int
(
*
stream_set_volume
)
(
cubeb_stream
*
stream
float
volumes
)
;
int
(
*
stream_set_name
)
(
cubeb_stream
*
stream
char
const
*
stream_name
)
;
int
(
*
stream_get_current_device
)
(
cubeb_stream
*
stream
cubeb_device
*
*
const
device
)
;
int
(
*
stream_device_destroy
)
(
cubeb_stream
*
stream
cubeb_device
*
device
)
;
int
(
*
stream_register_device_changed_callback
)
(
cubeb_stream
*
stream
cubeb_device_changed_callback
device_changed_callback
)
;
int
(
*
register_device_collection_changed
)
(
cubeb
*
context
cubeb_device_type
devtype
cubeb_device_collection_changed_callback
callback
void
*
user_ptr
)
;
}
;
void
cubeb_mock_destroy
(
cubeb
*
context
)
;
static
int
cubeb_mock_enumerate_devices
(
cubeb
*
context
cubeb_device_type
type
cubeb_device_collection
*
out
)
;
static
int
cubeb_mock_device_collection_destroy
(
cubeb
*
context
cubeb_device_collection
*
collection
)
;
static
int
cubeb_mock_register_device_collection_changed
(
cubeb
*
context
cubeb_device_type
devtype
cubeb_device_collection_changed_callback
callback
void
*
user_ptr
)
;
static
int
cubeb_mock_stream_init
(
cubeb
*
context
cubeb_stream
*
*
stream
char
const
*
stream_name
cubeb_devid
input_device
cubeb_stream_params
*
input_stream_params
cubeb_devid
output_device
cubeb_stream_params
*
output_stream_params
unsigned
int
latency
cubeb_data_callback
data_callback
cubeb_state_callback
state_callback
void
*
user_ptr
)
;
static
int
cubeb_mock_stream_start
(
cubeb_stream
*
stream
)
;
static
int
cubeb_mock_stream_stop
(
cubeb_stream
*
stream
)
;
static
void
cubeb_mock_stream_destroy
(
cubeb_stream
*
stream
)
;
static
char
const
*
cubeb_mock_get_backend_id
(
cubeb
*
context
)
;
static
int
cubeb_mock_stream_set_volume
(
cubeb_stream
*
stream
float
volume
)
;
static
int
cubeb_mock_get_min_latency
(
cubeb
*
context
cubeb_stream_params
params
uint32_t
*
latency_ms
)
;
static
int
cubeb_mock_get_max_channel_count
(
cubeb
*
context
uint32_t
*
max_channels
)
;
cubeb_ops
const
mock_ops
=
{
NULL
cubeb_mock_get_backend_id
cubeb_mock_get_max_channel_count
cubeb_mock_get_min_latency
NULL
cubeb_mock_enumerate_devices
cubeb_mock_device_collection_destroy
cubeb_mock_destroy
cubeb_mock_stream_init
cubeb_mock_stream_destroy
cubeb_mock_stream_start
cubeb_mock_stream_stop
NULL
NULL
NULL
cubeb_mock_stream_set_volume
NULL
NULL
NULL
NULL
cubeb_mock_register_device_collection_changed
}
;
class
SmartMockCubebStream
;
class
MockCubebStream
{
public
:
MockCubebStream
(
cubeb
*
aContext
cubeb_devid
aInputDevice
cubeb_stream_params
*
aInputStreamParams
cubeb_devid
aOutputDevice
cubeb_stream_params
*
aOutputStreamParams
cubeb_data_callback
aDataCallback
cubeb_state_callback
aStateCallback
void
*
aUserPtr
SmartMockCubebStream
*
aSelf
bool
aFrozenStart
)
;
~
MockCubebStream
(
)
;
int
Start
(
)
;
int
Stop
(
)
;
cubeb_stream
*
AsCubebStream
(
)
;
static
MockCubebStream
*
AsMock
(
cubeb_stream
*
aStream
)
;
cubeb_devid
GetInputDeviceID
(
)
const
;
cubeb_devid
GetOutputDeviceID
(
)
const
;
uint32_t
InputChannels
(
)
const
;
uint32_t
OutputChannels
(
)
const
;
uint32_t
InputSampleRate
(
)
const
;
uint32_t
InputFrequency
(
)
const
;
void
SetDriftFactor
(
float
aDriftFactor
)
;
void
ForceError
(
)
;
void
Thaw
(
)
;
void
SetOutputRecordingEnabled
(
bool
aEnabled
)
;
nsTArray
<
AudioDataValue
>
&
&
TakeRecordedOutput
(
)
;
MediaEventSource
<
uint32_t
>
&
FramesProcessedEvent
(
)
;
MediaEventSource
<
uint32_t
>
&
FramesVerifiedEvent
(
)
;
MediaEventSource
<
Tuple
<
uint64_t
float
uint32_t
>
>
&
OutputVerificationEvent
(
)
;
MediaEventSource
<
void
>
&
ErrorForcedEvent
(
)
;
void
Process10Ms
(
)
;
public
:
cubeb
*
context
=
nullptr
;
const
bool
mHasInput
;
const
bool
mHasOutput
;
SmartMockCubebStream
*
const
mSelf
;
private
:
Monitor
mFrozenStartMonitor
;
bool
mFrozenStart
;
std
:
:
atomic_bool
mStreamStop
{
true
}
;
std
:
:
atomic_bool
mOutputRecordingEnabled
{
false
}
;
AudioDataValue
mOutputBuffer
[
NUM_OF_CHANNELS
*
1920
]
=
{
}
;
AudioDataValue
mInputBuffer
[
NUM_OF_CHANNELS
*
1920
]
=
{
}
;
cubeb_data_callback
mDataCallback
=
nullptr
;
cubeb_state_callback
mStateCallback
=
nullptr
;
void
*
mUserPtr
=
nullptr
;
cubeb_stream_params
mOutputParams
=
{
}
;
cubeb_stream_params
mInputParams
=
{
}
;
cubeb_devid
mInputDeviceID
;
cubeb_devid
mOutputDeviceID
;
std
:
:
atomic
<
float
>
mDriftFactor
{
1
.
0
}
;
std
:
:
atomic_bool
mFastMode
{
false
}
;
std
:
:
atomic_bool
mForceErrorState
{
false
}
;
AudioGenerator
<
AudioDataValue
>
mAudioGenerator
;
AudioVerifier
<
AudioDataValue
>
mAudioVerifier
;
MediaEventProducer
<
uint32_t
>
mFramesProcessedEvent
;
MediaEventProducer
<
uint32_t
>
mFramesVerifiedEvent
;
MediaEventProducer
<
Tuple
<
uint64_t
float
uint32_t
>
>
mOutputVerificationEvent
;
MediaEventProducer
<
void
>
mErrorForcedEvent
;
nsTArray
<
AudioDataValue
>
mRecordedOutput
;
}
;
class
SmartMockCubebStream
:
public
MockCubebStream
public
SupportsThreadSafeWeakPtr
<
SmartMockCubebStream
>
{
public
:
MOZ_DECLARE_THREADSAFEWEAKREFERENCE_TYPENAME
(
SmartMockCubebStream
)
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
SmartMockCubebStream
)
SmartMockCubebStream
(
cubeb
*
aContext
cubeb_devid
aInputDevice
cubeb_stream_params
*
aInputStreamParams
cubeb_devid
aOutputDevice
cubeb_stream_params
*
aOutputStreamParams
cubeb_data_callback
aDataCallback
cubeb_state_callback
aStateCallback
void
*
aUserPtr
bool
aFrozenStart
)
:
MockCubebStream
(
aContext
aInputDevice
aInputStreamParams
aOutputDevice
aOutputStreamParams
aDataCallback
aStateCallback
aUserPtr
this
aFrozenStart
)
{
}
}
;
class
MockCubeb
{
public
:
MockCubeb
(
)
;
~
MockCubeb
(
)
;
cubeb
*
AsCubebContext
(
)
;
static
MockCubeb
*
AsMock
(
cubeb
*
aContext
)
;
int
EnumerateDevices
(
cubeb_device_type
aType
cubeb_device_collection
*
collection
)
;
int
RegisterDeviceCollectionChangeCallback
(
cubeb_device_type
aDevType
cubeb_device_collection_changed_callback
aCallback
void
*
aUserPtr
)
;
void
AddDevice
(
cubeb_device_info
aDevice
)
;
bool
RemoveDevice
(
cubeb_devid
aId
)
;
void
ClearDevices
(
cubeb_device_type
aType
)
;
void
SetSupportDeviceChangeCallback
(
bool
aSupports
)
;
void
SetStreamStartFreezeEnabled
(
bool
aEnabled
)
;
class
AudioThreadAutoUnforcer
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
AudioThreadAutoUnforcer
)
public
:
explicit
AudioThreadAutoUnforcer
(
MockCubeb
*
aContext
)
:
mContext
(
aContext
)
{
}
protected
:
virtual
~
AudioThreadAutoUnforcer
(
)
{
mContext
-
>
UnforceAudioThread
(
)
;
}
MockCubeb
*
mContext
;
}
;
using
ForcedAudioThreadPromise
=
MozPromise
<
RefPtr
<
AudioThreadAutoUnforcer
>
nsresult
false
>
;
RefPtr
<
ForcedAudioThreadPromise
>
ForceAudioThread
(
)
;
void
UnforceAudioThread
(
)
;
int
StreamInit
(
cubeb
*
aContext
cubeb_stream
*
*
aStream
cubeb_devid
aInputDevice
cubeb_stream_params
*
aInputStreamParams
cubeb_devid
aOutputDevice
cubeb_stream_params
*
aOutputStreamParams
cubeb_data_callback
aDataCallback
cubeb_state_callback
aStateCallback
void
*
aUserPtr
)
;
void
StreamDestroy
(
cubeb_stream
*
aStream
)
;
void
GoFaster
(
)
;
void
DontGoFaster
(
)
;
MediaEventSource
<
RefPtr
<
SmartMockCubebStream
>
>
&
StreamInitEvent
(
)
;
MediaEventSource
<
void
>
&
StreamDestroyEvent
(
)
;
void
StartStream
(
MockCubebStream
*
aStream
)
;
int
StopStream
(
MockCubebStream
*
aStream
)
;
static
void
ThreadFunction_s
(
MockCubeb
*
aContext
)
{
aContext
-
>
ThreadFunction
(
)
;
}
void
ThreadFunction
(
)
;
private
:
const
cubeb_ops
*
ops
;
cubeb_device_collection_changed_callback
mInputDeviceCollectionChangeCallback
=
nullptr
;
cubeb_device_collection_changed_callback
mOutputDeviceCollectionChangeCallback
=
nullptr
;
void
*
mInputDeviceCollectionChangeUserPtr
=
nullptr
;
void
*
mOutputDeviceCollectionChangeUserPtr
=
nullptr
;
void
*
mUserPtr
=
nullptr
;
bool
mSupportsDeviceCollectionChangedCallback
=
true
;
Atomic
<
bool
>
mStreamStartFreezeEnabled
{
false
}
;
Atomic
<
bool
>
mForcedAudioThread
{
false
}
;
MozPromiseHolder
<
ForcedAudioThreadPromise
>
mForcedAudioThreadPromise
;
nsTArray
<
cubeb_device_info
>
mInputDevices
;
nsTArray
<
cubeb_device_info
>
mOutputDevices
;
DataMutex
<
nsTArray
<
RefPtr
<
SmartMockCubebStream
>
>
>
mLiveStreams
{
"
MockCubeb
:
:
mLiveStreams
"
}
;
UniquePtr
<
std
:
:
thread
>
mFakeAudioThread
;
std
:
:
atomic
<
bool
>
mFastMode
{
false
}
;
MediaEventProducer
<
RefPtr
<
SmartMockCubebStream
>
>
mStreamInitEvent
;
MediaEventProducer
<
void
>
mStreamDestroyEvent
;
}
;
void
cubeb_mock_destroy
(
cubeb
*
context
)
{
delete
MockCubeb
:
:
AsMock
(
context
)
;
}
int
cubeb_mock_enumerate_devices
(
cubeb
*
context
cubeb_device_type
type
cubeb_device_collection
*
out
)
{
return
MockCubeb
:
:
AsMock
(
context
)
-
>
EnumerateDevices
(
type
out
)
;
}
int
cubeb_mock_device_collection_destroy
(
cubeb
*
context
cubeb_device_collection
*
collection
)
{
delete
[
]
collection
-
>
device
;
return
CUBEB_OK
;
}
int
cubeb_mock_register_device_collection_changed
(
cubeb
*
context
cubeb_device_type
devtype
cubeb_device_collection_changed_callback
callback
void
*
user_ptr
)
{
return
MockCubeb
:
:
AsMock
(
context
)
-
>
RegisterDeviceCollectionChangeCallback
(
devtype
callback
user_ptr
)
;
}
int
cubeb_mock_stream_init
(
cubeb
*
context
cubeb_stream
*
*
stream
char
const
*
stream_name
cubeb_devid
input_device
cubeb_stream_params
*
input_stream_params
cubeb_devid
output_device
cubeb_stream_params
*
output_stream_params
unsigned
int
latency
cubeb_data_callback
data_callback
cubeb_state_callback
state_callback
void
*
user_ptr
)
{
return
MockCubeb
:
:
AsMock
(
context
)
-
>
StreamInit
(
context
stream
input_device
input_stream_params
output_device
output_stream_params
data_callback
state_callback
user_ptr
)
;
}
int
cubeb_mock_stream_start
(
cubeb_stream
*
stream
)
{
return
MockCubebStream
:
:
AsMock
(
stream
)
-
>
Start
(
)
;
}
int
cubeb_mock_stream_stop
(
cubeb_stream
*
stream
)
{
return
MockCubebStream
:
:
AsMock
(
stream
)
-
>
Stop
(
)
;
}
void
cubeb_mock_stream_destroy
(
cubeb_stream
*
stream
)
{
MockCubebStream
*
mockStream
=
MockCubebStream
:
:
AsMock
(
stream
)
;
MockCubeb
*
mock
=
MockCubeb
:
:
AsMock
(
mockStream
-
>
context
)
;
return
mock
-
>
StreamDestroy
(
stream
)
;
}
static
char
const
*
cubeb_mock_get_backend_id
(
cubeb
*
context
)
{
#
if
defined
(
XP_MACOSX
)
return
"
audiounit
"
;
#
elif
defined
(
XP_WIN
)
return
"
wasapi
"
;
#
elif
defined
(
ANDROID
)
return
"
opensl
"
;
#
elif
defined
(
__OpenBSD__
)
return
"
sndio
"
;
#
else
return
"
pulse
"
;
#
endif
}
static
int
cubeb_mock_stream_set_volume
(
cubeb_stream
*
stream
float
volume
)
{
return
CUBEB_OK
;
}
int
cubeb_mock_get_min_latency
(
cubeb
*
context
cubeb_stream_params
params
uint32_t
*
latency_ms
)
{
*
latency_ms
=
10
;
return
CUBEB_OK
;
}
int
cubeb_mock_get_max_channel_count
(
cubeb
*
context
uint32_t
*
max_channels
)
{
*
max_channels
=
NUM_OF_CHANNELS
;
return
CUBEB_OK
;
}
void
PrintDevice
(
cubeb_device_info
aInfo
)
{
printf
(
"
id
:
%
zu
\
n
"
"
device_id
:
%
s
\
n
"
"
friendly_name
:
%
s
\
n
"
"
group_id
:
%
s
\
n
"
"
vendor_name
:
%
s
\
n
"
"
type
:
%
d
\
n
"
"
state
:
%
d
\
n
"
"
preferred
:
%
d
\
n
"
"
format
:
%
d
\
n
"
"
default_format
:
%
d
\
n
"
"
max_channels
:
%
d
\
n
"
"
default_rate
:
%
d
\
n
"
"
max_rate
:
%
d
\
n
"
"
min_rate
:
%
d
\
n
"
"
latency_lo
:
%
d
\
n
"
"
latency_hi
:
%
d
\
n
"
reinterpret_cast
<
uintptr_t
>
(
aInfo
.
devid
)
aInfo
.
device_id
aInfo
.
friendly_name
aInfo
.
group_id
aInfo
.
vendor_name
aInfo
.
type
aInfo
.
state
aInfo
.
preferred
aInfo
.
format
aInfo
.
default_format
aInfo
.
max_channels
aInfo
.
default_rate
aInfo
.
max_rate
aInfo
.
min_rate
aInfo
.
latency_lo
aInfo
.
latency_hi
)
;
}
void
PrintDevice
(
AudioDeviceInfo
*
aInfo
)
{
cubeb_devid
id
;
nsString
name
;
nsString
groupid
;
nsString
vendor
;
uint16_t
type
;
uint16_t
state
;
uint16_t
preferred
;
uint16_t
supportedFormat
;
uint16_t
defaultFormat
;
uint32_t
maxChannels
;
uint32_t
defaultRate
;
uint32_t
maxRate
;
uint32_t
minRate
;
uint32_t
maxLatency
;
uint32_t
minLatency
;
id
=
aInfo
-
>
DeviceID
(
)
;
aInfo
-
>
GetName
(
name
)
;
aInfo
-
>
GetGroupId
(
groupid
)
;
aInfo
-
>
GetVendor
(
vendor
)
;
aInfo
-
>
GetType
(
&
type
)
;
aInfo
-
>
GetState
(
&
state
)
;
aInfo
-
>
GetPreferred
(
&
preferred
)
;
aInfo
-
>
GetSupportedFormat
(
&
supportedFormat
)
;
aInfo
-
>
GetDefaultFormat
(
&
defaultFormat
)
;
aInfo
-
>
GetMaxChannels
(
&
maxChannels
)
;
aInfo
-
>
GetDefaultRate
(
&
defaultRate
)
;
aInfo
-
>
GetMaxRate
(
&
maxRate
)
;
aInfo
-
>
GetMinRate
(
&
minRate
)
;
aInfo
-
>
GetMinLatency
(
&
minLatency
)
;
aInfo
-
>
GetMaxLatency
(
&
maxLatency
)
;
printf
(
"
device
id
:
%
zu
\
n
"
"
friendly_name
:
%
s
\
n
"
"
group_id
:
%
s
\
n
"
"
vendor_name
:
%
s
\
n
"
"
type
:
%
d
\
n
"
"
state
:
%
d
\
n
"
"
preferred
:
%
d
\
n
"
"
format
:
%
d
\
n
"
"
default_format
:
%
d
\
n
"
"
max_channels
:
%
d
\
n
"
"
default_rate
:
%
d
\
n
"
"
max_rate
:
%
d
\
n
"
"
min_rate
:
%
d
\
n
"
"
latency_lo
:
%
d
\
n
"
"
latency_hi
:
%
d
\
n
"
reinterpret_cast
<
uintptr_t
>
(
id
)
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
NS_LossyConvertUTF16toASCII
(
groupid
)
.
get
(
)
NS_LossyConvertUTF16toASCII
(
vendor
)
.
get
(
)
type
state
preferred
supportedFormat
defaultFormat
maxChannels
defaultRate
maxRate
minRate
minLatency
maxLatency
)
;
}
cubeb_device_info
DeviceTemplate
(
cubeb_devid
aId
cubeb_device_type
aType
const
char
*
name
)
{
cubeb_device_info
device
;
device
.
devid
=
aId
;
device
.
device_id
=
"
nice
name
"
;
device
.
friendly_name
=
name
;
device
.
group_id
=
"
the
physical
device
"
;
device
.
vendor_name
=
"
mozilla
"
;
device
.
type
=
aType
;
device
.
state
=
CUBEB_DEVICE_STATE_ENABLED
;
device
.
preferred
=
CUBEB_DEVICE_PREF_NONE
;
device
.
format
=
CUBEB_DEVICE_FMT_F32NE
;
device
.
default_format
=
CUBEB_DEVICE_FMT_F32NE
;
device
.
max_channels
=
2
;
device
.
default_rate
=
44100
;
device
.
max_rate
=
44100
;
device
.
min_rate
=
16000
;
device
.
latency_lo
=
256
;
device
.
latency_hi
=
1024
;
return
device
;
}
cubeb_device_info
DeviceTemplate
(
cubeb_devid
aId
cubeb_device_type
aType
)
{
return
DeviceTemplate
(
aId
aType
"
nice
name
"
)
;
}
void
AddDevices
(
MockCubeb
*
mock
uint32_t
device_count
cubeb_device_type
deviceType
)
{
mock
-
>
ClearDevices
(
deviceType
)
;
for
(
uintptr_t
i
=
0
;
i
<
device_count
;
i
+
+
)
{
cubeb_device_info
device
=
DeviceTemplate
(
reinterpret_cast
<
void
*
>
(
i
+
1
)
deviceType
)
;
if
(
i
=
=
device_count
-
1
)
{
device
.
preferred
=
CUBEB_DEVICE_PREF_ALL
;
}
mock
-
>
AddDevice
(
device
)
;
}
}
}
#
endif
