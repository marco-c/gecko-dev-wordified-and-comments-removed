#
include
<
algorithm
>
#
include
"
DriftCompensation
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
MediaStreamGraph
.
h
"
#
include
"
MediaStreamListener
.
h
"
#
include
"
VP8TrackEncoder
.
h
"
#
include
"
WebMWriter
.
h
"
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
prtime
.
h
"
#
define
VIDEO_TRACK_RATE
90000
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
Invoke
;
using
:
:
testing
:
:
NiceMock
;
using
:
:
testing
:
:
TestWithParam
;
using
:
:
testing
:
:
Values
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
;
class
YUVBufferGenerator
{
public
:
YUVBufferGenerator
(
)
{
}
void
Init
(
const
mozilla
:
:
gfx
:
:
IntSize
&
aSize
)
{
mImageSize
=
aSize
;
int
yPlaneLen
=
aSize
.
width
*
aSize
.
height
;
int
cbcrPlaneLen
=
(
yPlaneLen
+
1
)
/
2
;
int
frameLen
=
yPlaneLen
+
cbcrPlaneLen
;
mSourceBuffer
.
SetLength
(
frameLen
)
;
memset
(
mSourceBuffer
.
Elements
(
)
0x10
yPlaneLen
)
;
memset
(
mSourceBuffer
.
Elements
(
)
+
yPlaneLen
0x80
cbcrPlaneLen
)
;
}
mozilla
:
:
gfx
:
:
IntSize
GetSize
(
)
const
{
return
mImageSize
;
}
already_AddRefed
<
Image
>
GenerateI420Image
(
)
{
return
do_AddRef
(
CreateI420Image
(
)
)
;
}
already_AddRefed
<
Image
>
GenerateNV12Image
(
)
{
return
do_AddRef
(
CreateNV12Image
(
)
)
;
}
already_AddRefed
<
Image
>
GenerateNV21Image
(
)
{
return
do_AddRef
(
CreateNV21Image
(
)
)
;
}
private
:
Image
*
CreateI420Image
(
)
{
PlanarYCbCrImage
*
image
=
new
RecyclingPlanarYCbCrImage
(
new
BufferRecycleBin
(
)
)
;
PlanarYCbCrData
data
;
data
.
mPicSize
=
mImageSize
;
const
uint32_t
yPlaneSize
=
mImageSize
.
width
*
mImageSize
.
height
;
const
uint32_t
halfWidth
=
(
mImageSize
.
width
+
1
)
/
2
;
const
uint32_t
halfHeight
=
(
mImageSize
.
height
+
1
)
/
2
;
const
uint32_t
uvPlaneSize
=
halfWidth
*
halfHeight
;
uint8_t
*
y
=
mSourceBuffer
.
Elements
(
)
;
data
.
mYChannel
=
y
;
data
.
mYSize
.
width
=
mImageSize
.
width
;
data
.
mYSize
.
height
=
mImageSize
.
height
;
data
.
mYStride
=
mImageSize
.
width
;
data
.
mYSkip
=
0
;
uint8_t
*
cr
=
y
+
yPlaneSize
+
uvPlaneSize
;
data
.
mCrChannel
=
cr
;
data
.
mCrSkip
=
0
;
uint8_t
*
cb
=
y
+
yPlaneSize
;
data
.
mCbChannel
=
cb
;
data
.
mCbSkip
=
0
;
data
.
mCbCrStride
=
halfWidth
;
data
.
mCbCrSize
.
width
=
halfWidth
;
data
.
mCbCrSize
.
height
=
halfHeight
;
image
-
>
CopyData
(
data
)
;
return
image
;
}
Image
*
CreateNV12Image
(
)
{
NVImage
*
image
=
new
NVImage
(
)
;
PlanarYCbCrData
data
;
data
.
mPicSize
=
mImageSize
;
const
uint32_t
yPlaneSize
=
mImageSize
.
width
*
mImageSize
.
height
;
const
uint32_t
halfWidth
=
(
mImageSize
.
width
+
1
)
/
2
;
const
uint32_t
halfHeight
=
(
mImageSize
.
height
+
1
)
/
2
;
uint8_t
*
y
=
mSourceBuffer
.
Elements
(
)
;
data
.
mYChannel
=
y
;
data
.
mYSize
.
width
=
mImageSize
.
width
;
data
.
mYSize
.
height
=
mImageSize
.
height
;
data
.
mYStride
=
mImageSize
.
width
;
data
.
mYSkip
=
0
;
uint8_t
*
cr
=
y
+
yPlaneSize
;
data
.
mCrChannel
=
cr
;
data
.
mCrSkip
=
1
;
uint8_t
*
cb
=
y
+
yPlaneSize
+
1
;
data
.
mCbChannel
=
cb
;
data
.
mCbSkip
=
1
;
data
.
mCbCrStride
=
mImageSize
.
width
;
data
.
mCbCrSize
.
width
=
halfWidth
;
data
.
mCbCrSize
.
height
=
halfHeight
;
image
-
>
SetData
(
data
)
;
return
image
;
}
Image
*
CreateNV21Image
(
)
{
NVImage
*
image
=
new
NVImage
(
)
;
PlanarYCbCrData
data
;
data
.
mPicSize
=
mImageSize
;
const
uint32_t
yPlaneSize
=
mImageSize
.
width
*
mImageSize
.
height
;
const
uint32_t
halfWidth
=
(
mImageSize
.
width
+
1
)
/
2
;
const
uint32_t
halfHeight
=
(
mImageSize
.
height
+
1
)
/
2
;
uint8_t
*
y
=
mSourceBuffer
.
Elements
(
)
;
data
.
mYChannel
=
y
;
data
.
mYSize
.
width
=
mImageSize
.
width
;
data
.
mYSize
.
height
=
mImageSize
.
height
;
data
.
mYStride
=
mImageSize
.
width
;
data
.
mYSkip
=
0
;
uint8_t
*
cr
=
y
+
yPlaneSize
+
1
;
data
.
mCrChannel
=
cr
;
data
.
mCrSkip
=
1
;
uint8_t
*
cb
=
y
+
yPlaneSize
;
data
.
mCbChannel
=
cb
;
data
.
mCbSkip
=
1
;
data
.
mCbCrStride
=
mImageSize
.
width
;
data
.
mCbCrSize
.
width
=
halfWidth
;
data
.
mCbCrSize
.
height
=
halfHeight
;
image
-
>
SetData
(
data
)
;
return
image
;
}
private
:
mozilla
:
:
gfx
:
:
IntSize
mImageSize
;
nsTArray
<
uint8_t
>
mSourceBuffer
;
}
;
struct
InitParam
{
bool
mShouldSucceed
;
int
mWidth
;
int
mHeight
;
}
;
class
MockDriftCompensator
:
public
DriftCompensator
{
public
:
MockDriftCompensator
(
)
:
DriftCompensator
(
GetCurrentThreadEventTarget
(
)
VIDEO_TRACK_RATE
)
{
ON_CALL
(
*
this
GetVideoTime
(
_
_
)
)
.
WillByDefault
(
Invoke
(
[
]
(
TimeStamp
TimeStamp
t
)
{
return
t
;
}
)
)
;
}
MOCK_METHOD2
(
GetVideoTime
TimeStamp
(
TimeStamp
TimeStamp
)
)
;
}
;
class
TestVP8TrackEncoder
:
public
VP8TrackEncoder
{
public
:
explicit
TestVP8TrackEncoder
(
TrackRate
aTrackRate
=
VIDEO_TRACK_RATE
)
:
VP8TrackEncoder
(
MakeRefPtr
<
NiceMock
<
MockDriftCompensator
>
>
(
)
aTrackRate
FrameDroppingMode
:
:
DISALLOW
)
{
}
MockDriftCompensator
*
DriftCompensator
(
)
{
return
static_cast
<
MockDriftCompensator
*
>
(
mDriftCompensator
.
get
(
)
)
;
}
:
:
testing
:
:
AssertionResult
TestInit
(
const
InitParam
&
aParam
)
{
nsresult
result
=
Init
(
aParam
.
mWidth
aParam
.
mHeight
aParam
.
mWidth
aParam
.
mHeight
)
;
if
(
(
(
NS_FAILED
(
result
)
&
&
aParam
.
mShouldSucceed
)
)
|
|
(
NS_SUCCEEDED
(
result
)
&
&
!
aParam
.
mShouldSucceed
)
)
{
return
:
:
testing
:
:
AssertionFailure
(
)
<
<
"
width
=
"
<
<
aParam
.
mWidth
<
<
"
height
=
"
<
<
aParam
.
mHeight
;
}
else
{
return
:
:
testing
:
:
AssertionSuccess
(
)
;
}
}
}
;
TEST
(
VP8VideoTrackEncoder
Initialization
)
{
InitParam
params
[
]
=
{
{
false
0
0
}
{
false
0
1
}
{
false
1
0
}
{
true
640
480
}
{
true
800
480
}
{
true
960
540
}
{
true
1280
720
}
}
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
params
)
;
i
+
+
)
{
TestVP8TrackEncoder
encoder
;
EXPECT_TRUE
(
encoder
.
TestInit
(
params
[
i
]
)
)
;
}
}
TEST
(
VP8VideoTrackEncoder
FetchMetaData
)
{
InitParam
params
[
]
=
{
{
true
640
480
}
{
true
800
480
}
{
true
960
540
}
{
true
1280
720
}
}
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
params
)
;
i
+
+
)
{
TestVP8TrackEncoder
encoder
;
EXPECT_TRUE
(
encoder
.
TestInit
(
params
[
i
]
)
)
;
RefPtr
<
TrackMetadataBase
>
meta
=
encoder
.
GetMetadata
(
)
;
RefPtr
<
VP8Metadata
>
vp8Meta
(
static_cast
<
VP8Metadata
*
>
(
meta
.
get
(
)
)
)
;
EXPECT_TRUE
(
vp8Meta
-
>
mWidth
=
=
params
[
i
]
.
mWidth
)
;
EXPECT_TRUE
(
vp8Meta
-
>
mHeight
=
=
params
[
i
]
.
mHeight
)
;
}
}
TEST
(
VP8VideoTrackEncoder
FrameEncode
)
{
TestVP8TrackEncoder
encoder
;
nsTArray
<
RefPtr
<
Image
>
>
images
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
images
.
AppendElement
(
generator
.
GenerateI420Image
(
)
)
;
images
.
AppendElement
(
generator
.
GenerateNV12Image
(
)
)
;
images
.
AppendElement
(
generator
.
GenerateNV21Image
(
)
)
;
VideoSegment
segment
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
for
(
nsTArray
<
RefPtr
<
Image
>
>
:
:
size_type
i
=
0
;
i
<
images
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
Image
>
image
=
images
[
i
]
;
segment
.
AppendFrame
(
image
.
forget
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
i
)
)
;
}
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
images
.
Length
(
)
)
)
;
EncodedFrameContainer
container
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
}
TEST
(
VP8VideoTrackEncoder
SingleFrameEncode
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
VideoSegment
segment
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
nsTArray
<
RefPtr
<
EncodedFrame
>
>
&
frames
=
container
.
GetEncodedFrames
(
)
;
const
size_t
oneElement
=
1
;
ASSERT_EQ
(
oneElement
frames
.
Length
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
0
]
-
>
GetFrameType
(
)
)
<
<
"
We
only
have
one
frame
so
it
should
be
a
keyframe
"
;
const
uint64_t
halfSecond
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
halfSecond
frames
[
0
]
-
>
GetDuration
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
SameFrameEncode
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
RefPtr
<
Image
>
image
=
generator
.
GenerateI420Image
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
15
;
+
+
i
)
{
segment
.
AppendFrame
(
do_AddRef
(
image
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
i
*
0
.
1
)
)
;
}
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
oneAndAHalf
=
(
PR_USEC_PER_SEC
/
2
)
*
3
;
EXPECT_EQ
(
oneAndAHalf
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
SkippedFrames
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
100
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
i
)
)
;
}
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
hundredMillis
=
PR_USEC_PER_SEC
/
10
;
EXPECT_EQ
(
hundredMillis
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
RoundingErrorFramesEncode
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
uint32_t
usPerFrame
=
99999
;
for
(
uint32_t
i
=
0
;
i
<
9
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMicroseconds
(
i
*
usPerFrame
)
)
;
}
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
9
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
oneSecond
=
PR_USEC_PER_SEC
;
EXPECT_EQ
(
oneSecond
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
TimestampFrameEncode
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
05
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
3
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
expectedDurations
[
]
=
{
(
PR_USEC_PER_SEC
/
10
)
/
2
(
PR_USEC_PER_SEC
/
10
)
*
3
/
2
(
PR_USEC_PER_SEC
/
10
)
}
;
uint64_t
totalDuration
=
0
;
size_t
i
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
EXPECT_EQ
(
expectedDurations
[
i
+
+
]
frame
-
>
GetDuration
(
)
)
;
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
pointThree
=
(
PR_USEC_PER_SEC
/
10
)
*
3
;
EXPECT_EQ
(
pointThree
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
DriftingFrameEncode
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
EXPECT_CALL
(
*
encoder
.
DriftCompensator
(
)
GetVideoTime
(
_
_
)
)
.
WillRepeatedly
(
Invoke
(
[
&
]
(
TimeStamp
TimeStamp
aTime
)
{
return
now
+
(
aTime
-
now
)
*
2
;
}
)
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
05
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
3
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
expectedDurations
[
]
=
{
(
PR_USEC_PER_SEC
/
10
)
(
PR_USEC_PER_SEC
/
10
)
*
3
(
PR_USEC_PER_SEC
/
10
)
*
2
}
;
uint64_t
totalDuration
=
0
;
size_t
i
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
EXPECT_EQ
(
expectedDurations
[
i
+
+
]
frame
-
>
GetDuration
(
)
)
;
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
pointSix
=
(
PR_USEC_PER_SEC
/
10
)
*
6
;
EXPECT_EQ
(
pointSix
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
Suspended
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
encoder
.
Suspend
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
encoder
.
Resume
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
3
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
uint64_t
two
=
2
;
EXPECT_EQ
(
two
container
.
GetEncodedFrames
(
)
.
Length
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
pointTwo
=
(
PR_USEC_PER_SEC
/
10
)
*
2
;
EXPECT_EQ
(
pointTwo
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
SuspendedUntilEnd
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
encoder
.
Suspend
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
uint64_t
one
=
1
;
EXPECT_EQ
(
one
container
.
GetEncodedFrames
(
)
.
Length
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
pointOne
=
PR_USEC_PER_SEC
/
10
;
EXPECT_EQ
(
pointOne
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
AlwaysSuspended
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
encoder
.
Suspend
(
now
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
2
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
uint64_t
none
=
0
;
EXPECT_EQ
(
none
container
.
GetEncodedFrames
(
)
.
Length
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
SuspendedBeginning
)
{
TestVP8TrackEncoder
encoder
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
encoder
.
Suspend
(
now
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
Resume
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
uint64_t
one
=
1
;
EXPECT_EQ
(
one
container
.
GetEncodedFrames
(
)
.
Length
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
SuspendedOverlap
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
Suspend
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
.
3
)
)
;
encoder
.
Resume
(
now
+
TimeDuration
:
:
FromSeconds
(
1
.
3
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
2
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
uint64_t
two
=
2
;
EXPECT_EQ
(
two
container
.
GetEncodedFrames
(
)
.
Length
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
onePointTwo
=
(
PR_USEC_PER_SEC
/
10
)
*
12
;
EXPECT_EQ
(
onePointTwo
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
PrematureEnding
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
DelayedStart
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
DelayedStartOtherEventOrder
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
SetStartOffset
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
VeryDelayedStart
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
+
TimeDuration
:
:
FromSeconds
(
10
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
10
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
LongFramesReEncoded
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
{
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
.
5
)
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_FALSE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
oneSec
=
PR_USEC_PER_SEC
;
EXPECT_EQ
(
oneSec
totalDuration
)
;
EXPECT_EQ
(
1U
container
.
GetEncodedFrames
(
)
.
Length
(
)
)
;
}
{
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
11
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
tenSec
=
PR_USEC_PER_SEC
*
10
;
EXPECT_EQ
(
tenSec
totalDuration
)
;
EXPECT_EQ
(
10U
container
.
GetEncodedFrames
(
)
.
Length
(
)
)
;
}
}
TEST
(
VP8VideoTrackEncoder
ShortKeyFrameInterval
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
400
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
600
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
750
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
900
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
1100
)
)
;
encoder
.
SetKeyFrameInterval
(
500
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
.
2
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
nsTArray
<
RefPtr
<
EncodedFrame
>
>
&
frames
=
container
.
GetEncodedFrames
(
)
;
ASSERT_EQ
(
6UL
frames
.
Length
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
400UL
frames
[
0
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
0
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
200UL
frames
[
1
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
1
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
150UL
frames
[
2
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
2
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
150UL
frames
[
3
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
3
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
200UL
frames
[
4
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
4
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
5
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
5
]
-
>
GetFrameType
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
LongKeyFrameInterval
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
600
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
900
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
1100
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
1900
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
2100
)
)
;
encoder
.
SetKeyFrameInterval
(
2000
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
2
.
2
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
nsTArray
<
RefPtr
<
EncodedFrame
>
>
&
frames
=
container
.
GetEncodedFrames
(
)
;
ASSERT_EQ
(
6UL
frames
.
Length
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
600UL
frames
[
0
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
0
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
300UL
frames
[
1
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
1
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
200UL
frames
[
2
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
2
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
800UL
frames
[
3
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
3
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
200UL
frames
[
4
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
4
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
5
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
5
]
-
>
GetFrameType
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
DefaultKeyFrameInterval
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
600
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
900
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
1100
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
1900
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
2100
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
2
.
2
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
nsTArray
<
RefPtr
<
EncodedFrame
>
>
&
frames
=
container
.
GetEncodedFrames
(
)
;
ASSERT_EQ
(
6UL
frames
.
Length
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
600UL
frames
[
0
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
0
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
300UL
frames
[
1
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
1
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
200UL
frames
[
2
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
2
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
800UL
frames
[
3
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
3
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
200UL
frames
[
4
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
4
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
5
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
5
]
-
>
GetFrameType
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
DynamicKeyFrameIntervalChanges
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
EncodedFrameContainer
container
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
120
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
130
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
300
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
500
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
SetKeyFrameInterval
(
100
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
501
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
1300
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
1400
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
2400
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
2500
)
)
;
encoder
.
SetKeyFrameInterval
(
1100
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
2501
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
2600
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
2800
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
2900
)
)
;
encoder
.
SetKeyFrameInterval
(
200
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
3000
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
nsTArray
<
RefPtr
<
EncodedFrame
>
>
&
frames
=
container
.
GetEncodedFrames
(
)
;
ASSERT_EQ
(
14UL
frames
.
Length
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
0
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
0
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
20UL
frames
[
1
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
1
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
10UL
frames
[
2
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
2
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
70UL
frames
[
3
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
3
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
4
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
4
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
200UL
frames
[
5
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
5
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
800UL
frames
[
6
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
6
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
7
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
7
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frames
[
8
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
8
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
9
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
9
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
10
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
10
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
200UL
frames
[
11
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
11
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
12
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
12
]
-
>
GetFrameType
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
13
]
-
>
GetDuration
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
13
]
-
>
GetFrameType
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
EncodeComplete
)
{
TestVP8TrackEncoder
encoder
;
encoder
.
NotifyEndOfStream
(
)
;
EncodedFrameContainer
container
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
}
