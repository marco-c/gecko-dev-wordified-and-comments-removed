#
include
<
algorithm
>
#
include
"
DriftCompensation
.
h
"
#
include
"
MediaTrackGraph
.
h
"
#
include
"
MediaTrackListener
.
h
"
#
include
"
VP8TrackEncoder
.
h
"
#
include
"
WebMWriter
.
h
"
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
prtime
.
h
"
#
include
"
YUVBufferGenerator
.
h
"
#
define
VIDEO_TRACK_RATE
90000
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
Invoke
;
using
:
:
testing
:
:
NiceMock
;
using
:
:
testing
:
:
TestWithParam
;
using
:
:
testing
:
:
Values
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
;
struct
InitParam
{
bool
mShouldSucceed
;
int
mWidth
;
int
mHeight
;
}
;
class
MockDriftCompensator
:
public
DriftCompensator
{
public
:
MockDriftCompensator
(
)
:
DriftCompensator
(
GetCurrentSerialEventTarget
(
)
VIDEO_TRACK_RATE
)
{
ON_CALL
(
*
this
GetVideoTime
(
_
_
)
)
.
WillByDefault
(
Invoke
(
[
]
(
TimeStamp
TimeStamp
t
)
{
return
t
;
}
)
)
;
}
MOCK_METHOD2
(
GetVideoTime
TimeStamp
(
TimeStamp
TimeStamp
)
)
;
}
;
class
TestVP8TrackEncoder
:
public
VP8TrackEncoder
{
public
:
explicit
TestVP8TrackEncoder
(
Maybe
<
float
>
aKeyFrameIntervalFactor
=
Nothing
(
)
)
:
VP8TrackEncoder
(
MakeRefPtr
<
NiceMock
<
MockDriftCompensator
>
>
(
)
VIDEO_TRACK_RATE
mEncodedVideoQueue
FrameDroppingMode
:
:
DISALLOW
aKeyFrameIntervalFactor
)
{
}
MockDriftCompensator
*
DriftCompensator
(
)
{
return
static_cast
<
MockDriftCompensator
*
>
(
mDriftCompensator
.
get
(
)
)
;
}
:
:
testing
:
:
AssertionResult
TestInit
(
const
InitParam
&
aParam
)
{
nsresult
result
=
Init
(
aParam
.
mWidth
aParam
.
mHeight
aParam
.
mWidth
aParam
.
mHeight
30
)
;
if
(
(
(
NS_FAILED
(
result
)
&
&
aParam
.
mShouldSucceed
)
)
|
|
(
NS_SUCCEEDED
(
result
)
&
&
!
aParam
.
mShouldSucceed
)
)
{
return
:
:
testing
:
:
AssertionFailure
(
)
<
<
"
width
=
"
<
<
aParam
.
mWidth
<
<
"
height
=
"
<
<
aParam
.
mHeight
;
}
return
:
:
testing
:
:
AssertionSuccess
(
)
;
}
MediaQueue
<
EncodedFrame
>
mEncodedVideoQueue
;
}
;
TEST
(
VP8VideoTrackEncoder
Initialization
)
{
InitParam
params
[
]
=
{
{
false
0
0
}
{
false
0
1
}
{
false
1
0
}
{
true
640
480
}
{
true
800
480
}
{
true
960
540
}
{
true
1280
720
}
}
;
for
(
const
InitParam
&
param
:
params
)
{
TestVP8TrackEncoder
encoder
;
EXPECT_TRUE
(
encoder
.
TestInit
(
param
)
)
;
}
}
TEST
(
VP8VideoTrackEncoder
FetchMetaData
)
{
InitParam
params
[
]
=
{
{
true
640
480
}
{
true
800
480
}
{
true
960
540
}
{
true
1280
720
}
}
;
for
(
const
InitParam
&
param
:
params
)
{
TestVP8TrackEncoder
encoder
;
EXPECT_TRUE
(
encoder
.
TestInit
(
param
)
)
;
RefPtr
<
TrackMetadataBase
>
meta
=
encoder
.
GetMetadata
(
)
;
RefPtr
<
VP8Metadata
>
vp8Meta
(
static_cast
<
VP8Metadata
*
>
(
meta
.
get
(
)
)
)
;
EXPECT_EQ
(
vp8Meta
-
>
mWidth
param
.
mWidth
)
;
EXPECT_EQ
(
vp8Meta
-
>
mHeight
param
.
mHeight
)
;
}
}
TEST
(
VP8VideoTrackEncoder
FrameEncode
)
{
TestVP8TrackEncoder
encoder
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
nsTArray
<
RefPtr
<
Image
>
>
images
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
images
.
AppendElement
(
generator
.
GenerateI420Image
(
)
)
;
images
.
AppendElement
(
generator
.
GenerateNV12Image
(
)
)
;
images
.
AppendElement
(
generator
.
GenerateNV21Image
(
)
)
;
VideoSegment
segment
;
for
(
nsTArray
<
RefPtr
<
Image
>
>
:
:
size_type
i
=
0
;
i
<
images
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
Image
>
image
=
images
[
i
]
;
segment
.
AppendFrame
(
image
.
forget
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
i
)
)
;
}
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
images
.
Length
(
)
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
SingleFrameEncode
)
{
TestVP8TrackEncoder
encoder
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frame
-
>
mFrameType
)
<
<
"
We
only
have
one
frame
so
it
should
be
a
keyframe
"
;
const
uint64_t
halfSecond
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
halfSecond
frame
-
>
mDuration
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
SameFrameEncode
)
{
TestVP8TrackEncoder
encoder
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
RefPtr
<
Image
>
image
=
generator
.
GenerateI420Image
(
)
;
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
15
;
+
+
i
)
{
segment
.
AppendFrame
(
do_AddRef
(
image
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
i
*
0
.
1
)
)
;
}
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
uint64_t
totalDuration
=
0
;
while
(
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
oneAndAHalf
=
(
PR_USEC_PER_SEC
/
2
)
*
3
;
EXPECT_EQ
(
oneAndAHalf
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
SkippedFrames
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
100
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
i
)
)
;
}
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
uint64_t
totalDuration
=
0
;
while
(
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
hundredMillis
=
PR_USEC_PER_SEC
/
10
;
EXPECT_EQ
(
hundredMillis
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
RoundingErrorFramesEncode
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
uint32_t
usPerFrame
=
99999
;
for
(
uint32_t
i
=
0
;
i
<
9
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMicroseconds
(
i
*
usPerFrame
)
)
;
}
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
9
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
uint64_t
totalDuration
=
0
;
while
(
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
oneSecond
=
PR_USEC_PER_SEC
-
1
;
EXPECT_EQ
(
oneSecond
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
TimestampFrameEncode
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
05
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
3
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
uint64_t
expectedDurations
[
]
=
{
(
PR_USEC_PER_SEC
/
10
)
/
2
(
PR_USEC_PER_SEC
/
10
)
*
3
/
2
(
PR_USEC_PER_SEC
/
10
)
}
;
uint64_t
totalDuration
=
0
;
size_t
i
=
0
;
while
(
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
)
{
EXPECT_EQ
(
expectedDurations
[
i
]
frame
-
>
mDuration
)
;
i
+
+
;
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
pointThree
=
(
PR_USEC_PER_SEC
/
10
)
*
3
;
EXPECT_EQ
(
pointThree
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
DriftingFrameEncode
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
EXPECT_CALL
(
*
encoder
.
DriftCompensator
(
)
GetVideoTime
(
_
_
)
)
.
WillRepeatedly
(
Invoke
(
[
&
]
(
TimeStamp
TimeStamp
aTime
)
{
return
now
+
(
aTime
-
now
)
*
2
;
}
)
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
05
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
3
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
uint64_t
expectedDurations
[
]
=
{
(
PR_USEC_PER_SEC
/
10
)
(
PR_USEC_PER_SEC
/
10
)
*
3
(
PR_USEC_PER_SEC
/
10
)
*
2
}
;
uint64_t
totalDuration
=
0
;
size_t
i
=
0
;
while
(
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
)
{
EXPECT_EQ
(
expectedDurations
[
i
]
frame
-
>
mDuration
)
;
i
+
+
;
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
pointSix
=
(
PR_USEC_PER_SEC
/
10
)
*
6
;
EXPECT_EQ
(
pointSix
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
Suspended
)
{
TestVP8TrackEncoder
encoder
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
}
encoder
.
Suspend
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
}
encoder
.
Resume
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
3
)
)
;
}
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
uint64_t
count
=
0
;
uint64_t
totalDuration
=
0
;
while
(
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
)
{
+
+
count
;
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
two
=
2
;
EXPECT_EQ
(
two
count
)
;
const
uint64_t
pointTwo
=
(
PR_USEC_PER_SEC
/
10
)
*
2
;
EXPECT_EQ
(
pointTwo
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
SuspendedUntilEnd
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
}
encoder
.
Suspend
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
}
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
uint64_t
count
=
0
;
uint64_t
totalDuration
=
0
;
while
(
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
)
{
+
+
count
;
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
one
=
1
;
EXPECT_EQ
(
one
count
)
;
const
uint64_t
pointOne
=
PR_USEC_PER_SEC
/
10
;
EXPECT_EQ
(
pointOne
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
AlwaysSuspended
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
encoder
.
Suspend
(
now
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
2
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
SuspendedBeginning
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
encoder
.
Suspend
(
now
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
}
encoder
.
Resume
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
}
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
uint64_t
count
=
0
;
uint64_t
totalDuration
=
0
;
while
(
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
)
{
+
+
count
;
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
one
=
1
;
EXPECT_EQ
(
one
count
)
;
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
SuspendedOverlap
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
Suspend
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
.
3
)
)
;
encoder
.
Resume
(
now
+
TimeDuration
:
:
FromSeconds
(
1
.
3
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
2
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
const
uint64_t
pointFive
=
(
PR_USEC_PER_SEC
/
10
)
*
5
;
EXPECT_EQ
(
pointFive
frame
-
>
mDuration
)
;
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
const
uint64_t
pointSeven
=
(
PR_USEC_PER_SEC
/
10
)
*
7
;
EXPECT_EQ
(
pointSeven
frame
-
>
mDuration
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
PrematureEnding
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
uint64_t
totalDuration
=
0
;
while
(
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
DelayedStart
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
uint64_t
totalDuration
=
0
;
while
(
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
DelayedStartOtherEventOrder
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
SetStartOffset
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
uint64_t
totalDuration
=
0
;
while
(
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
VeryDelayedStart
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
+
TimeDuration
:
:
FromSeconds
(
10
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
10
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
uint64_t
totalDuration
=
0
;
while
(
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
LongFramesReEncoded
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
{
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
6
.
5
)
)
;
EXPECT_FALSE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
uint64_t
count
=
0
;
uint64_t
totalDuration
=
0
;
while
(
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
)
{
+
+
count
;
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
sixSec
=
6
*
PR_USEC_PER_SEC
;
EXPECT_EQ
(
sixSec
totalDuration
)
;
EXPECT_EQ
(
6U
count
)
;
}
{
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
11
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
uint64_t
count
=
0
;
uint64_t
totalDuration
=
0
;
while
(
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
)
{
+
+
count
;
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
fiveSec
=
5
*
PR_USEC_PER_SEC
;
EXPECT_EQ
(
fiveSec
totalDuration
)
;
EXPECT_EQ
(
5U
count
)
;
}
}
TEST
(
VP8VideoTrackEncoder
DefaultKeyFrameInterval
)
{
TestVP8TrackEncoder
encoder
(
Some
(
2
.
0
)
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
21
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frame
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frame
-
>
mFrameType
)
;
for
(
int
i
=
0
;
i
<
9
;
+
+
i
)
{
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frame
-
>
mDuration
)
<
<
"
Start
time
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Start
time
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frame
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frame
-
>
mFrameType
)
;
for
(
int
i
=
0
;
i
<
9
;
+
+
i
)
{
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frame
-
>
mDuration
)
<
<
"
Start
time
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Start
time
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frame
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frame
-
>
mFrameType
)
;
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
500UL
frame
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
DisableOnFrameTime
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
Disable
(
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frame
-
>
mDuration
)
;
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frame
-
>
mDuration
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
DisableBetweenFrames
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
Disable
(
now
+
TimeDuration
:
:
FromMilliseconds
(
50
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
50UL
frame
-
>
mDuration
)
;
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
50UL
frame
-
>
mDuration
)
;
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frame
-
>
mDuration
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
DisableBeforeFirstFrame
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
50
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
Disable
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
Enable
(
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frame
-
>
mDuration
)
;
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frame
-
>
mDuration
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
EnableOnFrameTime
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
Disable
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
Enable
(
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frame
-
>
mDuration
)
;
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frame
-
>
mDuration
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
EnableBetweenFrames
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
Disable
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
Enable
(
now
+
TimeDuration
:
:
FromMilliseconds
(
50
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
50UL
frame
-
>
mDuration
)
;
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
50UL
frame
-
>
mDuration
)
;
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frame
-
>
mDuration
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
BackwardsTimeResets
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
encoder
.
SetStartOffset
(
now
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
300
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
125
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
150
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
250
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
350
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
300
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frame
-
>
mDuration
)
;
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
50UL
frame
-
>
mDuration
)
;
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frame
-
>
mDuration
)
;
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
50UL
frame
-
>
mDuration
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
NullImageResets
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
encoder
.
SetStartOffset
(
now
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
300
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
125
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
nullptr
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
125
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
250
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
350
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
300
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frame
-
>
mDuration
)
;
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
150UL
frame
-
>
mDuration
)
;
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
50UL
frame
-
>
mDuration
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
MaxKeyFrameDistanceLowFramerate
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
240
180
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
encoder
.
SetStartOffset
(
now
)
;
const
TimeDuration
duration
=
TimeDuration
:
:
FromSeconds
(
10
)
;
const
uint32_t
numFrames
=
10
*
2
;
const
TimeDuration
frameDuration
=
duration
/
static_cast
<
int64_t
>
(
numFrames
)
;
{
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
numFrames
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
frameDuration
*
i
)
;
}
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
duration
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
numFrames
;
+
+
i
)
{
const
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
500UL
frame
-
>
mDuration
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
EXPECT_EQ
(
i
%
15
=
=
0
?
EncodedFrame
:
:
VP8_I_FRAME
:
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
MaxKeyFrameDistanceHighFramerate
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
240
180
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
encoder
.
SetStartOffset
(
now
)
;
const
TimeDuration
duration
=
TimeDuration
:
:
FromSeconds
(
10
)
;
const
uint32_t
numFrames
=
10
*
8
;
const
TimeDuration
frameDuration
=
duration
/
static_cast
<
int64_t
>
(
numFrames
)
;
{
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
numFrames
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
frameDuration
*
i
)
;
}
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
duration
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
numFrames
;
+
+
i
)
{
const
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
125UL
frame
-
>
mDuration
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
EXPECT_EQ
(
i
%
60
=
=
0
?
EncodedFrame
:
:
VP8_I_FRAME
:
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
MaxKeyFrameDistanceAdaptiveFramerate
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
240
180
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
encoder
.
SetStartOffset
(
now
)
;
const
TimeDuration
firstDuration
=
TimeDuration
:
:
FromSeconds
(
11
)
;
const
uint32_t
firstNumFrames
=
11
*
2
;
const
TimeDuration
firstFrameDuration
=
firstDuration
/
static_cast
<
int64_t
>
(
firstNumFrames
)
;
{
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
firstNumFrames
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
firstFrameDuration
*
i
)
;
}
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
firstDuration
)
;
const
TimeDuration
secondDuration
=
TimeDuration
:
:
FromSeconds
(
14
)
;
const
uint32_t
secondNumFrames
=
14
*
10
;
const
TimeDuration
secondFrameDuration
=
secondDuration
/
static_cast
<
int64_t
>
(
secondNumFrames
)
;
{
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
secondNumFrames
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
firstDuration
+
secondFrameDuration
*
i
)
;
}
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
firstDuration
+
secondDuration
)
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
EXPECT_FALSE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
22
;
+
+
i
)
{
const
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
500UL
frame
-
>
mDuration
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
EXPECT_EQ
(
i
%
15
=
=
0
?
EncodedFrame
:
:
VP8_I_FRAME
:
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
for
(
uint32_t
i
=
22
;
i
<
162
;
+
+
i
)
{
const
RefPtr
<
EncodedFrame
>
frame
=
encoder
.
mEncodedVideoQueue
.
PopFront
(
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frame
-
>
mDuration
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
if
(
i
<
22
+
40
)
{
EXPECT_EQ
(
i
%
15
=
=
0
?
EncodedFrame
:
:
VP8_I_FRAME
:
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
else
{
EXPECT_EQ
(
(
i
-
22
-
40
)
%
75
=
=
0
?
EncodedFrame
:
:
VP8_I_FRAME
:
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
}
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
AtEndOfStream
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
EncodeComplete
)
{
TestVP8TrackEncoder
encoder
;
encoder
.
NotifyEndOfStream
(
)
;
EXPECT_TRUE
(
encoder
.
mEncodedVideoQueue
.
IsFinished
(
)
)
;
}
