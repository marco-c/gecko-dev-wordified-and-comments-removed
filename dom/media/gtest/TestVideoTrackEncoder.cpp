#
include
<
algorithm
>
#
include
"
DriftCompensation
.
h
"
#
include
"
MediaTrackGraph
.
h
"
#
include
"
MediaTrackListener
.
h
"
#
include
"
VP8TrackEncoder
.
h
"
#
include
"
WebMWriter
.
h
"
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
prtime
.
h
"
#
include
"
YUVBufferGenerator
.
h
"
#
define
VIDEO_TRACK_RATE
90000
using
:
:
testing
:
:
_
;
using
:
:
testing
:
:
Invoke
;
using
:
:
testing
:
:
NiceMock
;
using
:
:
testing
:
:
TestWithParam
;
using
:
:
testing
:
:
Values
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
;
struct
InitParam
{
bool
mShouldSucceed
;
int
mWidth
;
int
mHeight
;
}
;
class
MockDriftCompensator
:
public
DriftCompensator
{
public
:
MockDriftCompensator
(
)
:
DriftCompensator
(
GetCurrentEventTarget
(
)
VIDEO_TRACK_RATE
)
{
ON_CALL
(
*
this
GetVideoTime
(
_
_
)
)
.
WillByDefault
(
Invoke
(
[
]
(
TimeStamp
TimeStamp
t
)
{
return
t
;
}
)
)
;
}
MOCK_METHOD2
(
GetVideoTime
TimeStamp
(
TimeStamp
TimeStamp
)
)
;
}
;
class
TestVP8TrackEncoder
:
public
VP8TrackEncoder
{
public
:
explicit
TestVP8TrackEncoder
(
Maybe
<
float
>
aKeyFrameIntervalFactor
=
Nothing
(
)
)
:
VP8TrackEncoder
(
MakeRefPtr
<
NiceMock
<
MockDriftCompensator
>
>
(
)
VIDEO_TRACK_RATE
FrameDroppingMode
:
:
DISALLOW
aKeyFrameIntervalFactor
)
{
}
MockDriftCompensator
*
DriftCompensator
(
)
{
return
static_cast
<
MockDriftCompensator
*
>
(
mDriftCompensator
.
get
(
)
)
;
}
:
:
testing
:
:
AssertionResult
TestInit
(
const
InitParam
&
aParam
)
{
nsresult
result
=
Init
(
aParam
.
mWidth
aParam
.
mHeight
aParam
.
mWidth
aParam
.
mHeight
30
)
;
if
(
(
(
NS_FAILED
(
result
)
&
&
aParam
.
mShouldSucceed
)
)
|
|
(
NS_SUCCEEDED
(
result
)
&
&
!
aParam
.
mShouldSucceed
)
)
{
return
:
:
testing
:
:
AssertionFailure
(
)
<
<
"
width
=
"
<
<
aParam
.
mWidth
<
<
"
height
=
"
<
<
aParam
.
mHeight
;
}
return
:
:
testing
:
:
AssertionSuccess
(
)
;
}
}
;
TEST
(
VP8VideoTrackEncoder
Initialization
)
{
InitParam
params
[
]
=
{
{
false
0
0
}
{
false
0
1
}
{
false
1
0
}
{
true
640
480
}
{
true
800
480
}
{
true
960
540
}
{
true
1280
720
}
}
;
for
(
const
InitParam
&
param
:
params
)
{
TestVP8TrackEncoder
encoder
;
EXPECT_TRUE
(
encoder
.
TestInit
(
param
)
)
;
}
}
TEST
(
VP8VideoTrackEncoder
FetchMetaData
)
{
InitParam
params
[
]
=
{
{
true
640
480
}
{
true
800
480
}
{
true
960
540
}
{
true
1280
720
}
}
;
for
(
const
InitParam
&
param
:
params
)
{
TestVP8TrackEncoder
encoder
;
EXPECT_TRUE
(
encoder
.
TestInit
(
param
)
)
;
RefPtr
<
TrackMetadataBase
>
meta
=
encoder
.
GetMetadata
(
)
;
RefPtr
<
VP8Metadata
>
vp8Meta
(
static_cast
<
VP8Metadata
*
>
(
meta
.
get
(
)
)
)
;
EXPECT_EQ
(
vp8Meta
-
>
mWidth
param
.
mWidth
)
;
EXPECT_EQ
(
vp8Meta
-
>
mHeight
param
.
mHeight
)
;
}
}
TEST
(
VP8VideoTrackEncoder
FrameEncode
)
{
TestVP8TrackEncoder
encoder
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
nsTArray
<
RefPtr
<
Image
>
>
images
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
images
.
AppendElement
(
generator
.
GenerateI420Image
(
)
)
;
images
.
AppendElement
(
generator
.
GenerateNV12Image
(
)
)
;
images
.
AppendElement
(
generator
.
GenerateNV21Image
(
)
)
;
VideoSegment
segment
;
for
(
nsTArray
<
RefPtr
<
Image
>
>
:
:
size_type
i
=
0
;
i
<
images
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
Image
>
image
=
images
[
i
]
;
segment
.
AppendFrame
(
image
.
forget
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
i
)
)
;
}
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
images
.
Length
(
)
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
}
TEST
(
VP8VideoTrackEncoder
SingleFrameEncode
)
{
TestVP8TrackEncoder
encoder
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
size_t
oneElement
=
1
;
ASSERT_EQ
(
oneElement
frames
.
Length
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
0
]
-
>
mFrameType
)
<
<
"
We
only
have
one
frame
so
it
should
be
a
keyframe
"
;
const
uint64_t
halfSecond
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
halfSecond
frames
[
0
]
-
>
mDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
SameFrameEncode
)
{
TestVP8TrackEncoder
encoder
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
RefPtr
<
Image
>
image
=
generator
.
GenerateI420Image
(
)
;
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
15
;
+
+
i
)
{
segment
.
AppendFrame
(
do_AddRef
(
image
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
i
*
0
.
1
)
)
;
}
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
frames
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
oneAndAHalf
=
(
PR_USEC_PER_SEC
/
2
)
*
3
;
EXPECT_EQ
(
oneAndAHalf
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
SkippedFrames
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
100
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
i
)
)
;
}
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
frames
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
hundredMillis
=
PR_USEC_PER_SEC
/
10
;
EXPECT_EQ
(
hundredMillis
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
RoundingErrorFramesEncode
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
uint32_t
usPerFrame
=
99999
;
for
(
uint32_t
i
=
0
;
i
<
9
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMicroseconds
(
i
*
usPerFrame
)
)
;
}
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
9
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
frames
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
oneSecond
=
PR_USEC_PER_SEC
;
EXPECT_EQ
(
oneSecond
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
TimestampFrameEncode
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
05
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
3
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
expectedDurations
[
]
=
{
(
PR_USEC_PER_SEC
/
10
)
/
2
(
PR_USEC_PER_SEC
/
10
)
*
3
/
2
(
PR_USEC_PER_SEC
/
10
)
}
;
uint64_t
totalDuration
=
0
;
size_t
i
=
0
;
for
(
auto
&
frame
:
frames
)
{
EXPECT_EQ
(
expectedDurations
[
i
]
frame
-
>
mDuration
)
;
i
+
+
;
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
pointThree
=
(
PR_USEC_PER_SEC
/
10
)
*
3
;
EXPECT_EQ
(
pointThree
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
DriftingFrameEncode
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
EXPECT_CALL
(
*
encoder
.
DriftCompensator
(
)
GetVideoTime
(
_
_
)
)
.
WillRepeatedly
(
Invoke
(
[
&
]
(
TimeStamp
TimeStamp
aTime
)
{
return
now
+
(
aTime
-
now
)
*
2
;
}
)
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
05
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
3
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
expectedDurations
[
]
=
{
(
PR_USEC_PER_SEC
/
10
)
(
PR_USEC_PER_SEC
/
10
)
*
3
(
PR_USEC_PER_SEC
/
10
)
*
2
}
;
uint64_t
totalDuration
=
0
;
size_t
i
=
0
;
for
(
auto
&
frame
:
frames
)
{
EXPECT_EQ
(
expectedDurations
[
i
]
frame
-
>
mDuration
)
;
i
+
+
;
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
pointSix
=
(
PR_USEC_PER_SEC
/
10
)
*
6
;
EXPECT_EQ
(
pointSix
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
Suspended
)
{
TestVP8TrackEncoder
encoder
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
}
encoder
.
Suspend
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
}
encoder
.
Resume
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
3
)
)
;
}
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
uint64_t
two
=
2
;
EXPECT_EQ
(
two
frames
.
Length
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
frames
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
pointTwo
=
(
PR_USEC_PER_SEC
/
10
)
*
2
;
EXPECT_EQ
(
pointTwo
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
SuspendedUntilEnd
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
}
encoder
.
Suspend
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
1
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
2
)
)
;
}
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
uint64_t
one
=
1
;
EXPECT_EQ
(
one
frames
.
Length
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
frames
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
pointOne
=
PR_USEC_PER_SEC
/
10
;
EXPECT_EQ
(
pointOne
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
AlwaysSuspended
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
encoder
.
Suspend
(
now
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
2
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
uint64_t
none
=
0
;
EXPECT_EQ
(
none
frames
.
Length
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
SuspendedBeginning
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
encoder
.
Suspend
(
now
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
}
encoder
.
Resume
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
}
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
uint64_t
one
=
1
;
EXPECT_EQ
(
one
frames
.
Length
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
frames
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
SuspendedOverlap
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
Suspend
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
.
3
)
)
;
encoder
.
Resume
(
now
+
TimeDuration
:
:
FromSeconds
(
1
.
3
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
2
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
uint64_t
two
=
2
;
ASSERT_EQ
(
two
frames
.
Length
(
)
)
;
const
uint64_t
pointFive
=
(
PR_USEC_PER_SEC
/
10
)
*
5
;
EXPECT_EQ
(
pointFive
frames
[
0
]
-
>
mDuration
)
;
const
uint64_t
pointSeven
=
(
PR_USEC_PER_SEC
/
10
)
*
7
;
EXPECT_EQ
(
pointSeven
frames
[
1
]
-
>
mDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
PrematureEnding
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
frames
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
DelayedStart
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
frames
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
DelayedStartOtherEventOrder
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
SetStartOffset
(
now
+
TimeDuration
:
:
FromSeconds
(
0
.
5
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
frames
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
VeryDelayedStart
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
+
TimeDuration
:
:
FromSeconds
(
10
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
10
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
frames
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
half
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
half
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
LongFramesReEncoded
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
{
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
6
.
5
)
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_FALSE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
frames
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
sixSec
=
6
*
PR_USEC_PER_SEC
;
EXPECT_EQ
(
sixSec
totalDuration
)
;
EXPECT_EQ
(
6U
frames
.
Length
(
)
)
;
}
{
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
11
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
frames
)
{
totalDuration
+
=
frame
-
>
mDuration
;
}
const
uint64_t
fiveSec
=
5
*
PR_USEC_PER_SEC
;
EXPECT_EQ
(
fiveSec
totalDuration
)
;
EXPECT_EQ
(
5U
frames
.
Length
(
)
)
;
}
}
TEST
(
VP8VideoTrackEncoder
ShortKeyFrameInterval
)
{
TestVP8TrackEncoder
encoder
(
Some
(
2
.
0
)
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
400
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
600
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
750
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
900
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
1100
)
)
;
encoder
.
SetKeyFrameInterval
(
Some
(
TimeDuration
:
:
FromMilliseconds
(
500
)
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
1
.
2
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
ASSERT_EQ
(
6UL
frames
.
Length
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
400UL
frames
[
0
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
0
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
200UL
frames
[
1
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
1
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
150UL
frames
[
2
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
2
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
150UL
frames
[
3
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
3
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
200UL
frames
[
4
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
4
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
5
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
5
]
-
>
mFrameType
)
;
}
TEST
(
VP8VideoTrackEncoder
LongKeyFrameInterval
)
{
TestVP8TrackEncoder
encoder
(
Some
(
2
.
0
)
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetKeyFrameInterval
(
Some
(
TimeDuration
:
:
FromMilliseconds
(
11000
)
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
21
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
framesArray
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
framesArray
)
)
)
;
auto
frames
=
Span
(
framesArray
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
ASSERT_EQ
(
22UL
frames
.
Length
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frames
[
0
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
0
]
-
>
mFrameType
)
;
for
(
const
auto
&
frame
:
frames
.
Subspan
<
1
8
>
(
)
)
{
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frame
-
>
mDuration
)
<
<
"
Start
time
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Start
time
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frames
[
10
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
10
]
-
>
mFrameType
)
;
for
(
const
auto
&
frame
:
frames
.
FromTo
(
11
20
)
)
{
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frame
-
>
mDuration
)
<
<
"
Start
time
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Start
time
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frames
[
20
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
20
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
500UL
frames
[
21
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
21
]
-
>
mFrameType
)
;
}
TEST
(
VP8VideoTrackEncoder
DefaultKeyFrameInterval
)
{
TestVP8TrackEncoder
encoder
(
Some
(
2
.
0
)
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromSeconds
(
21
.
5
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
framesArray
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
framesArray
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
ASSERT_EQ
(
22UL
framesArray
.
Length
(
)
)
;
auto
frames
=
Span
(
framesArray
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frames
[
0
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
0
]
-
>
mFrameType
)
;
for
(
const
auto
&
frame
:
frames
.
Subspan
<
1
8
>
(
)
)
{
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frame
-
>
mDuration
)
<
<
"
Start
time
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Start
time
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frames
[
10
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
10
]
-
>
mFrameType
)
;
for
(
const
auto
&
frame
:
frames
.
FromTo
(
11
20
)
)
{
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frame
-
>
mDuration
)
<
<
"
Start
time
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Start
time
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frames
[
20
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
20
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
500UL
frames
[
21
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
21
]
-
>
mFrameType
)
;
}
TEST
(
VP8VideoTrackEncoder
DynamicKeyFrameIntervalChanges
)
{
TestVP8TrackEncoder
encoder
(
Some
(
10
.
0
)
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
1000
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
1200
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
1300
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
2000
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
3000
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
3400
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
SetKeyFrameInterval
(
Some
(
TimeDuration
:
:
FromMilliseconds
(
1000
)
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
3401
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
13300
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
13400
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
13500
)
)
;
encoder
.
SetKeyFrameInterval
(
Some
(
TimeDuration
:
:
FromMilliseconds
(
11000
)
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
13501
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
13900
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
14000
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
14400
)
)
;
encoder
.
SetKeyFrameInterval
(
Some
(
TimeDuration
:
:
FromMilliseconds
(
500
)
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
15000
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
ASSERT_EQ
(
22UL
frames
.
Length
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frames
[
0
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
0
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
200UL
frames
[
1
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
1
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
2
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
2
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
700UL
frames
[
3
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
3
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frames
[
4
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
4
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
400UL
frames
[
5
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
5
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frames
[
6
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
6
]
-
>
mFrameType
)
;
for
(
const
auto
&
frame
:
Span
(
frames
)
.
FromTo
(
7
15
)
)
{
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
1000UL
frame
-
>
mDuration
)
<
<
"
Start
time
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Start
time
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
900UL
frames
[
15
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
15
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
16
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
16
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
17
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
17
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
400UL
frames
[
18
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
18
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
19
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
19
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
400UL
frames
[
20
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
20
]
-
>
mFrameType
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
600UL
frames
[
21
]
-
>
mDuration
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_P_FRAME
frames
[
21
]
-
>
mFrameType
)
;
}
TEST
(
VP8VideoTrackEncoder
DisableOnFrameTime
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
Disable
(
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
ASSERT_EQ
(
2UL
frames
.
Length
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
0
]
-
>
mDuration
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
1
]
-
>
mDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
DisableBetweenFrames
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
Disable
(
now
+
TimeDuration
:
:
FromMilliseconds
(
50
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
ASSERT_EQ
(
3UL
frames
.
Length
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
50UL
frames
[
0
]
-
>
mDuration
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
50UL
frames
[
1
]
-
>
mDuration
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
2
]
-
>
mDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
DisableBeforeFirstFrame
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
50
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
Disable
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
Enable
(
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
ASSERT_EQ
(
2UL
frames
.
Length
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
0
]
-
>
mDuration
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
1
]
-
>
mDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
EnableOnFrameTime
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
Disable
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
Enable
(
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
ASSERT_EQ
(
2UL
frames
.
Length
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
0
]
-
>
mDuration
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
1
]
-
>
mDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
EnableBetweenFrames
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
encoder
.
SetStartOffset
(
now
)
;
encoder
.
Disable
(
now
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
encoder
.
Enable
(
now
+
TimeDuration
:
:
FromMilliseconds
(
50
)
)
;
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
ASSERT_EQ
(
3UL
frames
.
Length
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
50UL
frames
[
0
]
-
>
mDuration
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
50UL
frames
[
1
]
-
>
mDuration
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
2
]
-
>
mDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
BackwardsTimeResets
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
encoder
.
SetStartOffset
(
now
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
300
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
125
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
150
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
250
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
350
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
300
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
ASSERT_EQ
(
4UL
frames
.
Length
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
0
]
-
>
mDuration
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
50UL
frames
[
1
]
-
>
mDuration
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
2
]
-
>
mDuration
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
50UL
frames
[
3
]
-
>
mDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
NullImageResets
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
encoder
.
SetStartOffset
(
now
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
100
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
200
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
300
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
125
)
)
;
{
VideoSegment
segment
;
segment
.
AppendFrame
(
nullptr
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
125
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
250
)
)
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
350
)
)
;
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
TimeDuration
:
:
FromMilliseconds
(
300
)
)
;
encoder
.
NotifyEndOfStream
(
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
ASSERT_EQ
(
3UL
frames
.
Length
(
)
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frames
[
0
]
-
>
mDuration
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
150UL
frames
[
1
]
-
>
mDuration
)
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
50UL
frames
[
2
]
-
>
mDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
MaxKeyFrameDistanceLowFramerate
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
240
180
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
encoder
.
SetStartOffset
(
now
)
;
const
TimeDuration
duration
=
TimeDuration
:
:
FromSeconds
(
10
)
;
const
uint32_t
numFrames
=
10
*
2
;
const
TimeDuration
frameDuration
=
duration
/
static_cast
<
int64_t
>
(
numFrames
)
;
{
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
numFrames
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
frameDuration
*
i
)
;
}
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
duration
)
;
encoder
.
NotifyEndOfStream
(
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
ASSERT_EQ
(
numFrames
frames
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
frames
.
Length
(
)
;
+
+
i
)
{
const
auto
&
frame
=
frames
[
i
]
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
500UL
frame
-
>
mDuration
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
EXPECT_EQ
(
i
%
15
=
=
0
?
EncodedFrame
:
:
VP8_I_FRAME
:
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
}
TEST
(
VP8VideoTrackEncoder
MaxKeyFrameDistanceHighFramerate
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
240
180
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
encoder
.
SetStartOffset
(
now
)
;
const
TimeDuration
duration
=
TimeDuration
:
:
FromSeconds
(
10
)
;
const
uint32_t
numFrames
=
10
*
8
;
const
TimeDuration
frameDuration
=
duration
/
static_cast
<
int64_t
>
(
numFrames
)
;
{
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
numFrames
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
frameDuration
*
i
)
;
}
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
duration
)
;
encoder
.
NotifyEndOfStream
(
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
ASSERT_EQ
(
numFrames
frames
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
frames
.
Length
(
)
;
+
+
i
)
{
const
auto
&
frame
=
frames
[
i
]
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
125UL
frame
-
>
mDuration
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
EXPECT_EQ
(
i
%
60
=
=
0
?
EncodedFrame
:
:
VP8_I_FRAME
:
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
}
TEST
(
VP8VideoTrackEncoder
MaxKeyFrameDistanceAdaptiveFramerate
)
{
TestVP8TrackEncoder
encoder
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
240
180
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
encoder
.
SetStartOffset
(
now
)
;
const
TimeDuration
firstDuration
=
TimeDuration
:
:
FromSeconds
(
11
)
;
const
uint32_t
firstNumFrames
=
11
*
2
;
const
TimeDuration
firstFrameDuration
=
firstDuration
/
static_cast
<
int64_t
>
(
firstNumFrames
)
;
{
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
firstNumFrames
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
firstFrameDuration
*
i
)
;
}
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
firstDuration
)
;
const
TimeDuration
secondDuration
=
TimeDuration
:
:
FromSeconds
(
14
)
;
const
uint32_t
secondNumFrames
=
14
*
10
;
const
TimeDuration
secondFrameDuration
=
secondDuration
/
static_cast
<
int64_t
>
(
secondNumFrames
)
;
{
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
secondNumFrames
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
firstDuration
+
secondFrameDuration
*
i
)
;
}
encoder
.
AppendVideoSegment
(
std
:
:
move
(
segment
)
)
;
}
encoder
.
AdvanceCurrentTime
(
now
+
firstDuration
+
secondDuration
)
;
encoder
.
NotifyEndOfStream
(
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
ASSERT_EQ
(
firstNumFrames
+
secondNumFrames
frames
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
22
;
+
+
i
)
{
const
auto
&
frame
=
frames
[
i
]
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
500UL
frame
-
>
mDuration
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
EXPECT_EQ
(
i
%
15
=
=
0
?
EncodedFrame
:
:
VP8_I_FRAME
:
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
for
(
uint32_t
i
=
22
;
i
<
frames
.
Length
(
)
;
+
+
i
)
{
const
auto
&
frame
=
frames
[
i
]
;
EXPECT_EQ
(
PR_USEC_PER_SEC
/
1000
*
100UL
frame
-
>
mDuration
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
if
(
i
<
22
+
40
)
{
EXPECT_EQ
(
i
%
15
=
=
0
?
EncodedFrame
:
:
VP8_I_FRAME
:
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
else
{
EXPECT_EQ
(
(
i
-
22
-
40
)
%
75
=
=
0
?
EncodedFrame
:
:
VP8_I_FRAME
:
EncodedFrame
:
:
VP8_P_FRAME
frame
-
>
mFrameType
)
<
<
"
Frame
"
<
<
i
<
<
"
with
start
:
"
<
<
frame
-
>
mTime
.
ToMicroseconds
(
)
<
<
"
us
"
;
}
}
}
TEST
(
VP8VideoTrackEncoder
EncodeComplete
)
{
TestVP8TrackEncoder
encoder
;
encoder
.
NotifyEndOfStream
(
)
;
nsTArray
<
RefPtr
<
EncodedFrame
>
>
frames
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
frames
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
}
