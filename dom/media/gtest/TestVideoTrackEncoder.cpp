#
include
"
gtest
/
gtest
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
VP8TrackEncoder
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
MediaStreamGraph
.
h
"
#
include
"
MediaStreamListener
.
h
"
#
include
"
WebMWriter
.
h
"
using
:
:
testing
:
:
TestWithParam
;
using
:
:
testing
:
:
Values
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
;
class
YUVBufferGenerator
{
public
:
YUVBufferGenerator
(
)
{
}
void
Init
(
const
mozilla
:
:
gfx
:
:
IntSize
&
aSize
)
{
mImageSize
=
aSize
;
int
yPlaneLen
=
aSize
.
width
*
aSize
.
height
;
int
cbcrPlaneLen
=
(
yPlaneLen
+
1
)
/
2
;
int
frameLen
=
yPlaneLen
+
cbcrPlaneLen
;
mSourceBuffer
.
SetLength
(
frameLen
)
;
memset
(
mSourceBuffer
.
Elements
(
)
0x10
yPlaneLen
)
;
memset
(
mSourceBuffer
.
Elements
(
)
+
yPlaneLen
0x80
cbcrPlaneLen
)
;
}
mozilla
:
:
gfx
:
:
IntSize
GetSize
(
)
const
{
return
mImageSize
;
}
already_AddRefed
<
Image
>
GenerateI420Image
(
)
{
return
do_AddRef
(
CreateI420Image
(
)
)
;
}
already_AddRefed
<
Image
>
GenerateNV12Image
(
)
{
return
do_AddRef
(
CreateNV12Image
(
)
)
;
}
already_AddRefed
<
Image
>
GenerateNV21Image
(
)
{
return
do_AddRef
(
CreateNV21Image
(
)
)
;
}
private
:
Image
*
CreateI420Image
(
)
{
PlanarYCbCrImage
*
image
=
new
RecyclingPlanarYCbCrImage
(
new
BufferRecycleBin
(
)
)
;
PlanarYCbCrData
data
;
data
.
mPicSize
=
mImageSize
;
const
uint32_t
yPlaneSize
=
mImageSize
.
width
*
mImageSize
.
height
;
const
uint32_t
halfWidth
=
(
mImageSize
.
width
+
1
)
/
2
;
const
uint32_t
halfHeight
=
(
mImageSize
.
height
+
1
)
/
2
;
const
uint32_t
uvPlaneSize
=
halfWidth
*
halfHeight
;
uint8_t
*
y
=
mSourceBuffer
.
Elements
(
)
;
data
.
mYChannel
=
y
;
data
.
mYSize
.
width
=
mImageSize
.
width
;
data
.
mYSize
.
height
=
mImageSize
.
height
;
data
.
mYStride
=
mImageSize
.
width
;
data
.
mYSkip
=
0
;
uint8_t
*
cr
=
y
+
yPlaneSize
+
uvPlaneSize
;
data
.
mCrChannel
=
cr
;
data
.
mCrSkip
=
0
;
uint8_t
*
cb
=
y
+
yPlaneSize
;
data
.
mCbChannel
=
cb
;
data
.
mCbSkip
=
0
;
data
.
mCbCrStride
=
halfWidth
;
data
.
mCbCrSize
.
width
=
halfWidth
;
data
.
mCbCrSize
.
height
=
halfHeight
;
image
-
>
CopyData
(
data
)
;
return
image
;
}
Image
*
CreateNV12Image
(
)
{
PlanarYCbCrImage
*
image
=
new
RecyclingPlanarYCbCrImage
(
new
BufferRecycleBin
(
)
)
;
PlanarYCbCrData
data
;
data
.
mPicSize
=
mImageSize
;
const
uint32_t
yPlaneSize
=
mImageSize
.
width
*
mImageSize
.
height
;
const
uint32_t
halfWidth
=
(
mImageSize
.
width
+
1
)
/
2
;
const
uint32_t
halfHeight
=
(
mImageSize
.
height
+
1
)
/
2
;
uint8_t
*
y
=
mSourceBuffer
.
Elements
(
)
;
data
.
mYChannel
=
y
;
data
.
mYSize
.
width
=
mImageSize
.
width
;
data
.
mYSize
.
height
=
mImageSize
.
height
;
data
.
mYStride
=
mImageSize
.
width
;
data
.
mYSkip
=
0
;
uint8_t
*
cr
=
y
+
yPlaneSize
;
data
.
mCrChannel
=
cr
;
data
.
mCrSkip
=
1
;
uint8_t
*
cb
=
y
+
yPlaneSize
+
1
;
data
.
mCbChannel
=
cb
;
data
.
mCbSkip
=
1
;
data
.
mCbCrStride
=
mImageSize
.
width
;
data
.
mCbCrSize
.
width
=
halfWidth
;
data
.
mCbCrSize
.
height
=
halfHeight
;
image
-
>
CopyData
(
data
)
;
return
image
;
}
Image
*
CreateNV21Image
(
)
{
PlanarYCbCrImage
*
image
=
new
RecyclingPlanarYCbCrImage
(
new
BufferRecycleBin
(
)
)
;
PlanarYCbCrData
data
;
data
.
mPicSize
=
mImageSize
;
const
uint32_t
yPlaneSize
=
mImageSize
.
width
*
mImageSize
.
height
;
const
uint32_t
halfWidth
=
(
mImageSize
.
width
+
1
)
/
2
;
const
uint32_t
halfHeight
=
(
mImageSize
.
height
+
1
)
/
2
;
uint8_t
*
y
=
mSourceBuffer
.
Elements
(
)
;
data
.
mYChannel
=
y
;
data
.
mYSize
.
width
=
mImageSize
.
width
;
data
.
mYSize
.
height
=
mImageSize
.
height
;
data
.
mYStride
=
mImageSize
.
width
;
data
.
mYSkip
=
0
;
uint8_t
*
cr
=
y
+
yPlaneSize
+
1
;
data
.
mCrChannel
=
cr
;
data
.
mCrSkip
=
1
;
uint8_t
*
cb
=
y
+
yPlaneSize
;
data
.
mCbChannel
=
cb
;
data
.
mCbSkip
=
1
;
data
.
mCbCrStride
=
mImageSize
.
width
;
data
.
mCbCrSize
.
width
=
halfWidth
;
data
.
mCbCrSize
.
height
=
halfHeight
;
image
-
>
CopyData
(
data
)
;
return
image
;
}
private
:
mozilla
:
:
gfx
:
:
IntSize
mImageSize
;
nsTArray
<
uint8_t
>
mSourceBuffer
;
}
;
struct
InitParam
{
bool
mShouldSucceed
;
int
mWidth
;
int
mHeight
;
}
;
class
TestVP8TrackEncoder
:
public
VP8TrackEncoder
{
public
:
explicit
TestVP8TrackEncoder
(
TrackRate
aTrackRate
=
90000
)
:
VP8TrackEncoder
(
aTrackRate
)
{
}
:
:
testing
:
:
AssertionResult
TestInit
(
const
InitParam
&
aParam
)
{
nsresult
result
=
Init
(
aParam
.
mWidth
aParam
.
mHeight
aParam
.
mWidth
aParam
.
mHeight
)
;
if
(
(
(
NS_FAILED
(
result
)
&
&
aParam
.
mShouldSucceed
)
)
|
|
(
NS_SUCCEEDED
(
result
)
&
&
!
aParam
.
mShouldSucceed
)
)
{
return
:
:
testing
:
:
AssertionFailure
(
)
<
<
"
width
=
"
<
<
aParam
.
mWidth
<
<
"
height
=
"
<
<
aParam
.
mHeight
;
}
else
{
return
:
:
testing
:
:
AssertionSuccess
(
)
;
}
}
}
;
TEST
(
VP8VideoTrackEncoder
Initialization
)
{
InitParam
params
[
]
=
{
{
false
0
0
}
{
false
0
1
}
{
false
1
0
}
{
true
640
480
}
{
true
800
480
}
{
true
960
540
}
{
true
1280
720
}
}
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
params
)
;
i
+
+
)
{
TestVP8TrackEncoder
encoder
;
EXPECT_TRUE
(
encoder
.
TestInit
(
params
[
i
]
)
)
;
}
}
TEST
(
VP8VideoTrackEncoder
FetchMetaData
)
{
InitParam
params
[
]
=
{
{
true
640
480
}
{
true
800
480
}
{
true
960
540
}
{
true
1280
720
}
}
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
params
)
;
i
+
+
)
{
TestVP8TrackEncoder
encoder
;
EXPECT_TRUE
(
encoder
.
TestInit
(
params
[
i
]
)
)
;
RefPtr
<
TrackMetadataBase
>
meta
=
encoder
.
GetMetadata
(
)
;
RefPtr
<
VP8Metadata
>
vp8Meta
(
static_cast
<
VP8Metadata
*
>
(
meta
.
get
(
)
)
)
;
EXPECT_TRUE
(
vp8Meta
-
>
mWidth
=
=
params
[
i
]
.
mWidth
)
;
EXPECT_TRUE
(
vp8Meta
-
>
mHeight
=
=
params
[
i
]
.
mHeight
)
;
}
}
TEST
(
VP8VideoTrackEncoder
FrameEncode
)
{
TestVP8TrackEncoder
encoder
;
InitParam
param
=
{
true
640
480
}
;
encoder
.
TestInit
(
param
)
;
nsTArray
<
RefPtr
<
Image
>
>
images
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
images
.
AppendElement
(
generator
.
GenerateI420Image
(
)
)
;
images
.
AppendElement
(
generator
.
GenerateNV12Image
(
)
)
;
images
.
AppendElement
(
generator
.
GenerateNV21Image
(
)
)
;
VideoSegment
segment
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
for
(
nsTArray
<
RefPtr
<
Image
>
>
:
:
size_type
i
=
0
;
i
<
images
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
Image
>
image
=
images
[
i
]
;
segment
.
AppendFrame
(
image
.
forget
(
)
mozilla
:
:
StreamTime
(
90000
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
i
)
)
;
}
encoder
.
SetCurrentFrames
(
segment
)
;
EncodedFrameContainer
container
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
}
TEST
(
VP8VideoTrackEncoder
SingleFrameEncode
)
{
TestVP8TrackEncoder
encoder
;
InitParam
param
=
{
true
640
480
}
;
encoder
.
TestInit
(
param
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
VideoSegment
segment
;
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
mozilla
:
:
StreamTime
(
45000
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
)
;
encoder
.
SetCurrentFrames
(
segment
)
;
segment
.
Clear
(
)
;
encoder
.
NotifyQueuedTrackChanges
(
nullptr
0
0
TrackEventCommand
:
:
TRACK_EVENT_ENDED
segment
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
const
nsTArray
<
RefPtr
<
EncodedFrame
>
>
&
frames
=
container
.
GetEncodedFrames
(
)
;
const
size_t
oneElement
=
1
;
ASSERT_EQ
(
oneElement
frames
.
Length
(
)
)
;
EXPECT_EQ
(
EncodedFrame
:
:
VP8_I_FRAME
frames
[
0
]
-
>
GetFrameType
(
)
)
<
<
"
We
only
have
one
frame
so
it
should
be
a
keyframe
"
;
const
uint64_t
halfSecond
=
PR_USEC_PER_SEC
/
2
;
EXPECT_EQ
(
halfSecond
frames
[
0
]
-
>
GetDuration
(
)
)
;
}
TEST
(
VP8VideoTrackEncoder
SameFrameEncode
)
{
TestVP8TrackEncoder
encoder
;
InitParam
param
=
{
true
640
480
}
;
encoder
.
TestInit
(
param
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
RefPtr
<
Image
>
image
=
generator
.
GenerateI420Image
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
15
;
+
+
i
)
{
segment
.
AppendFrame
(
do_AddRef
(
image
)
mozilla
:
:
StreamTime
(
9000
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
i
*
0
.
1
)
)
;
}
encoder
.
SetCurrentFrames
(
segment
)
;
segment
.
Clear
(
)
;
encoder
.
NotifyQueuedTrackChanges
(
nullptr
0
0
TrackEventCommand
:
:
TRACK_EVENT_ENDED
segment
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
oneAndAHalf
=
(
PR_USEC_PER_SEC
/
2
)
*
3
;
EXPECT_EQ
(
oneAndAHalf
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
NullFrameFirst
)
{
TestVP8TrackEncoder
encoder
;
InitParam
param
=
{
true
640
480
}
;
encoder
.
TestInit
(
param
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
RefPtr
<
Image
>
image
=
generator
.
GenerateI420Image
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
2
;
+
+
i
)
{
segment
.
AppendFrame
(
nullptr
mozilla
:
:
StreamTime
(
9000
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
i
*
0
.
1
)
)
;
}
segment
.
AppendFrame
(
image
.
forget
(
)
mozilla
:
:
StreamTime
(
9000
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
3
)
)
;
encoder
.
SetCurrentFrames
(
segment
)
;
segment
.
Clear
(
)
;
encoder
.
NotifyQueuedTrackChanges
(
nullptr
0
0
TrackEventCommand
:
:
TRACK_EVENT_ENDED
segment
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
pointThree
=
(
PR_USEC_PER_SEC
/
10
)
*
3
;
EXPECT_EQ
(
pointThree
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
SkippedFrames
)
{
TestVP8TrackEncoder
encoder
;
InitParam
param
=
{
true
640
480
}
;
encoder
.
TestInit
(
param
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
for
(
uint32_t
i
=
0
;
i
<
100
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
mozilla
:
:
StreamTime
(
90
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMilliseconds
(
i
)
)
;
}
encoder
.
SetCurrentFrames
(
segment
)
;
segment
.
Clear
(
)
;
encoder
.
NotifyQueuedTrackChanges
(
nullptr
0
0
TrackEventCommand
:
:
TRACK_EVENT_ENDED
segment
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
hundredMillis
=
PR_USEC_PER_SEC
/
10
;
EXPECT_EQ
(
hundredMillis
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
RoundingErrorFramesEncode
)
{
TestVP8TrackEncoder
encoder
;
InitParam
param
=
{
true
640
480
}
;
encoder
.
TestInit
(
param
)
;
YUVBufferGenerator
generator
;
generator
.
Init
(
mozilla
:
:
gfx
:
:
IntSize
(
640
480
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
VideoSegment
segment
;
uint32_t
usPerFrame
=
99999
;
for
(
uint32_t
i
=
0
;
i
<
9
;
+
+
i
)
{
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
mozilla
:
:
StreamTime
(
9000
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromMicroseconds
(
i
*
usPerFrame
)
)
;
}
segment
.
AppendFrame
(
generator
.
GenerateI420Image
(
)
mozilla
:
:
StreamTime
(
9000
)
generator
.
GetSize
(
)
PRINCIPAL_HANDLE_NONE
false
now
+
TimeDuration
:
:
FromSeconds
(
0
.
9
)
)
;
encoder
.
SetCurrentFrames
(
segment
)
;
segment
.
Clear
(
)
;
encoder
.
NotifyQueuedTrackChanges
(
nullptr
0
0
TrackEventCommand
:
:
TRACK_EVENT_ENDED
segment
)
;
EncodedFrameContainer
container
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
uint64_t
totalDuration
=
0
;
for
(
auto
&
frame
:
container
.
GetEncodedFrames
(
)
)
{
totalDuration
+
=
frame
-
>
GetDuration
(
)
;
}
const
uint64_t
oneSecond
=
PR_USEC_PER_SEC
;
EXPECT_EQ
(
oneSecond
totalDuration
)
;
}
TEST
(
VP8VideoTrackEncoder
EncodeComplete
)
{
TestVP8TrackEncoder
encoder
;
InitParam
param
=
{
true
640
480
}
;
encoder
.
TestInit
(
param
)
;
VideoSegment
segment
;
encoder
.
NotifyQueuedTrackChanges
(
nullptr
0
0
TrackEventCommand
:
:
TRACK_EVENT_ENDED
segment
)
;
EncodedFrameContainer
container
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
encoder
.
GetEncodedTrack
(
container
)
)
)
;
EXPECT_TRUE
(
encoder
.
IsEncodingComplete
(
)
)
;
}
