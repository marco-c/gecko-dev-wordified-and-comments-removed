#
include
"
DeviceInputTrack
.
h
"
#
include
"
gmock
/
gmock
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
AudioGenerator
.
h
"
#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
MockCubeb
.
h
"
#
include
"
WaitFor
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
nsContentUtils
.
h
"
using
namespace
mozilla
;
using
testing
:
:
NiceMock
;
using
testing
:
:
Return
;
namespace
{
#
define
DispatchFunction
(
f
)
\
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
__func__
f
)
)
}
class
MockGraphImpl
:
public
MediaTrackGraphImpl
{
public
:
MockGraphImpl
(
TrackRate
aRate
uint32_t
aChannels
)
:
MediaTrackGraphImpl
(
OFFLINE_THREAD_DRIVER
DIRECT_DRIVER
aRate
aChannels
nullptr
NS_GetCurrentThread
(
)
)
{
ON_CALL
(
*
this
OnGraphThread
)
.
WillByDefault
(
Return
(
true
)
)
;
SetCurrentDriver
(
new
NiceMock
<
MockDriver
>
(
)
)
;
}
MOCK_CONST_METHOD0
(
OnGraphThread
bool
(
)
)
;
MOCK_METHOD1
(
AppendMessage
void
(
UniquePtr
<
ControlMessage
>
)
)
;
protected
:
~
MockGraphImpl
(
)
=
default
;
class
MockDriver
:
public
GraphDriver
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MockDriver
override
)
;
MockDriver
(
)
:
GraphDriver
(
nullptr
nullptr
0
)
{
ON_CALL
(
*
this
OnThread
)
.
WillByDefault
(
Return
(
true
)
)
;
ON_CALL
(
*
this
ThreadRunning
)
.
WillByDefault
(
Return
(
true
)
)
;
}
MOCK_METHOD0
(
Start
void
(
)
)
;
MOCK_METHOD0
(
Shutdown
void
(
)
)
;
MOCK_METHOD0
(
IterationDuration
uint32_t
(
)
)
;
MOCK_METHOD0
(
EnsureNextIteration
void
(
)
)
;
MOCK_CONST_METHOD0
(
OnThread
bool
(
)
)
;
MOCK_CONST_METHOD0
(
ThreadRunning
bool
(
)
)
;
protected
:
~
MockDriver
(
)
=
default
;
}
;
}
;
class
TestDeviceInputTrack
:
public
testing
:
:
Test
{
protected
:
TestDeviceInputTrack
(
)
:
mChannels
(
2
)
mRate
(
44100
)
{
}
void
SetUp
(
)
override
{
mGraph
=
MakeRefPtr
<
NiceMock
<
MockGraphImpl
>
>
(
mRate
mChannels
)
;
}
void
TearDown
(
)
override
{
mGraph
-
>
Destroy
(
)
;
}
const
uint32_t
mChannels
;
const
TrackRate
mRate
;
RefPtr
<
MockGraphImpl
>
mGraph
;
}
;
TEST_F
(
TestDeviceInputTrack
DeviceInputConsumerTrack
)
{
class
TestDeviceInputConsumerTrack
:
public
DeviceInputConsumerTrack
{
public
:
static
TestDeviceInputConsumerTrack
*
Create
(
MediaTrackGraph
*
aGraph
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
TestDeviceInputConsumerTrack
*
track
=
new
TestDeviceInputConsumerTrack
(
aGraph
-
>
GraphRate
(
)
)
;
aGraph
-
>
AddTrack
(
track
)
;
return
track
;
}
void
Destroy
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
DisconnectDeviceInput
(
)
;
DeviceInputConsumerTrack
:
:
Destroy
(
)
;
}
void
ProcessInput
(
GraphTime
aFrom
GraphTime
aTo
uint32_t
aFlags
)
override
{
}
;
uint32_t
NumberOfChannels
(
)
const
override
{
if
(
mInputs
.
IsEmpty
(
)
)
{
return
0
;
}
DeviceInputTrack
*
t
=
mInputs
[
0
]
-
>
GetSource
(
)
-
>
AsDeviceInputTrack
(
)
;
MOZ_ASSERT
(
t
)
;
return
t
-
>
NumberOfChannels
(
)
;
}
private
:
explicit
TestDeviceInputConsumerTrack
(
TrackRate
aSampleRate
)
:
DeviceInputConsumerTrack
(
aSampleRate
)
{
}
}
;
class
TestAudioDataListener
:
public
AudioDataListener
{
public
:
TestAudioDataListener
(
uint32_t
aChannelCount
bool
aIsVoice
)
:
mChannelCount
(
aChannelCount
)
mIsVoice
(
aIsVoice
)
{
}
uint32_t
RequestedInputChannelCount
(
MediaTrackGraphImpl
*
aGraph
)
override
{
MOZ_ASSERT
(
aGraph
-
>
OnGraphThread
(
)
)
;
return
mChannelCount
;
}
bool
IsVoiceInput
(
MediaTrackGraphImpl
*
aGraph
)
const
override
{
return
mIsVoice
;
}
;
void
DeviceChanged
(
MediaTrackGraphImpl
*
aGraph
)
override
{
}
void
Disconnect
(
MediaTrackGraphImpl
*
aGraph
)
override
{
}
;
private
:
~
TestAudioDataListener
(
)
=
default
;
uint32_t
mChannelCount
;
const
bool
mIsVoice
;
}
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
const
CubebUtils
:
:
AudioDeviceID
device1
=
(
void
*
)
1
;
RefPtr
<
TestAudioDataListener
>
listener1
=
new
TestAudioDataListener
(
1
false
)
;
RefPtr
<
TestDeviceInputConsumerTrack
>
track1
=
TestDeviceInputConsumerTrack
:
:
Create
(
mGraph
)
;
track1
-
>
ConnectDeviceInput
(
device1
listener1
.
get
(
)
testPrincipal
)
;
EXPECT_TRUE
(
track1
-
>
ConnectToNativeDevice
(
)
)
;
EXPECT_FALSE
(
track1
-
>
ConnectToNonNativeDevice
(
)
)
;
const
CubebUtils
:
:
AudioDeviceID
device2
=
(
void
*
)
2
;
RefPtr
<
TestAudioDataListener
>
listener2
=
new
TestAudioDataListener
(
2
false
)
;
RefPtr
<
TestDeviceInputConsumerTrack
>
track2
=
TestDeviceInputConsumerTrack
:
:
Create
(
mGraph
)
;
track2
-
>
ConnectDeviceInput
(
device2
listener2
.
get
(
)
testPrincipal
)
;
EXPECT_FALSE
(
track2
-
>
ConnectToNativeDevice
(
)
)
;
EXPECT_TRUE
(
track2
-
>
ConnectToNonNativeDevice
(
)
)
;
track2
-
>
Destroy
(
)
;
mGraph
-
>
RemoveTrackGraphThread
(
track2
)
;
track1
-
>
Destroy
(
)
;
mGraph
-
>
RemoveTrackGraphThread
(
track1
)
;
}
TEST_F
(
TestDeviceInputTrack
NativeInputTrackData
)
{
const
uint32_t
flags
=
0
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
void
*
)
1
;
AudioGenerator
<
AudioDataValue
>
generator
(
mChannels
mRate
)
;
const
size_t
nrFrames
=
10
;
const
size_t
bufferSize
=
nrFrames
*
mChannels
;
nsTArray
<
AudioDataValue
>
buffer
(
bufferSize
)
;
buffer
.
AppendElements
(
bufferSize
)
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
RefPtr
<
NativeInputTrack
>
track
=
new
NativeInputTrack
(
mGraph
-
>
GraphRate
(
)
deviceId
testPrincipal
)
;
mGraph
-
>
AddTrack
(
track
)
;
generator
.
GenerateInterleaved
(
buffer
.
Elements
(
)
nrFrames
)
;
track
-
>
NotifyInputData
(
mGraph
.
get
(
)
buffer
.
Elements
(
)
nrFrames
mRate
mChannels
0
)
;
track
-
>
ProcessInput
(
0
WEBAUDIO_BLOCK_SIZE
+
nrFrames
flags
)
;
EXPECT_EQ
(
static_cast
<
size_t
>
(
track
-
>
GetEnd
(
)
)
static_cast
<
size_t
>
(
WEBAUDIO_BLOCK_SIZE
)
+
nrFrames
)
;
AudioSegment
preBuffering
;
preBuffering
.
AppendSlice
(
*
track
-
>
GetData
(
)
0
WEBAUDIO_BLOCK_SIZE
)
;
EXPECT_TRUE
(
preBuffering
.
IsNull
(
)
)
;
for
(
AudioSegment
:
:
ConstChunkIterator
iter
(
preBuffering
)
;
!
iter
.
IsEnded
(
)
;
iter
.
Next
(
)
)
{
const
AudioChunk
&
chunk
=
*
iter
;
EXPECT_EQ
(
chunk
.
mPrincipalHandle
PRINCIPAL_HANDLE_NONE
)
;
}
AudioSegment
data
;
data
.
AppendSlice
(
*
track
-
>
GetData
(
)
WEBAUDIO_BLOCK_SIZE
WEBAUDIO_BLOCK_SIZE
+
nrFrames
)
;
nsTArray
<
AudioDataValue
>
interleaved
;
size_t
sampleCount
=
data
.
WriteToInterleavedBuffer
(
interleaved
mChannels
)
;
EXPECT_EQ
(
sampleCount
bufferSize
)
;
EXPECT_EQ
(
interleaved
buffer
)
;
for
(
AudioSegment
:
:
ConstChunkIterator
iter
(
data
)
;
!
iter
.
IsEnded
(
)
;
iter
.
Next
(
)
)
{
const
AudioChunk
&
chunk
=
*
iter
;
EXPECT_EQ
(
chunk
.
mPrincipalHandle
testPrincipal
)
;
}
track
-
>
Destroy
(
)
;
mGraph
-
>
RemoveTrackGraphThread
(
track
)
;
}
class
MockEventListener
:
public
AudioInputSource
:
:
EventListener
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MockEventListener
override
)
;
MOCK_METHOD1
(
AudioDeviceChanged
void
(
AudioInputSource
:
:
Id
)
)
;
MOCK_METHOD2
(
AudioStateCallback
void
(
AudioInputSource
:
:
Id
AudioInputSource
:
:
EventListener
:
:
State
)
)
;
private
:
~
MockEventListener
(
)
=
default
;
}
;
TEST_F
(
TestDeviceInputTrack
StartAndStop
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
const
AudioInputSource
:
:
Id
sourceId
=
1
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
const
uint32_t
channels
=
2
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
const
TrackRate
rate
=
48000
;
const
uint32_t
bufferingMs
=
StaticPrefs
:
:
media_clockdrift_buffering
(
)
;
RefPtr
<
NonNativeInputTrack
>
track
=
new
NonNativeInputTrack
(
mGraph
-
>
GraphRate
(
)
deviceId
testPrincipal
)
;
mGraph
-
>
AddTrack
(
track
)
;
{
auto
listener
=
MakeRefPtr
<
MockEventListener
>
(
)
;
EXPECT_CALL
(
*
listener
AudioStateCallback
(
sourceId
AudioInputSource
:
:
EventListener
:
:
State
:
:
Started
)
)
;
EXPECT_CALL
(
*
listener
AudioStateCallback
(
sourceId
AudioInputSource
:
:
EventListener
:
:
State
:
:
Stopped
)
)
.
Times
(
2
)
;
EXPECT_EQ
(
track
-
>
NumberOfChannels
(
)
0U
)
;
EXPECT_EQ
(
track
-
>
DevicePreference
(
)
AudioInputType
:
:
Unknown
)
;
DispatchFunction
(
[
&
]
{
track
-
>
StartAudio
(
MakeRefPtr
<
AudioInputSource
>
(
std
:
:
move
(
listener
)
sourceId
deviceId
channels
true
testPrincipal
rate
mGraph
-
>
GraphRate
(
)
bufferingMs
)
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
EXPECT_FALSE
(
stream
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream
-
>
GetInputDeviceID
(
)
deviceId
)
;
EXPECT_EQ
(
stream
-
>
InputChannels
(
)
channels
)
;
EXPECT_EQ
(
stream
-
>
InputSampleRate
(
)
static_cast
<
uint32_t
>
(
rate
)
)
;
EXPECT_EQ
(
track
-
>
NumberOfChannels
(
)
channels
)
;
EXPECT_EQ
(
track
-
>
DevicePreference
(
)
AudioInputType
:
:
Voice
)
;
Unused
<
<
WaitFor
(
stream
-
>
FramesProcessedEvent
(
)
)
;
DispatchFunction
(
[
&
]
{
track
-
>
StopAudio
(
)
;
}
)
;
Unused
<
<
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
EXPECT_EQ
(
track
-
>
NumberOfChannels
(
)
0U
)
;
EXPECT_EQ
(
track
-
>
DevicePreference
(
)
AudioInputType
:
:
Unknown
)
;
}
{
auto
listener
=
MakeRefPtr
<
MockEventListener
>
(
)
;
EXPECT_CALL
(
*
listener
AudioStateCallback
(
sourceId
AudioInputSource
:
:
EventListener
:
:
State
:
:
Started
)
)
;
EXPECT_CALL
(
*
listener
AudioStateCallback
(
sourceId
AudioInputSource
:
:
EventListener
:
:
State
:
:
Stopped
)
)
.
Times
(
2
)
;
DispatchFunction
(
[
&
]
{
track
-
>
StartAudio
(
MakeRefPtr
<
AudioInputSource
>
(
std
:
:
move
(
listener
)
sourceId
deviceId
channels
true
testPrincipal
rate
mGraph
-
>
GraphRate
(
)
bufferingMs
)
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
EXPECT_FALSE
(
stream
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream
-
>
GetInputDeviceID
(
)
deviceId
)
;
EXPECT_EQ
(
stream
-
>
InputChannels
(
)
channels
)
;
EXPECT_EQ
(
stream
-
>
InputSampleRate
(
)
static_cast
<
uint32_t
>
(
rate
)
)
;
Unused
<
<
WaitFor
(
stream
-
>
FramesProcessedEvent
(
)
)
;
DispatchFunction
(
[
&
]
{
track
-
>
StopAudio
(
)
;
}
)
;
Unused
<
<
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
}
track
-
>
Destroy
(
)
;
mGraph
-
>
RemoveTrackGraphThread
(
track
)
;
}
TEST_F
(
TestDeviceInputTrack
NonNativeInputTrackData
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
const
uint32_t
flags
=
0
;
const
GraphTime
frames
=
440
;
const
AudioInputSource
:
:
Id
sourceId
=
1
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
const
uint32_t
channels
=
2
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
const
TrackRate
rate
=
48000
;
const
uint32_t
bufferingMs
=
static_cast
<
uint32_t
>
(
StaticPrefs
:
:
media_clockdrift_buffering
(
)
)
;
RefPtr
<
NonNativeInputTrack
>
track
=
new
NonNativeInputTrack
(
mGraph
-
>
GraphRate
(
)
deviceId
testPrincipal
)
;
mGraph
-
>
AddTrack
(
track
)
;
GraphTime
current
=
0
;
GraphTime
next
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
frames
)
;
ASSERT_NE
(
current
next
)
;
track
-
>
ProcessInput
(
current
next
flags
)
;
{
AudioSegment
data
;
data
.
AppendSegment
(
track
-
>
GetData
<
AudioSegment
>
(
)
)
;
EXPECT_TRUE
(
data
.
IsNull
(
)
)
;
}
current
=
next
;
next
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
2
*
frames
)
;
ASSERT_NE
(
current
next
)
;
auto
listener
=
MakeRefPtr
<
MockEventListener
>
(
)
;
EXPECT_CALL
(
*
listener
AudioStateCallback
(
sourceId
AudioInputSource
:
:
EventListener
:
:
State
:
:
Started
)
)
;
EXPECT_CALL
(
*
listener
AudioStateCallback
(
sourceId
AudioInputSource
:
:
EventListener
:
:
State
:
:
Stopped
)
)
.
Times
(
2
)
;
DispatchFunction
(
[
&
]
{
track
-
>
StartAudio
(
MakeRefPtr
<
AudioInputSource
>
(
std
:
:
move
(
listener
)
sourceId
deviceId
channels
true
testPrincipal
rate
mGraph
-
>
GraphRate
(
)
bufferingMs
)
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
EXPECT_FALSE
(
stream
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream
-
>
GetInputDeviceID
(
)
deviceId
)
;
EXPECT_EQ
(
stream
-
>
InputChannels
(
)
channels
)
;
EXPECT_EQ
(
stream
-
>
InputSampleRate
(
)
static_cast
<
uint32_t
>
(
rate
)
)
;
Unused
<
<
WaitFor
(
stream
-
>
FramesProcessedEvent
(
)
)
;
track
-
>
ProcessInput
(
current
next
flags
)
;
{
AudioSegment
data
;
data
.
AppendSlice
(
*
track
-
>
GetData
<
AudioSegment
>
(
)
current
next
)
;
EXPECT_FALSE
(
data
.
IsNull
(
)
)
;
for
(
AudioSegment
:
:
ConstChunkIterator
iter
(
data
)
;
!
iter
.
IsEnded
(
)
;
iter
.
Next
(
)
)
{
EXPECT_EQ
(
iter
-
>
mChannelData
.
Length
(
)
channels
)
;
EXPECT_EQ
(
iter
-
>
mPrincipalHandle
testPrincipal
)
;
}
}
current
=
next
;
next
=
MediaTrackGraphImpl
:
:
RoundUpToEndOfAudioBlock
(
3
*
frames
)
;
ASSERT_NE
(
current
next
)
;
DispatchFunction
(
[
&
]
{
track
-
>
StopAudio
(
)
;
}
)
;
Unused
<
<
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
track
-
>
ProcessInput
(
current
next
flags
)
;
{
AudioSegment
data
;
data
.
AppendSlice
(
*
track
-
>
GetData
<
AudioSegment
>
(
)
current
next
)
;
EXPECT_TRUE
(
data
.
IsNull
(
)
)
;
}
track
-
>
Destroy
(
)
;
mGraph
-
>
RemoveTrackGraphThread
(
track
)
;
}
TEST_F
(
TestDeviceInputTrack
NonNativeDeviceChangedCallback
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
const
AudioInputSource
:
:
Id
sourceId
=
1
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
const
uint32_t
channels
=
2
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
const
TrackRate
rate
=
48000
;
const
uint32_t
bufferingMs
=
StaticPrefs
:
:
media_clockdrift_buffering
(
)
;
RefPtr
<
NonNativeInputTrack
>
track
=
new
NonNativeInputTrack
(
mGraph
-
>
GraphRate
(
)
deviceId
testPrincipal
)
;
mGraph
-
>
AddTrack
(
track
)
;
auto
listener
=
MakeRefPtr
<
MockEventListener
>
(
)
;
EXPECT_CALL
(
*
listener
AudioDeviceChanged
(
sourceId
)
)
;
EXPECT_CALL
(
*
listener
AudioStateCallback
(
sourceId
AudioInputSource
:
:
EventListener
:
:
State
:
:
Started
)
)
;
EXPECT_CALL
(
*
listener
AudioStateCallback
(
sourceId
AudioInputSource
:
:
EventListener
:
:
State
:
:
Stopped
)
)
.
Times
(
2
)
;
DispatchFunction
(
[
&
]
{
track
-
>
StartAudio
(
MakeRefPtr
<
AudioInputSource
>
(
std
:
:
move
(
listener
)
sourceId
deviceId
channels
true
testPrincipal
rate
mGraph
-
>
GraphRate
(
)
bufferingMs
)
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
EXPECT_FALSE
(
stream
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream
-
>
GetInputDeviceID
(
)
deviceId
)
;
EXPECT_EQ
(
stream
-
>
InputChannels
(
)
channels
)
;
EXPECT_EQ
(
stream
-
>
InputSampleRate
(
)
static_cast
<
uint32_t
>
(
rate
)
)
;
Unused
<
<
WaitFor
(
stream
-
>
FramesProcessedEvent
(
)
)
;
DispatchFunction
(
[
&
]
{
stream
-
>
ForceDeviceChanged
(
)
;
}
)
;
WaitFor
(
stream
-
>
DeviceChangeForcedEvent
(
)
)
;
DispatchFunction
(
[
&
]
{
track
-
>
StopAudio
(
)
;
}
)
;
Unused
<
<
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
track
-
>
Destroy
(
)
;
mGraph
-
>
RemoveTrackGraphThread
(
track
)
;
}
TEST_F
(
TestDeviceInputTrack
NonNativeErrorCallback
)
{
MockCubeb
*
cubeb
=
new
MockCubeb
(
)
;
CubebUtils
:
:
ForceSetCubebContext
(
cubeb
-
>
AsCubebContext
(
)
)
;
const
AudioInputSource
:
:
Id
sourceId
=
1
;
const
CubebUtils
:
:
AudioDeviceID
deviceId
=
(
CubebUtils
:
:
AudioDeviceID
)
1
;
const
uint32_t
channels
=
2
;
const
PrincipalHandle
testPrincipal
=
MakePrincipalHandle
(
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
const
TrackRate
rate
=
48000
;
const
uint32_t
bufferingMs
=
StaticPrefs
:
:
media_clockdrift_buffering
(
)
;
RefPtr
<
NonNativeInputTrack
>
track
=
new
NonNativeInputTrack
(
mGraph
-
>
GraphRate
(
)
deviceId
testPrincipal
)
;
mGraph
-
>
AddTrack
(
track
)
;
auto
listener
=
MakeRefPtr
<
MockEventListener
>
(
)
;
EXPECT_CALL
(
*
listener
AudioStateCallback
(
sourceId
AudioInputSource
:
:
EventListener
:
:
State
:
:
Started
)
)
;
EXPECT_CALL
(
*
listener
AudioStateCallback
(
sourceId
AudioInputSource
:
:
EventListener
:
:
State
:
:
Error
)
)
;
EXPECT_CALL
(
*
listener
AudioStateCallback
(
sourceId
AudioInputSource
:
:
EventListener
:
:
State
:
:
Stopped
)
)
;
DispatchFunction
(
[
&
]
{
track
-
>
StartAudio
(
MakeRefPtr
<
AudioInputSource
>
(
std
:
:
move
(
listener
)
sourceId
deviceId
channels
true
testPrincipal
rate
mGraph
-
>
GraphRate
(
)
bufferingMs
)
)
;
}
)
;
RefPtr
<
SmartMockCubebStream
>
stream
=
WaitFor
(
cubeb
-
>
StreamInitEvent
(
)
)
;
EXPECT_TRUE
(
stream
-
>
mHasInput
)
;
EXPECT_FALSE
(
stream
-
>
mHasOutput
)
;
EXPECT_EQ
(
stream
-
>
GetInputDeviceID
(
)
deviceId
)
;
EXPECT_EQ
(
stream
-
>
InputChannels
(
)
channels
)
;
EXPECT_EQ
(
stream
-
>
InputSampleRate
(
)
static_cast
<
uint32_t
>
(
rate
)
)
;
Unused
<
<
WaitFor
(
stream
-
>
FramesProcessedEvent
(
)
)
;
DispatchFunction
(
[
&
]
{
stream
-
>
ForceError
(
)
;
}
)
;
WaitFor
(
stream
-
>
ErrorForcedEvent
(
)
)
;
WaitFor
(
stream
-
>
ErrorStoppedEvent
(
)
)
;
DispatchFunction
(
[
&
]
{
track
-
>
StopAudio
(
)
;
}
)
;
Unused
<
<
WaitFor
(
cubeb
-
>
StreamDestroyEvent
(
)
)
;
track
-
>
Destroy
(
)
;
mGraph
-
>
RemoveTrackGraphThread
(
track
)
;
}
