#
ifndef
MOZILLA_AUDIO_DRIFT_CORRECTION_H_
#
define
MOZILLA_AUDIO_DRIFT_CORRECTION_H_
#
include
"
DynamicResampler
.
h
"
namespace
mozilla
{
class
ClockDrift
final
{
public
:
ClockDrift
(
int32_t
aSourceRate
int32_t
aTargetRate
int32_t
aDesiredBuffering
)
:
mSourceRate
(
aSourceRate
)
mTargetRate
(
aTargetRate
)
mDesiredBuffering
(
aDesiredBuffering
)
{
}
float
GetCorrection
(
)
{
return
mCorrection
;
}
void
UpdateClock
(
int
aSourceFrames
int
aTargetFrames
int
aBufferedFrames
)
{
if
(
(
mTargetClock
*
1000
/
mTargetRate
)
>
=
mAdjustmentIntervalMs
|
|
(
mSourceClock
*
1000
/
mSourceRate
)
>
=
mAdjustmentIntervalMs
)
{
CalculateCorrection
(
aBufferedFrames
)
;
}
else
if
(
aBufferedFrames
<
2
*
mSourceRate
/
100
)
{
BufferedFramesCorrection
(
aBufferedFrames
)
;
}
mTargetClock
+
=
aTargetFrames
;
mSourceClock
+
=
aSourceFrames
;
}
private
:
void
CalculateCorrection
(
int
aBufferedFrames
)
{
int32_t
bufferedFramesDiff
=
aBufferedFrames
-
mDesiredBuffering
;
int32_t
resampledSourceClock
=
std
:
:
max
(
1
mSourceClock
+
bufferedFramesDiff
)
;
if
(
mTargetRate
!
=
mSourceRate
)
{
resampledSourceClock
=
resampledSourceClock
*
(
static_cast
<
float
>
(
mTargetRate
)
/
static_cast
<
float
>
(
mSourceRate
)
)
;
}
mCorrection
=
static_cast
<
float
>
(
mTargetClock
)
/
resampledSourceClock
;
mCorrection
=
std
:
:
min
(
std
:
:
max
(
mCorrection
0
.
9f
)
1
.
1f
)
;
if
(
mPreviousCorrection
-
mCorrection
<
=
0
.
01
&
&
mPreviousCorrection
-
mCorrection
>
0
)
{
mCorrection
=
mPreviousCorrection
;
}
mPreviousCorrection
=
mCorrection
;
mTargetClock
=
0
;
mSourceClock
=
0
;
}
void
BufferedFramesCorrection
(
int
aBufferedFrames
)
{
int32_t
bufferedFramesDiff
=
aBufferedFrames
-
mDesiredBuffering
;
int32_t
resampledSourceClock
=
std
:
:
max
(
1
mSourceRate
+
bufferedFramesDiff
)
;
if
(
mTargetRate
!
=
mSourceRate
)
{
resampledSourceClock
=
resampledSourceClock
*
(
static_cast
<
float
>
(
mTargetRate
)
/
mSourceRate
)
;
}
MOZ_ASSERT
(
mTargetRate
>
resampledSourceClock
)
;
mPreviousCorrection
=
mCorrection
;
mCorrection
+
=
static_cast
<
float
>
(
mTargetRate
)
/
resampledSourceClock
-
1
.
0f
;
mCorrection
=
std
:
:
min
(
std
:
:
max
(
mCorrection
0
.
9f
)
1
.
1f
)
;
}
public
:
const
int32_t
mSourceRate
;
const
int32_t
mTargetRate
;
const
int32_t
mAdjustmentIntervalMs
=
1000
;
const
int32_t
mDesiredBuffering
;
private
:
float
mCorrection
=
1
.
0
;
float
mPreviousCorrection
=
1
.
0
;
int32_t
mSourceClock
=
0
;
int32_t
mTargetClock
=
0
;
}
;
class
AudioDriftCorrection
final
{
public
:
AudioDriftCorrection
(
int32_t
aSourceRate
int32_t
aTargetRate
)
:
mDesiredBuffering
(
std
:
:
max
(
5
Preferences
:
:
GetInt
(
"
media
.
clockdrift
.
buffering
"
50
)
)
*
aSourceRate
/
1000
)
mTargetRate
(
aTargetRate
)
mClockDrift
(
aSourceRate
aTargetRate
mDesiredBuffering
)
mResampler
(
aSourceRate
aTargetRate
mDesiredBuffering
)
{
}
AudioSegment
RequestFrames
(
const
AudioSegment
&
aInput
int32_t
aOutputFrames
)
{
if
(
aInput
.
GetDuration
(
)
)
{
mResampler
.
AppendInput
(
aInput
)
;
}
mClockDrift
.
UpdateClock
(
aInput
.
GetDuration
(
)
aOutputFrames
mResampler
.
InputDuration
(
)
)
;
TrackRate
receivingRate
=
mTargetRate
*
mClockDrift
.
GetCorrection
(
)
;
mResampler
.
UpdateOutRate
(
receivingRate
)
;
AudioSegment
output
=
mResampler
.
Resample
(
aOutputFrames
)
;
if
(
output
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
Got
nothing
from
the
resampler
"
)
;
output
.
AppendNullData
(
aOutputFrames
)
;
}
return
output
;
}
uint32_t
CurrentBuffering
(
)
const
{
return
mResampler
.
InputDuration
(
)
;
}
const
int32_t
mDesiredBuffering
;
const
int32_t
mTargetRate
;
private
:
ClockDrift
mClockDrift
;
AudioResampler
mResampler
;
}
;
}
;
#
endif
