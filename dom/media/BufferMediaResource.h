#
if
!
defined
(
BufferMediaResource_h_
)
#
define
BufferMediaResource_h_
#
include
"
MediaResource
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
class
BufferMediaResource
:
public
MediaResource
{
public
:
BufferMediaResource
(
const
uint8_t
*
aBuffer
uint32_t
aLength
)
:
mBuffer
(
aBuffer
)
mLength
(
aLength
)
mOffset
(
0
)
{
}
protected
:
virtual
~
BufferMediaResource
(
)
{
}
private
:
nsresult
ReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
override
{
if
(
aOffset
<
0
|
|
aOffset
>
mLength
)
{
return
NS_ERROR_FAILURE
;
}
*
aBytes
=
std
:
:
min
(
mLength
-
static_cast
<
uint32_t
>
(
aOffset
)
aCount
)
;
memcpy
(
aBuffer
mBuffer
+
aOffset
*
aBytes
)
;
mOffset
=
aOffset
+
*
aBytes
;
return
NS_OK
;
}
bool
ShouldCacheReads
(
)
override
{
return
false
;
}
int64_t
Tell
(
)
override
{
return
mOffset
;
}
void
Pin
(
)
override
{
}
void
Unpin
(
)
override
{
}
int64_t
GetLength
(
)
override
{
return
mLength
;
}
int64_t
GetNextCachedData
(
int64_t
aOffset
)
override
{
return
aOffset
;
}
int64_t
GetCachedDataEnd
(
int64_t
aOffset
)
override
{
return
std
:
:
max
(
aOffset
int64_t
(
mLength
)
)
;
}
bool
IsDataCachedToEndOfResource
(
int64_t
aOffset
)
override
{
return
true
;
}
nsresult
ReadFromCache
(
char
*
aBuffer
int64_t
aOffset
uint32_t
aCount
)
override
{
if
(
aOffset
<
0
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
bytes
=
std
:
:
min
(
mLength
-
static_cast
<
uint32_t
>
(
aOffset
)
aCount
)
;
memcpy
(
aBuffer
mBuffer
+
aOffset
bytes
)
;
return
NS_OK
;
}
nsresult
GetCachedRanges
(
MediaByteRangeSet
&
aRanges
)
override
{
aRanges
+
=
MediaByteRange
(
0
int64_t
(
mLength
)
)
;
return
NS_OK
;
}
private
:
const
uint8_t
*
mBuffer
;
uint32_t
mLength
;
uint32_t
mOffset
;
}
;
}
#
endif
