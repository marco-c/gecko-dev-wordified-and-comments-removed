#
ifndef
BOX_H_
#
define
BOX_H_
#
include
<
stdint
.
h
>
#
include
"
nsTArray
.
h
"
#
include
"
MediaResource
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
AtomType
.
h
"
#
include
"
BufferReader
.
h
"
namespace
mozilla
{
class
ByteStream
;
class
BumpAllocator
{
public
:
uint8_t
*
Allocate
(
size_t
aNumBytes
)
;
private
:
nsTArray
<
nsTArray
<
uint8_t
>
>
mBuffers
;
}
;
class
BoxContext
{
public
:
BoxContext
(
ByteStream
*
aSource
const
MediaByteRangeSet
&
aByteRanges
)
:
mSource
(
aSource
)
mByteRanges
(
aByteRanges
)
{
}
RefPtr
<
ByteStream
>
mSource
;
const
MediaByteRangeSet
&
mByteRanges
;
BumpAllocator
mAllocator
;
}
;
struct
ByteSlice
{
const
uint8_t
*
mBytes
;
size_t
mSize
;
}
;
class
Box
{
public
:
Box
(
BoxContext
*
aContext
uint64_t
aOffset
const
Box
*
aParent
=
nullptr
)
;
Box
(
)
;
bool
IsAvailable
(
)
const
{
return
!
mRange
.
IsEmpty
(
)
;
}
uint64_t
Offset
(
)
const
{
return
mRange
.
mStart
;
}
uint64_t
Length
(
)
const
{
return
mRange
.
mEnd
-
mRange
.
mStart
;
}
uint64_t
NextOffset
(
)
const
{
return
mRange
.
mEnd
;
}
const
MediaByteRange
&
Range
(
)
const
{
return
mRange
;
}
const
Box
*
Parent
(
)
const
{
return
mParent
;
}
bool
IsType
(
const
char
*
aType
)
const
{
return
mType
=
=
AtomType
(
aType
)
;
}
Box
Next
(
)
const
;
Box
FirstChild
(
)
const
;
nsTArray
<
uint8_t
>
Read
(
)
const
;
nsTArray
<
uint8_t
>
ReadCompleteBox
(
)
const
;
bool
Read
(
nsTArray
<
uint8_t
>
*
aDest
const
MediaByteRange
&
aRange
)
const
;
static
const
uint64_t
kMAX_BOX_READ
;
ByteSlice
ReadAsSlice
(
)
;
private
:
bool
Contains
(
MediaByteRange
aRange
)
const
;
BoxContext
*
mContext
;
mozilla
:
:
MediaByteRange
mRange
;
uint64_t
mBodyOffset
;
uint64_t
mChildOffset
;
AtomType
mType
;
const
Box
*
mParent
;
}
;
class
MOZ_RAII
BoxReader
{
public
:
explicit
BoxReader
(
Box
&
aBox
)
:
mData
(
aBox
.
ReadAsSlice
(
)
)
mReader
(
mData
.
mBytes
mData
.
mSize
)
{
}
BufferReader
*
operator
-
>
(
)
{
return
&
mReader
;
}
private
:
ByteSlice
mData
;
BufferReader
mReader
;
}
;
}
#
endif
