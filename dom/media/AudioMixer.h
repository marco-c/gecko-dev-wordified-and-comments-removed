#
ifndef
MOZILLA_AUDIOMIXER_H_
#
define
MOZILLA_AUDIOMIXER_H_
#
include
"
AudioSampleFormat
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
AudioStream
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
namespace
mozilla
{
struct
MixerCallbackReceiver
{
virtual
void
MixerCallback
(
AudioChunk
*
aMixedBuffer
uint32_t
aSampleRate
)
=
0
;
}
;
class
AudioMixer
{
public
:
AudioMixer
(
)
{
mChunk
.
mBufferFormat
=
AUDIO_OUTPUT_FORMAT
;
}
~
AudioMixer
(
)
{
MixerCallback
*
cb
;
while
(
(
cb
=
mCallbacks
.
popFirst
(
)
)
)
{
delete
cb
;
}
}
void
StartMixing
(
)
{
mChunk
.
mDuration
=
0
;
mSampleRate
=
0
;
}
void
FinishMixing
(
)
{
MOZ_ASSERT
(
mSampleRate
"
Mix
not
called
for
this
cycle
?
"
)
;
for
(
MixerCallback
*
cb
=
mCallbacks
.
getFirst
(
)
;
cb
!
=
nullptr
;
cb
=
cb
-
>
getNext
(
)
)
{
MixerCallbackReceiver
*
receiver
=
cb
-
>
mReceiver
;
MOZ_ASSERT
(
receiver
)
;
receiver
-
>
MixerCallback
(
&
mChunk
mSampleRate
)
;
}
mChunk
.
mDuration
=
0
;
mSampleRate
=
0
;
}
void
Mix
(
AudioDataValue
*
aSamples
uint32_t
aChannels
uint32_t
aFrames
uint32_t
aSampleRate
)
{
if
(
!
mChunk
.
mDuration
)
{
mChunk
.
mDuration
=
aFrames
;
MOZ_ASSERT
(
aChannels
>
0
)
;
mChunk
.
mChannelData
.
SetLength
(
aChannels
)
;
mSampleRate
=
aSampleRate
;
EnsureCapacityAndSilence
(
)
;
}
MOZ_ASSERT
(
aFrames
=
=
mChunk
.
mDuration
)
;
MOZ_ASSERT
(
aChannels
=
=
mChunk
.
ChannelCount
(
)
)
;
MOZ_ASSERT
(
aSampleRate
=
=
mSampleRate
)
;
if
(
!
aSamples
)
{
return
;
}
for
(
uint32_t
i
=
0
;
i
<
aFrames
*
aChannels
;
i
+
+
)
{
mChunk
.
ChannelDataForWrite
<
AudioDataValue
>
(
0
)
[
i
]
+
=
aSamples
[
i
]
;
}
}
void
AddCallback
(
NotNull
<
MixerCallbackReceiver
*
>
aReceiver
)
{
mCallbacks
.
insertBack
(
new
MixerCallback
(
aReceiver
)
)
;
}
bool
FindCallback
(
MixerCallbackReceiver
*
aReceiver
)
{
for
(
MixerCallback
*
cb
=
mCallbacks
.
getFirst
(
)
;
cb
!
=
nullptr
;
cb
=
cb
-
>
getNext
(
)
)
{
if
(
cb
-
>
mReceiver
=
=
aReceiver
)
{
return
true
;
}
}
return
false
;
}
bool
RemoveCallback
(
MixerCallbackReceiver
*
aReceiver
)
{
for
(
MixerCallback
*
cb
=
mCallbacks
.
getFirst
(
)
;
cb
!
=
nullptr
;
cb
=
cb
-
>
getNext
(
)
)
{
if
(
cb
-
>
mReceiver
=
=
aReceiver
)
{
cb
-
>
remove
(
)
;
delete
cb
;
return
true
;
}
}
return
false
;
}
private
:
void
EnsureCapacityAndSilence
(
)
{
uint32_t
sampleCount
=
mChunk
.
mDuration
*
mChunk
.
ChannelCount
(
)
;
if
(
!
mChunk
.
mBuffer
|
|
sampleCount
>
mSampleCapacity
)
{
CheckedInt
<
size_t
>
bufferSize
(
sizeof
(
AudioDataValue
)
)
;
bufferSize
*
=
sampleCount
;
mChunk
.
mBuffer
=
SharedBuffer
:
:
Create
(
bufferSize
)
;
mSampleCapacity
=
sampleCount
;
}
MOZ_ASSERT
(
!
mChunk
.
mBuffer
-
>
IsShared
(
)
)
;
mChunk
.
mChannelData
[
0
]
=
static_cast
<
SharedBuffer
*
>
(
mChunk
.
mBuffer
.
get
(
)
)
-
>
Data
(
)
;
for
(
size_t
i
=
1
;
i
<
mChunk
.
ChannelCount
(
)
;
+
+
i
)
{
mChunk
.
mChannelData
[
i
]
=
mChunk
.
ChannelData
<
AudioDataValue
>
(
)
[
0
]
+
i
*
mChunk
.
mDuration
;
}
PodZero
(
mChunk
.
ChannelDataForWrite
<
AudioDataValue
>
(
0
)
sampleCount
)
;
}
class
MixerCallback
:
public
LinkedListElement
<
MixerCallback
>
{
public
:
explicit
MixerCallback
(
NotNull
<
MixerCallbackReceiver
*
>
aReceiver
)
:
mReceiver
(
aReceiver
)
{
}
NotNull
<
MixerCallbackReceiver
*
>
mReceiver
;
}
;
LinkedList
<
MixerCallback
>
mCallbacks
;
AudioChunk
mChunk
;
uint32_t
mSampleCapacity
=
0
;
uint32_t
mSampleRate
=
0
;
}
;
}
#
endif
