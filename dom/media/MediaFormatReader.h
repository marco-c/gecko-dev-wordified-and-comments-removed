#
if
!
defined
(
MediaFormatReader_h_
)
#
define
MediaFormatReader_h_
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaDataDemuxer
.
h
"
#
include
"
MediaDecoderReader
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
PDMFactory
.
h
"
namespace
mozilla
{
class
CDMProxy
;
class
MediaFormatReader
final
:
public
MediaDecoderReader
{
typedef
TrackInfo
:
:
TrackType
TrackType
;
typedef
MozPromise
<
bool
MediaResult
true
>
NotifyDataArrivedPromise
;
public
:
MediaFormatReader
(
AbstractMediaDecoder
*
aDecoder
MediaDataDemuxer
*
aDemuxer
VideoFrameContainer
*
aVideoFrameContainer
=
nullptr
)
;
virtual
~
MediaFormatReader
(
)
;
size_t
SizeOfVideoQueueInFrames
(
)
override
;
size_t
SizeOfAudioQueueInFrames
(
)
override
;
RefPtr
<
MediaDataPromise
>
RequestVideoData
(
bool
aSkipToNextKeyframe
int64_t
aTimeThreshold
)
override
;
RefPtr
<
MediaDataPromise
>
RequestAudioData
(
)
override
;
RefPtr
<
MetadataPromise
>
AsyncReadMetadata
(
)
override
;
void
ReadUpdatedMetadata
(
MediaInfo
*
aInfo
)
override
;
RefPtr
<
SeekPromise
>
Seek
(
const
SeekTarget
&
aTarget
)
override
;
protected
:
void
NotifyDataArrived
(
)
override
;
void
UpdateBuffered
(
)
override
;
public
:
void
ReleaseResources
(
)
override
;
nsresult
ResetDecode
(
TrackSet
aTracks
)
override
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
bool
IsAsync
(
)
const
override
{
return
true
;
}
bool
VideoIsHardwareAccelerated
(
)
const
override
;
bool
IsWaitForDataSupported
(
)
const
override
{
return
true
;
}
RefPtr
<
WaitForDataPromise
>
WaitForData
(
MediaData
:
:
Type
aType
)
override
;
bool
UseBufferingHeuristics
(
)
const
override
{
return
mTrackDemuxersMayBlock
;
}
void
SetCDMProxy
(
CDMProxy
*
aProxy
)
override
;
void
GetMozDebugReaderData
(
nsACString
&
aString
)
;
void
SetVideoBlankDecode
(
bool
aIsBlankDecode
)
override
;
private
:
nsresult
InitInternal
(
)
override
;
bool
HasVideo
(
)
const
{
return
mVideo
.
mTrackDemuxer
;
}
bool
HasAudio
(
)
const
{
return
mAudio
.
mTrackDemuxer
;
}
bool
IsWaitingOnCDMResource
(
)
;
bool
InitDemuxer
(
)
;
void
NotifyTrackDemuxers
(
)
;
void
ReturnOutput
(
MediaData
*
aData
TrackType
aTrack
)
;
void
ScheduleUpdate
(
TrackType
aTrack
)
;
void
Update
(
TrackType
aTrack
)
;
bool
UpdateReceivedNewData
(
TrackType
aTrack
)
;
void
RequestDemuxSamples
(
TrackType
aTrack
)
;
void
HandleDemuxedSamples
(
TrackType
aTrack
AbstractMediaDecoder
:
:
AutoNotifyDecoded
&
aA
)
;
void
DecodeDemuxedSamples
(
TrackType
aTrack
MediaRawData
*
aSample
)
;
struct
InternalSeekTarget
{
InternalSeekTarget
(
const
media
:
:
TimeInterval
&
aTime
bool
aDropTarget
)
:
mTime
(
aTime
)
mDropTarget
(
aDropTarget
)
mWaiting
(
false
)
mHasSeeked
(
false
)
{
}
media
:
:
TimeUnit
Time
(
)
const
{
return
mTime
.
mStart
;
}
media
:
:
TimeUnit
EndTime
(
)
const
{
return
mTime
.
mEnd
;
}
bool
Contains
(
const
media
:
:
TimeUnit
&
aTime
)
const
{
return
mTime
.
Contains
(
aTime
)
;
}
media
:
:
TimeInterval
mTime
;
bool
mDropTarget
;
bool
mWaiting
;
bool
mHasSeeked
;
}
;
void
InternalSeek
(
TrackType
aTrack
const
InternalSeekTarget
&
aTarget
)
;
void
DrainDecoder
(
TrackType
aTrack
)
;
void
NotifyNewOutput
(
TrackType
aTrack
const
MediaDataDecoder
:
:
DecodedData
&
aResults
)
;
void
NotifyError
(
TrackType
aTrack
const
MediaResult
&
aError
)
;
void
NotifyWaitingForData
(
TrackType
aTrack
)
;
void
NotifyWaitingForKey
(
TrackType
aTrack
)
;
void
NotifyEndOfStream
(
TrackType
aTrack
)
;
void
ExtractCryptoInitData
(
nsTArray
<
uint8_t
>
&
aInitData
)
;
void
InitLayersBackendType
(
)
;
void
Reset
(
TrackType
aTrack
)
;
void
DropDecodedSamples
(
TrackType
aTrack
)
;
bool
ShouldSkip
(
bool
aSkipToNextKeyframe
media
:
:
TimeUnit
aTimeThreshold
)
;
void
SetVideoDecodeThreshold
(
)
;
size_t
SizeOfQueue
(
TrackType
aTrack
)
;
RefPtr
<
PDMFactory
>
mPlatform
;
enum
class
DrainState
{
None
DrainRequested
Draining
PartialDrainPending
DrainCompleted
DrainAborted
}
;
struct
DecoderData
{
DecoderData
(
MediaFormatReader
*
aOwner
MediaData
:
:
Type
aType
uint32_t
aNumOfMaxError
)
:
mOwner
(
aOwner
)
mType
(
aType
)
mMutex
(
"
DecoderData
"
)
mDescription
(
"
shutdown
"
)
mUpdateScheduled
(
false
)
mDemuxEOS
(
false
)
mWaitingForData
(
false
)
mWaitingForKey
(
false
)
mReceivedNewData
(
false
)
mFlushed
(
true
)
mDrainState
(
DrainState
:
:
None
)
mNumOfConsecutiveError
(
0
)
mMaxConsecutiveError
(
aNumOfMaxError
)
mNumSamplesInput
(
0
)
mNumSamplesOutput
(
0
)
mNumSamplesOutputTotal
(
0
)
mNumSamplesSkippedTotal
(
0
)
mSizeOfQueue
(
0
)
mIsHardwareAccelerated
(
false
)
mLastStreamSourceID
(
UINT32_MAX
)
mIsBlankDecode
(
false
)
{
}
MediaFormatReader
*
mOwner
;
MediaData
:
:
Type
mType
;
RefPtr
<
MediaTrackDemuxer
>
mTrackDemuxer
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
Mutex
mMutex
;
RefPtr
<
MediaDataDecoder
>
mDecoder
;
const
char
*
mDescription
;
void
ShutdownDecoder
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mDecoder
)
{
RefPtr
<
MediaFormatReader
>
owner
=
mOwner
;
TrackType
type
=
mType
=
=
MediaData
:
:
AUDIO_DATA
?
TrackType
:
:
kAudioTrack
:
TrackType
:
:
kVideoTrack
;
mDecoder
-
>
Shutdown
(
)
-
>
Then
(
mOwner
-
>
OwnerThread
(
)
__func__
[
owner
this
type
]
(
)
{
mShutdownRequest
.
Complete
(
)
;
mShutdownPromise
.
ResolveIfExists
(
true
__func__
)
;
owner
-
>
ScheduleUpdate
(
type
)
;
}
[
]
(
)
{
MOZ_RELEASE_ASSERT
(
false
"
Can
'
t
ever
be
here
"
)
;
}
)
-
>
Track
(
mShutdownRequest
)
;
}
mDescription
=
"
shutdown
"
;
mDecoder
=
nullptr
;
}
bool
mUpdateScheduled
;
bool
mDemuxEOS
;
bool
mWaitingForData
;
bool
mWaitingForKey
;
bool
mReceivedNewData
;
MozPromiseRequestHolder
<
MediaTrackDemuxer
:
:
SeekPromise
>
mSeekRequest
;
nsTArray
<
RefPtr
<
MediaRawData
>
>
mQueuedSamples
;
MozPromiseRequestHolder
<
MediaTrackDemuxer
:
:
SamplesPromise
>
mDemuxRequest
;
MozPromiseHolder
<
WaitForDataPromise
>
mWaitingPromise
;
bool
HasWaitingPromise
(
)
const
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
return
!
mWaitingPromise
.
IsEmpty
(
)
;
}
bool
IsWaiting
(
)
const
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
return
mWaitingForData
|
|
mWaitingForKey
;
}
MozPromiseRequestHolder
<
MediaDataDecoder
:
:
DecodePromise
>
mDecodeRequest
;
MozPromiseRequestHolder
<
MediaDataDecoder
:
:
FlushPromise
>
mFlushRequest
;
bool
mFlushed
;
MozPromiseHolder
<
ShutdownPromise
>
mShutdownPromise
;
MozPromiseRequestHolder
<
ShutdownPromise
>
mShutdownRequest
;
MozPromiseRequestHolder
<
MediaDataDecoder
:
:
DecodePromise
>
mDrainRequest
;
DrainState
mDrainState
;
bool
HasPendingDrain
(
)
const
{
return
mDrainState
!
=
DrainState
:
:
None
;
}
void
RequestDrain
(
)
{
MOZ_RELEASE_ASSERT
(
mDrainState
=
=
DrainState
:
:
None
)
;
mDrainState
=
DrainState
:
:
DrainRequested
;
}
uint32_t
mNumOfConsecutiveError
;
uint32_t
mMaxConsecutiveError
;
Maybe
<
MediaResult
>
mError
;
bool
HasFatalError
(
)
const
{
if
(
!
mError
.
isSome
(
)
)
{
return
false
;
}
if
(
mError
.
ref
(
)
=
=
NS_ERROR_DOM_MEDIA_DECODE_ERR
)
{
return
mNumOfConsecutiveError
>
mMaxConsecutiveError
;
}
else
if
(
mError
.
ref
(
)
=
=
NS_ERROR_DOM_MEDIA_NEED_NEW_DECODER
)
{
return
false
;
}
else
{
return
true
;
}
}
Maybe
<
InternalSeekTarget
>
mTimeThreshold
;
Maybe
<
media
:
:
TimeInterval
>
mLastSampleTime
;
nsTArray
<
RefPtr
<
MediaData
>
>
mOutput
;
uint64_t
mNumSamplesInput
;
uint64_t
mNumSamplesOutput
;
uint64_t
mNumSamplesOutputTotal
;
uint64_t
mNumSamplesSkippedTotal
;
virtual
bool
HasPromise
(
)
const
=
0
;
virtual
RefPtr
<
MediaDataPromise
>
EnsurePromise
(
const
char
*
aMethodName
)
=
0
;
virtual
void
ResolvePromise
(
MediaData
*
aData
const
char
*
aMethodName
)
=
0
;
virtual
void
RejectPromise
(
const
MediaResult
&
aError
const
char
*
aMethodName
)
=
0
;
void
ResetDemuxer
(
)
{
mDemuxRequest
.
DisconnectIfExists
(
)
;
mSeekRequest
.
DisconnectIfExists
(
)
;
mTrackDemuxer
-
>
Reset
(
)
;
mQueuedSamples
.
Clear
(
)
;
}
void
Flush
(
)
{
if
(
mFlushRequest
.
Exists
(
)
|
|
mFlushed
)
{
return
;
}
mDecodeRequest
.
DisconnectIfExists
(
)
;
mDrainRequest
.
DisconnectIfExists
(
)
;
mDrainState
=
DrainState
:
:
None
;
CancelWaitingForKey
(
)
;
mOutput
.
Clear
(
)
;
mNumSamplesInput
=
0
;
mNumSamplesOutput
=
0
;
mSizeOfQueue
=
0
;
if
(
mDecoder
&
&
!
mFlushed
)
{
RefPtr
<
MediaFormatReader
>
owner
=
mOwner
;
TrackType
type
=
mType
=
=
MediaData
:
:
AUDIO_DATA
?
TrackType
:
:
kAudioTrack
:
TrackType
:
:
kVideoTrack
;
mDecoder
-
>
Flush
(
)
-
>
Then
(
mOwner
-
>
OwnerThread
(
)
__func__
[
owner
type
this
]
(
)
{
mFlushRequest
.
Complete
(
)
;
if
(
!
mShutdownPromise
.
IsEmpty
(
)
)
{
ShutdownDecoder
(
)
;
return
;
}
owner
-
>
ScheduleUpdate
(
type
)
;
}
[
owner
type
this
]
(
const
MediaResult
&
aError
)
{
mFlushRequest
.
Complete
(
)
;
if
(
!
mShutdownPromise
.
IsEmpty
(
)
)
{
ShutdownDecoder
(
)
;
return
;
}
owner
-
>
NotifyError
(
type
aError
)
;
}
)
-
>
Track
(
mFlushRequest
)
;
}
mFlushed
=
true
;
}
bool
CancelWaitingForKey
(
)
{
if
(
!
mWaitingForKey
)
{
return
false
;
}
mWaitingForKey
=
false
;
if
(
IsWaiting
(
)
|
|
!
HasWaitingPromise
(
)
)
{
return
false
;
}
mWaitingPromise
.
Resolve
(
mType
__func__
)
;
return
true
;
}
void
ResetState
(
)
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
mDemuxEOS
=
false
;
mWaitingForData
=
false
;
mQueuedSamples
.
Clear
(
)
;
mDecodeRequest
.
DisconnectIfExists
(
)
;
mDrainRequest
.
DisconnectIfExists
(
)
;
mDrainState
=
DrainState
:
:
None
;
CancelWaitingForKey
(
)
;
mTimeThreshold
.
reset
(
)
;
mLastSampleTime
.
reset
(
)
;
mOutput
.
Clear
(
)
;
mNumSamplesInput
=
0
;
mNumSamplesOutput
=
0
;
mSizeOfQueue
=
0
;
mNextStreamSourceID
.
reset
(
)
;
if
(
!
HasFatalError
(
)
)
{
mError
.
reset
(
)
;
}
}
bool
HasInternalSeekPending
(
)
const
{
return
mTimeThreshold
&
&
!
mTimeThreshold
.
ref
(
)
.
mHasSeeked
;
}
Atomic
<
size_t
>
mSizeOfQueue
;
Atomic
<
bool
>
mIsHardwareAccelerated
;
uint32_t
mLastStreamSourceID
;
Maybe
<
uint32_t
>
mNextStreamSourceID
;
media
:
:
TimeIntervals
mTimeRanges
;
Maybe
<
media
:
:
TimeUnit
>
mLastTimeRangesEnd
;
UniquePtr
<
TrackInfo
>
mOriginalInfo
;
RefPtr
<
TrackInfoSharedPtr
>
mInfo
;
Maybe
<
media
:
:
TimeUnit
>
mFirstDemuxedSampleTime
;
bool
mIsBlankDecode
;
}
;
class
DecoderDataWithPromise
:
public
DecoderData
{
public
:
DecoderDataWithPromise
(
MediaFormatReader
*
aOwner
MediaData
:
:
Type
aType
uint32_t
aNumOfMaxError
)
:
DecoderData
(
aOwner
aType
aNumOfMaxError
)
mHasPromise
(
false
)
{
}
bool
HasPromise
(
)
const
override
{
return
mHasPromise
;
}
RefPtr
<
MediaDataPromise
>
EnsurePromise
(
const
char
*
aMethodName
)
override
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
mHasPromise
=
true
;
return
mPromise
.
Ensure
(
aMethodName
)
;
}
void
ResolvePromise
(
MediaData
*
aData
const
char
*
aMethodName
)
override
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
mPromise
.
Resolve
(
aData
aMethodName
)
;
mHasPromise
=
false
;
}
void
RejectPromise
(
const
MediaResult
&
aError
const
char
*
aMethodName
)
override
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
mPromise
.
Reject
(
aError
aMethodName
)
;
mHasPromise
=
false
;
}
private
:
MozPromiseHolder
<
MediaDataPromise
>
mPromise
;
Atomic
<
bool
>
mHasPromise
;
}
;
DecoderDataWithPromise
mAudio
;
DecoderDataWithPromise
mVideo
;
bool
NeedInput
(
DecoderData
&
aDecoder
)
;
DecoderData
&
GetDecoderData
(
TrackType
aTrack
)
;
class
DemuxerProxy
;
UniquePtr
<
DemuxerProxy
>
mDemuxer
;
bool
mDemuxerInitDone
;
void
OnDemuxerInitDone
(
nsresult
)
;
void
OnDemuxerInitFailed
(
const
MediaResult
&
aError
)
;
MozPromiseRequestHolder
<
MediaDataDemuxer
:
:
InitPromise
>
mDemuxerInitRequest
;
MozPromiseRequestHolder
<
NotifyDataArrivedPromise
>
mNotifyDataArrivedPromise
;
void
OnDemuxFailed
(
TrackType
aTrack
const
MediaResult
&
aError
)
;
void
DoDemuxVideo
(
)
;
void
OnVideoDemuxCompleted
(
RefPtr
<
MediaTrackDemuxer
:
:
SamplesHolder
>
aSamples
)
;
void
OnVideoDemuxFailed
(
const
MediaResult
&
aError
)
{
OnDemuxFailed
(
TrackType
:
:
kVideoTrack
aError
)
;
}
void
DoDemuxAudio
(
)
;
void
OnAudioDemuxCompleted
(
RefPtr
<
MediaTrackDemuxer
:
:
SamplesHolder
>
aSamples
)
;
void
OnAudioDemuxFailed
(
const
MediaResult
&
aError
)
{
OnDemuxFailed
(
TrackType
:
:
kAudioTrack
aError
)
;
}
void
SkipVideoDemuxToNextKeyFrame
(
media
:
:
TimeUnit
aTimeThreshold
)
;
MozPromiseRequestHolder
<
MediaTrackDemuxer
:
:
SkipAccessPointPromise
>
mSkipRequest
;
void
VideoSkipReset
(
uint32_t
aSkipped
)
;
void
OnVideoSkipCompleted
(
uint32_t
aSkipped
)
;
void
OnVideoSkipFailed
(
MediaTrackDemuxer
:
:
SkipFailureHolder
aFailure
)
;
uint64_t
mLastReportedNumDecodedFrames
;
int64_t
mPreviousDecodedKeyframeTime_us
;
static
const
int64_t
sNoPreviousDecodedKeyframe
=
INT64_MAX
;
RefPtr
<
layers
:
:
KnowsCompositor
>
mKnowsCompositor
;
bool
mInitDone
;
MozPromiseHolder
<
MetadataPromise
>
mMetadataPromise
;
bool
IsEncrypted
(
)
const
;
bool
mTrackDemuxersMayBlock
;
void
SetSeekTarget
(
const
SeekTarget
&
aTarget
)
;
bool
IsSeeking
(
)
const
{
return
mPendingSeekTime
.
isSome
(
)
;
}
bool
IsVideoSeeking
(
)
const
{
return
IsSeeking
(
)
&
&
mOriginalSeekTarget
.
IsVideoOnly
(
)
;
}
void
ScheduleSeek
(
)
;
void
AttemptSeek
(
)
;
void
OnSeekFailed
(
TrackType
aTrack
const
MediaResult
&
aError
)
;
void
DoVideoSeek
(
)
;
void
OnVideoSeekCompleted
(
media
:
:
TimeUnit
aTime
)
;
void
OnVideoSeekFailed
(
const
MediaResult
&
aError
)
;
bool
mSeekScheduled
;
void
NotifyCompositorUpdated
(
RefPtr
<
layers
:
:
KnowsCompositor
>
aKnowsCompositor
)
{
mKnowsCompositor
=
aKnowsCompositor
.
forget
(
)
;
}
void
DoAudioSeek
(
)
;
void
OnAudioSeekCompleted
(
media
:
:
TimeUnit
aTime
)
;
void
OnAudioSeekFailed
(
const
MediaResult
&
aError
)
;
SeekTarget
mOriginalSeekTarget
;
Maybe
<
media
:
:
TimeUnit
>
mFallbackSeekTime
;
Maybe
<
media
:
:
TimeUnit
>
mPendingSeekTime
;
MozPromiseHolder
<
SeekPromise
>
mSeekPromise
;
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
layers
:
:
ImageContainer
*
GetImageContainer
(
)
;
RefPtr
<
CDMProxy
>
mCDMProxy
;
RefPtr
<
GMPCrashHelper
>
mCrashHelper
;
void
SetBlankDecode
(
TrackType
aTrack
bool
aIsBlankDecode
)
;
class
DecoderFactory
;
UniquePtr
<
DecoderFactory
>
mDecoderFactory
;
class
ShutdownPromisePool
;
UniquePtr
<
ShutdownPromisePool
>
mShutdownPromisePool
;
MediaEventListener
mCompositorUpdatedListener
;
MediaEventListener
mOnTrackWaitingForKeyListener
;
void
OnFirstDemuxCompleted
(
TrackInfo
:
:
TrackType
aType
RefPtr
<
MediaTrackDemuxer
:
:
SamplesHolder
>
aSamples
)
;
void
OnFirstDemuxFailed
(
TrackInfo
:
:
TrackType
aType
const
MediaResult
&
aError
)
;
void
MaybeResolveMetadataPromise
(
)
;
UniquePtr
<
MetadataTags
>
mTags
;
bool
mHasStartTime
=
false
;
void
ShutdownDecoder
(
TrackType
aTrack
)
;
RefPtr
<
ShutdownPromise
>
ShutdownDecoderWithPromise
(
TrackType
aTrack
)
;
RefPtr
<
ShutdownPromise
>
TearDownDecoders
(
)
;
}
;
}
#
endif
