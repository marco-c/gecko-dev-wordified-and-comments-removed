#
if
!
defined
(
MediaFormatReader_h_
)
#
define
MediaFormatReader_h_
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
MediaDataDemuxer
.
h
"
#
include
"
MediaDecoderReader
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
PDMFactory
.
h
"
namespace
mozilla
{
class
CDMProxy
;
class
MediaFormatReader
final
:
public
MediaDecoderReader
{
typedef
TrackInfo
:
:
TrackType
TrackType
;
public
:
MediaFormatReader
(
AbstractMediaDecoder
*
aDecoder
MediaDataDemuxer
*
aDemuxer
VideoFrameContainer
*
aVideoFrameContainer
=
nullptr
layers
:
:
LayersBackend
aLayersBackend
=
layers
:
:
LayersBackend
:
:
LAYERS_NONE
)
;
virtual
~
MediaFormatReader
(
)
;
nsresult
Init
(
)
override
;
size_t
SizeOfVideoQueueInFrames
(
)
override
;
size_t
SizeOfAudioQueueInFrames
(
)
override
;
RefPtr
<
MediaDataPromise
>
RequestVideoData
(
bool
aSkipToNextKeyframe
int64_t
aTimeThreshold
)
override
;
RefPtr
<
MediaDataPromise
>
RequestAudioData
(
)
override
;
RefPtr
<
MetadataPromise
>
AsyncReadMetadata
(
)
override
;
void
ReadUpdatedMetadata
(
MediaInfo
*
aInfo
)
override
;
RefPtr
<
SeekPromise
>
Seek
(
SeekTarget
aTarget
int64_t
aUnused
)
override
;
protected
:
void
NotifyDataArrivedInternal
(
)
override
;
public
:
media
:
:
TimeIntervals
GetBuffered
(
)
override
;
RefPtr
<
BufferedUpdatePromise
>
UpdateBufferedWithPromise
(
)
override
;
bool
ForceZeroStartTime
(
)
const
override
;
void
ReleaseMediaResources
(
)
override
;
nsresult
ResetDecode
(
TrackSet
aTracks
)
override
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
bool
IsAsync
(
)
const
override
{
return
true
;
}
bool
VideoIsHardwareAccelerated
(
)
const
override
;
bool
IsWaitForDataSupported
(
)
const
override
{
return
true
;
}
RefPtr
<
WaitForDataPromise
>
WaitForData
(
MediaData
:
:
Type
aType
)
override
;
bool
IsDemuxOnlySupported
(
)
const
override
{
return
true
;
}
void
SetDemuxOnly
(
bool
aDemuxedOnly
)
override
{
if
(
OnTaskQueue
(
)
)
{
mDemuxOnly
=
aDemuxedOnly
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
r
=
NewRunnableMethod
<
bool
>
(
this
&
MediaDecoderReader
:
:
SetDemuxOnly
aDemuxedOnly
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
bool
UseBufferingHeuristics
(
)
const
override
{
return
mTrackDemuxersMayBlock
;
}
#
ifdef
MOZ_EME
void
SetCDMProxy
(
CDMProxy
*
aProxy
)
override
;
#
endif
void
GetMozDebugReaderData
(
nsAString
&
aString
)
;
void
SetVideoBlankDecode
(
bool
aIsBlankDecode
)
override
;
private
:
bool
HasVideo
(
)
{
return
mVideo
.
mTrackDemuxer
;
}
bool
HasAudio
(
)
{
return
mAudio
.
mTrackDemuxer
;
}
bool
IsWaitingOnCDMResource
(
)
;
bool
InitDemuxer
(
)
;
void
NotifyDemuxer
(
)
;
void
ReturnOutput
(
MediaData
*
aData
TrackType
aTrack
)
;
bool
EnsureDecoderCreated
(
TrackType
aTrack
)
;
bool
EnsureDecoderInitialized
(
TrackType
aTrack
)
;
void
ScheduleUpdate
(
TrackType
aTrack
)
;
void
Update
(
TrackType
aTrack
)
;
bool
UpdateReceivedNewData
(
TrackType
aTrack
)
;
void
RequestDemuxSamples
(
TrackType
aTrack
)
;
void
HandleDemuxedSamples
(
TrackType
aTrack
AbstractMediaDecoder
:
:
AutoNotifyDecoded
&
aA
)
;
bool
DecodeDemuxedSamples
(
TrackType
aTrack
MediaRawData
*
aSample
)
;
struct
InternalSeekTarget
{
InternalSeekTarget
(
const
media
:
:
TimeInterval
&
aTime
bool
aDropTarget
)
:
mTime
(
aTime
)
mDropTarget
(
aDropTarget
)
mWaiting
(
false
)
mHasSeeked
(
false
)
{
}
media
:
:
TimeUnit
Time
(
)
const
{
return
mTime
.
mStart
;
}
media
:
:
TimeUnit
EndTime
(
)
const
{
return
mTime
.
mEnd
;
}
bool
Contains
(
const
media
:
:
TimeUnit
&
aTime
)
const
{
return
mTime
.
Contains
(
aTime
)
;
}
media
:
:
TimeInterval
mTime
;
bool
mDropTarget
;
bool
mWaiting
;
bool
mHasSeeked
;
}
;
void
InternalSeek
(
TrackType
aTrack
const
InternalSeekTarget
&
aTarget
)
;
void
DrainDecoder
(
TrackType
aTrack
)
;
void
NotifyNewOutput
(
TrackType
aTrack
MediaData
*
aSample
)
;
void
NotifyInputExhausted
(
TrackType
aTrack
)
;
void
NotifyDrainComplete
(
TrackType
aTrack
)
;
void
NotifyError
(
TrackType
aTrack
MediaDataDecoderError
aError
=
MediaDataDecoderError
:
:
FATAL_ERROR
)
;
void
NotifyWaitingForData
(
TrackType
aTrack
)
;
void
NotifyEndOfStream
(
TrackType
aTrack
)
;
void
NotifyDecodingRequested
(
TrackType
aTrack
)
;
void
ExtractCryptoInitData
(
nsTArray
<
uint8_t
>
&
aInitData
)
;
void
InitLayersBackendType
(
)
;
void
Output
(
TrackType
aType
MediaData
*
aSample
)
;
void
InputExhausted
(
TrackType
aTrack
)
;
void
Error
(
TrackType
aTrack
MediaDataDecoderError
aError
=
MediaDataDecoderError
:
:
FATAL_ERROR
)
;
void
Reset
(
TrackType
aTrack
)
;
void
DrainComplete
(
TrackType
aTrack
)
;
void
DropDecodedSamples
(
TrackType
aTrack
)
;
bool
ShouldSkip
(
bool
aSkipToNextKeyframe
media
:
:
TimeUnit
aTimeThreshold
)
;
void
SetVideoDecodeThreshold
(
)
;
size_t
SizeOfQueue
(
TrackType
aTrack
)
;
RefPtr
<
PDMFactory
>
mPlatform
;
class
DecoderCallback
:
public
MediaDataDecoderCallback
{
public
:
DecoderCallback
(
MediaFormatReader
*
aReader
TrackType
aType
)
:
mReader
(
aReader
)
mType
(
aType
)
{
}
void
Output
(
MediaData
*
aSample
)
override
{
mReader
-
>
Output
(
mType
aSample
)
;
}
void
InputExhausted
(
)
override
{
mReader
-
>
InputExhausted
(
mType
)
;
}
void
Error
(
MediaDataDecoderError
aError
)
override
{
mReader
-
>
Error
(
mType
aError
)
;
}
void
DrainComplete
(
)
override
{
mReader
-
>
DrainComplete
(
mType
)
;
}
void
ReleaseMediaResources
(
)
override
{
mReader
-
>
ReleaseMediaResources
(
)
;
}
bool
OnReaderTaskQueue
(
)
override
{
return
mReader
-
>
OnTaskQueue
(
)
;
}
private
:
MediaFormatReader
*
mReader
;
TrackType
mType
;
}
;
struct
DecoderData
{
DecoderData
(
MediaFormatReader
*
aOwner
MediaData
:
:
Type
aType
uint32_t
aDecodeAhead
uint32_t
aNumOfMaxError
)
:
mOwner
(
aOwner
)
mType
(
aType
)
mMonitor
(
"
DecoderData
"
)
mDescription
(
"
shutdown
"
)
mDecodeAhead
(
aDecodeAhead
)
mUpdateScheduled
(
false
)
mDemuxEOS
(
false
)
mWaitingForData
(
false
)
mReceivedNewData
(
false
)
mDiscontinuity
(
true
)
mDecoderInitialized
(
false
)
mDecodingRequested
(
false
)
mOutputRequested
(
false
)
mInputExhausted
(
false
)
mNeedDraining
(
false
)
mDraining
(
false
)
mDrainComplete
(
false
)
mNumOfConsecutiveError
(
0
)
mMaxConsecutiveError
(
aNumOfMaxError
)
mNumSamplesInput
(
0
)
mNumSamplesOutput
(
0
)
mNumSamplesOutputTotal
(
0
)
mNumSamplesSkippedTotal
(
0
)
mSizeOfQueue
(
0
)
mIsHardwareAccelerated
(
false
)
mLastStreamSourceID
(
UINT32_MAX
)
mIsBlankDecode
(
false
)
{
}
MediaFormatReader
*
mOwner
;
MediaData
:
:
Type
mType
;
RefPtr
<
MediaTrackDemuxer
>
mTrackDemuxer
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
nsAutoPtr
<
DecoderCallback
>
mCallback
;
Monitor
mMonitor
;
RefPtr
<
MediaDataDecoder
>
mDecoder
;
const
char
*
mDescription
;
void
ShutdownDecoder
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
if
(
mDecoder
)
{
mDecoder
-
>
Shutdown
(
)
;
}
mDescription
=
"
shutdown
"
;
mDecoder
=
nullptr
;
}
uint32_t
mDecodeAhead
;
bool
mUpdateScheduled
;
bool
mDemuxEOS
;
bool
mWaitingForData
;
bool
mReceivedNewData
;
bool
mDiscontinuity
;
MozPromiseRequestHolder
<
MediaTrackDemuxer
:
:
SeekPromise
>
mSeekRequest
;
nsTArray
<
RefPtr
<
MediaRawData
>
>
mQueuedSamples
;
MozPromiseRequestHolder
<
MediaTrackDemuxer
:
:
SamplesPromise
>
mDemuxRequest
;
MozPromiseHolder
<
WaitForDataPromise
>
mWaitingPromise
;
bool
HasWaitingPromise
(
)
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
return
!
mWaitingPromise
.
IsEmpty
(
)
;
}
MozPromiseRequestHolder
<
MediaDataDecoder
:
:
InitPromise
>
mInitPromise
;
bool
mDecoderInitialized
;
bool
mDecodingRequested
;
bool
mOutputRequested
;
bool
mInputExhausted
;
bool
mNeedDraining
;
bool
mDraining
;
bool
mDrainComplete
;
bool
HasPendingDrain
(
)
const
{
return
mDraining
|
|
mDrainComplete
;
}
uint32_t
mNumOfConsecutiveError
;
uint32_t
mMaxConsecutiveError
;
Maybe
<
MediaDataDecoderError
>
mError
;
bool
HasFatalError
(
)
const
{
return
mError
.
isSome
(
)
&
&
mError
.
ref
(
)
=
=
MediaDataDecoderError
:
:
FATAL_ERROR
;
}
Maybe
<
InternalSeekTarget
>
mTimeThreshold
;
Maybe
<
media
:
:
TimeInterval
>
mLastSampleTime
;
nsTArray
<
RefPtr
<
MediaData
>
>
mOutput
;
uint64_t
mNumSamplesInput
;
uint64_t
mNumSamplesOutput
;
uint64_t
mNumSamplesOutputTotal
;
uint64_t
mNumSamplesSkippedTotal
;
virtual
bool
HasPromise
(
)
const
=
0
;
virtual
RefPtr
<
MediaDataPromise
>
EnsurePromise
(
const
char
*
aMethodName
)
=
0
;
virtual
void
ResolvePromise
(
MediaData
*
aData
const
char
*
aMethodName
)
=
0
;
virtual
void
RejectPromise
(
MediaDecoderReader
:
:
NotDecodedReason
aReason
const
char
*
aMethodName
)
=
0
;
void
ResetDemuxer
(
)
{
mDemuxRequest
.
DisconnectIfExists
(
)
;
mSeekRequest
.
DisconnectIfExists
(
)
;
mTrackDemuxer
-
>
Reset
(
)
;
mQueuedSamples
.
Clear
(
)
;
}
void
Flush
(
)
{
if
(
mDecoder
)
{
mDecoder
-
>
Flush
(
)
;
}
mDecodingRequested
=
false
;
mOutputRequested
=
false
;
mInputExhausted
=
false
;
mOutput
.
Clear
(
)
;
mNumSamplesInput
=
0
;
mNumSamplesOutput
=
0
;
mSizeOfQueue
=
0
;
mDraining
=
false
;
mDrainComplete
=
false
;
}
void
ResetState
(
)
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
mDemuxEOS
=
false
;
mWaitingForData
=
false
;
mDiscontinuity
=
true
;
mQueuedSamples
.
Clear
(
)
;
mDecodingRequested
=
false
;
mOutputRequested
=
false
;
mInputExhausted
=
false
;
mNeedDraining
=
false
;
mDraining
=
false
;
mDrainComplete
=
false
;
mTimeThreshold
.
reset
(
)
;
mLastSampleTime
.
reset
(
)
;
mOutput
.
Clear
(
)
;
mNumSamplesInput
=
0
;
mNumSamplesOutput
=
0
;
mSizeOfQueue
=
0
;
mNextStreamSourceID
.
reset
(
)
;
if
(
!
HasFatalError
(
)
)
{
mError
.
reset
(
)
;
}
}
bool
HasInternalSeekPending
(
)
const
{
return
mTimeThreshold
&
&
!
mTimeThreshold
.
ref
(
)
.
mHasSeeked
;
}
Atomic
<
size_t
>
mSizeOfQueue
;
Atomic
<
bool
>
mIsHardwareAccelerated
;
uint32_t
mLastStreamSourceID
;
Maybe
<
uint32_t
>
mNextStreamSourceID
;
media
:
:
TimeIntervals
mTimeRanges
;
Maybe
<
media
:
:
TimeUnit
>
mLastTimeRangesEnd
;
RefPtr
<
SharedTrackInfo
>
mInfo
;
Maybe
<
media
:
:
TimeUnit
>
mFirstDemuxedSampleTime
;
bool
mIsBlankDecode
;
}
;
class
DecoderDataWithPromise
:
public
DecoderData
{
public
:
DecoderDataWithPromise
(
MediaFormatReader
*
aOwner
MediaData
:
:
Type
aType
uint32_t
aDecodeAhead
uint32_t
aNumOfMaxError
)
:
DecoderData
(
aOwner
aType
aDecodeAhead
aNumOfMaxError
)
mHasPromise
(
false
)
{
}
bool
HasPromise
(
)
const
override
{
return
mHasPromise
;
}
RefPtr
<
MediaDataPromise
>
EnsurePromise
(
const
char
*
aMethodName
)
override
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
mHasPromise
=
true
;
return
mPromise
.
Ensure
(
aMethodName
)
;
}
void
ResolvePromise
(
MediaData
*
aData
const
char
*
aMethodName
)
override
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
mPromise
.
Resolve
(
aData
aMethodName
)
;
mHasPromise
=
false
;
}
void
RejectPromise
(
MediaDecoderReader
:
:
NotDecodedReason
aReason
const
char
*
aMethodName
)
override
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
mPromise
.
Reject
(
aReason
aMethodName
)
;
mDecodingRequested
=
false
;
mHasPromise
=
false
;
}
private
:
MozPromiseHolder
<
MediaDataPromise
>
mPromise
;
Atomic
<
bool
>
mHasPromise
;
}
;
DecoderDataWithPromise
mAudio
;
DecoderDataWithPromise
mVideo
;
bool
NeedInput
(
DecoderData
&
aDecoder
)
;
DecoderData
&
GetDecoderData
(
TrackType
aTrack
)
;
RefPtr
<
MediaDataDemuxer
>
mDemuxer
;
bool
mDemuxerInitDone
;
void
OnDemuxerInitDone
(
nsresult
)
;
void
OnDemuxerInitFailed
(
DemuxerFailureReason
aFailure
)
;
MozPromiseRequestHolder
<
MediaDataDemuxer
:
:
InitPromise
>
mDemuxerInitRequest
;
void
OnDemuxFailed
(
TrackType
aTrack
DemuxerFailureReason
aFailure
)
;
void
DoDemuxVideo
(
)
;
void
OnVideoDemuxCompleted
(
RefPtr
<
MediaTrackDemuxer
:
:
SamplesHolder
>
aSamples
)
;
void
OnVideoDemuxFailed
(
DemuxerFailureReason
aFailure
)
{
OnDemuxFailed
(
TrackType
:
:
kVideoTrack
aFailure
)
;
}
void
DoDemuxAudio
(
)
;
void
OnAudioDemuxCompleted
(
RefPtr
<
MediaTrackDemuxer
:
:
SamplesHolder
>
aSamples
)
;
void
OnAudioDemuxFailed
(
DemuxerFailureReason
aFailure
)
{
OnDemuxFailed
(
TrackType
:
:
kAudioTrack
aFailure
)
;
}
void
SkipVideoDemuxToNextKeyFrame
(
media
:
:
TimeUnit
aTimeThreshold
)
;
MozPromiseRequestHolder
<
MediaTrackDemuxer
:
:
SkipAccessPointPromise
>
mSkipRequest
;
void
VideoSkipReset
(
uint32_t
aSkipped
)
;
void
OnVideoSkipCompleted
(
uint32_t
aSkipped
)
;
void
OnVideoSkipFailed
(
MediaTrackDemuxer
:
:
SkipFailureHolder
aFailure
)
;
uint64_t
mLastReportedNumDecodedFrames
;
int64_t
mPreviousDecodedKeyframeTime_us
;
static
const
int64_t
sNoPreviousDecodedKeyframe
=
INT64_MAX
;
layers
:
:
LayersBackend
mLayersBackendType
;
bool
mInitDone
;
MozPromiseHolder
<
MetadataPromise
>
mMetadataPromise
;
bool
IsEncrypted
(
)
{
return
mIsEncrypted
;
}
bool
mIsEncrypted
;
bool
mTrackDemuxersMayBlock
;
Atomic
<
bool
>
mDemuxOnly
;
void
SetSeekTarget
(
const
SeekTarget
&
aTarget
)
;
media
:
:
TimeUnit
DemuxStartTime
(
)
;
bool
IsSeeking
(
)
const
{
return
mPendingSeekTime
.
isSome
(
)
;
}
bool
IsVideoSeeking
(
)
const
{
return
IsSeeking
(
)
&
&
mOriginalSeekTarget
.
IsVideoOnly
(
)
;
}
void
ScheduleSeek
(
)
;
void
AttemptSeek
(
)
;
void
OnSeekFailed
(
TrackType
aTrack
DemuxerFailureReason
aFailure
)
;
void
DoVideoSeek
(
)
;
void
OnVideoSeekCompleted
(
media
:
:
TimeUnit
aTime
)
;
void
OnVideoSeekFailed
(
DemuxerFailureReason
aFailure
)
;
bool
mSeekScheduled
;
void
DoAudioSeek
(
)
;
void
OnAudioSeekCompleted
(
media
:
:
TimeUnit
aTime
)
;
void
OnAudioSeekFailed
(
DemuxerFailureReason
aFailure
)
;
SeekTarget
mOriginalSeekTarget
;
Maybe
<
media
:
:
TimeUnit
>
mFallbackSeekTime
;
Maybe
<
media
:
:
TimeUnit
>
mPendingSeekTime
;
MozPromiseHolder
<
SeekPromise
>
mSeekPromise
;
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
layers
:
:
ImageContainer
*
GetImageContainer
(
)
;
#
ifdef
MOZ_EME
RefPtr
<
CDMProxy
>
mCDMProxy
;
#
endif
RefPtr
<
GMPCrashHelper
>
mCrashHelper
;
void
SetBlankDecode
(
TrackType
aTrack
bool
aIsBlankDecode
)
;
Mirror
<
Maybe
<
double
>
>
mExplicitDuration
;
}
;
}
#
endif
