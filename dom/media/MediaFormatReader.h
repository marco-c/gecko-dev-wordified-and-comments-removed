#
if
!
defined
(
MediaFormatReader_h_
)
#
define
MediaFormatReader_h_
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
MediaDataDemuxer
.
h
"
#
include
"
MediaDecoderReader
.
h
"
#
include
"
PDMFactory
.
h
"
namespace
mozilla
{
class
CDMProxy
;
class
MediaFormatReader
final
:
public
MediaDecoderReader
{
typedef
TrackInfo
:
:
TrackType
TrackType
;
typedef
media
:
:
Interval
<
int64_t
>
ByteInterval
;
public
:
MediaFormatReader
(
AbstractMediaDecoder
*
aDecoder
MediaDataDemuxer
*
aDemuxer
VideoFrameContainer
*
aVideoFrameContainer
=
nullptr
layers
:
:
LayersBackend
aLayersBackend
=
layers
:
:
LayersBackend
:
:
LAYERS_NONE
)
;
virtual
~
MediaFormatReader
(
)
;
nsresult
Init
(
)
override
;
size_t
SizeOfVideoQueueInFrames
(
)
override
;
size_t
SizeOfAudioQueueInFrames
(
)
override
;
RefPtr
<
VideoDataPromise
>
RequestVideoData
(
bool
aSkipToNextKeyframe
int64_t
aTimeThreshold
)
override
;
RefPtr
<
AudioDataPromise
>
RequestAudioData
(
)
override
;
RefPtr
<
MetadataPromise
>
AsyncReadMetadata
(
)
override
;
void
ReadUpdatedMetadata
(
MediaInfo
*
aInfo
)
override
;
RefPtr
<
SeekPromise
>
Seek
(
int64_t
aTime
int64_t
aUnused
)
override
;
protected
:
void
NotifyDataArrivedInternal
(
)
override
;
public
:
media
:
:
TimeIntervals
GetBuffered
(
)
override
;
bool
ForceZeroStartTime
(
)
const
override
;
void
ReleaseMediaResources
(
)
override
;
nsresult
ResetDecode
(
)
override
;
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
override
;
bool
IsAsync
(
)
const
override
{
return
true
;
}
bool
VideoIsHardwareAccelerated
(
)
const
override
;
void
DisableHardwareAcceleration
(
)
override
;
bool
IsWaitForDataSupported
(
)
override
{
return
true
;
}
RefPtr
<
WaitForDataPromise
>
WaitForData
(
MediaData
:
:
Type
aType
)
override
;
bool
IsDemuxOnlySupported
(
)
const
override
{
return
true
;
}
void
SetDemuxOnly
(
bool
aDemuxedOnly
)
override
{
if
(
OnTaskQueue
(
)
)
{
mDemuxOnly
=
aDemuxedOnly
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableMethodWithArg
<
bool
>
(
this
&
MediaDecoderReader
:
:
SetDemuxOnly
aDemuxedOnly
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
bool
UseBufferingHeuristics
(
)
override
{
return
mTrackDemuxersMayBlock
;
}
#
ifdef
MOZ_EME
void
SetCDMProxy
(
CDMProxy
*
aProxy
)
override
;
#
endif
private
:
bool
HasVideo
(
)
{
return
mVideo
.
mTrackDemuxer
;
}
bool
HasAudio
(
)
{
return
mAudio
.
mTrackDemuxer
;
}
bool
IsWaitingOnCDMResource
(
)
;
bool
InitDemuxer
(
)
;
void
NotifyDemuxer
(
)
;
void
ReturnOutput
(
MediaData
*
aData
TrackType
aTrack
)
;
bool
EnsureDecoderCreated
(
TrackType
aTrack
)
;
bool
EnsureDecoderInitialized
(
TrackType
aTrack
)
;
void
ScheduleUpdate
(
TrackType
aTrack
)
;
void
Update
(
TrackType
aTrack
)
;
bool
UpdateReceivedNewData
(
TrackType
aTrack
)
;
void
RequestDemuxSamples
(
TrackType
aTrack
)
;
void
HandleDemuxedSamples
(
TrackType
aTrack
AbstractMediaDecoder
:
:
AutoNotifyDecoded
&
aA
)
;
bool
DecodeDemuxedSamples
(
TrackType
aTrack
MediaRawData
*
aSample
)
;
struct
SeekTarget
{
SeekTarget
(
const
media
:
:
TimeUnit
&
aTime
bool
aDropTarget
)
:
mTime
(
aTime
)
mDropTarget
(
aDropTarget
)
mWaiting
(
false
)
{
}
media
:
:
TimeUnit
mTime
;
bool
mDropTarget
;
bool
mWaiting
;
}
;
void
InternalSeek
(
TrackType
aTrack
const
SeekTarget
&
aTarget
)
;
void
DrainDecoder
(
TrackType
aTrack
)
;
void
NotifyNewOutput
(
TrackType
aTrack
MediaData
*
aSample
)
;
void
NotifyInputExhausted
(
TrackType
aTrack
)
;
void
NotifyDrainComplete
(
TrackType
aTrack
)
;
void
NotifyError
(
TrackType
aTrack
)
;
void
NotifyWaitingForData
(
TrackType
aTrack
)
;
void
NotifyEndOfStream
(
TrackType
aTrack
)
;
void
NotifyDecodingRequested
(
TrackType
aTrack
)
;
void
ExtractCryptoInitData
(
nsTArray
<
uint8_t
>
&
aInitData
)
;
void
InitLayersBackendType
(
)
;
void
Output
(
TrackType
aType
MediaData
*
aSample
)
;
void
InputExhausted
(
TrackType
aTrack
)
;
void
Error
(
TrackType
aTrack
)
;
void
Flush
(
TrackType
aTrack
)
;
void
DrainComplete
(
TrackType
aTrack
)
;
bool
ShouldSkip
(
bool
aSkipToNextKeyframe
media
:
:
TimeUnit
aTimeThreshold
)
;
size_t
SizeOfQueue
(
TrackType
aTrack
)
;
RefPtr
<
PDMFactory
>
mPlatform
;
class
DecoderCallback
:
public
MediaDataDecoderCallback
{
public
:
DecoderCallback
(
MediaFormatReader
*
aReader
TrackType
aType
)
:
mReader
(
aReader
)
mType
(
aType
)
{
}
void
Output
(
MediaData
*
aSample
)
override
{
mReader
-
>
Output
(
mType
aSample
)
;
}
void
InputExhausted
(
)
override
{
mReader
-
>
InputExhausted
(
mType
)
;
}
void
Error
(
)
override
{
mReader
-
>
Error
(
mType
)
;
}
void
DrainComplete
(
)
override
{
mReader
-
>
DrainComplete
(
mType
)
;
}
void
ReleaseMediaResources
(
)
override
{
mReader
-
>
ReleaseMediaResources
(
)
;
}
bool
OnReaderTaskQueue
(
)
override
{
return
mReader
-
>
OnTaskQueue
(
)
;
}
private
:
MediaFormatReader
*
mReader
;
TrackType
mType
;
}
;
struct
DecoderData
{
DecoderData
(
MediaFormatReader
*
aOwner
MediaData
:
:
Type
aType
uint32_t
aDecodeAhead
)
:
mOwner
(
aOwner
)
mType
(
aType
)
mDecodeAhead
(
aDecodeAhead
)
mUpdateScheduled
(
false
)
mDemuxEOS
(
false
)
mWaitingForData
(
false
)
mReceivedNewData
(
false
)
mDiscontinuity
(
true
)
mDecoderInitialized
(
false
)
mDecodingRequested
(
false
)
mOutputRequested
(
false
)
mInputExhausted
(
false
)
mError
(
false
)
mNeedDraining
(
false
)
mDraining
(
false
)
mDrainComplete
(
false
)
mNumSamplesInput
(
0
)
mNumSamplesOutput
(
0
)
mNumSamplesOutputTotal
(
0
)
mSizeOfQueue
(
0
)
mIsHardwareAccelerated
(
false
)
mLastStreamSourceID
(
UINT32_MAX
)
{
}
MediaFormatReader
*
mOwner
;
MediaData
:
:
Type
mType
;
RefPtr
<
MediaTrackDemuxer
>
mTrackDemuxer
;
RefPtr
<
MediaDataDecoder
>
mDecoder
;
RefPtr
<
FlushableTaskQueue
>
mTaskQueue
;
nsAutoPtr
<
DecoderCallback
>
mCallback
;
uint32_t
mDecodeAhead
;
bool
mUpdateScheduled
;
bool
mDemuxEOS
;
bool
mWaitingForData
;
bool
mReceivedNewData
;
bool
mDiscontinuity
;
MozPromiseRequestHolder
<
MediaTrackDemuxer
:
:
SeekPromise
>
mSeekRequest
;
nsTArray
<
RefPtr
<
MediaRawData
>
>
mQueuedSamples
;
MozPromiseRequestHolder
<
MediaTrackDemuxer
:
:
SamplesPromise
>
mDemuxRequest
;
MozPromiseHolder
<
WaitForDataPromise
>
mWaitingPromise
;
bool
HasWaitingPromise
(
)
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
return
!
mWaitingPromise
.
IsEmpty
(
)
;
}
MozPromiseRequestHolder
<
MediaDataDecoder
:
:
InitPromise
>
mInitPromise
;
bool
mDecoderInitialized
;
bool
mDecodingRequested
;
bool
mOutputRequested
;
bool
mInputExhausted
;
bool
mError
;
bool
mNeedDraining
;
bool
mDraining
;
bool
mDrainComplete
;
Maybe
<
SeekTarget
>
mTimeThreshold
;
Maybe
<
media
:
:
TimeUnit
>
mLastSampleTime
;
nsTArray
<
RefPtr
<
MediaData
>
>
mOutput
;
uint64_t
mNumSamplesInput
;
uint64_t
mNumSamplesOutput
;
uint64_t
mNumSamplesOutputTotal
;
virtual
bool
HasPromise
(
)
=
0
;
virtual
void
RejectPromise
(
MediaDecoderReader
:
:
NotDecodedReason
aReason
const
char
*
aMethodName
)
=
0
;
void
ResetDemuxer
(
)
{
mDemuxRequest
.
DisconnectIfExists
(
)
;
mTrackDemuxer
-
>
Reset
(
)
;
}
void
ResetState
(
)
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
mDemuxEOS
=
false
;
mWaitingForData
=
false
;
mReceivedNewData
=
false
;
mDiscontinuity
=
true
;
mQueuedSamples
.
Clear
(
)
;
mDecodingRequested
=
false
;
mOutputRequested
=
false
;
mInputExhausted
=
false
;
mNeedDraining
=
false
;
mDraining
=
false
;
mDrainComplete
=
false
;
mTimeThreshold
.
reset
(
)
;
mLastSampleTime
.
reset
(
)
;
mOutput
.
Clear
(
)
;
mNumSamplesInput
=
0
;
mNumSamplesOutput
=
0
;
mSizeOfQueue
=
0
;
mNextStreamSourceID
.
reset
(
)
;
}
Atomic
<
size_t
>
mSizeOfQueue
;
Atomic
<
bool
>
mIsHardwareAccelerated
;
uint32_t
mLastStreamSourceID
;
Maybe
<
uint32_t
>
mNextStreamSourceID
;
media
:
:
TimeIntervals
mTimeRanges
;
Maybe
<
media
:
:
TimeUnit
>
mLastTimeRangesEnd
;
RefPtr
<
SharedTrackInfo
>
mInfo
;
}
;
template
<
typename
PromiseType
>
struct
DecoderDataWithPromise
:
public
DecoderData
{
DecoderDataWithPromise
(
MediaFormatReader
*
aOwner
MediaData
:
:
Type
aType
uint32_t
aDecodeAhead
)
:
DecoderData
(
aOwner
aType
aDecodeAhead
)
{
}
MozPromiseHolder
<
PromiseType
>
mPromise
;
bool
HasPromise
(
)
override
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
return
!
mPromise
.
IsEmpty
(
)
;
}
void
RejectPromise
(
MediaDecoderReader
:
:
NotDecodedReason
aReason
const
char
*
aMethodName
)
override
{
MOZ_ASSERT
(
mOwner
-
>
OnTaskQueue
(
)
)
;
mPromise
.
Reject
(
aReason
aMethodName
)
;
mDecodingRequested
=
false
;
}
}
;
DecoderDataWithPromise
<
AudioDataPromise
>
mAudio
;
DecoderDataWithPromise
<
VideoDataPromise
>
mVideo
;
bool
NeedInput
(
DecoderData
&
aDecoder
)
;
DecoderData
&
GetDecoderData
(
TrackType
aTrack
)
;
RefPtr
<
MediaDataDemuxer
>
mDemuxer
;
bool
mDemuxerInitDone
;
void
OnDemuxerInitDone
(
nsresult
)
;
void
OnDemuxerInitFailed
(
DemuxerFailureReason
aFailure
)
;
MozPromiseRequestHolder
<
MediaDataDemuxer
:
:
InitPromise
>
mDemuxerInitRequest
;
void
OnDemuxFailed
(
TrackType
aTrack
DemuxerFailureReason
aFailure
)
;
void
DoDemuxVideo
(
)
;
void
OnVideoDemuxCompleted
(
RefPtr
<
MediaTrackDemuxer
:
:
SamplesHolder
>
aSamples
)
;
void
OnVideoDemuxFailed
(
DemuxerFailureReason
aFailure
)
{
OnDemuxFailed
(
TrackType
:
:
kVideoTrack
aFailure
)
;
}
void
DoDemuxAudio
(
)
;
void
OnAudioDemuxCompleted
(
RefPtr
<
MediaTrackDemuxer
:
:
SamplesHolder
>
aSamples
)
;
void
OnAudioDemuxFailed
(
DemuxerFailureReason
aFailure
)
{
OnDemuxFailed
(
TrackType
:
:
kAudioTrack
aFailure
)
;
}
void
SkipVideoDemuxToNextKeyFrame
(
media
:
:
TimeUnit
aTimeThreshold
)
;
MozPromiseRequestHolder
<
MediaTrackDemuxer
:
:
SkipAccessPointPromise
>
mSkipRequest
;
void
OnVideoSkipCompleted
(
uint32_t
aSkipped
)
;
void
OnVideoSkipFailed
(
MediaTrackDemuxer
:
:
SkipFailureHolder
aFailure
)
;
uint64_t
mLastReportedNumDecodedFrames
;
layers
:
:
LayersBackend
mLayersBackendType
;
bool
mInitDone
;
MozPromiseHolder
<
MetadataPromise
>
mMetadataPromise
;
bool
IsEncrypted
(
)
{
return
mIsEncrypted
;
}
bool
mIsEncrypted
;
bool
mTrackDemuxersMayBlock
;
bool
mHardwareAccelerationDisabled
;
Atomic
<
bool
>
mDemuxOnly
;
bool
IsSeeking
(
)
const
{
return
mPendingSeekTime
.
isSome
(
)
;
}
void
AttemptSeek
(
)
;
void
OnSeekFailed
(
TrackType
aTrack
DemuxerFailureReason
aFailure
)
;
void
DoVideoSeek
(
)
;
void
OnVideoSeekCompleted
(
media
:
:
TimeUnit
aTime
)
;
void
OnVideoSeekFailed
(
DemuxerFailureReason
aFailure
)
{
OnSeekFailed
(
TrackType
:
:
kVideoTrack
aFailure
)
;
}
void
DoAudioSeek
(
)
;
void
OnAudioSeekCompleted
(
media
:
:
TimeUnit
aTime
)
;
void
OnAudioSeekFailed
(
DemuxerFailureReason
aFailure
)
{
OnSeekFailed
(
TrackType
:
:
kAudioTrack
aFailure
)
;
}
Maybe
<
media
:
:
TimeUnit
>
mOriginalSeekTime
;
Maybe
<
media
:
:
TimeUnit
>
mPendingSeekTime
;
MozPromiseHolder
<
SeekPromise
>
mSeekPromise
;
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
layers
:
:
ImageContainer
*
GetImageContainer
(
)
;
#
ifdef
MOZ_EME
RefPtr
<
CDMProxy
>
mCDMProxy
;
#
endif
#
if
defined
(
READER_DORMANT_HEURISTIC
)
const
bool
mDormantEnabled
;
#
endif
}
;
}
#
endif
