#
include
"
DecoderTraits
.
h
"
#
include
"
MediaContainerType
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
OggDecoder
.
h
"
#
include
"
OggDemuxer
.
h
"
#
include
"
WebMDecoder
.
h
"
#
include
"
WebMDemuxer
.
h
"
#
ifdef
MOZ_ANDROID_HLS_SUPPORT
#
include
"
HLSDecoder
.
h
"
#
endif
#
ifdef
MOZ_FMP4
#
include
"
MP4Decoder
.
h
"
#
include
"
MP4Demuxer
.
h
"
#
endif
#
include
"
MediaFormatReader
.
h
"
#
include
"
MP3Decoder
.
h
"
#
include
"
MP3Demuxer
.
h
"
#
include
"
WaveDecoder
.
h
"
#
include
"
WaveDemuxer
.
h
"
#
include
"
ADTSDecoder
.
h
"
#
include
"
ADTSDemuxer
.
h
"
#
include
"
FlacDecoder
.
h
"
#
include
"
FlacDemuxer
.
h
"
#
include
"
nsPluginHost
.
h
"
namespace
mozilla
{
bool
DecoderTraits
:
:
IsHttpLiveStreamingType
(
const
MediaContainerType
&
aType
)
{
const
auto
&
mimeType
=
aType
.
Type
(
)
;
return
mimeType
=
=
MEDIAMIMETYPE
(
"
application
/
vnd
.
apple
.
mpegurl
"
)
|
|
mimeType
=
=
MEDIAMIMETYPE
(
"
application
/
x
-
mpegurl
"
)
|
|
mimeType
=
=
MEDIAMIMETYPE
(
"
audio
/
mpegurl
"
)
|
|
mimeType
=
=
MEDIAMIMETYPE
(
"
audio
/
x
-
mpegurl
"
)
;
}
bool
DecoderTraits
:
:
IsMatroskaType
(
const
MediaContainerType
&
aType
)
{
const
auto
&
mimeType
=
aType
.
Type
(
)
;
return
mimeType
=
=
MEDIAMIMETYPE
(
"
audio
/
x
-
matroska
"
)
|
|
mimeType
=
=
MEDIAMIMETYPE
(
"
video
/
x
-
matroska
"
)
;
}
bool
DecoderTraits
:
:
IsMP4SupportedType
(
const
MediaContainerType
&
aType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
#
ifdef
MOZ_FMP4
return
MP4Decoder
:
:
IsSupportedType
(
aType
aDiagnostics
)
;
#
else
return
false
;
#
endif
}
static
CanPlayStatus
CanHandleCodecsType
(
const
MediaContainerType
&
aType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
MOZ_ASSERT
(
aType
.
ExtendedType
(
)
.
HaveCodecs
(
)
)
;
const
MediaContainerType
mimeType
(
aType
.
Type
(
)
)
;
if
(
OggDecoder
:
:
IsSupportedType
(
mimeType
)
)
{
if
(
OggDecoder
:
:
IsSupportedType
(
aType
)
)
{
return
CANPLAY_YES
;
}
return
CANPLAY_NO
;
}
if
(
WaveDecoder
:
:
IsSupportedType
(
MediaContainerType
(
mimeType
)
)
)
{
if
(
WaveDecoder
:
:
IsSupportedType
(
aType
)
)
{
return
CANPLAY_YES
;
}
return
CANPLAY_NO
;
}
if
(
WebMDecoder
:
:
IsSupportedType
(
mimeType
)
)
{
if
(
WebMDecoder
:
:
IsSupportedType
(
aType
)
)
{
return
CANPLAY_YES
;
}
return
CANPLAY_NO
;
}
#
ifdef
MOZ_FMP4
if
(
MP4Decoder
:
:
IsSupportedType
(
mimeType
nullptr
)
)
{
if
(
MP4Decoder
:
:
IsSupportedType
(
aType
aDiagnostics
)
)
{
return
CANPLAY_YES
;
}
return
CANPLAY_NO
;
}
#
endif
if
(
MP3Decoder
:
:
IsSupportedType
(
mimeType
)
)
{
if
(
MP3Decoder
:
:
IsSupportedType
(
aType
)
)
{
return
CANPLAY_YES
;
}
return
CANPLAY_NO
;
}
if
(
ADTSDecoder
:
:
IsSupportedType
(
mimeType
)
)
{
if
(
ADTSDecoder
:
:
IsSupportedType
(
aType
)
)
{
return
CANPLAY_YES
;
}
return
CANPLAY_NO
;
}
if
(
FlacDecoder
:
:
IsSupportedType
(
mimeType
)
)
{
if
(
FlacDecoder
:
:
IsSupportedType
(
aType
)
)
{
return
CANPLAY_YES
;
}
return
CANPLAY_NO
;
}
return
CANPLAY_MAYBE
;
}
static
CanPlayStatus
CanHandleMediaType
(
const
MediaContainerType
&
aType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
#
ifdef
MOZ_ANDROID_HLS_SUPPORT
if
(
HLSDecoder
:
:
IsSupportedType
(
aType
)
)
{
return
CANPLAY_MAYBE
;
}
#
endif
if
(
DecoderTraits
:
:
IsMatroskaType
(
aType
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MEDIA_MKV_CANPLAY_REQUESTED
true
)
;
}
if
(
aType
.
ExtendedType
(
)
.
HaveCodecs
(
)
)
{
CanPlayStatus
result
=
CanHandleCodecsType
(
aType
aDiagnostics
)
;
if
(
result
=
=
CANPLAY_NO
|
|
result
=
=
CANPLAY_YES
)
{
return
result
;
}
}
const
MediaContainerType
mimeType
(
aType
.
Type
(
)
)
;
if
(
OggDecoder
:
:
IsSupportedType
(
mimeType
)
)
{
return
CANPLAY_MAYBE
;
}
if
(
WaveDecoder
:
:
IsSupportedType
(
mimeType
)
)
{
return
CANPLAY_MAYBE
;
}
#
ifdef
MOZ_FMP4
if
(
MP4Decoder
:
:
IsSupportedType
(
mimeType
aDiagnostics
)
)
{
return
CANPLAY_MAYBE
;
}
#
endif
if
(
WebMDecoder
:
:
IsSupportedType
(
mimeType
)
)
{
return
CANPLAY_MAYBE
;
}
if
(
MP3Decoder
:
:
IsSupportedType
(
mimeType
)
)
{
return
CANPLAY_MAYBE
;
}
if
(
ADTSDecoder
:
:
IsSupportedType
(
mimeType
)
)
{
return
CANPLAY_MAYBE
;
}
if
(
FlacDecoder
:
:
IsSupportedType
(
mimeType
)
)
{
return
CANPLAY_MAYBE
;
}
return
CANPLAY_NO
;
}
CanPlayStatus
DecoderTraits
:
:
CanHandleContainerType
(
const
MediaContainerType
&
aContainerType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
return
CanHandleMediaType
(
aContainerType
aDiagnostics
)
;
}
bool
DecoderTraits
:
:
ShouldHandleMediaType
(
const
char
*
aMIMEType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
Maybe
<
MediaContainerType
>
containerType
=
MakeMediaContainerType
(
aMIMEType
)
;
if
(
!
containerType
)
{
return
false
;
}
if
(
WaveDecoder
:
:
IsSupportedType
(
*
containerType
)
)
{
return
false
;
}
if
(
containerType
-
>
Type
(
)
=
=
MEDIAMIMETYPE
(
"
video
/
quicktime
"
)
)
{
RefPtr
<
nsPluginHost
>
pluginHost
=
nsPluginHost
:
:
GetInst
(
)
;
if
(
pluginHost
&
&
pluginHost
-
>
HavePluginForType
(
containerType
-
>
Type
(
)
.
AsString
(
)
)
)
{
return
false
;
}
}
return
CanHandleMediaType
(
*
containerType
aDiagnostics
)
!
=
CANPLAY_NO
;
}
already_AddRefed
<
MediaDataDemuxer
>
DecoderTraits
:
:
CreateDemuxer
(
const
MediaContainerType
&
aType
MediaResource
*
aResource
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
MediaDataDemuxer
>
demuxer
;
#
ifdef
MOZ_FMP4
if
(
MP4Decoder
:
:
IsSupportedType
(
aType
nullptr
)
)
{
demuxer
=
new
MP4Demuxer
(
aResource
)
;
}
else
#
endif
if
(
MP3Decoder
:
:
IsSupportedType
(
aType
)
)
{
demuxer
=
new
MP3Demuxer
(
aResource
)
;
}
else
if
(
ADTSDecoder
:
:
IsSupportedType
(
aType
)
)
{
demuxer
=
new
ADTSDemuxer
(
aResource
)
;
}
else
if
(
WaveDecoder
:
:
IsSupportedType
(
aType
)
)
{
demuxer
=
new
WAVDemuxer
(
aResource
)
;
}
else
if
(
FlacDecoder
:
:
IsSupportedType
(
aType
)
)
{
demuxer
=
new
FlacDemuxer
(
aResource
)
;
}
else
if
(
OggDecoder
:
:
IsSupportedType
(
aType
)
)
{
demuxer
=
new
OggDemuxer
(
aResource
)
;
}
else
if
(
WebMDecoder
:
:
IsSupportedType
(
aType
)
)
{
demuxer
=
new
WebMDemuxer
(
aResource
)
;
}
return
demuxer
.
forget
(
)
;
}
MediaFormatReader
*
DecoderTraits
:
:
CreateReader
(
const
MediaContainerType
&
aType
MediaFormatReaderInit
&
aInit
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
MediaDataDemuxer
>
demuxer
=
CreateDemuxer
(
aType
aInit
.
mResource
)
;
if
(
!
demuxer
)
{
return
nullptr
;
}
MediaFormatReader
*
decoderReader
=
new
MediaFormatReader
(
aInit
demuxer
)
;
if
(
OggDecoder
:
:
IsSupportedType
(
aType
)
)
{
static_cast
<
OggDemuxer
*
>
(
demuxer
.
get
(
)
)
-
>
SetChainingEvents
(
&
decoderReader
-
>
TimedMetadataProducer
(
)
&
decoderReader
-
>
MediaNotSeekableProducer
(
)
)
;
}
return
decoderReader
;
}
bool
DecoderTraits
:
:
IsSupportedType
(
const
MediaContainerType
&
aType
)
{
typedef
bool
(
*
IsSupportedFunction
)
(
const
MediaContainerType
&
aType
)
;
static
const
IsSupportedFunction
funcs
[
]
=
{
&
ADTSDecoder
:
:
IsSupportedType
&
FlacDecoder
:
:
IsSupportedType
&
MP3Decoder
:
:
IsSupportedType
#
ifdef
MOZ_FMP4
&
MP4Decoder
:
:
IsSupportedTypeWithoutDiagnostics
#
endif
&
OggDecoder
:
:
IsSupportedType
&
WaveDecoder
:
:
IsSupportedType
&
WebMDecoder
:
:
IsSupportedType
}
;
for
(
IsSupportedFunction
func
:
funcs
)
{
if
(
func
(
aType
)
)
{
return
true
;
}
}
return
false
;
}
bool
DecoderTraits
:
:
IsSupportedInVideoDocument
(
const
nsACString
&
aType
)
{
if
(
!
Preferences
:
:
GetBool
(
"
media
.
wmf
.
play
-
stand
-
alone
"
true
)
|
|
!
Preferences
:
:
GetBool
(
"
media
.
play
-
stand
-
alone
"
true
)
)
{
return
false
;
}
Maybe
<
MediaContainerType
>
type
=
MakeMediaContainerType
(
aType
)
;
if
(
!
type
)
{
return
false
;
}
return
OggDecoder
:
:
IsSupportedType
(
*
type
)
|
|
WebMDecoder
:
:
IsSupportedType
(
*
type
)
|
|
#
ifdef
MOZ_FMP4
MP4Decoder
:
:
IsSupportedType
(
*
type
nullptr
)
|
|
#
endif
MP3Decoder
:
:
IsSupportedType
(
*
type
)
|
|
ADTSDecoder
:
:
IsSupportedType
(
*
type
)
|
|
FlacDecoder
:
:
IsSupportedType
(
*
type
)
|
|
#
ifdef
MOZ_ANDROID_HLS_SUPPORT
HLSDecoder
:
:
IsSupportedType
(
*
type
)
|
|
#
endif
false
;
}
nsTArray
<
UniquePtr
<
TrackInfo
>
>
DecoderTraits
:
:
GetTracksInfo
(
const
MediaContainerType
&
aType
)
{
const
MediaContainerType
mimeType
(
aType
.
Type
(
)
)
;
if
(
OggDecoder
:
:
IsSupportedType
(
mimeType
)
)
{
return
OggDecoder
:
:
GetTracksInfo
(
aType
)
;
}
if
(
WaveDecoder
:
:
IsSupportedType
(
mimeType
)
)
{
return
WaveDecoder
:
:
GetTracksInfo
(
aType
)
;
}
#
ifdef
MOZ_FMP4
if
(
MP4Decoder
:
:
IsSupportedType
(
mimeType
nullptr
)
)
{
return
MP4Decoder
:
:
GetTracksInfo
(
aType
)
;
}
#
endif
if
(
WebMDecoder
:
:
IsSupportedType
(
mimeType
)
)
{
return
WebMDecoder
:
:
GetTracksInfo
(
aType
)
;
}
if
(
MP3Decoder
:
:
IsSupportedType
(
mimeType
)
)
{
return
MP3Decoder
:
:
GetTracksInfo
(
aType
)
;
}
if
(
ADTSDecoder
:
:
IsSupportedType
(
mimeType
)
)
{
return
ADTSDecoder
:
:
GetTracksInfo
(
aType
)
;
}
if
(
FlacDecoder
:
:
IsSupportedType
(
mimeType
)
)
{
return
FlacDecoder
:
:
GetTracksInfo
(
aType
)
;
}
return
nsTArray
<
UniquePtr
<
TrackInfo
>
>
(
)
;
}
}
