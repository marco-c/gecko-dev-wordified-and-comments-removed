#
include
"
DecoderTraits
.
h
"
#
include
"
MediaContentType
.
h
"
#
include
"
MediaDecoder
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
OggDecoder
.
h
"
#
include
"
OggReader
.
h
"
#
include
"
OggDemuxer
.
h
"
#
include
"
WebMDecoder
.
h
"
#
include
"
WebMDemuxer
.
h
"
#
ifdef
MOZ_ANDROID_OMX
#
include
"
AndroidMediaDecoder
.
h
"
#
include
"
AndroidMediaReader
.
h
"
#
include
"
AndroidMediaPluginHost
.
h
"
#
endif
#
ifdef
MOZ_DIRECTSHOW
#
include
"
DirectShowDecoder
.
h
"
#
include
"
DirectShowReader
.
h
"
#
endif
#
ifdef
MOZ_FMP4
#
include
"
MP4Decoder
.
h
"
#
include
"
MP4Demuxer
.
h
"
#
endif
#
include
"
MediaFormatReader
.
h
"
#
include
"
MP3Decoder
.
h
"
#
include
"
MP3Demuxer
.
h
"
#
include
"
WaveDecoder
.
h
"
#
include
"
WaveDemuxer
.
h
"
#
include
"
WaveReader
.
h
"
#
include
"
ADTSDecoder
.
h
"
#
include
"
ADTSDemuxer
.
h
"
#
include
"
FlacDecoder
.
h
"
#
include
"
FlacDemuxer
.
h
"
#
include
"
nsPluginHost
.
h
"
#
include
"
MediaPrefs
.
h
"
namespace
mozilla
{
template
<
class
String
>
static
bool
CodecListContains
(
char
const
*
const
*
aCodecs
const
String
&
aCodec
)
{
for
(
int32_t
i
=
0
;
aCodecs
[
i
]
;
+
+
i
)
{
if
(
aCodec
.
EqualsASCII
(
aCodecs
[
i
]
)
)
return
true
;
}
return
false
;
}
static
bool
IsOggSupportedType
(
const
nsACString
&
aType
const
nsAString
&
aCodecs
=
EmptyString
(
)
)
{
return
OggDecoder
:
:
CanHandleMediaType
(
aType
aCodecs
)
;
}
static
bool
IsOggTypeAndEnabled
(
const
nsACString
&
aType
)
{
return
IsOggSupportedType
(
aType
)
;
}
static
const
char
*
const
gWaveTypes
[
5
]
=
{
"
audio
/
x
-
wav
"
"
audio
/
wav
"
"
audio
/
wave
"
"
audio
/
x
-
pn
-
wav
"
nullptr
}
;
static
char
const
*
const
gWaveCodecs
[
4
]
=
{
"
1
"
"
6
"
"
7
"
nullptr
}
;
static
bool
IsWaveType
(
const
nsACString
&
aType
)
{
if
(
!
MediaDecoder
:
:
IsWaveEnabled
(
)
)
{
return
false
;
}
return
CodecListContains
(
gWaveTypes
aType
)
;
}
static
bool
IsWebMSupportedType
(
const
nsACString
&
aType
const
nsAString
&
aCodecs
=
EmptyString
(
)
)
{
return
WebMDecoder
:
:
CanHandleMediaType
(
aType
aCodecs
)
;
}
bool
DecoderTraits
:
:
IsWebMTypeAndEnabled
(
const
nsACString
&
aType
)
{
return
IsWebMSupportedType
(
aType
)
;
}
bool
DecoderTraits
:
:
IsWebMAudioType
(
const
nsACString
&
aType
)
{
return
aType
.
EqualsASCII
(
"
audio
/
webm
"
)
;
}
static
char
const
*
const
gHttpLiveStreamingTypes
[
]
=
{
"
application
/
vnd
.
apple
.
mpegurl
"
"
application
/
x
-
mpegurl
"
"
audio
/
x
-
mpegurl
"
nullptr
}
;
static
bool
IsHttpLiveStreamingType
(
const
nsACString
&
aType
)
{
return
CodecListContains
(
gHttpLiveStreamingTypes
aType
)
;
}
#
ifdef
MOZ_ANDROID_OMX
static
bool
IsAndroidMediaType
(
const
nsACString
&
aType
)
{
if
(
!
MediaDecoder
:
:
IsAndroidMediaPluginEnabled
(
)
)
{
return
false
;
}
static
const
char
*
supportedTypes
[
]
=
{
"
audio
/
mpeg
"
"
audio
/
mp4
"
"
video
/
mp4
"
"
video
/
x
-
m4v
"
nullptr
}
;
return
CodecListContains
(
supportedTypes
aType
)
;
}
#
endif
#
ifdef
MOZ_DIRECTSHOW
static
bool
IsDirectShowSupportedType
(
const
nsACString
&
aType
)
{
return
DirectShowDecoder
:
:
GetSupportedCodecs
(
aType
nullptr
)
;
}
#
endif
#
ifdef
MOZ_FMP4
static
bool
IsMP4SupportedType
(
const
MediaContentType
&
aParsedType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
return
MP4Decoder
:
:
CanHandleMediaType
(
aParsedType
aDiagnostics
)
;
}
static
bool
IsMP4SupportedType
(
const
nsACString
&
aType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
MediaContentType
contentType
{
aType
}
;
return
IsMP4SupportedType
(
contentType
aDiagnostics
)
;
}
#
endif
bool
DecoderTraits
:
:
IsMP4TypeAndEnabled
(
const
nsACString
&
aType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
#
ifdef
MOZ_FMP4
return
IsMP4SupportedType
(
aType
aDiagnostics
)
;
#
else
return
false
;
#
endif
}
static
bool
IsMP3SupportedType
(
const
nsACString
&
aType
const
nsAString
&
aCodecs
=
EmptyString
(
)
)
{
return
MP3Decoder
:
:
CanHandleMediaType
(
aType
aCodecs
)
;
}
static
bool
IsAACSupportedType
(
const
nsACString
&
aType
const
nsAString
&
aCodecs
=
EmptyString
(
)
)
{
return
ADTSDecoder
:
:
CanHandleMediaType
(
aType
aCodecs
)
;
}
static
bool
IsWAVSupportedType
(
const
nsACString
&
aType
const
nsAString
&
aCodecs
=
EmptyString
(
)
)
{
return
WaveDecoder
:
:
CanHandleMediaType
(
aType
aCodecs
)
;
}
static
bool
IsFlacSupportedType
(
const
nsACString
&
aType
const
nsAString
&
aCodecs
=
EmptyString
(
)
)
{
return
FlacDecoder
:
:
CanHandleMediaType
(
aType
aCodecs
)
;
}
static
CanPlayStatus
CanHandleCodecsType
(
const
MediaContentType
&
aType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
MOZ_ASSERT
(
aType
.
IsValid
(
)
)
;
MOZ_ASSERT
(
aType
.
HaveCodecs
(
)
)
;
char
const
*
const
*
codecList
=
nullptr
;
if
(
IsOggTypeAndEnabled
(
aType
.
GetMIMEType
(
)
)
)
{
if
(
IsOggSupportedType
(
aType
.
GetMIMEType
(
)
aType
.
GetCodecs
(
)
)
)
{
return
CANPLAY_YES
;
}
else
{
return
CANPLAY_NO
;
}
}
if
(
IsWaveType
(
aType
.
GetMIMEType
(
)
)
)
{
codecList
=
gWaveCodecs
;
}
#
if
!
defined
(
MOZ_OMX_WEBM_DECODER
)
if
(
DecoderTraits
:
:
IsWebMTypeAndEnabled
(
aType
.
GetMIMEType
(
)
)
)
{
if
(
IsWebMSupportedType
(
aType
.
GetMIMEType
(
)
aType
.
GetCodecs
(
)
)
)
{
return
CANPLAY_YES
;
}
else
{
return
CANPLAY_NO
;
}
}
#
endif
#
ifdef
MOZ_FMP4
if
(
DecoderTraits
:
:
IsMP4TypeAndEnabled
(
aType
.
GetMIMEType
(
)
aDiagnostics
)
)
{
if
(
IsMP4SupportedType
(
aType
aDiagnostics
)
)
{
return
CANPLAY_YES
;
}
else
{
return
CANPLAY_NO
;
}
}
#
endif
if
(
IsMP3SupportedType
(
aType
.
GetMIMEType
(
)
aType
.
GetCodecs
(
)
)
)
{
return
CANPLAY_YES
;
}
if
(
IsAACSupportedType
(
aType
.
GetMIMEType
(
)
aType
.
GetCodecs
(
)
)
)
{
return
CANPLAY_YES
;
}
if
(
IsFlacSupportedType
(
aType
.
GetMIMEType
(
)
aType
.
GetCodecs
(
)
)
)
{
return
CANPLAY_YES
;
}
#
ifdef
MOZ_DIRECTSHOW
DirectShowDecoder
:
:
GetSupportedCodecs
(
aType
.
GetMIMEType
(
)
&
codecList
)
;
#
endif
#
ifdef
MOZ_ANDROID_OMX
if
(
MediaDecoder
:
:
IsAndroidMediaPluginEnabled
(
)
)
{
EnsureAndroidMediaPluginHost
(
)
-
>
FindDecoder
(
aType
.
GetMIMEType
(
)
&
codecList
)
;
}
#
endif
if
(
!
codecList
)
{
return
CANPLAY_MAYBE
;
}
nsCharSeparatedTokenizer
tokenizer
(
aType
.
GetCodecs
(
)
'
'
)
;
bool
expectMoreTokens
=
false
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
const
nsSubstring
&
token
=
tokenizer
.
nextToken
(
)
;
if
(
!
CodecListContains
(
codecList
token
)
)
{
return
CANPLAY_NO
;
}
expectMoreTokens
=
tokenizer
.
separatorAfterCurrentToken
(
)
;
}
if
(
expectMoreTokens
)
{
return
CANPLAY_NO
;
}
return
CANPLAY_YES
;
}
static
CanPlayStatus
CanHandleMediaType
(
const
MediaContentType
&
aType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsHttpLiveStreamingType
(
aType
.
GetMIMEType
(
)
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MEDIA_HLS_CANPLAY_REQUESTED
true
)
;
}
if
(
aType
.
HaveCodecs
(
)
)
{
CanPlayStatus
result
=
CanHandleCodecsType
(
aType
aDiagnostics
)
;
if
(
result
=
=
CANPLAY_NO
|
|
result
=
=
CANPLAY_YES
)
{
return
result
;
}
}
if
(
IsOggTypeAndEnabled
(
aType
.
GetMIMEType
(
)
)
)
{
return
CANPLAY_MAYBE
;
}
if
(
IsWaveType
(
aType
.
GetMIMEType
(
)
)
)
{
return
CANPLAY_MAYBE
;
}
if
(
DecoderTraits
:
:
IsMP4TypeAndEnabled
(
aType
.
GetMIMEType
(
)
aDiagnostics
)
)
{
return
CANPLAY_MAYBE
;
}
#
if
!
defined
(
MOZ_OMX_WEBM_DECODER
)
if
(
DecoderTraits
:
:
IsWebMTypeAndEnabled
(
aType
.
GetMIMEType
(
)
)
)
{
return
CANPLAY_MAYBE
;
}
#
endif
if
(
IsMP3SupportedType
(
aType
.
GetMIMEType
(
)
)
)
{
return
CANPLAY_MAYBE
;
}
if
(
IsAACSupportedType
(
aType
.
GetMIMEType
(
)
)
)
{
return
CANPLAY_MAYBE
;
}
if
(
IsFlacSupportedType
(
aType
.
GetMIMEType
(
)
)
)
{
return
CANPLAY_MAYBE
;
}
#
ifdef
MOZ_DIRECTSHOW
if
(
DirectShowDecoder
:
:
GetSupportedCodecs
(
aType
.
GetMIMEType
(
)
nullptr
)
)
{
return
CANPLAY_MAYBE
;
}
#
endif
#
ifdef
MOZ_ANDROID_OMX
if
(
MediaDecoder
:
:
IsAndroidMediaPluginEnabled
(
)
&
&
EnsureAndroidMediaPluginHost
(
)
-
>
FindDecoder
(
aType
.
GetMIMEType
(
)
nullptr
)
)
{
return
CANPLAY_MAYBE
;
}
#
endif
return
CANPLAY_NO
;
}
CanPlayStatus
DecoderTraits
:
:
CanHandleContentType
(
const
MediaContentType
&
aContentType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
if
(
!
aContentType
.
IsValid
(
)
)
{
return
CANPLAY_NO
;
}
return
CanHandleMediaType
(
aContentType
aDiagnostics
)
;
}
bool
DecoderTraits
:
:
ShouldHandleMediaType
(
const
char
*
aMIMEType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
if
(
IsWaveType
(
nsDependentCString
(
aMIMEType
)
)
)
{
return
false
;
}
if
(
nsDependentCString
(
aMIMEType
)
.
EqualsASCII
(
"
video
/
quicktime
"
)
)
{
RefPtr
<
nsPluginHost
>
pluginHost
=
nsPluginHost
:
:
GetInst
(
)
;
if
(
pluginHost
&
&
pluginHost
-
>
HavePluginForType
(
nsDependentCString
(
aMIMEType
)
)
)
{
return
false
;
}
}
MediaContentType
parsed
{
nsDependentCString
(
aMIMEType
)
}
;
return
CanHandleMediaType
(
parsed
aDiagnostics
)
!
=
CANPLAY_NO
;
}
static
already_AddRefed
<
MediaDecoder
>
InstantiateDecoder
(
const
nsACString
&
aType
MediaDecoderOwner
*
aOwner
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
MediaDecoder
>
decoder
;
#
ifdef
MOZ_FMP4
if
(
IsMP4SupportedType
(
aType
aDiagnostics
)
)
{
decoder
=
new
MP4Decoder
(
aOwner
)
;
return
decoder
.
forget
(
)
;
}
#
endif
if
(
IsMP3SupportedType
(
aType
)
)
{
decoder
=
new
MP3Decoder
(
aOwner
)
;
return
decoder
.
forget
(
)
;
}
if
(
IsAACSupportedType
(
aType
)
)
{
decoder
=
new
ADTSDecoder
(
aOwner
)
;
return
decoder
.
forget
(
)
;
}
if
(
IsOggSupportedType
(
aType
)
)
{
decoder
=
new
OggDecoder
(
aOwner
)
;
return
decoder
.
forget
(
)
;
}
if
(
IsWaveType
(
aType
)
)
{
decoder
=
new
WaveDecoder
(
aOwner
)
;
return
decoder
.
forget
(
)
;
}
if
(
IsFlacSupportedType
(
aType
)
)
{
decoder
=
new
FlacDecoder
(
aOwner
)
;
return
decoder
.
forget
(
)
;
}
#
ifdef
MOZ_ANDROID_OMX
if
(
MediaDecoder
:
:
IsAndroidMediaPluginEnabled
(
)
&
&
EnsureAndroidMediaPluginHost
(
)
-
>
FindDecoder
(
aType
nullptr
)
)
{
decoder
=
new
AndroidMediaDecoder
(
aOwner
aType
)
;
return
decoder
.
forget
(
)
;
}
#
endif
if
(
IsWebMSupportedType
(
aType
)
)
{
decoder
=
new
WebMDecoder
(
aOwner
)
;
return
decoder
.
forget
(
)
;
}
#
ifdef
MOZ_DIRECTSHOW
if
(
IsDirectShowSupportedType
(
aType
)
)
{
decoder
=
new
DirectShowDecoder
(
aOwner
)
;
return
decoder
.
forget
(
)
;
}
#
endif
if
(
IsHttpLiveStreamingType
(
aType
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MEDIA_HLS_DECODER_SUCCESS
false
)
;
}
return
nullptr
;
}
already_AddRefed
<
MediaDecoder
>
DecoderTraits
:
:
CreateDecoder
(
const
nsACString
&
aType
MediaDecoderOwner
*
aOwner
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
InstantiateDecoder
(
aType
aOwner
aDiagnostics
)
;
}
MediaDecoderReader
*
DecoderTraits
:
:
CreateReader
(
const
nsACString
&
aType
AbstractMediaDecoder
*
aDecoder
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MediaDecoderReader
*
decoderReader
=
nullptr
;
if
(
!
aDecoder
)
{
return
decoderReader
;
}
#
ifdef
MOZ_FMP4
if
(
IsMP4SupportedType
(
aType
nullptr
)
)
{
decoderReader
=
new
MediaFormatReader
(
aDecoder
new
MP4Demuxer
(
aDecoder
-
>
GetResource
(
)
)
)
;
}
else
#
endif
if
(
IsMP3SupportedType
(
aType
)
)
{
decoderReader
=
new
MediaFormatReader
(
aDecoder
new
mp3
:
:
MP3Demuxer
(
aDecoder
-
>
GetResource
(
)
)
)
;
}
else
if
(
IsAACSupportedType
(
aType
)
)
{
decoderReader
=
new
MediaFormatReader
(
aDecoder
new
ADTSDemuxer
(
aDecoder
-
>
GetResource
(
)
)
)
;
}
else
if
(
IsWAVSupportedType
(
aType
)
)
{
decoderReader
=
new
MediaFormatReader
(
aDecoder
new
WAVDemuxer
(
aDecoder
-
>
GetResource
(
)
)
)
;
}
else
if
(
IsFlacSupportedType
(
aType
)
)
{
decoderReader
=
new
MediaFormatReader
(
aDecoder
new
FlacDemuxer
(
aDecoder
-
>
GetResource
(
)
)
)
;
}
else
if
(
IsOggSupportedType
(
aType
)
)
{
decoderReader
=
MediaPrefs
:
:
OggFormatReader
(
)
?
static_cast
<
MediaDecoderReader
*
>
(
new
MediaFormatReader
(
aDecoder
new
OggDemuxer
(
aDecoder
-
>
GetResource
(
)
)
)
)
:
new
OggReader
(
aDecoder
)
;
}
else
if
(
IsWaveType
(
aType
)
)
{
decoderReader
=
new
WaveReader
(
aDecoder
)
;
}
else
#
ifdef
MOZ_ANDROID_OMX
if
(
MediaDecoder
:
:
IsAndroidMediaPluginEnabled
(
)
&
&
EnsureAndroidMediaPluginHost
(
)
-
>
FindDecoder
(
aType
nullptr
)
)
{
decoderReader
=
new
AndroidMediaReader
(
aDecoder
aType
)
;
}
else
#
endif
if
(
IsWebMSupportedType
(
aType
)
)
{
decoderReader
=
new
MediaFormatReader
(
aDecoder
new
WebMDemuxer
(
aDecoder
-
>
GetResource
(
)
)
)
;
}
else
#
ifdef
MOZ_DIRECTSHOW
if
(
IsDirectShowSupportedType
(
aType
)
)
{
decoderReader
=
new
DirectShowReader
(
aDecoder
)
;
}
else
#
endif
if
(
false
)
{
}
return
decoderReader
;
}
bool
DecoderTraits
:
:
IsSupportedInVideoDocument
(
const
nsACString
&
aType
)
{
if
(
!
Preferences
:
:
GetBool
(
"
media
.
windows
-
media
-
foundation
.
play
-
stand
-
alone
"
true
)
|
|
!
Preferences
:
:
GetBool
(
"
media
.
play
-
stand
-
alone
"
true
)
)
{
return
false
;
}
return
IsOggSupportedType
(
aType
)
|
|
IsWebMSupportedType
(
aType
)
|
|
#
ifdef
MOZ_ANDROID_OMX
(
MediaDecoder
:
:
IsAndroidMediaPluginEnabled
(
)
&
&
IsAndroidMediaType
(
aType
)
)
|
|
#
endif
#
ifdef
MOZ_FMP4
IsMP4SupportedType
(
aType
nullptr
)
|
|
#
endif
IsMP3SupportedType
(
aType
)
|
|
IsAACSupportedType
(
aType
)
|
|
IsFlacSupportedType
(
aType
)
|
|
#
ifdef
MOZ_DIRECTSHOW
IsDirectShowSupportedType
(
aType
)
|
|
#
endif
false
;
}
}
