#
include
"
MediaStreamGraphImpl
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
AudioCaptureStream
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeStream
.
h
"
#
include
"
AudioNodeExternalInputStream
.
h
"
#
include
"
webaudio
/
MediaStreamAudioDestinationNode
.
h
"
#
include
<
algorithm
>
#
include
"
DOMMediaStream
.
h
"
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
static
const
uint32_t
MONO
=
1
;
AudioCaptureStream
:
:
AudioCaptureStream
(
DOMMediaStream
*
aWrapper
TrackID
aTrackId
)
:
ProcessedMediaStream
(
aWrapper
)
mTrackId
(
aTrackId
)
mTrackCreated
(
false
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_COUNT_CTOR
(
AudioCaptureStream
)
;
mMixer
.
AddCallback
(
this
)
;
}
AudioCaptureStream
:
:
~
AudioCaptureStream
(
)
{
MOZ_COUNT_DTOR
(
AudioCaptureStream
)
;
mMixer
.
RemoveCallback
(
this
)
;
}
void
AudioCaptureStream
:
:
ProcessInput
(
GraphTime
aFrom
GraphTime
aTo
uint32_t
aFlags
)
{
uint32_t
inputCount
=
mInputs
.
Length
(
)
;
StreamBuffer
:
:
Track
*
track
=
EnsureTrack
(
mTrackId
)
;
if
(
!
mTrackCreated
)
{
for
(
uint32_t
i
=
0
;
i
<
mListeners
.
Length
(
)
;
i
+
+
)
{
MediaStreamListener
*
l
=
mListeners
[
i
]
;
AudioSegment
tmp
;
l
-
>
NotifyQueuedTrackChanges
(
Graph
(
)
mTrackId
0
MediaStreamListener
:
:
TRACK_EVENT_CREATED
tmp
)
;
l
-
>
NotifyFinishedTrackCreation
(
Graph
(
)
)
;
}
mTrackCreated
=
true
;
}
if
(
mFinished
|
|
InMutedCycle
(
)
|
|
inputCount
=
=
0
)
{
track
-
>
Get
<
AudioSegment
>
(
)
-
>
AppendNullData
(
aTo
-
aFrom
)
;
}
else
{
mMixer
.
StartMixing
(
)
;
AudioSegment
output
;
for
(
uint32_t
i
=
0
;
i
<
inputCount
;
i
+
+
)
{
MediaStream
*
s
=
mInputs
[
i
]
-
>
GetSource
(
)
;
StreamBuffer
:
:
TrackIter
tracks
(
s
-
>
GetStreamBuffer
(
)
MediaSegment
:
:
AUDIO
)
;
while
(
!
tracks
.
IsEnded
(
)
)
{
AudioSegment
*
inputSegment
=
tracks
-
>
Get
<
AudioSegment
>
(
)
;
StreamTime
inputStart
=
s
-
>
GraphTimeToStreamTimeWithBlocking
(
aFrom
)
;
StreamTime
inputEnd
=
s
-
>
GraphTimeToStreamTimeWithBlocking
(
aTo
)
;
AudioSegment
toMix
;
toMix
.
AppendSlice
(
*
inputSegment
inputStart
inputEnd
)
;
if
(
inputEnd
-
inputStart
<
aTo
-
aFrom
)
{
toMix
.
AppendNullData
(
(
aTo
-
aFrom
)
-
(
inputEnd
-
inputStart
)
)
;
}
toMix
.
Mix
(
mMixer
MONO
Graph
(
)
-
>
GraphRate
(
)
)
;
tracks
.
Next
(
)
;
}
}
mMixer
.
FinishMixing
(
)
;
}
mBuffer
.
AdvanceKnownTracksTime
(
GraphTimeToStreamTimeWithBlocking
(
(
aTo
)
)
)
;
}
void
AudioCaptureStream
:
:
MixerCallback
(
AudioDataValue
*
aMixedBuffer
AudioSampleFormat
aFormat
uint32_t
aChannels
uint32_t
aFrames
uint32_t
aSampleRate
)
{
nsAutoTArray
<
nsTArray
<
AudioDataValue
>
MONO
>
output
;
nsAutoTArray
<
const
AudioDataValue
*
MONO
>
bufferPtrs
;
output
.
SetLength
(
MONO
)
;
bufferPtrs
.
SetLength
(
MONO
)
;
uint32_t
written
=
0
;
for
(
uint32_t
channel
=
0
;
channel
<
aChannels
;
channel
+
+
)
{
AudioDataValue
*
out
=
output
[
channel
]
.
AppendElements
(
aFrames
)
;
PodCopy
(
out
aMixedBuffer
+
written
aFrames
)
;
bufferPtrs
[
channel
]
=
out
;
written
+
=
aFrames
;
}
AudioChunk
chunk
;
chunk
.
mBuffer
=
new
mozilla
:
:
SharedChannelArrayBuffer
<
AudioDataValue
>
(
&
output
)
;
chunk
.
mDuration
=
aFrames
;
chunk
.
mBufferFormat
=
aFormat
;
chunk
.
mVolume
=
1
.
0f
;
chunk
.
mChannelData
.
SetLength
(
MONO
)
;
for
(
uint32_t
channel
=
0
;
channel
<
aChannels
;
channel
+
+
)
{
chunk
.
mChannelData
[
channel
]
=
bufferPtrs
[
channel
]
;
}
EnsureTrack
(
mTrackId
)
-
>
Get
<
AudioSegment
>
(
)
-
>
AppendAndConsumeChunk
(
&
chunk
)
;
}
}
