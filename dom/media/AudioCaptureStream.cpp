#
include
"
MediaStreamGraphImpl
.
h
"
#
include
"
MediaStreamListener
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
AudioCaptureStream
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeStream
.
h
"
#
include
"
AudioNodeExternalInputStream
.
h
"
#
include
"
webaudio
/
MediaStreamAudioDestinationNode
.
h
"
#
include
<
algorithm
>
#
include
"
DOMMediaStream
.
h
"
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
static
const
uint32_t
MONO
=
1
;
AudioCaptureStream
:
:
AudioCaptureStream
(
TrackRate
aRate
)
:
ProcessedMediaStream
(
aRate
MediaSegment
:
:
AUDIO
new
AudioSegment
(
)
)
mStarted
(
false
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_COUNT_CTOR
(
AudioCaptureStream
)
;
mMixer
.
AddCallback
(
this
)
;
}
AudioCaptureStream
:
:
~
AudioCaptureStream
(
)
{
MOZ_COUNT_DTOR
(
AudioCaptureStream
)
;
mMixer
.
RemoveCallback
(
this
)
;
}
void
AudioCaptureStream
:
:
Start
(
)
{
class
Message
:
public
ControlMessage
{
public
:
explicit
Message
(
AudioCaptureStream
*
aStream
)
:
ControlMessage
(
aStream
)
mStream
(
aStream
)
{
}
virtual
void
Run
(
)
{
mStream
-
>
mStarted
=
true
;
}
protected
:
AudioCaptureStream
*
mStream
;
}
;
GraphImpl
(
)
-
>
AppendMessage
(
MakeUnique
<
Message
>
(
this
)
)
;
}
void
AudioCaptureStream
:
:
ProcessInput
(
GraphTime
aFrom
GraphTime
aTo
uint32_t
aFlags
)
{
if
(
!
mStarted
)
{
return
;
}
uint32_t
inputCount
=
mInputs
.
Length
(
)
;
if
(
mEnded
)
{
return
;
}
if
(
InMutedCycle
(
)
|
|
inputCount
=
=
0
)
{
GetData
<
AudioSegment
>
(
)
-
>
AppendNullData
(
aTo
-
aFrom
)
;
}
else
{
mMixer
.
StartMixing
(
)
;
AudioSegment
output
;
for
(
uint32_t
i
=
0
;
i
<
inputCount
;
i
+
+
)
{
MediaStream
*
s
=
mInputs
[
i
]
-
>
GetSource
(
)
;
AudioSegment
*
inputSegment
=
s
-
>
GetData
<
AudioSegment
>
(
)
;
StreamTime
inputStart
=
s
-
>
GraphTimeToStreamTimeWithBlocking
(
aFrom
)
;
StreamTime
inputEnd
=
s
-
>
GraphTimeToStreamTimeWithBlocking
(
aTo
)
;
AudioSegment
toMix
;
if
(
s
-
>
Ended
(
)
&
&
inputSegment
-
>
GetDuration
(
)
<
=
inputStart
)
{
toMix
.
AppendNullData
(
aTo
-
aFrom
)
;
}
else
{
toMix
.
AppendSlice
(
*
inputSegment
inputStart
inputEnd
)
;
if
(
inputEnd
-
inputStart
<
aTo
-
aFrom
)
{
toMix
.
AppendNullData
(
(
aTo
-
aFrom
)
-
(
inputEnd
-
inputStart
)
)
;
}
}
toMix
.
Mix
(
mMixer
MONO
Graph
(
)
-
>
GraphRate
(
)
)
;
}
mMixer
.
FinishMixing
(
)
;
}
}
void
AudioCaptureStream
:
:
MixerCallback
(
AudioDataValue
*
aMixedBuffer
AudioSampleFormat
aFormat
uint32_t
aChannels
uint32_t
aFrames
uint32_t
aSampleRate
)
{
AutoTArray
<
nsTArray
<
AudioDataValue
>
MONO
>
output
;
AutoTArray
<
const
AudioDataValue
*
MONO
>
bufferPtrs
;
output
.
SetLength
(
MONO
)
;
bufferPtrs
.
SetLength
(
MONO
)
;
uint32_t
written
=
0
;
for
(
uint32_t
channel
=
0
;
channel
<
aChannels
;
channel
+
+
)
{
AudioDataValue
*
out
=
output
[
channel
]
.
AppendElements
(
aFrames
)
;
PodCopy
(
out
aMixedBuffer
+
written
aFrames
)
;
bufferPtrs
[
channel
]
=
out
;
written
+
=
aFrames
;
}
AudioChunk
chunk
;
chunk
.
mBuffer
=
new
mozilla
:
:
SharedChannelArrayBuffer
<
AudioDataValue
>
(
&
output
)
;
chunk
.
mDuration
=
aFrames
;
chunk
.
mBufferFormat
=
aFormat
;
chunk
.
mChannelData
.
SetLength
(
MONO
)
;
for
(
uint32_t
channel
=
0
;
channel
<
aChannels
;
channel
+
+
)
{
chunk
.
mChannelData
[
channel
]
=
bufferPtrs
[
channel
]
;
}
GetData
<
AudioSegment
>
(
)
-
>
AppendAndConsumeChunk
(
&
chunk
)
;
}
}
