#
if
!
defined
(
MediaQueue_h_
)
#
define
MediaQueue_h_
#
include
"
mozilla
/
ReentrantMonitor
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
nsDeque
.
h
"
#
include
"
MediaEventSource
.
h
"
namespace
mozilla
{
template
<
class
T
>
class
MediaQueueDeallocator
:
public
nsDequeFunctor
{
virtual
void
*
operator
(
)
(
void
*
aObject
)
{
nsRefPtr
<
T
>
releaseMe
=
dont_AddRef
(
static_cast
<
T
*
>
(
aObject
)
)
;
return
nullptr
;
}
}
;
template
<
class
T
>
class
MediaQueue
:
private
nsDeque
{
public
:
MediaQueue
(
)
:
nsDeque
(
new
MediaQueueDeallocator
<
T
>
(
)
)
mReentrantMonitor
(
"
mediaqueue
"
)
mEndOfStream
(
false
)
{
}
~
MediaQueue
(
)
{
Reset
(
)
;
}
inline
int32_t
GetSize
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
return
nsDeque
:
:
GetSize
(
)
;
}
inline
void
Push
(
T
*
aItem
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
MOZ_ASSERT
(
aItem
)
;
NS_ADDREF
(
aItem
)
;
nsDeque
:
:
Push
(
aItem
)
;
mPushEvent
.
Notify
(
)
;
}
inline
void
PushFront
(
T
*
aItem
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
MOZ_ASSERT
(
aItem
)
;
NS_ADDREF
(
aItem
)
;
nsDeque
:
:
PushFront
(
aItem
)
;
mPushEvent
.
Notify
(
)
;
}
inline
already_AddRefed
<
T
>
PopFront
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
nsRefPtr
<
T
>
rv
=
dont_AddRef
(
static_cast
<
T
*
>
(
nsDeque
:
:
PopFront
(
)
)
)
;
if
(
rv
)
{
mPopEvent
.
Notify
(
rv
)
;
}
return
rv
.
forget
(
)
;
}
inline
T
*
Peek
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
return
static_cast
<
T
*
>
(
nsDeque
:
:
Peek
(
)
)
;
}
inline
T
*
PeekFront
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
return
static_cast
<
T
*
>
(
nsDeque
:
:
PeekFront
(
)
)
;
}
void
Reset
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
while
(
GetSize
(
)
>
0
)
{
nsRefPtr
<
T
>
x
=
PopFront
(
)
;
}
mEndOfStream
=
false
;
}
bool
AtEndOfStream
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
return
GetSize
(
)
=
=
0
&
&
mEndOfStream
;
}
bool
IsFinished
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
return
mEndOfStream
;
}
void
Finish
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
mEndOfStream
=
true
;
mFinishEvent
.
Notify
(
)
;
}
int64_t
Duration
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
if
(
GetSize
(
)
=
=
0
)
{
return
0
;
}
T
*
last
=
Peek
(
)
;
T
*
first
=
PeekFront
(
)
;
return
last
-
>
GetEndTime
(
)
-
first
-
>
mTime
;
}
void
LockedForEach
(
nsDequeFunctor
&
aFunctor
)
const
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
ForEach
(
aFunctor
)
;
}
void
GetElementsAfter
(
int64_t
aTime
nsTArray
<
nsRefPtr
<
T
>
>
*
aResult
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
if
(
!
GetSize
(
)
)
return
;
int32_t
i
;
for
(
i
=
GetSize
(
)
-
1
;
i
>
0
;
-
-
i
)
{
T
*
v
=
static_cast
<
T
*
>
(
ObjectAt
(
i
)
)
;
if
(
v
-
>
GetEndTime
(
)
<
aTime
)
break
;
}
for
(
;
i
<
GetSize
(
)
;
+
+
i
)
{
nsRefPtr
<
T
>
elem
=
static_cast
<
T
*
>
(
ObjectAt
(
i
)
)
;
aResult
-
>
AppendElement
(
elem
)
;
}
}
void
GetFirstElements
(
uint32_t
aMaxElements
nsTArray
<
nsRefPtr
<
T
>
>
*
aResult
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
for
(
int32_t
i
=
0
;
i
<
(
int32_t
)
aMaxElements
&
&
i
<
GetSize
(
)
;
+
+
i
)
{
*
aResult
-
>
AppendElement
(
)
=
static_cast
<
T
*
>
(
ObjectAt
(
i
)
)
;
}
}
uint32_t
FrameCount
(
)
{
ReentrantMonitorAutoEnter
mon
(
mReentrantMonitor
)
;
uint32_t
frames
=
0
;
for
(
int32_t
i
=
0
;
i
<
GetSize
(
)
;
+
+
i
)
{
T
*
v
=
static_cast
<
T
*
>
(
ObjectAt
(
i
)
)
;
frames
+
=
v
-
>
mFrames
;
}
return
frames
;
}
MediaEventSource
<
nsRefPtr
<
T
>
>
&
PopEvent
(
)
{
return
mPopEvent
;
}
MediaEventSource
<
void
>
&
PushEvent
(
)
{
return
mPushEvent
;
}
MediaEventSource
<
void
>
&
FinishEvent
(
)
{
return
mFinishEvent
;
}
private
:
mutable
ReentrantMonitor
mReentrantMonitor
;
MediaEventProducer
<
nsRefPtr
<
T
>
>
mPopEvent
;
MediaEventProducer
<
void
>
mPushEvent
;
MediaEventProducer
<
void
>
mFinishEvent
;
bool
mEndOfStream
;
}
;
}
#
endif
