#
if
!
defined
(
MediaQueue_h_
)
#
define
MediaQueue_h_
#
include
"
mozilla
/
RecursiveMutex
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
nsDeque
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
TimeUnits
.
h
"
namespace
mozilla
{
class
AudioData
;
template
<
class
T
>
class
MediaQueueDeallocator
:
public
nsDequeFunctor
{
virtual
void
operator
(
)
(
void
*
aObject
)
override
{
RefPtr
<
T
>
releaseMe
=
dont_AddRef
(
static_cast
<
T
*
>
(
aObject
)
)
;
}
}
;
template
<
class
T
>
class
MediaQueue
:
private
nsDeque
{
public
:
MediaQueue
(
)
:
nsDeque
(
new
MediaQueueDeallocator
<
T
>
(
)
)
mRecursiveMutex
(
"
mediaqueue
"
)
mEndOfStream
(
false
)
{
}
~
MediaQueue
(
)
{
Reset
(
)
;
}
inline
size_t
GetSize
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
nsDeque
:
:
GetSize
(
)
;
}
inline
void
Push
(
T
*
aItem
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
MOZ_ASSERT
(
aItem
)
;
NS_ADDREF
(
aItem
)
;
MOZ_ASSERT
(
aItem
-
>
GetEndTime
(
)
>
=
aItem
-
>
mTime
)
;
nsDeque
:
:
Push
(
aItem
)
;
mPushEvent
.
Notify
(
RefPtr
<
T
>
(
aItem
)
)
;
if
(
mEndOfStream
)
{
mEndOfStream
=
false
;
}
}
inline
already_AddRefed
<
T
>
PopFront
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
RefPtr
<
T
>
rv
=
dont_AddRef
(
static_cast
<
T
*
>
(
nsDeque
:
:
PopFront
(
)
)
)
;
if
(
rv
)
{
mPopFrontEvent
.
Notify
(
rv
)
;
}
return
rv
.
forget
(
)
;
}
inline
already_AddRefed
<
T
>
PopBack
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
RefPtr
<
T
>
rv
=
dont_AddRef
(
static_cast
<
T
*
>
(
nsDeque
:
:
Pop
(
)
)
)
;
return
rv
.
forget
(
)
;
}
inline
RefPtr
<
T
>
PeekFront
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
static_cast
<
T
*
>
(
nsDeque
:
:
PeekFront
(
)
)
;
}
inline
RefPtr
<
T
>
PeekBack
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
static_cast
<
T
*
>
(
nsDeque
:
:
Peek
(
)
)
;
}
void
Reset
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
while
(
GetSize
(
)
>
0
)
{
RefPtr
<
T
>
x
=
dont_AddRef
(
static_cast
<
T
*
>
(
nsDeque
:
:
PopFront
(
)
)
)
;
}
mEndOfStream
=
false
;
}
bool
AtEndOfStream
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
GetSize
(
)
=
=
0
&
&
mEndOfStream
;
}
bool
IsFinished
(
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
return
mEndOfStream
;
}
void
Finish
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
!
mEndOfStream
)
{
mEndOfStream
=
true
;
mFinishEvent
.
Notify
(
)
;
}
}
int64_t
Duration
(
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
GetSize
(
)
=
=
0
)
{
return
0
;
}
T
*
last
=
static_cast
<
T
*
>
(
nsDeque
:
:
Peek
(
)
)
;
T
*
first
=
static_cast
<
T
*
>
(
nsDeque
:
:
PeekFront
(
)
)
;
return
(
last
-
>
GetEndTime
(
)
-
first
-
>
mTime
)
.
ToMicroseconds
(
)
;
}
void
LockedForEach
(
nsDequeFunctor
&
aFunctor
)
const
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
ForEach
(
aFunctor
)
;
}
void
GetElementsAfter
(
int64_t
aTime
nsTArray
<
RefPtr
<
T
>
>
*
aResult
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
if
(
GetSize
(
)
=
=
0
)
return
;
size_t
i
;
for
(
i
=
GetSize
(
)
-
1
;
i
>
0
;
-
-
i
)
{
T
*
v
=
static_cast
<
T
*
>
(
ObjectAt
(
i
)
)
;
if
(
v
-
>
GetEndTime
(
)
.
ToMicroseconds
(
)
<
aTime
)
break
;
}
for
(
;
i
<
GetSize
(
)
;
+
+
i
)
{
RefPtr
<
T
>
elem
=
static_cast
<
T
*
>
(
ObjectAt
(
static_cast
<
size_t
>
(
i
)
)
)
;
aResult
-
>
AppendElement
(
elem
)
;
}
}
void
GetElementsAfter
(
const
media
:
:
TimeUnit
&
aTime
nsTArray
<
RefPtr
<
T
>
>
*
aResult
)
{
GetElementsAfter
(
aTime
.
ToMicroseconds
(
)
aResult
)
;
}
void
GetFirstElements
(
uint32_t
aMaxElements
nsTArray
<
RefPtr
<
T
>
>
*
aResult
)
{
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
for
(
size_t
i
=
0
;
i
<
aMaxElements
&
&
i
<
GetSize
(
)
;
+
+
i
)
{
*
aResult
-
>
AppendElement
(
)
=
static_cast
<
T
*
>
(
ObjectAt
(
i
)
)
;
}
}
uint32_t
AudioFramesCount
(
)
{
static_assert
(
mozilla
:
:
IsSame
<
T
AudioData
>
:
:
value
"
Only
usable
with
MediaQueue
<
AudioData
>
"
)
;
RecursiveMutexAutoLock
lock
(
mRecursiveMutex
)
;
uint32_t
frames
=
0
;
for
(
size_t
i
=
0
;
i
<
GetSize
(
)
;
+
+
i
)
{
T
*
v
=
static_cast
<
T
*
>
(
ObjectAt
(
i
)
)
;
frames
+
=
v
-
>
Frames
(
)
;
}
return
frames
;
}
MediaEventSource
<
RefPtr
<
T
>
>
&
PopFrontEvent
(
)
{
return
mPopFrontEvent
;
}
MediaEventSource
<
RefPtr
<
T
>
>
&
PushEvent
(
)
{
return
mPushEvent
;
}
MediaEventSource
<
void
>
&
FinishEvent
(
)
{
return
mFinishEvent
;
}
private
:
mutable
RecursiveMutex
mRecursiveMutex
;
MediaEventProducer
<
RefPtr
<
T
>
>
mPopFrontEvent
;
MediaEventProducer
<
RefPtr
<
T
>
>
mPushEvent
;
MediaEventProducer
<
void
>
mFinishEvent
;
bool
mEndOfStream
;
}
;
}
#
endif
