#
ifndef
AudioPacketizer_h_
#
define
AudioPacketizer_h_
#
include
<
mozilla
/
PodOperations
.
h
>
#
include
<
mozilla
/
Assertions
.
h
>
#
include
<
mozilla
/
UniquePtr
.
h
>
#
include
<
AudioSampleFormat
.
h
>
namespace
mozilla
{
template
<
typename
InputType
typename
OutputType
>
class
AudioPacketizer
{
public
:
AudioPacketizer
(
uint32_t
aPacketSize
uint32_t
aChannels
)
:
mPacketSize
(
aPacketSize
)
mChannels
(
aChannels
)
mReadIndex
(
0
)
mWriteIndex
(
0
)
mStorage
(
new
InputType
[
aPacketSize
*
aChannels
]
)
mLength
(
aPacketSize
*
aChannels
)
{
MOZ_ASSERT
(
aPacketSize
>
0
&
&
aChannels
>
0
"
The
packet
size
and
the
number
of
channel
should
be
strictly
positive
"
)
;
}
void
Input
(
const
InputType
*
aFrames
uint32_t
aFrameCount
)
{
uint32_t
inputSamples
=
aFrameCount
*
mChannels
;
if
(
inputSamples
>
EmptySlots
(
)
)
{
uint32_t
newLength
=
AvailableSamples
(
)
+
inputSamples
;
uint32_t
toCopy
=
AvailableSamples
(
)
;
UniquePtr
<
InputType
[
]
>
oldStorage
=
mozilla
:
:
Move
(
mStorage
)
;
mStorage
=
mozilla
:
:
MakeUnique
<
InputType
[
]
>
(
newLength
)
;
if
(
WriteIndex
(
)
>
=
ReadIndex
(
)
)
{
PodCopy
(
mStorage
.
get
(
)
oldStorage
.
get
(
)
+
ReadIndex
(
)
AvailableSamples
(
)
)
;
}
else
{
uint32_t
firstPartLength
=
mLength
-
ReadIndex
(
)
;
uint32_t
secondPartLength
=
AvailableSamples
(
)
-
firstPartLength
;
PodCopy
(
mStorage
.
get
(
)
oldStorage
.
get
(
)
+
ReadIndex
(
)
firstPartLength
)
;
PodCopy
(
mStorage
.
get
(
)
+
firstPartLength
oldStorage
.
get
(
)
secondPartLength
)
;
}
mWriteIndex
=
toCopy
;
mReadIndex
=
0
;
mLength
=
newLength
;
}
if
(
WriteIndex
(
)
+
inputSamples
<
=
mLength
)
{
PodCopy
(
mStorage
.
get
(
)
+
WriteIndex
(
)
aFrames
aFrameCount
*
mChannels
)
;
}
else
{
uint32_t
firstPartLength
=
mLength
-
WriteIndex
(
)
;
uint32_t
secondPartLength
=
inputSamples
-
firstPartLength
;
PodCopy
(
mStorage
.
get
(
)
+
WriteIndex
(
)
aFrames
firstPartLength
)
;
PodCopy
(
mStorage
.
get
(
)
aFrames
+
firstPartLength
secondPartLength
)
;
}
mWriteIndex
+
=
inputSamples
;
}
OutputType
*
Output
(
)
{
uint32_t
samplesNeeded
=
mPacketSize
*
mChannels
;
OutputType
*
out
=
new
OutputType
[
samplesNeeded
]
;
Output
(
out
)
;
return
out
;
}
void
Output
(
OutputType
*
aOutputBuffer
)
{
uint32_t
samplesNeeded
=
mPacketSize
*
mChannels
;
if
(
AvailableSamples
(
)
<
samplesNeeded
)
{
#
ifdef
LOG_PACKETIZER_UNDERRUN
char
buf
[
256
]
;
snprintf
(
buf
256
"
AudioPacketizer
%
p
underrun
:
available
:
%
u
needed
:
%
u
\
n
"
this
AvailableSamples
(
)
samplesNeeded
)
;
NS_WARNING
(
buf
)
;
#
endif
uint32_t
zeros
=
samplesNeeded
-
AvailableSamples
(
)
;
PodZero
(
aOutputBuffer
+
AvailableSamples
(
)
zeros
)
;
samplesNeeded
-
=
zeros
;
}
if
(
ReadIndex
(
)
+
samplesNeeded
<
=
mLength
)
{
ConvertAudioSamples
<
InputType
OutputType
>
(
mStorage
.
get
(
)
+
ReadIndex
(
)
aOutputBuffer
samplesNeeded
)
;
}
else
{
uint32_t
firstPartLength
=
mLength
-
ReadIndex
(
)
;
uint32_t
secondPartLength
=
samplesNeeded
-
firstPartLength
;
ConvertAudioSamples
<
InputType
OutputType
>
(
mStorage
.
get
(
)
+
ReadIndex
(
)
aOutputBuffer
firstPartLength
)
;
ConvertAudioSamples
<
InputType
OutputType
>
(
mStorage
.
get
(
)
aOutputBuffer
+
firstPartLength
secondPartLength
)
;
}
mReadIndex
+
=
samplesNeeded
;
}
uint32_t
PacketsAvailable
(
)
const
{
return
AvailableSamples
(
)
/
mChannels
/
mPacketSize
;
}
bool
Empty
(
)
const
{
return
mWriteIndex
=
=
mReadIndex
;
}
bool
Full
(
)
const
{
return
mWriteIndex
-
mReadIndex
=
=
mLength
;
}
uint32_t
PacketSize
(
)
const
{
return
mPacketSize
;
}
uint32_t
Channels
(
)
const
{
return
mChannels
;
}
private
:
uint32_t
ReadIndex
(
)
const
{
return
mReadIndex
%
mLength
;
}
uint32_t
WriteIndex
(
)
const
{
return
mWriteIndex
%
mLength
;
}
uint32_t
AvailableSamples
(
)
const
{
return
mWriteIndex
-
mReadIndex
;
}
uint32_t
EmptySlots
(
)
const
{
return
mLength
-
AvailableSamples
(
)
;
}
uint32_t
mPacketSize
;
uint32_t
mChannels
;
uint64_t
mReadIndex
;
uint64_t
mWriteIndex
;
mozilla
:
:
UniquePtr
<
InputType
[
]
>
mStorage
;
uint32_t
mLength
;
}
;
}
#
endif
