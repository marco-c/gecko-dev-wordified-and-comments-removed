#
include
"
AudioSink
.
h
"
#
include
"
AudioConverter
.
h
"
#
include
"
MediaQueue
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
nsPrintfCString
.
h
"
namespace
mozilla
{
extern
LazyLogModule
gMediaDecoderLog
;
#
define
SINK_LOG
(
msg
.
.
.
)
\
MOZ_LOG
(
gMediaDecoderLog
LogLevel
:
:
Debug
\
(
"
AudioSink
=
%
p
"
msg
this
#
#
__VA_ARGS__
)
)
#
define
SINK_LOG_V
(
msg
.
.
.
)
\
MOZ_LOG
(
gMediaDecoderLog
LogLevel
:
:
Verbose
\
(
"
AudioSink
=
%
p
"
msg
this
#
#
__VA_ARGS__
)
)
static
const
int64_t
AUDIO_FUZZ_FRAMES
=
1
;
static
const
int32_t
LOW_AUDIO_USECS
=
300000
;
using
media
:
:
TimeUnit
;
AudioSink
:
:
AudioSink
(
AbstractThread
*
aThread
MediaQueue
<
AudioData
>
&
aAudioQueue
const
TimeUnit
&
aStartTime
const
AudioInfo
&
aInfo
)
:
mStartTime
(
aStartTime
)
mInfo
(
aInfo
)
mPlaying
(
true
)
mMonitor
(
"
AudioSink
"
)
mWritten
(
0
)
mErrored
(
false
)
mPlaybackComplete
(
false
)
mOwnerThread
(
aThread
)
mProcessedQueueLength
(
0
)
mFramesParsed
(
0
)
mIsAudioDataAudible
(
false
)
mAudioQueue
(
aAudioQueue
)
{
bool
resampling
=
StaticPrefs
:
:
media_resampling_enabled
(
)
;
if
(
resampling
)
{
mOutputRate
=
48000
;
}
else
if
(
mInfo
.
mRate
=
=
44100
|
|
mInfo
.
mRate
=
=
48000
)
{
mOutputRate
=
mInfo
.
mRate
;
}
else
{
mOutputRate
=
AudioStream
:
:
GetPreferredRate
(
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mOutputRate
"
output
rate
can
'
t
be
0
.
"
)
;
mOutputChannels
=
DecideAudioPlaybackChannels
(
mInfo
)
;
}
AudioSink
:
:
~
AudioSink
(
)
{
}
nsresult
AudioSink
:
:
Init
(
const
PlaybackParams
&
aParams
RefPtr
<
MediaSink
:
:
EndedPromise
>
&
aEndedPromise
)
{
MOZ_ASSERT
(
mOwnerThread
-
>
IsCurrentThreadIn
(
)
)
;
mAudioQueueListener
=
mAudioQueue
.
PushEvent
(
)
.
Connect
(
mOwnerThread
this
&
AudioSink
:
:
OnAudioPushed
)
;
mAudioQueueFinishListener
=
mAudioQueue
.
FinishEvent
(
)
.
Connect
(
mOwnerThread
this
&
AudioSink
:
:
NotifyAudioNeeded
)
;
mProcessedQueueListener
=
mProcessedQueue
.
PopFrontEvent
(
)
.
Connect
(
mOwnerThread
this
&
AudioSink
:
:
OnAudioPopped
)
;
NotifyAudioNeeded
(
)
;
aEndedPromise
=
mEndedPromise
.
Ensure
(
__func__
)
;
nsresult
rv
=
InitializeAudioStream
(
aParams
)
;
if
(
NS_FAILED
(
rv
)
)
{
mEndedPromise
.
Reject
(
rv
__func__
)
;
}
return
rv
;
}
TimeUnit
AudioSink
:
:
GetPosition
(
)
{
int64_t
tmp
;
if
(
mAudioStream
&
&
(
tmp
=
mAudioStream
-
>
GetPosition
(
)
)
>
=
0
)
{
TimeUnit
pos
=
TimeUnit
:
:
FromMicroseconds
(
tmp
)
;
NS_ASSERTION
(
pos
>
=
mLastGoodPosition
"
AudioStream
position
shouldn
'
t
go
backward
"
)
;
TimeUnit
tmp
=
mStartTime
+
pos
;
if
(
!
tmp
.
IsValid
(
)
)
{
mErrored
=
true
;
return
mStartTime
+
mLastGoodPosition
;
}
if
(
pos
>
=
mLastGoodPosition
)
{
mLastGoodPosition
=
pos
;
}
}
return
mStartTime
+
mLastGoodPosition
;
}
bool
AudioSink
:
:
HasUnplayedFrames
(
)
{
int64_t
total
;
{
MonitorAutoLock
mon
(
mMonitor
)
;
total
=
mWritten
+
(
mCursor
.
get
(
)
?
mCursor
-
>
Available
(
)
:
0
)
;
}
return
mProcessedQueue
.
GetSize
(
)
|
|
(
mAudioStream
&
&
mAudioStream
-
>
GetPositionInFrames
(
)
+
1
<
total
)
;
}
void
AudioSink
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
mOwnerThread
-
>
IsCurrentThreadIn
(
)
)
;
mAudioQueueListener
.
Disconnect
(
)
;
mAudioQueueFinishListener
.
Disconnect
(
)
;
mProcessedQueueListener
.
Disconnect
(
)
;
if
(
mAudioStream
)
{
mAudioStream
-
>
Shutdown
(
)
;
mAudioStream
=
nullptr
;
}
mProcessedQueue
.
Reset
(
)
;
mProcessedQueue
.
Finish
(
)
;
mEndedPromise
.
ResolveIfExists
(
true
__func__
)
;
}
void
AudioSink
:
:
SetVolume
(
double
aVolume
)
{
if
(
mAudioStream
)
{
mAudioStream
-
>
SetVolume
(
aVolume
)
;
}
}
void
AudioSink
:
:
SetPlaybackRate
(
double
aPlaybackRate
)
{
MOZ_ASSERT
(
aPlaybackRate
!
=
0
"
Don
'
t
set
the
playbackRate
to
0
on
AudioStream
"
)
;
if
(
mAudioStream
)
{
mAudioStream
-
>
SetPlaybackRate
(
aPlaybackRate
)
;
}
}
void
AudioSink
:
:
SetPreservesPitch
(
bool
aPreservesPitch
)
{
if
(
mAudioStream
)
{
mAudioStream
-
>
SetPreservesPitch
(
aPreservesPitch
)
;
}
}
void
AudioSink
:
:
SetPlaying
(
bool
aPlaying
)
{
if
(
!
mAudioStream
|
|
mPlaying
=
=
aPlaying
|
|
mPlaybackComplete
)
{
return
;
}
if
(
!
aPlaying
)
{
mAudioStream
-
>
Pause
(
)
;
}
else
if
(
aPlaying
)
{
mAudioStream
-
>
Resume
(
)
;
}
mPlaying
=
aPlaying
;
}
nsresult
AudioSink
:
:
InitializeAudioStream
(
const
PlaybackParams
&
aParams
)
{
mAudioStream
=
new
AudioStream
(
*
this
)
;
AudioConfig
:
:
ChannelLayout
:
:
ChannelMap
channelMap
=
mConverter
?
mConverter
-
>
OutputConfig
(
)
.
Layout
(
)
.
Map
(
)
:
AudioConfig
:
:
ChannelLayout
(
mOutputChannels
)
.
Map
(
)
;
nsresult
rv
=
mAudioStream
-
>
Init
(
mOutputChannels
channelMap
mOutputRate
aParams
.
mSink
)
;
if
(
NS_FAILED
(
rv
)
)
{
mAudioStream
-
>
Shutdown
(
)
;
mAudioStream
=
nullptr
;
return
rv
;
}
mAudioStream
-
>
SetVolume
(
aParams
.
mVolume
)
;
mAudioStream
-
>
SetPlaybackRate
(
aParams
.
mPlaybackRate
)
;
mAudioStream
-
>
SetPreservesPitch
(
aParams
.
mPreservesPitch
)
;
return
mAudioStream
-
>
Start
(
)
;
}
TimeUnit
AudioSink
:
:
GetEndTime
(
)
const
{
int64_t
written
;
{
MonitorAutoLock
mon
(
mMonitor
)
;
written
=
mWritten
;
}
TimeUnit
played
=
FramesToTimeUnit
(
written
mOutputRate
)
+
mStartTime
;
if
(
!
played
.
IsValid
(
)
)
{
NS_WARNING
(
"
Int
overflow
calculating
audio
end
time
"
)
;
return
TimeUnit
:
:
Zero
(
)
;
}
return
std
:
:
min
(
mLastEndTime
played
)
;
}
UniquePtr
<
AudioStream
:
:
Chunk
>
AudioSink
:
:
PopFrames
(
uint32_t
aFrames
)
{
class
Chunk
:
public
AudioStream
:
:
Chunk
{
public
:
Chunk
(
AudioData
*
aBuffer
uint32_t
aFrames
AudioDataValue
*
aData
)
:
mBuffer
(
aBuffer
)
mFrames
(
aFrames
)
mData
(
aData
)
{
}
Chunk
(
)
:
mFrames
(
0
)
mData
(
nullptr
)
{
}
const
AudioDataValue
*
Data
(
)
const
override
{
return
mData
;
}
uint32_t
Frames
(
)
const
override
{
return
mFrames
;
}
uint32_t
Channels
(
)
const
override
{
return
mBuffer
?
mBuffer
-
>
mChannels
:
0
;
}
uint32_t
Rate
(
)
const
override
{
return
mBuffer
?
mBuffer
-
>
mRate
:
0
;
}
AudioDataValue
*
GetWritable
(
)
const
override
{
return
mData
;
}
private
:
const
RefPtr
<
AudioData
>
mBuffer
;
const
uint32_t
mFrames
;
AudioDataValue
*
const
mData
;
}
;
bool
needPopping
=
false
;
if
(
!
mCurrentData
)
{
if
(
!
mProcessedQueue
.
GetSize
(
)
)
{
return
MakeUnique
<
Chunk
>
(
)
;
}
needPopping
=
true
;
mCurrentData
=
mProcessedQueue
.
PeekFront
(
)
;
{
MonitorAutoLock
mon
(
mMonitor
)
;
mCursor
=
MakeUnique
<
AudioBufferCursor
>
(
mCurrentData
-
>
Data
(
)
mCurrentData
-
>
mChannels
mCurrentData
-
>
Frames
(
)
)
;
}
MOZ_ASSERT
(
mCurrentData
-
>
Frames
(
)
>
0
)
;
mProcessedQueueLength
-
=
FramesToUsecs
(
mCurrentData
-
>
Frames
(
)
mOutputRate
)
.
value
(
)
;
}
auto
framesToPop
=
std
:
:
min
(
aFrames
mCursor
-
>
Available
(
)
)
;
SINK_LOG_V
(
"
playing
audio
at
time
=
%
"
PRId64
"
offset
=
%
u
length
=
%
u
"
mCurrentData
-
>
mTime
.
ToMicroseconds
(
)
mCurrentData
-
>
Frames
(
)
-
mCursor
-
>
Available
(
)
framesToPop
)
;
UniquePtr
<
AudioStream
:
:
Chunk
>
chunk
=
MakeUnique
<
Chunk
>
(
mCurrentData
framesToPop
mCursor
-
>
Ptr
(
)
)
;
{
MonitorAutoLock
mon
(
mMonitor
)
;
mWritten
+
=
framesToPop
;
mCursor
-
>
Advance
(
framesToPop
)
;
}
if
(
!
mCursor
-
>
Available
(
)
)
{
mCurrentData
=
nullptr
;
}
if
(
needPopping
)
{
RefPtr
<
AudioData
>
releaseMe
=
mProcessedQueue
.
PopFront
(
)
;
CheckIsAudible
(
releaseMe
)
;
}
return
chunk
;
}
bool
AudioSink
:
:
Ended
(
)
const
{
return
mProcessedQueue
.
IsFinished
(
)
|
|
mErrored
;
}
void
AudioSink
:
:
Drained
(
)
{
SINK_LOG
(
"
Drained
"
)
;
mPlaybackComplete
=
true
;
mEndedPromise
.
ResolveIfExists
(
true
__func__
)
;
}
void
AudioSink
:
:
Errored
(
)
{
SINK_LOG
(
"
Errored
"
)
;
mPlaybackComplete
=
true
;
mEndedPromise
.
RejectIfExists
(
NS_ERROR_FAILURE
__func__
)
;
}
void
AudioSink
:
:
CheckIsAudible
(
const
AudioData
*
aData
)
{
MOZ_ASSERT
(
aData
)
;
bool
isAudible
=
aData
-
>
IsAudible
(
)
;
if
(
isAudible
!
=
mIsAudioDataAudible
)
{
mIsAudioDataAudible
=
isAudible
;
mAudibleEvent
.
Notify
(
mIsAudioDataAudible
)
;
}
}
void
AudioSink
:
:
OnAudioPopped
(
const
RefPtr
<
AudioData
>
&
aSample
)
{
SINK_LOG_V
(
"
AudioStream
has
used
an
audio
packet
.
"
)
;
NotifyAudioNeeded
(
)
;
}
void
AudioSink
:
:
OnAudioPushed
(
const
RefPtr
<
AudioData
>
&
aSample
)
{
SINK_LOG_V
(
"
One
new
audio
packet
available
.
"
)
;
NotifyAudioNeeded
(
)
;
}
void
AudioSink
:
:
NotifyAudioNeeded
(
)
{
MOZ_ASSERT
(
mOwnerThread
-
>
IsCurrentThreadIn
(
)
"
Not
called
from
the
owner
'
s
thread
"
)
;
while
(
mAudioQueue
.
GetSize
(
)
&
&
(
mAudioQueue
.
IsFinished
(
)
|
|
mProcessedQueueLength
<
LOW_AUDIO_USECS
|
|
mProcessedQueue
.
GetSize
(
)
<
2
)
)
{
RefPtr
<
AudioData
>
data
=
mAudioQueue
.
PopFront
(
)
;
if
(
!
data
-
>
Frames
(
)
)
{
continue
;
}
if
(
!
mConverter
|
|
(
data
-
>
mRate
!
=
mConverter
-
>
InputConfig
(
)
.
Rate
(
)
|
|
data
-
>
mChannels
!
=
mConverter
-
>
InputConfig
(
)
.
Channels
(
)
)
)
{
SINK_LOG_V
(
"
Audio
format
changed
from
%
u
%
uHz
to
%
u
%
uHz
"
mConverter
?
mConverter
-
>
InputConfig
(
)
.
Channels
(
)
:
0
mConverter
?
mConverter
-
>
InputConfig
(
)
.
Rate
(
)
:
0
data
-
>
mChannels
data
-
>
mRate
)
;
DrainConverter
(
)
;
if
(
mFramesParsed
)
{
uint32_t
oldRate
=
mConverter
-
>
InputConfig
(
)
.
Rate
(
)
;
uint32_t
newRate
=
data
-
>
mRate
;
CheckedInt64
result
=
SaferMultDiv
(
mFramesParsed
newRate
oldRate
)
;
if
(
!
result
.
isValid
(
)
)
{
NS_WARNING
(
"
Int
overflow
in
AudioSink
"
)
;
mErrored
=
true
;
return
;
}
mFramesParsed
=
result
.
value
(
)
;
}
const
AudioConfig
:
:
ChannelLayout
inputLayout
=
data
-
>
mChannelMap
?
AudioConfig
:
:
ChannelLayout
:
:
SMPTEDefault
(
data
-
>
mChannelMap
)
:
AudioConfig
:
:
ChannelLayout
(
data
-
>
mChannels
)
;
const
AudioConfig
:
:
ChannelLayout
outputLayout
=
mOutputChannels
=
=
data
-
>
mChannels
?
inputLayout
:
AudioConfig
:
:
ChannelLayout
(
mOutputChannels
)
;
mConverter
=
MakeUnique
<
AudioConverter
>
(
AudioConfig
(
inputLayout
data
-
>
mChannels
data
-
>
mRate
)
AudioConfig
(
outputLayout
mOutputChannels
mOutputRate
)
)
;
}
CheckedInt64
sampleTime
=
TimeUnitToFrames
(
data
-
>
mTime
-
mStartTime
data
-
>
mRate
)
;
CheckedInt64
missingFrames
=
sampleTime
-
mFramesParsed
;
if
(
!
missingFrames
.
isValid
(
)
|
|
!
sampleTime
.
isValid
(
)
)
{
NS_WARNING
(
"
Int
overflow
in
AudioSink
"
)
;
mErrored
=
true
;
return
;
}
if
(
missingFrames
.
value
(
)
>
AUDIO_FUZZ_FRAMES
)
{
missingFrames
=
std
:
:
min
<
int64_t
>
(
INT32_MAX
missingFrames
.
value
(
)
)
;
mFramesParsed
+
=
missingFrames
.
value
(
)
;
RefPtr
<
AudioData
>
silenceData
;
AlignedAudioBuffer
silenceBuffer
(
missingFrames
.
value
(
)
*
data
-
>
mChannels
)
;
if
(
!
silenceBuffer
)
{
NS_WARNING
(
"
OOM
in
AudioSink
"
)
;
mErrored
=
true
;
return
;
}
if
(
mConverter
-
>
InputConfig
(
)
!
=
mConverter
-
>
OutputConfig
(
)
)
{
AlignedAudioBuffer
convertedData
=
mConverter
-
>
Process
(
AudioSampleBuffer
(
std
:
:
move
(
silenceBuffer
)
)
)
.
Forget
(
)
;
silenceData
=
CreateAudioFromBuffer
(
std
:
:
move
(
convertedData
)
data
)
;
}
else
{
silenceData
=
CreateAudioFromBuffer
(
std
:
:
move
(
silenceBuffer
)
data
)
;
}
PushProcessedAudio
(
silenceData
)
;
}
mLastEndTime
=
data
-
>
GetEndTime
(
)
;
mFramesParsed
+
=
data
-
>
Frames
(
)
;
if
(
mConverter
-
>
InputConfig
(
)
!
=
mConverter
-
>
OutputConfig
(
)
)
{
AlignedAudioBuffer
buffer
(
data
-
>
MoveableData
(
)
)
;
AlignedAudioBuffer
convertedData
=
mConverter
-
>
Process
(
AudioSampleBuffer
(
std
:
:
move
(
buffer
)
)
)
.
Forget
(
)
;
data
=
CreateAudioFromBuffer
(
std
:
:
move
(
convertedData
)
data
)
;
}
if
(
PushProcessedAudio
(
data
)
)
{
mLastProcessedPacket
=
Some
(
data
)
;
}
}
if
(
mAudioQueue
.
IsFinished
(
)
)
{
DrainConverter
(
)
;
mProcessedQueue
.
Finish
(
)
;
}
}
uint32_t
AudioSink
:
:
PushProcessedAudio
(
AudioData
*
aData
)
{
if
(
!
aData
|
|
!
aData
-
>
Frames
(
)
)
{
return
0
;
}
mProcessedQueue
.
Push
(
aData
)
;
mProcessedQueueLength
+
=
FramesToUsecs
(
aData
-
>
Frames
(
)
mOutputRate
)
.
value
(
)
;
return
aData
-
>
Frames
(
)
;
}
already_AddRefed
<
AudioData
>
AudioSink
:
:
CreateAudioFromBuffer
(
AlignedAudioBuffer
&
&
aBuffer
AudioData
*
aReference
)
{
uint32_t
frames
=
aBuffer
.
Length
(
)
/
mOutputChannels
;
if
(
!
frames
)
{
return
nullptr
;
}
auto
duration
=
FramesToTimeUnit
(
frames
mOutputRate
)
;
if
(
!
duration
.
IsValid
(
)
)
{
NS_WARNING
(
"
Int
overflow
in
AudioSink
"
)
;
mErrored
=
true
;
return
nullptr
;
}
RefPtr
<
AudioData
>
data
=
new
AudioData
(
aReference
-
>
mOffset
aReference
-
>
mTime
std
:
:
move
(
aBuffer
)
mOutputChannels
mOutputRate
)
;
MOZ_DIAGNOSTIC_ASSERT
(
duration
=
=
data
-
>
mDuration
"
must
be
equal
"
)
;
return
data
.
forget
(
)
;
}
uint32_t
AudioSink
:
:
DrainConverter
(
uint32_t
aMaxFrames
)
{
MOZ_ASSERT
(
mOwnerThread
-
>
IsCurrentThreadIn
(
)
)
;
if
(
!
mConverter
|
|
!
mLastProcessedPacket
|
|
!
aMaxFrames
)
{
return
0
;
}
RefPtr
<
AudioData
>
lastPacket
=
mLastProcessedPacket
.
ref
(
)
;
mLastProcessedPacket
.
reset
(
)
;
AlignedAudioBuffer
convertedData
=
mConverter
-
>
Process
(
AudioSampleBuffer
(
AlignedAudioBuffer
(
)
)
)
.
Forget
(
)
;
uint32_t
frames
=
convertedData
.
Length
(
)
/
mOutputChannels
;
if
(
!
convertedData
.
SetLength
(
std
:
:
min
(
frames
aMaxFrames
)
*
mOutputChannels
)
)
{
mErrored
=
true
;
return
0
;
}
RefPtr
<
AudioData
>
data
=
CreateAudioFromBuffer
(
std
:
:
move
(
convertedData
)
lastPacket
)
;
if
(
!
data
)
{
return
0
;
}
mProcessedQueue
.
Push
(
data
)
;
return
data
-
>
Frames
(
)
;
}
void
AudioSink
:
:
GetDebugInfo
(
dom
:
:
MediaSinkDebugInfo
&
aInfo
)
{
MOZ_ASSERT
(
mOwnerThread
-
>
IsCurrentThreadIn
(
)
)
;
aInfo
.
mAudioSinkWrapper
.
mAudioSink
.
mStartTime
=
mStartTime
.
ToMicroseconds
(
)
;
aInfo
.
mAudioSinkWrapper
.
mAudioSink
.
mLastGoodPosition
=
mLastGoodPosition
.
ToMicroseconds
(
)
;
aInfo
.
mAudioSinkWrapper
.
mAudioSink
.
mIsPlaying
=
mPlaying
;
aInfo
.
mAudioSinkWrapper
.
mAudioSink
.
mOutputRate
=
mOutputRate
;
aInfo
.
mAudioSinkWrapper
.
mAudioSink
.
mWritten
=
mWritten
;
aInfo
.
mAudioSinkWrapper
.
mAudioSink
.
mHasErrored
=
bool
(
mErrored
)
;
aInfo
.
mAudioSinkWrapper
.
mAudioSink
.
mPlaybackComplete
=
bool
(
mPlaybackComplete
)
;
}
}
