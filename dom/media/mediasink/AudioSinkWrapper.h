#
ifndef
AudioSinkWrapper_h_
#
define
AudioSinkWrapper_h_
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
AudioSink
.
h
"
#
include
"
MediaSink
.
h
"
namespace
mozilla
{
class
MediaData
;
template
<
class
T
>
class
MediaQueue
;
class
AudioSinkWrapper
:
public
MediaSink
{
using
PlaybackParams
=
AudioSink
:
:
PlaybackParams
;
class
Creator
{
public
:
virtual
~
Creator
(
)
=
default
;
virtual
AudioSink
*
Create
(
)
=
0
;
}
;
template
<
typename
Function
>
class
CreatorImpl
:
public
Creator
{
public
:
explicit
CreatorImpl
(
const
Function
&
aFunc
)
:
mFunction
(
aFunc
)
{
}
AudioSink
*
Create
(
)
override
{
return
mFunction
(
)
;
}
private
:
Function
mFunction
;
}
;
public
:
template
<
typename
Function
>
AudioSinkWrapper
(
AbstractThread
*
aOwnerThread
MediaQueue
<
AudioData
>
&
aAudioQueue
const
Function
&
aFunc
double
aVolume
double
aPlaybackRate
bool
aPreservesPitch
)
:
mOwnerThread
(
aOwnerThread
)
mCreator
(
new
CreatorImpl
<
Function
>
(
aFunc
)
)
mIsStarted
(
false
)
mParams
(
aVolume
aPlaybackRate
aPreservesPitch
)
mPlayDuration
(
media
:
:
TimeUnit
:
:
Invalid
(
)
)
mAudioEnded
(
true
)
mAudioQueue
(
aAudioQueue
)
{
}
RefPtr
<
EndedPromise
>
OnEnded
(
TrackType
aType
)
override
;
media
:
:
TimeUnit
GetEndTime
(
TrackType
aType
)
const
override
;
media
:
:
TimeUnit
GetPosition
(
TimeStamp
*
aTimeStamp
=
nullptr
)
override
;
bool
HasUnplayedFrames
(
TrackType
aType
)
const
override
;
media
:
:
TimeUnit
UnplayedDuration
(
TrackType
aType
)
const
override
;
void
DropAudioPacketsIfNeeded
(
const
media
:
:
TimeUnit
&
aMediaPosition
)
;
void
SetVolume
(
double
aVolume
)
override
;
void
SetStreamName
(
const
nsAString
&
aStreamName
)
override
;
void
SetPlaybackRate
(
double
aPlaybackRate
)
override
;
void
SetPreservesPitch
(
bool
aPreservesPitch
)
override
;
void
SetPlaying
(
bool
aPlaying
)
override
;
double
PlaybackRate
(
)
const
override
;
nsresult
Start
(
const
media
:
:
TimeUnit
&
aStartTime
const
MediaInfo
&
aInfo
)
override
;
void
Stop
(
)
override
;
bool
IsStarted
(
)
const
override
;
bool
IsPlaying
(
)
const
override
;
void
Shutdown
(
)
override
;
void
GetDebugInfo
(
dom
:
:
MediaSinkDebugInfo
&
aInfo
)
override
;
private
:
enum
class
ClockSource
{
AudioStream
SystemClock
Paused
}
mLastClockSource
=
ClockSource
:
:
Paused
;
bool
IsMuted
(
)
const
;
void
OnMuted
(
bool
aMuted
)
;
virtual
~
AudioSinkWrapper
(
)
;
void
AssertOwnerThread
(
)
const
{
MOZ_ASSERT
(
mOwnerThread
-
>
IsCurrentThreadIn
(
)
)
;
}
enum
class
AudioSinkStartPolicy
{
SYNC
ASYNC
}
;
nsresult
StartAudioSink
(
const
media
:
:
TimeUnit
&
aStartTime
AudioSinkStartPolicy
aPolicy
)
;
media
:
:
TimeUnit
GetSystemClockPosition
(
TimeStamp
aNow
)
const
;
bool
CheckIfEnded
(
)
const
;
void
OnAudioEnded
(
)
;
bool
IsAudioSourceEnded
(
const
MediaInfo
&
aInfo
)
const
;
const
RefPtr
<
AbstractThread
>
mOwnerThread
;
UniquePtr
<
Creator
>
mCreator
;
UniquePtr
<
AudioSink
>
mAudioSink
;
RefPtr
<
EndedPromise
>
mEndedPromise
;
MozPromiseHolder
<
EndedPromise
>
mEndedPromiseHolder
;
bool
mIsStarted
;
PlaybackParams
mParams
;
TimeStamp
mPlayStartTime
;
media
:
:
TimeUnit
mPlayDuration
;
bool
mAudioEnded
;
MozPromiseRequestHolder
<
EndedPromise
>
mAudioSinkEndedPromise
;
MediaQueue
<
AudioData
>
&
mAudioQueue
;
}
;
}
#
endif
