#
include
"
MediaStreamGraph
.
h
"
#
include
"
OutputStreamManager
.
h
"
namespace
mozilla
{
OutputStreamData
:
:
~
OutputStreamData
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
RefPtr
<
MediaInputPort
>
&
port
:
mPorts
)
{
port
-
>
Destroy
(
)
;
}
}
void
OutputStreamData
:
:
Init
(
OutputStreamManager
*
aOwner
ProcessedMediaStream
*
aStream
TrackID
aNextAvailableTrackID
)
{
mOwner
=
aOwner
;
mStream
=
aStream
;
mNextAvailableTrackID
=
aNextAvailableTrackID
;
}
bool
OutputStreamData
:
:
Connect
(
MediaStream
*
aStream
TrackID
aInputAudioTrackID
TrackID
aInputVideoTrackID
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mPorts
.
IsEmpty
(
)
"
Already
connected
?
"
)
;
if
(
mStream
-
>
IsDestroyed
(
)
)
{
return
false
;
}
for
(
TrackID
tid
:
{
aInputAudioTrackID
aInputVideoTrackID
}
)
{
if
(
tid
=
=
TRACK_NONE
)
{
continue
;
}
MOZ_ASSERT
(
IsTrackIDExplicit
(
tid
)
)
;
mPorts
.
AppendElement
(
mStream
-
>
AllocateInputPort
(
aStream
tid
mNextAvailableTrackID
+
+
)
)
;
}
return
true
;
}
bool
OutputStreamData
:
:
Disconnect
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mStream
-
>
IsDestroyed
(
)
)
{
return
false
;
}
for
(
RefPtr
<
MediaInputPort
>
&
port
:
mPorts
)
{
port
-
>
Destroy
(
)
;
}
mPorts
.
Clear
(
)
;
return
true
;
}
bool
OutputStreamData
:
:
Equals
(
MediaStream
*
aStream
)
const
{
return
mStream
=
=
aStream
;
}
MediaStreamGraph
*
OutputStreamData
:
:
Graph
(
)
const
{
return
mStream
-
>
Graph
(
)
;
}
TrackID
OutputStreamData
:
:
NextAvailableTrackID
(
)
const
{
return
mNextAvailableTrackID
;
}
void
OutputStreamManager
:
:
Add
(
ProcessedMediaStream
*
aStream
TrackID
aNextAvailableTrackID
bool
aFinishWhenEnded
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
Graph
(
)
|
|
Graph
(
)
=
=
aStream
-
>
Graph
(
)
)
;
if
(
aFinishWhenEnded
)
{
aStream
-
>
QueueSetAutofinish
(
true
)
;
}
OutputStreamData
*
p
=
mStreams
.
AppendElement
(
)
;
p
-
>
Init
(
this
aStream
aNextAvailableTrackID
)
;
if
(
mInputStream
)
{
p
-
>
Connect
(
mInputStream
mInputAudioTrackID
mInputVideoTrackID
)
;
}
}
void
OutputStreamManager
:
:
Remove
(
MediaStream
*
aStream
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
int32_t
i
=
mStreams
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
mStreams
[
i
]
.
Equals
(
aStream
)
)
{
mStreams
.
RemoveElementAt
(
i
)
;
break
;
}
}
}
void
OutputStreamManager
:
:
Clear
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mStreams
.
Clear
(
)
;
}
TrackID
OutputStreamManager
:
:
NextAvailableTrackIDFor
(
MediaStream
*
aOutputStream
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
const
OutputStreamData
&
out
:
mStreams
)
{
if
(
out
.
Equals
(
aOutputStream
)
)
{
return
out
.
NextAvailableTrackID
(
)
;
}
}
return
TRACK_INVALID
;
}
void
OutputStreamManager
:
:
Connect
(
MediaStream
*
aStream
TrackID
aAudioTrackID
TrackID
aVideoTrackID
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mInputStream
=
aStream
;
mInputAudioTrackID
=
aAudioTrackID
;
mInputVideoTrackID
=
aVideoTrackID
;
for
(
int32_t
i
=
mStreams
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
!
mStreams
[
i
]
.
Connect
(
aStream
mInputAudioTrackID
mInputVideoTrackID
)
)
{
mStreams
.
RemoveElementAt
(
i
)
;
}
}
}
void
OutputStreamManager
:
:
Disconnect
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mInputStream
=
nullptr
;
mInputAudioTrackID
=
TRACK_INVALID
;
mInputVideoTrackID
=
TRACK_INVALID
;
for
(
int32_t
i
=
mStreams
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
!
mStreams
[
i
]
.
Disconnect
(
)
)
{
mStreams
.
RemoveElementAt
(
i
)
;
}
}
}
}
