#
if
!
defined
(
DecodedAudioDataSink_h__
)
#
define
DecodedAudioDataSink_h__
#
include
"
AudioSink
.
h
"
#
include
"
AudioStream
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
MediaQueue
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
mozilla
/
dom
/
AudioChannelBinding
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
namespace
mozilla
{
class
AudioConverter
;
namespace
media
{
class
DecodedAudioDataSink
:
public
AudioSink
private
AudioStream
:
:
DataSource
{
public
:
DecodedAudioDataSink
(
AbstractThread
*
aThread
MediaQueue
<
MediaData
>
&
aAudioQueue
int64_t
aStartTime
const
AudioInfo
&
aInfo
dom
:
:
AudioChannel
aChannel
)
;
RefPtr
<
GenericPromise
>
Init
(
const
PlaybackParams
&
aParams
)
override
;
int64_t
GetPosition
(
)
override
;
int64_t
GetEndTime
(
)
const
override
;
bool
HasUnplayedFrames
(
)
override
;
void
Shutdown
(
)
override
;
void
SetVolume
(
double
aVolume
)
override
;
void
SetPlaybackRate
(
double
aPlaybackRate
)
override
;
void
SetPreservesPitch
(
bool
aPreservesPitch
)
override
;
void
SetPlaying
(
bool
aPlaying
)
override
;
MediaEventSource
<
bool
>
&
AudibleEvent
(
)
{
return
mAudibleEvent
;
}
private
:
virtual
~
DecodedAudioDataSink
(
)
;
nsresult
InitializeAudioStream
(
const
PlaybackParams
&
aParams
)
;
UniquePtr
<
AudioStream
:
:
Chunk
>
PopFrames
(
uint32_t
aFrames
)
override
;
bool
Ended
(
)
const
override
;
void
Drained
(
)
override
;
void
CheckIsAudible
(
const
AudioData
*
aData
)
;
RefPtr
<
AudioStream
>
mAudioStream
;
const
int64_t
mStartTime
;
int64_t
mLastGoodPosition
;
const
AudioInfo
mInfo
;
const
dom
:
:
AudioChannel
mChannel
;
bool
mPlaying
;
MozPromiseHolder
<
GenericPromise
>
mEndPromise
;
RefPtr
<
AudioData
>
mCurrentData
;
mutable
Monitor
mMonitor
;
UniquePtr
<
AudioBufferCursor
>
mCursor
;
int64_t
mWritten
;
Atomic
<
bool
>
mErrored
;
Atomic
<
bool
>
mPlaybackComplete
;
const
RefPtr
<
AbstractThread
>
mOwnerThread
;
void
OnAudioPopped
(
const
RefPtr
<
MediaData
>
&
aSample
)
;
void
OnAudioPushed
(
const
RefPtr
<
MediaData
>
&
aSample
)
;
void
NotifyAudioNeeded
(
)
;
uint32_t
DrainConverter
(
uint32_t
aMaxFrames
=
UINT32_MAX
)
;
already_AddRefed
<
AudioData
>
CreateAudioFromBuffer
(
AlignedAudioBuffer
&
&
aBuffer
AudioData
*
aReference
)
;
uint32_t
PushProcessedAudio
(
AudioData
*
aData
)
;
UniquePtr
<
AudioConverter
>
mConverter
;
MediaQueue
<
AudioData
>
mProcessedQueue
;
Atomic
<
int32_t
>
mProcessedQueueLength
;
MediaEventListener
mAudioQueueListener
;
MediaEventListener
mAudioQueueFinishListener
;
MediaEventListener
mProcessedQueueListener
;
int64_t
mFramesParsed
;
Maybe
<
RefPtr
<
AudioData
>
>
mLastProcessedPacket
;
int64_t
mLastEndTime
;
uint32_t
mOutputRate
;
uint32_t
mOutputChannels
;
bool
mIsAudioDataAudible
;
MediaEventProducer
<
bool
>
mAudibleEvent
;
}
;
}
}
#
endif
