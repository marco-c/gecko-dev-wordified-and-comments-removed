#
ifndef
OutputStreamManager_h
#
define
OutputStreamManager_h
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
TrackID
.
h
"
namespace
mozilla
{
class
DOMMediaStream
;
class
MediaInputPort
;
class
MediaStream
;
class
OutputStreamManager
;
class
ProcessedMediaStream
;
class
SourceMediaStream
;
namespace
dom
{
class
MediaStreamTrack
;
}
class
OutputStreamData
{
public
:
OutputStreamData
(
OutputStreamManager
*
aManager
AbstractThread
*
aAbstractMainThread
DOMMediaStream
*
aDOMStream
)
;
OutputStreamData
(
const
OutputStreamData
&
aOther
)
=
delete
;
OutputStreamData
(
OutputStreamData
&
&
aOther
)
=
delete
;
~
OutputStreamData
(
)
;
void
AddTrack
(
TrackID
aTrackID
MediaSegment
:
:
Type
aType
nsIPrincipal
*
aPrincipal
bool
aAsyncAddTrack
)
;
void
RemoveTrack
(
TrackID
aTrackID
)
;
void
SetPrincipal
(
nsIPrincipal
*
aPrincipal
)
;
const
RefPtr
<
OutputStreamManager
>
mManager
;
const
RefPtr
<
AbstractThread
>
mAbstractMainThread
;
const
WeakPtr
<
DOMMediaStream
>
mDOMStream
;
const
RefPtr
<
ProcessedMediaStream
>
mInputStream
;
private
:
const
RefPtr
<
MediaInputPort
>
mPort
;
nsTArray
<
WeakPtr
<
dom
:
:
MediaStreamTrack
>
>
mTracks
;
}
;
class
OutputStreamManager
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
OutputStreamManager
)
;
public
:
explicit
OutputStreamManager
(
SourceMediaStream
*
aSourceStream
TrackID
aNextTrackID
nsIPrincipal
*
aPrincipal
AbstractThread
*
aAbstractMainThread
)
;
void
Add
(
DOMMediaStream
*
aDOMStream
)
;
void
Remove
(
DOMMediaStream
*
aDOMStream
)
;
bool
HasTrackType
(
MediaSegment
:
:
Type
aType
)
;
bool
HasTracks
(
TrackID
aAudioTrack
TrackID
aVideoTrack
)
;
size_t
NumberOfTracks
(
)
;
void
AddTrack
(
MediaSegment
:
:
Type
aType
)
;
void
RemoveTracks
(
)
;
void
Disconnect
(
)
;
AbstractCanonical
<
PrincipalHandle
>
*
CanonicalPrincipalHandle
(
)
;
void
SetPrincipal
(
nsIPrincipal
*
aPrincipal
)
;
TrackID
NextTrackID
(
)
const
;
TrackID
GetLiveTrackIDFor
(
MediaSegment
:
:
Type
aType
)
const
;
void
SetPlaying
(
bool
aPlaying
)
;
bool
IsEmpty
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mStreams
.
IsEmpty
(
)
;
}
const
RefPtr
<
SourceMediaStream
>
mSourceStream
;
const
RefPtr
<
AbstractThread
>
mAbstractMainThread
;
private
:
~
OutputStreamManager
(
)
=
default
;
struct
StreamComparator
{
static
bool
Equals
(
const
UniquePtr
<
OutputStreamData
>
&
aData
DOMMediaStream
*
aStream
)
{
return
aData
-
>
mDOMStream
=
=
aStream
;
}
}
;
struct
TrackIDComparator
{
static
bool
Equals
(
const
Pair
<
TrackID
MediaSegment
:
:
Type
>
&
aLiveTrack
TrackID
aTrackID
)
{
return
aLiveTrack
.
first
(
)
=
=
aTrackID
;
}
}
;
struct
TrackTypeComparator
{
static
bool
Equals
(
const
Pair
<
TrackID
MediaSegment
:
:
Type
>
&
aLiveTrack
MediaSegment
:
:
Type
aType
)
{
return
aLiveTrack
.
second
(
)
=
=
aType
;
}
}
;
struct
TrackComparator
{
static
bool
Equals
(
const
Pair
<
TrackID
MediaSegment
:
:
Type
>
&
aLiveTrack
const
Pair
<
TrackID
MediaSegment
:
:
Type
>
&
aOther
)
{
return
aLiveTrack
.
first
(
)
=
=
aOther
.
first
(
)
&
&
aLiveTrack
.
second
(
)
=
=
aOther
.
second
(
)
;
}
}
;
void
AutoRemoveDestroyedStreams
(
)
;
void
RemoveTrack
(
TrackID
aTrackID
)
;
nsTArray
<
UniquePtr
<
OutputStreamData
>
>
mStreams
;
nsTArray
<
Pair
<
TrackID
MediaSegment
:
:
Type
>
>
mLiveTracks
;
Canonical
<
PrincipalHandle
>
mPrincipalHandle
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
TrackID
mNextTrackID
;
bool
mPlaying
;
}
;
}
#
endif
