#
ifndef
OutputStreamManager_h
#
define
OutputStreamManager_h
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
TrackID
.
h
"
namespace
mozilla
{
class
MediaInputPort
;
class
MediaStream
;
class
MediaStreamGraph
;
class
OutputStreamManager
;
class
ProcessedMediaStream
;
class
OutputStreamData
{
public
:
~
OutputStreamData
(
)
;
void
Init
(
OutputStreamManager
*
aOwner
ProcessedMediaStream
*
aStream
TrackID
aNextAvailableTrackID
)
;
bool
Connect
(
MediaStream
*
aStream
TrackID
aAudioTrackID
TrackID
aVideoTrackID
)
;
bool
Disconnect
(
)
;
bool
Equals
(
MediaStream
*
aStream
)
const
;
MediaStreamGraph
*
Graph
(
)
const
;
TrackID
NextAvailableTrackID
(
)
const
;
private
:
OutputStreamManager
*
mOwner
;
RefPtr
<
ProcessedMediaStream
>
mStream
;
nsTArray
<
RefPtr
<
MediaInputPort
>
>
mPorts
;
TrackID
mNextAvailableTrackID
=
TRACK_INVALID
;
}
;
class
OutputStreamManager
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
OutputStreamManager
)
;
public
:
void
Add
(
ProcessedMediaStream
*
aStream
TrackID
aNextAvailableTrackID
bool
aFinishWhenEnded
)
;
void
Remove
(
MediaStream
*
aStream
)
;
void
Clear
(
)
;
TrackID
NextAvailableTrackIDFor
(
MediaStream
*
aOutputStream
)
const
;
bool
IsEmpty
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mStreams
.
IsEmpty
(
)
;
}
void
Connect
(
MediaStream
*
aStream
TrackID
aAudioTrackID
TrackID
aVideoTrackID
)
;
void
Disconnect
(
)
;
MediaStreamGraph
*
Graph
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
!
IsEmpty
(
)
?
mStreams
[
0
]
.
Graph
(
)
:
nullptr
;
}
private
:
~
OutputStreamManager
(
)
{
}
RefPtr
<
MediaStream
>
mInputStream
;
TrackID
mInputAudioTrackID
=
TRACK_INVALID
;
TrackID
mInputVideoTrackID
=
TRACK_INVALID
;
nsTArray
<
OutputStreamData
>
mStreams
;
}
;
}
#
endif
