#
ifndef
OutputStreamManager_h
#
define
OutputStreamManager_h
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
TrackID
.
h
"
namespace
mozilla
{
class
DOMMediaStream
;
class
MediaInputPort
;
class
MediaStream
;
class
OutputStreamManager
;
class
ProcessedMediaStream
;
class
SourceMediaStream
;
namespace
dom
{
class
MediaStreamTrack
;
}
class
OutputStreamData
{
public
:
OutputStreamData
(
OutputStreamManager
*
aManager
AbstractThread
*
aAbstractMainThread
DOMMediaStream
*
aDOMStream
)
;
OutputStreamData
(
const
OutputStreamData
&
aOther
)
=
delete
;
OutputStreamData
(
OutputStreamData
&
&
aOther
)
=
delete
;
~
OutputStreamData
(
)
;
void
AddTrack
(
SourceMediaStream
*
aStream
MediaSegment
:
:
Type
aType
nsIPrincipal
*
aPrincipal
bool
aAsyncAddTrack
)
;
void
RemoveTrack
(
SourceMediaStream
*
aStream
)
;
void
SetPrincipal
(
nsIPrincipal
*
aPrincipal
)
;
const
RefPtr
<
OutputStreamManager
>
mManager
;
const
RefPtr
<
AbstractThread
>
mAbstractMainThread
;
const
WeakPtr
<
DOMMediaStream
>
mDOMStream
;
private
:
nsTArray
<
WeakPtr
<
dom
:
:
MediaStreamTrack
>
>
mTracks
;
}
;
class
OutputStreamManager
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
OutputStreamManager
)
;
public
:
OutputStreamManager
(
MediaStreamGraph
*
aGraph
nsIPrincipal
*
aPrincipal
AbstractThread
*
aAbstractMainThread
)
;
void
Add
(
DOMMediaStream
*
aDOMStream
)
;
void
Remove
(
DOMMediaStream
*
aDOMStream
)
;
bool
HasTrackType
(
MediaSegment
:
:
Type
aType
)
;
bool
HasTracks
(
SourceMediaStream
*
aAudioStream
SourceMediaStream
*
aVideoStream
)
;
SourceMediaStream
*
GetPrecreatedTrackOfType
(
MediaSegment
:
:
Type
aType
)
const
;
size_t
NumberOfTracks
(
)
;
already_AddRefed
<
SourceMediaStream
>
AddTrack
(
MediaSegment
:
:
Type
aType
)
;
void
RemoveTracks
(
)
;
void
Disconnect
(
)
;
AbstractCanonical
<
PrincipalHandle
>
*
CanonicalPrincipalHandle
(
)
;
void
SetPrincipal
(
nsIPrincipal
*
aPrincipal
)
;
void
SetPlaying
(
bool
aPlaying
)
;
bool
IsEmpty
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mStreams
.
IsEmpty
(
)
;
}
static
const
TrackID
sTrackID
=
1
;
const
RefPtr
<
AbstractThread
>
mAbstractMainThread
;
private
:
~
OutputStreamManager
(
)
;
class
LiveTrack
{
public
:
LiveTrack
(
SourceMediaStream
*
aSourceStream
MediaSegment
:
:
Type
aType
)
:
mSourceStream
(
aSourceStream
)
mType
(
aType
)
{
}
~
LiveTrack
(
)
;
const
RefPtr
<
SourceMediaStream
>
mSourceStream
;
const
MediaSegment
:
:
Type
mType
;
bool
mEverPlayed
=
false
;
}
;
struct
StreamComparator
{
static
bool
Equals
(
const
UniquePtr
<
OutputStreamData
>
&
aData
DOMMediaStream
*
aStream
)
{
return
aData
-
>
mDOMStream
=
=
aStream
;
}
}
;
struct
TrackStreamComparator
{
static
bool
Equals
(
const
UniquePtr
<
LiveTrack
>
&
aLiveTrack
SourceMediaStream
*
aStream
)
{
return
aLiveTrack
-
>
mSourceStream
=
=
aStream
;
}
}
;
struct
TrackTypeComparator
{
static
bool
Equals
(
const
UniquePtr
<
LiveTrack
>
&
aLiveTrack
MediaSegment
:
:
Type
aType
)
{
return
aLiveTrack
-
>
mType
=
=
aType
;
}
}
;
struct
PrecreatedTrackTypeComparator
{
static
bool
Equals
(
const
UniquePtr
<
LiveTrack
>
&
aLiveTrack
MediaSegment
:
:
Type
aType
)
{
return
!
aLiveTrack
-
>
mEverPlayed
&
&
aLiveTrack
-
>
mType
=
=
aType
;
}
}
;
struct
TrackComparator
{
static
bool
Equals
(
const
UniquePtr
<
LiveTrack
>
&
aLiveTrack
const
Pair
<
SourceMediaStream
*
MediaSegment
:
:
Type
>
&
aOther
)
{
return
aLiveTrack
-
>
mSourceStream
=
=
aOther
.
first
(
)
&
&
aLiveTrack
-
>
mType
=
=
aOther
.
second
(
)
;
}
}
;
void
AutoRemoveDestroyedStreams
(
)
;
void
RemoveTrack
(
SourceMediaStream
*
aStream
)
;
const
RefPtr
<
SourceMediaStream
>
mDummyStream
;
nsTArray
<
UniquePtr
<
OutputStreamData
>
>
mStreams
;
nsTArray
<
UniquePtr
<
LiveTrack
>
>
mLiveTracks
;
Canonical
<
PrincipalHandle
>
mPrincipalHandle
;
bool
mPlaying
=
false
;
}
;
}
#
endif
