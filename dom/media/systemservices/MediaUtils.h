#
ifndef
mozilla_MediaUtils_h
#
define
mozilla_MediaUtils_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIAsyncShutdown
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsThreadUtils
.
h
"
class
nsIEventTarget
;
namespace
mozilla
{
namespace
media
{
class
PledgeBase
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
PledgeBase
)
;
protected
:
virtual
~
PledgeBase
(
)
{
}
;
}
;
template
<
typename
ValueType
typename
ErrorType
=
nsresult
>
class
Pledge
:
public
PledgeBase
{
class
FunctorsBase
{
public
:
FunctorsBase
(
)
{
}
virtual
void
Succeed
(
ValueType
&
result
)
=
0
;
virtual
void
Fail
(
ErrorType
&
error
)
=
0
;
virtual
~
FunctorsBase
(
)
{
}
;
}
;
public
:
explicit
Pledge
(
)
:
mDone
(
false
)
mRejected
(
false
)
{
}
Pledge
(
const
Pledge
&
aOther
)
=
delete
;
Pledge
&
operator
=
(
const
Pledge
&
)
=
delete
;
template
<
typename
OnSuccessType
>
void
Then
(
OnSuccessType
&
&
aOnSuccess
)
{
Then
(
std
:
:
forward
<
OnSuccessType
>
(
aOnSuccess
)
[
]
(
ErrorType
&
)
{
}
)
;
}
template
<
typename
OnSuccessType
typename
OnFailureType
>
void
Then
(
OnSuccessType
&
&
aOnSuccess
OnFailureType
&
&
aOnFailure
)
{
class
Functors
:
public
FunctorsBase
{
public
:
Functors
(
OnSuccessType
&
&
aOnSuccessRef
OnFailureType
&
&
aOnFailureRef
)
:
mOnSuccess
(
std
:
:
move
(
aOnSuccessRef
)
)
mOnFailure
(
std
:
:
move
(
aOnFailureRef
)
)
{
}
void
Succeed
(
ValueType
&
result
)
{
mOnSuccess
(
result
)
;
}
void
Fail
(
ErrorType
&
error
)
{
mOnFailure
(
error
)
;
}
;
OnSuccessType
mOnSuccess
;
OnFailureType
mOnFailure
;
}
;
mFunctors
=
MakeUnique
<
Functors
>
(
std
:
:
forward
<
OnSuccessType
>
(
aOnSuccess
)
std
:
:
forward
<
OnFailureType
>
(
aOnFailure
)
)
;
if
(
mDone
)
{
if
(
!
mRejected
)
{
mFunctors
-
>
Succeed
(
mValue
)
;
}
else
{
mFunctors
-
>
Fail
(
mError
)
;
}
}
}
void
Resolve
(
const
ValueType
&
aValue
)
{
mValue
=
aValue
;
Resolve
(
)
;
}
void
Reject
(
ErrorType
rv
)
{
if
(
!
mDone
)
{
mDone
=
mRejected
=
true
;
mError
=
rv
;
if
(
mFunctors
)
{
mFunctors
-
>
Fail
(
mError
)
;
}
}
}
protected
:
void
Resolve
(
)
{
if
(
!
mDone
)
{
mDone
=
true
;
MOZ_ASSERT
(
!
mRejected
)
;
if
(
mFunctors
)
{
mFunctors
-
>
Succeed
(
mValue
)
;
}
}
}
ValueType
mValue
;
private
:
~
Pledge
(
)
{
}
;
bool
mDone
;
bool
mRejected
;
ErrorType
mError
;
UniquePtr
<
FunctorsBase
>
mFunctors
;
}
;
template
<
typename
OnRunType
>
class
LambdaRunnable
:
public
Runnable
{
public
:
explicit
LambdaRunnable
(
OnRunType
&
&
aOnRun
)
:
Runnable
(
"
media
:
:
LambdaRunnable
"
)
mOnRun
(
std
:
:
move
(
aOnRun
)
)
{
}
private
:
NS_IMETHODIMP
Run
(
)
override
{
return
mOnRun
(
)
;
}
OnRunType
mOnRun
;
}
;
template
<
typename
OnRunType
>
already_AddRefed
<
LambdaRunnable
<
OnRunType
>
>
NewRunnableFrom
(
OnRunType
&
&
aOnRun
)
{
typedef
LambdaRunnable
<
OnRunType
>
LambdaType
;
RefPtr
<
LambdaType
>
lambda
=
new
LambdaType
(
std
:
:
forward
<
OnRunType
>
(
aOnRun
)
)
;
return
lambda
.
forget
(
)
;
}
template
<
class
T
>
class
CoatCheck
{
public
:
typedef
std
:
:
pair
<
uint32_t
RefPtr
<
T
>
>
Element
;
uint32_t
Append
(
T
&
t
)
{
uint32_t
id
=
GetNextId
(
)
;
mElements
.
AppendElement
(
Element
(
id
RefPtr
<
T
>
(
&
t
)
)
)
;
return
id
;
}
already_AddRefed
<
T
>
Remove
(
uint32_t
aId
)
{
for
(
auto
&
element
:
mElements
)
{
if
(
element
.
first
=
=
aId
)
{
RefPtr
<
T
>
ref
;
ref
.
swap
(
element
.
second
)
;
mElements
.
RemoveElement
(
element
)
;
return
ref
.
forget
(
)
;
}
}
MOZ_ASSERT_UNREACHABLE
(
"
Received
id
with
no
matching
parked
object
!
"
)
;
return
nullptr
;
}
private
:
static
uint32_t
GetNextId
(
)
{
static
uint32_t
counter
=
0
;
return
+
+
counter
;
}
;
AutoTArray
<
Element
3
>
mElements
;
}
;
class
RefcountableBase
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RefcountableBase
)
protected
:
virtual
~
RefcountableBase
(
)
{
}
}
;
template
<
typename
T
>
class
Refcountable
:
public
T
public
RefcountableBase
{
public
:
NS_METHOD_
(
MozExternalRefCountType
)
AddRef
(
)
{
return
RefcountableBase
:
:
AddRef
(
)
;
}
NS_METHOD_
(
MozExternalRefCountType
)
Release
(
)
{
return
RefcountableBase
:
:
Release
(
)
;
}
private
:
~
Refcountable
<
T
>
(
)
{
}
}
;
template
<
typename
T
>
class
Refcountable
<
UniquePtr
<
T
>
>
:
public
UniquePtr
<
T
>
{
public
:
explicit
Refcountable
<
UniquePtr
<
T
>
>
(
T
*
aPtr
)
:
UniquePtr
<
T
>
(
aPtr
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Refcountable
<
T
>
)
private
:
~
Refcountable
<
UniquePtr
<
T
>
>
(
)
{
}
}
;
already_AddRefed
<
nsIAsyncShutdownClient
>
GetShutdownBarrier
(
)
;
class
ShutdownBlocker
:
public
nsIAsyncShutdownBlocker
{
public
:
ShutdownBlocker
(
const
nsString
&
aName
)
:
mName
(
aName
)
{
}
NS_IMETHOD
BlockShutdown
(
nsIAsyncShutdownClient
*
aProfileBeforeChange
)
override
=
0
;
NS_IMETHOD
GetName
(
nsAString
&
aName
)
override
{
aName
=
mName
;
return
NS_OK
;
}
NS_IMETHOD
GetState
(
nsIPropertyBag
*
*
)
override
{
return
NS_OK
;
}
NS_DECL_ISUPPORTS
protected
:
virtual
~
ShutdownBlocker
(
)
{
}
private
:
const
nsString
mName
;
}
;
class
ShutdownTicket
final
{
public
:
explicit
ShutdownTicket
(
nsIAsyncShutdownBlocker
*
aBlocker
)
:
mBlocker
(
aBlocker
)
{
}
NS_INLINE_DECL_REFCOUNTING
(
ShutdownTicket
)
private
:
~
ShutdownTicket
(
)
{
nsCOMPtr
<
nsIAsyncShutdownClient
>
barrier
=
GetShutdownBarrier
(
)
;
barrier
-
>
RemoveBlocker
(
mBlocker
)
;
}
nsCOMPtr
<
nsIAsyncShutdownBlocker
>
mBlocker
;
}
;
template
<
typename
ResolveValueType
typename
RejectValueType
typename
ResolveFunction
typename
RejectFunction
>
void
Await
(
already_AddRefed
<
nsIEventTarget
>
aPool
RefPtr
<
MozPromise
<
ResolveValueType
RejectValueType
true
>
>
aPromise
ResolveFunction
&
&
aResolveFunction
RejectFunction
&
&
aRejectFunction
)
{
RefPtr
<
TaskQueue
>
taskQueue
=
new
TaskQueue
(
std
:
:
move
(
aPool
)
"
MozPromiseAwait
"
)
;
Monitor
mon
(
__func__
)
;
bool
done
=
false
;
aPromise
-
>
Then
(
taskQueue
__func__
[
&
]
(
ResolveValueType
&
&
aResolveValue
)
{
MonitorAutoLock
lock
(
mon
)
;
aResolveFunction
(
std
:
:
forward
<
ResolveValueType
>
(
aResolveValue
)
)
;
done
=
true
;
mon
.
Notify
(
)
;
}
[
&
]
(
RejectValueType
&
&
aRejectValue
)
{
MonitorAutoLock
lock
(
mon
)
;
aRejectFunction
(
std
:
:
forward
<
RejectValueType
>
(
aRejectValue
)
)
;
done
=
true
;
mon
.
Notify
(
)
;
}
)
;
MonitorAutoLock
lock
(
mon
)
;
while
(
!
done
)
{
mon
.
Wait
(
)
;
}
}
template
<
typename
ResolveValueType
typename
RejectValueType
bool
Excl
>
typename
MozPromise
<
ResolveValueType
RejectValueType
Excl
>
:
:
ResolveOrRejectValue
Await
(
already_AddRefed
<
nsIEventTarget
>
aPool
RefPtr
<
MozPromise
<
ResolveValueType
RejectValueType
Excl
>
>
aPromise
)
{
RefPtr
<
TaskQueue
>
taskQueue
=
new
TaskQueue
(
std
:
:
move
(
aPool
)
"
MozPromiseAwait
"
)
;
Monitor
mon
(
__func__
)
;
bool
done
=
false
;
typename
MozPromise
<
ResolveValueType
RejectValueType
Excl
>
:
:
ResolveOrRejectValue
val
;
aPromise
-
>
Then
(
taskQueue
__func__
[
&
]
(
ResolveValueType
aResolveValue
)
{
val
.
SetResolve
(
std
:
:
move
(
aResolveValue
)
)
;
MonitorAutoLock
lock
(
mon
)
;
done
=
true
;
mon
.
Notify
(
)
;
}
[
&
]
(
RejectValueType
aRejectValue
)
{
val
.
SetReject
(
std
:
:
move
(
aRejectValue
)
)
;
MonitorAutoLock
lock
(
mon
)
;
done
=
true
;
mon
.
Notify
(
)
;
}
)
;
MonitorAutoLock
lock
(
mon
)
;
while
(
!
done
)
{
mon
.
Wait
(
)
;
}
return
val
;
}
template
<
typename
ResolveValueType
typename
RejectValueType
typename
ResolveFunction
typename
RejectFunction
>
void
AwaitAll
(
already_AddRefed
<
nsIEventTarget
>
aPool
nsTArray
<
RefPtr
<
MozPromise
<
ResolveValueType
RejectValueType
true
>
>
>
&
aPromises
ResolveFunction
&
&
aResolveFunction
RejectFunction
&
&
aRejectFunction
)
{
typedef
MozPromise
<
ResolveValueType
RejectValueType
true
>
Promise
;
RefPtr
<
nsIEventTarget
>
pool
=
aPool
;
RefPtr
<
TaskQueue
>
taskQueue
=
new
TaskQueue
(
do_AddRef
(
pool
)
"
MozPromiseAwaitAll
"
)
;
RefPtr
<
typename
Promise
:
:
AllPromiseType
>
p
=
Promise
:
:
All
(
taskQueue
aPromises
)
;
Await
(
pool
.
forget
(
)
p
std
:
:
move
(
aResolveFunction
)
std
:
:
move
(
aRejectFunction
)
)
;
}
template
<
typename
ResolveValueType
typename
RejectValueType
>
typename
MozPromise
<
ResolveValueType
RejectValueType
true
>
:
:
AllPromiseType
:
:
ResolveOrRejectValue
AwaitAll
(
already_AddRefed
<
nsIEventTarget
>
aPool
nsTArray
<
RefPtr
<
MozPromise
<
ResolveValueType
RejectValueType
true
>
>
>
&
aPromises
)
{
typedef
MozPromise
<
ResolveValueType
RejectValueType
true
>
Promise
;
RefPtr
<
nsIEventTarget
>
pool
=
aPool
;
RefPtr
<
TaskQueue
>
taskQueue
=
new
TaskQueue
(
do_AddRef
(
pool
)
"
MozPromiseAwaitAll
"
)
;
RefPtr
<
typename
Promise
:
:
AllPromiseType
>
p
=
Promise
:
:
All
(
taskQueue
aPromises
)
;
return
Await
(
pool
.
forget
(
)
p
)
;
}
}
}
#
endif
