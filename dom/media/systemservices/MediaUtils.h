#
ifndef
mozilla_MediaUtils_h
#
define
mozilla_MediaUtils_h
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIAsyncShutdown
.
h
"
#
include
"
base
/
task
.
h
"
namespace
mozilla
{
namespace
media
{
class
PledgeBase
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
PledgeBase
)
;
protected
:
virtual
~
PledgeBase
(
)
{
}
;
}
;
template
<
typename
ValueType
typename
ErrorType
=
nsresult
>
class
Pledge
:
public
PledgeBase
{
class
FunctorsBase
{
public
:
FunctorsBase
(
)
{
}
virtual
void
Succeed
(
ValueType
&
result
)
=
0
;
virtual
void
Fail
(
ErrorType
&
error
)
=
0
;
virtual
~
FunctorsBase
(
)
{
}
;
}
;
public
:
explicit
Pledge
(
)
:
mDone
(
false
)
mRejected
(
false
)
{
}
Pledge
(
const
Pledge
&
aOther
)
=
delete
;
Pledge
&
operator
=
(
const
Pledge
&
)
=
delete
;
template
<
typename
OnSuccessType
>
void
Then
(
OnSuccessType
&
&
aOnSuccess
)
{
Then
(
Forward
<
OnSuccessType
>
(
aOnSuccess
)
[
]
(
ErrorType
&
)
{
}
)
;
}
template
<
typename
OnSuccessType
typename
OnFailureType
>
void
Then
(
OnSuccessType
&
&
aOnSuccess
OnFailureType
&
&
aOnFailure
)
{
class
Functors
:
public
FunctorsBase
{
public
:
Functors
(
OnSuccessType
&
&
aOnSuccess
OnFailureType
&
&
aOnFailure
)
:
mOnSuccess
(
Move
(
aOnSuccess
)
)
mOnFailure
(
Move
(
aOnFailure
)
)
{
}
void
Succeed
(
ValueType
&
result
)
{
mOnSuccess
(
result
)
;
}
void
Fail
(
ErrorType
&
error
)
{
mOnFailure
(
error
)
;
}
;
OnSuccessType
mOnSuccess
;
OnFailureType
mOnFailure
;
}
;
mFunctors
=
new
Functors
(
Forward
<
OnSuccessType
>
(
aOnSuccess
)
Forward
<
OnFailureType
>
(
aOnFailure
)
)
;
if
(
mDone
)
{
if
(
!
mRejected
)
{
mFunctors
-
>
Succeed
(
mValue
)
;
}
else
{
mFunctors
-
>
Fail
(
mError
)
;
}
}
}
void
Resolve
(
const
ValueType
&
aValue
)
{
mValue
=
aValue
;
Resolve
(
)
;
}
void
Reject
(
ErrorType
rv
)
{
if
(
!
mDone
)
{
mDone
=
mRejected
=
true
;
mError
=
rv
;
if
(
mFunctors
)
{
mFunctors
-
>
Fail
(
mError
)
;
}
}
}
protected
:
void
Resolve
(
)
{
if
(
!
mDone
)
{
mDone
=
true
;
MOZ_ASSERT
(
!
mRejected
)
;
if
(
mFunctors
)
{
mFunctors
-
>
Succeed
(
mValue
)
;
}
}
}
ValueType
mValue
;
private
:
~
Pledge
(
)
{
}
;
bool
mDone
;
bool
mRejected
;
ErrorType
mError
;
ScopedDeletePtr
<
FunctorsBase
>
mFunctors
;
}
;
template
<
typename
OnRunType
>
class
LambdaRunnable
:
public
nsRunnable
{
public
:
explicit
LambdaRunnable
(
OnRunType
&
&
aOnRun
)
:
mOnRun
(
Move
(
aOnRun
)
)
{
}
private
:
NS_IMETHODIMP
Run
(
)
{
return
mOnRun
(
)
;
}
OnRunType
mOnRun
;
}
;
template
<
typename
OnRunType
>
LambdaRunnable
<
OnRunType
>
*
NewRunnableFrom
(
OnRunType
&
&
aOnRun
)
{
return
new
LambdaRunnable
<
OnRunType
>
(
Forward
<
OnRunType
>
(
aOnRun
)
)
;
}
template
<
typename
OnRunType
>
class
LambdaTask
:
public
Task
{
public
:
explicit
LambdaTask
(
OnRunType
&
&
aOnRun
)
:
mOnRun
(
Move
(
aOnRun
)
)
{
}
private
:
void
Run
(
)
{
return
mOnRun
(
)
;
}
OnRunType
mOnRun
;
}
;
template
<
typename
OnRunType
>
LambdaTask
<
OnRunType
>
*
NewTaskFrom
(
OnRunType
&
&
aOnRun
)
{
return
new
LambdaTask
<
OnRunType
>
(
Forward
<
OnRunType
>
(
aOnRun
)
)
;
}
template
<
class
T
>
class
CoatCheck
{
public
:
typedef
std
:
:
pair
<
uint32_t
RefPtr
<
T
>
>
Element
;
uint32_t
Append
(
T
&
t
)
{
uint32_t
id
=
GetNextId
(
)
;
mElements
.
AppendElement
(
Element
(
id
RefPtr
<
T
>
(
&
t
)
)
)
;
return
id
;
}
already_AddRefed
<
T
>
Remove
(
uint32_t
aId
)
{
for
(
auto
&
element
:
mElements
)
{
if
(
element
.
first
=
=
aId
)
{
RefPtr
<
T
>
ref
;
ref
.
swap
(
element
.
second
)
;
mElements
.
RemoveElement
(
element
)
;
return
ref
.
forget
(
)
;
}
}
MOZ_ASSERT_UNREACHABLE
(
"
Received
id
with
no
matching
parked
object
!
"
)
;
return
nullptr
;
}
private
:
static
uint32_t
GetNextId
(
)
{
static
uint32_t
counter
=
0
;
return
+
+
counter
;
}
;
AutoTArray
<
Element
3
>
mElements
;
}
;
template
<
typename
T
>
class
Refcountable
:
public
T
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Refcountable
<
T
>
)
private
:
~
Refcountable
<
T
>
(
)
{
}
}
;
template
<
typename
T
>
class
Refcountable
<
ScopedDeletePtr
<
T
>
>
:
public
ScopedDeletePtr
<
T
>
{
public
:
explicit
Refcountable
<
ScopedDeletePtr
<
T
>
>
(
T
*
aPtr
)
:
ScopedDeletePtr
<
T
>
(
aPtr
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Refcountable
<
T
>
)
private
:
~
Refcountable
<
ScopedDeletePtr
<
T
>
>
(
)
{
}
}
;
class
ShutdownBlocker
:
public
nsIAsyncShutdownBlocker
{
public
:
ShutdownBlocker
(
const
nsString
&
aName
)
:
mName
(
aName
)
{
}
NS_IMETHOD
BlockShutdown
(
nsIAsyncShutdownClient
*
aProfileBeforeChange
)
override
=
0
;
NS_IMETHOD
GetName
(
nsAString
&
aName
)
override
{
aName
=
mName
;
return
NS_OK
;
}
NS_IMETHOD
GetState
(
nsIPropertyBag
*
*
)
override
{
return
NS_OK
;
}
NS_DECL_ISUPPORTS
protected
:
virtual
~
ShutdownBlocker
(
)
{
}
private
:
const
nsString
mName
;
}
;
}
}
#
endif
