#
ifndef
mozilla_MediaUtils_h
#
define
mozilla_MediaUtils_h
#
include
<
map
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIAsyncShutdown
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsThreadUtils
.
h
"
class
nsIEventTarget
;
namespace
mozilla
{
namespace
media
{
template
<
typename
OnRunType
>
class
LambdaRunnable
:
public
Runnable
{
public
:
explicit
LambdaRunnable
(
OnRunType
&
&
aOnRun
)
:
Runnable
(
"
media
:
:
LambdaRunnable
"
)
mOnRun
(
std
:
:
move
(
aOnRun
)
)
{
}
private
:
NS_IMETHODIMP
Run
(
)
override
{
return
mOnRun
(
)
;
}
OnRunType
mOnRun
;
}
;
template
<
typename
OnRunType
>
already_AddRefed
<
LambdaRunnable
<
OnRunType
>
>
NewRunnableFrom
(
OnRunType
&
&
aOnRun
)
{
typedef
LambdaRunnable
<
OnRunType
>
LambdaType
;
RefPtr
<
LambdaType
>
lambda
=
new
LambdaType
(
std
:
:
forward
<
OnRunType
>
(
aOnRun
)
)
;
return
lambda
.
forget
(
)
;
}
class
RefcountableBase
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RefcountableBase
)
protected
:
virtual
~
RefcountableBase
(
)
=
default
;
}
;
template
<
typename
T
>
class
Refcountable
:
public
T
public
RefcountableBase
{
public
:
NS_METHOD_
(
MozExternalRefCountType
)
AddRef
(
)
{
return
RefcountableBase
:
:
AddRef
(
)
;
}
NS_METHOD_
(
MozExternalRefCountType
)
Release
(
)
{
return
RefcountableBase
:
:
Release
(
)
;
}
Refcountable
<
T
>
&
operator
=
(
T
&
&
aOther
)
{
T
:
:
operator
=
(
std
:
:
move
(
aOther
)
)
;
return
*
this
;
}
Refcountable
<
T
>
&
operator
=
(
T
&
aOther
)
{
T
:
:
operator
=
(
aOther
)
;
return
*
this
;
}
private
:
~
Refcountable
<
T
>
(
)
=
default
;
}
;
template
<
typename
T
>
class
Refcountable
<
UniquePtr
<
T
>
>
:
public
UniquePtr
<
T
>
{
public
:
explicit
Refcountable
<
UniquePtr
<
T
>
>
(
T
*
aPtr
)
:
UniquePtr
<
T
>
(
aPtr
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Refcountable
<
T
>
)
private
:
~
Refcountable
<
UniquePtr
<
T
>
>
(
)
=
default
;
}
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
GetShutdownBarrier
(
)
;
class
ShutdownBlocker
:
public
nsIAsyncShutdownBlocker
{
public
:
ShutdownBlocker
(
const
nsString
&
aName
)
:
mName
(
aName
)
{
}
NS_IMETHOD
BlockShutdown
(
nsIAsyncShutdownClient
*
aProfileBeforeChange
)
override
=
0
;
NS_IMETHOD
GetName
(
nsAString
&
aName
)
override
{
aName
=
mName
;
return
NS_OK
;
}
NS_IMETHOD
GetState
(
nsIPropertyBag
*
*
)
override
{
return
NS_OK
;
}
NS_DECL_ISUPPORTS
protected
:
virtual
~
ShutdownBlocker
(
)
=
default
;
private
:
const
nsString
mName
;
}
;
class
ShutdownTicket
final
{
public
:
explicit
ShutdownTicket
(
nsIAsyncShutdownBlocker
*
aBlocker
)
:
mBlocker
(
aBlocker
)
{
}
NS_INLINE_DECL_REFCOUNTING
(
ShutdownTicket
)
private
:
~
ShutdownTicket
(
)
{
GetShutdownBarrier
(
)
-
>
RemoveBlocker
(
mBlocker
)
;
}
nsCOMPtr
<
nsIAsyncShutdownBlocker
>
mBlocker
;
}
;
template
<
typename
ResolveValueType
typename
RejectValueType
typename
ResolveFunction
typename
RejectFunction
>
void
Await
(
already_AddRefed
<
nsIEventTarget
>
aPool
RefPtr
<
MozPromise
<
ResolveValueType
RejectValueType
true
>
>
aPromise
ResolveFunction
&
&
aResolveFunction
RejectFunction
&
&
aRejectFunction
)
{
RefPtr
<
TaskQueue
>
taskQueue
=
new
TaskQueue
(
std
:
:
move
(
aPool
)
"
MozPromiseAwait
"
)
;
Monitor
mon
(
__func__
)
;
bool
done
=
false
;
aPromise
-
>
Then
(
taskQueue
__func__
[
&
]
(
ResolveValueType
&
&
aResolveValue
)
{
MonitorAutoLock
lock
(
mon
)
;
aResolveFunction
(
std
:
:
forward
<
ResolveValueType
>
(
aResolveValue
)
)
;
done
=
true
;
mon
.
Notify
(
)
;
}
[
&
]
(
RejectValueType
&
&
aRejectValue
)
{
MonitorAutoLock
lock
(
mon
)
;
aRejectFunction
(
std
:
:
forward
<
RejectValueType
>
(
aRejectValue
)
)
;
done
=
true
;
mon
.
Notify
(
)
;
}
)
;
MonitorAutoLock
lock
(
mon
)
;
while
(
!
done
)
{
mon
.
Wait
(
)
;
}
}
template
<
typename
ResolveValueType
typename
RejectValueType
bool
Excl
>
typename
MozPromise
<
ResolveValueType
RejectValueType
Excl
>
:
:
ResolveOrRejectValue
Await
(
already_AddRefed
<
nsIEventTarget
>
aPool
RefPtr
<
MozPromise
<
ResolveValueType
RejectValueType
Excl
>
>
aPromise
)
{
RefPtr
<
TaskQueue
>
taskQueue
=
new
TaskQueue
(
std
:
:
move
(
aPool
)
"
MozPromiseAwait
"
)
;
Monitor
mon
(
__func__
)
;
bool
done
=
false
;
typename
MozPromise
<
ResolveValueType
RejectValueType
Excl
>
:
:
ResolveOrRejectValue
val
;
aPromise
-
>
Then
(
taskQueue
__func__
[
&
]
(
ResolveValueType
aResolveValue
)
{
val
.
SetResolve
(
std
:
:
move
(
aResolveValue
)
)
;
MonitorAutoLock
lock
(
mon
)
;
done
=
true
;
mon
.
Notify
(
)
;
}
[
&
]
(
RejectValueType
aRejectValue
)
{
val
.
SetReject
(
std
:
:
move
(
aRejectValue
)
)
;
MonitorAutoLock
lock
(
mon
)
;
done
=
true
;
mon
.
Notify
(
)
;
}
)
;
MonitorAutoLock
lock
(
mon
)
;
while
(
!
done
)
{
mon
.
Wait
(
)
;
}
return
val
;
}
template
<
typename
ResolveValueType
typename
RejectValueType
typename
ResolveFunction
typename
RejectFunction
>
void
AwaitAll
(
already_AddRefed
<
nsIEventTarget
>
aPool
nsTArray
<
RefPtr
<
MozPromise
<
ResolveValueType
RejectValueType
true
>
>
>
&
aPromises
ResolveFunction
&
&
aResolveFunction
RejectFunction
&
&
aRejectFunction
)
{
typedef
MozPromise
<
ResolveValueType
RejectValueType
true
>
Promise
;
RefPtr
<
nsIEventTarget
>
pool
=
aPool
;
RefPtr
<
TaskQueue
>
taskQueue
=
new
TaskQueue
(
do_AddRef
(
pool
)
"
MozPromiseAwaitAll
"
)
;
RefPtr
<
typename
Promise
:
:
AllPromiseType
>
p
=
Promise
:
:
All
(
taskQueue
aPromises
)
;
Await
(
pool
.
forget
(
)
p
std
:
:
move
(
aResolveFunction
)
std
:
:
move
(
aRejectFunction
)
)
;
}
template
<
typename
ResolveValueType
typename
RejectValueType
>
typename
MozPromise
<
ResolveValueType
RejectValueType
true
>
:
:
AllPromiseType
:
:
ResolveOrRejectValue
AwaitAll
(
already_AddRefed
<
nsIEventTarget
>
aPool
nsTArray
<
RefPtr
<
MozPromise
<
ResolveValueType
RejectValueType
true
>
>
>
&
aPromises
)
{
typedef
MozPromise
<
ResolveValueType
RejectValueType
true
>
Promise
;
RefPtr
<
nsIEventTarget
>
pool
=
aPool
;
RefPtr
<
TaskQueue
>
taskQueue
=
new
TaskQueue
(
do_AddRef
(
pool
)
"
MozPromiseAwaitAll
"
)
;
RefPtr
<
typename
Promise
:
:
AllPromiseType
>
p
=
Promise
:
:
All
(
taskQueue
aPromises
)
;
return
Await
(
pool
.
forget
(
)
p
)
;
}
}
class
AsyncBlockers
{
public
:
AsyncBlockers
(
)
:
mLock
(
"
AsyncRegistrar
"
)
mPromise
(
new
GenericPromise
:
:
Private
(
__func__
)
)
{
}
void
Register
(
void
*
aBlocker
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
mResolved
)
{
return
;
}
mBlockers
.
insert
(
{
aBlocker
true
}
)
;
}
void
Deregister
(
void
*
aBlocker
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
mResolved
)
{
return
;
}
auto
it
=
mBlockers
.
find
(
aBlocker
)
;
MOZ_ASSERT
(
it
!
=
mBlockers
.
end
(
)
)
;
mBlockers
.
erase
(
it
)
;
MaybeResolve
(
)
;
}
RefPtr
<
GenericPromise
>
WaitUntilClear
(
uint32_t
aTimeOutInMs
=
0
)
{
if
(
!
aTimeOutInMs
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
!
mResolved
)
{
mPromise
-
>
Resolve
(
true
__func__
)
;
mResolved
=
true
;
}
}
else
{
GetCurrentEventTarget
(
)
-
>
DelayedDispatch
(
NS_NewRunnableFunction
(
"
AsyncBlockers
:
:
WaitUntilClear
"
[
promise
=
mPromise
]
(
)
{
promise
-
>
Resolve
(
true
__func__
)
;
}
)
aTimeOutInMs
)
;
}
return
mPromise
;
}
virtual
~
AsyncBlockers
(
)
{
if
(
!
mResolved
)
{
mPromise
-
>
Resolve
(
true
__func__
)
;
}
}
private
:
void
MaybeResolve
(
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
mResolved
)
{
return
;
}
if
(
!
mBlockers
.
empty
(
)
)
{
return
;
}
mPromise
-
>
Resolve
(
true
__func__
)
;
mResolved
=
true
;
}
Mutex
mLock
;
std
:
:
map
<
void
*
bool
>
mBlockers
;
bool
mResolved
=
false
;
const
RefPtr
<
GenericPromise
:
:
Private
>
mPromise
;
}
;
}
#
endif
