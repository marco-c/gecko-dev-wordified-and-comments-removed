#
ifndef
mozilla_CamerasChild_h
#
define
mozilla_CamerasChild_h
#
include
<
utility
>
#
include
"
MediaEventSource
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
camera
/
PCamerasChild
.
h
"
#
include
"
mozilla
/
camera
/
PCamerasParent
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
undef
FF
#
include
"
modules
/
video_capture
/
video_capture_defines
.
h
"
namespace
mozilla
{
namespace
ipc
{
class
BackgroundChildImpl
;
}
namespace
camera
{
class
FrameRelay
{
public
:
virtual
int
DeliverFrame
(
uint8_t
*
buffer
const
mozilla
:
:
camera
:
:
VideoFrameProperties
&
props
)
=
0
;
}
;
struct
CapturerElement
{
CaptureEngine
engine
;
int
id
;
FrameRelay
*
callback
;
}
;
class
CamerasChild
;
template
<
class
T
>
class
LockAndDispatch
;
class
CamerasSingleton
{
public
:
static
OffTheBooksMutex
&
Mutex
(
)
{
return
singleton
(
)
.
mCamerasMutex
;
}
static
CamerasChild
*
&
Child
(
)
{
Mutex
(
)
.
AssertCurrentThreadOwns
(
)
;
return
singleton
(
)
.
mCameras
;
}
static
nsCOMPtr
<
nsIThread
>
&
Thread
(
)
{
Mutex
(
)
.
AssertCurrentThreadOwns
(
)
;
return
singleton
(
)
.
mCamerasChildThread
;
}
static
bool
InShutdown
(
)
{
return
singleton
(
)
.
mInShutdown
;
}
static
void
StartShutdown
(
)
{
singleton
(
)
.
mInShutdown
=
true
;
}
private
:
CamerasSingleton
(
)
;
~
CamerasSingleton
(
)
;
static
CamerasSingleton
&
singleton
(
)
{
static
CamerasSingleton
camera
;
return
camera
;
}
mozilla
:
:
OffTheBooksMutex
mCamerasMutex
;
CamerasChild
*
mCameras
;
nsCOMPtr
<
nsIThread
>
mCamerasChildThread
;
Atomic
<
bool
>
mInShutdown
;
}
;
CamerasChild
*
GetCamerasChild
(
)
;
CamerasChild
*
GetCamerasChildIfExists
(
)
;
void
Shutdown
(
void
)
;
template
<
class
MEM_FUN
class
.
.
.
ARGS
>
int
GetChildAndCall
(
MEM_FUN
&
&
f
ARGS
&
&
.
.
.
args
)
{
OffTheBooksMutexAutoLock
lock
(
CamerasSingleton
:
:
Mutex
(
)
)
;
CamerasChild
*
child
=
GetCamerasChild
(
)
;
if
(
child
)
{
return
(
child
-
>
*
f
)
(
std
:
:
forward
<
ARGS
>
(
args
)
.
.
.
)
;
}
else
{
return
-
1
;
}
}
class
CamerasChild
final
:
public
PCamerasChild
{
friend
class
mozilla
:
:
ipc
:
:
BackgroundChildImpl
;
template
<
class
T
>
friend
class
mozilla
:
:
camera
:
:
LockAndDispatch
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CamerasChild
)
mozilla
:
:
ipc
:
:
IPCResult
RecvDeliverFrame
(
const
CaptureEngine
&
const
int
&
mozilla
:
:
ipc
:
:
Shmem
&
&
const
VideoFrameProperties
&
prop
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvDeviceChange
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvReplyNumberOfCaptureDevices
(
const
int
&
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvReplyNumberOfCapabilities
(
const
int
&
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvReplyAllocateCapture
(
const
int
&
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvReplyGetCaptureCapability
(
const
VideoCaptureCapability
&
capability
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvReplyGetCaptureDevice
(
const
nsCString
&
device_name
const
nsCString
&
device_id
const
bool
&
scary
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvReplyFailure
(
void
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvReplySuccess
(
void
)
override
;
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
int
NumberOfCaptureDevices
(
CaptureEngine
aCapEngine
)
;
int
NumberOfCapabilities
(
CaptureEngine
aCapEngine
const
char
*
deviceUniqueIdUTF8
)
;
int
ReleaseCapture
(
CaptureEngine
aCapEngine
const
int
capture_id
)
;
int
StartCapture
(
CaptureEngine
aCapEngine
const
int
capture_id
const
webrtc
:
:
VideoCaptureCapability
&
capability
FrameRelay
*
func
)
;
int
FocusOnSelectedSource
(
CaptureEngine
aCapEngine
const
int
capture_id
)
;
int
StopCapture
(
CaptureEngine
aCapEngine
const
int
capture_id
)
;
int
AllocateCapture
(
CaptureEngine
aCapEngine
const
char
*
unique_idUTF8
uint64_t
aWindowID
)
;
int
GetCaptureCapability
(
CaptureEngine
aCapEngine
const
char
*
unique_idUTF8
const
unsigned
int
capability_number
webrtc
:
:
VideoCaptureCapability
*
capability
)
;
int
GetCaptureDevice
(
CaptureEngine
aCapEngine
unsigned
int
list_number
char
*
device_nameUTF8
const
unsigned
int
device_nameUTF8Length
char
*
unique_idUTF8
const
unsigned
int
unique_idUTF8Length
bool
*
scary
=
nullptr
)
;
void
ShutdownAll
(
)
;
int
EnsureInitialized
(
CaptureEngine
aCapEngine
)
;
template
<
typename
This
>
int
ConnectDeviceListChangeListener
(
MediaEventListener
*
aListener
AbstractThread
*
aTarget
This
*
aThis
void
(
This
:
:
*
aMethod
)
(
)
)
{
EnsureInitialized
(
CameraEngine
)
;
*
aListener
=
mDeviceListChangeEvent
.
Connect
(
aTarget
aThis
aMethod
)
;
return
IPC_OK
(
)
;
}
FrameRelay
*
Callback
(
CaptureEngine
aCapEngine
int
capture_id
)
;
private
:
CamerasChild
(
)
;
~
CamerasChild
(
)
;
bool
DispatchToParent
(
nsIRunnable
*
aRunnable
MonitorAutoLock
&
aMonitor
)
;
void
AddCallback
(
const
CaptureEngine
aCapEngine
const
int
capture_id
FrameRelay
*
render
)
;
void
RemoveCallback
(
const
CaptureEngine
aCapEngine
const
int
capture_id
)
;
void
ShutdownParent
(
)
;
void
ShutdownChild
(
)
;
nsTArray
<
CapturerElement
>
mCallbacks
;
Mutex
mCallbackMutex
;
bool
mIPCIsAlive
;
Mutex
mRequestMutex
;
Monitor
mReplyMonitor
;
bool
mReceivedReply
;
bool
mReplySuccess
;
const
int
mZero
;
int
mReplyInteger
;
webrtc
:
:
VideoCaptureCapability
*
mReplyCapability
=
nullptr
;
nsCString
mReplyDeviceName
;
nsCString
mReplyDeviceID
;
bool
mReplyScary
;
MediaEventProducer
<
void
>
mDeviceListChangeEvent
;
}
;
}
}
#
endif
