#
ifndef
mozilla_CamerasChild_h
#
define
mozilla_CamerasChild_h
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Pair
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
camera
/
PCamerasChild
.
h
"
#
include
"
mozilla
/
camera
/
PCamerasParent
.
h
"
#
include
"
mozilla
/
media
/
DeviceChangeCallback
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
base
/
singleton
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
undef
FF
#
include
"
webrtc
/
common
.
h
"
#
include
"
webrtc
/
video_engine
/
include
/
vie_base
.
h
"
#
include
"
webrtc
/
video_engine
/
include
/
vie_capture
.
h
"
#
include
"
webrtc
/
video_engine
/
include
/
vie_render
.
h
"
namespace
mozilla
{
namespace
ipc
{
class
BackgroundChildImpl
;
}
namespace
camera
{
struct
CapturerElement
{
CaptureEngine
engine
;
int
id
;
webrtc
:
:
ExternalRenderer
*
callback
;
}
;
class
CamerasChild
;
template
<
class
T
>
class
LockAndDispatch
;
class
CamerasSingleton
{
public
:
CamerasSingleton
(
)
;
~
CamerasSingleton
(
)
;
static
OffTheBooksMutex
&
Mutex
(
)
{
return
gTheInstance
.
get
(
)
-
>
mCamerasMutex
;
}
static
CamerasChild
*
&
Child
(
)
{
Mutex
(
)
.
AssertCurrentThreadOwns
(
)
;
return
gTheInstance
.
get
(
)
-
>
mCameras
;
}
static
nsCOMPtr
<
nsIThread
>
&
Thread
(
)
{
Mutex
(
)
.
AssertCurrentThreadOwns
(
)
;
return
gTheInstance
.
get
(
)
-
>
mCamerasChildThread
;
}
static
nsCOMPtr
<
nsIThread
>
&
FakeDeviceChangeEventThread
(
)
{
Mutex
(
)
.
AssertCurrentThreadOwns
(
)
;
return
gTheInstance
.
get
(
)
-
>
mFakeDeviceChangeEventThread
;
}
private
:
static
Singleton
<
CamerasSingleton
>
gTheInstance
;
mozilla
:
:
OffTheBooksMutex
mCamerasMutex
;
CamerasChild
*
mCameras
;
nsCOMPtr
<
nsIThread
>
mCamerasChildThread
;
nsCOMPtr
<
nsIThread
>
mFakeDeviceChangeEventThread
;
}
;
CamerasChild
*
GetCamerasChild
(
)
;
CamerasChild
*
GetCamerasChildIfExists
(
)
;
void
Shutdown
(
void
)
;
template
<
class
MEM_FUN
class
.
.
.
ARGS
>
int
GetChildAndCall
(
MEM_FUN
&
&
f
ARGS
&
&
.
.
.
args
)
{
OffTheBooksMutexAutoLock
lock
(
CamerasSingleton
:
:
Mutex
(
)
)
;
CamerasChild
*
child
=
GetCamerasChild
(
)
;
if
(
child
)
{
return
(
child
-
>
*
f
)
(
mozilla
:
:
Forward
<
ARGS
>
(
args
)
.
.
.
)
;
}
else
{
return
-
1
;
}
}
class
CamerasChild
final
:
public
PCamerasChild
public
DeviceChangeCallback
{
friend
class
mozilla
:
:
ipc
:
:
BackgroundChildImpl
;
template
<
class
T
>
friend
class
mozilla
:
:
camera
:
:
LockAndDispatch
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
CamerasChild
)
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvDeliverFrame
(
const
CaptureEngine
&
const
int
&
mozilla
:
:
ipc
:
:
Shmem
&
&
const
size_t
&
const
uint32_t
&
const
int64_t
&
const
int64_t
&
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvFrameSizeChange
(
const
CaptureEngine
&
const
int
&
const
int
&
w
const
int
&
h
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvDeviceChange
(
)
override
;
virtual
int
AddDeviceChangeCallback
(
DeviceChangeCallback
*
aCallback
)
override
;
int
SetFakeDeviceChangeEvents
(
)
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvReplyNumberOfCaptureDevices
(
const
int
&
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvReplyNumberOfCapabilities
(
const
int
&
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvReplyAllocateCaptureDevice
(
const
int
&
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvReplyGetCaptureCapability
(
const
CaptureCapability
&
capability
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvReplyGetCaptureDevice
(
const
nsCString
&
device_name
const
nsCString
&
device_id
const
bool
&
scary
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvReplyFailure
(
void
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvReplySuccess
(
void
)
override
;
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
int
NumberOfCaptureDevices
(
CaptureEngine
aCapEngine
)
;
int
NumberOfCapabilities
(
CaptureEngine
aCapEngine
const
char
*
deviceUniqueIdUTF8
)
;
int
ReleaseCaptureDevice
(
CaptureEngine
aCapEngine
const
int
capture_id
)
;
int
StartCapture
(
CaptureEngine
aCapEngine
const
int
capture_id
webrtc
:
:
CaptureCapability
&
capability
webrtc
:
:
ExternalRenderer
*
func
)
;
int
StopCapture
(
CaptureEngine
aCapEngine
const
int
capture_id
)
;
int
AllocateCaptureDevice
(
CaptureEngine
aCapEngine
const
char
*
unique_idUTF8
const
unsigned
int
unique_idUTF8Length
int
&
capture_id
const
nsACString
&
aOrigin
)
;
int
GetCaptureCapability
(
CaptureEngine
aCapEngine
const
char
*
unique_idUTF8
const
unsigned
int
capability_number
webrtc
:
:
CaptureCapability
&
capability
)
;
int
GetCaptureDevice
(
CaptureEngine
aCapEngine
unsigned
int
list_number
char
*
device_nameUTF8
const
unsigned
int
device_nameUTF8Length
char
*
unique_idUTF8
const
unsigned
int
unique_idUTF8Length
bool
*
scary
=
nullptr
)
;
void
ShutdownAll
(
)
;
int
EnsureInitialized
(
CaptureEngine
aCapEngine
)
;
webrtc
:
:
ExternalRenderer
*
Callback
(
CaptureEngine
aCapEngine
int
capture_id
)
;
private
:
CamerasChild
(
)
;
~
CamerasChild
(
)
;
bool
DispatchToParent
(
nsIRunnable
*
aRunnable
MonitorAutoLock
&
aMonitor
)
;
void
AddCallback
(
const
CaptureEngine
aCapEngine
const
int
capture_id
webrtc
:
:
ExternalRenderer
*
render
)
;
void
RemoveCallback
(
const
CaptureEngine
aCapEngine
const
int
capture_id
)
;
void
ShutdownParent
(
)
;
void
ShutdownChild
(
)
;
nsTArray
<
CapturerElement
>
mCallbacks
;
Mutex
mCallbackMutex
;
bool
mIPCIsAlive
;
Mutex
mRequestMutex
;
Monitor
mReplyMonitor
;
bool
mReceivedReply
;
bool
mReplySuccess
;
int
mReplyInteger
;
webrtc
:
:
CaptureCapability
mReplyCapability
;
nsCString
mReplyDeviceName
;
nsCString
mReplyDeviceID
;
bool
mReplyScary
;
}
;
}
}
#
endif
