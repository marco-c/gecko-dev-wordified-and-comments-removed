#
include
"
MediaUtils
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRef
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsNetUtil
.
h
"
namespace
mozilla
:
:
media
{
bool
HostnameInPref
(
const
char
*
aPref
const
nsCString
&
aHostName
)
{
auto
HostInDomain
=
[
]
(
const
nsCString
&
aHost
const
nsCString
&
aPattern
)
{
int32_t
patternOffset
=
0
;
int32_t
hostOffset
=
0
;
if
(
StringBeginsWith
(
aPattern
nsCString
(
"
*
.
"
)
)
)
{
patternOffset
=
2
;
hostOffset
=
aHost
.
FindChar
(
'
.
'
)
+
1
;
if
(
hostOffset
<
=
1
)
{
return
false
;
}
}
nsDependentCString
hostRoot
(
aHost
hostOffset
)
;
return
hostRoot
.
EqualsIgnoreCase
(
aPattern
.
BeginReading
(
)
+
patternOffset
)
;
}
;
nsCString
domainList
;
nsresult
rv
=
Preferences
:
:
GetCString
(
aPref
domainList
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
domainList
.
StripWhitespace
(
)
;
if
(
domainList
.
IsEmpty
(
)
|
|
aHostName
.
IsEmpty
(
)
)
{
return
false
;
}
for
(
const
nsACString
&
each
:
domainList
.
Split
(
'
'
)
)
{
nsCString
domainPattern
;
rv
=
NS_DomainToASCIIAllowAnyGlyphfulASCII
(
each
domainPattern
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
HostInDomain
(
aHostName
domainPattern
)
)
{
return
true
;
}
}
else
{
NS_WARNING
(
"
Failed
to
convert
UTF
-
8
host
to
ASCII
"
)
;
}
}
return
false
;
}
nsCOMPtr
<
nsIAsyncShutdownClient
>
GetShutdownBarrier
(
)
{
nsCOMPtr
<
nsIAsyncShutdownService
>
svc
=
services
:
:
GetAsyncShutdownService
(
)
;
if
(
!
svc
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIAsyncShutdownClient
>
barrier
;
nsresult
rv
=
svc
-
>
GetProfileBeforeChange
(
getter_AddRefs
(
barrier
)
)
;
if
(
!
barrier
)
{
rv
=
svc
-
>
GetXpcomWillShutdown
(
getter_AddRefs
(
barrier
)
)
;
}
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_RELEASE_ASSERT
(
barrier
)
;
return
barrier
;
}
nsCOMPtr
<
nsIAsyncShutdownClient
>
MustGetShutdownBarrier
(
)
{
nsCOMPtr
<
nsIAsyncShutdownClient
>
barrier
=
GetShutdownBarrier
(
)
;
MOZ_RELEASE_ASSERT
(
barrier
)
;
return
barrier
;
}
NS_IMPL_ISUPPORTS
(
ShutdownBlocker
nsIAsyncShutdownBlocker
)
namespace
{
class
TicketBlocker
:
public
ShutdownBlocker
{
using
ShutdownMozPromise
=
ShutdownBlockingTicket
:
:
ShutdownMozPromise
;
public
:
explicit
TicketBlocker
(
const
nsAString
&
aName
)
:
ShutdownBlocker
(
aName
)
mPromise
(
mHolder
.
Ensure
(
__func__
)
)
{
}
NS_IMETHOD
BlockShutdown
(
nsIAsyncShutdownClient
*
aProfileBeforeChange
)
override
{
mHolder
.
Resolve
(
true
__func__
)
;
return
NS_OK
;
}
void
RejectIfExists
(
)
{
mHolder
.
RejectIfExists
(
false
__func__
)
;
}
ShutdownMozPromise
*
ShutdownPromise
(
)
{
return
mPromise
;
}
private
:
~
TicketBlocker
(
)
=
default
;
MozPromiseHolder
<
ShutdownMozPromise
>
mHolder
;
const
RefPtr
<
ShutdownMozPromise
>
mPromise
;
}
;
class
ShutdownBlockingTicketImpl
:
public
ShutdownBlockingTicket
{
private
:
RefPtr
<
TicketBlocker
>
mBlocker
;
public
:
explicit
ShutdownBlockingTicketImpl
(
RefPtr
<
TicketBlocker
>
aBlocker
)
:
mBlocker
(
std
:
:
move
(
aBlocker
)
)
{
}
static
UniquePtr
<
ShutdownBlockingTicket
>
Create
(
const
nsAString
&
aName
const
nsAString
&
aFileName
int32_t
aLineNr
)
{
auto
blocker
=
MakeRefPtr
<
TicketBlocker
>
(
aName
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ShutdownBlockingTicketImpl
:
:
AddBlocker
"
[
blocker
file
=
nsString
(
aFileName
)
aLineNr
]
{
MustGetShutdownBarrier
(
)
-
>
AddBlocker
(
blocker
file
aLineNr
u
"
"
_ns
)
;
}
)
)
;
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdown
)
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ShutdownBlockingTicketImpl
:
:
RemoveBlocker
"
[
blocker
]
{
MustGetShutdownBarrier
(
)
-
>
RemoveBlocker
(
blocker
)
;
blocker
-
>
RejectIfExists
(
)
;
}
)
)
;
return
nullptr
;
}
return
MakeUnique
<
ShutdownBlockingTicketImpl
>
(
std
:
:
move
(
blocker
)
)
;
}
~
ShutdownBlockingTicketImpl
(
)
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
blocker
=
std
:
:
move
(
mBlocker
)
]
{
GetShutdownBarrier
(
)
-
>
RemoveBlocker
(
blocker
)
;
blocker
-
>
RejectIfExists
(
)
;
}
)
)
)
;
}
ShutdownMozPromise
*
ShutdownPromise
(
)
override
{
return
mBlocker
-
>
ShutdownPromise
(
)
;
}
}
;
}
UniquePtr
<
ShutdownBlockingTicket
>
ShutdownBlockingTicket
:
:
Create
(
const
nsAString
&
aName
const
nsAString
&
aFileName
int32_t
aLineNr
)
{
return
ShutdownBlockingTicketImpl
:
:
Create
(
aName
aFileName
aLineNr
)
;
}
class
MainShutdownWatcher
final
:
public
ShutdownWatcher
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
explicit
MainShutdownWatcher
(
ShutdownConsumer
*
aConsumer
)
:
ShutdownWatcher
(
aConsumer
)
{
}
bool
Initialize
(
)
{
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownConfirmed
)
)
{
mConsumer
=
nullptr
;
return
false
;
}
nsCOMPtr
<
nsIObserverService
>
obsService
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obsService
)
)
{
mConsumer
=
nullptr
;
return
false
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
obsService
-
>
AddObserver
(
this
NS_XPCOM_WILL_SHUTDOWN_OBSERVER_ID
false
)
)
)
)
{
mConsumer
=
nullptr
;
return
false
;
}
mRegistered
=
true
;
return
true
;
}
void
Destroy
(
)
override
{
if
(
!
mRegistered
)
{
return
;
}
mRegistered
=
false
;
mConsumer
=
nullptr
;
if
(
nsCOMPtr
<
nsIObserverService
>
obsService
=
services
:
:
GetObserverService
(
)
)
{
obsService
-
>
RemoveObserver
(
this
NS_XPCOM_WILL_SHUTDOWN_OBSERVER_ID
)
;
}
}
NS_IMETHODIMP
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
MOZ_ASSERT
(
strcmp
(
aTopic
NS_XPCOM_WILL_SHUTDOWN_OBSERVER_ID
)
=
=
0
)
;
if
(
mConsumer
)
{
mConsumer
-
>
OnShutdown
(
)
;
}
Destroy
(
)
;
return
NS_OK
;
}
private
:
~
MainShutdownWatcher
(
)
override
{
Destroy
(
)
;
}
bool
mRegistered
=
false
;
}
;
NS_IMPL_ISUPPORTS
(
MainShutdownWatcher
nsIObserver
)
;
class
WorkerShutdownWatcher
final
:
public
ShutdownWatcher
{
public
:
NS_DECL_ISUPPORTS
explicit
WorkerShutdownWatcher
(
ShutdownConsumer
*
aConsumer
)
:
ShutdownWatcher
(
aConsumer
)
{
}
bool
Initialize
(
dom
:
:
WorkerPrivate
*
aWorkerPrivate
)
{
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdownConfirmed
)
)
{
mConsumer
=
nullptr
;
return
false
;
}
mWorkerRef
=
dom
:
:
WeakWorkerRef
:
:
Create
(
aWorkerPrivate
[
self
=
RefPtr
{
this
}
]
{
self
-
>
OnShutdown
(
)
;
}
)
;
if
(
NS_WARN_IF
(
!
mWorkerRef
)
)
{
mConsumer
=
nullptr
;
return
false
;
}
return
true
;
}
void
OnShutdown
(
)
{
if
(
mConsumer
)
{
mConsumer
-
>
OnShutdown
(
)
;
}
Destroy
(
)
;
}
void
Destroy
(
)
override
{
mWorkerRef
=
nullptr
;
mConsumer
=
nullptr
;
}
private
:
~
WorkerShutdownWatcher
(
)
override
{
Destroy
(
)
;
}
RefPtr
<
dom
:
:
WeakWorkerRef
>
mWorkerRef
;
}
;
NS_IMPL_ISUPPORTS0
(
WorkerShutdownWatcher
)
;
already_AddRefed
<
ShutdownWatcher
>
ShutdownWatcher
:
:
Create
(
ShutdownConsumer
*
aConsumer
)
{
if
(
NS_IsMainThread
(
)
)
{
auto
watcher
=
MakeRefPtr
<
MainShutdownWatcher
>
(
aConsumer
)
;
if
(
watcher
-
>
Initialize
(
)
)
{
return
watcher
.
forget
(
)
.
downcast
<
ShutdownWatcher
>
(
)
;
}
}
else
if
(
dom
:
:
WorkerPrivate
*
workerPrivate
=
dom
:
:
GetCurrentThreadWorkerPrivate
(
)
)
{
auto
watcher
=
MakeRefPtr
<
WorkerShutdownWatcher
>
(
aConsumer
)
;
if
(
watcher
-
>
Initialize
(
workerPrivate
)
)
{
return
watcher
.
forget
(
)
.
downcast
<
ShutdownWatcher
>
(
)
;
}
}
return
nullptr
;
}
}
