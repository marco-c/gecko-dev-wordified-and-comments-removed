#
include
"
CamerasParent
.
h
"
#
include
"
CamerasUtils
.
h
"
#
include
"
MediaEngine
.
h
"
#
include
"
MediaUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
undef
LOG
#
undef
LOG_ENABLED
PRLogModuleInfo
*
gCamerasParentLog
;
#
define
LOG
(
args
)
MOZ_LOG
(
gCamerasParentLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
MOZ_LOG_TEST
(
gCamerasParentLog
mozilla
:
:
LogLevel
:
:
Debug
)
namespace
mozilla
{
namespace
camera
{
class
FrameSizeChangeRunnable
:
public
nsRunnable
{
public
:
FrameSizeChangeRunnable
(
CamerasParent
*
aParent
CaptureEngine
capEngine
int
cap_id
unsigned
int
aWidth
unsigned
int
aHeight
)
:
mParent
(
aParent
)
mCapEngine
(
capEngine
)
mCapId
(
cap_id
)
mWidth
(
aWidth
)
mHeight
(
aHeight
)
{
}
NS_IMETHOD
Run
(
)
{
if
(
mParent
-
>
IsShuttingDown
(
)
)
{
LOG
(
(
"
FrameSizeChangeRunnable
is
active
without
active
Child
"
)
)
;
mResult
=
0
;
return
NS_OK
;
}
if
(
!
mParent
-
>
SendFrameSizeChange
(
mCapEngine
mCapId
mWidth
mHeight
)
)
{
mResult
=
-
1
;
}
else
{
mResult
=
0
;
}
return
NS_OK
;
}
int
GetResult
(
)
{
return
mResult
;
}
private
:
nsRefPtr
<
CamerasParent
>
mParent
;
CaptureEngine
mCapEngine
;
int
mCapId
;
unsigned
int
mWidth
;
unsigned
int
mHeight
;
int
mResult
;
}
;
int
CallbackHelper
:
:
FrameSizeChange
(
unsigned
int
w
unsigned
int
h
unsigned
int
streams
)
{
LOG
(
(
"
CallbackHelper
Video
FrameSizeChange
:
%
ux
%
u
"
w
h
)
)
;
nsRefPtr
<
FrameSizeChangeRunnable
>
runnable
=
new
FrameSizeChangeRunnable
(
mParent
mCapEngine
mCapturerId
w
h
)
;
MOZ_ASSERT
(
mParent
)
;
nsIThread
*
thread
=
mParent
-
>
GetBackgroundThread
(
)
;
MOZ_ASSERT
(
thread
!
=
nullptr
)
;
thread
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
return
0
;
}
class
DeliverFrameRunnable
:
public
nsRunnable
{
public
:
DeliverFrameRunnable
(
CamerasParent
*
aParent
CaptureEngine
engine
int
cap_id
ShmemBuffer
buffer
unsigned
char
*
altbuffer
int
size
uint32_t
time_stamp
int64_t
ntp_time
int64_t
render_time
)
:
mParent
(
aParent
)
mCapEngine
(
engine
)
mCapId
(
cap_id
)
mBuffer
(
Move
(
buffer
)
)
mSize
(
size
)
mTimeStamp
(
time_stamp
)
mNtpTime
(
ntp_time
)
mRenderTime
(
render_time
)
{
if
(
altbuffer
!
=
nullptr
)
{
mAlternateBuffer
.
reset
(
new
unsigned
char
[
size
]
)
;
memcpy
(
mAlternateBuffer
.
get
(
)
altbuffer
size
)
;
}
}
;
NS_IMETHOD
Run
(
)
{
if
(
mParent
-
>
IsShuttingDown
(
)
)
{
mResult
=
0
;
return
NS_OK
;
}
if
(
!
mParent
-
>
DeliverFrameOverIPC
(
mCapEngine
mCapId
Move
(
mBuffer
)
mAlternateBuffer
.
get
(
)
mSize
mTimeStamp
mNtpTime
mRenderTime
)
)
{
mResult
=
-
1
;
}
else
{
mResult
=
0
;
}
return
NS_OK
;
}
int
GetResult
(
)
{
return
mResult
;
}
private
:
nsRefPtr
<
CamerasParent
>
mParent
;
CaptureEngine
mCapEngine
;
int
mCapId
;
ShmemBuffer
mBuffer
;
mozilla
:
:
UniquePtr
<
unsigned
char
[
]
>
mAlternateBuffer
;
int
mSize
;
uint32_t
mTimeStamp
;
int64_t
mNtpTime
;
int64_t
mRenderTime
;
int
mResult
;
}
;
int
CamerasParent
:
:
DeliverFrameOverIPC
(
CaptureEngine
cap_engine
int
cap_id
ShmemBuffer
buffer
unsigned
char
*
altbuffer
int
size
uint32_t
time_stamp
int64_t
ntp_time
int64_t
render_time
)
{
if
(
altbuffer
!
=
nullptr
)
{
ShmemBuffer
shMemBuff
=
mShmemPool
.
Get
(
this
size
)
;
if
(
!
shMemBuff
.
Valid
(
)
)
{
LOG
(
(
"
No
usable
Video
shmem
in
DeliverFrame
(
out
of
buffers
?
)
"
)
)
;
return
0
;
}
memcpy
(
shMemBuff
.
GetBytes
(
)
altbuffer
size
)
;
if
(
!
SendDeliverFrame
(
cap_engine
cap_id
shMemBuff
.
Get
(
)
size
time_stamp
ntp_time
render_time
)
)
{
return
-
1
;
}
}
else
{
MOZ_ASSERT
(
buffer
.
Valid
(
)
)
;
if
(
!
SendDeliverFrame
(
cap_engine
cap_id
buffer
.
Get
(
)
size
time_stamp
ntp_time
render_time
)
)
{
return
-
1
;
}
}
return
0
;
}
ShmemBuffer
CamerasParent
:
:
GetBuffer
(
size_t
aSize
)
{
return
mShmemPool
.
GetIfAvailable
(
aSize
)
;
}
int
CallbackHelper
:
:
DeliverFrame
(
unsigned
char
*
buffer
int
size
uint32_t
time_stamp
int64_t
ntp_time
int64_t
render_time
void
*
handle
)
{
ShmemBuffer
shMemBuffer
=
mParent
-
>
GetBuffer
(
size
)
;
if
(
!
shMemBuffer
.
Valid
(
)
)
{
LOG
(
(
"
Correctly
sized
Video
shmem
not
available
in
DeliverFrame
"
)
)
;
}
else
{
memcpy
(
shMemBuffer
.
GetBytes
(
)
buffer
size
)
;
buffer
=
nullptr
;
}
nsRefPtr
<
DeliverFrameRunnable
>
runnable
=
new
DeliverFrameRunnable
(
mParent
mCapEngine
mCapturerId
Move
(
shMemBuffer
)
buffer
size
time_stamp
ntp_time
render_time
)
;
MOZ_ASSERT
(
mParent
)
;
nsIThread
*
thread
=
mParent
-
>
GetBackgroundThread
(
)
;
MOZ_ASSERT
(
thread
!
=
nullptr
)
;
thread
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
return
0
;
}
bool
CamerasParent
:
:
RecvReleaseFrame
(
mozilla
:
:
ipc
:
:
Shmem
&
&
s
)
{
mShmemPool
.
Put
(
ShmemBuffer
(
s
)
)
;
return
true
;
}
bool
CamerasParent
:
:
SetupEngine
(
CaptureEngine
aCapEngine
)
{
EngineHelper
*
helper
=
&
mEngines
[
aCapEngine
]
;
if
(
helper
-
>
mEngine
)
{
return
true
;
}
webrtc
:
:
CaptureDeviceInfo
*
captureDeviceInfo
=
nullptr
;
switch
(
aCapEngine
)
{
case
ScreenEngine
:
captureDeviceInfo
=
new
webrtc
:
:
CaptureDeviceInfo
(
webrtc
:
:
CaptureDeviceType
:
:
Screen
)
;
break
;
case
BrowserEngine
:
captureDeviceInfo
=
new
webrtc
:
:
CaptureDeviceInfo
(
webrtc
:
:
CaptureDeviceType
:
:
Browser
)
;
break
;
case
WinEngine
:
captureDeviceInfo
=
new
webrtc
:
:
CaptureDeviceInfo
(
webrtc
:
:
CaptureDeviceType
:
:
Window
)
;
break
;
case
AppEngine
:
captureDeviceInfo
=
new
webrtc
:
:
CaptureDeviceInfo
(
webrtc
:
:
CaptureDeviceType
:
:
Application
)
;
break
;
case
CameraEngine
:
captureDeviceInfo
=
new
webrtc
:
:
CaptureDeviceInfo
(
webrtc
:
:
CaptureDeviceType
:
:
Camera
)
;
break
;
default
:
LOG
(
(
"
Invalid
webrtc
Video
engine
"
)
)
;
MOZ_CRASH
(
)
;
break
;
}
helper
-
>
mConfig
.
Set
<
webrtc
:
:
CaptureDeviceInfo
>
(
captureDeviceInfo
)
;
helper
-
>
mEngine
=
webrtc
:
:
VideoEngine
:
:
Create
(
helper
-
>
mConfig
)
;
if
(
!
helper
-
>
mEngine
)
{
LOG
(
(
"
VideoEngine
:
:
Create
failed
"
)
)
;
return
false
;
}
helper
-
>
mPtrViEBase
=
webrtc
:
:
ViEBase
:
:
GetInterface
(
helper
-
>
mEngine
)
;
if
(
!
helper
-
>
mPtrViEBase
)
{
LOG
(
(
"
ViEBase
:
:
GetInterface
failed
"
)
)
;
return
false
;
}
if
(
helper
-
>
mPtrViEBase
-
>
Init
(
)
<
0
)
{
LOG
(
(
"
ViEBase
:
:
Init
failed
"
)
)
;
return
false
;
}
helper
-
>
mPtrViECapture
=
webrtc
:
:
ViECapture
:
:
GetInterface
(
helper
-
>
mEngine
)
;
if
(
!
helper
-
>
mPtrViECapture
)
{
LOG
(
(
"
ViECapture
:
:
GetInterface
failed
"
)
)
;
return
false
;
}
helper
-
>
mPtrViERender
=
webrtc
:
:
ViERender
:
:
GetInterface
(
helper
-
>
mEngine
)
;
if
(
!
helper
-
>
mPtrViERender
)
{
LOG
(
(
"
ViERender
:
:
GetInterface
failed
"
)
)
;
return
false
;
}
return
true
;
}
void
CamerasParent
:
:
CloseEngines
(
)
{
{
MutexAutoLock
lock
(
mCallbackMutex
)
;
while
(
mCallbacks
.
Length
(
)
)
{
auto
capEngine
=
mCallbacks
[
0
]
-
>
mCapEngine
;
auto
capNum
=
mCallbacks
[
0
]
-
>
mCapturerId
;
LOG
(
(
"
Forcing
shutdown
of
engine
%
d
capturer
%
d
"
capEngine
capNum
)
)
;
{
MutexAutoUnlock
unlock
(
mCallbackMutex
)
;
RecvStopCapture
(
capEngine
capNum
)
;
RecvReleaseCaptureDevice
(
capEngine
capNum
)
;
}
}
}
{
MutexAutoLock
lock
(
mEngineMutex
)
;
for
(
int
i
=
0
;
i
<
CaptureEngine
:
:
MaxEngine
;
i
+
+
)
{
if
(
mEngines
[
i
]
.
mEngineIsRunning
)
{
LOG
(
(
"
Being
closed
down
while
engine
%
d
is
running
!
"
i
)
)
;
}
if
(
mEngines
[
i
]
.
mPtrViERender
)
{
mEngines
[
i
]
.
mPtrViERender
-
>
Release
(
)
;
mEngines
[
i
]
.
mPtrViERender
=
nullptr
;
}
if
(
mEngines
[
i
]
.
mPtrViECapture
)
{
mEngines
[
i
]
.
mPtrViECapture
-
>
Release
(
)
;
mEngines
[
i
]
.
mPtrViECapture
=
nullptr
;
}
if
(
mEngines
[
i
]
.
mPtrViEBase
)
{
mEngines
[
i
]
.
mPtrViEBase
-
>
Release
(
)
;
mEngines
[
i
]
.
mPtrViEBase
=
nullptr
;
}
}
}
}
bool
CamerasParent
:
:
EnsureInitialized
(
int
aEngine
)
{
LOG
(
(
__PRETTY_FUNCTION__
)
)
;
CaptureEngine
capEngine
=
static_cast
<
CaptureEngine
>
(
aEngine
)
;
if
(
!
SetupEngine
(
capEngine
)
)
{
return
false
;
}
return
true
;
}
bool
CamerasParent
:
:
RecvNumberOfCaptureDevices
(
const
int
&
aCapEngine
)
{
LOG
(
(
__PRETTY_FUNCTION__
)
)
;
if
(
!
EnsureInitialized
(
aCapEngine
)
)
{
LOG
(
(
"
RecvNumberOfCaptureDevices
fails
to
initialize
"
)
)
;
unused
<
<
SendReplyFailure
(
)
;
return
false
;
}
nsRefPtr
<
CamerasParent
>
self
(
this
)
;
nsRefPtr
<
nsRunnable
>
webrtc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
aCapEngine
]
(
)
-
>
nsresult
{
MutexAutoLock
lock
(
self
-
>
mEngineMutex
)
;
int
num
=
-
1
;
if
(
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
)
{
num
=
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
-
>
NumberOfCaptureDevices
(
)
;
}
nsRefPtr
<
nsIRunnable
>
ipc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
num
]
(
)
-
>
nsresult
{
if
(
self
-
>
IsShuttingDown
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
num
<
0
)
{
LOG
(
(
"
RecvNumberOfCaptureDevices
couldn
'
t
find
devices
"
)
)
;
unused
<
<
self
-
>
SendReplyFailure
(
)
;
return
NS_ERROR_FAILURE
;
}
else
{
LOG
(
(
"
RecvNumberOfCaptureDevices
:
%
d
"
num
)
)
;
unused
<
<
self
-
>
SendReplyNumberOfCaptureDevices
(
num
)
;
return
NS_OK
;
}
}
)
;
self
-
>
mPBackgroundThread
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
mVideoCaptureThread
-
>
message_loop
(
)
-
>
PostTask
(
FROM_HERE
new
RunnableTask
(
webrtc_runnable
)
)
;
return
true
;
}
bool
CamerasParent
:
:
RecvNumberOfCapabilities
(
const
int
&
aCapEngine
const
nsCString
&
unique_id
)
{
LOG
(
(
__PRETTY_FUNCTION__
)
)
;
if
(
!
EnsureInitialized
(
aCapEngine
)
)
{
LOG
(
(
"
RecvNumberOfCapabilities
fails
to
initialize
"
)
)
;
unused
<
<
SendReplyFailure
(
)
;
return
false
;
}
LOG
(
(
"
Getting
caps
for
%
s
"
unique_id
.
get
(
)
)
)
;
nsRefPtr
<
CamerasParent
>
self
(
this
)
;
nsRefPtr
<
nsRunnable
>
webrtc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
unique_id
aCapEngine
]
(
)
-
>
nsresult
{
MutexAutoLock
lock
(
self
-
>
mEngineMutex
)
;
int
num
=
-
1
;
if
(
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
)
{
num
=
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
-
>
NumberOfCapabilities
(
unique_id
.
get
(
)
MediaEngineSource
:
:
kMaxUniqueIdLength
)
;
}
nsRefPtr
<
nsIRunnable
>
ipc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
num
]
(
)
-
>
nsresult
{
if
(
self
-
>
IsShuttingDown
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
num
<
0
)
{
LOG
(
(
"
RecvNumberOfCapabilities
couldn
'
t
find
capabilities
"
)
)
;
unused
<
<
self
-
>
SendReplyFailure
(
)
;
return
NS_ERROR_FAILURE
;
}
else
{
LOG
(
(
"
RecvNumberOfCapabilities
:
%
d
"
num
)
)
;
}
unused
<
<
self
-
>
SendReplyNumberOfCapabilities
(
num
)
;
return
NS_OK
;
}
)
;
self
-
>
mPBackgroundThread
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
mVideoCaptureThread
-
>
message_loop
(
)
-
>
PostTask
(
FROM_HERE
new
RunnableTask
(
webrtc_runnable
)
)
;
return
true
;
}
bool
CamerasParent
:
:
RecvGetCaptureCapability
(
const
int
&
aCapEngine
const
nsCString
&
unique_id
const
int
&
num
)
{
LOG
(
(
__PRETTY_FUNCTION__
)
)
;
if
(
!
EnsureInitialized
(
aCapEngine
)
)
{
LOG
(
(
"
Fails
to
initialize
"
)
)
;
unused
<
<
SendReplyFailure
(
)
;
return
false
;
}
LOG
(
(
"
RecvGetCaptureCapability
:
%
s
%
d
"
unique_id
.
get
(
)
num
)
)
;
nsRefPtr
<
CamerasParent
>
self
(
this
)
;
nsRefPtr
<
nsRunnable
>
webrtc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
unique_id
aCapEngine
num
]
(
)
-
>
nsresult
{
webrtc
:
:
CaptureCapability
webrtcCaps
;
MutexAutoLock
lock
(
self
-
>
mEngineMutex
)
;
int
error
=
-
1
;
if
(
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
)
{
error
=
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
-
>
GetCaptureCapability
(
unique_id
.
get
(
)
MediaEngineSource
:
:
kMaxUniqueIdLength
num
webrtcCaps
)
;
}
nsRefPtr
<
nsIRunnable
>
ipc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
webrtcCaps
error
]
(
)
-
>
nsresult
{
if
(
self
-
>
IsShuttingDown
(
)
)
{
return
NS_ERROR_FAILURE
;
}
CaptureCapability
capCap
(
webrtcCaps
.
width
webrtcCaps
.
height
webrtcCaps
.
maxFPS
webrtcCaps
.
expectedCaptureDelay
webrtcCaps
.
rawType
webrtcCaps
.
codecType
webrtcCaps
.
interlaced
)
;
LOG
(
(
"
Capability
:
%
u
%
u
%
u
%
u
%
d
%
d
"
webrtcCaps
.
width
webrtcCaps
.
height
webrtcCaps
.
maxFPS
webrtcCaps
.
expectedCaptureDelay
webrtcCaps
.
rawType
webrtcCaps
.
codecType
)
)
;
if
(
error
)
{
unused
<
<
self
-
>
SendReplyFailure
(
)
;
return
NS_ERROR_FAILURE
;
}
unused
<
<
self
-
>
SendReplyGetCaptureCapability
(
capCap
)
;
return
NS_OK
;
}
)
;
self
-
>
mPBackgroundThread
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
mVideoCaptureThread
-
>
message_loop
(
)
-
>
PostTask
(
FROM_HERE
new
RunnableTask
(
webrtc_runnable
)
)
;
return
true
;
}
bool
CamerasParent
:
:
RecvGetCaptureDevice
(
const
int
&
aCapEngine
const
int
&
aListNumber
)
{
LOG
(
(
__PRETTY_FUNCTION__
)
)
;
if
(
!
EnsureInitialized
(
aCapEngine
)
)
{
LOG
(
(
"
Fails
to
initialize
"
)
)
;
unused
<
<
SendReplyFailure
(
)
;
return
false
;
}
LOG
(
(
"
RecvGetCaptureDevice
"
)
)
;
nsRefPtr
<
CamerasParent
>
self
(
this
)
;
nsRefPtr
<
nsRunnable
>
webrtc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
aCapEngine
aListNumber
]
(
)
-
>
nsresult
{
char
deviceName
[
MediaEngineSource
:
:
kMaxDeviceNameLength
]
;
char
deviceUniqueId
[
MediaEngineSource
:
:
kMaxUniqueIdLength
]
;
nsCString
name
;
nsCString
uniqueId
;
MutexAutoLock
lock
(
self
-
>
mEngineMutex
)
;
int
error
=
-
1
;
if
(
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
)
{
error
=
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
-
>
GetCaptureDevice
(
aListNumber
deviceName
sizeof
(
deviceName
)
deviceUniqueId
sizeof
(
deviceUniqueId
)
)
;
}
if
(
!
error
)
{
name
.
Assign
(
deviceName
)
;
uniqueId
.
Assign
(
deviceUniqueId
)
;
}
nsRefPtr
<
nsIRunnable
>
ipc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
error
name
uniqueId
]
(
)
-
>
nsresult
{
if
(
self
-
>
IsShuttingDown
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
error
)
{
LOG
(
(
"
GetCaptureDevice
failed
:
%
d
"
error
)
)
;
unused
<
<
self
-
>
SendReplyFailure
(
)
;
return
NS_ERROR_FAILURE
;
}
LOG
(
(
"
Returning
%
s
name
%
s
id
"
name
.
get
(
)
uniqueId
.
get
(
)
)
)
;
unused
<
<
self
-
>
SendReplyGetCaptureDevice
(
name
uniqueId
)
;
return
NS_OK
;
}
)
;
self
-
>
mPBackgroundThread
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
mVideoCaptureThread
-
>
message_loop
(
)
-
>
PostTask
(
FROM_HERE
new
RunnableTask
(
webrtc_runnable
)
)
;
return
true
;
}
bool
CamerasParent
:
:
RecvAllocateCaptureDevice
(
const
int
&
aCapEngine
const
nsCString
&
unique_id
)
{
LOG
(
(
__PRETTY_FUNCTION__
)
)
;
if
(
!
EnsureInitialized
(
aCapEngine
)
)
{
LOG
(
(
"
Fails
to
initialize
"
)
)
;
unused
<
<
SendReplyFailure
(
)
;
return
false
;
}
nsRefPtr
<
CamerasParent
>
self
(
this
)
;
nsRefPtr
<
nsRunnable
>
webrtc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
aCapEngine
unique_id
]
(
)
-
>
nsresult
{
int
numdev
=
-
1
;
MutexAutoLock
lock
(
self
-
>
mEngineMutex
)
;
int
error
=
-
1
;
if
(
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
)
{
error
=
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
-
>
AllocateCaptureDevice
(
unique_id
.
get
(
)
MediaEngineSource
:
:
kMaxUniqueIdLength
numdev
)
;
}
nsRefPtr
<
nsIRunnable
>
ipc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
numdev
error
]
(
)
-
>
nsresult
{
if
(
self
-
>
IsShuttingDown
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
error
)
{
unused
<
<
self
-
>
SendReplyFailure
(
)
;
return
NS_ERROR_FAILURE
;
}
else
{
LOG
(
(
"
Allocated
device
nr
%
d
"
numdev
)
)
;
unused
<
<
self
-
>
SendReplyAllocateCaptureDevice
(
numdev
)
;
return
NS_OK
;
}
}
)
;
self
-
>
mPBackgroundThread
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
mVideoCaptureThread
-
>
message_loop
(
)
-
>
PostTask
(
FROM_HERE
new
RunnableTask
(
webrtc_runnable
)
)
;
return
true
;
}
bool
CamerasParent
:
:
RecvReleaseCaptureDevice
(
const
int
&
aCapEngine
const
int
&
numdev
)
{
LOG
(
(
__PRETTY_FUNCTION__
)
)
;
if
(
!
EnsureInitialized
(
aCapEngine
)
)
{
LOG
(
(
"
Fails
to
initialize
"
)
)
;
unused
<
<
SendReplyFailure
(
)
;
return
false
;
}
nsRefPtr
<
CamerasParent
>
self
(
this
)
;
nsRefPtr
<
nsRunnable
>
webrtc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
aCapEngine
numdev
]
(
)
-
>
nsresult
{
LOG
(
(
"
RecvReleaseCamera
device
nr
%
d
"
numdev
)
)
;
MutexAutoLock
lock
(
self
-
>
mEngineMutex
)
;
int
error
=
-
1
;
if
(
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
)
{
error
=
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
-
>
ReleaseCaptureDevice
(
numdev
)
;
}
nsRefPtr
<
nsIRunnable
>
ipc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
error
numdev
]
(
)
-
>
nsresult
{
if
(
self
-
>
IsShuttingDown
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
error
)
{
unused
<
<
self
-
>
SendReplyFailure
(
)
;
return
NS_ERROR_FAILURE
;
}
else
{
unused
<
<
self
-
>
SendReplySuccess
(
)
;
LOG
(
(
"
Freed
device
nr
%
d
"
numdev
)
)
;
return
NS_OK
;
}
}
)
;
self
-
>
mPBackgroundThread
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
#
ifndef
XP_MACOSX
mVideoCaptureThread
-
>
message_loop
(
)
-
>
PostTask
(
FROM_HERE
new
RunnableTask
(
webrtc_runnable
)
)
;
#
else
NS_DispatchToMainThread
(
webrtc_runnable
)
;
#
endif
return
true
;
}
bool
CamerasParent
:
:
RecvStartCapture
(
const
int
&
aCapEngine
const
int
&
capnum
const
CaptureCapability
&
ipcCaps
)
{
LOG
(
(
__PRETTY_FUNCTION__
)
)
;
if
(
!
EnsureInitialized
(
aCapEngine
)
)
{
LOG
(
(
"
Failure
to
initialize
"
)
)
;
unused
<
<
SendReplyFailure
(
)
;
return
false
;
}
nsRefPtr
<
CamerasParent
>
self
(
this
)
;
nsRefPtr
<
nsRunnable
>
webrtc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
aCapEngine
capnum
ipcCaps
]
(
)
-
>
nsresult
{
CallbackHelper
*
*
cbh
;
webrtc
:
:
ExternalRenderer
*
render
;
EngineHelper
*
helper
=
nullptr
;
int
error
;
{
MutexAutoLock
lockCallback
(
self
-
>
mCallbackMutex
)
;
cbh
=
self
-
>
mCallbacks
.
AppendElement
(
new
CallbackHelper
(
static_cast
<
CaptureEngine
>
(
aCapEngine
)
capnum
self
)
)
;
render
=
static_cast
<
webrtc
:
:
ExternalRenderer
*
>
(
*
cbh
)
;
}
{
MutexAutoLock
lockEngine
(
self
-
>
mEngineMutex
)
;
if
(
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
)
{
helper
=
&
self
-
>
mEngines
[
aCapEngine
]
;
error
=
helper
-
>
mPtrViERender
-
>
AddRenderer
(
capnum
webrtc
:
:
kVideoI420
render
)
;
}
else
{
error
=
-
1
;
}
if
(
!
error
)
{
error
=
helper
-
>
mPtrViERender
-
>
StartRender
(
capnum
)
;
}
webrtc
:
:
CaptureCapability
capability
;
capability
.
width
=
ipcCaps
.
width
(
)
;
capability
.
height
=
ipcCaps
.
height
(
)
;
capability
.
maxFPS
=
ipcCaps
.
maxFPS
(
)
;
capability
.
expectedCaptureDelay
=
ipcCaps
.
expectedCaptureDelay
(
)
;
capability
.
rawType
=
static_cast
<
webrtc
:
:
RawVideoType
>
(
ipcCaps
.
rawType
(
)
)
;
capability
.
codecType
=
static_cast
<
webrtc
:
:
VideoCodecType
>
(
ipcCaps
.
codecType
(
)
)
;
capability
.
interlaced
=
ipcCaps
.
interlaced
(
)
;
if
(
!
error
)
{
error
=
helper
-
>
mPtrViECapture
-
>
StartCapture
(
capnum
capability
)
;
}
if
(
!
error
)
{
helper
-
>
mEngineIsRunning
=
true
;
}
}
nsRefPtr
<
nsIRunnable
>
ipc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
error
]
(
)
-
>
nsresult
{
if
(
self
-
>
IsShuttingDown
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
error
)
{
unused
<
<
self
-
>
SendReplySuccess
(
)
;
return
NS_OK
;
}
else
{
unused
<
<
self
-
>
SendReplyFailure
(
)
;
return
NS_ERROR_FAILURE
;
}
}
)
;
self
-
>
mPBackgroundThread
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
mVideoCaptureThread
-
>
message_loop
(
)
-
>
PostTask
(
FROM_HERE
new
RunnableTask
(
webrtc_runnable
)
)
;
return
true
;
}
bool
CamerasParent
:
:
RecvStopCapture
(
const
int
&
aCapEngine
const
int
&
capnum
)
{
LOG
(
(
__PRETTY_FUNCTION__
)
)
;
if
(
!
EnsureInitialized
(
aCapEngine
)
)
{
LOG
(
(
"
Failure
to
initialize
"
)
)
;
unused
<
<
SendReplyFailure
(
)
;
return
false
;
}
nsRefPtr
<
CamerasParent
>
self
(
this
)
;
nsRefPtr
<
nsRunnable
>
webrtc_runnable
=
media
:
:
NewRunnableFrom
(
[
self
aCapEngine
capnum
]
(
)
-
>
nsresult
{
{
MutexAutoLock
lock
(
self
-
>
mEngineMutex
)
;
if
(
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
)
{
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViECapture
-
>
StopCapture
(
capnum
)
;
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViERender
-
>
StopRender
(
capnum
)
;
self
-
>
mEngines
[
aCapEngine
]
.
mPtrViERender
-
>
RemoveRenderer
(
capnum
)
;
self
-
>
mEngines
[
aCapEngine
]
.
mEngineIsRunning
=
false
;
}
}
MutexAutoLock
lock
(
self
-
>
mCallbackMutex
)
;
for
(
unsigned
int
i
=
0
;
i
<
self
-
>
mCallbacks
.
Length
(
)
;
i
+
+
)
{
if
(
self
-
>
mCallbacks
[
i
]
-
>
mCapEngine
=
=
aCapEngine
&
&
self
-
>
mCallbacks
[
i
]
-
>
mCapturerId
=
=
capnum
)
{
delete
self
-
>
mCallbacks
[
i
]
;
self
-
>
mCallbacks
.
RemoveElementAt
(
i
)
;
break
;
}
}
return
NS_OK
;
}
)
;
mVideoCaptureThread
-
>
message_loop
(
)
-
>
PostTask
(
FROM_HERE
new
RunnableTask
(
webrtc_runnable
)
)
;
return
SendReplySuccess
(
)
;
}
void
CamerasParent
:
:
StopIPC
(
)
{
MOZ_ASSERT
(
!
mDestroyed
)
;
mShmemPool
.
Cleanup
(
this
)
;
mChildIsAlive
=
false
;
mDestroyed
=
true
;
}
bool
CamerasParent
:
:
RecvAllDone
(
)
{
LOG
(
(
__PRETTY_FUNCTION__
)
)
;
mChildIsAlive
=
false
;
return
Send__delete__
(
this
)
;
}
void
CamerasParent
:
:
DoShutdown
(
)
{
LOG
(
(
__PRETTY_FUNCTION__
)
)
;
CloseEngines
(
)
;
{
MutexAutoLock
lock
(
mEngineMutex
)
;
for
(
int
i
=
0
;
i
<
CaptureEngine
:
:
MaxEngine
;
i
+
+
)
{
if
(
mEngines
[
i
]
.
mEngine
)
{
mEngines
[
i
]
.
mEngine
-
>
SetTraceCallback
(
nullptr
)
;
webrtc
:
:
VideoEngine
:
:
Delete
(
mEngines
[
i
]
.
mEngine
)
;
mEngines
[
i
]
.
mEngine
=
nullptr
;
}
}
}
mPBackgroundThread
=
nullptr
;
if
(
mVideoCaptureThread
)
{
if
(
mVideoCaptureThread
-
>
IsRunning
(
)
)
{
mVideoCaptureThread
-
>
Stop
(
)
;
}
delete
mVideoCaptureThread
;
mVideoCaptureThread
=
nullptr
;
}
}
void
CamerasParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
LOG
(
(
__PRETTY_FUNCTION__
)
)
;
StopIPC
(
)
;
CloseEngines
(
)
;
}
CamerasParent
:
:
CamerasParent
(
)
:
mCallbackMutex
(
"
CamerasParent
.
mCallbackMutex
"
)
mEngineMutex
(
"
CamerasParent
.
mEngineMutex
"
)
mShmemPool
(
CaptureEngine
:
:
MaxEngine
)
mVideoCaptureThread
(
nullptr
)
mChildIsAlive
(
true
)
mDestroyed
(
false
)
{
if
(
!
gCamerasParentLog
)
{
gCamerasParentLog
=
PR_NewLogModule
(
"
CamerasParent
"
)
;
}
LOG
(
(
"
CamerasParent
:
%
p
"
this
)
)
;
mPBackgroundThread
=
NS_GetCurrentThread
(
)
;
MOZ_ASSERT
(
mPBackgroundThread
!
=
nullptr
"
GetCurrentThread
failed
"
)
;
LOG
(
(
"
Spinning
up
WebRTC
Cameras
Thread
"
)
)
;
mVideoCaptureThread
=
new
base
:
:
Thread
(
"
VideoCapture
"
)
;
base
:
:
Thread
:
:
Options
options
;
#
if
defined
(
_WIN32
)
options
.
message_loop_type
=
MessageLoop
:
:
TYPE_MOZILLA_NONMAINUITHREAD
;
#
else
options
.
message_loop_type
=
MessageLoop
:
:
TYPE_MOZILLA_NONMAINTHREAD
;
#
endif
if
(
!
mVideoCaptureThread
-
>
StartWithOptions
(
options
)
)
{
MOZ_CRASH
(
)
;
}
MOZ_COUNT_CTOR
(
CamerasParent
)
;
}
CamerasParent
:
:
~
CamerasParent
(
)
{
LOG
(
(
"
~
CamerasParent
:
%
p
"
this
)
)
;
MOZ_COUNT_DTOR
(
CamerasParent
)
;
DoShutdown
(
)
;
}
already_AddRefed
<
CamerasParent
>
CamerasParent
:
:
Create
(
)
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
nsRefPtr
<
CamerasParent
>
camerasParent
=
new
CamerasParent
(
)
;
return
camerasParent
.
forget
(
)
;
}
}
}
