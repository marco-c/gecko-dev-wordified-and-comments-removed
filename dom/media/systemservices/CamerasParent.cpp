#
include
"
CamerasParent
.
h
"
#
include
"
MediaEngineSource
.
h
"
#
include
"
MediaUtils
.
h
"
#
include
"
VideoFrameUtils
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundParent
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_permissions
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
common_video
/
libyuv
/
include
/
webrtc_libyuv
.
h
"
#
if
defined
(
_WIN32
)
#
include
<
process
.
h
>
#
define
getpid
(
)
_getpid
(
)
#
endif
#
undef
LOG
#
undef
LOG_VERBOSE
#
undef
LOG_ENABLED
mozilla
:
:
LazyLogModule
gCamerasParentLog
(
"
CamerasParent
"
)
;
#
define
LOG
(
.
.
.
)
\
MOZ_LOG
(
gCamerasParentLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
define
LOG_VERBOSE
(
.
.
.
)
\
MOZ_LOG
(
gCamerasParentLog
mozilla
:
:
LogLevel
:
:
Verbose
(
__VA_ARGS__
)
)
#
define
LOG_ENABLED
(
)
MOZ_LOG_TEST
(
gCamerasParentLog
mozilla
:
:
LogLevel
:
:
Debug
)
namespace
mozilla
{
using
media
:
:
MustGetShutdownBarrier
;
using
media
:
:
NewRunnableFrom
;
namespace
camera
{
std
:
:
map
<
uint32_t
const
char
*
>
sDeviceUniqueIDs
;
std
:
:
map
<
uint32_t
webrtc
:
:
VideoCaptureCapability
>
sAllRequestedCapabilities
;
uint32_t
ResolutionFeasibilityDistance
(
int32_t
candidate
int32_t
requested
)
{
MOZ_DIAGNOSTIC_ASSERT
(
candidate
>
=
0
"
Candidate
unexpectedly
negative
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
requested
>
=
0
"
Requested
unexpectedly
negative
"
)
;
if
(
candidate
=
=
0
)
{
return
0
;
}
uint32_t
distance
=
std
:
:
abs
(
candidate
-
requested
)
*
1000
/
std
:
:
max
(
candidate
requested
)
;
if
(
candidate
>
=
requested
)
{
return
distance
;
}
return
10000
+
distance
;
}
uint32_t
FeasibilityDistance
(
int32_t
candidate
int32_t
requested
)
{
MOZ_DIAGNOSTIC_ASSERT
(
candidate
>
=
0
"
Candidate
unexpectedly
negative
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
requested
>
=
0
"
Requested
unexpectedly
negative
"
)
;
if
(
candidate
=
=
0
)
{
return
0
;
}
return
std
:
:
abs
(
candidate
-
requested
)
*
1000
/
std
:
:
max
(
candidate
requested
)
;
}
StaticRefPtr
<
VideoEngine
>
CamerasParent
:
:
sEngines
[
CaptureEngine
:
:
MaxEngine
]
;
int32_t
CamerasParent
:
:
sNumOfOpenCamerasParentEngines
=
0
;
int32_t
CamerasParent
:
:
sNumOfCamerasParents
=
0
;
base
:
:
Thread
*
CamerasParent
:
:
sVideoCaptureThread
=
nullptr
;
Monitor
*
CamerasParent
:
:
sThreadMonitor
=
nullptr
;
StaticMutex
CamerasParent
:
:
sMutex
;
void
InputObserver
:
:
OnDeviceChange
(
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
MOZ_ASSERT
(
mParent
)
;
RefPtr
<
InputObserver
>
self
(
this
)
;
RefPtr
<
nsIRunnable
>
ipc_runnable
=
NewRunnableFrom
(
[
self
]
(
)
{
if
(
self
-
>
mParent
-
>
IsShuttingDown
(
)
)
{
LOG
(
"
OnDeviceChanged
failure
:
parent
shutting
down
.
"
)
;
return
NS_ERROR_FAILURE
;
}
Unused
<
<
self
-
>
mParent
-
>
SendDeviceChange
(
)
;
return
NS_OK
;
}
)
;
nsIEventTarget
*
target
=
mParent
-
>
GetBackgroundEventTarget
(
)
;
MOZ_ASSERT
(
target
!
=
nullptr
)
;
target
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
}
;
class
DeliverFrameRunnable
:
public
mozilla
:
:
Runnable
{
public
:
DeliverFrameRunnable
(
CamerasParent
*
aParent
CaptureEngine
aEngine
uint32_t
aStreamId
const
webrtc
:
:
VideoFrame
&
aFrame
const
VideoFrameProperties
&
aProperties
)
:
Runnable
(
"
camera
:
:
DeliverFrameRunnable
"
)
mParent
(
aParent
)
mCapEngine
(
aEngine
)
mStreamId
(
aStreamId
)
mProperties
(
aProperties
)
mResult
(
0
)
{
mAlternateBuffer
.
reset
(
new
unsigned
char
[
aProperties
.
bufferSize
(
)
]
)
;
VideoFrameUtils
:
:
CopyVideoFrameBuffers
(
mAlternateBuffer
.
get
(
)
aProperties
.
bufferSize
(
)
aFrame
)
;
}
DeliverFrameRunnable
(
CamerasParent
*
aParent
CaptureEngine
aEngine
uint32_t
aStreamId
ShmemBuffer
aBuffer
VideoFrameProperties
&
aProperties
)
:
Runnable
(
"
camera
:
:
DeliverFrameRunnable
"
)
mParent
(
aParent
)
mCapEngine
(
aEngine
)
mStreamId
(
aStreamId
)
mBuffer
(
std
:
:
move
(
aBuffer
)
)
mProperties
(
aProperties
)
mResult
(
0
)
{
}
;
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
GetCurrentSerialEventTarget
(
)
=
=
mParent
-
>
mPBackgroundEventTarget
)
;
if
(
mParent
-
>
IsShuttingDown
(
)
)
{
mResult
=
0
;
return
NS_OK
;
}
if
(
!
mParent
-
>
DeliverFrameOverIPC
(
mCapEngine
mStreamId
std
:
:
move
(
mBuffer
)
mAlternateBuffer
.
get
(
)
mProperties
)
)
{
mResult
=
-
1
;
}
else
{
mResult
=
0
;
}
return
NS_OK
;
}
int
GetResult
(
)
{
return
mResult
;
}
private
:
RefPtr
<
CamerasParent
>
mParent
;
CaptureEngine
mCapEngine
;
uint32_t
mStreamId
;
ShmemBuffer
mBuffer
;
UniquePtr
<
unsigned
char
[
]
>
mAlternateBuffer
;
VideoFrameProperties
mProperties
;
int
mResult
;
}
;
NS_IMPL_ISUPPORTS
(
CamerasParent
nsIAsyncShutdownBlocker
)
nsresult
CamerasParent
:
:
DispatchToVideoCaptureThread
(
RefPtr
<
Runnable
>
event
)
{
MonitorAutoLock
lock
(
*
sThreadMonitor
)
;
if
(
!
sVideoCaptureThread
)
{
LOG
(
"
Can
'
t
dispatch
to
video
capture
thread
:
thread
not
present
"
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
sVideoCaptureThread
-
>
thread_id
(
)
!
=
PlatformThread
:
:
CurrentId
(
)
)
;
sVideoCaptureThread
-
>
message_loop
(
)
-
>
PostTask
(
event
.
forget
(
)
)
;
return
NS_OK
;
}
void
CamerasParent
:
:
StopVideoCapture
(
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
RefPtr
<
CamerasParent
>
self
(
this
)
;
DebugOnly
<
nsresult
>
rv
=
DispatchToVideoCaptureThread
(
NewRunnableFrom
(
[
self
]
(
)
{
MonitorAutoLock
lock
(
*
(
self
-
>
sThreadMonitor
)
)
;
self
-
>
CloseEngines
(
)
;
base
:
:
Thread
*
thread
=
nullptr
;
if
(
sNumOfOpenCamerasParentEngines
=
=
0
&
&
self
-
>
sVideoCaptureThread
)
{
thread
=
self
-
>
sVideoCaptureThread
;
self
-
>
sVideoCaptureThread
=
nullptr
;
}
nsresult
rv
=
NS_DispatchToMainThread
(
NewRunnableFrom
(
[
self
thread
]
(
)
{
if
(
thread
)
{
thread
-
>
Stop
(
)
;
delete
thread
;
}
(
void
)
MustGetShutdownBarrier
(
)
-
>
RemoveBlocker
(
self
)
;
return
NS_OK
;
}
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
dispatch
for
video
thread
shutdown
"
)
;
return
rv
;
}
)
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
|
|
!
mWebRTCAlive
)
;
#
endif
}
int
CamerasParent
:
:
DeliverFrameOverIPC
(
CaptureEngine
capEng
uint32_t
aStreamId
ShmemBuffer
buffer
unsigned
char
*
altbuffer
VideoFrameProperties
&
aProps
)
{
if
(
altbuffer
!
=
nullptr
)
{
ShmemBuffer
shMemBuff
=
mShmemPool
.
Get
(
this
aProps
.
bufferSize
(
)
)
;
if
(
!
shMemBuff
.
Valid
(
)
)
{
LOG
(
"
No
usable
Video
shmem
in
DeliverFrame
(
out
of
buffers
?
)
"
)
;
return
0
;
}
memcpy
(
shMemBuff
.
GetBytes
(
)
altbuffer
aProps
.
bufferSize
(
)
)
;
if
(
!
SendDeliverFrame
(
capEng
aStreamId
std
:
:
move
(
shMemBuff
.
Get
(
)
)
aProps
)
)
{
return
-
1
;
}
}
else
{
MOZ_ASSERT
(
buffer
.
Valid
(
)
)
;
if
(
!
SendDeliverFrame
(
capEng
aStreamId
std
:
:
move
(
buffer
.
Get
(
)
)
aProps
)
)
{
return
-
1
;
}
}
return
0
;
}
ShmemBuffer
CamerasParent
:
:
GetBuffer
(
size_t
aSize
)
{
return
mShmemPool
.
GetIfAvailable
(
aSize
)
;
}
void
CallbackHelper
:
:
OnFrame
(
const
webrtc
:
:
VideoFrame
&
aVideoFrame
)
{
LOG_VERBOSE
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
RefPtr
<
DeliverFrameRunnable
>
runnable
=
nullptr
;
camera
:
:
VideoFrameProperties
properties
;
VideoFrameUtils
:
:
InitFrameBufferProperties
(
aVideoFrame
properties
)
;
ShmemBuffer
shMemBuffer
=
mParent
-
>
GetBuffer
(
properties
.
bufferSize
(
)
)
;
if
(
!
shMemBuffer
.
Valid
(
)
)
{
LOG
(
"
Correctly
sized
Video
shmem
not
available
in
DeliverFrame
"
)
;
}
else
{
VideoFrameUtils
:
:
CopyVideoFrameBuffers
(
shMemBuffer
.
GetBytes
(
)
properties
.
bufferSize
(
)
aVideoFrame
)
;
runnable
=
new
DeliverFrameRunnable
(
mParent
mCapEngine
mStreamId
std
:
:
move
(
shMemBuffer
)
properties
)
;
}
if
(
!
runnable
)
{
runnable
=
new
DeliverFrameRunnable
(
mParent
mCapEngine
mStreamId
aVideoFrame
properties
)
;
}
MOZ_ASSERT
(
mParent
)
;
nsIEventTarget
*
target
=
mParent
-
>
GetBackgroundEventTarget
(
)
;
MOZ_ASSERT
(
target
!
=
nullptr
)
;
target
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CamerasParent
:
:
RecvReleaseFrame
(
mozilla
:
:
ipc
:
:
Shmem
&
&
s
)
{
mShmemPool
.
Put
(
ShmemBuffer
(
s
)
)
;
return
IPC_OK
(
)
;
}
bool
CamerasParent
:
:
SetupEngine
(
CaptureEngine
aCapEngine
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
StaticRefPtr
<
VideoEngine
>
&
engine
=
sEngines
[
aCapEngine
]
;
if
(
!
engine
)
{
UniquePtr
<
webrtc
:
:
CaptureDeviceInfo
>
captureDeviceInfo
;
auto
config
=
MakeUnique
<
webrtc
:
:
Config
>
(
)
;
switch
(
aCapEngine
)
{
case
ScreenEngine
:
captureDeviceInfo
=
MakeUnique
<
webrtc
:
:
CaptureDeviceInfo
>
(
webrtc
:
:
CaptureDeviceType
:
:
Screen
)
;
break
;
case
BrowserEngine
:
captureDeviceInfo
=
MakeUnique
<
webrtc
:
:
CaptureDeviceInfo
>
(
webrtc
:
:
CaptureDeviceType
:
:
Browser
)
;
break
;
case
WinEngine
:
captureDeviceInfo
=
MakeUnique
<
webrtc
:
:
CaptureDeviceInfo
>
(
webrtc
:
:
CaptureDeviceType
:
:
Window
)
;
break
;
case
CameraEngine
:
captureDeviceInfo
=
MakeUnique
<
webrtc
:
:
CaptureDeviceInfo
>
(
webrtc
:
:
CaptureDeviceType
:
:
Camera
)
;
break
;
default
:
LOG
(
"
Invalid
webrtc
Video
engine
"
)
;
MOZ_CRASH
(
)
;
break
;
}
config
-
>
Set
<
webrtc
:
:
CaptureDeviceInfo
>
(
captureDeviceInfo
.
release
(
)
)
;
engine
=
VideoEngine
:
:
Create
(
std
:
:
move
(
config
)
)
;
if
(
!
engine
)
{
LOG
(
"
VideoEngine
:
:
Create
failed
"
)
;
return
false
;
}
}
if
(
aCapEngine
=
=
CameraEngine
&
&
!
mCameraObserver
)
{
mCameraObserver
=
new
InputObserver
(
this
)
;
auto
device_info
=
engine
-
>
GetOrCreateVideoCaptureDeviceInfo
(
)
;
MOZ_ASSERT
(
device_info
)
;
if
(
device_info
)
{
device_info
-
>
RegisterVideoInputFeedBack
(
mCameraObserver
)
;
}
}
return
true
;
}
void
CamerasParent
:
:
CloseEngines
(
)
{
sThreadMonitor
-
>
AssertCurrentThreadOwns
(
)
;
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
if
(
!
mWebRTCAlive
)
{
return
;
}
MOZ_ASSERT
(
sVideoCaptureThread
-
>
thread_id
(
)
=
=
PlatformThread
:
:
CurrentId
(
)
)
;
while
(
mCallbacks
.
Length
(
)
)
{
auto
capEngine
=
mCallbacks
[
0
]
-
>
mCapEngine
;
auto
streamNum
=
mCallbacks
[
0
]
-
>
mStreamId
;
LOG
(
"
Forcing
shutdown
of
engine
%
d
capturer
%
d
"
capEngine
streamNum
)
;
StopCapture
(
capEngine
streamNum
)
;
Unused
<
<
ReleaseCapture
(
capEngine
streamNum
)
;
}
StaticRefPtr
<
VideoEngine
>
&
engine
=
sEngines
[
CameraEngine
]
;
if
(
engine
&
&
mCameraObserver
)
{
auto
device_info
=
engine
-
>
GetOrCreateVideoCaptureDeviceInfo
(
)
;
MOZ_ASSERT
(
device_info
)
;
if
(
device_info
)
{
device_info
-
>
DeRegisterVideoInputFeedBack
(
mCameraObserver
)
;
}
mCameraObserver
=
nullptr
;
}
sNumOfOpenCamerasParentEngines
-
-
;
if
(
sNumOfOpenCamerasParentEngines
=
=
0
)
{
for
(
StaticRefPtr
<
VideoEngine
>
&
engine
:
sEngines
)
{
if
(
engine
)
{
VideoEngine
:
:
Delete
(
engine
)
;
engine
=
nullptr
;
}
}
}
mWebRTCAlive
=
false
;
}
VideoEngine
*
CamerasParent
:
:
EnsureInitialized
(
int
aEngine
)
{
LOG_VERBOSE
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
if
(
!
mWebRTCAlive
)
{
return
nullptr
;
}
CaptureEngine
capEngine
=
static_cast
<
CaptureEngine
>
(
aEngine
)
;
if
(
!
SetupEngine
(
capEngine
)
)
{
LOG
(
"
CamerasParent
failed
to
initialize
engine
"
)
;
return
nullptr
;
}
return
sEngines
[
aEngine
]
;
}
mozilla
:
:
ipc
:
:
IPCResult
CamerasParent
:
:
RecvNumberOfCaptureDevices
(
const
CaptureEngine
&
aCapEngine
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
LOG
(
"
CaptureEngine
=
%
d
"
aCapEngine
)
;
RefPtr
<
CamerasParent
>
self
(
this
)
;
RefPtr
<
Runnable
>
webrtc_runnable
=
NewRunnableFrom
(
[
self
aCapEngine
]
(
)
{
int
num
=
-
1
;
if
(
auto
engine
=
self
-
>
EnsureInitialized
(
aCapEngine
)
)
{
if
(
auto
devInfo
=
engine
-
>
GetOrCreateVideoCaptureDeviceInfo
(
)
)
{
num
=
devInfo
-
>
NumberOfDevices
(
)
;
}
}
RefPtr
<
nsIRunnable
>
ipc_runnable
=
NewRunnableFrom
(
[
self
num
]
(
)
{
if
(
!
self
-
>
mChildIsAlive
)
{
LOG
(
"
RecvNumberOfCaptureDevices
failure
:
child
not
alive
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
num
<
0
)
{
LOG
(
"
RecvNumberOfCaptureDevices
couldn
'
t
find
devices
"
)
;
Unused
<
<
self
-
>
SendReplyFailure
(
)
;
return
NS_ERROR_FAILURE
;
}
LOG
(
"
RecvNumberOfCaptureDevices
:
%
d
"
num
)
;
Unused
<
<
self
-
>
SendReplyNumberOfCaptureDevices
(
num
)
;
return
NS_OK
;
}
)
;
self
-
>
mPBackgroundEventTarget
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
DispatchToVideoCaptureThread
(
webrtc_runnable
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CamerasParent
:
:
RecvEnsureInitialized
(
const
CaptureEngine
&
aCapEngine
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
RefPtr
<
CamerasParent
>
self
(
this
)
;
RefPtr
<
Runnable
>
webrtc_runnable
=
NewRunnableFrom
(
[
self
aCapEngine
]
(
)
{
bool
result
=
self
-
>
EnsureInitialized
(
aCapEngine
)
;
RefPtr
<
nsIRunnable
>
ipc_runnable
=
NewRunnableFrom
(
[
self
result
]
(
)
{
if
(
!
self
-
>
mChildIsAlive
)
{
LOG
(
"
RecvEnsureInitialized
:
child
not
alive
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
result
)
{
LOG
(
"
RecvEnsureInitialized
failed
"
)
;
Unused
<
<
self
-
>
SendReplyFailure
(
)
;
return
NS_ERROR_FAILURE
;
}
LOG
(
"
RecvEnsureInitialized
succeeded
"
)
;
Unused
<
<
self
-
>
SendReplySuccess
(
)
;
return
NS_OK
;
}
)
;
self
-
>
mPBackgroundEventTarget
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
DispatchToVideoCaptureThread
(
webrtc_runnable
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CamerasParent
:
:
RecvNumberOfCapabilities
(
const
CaptureEngine
&
aCapEngine
const
nsCString
&
unique_id
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
LOG
(
"
Getting
caps
for
%
s
"
unique_id
.
get
(
)
)
;
RefPtr
<
CamerasParent
>
self
(
this
)
;
RefPtr
<
Runnable
>
webrtc_runnable
=
NewRunnableFrom
(
[
self
unique_id
aCapEngine
]
(
)
{
int
num
=
-
1
;
if
(
auto
engine
=
self
-
>
EnsureInitialized
(
aCapEngine
)
)
{
if
(
auto
devInfo
=
engine
-
>
GetOrCreateVideoCaptureDeviceInfo
(
)
)
{
num
=
devInfo
-
>
NumberOfCapabilities
(
unique_id
.
get
(
)
)
;
}
}
RefPtr
<
nsIRunnable
>
ipc_runnable
=
NewRunnableFrom
(
[
self
num
]
(
)
{
if
(
!
self
-
>
mChildIsAlive
)
{
LOG
(
"
RecvNumberOfCapabilities
:
child
not
alive
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
num
<
0
)
{
LOG
(
"
RecvNumberOfCapabilities
couldn
'
t
find
capabilities
"
)
;
Unused
<
<
self
-
>
SendReplyFailure
(
)
;
return
NS_ERROR_FAILURE
;
}
LOG
(
"
RecvNumberOfCapabilities
:
%
d
"
num
)
;
Unused
<
<
self
-
>
SendReplyNumberOfCapabilities
(
num
)
;
return
NS_OK
;
}
)
;
self
-
>
mPBackgroundEventTarget
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
DispatchToVideoCaptureThread
(
webrtc_runnable
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CamerasParent
:
:
RecvGetCaptureCapability
(
const
CaptureEngine
&
aCapEngine
const
nsCString
&
unique_id
const
int
&
num
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
LOG
(
"
RecvGetCaptureCapability
:
%
s
%
d
"
unique_id
.
get
(
)
num
)
;
RefPtr
<
CamerasParent
>
self
(
this
)
;
RefPtr
<
Runnable
>
webrtc_runnable
=
NewRunnableFrom
(
[
self
unique_id
aCapEngine
num
]
(
)
{
webrtc
:
:
VideoCaptureCapability
webrtcCaps
;
int
error
=
-
1
;
if
(
auto
engine
=
self
-
>
EnsureInitialized
(
aCapEngine
)
)
{
if
(
auto
devInfo
=
engine
-
>
GetOrCreateVideoCaptureDeviceInfo
(
)
)
{
error
=
devInfo
-
>
GetCapability
(
unique_id
.
get
(
)
num
webrtcCaps
)
;
}
if
(
!
error
&
&
aCapEngine
=
=
CameraEngine
)
{
auto
iter
=
self
-
>
mAllCandidateCapabilities
.
find
(
unique_id
)
;
if
(
iter
=
=
self
-
>
mAllCandidateCapabilities
.
end
(
)
)
{
std
:
:
map
<
uint32_t
webrtc
:
:
VideoCaptureCapability
>
candidateCapabilities
;
candidateCapabilities
.
emplace
(
num
webrtcCaps
)
;
self
-
>
mAllCandidateCapabilities
.
emplace
(
nsCString
(
unique_id
)
candidateCapabilities
)
;
}
else
{
(
iter
-
>
second
)
.
emplace
(
num
webrtcCaps
)
;
}
}
}
RefPtr
<
nsIRunnable
>
ipc_runnable
=
NewRunnableFrom
(
[
self
webrtcCaps
error
]
(
)
{
if
(
!
self
-
>
mChildIsAlive
)
{
LOG
(
"
RecvGetCaptureCapability
:
child
not
alive
"
)
;
return
NS_ERROR_FAILURE
;
}
VideoCaptureCapability
capCap
(
webrtcCaps
.
width
webrtcCaps
.
height
webrtcCaps
.
maxFPS
static_cast
<
int
>
(
webrtcCaps
.
videoType
)
webrtcCaps
.
interlaced
)
;
LOG
(
"
Capability
:
%
u
%
u
%
u
%
d
%
d
"
webrtcCaps
.
width
webrtcCaps
.
height
webrtcCaps
.
maxFPS
static_cast
<
int
>
(
webrtcCaps
.
videoType
)
webrtcCaps
.
interlaced
)
;
if
(
error
)
{
LOG
(
"
RecvGetCaptureCapability
:
reply
failure
"
)
;
Unused
<
<
self
-
>
SendReplyFailure
(
)
;
return
NS_ERROR_FAILURE
;
}
Unused
<
<
self
-
>
SendReplyGetCaptureCapability
(
capCap
)
;
return
NS_OK
;
}
)
;
self
-
>
mPBackgroundEventTarget
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
DispatchToVideoCaptureThread
(
webrtc_runnable
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CamerasParent
:
:
RecvGetCaptureDevice
(
const
CaptureEngine
&
aCapEngine
const
int
&
aDeviceIndex
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
RefPtr
<
CamerasParent
>
self
(
this
)
;
RefPtr
<
Runnable
>
webrtc_runnable
=
NewRunnableFrom
(
[
self
aCapEngine
aDeviceIndex
]
(
)
{
char
deviceName
[
MediaEngineSource
:
:
kMaxDeviceNameLength
]
;
char
deviceUniqueId
[
MediaEngineSource
:
:
kMaxUniqueIdLength
]
;
nsCString
name
;
nsCString
uniqueId
;
pid_t
devicePid
=
0
;
int
error
=
-
1
;
if
(
auto
engine
=
self
-
>
EnsureInitialized
(
aCapEngine
)
)
{
if
(
auto
devInfo
=
engine
-
>
GetOrCreateVideoCaptureDeviceInfo
(
)
)
{
error
=
devInfo
-
>
GetDeviceName
(
aDeviceIndex
deviceName
sizeof
(
deviceName
)
deviceUniqueId
sizeof
(
deviceUniqueId
)
nullptr
0
&
devicePid
)
;
}
}
if
(
!
error
)
{
name
.
Assign
(
deviceName
)
;
uniqueId
.
Assign
(
deviceUniqueId
)
;
}
RefPtr
<
nsIRunnable
>
ipc_runnable
=
NewRunnableFrom
(
[
self
error
name
uniqueId
devicePid
]
(
)
{
if
(
!
self
-
>
mChildIsAlive
)
{
return
NS_ERROR_FAILURE
;
}
if
(
error
)
{
LOG
(
"
GetCaptureDevice
failed
:
%
d
"
error
)
;
Unused
<
<
self
-
>
SendReplyFailure
(
)
;
return
NS_ERROR_FAILURE
;
}
bool
scary
=
(
devicePid
=
=
getpid
(
)
)
;
LOG
(
"
Returning
%
s
name
%
s
id
(
pid
=
%
d
)
%
s
"
name
.
get
(
)
uniqueId
.
get
(
)
devicePid
(
scary
?
"
(
scary
)
"
:
"
"
)
)
;
Unused
<
<
self
-
>
SendReplyGetCaptureDevice
(
name
uniqueId
scary
)
;
return
NS_OK
;
}
)
;
self
-
>
mPBackgroundEventTarget
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
DispatchToVideoCaptureThread
(
webrtc_runnable
)
;
return
IPC_OK
(
)
;
}
static
bool
HasCameraPermission
(
const
uint64_t
&
aWindowId
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
dom
:
:
WindowGlobalParent
>
window
=
dom
:
:
WindowGlobalParent
:
:
GetByInnerWindowId
(
aWindowId
)
;
if
(
!
window
)
{
return
false
;
}
if
(
StaticPrefs
:
:
permissions_delegation_enabled
(
)
)
{
RefPtr
<
dom
:
:
BrowsingContext
>
topBC
=
window
-
>
BrowsingContext
(
)
-
>
Top
(
)
;
window
=
topBC
-
>
Canonical
(
)
-
>
GetCurrentWindowGlobal
(
)
;
}
if
(
!
window
|
|
!
window
-
>
IsCurrentGlobal
(
)
)
{
return
false
;
}
nsIPrincipal
*
principal
=
window
-
>
DocumentPrincipal
(
)
;
if
(
principal
-
>
GetIsNullPrincipal
(
)
)
{
return
false
;
}
if
(
principal
-
>
IsSystemPrincipal
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
principal
-
>
GetIsContentPrincipal
(
)
)
;
nsresult
rv
;
static
const
nsLiteralCString
cameraPermission
=
"
MediaManagerVideo
"
_ns
;
nsCOMPtr
<
nsIPermissionManager
>
mgr
=
do_GetService
(
NS_PERMISSIONMANAGER_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
uint32_t
video
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
rv
=
mgr
-
>
TestExactPermissionFromPrincipal
(
principal
cameraPermission
&
video
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
bool
allowed
=
(
video
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
;
if
(
allowed
)
{
mgr
-
>
RemoveFromPrincipal
(
principal
cameraPermission
)
;
}
return
allowed
;
}
mozilla
:
:
ipc
:
:
IPCResult
CamerasParent
:
:
RecvAllocateCapture
(
const
CaptureEngine
&
aCapEngine
const
nsCString
&
unique_id
const
uint64_t
&
aWindowID
)
{
LOG
(
"
%
s
:
Verifying
permissions
"
__PRETTY_FUNCTION__
)
;
RefPtr
<
CamerasParent
>
self
(
this
)
;
RefPtr
<
Runnable
>
mainthread_runnable
=
NewRunnableFrom
(
[
self
aCapEngine
unique_id
aWindowID
]
(
)
{
bool
allowed
=
HasCameraPermission
(
aWindowID
)
;
if
(
!
allowed
)
{
if
(
Preferences
:
:
GetBool
(
"
media
.
navigator
.
permission
.
disabled
"
false
)
)
{
allowed
=
true
;
LOG
(
"
No
permission
but
checks
are
disabled
"
)
;
}
else
{
LOG
(
"
No
camera
permission
for
this
origin
"
)
;
}
}
RefPtr
<
Runnable
>
webrtc_runnable
=
NewRunnableFrom
(
[
self
allowed
aCapEngine
unique_id
]
(
)
{
int
captureId
=
-
1
;
int
error
=
-
1
;
if
(
allowed
&
&
self
-
>
EnsureInitialized
(
aCapEngine
)
)
{
StaticRefPtr
<
VideoEngine
>
&
engine
=
self
-
>
sEngines
[
aCapEngine
]
;
captureId
=
engine
-
>
CreateVideoCapture
(
unique_id
.
get
(
)
)
;
engine
-
>
WithEntry
(
captureId
[
&
error
]
(
VideoEngine
:
:
CaptureEntry
&
cap
)
{
if
(
cap
.
VideoCapture
(
)
)
{
error
=
0
;
}
}
)
;
}
RefPtr
<
nsIRunnable
>
ipc_runnable
=
NewRunnableFrom
(
[
self
captureId
error
]
(
)
{
if
(
!
self
-
>
mChildIsAlive
)
{
LOG
(
"
RecvAllocateCapture
:
child
not
alive
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
error
)
{
Unused
<
<
self
-
>
SendReplyFailure
(
)
;
LOG
(
"
RecvAllocateCapture
:
WithEntry
error
"
)
;
return
NS_ERROR_FAILURE
;
}
LOG
(
"
Allocated
device
nr
%
d
"
captureId
)
;
Unused
<
<
self
-
>
SendReplyAllocateCapture
(
captureId
)
;
return
NS_OK
;
}
)
;
self
-
>
mPBackgroundEventTarget
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
self
-
>
DispatchToVideoCaptureThread
(
webrtc_runnable
)
;
return
NS_OK
;
}
)
;
NS_DispatchToMainThread
(
mainthread_runnable
)
;
return
IPC_OK
(
)
;
}
int
CamerasParent
:
:
ReleaseCapture
(
const
CaptureEngine
&
aCapEngine
int
aCaptureId
)
{
int
error
=
-
1
;
if
(
auto
engine
=
EnsureInitialized
(
aCapEngine
)
)
{
error
=
engine
-
>
ReleaseVideoCapture
(
aCaptureId
)
;
}
return
error
;
}
mozilla
:
:
ipc
:
:
IPCResult
CamerasParent
:
:
RecvReleaseCapture
(
const
CaptureEngine
&
aCapEngine
const
int
&
aCaptureId
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
LOG
(
"
RecvReleaseCamera
device
nr
%
d
"
aCaptureId
)
;
RefPtr
<
CamerasParent
>
self
(
this
)
;
RefPtr
<
Runnable
>
webrtc_runnable
=
NewRunnableFrom
(
[
self
aCapEngine
aCaptureId
]
(
)
{
int
error
=
self
-
>
ReleaseCapture
(
aCapEngine
aCaptureId
)
;
RefPtr
<
nsIRunnable
>
ipc_runnable
=
NewRunnableFrom
(
[
self
error
aCaptureId
]
(
)
{
if
(
!
self
-
>
mChildIsAlive
)
{
LOG
(
"
RecvReleaseCapture
:
child
not
alive
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
error
)
{
Unused
<
<
self
-
>
SendReplyFailure
(
)
;
LOG
(
"
RecvReleaseCapture
:
Failed
to
free
device
nr
%
d
"
aCaptureId
)
;
return
NS_ERROR_FAILURE
;
}
Unused
<
<
self
-
>
SendReplySuccess
(
)
;
LOG
(
"
Freed
device
nr
%
d
"
aCaptureId
)
;
return
NS_OK
;
}
)
;
self
-
>
mPBackgroundEventTarget
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
DispatchToVideoCaptureThread
(
webrtc_runnable
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CamerasParent
:
:
RecvStartCapture
(
const
CaptureEngine
&
aCapEngine
const
int
&
aCaptureId
const
VideoCaptureCapability
&
ipcCaps
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
RefPtr
<
CamerasParent
>
self
(
this
)
;
RefPtr
<
Runnable
>
webrtc_runnable
=
NewRunnableFrom
(
[
self
aCapEngine
aCaptureId
ipcCaps
]
(
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
CallbackHelper
*
*
cbh
;
int
error
=
-
1
;
if
(
self
-
>
EnsureInitialized
(
aCapEngine
)
)
{
cbh
=
self
-
>
mCallbacks
.
AppendElement
(
new
CallbackHelper
(
static_cast
<
CaptureEngine
>
(
aCapEngine
)
aCaptureId
self
)
)
;
self
-
>
sEngines
[
aCapEngine
]
-
>
WithEntry
(
aCaptureId
[
&
aCaptureId
&
aCapEngine
&
error
&
ipcCaps
&
cbh
self
]
(
VideoEngine
:
:
CaptureEntry
&
cap
)
{
webrtc
:
:
VideoCaptureCapability
capability
;
capability
.
width
=
ipcCaps
.
width
(
)
;
capability
.
height
=
ipcCaps
.
height
(
)
;
capability
.
maxFPS
=
ipcCaps
.
maxFPS
(
)
;
capability
.
videoType
=
static_cast
<
webrtc
:
:
VideoType
>
(
ipcCaps
.
videoType
(
)
)
;
capability
.
interlaced
=
ipcCaps
.
interlaced
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
sDeviceUniqueIDs
.
find
(
aCaptureId
)
=
=
sDeviceUniqueIDs
.
end
(
)
)
;
sDeviceUniqueIDs
.
emplace
(
aCaptureId
cap
.
VideoCapture
(
)
-
>
CurrentDeviceName
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
sAllRequestedCapabilities
.
find
(
aCaptureId
)
=
=
sAllRequestedCapabilities
.
end
(
)
)
;
sAllRequestedCapabilities
.
emplace
(
aCaptureId
capability
)
;
if
(
aCapEngine
=
=
CameraEngine
)
{
for
(
const
auto
&
it
:
sDeviceUniqueIDs
)
{
if
(
strcmp
(
it
.
second
cap
.
VideoCapture
(
)
-
>
CurrentDeviceName
(
)
)
=
=
0
)
{
capability
.
width
=
std
:
:
max
(
capability
.
width
sAllRequestedCapabilities
[
it
.
first
]
.
width
)
;
capability
.
height
=
std
:
:
max
(
capability
.
height
sAllRequestedCapabilities
[
it
.
first
]
.
height
)
;
capability
.
maxFPS
=
std
:
:
max
(
capability
.
maxFPS
sAllRequestedCapabilities
[
it
.
first
]
.
maxFPS
)
;
}
}
auto
candidateCapabilities
=
self
-
>
mAllCandidateCapabilities
.
find
(
nsCString
(
cap
.
VideoCapture
(
)
-
>
CurrentDeviceName
(
)
)
)
;
if
(
(
candidateCapabilities
!
=
self
-
>
mAllCandidateCapabilities
.
end
(
)
)
&
&
(
!
candidateCapabilities
-
>
second
.
empty
(
)
)
)
{
int32_t
minIdx
=
-
1
;
uint64_t
minDistance
=
UINT64_MAX
;
for
(
auto
&
candidateCapability
:
candidateCapabilities
-
>
second
)
{
if
(
candidateCapability
.
second
.
videoType
!
=
capability
.
videoType
)
{
continue
;
}
uint64_t
distance
=
uint64_t
(
ResolutionFeasibilityDistance
(
candidateCapability
.
second
.
width
capability
.
width
)
)
+
uint64_t
(
ResolutionFeasibilityDistance
(
candidateCapability
.
second
.
height
capability
.
height
)
)
+
uint64_t
(
FeasibilityDistance
(
candidateCapability
.
second
.
maxFPS
capability
.
maxFPS
)
)
;
if
(
distance
<
minDistance
)
{
minIdx
=
candidateCapability
.
first
;
minDistance
=
distance
;
}
}
MOZ_ASSERT
(
minIdx
!
=
-
1
)
;
capability
=
candidateCapabilities
-
>
second
[
minIdx
]
;
}
}
else
if
(
aCapEngine
=
=
ScreenEngine
|
|
aCapEngine
=
=
BrowserEngine
|
|
aCapEngine
=
=
WinEngine
)
{
for
(
const
auto
&
it
:
sDeviceUniqueIDs
)
{
if
(
strcmp
(
it
.
second
cap
.
VideoCapture
(
)
-
>
CurrentDeviceName
(
)
)
=
=
0
)
{
capability
.
maxFPS
=
std
:
:
max
(
capability
.
maxFPS
sAllRequestedCapabilities
[
it
.
first
]
.
maxFPS
)
;
}
}
}
error
=
cap
.
VideoCapture
(
)
-
>
StartCapture
(
capability
)
;
if
(
!
error
)
{
cap
.
VideoCapture
(
)
-
>
RegisterCaptureDataCallback
(
static_cast
<
rtc
:
:
VideoSinkInterface
<
webrtc
:
:
VideoFrame
>
*
>
(
*
cbh
)
)
;
}
else
{
sDeviceUniqueIDs
.
erase
(
aCaptureId
)
;
sAllRequestedCapabilities
.
erase
(
aCaptureId
)
;
}
}
)
;
}
RefPtr
<
nsIRunnable
>
ipc_runnable
=
NewRunnableFrom
(
[
self
error
]
(
)
{
if
(
!
self
-
>
mChildIsAlive
)
{
LOG
(
"
RecvStartCapture
failure
:
child
is
not
alive
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
error
)
{
Unused
<
<
self
-
>
SendReplySuccess
(
)
;
return
NS_OK
;
}
LOG
(
"
RecvStartCapture
failure
:
StartCapture
failed
"
)
;
Unused
<
<
self
-
>
SendReplyFailure
(
)
;
return
NS_ERROR_FAILURE
;
}
)
;
self
-
>
mPBackgroundEventTarget
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
)
;
DispatchToVideoCaptureThread
(
webrtc_runnable
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CamerasParent
:
:
RecvFocusOnSelectedSource
(
const
CaptureEngine
&
aCapEngine
const
int
&
aCaptureId
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
RefPtr
<
Runnable
>
webrtc_runnable
=
NewRunnableFrom
(
[
self
=
RefPtr
<
CamerasParent
>
(
this
)
aCapEngine
aCaptureId
]
(
)
{
if
(
auto
engine
=
self
-
>
EnsureInitialized
(
aCapEngine
)
)
{
engine
-
>
WithEntry
(
aCaptureId
[
self
]
(
VideoEngine
:
:
CaptureEntry
&
cap
)
{
if
(
cap
.
VideoCapture
(
)
)
{
bool
result
=
cap
.
VideoCapture
(
)
-
>
FocusOnSelectedSource
(
)
;
RefPtr
<
nsIRunnable
>
ipc_runnable
=
NewRunnableFrom
(
[
self
result
]
(
)
{
if
(
!
self
-
>
mChildIsAlive
)
{
LOG
(
"
RecvFocusOnSelectedSource
failure
:
child
is
not
alive
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
result
)
{
Unused
<
<
self
-
>
SendReplySuccess
(
)
;
return
NS_OK
;
}
Unused
<
<
self
-
>
SendReplyFailure
(
)
;
LOG
(
"
RecvFocusOnSelectedSource
failure
.
"
)
;
return
NS_ERROR_FAILURE
;
}
)
;
self
-
>
mPBackgroundEventTarget
-
>
Dispatch
(
ipc_runnable
NS_DISPATCH_NORMAL
)
;
}
}
)
;
}
LOG
(
"
RecvFocusOnSelectedSource
CameraParent
not
initialized
"
)
;
return
NS_ERROR_FAILURE
;
}
)
;
DispatchToVideoCaptureThread
(
webrtc_runnable
)
;
return
IPC_OK
(
)
;
}
void
CamerasParent
:
:
StopCapture
(
const
CaptureEngine
&
aCapEngine
int
aCaptureId
)
{
if
(
auto
engine
=
EnsureInitialized
(
aCapEngine
)
)
{
for
(
size_t
i
=
mCallbacks
.
Length
(
)
;
i
>
0
;
i
-
-
)
{
if
(
mCallbacks
[
i
-
1
]
-
>
mCapEngine
=
=
aCapEngine
&
&
mCallbacks
[
i
-
1
]
-
>
mStreamId
=
=
(
uint32_t
)
aCaptureId
)
{
CallbackHelper
*
cbh
=
mCallbacks
[
i
-
1
]
;
engine
-
>
WithEntry
(
aCaptureId
[
cbh
&
aCaptureId
]
(
VideoEngine
:
:
CaptureEntry
&
cap
)
{
if
(
cap
.
VideoCapture
(
)
)
{
cap
.
VideoCapture
(
)
-
>
DeRegisterCaptureDataCallback
(
static_cast
<
rtc
:
:
VideoSinkInterface
<
webrtc
:
:
VideoFrame
>
*
>
(
cbh
)
)
;
cap
.
VideoCapture
(
)
-
>
StopCaptureIfAllClientsClose
(
)
;
sDeviceUniqueIDs
.
erase
(
aCaptureId
)
;
sAllRequestedCapabilities
.
erase
(
aCaptureId
)
;
}
}
)
;
delete
mCallbacks
[
i
-
1
]
;
mCallbacks
.
RemoveElementAt
(
i
-
1
)
;
break
;
}
}
}
}
mozilla
:
:
ipc
:
:
IPCResult
CamerasParent
:
:
RecvStopCapture
(
const
CaptureEngine
&
aCapEngine
const
int
&
aCaptureId
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
RefPtr
<
CamerasParent
>
self
(
this
)
;
RefPtr
<
Runnable
>
webrtc_runnable
=
NewRunnableFrom
(
[
self
aCapEngine
aCaptureId
]
(
)
{
self
-
>
StopCapture
(
aCapEngine
aCaptureId
)
;
return
NS_OK
;
}
)
;
nsresult
rv
=
DispatchToVideoCaptureThread
(
webrtc_runnable
)
;
if
(
!
self
-
>
mChildIsAlive
)
{
if
(
NS_FAILED
(
rv
)
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
}
else
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
!
SendReplySuccess
(
)
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
}
else
{
if
(
!
SendReplyFailure
(
)
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
}
}
return
IPC_OK
(
)
;
}
void
CamerasParent
:
:
StopIPC
(
)
{
MOZ_ASSERT
(
!
mDestroyed
)
;
mShmemPool
.
Cleanup
(
this
)
;
mChildIsAlive
=
false
;
mDestroyed
=
true
;
}
mozilla
:
:
ipc
:
:
IPCResult
CamerasParent
:
:
RecvAllDone
(
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
mChildIsAlive
=
false
;
IProtocol
*
mgr
=
Manager
(
)
;
if
(
!
Send__delete__
(
this
)
)
{
return
IPC_FAIL_NO_REASON
(
mgr
)
;
}
return
IPC_OK
(
)
;
}
void
CamerasParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
LOG
(
"
%
s
"
__PRETTY_FUNCTION__
)
;
StopIPC
(
)
;
StopVideoCapture
(
)
;
}
nsString
CamerasParent
:
:
GetNewName
(
)
{
static
volatile
uint64_t
counter
=
0
;
nsString
name
(
u
"
CamerasParent
"
_ns
)
;
name
.
AppendInt
(
+
+
counter
)
;
return
name
;
}
NS_IMETHODIMP
CamerasParent
:
:
BlockShutdown
(
nsIAsyncShutdownClient
*
)
{
StopVideoCapture
(
)
;
return
NS_OK
;
}
CamerasParent
:
:
CamerasParent
(
)
:
mName
(
GetNewName
(
)
)
mShmemPool
(
CaptureEngine
:
:
MaxEngine
)
mPBackgroundEventTarget
(
GetCurrentSerialEventTarget
(
)
)
mChildIsAlive
(
true
)
mDestroyed
(
false
)
mWebRTCAlive
(
false
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
!
=
nullptr
"
GetCurrentThreadEventTarget
failed
"
)
;
LOG
(
"
CamerasParent
:
%
p
"
this
)
;
StaticMutexAutoLock
slock
(
sMutex
)
;
if
(
sNumOfCamerasParents
+
+
=
=
0
)
{
sThreadMonitor
=
new
Monitor
(
"
CamerasParent
:
:
sThreadMonitor
"
)
;
}
}
ipc
:
:
IPCResult
CamerasParent
:
:
RecvPCamerasConstructor
(
)
{
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
self
=
RefPtr
(
this
)
]
(
)
{
nsresult
rv
=
MustGetShutdownBarrier
(
)
-
>
AddBlocker
(
self
NS_LITERAL_STRING_FROM_CSTRING
(
__FILE__
)
__LINE__
u
"
"
_ns
)
;
LOG
(
"
AddBlocker
returned
0x
%
"
PRIx32
rv
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
|
|
!
self
-
>
mWebRTCAlive
)
;
}
)
)
;
if
(
AppShutdown
:
:
IsInOrBeyond
(
ShutdownPhase
:
:
AppShutdown
)
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
self
=
RefPtr
(
this
)
]
(
)
{
(
void
)
MustGetShutdownBarrier
(
)
-
>
RemoveBlocker
(
self
)
;
}
)
)
;
return
Send__delete__
(
this
)
?
IPC_OK
(
)
:
IPC_FAIL
(
this
"
Failed
to
send
"
)
;
}
LOG
(
"
Spinning
up
WebRTC
Cameras
Thread
"
)
;
MonitorAutoLock
lock
(
*
sThreadMonitor
)
;
if
(
sVideoCaptureThread
=
=
nullptr
)
{
MOZ_ASSERT
(
sNumOfOpenCamerasParentEngines
=
=
0
)
;
sVideoCaptureThread
=
new
base
:
:
Thread
(
"
VideoCapture
"
)
;
base
:
:
Thread
:
:
Options
options
;
#
if
defined
(
_WIN32
)
options
.
message_loop_type
=
MessageLoop
:
:
TYPE_MOZILLA_NONMAINUITHREAD
;
#
else
options
.
message_loop_type
=
MessageLoop
:
:
TYPE_MOZILLA_NONMAINTHREAD
;
#
endif
if
(
!
sVideoCaptureThread
-
>
StartWithOptions
(
options
)
)
{
MOZ_CRASH
(
)
;
}
}
mWebRTCAlive
=
true
;
sNumOfOpenCamerasParentEngines
+
+
;
return
IPC_OK
(
)
;
}
CamerasParent
:
:
~
CamerasParent
(
)
{
LOG
(
"
~
CamerasParent
:
%
p
"
this
)
;
StaticMutexAutoLock
slock
(
sMutex
)
;
if
(
-
-
sNumOfCamerasParents
=
=
0
)
{
delete
sThreadMonitor
;
sThreadMonitor
=
nullptr
;
}
}
already_AddRefed
<
CamerasParent
>
CamerasParent
:
:
Create
(
)
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
return
MakeAndAddRef
<
CamerasParent
>
(
)
;
}
}
}
