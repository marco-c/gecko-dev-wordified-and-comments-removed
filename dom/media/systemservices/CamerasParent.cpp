#
include
"
CamerasParent
.
h
"
#
include
<
atomic
>
#
include
"
CamerasTypes
.
h
"
#
include
"
MediaEngineSource
.
h
"
#
include
"
PerformanceRecorder
.
h
"
#
include
"
VideoEngine
.
h
"
#
include
"
VideoFrameUtils
.
h
"
#
include
"
common
/
browser_logging
/
WebRtcLog
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundParent
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
media
/
MediaUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
mozilla
/
StaticPrefs_permissions
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
video_engine
/
desktop_capture_impl
.
h
"
#
include
"
video_engine
/
video_capture_factory
.
h
"
#
include
"
api
/
video
/
video_frame_buffer
.
h
"
#
include
"
common_video
/
libyuv
/
include
/
webrtc_libyuv
.
h
"
#
if
defined
(
_WIN32
)
#
include
<
process
.
h
>
#
define
getpid
(
)
_getpid
(
)
#
endif
#
undef
LOG
#
undef
LOG_VERBOSE
#
undef
LOG_ENABLED
mozilla
:
:
LazyLogModule
gCamerasParentLog
(
"
CamerasParent
"
)
;
#
define
LOG
(
.
.
.
)
\
MOZ_LOG
(
gCamerasParentLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
define
LOG_FUNCTION
(
)
\
MOZ_LOG
(
gCamerasParentLog
mozilla
:
:
LogLevel
:
:
Debug
\
(
"
CamerasParent
(
%
p
)
:
:
%
s
"
this
__func__
)
)
#
define
LOG_VERBOSE
(
.
.
.
)
\
MOZ_LOG
(
gCamerasParentLog
mozilla
:
:
LogLevel
:
:
Verbose
(
__VA_ARGS__
)
)
#
define
LOG_ENABLED
(
)
MOZ_LOG_TEST
(
gCamerasParentLog
mozilla
:
:
LogLevel
:
:
Debug
)
namespace
mozilla
{
using
media
:
:
ShutdownBlockingTicket
;
namespace
camera
{
std
:
:
map
<
uint32_t
const
char
*
>
sDeviceUniqueIDs
;
std
:
:
map
<
uint32_t
webrtc
:
:
VideoCaptureCapability
>
sAllRequestedCapabilities
;
uint32_t
ResolutionFeasibilityDistance
(
int32_t
candidate
int32_t
requested
)
{
MOZ_DIAGNOSTIC_ASSERT
(
candidate
>
=
0
"
Candidate
unexpectedly
negative
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
requested
>
=
0
"
Requested
unexpectedly
negative
"
)
;
if
(
candidate
=
=
0
)
{
return
0
;
}
uint32_t
distance
=
std
:
:
abs
(
candidate
-
requested
)
*
1000
/
std
:
:
max
(
candidate
requested
)
;
if
(
candidate
>
=
requested
)
{
return
distance
;
}
return
10000
+
distance
;
}
uint32_t
FeasibilityDistance
(
int32_t
candidate
int32_t
requested
)
{
MOZ_DIAGNOSTIC_ASSERT
(
candidate
>
=
0
"
Candidate
unexpectedly
negative
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
requested
>
=
0
"
Requested
unexpectedly
negative
"
)
;
if
(
candidate
=
=
0
)
{
return
0
;
}
return
std
:
:
abs
(
candidate
-
requested
)
*
1000
/
std
:
:
max
(
candidate
requested
)
;
}
class
CamerasParent
:
:
VideoEngineArray
:
public
media
:
:
Refcountable
<
nsTArray
<
RefPtr
<
VideoEngine
>
>
>
{
}
;
using
VideoEngineArray
=
CamerasParent
:
:
VideoEngineArray
;
static
StaticRefPtr
<
VideoEngineArray
>
sEngines
;
static
int32_t
sNumCamerasParents
=
0
;
static
StaticRefPtr
<
nsIThread
>
sVideoCaptureThread
;
static
StaticRefPtr
<
VideoCaptureFactory
>
sVideoCaptureFactory
;
static
VideoCaptureFactory
*
EnsureVideoCaptureFactory
(
)
{
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
if
(
sVideoCaptureFactory
)
{
return
sVideoCaptureFactory
;
}
sVideoCaptureFactory
=
MakeRefPtr
<
VideoCaptureFactory
>
(
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
CamerasParent
:
:
EnsureVideoCaptureFactory
"
[
]
(
)
{
ClearOnShutdown
(
&
sVideoCaptureFactory
)
;
}
)
)
;
return
sVideoCaptureFactory
;
}
static
already_AddRefed
<
nsISerialEventTarget
>
MakeAndAddRefVideoCaptureThreadAndSingletons
(
)
{
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT_IF
(
sVideoCaptureThread
sNumCamerasParents
>
0
)
;
MOZ_ASSERT_IF
(
!
sVideoCaptureThread
sNumCamerasParents
=
=
0
)
;
if
(
!
sVideoCaptureThread
)
{
LOG
(
"
Spinning
up
WebRTC
Cameras
Thread
"
)
;
nsIThreadManager
:
:
ThreadCreationOptions
options
;
#
ifdef
XP_WIN
options
.
isUiThread
=
true
;
#
endif
nsCOMPtr
<
nsIThread
>
videoCaptureThread
;
if
(
NS_FAILED
(
NS_NewNamedThread
(
"
VideoCapture
"
getter_AddRefs
(
videoCaptureThread
)
nullptr
options
)
)
)
{
return
nullptr
;
}
sVideoCaptureThread
=
videoCaptureThread
.
forget
(
)
;
sEngines
=
MakeRefPtr
<
VideoEngineArray
>
(
)
;
sEngines
-
>
AppendElements
(
CaptureEngine
:
:
MaxEngine
)
;
}
+
+
sNumCamerasParents
;
return
do_AddRef
(
sVideoCaptureThread
)
;
}
static
void
ReleaseVideoCaptureThreadAndSingletons
(
)
{
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
if
(
-
-
sNumCamerasParents
>
0
)
{
return
;
}
MOZ_ASSERT
(
sNumCamerasParents
=
=
0
"
Double
release
!
"
)
;
LOG
(
"
Shutting
down
VideoEngines
and
the
VideoCapture
thread
"
)
;
MOZ_ALWAYS_SUCCEEDS
(
sVideoCaptureThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
engines
=
RefPtr
(
sEngines
.
forget
(
)
)
]
{
for
(
RefPtr
<
VideoEngine
>
&
engine
:
*
engines
)
{
if
(
engine
)
{
VideoEngine
:
:
Delete
(
engine
)
;
engine
=
nullptr
;
}
}
}
)
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
RefPtr
(
sVideoCaptureThread
.
forget
(
)
)
-
>
AsyncShutdown
(
)
)
;
}
void
CamerasParent
:
:
OnDeviceChange
(
)
{
LOG_FUNCTION
(
)
;
mPBackgroundEventTarget
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
(
this
)
]
(
)
{
if
(
IsShuttingDown
(
)
)
{
LOG
(
"
OnDeviceChanged
failure
:
parent
shutting
down
.
"
)
;
return
;
}
Unused
<
<
SendDeviceChange
(
)
;
}
)
)
;
}
;
class
DeliverFrameRunnable
:
public
mozilla
:
:
Runnable
{
public
:
DeliverFrameRunnable
(
CamerasParent
*
aParent
CaptureEngine
aEngine
uint32_t
aStreamId
const
TrackingId
&
aTrackingId
const
webrtc
:
:
VideoFrame
&
aFrame
const
VideoFrameProperties
&
aProperties
)
:
Runnable
(
"
camera
:
:
DeliverFrameRunnable
"
)
mParent
(
aParent
)
mCapEngine
(
aEngine
)
mStreamId
(
aStreamId
)
mTrackingId
(
aTrackingId
)
mProperties
(
aProperties
)
mResult
(
0
)
{
PerformanceRecorder
<
CopyVideoStage
>
rec
(
"
CamerasParent
:
:
VideoFrameToAltBuffer
"
_ns
aTrackingId
aFrame
.
width
(
)
aFrame
.
height
(
)
)
;
mAlternateBuffer
.
reset
(
new
unsigned
char
[
aProperties
.
bufferSize
(
)
]
)
;
VideoFrameUtils
:
:
CopyVideoFrameBuffers
(
mAlternateBuffer
.
get
(
)
aProperties
.
bufferSize
(
)
aFrame
)
;
rec
.
Record
(
)
;
}
DeliverFrameRunnable
(
CamerasParent
*
aParent
CaptureEngine
aEngine
uint32_t
aStreamId
const
TrackingId
&
aTrackingId
ShmemBuffer
aBuffer
VideoFrameProperties
&
aProperties
)
:
Runnable
(
"
camera
:
:
DeliverFrameRunnable
"
)
mParent
(
aParent
)
mCapEngine
(
aEngine
)
mStreamId
(
aStreamId
)
mTrackingId
(
aTrackingId
)
mBuffer
(
std
:
:
move
(
aBuffer
)
)
mProperties
(
aProperties
)
mResult
(
0
)
{
}
;
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
GetCurrentSerialEventTarget
(
)
=
=
mParent
-
>
mPBackgroundEventTarget
)
;
if
(
mParent
-
>
IsShuttingDown
(
)
)
{
mResult
=
0
;
return
NS_OK
;
}
if
(
!
mParent
-
>
DeliverFrameOverIPC
(
mCapEngine
mStreamId
mTrackingId
std
:
:
move
(
mBuffer
)
mAlternateBuffer
.
get
(
)
mProperties
)
)
{
mResult
=
-
1
;
}
else
{
mResult
=
0
;
}
return
NS_OK
;
}
int
GetResult
(
)
{
return
mResult
;
}
private
:
const
RefPtr
<
CamerasParent
>
mParent
;
const
CaptureEngine
mCapEngine
;
const
uint32_t
mStreamId
;
const
TrackingId
mTrackingId
;
ShmemBuffer
mBuffer
;
UniquePtr
<
unsigned
char
[
]
>
mAlternateBuffer
;
const
VideoFrameProperties
mProperties
;
int
mResult
;
}
;
int
CamerasParent
:
:
DeliverFrameOverIPC
(
CaptureEngine
aCapEngine
uint32_t
aStreamId
const
TrackingId
&
aTrackingId
ShmemBuffer
aBuffer
unsigned
char
*
aAltBuffer
const
VideoFrameProperties
&
aProps
)
{
if
(
aAltBuffer
!
=
nullptr
)
{
ShmemBuffer
shMemBuff
=
mShmemPool
.
Get
(
this
aProps
.
bufferSize
(
)
)
;
if
(
!
shMemBuff
.
Valid
(
)
)
{
LOG
(
"
No
usable
Video
shmem
in
DeliverFrame
(
out
of
buffers
?
)
"
)
;
return
0
;
}
PerformanceRecorder
<
CopyVideoStage
>
rec
(
"
CamerasParent
:
:
AltBufferToShmem
"
_ns
aTrackingId
aProps
.
width
(
)
aProps
.
height
(
)
)
;
memcpy
(
shMemBuff
.
GetBytes
(
)
aAltBuffer
aProps
.
bufferSize
(
)
)
;
rec
.
Record
(
)
;
if
(
!
SendDeliverFrame
(
aCapEngine
aStreamId
std
:
:
move
(
shMemBuff
.
Get
(
)
)
aProps
)
)
{
return
-
1
;
}
}
else
{
MOZ_ASSERT
(
aBuffer
.
Valid
(
)
)
;
if
(
!
SendDeliverFrame
(
aCapEngine
aStreamId
std
:
:
move
(
aBuffer
.
Get
(
)
)
aProps
)
)
{
return
-
1
;
}
}
return
0
;
}
ShmemBuffer
CamerasParent
:
:
GetBuffer
(
size_t
aSize
)
{
return
mShmemPool
.
GetIfAvailable
(
aSize
)
;
}
void
CallbackHelper
:
:
OnCaptureEnded
(
)
{
nsIEventTarget
*
target
=
mParent
-
>
GetBackgroundEventTarget
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
target
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
&
]
{
Unused
<
<
mParent
-
>
SendCaptureEnded
(
mCapEngine
mStreamId
)
;
}
)
)
)
;
}
void
CallbackHelper
:
:
OnFrame
(
const
webrtc
:
:
VideoFrame
&
aVideoFrame
)
{
LOG_VERBOSE
(
"
CamerasParent
(
%
p
)
:
:
%
s
"
mParent
__func__
)
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
PROFILER_MARKER_UNTYPED
(
nsPrintfCString
(
"
CaptureVideoFrame
%
dx
%
d
%
s
%
s
"
aVideoFrame
.
width
(
)
aVideoFrame
.
height
(
)
webrtc
:
:
VideoFrameBufferTypeToString
(
aVideoFrame
.
video_frame_buffer
(
)
-
>
type
(
)
)
mTrackingId
.
ToString
(
)
.
get
(
)
)
MEDIA_RT
)
;
}
RefPtr
<
DeliverFrameRunnable
>
runnable
=
nullptr
;
camera
:
:
VideoFrameProperties
properties
;
VideoFrameUtils
:
:
InitFrameBufferProperties
(
aVideoFrame
properties
)
;
ShmemBuffer
shMemBuffer
=
mParent
-
>
GetBuffer
(
properties
.
bufferSize
(
)
)
;
if
(
!
shMemBuffer
.
Valid
(
)
)
{
LOG
(
"
Correctly
sized
Video
shmem
not
available
in
DeliverFrame
"
)
;
}
else
{
PerformanceRecorder
<
CopyVideoStage
>
rec
(
"
CamerasParent
:
:
VideoFrameToShmem
"
_ns
mTrackingId
aVideoFrame
.
width
(
)
aVideoFrame
.
height
(
)
)
;
VideoFrameUtils
:
:
CopyVideoFrameBuffers
(
shMemBuffer
.
GetBytes
(
)
properties
.
bufferSize
(
)
aVideoFrame
)
;
rec
.
Record
(
)
;
runnable
=
new
DeliverFrameRunnable
(
mParent
mCapEngine
mStreamId
mTrackingId
std
:
:
move
(
shMemBuffer
)
properties
)
;
}
if
(
!
runnable
)
{
runnable
=
new
DeliverFrameRunnable
(
mParent
mCapEngine
mStreamId
mTrackingId
aVideoFrame
properties
)
;
}
MOZ_ASSERT
(
mParent
)
;
nsIEventTarget
*
target
=
mParent
-
>
GetBackgroundEventTarget
(
)
;
MOZ_ASSERT
(
target
!
=
nullptr
)
;
target
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
ipc
:
:
IPCResult
CamerasParent
:
:
RecvReleaseFrame
(
ipc
:
:
Shmem
&
&
aShmem
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
-
>
IsOnCurrentThread
(
)
)
;
mShmemPool
.
Put
(
ShmemBuffer
(
aShmem
)
)
;
return
IPC_OK
(
)
;
}
void
CamerasParent
:
:
CloseEngines
(
)
{
MOZ_ASSERT
(
mVideoCaptureThread
-
>
IsOnCurrentThread
(
)
)
;
LOG_FUNCTION
(
)
;
while
(
!
mCallbacks
.
IsEmpty
(
)
)
{
auto
capEngine
=
mCallbacks
[
0
]
-
>
mCapEngine
;
auto
streamNum
=
mCallbacks
[
0
]
-
>
mStreamId
;
LOG
(
"
Forcing
shutdown
of
engine
%
d
capturer
%
d
"
capEngine
streamNum
)
;
StopCapture
(
capEngine
streamNum
)
;
Unused
<
<
ReleaseCapture
(
capEngine
streamNum
)
;
}
auto
device_info
=
GetDeviceInfo
(
CameraEngine
)
;
MOZ_ASSERT
(
device_info
)
;
if
(
device_info
)
{
device_info
-
>
DeRegisterVideoInputFeedBack
(
this
)
;
}
}
std
:
:
shared_ptr
<
webrtc
:
:
VideoCaptureModule
:
:
DeviceInfo
>
CamerasParent
:
:
GetDeviceInfo
(
int
aEngine
)
{
MOZ_ASSERT
(
mVideoCaptureThread
-
>
IsOnCurrentThread
(
)
)
;
LOG_VERBOSE
(
"
CamerasParent
(
%
p
)
:
:
%
s
"
this
__func__
)
;
auto
*
engine
=
EnsureInitialized
(
aEngine
)
;
if
(
!
engine
)
{
return
nullptr
;
}
return
engine
-
>
GetOrCreateVideoCaptureDeviceInfo
(
this
)
;
}
VideoEngine
*
CamerasParent
:
:
EnsureInitialized
(
int
aEngine
)
{
MOZ_ASSERT
(
mVideoCaptureThread
-
>
IsOnCurrentThread
(
)
)
;
LOG_VERBOSE
(
"
CamerasParent
(
%
p
)
:
:
%
s
"
this
__func__
)
;
CaptureEngine
capEngine
=
static_cast
<
CaptureEngine
>
(
aEngine
)
;
if
(
VideoEngine
*
engine
=
mEngines
-
>
ElementAt
(
capEngine
)
;
engine
)
{
return
engine
;
}
CaptureDeviceType
captureDeviceType
=
CaptureDeviceType
:
:
Camera
;
switch
(
capEngine
)
{
case
ScreenEngine
:
captureDeviceType
=
CaptureDeviceType
:
:
Screen
;
break
;
case
BrowserEngine
:
captureDeviceType
=
CaptureDeviceType
:
:
Browser
;
break
;
case
WinEngine
:
captureDeviceType
=
CaptureDeviceType
:
:
Window
;
break
;
case
CameraEngine
:
captureDeviceType
=
CaptureDeviceType
:
:
Camera
;
break
;
default
:
LOG
(
"
Invalid
webrtc
Video
engine
"
)
;
return
nullptr
;
}
RefPtr
<
VideoEngine
>
engine
=
VideoEngine
:
:
Create
(
captureDeviceType
mVideoCaptureFactory
)
;
if
(
!
engine
)
{
LOG
(
"
VideoEngine
:
:
Create
failed
"
)
;
return
nullptr
;
}
return
mEngines
-
>
ElementAt
(
capEngine
)
=
std
:
:
move
(
engine
)
;
}
ipc
:
:
IPCResult
CamerasParent
:
:
RecvNumberOfCaptureDevices
(
const
CaptureEngine
&
aCapEngine
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
!
mDestroyed
)
;
LOG_FUNCTION
(
)
;
LOG
(
"
CaptureEngine
=
%
d
"
aCapEngine
)
;
using
Promise
=
MozPromise
<
int
bool
true
>
;
InvokeAsync
(
mVideoCaptureThread
__func__
[
this
self
=
RefPtr
(
this
)
aCapEngine
]
{
int
num
=
-
1
;
if
(
auto
devInfo
=
GetDeviceInfo
(
aCapEngine
)
)
{
num
=
static_cast
<
int
>
(
devInfo
-
>
NumberOfDevices
(
)
)
;
}
return
Promise
:
:
CreateAndResolve
(
num
"
CamerasParent
:
:
RecvNumberOfCaptureDevices
"
)
;
}
)
-
>
Then
(
mPBackgroundEventTarget
__func__
[
this
self
=
RefPtr
(
this
)
]
(
Promise
:
:
ResolveOrRejectValue
&
&
aValue
)
{
int
nrDevices
=
aValue
.
ResolveValue
(
)
;
if
(
mDestroyed
)
{
LOG
(
"
RecvNumberOfCaptureDevices
failure
:
child
not
alive
"
)
;
return
;
}
if
(
nrDevices
<
0
)
{
LOG
(
"
RecvNumberOfCaptureDevices
couldn
'
t
find
devices
"
)
;
Unused
<
<
SendReplyFailure
(
)
;
return
;
}
LOG
(
"
RecvNumberOfCaptureDevices
:
%
d
"
nrDevices
)
;
Unused
<
<
SendReplyNumberOfCaptureDevices
(
nrDevices
)
;
}
)
;
return
IPC_OK
(
)
;
}
ipc
:
:
IPCResult
CamerasParent
:
:
RecvEnsureInitialized
(
const
CaptureEngine
&
aCapEngine
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
!
mDestroyed
)
;
LOG_FUNCTION
(
)
;
using
Promise
=
MozPromise
<
bool
bool
true
>
;
InvokeAsync
(
mVideoCaptureThread
__func__
[
this
self
=
RefPtr
(
this
)
aCapEngine
]
{
return
Promise
:
:
CreateAndResolve
(
EnsureInitialized
(
aCapEngine
)
"
CamerasParent
:
:
RecvEnsureInitialized
"
)
;
}
)
-
>
Then
(
mPBackgroundEventTarget
__func__
[
this
self
=
RefPtr
(
this
)
]
(
Promise
:
:
ResolveOrRejectValue
&
&
aValue
)
{
bool
result
=
aValue
.
ResolveValue
(
)
;
if
(
mDestroyed
)
{
LOG
(
"
RecvEnsureInitialized
:
child
not
alive
"
)
;
return
;
}
if
(
!
result
)
{
LOG
(
"
RecvEnsureInitialized
failed
"
)
;
Unused
<
<
SendReplyFailure
(
)
;
return
;
}
LOG
(
"
RecvEnsureInitialized
succeeded
"
)
;
Unused
<
<
SendReplySuccess
(
)
;
}
)
;
return
IPC_OK
(
)
;
}
ipc
:
:
IPCResult
CamerasParent
:
:
RecvNumberOfCapabilities
(
const
CaptureEngine
&
aCapEngine
const
nsACString
&
aUniqueId
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
!
mDestroyed
)
;
LOG_FUNCTION
(
)
;
LOG
(
"
Getting
caps
for
%
s
"
PromiseFlatCString
(
aUniqueId
)
.
get
(
)
)
;
using
Promise
=
MozPromise
<
int
bool
true
>
;
InvokeAsync
(
mVideoCaptureThread
__func__
[
this
self
=
RefPtr
(
this
)
id
=
nsCString
(
aUniqueId
)
aCapEngine
]
(
)
{
int
num
=
-
1
;
if
(
auto
devInfo
=
GetDeviceInfo
(
aCapEngine
)
)
{
num
=
devInfo
-
>
NumberOfCapabilities
(
id
.
get
(
)
)
;
}
return
Promise
:
:
CreateAndResolve
(
num
"
CamerasParent
:
:
RecvNumberOfCapabilities
"
)
;
}
)
-
>
Then
(
mPBackgroundEventTarget
__func__
[
this
self
=
RefPtr
(
this
)
]
(
Promise
:
:
ResolveOrRejectValue
&
&
aValue
)
{
int
aNrCapabilities
=
aValue
.
ResolveValue
(
)
;
if
(
mDestroyed
)
{
LOG
(
"
RecvNumberOfCapabilities
:
child
not
alive
"
)
;
return
;
}
if
(
aNrCapabilities
<
0
)
{
LOG
(
"
RecvNumberOfCapabilities
couldn
'
t
find
capabilities
"
)
;
Unused
<
<
SendReplyFailure
(
)
;
return
;
}
LOG
(
"
RecvNumberOfCapabilities
:
%
d
"
aNrCapabilities
)
;
Unused
<
<
SendReplyNumberOfCapabilities
(
aNrCapabilities
)
;
}
)
;
return
IPC_OK
(
)
;
}
ipc
:
:
IPCResult
CamerasParent
:
:
RecvGetCaptureCapability
(
const
CaptureEngine
&
aCapEngine
const
nsACString
&
aUniqueId
const
int
&
aIndex
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
!
mDestroyed
)
;
LOG_FUNCTION
(
)
;
LOG
(
"
RecvGetCaptureCapability
:
%
s
%
d
"
PromiseFlatCString
(
aUniqueId
)
.
get
(
)
aIndex
)
;
using
Promise
=
MozPromise
<
webrtc
:
:
VideoCaptureCapability
int
true
>
;
InvokeAsync
(
mVideoCaptureThread
__func__
[
this
self
=
RefPtr
(
this
)
id
=
nsCString
(
aUniqueId
)
aCapEngine
aIndex
]
{
webrtc
:
:
VideoCaptureCapability
webrtcCaps
;
int
error
=
-
1
;
if
(
auto
devInfo
=
GetDeviceInfo
(
aCapEngine
)
)
{
error
=
devInfo
-
>
GetCapability
(
id
.
get
(
)
aIndex
webrtcCaps
)
;
}
if
(
!
error
&
&
aCapEngine
=
=
CameraEngine
)
{
auto
iter
=
mAllCandidateCapabilities
.
find
(
id
)
;
if
(
iter
=
=
mAllCandidateCapabilities
.
end
(
)
)
{
std
:
:
map
<
uint32_t
webrtc
:
:
VideoCaptureCapability
>
candidateCapabilities
;
candidateCapabilities
.
emplace
(
aIndex
webrtcCaps
)
;
mAllCandidateCapabilities
.
emplace
(
id
candidateCapabilities
)
;
}
else
{
(
iter
-
>
second
)
.
emplace
(
aIndex
webrtcCaps
)
;
}
}
if
(
error
)
{
return
Promise
:
:
CreateAndReject
(
error
"
CamerasParent
:
:
RecvGetCaptureCapability
"
)
;
}
return
Promise
:
:
CreateAndResolve
(
webrtcCaps
"
CamerasParent
:
:
RecvGetCaptureCapability
"
)
;
}
)
-
>
Then
(
mPBackgroundEventTarget
__func__
[
this
self
=
RefPtr
(
this
)
]
(
Promise
:
:
ResolveOrRejectValue
&
&
aValue
)
{
if
(
mDestroyed
)
{
LOG
(
"
RecvGetCaptureCapability
:
child
not
alive
"
)
;
return
;
}
if
(
aValue
.
IsReject
(
)
)
{
LOG
(
"
RecvGetCaptureCapability
:
reply
failure
"
)
;
Unused
<
<
SendReplyFailure
(
)
;
return
;
}
auto
webrtcCaps
=
aValue
.
ResolveValue
(
)
;
VideoCaptureCapability
capCap
(
webrtcCaps
.
width
webrtcCaps
.
height
webrtcCaps
.
maxFPS
static_cast
<
int
>
(
webrtcCaps
.
videoType
)
webrtcCaps
.
interlaced
)
;
LOG
(
"
Capability
:
%
u
%
u
%
u
%
d
%
d
"
webrtcCaps
.
width
webrtcCaps
.
height
webrtcCaps
.
maxFPS
static_cast
<
int
>
(
webrtcCaps
.
videoType
)
webrtcCaps
.
interlaced
)
;
Unused
<
<
SendReplyGetCaptureCapability
(
capCap
)
;
}
)
;
return
IPC_OK
(
)
;
}
ipc
:
:
IPCResult
CamerasParent
:
:
RecvGetCaptureDevice
(
const
CaptureEngine
&
aCapEngine
const
int
&
aDeviceIndex
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
!
mDestroyed
)
;
LOG_FUNCTION
(
)
;
using
Data
=
std
:
:
tuple
<
nsCString
nsCString
pid_t
bool
int
>
;
using
Promise
=
MozPromise
<
Data
bool
true
>
;
InvokeAsync
(
mVideoCaptureThread
__func__
[
this
self
=
RefPtr
(
this
)
aCapEngine
aDeviceIndex
]
{
char
deviceName
[
MediaEngineSource
:
:
kMaxDeviceNameLength
]
;
char
deviceUniqueId
[
MediaEngineSource
:
:
kMaxUniqueIdLength
]
;
nsCString
name
;
nsCString
uniqueId
;
pid_t
devicePid
=
0
;
bool
placeholder
=
false
;
int
error
=
-
1
;
if
(
auto
devInfo
=
GetDeviceInfo
(
aCapEngine
)
)
{
error
=
devInfo
-
>
GetDeviceName
(
aDeviceIndex
deviceName
sizeof
(
deviceName
)
deviceUniqueId
sizeof
(
deviceUniqueId
)
nullptr
0
&
devicePid
&
placeholder
)
;
}
if
(
error
=
=
0
)
{
name
.
Assign
(
deviceName
)
;
uniqueId
.
Assign
(
deviceUniqueId
)
;
}
return
Promise
:
:
CreateAndResolve
(
std
:
:
make_tuple
(
std
:
:
move
(
name
)
std
:
:
move
(
uniqueId
)
devicePid
placeholder
error
)
"
CamerasParent
:
:
RecvGetCaptureDevice
"
)
;
}
)
-
>
Then
(
mPBackgroundEventTarget
__func__
[
this
self
=
RefPtr
(
this
)
]
(
Promise
:
:
ResolveOrRejectValue
&
&
aValue
)
{
const
auto
&
[
name
uniqueId
devicePid
placeholder
error
]
=
aValue
.
ResolveValue
(
)
;
if
(
mDestroyed
)
{
return
;
}
if
(
error
!
=
0
)
{
LOG
(
"
GetCaptureDevice
failed
:
%
d
"
error
)
;
Unused
<
<
SendReplyFailure
(
)
;
return
;
}
bool
scary
=
(
devicePid
=
=
getpid
(
)
)
;
LOG
(
"
Returning
%
s
name
%
s
id
(
pid
=
%
d
)
%
s
"
name
.
get
(
)
uniqueId
.
get
(
)
devicePid
(
scary
?
"
(
scary
)
"
:
"
"
)
)
;
Unused
<
<
SendReplyGetCaptureDevice
(
name
uniqueId
scary
placeholder
)
;
}
)
;
return
IPC_OK
(
)
;
}
static
bool
HasCameraPermission
(
const
uint64_t
&
aWindowId
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
dom
:
:
WindowGlobalParent
>
window
=
dom
:
:
WindowGlobalParent
:
:
GetByInnerWindowId
(
aWindowId
)
;
if
(
!
window
)
{
return
false
;
}
RefPtr
<
dom
:
:
BrowsingContext
>
topBC
=
window
-
>
BrowsingContext
(
)
-
>
Top
(
)
;
window
=
topBC
-
>
Canonical
(
)
-
>
GetCurrentWindowGlobal
(
)
;
if
(
!
window
|
|
!
window
-
>
IsCurrentGlobal
(
)
)
{
return
false
;
}
nsIPrincipal
*
principal
=
window
-
>
DocumentPrincipal
(
)
;
if
(
principal
-
>
GetIsNullPrincipal
(
)
)
{
return
false
;
}
if
(
principal
-
>
IsSystemPrincipal
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
principal
-
>
GetIsContentPrincipal
(
)
)
;
nsresult
rv
;
static
const
nsLiteralCString
cameraPermission
=
"
MediaManagerVideo
"
_ns
;
nsCOMPtr
<
nsIPermissionManager
>
mgr
=
do_GetService
(
NS_PERMISSIONMANAGER_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
uint32_t
video
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
rv
=
mgr
-
>
TestExactPermissionFromPrincipal
(
principal
cameraPermission
&
video
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
bool
allowed
=
(
video
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
;
if
(
allowed
)
{
mgr
-
>
RemoveFromPrincipal
(
principal
cameraPermission
)
;
}
return
allowed
;
}
ipc
:
:
IPCResult
CamerasParent
:
:
RecvAllocateCapture
(
const
CaptureEngine
&
aCapEngine
const
nsACString
&
aUniqueIdUTF8
const
uint64_t
&
aWindowID
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
!
mDestroyed
)
;
LOG
(
"
CamerasParent
(
%
p
)
:
:
%
s
:
Verifying
permissions
"
this
__func__
)
;
using
Promise1
=
MozPromise
<
bool
bool
true
>
;
using
Data
=
std
:
:
tuple
<
int
int
>
;
using
Promise2
=
MozPromise
<
Data
bool
true
>
;
InvokeAsync
(
GetMainThreadSerialEventTarget
(
)
__func__
[
aWindowID
]
{
bool
allowed
=
HasCameraPermission
(
aWindowID
)
;
if
(
!
allowed
)
{
if
(
Preferences
:
:
GetBool
(
"
media
.
navigator
.
permission
.
disabled
"
false
)
)
{
allowed
=
true
;
LOG
(
"
No
permission
but
checks
are
disabled
"
)
;
}
else
{
LOG
(
"
No
camera
permission
for
this
origin
"
)
;
}
}
return
Promise1
:
:
CreateAndResolve
(
allowed
"
CamerasParent
:
:
RecvAllocateCapture
"
)
;
}
)
-
>
Then
(
mVideoCaptureThread
__func__
[
this
self
=
RefPtr
(
this
)
aCapEngine
unique_id
=
nsCString
(
aUniqueIdUTF8
)
]
(
Promise1
:
:
ResolveOrRejectValue
&
&
aValue
)
{
bool
allowed
=
aValue
.
ResolveValue
(
)
;
int
captureId
=
-
1
;
int
error
=
-
1
;
if
(
allowed
&
&
EnsureInitialized
(
aCapEngine
)
)
{
VideoEngine
*
engine
=
mEngines
-
>
ElementAt
(
aCapEngine
)
;
captureId
=
engine
-
>
CreateVideoCapture
(
unique_id
.
get
(
)
)
;
engine
-
>
WithEntry
(
captureId
[
&
error
]
(
VideoEngine
:
:
CaptureEntry
&
cap
)
{
if
(
cap
.
VideoCapture
(
)
)
{
error
=
0
;
}
}
)
;
}
return
Promise2
:
:
CreateAndResolve
(
std
:
:
make_tuple
(
captureId
error
)
"
CamerasParent
:
:
RecvAllocateCapture
"
)
;
}
)
-
>
Then
(
mPBackgroundEventTarget
__func__
[
this
self
=
RefPtr
(
this
)
]
(
Promise2
:
:
ResolveOrRejectValue
&
&
aValue
)
{
const
auto
[
captureId
error
]
=
aValue
.
ResolveValue
(
)
;
if
(
mDestroyed
)
{
LOG
(
"
RecvAllocateCapture
:
child
not
alive
"
)
;
return
;
}
if
(
error
!
=
0
)
{
Unused
<
<
SendReplyFailure
(
)
;
LOG
(
"
RecvAllocateCapture
:
WithEntry
error
"
)
;
return
;
}
LOG
(
"
Allocated
device
nr
%
d
"
captureId
)
;
Unused
<
<
SendReplyAllocateCapture
(
captureId
)
;
}
)
;
return
IPC_OK
(
)
;
}
int
CamerasParent
:
:
ReleaseCapture
(
const
CaptureEngine
&
aCapEngine
int
aCaptureId
)
{
MOZ_ASSERT
(
mVideoCaptureThread
-
>
IsOnCurrentThread
(
)
)
;
int
error
=
-
1
;
if
(
auto
*
engine
=
EnsureInitialized
(
aCapEngine
)
)
{
error
=
engine
-
>
ReleaseVideoCapture
(
aCaptureId
)
;
}
return
error
;
}
ipc
:
:
IPCResult
CamerasParent
:
:
RecvReleaseCapture
(
const
CaptureEngine
&
aCapEngine
const
int
&
aCaptureId
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
!
mDestroyed
)
;
LOG_FUNCTION
(
)
;
LOG
(
"
RecvReleaseCamera
device
nr
%
d
"
aCaptureId
)
;
using
Promise
=
MozPromise
<
int
bool
true
>
;
InvokeAsync
(
mVideoCaptureThread
__func__
[
this
self
=
RefPtr
(
this
)
aCapEngine
aCaptureId
]
{
return
Promise
:
:
CreateAndResolve
(
ReleaseCapture
(
aCapEngine
aCaptureId
)
"
CamerasParent
:
:
RecvReleaseCapture
"
)
;
}
)
-
>
Then
(
mPBackgroundEventTarget
__func__
[
this
self
=
RefPtr
(
this
)
aCaptureId
]
(
Promise
:
:
ResolveOrRejectValue
&
&
aValue
)
{
int
error
=
aValue
.
ResolveValue
(
)
;
if
(
mDestroyed
)
{
LOG
(
"
RecvReleaseCapture
:
child
not
alive
"
)
;
return
;
}
if
(
error
!
=
0
)
{
Unused
<
<
SendReplyFailure
(
)
;
LOG
(
"
RecvReleaseCapture
:
Failed
to
free
device
nr
%
d
"
aCaptureId
)
;
return
;
}
Unused
<
<
SendReplySuccess
(
)
;
LOG
(
"
Freed
device
nr
%
d
"
aCaptureId
)
;
}
)
;
return
IPC_OK
(
)
;
}
ipc
:
:
IPCResult
CamerasParent
:
:
RecvStartCapture
(
const
CaptureEngine
&
aCapEngine
const
int
&
aCaptureId
const
VideoCaptureCapability
&
aIpcCaps
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
!
mDestroyed
)
;
LOG_FUNCTION
(
)
;
using
Promise
=
MozPromise
<
int
bool
true
>
;
InvokeAsync
(
mVideoCaptureThread
__func__
[
this
self
=
RefPtr
(
this
)
aCapEngine
aCaptureId
aIpcCaps
]
{
LOG_FUNCTION
(
)
;
int
error
=
-
1
;
if
(
!
EnsureInitialized
(
aCapEngine
)
)
{
return
Promise
:
:
CreateAndResolve
(
error
"
CamerasParent
:
:
RecvStartCapture
"
)
;
}
mEngines
-
>
ElementAt
(
aCapEngine
)
-
>
WithEntry
(
aCaptureId
[
&
]
(
VideoEngine
:
:
CaptureEntry
&
cap
)
{
webrtc
:
:
VideoCaptureCapability
capability
;
capability
.
width
=
aIpcCaps
.
width
(
)
;
capability
.
height
=
aIpcCaps
.
height
(
)
;
capability
.
maxFPS
=
aIpcCaps
.
maxFPS
(
)
;
capability
.
videoType
=
static_cast
<
webrtc
:
:
VideoType
>
(
aIpcCaps
.
videoType
(
)
)
;
capability
.
interlaced
=
aIpcCaps
.
interlaced
(
)
;
if
(
sDeviceUniqueIDs
.
find
(
aCaptureId
)
=
=
sDeviceUniqueIDs
.
end
(
)
)
{
sDeviceUniqueIDs
.
emplace
(
aCaptureId
cap
.
VideoCapture
(
)
-
>
CurrentDeviceName
(
)
)
;
sAllRequestedCapabilities
.
emplace
(
aCaptureId
capability
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
strcmp
(
sDeviceUniqueIDs
[
aCaptureId
]
cap
.
VideoCapture
(
)
-
>
CurrentDeviceName
(
)
)
=
=
0
)
;
MOZ_DIAGNOSTIC_ASSERT
(
sAllRequestedCapabilities
.
find
(
aCaptureId
)
!
=
sAllRequestedCapabilities
.
end
(
)
)
;
sAllRequestedCapabilities
[
aCaptureId
]
=
capability
;
}
if
(
aCapEngine
=
=
CameraEngine
)
{
for
(
const
auto
&
it
:
sDeviceUniqueIDs
)
{
if
(
strcmp
(
it
.
second
cap
.
VideoCapture
(
)
-
>
CurrentDeviceName
(
)
)
=
=
0
)
{
capability
.
width
=
std
:
:
max
(
capability
.
width
sAllRequestedCapabilities
[
it
.
first
]
.
width
)
;
capability
.
height
=
std
:
:
max
(
capability
.
height
sAllRequestedCapabilities
[
it
.
first
]
.
height
)
;
capability
.
maxFPS
=
std
:
:
max
(
capability
.
maxFPS
sAllRequestedCapabilities
[
it
.
first
]
.
maxFPS
)
;
}
}
auto
candidateCapabilities
=
mAllCandidateCapabilities
.
find
(
nsCString
(
cap
.
VideoCapture
(
)
-
>
CurrentDeviceName
(
)
)
)
;
if
(
(
candidateCapabilities
!
=
mAllCandidateCapabilities
.
end
(
)
)
&
&
(
!
candidateCapabilities
-
>
second
.
empty
(
)
)
)
{
int32_t
minIdx
=
-
1
;
uint64_t
minDistance
=
UINT64_MAX
;
for
(
auto
&
candidateCapability
:
candidateCapabilities
-
>
second
)
{
if
(
candidateCapability
.
second
.
videoType
!
=
capability
.
videoType
)
{
continue
;
}
uint64_t
distance
=
uint64_t
(
ResolutionFeasibilityDistance
(
candidateCapability
.
second
.
width
capability
.
width
)
)
+
uint64_t
(
ResolutionFeasibilityDistance
(
candidateCapability
.
second
.
height
capability
.
height
)
)
+
uint64_t
(
FeasibilityDistance
(
candidateCapability
.
second
.
maxFPS
capability
.
maxFPS
)
)
;
if
(
distance
<
minDistance
)
{
minIdx
=
static_cast
<
int32_t
>
(
candidateCapability
.
first
)
;
minDistance
=
distance
;
}
}
MOZ_ASSERT
(
minIdx
!
=
-
1
)
;
capability
=
candidateCapabilities
-
>
second
[
minIdx
]
;
}
}
else
if
(
aCapEngine
=
=
ScreenEngine
|
|
aCapEngine
=
=
BrowserEngine
|
|
aCapEngine
=
=
WinEngine
)
{
for
(
const
auto
&
it
:
sDeviceUniqueIDs
)
{
if
(
strcmp
(
it
.
second
cap
.
VideoCapture
(
)
-
>
CurrentDeviceName
(
)
)
=
=
0
)
{
capability
.
maxFPS
=
std
:
:
max
(
capability
.
maxFPS
sAllRequestedCapabilities
[
it
.
first
]
.
maxFPS
)
;
}
}
}
bool
cbhExists
=
false
;
CallbackHelper
*
*
cbh
=
nullptr
;
for
(
auto
*
cb
:
mCallbacks
)
{
if
(
cb
-
>
mCapEngine
=
=
aCapEngine
&
&
cb
-
>
mStreamId
=
=
(
uint32_t
)
aCaptureId
)
{
cbhExists
=
true
;
break
;
}
}
if
(
!
cbhExists
)
{
cbh
=
mCallbacks
.
AppendElement
(
new
CallbackHelper
(
static_cast
<
CaptureEngine
>
(
aCapEngine
)
aCaptureId
this
)
)
;
cap
.
VideoCapture
(
)
-
>
SetTrackingId
(
(
*
cbh
)
-
>
mTrackingId
.
mUniqueInProcId
)
;
}
error
=
cap
.
VideoCapture
(
)
-
>
StartCapture
(
capability
)
;
if
(
!
error
)
{
if
(
cbh
)
{
cap
.
VideoCapture
(
)
-
>
RegisterCaptureDataCallback
(
static_cast
<
rtc
:
:
VideoSinkInterface
<
webrtc
:
:
VideoFrame
>
*
>
(
*
cbh
)
)
;
if
(
auto
*
event
=
cap
.
CaptureEndedEvent
(
)
;
event
&
&
!
(
*
cbh
)
-
>
mConnectedToCaptureEnded
)
{
(
*
cbh
)
-
>
mCaptureEndedListener
=
event
-
>
Connect
(
mVideoCaptureThread
(
*
cbh
)
&
CallbackHelper
:
:
OnCaptureEnded
)
;
(
*
cbh
)
-
>
mConnectedToCaptureEnded
=
true
;
}
}
}
else
{
sDeviceUniqueIDs
.
erase
(
aCaptureId
)
;
sAllRequestedCapabilities
.
erase
(
aCaptureId
)
;
}
}
)
;
return
Promise
:
:
CreateAndResolve
(
error
"
CamerasParent
:
:
RecvStartCapture
"
)
;
}
)
-
>
Then
(
mPBackgroundEventTarget
__func__
[
this
self
=
RefPtr
(
this
)
]
(
Promise
:
:
ResolveOrRejectValue
&
&
aValue
)
{
int
error
=
aValue
.
ResolveValue
(
)
;
if
(
mDestroyed
)
{
LOG
(
"
RecvStartCapture
failure
:
child
is
not
alive
"
)
;
return
;
}
if
(
error
!
=
0
)
{
LOG
(
"
RecvStartCapture
failure
:
StartCapture
failed
"
)
;
Unused
<
<
SendReplyFailure
(
)
;
return
;
}
Unused
<
<
SendReplySuccess
(
)
;
}
)
;
return
IPC_OK
(
)
;
}
ipc
:
:
IPCResult
CamerasParent
:
:
RecvFocusOnSelectedSource
(
const
CaptureEngine
&
aCapEngine
const
int
&
aCaptureId
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
!
mDestroyed
)
;
LOG_FUNCTION
(
)
;
using
Promise
=
MozPromise
<
bool
bool
true
>
;
InvokeAsync
(
mVideoCaptureThread
__func__
[
this
self
=
RefPtr
(
this
)
aCapEngine
aCaptureId
]
{
bool
result
=
false
;
if
(
auto
*
engine
=
EnsureInitialized
(
aCapEngine
)
)
{
engine
-
>
WithEntry
(
aCaptureId
[
&
]
(
VideoEngine
:
:
CaptureEntry
&
cap
)
{
if
(
cap
.
VideoCapture
(
)
)
{
result
=
cap
.
VideoCapture
(
)
-
>
FocusOnSelectedSource
(
)
;
}
}
)
;
}
return
Promise
:
:
CreateAndResolve
(
result
"
CamerasParent
:
:
RecvFocusOnSelectedSource
"
)
;
}
)
-
>
Then
(
mPBackgroundEventTarget
__func__
[
this
self
=
RefPtr
(
this
)
]
(
Promise
:
:
ResolveOrRejectValue
&
&
aValue
)
{
bool
result
=
aValue
.
ResolveValue
(
)
;
if
(
mDestroyed
)
{
LOG
(
"
RecvFocusOnSelectedSource
failure
:
child
is
not
alive
"
)
;
return
;
}
if
(
!
result
)
{
Unused
<
<
SendReplyFailure
(
)
;
LOG
(
"
RecvFocusOnSelectedSource
failure
.
"
)
;
return
;
}
Unused
<
<
SendReplySuccess
(
)
;
}
)
;
return
IPC_OK
(
)
;
}
void
CamerasParent
:
:
StopCapture
(
const
CaptureEngine
&
aCapEngine
int
aCaptureId
)
{
MOZ_ASSERT
(
mVideoCaptureThread
-
>
IsOnCurrentThread
(
)
)
;
if
(
auto
*
engine
=
EnsureInitialized
(
aCapEngine
)
)
{
for
(
size_t
i
=
mCallbacks
.
Length
(
)
;
i
>
0
;
i
-
-
)
{
if
(
mCallbacks
[
i
-
1
]
-
>
mCapEngine
=
=
aCapEngine
&
&
mCallbacks
[
i
-
1
]
-
>
mStreamId
=
=
(
uint32_t
)
aCaptureId
)
{
CallbackHelper
*
cbh
=
mCallbacks
[
i
-
1
]
;
engine
-
>
WithEntry
(
aCaptureId
[
cbh
&
aCaptureId
]
(
VideoEngine
:
:
CaptureEntry
&
cap
)
{
if
(
cap
.
VideoCapture
(
)
)
{
cap
.
VideoCapture
(
)
-
>
DeRegisterCaptureDataCallback
(
static_cast
<
rtc
:
:
VideoSinkInterface
<
webrtc
:
:
VideoFrame
>
*
>
(
cbh
)
)
;
cap
.
VideoCapture
(
)
-
>
StopCaptureIfAllClientsClose
(
)
;
sDeviceUniqueIDs
.
erase
(
aCaptureId
)
;
sAllRequestedCapabilities
.
erase
(
aCaptureId
)
;
}
}
)
;
cbh
-
>
mCaptureEndedListener
.
DisconnectIfExists
(
)
;
delete
mCallbacks
[
i
-
1
]
;
mCallbacks
.
RemoveElementAt
(
i
-
1
)
;
break
;
}
}
}
}
ipc
:
:
IPCResult
CamerasParent
:
:
RecvStopCapture
(
const
CaptureEngine
&
aCapEngine
const
int
&
aCaptureId
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
!
mDestroyed
)
;
LOG_FUNCTION
(
)
;
nsresult
rv
=
mVideoCaptureThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
(
this
)
aCapEngine
aCaptureId
]
{
StopCapture
(
aCapEngine
aCaptureId
)
;
}
)
)
;
if
(
mDestroyed
)
{
if
(
NS_FAILED
(
rv
)
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
}
else
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
!
SendReplySuccess
(
)
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
}
else
{
if
(
!
SendReplyFailure
(
)
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
}
}
return
IPC_OK
(
)
;
}
void
CamerasParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
-
>
IsOnCurrentThread
(
)
)
;
LOG_FUNCTION
(
)
;
mShmemPool
.
Cleanup
(
this
)
;
mDestroyed
=
true
;
mShutdownRequest
.
DisconnectIfExists
(
)
;
if
(
mVideoCaptureThread
)
{
MOZ_ALWAYS_SUCCEEDS
(
mVideoCaptureThread
-
>
Dispatch
(
NewRunnableMethod
(
__func__
this
&
CamerasParent
:
:
CloseEngines
)
)
)
;
}
}
void
CamerasParent
:
:
OnShutdown
(
)
{
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
LOG
(
"
CamerasParent
(
%
p
)
ShutdownEvent
"
this
)
;
mShutdownRequest
.
Complete
(
)
;
(
void
)
Send__delete__
(
this
)
;
}
CamerasParent
:
:
CamerasParent
(
)
:
mShutdownBlocker
(
ShutdownBlockingTicket
:
:
Create
(
u
"
CamerasParent
"
_ns
NS_LITERAL_STRING_FROM_CSTRING
(
__FILE__
)
__LINE__
)
)
mVideoCaptureThread
(
mShutdownBlocker
?
MakeAndAddRefVideoCaptureThreadAndSingletons
(
)
:
nullptr
)
mEngines
(
sEngines
)
mVideoCaptureFactory
(
EnsureVideoCaptureFactory
(
)
)
mShmemPool
(
CaptureEngine
:
:
MaxEngine
)
mPBackgroundEventTarget
(
GetCurrentSerialEventTarget
(
)
)
mDestroyed
(
false
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
!
=
nullptr
"
GetCurrentThreadEventTarget
failed
"
)
;
LOG
(
"
CamerasParent
:
%
p
"
this
)
;
}
auto
CamerasParent
:
:
RequestCameraAccess
(
bool
aAllowPermissionRequest
)
-
>
RefPtr
<
CameraAccessRequestPromise
>
{
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
if
(
!
aAllowPermissionRequest
)
{
return
EnsureVideoCaptureFactory
(
)
-
>
UpdateCameraAvailability
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
"
CamerasParent
:
:
RequestCameraAccess
update
camera
availability
"
[
]
(
const
VideoCaptureFactory
:
:
UpdateCameraAvailabilityPromise
:
:
ResolveOrRejectValue
&
aValue
)
{
LOG
(
"
Camera
availability
updated
to
%
s
"
aValue
.
IsResolve
(
)
?
aValue
.
ResolveValue
(
)
=
=
VideoCaptureFactory
:
:
CameraAvailability
:
:
Available
?
"
available
"
:
"
not
available
"
:
"
still
unknown
"
)
;
return
CameraAccessRequestPromise
:
:
CreateAndResolve
(
CamerasAccessStatus
:
:
RequestRequired
"
CamerasParent
:
:
RequestCameraAccess
camera
availability
updated
"
)
;
}
)
;
}
static
StaticRefPtr
<
CameraAccessRequestPromise
>
sCameraAccessRequestPromise
;
if
(
!
sCameraAccessRequestPromise
)
{
sCameraAccessRequestPromise
=
RefPtr
<
CameraAccessRequestPromise
>
(
EnsureVideoCaptureFactory
(
)
-
>
InitCameraBackend
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
"
CamerasParent
:
:
RequestCameraAccess
camera
backend
init
handler
"
[
]
(
nsresult
aRv
)
mutable
{
MOZ_ASSERT
(
NS_SUCCEEDED
(
aRv
)
)
;
if
(
sVideoCaptureThread
)
{
MOZ_ASSERT
(
sEngines
)
;
MOZ_ALWAYS_SUCCEEDS
(
sVideoCaptureThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
__func__
[
engines
=
RefPtr
(
sEngines
.
get
(
)
)
]
{
if
(
VideoEngine
*
engine
=
engines
-
>
ElementAt
(
CameraEngine
)
)
{
engine
-
>
ClearVideoCaptureDeviceInfo
(
)
;
}
}
)
)
)
;
}
return
CameraAccessRequestPromise
:
:
CreateAndResolve
(
CamerasAccessStatus
:
:
Granted
"
CamerasParent
:
:
RequestCameraAccess
camera
backend
init
"
"
resolve
"
)
;
}
[
]
(
nsresult
aRv
)
mutable
{
MOZ_ASSERT
(
NS_FAILED
(
aRv
)
)
;
return
CameraAccessRequestPromise
:
:
CreateAndResolve
(
aRv
=
=
NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR
?
CamerasAccessStatus
:
:
Rejected
:
CamerasAccessStatus
:
:
Error
"
CamerasParent
:
:
RequestCameraAccess
camera
backend
init
"
"
reject
"
)
;
}
)
)
;
static
nsresult
clearingRv
=
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
]
{
ClearOnShutdown
(
&
sCameraAccessRequestPromise
)
;
}
)
)
;
Unused
<
<
clearingRv
;
}
return
sCameraAccessRequestPromise
-
>
Then
(
GetCurrentSerialEventTarget
(
)
"
CamerasParent
:
:
CameraAccessRequestPromise
rejection
handler
"
[
]
(
CamerasAccessStatus
aStatus
)
{
return
CameraAccessRequestPromise
:
:
CreateAndResolve
(
aStatus
"
CamerasParent
:
:
RequestCameraAccess
resolve
"
)
;
}
[
promise
=
RefPtr
(
sCameraAccessRequestPromise
.
get
(
)
)
aAllowPermissionRequest
]
(
void_t
aRv
)
{
if
(
promise
=
=
sCameraAccessRequestPromise
)
{
sCameraAccessRequestPromise
=
nullptr
;
return
CameraAccessRequestPromise
:
:
CreateAndResolve
(
CamerasAccessStatus
:
:
Error
"
CamerasParent
:
:
RequestCameraAccess
reject
"
)
;
}
return
CamerasParent
:
:
RequestCameraAccess
(
aAllowPermissionRequest
)
;
}
)
;
}
ipc
:
:
IPCResult
CamerasParent
:
:
RecvPCamerasConstructor
(
)
{
MOZ_ASSERT
(
mPBackgroundEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
!
mShutdownBlocker
)
{
LOG
(
"
CamerasParent
(
%
p
)
Got
no
ShutdownBlockingTicket
.
We
are
already
in
"
"
shutdown
.
Deleting
.
"
this
)
;
return
Send__delete__
(
this
)
?
IPC_OK
(
)
:
IPC_FAIL
(
this
"
Failed
to
send
"
)
;
}
if
(
!
mVideoCaptureThread
)
{
return
Send__delete__
(
this
)
?
IPC_OK
(
)
:
IPC_FAIL
(
this
"
Failed
to
send
"
)
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
this
self
=
RefPtr
(
this
)
]
{
mLogHandle
=
new
nsMainThreadPtrHolder
<
WebrtcLogSinkHandle
>
(
"
CamerasParent
:
:
mLogHandle
"
EnsureWebrtcLogging
(
)
)
;
}
)
)
;
MOZ_ASSERT
(
mEngines
)
;
mShutdownBlocker
-
>
ShutdownPromise
(
)
-
>
Then
(
mPBackgroundEventTarget
"
CamerasParent
OnShutdown
"
[
this
self
=
RefPtr
(
this
)
]
(
const
ShutdownPromise
:
:
ResolveOrRejectValue
&
aValue
)
{
MOZ_ASSERT
(
aValue
.
IsResolve
(
)
"
ShutdownBlockingTicket
must
have
been
destroyed
"
"
without
us
disconnecting
the
shutdown
request
"
)
;
OnShutdown
(
)
;
}
)
-
>
Track
(
mShutdownRequest
)
;
return
IPC_OK
(
)
;
}
CamerasParent
:
:
~
CamerasParent
(
)
{
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
LOG_FUNCTION
(
)
;
if
(
!
mVideoCaptureThread
)
{
return
;
}
MOZ_ASSERT
(
mShutdownBlocker
"
A
ShutdownBlocker
is
a
prerequisite
for
mVideoCaptureThread
"
)
;
ReleaseVideoCaptureThreadAndSingletons
(
)
;
}
already_AddRefed
<
CamerasParent
>
CamerasParent
:
:
Create
(
)
{
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
return
MakeAndAddRef
<
CamerasParent
>
(
)
;
}
}
}
