#
if
defined
(
WEBRTC_WIN
)
#
include
"
platform_uithread
.
h
"
namespace
rtc
{
static
const
UINT_PTR
kTimerId
=
1
;
static
const
wchar_t
kThisProperty
[
]
=
L
"
ThreadWindowsUIPtr
"
;
static
const
wchar_t
kThreadWindow
[
]
=
L
"
WebrtcWindowsUIThread
"
;
PlatformUIThread
:
:
~
PlatformUIThread
(
)
{
CritScope
scoped_lock
(
&
cs_
)
;
switch
(
state_
)
{
case
State
:
:
STARTED
:
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
PlatformUIThread
must
be
stopped
before
destruction
"
)
;
break
;
}
case
State
:
:
STOPPED
:
break
;
case
State
:
:
UNSTARTED
:
break
;
}
}
bool
PlatformUIThread
:
:
InternalInit
(
)
{
CritScope
scoped_lock
(
&
cs_
)
;
switch
(
state_
)
{
case
State
:
:
STARTED
:
break
;
case
State
:
:
STOPPED
:
break
;
case
State
:
:
UNSTARTED
:
{
WNDCLASSW
wc
;
HMODULE
hModule
=
GetModuleHandle
(
NULL
)
;
if
(
!
GetClassInfoW
(
hModule
kThreadWindow
&
wc
)
)
{
ZeroMemory
(
&
wc
sizeof
(
WNDCLASSW
)
)
;
wc
.
hInstance
=
hModule
;
wc
.
lpfnWndProc
=
EventWindowProc
;
wc
.
lpszClassName
=
kThreadWindow
;
RegisterClassW
(
&
wc
)
;
}
hwnd_
=
CreateWindowW
(
kThreadWindow
L
"
"
0
0
0
0
0
NULL
NULL
hModule
NULL
)
;
MOZ_RELEASE_ASSERT
(
hwnd_
)
;
if
(
hwnd_
)
{
SetPropW
(
hwnd_
kThisProperty
this
)
;
state_
=
State
:
:
STARTED
;
if
(
timeout_
)
{
RequestCallbackTimer
(
timeout_
)
;
}
}
break
;
}
}
;
return
state_
=
=
State
:
:
STARTED
;
}
bool
PlatformUIThread
:
:
RequestCallbackTimer
(
unsigned
int
milliseconds
)
{
CritScope
scoped_lock
(
&
cs_
)
;
switch
(
state_
)
{
case
State
:
:
UNSTARTED
:
{
timeout_
=
milliseconds
;
return
false
;
}
case
State
:
:
STOPPED
:
return
false
;
case
State
:
:
STARTED
:
{
if
(
timerid_
)
{
KillTimer
(
hwnd_
timerid_
)
;
}
timeout_
=
milliseconds
;
timerid_
=
SetTimer
(
hwnd_
kTimerId
milliseconds
NULL
)
;
return
!
!
timerid_
;
}
}
}
void
PlatformUIThread
:
:
Stop
(
)
{
{
CritScope
scoped_lock
(
&
cs_
)
;
RTC_DCHECK
(
thread_checker_
.
CalledOnValidThread
(
)
)
;
if
(
timerid_
)
{
MOZ_ASSERT
(
hwnd_
)
;
KillTimer
(
hwnd_
timerid_
)
;
timerid_
=
0
;
}
switch
(
state_
)
{
case
State
:
:
UNSTARTED
:
break
;
case
State
:
:
STARTED
:
{
MOZ_ASSERT
(
hwnd_
)
;
PostMessage
(
hwnd_
WM_CLOSE
0
0
)
;
break
;
}
case
State
:
:
STOPPED
:
break
;
}
state_
=
State
:
:
STOPPED
;
}
PlatformThread
:
:
Stop
(
)
;
}
void
PlatformUIThread
:
:
Run
(
)
{
const
bool
runUntilQuitMsg
=
InternalInit
(
)
;
NativeEventCallback
(
)
;
while
(
runUntilQuitMsg
)
{
if
(
MsgWaitForMultipleObjectsEx
(
0
nullptr
INFINITE
QS_ALLINPUT
MWMO_ALERTABLE
|
MWMO_INPUTAVAILABLE
)
=
=
WAIT_OBJECT_0
)
{
MSG
msg
;
if
(
PeekMessage
(
&
msg
NULL
0
0
PM_REMOVE
)
)
{
if
(
msg
.
message
=
=
WM_QUIT
)
{
break
;
}
TranslateMessage
(
&
msg
)
;
DispatchMessage
(
&
msg
)
;
}
}
}
}
void
PlatformUIThread
:
:
NativeEventCallback
(
)
{
run_function_
(
obj_
)
;
}
LRESULT
CALLBACK
PlatformUIThread
:
:
EventWindowProc
(
HWND
hwnd
UINT
uMsg
WPARAM
wParam
LPARAM
lParam
)
{
if
(
uMsg
=
=
WM_DESTROY
)
{
RemovePropW
(
hwnd
kThisProperty
)
;
PostQuitMessage
(
0
)
;
return
0
;
}
PlatformUIThread
*
twui
=
static_cast
<
PlatformUIThread
*
>
(
GetPropW
(
hwnd
kThisProperty
)
)
;
if
(
!
twui
)
{
return
DefWindowProc
(
hwnd
uMsg
wParam
lParam
)
;
}
if
(
uMsg
=
=
WM_TIMER
&
&
wParam
=
=
kTimerId
)
{
twui
-
>
NativeEventCallback
(
)
;
return
0
;
}
return
DefWindowProc
(
hwnd
uMsg
wParam
lParam
)
;
}
}
#
endif
