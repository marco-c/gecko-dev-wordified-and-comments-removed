#
include
"
modules
/
desktop_capture
/
desktop_capture_options
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_capturer
.
h
"
#
include
"
tab_capturer
.
h
"
#
include
<
memory
>
#
include
<
string
>
#
include
<
utility
>
#
include
"
modules
/
desktop_capture
/
desktop_frame
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
rtc_base
/
checks
.
h
"
#
include
"
rtc_base
/
logging
.
h
"
#
include
"
rtc_base
/
scoped_ref_ptr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
mozilla
/
dom
/
BrowserHost
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmapBinding
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
mozilla
:
:
LazyLogModule
gTabShareLog
(
"
TabShare
"
)
;
using
namespace
mozilla
:
:
dom
;
#
define
NO_TABSHARE_UI
1
namespace
mozilla
{
TabCapturer
:
:
TabCapturer
(
const
webrtc
:
:
DesktopCaptureOptions
&
options
)
:
mMonitor
(
"
TabCapture
"
)
{
}
TabCapturer
:
:
~
TabCapturer
(
)
{
}
bool
TabCapturer
:
:
GetSourceList
(
webrtc
:
:
DesktopCapturer
:
:
SourceList
*
sources
)
{
MOZ_LOG
(
gTabShareLog
LogLevel
:
:
Debug
(
"
TabShare
:
GetSourceList
result
%
lu
"
sources
-
>
size
(
)
)
)
;
return
true
;
}
bool
TabCapturer
:
:
SelectSource
(
webrtc
:
:
DesktopCapturer
:
:
SourceId
id
)
{
MOZ_LOG
(
gTabShareLog
LogLevel
:
:
Debug
(
"
TabShare
:
source
%
ld
"
id
)
)
;
mBrowserId
=
id
;
return
true
;
}
bool
TabCapturer
:
:
FocusOnSelectedSource
(
)
{
return
true
;
}
nsresult
TabCapturer
:
:
StartRunnable
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
ifdef
NO_TABSHARE_UI
nsCOMPtr
<
nsPIDOMWindowOuter
>
chromeWindow
=
nsContentUtils
:
:
GetMostRecentNonPBWindow
(
)
;
if
(
!
chromeWindow
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
chromeWindow
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
owner
;
docShell
-
>
GetTreeOwner
(
getter_AddRefs
(
owner
)
)
;
if
(
!
owner
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIRemoteTab
>
primaryRemoteTab
;
owner
-
>
GetPrimaryRemoteTab
(
getter_AddRefs
(
primaryRemoteTab
)
)
;
if
(
!
primaryRemoteTab
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
BrowsingContext
>
context
=
BrowserHost
:
:
GetFrom
(
primaryRemoteTab
)
-
>
GetBrowsingContext
(
)
;
if
(
!
context
)
{
return
NS_ERROR_FAILURE
;
}
mVideoSource
-
>
mBrowserId
=
context
-
>
BrowserId
(
)
;
#
endif
MOZ_LOG
(
gTabShareLog
LogLevel
:
:
Debug
(
"
TabShare
:
Start
id
=
%
ld
"
mVideoSource
-
>
mBrowserId
)
)
;
mVideoSource
-
>
CaptureFrameNow
(
)
;
return
NS_OK
;
}
void
TabCapturer
:
:
Start
(
webrtc
:
:
DesktopCapturer
:
:
Callback
*
callback
)
{
RTC_DCHECK
(
!
mCallback
)
;
RTC_DCHECK
(
callback
)
;
mCallback
=
callback
;
NS_DispatchToMainThread
(
new
StartRunnable
(
this
)
)
;
}
void
TabCapturer
:
:
CaptureFrame
(
)
{
MonitorAutoLock
monitor
(
mMonitor
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
TabCapturer
:
Capture
a
frame
"
[
self
=
RefPtr
{
this
}
]
{
self
-
>
CaptureFrameNow
(
)
;
}
)
)
;
monitor
.
Wait
(
)
;
}
bool
TabCapturer
:
:
IsOccluded
(
const
webrtc
:
:
DesktopVector
&
pos
)
{
return
false
;
}
class
TabCapturedHandler
final
:
public
dom
:
:
PromiseNativeHandler
{
public
:
NS_DECL_ISUPPORTS
static
void
Create
(
dom
:
:
Promise
*
aPromise
TabCapturer
*
aEngine
)
{
MOZ_ASSERT
(
aPromise
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
TabCapturedHandler
>
handler
=
new
TabCapturedHandler
(
aEngine
)
;
aPromise
-
>
AppendNativeHandler
(
handler
)
;
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MonitorAutoLock
monitor
(
mEngine
-
>
mMonitor
)
;
if
(
NS_WARN_IF
(
!
aValue
.
isObject
(
)
)
)
{
monitor
.
Notify
(
)
;
return
;
}
RefPtr
<
dom
:
:
ImageBitmap
>
bitmap
;
if
(
NS_WARN_IF
(
NS_FAILED
(
UNWRAP_OBJECT
(
ImageBitmap
&
aValue
.
toObject
(
)
bitmap
)
)
)
)
{
monitor
.
Notify
(
)
;
return
;
}
mEngine
-
>
OnFrame
(
bitmap
)
;
mEngine
-
>
mCapturing
=
false
;
monitor
.
Notify
(
)
;
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MonitorAutoLock
monitor
(
mEngine
-
>
mMonitor
)
;
mEngine
-
>
mCapturing
=
false
;
monitor
.
Notify
(
)
;
}
private
:
explicit
TabCapturedHandler
(
TabCapturer
*
aEngine
)
:
mEngine
(
aEngine
)
{
MOZ_ASSERT
(
aEngine
)
;
}
~
TabCapturedHandler
(
)
=
default
;
RefPtr
<
TabCapturer
>
mEngine
;
}
;
NS_IMPL_ISUPPORTS0
(
TabCapturedHandler
)
void
TabCapturer
:
:
CaptureFrameNow
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_LOG
(
gTabShareLog
LogLevel
:
:
Debug
(
"
TabShare
:
CaptureFrameNow
"
)
)
;
auto
autoFailureCallback
=
MakeScopeExit
(
[
&
]
{
MonitorAutoLock
monitor
(
mMonitor
)
;
mCallback
-
>
OnCaptureResult
(
webrtc
:
:
DesktopCapturer
:
:
Result
:
:
ERROR_TEMPORARY
nullptr
)
;
monitor
.
Notify
(
)
;
}
)
;
WindowGlobalParent
*
wgp
=
nullptr
;
if
(
mBrowserId
!
=
0
)
{
RefPtr
<
BrowsingContext
>
context
=
BrowsingContext
:
:
GetCurrentTopByBrowserId
(
mBrowserId
)
;
if
(
context
)
{
wgp
=
context
-
>
Canonical
(
)
-
>
GetCurrentWindowGlobal
(
)
;
}
}
if
(
!
wgp
)
{
return
;
}
if
(
!
mCapturing
)
{
RefPtr
<
dom
:
:
Promise
>
promise
=
wgp
-
>
DrawSnapshot
(
nullptr
1
.
0
"
white
"
_ns
IgnoreErrors
(
)
)
;
if
(
!
promise
)
{
return
;
}
mCapturing
=
true
;
TabCapturedHandler
:
:
Create
(
promise
this
)
;
}
autoFailureCallback
.
release
(
)
;
}
void
TabCapturer
:
:
OnFrame
(
dom
:
:
ImageBitmap
*
aBitmap
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
UniquePtr
<
dom
:
:
ImageBitmapCloneData
>
data
=
aBitmap
-
>
ToCloneData
(
)
;
webrtc
:
:
DesktopSize
size
(
data
-
>
mPictureRect
.
Width
(
)
data
-
>
mPictureRect
.
Height
(
)
)
;
webrtc
:
:
DesktopRect
rect
=
webrtc
:
:
DesktopRect
:
:
MakeSize
(
size
)
;
std
:
:
unique_ptr
<
webrtc
:
:
DesktopFrame
>
frame
(
new
webrtc
:
:
BasicDesktopFrame
(
size
)
)
;
gfx
:
:
DataSourceSurface
:
:
ScopedMap
map
(
data
-
>
mSurface
gfx
:
:
DataSourceSurface
:
:
READ
)
;
if
(
!
map
.
IsMapped
(
)
)
{
mCallback
-
>
OnCaptureResult
(
webrtc
:
:
DesktopCapturer
:
:
Result
:
:
ERROR_TEMPORARY
nullptr
)
;
return
;
}
frame
-
>
CopyPixelsFrom
(
map
.
GetData
(
)
map
.
GetStride
(
)
rect
)
;
mCallback
-
>
OnCaptureResult
(
webrtc
:
:
DesktopCapturer
:
:
Result
:
:
SUCCESS
std
:
:
move
(
frame
)
)
;
}
}
namespace
webrtc
{
std
:
:
unique_ptr
<
webrtc
:
:
DesktopCapturer
>
webrtc
:
:
DesktopCapturer
:
:
CreateRawTabCapturer
(
const
webrtc
:
:
DesktopCaptureOptions
&
options
)
{
return
std
:
:
unique_ptr
<
webrtc
:
:
DesktopCapturer
>
(
new
mozilla
:
:
TabCapturerWebrtc
(
options
)
)
;
}
}
