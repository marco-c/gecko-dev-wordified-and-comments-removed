#
ifndef
WEBRTC_MODULES_DESKTOP_CAPTURE_MAIN_SOURCE_DESKTOP_CAPTURE_IMPL_H_
#
define
WEBRTC_MODULES_DESKTOP_CAPTURE_MAIN_SOURCE_DESKTOP_CAPTURE_IMPL_H_
#
include
<
memory
>
#
include
<
set
>
#
include
<
string
>
#
include
"
MediaEventSource
.
h
"
#
include
"
PerformanceRecorder
.
h
"
#
include
"
api
/
sequence_checker
.
h
"
#
include
"
api
/
video
/
video_frame
.
h
"
#
include
"
api
/
video
/
video_sink_interface
.
h
"
#
include
"
modules
/
desktop_capture
/
desktop_capturer
.
h
"
#
include
"
modules
/
video_capture
/
video_capture
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsCOMPtr
.
h
"
class
nsIThread
;
class
nsITimer
;
namespace
mozilla
:
:
camera
{
enum
class
CaptureDeviceType
;
}
namespace
webrtc
{
class
VideoCaptureEncodeInterface
;
class
DesktopCaptureImpl
:
public
DesktopCapturer
:
:
Callback
public
VideoCaptureModule
{
public
:
static
DesktopCaptureImpl
*
Create
(
const
int32_t
aModuleId
const
char
*
aUniqueId
const
mozilla
:
:
camera
:
:
CaptureDeviceType
aType
)
;
[
[
nodiscard
]
]
static
std
:
:
shared_ptr
<
VideoCaptureModule
:
:
DeviceInfo
>
CreateDeviceInfo
(
const
int32_t
aId
const
mozilla
:
:
camera
:
:
CaptureDeviceType
aType
)
;
void
RegisterCaptureDataCallback
(
webrtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
aCallback
)
override
;
void
RegisterCaptureDataCallback
(
RawVideoSinkInterface
*
dataCallback
)
override
{
}
void
DeRegisterCaptureDataCallback
(
webrtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
aCallback
)
override
;
int32_t
StopCaptureIfAllClientsClose
(
)
override
;
int32_t
SetCaptureRotation
(
VideoRotation
aRotation
)
override
;
bool
SetApplyRotation
(
bool
aEnable
)
override
;
bool
GetApplyRotation
(
)
override
{
return
true
;
}
const
char
*
CurrentDeviceName
(
)
const
override
;
int32_t
StartCapture
(
const
VideoCaptureCapability
&
aCapability
)
override
;
virtual
bool
FocusOnSelectedSource
(
)
override
;
int32_t
StopCapture
(
)
override
;
bool
CaptureStarted
(
)
override
;
int32_t
CaptureSettings
(
VideoCaptureCapability
&
aSettings
)
override
;
void
CaptureFrameOnThread
(
)
;
mozilla
:
:
MediaEventSource
<
void
>
*
CaptureEndedEvent
(
)
;
const
int32_t
mModuleId
;
const
mozilla
:
:
TrackingId
mTrackingId
;
const
std
:
:
string
mDeviceUniqueId
;
const
mozilla
:
:
camera
:
:
CaptureDeviceType
mDeviceType
;
protected
:
DesktopCaptureImpl
(
const
int32_t
aId
const
char
*
aUniqueId
const
mozilla
:
:
camera
:
:
CaptureDeviceType
aType
)
;
virtual
~
DesktopCaptureImpl
(
)
;
private
:
static
constexpr
uint32_t
kMaxDesktopCaptureCpuUsage
=
50
;
void
InitOnThread
(
std
:
:
unique_ptr
<
DesktopCapturer
>
aCapturer
int
aFramerate
)
;
void
UpdateOnThread
(
int
aFramerate
)
;
void
ShutdownOnThread
(
)
;
void
OnCaptureResult
(
DesktopCapturer
:
:
Result
aResult
std
:
:
unique_ptr
<
DesktopFrame
>
aFrame
)
override
;
void
NotifyOnFrame
(
const
VideoFrame
&
aFrame
)
;
const
nsCOMPtr
<
nsISerialEventTarget
>
mControlThread
;
mozilla
:
:
Maybe
<
VideoCaptureCapability
>
mRequestedCapability
RTC_GUARDED_BY
(
mControlThreadChecker
)
;
std
:
:
unique_ptr
<
DesktopCapturer
>
mCapturer
RTC_GUARDED_BY
(
mCaptureThreadChecker
)
;
nsCOMPtr
<
nsIThread
>
mCaptureThread
RTC_GUARDED_BY
(
mControlThreadChecker
)
;
webrtc
:
:
SequenceChecker
mControlThreadChecker
;
webrtc
:
:
SequenceChecker
mCaptureThreadChecker
;
nsCOMPtr
<
nsITimer
>
mCaptureTimer
RTC_GUARDED_BY
(
mCaptureThreadChecker
)
;
mozilla
:
:
Maybe
<
mozilla
:
:
TimeDuration
>
mRequestedCaptureInterval
RTC_GUARDED_BY
(
mCaptureThreadChecker
)
;
webrtc
:
:
Timestamp
mNextFrameMinimumTime
RTC_GUARDED_BY
(
mCaptureThreadChecker
)
;
mozilla
:
:
DataMutex
<
std
:
:
set
<
webrtc
:
:
VideoSinkInterface
<
VideoFrame
>
*
>
>
mCallbacks
;
mozilla
:
:
MediaEventProducer
<
void
>
mCaptureEndedEvent
;
}
;
}
#
endif
