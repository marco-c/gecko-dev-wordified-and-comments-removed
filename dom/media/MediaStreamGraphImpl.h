#
ifndef
MOZILLA_MEDIASTREAMGRAPHIMPL_H_
#
define
MOZILLA_MEDIASTREAMGRAPHIMPL_H_
#
include
"
MediaStreamGraph
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIAsyncShutdown
.
h
"
#
include
"
Latency
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
GraphDriver
.
h
"
#
include
"
AudioMixer
.
h
"
namespace
mozilla
{
template
<
typename
T
>
class
LinkedList
;
#
ifdef
MOZ_WEBRTC
class
AudioOutputObserver
;
#
endif
struct
StreamUpdate
{
RefPtr
<
MediaStream
>
mStream
;
StreamTime
mNextMainThreadCurrentTime
;
bool
mNextMainThreadFinished
;
}
;
class
ControlMessage
{
public
:
explicit
ControlMessage
(
MediaStream
*
aStream
)
:
mStream
(
aStream
)
{
MOZ_COUNT_CTOR
(
ControlMessage
)
;
}
virtual
~
ControlMessage
(
)
{
MOZ_COUNT_DTOR
(
ControlMessage
)
;
}
virtual
void
Run
(
)
=
0
;
virtual
void
RunDuringShutdown
(
)
{
}
MediaStream
*
GetStream
(
)
{
return
mStream
;
}
protected
:
MediaStream
*
mStream
;
}
;
class
MessageBlock
{
public
:
nsTArray
<
UniquePtr
<
ControlMessage
>
>
mMessages
;
}
;
class
MediaStreamGraphImpl
:
public
MediaStreamGraph
public
nsIMemoryReporter
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIMEMORYREPORTER
explicit
MediaStreamGraphImpl
(
GraphDriverType
aGraphDriverRequested
TrackRate
aSampleRate
dom
:
:
AudioChannel
aChannel
)
;
void
Destroy
(
)
;
void
RunInStableState
(
bool
aSourceIsMSG
)
;
void
EnsureRunInStableState
(
)
;
void
ApplyStreamUpdate
(
StreamUpdate
*
aUpdate
)
;
void
AppendMessage
(
UniquePtr
<
ControlMessage
>
aMessage
)
;
static
already_AddRefed
<
nsIAsyncShutdownClient
>
GetShutdownBarrier
(
)
{
nsCOMPtr
<
nsIAsyncShutdownService
>
svc
=
services
:
:
GetAsyncShutdown
(
)
;
MOZ_RELEASE_ASSERT
(
svc
)
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
barrier
;
nsresult
rv
=
svc
-
>
GetProfileBeforeChange
(
getter_AddRefs
(
barrier
)
)
;
if
(
!
barrier
)
{
rv
=
svc
-
>
GetXpcomWillShutdown
(
getter_AddRefs
(
barrier
)
)
;
}
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_RELEASE_ASSERT
(
barrier
)
;
return
barrier
.
forget
(
)
;
}
class
ShutdownTicket
final
{
public
:
explicit
ShutdownTicket
(
nsIAsyncShutdownBlocker
*
aBlocker
)
:
mBlocker
(
aBlocker
)
{
}
NS_INLINE_DECL_REFCOUNTING
(
ShutdownTicket
)
private
:
~
ShutdownTicket
(
)
{
nsCOMPtr
<
nsIAsyncShutdownClient
>
barrier
=
GetShutdownBarrier
(
)
;
barrier
-
>
RemoveBlocker
(
mBlocker
)
;
}
nsCOMPtr
<
nsIAsyncShutdownBlocker
>
mBlocker
;
}
;
void
ForceShutDown
(
ShutdownTicket
*
aShutdownTicket
)
;
void
Init
(
)
;
static
void
FinishCollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
const
nsTArray
<
AudioNodeSizes
>
&
aAudioStreamSizes
)
;
void
CollectSizesForMemoryReport
(
already_AddRefed
<
nsIHandleReportCallback
>
aHandleReport
already_AddRefed
<
nsISupports
>
aHandlerData
)
;
bool
UpdateMainThreadState
(
)
;
bool
OneIteration
(
GraphTime
aStateEnd
)
;
bool
Running
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
return
mLifecycleState
=
=
LIFECYCLE_RUNNING
;
}
GraphTime
IterationEnd
(
)
const
;
void
EnsureStableStateEventPosted
(
)
;
void
PrepareUpdatesToMainThreadState
(
bool
aFinalUpdate
)
;
bool
AllFinishedStreamsNotified
(
)
;
bool
ShouldUpdateMainThread
(
)
;
void
UpdateCurrentTimeForStreams
(
GraphTime
aPrevCurrentTime
)
;
void
ProcessChunkMetadata
(
GraphTime
aPrevCurrentTime
)
;
template
<
typename
C
typename
Chunk
>
void
ProcessChunkMetadataForInterval
(
MediaStream
*
aStream
TrackID
aTrackID
C
&
aSegment
StreamTime
aStart
StreamTime
aEnd
)
;
void
RunMessagesInQueue
(
)
;
void
UpdateGraph
(
GraphTime
aEndBlockingDecisions
)
;
void
SwapMessageQueues
(
)
{
MOZ_ASSERT
(
CurrentDriver
(
)
-
>
OnThread
(
)
)
;
MOZ_ASSERT
(
mFrontMessageQueue
.
IsEmpty
(
)
)
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
mFrontMessageQueue
.
SwapElements
(
mBackMessageQueue
)
;
}
void
Process
(
)
;
void
ExtractPendingInput
(
SourceMediaStream
*
aStream
GraphTime
aDesiredUpToTime
bool
*
aEnsureNextIteration
)
;
void
RunMessageAfterProcessing
(
UniquePtr
<
ControlMessage
>
aMessage
)
;
void
AudioContextOperationCompleted
(
MediaStream
*
aStream
void
*
aPromise
dom
:
:
AudioContextOperation
aOperation
)
;
void
ApplyAudioContextOperationImpl
(
MediaStream
*
aDestinationStream
const
nsTArray
<
MediaStream
*
>
&
aStreams
dom
:
:
AudioContextOperation
aOperation
void
*
aPromise
)
;
void
IncrementSuspendCount
(
MediaStream
*
aStream
)
;
void
DecrementSuspendCount
(
MediaStream
*
aStream
)
;
void
SuspendOrResumeStreams
(
dom
:
:
AudioContextOperation
aAudioContextOperation
const
nsTArray
<
MediaStream
*
>
&
aStreamSet
)
;
bool
AudioTrackPresent
(
bool
&
aNeedsAEC
)
;
void
UpdateStreamOrder
(
)
;
GraphTime
RoundUpToNextAudioBlock
(
GraphTime
aTime
)
;
void
ProduceDataForStreamsBlockByBlock
(
uint32_t
aStreamIndex
TrackRate
aSampleRate
)
;
GraphTime
WillUnderrun
(
MediaStream
*
aStream
GraphTime
aEndBlockingDecisions
)
;
StreamTime
GraphTimeToStreamTimeWithBlocking
(
MediaStream
*
aStream
GraphTime
aTime
)
;
void
NotifyHasCurrentData
(
MediaStream
*
aStream
)
;
void
CreateOrDestroyAudioStreams
(
MediaStream
*
aStream
)
;
StreamTime
PlayAudio
(
MediaStream
*
aStream
)
;
void
OpenAudioInputImpl
(
int
aID
AudioDataListener
*
aListener
)
;
virtual
nsresult
OpenAudioInput
(
int
aID
AudioDataListener
*
aListener
)
override
;
void
CloseAudioInputImpl
(
AudioDataListener
*
aListener
)
;
virtual
void
CloseAudioInput
(
AudioDataListener
*
aListener
)
override
;
void
FinishStream
(
MediaStream
*
aStream
)
;
StreamTime
GetDesiredBufferEnd
(
MediaStream
*
aStream
)
;
bool
IsEmpty
(
)
const
{
return
mStreams
.
IsEmpty
(
)
&
&
mSuspendedStreams
.
IsEmpty
(
)
&
&
mPortCount
=
=
0
;
}
void
AddStreamGraphThread
(
MediaStream
*
aStream
)
;
void
RemoveStreamGraphThread
(
MediaStream
*
aStream
)
;
void
DestroyPort
(
MediaInputPort
*
aPort
)
;
void
SetStreamOrderDirty
(
)
{
mStreamOrderDirty
=
true
;
}
uint32_t
AudioChannelCount
(
)
const
{
return
2
;
}
double
MediaTimeToSeconds
(
GraphTime
aTime
)
const
{
NS_ASSERTION
(
aTime
>
-
STREAM_TIME_MAX
&
&
aTime
<
=
STREAM_TIME_MAX
"
Bad
time
"
)
;
return
static_cast
<
double
>
(
aTime
)
/
GraphRate
(
)
;
}
GraphTime
SecondsToMediaTime
(
double
aS
)
const
{
NS_ASSERTION
(
0
<
=
aS
&
&
aS
<
=
TRACK_TICKS_MAX
/
TRACK_RATE_MAX
"
Bad
seconds
"
)
;
return
GraphRate
(
)
*
aS
;
}
GraphTime
MillisecondsToMediaTime
(
int32_t
aMS
)
const
{
return
RateConvertTicksRoundDown
(
GraphRate
(
)
1000
aMS
)
;
}
void
PausedIndefinitly
(
)
;
void
ResumedFromPaused
(
)
;
GraphDriver
*
CurrentDriver
(
)
const
{
AssertOnGraphThreadOrNotRunning
(
)
;
return
mDriver
;
}
bool
RemoveMixerCallback
(
MixerCallbackReceiver
*
aReceiver
)
{
return
mMixer
.
RemoveCallback
(
aReceiver
)
;
}
void
SetCurrentDriver
(
GraphDriver
*
aDriver
)
{
AssertOnGraphThreadOrNotRunning
(
)
;
mDriver
=
aDriver
;
}
Monitor
&
GetMonitor
(
)
{
return
mMonitor
;
}
void
EnsureNextIteration
(
)
{
mNeedAnotherIteration
=
true
;
if
(
mGraphDriverAsleep
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
CurrentDriver
(
)
-
>
WakeUp
(
)
;
}
}
void
EnsureNextIterationLocked
(
)
{
mNeedAnotherIteration
=
true
;
if
(
mGraphDriverAsleep
)
{
CurrentDriver
(
)
-
>
WakeUp
(
)
;
}
}
void
RegisterCaptureStreamForWindow
(
uint64_t
aWindowId
ProcessedMediaStream
*
aCaptureStream
)
;
void
UnregisterCaptureStreamForWindow
(
uint64_t
aWindowId
)
;
already_AddRefed
<
MediaInputPort
>
ConnectToCaptureStream
(
uint64_t
aWindowId
MediaStream
*
aMediaStream
)
;
class
StreamSet
{
public
:
class
iterator
{
public
:
explicit
iterator
(
MediaStreamGraphImpl
&
aGraph
)
:
mGraph
(
&
aGraph
)
mArrayNum
(
-
1
)
mArrayIndex
(
0
)
{
+
+
(
*
this
)
;
}
iterator
(
)
:
mGraph
(
nullptr
)
mArrayNum
(
2
)
mArrayIndex
(
0
)
{
}
MediaStream
*
operator
*
(
)
{
return
Array
(
)
-
>
ElementAt
(
mArrayIndex
)
;
}
iterator
operator
+
+
(
)
{
+
+
mArrayIndex
;
while
(
mArrayNum
<
2
&
&
(
mArrayNum
<
0
|
|
mArrayIndex
>
=
Array
(
)
-
>
Length
(
)
)
)
{
+
+
mArrayNum
;
mArrayIndex
=
0
;
}
return
*
this
;
}
bool
operator
=
=
(
const
iterator
&
aOther
)
const
{
return
mArrayNum
=
=
aOther
.
mArrayNum
&
&
mArrayIndex
=
=
aOther
.
mArrayIndex
;
}
bool
operator
!
=
(
const
iterator
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
nsTArray
<
MediaStream
*
>
*
Array
(
)
{
return
mArrayNum
=
=
0
?
&
mGraph
-
>
mStreams
:
&
mGraph
-
>
mSuspendedStreams
;
}
MediaStreamGraphImpl
*
mGraph
;
int
mArrayNum
;
uint32_t
mArrayIndex
;
}
;
explicit
StreamSet
(
MediaStreamGraphImpl
&
aGraph
)
:
mGraph
(
aGraph
)
{
}
iterator
begin
(
)
{
return
iterator
(
mGraph
)
;
}
iterator
end
(
)
{
return
iterator
(
)
;
}
private
:
MediaStreamGraphImpl
&
mGraph
;
}
;
StreamSet
AllStreams
(
)
{
return
StreamSet
(
*
this
)
;
}
RefPtr
<
GraphDriver
>
mDriver
;
nsTArray
<
MediaStream
*
>
mStreams
;
nsTArray
<
MediaStream
*
>
mSuspendedStreams
;
nsTHashtable
<
nsUint64HashKey
>
mSuspendedContexts
;
uint32_t
mFirstCycleBreaker
;
GraphTime
mStateComputedTime
=
0
;
GraphTime
mProcessedTime
=
0
;
TimeStamp
mLastMainThreadUpdate
;
int32_t
mPortCount
;
bool
mInputWanted
;
int
mInputDeviceID
;
bool
mOutputWanted
;
int
mOutputDeviceID
;
nsDataHashtable
<
nsPtrHashKey
<
AudioDataListener
>
uint32_t
>
mInputDeviceUsers
;
Atomic
<
bool
>
mNeedAnotherIteration
;
Atomic
<
bool
>
mGraphDriverAsleep
;
Monitor
mMonitor
;
nsTArray
<
StreamUpdate
>
mStreamUpdates
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mUpdateRunnables
;
nsTArray
<
MessageBlock
>
mFrontMessageQueue
;
nsTArray
<
MessageBlock
>
mBackMessageQueue
;
bool
MessagesQueued
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
return
!
mBackMessageQueue
.
IsEmpty
(
)
;
}
enum
LifecycleState
{
LIFECYCLE_THREAD_NOT_STARTED
LIFECYCLE_RUNNING
LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP
LIFECYCLE_WAITING_FOR_THREAD_SHUTDOWN
LIFECYCLE_WAITING_FOR_STREAM_DESTRUCTION
}
;
LifecycleState
mLifecycleState
;
GraphTime
mEndTime
;
bool
mForceShutDown
;
RefPtr
<
ShutdownTicket
>
mForceShutdownTicket
;
bool
mPostedRunInStableStateEvent
;
nsTArray
<
UniquePtr
<
ControlMessage
>
>
mCurrentTaskMessageQueue
;
bool
mDetectedNotRunning
;
bool
mPostedRunInStableState
;
bool
mRealtime
;
bool
mNonRealtimeProcessing
;
bool
mStreamOrderDirty
;
RefPtr
<
AsyncLatencyLogger
>
mLatencyLog
;
AudioMixer
mMixer
;
#
ifdef
MOZ_WEBRTC
RefPtr
<
AudioOutputObserver
>
mFarendObserverRef
;
#
endif
dom
:
:
AudioChannel
AudioChannel
(
)
const
{
return
mAudioChannel
;
}
private
:
virtual
~
MediaStreamGraphImpl
(
)
;
MOZ_DEFINE_MALLOC_SIZE_OF
(
MallocSizeOf
)
RefPtr
<
MediaStreamGraphImpl
>
mSelfRef
;
struct
WindowAndStream
{
uint64_t
mWindowId
;
RefPtr
<
ProcessedMediaStream
>
mCaptureStreamSink
;
}
;
nsTArray
<
WindowAndStream
>
mWindowCaptureStreams
;
#
ifdef
DEBUG
bool
mCanRunMessagesSynchronously
;
#
endif
dom
:
:
AudioChannel
mAudioChannel
;
}
;
}
#
endif
