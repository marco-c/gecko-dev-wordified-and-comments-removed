#
ifndef
MOZILLA_MEDIASTREAMGRAPHIMPL_H_
#
define
MOZILLA_MEDIASTREAMGRAPHIMPL_H_
#
include
"
MediaStreamGraph
.
h
"
#
include
"
AudioMixer
.
h
"
#
include
"
GraphDriver
.
h
"
#
include
"
Latency
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
AsyncLogger
.
h
"
namespace
mozilla
{
namespace
media
{
class
ShutdownTicket
;
}
template
<
typename
T
>
class
LinkedList
;
struct
StreamUpdate
{
RefPtr
<
MediaStream
>
mStream
;
StreamTime
mNextMainThreadCurrentTime
;
bool
mNextMainThreadFinished
;
}
;
class
ControlMessage
{
public
:
explicit
ControlMessage
(
MediaStream
*
aStream
)
:
mStream
(
aStream
)
{
MOZ_COUNT_CTOR
(
ControlMessage
)
;
}
virtual
~
ControlMessage
(
)
{
MOZ_COUNT_DTOR
(
ControlMessage
)
;
}
virtual
void
Run
(
)
=
0
;
virtual
void
RunDuringShutdown
(
)
{
}
MediaStream
*
GetStream
(
)
{
return
mStream
;
}
protected
:
MediaStream
*
mStream
;
}
;
class
MessageBlock
{
public
:
nsTArray
<
UniquePtr
<
ControlMessage
>
>
mMessages
;
}
;
class
MediaStreamGraphImpl
:
public
MediaStreamGraph
public
nsIMemoryReporter
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIMEMORYREPORTER
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
explicit
MediaStreamGraphImpl
(
GraphDriverType
aGraphDriverRequested
TrackRate
aSampleRate
AbstractThread
*
aWindow
)
;
void
Destroy
(
)
;
void
RunInStableState
(
bool
aSourceIsMSG
)
;
void
EnsureRunInStableState
(
)
;
void
ApplyStreamUpdate
(
StreamUpdate
*
aUpdate
)
;
void
AppendMessage
(
UniquePtr
<
ControlMessage
>
aMessage
)
;
void
Dispatch
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
void
ForceShutDown
(
media
:
:
ShutdownTicket
*
aShutdownTicket
)
;
void
Init
(
)
;
static
void
FinishCollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
const
nsTArray
<
AudioNodeSizes
>
&
aAudioStreamSizes
)
;
void
CollectSizesForMemoryReport
(
already_AddRefed
<
nsIHandleReportCallback
>
aHandleReport
already_AddRefed
<
nsISupports
>
aHandlerData
)
;
bool
UpdateMainThreadState
(
)
;
bool
OneIteration
(
GraphTime
aStateEnd
)
;
void
SignalMainThreadCleanup
(
)
;
bool
Running
(
)
const
{
return
LifecycleStateRef
(
)
=
=
LIFECYCLE_RUNNING
;
}
GraphTime
IterationEnd
(
)
const
;
void
EnsureStableStateEventPosted
(
)
;
void
PrepareUpdatesToMainThreadState
(
bool
aFinalUpdate
)
;
bool
AllFinishedStreamsNotified
(
)
;
bool
ShouldUpdateMainThread
(
)
;
void
UpdateCurrentTimeForStreams
(
GraphTime
aPrevCurrentTime
)
;
void
ProcessChunkMetadata
(
GraphTime
aPrevCurrentTime
)
;
template
<
typename
C
typename
Chunk
>
void
ProcessChunkMetadataForInterval
(
MediaStream
*
aStream
TrackID
aTrackID
C
&
aSegment
StreamTime
aStart
StreamTime
aEnd
)
;
void
RunMessagesInQueue
(
)
;
void
UpdateGraph
(
GraphTime
aEndBlockingDecisions
)
;
void
SwapMessageQueues
(
)
{
MOZ_ASSERT
(
CurrentDriver
(
)
-
>
OnThread
(
)
)
;
MOZ_ASSERT
(
mFrontMessageQueue
.
IsEmpty
(
)
)
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
mFrontMessageQueue
.
SwapElements
(
mBackMessageQueue
)
;
}
void
Process
(
)
;
void
RunMessageAfterProcessing
(
UniquePtr
<
ControlMessage
>
aMessage
)
;
void
AudioContextOperationCompleted
(
MediaStream
*
aStream
void
*
aPromise
dom
:
:
AudioContextOperation
aOperation
)
;
void
ApplyAudioContextOperationImpl
(
MediaStream
*
aDestinationStream
const
nsTArray
<
MediaStream
*
>
&
aStreams
dom
:
:
AudioContextOperation
aOperation
void
*
aPromise
)
;
void
IncrementSuspendCount
(
MediaStream
*
aStream
)
;
void
DecrementSuspendCount
(
MediaStream
*
aStream
)
;
void
SuspendOrResumeStreams
(
dom
:
:
AudioContextOperation
aAudioContextOperation
const
nsTArray
<
MediaStream
*
>
&
aStreamSet
)
;
bool
AudioTrackPresent
(
)
;
void
UpdateStreamOrder
(
)
;
GraphTime
RoundUpToEndOfAudioBlock
(
GraphTime
aTime
)
;
GraphTime
RoundUpToNextAudioBlock
(
GraphTime
aTime
)
;
void
ProduceDataForStreamsBlockByBlock
(
uint32_t
aStreamIndex
TrackRate
aSampleRate
)
;
GraphTime
WillUnderrun
(
MediaStream
*
aStream
GraphTime
aEndBlockingDecisions
)
;
StreamTime
GraphTimeToStreamTimeWithBlocking
(
const
MediaStream
*
aStream
GraphTime
aTime
)
const
;
void
NotifyHasCurrentData
(
MediaStream
*
aStream
)
;
void
CreateOrDestroyAudioStreams
(
MediaStream
*
aStream
)
;
StreamTime
PlayAudio
(
MediaStream
*
aStream
)
;
void
OpenAudioInputImpl
(
CubebUtils
:
:
AudioDeviceID
aID
AudioDataListener
*
aListener
)
;
virtual
nsresult
OpenAudioInput
(
CubebUtils
:
:
AudioDeviceID
aID
AudioDataListener
*
aListener
)
override
;
void
CloseAudioInputImpl
(
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
&
aID
AudioDataListener
*
aListener
)
;
virtual
void
CloseAudioInput
(
Maybe
<
CubebUtils
:
:
AudioDeviceID
>
&
aID
AudioDataListener
*
aListener
)
override
;
void
ReevaluateInputDevice
(
)
;
void
NotifyOutputData
(
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
;
void
NotifyInputData
(
const
AudioDataValue
*
aBuffer
size_t
aFrames
TrackRate
aRate
uint32_t
aChannels
)
;
void
DeviceChanged
(
)
;
void
DeviceChangedImpl
(
)
;
StreamTime
GetDesiredBufferEnd
(
MediaStream
*
aStream
)
;
bool
IsEmpty
(
)
const
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
|
|
(
NS_IsMainThread
(
)
&
&
LifecycleStateRef
(
)
>
=
LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP
)
)
;
return
mStreams
.
IsEmpty
(
)
&
&
mSuspendedStreams
.
IsEmpty
(
)
&
&
mPortCount
=
=
0
;
}
void
AddStreamGraphThread
(
MediaStream
*
aStream
)
;
void
RemoveStreamGraphThread
(
MediaStream
*
aStream
)
;
void
DestroyPort
(
MediaInputPort
*
aPort
)
;
void
SetStreamOrderDirty
(
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
mStreamOrderDirty
=
true
;
}
uint32_t
AudioOutputChannelCount
(
)
const
{
return
mOutputChannels
;
}
uint32_t
AudioInputChannelCount
(
)
{
MOZ_ASSERT
(
OnGraphThreadOrNotRunning
(
)
)
;
if
(
!
mInputDeviceID
)
{
#
ifndef
ANDROID
MOZ_ASSERT
(
mInputDeviceUsers
.
Count
(
)
=
=
0
"
If
running
on
a
platform
other
than
android
"
"
an
explicit
device
id
should
be
present
"
)
;
#
endif
return
0
;
}
uint32_t
maxInputChannels
=
0
;
nsTArray
<
RefPtr
<
AudioDataListener
>
>
*
listeners
=
mInputDeviceUsers
.
GetValue
(
mInputDeviceID
)
;
MOZ_ASSERT
(
listeners
)
;
for
(
const
auto
&
listener
:
*
listeners
)
{
maxInputChannels
=
std
:
:
max
(
maxInputChannels
listener
-
>
RequestedInputChannelCount
(
this
)
)
;
}
return
maxInputChannels
;
}
CubebUtils
:
:
AudioDeviceID
InputDeviceID
(
)
{
return
mInputDeviceID
;
}
double
MediaTimeToSeconds
(
GraphTime
aTime
)
const
{
NS_ASSERTION
(
aTime
>
-
STREAM_TIME_MAX
&
&
aTime
<
=
STREAM_TIME_MAX
"
Bad
time
"
)
;
return
static_cast
<
double
>
(
aTime
)
/
GraphRate
(
)
;
}
GraphTime
SecondsToMediaTime
(
double
aS
)
const
{
NS_ASSERTION
(
0
<
=
aS
&
&
aS
<
=
TRACK_TICKS_MAX
/
TRACK_RATE_MAX
"
Bad
seconds
"
)
;
return
GraphRate
(
)
*
aS
;
}
GraphTime
MillisecondsToMediaTime
(
int32_t
aMS
)
const
{
return
RateConvertTicksRoundDown
(
GraphRate
(
)
1000
aMS
)
;
}
void
PausedIndefinitly
(
)
;
void
ResumedFromPaused
(
)
;
GraphDriver
*
CurrentDriver
(
)
const
{
#
ifdef
DEBUG
if
(
!
OnGraphThreadOrNotRunning
(
)
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
return
mDriver
;
}
void
SetCurrentDriver
(
GraphDriver
*
aDriver
)
{
MOZ_ASSERT
(
mDriver
-
>
OnThread
(
)
|
|
!
mDriver
-
>
ThreadRunning
(
)
)
;
#
ifdef
DEBUG
mMonitor
.
AssertCurrentThreadOwns
(
)
;
#
endif
mDriver
=
aDriver
;
}
Monitor
&
GetMonitor
(
)
{
return
mMonitor
;
}
void
EnsureNextIteration
(
)
{
mNeedAnotherIteration
=
true
;
if
(
mGraphDriverAsleep
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
CurrentDriver
(
)
-
>
WakeUp
(
)
;
}
}
void
EnsureNextIterationLocked
(
)
{
mNeedAnotherIteration
=
true
;
if
(
mGraphDriverAsleep
)
{
CurrentDriver
(
)
-
>
WakeUp
(
)
;
}
}
void
RegisterCaptureStreamForWindow
(
uint64_t
aWindowId
ProcessedMediaStream
*
aCaptureStream
)
;
void
UnregisterCaptureStreamForWindow
(
uint64_t
aWindowId
)
;
already_AddRefed
<
MediaInputPort
>
ConnectToCaptureStream
(
uint64_t
aWindowId
MediaStream
*
aMediaStream
)
;
class
StreamSet
{
public
:
class
iterator
{
public
:
explicit
iterator
(
MediaStreamGraphImpl
&
aGraph
)
:
mGraph
(
&
aGraph
)
mArrayNum
(
-
1
)
mArrayIndex
(
0
)
{
+
+
(
*
this
)
;
}
iterator
(
)
:
mGraph
(
nullptr
)
mArrayNum
(
2
)
mArrayIndex
(
0
)
{
}
MediaStream
*
operator
*
(
)
{
return
Array
(
)
-
>
ElementAt
(
mArrayIndex
)
;
}
iterator
operator
+
+
(
)
{
+
+
mArrayIndex
;
while
(
mArrayNum
<
2
&
&
(
mArrayNum
<
0
|
|
mArrayIndex
>
=
Array
(
)
-
>
Length
(
)
)
)
{
+
+
mArrayNum
;
mArrayIndex
=
0
;
}
return
*
this
;
}
bool
operator
=
=
(
const
iterator
&
aOther
)
const
{
return
mArrayNum
=
=
aOther
.
mArrayNum
&
&
mArrayIndex
=
=
aOther
.
mArrayIndex
;
}
bool
operator
!
=
(
const
iterator
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
nsTArray
<
MediaStream
*
>
*
Array
(
)
{
return
mArrayNum
=
=
0
?
&
mGraph
-
>
mStreams
:
&
mGraph
-
>
mSuspendedStreams
;
}
MediaStreamGraphImpl
*
mGraph
;
int
mArrayNum
;
uint32_t
mArrayIndex
;
}
;
explicit
StreamSet
(
MediaStreamGraphImpl
&
aGraph
)
:
mGraph
(
aGraph
)
{
}
iterator
begin
(
)
{
return
iterator
(
mGraph
)
;
}
iterator
end
(
)
{
return
iterator
(
)
;
}
private
:
MediaStreamGraphImpl
&
mGraph
;
}
;
StreamSet
AllStreams
(
)
{
return
StreamSet
(
*
this
)
;
}
RefPtr
<
GraphDriver
>
mDriver
;
nsTArray
<
MediaStream
*
>
mStreams
;
nsTArray
<
MediaStream
*
>
mSuspendedStreams
;
uint32_t
mFirstCycleBreaker
;
GraphTime
mStateComputedTime
=
0
;
GraphTime
mProcessedTime
=
0
;
TimeStamp
mLastMainThreadUpdate
;
int32_t
mPortCount
;
CubebUtils
:
:
AudioDeviceID
mInputDeviceID
;
CubebUtils
:
:
AudioDeviceID
mOutputDeviceID
;
nsDataHashtable
<
nsVoidPtrHashKey
nsTArray
<
RefPtr
<
AudioDataListener
>
>
>
mInputDeviceUsers
;
Atomic
<
bool
>
mNeedAnotherIteration
;
Atomic
<
bool
>
mGraphDriverAsleep
;
Monitor
mMonitor
;
nsTArray
<
StreamUpdate
>
mStreamUpdates
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mUpdateRunnables
;
nsTArray
<
MessageBlock
>
mFrontMessageQueue
;
nsTArray
<
MessageBlock
>
mBackMessageQueue
;
bool
MessagesQueued
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
return
!
mBackMessageQueue
.
IsEmpty
(
)
;
}
enum
LifecycleState
{
LIFECYCLE_THREAD_NOT_STARTED
LIFECYCLE_RUNNING
LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP
LIFECYCLE_WAITING_FOR_THREAD_SHUTDOWN
LIFECYCLE_WAITING_FOR_STREAM_DESTRUCTION
}
;
LifecycleState
mLifecycleState
;
LifecycleState
&
LifecycleStateRef
(
)
{
#
if
DEBUG
if
(
!
mDetectedNotRunning
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
return
mLifecycleState
;
}
const
LifecycleState
&
LifecycleStateRef
(
)
const
{
#
if
DEBUG
if
(
!
mDetectedNotRunning
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
return
mLifecycleState
;
}
Atomic
<
GraphTime
>
mEndTime
;
bool
mForceShutDown
;
RefPtr
<
media
:
:
ShutdownTicket
>
mForceShutdownTicket
;
bool
mPostedRunInStableStateEvent
;
nsTArray
<
UniquePtr
<
ControlMessage
>
>
mCurrentTaskMessageQueue
;
Atomic
<
bool
>
mDetectedNotRunning
;
bool
mPostedRunInStableState
;
const
bool
mRealtime
;
bool
mNonRealtimeProcessing
;
bool
mStreamOrderDirty
;
RefPtr
<
AsyncLatencyLogger
>
mLatencyLog
;
AudioMixer
mMixer
;
const
RefPtr
<
AbstractThread
>
mAbstractMainThread
;
nsCOMPtr
<
nsITimer
>
mShutdownTimer
;
private
:
virtual
~
MediaStreamGraphImpl
(
)
;
MOZ_DEFINE_MALLOC_SIZE_OF
(
MallocSizeOf
)
RefPtr
<
MediaStreamGraphImpl
>
mSelfRef
;
struct
WindowAndStream
{
uint64_t
mWindowId
;
RefPtr
<
ProcessedMediaStream
>
mCaptureStreamSink
;
}
;
nsTArray
<
WindowAndStream
>
mWindowCaptureStreams
;
const
uint32_t
mOutputChannels
;
#
ifdef
DEBUG
bool
mCanRunMessagesSynchronously
;
#
endif
}
;
}
#
endif
