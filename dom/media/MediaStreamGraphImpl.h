#
ifndef
MOZILLA_MEDIASTREAMGRAPHIMPL_H_
#
define
MOZILLA_MEDIASTREAMGRAPHIMPL_H_
#
include
"
MediaStreamGraph
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
Latency
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
GraphDriver
.
h
"
#
include
"
AudioMixer
.
h
"
namespace
mozilla
{
template
<
typename
T
>
class
LinkedList
;
#
ifdef
MOZ_WEBRTC
class
AudioOutputObserver
;
#
endif
struct
StreamUpdate
{
RefPtr
<
MediaStream
>
mStream
;
StreamTime
mNextMainThreadCurrentTime
;
bool
mNextMainThreadFinished
;
}
;
class
ControlMessage
{
public
:
explicit
ControlMessage
(
MediaStream
*
aStream
)
:
mStream
(
aStream
)
{
MOZ_COUNT_CTOR
(
ControlMessage
)
;
}
virtual
~
ControlMessage
(
)
{
MOZ_COUNT_DTOR
(
ControlMessage
)
;
}
virtual
void
Run
(
)
=
0
;
virtual
void
RunDuringShutdown
(
)
{
}
MediaStream
*
GetStream
(
)
{
return
mStream
;
}
protected
:
MediaStream
*
mStream
;
}
;
class
MessageBlock
{
public
:
nsTArray
<
nsAutoPtr
<
ControlMessage
>
>
mMessages
;
}
;
class
MediaStreamGraphImpl
:
public
MediaStreamGraph
public
nsIMemoryReporter
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIMEMORYREPORTER
explicit
MediaStreamGraphImpl
(
GraphDriverType
aGraphDriverRequested
TrackRate
aSampleRate
dom
:
:
AudioChannel
aChannel
)
;
void
Destroy
(
)
;
void
RunInStableState
(
bool
aSourceIsMSG
)
;
void
EnsureRunInStableState
(
)
;
void
ApplyStreamUpdate
(
StreamUpdate
*
aUpdate
)
;
void
AppendMessage
(
ControlMessage
*
aMessage
)
;
void
ForceShutDown
(
)
;
void
ShutdownThreads
(
)
;
void
Init
(
)
;
void
AssertOnGraphThreadOrNotRunning
(
)
const
{
#
ifdef
DEBUG
if
(
!
mDriver
-
>
OnThread
(
)
)
{
if
(
!
(
mDetectedNotRunning
&
&
mLifecycleState
>
LIFECYCLE_RUNNING
&
&
NS_IsMainThread
(
)
)
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
}
}
#
endif
}
void
MaybeProduceMemoryReport
(
)
;
bool
UpdateMainThreadState
(
)
;
bool
OneIteration
(
GraphTime
aStateEnd
)
;
bool
Running
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
return
mLifecycleState
=
=
LIFECYCLE_RUNNING
;
}
GraphTime
IterationEnd
(
)
const
;
void
EnsureStableStateEventPosted
(
)
;
void
PrepareUpdatesToMainThreadState
(
bool
aFinalUpdate
)
;
bool
AllFinishedStreamsNotified
(
)
;
bool
ShouldUpdateMainThread
(
)
;
void
UpdateCurrentTimeForStreams
(
GraphTime
aPrevCurrentTime
)
;
void
RunMessagesInQueue
(
)
;
void
UpdateGraph
(
GraphTime
aEndBlockingDecisions
)
;
void
SwapMessageQueues
(
)
{
MOZ_ASSERT
(
CurrentDriver
(
)
-
>
OnThread
(
)
)
;
MOZ_ASSERT
(
mFrontMessageQueue
.
IsEmpty
(
)
)
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
mFrontMessageQueue
.
SwapElements
(
mBackMessageQueue
)
;
}
void
Process
(
)
;
void
ExtractPendingInput
(
SourceMediaStream
*
aStream
GraphTime
aDesiredUpToTime
bool
*
aEnsureNextIteration
)
;
void
RunMessageAfterProcessing
(
nsAutoPtr
<
ControlMessage
>
aMessage
)
;
void
AudioContextOperationCompleted
(
MediaStream
*
aStream
void
*
aPromise
dom
:
:
AudioContextOperation
aOperation
)
;
void
ApplyAudioContextOperationImpl
(
MediaStream
*
aDestinationStream
const
nsTArray
<
MediaStream
*
>
&
aStreams
dom
:
:
AudioContextOperation
aOperation
void
*
aPromise
)
;
void
IncrementSuspendCount
(
MediaStream
*
aStream
)
;
void
DecrementSuspendCount
(
MediaStream
*
aStream
)
;
void
SuspendOrResumeStreams
(
dom
:
:
AudioContextOperation
aAudioContextOperation
const
nsTArray
<
MediaStream
*
>
&
aStreamSet
)
;
void
UpdateStreamOrder
(
)
;
GraphTime
RoundUpToNextAudioBlock
(
GraphTime
aTime
)
;
void
ProduceDataForStreamsBlockByBlock
(
uint32_t
aStreamIndex
TrackRate
aSampleRate
)
;
GraphTime
WillUnderrun
(
MediaStream
*
aStream
GraphTime
aEndBlockingDecisions
)
;
StreamTime
GraphTimeToStreamTimeWithBlocking
(
MediaStream
*
aStream
GraphTime
aTime
)
;
void
NotifyHasCurrentData
(
MediaStream
*
aStream
)
;
void
CreateOrDestroyAudioStreams
(
MediaStream
*
aStream
)
;
StreamTime
PlayAudio
(
MediaStream
*
aStream
)
;
void
PlayVideo
(
MediaStream
*
aStream
)
;
void
OpenAudioInputImpl
(
char
*
aName
MediaStreamListener
*
aListener
)
;
virtual
nsresult
OpenAudioInput
(
char
*
aName
MediaStreamListener
*
aListener
)
override
;
void
CloseAudioInputImpl
(
MediaStreamListener
*
aListener
)
;
virtual
void
CloseAudioInput
(
MediaStreamListener
*
aListener
)
override
;
void
FinishStream
(
MediaStream
*
aStream
)
;
StreamTime
GetDesiredBufferEnd
(
MediaStream
*
aStream
)
;
bool
IsEmpty
(
)
const
{
return
mStreams
.
IsEmpty
(
)
&
&
mSuspendedStreams
.
IsEmpty
(
)
&
&
mPortCount
=
=
0
;
}
void
AddStreamGraphThread
(
MediaStream
*
aStream
)
;
void
RemoveStreamGraphThread
(
MediaStream
*
aStream
)
;
void
DestroyPort
(
MediaInputPort
*
aPort
)
;
void
SetStreamOrderDirty
(
)
{
mStreamOrderDirty
=
true
;
}
uint32_t
AudioChannelCount
(
)
const
{
return
2
;
}
double
MediaTimeToSeconds
(
GraphTime
aTime
)
const
{
NS_ASSERTION
(
aTime
>
-
STREAM_TIME_MAX
&
&
aTime
<
=
STREAM_TIME_MAX
"
Bad
time
"
)
;
return
static_cast
<
double
>
(
aTime
)
/
GraphRate
(
)
;
}
GraphTime
SecondsToMediaTime
(
double
aS
)
const
{
NS_ASSERTION
(
0
<
=
aS
&
&
aS
<
=
TRACK_TICKS_MAX
/
TRACK_RATE_MAX
"
Bad
seconds
"
)
;
return
GraphRate
(
)
*
aS
;
}
GraphTime
MillisecondsToMediaTime
(
int32_t
aMS
)
const
{
return
RateConvertTicksRoundDown
(
GraphRate
(
)
1000
aMS
)
;
}
void
PausedIndefinitly
(
)
;
void
ResumedFromPaused
(
)
;
GraphDriver
*
CurrentDriver
(
)
const
{
AssertOnGraphThreadOrNotRunning
(
)
;
return
mDriver
;
}
bool
RemoveMixerCallback
(
MixerCallbackReceiver
*
aReceiver
)
{
return
mMixer
.
RemoveCallback
(
aReceiver
)
;
}
void
SetCurrentDriver
(
GraphDriver
*
aDriver
)
{
AssertOnGraphThreadOrNotRunning
(
)
;
mDriver
=
aDriver
;
}
Monitor
&
GetMonitor
(
)
{
return
mMonitor
;
}
void
EnsureNextIteration
(
)
{
mNeedAnotherIteration
=
true
;
if
(
mGraphDriverAsleep
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
CurrentDriver
(
)
-
>
WakeUp
(
)
;
}
}
void
EnsureNextIterationLocked
(
)
{
mNeedAnotherIteration
=
true
;
if
(
mGraphDriverAsleep
)
{
CurrentDriver
(
)
-
>
WakeUp
(
)
;
}
}
void
RegisterCaptureStreamForWindow
(
uint64_t
aWindowId
ProcessedMediaStream
*
aCaptureStream
)
;
void
UnregisterCaptureStreamForWindow
(
uint64_t
aWindowId
)
;
already_AddRefed
<
MediaInputPort
>
ConnectToCaptureStream
(
uint64_t
aWindowId
MediaStream
*
aMediaStream
)
;
class
StreamSet
{
public
:
class
iterator
{
public
:
explicit
iterator
(
MediaStreamGraphImpl
&
aGraph
)
:
mGraph
(
&
aGraph
)
mArrayNum
(
-
1
)
mArrayIndex
(
0
)
{
+
+
(
*
this
)
;
}
iterator
(
)
:
mGraph
(
nullptr
)
mArrayNum
(
2
)
mArrayIndex
(
0
)
{
}
MediaStream
*
operator
*
(
)
{
return
Array
(
)
-
>
ElementAt
(
mArrayIndex
)
;
}
iterator
operator
+
+
(
)
{
+
+
mArrayIndex
;
while
(
mArrayNum
<
2
&
&
(
mArrayNum
<
0
|
|
mArrayIndex
>
=
Array
(
)
-
>
Length
(
)
)
)
{
+
+
mArrayNum
;
mArrayIndex
=
0
;
}
return
*
this
;
}
bool
operator
=
=
(
const
iterator
&
aOther
)
const
{
return
mArrayNum
=
=
aOther
.
mArrayNum
&
&
mArrayIndex
=
=
aOther
.
mArrayIndex
;
}
bool
operator
!
=
(
const
iterator
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
nsTArray
<
MediaStream
*
>
*
Array
(
)
{
return
mArrayNum
=
=
0
?
&
mGraph
-
>
mStreams
:
&
mGraph
-
>
mSuspendedStreams
;
}
MediaStreamGraphImpl
*
mGraph
;
int
mArrayNum
;
uint32_t
mArrayIndex
;
}
;
explicit
StreamSet
(
MediaStreamGraphImpl
&
aGraph
)
:
mGraph
(
aGraph
)
{
}
iterator
begin
(
)
{
return
iterator
(
mGraph
)
;
}
iterator
end
(
)
{
return
iterator
(
)
;
}
private
:
MediaStreamGraphImpl
&
mGraph
;
}
;
StreamSet
AllStreams
(
)
{
return
StreamSet
(
*
this
)
;
}
RefPtr
<
GraphDriver
>
mDriver
;
nsTArray
<
MediaStream
*
>
mStreams
;
nsTArray
<
MediaStream
*
>
mSuspendedStreams
;
nsTHashtable
<
nsUint64HashKey
>
mSuspendedContexts
;
uint32_t
mFirstCycleBreaker
;
GraphTime
mStateComputedTime
=
0
;
GraphTime
mProcessedTime
=
0
;
TimeStamp
mLastMainThreadUpdate
;
int32_t
mPortCount
;
Atomic
<
bool
>
mNeedAnotherIteration
;
Atomic
<
bool
>
mGraphDriverAsleep
;
Monitor
mMonitor
;
nsTArray
<
StreamUpdate
>
mStreamUpdates
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mUpdateRunnables
;
nsTArray
<
MessageBlock
>
mFrontMessageQueue
;
nsTArray
<
MessageBlock
>
mBackMessageQueue
;
bool
MessagesQueued
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
return
!
mBackMessageQueue
.
IsEmpty
(
)
;
}
enum
LifecycleState
{
LIFECYCLE_THREAD_NOT_STARTED
LIFECYCLE_RUNNING
LIFECYCLE_WAITING_FOR_MAIN_THREAD_CLEANUP
LIFECYCLE_WAITING_FOR_THREAD_SHUTDOWN
LIFECYCLE_WAITING_FOR_STREAM_DESTRUCTION
}
;
LifecycleState
mLifecycleState
;
GraphTime
mEndTime
;
bool
mForceShutDown
;
bool
mPostedRunInStableStateEvent
;
nsTArray
<
nsAutoPtr
<
ControlMessage
>
>
mCurrentTaskMessageQueue
;
bool
mDetectedNotRunning
;
bool
mPostedRunInStableState
;
bool
mRealtime
;
bool
mNonRealtimeProcessing
;
bool
mStreamOrderDirty
;
RefPtr
<
AsyncLatencyLogger
>
mLatencyLog
;
AudioMixer
mMixer
;
#
ifdef
MOZ_WEBRTC
RefPtr
<
AudioOutputObserver
>
mFarendObserverRef
;
#
endif
dom
:
:
AudioChannel
AudioChannel
(
)
const
{
return
mAudioChannel
;
}
private
:
virtual
~
MediaStreamGraphImpl
(
)
;
MOZ_DEFINE_MALLOC_SIZE_OF
(
MallocSizeOf
)
Monitor
mMemoryReportMonitor
;
RefPtr
<
MediaStreamGraphImpl
>
mSelfRef
;
nsTArray
<
AudioNodeSizes
>
mAudioStreamSizes
;
struct
WindowAndStream
{
uint64_t
mWindowId
;
RefPtr
<
ProcessedMediaStream
>
mCaptureStreamSink
;
}
;
nsTArray
<
WindowAndStream
>
mWindowCaptureStreams
;
bool
mNeedsMemoryReport
;
#
ifdef
DEBUG
bool
mCanRunMessagesSynchronously
;
#
endif
dom
:
:
AudioChannel
mAudioChannel
;
}
;
}
#
endif
