#
ifndef
SEEK_TARGET_H
#
define
SEEK_TARGET_H
#
include
"
TimeUnits
.
h
"
namespace
mozilla
{
enum
class
MediaDecoderEventVisibility
:
int8_t
{
Observable
Suppressed
}
;
struct
SeekTarget
{
enum
Type
{
Invalid
PrevSyncPoint
Accurate
NextFrame
}
;
enum
Track
{
All
AudioOnly
VideoOnly
}
;
SeekTarget
(
)
:
mTime
(
media
:
:
TimeUnit
:
:
Invalid
(
)
)
mType
(
SeekTarget
:
:
Invalid
)
mTargetTrack
(
Track
:
:
All
)
{
}
SeekTarget
(
const
media
:
:
TimeUnit
&
aTime
Type
aType
Track
aTrack
=
Track
:
:
All
)
:
mTime
(
aTime
)
mType
(
aType
)
mTargetTrack
(
aTrack
)
{
MOZ_ASSERT
(
mTime
.
IsValid
(
)
)
;
}
SeekTarget
(
const
SeekTarget
&
aOther
)
:
mTime
(
aOther
.
mTime
)
mType
(
aOther
.
mType
)
mTargetTrack
(
aOther
.
mTargetTrack
)
{
MOZ_ASSERT
(
mTime
.
IsValid
(
)
)
;
}
media
:
:
TimeUnit
GetTime
(
)
const
{
MOZ_ASSERT
(
mTime
.
IsValid
(
)
"
Invalid
SeekTarget
"
)
;
return
mTime
;
}
void
SetTime
(
const
media
:
:
TimeUnit
&
aTime
)
{
MOZ_ASSERT
(
aTime
.
IsValid
(
)
"
Invalid
SeekTarget
destination
"
)
;
mTime
=
aTime
;
}
void
SetType
(
Type
aType
)
{
mType
=
aType
;
}
bool
IsFast
(
)
const
{
return
mType
=
=
SeekTarget
:
:
Type
:
:
PrevSyncPoint
;
}
bool
IsAccurate
(
)
const
{
return
mType
=
=
SeekTarget
:
:
Type
:
:
Accurate
;
}
bool
IsNextFrame
(
)
const
{
return
mType
=
=
SeekTarget
:
:
Type
:
:
NextFrame
;
}
bool
IsVideoOnly
(
)
const
{
return
mTargetTrack
=
=
Track
:
:
VideoOnly
;
}
bool
IsAudioOnly
(
)
const
{
return
mTargetTrack
=
=
Track
:
:
AudioOnly
;
}
bool
IsAllTracks
(
)
const
{
return
mTargetTrack
=
=
Track
:
:
All
;
}
Type
GetType
(
)
const
{
return
mType
;
}
Track
GetTrack
(
)
const
{
return
mTargetTrack
;
}
static
const
char
*
TrackToStr
(
Track
aTrack
)
{
switch
(
aTrack
)
{
case
Track
:
:
All
:
return
"
all
tracks
"
;
case
Track
:
:
AudioOnly
:
return
"
audio
only
"
;
case
Track
:
:
VideoOnly
:
return
"
video
only
"
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Not
defined
track
!
"
)
;
return
"
none
"
;
}
}
private
:
media
:
:
TimeUnit
mTime
;
Type
mType
;
Track
mTargetTrack
;
}
;
}
#
endif
