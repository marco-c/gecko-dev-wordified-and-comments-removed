"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
WebVTT
"
]
;
const
{
Services
}
=
ChromeUtils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Services
.
jsm
'
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
(
function
(
global
)
{
var
_objCreate
=
Object
.
create
|
|
(
function
(
)
{
function
F
(
)
{
}
return
function
(
o
)
{
if
(
arguments
.
length
!
=
=
1
)
{
throw
new
Error
(
'
Object
.
create
shim
only
accepts
one
parameter
.
'
)
;
}
F
.
prototype
=
o
;
return
new
F
(
)
;
}
;
}
)
(
)
;
function
ParsingError
(
errorData
message
)
{
this
.
name
=
"
ParsingError
"
;
this
.
code
=
errorData
.
code
;
this
.
message
=
message
|
|
errorData
.
message
;
}
ParsingError
.
prototype
=
_objCreate
(
Error
.
prototype
)
;
ParsingError
.
prototype
.
constructor
=
ParsingError
;
ParsingError
.
Errors
=
{
BadSignature
:
{
code
:
0
message
:
"
Malformed
WebVTT
signature
.
"
}
BadTimeStamp
:
{
code
:
1
message
:
"
Malformed
time
stamp
.
"
}
}
;
function
collectTimeStamp
(
input
)
{
function
computeSeconds
(
h
m
s
f
)
{
if
(
m
>
59
|
|
s
>
59
)
{
return
null
;
}
if
(
f
.
length
!
=
=
3
)
{
return
null
;
}
return
(
h
|
0
)
*
3600
+
(
m
|
0
)
*
60
+
(
s
|
0
)
+
(
f
|
0
)
/
1000
;
}
var
timestamp
=
input
.
match
(
/
^
(
\
d
+
:
)
?
(
\
d
{
2
}
)
:
(
\
d
{
2
}
)
\
.
(
\
d
+
)
/
)
;
if
(
!
timestamp
|
|
timestamp
.
length
!
=
=
5
)
{
return
null
;
}
let
hours
=
timestamp
[
1
]
?
timestamp
[
1
]
.
replace
(
"
:
"
"
"
)
:
0
;
let
minutes
=
timestamp
[
2
]
;
let
seconds
=
timestamp
[
3
]
;
let
milliSeconds
=
timestamp
[
4
]
;
return
computeSeconds
(
hours
minutes
seconds
milliSeconds
)
;
}
function
Settings
(
)
{
this
.
values
=
_objCreate
(
null
)
;
}
Settings
.
prototype
=
{
set
:
function
(
k
v
)
{
if
(
v
!
=
=
"
"
)
{
this
.
values
[
k
]
=
v
;
}
}
get
:
function
(
k
dflt
defaultKey
)
{
if
(
defaultKey
)
{
return
this
.
has
(
k
)
?
this
.
values
[
k
]
:
dflt
[
defaultKey
]
;
}
return
this
.
has
(
k
)
?
this
.
values
[
k
]
:
dflt
;
}
has
:
function
(
k
)
{
return
k
in
this
.
values
;
}
alt
:
function
(
k
v
a
)
{
for
(
var
n
=
0
;
n
<
a
.
length
;
+
+
n
)
{
if
(
v
=
=
=
a
[
n
]
)
{
this
.
set
(
k
v
)
;
return
true
;
}
}
return
false
;
}
digitsValue
:
function
(
k
v
)
{
if
(
/
^
-
0
+
(
\
.
[
0
]
*
)
?
/
.
test
(
v
)
)
{
this
.
set
(
k
0
.
0
)
;
}
else
if
(
/
^
-
?
\
d
+
(
\
.
[
\
d
]
*
)
?
/
.
test
(
v
)
)
{
this
.
set
(
k
parseFloat
(
v
)
)
;
}
}
percent
:
function
(
k
v
)
{
var
m
;
if
(
(
m
=
v
.
match
(
/
^
(
[
\
d
]
{
1
3
}
)
(
\
.
[
\
d
]
*
)
?
%
/
)
)
)
{
v
=
parseFloat
(
v
)
;
if
(
v
>
=
0
&
&
v
<
=
100
)
{
this
.
set
(
k
v
)
;
return
true
;
}
}
return
false
;
}
del
:
function
(
k
)
{
if
(
this
.
has
(
k
)
)
{
delete
this
.
values
[
k
]
;
}
}
}
;
function
parseOptions
(
input
callback
keyValueDelim
groupDelim
)
{
var
groups
=
groupDelim
?
input
.
split
(
groupDelim
)
:
[
input
]
;
for
(
var
i
in
groups
)
{
if
(
typeof
groups
[
i
]
!
=
=
"
string
"
)
{
continue
;
}
var
kv
=
groups
[
i
]
.
split
(
keyValueDelim
)
;
if
(
kv
.
length
!
=
=
2
)
{
continue
;
}
var
k
=
kv
[
0
]
;
var
v
=
kv
[
1
]
;
callback
(
k
v
)
;
}
}
function
parseCue
(
input
cue
regionList
)
{
var
oInput
=
input
;
function
consumeTimeStamp
(
)
{
var
ts
=
collectTimeStamp
(
input
)
;
if
(
ts
=
=
=
null
)
{
throw
new
ParsingError
(
ParsingError
.
Errors
.
BadTimeStamp
"
Malformed
timestamp
:
"
+
oInput
)
;
}
input
=
input
.
replace
(
/
^
[
^
\
s
\
uFFFDa
-
zA
-
Z
-
]
+
/
"
"
)
;
return
ts
;
}
function
consumeCueSettings
(
input
cue
)
{
var
settings
=
new
Settings
(
)
;
parseOptions
(
input
function
(
k
v
)
{
switch
(
k
)
{
case
"
region
"
:
for
(
var
i
=
regionList
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
regionList
[
i
]
.
id
=
=
=
v
)
{
settings
.
set
(
k
regionList
[
i
]
.
region
)
;
break
;
}
}
break
;
case
"
vertical
"
:
settings
.
alt
(
k
v
[
"
rl
"
"
lr
"
]
)
;
break
;
case
"
line
"
:
var
vals
=
v
.
split
(
"
"
)
vals0
=
vals
[
0
]
;
settings
.
digitsValue
(
k
vals0
)
;
settings
.
percent
(
k
vals0
)
?
settings
.
set
(
"
snapToLines
"
false
)
:
null
;
settings
.
alt
(
k
vals0
[
"
auto
"
]
)
;
if
(
vals
.
length
=
=
=
2
)
{
settings
.
alt
(
"
lineAlign
"
vals
[
1
]
[
"
start
"
"
center
"
"
end
"
]
)
;
}
break
;
case
"
position
"
:
vals
=
v
.
split
(
"
"
)
;
if
(
settings
.
percent
(
k
vals
[
0
]
)
)
{
if
(
vals
.
length
=
=
=
2
)
{
if
(
!
settings
.
alt
(
"
positionAlign
"
vals
[
1
]
[
"
line
-
left
"
"
center
"
"
line
-
right
"
]
)
)
{
settings
.
del
(
k
)
;
}
}
}
break
;
case
"
size
"
:
settings
.
percent
(
k
v
)
;
break
;
case
"
align
"
:
settings
.
alt
(
k
v
[
"
start
"
"
center
"
"
end
"
"
left
"
"
right
"
]
)
;
break
;
}
}
/
:
/
/
\
t
|
\
n
|
\
f
|
\
r
|
/
)
;
cue
.
region
=
settings
.
get
(
"
region
"
null
)
;
cue
.
vertical
=
settings
.
get
(
"
vertical
"
"
"
)
;
cue
.
line
=
settings
.
get
(
"
line
"
"
auto
"
)
;
cue
.
lineAlign
=
settings
.
get
(
"
lineAlign
"
"
start
"
)
;
cue
.
snapToLines
=
settings
.
get
(
"
snapToLines
"
true
)
;
cue
.
size
=
settings
.
get
(
"
size
"
100
)
;
cue
.
align
=
settings
.
get
(
"
align
"
"
center
"
)
;
cue
.
position
=
settings
.
get
(
"
position
"
"
auto
"
)
;
cue
.
positionAlign
=
settings
.
get
(
"
positionAlign
"
"
auto
"
)
;
}
function
skipWhitespace
(
)
{
input
=
input
.
replace
(
/
^
[
\
f
\
n
\
r
\
t
]
+
/
"
"
)
;
}
skipWhitespace
(
)
;
cue
.
startTime
=
consumeTimeStamp
(
)
;
skipWhitespace
(
)
;
if
(
input
.
substr
(
0
3
)
!
=
=
"
-
-
>
"
)
{
throw
new
ParsingError
(
ParsingError
.
Errors
.
BadTimeStamp
"
Malformed
time
stamp
(
time
stamps
must
be
separated
by
'
-
-
>
'
)
:
"
+
oInput
)
;
}
input
=
input
.
substr
(
3
)
;
skipWhitespace
(
)
;
cue
.
endTime
=
consumeTimeStamp
(
)
;
skipWhitespace
(
)
;
consumeCueSettings
(
input
cue
)
;
}
function
emptyOrOnlyContainsWhiteSpaces
(
input
)
{
return
input
=
=
"
"
|
|
/
^
[
\
f
\
n
\
r
\
t
]
+
/
.
test
(
input
)
;
}
function
containsTimeDirectionSymbol
(
input
)
{
return
input
.
includes
(
"
-
-
>
"
)
;
}
function
maybeIsTimeStampFormat
(
input
)
{
return
/
^
\
s
*
(
\
d
+
:
)
?
(
\
d
{
2
}
)
:
(
\
d
{
2
}
)
\
.
(
\
d
+
)
\
s
*
-
-
>
\
s
*
(
\
d
+
:
)
?
(
\
d
{
2
}
)
:
(
\
d
{
2
}
)
\
.
(
\
d
+
)
\
s
*
/
.
test
(
input
)
;
}
var
ESCAPE
=
{
"
&
amp
;
"
:
"
&
"
"
&
lt
;
"
:
"
<
"
"
&
gt
;
"
:
"
>
"
"
&
lrm
;
"
:
"
\
u200e
"
"
&
rlm
;
"
:
"
\
u200f
"
"
&
nbsp
;
"
:
"
\
u00a0
"
}
;
var
TAG_NAME
=
{
c
:
"
span
"
i
:
"
i
"
b
:
"
b
"
u
:
"
u
"
ruby
:
"
ruby
"
rt
:
"
rt
"
v
:
"
span
"
lang
:
"
span
"
}
;
var
TAG_ANNOTATION
=
{
v
:
"
title
"
lang
:
"
lang
"
}
;
var
NEEDS_PARENT
=
{
rt
:
"
ruby
"
}
;
const
PARSE_CONTENT_MODE
=
{
NORMAL_CUE
:
"
normal_cue
"
PSUEDO_CUE
:
"
pseudo_cue
"
DOCUMENT_FRAGMENT
:
"
document_fragment
"
REGION_CUE
:
"
region_cue
"
}
function
parseContent
(
window
input
mode
)
{
function
nextToken
(
)
{
if
(
!
input
)
{
return
null
;
}
function
consume
(
result
)
{
input
=
input
.
substr
(
result
.
length
)
;
return
result
;
}
var
m
=
input
.
match
(
/
^
(
[
^
<
]
*
)
(
<
[
^
>
]
+
>
?
)
?
/
)
;
if
(
!
m
[
0
]
)
{
return
null
;
}
return
consume
(
m
[
1
]
?
m
[
1
]
:
m
[
2
]
)
;
}
function
unescape1
(
e
)
{
return
ESCAPE
[
e
]
;
}
function
unescape
(
s
)
{
while
(
(
m
=
s
.
match
(
/
&
(
amp
|
lt
|
gt
|
lrm
|
rlm
|
nbsp
)
;
/
)
)
)
{
s
=
s
.
replace
(
m
[
0
]
unescape1
)
;
}
return
s
;
}
function
shouldAdd
(
current
element
)
{
return
!
NEEDS_PARENT
[
element
.
localName
]
|
|
NEEDS_PARENT
[
element
.
localName
]
=
=
=
current
.
localName
;
}
function
createElement
(
type
annotation
)
{
var
tagName
=
TAG_NAME
[
type
]
;
if
(
!
tagName
)
{
return
null
;
}
var
element
=
window
.
document
.
createElement
(
tagName
)
;
var
name
=
TAG_ANNOTATION
[
type
]
;
if
(
name
)
{
element
[
name
]
=
annotation
?
annotation
.
trim
(
)
:
"
"
;
}
return
element
;
}
function
normalizedTimeStamp
(
secondsWithFrag
)
{
var
totalsec
=
parseInt
(
secondsWithFrag
10
)
;
var
hours
=
Math
.
floor
(
totalsec
/
3600
)
;
var
minutes
=
Math
.
floor
(
totalsec
%
3600
/
60
)
;
var
seconds
=
Math
.
floor
(
totalsec
%
60
)
;
if
(
hours
<
10
)
{
hours
=
"
0
"
+
hours
;
}
if
(
minutes
<
10
)
{
minutes
=
"
0
"
+
minutes
;
}
if
(
seconds
<
10
)
{
seconds
=
"
0
"
+
seconds
;
}
var
f
=
secondsWithFrag
.
toString
(
)
.
split
(
"
.
"
)
;
if
(
f
[
1
]
)
{
f
=
f
[
1
]
.
slice
(
0
3
)
.
padEnd
(
3
"
0
"
)
;
}
else
{
f
=
"
000
"
;
}
return
hours
+
'
:
'
+
minutes
+
'
:
'
+
seconds
+
'
.
'
+
f
;
}
var
root
;
switch
(
mode
)
{
case
PARSE_CONTENT_MODE
.
PSUEDO_CUE
:
root
=
window
.
document
.
createElement
(
"
div
"
{
pseudo
:
"
:
:
cue
"
}
)
;
break
;
case
PARSE_CONTENT_MODE
.
NORMAL_CUE
:
case
PARSE_CONTENT_MODE
.
REGION_CUE
:
root
=
window
.
document
.
createElement
(
"
div
"
)
;
break
;
case
PARSE_CONTENT_MODE
.
DOCUMENT_FRAGMENT
:
root
=
window
.
document
.
createDocumentFragment
(
)
;
break
;
}
var
current
=
root
t
tagStack
=
[
]
;
while
(
(
t
=
nextToken
(
)
)
!
=
=
null
)
{
if
(
t
[
0
]
=
=
=
'
<
'
)
{
if
(
t
[
1
]
=
=
=
"
/
"
)
{
if
(
tagStack
.
length
&
&
tagStack
[
tagStack
.
length
-
1
]
=
=
=
t
.
substr
(
2
)
.
replace
(
"
>
"
"
"
)
)
{
tagStack
.
pop
(
)
;
current
=
current
.
parentNode
;
}
continue
;
}
var
ts
=
collectTimeStamp
(
t
.
substr
(
1
t
.
length
-
1
)
)
;
var
node
;
if
(
ts
)
{
node
=
window
.
document
.
createProcessingInstruction
(
"
timestamp
"
normalizedTimeStamp
(
ts
)
)
;
current
.
appendChild
(
node
)
;
continue
;
}
var
m
=
t
.
match
(
/
^
<
(
[
^
.
\
s
/
0
-
9
>
]
+
)
(
\
.
[
^
\
s
\
\
>
]
+
)
?
(
[
^
>
\
\
]
+
)
?
(
\
\
?
)
>
?
/
)
;
if
(
!
m
)
{
continue
;
}
node
=
createElement
(
m
[
1
]
m
[
3
]
)
;
if
(
!
node
)
{
continue
;
}
if
(
!
shouldAdd
(
current
node
)
)
{
continue
;
}
if
(
m
[
2
]
)
{
node
.
className
=
m
[
2
]
.
substr
(
1
)
.
replace
(
'
.
'
'
'
)
;
}
tagStack
.
push
(
m
[
1
]
)
;
current
.
appendChild
(
node
)
;
current
=
node
;
continue
;
}
current
.
appendChild
(
window
.
document
.
createTextNode
(
unescape
(
t
)
)
)
;
}
return
root
;
}
function
StyleBox
(
)
{
}
StyleBox
.
prototype
.
applyStyles
=
function
(
styles
div
)
{
div
=
div
|
|
this
.
div
;
for
(
var
prop
in
styles
)
{
if
(
styles
.
hasOwnProperty
(
prop
)
)
{
div
.
style
[
prop
]
=
styles
[
prop
]
;
}
}
}
;
StyleBox
.
prototype
.
formatStyle
=
function
(
val
unit
)
{
return
val
=
=
=
0
?
0
:
val
+
unit
;
}
;
XPCOMUtils
.
defineLazyPreferenceGetter
(
StyleBox
.
prototype
"
supportPseudo
"
"
media
.
webvtt
.
pseudo
.
enabled
"
false
)
;
function
CueStyleBox
(
window
cue
styleOptions
)
{
var
isIE8
=
(
typeof
navigator
!
=
=
"
undefined
"
)
&
&
(
/
MSIE
\
s8
\
.
0
/
)
.
test
(
navigator
.
userAgent
)
;
var
isFirefoxSupportPseudo
=
(
/
firefox
/
i
.
test
(
window
.
navigator
.
userAgent
)
)
&
&
this
.
supportPseudo
;
var
color
=
"
rgba
(
255
255
255
1
)
"
;
var
backgroundColor
=
"
rgba
(
0
0
0
0
.
8
)
"
;
if
(
isIE8
)
{
color
=
"
rgb
(
255
255
255
)
"
;
backgroundColor
=
"
rgb
(
0
0
0
)
"
;
}
StyleBox
.
call
(
this
)
;
this
.
cue
=
cue
;
if
(
isFirefoxSupportPseudo
)
{
this
.
cueDiv
=
parseContent
(
window
cue
.
text
PARSE_CONTENT_MODE
.
PSUEDO_CUE
)
;
}
else
{
this
.
cueDiv
=
parseContent
(
window
cue
.
text
PARSE_CONTENT_MODE
.
NORMAL_CUE
)
;
}
var
styles
=
{
color
:
color
backgroundColor
:
backgroundColor
display
:
"
inline
"
font
:
styleOptions
.
font
whiteSpace
:
"
pre
-
line
"
}
;
if
(
isFirefoxSupportPseudo
)
{
delete
styles
.
color
;
delete
styles
.
backgroundColor
;
delete
styles
.
font
;
delete
styles
.
whiteSpace
;
}
if
(
!
isIE8
)
{
styles
.
writingMode
=
cue
.
vertical
=
=
=
"
"
?
"
horizontal
-
tb
"
:
cue
.
vertical
=
=
=
"
lr
"
?
"
vertical
-
lr
"
:
"
vertical
-
rl
"
;
styles
.
unicodeBidi
=
"
plaintext
"
;
}
this
.
applyStyles
(
styles
this
.
cueDiv
)
;
styles
=
{
position
:
"
absolute
"
textAlign
:
cue
.
align
font
:
styleOptions
.
font
}
;
this
.
div
=
window
.
document
.
createElement
(
"
div
"
)
;
this
.
applyStyles
(
styles
)
;
this
.
div
.
appendChild
(
this
.
cueDiv
)
;
function
convertCuePostionToPercentage
(
cuePosition
)
{
if
(
cuePosition
=
=
=
"
auto
"
)
{
return
50
;
}
return
cuePosition
;
}
var
textPos
=
0
;
let
postionPercentage
=
convertCuePostionToPercentage
(
cue
.
position
)
;
switch
(
cue
.
computedPositionAlign
)
{
case
"
line
-
left
"
:
textPos
=
postionPercentage
;
break
;
case
"
center
"
:
textPos
=
postionPercentage
-
(
cue
.
size
/
2
)
;
break
;
case
"
line
-
right
"
:
textPos
=
postionPercentage
-
cue
.
size
;
break
;
}
if
(
cue
.
vertical
=
=
=
"
"
)
{
this
.
applyStyles
(
{
left
:
this
.
formatStyle
(
textPos
"
%
"
)
width
:
this
.
formatStyle
(
cue
.
size
"
%
"
)
}
)
;
}
else
{
this
.
applyStyles
(
{
top
:
this
.
formatStyle
(
textPos
"
%
"
)
height
:
this
.
formatStyle
(
cue
.
size
"
%
"
)
}
)
;
}
this
.
move
=
function
(
box
)
{
this
.
applyStyles
(
{
top
:
this
.
formatStyle
(
box
.
top
"
px
"
)
bottom
:
this
.
formatStyle
(
box
.
bottom
"
px
"
)
left
:
this
.
formatStyle
(
box
.
left
"
px
"
)
right
:
this
.
formatStyle
(
box
.
right
"
px
"
)
height
:
this
.
formatStyle
(
box
.
height
"
px
"
)
width
:
this
.
formatStyle
(
box
.
width
"
px
"
)
}
)
;
}
;
}
CueStyleBox
.
prototype
=
_objCreate
(
StyleBox
.
prototype
)
;
CueStyleBox
.
prototype
.
constructor
=
CueStyleBox
;
function
RegionNodeBox
(
window
region
container
)
{
StyleBox
.
call
(
this
)
;
var
boxLineHeight
=
container
.
height
*
0
.
0533
var
boxHeight
=
boxLineHeight
*
region
.
lines
;
var
boxWidth
=
container
.
width
*
region
.
width
/
100
;
var
regionNodeStyles
=
{
position
:
"
absolute
"
height
:
boxHeight
+
"
px
"
width
:
boxWidth
+
"
px
"
top
:
(
region
.
viewportAnchorY
*
container
.
height
/
100
)
-
(
region
.
regionAnchorY
*
boxHeight
/
100
)
+
"
px
"
left
:
(
region
.
viewportAnchorX
*
container
.
width
/
100
)
-
(
region
.
regionAnchorX
*
boxWidth
/
100
)
+
"
px
"
lineHeight
:
boxLineHeight
+
"
px
"
writingMode
:
"
horizontal
-
tb
"
backgroundColor
:
"
rgba
(
0
0
0
0
.
8
)
"
wordWrap
:
"
break
-
word
"
overflowWrap
:
"
break
-
word
"
font
:
(
boxLineHeight
/
1
.
3
)
+
"
px
sans
-
serif
"
color
:
"
rgba
(
255
255
255
1
)
"
overflow
:
"
hidden
"
minHeight
:
"
0px
"
maxHeight
:
boxHeight
+
"
px
"
display
:
"
inline
-
flex
"
flexFlow
:
"
column
"
justifyContent
:
"
flex
-
end
"
}
;
this
.
div
=
window
.
document
.
createElement
(
"
div
"
)
;
this
.
div
.
id
=
region
.
id
;
this
.
applyStyles
(
regionNodeStyles
)
;
}
RegionNodeBox
.
prototype
=
_objCreate
(
StyleBox
.
prototype
)
;
RegionNodeBox
.
prototype
.
constructor
=
RegionNodeBox
;
function
RegionCueStyleBox
(
window
cue
)
{
StyleBox
.
call
(
this
)
;
this
.
cueDiv
=
parseContent
(
window
cue
.
text
PARSE_CONTENT_MODE
.
REGION_CUE
)
;
var
regionCueStyles
=
{
position
:
"
relative
"
writingMode
:
"
horizontal
-
tb
"
unicodeBidi
:
"
plaintext
"
width
:
"
auto
"
height
:
"
auto
"
textAlign
:
cue
.
align
}
;
var
offset
=
cue
.
computedPosition
*
cue
.
region
.
width
/
100
;
switch
(
cue
.
align
)
{
case
"
start
"
:
case
"
left
"
:
regionCueStyles
.
left
=
offset
+
"
%
"
;
regionCueStyles
.
right
=
"
auto
"
;
break
;
case
"
end
"
:
case
"
right
"
:
regionCueStyles
.
left
=
"
auto
"
;
regionCueStyles
.
right
=
offset
+
"
%
"
;
break
;
case
"
middle
"
:
break
;
}
this
.
div
=
window
.
document
.
createElement
(
"
div
"
)
;
this
.
applyStyles
(
regionCueStyles
)
;
this
.
div
.
appendChild
(
this
.
cueDiv
)
;
}
RegionCueStyleBox
.
prototype
=
_objCreate
(
StyleBox
.
prototype
)
;
RegionCueStyleBox
.
prototype
.
constructor
=
RegionCueStyleBox
;
function
BoxPosition
(
obj
)
{
var
isIE8
=
(
typeof
navigator
!
=
=
"
undefined
"
)
&
&
(
/
MSIE
\
s8
\
.
0
/
)
.
test
(
navigator
.
userAgent
)
;
var
lh
height
width
top
;
if
(
obj
.
div
)
{
height
=
obj
.
div
.
offsetHeight
;
width
=
obj
.
div
.
offsetWidth
;
top
=
obj
.
div
.
offsetTop
;
var
rects
=
(
rects
=
obj
.
div
.
childNodes
)
&
&
(
rects
=
rects
[
0
]
)
&
&
rects
.
getClientRects
&
&
rects
.
getClientRects
(
)
;
obj
=
obj
.
div
.
getBoundingClientRect
(
)
;
lh
=
rects
?
Math
.
max
(
(
rects
[
0
]
&
&
rects
[
0
]
.
height
)
|
|
0
obj
.
height
/
rects
.
length
)
:
0
;
}
this
.
left
=
obj
.
left
;
this
.
right
=
obj
.
right
;
this
.
top
=
obj
.
top
|
|
top
;
this
.
height
=
obj
.
height
|
|
height
;
this
.
bottom
=
obj
.
bottom
|
|
(
top
+
(
obj
.
height
|
|
height
)
)
;
this
.
width
=
obj
.
width
|
|
width
;
this
.
lineHeight
=
lh
!
=
=
undefined
?
lh
:
obj
.
lineHeight
;
if
(
isIE8
&
&
!
this
.
lineHeight
)
{
this
.
lineHeight
=
13
;
}
}
BoxPosition
.
prototype
.
move
=
function
(
axis
toMove
)
{
toMove
=
toMove
!
=
=
undefined
?
toMove
:
this
.
lineHeight
;
switch
(
axis
)
{
case
"
+
x
"
:
this
.
left
+
=
toMove
;
this
.
right
+
=
toMove
;
break
;
case
"
-
x
"
:
this
.
left
-
=
toMove
;
this
.
right
-
=
toMove
;
break
;
case
"
+
y
"
:
this
.
top
+
=
toMove
;
this
.
bottom
+
=
toMove
;
break
;
case
"
-
y
"
:
this
.
top
-
=
toMove
;
this
.
bottom
-
=
toMove
;
break
;
}
}
;
BoxPosition
.
prototype
.
overlaps
=
function
(
b2
)
{
return
this
.
left
<
b2
.
right
&
&
this
.
right
>
b2
.
left
&
&
this
.
top
<
b2
.
bottom
&
&
this
.
bottom
>
b2
.
top
;
}
;
BoxPosition
.
prototype
.
overlapsAny
=
function
(
boxes
)
{
for
(
var
i
=
0
;
i
<
boxes
.
length
;
i
+
+
)
{
if
(
this
.
overlaps
(
boxes
[
i
]
)
)
{
return
true
;
}
}
return
false
;
}
;
BoxPosition
.
prototype
.
within
=
function
(
container
)
{
return
this
.
top
>
=
container
.
top
&
&
this
.
bottom
<
=
container
.
bottom
&
&
this
.
left
>
=
container
.
left
&
&
this
.
right
<
=
container
.
right
;
}
;
BoxPosition
.
prototype
.
overlapsOppositeAxis
=
function
(
container
axis
)
{
switch
(
axis
)
{
case
"
+
x
"
:
return
this
.
left
<
container
.
left
;
case
"
-
x
"
:
return
this
.
right
>
container
.
right
;
case
"
+
y
"
:
return
this
.
top
<
container
.
top
;
case
"
-
y
"
:
return
this
.
bottom
>
container
.
bottom
;
}
}
;
BoxPosition
.
prototype
.
intersectPercentage
=
function
(
b2
)
{
var
x
=
Math
.
max
(
0
Math
.
min
(
this
.
right
b2
.
right
)
-
Math
.
max
(
this
.
left
b2
.
left
)
)
y
=
Math
.
max
(
0
Math
.
min
(
this
.
bottom
b2
.
bottom
)
-
Math
.
max
(
this
.
top
b2
.
top
)
)
intersectArea
=
x
*
y
;
return
intersectArea
/
(
this
.
height
*
this
.
width
)
;
}
;
BoxPosition
.
prototype
.
toCSSCompatValues
=
function
(
reference
)
{
return
{
top
:
this
.
top
-
reference
.
top
bottom
:
reference
.
bottom
-
this
.
bottom
left
:
this
.
left
-
reference
.
left
right
:
reference
.
right
-
this
.
right
height
:
this
.
height
width
:
this
.
width
}
;
}
;
BoxPosition
.
getSimpleBoxPosition
=
function
(
obj
)
{
var
height
=
obj
.
div
?
obj
.
div
.
offsetHeight
:
obj
.
tagName
?
obj
.
offsetHeight
:
0
;
var
width
=
obj
.
div
?
obj
.
div
.
offsetWidth
:
obj
.
tagName
?
obj
.
offsetWidth
:
0
;
var
top
=
obj
.
div
?
obj
.
div
.
offsetTop
:
obj
.
tagName
?
obj
.
offsetTop
:
0
;
obj
=
obj
.
div
?
obj
.
div
.
getBoundingClientRect
(
)
:
obj
.
tagName
?
obj
.
getBoundingClientRect
(
)
:
obj
;
var
ret
=
{
left
:
obj
.
left
right
:
obj
.
right
top
:
obj
.
top
|
|
top
height
:
obj
.
height
|
|
height
bottom
:
obj
.
bottom
|
|
(
top
+
(
obj
.
height
|
|
height
)
)
width
:
obj
.
width
|
|
width
}
;
return
ret
;
}
;
function
moveBoxToLinePosition
(
window
styleBox
containerBox
boxPositions
)
{
function
findBestPosition
(
b
axis
)
{
var
bestPosition
specifiedPosition
=
new
BoxPosition
(
b
)
percentage
=
1
;
for
(
var
i
=
0
;
i
<
axis
.
length
;
i
+
+
)
{
while
(
b
.
overlapsOppositeAxis
(
containerBox
axis
[
i
]
)
|
|
(
b
.
within
(
containerBox
)
&
&
b
.
overlapsAny
(
boxPositions
)
)
)
{
b
.
move
(
axis
[
i
]
)
;
}
if
(
b
.
within
(
containerBox
)
)
{
return
b
;
}
var
p
=
b
.
intersectPercentage
(
containerBox
)
;
if
(
percentage
>
p
)
{
bestPosition
=
new
BoxPosition
(
b
)
;
percentage
=
p
;
}
b
=
new
BoxPosition
(
specifiedPosition
)
;
}
return
bestPosition
|
|
specifiedPosition
;
}
var
boxPosition
=
new
BoxPosition
(
styleBox
)
cue
=
styleBox
.
cue
linePos
=
cue
.
computedLine
axis
=
[
]
;
if
(
cue
.
snapToLines
)
{
var
size
;
switch
(
cue
.
vertical
)
{
case
"
"
:
axis
=
[
"
+
y
"
"
-
y
"
]
;
size
=
"
height
"
;
break
;
case
"
rl
"
:
axis
=
[
"
+
x
"
"
-
x
"
]
;
size
=
"
width
"
;
break
;
case
"
lr
"
:
axis
=
[
"
-
x
"
"
+
x
"
]
;
size
=
"
width
"
;
break
;
}
var
step
=
boxPosition
.
lineHeight
position
=
step
*
Math
.
round
(
linePos
)
maxPosition
=
containerBox
[
size
]
+
step
initialAxis
=
axis
[
0
]
;
if
(
step
=
=
0
)
{
return
;
}
if
(
Math
.
abs
(
position
)
>
maxPosition
)
{
position
=
position
<
0
?
-
1
:
1
;
position
*
=
Math
.
ceil
(
maxPosition
/
step
)
*
step
;
}
if
(
linePos
<
0
)
{
position
+
=
cue
.
vertical
=
=
=
"
"
?
containerBox
.
height
:
containerBox
.
width
;
axis
=
axis
.
reverse
(
)
;
}
boxPosition
.
move
(
initialAxis
position
)
;
}
else
{
var
calculatedPercentage
=
(
boxPosition
.
lineHeight
/
containerBox
.
height
)
*
100
;
switch
(
cue
.
lineAlign
)
{
case
"
center
"
:
linePos
-
=
(
calculatedPercentage
/
2
)
;
break
;
case
"
end
"
:
linePos
-
=
calculatedPercentage
;
break
;
}
switch
(
cue
.
vertical
)
{
case
"
"
:
styleBox
.
applyStyles
(
{
top
:
styleBox
.
formatStyle
(
linePos
"
%
"
)
}
)
;
break
;
case
"
rl
"
:
styleBox
.
applyStyles
(
{
left
:
styleBox
.
formatStyle
(
linePos
"
%
"
)
}
)
;
break
;
case
"
lr
"
:
styleBox
.
applyStyles
(
{
right
:
styleBox
.
formatStyle
(
linePos
"
%
"
)
}
)
;
break
;
}
axis
=
[
"
+
y
"
"
-
x
"
"
+
x
"
"
-
y
"
]
;
boxPosition
=
new
BoxPosition
(
styleBox
)
;
}
var
bestPosition
=
findBestPosition
(
boxPosition
axis
)
;
styleBox
.
move
(
bestPosition
.
toCSSCompatValues
(
containerBox
)
)
;
}
function
WebVTT
(
)
{
}
WebVTT
.
StringDecoder
=
function
(
)
{
return
{
decode
:
function
(
data
)
{
if
(
!
data
)
{
return
"
"
;
}
if
(
typeof
data
!
=
=
"
string
"
)
{
throw
new
Error
(
"
Error
-
expected
string
data
.
"
)
;
}
return
decodeURIComponent
(
encodeURIComponent
(
data
)
)
;
}
}
;
}
;
WebVTT
.
convertCueToDOMTree
=
function
(
window
cuetext
)
{
if
(
!
window
)
{
return
null
;
}
return
parseContent
(
window
cuetext
PARSE_CONTENT_MODE
.
DOCUMENT_FRAGMENT
)
;
}
;
var
FONT_SIZE_PERCENT
=
0
.
05
;
var
FONT_STYLE
=
"
sans
-
serif
"
;
WebVTT
.
processCues
=
function
(
window
cues
overlay
controls
)
{
if
(
!
window
|
|
!
cues
|
|
!
overlay
)
{
return
null
;
}
var
controlBar
;
var
controlBarShown
;
if
(
controls
)
{
controlBar
=
controls
.
parentNode
.
getElementById
(
"
controlBar
"
)
;
controlBarShown
=
controlBar
?
!
!
controlBar
.
clientHeight
:
false
;
}
else
{
controlBarShown
=
false
;
}
function
shouldCompute
(
cues
)
{
if
(
overlay
.
lastControlBarShownStatus
!
=
controlBarShown
)
{
return
true
;
}
for
(
var
i
=
0
;
i
<
cues
.
length
;
i
+
+
)
{
if
(
cues
[
i
]
.
hasBeenReset
|
|
!
cues
[
i
]
.
displayState
)
{
return
true
;
}
}
return
false
;
}
if
(
!
shouldCompute
(
cues
)
)
{
return
;
}
overlay
.
lastControlBarShownStatus
=
controlBarShown
;
while
(
overlay
.
firstChild
)
{
overlay
.
firstChild
.
remove
(
)
;
}
var
rootOfCues
=
window
.
document
.
createElement
(
"
div
"
)
;
rootOfCues
.
style
.
position
=
"
absolute
"
;
rootOfCues
.
style
.
left
=
"
0
"
;
rootOfCues
.
style
.
right
=
"
0
"
;
rootOfCues
.
style
.
top
=
"
0
"
;
rootOfCues
.
style
.
bottom
=
"
0
"
;
overlay
.
appendChild
(
rootOfCues
)
;
var
boxPositions
=
[
]
containerBox
=
BoxPosition
.
getSimpleBoxPosition
(
rootOfCues
)
fontSize
=
Math
.
round
(
containerBox
.
height
*
FONT_SIZE_PERCENT
*
100
)
/
100
;
var
styleOptions
=
{
font
:
fontSize
+
"
px
"
+
FONT_STYLE
}
;
(
function
(
)
{
var
styleBox
cue
controlBarBox
;
if
(
controlBarShown
)
{
controlBarBox
=
BoxPosition
.
getSimpleBoxPosition
(
controlBar
)
;
boxPositions
.
push
(
controlBarBox
)
;
}
var
regionNodeBoxes
=
{
}
;
var
regionNodeBox
;
for
(
var
i
=
0
;
i
<
cues
.
length
;
i
+
+
)
{
cue
=
cues
[
i
]
;
if
(
cue
.
region
!
=
null
)
{
styleBox
=
new
RegionCueStyleBox
(
window
cue
)
;
if
(
!
regionNodeBoxes
[
cue
.
region
.
id
]
)
{
var
adjustContainerBox
=
BoxPosition
.
getSimpleBoxPosition
(
rootOfCues
)
;
if
(
controlBarShown
)
{
adjustContainerBox
.
height
-
=
controlBarBox
.
height
;
adjustContainerBox
.
bottom
+
=
controlBarBox
.
height
;
}
regionNodeBox
=
new
RegionNodeBox
(
window
cue
.
region
adjustContainerBox
)
;
regionNodeBoxes
[
cue
.
region
.
id
]
=
regionNodeBox
;
}
var
currentRegionBox
=
regionNodeBoxes
[
cue
.
region
.
id
]
;
var
currentRegionNodeDiv
=
currentRegionBox
.
div
;
if
(
cue
.
region
.
scroll
=
=
"
up
"
&
&
currentRegionNodeDiv
.
childElementCount
>
0
)
{
styleBox
.
div
.
style
.
transitionProperty
=
"
top
"
;
styleBox
.
div
.
style
.
transitionDuration
=
"
0
.
433s
"
;
}
currentRegionNodeDiv
.
appendChild
(
styleBox
.
div
)
;
rootOfCues
.
appendChild
(
currentRegionNodeDiv
)
;
cue
.
displayState
=
styleBox
.
div
;
boxPositions
.
push
(
BoxPosition
.
getSimpleBoxPosition
(
currentRegionBox
)
)
;
}
else
{
styleBox
=
new
CueStyleBox
(
window
cue
styleOptions
)
;
styleBox
.
cueDiv
.
style
.
setProperty
(
"
-
-
cue
-
font
-
size
"
fontSize
+
"
px
"
)
;
rootOfCues
.
appendChild
(
styleBox
.
div
)
;
moveBoxToLinePosition
(
window
styleBox
containerBox
boxPositions
)
;
cue
.
displayState
=
styleBox
.
div
;
boxPositions
.
push
(
BoxPosition
.
getSimpleBoxPosition
(
styleBox
)
)
;
}
}
}
)
(
)
;
}
;
WebVTT
.
Parser
=
function
(
window
decoder
)
{
this
.
window
=
window
;
this
.
state
=
"
INITIAL
"
;
this
.
substate
=
"
"
;
this
.
substatebuffer
=
"
"
;
this
.
buffer
=
"
"
;
this
.
decoder
=
decoder
|
|
new
TextDecoder
(
"
utf8
"
)
;
this
.
regionList
=
[
]
;
}
;
WebVTT
.
Parser
.
prototype
=
{
reportOrThrowError
:
function
(
e
)
{
if
(
e
instanceof
ParsingError
)
{
this
.
onparsingerror
&
&
this
.
onparsingerror
(
e
)
;
}
else
{
throw
e
;
}
}
parse
:
function
(
data
)
{
if
(
data
)
{
this
.
buffer
+
=
this
.
decoder
.
decode
(
data
{
stream
:
true
}
)
;
}
while
(
/
\
r
\
n
|
\
n
|
\
r
/
.
test
(
this
.
buffer
)
)
{
var
buffer
=
this
.
buffer
;
var
pos
=
0
;
while
(
buffer
[
pos
]
!
=
=
'
\
r
'
&
&
buffer
[
pos
]
!
=
=
'
\
n
'
)
{
+
+
pos
;
}
var
line
=
buffer
.
substr
(
0
pos
)
;
if
(
buffer
[
pos
]
=
=
=
'
\
r
'
)
{
+
+
pos
;
}
if
(
buffer
[
pos
]
=
=
=
'
\
n
'
)
{
+
+
pos
;
}
this
.
buffer
=
buffer
.
substr
(
pos
)
;
line
=
line
.
replace
(
/
[
\
u0000
]
/
g
"
\
uFFFD
"
)
;
if
(
!
/
^
NOTE
(
|
[
\
t
]
)
/
.
test
(
line
)
)
{
this
.
parseLine
(
line
)
;
}
}
return
this
;
}
parseLine
:
function
(
line
)
{
var
self
=
this
;
function
createCueIfNeeded
(
)
{
if
(
!
self
.
cue
)
{
self
.
cue
=
new
self
.
window
.
VTTCue
(
0
0
"
"
)
;
}
}
function
parseCueIdentifier
(
input
)
{
if
(
maybeIsTimeStampFormat
(
input
)
)
{
self
.
state
=
"
CUE
"
;
return
false
;
}
createCueIfNeeded
(
)
;
self
.
cue
.
id
=
containsTimeDirectionSymbol
(
input
)
?
"
"
:
input
;
self
.
state
=
"
CUE
"
;
return
true
;
}
function
parseCueMayThrow
(
input
)
{
try
{
createCueIfNeeded
(
)
;
parseCue
(
input
self
.
cue
self
.
regionList
)
;
self
.
state
=
"
CUETEXT
"
;
}
catch
(
e
)
{
self
.
reportOrThrowError
(
e
)
;
self
.
cue
=
null
;
self
.
state
=
"
BADCUE
"
;
}
}
function
parseRegion
(
input
)
{
var
settings
=
new
Settings
(
)
;
parseOptions
(
input
function
(
k
v
)
{
switch
(
k
)
{
case
"
id
"
:
settings
.
set
(
k
v
)
;
break
;
case
"
width
"
:
settings
.
percent
(
k
v
)
;
break
;
case
"
lines
"
:
settings
.
digitsValue
(
k
v
)
;
break
;
case
"
regionanchor
"
:
case
"
viewportanchor
"
:
var
xy
=
v
.
split
(
'
'
)
;
if
(
xy
.
length
!
=
=
2
)
{
break
;
}
var
anchor
=
new
Settings
(
)
;
anchor
.
percent
(
"
x
"
xy
[
0
]
)
;
anchor
.
percent
(
"
y
"
xy
[
1
]
)
;
if
(
!
anchor
.
has
(
"
x
"
)
|
|
!
anchor
.
has
(
"
y
"
)
)
{
break
;
}
settings
.
set
(
k
+
"
X
"
anchor
.
get
(
"
x
"
)
)
;
settings
.
set
(
k
+
"
Y
"
anchor
.
get
(
"
y
"
)
)
;
break
;
case
"
scroll
"
:
settings
.
alt
(
k
v
[
"
up
"
]
)
;
break
;
}
}
/
:
/
/
\
t
|
\
n
|
\
f
|
\
r
|
/
)
;
if
(
settings
.
has
(
"
id
"
)
)
{
try
{
var
region
=
new
self
.
window
.
VTTRegion
(
)
;
region
.
id
=
settings
.
get
(
"
id
"
"
"
)
;
region
.
width
=
settings
.
get
(
"
width
"
100
)
;
region
.
lines
=
settings
.
get
(
"
lines
"
3
)
;
region
.
regionAnchorX
=
settings
.
get
(
"
regionanchorX
"
0
)
;
region
.
regionAnchorY
=
settings
.
get
(
"
regionanchorY
"
100
)
;
region
.
viewportAnchorX
=
settings
.
get
(
"
viewportanchorX
"
0
)
;
region
.
viewportAnchorY
=
settings
.
get
(
"
viewportanchorY
"
100
)
;
region
.
scroll
=
settings
.
get
(
"
scroll
"
"
"
)
;
self
.
onregion
&
&
self
.
onregion
(
region
)
;
self
.
regionList
.
push
(
{
id
:
settings
.
get
(
"
id
"
)
region
:
region
}
)
;
}
catch
(
e
)
{
dump
(
"
VTTRegion
Error
"
+
e
+
"
\
n
"
)
;
var
regionPref
=
Services
.
prefs
.
getBoolPref
(
"
media
.
webvtt
.
regions
.
enabled
"
)
;
dump
(
"
regionPref
"
+
regionPref
+
"
\
n
"
)
;
}
}
}
function
parseSignatureMayThrow
(
signature
)
{
if
(
!
/
^
WEBVTT
(
[
\
t
]
.
*
)
?
/
.
test
(
signature
)
)
{
throw
new
ParsingError
(
ParsingError
.
Errors
.
BadSignature
)
;
}
else
{
self
.
state
=
"
HEADER
"
;
}
}
function
parseRegionOrStyle
(
input
)
{
switch
(
self
.
substate
)
{
case
"
REGION
"
:
parseRegion
(
input
)
;
break
;
case
"
STYLE
"
:
break
;
}
}
function
parseHeader
(
line
)
{
if
(
!
self
.
substate
&
&
/
^
REGION
|
^
STYLE
/
.
test
(
line
)
)
{
self
.
substate
=
/
^
REGION
/
.
test
(
line
)
?
"
REGION
"
:
"
STYLE
"
;
return
false
;
}
if
(
self
.
substate
=
=
=
"
REGION
"
|
|
self
.
substate
=
=
=
"
STYLE
"
)
{
if
(
maybeIsTimeStampFormat
(
line
)
|
|
emptyOrOnlyContainsWhiteSpaces
(
line
)
|
|
containsTimeDirectionSymbol
(
line
)
)
{
parseRegionOrStyle
(
self
.
substatebuffer
)
;
self
.
substatebuffer
=
"
"
;
self
.
substate
=
null
;
return
parseHeader
(
line
)
;
}
if
(
/
^
REGION
|
^
STYLE
/
.
test
(
line
)
)
{
parseRegionOrStyle
(
self
.
substatebuffer
)
;
self
.
substatebuffer
=
"
"
;
self
.
substate
=
/
^
REGION
/
.
test
(
line
)
?
"
REGION
"
:
"
STYLE
"
;
return
false
;
}
self
.
substatebuffer
+
=
"
"
+
line
;
return
false
;
}
if
(
emptyOrOnlyContainsWhiteSpaces
(
line
)
)
{
return
false
;
}
if
(
maybeIsTimeStampFormat
(
line
)
)
{
self
.
state
=
"
CUE
"
;
return
true
;
}
self
.
state
=
"
ID
"
;
return
true
;
}
try
{
if
(
self
.
state
=
=
=
"
INITIAL
"
)
{
parseSignatureMayThrow
(
line
)
;
return
;
}
if
(
self
.
state
=
=
=
"
HEADER
"
)
{
if
(
!
parseHeader
(
line
)
)
{
return
;
}
}
if
(
self
.
state
=
=
=
"
ID
"
)
{
if
(
line
=
=
"
"
)
{
return
;
}
if
(
!
parseCueIdentifier
(
line
)
)
{
return
self
.
parseLine
(
line
)
;
}
return
;
}
if
(
self
.
state
=
=
=
"
CUE
"
)
{
parseCueMayThrow
(
line
)
;
return
;
}
if
(
self
.
state
=
=
=
"
CUETEXT
"
)
{
if
(
emptyOrOnlyContainsWhiteSpaces
(
line
)
|
|
containsTimeDirectionSymbol
(
line
)
)
{
self
.
oncue
&
&
self
.
oncue
(
self
.
cue
)
;
self
.
cue
=
null
;
self
.
state
=
"
ID
"
;
if
(
emptyOrOnlyContainsWhiteSpaces
(
line
)
)
{
return
;
}
return
self
.
parseLine
(
line
)
;
}
if
(
self
.
cue
.
text
)
{
self
.
cue
.
text
+
=
"
\
n
"
;
}
self
.
cue
.
text
+
=
line
;
return
;
}
if
(
self
.
state
=
=
=
"
BADCUE
"
)
{
self
.
state
=
"
ID
"
;
return
self
.
parseLine
(
line
)
;
}
}
catch
(
e
)
{
self
.
reportOrThrowError
(
e
)
;
if
(
self
.
state
=
=
=
"
CUETEXT
"
&
&
self
.
cue
&
&
self
.
oncue
)
{
self
.
oncue
(
self
.
cue
)
;
}
self
.
cue
=
null
;
self
.
state
=
self
.
state
=
=
=
"
INITIAL
"
?
"
BADWEBVTT
"
:
"
BADCUE
"
;
}
return
this
;
}
flush
:
function
(
)
{
var
self
=
this
;
try
{
self
.
buffer
+
=
self
.
decoder
.
decode
(
)
;
self
.
buffer
+
=
"
\
n
\
n
"
;
self
.
parse
(
)
;
}
catch
(
e
)
{
self
.
reportOrThrowError
(
e
)
;
}
self
.
onflush
&
&
self
.
onflush
(
)
;
return
this
;
}
}
;
global
.
WebVTT
=
WebVTT
;
}
(
this
)
)
;
