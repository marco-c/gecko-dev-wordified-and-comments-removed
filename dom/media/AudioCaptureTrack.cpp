#
include
"
MediaTrackGraph
.
h
"
#
include
"
MediaTrackListener
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
AudioCaptureTrack
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeTrack
.
h
"
#
include
"
AudioNodeExternalInputTrack
.
h
"
#
include
"
webaudio
/
MediaStreamAudioDestinationNode
.
h
"
#
include
<
algorithm
>
#
include
"
DOMMediaStream
.
h
"
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
static
const
uint32_t
MONO
=
1
;
AudioCaptureTrack
:
:
AudioCaptureTrack
(
TrackRate
aRate
)
:
ProcessedMediaTrack
(
aRate
MediaSegment
:
:
AUDIO
new
AudioSegment
(
)
)
mStarted
(
false
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_COUNT_CTOR
(
AudioCaptureTrack
)
;
}
AudioCaptureTrack
:
:
~
AudioCaptureTrack
(
)
{
MOZ_COUNT_DTOR
(
AudioCaptureTrack
)
;
}
void
AudioCaptureTrack
:
:
Start
(
)
{
QueueControlMessageWithNoShutdown
(
[
self
=
RefPtr
{
this
}
this
]
{
mStarted
=
true
;
}
)
;
}
void
AudioCaptureTrack
:
:
ProcessInput
(
GraphTime
aFrom
GraphTime
aTo
uint32_t
aFlags
)
{
if
(
!
mStarted
)
{
return
;
}
uint32_t
inputCount
=
mInputs
.
Length
(
)
;
if
(
mEnded
)
{
return
;
}
if
(
InMutedCycle
(
)
|
|
inputCount
=
=
0
)
{
GetData
<
AudioSegment
>
(
)
-
>
AppendNullData
(
aTo
-
aFrom
)
;
}
else
{
mMixer
.
StartMixing
(
)
;
AudioSegment
output
;
for
(
uint32_t
i
=
0
;
i
<
inputCount
;
i
+
+
)
{
MediaTrack
*
s
=
mInputs
[
i
]
-
>
GetSource
(
)
;
AudioSegment
*
inputSegment
=
s
-
>
GetData
<
AudioSegment
>
(
)
;
TrackTime
inputStart
=
s
-
>
GraphTimeToTrackTimeWithBlocking
(
aFrom
)
;
TrackTime
inputEnd
=
s
-
>
GraphTimeToTrackTimeWithBlocking
(
aTo
)
;
AudioSegment
toMix
;
if
(
s
-
>
Ended
(
)
&
&
inputSegment
-
>
GetDuration
(
)
<
=
inputStart
)
{
toMix
.
AppendNullData
(
aTo
-
aFrom
)
;
}
else
{
toMix
.
AppendSlice
(
*
inputSegment
inputStart
inputEnd
)
;
if
(
inputEnd
-
inputStart
<
aTo
-
aFrom
)
{
toMix
.
AppendNullData
(
(
aTo
-
aFrom
)
-
(
inputEnd
-
inputStart
)
)
;
}
}
toMix
.
Mix
(
mMixer
MONO
Graph
(
)
-
>
GraphRate
(
)
)
;
}
AudioChunk
*
mixed
=
mMixer
.
MixedChunk
(
)
;
MOZ_ASSERT
(
mixed
-
>
ChannelCount
(
)
=
=
MONO
)
;
GetData
<
AudioSegment
>
(
)
-
>
AppendAndConsumeChunk
(
std
:
:
move
(
*
mixed
)
)
;
}
}
uint32_t
AudioCaptureTrack
:
:
NumberOfChannels
(
)
const
{
return
GetData
<
AudioSegment
>
(
)
-
>
MaxChannelCount
(
)
;
}
}
