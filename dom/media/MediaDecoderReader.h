#
if
!
defined
(
MediaDecoderReader_h_
)
#
define
MediaDecoderReader_h_
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
AbstractMediaDecoder
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaQueue
.
h
"
#
include
"
MediaTimer
.
h
"
#
include
"
AudioCompactor
.
h
"
#
include
"
Intervals
.
h
"
#
include
"
TimeUnits
.
h
"
namespace
mozilla
{
class
CDMProxy
;
class
MediaDecoderReader
;
struct
WaitForDataRejectValue
{
enum
Reason
{
SHUTDOWN
CANCELED
}
;
WaitForDataRejectValue
(
MediaData
:
:
Type
aType
Reason
aReason
)
:
mType
(
aType
)
mReason
(
aReason
)
{
}
MediaData
:
:
Type
mType
;
Reason
mReason
;
}
;
class
MetadataHolder
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MetadataHolder
)
MediaInfo
mInfo
;
nsAutoPtr
<
MetadataTags
>
mTags
;
private
:
virtual
~
MetadataHolder
(
)
{
}
}
;
enum
class
ReadMetadataFailureReason
:
int8_t
{
METADATA_ERROR
}
;
class
MediaDecoderReader
{
public
:
enum
NotDecodedReason
{
END_OF_STREAM
DECODE_ERROR
WAITING_FOR_DATA
CANCELED
}
;
typedef
MozPromise
<
RefPtr
<
MetadataHolder
>
ReadMetadataFailureReason
true
>
MetadataPromise
;
typedef
MozPromise
<
RefPtr
<
MediaData
>
NotDecodedReason
true
>
AudioDataPromise
;
typedef
MozPromise
<
RefPtr
<
MediaData
>
NotDecodedReason
true
>
VideoDataPromise
;
typedef
MozPromise
<
int64_t
nsresult
true
>
SeekPromise
;
typedef
MozPromise
<
MediaData
:
:
Type
WaitForDataRejectValue
true
>
WaitForDataPromise
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDecoderReader
)
explicit
MediaDecoderReader
(
AbstractMediaDecoder
*
aDecoder
)
;
void
InitializationTask
(
)
;
virtual
nsresult
Init
(
)
{
return
NS_OK
;
}
virtual
void
ReleaseMediaResources
(
)
{
}
;
virtual
void
BreakCycles
(
)
;
virtual
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
;
virtual
bool
OnTaskQueue
(
)
const
{
return
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
;
}
virtual
nsresult
ResetDecode
(
)
;
virtual
RefPtr
<
AudioDataPromise
>
RequestAudioData
(
)
;
virtual
RefPtr
<
VideoDataPromise
>
RequestVideoData
(
bool
aSkipToNextKeyframe
int64_t
aTimeThreshold
)
;
friend
class
ReRequestVideoWithSkipTask
;
friend
class
ReRequestAudioTask
;
virtual
bool
IsWaitForDataSupported
(
)
{
return
false
;
}
virtual
RefPtr
<
WaitForDataPromise
>
WaitForData
(
MediaData
:
:
Type
aType
)
{
MOZ_CRASH
(
)
;
}
virtual
bool
IsDemuxOnlySupported
(
)
const
{
return
false
;
}
virtual
void
SetDemuxOnly
(
bool
)
{
}
virtual
bool
HasAudio
(
)
=
0
;
virtual
bool
HasVideo
(
)
=
0
;
virtual
RefPtr
<
MetadataPromise
>
AsyncReadMetadata
(
)
;
virtual
nsresult
ReadMetadata
(
MediaInfo
*
aInfo
MetadataTags
*
*
aTags
)
{
MOZ_CRASH
(
)
;
}
virtual
void
ReadUpdatedMetadata
(
MediaInfo
*
aInfo
)
{
}
;
virtual
RefPtr
<
SeekPromise
>
Seek
(
int64_t
aTime
int64_t
aEndTime
)
=
0
;
virtual
void
SetIdle
(
)
{
}
#
ifdef
MOZ_EME
virtual
void
SetCDMProxy
(
CDMProxy
*
aProxy
)
{
}
#
endif
void
SetIgnoreAudioOutputFormat
(
)
{
mIgnoreAudioOutputFormat
=
true
;
}
virtual
media
:
:
TimeIntervals
GetBuffered
(
)
;
virtual
void
UpdateBuffered
(
)
;
virtual
bool
ForceZeroStartTime
(
)
const
{
return
false
;
}
virtual
bool
UseBufferingHeuristics
(
)
{
return
true
;
}
size_t
SizeOfVideoQueueInBytes
(
)
const
;
size_t
SizeOfAudioQueueInBytes
(
)
const
;
virtual
size_t
SizeOfVideoQueueInFrames
(
)
;
virtual
size_t
SizeOfAudioQueueInFrames
(
)
;
protected
:
friend
class
TrackBuffer
;
virtual
void
NotifyDataArrivedInternal
(
uint32_t
aLength
int64_t
aOffset
)
{
}
void
NotifyDataArrived
(
const
media
:
:
Interval
<
int64_t
>
&
aInfo
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
NS_ENSURE_TRUE_VOID
(
!
mShutdown
)
;
NotifyDataArrivedInternal
(
aInfo
.
Length
(
)
aInfo
.
mStart
)
;
UpdateBuffered
(
)
;
}
void
ThrottledNotifyDataArrived
(
const
media
:
:
Interval
<
int64_t
>
&
aInterval
)
;
void
DoThrottledNotify
(
)
;
public
:
void
DispatchNotifyDataArrived
(
uint32_t
aLength
int64_t
aOffset
bool
aThrottleUpdates
)
{
RefPtr
<
nsRunnable
>
r
=
NS_NewRunnableMethodWithArg
<
media
:
:
Interval
<
int64_t
>
>
(
this
aThrottleUpdates
?
&
MediaDecoderReader
:
:
ThrottledNotifyDataArrived
:
&
MediaDecoderReader
:
:
NotifyDataArrived
media
:
:
Interval
<
int64_t
>
(
aOffset
aOffset
+
aLength
)
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
AbstractThread
:
:
DontAssertDispatchSuccess
)
;
}
virtual
void
NotifyDataRemoved
(
)
{
}
virtual
MediaQueue
<
AudioData
>
&
AudioQueue
(
)
{
return
mAudioQueue
;
}
virtual
MediaQueue
<
VideoData
>
&
VideoQueue
(
)
{
return
mVideoQueue
;
}
AbstractMediaDecoder
*
GetDecoder
(
)
{
return
mDecoder
;
}
RefPtr
<
VideoDataPromise
>
DecodeToFirstVideoData
(
)
;
MediaInfo
GetMediaInfo
(
)
{
return
mInfo
;
}
virtual
bool
IsMediaSeekable
(
)
=
0
;
void
DispatchSetStartTime
(
int64_t
aStartTime
)
{
RefPtr
<
MediaDecoderReader
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
self
aStartTime
]
(
)
-
>
void
{
MOZ_ASSERT
(
self
-
>
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
!
self
-
>
HaveStartTime
(
)
)
;
self
-
>
mStartTime
.
emplace
(
aStartTime
)
;
self
-
>
UpdateBuffered
(
)
;
}
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
TaskQueue
*
OwnerThread
(
)
const
{
return
mTaskQueue
;
}
virtual
bool
IsAsync
(
)
const
{
return
false
;
}
virtual
bool
VideoIsHardwareAccelerated
(
)
const
{
return
false
;
}
virtual
void
DisableHardwareAcceleration
(
)
{
}
TimedMetadataEventSource
&
TimedMetadataEvent
(
)
{
return
mTimedMetadataEvent
;
}
protected
:
virtual
~
MediaDecoderReader
(
)
;
virtual
bool
DecodeAudioData
(
)
{
return
false
;
}
virtual
bool
DecodeVideoFrame
(
bool
&
aKeyframeSkip
int64_t
aTimeThreshold
)
{
return
false
;
}
MediaQueue
<
AudioData
>
mAudioQueue
;
MediaQueue
<
VideoData
>
mVideoQueue
;
AudioCompactor
mAudioCompactor
;
AbstractMediaDecoder
*
mDecoder
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
WatchManager
<
MediaDecoderReader
>
mWatchManager
;
RefPtr
<
MediaTimer
>
mTimer
;
Canonical
<
media
:
:
TimeIntervals
>
mBuffered
;
public
:
AbstractCanonical
<
media
:
:
TimeIntervals
>
*
CanonicalBuffered
(
)
{
return
&
mBuffered
;
}
protected
:
MediaInfo
mInfo
;
Mirror
<
media
:
:
NullableTimeUnit
>
mDuration
;
MozPromiseRequestHolder
<
MediaTimerPromise
>
mThrottledNotify
;
const
TimeDuration
mThrottleDuration
;
TimeStamp
mLastThrottledNotify
;
Maybe
<
media
:
:
Interval
<
int64_t
>
>
mThrottledInterval
;
bool
mIgnoreAudioOutputFormat
;
Maybe
<
int64_t
>
mStartTime
;
bool
HaveStartTime
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mStartTime
.
isSome
(
)
;
}
int64_t
StartTime
(
)
{
MOZ_ASSERT
(
HaveStartTime
(
)
)
;
return
mStartTime
.
ref
(
)
;
}
bool
mHitAudioDecodeError
;
bool
mShutdown
;
TimedMetadataEventProducer
mTimedMetadataEvent
;
private
:
MozPromiseHolder
<
AudioDataPromise
>
mBaseAudioPromise
;
MozPromiseHolder
<
VideoDataPromise
>
mBaseVideoPromise
;
bool
mAudioDiscontinuity
;
bool
mVideoDiscontinuity
;
}
;
}
#
endif
