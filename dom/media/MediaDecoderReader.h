#
if
!
defined
(
MediaDecoderReader_h_
)
#
define
MediaDecoderReader_h_
#
include
"
AbstractMediaDecoder
.
h
"
#
include
"
AudioCompactor
.
h
"
#
include
"
Intervals
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaQueue
.
h
"
#
include
"
MediaResult
.
h
"
#
include
"
MediaTimer
.
h
"
#
include
"
SeekTarget
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
nsAutoPtr
.
h
"
namespace
mozilla
{
class
CDMProxy
;
class
GMPCrashHelper
;
class
MediaDecoderReader
;
class
TaskQueue
;
class
VideoFrameContainer
;
struct
WaitForDataRejectValue
{
enum
Reason
{
SHUTDOWN
CANCELED
}
;
WaitForDataRejectValue
(
MediaData
:
:
Type
aType
Reason
aReason
)
:
mType
(
aType
)
mReason
(
aReason
)
{
}
MediaData
:
:
Type
mType
;
Reason
mReason
;
}
;
struct
SeekRejectValue
{
MOZ_IMPLICIT
SeekRejectValue
(
const
MediaResult
&
aError
)
:
mType
(
MediaData
:
:
NULL_DATA
)
mError
(
aError
)
{
}
MOZ_IMPLICIT
SeekRejectValue
(
nsresult
aResult
)
:
mType
(
MediaData
:
:
NULL_DATA
)
mError
(
aResult
)
{
}
SeekRejectValue
(
MediaData
:
:
Type
aType
const
MediaResult
&
aError
)
:
mType
(
aType
)
mError
(
aError
)
{
}
MediaData
:
:
Type
mType
;
MediaResult
mError
;
}
;
struct
MetadataHolder
{
UniquePtr
<
MediaInfo
>
mInfo
;
UniquePtr
<
MetadataTags
>
mTags
;
}
;
struct
MOZ_STACK_CLASS
MediaDecoderReaderInit
{
AbstractMediaDecoder
*
const
mDecoder
;
MediaResource
*
mResource
=
nullptr
;
VideoFrameContainer
*
mVideoFrameContainer
=
nullptr
;
already_AddRefed
<
layers
:
:
KnowsCompositor
>
mKnowsCompositor
;
already_AddRefed
<
GMPCrashHelper
>
mCrashHelper
;
explicit
MediaDecoderReaderInit
(
AbstractMediaDecoder
*
aDecoder
)
:
mDecoder
(
aDecoder
)
{
}
}
;
class
MediaDecoderReader
{
static
const
bool
IsExclusive
=
true
;
public
:
using
TrackSet
=
EnumSet
<
TrackInfo
:
:
TrackType
>
;
using
MetadataPromise
=
MozPromise
<
MetadataHolder
MediaResult
IsExclusive
>
;
template
<
typename
Type
>
using
DataPromise
=
MozPromise
<
RefPtr
<
Type
>
MediaResult
IsExclusive
>
;
using
AudioDataPromise
=
DataPromise
<
AudioData
>
;
using
VideoDataPromise
=
DataPromise
<
VideoData
>
;
using
SeekPromise
=
MozPromise
<
media
:
:
TimeUnit
SeekRejectValue
IsExclusive
>
;
using
WaitForDataPromise
=
MozPromise
<
MediaData
:
:
Type
WaitForDataRejectValue
IsExclusive
>
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDecoderReader
)
explicit
MediaDecoderReader
(
MediaDecoderReaderInit
&
aInit
)
;
nsresult
Init
(
)
;
virtual
void
ReleaseResources
(
)
=
0
;
virtual
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
;
virtual
bool
OnTaskQueue
(
)
const
{
return
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
;
}
void
UpdateDuration
(
const
media
:
:
TimeUnit
&
aDuration
)
;
virtual
void
UpdateCompositor
(
already_AddRefed
<
layers
:
:
KnowsCompositor
>
)
=
0
;
virtual
nsresult
ResetDecode
(
TrackSet
aTracks
=
TrackSet
(
TrackInfo
:
:
kAudioTrack
TrackInfo
:
:
kVideoTrack
)
)
;
virtual
RefPtr
<
AudioDataPromise
>
RequestAudioData
(
)
=
0
;
virtual
RefPtr
<
VideoDataPromise
>
RequestVideoData
(
const
media
:
:
TimeUnit
&
aTimeThreshold
)
=
0
;
virtual
bool
IsWaitForDataSupported
(
)
const
=
0
;
virtual
RefPtr
<
WaitForDataPromise
>
WaitForData
(
MediaData
:
:
Type
aType
)
=
0
;
virtual
RefPtr
<
MetadataPromise
>
AsyncReadMetadata
(
)
=
0
;
virtual
void
ReadUpdatedMetadata
(
MediaInfo
*
aInfo
)
=
0
;
virtual
RefPtr
<
SeekPromise
>
Seek
(
const
SeekTarget
&
aTarget
)
=
0
;
virtual
void
SetCDMProxy
(
CDMProxy
*
aProxy
)
=
0
;
void
SetIgnoreAudioOutputFormat
(
)
{
}
virtual
bool
UseBufferingHeuristics
(
)
const
=
0
;
size_t
SizeOfVideoQueueInBytes
(
)
const
;
size_t
SizeOfAudioQueueInBytes
(
)
const
;
virtual
size_t
SizeOfVideoQueueInFrames
(
)
;
virtual
size_t
SizeOfAudioQueueInFrames
(
)
;
virtual
void
NotifyDataArrived
(
)
=
0
;
virtual
MediaQueue
<
AudioData
>
&
AudioQueue
(
)
{
return
mAudioQueue
;
}
virtual
MediaQueue
<
VideoData
>
&
VideoQueue
(
)
{
return
mVideoQueue
;
}
AbstractCanonical
<
media
:
:
TimeIntervals
>
*
CanonicalBuffered
(
)
{
return
&
mBuffered
;
}
TaskQueue
*
OwnerThread
(
)
const
{
return
mTaskQueue
;
}
virtual
bool
VideoIsHardwareAccelerated
(
)
const
=
0
;
TimedMetadataEventSource
&
TimedMetadataEvent
(
)
{
return
mTimedMetadataEvent
;
}
MediaEventSource
<
void
>
&
OnMediaNotSeekable
(
)
{
return
mOnMediaNotSeekable
;
}
TimedMetadataEventProducer
&
TimedMetadataProducer
(
)
{
return
mTimedMetadataEvent
;
}
MediaEventProducer
<
void
>
&
MediaNotSeekableProducer
(
)
{
return
mOnMediaNotSeekable
;
}
MediaEventSource
<
TrackInfo
:
:
TrackType
>
&
OnTrackWaitingForKey
(
)
{
return
mOnTrackWaitingForKey
;
}
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
&
OnTrackWaitingForKeyProducer
(
)
{
return
mOnTrackWaitingForKey
;
}
MediaEventSource
<
nsTArray
<
uint8_t
>
nsString
>
&
OnEncrypted
(
)
{
return
mOnEncrypted
;
}
MediaEventSource
<
void
>
&
OnWaitingForKey
(
)
{
return
mOnWaitingForKey
;
}
MediaEventSource
<
MediaResult
>
&
OnDecodeWarning
(
)
{
return
mOnDecodeWarning
;
}
virtual
void
SetVideoNullDecode
(
bool
aIsNullDecode
)
=
0
;
protected
:
virtual
~
MediaDecoderReader
(
)
;
virtual
void
UpdateBuffered
(
)
=
0
;
MediaQueue
<
AudioData
>
mAudioQueue
;
MediaQueue
<
VideoData
>
mVideoQueue
;
AbstractMediaDecoder
*
mDecoder
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
Canonical
<
media
:
:
TimeIntervals
>
mBuffered
;
MediaInfo
mInfo
;
media
:
:
NullableTimeUnit
mDuration
;
bool
mShutdown
;
TimedMetadataEventProducer
mTimedMetadataEvent
;
MediaEventProducer
<
void
>
mOnMediaNotSeekable
;
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
mOnTrackWaitingForKey
;
MediaEventProducer
<
nsTArray
<
uint8_t
>
nsString
>
mOnEncrypted
;
MediaEventProducer
<
void
>
mOnWaitingForKey
;
MediaEventProducer
<
MediaResult
>
mOnDecodeWarning
;
RefPtr
<
MediaResource
>
mResource
;
private
:
virtual
nsresult
InitInternal
(
)
=
0
;
}
;
}
#
endif
