#
if
!
defined
(
MediaDecoderReader_h_
)
#
define
MediaDecoderReader_h_
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
AbstractMediaDecoder
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaQueue
.
h
"
#
include
"
MediaTimer
.
h
"
#
include
"
AudioCompactor
.
h
"
#
include
"
Intervals
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
SeekTarget
.
h
"
namespace
mozilla
{
class
CDMProxy
;
class
MediaDecoderReader
;
struct
WaitForDataRejectValue
{
enum
Reason
{
SHUTDOWN
CANCELED
}
;
WaitForDataRejectValue
(
MediaData
:
:
Type
aType
Reason
aReason
)
:
mType
(
aType
)
mReason
(
aReason
)
{
}
MediaData
:
:
Type
mType
;
Reason
mReason
;
}
;
class
MetadataHolder
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MetadataHolder
)
MediaInfo
mInfo
;
nsAutoPtr
<
MetadataTags
>
mTags
;
private
:
virtual
~
MetadataHolder
(
)
{
}
}
;
enum
class
ReadMetadataFailureReason
:
int8_t
{
METADATA_ERROR
}
;
class
MediaDecoderReader
{
friend
class
ReRequestVideoWithSkipTask
;
friend
class
ReRequestAudioTask
;
static
const
bool
IsExclusive
=
true
;
public
:
enum
NotDecodedReason
{
END_OF_STREAM
DECODE_ERROR
WAITING_FOR_DATA
CANCELED
}
;
using
MetadataPromise
=
MozPromise
<
RefPtr
<
MetadataHolder
>
ReadMetadataFailureReason
IsExclusive
>
;
using
AudioDataPromise
=
MozPromise
<
RefPtr
<
MediaData
>
NotDecodedReason
IsExclusive
>
;
using
VideoDataPromise
=
MozPromise
<
RefPtr
<
MediaData
>
NotDecodedReason
IsExclusive
>
;
using
SeekPromise
=
MozPromise
<
int64_t
nsresult
IsExclusive
>
;
using
WaitForDataPromise
=
MozPromise
<
MediaData
:
:
Type
WaitForDataRejectValue
IsExclusive
>
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDecoderReader
)
explicit
MediaDecoderReader
(
AbstractMediaDecoder
*
aDecoder
)
;
virtual
nsresult
Init
(
)
{
return
NS_OK
;
}
virtual
void
ReleaseMediaResources
(
)
{
}
virtual
void
BreakCycles
(
)
;
virtual
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
;
virtual
bool
OnTaskQueue
(
)
const
{
return
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
;
}
virtual
nsresult
ResetDecode
(
)
;
virtual
RefPtr
<
AudioDataPromise
>
RequestAudioData
(
)
;
virtual
RefPtr
<
VideoDataPromise
>
RequestVideoData
(
bool
aSkipToNextKeyframe
int64_t
aTimeThreshold
)
;
virtual
bool
IsWaitForDataSupported
(
)
{
return
false
;
}
virtual
RefPtr
<
WaitForDataPromise
>
WaitForData
(
MediaData
:
:
Type
aType
)
{
MOZ_CRASH
(
)
;
}
virtual
bool
IsDemuxOnlySupported
(
)
const
{
return
false
;
}
virtual
void
SetDemuxOnly
(
bool
)
{
}
virtual
RefPtr
<
MetadataPromise
>
AsyncReadMetadata
(
)
;
virtual
void
ReadUpdatedMetadata
(
MediaInfo
*
aInfo
)
{
}
virtual
RefPtr
<
SeekPromise
>
Seek
(
SeekTarget
aTarget
int64_t
aEndTime
)
=
0
;
virtual
void
SetIdle
(
)
{
}
#
ifdef
MOZ_EME
virtual
void
SetCDMProxy
(
CDMProxy
*
aProxy
)
{
}
#
endif
void
SetIgnoreAudioOutputFormat
(
)
{
mIgnoreAudioOutputFormat
=
true
;
}
virtual
bool
ForceZeroStartTime
(
)
const
{
return
false
;
}
virtual
bool
UseBufferingHeuristics
(
)
{
return
true
;
}
size_t
SizeOfVideoQueueInBytes
(
)
const
;
size_t
SizeOfAudioQueueInBytes
(
)
const
;
virtual
size_t
SizeOfVideoQueueInFrames
(
)
;
virtual
size_t
SizeOfAudioQueueInFrames
(
)
;
void
NotifyDataArrived
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
NS_ENSURE_TRUE_VOID
(
!
mShutdown
)
;
NotifyDataArrivedInternal
(
)
;
UpdateBuffered
(
)
;
}
virtual
MediaQueue
<
AudioData
>
&
AudioQueue
(
)
{
return
mAudioQueue
;
}
virtual
MediaQueue
<
VideoData
>
&
VideoQueue
(
)
{
return
mVideoQueue
;
}
AbstractCanonical
<
media
:
:
TimeIntervals
>
*
CanonicalBuffered
(
)
{
return
&
mBuffered
;
}
void
DispatchSetStartTime
(
int64_t
aStartTime
)
{
RefPtr
<
MediaDecoderReader
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
[
self
aStartTime
]
(
)
-
>
void
{
MOZ_ASSERT
(
self
-
>
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
!
self
-
>
HaveStartTime
(
)
)
;
self
-
>
mStartTime
.
emplace
(
aStartTime
)
;
self
-
>
UpdateBuffered
(
)
;
}
)
;
OwnerThread
(
)
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
TaskQueue
*
OwnerThread
(
)
const
{
return
mTaskQueue
;
}
virtual
bool
IsAsync
(
)
const
{
return
false
;
}
virtual
bool
VideoIsHardwareAccelerated
(
)
const
{
return
false
;
}
virtual
void
DisableHardwareAcceleration
(
)
{
}
TimedMetadataEventSource
&
TimedMetadataEvent
(
)
{
return
mTimedMetadataEvent
;
}
MediaEventSource
<
void
>
&
OnMediaNotSeekable
(
)
{
return
mOnMediaNotSeekable
;
}
protected
:
virtual
~
MediaDecoderReader
(
)
;
virtual
media
:
:
TimeIntervals
GetBuffered
(
)
;
RefPtr
<
VideoDataPromise
>
DecodeToFirstVideoData
(
)
;
bool
HaveStartTime
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
mStartTime
.
isSome
(
)
;
}
int64_t
StartTime
(
)
{
MOZ_ASSERT
(
HaveStartTime
(
)
)
;
return
mStartTime
.
ref
(
)
;
}
MediaQueue
<
AudioData
>
mAudioQueue
;
MediaQueue
<
VideoData
>
mVideoQueue
;
AudioCompactor
mAudioCompactor
;
AbstractMediaDecoder
*
mDecoder
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
WatchManager
<
MediaDecoderReader
>
mWatchManager
;
Canonical
<
media
:
:
TimeIntervals
>
mBuffered
;
MediaInfo
mInfo
;
Mirror
<
media
:
:
NullableTimeUnit
>
mDuration
;
bool
mIgnoreAudioOutputFormat
;
Maybe
<
int64_t
>
mStartTime
;
bool
mHitAudioDecodeError
;
bool
mShutdown
;
TimedMetadataEventProducer
mTimedMetadataEvent
;
MediaEventProducer
<
void
>
mOnMediaNotSeekable
;
private
:
void
InitializationTask
(
)
;
virtual
nsresult
ReadMetadata
(
MediaInfo
*
aInfo
MetadataTags
*
*
aTags
)
{
MOZ_CRASH
(
)
;
}
virtual
void
UpdateBuffered
(
)
;
virtual
void
NotifyDataArrivedInternal
(
)
{
}
virtual
bool
DecodeAudioData
(
)
{
return
false
;
}
virtual
bool
DecodeVideoFrame
(
bool
&
aKeyframeSkip
int64_t
aTimeThreshold
)
{
return
false
;
}
MozPromiseHolder
<
AudioDataPromise
>
mBaseAudioPromise
;
MozPromiseHolder
<
VideoDataPromise
>
mBaseVideoPromise
;
bool
mAudioDiscontinuity
;
bool
mVideoDiscontinuity
;
MediaEventListener
mDataArrivedListener
;
}
;
}
#
endif
