#
if
!
defined
(
MediaDecoderReader_h_
)
#
define
MediaDecoderReader_h_
#
include
"
AbstractMediaDecoder
.
h
"
#
include
"
AudioCompactor
.
h
"
#
include
"
Intervals
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
MediaInfo
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaQueue
.
h
"
#
include
"
MediaResult
.
h
"
#
include
"
MediaTimer
.
h
"
#
include
"
SeekTarget
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
nsAutoPtr
.
h
"
namespace
mozilla
{
class
CDMProxy
;
class
MediaDecoderReader
;
class
TaskQueue
;
struct
WaitForDataRejectValue
{
enum
Reason
{
SHUTDOWN
CANCELED
}
;
WaitForDataRejectValue
(
MediaData
:
:
Type
aType
Reason
aReason
)
:
mType
(
aType
)
mReason
(
aReason
)
{
}
MediaData
:
:
Type
mType
;
Reason
mReason
;
}
;
struct
SeekRejectValue
{
MOZ_IMPLICIT
SeekRejectValue
(
const
MediaResult
&
aError
)
:
mType
(
MediaData
:
:
NULL_DATA
)
mError
(
aError
)
{
}
MOZ_IMPLICIT
SeekRejectValue
(
nsresult
aResult
)
:
mType
(
MediaData
:
:
NULL_DATA
)
mError
(
aResult
)
{
}
SeekRejectValue
(
MediaData
:
:
Type
aType
const
MediaResult
&
aError
)
:
mType
(
aType
)
mError
(
aError
)
{
}
MediaData
:
:
Type
mType
;
MediaResult
mError
;
}
;
struct
MetadataHolder
{
UniquePtr
<
MediaInfo
>
mInfo
;
UniquePtr
<
MetadataTags
>
mTags
;
}
;
class
MediaDecoderReader
{
friend
class
ReRequestVideoWithSkipTask
;
friend
class
ReRequestAudioTask
;
static
const
bool
IsExclusive
=
true
;
public
:
using
TrackSet
=
EnumSet
<
TrackInfo
:
:
TrackType
>
;
using
MetadataPromise
=
MozPromise
<
MetadataHolder
MediaResult
IsExclusive
>
;
template
<
typename
Type
>
using
DataPromise
=
MozPromise
<
RefPtr
<
Type
>
MediaResult
IsExclusive
>
;
using
AudioDataPromise
=
DataPromise
<
AudioData
>
;
using
VideoDataPromise
=
DataPromise
<
VideoData
>
;
using
SeekPromise
=
MozPromise
<
media
:
:
TimeUnit
SeekRejectValue
IsExclusive
>
;
using
WaitForDataPromise
=
MozPromise
<
MediaData
:
:
Type
WaitForDataRejectValue
IsExclusive
>
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaDecoderReader
)
explicit
MediaDecoderReader
(
AbstractMediaDecoder
*
aDecoder
)
;
nsresult
Init
(
)
;
virtual
void
ReleaseResources
(
)
{
}
virtual
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
;
virtual
bool
OnTaskQueue
(
)
const
{
return
OwnerThread
(
)
-
>
IsCurrentThreadIn
(
)
;
}
virtual
nsresult
ResetDecode
(
TrackSet
aTracks
=
TrackSet
(
TrackInfo
:
:
kAudioTrack
TrackInfo
:
:
kVideoTrack
)
)
;
virtual
RefPtr
<
AudioDataPromise
>
RequestAudioData
(
)
;
virtual
RefPtr
<
VideoDataPromise
>
RequestVideoData
(
const
media
:
:
TimeUnit
&
aTimeThreshold
)
;
virtual
bool
IsWaitForDataSupported
(
)
const
{
return
false
;
}
virtual
RefPtr
<
WaitForDataPromise
>
WaitForData
(
MediaData
:
:
Type
aType
)
{
MOZ_CRASH
(
)
;
}
virtual
RefPtr
<
MetadataPromise
>
AsyncReadMetadata
(
)
;
virtual
void
ReadUpdatedMetadata
(
MediaInfo
*
aInfo
)
{
}
virtual
RefPtr
<
SeekPromise
>
Seek
(
const
SeekTarget
&
aTarget
)
=
0
;
virtual
void
SetCDMProxy
(
CDMProxy
*
aProxy
)
{
}
void
SetIgnoreAudioOutputFormat
(
)
{
mIgnoreAudioOutputFormat
=
true
;
}
virtual
bool
UseBufferingHeuristics
(
)
const
{
return
true
;
}
size_t
SizeOfVideoQueueInBytes
(
)
const
;
size_t
SizeOfAudioQueueInBytes
(
)
const
;
virtual
size_t
SizeOfVideoQueueInFrames
(
)
;
virtual
size_t
SizeOfAudioQueueInFrames
(
)
;
virtual
void
NotifyDataArrived
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
NS_ENSURE_TRUE_VOID
(
!
mShutdown
)
;
UpdateBuffered
(
)
;
}
virtual
MediaQueue
<
AudioData
>
&
AudioQueue
(
)
{
return
mAudioQueue
;
}
virtual
MediaQueue
<
VideoData
>
&
VideoQueue
(
)
{
return
mVideoQueue
;
}
AbstractCanonical
<
media
:
:
TimeIntervals
>
*
CanonicalBuffered
(
)
{
return
&
mBuffered
;
}
TaskQueue
*
OwnerThread
(
)
const
{
return
mTaskQueue
;
}
virtual
bool
IsAsync
(
)
const
{
return
false
;
}
virtual
bool
VideoIsHardwareAccelerated
(
)
const
{
return
false
;
}
TimedMetadataEventSource
&
TimedMetadataEvent
(
)
{
return
mTimedMetadataEvent
;
}
MediaEventSource
<
void
>
&
OnMediaNotSeekable
(
)
{
return
mOnMediaNotSeekable
;
}
TimedMetadataEventProducer
&
TimedMetadataProducer
(
)
{
return
mTimedMetadataEvent
;
}
MediaEventProducer
<
void
>
&
MediaNotSeekableProducer
(
)
{
return
mOnMediaNotSeekable
;
}
MediaEventSource
<
TrackInfo
:
:
TrackType
>
&
OnTrackWaitingForKey
(
)
{
return
mOnTrackWaitingForKey
;
}
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
&
OnTrackWaitingForKeyProducer
(
)
{
return
mOnTrackWaitingForKey
;
}
virtual
void
SetVideoNullDecode
(
bool
aIsNullDecode
)
{
}
protected
:
virtual
~
MediaDecoderReader
(
)
;
virtual
void
UpdateBuffered
(
)
;
RefPtr
<
VideoDataPromise
>
DecodeToFirstVideoData
(
)
;
MediaQueue
<
AudioData
>
mAudioQueue
;
MediaQueue
<
VideoData
>
mVideoQueue
;
AudioCompactor
mAudioCompactor
;
AbstractMediaDecoder
*
mDecoder
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
WatchManager
<
MediaDecoderReader
>
mWatchManager
;
Canonical
<
media
:
:
TimeIntervals
>
mBuffered
;
MediaInfo
mInfo
;
Mirror
<
media
:
:
NullableTimeUnit
>
mDuration
;
bool
mIgnoreAudioOutputFormat
;
bool
mHitAudioDecodeError
;
bool
mShutdown
;
TimedMetadataEventProducer
mTimedMetadataEvent
;
MediaEventProducer
<
void
>
mOnMediaNotSeekable
;
MediaEventProducer
<
TrackInfo
:
:
TrackType
>
mOnTrackWaitingForKey
;
private
:
virtual
nsresult
InitInternal
(
)
{
return
NS_OK
;
}
void
InitializationTask
(
)
;
virtual
nsresult
ReadMetadata
(
MediaInfo
*
aInfo
MetadataTags
*
*
aTags
)
{
MOZ_CRASH
(
)
;
}
virtual
void
VisibilityChanged
(
)
;
virtual
bool
DecodeAudioData
(
)
{
return
false
;
}
virtual
bool
DecodeVideoFrame
(
bool
&
aKeyframeSkip
const
media
:
:
TimeUnit
&
aTimeThreshold
)
{
return
false
;
}
media
:
:
TimeIntervals
GetBuffered
(
)
;
MozPromiseHolder
<
AudioDataPromise
>
mBaseAudioPromise
;
MozPromiseHolder
<
VideoDataPromise
>
mBaseVideoPromise
;
MediaEventListener
mDataArrivedListener
;
}
;
}
#
endif
