#
if
!
defined
(
MediaData_h
)
#
define
MediaData_h
#
include
"
AudioSampleFormat
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
SharedBuffer
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
namespace
mozilla
{
namespace
layers
{
class
Image
;
class
ImageContainer
;
}
class
MediaByteBuffer
;
class
SharedTrackInfo
;
template
<
typename
Type
int
Alignment
=
32
>
class
AlignedBuffer
{
public
:
AlignedBuffer
(
)
:
mData
(
nullptr
)
mLength
(
0
)
mBuffer
(
nullptr
)
mCapacity
(
0
)
{
}
explicit
AlignedBuffer
(
size_t
aLength
)
:
mData
(
nullptr
)
mLength
(
0
)
mBuffer
(
nullptr
)
mCapacity
(
0
)
{
if
(
EnsureCapacity
(
aLength
)
)
{
mLength
=
aLength
;
}
}
AlignedBuffer
(
const
Type
*
aData
size_t
aLength
)
:
AlignedBuffer
(
aLength
)
{
if
(
!
mData
)
{
return
;
}
PodCopy
(
mData
aData
aLength
)
;
}
AlignedBuffer
(
const
AlignedBuffer
&
aOther
)
:
AlignedBuffer
(
aOther
.
Data
(
)
aOther
.
Length
(
)
)
{
}
AlignedBuffer
(
AlignedBuffer
&
&
aOther
)
:
mData
(
aOther
.
mData
)
mLength
(
aOther
.
mLength
)
mBuffer
(
Move
(
aOther
.
mBuffer
)
)
mCapacity
(
aOther
.
mCapacity
)
{
aOther
.
mData
=
nullptr
;
aOther
.
mLength
=
0
;
aOther
.
mCapacity
=
0
;
}
AlignedBuffer
&
operator
=
(
AlignedBuffer
&
&
aOther
)
{
this
-
>
~
AlignedBuffer
(
)
;
new
(
this
)
AlignedBuffer
(
Move
(
aOther
)
)
;
return
*
this
;
}
Type
*
Data
(
)
const
{
return
mData
;
}
size_t
Length
(
)
const
{
return
mLength
;
}
size_t
Size
(
)
const
{
return
mLength
*
sizeof
(
Type
)
;
}
Type
&
operator
[
]
(
size_t
aIndex
)
{
MOZ_ASSERT
(
aIndex
<
mLength
)
;
return
mData
[
aIndex
]
;
}
const
Type
&
operator
[
]
(
size_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
mLength
)
;
return
mData
[
aIndex
]
;
}
bool
SetLength
(
size_t
aLength
)
{
if
(
aLength
>
mLength
&
&
!
EnsureCapacity
(
aLength
)
)
{
return
false
;
}
mLength
=
aLength
;
return
true
;
}
bool
Prepend
(
const
Type
*
aData
size_t
aLength
)
{
if
(
!
EnsureCapacity
(
aLength
+
mLength
)
)
{
return
false
;
}
PodMove
(
mData
+
aLength
mData
mLength
)
;
PodCopy
(
mData
aData
aLength
)
;
mLength
+
=
aLength
;
return
true
;
}
bool
Append
(
const
Type
*
aData
size_t
aLength
)
{
if
(
!
EnsureCapacity
(
aLength
+
mLength
)
)
{
return
false
;
}
PodCopy
(
mData
+
mLength
aData
aLength
)
;
mLength
+
=
aLength
;
return
true
;
}
bool
Replace
(
const
Type
*
aData
size_t
aLength
)
{
if
(
!
EnsureCapacity
(
aLength
)
)
{
return
false
;
}
PodCopy
(
mData
aData
aLength
)
;
mLength
=
aLength
;
return
true
;
}
void
Clear
(
)
{
mLength
=
0
;
mData
=
nullptr
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
size
=
aMallocSizeOf
(
this
)
;
size
+
=
aMallocSizeOf
(
mBuffer
.
get
(
)
)
;
return
size
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
mBuffer
.
get
(
)
)
;
}
size_t
ComputedSizeOfExcludingThis
(
)
const
{
return
mCapacity
;
}
Type
*
get
(
)
const
{
return
mData
;
}
explicit
operator
bool
(
)
const
{
return
mData
!
=
nullptr
;
}
static
size_t
AlignmentPaddingSize
(
)
{
return
AlignmentOffset
(
)
*
2
;
}
private
:
static
size_t
AlignmentOffset
(
)
{
return
Alignment
?
Alignment
-
1
:
0
;
}
bool
EnsureCapacity
(
size_t
aLength
)
{
const
CheckedInt
<
size_t
>
sizeNeeded
=
CheckedInt
<
size_t
>
(
aLength
)
*
sizeof
(
Type
)
+
AlignmentPaddingSize
(
)
;
if
(
!
sizeNeeded
.
isValid
(
)
|
|
sizeNeeded
.
value
(
)
>
=
INT32_MAX
)
{
return
false
;
}
if
(
mData
&
&
mCapacity
>
=
sizeNeeded
.
value
(
)
)
{
return
true
;
}
auto
newBuffer
=
MakeUniqueFallible
<
uint8_t
[
]
>
(
sizeNeeded
.
value
(
)
)
;
if
(
!
newBuffer
)
{
return
false
;
}
const
uintptr_t
alignmask
=
AlignmentOffset
(
)
;
Type
*
newData
=
reinterpret_cast
<
Type
*
>
(
(
reinterpret_cast
<
uintptr_t
>
(
newBuffer
.
get
(
)
)
+
alignmask
)
&
~
alignmask
)
;
MOZ_ASSERT
(
uintptr_t
(
newData
)
%
(
AlignmentOffset
(
)
+
1
)
=
=
0
)
;
MOZ_ASSERT
(
!
mLength
|
|
mData
)
;
PodZero
(
newData
+
mLength
aLength
-
mLength
)
;
if
(
mLength
)
{
PodCopy
(
newData
mData
mLength
)
;
}
mBuffer
=
Move
(
newBuffer
)
;
mCapacity
=
sizeNeeded
.
value
(
)
;
mData
=
newData
;
return
true
;
}
Type
*
mData
;
size_t
mLength
;
UniquePtr
<
uint8_t
[
]
>
mBuffer
;
size_t
mCapacity
;
}
;
typedef
AlignedBuffer
<
uint8_t
>
AlignedByteBuffer
;
typedef
AlignedBuffer
<
float
>
AlignedFloatBuffer
;
typedef
AlignedBuffer
<
int16_t
>
AlignedShortBuffer
;
typedef
AlignedBuffer
<
AudioDataValue
>
AlignedAudioBuffer
;
class
MediaData
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaData
)
enum
Type
{
AUDIO_DATA
=
0
VIDEO_DATA
RAW_DATA
NULL_DATA
}
;
MediaData
(
Type
aType
int64_t
aOffset
int64_t
aTimestamp
int64_t
aDuration
uint32_t
aFrames
)
:
mType
(
aType
)
mOffset
(
aOffset
)
mTime
(
aTimestamp
)
mTimecode
(
aTimestamp
)
mDuration
(
aDuration
)
mFrames
(
aFrames
)
mKeyframe
(
false
)
{
}
const
Type
mType
;
int64_t
mOffset
;
int64_t
mTime
;
int64_t
mTimecode
;
int64_t
mDuration
;
const
uint32_t
mFrames
;
bool
mKeyframe
;
int64_t
GetEndTime
(
)
const
{
return
mTime
+
mDuration
;
}
bool
AdjustForStartTime
(
int64_t
aStartTime
)
{
mTime
=
mTime
-
aStartTime
;
return
mTime
>
=
0
;
}
template
<
typename
ReturnType
>
const
ReturnType
*
As
(
)
const
{
MOZ_ASSERT
(
this
-
>
mType
=
=
ReturnType
:
:
sType
)
;
return
static_cast
<
const
ReturnType
*
>
(
this
)
;
}
template
<
typename
ReturnType
>
ReturnType
*
As
(
)
{
MOZ_ASSERT
(
this
-
>
mType
=
=
ReturnType
:
:
sType
)
;
return
static_cast
<
ReturnType
*
>
(
this
)
;
}
protected
:
MediaData
(
Type
aType
uint32_t
aFrames
)
:
mType
(
aType
)
mOffset
(
0
)
mTime
(
0
)
mTimecode
(
0
)
mDuration
(
0
)
mFrames
(
aFrames
)
mKeyframe
(
false
)
{
}
virtual
~
MediaData
(
)
{
}
}
;
class
NullData
:
public
MediaData
{
public
:
NullData
(
int64_t
aOffset
int64_t
aTime
int64_t
aDuration
)
:
MediaData
(
NULL_DATA
aOffset
aTime
aDuration
0
)
{
}
static
const
Type
sType
=
NULL_DATA
;
}
;
class
AudioData
:
public
MediaData
{
public
:
AudioData
(
int64_t
aOffset
int64_t
aTime
int64_t
aDuration
uint32_t
aFrames
AlignedAudioBuffer
&
&
aData
uint32_t
aChannels
uint32_t
aRate
)
:
MediaData
(
sType
aOffset
aTime
aDuration
aFrames
)
mChannels
(
aChannels
)
mRate
(
aRate
)
mAudioData
(
Move
(
aData
)
)
{
}
static
const
Type
sType
=
AUDIO_DATA
;
static
const
char
*
sTypeName
;
static
already_AddRefed
<
AudioData
>
TransferAndUpdateTimestampAndDuration
(
AudioData
*
aOther
int64_t
aTimestamp
int64_t
aDuration
)
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
void
EnsureAudioBuffer
(
)
;
bool
IsAudible
(
)
const
;
const
uint32_t
mChannels
;
const
uint32_t
mRate
;
RefPtr
<
SharedBuffer
>
mAudioBuffer
;
AlignedAudioBuffer
mAudioData
;
protected
:
~
AudioData
(
)
{
}
}
;
namespace
layers
{
class
TextureClient
;
class
PlanarYCbCrImage
;
}
class
VideoInfo
;
class
VideoData
:
public
MediaData
{
public
:
typedef
gfx
:
:
IntRect
IntRect
;
typedef
gfx
:
:
IntSize
IntSize
;
typedef
layers
:
:
ImageContainer
ImageContainer
;
typedef
layers
:
:
Image
Image
;
typedef
layers
:
:
PlanarYCbCrImage
PlanarYCbCrImage
;
static
const
Type
sType
=
VIDEO_DATA
;
static
const
char
*
sTypeName
;
struct
YCbCrBuffer
{
struct
Plane
{
uint8_t
*
mData
;
uint32_t
mWidth
;
uint32_t
mHeight
;
uint32_t
mStride
;
uint32_t
mOffset
;
uint32_t
mSkip
;
}
;
Plane
mPlanes
[
3
]
;
YUVColorSpace
mYUVColorSpace
=
YUVColorSpace
:
:
BT601
;
}
;
class
Listener
{
public
:
virtual
void
OnSentToCompositor
(
)
=
0
;
virtual
~
Listener
(
)
{
}
}
;
static
already_AddRefed
<
VideoData
>
CreateAndCopyData
(
const
VideoInfo
&
aInfo
ImageContainer
*
aContainer
int64_t
aOffset
int64_t
aTime
int64_t
aDuration
const
YCbCrBuffer
&
aBuffer
bool
aKeyframe
int64_t
aTimecode
const
IntRect
&
aPicture
)
;
static
already_AddRefed
<
VideoData
>
CreateAndCopyIntoTextureClient
(
const
VideoInfo
&
aInfo
int64_t
aOffset
int64_t
aTime
int64_t
aDuration
layers
:
:
TextureClient
*
aBuffer
bool
aKeyframe
int64_t
aTimecode
const
IntRect
&
aPicture
)
;
static
already_AddRefed
<
VideoData
>
CreateFromImage
(
const
VideoInfo
&
aInfo
int64_t
aOffset
int64_t
aTime
int64_t
aDuration
const
RefPtr
<
Image
>
&
aImage
bool
aKeyframe
int64_t
aTimecode
const
IntRect
&
aPicture
)
;
static
already_AddRefed
<
VideoData
>
ShallowCopyUpdateDuration
(
const
VideoData
*
aOther
int64_t
aDuration
)
;
static
already_AddRefed
<
VideoData
>
ShallowCopyUpdateTimestamp
(
const
VideoData
*
aOther
int64_t
aTimestamp
)
;
static
already_AddRefed
<
VideoData
>
ShallowCopyUpdateTimestampAndDuration
(
const
VideoData
*
aOther
int64_t
aTimestamp
int64_t
aDuration
)
;
static
bool
SetVideoDataToImage
(
PlanarYCbCrImage
*
aVideoImage
const
VideoInfo
&
aInfo
const
YCbCrBuffer
&
aBuffer
const
IntRect
&
aPicture
bool
aCopyData
)
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
const
IntSize
mDisplay
;
RefPtr
<
Image
>
mImage
;
int32_t
mFrameID
;
VideoData
(
int64_t
aOffset
int64_t
aTime
int64_t
aDuration
bool
aKeyframe
int64_t
aTimecode
IntSize
aDisplay
uint32_t
aFrameID
)
;
void
SetListener
(
UniquePtr
<
Listener
>
aListener
)
;
void
MarkSentToCompositor
(
)
;
bool
IsSentToCompositor
(
)
{
return
mSentToCompositor
;
}
protected
:
~
VideoData
(
)
;
bool
mSentToCompositor
;
UniquePtr
<
Listener
>
mListener
;
}
;
class
CryptoTrack
{
public
:
CryptoTrack
(
)
:
mValid
(
false
)
mMode
(
0
)
mIVSize
(
0
)
{
}
bool
mValid
;
int32_t
mMode
;
int32_t
mIVSize
;
nsTArray
<
uint8_t
>
mKeyId
;
}
;
class
CryptoSample
:
public
CryptoTrack
{
public
:
nsTArray
<
uint16_t
>
mPlainSizes
;
nsTArray
<
uint32_t
>
mEncryptedSizes
;
nsTArray
<
uint8_t
>
mIV
;
nsTArray
<
nsCString
>
mSessionIds
;
}
;
class
MediaRawData
;
class
MediaRawDataWriter
{
public
:
uint8_t
*
Data
(
)
;
size_t
Size
(
)
;
CryptoSample
&
mCrypto
;
bool
SetSize
(
size_t
aSize
)
;
bool
Prepend
(
const
uint8_t
*
aData
size_t
aSize
)
;
bool
Replace
(
const
uint8_t
*
aData
size_t
aSize
)
;
void
Clear
(
)
;
private
:
friend
class
MediaRawData
;
explicit
MediaRawDataWriter
(
MediaRawData
*
aMediaRawData
)
;
bool
EnsureSize
(
size_t
aSize
)
;
MediaRawData
*
mTarget
;
}
;
class
MediaRawData
:
public
MediaData
{
public
:
MediaRawData
(
)
;
MediaRawData
(
const
uint8_t
*
aData
size_t
aSize
)
;
MediaRawData
(
const
uint8_t
*
aData
size_t
aSize
const
uint8_t
*
aAlphaData
size_t
aAlphaSize
)
;
const
uint8_t
*
Data
(
)
const
{
return
mBuffer
.
Data
(
)
;
}
const
uint8_t
*
AlphaData
(
)
const
{
return
mAlphaBuffer
.
Data
(
)
;
}
size_t
Size
(
)
const
{
return
mBuffer
.
Length
(
)
;
}
size_t
AlphaSize
(
)
const
{
return
mAlphaBuffer
.
Length
(
)
;
}
size_t
ComputedSizeOfIncludingThis
(
)
const
{
return
sizeof
(
*
this
)
+
mBuffer
.
ComputedSizeOfExcludingThis
(
)
+
mAlphaBuffer
.
ComputedSizeOfExcludingThis
(
)
;
}
const
CryptoSample
&
mCrypto
;
RefPtr
<
MediaByteBuffer
>
mExtraData
;
bool
mEOS
=
false
;
uint32_t
mDiscardPadding
=
0
;
RefPtr
<
SharedTrackInfo
>
mTrackInfo
;
virtual
already_AddRefed
<
MediaRawData
>
Clone
(
)
const
;
virtual
MediaRawDataWriter
*
CreateWriter
(
)
;
virtual
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
protected
:
~
MediaRawData
(
)
;
private
:
friend
class
MediaRawDataWriter
;
AlignedByteBuffer
mBuffer
;
AlignedByteBuffer
mAlphaBuffer
;
CryptoSample
mCryptoInternal
;
MediaRawData
(
const
MediaRawData
&
)
;
}
;
class
MediaByteBuffer
:
public
nsTArray
<
uint8_t
>
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaByteBuffer
)
;
MediaByteBuffer
(
)
=
default
;
explicit
MediaByteBuffer
(
size_t
aCapacity
)
:
nsTArray
<
uint8_t
>
(
aCapacity
)
{
}
private
:
~
MediaByteBuffer
(
)
{
}
}
;
}
#
endif
