#
if
!
defined
(
MediaData_h
)
#
define
MediaData_h
#
include
"
AudioConfig
.
h
"
#
include
"
AudioSampleFormat
.
h
"
#
include
"
ImageTypes
.
h
"
#
include
"
SharedBuffer
.
h
"
#
include
"
TimeUnits
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
layers
{
class
Image
;
class
ImageContainer
;
class
KnowsCompositor
;
}
class
MediaByteBuffer
;
class
TrackInfoSharedPtr
;
template
<
typename
Type
int
Alignment
=
32
>
class
AlignedBuffer
{
public
:
AlignedBuffer
(
)
:
mData
(
nullptr
)
mLength
(
0
)
mBuffer
(
nullptr
)
mCapacity
(
0
)
{
}
explicit
AlignedBuffer
(
size_t
aLength
)
:
mData
(
nullptr
)
mLength
(
0
)
mBuffer
(
nullptr
)
mCapacity
(
0
)
{
if
(
EnsureCapacity
(
aLength
)
)
{
mLength
=
aLength
;
}
}
AlignedBuffer
(
const
Type
*
aData
size_t
aLength
)
:
AlignedBuffer
(
aLength
)
{
if
(
!
mData
)
{
return
;
}
PodCopy
(
mData
aData
aLength
)
;
}
AlignedBuffer
(
const
AlignedBuffer
&
aOther
)
:
AlignedBuffer
(
aOther
.
Data
(
)
aOther
.
Length
(
)
)
{
}
AlignedBuffer
(
AlignedBuffer
&
&
aOther
)
:
mData
(
aOther
.
mData
)
mLength
(
aOther
.
mLength
)
mBuffer
(
std
:
:
move
(
aOther
.
mBuffer
)
)
mCapacity
(
aOther
.
mCapacity
)
{
aOther
.
mData
=
nullptr
;
aOther
.
mLength
=
0
;
aOther
.
mCapacity
=
0
;
}
AlignedBuffer
&
operator
=
(
AlignedBuffer
&
&
aOther
)
{
this
-
>
~
AlignedBuffer
(
)
;
new
(
this
)
AlignedBuffer
(
std
:
:
move
(
aOther
)
)
;
return
*
this
;
}
Type
*
Data
(
)
const
{
return
mData
;
}
size_t
Length
(
)
const
{
return
mLength
;
}
size_t
Size
(
)
const
{
return
mLength
*
sizeof
(
Type
)
;
}
Type
&
operator
[
]
(
size_t
aIndex
)
{
MOZ_ASSERT
(
aIndex
<
mLength
)
;
return
mData
[
aIndex
]
;
}
const
Type
&
operator
[
]
(
size_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
mLength
)
;
return
mData
[
aIndex
]
;
}
bool
SetLength
(
size_t
aLength
)
{
if
(
aLength
>
mLength
&
&
!
EnsureCapacity
(
aLength
)
)
{
return
false
;
}
mLength
=
aLength
;
return
true
;
}
bool
Prepend
(
const
Type
*
aData
size_t
aLength
)
{
if
(
!
EnsureCapacity
(
aLength
+
mLength
)
)
{
return
false
;
}
PodMove
(
mData
+
aLength
mData
mLength
)
;
PodCopy
(
mData
aData
aLength
)
;
mLength
+
=
aLength
;
return
true
;
}
bool
Append
(
const
Type
*
aData
size_t
aLength
)
{
if
(
!
EnsureCapacity
(
aLength
+
mLength
)
)
{
return
false
;
}
PodCopy
(
mData
+
mLength
aData
aLength
)
;
mLength
+
=
aLength
;
return
true
;
}
bool
Replace
(
const
Type
*
aData
size_t
aLength
)
{
if
(
!
EnsureCapacity
(
aLength
)
)
{
return
false
;
}
PodCopy
(
mData
aData
aLength
)
;
mLength
=
aLength
;
return
true
;
}
void
Clear
(
)
{
mLength
=
0
;
mData
=
nullptr
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
size
=
aMallocSizeOf
(
this
)
;
size
+
=
aMallocSizeOf
(
mBuffer
.
get
(
)
)
;
return
size
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
mBuffer
.
get
(
)
)
;
}
size_t
ComputedSizeOfExcludingThis
(
)
const
{
return
mCapacity
;
}
Type
*
get
(
)
const
{
return
mData
;
}
explicit
operator
bool
(
)
const
{
return
mData
!
=
nullptr
;
}
static
size_t
AlignmentPaddingSize
(
)
{
return
AlignmentOffset
(
)
*
2
;
}
void
PopFront
(
size_t
aSize
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mLength
>
=
aSize
"
Popping
too
many
frames
"
)
;
PodMove
(
mData
mData
+
aSize
mLength
-
aSize
)
;
mLength
-
=
aSize
;
}
private
:
static
size_t
AlignmentOffset
(
)
{
return
Alignment
?
Alignment
-
1
:
0
;
}
bool
EnsureCapacity
(
size_t
aLength
)
{
if
(
!
aLength
)
{
return
true
;
}
const
CheckedInt
<
size_t
>
sizeNeeded
=
CheckedInt
<
size_t
>
(
aLength
)
*
sizeof
(
Type
)
+
AlignmentPaddingSize
(
)
;
if
(
!
sizeNeeded
.
isValid
(
)
|
|
sizeNeeded
.
value
(
)
>
=
INT32_MAX
)
{
return
false
;
}
if
(
mData
&
&
mCapacity
>
=
sizeNeeded
.
value
(
)
)
{
return
true
;
}
auto
newBuffer
=
MakeUniqueFallible
<
uint8_t
[
]
>
(
sizeNeeded
.
value
(
)
)
;
if
(
!
newBuffer
)
{
return
false
;
}
const
uintptr_t
alignmask
=
AlignmentOffset
(
)
;
Type
*
newData
=
reinterpret_cast
<
Type
*
>
(
(
reinterpret_cast
<
uintptr_t
>
(
newBuffer
.
get
(
)
)
+
alignmask
)
&
~
alignmask
)
;
MOZ_ASSERT
(
uintptr_t
(
newData
)
%
(
AlignmentOffset
(
)
+
1
)
=
=
0
)
;
MOZ_ASSERT
(
!
mLength
|
|
mData
)
;
PodZero
(
newData
+
mLength
aLength
-
mLength
)
;
if
(
mLength
)
{
PodCopy
(
newData
mData
mLength
)
;
}
mBuffer
=
std
:
:
move
(
newBuffer
)
;
mCapacity
=
sizeNeeded
.
value
(
)
;
mData
=
newData
;
return
true
;
}
Type
*
mData
;
size_t
mLength
;
UniquePtr
<
uint8_t
[
]
>
mBuffer
;
size_t
mCapacity
;
}
;
typedef
AlignedBuffer
<
uint8_t
>
AlignedByteBuffer
;
typedef
AlignedBuffer
<
float
>
AlignedFloatBuffer
;
typedef
AlignedBuffer
<
int16_t
>
AlignedShortBuffer
;
typedef
AlignedBuffer
<
AudioDataValue
>
AlignedAudioBuffer
;
class
MediaData
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaData
)
enum
class
Type
{
AUDIO_DATA
=
0
VIDEO_DATA
RAW_DATA
NULL_DATA
}
;
static
const
char
*
TypeToStr
(
Type
aType
)
{
switch
(
aType
)
{
case
Type
:
:
AUDIO_DATA
:
return
"
AUDIO_DATA
"
;
case
Type
:
:
VIDEO_DATA
:
return
"
VIDEO_DATA
"
;
case
Type
:
:
RAW_DATA
:
return
"
RAW_DATA
"
;
case
Type
:
:
NULL_DATA
:
return
"
NULL_DATA
"
;
default
:
MOZ_CRASH
(
"
bad
value
"
)
;
}
}
MediaData
(
Type
aType
int64_t
aOffset
const
media
:
:
TimeUnit
&
aTimestamp
const
media
:
:
TimeUnit
&
aDuration
)
:
mType
(
aType
)
mOffset
(
aOffset
)
mTime
(
aTimestamp
)
mTimecode
(
aTimestamp
)
mDuration
(
aDuration
)
mKeyframe
(
false
)
{
}
const
Type
mType
;
int64_t
mOffset
;
media
:
:
TimeUnit
mTime
;
media
:
:
TimeUnit
mTimecode
;
media
:
:
TimeUnit
mDuration
;
bool
mKeyframe
;
media
:
:
TimeUnit
GetEndTime
(
)
const
{
return
mTime
+
mDuration
;
}
virtual
bool
AdjustForStartTime
(
const
media
:
:
TimeUnit
&
aStartTime
)
{
mTime
-
=
aStartTime
;
MOZ_ASSERT
(
!
mTime
.
IsNegative
(
)
)
;
return
mTime
.
IsValid
(
)
;
}
template
<
typename
ReturnType
>
const
ReturnType
*
As
(
)
const
{
MOZ_ASSERT
(
this
-
>
mType
=
=
ReturnType
:
:
sType
)
;
return
static_cast
<
const
ReturnType
*
>
(
this
)
;
}
template
<
typename
ReturnType
>
ReturnType
*
As
(
)
{
MOZ_ASSERT
(
this
-
>
mType
=
=
ReturnType
:
:
sType
)
;
return
static_cast
<
ReturnType
*
>
(
this
)
;
}
protected
:
explicit
MediaData
(
Type
aType
)
:
mType
(
aType
)
mOffset
(
0
)
mKeyframe
(
false
)
{
}
virtual
~
MediaData
(
)
{
}
}
;
class
NullData
:
public
MediaData
{
public
:
NullData
(
int64_t
aOffset
const
media
:
:
TimeUnit
&
aTime
const
media
:
:
TimeUnit
&
aDuration
)
:
MediaData
(
Type
:
:
NULL_DATA
aOffset
aTime
aDuration
)
{
}
static
const
Type
sType
=
Type
:
:
NULL_DATA
;
}
;
class
AudioData
:
public
MediaData
{
public
:
AudioData
(
int64_t
aOffset
const
media
:
:
TimeUnit
&
aTime
AlignedAudioBuffer
&
&
aData
uint32_t
aChannels
uint32_t
aRate
uint32_t
aChannelMap
=
AudioConfig
:
:
ChannelLayout
:
:
UNKNOWN_MAP
)
;
static
const
Type
sType
=
Type
:
:
AUDIO_DATA
;
static
const
char
*
sTypeName
;
Span
<
AudioDataValue
>
Data
(
)
const
;
uint32_t
Frames
(
)
const
{
return
mFrames
;
}
bool
SetTrimWindow
(
const
media
:
:
TimeInterval
&
aTrim
)
;
AlignedAudioBuffer
MoveableData
(
)
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
void
EnsureAudioBuffer
(
)
;
bool
IsAudible
(
)
const
;
bool
AdjustForStartTime
(
const
media
:
:
TimeUnit
&
aStartTime
)
override
;
const
uint32_t
mChannels
;
const
AudioConfig
:
:
ChannelLayout
:
:
ChannelMap
mChannelMap
;
const
uint32_t
mRate
;
RefPtr
<
SharedBuffer
>
mAudioBuffer
;
protected
:
~
AudioData
(
)
{
}
private
:
AudioDataValue
*
GetAdjustedData
(
)
const
;
media
:
:
TimeUnit
mOriginalTime
;
AlignedAudioBuffer
mAudioData
;
Maybe
<
media
:
:
TimeInterval
>
mTrimWindow
;
uint32_t
mFrames
;
size_t
mDataOffset
=
0
;
}
;
namespace
layers
{
class
TextureClient
;
class
PlanarYCbCrImage
;
}
class
VideoInfo
;
class
VideoData
:
public
MediaData
{
public
:
typedef
gfx
:
:
IntRect
IntRect
;
typedef
gfx
:
:
IntSize
IntSize
;
typedef
gfx
:
:
ColorDepth
ColorDepth
;
typedef
gfx
:
:
YUVColorSpace
YUVColorSpace
;
typedef
layers
:
:
ImageContainer
ImageContainer
;
typedef
layers
:
:
Image
Image
;
typedef
layers
:
:
PlanarYCbCrImage
PlanarYCbCrImage
;
static
const
Type
sType
=
Type
:
:
VIDEO_DATA
;
static
const
char
*
sTypeName
;
struct
YCbCrBuffer
{
struct
Plane
{
uint8_t
*
mData
;
uint32_t
mWidth
;
uint32_t
mHeight
;
uint32_t
mStride
;
uint32_t
mOffset
;
uint32_t
mSkip
;
}
;
Plane
mPlanes
[
3
]
;
YUVColorSpace
mYUVColorSpace
=
YUVColorSpace
:
:
BT601
;
ColorDepth
mColorDepth
=
ColorDepth
:
:
COLOR_8
;
}
;
class
Listener
{
public
:
virtual
void
OnSentToCompositor
(
)
=
0
;
virtual
~
Listener
(
)
{
}
}
;
static
already_AddRefed
<
VideoData
>
CreateAndCopyData
(
const
VideoInfo
&
aInfo
ImageContainer
*
aContainer
int64_t
aOffset
const
media
:
:
TimeUnit
&
aTime
const
media
:
:
TimeUnit
&
aDuration
const
YCbCrBuffer
&
aBuffer
bool
aKeyframe
const
media
:
:
TimeUnit
&
aTimecode
const
IntRect
&
aPicture
layers
:
:
KnowsCompositor
*
aAllocator
=
nullptr
)
;
static
already_AddRefed
<
VideoData
>
CreateAndCopyData
(
const
VideoInfo
&
aInfo
ImageContainer
*
aContainer
int64_t
aOffset
const
media
:
:
TimeUnit
&
aTime
const
media
:
:
TimeUnit
&
aDuration
const
YCbCrBuffer
&
aBuffer
const
YCbCrBuffer
:
:
Plane
&
aAlphaPlane
bool
aKeyframe
const
media
:
:
TimeUnit
&
aTimecode
const
IntRect
&
aPicture
)
;
static
already_AddRefed
<
VideoData
>
CreateFromImage
(
const
IntSize
&
aDisplay
int64_t
aOffset
const
media
:
:
TimeUnit
&
aTime
const
media
:
:
TimeUnit
&
aDuration
const
RefPtr
<
Image
>
&
aImage
bool
aKeyframe
const
media
:
:
TimeUnit
&
aTimecode
)
;
static
bool
SetVideoDataToImage
(
PlanarYCbCrImage
*
aVideoImage
const
VideoInfo
&
aInfo
const
YCbCrBuffer
&
aBuffer
const
IntRect
&
aPicture
bool
aCopyData
)
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
const
IntSize
mDisplay
;
RefPtr
<
Image
>
mImage
;
int32_t
mFrameID
;
VideoData
(
int64_t
aOffset
const
media
:
:
TimeUnit
&
aTime
const
media
:
:
TimeUnit
&
aDuration
bool
aKeyframe
const
media
:
:
TimeUnit
&
aTimecode
IntSize
aDisplay
uint32_t
aFrameID
)
;
void
SetListener
(
UniquePtr
<
Listener
>
aListener
)
;
void
MarkSentToCompositor
(
)
;
bool
IsSentToCompositor
(
)
{
return
mSentToCompositor
;
}
void
UpdateDuration
(
const
media
:
:
TimeUnit
&
aDuration
)
;
void
UpdateTimestamp
(
const
media
:
:
TimeUnit
&
aTimestamp
)
;
void
SetNextKeyFrameTime
(
const
media
:
:
TimeUnit
&
aTime
)
{
mNextKeyFrameTime
=
aTime
;
}
const
media
:
:
TimeUnit
&
NextKeyFrameTime
(
)
const
{
return
mNextKeyFrameTime
;
}
protected
:
~
VideoData
(
)
;
bool
mSentToCompositor
;
UniquePtr
<
Listener
>
mListener
;
media
:
:
TimeUnit
mNextKeyFrameTime
;
}
;
enum
class
CryptoScheme
:
uint8_t
{
None
Cenc
Cbcs
}
;
class
CryptoTrack
{
public
:
CryptoTrack
(
)
:
mCryptoScheme
(
CryptoScheme
:
:
None
)
mIVSize
(
0
)
mCryptByteBlock
(
0
)
mSkipByteBlock
(
0
)
{
}
CryptoScheme
mCryptoScheme
;
int32_t
mIVSize
;
nsTArray
<
uint8_t
>
mKeyId
;
uint8_t
mCryptByteBlock
;
uint8_t
mSkipByteBlock
;
nsTArray
<
uint8_t
>
mConstantIV
;
bool
IsEncrypted
(
)
const
{
return
mCryptoScheme
!
=
CryptoScheme
:
:
None
;
}
}
;
class
CryptoSample
:
public
CryptoTrack
{
public
:
nsTArray
<
uint16_t
>
mPlainSizes
;
nsTArray
<
uint32_t
>
mEncryptedSizes
;
nsTArray
<
uint8_t
>
mIV
;
nsTArray
<
nsTArray
<
uint8_t
>
>
mInitDatas
;
nsString
mInitDataType
;
}
;
class
MediaRawData
;
class
MediaRawDataWriter
{
public
:
uint8_t
*
Data
(
)
;
size_t
Size
(
)
;
CryptoSample
&
mCrypto
;
MOZ_MUST_USE
bool
SetSize
(
size_t
aSize
)
;
MOZ_MUST_USE
bool
Prepend
(
const
uint8_t
*
aData
size_t
aSize
)
;
MOZ_MUST_USE
bool
Append
(
const
uint8_t
*
aData
size_t
aSize
)
;
MOZ_MUST_USE
bool
Replace
(
const
uint8_t
*
aData
size_t
aSize
)
;
void
Clear
(
)
;
void
PopFront
(
size_t
aSize
)
;
private
:
friend
class
MediaRawData
;
explicit
MediaRawDataWriter
(
MediaRawData
*
aMediaRawData
)
;
MOZ_MUST_USE
bool
EnsureSize
(
size_t
aSize
)
;
MediaRawData
*
mTarget
;
}
;
class
MediaRawData
final
:
public
MediaData
{
public
:
MediaRawData
(
)
;
MediaRawData
(
const
uint8_t
*
aData
size_t
aSize
)
;
MediaRawData
(
const
uint8_t
*
aData
size_t
aSize
const
uint8_t
*
aAlphaData
size_t
aAlphaSize
)
;
const
uint8_t
*
Data
(
)
const
{
return
mBuffer
.
Data
(
)
;
}
const
uint8_t
*
AlphaData
(
)
const
{
return
mAlphaBuffer
.
Data
(
)
;
}
size_t
Size
(
)
const
{
return
mBuffer
.
Length
(
)
;
}
size_t
AlphaSize
(
)
const
{
return
mAlphaBuffer
.
Length
(
)
;
}
size_t
ComputedSizeOfIncludingThis
(
)
const
{
return
sizeof
(
*
this
)
+
mBuffer
.
ComputedSizeOfExcludingThis
(
)
+
mAlphaBuffer
.
ComputedSizeOfExcludingThis
(
)
;
}
operator
Span
<
const
uint8_t
>
(
)
{
return
MakeSpan
(
Data
(
)
Size
(
)
)
;
}
const
CryptoSample
&
mCrypto
;
RefPtr
<
MediaByteBuffer
>
mExtraData
;
bool
mEOS
=
false
;
uint32_t
mDiscardPadding
=
0
;
RefPtr
<
TrackInfoSharedPtr
>
mTrackInfo
;
Maybe
<
media
:
:
TimeInterval
>
mOriginalPresentationWindow
;
already_AddRefed
<
MediaRawData
>
Clone
(
)
const
;
UniquePtr
<
MediaRawDataWriter
>
CreateWriter
(
)
;
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
protected
:
~
MediaRawData
(
)
;
private
:
friend
class
MediaRawDataWriter
;
AlignedByteBuffer
mBuffer
;
AlignedByteBuffer
mAlphaBuffer
;
CryptoSample
mCryptoInternal
;
MediaRawData
(
const
MediaRawData
&
)
;
}
;
class
MediaByteBuffer
:
public
nsTArray
<
uint8_t
>
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MediaByteBuffer
)
;
MediaByteBuffer
(
)
=
default
;
explicit
MediaByteBuffer
(
size_t
aCapacity
)
:
nsTArray
<
uint8_t
>
(
aCapacity
)
{
}
private
:
~
MediaByteBuffer
(
)
{
}
}
;
}
#
endif
