#
ifndef
VideoOutput_h
#
define
VideoOutput_h
#
include
"
MediaTrackListener
.
h
"
#
include
"
VideoFrameContainer
.
h
"
namespace
mozilla
{
using
layers
:
:
Image
;
using
layers
:
:
ImageContainer
;
using
layers
:
:
PlanarYCbCrData
;
using
layers
:
:
PlanarYCbCrImage
;
static
bool
SetImageToBlackPixel
(
PlanarYCbCrImage
*
aImage
)
{
uint8_t
blackPixel
[
]
=
{
0x10
0x80
0x80
}
;
PlanarYCbCrData
data
;
data
.
mYChannel
=
blackPixel
;
data
.
mCbChannel
=
blackPixel
+
1
;
data
.
mCrChannel
=
blackPixel
+
2
;
data
.
mYStride
=
data
.
mCbCrStride
=
1
;
data
.
mPicSize
=
data
.
mYSize
=
data
.
mCbCrSize
=
gfx
:
:
IntSize
(
1
1
)
;
data
.
mYUVColorSpace
=
gfx
:
:
YUVColorSpace
:
:
BT601
;
data
.
mColorRange
=
gfx
:
:
ColorRange
:
:
LIMITED
;
return
aImage
-
>
CopyData
(
data
)
;
}
class
VideoOutput
:
public
DirectMediaTrackListener
{
protected
:
virtual
~
VideoOutput
(
)
=
default
;
void
DropPastFrames
(
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
size_t
nrChunksInPast
=
0
;
for
(
const
auto
&
idChunkPair
:
mFrames
)
{
const
VideoChunk
&
chunk
=
idChunkPair
.
second
;
if
(
chunk
.
mTimeStamp
>
now
)
{
break
;
}
+
+
nrChunksInPast
;
}
if
(
nrChunksInPast
>
1
)
{
mFrames
.
RemoveElementsAt
(
0
nrChunksInPast
-
1
)
;
}
}
void
SendFramesEnsureLocked
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
SendFrames
(
)
;
}
void
SendFrames
(
)
{
DropPastFrames
(
)
;
if
(
mFrames
.
IsEmpty
(
)
)
{
return
;
}
AutoTArray
<
ImageContainer
:
:
NonOwningImage
16
>
images
;
PrincipalHandle
lastPrincipalHandle
=
PRINCIPAL_HANDLE_NONE
;
for
(
const
auto
&
idChunkPair
:
mFrames
)
{
ImageContainer
:
:
FrameID
frameId
=
idChunkPair
.
first
;
const
VideoChunk
&
chunk
=
idChunkPair
.
second
;
const
VideoFrame
&
frame
=
chunk
.
mFrame
;
Image
*
image
=
frame
.
GetImage
(
)
;
if
(
frame
.
GetForceBlack
(
)
|
|
!
mEnabled
)
{
if
(
!
mBlackImage
)
{
RefPtr
<
Image
>
blackImage
=
mVideoFrameContainer
-
>
GetImageContainer
(
)
-
>
CreatePlanarYCbCrImage
(
)
;
if
(
blackImage
)
{
if
(
SetImageToBlackPixel
(
blackImage
-
>
AsPlanarYCbCrImage
(
)
)
)
{
mBlackImage
=
blackImage
;
}
}
}
if
(
mBlackImage
)
{
image
=
mBlackImage
;
}
}
if
(
!
image
)
{
continue
;
}
images
.
AppendElement
(
ImageContainer
:
:
NonOwningImage
(
image
chunk
.
mTimeStamp
frameId
mProducerID
)
)
;
lastPrincipalHandle
=
chunk
.
GetPrincipalHandle
(
)
;
}
if
(
images
.
IsEmpty
(
)
)
{
mVideoFrameContainer
-
>
ClearFutureFrames
(
)
;
return
;
}
bool
principalHandleChanged
=
lastPrincipalHandle
!
=
PRINCIPAL_HANDLE_NONE
&
&
lastPrincipalHandle
!
=
mVideoFrameContainer
-
>
GetLastPrincipalHandle
(
)
;
if
(
principalHandleChanged
)
{
mVideoFrameContainer
-
>
UpdatePrincipalHandleForFrameID
(
lastPrincipalHandle
images
.
LastElement
(
)
.
mFrameID
)
;
}
mVideoFrameContainer
-
>
SetCurrentFrames
(
mFrames
[
0
]
.
second
.
mFrame
.
GetIntrinsicSize
(
)
images
)
;
mMainThread
-
>
Dispatch
(
NewRunnableMethod
(
"
VideoFrameContainer
:
:
Invalidate
"
mVideoFrameContainer
&
VideoFrameContainer
:
:
Invalidate
)
)
;
}
public
:
VideoOutput
(
VideoFrameContainer
*
aContainer
AbstractThread
*
aMainThread
)
:
mMutex
(
"
VideoOutput
:
:
mMutex
"
)
mVideoFrameContainer
(
aContainer
)
mMainThread
(
aMainThread
)
{
}
void
NotifyRealtimeTrackData
(
MediaTrackGraph
*
aGraph
TrackTime
aTrackOffset
const
MediaSegment
&
aMedia
)
override
{
MOZ_ASSERT
(
aMedia
.
GetType
(
)
=
=
MediaSegment
:
:
VIDEO
)
;
const
VideoSegment
&
video
=
static_cast
<
const
VideoSegment
&
>
(
aMedia
)
;
MutexAutoLock
lock
(
mMutex
)
;
for
(
VideoSegment
:
:
ConstChunkIterator
i
(
video
)
;
!
i
.
IsEnded
(
)
;
i
.
Next
(
)
)
{
if
(
!
mLastFrameTime
.
IsNull
(
)
&
&
i
-
>
mTimeStamp
<
mLastFrameTime
)
{
mFrames
.
ClearAndRetainStorage
(
)
;
}
mFrames
.
AppendElement
(
std
:
:
make_pair
(
mVideoFrameContainer
-
>
NewFrameID
(
)
*
i
)
)
;
mLastFrameTime
=
i
-
>
mTimeStamp
;
}
SendFramesEnsureLocked
(
)
;
}
void
NotifyRemoved
(
MediaTrackGraph
*
aGraph
)
override
{
if
(
mFrames
.
Length
(
)
<
=
1
)
{
mFrames
.
ClearAndRetainStorage
(
)
;
mVideoFrameContainer
-
>
ClearFutureFrames
(
)
;
return
;
}
DropPastFrames
(
)
;
mFrames
.
RemoveLastElements
(
mFrames
.
Length
(
)
-
1
)
;
SendFrames
(
)
;
mFrames
.
ClearAndRetainStorage
(
)
;
}
void
NotifyEnded
(
MediaTrackGraph
*
aGraph
)
override
{
if
(
mFrames
.
IsEmpty
(
)
)
{
return
;
}
mFrames
.
RemoveElementsAt
(
0
mFrames
.
Length
(
)
-
1
)
;
SendFrames
(
)
;
mFrames
.
ClearAndRetainStorage
(
)
;
}
void
NotifyEnabledStateChanged
(
MediaTrackGraph
*
aGraph
bool
aEnabled
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
mEnabled
=
aEnabled
;
DropPastFrames
(
)
;
if
(
!
mEnabled
|
|
mFrames
.
Length
(
)
>
1
)
{
for
(
auto
&
idChunkPair
:
mFrames
)
{
idChunkPair
.
first
=
mVideoFrameContainer
-
>
NewFrameID
(
)
;
}
SendFramesEnsureLocked
(
)
;
}
}
Mutex
mMutex
;
TimeStamp
mLastFrameTime
;
RefPtr
<
Image
>
mBlackImage
;
bool
mEnabled
=
true
;
nsTArray
<
std
:
:
pair
<
ImageContainer
:
:
FrameID
VideoChunk
>
>
mFrames
;
const
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
const
RefPtr
<
AbstractThread
>
mMainThread
;
const
layers
:
:
ImageContainer
:
:
ProducerID
mProducerID
=
layers
:
:
ImageContainer
:
:
AllocateProducerID
(
)
;
}
;
}
#
endif
