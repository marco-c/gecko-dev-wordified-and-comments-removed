#
ifndef
mozilla_dom_SourceBuffer_h_
#
define
mozilla_dom_SourceBuffer_h_
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
MediaSource
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
dom
/
SourceBufferBinding
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionNoteChild
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nscore
.
h
"
#
include
"
SourceBufferContentManager
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
class
JSObject
;
struct
JSContext
;
namespace
mozilla
{
class
ErrorResult
;
class
MediaByteBuffer
;
template
<
typename
T
>
class
AsyncEventRunner
;
class
TrackBuffersManager
;
namespace
dom
{
class
TimeRanges
;
class
SourceBufferAttributes
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SourceBufferAttributes
)
;
explicit
SourceBufferAttributes
(
bool
aGenerateTimestamp
)
:
mGenerateTimestamps
(
aGenerateTimestamp
)
mMonitor
(
"
SourceBufferAttributes
"
)
mAppendWindowStart
(
0
)
mAppendWindowEnd
(
PositiveInfinity
<
double
>
(
)
)
mAppendMode
(
SourceBufferAppendMode
:
:
Segments
)
mApparentTimestampOffset
(
0
)
{
}
double
GetAppendWindowStart
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
return
mAppendWindowStart
;
}
double
GetAppendWindowEnd
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
return
mAppendWindowEnd
;
}
void
SetAppendWindowStart
(
double
aWindowStart
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
mAppendWindowStart
=
aWindowStart
;
}
void
SetAppendWindowEnd
(
double
aWindowEnd
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
mAppendWindowEnd
=
aWindowEnd
;
}
double
GetApparentTimestampOffset
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
return
mApparentTimestampOffset
;
}
void
SetApparentTimestampOffset
(
double
aTimestampOffset
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
mApparentTimestampOffset
=
aTimestampOffset
;
mTimestampOffset
=
media
:
:
TimeUnit
:
:
FromSeconds
(
aTimestampOffset
)
;
}
media
:
:
TimeUnit
GetTimestampOffset
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
return
mTimestampOffset
;
}
void
SetTimestampOffset
(
media
:
:
TimeUnit
&
aTimestampOffset
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
mTimestampOffset
=
aTimestampOffset
;
mApparentTimestampOffset
=
aTimestampOffset
.
ToSeconds
(
)
;
}
SourceBufferAppendMode
GetAppendMode
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
return
mAppendMode
;
}
void
SetAppendMode
(
SourceBufferAppendMode
aAppendMode
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
mAppendMode
=
aAppendMode
;
}
const
bool
mGenerateTimestamps
;
private
:
~
SourceBufferAttributes
(
)
{
}
;
Monitor
mMonitor
;
double
mAppendWindowStart
;
double
mAppendWindowEnd
;
SourceBufferAppendMode
mAppendMode
;
double
mApparentTimestampOffset
;
media
:
:
TimeUnit
mTimestampOffset
;
}
;
class
SourceBuffer
final
:
public
DOMEventTargetHelper
{
public
:
SourceBufferAppendMode
Mode
(
)
const
{
return
mAttributes
-
>
GetAppendMode
(
)
;
}
void
SetMode
(
SourceBufferAppendMode
aMode
ErrorResult
&
aRv
)
;
bool
Updating
(
)
const
{
return
mUpdating
;
}
TimeRanges
*
GetBuffered
(
ErrorResult
&
aRv
)
;
media
:
:
TimeIntervals
GetTimeIntervals
(
)
;
double
TimestampOffset
(
)
const
{
return
mAttributes
-
>
GetApparentTimestampOffset
(
)
;
}
void
SetTimestampOffset
(
double
aTimestampOffset
ErrorResult
&
aRv
)
;
double
AppendWindowStart
(
)
const
{
return
mAttributes
-
>
GetAppendWindowStart
(
)
;
}
void
SetAppendWindowStart
(
double
aAppendWindowStart
ErrorResult
&
aRv
)
;
double
AppendWindowEnd
(
)
const
{
return
mAttributes
-
>
GetAppendWindowEnd
(
)
;
}
void
SetAppendWindowEnd
(
double
aAppendWindowEnd
ErrorResult
&
aRv
)
;
void
AppendBuffer
(
const
ArrayBuffer
&
aData
ErrorResult
&
aRv
)
;
void
AppendBuffer
(
const
ArrayBufferView
&
aData
ErrorResult
&
aRv
)
;
void
Abort
(
ErrorResult
&
aRv
)
;
void
AbortBufferAppend
(
)
;
void
Remove
(
double
aStart
double
aEnd
ErrorResult
&
aRv
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
SourceBuffer
DOMEventTargetHelper
)
SourceBuffer
(
MediaSource
*
aMediaSource
const
nsACString
&
aType
)
;
MediaSource
*
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
void
Detach
(
)
;
bool
IsAttached
(
)
const
{
return
mMediaSource
!
=
nullptr
;
}
void
Ended
(
)
;
void
Evict
(
double
aStart
double
aEnd
)
;
double
GetBufferedStart
(
)
;
double
GetBufferedEnd
(
)
;
void
RangeRemoval
(
double
aStart
double
aEnd
)
;
bool
IsActive
(
)
const
{
return
mActive
;
}
#
if
defined
(
DEBUG
)
void
Dump
(
const
char
*
aPath
)
;
#
endif
private
:
~
SourceBuffer
(
)
;
friend
class
AsyncEventRunner
<
SourceBuffer
>
;
friend
class
BufferAppendRunnable
;
friend
class
mozilla
:
:
TrackBuffersManager
;
void
DispatchSimpleEvent
(
const
char
*
aName
)
;
void
QueueAsyncSimpleEvent
(
const
char
*
aName
)
;
void
StartUpdating
(
)
;
void
StopUpdating
(
)
;
void
AbortUpdating
(
)
;
void
CheckEndTime
(
)
;
void
AppendData
(
const
uint8_t
*
aData
uint32_t
aLength
ErrorResult
&
aRv
)
;
void
BufferAppend
(
uint32_t
aAppendID
)
;
void
AppendError
(
bool
aDecoderError
)
;
already_AddRefed
<
MediaByteBuffer
>
PrepareAppend
(
const
uint8_t
*
aData
uint32_t
aLength
ErrorResult
&
aRv
)
;
void
AppendDataCompletedWithSuccess
(
bool
aHasActiveTracks
)
;
void
AppendDataErrored
(
nsresult
aError
)
;
RefPtr
<
MediaSource
>
mMediaSource
;
uint32_t
mEvictionThreshold
;
RefPtr
<
SourceBufferContentManager
>
mContentManager
;
RefPtr
<
SourceBufferAttributes
>
mAttributes
;
bool
mUpdating
;
mozilla
:
:
Atomic
<
bool
>
mActive
;
uint32_t
mUpdateID
;
int64_t
mReportedOffset
;
MozPromiseRequestHolder
<
SourceBufferContentManager
:
:
AppendPromise
>
mPendingAppend
;
const
nsCString
mType
;
RefPtr
<
TimeRanges
>
mBuffered
;
}
;
}
}
#
endif
