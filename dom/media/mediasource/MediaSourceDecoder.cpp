#
include
"
MediaSourceDecoder
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
MediaDecoderStateMachine
.
h
"
#
include
"
MediaShutdownManager
.
h
"
#
include
"
MediaSource
.
h
"
#
include
"
MediaSourceDemuxer
.
h
"
#
include
"
MediaSourceUtils
.
h
"
#
include
"
SourceBuffer
.
h
"
#
include
"
SourceBufferList
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
<
algorithm
>
extern
mozilla
:
:
LogModule
*
GetMediaSourceLog
(
)
;
#
define
MSE_DEBUG
(
arg
.
.
.
)
\
DDMOZ_LOG
(
GetMediaSourceLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
"
:
:
%
s
:
"
arg
\
__func__
#
#
__VA_ARGS__
)
#
define
MSE_DEBUGV
(
arg
.
.
.
)
\
DDMOZ_LOG
(
GetMediaSourceLog
(
)
mozilla
:
:
LogLevel
:
:
Verbose
"
:
:
%
s
:
"
arg
\
__func__
#
#
__VA_ARGS__
)
using
namespace
mozilla
:
:
media
;
namespace
mozilla
{
MediaSourceDecoder
:
:
MediaSourceDecoder
(
MediaDecoderInit
&
aInit
)
:
MediaDecoder
(
aInit
)
mMediaSource
(
nullptr
)
mEnded
(
false
)
{
mExplicitDuration
.
emplace
(
UnspecifiedNaN
<
double
>
(
)
)
;
}
MediaDecoderStateMachine
*
MediaSourceDecoder
:
:
CreateStateMachine
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mDemuxer
=
new
MediaSourceDemuxer
(
AbstractMainThread
(
)
)
;
MediaFormatReaderInit
init
;
init
.
mVideoFrameContainer
=
GetVideoFrameContainer
(
)
;
init
.
mKnowsCompositor
=
GetCompositor
(
)
;
init
.
mCrashHelper
=
GetOwner
(
)
-
>
CreateGMPCrashHelper
(
)
;
init
.
mFrameStats
=
mFrameStats
;
init
.
mMediaDecoderOwnerID
=
mOwner
;
mReader
=
new
MediaFormatReader
(
init
mDemuxer
)
;
return
new
MediaDecoderStateMachine
(
this
mReader
)
;
}
nsresult
MediaSourceDecoder
:
:
Load
(
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
GetStateMachine
(
)
)
;
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
mPrincipal
=
aPrincipal
;
nsresult
rv
=
MediaShutdownManager
:
:
Instance
(
)
.
Register
(
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
SetStateMachine
(
CreateStateMachine
(
)
)
;
if
(
!
GetStateMachine
(
)
)
{
NS_WARNING
(
"
Failed
to
create
state
machine
!
"
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
GetStateMachine
(
)
-
>
Init
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
GetStateMachine
(
)
-
>
DispatchIsLiveStream
(
!
mEnded
)
;
SetStateMachineParameters
(
)
;
return
NS_OK
;
}
media
:
:
TimeIntervals
MediaSourceDecoder
:
:
GetSeekable
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
if
(
!
mMediaSource
)
{
NS_WARNING
(
"
MediaSource
element
isn
'
t
attached
"
)
;
return
media
:
:
TimeIntervals
:
:
Invalid
(
)
;
}
media
:
:
TimeIntervals
seekable
;
double
duration
=
mMediaSource
-
>
Duration
(
)
;
if
(
IsNaN
(
duration
)
)
{
}
else
if
(
duration
>
0
&
&
mozilla
:
:
IsInfinite
(
duration
)
)
{
media
:
:
TimeIntervals
buffered
=
GetBuffered
(
)
;
if
(
mMediaSource
-
>
HasLiveSeekableRange
(
)
)
{
media
:
:
TimeIntervals
unionRanges
=
buffered
+
mMediaSource
-
>
LiveSeekableRange
(
)
;
seekable
+
=
media
:
:
TimeInterval
(
unionRanges
.
GetStart
(
)
unionRanges
.
GetEnd
(
)
)
;
return
seekable
;
}
if
(
buffered
.
Length
(
)
)
{
seekable
+
=
media
:
:
TimeInterval
(
TimeUnit
:
:
Zero
(
)
buffered
.
GetEnd
(
)
)
;
}
}
else
{
seekable
+
=
media
:
:
TimeInterval
(
TimeUnit
:
:
Zero
(
)
TimeUnit
:
:
FromSeconds
(
duration
)
)
;
}
MSE_DEBUG
(
"
ranges
=
%
s
"
DumpTimeRanges
(
seekable
)
.
get
(
)
)
;
return
seekable
;
}
media
:
:
TimeIntervals
MediaSourceDecoder
:
:
GetBuffered
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
if
(
!
mMediaSource
)
{
NS_WARNING
(
"
MediaSource
element
isn
'
t
attached
"
)
;
return
media
:
:
TimeIntervals
:
:
Invalid
(
)
;
}
dom
:
:
SourceBufferList
*
sourceBuffers
=
mMediaSource
-
>
ActiveSourceBuffers
(
)
;
if
(
!
sourceBuffers
)
{
return
TimeIntervals
(
)
;
}
TimeUnit
highestEndTime
;
nsTArray
<
media
:
:
TimeIntervals
>
activeRanges
;
media
:
:
TimeIntervals
buffered
;
for
(
uint32_t
i
=
0
;
i
<
sourceBuffers
-
>
Length
(
)
;
i
+
+
)
{
bool
found
;
dom
:
:
SourceBuffer
*
sb
=
sourceBuffers
-
>
IndexedGetter
(
i
found
)
;
MOZ_ASSERT
(
found
)
;
activeRanges
.
AppendElement
(
sb
-
>
GetTimeIntervals
(
)
)
;
highestEndTime
=
std
:
:
max
(
highestEndTime
activeRanges
.
LastElement
(
)
.
GetEnd
(
)
)
;
}
buffered
+
=
media
:
:
TimeInterval
(
TimeUnit
:
:
Zero
(
)
highestEndTime
)
;
for
(
auto
&
range
:
activeRanges
)
{
if
(
mEnded
&
&
range
.
Length
(
)
)
{
range
+
=
media
:
:
TimeInterval
(
range
.
GetEnd
(
)
highestEndTime
)
;
}
buffered
.
Intersection
(
range
)
;
}
MSE_DEBUG
(
"
ranges
=
%
s
"
DumpTimeRanges
(
buffered
)
.
get
(
)
)
;
return
buffered
;
}
void
MediaSourceDecoder
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
MSE_DEBUG
(
"
Shutdown
"
)
;
if
(
mMediaSource
)
{
mMediaSource
-
>
Detach
(
)
;
}
mDemuxer
=
nullptr
;
MediaDecoder
:
:
Shutdown
(
)
;
}
void
MediaSourceDecoder
:
:
AttachMediaSource
(
dom
:
:
MediaSource
*
aMediaSource
)
{
MOZ_ASSERT
(
!
mMediaSource
&
&
!
GetStateMachine
(
)
&
&
NS_IsMainThread
(
)
)
;
mMediaSource
=
aMediaSource
;
DDLINKCHILD
(
"
mediasource
"
aMediaSource
)
;
}
void
MediaSourceDecoder
:
:
DetachMediaSource
(
)
{
MOZ_ASSERT
(
mMediaSource
&
&
NS_IsMainThread
(
)
)
;
DDUNLINKCHILD
(
mMediaSource
)
;
mMediaSource
=
nullptr
;
}
void
MediaSourceDecoder
:
:
Ended
(
bool
aEnded
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
if
(
aEnded
)
{
NotifyDataArrived
(
)
;
}
mEnded
=
aEnded
;
GetStateMachine
(
)
-
>
DispatchIsLiveStream
(
!
mEnded
)
;
}
void
MediaSourceDecoder
:
:
AddSizeOfResources
(
ResourceSizes
*
aSizes
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
if
(
GetDemuxer
(
)
)
{
GetDemuxer
(
)
-
>
AddSizeOfResources
(
aSizes
)
;
}
}
void
MediaSourceDecoder
:
:
SetInitialDuration
(
int64_t
aDuration
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
if
(
!
mMediaSource
|
|
!
IsNaN
(
ExplicitDuration
(
)
)
)
{
return
;
}
double
duration
=
aDuration
;
if
(
aDuration
>
=
0
)
{
duration
/
=
USECS_PER_S
;
}
SetMediaSourceDuration
(
duration
)
;
}
void
MediaSourceDecoder
:
:
SetMediaSourceDuration
(
double
aDuration
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
MOZ_ASSERT
(
!
IsShutdown
(
)
)
;
if
(
aDuration
>
=
0
)
{
int64_t
checkedDuration
;
if
(
NS_FAILED
(
SecondsToUsecs
(
aDuration
checkedDuration
)
)
)
{
checkedDuration
=
INT64_MAX
-
1
;
}
SetExplicitDuration
(
aDuration
)
;
}
else
{
SetExplicitDuration
(
PositiveInfinity
<
double
>
(
)
)
;
}
}
void
MediaSourceDecoder
:
:
GetDebugInfo
(
dom
:
:
MediaSourceDecoderDebugInfo
&
aInfo
)
{
if
(
mReader
&
&
mDemuxer
)
{
mReader
-
>
GetDebugInfo
(
aInfo
.
mReader
)
;
mDemuxer
-
>
GetDebugInfo
(
aInfo
.
mDemuxer
)
;
}
}
double
MediaSourceDecoder
:
:
GetDuration
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
return
ExplicitDuration
(
)
;
}
MediaDecoderOwner
:
:
NextFrameStatus
MediaSourceDecoder
:
:
NextFrameBufferedStatus
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
if
(
!
mMediaSource
|
|
mMediaSource
-
>
ReadyState
(
)
=
=
dom
:
:
MediaSourceReadyState
:
:
Closed
)
{
return
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE
;
}
auto
currentPosition
=
CurrentPosition
(
)
;
TimeIntervals
buffered
=
GetBuffered
(
)
;
buffered
.
SetFuzz
(
MediaSourceDemuxer
:
:
EOS_FUZZ
/
2
)
;
TimeInterval
interval
(
currentPosition
currentPosition
+
DEFAULT_NEXT_FRAME_AVAILABLE_BUFFERED
)
;
return
buffered
.
ContainsWithStrictEnd
(
ClampIntervalToEnd
(
interval
)
)
?
MediaDecoderOwner
:
:
NEXT_FRAME_AVAILABLE
:
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE
;
}
bool
MediaSourceDecoder
:
:
CanPlayThroughImpl
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
if
(
NextFrameBufferedStatus
(
)
=
=
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE
)
{
return
false
;
}
if
(
IsNaN
(
mMediaSource
-
>
Duration
(
)
)
)
{
return
false
;
}
TimeUnit
duration
=
TimeUnit
:
:
FromSeconds
(
mMediaSource
-
>
Duration
(
)
)
;
auto
currentPosition
=
CurrentPosition
(
)
;
if
(
duration
<
=
currentPosition
)
{
return
true
;
}
TimeIntervals
buffered
=
GetBuffered
(
)
;
buffered
.
SetFuzz
(
MediaSourceDemuxer
:
:
EOS_FUZZ
/
2
)
;
TimeUnit
timeAhead
=
std
:
:
min
(
duration
currentPosition
+
TimeUnit
:
:
FromSeconds
(
3
)
)
;
TimeInterval
interval
(
currentPosition
timeAhead
)
;
return
buffered
.
ContainsWithStrictEnd
(
ClampIntervalToEnd
(
interval
)
)
;
}
TimeInterval
MediaSourceDecoder
:
:
ClampIntervalToEnd
(
const
TimeInterval
&
aInterval
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
if
(
!
mEnded
)
{
return
aInterval
;
}
TimeUnit
duration
=
TimeUnit
:
:
FromSeconds
(
GetDuration
(
)
)
;
if
(
duration
<
aInterval
.
mStart
)
{
return
aInterval
;
}
return
TimeInterval
(
aInterval
.
mStart
std
:
:
min
(
aInterval
.
mEnd
duration
)
aInterval
.
mFuzz
)
;
}
void
MediaSourceDecoder
:
:
NotifyInitDataArrived
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
if
(
mDemuxer
)
{
mDemuxer
-
>
NotifyInitDataArrived
(
)
;
}
}
void
MediaSourceDecoder
:
:
NotifyDataArrived
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsShutdown
(
)
)
;
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
NotifyReaderDataArrived
(
)
;
GetOwner
(
)
-
>
DownloadProgressed
(
)
;
}
already_AddRefed
<
nsIPrincipal
>
MediaSourceDecoder
:
:
GetCurrentPrincipal
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
do_AddRef
(
mPrincipal
)
;
}
#
undef
MSE_DEBUG
#
undef
MSE_DEBUGV
}
