#
ifndef
MOZILLA_MEDIASOURCEDECODER_H_
#
define
MOZILLA_MEDIASOURCEDECODER_H_
#
include
"
MediaDecoder
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
namespace
mozilla
{
class
MediaDecoderStateMachine
;
class
MediaSourceDemuxer
;
namespace
dom
{
class
MediaSource
;
}
DDLoggedTypeDeclNameAndBase
(
MediaSourceDecoder
MediaDecoder
)
;
class
MediaSourceDecoder
:
public
MediaDecoder
public
DecoderDoctorLifeLogger
<
MediaSourceDecoder
>
{
public
:
explicit
MediaSourceDecoder
(
MediaDecoderInit
&
aInit
)
;
nsresult
Load
(
nsIPrincipal
*
aPrincipal
)
;
media
:
:
TimeIntervals
GetSeekable
(
)
override
;
media
:
:
TimeIntervals
GetBuffered
(
)
override
;
void
Shutdown
(
)
override
;
void
AttachMediaSource
(
dom
:
:
MediaSource
*
aMediaSource
)
;
void
DetachMediaSource
(
)
;
void
Ended
(
bool
aEnded
)
;
double
GetDuration
(
)
override
;
void
SetInitialDuration
(
int64_t
aDuration
)
;
void
SetMediaSourceDuration
(
double
aDuration
)
;
MediaSourceDemuxer
*
GetDemuxer
(
)
{
return
mDemuxer
;
}
already_AddRefed
<
nsIPrincipal
>
GetCurrentPrincipal
(
)
override
;
bool
IsTransportSeekable
(
)
override
{
return
true
;
}
void
GetMozDebugReaderData
(
nsACString
&
aString
)
override
;
void
AddSizeOfResources
(
ResourceSizes
*
aSizes
)
override
;
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameBufferedStatus
(
)
override
;
bool
IsMSE
(
)
const
override
{
return
true
;
}
void
NotifyInitDataArrived
(
)
;
void
NotifyDataArrived
(
)
;
private
:
void
PinForSeek
(
)
override
{
}
void
UnpinForSeek
(
)
override
{
}
MediaDecoderStateMachine
*
CreateStateMachine
(
)
;
void
DoSetMediaSourceDuration
(
double
aDuration
)
;
media
:
:
TimeInterval
ClampIntervalToEnd
(
const
media
:
:
TimeInterval
&
aInterval
)
;
bool
CanPlayThroughImpl
(
)
override
;
bool
IsLiveStream
(
)
override
final
{
return
!
mEnded
;
}
RefPtr
<
nsIPrincipal
>
mPrincipal
;
dom
:
:
MediaSource
*
mMediaSource
;
RefPtr
<
MediaSourceDemuxer
>
mDemuxer
;
bool
mEnded
;
}
;
}
#
endif
