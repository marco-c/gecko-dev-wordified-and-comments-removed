#
ifndef
MOZILLA_TRACKBUFFERSMANAGER_H_
#
define
MOZILLA_TRACKBUFFERSMANAGER_H_
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Pair
.
h
"
#
include
"
mozilla
/
dom
/
SourceBufferBinding
.
h
"
#
include
"
SourceBufferContentManager
.
h
"
#
include
"
MediaDataDemuxer
.
h
"
#
include
"
MediaSourceDecoder
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
class
ContainerParser
;
class
MediaByteBuffer
;
class
MediaRawData
;
class
MediaSourceDemuxer
;
class
SourceBufferResource
;
namespace
dom
{
class
SourceBufferAttributes
;
}
class
TrackBuffersManager
:
public
SourceBufferContentManager
{
public
:
typedef
MozPromise
<
bool
nsresult
true
>
CodedFrameProcessingPromise
;
typedef
TrackInfo
:
:
TrackType
TrackType
;
typedef
MediaData
:
:
Type
MediaType
;
typedef
nsTArray
<
RefPtr
<
MediaRawData
>
>
TrackBuffer
;
TrackBuffersManager
(
dom
:
:
SourceBufferAttributes
*
aAttributes
MediaSourceDecoder
*
aParentDecoder
const
nsACString
&
aType
)
;
bool
AppendData
(
MediaByteBuffer
*
aData
media
:
:
TimeUnit
aTimestampOffset
)
override
;
RefPtr
<
AppendPromise
>
BufferAppend
(
)
override
;
void
AbortAppendData
(
)
override
;
void
ResetParserState
(
)
override
;
RefPtr
<
RangeRemovalPromise
>
RangeRemoval
(
media
:
:
TimeUnit
aStart
media
:
:
TimeUnit
aEnd
)
override
;
EvictDataResult
EvictData
(
media
:
:
TimeUnit
aPlaybackTime
uint32_t
aThreshold
media
:
:
TimeUnit
*
aBufferStartTime
)
override
;
void
EvictBefore
(
media
:
:
TimeUnit
aTime
)
override
;
media
:
:
TimeIntervals
Buffered
(
)
override
;
int64_t
GetSize
(
)
override
;
void
Ended
(
)
override
;
void
Detach
(
)
override
;
AppendState
GetAppendState
(
)
override
{
return
mAppendState
;
}
void
SetGroupStartTimestamp
(
const
media
:
:
TimeUnit
&
aGroupStartTimestamp
)
override
;
void
RestartGroupStartTimestamp
(
)
override
;
media
:
:
TimeUnit
GroupEndTimestamp
(
)
override
;
MediaInfo
GetMetadata
(
)
;
const
TrackBuffer
&
GetTrackBuffer
(
TrackInfo
:
:
TrackType
aTrack
)
;
const
media
:
:
TimeIntervals
&
Buffered
(
TrackInfo
:
:
TrackType
)
;
media
:
:
TimeIntervals
SafeBuffered
(
TrackInfo
:
:
TrackType
)
const
;
bool
IsEnded
(
)
const
{
return
mEnded
;
}
media
:
:
TimeUnit
Seek
(
TrackInfo
:
:
TrackType
aTrack
const
media
:
:
TimeUnit
&
aTime
const
media
:
:
TimeUnit
&
aFuzz
)
;
uint32_t
SkipToNextRandomAccessPoint
(
TrackInfo
:
:
TrackType
aTrack
const
media
:
:
TimeUnit
&
aTimeThreadshold
bool
&
aFound
)
;
already_AddRefed
<
MediaRawData
>
GetSample
(
TrackInfo
:
:
TrackType
aTrack
const
media
:
:
TimeUnit
&
aFuzz
bool
&
aError
)
;
media
:
:
TimeUnit
GetNextRandomAccessPoint
(
TrackInfo
:
:
TrackType
aTrack
)
;
#
if
defined
(
DEBUG
)
void
Dump
(
const
char
*
aPath
)
override
;
#
endif
void
AddSizeOfResources
(
MediaSourceDecoder
:
:
ResourceSizes
*
aSizes
)
;
private
:
friend
class
MediaSourceDemuxer
;
virtual
~
TrackBuffersManager
(
)
;
RefPtr
<
AppendPromise
>
InitSegmentParserLoop
(
)
;
void
ScheduleSegmentParserLoop
(
)
;
void
SegmentParserLoop
(
)
;
void
AppendIncomingBuffers
(
)
;
void
InitializationSegmentReceived
(
)
;
void
ShutdownDemuxers
(
)
;
void
CreateDemuxerforMIMEType
(
)
;
void
ResetDemuxingState
(
)
;
void
NeedMoreData
(
)
;
void
RejectAppend
(
nsresult
aRejectValue
const
char
*
aName
)
;
RefPtr
<
CodedFrameProcessingPromise
>
CodedFrameProcessing
(
)
;
void
CompleteCodedFrameProcessing
(
)
;
void
FinishCodedFrameProcessing
(
)
;
void
CompleteResetParserState
(
)
;
RefPtr
<
RangeRemovalPromise
>
CodedFrameRemovalWithPromise
(
media
:
:
TimeInterval
aInterval
)
;
bool
CodedFrameRemoval
(
media
:
:
TimeInterval
aInterval
)
;
void
SetAppendState
(
AppendState
aAppendState
)
;
bool
HasVideo
(
)
const
{
return
mVideoTracks
.
mNumTracks
>
0
;
}
bool
HasAudio
(
)
const
{
return
mAudioTracks
.
mNumTracks
>
0
;
}
typedef
Pair
<
RefPtr
<
MediaByteBuffer
>
media
:
:
TimeUnit
>
IncomingBuffer
;
void
AppendIncomingBuffer
(
IncomingBuffer
aData
)
;
nsTArray
<
IncomingBuffer
>
mIncomingBuffers
;
RefPtr
<
MediaByteBuffer
>
mInputBuffer
;
Atomic
<
AppendState
>
mAppendState
;
Atomic
<
bool
>
mBufferFull
;
bool
mFirstInitializationSegmentReceived
;
bool
mNewMediaSegmentStarted
;
bool
mActiveTrack
;
Maybe
<
media
:
:
TimeUnit
>
mGroupStartTimestamp
;
media
:
:
TimeUnit
mGroupEndTimestamp
;
nsCString
mType
;
void
RecreateParser
(
bool
aReuseInitData
)
;
nsAutoPtr
<
ContainerParser
>
mParser
;
void
AppendDataToCurrentInputBuffer
(
MediaByteBuffer
*
aData
)
;
RefPtr
<
MediaByteBuffer
>
mInitData
;
RefPtr
<
MediaByteBuffer
>
mPendingInputBuffer
;
RefPtr
<
SourceBufferResource
>
mCurrentInputBuffer
;
RefPtr
<
MediaDataDemuxer
>
mInputDemuxer
;
uint32_t
mProcessedInput
;
Maybe
<
media
:
:
TimeUnit
>
mLastParsedEndTime
;
void
OnDemuxerInitDone
(
nsresult
)
;
void
OnDemuxerInitFailed
(
DemuxerFailureReason
aFailure
)
;
void
OnDemuxerResetDone
(
nsresult
)
;
MozPromiseRequestHolder
<
MediaDataDemuxer
:
:
InitPromise
>
mDemuxerInitRequest
;
bool
mEncrypted
;
void
OnDemuxFailed
(
TrackType
aTrack
DemuxerFailureReason
aFailure
)
;
void
DoDemuxVideo
(
)
;
void
OnVideoDemuxCompleted
(
RefPtr
<
MediaTrackDemuxer
:
:
SamplesHolder
>
aSamples
)
;
void
OnVideoDemuxFailed
(
DemuxerFailureReason
aFailure
)
{
mVideoTracks
.
mDemuxRequest
.
Complete
(
)
;
OnDemuxFailed
(
TrackType
:
:
kVideoTrack
aFailure
)
;
}
void
DoDemuxAudio
(
)
;
void
OnAudioDemuxCompleted
(
RefPtr
<
MediaTrackDemuxer
:
:
SamplesHolder
>
aSamples
)
;
void
OnAudioDemuxFailed
(
DemuxerFailureReason
aFailure
)
{
mAudioTracks
.
mDemuxRequest
.
Complete
(
)
;
OnDemuxFailed
(
TrackType
:
:
kAudioTrack
aFailure
)
;
}
void
DoEvictData
(
const
media
:
:
TimeUnit
&
aPlaybackTime
uint32_t
aThreshold
)
;
struct
TrackData
{
TrackData
(
)
:
mNumTracks
(
0
)
mNeedRandomAccessPoint
(
true
)
mSizeBuffer
(
0
)
{
}
uint32_t
mNumTracks
;
Maybe
<
media
:
:
TimeUnit
>
mLastDecodeTimestamp
;
Maybe
<
media
:
:
TimeUnit
>
mLastFrameDuration
;
Maybe
<
media
:
:
TimeUnit
>
mHighestEndTimestamp
;
Maybe
<
media
:
:
TimeUnit
>
mLongestFrameDuration
;
bool
mNeedRandomAccessPoint
;
RefPtr
<
MediaTrackDemuxer
>
mDemuxer
;
MozPromiseRequestHolder
<
MediaTrackDemuxer
:
:
SamplesPromise
>
mDemuxRequest
;
media
:
:
TimeUnit
mLastParsedEndTime
;
Maybe
<
size_t
>
mNextInsertionIndex
;
TrackBuffer
mQueuedSamples
;
nsTArray
<
TrackBuffer
>
mBuffers
;
media
:
:
TimeIntervals
mBufferedRanges
;
media
:
:
TimeIntervals
mSanitizedBufferedRanges
;
uint32_t
mSizeBuffer
;
RefPtr
<
SharedTrackInfo
>
mInfo
;
RefPtr
<
SharedTrackInfo
>
mLastInfo
;
Maybe
<
uint32_t
>
mNextGetSampleIndex
;
media
:
:
TimeUnit
mNextSampleTimecode
;
media
:
:
TimeUnit
mNextSampleTime
;
void
ResetAppendState
(
)
{
mLastDecodeTimestamp
.
reset
(
)
;
mLastFrameDuration
.
reset
(
)
;
mHighestEndTimestamp
.
reset
(
)
;
mNeedRandomAccessPoint
=
true
;
mLongestFrameDuration
.
reset
(
)
;
mNextInsertionIndex
.
reset
(
)
;
}
void
AddSizeOfResources
(
MediaSourceDecoder
:
:
ResourceSizes
*
aSizes
)
;
}
;
void
CheckSequenceDiscontinuity
(
const
media
:
:
TimeUnit
&
aPresentationTime
)
;
void
ProcessFrames
(
TrackBuffer
&
aSamples
TrackData
&
aTrackData
)
;
bool
CheckNextInsertionIndex
(
TrackData
&
aTrackData
const
media
:
:
TimeUnit
&
aSampleTime
)
;
void
InsertFrames
(
TrackBuffer
&
aSamples
const
media
:
:
TimeIntervals
&
aIntervals
TrackData
&
aTrackData
)
;
void
RemoveFrames
(
const
media
:
:
TimeIntervals
&
aIntervals
TrackData
&
aTrackData
uint32_t
aStartIndex
)
;
uint32_t
FindSampleIndex
(
const
TrackBuffer
&
aTrackBuffer
const
media
:
:
TimeInterval
&
aInterval
)
;
void
UpdateBufferedRanges
(
)
;
void
RejectProcessing
(
nsresult
aRejectValue
const
char
*
aName
)
;
void
ResolveProcessing
(
bool
aResolveValue
const
char
*
aName
)
;
MozPromiseRequestHolder
<
CodedFrameProcessingPromise
>
mProcessingRequest
;
MozPromiseHolder
<
CodedFrameProcessingPromise
>
mProcessingPromise
;
MozPromiseHolder
<
AppendPromise
>
mAppendPromise
;
bool
mAppendRunning
;
nsTArray
<
TrackData
*
>
GetTracksList
(
)
;
TrackData
&
GetTracksData
(
TrackType
aTrack
)
{
switch
(
aTrack
)
{
case
TrackType
:
:
kVideoTrack
:
return
mVideoTracks
;
case
TrackType
:
:
kAudioTrack
:
default
:
return
mAudioTracks
;
}
}
TrackData
mVideoTracks
;
TrackData
mAudioTracks
;
AbstractThread
*
GetTaskQueue
(
)
{
return
mTaskQueue
;
}
bool
OnTaskQueue
(
)
{
return
!
GetTaskQueue
(
)
|
|
GetTaskQueue
(
)
-
>
IsCurrentThreadIn
(
)
;
}
RefPtr
<
TaskQueue
>
mTaskQueue
;
media
:
:
TimeInterval
mAppendWindow
;
media
:
:
TimeUnit
mTimestampOffset
;
media
:
:
TimeUnit
mLastTimestampOffset
;
void
RestoreCachedVariables
(
)
;
RefPtr
<
dom
:
:
SourceBufferAttributes
>
mSourceBufferAttributes
;
nsMainThreadPtrHandle
<
MediaSourceDecoder
>
mParentDecoder
;
Mirror
<
Maybe
<
double
>
>
mMediaSourceDuration
;
Atomic
<
bool
>
mAbort
;
Atomic
<
bool
>
mEnded
;
Atomic
<
int64_t
>
mSizeSourceBuffer
;
uint32_t
mEvictionThreshold
;
Atomic
<
bool
>
mEvictionOccurred
;
mutable
Monitor
mMonitor
;
media
:
:
TimeIntervals
mVideoBufferedRanges
;
media
:
:
TimeIntervals
mAudioBufferedRanges
;
media
:
:
TimeUnit
mOfficialGroupEndTimestamp
;
MediaInfo
mInfo
;
}
;
}
#
endif
