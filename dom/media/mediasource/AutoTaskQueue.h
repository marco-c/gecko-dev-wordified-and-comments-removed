#
ifndef
MOZILLA_AUTOTASKQUEUE_H_
#
define
MOZILLA_AUTOTASKQUEUE_H_
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
namespace
mozilla
{
class
AutoTaskQueue
:
public
AbstractThread
{
public
:
explicit
AutoTaskQueue
(
already_AddRefed
<
SharedThreadPool
>
aPool
bool
aSupportsTailDispatch
=
false
)
:
AbstractThread
(
aSupportsTailDispatch
)
mTaskQueue
(
new
TaskQueue
(
Move
(
aPool
)
aSupportsTailDispatch
)
)
{
}
AutoTaskQueue
(
already_AddRefed
<
SharedThreadPool
>
aPool
const
char
*
aName
bool
aSupportsTailDispatch
=
false
)
:
AbstractThread
(
aSupportsTailDispatch
)
mTaskQueue
(
new
TaskQueue
(
Move
(
aPool
)
aName
aSupportsTailDispatch
)
)
{
}
TaskDispatcher
&
TailDispatcher
(
)
override
{
return
mTaskQueue
-
>
TailDispatcher
(
)
;
}
void
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
DispatchFailureHandling
aFailureHandling
=
AssertDispatchSuccess
DispatchReason
aReason
=
NormalDispatch
)
override
{
mTaskQueue
-
>
Dispatch
(
Move
(
aRunnable
)
aFailureHandling
aReason
)
;
}
using
AbstractThread
:
:
Dispatch
;
void
AwaitIdle
(
)
{
mTaskQueue
-
>
AwaitIdle
(
)
;
}
bool
IsEmpty
(
)
{
return
mTaskQueue
-
>
IsEmpty
(
)
;
}
bool
IsCurrentThreadIn
(
)
override
{
return
mTaskQueue
-
>
IsCurrentThreadIn
(
)
;
}
private
:
~
AutoTaskQueue
(
)
{
RefPtr
<
TaskQueue
>
taskqueue
=
mTaskQueue
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
"
AutoTaskQueue
:
:
~
AutoTaskQueue
"
[
taskqueue
]
(
)
{
taskqueue
-
>
BeginShutdown
(
)
;
}
)
;
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
task
.
forget
(
)
)
;
}
RefPtr
<
TaskQueue
>
mTaskQueue
;
}
;
}
#
endif
