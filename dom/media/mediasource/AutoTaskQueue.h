#
ifndef
MOZILLA_AUTOTASKQUEUE_H_
#
define
MOZILLA_AUTOTASKQUEUE_H_
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
class
nsIEventTarget
;
namespace
mozilla
{
class
AutoTaskQueue
:
public
AbstractThread
{
public
:
explicit
AutoTaskQueue
(
already_AddRefed
<
nsIEventTarget
>
aPool
bool
aSupportsTailDispatch
=
false
)
:
AbstractThread
(
aSupportsTailDispatch
)
mTaskQueue
(
new
TaskQueue
(
std
:
:
move
(
aPool
)
aSupportsTailDispatch
)
)
mMonitor
(
"
AutoTaskQueue
"
)
{
}
AutoTaskQueue
(
already_AddRefed
<
nsIEventTarget
>
aPool
const
char
*
aName
bool
aSupportsTailDispatch
=
false
)
:
AbstractThread
(
aSupportsTailDispatch
)
mTaskQueue
(
new
TaskQueue
(
std
:
:
move
(
aPool
)
aName
aSupportsTailDispatch
)
)
mMonitor
(
"
AutoTaskQueue
"
)
{
}
TaskDispatcher
&
TailDispatcher
(
)
override
{
return
mTaskQueue
-
>
TailDispatcher
(
)
;
}
MOZ_MUST_USE
nsresult
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
DispatchReason
aReason
=
NormalDispatch
)
override
{
return
mTaskQueue
-
>
Dispatch
(
std
:
:
move
(
aRunnable
)
aReason
)
;
}
using
AbstractThread
:
:
Dispatch
;
void
AwaitIdle
(
)
{
mTaskQueue
-
>
AwaitIdle
(
)
;
}
bool
IsEmpty
(
)
{
return
mTaskQueue
-
>
IsEmpty
(
)
;
}
bool
IsCurrentThreadIn
(
)
override
{
return
mTaskQueue
-
>
IsCurrentThreadIn
(
)
;
}
mozilla
:
:
Monitor
&
Monitor
(
)
{
return
mMonitor
;
}
private
:
~
AutoTaskQueue
(
)
{
mTaskQueue
-
>
BeginShutdown
(
)
;
}
RefPtr
<
TaskQueue
>
mTaskQueue
;
mozilla
:
:
Monitor
mMonitor
;
}
;
}
#
endif
