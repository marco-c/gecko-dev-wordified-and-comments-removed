#
ifndef
MOZILLA_AUTOTASKQUEUE_H_
#
define
MOZILLA_AUTOTASKQUEUE_H_
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
namespace
mozilla
{
class
AutoTaskQueue
:
public
AbstractThread
{
public
:
explicit
AutoTaskQueue
(
already_AddRefed
<
SharedThreadPool
>
aPool
AbstractThread
*
aAbstractMainThread
bool
aSupportsTailDispatch
=
false
)
:
AbstractThread
(
aSupportsTailDispatch
)
mTaskQueue
(
new
TaskQueue
(
Move
(
aPool
)
aSupportsTailDispatch
)
)
mAbstractMainThread
(
aAbstractMainThread
)
{
}
TaskDispatcher
&
TailDispatcher
(
)
override
{
return
mTaskQueue
-
>
TailDispatcher
(
)
;
}
void
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
DispatchFailureHandling
aFailureHandling
=
AssertDispatchSuccess
DispatchReason
aReason
=
NormalDispatch
)
override
{
mTaskQueue
-
>
Dispatch
(
Move
(
aRunnable
)
aFailureHandling
aReason
)
;
}
void
AwaitIdle
(
)
{
mTaskQueue
-
>
AwaitIdle
(
)
;
}
bool
IsEmpty
(
)
{
return
mTaskQueue
-
>
IsEmpty
(
)
;
}
bool
IsCurrentThreadIn
(
)
override
{
return
mTaskQueue
-
>
IsCurrentThreadIn
(
)
;
}
private
:
~
AutoTaskQueue
(
)
{
RefPtr
<
TaskQueue
>
taskqueue
=
mTaskQueue
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
[
taskqueue
]
(
)
{
taskqueue
-
>
BeginShutdown
(
)
;
}
)
;
mAbstractMainThread
-
>
Dispatch
(
task
.
forget
(
)
)
;
}
RefPtr
<
TaskQueue
>
mTaskQueue
;
const
RefPtr
<
AbstractThread
>
mAbstractMainThread
;
}
;
}
#
endif
