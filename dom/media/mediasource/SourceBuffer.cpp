#
include
"
SourceBuffer
.
h
"
#
include
"
AsyncEventRunner
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
MediaSourceDemuxer
.
h
"
#
include
"
MediaSourceUtils
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
MediaSourceBinding
.
h
"
#
include
"
mozilla
/
dom
/
TimeRanges
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
<
time
.
h
>
#
include
"
TimeUnits
.
h
"
struct
JSContext
;
class
JSObject
;
extern
mozilla
:
:
LogModule
*
GetMediaSourceLog
(
)
;
extern
mozilla
:
:
LogModule
*
GetMediaSourceAPILog
(
)
;
#
define
MSE_DEBUG
(
arg
.
.
.
)
MOZ_LOG
(
GetMediaSourceLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
SourceBuffer
(
%
p
:
%
s
)
:
:
%
s
:
"
arg
this
mType
.
get
(
)
__func__
#
#
__VA_ARGS__
)
)
#
define
MSE_DEBUGV
(
arg
.
.
.
)
MOZ_LOG
(
GetMediaSourceLog
(
)
mozilla
:
:
LogLevel
:
:
Verbose
(
"
SourceBuffer
(
%
p
:
%
s
)
:
:
%
s
:
"
arg
this
mType
.
get
(
)
__func__
#
#
__VA_ARGS__
)
)
#
define
MSE_API
(
arg
.
.
.
)
MOZ_LOG
(
GetMediaSourceAPILog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
SourceBuffer
(
%
p
:
%
s
)
:
:
%
s
:
"
arg
this
mType
.
get
(
)
__func__
#
#
__VA_ARGS__
)
)
namespace
mozilla
{
using
media
:
:
TimeUnit
;
namespace
dom
{
class
BufferAppendRunnable
:
public
nsRunnable
{
public
:
BufferAppendRunnable
(
SourceBuffer
*
aSourceBuffer
uint32_t
aUpdateID
)
:
mSourceBuffer
(
aSourceBuffer
)
mUpdateID
(
aUpdateID
)
{
}
NS_IMETHOD
Run
(
)
override
final
{
mSourceBuffer
-
>
BufferAppend
(
mUpdateID
)
;
return
NS_OK
;
}
private
:
RefPtr
<
SourceBuffer
>
mSourceBuffer
;
uint32_t
mUpdateID
;
}
;
void
SourceBuffer
:
:
SetMode
(
SourceBufferAppendMode
aMode
ErrorResult
&
aRv
)
{
typedef
mozilla
:
:
SourceBufferContentManager
:
:
AppendState
AppendState
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_API
(
"
SetMode
(
aMode
=
%
d
)
"
aMode
)
;
if
(
!
IsAttached
(
)
|
|
mUpdating
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
mAttributes
-
>
mGenerateTimestamps
&
&
aMode
=
=
SourceBufferAppendMode
:
:
Segments
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_ACCESS_ERR
)
;
return
;
}
MOZ_ASSERT
(
mMediaSource
-
>
ReadyState
(
)
!
=
MediaSourceReadyState
:
:
Closed
)
;
if
(
mMediaSource
-
>
ReadyState
(
)
=
=
MediaSourceReadyState
:
:
Ended
)
{
mMediaSource
-
>
SetReadyState
(
MediaSourceReadyState
:
:
Open
)
;
}
if
(
mContentManager
-
>
GetAppendState
(
)
=
=
AppendState
:
:
PARSING_MEDIA_SEGMENT
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
aMode
=
=
SourceBufferAppendMode
:
:
Sequence
)
{
mContentManager
-
>
RestartGroupStartTimestamp
(
)
;
}
mAttributes
-
>
SetAppendMode
(
aMode
)
;
}
void
SourceBuffer
:
:
SetTimestampOffset
(
double
aTimestampOffset
ErrorResult
&
aRv
)
{
typedef
mozilla
:
:
SourceBufferContentManager
:
:
AppendState
AppendState
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_API
(
"
SetTimestampOffset
(
aTimestampOffset
=
%
f
)
"
aTimestampOffset
)
;
if
(
!
IsAttached
(
)
|
|
mUpdating
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
MOZ_ASSERT
(
mMediaSource
-
>
ReadyState
(
)
!
=
MediaSourceReadyState
:
:
Closed
)
;
if
(
mMediaSource
-
>
ReadyState
(
)
=
=
MediaSourceReadyState
:
:
Ended
)
{
mMediaSource
-
>
SetReadyState
(
MediaSourceReadyState
:
:
Open
)
;
}
if
(
mContentManager
-
>
GetAppendState
(
)
=
=
AppendState
:
:
PARSING_MEDIA_SEGMENT
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
mAttributes
-
>
SetApparentTimestampOffset
(
aTimestampOffset
)
;
if
(
mAttributes
-
>
GetAppendMode
(
)
=
=
SourceBufferAppendMode
:
:
Sequence
)
{
mContentManager
-
>
SetGroupStartTimestamp
(
mAttributes
-
>
GetTimestampOffset
(
)
)
;
}
}
TimeRanges
*
SourceBuffer
:
:
GetBuffered
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
IsAttached
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
bool
rangeChanged
=
true
;
media
:
:
TimeIntervals
intersection
=
mContentManager
-
>
Buffered
(
)
;
MSE_DEBUGV
(
"
intersection
=
%
s
"
DumpTimeRanges
(
intersection
)
.
get
(
)
)
;
if
(
mBuffered
)
{
media
:
:
TimeIntervals
currentValue
(
mBuffered
)
;
rangeChanged
=
(
intersection
!
=
currentValue
)
;
MSE_DEBUGV
(
"
currentValue
=
%
s
"
DumpTimeRanges
(
currentValue
)
.
get
(
)
)
;
}
if
(
rangeChanged
)
{
mBuffered
=
new
TimeRanges
(
ToSupports
(
this
)
)
;
intersection
.
ToTimeRanges
(
mBuffered
)
;
}
return
mBuffered
;
}
media
:
:
TimeIntervals
SourceBuffer
:
:
GetTimeIntervals
(
)
{
return
mContentManager
-
>
Buffered
(
)
;
}
void
SourceBuffer
:
:
SetAppendWindowStart
(
double
aAppendWindowStart
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_API
(
"
SetAppendWindowStart
(
aAppendWindowStart
=
%
f
)
"
aAppendWindowStart
)
;
if
(
!
IsAttached
(
)
|
|
mUpdating
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
aAppendWindowStart
<
0
|
|
aAppendWindowStart
>
=
mAttributes
-
>
GetAppendWindowEnd
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_ACCESS_ERR
)
;
return
;
}
mAttributes
-
>
SetAppendWindowStart
(
aAppendWindowStart
)
;
}
void
SourceBuffer
:
:
SetAppendWindowEnd
(
double
aAppendWindowEnd
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_API
(
"
SetAppendWindowEnd
(
aAppendWindowEnd
=
%
f
)
"
aAppendWindowEnd
)
;
if
(
!
IsAttached
(
)
|
|
mUpdating
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
IsNaN
(
aAppendWindowEnd
)
|
|
aAppendWindowEnd
<
=
mAttributes
-
>
GetAppendWindowStart
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_ACCESS_ERR
)
;
return
;
}
mAttributes
-
>
SetAppendWindowEnd
(
aAppendWindowEnd
)
;
}
void
SourceBuffer
:
:
AppendBuffer
(
const
ArrayBuffer
&
aData
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_API
(
"
AppendBuffer
(
ArrayBuffer
)
"
)
;
aData
.
ComputeLengthAndData
(
)
;
AppendData
(
aData
.
Data
(
)
aData
.
Length
(
)
aRv
)
;
}
void
SourceBuffer
:
:
AppendBuffer
(
const
ArrayBufferView
&
aData
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_API
(
"
AppendBuffer
(
ArrayBufferView
)
"
)
;
aData
.
ComputeLengthAndData
(
)
;
AppendData
(
aData
.
Data
(
)
aData
.
Length
(
)
aRv
)
;
}
void
SourceBuffer
:
:
Abort
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_API
(
"
Abort
(
)
"
)
;
if
(
!
IsAttached
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
mMediaSource
-
>
ReadyState
(
)
!
=
MediaSourceReadyState
:
:
Open
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
AbortBufferAppend
(
)
;
mContentManager
-
>
ResetParserState
(
)
;
mAttributes
-
>
SetAppendWindowStart
(
0
)
;
mAttributes
-
>
SetAppendWindowEnd
(
PositiveInfinity
<
double
>
(
)
)
;
}
void
SourceBuffer
:
:
AbortBufferAppend
(
)
{
if
(
mUpdating
)
{
mPendingAppend
.
DisconnectIfExists
(
)
;
mContentManager
-
>
AbortAppendData
(
)
;
AbortUpdating
(
)
;
}
}
void
SourceBuffer
:
:
Remove
(
double
aStart
double
aEnd
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_API
(
"
Remove
(
aStart
=
%
f
aEnd
=
%
f
)
"
aStart
aEnd
)
;
if
(
!
IsAttached
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
mUpdating
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
IsNaN
(
mMediaSource
-
>
Duration
(
)
)
|
|
aStart
<
0
|
|
aStart
>
mMediaSource
-
>
Duration
(
)
|
|
aEnd
<
=
aStart
|
|
IsNaN
(
aEnd
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_ACCESS_ERR
)
;
return
;
}
if
(
mMediaSource
-
>
ReadyState
(
)
=
=
MediaSourceReadyState
:
:
Ended
)
{
mMediaSource
-
>
SetReadyState
(
MediaSourceReadyState
:
:
Open
)
;
}
RangeRemoval
(
aStart
aEnd
)
;
}
void
SourceBuffer
:
:
RangeRemoval
(
double
aStart
double
aEnd
)
{
StartUpdating
(
)
;
RefPtr
<
SourceBuffer
>
self
=
this
;
mContentManager
-
>
RangeRemoval
(
TimeUnit
:
:
FromSeconds
(
aStart
)
TimeUnit
:
:
FromSeconds
(
aEnd
)
)
-
>
Then
(
AbstractThread
:
:
MainThread
(
)
__func__
[
self
]
(
bool
)
{
self
-
>
StopUpdating
(
)
;
}
[
]
(
)
{
MOZ_ASSERT
(
false
)
;
}
)
;
}
void
SourceBuffer
:
:
Detach
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_DEBUG
(
"
Detach
"
)
;
if
(
!
mMediaSource
)
{
MSE_DEBUG
(
"
Already
detached
"
)
;
return
;
}
AbortBufferAppend
(
)
;
if
(
mContentManager
)
{
mContentManager
-
>
Detach
(
)
;
mMediaSource
-
>
GetDecoder
(
)
-
>
GetDemuxer
(
)
-
>
DetachSourceBuffer
(
static_cast
<
mozilla
:
:
TrackBuffersManager
*
>
(
mContentManager
.
get
(
)
)
)
;
}
mContentManager
=
nullptr
;
mMediaSource
=
nullptr
;
}
void
SourceBuffer
:
:
Ended
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
IsAttached
(
)
)
;
MSE_DEBUG
(
"
Ended
"
)
;
mContentManager
-
>
Ended
(
)
;
mMediaSource
-
>
GetDecoder
(
)
-
>
NotifyDataArrived
(
false
)
;
}
SourceBuffer
:
:
SourceBuffer
(
MediaSource
*
aMediaSource
const
nsACString
&
aType
)
:
DOMEventTargetHelper
(
aMediaSource
-
>
GetParentObject
(
)
)
mMediaSource
(
aMediaSource
)
mUpdating
(
false
)
mActive
(
false
)
mUpdateID
(
0
)
mType
(
aType
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aMediaSource
)
;
mEvictionThreshold
=
Preferences
:
:
GetUint
(
"
media
.
mediasource
.
eviction_threshold
"
100
*
(
1
<
<
20
)
)
;
bool
generateTimestamps
=
false
;
if
(
aType
.
LowerCaseEqualsLiteral
(
"
audio
/
mpeg
"
)
|
|
aType
.
LowerCaseEqualsLiteral
(
"
audio
/
aac
"
)
)
{
generateTimestamps
=
true
;
}
mAttributes
=
new
SourceBufferAttributes
(
generateTimestamps
)
;
mContentManager
=
SourceBufferContentManager
:
:
CreateManager
(
mAttributes
aMediaSource
-
>
GetDecoder
(
)
aType
)
;
MSE_DEBUG
(
"
Create
mContentManager
=
%
p
"
mContentManager
.
get
(
)
)
;
ErrorResult
dummy
;
if
(
mAttributes
-
>
mGenerateTimestamps
)
{
SetMode
(
SourceBufferAppendMode
:
:
Sequence
dummy
)
;
}
else
{
SetMode
(
SourceBufferAppendMode
:
:
Segments
dummy
)
;
}
mMediaSource
-
>
GetDecoder
(
)
-
>
GetDemuxer
(
)
-
>
AttachSourceBuffer
(
static_cast
<
mozilla
:
:
TrackBuffersManager
*
>
(
mContentManager
.
get
(
)
)
)
;
}
SourceBuffer
:
:
~
SourceBuffer
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mMediaSource
)
;
MSE_DEBUG
(
"
"
)
;
}
MediaSource
*
SourceBuffer
:
:
GetParentObject
(
)
const
{
return
mMediaSource
;
}
JSObject
*
SourceBuffer
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
SourceBufferBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
SourceBuffer
:
:
DispatchSimpleEvent
(
const
char
*
aName
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_API
(
"
Dispatch
event
'
%
s
'
"
aName
)
;
DispatchTrustedEvent
(
NS_ConvertUTF8toUTF16
(
aName
)
)
;
}
void
SourceBuffer
:
:
QueueAsyncSimpleEvent
(
const
char
*
aName
)
{
MSE_DEBUG
(
"
Queuing
event
'
%
s
'
"
aName
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
AsyncEventRunner
<
SourceBuffer
>
(
this
aName
)
;
NS_DispatchToMainThread
(
event
NS_DISPATCH_NORMAL
)
;
}
void
SourceBuffer
:
:
StartUpdating
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mUpdating
)
;
mUpdating
=
true
;
mUpdateID
+
+
;
QueueAsyncSimpleEvent
(
"
updatestart
"
)
;
}
void
SourceBuffer
:
:
StopUpdating
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mUpdating
)
{
return
;
}
mUpdating
=
false
;
QueueAsyncSimpleEvent
(
"
update
"
)
;
QueueAsyncSimpleEvent
(
"
updateend
"
)
;
}
void
SourceBuffer
:
:
AbortUpdating
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mUpdating
)
;
mUpdating
=
false
;
QueueAsyncSimpleEvent
(
"
abort
"
)
;
QueueAsyncSimpleEvent
(
"
updateend
"
)
;
}
void
SourceBuffer
:
:
CheckEndTime
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
double
endTime
=
mContentManager
-
>
GroupEndTimestamp
(
)
.
ToSeconds
(
)
;
double
duration
=
mMediaSource
-
>
Duration
(
)
;
if
(
endTime
>
duration
)
{
mMediaSource
-
>
SetDuration
(
endTime
MSRangeRemovalAction
:
:
SKIP
)
;
}
}
void
SourceBuffer
:
:
AppendData
(
const
uint8_t
*
aData
uint32_t
aLength
ErrorResult
&
aRv
)
{
MSE_DEBUG
(
"
AppendData
(
aLength
=
%
u
)
"
aLength
)
;
RefPtr
<
MediaByteBuffer
>
data
=
PrepareAppend
(
aData
aLength
aRv
)
;
if
(
!
data
)
{
return
;
}
mContentManager
-
>
AppendData
(
data
mAttributes
-
>
GetTimestampOffset
(
)
)
;
StartUpdating
(
)
;
nsCOMPtr
<
nsIRunnable
>
task
=
new
BufferAppendRunnable
(
this
mUpdateID
)
;
NS_DispatchToMainThread
(
task
)
;
}
void
SourceBuffer
:
:
BufferAppend
(
uint32_t
aUpdateID
)
{
if
(
!
mUpdating
|
|
aUpdateID
!
=
mUpdateID
)
{
return
;
}
MOZ_ASSERT
(
mMediaSource
)
;
MOZ_ASSERT
(
!
mPendingAppend
.
Exists
(
)
)
;
mPendingAppend
.
Begin
(
mContentManager
-
>
BufferAppend
(
)
-
>
Then
(
AbstractThread
:
:
MainThread
(
)
__func__
this
&
SourceBuffer
:
:
AppendDataCompletedWithSuccess
&
SourceBuffer
:
:
AppendDataErrored
)
)
;
}
void
SourceBuffer
:
:
AppendDataCompletedWithSuccess
(
bool
aHasActiveTracks
)
{
mPendingAppend
.
Complete
(
)
;
if
(
!
mUpdating
)
{
return
;
}
if
(
aHasActiveTracks
)
{
if
(
!
mActive
)
{
mActive
=
true
;
mMediaSource
-
>
SourceBufferIsActive
(
this
)
;
}
}
if
(
mActive
)
{
mMediaSource
-
>
GetDecoder
(
)
-
>
NotifyDataArrived
(
false
)
;
mMediaSource
-
>
GetDecoder
(
)
-
>
NotifyBytesDownloaded
(
)
;
}
CheckEndTime
(
)
;
StopUpdating
(
)
;
}
void
SourceBuffer
:
:
AppendDataErrored
(
nsresult
aError
)
{
mPendingAppend
.
Complete
(
)
;
switch
(
aError
)
{
case
NS_ERROR_ABORT
:
break
;
default
:
AppendError
(
true
)
;
break
;
}
}
void
SourceBuffer
:
:
AppendError
(
bool
aDecoderError
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mUpdating
)
{
return
;
}
mContentManager
-
>
ResetParserState
(
)
;
mUpdating
=
false
;
QueueAsyncSimpleEvent
(
"
error
"
)
;
QueueAsyncSimpleEvent
(
"
updateend
"
)
;
if
(
aDecoderError
)
{
Optional
<
MediaSourceEndOfStreamError
>
decodeError
(
MediaSourceEndOfStreamError
:
:
Decode
)
;
ErrorResult
dummy
;
mMediaSource
-
>
EndOfStream
(
decodeError
dummy
)
;
}
}
already_AddRefed
<
MediaByteBuffer
>
SourceBuffer
:
:
PrepareAppend
(
const
uint8_t
*
aData
uint32_t
aLength
ErrorResult
&
aRv
)
{
typedef
SourceBufferContentManager
:
:
EvictDataResult
Result
;
if
(
!
IsAttached
(
)
|
|
mUpdating
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
if
(
!
mMediaSource
-
>
GetDecoder
(
)
|
|
mMediaSource
-
>
GetDecoder
(
)
-
>
IsEndedOrShutdown
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
if
(
mMediaSource
-
>
ReadyState
(
)
=
=
MediaSourceReadyState
:
:
Ended
)
{
mMediaSource
-
>
SetReadyState
(
MediaSourceReadyState
:
:
Open
)
;
}
TimeUnit
newBufferStartTime
;
uint32_t
toEvict
=
(
mEvictionThreshold
>
aLength
)
?
mEvictionThreshold
-
aLength
:
aLength
;
Result
evicted
=
mContentManager
-
>
EvictData
(
TimeUnit
:
:
FromSeconds
(
mMediaSource
-
>
GetDecoder
(
)
-
>
GetCurrentTime
(
)
)
toEvict
&
newBufferStartTime
)
;
if
(
evicted
=
=
Result
:
:
DATA_EVICTED
)
{
MSE_DEBUG
(
"
AppendData
Evict
;
current
buffered
start
=
%
f
"
GetBufferedStart
(
)
)
;
mMediaSource
-
>
NotifyEvicted
(
0
.
0
newBufferStartTime
.
ToSeconds
(
)
)
;
}
if
(
aLength
>
mEvictionThreshold
|
|
evicted
=
=
Result
:
:
BUFFER_FULL
)
{
aRv
.
Throw
(
NS_ERROR_DOM_QUOTA_EXCEEDED_ERR
)
;
return
nullptr
;
}
RefPtr
<
MediaByteBuffer
>
data
=
new
MediaByteBuffer
(
)
;
if
(
!
data
-
>
AppendElements
(
aData
aLength
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_QUOTA_EXCEEDED_ERR
)
;
return
nullptr
;
}
return
data
.
forget
(
)
;
}
double
SourceBuffer
:
:
GetBufferedStart
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ErrorResult
dummy
;
RefPtr
<
TimeRanges
>
ranges
=
GetBuffered
(
dummy
)
;
return
ranges
-
>
Length
(
)
>
0
?
ranges
-
>
GetStartTime
(
)
:
0
;
}
double
SourceBuffer
:
:
GetBufferedEnd
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ErrorResult
dummy
;
RefPtr
<
TimeRanges
>
ranges
=
GetBuffered
(
dummy
)
;
return
ranges
-
>
Length
(
)
>
0
?
ranges
-
>
GetEndTime
(
)
:
0
;
}
void
SourceBuffer
:
:
Evict
(
double
aStart
double
aEnd
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_DEBUG
(
"
Evict
(
aStart
=
%
f
aEnd
=
%
f
)
"
aStart
aEnd
)
;
double
currentTime
=
mMediaSource
-
>
GetDecoder
(
)
-
>
GetCurrentTime
(
)
;
double
evictTime
=
aEnd
;
const
double
safety_threshold
=
5
;
if
(
currentTime
+
safety_threshold
>
=
evictTime
)
{
evictTime
-
=
safety_threshold
;
}
mContentManager
-
>
EvictBefore
(
TimeUnit
:
:
FromSeconds
(
evictTime
)
)
;
}
#
if
defined
(
DEBUG
)
void
SourceBuffer
:
:
Dump
(
const
char
*
aPath
)
{
if
(
mContentManager
)
{
mContentManager
-
>
Dump
(
aPath
)
;
}
}
#
endif
NS_IMPL_CYCLE_COLLECTION_CLASS
(
SourceBuffer
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
SourceBuffer
)
SourceBufferContentManager
*
manager
=
tmp
-
>
mContentManager
;
if
(
manager
)
{
manager
-
>
Detach
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMediaSource
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mBuffered
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END_INHERITED
(
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
SourceBuffer
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMediaSource
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBuffered
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ADDREF_INHERITED
(
SourceBuffer
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
SourceBuffer
DOMEventTargetHelper
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
SourceBuffer
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
#
undef
MSE_DEBUG
#
undef
MSE_DEBUGV
#
undef
MSE_API
}
}
