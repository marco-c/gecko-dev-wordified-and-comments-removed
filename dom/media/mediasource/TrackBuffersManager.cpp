#
include
"
TrackBuffersManager
.
h
"
#
include
"
ContainerParser
.
h
"
#
include
"
MediaSourceDemuxer
.
h
"
#
include
"
MediaSourceUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
SourceBufferResource
.
h
"
#
include
"
SourceBuffer
.
h
"
#
include
"
WebMDemuxer
.
h
"
#
ifdef
MOZ_FMP4
#
include
"
MP4Demuxer
.
h
"
#
endif
#
include
<
limits
>
extern
mozilla
:
:
LogModule
*
GetMediaSourceLog
(
)
;
#
define
MSE_DEBUG
(
arg
.
.
.
)
MOZ_LOG
(
GetMediaSourceLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
TrackBuffersManager
(
%
p
:
%
s
)
:
:
%
s
:
"
arg
this
mType
.
get
(
)
__func__
#
#
__VA_ARGS__
)
)
#
define
MSE_DEBUGV
(
arg
.
.
.
)
MOZ_LOG
(
GetMediaSourceLog
(
)
mozilla
:
:
LogLevel
:
:
Verbose
(
"
TrackBuffersManager
(
%
p
:
%
s
)
:
:
%
s
:
"
arg
this
mType
.
get
(
)
__func__
#
#
__VA_ARGS__
)
)
mozilla
:
:
LogModule
*
GetMediaSourceSamplesLog
(
)
{
static
mozilla
:
:
LazyLogModule
sLogModule
(
"
MediaSourceSamples
"
)
;
return
sLogModule
;
}
#
define
SAMPLE_DEBUG
(
arg
.
.
.
)
MOZ_LOG
(
GetMediaSourceSamplesLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
TrackBuffersManager
(
%
p
:
%
s
)
:
:
%
s
:
"
arg
this
mType
.
get
(
)
__func__
#
#
__VA_ARGS__
)
)
namespace
mozilla
{
using
dom
:
:
SourceBufferAppendMode
;
using
media
:
:
TimeUnit
;
using
media
:
:
TimeInterval
;
using
media
:
:
TimeIntervals
;
static
const
char
*
AppendStateToStr
(
TrackBuffersManager
:
:
AppendState
aState
)
{
switch
(
aState
)
{
case
TrackBuffersManager
:
:
AppendState
:
:
WAITING_FOR_SEGMENT
:
return
"
WAITING_FOR_SEGMENT
"
;
case
TrackBuffersManager
:
:
AppendState
:
:
PARSING_INIT_SEGMENT
:
return
"
PARSING_INIT_SEGMENT
"
;
case
TrackBuffersManager
:
:
AppendState
:
:
PARSING_MEDIA_SEGMENT
:
return
"
PARSING_MEDIA_SEGMENT
"
;
default
:
return
"
IMPOSSIBLE
"
;
}
}
static
Atomic
<
uint32_t
>
sStreamSourceID
(
0u
)
;
#
ifdef
MOZ_EME
class
DispatchKeyNeededEvent
:
public
nsRunnable
{
public
:
DispatchKeyNeededEvent
(
AbstractMediaDecoder
*
aDecoder
nsTArray
<
uint8_t
>
&
aInitData
const
nsString
&
aInitDataType
)
:
mDecoder
(
aDecoder
)
mInitData
(
aInitData
)
mInitDataType
(
aInitDataType
)
{
}
NS_IMETHOD
Run
(
)
{
MediaDecoderOwner
*
owner
=
mDecoder
-
>
GetOwner
(
)
;
if
(
owner
)
{
owner
-
>
DispatchEncrypted
(
mInitData
mInitDataType
)
;
}
mDecoder
=
nullptr
;
return
NS_OK
;
}
private
:
RefPtr
<
AbstractMediaDecoder
>
mDecoder
;
nsTArray
<
uint8_t
>
mInitData
;
nsString
mInitDataType
;
}
;
#
endif
TrackBuffersManager
:
:
TrackBuffersManager
(
dom
:
:
SourceBufferAttributes
*
aAttributes
MediaSourceDecoder
*
aParentDecoder
const
nsACString
&
aType
)
:
mInputBuffer
(
new
MediaByteBuffer
)
mAppendState
(
AppendState
:
:
WAITING_FOR_SEGMENT
)
mBufferFull
(
false
)
mFirstInitializationSegmentReceived
(
false
)
mNewMediaSegmentStarted
(
false
)
mActiveTrack
(
false
)
mType
(
aType
)
mParser
(
ContainerParser
:
:
CreateForMIMEType
(
aType
)
)
mProcessedInput
(
0
)
mTaskQueue
(
aParentDecoder
-
>
GetDemuxer
(
)
-
>
GetTaskQueue
(
)
)
mSourceBufferAttributes
(
aAttributes
)
mParentDecoder
(
new
nsMainThreadPtrHolder
<
MediaSourceDecoder
>
(
aParentDecoder
false
)
)
mVideoEvictionThreshold
(
Preferences
:
:
GetUint
(
"
media
.
mediasource
.
eviction_threshold
.
video
"
100
*
1024
*
1024
)
)
mAudioEvictionThreshold
(
Preferences
:
:
GetUint
(
"
media
.
mediasource
.
eviction_threshold
.
audio
"
15
*
1024
*
1024
)
)
mEvictionOccurred
(
false
)
mMonitor
(
"
TrackBuffersManager
"
)
mAppendRunning
(
false
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
instanciated
on
the
main
thread
"
)
;
}
TrackBuffersManager
:
:
~
TrackBuffersManager
(
)
{
ShutdownDemuxers
(
)
;
}
bool
TrackBuffersManager
:
:
AppendData
(
MediaByteBuffer
*
aData
TimeUnit
aTimestampOffset
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_DEBUG
(
"
Appending
%
lld
bytes
"
aData
-
>
Length
(
)
)
;
mEnded
=
false
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableMethodWithArg
<
IncomingBuffer
>
(
this
&
TrackBuffersManager
:
:
AppendIncomingBuffer
IncomingBuffer
(
aData
aTimestampOffset
)
)
;
GetTaskQueue
(
)
-
>
Dispatch
(
task
.
forget
(
)
)
;
return
true
;
}
void
TrackBuffersManager
:
:
AppendIncomingBuffer
(
IncomingBuffer
aData
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mIncomingBuffers
.
AppendElement
(
aData
)
;
}
RefPtr
<
TrackBuffersManager
:
:
AppendPromise
>
TrackBuffersManager
:
:
BufferAppend
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_DEBUG
(
"
"
)
;
mAppendRunning
=
true
;
return
InvokeAsync
(
GetTaskQueue
(
)
this
__func__
&
TrackBuffersManager
:
:
InitSegmentParserLoop
)
;
}
void
TrackBuffersManager
:
:
AbortAppendData
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_DEBUG
(
"
"
)
;
MonitorAutoLock
mon
(
mMonitor
)
;
while
(
mAppendRunning
)
{
mon
.
Wait
(
)
;
}
}
void
TrackBuffersManager
:
:
ResetParserState
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mAppendRunning
"
Append
is
running
abort
must
have
been
called
"
)
;
MSE_DEBUG
(
"
"
)
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableMethod
(
this
&
TrackBuffersManager
:
:
CompleteResetParserState
)
;
GetTaskQueue
(
)
-
>
Dispatch
(
task
.
forget
(
)
)
;
SetAppendState
(
AppendState
:
:
WAITING_FOR_SEGMENT
)
;
}
RefPtr
<
TrackBuffersManager
:
:
RangeRemovalPromise
>
TrackBuffersManager
:
:
RangeRemoval
(
TimeUnit
aStart
TimeUnit
aEnd
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mAppendRunning
"
Append
is
running
"
)
;
MSE_DEBUG
(
"
From
%
.
2f
to
%
.
2f
"
aStart
.
ToSeconds
(
)
aEnd
.
ToSeconds
(
)
)
;
mEnded
=
false
;
return
InvokeAsync
(
GetTaskQueue
(
)
this
__func__
&
TrackBuffersManager
:
:
CodedFrameRemovalWithPromise
TimeInterval
(
aStart
aEnd
)
)
;
}
TrackBuffersManager
:
:
EvictDataResult
TrackBuffersManager
:
:
EvictData
(
TimeUnit
aPlaybackTime
int64_t
aThresholdReduct
TimeUnit
*
aBufferStartTime
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
const
int64_t
toEvict
=
GetSize
(
)
-
std
:
:
max
(
EvictionThreshold
(
)
-
aThresholdReduct
aThresholdReduct
)
;
MSE_DEBUG
(
"
buffered
=
%
lldkb
eviction
threshold
=
%
ukb
evict
=
%
lldkb
"
GetSize
(
)
/
1024
EvictionThreshold
(
)
/
1024
toEvict
/
1024
)
;
if
(
toEvict
<
=
0
)
{
return
EvictDataResult
:
:
NO_DATA_EVICTED
;
}
if
(
toEvict
<
=
512
*
1024
)
{
return
EvictDataResult
:
:
CANT_EVICT
;
}
if
(
mBufferFull
&
&
mEvictionOccurred
)
{
return
EvictDataResult
:
:
BUFFER_FULL
;
}
MSE_DEBUG
(
"
Reaching
our
size
limit
schedule
eviction
of
%
lld
bytes
"
toEvict
)
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableMethodWithArgs
<
TimeUnit
uint32_t
>
(
this
&
TrackBuffersManager
:
:
DoEvictData
aPlaybackTime
toEvict
)
;
GetTaskQueue
(
)
-
>
Dispatch
(
task
.
forget
(
)
)
;
return
EvictDataResult
:
:
NO_DATA_EVICTED
;
}
void
TrackBuffersManager
:
:
EvictBefore
(
TimeUnit
aTime
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_DEBUG
(
"
"
)
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableMethodWithArg
<
TimeInterval
>
(
this
&
TrackBuffersManager
:
:
CodedFrameRemoval
TimeInterval
(
TimeUnit
:
:
FromSeconds
(
0
)
aTime
)
)
;
GetTaskQueue
(
)
-
>
Dispatch
(
task
.
forget
(
)
)
;
}
TimeIntervals
TrackBuffersManager
:
:
Buffered
(
)
{
MSE_DEBUG
(
"
"
)
;
MonitorAutoLock
mon
(
mMonitor
)
;
TimeUnit
highestEndTime
;
nsTArray
<
TimeIntervals
*
>
tracks
;
if
(
HasVideo
(
)
)
{
tracks
.
AppendElement
(
&
mVideoBufferedRanges
)
;
}
if
(
HasAudio
(
)
)
{
tracks
.
AppendElement
(
&
mAudioBufferedRanges
)
;
}
for
(
auto
trackRanges
:
tracks
)
{
highestEndTime
=
std
:
:
max
(
trackRanges
-
>
GetEnd
(
)
highestEndTime
)
;
}
TimeIntervals
intersection
{
TimeInterval
(
TimeUnit
:
:
FromSeconds
(
0
)
highestEndTime
)
}
;
for
(
auto
trackRanges
:
tracks
)
{
if
(
mEnded
)
{
trackRanges
-
>
Add
(
TimeInterval
(
trackRanges
-
>
GetEnd
(
)
highestEndTime
)
)
;
}
intersection
.
Intersection
(
*
trackRanges
)
;
}
return
intersection
;
}
int64_t
TrackBuffersManager
:
:
GetSize
(
)
{
return
mSizeSourceBuffer
;
}
void
TrackBuffersManager
:
:
Ended
(
)
{
mEnded
=
true
;
}
void
TrackBuffersManager
:
:
Detach
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_DEBUG
(
"
"
)
;
}
void
TrackBuffersManager
:
:
CompleteResetParserState
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MSE_DEBUG
(
"
"
)
;
NS_ASSERTION
(
!
mDemuxerInitRequest
.
Exists
(
)
"
Previous
AppendBuffer
didn
'
t
complete
"
)
;
if
(
mDemuxerInitRequest
.
Exists
(
)
)
{
mDemuxerInitRequest
.
Disconnect
(
)
;
}
for
(
auto
&
track
:
GetTracksList
(
)
)
{
track
-
>
ResetAppendState
(
)
;
track
-
>
mQueuedSamples
.
Clear
(
)
;
}
if
(
mSourceBufferAttributes
-
>
GetAppendMode
(
)
=
=
SourceBufferAppendMode
:
:
Sequence
)
{
mGroupStartTimestamp
=
Some
(
mGroupEndTimestamp
)
;
}
mIncomingBuffers
.
Clear
(
)
;
mInputBuffer
=
nullptr
;
if
(
mCurrentInputBuffer
)
{
mCurrentInputBuffer
-
>
EvictAll
(
)
;
mCurrentInputBuffer
=
new
SourceBufferResource
(
mType
)
;
}
if
(
mFirstInitializationSegmentReceived
)
{
MOZ_ASSERT
(
mInitData
&
&
mInitData
-
>
Length
(
)
"
we
must
have
an
init
segment
"
)
;
CreateDemuxerforMIMEType
(
)
;
mInputBuffer
=
new
MediaByteBuffer
;
mInputBuffer
-
>
AppendElements
(
*
mInitData
)
;
}
RecreateParser
(
true
)
;
SetAppendState
(
AppendState
:
:
WAITING_FOR_SEGMENT
)
;
mAppendPromise
.
RejectIfExists
(
NS_ERROR_ABORT
__func__
)
;
}
int64_t
TrackBuffersManager
:
:
EvictionThreshold
(
)
const
{
if
(
HasVideo
(
)
)
{
return
mVideoEvictionThreshold
;
}
return
mAudioEvictionThreshold
;
}
void
TrackBuffersManager
:
:
DoEvictData
(
const
TimeUnit
&
aPlaybackTime
int64_t
aSizeToEvict
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
const
auto
&
track
=
HasVideo
(
)
?
mVideoTracks
:
mAudioTracks
;
const
auto
&
buffer
=
track
.
mBuffers
.
LastElement
(
)
;
TimeUnit
lowerLimit
=
std
:
:
min
(
track
.
mNextSampleTime
aPlaybackTime
)
;
uint32_t
lastKeyFrameIndex
=
0
;
int64_t
toEvict
=
aSizeToEvict
;
int64_t
partialEvict
=
0
;
for
(
uint32_t
i
=
0
;
i
<
buffer
.
Length
(
)
;
i
+
+
)
{
const
auto
&
frame
=
buffer
[
i
]
;
if
(
frame
-
>
mKeyframe
)
{
lastKeyFrameIndex
=
i
;
toEvict
-
=
partialEvict
;
if
(
toEvict
<
0
)
{
break
;
}
partialEvict
=
0
;
}
if
(
frame
-
>
mTime
>
=
lowerLimit
.
ToMicroseconds
(
)
)
{
break
;
}
partialEvict
+
=
frame
-
>
ComputedSizeOfIncludingThis
(
)
;
}
if
(
lastKeyFrameIndex
>
0
)
{
MSE_DEBUG
(
"
Step1
.
Evicting
%
lld
bytes
prior
currentTime
"
aSizeToEvict
-
toEvict
)
;
CodedFrameRemoval
(
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
0
)
TimeUnit
:
:
FromMicroseconds
(
buffer
[
lastKeyFrameIndex
]
-
>
mTime
-
1
)
)
)
;
}
const
int64_t
finalSize
=
mSizeSourceBuffer
-
aSizeToEvict
;
if
(
mSizeSourceBuffer
<
=
finalSize
|
|
!
buffer
.
Length
(
)
)
{
return
;
}
toEvict
=
mSizeSourceBuffer
-
finalSize
;
TimeUnit
upperLimit
=
std
:
:
max
(
aPlaybackTime
track
.
mNextSampleTime
)
+
TimeUnit
:
:
FromSeconds
(
30
)
;
uint32_t
evictedFramesStartIndex
=
buffer
.
Length
(
)
;
for
(
int32_t
i
=
buffer
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
const
auto
&
frame
=
buffer
[
i
]
;
if
(
frame
-
>
mTime
<
=
upperLimit
.
ToMicroseconds
(
)
|
|
toEvict
<
0
)
{
evictedFramesStartIndex
=
i
+
1
;
break
;
}
toEvict
-
=
frame
-
>
ComputedSizeOfIncludingThis
(
)
;
}
if
(
evictedFramesStartIndex
<
buffer
.
Length
(
)
)
{
MSE_DEBUG
(
"
Step2
.
Evicting
%
lld
bytes
from
trailing
data
"
mSizeSourceBuffer
-
finalSize
-
toEvict
)
;
CodedFrameRemoval
(
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
buffer
[
evictedFramesStartIndex
]
-
>
mTime
)
TimeUnit
:
:
FromInfinity
(
)
)
)
;
}
}
RefPtr
<
TrackBuffersManager
:
:
RangeRemovalPromise
>
TrackBuffersManager
:
:
CodedFrameRemovalWithPromise
(
TimeInterval
aInterval
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
bool
rv
=
CodedFrameRemoval
(
aInterval
)
;
return
RangeRemovalPromise
:
:
CreateAndResolve
(
rv
__func__
)
;
}
bool
TrackBuffersManager
:
:
CodedFrameRemoval
(
TimeInterval
aInterval
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MSE_DEBUG
(
"
From
%
.
2fs
to
%
.
2f
"
aInterval
.
mStart
.
ToSeconds
(
)
aInterval
.
mEnd
.
ToSeconds
(
)
)
;
#
if
DEBUG
if
(
HasVideo
(
)
)
{
MSE_DEBUG
(
"
before
video
ranges
=
%
s
"
DumpTimeRanges
(
mVideoTracks
.
mBufferedRanges
)
.
get
(
)
)
;
}
if
(
HasAudio
(
)
)
{
MSE_DEBUG
(
"
before
audio
ranges
=
%
s
"
DumpTimeRanges
(
mAudioTracks
.
mBufferedRanges
)
.
get
(
)
)
;
}
#
endif
TimeUnit
start
=
aInterval
.
mStart
;
TimeUnit
end
=
aInterval
.
mEnd
;
bool
dataRemoved
=
false
;
for
(
auto
track
:
GetTracksList
(
)
)
{
MSE_DEBUGV
(
"
Processing
%
s
track
"
track
-
>
mInfo
-
>
mMimeType
.
get
(
)
)
;
TimeUnit
removeEndTimestamp
=
track
-
>
mBufferedRanges
.
GetEnd
(
)
;
if
(
start
>
removeEndTimestamp
)
{
continue
;
}
if
(
end
<
track
-
>
mBufferedRanges
.
GetEnd
(
)
)
{
for
(
auto
&
frame
:
track
-
>
mBuffers
.
LastElement
(
)
)
{
if
(
frame
-
>
mKeyframe
&
&
frame
-
>
mTime
>
=
end
.
ToMicroseconds
(
)
)
{
removeEndTimestamp
=
TimeUnit
:
:
FromMicroseconds
(
frame
-
>
mTime
)
;
break
;
}
}
}
TimeIntervals
removedInterval
{
TimeInterval
(
start
removeEndTimestamp
)
}
;
RemoveFrames
(
removedInterval
*
track
0
)
;
}
UpdateBufferedRanges
(
)
;
mSizeSourceBuffer
=
mVideoTracks
.
mSizeBuffer
+
mAudioTracks
.
mSizeBuffer
;
if
(
mBufferFull
&
&
mSizeSourceBuffer
<
EvictionThreshold
(
)
)
{
mBufferFull
=
false
;
}
mEvictionOccurred
=
true
;
return
dataRemoved
;
}
void
TrackBuffersManager
:
:
UpdateBufferedRanges
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
mVideoBufferedRanges
=
mVideoTracks
.
mSanitizedBufferedRanges
;
mAudioBufferedRanges
=
mAudioTracks
.
mSanitizedBufferedRanges
;
#
if
DEBUG
if
(
HasVideo
(
)
)
{
MSE_DEBUG
(
"
after
video
ranges
=
%
s
"
DumpTimeRanges
(
mVideoTracks
.
mBufferedRanges
)
.
get
(
)
)
;
}
if
(
HasAudio
(
)
)
{
MSE_DEBUG
(
"
after
audio
ranges
=
%
s
"
DumpTimeRanges
(
mAudioTracks
.
mBufferedRanges
)
.
get
(
)
)
;
}
#
endif
mOfficialGroupEndTimestamp
=
mGroupEndTimestamp
;
}
RefPtr
<
TrackBuffersManager
:
:
AppendPromise
>
TrackBuffersManager
:
:
InitSegmentParserLoop
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mAppendPromise
.
IsEmpty
(
)
)
;
MSE_DEBUG
(
"
"
)
;
RefPtr
<
AppendPromise
>
p
=
mAppendPromise
.
Ensure
(
__func__
)
;
AppendIncomingBuffers
(
)
;
SegmentParserLoop
(
)
;
return
p
;
}
void
TrackBuffersManager
:
:
AppendIncomingBuffers
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MonitorAutoLock
mon
(
mMonitor
)
;
for
(
auto
&
incomingBuffer
:
mIncomingBuffers
)
{
if
(
!
mInputBuffer
)
{
mInputBuffer
=
incomingBuffer
.
first
(
)
;
}
else
if
(
!
mInputBuffer
-
>
AppendElements
(
*
incomingBuffer
.
first
(
)
fallible
)
)
{
RejectAppend
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
}
mTimestampOffset
=
incomingBuffer
.
second
(
)
;
mLastTimestampOffset
=
mTimestampOffset
;
}
mIncomingBuffers
.
Clear
(
)
;
mAppendWindow
=
TimeInterval
(
TimeUnit
:
:
FromSeconds
(
mSourceBufferAttributes
-
>
GetAppendWindowStart
(
)
)
TimeUnit
:
:
FromSeconds
(
mSourceBufferAttributes
-
>
GetAppendWindowEnd
(
)
)
)
;
}
void
TrackBuffersManager
:
:
SegmentParserLoop
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
while
(
true
)
{
if
(
!
mInputBuffer
|
|
mInputBuffer
-
>
IsEmpty
(
)
)
{
NeedMoreData
(
)
;
return
;
}
if
(
mAppendState
=
=
AppendState
:
:
WAITING_FOR_SEGMENT
)
{
if
(
mParser
-
>
IsInitSegmentPresent
(
mInputBuffer
)
)
{
SetAppendState
(
AppendState
:
:
PARSING_INIT_SEGMENT
)
;
if
(
mFirstInitializationSegmentReceived
)
{
RecreateParser
(
false
)
;
}
continue
;
}
if
(
mParser
-
>
IsMediaSegmentPresent
(
mInputBuffer
)
)
{
SetAppendState
(
AppendState
:
:
PARSING_MEDIA_SEGMENT
)
;
mNewMediaSegmentStarted
=
true
;
continue
;
}
MSE_DEBUG
(
"
Found
invalid
or
incomplete
data
.
"
)
;
NeedMoreData
(
)
;
return
;
}
int64_t
start
end
;
bool
newData
=
mParser
-
>
ParseStartAndEndTimestamps
(
mInputBuffer
start
end
)
;
mProcessedInput
+
=
mInputBuffer
-
>
Length
(
)
;
if
(
mAppendState
=
=
AppendState
:
:
PARSING_INIT_SEGMENT
)
{
if
(
mParser
-
>
InitSegmentRange
(
)
.
IsEmpty
(
)
)
{
mInputBuffer
=
nullptr
;
NeedMoreData
(
)
;
return
;
}
InitializationSegmentReceived
(
)
;
return
;
}
if
(
mAppendState
=
=
AppendState
:
:
PARSING_MEDIA_SEGMENT
)
{
if
(
!
mFirstInitializationSegmentReceived
)
{
RejectAppend
(
NS_ERROR_FAILURE
__func__
)
;
return
;
}
if
(
mNewMediaSegmentStarted
)
{
if
(
newData
&
&
mLastParsedEndTime
.
isSome
(
)
&
&
start
<
mLastParsedEndTime
.
ref
(
)
.
ToMicroseconds
(
)
)
{
MSE_DEBUG
(
"
Re
-
creating
demuxer
"
)
;
ResetDemuxingState
(
)
;
return
;
}
if
(
newData
|
|
!
mParser
-
>
MediaSegmentRange
(
)
.
IsEmpty
(
)
)
{
if
(
mPendingInputBuffer
)
{
AppendDataToCurrentInputBuffer
(
mPendingInputBuffer
)
;
mPendingInputBuffer
=
nullptr
;
}
mNewMediaSegmentStarted
=
false
;
}
else
{
if
(
!
mPendingInputBuffer
)
{
mPendingInputBuffer
=
mInputBuffer
;
}
else
{
mPendingInputBuffer
-
>
AppendElements
(
*
mInputBuffer
)
;
}
mInputBuffer
=
nullptr
;
NeedMoreData
(
)
;
return
;
}
}
RefPtr
<
TrackBuffersManager
>
self
=
this
;
mProcessingRequest
.
Begin
(
CodedFrameProcessing
(
)
-
>
Then
(
GetTaskQueue
(
)
__func__
[
self
]
(
bool
aNeedMoreData
)
{
self
-
>
mProcessingRequest
.
Complete
(
)
;
if
(
aNeedMoreData
)
{
self
-
>
NeedMoreData
(
)
;
}
else
{
self
-
>
ScheduleSegmentParserLoop
(
)
;
}
}
[
self
]
(
nsresult
aRejectValue
)
{
self
-
>
mProcessingRequest
.
Complete
(
)
;
self
-
>
RejectAppend
(
aRejectValue
__func__
)
;
}
)
)
;
return
;
}
}
}
void
TrackBuffersManager
:
:
NeedMoreData
(
)
{
MSE_DEBUG
(
"
"
)
;
RestoreCachedVariables
(
)
;
mAppendRunning
=
false
;
{
MonitorAutoLock
mon
(
mMonitor
)
;
mon
.
NotifyAll
(
)
;
}
mAppendPromise
.
ResolveIfExists
(
mActiveTrack
__func__
)
;
}
void
TrackBuffersManager
:
:
RejectAppend
(
nsresult
aRejectValue
const
char
*
aName
)
{
MSE_DEBUG
(
"
rv
=
%
d
"
aRejectValue
)
;
mAppendRunning
=
false
;
{
MonitorAutoLock
mon
(
mMonitor
)
;
mon
.
NotifyAll
(
)
;
}
mAppendPromise
.
RejectIfExists
(
aRejectValue
aName
)
;
}
void
TrackBuffersManager
:
:
ScheduleSegmentParserLoop
(
)
{
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableMethod
(
this
&
TrackBuffersManager
:
:
SegmentParserLoop
)
;
GetTaskQueue
(
)
-
>
Dispatch
(
task
.
forget
(
)
)
;
}
void
TrackBuffersManager
:
:
ShutdownDemuxers
(
)
{
if
(
mVideoTracks
.
mDemuxer
)
{
mVideoTracks
.
mDemuxer
-
>
BreakCycles
(
)
;
mVideoTracks
.
mDemuxer
=
nullptr
;
}
if
(
mAudioTracks
.
mDemuxer
)
{
mAudioTracks
.
mDemuxer
-
>
BreakCycles
(
)
;
mAudioTracks
.
mDemuxer
=
nullptr
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
mDemuxerInitRequest
.
Exists
(
)
)
;
mInputDemuxer
=
nullptr
;
mLastParsedEndTime
.
reset
(
)
;
}
void
TrackBuffersManager
:
:
CreateDemuxerforMIMEType
(
)
{
ShutdownDemuxers
(
)
;
if
(
mType
.
LowerCaseEqualsLiteral
(
"
video
/
webm
"
)
|
|
mType
.
LowerCaseEqualsLiteral
(
"
audio
/
webm
"
)
)
{
mInputDemuxer
=
new
WebMDemuxer
(
mCurrentInputBuffer
true
)
;
return
;
}
#
ifdef
MOZ_FMP4
if
(
mType
.
LowerCaseEqualsLiteral
(
"
video
/
mp4
"
)
|
|
mType
.
LowerCaseEqualsLiteral
(
"
audio
/
mp4
"
)
)
{
mInputDemuxer
=
new
MP4Demuxer
(
mCurrentInputBuffer
)
;
return
;
}
#
endif
NS_WARNING
(
"
Not
supported
(
yet
)
"
)
;
return
;
}
void
TrackBuffersManager
:
:
ResetDemuxingState
(
)
{
MOZ_ASSERT
(
mParser
&
&
mParser
-
>
HasInitData
(
)
)
;
RecreateParser
(
true
)
;
mCurrentInputBuffer
=
new
SourceBufferResource
(
mType
)
;
mCurrentInputBuffer
-
>
AppendData
(
mParser
-
>
InitData
(
)
)
;
CreateDemuxerforMIMEType
(
)
;
if
(
!
mInputDemuxer
)
{
RejectAppend
(
NS_ERROR_FAILURE
__func__
)
;
return
;
}
mDemuxerInitRequest
.
Begin
(
mInputDemuxer
-
>
Init
(
)
-
>
Then
(
GetTaskQueue
(
)
__func__
this
&
TrackBuffersManager
:
:
OnDemuxerResetDone
&
TrackBuffersManager
:
:
OnDemuxerInitFailed
)
)
;
}
void
TrackBuffersManager
:
:
OnDemuxerResetDone
(
nsresult
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mDemuxerInitRequest
.
Complete
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInputDemuxer
)
;
uint32_t
numVideos
=
mInputDemuxer
-
>
GetNumberTracks
(
TrackInfo
:
:
kVideoTrack
)
;
if
(
numVideos
)
{
mVideoTracks
.
mDemuxer
=
mInputDemuxer
-
>
GetTrackDemuxer
(
TrackInfo
:
:
kVideoTrack
0
)
;
MOZ_ASSERT
(
mVideoTracks
.
mDemuxer
)
;
}
uint32_t
numAudios
=
mInputDemuxer
-
>
GetNumberTracks
(
TrackInfo
:
:
kAudioTrack
)
;
if
(
numAudios
)
{
mAudioTracks
.
mDemuxer
=
mInputDemuxer
-
>
GetTrackDemuxer
(
TrackInfo
:
:
kAudioTrack
0
)
;
MOZ_ASSERT
(
mAudioTracks
.
mDemuxer
)
;
}
if
(
mPendingInputBuffer
)
{
int64_t
start
end
;
mParser
-
>
ParseStartAndEndTimestamps
(
mPendingInputBuffer
start
end
)
;
mProcessedInput
+
=
mPendingInputBuffer
-
>
Length
(
)
;
}
SegmentParserLoop
(
)
;
}
void
TrackBuffersManager
:
:
AppendDataToCurrentInputBuffer
(
MediaByteBuffer
*
aData
)
{
MOZ_ASSERT
(
mCurrentInputBuffer
)
;
mCurrentInputBuffer
-
>
AppendData
(
aData
)
;
mInputDemuxer
-
>
NotifyDataArrived
(
)
;
}
void
TrackBuffersManager
:
:
InitializationSegmentReceived
(
)
{
MOZ_ASSERT
(
mParser
-
>
HasCompleteInitData
(
)
)
;
mCurrentInputBuffer
=
new
SourceBufferResource
(
mType
)
;
mCurrentInputBuffer
-
>
AppendData
(
mParser
-
>
InitData
(
)
)
;
uint32_t
length
=
mParser
-
>
InitSegmentRange
(
)
.
mEnd
-
(
mProcessedInput
-
mInputBuffer
-
>
Length
(
)
)
;
if
(
mInputBuffer
-
>
Length
(
)
=
=
length
)
{
mInputBuffer
=
nullptr
;
}
else
{
mInputBuffer
-
>
RemoveElementsAt
(
0
length
)
;
}
CreateDemuxerforMIMEType
(
)
;
if
(
!
mInputDemuxer
)
{
NS_WARNING
(
"
TODO
type
not
supported
"
)
;
RejectAppend
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
__func__
)
;
return
;
}
mDemuxerInitRequest
.
Begin
(
mInputDemuxer
-
>
Init
(
)
-
>
Then
(
GetTaskQueue
(
)
__func__
this
&
TrackBuffersManager
:
:
OnDemuxerInitDone
&
TrackBuffersManager
:
:
OnDemuxerInitFailed
)
)
;
}
void
TrackBuffersManager
:
:
OnDemuxerInitDone
(
nsresult
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mDemuxerInitRequest
.
Complete
(
)
;
if
(
!
mInputDemuxer
)
{
NS_ASSERTION
(
false
"
mInputDemuxer
has
been
destroyed
"
)
;
RejectAppend
(
NS_ERROR_ABORT
__func__
)
;
}
MediaInfo
info
;
uint32_t
numVideos
=
mInputDemuxer
-
>
GetNumberTracks
(
TrackInfo
:
:
kVideoTrack
)
;
if
(
numVideos
)
{
mVideoTracks
.
mDemuxer
=
mInputDemuxer
-
>
GetTrackDemuxer
(
TrackInfo
:
:
kVideoTrack
0
)
;
MOZ_ASSERT
(
mVideoTracks
.
mDemuxer
)
;
info
.
mVideo
=
*
mVideoTracks
.
mDemuxer
-
>
GetInfo
(
)
-
>
GetAsVideoInfo
(
)
;
info
.
mVideo
.
mTrackId
=
2
;
}
uint32_t
numAudios
=
mInputDemuxer
-
>
GetNumberTracks
(
TrackInfo
:
:
kAudioTrack
)
;
if
(
numAudios
)
{
mAudioTracks
.
mDemuxer
=
mInputDemuxer
-
>
GetTrackDemuxer
(
TrackInfo
:
:
kAudioTrack
0
)
;
MOZ_ASSERT
(
mAudioTracks
.
mDemuxer
)
;
info
.
mAudio
=
*
mAudioTracks
.
mDemuxer
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
;
info
.
mAudio
.
mTrackId
=
1
;
}
int64_t
videoDuration
=
numVideos
?
info
.
mVideo
.
mDuration
:
0
;
int64_t
audioDuration
=
numAudios
?
info
.
mAudio
.
mDuration
:
0
;
int64_t
duration
=
std
:
:
max
(
videoDuration
audioDuration
)
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableMethodWithArg
<
int64_t
>
(
mParentDecoder
&
MediaSourceDecoder
:
:
SetInitialDuration
duration
?
duration
:
-
1
)
;
AbstractThread
:
:
MainThread
(
)
-
>
Dispatch
(
task
.
forget
(
)
)
;
if
(
!
numVideos
&
&
!
numAudios
)
{
RejectAppend
(
NS_ERROR_FAILURE
__func__
)
;
return
;
}
if
(
mFirstInitializationSegmentReceived
)
{
if
(
numVideos
!
=
mVideoTracks
.
mNumTracks
|
|
numAudios
!
=
mAudioTracks
.
mNumTracks
|
|
(
numVideos
&
&
info
.
mVideo
.
mMimeType
!
=
mVideoTracks
.
mInfo
-
>
mMimeType
)
|
|
(
numAudios
&
&
info
.
mAudio
.
mMimeType
!
=
mAudioTracks
.
mInfo
-
>
mMimeType
)
)
{
RejectAppend
(
NS_ERROR_FAILURE
__func__
)
;
return
;
}
mVideoTracks
.
mNeedRandomAccessPoint
=
true
;
mAudioTracks
.
mNeedRandomAccessPoint
=
true
;
mVideoTracks
.
mLongestFrameDuration
=
mVideoTracks
.
mLastFrameDuration
;
mAudioTracks
.
mLongestFrameDuration
=
mAudioTracks
.
mLastFrameDuration
;
}
bool
activeTrack
=
false
;
uint32_t
streamID
=
sStreamSourceID
+
+
;
if
(
!
mFirstInitializationSegmentReceived
)
{
mAudioTracks
.
mNumTracks
=
numAudios
;
if
(
numAudios
)
{
activeTrack
=
true
;
mAudioTracks
.
mBuffers
.
AppendElement
(
TrackBuffer
(
)
)
;
mAudioTracks
.
mInfo
=
new
SharedTrackInfo
(
info
.
mAudio
streamID
)
;
mAudioTracks
.
mLastInfo
=
mAudioTracks
.
mInfo
;
}
mVideoTracks
.
mNumTracks
=
numVideos
;
if
(
numVideos
)
{
activeTrack
=
true
;
mVideoTracks
.
mBuffers
.
AppendElement
(
TrackBuffer
(
)
)
;
mVideoTracks
.
mInfo
=
new
SharedTrackInfo
(
info
.
mVideo
streamID
)
;
mVideoTracks
.
mLastInfo
=
mVideoTracks
.
mInfo
;
}
if
(
activeTrack
)
{
mActiveTrack
=
true
;
}
mFirstInitializationSegmentReceived
=
true
;
}
else
{
if
(
mAudioTracks
.
mNumTracks
&
&
(
info
.
mAudio
.
mChannels
!
=
mAudioTracks
.
mInfo
-
>
GetAsAudioInfo
(
)
-
>
mChannels
|
|
info
.
mAudio
.
mRate
!
=
mAudioTracks
.
mInfo
-
>
GetAsAudioInfo
(
)
-
>
mRate
)
)
{
RejectAppend
(
NS_ERROR_FAILURE
__func__
)
;
}
mAudioTracks
.
mLastInfo
=
new
SharedTrackInfo
(
info
.
mAudio
streamID
)
;
mVideoTracks
.
mLastInfo
=
new
SharedTrackInfo
(
info
.
mVideo
streamID
)
;
}
UniquePtr
<
EncryptionInfo
>
crypto
=
mInputDemuxer
-
>
GetCrypto
(
)
;
if
(
crypto
&
&
crypto
-
>
IsEncrypted
(
)
)
{
#
ifdef
MOZ_EME
for
(
uint32_t
i
=
0
;
i
<
crypto
-
>
mInitDatas
.
Length
(
)
;
i
+
+
)
{
NS_DispatchToMainThread
(
new
DispatchKeyNeededEvent
(
mParentDecoder
crypto
-
>
mInitDatas
[
i
]
.
mInitData
NS_LITERAL_STRING
(
"
cenc
"
)
)
)
;
}
#
endif
info
.
mCrypto
=
*
crypto
;
info
.
mCrypto
.
mInitDatas
.
Clear
(
)
;
mEncrypted
=
true
;
}
{
MonitorAutoLock
mon
(
mMonitor
)
;
mInfo
=
info
;
}
mInitData
=
mParser
-
>
InitData
(
)
;
mCurrentInputBuffer
-
>
EvictAll
(
)
;
mInputDemuxer
-
>
NotifyDataRemoved
(
)
;
RecreateParser
(
true
)
;
SetAppendState
(
AppendState
:
:
WAITING_FOR_SEGMENT
)
;
ScheduleSegmentParserLoop
(
)
;
}
void
TrackBuffersManager
:
:
OnDemuxerInitFailed
(
DemuxerFailureReason
aFailure
)
{
MOZ_ASSERT
(
aFailure
!
=
DemuxerFailureReason
:
:
WAITING_FOR_DATA
)
;
mDemuxerInitRequest
.
Complete
(
)
;
RejectAppend
(
NS_ERROR_FAILURE
__func__
)
;
}
RefPtr
<
TrackBuffersManager
:
:
CodedFrameProcessingPromise
>
TrackBuffersManager
:
:
CodedFrameProcessing
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mProcessingPromise
.
IsEmpty
(
)
)
;
MediaByteRange
mediaRange
=
mParser
-
>
MediaSegmentRange
(
)
;
if
(
mediaRange
.
IsEmpty
(
)
)
{
AppendDataToCurrentInputBuffer
(
mInputBuffer
)
;
mInputBuffer
=
nullptr
;
}
else
{
MOZ_ASSERT
(
mProcessedInput
>
=
mInputBuffer
-
>
Length
(
)
)
;
if
(
int64_t
(
mProcessedInput
-
mInputBuffer
-
>
Length
(
)
)
>
mediaRange
.
mEnd
)
{
return
CodedFrameProcessingPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
uint32_t
length
=
mediaRange
.
mEnd
-
(
mProcessedInput
-
mInputBuffer
-
>
Length
(
)
)
;
if
(
!
length
)
{
RefPtr
<
CodedFrameProcessingPromise
>
p
=
mProcessingPromise
.
Ensure
(
__func__
)
;
CompleteCodedFrameProcessing
(
)
;
return
p
;
}
RefPtr
<
MediaByteBuffer
>
segment
=
new
MediaByteBuffer
;
if
(
!
segment
-
>
AppendElements
(
mInputBuffer
-
>
Elements
(
)
length
fallible
)
)
{
return
CodedFrameProcessingPromise
:
:
CreateAndReject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
}
AppendDataToCurrentInputBuffer
(
segment
)
;
mInputBuffer
-
>
RemoveElementsAt
(
0
length
)
;
}
RefPtr
<
CodedFrameProcessingPromise
>
p
=
mProcessingPromise
.
Ensure
(
__func__
)
;
DoDemuxVideo
(
)
;
return
p
;
}
void
TrackBuffersManager
:
:
OnDemuxFailed
(
TrackType
aTrack
DemuxerFailureReason
aFailure
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MSE_DEBUG
(
"
Failed
to
demux
%
s
failure
:
%
d
"
aTrack
=
=
TrackType
:
:
kVideoTrack
?
"
video
"
:
"
audio
"
aFailure
)
;
switch
(
aFailure
)
{
case
DemuxerFailureReason
:
:
END_OF_STREAM
:
case
DemuxerFailureReason
:
:
WAITING_FOR_DATA
:
if
(
aTrack
=
=
TrackType
:
:
kVideoTrack
)
{
DoDemuxAudio
(
)
;
}
else
{
CompleteCodedFrameProcessing
(
)
;
}
break
;
case
DemuxerFailureReason
:
:
DEMUXER_ERROR
:
RejectProcessing
(
NS_ERROR_FAILURE
__func__
)
;
break
;
case
DemuxerFailureReason
:
:
CANCELED
:
case
DemuxerFailureReason
:
:
SHUTDOWN
:
RejectProcessing
(
NS_ERROR_ABORT
__func__
)
;
break
;
default
:
MOZ_ASSERT
(
false
)
;
break
;
}
}
void
TrackBuffersManager
:
:
DoDemuxVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
!
HasVideo
(
)
)
{
DoDemuxAudio
(
)
;
return
;
}
mVideoTracks
.
mDemuxRequest
.
Begin
(
mVideoTracks
.
mDemuxer
-
>
GetSamples
(
-
1
)
-
>
Then
(
GetTaskQueue
(
)
__func__
this
&
TrackBuffersManager
:
:
OnVideoDemuxCompleted
&
TrackBuffersManager
:
:
OnVideoDemuxFailed
)
)
;
}
void
TrackBuffersManager
:
:
OnVideoDemuxCompleted
(
RefPtr
<
MediaTrackDemuxer
:
:
SamplesHolder
>
aSamples
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MSE_DEBUG
(
"
%
d
video
samples
demuxed
"
aSamples
-
>
mSamples
.
Length
(
)
)
;
mVideoTracks
.
mDemuxRequest
.
Complete
(
)
;
mVideoTracks
.
mQueuedSamples
.
AppendElements
(
aSamples
-
>
mSamples
)
;
DoDemuxAudio
(
)
;
}
void
TrackBuffersManager
:
:
DoDemuxAudio
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
!
HasAudio
(
)
)
{
CompleteCodedFrameProcessing
(
)
;
return
;
}
mAudioTracks
.
mDemuxRequest
.
Begin
(
mAudioTracks
.
mDemuxer
-
>
GetSamples
(
-
1
)
-
>
Then
(
GetTaskQueue
(
)
__func__
this
&
TrackBuffersManager
:
:
OnAudioDemuxCompleted
&
TrackBuffersManager
:
:
OnAudioDemuxFailed
)
)
;
}
void
TrackBuffersManager
:
:
OnAudioDemuxCompleted
(
RefPtr
<
MediaTrackDemuxer
:
:
SamplesHolder
>
aSamples
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MSE_DEBUG
(
"
%
d
audio
samples
demuxed
"
aSamples
-
>
mSamples
.
Length
(
)
)
;
mAudioTracks
.
mDemuxRequest
.
Complete
(
)
;
mAudioTracks
.
mQueuedSamples
.
AppendElements
(
aSamples
-
>
mSamples
)
;
CompleteCodedFrameProcessing
(
)
;
}
void
TrackBuffersManager
:
:
CompleteCodedFrameProcessing
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
ProcessFrames
(
mVideoTracks
.
mQueuedSamples
mVideoTracks
)
;
mVideoTracks
.
mQueuedSamples
.
Clear
(
)
;
#
if
defined
(
DEBUG
)
if
(
HasVideo
(
)
)
{
const
auto
&
track
=
mVideoTracks
.
mBuffers
.
LastElement
(
)
;
MOZ_ASSERT
(
track
.
IsEmpty
(
)
|
|
track
[
0
]
-
>
mKeyframe
)
;
for
(
uint32_t
i
=
1
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
(
track
[
i
-
1
]
-
>
mTrackInfo
-
>
GetID
(
)
=
=
track
[
i
]
-
>
mTrackInfo
-
>
GetID
(
)
&
&
track
[
i
-
1
]
-
>
mTimecode
<
=
track
[
i
]
-
>
mTimecode
)
|
|
track
[
i
]
-
>
mKeyframe
)
;
}
}
#
endif
ProcessFrames
(
mAudioTracks
.
mQueuedSamples
mAudioTracks
)
;
mAudioTracks
.
mQueuedSamples
.
Clear
(
)
;
#
if
defined
(
DEBUG
)
if
(
HasAudio
(
)
)
{
const
auto
&
track
=
mAudioTracks
.
mBuffers
.
LastElement
(
)
;
MOZ_ASSERT
(
track
.
IsEmpty
(
)
|
|
track
[
0
]
-
>
mKeyframe
)
;
for
(
uint32_t
i
=
1
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
(
track
[
i
-
1
]
-
>
mTrackInfo
-
>
GetID
(
)
=
=
track
[
i
]
-
>
mTrackInfo
-
>
GetID
(
)
&
&
track
[
i
-
1
]
-
>
mTimecode
<
=
track
[
i
]
-
>
mTimecode
)
|
|
track
[
i
]
-
>
mKeyframe
)
;
}
}
#
endif
UpdateBufferedRanges
(
)
;
mSizeSourceBuffer
=
mVideoTracks
.
mSizeBuffer
+
mAudioTracks
.
mSizeBuffer
;
if
(
mSizeSourceBuffer
>
=
EvictionThreshold
(
)
)
{
mBufferFull
=
true
;
mEvictionOccurred
=
false
;
}
if
(
mParser
-
>
MediaSegmentRange
(
)
.
IsEmpty
(
)
)
{
ResolveProcessing
(
true
__func__
)
;
return
;
}
mLastParsedEndTime
=
Some
(
std
:
:
max
(
mAudioTracks
.
mLastParsedEndTime
mVideoTracks
.
mLastParsedEndTime
)
)
;
mCurrentInputBuffer
-
>
EvictAll
(
)
;
mInputDemuxer
-
>
NotifyDataRemoved
(
)
;
RecreateParser
(
true
)
;
SetAppendState
(
AppendState
:
:
WAITING_FOR_SEGMENT
)
;
ResolveProcessing
(
false
__func__
)
;
}
void
TrackBuffersManager
:
:
RejectProcessing
(
nsresult
aRejectValue
const
char
*
aName
)
{
mProcessingPromise
.
RejectIfExists
(
aRejectValue
__func__
)
;
}
void
TrackBuffersManager
:
:
ResolveProcessing
(
bool
aResolveValue
const
char
*
aName
)
{
mProcessingPromise
.
ResolveIfExists
(
aResolveValue
__func__
)
;
}
void
TrackBuffersManager
:
:
CheckSequenceDiscontinuity
(
const
TimeUnit
&
aPresentationTime
)
{
if
(
mSourceBufferAttributes
-
>
GetAppendMode
(
)
=
=
SourceBufferAppendMode
:
:
Sequence
&
&
mGroupStartTimestamp
.
isSome
(
)
)
{
mTimestampOffset
=
mGroupStartTimestamp
.
ref
(
)
-
aPresentationTime
;
mGroupEndTimestamp
=
mGroupStartTimestamp
.
ref
(
)
;
mVideoTracks
.
mNeedRandomAccessPoint
=
true
;
mAudioTracks
.
mNeedRandomAccessPoint
=
true
;
mGroupStartTimestamp
.
reset
(
)
;
}
}
void
TrackBuffersManager
:
:
ProcessFrames
(
TrackBuffer
&
aSamples
TrackData
&
aTrackData
)
{
if
(
!
aSamples
.
Length
(
)
)
{
return
;
}
TimeUnit
presentationTimestamp
=
mSourceBufferAttributes
-
>
mGenerateTimestamps
?
TimeUnit
(
)
:
TimeUnit
:
:
FromMicroseconds
(
aSamples
[
0
]
-
>
mTime
)
;
CheckSequenceDiscontinuity
(
presentationTimestamp
)
;
auto
&
trackBuffer
=
aTrackData
;
TimeInterval
targetWindow
=
mAppendWindow
.
mStart
!
=
TimeUnit
:
:
FromSeconds
(
0
)
?
mAppendWindow
:
TimeInterval
(
mAppendWindow
.
mStart
mAppendWindow
.
mEnd
trackBuffer
.
mLongestFrameDuration
.
refOr
(
TimeUnit
:
:
FromMicroseconds
(
aSamples
[
0
]
-
>
mDuration
)
)
)
;
TimeIntervals
samplesRange
;
uint32_t
sizeNewSamples
=
0
;
TrackBuffer
samples
;
bool
needDiscontinuityCheck
=
true
;
if
(
aSamples
.
Length
(
)
)
{
aTrackData
.
mLastParsedEndTime
=
TimeUnit
(
)
;
}
for
(
auto
&
sample
:
aSamples
)
{
SAMPLE_DEBUG
(
"
Processing
%
s
frame
(
pts
:
%
lld
end
:
%
lld
dts
:
%
lld
duration
:
%
lld
"
"
kf
:
%
d
)
"
aTrackData
.
mInfo
-
>
mMimeType
.
get
(
)
sample
-
>
mTime
sample
-
>
GetEndTime
(
)
sample
-
>
mTimecode
sample
-
>
mDuration
sample
-
>
mKeyframe
)
;
const
TimeUnit
sampleEndTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
;
if
(
sampleEndTime
>
aTrackData
.
mLastParsedEndTime
)
{
aTrackData
.
mLastParsedEndTime
=
sampleEndTime
;
}
if
(
trackBuffer
.
mNeedRandomAccessPoint
)
{
if
(
!
sample
-
>
mKeyframe
)
{
continue
;
}
trackBuffer
.
mNeedRandomAccessPoint
=
false
;
}
TimeInterval
sampleInterval
=
mSourceBufferAttributes
-
>
mGenerateTimestamps
?
TimeInterval
(
mTimestampOffset
mTimestampOffset
+
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mDuration
)
)
:
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
+
mTimestampOffset
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
+
mTimestampOffset
)
;
TimeUnit
decodeTimestamp
=
mSourceBufferAttributes
-
>
mGenerateTimestamps
?
mTimestampOffset
:
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
)
+
mTimestampOffset
;
if
(
needDiscontinuityCheck
&
&
trackBuffer
.
mLastDecodeTimestamp
.
isSome
(
)
&
&
(
decodeTimestamp
<
trackBuffer
.
mLastDecodeTimestamp
.
ref
(
)
|
|
decodeTimestamp
-
trackBuffer
.
mLastDecodeTimestamp
.
ref
(
)
>
2
*
trackBuffer
.
mLongestFrameDuration
.
ref
(
)
)
)
{
MSE_DEBUG
(
"
Discontinuity
detected
.
"
)
;
SourceBufferAppendMode
appendMode
=
mSourceBufferAttributes
-
>
GetAppendMode
(
)
;
if
(
appendMode
=
=
SourceBufferAppendMode
:
:
Segments
)
{
mGroupEndTimestamp
=
sampleInterval
.
mStart
;
}
if
(
appendMode
=
=
SourceBufferAppendMode
:
:
Sequence
)
{
mGroupStartTimestamp
=
Some
(
mGroupEndTimestamp
)
;
}
for
(
auto
&
track
:
GetTracksList
(
)
)
{
track
-
>
ResetAppendState
(
)
;
}
TimeUnit
presentationTimestamp
=
mSourceBufferAttributes
-
>
mGenerateTimestamps
?
TimeUnit
(
)
:
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
;
CheckSequenceDiscontinuity
(
presentationTimestamp
)
;
if
(
!
sample
-
>
mKeyframe
)
{
continue
;
}
if
(
appendMode
=
=
SourceBufferAppendMode
:
:
Sequence
)
{
sampleInterval
=
mSourceBufferAttributes
-
>
mGenerateTimestamps
?
TimeInterval
(
mTimestampOffset
mTimestampOffset
+
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mDuration
)
)
:
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
+
mTimestampOffset
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
+
mTimestampOffset
)
;
decodeTimestamp
=
mSourceBufferAttributes
-
>
mGenerateTimestamps
?
mTimestampOffset
:
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
)
+
mTimestampOffset
;
}
trackBuffer
.
mNeedRandomAccessPoint
=
false
;
needDiscontinuityCheck
=
false
;
}
if
(
!
targetWindow
.
ContainsWithStrictEnd
(
sampleInterval
)
)
{
if
(
samples
.
Length
(
)
)
{
InsertFrames
(
samples
samplesRange
trackBuffer
)
;
samples
.
Clear
(
)
;
samplesRange
=
TimeIntervals
(
)
;
trackBuffer
.
mSizeBuffer
+
=
sizeNewSamples
;
sizeNewSamples
=
0
;
}
trackBuffer
.
mNeedRandomAccessPoint
=
true
;
needDiscontinuityCheck
=
true
;
continue
;
}
samplesRange
+
=
sampleInterval
;
sizeNewSamples
+
=
sample
-
>
ComputedSizeOfIncludingThis
(
)
;
sample
-
>
mTime
=
sampleInterval
.
mStart
.
ToMicroseconds
(
)
;
sample
-
>
mTimecode
=
decodeTimestamp
.
ToMicroseconds
(
)
;
sample
-
>
mTrackInfo
=
trackBuffer
.
mLastInfo
;
samples
.
AppendElement
(
sample
)
;
trackBuffer
.
mLastDecodeTimestamp
=
Some
(
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
)
)
;
trackBuffer
.
mLastFrameDuration
=
Some
(
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mDuration
)
)
;
trackBuffer
.
mLongestFrameDuration
=
Some
(
trackBuffer
.
mLongestFrameDuration
.
isNothing
(
)
?
trackBuffer
.
mLastFrameDuration
.
ref
(
)
:
std
:
:
max
(
trackBuffer
.
mLastFrameDuration
.
ref
(
)
trackBuffer
.
mLongestFrameDuration
.
ref
(
)
)
)
;
if
(
trackBuffer
.
mHighestEndTimestamp
.
isNothing
(
)
|
|
sampleInterval
.
mEnd
>
trackBuffer
.
mHighestEndTimestamp
.
ref
(
)
)
{
trackBuffer
.
mHighestEndTimestamp
=
Some
(
sampleInterval
.
mEnd
)
;
}
if
(
sampleInterval
.
mEnd
>
mGroupEndTimestamp
)
{
mGroupEndTimestamp
=
sampleInterval
.
mEnd
;
}
if
(
mSourceBufferAttributes
-
>
mGenerateTimestamps
)
{
mTimestampOffset
=
sampleInterval
.
mEnd
;
}
}
if
(
samples
.
Length
(
)
)
{
InsertFrames
(
samples
samplesRange
trackBuffer
)
;
trackBuffer
.
mSizeBuffer
+
=
sizeNewSamples
;
}
}
bool
TrackBuffersManager
:
:
CheckNextInsertionIndex
(
TrackData
&
aTrackData
const
TimeUnit
&
aSampleTime
)
{
if
(
aTrackData
.
mNextInsertionIndex
.
isSome
(
)
)
{
return
true
;
}
TrackBuffer
&
data
=
aTrackData
.
mBuffers
.
LastElement
(
)
;
if
(
data
.
IsEmpty
(
)
|
|
aSampleTime
<
aTrackData
.
mBufferedRanges
.
GetStart
(
)
)
{
aTrackData
.
mNextInsertionIndex
=
Some
(
size_t
(
0
)
)
;
return
true
;
}
TimeInterval
target
;
for
(
const
auto
&
interval
:
aTrackData
.
mBufferedRanges
)
{
if
(
aSampleTime
<
interval
.
mStart
)
{
target
=
interval
;
break
;
}
}
if
(
target
.
IsEmpty
(
)
)
{
aTrackData
.
mNextInsertionIndex
=
Some
(
data
.
Length
(
)
)
;
return
true
;
}
for
(
uint32_t
i
=
0
;
i
<
data
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
data
[
i
]
;
if
(
sample
-
>
mTime
>
=
target
.
mStart
.
ToMicroseconds
(
)
|
|
sample
-
>
GetEndTime
(
)
>
target
.
mStart
.
ToMicroseconds
(
)
)
{
aTrackData
.
mNextInsertionIndex
=
Some
(
size_t
(
i
)
)
;
return
true
;
}
}
NS_ASSERTION
(
false
"
Insertion
Index
Not
Found
"
)
;
return
false
;
}
void
TrackBuffersManager
:
:
InsertFrames
(
TrackBuffer
&
aSamples
const
TimeIntervals
&
aIntervals
TrackData
&
aTrackData
)
{
auto
&
trackBuffer
=
aTrackData
;
MSE_DEBUGV
(
"
Processing
%
d
%
s
frames
(
start
:
%
lld
end
:
%
lld
)
"
aSamples
.
Length
(
)
aTrackData
.
mInfo
-
>
mMimeType
.
get
(
)
aIntervals
.
GetStart
(
)
.
ToMicroseconds
(
)
aIntervals
.
GetEnd
(
)
.
ToMicroseconds
(
)
)
;
TimeIntervals
intersection
=
trackBuffer
.
mBufferedRanges
;
intersection
.
Intersection
(
aIntervals
)
;
if
(
intersection
.
Length
(
)
)
{
RemoveFrames
(
aIntervals
trackBuffer
trackBuffer
.
mNextInsertionIndex
.
refOr
(
0
)
)
;
}
if
(
!
CheckNextInsertionIndex
(
aTrackData
TimeUnit
:
:
FromMicroseconds
(
aSamples
[
0
]
-
>
mTime
)
)
)
{
RejectProcessing
(
NS_ERROR_FAILURE
__func__
)
;
return
;
}
if
(
trackBuffer
.
mNextGetSampleIndex
.
isSome
(
)
)
{
if
(
trackBuffer
.
mNextInsertionIndex
.
ref
(
)
=
=
trackBuffer
.
mNextGetSampleIndex
.
ref
(
)
&
&
aIntervals
.
GetEnd
(
)
>
=
trackBuffer
.
mNextSampleTime
)
{
MSE_DEBUG
(
"
Next
sample
to
be
played
got
overwritten
"
)
;
trackBuffer
.
mNextGetSampleIndex
.
reset
(
)
;
}
else
if
(
trackBuffer
.
mNextInsertionIndex
.
ref
(
)
<
=
trackBuffer
.
mNextGetSampleIndex
.
ref
(
)
)
{
trackBuffer
.
mNextGetSampleIndex
.
ref
(
)
+
=
aSamples
.
Length
(
)
;
}
}
TrackBuffer
&
data
=
trackBuffer
.
mBuffers
.
LastElement
(
)
;
data
.
InsertElementsAt
(
trackBuffer
.
mNextInsertionIndex
.
ref
(
)
aSamples
)
;
trackBuffer
.
mNextInsertionIndex
.
ref
(
)
+
=
aSamples
.
Length
(
)
;
trackBuffer
.
mBufferedRanges
+
=
aIntervals
;
TimeIntervals
range
(
aIntervals
)
;
range
.
SetFuzz
(
trackBuffer
.
mLongestFrameDuration
.
ref
(
)
/
2
)
;
trackBuffer
.
mSanitizedBufferedRanges
+
=
range
;
}
void
TrackBuffersManager
:
:
RemoveFrames
(
const
TimeIntervals
&
aIntervals
TrackData
&
aTrackData
uint32_t
aStartIndex
)
{
TrackBuffer
&
data
=
aTrackData
.
mBuffers
.
LastElement
(
)
;
Maybe
<
uint32_t
>
firstRemovedIndex
;
uint32_t
lastRemovedIndex
=
0
;
for
(
uint32_t
i
=
aStartIndex
;
i
<
data
.
Length
(
)
;
i
+
+
)
{
MediaRawData
*
sample
=
data
[
i
]
.
get
(
)
;
TimeInterval
sampleInterval
=
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
)
;
if
(
aIntervals
.
Contains
(
sampleInterval
)
)
{
if
(
firstRemovedIndex
.
isNothing
(
)
)
{
firstRemovedIndex
=
Some
(
i
)
;
}
lastRemovedIndex
=
i
;
}
}
if
(
firstRemovedIndex
.
isNothing
(
)
)
{
return
;
}
for
(
uint32_t
i
=
lastRemovedIndex
+
1
;
i
<
data
.
Length
(
)
;
i
+
+
)
{
MediaRawData
*
sample
=
data
[
i
]
.
get
(
)
;
if
(
sample
-
>
mKeyframe
)
{
break
;
}
lastRemovedIndex
=
i
;
}
int64_t
maxSampleDuration
=
0
;
TimeIntervals
removedIntervals
;
for
(
uint32_t
i
=
firstRemovedIndex
.
ref
(
)
;
i
<
=
lastRemovedIndex
;
i
+
+
)
{
MediaRawData
*
sample
=
data
[
i
]
.
get
(
)
;
TimeInterval
sampleInterval
=
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
)
;
removedIntervals
+
=
sampleInterval
;
if
(
sample
-
>
mDuration
>
maxSampleDuration
)
{
maxSampleDuration
=
sample
-
>
mDuration
;
}
aTrackData
.
mSizeBuffer
-
=
sample
-
>
ComputedSizeOfIncludingThis
(
)
;
}
MSE_DEBUG
(
"
Removing
frames
from
:
%
u
(
frames
:
%
u
)
(
[
%
f
%
f
)
)
"
firstRemovedIndex
.
ref
(
)
lastRemovedIndex
-
firstRemovedIndex
.
ref
(
)
+
1
removedIntervals
.
GetStart
(
)
.
ToSeconds
(
)
removedIntervals
.
GetEnd
(
)
.
ToSeconds
(
)
)
;
if
(
aTrackData
.
mNextGetSampleIndex
.
isSome
(
)
)
{
if
(
aTrackData
.
mNextGetSampleIndex
.
ref
(
)
>
=
firstRemovedIndex
.
ref
(
)
&
&
aTrackData
.
mNextGetSampleIndex
.
ref
(
)
<
=
lastRemovedIndex
)
{
MSE_DEBUG
(
"
Next
sample
to
be
played
got
evicted
"
)
;
aTrackData
.
mNextGetSampleIndex
.
reset
(
)
;
}
else
if
(
aTrackData
.
mNextGetSampleIndex
.
ref
(
)
>
lastRemovedIndex
)
{
aTrackData
.
mNextGetSampleIndex
.
ref
(
)
-
=
lastRemovedIndex
-
firstRemovedIndex
.
ref
(
)
+
1
;
}
}
if
(
aTrackData
.
mNextInsertionIndex
.
isSome
(
)
)
{
if
(
aTrackData
.
mNextInsertionIndex
.
ref
(
)
>
firstRemovedIndex
.
ref
(
)
&
&
aTrackData
.
mNextInsertionIndex
.
ref
(
)
<
=
lastRemovedIndex
+
1
)
{
aTrackData
.
ResetAppendState
(
)
;
MSE_DEBUG
(
"
NextInsertionIndex
got
reset
.
"
)
;
}
else
if
(
aTrackData
.
mNextInsertionIndex
.
ref
(
)
>
lastRemovedIndex
+
1
)
{
aTrackData
.
mNextInsertionIndex
.
ref
(
)
-
=
lastRemovedIndex
-
firstRemovedIndex
.
ref
(
)
+
1
;
}
}
aTrackData
.
mBufferedRanges
-
=
removedIntervals
;
aTrackData
.
mSanitizedBufferedRanges
=
aTrackData
.
mBufferedRanges
;
aTrackData
.
mSanitizedBufferedRanges
.
SetFuzz
(
TimeUnit
:
:
FromMicroseconds
(
maxSampleDuration
/
2
)
)
;
data
.
RemoveElementsAt
(
firstRemovedIndex
.
ref
(
)
lastRemovedIndex
-
firstRemovedIndex
.
ref
(
)
+
1
)
;
}
void
TrackBuffersManager
:
:
RecreateParser
(
bool
aReuseInitData
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mParser
=
ContainerParser
:
:
CreateForMIMEType
(
mType
)
;
if
(
aReuseInitData
&
&
mInitData
)
{
int64_t
start
end
;
mParser
-
>
ParseStartAndEndTimestamps
(
mInitData
start
end
)
;
mProcessedInput
=
mInitData
-
>
Length
(
)
;
}
else
{
mProcessedInput
=
0
;
}
}
nsTArray
<
TrackBuffersManager
:
:
TrackData
*
>
TrackBuffersManager
:
:
GetTracksList
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
nsTArray
<
TrackData
*
>
tracks
;
if
(
HasVideo
(
)
)
{
tracks
.
AppendElement
(
&
mVideoTracks
)
;
}
if
(
HasAudio
(
)
)
{
tracks
.
AppendElement
(
&
mAudioTracks
)
;
}
return
tracks
;
}
void
TrackBuffersManager
:
:
RestoreCachedVariables
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mTimestampOffset
!
=
mLastTimestampOffset
)
{
mSourceBufferAttributes
-
>
SetTimestampOffset
(
mTimestampOffset
)
;
}
}
void
TrackBuffersManager
:
:
SetAppendState
(
TrackBuffersManager
:
:
AppendState
aAppendState
)
{
MSE_DEBUG
(
"
AppendState
changed
from
%
s
to
%
s
"
AppendStateToStr
(
mAppendState
)
AppendStateToStr
(
aAppendState
)
)
;
mAppendState
=
aAppendState
;
}
void
TrackBuffersManager
:
:
SetGroupStartTimestamp
(
const
TimeUnit
&
aGroupStartTimestamp
)
{
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableMethodWithArg
<
TimeUnit
>
(
this
&
TrackBuffersManager
:
:
SetGroupStartTimestamp
aGroupStartTimestamp
)
;
GetTaskQueue
(
)
-
>
Dispatch
(
task
.
forget
(
)
)
;
return
;
}
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mGroupStartTimestamp
=
Some
(
aGroupStartTimestamp
)
;
}
void
TrackBuffersManager
:
:
RestartGroupStartTimestamp
(
)
{
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableMethod
(
this
&
TrackBuffersManager
:
:
RestartGroupStartTimestamp
)
;
GetTaskQueue
(
)
-
>
Dispatch
(
task
.
forget
(
)
)
;
return
;
}
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mGroupStartTimestamp
=
Some
(
mGroupEndTimestamp
)
;
}
TimeUnit
TrackBuffersManager
:
:
GroupEndTimestamp
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
return
mOfficialGroupEndTimestamp
;
}
MediaInfo
TrackBuffersManager
:
:
GetMetadata
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
return
mInfo
;
}
const
TimeIntervals
&
TrackBuffersManager
:
:
Buffered
(
TrackInfo
:
:
TrackType
aTrack
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
GetTracksData
(
aTrack
)
.
mBufferedRanges
;
}
TimeIntervals
TrackBuffersManager
:
:
SafeBuffered
(
TrackInfo
:
:
TrackType
aTrack
)
const
{
MonitorAutoLock
mon
(
mMonitor
)
;
return
aTrack
=
=
TrackInfo
:
:
kVideoTrack
?
mVideoBufferedRanges
:
mAudioBufferedRanges
;
}
const
TrackBuffersManager
:
:
TrackBuffer
&
TrackBuffersManager
:
:
GetTrackBuffer
(
TrackInfo
:
:
TrackType
aTrack
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
GetTracksData
(
aTrack
)
.
mBuffers
.
LastElement
(
)
;
}
uint32_t
TrackBuffersManager
:
:
FindSampleIndex
(
const
TrackBuffer
&
aTrackBuffer
const
TimeInterval
&
aInterval
)
{
TimeUnit
target
=
aInterval
.
mStart
-
aInterval
.
mFuzz
;
for
(
uint32_t
i
=
0
;
i
<
aTrackBuffer
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
aTrackBuffer
[
i
]
;
if
(
sample
-
>
mTime
>
=
target
.
ToMicroseconds
(
)
|
|
sample
-
>
GetEndTime
(
)
>
target
.
ToMicroseconds
(
)
)
{
return
i
;
}
}
NS_ASSERTION
(
false
"
FindSampleIndex
called
with
invalid
arguments
"
)
;
return
0
;
}
TimeUnit
TrackBuffersManager
:
:
Seek
(
TrackInfo
:
:
TrackType
aTrack
const
TimeUnit
&
aTime
const
TimeUnit
&
aFuzz
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
auto
&
trackBuffer
=
GetTracksData
(
aTrack
)
;
const
TrackBuffersManager
:
:
TrackBuffer
&
track
=
GetTrackBuffer
(
aTrack
)
;
if
(
!
track
.
Length
(
)
)
{
trackBuffer
.
mNextGetSampleIndex
=
Some
(
uint32_t
(
0
)
)
;
trackBuffer
.
mNextSampleTimecode
=
TimeUnit
(
)
;
trackBuffer
.
mNextSampleTime
=
TimeUnit
(
)
;
return
TimeUnit
(
)
;
}
uint32_t
i
=
0
;
if
(
aTime
!
=
TimeUnit
(
)
)
{
TimeIntervals
buffered
=
trackBuffer
.
mBufferedRanges
;
TimeIntervals
:
:
IndexType
index
=
buffered
.
Find
(
aTime
)
;
buffered
.
SetFuzz
(
aFuzz
)
;
index
=
buffered
.
Find
(
aTime
)
;
MOZ_ASSERT
(
index
!
=
TimeIntervals
:
:
NoIndex
)
;
TimeInterval
target
=
buffered
[
index
]
;
i
=
FindSampleIndex
(
track
target
)
;
}
Maybe
<
TimeUnit
>
lastKeyFrameTime
;
TimeUnit
lastKeyFrameTimecode
;
uint32_t
lastKeyFrameIndex
=
0
;
for
(
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
track
[
i
]
;
TimeUnit
sampleTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
;
if
(
sampleTime
>
aTime
&
&
lastKeyFrameTime
.
isSome
(
)
)
{
break
;
}
if
(
sample
-
>
mKeyframe
)
{
lastKeyFrameTimecode
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
)
;
lastKeyFrameTime
=
Some
(
sampleTime
)
;
lastKeyFrameIndex
=
i
;
}
if
(
sampleTime
=
=
aTime
|
|
(
sampleTime
>
aTime
&
&
lastKeyFrameTime
.
isSome
(
)
)
)
{
break
;
}
}
MSE_DEBUG
(
"
Keyframe
%
s
found
at
%
lld
"
lastKeyFrameTime
.
isSome
(
)
?
"
"
:
"
not
"
lastKeyFrameTime
.
refOr
(
TimeUnit
(
)
)
.
ToMicroseconds
(
)
)
;
trackBuffer
.
mNextGetSampleIndex
=
Some
(
lastKeyFrameIndex
)
;
trackBuffer
.
mNextSampleTimecode
=
lastKeyFrameTimecode
;
trackBuffer
.
mNextSampleTime
=
lastKeyFrameTime
.
refOr
(
TimeUnit
(
)
)
;
return
lastKeyFrameTime
.
refOr
(
TimeUnit
(
)
)
;
}
uint32_t
TrackBuffersManager
:
:
SkipToNextRandomAccessPoint
(
TrackInfo
:
:
TrackType
aTrack
const
TimeUnit
&
aTimeThreadshold
bool
&
aFound
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
uint32_t
parsed
=
0
;
auto
&
trackData
=
GetTracksData
(
aTrack
)
;
const
TrackBuffer
&
track
=
GetTrackBuffer
(
aTrack
)
;
uint32_t
nextSampleIndex
=
trackData
.
mNextGetSampleIndex
.
valueOr
(
0
)
;
for
(
uint32_t
i
=
nextSampleIndex
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
track
[
i
]
;
if
(
sample
-
>
mKeyframe
&
&
sample
-
>
mTime
>
=
aTimeThreadshold
.
ToMicroseconds
(
)
)
{
trackData
.
mNextSampleTimecode
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
)
;
trackData
.
mNextSampleTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
;
trackData
.
mNextGetSampleIndex
=
Some
(
i
)
;
aFound
=
true
;
break
;
}
parsed
+
+
;
}
return
parsed
;
}
already_AddRefed
<
MediaRawData
>
TrackBuffersManager
:
:
GetSample
(
TrackInfo
:
:
TrackType
aTrack
const
TimeUnit
&
aFuzz
bool
&
aError
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
auto
&
trackData
=
GetTracksData
(
aTrack
)
;
const
TrackBuffer
&
track
=
GetTrackBuffer
(
aTrack
)
;
aError
=
false
;
if
(
!
track
.
Length
(
)
|
|
(
trackData
.
mNextGetSampleIndex
.
isSome
(
)
&
&
trackData
.
mNextGetSampleIndex
.
ref
(
)
>
=
track
.
Length
(
)
)
)
{
return
nullptr
;
}
if
(
trackData
.
mNextGetSampleIndex
.
isNothing
(
)
&
&
trackData
.
mNextSampleTimecode
=
=
TimeUnit
(
)
)
{
trackData
.
mNextGetSampleIndex
=
Some
(
0u
)
;
}
if
(
trackData
.
mNextGetSampleIndex
.
isSome
(
)
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
track
[
trackData
.
mNextGetSampleIndex
.
ref
(
)
]
;
if
(
trackData
.
mNextGetSampleIndex
.
ref
(
)
&
&
sample
-
>
mTimecode
>
(
trackData
.
mNextSampleTimecode
+
aFuzz
)
.
ToMicroseconds
(
)
)
{
return
nullptr
;
}
RefPtr
<
MediaRawData
>
p
=
sample
-
>
Clone
(
)
;
if
(
!
p
)
{
aError
=
true
;
return
nullptr
;
}
trackData
.
mNextGetSampleIndex
.
ref
(
)
+
+
;
trackData
.
mNextSampleTimecode
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
+
sample
-
>
mDuration
)
;
trackData
.
mNextSampleTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
;
return
p
.
forget
(
)
;
}
for
(
uint32_t
i
=
0
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
track
[
i
]
;
TimeInterval
sampleInterval
{
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
)
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
+
sample
-
>
mDuration
)
aFuzz
}
;
if
(
sampleInterval
.
ContainsWithStrictEnd
(
trackData
.
mNextSampleTimecode
)
)
{
RefPtr
<
MediaRawData
>
p
=
sample
-
>
Clone
(
)
;
if
(
!
p
)
{
aError
=
true
;
return
nullptr
;
}
trackData
.
mNextGetSampleIndex
=
Some
(
i
+
1
)
;
trackData
.
mNextSampleTimecode
=
sampleInterval
.
mEnd
;
trackData
.
mNextSampleTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
;
return
p
.
forget
(
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
track
[
i
]
;
TimeInterval
sampleInterval
{
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
aFuzz
}
;
if
(
sampleInterval
.
ContainsWithStrictEnd
(
trackData
.
mNextSampleTimecode
)
)
{
RefPtr
<
MediaRawData
>
p
=
sample
-
>
Clone
(
)
;
if
(
!
p
)
{
aError
=
true
;
return
nullptr
;
}
trackData
.
mNextGetSampleIndex
=
Some
(
i
+
1
)
;
trackData
.
mNextSampleTimecode
=
sampleInterval
.
mEnd
;
trackData
.
mNextSampleTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
;
return
p
.
forget
(
)
;
}
}
MSE_DEBUG
(
"
Couldn
'
t
find
sample
(
pts
:
%
lld
dts
:
%
lld
)
"
trackData
.
mNextSampleTime
.
ToMicroseconds
(
)
trackData
.
mNextSampleTimecode
.
ToMicroseconds
(
)
)
;
return
nullptr
;
}
TimeUnit
TrackBuffersManager
:
:
GetNextRandomAccessPoint
(
TrackInfo
:
:
TrackType
aTrack
)
{
auto
&
trackData
=
GetTracksData
(
aTrack
)
;
MOZ_ASSERT
(
trackData
.
mNextGetSampleIndex
.
isSome
(
)
)
;
const
TrackBuffersManager
:
:
TrackBuffer
&
track
=
GetTrackBuffer
(
aTrack
)
;
uint32_t
i
=
trackData
.
mNextGetSampleIndex
.
ref
(
)
;
for
(
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
track
[
i
]
;
if
(
sample
-
>
mKeyframe
)
{
return
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
;
}
}
return
media
:
:
TimeUnit
:
:
FromInfinity
(
)
;
}
void
TrackBuffersManager
:
:
TrackData
:
:
AddSizeOfResources
(
MediaSourceDecoder
:
:
ResourceSizes
*
aSizes
)
{
for
(
TrackBuffer
&
buffer
:
mBuffers
)
{
for
(
MediaRawData
*
data
:
buffer
)
{
aSizes
-
>
mByteSize
+
=
data
-
>
SizeOfIncludingThis
(
aSizes
-
>
mMallocSizeOf
)
;
}
}
}
void
TrackBuffersManager
:
:
AddSizeOfResources
(
MediaSourceDecoder
:
:
ResourceSizes
*
aSizes
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mVideoTracks
.
AddSizeOfResources
(
aSizes
)
;
mAudioTracks
.
AddSizeOfResources
(
aSizes
)
;
}
}
#
undef
MSE_DEBUG
#
undef
MSE_DEBUGV
#
undef
SAMPLE_DEBUG
