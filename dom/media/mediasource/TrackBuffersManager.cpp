#
include
"
TrackBuffersManager
.
h
"
#
include
"
ContainerParser
.
h
"
#
include
"
MediaSourceDemuxer
.
h
"
#
include
"
MediaSourceUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StateMirroring
.
h
"
#
include
"
SourceBufferResource
.
h
"
#
include
"
SourceBuffer
.
h
"
#
include
"
WebMDemuxer
.
h
"
#
include
"
SourceBufferTask
.
h
"
#
ifdef
MOZ_FMP4
#
include
"
MP4Demuxer
.
h
"
#
endif
#
include
<
limits
>
extern
mozilla
:
:
LogModule
*
GetMediaSourceLog
(
)
;
#
define
MSE_DEBUG
(
arg
.
.
.
)
MOZ_LOG
(
GetMediaSourceLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
TrackBuffersManager
(
%
p
:
%
s
)
:
:
%
s
:
"
arg
this
mType
.
get
(
)
__func__
#
#
__VA_ARGS__
)
)
#
define
MSE_DEBUGV
(
arg
.
.
.
)
MOZ_LOG
(
GetMediaSourceLog
(
)
mozilla
:
:
LogLevel
:
:
Verbose
(
"
TrackBuffersManager
(
%
p
:
%
s
)
:
:
%
s
:
"
arg
this
mType
.
get
(
)
__func__
#
#
__VA_ARGS__
)
)
mozilla
:
:
LogModule
*
GetMediaSourceSamplesLog
(
)
{
static
mozilla
:
:
LazyLogModule
sLogModule
(
"
MediaSourceSamples
"
)
;
return
sLogModule
;
}
#
define
SAMPLE_DEBUG
(
arg
.
.
.
)
MOZ_LOG
(
GetMediaSourceSamplesLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
TrackBuffersManager
(
%
p
:
%
s
)
:
:
%
s
:
"
arg
this
mType
.
get
(
)
__func__
#
#
__VA_ARGS__
)
)
namespace
mozilla
{
using
dom
:
:
SourceBufferAppendMode
;
using
media
:
:
TimeUnit
;
using
media
:
:
TimeInterval
;
using
media
:
:
TimeIntervals
;
typedef
SourceBufferTask
:
:
AppendBufferResult
AppendBufferResult
;
static
const
char
*
AppendStateToStr
(
SourceBufferAttributes
:
:
AppendState
aState
)
{
switch
(
aState
)
{
case
SourceBufferAttributes
:
:
AppendState
:
:
WAITING_FOR_SEGMENT
:
return
"
WAITING_FOR_SEGMENT
"
;
case
SourceBufferAttributes
:
:
AppendState
:
:
PARSING_INIT_SEGMENT
:
return
"
PARSING_INIT_SEGMENT
"
;
case
SourceBufferAttributes
:
:
AppendState
:
:
PARSING_MEDIA_SEGMENT
:
return
"
PARSING_MEDIA_SEGMENT
"
;
default
:
return
"
IMPOSSIBLE
"
;
}
}
static
Atomic
<
uint32_t
>
sStreamSourceID
(
0u
)
;
#
ifdef
MOZ_EME
class
DispatchKeyNeededEvent
:
public
Runnable
{
public
:
DispatchKeyNeededEvent
(
AbstractMediaDecoder
*
aDecoder
nsTArray
<
uint8_t
>
&
aInitData
const
nsString
&
aInitDataType
)
:
mDecoder
(
aDecoder
)
mInitData
(
aInitData
)
mInitDataType
(
aInitDataType
)
{
}
NS_IMETHOD
Run
(
)
override
{
MediaDecoderOwner
*
owner
=
mDecoder
-
>
GetOwner
(
)
;
if
(
owner
)
{
owner
-
>
DispatchEncrypted
(
mInitData
mInitDataType
)
;
}
mDecoder
=
nullptr
;
return
NS_OK
;
}
private
:
RefPtr
<
AbstractMediaDecoder
>
mDecoder
;
nsTArray
<
uint8_t
>
mInitData
;
nsString
mInitDataType
;
}
;
#
endif
TrackBuffersManager
:
:
TrackBuffersManager
(
MediaSourceDecoder
*
aParentDecoder
const
nsACString
&
aType
)
:
mInputBuffer
(
new
MediaByteBuffer
)
mBufferFull
(
false
)
mFirstInitializationSegmentReceived
(
false
)
mNewMediaSegmentStarted
(
false
)
mActiveTrack
(
false
)
mType
(
aType
)
mParser
(
ContainerParser
:
:
CreateForMIMEType
(
aType
)
)
mProcessedInput
(
0
)
mTaskQueue
(
aParentDecoder
-
>
GetDemuxer
(
)
-
>
GetTaskQueue
(
)
)
mParentDecoder
(
new
nsMainThreadPtrHolder
<
MediaSourceDecoder
>
(
aParentDecoder
false
)
)
mEnded
(
false
)
mVideoEvictionThreshold
(
Preferences
:
:
GetUint
(
"
media
.
mediasource
.
eviction_threshold
.
video
"
100
*
1024
*
1024
)
)
mAudioEvictionThreshold
(
Preferences
:
:
GetUint
(
"
media
.
mediasource
.
eviction_threshold
.
audio
"
10
*
1024
*
1024
)
)
mEvictionState
(
EvictionState
:
:
NO_EVICTION_NEEDED
)
mMonitor
(
"
TrackBuffersManager
"
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
instanciated
on
the
main
thread
"
)
;
}
TrackBuffersManager
:
:
~
TrackBuffersManager
(
)
{
ShutdownDemuxers
(
)
;
}
RefPtr
<
TrackBuffersManager
:
:
AppendPromise
>
TrackBuffersManager
:
:
AppendData
(
MediaByteBuffer
*
aData
const
SourceBufferAttributes
&
aAttributes
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_DEBUG
(
"
Appending
%
lld
bytes
"
aData
-
>
Length
(
)
)
;
mEnded
=
false
;
RefPtr
<
MediaByteBuffer
>
buffer
=
aData
;
return
InvokeAsync
(
GetTaskQueue
(
)
this
__func__
&
TrackBuffersManager
:
:
DoAppendData
buffer
aAttributes
)
;
}
RefPtr
<
TrackBuffersManager
:
:
AppendPromise
>
TrackBuffersManager
:
:
DoAppendData
(
RefPtr
<
MediaByteBuffer
>
aData
SourceBufferAttributes
aAttributes
)
{
RefPtr
<
AppendBufferTask
>
task
=
new
AppendBufferTask
(
aData
aAttributes
)
;
RefPtr
<
AppendPromise
>
p
=
task
-
>
mPromise
.
Ensure
(
__func__
)
;
QueueTask
(
task
)
;
return
p
;
}
void
TrackBuffersManager
:
:
QueueTask
(
SourceBufferTask
*
aTask
)
{
if
(
!
OnTaskQueue
(
)
)
{
GetTaskQueue
(
)
-
>
Dispatch
(
NewRunnableMethod
<
RefPtr
<
SourceBufferTask
>
>
(
this
&
TrackBuffersManager
:
:
QueueTask
aTask
)
)
;
return
;
}
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mQueue
.
Push
(
aTask
)
;
ProcessTasks
(
)
;
}
void
TrackBuffersManager
:
:
ProcessTasks
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
typedef
SourceBufferTask
:
:
Type
Type
;
if
(
mCurrentTask
)
{
return
;
}
RefPtr
<
SourceBufferTask
>
task
=
mQueue
.
Pop
(
)
;
if
(
!
task
)
{
return
;
}
switch
(
task
-
>
GetType
(
)
)
{
case
Type
:
:
AppendBuffer
:
mCurrentTask
=
task
;
if
(
!
mInputBuffer
)
{
mInputBuffer
=
task
-
>
As
<
AppendBufferTask
>
(
)
-
>
mBuffer
;
}
else
if
(
!
mInputBuffer
-
>
AppendElements
(
*
task
-
>
As
<
AppendBufferTask
>
(
)
-
>
mBuffer
fallible
)
)
{
RejectAppend
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
return
;
}
mSourceBufferAttributes
=
MakeUnique
<
SourceBufferAttributes
>
(
task
-
>
As
<
AppendBufferTask
>
(
)
-
>
mAttributes
)
;
mAppendWindow
=
TimeInterval
(
TimeUnit
:
:
FromSeconds
(
mSourceBufferAttributes
-
>
GetAppendWindowStart
(
)
)
TimeUnit
:
:
FromSeconds
(
mSourceBufferAttributes
-
>
GetAppendWindowEnd
(
)
)
)
;
ScheduleSegmentParserLoop
(
)
;
break
;
case
Type
:
:
RangeRemoval
:
{
bool
rv
=
CodedFrameRemoval
(
task
-
>
As
<
RangeRemovalTask
>
(
)
-
>
mRange
)
;
task
-
>
As
<
RangeRemovalTask
>
(
)
-
>
mPromise
.
Resolve
(
rv
__func__
)
;
break
;
}
case
Type
:
:
EvictData
:
DoEvictData
(
task
-
>
As
<
EvictDataTask
>
(
)
-
>
mPlaybackTime
task
-
>
As
<
EvictDataTask
>
(
)
-
>
mSizeToEvict
)
;
break
;
case
Type
:
:
Abort
:
break
;
case
Type
:
:
Reset
:
CompleteResetParserState
(
)
;
break
;
case
Type
:
:
Detach
:
mTaskQueue
=
nullptr
;
MOZ_DIAGNOSTIC_ASSERT
(
mQueue
.
Length
(
)
=
=
0
"
Detach
task
must
be
the
last
"
)
;
return
;
default
:
NS_WARNING
(
"
Invalid
Task
"
)
;
}
GetTaskQueue
(
)
-
>
Dispatch
(
NewRunnableMethod
(
this
&
TrackBuffersManager
:
:
ProcessTasks
)
)
;
}
void
TrackBuffersManager
:
:
AbortAppendData
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_DEBUG
(
"
"
)
;
QueueTask
(
new
AbortTask
(
)
)
;
}
void
TrackBuffersManager
:
:
ResetParserState
(
SourceBufferAttributes
&
aAttributes
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_DEBUG
(
"
"
)
;
QueueTask
(
new
ResetTask
(
)
)
;
if
(
aAttributes
.
GetAppendMode
(
)
=
=
SourceBufferAppendMode
:
:
Sequence
)
{
aAttributes
.
SetGroupStartTimestamp
(
aAttributes
.
GetGroupEndTimestamp
(
)
)
;
}
aAttributes
.
SetAppendState
(
AppendState
:
:
WAITING_FOR_SEGMENT
)
;
}
RefPtr
<
TrackBuffersManager
:
:
RangeRemovalPromise
>
TrackBuffersManager
:
:
RangeRemoval
(
TimeUnit
aStart
TimeUnit
aEnd
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_DEBUG
(
"
From
%
.
2f
to
%
.
2f
"
aStart
.
ToSeconds
(
)
aEnd
.
ToSeconds
(
)
)
;
mEnded
=
false
;
return
InvokeAsync
(
GetTaskQueue
(
)
this
__func__
&
TrackBuffersManager
:
:
CodedFrameRemovalWithPromise
TimeInterval
(
aStart
aEnd
)
)
;
}
TrackBuffersManager
:
:
EvictDataResult
TrackBuffersManager
:
:
EvictData
(
const
TimeUnit
&
aPlaybackTime
int64_t
aSize
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aSize
>
EvictionThreshold
(
)
)
{
return
EvictDataResult
:
:
BUFFER_FULL
;
}
const
int64_t
toEvict
=
GetSize
(
)
+
aSize
-
EvictionThreshold
(
)
;
const
uint32_t
canEvict
=
Evictable
(
HasVideo
(
)
?
TrackInfo
:
:
kVideoTrack
:
TrackInfo
:
:
kAudioTrack
)
;
MSE_DEBUG
(
"
buffered
=
%
lldkB
eviction
threshold
=
%
ukB
evict
=
%
lldkB
canevict
=
%
ukB
"
GetSize
(
)
/
1024
EvictionThreshold
(
)
/
1024
toEvict
/
1024
canEvict
/
1024
)
;
if
(
toEvict
<
=
0
)
{
mEvictionState
=
EvictionState
:
:
NO_EVICTION_NEEDED
;
return
EvictDataResult
:
:
NO_DATA_EVICTED
;
}
if
(
toEvict
<
=
512
*
1024
)
{
mEvictionState
=
EvictionState
:
:
NO_EVICTION_NEEDED
;
return
EvictDataResult
:
:
CANT_EVICT
;
}
EvictDataResult
result
;
if
(
mBufferFull
&
&
mEvictionState
=
=
EvictionState
:
:
EVICTION_COMPLETED
&
&
canEvict
<
uint32_t
(
toEvict
)
)
{
result
=
EvictDataResult
:
:
BUFFER_FULL
;
}
else
{
mEvictionState
=
EvictionState
:
:
EVICTION_NEEDED
;
result
=
EvictDataResult
:
:
NO_DATA_EVICTED
;
}
MSE_DEBUG
(
"
Reached
our
size
limit
schedule
eviction
of
%
lld
bytes
"
toEvict
)
;
QueueTask
(
new
EvictDataTask
(
aPlaybackTime
toEvict
)
)
;
return
result
;
}
TimeIntervals
TrackBuffersManager
:
:
Buffered
(
)
{
MSE_DEBUG
(
"
"
)
;
TimeUnit
highestEndTime
=
HighestEndTime
(
)
;
MonitorAutoLock
mon
(
mMonitor
)
;
nsTArray
<
TimeIntervals
*
>
tracks
;
if
(
HasVideo
(
)
)
{
tracks
.
AppendElement
(
&
mVideoBufferedRanges
)
;
}
if
(
HasAudio
(
)
)
{
tracks
.
AppendElement
(
&
mAudioBufferedRanges
)
;
}
TimeIntervals
intersection
{
TimeInterval
(
TimeUnit
:
:
FromSeconds
(
0
)
highestEndTime
)
}
;
for
(
auto
trackRanges
:
tracks
)
{
if
(
mEnded
)
{
trackRanges
-
>
Add
(
TimeInterval
(
trackRanges
-
>
GetEnd
(
)
highestEndTime
)
)
;
}
intersection
.
Intersection
(
*
trackRanges
)
;
}
return
intersection
;
}
int64_t
TrackBuffersManager
:
:
GetSize
(
)
const
{
return
mSizeSourceBuffer
;
}
void
TrackBuffersManager
:
:
Ended
(
)
{
mEnded
=
true
;
}
void
TrackBuffersManager
:
:
Detach
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MSE_DEBUG
(
"
"
)
;
QueueTask
(
new
DetachTask
(
)
)
;
}
void
TrackBuffersManager
:
:
CompleteResetParserState
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MSE_DEBUG
(
"
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mDemuxerInitRequest
.
Exists
(
)
"
Previous
AppendBuffer
didn
'
t
complete
"
)
;
for
(
auto
&
track
:
GetTracksList
(
)
)
{
track
-
>
ResetAppendState
(
)
;
track
-
>
mQueuedSamples
.
Clear
(
)
;
}
mInputBuffer
=
nullptr
;
if
(
mCurrentInputBuffer
)
{
mCurrentInputBuffer
-
>
EvictAll
(
)
;
mCurrentInputBuffer
=
new
SourceBufferResource
(
mType
)
;
}
if
(
mFirstInitializationSegmentReceived
)
{
MOZ_ASSERT
(
mInitData
&
&
mInitData
-
>
Length
(
)
"
we
must
have
an
init
segment
"
)
;
CreateDemuxerforMIMEType
(
)
;
mInputBuffer
=
new
MediaByteBuffer
;
mInputBuffer
-
>
AppendElements
(
*
mInitData
)
;
}
RecreateParser
(
true
)
;
}
int64_t
TrackBuffersManager
:
:
EvictionThreshold
(
)
const
{
if
(
HasVideo
(
)
)
{
return
mVideoEvictionThreshold
;
}
return
mAudioEvictionThreshold
;
}
void
TrackBuffersManager
:
:
DoEvictData
(
const
TimeUnit
&
aPlaybackTime
int64_t
aSizeToEvict
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mEvictionState
=
EvictionState
:
:
EVICTION_COMPLETED
;
auto
&
track
=
HasVideo
(
)
?
mVideoTracks
:
mAudioTracks
;
const
auto
&
buffer
=
track
.
mBuffers
.
LastElement
(
)
;
TimeUnit
lowerLimit
=
std
:
:
min
(
track
.
mNextSampleTime
aPlaybackTime
)
;
uint32_t
lastKeyFrameIndex
=
0
;
int64_t
toEvict
=
aSizeToEvict
;
int64_t
partialEvict
=
0
;
for
(
uint32_t
i
=
0
;
i
<
buffer
.
Length
(
)
;
i
+
+
)
{
const
auto
&
frame
=
buffer
[
i
]
;
if
(
frame
-
>
mKeyframe
)
{
lastKeyFrameIndex
=
i
;
toEvict
-
=
partialEvict
;
if
(
toEvict
<
0
)
{
break
;
}
partialEvict
=
0
;
}
if
(
frame
-
>
mTime
>
=
lowerLimit
.
ToMicroseconds
(
)
)
{
break
;
}
partialEvict
+
=
frame
-
>
ComputedSizeOfIncludingThis
(
)
;
}
const
int64_t
finalSize
=
mSizeSourceBuffer
-
aSizeToEvict
;
if
(
lastKeyFrameIndex
>
0
)
{
MSE_DEBUG
(
"
Step1
.
Evicting
%
lld
bytes
prior
currentTime
"
aSizeToEvict
-
toEvict
)
;
CodedFrameRemoval
(
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
0
)
TimeUnit
:
:
FromMicroseconds
(
buffer
[
lastKeyFrameIndex
]
-
>
mTime
-
1
)
)
)
;
}
if
(
mSizeSourceBuffer
<
=
finalSize
)
{
return
;
}
toEvict
=
mSizeSourceBuffer
-
finalSize
;
TimeUnit
currentPosition
=
std
:
:
max
(
aPlaybackTime
track
.
mNextSampleTime
)
;
TimeIntervals
futureBuffered
(
TimeInterval
(
currentPosition
TimeUnit
:
:
FromInfinity
(
)
)
)
;
futureBuffered
.
Intersection
(
track
.
mBufferedRanges
)
;
futureBuffered
.
SetFuzz
(
MediaSourceDemuxer
:
:
EOS_FUZZ
/
2
)
;
if
(
futureBuffered
.
Length
(
)
<
=
1
)
{
return
;
}
TimeUnit
upperLimit
=
futureBuffered
[
0
]
.
mEnd
;
uint32_t
evictedFramesStartIndex
=
buffer
.
Length
(
)
;
for
(
int32_t
i
=
buffer
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
const
auto
&
frame
=
buffer
[
i
]
;
if
(
frame
-
>
mTime
<
=
upperLimit
.
ToMicroseconds
(
)
|
|
toEvict
<
0
)
{
evictedFramesStartIndex
=
i
+
1
;
break
;
}
toEvict
-
=
frame
-
>
ComputedSizeOfIncludingThis
(
)
;
}
if
(
evictedFramesStartIndex
<
buffer
.
Length
(
)
)
{
MSE_DEBUG
(
"
Step2
.
Evicting
%
lld
bytes
from
trailing
data
"
mSizeSourceBuffer
-
finalSize
-
toEvict
)
;
CodedFrameRemoval
(
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
buffer
[
evictedFramesStartIndex
]
-
>
mTime
)
TimeUnit
:
:
FromInfinity
(
)
)
)
;
}
}
RefPtr
<
TrackBuffersManager
:
:
RangeRemovalPromise
>
TrackBuffersManager
:
:
CodedFrameRemovalWithPromise
(
TimeInterval
aInterval
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
RefPtr
<
RangeRemovalTask
>
task
=
new
RangeRemovalTask
(
aInterval
)
;
RefPtr
<
RangeRemovalPromise
>
p
=
task
-
>
mPromise
.
Ensure
(
__func__
)
;
QueueTask
(
task
)
;
return
p
;
}
bool
TrackBuffersManager
:
:
CodedFrameRemoval
(
TimeInterval
aInterval
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MSE_DEBUG
(
"
From
%
.
2fs
to
%
.
2f
"
aInterval
.
mStart
.
ToSeconds
(
)
aInterval
.
mEnd
.
ToSeconds
(
)
)
;
#
if
DEBUG
if
(
HasVideo
(
)
)
{
MSE_DEBUG
(
"
before
video
ranges
=
%
s
"
DumpTimeRanges
(
mVideoTracks
.
mBufferedRanges
)
.
get
(
)
)
;
}
if
(
HasAudio
(
)
)
{
MSE_DEBUG
(
"
before
audio
ranges
=
%
s
"
DumpTimeRanges
(
mAudioTracks
.
mBufferedRanges
)
.
get
(
)
)
;
}
#
endif
TimeUnit
start
=
aInterval
.
mStart
;
TimeUnit
end
=
aInterval
.
mEnd
;
bool
dataRemoved
=
false
;
for
(
auto
track
:
GetTracksList
(
)
)
{
MSE_DEBUGV
(
"
Processing
%
s
track
"
track
-
>
mInfo
-
>
mMimeType
.
get
(
)
)
;
TimeUnit
removeEndTimestamp
=
track
-
>
mBufferedRanges
.
GetEnd
(
)
;
if
(
start
>
removeEndTimestamp
)
{
continue
;
}
if
(
end
<
track
-
>
mBufferedRanges
.
GetEnd
(
)
)
{
for
(
auto
&
frame
:
track
-
>
mBuffers
.
LastElement
(
)
)
{
if
(
frame
-
>
mKeyframe
&
&
frame
-
>
mTime
>
=
end
.
ToMicroseconds
(
)
)
{
removeEndTimestamp
=
TimeUnit
:
:
FromMicroseconds
(
frame
-
>
mTime
)
;
break
;
}
}
}
TimeIntervals
removedInterval
{
TimeInterval
(
start
removeEndTimestamp
)
}
;
RemoveFrames
(
removedInterval
*
track
0
)
;
}
UpdateBufferedRanges
(
)
;
mSizeSourceBuffer
=
mVideoTracks
.
mSizeBuffer
+
mAudioTracks
.
mSizeBuffer
;
if
(
mBufferFull
&
&
mSizeSourceBuffer
<
EvictionThreshold
(
)
)
{
mBufferFull
=
false
;
}
return
dataRemoved
;
}
void
TrackBuffersManager
:
:
UpdateBufferedRanges
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
mVideoBufferedRanges
=
mVideoTracks
.
mSanitizedBufferedRanges
;
mAudioBufferedRanges
=
mAudioTracks
.
mSanitizedBufferedRanges
;
#
if
DEBUG
if
(
HasVideo
(
)
)
{
MSE_DEBUG
(
"
after
video
ranges
=
%
s
"
DumpTimeRanges
(
mVideoTracks
.
mBufferedRanges
)
.
get
(
)
)
;
}
if
(
HasAudio
(
)
)
{
MSE_DEBUG
(
"
after
audio
ranges
=
%
s
"
DumpTimeRanges
(
mAudioTracks
.
mBufferedRanges
)
.
get
(
)
)
;
}
#
endif
}
void
TrackBuffersManager
:
:
SegmentParserLoop
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
while
(
true
)
{
if
(
!
mInputBuffer
|
|
mInputBuffer
-
>
IsEmpty
(
)
)
{
NeedMoreData
(
)
;
return
;
}
if
(
mSourceBufferAttributes
-
>
GetAppendState
(
)
=
=
AppendState
:
:
WAITING_FOR_SEGMENT
)
{
if
(
mParser
-
>
IsInitSegmentPresent
(
mInputBuffer
)
)
{
SetAppendState
(
AppendState
:
:
PARSING_INIT_SEGMENT
)
;
if
(
mFirstInitializationSegmentReceived
)
{
RecreateParser
(
false
)
;
}
continue
;
}
if
(
mParser
-
>
IsMediaSegmentPresent
(
mInputBuffer
)
)
{
SetAppendState
(
AppendState
:
:
PARSING_MEDIA_SEGMENT
)
;
mNewMediaSegmentStarted
=
true
;
continue
;
}
MSE_DEBUG
(
"
Found
invalid
or
incomplete
data
.
"
)
;
NeedMoreData
(
)
;
return
;
}
int64_t
start
end
;
bool
newData
=
mParser
-
>
ParseStartAndEndTimestamps
(
mInputBuffer
start
end
)
;
mProcessedInput
+
=
mInputBuffer
-
>
Length
(
)
;
if
(
mSourceBufferAttributes
-
>
GetAppendState
(
)
=
=
AppendState
:
:
PARSING_INIT_SEGMENT
)
{
if
(
mParser
-
>
InitSegmentRange
(
)
.
IsEmpty
(
)
)
{
mInputBuffer
=
nullptr
;
NeedMoreData
(
)
;
return
;
}
InitializationSegmentReceived
(
)
;
return
;
}
if
(
mSourceBufferAttributes
-
>
GetAppendState
(
)
=
=
AppendState
:
:
PARSING_MEDIA_SEGMENT
)
{
if
(
!
mFirstInitializationSegmentReceived
)
{
RejectAppend
(
NS_ERROR_FAILURE
__func__
)
;
return
;
}
if
(
mNewMediaSegmentStarted
)
{
if
(
newData
&
&
mLastParsedEndTime
.
isSome
(
)
&
&
start
<
mLastParsedEndTime
.
ref
(
)
.
ToMicroseconds
(
)
)
{
MSE_DEBUG
(
"
Re
-
creating
demuxer
"
)
;
ResetDemuxingState
(
)
;
return
;
}
if
(
newData
|
|
!
mParser
-
>
MediaSegmentRange
(
)
.
IsEmpty
(
)
)
{
if
(
mPendingInputBuffer
)
{
AppendDataToCurrentInputBuffer
(
mPendingInputBuffer
)
;
mPendingInputBuffer
=
nullptr
;
}
mNewMediaSegmentStarted
=
false
;
}
else
{
if
(
!
mPendingInputBuffer
)
{
mPendingInputBuffer
=
mInputBuffer
;
}
else
{
mPendingInputBuffer
-
>
AppendElements
(
*
mInputBuffer
)
;
}
mInputBuffer
=
nullptr
;
NeedMoreData
(
)
;
return
;
}
}
RefPtr
<
TrackBuffersManager
>
self
=
this
;
mProcessingRequest
.
Begin
(
CodedFrameProcessing
(
)
-
>
Then
(
GetTaskQueue
(
)
__func__
[
self
]
(
bool
aNeedMoreData
)
{
self
-
>
mProcessingRequest
.
Complete
(
)
;
if
(
aNeedMoreData
)
{
self
-
>
NeedMoreData
(
)
;
}
else
{
self
-
>
ScheduleSegmentParserLoop
(
)
;
}
}
[
self
]
(
const
MediaResult
&
aRejectValue
)
{
self
-
>
mProcessingRequest
.
Complete
(
)
;
self
-
>
RejectAppend
(
aRejectValue
__func__
)
;
}
)
)
;
return
;
}
}
}
void
TrackBuffersManager
:
:
NeedMoreData
(
)
{
MSE_DEBUG
(
"
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mCurrentTask
&
&
mCurrentTask
-
>
GetType
(
)
=
=
SourceBufferTask
:
:
Type
:
:
AppendBuffer
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mSourceBufferAttributes
)
;
mCurrentTask
-
>
As
<
AppendBufferTask
>
(
)
-
>
mPromise
.
Resolve
(
SourceBufferTask
:
:
AppendBufferResult
(
mActiveTrack
*
mSourceBufferAttributes
)
__func__
)
;
mSourceBufferAttributes
=
nullptr
;
mCurrentTask
=
nullptr
;
ProcessTasks
(
)
;
}
void
TrackBuffersManager
:
:
RejectAppend
(
const
MediaResult
&
aRejectValue
const
char
*
aName
)
{
MSE_DEBUG
(
"
rv
=
%
u
"
aRejectValue
.
Code
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mCurrentTask
&
&
mCurrentTask
-
>
GetType
(
)
=
=
SourceBufferTask
:
:
Type
:
:
AppendBuffer
)
;
mCurrentTask
-
>
As
<
AppendBufferTask
>
(
)
-
>
mPromise
.
Reject
(
aRejectValue
__func__
)
;
mSourceBufferAttributes
=
nullptr
;
mCurrentTask
=
nullptr
;
ProcessTasks
(
)
;
}
void
TrackBuffersManager
:
:
ScheduleSegmentParserLoop
(
)
{
GetTaskQueue
(
)
-
>
Dispatch
(
NewRunnableMethod
(
this
&
TrackBuffersManager
:
:
SegmentParserLoop
)
)
;
}
void
TrackBuffersManager
:
:
ShutdownDemuxers
(
)
{
if
(
mVideoTracks
.
mDemuxer
)
{
mVideoTracks
.
mDemuxer
-
>
BreakCycles
(
)
;
mVideoTracks
.
mDemuxer
=
nullptr
;
}
if
(
mAudioTracks
.
mDemuxer
)
{
mAudioTracks
.
mDemuxer
-
>
BreakCycles
(
)
;
mAudioTracks
.
mDemuxer
=
nullptr
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
mDemuxerInitRequest
.
Exists
(
)
)
;
mInputDemuxer
=
nullptr
;
mLastParsedEndTime
.
reset
(
)
;
}
void
TrackBuffersManager
:
:
CreateDemuxerforMIMEType
(
)
{
ShutdownDemuxers
(
)
;
if
(
mType
.
LowerCaseEqualsLiteral
(
"
video
/
webm
"
)
|
|
mType
.
LowerCaseEqualsLiteral
(
"
audio
/
webm
"
)
)
{
mInputDemuxer
=
new
WebMDemuxer
(
mCurrentInputBuffer
true
)
;
return
;
}
#
ifdef
MOZ_FMP4
if
(
mType
.
LowerCaseEqualsLiteral
(
"
video
/
mp4
"
)
|
|
mType
.
LowerCaseEqualsLiteral
(
"
audio
/
mp4
"
)
)
{
mInputDemuxer
=
new
MP4Demuxer
(
mCurrentInputBuffer
)
;
return
;
}
#
endif
NS_WARNING
(
"
Not
supported
(
yet
)
"
)
;
return
;
}
void
TrackBuffersManager
:
:
ResetDemuxingState
(
)
{
MOZ_ASSERT
(
mParser
&
&
mParser
-
>
HasInitData
(
)
)
;
RecreateParser
(
true
)
;
mCurrentInputBuffer
=
new
SourceBufferResource
(
mType
)
;
mCurrentInputBuffer
-
>
AppendData
(
mParser
-
>
InitData
(
)
)
;
CreateDemuxerforMIMEType
(
)
;
if
(
!
mInputDemuxer
)
{
RejectAppend
(
NS_ERROR_FAILURE
__func__
)
;
return
;
}
mDemuxerInitRequest
.
Begin
(
mInputDemuxer
-
>
Init
(
)
-
>
Then
(
GetTaskQueue
(
)
__func__
this
&
TrackBuffersManager
:
:
OnDemuxerResetDone
&
TrackBuffersManager
:
:
OnDemuxerInitFailed
)
)
;
}
void
TrackBuffersManager
:
:
OnDemuxerResetDone
(
nsresult
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mDemuxerInitRequest
.
Complete
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInputDemuxer
)
;
uint32_t
numVideos
=
mInputDemuxer
-
>
GetNumberTracks
(
TrackInfo
:
:
kVideoTrack
)
;
if
(
numVideos
)
{
mVideoTracks
.
mDemuxer
=
mInputDemuxer
-
>
GetTrackDemuxer
(
TrackInfo
:
:
kVideoTrack
0
)
;
MOZ_ASSERT
(
mVideoTracks
.
mDemuxer
)
;
}
uint32_t
numAudios
=
mInputDemuxer
-
>
GetNumberTracks
(
TrackInfo
:
:
kAudioTrack
)
;
if
(
numAudios
)
{
mAudioTracks
.
mDemuxer
=
mInputDemuxer
-
>
GetTrackDemuxer
(
TrackInfo
:
:
kAudioTrack
0
)
;
MOZ_ASSERT
(
mAudioTracks
.
mDemuxer
)
;
}
if
(
mPendingInputBuffer
)
{
int64_t
start
end
;
mParser
-
>
ParseStartAndEndTimestamps
(
mPendingInputBuffer
start
end
)
;
mProcessedInput
+
=
mPendingInputBuffer
-
>
Length
(
)
;
}
SegmentParserLoop
(
)
;
}
void
TrackBuffersManager
:
:
AppendDataToCurrentInputBuffer
(
MediaByteBuffer
*
aData
)
{
MOZ_ASSERT
(
mCurrentInputBuffer
)
;
mCurrentInputBuffer
-
>
AppendData
(
aData
)
;
mInputDemuxer
-
>
NotifyDataArrived
(
)
;
}
void
TrackBuffersManager
:
:
InitializationSegmentReceived
(
)
{
MOZ_ASSERT
(
mParser
-
>
HasCompleteInitData
(
)
)
;
mCurrentInputBuffer
=
new
SourceBufferResource
(
mType
)
;
mCurrentInputBuffer
-
>
AppendData
(
mParser
-
>
InitData
(
)
)
;
uint32_t
length
=
mParser
-
>
InitSegmentRange
(
)
.
mEnd
-
(
mProcessedInput
-
mInputBuffer
-
>
Length
(
)
)
;
if
(
mInputBuffer
-
>
Length
(
)
=
=
length
)
{
mInputBuffer
=
nullptr
;
}
else
{
mInputBuffer
-
>
RemoveElementsAt
(
0
length
)
;
}
CreateDemuxerforMIMEType
(
)
;
if
(
!
mInputDemuxer
)
{
NS_WARNING
(
"
TODO
type
not
supported
"
)
;
RejectAppend
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
__func__
)
;
return
;
}
mDemuxerInitRequest
.
Begin
(
mInputDemuxer
-
>
Init
(
)
-
>
Then
(
GetTaskQueue
(
)
__func__
this
&
TrackBuffersManager
:
:
OnDemuxerInitDone
&
TrackBuffersManager
:
:
OnDemuxerInitFailed
)
)
;
}
void
TrackBuffersManager
:
:
OnDemuxerInitDone
(
nsresult
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInputDemuxer
"
mInputDemuxer
has
been
destroyed
"
)
;
mDemuxerInitRequest
.
Complete
(
)
;
MediaInfo
info
;
uint32_t
numVideos
=
mInputDemuxer
-
>
GetNumberTracks
(
TrackInfo
:
:
kVideoTrack
)
;
if
(
numVideos
)
{
mVideoTracks
.
mDemuxer
=
mInputDemuxer
-
>
GetTrackDemuxer
(
TrackInfo
:
:
kVideoTrack
0
)
;
MOZ_ASSERT
(
mVideoTracks
.
mDemuxer
)
;
info
.
mVideo
=
*
mVideoTracks
.
mDemuxer
-
>
GetInfo
(
)
-
>
GetAsVideoInfo
(
)
;
info
.
mVideo
.
mTrackId
=
2
;
}
uint32_t
numAudios
=
mInputDemuxer
-
>
GetNumberTracks
(
TrackInfo
:
:
kAudioTrack
)
;
if
(
numAudios
)
{
mAudioTracks
.
mDemuxer
=
mInputDemuxer
-
>
GetTrackDemuxer
(
TrackInfo
:
:
kAudioTrack
0
)
;
MOZ_ASSERT
(
mAudioTracks
.
mDemuxer
)
;
info
.
mAudio
=
*
mAudioTracks
.
mDemuxer
-
>
GetInfo
(
)
-
>
GetAsAudioInfo
(
)
;
info
.
mAudio
.
mTrackId
=
1
;
}
int64_t
videoDuration
=
numVideos
?
info
.
mVideo
.
mDuration
:
0
;
int64_t
audioDuration
=
numAudios
?
info
.
mAudio
.
mDuration
:
0
;
int64_t
duration
=
std
:
:
max
(
videoDuration
audioDuration
)
;
AbstractThread
:
:
MainThread
(
)
-
>
Dispatch
(
NewRunnableMethod
<
int64_t
>
(
mParentDecoder
&
MediaSourceDecoder
:
:
SetInitialDuration
duration
?
duration
:
-
1
)
)
;
if
(
!
numVideos
&
&
!
numAudios
)
{
RejectAppend
(
NS_ERROR_FAILURE
__func__
)
;
return
;
}
if
(
mFirstInitializationSegmentReceived
)
{
if
(
numVideos
!
=
mVideoTracks
.
mNumTracks
|
|
numAudios
!
=
mAudioTracks
.
mNumTracks
|
|
(
numVideos
&
&
info
.
mVideo
.
mMimeType
!
=
mVideoTracks
.
mInfo
-
>
mMimeType
)
|
|
(
numAudios
&
&
info
.
mAudio
.
mMimeType
!
=
mAudioTracks
.
mInfo
-
>
mMimeType
)
)
{
RejectAppend
(
NS_ERROR_FAILURE
__func__
)
;
return
;
}
mVideoTracks
.
mNeedRandomAccessPoint
=
true
;
mAudioTracks
.
mNeedRandomAccessPoint
=
true
;
}
bool
activeTrack
=
false
;
uint32_t
streamID
=
sStreamSourceID
+
+
;
if
(
!
mFirstInitializationSegmentReceived
)
{
mAudioTracks
.
mNumTracks
=
numAudios
;
if
(
numAudios
)
{
activeTrack
=
true
;
mAudioTracks
.
mBuffers
.
AppendElement
(
TrackBuffer
(
)
)
;
mAudioTracks
.
mInfo
=
new
SharedTrackInfo
(
info
.
mAudio
streamID
)
;
mAudioTracks
.
mLastInfo
=
mAudioTracks
.
mInfo
;
}
mVideoTracks
.
mNumTracks
=
numVideos
;
if
(
numVideos
)
{
activeTrack
=
true
;
mVideoTracks
.
mBuffers
.
AppendElement
(
TrackBuffer
(
)
)
;
mVideoTracks
.
mInfo
=
new
SharedTrackInfo
(
info
.
mVideo
streamID
)
;
mVideoTracks
.
mLastInfo
=
mVideoTracks
.
mInfo
;
}
if
(
activeTrack
)
{
mActiveTrack
=
true
;
}
mFirstInitializationSegmentReceived
=
true
;
}
else
{
mAudioTracks
.
mLastInfo
=
new
SharedTrackInfo
(
info
.
mAudio
streamID
)
;
mVideoTracks
.
mLastInfo
=
new
SharedTrackInfo
(
info
.
mVideo
streamID
)
;
}
UniquePtr
<
EncryptionInfo
>
crypto
=
mInputDemuxer
-
>
GetCrypto
(
)
;
if
(
crypto
&
&
crypto
-
>
IsEncrypted
(
)
)
{
#
ifdef
MOZ_EME
for
(
uint32_t
i
=
0
;
i
<
crypto
-
>
mInitDatas
.
Length
(
)
;
i
+
+
)
{
NS_DispatchToMainThread
(
new
DispatchKeyNeededEvent
(
mParentDecoder
crypto
-
>
mInitDatas
[
i
]
.
mInitData
crypto
-
>
mInitDatas
[
i
]
.
mType
)
)
;
}
#
endif
info
.
mCrypto
=
*
crypto
;
info
.
mCrypto
.
mInitDatas
.
Clear
(
)
;
mEncrypted
=
true
;
}
{
MonitorAutoLock
mon
(
mMonitor
)
;
mInfo
=
info
;
}
mInitData
=
mParser
-
>
InitData
(
)
;
mCurrentInputBuffer
-
>
EvictAll
(
)
;
mInputDemuxer
-
>
NotifyDataRemoved
(
)
;
RecreateParser
(
true
)
;
SetAppendState
(
AppendState
:
:
WAITING_FOR_SEGMENT
)
;
ScheduleSegmentParserLoop
(
)
;
}
void
TrackBuffersManager
:
:
OnDemuxerInitFailed
(
const
MediaResult
&
aError
)
{
MOZ_ASSERT
(
aError
!
=
NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA
)
;
mDemuxerInitRequest
.
Complete
(
)
;
RejectAppend
(
aError
__func__
)
;
}
RefPtr
<
TrackBuffersManager
:
:
CodedFrameProcessingPromise
>
TrackBuffersManager
:
:
CodedFrameProcessing
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MOZ_ASSERT
(
mProcessingPromise
.
IsEmpty
(
)
)
;
MediaByteRange
mediaRange
=
mParser
-
>
MediaSegmentRange
(
)
;
if
(
mediaRange
.
IsEmpty
(
)
)
{
AppendDataToCurrentInputBuffer
(
mInputBuffer
)
;
mInputBuffer
=
nullptr
;
}
else
{
MOZ_ASSERT
(
mProcessedInput
>
=
mInputBuffer
-
>
Length
(
)
)
;
if
(
int64_t
(
mProcessedInput
-
mInputBuffer
-
>
Length
(
)
)
>
mediaRange
.
mEnd
)
{
return
CodedFrameProcessingPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
uint32_t
length
=
mediaRange
.
mEnd
-
(
mProcessedInput
-
mInputBuffer
-
>
Length
(
)
)
;
if
(
!
length
)
{
RefPtr
<
CodedFrameProcessingPromise
>
p
=
mProcessingPromise
.
Ensure
(
__func__
)
;
CompleteCodedFrameProcessing
(
)
;
return
p
;
}
RefPtr
<
MediaByteBuffer
>
segment
=
new
MediaByteBuffer
;
if
(
!
segment
-
>
AppendElements
(
mInputBuffer
-
>
Elements
(
)
length
fallible
)
)
{
return
CodedFrameProcessingPromise
:
:
CreateAndReject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
}
AppendDataToCurrentInputBuffer
(
segment
)
;
mInputBuffer
-
>
RemoveElementsAt
(
0
length
)
;
}
RefPtr
<
CodedFrameProcessingPromise
>
p
=
mProcessingPromise
.
Ensure
(
__func__
)
;
DoDemuxVideo
(
)
;
return
p
;
}
void
TrackBuffersManager
:
:
OnDemuxFailed
(
TrackType
aTrack
const
MediaResult
&
aError
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MSE_DEBUG
(
"
Failed
to
demux
%
s
failure
:
%
u
"
aTrack
=
=
TrackType
:
:
kVideoTrack
?
"
video
"
:
"
audio
"
aError
.
Code
(
)
)
;
switch
(
aError
.
Code
(
)
)
{
case
NS_ERROR_DOM_MEDIA_END_OF_STREAM
:
case
NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA
:
if
(
aTrack
=
=
TrackType
:
:
kVideoTrack
)
{
DoDemuxAudio
(
)
;
}
else
{
CompleteCodedFrameProcessing
(
)
;
}
break
;
default
:
RejectProcessing
(
aError
__func__
)
;
break
;
}
}
void
TrackBuffersManager
:
:
DoDemuxVideo
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
!
HasVideo
(
)
)
{
DoDemuxAudio
(
)
;
return
;
}
mVideoTracks
.
mDemuxRequest
.
Begin
(
mVideoTracks
.
mDemuxer
-
>
GetSamples
(
-
1
)
-
>
Then
(
GetTaskQueue
(
)
__func__
this
&
TrackBuffersManager
:
:
OnVideoDemuxCompleted
&
TrackBuffersManager
:
:
OnVideoDemuxFailed
)
)
;
}
void
TrackBuffersManager
:
:
OnVideoDemuxCompleted
(
RefPtr
<
MediaTrackDemuxer
:
:
SamplesHolder
>
aSamples
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MSE_DEBUG
(
"
%
d
video
samples
demuxed
"
aSamples
-
>
mSamples
.
Length
(
)
)
;
mVideoTracks
.
mDemuxRequest
.
Complete
(
)
;
mVideoTracks
.
mQueuedSamples
.
AppendElements
(
aSamples
-
>
mSamples
)
;
DoDemuxAudio
(
)
;
}
void
TrackBuffersManager
:
:
DoDemuxAudio
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
!
HasAudio
(
)
)
{
CompleteCodedFrameProcessing
(
)
;
return
;
}
mAudioTracks
.
mDemuxRequest
.
Begin
(
mAudioTracks
.
mDemuxer
-
>
GetSamples
(
-
1
)
-
>
Then
(
GetTaskQueue
(
)
__func__
this
&
TrackBuffersManager
:
:
OnAudioDemuxCompleted
&
TrackBuffersManager
:
:
OnAudioDemuxFailed
)
)
;
}
void
TrackBuffersManager
:
:
OnAudioDemuxCompleted
(
RefPtr
<
MediaTrackDemuxer
:
:
SamplesHolder
>
aSamples
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
MSE_DEBUG
(
"
%
d
audio
samples
demuxed
"
aSamples
-
>
mSamples
.
Length
(
)
)
;
mAudioTracks
.
mDemuxRequest
.
Complete
(
)
;
mAudioTracks
.
mQueuedSamples
.
AppendElements
(
aSamples
-
>
mSamples
)
;
CompleteCodedFrameProcessing
(
)
;
}
void
TrackBuffersManager
:
:
CompleteCodedFrameProcessing
(
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
if
(
mSourceBufferAttributes
-
>
GetAppendMode
(
)
=
=
SourceBufferAppendMode
:
:
Sequence
&
&
mVideoTracks
.
mQueuedSamples
.
Length
(
)
&
&
mAudioTracks
.
mQueuedSamples
.
Length
(
)
)
{
TimeInterval
videoInterval
=
PresentationInterval
(
mVideoTracks
.
mQueuedSamples
)
;
TimeInterval
audioInterval
=
PresentationInterval
(
mAudioTracks
.
mQueuedSamples
)
;
if
(
audioInterval
.
mStart
<
videoInterval
.
mStart
)
{
ProcessFrames
(
mAudioTracks
.
mQueuedSamples
mAudioTracks
)
;
ProcessFrames
(
mVideoTracks
.
mQueuedSamples
mVideoTracks
)
;
}
else
{
ProcessFrames
(
mVideoTracks
.
mQueuedSamples
mVideoTracks
)
;
ProcessFrames
(
mAudioTracks
.
mQueuedSamples
mAudioTracks
)
;
}
}
else
{
ProcessFrames
(
mVideoTracks
.
mQueuedSamples
mVideoTracks
)
;
ProcessFrames
(
mAudioTracks
.
mQueuedSamples
mAudioTracks
)
;
}
#
if
defined
(
DEBUG
)
if
(
HasVideo
(
)
)
{
const
auto
&
track
=
mVideoTracks
.
mBuffers
.
LastElement
(
)
;
MOZ_ASSERT
(
track
.
IsEmpty
(
)
|
|
track
[
0
]
-
>
mKeyframe
)
;
for
(
uint32_t
i
=
1
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
(
track
[
i
-
1
]
-
>
mTrackInfo
-
>
GetID
(
)
=
=
track
[
i
]
-
>
mTrackInfo
-
>
GetID
(
)
&
&
track
[
i
-
1
]
-
>
mTimecode
<
=
track
[
i
]
-
>
mTimecode
)
|
|
track
[
i
]
-
>
mKeyframe
)
;
}
}
if
(
HasAudio
(
)
)
{
const
auto
&
track
=
mAudioTracks
.
mBuffers
.
LastElement
(
)
;
MOZ_ASSERT
(
track
.
IsEmpty
(
)
|
|
track
[
0
]
-
>
mKeyframe
)
;
for
(
uint32_t
i
=
1
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
(
track
[
i
-
1
]
-
>
mTrackInfo
-
>
GetID
(
)
=
=
track
[
i
]
-
>
mTrackInfo
-
>
GetID
(
)
&
&
track
[
i
-
1
]
-
>
mTimecode
<
=
track
[
i
]
-
>
mTimecode
)
|
|
track
[
i
]
-
>
mKeyframe
)
;
}
}
#
endif
mVideoTracks
.
mQueuedSamples
.
Clear
(
)
;
mAudioTracks
.
mQueuedSamples
.
Clear
(
)
;
UpdateBufferedRanges
(
)
;
mSizeSourceBuffer
=
mVideoTracks
.
mSizeBuffer
+
mAudioTracks
.
mSizeBuffer
;
if
(
mSizeSourceBuffer
>
=
EvictionThreshold
(
)
)
{
mBufferFull
=
true
;
}
if
(
mParser
-
>
MediaSegmentRange
(
)
.
IsEmpty
(
)
)
{
ResolveProcessing
(
true
__func__
)
;
return
;
}
mLastParsedEndTime
=
Some
(
std
:
:
max
(
mAudioTracks
.
mLastParsedEndTime
mVideoTracks
.
mLastParsedEndTime
)
)
;
int64_t
safeToEvict
=
std
:
:
min
(
HasVideo
(
)
?
mVideoTracks
.
mDemuxer
-
>
GetEvictionOffset
(
mVideoTracks
.
mLastParsedEndTime
)
:
INT64_MAX
HasAudio
(
)
?
mAudioTracks
.
mDemuxer
-
>
GetEvictionOffset
(
mAudioTracks
.
mLastParsedEndTime
)
:
INT64_MAX
)
;
ErrorResult
rv
;
mCurrentInputBuffer
-
>
EvictBefore
(
safeToEvict
rv
)
;
if
(
rv
.
Failed
(
)
)
{
rv
.
SuppressException
(
)
;
RejectProcessing
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
return
;
}
mInputDemuxer
-
>
NotifyDataRemoved
(
)
;
RecreateParser
(
true
)
;
SetAppendState
(
AppendState
:
:
WAITING_FOR_SEGMENT
)
;
ResolveProcessing
(
false
__func__
)
;
}
void
TrackBuffersManager
:
:
RejectProcessing
(
const
MediaResult
&
aRejectValue
const
char
*
aName
)
{
mProcessingPromise
.
RejectIfExists
(
aRejectValue
__func__
)
;
}
void
TrackBuffersManager
:
:
ResolveProcessing
(
bool
aResolveValue
const
char
*
aName
)
{
mProcessingPromise
.
ResolveIfExists
(
aResolveValue
__func__
)
;
}
void
TrackBuffersManager
:
:
CheckSequenceDiscontinuity
(
const
TimeUnit
&
aPresentationTime
)
{
if
(
mSourceBufferAttributes
-
>
GetAppendMode
(
)
=
=
SourceBufferAppendMode
:
:
Sequence
&
&
mSourceBufferAttributes
-
>
HaveGroupStartTimestamp
(
)
)
{
mSourceBufferAttributes
-
>
SetTimestampOffset
(
mSourceBufferAttributes
-
>
GetGroupStartTimestamp
(
)
-
aPresentationTime
)
;
mSourceBufferAttributes
-
>
SetGroupEndTimestamp
(
mSourceBufferAttributes
-
>
GetGroupStartTimestamp
(
)
)
;
mVideoTracks
.
mNeedRandomAccessPoint
=
true
;
mAudioTracks
.
mNeedRandomAccessPoint
=
true
;
mSourceBufferAttributes
-
>
ResetGroupStartTimestamp
(
)
;
}
}
TimeInterval
TrackBuffersManager
:
:
PresentationInterval
(
const
TrackBuffer
&
aSamples
)
const
{
TimeInterval
presentationInterval
=
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
aSamples
[
0
]
-
>
mTime
)
TimeUnit
:
:
FromMicroseconds
(
aSamples
[
0
]
-
>
GetEndTime
(
)
)
)
;
for
(
uint32_t
i
=
1
;
i
<
aSamples
.
Length
(
)
;
i
+
+
)
{
auto
&
sample
=
aSamples
[
i
]
;
presentationInterval
=
presentationInterval
.
Span
(
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
)
)
;
}
return
presentationInterval
;
}
void
TrackBuffersManager
:
:
ProcessFrames
(
TrackBuffer
&
aSamples
TrackData
&
aTrackData
)
{
if
(
!
aSamples
.
Length
(
)
)
{
return
;
}
TimeUnit
presentationTimestamp
=
mSourceBufferAttributes
-
>
mGenerateTimestamps
?
TimeUnit
(
)
:
TimeUnit
:
:
FromMicroseconds
(
aSamples
[
0
]
-
>
mTime
)
;
CheckSequenceDiscontinuity
(
presentationTimestamp
)
;
auto
&
trackBuffer
=
aTrackData
;
TimeInterval
targetWindow
=
mAppendWindow
.
mStart
!
=
TimeUnit
:
:
FromSeconds
(
0
)
?
mAppendWindow
:
TimeInterval
(
mAppendWindow
.
mStart
mAppendWindow
.
mEnd
trackBuffer
.
mLastFrameDuration
.
isSome
(
)
?
trackBuffer
.
mLongestFrameDuration
:
TimeUnit
:
:
FromMicroseconds
(
aSamples
[
0
]
-
>
mDuration
)
)
;
TimeIntervals
samplesRange
;
uint32_t
sizeNewSamples
=
0
;
TrackBuffer
samples
;
bool
needDiscontinuityCheck
=
true
;
TimeUnit
highestSampleTime
;
if
(
aSamples
.
Length
(
)
)
{
aTrackData
.
mLastParsedEndTime
=
TimeUnit
(
)
;
}
for
(
auto
&
sample
:
aSamples
)
{
SAMPLE_DEBUG
(
"
Processing
%
s
frame
(
pts
:
%
lld
end
:
%
lld
dts
:
%
lld
duration
:
%
lld
"
"
kf
:
%
d
)
"
aTrackData
.
mInfo
-
>
mMimeType
.
get
(
)
sample
-
>
mTime
sample
-
>
GetEndTime
(
)
sample
-
>
mTimecode
sample
-
>
mDuration
sample
-
>
mKeyframe
)
;
const
TimeUnit
sampleEndTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
;
if
(
sampleEndTime
>
aTrackData
.
mLastParsedEndTime
)
{
aTrackData
.
mLastParsedEndTime
=
sampleEndTime
;
}
if
(
trackBuffer
.
mNeedRandomAccessPoint
)
{
if
(
!
sample
-
>
mKeyframe
)
{
continue
;
}
trackBuffer
.
mNeedRandomAccessPoint
=
false
;
}
TimeUnit
sampleTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
;
TimeUnit
sampleTimecode
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
)
;
TimeUnit
sampleDuration
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mDuration
)
;
TimeUnit
timestampOffset
=
mSourceBufferAttributes
-
>
GetTimestampOffset
(
)
;
TimeInterval
sampleInterval
=
mSourceBufferAttributes
-
>
mGenerateTimestamps
?
TimeInterval
(
timestampOffset
timestampOffset
+
sampleDuration
)
:
TimeInterval
(
timestampOffset
+
sampleTime
timestampOffset
+
sampleTime
+
sampleDuration
)
;
TimeUnit
decodeTimestamp
=
mSourceBufferAttributes
-
>
mGenerateTimestamps
?
timestampOffset
:
timestampOffset
+
sampleTimecode
;
if
(
needDiscontinuityCheck
&
&
trackBuffer
.
mLastDecodeTimestamp
.
isSome
(
)
&
&
(
decodeTimestamp
<
trackBuffer
.
mLastDecodeTimestamp
.
ref
(
)
|
|
(
decodeTimestamp
-
trackBuffer
.
mLastDecodeTimestamp
.
ref
(
)
>
2
*
trackBuffer
.
mLongestFrameDuration
)
)
)
{
MSE_DEBUG
(
"
Discontinuity
detected
.
"
)
;
SourceBufferAppendMode
appendMode
=
mSourceBufferAttributes
-
>
GetAppendMode
(
)
;
if
(
appendMode
=
=
SourceBufferAppendMode
:
:
Segments
)
{
mSourceBufferAttributes
-
>
SetGroupEndTimestamp
(
sampleInterval
.
mStart
)
;
}
if
(
appendMode
=
=
SourceBufferAppendMode
:
:
Sequence
)
{
mSourceBufferAttributes
-
>
SetGroupStartTimestamp
(
mSourceBufferAttributes
-
>
GetGroupEndTimestamp
(
)
)
;
}
for
(
auto
&
track
:
GetTracksList
(
)
)
{
track
-
>
ResetAppendState
(
)
;
}
TimeUnit
presentationTimestamp
=
mSourceBufferAttributes
-
>
mGenerateTimestamps
?
TimeUnit
(
)
:
sampleTime
;
CheckSequenceDiscontinuity
(
presentationTimestamp
)
;
if
(
!
sample
-
>
mKeyframe
)
{
continue
;
}
if
(
appendMode
=
=
SourceBufferAppendMode
:
:
Sequence
)
{
timestampOffset
=
mSourceBufferAttributes
-
>
GetTimestampOffset
(
)
;
sampleInterval
=
mSourceBufferAttributes
-
>
mGenerateTimestamps
?
TimeInterval
(
timestampOffset
timestampOffset
+
sampleDuration
)
:
TimeInterval
(
timestampOffset
+
sampleTime
timestampOffset
+
sampleTime
+
sampleDuration
)
;
decodeTimestamp
=
mSourceBufferAttributes
-
>
mGenerateTimestamps
?
timestampOffset
:
timestampOffset
+
sampleTimecode
;
}
trackBuffer
.
mNeedRandomAccessPoint
=
false
;
needDiscontinuityCheck
=
false
;
}
if
(
!
targetWindow
.
ContainsWithStrictEnd
(
sampleInterval
)
)
{
if
(
samples
.
Length
(
)
)
{
InsertFrames
(
samples
samplesRange
trackBuffer
)
;
samples
.
Clear
(
)
;
samplesRange
=
TimeIntervals
(
)
;
trackBuffer
.
mSizeBuffer
+
=
sizeNewSamples
;
sizeNewSamples
=
0
;
UpdateHighestTimestamp
(
trackBuffer
highestSampleTime
)
;
}
trackBuffer
.
mNeedRandomAccessPoint
=
true
;
needDiscontinuityCheck
=
true
;
continue
;
}
samplesRange
+
=
sampleInterval
;
sizeNewSamples
+
=
sample
-
>
ComputedSizeOfIncludingThis
(
)
;
sample
-
>
mTime
=
sampleInterval
.
mStart
.
ToMicroseconds
(
)
;
sample
-
>
mTimecode
=
decodeTimestamp
.
ToMicroseconds
(
)
;
sample
-
>
mTrackInfo
=
trackBuffer
.
mLastInfo
;
samples
.
AppendElement
(
sample
)
;
trackBuffer
.
mLongestFrameDuration
=
trackBuffer
.
mLastFrameDuration
.
isSome
(
)
?
sample
-
>
mKeyframe
?
sampleDuration
:
std
:
:
max
(
sampleDuration
trackBuffer
.
mLongestFrameDuration
)
:
sampleDuration
;
trackBuffer
.
mLastDecodeTimestamp
=
Some
(
decodeTimestamp
)
;
trackBuffer
.
mLastFrameDuration
=
Some
(
sampleDuration
)
;
if
(
trackBuffer
.
mHighestEndTimestamp
.
isNothing
(
)
|
|
sampleInterval
.
mEnd
>
trackBuffer
.
mHighestEndTimestamp
.
ref
(
)
)
{
trackBuffer
.
mHighestEndTimestamp
=
Some
(
sampleInterval
.
mEnd
)
;
}
if
(
sampleInterval
.
mStart
>
highestSampleTime
)
{
highestSampleTime
=
sampleInterval
.
mStart
;
}
if
(
sampleInterval
.
mEnd
>
mSourceBufferAttributes
-
>
GetGroupEndTimestamp
(
)
)
{
mSourceBufferAttributes
-
>
SetGroupEndTimestamp
(
sampleInterval
.
mEnd
)
;
}
if
(
mSourceBufferAttributes
-
>
mGenerateTimestamps
)
{
mSourceBufferAttributes
-
>
SetTimestampOffset
(
sampleInterval
.
mEnd
)
;
}
}
if
(
samples
.
Length
(
)
)
{
InsertFrames
(
samples
samplesRange
trackBuffer
)
;
trackBuffer
.
mSizeBuffer
+
=
sizeNewSamples
;
UpdateHighestTimestamp
(
trackBuffer
highestSampleTime
)
;
}
}
bool
TrackBuffersManager
:
:
CheckNextInsertionIndex
(
TrackData
&
aTrackData
const
TimeUnit
&
aSampleTime
)
{
if
(
aTrackData
.
mNextInsertionIndex
.
isSome
(
)
)
{
return
true
;
}
TrackBuffer
&
data
=
aTrackData
.
mBuffers
.
LastElement
(
)
;
if
(
data
.
IsEmpty
(
)
|
|
aSampleTime
<
aTrackData
.
mBufferedRanges
.
GetStart
(
)
)
{
aTrackData
.
mNextInsertionIndex
=
Some
(
0u
)
;
return
true
;
}
TimeInterval
target
;
for
(
const
auto
&
interval
:
aTrackData
.
mBufferedRanges
)
{
if
(
aSampleTime
<
interval
.
mStart
)
{
target
=
interval
;
break
;
}
}
if
(
target
.
IsEmpty
(
)
)
{
aTrackData
.
mNextInsertionIndex
=
Some
(
uint32_t
(
data
.
Length
(
)
)
)
;
return
true
;
}
for
(
uint32_t
i
=
0
;
i
<
data
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
data
[
i
]
;
if
(
sample
-
>
mTime
>
=
target
.
mStart
.
ToMicroseconds
(
)
|
|
sample
-
>
GetEndTime
(
)
>
target
.
mStart
.
ToMicroseconds
(
)
)
{
aTrackData
.
mNextInsertionIndex
=
Some
(
i
)
;
return
true
;
}
}
NS_ASSERTION
(
false
"
Insertion
Index
Not
Found
"
)
;
return
false
;
}
void
TrackBuffersManager
:
:
InsertFrames
(
TrackBuffer
&
aSamples
const
TimeIntervals
&
aIntervals
TrackData
&
aTrackData
)
{
auto
&
trackBuffer
=
aTrackData
;
MSE_DEBUGV
(
"
Processing
%
d
%
s
frames
(
start
:
%
lld
end
:
%
lld
)
"
aSamples
.
Length
(
)
aTrackData
.
mInfo
-
>
mMimeType
.
get
(
)
aIntervals
.
GetStart
(
)
.
ToMicroseconds
(
)
aIntervals
.
GetEnd
(
)
.
ToMicroseconds
(
)
)
;
TimeIntervals
intersection
=
trackBuffer
.
mBufferedRanges
;
intersection
.
Intersection
(
aIntervals
)
;
if
(
intersection
.
Length
(
)
)
{
if
(
aSamples
[
0
]
-
>
mKeyframe
&
&
(
mType
.
LowerCaseEqualsLiteral
(
"
video
/
webm
"
)
|
|
mType
.
LowerCaseEqualsLiteral
(
"
audio
/
webm
"
)
)
)
{
trackBuffer
.
mNextInsertionIndex
.
reset
(
)
;
}
uint32_t
index
=
RemoveFrames
(
aIntervals
trackBuffer
trackBuffer
.
mNextInsertionIndex
.
refOr
(
0
)
)
;
if
(
index
)
{
trackBuffer
.
mNextInsertionIndex
=
Some
(
index
)
;
}
}
if
(
!
CheckNextInsertionIndex
(
aTrackData
TimeUnit
:
:
FromMicroseconds
(
aSamples
[
0
]
-
>
mTime
)
)
)
{
RejectProcessing
(
NS_ERROR_FAILURE
__func__
)
;
return
;
}
if
(
trackBuffer
.
mNextGetSampleIndex
.
isSome
(
)
)
{
if
(
trackBuffer
.
mNextInsertionIndex
.
ref
(
)
=
=
trackBuffer
.
mNextGetSampleIndex
.
ref
(
)
&
&
aIntervals
.
GetEnd
(
)
>
=
trackBuffer
.
mNextSampleTime
)
{
MSE_DEBUG
(
"
Next
sample
to
be
played
got
overwritten
"
)
;
trackBuffer
.
mNextGetSampleIndex
.
reset
(
)
;
ResetEvictionIndex
(
trackBuffer
)
;
}
else
if
(
trackBuffer
.
mNextInsertionIndex
.
ref
(
)
<
=
trackBuffer
.
mNextGetSampleIndex
.
ref
(
)
)
{
trackBuffer
.
mNextGetSampleIndex
.
ref
(
)
+
=
aSamples
.
Length
(
)
;
ResetEvictionIndex
(
trackBuffer
)
;
}
}
TrackBuffer
&
data
=
trackBuffer
.
mBuffers
.
LastElement
(
)
;
data
.
InsertElementsAt
(
trackBuffer
.
mNextInsertionIndex
.
ref
(
)
aSamples
)
;
trackBuffer
.
mNextInsertionIndex
.
ref
(
)
+
=
aSamples
.
Length
(
)
;
trackBuffer
.
mBufferedRanges
+
=
aIntervals
;
if
(
aIntervals
.
Length
(
)
)
{
TimeIntervals
range
(
aIntervals
)
;
range
.
SetFuzz
(
trackBuffer
.
mLongestFrameDuration
/
2
)
;
trackBuffer
.
mSanitizedBufferedRanges
+
=
range
;
}
}
void
TrackBuffersManager
:
:
UpdateHighestTimestamp
(
TrackData
&
aTrackData
const
media
:
:
TimeUnit
&
aHighestTime
)
{
if
(
aHighestTime
>
aTrackData
.
mHighestStartTimestamp
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
aTrackData
.
mHighestStartTimestamp
=
aHighestTime
;
}
}
uint32_t
TrackBuffersManager
:
:
RemoveFrames
(
const
TimeIntervals
&
aIntervals
TrackData
&
aTrackData
uint32_t
aStartIndex
)
{
TrackBuffer
&
data
=
aTrackData
.
mBuffers
.
LastElement
(
)
;
Maybe
<
uint32_t
>
firstRemovedIndex
;
uint32_t
lastRemovedIndex
=
0
;
for
(
uint32_t
i
=
aStartIndex
;
i
<
data
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
sample
=
data
[
i
]
;
TimeInterval
sampleInterval
=
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
)
;
if
(
aIntervals
.
Contains
(
sampleInterval
)
)
{
if
(
firstRemovedIndex
.
isNothing
(
)
)
{
firstRemovedIndex
=
Some
(
i
)
;
}
lastRemovedIndex
=
i
;
}
}
if
(
firstRemovedIndex
.
isNothing
(
)
)
{
return
0
;
}
for
(
uint32_t
i
=
lastRemovedIndex
+
1
;
i
<
data
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
data
[
i
]
;
if
(
sample
-
>
mKeyframe
)
{
break
;
}
lastRemovedIndex
=
i
;
}
int64_t
maxSampleDuration
=
0
;
uint32_t
sizeRemoved
=
0
;
TimeIntervals
removedIntervals
;
for
(
uint32_t
i
=
firstRemovedIndex
.
ref
(
)
;
i
<
=
lastRemovedIndex
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
sample
=
data
[
i
]
;
TimeInterval
sampleInterval
=
TimeInterval
(
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
)
;
removedIntervals
+
=
sampleInterval
;
if
(
sample
-
>
mDuration
>
maxSampleDuration
)
{
maxSampleDuration
=
sample
-
>
mDuration
;
}
sizeRemoved
+
=
sample
-
>
ComputedSizeOfIncludingThis
(
)
;
}
aTrackData
.
mSizeBuffer
-
=
sizeRemoved
;
MSE_DEBUG
(
"
Removing
frames
from
:
%
u
(
frames
:
%
u
)
(
[
%
f
%
f
)
)
"
firstRemovedIndex
.
ref
(
)
lastRemovedIndex
-
firstRemovedIndex
.
ref
(
)
+
1
removedIntervals
.
GetStart
(
)
.
ToSeconds
(
)
removedIntervals
.
GetEnd
(
)
.
ToSeconds
(
)
)
;
if
(
aTrackData
.
mNextGetSampleIndex
.
isSome
(
)
)
{
if
(
aTrackData
.
mNextGetSampleIndex
.
ref
(
)
>
=
firstRemovedIndex
.
ref
(
)
&
&
aTrackData
.
mNextGetSampleIndex
.
ref
(
)
<
=
lastRemovedIndex
)
{
MSE_DEBUG
(
"
Next
sample
to
be
played
got
evicted
"
)
;
aTrackData
.
mNextGetSampleIndex
.
reset
(
)
;
ResetEvictionIndex
(
aTrackData
)
;
}
else
if
(
aTrackData
.
mNextGetSampleIndex
.
ref
(
)
>
lastRemovedIndex
)
{
uint32_t
samplesRemoved
=
lastRemovedIndex
-
firstRemovedIndex
.
ref
(
)
+
1
;
aTrackData
.
mNextGetSampleIndex
.
ref
(
)
-
=
samplesRemoved
;
if
(
aTrackData
.
mEvictionIndex
.
mLastIndex
>
lastRemovedIndex
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aTrackData
.
mEvictionIndex
.
mLastIndex
>
=
samplesRemoved
&
&
aTrackData
.
mEvictionIndex
.
mEvictable
>
=
sizeRemoved
"
Invalid
eviction
index
"
)
;
MonitorAutoLock
mon
(
mMonitor
)
;
aTrackData
.
mEvictionIndex
.
mLastIndex
-
=
samplesRemoved
;
aTrackData
.
mEvictionIndex
.
mEvictable
-
=
sizeRemoved
;
}
else
{
ResetEvictionIndex
(
aTrackData
)
;
}
}
}
if
(
aTrackData
.
mNextInsertionIndex
.
isSome
(
)
)
{
if
(
aTrackData
.
mNextInsertionIndex
.
ref
(
)
>
firstRemovedIndex
.
ref
(
)
&
&
aTrackData
.
mNextInsertionIndex
.
ref
(
)
<
=
lastRemovedIndex
+
1
)
{
aTrackData
.
ResetAppendState
(
)
;
MSE_DEBUG
(
"
NextInsertionIndex
got
reset
.
"
)
;
}
else
if
(
aTrackData
.
mNextInsertionIndex
.
ref
(
)
>
lastRemovedIndex
+
1
)
{
aTrackData
.
mNextInsertionIndex
.
ref
(
)
-
=
lastRemovedIndex
-
firstRemovedIndex
.
ref
(
)
+
1
;
}
}
aTrackData
.
mBufferedRanges
-
=
removedIntervals
;
aTrackData
.
mSanitizedBufferedRanges
=
aTrackData
.
mBufferedRanges
;
aTrackData
.
mSanitizedBufferedRanges
.
SetFuzz
(
TimeUnit
:
:
FromMicroseconds
(
maxSampleDuration
/
2
)
)
;
data
.
RemoveElementsAt
(
firstRemovedIndex
.
ref
(
)
lastRemovedIndex
-
firstRemovedIndex
.
ref
(
)
+
1
)
;
if
(
aIntervals
.
GetEnd
(
)
>
=
aTrackData
.
mHighestStartTimestamp
)
{
int64_t
highestStartTime
=
0
;
for
(
const
auto
&
sample
:
data
)
{
if
(
sample
-
>
mTime
>
highestStartTime
)
{
highestStartTime
=
sample
-
>
mTime
;
}
}
MonitorAutoLock
mon
(
mMonitor
)
;
aTrackData
.
mHighestStartTimestamp
=
TimeUnit
:
:
FromMicroseconds
(
highestStartTime
)
;
}
return
firstRemovedIndex
.
ref
(
)
;
}
void
TrackBuffersManager
:
:
RecreateParser
(
bool
aReuseInitData
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mParser
=
ContainerParser
:
:
CreateForMIMEType
(
mType
)
;
if
(
aReuseInitData
&
&
mInitData
)
{
int64_t
start
end
;
mParser
-
>
ParseStartAndEndTimestamps
(
mInitData
start
end
)
;
mProcessedInput
=
mInitData
-
>
Length
(
)
;
}
else
{
mProcessedInput
=
0
;
}
}
nsTArray
<
TrackBuffersManager
:
:
TrackData
*
>
TrackBuffersManager
:
:
GetTracksList
(
)
{
nsTArray
<
TrackData
*
>
tracks
;
if
(
HasVideo
(
)
)
{
tracks
.
AppendElement
(
&
mVideoTracks
)
;
}
if
(
HasAudio
(
)
)
{
tracks
.
AppendElement
(
&
mAudioTracks
)
;
}
return
tracks
;
}
void
TrackBuffersManager
:
:
SetAppendState
(
SourceBufferAttributes
:
:
AppendState
aAppendState
)
{
MSE_DEBUG
(
"
AppendState
changed
from
%
s
to
%
s
"
AppendStateToStr
(
mSourceBufferAttributes
-
>
GetAppendState
(
)
)
AppendStateToStr
(
aAppendState
)
)
;
mSourceBufferAttributes
-
>
SetAppendState
(
aAppendState
)
;
}
MediaInfo
TrackBuffersManager
:
:
GetMetadata
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
return
mInfo
;
}
const
TimeIntervals
&
TrackBuffersManager
:
:
Buffered
(
TrackInfo
:
:
TrackType
aTrack
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
GetTracksData
(
aTrack
)
.
mBufferedRanges
;
}
const
media
:
:
TimeUnit
&
TrackBuffersManager
:
:
HighestStartTime
(
TrackInfo
:
:
TrackType
aTrack
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
GetTracksData
(
aTrack
)
.
mHighestStartTimestamp
;
}
TimeIntervals
TrackBuffersManager
:
:
SafeBuffered
(
TrackInfo
:
:
TrackType
aTrack
)
const
{
MonitorAutoLock
mon
(
mMonitor
)
;
return
aTrack
=
=
TrackInfo
:
:
kVideoTrack
?
mVideoBufferedRanges
:
mAudioBufferedRanges
;
}
TimeUnit
TrackBuffersManager
:
:
HighestStartTime
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
TimeUnit
highestStartTime
;
for
(
auto
&
track
:
GetTracksList
(
)
)
{
highestStartTime
=
std
:
:
max
(
track
-
>
mHighestStartTimestamp
highestStartTime
)
;
}
return
highestStartTime
;
}
TimeUnit
TrackBuffersManager
:
:
HighestEndTime
(
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
TimeUnit
highestEndTime
;
nsTArray
<
TimeIntervals
*
>
tracks
;
if
(
HasVideo
(
)
)
{
tracks
.
AppendElement
(
&
mVideoBufferedRanges
)
;
}
if
(
HasAudio
(
)
)
{
tracks
.
AppendElement
(
&
mAudioBufferedRanges
)
;
}
for
(
auto
trackRanges
:
tracks
)
{
highestEndTime
=
std
:
:
max
(
trackRanges
-
>
GetEnd
(
)
highestEndTime
)
;
}
return
highestEndTime
;
}
void
TrackBuffersManager
:
:
ResetEvictionIndex
(
TrackData
&
aTrackData
)
{
MonitorAutoLock
mon
(
mMonitor
)
;
aTrackData
.
mEvictionIndex
.
Reset
(
)
;
}
void
TrackBuffersManager
:
:
UpdateEvictionIndex
(
TrackData
&
aTrackData
uint32_t
currentIndex
)
{
uint32_t
evictable
=
0
;
TrackBuffer
&
data
=
aTrackData
.
mBuffers
.
LastElement
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
currentIndex
>
=
aTrackData
.
mEvictionIndex
.
mLastIndex
"
Invalid
call
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
currentIndex
=
=
data
.
Length
(
)
|
|
data
[
currentIndex
]
-
>
mKeyframe
"
Must
stop
at
keyframe
"
)
;
for
(
uint32_t
i
=
aTrackData
.
mEvictionIndex
.
mLastIndex
;
i
<
currentIndex
;
i
+
+
)
{
evictable
+
=
data
[
i
]
-
>
ComputedSizeOfIncludingThis
(
)
;
}
aTrackData
.
mEvictionIndex
.
mLastIndex
=
currentIndex
;
MonitorAutoLock
mon
(
mMonitor
)
;
aTrackData
.
mEvictionIndex
.
mEvictable
+
=
evictable
;
}
const
TrackBuffersManager
:
:
TrackBuffer
&
TrackBuffersManager
:
:
GetTrackBuffer
(
TrackInfo
:
:
TrackType
aTrack
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
return
GetTracksData
(
aTrack
)
.
mBuffers
.
LastElement
(
)
;
}
uint32_t
TrackBuffersManager
:
:
FindSampleIndex
(
const
TrackBuffer
&
aTrackBuffer
const
TimeInterval
&
aInterval
)
{
TimeUnit
target
=
aInterval
.
mStart
-
aInterval
.
mFuzz
;
for
(
uint32_t
i
=
0
;
i
<
aTrackBuffer
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
aTrackBuffer
[
i
]
;
if
(
sample
-
>
mTime
>
=
target
.
ToMicroseconds
(
)
|
|
sample
-
>
GetEndTime
(
)
>
target
.
ToMicroseconds
(
)
)
{
return
i
;
}
}
NS_ASSERTION
(
false
"
FindSampleIndex
called
with
invalid
arguments
"
)
;
return
0
;
}
TimeUnit
TrackBuffersManager
:
:
Seek
(
TrackInfo
:
:
TrackType
aTrack
const
TimeUnit
&
aTime
const
TimeUnit
&
aFuzz
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
auto
&
trackBuffer
=
GetTracksData
(
aTrack
)
;
const
TrackBuffersManager
:
:
TrackBuffer
&
track
=
GetTrackBuffer
(
aTrack
)
;
if
(
!
track
.
Length
(
)
)
{
trackBuffer
.
mNextGetSampleIndex
=
Some
(
uint32_t
(
0
)
)
;
trackBuffer
.
mNextSampleTimecode
=
TimeUnit
(
)
;
trackBuffer
.
mNextSampleTime
=
TimeUnit
(
)
;
ResetEvictionIndex
(
trackBuffer
)
;
return
TimeUnit
(
)
;
}
uint32_t
i
=
0
;
if
(
aTime
!
=
TimeUnit
(
)
)
{
TimeIntervals
buffered
=
trackBuffer
.
mBufferedRanges
;
buffered
.
SetFuzz
(
aFuzz
/
2
)
;
TimeIntervals
:
:
IndexType
index
=
buffered
.
Find
(
aTime
)
;
MOZ_ASSERT
(
index
!
=
TimeIntervals
:
:
NoIndex
"
We
shouldn
'
t
be
called
if
aTime
isn
'
t
buffered
"
)
;
TimeInterval
target
=
buffered
[
index
]
;
target
.
mFuzz
=
aFuzz
;
i
=
FindSampleIndex
(
track
target
)
;
}
Maybe
<
TimeUnit
>
lastKeyFrameTime
;
TimeUnit
lastKeyFrameTimecode
;
uint32_t
lastKeyFrameIndex
=
0
;
for
(
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
track
[
i
]
;
TimeUnit
sampleTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
;
if
(
sampleTime
>
aTime
&
&
lastKeyFrameTime
.
isSome
(
)
)
{
break
;
}
if
(
sample
-
>
mKeyframe
)
{
lastKeyFrameTimecode
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
)
;
lastKeyFrameTime
=
Some
(
sampleTime
)
;
lastKeyFrameIndex
=
i
;
}
if
(
sampleTime
=
=
aTime
|
|
(
sampleTime
>
aTime
&
&
lastKeyFrameTime
.
isSome
(
)
)
)
{
break
;
}
}
MSE_DEBUG
(
"
Keyframe
%
s
found
at
%
lld
%
u
"
lastKeyFrameTime
.
isSome
(
)
?
"
"
:
"
not
"
lastKeyFrameTime
.
refOr
(
TimeUnit
(
)
)
.
ToMicroseconds
(
)
lastKeyFrameIndex
)
;
trackBuffer
.
mNextGetSampleIndex
=
Some
(
lastKeyFrameIndex
)
;
trackBuffer
.
mNextSampleTimecode
=
lastKeyFrameTimecode
;
trackBuffer
.
mNextSampleTime
=
lastKeyFrameTime
.
refOr
(
TimeUnit
(
)
)
;
ResetEvictionIndex
(
trackBuffer
)
;
UpdateEvictionIndex
(
trackBuffer
lastKeyFrameIndex
)
;
return
lastKeyFrameTime
.
refOr
(
TimeUnit
(
)
)
;
}
uint32_t
TrackBuffersManager
:
:
SkipToNextRandomAccessPoint
(
TrackInfo
:
:
TrackType
aTrack
const
TimeUnit
&
aTimeThreadshold
const
media
:
:
TimeUnit
&
aFuzz
bool
&
aFound
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
uint32_t
parsed
=
0
;
auto
&
trackData
=
GetTracksData
(
aTrack
)
;
const
TrackBuffer
&
track
=
GetTrackBuffer
(
aTrack
)
;
aFound
=
false
;
if
(
trackData
.
mNextGetSampleIndex
.
isNothing
(
)
)
{
if
(
trackData
.
mNextSampleTimecode
=
=
TimeUnit
(
)
)
{
trackData
.
mNextGetSampleIndex
=
Some
(
0u
)
;
}
else
{
int32_t
pos
=
FindCurrentPosition
(
aTrack
aFuzz
)
;
if
(
pos
<
0
)
{
return
0
;
}
trackData
.
mNextGetSampleIndex
=
Some
(
uint32_t
(
pos
)
)
;
}
}
TimeUnit
nextSampleTimecode
=
trackData
.
mNextSampleTimecode
;
TimeUnit
nextSampleTime
=
trackData
.
mNextSampleTime
;
uint32_t
i
=
trackData
.
mNextGetSampleIndex
.
ref
(
)
;
int32_t
originalPos
=
i
;
for
(
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
const
MediaRawData
*
sample
=
GetSample
(
aTrack
i
nextSampleTimecode
nextSampleTime
aFuzz
)
;
if
(
!
sample
)
{
break
;
}
if
(
sample
-
>
mKeyframe
&
&
sample
-
>
mTime
>
=
aTimeThreadshold
.
ToMicroseconds
(
)
)
{
aFound
=
true
;
break
;
}
nextSampleTimecode
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
+
sample
-
>
mDuration
)
;
nextSampleTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
;
parsed
+
+
;
}
if
(
aFound
)
{
trackData
.
mNextSampleTimecode
=
TimeUnit
:
:
FromMicroseconds
(
track
[
i
]
-
>
mTimecode
)
;
trackData
.
mNextSampleTime
=
TimeUnit
:
:
FromMicroseconds
(
track
[
i
]
-
>
mTime
)
;
trackData
.
mNextGetSampleIndex
=
Some
(
i
)
;
}
else
if
(
i
>
0
)
{
for
(
int
j
=
i
-
1
;
j
>
=
originalPos
;
j
-
-
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
track
[
j
]
;
if
(
sample
-
>
mKeyframe
)
{
trackData
.
mNextSampleTimecode
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
)
;
trackData
.
mNextSampleTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
;
trackData
.
mNextGetSampleIndex
=
Some
(
uint32_t
(
j
)
)
;
aFound
=
true
;
break
;
}
parsed
-
-
;
}
}
if
(
aFound
)
{
UpdateEvictionIndex
(
trackData
trackData
.
mNextGetSampleIndex
.
ref
(
)
)
;
}
return
parsed
;
}
const
MediaRawData
*
TrackBuffersManager
:
:
GetSample
(
TrackInfo
:
:
TrackType
aTrack
uint32_t
aIndex
const
TimeUnit
&
aExpectedDts
const
TimeUnit
&
aExpectedPts
const
TimeUnit
&
aFuzz
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
const
TrackBuffer
&
track
=
GetTrackBuffer
(
aTrack
)
;
if
(
aIndex
>
=
track
.
Length
(
)
)
{
return
nullptr
;
}
const
RefPtr
<
MediaRawData
>
&
sample
=
track
[
aIndex
]
;
if
(
!
aIndex
|
|
sample
-
>
mTimecode
<
=
(
aExpectedDts
+
aFuzz
)
.
ToMicroseconds
(
)
|
|
sample
-
>
mTime
<
=
(
aExpectedPts
+
aFuzz
)
.
ToMicroseconds
(
)
)
{
return
sample
;
}
return
nullptr
;
}
already_AddRefed
<
MediaRawData
>
TrackBuffersManager
:
:
GetSample
(
TrackInfo
:
:
TrackType
aTrack
const
TimeUnit
&
aFuzz
MediaResult
&
aResult
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
auto
&
trackData
=
GetTracksData
(
aTrack
)
;
const
TrackBuffer
&
track
=
GetTrackBuffer
(
aTrack
)
;
aResult
=
NS_ERROR_DOM_MEDIA_WAITING_FOR_DATA
;
if
(
!
track
.
Length
(
)
)
{
aResult
=
NS_ERROR_DOM_MEDIA_END_OF_STREAM
;
return
nullptr
;
}
if
(
trackData
.
mNextGetSampleIndex
.
isNothing
(
)
&
&
trackData
.
mNextSampleTimecode
=
=
TimeUnit
(
)
)
{
trackData
.
mNextGetSampleIndex
=
Some
(
0u
)
;
}
if
(
trackData
.
mNextGetSampleIndex
.
isSome
(
)
)
{
if
(
trackData
.
mNextGetSampleIndex
.
ref
(
)
>
=
track
.
Length
(
)
)
{
aResult
=
NS_ERROR_DOM_MEDIA_END_OF_STREAM
;
return
nullptr
;
}
const
MediaRawData
*
sample
=
GetSample
(
aTrack
trackData
.
mNextGetSampleIndex
.
ref
(
)
trackData
.
mNextSampleTimecode
trackData
.
mNextSampleTime
aFuzz
)
;
if
(
!
sample
)
{
return
nullptr
;
}
RefPtr
<
MediaRawData
>
p
=
sample
-
>
Clone
(
)
;
if
(
!
p
)
{
aResult
=
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
return
nullptr
;
}
if
(
p
-
>
mKeyframe
)
{
UpdateEvictionIndex
(
trackData
trackData
.
mNextGetSampleIndex
.
ref
(
)
)
;
}
trackData
.
mNextGetSampleIndex
.
ref
(
)
+
+
;
TimeUnit
nextSampleTimecode
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
+
sample
-
>
mDuration
)
;
TimeUnit
nextSampleTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
;
const
MediaRawData
*
nextSample
=
GetSample
(
aTrack
trackData
.
mNextGetSampleIndex
.
ref
(
)
nextSampleTimecode
nextSampleTime
aFuzz
)
;
if
(
nextSample
)
{
trackData
.
mNextSampleTimecode
=
TimeUnit
:
:
FromMicroseconds
(
nextSample
-
>
mTimecode
)
;
trackData
.
mNextSampleTime
=
TimeUnit
:
:
FromMicroseconds
(
nextSample
-
>
mTime
)
;
}
else
{
trackData
.
mNextSampleTimecode
=
nextSampleTimecode
;
trackData
.
mNextSampleTime
=
nextSampleTime
;
}
aResult
=
NS_OK
;
return
p
.
forget
(
)
;
}
if
(
trackData
.
mNextSampleTimecode
.
ToMicroseconds
(
)
>
track
.
LastElement
(
)
-
>
mTimecode
+
track
.
LastElement
(
)
-
>
mDuration
)
{
trackData
.
mNextGetSampleIndex
=
Some
(
uint32_t
(
track
.
Length
(
)
)
)
;
aResult
=
NS_ERROR_DOM_MEDIA_END_OF_STREAM
;
return
nullptr
;
}
int32_t
pos
=
FindCurrentPosition
(
aTrack
aFuzz
)
;
if
(
pos
<
0
)
{
MSE_DEBUG
(
"
Couldn
'
t
find
sample
(
pts
:
%
lld
dts
:
%
lld
)
"
trackData
.
mNextSampleTime
.
ToMicroseconds
(
)
trackData
.
mNextSampleTimecode
.
ToMicroseconds
(
)
)
;
return
nullptr
;
}
const
RefPtr
<
MediaRawData
>
&
sample
=
track
[
pos
]
;
RefPtr
<
MediaRawData
>
p
=
sample
-
>
Clone
(
)
;
if
(
!
p
)
{
aResult
=
MediaResult
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
return
nullptr
;
}
int32_t
i
=
pos
;
for
(
;
!
track
[
i
]
-
>
mKeyframe
;
i
-
-
)
{
}
UpdateEvictionIndex
(
trackData
i
)
;
trackData
.
mNextGetSampleIndex
=
Some
(
uint32_t
(
pos
)
+
1
)
;
trackData
.
mNextSampleTimecode
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
+
sample
-
>
mDuration
)
;
trackData
.
mNextSampleTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
;
aResult
=
NS_OK
;
return
p
.
forget
(
)
;
}
int32_t
TrackBuffersManager
:
:
FindCurrentPosition
(
TrackInfo
:
:
TrackType
aTrack
const
TimeUnit
&
aFuzz
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
auto
&
trackData
=
GetTracksData
(
aTrack
)
;
const
TrackBuffer
&
track
=
GetTrackBuffer
(
aTrack
)
;
for
(
uint32_t
i
=
0
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
track
[
i
]
;
TimeInterval
sampleInterval
{
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
)
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
+
sample
-
>
mDuration
)
}
;
if
(
sampleInterval
.
ContainsStrict
(
trackData
.
mNextSampleTimecode
)
)
{
return
i
;
}
if
(
sampleInterval
.
mStart
>
trackData
.
mNextSampleTimecode
)
{
break
;
}
}
for
(
uint32_t
i
=
0
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
track
[
i
]
;
TimeInterval
sampleInterval
{
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
)
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
+
sample
-
>
mDuration
)
aFuzz
}
;
if
(
sampleInterval
.
ContainsWithStrictEnd
(
trackData
.
mNextSampleTimecode
)
)
{
return
i
;
}
if
(
sampleInterval
.
mStart
-
aFuzz
>
trackData
.
mNextSampleTimecode
)
{
break
;
}
}
for
(
uint32_t
i
=
0
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
const
RefPtr
<
MediaRawData
>
&
sample
=
track
[
i
]
;
TimeInterval
sampleInterval
{
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
aFuzz
}
;
if
(
sampleInterval
.
ContainsWithStrictEnd
(
trackData
.
mNextSampleTimecode
)
)
{
return
i
;
}
}
return
-
1
;
}
uint32_t
TrackBuffersManager
:
:
Evictable
(
TrackInfo
:
:
TrackType
aTrack
)
const
{
MonitorAutoLock
mon
(
mMonitor
)
;
return
GetTracksData
(
aTrack
)
.
mEvictionIndex
.
mEvictable
;
}
TimeUnit
TrackBuffersManager
:
:
GetNextRandomAccessPoint
(
TrackInfo
:
:
TrackType
aTrack
const
TimeUnit
&
aFuzz
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
auto
&
trackData
=
GetTracksData
(
aTrack
)
;
MOZ_ASSERT
(
trackData
.
mNextGetSampleIndex
.
isSome
(
)
)
;
const
TrackBuffersManager
:
:
TrackBuffer
&
track
=
GetTrackBuffer
(
aTrack
)
;
uint32_t
i
=
trackData
.
mNextGetSampleIndex
.
ref
(
)
;
TimeUnit
nextSampleTimecode
=
trackData
.
mNextSampleTimecode
;
TimeUnit
nextSampleTime
=
trackData
.
mNextSampleTime
;
for
(
;
i
<
track
.
Length
(
)
;
i
+
+
)
{
const
MediaRawData
*
sample
=
GetSample
(
aTrack
i
nextSampleTimecode
nextSampleTime
aFuzz
)
;
if
(
!
sample
)
{
break
;
}
if
(
sample
-
>
mKeyframe
)
{
return
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTime
)
;
}
nextSampleTimecode
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
mTimecode
+
sample
-
>
mDuration
)
;
nextSampleTime
=
TimeUnit
:
:
FromMicroseconds
(
sample
-
>
GetEndTime
(
)
)
;
}
return
TimeUnit
:
:
FromInfinity
(
)
;
}
void
TrackBuffersManager
:
:
TrackData
:
:
AddSizeOfResources
(
MediaSourceDecoder
:
:
ResourceSizes
*
aSizes
)
{
for
(
TrackBuffer
&
buffer
:
mBuffers
)
{
for
(
MediaRawData
*
data
:
buffer
)
{
aSizes
-
>
mByteSize
+
=
data
-
>
SizeOfIncludingThis
(
aSizes
-
>
mMallocSizeOf
)
;
}
}
}
void
TrackBuffersManager
:
:
AddSizeOfResources
(
MediaSourceDecoder
:
:
ResourceSizes
*
aSizes
)
{
MOZ_ASSERT
(
OnTaskQueue
(
)
)
;
mVideoTracks
.
AddSizeOfResources
(
aSizes
)
;
mAudioTracks
.
AddSizeOfResources
(
aSizes
)
;
}
}
#
undef
MSE_DEBUG
#
undef
MSE_DEBUGV
#
undef
SAMPLE_DEBUG
