#
if
!
defined
(
MediaSourceDemuxer_h_
)
#
define
MediaSourceDemuxer_h_
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
MediaDataDemuxer
.
h
"
#
include
"
MediaDecoderReader
.
h
"
#
include
"
MediaResource
.
h
"
#
include
"
MediaSource
.
h
"
#
include
"
TrackBuffersManager
.
h
"
namespace
mozilla
{
class
MediaSourceTrackDemuxer
;
class
MediaSourceDemuxer
:
public
MediaDataDemuxer
{
public
:
explicit
MediaSourceDemuxer
(
)
;
RefPtr
<
InitPromise
>
Init
(
)
override
;
bool
HasTrackType
(
TrackInfo
:
:
TrackType
aType
)
const
override
;
uint32_t
GetNumberTracks
(
TrackInfo
:
:
TrackType
aType
)
const
override
;
already_AddRefed
<
MediaTrackDemuxer
>
GetTrackDemuxer
(
TrackInfo
:
:
TrackType
aType
uint32_t
aTrackNumber
)
override
;
bool
IsSeekable
(
)
const
override
;
UniquePtr
<
EncryptionInfo
>
GetCrypto
(
)
override
;
bool
ShouldComputeStartTime
(
)
const
override
{
return
false
;
}
void
NotifyDataArrived
(
uint32_t
aLength
int64_t
aOffset
)
override
;
void
AttachSourceBuffer
(
TrackBuffersManager
*
aSourceBuffer
)
;
void
DetachSourceBuffer
(
TrackBuffersManager
*
aSourceBuffer
)
;
TaskQueue
*
GetTaskQueue
(
)
{
return
mTaskQueue
;
}
void
GetMozDebugReaderData
(
nsAString
&
aString
)
;
private
:
~
MediaSourceDemuxer
(
)
;
friend
class
MediaSourceTrackDemuxer
;
bool
ScanSourceBuffersForContent
(
)
;
RefPtr
<
InitPromise
>
AttemptInit
(
)
;
TrackBuffersManager
*
GetManager
(
TrackInfo
:
:
TrackType
aType
)
;
TrackInfo
*
GetTrackInfo
(
TrackInfo
:
:
TrackType
)
;
void
DoAttachSourceBuffer
(
TrackBuffersManager
*
aSourceBuffer
)
;
void
DoDetachSourceBuffer
(
TrackBuffersManager
*
aSourceBuffer
)
;
bool
OnTaskQueue
(
)
{
return
!
GetTaskQueue
(
)
|
|
GetTaskQueue
(
)
-
>
IsCurrentThreadIn
(
)
;
}
RefPtr
<
TaskQueue
>
mTaskQueue
;
nsTArray
<
RefPtr
<
MediaSourceTrackDemuxer
>
>
mDemuxers
;
nsTArray
<
RefPtr
<
TrackBuffersManager
>
>
mSourceBuffers
;
MozPromiseHolder
<
InitPromise
>
mInitPromise
;
mutable
Monitor
mMonitor
;
RefPtr
<
TrackBuffersManager
>
mAudioTrack
;
RefPtr
<
TrackBuffersManager
>
mVideoTrack
;
MediaInfo
mInfo
;
}
;
class
MediaSourceTrackDemuxer
:
public
MediaTrackDemuxer
{
public
:
MediaSourceTrackDemuxer
(
MediaSourceDemuxer
*
aParent
TrackInfo
:
:
TrackType
aType
TrackBuffersManager
*
aManager
)
;
UniquePtr
<
TrackInfo
>
GetInfo
(
)
const
override
;
RefPtr
<
SeekPromise
>
Seek
(
media
:
:
TimeUnit
aTime
)
override
;
RefPtr
<
SamplesPromise
>
GetSamples
(
int32_t
aNumSamples
=
1
)
override
;
void
Reset
(
)
override
;
nsresult
GetNextRandomAccessPoint
(
media
:
:
TimeUnit
*
aTime
)
override
;
RefPtr
<
SkipAccessPointPromise
>
SkipToNextRandomAccessPoint
(
media
:
:
TimeUnit
aTimeThreshold
)
override
;
media
:
:
TimeIntervals
GetBuffered
(
)
override
;
void
BreakCycles
(
)
override
;
bool
GetSamplesMayBlock
(
)
const
override
{
return
false
;
}
private
:
RefPtr
<
SeekPromise
>
DoSeek
(
media
:
:
TimeUnit
aTime
)
;
RefPtr
<
SamplesPromise
>
DoGetSamples
(
int32_t
aNumSamples
)
;
RefPtr
<
SkipAccessPointPromise
>
DoSkipToNextRandomAccessPoint
(
media
:
:
TimeUnit
aTimeThreadshold
)
;
already_AddRefed
<
MediaRawData
>
GetSample
(
DemuxerFailureReason
&
aFailure
)
;
media
:
:
TimeUnit
GetNextRandomAccessPoint
(
)
;
RefPtr
<
MediaSourceDemuxer
>
mParent
;
RefPtr
<
TrackBuffersManager
>
mManager
;
TrackInfo
:
:
TrackType
mType
;
Monitor
mMonitor
;
media
:
:
TimeUnit
mNextRandomAccessPoint
;
}
;
}
#
endif
