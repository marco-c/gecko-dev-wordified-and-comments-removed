#
include
"
MediaRecorder
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeStream
.
h
"
#
include
"
DOMMediaStream
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
MediaDecoder
.
h
"
#
include
"
MediaEncoder
.
h
"
#
include
"
MediaStreamGraphImpl
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
dom
/
AudioStreamTrack
.
h
"
#
include
"
mozilla
/
dom
/
BlobEvent
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
MediaRecorderErrorEvent
.
h
"
#
include
"
mozilla
/
dom
/
MutableBlobStorage
.
h
"
#
include
"
mozilla
/
dom
/
VideoStreamTrack
.
h
"
#
include
"
mozilla
/
media
/
MediaUtils
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsContentTypeParser
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsError
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsTArray
.
h
"
#
ifdef
LOG
#
undef
LOG
#
endif
mozilla
:
:
LazyLogModule
gMediaRecorderLog
(
"
MediaRecorder
"
)
;
#
define
LOG
(
type
msg
)
MOZ_LOG
(
gMediaRecorderLog
type
msg
)
namespace
mozilla
{
namespace
dom
{
using
namespace
mozilla
:
:
media
;
StaticRefPtr
<
nsIAsyncShutdownBlocker
>
gMediaRecorderShutdownBlocker
;
static
nsTHashtable
<
nsRefPtrHashKey
<
MediaRecorder
:
:
Session
>
>
gSessions
;
class
MediaRecorderReporter
final
:
public
nsIMemoryReporter
{
public
:
static
void
AddMediaRecorder
(
MediaRecorder
*
aRecorder
)
{
if
(
!
sUniqueInstance
)
{
sUniqueInstance
=
MakeAndAddRef
<
MediaRecorderReporter
>
(
)
;
RegisterWeakAsyncMemoryReporter
(
sUniqueInstance
)
;
}
sUniqueInstance
-
>
mRecorders
.
AppendElement
(
aRecorder
)
;
}
static
void
RemoveMediaRecorder
(
MediaRecorder
*
aRecorder
)
{
if
(
!
sUniqueInstance
)
{
return
;
}
sUniqueInstance
-
>
mRecorders
.
RemoveElement
(
aRecorder
)
;
if
(
sUniqueInstance
-
>
mRecorders
.
IsEmpty
(
)
)
{
UnregisterWeakMemoryReporter
(
sUniqueInstance
)
;
sUniqueInstance
=
nullptr
;
}
}
NS_DECL_THREADSAFE_ISUPPORTS
MediaRecorderReporter
(
)
=
default
;
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
nsTArray
<
RefPtr
<
MediaRecorder
:
:
SizeOfPromise
>
>
promises
;
for
(
const
RefPtr
<
MediaRecorder
>
&
recorder
:
mRecorders
)
{
promises
.
AppendElement
(
recorder
-
>
SizeOfExcludingThis
(
MallocSizeOf
)
)
;
}
nsCOMPtr
<
nsIHandleReportCallback
>
handleReport
=
aHandleReport
;
nsCOMPtr
<
nsISupports
>
data
=
aData
;
MediaRecorder
:
:
SizeOfPromise
:
:
All
(
GetCurrentThreadSerialEventTarget
(
)
promises
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
handleReport
data
]
(
const
nsTArray
<
size_t
>
&
sizes
)
{
nsCOMPtr
<
nsIMemoryReporterManager
>
manager
=
do_GetService
(
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
)
;
if
(
!
manager
)
{
return
;
}
size_t
sum
=
0
;
for
(
const
size_t
&
size
:
sizes
)
{
sum
+
=
size
;
}
handleReport
-
>
Callback
(
EmptyCString
(
)
NS_LITERAL_CSTRING
(
"
explicit
/
media
/
recorder
"
)
KIND_HEAP
UNITS_BYTES
sum
NS_LITERAL_CSTRING
(
"
Memory
used
by
media
recorder
.
"
)
data
)
;
manager
-
>
EndReport
(
)
;
}
[
]
(
size_t
)
{
MOZ_CRASH
(
"
Unexpected
reject
"
)
;
}
)
;
return
NS_OK
;
}
private
:
MOZ_DEFINE_MALLOC_SIZE_OF
(
MallocSizeOf
)
virtual
~
MediaRecorderReporter
(
)
{
MOZ_ASSERT
(
mRecorders
.
IsEmpty
(
)
"
All
recorders
must
have
been
removed
"
)
;
}
static
StaticRefPtr
<
MediaRecorderReporter
>
sUniqueInstance
;
nsTArray
<
RefPtr
<
MediaRecorder
>
>
mRecorders
;
}
;
NS_IMPL_ISUPPORTS
(
MediaRecorderReporter
nsIMemoryReporter
)
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
MediaRecorder
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
MediaRecorder
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDOMStream
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAudioNode
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSecurityDomException
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mUnknownDomException
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocument
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
MediaRecorder
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDOMStream
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAudioNode
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSecurityDomException
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mUnknownDomException
)
tmp
-
>
UnRegisterActivityObserver
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocument
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
MediaRecorder
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentActivity
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
NS_IMPL_ADDREF_INHERITED
(
MediaRecorder
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
MediaRecorder
DOMEventTargetHelper
)
class
MediaRecorder
:
:
Session
:
public
PrincipalChangeObserver
<
MediaStreamTrack
>
public
DOMMediaStream
:
:
TrackListener
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Session
)
class
PushBlobRunnable
:
public
Runnable
public
MutableBlobStorageCallback
{
public
:
NS_DECL_ISUPPORTS_INHERITED
PushBlobRunnable
(
Session
*
aSession
Runnable
*
aDestroyRunnable
)
:
Runnable
(
"
dom
:
:
MediaRecorder
:
:
Session
:
:
PushBlobRunnable
"
)
mSession
(
aSession
)
mDestroyRunnable
(
aDestroyRunnable
)
{
}
NS_IMETHOD
Run
(
)
override
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
PushBlobRunnable
s
=
(
%
p
)
"
mSession
.
get
(
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mSession
-
>
GetBlobWhenReady
(
this
)
;
return
NS_OK
;
}
void
BlobStoreCompleted
(
MutableBlobStorage
*
aBlobStorage
Blob
*
aBlob
nsresult
aRv
)
override
{
RefPtr
<
MediaRecorder
>
recorder
=
mSession
-
>
mRecorder
;
if
(
!
recorder
)
{
return
;
}
if
(
NS_FAILED
(
aRv
)
)
{
mSession
-
>
DoSessionEndTask
(
aRv
)
;
return
;
}
nsresult
rv
=
recorder
-
>
CreateAndDispatchBlobEvent
(
aBlob
)
;
if
(
NS_FAILED
(
rv
)
)
{
mSession
-
>
DoSessionEndTask
(
aRv
)
;
}
if
(
mDestroyRunnable
&
&
NS_FAILED
(
NS_DispatchToMainThread
(
mDestroyRunnable
.
forget
(
)
)
)
)
{
MOZ_ASSERT
(
false
"
NS_DispatchToMainThread
failed
"
)
;
}
}
private
:
~
PushBlobRunnable
(
)
=
default
;
RefPtr
<
Session
>
mSession
;
RefPtr
<
Runnable
>
mDestroyRunnable
;
}
;
class
StoreEncodedBufferRunnable
final
:
public
Runnable
{
RefPtr
<
Session
>
mSession
;
nsTArray
<
nsTArray
<
uint8_t
>
>
mBuffer
;
public
:
StoreEncodedBufferRunnable
(
Session
*
aSession
nsTArray
<
nsTArray
<
uint8_t
>
>
&
&
aBuffer
)
:
Runnable
(
"
StoreEncodedBufferRunnable
"
)
mSession
(
aSession
)
mBuffer
(
std
:
:
move
(
aBuffer
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mSession
-
>
MaybeCreateMutableBlobStorage
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mBuffer
.
Length
(
)
;
i
+
+
)
{
if
(
mBuffer
[
i
]
.
IsEmpty
(
)
)
{
continue
;
}
nsresult
rv
=
mSession
-
>
mMutableBlobStorage
-
>
Append
(
mBuffer
[
i
]
.
Elements
(
)
mBuffer
[
i
]
.
Length
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mSession
-
>
DoSessionEndTask
(
rv
)
;
break
;
}
}
return
NS_OK
;
}
}
;
class
EncoderErrorNotifierRunnable
:
public
Runnable
{
public
:
explicit
EncoderErrorNotifierRunnable
(
Session
*
aSession
)
:
Runnable
(
"
dom
:
:
MediaRecorder
:
:
Session
:
:
EncoderErrorNotifierRunnable
"
)
mSession
(
aSession
)
{
}
NS_IMETHOD
Run
(
)
override
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
ErrorNotifyRunnable
s
=
(
%
p
)
"
mSession
.
get
(
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
MediaRecorder
>
recorder
=
mSession
-
>
mRecorder
;
if
(
!
recorder
)
{
return
NS_OK
;
}
recorder
-
>
NotifyError
(
NS_ERROR_UNEXPECTED
)
;
return
NS_OK
;
}
private
:
RefPtr
<
Session
>
mSession
;
}
;
class
DispatchEventRunnable
:
public
Runnable
{
public
:
explicit
DispatchEventRunnable
(
Session
*
aSession
const
nsAString
&
aEventName
)
:
Runnable
(
"
dom
:
:
MediaRecorder
:
:
Session
:
:
DispatchEventRunnable
"
)
mSession
(
aSession
)
mEventName
(
aEventName
)
{
}
NS_IMETHOD
Run
(
)
override
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
DispatchEventRunnable
s
=
(
%
p
)
e
=
(
%
s
)
"
mSession
.
get
(
)
NS_ConvertUTF16toUTF8
(
mEventName
)
.
get
(
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_TRUE
(
mSession
-
>
mRecorder
NS_OK
)
;
mSession
-
>
mRecorder
-
>
DispatchSimpleEvent
(
mEventName
)
;
return
NS_OK
;
}
private
:
RefPtr
<
Session
>
mSession
;
nsString
mEventName
;
}
;
class
DestroyRunnable
:
public
Runnable
{
public
:
explicit
DestroyRunnable
(
Session
*
aSession
)
:
Runnable
(
"
dom
:
:
MediaRecorder
:
:
Session
:
:
DestroyRunnable
"
)
mSession
(
aSession
)
{
}
explicit
DestroyRunnable
(
already_AddRefed
<
Session
>
aSession
)
:
Runnable
(
"
dom
:
:
MediaRecorder
:
:
Session
:
:
DestroyRunnable
"
)
mSession
(
aSession
)
{
}
NS_IMETHOD
Run
(
)
override
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
DestroyRunnable
session
refcnt
=
(
%
d
)
s
=
(
%
p
)
"
static_cast
<
int
>
(
mSession
-
>
mRefCnt
)
mSession
.
get
(
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
&
&
mSession
)
;
RefPtr
<
MediaRecorder
>
recorder
=
mSession
-
>
mRecorder
;
if
(
!
recorder
)
{
return
NS_OK
;
}
if
(
mSession
-
>
mRunningState
.
isOk
(
)
&
&
mSession
-
>
mRunningState
.
unwrap
(
)
!
=
RunningState
:
:
Stopping
&
&
mSession
-
>
mRunningState
.
unwrap
(
)
!
=
RunningState
:
:
Stopped
)
{
recorder
-
>
StopForSessionDestruction
(
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
new
DestroyRunnable
(
mSession
.
forget
(
)
)
)
)
)
{
MOZ_ASSERT
(
false
"
NS_DispatchToMainThread
failed
"
)
;
}
return
NS_OK
;
}
if
(
mSession
-
>
mRunningState
.
isOk
(
)
)
{
mSession
-
>
mRunningState
=
RunningState
:
:
Stopped
;
}
mSession
-
>
mMimeType
=
NS_LITERAL_STRING
(
"
"
)
;
recorder
-
>
SetMimeType
(
mSession
-
>
mMimeType
)
;
recorder
-
>
DispatchSimpleEvent
(
NS_LITERAL_STRING
(
"
stop
"
)
)
;
RefPtr
<
Session
>
session
=
mSession
.
forget
(
)
;
session
-
>
Shutdown
(
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
session
]
(
)
{
gSessions
.
RemoveEntry
(
session
)
;
if
(
gSessions
.
Count
(
)
=
=
0
&
&
gMediaRecorderShutdownBlocker
)
{
RefPtr
<
nsIAsyncShutdownClient
>
barrier
=
GetShutdownBarrier
(
)
;
barrier
-
>
RemoveBlocker
(
gMediaRecorderShutdownBlocker
)
;
gMediaRecorderShutdownBlocker
=
nullptr
;
}
}
[
]
(
)
{
MOZ_CRASH
(
"
Not
reached
"
)
;
}
)
;
return
NS_OK
;
}
private
:
RefPtr
<
Session
>
mSession
;
}
;
class
EncoderListener
:
public
MediaEncoderListener
{
public
:
EncoderListener
(
TaskQueue
*
aEncoderThread
Session
*
aSession
)
:
mEncoderThread
(
aEncoderThread
)
mSession
(
aSession
)
{
}
void
Forget
(
)
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
mSession
=
nullptr
;
}
void
Initialized
(
)
override
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
if
(
mSession
)
{
mSession
-
>
MediaEncoderInitialized
(
)
;
}
}
void
DataAvailable
(
)
override
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
if
(
mSession
)
{
mSession
-
>
MediaEncoderDataAvailable
(
)
;
}
}
void
Error
(
)
override
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
if
(
mSession
)
{
mSession
-
>
MediaEncoderError
(
)
;
}
}
void
Shutdown
(
)
override
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
if
(
mSession
)
{
mSession
-
>
MediaEncoderShutdown
(
)
;
}
}
protected
:
RefPtr
<
TaskQueue
>
mEncoderThread
;
RefPtr
<
Session
>
mSession
;
}
;
friend
class
EncoderErrorNotifierRunnable
;
friend
class
PushBlobRunnable
;
friend
class
DestroyRunnable
;
public
:
Session
(
MediaRecorder
*
aRecorder
int32_t
aTimeSlice
)
:
mRecorder
(
aRecorder
)
mMediaStreamReady
(
false
)
mTimeSlice
(
aTimeSlice
)
mRunningState
(
RunningState
:
:
Idling
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMaxMemory
=
Preferences
:
:
GetUint
(
"
media
.
recorder
.
max_memory
"
MAX_ALLOW_MEMORY_BUFFER
)
;
mLastBlobTimeStamp
=
TimeStamp
:
:
Now
(
)
;
}
void
PrincipalChanged
(
MediaStreamTrack
*
aTrack
)
override
{
NS_ASSERTION
(
mMediaStreamTracks
.
Contains
(
aTrack
)
"
Principal
changed
for
unrecorded
track
"
)
;
if
(
!
MediaStreamTracksPrincipalSubsumes
(
)
)
{
DoSessionEndTask
(
NS_ERROR_DOM_SECURITY_ERR
)
;
}
}
void
NotifyTrackAdded
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
override
{
LOG
(
LogLevel
:
:
Warning
(
"
Session
.
NotifyTrackAdded
%
p
Raising
error
due
to
track
set
change
"
this
)
)
;
if
(
mMediaStreamReady
)
{
DoSessionEndTask
(
NS_ERROR_ABORT
)
;
}
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
MediaRecorder
:
:
Session
:
:
MediaStreamReady
"
this
&
Session
:
:
MediaStreamReady
)
)
;
return
;
}
void
NotifyTrackRemoved
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
override
{
if
(
!
mMediaStreamReady
)
{
return
;
}
if
(
aTrack
-
>
Ended
(
)
)
{
return
;
}
MOZ_ASSERT
(
mEncoder
)
;
if
(
mEncoder
)
{
mEncoder
-
>
RemoveMediaStreamTrack
(
aTrack
)
;
}
LOG
(
LogLevel
:
:
Warning
(
"
Session
.
NotifyTrackRemoved
%
p
Raising
error
due
to
track
set
change
"
this
)
)
;
DoSessionEndTask
(
NS_ERROR_ABORT
)
;
}
void
Start
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Start
%
p
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
DOMMediaStream
*
domStream
=
mRecorder
-
>
Stream
(
)
;
if
(
domStream
)
{
mMediaStream
=
domStream
;
mMediaStream
-
>
RegisterTrackListener
(
this
)
;
nsTArray
<
RefPtr
<
MediaStreamTrack
>
>
tracks
(
2
)
;
mMediaStream
-
>
GetTracks
(
tracks
)
;
for
(
const
auto
&
track
:
tracks
)
{
NotifyTrackAdded
(
track
)
;
}
return
;
}
if
(
mRecorder
-
>
mAudioNode
)
{
if
(
!
AudioNodePrincipalSubsumes
(
)
)
{
LOG
(
LogLevel
:
:
Warning
(
"
Session
.
Start
AudioNode
principal
check
failed
"
)
)
;
DoSessionEndTask
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
TrackRate
trackRate
=
mRecorder
-
>
mAudioNode
-
>
Context
(
)
-
>
Graph
(
)
-
>
GraphRate
(
)
;
InitEncoder
(
ContainerWriter
:
:
CREATE_AUDIO_TRACK
trackRate
)
;
return
;
}
MOZ_ASSERT
(
false
"
Unknown
source
"
)
;
}
void
Stop
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Stop
%
p
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mEncoder
)
{
mEncoder
-
>
Stop
(
)
;
}
if
(
mRunningState
.
isOk
(
)
&
&
mRunningState
.
unwrap
(
)
=
=
RunningState
:
:
Idling
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Stop
Explicit
end
task
%
p
"
this
)
)
;
DoSessionEndTask
(
NS_OK
)
;
}
else
if
(
mRunningState
.
isOk
(
)
&
&
(
mRunningState
.
unwrap
(
)
=
=
RunningState
:
:
Starting
|
|
mRunningState
.
unwrap
(
)
=
=
RunningState
:
:
Running
)
)
{
mRunningState
=
RunningState
:
:
Stopping
;
}
}
nsresult
Pause
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Pause
"
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mEncoder
)
{
return
NS_ERROR_FAILURE
;
}
mEncoder
-
>
Suspend
(
)
;
NS_DispatchToMainThread
(
new
DispatchEventRunnable
(
this
NS_LITERAL_STRING
(
"
pause
"
)
)
)
;
return
NS_OK
;
}
nsresult
Resume
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Resume
"
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mEncoder
)
{
return
NS_ERROR_FAILURE
;
}
mEncoder
-
>
Resume
(
)
;
NS_DispatchToMainThread
(
new
DispatchEventRunnable
(
this
NS_LITERAL_STRING
(
"
resume
"
)
)
)
;
return
NS_OK
;
}
nsresult
RequestData
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
RequestData
"
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
new
PushBlobRunnable
(
this
nullptr
)
)
)
)
{
MOZ_ASSERT
(
false
"
RequestData
NS_DispatchToMainThread
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
MaybeCreateMutableBlobStorage
(
)
{
if
(
!
mMutableBlobStorage
)
{
mMutableBlobStorage
=
new
MutableBlobStorage
(
MutableBlobStorage
:
:
eCouldBeInTemporaryFile
nullptr
mMaxMemory
)
;
}
}
void
GetBlobWhenReady
(
MutableBlobStorageCallback
*
aCallback
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MaybeCreateMutableBlobStorage
(
)
;
mMutableBlobStorage
-
>
GetBlobWhenReady
(
mRecorder
-
>
GetParentObject
(
)
NS_ConvertUTF16toUTF8
(
mMimeType
)
aCallback
)
;
mMutableBlobStorage
=
nullptr
;
}
RefPtr
<
SizeOfPromise
>
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
size_t
encodedBufferSize
=
mMutableBlobStorage
?
mMutableBlobStorage
-
>
SizeOfCurrentMemoryBuffer
(
)
:
0
;
if
(
!
mEncoder
)
{
return
SizeOfPromise
:
:
CreateAndResolve
(
encodedBufferSize
__func__
)
;
}
auto
&
encoder
=
mEncoder
;
return
InvokeAsync
(
mEncoderThread
__func__
[
encoder
encodedBufferSize
aMallocSizeOf
]
(
)
{
return
SizeOfPromise
:
:
CreateAndResolve
(
encodedBufferSize
+
encoder
-
>
SizeOfExcludingThis
(
aMallocSizeOf
)
__func__
)
;
}
)
;
}
private
:
virtual
~
Session
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mShutdownPromise
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
~
Session
(
%
p
)
"
this
)
)
;
}
void
Extract
(
bool
aForceFlush
Runnable
*
aDestroyRunnable
)
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Extract
%
p
"
this
)
)
;
AUTO_PROFILER_LABEL
(
"
MediaRecorder
:
:
Session
:
:
Extract
"
OTHER
)
;
nsTArray
<
nsTArray
<
uint8_t
>
>
encodedBuf
;
nsresult
rv
=
mEncoder
-
>
GetEncodedData
(
&
encodedBuf
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_RELEASE_ASSERT
(
encodedBuf
.
IsEmpty
(
)
)
;
}
NS_DispatchToMainThread
(
new
StoreEncodedBufferRunnable
(
this
std
:
:
move
(
encodedBuf
)
)
)
;
bool
pushBlob
=
aForceFlush
;
if
(
!
pushBlob
&
&
mTimeSlice
>
0
&
&
(
TimeStamp
:
:
Now
(
)
-
mLastBlobTimeStamp
)
.
ToMilliseconds
(
)
>
mTimeSlice
)
{
pushBlob
=
true
;
}
if
(
pushBlob
)
{
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
new
PushBlobRunnable
(
this
aDestroyRunnable
)
)
)
)
{
MOZ_ASSERT
(
false
"
NS_DispatchToMainThread
PushBlobRunnable
failed
"
)
;
}
else
{
mLastBlobTimeStamp
=
TimeStamp
:
:
Now
(
)
;
}
}
else
if
(
aDestroyRunnable
)
{
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
aDestroyRunnable
)
)
)
{
MOZ_ASSERT
(
false
"
NS_DispatchToMainThread
DestroyRunnable
failed
"
)
;
}
}
}
void
MediaStreamReady
(
)
{
if
(
!
mMediaStream
)
{
return
;
}
if
(
mMediaStreamReady
)
{
return
;
}
if
(
!
mRunningState
.
isOk
(
)
|
|
mRunningState
.
unwrap
(
)
!
=
RunningState
:
:
Idling
)
{
return
;
}
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
MediaStreamTrack
>
>
tracks
;
mMediaStream
-
>
GetTracks
(
tracks
)
;
uint8_t
trackTypes
=
0
;
int32_t
audioTracks
=
0
;
int32_t
videoTracks
=
0
;
for
(
auto
&
track
:
tracks
)
{
if
(
track
-
>
Ended
(
)
)
{
continue
;
}
ConnectMediaStreamTrack
(
*
track
)
;
if
(
track
-
>
AsAudioStreamTrack
(
)
)
{
+
+
audioTracks
;
trackTypes
|
=
ContainerWriter
:
:
CREATE_AUDIO_TRACK
;
}
else
if
(
track
-
>
AsVideoStreamTrack
(
)
)
{
+
+
videoTracks
;
trackTypes
|
=
ContainerWriter
:
:
CREATE_VIDEO_TRACK
;
}
else
{
MOZ_CRASH
(
"
Unexpected
track
type
"
)
;
}
}
if
(
trackTypes
=
=
0
)
{
MOZ_ASSERT
(
audioTracks
=
=
0
)
;
MOZ_ASSERT
(
videoTracks
=
=
0
)
;
return
;
}
mMediaStreamReady
=
true
;
if
(
audioTracks
>
1
|
|
videoTracks
>
1
)
{
nsPIDOMWindowInner
*
window
=
mRecorder
-
>
GetParentObject
(
)
;
Document
*
document
=
window
?
window
-
>
GetExtantDoc
(
)
:
nullptr
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
NS_LITERAL_CSTRING
(
"
Media
"
)
document
nsContentUtils
:
:
eDOM_PROPERTIES
"
MediaRecorderMultiTracksNotSupported
"
)
;
DoSessionEndTask
(
NS_ERROR_ABORT
)
;
return
;
}
if
(
!
MediaStreamTracksPrincipalSubsumes
(
)
)
{
LOG
(
LogLevel
:
:
Warning
(
"
Session
.
MediaTracksReady
MediaStreamTracks
"
"
principal
check
failed
"
)
)
;
DoSessionEndTask
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
MediaTracksReady
track
type
=
(
%
d
)
"
trackTypes
)
)
;
InitEncoder
(
trackTypes
mMediaStream
-
>
GraphRate
(
)
)
;
}
void
ConnectMediaStreamTrack
(
MediaStreamTrack
&
aTrack
)
{
for
(
auto
&
track
:
mMediaStreamTracks
)
{
if
(
track
-
>
AsAudioStreamTrack
(
)
&
&
aTrack
.
AsAudioStreamTrack
(
)
)
{
return
;
}
if
(
track
-
>
AsVideoStreamTrack
(
)
&
&
aTrack
.
AsVideoStreamTrack
(
)
)
{
return
;
}
}
mMediaStreamTracks
.
AppendElement
(
&
aTrack
)
;
aTrack
.
AddPrincipalChangeObserver
(
this
)
;
}
bool
PrincipalSubsumes
(
nsIPrincipal
*
aPrincipal
)
{
if
(
!
mRecorder
-
>
GetOwner
(
)
)
return
false
;
nsCOMPtr
<
Document
>
doc
=
mRecorder
-
>
GetOwner
(
)
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
false
;
}
if
(
!
aPrincipal
)
{
return
false
;
}
bool
subsumes
;
if
(
NS_FAILED
(
doc
-
>
NodePrincipal
(
)
-
>
Subsumes
(
aPrincipal
&
subsumes
)
)
)
{
return
false
;
}
return
subsumes
;
}
bool
MediaStreamTracksPrincipalSubsumes
(
)
{
MOZ_ASSERT
(
mRecorder
-
>
mDOMStream
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
nullptr
;
for
(
RefPtr
<
MediaStreamTrack
>
&
track
:
mMediaStreamTracks
)
{
nsContentUtils
:
:
CombineResourcePrincipals
(
&
principal
track
-
>
GetPrincipal
(
)
)
;
}
return
PrincipalSubsumes
(
principal
)
;
}
bool
AudioNodePrincipalSubsumes
(
)
{
MOZ_ASSERT
(
mRecorder
-
>
mAudioNode
)
;
Document
*
doc
=
mRecorder
-
>
mAudioNode
-
>
GetOwner
(
)
?
mRecorder
-
>
mAudioNode
-
>
GetOwner
(
)
-
>
GetExtantDoc
(
)
:
nullptr
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
doc
?
doc
-
>
NodePrincipal
(
)
:
nullptr
;
return
PrincipalSubsumes
(
principal
)
;
}
void
InitEncoder
(
uint8_t
aTrackTypes
TrackRate
aTrackRate
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
InitEncoder
%
p
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mRunningState
.
isOk
(
)
|
|
mRunningState
.
unwrap
(
)
!
=
RunningState
:
:
Idling
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Double
-
init
"
)
;
return
;
}
MOZ_RELEASE_ASSERT
(
!
mEncoderThread
)
;
RefPtr
<
SharedThreadPool
>
pool
=
GetMediaThreadPool
(
MediaThreadType
:
:
WEBRTC_DECODER
)
;
if
(
!
pool
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
InitEncoder
%
p
Failed
to
create
"
"
MediaRecorderReadThread
thread
pool
"
this
)
)
;
DoSessionEndTask
(
NS_ERROR_FAILURE
)
;
return
;
}
mEncoderThread
=
MakeAndAddRef
<
TaskQueue
>
(
pool
.
forget
(
)
"
MediaRecorderReadThread
"
)
;
if
(
!
gMediaRecorderShutdownBlocker
)
{
class
Blocker
:
public
ShutdownBlocker
{
public
:
Blocker
(
)
:
ShutdownBlocker
(
NS_LITERAL_STRING
(
"
MediaRecorder
:
:
Session
:
shutdown
"
)
)
{
}
NS_IMETHOD
BlockShutdown
(
nsIAsyncShutdownClient
*
)
override
{
RefPtr
<
ShutdownTicket
>
ticket
=
MakeAndAddRef
<
ShutdownTicket
>
(
gMediaRecorderShutdownBlocker
)
;
gMediaRecorderShutdownBlocker
=
nullptr
;
nsTArray
<
RefPtr
<
ShutdownPromise
>
>
promises
(
gSessions
.
Count
(
)
)
;
for
(
auto
iter
=
gSessions
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
promises
.
AppendElement
(
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
Shutdown
(
)
)
;
}
gSessions
.
Clear
(
)
;
ShutdownPromise
:
:
All
(
GetCurrentThreadSerialEventTarget
(
)
promises
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
ticket
]
(
)
mutable
{
MOZ_ASSERT
(
gSessions
.
Count
(
)
=
=
0
)
;
ticket
=
nullptr
;
}
[
]
(
)
{
MOZ_CRASH
(
"
Not
reached
"
)
;
}
)
;
return
NS_OK
;
}
}
;
gMediaRecorderShutdownBlocker
=
MakeAndAddRef
<
Blocker
>
(
)
;
RefPtr
<
nsIAsyncShutdownClient
>
barrier
=
GetShutdownBarrier
(
)
;
nsresult
rv
=
barrier
-
>
AddBlocker
(
gMediaRecorderShutdownBlocker
NS_LITERAL_STRING
(
__FILE__
)
__LINE__
NS_LITERAL_STRING
(
"
MediaRecorder
:
:
Session
:
shutdown
"
)
)
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
gSessions
.
PutEntry
(
this
)
;
uint32_t
audioBitrate
=
mRecorder
-
>
GetAudioBitrate
(
)
;
uint32_t
videoBitrate
=
mRecorder
-
>
GetVideoBitrate
(
)
;
uint32_t
bitrate
=
mRecorder
-
>
GetBitrate
(
)
;
if
(
bitrate
>
0
)
{
if
(
(
aTrackTypes
&
ContainerWriter
:
:
CREATE_AUDIO_TRACK
)
&
&
(
aTrackTypes
&
ContainerWriter
:
:
CREATE_VIDEO_TRACK
)
&
&
audioBitrate
+
videoBitrate
>
bitrate
)
{
LOG
(
LogLevel
:
:
Info
(
"
Session
.
InitEncoder
Bitrates
higher
than
total
"
"
cap
.
Recalculating
.
"
)
)
;
double
factor
=
bitrate
/
static_cast
<
double
>
(
audioBitrate
+
videoBitrate
)
;
audioBitrate
=
static_cast
<
uint32_t
>
(
audioBitrate
*
factor
)
;
videoBitrate
=
static_cast
<
uint32_t
>
(
videoBitrate
*
factor
)
;
}
else
if
(
(
aTrackTypes
&
ContainerWriter
:
:
CREATE_AUDIO_TRACK
)
&
&
!
(
aTrackTypes
&
ContainerWriter
:
:
CREATE_VIDEO_TRACK
)
)
{
audioBitrate
=
std
:
:
min
(
audioBitrate
bitrate
)
;
videoBitrate
=
0
;
}
else
if
(
!
(
aTrackTypes
&
ContainerWriter
:
:
CREATE_AUDIO_TRACK
)
&
&
(
aTrackTypes
&
ContainerWriter
:
:
CREATE_VIDEO_TRACK
)
)
{
audioBitrate
=
0
;
videoBitrate
=
std
:
:
min
(
videoBitrate
bitrate
)
;
}
MOZ_ASSERT
(
audioBitrate
+
videoBitrate
<
=
bitrate
)
;
}
mEncoder
=
MediaEncoder
:
:
CreateEncoder
(
mEncoderThread
NS_LITERAL_STRING
(
"
"
)
audioBitrate
videoBitrate
aTrackTypes
aTrackRate
)
;
if
(
!
mEncoder
)
{
LOG
(
LogLevel
:
:
Error
(
"
Session
.
InitEncoder
!
mEncoder
%
p
"
this
)
)
;
DoSessionEndTask
(
NS_ERROR_ABORT
)
;
return
;
}
mEncoderListener
=
MakeAndAddRef
<
EncoderListener
>
(
mEncoderThread
this
)
;
nsresult
rv
=
mEncoderThread
-
>
Dispatch
(
NewRunnableMethod
<
RefPtr
<
EncoderListener
>
>
(
"
mozilla
:
:
MediaEncoder
:
:
RegisterListener
"
mEncoder
&
MediaEncoder
:
:
RegisterListener
mEncoderListener
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
Unused
<
<
rv
;
if
(
mRecorder
-
>
mAudioNode
)
{
mEncoder
-
>
ConnectAudioNode
(
mRecorder
-
>
mAudioNode
mRecorder
-
>
mAudioNodeOutput
)
;
}
for
(
auto
&
track
:
mMediaStreamTracks
)
{
mEncoder
-
>
ConnectMediaStreamTrack
(
track
)
;
}
mEncoder
-
>
SetVideoKeyFrameInterval
(
mTimeSlice
)
;
mRunningState
=
RunningState
:
:
Starting
;
}
void
DoSessionEndTask
(
nsresult
rv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mRunningState
.
isErr
(
)
)
{
return
;
}
if
(
mRunningState
.
isOk
(
)
&
&
mRunningState
.
unwrap
(
)
=
=
RunningState
:
:
Stopped
)
{
return
;
}
if
(
mRunningState
.
isOk
(
)
&
&
(
mRunningState
.
unwrap
(
)
=
=
RunningState
:
:
Idling
|
|
mRunningState
.
unwrap
(
)
=
=
RunningState
:
:
Starting
)
)
{
NS_DispatchToMainThread
(
new
DispatchEventRunnable
(
this
NS_LITERAL_STRING
(
"
start
"
)
)
)
;
}
if
(
rv
=
=
NS_OK
)
{
mRunningState
=
RunningState
:
:
Stopped
;
}
else
{
mRunningState
=
Err
(
rv
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
mRecorder
-
>
ForceInactive
(
)
;
NS_DispatchToMainThread
(
NewRunnableMethod
<
nsresult
>
(
"
dom
:
:
MediaRecorder
:
:
NotifyError
"
mRecorder
&
MediaRecorder
:
:
NotifyError
rv
)
)
;
}
RefPtr
<
Runnable
>
destroyRunnable
=
new
DestroyRunnable
(
this
)
;
if
(
rv
!
=
NS_ERROR_DOM_SECURITY_ERR
)
{
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
new
PushBlobRunnable
(
this
destroyRunnable
)
)
)
)
{
MOZ_ASSERT
(
false
"
NS_DispatchToMainThread
PushBlobRunnable
failed
"
)
;
}
}
else
{
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
destroyRunnable
)
)
)
{
MOZ_ASSERT
(
false
"
NS_DispatchToMainThread
DestroyRunnable
failed
"
)
;
}
}
}
void
MediaEncoderInitialized
(
)
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
nsTArray
<
nsTArray
<
uint8_t
>
>
encodedBuf
;
nsString
mime
;
nsresult
rv
=
mEncoder
-
>
GetEncodedMetadata
(
&
encodedBuf
mime
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
NS_DispatchToMainThread
(
new
StoreEncodedBufferRunnable
(
this
std
:
:
move
(
encodedBuf
)
)
)
;
RefPtr
<
Session
>
self
=
this
;
NS_DispatchToMainThread
(
NewRunnableFrom
(
[
self
mime
]
(
)
{
if
(
!
self
-
>
mRecorder
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Recorder
should
be
live
"
)
;
return
NS_OK
;
}
if
(
self
-
>
mRunningState
.
isOk
(
)
)
{
auto
state
=
self
-
>
mRunningState
.
unwrap
(
)
;
if
(
state
=
=
RunningState
:
:
Starting
|
|
state
=
=
RunningState
:
:
Stopping
)
{
if
(
state
=
=
RunningState
:
:
Starting
)
{
self
-
>
mRunningState
=
RunningState
:
:
Running
;
}
self
-
>
mMimeType
=
mime
;
self
-
>
mRecorder
-
>
SetMimeType
(
self
-
>
mMimeType
)
;
auto
startEvent
=
MakeRefPtr
<
DispatchEventRunnable
>
(
self
NS_LITERAL_STRING
(
"
start
"
)
)
;
startEvent
-
>
Run
(
)
;
}
}
return
NS_OK
;
}
)
)
;
}
void
MediaEncoderDataAvailable
(
)
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
Extract
(
false
nullptr
)
;
}
void
MediaEncoderError
(
)
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
NS_DispatchToMainThread
(
NewRunnableMethod
<
nsresult
>
(
"
dom
:
:
MediaRecorder
:
:
Session
:
:
DoSessionEndTask
"
this
&
Session
:
:
DoSessionEndTask
NS_ERROR_FAILURE
)
)
;
}
void
MediaEncoderShutdown
(
)
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
MOZ_ASSERT
(
mEncoder
-
>
IsShutdown
(
)
)
;
RefPtr
<
Runnable
>
destroyRunnable
=
new
DestroyRunnable
(
this
)
;
Extract
(
true
destroyRunnable
)
;
mEncoderListener
-
>
Forget
(
)
;
DebugOnly
<
bool
>
unregistered
=
mEncoder
-
>
UnregisterListener
(
mEncoderListener
)
;
MOZ_ASSERT
(
unregistered
)
;
}
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Session
Shutdown
%
p
"
this
)
)
;
if
(
mShutdownPromise
)
{
return
mShutdownPromise
;
}
mShutdownPromise
=
ShutdownPromise
:
:
CreateAndResolve
(
true
__func__
)
;
RefPtr
<
Session
>
self
=
this
;
if
(
mEncoder
)
{
auto
&
encoder
=
mEncoder
;
encoder
-
>
Cancel
(
)
;
MOZ_RELEASE_ASSERT
(
mEncoderListener
)
;
auto
&
encoderListener
=
mEncoderListener
;
mShutdownPromise
=
mShutdownPromise
-
>
Then
(
mEncoderThread
__func__
[
encoder
encoderListener
]
(
)
{
encoder
-
>
UnregisterListener
(
encoderListener
)
;
encoderListener
-
>
Forget
(
)
;
return
ShutdownPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
[
]
(
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
reject
"
)
;
return
ShutdownPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
;
}
if
(
mMediaStream
)
{
mMediaStream
-
>
UnregisterTrackListener
(
this
)
;
mMediaStream
=
nullptr
;
}
{
auto
tracks
(
std
:
:
move
(
mMediaStreamTracks
)
)
;
for
(
RefPtr
<
MediaStreamTrack
>
&
track
:
tracks
)
{
track
-
>
RemovePrincipalChangeObserver
(
this
)
;
}
}
if
(
mRecorder
)
{
mShutdownPromise
=
mShutdownPromise
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
self
]
(
)
{
self
-
>
mRecorder
-
>
RemoveSession
(
self
)
;
self
-
>
mRecorder
=
nullptr
;
return
ShutdownPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
[
]
(
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
reject
"
)
;
return
ShutdownPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
;
}
if
(
mEncoderThread
)
{
RefPtr
<
TaskQueue
>
&
encoderThread
=
mEncoderThread
;
mShutdownPromise
=
mShutdownPromise
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
encoderThread
]
(
)
{
return
encoderThread
-
>
BeginShutdown
(
)
;
}
[
]
(
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
reject
"
)
;
return
ShutdownPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
;
}
return
mShutdownPromise
;
}
private
:
enum
class
RunningState
{
Idling
Starting
Running
Stopping
Stopped
}
;
RefPtr
<
MediaRecorder
>
mRecorder
;
RefPtr
<
DOMMediaStream
>
mMediaStream
;
bool
mMediaStreamReady
;
nsTArray
<
RefPtr
<
MediaStreamTrack
>
>
mMediaStreamTracks
;
RefPtr
<
TaskQueue
>
mEncoderThread
;
RefPtr
<
MediaEncoder
>
mEncoder
;
RefPtr
<
EncoderListener
>
mEncoderListener
;
RefPtr
<
ShutdownPromise
>
mShutdownPromise
;
RefPtr
<
MutableBlobStorage
>
mMutableBlobStorage
;
uint64_t
mMaxMemory
;
nsString
mMimeType
;
TimeStamp
mLastBlobTimeStamp
;
const
int32_t
mTimeSlice
;
Result
<
RunningState
nsresult
>
mRunningState
;
}
;
NS_IMPL_ISUPPORTS_INHERITED0
(
MediaRecorder
:
:
Session
:
:
PushBlobRunnable
Runnable
)
MediaRecorder
:
:
~
MediaRecorder
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
~
MediaRecorder
(
%
p
)
"
this
)
)
;
UnRegisterActivityObserver
(
)
;
}
MediaRecorder
:
:
MediaRecorder
(
DOMMediaStream
&
aSourceMediaStream
nsPIDOMWindowInner
*
aOwnerWindow
)
:
DOMEventTargetHelper
(
aOwnerWindow
)
mAudioNodeOutput
(
0
)
mState
(
RecordingState
:
:
Inactive
)
mAudioBitsPerSecond
(
0
)
mVideoBitsPerSecond
(
0
)
mBitsPerSecond
(
0
)
{
MOZ_ASSERT
(
aOwnerWindow
)
;
mDOMStream
=
&
aSourceMediaStream
;
RegisterActivityObserver
(
)
;
}
MediaRecorder
:
:
MediaRecorder
(
AudioNode
&
aSrcAudioNode
uint32_t
aSrcOutput
nsPIDOMWindowInner
*
aOwnerWindow
)
:
DOMEventTargetHelper
(
aOwnerWindow
)
mAudioNodeOutput
(
aSrcOutput
)
mState
(
RecordingState
:
:
Inactive
)
mAudioBitsPerSecond
(
0
)
mVideoBitsPerSecond
(
0
)
mBitsPerSecond
(
0
)
{
MOZ_ASSERT
(
aOwnerWindow
)
;
mAudioNode
=
&
aSrcAudioNode
;
RegisterActivityObserver
(
)
;
}
void
MediaRecorder
:
:
RegisterActivityObserver
(
)
{
if
(
nsPIDOMWindowInner
*
window
=
GetOwner
(
)
)
{
mDocument
=
window
-
>
GetExtantDoc
(
)
;
if
(
mDocument
)
{
mDocument
-
>
RegisterActivityObserver
(
NS_ISUPPORTS_CAST
(
nsIDocumentActivity
*
this
)
)
;
}
}
}
void
MediaRecorder
:
:
UnRegisterActivityObserver
(
)
{
if
(
mDocument
)
{
mDocument
-
>
UnregisterActivityObserver
(
NS_ISUPPORTS_CAST
(
nsIDocumentActivity
*
this
)
)
;
}
}
void
MediaRecorder
:
:
SetMimeType
(
const
nsString
&
aMimeType
)
{
mMimeType
=
aMimeType
;
}
void
MediaRecorder
:
:
GetMimeType
(
nsString
&
aMimeType
)
{
aMimeType
=
mMimeType
;
}
void
MediaRecorder
:
:
Start
(
const
Optional
<
int32_t
>
&
aTimeSlice
ErrorResult
&
aResult
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
Start
%
p
"
this
)
)
;
InitializeDomExceptions
(
)
;
if
(
mState
!
=
RecordingState
:
:
Inactive
)
{
aResult
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
nsTArray
<
RefPtr
<
MediaStreamTrack
>
>
tracks
;
if
(
mDOMStream
)
{
mDOMStream
-
>
GetTracks
(
tracks
)
;
}
if
(
!
tracks
.
IsEmpty
(
)
)
{
bool
subsumes
=
false
;
nsPIDOMWindowInner
*
window
;
Document
*
doc
;
if
(
!
(
window
=
GetOwner
(
)
)
|
|
!
(
doc
=
window
-
>
GetExtantDoc
(
)
)
|
|
NS_FAILED
(
doc
-
>
NodePrincipal
(
)
-
>
Subsumes
(
mDOMStream
-
>
GetPrincipal
(
)
&
subsumes
)
)
|
|
!
subsumes
)
{
aResult
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
}
int32_t
timeSlice
=
0
;
if
(
aTimeSlice
.
WasPassed
(
)
)
{
if
(
aTimeSlice
.
Value
(
)
<
0
)
{
aResult
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
timeSlice
=
aTimeSlice
.
Value
(
)
;
}
MediaRecorderReporter
:
:
AddMediaRecorder
(
this
)
;
mState
=
RecordingState
:
:
Recording
;
mSessions
.
AppendElement
(
)
;
mSessions
.
LastElement
(
)
=
new
Session
(
this
timeSlice
)
;
mSessions
.
LastElement
(
)
-
>
Start
(
)
;
mStartTime
=
TimeStamp
:
:
Now
(
)
;
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
MEDIARECORDER_RECORDING_COUNT
1
)
;
}
void
MediaRecorder
:
:
Stop
(
ErrorResult
&
aResult
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
Stop
%
p
"
this
)
)
;
MediaRecorderReporter
:
:
RemoveMediaRecorder
(
this
)
;
if
(
mState
=
=
RecordingState
:
:
Inactive
)
{
return
;
}
mState
=
RecordingState
:
:
Inactive
;
MOZ_ASSERT
(
mSessions
.
Length
(
)
>
0
)
;
mSessions
.
LastElement
(
)
-
>
Stop
(
)
;
}
void
MediaRecorder
:
:
Pause
(
ErrorResult
&
aResult
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
Pause
%
p
"
this
)
)
;
if
(
mState
=
=
RecordingState
:
:
Inactive
)
{
aResult
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
mState
=
=
RecordingState
:
:
Paused
)
{
return
;
}
MOZ_ASSERT
(
mSessions
.
Length
(
)
>
0
)
;
nsresult
rv
=
mSessions
.
LastElement
(
)
-
>
Pause
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NotifyError
(
rv
)
;
return
;
}
mState
=
RecordingState
:
:
Paused
;
}
void
MediaRecorder
:
:
Resume
(
ErrorResult
&
aResult
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
Resume
%
p
"
this
)
)
;
if
(
mState
=
=
RecordingState
:
:
Inactive
)
{
aResult
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
mState
=
=
RecordingState
:
:
Recording
)
{
return
;
}
MOZ_ASSERT
(
mSessions
.
Length
(
)
>
0
)
;
nsresult
rv
=
mSessions
.
LastElement
(
)
-
>
Resume
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NotifyError
(
rv
)
;
return
;
}
mState
=
RecordingState
:
:
Recording
;
}
void
MediaRecorder
:
:
RequestData
(
ErrorResult
&
aResult
)
{
if
(
mState
=
=
RecordingState
:
:
Inactive
)
{
aResult
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
MOZ_ASSERT
(
mSessions
.
Length
(
)
>
0
)
;
nsresult
rv
=
mSessions
.
LastElement
(
)
-
>
RequestData
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NotifyError
(
rv
)
;
}
}
JSObject
*
MediaRecorder
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MediaRecorder_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
MediaRecorder
>
MediaRecorder
:
:
Constructor
(
const
GlobalObject
&
aGlobal
DOMMediaStream
&
aStream
const
MediaRecorderOptions
&
aInitDict
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
ownerWindow
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
ownerWindow
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
!
IsTypeSupported
(
aInitDict
.
mMimeType
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
RefPtr
<
MediaRecorder
>
object
=
new
MediaRecorder
(
aStream
ownerWindow
)
;
object
-
>
SetOptions
(
aInitDict
)
;
return
object
.
forget
(
)
;
}
already_AddRefed
<
MediaRecorder
>
MediaRecorder
:
:
Constructor
(
const
GlobalObject
&
aGlobal
AudioNode
&
aSrcAudioNode
uint32_t
aSrcOutput
const
MediaRecorderOptions
&
aInitDict
ErrorResult
&
aRv
)
{
if
(
!
Preferences
:
:
GetBool
(
"
media
.
recorder
.
audio_node
.
enabled
"
false
)
)
{
NS_NAMED_LITERAL_STRING
(
argStr
"
Argument
1
of
MediaRecorder
.
constructor
"
)
;
NS_NAMED_LITERAL_STRING
(
typeStr
"
MediaStream
"
)
;
aRv
.
ThrowTypeError
<
MSG_DOES_NOT_IMPLEMENT_INTERFACE
>
(
argStr
typeStr
)
;
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
ownerWindow
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
ownerWindow
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
aSrcAudioNode
.
NumberOfOutputs
(
)
>
0
&
&
aSrcOutput
>
=
aSrcAudioNode
.
NumberOfOutputs
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
if
(
!
IsTypeSupported
(
aInitDict
.
mMimeType
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
RefPtr
<
MediaRecorder
>
object
=
new
MediaRecorder
(
aSrcAudioNode
aSrcOutput
ownerWindow
)
;
object
-
>
SetOptions
(
aInitDict
)
;
return
object
.
forget
(
)
;
}
void
MediaRecorder
:
:
SetOptions
(
const
MediaRecorderOptions
&
aInitDict
)
{
SetMimeType
(
aInitDict
.
mMimeType
)
;
mAudioBitsPerSecond
=
aInitDict
.
mAudioBitsPerSecond
.
WasPassed
(
)
?
aInitDict
.
mAudioBitsPerSecond
.
Value
(
)
:
0
;
mVideoBitsPerSecond
=
aInitDict
.
mVideoBitsPerSecond
.
WasPassed
(
)
?
aInitDict
.
mVideoBitsPerSecond
.
Value
(
)
:
0
;
mBitsPerSecond
=
aInitDict
.
mBitsPerSecond
.
WasPassed
(
)
?
aInitDict
.
mBitsPerSecond
.
Value
(
)
:
0
;
if
(
aInitDict
.
mBitsPerSecond
.
WasPassed
(
)
&
&
!
aInitDict
.
mVideoBitsPerSecond
.
WasPassed
(
)
)
{
mVideoBitsPerSecond
=
mBitsPerSecond
;
}
}
static
char
const
*
const
gWebMVideoEncoderCodecs
[
4
]
=
{
"
opus
"
"
vp8
"
"
vp8
.
0
"
nullptr
}
;
static
char
const
*
const
gWebMAudioEncoderCodecs
[
4
]
=
{
"
opus
"
nullptr
}
;
static
char
const
*
const
gOggAudioEncoderCodecs
[
2
]
=
{
"
opus
"
nullptr
}
;
template
<
class
String
>
static
bool
CodecListContains
(
char
const
*
const
*
aCodecs
const
String
&
aCodec
)
{
for
(
int32_t
i
=
0
;
aCodecs
[
i
]
;
+
+
i
)
{
if
(
aCodec
.
EqualsASCII
(
aCodecs
[
i
]
)
)
return
true
;
}
return
false
;
}
bool
MediaRecorder
:
:
IsTypeSupported
(
GlobalObject
&
aGlobal
const
nsAString
&
aMIMEType
)
{
return
IsTypeSupported
(
aMIMEType
)
;
}
bool
MediaRecorder
:
:
IsTypeSupported
(
const
nsAString
&
aMIMEType
)
{
char
const
*
const
*
codeclist
=
nullptr
;
if
(
aMIMEType
.
IsEmpty
(
)
)
{
return
true
;
}
nsContentTypeParser
parser
(
aMIMEType
)
;
nsAutoString
mimeType
;
nsresult
rv
=
parser
.
GetType
(
mimeType
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
mimeType
.
EqualsLiteral
(
AUDIO_OGG
)
)
{
if
(
MediaDecoder
:
:
IsOggEnabled
(
)
&
&
MediaDecoder
:
:
IsOpusEnabled
(
)
)
{
codeclist
=
gOggAudioEncoderCodecs
;
}
}
#
ifdef
MOZ_WEBM_ENCODER
else
if
(
(
mimeType
.
EqualsLiteral
(
VIDEO_WEBM
)
|
|
mimeType
.
EqualsLiteral
(
AUDIO_WEBM
)
)
&
&
MediaEncoder
:
:
IsWebMEncoderEnabled
(
)
)
{
if
(
mimeType
.
EqualsLiteral
(
AUDIO_WEBM
)
)
{
codeclist
=
gWebMAudioEncoderCodecs
;
}
else
{
codeclist
=
gWebMVideoEncoderCodecs
;
}
}
#
endif
if
(
!
codeclist
)
{
return
false
;
}
nsAutoString
codecstring
;
rv
=
parser
.
GetParameter
(
"
codecs
"
codecstring
)
;
nsTArray
<
nsString
>
codecs
;
if
(
!
ParseCodecsString
(
codecstring
codecs
)
)
{
return
false
;
}
for
(
const
nsString
&
codec
:
codecs
)
{
if
(
!
CodecListContains
(
codeclist
codec
)
)
{
return
false
;
}
}
return
true
;
}
nsresult
MediaRecorder
:
:
CreateAndDispatchBlobEvent
(
Blob
*
aBlob
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Not
running
on
main
thread
"
)
;
BlobEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mData
=
aBlob
;
RefPtr
<
BlobEvent
>
event
=
BlobEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
dataavailable
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
ErrorResult
rv
;
DispatchEvent
(
*
event
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
MediaRecorder
:
:
DispatchSimpleEvent
(
const
nsAString
&
aStr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Not
running
on
main
thread
"
)
;
nsresult
rv
=
CheckCurrentGlobalCorrectness
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
DOMEventTargetHelper
:
:
DispatchTrustedEvent
(
aStr
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
LogLevel
:
:
Error
(
"
MediaRecorder
.
DispatchSimpleEvent
:
DispatchTrustedEvent
failed
%
p
"
this
)
)
;
NS_ERROR
(
"
Failed
to
dispatch
the
event
!
!
!
"
)
;
}
}
void
MediaRecorder
:
:
NotifyError
(
nsresult
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Not
running
on
main
thread
"
)
;
nsresult
rv
=
CheckCurrentGlobalCorrectness
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
MediaRecorderErrorEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
switch
(
aRv
)
{
case
NS_ERROR_DOM_SECURITY_ERR
:
if
(
!
mSecurityDomException
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
NotifyError
:
"
"
mSecurityDomException
was
not
initialized
"
)
)
;
mSecurityDomException
=
DOMException
:
:
Create
(
NS_ERROR_DOM_SECURITY_ERR
)
;
}
init
.
mError
=
mSecurityDomException
.
forget
(
)
;
break
;
default
:
if
(
!
mUnknownDomException
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
NotifyError
:
"
"
mUnknownDomException
was
not
initialized
"
)
)
;
mUnknownDomException
=
DOMException
:
:
Create
(
NS_ERROR_DOM_UNKNOWN_ERR
)
;
}
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
NotifyError
:
"
"
mUnknownDomException
being
fired
for
aRv
:
%
X
"
uint32_t
(
aRv
)
)
)
;
init
.
mError
=
mUnknownDomException
.
forget
(
)
;
}
RefPtr
<
MediaRecorderErrorEvent
>
event
=
MediaRecorderErrorEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
error
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
IgnoredErrorResult
res
;
DispatchEvent
(
*
event
res
)
;
if
(
res
.
Failed
(
)
)
{
NS_ERROR
(
"
Failed
to
dispatch
the
error
event
!
!
!
"
)
;
}
}
void
MediaRecorder
:
:
RemoveSession
(
Session
*
aSession
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
RemoveSession
(
%
p
)
"
aSession
)
)
;
mSessions
.
RemoveElement
(
aSession
)
;
}
void
MediaRecorder
:
:
NotifyOwnerDocumentActivityChanged
(
)
{
nsPIDOMWindowInner
*
window
=
GetOwner
(
)
;
NS_ENSURE_TRUE_VOID
(
window
)
;
Document
*
doc
=
window
-
>
GetExtantDoc
(
)
;
NS_ENSURE_TRUE_VOID
(
doc
)
;
bool
inFrameSwap
=
false
;
if
(
nsDocShell
*
docShell
=
static_cast
<
nsDocShell
*
>
(
doc
-
>
GetDocShell
(
)
)
)
{
inFrameSwap
=
docShell
-
>
InFrameSwap
(
)
;
}
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
%
p
NotifyOwnerDocumentActivityChanged
"
"
IsActive
=
%
d
"
"
IsVisible
=
%
d
"
"
InFrameSwap
=
%
d
"
this
doc
-
>
IsActive
(
)
doc
-
>
IsVisible
(
)
inFrameSwap
)
)
;
if
(
!
doc
-
>
IsActive
(
)
|
|
!
(
inFrameSwap
|
|
doc
-
>
IsVisible
(
)
)
)
{
ErrorResult
result
;
Stop
(
result
)
;
result
.
SuppressException
(
)
;
}
}
void
MediaRecorder
:
:
ForceInactive
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
ForceInactive
%
p
"
this
)
)
;
mState
=
RecordingState
:
:
Inactive
;
}
void
MediaRecorder
:
:
StopForSessionDestruction
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
StopForSessionDestruction
%
p
"
this
)
)
;
MediaRecorderReporter
:
:
RemoveMediaRecorder
(
this
)
;
mState
=
RecordingState
:
:
Inactive
;
MOZ_ASSERT
(
mSessions
.
Length
(
)
>
0
)
;
mSessions
.
LastElement
(
)
-
>
Stop
(
)
;
TimeDuration
timeDelta
=
TimeStamp
:
:
Now
(
)
-
mStartTime
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MEDIA_RECORDER_RECORDING_DURATION
timeDelta
.
ToSeconds
(
)
)
;
}
void
MediaRecorder
:
:
InitializeDomExceptions
(
)
{
mSecurityDomException
=
DOMException
:
:
Create
(
NS_ERROR_DOM_SECURITY_ERR
)
;
mUnknownDomException
=
DOMException
:
:
Create
(
NS_ERROR_DOM_UNKNOWN_ERR
)
;
}
RefPtr
<
MediaRecorder
:
:
SizeOfPromise
>
MediaRecorder
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
holder
=
MakeRefPtr
<
Refcountable
<
MozPromiseHolder
<
SizeOfPromise
>
>
>
(
)
;
RefPtr
<
SizeOfPromise
>
promise
=
holder
-
>
Ensure
(
__func__
)
;
nsTArray
<
RefPtr
<
SizeOfPromise
>
>
promises
(
mSessions
.
Length
(
)
)
;
for
(
const
RefPtr
<
Session
>
&
session
:
mSessions
)
{
promises
.
AppendElement
(
session
-
>
SizeOfExcludingThis
(
aMallocSizeOf
)
)
;
}
SizeOfPromise
:
:
All
(
GetCurrentThreadSerialEventTarget
(
)
promises
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
holder
]
(
const
nsTArray
<
size_t
>
&
sizes
)
{
size_t
total
=
0
;
for
(
const
size_t
&
size
:
sizes
)
{
total
+
=
size
;
}
holder
-
>
Resolve
(
total
__func__
)
;
}
[
]
(
)
{
MOZ_CRASH
(
"
Unexpected
reject
"
)
;
}
)
;
return
promise
;
}
StaticRefPtr
<
MediaRecorderReporter
>
MediaRecorderReporter
:
:
sUniqueInstance
;
}
}
