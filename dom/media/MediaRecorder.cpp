#
include
"
MediaRecorder
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeStream
.
h
"
#
include
"
DOMMediaStream
.
h
"
#
include
"
EncodedBufferCache
.
h
"
#
include
"
MediaDecoder
.
h
"
#
include
"
MediaEncoder
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
AudioStreamTrack
.
h
"
#
include
"
mozilla
/
dom
/
BlobEvent
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
RecordErrorEvent
.
h
"
#
include
"
mozilla
/
dom
/
VideoStreamTrack
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsContentTypeParser
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
ifdef
LOG
#
undef
LOG
#
endif
mozilla
:
:
LazyLogModule
gMediaRecorderLog
(
"
MediaRecorder
"
)
;
#
define
LOG
(
type
msg
)
MOZ_LOG
(
gMediaRecorderLog
type
msg
)
namespace
mozilla
{
namespace
dom
{
class
MediaRecorderReporter
final
:
public
nsIMemoryReporter
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
MediaRecorderReporter
(
)
{
}
;
static
MediaRecorderReporter
*
UniqueInstance
(
)
;
void
InitMemoryReporter
(
)
;
static
void
AddMediaRecorder
(
MediaRecorder
*
aRecorder
)
{
GetRecorders
(
)
.
AppendElement
(
aRecorder
)
;
}
static
void
RemoveMediaRecorder
(
MediaRecorder
*
aRecorder
)
{
RecordersArray
&
recorders
=
GetRecorders
(
)
;
recorders
.
RemoveElement
(
aRecorder
)
;
if
(
recorders
.
IsEmpty
(
)
)
{
sUniqueInstance
=
nullptr
;
}
}
NS_METHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
int64_t
amount
=
0
;
RecordersArray
&
recorders
=
GetRecorders
(
)
;
for
(
size_t
i
=
0
;
i
<
recorders
.
Length
(
)
;
+
+
i
)
{
amount
+
=
recorders
[
i
]
-
>
SizeOfExcludingThis
(
MallocSizeOf
)
;
}
#
define
MEMREPORT
(
_path
_amount
_desc
)
\
do
{
\
nsresult
rv
;
\
rv
=
aHandleReport
-
>
Callback
(
EmptyCString
(
)
NS_LITERAL_CSTRING
(
_path
)
\
KIND_HEAP
UNITS_BYTES
_amount
\
NS_LITERAL_CSTRING
(
_desc
)
aData
)
;
\
NS_ENSURE_SUCCESS
(
rv
rv
)
;
\
}
while
(
0
)
MEMREPORT
(
"
explicit
/
media
/
recorder
"
amount
"
Memory
used
by
media
recorder
.
"
)
;
return
NS_OK
;
}
private
:
MOZ_DEFINE_MALLOC_SIZE_OF
(
MallocSizeOf
)
virtual
~
MediaRecorderReporter
(
)
;
static
StaticRefPtr
<
MediaRecorderReporter
>
sUniqueInstance
;
typedef
nsTArray
<
MediaRecorder
*
>
RecordersArray
;
static
RecordersArray
&
GetRecorders
(
)
{
return
UniqueInstance
(
)
-
>
mRecorders
;
}
RecordersArray
mRecorders
;
}
;
NS_IMPL_ISUPPORTS
(
MediaRecorderReporter
nsIMemoryReporter
)
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
MediaRecorder
DOMEventTargetHelper
mDOMStream
mAudioNode
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
MediaRecorder
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentActivity
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
NS_IMPL_ADDREF_INHERITED
(
MediaRecorder
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
MediaRecorder
DOMEventTargetHelper
)
class
MediaRecorder
:
:
Session
:
public
nsIObserver
public
PrincipalChangeObserver
<
MediaStreamTrack
>
public
DOMMediaStream
:
:
TrackListener
{
NS_DECL_THREADSAFE_ISUPPORTS
class
PushBlobRunnable
:
public
nsRunnable
{
public
:
explicit
PushBlobRunnable
(
Session
*
aSession
)
:
mSession
(
aSession
)
{
}
NS_IMETHODIMP
Run
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
PushBlobRunnable
s
=
(
%
p
)
"
mSession
.
get
(
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
MediaRecorder
>
recorder
=
mSession
-
>
mRecorder
;
if
(
!
recorder
)
{
return
NS_OK
;
}
nsresult
rv
=
recorder
-
>
CreateAndDispatchBlobEvent
(
mSession
-
>
GetEncodedData
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
recorder
-
>
NotifyError
(
rv
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
Session
>
mSession
;
}
;
class
EncoderErrorNotifierRunnable
:
public
nsRunnable
{
public
:
explicit
EncoderErrorNotifierRunnable
(
Session
*
aSession
)
:
mSession
(
aSession
)
{
}
NS_IMETHODIMP
Run
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
ErrorNotifyRunnable
s
=
(
%
p
)
"
mSession
.
get
(
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
MediaRecorder
>
recorder
=
mSession
-
>
mRecorder
;
if
(
!
recorder
)
{
return
NS_OK
;
}
if
(
mSession
-
>
IsEncoderError
(
)
)
{
recorder
-
>
NotifyError
(
NS_ERROR_UNEXPECTED
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
Session
>
mSession
;
}
;
class
DispatchStartEventRunnable
:
public
nsRunnable
{
public
:
DispatchStartEventRunnable
(
Session
*
aSession
const
nsAString
&
aEventName
)
:
mSession
(
aSession
)
mEventName
(
aEventName
)
{
}
NS_IMETHODIMP
Run
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
DispatchStartEventRunnable
s
=
(
%
p
)
"
mSession
.
get
(
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_TRUE
(
mSession
-
>
mRecorder
NS_OK
)
;
RefPtr
<
MediaRecorder
>
recorder
=
mSession
-
>
mRecorder
;
recorder
-
>
SetMimeType
(
mSession
-
>
mMimeType
)
;
recorder
-
>
DispatchSimpleEvent
(
mEventName
)
;
return
NS_OK
;
}
private
:
RefPtr
<
Session
>
mSession
;
nsString
mEventName
;
}
;
class
ExtractRunnable
:
public
nsRunnable
{
public
:
explicit
ExtractRunnable
(
Session
*
aSession
)
:
mSession
(
aSession
)
{
}
~
ExtractRunnable
(
)
{
}
NS_IMETHODIMP
Run
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mSession
-
>
mReadThread
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
ExtractRunnable
shutdown
=
%
d
"
mSession
-
>
mEncoder
-
>
IsShutdown
(
)
)
)
;
if
(
!
mSession
-
>
mEncoder
-
>
IsShutdown
(
)
)
{
mSession
-
>
Extract
(
false
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
ExtractRunnable
(
mSession
)
;
if
(
NS_FAILED
(
NS_DispatchToCurrentThread
(
event
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
ExtractRunnable
to
encoder
thread
"
)
;
}
}
else
{
mSession
-
>
Extract
(
true
)
;
if
(
mSession
-
>
mIsRegisterProfiler
)
profiler_unregister_thread
(
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
new
DestroyRunnable
(
mSession
)
)
)
)
{
MOZ_ASSERT
(
false
"
NS_DispatchToMainThread
DestroyRunnable
failed
"
)
;
}
}
return
NS_OK
;
}
private
:
RefPtr
<
Session
>
mSession
;
}
;
class
TracksAvailableCallback
:
public
OnTracksAvailableCallback
{
public
:
explicit
TracksAvailableCallback
(
Session
*
aSession
)
:
mSession
(
aSession
)
{
}
virtual
void
NotifyTracksAvailable
(
DOMMediaStream
*
aStream
)
{
if
(
mSession
-
>
mStopIssued
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
aStream
)
;
mSession
-
>
MediaStreamReady
(
*
aStream
)
;
uint8_t
trackTypes
=
0
;
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
AudioStreamTrack
>
>
audioTracks
;
aStream
-
>
GetAudioTracks
(
audioTracks
)
;
if
(
!
audioTracks
.
IsEmpty
(
)
)
{
trackTypes
|
=
ContainerWriter
:
:
CREATE_AUDIO_TRACK
;
mSession
-
>
ConnectMediaStreamTrack
(
*
audioTracks
[
0
]
)
;
}
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
VideoStreamTrack
>
>
videoTracks
;
aStream
-
>
GetVideoTracks
(
videoTracks
)
;
if
(
!
videoTracks
.
IsEmpty
(
)
)
{
trackTypes
|
=
ContainerWriter
:
:
CREATE_VIDEO_TRACK
;
mSession
-
>
ConnectMediaStreamTrack
(
*
videoTracks
[
0
]
)
;
}
if
(
audioTracks
.
Length
(
)
>
1
|
|
videoTracks
.
Length
(
)
>
1
)
{
nsPIDOMWindowInner
*
window
=
mSession
-
>
mRecorder
-
>
GetParentObject
(
)
;
nsIDocument
*
document
=
window
?
window
-
>
GetExtantDoc
(
)
:
nullptr
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
NS_LITERAL_CSTRING
(
"
Media
"
)
document
nsContentUtils
:
:
eDOM_PROPERTIES
"
MediaRecorderMultiTracksNotSupported
"
)
;
mSession
-
>
DoSessionEndTask
(
NS_ERROR_ABORT
)
;
return
;
}
NS_ASSERTION
(
trackTypes
!
=
0
"
TracksAvailableCallback
without
any
tracks
available
"
)
;
if
(
!
mSession
-
>
MediaStreamTracksPrincipalSubsumes
(
)
)
{
LOG
(
LogLevel
:
:
Warning
(
"
Session
.
NotifyTracksAvailable
MediaStreamTracks
principal
check
failed
"
)
)
;
mSession
-
>
DoSessionEndTask
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
NotifyTracksAvailable
track
type
=
(
%
d
)
"
trackTypes
)
)
;
mSession
-
>
InitEncoder
(
trackTypes
)
;
}
private
:
RefPtr
<
Session
>
mSession
;
}
;
class
DestroyRunnable
:
public
nsRunnable
{
public
:
explicit
DestroyRunnable
(
Session
*
aSession
)
:
mSession
(
aSession
)
{
}
NS_IMETHODIMP
Run
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
DestroyRunnable
session
refcnt
=
(
%
d
)
stopIssued
%
d
s
=
(
%
p
)
"
(
int
)
mSession
-
>
mRefCnt
mSession
-
>
mStopIssued
mSession
.
get
(
)
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
&
&
mSession
)
;
RefPtr
<
MediaRecorder
>
recorder
=
mSession
-
>
mRecorder
;
if
(
!
recorder
)
{
return
NS_OK
;
}
if
(
!
mSession
-
>
mStopIssued
)
{
ErrorResult
result
;
mSession
-
>
mStopIssued
=
true
;
recorder
-
>
Stop
(
result
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
new
DestroyRunnable
(
mSession
)
)
)
)
{
MOZ_ASSERT
(
false
"
NS_DispatchToMainThread
failed
"
)
;
}
return
NS_OK
;
}
mSession
-
>
mMimeType
=
NS_LITERAL_STRING
(
"
"
)
;
recorder
-
>
SetMimeType
(
mSession
-
>
mMimeType
)
;
recorder
-
>
DispatchSimpleEvent
(
NS_LITERAL_STRING
(
"
stop
"
)
)
;
mSession
-
>
BreakCycle
(
)
;
return
NS_OK
;
}
private
:
RefPtr
<
Session
>
mSession
;
}
;
friend
class
EncoderErrorNotifierRunnable
;
friend
class
PushBlobRunnable
;
friend
class
ExtractRunnable
;
friend
class
DestroyRunnable
;
friend
class
TracksAvailableCallback
;
public
:
Session
(
MediaRecorder
*
aRecorder
int32_t
aTimeSlice
)
:
mRecorder
(
aRecorder
)
mTimeSlice
(
aTimeSlice
)
mStopIssued
(
false
)
mIsStartEventFired
(
false
)
mIsRegisterProfiler
(
false
)
mNeedSessionEndTask
(
true
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_COUNT_CTOR
(
MediaRecorder
:
:
Session
)
;
uint32_t
maxMem
=
Preferences
:
:
GetUint
(
"
media
.
recorder
.
max_memory
"
MAX_ALLOW_MEMORY_BUFFER
)
;
mEncodedBufferCache
=
new
EncodedBufferCache
(
maxMem
)
;
mLastBlobTimeStamp
=
TimeStamp
:
:
Now
(
)
;
}
void
PrincipalChanged
(
MediaStreamTrack
*
aTrack
)
override
{
NS_ASSERTION
(
mMediaStreamTracks
.
Contains
(
aTrack
)
"
Principal
changed
for
unrecorded
track
"
)
;
if
(
!
MediaStreamTracksPrincipalSubsumes
(
)
)
{
DoSessionEndTask
(
NS_ERROR_DOM_SECURITY_ERR
)
;
}
}
void
NotifyTrackAdded
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
override
{
LOG
(
LogLevel
:
:
Warning
(
"
Session
.
NotifyTrackAdded
%
p
Raising
error
due
to
track
set
change
"
this
)
)
;
DoSessionEndTask
(
NS_ERROR_ABORT
)
;
}
void
NotifyTrackRemoved
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
override
{
RefPtr
<
MediaInputPort
>
foundInputPort
;
for
(
RefPtr
<
MediaInputPort
>
inputPort
:
mInputPorts
)
{
if
(
aTrack
-
>
IsForwardedThrough
(
inputPort
)
)
{
foundInputPort
=
inputPort
;
break
;
}
}
if
(
foundInputPort
)
{
foundInputPort
-
>
Destroy
(
)
;
DebugOnly
<
bool
>
removed
=
mInputPorts
.
RemoveElement
(
foundInputPort
)
;
MOZ_ASSERT
(
removed
)
;
return
;
}
LOG
(
LogLevel
:
:
Warning
(
"
Session
.
NotifyTrackRemoved
%
p
Raising
error
due
to
track
set
change
"
this
)
)
;
DoSessionEndTask
(
NS_ERROR_ABORT
)
;
}
void
Start
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Start
%
p
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MediaStreamGraph
*
gm
=
mRecorder
-
>
GetSourceMediaStream
(
)
-
>
Graph
(
)
;
mTrackUnionStream
=
gm
-
>
CreateTrackUnionStream
(
nullptr
)
;
MOZ_ASSERT
(
mTrackUnionStream
"
CreateTrackUnionStream
failed
"
)
;
mTrackUnionStream
-
>
SetAutofinish
(
true
)
;
DOMMediaStream
*
domStream
=
mRecorder
-
>
Stream
(
)
;
if
(
domStream
)
{
TracksAvailableCallback
*
tracksAvailableCallback
=
new
TracksAvailableCallback
(
this
)
;
domStream
-
>
OnTracksAvailable
(
tracksAvailableCallback
)
;
}
else
{
if
(
!
AudioNodePrincipalSubsumes
(
)
)
{
LOG
(
LogLevel
:
:
Warning
(
"
Session
.
Start
AudioNode
principal
check
failed
"
)
)
;
DoSessionEndTask
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
RefPtr
<
MediaInputPort
>
inputPort
=
mTrackUnionStream
-
>
AllocateInputPort
(
mRecorder
-
>
GetSourceMediaStream
(
)
)
;
mInputPorts
.
AppendElement
(
inputPort
.
forget
(
)
)
;
MOZ_ASSERT
(
mInputPorts
[
mInputPorts
.
Length
(
)
-
1
]
)
;
InitEncoder
(
ContainerWriter
:
:
CREATE_AUDIO_TRACK
)
;
}
}
void
Stop
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Stop
%
p
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mStopIssued
=
true
;
CleanupStreams
(
)
;
if
(
mNeedSessionEndTask
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Stop
mNeedSessionEndTask
%
p
"
this
)
)
;
DoSessionEndTask
(
NS_OK
)
;
}
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
}
nsresult
Pause
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Pause
"
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_TRUE
(
mTrackUnionStream
NS_ERROR_FAILURE
)
;
mTrackUnionStream
-
>
Suspend
(
)
;
if
(
mEncoder
)
{
mEncoder
-
>
Suspend
(
)
;
}
return
NS_OK
;
}
nsresult
Resume
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Resume
"
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_TRUE
(
mTrackUnionStream
NS_ERROR_FAILURE
)
;
if
(
mEncoder
)
{
mEncoder
-
>
Resume
(
)
;
}
mTrackUnionStream
-
>
Resume
(
)
;
return
NS_OK
;
}
nsresult
RequestData
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
RequestData
"
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
new
EncoderErrorNotifierRunnable
(
this
)
)
)
|
|
NS_FAILED
(
NS_DispatchToMainThread
(
new
PushBlobRunnable
(
this
)
)
)
)
{
MOZ_ASSERT
(
false
"
RequestData
NS_DispatchToMainThread
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
already_AddRefed
<
nsIDOMBlob
>
GetEncodedData
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mEncodedBufferCache
-
>
ExtractBlob
(
mRecorder
-
>
GetParentObject
(
)
mMimeType
)
;
}
bool
IsEncoderError
(
)
{
if
(
mEncoder
&
&
mEncoder
-
>
HasError
(
)
)
{
return
true
;
}
return
false
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
(
mEncoder
?
mEncoder
-
>
SizeOfExcludingThis
(
aMallocSizeOf
)
:
0
)
;
}
private
:
virtual
~
Session
(
)
{
MOZ_COUNT_DTOR
(
MediaRecorder
:
:
Session
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
~
Session
(
%
p
)
"
this
)
)
;
CleanupStreams
(
)
;
}
void
Extract
(
bool
aForceFlush
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mReadThread
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Extract
%
p
"
this
)
)
;
if
(
!
mIsRegisterProfiler
)
{
char
aLocal
;
profiler_register_thread
(
"
Media_Encoder
"
&
aLocal
)
;
mIsRegisterProfiler
=
true
;
}
PROFILER_LABEL
(
"
MediaRecorder
"
"
Session
Extract
"
js
:
:
ProfileEntry
:
:
Category
:
:
OTHER
)
;
nsTArray
<
nsTArray
<
uint8_t
>
>
encodedBuf
;
mEncoder
-
>
GetEncodedData
(
&
encodedBuf
mMimeType
)
;
for
(
uint32_t
i
=
0
;
i
<
encodedBuf
.
Length
(
)
;
i
+
+
)
{
if
(
!
encodedBuf
[
i
]
.
IsEmpty
(
)
)
{
mEncodedBufferCache
-
>
AppendBuffer
(
encodedBuf
[
i
]
)
;
if
(
!
mIsStartEventFired
)
{
NS_DispatchToMainThread
(
new
DispatchStartEventRunnable
(
this
NS_LITERAL_STRING
(
"
start
"
)
)
)
;
mIsStartEventFired
=
true
;
}
}
}
bool
pushBlob
=
false
;
if
(
(
mTimeSlice
>
0
)
&
&
(
(
TimeStamp
:
:
Now
(
)
-
mLastBlobTimeStamp
)
.
ToMilliseconds
(
)
>
mTimeSlice
)
)
{
pushBlob
=
true
;
}
if
(
pushBlob
|
|
aForceFlush
)
{
if
(
!
mIsStartEventFired
)
{
NS_DispatchToMainThread
(
new
DispatchStartEventRunnable
(
this
NS_LITERAL_STRING
(
"
start
"
)
)
)
;
mIsStartEventFired
=
true
;
}
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
new
EncoderErrorNotifierRunnable
(
this
)
)
)
)
{
MOZ_ASSERT
(
false
"
NS_DispatchToMainThread
EncoderErrorNotifierRunnable
failed
"
)
;
}
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
new
PushBlobRunnable
(
this
)
)
)
)
{
MOZ_ASSERT
(
false
"
NS_DispatchToMainThread
PushBlobRunnable
failed
"
)
;
}
else
{
mLastBlobTimeStamp
=
TimeStamp
:
:
Now
(
)
;
}
}
}
void
MediaStreamReady
(
DOMMediaStream
&
aStream
)
{
mMediaStream
=
&
aStream
;
aStream
.
RegisterTrackListener
(
this
)
;
}
void
ConnectMediaStreamTrack
(
MediaStreamTrack
&
aTrack
)
{
mMediaStreamTracks
.
AppendElement
(
&
aTrack
)
;
aTrack
.
AddPrincipalChangeObserver
(
this
)
;
RefPtr
<
MediaInputPort
>
inputPort
=
aTrack
.
ForwardTrackContentsTo
(
mTrackUnionStream
)
;
MOZ_ASSERT
(
inputPort
)
;
mInputPorts
.
AppendElement
(
inputPort
.
forget
(
)
)
;
MOZ_ASSERT
(
mInputPorts
[
mInputPorts
.
Length
(
)
-
1
]
)
;
}
bool
PrincipalSubsumes
(
nsIPrincipal
*
aPrincipal
)
{
if
(
!
mRecorder
-
>
GetOwner
(
)
)
return
false
;
nsCOMPtr
<
nsIDocument
>
doc
=
mRecorder
-
>
GetOwner
(
)
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
false
;
}
if
(
!
aPrincipal
)
{
return
false
;
}
bool
subsumes
;
if
(
NS_FAILED
(
doc
-
>
NodePrincipal
(
)
-
>
Subsumes
(
aPrincipal
&
subsumes
)
)
)
{
return
false
;
}
return
subsumes
;
}
bool
MediaStreamTracksPrincipalSubsumes
(
)
{
MOZ_ASSERT
(
mRecorder
-
>
mDOMStream
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
nullptr
;
for
(
RefPtr
<
MediaStreamTrack
>
&
track
:
mMediaStreamTracks
)
{
nsContentUtils
:
:
CombineResourcePrincipals
(
&
principal
track
-
>
GetPrincipal
(
)
)
;
}
return
PrincipalSubsumes
(
principal
)
;
}
bool
AudioNodePrincipalSubsumes
(
)
{
MOZ_ASSERT
(
mRecorder
-
>
mAudioNode
!
=
nullptr
)
;
nsIDocument
*
doc
=
mRecorder
-
>
mAudioNode
-
>
GetOwner
(
)
?
mRecorder
-
>
mAudioNode
-
>
GetOwner
(
)
-
>
GetExtantDoc
(
)
:
nullptr
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
doc
?
doc
-
>
NodePrincipal
(
)
:
nullptr
;
return
PrincipalSubsumes
(
principal
)
;
}
bool
CheckPermission
(
const
char
*
aType
)
{
if
(
!
mRecorder
|
|
!
mRecorder
-
>
GetOwner
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
mRecorder
-
>
GetOwner
(
)
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
false
;
}
uint16_t
appStatus
=
nsIPrincipal
:
:
APP_STATUS_NOT_INSTALLED
;
doc
-
>
NodePrincipal
(
)
-
>
GetAppStatus
(
&
appStatus
)
;
if
(
appStatus
=
=
nsIPrincipal
:
:
APP_STATUS_CERTIFIED
)
{
return
true
;
}
nsCOMPtr
<
nsIPermissionManager
>
pm
=
do_GetService
(
NS_PERMISSIONMANAGER_CONTRACTID
)
;
if
(
!
pm
)
{
return
false
;
}
uint32_t
perm
=
nsIPermissionManager
:
:
DENY_ACTION
;
pm
-
>
TestExactPermissionFromPrincipal
(
doc
-
>
NodePrincipal
(
)
aType
&
perm
)
;
return
perm
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
;
}
void
InitEncoder
(
uint8_t
aTrackTypes
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
InitEncoder
%
p
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mRecorder
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
InitEncoder
failure
mRecorder
is
null
%
p
"
this
)
)
;
return
;
}
if
(
mRecorder
-
>
mMimeType
.
EqualsLiteral
(
AUDIO_3GPP
)
&
&
CheckPermission
(
"
audio
-
capture
:
3gpp
"
)
)
{
mEncoder
=
MediaEncoder
:
:
CreateEncoder
(
NS_LITERAL_STRING
(
AUDIO_3GPP
)
mRecorder
-
>
GetAudioBitrate
(
)
mRecorder
-
>
GetVideoBitrate
(
)
mRecorder
-
>
GetBitrate
(
)
aTrackTypes
)
;
}
else
if
(
mRecorder
-
>
mMimeType
.
EqualsLiteral
(
AUDIO_3GPP2
)
&
&
CheckPermission
(
"
audio
-
capture
:
3gpp2
"
)
)
{
mEncoder
=
MediaEncoder
:
:
CreateEncoder
(
NS_LITERAL_STRING
(
AUDIO_3GPP2
)
mRecorder
-
>
GetAudioBitrate
(
)
mRecorder
-
>
GetVideoBitrate
(
)
mRecorder
-
>
GetBitrate
(
)
aTrackTypes
)
;
}
else
{
mEncoder
=
MediaEncoder
:
:
CreateEncoder
(
NS_LITERAL_STRING
(
"
"
)
mRecorder
-
>
GetAudioBitrate
(
)
mRecorder
-
>
GetVideoBitrate
(
)
mRecorder
-
>
GetBitrate
(
)
aTrackTypes
)
;
}
if
(
!
mEncoder
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
InitEncoder
!
mEncoder
%
p
"
this
)
)
;
DoSessionEndTask
(
NS_ERROR_ABORT
)
;
return
;
}
if
(
!
mTrackUnionStream
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
InitEncoder
!
mTrackUnionStream
%
p
"
this
)
)
;
DoSessionEndTask
(
NS_OK
)
;
return
;
}
mTrackUnionStream
-
>
AddListener
(
mEncoder
)
;
DOMMediaStream
*
domStream
=
mRecorder
-
>
Stream
(
)
;
if
(
domStream
&
&
domStream
-
>
GetInputStream
(
)
)
{
mInputStream
=
domStream
-
>
GetInputStream
(
)
-
>
AsSourceStream
(
)
;
if
(
mInputStream
)
{
mInputStream
-
>
AddDirectListener
(
mEncoder
)
;
mEncoder
-
>
SetDirectConnect
(
true
)
;
}
}
if
(
!
mReadThread
)
{
nsresult
rv
=
NS_NewNamedThread
(
"
Media_Encoder
"
getter_AddRefs
(
mReadThread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
InitEncoder
!
mReadThread
%
p
"
this
)
)
;
DoSessionEndTask
(
rv
)
;
return
;
}
}
nsContentUtils
:
:
RegisterShutdownObserver
(
this
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
ExtractRunnable
(
this
)
;
if
(
NS_FAILED
(
mReadThread
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
ExtractRunnable
at
beginning
"
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
InitEncoder
!
ReadThread
-
>
Dispatch
%
p
"
this
)
)
;
DoSessionEndTask
(
NS_ERROR_ABORT
)
;
}
mNeedSessionEndTask
=
false
;
}
void
DoSessionEndTask
(
nsresult
rv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
CleanupStreams
(
)
;
NS_DispatchToMainThread
(
new
DispatchStartEventRunnable
(
this
NS_LITERAL_STRING
(
"
start
"
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableMethodWithArg
<
nsresult
>
(
mRecorder
&
MediaRecorder
:
:
NotifyError
rv
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
new
EncoderErrorNotifierRunnable
(
this
)
)
)
)
{
MOZ_ASSERT
(
false
"
NS_DispatchToMainThread
EncoderErrorNotifierRunnable
failed
"
)
;
}
if
(
rv
!
=
NS_ERROR_DOM_SECURITY_ERR
)
{
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
new
PushBlobRunnable
(
this
)
)
)
)
{
MOZ_ASSERT
(
false
"
NS_DispatchToMainThread
PushBlobRunnable
failed
"
)
;
}
}
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
new
DestroyRunnable
(
this
)
)
)
)
{
MOZ_ASSERT
(
false
"
NS_DispatchToMainThread
DestroyRunnable
failed
"
)
;
}
mNeedSessionEndTask
=
false
;
}
void
CleanupStreams
(
)
{
if
(
mInputStream
)
{
if
(
mEncoder
)
{
mInputStream
-
>
RemoveDirectListener
(
mEncoder
)
;
}
mInputStream
=
nullptr
;
}
for
(
RefPtr
<
MediaInputPort
>
&
inputPort
:
mInputPorts
)
{
MOZ_ASSERT
(
inputPort
)
;
inputPort
-
>
Destroy
(
)
;
}
mInputPorts
.
Clear
(
)
;
if
(
mTrackUnionStream
)
{
if
(
mEncoder
)
{
mTrackUnionStream
-
>
RemoveListener
(
mEncoder
)
;
}
mTrackUnionStream
-
>
Destroy
(
)
;
mTrackUnionStream
=
nullptr
;
}
if
(
mMediaStream
)
{
mMediaStream
-
>
UnregisterTrackListener
(
this
)
;
mMediaStream
=
nullptr
;
}
for
(
RefPtr
<
MediaStreamTrack
>
&
track
:
mMediaStreamTracks
)
{
track
-
>
RemovePrincipalChangeObserver
(
this
)
;
}
mMediaStreamTracks
.
Clear
(
)
;
}
NS_IMETHODIMP
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Observe
XPCOM_SHUTDOWN
%
p
"
this
)
)
;
if
(
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
=
=
0
)
{
mEncoder
-
>
Cancel
(
)
;
if
(
mReadThread
)
{
mReadThread
-
>
Shutdown
(
)
;
mReadThread
=
nullptr
;
}
BreakCycle
(
)
;
Stop
(
)
;
}
return
NS_OK
;
}
void
BreakCycle
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mRecorder
)
{
mRecorder
-
>
RemoveSession
(
this
)
;
mRecorder
=
nullptr
;
}
}
private
:
RefPtr
<
MediaRecorder
>
mRecorder
;
RefPtr
<
ProcessedMediaStream
>
mTrackUnionStream
;
RefPtr
<
SourceMediaStream
>
mInputStream
;
nsTArray
<
RefPtr
<
MediaInputPort
>
>
mInputPorts
;
RefPtr
<
DOMMediaStream
>
mMediaStream
;
nsTArray
<
RefPtr
<
MediaStreamTrack
>
>
mMediaStreamTracks
;
nsCOMPtr
<
nsIThread
>
mReadThread
;
RefPtr
<
MediaEncoder
>
mEncoder
;
nsAutoPtr
<
EncodedBufferCache
>
mEncodedBufferCache
;
nsString
mMimeType
;
TimeStamp
mLastBlobTimeStamp
;
const
int32_t
mTimeSlice
;
bool
mStopIssued
;
bool
mIsStartEventFired
;
bool
mIsRegisterProfiler
;
bool
mNeedSessionEndTask
;
}
;
NS_IMPL_ISUPPORTS
(
MediaRecorder
:
:
Session
nsIObserver
)
MediaRecorder
:
:
~
MediaRecorder
(
)
{
if
(
mPipeStream
!
=
nullptr
)
{
mInputPort
-
>
Destroy
(
)
;
mPipeStream
-
>
Destroy
(
)
;
}
LOG
(
LogLevel
:
:
Debug
(
"
~
MediaRecorder
(
%
p
)
"
this
)
)
;
UnRegisterActivityObserver
(
)
;
}
MediaRecorder
:
:
MediaRecorder
(
DOMMediaStream
&
aSourceMediaStream
nsPIDOMWindowInner
*
aOwnerWindow
)
:
DOMEventTargetHelper
(
aOwnerWindow
)
mState
(
RecordingState
:
:
Inactive
)
{
MOZ_ASSERT
(
aOwnerWindow
)
;
MOZ_ASSERT
(
aOwnerWindow
-
>
IsInnerWindow
(
)
)
;
mDOMStream
=
&
aSourceMediaStream
;
RegisterActivityObserver
(
)
;
}
MediaRecorder
:
:
MediaRecorder
(
AudioNode
&
aSrcAudioNode
uint32_t
aSrcOutput
nsPIDOMWindowInner
*
aOwnerWindow
)
:
DOMEventTargetHelper
(
aOwnerWindow
)
mState
(
RecordingState
:
:
Inactive
)
{
MOZ_ASSERT
(
aOwnerWindow
)
;
MOZ_ASSERT
(
aOwnerWindow
-
>
IsInnerWindow
(
)
)
;
if
(
aSrcAudioNode
.
NumberOfOutputs
(
)
>
0
)
{
AudioContext
*
ctx
=
aSrcAudioNode
.
Context
(
)
;
AudioNodeEngine
*
engine
=
new
AudioNodeEngine
(
nullptr
)
;
AudioNodeStream
:
:
Flags
flags
=
AudioNodeStream
:
:
EXTERNAL_OUTPUT
|
AudioNodeStream
:
:
NEED_MAIN_THREAD_FINISHED
;
mPipeStream
=
AudioNodeStream
:
:
Create
(
ctx
engine
flags
)
;
AudioNodeStream
*
ns
=
aSrcAudioNode
.
GetStream
(
)
;
if
(
ns
)
{
mInputPort
=
mPipeStream
-
>
AllocateInputPort
(
aSrcAudioNode
.
GetStream
(
)
TRACK_ANY
TRACK_ANY
0
aSrcOutput
)
;
}
}
mAudioNode
=
&
aSrcAudioNode
;
RegisterActivityObserver
(
)
;
}
void
MediaRecorder
:
:
RegisterActivityObserver
(
)
{
if
(
nsPIDOMWindowInner
*
window
=
GetOwner
(
)
)
{
nsIDocument
*
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
doc
)
{
doc
-
>
RegisterActivityObserver
(
NS_ISUPPORTS_CAST
(
nsIDocumentActivity
*
this
)
)
;
}
}
}
void
MediaRecorder
:
:
UnRegisterActivityObserver
(
)
{
if
(
nsPIDOMWindowInner
*
window
=
GetOwner
(
)
)
{
nsIDocument
*
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
doc
)
{
doc
-
>
UnregisterActivityObserver
(
NS_ISUPPORTS_CAST
(
nsIDocumentActivity
*
this
)
)
;
}
}
}
void
MediaRecorder
:
:
SetMimeType
(
const
nsString
&
aMimeType
)
{
mMimeType
=
aMimeType
;
}
void
MediaRecorder
:
:
GetMimeType
(
nsString
&
aMimeType
)
{
aMimeType
=
mMimeType
;
}
void
MediaRecorder
:
:
Start
(
const
Optional
<
int32_t
>
&
aTimeSlice
ErrorResult
&
aResult
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
Start
%
p
"
this
)
)
;
if
(
mState
!
=
RecordingState
:
:
Inactive
)
{
aResult
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
GetSourceMediaStream
(
)
-
>
IsFinished
(
)
|
|
GetSourceMediaStream
(
)
-
>
IsDestroyed
(
)
)
{
aResult
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
int32_t
timeSlice
=
0
;
if
(
aTimeSlice
.
WasPassed
(
)
)
{
if
(
aTimeSlice
.
Value
(
)
<
0
)
{
aResult
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
timeSlice
=
aTimeSlice
.
Value
(
)
;
}
MediaRecorderReporter
:
:
AddMediaRecorder
(
this
)
;
mState
=
RecordingState
:
:
Recording
;
mSessions
.
AppendElement
(
)
;
mSessions
.
LastElement
(
)
=
new
Session
(
this
timeSlice
)
;
mSessions
.
LastElement
(
)
-
>
Start
(
)
;
}
void
MediaRecorder
:
:
Stop
(
ErrorResult
&
aResult
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
Stop
%
p
"
this
)
)
;
MediaRecorderReporter
:
:
RemoveMediaRecorder
(
this
)
;
if
(
mState
=
=
RecordingState
:
:
Inactive
)
{
aResult
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
mState
=
RecordingState
:
:
Inactive
;
MOZ_ASSERT
(
mSessions
.
Length
(
)
>
0
)
;
mSessions
.
LastElement
(
)
-
>
Stop
(
)
;
}
void
MediaRecorder
:
:
Pause
(
ErrorResult
&
aResult
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
Pause
"
)
)
;
if
(
mState
!
=
RecordingState
:
:
Recording
)
{
aResult
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
MOZ_ASSERT
(
mSessions
.
Length
(
)
>
0
)
;
nsresult
rv
=
mSessions
.
LastElement
(
)
-
>
Pause
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NotifyError
(
rv
)
;
return
;
}
mState
=
RecordingState
:
:
Paused
;
}
void
MediaRecorder
:
:
Resume
(
ErrorResult
&
aResult
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
Resume
"
)
)
;
if
(
mState
!
=
RecordingState
:
:
Paused
)
{
aResult
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
MOZ_ASSERT
(
mSessions
.
Length
(
)
>
0
)
;
nsresult
rv
=
mSessions
.
LastElement
(
)
-
>
Resume
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NotifyError
(
rv
)
;
return
;
}
mState
=
RecordingState
:
:
Recording
;
}
void
MediaRecorder
:
:
RequestData
(
ErrorResult
&
aResult
)
{
if
(
mState
!
=
RecordingState
:
:
Recording
)
{
aResult
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
MOZ_ASSERT
(
mSessions
.
Length
(
)
>
0
)
;
nsresult
rv
=
mSessions
.
LastElement
(
)
-
>
RequestData
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NotifyError
(
rv
)
;
}
}
JSObject
*
MediaRecorder
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MediaRecorderBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
MediaRecorder
>
MediaRecorder
:
:
Constructor
(
const
GlobalObject
&
aGlobal
DOMMediaStream
&
aStream
const
MediaRecorderOptions
&
aInitDict
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
ownerWindow
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
ownerWindow
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
!
IsTypeSupported
(
aInitDict
.
mMimeType
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
RefPtr
<
MediaRecorder
>
object
=
new
MediaRecorder
(
aStream
ownerWindow
)
;
object
-
>
SetOptions
(
aInitDict
)
;
return
object
.
forget
(
)
;
}
already_AddRefed
<
MediaRecorder
>
MediaRecorder
:
:
Constructor
(
const
GlobalObject
&
aGlobal
AudioNode
&
aSrcAudioNode
uint32_t
aSrcOutput
const
MediaRecorderOptions
&
aInitDict
ErrorResult
&
aRv
)
{
if
(
!
Preferences
:
:
GetBool
(
"
media
.
recorder
.
audio_node
.
enabled
"
false
)
)
{
NS_NAMED_LITERAL_STRING
(
argStr
"
Argument
1
of
MediaRecorder
.
constructor
"
)
;
NS_NAMED_LITERAL_STRING
(
typeStr
"
MediaStream
"
)
;
aRv
.
ThrowTypeError
<
MSG_DOES_NOT_IMPLEMENT_INTERFACE
>
(
argStr
typeStr
)
;
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
ownerWindow
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
ownerWindow
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
aSrcAudioNode
.
NumberOfOutputs
(
)
>
0
&
&
aSrcOutput
>
=
aSrcAudioNode
.
NumberOfOutputs
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
if
(
!
IsTypeSupported
(
aInitDict
.
mMimeType
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
RefPtr
<
MediaRecorder
>
object
=
new
MediaRecorder
(
aSrcAudioNode
aSrcOutput
ownerWindow
)
;
object
-
>
SetOptions
(
aInitDict
)
;
return
object
.
forget
(
)
;
}
void
MediaRecorder
:
:
SetOptions
(
const
MediaRecorderOptions
&
aInitDict
)
{
SetMimeType
(
aInitDict
.
mMimeType
)
;
mAudioBitsPerSecond
=
aInitDict
.
mAudioBitsPerSecond
.
WasPassed
(
)
?
aInitDict
.
mAudioBitsPerSecond
.
Value
(
)
:
0
;
mVideoBitsPerSecond
=
aInitDict
.
mVideoBitsPerSecond
.
WasPassed
(
)
?
aInitDict
.
mVideoBitsPerSecond
.
Value
(
)
:
0
;
mBitsPerSecond
=
aInitDict
.
mBitsPerSecond
.
WasPassed
(
)
?
aInitDict
.
mBitsPerSecond
.
Value
(
)
:
0
;
if
(
aInitDict
.
mBitsPerSecond
.
WasPassed
(
)
&
&
!
aInitDict
.
mVideoBitsPerSecond
.
WasPassed
(
)
)
{
mVideoBitsPerSecond
=
mBitsPerSecond
;
}
}
static
char
const
*
const
gWebMAudioEncoderCodecs
[
3
]
=
{
"
vorbis
"
"
opus
"
nullptr
}
;
static
char
const
*
const
gWebMVideoEncoderCodecs
[
5
]
=
{
"
vorbis
"
"
opus
"
"
vp8
"
"
vp8
.
0
"
nullptr
}
;
static
char
const
*
const
gOggAudioEncoderCodecs
[
2
]
=
{
"
opus
"
nullptr
}
;
template
<
class
String
>
static
bool
CodecListContains
(
char
const
*
const
*
aCodecs
const
String
&
aCodec
)
{
for
(
int32_t
i
=
0
;
aCodecs
[
i
]
;
+
+
i
)
{
if
(
aCodec
.
EqualsASCII
(
aCodecs
[
i
]
)
)
return
true
;
}
return
false
;
}
bool
MediaRecorder
:
:
IsTypeSupported
(
GlobalObject
&
aGlobal
const
nsAString
&
aMIMEType
)
{
return
IsTypeSupported
(
aMIMEType
)
;
}
bool
MediaRecorder
:
:
IsTypeSupported
(
const
nsAString
&
aMIMEType
)
{
char
const
*
const
*
codeclist
=
nullptr
;
if
(
aMIMEType
.
IsEmpty
(
)
)
{
return
true
;
}
nsContentTypeParser
parser
(
aMIMEType
)
;
nsAutoString
mimeType
;
nsresult
rv
=
parser
.
GetType
(
mimeType
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
mimeType
.
EqualsLiteral
(
AUDIO_OGG
)
)
{
if
(
MediaDecoder
:
:
IsOggEnabled
(
)
&
&
MediaDecoder
:
:
IsOpusEnabled
(
)
)
{
codeclist
=
gOggAudioEncoderCodecs
;
}
}
#
ifdef
MOZ_WEBM_ENCODER
else
if
(
mimeType
.
EqualsLiteral
(
VIDEO_WEBM
)
&
&
MediaEncoder
:
:
IsWebMEncoderEnabled
(
)
)
{
codeclist
=
gWebMVideoEncoderCodecs
;
}
#
endif
#
ifdef
MOZ_OMX_ENCODER
else
if
(
mimeType
.
EqualsLiteral
(
VIDEO_MP4
)
|
|
mimeType
.
EqualsLiteral
(
AUDIO_3GPP
)
|
|
mimeType
.
EqualsLiteral
(
AUDIO_3GPP2
)
)
{
if
(
MediaEncoder
:
:
IsOMXEncoderEnabled
(
)
)
{
return
true
;
}
}
#
endif
if
(
!
codeclist
)
{
return
false
;
}
nsAutoString
codecstring
;
rv
=
parser
.
GetParameter
(
"
codecs
"
codecstring
)
;
nsTArray
<
nsString
>
codecs
;
if
(
!
ParseCodecsString
(
codecstring
codecs
)
)
{
return
false
;
}
for
(
const
nsString
&
codec
:
codecs
)
{
if
(
!
CodecListContains
(
codeclist
codec
)
)
{
return
false
;
}
}
return
true
;
}
nsresult
MediaRecorder
:
:
CreateAndDispatchBlobEvent
(
already_AddRefed
<
nsIDOMBlob
>
&
&
aBlob
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Not
running
on
main
thread
"
)
;
BlobEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
nsCOMPtr
<
nsIDOMBlob
>
blob
=
aBlob
;
init
.
mData
=
static_cast
<
Blob
*
>
(
blob
.
get
(
)
)
;
RefPtr
<
BlobEvent
>
event
=
BlobEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
dataavailable
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
return
DispatchDOMEvent
(
nullptr
event
nullptr
nullptr
)
;
}
void
MediaRecorder
:
:
DispatchSimpleEvent
(
const
nsAString
&
aStr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Not
running
on
main
thread
"
)
;
nsresult
rv
=
CheckInnerWindowCorrectness
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
RefPtr
<
Event
>
event
=
NS_NewDOMEvent
(
this
nullptr
nullptr
)
;
event
-
>
InitEvent
(
aStr
false
false
)
;
event
-
>
SetTrusted
(
true
)
;
rv
=
DispatchDOMEvent
(
nullptr
event
nullptr
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ERROR
(
"
Failed
to
dispatch
the
event
!
!
!
"
)
;
return
;
}
}
void
MediaRecorder
:
:
NotifyError
(
nsresult
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Not
running
on
main
thread
"
)
;
nsresult
rv
=
CheckInnerWindowCorrectness
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsString
errorMsg
;
switch
(
aRv
)
{
case
NS_ERROR_DOM_SECURITY_ERR
:
errorMsg
=
NS_LITERAL_STRING
(
"
SecurityError
"
)
;
break
;
case
NS_ERROR_OUT_OF_MEMORY
:
errorMsg
=
NS_LITERAL_STRING
(
"
OutOfMemoryError
"
)
;
break
;
default
:
errorMsg
=
NS_LITERAL_STRING
(
"
GenericError
"
)
;
}
RecordErrorEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mName
=
errorMsg
;
RefPtr
<
RecordErrorEvent
>
event
=
RecordErrorEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
error
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
rv
=
DispatchDOMEvent
(
nullptr
event
nullptr
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ERROR
(
"
Failed
to
dispatch
the
error
event
!
!
!
"
)
;
return
;
}
return
;
}
void
MediaRecorder
:
:
RemoveSession
(
Session
*
aSession
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
RemoveSession
(
%
p
)
"
aSession
)
)
;
mSessions
.
RemoveElement
(
aSession
)
;
}
void
MediaRecorder
:
:
NotifyOwnerDocumentActivityChanged
(
)
{
nsPIDOMWindowInner
*
window
=
GetOwner
(
)
;
NS_ENSURE_TRUE_VOID
(
window
)
;
nsIDocument
*
doc
=
window
-
>
GetExtantDoc
(
)
;
NS_ENSURE_TRUE_VOID
(
doc
)
;
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
%
p
document
IsActive
%
d
isVisible
%
d
\
n
"
this
doc
-
>
IsActive
(
)
doc
-
>
IsVisible
(
)
)
)
;
if
(
!
doc
-
>
IsActive
(
)
|
|
!
doc
-
>
IsVisible
(
)
)
{
ErrorResult
result
;
Stop
(
result
)
;
result
.
SuppressException
(
)
;
}
}
MediaStream
*
MediaRecorder
:
:
GetSourceMediaStream
(
)
{
if
(
mDOMStream
!
=
nullptr
)
{
return
mDOMStream
-
>
GetPlaybackStream
(
)
;
}
MOZ_ASSERT
(
mAudioNode
!
=
nullptr
)
;
return
mPipeStream
?
mPipeStream
.
get
(
)
:
mAudioNode
-
>
GetStream
(
)
;
}
size_t
MediaRecorder
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
amount
=
42
;
for
(
size_t
i
=
0
;
i
<
mSessions
.
Length
(
)
;
+
+
i
)
{
amount
+
=
mSessions
[
i
]
-
>
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
return
amount
;
}
StaticRefPtr
<
MediaRecorderReporter
>
MediaRecorderReporter
:
:
sUniqueInstance
;
MediaRecorderReporter
*
MediaRecorderReporter
:
:
UniqueInstance
(
)
{
if
(
!
sUniqueInstance
)
{
sUniqueInstance
=
new
MediaRecorderReporter
(
)
;
sUniqueInstance
-
>
InitMemoryReporter
(
)
;
}
return
sUniqueInstance
;
}
void
MediaRecorderReporter
:
:
InitMemoryReporter
(
)
{
RegisterWeakMemoryReporter
(
this
)
;
}
MediaRecorderReporter
:
:
~
MediaRecorderReporter
(
)
{
UnregisterWeakMemoryReporter
(
this
)
;
}
}
}
