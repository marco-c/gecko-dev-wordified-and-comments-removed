#
include
"
MediaRecorder
.
h
"
#
include
"
AudioNodeEngine
.
h
"
#
include
"
AudioNodeTrack
.
h
"
#
include
"
DOMMediaStream
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
MediaDecoder
.
h
"
#
include
"
MediaEncoder
.
h
"
#
include
"
MediaTrackGraphImpl
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
dom
/
AudioStreamTrack
.
h
"
#
include
"
mozilla
/
dom
/
BlobEvent
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
MediaRecorderErrorEvent
.
h
"
#
include
"
mozilla
/
dom
/
MutableBlobStorage
.
h
"
#
include
"
mozilla
/
dom
/
VideoStreamTrack
.
h
"
#
include
"
mozilla
/
media
/
MediaUtils
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsContentTypeParser
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsError
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsTArray
.
h
"
mozilla
:
:
LazyLogModule
gMediaRecorderLog
(
"
MediaRecorder
"
)
;
#
define
LOG
(
type
msg
)
MOZ_LOG
(
gMediaRecorderLog
type
msg
)
#
define
MIN_VIDEO_BITRATE_BPS
10e3
/
/
10kbps
#
define
DEFAULT_VIDEO_BITRATE_BPS
2500e3
/
/
2
.
5Mbps
#
define
MAX_VIDEO_BITRATE_BPS
100e6
/
/
100Mbps
#
define
MIN_AUDIO_BITRATE_BPS
500
/
/
500bps
#
define
DEFAULT_AUDIO_BITRATE_BPS
128e3
/
/
128kbps
#
define
MAX_AUDIO_BITRATE_BPS
512e3
/
/
512kbps
namespace
mozilla
{
namespace
dom
{
using
namespace
mozilla
:
:
media
;
StaticRefPtr
<
nsIAsyncShutdownBlocker
>
gMediaRecorderShutdownBlocker
;
static
nsTHashtable
<
nsRefPtrHashKey
<
MediaRecorder
:
:
Session
>
>
gSessions
;
class
MediaRecorderReporter
final
:
public
nsIMemoryReporter
{
public
:
static
void
AddMediaRecorder
(
MediaRecorder
*
aRecorder
)
{
if
(
!
sUniqueInstance
)
{
sUniqueInstance
=
MakeAndAddRef
<
MediaRecorderReporter
>
(
)
;
RegisterWeakAsyncMemoryReporter
(
sUniqueInstance
)
;
}
sUniqueInstance
-
>
mRecorders
.
AppendElement
(
aRecorder
)
;
}
static
void
RemoveMediaRecorder
(
MediaRecorder
*
aRecorder
)
{
if
(
!
sUniqueInstance
)
{
return
;
}
sUniqueInstance
-
>
mRecorders
.
RemoveElement
(
aRecorder
)
;
if
(
sUniqueInstance
-
>
mRecorders
.
IsEmpty
(
)
)
{
UnregisterWeakMemoryReporter
(
sUniqueInstance
)
;
sUniqueInstance
=
nullptr
;
}
}
NS_DECL_THREADSAFE_ISUPPORTS
MediaRecorderReporter
(
)
=
default
;
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
nsTArray
<
RefPtr
<
MediaRecorder
:
:
SizeOfPromise
>
>
promises
;
for
(
const
RefPtr
<
MediaRecorder
>
&
recorder
:
mRecorders
)
{
promises
.
AppendElement
(
recorder
-
>
SizeOfExcludingThis
(
MallocSizeOf
)
)
;
}
nsCOMPtr
<
nsIHandleReportCallback
>
handleReport
=
aHandleReport
;
nsCOMPtr
<
nsISupports
>
data
=
aData
;
MediaRecorder
:
:
SizeOfPromise
:
:
All
(
GetCurrentThreadSerialEventTarget
(
)
promises
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
handleReport
data
]
(
const
nsTArray
<
size_t
>
&
sizes
)
{
nsCOMPtr
<
nsIMemoryReporterManager
>
manager
=
do_GetService
(
"
mozilla
.
org
/
memory
-
reporter
-
manager
;
1
"
)
;
if
(
!
manager
)
{
return
;
}
size_t
sum
=
0
;
for
(
const
size_t
&
size
:
sizes
)
{
sum
+
=
size
;
}
handleReport
-
>
Callback
(
EmptyCString
(
)
NS_LITERAL_CSTRING
(
"
explicit
/
media
/
recorder
"
)
KIND_HEAP
UNITS_BYTES
sum
NS_LITERAL_CSTRING
(
"
Memory
used
by
media
recorder
.
"
)
data
)
;
manager
-
>
EndReport
(
)
;
}
[
]
(
size_t
)
{
MOZ_CRASH
(
"
Unexpected
reject
"
)
;
}
)
;
return
NS_OK
;
}
private
:
MOZ_DEFINE_MALLOC_SIZE_OF
(
MallocSizeOf
)
virtual
~
MediaRecorderReporter
(
)
{
MOZ_ASSERT
(
mRecorders
.
IsEmpty
(
)
"
All
recorders
must
have
been
removed
"
)
;
}
static
StaticRefPtr
<
MediaRecorderReporter
>
sUniqueInstance
;
nsTArray
<
RefPtr
<
MediaRecorder
>
>
mRecorders
;
}
;
NS_IMPL_ISUPPORTS
(
MediaRecorderReporter
nsIMemoryReporter
)
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
MediaRecorder
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
MediaRecorder
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStream
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAudioNode
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSecurityDomException
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mUnknownDomException
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocument
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
MediaRecorder
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mStream
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAudioNode
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSecurityDomException
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mUnknownDomException
)
tmp
-
>
UnRegisterActivityObserver
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocument
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
MediaRecorder
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentActivity
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
NS_IMPL_ADDREF_INHERITED
(
MediaRecorder
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
MediaRecorder
DOMEventTargetHelper
)
static
bool
PrincipalSubsumes
(
MediaRecorder
*
aRecorder
nsIPrincipal
*
aPrincipal
)
{
if
(
!
aRecorder
-
>
GetOwner
(
)
)
{
return
false
;
}
nsCOMPtr
<
Document
>
doc
=
aRecorder
-
>
GetOwner
(
)
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
false
;
}
if
(
!
aPrincipal
)
{
return
false
;
}
bool
subsumes
;
if
(
NS_FAILED
(
doc
-
>
NodePrincipal
(
)
-
>
Subsumes
(
aPrincipal
&
subsumes
)
)
)
{
return
false
;
}
return
subsumes
;
}
static
bool
MediaStreamTracksPrincipalSubsumes
(
MediaRecorder
*
aRecorder
const
nsTArray
<
RefPtr
<
MediaStreamTrack
>
>
&
aTracks
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
nullptr
;
for
(
const
auto
&
track
:
aTracks
)
{
nsContentUtils
:
:
CombineResourcePrincipals
(
&
principal
track
-
>
GetPrincipal
(
)
)
;
}
return
PrincipalSubsumes
(
aRecorder
principal
)
;
}
static
bool
AudioNodePrincipalSubsumes
(
MediaRecorder
*
aRecorder
AudioNode
*
aAudioNode
)
{
MOZ_ASSERT
(
aAudioNode
)
;
Document
*
doc
=
aAudioNode
-
>
GetOwner
(
)
?
aAudioNode
-
>
GetOwner
(
)
-
>
GetExtantDoc
(
)
:
nullptr
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
doc
?
doc
-
>
NodePrincipal
(
)
:
nullptr
;
return
PrincipalSubsumes
(
aRecorder
principal
)
;
}
static
void
SelectBitrates
(
uint32_t
aBitsPerSecond
uint8_t
aNumVideoTracks
uint32_t
*
aOutVideoBps
uint8_t
aNumAudioTracks
uint32_t
*
aOutAudioBps
)
{
uint32_t
vbps
=
0
;
uint32_t
abps
=
0
;
const
uint32_t
minVideoBps
=
MIN_VIDEO_BITRATE_BPS
*
aNumVideoTracks
;
const
uint32_t
maxVideoBps
=
MAX_VIDEO_BITRATE_BPS
*
aNumVideoTracks
;
const
uint32_t
minAudioBps
=
MIN_AUDIO_BITRATE_BPS
*
aNumAudioTracks
;
const
uint32_t
maxAudioBps
=
MAX_AUDIO_BITRATE_BPS
*
aNumAudioTracks
;
if
(
aNumVideoTracks
=
=
0
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aNumAudioTracks
>
0
)
;
abps
=
std
:
:
min
(
maxAudioBps
std
:
:
max
(
minAudioBps
aBitsPerSecond
)
)
;
}
else
if
(
aNumAudioTracks
=
=
0
)
{
vbps
=
std
:
:
min
(
maxVideoBps
std
:
:
max
(
minVideoBps
aBitsPerSecond
)
)
;
}
else
{
const
uint32_t
videoWeight
=
aNumVideoTracks
*
20
;
const
uint32_t
audioWeight
=
aNumAudioTracks
;
const
uint32_t
totalWeights
=
audioWeight
+
videoWeight
;
const
uint32_t
videoBitrate
=
uint64_t
(
aBitsPerSecond
)
*
videoWeight
/
totalWeights
;
const
uint32_t
audioBitrate
=
uint64_t
(
aBitsPerSecond
)
*
audioWeight
/
totalWeights
;
vbps
=
std
:
:
min
(
maxVideoBps
std
:
:
max
(
minVideoBps
videoBitrate
)
)
;
abps
=
std
:
:
min
(
maxAudioBps
std
:
:
max
(
minAudioBps
audioBitrate
)
)
;
}
*
aOutVideoBps
=
vbps
;
*
aOutAudioBps
=
abps
;
}
class
MediaRecorder
:
:
Session
:
public
PrincipalChangeObserver
<
MediaStreamTrack
>
public
DOMMediaStream
:
:
TrackListener
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Session
)
class
StoreEncodedBufferRunnable
final
:
public
Runnable
{
RefPtr
<
Session
>
mSession
;
nsTArray
<
nsTArray
<
uint8_t
>
>
mBuffer
;
public
:
StoreEncodedBufferRunnable
(
Session
*
aSession
nsTArray
<
nsTArray
<
uint8_t
>
>
&
&
aBuffer
)
:
Runnable
(
"
StoreEncodedBufferRunnable
"
)
mSession
(
aSession
)
mBuffer
(
std
:
:
move
(
aBuffer
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mSession
-
>
MaybeCreateMutableBlobStorage
(
)
;
for
(
const
auto
&
part
:
mBuffer
)
{
if
(
part
.
IsEmpty
(
)
)
{
continue
;
}
nsresult
rv
=
mSession
-
>
mMutableBlobStorage
-
>
Append
(
part
.
Elements
(
)
part
.
Length
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mSession
-
>
DoSessionEndTask
(
rv
)
;
break
;
}
}
return
NS_OK
;
}
}
;
class
EncoderListener
:
public
MediaEncoderListener
{
public
:
EncoderListener
(
TaskQueue
*
aEncoderThread
Session
*
aSession
)
:
mEncoderThread
(
aEncoderThread
)
mSession
(
aSession
)
{
}
void
Forget
(
)
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
mSession
=
nullptr
;
}
void
Initialized
(
)
override
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
if
(
mSession
)
{
mSession
-
>
MediaEncoderInitialized
(
)
;
}
}
void
DataAvailable
(
)
override
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
if
(
mSession
)
{
mSession
-
>
MediaEncoderDataAvailable
(
)
;
}
}
void
Error
(
)
override
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
if
(
mSession
)
{
mSession
-
>
MediaEncoderError
(
)
;
}
}
void
Shutdown
(
)
override
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
if
(
mSession
)
{
mSession
-
>
MediaEncoderShutdown
(
)
;
}
}
protected
:
RefPtr
<
TaskQueue
>
mEncoderThread
;
RefPtr
<
Session
>
mSession
;
}
;
public
:
Session
(
MediaRecorder
*
aRecorder
nsTArray
<
RefPtr
<
MediaStreamTrack
>
>
aMediaStreamTracks
TimeDuration
aTimeslice
uint32_t
aVideoBitsPerSecond
uint32_t
aAudioBitsPerSecond
)
:
mRecorder
(
aRecorder
)
mMediaStreamTracks
(
std
:
:
move
(
aMediaStreamTracks
)
)
mMainThread
(
mRecorder
-
>
GetOwner
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
mTimeslice
(
aTimeslice
)
mVideoBitsPerSecond
(
aVideoBitsPerSecond
)
mAudioBitsPerSecond
(
aAudioBitsPerSecond
)
mStartTime
(
TimeStamp
:
:
Now
(
)
)
mRunningState
(
RunningState
:
:
Idling
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aRecorder
-
>
GetMimeType
(
mMimeType
)
;
mMaxMemory
=
Preferences
:
:
GetUint
(
"
media
.
recorder
.
max_memory
"
MAX_ALLOW_MEMORY_BUFFER
)
;
mLastBlobTimeStamp
=
mStartTime
;
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
MEDIARECORDER_RECORDING_COUNT
1
)
;
}
void
PrincipalChanged
(
MediaStreamTrack
*
aTrack
)
override
{
NS_ASSERTION
(
mMediaStreamTracks
.
Contains
(
aTrack
)
"
Principal
changed
for
unrecorded
track
"
)
;
if
(
!
MediaStreamTracksPrincipalSubsumes
(
mRecorder
mMediaStreamTracks
)
)
{
DoSessionEndTask
(
NS_ERROR_DOM_SECURITY_ERR
)
;
}
}
void
NotifyTrackAdded
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
override
{
LOG
(
LogLevel
:
:
Warning
(
"
Session
.
NotifyTrackAdded
%
p
Raising
error
due
to
track
set
change
"
this
)
)
;
DoSessionEndTask
(
NS_ERROR_ABORT
)
;
}
void
NotifyTrackRemoved
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
override
{
if
(
aTrack
-
>
Ended
(
)
)
{
return
;
}
MOZ_ASSERT
(
mEncoder
)
;
if
(
mEncoder
)
{
mEncoder
-
>
RemoveMediaStreamTrack
(
aTrack
)
;
}
LOG
(
LogLevel
:
:
Warning
(
"
Session
.
NotifyTrackRemoved
%
p
Raising
error
due
to
track
set
change
"
this
)
)
;
DoSessionEndTask
(
NS_ERROR_ABORT
)
;
}
void
Start
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Start
%
p
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mRecorder
-
>
mStream
)
{
mMediaStream
=
mRecorder
-
>
mStream
;
mMediaStream
-
>
RegisterTrackListener
(
this
)
;
uint8_t
trackTypes
=
0
;
int32_t
audioTracks
=
0
;
int32_t
videoTracks
=
0
;
for
(
const
auto
&
track
:
mMediaStreamTracks
)
{
if
(
track
-
>
AsAudioStreamTrack
(
)
)
{
+
+
audioTracks
;
trackTypes
|
=
ContainerWriter
:
:
CREATE_AUDIO_TRACK
;
}
else
if
(
track
-
>
AsVideoStreamTrack
(
)
)
{
+
+
videoTracks
;
trackTypes
|
=
ContainerWriter
:
:
CREATE_VIDEO_TRACK
;
}
else
{
MOZ_CRASH
(
"
Unexpected
track
type
"
)
;
}
}
if
(
audioTracks
>
1
|
|
videoTracks
>
1
)
{
nsPIDOMWindowInner
*
window
=
mRecorder
-
>
GetOwner
(
)
;
Document
*
document
=
window
?
window
-
>
GetExtantDoc
(
)
:
nullptr
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
NS_LITERAL_CSTRING
(
"
Media
"
)
document
nsContentUtils
:
:
eDOM_PROPERTIES
"
MediaRecorderMultiTracksNotSupported
"
)
;
DoSessionEndTask
(
NS_ERROR_ABORT
)
;
return
;
}
for
(
const
auto
&
t
:
mMediaStreamTracks
)
{
t
-
>
AddPrincipalChangeObserver
(
this
)
;
}
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Start
track
types
=
(
%
d
)
"
trackTypes
)
)
;
InitEncoder
(
trackTypes
mMediaStreamTracks
[
0
]
-
>
Graph
(
)
-
>
GraphRate
(
)
)
;
return
;
}
if
(
mRecorder
-
>
mAudioNode
)
{
TrackRate
trackRate
=
mRecorder
-
>
mAudioNode
-
>
Context
(
)
-
>
Graph
(
)
-
>
GraphRate
(
)
;
InitEncoder
(
ContainerWriter
:
:
CREATE_AUDIO_TRACK
trackRate
)
;
return
;
}
MOZ_ASSERT
(
false
"
Unknown
source
"
)
;
}
void
Stop
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Stop
%
p
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mEncoder
)
{
mEncoder
-
>
Stop
(
)
;
}
if
(
mMediaStream
)
{
mMediaStream
-
>
UnregisterTrackListener
(
this
)
;
mMediaStream
=
nullptr
;
}
{
for
(
const
auto
&
track
:
mMediaStreamTracks
)
{
track
-
>
RemovePrincipalChangeObserver
(
this
)
;
}
}
if
(
mRunningState
.
isOk
(
)
&
&
mRunningState
.
inspect
(
)
=
=
RunningState
:
:
Idling
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Stop
Explicit
end
task
%
p
"
this
)
)
;
DoSessionEndTask
(
NS_OK
)
;
}
else
if
(
mRunningState
.
isOk
(
)
&
&
(
mRunningState
.
inspect
(
)
=
=
RunningState
:
:
Starting
|
|
mRunningState
.
inspect
(
)
=
=
RunningState
:
:
Running
)
)
{
mRunningState
=
RunningState
:
:
Stopping
;
}
}
void
Pause
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Pause
"
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT_IF
(
mRunningState
.
isOk
(
)
mRunningState
.
unwrap
(
)
!
=
RunningState
:
:
Idling
)
;
if
(
mRunningState
.
isErr
(
)
|
|
mRunningState
.
unwrap
(
)
=
=
RunningState
:
:
Stopping
|
|
mRunningState
.
unwrap
(
)
=
=
RunningState
:
:
Stopped
)
{
return
;
}
MOZ_ASSERT
(
mEncoder
)
;
mEncoder
-
>
Suspend
(
)
;
}
void
Resume
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Resume
"
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT_IF
(
mRunningState
.
isOk
(
)
mRunningState
.
unwrap
(
)
!
=
RunningState
:
:
Idling
)
;
if
(
mRunningState
.
isErr
(
)
|
|
mRunningState
.
unwrap
(
)
=
=
RunningState
:
:
Stopping
|
|
mRunningState
.
unwrap
(
)
=
=
RunningState
:
:
Stopped
)
{
return
;
}
MOZ_ASSERT
(
mEncoder
)
;
mEncoder
-
>
Resume
(
)
;
}
void
RequestData
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
RequestData
"
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
GatherBlob
(
)
-
>
Then
(
mMainThread
__func__
[
this
self
=
RefPtr
<
Session
>
(
this
)
]
(
const
BlobPromise
:
:
ResolveOrRejectValue
&
aResult
)
{
if
(
aResult
.
IsReject
(
)
)
{
LOG
(
LogLevel
:
:
Warning
(
"
GatherBlob
failed
for
RequestData
(
)
"
)
)
;
DoSessionEndTask
(
aResult
.
RejectValue
(
)
)
;
return
;
}
nsresult
rv
=
mRecorder
-
>
CreateAndDispatchBlobEvent
(
aResult
.
ResolveValue
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
DoSessionEndTask
(
NS_OK
)
;
}
}
)
;
}
void
MaybeCreateMutableBlobStorage
(
)
{
if
(
!
mMutableBlobStorage
)
{
mMutableBlobStorage
=
new
MutableBlobStorage
(
MutableBlobStorage
:
:
eCouldBeInTemporaryFile
nullptr
mMaxMemory
)
;
}
}
static
const
bool
IsExclusive
=
false
;
using
BlobPromise
=
MozPromise
<
nsMainThreadPtrHandle
<
Blob
>
nsresult
IsExclusive
>
;
class
BlobStorer
:
public
MutableBlobStorageCallback
{
MozPromiseHolder
<
BlobPromise
>
mHolder
;
virtual
~
BlobStorer
(
)
=
default
;
public
:
BlobStorer
(
)
=
default
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
BlobStorer
override
)
void
BlobStoreCompleted
(
MutableBlobStorage
*
Blob
*
aBlob
nsresult
aRv
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_FAILED
(
aRv
)
)
{
mHolder
.
Reject
(
aRv
__func__
)
;
}
else
{
mHolder
.
Resolve
(
nsMainThreadPtrHandle
<
Blob
>
(
MakeAndAddRef
<
nsMainThreadPtrHolder
<
Blob
>
>
(
"
BlobStorer
:
:
ResolveBlob
"
aBlob
)
)
__func__
)
;
}
}
RefPtr
<
BlobPromise
>
Promise
(
)
{
return
mHolder
.
Ensure
(
__func__
)
;
}
}
;
protected
:
RefPtr
<
BlobPromise
>
GatherBlobImpl
(
)
{
RefPtr
<
BlobStorer
>
storer
=
MakeAndAddRef
<
BlobStorer
>
(
)
;
MaybeCreateMutableBlobStorage
(
)
;
mMutableBlobStorage
-
>
GetBlobWhenReady
(
mRecorder
-
>
GetOwner
(
)
NS_ConvertUTF16toUTF8
(
mMimeType
)
storer
)
;
mMutableBlobStorage
=
nullptr
;
storer
-
>
Promise
(
)
-
>
Then
(
mMainThread
__func__
[
self
=
RefPtr
<
Session
>
(
this
)
p
=
storer
-
>
Promise
(
)
]
{
if
(
self
-
>
mBlobPromise
=
=
p
)
{
self
-
>
mBlobPromise
=
nullptr
;
}
}
)
;
return
storer
-
>
Promise
(
)
;
}
public
:
RefPtr
<
BlobPromise
>
GatherBlob
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mBlobPromise
)
{
return
mBlobPromise
=
GatherBlobImpl
(
)
;
}
return
mBlobPromise
=
mBlobPromise
-
>
Then
(
mMainThread
__func__
[
self
=
RefPtr
<
Session
>
(
this
)
]
{
return
self
-
>
GatherBlobImpl
(
)
;
}
)
;
}
RefPtr
<
SizeOfPromise
>
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
size_t
encodedBufferSize
=
mMutableBlobStorage
?
mMutableBlobStorage
-
>
SizeOfCurrentMemoryBuffer
(
)
:
0
;
if
(
!
mEncoder
)
{
return
SizeOfPromise
:
:
CreateAndResolve
(
encodedBufferSize
__func__
)
;
}
auto
&
encoder
=
mEncoder
;
return
InvokeAsync
(
mEncoderThread
__func__
[
encoder
encodedBufferSize
aMallocSizeOf
]
(
)
{
return
SizeOfPromise
:
:
CreateAndResolve
(
encodedBufferSize
+
encoder
-
>
SizeOfExcludingThis
(
aMallocSizeOf
)
__func__
)
;
}
)
;
}
private
:
virtual
~
Session
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mShutdownPromise
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
~
Session
(
%
p
)
"
this
)
)
;
}
void
Extract
(
bool
aForceFlush
)
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
Extract
%
p
"
this
)
)
;
AUTO_PROFILER_LABEL
(
"
MediaRecorder
:
:
Session
:
:
Extract
"
OTHER
)
;
nsTArray
<
nsTArray
<
uint8_t
>
>
encodedBuf
;
nsresult
rv
=
mEncoder
-
>
GetEncodedData
(
&
encodedBuf
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_RELEASE_ASSERT
(
encodedBuf
.
IsEmpty
(
)
)
;
}
NS_DispatchToMainThread
(
new
StoreEncodedBufferRunnable
(
this
std
:
:
move
(
encodedBuf
)
)
)
;
bool
pushBlob
=
aForceFlush
;
if
(
!
pushBlob
&
&
(
TimeStamp
:
:
Now
(
)
-
mLastBlobTimeStamp
)
>
mTimeslice
)
{
pushBlob
=
true
;
}
if
(
pushBlob
)
{
mLastBlobTimeStamp
=
TimeStamp
:
:
Now
(
)
;
InvokeAsync
(
mMainThread
this
__func__
&
Session
:
:
GatherBlob
)
-
>
Then
(
mMainThread
__func__
[
this
self
=
RefPtr
<
Session
>
(
this
)
]
(
const
BlobPromise
:
:
ResolveOrRejectValue
&
aResult
)
{
if
(
aResult
.
IsReject
(
)
)
{
LOG
(
LogLevel
:
:
Warning
(
"
GatherBlob
failed
for
pushing
blob
"
)
)
;
DoSessionEndTask
(
aResult
.
RejectValue
(
)
)
;
return
;
}
nsresult
rv
=
mRecorder
-
>
CreateAndDispatchBlobEvent
(
aResult
.
ResolveValue
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
DoSessionEndTask
(
NS_OK
)
;
}
}
)
;
}
}
void
InitEncoder
(
uint8_t
aTrackTypes
TrackRate
aTrackRate
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
InitEncoder
%
p
"
this
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mRunningState
.
isOk
(
)
|
|
mRunningState
.
inspect
(
)
!
=
RunningState
:
:
Idling
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Double
-
init
"
)
;
return
;
}
MOZ_RELEASE_ASSERT
(
!
mEncoderThread
)
;
RefPtr
<
SharedThreadPool
>
pool
=
GetMediaThreadPool
(
MediaThreadType
:
:
WEBRTC_DECODER
)
;
if
(
!
pool
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Session
.
InitEncoder
%
p
Failed
to
create
"
"
MediaRecorderReadThread
thread
pool
"
this
)
)
;
DoSessionEndTask
(
NS_ERROR_FAILURE
)
;
return
;
}
mEncoderThread
=
MakeAndAddRef
<
TaskQueue
>
(
pool
.
forget
(
)
"
MediaRecorderReadThread
"
)
;
if
(
!
gMediaRecorderShutdownBlocker
)
{
class
Blocker
:
public
ShutdownBlocker
{
public
:
Blocker
(
)
:
ShutdownBlocker
(
NS_LITERAL_STRING
(
"
MediaRecorder
:
:
Session
:
shutdown
"
)
)
{
}
NS_IMETHOD
BlockShutdown
(
nsIAsyncShutdownClient
*
)
override
{
RefPtr
<
ShutdownTicket
>
ticket
=
MakeAndAddRef
<
ShutdownTicket
>
(
gMediaRecorderShutdownBlocker
)
;
gMediaRecorderShutdownBlocker
=
nullptr
;
nsTArray
<
RefPtr
<
ShutdownPromise
>
>
promises
(
gSessions
.
Count
(
)
)
;
for
(
auto
iter
=
gSessions
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
promises
.
AppendElement
(
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
Shutdown
(
)
)
;
}
gSessions
.
Clear
(
)
;
ShutdownPromise
:
:
All
(
GetCurrentThreadSerialEventTarget
(
)
promises
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
ticket
]
(
)
mutable
{
MOZ_ASSERT
(
gSessions
.
Count
(
)
=
=
0
)
;
ticket
=
nullptr
;
}
[
]
(
)
{
MOZ_CRASH
(
"
Not
reached
"
)
;
}
)
;
return
NS_OK
;
}
}
;
gMediaRecorderShutdownBlocker
=
MakeAndAddRef
<
Blocker
>
(
)
;
RefPtr
<
nsIAsyncShutdownClient
>
barrier
=
GetShutdownBarrier
(
)
;
nsresult
rv
=
barrier
-
>
AddBlocker
(
gMediaRecorderShutdownBlocker
NS_LITERAL_STRING
(
__FILE__
)
__LINE__
NS_LITERAL_STRING
(
"
MediaRecorder
:
:
Session
:
shutdown
"
)
)
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
gSessions
.
PutEntry
(
this
)
;
mEncoder
=
MediaEncoder
:
:
CreateEncoder
(
mEncoderThread
mMimeType
mAudioBitsPerSecond
mVideoBitsPerSecond
aTrackTypes
aTrackRate
)
;
if
(
!
mEncoder
)
{
LOG
(
LogLevel
:
:
Error
(
"
Session
.
InitEncoder
!
mEncoder
%
p
"
this
)
)
;
DoSessionEndTask
(
NS_ERROR_ABORT
)
;
return
;
}
mEncoderListener
=
MakeAndAddRef
<
EncoderListener
>
(
mEncoderThread
this
)
;
nsresult
rv
=
mEncoderThread
-
>
Dispatch
(
NewRunnableMethod
<
RefPtr
<
EncoderListener
>
>
(
"
mozilla
:
:
MediaEncoder
:
:
RegisterListener
"
mEncoder
&
MediaEncoder
:
:
RegisterListener
mEncoderListener
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
Unused
<
<
rv
;
if
(
mRecorder
-
>
mAudioNode
)
{
mEncoder
-
>
ConnectAudioNode
(
mRecorder
-
>
mAudioNode
mRecorder
-
>
mAudioNodeOutput
)
;
}
for
(
const
auto
&
track
:
mMediaStreamTracks
)
{
mEncoder
-
>
ConnectMediaStreamTrack
(
track
)
;
}
mEncoder
-
>
SetVideoKeyFrameInterval
(
std
:
:
max
(
TimeDuration
:
:
FromSeconds
(
1
)
mTimeslice
)
.
ToMilliseconds
(
)
)
;
mRunningState
=
RunningState
:
:
Starting
;
}
void
DoSessionEndTask
(
nsresult
rv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mRunningState
.
isErr
(
)
)
{
return
;
}
if
(
mRunningState
.
isOk
(
)
&
&
mRunningState
.
inspect
(
)
=
=
RunningState
:
:
Stopped
)
{
return
;
}
bool
needsStartEvent
=
false
;
if
(
mRunningState
.
isOk
(
)
&
&
(
mRunningState
.
inspect
(
)
=
=
RunningState
:
:
Idling
|
|
mRunningState
.
inspect
(
)
=
=
RunningState
:
:
Starting
)
)
{
needsStartEvent
=
true
;
}
if
(
rv
=
=
NS_OK
)
{
mRunningState
=
RunningState
:
:
Stopped
;
}
else
{
mRunningState
=
Err
(
rv
)
;
}
GatherBlob
(
)
-
>
Then
(
mMainThread
__func__
[
this
self
=
RefPtr
<
Session
>
(
this
)
rv
needsStartEvent
]
(
const
BlobPromise
:
:
ResolveOrRejectValue
&
aResult
)
{
if
(
mRecorder
-
>
mSessions
.
LastElement
(
)
=
=
this
)
{
mRecorder
-
>
Inactivate
(
)
;
}
if
(
needsStartEvent
)
{
mRecorder
-
>
DispatchSimpleEvent
(
NS_LITERAL_STRING
(
"
start
"
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
mRecorder
-
>
NotifyError
(
rv
)
;
}
RefPtr
<
Blob
>
blob
;
if
(
rv
=
=
NS_ERROR_DOM_SECURITY_ERR
|
|
aResult
.
IsReject
(
)
)
{
blob
=
Blob
:
:
CreateEmptyBlob
(
mRecorder
-
>
GetParentObject
(
)
mMimeType
)
;
}
else
{
blob
=
aResult
.
ResolveValue
(
)
;
}
if
(
NS_FAILED
(
mRecorder
-
>
CreateAndDispatchBlobEvent
(
blob
)
)
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
mRecorder
-
>
NotifyError
(
NS_ERROR_FAILURE
)
;
}
}
mMimeType
=
NS_LITERAL_STRING
(
"
"
)
;
mRecorder
-
>
SetMimeType
(
mMimeType
)
;
mRecorder
-
>
DispatchSimpleEvent
(
NS_LITERAL_STRING
(
"
stop
"
)
)
;
return
Shutdown
(
)
;
}
)
-
>
Then
(
mMainThread
__func__
[
this
self
=
RefPtr
<
Session
>
(
this
)
]
{
gSessions
.
RemoveEntry
(
this
)
;
if
(
gSessions
.
Count
(
)
=
=
0
&
&
gMediaRecorderShutdownBlocker
)
{
RefPtr
<
nsIAsyncShutdownClient
>
barrier
=
GetShutdownBarrier
(
)
;
barrier
-
>
RemoveBlocker
(
gMediaRecorderShutdownBlocker
)
;
gMediaRecorderShutdownBlocker
=
nullptr
;
}
}
)
;
}
void
MediaEncoderInitialized
(
)
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
NS_DispatchToMainThread
(
NewRunnableFrom
(
[
self
=
RefPtr
<
Session
>
(
this
)
this
mime
=
mEncoder
-
>
MimeType
(
)
]
(
)
{
if
(
mRunningState
.
isErr
(
)
)
{
return
NS_OK
;
}
mMimeType
=
mime
;
mRecorder
-
>
SetMimeType
(
mime
)
;
RunningState
state
=
mRunningState
.
inspect
(
)
;
if
(
state
=
=
RunningState
:
:
Starting
|
|
state
=
=
RunningState
:
:
Stopping
)
{
if
(
state
=
=
RunningState
:
:
Starting
)
{
mRunningState
=
RunningState
:
:
Running
;
}
mRecorder
-
>
DispatchSimpleEvent
(
NS_LITERAL_STRING
(
"
start
"
)
)
;
}
return
NS_OK
;
}
)
)
;
Extract
(
false
)
;
}
void
MediaEncoderDataAvailable
(
)
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
Extract
(
false
)
;
}
void
MediaEncoderError
(
)
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
NS_DispatchToMainThread
(
NewRunnableMethod
<
nsresult
>
(
"
dom
:
:
MediaRecorder
:
:
Session
:
:
DoSessionEndTask
"
this
&
Session
:
:
DoSessionEndTask
NS_ERROR_FAILURE
)
)
;
}
void
MediaEncoderShutdown
(
)
{
MOZ_ASSERT
(
mEncoderThread
-
>
IsCurrentThreadIn
(
)
)
;
MOZ_ASSERT
(
mEncoder
-
>
IsShutdown
(
)
)
;
mMainThread
-
>
Dispatch
(
NewRunnableMethod
<
nsresult
>
(
"
MediaRecorder
:
:
Session
:
:
MediaEncoderShutdown
-
>
DoSessionEndTask
"
this
&
Session
:
:
DoSessionEndTask
NS_OK
)
)
;
mEncoderListener
-
>
Forget
(
)
;
DebugOnly
<
bool
>
unregistered
=
mEncoder
-
>
UnregisterListener
(
mEncoderListener
)
;
MOZ_ASSERT
(
unregistered
)
;
}
RefPtr
<
ShutdownPromise
>
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Session
Shutdown
%
p
"
this
)
)
;
if
(
mShutdownPromise
)
{
return
mShutdownPromise
;
}
TimeDuration
timeDelta
=
TimeStamp
:
:
Now
(
)
-
mStartTime
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MEDIA_RECORDER_RECORDING_DURATION
timeDelta
.
ToSeconds
(
)
)
;
mShutdownPromise
=
ShutdownPromise
:
:
CreateAndResolve
(
true
__func__
)
;
RefPtr
<
Session
>
self
=
this
;
if
(
mEncoder
)
{
auto
&
encoder
=
mEncoder
;
encoder
-
>
Cancel
(
)
;
MOZ_RELEASE_ASSERT
(
mEncoderListener
)
;
auto
&
encoderListener
=
mEncoderListener
;
mShutdownPromise
=
mShutdownPromise
-
>
Then
(
mEncoderThread
__func__
[
encoder
encoderListener
]
(
)
{
encoder
-
>
UnregisterListener
(
encoderListener
)
;
encoderListener
-
>
Forget
(
)
;
return
ShutdownPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
[
]
(
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
reject
"
)
;
return
ShutdownPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
;
}
if
(
mMediaStream
)
{
mMediaStream
-
>
UnregisterTrackListener
(
this
)
;
mMediaStream
=
nullptr
;
}
{
auto
tracks
(
std
:
:
move
(
mMediaStreamTracks
)
)
;
for
(
RefPtr
<
MediaStreamTrack
>
&
track
:
tracks
)
{
track
-
>
RemovePrincipalChangeObserver
(
this
)
;
}
}
mShutdownPromise
=
mShutdownPromise
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
self
]
(
)
{
self
-
>
mRecorder
-
>
RemoveSession
(
self
)
;
return
ShutdownPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
[
]
(
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
reject
"
)
;
return
ShutdownPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
;
if
(
mEncoderThread
)
{
RefPtr
<
TaskQueue
>
&
encoderThread
=
mEncoderThread
;
mShutdownPromise
=
mShutdownPromise
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
encoderThread
]
(
)
{
return
encoderThread
-
>
BeginShutdown
(
)
;
}
[
]
(
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
reject
"
)
;
return
ShutdownPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
;
}
return
mShutdownPromise
;
}
private
:
enum
class
RunningState
{
Idling
Starting
Running
Stopping
Stopped
}
;
const
RefPtr
<
MediaRecorder
>
mRecorder
;
RefPtr
<
DOMMediaStream
>
mMediaStream
;
nsTArray
<
RefPtr
<
MediaStreamTrack
>
>
mMediaStreamTracks
;
const
RefPtr
<
nsISerialEventTarget
>
mMainThread
;
RefPtr
<
TaskQueue
>
mEncoderThread
;
RefPtr
<
MediaEncoder
>
mEncoder
;
RefPtr
<
EncoderListener
>
mEncoderListener
;
RefPtr
<
ShutdownPromise
>
mShutdownPromise
;
RefPtr
<
MutableBlobStorage
>
mMutableBlobStorage
;
uint64_t
mMaxMemory
;
RefPtr
<
BlobPromise
>
mBlobPromise
;
nsString
mMimeType
;
TimeStamp
mLastBlobTimeStamp
;
const
TimeDuration
mTimeslice
;
const
uint32_t
mVideoBitsPerSecond
;
const
uint32_t
mAudioBitsPerSecond
;
const
TimeStamp
mStartTime
;
Result
<
RunningState
nsresult
>
mRunningState
;
}
;
MediaRecorder
:
:
~
MediaRecorder
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
~
MediaRecorder
(
%
p
)
"
this
)
)
;
UnRegisterActivityObserver
(
)
;
}
MediaRecorder
:
:
MediaRecorder
(
nsPIDOMWindowInner
*
aOwnerWindow
)
:
DOMEventTargetHelper
(
aOwnerWindow
)
{
MOZ_ASSERT
(
aOwnerWindow
)
;
RegisterActivityObserver
(
)
;
}
void
MediaRecorder
:
:
RegisterActivityObserver
(
)
{
if
(
nsPIDOMWindowInner
*
window
=
GetOwner
(
)
)
{
mDocument
=
window
-
>
GetExtantDoc
(
)
;
if
(
mDocument
)
{
mDocument
-
>
RegisterActivityObserver
(
NS_ISUPPORTS_CAST
(
nsIDocumentActivity
*
this
)
)
;
}
}
}
void
MediaRecorder
:
:
UnRegisterActivityObserver
(
)
{
if
(
mDocument
)
{
mDocument
-
>
UnregisterActivityObserver
(
NS_ISUPPORTS_CAST
(
nsIDocumentActivity
*
this
)
)
;
}
}
void
MediaRecorder
:
:
SetMimeType
(
const
nsString
&
aMimeType
)
{
mMimeType
=
aMimeType
;
}
void
MediaRecorder
:
:
GetMimeType
(
nsString
&
aMimeType
)
{
aMimeType
=
mMimeType
;
}
void
MediaRecorder
:
:
Start
(
const
Optional
<
uint32_t
>
&
aTimeslice
ErrorResult
&
aResult
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
Start
%
p
"
this
)
)
;
InitializeDomExceptions
(
)
;
TimeDuration
timeslice
=
aTimeslice
.
WasPassed
(
)
?
TimeDuration
:
:
FromMilliseconds
(
aTimeslice
.
Value
(
)
)
:
TimeDuration
:
:
Forever
(
)
;
nsTArray
<
RefPtr
<
MediaStreamTrack
>
>
tracks
;
if
(
mStream
)
{
mStream
-
>
GetTracks
(
tracks
)
;
}
for
(
const
auto
&
t
:
nsTArray
<
RefPtr
<
MediaStreamTrack
>
>
(
tracks
)
)
{
if
(
t
-
>
Ended
(
)
)
{
tracks
.
RemoveElement
(
t
)
;
}
}
if
(
mState
!
=
RecordingState
:
:
Inactive
)
{
aResult
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
mStream
)
{
RefPtr
<
nsIPrincipal
>
streamPrincipal
=
mStream
-
>
GetPrincipal
(
)
;
if
(
!
PrincipalSubsumes
(
this
streamPrincipal
)
)
{
aResult
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
}
if
(
mAudioNode
&
&
!
AudioNodePrincipalSubsumes
(
this
mAudioNode
)
)
{
LOG
(
LogLevel
:
:
Warning
(
"
MediaRecorder
%
p
Start
AudioNode
principal
check
failed
"
this
)
)
;
aResult
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
mStream
&
&
!
mStream
-
>
Active
(
)
)
{
aResult
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
uint8_t
numVideoTracks
=
0
;
uint8_t
numAudioTracks
=
0
;
for
(
const
auto
&
t
:
tracks
)
{
if
(
t
-
>
AsVideoStreamTrack
(
)
&
&
numVideoTracks
<
UINT8_MAX
)
{
+
+
numVideoTracks
;
}
else
if
(
t
-
>
AsAudioStreamTrack
(
)
&
&
numAudioTracks
<
UINT8_MAX
)
{
+
+
numAudioTracks
;
}
}
if
(
mAudioNode
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mStream
)
;
+
+
numAudioTracks
;
}
if
(
mConstrainedBitsPerSecond
)
{
SelectBitrates
(
*
mConstrainedBitsPerSecond
numVideoTracks
&
mVideoBitsPerSecond
numAudioTracks
&
mAudioBitsPerSecond
)
;
}
const
uint32_t
videoBitrate
=
mVideoBitsPerSecond
;
const
uint32_t
audioBitrate
=
mAudioBitsPerSecond
;
mState
=
RecordingState
:
:
Recording
;
MediaRecorderReporter
:
:
AddMediaRecorder
(
this
)
;
mSessions
.
AppendElement
(
)
;
mSessions
.
LastElement
(
)
=
new
Session
(
this
std
:
:
move
(
tracks
)
timeslice
videoBitrate
audioBitrate
)
;
mSessions
.
LastElement
(
)
-
>
Start
(
)
;
}
void
MediaRecorder
:
:
Stop
(
ErrorResult
&
aResult
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
Stop
%
p
"
this
)
)
;
MediaRecorderReporter
:
:
RemoveMediaRecorder
(
this
)
;
if
(
mState
=
=
RecordingState
:
:
Inactive
)
{
return
;
}
Inactivate
(
)
;
MOZ_ASSERT
(
mSessions
.
Length
(
)
>
0
)
;
mSessions
.
LastElement
(
)
-
>
Stop
(
)
;
}
void
MediaRecorder
:
:
Pause
(
ErrorResult
&
aResult
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
Pause
%
p
"
this
)
)
;
if
(
mState
=
=
RecordingState
:
:
Inactive
)
{
aResult
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
mState
=
=
RecordingState
:
:
Paused
)
{
return
;
}
mState
=
RecordingState
:
:
Paused
;
MOZ_ASSERT
(
!
mSessions
.
IsEmpty
(
)
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
MediaRecorder
:
:
Pause
"
[
session
=
mSessions
.
LastElement
(
)
recorder
=
RefPtr
<
MediaRecorder
>
(
this
)
]
{
session
-
>
Pause
(
)
;
recorder
-
>
DispatchSimpleEvent
(
NS_LITERAL_STRING
(
"
pause
"
)
)
;
}
)
)
;
}
void
MediaRecorder
:
:
Resume
(
ErrorResult
&
aResult
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
Resume
%
p
"
this
)
)
;
if
(
mState
=
=
RecordingState
:
:
Inactive
)
{
aResult
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
mState
=
=
RecordingState
:
:
Recording
)
{
return
;
}
mState
=
RecordingState
:
:
Recording
;
MOZ_ASSERT
(
!
mSessions
.
IsEmpty
(
)
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
MediaRecorder
:
:
Resume
"
[
session
=
mSessions
.
LastElement
(
)
recorder
=
RefPtr
<
MediaRecorder
>
(
this
)
]
{
session
-
>
Resume
(
)
;
recorder
-
>
DispatchSimpleEvent
(
NS_LITERAL_STRING
(
"
resume
"
)
)
;
}
)
)
;
}
void
MediaRecorder
:
:
RequestData
(
ErrorResult
&
aResult
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
RequestData
%
p
"
this
)
)
;
if
(
mState
=
=
RecordingState
:
:
Inactive
)
{
aResult
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
MOZ_ASSERT
(
mSessions
.
Length
(
)
>
0
)
;
mSessions
.
LastElement
(
)
-
>
RequestData
(
)
;
}
JSObject
*
MediaRecorder
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MediaRecorder_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
MediaRecorder
>
MediaRecorder
:
:
Constructor
(
const
GlobalObject
&
aGlobal
DOMMediaStream
&
aStream
const
MediaRecorderOptions
&
aOptions
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
ownerWindow
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
ownerWindow
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
!
IsTypeSupported
(
aOptions
.
mMimeType
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
RefPtr
<
MediaRecorder
>
recorder
=
new
MediaRecorder
(
ownerWindow
)
;
recorder
-
>
SetMimeType
(
aOptions
.
mMimeType
)
;
recorder
-
>
mConstrainedBitsPerSecond
=
aOptions
.
mBitsPerSecond
.
WasPassed
(
)
?
Some
(
aOptions
.
mBitsPerSecond
.
Value
(
)
)
:
Nothing
(
)
;
recorder
-
>
mStream
=
&
aStream
;
recorder
-
>
mState
=
RecordingState
:
:
Inactive
;
recorder
-
>
mVideoBitsPerSecond
=
aOptions
.
mVideoBitsPerSecond
.
WasPassed
(
)
?
aOptions
.
mVideoBitsPerSecond
.
Value
(
)
:
DEFAULT_VIDEO_BITRATE_BPS
;
recorder
-
>
mAudioBitsPerSecond
=
aOptions
.
mAudioBitsPerSecond
.
WasPassed
(
)
?
aOptions
.
mAudioBitsPerSecond
.
Value
(
)
:
DEFAULT_AUDIO_BITRATE_BPS
;
if
(
recorder
-
>
mConstrainedBitsPerSecond
)
{
SelectBitrates
(
*
recorder
-
>
mConstrainedBitsPerSecond
1
&
recorder
-
>
mVideoBitsPerSecond
1
&
recorder
-
>
mAudioBitsPerSecond
)
;
}
return
recorder
.
forget
(
)
;
}
already_AddRefed
<
MediaRecorder
>
MediaRecorder
:
:
Constructor
(
const
GlobalObject
&
aGlobal
AudioNode
&
aAudioNode
uint32_t
aAudioNodeOutput
const
MediaRecorderOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
!
Preferences
:
:
GetBool
(
"
media
.
recorder
.
audio_node
.
enabled
"
false
)
)
{
NS_NAMED_LITERAL_STRING
(
argStr
"
Argument
1
of
MediaRecorder
.
constructor
"
)
;
NS_NAMED_LITERAL_STRING
(
typeStr
"
MediaStream
"
)
;
aRv
.
ThrowTypeError
<
MSG_DOES_NOT_IMPLEMENT_INTERFACE
>
(
argStr
typeStr
)
;
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
ownerWindow
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
ownerWindow
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
aAudioNode
.
NumberOfOutputs
(
)
>
0
&
&
aAudioNodeOutput
>
=
aAudioNode
.
NumberOfOutputs
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
if
(
!
IsTypeSupported
(
aOptions
.
mMimeType
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
RefPtr
<
MediaRecorder
>
recorder
=
new
MediaRecorder
(
ownerWindow
)
;
recorder
-
>
SetMimeType
(
aOptions
.
mMimeType
)
;
recorder
-
>
mConstrainedBitsPerSecond
=
aOptions
.
mBitsPerSecond
.
WasPassed
(
)
?
Some
(
aOptions
.
mBitsPerSecond
.
Value
(
)
)
:
Nothing
(
)
;
recorder
-
>
mAudioNode
=
&
aAudioNode
;
recorder
-
>
mAudioNodeOutput
=
aAudioNodeOutput
;
recorder
-
>
mState
=
RecordingState
:
:
Inactive
;
recorder
-
>
mVideoBitsPerSecond
=
aOptions
.
mVideoBitsPerSecond
.
WasPassed
(
)
?
aOptions
.
mVideoBitsPerSecond
.
Value
(
)
:
DEFAULT_VIDEO_BITRATE_BPS
;
recorder
-
>
mAudioBitsPerSecond
=
aOptions
.
mAudioBitsPerSecond
.
WasPassed
(
)
?
aOptions
.
mAudioBitsPerSecond
.
Value
(
)
:
DEFAULT_AUDIO_BITRATE_BPS
;
if
(
recorder
-
>
mConstrainedBitsPerSecond
)
{
SelectBitrates
(
*
recorder
-
>
mConstrainedBitsPerSecond
1
&
recorder
-
>
mVideoBitsPerSecond
1
&
recorder
-
>
mAudioBitsPerSecond
)
;
}
return
recorder
.
forget
(
)
;
}
static
char
const
*
const
gWebMVideoEncoderCodecs
[
4
]
=
{
"
opus
"
"
vp8
"
"
vp8
.
0
"
nullptr
}
;
static
char
const
*
const
gWebMAudioEncoderCodecs
[
4
]
=
{
"
opus
"
nullptr
}
;
static
char
const
*
const
gOggAudioEncoderCodecs
[
2
]
=
{
"
opus
"
nullptr
}
;
template
<
class
String
>
static
bool
CodecListContains
(
char
const
*
const
*
aCodecs
const
String
&
aCodec
)
{
for
(
int32_t
i
=
0
;
aCodecs
[
i
]
;
+
+
i
)
{
if
(
aCodec
.
EqualsASCII
(
aCodecs
[
i
]
)
)
{
return
true
;
}
}
return
false
;
}
bool
MediaRecorder
:
:
IsTypeSupported
(
GlobalObject
&
aGlobal
const
nsAString
&
aMIMEType
)
{
return
IsTypeSupported
(
aMIMEType
)
;
}
bool
MediaRecorder
:
:
IsTypeSupported
(
const
nsAString
&
aMIMEType
)
{
char
const
*
const
*
codeclist
=
nullptr
;
if
(
aMIMEType
.
IsEmpty
(
)
)
{
return
true
;
}
nsContentTypeParser
parser
(
aMIMEType
)
;
nsAutoString
mimeType
;
nsresult
rv
=
parser
.
GetType
(
mimeType
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
mimeType
.
EqualsLiteral
(
AUDIO_OGG
)
)
{
if
(
MediaDecoder
:
:
IsOggEnabled
(
)
&
&
MediaDecoder
:
:
IsOpusEnabled
(
)
)
{
codeclist
=
gOggAudioEncoderCodecs
;
}
}
#
ifdef
MOZ_WEBM_ENCODER
else
if
(
(
mimeType
.
EqualsLiteral
(
VIDEO_WEBM
)
|
|
mimeType
.
EqualsLiteral
(
AUDIO_WEBM
)
)
&
&
MediaEncoder
:
:
IsWebMEncoderEnabled
(
)
)
{
if
(
mimeType
.
EqualsLiteral
(
AUDIO_WEBM
)
)
{
codeclist
=
gWebMAudioEncoderCodecs
;
}
else
{
codeclist
=
gWebMVideoEncoderCodecs
;
}
}
#
endif
if
(
!
codeclist
)
{
return
false
;
}
nsAutoString
codecstring
;
rv
=
parser
.
GetParameter
(
"
codecs
"
codecstring
)
;
nsTArray
<
nsString
>
codecs
;
if
(
!
ParseCodecsString
(
codecstring
codecs
)
)
{
return
false
;
}
for
(
const
nsString
&
codec
:
codecs
)
{
if
(
!
CodecListContains
(
codeclist
codec
)
)
{
return
false
;
}
}
return
true
;
}
nsresult
MediaRecorder
:
:
CreateAndDispatchBlobEvent
(
Blob
*
aBlob
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Not
running
on
main
thread
"
)
;
BlobEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mData
=
aBlob
;
RefPtr
<
BlobEvent
>
event
=
BlobEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
dataavailable
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
ErrorResult
rv
;
DispatchEvent
(
*
event
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
MediaRecorder
:
:
DispatchSimpleEvent
(
const
nsAString
&
aStr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Not
running
on
main
thread
"
)
;
nsresult
rv
=
CheckCurrentGlobalCorrectness
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
DOMEventTargetHelper
:
:
DispatchTrustedEvent
(
aStr
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
LogLevel
:
:
Error
(
"
MediaRecorder
.
DispatchSimpleEvent
:
DispatchTrustedEvent
failed
%
p
"
this
)
)
;
NS_ERROR
(
"
Failed
to
dispatch
the
event
!
!
!
"
)
;
}
}
void
MediaRecorder
:
:
NotifyError
(
nsresult
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Not
running
on
main
thread
"
)
;
nsresult
rv
=
CheckCurrentGlobalCorrectness
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
MediaRecorderErrorEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
switch
(
aRv
)
{
case
NS_ERROR_DOM_SECURITY_ERR
:
if
(
!
mSecurityDomException
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
NotifyError
:
"
"
mSecurityDomException
was
not
initialized
"
)
)
;
mSecurityDomException
=
DOMException
:
:
Create
(
NS_ERROR_DOM_SECURITY_ERR
)
;
}
init
.
mError
=
mSecurityDomException
.
forget
(
)
;
break
;
default
:
if
(
!
mUnknownDomException
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
NotifyError
:
"
"
mUnknownDomException
was
not
initialized
"
)
)
;
mUnknownDomException
=
DOMException
:
:
Create
(
NS_ERROR_DOM_UNKNOWN_ERR
)
;
}
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
NotifyError
:
"
"
mUnknownDomException
being
fired
for
aRv
:
%
X
"
uint32_t
(
aRv
)
)
)
;
init
.
mError
=
mUnknownDomException
.
forget
(
)
;
}
RefPtr
<
MediaRecorderErrorEvent
>
event
=
MediaRecorderErrorEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
error
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
IgnoredErrorResult
res
;
DispatchEvent
(
*
event
res
)
;
if
(
res
.
Failed
(
)
)
{
NS_ERROR
(
"
Failed
to
dispatch
the
error
event
!
!
!
"
)
;
}
}
void
MediaRecorder
:
:
RemoveSession
(
Session
*
aSession
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
RemoveSession
(
%
p
)
"
aSession
)
)
;
mSessions
.
RemoveElement
(
aSession
)
;
}
void
MediaRecorder
:
:
NotifyOwnerDocumentActivityChanged
(
)
{
nsPIDOMWindowInner
*
window
=
GetOwner
(
)
;
NS_ENSURE_TRUE_VOID
(
window
)
;
Document
*
doc
=
window
-
>
GetExtantDoc
(
)
;
NS_ENSURE_TRUE_VOID
(
doc
)
;
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
%
p
NotifyOwnerDocumentActivityChanged
"
"
IsActive
=
%
d
"
"
IsVisible
=
%
d
"
this
doc
-
>
IsActive
(
)
doc
-
>
IsVisible
(
)
)
)
;
if
(
!
doc
-
>
IsActive
(
)
|
|
!
doc
-
>
IsVisible
(
)
)
{
ErrorResult
result
;
Stop
(
result
)
;
result
.
SuppressException
(
)
;
}
}
void
MediaRecorder
:
:
Inactivate
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaRecorder
.
Inactivate
%
p
"
this
)
)
;
mState
=
RecordingState
:
:
Inactive
;
if
(
mConstrainedBitsPerSecond
)
{
SelectBitrates
(
*
mConstrainedBitsPerSecond
1
&
mVideoBitsPerSecond
1
&
mAudioBitsPerSecond
)
;
}
}
void
MediaRecorder
:
:
InitializeDomExceptions
(
)
{
mSecurityDomException
=
DOMException
:
:
Create
(
NS_ERROR_DOM_SECURITY_ERR
)
;
mUnknownDomException
=
DOMException
:
:
Create
(
NS_ERROR_DOM_UNKNOWN_ERR
)
;
}
RefPtr
<
MediaRecorder
:
:
SizeOfPromise
>
MediaRecorder
:
:
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
holder
=
MakeRefPtr
<
Refcountable
<
MozPromiseHolder
<
SizeOfPromise
>
>
>
(
)
;
RefPtr
<
SizeOfPromise
>
promise
=
holder
-
>
Ensure
(
__func__
)
;
nsTArray
<
RefPtr
<
SizeOfPromise
>
>
promises
(
mSessions
.
Length
(
)
)
;
for
(
const
RefPtr
<
Session
>
&
session
:
mSessions
)
{
promises
.
AppendElement
(
session
-
>
SizeOfExcludingThis
(
aMallocSizeOf
)
)
;
}
SizeOfPromise
:
:
All
(
GetCurrentThreadSerialEventTarget
(
)
promises
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
holder
]
(
const
nsTArray
<
size_t
>
&
sizes
)
{
size_t
total
=
0
;
for
(
const
size_t
&
size
:
sizes
)
{
total
+
=
size
;
}
holder
-
>
Resolve
(
total
__func__
)
;
}
[
]
(
)
{
MOZ_CRASH
(
"
Unexpected
reject
"
)
;
}
)
;
return
promise
;
}
StaticRefPtr
<
MediaRecorderReporter
>
MediaRecorderReporter
:
:
sUniqueInstance
;
}
}
#
undef
LOG
