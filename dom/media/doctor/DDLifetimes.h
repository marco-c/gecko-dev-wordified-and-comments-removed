#
ifndef
DDLifetimes_h_
#
define
DDLifetimes_h_
#
include
"
DDLifetime
.
h
"
#
include
"
DDLoggedTypeTraits
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
class
DDLifetimes
{
public
:
DDLifetime
*
FindLifetime
(
const
DDLogObject
&
aObject
const
DDMessageIndex
&
aIndex
)
;
const
DDLifetime
*
FindLifetime
(
const
DDLogObject
&
aObject
const
DDMessageIndex
&
aIndex
)
const
;
DDLifetime
&
CreateLifetime
(
const
DDLogObject
&
aObject
DDMessageIndex
aIndex
const
DDTimeStamp
&
aConstructionTimeStamp
)
;
void
RemoveLifetime
(
const
DDLifetime
*
aLifetime
)
;
void
RemoveLifetimesFor
(
const
dom
:
:
HTMLMediaElement
*
aMediaElement
)
;
void
Clear
(
)
;
template
<
typename
F
>
void
Visit
(
const
dom
:
:
HTMLMediaElement
*
aMediaElement
F
&
&
aF
bool
aOnlyHTMLMediaElement
=
false
)
const
{
for
(
auto
iter
=
mLifetimes
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
for
(
const
DDLifetime
&
lifetime
:
*
iter
.
UserData
(
)
)
{
if
(
lifetime
.
mMediaElement
=
=
aMediaElement
)
{
if
(
aOnlyHTMLMediaElement
)
{
if
(
lifetime
.
mObject
.
Pointer
(
)
=
=
aMediaElement
&
&
lifetime
.
mObject
.
TypeName
(
)
=
=
DDLoggedTypeTraits
<
dom
:
:
HTMLMediaElement
>
:
:
Name
(
)
)
{
aF
(
lifetime
)
;
break
;
}
continue
;
}
static_assert
(
IsSame
<
decltype
(
aF
(
lifetime
)
)
void
>
:
:
value
"
"
)
;
aF
(
lifetime
)
;
}
}
}
}
template
<
typename
F
>
bool
VisitBreakable
(
const
dom
:
:
HTMLMediaElement
*
aMediaElement
F
&
&
aF
)
const
{
for
(
auto
iter
=
mLifetimes
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
for
(
const
DDLifetime
&
lifetime
:
*
iter
.
UserData
(
)
)
{
if
(
lifetime
.
mMediaElement
=
=
aMediaElement
)
{
static_assert
(
IsSame
<
decltype
(
aF
(
lifetime
)
)
bool
>
:
:
value
"
"
)
;
if
(
aF
(
lifetime
)
)
{
return
true
;
}
}
}
}
return
false
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
class
DDLogObjectHashKey
:
public
PLDHashEntryHdr
{
public
:
typedef
const
DDLogObject
&
KeyType
;
typedef
const
DDLogObject
*
KeyTypePointer
;
explicit
DDLogObjectHashKey
(
KeyTypePointer
aKey
)
:
mValue
(
*
aKey
)
{
}
DDLogObjectHashKey
(
const
DDLogObjectHashKey
&
aToCopy
)
:
mValue
(
aToCopy
.
mValue
)
{
}
~
DDLogObjectHashKey
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
mValue
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
*
aKey
=
=
mValue
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
HashBytes
(
aKey
sizeof
(
DDLogObject
)
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
const
DDLogObject
mValue
;
}
;
using
LifetimesForObject
=
nsTArray
<
DDLifetime
>
;
nsClassHashtable
<
DDLogObjectHashKey
LifetimesForObject
>
mLifetimes
;
}
;
}
#
endif
