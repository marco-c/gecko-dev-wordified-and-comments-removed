#
ifndef
mozilla_MultiWriterQueue_h_
#
define
mozilla_MultiWriterQueue_h_
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
prthread
.
h
"
#
include
"
RollingNumber
.
h
"
#
include
<
cstdint
>
namespace
mozilla
{
class
MultiWriterQueueReaderLocking_Mutex
{
public
:
MultiWriterQueueReaderLocking_Mutex
(
)
:
mMutex
(
"
MultiWriterQueueReaderLocking_Mutex
"
)
{
}
void
Lock
(
)
{
mMutex
.
Lock
(
)
;
}
;
void
Unlock
(
)
{
mMutex
.
Unlock
(
)
;
}
;
private
:
Mutex
mMutex
;
}
;
class
MultiWriterQueueReaderLocking_None
{
public
:
#
ifndef
DEBUG
void
Lock
(
)
{
}
;
void
Unlock
(
)
{
}
;
#
else
void
Lock
(
)
{
MOZ_ASSERT
(
mLocked
.
compareExchange
(
false
true
)
)
;
}
;
void
Unlock
(
)
{
MOZ_ASSERT
(
mLocked
.
compareExchange
(
true
false
)
)
;
}
;
private
:
Atomic
<
bool
>
mLocked
{
false
}
;
#
endif
}
;
static
constexpr
uint32_t
MultiWriterQueueDefaultBufferSize
=
8192
;
template
<
typename
T
uint32_t
BufferSize
=
MultiWriterQueueDefaultBufferSize
typename
ReaderLocking
=
MultiWriterQueueReaderLocking_Mutex
>
class
MultiWriterQueue
{
static_assert
(
BufferSize
>
0
"
0
-
sized
MultiWriterQueue
buffer
"
)
;
public
:
MultiWriterQueue
(
)
:
mBuffersCoverAtLeastUpTo
(
BufferSize
-
1
)
mMostRecentBuffer
(
new
Buffer
{
}
)
mReusableBuffers
(
new
Buffer
{
}
)
mOldestBuffer
(
static_cast
<
Buffer
*
>
(
mMostRecentBuffer
)
)
mLiveBuffersStats
(
1
)
mReusableBuffersStats
(
1
)
mAllocatedBuffersStats
(
2
)
{
}
~
MultiWriterQueue
(
)
{
auto
DestroyList
=
[
]
(
Buffer
*
aBuffer
)
{
while
(
aBuffer
)
{
Buffer
*
older
=
aBuffer
-
>
Older
(
)
;
delete
aBuffer
;
aBuffer
=
older
;
}
}
;
DestroyList
(
mMostRecentBuffer
)
;
DestroyList
(
mReusableBuffers
)
;
}
using
Index
=
RollingNumber
<
uint32_t
>
;
using
DidReachEndOfBuffer
=
bool
;
template
<
typename
F
>
DidReachEndOfBuffer
PushF
(
F
&
&
aF
)
{
const
Index
index
{
mNextElementToWrite
+
+
}
;
for
(
;
;
)
{
Index
lastIndex
{
mBuffersCoverAtLeastUpTo
}
;
if
(
MOZ_UNLIKELY
(
index
=
=
lastIndex
)
)
{
Buffer
*
ourBuffer
=
mMostRecentBuffer
;
Buffer
*
newBuffer
=
NewBuffer
(
ourBuffer
index
+
1
)
;
MOZ_ASSERT
(
mMostRecentBuffer
=
=
ourBuffer
)
;
mMostRecentBuffer
=
newBuffer
;
MOZ_ASSERT
(
mBuffersCoverAtLeastUpTo
=
=
lastIndex
.
Value
(
)
)
;
mBuffersCoverAtLeastUpTo
=
index
.
Value
(
)
+
BufferSize
;
ourBuffer
-
>
SetAndValidateElement
(
aF
index
)
;
return
true
;
}
if
(
MOZ_UNLIKELY
(
index
>
lastIndex
)
)
{
while
(
Index
(
mBuffersCoverAtLeastUpTo
)
<
index
)
{
PR_Sleep
(
PR_INTERVAL_NO_WAIT
)
;
}
continue
;
}
MOZ_ASSERT
(
index
<
lastIndex
)
;
Buffer
*
ourBuffer
=
mMostRecentBuffer
;
while
(
MOZ_UNLIKELY
(
index
<
ourBuffer
-
>
Origin
(
)
)
)
{
MOZ_ASSERT
(
ourBuffer
-
>
Older
(
)
)
;
ourBuffer
=
ourBuffer
-
>
Older
(
)
;
}
ourBuffer
-
>
SetAndValidateElement
(
aF
index
)
;
return
false
;
}
}
DidReachEndOfBuffer
Push
(
const
T
&
aT
)
{
return
PushF
(
[
&
aT
]
(
T
&
aElement
Index
)
{
aElement
=
aT
;
}
)
;
}
DidReachEndOfBuffer
Push
(
T
&
&
aT
)
{
return
PushF
(
[
&
aT
]
(
T
&
aElement
Index
)
{
aElement
=
Move
(
aT
)
;
}
)
;
}
template
<
typename
F
>
void
PopAll
(
F
&
&
aF
)
{
mReaderLocking
.
Lock
(
)
;
bool
destroy
=
false
;
for
(
;
;
)
{
Buffer
*
b
=
mOldestBuffer
;
MOZ_ASSERT
(
!
b
-
>
Older
(
)
)
;
MOZ_ASSERT
(
mNextElementToPop
>
=
b
-
>
Origin
(
)
)
;
MOZ_ASSERT
(
mNextElementToPop
<
b
-
>
Origin
(
)
+
BufferSize
)
;
if
(
!
b
-
>
ReadAndInvalidateAll
(
aF
mNextElementToPop
)
)
{
mReaderLocking
.
Unlock
(
)
;
return
;
}
MOZ_ASSERT
(
mNextElementToPop
=
=
b
-
>
Origin
(
)
+
BufferSize
)
;
MOZ_ASSERT
(
b
-
>
Newer
(
)
)
;
MOZ_ASSERT
(
mNextElementToPop
=
=
b
-
>
Newer
(
)
-
>
Origin
(
)
)
;
StopUsing
(
b
destroy
)
;
destroy
=
!
destroy
;
}
}
struct
CountAndWatermark
{
int
mCount
;
int
mWatermark
;
}
;
CountAndWatermark
LiveBuffersStats
(
)
const
{
return
mLiveBuffersStats
.
Get
(
)
;
}
CountAndWatermark
ReusableBuffersStats
(
)
const
{
return
mReusableBuffersStats
.
Get
(
)
;
}
CountAndWatermark
AllocatedBuffersStats
(
)
const
{
return
mAllocatedBuffersStats
.
Get
(
)
;
}
private
:
class
BufferedElement
{
public
:
template
<
typename
F
>
void
SetAndValidate
(
F
&
&
aF
Index
aIndex
)
{
MOZ_ASSERT
(
!
mValid
)
;
aF
(
mT
aIndex
)
;
mValid
=
true
;
}
template
<
typename
F
>
bool
ReadAndInvalidate
(
F
&
&
aF
)
{
if
(
!
mValid
)
{
return
false
;
}
aF
(
mT
)
;
mValid
=
false
;
return
true
;
}
private
:
T
mT
;
Atomic
<
bool
>
mValid
{
false
}
;
}
;
class
Buffer
{
public
:
Buffer
(
)
:
mOlder
(
nullptr
)
mNewer
(
nullptr
)
mOrigin
(
0
)
{
}
Buffer
(
Buffer
*
aOlder
Index
aOrigin
)
:
mOlder
(
aOlder
)
mNewer
(
nullptr
)
mOrigin
(
aOrigin
)
{
MOZ_ASSERT
(
aOlder
)
;
aOlder
-
>
mNewer
=
this
;
}
Buffer
*
Older
(
)
const
{
return
mOlder
;
}
void
SetOlder
(
Buffer
*
aOlder
)
{
mOlder
=
aOlder
;
}
Buffer
*
Newer
(
)
const
{
return
mNewer
;
}
void
SetNewer
(
Buffer
*
aNewer
)
{
mNewer
=
aNewer
;
}
Index
Origin
(
)
const
{
return
mOrigin
;
}
void
SetOrigin
(
Index
aOrigin
)
{
mOrigin
=
aOrigin
;
}
template
<
typename
F
>
void
SetAndValidateElement
(
F
&
&
aF
Index
aIndex
)
{
MOZ_ASSERT
(
aIndex
>
=
Origin
(
)
)
;
MOZ_ASSERT
(
aIndex
<
Origin
(
)
+
BufferSize
)
;
mElements
[
aIndex
-
Origin
(
)
]
.
SetAndValidate
(
aF
aIndex
)
;
}
using
DidReadLastElement
=
bool
;
template
<
typename
F
>
DidReadLastElement
ReadAndInvalidateAll
(
F
&
&
aF
Index
&
aIndex
)
{
MOZ_ASSERT
(
aIndex
>
=
Origin
(
)
)
;
MOZ_ASSERT
(
aIndex
<
Origin
(
)
+
BufferSize
)
;
for
(
;
aIndex
<
Origin
(
)
+
BufferSize
;
+
+
aIndex
)
{
if
(
!
mElements
[
aIndex
-
Origin
(
)
]
.
ReadAndInvalidate
(
aF
)
)
{
return
false
;
}
}
return
true
;
}
private
:
Buffer
*
mOlder
;
Buffer
*
mNewer
;
Index
mOrigin
;
BufferedElement
mElements
[
BufferSize
]
;
}
;
Buffer
*
NewBuffer
(
Buffer
*
aOlder
Index
aOrigin
)
{
MOZ_ASSERT
(
aOlder
)
;
for
(
;
;
)
{
Buffer
*
head
=
mReusableBuffers
;
if
(
!
head
)
{
+
+
mAllocatedBuffersStats
;
+
+
mLiveBuffersStats
;
Buffer
*
buffer
=
new
Buffer
(
aOlder
aOrigin
)
;
return
buffer
;
}
Buffer
*
older
=
head
-
>
Older
(
)
;
if
(
mReusableBuffers
.
compareExchange
(
head
older
)
)
{
-
-
mReusableBuffersStats
;
+
+
mLiveBuffersStats
;
head
-
>
SetOlder
(
aOlder
)
;
aOlder
-
>
SetNewer
(
head
)
;
MOZ_ASSERT
(
!
head
-
>
Newer
(
)
)
;
head
-
>
SetOrigin
(
aOrigin
)
;
return
head
;
}
}
}
void
StopUsing
(
Buffer
*
aBuffer
bool
aDestroy
)
{
-
-
mLiveBuffersStats
;
MOZ_ASSERT
(
!
aBuffer
-
>
Older
(
)
)
;
MOZ_ASSERT
(
aBuffer
-
>
Newer
(
)
)
;
MOZ_ASSERT
(
aBuffer
-
>
Newer
(
)
-
>
Older
(
)
=
=
aBuffer
)
;
aBuffer
-
>
Newer
(
)
-
>
SetOlder
(
nullptr
)
;
mOldestBuffer
=
aBuffer
-
>
Newer
(
)
;
if
(
aDestroy
)
{
-
-
mAllocatedBuffersStats
;
delete
aBuffer
;
}
else
{
+
+
mReusableBuffersStats
;
aBuffer
-
>
SetNewer
(
nullptr
)
;
for
(
;
;
)
{
Buffer
*
head
=
mReusableBuffers
;
aBuffer
-
>
SetOlder
(
head
)
;
if
(
mReusableBuffers
.
compareExchange
(
head
aBuffer
)
)
{
break
;
}
}
}
}
Atomic
<
Index
:
:
ValueType
>
mNextElementToWrite
{
0
}
;
Atomic
<
Index
:
:
ValueType
>
mBuffersCoverAtLeastUpTo
;
Atomic
<
Buffer
*
>
mMostRecentBuffer
;
Atomic
<
Buffer
*
>
mReusableBuffers
;
ReaderLocking
mReaderLocking
;
Buffer
*
mOldestBuffer
;
Index
mNextElementToPop
{
0
}
;
class
AtomicCountAndWatermark
{
public
:
explicit
AtomicCountAndWatermark
(
int
aCount
)
:
mCount
(
aCount
)
mWatermark
(
aCount
)
{
}
CountAndWatermark
Get
(
)
const
{
return
CountAndWatermark
{
int
(
mCount
)
int
(
mWatermark
)
}
;
}
int
operator
+
+
(
)
{
int
count
=
int
(
+
+
mCount
)
;
for
(
;
;
)
{
int
watermark
=
int
(
mWatermark
)
;
if
(
watermark
>
=
count
)
{
break
;
}
if
(
mWatermark
.
compareExchange
(
watermark
count
)
)
{
break
;
}
}
return
count
;
}
int
operator
-
-
(
)
{
int
count
=
int
(
-
-
mCount
)
;
return
count
;
}
private
:
Atomic
<
int
>
mCount
;
Atomic
<
int
>
mWatermark
;
}
;
AtomicCountAndWatermark
mLiveBuffersStats
;
AtomicCountAndWatermark
mReusableBuffersStats
;
AtomicCountAndWatermark
mAllocatedBuffersStats
;
}
;
}
#
endif
