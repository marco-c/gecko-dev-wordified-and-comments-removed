#
include
"
AutoplayPolicy
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
AudioContext
.
h
"
#
include
"
mozilla
/
dom
/
FeaturePolicyUtils
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMediaElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMediaElementBinding
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsIAutoplay
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
MediaManager
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
mozilla
:
:
LazyLogModule
gAutoplayPermissionLog
(
"
Autoplay
"
)
;
#
define
AUTOPLAY_LOG
(
msg
.
.
.
)
\
MOZ_LOG
(
gAutoplayPermissionLog
LogLevel
:
:
Debug
(
msg
#
#
__VA_ARGS__
)
)
namespace
mozilla
{
namespace
dom
{
static
Document
*
ApproverDocOf
(
const
Document
&
aDocument
)
{
nsCOMPtr
<
nsIDocShell
>
ds
=
aDocument
.
GetDocShell
(
)
;
if
(
!
ds
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
rootTreeItem
;
ds
-
>
GetSameTypeRootTreeItem
(
getter_AddRefs
(
rootTreeItem
)
)
;
if
(
!
rootTreeItem
)
{
return
nullptr
;
}
return
rootTreeItem
-
>
GetDocument
(
)
;
}
static
bool
IsActivelyCapturingOrHasAPermission
(
nsPIDOMWindowInner
*
aWindow
)
{
if
(
MediaManager
:
:
GetIfExists
(
)
)
{
return
MediaManager
:
:
GetIfExists
(
)
-
>
IsActivelyCapturingOrHasAPermission
(
aWindow
-
>
WindowID
(
)
)
;
}
auto
principal
=
nsGlobalWindowInner
:
:
Cast
(
aWindow
)
-
>
GetPrincipal
(
)
;
return
(
nsContentUtils
:
:
IsExactSitePermAllow
(
principal
"
camera
"
)
|
|
nsContentUtils
:
:
IsExactSitePermAllow
(
principal
"
microphone
"
)
|
|
nsContentUtils
:
:
IsExactSitePermAllow
(
principal
"
screen
"
)
)
;
}
static
bool
IsSiteInAutoplayWhiteList
(
const
Document
*
aDocument
)
{
return
aDocument
?
nsContentUtils
:
:
IsExactSitePermAllow
(
aDocument
-
>
NodePrincipal
(
)
"
autoplay
-
media
"
)
:
false
;
}
static
bool
IsSiteInAutoplayBlackList
(
const
Document
*
aDocument
)
{
return
aDocument
?
nsContentUtils
:
:
IsExactSitePermDeny
(
aDocument
-
>
NodePrincipal
(
)
"
autoplay
-
media
"
)
:
false
;
}
static
bool
IsWindowAllowedToPlay
(
nsPIDOMWindowInner
*
aWindow
)
{
if
(
!
aWindow
)
{
return
false
;
}
if
(
IsActivelyCapturingOrHasAPermission
(
aWindow
)
)
{
AUTOPLAY_LOG
(
"
Allow
autoplay
as
document
has
camera
or
microphone
or
screen
"
"
permission
.
"
)
;
return
true
;
}
if
(
!
aWindow
-
>
GetExtantDoc
(
)
)
{
return
false
;
}
if
(
!
FeaturePolicyUtils
:
:
IsFeatureAllowed
(
aWindow
-
>
GetExtantDoc
(
)
NS_LITERAL_STRING
(
"
autoplay
"
)
)
)
{
return
false
;
}
Document
*
approver
=
ApproverDocOf
(
*
aWindow
-
>
GetExtantDoc
(
)
)
;
if
(
!
approver
)
{
return
false
;
}
if
(
approver
-
>
HasBeenUserGestureActivated
(
)
)
{
AUTOPLAY_LOG
(
"
Allow
autoplay
as
document
activated
by
user
gesture
.
"
)
;
return
true
;
}
if
(
approver
-
>
IsExtensionPage
(
)
)
{
AUTOPLAY_LOG
(
"
Allow
autoplay
as
in
extension
document
.
"
)
;
return
true
;
}
if
(
approver
-
>
MediaDocumentKind
(
)
=
=
Document
:
:
MediaDocumentKind
:
:
Video
)
{
AUTOPLAY_LOG
(
"
Allow
video
document
to
autoplay
.
"
)
;
return
true
;
}
return
false
;
}
static
uint32_t
DefaultAutoplayBehaviour
(
)
{
int
prefValue
=
Preferences
:
:
GetInt
(
"
media
.
autoplay
.
default
"
nsIAutoplay
:
:
ALLOWED
)
;
if
(
prefValue
<
nsIAutoplay
:
:
ALLOWED
|
|
prefValue
>
nsIAutoplay
:
:
BLOCKED
)
{
return
nsIAutoplay
:
:
BLOCKED
;
}
return
prefValue
;
}
static
bool
IsMediaElementAllowedToPlay
(
const
HTMLMediaElement
&
aElement
)
{
const
bool
isAllowedMuted
=
Preferences
:
:
GetBool
(
"
media
.
autoplay
.
allow
-
muted
"
true
)
;
if
(
(
aElement
.
Volume
(
)
=
=
0
.
0
|
|
aElement
.
Muted
(
)
)
&
&
isAllowedMuted
)
{
AUTOPLAY_LOG
(
"
Allow
muted
media
%
p
to
autoplay
.
"
&
aElement
)
;
return
true
;
}
if
(
!
aElement
.
HasAudio
(
)
&
&
aElement
.
ReadyState
(
)
>
=
HTMLMediaElement_Binding
:
:
HAVE_METADATA
&
&
isAllowedMuted
)
{
AUTOPLAY_LOG
(
"
Allow
media
%
p
without
audio
track
to
autoplay
"
&
aElement
)
;
return
true
;
}
return
false
;
}
static
bool
IsAudioContextAllowedToPlay
(
const
AudioContext
&
aContext
)
{
return
aContext
.
IsOffline
(
)
|
|
IsWindowAllowedToPlay
(
aContext
.
GetParentObject
(
)
)
;
}
static
bool
IsEnableBlockingWebAudioByUserGesturePolicy
(
)
{
return
DefaultAutoplayBehaviour
(
)
!
=
nsIAutoplay
:
:
ALLOWED
&
&
Preferences
:
:
GetBool
(
"
media
.
autoplay
.
block
-
webaudio
"
false
)
&
&
Preferences
:
:
GetBool
(
"
media
.
autoplay
.
enabled
.
user
-
gestures
-
needed
"
false
)
;
}
bool
AutoplayPolicy
:
:
WouldBeAllowedToPlayIfAutoplayDisabled
(
const
HTMLMediaElement
&
aElement
)
{
return
IsMediaElementAllowedToPlay
(
aElement
)
|
|
IsWindowAllowedToPlay
(
aElement
.
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
)
;
}
bool
AutoplayPolicy
:
:
WouldBeAllowedToPlayIfAutoplayDisabled
(
const
AudioContext
&
aContext
)
{
return
IsAudioContextAllowedToPlay
(
aContext
)
;
}
static
bool
IsAllowedToPlayInternal
(
const
HTMLMediaElement
&
aElement
)
{
if
(
IsMediaElementAllowedToPlay
(
aElement
)
)
{
return
true
;
}
Document
*
approver
=
ApproverDocOf
(
*
aElement
.
OwnerDoc
(
)
)
;
if
(
IsSiteInAutoplayWhiteList
(
approver
)
)
{
AUTOPLAY_LOG
(
"
Allow
autoplay
as
document
has
permanent
autoplay
permission
.
"
)
;
return
true
;
}
if
(
DefaultAutoplayBehaviour
(
)
=
=
nsIAutoplay
:
:
ALLOWED
&
&
!
(
IsSiteInAutoplayBlackList
(
approver
)
&
&
StaticPrefs
:
:
MediaAutoplayBlackListOverrideDefault
(
)
)
)
{
AUTOPLAY_LOG
(
"
Allow
autoplay
as
global
autoplay
setting
is
allowing
autoplay
by
"
"
default
.
"
)
;
return
true
;
}
if
(
!
Preferences
:
:
GetBool
(
"
media
.
autoplay
.
enabled
.
user
-
gestures
-
needed
"
false
)
)
{
return
aElement
.
IsBlessed
(
)
|
|
EventStateManager
:
:
IsHandlingUserInput
(
)
;
}
return
IsWindowAllowedToPlay
(
aElement
.
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
)
;
}
bool
AutoplayPolicy
:
:
IsAllowedToPlay
(
const
HTMLMediaElement
&
aElement
)
{
const
bool
result
=
IsAllowedToPlayInternal
(
aElement
)
;
AUTOPLAY_LOG
(
"
IsAllowedToPlay
mediaElement
=
%
p
isAllowToPlay
=
%
s
"
&
aElement
result
?
"
allowed
"
:
"
blocked
"
)
;
return
result
;
}
bool
AutoplayPolicy
:
:
IsAllowedToPlay
(
const
AudioContext
&
aContext
)
{
if
(
aContext
.
IsOffline
(
)
)
{
return
true
;
}
nsPIDOMWindowInner
*
window
=
aContext
.
GetParentObject
(
)
;
Document
*
approver
=
aContext
.
GetParentObject
(
)
?
ApproverDocOf
(
*
(
window
-
>
GetExtantDoc
(
)
)
)
:
nullptr
;
if
(
IsSiteInAutoplayWhiteList
(
approver
)
)
{
AUTOPLAY_LOG
(
"
Allow
autoplay
as
document
has
permanent
autoplay
permission
.
"
)
;
return
true
;
}
if
(
DefaultAutoplayBehaviour
(
)
=
=
nsIAutoplay
:
:
ALLOWED
&
&
!
IsSiteInAutoplayBlackList
(
approver
)
)
{
AUTOPLAY_LOG
(
"
Allow
autoplay
as
global
autoplay
setting
is
allowing
autoplay
by
"
"
default
.
"
)
;
return
true
;
}
if
(
!
IsEnableBlockingWebAudioByUserGesturePolicy
(
)
)
{
return
true
;
}
return
IsWindowAllowedToPlay
(
window
)
;
}
DocumentAutoplayPolicy
AutoplayPolicy
:
:
IsAllowedToPlay
(
const
Document
&
aDocument
)
{
if
(
DefaultAutoplayBehaviour
(
)
=
=
nsIAutoplay
:
:
ALLOWED
|
|
IsWindowAllowedToPlay
(
aDocument
.
GetInnerWindow
(
)
)
)
{
return
DocumentAutoplayPolicy
:
:
Allowed
;
}
if
(
StaticPrefs
:
:
MediaAutoplayAllowMuted
(
)
)
{
return
DocumentAutoplayPolicy
:
:
Allowed_muted
;
}
return
DocumentAutoplayPolicy
:
:
Disallowed
;
}
}
}
