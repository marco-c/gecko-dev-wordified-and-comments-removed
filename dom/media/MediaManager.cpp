#
include
"
MediaManager
.
h
"
#
include
"
MediaStreamGraph
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamTrack
.
h
"
#
include
"
GetUserMediaRequest
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsHashPropertyBag
.
h
"
#
ifdef
MOZ_WIDGET_GONK
#
include
"
nsIAudioManager
.
h
"
#
endif
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsIUUIDGenerator
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIPopupWindowManager
.
h
"
#
include
"
nsISupportsArray
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIIDNService
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPrincipal
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsICryptoHMAC
.
h
"
#
include
"
nsIKeyModule
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsILineInputStream
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Types
.
h
"
#
include
"
mozilla
/
PeerIdentity
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamBinding
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamTrackBinding
.
h
"
#
include
"
mozilla
/
dom
/
GetUserMediaRequestBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
media
/
MediaChild
.
h
"
#
include
"
MediaTrackConstraints
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
Latency
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsNullPrincipal
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
mozilla
/
Snprintf
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsIUUIDGenerator
.
h
"
#
include
"
nspr
.
h
"
#
include
"
nss
.
h
"
#
include
"
pk11pub
.
h
"
#
include
"
MediaEngineDefault
.
h
"
#
if
defined
(
MOZ_WEBRTC
)
#
include
"
MediaEngineWebRTC
.
h
"
#
include
"
browser_logging
/
WebRtcLog
.
h
"
#
endif
#
ifdef
MOZ_B2G
#
include
"
MediaPermissionGonk
.
h
"
#
endif
#
if
defined
(
XP_MACOSX
)
#
include
"
nsCocoaFeatures
.
h
"
#
endif
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
<
winsock2
.
h
>
#
include
<
iphlpapi
.
h
>
#
include
<
tchar
.
h
>
#
endif
#
ifdef
GetCurrentTime
#
undef
GetCurrentTime
#
endif
template
<
>
struct
nsIMediaDevice
:
:
COMTypeInfo
<
mozilla
:
:
VideoDevice
void
>
{
static
const
nsIID
kIID
;
}
;
const
nsIID
nsIMediaDevice
:
:
COMTypeInfo
<
mozilla
:
:
VideoDevice
void
>
:
:
kIID
=
NS_IMEDIADEVICE_IID
;
template
<
>
struct
nsIMediaDevice
:
:
COMTypeInfo
<
mozilla
:
:
AudioDevice
void
>
{
static
const
nsIID
kIID
;
}
;
const
nsIID
nsIMediaDevice
:
:
COMTypeInfo
<
mozilla
:
:
AudioDevice
void
>
:
:
kIID
=
NS_IMEDIADEVICE_IID
;
namespace
{
already_AddRefed
<
nsIAsyncShutdownClient
>
GetShutdownPhase
(
)
{
nsCOMPtr
<
nsIAsyncShutdownService
>
svc
=
mozilla
:
:
services
:
:
GetAsyncShutdown
(
)
;
MOZ_RELEASE_ASSERT
(
svc
)
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
shutdownPhase
;
nsresult
rv
=
svc
-
>
GetProfileBeforeChange
(
getter_AddRefs
(
shutdownPhase
)
)
;
if
(
!
shutdownPhase
)
{
rv
=
svc
-
>
GetContentChildShutdown
(
getter_AddRefs
(
shutdownPhase
)
)
;
}
MOZ_RELEASE_ASSERT
(
shutdownPhase
)
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
shutdownPhase
.
forget
(
)
;
}
}
namespace
mozilla
{
#
ifdef
LOG
#
undef
LOG
#
endif
LogModule
*
GetMediaManagerLog
(
)
{
static
LazyLogModule
sLog
(
"
MediaManager
"
)
;
return
sLog
;
}
#
define
LOG
(
msg
)
MOZ_LOG
(
GetMediaManagerLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
msg
)
using
dom
:
:
ConstrainDOMStringParameters
;
using
dom
:
:
File
;
using
dom
:
:
GetUserMediaRequest
;
using
dom
:
:
MediaSourceEnum
;
using
dom
:
:
MediaStreamConstraints
;
using
dom
:
:
MediaStreamError
;
using
dom
:
:
MediaStreamTrack
;
using
dom
:
:
MediaStreamTrackSource
;
using
dom
:
:
MediaTrackConstraints
;
using
dom
:
:
MediaTrackConstraintSet
;
using
dom
:
:
OwningBooleanOrMediaTrackConstraints
;
using
dom
:
:
OwningStringOrStringSequence
;
using
dom
:
:
OwningStringOrStringSequenceOrConstrainDOMStringParameters
;
using
dom
:
:
Promise
;
using
dom
:
:
Sequence
;
using
media
:
:
NewRunnableFrom
;
using
media
:
:
NewTaskFrom
;
using
media
:
:
Pledge
;
using
media
:
:
Refcountable
;
static
Atomic
<
bool
>
sInShutdown
;
static
bool
HostInDomain
(
const
nsCString
&
aHost
const
nsCString
&
aPattern
)
{
int32_t
patternOffset
=
0
;
int32_t
hostOffset
=
0
;
if
(
aPattern
.
Length
(
)
>
2
&
&
aPattern
[
0
]
=
=
'
*
'
&
&
aPattern
[
1
]
=
=
'
.
'
)
{
patternOffset
=
2
;
hostOffset
=
aHost
.
FindChar
(
'
.
'
)
+
1
;
if
(
hostOffset
<
=
1
)
{
return
false
;
}
}
nsDependentCString
hostRoot
(
aHost
hostOffset
)
;
return
hostRoot
.
EqualsIgnoreCase
(
aPattern
.
BeginReading
(
)
+
patternOffset
)
;
}
static
bool
HostIsHttps
(
nsIURI
&
docURI
)
{
bool
isHttps
;
nsresult
rv
=
docURI
.
SchemeIs
(
"
https
"
&
isHttps
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
return
isHttps
;
}
static
bool
HostHasPermission
(
nsIURI
&
docURI
)
{
nsAdoptingCString
hostName
;
docURI
.
GetAsciiHost
(
hostName
)
;
nsAdoptingCString
domainWhiteList
=
Preferences
:
:
GetCString
(
"
media
.
getusermedia
.
screensharing
.
allowed_domains
"
)
;
domainWhiteList
.
StripWhitespace
(
)
;
if
(
domainWhiteList
.
IsEmpty
(
)
|
|
hostName
.
IsEmpty
(
)
)
{
return
false
;
}
nsresult
rv
;
nsCOMPtr
<
nsIIDNService
>
idnService
=
do_GetService
(
"
mozilla
.
org
/
network
/
idn
-
service
;
1
"
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
uint32_t
begin
=
0
;
uint32_t
end
=
0
;
nsCString
domainName
;
do
{
end
=
domainWhiteList
.
FindChar
(
'
'
begin
)
;
if
(
end
=
=
(
uint32_t
)
-
1
)
{
end
=
domainWhiteList
.
Length
(
)
;
}
rv
=
idnService
-
>
ConvertUTF8toACE
(
Substring
(
domainWhiteList
begin
end
-
begin
)
domainName
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
HostInDomain
(
hostName
domainName
)
)
{
return
true
;
}
}
else
{
NS_WARNING
(
"
Failed
to
convert
UTF
-
8
host
to
ASCII
"
)
;
}
begin
=
end
+
1
;
}
while
(
end
<
domainWhiteList
.
Length
(
)
)
;
return
false
;
}
class
MediaOperationTask
:
public
Task
{
public
:
MediaOperationTask
(
MediaOperation
aType
GetUserMediaCallbackMediaStreamListener
*
aListener
DOMMediaStream
*
aStream
OnTracksAvailableCallback
*
aOnTracksAvailableCallback
AudioDevice
*
aAudioDevice
VideoDevice
*
aVideoDevice
bool
aBool
uint64_t
aWindowID
already_AddRefed
<
nsIDOMGetUserMediaErrorCallback
>
aError
const
dom
:
:
MediaTrackConstraints
&
aConstraints
=
dom
:
:
MediaTrackConstraints
(
)
)
:
mType
(
aType
)
mStream
(
aStream
)
mOnTracksAvailableCallback
(
aOnTracksAvailableCallback
)
mAudioDevice
(
aAudioDevice
)
mVideoDevice
(
aVideoDevice
)
mListener
(
aListener
)
mBool
(
aBool
)
mWindowID
(
aWindowID
)
mOnFailure
(
aError
)
mConstraints
(
aConstraints
)
{
}
~
MediaOperationTask
(
)
{
}
void
ReturnCallbackError
(
nsresult
rv
const
char
*
errorLog
)
;
void
Run
(
)
{
SourceMediaStream
*
source
=
mListener
-
>
GetSourceStream
(
)
;
if
(
!
source
)
return
;
switch
(
mType
)
{
case
MEDIA_START
:
{
NS_ASSERTION
(
!
NS_IsMainThread
(
)
"
Never
call
on
main
thread
"
)
;
nsresult
rv
;
if
(
mAudioDevice
)
{
rv
=
mAudioDevice
-
>
GetSource
(
)
-
>
Start
(
source
kAudioTrack
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReturnCallbackError
(
rv
"
Starting
audio
failed
"
)
;
return
;
}
}
if
(
mVideoDevice
)
{
rv
=
mVideoDevice
-
>
GetSource
(
)
-
>
Start
(
source
kVideoTrack
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReturnCallbackError
(
rv
"
Starting
video
failed
"
)
;
return
;
}
}
source
-
>
FinishAddTracks
(
)
;
source
-
>
SetPullEnabled
(
true
)
;
source
-
>
AdvanceKnownTracksTime
(
STREAM_TIME_MAX
)
;
MM_LOG
(
(
"
started
all
sources
"
)
)
;
nsIRunnable
*
event
=
new
GetUserMediaNotificationEvent
(
GetUserMediaNotificationEvent
:
:
STARTING
mStream
.
forget
(
)
mOnTracksAvailableCallback
.
forget
(
)
mAudioDevice
!
=
nullptr
mVideoDevice
!
=
nullptr
mWindowID
mOnFailure
.
forget
(
)
)
;
NS_DispatchToMainThread
(
event
)
;
}
break
;
case
MEDIA_STOP
:
case
MEDIA_STOP_TRACK
:
{
NS_ASSERTION
(
!
NS_IsMainThread
(
)
"
Never
call
on
main
thread
"
)
;
if
(
mAudioDevice
)
{
mAudioDevice
-
>
GetSource
(
)
-
>
Stop
(
source
kAudioTrack
)
;
mAudioDevice
-
>
GetSource
(
)
-
>
Deallocate
(
)
;
}
if
(
mVideoDevice
)
{
mVideoDevice
-
>
GetSource
(
)
-
>
Stop
(
source
kVideoTrack
)
;
mVideoDevice
-
>
GetSource
(
)
-
>
Deallocate
(
)
;
}
if
(
mType
=
=
MEDIA_STOP
)
{
source
-
>
EndAllTrackAndFinish
(
)
;
}
nsIRunnable
*
event
=
new
GetUserMediaNotificationEvent
(
mListener
mType
=
=
MEDIA_STOP
?
GetUserMediaNotificationEvent
:
:
STOPPING
:
GetUserMediaNotificationEvent
:
:
STOPPED_TRACK
mAudioDevice
!
=
nullptr
mVideoDevice
!
=
nullptr
mWindowID
)
;
NS_DispatchToMainThread
(
event
)
;
}
break
;
case
MEDIA_DIRECT_LISTENERS
:
{
NS_ASSERTION
(
!
NS_IsMainThread
(
)
"
Never
call
on
main
thread
"
)
;
if
(
mVideoDevice
)
{
mVideoDevice
-
>
GetSource
(
)
-
>
SetDirectListeners
(
mBool
)
;
}
}
break
;
default
:
MOZ_ASSERT
(
false
"
invalid
MediaManager
operation
"
)
;
break
;
}
}
private
:
MediaOperation
mType
;
RefPtr
<
DOMMediaStream
>
mStream
;
nsAutoPtr
<
OnTracksAvailableCallback
>
mOnTracksAvailableCallback
;
RefPtr
<
AudioDevice
>
mAudioDevice
;
RefPtr
<
VideoDevice
>
mVideoDevice
;
RefPtr
<
GetUserMediaCallbackMediaStreamListener
>
mListener
;
bool
mBool
;
uint64_t
mWindowID
;
nsCOMPtr
<
nsIDOMGetUserMediaErrorCallback
>
mOnFailure
;
dom
:
:
MediaTrackConstraints
mConstraints
;
}
;
template
<
class
SuccessCallbackType
>
class
ErrorCallbackRunnable
:
public
nsRunnable
{
public
:
ErrorCallbackRunnable
(
nsCOMPtr
<
SuccessCallbackType
>
&
aOnSuccess
nsCOMPtr
<
nsIDOMGetUserMediaErrorCallback
>
&
aOnFailure
MediaMgrError
&
aError
uint64_t
aWindowID
)
:
mError
(
&
aError
)
mWindowID
(
aWindowID
)
mManager
(
MediaManager
:
:
GetInstance
(
)
)
{
mOnSuccess
.
swap
(
aOnSuccess
)
;
mOnFailure
.
swap
(
aOnFailure
)
;
}
NS_IMETHODIMP
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
SuccessCallbackType
>
onSuccess
=
mOnSuccess
.
forget
(
)
;
nsCOMPtr
<
nsIDOMGetUserMediaErrorCallback
>
onFailure
=
mOnFailure
.
forget
(
)
;
if
(
!
(
mManager
-
>
IsWindowStillActive
(
mWindowID
)
)
)
{
return
NS_OK
;
}
if
(
auto
*
window
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
mWindowID
)
)
{
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
window
-
>
AsInner
(
)
*
mError
)
;
onFailure
-
>
OnError
(
error
)
;
}
return
NS_OK
;
}
private
:
~
ErrorCallbackRunnable
(
)
{
MOZ_ASSERT
(
!
mOnSuccess
&
&
!
mOnFailure
)
;
}
nsCOMPtr
<
SuccessCallbackType
>
mOnSuccess
;
nsCOMPtr
<
nsIDOMGetUserMediaErrorCallback
>
mOnFailure
;
RefPtr
<
MediaMgrError
>
mError
;
uint64_t
mWindowID
;
RefPtr
<
MediaManager
>
mManager
;
}
;
class
GetUserMediaListenerRemove
:
public
nsRunnable
{
public
:
GetUserMediaListenerRemove
(
uint64_t
aWindowID
GetUserMediaCallbackMediaStreamListener
*
aListener
)
:
mWindowID
(
aWindowID
)
mListener
(
aListener
)
{
}
NS_IMETHOD
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
MediaManager
>
manager
(
MediaManager
:
:
GetInstance
(
)
)
;
manager
-
>
RemoveFromWindowList
(
mWindowID
mListener
)
;
return
NS_OK
;
}
protected
:
uint64_t
mWindowID
;
RefPtr
<
GetUserMediaCallbackMediaStreamListener
>
mListener
;
}
;
NS_IMPL_ISUPPORTS
(
MediaDevice
nsIMediaDevice
)
MediaDevice
:
:
MediaDevice
(
MediaEngineSource
*
aSource
bool
aIsVideo
)
:
mMediaSource
(
aSource
-
>
GetMediaSource
(
)
)
mSource
(
aSource
)
mIsVideo
(
aIsVideo
)
{
mSource
-
>
GetName
(
mName
)
;
nsCString
id
;
mSource
-
>
GetUUID
(
id
)
;
CopyUTF8toUTF16
(
id
mID
)
;
}
VideoDevice
:
:
VideoDevice
(
MediaEngineVideoSource
*
aSource
)
:
MediaDevice
(
aSource
true
)
{
}
bool
MediaDevice
:
:
StringsContain
(
const
OwningStringOrStringSequence
&
aStrings
nsString
aN
)
{
return
aStrings
.
IsString
(
)
?
aStrings
.
GetAsString
(
)
=
=
aN
:
aStrings
.
GetAsStringSequence
(
)
.
Contains
(
aN
)
;
}
uint32_t
MediaDevice
:
:
FitnessDistance
(
nsString
aN
const
ConstrainDOMStringParameters
&
aParams
)
{
if
(
aParams
.
mExact
.
WasPassed
(
)
&
&
!
StringsContain
(
aParams
.
mExact
.
Value
(
)
aN
)
)
{
return
UINT32_MAX
;
}
if
(
aParams
.
mIdeal
.
WasPassed
(
)
&
&
!
StringsContain
(
aParams
.
mIdeal
.
Value
(
)
aN
)
)
{
return
1
;
}
return
0
;
}
uint32_t
MediaDevice
:
:
FitnessDistance
(
nsString
aN
const
OwningStringOrStringSequenceOrConstrainDOMStringParameters
&
aConstraint
)
{
if
(
aConstraint
.
IsString
(
)
)
{
ConstrainDOMStringParameters
params
;
params
.
mIdeal
.
Construct
(
)
;
params
.
mIdeal
.
Value
(
)
.
SetAsString
(
)
=
aConstraint
.
GetAsString
(
)
;
return
FitnessDistance
(
aN
params
)
;
}
else
if
(
aConstraint
.
IsStringSequence
(
)
)
{
ConstrainDOMStringParameters
params
;
params
.
mIdeal
.
Construct
(
)
;
params
.
mIdeal
.
Value
(
)
.
SetAsStringSequence
(
)
=
aConstraint
.
GetAsStringSequence
(
)
;
return
FitnessDistance
(
aN
params
)
;
}
else
{
return
FitnessDistance
(
aN
aConstraint
.
GetAsConstrainDOMStringParameters
(
)
)
;
}
}
uint32_t
MediaDevice
:
:
GetBestFitnessDistance
(
const
nsTArray
<
const
MediaTrackConstraintSet
*
>
&
aConstraintSets
)
{
nsString
mediaSource
;
GetMediaSource
(
mediaSource
)
;
if
(
!
mediaSource
.
EqualsASCII
(
"
microphone
"
)
)
{
for
(
const
auto
&
constraint
:
aConstraintSets
)
{
if
(
mediaSource
!
=
constraint
-
>
mMediaSource
)
{
return
UINT32_MAX
;
}
}
}
nsString
id
;
GetId
(
id
)
;
return
mSource
-
>
GetBestFitnessDistance
(
aConstraintSets
id
)
;
}
AudioDevice
:
:
AudioDevice
(
MediaEngineAudioSource
*
aSource
)
:
MediaDevice
(
aSource
false
)
{
mMediaSource
=
aSource
-
>
GetMediaSource
(
)
;
}
NS_IMETHODIMP
MediaDevice
:
:
GetName
(
nsAString
&
aName
)
{
aName
.
Assign
(
mName
)
;
return
NS_OK
;
}
NS_IMETHODIMP
MediaDevice
:
:
GetType
(
nsAString
&
aType
)
{
return
NS_OK
;
}
NS_IMETHODIMP
VideoDevice
:
:
GetType
(
nsAString
&
aType
)
{
aType
.
AssignLiteral
(
MOZ_UTF16
(
"
video
"
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
AudioDevice
:
:
GetType
(
nsAString
&
aType
)
{
aType
.
AssignLiteral
(
MOZ_UTF16
(
"
audio
"
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
MediaDevice
:
:
GetId
(
nsAString
&
aID
)
{
aID
.
Assign
(
mID
)
;
return
NS_OK
;
}
void
MediaDevice
:
:
SetId
(
const
nsAString
&
aID
)
{
mID
.
Assign
(
aID
)
;
}
NS_IMETHODIMP
MediaDevice
:
:
GetMediaSource
(
nsAString
&
aMediaSource
)
{
if
(
mMediaSource
=
=
MediaSourceEnum
:
:
Microphone
)
{
aMediaSource
.
Assign
(
NS_LITERAL_STRING
(
"
microphone
"
)
)
;
}
else
if
(
mMediaSource
=
=
MediaSourceEnum
:
:
AudioCapture
)
{
aMediaSource
.
Assign
(
NS_LITERAL_STRING
(
"
audioCapture
"
)
)
;
}
else
if
(
mMediaSource
=
=
MediaSourceEnum
:
:
Window
)
{
aMediaSource
.
Assign
(
NS_LITERAL_STRING
(
"
window
"
)
)
;
}
else
{
aMediaSource
.
Assign
(
NS_ConvertUTF8toUTF16
(
dom
:
:
MediaSourceEnumValues
:
:
strings
[
uint32_t
(
mMediaSource
)
]
.
value
)
)
;
}
return
NS_OK
;
}
VideoDevice
:
:
Source
*
VideoDevice
:
:
GetSource
(
)
{
return
static_cast
<
Source
*
>
(
&
*
mSource
)
;
}
AudioDevice
:
:
Source
*
AudioDevice
:
:
GetSource
(
)
{
return
static_cast
<
Source
*
>
(
&
*
mSource
)
;
}
nsresult
VideoDevice
:
:
Allocate
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsACString
&
aOrigin
)
{
return
GetSource
(
)
-
>
Allocate
(
aConstraints
aPrefs
mID
aOrigin
)
;
}
nsresult
AudioDevice
:
:
Allocate
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
nsACString
&
aOrigin
)
{
return
GetSource
(
)
-
>
Allocate
(
aConstraints
aPrefs
mID
aOrigin
)
;
}
nsresult
VideoDevice
:
:
Restart
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
)
{
return
GetSource
(
)
-
>
Restart
(
aConstraints
aPrefs
mID
)
;
}
nsresult
AudioDevice
:
:
Restart
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
)
{
return
GetSource
(
)
-
>
Restart
(
aConstraints
aPrefs
mID
)
;
}
class
nsDOMUserMediaStream
:
public
DOMLocalMediaStream
{
public
:
static
already_AddRefed
<
nsDOMUserMediaStream
>
CreateSourceStream
(
nsPIDOMWindowInner
*
aWindow
GetUserMediaCallbackMediaStreamListener
*
aListener
MediaStreamGraph
*
aMSG
MediaStreamTrackSourceGetter
*
aTrackSourceGetter
)
{
RefPtr
<
nsDOMUserMediaStream
>
stream
=
new
nsDOMUserMediaStream
(
aWindow
aListener
aTrackSourceGetter
)
;
stream
-
>
InitSourceStream
(
aMSG
)
;
return
stream
.
forget
(
)
;
}
nsDOMUserMediaStream
(
nsPIDOMWindowInner
*
aWindow
GetUserMediaCallbackMediaStreamListener
*
aListener
MediaStreamTrackSourceGetter
*
aTrackSourceGetter
)
:
DOMLocalMediaStream
(
aWindow
aTrackSourceGetter
)
mListener
(
aListener
)
{
}
virtual
~
nsDOMUserMediaStream
(
)
{
StopImpl
(
)
;
if
(
GetSourceStream
(
)
)
{
GetSourceStream
(
)
-
>
Destroy
(
)
;
}
}
already_AddRefed
<
Promise
>
ApplyConstraintsToTrack
(
TrackID
aTrackID
const
MediaTrackConstraints
&
aConstraints
ErrorResult
&
aRv
)
override
{
nsCOMPtr
<
nsIGlobalObject
>
go
=
do_QueryInterface
(
mWindow
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
go
aRv
)
;
if
(
sInShutdown
)
{
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
mWindow
NS_LITERAL_STRING
(
"
AbortError
"
)
NS_LITERAL_STRING
(
"
In
shutdown
"
)
)
;
promise
-
>
MaybeReject
(
error
)
;
return
promise
.
forget
(
)
;
}
if
(
!
GetSourceStream
(
)
)
{
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
mWindow
NS_LITERAL_STRING
(
"
InternalError
"
)
NS_LITERAL_STRING
(
"
No
stream
.
"
)
)
;
promise
-
>
MaybeReject
(
error
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
dom
:
:
MediaStreamTrack
>
track
=
FindOwnedDOMTrack
(
mOwnedStream
aTrackID
)
;
if
(
!
track
)
{
LOG
(
(
"
ApplyConstraintsToTrack
(
%
d
)
on
non
-
existent
track
"
aTrackID
)
)
;
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
mWindow
NS_LITERAL_STRING
(
"
InternalError
"
)
NS_LITERAL_STRING
(
"
No
track
.
"
)
)
;
promise
-
>
MaybeReject
(
error
)
;
return
promise
.
forget
(
)
;
}
typedef
media
:
:
Pledge
<
bool
MediaStreamError
*
>
PledgeVoid
;
RefPtr
<
PledgeVoid
>
p
=
mListener
-
>
ApplyConstraintsToTrack
(
mWindow
aTrackID
!
!
track
-
>
AsAudioStreamTrack
(
)
aConstraints
)
;
p
-
>
Then
(
[
promise
]
(
bool
&
aDummy
)
mutable
{
promise
-
>
MaybeResolve
(
false
)
;
}
[
promise
]
(
MediaStreamError
*
&
reason
)
mutable
{
promise
-
>
MaybeReject
(
reason
)
;
}
)
;
return
promise
.
forget
(
)
;
}
bool
AddDirectListener
(
MediaStreamDirectListener
*
aListener
)
override
{
if
(
GetSourceStream
(
)
)
{
GetSourceStream
(
)
-
>
AddDirectListener
(
aListener
)
;
return
true
;
}
return
false
;
}
void
RemoveDirectListener
(
MediaStreamDirectListener
*
aListener
)
override
{
if
(
GetSourceStream
(
)
)
{
GetSourceStream
(
)
-
>
RemoveDirectListener
(
aListener
)
;
}
}
DOMLocalMediaStream
*
AsDOMLocalMediaStream
(
)
override
{
return
this
;
}
SourceMediaStream
*
GetSourceStream
(
)
{
if
(
GetInputStream
(
)
)
{
return
GetInputStream
(
)
-
>
AsSourceStream
(
)
;
}
return
nullptr
;
}
RefPtr
<
GetUserMediaCallbackMediaStreamListener
>
mListener
;
}
;
void
MediaOperationTask
:
:
ReturnCallbackError
(
nsresult
rv
const
char
*
errorLog
)
{
MM_LOG
(
(
"
%
s
rv
=
%
d
"
errorLog
rv
)
)
;
NS_DispatchToMainThread
(
do_AddRef
(
new
ReleaseMediaOperationResource
(
mStream
.
forget
(
)
mOnTracksAvailableCallback
.
forget
(
)
)
)
)
;
nsString
log
;
log
.
AssignASCII
(
errorLog
)
;
nsCOMPtr
<
nsIDOMGetUserMediaSuccessCallback
>
onSuccess
;
RefPtr
<
MediaMgrError
>
error
=
new
MediaMgrError
(
NS_LITERAL_STRING
(
"
InternalError
"
)
log
)
;
NS_DispatchToMainThread
(
do_AddRef
(
new
ErrorCallbackRunnable
<
nsIDOMGetUserMediaSuccessCallback
>
(
onSuccess
mOnFailure
*
error
mWindowID
)
)
)
;
}
class
GetUserMediaStreamRunnable
:
public
nsRunnable
{
public
:
GetUserMediaStreamRunnable
(
nsCOMPtr
<
nsIDOMGetUserMediaSuccessCallback
>
&
aOnSuccess
nsCOMPtr
<
nsIDOMGetUserMediaErrorCallback
>
&
aOnFailure
uint64_t
aWindowID
GetUserMediaCallbackMediaStreamListener
*
aListener
const
nsCString
&
aOrigin
AudioDevice
*
aAudioDevice
VideoDevice
*
aVideoDevice
PeerIdentity
*
aPeerIdentity
)
:
mAudioDevice
(
aAudioDevice
)
mVideoDevice
(
aVideoDevice
)
mWindowID
(
aWindowID
)
mListener
(
aListener
)
mOrigin
(
aOrigin
)
mPeerIdentity
(
aPeerIdentity
)
mManager
(
MediaManager
:
:
GetInstance
(
)
)
{
mOnSuccess
.
swap
(
aOnSuccess
)
;
mOnFailure
.
swap
(
aOnFailure
)
;
}
~
GetUserMediaStreamRunnable
(
)
{
}
class
TracksAvailableCallback
:
public
OnTracksAvailableCallback
{
public
:
TracksAvailableCallback
(
MediaManager
*
aManager
nsIDOMGetUserMediaSuccessCallback
*
aSuccess
uint64_t
aWindowID
DOMMediaStream
*
aStream
)
:
mWindowID
(
aWindowID
)
mOnSuccess
(
aSuccess
)
mManager
(
aManager
)
mStream
(
aStream
)
{
}
void
NotifyTracksAvailable
(
DOMMediaStream
*
aStream
)
override
{
if
(
!
(
mManager
-
>
IsWindowStillActive
(
mWindowID
)
)
)
{
return
;
}
aStream
-
>
SetLogicalStreamStartTime
(
aStream
-
>
GetPlaybackStream
(
)
-
>
GetCurrentTime
(
)
)
;
LOG
(
(
"
Returning
success
for
getUserMedia
(
)
"
)
)
;
mOnSuccess
-
>
OnSuccess
(
aStream
)
;
}
uint64_t
mWindowID
;
nsCOMPtr
<
nsIDOMGetUserMediaSuccessCallback
>
mOnSuccess
;
RefPtr
<
MediaManager
>
mManager
;
RefPtr
<
DOMMediaStream
>
mStream
;
}
;
NS_IMETHOD
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
*
globalWindow
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
mWindowID
)
;
nsPIDOMWindowInner
*
window
=
globalWindow
?
globalWindow
-
>
AsInner
(
)
:
nullptr
;
StreamListeners
*
listeners
=
mManager
-
>
GetWindowListeners
(
mWindowID
)
;
if
(
!
listeners
|
|
!
window
|
|
!
window
-
>
GetExtantDoc
(
)
)
{
return
NS_OK
;
}
MediaStreamGraph
:
:
GraphDriverType
graphDriverType
=
mAudioDevice
?
MediaStreamGraph
:
:
AUDIO_THREAD_DRIVER
:
MediaStreamGraph
:
:
SYSTEM_THREAD_DRIVER
;
MediaStreamGraph
*
msg
=
MediaStreamGraph
:
:
GetInstance
(
graphDriverType
dom
:
:
AudioChannel
:
:
Normal
)
;
RefPtr
<
DOMLocalMediaStream
>
domStream
;
RefPtr
<
SourceMediaStream
>
stream
;
if
(
mAudioDevice
&
&
mAudioDevice
-
>
GetMediaSource
(
)
=
=
MediaSourceEnum
:
:
AudioCapture
)
{
domStream
=
DOMLocalMediaStream
:
:
CreateAudioCaptureStream
(
window
msg
)
;
domStream
-
>
SetPrincipal
(
window
-
>
GetExtantDoc
(
)
-
>
NodePrincipal
(
)
)
;
stream
=
msg
-
>
CreateSourceStream
(
nullptr
)
;
msg
-
>
RegisterCaptureStreamForWindow
(
mWindowID
domStream
-
>
GetInputStream
(
)
-
>
AsProcessedStream
(
)
)
;
window
-
>
SetAudioCapture
(
true
)
;
}
else
{
class
LocalTrackSource
:
public
MediaStreamTrackSource
{
public
:
LocalTrackSource
(
GetUserMediaCallbackMediaStreamListener
*
aListener
const
MediaSourceEnum
aSource
const
TrackID
aTrackID
)
:
MediaStreamTrackSource
(
nullptr
false
)
mListener
(
aListener
)
mSource
(
aSource
)
mTrackID
(
aTrackID
)
{
}
MediaSourceEnum
GetMediaSource
(
)
const
override
{
return
mSource
;
}
void
Stop
(
)
override
{
if
(
mListener
)
{
mListener
-
>
StopTrack
(
mTrackID
)
;
mListener
=
nullptr
;
}
}
protected
:
~
LocalTrackSource
(
)
{
}
RefPtr
<
GetUserMediaCallbackMediaStreamListener
>
mListener
;
const
MediaSourceEnum
mSource
;
const
TrackID
mTrackID
;
}
;
domStream
=
nsDOMUserMediaStream
:
:
CreateSourceStream
(
window
mListener
msg
nullptr
)
;
if
(
mAudioDevice
)
{
nsString
audioDeviceName
;
mAudioDevice
-
>
GetName
(
audioDeviceName
)
;
const
MediaSourceEnum
source
=
mAudioDevice
-
>
GetSource
(
)
-
>
GetMediaSource
(
)
;
RefPtr
<
MediaStreamTrackSource
>
audioSource
=
new
LocalTrackSource
(
mListener
source
kAudioTrack
)
;
domStream
-
>
CreateOwnDOMTrack
(
kAudioTrack
MediaSegment
:
:
AUDIO
audioDeviceName
audioSource
)
;
}
if
(
mVideoDevice
)
{
nsString
videoDeviceName
;
mVideoDevice
-
>
GetName
(
videoDeviceName
)
;
const
MediaSourceEnum
source
=
mVideoDevice
-
>
GetSource
(
)
-
>
GetMediaSource
(
)
;
RefPtr
<
MediaStreamTrackSource
>
videoSource
=
new
LocalTrackSource
(
mListener
source
kVideoTrack
)
;
domStream
-
>
CreateOwnDOMTrack
(
kVideoTrack
MediaSegment
:
:
VIDEO
videoDeviceName
videoSource
)
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
if
(
mPeerIdentity
)
{
principal
=
nsNullPrincipal
:
:
Create
(
)
;
domStream
-
>
SetPeerIdentity
(
mPeerIdentity
.
forget
(
)
)
;
}
else
{
principal
=
window
-
>
GetExtantDoc
(
)
-
>
NodePrincipal
(
)
;
}
domStream
-
>
CombineWithPrincipal
(
principal
)
;
stream
=
domStream
-
>
GetInputStream
(
)
-
>
AsSourceStream
(
)
;
}
if
(
!
domStream
|
|
sInShutdown
)
{
nsCOMPtr
<
nsIDOMGetUserMediaErrorCallback
>
onFailure
=
mOnFailure
.
forget
(
)
;
LOG
(
(
"
Returning
error
for
getUserMedia
(
)
-
no
stream
"
)
)
;
if
(
auto
*
window
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
mWindowID
)
)
{
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
window
-
>
AsInner
(
)
NS_LITERAL_STRING
(
"
InternalError
"
)
sInShutdown
?
NS_LITERAL_STRING
(
"
In
shutdown
"
)
:
NS_LITERAL_STRING
(
"
No
stream
.
"
)
)
;
onFailure
-
>
OnError
(
error
)
;
}
return
NS_OK
;
}
MOZ_ASSERT
(
stream
)
;
mListener
-
>
Activate
(
stream
.
forget
(
)
mAudioDevice
mVideoDevice
)
;
TracksAvailableCallback
*
tracksAvailableCallback
=
new
TracksAvailableCallback
(
mManager
mOnSuccess
mWindowID
domStream
)
;
MediaManager
:
:
PostTask
(
FROM_HERE
new
MediaOperationTask
(
MEDIA_START
mListener
domStream
tracksAvailableCallback
mAudioDevice
mVideoDevice
false
mWindowID
mOnFailure
.
forget
(
)
)
)
;
mOnFailure
=
nullptr
;
if
(
!
MediaManager
:
:
IsPrivateBrowsing
(
window
)
)
{
RefPtr
<
Pledge
<
nsCString
>
>
p
=
media
:
:
GetOriginKey
(
mOrigin
false
true
)
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIDOMGetUserMediaSuccessCallback
>
mOnSuccess
;
nsCOMPtr
<
nsIDOMGetUserMediaErrorCallback
>
mOnFailure
;
RefPtr
<
AudioDevice
>
mAudioDevice
;
RefPtr
<
VideoDevice
>
mVideoDevice
;
uint64_t
mWindowID
;
RefPtr
<
GetUserMediaCallbackMediaStreamListener
>
mListener
;
nsCString
mOrigin
;
nsAutoPtr
<
PeerIdentity
>
mPeerIdentity
;
RefPtr
<
MediaManager
>
mManager
;
}
;
static
bool
IsOn
(
const
OwningBooleanOrMediaTrackConstraints
&
aUnion
)
{
return
!
aUnion
.
IsBoolean
(
)
|
|
aUnion
.
GetAsBoolean
(
)
;
}
static
const
MediaTrackConstraints
&
GetInvariant
(
const
OwningBooleanOrMediaTrackConstraints
&
aUnion
)
{
static
const
MediaTrackConstraints
empty
;
return
aUnion
.
IsMediaTrackConstraints
(
)
?
aUnion
.
GetAsMediaTrackConstraints
(
)
:
empty
;
}
template
<
class
DeviceType
>
static
void
GetSources
(
MediaEngine
*
engine
MediaSourceEnum
aSrcType
void
(
MediaEngine
:
:
*
aEnumerate
)
(
MediaSourceEnum
nsTArray
<
RefPtr
<
typename
DeviceType
:
:
Source
>
>
*
)
nsTArray
<
RefPtr
<
DeviceType
>
>
&
aResult
const
char
*
media_device_name
=
nullptr
)
{
nsTArray
<
RefPtr
<
typename
DeviceType
:
:
Source
>
>
sources
;
(
engine
-
>
*
aEnumerate
)
(
aSrcType
&
sources
)
;
if
(
media_device_name
&
&
*
media_device_name
)
{
for
(
auto
&
source
:
sources
)
{
nsString
deviceName
;
source
-
>
GetName
(
deviceName
)
;
if
(
deviceName
.
EqualsASCII
(
media_device_name
)
)
{
aResult
.
AppendElement
(
new
DeviceType
(
source
)
)
;
break
;
}
}
}
else
{
for
(
auto
&
source
:
sources
)
{
aResult
.
AppendElement
(
new
DeviceType
(
source
)
)
;
}
}
}
static
auto
&
MediaManager_GetInstance
=
MediaManager
:
:
GetInstance
;
static
auto
&
MediaManager_ToJSArray
=
MediaManager
:
:
ToJSArray
;
static
auto
&
MediaManager_AnonymizeDevices
=
MediaManager
:
:
AnonymizeDevices
;
already_AddRefed
<
MediaManager
:
:
PledgeChar
>
MediaManager
:
:
SelectSettings
(
MediaStreamConstraints
&
aConstraints
RefPtr
<
Refcountable
<
UniquePtr
<
SourceSet
>
>
>
&
aSources
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
PledgeChar
>
p
=
new
PledgeChar
(
)
;
uint32_t
id
=
mOutstandingCharPledges
.
Append
(
*
p
)
;
MediaManager
:
:
PostTask
(
FROM_HERE
NewTaskFrom
(
[
id
aConstraints
aSources
]
(
)
mutable
{
auto
&
sources
=
*
*
aSources
;
nsTArray
<
RefPtr
<
VideoDevice
>
>
videos
;
nsTArray
<
RefPtr
<
AudioDevice
>
>
audios
;
for
(
auto
&
source
:
sources
)
{
if
(
source
-
>
mIsVideo
)
{
RefPtr
<
VideoDevice
>
video
=
static_cast
<
VideoDevice
*
>
(
source
.
get
(
)
)
;
videos
.
AppendElement
(
video
)
;
}
else
{
RefPtr
<
AudioDevice
>
audio
=
static_cast
<
AudioDevice
*
>
(
source
.
get
(
)
)
;
audios
.
AppendElement
(
audio
)
;
}
}
sources
.
Clear
(
)
;
const
char
*
badConstraint
=
nullptr
;
if
(
videos
.
Length
(
)
&
&
IsOn
(
aConstraints
.
mVideo
)
)
{
badConstraint
=
MediaConstraintsHelper
:
:
SelectSettings
(
GetInvariant
(
aConstraints
.
mVideo
)
videos
)
;
for
(
auto
&
video
:
videos
)
{
sources
.
AppendElement
(
video
)
;
}
}
if
(
audios
.
Length
(
)
&
&
IsOn
(
aConstraints
.
mAudio
)
)
{
badConstraint
=
MediaConstraintsHelper
:
:
SelectSettings
(
GetInvariant
(
aConstraints
.
mAudio
)
audios
)
;
for
(
auto
&
audio
:
audios
)
{
sources
.
AppendElement
(
audio
)
;
}
}
NS_DispatchToMainThread
(
do_AddRef
(
NewRunnableFrom
(
[
id
badConstraint
]
(
)
mutable
{
RefPtr
<
MediaManager
>
mgr
=
MediaManager_GetInstance
(
)
;
RefPtr
<
PledgeChar
>
p
=
mgr
-
>
mOutstandingCharPledges
.
Remove
(
id
)
;
if
(
p
)
{
p
-
>
Resolve
(
badConstraint
)
;
}
return
NS_OK
;
}
)
)
)
;
}
)
)
;
return
p
.
forget
(
)
;
}
class
GetUserMediaTask
:
public
Task
{
public
:
GetUserMediaTask
(
const
MediaStreamConstraints
&
aConstraints
already_AddRefed
<
nsIDOMGetUserMediaSuccessCallback
>
aOnSuccess
already_AddRefed
<
nsIDOMGetUserMediaErrorCallback
>
aOnFailure
uint64_t
aWindowID
GetUserMediaCallbackMediaStreamListener
*
aListener
MediaEnginePrefs
&
aPrefs
const
nsCString
&
aOrigin
MediaManager
:
:
SourceSet
*
aSourceSet
)
:
mConstraints
(
aConstraints
)
mOnSuccess
(
aOnSuccess
)
mOnFailure
(
aOnFailure
)
mWindowID
(
aWindowID
)
mListener
(
aListener
)
mPrefs
(
aPrefs
)
mOrigin
(
aOrigin
)
mDeviceChosen
(
false
)
mSourceSet
(
aSourceSet
)
mManager
(
MediaManager
:
:
GetInstance
(
)
)
{
}
~
GetUserMediaTask
(
)
{
}
void
Fail
(
const
nsAString
&
aName
const
nsAString
&
aMessage
=
EmptyString
(
)
)
{
RefPtr
<
MediaMgrError
>
error
=
new
MediaMgrError
(
aName
aMessage
)
;
RefPtr
<
ErrorCallbackRunnable
<
nsIDOMGetUserMediaSuccessCallback
>
>
runnable
=
new
ErrorCallbackRunnable
<
nsIDOMGetUserMediaSuccessCallback
>
(
mOnSuccess
mOnFailure
*
error
mWindowID
)
;
MOZ_ASSERT
(
!
mOnSuccess
)
;
MOZ_ASSERT
(
!
mOnFailure
)
;
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
NS_DispatchToMainThread
(
do_AddRef
(
new
GetUserMediaListenerRemove
(
mWindowID
mListener
)
)
)
;
}
void
Run
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mOnSuccess
)
;
MOZ_ASSERT
(
mOnFailure
)
;
MOZ_ASSERT
(
mDeviceChosen
)
;
nsresult
rv
;
if
(
mAudioDevice
)
{
rv
=
mAudioDevice
-
>
Allocate
(
GetInvariant
(
mConstraints
.
mAudio
)
mPrefs
mOrigin
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
allocate
audiosource
%
d
"
rv
)
)
;
Fail
(
NS_LITERAL_STRING
(
"
SourceUnavailableError
"
)
NS_LITERAL_STRING
(
"
Failed
to
allocate
audiosource
"
)
)
;
return
;
}
}
if
(
mVideoDevice
)
{
rv
=
mVideoDevice
-
>
Allocate
(
GetInvariant
(
mConstraints
.
mVideo
)
mPrefs
mOrigin
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
Failed
to
allocate
videosource
%
d
\
n
"
rv
)
)
;
if
(
mAudioDevice
)
{
mAudioDevice
-
>
GetSource
(
)
-
>
Deallocate
(
)
;
}
Fail
(
NS_LITERAL_STRING
(
"
SourceUnavailableError
"
)
NS_LITERAL_STRING
(
"
Failed
to
allocate
videosource
"
)
)
;
return
;
}
}
PeerIdentity
*
peerIdentity
=
nullptr
;
if
(
!
mConstraints
.
mPeerIdentity
.
IsEmpty
(
)
)
{
peerIdentity
=
new
PeerIdentity
(
mConstraints
.
mPeerIdentity
)
;
}
NS_DispatchToMainThread
(
do_AddRef
(
new
GetUserMediaStreamRunnable
(
mOnSuccess
mOnFailure
mWindowID
mListener
mOrigin
mAudioDevice
mVideoDevice
peerIdentity
)
)
)
;
MOZ_ASSERT
(
!
mOnSuccess
)
;
MOZ_ASSERT
(
!
mOnFailure
)
;
}
nsresult
Denied
(
const
nsAString
&
aName
const
nsAString
&
aMessage
=
EmptyString
(
)
)
{
MOZ_ASSERT
(
mOnSuccess
)
;
MOZ_ASSERT
(
mOnFailure
)
;
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIDOMGetUserMediaSuccessCallback
>
onSuccess
=
mOnSuccess
.
forget
(
)
;
nsCOMPtr
<
nsIDOMGetUserMediaErrorCallback
>
onFailure
=
mOnFailure
.
forget
(
)
;
if
(
auto
*
window
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
mWindowID
)
)
{
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
window
-
>
AsInner
(
)
aName
aMessage
)
;
onFailure
-
>
OnError
(
error
)
;
}
RefPtr
<
MediaManager
>
manager
(
MediaManager
:
:
GetInstance
(
)
)
;
manager
-
>
RemoveFromWindowList
(
mWindowID
mListener
)
;
}
else
{
Fail
(
aName
aMessage
)
;
}
MOZ_ASSERT
(
!
mOnSuccess
)
;
MOZ_ASSERT
(
!
mOnFailure
)
;
return
NS_OK
;
}
nsresult
SetContraints
(
const
MediaStreamConstraints
&
aConstraints
)
{
mConstraints
=
aConstraints
;
return
NS_OK
;
}
nsresult
SetAudioDevice
(
AudioDevice
*
aAudioDevice
)
{
mAudioDevice
=
aAudioDevice
;
mDeviceChosen
=
true
;
return
NS_OK
;
}
nsresult
SetVideoDevice
(
VideoDevice
*
aVideoDevice
)
{
mVideoDevice
=
aVideoDevice
;
mDeviceChosen
=
true
;
return
NS_OK
;
}
private
:
MediaStreamConstraints
mConstraints
;
nsCOMPtr
<
nsIDOMGetUserMediaSuccessCallback
>
mOnSuccess
;
nsCOMPtr
<
nsIDOMGetUserMediaErrorCallback
>
mOnFailure
;
uint64_t
mWindowID
;
RefPtr
<
GetUserMediaCallbackMediaStreamListener
>
mListener
;
RefPtr
<
AudioDevice
>
mAudioDevice
;
RefPtr
<
VideoDevice
>
mVideoDevice
;
MediaEnginePrefs
mPrefs
;
nsCString
mOrigin
;
bool
mDeviceChosen
;
public
:
nsAutoPtr
<
MediaManager
:
:
SourceSet
>
mSourceSet
;
private
:
RefPtr
<
MediaManager
>
mManager
;
}
;
#
if
defined
(
ANDROID
)
&
&
!
defined
(
MOZ_WIDGET_GONK
)
class
GetUserMediaRunnableWrapper
:
public
nsRunnable
{
public
:
GetUserMediaRunnableWrapper
(
GetUserMediaTask
*
task
)
:
mTask
(
task
)
{
}
~
GetUserMediaRunnableWrapper
(
)
{
}
NS_IMETHOD
Run
(
)
{
mTask
-
>
Run
(
)
;
return
NS_OK
;
}
private
:
nsAutoPtr
<
GetUserMediaTask
>
mTask
;
}
;
#
endif
already_AddRefed
<
MediaManager
:
:
PledgeSourceSet
>
MediaManager
:
:
EnumerateRawDevices
(
uint64_t
aWindowId
MediaSourceEnum
aVideoType
MediaSourceEnum
aAudioType
bool
aFake
bool
aFakeTracks
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aVideoType
!
=
MediaSourceEnum
:
:
Other
|
|
aAudioType
!
=
MediaSourceEnum
:
:
Other
)
;
RefPtr
<
PledgeSourceSet
>
p
=
new
PledgeSourceSet
(
)
;
uint32_t
id
=
mOutstandingPledges
.
Append
(
*
p
)
;
nsAdoptingCString
audioLoopDev
videoLoopDev
;
if
(
!
aFake
)
{
if
(
aVideoType
=
=
MediaSourceEnum
:
:
Camera
)
{
videoLoopDev
=
Preferences
:
:
GetCString
(
"
media
.
video_loopback_dev
"
)
;
}
if
(
aAudioType
=
=
MediaSourceEnum
:
:
Microphone
)
{
audioLoopDev
=
Preferences
:
:
GetCString
(
"
media
.
audio_loopback_dev
"
)
;
}
}
if
(
!
aFake
)
{
aFakeTracks
=
false
;
}
MediaManager
:
:
PostTask
(
FROM_HERE
NewTaskFrom
(
[
id
aWindowId
audioLoopDev
videoLoopDev
aVideoType
aAudioType
aFake
aFakeTracks
]
(
)
mutable
{
bool
hasVideo
=
aVideoType
!
=
MediaSourceEnum
:
:
Other
;
bool
hasAudio
=
aAudioType
!
=
MediaSourceEnum
:
:
Other
;
bool
fakeCams
=
aFake
&
&
aVideoType
=
=
MediaSourceEnum
:
:
Camera
;
bool
fakeMics
=
aFake
&
&
aAudioType
=
=
MediaSourceEnum
:
:
Microphone
;
RefPtr
<
MediaEngine
>
fakeBackend
realBackend
;
if
(
fakeCams
|
|
fakeMics
)
{
fakeBackend
=
new
MediaEngineDefault
(
aFakeTracks
)
;
}
if
(
(
!
fakeCams
&
&
hasVideo
)
|
|
(
!
fakeMics
&
&
hasAudio
)
)
{
RefPtr
<
MediaManager
>
manager
=
MediaManager_GetInstance
(
)
;
realBackend
=
manager
-
>
GetBackend
(
aWindowId
)
;
}
auto
result
=
MakeUnique
<
SourceSet
>
(
)
;
if
(
hasVideo
)
{
nsTArray
<
RefPtr
<
VideoDevice
>
>
videos
;
GetSources
(
fakeCams
?
fakeBackend
:
realBackend
aVideoType
&
MediaEngine
:
:
EnumerateVideoDevices
videos
videoLoopDev
)
;
for
(
auto
&
source
:
videos
)
{
result
-
>
AppendElement
(
source
)
;
}
}
if
(
hasAudio
)
{
nsTArray
<
RefPtr
<
AudioDevice
>
>
audios
;
GetSources
(
fakeMics
?
fakeBackend
:
realBackend
aAudioType
&
MediaEngine
:
:
EnumerateAudioDevices
audios
audioLoopDev
)
;
for
(
auto
&
source
:
audios
)
{
result
-
>
AppendElement
(
source
)
;
}
}
SourceSet
*
handoff
=
result
.
release
(
)
;
NS_DispatchToMainThread
(
do_AddRef
(
NewRunnableFrom
(
[
id
handoff
]
(
)
mutable
{
UniquePtr
<
SourceSet
>
result
(
handoff
)
;
RefPtr
<
MediaManager
>
mgr
=
MediaManager_GetInstance
(
)
;
if
(
!
mgr
)
{
return
NS_OK
;
}
RefPtr
<
PledgeSourceSet
>
p
=
mgr
-
>
mOutstandingPledges
.
Remove
(
id
)
;
if
(
p
)
{
p
-
>
Resolve
(
result
.
release
(
)
)
;
}
return
NS_OK
;
}
)
)
)
;
}
)
)
;
return
p
.
forget
(
)
;
}
MediaManager
:
:
MediaManager
(
)
:
mMediaThread
(
nullptr
)
mBackend
(
nullptr
)
{
mPrefs
.
mFreq
=
1000
;
mPrefs
.
mWidth
=
0
;
mPrefs
.
mHeight
=
0
;
mPrefs
.
mFPS
=
MediaEngine
:
:
DEFAULT_VIDEO_FPS
;
mPrefs
.
mMinFPS
=
MediaEngine
:
:
DEFAULT_VIDEO_MIN_FPS
;
mPrefs
.
mAecOn
=
false
;
mPrefs
.
mAgcOn
=
false
;
mPrefs
.
mNoiseOn
=
false
;
#
ifdef
MOZ_WEBRTC
mPrefs
.
mAec
=
webrtc
:
:
kEcUnchanged
;
mPrefs
.
mAgc
=
webrtc
:
:
kAgcUnchanged
;
mPrefs
.
mNoise
=
webrtc
:
:
kNsUnchanged
;
#
else
mPrefs
.
mAec
=
0
;
mPrefs
.
mAgc
=
0
;
mPrefs
.
mNoise
=
0
;
#
endif
mPrefs
.
mPlayoutDelay
=
0
;
mPrefs
.
mFullDuplex
=
false
;
nsresult
rv
;
nsCOMPtr
<
nsIPrefService
>
prefs
=
do_GetService
(
"
mozilla
.
org
/
preferences
-
service
;
1
"
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIPrefBranch
>
branch
=
do_QueryInterface
(
prefs
)
;
if
(
branch
)
{
GetPrefs
(
branch
nullptr
)
;
}
}
LOG
(
(
"
%
s
:
default
prefs
:
%
dx
%
d
%
dfps
(
min
%
d
)
%
dHz
test
tones
aec
:
%
s
"
"
agc
:
%
s
noise
:
%
s
aec
level
:
%
d
agc
level
:
%
d
noise
level
:
%
d
"
"
playout
delay
:
%
d
%
sfull_duplex
"
__FUNCTION__
mPrefs
.
mWidth
mPrefs
.
mHeight
mPrefs
.
mFPS
mPrefs
.
mMinFPS
mPrefs
.
mFreq
mPrefs
.
mAecOn
?
"
on
"
:
"
off
"
mPrefs
.
mAgcOn
?
"
on
"
:
"
off
"
mPrefs
.
mNoiseOn
?
"
on
"
:
"
off
"
mPrefs
.
mAec
mPrefs
.
mAgc
mPrefs
.
mNoise
mPrefs
.
mPlayoutDelay
mPrefs
.
mFullDuplex
?
"
"
:
"
not
"
)
)
;
}
NS_IMPL_ISUPPORTS
(
MediaManager
nsIMediaManagerService
nsIObserver
)
StaticRefPtr
<
MediaManager
>
MediaManager
:
:
sSingleton
;
#
ifdef
DEBUG
bool
MediaManager
:
:
IsInMediaThread
(
)
{
return
sSingleton
?
(
sSingleton
-
>
mMediaThread
-
>
thread_id
(
)
=
=
PlatformThread
:
:
CurrentId
(
)
)
:
false
;
}
#
endif
MediaManager
*
MediaManager
:
:
Get
(
)
{
if
(
!
sSingleton
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
static
int
timesCreated
=
0
;
timesCreated
+
+
;
MOZ_RELEASE_ASSERT
(
timesCreated
=
=
1
)
;
sSingleton
=
new
MediaManager
(
)
;
sSingleton
-
>
mMediaThread
=
new
base
:
:
Thread
(
"
MediaManager
"
)
;
base
:
:
Thread
:
:
Options
options
;
#
if
defined
(
_WIN32
)
options
.
message_loop_type
=
MessageLoop
:
:
TYPE_MOZILLA_NONMAINUITHREAD
;
#
else
options
.
message_loop_type
=
MessageLoop
:
:
TYPE_MOZILLA_NONMAINTHREAD
;
#
endif
if
(
!
sSingleton
-
>
mMediaThread
-
>
StartWithOptions
(
options
)
)
{
MOZ_CRASH
(
)
;
}
LOG
(
(
"
New
Media
thread
for
gum
"
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
sSingleton
"
last
-
pb
-
context
-
exited
"
false
)
;
obs
-
>
AddObserver
(
sSingleton
"
getUserMedia
:
privileged
:
allow
"
false
)
;
obs
-
>
AddObserver
(
sSingleton
"
getUserMedia
:
response
:
allow
"
false
)
;
obs
-
>
AddObserver
(
sSingleton
"
getUserMedia
:
response
:
deny
"
false
)
;
obs
-
>
AddObserver
(
sSingleton
"
getUserMedia
:
revoke
"
false
)
;
obs
-
>
AddObserver
(
sSingleton
"
phone
-
state
-
changed
"
false
)
;
}
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
prefs
)
{
prefs
-
>
AddObserver
(
"
media
.
navigator
.
video
.
default_width
"
sSingleton
false
)
;
prefs
-
>
AddObserver
(
"
media
.
navigator
.
video
.
default_height
"
sSingleton
false
)
;
prefs
-
>
AddObserver
(
"
media
.
navigator
.
video
.
default_fps
"
sSingleton
false
)
;
prefs
-
>
AddObserver
(
"
media
.
navigator
.
video
.
default_minfps
"
sSingleton
false
)
;
prefs
-
>
AddObserver
(
"
media
.
navigator
.
audio
.
fake_frequency
"
sSingleton
false
)
;
prefs
-
>
AddObserver
(
"
media
.
navigator
.
audio
.
full_duplex
"
sSingleton
false
)
;
#
ifdef
MOZ_WEBRTC
prefs
-
>
AddObserver
(
"
media
.
getusermedia
.
aec_enabled
"
sSingleton
false
)
;
prefs
-
>
AddObserver
(
"
media
.
getusermedia
.
aec
"
sSingleton
false
)
;
prefs
-
>
AddObserver
(
"
media
.
getusermedia
.
agc_enabled
"
sSingleton
false
)
;
prefs
-
>
AddObserver
(
"
media
.
getusermedia
.
agc
"
sSingleton
false
)
;
prefs
-
>
AddObserver
(
"
media
.
getusermedia
.
noise_enabled
"
sSingleton
false
)
;
prefs
-
>
AddObserver
(
"
media
.
getusermedia
.
noise
"
sSingleton
false
)
;
prefs
-
>
AddObserver
(
"
media
.
getusermedia
.
playout_delay
"
sSingleton
false
)
;
#
endif
}
nsCOMPtr
<
nsIAsyncShutdownClient
>
shutdownPhase
=
GetShutdownPhase
(
)
;
class
Blocker
:
public
media
:
:
ShutdownBlocker
{
public
:
Blocker
(
)
:
media
:
:
ShutdownBlocker
(
NS_LITERAL_STRING
(
"
Media
shutdown
:
blocking
on
media
thread
"
)
)
{
}
NS_IMETHOD
BlockShutdown
(
nsIAsyncShutdownClient
*
)
override
{
MOZ_RELEASE_ASSERT
(
MediaManager
:
:
GetIfExists
(
)
)
;
MediaManager
:
:
GetIfExists
(
)
-
>
Shutdown
(
)
;
return
NS_OK
;
}
}
;
sSingleton
-
>
mShutdownBlocker
=
new
Blocker
(
)
;
nsresult
rv
=
shutdownPhase
-
>
AddBlocker
(
sSingleton
-
>
mShutdownBlocker
NS_LITERAL_STRING
(
__FILE__
)
__LINE__
NS_LITERAL_STRING
(
"
Media
shutdown
"
)
)
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
#
ifdef
MOZ_B2G
(
void
)
MediaPermissionManager
:
:
GetInstance
(
)
;
#
endif
}
return
sSingleton
;
}
MediaManager
*
MediaManager
:
:
GetIfExists
(
)
{
return
sSingleton
;
}
already_AddRefed
<
MediaManager
>
MediaManager
:
:
GetInstance
(
)
{
RefPtr
<
MediaManager
>
service
=
MediaManager
:
:
Get
(
)
;
return
service
.
forget
(
)
;
}
media
:
:
Parent
<
media
:
:
NonE10s
>
*
MediaManager
:
:
GetNonE10sParent
(
)
{
if
(
!
mNonE10sParent
)
{
mNonE10sParent
=
MakeUnique
<
media
:
:
Parent
<
media
:
:
NonE10s
>
>
(
true
)
;
}
return
mNonE10sParent
.
get
(
)
;
}
void
MediaManager
:
:
StartupInit
(
)
{
#
ifdef
WIN32
if
(
IsVistaOrLater
(
)
&
&
!
IsWin8OrLater
(
)
)
{
unsigned
long
out_buf_len
=
sizeof
(
IP_ADAPTER_INFO
)
;
PIP_ADAPTER_INFO
pAdapterInfo
=
(
IP_ADAPTER_INFO
*
)
moz_xmalloc
(
out_buf_len
)
;
if
(
GetAdaptersInfo
(
pAdapterInfo
&
out_buf_len
)
=
=
ERROR_BUFFER_OVERFLOW
)
{
free
(
pAdapterInfo
)
;
pAdapterInfo
=
(
IP_ADAPTER_INFO
*
)
moz_xmalloc
(
out_buf_len
)
;
GetAdaptersInfo
(
pAdapterInfo
&
out_buf_len
)
;
}
if
(
pAdapterInfo
)
{
free
(
pAdapterInfo
)
;
}
}
#
endif
}
void
MediaManager
:
:
PostTask
(
const
tracked_objects
:
:
Location
&
from_here
Task
*
task
)
{
if
(
sInShutdown
)
{
return
;
}
NS_ASSERTION
(
Get
(
)
"
MediaManager
singleton
?
"
)
;
NS_ASSERTION
(
Get
(
)
-
>
mMediaThread
"
No
thread
yet
"
)
;
Get
(
)
-
>
mMediaThread
-
>
message_loop
(
)
-
>
PostTask
(
from_here
task
)
;
}
nsresult
MediaManager
:
:
NotifyRecordingStatusChange
(
nsPIDOMWindowInner
*
aWindow
const
nsString
&
aMsg
const
bool
&
aIsAudio
const
bool
&
aIsVideo
)
{
NS_ENSURE_ARG
(
aWindow
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
!
obs
)
{
NS_WARNING
(
"
Could
not
get
the
Observer
service
for
GetUserMedia
recording
notification
.
"
)
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsHashPropertyBag
>
props
=
new
nsHashPropertyBag
(
)
;
props
-
>
SetPropertyAsBool
(
NS_LITERAL_STRING
(
"
isAudio
"
)
aIsAudio
)
;
props
-
>
SetPropertyAsBool
(
NS_LITERAL_STRING
(
"
isVideo
"
)
aIsVideo
)
;
bool
isApp
=
false
;
nsString
requestURL
;
if
(
nsCOMPtr
<
nsIDocShell
>
docShell
=
aWindow
-
>
GetDocShell
(
)
)
{
nsresult
rv
=
docShell
-
>
GetIsApp
(
&
isApp
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
isApp
)
{
rv
=
docShell
-
>
GetAppManifestURL
(
requestURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
!
isApp
)
{
nsCString
pageURL
;
nsCOMPtr
<
nsIURI
>
docURI
=
aWindow
-
>
GetDocumentURI
(
)
;
NS_ENSURE_TRUE
(
docURI
NS_ERROR_FAILURE
)
;
nsresult
rv
=
docURI
-
>
GetSpec
(
pageURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
requestURL
=
NS_ConvertUTF8toUTF16
(
pageURL
)
;
}
props
-
>
SetPropertyAsBool
(
NS_LITERAL_STRING
(
"
isApp
"
)
isApp
)
;
props
-
>
SetPropertyAsAString
(
NS_LITERAL_STRING
(
"
requestURL
"
)
requestURL
)
;
obs
-
>
NotifyObservers
(
static_cast
<
nsIPropertyBag2
*
>
(
props
)
"
recording
-
device
-
events
"
aMsg
.
get
(
)
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
Unused
<
<
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendRecordingDeviceEvents
(
aMsg
requestURL
aIsAudio
aIsVideo
)
;
}
return
NS_OK
;
}
bool
MediaManager
:
:
IsPrivileged
(
)
{
bool
permission
=
nsContentUtils
:
:
IsCallerChrome
(
)
;
if
(
Preferences
:
:
GetBool
(
"
media
.
navigator
.
permission
.
disabled
"
false
)
)
{
permission
=
true
;
}
return
permission
;
}
bool
MediaManager
:
:
IsLoop
(
nsIURI
*
aDocURI
)
{
MOZ_ASSERT
(
aDocURI
)
;
nsCOMPtr
<
nsIURI
>
loopURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
loopURI
)
"
about
:
loopconversation
"
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
bool
result
=
false
;
rv
=
aDocURI
-
>
EqualsExceptRef
(
loopURI
&
result
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
result
;
}
bool
MediaManager
:
:
IsPrivateBrowsing
(
nsPIDOMWindowInner
*
window
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
window
-
>
GetDoc
(
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
=
doc
-
>
GetLoadContext
(
)
;
return
loadContext
&
&
loadContext
-
>
UsePrivateBrowsing
(
)
;
}
nsresult
MediaManager
:
:
GenerateUUID
(
nsAString
&
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsIUUIDGenerator
>
uuidgen
=
do_GetService
(
"
mozilla
.
org
/
uuid
-
generator
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsID
id
;
rv
=
uuidgen
-
>
GenerateUUIDInPlace
(
&
id
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
char
buffer
[
NSID_LENGTH
]
;
id
.
ToProvidedString
(
buffer
)
;
aResult
.
Assign
(
NS_ConvertUTF8toUTF16
(
buffer
)
)
;
return
NS_OK
;
}
enum
class
GetUserMediaSecurityState
{
Other
=
0
HTTPS
=
1
File
=
2
App
=
3
Localhost
=
4
Loop
=
5
Privileged
=
6
}
;
nsresult
MediaManager
:
:
GetUserMedia
(
nsPIDOMWindowInner
*
aWindow
const
MediaStreamConstraints
&
aConstraintsPassedIn
nsIDOMGetUserMediaSuccessCallback
*
aOnSuccess
nsIDOMGetUserMediaErrorCallback
*
aOnFailure
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aWindow
)
;
MOZ_ASSERT
(
aOnFailure
)
;
MOZ_ASSERT
(
aOnSuccess
)
;
nsCOMPtr
<
nsIDOMGetUserMediaSuccessCallback
>
onSuccess
(
aOnSuccess
)
;
nsCOMPtr
<
nsIDOMGetUserMediaErrorCallback
>
onFailure
(
aOnFailure
)
;
uint64_t
windowID
=
aWindow
-
>
WindowID
(
)
;
MediaStreamConstraints
c
(
aConstraintsPassedIn
)
;
if
(
!
IsOn
(
c
.
mVideo
)
&
&
!
IsOn
(
c
.
mAudio
)
)
{
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
aWindow
NS_LITERAL_STRING
(
"
NotSupportedError
"
)
NS_LITERAL_STRING
(
"
audio
and
/
or
video
is
required
"
)
)
;
onFailure
-
>
OnError
(
error
)
;
return
NS_OK
;
}
if
(
sInShutdown
)
{
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
aWindow
NS_LITERAL_STRING
(
"
AbortError
"
)
NS_LITERAL_STRING
(
"
In
shutdown
"
)
)
;
onFailure
-
>
OnError
(
error
)
;
return
NS_OK
;
}
nsIURI
*
docURI
=
aWindow
-
>
GetDocumentURI
(
)
;
if
(
!
docURI
)
{
return
NS_ERROR_UNEXPECTED
;
}
bool
loop
=
IsLoop
(
docURI
)
;
bool
privileged
=
loop
|
|
IsPrivileged
(
)
;
bool
isHTTPS
=
false
;
docURI
-
>
SchemeIs
(
"
https
"
&
isHTTPS
)
;
nsCString
host
;
nsresult
rv
=
docURI
-
>
GetHost
(
host
)
;
bool
isFile
;
docURI
-
>
SchemeIs
(
"
file
"
&
isFile
)
;
bool
isApp
;
docURI
-
>
SchemeIs
(
"
app
"
&
isApp
)
;
bool
isLocalhost
=
NS_SUCCEEDED
(
rv
)
&
&
(
host
.
LowerCaseEqualsLiteral
(
"
localhost
"
)
|
|
host
.
LowerCaseEqualsLiteral
(
"
127
.
0
.
0
.
1
"
)
|
|
host
.
LowerCaseEqualsLiteral
(
"
:
:
1
"
)
)
;
if
(
loop
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBRTC_GET_USER_MEDIA_SECURE_ORIGIN
(
uint32_t
)
GetUserMediaSecurityState
:
:
Loop
)
;
}
else
if
(
privileged
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBRTC_GET_USER_MEDIA_SECURE_ORIGIN
(
uint32_t
)
GetUserMediaSecurityState
:
:
Privileged
)
;
}
else
if
(
isHTTPS
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBRTC_GET_USER_MEDIA_SECURE_ORIGIN
(
uint32_t
)
GetUserMediaSecurityState
:
:
HTTPS
)
;
}
else
if
(
isFile
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBRTC_GET_USER_MEDIA_SECURE_ORIGIN
(
uint32_t
)
GetUserMediaSecurityState
:
:
File
)
;
}
else
if
(
isApp
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBRTC_GET_USER_MEDIA_SECURE_ORIGIN
(
uint32_t
)
GetUserMediaSecurityState
:
:
App
)
;
}
else
if
(
isLocalhost
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBRTC_GET_USER_MEDIA_SECURE_ORIGIN
(
uint32_t
)
GetUserMediaSecurityState
:
:
Localhost
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBRTC_GET_USER_MEDIA_SECURE_ORIGIN
(
uint32_t
)
GetUserMediaSecurityState
:
:
Other
)
;
}
nsCString
origin
;
rv
=
nsPrincipal
:
:
GetOriginForURI
(
docURI
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
Preferences
:
:
GetBool
(
"
media
.
navigator
.
video
.
enabled
"
true
)
)
{
c
.
mVideo
.
SetAsBoolean
(
)
=
false
;
}
MediaSourceEnum
videoType
=
MediaSourceEnum
:
:
Other
;
MediaSourceEnum
audioType
=
MediaSourceEnum
:
:
Other
;
if
(
c
.
mVideo
.
IsMediaTrackConstraints
(
)
)
{
auto
&
vc
=
c
.
mVideo
.
GetAsMediaTrackConstraints
(
)
;
videoType
=
StringToEnum
(
dom
:
:
MediaSourceEnumValues
:
:
strings
vc
.
mMediaSource
MediaSourceEnum
:
:
Other
)
;
Telemetry
:
:
Accumulate
(
loop
?
Telemetry
:
:
LOOP_GET_USER_MEDIA_TYPE
:
Telemetry
:
:
WEBRTC_GET_USER_MEDIA_TYPE
(
uint32_t
)
videoType
)
;
switch
(
videoType
)
{
case
MediaSourceEnum
:
:
Camera
:
break
;
case
MediaSourceEnum
:
:
Browser
:
if
(
!
vc
.
mBrowserWindow
.
WasPassed
(
)
)
{
nsPIDOMWindowOuter
*
outer
=
aWindow
-
>
GetOuterWindow
(
)
;
vc
.
mBrowserWindow
.
Construct
(
outer
-
>
WindowID
(
)
)
;
}
MOZ_FALLTHROUGH
;
case
MediaSourceEnum
:
:
Screen
:
case
MediaSourceEnum
:
:
Application
:
case
MediaSourceEnum
:
:
Window
:
if
(
!
Preferences
:
:
GetBool
(
(
(
videoType
=
=
MediaSourceEnum
:
:
Browser
)
?
"
media
.
getusermedia
.
browser
.
enabled
"
:
"
media
.
getusermedia
.
screensharing
.
enabled
"
)
false
)
|
|
#
if
defined
(
XP_MACOSX
)
|
|
defined
(
XP_WIN
)
(
(
videoType
!
=
MediaSourceEnum
:
:
Browser
)
&
&
!
Preferences
:
:
GetBool
(
"
media
.
getusermedia
.
screensharing
.
allow_on_old_platforms
"
false
)
&
&
#
if
defined
(
XP_MACOSX
)
!
nsCocoaFeatures
:
:
OnLionOrLater
(
)
#
endif
#
if
defined
(
XP_WIN
)
!
IsVistaOrLater
(
)
#
endif
)
|
|
#
endif
(
!
privileged
&
&
!
HostIsHttps
(
*
docURI
)
)
|
|
!
(
loop
|
|
HostHasPermission
(
*
docURI
)
)
)
{
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
aWindow
NS_LITERAL_STRING
(
"
SecurityError
"
)
)
;
onFailure
-
>
OnError
(
error
)
;
return
NS_OK
;
}
break
;
case
MediaSourceEnum
:
:
Microphone
:
case
MediaSourceEnum
:
:
Other
:
default
:
{
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
aWindow
NS_LITERAL_STRING
(
"
OverconstrainedError
"
)
NS_LITERAL_STRING
(
"
"
)
NS_LITERAL_STRING
(
"
mediaSource
"
)
)
;
onFailure
-
>
OnError
(
error
)
;
return
NS_OK
;
}
}
if
(
vc
.
mAdvanced
.
WasPassed
(
)
&
&
videoType
!
=
MediaSourceEnum
:
:
Camera
)
{
const
char
*
unset
=
EnumToASCII
(
dom
:
:
MediaSourceEnumValues
:
:
strings
MediaSourceEnum
:
:
Camera
)
;
for
(
MediaTrackConstraintSet
&
cs
:
vc
.
mAdvanced
.
Value
(
)
)
{
if
(
cs
.
mMediaSource
.
EqualsASCII
(
unset
)
)
{
cs
.
mMediaSource
=
vc
.
mMediaSource
;
}
}
}
if
(
!
privileged
)
{
if
(
vc
.
mBrowserWindow
.
WasPassed
(
)
)
{
vc
.
mBrowserWindow
.
Value
(
)
=
-
1
;
}
if
(
vc
.
mAdvanced
.
WasPassed
(
)
)
{
for
(
MediaTrackConstraintSet
&
cs
:
vc
.
mAdvanced
.
Value
(
)
)
{
if
(
cs
.
mBrowserWindow
.
WasPassed
(
)
)
{
cs
.
mBrowserWindow
.
Value
(
)
=
-
1
;
}
}
}
}
if
(
loop
&
&
(
videoType
=
=
MediaSourceEnum
:
:
Window
|
|
videoType
=
=
MediaSourceEnum
:
:
Application
|
|
videoType
=
=
MediaSourceEnum
:
:
Screen
)
)
{
privileged
=
false
;
}
}
else
if
(
IsOn
(
c
.
mVideo
)
)
{
videoType
=
MediaSourceEnum
:
:
Camera
;
}
if
(
c
.
mAudio
.
IsMediaTrackConstraints
(
)
)
{
auto
&
ac
=
c
.
mAudio
.
GetAsMediaTrackConstraints
(
)
;
audioType
=
StringToEnum
(
dom
:
:
MediaSourceEnumValues
:
:
strings
ac
.
mMediaSource
MediaSourceEnum
:
:
Other
)
;
if
(
audioType
=
=
MediaSourceEnum
:
:
Camera
)
{
audioType
=
MediaSourceEnum
:
:
Microphone
;
ac
.
mMediaSource
.
AssignASCII
(
EnumToASCII
(
dom
:
:
MediaSourceEnumValues
:
:
strings
audioType
)
)
;
}
Telemetry
:
:
Accumulate
(
loop
?
Telemetry
:
:
LOOP_GET_USER_MEDIA_TYPE
:
Telemetry
:
:
WEBRTC_GET_USER_MEDIA_TYPE
(
uint32_t
)
audioType
)
;
switch
(
audioType
)
{
case
MediaSourceEnum
:
:
Microphone
:
break
;
case
MediaSourceEnum
:
:
AudioCapture
:
if
(
!
Preferences
:
:
GetBool
(
"
media
.
getusermedia
.
audiocapture
.
enabled
"
)
)
{
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
aWindow
NS_LITERAL_STRING
(
"
SecurityError
"
)
)
;
onFailure
-
>
OnError
(
error
)
;
return
NS_OK
;
}
break
;
case
MediaSourceEnum
:
:
Other
:
default
:
{
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
aWindow
NS_LITERAL_STRING
(
"
OverconstrainedError
"
)
NS_LITERAL_STRING
(
"
"
)
NS_LITERAL_STRING
(
"
mediaSource
"
)
)
;
onFailure
-
>
OnError
(
error
)
;
return
NS_OK
;
}
}
if
(
ac
.
mAdvanced
.
WasPassed
(
)
)
{
const
char
*
unset
=
EnumToASCII
(
dom
:
:
MediaSourceEnumValues
:
:
strings
MediaSourceEnum
:
:
Camera
)
;
for
(
MediaTrackConstraintSet
&
cs
:
ac
.
mAdvanced
.
Value
(
)
)
{
if
(
cs
.
mMediaSource
.
EqualsASCII
(
unset
)
)
{
cs
.
mMediaSource
=
ac
.
mMediaSource
;
}
}
}
}
else
if
(
IsOn
(
c
.
mAudio
)
)
{
audioType
=
MediaSourceEnum
:
:
Microphone
;
}
StreamListeners
*
listeners
=
AddWindowID
(
windowID
)
;
RefPtr
<
GetUserMediaCallbackMediaStreamListener
>
listener
=
new
GetUserMediaCallbackMediaStreamListener
(
mMediaThread
windowID
)
;
listeners
-
>
AppendElement
(
listener
)
;
if
(
!
privileged
)
{
nsCOMPtr
<
nsIPermissionManager
>
permManager
=
do_GetService
(
NS_PERMISSIONMANAGER_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
audioPerm
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
if
(
IsOn
(
c
.
mAudio
)
)
{
rv
=
permManager
-
>
TestExactPermissionFromPrincipal
(
aWindow
-
>
GetExtantDoc
(
)
-
>
NodePrincipal
(
)
"
microphone
"
&
audioPerm
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
uint32_t
videoPerm
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
if
(
IsOn
(
c
.
mVideo
)
)
{
rv
=
permManager
-
>
TestExactPermissionFromPrincipal
(
aWindow
-
>
GetExtantDoc
(
)
-
>
NodePrincipal
(
)
"
camera
"
&
videoPerm
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
(
!
IsOn
(
c
.
mAudio
)
|
|
audioPerm
=
=
nsIPermissionManager
:
:
DENY_ACTION
)
&
&
(
!
IsOn
(
c
.
mVideo
)
|
|
videoPerm
=
=
nsIPermissionManager
:
:
DENY_ACTION
)
)
{
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
aWindow
NS_LITERAL_STRING
(
"
SecurityError
"
)
)
;
onFailure
-
>
OnError
(
error
)
;
RemoveFromWindowList
(
windowID
listener
)
;
return
NS_OK
;
}
}
#
if
defined
(
MOZ_B2G_CAMERA
)
&
&
defined
(
MOZ_WIDGET_GONK
)
if
(
mCameraManager
=
=
nullptr
)
{
mCameraManager
=
nsDOMCameraManager
:
:
CreateInstance
(
aWindow
)
;
}
#
endif
MediaEnginePrefs
prefs
=
mPrefs
;
nsString
callID
;
rv
=
GenerateUUID
(
callID
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
fake
=
c
.
mFake
.
WasPassed
(
)
?
c
.
mFake
.
Value
(
)
:
Preferences
:
:
GetBool
(
"
media
.
navigator
.
streams
.
fake
"
)
;
bool
fakeTracks
=
c
.
mFakeTracks
.
WasPassed
(
)
?
c
.
mFakeTracks
.
Value
(
)
:
false
;
bool
askPermission
=
!
privileged
&
&
(
!
fake
|
|
Preferences
:
:
GetBool
(
"
media
.
navigator
.
permission
.
fake
"
)
)
;
RefPtr
<
PledgeSourceSet
>
p
=
EnumerateDevicesImpl
(
windowID
videoType
audioType
fake
fakeTracks
)
;
p
-
>
Then
(
[
this
onSuccess
onFailure
windowID
c
listener
askPermission
prefs
isHTTPS
callID
origin
]
(
SourceSet
*
&
aDevices
)
mutable
{
RefPtr
<
Refcountable
<
UniquePtr
<
SourceSet
>
>
>
devices
(
new
Refcountable
<
UniquePtr
<
SourceSet
>
>
(
aDevices
)
)
;
if
(
!
MediaManager
:
:
Exists
(
)
|
|
!
nsGlobalWindow
:
:
GetInnerWindowWithId
(
windowID
)
)
{
return
;
}
RefPtr
<
PledgeChar
>
p2
=
SelectSettings
(
c
devices
)
;
p2
-
>
Then
(
[
this
onSuccess
onFailure
windowID
c
listener
askPermission
prefs
isHTTPS
callID
origin
devices
]
(
const
char
*
&
badConstraint
)
mutable
{
auto
*
globalWindow
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
windowID
)
;
RefPtr
<
nsPIDOMWindowInner
>
window
=
globalWindow
?
globalWindow
-
>
AsInner
(
)
:
nullptr
;
if
(
!
MediaManager
:
:
Exists
(
)
|
|
!
window
)
{
return
;
}
if
(
badConstraint
)
{
nsString
constraint
;
constraint
.
AssignASCII
(
badConstraint
)
;
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
window
NS_LITERAL_STRING
(
"
OverconstrainedError
"
)
NS_LITERAL_STRING
(
"
"
)
constraint
)
;
onFailure
-
>
OnError
(
error
)
;
return
;
}
if
(
!
(
*
devices
)
-
>
Length
(
)
)
{
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
window
NS_LITERAL_STRING
(
"
NotFoundError
"
)
)
;
onFailure
-
>
OnError
(
error
)
;
return
;
}
nsCOMPtr
<
nsISupportsArray
>
devicesCopy
;
if
(
!
askPermission
)
{
nsresult
rv
=
NS_NewISupportsArray
(
getter_AddRefs
(
devicesCopy
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
for
(
auto
&
device
:
*
*
devices
)
{
rv
=
devicesCopy
-
>
AppendElement
(
device
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
}
nsAutoPtr
<
GetUserMediaTask
>
task
(
new
GetUserMediaTask
(
c
onSuccess
.
forget
(
)
onFailure
.
forget
(
)
windowID
listener
prefs
origin
devices
-
>
release
(
)
)
)
;
mActiveCallbacks
.
Put
(
callID
task
.
forget
(
)
)
;
nsTArray
<
nsString
>
*
array
;
if
(
!
mCallIds
.
Get
(
windowID
&
array
)
)
{
array
=
new
nsTArray
<
nsString
>
(
)
;
mCallIds
.
Put
(
windowID
array
)
;
}
array
-
>
AppendElement
(
callID
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
!
askPermission
)
{
obs
-
>
NotifyObservers
(
devicesCopy
"
getUserMedia
:
privileged
:
allow
"
callID
.
BeginReading
(
)
)
;
}
else
{
RefPtr
<
GetUserMediaRequest
>
req
=
new
GetUserMediaRequest
(
window
callID
c
isHTTPS
)
;
obs
-
>
NotifyObservers
(
req
"
getUserMedia
:
request
"
nullptr
)
;
}
#
ifdef
MOZ_WEBRTC
EnableWebRtcLog
(
)
;
#
endif
}
[
onFailure
]
(
MediaStreamError
*
&
reason
)
mutable
{
onFailure
-
>
OnError
(
reason
)
;
}
)
;
}
[
onFailure
]
(
MediaStreamError
*
&
reason
)
mutable
{
onFailure
-
>
OnError
(
reason
)
;
}
)
;
return
NS_OK
;
}
void
MediaManager
:
:
AnonymizeDevices
(
SourceSet
&
aDevices
const
nsACString
&
aOriginKey
)
{
if
(
!
aOriginKey
.
IsEmpty
(
)
)
{
for
(
auto
&
device
:
aDevices
)
{
nsString
id
;
device
-
>
GetId
(
id
)
;
AnonymizeId
(
id
aOriginKey
)
;
device
-
>
SetId
(
id
)
;
}
}
}
nsresult
MediaManager
:
:
AnonymizeId
(
nsAString
&
aId
const
nsACString
&
aOriginKey
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsIKeyObjectFactory
>
factory
=
do_GetService
(
"
mozilla
.
org
/
security
/
keyobjectfactory
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCString
rawKey
;
rv
=
Base64Decode
(
aOriginKey
rawKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIKeyObject
>
key
;
rv
=
factory
-
>
KeyFromString
(
nsIKeyObject
:
:
HMAC
rawKey
getter_AddRefs
(
key
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsICryptoHMAC
>
hasher
=
do_CreateInstance
(
NS_CRYPTO_HMAC_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
hasher
-
>
Init
(
nsICryptoHMAC
:
:
SHA256
key
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
NS_ConvertUTF16toUTF8
id
(
aId
)
;
rv
=
hasher
-
>
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
id
.
get
(
)
)
id
.
Length
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCString
mac
;
rv
=
hasher
-
>
Finish
(
true
mac
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aId
=
NS_ConvertUTF8toUTF16
(
mac
)
;
return
NS_OK
;
}
already_AddRefed
<
nsIWritableVariant
>
MediaManager
:
:
ToJSArray
(
SourceSet
&
aDevices
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
nsVariantCC
>
var
=
new
nsVariantCC
(
)
;
size_t
len
=
aDevices
.
Length
(
)
;
if
(
len
)
{
nsTArray
<
nsIMediaDevice
*
>
tmp
(
len
)
;
for
(
auto
&
device
:
aDevices
)
{
tmp
.
AppendElement
(
device
)
;
}
auto
*
elements
=
static_cast
<
const
void
*
>
(
tmp
.
Elements
(
)
)
;
nsresult
rv
=
var
-
>
SetAsArray
(
nsIDataType
:
:
VTYPE_INTERFACE
&
NS_GET_IID
(
nsIMediaDevice
)
len
const_cast
<
void
*
>
(
elements
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
}
else
{
var
-
>
SetAsEmptyArray
(
)
;
}
return
var
.
forget
(
)
;
}
already_AddRefed
<
MediaManager
:
:
PledgeSourceSet
>
MediaManager
:
:
EnumerateDevicesImpl
(
uint64_t
aWindowId
MediaSourceEnum
aVideoType
MediaSourceEnum
aAudioType
bool
aFake
bool
aFakeTracks
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsPIDOMWindowInner
*
window
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
aWindowId
)
-
>
AsInner
(
)
;
RefPtr
<
PledgeSourceSet
>
pledge
=
new
PledgeSourceSet
(
)
;
uint32_t
id
=
mOutstandingPledges
.
Append
(
*
pledge
)
;
bool
privateBrowsing
=
IsPrivateBrowsing
(
window
)
;
nsCString
origin
;
nsPrincipal
:
:
GetOriginForURI
(
window
-
>
GetDocumentURI
(
)
origin
)
;
bool
persist
=
IsActivelyCapturingOrHasAPermission
(
aWindowId
)
;
RefPtr
<
Pledge
<
nsCString
>
>
p
=
media
:
:
GetOriginKey
(
origin
privateBrowsing
persist
)
;
p
-
>
Then
(
[
id
aWindowId
aVideoType
aAudioType
aFake
aFakeTracks
]
(
const
nsCString
&
aOriginKey
)
mutable
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
MediaManager
>
mgr
=
MediaManager_GetInstance
(
)
;
RefPtr
<
PledgeSourceSet
>
p
=
mgr
-
>
EnumerateRawDevices
(
aWindowId
aVideoType
aAudioType
aFake
aFakeTracks
)
;
p
-
>
Then
(
[
id
aWindowId
aOriginKey
]
(
SourceSet
*
&
aDevices
)
mutable
{
UniquePtr
<
SourceSet
>
devices
(
aDevices
)
;
RefPtr
<
MediaManager
>
mgr
=
MediaManager_GetInstance
(
)
;
if
(
!
mgr
)
{
return
NS_OK
;
}
RefPtr
<
PledgeSourceSet
>
p
=
mgr
-
>
mOutstandingPledges
.
Remove
(
id
)
;
if
(
!
p
|
|
!
mgr
-
>
IsWindowStillActive
(
aWindowId
)
)
{
return
NS_OK
;
}
MediaManager_AnonymizeDevices
(
*
devices
aOriginKey
)
;
p
-
>
Resolve
(
devices
.
release
(
)
)
;
return
NS_OK
;
}
)
;
}
)
;
return
pledge
.
forget
(
)
;
}
nsresult
MediaManager
:
:
EnumerateDevices
(
nsPIDOMWindowInner
*
aWindow
nsIGetUserMediaDevicesSuccessCallback
*
aOnSuccess
nsIDOMGetUserMediaErrorCallback
*
aOnFailure
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_TRUE
(
!
sInShutdown
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIGetUserMediaDevicesSuccessCallback
>
onSuccess
(
aOnSuccess
)
;
nsCOMPtr
<
nsIDOMGetUserMediaErrorCallback
>
onFailure
(
aOnFailure
)
;
uint64_t
windowId
=
aWindow
-
>
WindowID
(
)
;
StreamListeners
*
listeners
=
AddWindowID
(
windowId
)
;
RefPtr
<
GetUserMediaCallbackMediaStreamListener
>
listener
=
new
GetUserMediaCallbackMediaStreamListener
(
mMediaThread
windowId
)
;
listeners
-
>
AppendElement
(
listener
)
;
bool
fake
=
Preferences
:
:
GetBool
(
"
media
.
navigator
.
streams
.
fake
"
)
;
RefPtr
<
PledgeSourceSet
>
p
=
EnumerateDevicesImpl
(
windowId
MediaSourceEnum
:
:
Camera
MediaSourceEnum
:
:
Microphone
fake
)
;
p
-
>
Then
(
[
onSuccess
windowId
listener
]
(
SourceSet
*
&
aDevices
)
mutable
{
UniquePtr
<
SourceSet
>
devices
(
aDevices
)
;
RefPtr
<
MediaManager
>
mgr
=
MediaManager_GetInstance
(
)
;
mgr
-
>
RemoveFromWindowList
(
windowId
listener
)
;
nsCOMPtr
<
nsIWritableVariant
>
array
=
MediaManager_ToJSArray
(
*
devices
)
;
onSuccess
-
>
OnSuccess
(
array
)
;
}
[
onFailure
windowId
listener
]
(
MediaStreamError
*
&
reason
)
mutable
{
RefPtr
<
MediaManager
>
mgr
=
MediaManager_GetInstance
(
)
;
mgr
-
>
RemoveFromWindowList
(
windowId
listener
)
;
onFailure
-
>
OnError
(
reason
)
;
}
)
;
return
NS_OK
;
}
nsresult
MediaManager
:
:
GetUserMediaDevices
(
nsPIDOMWindowInner
*
aWindow
const
MediaStreamConstraints
&
aConstraints
nsIGetUserMediaDevicesSuccessCallback
*
aOnSuccess
nsIDOMGetUserMediaErrorCallback
*
aOnFailure
uint64_t
aWindowId
const
nsAString
&
aCallID
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIGetUserMediaDevicesSuccessCallback
>
onSuccess
(
aOnSuccess
)
;
nsCOMPtr
<
nsIDOMGetUserMediaErrorCallback
>
onFailure
(
aOnFailure
)
;
if
(
!
aWindowId
)
{
aWindowId
=
aWindow
-
>
WindowID
(
)
;
}
nsTArray
<
nsString
>
*
callIDs
;
if
(
!
mCallIds
.
Get
(
aWindowId
&
callIDs
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
for
(
auto
&
callID
:
*
callIDs
)
{
GetUserMediaTask
*
task
;
if
(
!
aCallID
.
Length
(
)
|
|
aCallID
=
=
callID
)
{
if
(
mActiveCallbacks
.
Get
(
callID
&
task
)
)
{
nsCOMPtr
<
nsIWritableVariant
>
array
=
MediaManager_ToJSArray
(
*
task
-
>
mSourceSet
)
;
onSuccess
-
>
OnSuccess
(
array
)
;
return
NS_OK
;
}
}
}
return
NS_ERROR_UNEXPECTED
;
}
MediaEngine
*
MediaManager
:
:
GetBackend
(
uint64_t
aWindowId
)
{
MOZ_ASSERT
(
MediaManager
:
:
IsInMediaThread
(
)
)
;
if
(
!
mBackend
)
{
MOZ_RELEASE_ASSERT
(
!
sInShutdown
)
;
#
if
defined
(
MOZ_WEBRTC
)
mBackend
=
new
MediaEngineWebRTC
(
mPrefs
)
;
#
else
mBackend
=
new
MediaEngineDefault
(
)
;
#
endif
}
return
mBackend
;
}
static
void
StopSharingCallback
(
MediaManager
*
aThis
uint64_t
aWindowID
StreamListeners
*
aListeners
void
*
aData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aListeners
)
{
auto
length
=
aListeners
-
>
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
length
;
+
+
i
)
{
GetUserMediaCallbackMediaStreamListener
*
listener
=
aListeners
-
>
ElementAt
(
i
)
;
if
(
listener
-
>
Stream
(
)
)
{
listener
-
>
Stop
(
)
;
}
listener
-
>
Remove
(
)
;
listener
-
>
StopSharing
(
)
;
}
aListeners
-
>
Clear
(
)
;
aThis
-
>
RemoveWindowID
(
aWindowID
)
;
}
}
void
MediaManager
:
:
OnNavigation
(
uint64_t
aWindowID
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
(
"
OnNavigation
for
%
llu
"
aWindowID
)
)
;
nsTArray
<
nsString
>
*
callIDs
;
if
(
mCallIds
.
Get
(
aWindowID
&
callIDs
)
)
{
for
(
auto
&
callID
:
*
callIDs
)
{
mActiveCallbacks
.
Remove
(
callID
)
;
}
mCallIds
.
Remove
(
aWindowID
)
;
}
auto
*
window
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
aWindowID
)
;
if
(
window
)
{
IterateWindowListeners
(
window
-
>
AsInner
(
)
StopSharingCallback
nullptr
)
;
}
else
{
RemoveWindowID
(
aWindowID
)
;
}
}
StreamListeners
*
MediaManager
:
:
AddWindowID
(
uint64_t
aWindowId
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StreamListeners
*
listeners
=
GetActiveWindows
(
)
-
>
Get
(
aWindowId
)
;
if
(
!
listeners
)
{
listeners
=
new
StreamListeners
;
GetActiveWindows
(
)
-
>
Put
(
aWindowId
listeners
)
;
}
return
listeners
;
}
void
MediaManager
:
:
RemoveWindowID
(
uint64_t
aWindowId
)
{
mActiveWindows
.
Remove
(
aWindowId
)
;
auto
*
window
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
aWindowId
)
;
if
(
!
window
)
{
LOG
(
(
"
No
inner
window
for
%
llu
"
aWindowId
)
)
;
return
;
}
nsPIDOMWindowOuter
*
outer
=
window
-
>
AsInner
(
)
-
>
GetOuterWindow
(
)
;
if
(
!
outer
)
{
LOG
(
(
"
No
outer
window
for
inner
%
llu
"
aWindowId
)
)
;
return
;
}
uint64_t
outerID
=
outer
-
>
WindowID
(
)
;
char
windowBuffer
[
32
]
;
snprintf_literal
(
windowBuffer
"
%
"
PRIu64
outerID
)
;
nsString
data
=
NS_ConvertUTF8toUTF16
(
windowBuffer
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
obs
-
>
NotifyObservers
(
nullptr
"
recording
-
window
-
ended
"
data
.
get
(
)
)
;
LOG
(
(
"
Sent
recording
-
window
-
ended
for
window
%
llu
(
outer
%
llu
)
"
aWindowId
outerID
)
)
;
}
void
MediaManager
:
:
RemoveFromWindowList
(
uint64_t
aWindowID
GetUserMediaCallbackMediaStreamListener
*
aListener
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aListener
-
>
Remove
(
)
;
StreamListeners
*
listeners
=
GetWindowListeners
(
aWindowID
)
;
if
(
!
listeners
)
{
return
;
}
listeners
-
>
RemoveElement
(
aListener
)
;
if
(
listeners
-
>
Length
(
)
=
=
0
)
{
RemoveWindowID
(
aWindowID
)
;
}
}
void
MediaManager
:
:
GetPref
(
nsIPrefBranch
*
aBranch
const
char
*
aPref
const
char
*
aData
int32_t
*
aVal
)
{
int32_t
temp
;
if
(
aData
=
=
nullptr
|
|
strcmp
(
aPref
aData
)
=
=
0
)
{
if
(
NS_SUCCEEDED
(
aBranch
-
>
GetIntPref
(
aPref
&
temp
)
)
)
{
*
aVal
=
temp
;
}
}
}
void
MediaManager
:
:
GetPrefBool
(
nsIPrefBranch
*
aBranch
const
char
*
aPref
const
char
*
aData
bool
*
aVal
)
{
bool
temp
;
if
(
aData
=
=
nullptr
|
|
strcmp
(
aPref
aData
)
=
=
0
)
{
if
(
NS_SUCCEEDED
(
aBranch
-
>
GetBoolPref
(
aPref
&
temp
)
)
)
{
*
aVal
=
temp
;
}
}
}
void
MediaManager
:
:
GetPrefs
(
nsIPrefBranch
*
aBranch
const
char
*
aData
)
{
GetPref
(
aBranch
"
media
.
navigator
.
video
.
default_width
"
aData
&
mPrefs
.
mWidth
)
;
GetPref
(
aBranch
"
media
.
navigator
.
video
.
default_height
"
aData
&
mPrefs
.
mHeight
)
;
GetPref
(
aBranch
"
media
.
navigator
.
video
.
default_fps
"
aData
&
mPrefs
.
mFPS
)
;
GetPref
(
aBranch
"
media
.
navigator
.
video
.
default_minfps
"
aData
&
mPrefs
.
mMinFPS
)
;
GetPref
(
aBranch
"
media
.
navigator
.
audio
.
fake_frequency
"
aData
&
mPrefs
.
mFreq
)
;
#
ifdef
MOZ_WEBRTC
GetPrefBool
(
aBranch
"
media
.
getusermedia
.
aec_enabled
"
aData
&
mPrefs
.
mAecOn
)
;
GetPrefBool
(
aBranch
"
media
.
getusermedia
.
agc_enabled
"
aData
&
mPrefs
.
mAgcOn
)
;
GetPrefBool
(
aBranch
"
media
.
getusermedia
.
noise_enabled
"
aData
&
mPrefs
.
mNoiseOn
)
;
GetPref
(
aBranch
"
media
.
getusermedia
.
aec
"
aData
&
mPrefs
.
mAec
)
;
GetPref
(
aBranch
"
media
.
getusermedia
.
agc
"
aData
&
mPrefs
.
mAgc
)
;
GetPref
(
aBranch
"
media
.
getusermedia
.
noise
"
aData
&
mPrefs
.
mNoise
)
;
GetPref
(
aBranch
"
media
.
getusermedia
.
playout_delay
"
aData
&
mPrefs
.
mPlayoutDelay
)
;
#
endif
GetPrefBool
(
aBranch
"
media
.
navigator
.
audio
.
full_duplex
"
aData
&
mPrefs
.
mFullDuplex
)
;
}
void
MediaManager
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
sInShutdown
)
{
return
;
}
sInShutdown
=
true
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
obs
-
>
RemoveObserver
(
this
"
last
-
pb
-
context
-
exited
"
)
;
obs
-
>
RemoveObserver
(
this
"
getUserMedia
:
privileged
:
allow
"
)
;
obs
-
>
RemoveObserver
(
this
"
getUserMedia
:
response
:
allow
"
)
;
obs
-
>
RemoveObserver
(
this
"
getUserMedia
:
response
:
deny
"
)
;
obs
-
>
RemoveObserver
(
this
"
getUserMedia
:
revoke
"
)
;
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
prefs
)
{
prefs
-
>
RemoveObserver
(
"
media
.
navigator
.
video
.
default_width
"
this
)
;
prefs
-
>
RemoveObserver
(
"
media
.
navigator
.
video
.
default_height
"
this
)
;
prefs
-
>
RemoveObserver
(
"
media
.
navigator
.
video
.
default_fps
"
this
)
;
prefs
-
>
RemoveObserver
(
"
media
.
navigator
.
video
.
default_minfps
"
this
)
;
prefs
-
>
RemoveObserver
(
"
media
.
navigator
.
audio
.
fake_frequency
"
this
)
;
#
ifdef
MOZ_WEBRTC
prefs
-
>
RemoveObserver
(
"
media
.
getusermedia
.
aec_enabled
"
this
)
;
prefs
-
>
RemoveObserver
(
"
media
.
getusermedia
.
aec
"
this
)
;
prefs
-
>
RemoveObserver
(
"
media
.
getusermedia
.
agc_enabled
"
this
)
;
prefs
-
>
RemoveObserver
(
"
media
.
getusermedia
.
agc
"
this
)
;
prefs
-
>
RemoveObserver
(
"
media
.
getusermedia
.
noise_enabled
"
this
)
;
prefs
-
>
RemoveObserver
(
"
media
.
getusermedia
.
noise
"
this
)
;
prefs
-
>
RemoveObserver
(
"
media
.
getusermedia
.
playout_delay
"
this
)
;
#
endif
prefs
-
>
RemoveObserver
(
"
media
.
navigator
.
audio
.
full_duplex
"
this
)
;
}
GetActiveWindows
(
)
-
>
Clear
(
)
;
mActiveCallbacks
.
Clear
(
)
;
mCallIds
.
Clear
(
)
;
#
ifdef
MOZ_WEBRTC
StopWebRtcLog
(
)
;
#
endif
class
ShutdownTask
:
public
Task
{
public
:
ShutdownTask
(
MediaManager
*
aManager
nsRunnable
*
aReply
)
:
mManager
(
aManager
)
mReply
(
aReply
)
{
}
private
:
void
Run
(
)
override
{
LOG
(
(
"
MediaManager
Thread
Shutdown
"
)
)
;
MOZ_ASSERT
(
MediaManager
:
:
IsInMediaThread
(
)
)
;
{
if
(
mManager
-
>
mBackend
)
{
mManager
-
>
mBackend
-
>
Shutdown
(
)
;
}
}
mozilla
:
:
ipc
:
:
BackgroundChild
:
:
CloseForCurrentThread
(
)
;
mManager
-
>
mBackend
=
nullptr
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
mReply
.
forget
(
)
)
)
)
{
LOG
(
(
"
Will
leak
thread
:
DispatchToMainthread
of
reply
runnable
failed
in
MediaManager
shutdown
"
)
)
;
}
}
RefPtr
<
MediaManager
>
mManager
;
RefPtr
<
nsRunnable
>
mReply
;
}
;
RefPtr
<
MediaManager
>
that
(
sSingleton
)
;
mMediaThread
-
>
message_loop
(
)
-
>
PostTask
(
FROM_HERE
new
ShutdownTask
(
this
media
:
:
NewRunnableFrom
(
[
this
that
]
(
)
mutable
{
LOG
(
(
"
MediaManager
shutdown
lambda
running
releasing
MediaManager
singleton
and
thread
"
)
)
;
if
(
mMediaThread
)
{
mMediaThread
-
>
Stop
(
)
;
}
nsCOMPtr
<
nsIAsyncShutdownClient
>
shutdownPhase
=
GetShutdownPhase
(
)
;
shutdownPhase
-
>
RemoveBlocker
(
sSingleton
-
>
mShutdownBlocker
)
;
sSingleton
=
nullptr
;
return
NS_OK
;
}
)
)
)
;
}
nsresult
MediaManager
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
)
{
nsCOMPtr
<
nsIPrefBranch
>
branch
(
do_QueryInterface
(
aSubject
)
)
;
if
(
branch
)
{
GetPrefs
(
branch
NS_ConvertUTF16toUTF8
(
aData
)
.
get
(
)
)
;
LOG
(
(
"
%
s
:
%
dx
%
d
%
dfps
(
min
%
d
)
"
__FUNCTION__
mPrefs
.
mWidth
mPrefs
.
mHeight
mPrefs
.
mFPS
mPrefs
.
mMinFPS
)
)
;
}
}
else
if
(
!
strcmp
(
aTopic
"
last
-
pb
-
context
-
exited
"
)
)
{
media
:
:
SanitizeOriginKeys
(
0
true
)
;
return
NS_OK
;
}
else
if
(
!
strcmp
(
aTopic
"
getUserMedia
:
privileged
:
allow
"
)
|
|
!
strcmp
(
aTopic
"
getUserMedia
:
response
:
allow
"
)
)
{
nsString
key
(
aData
)
;
nsAutoPtr
<
GetUserMediaTask
>
task
;
mActiveCallbacks
.
RemoveAndForget
(
key
task
)
;
if
(
!
task
)
{
return
NS_OK
;
}
if
(
aSubject
)
{
nsCOMPtr
<
nsISupportsArray
>
array
(
do_QueryInterface
(
aSubject
)
)
;
MOZ_ASSERT
(
array
)
;
uint32_t
len
=
0
;
array
-
>
Count
(
&
len
)
;
if
(
!
len
)
{
task
-
>
Denied
(
NS_LITERAL_STRING
(
"
SecurityError
"
)
)
;
return
NS_OK
;
}
bool
videoFound
=
false
audioFound
=
false
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
nsCOMPtr
<
nsISupports
>
supports
;
array
-
>
GetElementAt
(
i
getter_AddRefs
(
supports
)
)
;
nsCOMPtr
<
nsIMediaDevice
>
device
(
do_QueryInterface
(
supports
)
)
;
MOZ_ASSERT
(
device
)
;
if
(
device
)
{
nsString
type
;
device
-
>
GetType
(
type
)
;
if
(
type
.
EqualsLiteral
(
"
video
"
)
)
{
if
(
!
videoFound
)
{
task
-
>
SetVideoDevice
(
static_cast
<
VideoDevice
*
>
(
device
.
get
(
)
)
)
;
videoFound
=
true
;
}
}
else
if
(
type
.
EqualsLiteral
(
"
audio
"
)
)
{
if
(
!
audioFound
)
{
task
-
>
SetAudioDevice
(
static_cast
<
AudioDevice
*
>
(
device
.
get
(
)
)
)
;
audioFound
=
true
;
}
}
else
{
NS_WARNING
(
"
Unknown
device
type
in
getUserMedia
"
)
;
}
}
}
}
if
(
sInShutdown
)
{
return
task
-
>
Denied
(
NS_LITERAL_STRING
(
"
In
shutdown
"
)
)
;
}
MediaManager
:
:
PostTask
(
FROM_HERE
task
.
forget
(
)
)
;
return
NS_OK
;
}
else
if
(
!
strcmp
(
aTopic
"
getUserMedia
:
response
:
deny
"
)
)
{
nsString
errorMessage
(
NS_LITERAL_STRING
(
"
SecurityError
"
)
)
;
if
(
aSubject
)
{
nsCOMPtr
<
nsISupportsString
>
msg
(
do_QueryInterface
(
aSubject
)
)
;
MOZ_ASSERT
(
msg
)
;
msg
-
>
GetData
(
errorMessage
)
;
if
(
errorMessage
.
IsEmpty
(
)
)
errorMessage
.
AssignLiteral
(
MOZ_UTF16
(
"
InternalError
"
)
)
;
}
nsString
key
(
aData
)
;
nsAutoPtr
<
GetUserMediaTask
>
task
;
mActiveCallbacks
.
RemoveAndForget
(
key
task
)
;
if
(
task
)
{
task
-
>
Denied
(
errorMessage
)
;
}
return
NS_OK
;
}
else
if
(
!
strcmp
(
aTopic
"
getUserMedia
:
revoke
"
)
)
{
nsresult
rv
;
nsDependentString
data
(
aData
)
;
if
(
Substring
(
data
0
strlen
(
"
screen
:
"
)
)
.
EqualsLiteral
(
"
screen
:
"
)
)
{
uint64_t
windowID
=
PromiseFlatString
(
Substring
(
data
strlen
(
"
screen
:
"
)
)
)
.
ToInteger64
(
&
rv
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
Revoking
Screen
/
windowCapture
access
for
window
%
llu
"
windowID
)
)
;
StopScreensharing
(
windowID
)
;
}
}
else
{
uint64_t
windowID
=
nsString
(
aData
)
.
ToInteger64
(
&
rv
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
(
"
Revoking
MediaCapture
access
for
window
%
llu
"
windowID
)
)
;
OnNavigation
(
windowID
)
;
}
}
return
NS_OK
;
}
#
ifdef
MOZ_WIDGET_GONK
else
if
(
!
strcmp
(
aTopic
"
phone
-
state
-
changed
"
)
)
{
nsString
state
(
aData
)
;
nsresult
rv
;
uint32_t
phoneState
=
state
.
ToInteger
(
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
phoneState
=
=
nsIAudioManager
:
:
PHONE_STATE_IN_CALL
)
{
StopMediaStreams
(
)
;
}
return
NS_OK
;
}
#
endif
return
NS_OK
;
}
nsresult
MediaManager
:
:
GetActiveMediaCaptureWindows
(
nsISupportsArray
*
*
aArray
)
{
MOZ_ASSERT
(
aArray
)
;
nsISupportsArray
*
array
;
nsresult
rv
=
NS_NewISupportsArray
(
&
array
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
for
(
auto
iter
=
mActiveWindows
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
uint64_t
&
id
=
iter
.
Key
(
)
;
StreamListeners
*
listeners
=
iter
.
UserData
(
)
;
nsPIDOMWindowInner
*
window
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
id
)
-
>
AsInner
(
)
;
MOZ_ASSERT
(
window
)
;
if
(
!
window
)
{
continue
;
}
bool
capturing
=
false
;
if
(
listeners
)
{
uint32_t
length
=
listeners
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
RefPtr
<
GetUserMediaCallbackMediaStreamListener
>
listener
=
listeners
-
>
ElementAt
(
i
)
;
if
(
listener
-
>
CapturingVideo
(
)
|
|
listener
-
>
CapturingAudio
(
)
|
|
listener
-
>
CapturingScreen
(
)
|
|
listener
-
>
CapturingWindow
(
)
|
|
listener
-
>
CapturingApplication
(
)
)
{
capturing
=
true
;
break
;
}
}
}
if
(
capturing
)
{
array
-
>
AppendElement
(
window
)
;
}
}
*
aArray
=
array
;
return
NS_OK
;
}
struct
CaptureWindowStateData
{
bool
*
mVideo
;
bool
*
mAudio
;
bool
*
mScreenShare
;
bool
*
mWindowShare
;
bool
*
mAppShare
;
bool
*
mBrowserShare
;
}
;
static
void
CaptureWindowStateCallback
(
MediaManager
*
aThis
uint64_t
aWindowID
StreamListeners
*
aListeners
void
*
aData
)
{
struct
CaptureWindowStateData
*
data
=
(
struct
CaptureWindowStateData
*
)
aData
;
if
(
aListeners
)
{
auto
length
=
aListeners
-
>
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
length
;
+
+
i
)
{
GetUserMediaCallbackMediaStreamListener
*
listener
=
aListeners
-
>
ElementAt
(
i
)
;
if
(
listener
-
>
CapturingVideo
(
)
)
{
*
data
-
>
mVideo
=
true
;
}
if
(
listener
-
>
CapturingAudio
(
)
)
{
*
data
-
>
mAudio
=
true
;
}
if
(
listener
-
>
CapturingScreen
(
)
)
{
*
data
-
>
mScreenShare
=
true
;
}
if
(
listener
-
>
CapturingWindow
(
)
)
{
*
data
-
>
mWindowShare
=
true
;
}
if
(
listener
-
>
CapturingApplication
(
)
)
{
*
data
-
>
mAppShare
=
true
;
}
if
(
listener
-
>
CapturingBrowser
(
)
)
{
*
data
-
>
mBrowserShare
=
true
;
}
}
}
}
NS_IMETHODIMP
MediaManager
:
:
MediaCaptureWindowState
(
nsIDOMWindow
*
aWindow
bool
*
aVideo
bool
*
aAudio
bool
*
aScreenShare
bool
*
aWindowShare
bool
*
aAppShare
bool
*
aBrowserShare
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
struct
CaptureWindowStateData
data
;
data
.
mVideo
=
aVideo
;
data
.
mAudio
=
aAudio
;
data
.
mScreenShare
=
aScreenShare
;
data
.
mWindowShare
=
aWindowShare
;
data
.
mAppShare
=
aAppShare
;
data
.
mBrowserShare
=
aBrowserShare
;
*
aVideo
=
false
;
*
aAudio
=
false
;
*
aScreenShare
=
false
;
*
aWindowShare
=
false
;
*
aAppShare
=
false
;
*
aBrowserShare
=
false
;
nsCOMPtr
<
nsPIDOMWindowInner
>
piWin
=
do_QueryInterface
(
aWindow
)
;
if
(
piWin
)
{
IterateWindowListeners
(
piWin
CaptureWindowStateCallback
&
data
)
;
}
#
ifdef
DEBUG
LOG
(
(
"
%
s
:
window
%
lld
capturing
%
s
%
s
%
s
%
s
%
s
%
s
"
__FUNCTION__
piWin
?
piWin
-
>
WindowID
(
)
:
-
1
*
aVideo
?
"
video
"
:
"
"
*
aAudio
?
"
audio
"
:
"
"
*
aScreenShare
?
"
screenshare
"
:
"
"
*
aWindowShare
?
"
windowshare
"
:
"
"
*
aAppShare
?
"
appshare
"
:
"
"
*
aBrowserShare
?
"
browsershare
"
:
"
"
)
)
;
#
endif
return
NS_OK
;
}
NS_IMETHODIMP
MediaManager
:
:
SanitizeDeviceIds
(
int64_t
aSinceWhen
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
(
"
%
s
:
sinceWhen
=
%
llu
"
__FUNCTION__
aSinceWhen
)
)
;
media
:
:
SanitizeOriginKeys
(
aSinceWhen
false
)
;
return
NS_OK
;
}
static
void
StopScreensharingCallback
(
MediaManager
*
aThis
uint64_t
aWindowID
StreamListeners
*
aListeners
void
*
aData
)
{
if
(
aListeners
)
{
auto
length
=
aListeners
-
>
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
length
;
+
+
i
)
{
aListeners
-
>
ElementAt
(
i
)
-
>
StopSharing
(
)
;
}
}
}
void
MediaManager
:
:
StopScreensharing
(
uint64_t
aWindowID
)
{
auto
*
window
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
aWindowID
)
;
if
(
!
window
)
{
return
;
}
IterateWindowListeners
(
window
-
>
AsInner
(
)
&
StopScreensharingCallback
nullptr
)
;
}
void
MediaManager
:
:
IterateWindowListeners
(
nsPIDOMWindowInner
*
aWindow
WindowListenerCallback
aCallback
void
*
aData
)
{
if
(
aWindow
)
{
uint64_t
windowID
=
aWindow
-
>
WindowID
(
)
;
StreamListeners
*
listeners
=
GetActiveWindows
(
)
-
>
Get
(
windowID
)
;
(
*
aCallback
)
(
this
windowID
listeners
aData
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
aWindow
-
>
GetDocShell
(
)
;
if
(
docShell
)
{
int32_t
i
count
;
docShell
-
>
GetChildCount
(
&
count
)
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
item
;
docShell
-
>
GetChildAt
(
i
getter_AddRefs
(
item
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
winOuter
=
item
?
item
-
>
GetWindow
(
)
:
nullptr
;
if
(
winOuter
)
{
IterateWindowListeners
(
winOuter
-
>
GetCurrentInnerWindow
(
)
aCallback
aData
)
;
}
}
}
}
}
void
MediaManager
:
:
StopMediaStreams
(
)
{
nsCOMPtr
<
nsISupportsArray
>
array
;
GetActiveMediaCaptureWindows
(
getter_AddRefs
(
array
)
)
;
uint32_t
len
;
array
-
>
Count
(
&
len
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
nsCOMPtr
<
nsISupports
>
window
;
array
-
>
GetElementAt
(
i
getter_AddRefs
(
window
)
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
win
(
do_QueryInterface
(
window
)
)
;
if
(
win
)
{
OnNavigation
(
win
-
>
WindowID
(
)
)
;
}
}
}
bool
MediaManager
:
:
IsActivelyCapturingOrHasAPermission
(
uint64_t
aWindowId
)
{
nsCOMPtr
<
nsISupportsArray
>
array
;
GetActiveMediaCaptureWindows
(
getter_AddRefs
(
array
)
)
;
uint32_t
len
;
array
-
>
Count
(
&
len
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
nsCOMPtr
<
nsISupports
>
window
;
array
-
>
GetElementAt
(
i
getter_AddRefs
(
window
)
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
win
(
do_QueryInterface
(
window
)
)
;
if
(
win
&
&
win
-
>
WindowID
(
)
=
=
aWindowId
)
{
return
true
;
}
}
auto
*
window
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
aWindowId
)
;
if
(
NS_WARN_IF
(
!
window
)
)
{
return
false
;
}
nsresult
rv
;
nsCOMPtr
<
nsIPermissionManager
>
mgr
=
do_GetService
(
NS_PERMISSIONMANAGER_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
uint32_t
audio
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
uint32_t
video
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
{
auto
*
principal
=
window
-
>
GetExtantDoc
(
)
-
>
NodePrincipal
(
)
;
rv
=
mgr
-
>
TestExactPermissionFromPrincipal
(
principal
"
microphone
"
&
audio
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
rv
=
mgr
-
>
TestExactPermissionFromPrincipal
(
principal
"
camera
"
&
video
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
}
return
audio
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
|
|
video
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
;
}
void
GetUserMediaCallbackMediaStreamListener
:
:
Stop
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Only
call
on
main
thread
"
)
;
if
(
mStopped
)
{
return
;
}
MediaManager
:
:
PostTask
(
FROM_HERE
new
MediaOperationTask
(
MEDIA_STOP
this
nullptr
nullptr
!
mAudioStopped
?
mAudioDevice
.
get
(
)
:
nullptr
!
mVideoStopped
?
mVideoDevice
.
get
(
)
:
nullptr
false
mWindowID
nullptr
)
)
;
mStopped
=
mAudioStopped
=
mVideoStopped
=
true
;
}
void
GetUserMediaCallbackMediaStreamListener
:
:
StopSharing
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mVideoDevice
&
&
(
mVideoDevice
-
>
GetMediaSource
(
)
=
=
MediaSourceEnum
:
:
Screen
|
|
mVideoDevice
-
>
GetMediaSource
(
)
=
=
MediaSourceEnum
:
:
Application
|
|
mVideoDevice
-
>
GetMediaSource
(
)
=
=
MediaSourceEnum
:
:
Window
)
)
{
StopTrack
(
kVideoTrack
)
;
}
else
if
(
mAudioDevice
&
&
mAudioDevice
-
>
GetMediaSource
(
)
=
=
MediaSourceEnum
:
:
AudioCapture
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
mWindowID
)
-
>
AsInner
(
)
;
MOZ_ASSERT
(
window
)
;
window
-
>
SetAudioCapture
(
false
)
;
MediaStreamGraph
*
graph
=
MediaStreamGraph
:
:
GetInstance
(
MediaStreamGraph
:
:
AUDIO_THREAD_DRIVER
dom
:
:
AudioChannel
:
:
Normal
)
;
graph
-
>
UnregisterCaptureStreamForWindow
(
mWindowID
)
;
mStream
-
>
Destroy
(
)
;
}
}
already_AddRefed
<
GetUserMediaCallbackMediaStreamListener
:
:
PledgeVoid
>
GetUserMediaCallbackMediaStreamListener
:
:
ApplyConstraintsToTrack
(
nsPIDOMWindowInner
*
aWindow
TrackID
aTrackID
bool
aIsAudio
const
MediaTrackConstraints
&
aConstraints
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
PledgeVoid
>
p
=
new
PledgeVoid
(
)
;
if
(
!
(
(
(
aIsAudio
&
&
mAudioDevice
)
|
|
(
!
aIsAudio
&
&
mVideoDevice
)
)
&
&
!
mStopped
)
)
{
LOG
(
(
"
gUM
track
%
d
applyConstraints
but
we
don
'
t
have
type
%
s
"
aTrackID
aIsAudio
?
"
audio
"
:
"
video
"
)
)
;
p
-
>
Resolve
(
false
)
;
return
p
.
forget
(
)
;
}
RefPtr
<
AudioDevice
>
audioDevice
=
aIsAudio
?
mAudioDevice
.
get
(
)
:
nullptr
;
RefPtr
<
VideoDevice
>
videoDevice
=
!
aIsAudio
?
mVideoDevice
.
get
(
)
:
nullptr
;
RefPtr
<
MediaManager
>
mgr
=
MediaManager
:
:
GetInstance
(
)
;
uint32_t
id
=
mgr
-
>
mOutstandingVoidPledges
.
Append
(
*
p
)
;
uint64_t
windowId
=
aWindow
-
>
WindowID
(
)
;
MediaManager
:
:
PostTask
(
FROM_HERE
NewTaskFrom
(
[
id
windowId
audioDevice
videoDevice
aConstraints
]
(
)
mutable
{
MOZ_ASSERT
(
MediaManager
:
:
IsInMediaThread
(
)
)
;
RefPtr
<
MediaManager
>
mgr
=
MediaManager
:
:
GetInstance
(
)
;
const
char
*
badConstraint
=
nullptr
;
nsresult
rv
=
NS_OK
;
if
(
audioDevice
)
{
rv
=
audioDevice
-
>
Restart
(
aConstraints
mgr
-
>
mPrefs
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
nsTArray
<
RefPtr
<
AudioDevice
>
>
audios
;
audios
.
AppendElement
(
audioDevice
)
;
badConstraint
=
MediaConstraintsHelper
:
:
SelectSettings
(
aConstraints
audios
)
;
}
}
else
{
rv
=
videoDevice
-
>
Restart
(
aConstraints
mgr
-
>
mPrefs
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
nsTArray
<
RefPtr
<
VideoDevice
>
>
videos
;
videos
.
AppendElement
(
videoDevice
)
;
badConstraint
=
MediaConstraintsHelper
:
:
SelectSettings
(
aConstraints
videos
)
;
}
}
NS_DispatchToMainThread
(
do_AddRef
(
NewRunnableFrom
(
[
id
windowId
rv
badConstraint
]
(
)
mutable
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
MediaManager
>
mgr
=
MediaManager_GetInstance
(
)
;
if
(
!
mgr
)
{
return
NS_OK
;
}
RefPtr
<
PledgeVoid
>
p
=
mgr
-
>
mOutstandingVoidPledges
.
Remove
(
id
)
;
if
(
p
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
p
-
>
Resolve
(
false
)
;
}
else
{
auto
*
window
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
windowId
)
;
if
(
window
)
{
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
nsString
constraint
;
constraint
.
AssignASCII
(
badConstraint
)
;
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
window
-
>
AsInner
(
)
NS_LITERAL_STRING
(
"
OverconstrainedError
"
)
NS_LITERAL_STRING
(
"
"
)
constraint
)
;
p
-
>
Reject
(
error
)
;
}
else
{
RefPtr
<
MediaStreamError
>
error
=
new
MediaStreamError
(
window
-
>
AsInner
(
)
NS_LITERAL_STRING
(
"
InternalError
"
)
)
;
p
-
>
Reject
(
error
)
;
}
}
}
}
return
NS_OK
;
}
)
)
)
;
}
)
)
;
return
p
.
forget
(
)
;
}
void
GetUserMediaCallbackMediaStreamListener
:
:
StopTrack
(
TrackID
aTrackID
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aTrackID
=
=
kAudioTrack
|
|
aTrackID
=
=
kVideoTrack
)
;
bool
stopAudio
=
aTrackID
=
=
kAudioTrack
;
bool
stopVideo
=
aTrackID
=
=
kVideoTrack
;
if
(
mStopped
|
|
(
stopAudio
&
&
(
mAudioStopped
|
|
!
mAudioDevice
)
)
|
|
(
stopVideo
&
&
(
mVideoStopped
|
|
!
mVideoDevice
)
)
)
{
LOG
(
(
"
Can
'
t
stop
gUM
track
%
d
(
%
s
)
exists
=
%
d
stopped
=
%
d
"
aTrackID
aTrackID
=
=
kAudioTrack
?
"
audio
"
:
"
video
"
aTrackID
=
=
kAudioTrack
?
!
!
mAudioDevice
:
!
!
mVideoDevice
aTrackID
=
=
kAudioTrack
?
mAudioStopped
:
mVideoStopped
)
)
;
return
;
}
if
(
(
stopAudio
|
|
mAudioStopped
|
|
!
mAudioDevice
)
&
&
(
stopVideo
|
|
mVideoStopped
|
|
!
mVideoDevice
)
)
{
Stop
(
)
;
return
;
}
MediaManager
:
:
PostTask
(
FROM_HERE
new
MediaOperationTask
(
MEDIA_STOP_TRACK
this
nullptr
nullptr
stopAudio
?
mAudioDevice
.
get
(
)
:
nullptr
stopVideo
?
mVideoDevice
.
get
(
)
:
nullptr
false
mWindowID
nullptr
)
)
;
mAudioStopped
|
=
stopAudio
;
mVideoStopped
|
=
stopVideo
;
}
void
GetUserMediaCallbackMediaStreamListener
:
:
NotifyFinished
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mFinished
=
true
;
Stop
(
)
;
RefPtr
<
MediaManager
>
manager
(
MediaManager
:
:
GetIfExists
(
)
)
;
if
(
manager
)
{
manager
-
>
RemoveFromWindowList
(
mWindowID
this
)
;
}
else
{
NS_WARNING
(
"
Late
NotifyFinished
after
MediaManager
shutdown
"
)
;
}
}
void
GetUserMediaCallbackMediaStreamListener
:
:
NotifyDirectListeners
(
MediaStreamGraph
*
aGraph
bool
aHasListeners
)
{
MediaManager
:
:
PostTask
(
FROM_HERE
new
MediaOperationTask
(
MEDIA_DIRECT_LISTENERS
this
nullptr
nullptr
mAudioDevice
mVideoDevice
aHasListeners
mWindowID
nullptr
)
)
;
}
void
GetUserMediaCallbackMediaStreamListener
:
:
NotifyRemoved
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MM_LOG
(
(
"
Listener
removed
by
DOM
Destroy
(
)
mFinished
=
%
d
"
(
int
)
mFinished
)
)
;
mRemoved
=
true
;
if
(
!
mFinished
)
{
NotifyFinished
(
)
;
}
}
NS_IMETHODIMP
GetUserMediaNotificationEvent
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
DOMMediaStream
>
stream
=
mStream
.
forget
(
)
;
nsString
msg
;
switch
(
mStatus
)
{
case
STARTING
:
msg
=
NS_LITERAL_STRING
(
"
starting
"
)
;
stream
-
>
OnTracksAvailable
(
mOnTracksAvailableCallback
.
forget
(
)
)
;
break
;
case
STOPPING
:
case
STOPPED_TRACK
:
msg
=
NS_LITERAL_STRING
(
"
shutdown
"
)
;
break
;
}
RefPtr
<
nsGlobalWindow
>
window
=
nsGlobalWindow
:
:
GetInnerWindowWithId
(
mWindowID
)
;
NS_ENSURE_TRUE
(
window
NS_ERROR_FAILURE
)
;
return
MediaManager
:
:
NotifyRecordingStatusChange
(
window
-
>
AsInner
(
)
msg
mIsAudio
mIsVideo
)
;
}
}
