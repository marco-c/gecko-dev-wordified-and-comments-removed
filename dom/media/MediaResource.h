#
if
!
defined
(
MediaResource_h_
)
#
define
MediaResource_h_
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIThreadRetargetableStreamListener
.
h
"
#
include
"
Intervals
.
h
"
#
include
"
MediaCache
.
h
"
#
include
"
MediaContainerType
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
MediaPrefs
.
h
"
#
include
"
MediaResourceCallback
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
<
algorithm
>
static
const
int64_t
SEEK_VS_READ_THRESHOLD
=
1
*
1024
*
1024
;
class
nsIHttpChannel
;
class
nsIPrincipal
;
namespace
mozilla
{
typedef
media
:
:
Interval
<
int64_t
>
MediaByteRange
;
typedef
media
:
:
IntervalSet
<
int64_t
>
MediaByteRangeSet
;
class
MediaResource
{
public
:
NS_METHOD_
(
MozExternalRefCountType
)
AddRef
(
void
)
;
NS_METHOD_
(
MozExternalRefCountType
)
Release
(
void
)
;
virtual
nsresult
ReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
=
0
;
virtual
bool
ShouldCacheReads
(
)
=
0
;
virtual
int64_t
Tell
(
)
=
0
;
virtual
void
Pin
(
)
=
0
;
virtual
void
Unpin
(
)
=
0
;
virtual
int64_t
GetLength
(
)
=
0
;
virtual
int64_t
GetNextCachedData
(
int64_t
aOffset
)
=
0
;
virtual
int64_t
GetCachedDataEnd
(
int64_t
aOffset
)
=
0
;
virtual
bool
IsDataCachedToEndOfResource
(
int64_t
aOffset
)
=
0
;
virtual
nsresult
ReadFromCache
(
char
*
aBuffer
int64_t
aOffset
uint32_t
aCount
)
=
0
;
virtual
nsresult
GetCachedRanges
(
MediaByteRangeSet
&
aRanges
)
=
0
;
protected
:
virtual
~
MediaResource
(
)
{
}
;
private
:
void
Destroy
(
)
;
mozilla
:
:
ThreadSafeAutoRefCnt
mRefCnt
;
NS_DECL_OWNINGTHREAD
}
;
class
BaseMediaResource
:
public
MediaResource
{
public
:
static
already_AddRefed
<
BaseMediaResource
>
Create
(
MediaResourceCallback
*
aCallback
nsIChannel
*
aChannel
bool
aIsPrivateBrowsing
)
;
virtual
nsresult
Close
(
)
=
0
;
virtual
void
ThrottleReadahead
(
bool
bThrottle
)
{
}
virtual
void
SetPlaybackRate
(
uint32_t
aBytesPerSecond
)
=
0
;
virtual
double
GetDownloadRate
(
bool
*
aIsReliable
)
=
0
;
void
SetLoadInBackground
(
bool
aLoadInBackground
)
;
virtual
void
Suspend
(
bool
aCloseImmediately
)
=
0
;
virtual
void
Resume
(
)
=
0
;
virtual
void
SetReadMode
(
MediaCacheStream
:
:
ReadMode
aMode
)
=
0
;
virtual
bool
IsTransportSeekable
(
)
=
0
;
virtual
already_AddRefed
<
nsIPrincipal
>
GetCurrentPrincipal
(
)
=
0
;
virtual
nsresult
Open
(
nsIStreamListener
*
*
aStreamListener
)
=
0
;
virtual
bool
CanClone
(
)
{
return
false
;
}
virtual
already_AddRefed
<
BaseMediaResource
>
CloneData
(
MediaResourceCallback
*
aCallback
)
{
return
nullptr
;
}
bool
IsLiveStream
(
)
{
return
GetLength
(
)
=
=
-
1
;
}
virtual
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
virtual
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
protected
:
BaseMediaResource
(
MediaResourceCallback
*
aCallback
nsIChannel
*
aChannel
nsIURI
*
aURI
)
:
mCallback
(
aCallback
)
mChannel
(
aChannel
)
mURI
(
aURI
)
mLoadInBackground
(
false
)
{
}
virtual
~
BaseMediaResource
(
)
{
}
void
ModifyLoadFlags
(
nsLoadFlags
aFlags
)
;
void
DispatchBytesConsumed
(
int64_t
aNumBytes
int64_t
aOffset
)
;
RefPtr
<
MediaResourceCallback
>
mCallback
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsCOMPtr
<
nsIURI
>
mURI
;
bool
mLoadInBackground
;
}
;
template
<
class
T
>
class
MOZ_RAII
AutoPinned
{
public
:
explicit
AutoPinned
(
T
*
aResource
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mResource
(
aResource
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
MOZ_ASSERT
(
mResource
)
;
mResource
-
>
Pin
(
)
;
}
~
AutoPinned
(
)
{
mResource
-
>
Unpin
(
)
;
}
operator
T
*
(
)
const
{
return
mResource
;
}
T
*
operator
-
>
(
)
const
MOZ_NO_ADDREF_RELEASE_ON_RETURN
{
return
mResource
;
}
private
:
T
*
mResource
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MediaResourceIndex
{
public
:
explicit
MediaResourceIndex
(
MediaResource
*
aResource
)
:
mResource
(
aResource
)
mOffset
(
0
)
mCacheBlockSize
(
aResource
-
>
ShouldCacheReads
(
)
?
SelectCacheSize
(
MediaPrefs
:
:
MediaResourceIndexCache
(
)
)
:
0
)
mCachedOffset
(
0
)
mCachedBytes
(
0
)
mCachedBlock
(
MakeUnique
<
char
[
]
>
(
mCacheBlockSize
)
)
{
}
nsresult
Read
(
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
;
nsresult
Seek
(
int32_t
aWhence
int64_t
aOffset
)
;
int64_t
Tell
(
)
const
{
return
mOffset
;
}
MediaResource
*
GetResource
(
)
const
{
return
mResource
;
}
nsresult
ReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
;
nsresult
UncachedReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
const
;
nsresult
UncachedRangedReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aRequestedCount
uint32_t
aExtraCount
uint32_t
*
aBytes
)
const
;
already_AddRefed
<
MediaByteBuffer
>
MediaReadAt
(
int64_t
aOffset
uint32_t
aCount
)
const
{
RefPtr
<
MediaByteBuffer
>
bytes
=
new
MediaByteBuffer
(
)
;
if
(
aOffset
<
0
)
{
return
bytes
.
forget
(
)
;
}
bool
ok
=
bytes
-
>
SetLength
(
aCount
fallible
)
;
NS_ENSURE_TRUE
(
ok
nullptr
)
;
char
*
curr
=
reinterpret_cast
<
char
*
>
(
bytes
-
>
Elements
(
)
)
;
const
char
*
start
=
curr
;
while
(
aCount
>
0
)
{
uint32_t
bytesRead
;
nsresult
rv
=
mResource
-
>
ReadAt
(
aOffset
curr
aCount
&
bytesRead
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
if
(
!
bytesRead
)
{
break
;
}
aOffset
+
=
bytesRead
;
if
(
aOffset
<
0
)
{
break
;
}
aCount
-
=
bytesRead
;
curr
+
=
bytesRead
;
}
bytes
-
>
SetLength
(
curr
-
start
)
;
return
bytes
.
forget
(
)
;
}
already_AddRefed
<
MediaByteBuffer
>
CachedMediaReadAt
(
int64_t
aOffset
uint32_t
aCount
)
const
{
RefPtr
<
MediaByteBuffer
>
bytes
=
new
MediaByteBuffer
(
)
;
bool
ok
=
bytes
-
>
SetLength
(
aCount
fallible
)
;
NS_ENSURE_TRUE
(
ok
nullptr
)
;
char
*
curr
=
reinterpret_cast
<
char
*
>
(
bytes
-
>
Elements
(
)
)
;
nsresult
rv
=
mResource
-
>
ReadFromCache
(
curr
aOffset
aCount
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
bytes
.
forget
(
)
;
}
int64_t
GetLength
(
)
const
{
return
mResource
-
>
GetLength
(
)
;
}
private
:
nsresult
CacheOrReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
;
static
uint32_t
SelectCacheSize
(
uint32_t
aHint
)
{
if
(
aHint
=
=
0
)
{
return
0
;
}
if
(
aHint
<
=
32
)
{
return
32
;
}
if
(
aHint
>
64
*
1024
)
{
return
128
*
1024
;
}
aHint
-
-
;
aHint
|
=
aHint
>
>
1
;
aHint
|
=
aHint
>
>
2
;
aHint
|
=
aHint
>
>
4
;
aHint
|
=
aHint
>
>
8
;
aHint
|
=
aHint
>
>
16
;
aHint
+
+
;
return
aHint
;
}
uint32_t
IndexInCache
(
int64_t
aOffsetInFile
)
const
{
const
uint32_t
index
=
uint32_t
(
aOffsetInFile
)
&
(
mCacheBlockSize
-
1
)
;
MOZ_ASSERT
(
index
=
=
aOffsetInFile
%
mCacheBlockSize
)
;
return
index
;
}
int64_t
CacheOffsetContaining
(
int64_t
aOffsetInFile
)
const
{
const
int64_t
offset
=
aOffsetInFile
&
~
(
int64_t
(
mCacheBlockSize
)
-
1
)
;
MOZ_ASSERT
(
offset
=
=
aOffsetInFile
-
IndexInCache
(
aOffsetInFile
)
)
;
return
offset
;
}
RefPtr
<
MediaResource
>
mResource
;
int64_t
mOffset
;
const
uint32_t
mCacheBlockSize
;
int64_t
mCachedOffset
;
uint32_t
mCachedBytes
;
UniquePtr
<
char
[
]
>
mCachedBlock
;
}
;
}
#
endif
