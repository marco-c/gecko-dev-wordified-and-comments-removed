#
if
!
defined
(
MediaResource_h_
)
#
define
MediaResource_h_
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
Intervals
.
h
"
#
include
"
MediaCache
.
h
"
#
include
"
MediaContainerType
.
h
"
#
include
"
MediaData
.
h
"
#
include
"
MediaPrefs
.
h
"
#
include
"
MediaResourceCallback
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
<
algorithm
>
static
const
int64_t
SEEK_VS_READ_THRESHOLD
=
1
*
1024
*
1024
;
static
const
uint32_t
HTTP_REQUESTED_RANGE_NOT_SATISFIABLE_CODE
=
416
;
static
const
int64_t
RELIABLE_DATA_THRESHOLD
=
57
*
1460
;
class
nsIHttpChannel
;
class
nsIPrincipal
;
namespace
mozilla
{
class
MediaChannelStatistics
;
class
MediaChannelStatistics
{
public
:
MediaChannelStatistics
(
)
=
default
;
MediaChannelStatistics
(
const
MediaChannelStatistics
&
)
=
default
;
void
Reset
(
)
{
mLastStartTime
=
TimeStamp
(
)
;
mAccumulatedTime
=
TimeDuration
(
0
)
;
mAccumulatedBytes
=
0
;
mIsStarted
=
false
;
}
void
Start
(
)
{
if
(
mIsStarted
)
return
;
mLastStartTime
=
TimeStamp
:
:
Now
(
)
;
mIsStarted
=
true
;
}
void
Stop
(
)
{
if
(
!
mIsStarted
)
return
;
mAccumulatedTime
+
=
TimeStamp
:
:
Now
(
)
-
mLastStartTime
;
mIsStarted
=
false
;
}
void
AddBytes
(
int64_t
aBytes
)
{
if
(
!
mIsStarted
)
{
return
;
}
mAccumulatedBytes
+
=
aBytes
;
}
double
GetRateAtLastStop
(
bool
*
aReliable
)
{
double
seconds
=
mAccumulatedTime
.
ToSeconds
(
)
;
*
aReliable
=
(
seconds
>
=
1
.
0
)
|
|
(
mAccumulatedBytes
>
=
RELIABLE_DATA_THRESHOLD
)
;
if
(
seconds
<
=
0
.
0
)
return
0
.
0
;
return
static_cast
<
double
>
(
mAccumulatedBytes
)
/
seconds
;
}
double
GetRate
(
bool
*
aReliable
)
{
TimeDuration
time
=
mAccumulatedTime
;
if
(
mIsStarted
)
{
time
+
=
TimeStamp
:
:
Now
(
)
-
mLastStartTime
;
}
double
seconds
=
time
.
ToSeconds
(
)
;
*
aReliable
=
(
seconds
>
=
3
.
0
)
|
|
(
mAccumulatedBytes
>
=
RELIABLE_DATA_THRESHOLD
)
;
if
(
seconds
<
=
0
.
0
)
return
0
.
0
;
return
static_cast
<
double
>
(
mAccumulatedBytes
)
/
seconds
;
}
private
:
int64_t
mAccumulatedBytes
=
0
;
TimeDuration
mAccumulatedTime
;
TimeStamp
mLastStartTime
;
bool
mIsStarted
=
false
;
}
;
typedef
media
:
:
Interval
<
int64_t
>
MediaByteRange
;
typedef
media
:
:
IntervalSet
<
int64_t
>
MediaByteRangeSet
;
class
MediaResource
{
public
:
NS_METHOD_
(
MozExternalRefCountType
)
AddRef
(
void
)
;
NS_METHOD_
(
MozExternalRefCountType
)
Release
(
void
)
;
virtual
nsresult
ReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
=
0
;
virtual
bool
ShouldCacheReads
(
)
=
0
;
virtual
int64_t
Tell
(
)
=
0
;
virtual
void
Pin
(
)
=
0
;
virtual
void
Unpin
(
)
=
0
;
virtual
int64_t
GetLength
(
)
=
0
;
virtual
int64_t
GetNextCachedData
(
int64_t
aOffset
)
=
0
;
virtual
int64_t
GetCachedDataEnd
(
int64_t
aOffset
)
=
0
;
virtual
bool
IsDataCachedToEndOfResource
(
int64_t
aOffset
)
=
0
;
virtual
nsresult
ReadFromCache
(
char
*
aBuffer
int64_t
aOffset
uint32_t
aCount
)
=
0
;
virtual
nsresult
GetCachedRanges
(
MediaByteRangeSet
&
aRanges
)
=
0
;
virtual
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
virtual
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
protected
:
virtual
~
MediaResource
(
)
{
}
;
private
:
void
Destroy
(
)
;
mozilla
:
:
ThreadSafeAutoRefCnt
mRefCnt
;
NS_DECL_OWNINGTHREAD
}
;
class
BaseMediaResource
:
public
MediaResource
{
public
:
static
already_AddRefed
<
BaseMediaResource
>
Create
(
MediaResourceCallback
*
aCallback
nsIChannel
*
aChannel
bool
aIsPrivateBrowsing
)
;
virtual
nsresult
Close
(
)
=
0
;
virtual
void
ThrottleReadahead
(
bool
bThrottle
)
{
}
virtual
void
SetPlaybackRate
(
uint32_t
aBytesPerSecond
)
=
0
;
virtual
double
GetDownloadRate
(
bool
*
aIsReliable
)
=
0
;
void
SetLoadInBackground
(
bool
aLoadInBackground
)
;
virtual
void
Suspend
(
bool
aCloseImmediately
)
=
0
;
virtual
void
Resume
(
)
=
0
;
virtual
void
SetReadMode
(
MediaCacheStream
:
:
ReadMode
aMode
)
=
0
;
virtual
bool
IsTransportSeekable
(
)
=
0
;
virtual
already_AddRefed
<
nsIPrincipal
>
GetCurrentPrincipal
(
)
=
0
;
virtual
nsresult
Open
(
nsIStreamListener
*
*
aStreamListener
)
=
0
;
virtual
bool
CanClone
(
)
{
return
false
;
}
virtual
already_AddRefed
<
BaseMediaResource
>
CloneData
(
MediaResourceCallback
*
aCallback
)
{
return
nullptr
;
}
bool
IsLiveStream
(
)
{
return
GetLength
(
)
=
=
-
1
;
}
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
size_t
size
=
MediaResource
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
return
size
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
protected
:
BaseMediaResource
(
MediaResourceCallback
*
aCallback
nsIChannel
*
aChannel
nsIURI
*
aURI
)
:
mCallback
(
aCallback
)
mChannel
(
aChannel
)
mURI
(
aURI
)
mLoadInBackground
(
false
)
{
}
virtual
~
BaseMediaResource
(
)
{
}
void
ModifyLoadFlags
(
nsLoadFlags
aFlags
)
;
void
DispatchBytesConsumed
(
int64_t
aNumBytes
int64_t
aOffset
)
;
RefPtr
<
MediaResourceCallback
>
mCallback
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsCOMPtr
<
nsIURI
>
mURI
;
bool
mLoadInBackground
;
}
;
class
ChannelSuspendAgent
{
public
:
explicit
ChannelSuspendAgent
(
nsIChannel
*
aChannel
)
:
mChannel
(
aChannel
)
mSuspendCount
(
0
)
mIsChannelSuspended
(
false
)
{
}
bool
IsSuspended
(
)
;
bool
Suspend
(
)
;
bool
Resume
(
)
;
void
NotifyChannelOpened
(
nsIChannel
*
aChannel
)
;
void
NotifyChannelClosing
(
)
;
void
UpdateSuspendedStatusIfNeeded
(
)
;
private
:
void
SuspendInternal
(
)
;
nsIChannel
*
mChannel
;
Atomic
<
uint32_t
>
mSuspendCount
;
bool
mIsChannelSuspended
;
}
;
class
ChannelMediaResource
:
public
BaseMediaResource
{
public
:
ChannelMediaResource
(
MediaResourceCallback
*
aDecoder
nsIChannel
*
aChannel
nsIURI
*
aURI
bool
aIsPrivateBrowsing
)
;
ChannelMediaResource
(
MediaResourceCallback
*
aDecoder
nsIChannel
*
aChannel
nsIURI
*
aURI
const
MediaChannelStatistics
&
aStatistics
)
;
~
ChannelMediaResource
(
)
;
void
CacheClientNotifyDataReceived
(
)
;
void
CacheClientNotifyDataEnded
(
nsresult
aStatus
)
;
void
CacheClientNotifyPrincipalChanged
(
)
;
void
CacheClientNotifySuspendedStatusChanged
(
)
;
nsresult
CacheClientSeek
(
int64_t
aOffset
bool
aResume
)
;
nsresult
CacheClientSuspend
(
)
;
nsresult
CacheClientResume
(
)
;
bool
IsSuspended
(
)
;
void
ThrottleReadahead
(
bool
bThrottle
)
override
;
nsresult
Open
(
nsIStreamListener
*
*
aStreamListener
)
override
;
nsresult
Close
(
)
override
;
void
Suspend
(
bool
aCloseImmediately
)
override
;
void
Resume
(
)
override
;
already_AddRefed
<
nsIPrincipal
>
GetCurrentPrincipal
(
)
override
;
bool
IsClosed
(
)
const
{
return
mCacheStream
.
IsClosed
(
)
;
}
bool
CanClone
(
)
override
;
already_AddRefed
<
BaseMediaResource
>
CloneData
(
MediaResourceCallback
*
aDecoder
)
override
;
nsresult
ReadFromCache
(
char
*
aBuffer
int64_t
aOffset
uint32_t
aCount
)
override
;
void
SetReadMode
(
MediaCacheStream
:
:
ReadMode
aMode
)
override
;
void
SetPlaybackRate
(
uint32_t
aBytesPerSecond
)
override
;
nsresult
ReadAt
(
int64_t
offset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
override
;
bool
ShouldCacheReads
(
)
override
{
return
true
;
}
int64_t
Tell
(
)
override
;
void
Pin
(
)
override
;
void
Unpin
(
)
override
;
double
GetDownloadRate
(
bool
*
aIsReliable
)
override
;
int64_t
GetLength
(
)
override
;
int64_t
GetNextCachedData
(
int64_t
aOffset
)
override
;
int64_t
GetCachedDataEnd
(
int64_t
aOffset
)
override
;
bool
IsDataCachedToEndOfResource
(
int64_t
aOffset
)
override
;
bool
IsTransportSeekable
(
)
override
;
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
size_t
size
=
BaseMediaResource
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
size
+
=
mCacheStream
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
return
size
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
class
Listener
final
:
public
nsIStreamListener
public
nsIInterfaceRequestor
public
nsIChannelEventSink
{
~
Listener
(
)
{
}
public
:
explicit
Listener
(
ChannelMediaResource
*
aResource
)
:
mResource
(
aResource
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIINTERFACEREQUESTOR
void
Revoke
(
)
{
mResource
=
nullptr
;
}
private
:
RefPtr
<
ChannelMediaResource
>
mResource
;
}
;
friend
class
Listener
;
nsresult
GetCachedRanges
(
MediaByteRangeSet
&
aRanges
)
override
;
protected
:
bool
IsSuspendedByCache
(
)
;
nsresult
OnStartRequest
(
nsIRequest
*
aRequest
)
;
nsresult
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
aStatus
)
;
nsresult
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aStream
uint32_t
aCount
)
;
nsresult
OnChannelRedirect
(
nsIChannel
*
aOld
nsIChannel
*
aNew
uint32_t
aFlags
)
;
nsresult
OpenChannel
(
nsIStreamListener
*
*
aStreamListener
)
;
nsresult
RecreateChannel
(
)
;
nsresult
SetupChannelHeaders
(
)
;
void
CloseChannel
(
)
;
nsresult
ParseContentRangeHeader
(
nsIHttpChannel
*
aHttpChan
int64_t
&
aRangeStart
int64_t
&
aRangeEnd
int64_t
&
aRangeTotal
)
;
void
DoNotifyDataReceived
(
)
;
static
nsresult
CopySegmentToCache
(
nsIInputStream
*
aInStream
void
*
aClosure
const
char
*
aFromSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
aWriteCount
)
;
nsresult
CopySegmentToCache
(
nsIPrincipal
*
aPrincipal
const
char
*
aFromSegment
uint32_t
aCount
uint32_t
*
aWriteCount
)
;
int64_t
mOffset
;
RefPtr
<
Listener
>
mListener
;
nsRevocableEventPtr
<
nsRunnableMethod
<
ChannelMediaResource
void
false
>
>
mDataReceivedEvent
;
bool
mReopenOnError
;
bool
mIgnoreClose
;
MediaCacheStream
mCacheStream
;
Mutex
mLock
;
MediaChannelStatistics
mChannelStatistics
;
bool
mIgnoreResume
;
ChannelSuspendAgent
mSuspendAgent
;
}
;
template
<
class
T
>
class
MOZ_RAII
AutoPinned
{
public
:
explicit
AutoPinned
(
T
*
aResource
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mResource
(
aResource
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
MOZ_ASSERT
(
mResource
)
;
mResource
-
>
Pin
(
)
;
}
~
AutoPinned
(
)
{
mResource
-
>
Unpin
(
)
;
}
operator
T
*
(
)
const
{
return
mResource
;
}
T
*
operator
-
>
(
)
const
MOZ_NO_ADDREF_RELEASE_ON_RETURN
{
return
mResource
;
}
private
:
T
*
mResource
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MediaResourceIndex
{
public
:
explicit
MediaResourceIndex
(
MediaResource
*
aResource
)
:
mResource
(
aResource
)
mOffset
(
0
)
mCacheBlockSize
(
aResource
-
>
ShouldCacheReads
(
)
?
SelectCacheSize
(
MediaPrefs
:
:
MediaResourceIndexCache
(
)
)
:
0
)
mCachedOffset
(
0
)
mCachedBytes
(
0
)
mCachedBlock
(
MakeUnique
<
char
[
]
>
(
mCacheBlockSize
)
)
{
}
nsresult
Read
(
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
;
nsresult
Seek
(
int32_t
aWhence
int64_t
aOffset
)
;
int64_t
Tell
(
)
const
{
return
mOffset
;
}
MediaResource
*
GetResource
(
)
const
{
return
mResource
;
}
nsresult
ReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
;
nsresult
UncachedReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
const
;
nsresult
UncachedRangedReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aRequestedCount
uint32_t
aExtraCount
uint32_t
*
aBytes
)
const
;
already_AddRefed
<
MediaByteBuffer
>
MediaReadAt
(
int64_t
aOffset
uint32_t
aCount
)
const
{
RefPtr
<
MediaByteBuffer
>
bytes
=
new
MediaByteBuffer
(
)
;
if
(
aOffset
<
0
)
{
return
bytes
.
forget
(
)
;
}
bool
ok
=
bytes
-
>
SetLength
(
aCount
fallible
)
;
NS_ENSURE_TRUE
(
ok
nullptr
)
;
char
*
curr
=
reinterpret_cast
<
char
*
>
(
bytes
-
>
Elements
(
)
)
;
const
char
*
start
=
curr
;
while
(
aCount
>
0
)
{
uint32_t
bytesRead
;
nsresult
rv
=
mResource
-
>
ReadAt
(
aOffset
curr
aCount
&
bytesRead
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
if
(
!
bytesRead
)
{
break
;
}
aOffset
+
=
bytesRead
;
if
(
aOffset
<
0
)
{
break
;
}
aCount
-
=
bytesRead
;
curr
+
=
bytesRead
;
}
bytes
-
>
SetLength
(
curr
-
start
)
;
return
bytes
.
forget
(
)
;
}
already_AddRefed
<
MediaByteBuffer
>
CachedMediaReadAt
(
int64_t
aOffset
uint32_t
aCount
)
const
{
RefPtr
<
MediaByteBuffer
>
bytes
=
new
MediaByteBuffer
(
)
;
bool
ok
=
bytes
-
>
SetLength
(
aCount
fallible
)
;
NS_ENSURE_TRUE
(
ok
nullptr
)
;
char
*
curr
=
reinterpret_cast
<
char
*
>
(
bytes
-
>
Elements
(
)
)
;
nsresult
rv
=
mResource
-
>
ReadFromCache
(
curr
aOffset
aCount
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
bytes
.
forget
(
)
;
}
int64_t
GetLength
(
)
const
{
return
mResource
-
>
GetLength
(
)
;
}
private
:
nsresult
CacheOrReadAt
(
int64_t
aOffset
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aBytes
)
;
static
uint32_t
SelectCacheSize
(
uint32_t
aHint
)
{
if
(
aHint
=
=
0
)
{
return
0
;
}
if
(
aHint
<
=
32
)
{
return
32
;
}
if
(
aHint
>
64
*
1024
)
{
return
128
*
1024
;
}
aHint
-
-
;
aHint
|
=
aHint
>
>
1
;
aHint
|
=
aHint
>
>
2
;
aHint
|
=
aHint
>
>
4
;
aHint
|
=
aHint
>
>
8
;
aHint
|
=
aHint
>
>
16
;
aHint
+
+
;
return
aHint
;
}
uint32_t
IndexInCache
(
int64_t
aOffsetInFile
)
const
{
const
uint32_t
index
=
uint32_t
(
aOffsetInFile
)
&
(
mCacheBlockSize
-
1
)
;
MOZ_ASSERT
(
index
=
=
aOffsetInFile
%
mCacheBlockSize
)
;
return
index
;
}
int64_t
CacheOffsetContaining
(
int64_t
aOffsetInFile
)
const
{
const
int64_t
offset
=
aOffsetInFile
&
~
(
int64_t
(
mCacheBlockSize
)
-
1
)
;
MOZ_ASSERT
(
offset
=
=
aOffsetInFile
-
IndexInCache
(
aOffsetInFile
)
)
;
return
offset
;
}
RefPtr
<
MediaResource
>
mResource
;
int64_t
mOffset
;
const
uint32_t
mCacheBlockSize
;
int64_t
mCachedOffset
;
uint32_t
mCachedBytes
;
UniquePtr
<
char
[
]
>
mCachedBlock
;
}
;
}
#
endif
