#
ifndef
SEEK_TASK_H
#
define
SEEK_TASK_H
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
MediaCallbackID
.
h
"
#
include
"
SeekJob
.
h
"
namespace
mozilla
{
class
AbstractThread
;
class
MediaData
;
class
MediaDecoderReaderWrapper
;
class
MediaInfo
;
namespace
media
{
class
TimeUnit
;
}
struct
SeekTaskResolveValue
{
RefPtr
<
MediaData
>
mSeekedAudioData
;
RefPtr
<
MediaData
>
mSeekedVideoData
;
bool
mIsAudioQueueFinished
;
bool
mIsVideoQueueFinished
;
bool
mNeedToStopPrerollingAudio
;
bool
mNeedToStopPrerollingVideo
;
}
;
struct
SeekTaskRejectValue
{
bool
mIsAudioQueueFinished
;
bool
mIsVideoQueueFinished
;
bool
mNeedToStopPrerollingAudio
;
bool
mNeedToStopPrerollingVideo
;
}
;
class
SeekTask
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SeekTask
)
public
:
static
const
bool
IsExclusive
=
true
;
using
SeekTaskPromise
=
MozPromise
<
SeekTaskResolveValue
SeekTaskRejectValue
IsExclusive
>
;
virtual
void
Discard
(
)
=
0
;
virtual
RefPtr
<
SeekTaskPromise
>
Seek
(
const
media
:
:
TimeUnit
&
aDuration
)
=
0
;
virtual
bool
NeedToResetMDSM
(
)
const
=
0
;
SeekTarget
&
GetSeekTarget
(
)
;
protected
:
SeekTask
(
const
void
*
aDecoderID
AbstractThread
*
aThread
MediaDecoderReaderWrapper
*
aReader
SeekJob
&
aSeekJob
)
;
virtual
~
SeekTask
(
)
;
void
Resolve
(
const
char
*
aCallSite
)
;
void
RejectIfExist
(
const
char
*
aCallSite
)
;
void
AssertOwnerThread
(
)
const
;
AbstractThread
*
OwnerThread
(
)
const
;
const
void
*
mDecoderID
;
const
RefPtr
<
AbstractThread
>
mOwnerThread
;
const
RefPtr
<
MediaDecoderReaderWrapper
>
mReader
;
SeekTarget
&
mTarget
;
MozPromiseHolder
<
SeekTaskPromise
>
mSeekTaskPromise
;
bool
mIsDiscarded
;
RefPtr
<
MediaData
>
mSeekedAudioData
;
RefPtr
<
MediaData
>
mSeekedVideoData
;
bool
mIsAudioQueueFinished
;
bool
mIsVideoQueueFinished
;
bool
mNeedToStopPrerollingAudio
;
bool
mNeedToStopPrerollingVideo
;
}
;
}
#
endif
