#
ifndef
SEEK_TASK_H
#
define
SEEK_TASK_H
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
MediaCallbackID
.
h
"
#
include
"
MediaDecoderReader
.
h
"
#
include
"
SeekJob
.
h
"
namespace
mozilla
{
class
AbstractThread
;
class
MediaData
;
class
MediaDecoderReaderWrapper
;
struct
SeekTaskResolveValue
{
RefPtr
<
MediaData
>
mSeekedAudioData
;
RefPtr
<
MediaData
>
mSeekedVideoData
;
bool
mIsAudioQueueFinished
;
bool
mIsVideoQueueFinished
;
bool
mNeedToStopPrerollingAudio
;
bool
mNeedToStopPrerollingVideo
;
}
;
struct
SeekTaskRejectValue
{
bool
mIsAudioQueueFinished
;
bool
mIsVideoQueueFinished
;
bool
mNeedToStopPrerollingAudio
;
bool
mNeedToStopPrerollingVideo
;
}
;
class
SeekTask
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SeekTask
)
public
:
static
const
bool
IsExclusive
=
true
;
using
SeekTaskPromise
=
MozPromise
<
SeekTaskResolveValue
SeekTaskRejectValue
IsExclusive
>
;
static
already_AddRefed
<
SeekTask
>
CreateSeekTask
(
const
void
*
aDecoderID
AbstractThread
*
aThread
MediaDecoderReaderWrapper
*
aReader
SeekJob
&
&
aSeekJob
const
MediaInfo
&
aInfo
const
media
:
:
TimeUnit
&
aDuration
int64_t
aCurrentMediaTime
)
;
virtual
void
Discard
(
)
;
virtual
RefPtr
<
SeekTaskPromise
>
Seek
(
const
media
:
:
TimeUnit
&
aDuration
)
;
virtual
bool
NeedToResetMDSM
(
)
const
;
SeekJob
&
GetSeekJob
(
)
;
bool
Exists
(
)
const
;
protected
:
SeekTask
(
const
void
*
aDecoderID
AbstractThread
*
aThread
MediaDecoderReaderWrapper
*
aReader
SeekJob
&
&
aSeekJob
const
MediaInfo
&
aInfo
const
media
:
:
TimeUnit
&
aDuration
int64_t
aCurrentMediaTime
)
;
virtual
~
SeekTask
(
)
;
void
Resolve
(
const
char
*
aCallSite
)
;
void
RejectIfExist
(
const
char
*
aCallSite
)
;
void
AssertOwnerThread
(
)
const
;
bool
HasAudio
(
)
const
;
bool
HasVideo
(
)
const
;
TaskQueue
*
DecodeTaskQueue
(
)
const
;
AbstractThread
*
OwnerThread
(
)
const
;
bool
IsVideoDecoding
(
)
const
;
bool
IsAudioDecoding
(
)
const
;
nsresult
EnsureVideoDecodeTaskQueued
(
)
;
nsresult
EnsureAudioDecodeTaskQueued
(
)
;
const
char
*
AudioRequestStatus
(
)
;
const
char
*
VideoRequestStatus
(
)
;
void
RequestVideoData
(
)
;
void
RequestAudioData
(
)
;
nsresult
DropAudioUpToSeekTarget
(
MediaData
*
aSample
)
;
nsresult
DropVideoUpToSeekTarget
(
MediaData
*
aSample
)
;
bool
IsAudioSeekComplete
(
)
;
bool
IsVideoSeekComplete
(
)
;
void
CheckIfSeekComplete
(
)
;
virtual
void
OnSeekResolved
(
media
:
:
TimeUnit
)
;
virtual
void
OnSeekRejected
(
nsresult
aResult
)
;
virtual
void
OnAudioDecoded
(
MediaData
*
aAudioSample
)
;
virtual
void
OnAudioNotDecoded
(
MediaDecoderReader
:
:
NotDecodedReason
aReason
)
;
virtual
void
OnVideoDecoded
(
MediaData
*
aVideoSample
)
;
virtual
void
OnVideoNotDecoded
(
MediaDecoderReader
:
:
NotDecodedReason
aReason
)
;
void
SetMediaDecoderReaderWrapperCallback
(
)
;
void
CancelMediaDecoderReaderWrapperCallback
(
)
;
const
void
*
mDecoderID
;
const
RefPtr
<
AbstractThread
>
mOwnerThread
;
const
RefPtr
<
MediaDecoderReaderWrapper
>
mReader
;
SeekJob
mSeekJob
;
MozPromiseHolder
<
SeekTaskPromise
>
mSeekTaskPromise
;
int64_t
mCurrentTimeBeforeSeek
;
const
uint32_t
mAudioRate
;
const
bool
mHasAudio
;
const
bool
mHasVideo
;
bool
mDropAudioUntilNextDiscontinuity
;
bool
mDropVideoUntilNextDiscontinuity
;
bool
mIsDiscarded
;
RefPtr
<
MediaData
>
mFirstVideoFrameAfterSeek
;
MozPromiseRequestHolder
<
MediaDecoderReader
:
:
SeekPromise
>
mSeekRequest
;
CallbackID
mAudioCallbackID
;
CallbackID
mVideoCallbackID
;
CallbackID
mWaitAudioCallbackID
;
CallbackID
mWaitVideoCallbackID
;
RefPtr
<
MediaData
>
mSeekedAudioData
;
RefPtr
<
MediaData
>
mSeekedVideoData
;
bool
mIsAudioQueueFinished
;
bool
mIsVideoQueueFinished
;
bool
mNeedToStopPrerollingAudio
;
bool
mNeedToStopPrerollingVideo
;
}
;
}
#
endif
