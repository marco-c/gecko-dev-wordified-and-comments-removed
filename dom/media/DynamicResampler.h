#
ifndef
MOZILLA_DYNAMIC_RESAMPLER_H_
#
define
MOZILLA_DYNAMIC_RESAMPLER_H_
#
include
"
AudioRingBuffer
.
h
"
#
include
"
AudioSegment
.
h
"
#
include
<
speex
/
speex_resampler
.
h
>
namespace
mozilla
{
const
uint32_t
STEREO
=
2
;
class
DynamicResampler
final
{
public
:
DynamicResampler
(
uint32_t
aInRate
uint32_t
aOutRate
uint32_t
aPreBufferFrames
=
0
)
;
~
DynamicResampler
(
)
;
void
SetSampleFormat
(
AudioSampleFormat
aFormat
)
;
uint32_t
GetOutRate
(
)
const
{
return
mOutRate
;
}
uint32_t
GetChannels
(
)
const
{
return
mChannels
;
}
void
AppendInput
(
const
nsTArray
<
const
float
*
>
&
aInBuffer
uint32_t
aInFrames
)
;
void
AppendInput
(
const
nsTArray
<
const
int16_t
*
>
&
aInBuffer
uint32_t
aInFrames
)
;
void
AppendInputSilence
(
const
uint32_t
aInFrames
)
;
uint32_t
InFramesBuffered
(
uint32_t
aChannelIndex
)
const
;
uint32_t
InFramesLeftToBuffer
(
uint32_t
aChannelIndex
)
const
;
bool
Resample
(
float
*
aOutBuffer
uint32_t
*
aOutFrames
uint32_t
aChannelIndex
)
;
bool
Resample
(
int16_t
*
aOutBuffer
uint32_t
*
aOutFrames
uint32_t
aChannelIndex
)
;
void
UpdateResampler
(
uint32_t
aOutRate
uint32_t
aChannels
)
;
bool
CanResample
(
uint32_t
aOutFrames
)
const
;
private
:
template
<
typename
T
>
void
AppendInputInternal
(
const
nsTArray
<
const
T
*
>
&
aInBuffer
uint32_t
aInFrames
)
{
MOZ_ASSERT
(
aInBuffer
.
Length
(
)
=
=
(
uint32_t
)
mChannels
)
;
for
(
uint32_t
i
=
0
;
i
<
mChannels
;
+
+
i
)
{
PushInFrames
(
aInBuffer
[
i
]
aInFrames
i
)
;
}
}
void
ResampleInternal
(
const
float
*
aInBuffer
uint32_t
*
aInFrames
float
*
aOutBuffer
uint32_t
*
aOutFrames
uint32_t
aChannelIndex
)
;
void
ResampleInternal
(
const
int16_t
*
aInBuffer
uint32_t
*
aInFrames
int16_t
*
aOutBuffer
uint32_t
*
aOutFrames
uint32_t
aChannelIndex
)
;
template
<
typename
T
>
bool
ResampleInternal
(
T
*
aOutBuffer
uint32_t
*
aOutFrames
uint32_t
aChannelIndex
)
{
MOZ_ASSERT
(
mInRate
)
;
MOZ_ASSERT
(
mOutRate
)
;
MOZ_ASSERT
(
mChannels
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mChannels
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mInternalInBuffer
.
Length
(
)
)
;
MOZ_ASSERT
(
aOutFrames
)
;
MOZ_ASSERT
(
*
aOutFrames
)
;
if
(
!
EnoughInFrames
(
*
aOutFrames
aChannelIndex
)
)
{
*
aOutFrames
=
0
;
return
false
;
}
if
(
mInRate
=
=
mOutRate
)
{
mInternalInBuffer
[
aChannelIndex
]
.
Read
(
Span
(
aOutBuffer
*
aOutFrames
)
)
;
mInputTail
[
aChannelIndex
]
.
StoreTail
<
T
>
(
aOutBuffer
*
aOutFrames
)
;
return
true
;
}
uint32_t
totalOutFramesNeeded
=
*
aOutFrames
;
mInternalInBuffer
[
aChannelIndex
]
.
ReadNoCopy
(
[
this
&
aOutBuffer
&
totalOutFramesNeeded
aChannelIndex
]
(
const
Span
<
const
T
>
&
aInBuffer
)
-
>
uint32_t
{
if
(
!
totalOutFramesNeeded
)
{
return
0
;
}
uint32_t
outFramesResampled
=
totalOutFramesNeeded
;
uint32_t
inFrames
=
aInBuffer
.
Length
(
)
;
ResampleInternal
(
aInBuffer
.
data
(
)
&
inFrames
aOutBuffer
&
outFramesResampled
aChannelIndex
)
;
aOutBuffer
+
=
outFramesResampled
;
totalOutFramesNeeded
-
=
outFramesResampled
;
mInputTail
[
aChannelIndex
]
.
StoreTail
<
T
>
(
aInBuffer
)
;
return
inFrames
;
}
)
;
MOZ_ASSERT
(
totalOutFramesNeeded
=
=
0
)
;
return
true
;
}
bool
EnoughInFrames
(
uint32_t
aOutFrames
uint32_t
aChannelIndex
)
const
;
template
<
typename
T
>
void
PushInFrames
(
const
T
*
aInBuffer
const
uint32_t
aInFrames
uint32_t
aChannelIndex
)
{
MOZ_ASSERT
(
aInBuffer
)
;
MOZ_ASSERT
(
aInFrames
)
;
MOZ_ASSERT
(
mChannels
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mChannels
)
;
MOZ_ASSERT
(
aChannelIndex
<
=
mInternalInBuffer
.
Length
(
)
)
;
mInternalInBuffer
[
aChannelIndex
]
.
Write
(
Span
(
aInBuffer
aInFrames
)
)
;
}
void
WarmUpResampler
(
bool
aSkipLatency
)
;
public
:
const
uint32_t
mInRate
;
const
uint32_t
mPreBufferFrames
;
private
:
uint32_t
mChannels
=
0
;
uint32_t
mOutRate
;
AutoTArray
<
AudioRingBuffer
STEREO
>
mInternalInBuffer
;
SpeexResamplerState
*
mResampler
=
nullptr
;
AudioSampleFormat
mSampleFormat
=
AUDIO_FORMAT_SILENCE
;
class
TailBuffer
{
public
:
template
<
typename
T
>
T
*
Buffer
(
)
{
return
reinterpret_cast
<
T
*
>
(
mBuffer
)
;
}
template
<
typename
T
>
void
StoreTail
(
const
Span
<
const
T
>
&
aInBuffer
)
{
StoreTail
(
aInBuffer
.
data
(
)
aInBuffer
.
size
(
)
)
;
}
template
<
typename
T
>
void
StoreTail
(
const
T
*
aInBuffer
uint32_t
aInFrames
)
{
if
(
aInFrames
>
=
MAXSIZE
)
{
PodCopy
(
Buffer
<
T
>
(
)
aInBuffer
+
aInFrames
-
MAXSIZE
MAXSIZE
)
;
mSize
=
MAXSIZE
;
}
else
{
PodCopy
(
Buffer
<
T
>
(
)
aInBuffer
aInFrames
)
;
mSize
=
aInFrames
;
}
}
uint32_t
Length
(
)
{
return
mSize
;
}
static
const
uint32_t
MAXSIZE
=
20
;
private
:
float
mBuffer
[
MAXSIZE
]
=
{
}
;
uint32_t
mSize
=
0
;
}
;
AutoTArray
<
TailBuffer
STEREO
>
mInputTail
;
}
;
class
AudioChunkList
{
public
:
AudioChunkList
(
uint32_t
aTotalDuration
uint32_t
aChannels
const
PrincipalHandle
&
aPrincipalHandle
)
;
AudioChunkList
(
const
AudioChunkList
&
)
=
delete
;
AudioChunkList
(
AudioChunkList
&
&
)
=
delete
;
~
AudioChunkList
(
)
=
default
;
void
SetSampleFormat
(
AudioSampleFormat
aFormat
)
;
AudioChunk
&
GetNext
(
)
;
uint32_t
ChunkCapacity
(
)
const
{
MOZ_ASSERT
(
mSampleFormat
=
=
AUDIO_FORMAT_S16
|
|
mSampleFormat
=
=
AUDIO_FORMAT_FLOAT32
)
;
return
mChunkCapacity
;
}
uint32_t
TotalCapacity
(
)
const
{
MOZ_ASSERT
(
mSampleFormat
=
=
AUDIO_FORMAT_S16
|
|
mSampleFormat
=
=
AUDIO_FORMAT_FLOAT32
)
;
return
CheckedInt
<
uint32_t
>
(
mChunkCapacity
*
mChunks
.
Length
(
)
)
.
value
(
)
;
}
void
Update
(
uint32_t
aChannels
)
;
private
:
void
IncrementIndex
(
)
{
+
+
mIndex
;
mIndex
=
CheckedInt
<
uint32_t
>
(
mIndex
%
mChunks
.
Length
(
)
)
.
value
(
)
;
}
void
CreateChunks
(
uint32_t
aNumOfChunks
uint32_t
aChannels
)
;
void
UpdateToMonoOrStereo
(
uint32_t
aChannels
)
;
private
:
const
PrincipalHandle
mPrincipalHandle
;
nsTArray
<
AudioChunk
>
mChunks
;
uint32_t
mIndex
=
0
;
uint32_t
mChunkCapacity
=
WEBAUDIO_BLOCK_SIZE
;
AudioSampleFormat
mSampleFormat
=
AUDIO_FORMAT_SILENCE
;
}
;
class
AudioResampler
final
{
public
:
AudioResampler
(
uint32_t
aInRate
uint32_t
aOutRate
uint32_t
aPreBufferFrames
const
PrincipalHandle
&
aPrincipalHandle
)
;
void
AppendInput
(
const
AudioSegment
&
aInSegment
)
;
uint32_t
InputReadableFrames
(
)
const
;
uint32_t
InputWritableFrames
(
)
const
;
AudioSegment
Resample
(
uint32_t
aOutFrames
)
;
void
UpdateOutRate
(
uint32_t
aOutRate
)
{
Update
(
aOutRate
mResampler
.
GetChannels
(
)
)
;
}
private
:
void
UpdateChannels
(
uint32_t
aChannels
)
{
Update
(
mResampler
.
GetOutRate
(
)
aChannels
)
;
}
void
Update
(
uint32_t
aOutRate
uint32_t
aChannels
)
;
private
:
DynamicResampler
mResampler
;
AudioChunkList
mOutputChunks
;
bool
mIsSampleFormatSet
=
false
;
}
;
}
#
endif
