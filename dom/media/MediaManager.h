#
ifndef
MOZILLA_MEDIAMANAGER_H
#
define
MOZILLA_MEDIAMANAGER_H
#
include
"
MediaEngine
.
h
"
#
include
"
MediaEnginePrefs
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
mozilla
/
dom
/
GetUserMediaRequest
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIMediaManager
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIDOMNavigatorUserMedia
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamBinding
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamTrackBinding
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamError
.
h
"
#
include
"
mozilla
/
dom
/
NavigatorBinding
.
h
"
#
include
"
mozilla
/
media
/
MediaChild
.
h
"
#
include
"
mozilla
/
media
/
MediaParent
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
DOMMediaStream
.
h
"
#
ifdef
MOZ_WEBRTC
#
include
"
transport
/
runnable_utils
.
h
"
#
endif
class
nsIPrefBranch
;
namespace
mozilla
{
class
TaskQueue
;
class
MediaTimer
;
namespace
dom
{
struct
MediaStreamConstraints
;
struct
MediaTrackConstraints
;
struct
MediaTrackConstraintSet
;
enum
class
CallerType
:
uint32_t
;
enum
class
MediaDeviceKind
:
uint8_t
;
}
namespace
ipc
{
class
PrincipalInfo
;
}
class
GetUserMediaTask
;
class
GetUserMediaWindowListener
;
class
MediaManager
;
class
SourceListener
;
class
MediaDevice
:
public
nsIMediaDevice
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIMEDIADEVICE
MediaDevice
(
const
RefPtr
<
MediaEngineSource
>
&
aSource
const
nsString
&
aName
const
nsString
&
aID
const
nsString
&
aGroupID
const
nsString
&
aRawID
)
;
MediaDevice
(
const
RefPtr
<
AudioDeviceInfo
>
&
aAudioDeviceInfo
const
nsString
&
aID
const
nsString
&
aGroupID
const
nsString
&
aRawID
=
u
"
"
_ns
)
;
MediaDevice
(
const
RefPtr
<
MediaDevice
>
&
aOther
const
nsString
&
aID
const
nsString
&
aGroupID
const
nsString
&
aRawID
const
nsString
&
aRawGroupID
)
;
MediaDevice
(
const
RefPtr
<
MediaDevice
>
&
aOther
const
nsString
&
aID
const
nsString
&
aGroupID
const
nsString
&
aRawID
const
nsString
&
aRawGroupID
const
nsString
&
aName
)
;
uint32_t
GetBestFitnessDistance
(
const
nsTArray
<
const
NormalizedConstraintSet
*
>
&
aConstraintSets
bool
aIsChrome
)
;
nsresult
Allocate
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
uint64_t
aWindowId
const
char
*
*
aOutBadConstraint
)
;
void
SetTrack
(
const
RefPtr
<
MediaTrack
>
&
aTrack
const
PrincipalHandle
&
aPrincipal
)
;
nsresult
Start
(
)
;
nsresult
Reconfigure
(
const
dom
:
:
MediaTrackConstraints
&
aConstraints
const
MediaEnginePrefs
&
aPrefs
const
char
*
*
aOutBadConstraint
)
;
nsresult
FocusOnSelectedSource
(
)
;
nsresult
Stop
(
)
;
nsresult
Deallocate
(
)
;
void
GetSettings
(
dom
:
:
MediaTrackSettings
&
aOutSettings
)
const
;
dom
:
:
MediaSourceEnum
GetMediaSource
(
)
const
;
protected
:
virtual
~
MediaDevice
(
)
=
default
;
static
uint32_t
FitnessDistance
(
nsString
aN
const
dom
:
:
OwningStringOrStringSequenceOrConstrainDOMStringParameters
&
aConstraint
)
;
private
:
static
bool
StringsContain
(
const
dom
:
:
OwningStringOrStringSequence
&
aStrings
nsString
aN
)
;
static
uint32_t
FitnessDistance
(
nsString
aN
const
dom
:
:
ConstrainDOMStringParameters
&
aParams
)
;
public
:
const
RefPtr
<
MediaEngineSource
>
mSource
;
const
RefPtr
<
AudioDeviceInfo
>
mSinkInfo
;
const
dom
:
:
MediaDeviceKind
mKind
;
const
bool
mScary
;
const
bool
mIsFake
;
const
nsString
mType
;
const
nsString
mName
;
const
nsString
mID
;
const
nsString
mGroupID
;
const
nsString
mRawID
;
const
nsString
mRawGroupID
;
const
nsString
mRawName
;
}
;
typedef
nsRefPtrHashtable
<
nsUint64HashKey
GetUserMediaWindowListener
>
WindowTable
;
typedef
MozPromise
<
RefPtr
<
AudioDeviceInfo
>
nsresult
true
>
SinkInfoPromise
;
class
MediaManager
final
:
public
nsIMediaManagerService
public
nsIObserver
{
friend
SourceListener
;
public
:
static
already_AddRefed
<
MediaManager
>
GetInstance
(
)
;
static
MediaManager
*
Get
(
)
;
static
MediaManager
*
GetIfExists
(
)
;
static
void
StartupInit
(
)
;
static
void
Dispatch
(
already_AddRefed
<
Runnable
>
task
)
;
template
<
typename
MozPromiseType
typename
FunctionType
>
static
RefPtr
<
MozPromiseType
>
Dispatch
(
const
char
*
aName
FunctionType
&
&
aFunction
)
;
#
ifdef
DEBUG
static
bool
IsInMediaThread
(
)
;
#
endif
static
bool
Exists
(
)
{
return
!
!
GetIfExists
(
)
;
}
static
nsresult
NotifyRecordingStatusChange
(
nsPIDOMWindowInner
*
aWindow
)
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSIMEDIAMANAGERSERVICE
media
:
:
Parent
<
media
:
:
NonE10s
>
*
GetNonE10sParent
(
)
;
MediaEngine
*
GetBackend
(
)
;
WindowTable
*
GetActiveWindows
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
&
mActiveWindows
;
}
GetUserMediaWindowListener
*
GetWindowListener
(
uint64_t
aWindowId
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mActiveWindows
.
GetWeak
(
aWindowId
)
;
}
void
AddWindowID
(
uint64_t
aWindowId
RefPtr
<
GetUserMediaWindowListener
>
aListener
)
;
void
RemoveWindowID
(
uint64_t
aWindowId
)
;
void
SendPendingGUMRequest
(
)
;
bool
IsWindowStillActive
(
uint64_t
aWindowId
)
{
return
!
!
GetWindowListener
(
aWindowId
)
;
}
bool
IsWindowListenerStillActive
(
const
RefPtr
<
GetUserMediaWindowListener
>
&
aListener
)
;
static
bool
IsOn
(
const
dom
:
:
OwningBooleanOrMediaTrackConstraints
&
aUnion
)
{
return
!
aUnion
.
IsBoolean
(
)
|
|
aUnion
.
GetAsBoolean
(
)
;
}
typedef
dom
:
:
NavigatorUserMediaSuccessCallback
GetUserMediaSuccessCallback
;
typedef
dom
:
:
NavigatorUserMediaErrorCallback
GetUserMediaErrorCallback
;
MOZ_CAN_RUN_SCRIPT
static
void
CallOnError
(
GetUserMediaErrorCallback
&
aCallback
dom
:
:
MediaStreamError
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
static
void
CallOnSuccess
(
GetUserMediaSuccessCallback
&
aCallback
DOMMediaStream
&
aTrack
)
;
typedef
nsTArray
<
RefPtr
<
MediaDevice
>
>
MediaDeviceSet
;
typedef
media
:
:
Refcountable
<
MediaDeviceSet
>
MediaDeviceSetRefCnt
;
typedef
MozPromise
<
RefPtr
<
DOMMediaStream
>
RefPtr
<
MediaMgrError
>
true
>
StreamPromise
;
typedef
MozPromise
<
RefPtr
<
MediaDeviceSetRefCnt
>
RefPtr
<
MediaMgrError
>
true
>
DevicesPromise
;
typedef
MozPromise
<
bool
RefPtr
<
MediaMgrError
>
true
>
MgrPromise
;
typedef
MozPromise
<
const
char
*
RefPtr
<
MediaMgrError
>
true
>
BadConstraintsPromise
;
RefPtr
<
StreamPromise
>
GetUserMedia
(
nsPIDOMWindowInner
*
aWindow
const
dom
:
:
MediaStreamConstraints
&
aConstraints
dom
:
:
CallerType
aCallerType
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
GetUserMediaDevices
(
nsPIDOMWindowInner
*
aWindow
const
dom
:
:
MediaStreamConstraints
&
aConstraints
dom
:
:
MozGetUserMediaDevicesSuccessCallback
&
aOnSuccess
uint64_t
aInnerWindowID
=
0
const
nsAString
&
aCallID
=
nsString
(
)
)
;
RefPtr
<
DevicesPromise
>
EnumerateDevices
(
nsPIDOMWindowInner
*
aWindow
dom
:
:
CallerType
aCallerType
)
;
nsresult
EnumerateDevices
(
nsPIDOMWindowInner
*
aWindow
dom
:
:
Promise
&
aPromise
)
;
RefPtr
<
SinkInfoPromise
>
GetSinkDevice
(
nsPIDOMWindowInner
*
aWindow
const
nsString
&
aDeviceId
)
;
void
OnNavigation
(
uint64_t
aWindowID
)
;
void
OnCameraMute
(
bool
aMute
)
;
void
OnMicrophoneMute
(
bool
aMute
)
;
bool
IsActivelyCapturingOrHasAPermission
(
uint64_t
aWindowId
)
;
MediaEventSource
<
void
>
&
DeviceListChangeEvent
(
)
{
return
mDeviceListChangeEvent
;
}
MediaEnginePrefs
mPrefs
;
private
:
static
nsresult
GenerateUUID
(
nsAString
&
aResult
)
;
static
nsresult
AnonymizeId
(
nsAString
&
aId
const
nsACString
&
aOriginKey
)
;
public
:
static
void
AnonymizeDevices
(
MediaDeviceSet
&
aDevices
const
nsACString
&
aOriginKey
const
uint64_t
aWindowId
)
;
static
already_AddRefed
<
nsIWritableVariant
>
ToJSArray
(
MediaDeviceSet
&
aDevices
)
;
static
void
GuessVideoDeviceGroupIDs
(
MediaDeviceSet
&
aDevices
const
MediaDeviceSet
&
aAudios
)
;
private
:
enum
class
DeviceEnumerationType
:
uint8_t
{
Normal
Fake
Loopback
}
;
RefPtr
<
MgrPromise
>
EnumerateRawDevices
(
uint64_t
aWindowId
dom
:
:
MediaSourceEnum
aVideoInputType
dom
:
:
MediaSourceEnum
aAudioInputType
MediaSinkEnum
aAudioOutputType
DeviceEnumerationType
aVideoInputEnumType
DeviceEnumerationType
aAudioInputEnumType
bool
aForceNoPermRequest
const
RefPtr
<
MediaDeviceSetRefCnt
>
&
aOutDevices
)
;
RefPtr
<
MgrPromise
>
EnumerateDevicesImpl
(
uint64_t
aWindowId
dom
:
:
MediaSourceEnum
aVideoInputType
dom
:
:
MediaSourceEnum
aAudioInputType
MediaSinkEnum
aAudioOutputType
DeviceEnumerationType
aVideoInputEnumType
DeviceEnumerationType
aAudioInputEnumType
bool
aForceNoPermRequest
const
RefPtr
<
MediaDeviceSetRefCnt
>
&
aOutDevices
)
;
RefPtr
<
BadConstraintsPromise
>
SelectSettings
(
const
dom
:
:
MediaStreamConstraints
&
aConstraints
bool
aIsChrome
const
RefPtr
<
MediaDeviceSetRefCnt
>
&
aSources
)
;
void
GetPref
(
nsIPrefBranch
*
aBranch
const
char
*
aPref
const
char
*
aData
int32_t
*
aVal
)
;
void
GetPrefBool
(
nsIPrefBranch
*
aBranch
const
char
*
aPref
const
char
*
aData
bool
*
aVal
)
;
void
GetPrefs
(
nsIPrefBranch
*
aBranch
const
char
*
aData
)
;
explicit
MediaManager
(
already_AddRefed
<
TaskQueue
>
aMediaThread
)
;
~
MediaManager
(
)
=
default
;
void
Shutdown
(
)
;
void
StopScreensharing
(
uint64_t
aWindowID
)
;
void
RemoveMediaDevicesCallback
(
uint64_t
aWindowID
)
;
void
DeviceListChanged
(
)
;
WindowTable
mActiveWindows
;
nsRefPtrHashtable
<
nsStringHashKey
GetUserMediaTask
>
mActiveCallbacks
;
nsClassHashtable
<
nsUint64HashKey
nsTArray
<
nsString
>
>
mCallIds
;
nsTArray
<
RefPtr
<
dom
:
:
GetUserMediaRequest
>
>
mPendingGUMRequest
;
RefPtr
<
MediaTimer
>
mDeviceChangeTimer
;
bool
mCamerasMuted
=
false
;
bool
mMicrophonesMuted
=
false
;
const
RefPtr
<
TaskQueue
>
mMediaThread
;
nsCOMPtr
<
nsIAsyncShutdownBlocker
>
mShutdownBlocker
;
RefPtr
<
MediaEngine
>
mBackend
;
static
StaticRefPtr
<
MediaManager
>
sSingleton
;
static
StaticMutex
sSingletonMutex
;
struct
nsStringHasher
{
using
Key
=
nsString
;
using
Lookup
=
nsString
;
static
HashNumber
hash
(
const
Lookup
&
aLookup
)
{
return
HashString
(
aLookup
.
get
(
)
)
;
}
static
bool
match
(
const
Key
&
aKey
const
Lookup
&
aLookup
)
{
return
aKey
=
=
aLookup
;
}
}
;
using
DeviceIdSet
=
HashSet
<
nsString
nsStringHasher
InfallibleAllocPolicy
>
;
DeviceIdSet
mDeviceIDs
;
MediaEventListener
mDeviceListChangeListener
;
MediaEventProducer
<
void
>
mDeviceListChangeEvent
;
public
:
RefPtr
<
media
:
:
Parent
<
media
:
:
NonE10s
>
>
mNonE10sParent
;
}
;
}
#
endif
