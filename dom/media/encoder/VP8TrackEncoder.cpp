#
include
"
VP8TrackEncoder
.
h
"
#
include
"
DriftCompensation
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
ImageToI420
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
VideoSegment
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
vpx
/
vp8cx
.
h
"
#
include
"
vpx
/
vpx_encoder
.
h
"
#
include
"
WebMWriter
.
h
"
#
include
"
mozilla
/
media
/
MediaUtils
.
h
"
#
include
"
mozilla
/
dom
/
ImageUtils
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmapBinding
.
h
"
namespace
mozilla
{
LazyLogModule
gVP8TrackEncoderLog
(
"
VP8TrackEncoder
"
)
;
#
define
VP8LOG
(
level
msg
.
.
.
)
\
MOZ_LOG
(
gVP8TrackEncoderLog
level
(
msg
#
#
__VA_ARGS__
)
)
#
define
DEFAULT_BITRATE_BPS
2500000
constexpr
int
DEFAULT_KEYFRAME_INTERVAL_MS
=
10000
;
constexpr
int
DYNAMIC_MAXKFDIST_CHECK_INTERVAL
=
5
;
constexpr
float
DYNAMIC_MAXKFDIST_DIFFACTOR
=
0
.
4
;
constexpr
float
DYNAMIC_MAXKFDIST_KFINTERVAL_FACTOR
=
0
.
75
;
constexpr
int
I420_STRIDE_ALIGN
=
16
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
media
;
using
namespace
mozilla
:
:
dom
;
namespace
{
template
<
int
N
>
static
int
Aligned
(
int
aValue
)
{
if
(
aValue
<
N
)
{
return
N
;
}
return
(
(
(
aValue
-
1
)
/
N
)
+
1
)
*
N
;
}
template
<
int
Alignment
>
size_t
I420Size
(
int
aWidth
int
aHeight
)
{
int
yStride
=
Aligned
<
Alignment
>
(
aWidth
)
;
int
yHeight
=
aHeight
;
size_t
yPlaneSize
=
yStride
*
yHeight
;
int
uvStride
=
Aligned
<
Alignment
>
(
(
aWidth
+
1
)
/
2
)
;
int
uvHeight
=
(
aHeight
+
1
)
/
2
;
size_t
uvPlaneSize
=
uvStride
*
uvHeight
;
return
yPlaneSize
+
uvPlaneSize
*
2
;
}
nsresult
CreateEncoderConfig
(
int32_t
aWidth
int32_t
aHeight
uint32_t
aVideoBitrate
TrackRate
aTrackRate
int32_t
aMaxKeyFrameDistance
vpx_codec_enc_cfg_t
*
config
)
{
memset
(
config
0
sizeof
(
vpx_codec_enc_cfg_t
)
)
;
if
(
vpx_codec_enc_config_default
(
vpx_codec_vp8_cx
(
)
config
0
)
)
{
VP8LOG
(
LogLevel
:
:
Error
"
Failed
to
get
default
configuration
"
)
;
return
NS_ERROR_FAILURE
;
}
config
-
>
g_w
=
aWidth
;
config
-
>
g_h
=
aHeight
;
config
-
>
rc_target_bitrate
=
(
aVideoBitrate
!
=
0
?
aVideoBitrate
:
DEFAULT_BITRATE_BPS
)
/
1000
;
config
-
>
g_timebase
.
num
=
1
;
config
-
>
g_timebase
.
den
=
aTrackRate
;
config
-
>
g_error_resilient
=
0
;
config
-
>
g_lag_in_frames
=
0
;
int32_t
number_of_cores
=
PR_GetNumberOfProcessors
(
)
;
if
(
aWidth
*
aHeight
>
1920
*
1080
&
&
number_of_cores
>
=
8
)
{
config
-
>
g_threads
=
4
;
}
else
if
(
aWidth
*
aHeight
>
1280
*
960
&
&
number_of_cores
>
=
6
)
{
config
-
>
g_threads
=
3
;
}
else
if
(
aWidth
*
aHeight
>
640
*
480
&
&
number_of_cores
>
=
3
)
{
config
-
>
g_threads
=
2
;
}
else
{
config
-
>
g_threads
=
1
;
}
config
-
>
rc_dropframe_thresh
=
0
;
config
-
>
rc_end_usage
=
VPX_VBR
;
config
-
>
g_pass
=
VPX_RC_ONE_PASS
;
config
-
>
rc_resize_allowed
=
0
;
config
-
>
rc_undershoot_pct
=
200
;
config
-
>
rc_overshoot_pct
=
200
;
config
-
>
rc_buf_initial_sz
=
500
;
config
-
>
rc_buf_optimal_sz
=
600
;
config
-
>
rc_buf_sz
=
1000
;
config
-
>
kf_mode
=
VPX_KF_AUTO
;
config
-
>
kf_max_dist
=
aMaxKeyFrameDistance
;
return
NS_OK
;
}
}
VP8TrackEncoder
:
:
VP8TrackEncoder
(
RefPtr
<
DriftCompensator
>
aDriftCompensator
TrackRate
aTrackRate
FrameDroppingMode
aFrameDroppingMode
Maybe
<
float
>
aKeyFrameIntervalFactor
)
:
VideoTrackEncoder
(
std
:
:
move
(
aDriftCompensator
)
aTrackRate
aFrameDroppingMode
)
mKeyFrameInterval
(
TimeDuration
:
:
FromMilliseconds
(
DEFAULT_KEYFRAME_INTERVAL_MS
)
)
mKeyFrameIntervalFactor
(
aKeyFrameIntervalFactor
.
valueOr
(
DYNAMIC_MAXKFDIST_KFINTERVAL_FACTOR
)
)
{
MOZ_COUNT_CTOR
(
VP8TrackEncoder
)
;
}
VP8TrackEncoder
:
:
~
VP8TrackEncoder
(
)
{
Destroy
(
)
;
MOZ_COUNT_DTOR
(
VP8TrackEncoder
)
;
}
void
VP8TrackEncoder
:
:
Destroy
(
)
{
if
(
mInitialized
)
{
vpx_codec_destroy
(
&
mVPXContext
)
;
}
mInitialized
=
false
;
}
Maybe
<
int32_t
>
VP8TrackEncoder
:
:
CalculateMaxKeyFrameDistance
(
Maybe
<
float
>
aEstimatedFrameRate
)
const
{
if
(
!
aEstimatedFrameRate
&
&
mMeanFrameDuration
.
empty
(
)
)
{
return
Nothing
(
)
;
}
const
float
estimatedFrameRate
=
aEstimatedFrameRate
.
valueOrFrom
(
[
&
]
{
return
1
.
0f
/
mMeanFrameDuration
.
mean
(
)
.
ToSeconds
(
)
;
}
)
;
return
Some
(
std
:
:
max
(
1
static_cast
<
int32_t
>
(
estimatedFrameRate
*
mKeyFrameIntervalFactor
*
mKeyFrameInterval
.
ToSeconds
(
)
)
)
)
;
}
void
VP8TrackEncoder
:
:
SetMaxKeyFrameDistance
(
int32_t
aMaxKeyFrameDistance
)
{
if
(
mInitialized
)
{
VP8LOG
(
LogLevel
:
:
Debug
"
%
p
SetMaxKeyFrameDistance
(
)
set
kf_max_dist
to
%
d
based
on
estimated
"
"
framerate
%
.
2ffps
keyframe
-
factor
%
.
2f
and
keyframe
-
interval
%
.
2fs
"
this
aMaxKeyFrameDistance
1
/
mMeanFrameDuration
.
mean
(
)
.
ToSeconds
(
)
mKeyFrameIntervalFactor
mKeyFrameInterval
.
ToSeconds
(
)
)
;
DebugOnly
<
nsresult
>
rv
=
Reconfigure
(
mFrameWidth
mFrameHeight
aMaxKeyFrameDistance
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Reconfig
for
new
key
frame
distance
with
proven
size
should
succeed
"
)
;
}
else
{
VP8LOG
(
LogLevel
:
:
Debug
"
%
p
SetMaxKeyFrameDistance
(
)
distance
=
%
d
"
this
aMaxKeyFrameDistance
)
;
mMaxKeyFrameDistance
=
Some
(
aMaxKeyFrameDistance
)
;
}
}
void
VP8TrackEncoder
:
:
SetKeyFrameInterval
(
Maybe
<
TimeDuration
>
aKeyFrameInterval
)
{
const
TimeDuration
defaultInterval
=
TimeDuration
:
:
FromMilliseconds
(
DEFAULT_KEYFRAME_INTERVAL_MS
)
;
mKeyFrameInterval
=
std
:
:
min
(
aKeyFrameInterval
.
valueOr
(
defaultInterval
)
defaultInterval
)
;
VP8LOG
(
LogLevel
:
:
Debug
"
%
p
keyframe
interval
is
now
%
.
2fs
"
this
mKeyFrameInterval
.
ToSeconds
(
)
)
;
CalculateMaxKeyFrameDistance
(
)
.
apply
(
[
&
]
(
auto
aKfd
)
{
SetMaxKeyFrameDistance
(
aKfd
)
;
}
)
;
}
nsresult
VP8TrackEncoder
:
:
Init
(
int32_t
aWidth
int32_t
aHeight
int32_t
aDisplayWidth
int32_t
aDisplayHeight
float
aEstimatedFrameRate
)
{
if
(
aDisplayWidth
<
1
|
|
aDisplayHeight
<
1
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aEstimatedFrameRate
<
=
0
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
maxKeyFrameDistance
=
*
CalculateMaxKeyFrameDistance
(
Some
(
aEstimatedFrameRate
)
)
;
nsresult
rv
=
InitInternal
(
aWidth
aHeight
maxKeyFrameDistance
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
!
mI420Frame
)
;
MOZ_ASSERT
(
mI420FrameSize
=
=
0
)
;
const
size_t
neededSize
=
I420Size
<
I420_STRIDE_ALIGN
>
(
aWidth
aHeight
)
;
mI420Frame
.
reset
(
new
(
fallible
)
uint8_t
[
neededSize
]
)
;
mI420FrameSize
=
mI420Frame
?
neededSize
:
0
;
if
(
!
mI420Frame
)
{
VP8LOG
(
LogLevel
:
:
Warning
"
Allocating
I420
frame
of
size
%
zu
failed
"
neededSize
)
;
return
NS_ERROR_FAILURE
;
}
vpx_img_wrap
(
&
mVPXImageWrapper
VPX_IMG_FMT_I420
aWidth
aHeight
I420_STRIDE_ALIGN
mI420Frame
.
get
(
)
)
;
if
(
!
mMetadata
)
{
mMetadata
=
MakeAndAddRef
<
VP8Metadata
>
(
)
;
mMetadata
-
>
mWidth
=
aWidth
;
mMetadata
-
>
mHeight
=
aHeight
;
mMetadata
-
>
mDisplayWidth
=
aDisplayWidth
;
mMetadata
-
>
mDisplayHeight
=
aDisplayHeight
;
VP8LOG
(
LogLevel
:
:
Info
"
%
p
Init
(
)
created
metadata
.
width
=
%
d
height
=
%
d
displayWidth
=
%
d
"
"
displayHeight
=
%
d
framerate
=
%
.
2f
"
this
mMetadata
-
>
mWidth
mMetadata
-
>
mHeight
mMetadata
-
>
mDisplayWidth
mMetadata
-
>
mDisplayHeight
aEstimatedFrameRate
)
;
SetInitialized
(
)
;
}
return
NS_OK
;
}
nsresult
VP8TrackEncoder
:
:
InitInternal
(
int32_t
aWidth
int32_t
aHeight
int32_t
aMaxKeyFrameDistance
)
{
if
(
aWidth
<
1
|
|
aHeight
<
1
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mInitialized
)
{
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_FAILURE
;
}
VP8LOG
(
LogLevel
:
:
Debug
"
%
p
InitInternal
(
)
.
width
=
%
d
height
=
%
d
kf_max_dist
=
%
d
"
this
aWidth
aHeight
aMaxKeyFrameDistance
)
;
vpx_codec_enc_cfg_t
config
;
nsresult
rv
=
CreateEncoderConfig
(
aWidth
aHeight
mVideoBitrate
mTrackRate
aMaxKeyFrameDistance
&
config
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
vpx_codec_flags_t
flags
=
0
;
flags
|
=
VPX_CODEC_USE_OUTPUT_PARTITION
;
if
(
vpx_codec_enc_init
(
&
mVPXContext
vpx_codec_vp8_cx
(
)
&
config
flags
)
)
{
return
NS_ERROR_FAILURE
;
}
vpx_codec_control
(
&
mVPXContext
VP8E_SET_STATIC_THRESHOLD
1
)
;
vpx_codec_control
(
&
mVPXContext
VP8E_SET_CPUUSED
15
)
;
vpx_codec_control
(
&
mVPXContext
VP8E_SET_TOKEN_PARTITIONS
VP8_TWO_TOKENPARTITION
)
;
mFrameWidth
=
aWidth
;
mFrameHeight
=
aHeight
;
mMaxKeyFrameDistance
=
Some
(
aMaxKeyFrameDistance
)
;
return
NS_OK
;
}
nsresult
VP8TrackEncoder
:
:
Reconfigure
(
int32_t
aWidth
int32_t
aHeight
int32_t
aMaxKeyFrameDistance
)
{
if
(
aWidth
<
=
0
|
|
aHeight
<
=
0
)
{
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
mInitialized
)
{
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_FAILURE
;
}
bool
needsReInit
=
aMaxKeyFrameDistance
!
=
*
mMaxKeyFrameDistance
;
if
(
aWidth
!
=
mFrameWidth
|
|
aHeight
!
=
mFrameHeight
)
{
VP8LOG
(
LogLevel
:
:
Info
"
Dynamic
resolution
change
(
%
dx
%
d
-
>
%
dx
%
d
)
.
"
mFrameWidth
mFrameHeight
aWidth
aHeight
)
;
const
size_t
neededSize
=
I420Size
<
I420_STRIDE_ALIGN
>
(
aWidth
aHeight
)
;
if
(
neededSize
>
mI420FrameSize
)
{
needsReInit
=
true
;
mI420Frame
.
reset
(
new
(
fallible
)
uint8_t
[
neededSize
]
)
;
mI420FrameSize
=
mI420Frame
?
neededSize
:
0
;
}
if
(
!
mI420Frame
)
{
VP8LOG
(
LogLevel
:
:
Warning
"
Allocating
I420
frame
of
size
%
zu
failed
"
neededSize
)
;
return
NS_ERROR_FAILURE
;
}
vpx_img_wrap
(
&
mVPXImageWrapper
VPX_IMG_FMT_I420
aWidth
aHeight
I420_STRIDE_ALIGN
mI420Frame
.
get
(
)
)
;
}
if
(
needsReInit
)
{
Destroy
(
)
;
mMaxKeyFrameDistance
=
Some
(
aMaxKeyFrameDistance
)
;
nsresult
rv
=
InitInternal
(
aWidth
aHeight
aMaxKeyFrameDistance
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
mInitialized
=
true
;
return
NS_OK
;
}
vpx_codec_enc_cfg_t
config
;
nsresult
rv
=
CreateEncoderConfig
(
aWidth
aHeight
mVideoBitrate
mTrackRate
aMaxKeyFrameDistance
&
config
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
if
(
vpx_codec_enc_config_set
(
&
mVPXContext
&
config
)
!
=
VPX_CODEC_OK
)
{
VP8LOG
(
LogLevel
:
:
Error
"
Failed
to
set
new
configuration
"
)
;
return
NS_ERROR_FAILURE
;
}
mFrameWidth
=
aWidth
;
mFrameHeight
=
aHeight
;
return
NS_OK
;
}
already_AddRefed
<
TrackMetadataBase
>
VP8TrackEncoder
:
:
GetMetadata
(
)
{
AUTO_PROFILER_LABEL
(
"
VP8TrackEncoder
:
:
GetMetadata
"
OTHER
)
;
MOZ_ASSERT
(
mInitialized
|
|
mCanceled
)
;
if
(
mCanceled
|
|
mEncodingComplete
)
{
return
nullptr
;
}
if
(
!
mInitialized
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mMetadata
)
;
return
do_AddRef
(
mMetadata
)
;
}
nsresult
VP8TrackEncoder
:
:
GetEncodedPartitions
(
nsTArray
<
RefPtr
<
EncodedFrame
>
>
&
aData
)
{
vpx_codec_iter_t
iter
=
nullptr
;
EncodedFrame
:
:
FrameType
frameType
=
EncodedFrame
:
:
VP8_P_FRAME
;
auto
frameData
=
MakeRefPtr
<
EncodedFrame
:
:
FrameData
>
(
)
;
const
vpx_codec_cx_pkt_t
*
pkt
=
nullptr
;
while
(
(
pkt
=
vpx_codec_get_cx_data
(
&
mVPXContext
&
iter
)
)
!
=
nullptr
)
{
switch
(
pkt
-
>
kind
)
{
case
VPX_CODEC_CX_FRAME_PKT
:
{
frameData
-
>
AppendElements
(
(
uint8_t
*
)
pkt
-
>
data
.
frame
.
buf
pkt
-
>
data
.
frame
.
sz
)
;
break
;
}
default
:
{
break
;
}
}
if
(
(
pkt
-
>
data
.
frame
.
flags
&
VPX_FRAME_IS_FRAGMENT
)
=
=
0
)
{
if
(
pkt
-
>
data
.
frame
.
flags
&
VPX_FRAME_IS_KEY
)
{
frameType
=
EncodedFrame
:
:
VP8_I_FRAME
;
}
break
;
}
}
if
(
!
frameData
-
>
IsEmpty
(
)
)
{
if
(
pkt
-
>
data
.
frame
.
flags
&
VPX_FRAME_IS_KEY
)
{
TrackTime
frameTime
=
pkt
-
>
data
.
frame
.
pts
;
DebugOnly
<
TrackTime
>
frameDuration
=
pkt
-
>
data
.
frame
.
duration
;
MOZ_ASSERT
(
frameTime
+
frameDuration
<
=
mEncodedTimestamp
)
;
mDurationSinceLastKeyframe
=
std
:
:
min
(
mDurationSinceLastKeyframe
mEncodedTimestamp
-
frameTime
)
;
}
media
:
:
TimeUnit
timestamp
=
FramesToTimeUnit
(
pkt
-
>
data
.
frame
.
pts
mTrackRate
)
;
if
(
!
timestamp
.
IsValid
(
)
)
{
NS_ERROR
(
"
Microsecond
timestamp
overflow
"
)
;
return
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
;
}
mExtractedDuration
+
=
pkt
-
>
data
.
frame
.
duration
;
if
(
!
mExtractedDuration
.
isValid
(
)
)
{
NS_ERROR
(
"
Duration
overflow
"
)
;
return
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
;
}
media
:
:
TimeUnit
totalDuration
=
FramesToTimeUnit
(
mExtractedDuration
.
value
(
)
mTrackRate
)
;
if
(
!
totalDuration
.
IsValid
(
)
)
{
NS_ERROR
(
"
Duration
overflow
"
)
;
return
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
;
}
media
:
:
TimeUnit
duration
=
totalDuration
-
mExtractedDurationUs
;
if
(
!
duration
.
IsValid
(
)
)
{
NS_ERROR
(
"
Duration
overflow
"
)
;
return
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
;
}
mExtractedDurationUs
=
totalDuration
;
VP8LOG
(
LogLevel
:
:
Verbose
"
GetEncodedPartitions
TimeStamp
%
.
2f
Duration
%
.
2f
FrameType
%
d
"
timestamp
.
ToSeconds
(
)
duration
.
ToSeconds
(
)
frameType
)
;
aData
.
AppendElement
(
MakeRefPtr
<
EncodedFrame
>
(
timestamp
duration
.
ToMicroseconds
(
)
PR_USEC_PER_SEC
frameType
std
:
:
move
(
frameData
)
)
)
;
if
(
static_cast
<
int
>
(
totalDuration
.
ToSeconds
(
)
)
/
DYNAMIC_MAXKFDIST_CHECK_INTERVAL
>
static_cast
<
int
>
(
mLastKeyFrameDistanceUpdate
.
ToSeconds
(
)
)
/
DYNAMIC_MAXKFDIST_CHECK_INTERVAL
)
{
mLastKeyFrameDistanceUpdate
=
totalDuration
;
const
int32_t
maxKfDistance
=
CalculateMaxKeyFrameDistance
(
)
.
valueOr
(
*
mMaxKeyFrameDistance
)
;
const
float
diffFactor
=
static_cast
<
float
>
(
maxKfDistance
)
/
*
mMaxKeyFrameDistance
;
VP8LOG
(
LogLevel
:
:
Debug
"
maxKfDistance
:
%
d
factor
:
%
.
2f
"
maxKfDistance
diffFactor
)
;
if
(
std
:
:
abs
(
1
.
0
-
diffFactor
)
>
DYNAMIC_MAXKFDIST_DIFFACTOR
)
{
SetMaxKeyFrameDistance
(
maxKfDistance
)
;
}
}
}
return
pkt
?
NS_OK
:
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
VP8TrackEncoder
:
:
PrepareRawFrame
(
VideoChunk
&
aChunk
)
{
gfx
:
:
IntSize
intrinsicSize
=
aChunk
.
mFrame
.
GetIntrinsicSize
(
)
;
RefPtr
<
Image
>
img
;
if
(
aChunk
.
mFrame
.
GetForceBlack
(
)
|
|
aChunk
.
IsNull
(
)
)
{
if
(
!
mMuteFrame
|
|
mMuteFrame
-
>
GetSize
(
)
!
=
intrinsicSize
)
{
mMuteFrame
=
VideoFrame
:
:
CreateBlackImage
(
intrinsicSize
)
;
}
if
(
!
mMuteFrame
)
{
VP8LOG
(
LogLevel
:
:
Warning
"
Failed
to
allocate
black
image
of
size
%
dx
%
d
"
intrinsicSize
.
width
intrinsicSize
.
height
)
;
return
NS_OK
;
}
img
=
mMuteFrame
;
}
else
{
img
=
aChunk
.
mFrame
.
GetImage
(
)
;
}
gfx
:
:
IntSize
imgSize
=
img
-
>
GetSize
(
)
;
if
(
imgSize
!
=
IntSize
(
mFrameWidth
mFrameHeight
)
)
{
nsresult
rv
=
Reconfigure
(
imgSize
.
width
imgSize
.
height
*
mMaxKeyFrameDistance
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
MOZ_ASSERT
(
mFrameWidth
=
=
imgSize
.
width
)
;
MOZ_ASSERT
(
mFrameHeight
=
=
imgSize
.
height
)
;
nsresult
rv
=
ConvertToI420
(
img
mVPXImageWrapper
.
planes
[
VPX_PLANE_Y
]
mVPXImageWrapper
.
stride
[
VPX_PLANE_Y
]
mVPXImageWrapper
.
planes
[
VPX_PLANE_U
]
mVPXImageWrapper
.
stride
[
VPX_PLANE_U
]
mVPXImageWrapper
.
planes
[
VPX_PLANE_V
]
mVPXImageWrapper
.
stride
[
VPX_PLANE_V
]
)
;
if
(
NS_FAILED
(
rv
)
)
{
VP8LOG
(
LogLevel
:
:
Error
"
Converting
to
I420
failed
"
)
;
return
rv
;
}
return
NS_OK
;
}
#
define
I_FRAME_RATIO
(
0
.
85
)
/
/
Effectively
disabled
because
perceived
quality
#
define
SKIP_FRAME_RATIO
(
0
.
85
)
VP8TrackEncoder
:
:
EncodeOperation
VP8TrackEncoder
:
:
GetNextEncodeOperation
(
TimeDuration
aTimeElapsed
TimeDuration
aProcessedDuration
)
{
if
(
mFrameDroppingMode
=
=
FrameDroppingMode
:
:
DISALLOW
)
{
return
ENCODE_NORMAL_FRAME
;
}
if
(
aTimeElapsed
.
ToSeconds
(
)
>
aProcessedDuration
.
ToSeconds
(
)
*
SKIP_FRAME_RATIO
)
{
return
SKIP_FRAME
;
}
if
(
aTimeElapsed
.
ToSeconds
(
)
>
aProcessedDuration
.
ToSeconds
(
)
*
I_FRAME_RATIO
)
{
return
ENCODE_I_FRAME
;
}
return
ENCODE_NORMAL_FRAME
;
}
nsresult
VP8TrackEncoder
:
:
GetEncodedTrack
(
nsTArray
<
RefPtr
<
EncodedFrame
>
>
&
aData
)
{
AUTO_PROFILER_LABEL
(
"
VP8TrackEncoder
:
:
GetEncodedTrack
"
OTHER
)
;
MOZ_ASSERT
(
mInitialized
|
|
mCanceled
)
;
if
(
mCanceled
|
|
mEncodingComplete
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mInitialized
)
{
return
NS_ERROR_FAILURE
;
}
TakeTrackData
(
mSourceSegment
)
;
EncodeOperation
nextEncodeOperation
=
ENCODE_NORMAL_FRAME
;
for
(
VideoSegment
:
:
ChunkIterator
iter
(
mSourceSegment
)
;
!
iter
.
IsEnded
(
)
;
iter
.
Next
(
)
)
{
TimeStamp
timebase
=
TimeStamp
:
:
Now
(
)
;
VideoChunk
&
chunk
=
*
iter
;
VP8LOG
(
LogLevel
:
:
Verbose
"
nextEncodeOperation
is
%
d
for
frame
of
duration
%
"
PRId64
nextEncodeOperation
chunk
.
GetDuration
(
)
)
;
if
(
nextEncodeOperation
!
=
SKIP_FRAME
)
{
nsresult
rv
=
PrepareRawFrame
(
chunk
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
int
flags
=
0
;
if
(
nextEncodeOperation
=
=
ENCODE_I_FRAME
)
{
VP8LOG
(
LogLevel
:
:
Warning
"
MediaRecorder
lagging
behind
.
Encoding
keyframe
.
"
)
;
flags
|
=
VPX_EFLAG_FORCE_KF
;
}
if
(
mKeyFrameInterval
>
TimeDuration
:
:
FromSeconds
(
0
)
)
{
if
(
FramesToTimeUnit
(
mDurationSinceLastKeyframe
mTrackRate
)
.
ToTimeDuration
(
)
>
=
mKeyFrameInterval
)
{
VP8LOG
(
LogLevel
:
:
Warning
"
Reached
mKeyFrameInterval
without
seeing
a
keyframe
.
Forcing
"
"
one
.
time
:
%
.
2f
interval
:
%
.
2f
"
FramesToTimeUnit
(
mDurationSinceLastKeyframe
mTrackRate
)
.
ToSeconds
(
)
mKeyFrameInterval
.
ToSeconds
(
)
)
;
mDurationSinceLastKeyframe
=
0
;
flags
|
=
VPX_EFLAG_FORCE_KF
;
}
mDurationSinceLastKeyframe
+
=
chunk
.
GetDuration
(
)
;
}
if
(
vpx_codec_encode
(
&
mVPXContext
&
mVPXImageWrapper
mEncodedTimestamp
(
unsigned
long
)
chunk
.
GetDuration
(
)
flags
VPX_DL_REALTIME
)
)
{
VP8LOG
(
LogLevel
:
:
Error
"
vpx_codec_encode
failed
to
encode
the
frame
.
"
)
;
return
NS_ERROR_FAILURE
;
}
mEncodedTimestamp
+
=
chunk
.
GetDuration
(
)
;
rv
=
GetEncodedPartitions
(
aData
)
;
if
(
rv
!
=
NS_OK
&
&
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
{
VP8LOG
(
LogLevel
:
:
Error
"
GetEncodedPartitions
failed
.
"
)
;
return
NS_ERROR_FAILURE
;
}
}
else
{
mEncodedTimestamp
+
=
chunk
.
GetDuration
(
)
;
VP8LOG
(
LogLevel
:
:
Warning
"
MediaRecorder
lagging
behind
.
Skipping
a
frame
.
"
)
;
mExtractedDuration
+
=
chunk
.
mDuration
;
if
(
!
mExtractedDuration
.
isValid
(
)
)
{
NS_ERROR
(
"
skipped
duration
overflow
"
)
;
return
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
;
}
media
:
:
TimeUnit
totalDuration
=
FramesToTimeUnit
(
mExtractedDuration
.
value
(
)
mTrackRate
)
;
media
:
:
TimeUnit
skippedDuration
=
totalDuration
-
mExtractedDurationUs
;
mExtractedDurationUs
=
totalDuration
;
if
(
!
skippedDuration
.
IsValid
(
)
)
{
NS_ERROR
(
"
skipped
duration
overflow
"
)
;
return
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
;
}
{
auto
&
last
=
aData
.
LastElement
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aData
.
LastElement
(
)
)
;
uint64_t
longerDuration
=
last
-
>
mDuration
+
skippedDuration
.
ToMicroseconds
(
)
;
auto
longerFrame
=
MakeRefPtr
<
EncodedFrame
>
(
last
-
>
mTime
longerDuration
last
-
>
mDurationBase
last
-
>
mFrameType
last
-
>
mFrameData
)
;
std
:
:
swap
(
last
longerFrame
)
;
MOZ_ASSERT
(
last
-
>
mDuration
=
=
longerDuration
)
;
}
}
mMeanFrameEncodeDuration
.
insert
(
TimeStamp
:
:
Now
(
)
-
timebase
)
;
mMeanFrameDuration
.
insert
(
FramesToTimeUnit
(
chunk
.
GetDuration
(
)
mTrackRate
)
.
ToTimeDuration
(
)
)
;
nextEncodeOperation
=
GetNextEncodeOperation
(
mMeanFrameEncodeDuration
.
mean
(
)
mMeanFrameDuration
.
mean
(
)
)
;
}
mSourceSegment
.
Clear
(
)
;
if
(
mEndOfStream
)
{
VP8LOG
(
LogLevel
:
:
Debug
"
mEndOfStream
is
true
"
)
;
mEncodingComplete
=
true
;
if
(
mI420Frame
)
{
mI420Frame
=
nullptr
;
mI420FrameSize
=
0
;
}
while
(
true
)
{
if
(
vpx_codec_encode
(
&
mVPXContext
nullptr
mEncodedTimestamp
0
0
VPX_DL_REALTIME
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
GetEncodedPartitions
(
aData
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
break
;
}
if
(
rv
!
=
NS_OK
)
{
return
NS_ERROR_FAILURE
;
}
}
}
return
NS_OK
;
}
}
#
undef
VP8LOG
