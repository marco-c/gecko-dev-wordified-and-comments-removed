#
include
"
VP8TrackEncoder
.
h
"
#
include
"
DriftCompensation
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
ImageToI420
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
VideoSegment
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
"
vpx
/
vp8cx
.
h
"
#
include
"
vpx
/
vpx_encoder
.
h
"
#
include
"
WebMWriter
.
h
"
#
include
"
mozilla
/
media
/
MediaUtils
.
h
"
#
include
"
mozilla
/
dom
/
ImageUtils
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmapBinding
.
h
"
namespace
mozilla
{
LazyLogModule
gVP8TrackEncoderLog
(
"
VP8TrackEncoder
"
)
;
#
define
VP8LOG
(
level
msg
.
.
.
)
\
MOZ_LOG
(
gVP8TrackEncoderLog
level
(
msg
#
#
__VA_ARGS__
)
)
#
define
DEFAULT_BITRATE_BPS
2500000
constexpr
int
I420_STRIDE_ALIGN
=
16
;
#
define
MAX_KEYFRAME_INTERVAL
600
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
media
;
using
namespace
mozilla
:
:
dom
;
namespace
{
template
<
int
N
>
static
int
Aligned
(
int
aValue
)
{
if
(
aValue
<
N
)
{
return
N
;
}
return
(
(
(
aValue
-
1
)
/
N
)
+
1
)
*
N
;
}
template
<
int
Alignment
>
size_t
I420Size
(
int
aWidth
int
aHeight
)
{
int
yStride
=
Aligned
<
Alignment
>
(
aWidth
)
;
int
yHeight
=
aHeight
;
size_t
yPlaneSize
=
yStride
*
yHeight
;
int
uvStride
=
Aligned
<
Alignment
>
(
(
aWidth
+
1
)
/
2
)
;
int
uvHeight
=
(
aHeight
+
1
)
/
2
;
size_t
uvPlaneSize
=
uvStride
*
uvHeight
;
return
yPlaneSize
+
uvPlaneSize
*
2
;
}
nsresult
CreateEncoderConfig
(
int32_t
aWidth
int32_t
aHeight
uint32_t
aVideoBitrate
TrackRate
aTrackRate
vpx_codec_enc_cfg_t
*
config
)
{
memset
(
config
0
sizeof
(
vpx_codec_enc_cfg_t
)
)
;
if
(
vpx_codec_enc_config_default
(
vpx_codec_vp8_cx
(
)
config
0
)
)
{
VP8LOG
(
LogLevel
:
:
Error
"
Failed
to
get
default
configuration
"
)
;
return
NS_ERROR_FAILURE
;
}
config
-
>
g_w
=
aWidth
;
config
-
>
g_h
=
aHeight
;
config
-
>
rc_target_bitrate
=
(
aVideoBitrate
!
=
0
?
aVideoBitrate
:
DEFAULT_BITRATE_BPS
)
/
1000
;
config
-
>
g_timebase
.
num
=
1
;
config
-
>
g_timebase
.
den
=
aTrackRate
;
config
-
>
g_error_resilient
=
0
;
config
-
>
g_lag_in_frames
=
0
;
int32_t
number_of_cores
=
PR_GetNumberOfProcessors
(
)
;
if
(
aWidth
*
aHeight
>
1920
*
1080
&
&
number_of_cores
>
=
8
)
{
config
-
>
g_threads
=
4
;
}
else
if
(
aWidth
*
aHeight
>
1280
*
960
&
&
number_of_cores
>
=
6
)
{
config
-
>
g_threads
=
3
;
}
else
if
(
aWidth
*
aHeight
>
640
*
480
&
&
number_of_cores
>
=
3
)
{
config
-
>
g_threads
=
2
;
}
else
{
config
-
>
g_threads
=
1
;
}
config
-
>
rc_dropframe_thresh
=
0
;
config
-
>
rc_end_usage
=
VPX_VBR
;
config
-
>
g_pass
=
VPX_RC_ONE_PASS
;
config
-
>
rc_resize_allowed
=
0
;
config
-
>
rc_undershoot_pct
=
200
;
config
-
>
rc_overshoot_pct
=
200
;
config
-
>
rc_buf_initial_sz
=
500
;
config
-
>
rc_buf_optimal_sz
=
600
;
config
-
>
rc_buf_sz
=
1000
;
config
-
>
kf_mode
=
VPX_KF_AUTO
;
config
-
>
kf_max_dist
=
MAX_KEYFRAME_INTERVAL
;
return
NS_OK
;
}
}
VP8TrackEncoder
:
:
VP8TrackEncoder
(
RefPtr
<
DriftCompensator
>
aDriftCompensator
TrackRate
aTrackRate
FrameDroppingMode
aFrameDroppingMode
)
:
VideoTrackEncoder
(
std
:
:
move
(
aDriftCompensator
)
aTrackRate
aFrameDroppingMode
)
{
MOZ_COUNT_CTOR
(
VP8TrackEncoder
)
;
}
VP8TrackEncoder
:
:
~
VP8TrackEncoder
(
)
{
Destroy
(
)
;
MOZ_COUNT_DTOR
(
VP8TrackEncoder
)
;
}
void
VP8TrackEncoder
:
:
Destroy
(
)
{
if
(
mInitialized
)
{
vpx_codec_destroy
(
&
mVPXContext
)
;
}
mInitialized
=
false
;
}
nsresult
VP8TrackEncoder
:
:
Init
(
int32_t
aWidth
int32_t
aHeight
int32_t
aDisplayWidth
int32_t
aDisplayHeight
)
{
if
(
aWidth
<
1
|
|
aHeight
<
1
|
|
aDisplayWidth
<
1
|
|
aDisplayHeight
<
1
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mInitialized
)
{
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_FAILURE
;
}
vpx_codec_enc_cfg_t
config
;
nsresult
rv
=
CreateEncoderConfig
(
aWidth
aHeight
mVideoBitrate
mTrackRate
&
config
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
vpx_codec_flags_t
flags
=
0
;
flags
|
=
VPX_CODEC_USE_OUTPUT_PARTITION
;
if
(
vpx_codec_enc_init
(
&
mVPXContext
vpx_codec_vp8_cx
(
)
&
config
flags
)
)
{
return
NS_ERROR_FAILURE
;
}
vpx_codec_control
(
&
mVPXContext
VP8E_SET_STATIC_THRESHOLD
1
)
;
vpx_codec_control
(
&
mVPXContext
VP8E_SET_CPUUSED
15
)
;
vpx_codec_control
(
&
mVPXContext
VP8E_SET_TOKEN_PARTITIONS
VP8_TWO_TOKENPARTITION
)
;
if
(
!
mMetadata
)
{
mMetadata
=
MakeAndAddRef
<
VP8Metadata
>
(
)
;
mMetadata
-
>
mWidth
=
aWidth
;
mMetadata
-
>
mHeight
=
aHeight
;
mMetadata
-
>
mDisplayWidth
=
aDisplayWidth
;
mMetadata
-
>
mDisplayHeight
=
aDisplayHeight
;
VP8LOG
(
LogLevel
:
:
Info
"
%
p
Init
(
)
created
metadata
.
width
=
%
d
height
=
%
d
displayWidth
=
%
d
"
"
displayHeight
=
%
d
"
this
mMetadata
-
>
mWidth
mMetadata
-
>
mHeight
mMetadata
-
>
mDisplayWidth
mMetadata
-
>
mDisplayHeight
)
;
}
mFrameWidth
=
aWidth
;
mFrameHeight
=
aHeight
;
SetInitialized
(
)
;
return
NS_OK
;
}
nsresult
VP8TrackEncoder
:
:
Reconfigure
(
int32_t
aWidth
int32_t
aHeight
int32_t
aDisplayWidth
int32_t
aDisplayHeight
)
{
if
(
aWidth
<
=
0
|
|
aHeight
<
=
0
|
|
aDisplayWidth
<
=
0
|
|
aDisplayHeight
<
=
0
)
{
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
mInitialized
)
{
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_FAILURE
;
}
vpx_codec_enc_cfg_t
config
;
nsresult
rv
=
CreateEncoderConfig
(
aWidth
aHeight
mVideoBitrate
mTrackRate
&
config
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
if
(
vpx_codec_enc_config_set
(
&
mVPXContext
&
config
)
!
=
VPX_CODEC_OK
)
{
VP8LOG
(
LogLevel
:
:
Error
"
Failed
to
set
new
configuration
"
)
;
return
NS_ERROR_FAILURE
;
}
mFrameWidth
=
aWidth
;
mFrameHeight
=
aHeight
;
return
NS_OK
;
}
already_AddRefed
<
TrackMetadataBase
>
VP8TrackEncoder
:
:
GetMetadata
(
)
{
AUTO_PROFILER_LABEL
(
"
VP8TrackEncoder
:
:
GetMetadata
"
OTHER
)
;
MOZ_ASSERT
(
mInitialized
|
|
mCanceled
)
;
if
(
mCanceled
|
|
mEncodingComplete
)
{
return
nullptr
;
}
if
(
!
mInitialized
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mMetadata
)
;
return
do_AddRef
(
mMetadata
)
;
}
nsresult
VP8TrackEncoder
:
:
GetEncodedPartitions
(
nsTArray
<
RefPtr
<
EncodedFrame
>
>
&
aData
)
{
vpx_codec_iter_t
iter
=
nullptr
;
EncodedFrame
:
:
FrameType
frameType
=
EncodedFrame
:
:
VP8_P_FRAME
;
auto
frameData
=
MakeRefPtr
<
EncodedFrame
:
:
FrameData
>
(
)
;
const
vpx_codec_cx_pkt_t
*
pkt
=
nullptr
;
while
(
(
pkt
=
vpx_codec_get_cx_data
(
&
mVPXContext
&
iter
)
)
!
=
nullptr
)
{
switch
(
pkt
-
>
kind
)
{
case
VPX_CODEC_CX_FRAME_PKT
:
{
frameData
-
>
AppendElements
(
(
uint8_t
*
)
pkt
-
>
data
.
frame
.
buf
pkt
-
>
data
.
frame
.
sz
)
;
break
;
}
default
:
{
break
;
}
}
if
(
(
pkt
-
>
data
.
frame
.
flags
&
VPX_FRAME_IS_FRAGMENT
)
=
=
0
)
{
if
(
pkt
-
>
data
.
frame
.
flags
&
VPX_FRAME_IS_KEY
)
{
frameType
=
EncodedFrame
:
:
VP8_I_FRAME
;
}
break
;
}
}
if
(
!
frameData
-
>
IsEmpty
(
)
)
{
media
:
:
TimeUnit
timestamp
=
FramesToTimeUnit
(
pkt
-
>
data
.
frame
.
pts
mTrackRate
)
;
if
(
!
timestamp
.
IsValid
(
)
)
{
NS_ERROR
(
"
Microsecond
timestamp
overflow
"
)
;
return
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
;
}
mExtractedDuration
+
=
pkt
-
>
data
.
frame
.
duration
;
if
(
!
mExtractedDuration
.
isValid
(
)
)
{
NS_ERROR
(
"
Duration
overflow
"
)
;
return
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
;
}
media
:
:
TimeUnit
totalDuration
=
FramesToTimeUnit
(
mExtractedDuration
.
value
(
)
mTrackRate
)
;
if
(
!
totalDuration
.
IsValid
(
)
)
{
NS_ERROR
(
"
Duration
overflow
"
)
;
return
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
;
}
media
:
:
TimeUnit
duration
=
totalDuration
-
mExtractedDurationUs
;
if
(
!
duration
.
IsValid
(
)
)
{
NS_ERROR
(
"
Duration
overflow
"
)
;
return
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
;
}
mExtractedDurationUs
=
totalDuration
;
VP8LOG
(
LogLevel
:
:
Verbose
"
GetEncodedPartitions
TimeStamp
%
.
2f
Duration
%
.
2f
FrameType
%
d
"
timestamp
.
ToSeconds
(
)
duration
.
ToSeconds
(
)
frameType
)
;
aData
.
AppendElement
(
MakeRefPtr
<
EncodedFrame
>
(
timestamp
duration
.
ToMicroseconds
(
)
PR_USEC_PER_SEC
frameType
std
:
:
move
(
frameData
)
)
)
;
}
return
pkt
?
NS_OK
:
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
VP8TrackEncoder
:
:
PrepareRawFrame
(
VideoChunk
&
aChunk
)
{
gfx
:
:
IntSize
intrinsicSize
=
aChunk
.
mFrame
.
GetIntrinsicSize
(
)
;
RefPtr
<
Image
>
img
;
if
(
aChunk
.
mFrame
.
GetForceBlack
(
)
|
|
aChunk
.
IsNull
(
)
)
{
if
(
!
mMuteFrame
|
|
mMuteFrame
-
>
GetSize
(
)
!
=
intrinsicSize
)
{
mMuteFrame
=
VideoFrame
:
:
CreateBlackImage
(
intrinsicSize
)
;
}
if
(
!
mMuteFrame
)
{
VP8LOG
(
LogLevel
:
:
Warning
"
Failed
to
allocate
black
image
of
size
%
dx
%
d
"
intrinsicSize
.
width
intrinsicSize
.
height
)
;
return
NS_OK
;
}
img
=
mMuteFrame
;
}
else
{
img
=
aChunk
.
mFrame
.
GetImage
(
)
;
}
gfx
:
:
IntSize
imgSize
=
img
-
>
GetSize
(
)
;
if
(
imgSize
!
=
IntSize
(
mFrameWidth
mFrameHeight
)
)
{
VP8LOG
(
LogLevel
:
:
Info
"
Dynamic
resolution
change
(
was
%
dx
%
d
now
%
dx
%
d
)
.
"
mFrameWidth
mFrameHeight
imgSize
.
width
imgSize
.
height
)
;
if
(
imgSize
<
=
IntSize
(
mFrameWidth
mFrameHeight
)
&
&
NS_SUCCEEDED
(
Reconfigure
(
imgSize
.
width
imgSize
.
height
intrinsicSize
.
width
intrinsicSize
.
height
)
)
)
{
VP8LOG
(
LogLevel
:
:
Info
"
Reconfigured
VP8
encoder
.
"
)
;
}
else
{
Destroy
(
)
;
nsresult
rv
=
Init
(
imgSize
.
width
imgSize
.
height
intrinsicSize
.
width
intrinsicSize
.
height
)
;
VP8LOG
(
LogLevel
:
:
Info
"
Recreated
VP8
encoder
.
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
const
size_t
neededSize
=
I420Size
<
I420_STRIDE_ALIGN
>
(
mFrameWidth
mFrameHeight
)
;
if
(
neededSize
>
mI420FrameSize
)
{
mI420Frame
.
reset
(
new
(
fallible
)
uint8_t
[
neededSize
]
)
;
}
if
(
!
mI420Frame
)
{
VP8LOG
(
LogLevel
:
:
Warning
"
Allocating
I420
frame
of
size
%
zu
failed
"
neededSize
)
;
mI420FrameSize
=
0
;
return
NS_ERROR_FAILURE
;
}
mI420FrameSize
=
neededSize
;
vpx_img_wrap
(
&
mVPXImageWrapper
VPX_IMG_FMT_I420
mFrameWidth
mFrameHeight
I420_STRIDE_ALIGN
mI420Frame
.
get
(
)
)
;
nsresult
rv
=
ConvertToI420
(
img
mVPXImageWrapper
.
planes
[
VPX_PLANE_Y
]
mVPXImageWrapper
.
stride
[
VPX_PLANE_Y
]
mVPXImageWrapper
.
planes
[
VPX_PLANE_U
]
mVPXImageWrapper
.
stride
[
VPX_PLANE_U
]
mVPXImageWrapper
.
planes
[
VPX_PLANE_V
]
mVPXImageWrapper
.
stride
[
VPX_PLANE_V
]
)
;
if
(
NS_FAILED
(
rv
)
)
{
VP8LOG
(
LogLevel
:
:
Error
"
Converting
to
I420
failed
"
)
;
return
rv
;
}
return
NS_OK
;
}
#
define
I_FRAME_RATIO
(
0
.
5
)
#
define
SKIP_FRAME_RATIO
(
0
.
75
)
VP8TrackEncoder
:
:
EncodeOperation
VP8TrackEncoder
:
:
GetNextEncodeOperation
(
TimeDuration
aTimeElapsed
TrackTime
aProcessedDuration
)
{
if
(
mFrameDroppingMode
=
=
FrameDroppingMode
:
:
DISALLOW
)
{
return
ENCODE_NORMAL_FRAME
;
}
int64_t
durationInUsec
=
FramesToUsecs
(
aProcessedDuration
mTrackRate
)
.
value
(
)
;
if
(
aTimeElapsed
.
ToMicroseconds
(
)
>
(
durationInUsec
*
SKIP_FRAME_RATIO
)
)
{
return
SKIP_FRAME
;
}
else
if
(
aTimeElapsed
.
ToMicroseconds
(
)
>
(
durationInUsec
*
I_FRAME_RATIO
)
)
{
return
ENCODE_I_FRAME
;
}
else
{
return
ENCODE_NORMAL_FRAME
;
}
}
nsresult
VP8TrackEncoder
:
:
GetEncodedTrack
(
nsTArray
<
RefPtr
<
EncodedFrame
>
>
&
aData
)
{
AUTO_PROFILER_LABEL
(
"
VP8TrackEncoder
:
:
GetEncodedTrack
"
OTHER
)
;
MOZ_ASSERT
(
mInitialized
|
|
mCanceled
)
;
if
(
mCanceled
|
|
mEncodingComplete
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mInitialized
)
{
return
NS_ERROR_FAILURE
;
}
TakeTrackData
(
mSourceSegment
)
;
TrackTime
totalProcessedDuration
=
0
;
TimeStamp
timebase
=
TimeStamp
:
:
Now
(
)
;
EncodeOperation
nextEncodeOperation
=
ENCODE_NORMAL_FRAME
;
for
(
VideoSegment
:
:
ChunkIterator
iter
(
mSourceSegment
)
;
!
iter
.
IsEnded
(
)
;
iter
.
Next
(
)
)
{
VideoChunk
&
chunk
=
*
iter
;
VP8LOG
(
LogLevel
:
:
Verbose
"
nextEncodeOperation
is
%
d
for
frame
of
duration
%
"
PRId64
nextEncodeOperation
chunk
.
GetDuration
(
)
)
;
if
(
nextEncodeOperation
!
=
SKIP_FRAME
)
{
nsresult
rv
=
PrepareRawFrame
(
chunk
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
int
flags
=
0
;
if
(
nextEncodeOperation
=
=
ENCODE_I_FRAME
)
{
VP8LOG
(
LogLevel
:
:
Warning
"
MediaRecorder
lagging
behind
.
Encoding
keyframe
.
"
)
;
flags
|
=
VPX_EFLAG_FORCE_KF
;
}
if
(
mKeyFrameInterval
>
0
)
{
if
(
(
mDurationSinceLastKeyframe
*
1000
/
mTrackRate
)
>
=
mKeyFrameInterval
)
{
mDurationSinceLastKeyframe
=
0
;
flags
|
=
VPX_EFLAG_FORCE_KF
;
}
mDurationSinceLastKeyframe
+
=
chunk
.
GetDuration
(
)
;
}
if
(
vpx_codec_encode
(
&
mVPXContext
&
mVPXImageWrapper
mEncodedTimestamp
(
unsigned
long
)
chunk
.
GetDuration
(
)
flags
VPX_DL_REALTIME
)
)
{
VP8LOG
(
LogLevel
:
:
Error
"
vpx_codec_encode
failed
to
encode
the
frame
.
"
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
GetEncodedPartitions
(
aData
)
;
if
(
rv
!
=
NS_OK
&
&
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
{
VP8LOG
(
LogLevel
:
:
Error
"
GetEncodedPartitions
failed
.
"
)
;
return
NS_ERROR_FAILURE
;
}
}
else
{
VP8LOG
(
LogLevel
:
:
Warning
"
MediaRecorder
lagging
behind
.
Skipping
a
frame
.
"
)
;
mExtractedDuration
+
=
chunk
.
mDuration
;
if
(
!
mExtractedDuration
.
isValid
(
)
)
{
NS_ERROR
(
"
skipped
duration
overflow
"
)
;
return
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
;
}
media
:
:
TimeUnit
totalDuration
=
FramesToTimeUnit
(
mExtractedDuration
.
value
(
)
mTrackRate
)
;
media
:
:
TimeUnit
skippedDuration
=
totalDuration
-
mExtractedDurationUs
;
mExtractedDurationUs
=
totalDuration
;
if
(
!
skippedDuration
.
IsValid
(
)
)
{
NS_ERROR
(
"
skipped
duration
overflow
"
)
;
return
NS_ERROR_DOM_MEDIA_OVERFLOW_ERR
;
}
{
auto
&
last
=
aData
.
LastElement
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aData
.
LastElement
(
)
)
;
uint64_t
longerDuration
=
last
-
>
mDuration
+
skippedDuration
.
ToMicroseconds
(
)
;
auto
longerFrame
=
MakeRefPtr
<
EncodedFrame
>
(
last
-
>
mTime
longerDuration
last
-
>
mDurationBase
last
-
>
mFrameType
last
-
>
mFrameData
)
;
std
:
:
swap
(
last
longerFrame
)
;
MOZ_ASSERT
(
last
-
>
mDuration
=
=
longerDuration
)
;
}
}
mEncodedTimestamp
+
=
chunk
.
GetDuration
(
)
;
totalProcessedDuration
+
=
chunk
.
GetDuration
(
)
;
TimeDuration
elapsedTime
=
TimeStamp
:
:
Now
(
)
-
timebase
;
nextEncodeOperation
=
GetNextEncodeOperation
(
elapsedTime
totalProcessedDuration
)
;
}
mSourceSegment
.
Clear
(
)
;
if
(
mEndOfStream
)
{
VP8LOG
(
LogLevel
:
:
Debug
"
mEndOfStream
is
true
"
)
;
mEncodingComplete
=
true
;
if
(
mI420Frame
)
{
mI420Frame
=
nullptr
;
mI420FrameSize
=
0
;
}
while
(
true
)
{
if
(
vpx_codec_encode
(
&
mVPXContext
nullptr
mEncodedTimestamp
0
0
VPX_DL_REALTIME
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
GetEncodedPartitions
(
aData
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
break
;
}
if
(
rv
!
=
NS_OK
)
{
return
NS_ERROR_FAILURE
;
}
}
}
return
NS_OK
;
}
}
#
undef
VP8LOG
