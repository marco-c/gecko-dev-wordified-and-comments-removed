#
include
"
OpusTrackEncoder
.
h
"
#
include
"
nsString
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
VideoUtils
.
h
"
#
include
<
opus
/
opus
.
h
>
#
define
LOG
(
args
.
.
.
)
namespace
mozilla
{
static
const
int
MAX_SUPPORTED_AUDIO_CHANNELS
=
8
;
static
const
int
MAX_CHANNELS
=
2
;
static
const
int
MAX_DATA_BYTES
=
4096
;
static
const
int
kOpusSamplingRate
=
48000
;
static
const
int
kFrameDurationMs
=
20
;
static
const
int
kOpusSupportedInputSamplingRates
[
]
=
{
8000
12000
16000
24000
48000
}
;
namespace
{
template
<
typename
T
>
static
void
SerializeToBuffer
(
T
aValue
nsTArray
<
uint8_t
>
*
aOutput
)
{
for
(
uint32_t
i
=
0
;
i
<
sizeof
(
T
)
;
i
+
+
)
{
aOutput
-
>
AppendElement
(
(
uint8_t
)
(
0x000000ff
&
(
aValue
>
>
(
i
*
8
)
)
)
)
;
}
}
static
inline
void
SerializeToBuffer
(
const
nsCString
&
aComment
nsTArray
<
uint8_t
>
*
aOutput
)
{
SerializeToBuffer
(
(
uint32_t
)
(
aComment
.
Length
(
)
)
aOutput
)
;
aOutput
-
>
AppendElements
(
aComment
.
get
(
)
aComment
.
Length
(
)
)
;
}
static
void
SerializeOpusIdHeader
(
uint8_t
aChannelCount
uint16_t
aPreskip
uint32_t
aInputSampleRate
nsTArray
<
uint8_t
>
*
aOutput
)
{
static
const
uint8_t
magic
[
]
=
"
OpusHead
"
;
aOutput
-
>
AppendElements
(
magic
sizeof
(
magic
)
-
1
)
;
aOutput
-
>
AppendElement
(
1
)
;
aOutput
-
>
AppendElement
(
aChannelCount
)
;
SerializeToBuffer
(
aPreskip
aOutput
)
;
SerializeToBuffer
(
aInputSampleRate
aOutput
)
;
SerializeToBuffer
(
(
int16_t
)
0
aOutput
)
;
aOutput
-
>
AppendElement
(
0
)
;
}
static
void
SerializeOpusCommentHeader
(
const
nsCString
&
aVendor
const
nsTArray
<
nsCString
>
&
aComments
nsTArray
<
uint8_t
>
*
aOutput
)
{
static
const
uint8_t
magic
[
]
=
"
OpusTags
"
;
aOutput
-
>
AppendElements
(
magic
sizeof
(
magic
)
-
1
)
;
SerializeToBuffer
(
aVendor
aOutput
)
;
SerializeToBuffer
(
(
uint32_t
)
aComments
.
Length
(
)
aOutput
)
;
for
(
uint32_t
i
=
0
;
i
<
aComments
.
Length
(
)
;
+
+
i
)
{
SerializeToBuffer
(
aComments
[
i
]
aOutput
)
;
}
}
}
OpusTrackEncoder
:
:
OpusTrackEncoder
(
TrackRate
aTrackRate
)
:
AudioTrackEncoder
(
aTrackRate
)
mEncoder
(
nullptr
)
mLookahead
(
0
)
mResampler
(
nullptr
)
mOutputTimeStamp
(
0
)
{
}
OpusTrackEncoder
:
:
~
OpusTrackEncoder
(
)
{
if
(
mEncoder
)
{
opus_encoder_destroy
(
mEncoder
)
;
}
if
(
mResampler
)
{
speex_resampler_destroy
(
mResampler
)
;
mResampler
=
nullptr
;
}
}
nsresult
OpusTrackEncoder
:
:
Init
(
int
aChannels
int
aSamplingRate
)
{
NS_ENSURE_TRUE
(
(
aChannels
<
=
MAX_SUPPORTED_AUDIO_CHANNELS
)
&
&
(
aChannels
>
0
)
NS_ERROR_FAILURE
)
;
mChannels
=
aChannels
>
MAX_CHANNELS
?
MAX_CHANNELS
:
aChannels
;
NS_ENSURE_TRUE
(
aSamplingRate
>
=
8000
NS_ERROR_INVALID_ARG
)
;
NS_ENSURE_TRUE
(
aSamplingRate
<
=
192000
NS_ERROR_INVALID_ARG
)
;
nsTArray
<
int
>
supportedSamplingRates
;
supportedSamplingRates
.
AppendElements
(
kOpusSupportedInputSamplingRates
ArrayLength
(
kOpusSupportedInputSamplingRates
)
)
;
if
(
!
supportedSamplingRates
.
Contains
(
aSamplingRate
)
)
{
int
error
;
mResampler
=
speex_resampler_init
(
mChannels
aSamplingRate
kOpusSamplingRate
SPEEX_RESAMPLER_QUALITY_DEFAULT
&
error
)
;
if
(
error
!
=
RESAMPLER_ERR_SUCCESS
)
{
return
NS_ERROR_FAILURE
;
}
}
mSamplingRate
=
aSamplingRate
;
NS_ENSURE_TRUE
(
mSamplingRate
>
0
NS_ERROR_FAILURE
)
;
int
error
=
0
;
mEncoder
=
opus_encoder_create
(
GetOutputSampleRate
(
)
mChannels
OPUS_APPLICATION_AUDIO
&
error
)
;
if
(
error
=
=
OPUS_OK
)
{
SetInitialized
(
)
;
}
if
(
mAudioBitrate
)
{
opus_encoder_ctl
(
mEncoder
OPUS_SET_BITRATE
(
static_cast
<
int
>
(
mAudioBitrate
)
)
)
;
}
return
error
=
=
OPUS_OK
?
NS_OK
:
NS_ERROR_FAILURE
;
}
int
OpusTrackEncoder
:
:
GetOutputSampleRate
(
)
{
return
mResampler
?
kOpusSamplingRate
:
mSamplingRate
;
}
int
OpusTrackEncoder
:
:
GetPacketDuration
(
)
{
return
GetOutputSampleRate
(
)
*
kFrameDurationMs
/
1000
;
}
already_AddRefed
<
TrackMetadataBase
>
OpusTrackEncoder
:
:
GetMetadata
(
)
{
AUTO_PROFILER_LABEL
(
"
OpusTrackEncoder
:
:
GetMetadata
"
OTHER
)
;
MOZ_ASSERT
(
mInitialized
|
|
mCanceled
)
;
if
(
mCanceled
|
|
mEncodingComplete
)
{
return
nullptr
;
}
if
(
!
mInitialized
)
{
return
nullptr
;
}
RefPtr
<
OpusMetadata
>
meta
=
new
OpusMetadata
(
)
;
meta
-
>
mChannels
=
mChannels
;
meta
-
>
mSamplingFrequency
=
mSamplingRate
;
mLookahead
=
0
;
int
error
=
opus_encoder_ctl
(
mEncoder
OPUS_GET_LOOKAHEAD
(
&
mLookahead
)
)
;
if
(
error
!
=
OPUS_OK
)
{
mLookahead
=
0
;
}
SerializeOpusIdHeader
(
mChannels
mLookahead
*
(
kOpusSamplingRate
/
GetOutputSampleRate
(
)
)
mSamplingRate
&
meta
-
>
mIdHeader
)
;
nsCString
vendor
;
vendor
.
AppendASCII
(
opus_get_version_string
(
)
)
;
nsTArray
<
nsCString
>
comments
;
comments
.
AppendElement
(
NS_LITERAL_CSTRING
(
"
ENCODER
=
Mozilla
"
MOZ_APP_UA_VERSION
)
)
;
SerializeOpusCommentHeader
(
vendor
comments
&
meta
-
>
mCommentHeader
)
;
return
meta
.
forget
(
)
;
}
nsresult
OpusTrackEncoder
:
:
GetEncodedTrack
(
nsTArray
<
RefPtr
<
EncodedFrame
>
>
&
aData
)
{
AUTO_PROFILER_LABEL
(
"
OpusTrackEncoder
:
:
GetEncodedTrack
"
OTHER
)
;
MOZ_ASSERT
(
mInitialized
|
|
mCanceled
)
;
if
(
mCanceled
|
|
mEncodingComplete
)
{
return
NS_ERROR_DOM_MEDIA_CANCELED
;
}
if
(
!
mInitialized
)
{
return
NS_ERROR_FAILURE
;
}
TakeTrackData
(
mSourceSegment
)
;
int
result
=
0
;
while
(
result
>
=
0
&
&
!
mEncodingComplete
)
{
const
int
framesLeft
=
mResampledLeftover
.
Length
(
)
/
mChannels
;
const
int
frameRoundUp
=
framesLeft
?
1
:
0
;
MOZ_ASSERT
(
GetPacketDuration
(
)
>
=
framesLeft
)
;
const
int
framesToFetch
=
!
mResampler
?
GetPacketDuration
(
)
:
(
GetPacketDuration
(
)
-
framesLeft
)
*
mSamplingRate
/
kOpusSamplingRate
+
frameRoundUp
;
if
(
!
mEndOfStream
&
&
mSourceSegment
.
GetDuration
(
)
<
framesToFetch
)
{
return
NS_OK
;
}
if
(
mEndOfStream
&
&
!
mEosSetInEncoder
)
{
mEosSetInEncoder
=
true
;
mSourceSegment
.
AppendNullData
(
mLookahead
)
;
}
AutoTArray
<
AudioDataValue
9600
>
pcm
;
pcm
.
SetLength
(
GetPacketDuration
(
)
*
mChannels
)
;
int
frameCopied
=
0
;
for
(
AudioSegment
:
:
ChunkIterator
iter
(
mSourceSegment
)
;
!
iter
.
IsEnded
(
)
&
&
frameCopied
<
framesToFetch
;
iter
.
Next
(
)
)
{
AudioChunk
chunk
=
*
iter
;
TrackTime
frameToCopy
=
chunk
.
GetDuration
(
)
;
if
(
frameToCopy
>
framesToFetch
-
frameCopied
)
{
frameToCopy
=
framesToFetch
-
frameCopied
;
}
MOZ_ASSERT
(
frameToCopy
<
=
3844
"
frameToCopy
exceeded
expected
range
"
)
;
if
(
!
chunk
.
IsNull
(
)
)
{
AudioTrackEncoder
:
:
InterleaveTrackData
(
chunk
frameToCopy
mChannels
pcm
.
Elements
(
)
+
frameCopied
*
mChannels
)
;
}
else
{
CheckedInt
<
int
>
memsetLength
=
CheckedInt
<
int
>
(
frameToCopy
)
*
mChannels
*
sizeof
(
AudioDataValue
)
;
if
(
!
memsetLength
.
isValid
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
memsetLength
invalid
!
"
)
;
return
NS_ERROR_FAILURE
;
}
memset
(
pcm
.
Elements
(
)
+
frameCopied
*
mChannels
0
memsetLength
.
value
(
)
)
;
}
frameCopied
+
=
frameToCopy
;
}
MOZ_ASSERT
(
frameCopied
<
=
3844
"
frameCopied
exceeded
expected
range
"
)
;
RefPtr
<
EncodedFrame
>
audiodata
=
new
EncodedFrame
(
)
;
audiodata
-
>
mFrameType
=
EncodedFrame
:
:
OPUS_AUDIO_FRAME
;
int
framesInPCM
=
frameCopied
;
if
(
mResampler
)
{
AutoTArray
<
AudioDataValue
9600
>
resamplingDest
;
uint32_t
outframes
=
frameCopied
*
kOpusSamplingRate
/
mSamplingRate
+
1
;
uint32_t
inframes
=
frameCopied
;
resamplingDest
.
SetLength
(
outframes
*
mChannels
)
;
#
if
MOZ_SAMPLE_TYPE_S16
short
*
in
=
reinterpret_cast
<
short
*
>
(
pcm
.
Elements
(
)
)
;
short
*
out
=
reinterpret_cast
<
short
*
>
(
resamplingDest
.
Elements
(
)
)
;
speex_resampler_process_interleaved_int
(
mResampler
in
&
inframes
out
&
outframes
)
;
#
else
float
*
in
=
reinterpret_cast
<
float
*
>
(
pcm
.
Elements
(
)
)
;
float
*
out
=
reinterpret_cast
<
float
*
>
(
resamplingDest
.
Elements
(
)
)
;
speex_resampler_process_interleaved_float
(
mResampler
in
&
inframes
out
&
outframes
)
;
#
endif
MOZ_ASSERT
(
pcm
.
Length
(
)
>
=
mResampledLeftover
.
Length
(
)
)
;
PodCopy
(
pcm
.
Elements
(
)
mResampledLeftover
.
Elements
(
)
mResampledLeftover
.
Length
(
)
)
;
uint32_t
outframesToCopy
=
std
:
:
min
(
outframes
static_cast
<
uint32_t
>
(
GetPacketDuration
(
)
-
framesLeft
)
)
;
MOZ_ASSERT
(
pcm
.
Length
(
)
-
mResampledLeftover
.
Length
(
)
>
=
outframesToCopy
*
mChannels
)
;
PodCopy
(
pcm
.
Elements
(
)
+
mResampledLeftover
.
Length
(
)
resamplingDest
.
Elements
(
)
outframesToCopy
*
mChannels
)
;
int
frameLeftover
=
outframes
-
outframesToCopy
;
mResampledLeftover
.
SetLength
(
frameLeftover
*
mChannels
)
;
PodCopy
(
mResampledLeftover
.
Elements
(
)
resamplingDest
.
Elements
(
)
+
outframesToCopy
*
mChannels
mResampledLeftover
.
Length
(
)
)
;
framesInPCM
=
framesLeft
+
outframesToCopy
;
audiodata
-
>
mDuration
=
framesInPCM
;
}
else
{
audiodata
-
>
mDuration
=
frameCopied
*
(
kOpusSamplingRate
/
mSamplingRate
)
;
}
mSourceSegment
.
RemoveLeading
(
frameCopied
)
;
if
(
mSourceSegment
.
GetDuration
(
)
=
=
0
&
&
mEosSetInEncoder
)
{
mEncodingComplete
=
true
;
LOG
(
"
[
Opus
]
Done
encoding
.
"
)
;
}
MOZ_ASSERT
(
mEosSetInEncoder
|
|
framesInPCM
=
=
GetPacketDuration
(
)
)
;
if
(
framesInPCM
<
GetPacketDuration
(
)
&
&
mEosSetInEncoder
)
{
PodZero
(
pcm
.
Elements
(
)
+
framesInPCM
*
mChannels
(
GetPacketDuration
(
)
-
framesInPCM
)
*
mChannels
)
;
}
nsTArray
<
uint8_t
>
frameData
;
frameData
.
SetLength
(
MAX_DATA_BYTES
)
;
result
=
0
;
#
ifdef
MOZ_SAMPLE_TYPE_S16
const
opus_int16
*
pcmBuf
=
static_cast
<
opus_int16
*
>
(
pcm
.
Elements
(
)
)
;
result
=
opus_encode
(
mEncoder
pcmBuf
GetPacketDuration
(
)
frameData
.
Elements
(
)
MAX_DATA_BYTES
)
;
#
else
const
float
*
pcmBuf
=
static_cast
<
float
*
>
(
pcm
.
Elements
(
)
)
;
result
=
opus_encode_float
(
mEncoder
pcmBuf
GetPacketDuration
(
)
frameData
.
Elements
(
)
MAX_DATA_BYTES
)
;
#
endif
frameData
.
SetLength
(
result
>
=
0
?
result
:
0
)
;
if
(
result
<
0
)
{
LOG
(
"
[
Opus
]
Fail
to
encode
data
!
Result
:
%
s
.
"
opus_strerror
(
result
)
)
;
}
if
(
mEncodingComplete
)
{
if
(
mResampler
)
{
speex_resampler_destroy
(
mResampler
)
;
mResampler
=
nullptr
;
}
mResampledLeftover
.
SetLength
(
0
)
;
}
audiodata
-
>
SwapInFrameData
(
frameData
)
;
audiodata
-
>
mTime
=
mOutputTimeStamp
;
mOutputTimeStamp
+
=
FramesToUsecs
(
GetPacketDuration
(
)
kOpusSamplingRate
)
.
value
(
)
;
LOG
(
"
[
Opus
]
mOutputTimeStamp
%
lld
.
"
mOutputTimeStamp
)
;
aData
.
AppendElement
(
audiodata
)
;
}
return
result
>
=
0
?
NS_OK
:
NS_ERROR_FAILURE
;
}
}
#
undef
LOG
