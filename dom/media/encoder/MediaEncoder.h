#
ifndef
MediaEncoder_h_
#
define
MediaEncoder_h_
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
TrackEncoder
.
h
"
#
include
"
ContainerWriter
.
h
"
#
include
"
CubebUtils
.
h
"
#
include
"
MediaStreamGraph
.
h
"
#
include
"
MediaStreamListener
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
MediaStreamVideoSink
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
namespace
mozilla
{
class
MediaStreamVideoRecorderSink
:
public
MediaStreamVideoSink
{
public
:
explicit
MediaStreamVideoRecorderSink
(
VideoTrackEncoder
*
aEncoder
)
:
mVideoEncoder
(
aEncoder
)
{
}
virtual
void
SetCurrentFrames
(
const
VideoSegment
&
aSegment
)
override
;
virtual
void
ClearFrames
(
)
override
{
}
private
:
virtual
~
MediaStreamVideoRecorderSink
(
)
{
}
VideoTrackEncoder
*
mVideoEncoder
;
}
;
class
MediaEncoder
:
public
DirectMediaStreamListener
{
friend
class
MediaStreamVideoRecorderSink
;
public
:
enum
{
ENCODE_METADDATA
ENCODE_TRACK
ENCODE_DONE
ENCODE_ERROR
}
;
MediaEncoder
(
ContainerWriter
*
aWriter
AudioTrackEncoder
*
aAudioEncoder
VideoTrackEncoder
*
aVideoEncoder
const
nsAString
&
aMIMEType
uint32_t
aAudioBitrate
uint32_t
aVideoBitrate
uint32_t
aBitrate
)
:
mWriter
(
aWriter
)
mAudioEncoder
(
aAudioEncoder
)
mVideoEncoder
(
aVideoEncoder
)
mVideoSink
(
new
MediaStreamVideoRecorderSink
(
mVideoEncoder
)
)
mStartTime
(
TimeStamp
:
:
Now
(
)
)
mMIMEType
(
aMIMEType
)
mSizeOfBuffer
(
0
)
mState
(
MediaEncoder
:
:
ENCODE_METADDATA
)
mShutdown
(
false
)
mDirectConnected
(
false
)
mSuspended
(
false
)
{
}
~
MediaEncoder
(
)
{
}
;
enum
SuspendState
{
RECORD_NOT_SUSPENDED
RECORD_SUSPENDED
RECORD_RESUMED
}
;
void
Suspend
(
)
{
mSuspended
=
RECORD_SUSPENDED
;
}
void
Resume
(
)
{
if
(
mSuspended
=
=
RECORD_SUSPENDED
)
{
mSuspended
=
RECORD_RESUMED
;
}
}
void
SetDirectConnect
(
bool
aConnected
)
;
void
NotifyRealtimeData
(
MediaStreamGraph
*
aGraph
TrackID
aID
StreamTime
aTrackOffset
uint32_t
aTrackEvents
const
MediaSegment
&
aRealtimeMedia
)
override
;
void
NotifyQueuedTrackChanges
(
MediaStreamGraph
*
aGraph
TrackID
aID
StreamTime
aTrackOffset
TrackEventCommand
aTrackEvents
const
MediaSegment
&
aQueuedMedia
MediaStream
*
aInputStream
TrackID
aInputTrackID
)
override
;
void
NotifyQueuedAudioData
(
MediaStreamGraph
*
aGraph
TrackID
aID
StreamTime
aTrackOffset
const
AudioSegment
&
aQueuedMedia
MediaStream
*
aInputStream
TrackID
aInputTrackID
)
override
;
void
NotifyEvent
(
MediaStreamGraph
*
aGraph
MediaStreamGraphEvent
event
)
override
;
static
already_AddRefed
<
MediaEncoder
>
CreateEncoder
(
const
nsAString
&
aMIMEType
uint32_t
aAudioBitrate
uint32_t
aVideoBitrate
uint32_t
aBitrate
uint8_t
aTrackTypes
=
ContainerWriter
:
:
CREATE_AUDIO_TRACK
TrackRate
aTrackRate
=
CubebUtils
:
:
PreferredSampleRate
(
)
)
;
void
GetEncodedData
(
nsTArray
<
nsTArray
<
uint8_t
>
>
*
aOutputBufs
nsAString
&
aMIMEType
)
;
bool
IsShutdown
(
)
{
return
mShutdown
;
}
void
Cancel
(
)
{
if
(
mAudioEncoder
)
{
mAudioEncoder
-
>
NotifyCancel
(
)
;
}
if
(
mVideoEncoder
)
{
mVideoEncoder
-
>
NotifyCancel
(
)
;
}
}
bool
HasError
(
)
{
return
mState
=
=
ENCODE_ERROR
;
}
#
ifdef
MOZ_WEBM_ENCODER
static
bool
IsWebMEncoderEnabled
(
)
;
#
endif
MOZ_DEFINE_MALLOC_SIZE_OF
(
MallocSizeOf
)
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
MediaStreamVideoRecorderSink
*
GetVideoSink
(
)
{
return
mVideoSink
.
get
(
)
;
}
private
:
nsresult
WriteEncodedDataToMuxer
(
TrackEncoder
*
aTrackEncoder
)
;
nsresult
CopyMetadataToMuxer
(
TrackEncoder
*
aTrackEncoder
)
;
nsAutoPtr
<
ContainerWriter
>
mWriter
;
nsAutoPtr
<
AudioTrackEncoder
>
mAudioEncoder
;
nsAutoPtr
<
VideoTrackEncoder
>
mVideoEncoder
;
RefPtr
<
MediaStreamVideoRecorderSink
>
mVideoSink
;
TimeStamp
mStartTime
;
nsString
mMIMEType
;
int64_t
mSizeOfBuffer
;
int
mState
;
bool
mShutdown
;
bool
mDirectConnected
;
Atomic
<
int
>
mSuspended
;
double
GetEncodeTimeStamp
(
)
{
TimeDuration
decodeTime
;
decodeTime
=
TimeStamp
:
:
Now
(
)
-
mStartTime
;
return
decodeTime
.
ToMilliseconds
(
)
;
}
}
;
}
#
endif
