#
include
"
MediaStatusManager
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
MediaControlUtils
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
nsIChromeRegistry
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIXULAppInfo
.
h
"
#
ifdef
MOZ_PLACES
#
include
"
nsIFaviconService
.
h
"
#
endif
extern
mozilla
:
:
LazyLogModule
gMediaControlLog
;
#
undef
LOG
#
define
LOG
(
msg
.
.
.
)
\
MOZ_LOG
(
gMediaControlLog
LogLevel
:
:
Debug
\
(
"
MediaStatusManager
=
%
p
"
msg
this
#
#
__VA_ARGS__
)
)
namespace
mozilla
{
namespace
dom
{
static
bool
IsMetadataEmpty
(
const
Maybe
<
MediaMetadataBase
>
&
aMetadata
)
{
if
(
!
aMetadata
)
{
return
true
;
}
const
MediaMetadataBase
&
metadata
=
*
aMetadata
;
return
metadata
.
mTitle
.
IsEmpty
(
)
&
&
metadata
.
mArtist
.
IsEmpty
(
)
&
&
metadata
.
mAlbum
.
IsEmpty
(
)
&
&
metadata
.
mArtwork
.
IsEmpty
(
)
;
}
MediaStatusManager
:
:
MediaStatusManager
(
uint64_t
aBrowsingContextId
)
:
mTopLevelBrowsingContextId
(
aBrowsingContextId
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
"
MediaStatusManager
only
runs
on
Chrome
process
!
"
)
;
}
void
MediaStatusManager
:
:
NotifyMediaAudibleChanged
(
uint64_t
aBrowsingContextId
MediaAudibleState
aState
)
{
mPlaybackStatusDelegate
.
UpdateMediaAudibleState
(
aBrowsingContextId
aState
)
;
}
void
MediaStatusManager
:
:
NotifySessionCreated
(
uint64_t
aBrowsingContextId
)
{
if
(
mMediaSessionInfoMap
.
Contains
(
aBrowsingContextId
)
)
{
return
;
}
LOG
(
"
Session
%
"
PRId64
"
has
been
created
"
aBrowsingContextId
)
;
mMediaSessionInfoMap
.
Put
(
aBrowsingContextId
MediaSessionInfo
:
:
EmptyInfo
(
)
)
;
UpdateActiveMediaSessionContextId
(
)
;
}
void
MediaStatusManager
:
:
NotifySessionDestroyed
(
uint64_t
aBrowsingContextId
)
{
if
(
!
mMediaSessionInfoMap
.
Contains
(
aBrowsingContextId
)
)
{
return
;
}
LOG
(
"
Session
%
"
PRId64
"
has
been
destroyed
"
aBrowsingContextId
)
;
mMediaSessionInfoMap
.
Remove
(
aBrowsingContextId
)
;
UpdateActiveMediaSessionContextId
(
)
;
}
void
MediaStatusManager
:
:
UpdateMetadata
(
uint64_t
aBrowsingContextId
const
Maybe
<
MediaMetadataBase
>
&
aMetadata
)
{
if
(
!
mMediaSessionInfoMap
.
Contains
(
aBrowsingContextId
)
)
{
return
;
}
MediaSessionInfo
*
info
=
mMediaSessionInfoMap
.
GetValue
(
aBrowsingContextId
)
;
if
(
IsMetadataEmpty
(
aMetadata
)
)
{
LOG
(
"
Reset
metadata
for
session
%
"
PRId64
aBrowsingContextId
)
;
info
-
>
mMetadata
.
reset
(
)
;
}
else
{
LOG
(
"
Update
metadata
for
session
%
"
PRId64
"
title
=
%
s
artist
=
%
s
album
=
%
s
"
aBrowsingContextId
NS_ConvertUTF16toUTF8
(
(
*
aMetadata
)
.
mTitle
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aMetadata
-
>
mArtist
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aMetadata
-
>
mAlbum
)
.
get
(
)
)
;
info
-
>
mMetadata
=
aMetadata
;
}
mMetadataChangedEvent
.
Notify
(
GetCurrentMediaMetadata
(
)
)
;
if
(
StaticPrefs
:
:
media_mediacontrol_testingevents_enabled
(
)
)
{
if
(
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
)
{
obs
-
>
NotifyObservers
(
nullptr
"
media
-
session
-
controller
-
metadata
-
changed
"
nullptr
)
;
}
}
}
void
MediaStatusManager
:
:
UpdateActiveMediaSessionContextId
(
)
{
uint64_t
candidateId
=
0
;
if
(
mActiveMediaSessionContextId
&
&
mMediaSessionInfoMap
.
Contains
(
*
mActiveMediaSessionContextId
)
)
{
candidateId
=
*
mActiveMediaSessionContextId
;
}
for
(
auto
iter
=
mMediaSessionInfoMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
BrowsingContext
>
bc
=
BrowsingContext
:
:
Get
(
iter
.
Key
(
)
)
;
if
(
!
bc
)
{
iter
.
Remove
(
)
;
continue
;
}
if
(
bc
-
>
IsTopContent
(
)
)
{
candidateId
=
iter
.
Key
(
)
;
break
;
}
if
(
!
candidateId
)
{
candidateId
=
iter
.
Key
(
)
;
}
}
if
(
mActiveMediaSessionContextId
&
&
*
mActiveMediaSessionContextId
=
=
candidateId
)
{
LOG
(
"
Active
session
%
"
PRId64
"
keeps
unchanged
"
*
mActiveMediaSessionContextId
)
;
return
;
}
mActiveMediaSessionContextId
=
Some
(
candidateId
)
;
LOG
(
"
Session
%
"
PRId64
"
becomes
active
session
"
*
mActiveMediaSessionContextId
)
;
}
MediaMetadataBase
MediaStatusManager
:
:
CreateDefaultMetadata
(
)
const
{
MediaMetadataBase
metadata
;
metadata
.
mTitle
=
GetDefaultTitle
(
)
;
metadata
.
mArtwork
.
AppendElement
(
)
-
>
mSrc
=
GetDefaultFaviconURL
(
)
;
LOG
(
"
Default
media
metadata
title
=
%
s
album
src
=
%
s
"
NS_ConvertUTF16toUTF8
(
metadata
.
mTitle
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
metadata
.
mArtwork
[
0
]
.
mSrc
)
.
get
(
)
)
;
return
metadata
;
}
nsString
MediaStatusManager
:
:
GetDefaultTitle
(
)
const
{
RefPtr
<
CanonicalBrowsingContext
>
bc
=
CanonicalBrowsingContext
:
:
Get
(
mTopLevelBrowsingContextId
)
;
if
(
!
bc
)
{
return
EmptyString
(
)
;
}
RefPtr
<
WindowGlobalParent
>
globalParent
=
bc
-
>
GetCurrentWindowGlobal
(
)
;
if
(
!
globalParent
)
{
return
EmptyString
(
)
;
}
nsString
defaultTitle
;
if
(
IsInPrivateBrowsing
(
)
)
{
if
(
nsCOMPtr
<
nsIXULAppInfo
>
appInfo
=
do_GetService
(
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
)
)
{
nsCString
appName
;
appInfo
-
>
GetName
(
appName
)
;
CopyUTF8toUTF16
(
appName
defaultTitle
)
;
}
else
{
defaultTitle
.
AssignLiteral
(
"
Firefox
"
)
;
}
defaultTitle
.
AppendLiteral
(
"
is
playing
media
"
)
;
}
else
{
globalParent
-
>
GetDocumentTitle
(
defaultTitle
)
;
}
return
defaultTitle
;
}
nsString
MediaStatusManager
:
:
GetDefaultFaviconURL
(
)
const
{
#
ifdef
MOZ_PLACES
nsCOMPtr
<
nsIURI
>
faviconURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
faviconURI
)
NS_LITERAL_CSTRING
(
FAVICON_DEFAULT_URL
)
)
;
NS_ENSURE_SUCCESS
(
rv
NS_LITERAL_STRING
(
"
"
)
)
;
nsCOMPtr
<
nsIChromeRegistry
>
regService
=
services
:
:
GetChromeRegistryService
(
)
;
if
(
!
regService
)
{
return
EmptyString
(
)
;
}
nsCOMPtr
<
nsIURI
>
processedURI
;
regService
-
>
ConvertChromeURL
(
faviconURI
getter_AddRefs
(
processedURI
)
)
;
nsAutoCString
spec
;
if
(
NS_FAILED
(
processedURI
-
>
GetSpec
(
spec
)
)
)
{
return
EmptyString
(
)
;
}
return
NS_ConvertUTF8toUTF16
(
spec
)
;
#
endif
return
EmptyString
(
)
;
}
void
MediaStatusManager
:
:
SetDeclaredPlaybackState
(
uint64_t
aBrowsingContextId
MediaSessionPlaybackState
aState
)
{
if
(
!
mMediaSessionInfoMap
.
Contains
(
aBrowsingContextId
)
)
{
return
;
}
MediaSessionInfo
*
info
=
mMediaSessionInfoMap
.
GetValue
(
aBrowsingContextId
)
;
LOG
(
"
SetDeclaredPlaybackState
from
%
s
to
%
s
"
ToMediaSessionPlaybackStateStr
(
info
-
>
mDeclaredPlaybackState
)
ToMediaSessionPlaybackStateStr
(
aState
)
)
;
info
-
>
mDeclaredPlaybackState
=
aState
;
UpdateActualPlaybackState
(
)
;
}
MediaSessionPlaybackState
MediaStatusManager
:
:
GetCurrentDeclaredPlaybackState
(
)
const
{
if
(
!
mActiveMediaSessionContextId
)
{
return
MediaSessionPlaybackState
:
:
None
;
}
return
mMediaSessionInfoMap
.
Get
(
*
mActiveMediaSessionContextId
)
.
mDeclaredPlaybackState
;
}
void
MediaStatusManager
:
:
NotifyMediaPlaybackChanged
(
uint64_t
aBrowsingContextId
MediaPlaybackState
aState
)
{
LOG
(
"
UpdateMediaPlaybackState
%
s
for
context
%
"
PRId64
ToMediaPlaybackStateStr
(
aState
)
aBrowsingContextId
)
;
const
bool
oldPlaying
=
mPlaybackStatusDelegate
.
IsPlaying
(
)
;
mPlaybackStatusDelegate
.
UpdateMediaPlaybackState
(
aBrowsingContextId
aState
)
;
if
(
mPlaybackStatusDelegate
.
IsPlaying
(
)
=
=
oldPlaying
)
{
return
;
}
if
(
mPlaybackStatusDelegate
.
IsPlaying
(
)
)
{
SetGuessedPlayState
(
MediaSessionPlaybackState
:
:
Playing
)
;
}
else
{
SetGuessedPlayState
(
MediaSessionPlaybackState
:
:
Paused
)
;
}
}
void
MediaStatusManager
:
:
SetGuessedPlayState
(
MediaSessionPlaybackState
aState
)
{
if
(
aState
=
=
mGuessedPlaybackState
)
{
return
;
}
LOG
(
"
SetGuessedPlayState
:
'
%
s
'
"
ToMediaSessionPlaybackStateStr
(
aState
)
)
;
mGuessedPlaybackState
=
aState
;
UpdateActualPlaybackState
(
)
;
}
void
MediaStatusManager
:
:
UpdateActualPlaybackState
(
)
{
MediaSessionPlaybackState
newState
=
GetCurrentDeclaredPlaybackState
(
)
=
=
MediaSessionPlaybackState
:
:
Playing
?
MediaSessionPlaybackState
:
:
Playing
:
mGuessedPlaybackState
;
if
(
mActualPlaybackState
=
=
newState
)
{
return
;
}
mActualPlaybackState
=
newState
;
LOG
(
"
UpdateActualPlaybackState
:
'
%
s
'
"
ToMediaSessionPlaybackStateStr
(
mActualPlaybackState
)
)
;
HandleActualPlaybackStateChanged
(
)
;
}
MediaMetadataBase
MediaStatusManager
:
:
GetCurrentMediaMetadata
(
)
const
{
if
(
mActiveMediaSessionContextId
&
&
!
IsInPrivateBrowsing
(
)
)
{
MediaSessionInfo
info
=
mMediaSessionInfoMap
.
Get
(
*
mActiveMediaSessionContextId
)
;
if
(
!
info
.
mMetadata
)
{
return
CreateDefaultMetadata
(
)
;
}
MediaMetadataBase
&
metadata
=
*
(
info
.
mMetadata
)
;
FillMissingTitleAndArtworkIfNeeded
(
metadata
)
;
return
metadata
;
}
return
CreateDefaultMetadata
(
)
;
}
void
MediaStatusManager
:
:
FillMissingTitleAndArtworkIfNeeded
(
MediaMetadataBase
&
aMetadata
)
const
{
if
(
aMetadata
.
mTitle
.
IsEmpty
(
)
)
{
aMetadata
.
mTitle
=
GetDefaultTitle
(
)
;
}
if
(
aMetadata
.
mArtwork
.
IsEmpty
(
)
)
{
aMetadata
.
mArtwork
.
AppendElement
(
)
-
>
mSrc
=
GetDefaultFaviconURL
(
)
;
}
}
bool
MediaStatusManager
:
:
IsInPrivateBrowsing
(
)
const
{
RefPtr
<
CanonicalBrowsingContext
>
bc
=
CanonicalBrowsingContext
:
:
Get
(
mTopLevelBrowsingContextId
)
;
if
(
!
bc
)
{
return
false
;
}
RefPtr
<
Element
>
element
=
bc
-
>
GetEmbedderElement
(
)
;
if
(
!
element
)
{
return
false
;
}
return
nsContentUtils
:
:
IsInPrivateBrowsing
(
element
-
>
OwnerDoc
(
)
)
;
}
MediaSessionPlaybackState
MediaStatusManager
:
:
GetState
(
)
const
{
return
mActualPlaybackState
;
}
bool
MediaStatusManager
:
:
IsMediaAudible
(
)
const
{
return
mPlaybackStatusDelegate
.
IsAudible
(
)
;
}
bool
MediaStatusManager
:
:
IsMediaPlaying
(
)
const
{
return
mActualPlaybackState
=
=
MediaSessionPlaybackState
:
:
Playing
;
}
bool
MediaStatusManager
:
:
IsAnyMediaBeingControlled
(
)
const
{
return
mPlaybackStatusDelegate
.
IsAnyMediaBeingControlled
(
)
;
}
}
}
