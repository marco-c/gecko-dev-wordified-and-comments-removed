async
function
createTabAndLoad
(
url
inputWindow
=
null
)
{
const
browser
=
inputWindow
?
inputWindow
.
gBrowser
:
window
.
gBrowser
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
browser
url
)
;
return
tab
;
}
function
generateMediaControlKeyEvent
(
event
)
{
const
playbackStateChanged
=
waitUntilDisplayedPlaybackChanged
(
)
;
ChromeUtils
.
generateMediaControlKey
(
event
)
;
return
playbackStateChanged
;
}
function
playMedia
(
tab
elementId
)
{
const
playPromise
=
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
Id
=
>
{
const
video
=
content
.
document
.
getElementById
(
Id
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
return
video
.
play
(
)
;
}
)
;
return
Promise
.
all
(
[
playPromise
waitUntilDisplayedPlaybackChanged
(
)
]
)
;
}
function
pauseMedia
(
tab
elementId
)
{
const
pausePromise
=
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
Id
=
>
{
const
video
=
content
.
document
.
getElementById
(
Id
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
ok
(
!
video
.
paused
video
is
playing
before
calling
pause
)
;
video
.
pause
(
)
;
}
)
;
return
Promise
.
all
(
[
pausePromise
waitUntilDisplayedPlaybackChanged
(
)
]
)
;
}
function
checkOrWaitUntilMediaStartedPlaying
(
tab
elementId
)
{
return
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
Id
=
>
{
return
new
Promise
(
resolve
=
>
{
const
video
=
content
.
document
.
getElementById
(
Id
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
if
(
!
video
.
paused
)
{
ok
(
true
media
started
playing
)
;
resolve
(
)
;
}
else
{
info
(
wait
until
media
starts
playing
)
;
video
.
onplaying
=
(
)
=
>
{
video
.
onplaying
=
null
;
ok
(
true
media
started
playing
)
;
resolve
(
)
;
}
;
}
}
)
;
}
)
;
}
function
checkOrWaitUntilMediaStoppedPlaying
(
tab
elementId
)
{
return
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
Id
=
>
{
return
new
Promise
(
resolve
=
>
{
const
video
=
content
.
document
.
getElementById
(
Id
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
if
(
video
.
paused
)
{
ok
(
true
media
stopped
playing
)
;
resolve
(
)
;
}
else
{
info
(
wait
until
media
stops
playing
)
;
video
.
onpause
=
(
)
=
>
{
video
.
onpause
=
null
;
ok
(
true
media
stopped
playing
)
;
resolve
(
)
;
}
;
}
}
)
;
}
)
;
}
function
isCurrentMetadataEmpty
(
)
{
const
current
=
ChromeUtils
.
getCurrentActiveMediaMetadata
(
)
;
is
(
current
.
title
"
"
current
title
should
be
empty
)
;
is
(
current
.
artist
"
"
current
title
should
be
empty
)
;
is
(
current
.
album
"
"
current
album
should
be
empty
)
;
is
(
current
.
artwork
.
length
0
current
artwork
should
be
empty
)
;
}
function
isCurrentMetadataEqualTo
(
metadata
)
{
const
current
=
ChromeUtils
.
getCurrentActiveMediaMetadata
(
)
;
is
(
current
.
title
metadata
.
title
tile
'
{
current
.
title
}
'
is
equal
to
{
metadata
.
title
}
)
;
is
(
current
.
artist
metadata
.
artist
artist
'
{
current
.
artist
}
'
is
equal
to
{
metadata
.
artist
}
)
;
is
(
current
.
album
metadata
.
album
album
'
{
current
.
album
}
'
is
equal
to
{
metadata
.
album
}
)
;
is
(
current
.
artwork
.
length
metadata
.
artwork
.
length
artwork
length
'
{
current
.
artwork
.
length
}
'
is
equal
to
{
metadata
.
artwork
.
length
}
)
;
for
(
let
idx
=
0
;
idx
<
metadata
.
artwork
.
length
;
idx
+
+
)
{
ok
(
current
.
artwork
[
idx
]
.
src
.
includes
(
metadata
.
artwork
[
idx
]
.
src
)
artwork
src
'
{
current
.
artwork
[
idx
]
.
src
}
'
includes
{
metadata
.
artwork
[
idx
]
.
src
}
)
;
is
(
current
.
artwork
[
idx
]
.
sizes
metadata
.
artwork
[
idx
]
.
sizes
artwork
sizes
'
{
current
.
artwork
[
idx
]
.
sizes
}
'
is
equal
to
{
metadata
.
artwork
[
idx
]
.
sizes
}
)
;
is
(
current
.
artwork
[
idx
]
.
type
metadata
.
artwork
[
idx
]
.
type
artwork
type
'
{
current
.
artwork
[
idx
]
.
type
}
'
is
equal
to
{
metadata
.
artwork
[
idx
]
.
type
}
)
;
}
}
async
function
isUsingDefaultMetadata
(
tab
options
=
{
}
)
{
let
metadata
=
ChromeUtils
.
getCurrentActiveMediaMetadata
(
)
;
if
(
options
.
isPrivateBrowsing
)
{
is
(
metadata
.
title
"
Firefox
is
playing
media
"
"
Using
generic
title
to
not
expose
sensitive
information
"
)
;
}
else
{
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
metadata
.
title
]
title
=
>
{
is
(
title
content
.
document
.
title
"
Using
website
title
as
a
default
title
"
)
;
}
)
;
}
is
(
metadata
.
artwork
.
length
1
"
Default
metada
contains
one
artwork
"
)
;
ok
(
metadata
.
artwork
[
0
]
.
src
.
includes
(
"
defaultFavicon
.
svg
"
)
"
Using
default
favicon
as
a
default
art
work
"
)
;
}
function
waitUntilDisplayedPlaybackChanged
(
)
{
return
BrowserUtils
.
promiseObserved
(
"
media
-
displayed
-
playback
-
changed
"
)
;
}
function
waitUntilDisplayedMetadataChanged
(
)
{
return
BrowserUtils
.
promiseObserved
(
"
media
-
displayed
-
metadata
-
changed
"
)
;
}
function
waitUntilMainMediaControllerChanged
(
)
{
return
BrowserUtils
.
promiseObserved
(
"
main
-
media
-
controller
-
changed
"
)
;
}
function
waitUntilControllerMetadataChanged
(
)
{
return
BrowserUtils
.
promiseObserved
(
"
media
-
session
-
controller
-
metadata
-
changed
"
)
;
}
function
waitUntilMediaControllerAmountChanged
(
)
{
return
BrowserUtils
.
promiseObserved
(
"
media
-
controller
-
amount
-
changed
"
)
;
}
async
function
checkOrWaitUntilControllerBecomeActive
(
tab
)
{
const
controller
=
tab
.
linkedBrowser
.
browsingContext
.
mediaController
;
if
(
controller
.
isActive
)
{
return
;
}
await
new
Promise
(
r
=
>
(
controller
.
onactivated
=
r
)
)
;
}
