async
function
createTabAndLoad
(
url
inputWindow
=
null
)
{
const
browser
=
inputWindow
?
inputWindow
.
gBrowser
:
window
.
gBrowser
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
browser
url
)
;
return
tab
;
}
async
function
createLoadedTabWrapper
(
url
{
inputWindow
=
window
needCheck
=
true
}
=
{
}
)
{
class
tabWrapper
{
constructor
(
tab
needCheck
)
{
this
.
_tab
=
tab
;
this
.
_controller
=
tab
.
linkedBrowser
.
browsingContext
.
mediaController
;
this
.
_firstEvent
=
"
"
;
this
.
_lastEvent
=
"
"
;
this
.
_events
=
[
"
activated
"
"
deactivated
"
"
metadatachange
"
"
playbackstatechange
"
"
positionstatechange
"
"
supportedkeyschange
"
]
;
this
.
_needCheck
=
needCheck
;
if
(
this
.
_needCheck
)
{
this
.
_registerAllEvents
(
)
;
}
}
_registerAllEvents
(
)
{
for
(
let
event
of
this
.
_events
)
{
this
.
_controller
.
addEventListener
(
event
this
.
_handleEvent
.
bind
(
this
)
)
;
}
}
_unregisterAllEvents
(
)
{
for
(
let
event
of
this
.
_events
)
{
this
.
_controller
.
removeEventListener
(
event
this
.
_handleEvent
.
bind
(
this
)
)
;
}
}
_handleEvent
(
event
)
{
info
(
handle
event
=
{
event
.
type
}
)
;
if
(
this
.
_firstEvent
=
=
=
"
"
)
{
this
.
_firstEvent
=
event
.
type
;
}
this
.
_lastEvent
=
event
.
type
;
}
get
linkedBrowser
(
)
{
return
this
.
_tab
.
linkedBrowser
;
}
get
controller
(
)
{
return
this
.
_controller
;
}
get
tabElement
(
)
{
return
this
.
_tab
;
}
async
close
(
)
{
info
(
wait
until
finishing
close
tab
wrapper
)
;
const
deactivationPromise
=
this
.
_controller
.
isActive
?
new
Promise
(
r
=
>
(
this
.
_controller
.
ondeactivated
=
r
)
)
:
Promise
.
resolve
(
)
;
BrowserTestUtils
.
removeTab
(
this
.
_tab
)
;
await
deactivationPromise
;
if
(
this
.
_needCheck
)
{
is
(
this
.
_firstEvent
"
activated
"
"
First
event
should
be
'
activated
'
"
)
;
is
(
this
.
_lastEvent
"
deactivated
"
"
Last
event
should
be
'
deactivated
'
"
)
;
this
.
_unregisterAllEvents
(
)
;
}
}
}
const
browser
=
inputWindow
?
inputWindow
.
gBrowser
:
window
.
gBrowser
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
browser
url
)
;
return
new
tabWrapper
(
tab
needCheck
)
;
}
function
generateMediaControlKeyEvent
(
event
)
{
const
playbackStateChanged
=
waitUntilDisplayedPlaybackChanged
(
)
;
MediaControlService
.
generateMediaControlKey
(
event
)
;
return
playbackStateChanged
;
}
function
playMedia
(
tab
elementId
)
{
const
playPromise
=
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
Id
=
>
{
const
video
=
content
.
document
.
getElementById
(
Id
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
return
video
.
play
(
)
;
}
)
;
return
Promise
.
all
(
[
playPromise
waitUntilDisplayedPlaybackChanged
(
)
]
)
;
}
function
pauseMedia
(
tab
elementId
)
{
const
pausePromise
=
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
Id
=
>
{
const
video
=
content
.
document
.
getElementById
(
Id
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
ok
(
!
video
.
paused
video
is
playing
before
calling
pause
)
;
video
.
pause
(
)
;
}
)
;
return
Promise
.
all
(
[
pausePromise
waitUntilDisplayedPlaybackChanged
(
)
]
)
;
}
function
checkOrWaitUntilMediaStartedPlaying
(
tab
elementId
)
{
return
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
Id
=
>
{
return
new
Promise
(
resolve
=
>
{
const
video
=
content
.
document
.
getElementById
(
Id
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
if
(
!
video
.
paused
)
{
ok
(
true
media
started
playing
)
;
resolve
(
)
;
}
else
{
info
(
wait
until
media
starts
playing
)
;
video
.
onplaying
=
(
)
=
>
{
video
.
onplaying
=
null
;
ok
(
true
media
started
playing
)
;
resolve
(
)
;
}
;
}
}
)
;
}
)
;
}
function
checkOrWaitUntilMediaStoppedPlaying
(
tab
elementId
)
{
return
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
Id
=
>
{
return
new
Promise
(
resolve
=
>
{
const
video
=
content
.
document
.
getElementById
(
Id
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
if
(
video
.
paused
)
{
ok
(
true
media
stopped
playing
)
;
resolve
(
)
;
}
else
{
info
(
wait
until
media
stops
playing
)
;
video
.
onpause
=
(
)
=
>
{
video
.
onpause
=
null
;
ok
(
true
media
stopped
playing
)
;
resolve
(
)
;
}
;
}
}
)
;
}
)
;
}
function
isCurrentMetadataEmpty
(
)
{
const
current
=
MediaControlService
.
getCurrentActiveMediaMetadata
(
)
;
is
(
current
.
title
"
"
current
title
should
be
empty
)
;
is
(
current
.
artist
"
"
current
title
should
be
empty
)
;
is
(
current
.
album
"
"
current
album
should
be
empty
)
;
is
(
current
.
artwork
.
length
0
current
artwork
should
be
empty
)
;
}
function
isCurrentMetadataEqualTo
(
metadata
)
{
const
current
=
MediaControlService
.
getCurrentActiveMediaMetadata
(
)
;
is
(
current
.
title
metadata
.
title
tile
'
{
current
.
title
}
'
is
equal
to
{
metadata
.
title
}
)
;
is
(
current
.
artist
metadata
.
artist
artist
'
{
current
.
artist
}
'
is
equal
to
{
metadata
.
artist
}
)
;
is
(
current
.
album
metadata
.
album
album
'
{
current
.
album
}
'
is
equal
to
{
metadata
.
album
}
)
;
is
(
current
.
artwork
.
length
metadata
.
artwork
.
length
artwork
length
'
{
current
.
artwork
.
length
}
'
is
equal
to
{
metadata
.
artwork
.
length
}
)
;
for
(
let
idx
=
0
;
idx
<
metadata
.
artwork
.
length
;
idx
+
+
)
{
ok
(
current
.
artwork
[
idx
]
.
src
.
includes
(
metadata
.
artwork
[
idx
]
.
src
)
artwork
src
'
{
current
.
artwork
[
idx
]
.
src
}
'
includes
{
metadata
.
artwork
[
idx
]
.
src
}
)
;
is
(
current
.
artwork
[
idx
]
.
sizes
metadata
.
artwork
[
idx
]
.
sizes
artwork
sizes
'
{
current
.
artwork
[
idx
]
.
sizes
}
'
is
equal
to
{
metadata
.
artwork
[
idx
]
.
sizes
}
)
;
is
(
current
.
artwork
[
idx
]
.
type
metadata
.
artwork
[
idx
]
.
type
artwork
type
'
{
current
.
artwork
[
idx
]
.
type
}
'
is
equal
to
{
metadata
.
artwork
[
idx
]
.
type
}
)
;
}
}
async
function
isGivenTabUsingDefaultMetadata
(
tab
options
=
{
}
)
{
const
localization
=
new
Localization
(
[
"
branding
/
brand
.
ftl
"
"
dom
/
media
.
ftl
"
]
)
;
const
fallbackTitle
=
await
localization
.
formatValue
(
"
mediastatus
-
fallback
-
title
"
)
;
ok
(
fallbackTitle
.
length
>
0
"
l10n
fallback
title
is
not
empty
"
)
;
const
metadata
=
tab
.
linkedBrowser
.
browsingContext
.
mediaController
.
getMetadata
(
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
metadata
.
title
fallbackTitle
options
.
isPrivateBrowsing
]
(
title
fallbackTitle
isPrivateBrowsing
)
=
>
{
if
(
isPrivateBrowsing
|
|
!
content
.
document
.
title
.
length
)
{
is
(
title
fallbackTitle
"
Using
a
generic
default
fallback
title
"
)
;
}
else
{
is
(
title
content
.
document
.
title
"
Using
website
title
as
a
default
title
"
)
;
}
}
)
;
is
(
metadata
.
artwork
.
length
1
"
Default
metada
contains
one
artwork
"
)
;
ok
(
metadata
.
artwork
[
0
]
.
src
.
includes
(
"
defaultFavicon
.
svg
"
)
"
Using
default
favicon
as
a
default
art
work
"
)
;
}
function
waitUntilDisplayedPlaybackChanged
(
)
{
return
BrowserUtils
.
promiseObserved
(
"
media
-
displayed
-
playback
-
changed
"
)
;
}
function
waitUntilDisplayedMetadataChanged
(
)
{
return
BrowserUtils
.
promiseObserved
(
"
media
-
displayed
-
metadata
-
changed
"
)
;
}
function
waitUntilMainMediaControllerChanged
(
)
{
return
BrowserUtils
.
promiseObserved
(
"
main
-
media
-
controller
-
changed
"
)
;
}
function
waitUntilControllerMetadataChanged
(
)
{
return
BrowserUtils
.
promiseObserved
(
"
media
-
session
-
controller
-
metadata
-
changed
"
)
;
}
function
waitUntilMediaControllerAmountChanged
(
)
{
return
BrowserUtils
.
promiseObserved
(
"
media
-
controller
-
amount
-
changed
"
)
;
}
async
function
checkOrWaitUntilControllerBecomeActive
(
tab
)
{
const
controller
=
tab
.
linkedBrowser
.
browsingContext
.
mediaController
;
if
(
controller
.
isActive
)
{
return
;
}
await
new
Promise
(
r
=
>
(
controller
.
onactivated
=
r
)
)
;
}
