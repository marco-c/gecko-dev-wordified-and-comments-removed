Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
toolkit
/
components
/
pictureinpicture
/
tests
/
head
.
js
"
this
)
;
const
PAGE_NON_AUTOPLAY
=
"
https
:
/
/
example
.
com
/
browser
/
dom
/
media
/
mediacontrol
/
tests
/
browser
/
file_non_autoplay
.
html
"
;
const
testVideoId
=
"
video
"
;
add_task
(
async
function
setupTestingPref
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
media
.
mediacontrol
.
testingevents
.
enabled
"
true
]
[
"
dom
.
media
.
mediasession
.
enabled
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
testDeterminingMainController
(
)
{
info
(
open
three
different
tabs
)
;
const
tab0
=
await
createLoadedTabWrapper
(
PAGE_NON_AUTOPLAY
)
;
const
tab1
=
await
createLoadedTabWrapper
(
PAGE_NON_AUTOPLAY
)
;
const
tab2
=
await
createLoadedTabWrapper
(
PAGE_NON_AUTOPLAY
)
;
info
(
#
[
]
-
>
[
tab0
]
-
>
[
tab0
tab1
]
-
>
[
tab0
tab1
tab2
]
#
)
;
info
(
set
different
metadata
for
each
tab
)
;
await
setMediaMetadataForTabs
(
[
tab0
tab1
tab2
]
)
;
info
(
start
media
for
tab0
main
controller
should
become
tab0
)
;
await
makeTabBecomeMainControllerAndWaitForMetadataChange
(
tab0
)
;
info
(
currrent
metadata
should
be
equal
to
tab0
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab0
.
metadata
)
;
info
(
start
media
for
tab1
main
controller
should
become
tab1
)
;
await
makeTabBecomeMainControllerAndWaitForMetadataChange
(
tab1
)
;
info
(
currrent
metadata
should
be
equal
to
tab1
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab1
.
metadata
)
;
info
(
start
media
for
tab2
main
controller
should
become
tab2
)
;
await
makeTabBecomeMainControllerAndWaitForMetadataChange
(
tab2
)
;
info
(
currrent
metadata
should
be
equal
to
tab2
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab2
.
metadata
)
;
info
(
#
[
tab0
tab1
tab2
]
-
>
[
tab0
tab2
tab1
]
-
>
[
tab2
tab1
tab0
]
#
)
;
info
(
start
media
for
tab1
main
controller
should
become
tab1
)
;
await
makeTabBecomeMainController
(
tab1
)
;
info
(
currrent
metadata
should
be
equal
to
tab1
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab1
.
metadata
)
;
info
(
start
media
for
tab0
main
controller
should
become
tab0
)
;
await
makeTabBecomeMainController
(
tab0
)
;
info
(
currrent
metadata
should
be
equal
to
tab0
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab0
.
metadata
)
;
info
(
#
[
tab2
tab1
tab0
]
-
>
[
tab2
tab1
]
-
>
[
tab2
]
-
>
[
]
#
)
;
info
(
remove
tab0
and
wait
until
main
controller
changes
)
;
await
Promise
.
all
(
[
waitUntilMainMediaControllerChanged
(
)
tab0
.
close
(
)
]
)
;
info
(
currrent
metadata
should
be
equal
to
tab1
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab1
.
metadata
)
;
info
(
remove
tab1
and
wait
until
main
controller
changes
)
;
await
Promise
.
all
(
[
waitUntilMainMediaControllerChanged
(
)
tab1
.
close
(
)
]
)
;
info
(
currrent
metadata
should
be
equal
to
tab2
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab2
.
metadata
)
;
info
(
remove
tab2
and
wait
until
main
controller
changes
)
;
await
Promise
.
all
(
[
waitUntilMainMediaControllerChanged
(
)
tab2
.
close
(
)
]
)
;
isCurrentMetadataEmpty
(
)
;
}
)
;
add_task
(
async
function
testPIPControllerWontBeReplacedByNormalController
(
)
{
info
(
open
two
different
tabs
)
;
const
tab0
=
await
createLoadedTabWrapper
(
PAGE_NON_AUTOPLAY
)
;
const
tab1
=
await
createLoadedTabWrapper
(
PAGE_NON_AUTOPLAY
)
;
info
(
set
different
metadata
for
each
tab
)
;
await
setMediaMetadataForTabs
(
[
tab0
tab1
]
)
;
info
(
start
media
for
tab0
main
controller
should
become
tab0
)
;
await
makeTabBecomeMainControllerAndWaitForMetadataChange
(
tab0
)
;
info
(
currrent
metadata
should
be
equal
to
tab0
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab0
.
metadata
)
;
info
(
trigger
Picture
-
in
-
Picture
mode
for
tab0
)
;
const
winPIP
=
await
triggerPictureInPicture
(
tab0
.
linkedBrowser
testVideoId
)
;
info
(
start
media
for
tab1
main
controller
should
still
be
tab0
)
;
await
playMediaAndWaitUntilRegisteringController
(
tab1
testVideoId
)
;
info
(
currrent
metadata
should
be
equal
to
tab0
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab0
.
metadata
)
;
info
(
remove
tab0
and
wait
until
main
controller
changes
)
;
await
BrowserTestUtils
.
closeWindow
(
winPIP
)
;
await
Promise
.
all
(
[
waitUntilMainMediaControllerChanged
(
)
tab0
.
close
(
)
]
)
;
info
(
currrent
metadata
should
be
equal
to
tab1
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab1
.
metadata
)
;
info
(
remove
tab1
and
wait
until
main
controller
changes
)
;
await
Promise
.
all
(
[
waitUntilMainMediaControllerChanged
(
)
tab1
.
close
(
)
]
)
;
isCurrentMetadataEmpty
(
)
;
}
)
;
add_task
(
async
function
testFullscreenControllerWontBeReplacedByNormalController
(
)
{
info
(
open
two
different
tabs
)
;
const
tab0
=
await
createLoadedTabWrapper
(
PAGE_NON_AUTOPLAY
)
;
const
tab1
=
await
createLoadedTabWrapper
(
PAGE_NON_AUTOPLAY
)
;
info
(
set
different
metadata
for
each
tab
)
;
await
setMediaMetadataForTabs
(
[
tab0
tab1
]
)
;
info
(
start
media
for
tab0
main
controller
should
become
tab0
)
;
await
makeTabBecomeMainControllerAndWaitForMetadataChange
(
tab0
)
;
info
(
current
metadata
should
be
equal
to
tab0
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab0
.
metadata
)
;
info
(
video
in
tab0
enters
fullscreen
)
;
await
switchTabToForegroundAndEnableFullScreen
(
tab0
testVideoId
)
;
info
(
normal
controller
won
'
t
become
the
main
controller
+
which
is
still
fullscreen
controller
)
;
await
playMediaAndWaitUntilRegisteringController
(
tab1
testVideoId
)
;
info
(
currrent
metadata
should
be
equal
to
tab0
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab0
.
metadata
)
;
info
(
remove
tabs
)
;
await
Promise
.
all
(
[
tab0
.
close
(
)
tab1
.
close
(
)
]
)
;
}
)
;
add_task
(
async
function
testFullscreenAndPIPControllers
(
)
{
info
(
open
three
different
tabs
)
;
const
tab0
=
await
createLoadedTabWrapper
(
PAGE_NON_AUTOPLAY
)
;
const
tab1
=
await
createLoadedTabWrapper
(
PAGE_NON_AUTOPLAY
)
;
const
tab2
=
await
createLoadedTabWrapper
(
PAGE_NON_AUTOPLAY
)
;
info
(
set
different
metadata
for
each
tab
)
;
await
setMediaMetadataForTabs
(
[
tab0
tab1
tab2
]
)
;
info
(
start
media
for
tab0
main
controller
should
become
tab0
)
;
await
makeTabBecomeMainControllerAndWaitForMetadataChange
(
tab0
)
;
info
(
currrent
metadata
should
be
equal
to
tab0
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab0
.
metadata
)
;
info
(
video
in
tab0
enters
fullscreen
)
;
await
switchTabToForegroundAndEnableFullScreen
(
tab0
testVideoId
)
;
info
(
start
media
for
tab1
main
controller
should
still
be
tab0
)
;
await
playMediaAndWaitUntilRegisteringController
(
tab1
testVideoId
)
;
info
(
currrent
metadata
should
be
equal
to
tab0
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab0
.
metadata
)
;
info
(
tab1
enters
PIP
so
tab1
should
become
new
main
controller
)
;
const
mainControllerChange
=
waitUntilMainMediaControllerChanged
(
)
;
const
winPIP
=
await
triggerPictureInPicture
(
tab1
.
linkedBrowser
testVideoId
)
;
await
mainControllerChange
;
info
(
currrent
metadata
should
be
equal
to
tab1
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab1
.
metadata
)
;
info
(
play
video
from
tab2
which
shouldn
'
t
affect
main
controller
)
;
await
playMediaAndWaitUntilRegisteringController
(
tab2
testVideoId
)
;
info
(
remove
tab1
and
wait
until
main
controller
changes
)
;
await
BrowserTestUtils
.
closeWindow
(
winPIP
)
;
await
Promise
.
all
(
[
waitUntilMainMediaControllerChanged
(
)
tab1
.
close
(
)
]
)
;
info
(
currrent
metadata
should
be
equal
to
tab0
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab0
.
metadata
)
;
info
(
remove
tab0
and
wait
until
main
controller
changes
)
;
await
Promise
.
all
(
[
waitUntilMainMediaControllerChanged
(
)
tab0
.
close
(
)
]
)
;
info
(
currrent
metadata
should
be
equal
to
tab0
'
s
metadata
)
;
await
isCurrentMetadataEqualTo
(
tab2
.
metadata
)
;
info
(
remove
tab2
and
wait
until
main
controller
changes
)
;
await
Promise
.
all
(
[
waitUntilMainMediaControllerChanged
(
)
tab2
.
close
(
)
]
)
;
isCurrentMetadataEmpty
(
)
;
}
)
;
async
function
setMediaMetadataForTabs
(
tabs
)
{
for
(
let
idx
=
0
;
idx
<
tabs
.
length
;
idx
+
+
)
{
const
tabName
=
"
tab
"
+
idx
;
info
(
create
metadata
for
{
tabName
}
)
;
tabs
[
idx
]
.
metadata
=
{
title
:
tabName
artist
:
tabName
album
:
tabName
artwork
:
[
{
src
:
tabName
sizes
:
"
128x128
"
type
:
"
image
/
jpeg
"
}
]
}
;
const
spawn
=
SpecialPowers
.
spawn
(
tabs
[
idx
]
.
linkedBrowser
[
tabs
[
idx
]
.
metadata
]
data
=
>
{
content
.
navigator
.
mediaSession
.
metadata
=
new
content
.
MediaMetadata
(
data
)
;
}
)
;
await
Promise
.
all
(
[
spawn
waitUntilControllerMetadataChanged
(
)
]
)
;
}
}
function
makeTabBecomeMainController
(
tab
)
{
const
playPromise
=
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
testVideoId
]
async
Id
=
>
{
const
video
=
content
.
document
.
getElementById
(
Id
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
if
(
!
video
.
paused
)
{
video
.
pause
(
)
;
info
(
wait
until
media
stops
)
;
await
new
Promise
(
r
=
>
(
video
.
onpause
=
r
)
)
;
}
info
(
start
media
)
;
return
video
.
play
(
)
;
}
)
;
return
Promise
.
all
(
[
playPromise
waitUntilMainMediaControllerChanged
(
)
]
)
;
}
function
makeTabBecomeMainControllerAndWaitForMetadataChange
(
tab
)
{
return
Promise
.
all
(
[
new
Promise
(
r
=
>
(
tab
.
controller
.
onmetadatachange
=
r
)
)
makeTabBecomeMainController
(
tab
)
]
)
;
}
function
playMediaAndWaitUntilRegisteringController
(
tab
elementId
)
{
const
playPromise
=
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
Id
=
>
{
const
video
=
content
.
document
.
getElementById
(
Id
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
return
video
.
play
(
)
;
}
)
;
return
Promise
.
all
(
[
waitUntilMediaControllerAmountChanged
(
)
playPromise
]
)
;
}
async
function
switchTabToForegroundAndEnableFullScreen
(
tab
elementId
)
{
await
BrowserTestUtils
.
switchTab
(
gBrowser
tab
.
tabElement
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
elementId
=
>
{
return
new
Promise
(
r
=
>
{
const
element
=
content
.
document
.
getElementById
(
elementId
)
;
element
.
requestFullscreen
(
)
;
element
.
onfullscreenchange
=
(
)
=
>
{
element
.
onfullscreenchange
=
null
;
element
.
onfullscreenerror
=
null
;
r
(
)
;
}
;
element
.
onfullscreenerror
=
(
)
=
>
{
element
.
requestFullscreen
(
)
;
}
;
}
)
;
}
)
;
}
