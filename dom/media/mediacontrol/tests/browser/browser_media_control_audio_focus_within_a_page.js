const
mainPageURL
=
"
https
:
/
/
example
.
com
/
browser
/
dom
/
media
/
mediacontrol
/
tests
/
browser
/
file_main_frame_with_multiple_child_session_frames
.
html
"
;
const
frameURL
=
"
https
:
/
/
example
.
com
/
browser
/
dom
/
media
/
mediacontrol
/
tests
/
browser
/
file_iframe_media
.
html
"
;
const
frame1
=
"
frame1
"
;
const
frame2
=
"
frame2
"
;
add_task
(
async
function
setupTestingPref
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
media
.
mediacontrol
.
testingevents
.
enabled
"
true
]
[
"
dom
.
media
.
mediasession
.
enabled
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
testAudioFocusChangesAmongMultipleFrames
(
)
{
const
tab
=
await
createLoadedTabWrapper
(
mainPageURL
)
;
await
playAndWaitUntilMetadataChanged
(
tab
)
;
await
isGivenTabUsingDefaultMetadata
(
tab
)
;
await
loadPageForFrame
(
tab
frame1
frameURL
)
;
let
metadata
=
await
setMetadataAndGetReturnResult
(
tab
frame1
)
;
await
playAndWaitUntilMetadataChanged
(
tab
frame1
)
;
isCurrentMetadataEqualTo
(
metadata
)
;
await
loadPageForFrame
(
tab
frame2
frameURL
)
;
metadata
=
await
setMetadataAndGetReturnResult
(
tab
frame2
)
;
await
playAndWaitUntilMetadataChanged
(
tab
frame2
)
;
isCurrentMetadataEqualTo
(
metadata
)
;
await
tab
.
close
(
)
;
}
)
;
add_task
(
async
function
testAudioFocusChangesAfterPausingAudioFocusOwner
(
)
{
const
tab
=
await
createLoadedTabWrapper
(
mainPageURL
)
;
await
playAndWaitUntilMetadataChanged
(
tab
)
;
await
isGivenTabUsingDefaultMetadata
(
tab
)
;
await
loadPageForFrame
(
tab
frame1
frameURL
)
;
let
metadata
=
await
setMetadataAndGetReturnResult
(
tab
frame1
)
;
await
playAndWaitUntilMetadataChanged
(
tab
frame1
)
;
isCurrentMetadataEqualTo
(
metadata
)
;
await
pauseAndWaitUntilMetadataChangedFrom
(
tab
frame1
)
;
await
isGivenTabUsingDefaultMetadata
(
tab
)
;
await
tab
.
close
(
)
;
}
)
;
add_task
(
async
function
testAudioFocusUnchangesAfterPausingAudioFocusOwner
(
)
{
const
tab
=
await
createLoadedTabWrapper
(
mainPageURL
)
;
await
playAndWaitUntilMetadataChanged
(
tab
)
;
await
isGivenTabUsingDefaultMetadata
(
tab
)
;
await
loadPageForFrame
(
tab
frame1
frameURL
)
;
let
metadata
=
await
setMetadataAndGetReturnResult
(
tab
frame1
)
;
await
playAndWaitUntilMetadataChanged
(
tab
frame1
)
;
isCurrentMetadataEqualTo
(
metadata
)
;
await
pauseMediaFrom
(
tab
)
;
isCurrentMetadataEqualTo
(
metadata
)
;
await
tab
.
close
(
)
;
}
)
;
add_task
(
async
function
testSwitchAudioFocusToMainFrameAfterRemovingAudioFocusOwner
(
)
{
const
tab
=
await
createLoadedTabWrapper
(
mainPageURL
)
;
await
playAndWaitUntilMetadataChanged
(
tab
)
;
await
isGivenTabUsingDefaultMetadata
(
tab
)
;
await
loadPageForFrame
(
tab
frame1
frameURL
)
;
let
metadata
=
await
setMetadataAndGetReturnResult
(
tab
frame1
)
;
await
playAndWaitUntilMetadataChanged
(
tab
frame1
)
;
isCurrentMetadataEqualTo
(
metadata
)
;
await
Promise
.
all
(
[
waitUntilDisplayedMetadataChanged
(
)
removeFrame
(
tab
frame1
)
]
)
;
await
isGivenTabUsingDefaultMetadata
(
tab
)
;
await
tab
.
close
(
)
;
}
)
;
add_task
(
async
function
testSwitchAudioFocusToIframeAfterRemovingAudioFocusOwner
(
)
{
const
tab
=
await
createLoadedTabWrapper
(
mainPageURL
)
;
await
loadPageForFrame
(
tab
frame1
frameURL
)
;
let
metadataFrame1
=
await
setMetadataAndGetReturnResult
(
tab
frame1
)
;
await
playAndWaitUntilMetadataChanged
(
tab
frame1
)
;
isCurrentMetadataEqualTo
(
metadataFrame1
)
;
await
loadPageForFrame
(
tab
frame2
frameURL
)
;
let
metadataFrame2
=
await
setMetadataAndGetReturnResult
(
tab
frame2
)
;
await
playAndWaitUntilMetadataChanged
(
tab
frame2
)
;
isCurrentMetadataEqualTo
(
metadataFrame2
)
;
await
Promise
.
all
(
[
waitUntilDisplayedMetadataChanged
(
)
removeFrame
(
tab
frame2
)
]
)
;
isCurrentMetadataEqualTo
(
metadataFrame1
)
;
await
tab
.
close
(
)
;
}
)
;
add_task
(
async
function
testNoAudioFocusAfterRemovingAudioFocusOwner
(
)
{
const
tab
=
await
createLoadedTabWrapper
(
mainPageURL
)
;
await
playAndWaitUntilMetadataChanged
(
tab
)
;
await
isGivenTabUsingDefaultMetadata
(
tab
)
;
await
loadPageForFrame
(
tab
frame1
frameURL
)
;
let
metadata
=
await
setMetadataAndGetReturnResult
(
tab
frame1
)
;
await
playAndWaitUntilMetadataChanged
(
tab
frame1
)
;
isCurrentMetadataEqualTo
(
metadata
)
;
await
pauseMediaFrom
(
tab
)
;
await
Promise
.
all
(
[
waitUntilDisplayedMetadataChanged
(
)
removeFrame
(
tab
frame1
)
]
)
;
await
isGivenTabUsingDefaultMetadata
(
tab
)
;
await
tab
.
close
(
)
;
}
)
;
function
loadPageForFrame
(
tab
frameId
pageUrl
)
{
info
(
start
to
load
page
for
{
frameId
}
)
;
return
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
frameId
pageUrl
]
async
(
id
url
)
=
>
{
const
iframe
=
content
.
document
.
getElementById
(
id
)
;
if
(
!
iframe
)
{
ok
(
false
can
not
get
iframe
'
{
id
}
'
)
;
}
iframe
.
src
=
url
;
await
new
Promise
(
r
=
>
(
iframe
.
onload
=
r
)
)
;
iframe
.
contentDocument
.
title
=
id
;
}
)
;
}
function
playMediaFrom
(
tab
frameId
=
undefined
)
{
return
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
frameId
]
id
=
>
{
if
(
id
=
=
undefined
)
{
info
(
start
to
play
media
from
main
frame
)
;
const
video
=
content
.
document
.
getElementById
(
"
video
"
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
return
video
.
play
(
)
;
}
info
(
start
to
play
media
from
{
id
}
)
;
const
iframe
=
content
.
document
.
getElementById
(
id
)
;
if
(
!
iframe
)
{
ok
(
false
can
not
get
{
id
}
)
;
}
iframe
.
contentWindow
.
postMessage
(
"
play
"
"
*
"
)
;
return
new
Promise
(
r
=
>
{
content
.
onmessage
=
event
=
>
{
is
(
event
.
data
"
played
"
media
started
playing
in
{
id
}
)
;
r
(
)
;
}
;
}
)
;
}
)
;
}
function
playAndWaitUntilMetadataChanged
(
tab
frameId
=
undefined
)
{
const
metadataChanged
=
waitUntilDisplayedMetadataChanged
(
)
;
return
Promise
.
all
(
[
metadataChanged
playMediaFrom
(
tab
frameId
)
]
)
;
}
function
pauseMediaFrom
(
tab
frameId
=
undefined
)
{
return
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
frameId
]
id
=
>
{
if
(
id
=
=
undefined
)
{
info
(
start
to
pause
media
from
in
frame
)
;
const
video
=
content
.
document
.
getElementById
(
"
video
"
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
return
video
.
pause
(
)
;
}
info
(
start
to
pause
media
in
{
id
}
)
;
const
iframe
=
content
.
document
.
getElementById
(
id
)
;
if
(
!
iframe
)
{
ok
(
false
can
not
get
{
id
}
)
;
}
iframe
.
contentWindow
.
postMessage
(
"
pause
"
"
*
"
)
;
return
new
Promise
(
r
=
>
{
content
.
onmessage
=
event
=
>
{
is
(
event
.
data
"
paused
"
media
paused
in
{
id
}
)
;
r
(
)
;
}
;
}
)
;
}
)
;
}
function
pauseAndWaitUntilMetadataChangedFrom
(
tab
frameId
=
undefined
)
{
const
metadataChanged
=
waitUntilDisplayedMetadataChanged
(
)
;
return
Promise
.
all
(
[
metadataChanged
pauseMediaFrom
(
tab
frameId
)
]
)
;
}
function
setMetadataAndGetReturnResult
(
tab
frameId
)
{
info
(
start
to
set
metadata
for
{
frameId
}
)
;
return
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
frameId
]
id
=
>
{
const
iframe
=
content
.
document
.
getElementById
(
id
)
;
if
(
!
iframe
)
{
ok
(
false
can
not
get
{
id
}
)
;
}
iframe
.
contentWindow
.
postMessage
(
"
setMetadata
"
"
*
"
)
;
info
(
wait
until
we
get
metadata
for
{
id
}
)
;
return
new
Promise
(
r
=
>
{
content
.
onmessage
=
event
=
>
{
ok
(
event
.
data
.
title
&
&
event
.
data
.
artist
&
&
event
.
data
.
album
"
correct
return
format
"
)
;
r
(
event
.
data
)
;
}
;
}
)
;
}
)
;
}
function
removeFrame
(
tab
frameId
)
{
info
(
remove
{
frameId
}
)
;
return
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
frameId
]
id
=
>
{
const
iframe
=
content
.
document
.
getElementById
(
id
)
;
if
(
!
iframe
)
{
ok
(
false
can
not
get
{
id
}
)
;
}
content
.
document
.
body
.
removeChild
(
iframe
)
;
}
)
;
}
