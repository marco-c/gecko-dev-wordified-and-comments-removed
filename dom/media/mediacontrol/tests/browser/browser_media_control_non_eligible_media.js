const
PAGE_NON_ELIGIBLE_MEDIA
=
"
https
:
/
/
example
.
com
/
browser
/
dom
/
media
/
mediacontrol
/
tests
/
browser
/
file_non_eligible_media
.
html
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
toolkit
/
components
/
pictureinpicture
/
tests
/
head
.
js
"
this
)
;
requestLongerTimeout
(
2
)
;
const
gNonEligibleElementIds
=
[
"
muted
"
"
volume
-
0
"
"
silent
-
audio
-
track
"
"
no
-
audio
-
track
"
"
short
-
duration
"
"
inaudible
-
captured
-
media
"
]
;
add_task
(
async
function
setupTestingPref
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
media
.
mediacontrol
.
testingevents
.
enabled
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
testPlayPauseAndStop
(
)
{
for
(
const
elementId
of
gNonEligibleElementIds
)
{
info
(
-
open
new
tab
and
start
non
eligible
media
{
elementId
}
-
)
;
const
tab
=
await
createTabAndLoad
(
PAGE_NON_ELIGIBLE_MEDIA
)
;
await
startNonEligibleMedia
(
tab
elementId
)
;
info
(
-
let
media
play
for
a
while
-
)
;
await
checkIfMediaIsStillPlaying
(
tab
elementId
)
;
info
(
-
simulate
pressing
'
pause
'
media
control
key
-
)
;
MediaControlService
.
generateMediaControlKey
(
"
pause
"
)
;
info
(
-
non
eligible
media
won
'
t
be
controlled
by
media
control
-
)
;
await
checkIfMediaIsStillPlaying
(
tab
elementId
)
;
if
(
couldElementBecomeEligible
(
elementId
)
)
{
info
(
-
make
element
{
elementId
}
audible
-
)
;
await
makeElementEligible
(
tab
elementId
)
;
info
(
-
simulate
pressing
'
pause
'
media
control
key
-
)
;
MediaControlService
.
generateMediaControlKey
(
"
pause
"
)
;
info
(
-
audible
media
should
be
controlled
by
media
control
-
)
;
await
waitUntilMediaPaused
(
tab
elementId
)
;
}
info
(
remove
tab
)
;
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
}
)
;
add_task
(
async
function
testNonEligibleMediaEnterFullscreen
(
)
{
for
(
const
elementId
of
gNonEligibleElementIds
)
{
info
(
-
open
new
tab
and
start
non
eligible
media
{
elementId
}
-
)
;
const
tab
=
await
createTabAndLoad
(
PAGE_NON_ELIGIBLE_MEDIA
)
;
await
startNonEligibleMedia
(
tab
elementId
)
;
info
(
entering
fullscreen
should
activate
the
media
controller
)
;
await
enableFullScreen
(
tab
elementId
)
;
await
checkOrWaitUntilControllerBecomeActive
(
tab
)
;
ok
(
true
fullscreen
{
elementId
}
media
is
able
to
being
controlled
)
;
info
(
remove
tab
)
;
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
}
)
;
add_task
(
async
function
testNonEligibleMediaEnterPIPMode
(
)
{
for
(
const
elementId
of
gNonEligibleElementIds
)
{
info
(
-
open
new
tab
and
start
non
eligible
media
{
elementId
}
-
)
;
const
tab
=
await
createTabAndLoad
(
PAGE_NON_ELIGIBLE_MEDIA
)
;
await
startNonEligibleMedia
(
tab
elementId
)
;
info
(
media
entering
PIP
mode
should
activate
the
media
controller
)
;
const
winPIP
=
await
triggerPictureInPicture
(
tab
.
linkedBrowser
elementId
)
;
await
checkOrWaitUntilControllerBecomeActive
(
tab
)
;
ok
(
true
PIP
{
elementId
}
media
is
able
to
being
controlled
)
;
info
(
remove
tab
)
;
await
BrowserTestUtils
.
closeWindow
(
winPIP
)
;
await
BrowserTestUtils
.
removeTab
(
tab
)
;
}
}
)
;
function
startNonEligibleMedia
(
tab
elementId
)
{
return
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
Id
=
>
{
const
video
=
content
.
document
.
getElementById
(
Id
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
if
(
Id
=
=
"
volume
-
0
"
)
{
video
.
volume
=
0
.
0
;
}
if
(
Id
=
=
"
inaudible
-
captured
-
media
"
)
{
const
context
=
new
content
.
AudioContext
(
)
;
context
.
createMediaElementSource
(
video
)
;
}
return
video
.
play
(
)
;
}
)
;
}
function
checkIfMediaIsStillPlaying
(
tab
elementId
)
{
return
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
Id
=
>
{
const
video
=
content
.
document
.
getElementById
(
Id
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
return
new
Promise
(
r
=
>
{
let
timeUpdateCount
=
0
;
ok
(
!
video
.
paused
)
;
video
.
ontimeupdate
=
(
)
=
>
{
if
(
+
+
timeUpdateCount
=
=
3
)
{
video
.
ontimeupdate
=
null
;
r
(
)
;
}
}
;
}
)
;
}
)
;
}
function
couldElementBecomeEligible
(
elementId
)
{
return
elementId
=
=
"
muted
"
|
|
elementId
=
=
"
volume
-
0
"
;
}
function
makeElementEligible
(
tab
elementId
)
{
return
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
Id
=
>
{
const
video
=
content
.
document
.
getElementById
(
Id
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
video
.
volume
=
1
.
0
;
video
.
muted
=
false
;
}
)
;
}
function
waitUntilMediaPaused
(
tab
elementId
)
{
return
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
Id
=
>
{
const
video
=
content
.
document
.
getElementById
(
Id
)
;
if
(
!
video
)
{
ok
(
false
can
'
t
get
the
media
element
!
)
;
}
if
(
video
.
paused
)
{
ok
(
true
"
media
has
been
paused
"
)
;
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
r
=
>
(
video
.
onpaused
=
r
)
)
;
}
)
;
}
function
enableFullScreen
(
tab
elementId
)
{
return
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
elementId
]
elementId
=
>
{
return
new
Promise
(
r
=
>
{
const
element
=
content
.
document
.
getElementById
(
elementId
)
;
element
.
requestFullscreen
(
)
;
element
.
onfullscreenchange
=
(
)
=
>
{
element
.
onfullscreenchange
=
null
;
element
.
onfullscreenerror
=
null
;
r
(
)
;
}
;
element
.
onfullscreenerror
=
(
)
=
>
{
element
.
requestFullscreen
(
)
;
}
;
}
)
;
}
)
;
}
