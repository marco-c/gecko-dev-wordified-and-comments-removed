#
include
"
MediaController
.
h
"
#
include
"
MediaControlService
.
h
"
#
include
"
MediaControlUtils
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
undef
LOG
#
define
LOG
(
msg
.
.
.
)
\
MOZ_LOG
(
gMediaControlLog
LogLevel
:
:
Debug
\
(
"
MediaController
=
%
p
Id
=
%
"
PRId64
"
"
msg
this
this
-
>
Id
(
)
\
#
#
__VA_ARGS__
)
)
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
MediaController
DOMEventTargetHelper
)
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
MediaController
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
MediaController
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
nsISupports
*
MediaController
:
:
GetParentObject
(
)
const
{
RefPtr
<
BrowsingContext
>
bc
=
BrowsingContext
:
:
Get
(
Id
(
)
)
;
return
bc
;
}
JSObject
*
MediaController
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MediaController_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
MediaController
:
:
GetSupportedKeys
(
nsTArray
<
MediaControlKey
>
&
aRetVal
)
const
{
aRetVal
.
Clear
(
)
;
for
(
const
auto
&
key
:
mSupportedKeys
)
{
aRetVal
.
AppendElement
(
key
)
;
}
}
static
const
MediaControlKey
sDefaultSupportedKeys
[
]
=
{
MediaControlKey
:
:
Focus
MediaControlKey
:
:
Play
MediaControlKey
:
:
Pause
MediaControlKey
:
:
Playpause
MediaControlKey
:
:
Stop
}
;
static
void
GetDefaultSupportedKeys
(
nsTArray
<
MediaControlKey
>
&
aKeys
)
{
for
(
const
auto
&
key
:
sDefaultSupportedKeys
)
{
aKeys
.
AppendElement
(
key
)
;
}
}
MediaController
:
:
MediaController
(
uint64_t
aBrowsingContextId
)
:
MediaStatusManager
(
aBrowsingContextId
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
"
MediaController
only
runs
on
Chrome
process
!
"
)
;
LOG
(
"
Create
controller
%
"
PRId64
Id
(
)
)
;
GetDefaultSupportedKeys
(
mSupportedKeys
)
;
mSupportedActionsChangedListener
=
SupportedActionsChangedEvent
(
)
.
Connect
(
AbstractThread
:
:
MainThread
(
)
this
&
MediaController
:
:
HandleSupportedMediaSessionActionsChanged
)
;
}
MediaController
:
:
~
MediaController
(
)
{
LOG
(
"
Destroy
controller
%
"
PRId64
Id
(
)
)
;
if
(
!
mShutdown
)
{
Shutdown
(
)
;
}
}
;
void
MediaController
:
:
Focus
(
)
{
LOG
(
"
Focus
"
)
;
UpdateMediaControlKeyToContentMediaIfNeeded
(
MediaControlKey
:
:
Focus
)
;
}
void
MediaController
:
:
Play
(
)
{
LOG
(
"
Play
"
)
;
UpdateMediaControlKeyToContentMediaIfNeeded
(
MediaControlKey
:
:
Play
)
;
}
void
MediaController
:
:
Pause
(
)
{
LOG
(
"
Pause
"
)
;
UpdateMediaControlKeyToContentMediaIfNeeded
(
MediaControlKey
:
:
Pause
)
;
}
void
MediaController
:
:
PrevTrack
(
)
{
LOG
(
"
Prev
Track
"
)
;
UpdateMediaControlKeyToContentMediaIfNeeded
(
MediaControlKey
:
:
Previoustrack
)
;
}
void
MediaController
:
:
NextTrack
(
)
{
LOG
(
"
Next
Track
"
)
;
UpdateMediaControlKeyToContentMediaIfNeeded
(
MediaControlKey
:
:
Nexttrack
)
;
}
void
MediaController
:
:
SeekBackward
(
)
{
LOG
(
"
Seek
Backward
"
)
;
UpdateMediaControlKeyToContentMediaIfNeeded
(
MediaControlKey
:
:
Seekbackward
)
;
}
void
MediaController
:
:
SeekForward
(
)
{
LOG
(
"
Seek
Forward
"
)
;
UpdateMediaControlKeyToContentMediaIfNeeded
(
MediaControlKey
:
:
Seekforward
)
;
}
void
MediaController
:
:
Stop
(
)
{
LOG
(
"
Stop
"
)
;
UpdateMediaControlKeyToContentMediaIfNeeded
(
MediaControlKey
:
:
Stop
)
;
}
uint64_t
MediaController
:
:
Id
(
)
const
{
return
mTopLevelBrowsingContextId
;
}
bool
MediaController
:
:
IsAudible
(
)
const
{
return
IsMediaAudible
(
)
;
}
bool
MediaController
:
:
IsPlaying
(
)
const
{
return
IsMediaPlaying
(
)
;
}
void
MediaController
:
:
UpdateMediaControlKeyToContentMediaIfNeeded
(
MediaControlKey
aKey
)
{
if
(
!
mIsActive
|
|
mShutdown
)
{
return
;
}
RefPtr
<
BrowsingContext
>
context
=
mActiveMediaSessionContextId
?
BrowsingContext
:
:
Get
(
*
mActiveMediaSessionContextId
)
:
BrowsingContext
:
:
Get
(
Id
(
)
)
;
if
(
context
&
&
!
context
-
>
IsDiscarded
(
)
)
{
context
-
>
Canonical
(
)
-
>
UpdateMediaControlKey
(
aKey
)
;
}
}
void
MediaController
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
!
mShutdown
"
Do
not
call
shutdown
twice
!
"
)
;
Deactivate
(
)
;
mShutdown
=
true
;
mSupportedActionsChangedListener
.
DisconnectIfExists
(
)
;
}
void
MediaController
:
:
NotifyMediaPlaybackChanged
(
uint64_t
aBrowsingContextId
MediaPlaybackState
aState
)
{
if
(
mShutdown
)
{
return
;
}
MediaStatusManager
:
:
NotifyMediaPlaybackChanged
(
aBrowsingContextId
aState
)
;
UpdateDeactivationTimerIfNeeded
(
)
;
UpdateActivatedStateIfNeeded
(
)
;
}
void
MediaController
:
:
UpdateDeactivationTimerIfNeeded
(
)
{
bool
shouldBeAlwaysActive
=
IsPlaying
(
)
|
|
mIsInPictureInPictureMode
;
if
(
shouldBeAlwaysActive
&
&
mDeactivationTimer
)
{
LOG
(
"
Cancel
deactivation
timer
"
)
;
mDeactivationTimer
-
>
Cancel
(
)
;
mDeactivationTimer
=
nullptr
;
}
else
if
(
!
shouldBeAlwaysActive
&
&
!
mDeactivationTimer
)
{
nsresult
rv
=
NS_NewTimerWithCallback
(
getter_AddRefs
(
mDeactivationTimer
)
this
StaticPrefs
:
:
media_mediacontrol_stopcontrol_timer_ms
(
)
nsITimer
:
:
TYPE_ONE_SHOT
AbstractThread
:
:
MainThread
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
"
Create
a
deactivation
timer
"
)
;
}
else
{
LOG
(
"
Failed
to
create
a
deactivation
timer
"
)
;
}
}
}
NS_IMETHODIMP
MediaController
:
:
Notify
(
nsITimer
*
aTimer
)
{
mDeactivationTimer
=
nullptr
;
if
(
mShutdown
)
{
LOG
(
"
Cancel
deactivation
timer
because
controller
has
been
shutdown
"
)
;
return
NS_OK
;
}
if
(
mIsInPictureInPictureMode
)
{
LOG
(
"
Cancel
deactivation
timer
because
controller
is
in
PIP
mode
"
)
;
return
NS_OK
;
}
if
(
IsPlaying
(
)
)
{
LOG
(
"
Cancel
deactivation
timer
because
controller
is
still
playing
"
)
;
return
NS_OK
;
}
if
(
!
mIsActive
)
{
LOG
(
"
Cancel
deactivation
timer
because
controller
has
been
deactivated
"
)
;
return
NS_OK
;
}
Deactivate
(
)
;
return
NS_OK
;
}
void
MediaController
:
:
NotifyMediaAudibleChanged
(
uint64_t
aBrowsingContextId
MediaAudibleState
aState
)
{
if
(
mShutdown
)
{
return
;
}
bool
oldAudible
=
IsAudible
(
)
;
MediaStatusManager
:
:
NotifyMediaAudibleChanged
(
aBrowsingContextId
aState
)
;
if
(
IsAudible
(
)
=
=
oldAudible
)
{
return
;
}
UpdateActivatedStateIfNeeded
(
)
;
RefPtr
<
MediaControlService
>
service
=
MediaControlService
:
:
GetService
(
)
;
MOZ_ASSERT
(
service
)
;
if
(
IsAudible
(
)
)
{
service
-
>
GetAudioFocusManager
(
)
.
RequestAudioFocus
(
this
)
;
}
else
{
service
-
>
GetAudioFocusManager
(
)
.
RevokeAudioFocus
(
this
)
;
}
}
bool
MediaController
:
:
ShouldActivateController
(
)
const
{
MOZ_ASSERT
(
!
mShutdown
)
;
return
IsAnyMediaBeingControlled
(
)
&
&
IsAudible
(
)
&
&
!
mIsActive
;
}
bool
MediaController
:
:
ShouldDeactivateController
(
)
const
{
MOZ_ASSERT
(
!
mShutdown
)
;
return
!
IsAnyMediaBeingControlled
(
)
&
&
mIsActive
;
}
void
MediaController
:
:
Activate
(
)
{
MOZ_ASSERT
(
!
mShutdown
)
;
RefPtr
<
MediaControlService
>
service
=
MediaControlService
:
:
GetService
(
)
;
if
(
service
&
&
!
mIsActive
)
{
LOG
(
"
Activate
"
)
;
mIsActive
=
service
-
>
RegisterActiveMediaController
(
this
)
;
MOZ_ASSERT
(
mIsActive
"
Fail
to
register
controller
!
"
)
;
}
}
void
MediaController
:
:
Deactivate
(
)
{
MOZ_ASSERT
(
!
mShutdown
)
;
RefPtr
<
MediaControlService
>
service
=
MediaControlService
:
:
GetService
(
)
;
if
(
service
)
{
service
-
>
GetAudioFocusManager
(
)
.
RevokeAudioFocus
(
this
)
;
if
(
mIsActive
)
{
LOG
(
"
Deactivate
"
)
;
mIsActive
=
!
service
-
>
UnregisterActiveMediaController
(
this
)
;
MOZ_ASSERT
(
!
mIsActive
"
Fail
to
unregister
controller
!
"
)
;
}
}
}
void
MediaController
:
:
SetIsInPictureInPictureMode
(
uint64_t
aBrowsingContextId
bool
aIsInPictureInPictureMode
)
{
if
(
mIsInPictureInPictureMode
=
=
aIsInPictureInPictureMode
)
{
return
;
}
LOG
(
"
Set
IsInPictureInPictureMode
to
%
s
"
aIsInPictureInPictureMode
?
"
true
"
:
"
false
"
)
;
mIsInPictureInPictureMode
=
aIsInPictureInPictureMode
;
if
(
RefPtr
<
MediaControlService
>
service
=
MediaControlService
:
:
GetService
(
)
;
service
&
&
mIsInPictureInPictureMode
)
{
service
-
>
NotifyControllerBeingUsedInPictureInPictureMode
(
this
)
;
}
UpdateDeactivationTimerIfNeeded
(
)
;
}
void
MediaController
:
:
NotifyMediaFullScreenState
(
uint64_t
aBrowsingContextId
bool
aIsInFullScreen
)
{
if
(
mIsInFullScreenMode
=
=
aIsInFullScreen
)
{
return
;
}
LOG
(
"
%
s
fullscreen
"
aIsInFullScreen
?
"
Entered
"
:
"
Left
"
)
;
mIsInFullScreenMode
=
aIsInFullScreen
;
}
void
MediaController
:
:
HandleActualPlaybackStateChanged
(
)
{
if
(
RefPtr
<
MediaControlService
>
service
=
MediaControlService
:
:
GetService
(
)
)
{
service
-
>
NotifyControllerPlaybackStateChanged
(
this
)
;
}
}
bool
MediaController
:
:
IsInPictureInPictureMode
(
)
const
{
return
mIsInPictureInPictureMode
;
}
void
MediaController
:
:
UpdateActivatedStateIfNeeded
(
)
{
if
(
ShouldActivateController
(
)
)
{
Activate
(
)
;
}
else
if
(
ShouldDeactivateController
(
)
)
{
Deactivate
(
)
;
}
}
void
MediaController
:
:
HandleSupportedMediaSessionActionsChanged
(
const
nsTArray
<
MediaSessionAction
>
&
aSupportedAction
)
{
nsTArray
<
MediaControlKey
>
newSupportedKeys
;
GetDefaultSupportedKeys
(
newSupportedKeys
)
;
for
(
const
auto
&
action
:
aSupportedAction
)
{
MediaControlKey
key
=
ConvertMediaSessionActionToControlKey
(
action
)
;
if
(
!
newSupportedKeys
.
Contains
(
key
)
)
{
newSupportedKeys
.
AppendElement
(
key
)
;
}
}
if
(
newSupportedKeys
=
=
mSupportedKeys
)
{
return
;
}
LOG
(
"
Supported
keys
changes
"
)
;
mSupportedKeys
=
newSupportedKeys
;
mSupportedKeysChangedEvent
.
Notify
(
mSupportedKeys
)
;
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
this
NS_LITERAL_STRING
(
"
supportedkeyschange
"
)
CanBubble
:
:
eYes
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
MediaController_Binding
:
:
ClearCachedSupportedKeysValue
(
this
)
;
}
CopyableTArray
<
MediaControlKey
>
MediaController
:
:
GetSupportedMediaKeys
(
)
const
{
return
mSupportedKeys
;
}
}
}
