#
ifndef
mozilla_dom_audiochannelservice_h__
#
define
mozilla_dom_audiochannelservice_h__
#
include
"
nsIAudioChannelService
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
AudioChannelAgent
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
mozilla
/
dom
/
AudioChannelBinding
.
h
"
#
include
<
functional
>
class
nsIRunnable
;
class
nsPIDOMWindowOuter
;
struct
PRLogModuleInfo
;
namespace
mozilla
{
namespace
dom
{
class
TabParent
;
#
define
NUMBER_OF_AUDIO_CHANNELS
(
uint32_t
)
AudioChannel
:
:
EndGuard_
class
AudioPlaybackConfig
{
public
:
AudioPlaybackConfig
(
)
:
mVolume
(
1
.
0
)
mMuted
(
false
)
mSuspend
(
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
{
}
AudioPlaybackConfig
(
float
aVolume
bool
aMuted
uint32_t
aSuspended
)
:
mVolume
(
aVolume
)
mMuted
(
aMuted
)
mSuspend
(
aSuspended
)
{
}
void
SetConfig
(
float
aVolume
bool
aMuted
uint32_t
aSuspended
)
{
mVolume
=
aVolume
;
mMuted
=
aMuted
;
mSuspend
=
aSuspended
;
}
float
mVolume
;
bool
mMuted
;
uint32_t
mSuspend
;
}
;
class
AudioChannelService
final
:
public
nsIAudioChannelService
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSIAUDIOCHANNELSERVICE
enum
AudibleState
:
uint8_t
{
eNotAudible
=
0
eMaybeAudible
=
1
eAudible
=
2
}
;
enum
AudioCaptureState
:
bool
{
eCapturing
=
true
eNotCapturing
=
false
}
;
enum
AudibleChangedReasons
:
uint32_t
{
eVolumeChanged
=
0
eDataAudibleChanged
=
1
ePauseStateChanged
=
2
}
;
static
already_AddRefed
<
AudioChannelService
>
GetOrCreate
(
)
;
static
already_AddRefed
<
AudioChannelService
>
Get
(
)
;
static
bool
IsAudioChannelMutedByDefault
(
)
;
static
PRLogModuleInfo
*
GetAudioChannelLog
(
)
;
static
bool
IsEnableAudioCompeting
(
)
;
static
bool
IsServiceStarted
(
)
;
void
RegisterAudioChannelAgent
(
AudioChannelAgent
*
aAgent
AudibleState
aAudible
)
;
void
UnregisterAudioChannelAgent
(
AudioChannelAgent
*
aAgent
)
;
void
RegisterTabParent
(
TabParent
*
aTabParent
)
;
void
UnregisterTabParent
(
TabParent
*
aTabParent
)
;
AudioPlaybackConfig
GetMediaConfig
(
nsPIDOMWindowOuter
*
aWindow
uint32_t
aAudioChannel
)
const
;
void
AudioAudibleChanged
(
AudioChannelAgent
*
aAgent
AudibleState
aAudible
AudibleChangedReasons
aReason
)
;
float
GetAudioChannelVolume
(
nsPIDOMWindowOuter
*
aWindow
AudioChannel
aChannel
)
;
void
SetAudioChannelVolume
(
nsPIDOMWindowOuter
*
aWindow
AudioChannel
aChannel
float
aVolume
)
;
bool
GetAudioChannelMuted
(
nsPIDOMWindowOuter
*
aWindow
AudioChannel
aChannel
)
;
void
SetAudioChannelMuted
(
nsPIDOMWindowOuter
*
aWindow
AudioChannel
aChannel
bool
aMuted
)
;
bool
IsAudioChannelActive
(
nsPIDOMWindowOuter
*
aWindow
AudioChannel
aChannel
)
;
bool
IsWindowActive
(
nsPIDOMWindowOuter
*
aWindow
)
;
bool
TelephonyChannelIsActive
(
)
;
bool
ProcessContentOrNormalChannelIsActive
(
uint64_t
aChildID
)
;
virtual
void
SetDefaultVolumeControlChannel
(
int32_t
aChannel
bool
aVisible
)
;
bool
AnyAudioChannelIsActive
(
)
;
void
RefreshAgentsVolume
(
nsPIDOMWindowOuter
*
aWindow
)
;
void
RefreshAgentsSuspend
(
nsPIDOMWindowOuter
*
aWindow
nsSuspendedTypes
aSuspend
)
;
void
RefreshAgentsVolumeAndPropagate
(
AudioChannel
aAudioChannel
nsPIDOMWindowOuter
*
aWindow
)
;
void
SetWindowAudioCaptured
(
nsPIDOMWindowOuter
*
aWindow
uint64_t
aInnerWindowID
bool
aCapture
)
;
static
const
nsAttrValue
:
:
EnumTable
*
GetAudioChannelTable
(
)
;
static
AudioChannel
GetAudioChannel
(
const
nsAString
&
aString
)
;
static
AudioChannel
GetDefaultAudioChannel
(
)
;
static
void
GetAudioChannelString
(
AudioChannel
aChannel
nsAString
&
aString
)
;
static
void
GetDefaultAudioChannelString
(
nsAString
&
aString
)
;
void
Notify
(
uint64_t
aWindowID
)
;
void
ChildStatusReceived
(
uint64_t
aChildID
bool
aTelephonyChannel
bool
aContentOrNormalChannel
bool
aAnyChannel
)
;
void
NotifyCreatedNewAgent
(
AudioChannelAgent
*
aAgent
)
;
void
NotifyMediaResumedFromBlock
(
nsPIDOMWindowOuter
*
aWindow
)
;
private
:
AudioChannelService
(
)
;
~
AudioChannelService
(
)
;
void
RefreshAgents
(
nsPIDOMWindowOuter
*
aWindow
std
:
:
function
<
void
(
AudioChannelAgent
*
)
>
aFunc
)
;
static
void
CreateServiceIfNeeded
(
)
;
static
void
Shutdown
(
)
;
void
MaybeSendStatusUpdate
(
)
;
bool
ContentOrNormalChannelIsActive
(
)
;
void
SetDefaultVolumeControlChannelInternal
(
int32_t
aChannel
bool
aVisible
uint64_t
aChildID
)
;
void
RefreshAgentsAudioFocusChanged
(
AudioChannelAgent
*
aAgent
)
;
class
AudioChannelConfig
final
:
public
AudioPlaybackConfig
{
public
:
AudioChannelConfig
(
)
:
AudioPlaybackConfig
(
1
.
0
IsAudioChannelMutedByDefault
(
)
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
mNumberOfAgents
(
0
)
{
}
uint32_t
mNumberOfAgents
;
}
;
class
AudioChannelWindow
final
{
public
:
explicit
AudioChannelWindow
(
uint64_t
aWindowID
)
:
mWindowID
(
aWindowID
)
mIsAudioCaptured
(
false
)
mOwningAudioFocus
(
!
AudioChannelService
:
:
IsEnableAudioCompeting
(
)
)
mShouldSendBlockStopEvent
(
false
)
{
mChannels
[
(
int16_t
)
AudioChannel
:
:
System
]
.
mMuted
=
false
;
}
void
AudioFocusChanged
(
AudioChannelAgent
*
aNewPlayingAgent
)
;
void
AudioAudibleChanged
(
AudioChannelAgent
*
aAgent
AudibleState
aAudible
AudibleChangedReasons
aReason
)
;
void
AppendAgent
(
AudioChannelAgent
*
aAgent
AudibleState
aAudible
)
;
void
RemoveAgent
(
AudioChannelAgent
*
aAgent
)
;
void
NotifyMediaBlockStop
(
nsPIDOMWindowOuter
*
aWindow
)
;
uint64_t
mWindowID
;
bool
mIsAudioCaptured
;
AudioChannelConfig
mChannels
[
NUMBER_OF_AUDIO_CHANNELS
]
;
nsTObserverArray
<
AudioChannelAgent
*
>
mAgents
;
nsTObserverArray
<
AudioChannelAgent
*
>
mAudibleAgents
;
bool
mOwningAudioFocus
;
bool
mShouldSendBlockStopEvent
;
private
:
void
AudioCapturedChanged
(
AudioChannelAgent
*
aAgent
AudioCaptureState
aCapture
)
;
void
AppendAudibleAgentIfNotContained
(
AudioChannelAgent
*
aAgent
AudibleChangedReasons
aReason
)
;
void
RemoveAudibleAgentIfContained
(
AudioChannelAgent
*
aAgent
AudibleChangedReasons
aReason
)
;
void
AppendAgentAndIncreaseAgentsNum
(
AudioChannelAgent
*
aAgent
)
;
void
RemoveAgentAndReduceAgentsNum
(
AudioChannelAgent
*
aAgent
)
;
bool
IsFirstAudibleAgent
(
)
const
;
bool
IsLastAudibleAgent
(
)
const
;
void
NotifyAudioAudibleChanged
(
nsPIDOMWindowOuter
*
aWindow
AudibleState
aAudible
AudibleChangedReasons
aReason
)
;
void
NotifyChannelActive
(
uint64_t
aWindowID
AudioChannel
aChannel
bool
aActive
)
;
void
MaybeNotifyMediaBlockStart
(
AudioChannelAgent
*
aAgent
)
;
void
RequestAudioFocus
(
AudioChannelAgent
*
aAgent
)
;
void
NotifyAudioCompetingChanged
(
AudioChannelAgent
*
aAgent
)
;
uint32_t
GetCompetingBehavior
(
AudioChannelAgent
*
aAgent
int32_t
aIncomingChannelType
)
const
;
bool
IsAgentInvolvingInAudioCompeting
(
AudioChannelAgent
*
aAgent
)
const
;
bool
IsAudioCompetingInSameTab
(
)
const
;
bool
IsContainingPlayingAgent
(
AudioChannelAgent
*
aAgent
)
const
;
bool
IsInactiveWindow
(
)
const
;
}
;
AudioChannelWindow
*
GetOrCreateWindowData
(
nsPIDOMWindowOuter
*
aWindow
)
;
AudioChannelWindow
*
GetWindowData
(
uint64_t
aWindowID
)
const
;
struct
AudioChannelChildStatus
final
{
explicit
AudioChannelChildStatus
(
uint64_t
aChildID
)
:
mChildID
(
aChildID
)
mActiveTelephonyChannel
(
false
)
mActiveContentOrNormalChannel
(
false
)
{
}
uint64_t
mChildID
;
bool
mActiveTelephonyChannel
;
bool
mActiveContentOrNormalChannel
;
}
;
AudioChannelChildStatus
*
GetChildStatus
(
uint64_t
aChildID
)
const
;
void
RemoveChildStatus
(
uint64_t
aChildID
)
;
nsTObserverArray
<
nsAutoPtr
<
AudioChannelWindow
>
>
mWindows
;
nsTObserverArray
<
nsAutoPtr
<
AudioChannelChildStatus
>
>
mPlayingChildren
;
nsTArray
<
TabParent
*
>
mTabParents
;
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
uint64_t
mDefChannelChildID
;
bool
mTelephonyChannel
;
bool
mContentOrNormalChannel
;
bool
mAnyChannel
;
friend
class
ContentParent
;
friend
class
ContentChild
;
}
;
}
}
#
endif
