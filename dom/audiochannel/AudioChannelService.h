#
ifndef
mozilla_dom_audiochannelservice_h__
#
define
mozilla_dom_audiochannelservice_h__
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
AudioChannelAgent
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
mozilla
/
dom
/
AudioChannelBinding
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
<
functional
>
class
nsPIDOMWindowOuter
;
struct
PRLogModuleInfo
;
namespace
mozilla
{
namespace
dom
{
#
define
NUMBER_OF_AUDIO_CHANNELS
(
uint32_t
)
AudioChannel
:
:
EndGuard_
class
AudioPlaybackConfig
{
public
:
AudioPlaybackConfig
(
)
:
mVolume
(
1
.
0
)
mMuted
(
false
)
mSuspend
(
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
{
}
AudioPlaybackConfig
(
float
aVolume
bool
aMuted
uint32_t
aSuspended
)
:
mVolume
(
aVolume
)
mMuted
(
aMuted
)
mSuspend
(
aSuspended
)
{
}
void
SetConfig
(
float
aVolume
bool
aMuted
uint32_t
aSuspended
)
{
mVolume
=
aVolume
;
mMuted
=
aMuted
;
mSuspend
=
aSuspended
;
}
float
mVolume
;
bool
mMuted
;
uint32_t
mSuspend
;
}
;
class
AudioChannelService
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
enum
AudibleState
:
uint8_t
{
eNotAudible
=
0
eMaybeAudible
=
1
eAudible
=
2
}
;
enum
AudioCaptureState
:
bool
{
eCapturing
=
true
eNotCapturing
=
false
}
;
enum
AudibleChangedReasons
:
uint32_t
{
eVolumeChanged
=
0
eDataAudibleChanged
=
1
ePauseStateChanged
=
2
}
;
static
already_AddRefed
<
AudioChannelService
>
GetOrCreate
(
)
;
static
already_AddRefed
<
AudioChannelService
>
Get
(
)
;
static
LogModule
*
GetAudioChannelLog
(
)
;
static
bool
IsEnableAudioCompeting
(
)
;
void
RegisterAudioChannelAgent
(
AudioChannelAgent
*
aAgent
AudibleState
aAudible
)
;
void
UnregisterAudioChannelAgent
(
AudioChannelAgent
*
aAgent
)
;
AudioPlaybackConfig
GetMediaConfig
(
nsPIDOMWindowOuter
*
aWindow
uint32_t
aAudioChannel
)
const
;
void
AudioAudibleChanged
(
AudioChannelAgent
*
aAgent
AudibleState
aAudible
AudibleChangedReasons
aReason
)
;
bool
IsWindowActive
(
nsPIDOMWindowOuter
*
aWindow
)
;
void
RefreshAgentsVolume
(
nsPIDOMWindowOuter
*
aWindow
)
;
void
RefreshAgentsSuspend
(
nsPIDOMWindowOuter
*
aWindow
nsSuspendedTypes
aSuspend
)
;
void
SetWindowAudioCaptured
(
nsPIDOMWindowOuter
*
aWindow
uint64_t
aInnerWindowID
bool
aCapture
)
;
static
const
nsAttrValue
:
:
EnumTable
*
GetAudioChannelTable
(
)
;
static
AudioChannel
GetAudioChannel
(
const
nsAString
&
aString
)
;
static
AudioChannel
GetDefaultAudioChannel
(
)
;
void
NotifyMediaResumedFromBlock
(
nsPIDOMWindowOuter
*
aWindow
)
;
private
:
AudioChannelService
(
)
;
~
AudioChannelService
(
)
;
void
RefreshAgents
(
nsPIDOMWindowOuter
*
aWindow
const
std
:
:
function
<
void
(
AudioChannelAgent
*
)
>
&
aFunc
)
;
static
void
CreateServiceIfNeeded
(
)
;
static
void
Shutdown
(
)
;
void
RefreshAgentsAudioFocusChanged
(
AudioChannelAgent
*
aAgent
)
;
class
AudioChannelConfig
final
:
public
AudioPlaybackConfig
{
public
:
AudioChannelConfig
(
)
:
AudioPlaybackConfig
(
1
.
0
false
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
mNumberOfAgents
(
0
)
{
}
uint32_t
mNumberOfAgents
;
}
;
class
AudioChannelWindow
final
{
public
:
explicit
AudioChannelWindow
(
uint64_t
aWindowID
)
:
mWindowID
(
aWindowID
)
mIsAudioCaptured
(
false
)
mOwningAudioFocus
(
!
AudioChannelService
:
:
IsEnableAudioCompeting
(
)
)
mShouldSendActiveMediaBlockStopEvent
(
false
)
{
}
void
AudioFocusChanged
(
AudioChannelAgent
*
aNewPlayingAgent
)
;
void
AudioAudibleChanged
(
AudioChannelAgent
*
aAgent
AudibleState
aAudible
AudibleChangedReasons
aReason
)
;
void
AppendAgent
(
AudioChannelAgent
*
aAgent
AudibleState
aAudible
)
;
void
RemoveAgent
(
AudioChannelAgent
*
aAgent
)
;
void
NotifyMediaBlockStop
(
nsPIDOMWindowOuter
*
aWindow
)
;
uint64_t
mWindowID
;
bool
mIsAudioCaptured
;
AudioChannelConfig
mChannels
[
NUMBER_OF_AUDIO_CHANNELS
]
;
nsTObserverArray
<
AudioChannelAgent
*
>
mAgents
;
nsTObserverArray
<
AudioChannelAgent
*
>
mAudibleAgents
;
bool
mOwningAudioFocus
;
bool
mShouldSendActiveMediaBlockStopEvent
;
private
:
void
AudioCapturedChanged
(
AudioChannelAgent
*
aAgent
AudioCaptureState
aCapture
)
;
void
AppendAudibleAgentIfNotContained
(
AudioChannelAgent
*
aAgent
AudibleChangedReasons
aReason
)
;
void
RemoveAudibleAgentIfContained
(
AudioChannelAgent
*
aAgent
AudibleChangedReasons
aReason
)
;
void
AppendAgentAndIncreaseAgentsNum
(
AudioChannelAgent
*
aAgent
)
;
void
RemoveAgentAndReduceAgentsNum
(
AudioChannelAgent
*
aAgent
)
;
bool
IsFirstAudibleAgent
(
)
const
;
bool
IsLastAudibleAgent
(
)
const
;
void
NotifyAudioAudibleChanged
(
nsPIDOMWindowOuter
*
aWindow
AudibleState
aAudible
AudibleChangedReasons
aReason
)
;
void
NotifyChannelActive
(
uint64_t
aWindowID
bool
aActive
)
;
void
MaybeNotifyMediaBlockStart
(
AudioChannelAgent
*
aAgent
)
;
void
RequestAudioFocus
(
AudioChannelAgent
*
aAgent
)
;
void
NotifyAudioCompetingChanged
(
AudioChannelAgent
*
aAgent
)
;
uint32_t
GetCompetingBehavior
(
AudioChannelAgent
*
aAgent
int32_t
aIncomingChannelType
)
const
;
bool
IsAgentInvolvingInAudioCompeting
(
AudioChannelAgent
*
aAgent
)
const
;
bool
IsAudioCompetingInSameTab
(
)
const
;
bool
IsContainingPlayingAgent
(
AudioChannelAgent
*
aAgent
)
const
;
bool
IsInactiveWindow
(
)
const
;
}
;
AudioChannelWindow
*
GetOrCreateWindowData
(
nsPIDOMWindowOuter
*
aWindow
)
;
AudioChannelWindow
*
GetWindowData
(
uint64_t
aWindowID
)
const
;
nsTObserverArray
<
nsAutoPtr
<
AudioChannelWindow
>
>
mWindows
;
}
;
const
char
*
SuspendTypeToStr
(
const
nsSuspendedTypes
&
aSuspend
)
;
const
char
*
AudibleStateToStr
(
const
AudioChannelService
:
:
AudibleState
&
aAudible
)
;
const
char
*
AudibleChangedReasonToStr
(
const
AudioChannelService
:
:
AudibleChangedReasons
&
aReason
)
;
}
}
#
endif
