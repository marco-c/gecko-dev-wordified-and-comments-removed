#
include
"
mozilla
/
dom
/
MIDIPort
.
h
"
#
include
"
mozilla
/
dom
/
MIDIConnectionEvent
.
h
"
#
include
"
mozilla
/
dom
/
MIDIPortChild
.
h
"
#
include
"
mozilla
/
dom
/
MIDIAccess
.
h
"
#
include
"
mozilla
/
dom
/
MIDITypes
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
MIDILog
.
h
"
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
MIDIPort
DOMEventTargetHelper
mOpeningPromise
mClosingPromise
)
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
MIDIPort
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
MIDIPort
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
NS_IMPL_ADDREF_INHERITED
(
MIDIPort
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
MIDIPort
DOMEventTargetHelper
)
MIDIPort
:
:
MIDIPort
(
nsPIDOMWindowInner
*
aWindow
MIDIAccess
*
aMIDIAccessParent
)
:
DOMEventTargetHelper
(
aWindow
)
mMIDIAccessParent
(
aMIDIAccessParent
)
mKeepAlive
(
false
)
{
MOZ_ASSERT
(
aWindow
)
;
MOZ_ASSERT
(
aMIDIAccessParent
)
;
Document
*
aDoc
=
GetOwner
(
)
-
>
GetExtantDoc
(
)
;
if
(
aDoc
)
{
aDoc
-
>
DisallowBFCaching
(
)
;
}
}
MIDIPort
:
:
~
MIDIPort
(
)
{
if
(
mMIDIAccessParent
)
{
mMIDIAccessParent
-
>
RemovePortListener
(
this
)
;
mMIDIAccessParent
=
nullptr
;
}
if
(
mPort
)
{
mPort
-
>
SendShutdown
(
)
;
mPort
-
>
Teardown
(
)
;
}
}
bool
MIDIPort
:
:
Initialize
(
const
MIDIPortInfo
&
aPortInfo
bool
aSysexEnabled
)
{
nsIURI
*
uri
=
GetDocumentIfCurrent
(
)
-
>
GetDocumentURI
(
)
;
nsAutoCString
origin
;
nsresult
rv
=
nsContentUtils
:
:
GetASCIIOrigin
(
uri
origin
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
RefPtr
<
MIDIPortChild
>
port
=
new
MIDIPortChild
(
aPortInfo
aSysexEnabled
this
)
;
if
(
NS_FAILED
(
port
-
>
GenerateStableId
(
origin
)
)
)
{
return
false
;
}
PBackgroundChild
*
b
=
BackgroundChild
:
:
GetForCurrentThread
(
)
;
MOZ_ASSERT
(
b
"
Should
always
have
a
valid
BackgroundChild
when
creating
a
port
"
"
object
!
"
)
;
if
(
!
b
-
>
SendPMIDIPortConstructor
(
port
aPortInfo
aSysexEnabled
)
)
{
return
false
;
}
mPort
=
port
;
LOG
(
"
MIDIPort
:
:
Initialize
(
%
s
%
s
)
"
NS_ConvertUTF16toUTF8
(
mPort
-
>
Name
(
)
)
.
get
(
)
MIDIPortTypeValues
:
:
strings
[
uint32_t
(
mPort
-
>
Type
(
)
)
]
.
value
)
;
mPort
-
>
SetActorAlive
(
)
;
return
true
;
}
void
MIDIPort
:
:
UnsetIPCPort
(
)
{
LOG
(
"
MIDIPort
:
:
UnsetIPCPort
(
%
s
%
s
)
"
NS_ConvertUTF16toUTF8
(
mPort
-
>
Name
(
)
)
.
get
(
)
MIDIPortTypeValues
:
:
strings
[
uint32_t
(
mPort
-
>
Type
(
)
)
]
.
value
)
;
mPort
=
nullptr
;
}
void
MIDIPort
:
:
GetId
(
nsString
&
aRetVal
)
const
{
MOZ_ASSERT
(
mPort
)
;
aRetVal
=
mPort
-
>
StableId
(
)
;
}
void
MIDIPort
:
:
GetManufacturer
(
nsString
&
aRetVal
)
const
{
MOZ_ASSERT
(
mPort
)
;
aRetVal
=
mPort
-
>
Manufacturer
(
)
;
}
void
MIDIPort
:
:
GetName
(
nsString
&
aRetVal
)
const
{
MOZ_ASSERT
(
mPort
)
;
aRetVal
=
mPort
-
>
Name
(
)
;
}
void
MIDIPort
:
:
GetVersion
(
nsString
&
aRetVal
)
const
{
MOZ_ASSERT
(
mPort
)
;
aRetVal
=
mPort
-
>
Version
(
)
;
}
MIDIPortType
MIDIPort
:
:
Type
(
)
const
{
MOZ_ASSERT
(
mPort
)
;
return
mPort
-
>
Type
(
)
;
}
MIDIPortConnectionState
MIDIPort
:
:
Connection
(
)
const
{
MOZ_ASSERT
(
mPort
)
;
return
mPort
-
>
ConnectionState
(
)
;
}
MIDIPortDeviceState
MIDIPort
:
:
State
(
)
const
{
MOZ_ASSERT
(
mPort
)
;
return
mPort
-
>
DeviceState
(
)
;
}
bool
MIDIPort
:
:
SysexEnabled
(
)
const
{
MOZ_ASSERT
(
mPort
)
;
return
mPort
-
>
SysexEnabled
(
)
;
}
already_AddRefed
<
Promise
>
MIDIPort
:
:
Open
(
)
{
LOG
(
"
MIDIPort
:
:
Open
"
)
;
MOZ_ASSERT
(
mPort
)
;
RefPtr
<
Promise
>
p
;
if
(
mOpeningPromise
)
{
p
=
mOpeningPromise
;
return
p
.
forget
(
)
;
}
ErrorResult
rv
;
nsCOMPtr
<
nsIGlobalObject
>
go
=
do_QueryInterface
(
GetOwner
(
)
)
;
p
=
Promise
:
:
Create
(
go
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
mOpeningPromise
=
p
;
mPort
-
>
SendOpen
(
)
;
return
p
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
MIDIPort
:
:
Close
(
)
{
LOG
(
"
MIDIPort
:
:
Close
"
)
;
MOZ_ASSERT
(
mPort
)
;
RefPtr
<
Promise
>
p
;
if
(
mClosingPromise
)
{
p
=
mClosingPromise
;
return
p
.
forget
(
)
;
}
ErrorResult
rv
;
nsCOMPtr
<
nsIGlobalObject
>
go
=
do_QueryInterface
(
GetOwner
(
)
)
;
p
=
Promise
:
:
Create
(
go
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
mClosingPromise
=
p
;
mPort
-
>
SendClose
(
)
;
return
p
.
forget
(
)
;
}
void
MIDIPort
:
:
Notify
(
const
void_t
&
aVoid
)
{
LOG
(
"
MIDIPort
:
:
notify
MIDIAccess
shutting
down
dropping
reference
.
"
)
;
mMIDIAccessParent
=
nullptr
;
}
void
MIDIPort
:
:
FireStateChangeEvent
(
)
{
if
(
!
GetOwner
(
)
)
{
return
;
}
StateChange
(
)
;
MOZ_ASSERT
(
mPort
)
;
if
(
mPort
-
>
ConnectionState
(
)
=
=
MIDIPortConnectionState
:
:
Open
|
|
mPort
-
>
ConnectionState
(
)
=
=
MIDIPortConnectionState
:
:
Pending
)
{
if
(
mOpeningPromise
)
{
mOpeningPromise
-
>
MaybeResolve
(
this
)
;
mOpeningPromise
=
nullptr
;
}
}
else
if
(
mPort
-
>
ConnectionState
(
)
=
=
MIDIPortConnectionState
:
:
Closed
)
{
if
(
mOpeningPromise
)
{
mOpeningPromise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_ACCESS_ERR
)
;
mOpeningPromise
=
nullptr
;
}
if
(
mClosingPromise
)
{
mClosingPromise
-
>
MaybeResolve
(
this
)
;
mClosingPromise
=
nullptr
;
}
}
if
(
mPort
-
>
DeviceState
(
)
=
=
MIDIPortDeviceState
:
:
Connected
&
&
mPort
-
>
ConnectionState
(
)
=
=
MIDIPortConnectionState
:
:
Pending
)
{
mPort
-
>
SendOpen
(
)
;
}
if
(
mPort
-
>
ConnectionState
(
)
=
=
MIDIPortConnectionState
:
:
Open
|
|
(
mPort
-
>
DeviceState
(
)
=
=
MIDIPortDeviceState
:
:
Connected
&
&
mPort
-
>
ConnectionState
(
)
=
=
MIDIPortConnectionState
:
:
Pending
)
)
{
KeepAliveOnStatechange
(
)
;
}
else
{
DontKeepAliveOnStatechange
(
)
;
}
if
(
mMIDIAccessParent
)
{
mMIDIAccessParent
-
>
FireConnectionEvent
(
this
)
;
}
MIDIConnectionEventInit
init
;
init
.
mPort
=
this
;
RefPtr
<
MIDIConnectionEvent
>
event
(
MIDIConnectionEvent
:
:
Constructor
(
this
u
"
statechange
"
_ns
init
)
)
;
DispatchTrustedEvent
(
event
)
;
}
void
MIDIPort
:
:
StateChange
(
)
{
}
void
MIDIPort
:
:
Receive
(
const
nsTArray
<
MIDIMessage
>
&
aMsg
)
{
MOZ_CRASH
(
"
We
should
never
get
here
!
"
)
;
}
void
MIDIPort
:
:
DisconnectFromOwner
(
)
{
DontKeepAliveOnStatechange
(
)
;
mPort
-
>
SendClose
(
)
;
DOMEventTargetHelper
:
:
DisconnectFromOwner
(
)
;
}
void
MIDIPort
:
:
KeepAliveOnStatechange
(
)
{
if
(
!
mKeepAlive
)
{
mKeepAlive
=
true
;
KeepAliveIfHasListenersFor
(
nsGkAtoms
:
:
onstatechange
)
;
}
}
void
MIDIPort
:
:
DontKeepAliveOnStatechange
(
)
{
if
(
mKeepAlive
)
{
IgnoreKeepAliveIfHasListenersFor
(
nsGkAtoms
:
:
onstatechange
)
;
mKeepAlive
=
false
;
}
}
const
nsString
&
MIDIPort
:
:
StableId
(
)
{
return
mPort
-
>
StableId
(
)
;
}
}
