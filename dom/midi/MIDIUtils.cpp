#
include
"
mozilla
/
dom
/
MIDITypes
.
h
"
#
include
"
mozilla
/
dom
/
MIDIUtils
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
static
const
uint8_t
kCommandByte
=
0x80
;
static
const
uint8_t
kSysexMessageStart
=
0xF0
;
static
const
uint8_t
kSystemMessage
=
0xF0
;
static
const
uint8_t
kSysexMessageEnd
=
0xF7
;
static
const
uint8_t
kSystemRealtimeMessage
=
0xF8
;
static
const
uint8_t
kCommandLengths
[
]
=
{
3
3
3
3
2
2
3
}
;
static
const
uint8_t
kSystemLengths
[
]
=
{
0
2
3
2
1
1
1
1
}
;
namespace
mozilla
{
namespace
dom
{
namespace
MIDIUtils
{
bool
IsValidMessage
(
const
MIDIMessage
*
aMsg
)
{
if
(
NS_WARN_IF
(
!
aMsg
)
)
{
return
false
;
}
MOZ_ASSERT
(
aMsg
-
>
data
(
)
.
Length
(
)
>
0
"
Created
a
MIDI
Message
of
Length
0
.
This
should
never
happen
!
"
)
;
uint8_t
cmd
=
aMsg
-
>
data
(
)
[
0
]
;
MOZ_ASSERT
(
(
cmd
&
kCommandByte
)
=
=
kCommandByte
"
Constructed
a
MIDI
packet
where
first
byte
is
not
command
!
"
)
;
if
(
cmd
=
=
kSysexMessageStart
)
{
if
(
aMsg
-
>
data
(
)
[
aMsg
-
>
data
(
)
.
Length
(
)
-
1
]
!
=
kSysexMessageEnd
)
{
NS_WARNING
(
"
Last
byte
of
Sysex
Message
not
0xF7
!
"
)
;
return
false
;
}
return
true
;
}
if
(
(
cmd
&
kSystemRealtimeMessage
)
=
=
kSystemRealtimeMessage
)
{
return
aMsg
-
>
data
(
)
.
Length
(
)
=
=
1
;
}
if
(
(
cmd
&
kSystemMessage
)
=
=
kSystemMessage
)
{
if
(
cmd
-
kSystemMessage
>
=
static_cast
<
uint8_t
>
(
ArrayLength
(
kSystemLengths
)
)
)
{
NS_WARNING
(
"
System
Message
Command
byte
not
valid
!
"
)
;
return
false
;
}
return
aMsg
-
>
data
(
)
.
Length
(
)
=
=
kSystemLengths
[
cmd
-
kSystemMessage
]
;
}
uint8_t
cmdIndex
=
(
cmd
-
kCommandByte
)
>
>
4
;
if
(
cmdIndex
>
=
ArrayLength
(
kCommandLengths
)
)
{
NS_WARNING
(
"
Unknown
MIDI
command
!
"
)
;
return
false
;
}
return
aMsg
-
>
data
(
)
.
Length
(
)
=
=
kCommandLengths
[
cmdIndex
]
;
}
uint32_t
ParseMessages
(
const
nsTArray
<
uint8_t
>
&
aByteBuffer
const
TimeStamp
&
aTimestamp
nsTArray
<
MIDIMessage
>
&
aMsgArray
)
{
uint32_t
bytesRead
=
0
;
bool
inSysexMessage
=
false
;
UniquePtr
<
MIDIMessage
>
currentMsg
;
for
(
auto
&
byte
:
aByteBuffer
)
{
bytesRead
+
+
;
if
(
(
byte
&
kSystemRealtimeMessage
)
=
=
kSystemRealtimeMessage
)
{
MIDIMessage
rt_msg
;
rt_msg
.
data
(
)
.
AppendElement
(
byte
)
;
rt_msg
.
timestamp
(
)
=
aTimestamp
;
aMsgArray
.
AppendElement
(
rt_msg
)
;
continue
;
}
if
(
byte
=
=
kSysexMessageEnd
)
{
if
(
!
inSysexMessage
)
{
MOZ_ASSERT
(
inSysexMessage
)
;
NS_WARNING
(
"
Got
sysex
message
end
with
no
sysex
message
being
processed
!
"
)
;
}
inSysexMessage
=
false
;
}
else
if
(
byte
&
kCommandByte
)
{
if
(
currentMsg
&
&
IsValidMessage
(
currentMsg
.
get
(
)
)
)
{
aMsgArray
.
AppendElement
(
*
currentMsg
)
;
}
currentMsg
=
MakeUnique
<
MIDIMessage
>
(
)
;
currentMsg
-
>
timestamp
(
)
=
aTimestamp
;
}
currentMsg
-
>
data
(
)
.
AppendElement
(
byte
)
;
if
(
byte
=
=
kSysexMessageStart
)
{
inSysexMessage
=
true
;
}
}
if
(
currentMsg
&
&
IsValidMessage
(
currentMsg
.
get
(
)
)
)
{
aMsgArray
.
AppendElement
(
*
currentMsg
)
;
}
return
bytesRead
;
}
bool
IsSysexMessage
(
const
MIDIMessage
&
aMsg
)
{
if
(
aMsg
.
data
(
)
.
Length
(
)
=
=
0
)
{
return
false
;
}
if
(
aMsg
.
data
(
)
[
0
]
=
=
kSysexMessageStart
)
{
return
true
;
}
return
false
;
}
}
}
}
