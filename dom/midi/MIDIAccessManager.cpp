#
include
"
mozilla
/
dom
/
MIDIAccessManager
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
StaticPrefs_midi
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
FeaturePolicyUtils
.
h
"
#
include
"
mozilla
/
dom
/
MIDIAccess
.
h
"
#
include
"
mozilla
/
dom
/
MIDIManagerChild
.
h
"
#
include
"
mozilla
/
dom
/
MIDIPermissionRequest
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
nsIGlobalObject
.
h
"
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
:
:
dom
{
namespace
{
StaticRefPtr
<
MIDIAccessManager
>
gMIDIAccessManager
;
}
MIDIAccessManager
:
:
MIDIAccessManager
(
)
:
mHasPortList
(
false
)
mChild
(
nullptr
)
{
}
MIDIAccessManager
:
:
~
MIDIAccessManager
(
)
=
default
;
MIDIAccessManager
*
MIDIAccessManager
:
:
Get
(
)
{
if
(
!
gMIDIAccessManager
)
{
gMIDIAccessManager
=
new
MIDIAccessManager
(
)
;
ClearOnShutdown
(
&
gMIDIAccessManager
)
;
}
return
gMIDIAccessManager
;
}
bool
MIDIAccessManager
:
:
IsRunning
(
)
{
return
!
!
gMIDIAccessManager
;
}
already_AddRefed
<
Promise
>
MIDIAccessManager
:
:
RequestMIDIAccess
(
nsPIDOMWindowInner
*
aWindow
const
MIDIOptions
&
aOptions
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aWindow
)
;
nsCOMPtr
<
nsIGlobalObject
>
go
=
do_QueryInterface
(
aWindow
)
;
RefPtr
<
Promise
>
p
=
Promise
:
:
Create
(
go
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
Document
>
doc
=
aWindow
-
>
GetDoc
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
#
ifndef
MOZ_WEBMIDI_MIDIR_IMPL
if
(
!
StaticPrefs
:
:
midi_testing
(
)
)
{
aRv
.
ThrowSecurityError
(
"
Access
not
allowed
"
)
;
return
nullptr
;
}
#
endif
if
(
!
FeaturePolicyUtils
:
:
IsFeatureAllowed
(
doc
u
"
midi
"
_ns
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIRunnable
>
permRunnable
=
new
MIDIPermissionRequest
(
aWindow
p
aOptions
)
;
aRv
=
NS_DispatchToMainThread
(
permRunnable
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
return
p
.
forget
(
)
;
}
bool
MIDIAccessManager
:
:
AddObserver
(
Observer
<
MIDIPortList
>
*
aObserver
)
{
mChangeObservers
.
AddObserver
(
aObserver
)
;
if
(
!
mChild
)
{
StartActor
(
)
;
}
else
{
mChild
-
>
SendRefresh
(
)
;
}
return
true
;
}
void
MIDIAccessManager
:
:
StartActor
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mChild
)
;
:
:
mozilla
:
:
ipc
:
:
PBackgroundChild
*
pBackground
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
Endpoint
<
PMIDIManagerParent
>
parentEndpoint
;
Endpoint
<
PMIDIManagerChild
>
childEndpoint
;
MOZ_ALWAYS_SUCCEEDS
(
PMIDIManager
:
:
CreateEndpoints
(
&
parentEndpoint
&
childEndpoint
)
)
;
mChild
=
new
MIDIManagerChild
(
)
;
MOZ_ALWAYS_TRUE
(
childEndpoint
.
Bind
(
mChild
)
)
;
pBackground
-
>
SendCreateMIDIManager
(
std
:
:
move
(
parentEndpoint
)
)
;
}
void
MIDIAccessManager
:
:
RemoveObserver
(
Observer
<
MIDIPortList
>
*
aObserver
)
{
mChangeObservers
.
RemoveObserver
(
aObserver
)
;
if
(
mChangeObservers
.
Length
(
)
=
=
0
)
{
if
(
mChild
)
{
mChild
-
>
Shutdown
(
)
;
mChild
=
nullptr
;
}
gMIDIAccessManager
=
nullptr
;
}
}
void
MIDIAccessManager
:
:
SendRefresh
(
)
{
if
(
mChild
)
{
mChild
-
>
SendRefresh
(
)
;
}
}
void
MIDIAccessManager
:
:
CreateMIDIAccess
(
nsPIDOMWindowInner
*
aWindow
bool
aNeedsSysex
Promise
*
aPromise
)
{
MOZ_ASSERT
(
aWindow
)
;
MOZ_ASSERT
(
aPromise
)
;
RefPtr
<
MIDIAccess
>
a
(
new
MIDIAccess
(
aWindow
aNeedsSysex
aPromise
)
)
;
if
(
NS_WARN_IF
(
!
AddObserver
(
a
)
)
)
{
aPromise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
!
mHasPortList
)
{
mAccessHolder
.
AppendElement
(
a
)
;
}
else
{
a
-
>
Notify
(
mPortList
)
;
}
}
void
MIDIAccessManager
:
:
Update
(
const
MIDIPortList
&
aPortList
)
{
mPortList
=
aPortList
;
mChangeObservers
.
Broadcast
(
aPortList
)
;
if
(
!
mHasPortList
)
{
mHasPortList
=
true
;
mAccessHolder
.
Clear
(
)
;
}
}
}
