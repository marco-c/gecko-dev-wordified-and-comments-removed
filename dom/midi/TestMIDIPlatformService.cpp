#
include
"
TestMIDIPlatformService
.
h
"
#
include
"
mozilla
/
dom
/
MIDIPort
.
h
"
#
include
"
mozilla
/
dom
/
MIDITypes
.
h
"
#
include
"
mozilla
/
dom
/
MIDIPortInterface
.
h
"
#
include
"
mozilla
/
dom
/
MIDIPortParent
.
h
"
#
include
"
mozilla
/
dom
/
MIDIPlatformRunnables
.
h
"
#
include
"
mozilla
/
dom
/
MIDIUtils
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
ipc
;
class
ProcessMessagesRunnable
:
public
mozilla
:
:
Runnable
{
public
:
explicit
ProcessMessagesRunnable
(
const
nsAString
&
aPortID
)
:
Runnable
(
"
ProcessMessagesRunnable
"
)
mPortID
(
aPortID
)
{
}
~
ProcessMessagesRunnable
(
)
=
default
;
NS_IMETHOD
Run
(
)
{
if
(
!
MIDIPlatformService
:
:
IsRunning
(
)
)
{
return
NS_OK
;
}
TestMIDIPlatformService
*
srv
=
static_cast
<
TestMIDIPlatformService
*
>
(
MIDIPlatformService
:
:
Get
(
)
)
;
srv
-
>
ProcessMessages
(
mPortID
)
;
return
NS_OK
;
}
private
:
nsString
mPortID
;
}
;
class
QueueMessagesRunnable
:
public
MIDIBackgroundRunnable
{
public
:
QueueMessagesRunnable
(
const
nsAString
&
aPortID
const
nsTArray
<
MIDIMessage
>
&
aMsgs
)
:
MIDIBackgroundRunnable
(
"
QueueMessagesRunnable
"
)
mPortID
(
aPortID
)
mMsgs
(
aMsgs
.
Clone
(
)
)
{
}
~
QueueMessagesRunnable
(
)
=
default
;
virtual
void
RunInternal
(
)
{
AssertIsOnBackgroundThread
(
)
;
MIDIPlatformService
:
:
Get
(
)
-
>
QueueMessages
(
mPortID
mMsgs
)
;
}
private
:
nsString
mPortID
;
nsTArray
<
MIDIMessage
>
mMsgs
;
}
;
TestMIDIPlatformService
:
:
TestMIDIPlatformService
(
)
:
mBackgroundThread
(
NS_GetCurrentThread
(
)
)
mControlInputPort
(
NS_LITERAL_STRING
(
"
b744eebe
-
f7d8
-
499b
-
872b
-
958f63c8f522
"
)
NS_LITERAL_STRING
(
"
Test
Control
MIDI
Device
Input
Port
"
)
NS_LITERAL_STRING
(
"
Test
Manufacturer
"
)
NS_LITERAL_STRING
(
"
1
.
0
.
0
"
)
static_cast
<
uint32_t
>
(
MIDIPortType
:
:
Input
)
)
mControlOutputPort
(
NS_LITERAL_STRING
(
"
ab8e7fe8
-
c4de
-
436a
-
a960
-
30898a7c9a3d
"
)
NS_LITERAL_STRING
(
"
Test
Control
MIDI
Device
Output
Port
"
)
NS_LITERAL_STRING
(
"
Test
Manufacturer
"
)
NS_LITERAL_STRING
(
"
1
.
0
.
0
"
)
static_cast
<
uint32_t
>
(
MIDIPortType
:
:
Output
)
)
mStateTestInputPort
(
NS_LITERAL_STRING
(
"
a9329677
-
8588
-
4460
-
a091
-
9d4a7f629a48
"
)
NS_LITERAL_STRING
(
"
Test
State
MIDI
Device
Input
Port
"
)
NS_LITERAL_STRING
(
"
Test
Manufacturer
"
)
NS_LITERAL_STRING
(
"
1
.
0
.
0
"
)
static_cast
<
uint32_t
>
(
MIDIPortType
:
:
Input
)
)
mStateTestOutputPort
(
NS_LITERAL_STRING
(
"
478fa225
-
b5fc
-
4fa6
-
a543
-
d32d9cb651e7
"
)
NS_LITERAL_STRING
(
"
Test
State
MIDI
Device
Output
Port
"
)
NS_LITERAL_STRING
(
"
Test
Manufacturer
"
)
NS_LITERAL_STRING
(
"
1
.
0
.
0
"
)
static_cast
<
uint32_t
>
(
MIDIPortType
:
:
Output
)
)
mAlwaysClosedTestOutputPort
(
NS_LITERAL_STRING
(
"
f87d0c76
-
3c68
-
49a9
-
a44f
-
700f1125c07a
"
)
NS_LITERAL_STRING
(
"
Always
Closed
MIDI
Device
Output
Port
"
)
NS_LITERAL_STRING
(
"
Test
Manufacturer
"
)
NS_LITERAL_STRING
(
"
1
.
0
.
0
"
)
static_cast
<
uint32_t
>
(
MIDIPortType
:
:
Output
)
)
mIsInitialized
(
false
)
{
AssertIsOnBackgroundThread
(
)
;
}
TestMIDIPlatformService
:
:
~
TestMIDIPlatformService
(
)
{
AssertIsOnBackgroundThread
(
)
;
}
void
TestMIDIPlatformService
:
:
Init
(
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
mIsInitialized
)
{
return
;
}
mIsInitialized
=
true
;
MIDIPlatformService
:
:
Get
(
)
-
>
AddPortInfo
(
mControlInputPort
)
;
MIDIPlatformService
:
:
Get
(
)
-
>
AddPortInfo
(
mControlOutputPort
)
;
MIDIPlatformService
:
:
Get
(
)
-
>
AddPortInfo
(
mAlwaysClosedTestOutputPort
)
;
nsCOMPtr
<
nsIRunnable
>
r
(
new
SendPortListRunnable
(
)
)
;
NS_DispatchToCurrentThread
(
r
)
;
}
void
TestMIDIPlatformService
:
:
Open
(
MIDIPortParent
*
aPort
)
{
MOZ_ASSERT
(
aPort
)
;
MIDIPortConnectionState
s
=
MIDIPortConnectionState
:
:
Open
;
if
(
aPort
-
>
MIDIPortInterface
:
:
Id
(
)
=
=
mAlwaysClosedTestOutputPort
.
id
(
)
)
{
s
=
MIDIPortConnectionState
:
:
Closed
;
}
nsCOMPtr
<
nsIRunnable
>
r
(
new
SetStatusRunnable
(
aPort
-
>
MIDIPortInterface
:
:
Id
(
)
aPort
-
>
DeviceState
(
)
s
)
)
;
NS_DispatchToCurrentThread
(
r
)
;
}
void
TestMIDIPlatformService
:
:
ScheduleClose
(
MIDIPortParent
*
aPort
)
{
MOZ_ASSERT
(
aPort
)
;
if
(
aPort
-
>
ConnectionState
(
)
=
=
MIDIPortConnectionState
:
:
Open
)
{
nsCOMPtr
<
nsIRunnable
>
r
(
new
SetStatusRunnable
(
aPort
-
>
MIDIPortInterface
:
:
Id
(
)
aPort
-
>
DeviceState
(
)
MIDIPortConnectionState
:
:
Closed
)
)
;
NS_DispatchToCurrentThread
(
r
)
;
}
}
void
TestMIDIPlatformService
:
:
Stop
(
)
{
AssertIsOnBackgroundThread
(
)
;
}
void
TestMIDIPlatformService
:
:
ScheduleSend
(
const
nsAString
&
aPortId
)
{
nsCOMPtr
<
nsIRunnable
>
r
(
new
ProcessMessagesRunnable
(
aPortId
)
)
;
NS_DispatchToCurrentThread
(
r
)
;
}
void
TestMIDIPlatformService
:
:
ProcessMessages
(
const
nsAString
&
aPortId
)
{
nsTArray
<
MIDIMessage
>
msgs
;
GetMessagesBefore
(
aPortId
TimeStamp
:
:
Now
(
)
msgs
)
;
for
(
MIDIMessage
msg
:
msgs
)
{
if
(
aPortId
=
=
mControlOutputPort
.
id
(
)
)
{
switch
(
msg
.
data
(
)
[
0
]
)
{
case
0x90
:
switch
(
msg
.
data
(
)
[
1
]
)
{
case
0x00
:
{
nsCOMPtr
<
nsIRunnable
>
r
(
new
ReceiveRunnable
(
mControlInputPort
.
id
(
)
msg
)
)
;
mBackgroundThread
-
>
Dispatch
(
r
NS_DISPATCH_NORMAL
)
;
break
;
}
case
0x01
:
{
nsCOMPtr
<
nsIRunnable
>
r1
(
new
AddPortRunnable
(
mStateTestInputPort
)
)
;
mBackgroundThread
-
>
Dispatch
(
r1
NS_DISPATCH_NORMAL
)
;
break
;
}
case
0x02
:
{
nsCOMPtr
<
nsIRunnable
>
r1
(
new
RemovePortRunnable
(
mStateTestInputPort
)
)
;
mBackgroundThread
-
>
Dispatch
(
r1
NS_DISPATCH_NORMAL
)
;
break
;
}
case
0x03
:
{
nsTArray
<
MIDIMessage
>
newMsgs
;
nsTArray
<
uint8_t
>
msg
;
msg
.
AppendElement
(
0x90
)
;
msg
.
AppendElement
(
0x00
)
;
msg
.
AppendElement
(
0x00
)
;
TimeStamp
currentTime
=
TimeStamp
:
:
Now
(
)
;
for
(
int
i
=
0
;
i
<
=
5
;
+
+
i
)
{
newMsgs
.
AppendElement
(
MIDIMessage
(
msg
currentTime
-
TimeDuration
:
:
FromMilliseconds
(
i
*
2
)
)
)
;
}
nsCOMPtr
<
nsIRunnable
>
r
(
new
QueueMessagesRunnable
(
aPortId
newMsgs
)
)
;
mBackgroundThread
-
>
Dispatch
(
r
NS_DISPATCH_NORMAL
)
;
break
;
}
default
:
NS_WARNING
(
"
Unknown
Test
MIDI
message
received
!
"
)
;
}
break
;
case
0xF0
:
switch
(
msg
.
data
(
)
[
1
]
)
{
case
0x00
:
{
nsCOMPtr
<
nsIRunnable
>
r
(
new
ReceiveRunnable
(
mControlInputPort
.
id
(
)
msg
)
)
;
mBackgroundThread
-
>
Dispatch
(
r
NS_DISPATCH_NORMAL
)
;
break
;
}
case
0x01
:
{
nsTArray
<
uint8_t
>
msgs
;
const
uint8_t
msg
[
]
=
{
0xF0
0x01
0xF8
0x02
0x03
0x04
0xF9
0x05
0xF7
}
;
for
(
auto
&
s
:
msg
)
{
msgs
.
AppendElement
(
s
)
;
}
nsTArray
<
MIDIMessage
>
newMsgs
;
MIDIUtils
:
:
ParseMessages
(
msgs
TimeStamp
:
:
Now
(
)
newMsgs
)
;
nsCOMPtr
<
nsIRunnable
>
r
(
new
ReceiveRunnable
(
mControlInputPort
.
id
(
)
newMsgs
)
)
;
mBackgroundThread
-
>
Dispatch
(
r
NS_DISPATCH_NORMAL
)
;
break
;
}
default
:
NS_WARNING
(
"
Unknown
Test
Sysex
MIDI
message
received
!
"
)
;
}
break
;
}
}
}
}
