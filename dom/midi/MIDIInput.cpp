#
include
"
mozilla
/
dom
/
MIDIInput
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
MIDIPortChild
.
h
"
#
include
"
mozilla
/
dom
/
MIDIInputBinding
.
h
"
#
include
"
mozilla
/
dom
/
MIDIMessageEvent
.
h
"
#
include
"
mozilla
/
dom
/
MIDIMessageEventBinding
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
namespace
mozilla
:
:
dom
{
MIDIInput
:
:
MIDIInput
(
nsPIDOMWindowInner
*
aWindow
MIDIAccess
*
aMIDIAccessParent
)
:
MIDIPort
(
aWindow
aMIDIAccessParent
)
mKeepAlive
(
false
)
{
}
MIDIInput
*
MIDIInput
:
:
Create
(
nsPIDOMWindowInner
*
aWindow
MIDIAccess
*
aMIDIAccessParent
const
MIDIPortInfo
&
aPortInfo
const
bool
aSysexEnabled
)
{
MOZ_ASSERT
(
static_cast
<
MIDIPortType
>
(
aPortInfo
.
type
(
)
)
=
=
MIDIPortType
:
:
Input
)
;
auto
*
port
=
new
MIDIInput
(
aWindow
aMIDIAccessParent
)
;
if
(
!
port
-
>
Initialize
(
aPortInfo
aSysexEnabled
)
)
{
return
nullptr
;
}
return
port
;
}
JSObject
*
MIDIInput
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MIDIInput_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
MIDIInput
:
:
Receive
(
const
nsTArray
<
MIDIMessage
>
&
aMsgs
)
{
if
(
!
GetOwner
(
)
)
{
return
;
}
nsCOMPtr
<
Document
>
doc
=
GetOwner
(
)
-
>
GetDoc
(
)
;
if
(
!
doc
)
{
NS_WARNING
(
"
No
document
available
to
send
MIDIMessageEvent
to
!
"
)
;
return
;
}
for
(
const
auto
&
msg
:
aMsgs
)
{
RefPtr
<
MIDIMessageEvent
>
event
(
MIDIMessageEvent
:
:
Constructor
(
this
msg
.
timestamp
(
)
msg
.
data
(
)
)
)
;
DispatchTrustedEvent
(
event
)
;
}
}
void
MIDIInput
:
:
StateChange
(
)
{
if
(
mPort
-
>
ConnectionState
(
)
=
=
MIDIPortConnectionState
:
:
Open
|
|
(
mPort
-
>
DeviceState
(
)
=
=
MIDIPortDeviceState
:
:
Connected
&
&
mPort
-
>
ConnectionState
(
)
=
=
MIDIPortConnectionState
:
:
Pending
)
)
{
KeepAliveOnMidimessage
(
)
;
}
else
{
DontKeepAliveOnMidimessage
(
)
;
}
}
void
MIDIInput
:
:
EventListenerAdded
(
nsAtom
*
aType
)
{
if
(
aType
=
=
nsGkAtoms
:
:
onmidimessage
)
{
if
(
mPort
-
>
ConnectionState
(
)
!
=
MIDIPortConnectionState
:
:
Open
)
{
mPort
-
>
SendOpen
(
)
;
}
}
DOMEventTargetHelper
:
:
EventListenerAdded
(
aType
)
;
}
void
MIDIInput
:
:
DisconnectFromOwner
(
)
{
DontKeepAliveOnMidimessage
(
)
;
MIDIPort
:
:
DisconnectFromOwner
(
)
;
}
void
MIDIInput
:
:
KeepAliveOnMidimessage
(
)
{
if
(
!
mKeepAlive
)
{
mKeepAlive
=
true
;
KeepAliveIfHasListenersFor
(
nsGkAtoms
:
:
onmidimessage
)
;
}
}
void
MIDIInput
:
:
DontKeepAliveOnMidimessage
(
)
{
if
(
mKeepAlive
)
{
IgnoreKeepAliveIfHasListenersFor
(
nsGkAtoms
:
:
onmidimessage
)
;
mKeepAlive
=
false
;
}
}
}
