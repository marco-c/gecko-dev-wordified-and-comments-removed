#
ifndef
mozilla_CheckedUnsafePtr_h
#
define
mozilla_CheckedUnsafePtr_h
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
nsTArray
.
h
"
#
include
<
cstddef
>
#
include
<
type_traits
>
#
include
<
utility
>
namespace
mozilla
{
enum
class
CheckingSupport
{
Enabled
Disabled
}
;
template
<
typename
T
>
class
CheckedUnsafePtr
;
namespace
detail
{
class
CheckedUnsafePtrBaseCheckingEnabled
;
struct
CheckedUnsafePtrCheckData
{
using
Data
=
nsTArray
<
CheckedUnsafePtrBaseCheckingEnabled
*
>
;
DataMutex
<
Data
>
mPtrs
{
"
mozilla
:
:
SupportsCheckedUnsafePtr
"
}
;
}
;
class
CheckedUnsafePtrBaseCheckingEnabled
{
friend
class
CheckedUnsafePtrBaseAccess
;
protected
:
constexpr
CheckedUnsafePtrBaseCheckingEnabled
(
)
=
default
;
CheckedUnsafePtrBaseCheckingEnabled
(
const
CheckedUnsafePtrBaseCheckingEnabled
&
aOther
)
=
default
;
void
CopyDanglingFlagIfAvailableFrom
(
const
CheckedUnsafePtrBaseCheckingEnabled
&
aOther
)
{
mIsDangling
=
aOther
.
mIsDangling
;
}
template
<
typename
Ptr
>
using
DisableForCheckedUnsafePtr
=
std
:
:
enable_if_t
<
!
std
:
:
is_base_of
<
CheckedUnsafePtrBaseCheckingEnabled
Ptr
>
:
:
value
>
;
template
<
typename
Ptr
>
DisableForCheckedUnsafePtr
<
Ptr
>
CopyDanglingFlagIfAvailableFrom
(
const
Ptr
&
)
{
}
template
<
typename
F
>
void
WithCheckedUnsafePtrsImpl
(
CheckedUnsafePtrCheckData
*
const
aRawPtr
F
&
&
aClosure
)
{
if
(
!
mIsDangling
&
&
aRawPtr
)
{
const
auto
CheckedUnsafePtrs
=
aRawPtr
-
>
mPtrs
.
Lock
(
)
;
aClosure
(
this
*
CheckedUnsafePtrs
)
;
}
}
private
:
bool
mIsDangling
=
false
;
}
;
class
CheckedUnsafePtrBaseAccess
{
protected
:
static
void
SetDanglingFlag
(
CheckedUnsafePtrBaseCheckingEnabled
&
aBase
)
{
aBase
.
mIsDangling
=
true
;
}
}
;
template
<
typename
T
CheckingSupport
=
T
:
:
SupportsChecking
:
:
value
>
class
CheckedUnsafePtrBase
;
template
<
typename
T
typename
U
typename
S
=
std
:
:
nullptr_t
>
using
EnableIfCompatible
=
std
:
:
enable_if_t
<
std
:
:
is_base_of
<
T
std
:
:
remove_reference_t
<
decltype
(
*
std
:
:
declval
<
U
>
(
)
)
>
>
:
:
value
S
>
;
template
<
typename
T
>
class
CheckedUnsafePtrBase
<
T
CheckingSupport
:
:
Enabled
>
:
detail
:
:
CheckedUnsafePtrBaseCheckingEnabled
{
public
:
MOZ_IMPLICIT
constexpr
CheckedUnsafePtrBase
(
const
std
:
:
nullptr_t
=
nullptr
)
:
mRawPtr
(
nullptr
)
{
}
template
<
typename
U
typename
=
EnableIfCompatible
<
T
U
>
>
MOZ_IMPLICIT
CheckedUnsafePtrBase
(
const
U
&
aPtr
)
{
Set
(
aPtr
)
;
}
CheckedUnsafePtrBase
(
const
CheckedUnsafePtrBase
&
aOther
)
{
Set
(
aOther
.
Downcast
(
)
)
;
}
~
CheckedUnsafePtrBase
(
)
{
Reset
(
)
;
}
CheckedUnsafePtr
<
T
>
&
operator
=
(
const
std
:
:
nullptr_t
)
{
Reset
(
)
;
return
Downcast
(
)
;
}
template
<
typename
U
>
EnableIfCompatible
<
T
U
CheckedUnsafePtr
<
T
>
&
>
operator
=
(
const
U
&
aPtr
)
{
Replace
(
aPtr
)
;
return
Downcast
(
)
;
}
CheckedUnsafePtr
<
T
>
&
operator
=
(
const
CheckedUnsafePtr
<
T
>
&
aOther
)
{
if
(
&
aOther
!
=
this
)
{
Replace
(
aOther
)
;
}
return
Downcast
(
)
;
}
constexpr
T
*
get
(
)
const
{
return
mRawPtr
;
}
private
:
template
<
typename
U
CheckingSupport
>
friend
class
CheckedUnsafePtrBase
;
CheckedUnsafePtr
<
T
>
&
Downcast
(
)
{
return
static_cast
<
CheckedUnsafePtr
<
T
>
&
>
(
*
this
)
;
}
const
CheckedUnsafePtr
<
T
>
&
Downcast
(
)
const
{
return
static_cast
<
const
CheckedUnsafePtr
<
T
>
&
>
(
*
this
)
;
}
using
Base
=
detail
:
:
CheckedUnsafePtrBaseCheckingEnabled
;
template
<
typename
U
>
void
Replace
(
const
U
&
aPtr
)
{
Reset
(
)
;
Set
(
aPtr
)
;
}
void
Reset
(
)
{
WithCheckedUnsafePtrs
(
[
]
(
Base
*
const
aSelf
detail
:
:
CheckedUnsafePtrCheckData
:
:
Data
&
aCheckedUnsafePtrs
)
{
const
auto
index
=
aCheckedUnsafePtrs
.
IndexOf
(
aSelf
)
;
aCheckedUnsafePtrs
.
UnorderedRemoveElementAt
(
index
)
;
}
)
;
mRawPtr
=
nullptr
;
}
template
<
typename
U
>
void
Set
(
const
U
&
aPtr
)
{
this
-
>
CopyDanglingFlagIfAvailableFrom
(
aPtr
)
;
mRawPtr
=
&
*
aPtr
;
WithCheckedUnsafePtrs
(
[
]
(
Base
*
const
aSelf
detail
:
:
CheckedUnsafePtrCheckData
:
:
Data
&
aCheckedUnsafePtrs
)
{
aCheckedUnsafePtrs
.
AppendElement
(
aSelf
)
;
}
)
;
}
template
<
typename
F
>
void
WithCheckedUnsafePtrs
(
F
&
&
aClosure
)
{
this
-
>
WithCheckedUnsafePtrsImpl
(
mRawPtr
std
:
:
forward
<
F
>
(
aClosure
)
)
;
}
T
*
mRawPtr
;
}
;
template
<
typename
T
>
class
CheckedUnsafePtrBase
<
T
CheckingSupport
:
:
Disabled
>
{
public
:
MOZ_IMPLICIT
constexpr
CheckedUnsafePtrBase
(
const
std
:
:
nullptr_t
=
nullptr
)
:
mRawPtr
(
nullptr
)
{
}
template
<
typename
U
typename
=
EnableIfCompatible
<
T
U
>
>
MOZ_IMPLICIT
constexpr
CheckedUnsafePtrBase
(
const
U
&
aPtr
)
:
mRawPtr
(
aPtr
)
{
}
constexpr
CheckedUnsafePtr
<
T
>
&
operator
=
(
const
std
:
:
nullptr_t
)
{
mRawPtr
=
nullptr
;
return
Downcast
(
)
;
}
template
<
typename
U
>
constexpr
EnableIfCompatible
<
T
U
CheckedUnsafePtr
<
T
>
&
>
operator
=
(
const
U
&
aPtr
)
{
mRawPtr
=
aPtr
;
return
Downcast
(
)
;
}
constexpr
T
*
get
(
)
const
{
return
mRawPtr
;
}
private
:
constexpr
CheckedUnsafePtr
<
T
>
&
Downcast
(
)
{
return
static_cast
<
CheckedUnsafePtr
<
T
>
&
>
(
*
this
)
;
}
T
*
mRawPtr
;
}
;
}
class
CheckingPolicyAccess
{
protected
:
template
<
typename
CheckingPolicy
>
static
void
NotifyCheckFailure
(
CheckingPolicy
&
aPolicy
)
{
aPolicy
.
NotifyCheckFailure
(
)
;
}
}
;
template
<
typename
Derived
>
class
CheckCheckedUnsafePtrs
:
private
CheckingPolicyAccess
private
detail
:
:
CheckedUnsafePtrBaseAccess
{
public
:
using
SupportsChecking
=
std
:
:
integral_constant
<
CheckingSupport
CheckingSupport
:
:
Enabled
>
;
protected
:
CheckCheckedUnsafePtrs
(
)
{
static_assert
(
std
:
:
is_base_of
<
CheckCheckedUnsafePtrs
Derived
>
:
:
value
"
cannot
instantiate
with
a
type
that
'
s
not
a
subclass
of
this
class
"
)
;
}
bool
ShouldCheck
(
)
const
{
return
true
;
}
void
Check
(
detail
:
:
CheckedUnsafePtrCheckData
:
:
Data
&
aCheckedUnsafePtrs
)
{
if
(
!
aCheckedUnsafePtrs
.
IsEmpty
(
)
)
{
for
(
const
auto
aCheckedUnsafePtrBase
:
aCheckedUnsafePtrs
)
{
SetDanglingFlag
(
*
aCheckedUnsafePtrBase
)
;
}
NotifyCheckFailure
(
*
static_cast
<
Derived
*
>
(
this
)
)
;
}
}
}
;
class
CrashOnDanglingCheckedUnsafePtr
:
public
CheckCheckedUnsafePtrs
<
CrashOnDanglingCheckedUnsafePtr
>
{
friend
class
mozilla
:
:
CheckingPolicyAccess
;
void
NotifyCheckFailure
(
)
{
MOZ_CRASH
(
"
Found
dangling
CheckedUnsafePtr
"
)
;
}
}
;
struct
DoNotCheckCheckedUnsafePtrs
{
using
SupportsChecking
=
std
:
:
integral_constant
<
CheckingSupport
CheckingSupport
:
:
Disabled
>
;
}
;
namespace
detail
{
template
<
typename
CheckingPolicy
CheckingSupport
=
CheckingPolicy
:
:
SupportsChecking
:
:
value
>
class
SupportCheckedUnsafePtrImpl
;
template
<
typename
CheckingPolicy
>
class
SupportCheckedUnsafePtrImpl
<
CheckingPolicy
CheckingSupport
:
:
Disabled
>
:
public
CheckingPolicy
{
protected
:
template
<
typename
.
.
.
Args
>
explicit
SupportCheckedUnsafePtrImpl
(
Args
&
&
.
.
.
aArgs
)
:
CheckingPolicy
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
{
}
}
;
template
<
typename
CheckingPolicy
>
class
SupportCheckedUnsafePtrImpl
<
CheckingPolicy
CheckingSupport
:
:
Enabled
>
:
public
CheckedUnsafePtrCheckData
public
CheckingPolicy
{
template
<
typename
T
>
friend
class
CheckedUnsafePtr
;
protected
:
template
<
typename
.
.
.
Args
>
explicit
SupportCheckedUnsafePtrImpl
(
Args
&
&
.
.
.
aArgs
)
:
CheckingPolicy
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
{
}
~
SupportCheckedUnsafePtrImpl
(
)
{
if
(
this
-
>
ShouldCheck
(
)
)
{
const
auto
ptrs
=
mPtrs
.
Lock
(
)
;
this
-
>
Check
(
*
ptrs
)
;
}
}
}
;
struct
SupportsCheckedUnsafePtrTag
{
}
;
}
template
<
typename
Condition
typename
CheckingPolicy
=
CrashOnDanglingCheckedUnsafePtr
>
using
CheckIf
=
std
:
:
conditional_t
<
Condition
:
:
value
CheckingPolicy
DoNotCheckCheckedUnsafePtrs
>
;
using
DiagnosticAssertEnabled
=
std
:
:
integral_constant
<
bool
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
true
#
else
false
#
endif
>
;
template
<
typename
CheckingPolicy
>
class
SupportsCheckedUnsafePtr
:
public
detail
:
:
SupportCheckedUnsafePtrImpl
<
CheckingPolicy
>
public
detail
:
:
SupportsCheckedUnsafePtrTag
{
public
:
template
<
typename
.
.
.
Args
>
explicit
SupportsCheckedUnsafePtr
(
Args
&
&
.
.
.
aArgs
)
:
detail
:
:
SupportCheckedUnsafePtrImpl
<
CheckingPolicy
>
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
{
}
}
;
template
<
typename
T
>
class
CheckedUnsafePtr
:
public
detail
:
:
CheckedUnsafePtrBase
<
T
>
{
static_assert
(
std
:
:
is_base_of
<
detail
:
:
SupportsCheckedUnsafePtrTag
T
>
:
:
value
"
type
T
must
be
derived
from
instantiation
of
SupportsCheckedUnsafePtr
"
)
;
public
:
using
detail
:
:
CheckedUnsafePtrBase
<
T
>
:
:
CheckedUnsafePtrBase
;
using
detail
:
:
CheckedUnsafePtrBase
<
T
>
:
:
get
;
constexpr
T
*
operator
-
>
(
)
const
{
return
get
(
)
;
}
constexpr
T
&
operator
*
(
)
const
{
return
*
get
(
)
;
}
MOZ_IMPLICIT
constexpr
operator
T
*
(
)
const
{
return
get
(
)
;
}
template
<
typename
U
>
constexpr
bool
operator
=
=
(
detail
:
:
EnableIfCompatible
<
T
U
const
U
&
>
aRhs
)
const
{
return
get
(
)
=
=
aRhs
.
get
(
)
;
}
template
<
typename
U
>
friend
constexpr
bool
operator
=
=
(
detail
:
:
EnableIfCompatible
<
T
U
const
U
&
>
aLhs
const
CheckedUnsafePtr
&
aRhs
)
{
return
aRhs
=
=
aLhs
;
}
template
<
typename
U
>
constexpr
bool
operator
!
=
(
detail
:
:
EnableIfCompatible
<
T
U
const
U
&
>
aRhs
)
const
{
return
!
(
*
this
=
=
aRhs
)
;
}
template
<
typename
U
>
friend
constexpr
bool
operator
!
=
(
detail
:
:
EnableIfCompatible
<
T
U
const
U
&
>
aLhs
const
CheckedUnsafePtr
&
aRhs
)
{
return
aRhs
!
=
aLhs
;
}
}
;
}
DECLARE_USE_COPY_CONSTRUCTORS_FOR_TEMPLATE
(
mozilla
:
:
CheckedUnsafePtr
)
#
endif
