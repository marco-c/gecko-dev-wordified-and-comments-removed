#
include
"
Client
.
h
"
#
include
"
BackgroundParent
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
namespace
mozilla
:
:
dom
:
:
quota
{
using
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
;
namespace
{
const
char
kIDBPrefix
=
'
I
'
;
const
char
kDOMCachePrefix
=
'
C
'
;
const
char
kSDBPrefix
=
'
S
'
;
const
char
kLSPrefix
=
'
L
'
;
#
define
SHUTDOWN_FORCE_KILL_TIMEOUT_MS
5000
#
define
SHUTDOWN_FORCE_CRASH_TIMEOUT_MS
45000
template
<
Client
:
:
Type
type
>
struct
ClientTypeTraits
;
template
<
>
struct
ClientTypeTraits
<
Client
:
:
Type
:
:
IDB
>
{
template
<
typename
T
>
static
void
To
(
T
&
aData
)
{
aData
.
AssignLiteral
(
IDB_DIRECTORY_NAME
)
;
}
static
void
To
(
char
&
aData
)
{
aData
=
kIDBPrefix
;
}
template
<
typename
T
>
static
bool
From
(
const
T
&
aData
)
{
return
aData
.
EqualsLiteral
(
IDB_DIRECTORY_NAME
)
;
}
static
bool
From
(
char
aData
)
{
return
aData
=
=
kIDBPrefix
;
}
}
;
template
<
>
struct
ClientTypeTraits
<
Client
:
:
Type
:
:
DOMCACHE
>
{
template
<
typename
T
>
static
void
To
(
T
&
aData
)
{
aData
.
AssignLiteral
(
DOMCACHE_DIRECTORY_NAME
)
;
}
static
void
To
(
char
&
aData
)
{
aData
=
kDOMCachePrefix
;
}
template
<
typename
T
>
static
bool
From
(
const
T
&
aData
)
{
return
aData
.
EqualsLiteral
(
DOMCACHE_DIRECTORY_NAME
)
;
}
static
bool
From
(
char
aData
)
{
return
aData
=
=
kDOMCachePrefix
;
}
}
;
template
<
>
struct
ClientTypeTraits
<
Client
:
:
Type
:
:
SDB
>
{
template
<
typename
T
>
static
void
To
(
T
&
aData
)
{
aData
.
AssignLiteral
(
SDB_DIRECTORY_NAME
)
;
}
static
void
To
(
char
&
aData
)
{
aData
=
kSDBPrefix
;
}
template
<
typename
T
>
static
bool
From
(
const
T
&
aData
)
{
return
aData
.
EqualsLiteral
(
SDB_DIRECTORY_NAME
)
;
}
static
bool
From
(
char
aData
)
{
return
aData
=
=
kSDBPrefix
;
}
}
;
template
<
>
struct
ClientTypeTraits
<
Client
:
:
Type
:
:
LS
>
{
template
<
typename
T
>
static
void
To
(
T
&
aData
)
{
aData
.
AssignLiteral
(
LS_DIRECTORY_NAME
)
;
}
static
void
To
(
char
&
aData
)
{
aData
=
kLSPrefix
;
}
template
<
typename
T
>
static
bool
From
(
const
T
&
aData
)
{
return
aData
.
EqualsLiteral
(
LS_DIRECTORY_NAME
)
;
}
static
bool
From
(
char
aData
)
{
return
aData
=
=
kLSPrefix
;
}
}
;
template
<
typename
T
>
bool
TypeTo_impl
(
Client
:
:
Type
aType
T
&
aData
)
{
switch
(
aType
)
{
case
Client
:
:
IDB
:
ClientTypeTraits
<
Client
:
:
Type
:
:
IDB
>
:
:
To
(
aData
)
;
return
true
;
case
Client
:
:
DOMCACHE
:
ClientTypeTraits
<
Client
:
:
Type
:
:
DOMCACHE
>
:
:
To
(
aData
)
;
return
true
;
case
Client
:
:
SDB
:
ClientTypeTraits
<
Client
:
:
Type
:
:
SDB
>
:
:
To
(
aData
)
;
return
true
;
case
Client
:
:
LS
:
if
(
CachedNextGenLocalStorageEnabled
(
)
)
{
ClientTypeTraits
<
Client
:
:
Type
:
:
LS
>
:
:
To
(
aData
)
;
return
true
;
}
[
[
fallthrough
]
]
;
case
Client
:
:
TYPE_MAX
:
default
:
return
false
;
}
MOZ_CRASH
(
"
Should
never
get
here
!
"
)
;
}
template
<
typename
T
>
bool
TypeFrom_impl
(
const
T
&
aData
Client
:
:
Type
&
aType
)
{
if
(
ClientTypeTraits
<
Client
:
:
Type
:
:
IDB
>
:
:
From
(
aData
)
)
{
aType
=
Client
:
:
IDB
;
return
true
;
}
if
(
ClientTypeTraits
<
Client
:
:
Type
:
:
DOMCACHE
>
:
:
From
(
aData
)
)
{
aType
=
Client
:
:
DOMCACHE
;
return
true
;
}
if
(
ClientTypeTraits
<
Client
:
:
Type
:
:
SDB
>
:
:
From
(
aData
)
)
{
aType
=
Client
:
:
SDB
;
return
true
;
}
if
(
CachedNextGenLocalStorageEnabled
(
)
&
&
ClientTypeTraits
<
Client
:
:
Type
:
:
LS
>
:
:
From
(
aData
)
)
{
aType
=
Client
:
:
LS
;
return
true
;
}
return
false
;
}
void
BadType
(
)
{
MOZ_CRASH
(
"
Bad
client
type
value
!
"
)
;
}
}
bool
Client
:
:
IsValidType
(
Type
aType
)
{
switch
(
aType
)
{
case
Client
:
:
IDB
:
case
Client
:
:
DOMCACHE
:
case
Client
:
:
SDB
:
return
true
;
case
Client
:
:
LS
:
if
(
CachedNextGenLocalStorageEnabled
(
)
)
{
return
true
;
}
[
[
fallthrough
]
]
;
default
:
return
false
;
}
}
bool
Client
:
:
TypeToText
(
Type
aType
nsAString
&
aText
const
fallible_t
&
)
{
nsString
text
;
if
(
!
TypeTo_impl
(
aType
text
)
)
{
return
false
;
}
aText
=
text
;
return
true
;
}
void
Client
:
:
TypeToText
(
Type
aType
nsAString
&
aText
)
{
if
(
!
TypeTo_impl
(
aType
aText
)
)
{
BadType
(
)
;
}
}
void
Client
:
:
TypeToText
(
Type
aType
nsACString
&
aText
)
{
if
(
!
TypeTo_impl
(
aType
aText
)
)
{
BadType
(
)
;
}
}
bool
Client
:
:
TypeFromText
(
const
nsAString
&
aText
Type
&
aType
const
fallible_t
&
)
{
Type
type
;
if
(
!
TypeFrom_impl
(
aText
type
)
)
{
return
false
;
}
aType
=
type
;
return
true
;
}
Client
:
:
Type
Client
:
:
TypeFromText
(
const
nsACString
&
aText
)
{
Type
type
;
if
(
!
TypeFrom_impl
(
aText
type
)
)
{
BadType
(
)
;
}
return
type
;
}
char
Client
:
:
TypeToPrefix
(
Type
aType
)
{
char
prefix
;
if
(
!
TypeTo_impl
(
aType
prefix
)
)
{
BadType
(
)
;
}
return
prefix
;
}
bool
Client
:
:
TypeFromPrefix
(
char
aPrefix
Type
&
aType
const
fallible_t
&
)
{
Type
type
;
if
(
!
TypeFrom_impl
(
aPrefix
type
)
)
{
return
false
;
}
aType
=
type
;
return
true
;
}
void
Client
:
:
ShutdownWorkThreads
(
)
{
AssertIsOnBackgroundThread
(
)
;
InitiateShutdown
(
)
;
if
(
!
IsShutdownCompleted
(
)
)
{
nsCOMPtr
<
nsITimer
>
timer
=
NS_NewTimer
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
timer
-
>
InitWithNamedFuncCallback
(
[
]
(
nsITimer
*
aTimer
void
*
aClosure
)
{
auto
*
const
quotaClient
=
static_cast
<
Client
*
>
(
aClosure
)
;
quotaClient
-
>
ForceKillActors
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
aTimer
-
>
InitWithNamedFuncCallback
(
[
]
(
nsITimer
*
aTimer
void
*
aClosure
)
{
auto
*
const
quotaClient
=
static_cast
<
Client
*
>
(
aClosure
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
quotaClient
-
>
IsShutdownCompleted
(
)
)
;
quotaClient
-
>
ShutdownTimedOut
(
)
;
}
aClosure
SHUTDOWN_FORCE_CRASH_TIMEOUT_MS
nsITimer
:
:
TYPE_ONE_SHOT
"
quota
:
:
Client
:
:
ShutdownWorkThreads
:
:
ForceCrashTimer
"
)
)
;
}
this
SHUTDOWN_FORCE_KILL_TIMEOUT_MS
nsITimer
:
:
TYPE_ONE_SHOT
"
quota
:
:
Client
:
:
ShutdownWorkThreads
:
:
ForceKillTimer
"
)
)
;
MOZ_ALWAYS_TRUE
(
SpinEventLoopUntil
(
[
this
]
{
return
IsShutdownCompleted
(
)
;
}
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
timer
-
>
Cancel
(
)
)
;
}
FinalizeShutdown
(
)
;
}
}
