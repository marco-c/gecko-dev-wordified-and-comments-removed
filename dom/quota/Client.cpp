#
include
"
Client
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
quota
{
namespace
{
template
<
Client
:
:
Type
type
>
struct
ClientTypeTraits
;
template
<
>
struct
ClientTypeTraits
<
Client
:
:
Type
:
:
IDB
>
{
template
<
typename
T
>
static
void
To
(
T
&
aData
)
{
aData
.
AssignLiteral
(
IDB_DIRECTORY_NAME
)
;
}
template
<
typename
T
>
static
bool
From
(
const
T
&
aData
)
{
return
aData
.
EqualsLiteral
(
IDB_DIRECTORY_NAME
)
;
}
}
;
template
<
>
struct
ClientTypeTraits
<
Client
:
:
Type
:
:
DOMCACHE
>
{
template
<
typename
T
>
static
void
To
(
T
&
aData
)
{
aData
.
AssignLiteral
(
DOMCACHE_DIRECTORY_NAME
)
;
}
template
<
typename
T
>
static
bool
From
(
const
T
&
aData
)
{
return
aData
.
EqualsLiteral
(
DOMCACHE_DIRECTORY_NAME
)
;
}
}
;
template
<
>
struct
ClientTypeTraits
<
Client
:
:
Type
:
:
SDB
>
{
template
<
typename
T
>
static
void
To
(
T
&
aData
)
{
aData
.
AssignLiteral
(
SDB_DIRECTORY_NAME
)
;
}
template
<
typename
T
>
static
bool
From
(
const
T
&
aData
)
{
return
aData
.
EqualsLiteral
(
SDB_DIRECTORY_NAME
)
;
}
}
;
template
<
>
struct
ClientTypeTraits
<
Client
:
:
Type
:
:
LS
>
{
template
<
typename
T
>
static
void
To
(
T
&
aData
)
{
aData
.
AssignLiteral
(
LS_DIRECTORY_NAME
)
;
}
template
<
typename
T
>
static
bool
From
(
const
T
&
aData
)
{
return
aData
.
EqualsLiteral
(
LS_DIRECTORY_NAME
)
;
}
}
;
template
<
typename
T
>
bool
TypeTo_impl
(
Client
:
:
Type
aType
T
&
aData
)
{
switch
(
aType
)
{
case
Client
:
:
IDB
:
ClientTypeTraits
<
Client
:
:
Type
:
:
IDB
>
:
:
To
(
aData
)
;
return
true
;
case
Client
:
:
DOMCACHE
:
ClientTypeTraits
<
Client
:
:
Type
:
:
DOMCACHE
>
:
:
To
(
aData
)
;
return
true
;
case
Client
:
:
SDB
:
ClientTypeTraits
<
Client
:
:
Type
:
:
SDB
>
:
:
To
(
aData
)
;
return
true
;
case
Client
:
:
LS
:
if
(
CachedNextGenLocalStorageEnabled
(
)
)
{
ClientTypeTraits
<
Client
:
:
Type
:
:
LS
>
:
:
To
(
aData
)
;
return
true
;
}
MOZ_FALLTHROUGH
;
case
Client
:
:
TYPE_MAX
:
default
:
return
false
;
}
MOZ_CRASH
(
"
Should
never
get
here
!
"
)
;
}
template
<
typename
T
>
bool
TypeFrom_impl
(
const
T
&
aData
Client
:
:
Type
&
aType
)
{
if
(
ClientTypeTraits
<
Client
:
:
Type
:
:
IDB
>
:
:
From
(
aData
)
)
{
aType
=
Client
:
:
IDB
;
return
true
;
}
if
(
ClientTypeTraits
<
Client
:
:
Type
:
:
DOMCACHE
>
:
:
From
(
aData
)
)
{
aType
=
Client
:
:
DOMCACHE
;
return
true
;
}
if
(
ClientTypeTraits
<
Client
:
:
Type
:
:
SDB
>
:
:
From
(
aData
)
)
{
aType
=
Client
:
:
SDB
;
return
true
;
}
if
(
CachedNextGenLocalStorageEnabled
(
)
&
&
ClientTypeTraits
<
Client
:
:
Type
:
:
LS
>
:
:
From
(
aData
)
)
{
aType
=
Client
:
:
LS
;
return
true
;
}
return
false
;
}
void
BadType
(
)
{
MOZ_CRASH
(
"
Bad
client
type
value
!
"
)
;
}
}
bool
Client
:
:
TypeToText
(
Type
aType
nsAString
&
aText
const
fallible_t
&
)
{
nsString
text
;
if
(
!
TypeTo_impl
(
aType
text
)
)
{
return
false
;
}
aText
=
text
;
return
true
;
}
void
Client
:
:
TypeToText
(
Type
aType
nsAString
&
aText
)
{
if
(
!
TypeTo_impl
(
aType
aText
)
)
{
BadType
(
)
;
}
}
void
Client
:
:
TypeToText
(
Type
aType
nsACString
&
aText
)
{
if
(
!
TypeTo_impl
(
aType
aText
)
)
{
BadType
(
)
;
}
}
bool
Client
:
:
TypeFromText
(
const
nsAString
&
aText
Type
&
aType
const
fallible_t
&
)
{
Type
type
;
if
(
!
TypeFrom_impl
(
aText
type
)
)
{
return
false
;
}
aType
=
type
;
return
true
;
}
Client
:
:
Type
Client
:
:
TypeFromText
(
const
nsACString
&
aText
)
{
Type
type
;
if
(
!
TypeFrom_impl
(
aText
type
)
)
{
BadType
(
)
;
}
return
type
;
}
}
}
}
