#
include
"
ScopedLogExtraInfo
.
h
"
namespace
mozilla
:
:
dom
:
:
quota
{
#
ifdef
QM_SCOPED_LOG_EXTRA_INFO_ENABLED
MOZ_THREAD_LOCAL
(
const
Tainted
<
nsCString
>
*
)
ScopedLogExtraInfo
:
:
sQueryValueTainted
;
MOZ_THREAD_LOCAL
(
const
Tainted
<
nsCString
>
*
)
ScopedLogExtraInfo
:
:
sContextValueTainted
;
auto
ScopedLogExtraInfo
:
:
FindSlot
(
const
char
*
aTag
)
{
if
(
aTag
=
=
kTagQueryTainted
)
{
return
&
sQueryValueTainted
;
}
if
(
aTag
=
=
kTagContextTainted
)
{
return
&
sContextValueTainted
;
}
MOZ_CRASH
(
"
Unknown
tag
!
"
)
;
}
ScopedLogExtraInfo
:
:
~
ScopedLogExtraInfo
(
)
{
if
(
mTag
)
{
MOZ_ASSERT
(
&
mCurrentValue
=
=
FindSlot
(
mTag
)
-
>
get
(
)
"
Bad
scoping
of
ScopedLogExtraInfo
must
not
be
interleaved
!
"
)
;
FindSlot
(
mTag
)
-
>
set
(
mPreviousValue
)
;
}
}
ScopedLogExtraInfo
:
:
ScopedLogExtraInfo
(
ScopedLogExtraInfo
&
&
aOther
)
noexcept
:
mTag
(
aOther
.
mTag
)
mPreviousValue
(
aOther
.
mPreviousValue
)
mCurrentValue
(
std
:
:
move
(
aOther
.
mCurrentValue
)
)
{
aOther
.
mTag
=
nullptr
;
FindSlot
(
mTag
)
-
>
set
(
&
mCurrentValue
)
;
}
ScopedLogExtraInfo
:
:
ScopedLogExtraInfoMap
ScopedLogExtraInfo
:
:
GetExtraInfoMap
(
)
{
ScopedLogExtraInfoMap
map
;
if
(
sQueryValueTainted
.
get
(
)
)
{
map
.
emplace
(
kTagQueryTainted
sQueryValueTainted
.
get
(
)
)
;
}
if
(
sContextValueTainted
.
get
(
)
)
{
map
.
emplace
(
kTagContextTainted
sContextValueTainted
.
get
(
)
)
;
}
return
map
;
}
void
ScopedLogExtraInfo
:
:
Initialize
(
)
{
MOZ_ALWAYS_TRUE
(
sQueryValueTainted
.
init
(
)
)
;
MOZ_ALWAYS_TRUE
(
sContextValueTainted
.
init
(
)
)
;
}
void
ScopedLogExtraInfo
:
:
AddInfo
(
)
{
auto
*
slot
=
FindSlot
(
mTag
)
;
MOZ_ASSERT
(
slot
)
;
mPreviousValue
=
slot
-
>
get
(
)
;
slot
-
>
set
(
&
mCurrentValue
)
;
}
#
endif
}
