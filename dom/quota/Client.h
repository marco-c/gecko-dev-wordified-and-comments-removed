#
ifndef
mozilla_dom_quota_client_h__
#
define
mozilla_dom_quota_client_h__
#
include
<
cstdint
>
#
include
"
ErrorList
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
LocalStorageCommon
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
PersistenceType
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaCommon
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTHashtable
.
h
"
class
nsIFile
;
#
define
IDB_DIRECTORY_NAME
"
idb
"
#
define
DOMCACHE_DIRECTORY_NAME
"
cache
"
#
define
SDB_DIRECTORY_NAME
"
sdb
"
#
define
LS_DIRECTORY_NAME
"
ls
"
#
define
ASMJSCACHE_DIRECTORY_NAME
"
asmjs
"
namespace
mozilla
:
:
dom
{
template
<
typename
T
>
struct
Nullable
;
}
BEGIN_QUOTA_NAMESPACE
class
OriginScope
;
class
QuotaManager
;
class
UsageInfo
;
struct
GroupAndOrigin
;
class
Client
{
public
:
typedef
Atomic
<
bool
>
AtomicBool
;
enum
Type
{
IDB
=
0
DOMCACHE
SDB
LS
TYPE_MAX
}
;
class
DirectoryLockIdTable
final
{
nsTHashtable
<
nsUint64HashKey
>
mIds
;
public
:
void
Put
(
const
int64_t
aId
)
{
mIds
.
PutEntry
(
aId
)
;
}
bool
Has
(
const
int64_t
aId
)
const
{
return
mIds
.
Contains
(
aId
)
;
}
bool
Filled
(
)
const
{
return
mIds
.
Count
(
)
;
}
}
;
static
Type
TypeMax
(
)
{
if
(
CachedNextGenLocalStorageEnabled
(
)
)
{
return
TYPE_MAX
;
}
return
LS
;
}
static
bool
IsValidType
(
Type
aType
)
;
static
bool
TypeToText
(
Type
aType
nsAString
&
aText
const
fallible_t
&
)
;
static
nsAutoCString
TypeToText
(
Type
aType
)
;
static
bool
TypeFromText
(
const
nsAString
&
aText
Type
&
aType
const
fallible_t
&
)
;
static
Type
TypeFromText
(
const
nsACString
&
aText
)
;
static
char
TypeToPrefix
(
Type
aType
)
;
static
bool
TypeFromPrefix
(
char
aPrefix
Type
&
aType
const
fallible_t
&
)
;
static
bool
IsDeprecatedClient
(
const
nsAString
&
aText
)
{
return
aText
.
EqualsLiteral
(
ASMJSCACHE_DIRECTORY_NAME
)
;
}
template
<
typename
T
>
static
bool
IsLockForObjectContainedInLockTable
(
const
T
&
aObject
const
DirectoryLockIdTable
&
aIds
)
{
const
auto
&
maybeDirectoryLock
=
aObject
.
MaybeDirectoryLockRef
(
)
;
MOZ_ASSERT
(
maybeDirectoryLock
.
isSome
(
)
)
;
return
aIds
.
Has
(
maybeDirectoryLock
-
>
Id
(
)
)
;
}
template
<
typename
T
>
static
bool
IsLockForObjectAcquiredAndContainedInLockTable
(
const
T
&
aObject
const
DirectoryLockIdTable
&
aIds
)
{
const
auto
&
maybeDirectoryLock
=
aObject
.
MaybeDirectoryLockRef
(
)
;
return
maybeDirectoryLock
&
&
aIds
.
Has
(
maybeDirectoryLock
-
>
Id
(
)
)
;
}
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
virtual
Type
GetType
(
)
=
0
;
virtual
nsresult
UpgradeStorageFrom1_0To2_0
(
nsIFile
*
aDirectory
)
{
return
NS_OK
;
}
virtual
nsresult
UpgradeStorageFrom2_0To2_1
(
nsIFile
*
aDirectory
)
{
return
NS_OK
;
}
virtual
nsresult
UpgradeStorageFrom2_1To2_2
(
nsIFile
*
aDirectory
)
{
return
NS_OK
;
}
virtual
Result
<
UsageInfo
nsresult
>
InitOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
=
0
;
virtual
nsresult
InitOriginWithoutTracking
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
=
0
;
virtual
Result
<
UsageInfo
nsresult
>
GetUsageForOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
=
0
;
virtual
nsresult
AboutToClearOrigins
(
const
Nullable
<
PersistenceType
>
&
aPersistenceType
const
OriginScope
&
aOriginScope
)
{
return
NS_OK
;
}
virtual
void
OnOriginClearCompleted
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
)
=
0
;
virtual
void
ReleaseIOThreadObjects
(
)
=
0
;
virtual
void
AbortOperationsForLocks
(
const
DirectoryLockIdTable
&
aDirectoryLockIds
)
=
0
;
virtual
void
AbortOperationsForProcess
(
ContentParentId
aContentParentId
)
=
0
;
virtual
void
AbortAllOperations
(
)
=
0
;
virtual
void
StartIdleMaintenance
(
)
=
0
;
virtual
void
StopIdleMaintenance
(
)
=
0
;
bool
InitiateShutdownWorkThreads
(
)
;
void
FinalizeShutdownWorkThreads
(
)
;
virtual
nsCString
GetShutdownStatus
(
)
const
=
0
;
virtual
bool
IsShutdownCompleted
(
)
const
=
0
;
virtual
void
ForceKillActors
(
)
=
0
;
private
:
virtual
void
InitiateShutdown
(
)
=
0
;
virtual
void
FinalizeShutdown
(
)
=
0
;
protected
:
virtual
~
Client
(
)
=
default
;
}
;
END_QUOTA_NAMESPACE
#
endif
