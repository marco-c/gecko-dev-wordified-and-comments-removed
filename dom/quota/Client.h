#
ifndef
mozilla_dom_quota_client_h__
#
define
mozilla_dom_quota_client_h__
#
include
<
cstdint
>
#
include
"
ErrorList
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
InitializedOnce
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
LocalStorageCommon
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
PersistenceType
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaCommon
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaInfo
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsStringFwd
.
h
"
class
nsIFile
;
#
define
IDB_DIRECTORY_NAME
"
idb
"
#
define
DOMCACHE_DIRECTORY_NAME
"
cache
"
#
define
SDB_DIRECTORY_NAME
"
sdb
"
#
define
LS_DIRECTORY_NAME
"
ls
"
#
define
ASMJSCACHE_DIRECTORY_NAME
"
asmjs
"
namespace
mozilla
:
:
dom
{
template
<
typename
T
>
struct
Nullable
;
}
BEGIN_QUOTA_NAMESPACE
class
OriginScope
;
class
QuotaManager
;
class
UsageInfo
;
class
Client
{
public
:
typedef
Atomic
<
bool
>
AtomicBool
;
enum
Type
{
IDB
=
0
DOMCACHE
SDB
LS
TYPE_MAX
}
;
static
Type
TypeMax
(
)
{
if
(
CachedNextGenLocalStorageEnabled
(
)
)
{
return
TYPE_MAX
;
}
return
LS
;
}
static
bool
IsValidType
(
Type
aType
)
;
static
bool
TypeToText
(
Type
aType
nsAString
&
aText
const
fallible_t
&
)
;
static
nsAutoCString
TypeToText
(
Type
aType
)
;
static
bool
TypeFromText
(
const
nsAString
&
aText
Type
&
aType
const
fallible_t
&
)
;
static
Type
TypeFromText
(
const
nsACString
&
aText
)
;
static
char
TypeToPrefix
(
Type
aType
)
;
static
bool
TypeFromPrefix
(
char
aPrefix
Type
&
aType
const
fallible_t
&
)
;
static
bool
IsDeprecatedClient
(
const
nsAString
&
aText
)
{
return
aText
.
EqualsLiteral
(
ASMJSCACHE_DIRECTORY_NAME
)
;
}
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
virtual
Type
GetType
(
)
=
0
;
virtual
nsresult
UpgradeStorageFrom1_0To2_0
(
nsIFile
*
aDirectory
)
{
return
NS_OK
;
}
virtual
nsresult
UpgradeStorageFrom2_0To2_1
(
nsIFile
*
aDirectory
)
{
return
NS_OK
;
}
virtual
nsresult
UpgradeStorageFrom2_1To2_2
(
nsIFile
*
aDirectory
)
{
return
NS_OK
;
}
virtual
Result
<
UsageInfo
nsresult
>
InitOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
=
0
;
virtual
nsresult
InitOriginWithoutTracking
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
=
0
;
virtual
Result
<
UsageInfo
nsresult
>
GetUsageForOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
=
0
;
virtual
nsresult
AboutToClearOrigins
(
const
Nullable
<
PersistenceType
>
&
aPersistenceType
const
OriginScope
&
aOriginScope
)
{
return
NS_OK
;
}
virtual
void
OnOriginClearCompleted
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
)
=
0
;
virtual
void
ReleaseIOThreadObjects
(
)
=
0
;
virtual
void
AbortOperations
(
const
nsACString
&
aOrigin
)
=
0
;
virtual
void
AbortOperationsForProcess
(
ContentParentId
aContentParentId
)
=
0
;
virtual
void
StartIdleMaintenance
(
)
=
0
;
virtual
void
StopIdleMaintenance
(
)
=
0
;
void
ShutdownWorkThreads
(
)
;
void
MaybeRecordShutdownStep
(
const
nsACString
&
aStepDescription
)
;
private
:
virtual
void
InitiateShutdown
(
)
=
0
;
virtual
bool
IsShutdownCompleted
(
)
const
=
0
;
virtual
nsCString
GetShutdownStatus
(
)
const
=
0
;
virtual
void
ForceKillActors
(
)
=
0
;
virtual
void
FinalizeShutdown
(
)
=
0
;
nsCString
mShutdownSteps
;
LazyInitializedOnce
<
const
TimeStamp
>
mShutdownStartedAt
;
protected
:
virtual
~
Client
(
)
=
default
;
}
;
END_QUOTA_NAMESPACE
#
endif
