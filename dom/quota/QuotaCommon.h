#
ifndef
mozilla_dom_quota_quotacommon_h__
#
define
mozilla_dom_quota_quotacommon_h__
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
define
MOZ_UNIQUE_VAR
(
base
)
MOZ_CONCAT
(
base
__COUNTER__
)
#
define
MOZ_REMOVE_PAREN
(
X
)
MOZ_REMOVE_PAREN_HELPER2
(
MOZ_REMOVE_PAREN_HELPER
X
)
#
define
MOZ_REMOVE_PAREN_HELPER
(
.
.
.
)
MOZ_REMOVE_PAREN_HELPER
__VA_ARGS__
#
define
MOZ_REMOVE_PAREN_HELPER2
(
.
.
.
)
MOZ_REMOVE_PAREN_HELPER3
(
__VA_ARGS__
)
#
define
MOZ_REMOVE_PAREN_HELPER3
(
.
.
.
)
MOZ_REMOVE_PAREN_HELPER4_
#
#
__VA_ARGS__
#
define
MOZ_REMOVE_PAREN_HELPER4_MOZ_REMOVE_PAREN_HELPER
#
define
MOZ_SELECT_OVERLOAD
(
func
)
\
[
]
(
auto
&
&
.
.
.
aArgs
)
-
>
decltype
(
auto
)
{
\
return
func
(
std
:
:
forward
<
decltype
(
aArgs
)
>
(
aArgs
)
.
.
.
)
;
\
}
#
define
BEGIN_QUOTA_NAMESPACE
\
namespace
mozilla
{
\
namespace
dom
{
\
namespace
quota
{
#
define
END_QUOTA_NAMESPACE
\
}
/
*
namespace
quota
*
/
\
}
/
*
namespace
dom
*
/
\
}
/
*
namespace
mozilla
*
/
#
define
USING_QUOTA_NAMESPACE
using
namespace
mozilla
:
:
dom
:
:
quota
;
#
define
DSSTORE_FILE_NAME
"
.
DS_Store
"
#
define
DESKTOP_FILE_NAME
"
.
desktop
"
#
define
DESKTOP_INI_FILE_NAME
"
desktop
.
ini
"
#
define
THUMBS_DB_FILE_NAME
"
thumbs
.
db
"
#
define
QM_WARNING
(
.
.
.
)
\
do
{
\
nsPrintfCString
str
(
__VA_ARGS__
)
;
\
mozilla
:
:
dom
:
:
quota
:
:
ReportInternalError
(
__FILE__
__LINE__
str
.
get
(
)
)
;
\
NS_WARNING
(
str
.
get
(
)
)
;
\
}
while
(
0
)
#
define
UNKNOWN_FILE_WARNING
(
_leafName
)
\
NS_WARNING
(
\
nsPrintfCString
(
"
Something
(
%
s
)
in
the
directory
that
doesn
'
t
belong
!
"
\
NS_ConvertUTF16toUTF8
(
_leafName
)
.
get
(
)
)
\
.
get
(
)
)
#
ifdef
DEBUG
#
define
WARN_IF_FILE_IS_UNKNOWN
(
_file
)
\
mozilla
:
:
dom
:
:
quota
:
:
WarnIfFileIsUnknown
(
_file
__FILE__
__LINE__
)
#
else
#
define
WARN_IF_FILE_IS_UNKNOWN
(
_file
)
Result
<
bool
nsresult
>
(
false
)
#
endif
#
define
QM_VOID
#
define
QM_PROPAGATE
tryTempResult
.
propagateErr
(
)
#
define
QM_MISSING_ARGS
(
.
.
.
)
\
do
{
\
static_assert
(
false
"
Did
you
forget
arguments
?
"
)
;
\
}
while
(
0
)
#
ifdef
DEBUG
#
define
QM_HANDLE_ERROR
(
expr
)
HandleError
(
#
expr
__FILE__
__LINE__
)
#
else
#
define
QM_HANDLE_ERROR
(
expr
)
HandleError
(
"
Unavailable
"
__FILE__
__LINE__
)
#
endif
#
define
QM_TRY_PROPAGATE_ERR
(
ns
tryResult
expr
)
\
auto
tryResult
=
:
:
mozilla
:
:
ToResult
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
tryResult
.
isErr
(
)
)
)
{
\
ns
:
:
QM_HANDLE_ERROR
(
expr
)
;
\
return
tryResult
.
propagateErr
(
)
;
\
}
#
define
QM_TRY_CUSTOM_RET_VAL
(
ns
tryResult
expr
customRetVal
)
\
auto
tryResult
=
:
:
mozilla
:
:
ToResult
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
tryResult
.
isErr
(
)
)
)
{
\
auto
tryTempResult
MOZ_MAYBE_UNUSED
=
std
:
:
move
(
tryResult
)
;
\
ns
:
:
QM_HANDLE_ERROR
(
expr
)
;
\
return
customRetVal
;
\
}
#
define
QM_TRY_CUSTOM_RET_VAL_WITH_CLEANUP
(
ns
tryResult
expr
customRetVal
\
cleanup
)
\
auto
tryResult
=
:
:
mozilla
:
:
ToResult
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
tryResult
.
isErr
(
)
)
)
{
\
auto
tryTempResult
MOZ_MAYBE_UNUSED
=
std
:
:
move
(
tryResult
)
;
\
ns
:
:
QM_HANDLE_ERROR
(
expr
)
;
\
cleanup
(
tryTempResult
)
;
\
return
customRetVal
;
\
}
#
define
QM_TRY_META
(
.
.
.
)
\
{
\
MOZ_ARG_7
(
#
#
__VA_ARGS__
\
QM_TRY_CUSTOM_RET_VAL_WITH_CLEANUP
(
__VA_ARGS__
)
\
QM_TRY_CUSTOM_RET_VAL
(
__VA_ARGS__
)
\
QM_TRY_PROPAGATE_ERR
(
__VA_ARGS__
)
QM_MISSING_ARGS
(
__VA_ARGS__
)
\
QM_MISSING_ARGS
(
__VA_ARGS__
)
QM_MISSING_ARGS
(
__VA_ARGS__
)
)
\
}
#
define
QM_TRY_GLUE
(
.
.
.
)
\
QM_TRY_META
(
mozilla
:
:
dom
:
:
quota
MOZ_UNIQUE_VAR
(
tryResult
)
#
#
__VA_ARGS__
)
#
define
QM_TRY
(
.
.
.
)
QM_TRY_GLUE
(
__VA_ARGS__
)
#
ifdef
DEBUG
#
define
QM_DEBUG_TRY
(
.
.
.
)
QM_TRY
(
__VA_ARGS__
)
#
else
#
define
QM_DEBUG_TRY
(
.
.
.
)
#
endif
#
define
QM_TRY_VAR_PROPAGATE_ERR
(
ns
tryResult
target
expr
)
\
auto
tryResult
=
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
tryResult
.
isErr
(
)
)
)
{
\
ns
:
:
QM_HANDLE_ERROR
(
expr
)
;
\
return
tryResult
.
propagateErr
(
)
;
\
}
\
MOZ_REMOVE_PAREN
(
target
)
=
tryResult
.
unwrap
(
)
;
#
define
QM_TRY_VAR_CUSTOM_RET_VAL
(
ns
tryResult
target
expr
customRetVal
)
\
auto
tryResult
=
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
tryResult
.
isErr
(
)
)
)
{
\
auto
tryTempResult
MOZ_MAYBE_UNUSED
=
std
:
:
move
(
tryResult
)
;
\
ns
:
:
QM_HANDLE_ERROR
(
expr
)
;
\
return
customRetVal
;
\
}
\
MOZ_REMOVE_PAREN
(
target
)
=
tryResult
.
unwrap
(
)
;
#
define
QM_TRY_VAR_CUSTOM_RET_VAL_WITH_CLEANUP
(
ns
tryResult
target
expr
\
customRetVal
cleanup
)
\
auto
tryResult
=
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
tryResult
.
isErr
(
)
)
)
{
\
auto
tryTempResult
MOZ_MAYBE_UNUSED
=
std
:
:
move
(
tryResult
)
;
\
ns
:
:
QM_HANDLE_ERROR
(
expr
)
;
\
cleanup
(
tryTempResult
)
;
\
return
customRetVal
;
\
}
\
MOZ_REMOVE_PAREN
(
target
)
=
tryResult
.
unwrap
(
)
;
#
define
QM_TRY_VAR_META
(
.
.
.
)
\
MOZ_ARG_8
(
#
#
__VA_ARGS__
\
QM_TRY_VAR_CUSTOM_RET_VAL_WITH_CLEANUP
(
__VA_ARGS__
)
\
QM_TRY_VAR_CUSTOM_RET_VAL
(
__VA_ARGS__
)
\
QM_TRY_VAR_PROPAGATE_ERR
(
__VA_ARGS__
)
\
QM_MISSING_ARGS
(
__VA_ARGS__
)
QM_MISSING_ARGS
(
__VA_ARGS__
)
\
QM_MISSING_ARGS
(
__VA_ARGS__
)
QM_MISSING_ARGS
(
__VA_ARGS__
)
)
#
define
QM_TRY_VAR_GLUE
(
.
.
.
)
\
QM_TRY_VAR_META
(
mozilla
:
:
dom
:
:
quota
MOZ_UNIQUE_VAR
(
tryResult
)
#
#
__VA_ARGS__
)
#
define
QM_TRY_VAR
(
.
.
.
)
QM_TRY_VAR_GLUE
(
__VA_ARGS__
)
#
ifdef
DEBUG
#
define
QM_DEBUG_TRY_VAR
(
.
.
.
)
QM_TRY_VAR
(
__VA_ARGS__
)
#
else
#
define
QM_DEBUG_TRY_VAR
(
.
.
.
)
#
endif
#
define
QM_FAIL_RET_VAL
(
ns
retVal
)
\
ns
:
:
QM_HANDLE_ERROR
(
Failure
)
;
\
return
retVal
;
#
define
QM_FAIL_RET_VAL_WITH_CLEANUP
(
ns
retVal
cleanup
)
\
ns
:
:
QM_HANDLE_ERROR
(
Failure
)
;
\
cleanup
(
)
;
\
return
retVal
;
#
define
QM_FAIL_META
(
.
.
.
)
\
MOZ_ARG_5
(
#
#
__VA_ARGS__
QM_FAIL_RET_VAL_WITH_CLEANUP
(
__VA_ARGS__
)
\
QM_FAIL_RET_VAL
(
__VA_ARGS__
)
QM_MISSING_ARGS
(
__VA_ARGS__
)
)
#
define
QM_FAIL_GLUE
(
.
.
.
)
QM_FAIL_META
(
mozilla
:
:
dom
:
:
quota
#
#
__VA_ARGS__
)
#
define
QM_FAIL
(
.
.
.
)
QM_FAIL_GLUE
(
__VA_ARGS__
)
#
ifdef
DEBUG
#
define
QM_DEBUG_FAIL
(
.
.
.
)
QM_FAIL
(
__VA_ARGS__
)
#
else
#
define
QM_DEBUG_FAIL
(
.
.
.
)
#
endif
#
ifdef
NIGHTLY_BUILD
#
define
REPORT_TELEMETRY_INIT_ERR
(
_key
_label
)
\
mozilla
:
:
Telemetry
:
:
AccumulateCategoricalKeyed
(
\
mozilla
:
:
dom
:
:
quota
:
:
_key
\
mozilla
:
:
Telemetry
:
:
LABELS_QM_INIT_TELEMETRY_ERROR
:
:
_label
)
;
#
define
REPORT_TELEMETRY_ERR_IN_INIT
(
_initializing
_key
_label
)
\
do
{
\
if
(
_initializing
)
{
\
REPORT_TELEMETRY_INIT_ERR
(
_key
_label
)
\
}
\
}
while
(
0
)
#
define
RECORD_IN_NIGHTLY
(
_recorder
_status
)
\
do
{
\
if
(
NS_SUCCEEDED
(
_recorder
)
)
{
\
_recorder
=
_status
;
\
}
\
}
while
(
0
)
#
define
CONTINUE_IN_NIGHTLY_RETURN_IN_OTHERS
(
_dummy
)
continue
#
define
RETURN_STATUS_OR_RESULT
(
_status
_rv
)
\
return
NS_FAILED
(
_status
)
?
_status
:
_rv
#
else
#
define
REPORT_TELEMETRY_INIT_ERR
(
_key
_label
)
\
{
}
#
define
REPORT_TELEMETRY_ERR_IN_INIT
(
_initializing
_key
_label
)
\
{
}
#
define
RECORD_IN_NIGHTLY
(
_dummy
_status
)
\
{
}
#
define
CONTINUE_IN_NIGHTLY_RETURN_IN_OTHERS
(
_rv
)
return
_rv
#
define
RETURN_STATUS_OR_RESULT
(
_status
_rv
)
return
_rv
#
endif
class
nsIEventTarget
;
class
nsIFile
;
namespace
mozilla
{
class
LogModule
;
struct
NotOk
{
}
;
inline
Result
<
Ok
NotOk
>
OkIf
(
bool
aValue
)
{
if
(
aValue
)
{
return
Ok
(
)
;
}
return
Err
(
NotOk
(
)
)
;
}
template
<
auto
SuccessValue
>
auto
OkToOk
(
Ok
)
-
>
Result
<
decltype
(
SuccessValue
)
nsresult
>
{
return
SuccessValue
;
}
template
<
nsresult
ErrorValue
auto
SuccessValue
typename
V
=
decltype
(
SuccessValue
)
>
auto
ErrToOkOrErr
(
nsresult
aValue
)
-
>
Result
<
V
nsresult
>
{
if
(
aValue
=
=
ErrorValue
)
{
return
V
{
SuccessValue
}
;
}
return
Err
(
aValue
)
;
}
template
<
nsresult
ErrorValue
typename
V
>
auto
ErrToDefaultOkOrErr
(
nsresult
aValue
)
-
>
Result
<
V
nsresult
>
{
if
(
aValue
=
=
ErrorValue
)
{
return
V
{
}
;
}
return
Err
(
aValue
)
;
}
template
<
typename
R
typename
Func
typename
.
.
.
Args
>
Result
<
R
nsresult
>
ToResultGet
(
const
Func
&
aFunc
Args
&
&
.
.
.
aArgs
)
{
nsresult
rv
;
R
res
=
aFunc
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
return
res
;
}
template
<
typename
Step
typename
Body
>
auto
CollectEach
(
const
Step
&
aStep
const
Body
&
aBody
)
-
>
Result
<
mozilla
:
:
Ok
typename
std
:
:
result_of_t
<
Step
(
)
>
:
:
err_type
>
{
using
StepResultType
=
typename
std
:
:
result_of_t
<
Step
(
)
>
:
:
ok_type
;
static_assert
(
std
:
:
is_empty_v
<
typename
std
:
:
result_of_t
<
Body
(
StepResultType
&
&
)
>
:
:
ok_type
>
)
;
while
(
true
)
{
StepResultType
element
;
MOZ_TRY_VAR
(
element
aStep
(
)
)
;
if
(
!
static_cast
<
bool
>
(
element
)
)
{
break
;
}
MOZ_TRY
(
aBody
(
std
:
:
move
(
element
)
)
)
;
}
return
mozilla
:
:
Ok
{
}
;
}
template
<
typename
Cond
typename
Body
>
auto
CollectWhile
(
const
Cond
&
aCond
const
Body
&
aBody
)
-
>
Result
<
mozilla
:
:
Ok
typename
std
:
:
result_of_t
<
Cond
(
)
>
:
:
err_type
>
{
return
CollectEach
(
aCond
[
&
aBody
]
(
bool
)
{
return
aBody
(
)
;
}
)
;
}
template
<
>
class
MOZ_MUST_USE_TYPE
GenericErrorResult
<
mozilla
:
:
ipc
:
:
IPCResult
>
{
mozilla
:
:
ipc
:
:
IPCResult
mErrorValue
;
template
<
typename
V
typename
E2
>
friend
class
Result
;
public
:
explicit
GenericErrorResult
(
mozilla
:
:
ipc
:
:
IPCResult
aErrorValue
)
:
mErrorValue
(
aErrorValue
)
{
MOZ_ASSERT
(
!
aErrorValue
)
;
}
operator
mozilla
:
:
ipc
:
:
IPCResult
(
)
const
{
return
mErrorValue
;
}
}
;
namespace
dom
{
namespace
quota
{
extern
const
char
kQuotaGenericDelimiter
;
#
ifdef
NIGHTLY_BUILD
extern
const
nsLiteralCString
kQuotaInternalError
;
extern
const
nsLiteralCString
kQuotaExternalError
;
#
else
#
define
kQuotaInternalError
#
define
kQuotaExternalError
#
endif
class
BackgroundThreadObject
{
protected
:
nsCOMPtr
<
nsIEventTarget
>
mOwningThread
;
public
:
void
AssertIsOnOwningThread
(
)
const
#
ifdef
DEBUG
;
#
else
{
}
#
endif
nsIEventTarget
*
OwningThread
(
)
const
;
protected
:
BackgroundThreadObject
(
)
;
explicit
BackgroundThreadObject
(
nsIEventTarget
*
aOwningThread
)
;
}
;
void
AssertIsOnIOThread
(
)
;
void
AssertCurrentThreadOwnsQuotaMutex
(
)
;
bool
IsOnIOThread
(
)
;
MOZ_COLD
void
ReportInternalError
(
const
char
*
aFile
uint32_t
aLine
const
char
*
aStr
)
;
LogModule
*
GetQuotaManagerLogger
(
)
;
void
AnonymizeCString
(
nsACString
&
aCString
)
;
inline
auto
AnonymizedCString
(
const
nsACString
&
aCString
)
{
nsAutoCString
result
{
aCString
}
;
AnonymizeCString
(
result
)
;
return
result
;
}
void
AnonymizeOriginString
(
nsACString
&
aOriginString
)
;
inline
auto
AnonymizedOriginString
(
const
nsACString
&
aOriginString
)
{
nsAutoCString
result
{
aOriginString
}
;
AnonymizeOriginString
(
result
)
;
return
result
;
}
template
<
typename
T
>
void
StringifyTableKeys
(
const
T
&
aTable
nsACString
&
aResult
)
{
bool
first
=
true
;
for
(
auto
iter
=
aTable
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
first
)
{
first
=
false
;
}
else
{
aResult
.
Append
(
"
"
_ns
)
;
}
const
auto
&
key
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
aResult
.
Append
(
key
)
;
}
}
#
ifdef
XP_WIN
void
CacheUseDOSDevicePathSyntaxPrefValue
(
)
;
#
endif
Result
<
nsCOMPtr
<
nsIFile
>
nsresult
>
QM_NewLocalFile
(
const
nsAString
&
aPath
)
;
class
IntString
:
public
nsAutoString
{
public
:
explicit
IntString
(
int64_t
aInteger
)
{
AppendInt
(
aInteger
)
;
}
}
;
class
IntCString
:
public
nsAutoCString
{
public
:
explicit
IntCString
(
int64_t
aInteger
)
{
AppendInt
(
aInteger
)
;
}
}
;
nsAutoString
GetIntString
(
const
int64_t
aInteger
)
;
nsAutoCString
GetIntCString
(
const
int64_t
aInteger
)
;
nsDependentCSubstring
GetLeafName
(
const
nsACString
&
aPath
)
;
void
LogError
(
const
nsLiteralCString
&
aModule
const
nsACString
&
aExpr
const
nsACString
&
aSourceFile
int32_t
aSourceLine
)
;
#
ifdef
DEBUG
Result
<
bool
nsresult
>
WarnIfFileIsUnknown
(
nsIFile
&
aFile
const
char
*
aSourceFile
int32_t
aSourceLine
)
;
#
endif
#
if
defined
(
EARLY_BETA_OR_EARLIER
)
|
|
defined
(
DEBUG
)
#
define
QM_META_HANDLE_ERROR
(
module
)
\
MOZ_COLD
inline
void
HandleError
(
\
const
char
*
aExpr
const
char
*
aSourceFile
int32_t
aSourceLine
)
{
\
mozilla
:
:
dom
:
:
quota
:
:
LogError
(
module
nsDependentCString
(
aExpr
)
\
nsDependentCString
(
aSourceFile
)
\
aSourceLine
)
;
\
}
#
else
#
define
QM_META_HANDLE_ERROR
(
module
)
\
MOZ_ALWAYS_INLINE
constexpr
void
HandleError
(
\
const
char
*
aExpr
const
char
*
aSourceFile
int32_t
aSourceLine
)
{
}
#
endif
QM_META_HANDLE_ERROR
(
"
QuotaManager
"
_ns
)
}
}
}
#
endif
