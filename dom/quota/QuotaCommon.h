#
ifndef
mozilla_dom_quota_quotacommon_h__
#
define
mozilla_dom_quota_quotacommon_h__
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
define
MOZ_ARG_5
(
a1
a2
a3
a4
a5
.
.
.
)
a5
#
define
MOZ_ARG_6
(
a1
a2
a3
a4
a5
a6
.
.
.
)
a6
#
define
BEGIN_QUOTA_NAMESPACE
\
namespace
mozilla
{
\
namespace
dom
{
\
namespace
quota
{
#
define
END_QUOTA_NAMESPACE
\
}
/
*
namespace
quota
*
/
\
}
/
*
namespace
dom
*
/
\
}
/
*
namespace
mozilla
*
/
#
define
USING_QUOTA_NAMESPACE
using
namespace
mozilla
:
:
dom
:
:
quota
;
#
define
DSSTORE_FILE_NAME
"
.
DS_Store
"
#
define
DESKTOP_FILE_NAME
"
.
desktop
"
#
define
DESKTOP_INI_FILE_NAME
"
desktop
.
ini
"
#
define
THUMBS_DB_FILE_NAME
"
thumbs
.
db
"
#
define
QM_WARNING
(
.
.
.
)
\
do
{
\
nsPrintfCString
str
(
__VA_ARGS__
)
;
\
mozilla
:
:
dom
:
:
quota
:
:
ReportInternalError
(
__FILE__
__LINE__
str
.
get
(
)
)
;
\
NS_WARNING
(
str
.
get
(
)
)
;
\
}
while
(
0
)
#
define
UNKNOWN_FILE_WARNING
(
_leafName
)
\
NS_WARNING
(
\
nsPrintfCString
(
"
Something
(
%
s
)
in
the
directory
that
doesn
'
t
belong
!
"
\
NS_ConvertUTF16toUTF8
(
_leafName
)
.
get
(
)
)
\
.
get
(
)
)
#
ifdef
DEBUG
#
define
WARN_IF_FILE_IS_UNKNOWN
(
_file
)
\
mozilla
:
:
dom
:
:
quota
:
:
WarnIfFileIsUnknown
(
_file
__FILE__
__LINE__
)
#
else
#
define
WARN_IF_FILE_IS_UNKNOWN
(
_file
)
Result
<
bool
nsresult
>
(
false
)
#
endif
#
define
QM_VOID
#
define
QM_MISSING_ARGS
(
.
.
.
)
\
do
{
\
static_assert
(
false
"
Did
you
forget
arguments
?
"
)
;
\
}
while
(
0
)
#
define
QM_TRY_PROPAGATE_ERR
(
ns
expr
)
\
do
{
\
auto
mozTryTempResult_
=
:
:
mozilla
:
:
ToResult
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
mozTryTempResult_
.
isErr
(
)
)
)
{
\
ns
:
:
HandleError
(
nsLiteralCString
(
#
expr
)
nsLiteralCString
(
__FILE__
)
\
__LINE__
)
;
\
return
mozTryTempResult_
.
propagateErr
(
)
;
\
}
\
}
while
(
0
)
#
define
QM_TRY_CUSTOM_RET_VAR
(
ns
expr
customRetVal
)
\
do
{
\
auto
mozTryTempResult_
=
:
:
mozilla
:
:
ToResult
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
mozTryTempResult_
.
isErr
(
)
)
)
{
\
ns
:
:
HandleError
(
nsLiteralCString
(
#
expr
)
nsLiteralCString
(
__FILE__
)
\
__LINE__
)
;
\
return
customRetVal
;
\
}
\
}
while
(
0
)
#
define
QM_TRY_META
(
.
.
.
)
\
MOZ_ARG_5
(
#
#
__VA_ARGS__
QM_TRY_CUSTOM_RET_VAR
(
__VA_ARGS__
)
\
QM_TRY_PROPAGATE_ERR
(
__VA_ARGS__
)
QM_MISSING_ARGS
(
__VA_ARGS__
)
\
QM_MISSING_ARGS
(
__VA_ARGS__
)
)
#
define
QM_TRY
(
.
.
.
)
QM_TRY_META
(
mozilla
:
:
dom
:
:
quota
#
#
__VA_ARGS__
)
#
define
QM_TRY_VAR_PROPAGATE_ERR
(
ns
target
expr
)
\
do
{
\
auto
mozTryVarTempResult_
=
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
mozTryVarTempResult_
.
isErr
(
)
)
)
{
\
ns
:
:
HandleError
(
nsLiteralCString
(
#
expr
)
nsLiteralCString
(
__FILE__
)
\
__LINE__
)
;
\
return
mozTryVarTempResult_
.
propagateErr
(
)
;
\
}
\
(
target
)
=
mozTryVarTempResult_
.
unwrap
(
)
;
\
}
while
(
0
)
#
define
QM_TRY_VAR_CUSTOM_RET_VAR
(
ns
target
expr
customRetVal
)
\
do
{
\
auto
mozTryVarTempResult_
=
(
expr
)
;
\
if
(
MOZ_UNLIKELY
(
mozTryVarTempResult_
.
isErr
(
)
)
)
{
\
ns
:
:
HandleError
(
nsLiteralCString
(
#
expr
)
nsLiteralCString
(
__FILE__
)
\
__LINE__
)
;
\
return
customRetVal
;
\
}
\
(
target
)
=
mozTryVarTempResult_
.
unwrap
(
)
;
\
}
while
(
0
)
#
define
QM_TRY_VAR_META
(
.
.
.
)
\
MOZ_ARG_6
(
#
#
__VA_ARGS__
QM_TRY_VAR_CUSTOM_RET_VAR
(
__VA_ARGS__
)
\
QM_TRY_VAR_PROPAGATE_ERR
(
__VA_ARGS__
)
\
QM_MISSING_ARGS
(
__VA_ARGS__
)
QM_MISSING_ARGS
(
__VA_ARGS__
)
\
QM_MISSING_ARGS
(
__VA_ARGS__
)
)
#
define
QM_TRY_VAR
(
.
.
.
)
QM_TRY_VAR_META
(
mozilla
:
:
dom
:
:
quota
#
#
__VA_ARGS__
)
#
ifdef
NIGHTLY_BUILD
#
define
REPORT_TELEMETRY_INIT_ERR
(
_key
_label
)
\
mozilla
:
:
Telemetry
:
:
AccumulateCategoricalKeyed
(
\
mozilla
:
:
dom
:
:
quota
:
:
_key
\
mozilla
:
:
Telemetry
:
:
LABELS_QM_INIT_TELEMETRY_ERROR
:
:
_label
)
;
#
define
REPORT_TELEMETRY_ERR_IN_INIT
(
_initializing
_key
_label
)
\
do
{
\
if
(
_initializing
)
{
\
REPORT_TELEMETRY_INIT_ERR
(
_key
_label
)
\
}
\
}
while
(
0
)
#
define
RECORD_IN_NIGHTLY
(
_recorder
_status
)
\
do
{
\
if
(
NS_SUCCEEDED
(
_recorder
)
)
{
\
_recorder
=
_status
;
\
}
\
}
while
(
0
)
#
define
CONTINUE_IN_NIGHTLY_RETURN_IN_OTHERS
(
_dummy
)
continue
#
define
RETURN_STATUS_OR_RESULT
(
_status
_rv
)
\
return
NS_FAILED
(
_status
)
?
_status
:
_rv
#
else
#
define
REPORT_TELEMETRY_INIT_ERR
(
_key
_label
)
\
{
}
#
define
REPORT_TELEMETRY_ERR_IN_INIT
(
_initializing
_key
_label
)
\
{
}
#
define
RECORD_IN_NIGHTLY
(
_dummy
_status
)
\
{
}
#
define
CONTINUE_IN_NIGHTLY_RETURN_IN_OTHERS
(
_rv
)
return
_rv
#
define
RETURN_STATUS_OR_RESULT
(
_status
_rv
)
return
_rv
#
endif
class
nsIEventTarget
;
class
nsIFile
;
namespace
mozilla
{
class
LogModule
;
struct
NotOk
{
}
;
inline
Result
<
Ok
NotOk
>
OkIf
(
bool
aValue
)
{
if
(
aValue
)
{
return
Ok
(
)
;
}
return
Err
(
NotOk
(
)
)
;
}
class
Okish
{
const
bool
mEnforced
;
public
:
explicit
Okish
(
bool
aEnforced
)
:
mEnforced
(
aEnforced
)
{
}
MOZ_IMPLICIT
operator
bool
(
)
const
{
return
mEnforced
;
}
}
;
template
<
typename
SuccessEnforcer
>
Result
<
Okish
nsresult
>
ToResult
(
nsresult
aValue
const
SuccessEnforcer
&
aSuccessEnforcer
)
{
if
(
NS_SUCCEEDED
(
aValue
)
)
{
return
Okish
(
false
)
;
}
if
(
aSuccessEnforcer
(
aValue
)
)
{
return
Okish
(
true
)
;
}
return
Err
(
aValue
)
;
}
namespace
dom
{
namespace
quota
{
extern
const
char
kQuotaGenericDelimiter
;
#
ifdef
NIGHTLY_BUILD
extern
const
nsLiteralCString
kQuotaInternalError
;
extern
const
nsLiteralCString
kQuotaExternalError
;
#
else
#
define
kQuotaInternalError
#
define
kQuotaExternalError
#
endif
class
BackgroundThreadObject
{
protected
:
nsCOMPtr
<
nsIEventTarget
>
mOwningThread
;
public
:
void
AssertIsOnOwningThread
(
)
const
#
ifdef
DEBUG
;
#
else
{
}
#
endif
nsIEventTarget
*
OwningThread
(
)
const
;
protected
:
BackgroundThreadObject
(
)
;
explicit
BackgroundThreadObject
(
nsIEventTarget
*
aOwningThread
)
;
}
;
void
AssertIsOnIOThread
(
)
;
void
AssertCurrentThreadOwnsQuotaMutex
(
)
;
bool
IsOnIOThread
(
)
;
void
ReportInternalError
(
const
char
*
aFile
uint32_t
aLine
const
char
*
aStr
)
;
LogModule
*
GetQuotaManagerLogger
(
)
;
void
AnonymizeCString
(
nsACString
&
aCString
)
;
class
AnonymizedCString
:
public
nsCString
{
public
:
explicit
AnonymizedCString
(
const
nsACString
&
aCString
)
:
nsCString
(
aCString
)
{
AnonymizeCString
(
*
this
)
;
}
}
;
void
AnonymizeOriginString
(
nsACString
&
aOriginString
)
;
class
AnonymizedOriginString
:
public
nsCString
{
public
:
explicit
AnonymizedOriginString
(
const
nsACString
&
aOriginString
)
:
nsCString
(
aOriginString
)
{
AnonymizeOriginString
(
*
this
)
;
}
}
;
template
<
typename
T
>
void
StringifyTableKeys
(
const
T
&
aTable
nsACString
&
aResult
)
{
bool
first
=
true
;
for
(
auto
iter
=
aTable
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
first
)
{
first
=
false
;
}
else
{
aResult
.
Append
(
"
"
_ns
)
;
}
const
auto
&
key
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
aResult
.
Append
(
key
)
;
}
}
#
ifdef
XP_WIN
void
CacheUseDOSDevicePathSyntaxPrefValue
(
)
;
#
endif
Result
<
nsCOMPtr
<
nsIFile
>
nsresult
>
QM_NewLocalFile
(
const
nsAString
&
aPath
)
;
class
IntString
:
public
nsAutoString
{
public
:
explicit
IntString
(
int64_t
aInteger
)
{
AppendInt
(
aInteger
)
;
}
}
;
class
IntCString
:
public
nsAutoCString
{
public
:
explicit
IntCString
(
int64_t
aInteger
)
{
AppendInt
(
aInteger
)
;
}
}
;
#
ifdef
DEBUG
Result
<
bool
nsresult
>
WarnIfFileIsUnknown
(
nsIFile
&
aFile
const
char
*
aSourceFile
int32_t
aSourceLine
)
;
#
endif
void
HandleError
(
const
nsLiteralCString
&
aExpr
const
nsLiteralCString
&
aSourceFile
int32_t
aSourceLine
)
;
}
}
}
#
endif
