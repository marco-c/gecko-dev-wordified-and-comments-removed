#
include
"
QuotaCommon
.
h
"
#
include
"
mozIStorageConnection
.
h
"
#
include
"
mozIStorageStatement
.
h
"
#
include
"
mozilla
/
ErrorNames
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TelemetryComms
.
h
"
#
include
"
mozilla
/
TelemetryEventEnums
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsStringFlags
.
h
"
#
include
"
nsTStringRepr
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
nsILocalFileWin
.
h
"
#
endif
namespace
mozilla
:
:
dom
:
:
quota
{
using
namespace
mozilla
:
:
Telemetry
;
namespace
{
#
ifdef
DEBUG
constexpr
auto
kDSStoreFileName
=
u
"
.
DS_Store
"
_ns
;
constexpr
auto
kDesktopFileName
=
u
"
.
desktop
"
_ns
;
constexpr
auto
kDesktopIniFileName
=
u
"
desktop
.
ini
"
_ns
;
constexpr
auto
kThumbsDbFileName
=
u
"
thumbs
.
db
"
_ns
;
#
endif
#
ifdef
XP_WIN
Atomic
<
int32_t
>
gUseDOSDevicePathSyntax
(
-
1
)
;
#
endif
LazyLogModule
gLogger
(
"
QuotaManager
"
)
;
void
AnonymizeCString
(
nsACString
&
aCString
uint32_t
aStart
)
{
MOZ_ASSERT
(
!
aCString
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aStart
<
aCString
.
Length
(
)
)
;
char
*
iter
=
aCString
.
BeginWriting
(
)
+
aStart
;
char
*
end
=
aCString
.
EndWriting
(
)
;
while
(
iter
!
=
end
)
{
char
c
=
*
iter
;
if
(
IsAsciiAlpha
(
c
)
)
{
*
iter
=
'
a
'
;
}
else
if
(
IsAsciiDigit
(
c
)
)
{
*
iter
=
'
D
'
;
}
+
+
iter
;
}
}
}
const
char
kQuotaGenericDelimiter
=
'
|
'
;
#
ifdef
NIGHTLY_BUILD
const
nsLiteralCString
kQuotaInternalError
=
"
internal
"
_ns
;
const
nsLiteralCString
kQuotaExternalError
=
"
external
"
_ns
;
#
endif
LogModule
*
GetQuotaManagerLogger
(
)
{
return
gLogger
;
}
void
AnonymizeCString
(
nsACString
&
aCString
)
{
if
(
aCString
.
IsEmpty
(
)
)
{
return
;
}
AnonymizeCString
(
aCString
0
)
;
}
void
AnonymizeOriginString
(
nsACString
&
aOriginString
)
{
if
(
aOriginString
.
IsEmpty
(
)
)
{
return
;
}
int32_t
start
=
aOriginString
.
FindChar
(
'
:
'
)
;
if
(
start
<
0
)
{
start
=
0
;
}
AnonymizeCString
(
aOriginString
start
)
;
}
#
ifdef
XP_WIN
void
CacheUseDOSDevicePathSyntaxPrefValue
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
AssertIsOnBackgroundThread
(
)
;
if
(
gUseDOSDevicePathSyntax
=
=
-
1
)
{
bool
useDOSDevicePathSyntax
=
StaticPrefs
:
:
dom_quotaManager_useDOSDevicePathSyntax_DoNotUseDirectly
(
)
;
gUseDOSDevicePathSyntax
=
useDOSDevicePathSyntax
?
1
:
0
;
}
}
#
endif
Result
<
nsCOMPtr
<
nsIFile
>
nsresult
>
QM_NewLocalFile
(
const
nsAString
&
aPath
)
{
QM_TRY_UNWRAP
(
auto
file
ToResultInvoke
<
nsCOMPtr
<
nsIFile
>
>
(
NS_NewLocalFile
aPath
false
)
QM_PROPAGATE
[
&
aPath
]
(
const
nsresult
rv
)
{
QM_WARNING
(
"
Failed
to
construct
a
file
for
path
(
%
s
)
"
NS_ConvertUTF16toUTF8
(
aPath
)
.
get
(
)
)
;
}
)
;
#
ifdef
XP_WIN
MOZ_ASSERT
(
gUseDOSDevicePathSyntax
!
=
-
1
)
;
if
(
gUseDOSDevicePathSyntax
)
{
QM_TRY_INSPECT
(
const
auto
&
winFile
ToResultGet
<
nsCOMPtr
<
nsILocalFileWin
>
>
(
MOZ_SELECT_OVERLOAD
(
do_QueryInterface
)
file
)
)
;
MOZ_ASSERT
(
winFile
)
;
winFile
-
>
SetUseDOSDevicePathSyntax
(
true
)
;
}
#
endif
return
file
;
}
nsDependentCSubstring
GetLeafName
(
const
nsACString
&
aPath
)
{
nsACString
:
:
const_iterator
start
end
;
aPath
.
BeginReading
(
start
)
;
aPath
.
EndReading
(
end
)
;
bool
found
=
RFindInReadable
(
"
/
"
_ns
start
end
)
;
if
(
found
)
{
start
=
end
;
}
aPath
.
EndReading
(
end
)
;
return
nsDependentCSubstring
(
start
.
get
(
)
end
.
get
(
)
)
;
}
Result
<
nsCOMPtr
<
nsIFile
>
nsresult
>
CloneFileAndAppend
(
nsIFile
&
aDirectory
const
nsAString
&
aPathElement
)
{
QM_TRY_UNWRAP
(
auto
resultFile
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCOMPtr
<
nsIFile
>
aDirectory
Clone
)
)
;
QM_TRY
(
resultFile
-
>
Append
(
aPathElement
)
)
;
return
resultFile
;
}
Result
<
nsIFileKind
nsresult
>
GetDirEntryKind
(
nsIFile
&
aFile
)
{
QM_TRY_RETURN
(
QM_OR_ELSE_WARN
(
MOZ_TO_RESULT_INVOKE
(
aFile
IsDirectory
)
.
map
(
[
]
(
const
bool
isDirectory
)
{
return
isDirectory
?
nsIFileKind
:
:
ExistsAsDirectory
:
nsIFileKind
:
:
ExistsAsFile
;
}
)
(
[
]
(
const
nsresult
rv
)
-
>
Result
<
nsIFileKind
nsresult
>
{
if
(
rv
=
=
NS_ERROR_FILE_NOT_FOUND
|
|
rv
=
=
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
#
ifdef
WIN32
|
|
(
NS_ERROR_GET_MODULE
(
rv
)
=
=
NS_ERROR_MODULE_WIN32
&
&
NS_ERROR_GET_CODE
(
rv
)
=
=
ERROR_FILE_CORRUPT
)
#
endif
)
{
return
nsIFileKind
:
:
DoesNotExist
;
}
return
Err
(
rv
)
;
}
)
)
)
;
}
Result
<
nsCOMPtr
<
mozIStorageStatement
>
nsresult
>
CreateStatement
(
mozIStorageConnection
&
aConnection
const
nsACString
&
aStatementString
)
{
QM_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCOMPtr
<
mozIStorageStatement
>
aConnection
CreateStatement
aStatementString
)
)
;
}
template
<
SingleStepResult
ResultHandling
>
Result
<
SingleStepSuccessType
<
ResultHandling
>
nsresult
>
ExecuteSingleStep
(
nsCOMPtr
<
mozIStorageStatement
>
&
&
aStatement
)
{
QM_TRY_INSPECT
(
const
bool
&
hasResult
MOZ_TO_RESULT_INVOKE
(
aStatement
ExecuteStep
)
)
;
if
constexpr
(
ResultHandling
=
=
SingleStepResult
:
:
AssertHasResult
)
{
MOZ_ASSERT
(
hasResult
)
;
(
void
)
hasResult
;
return
WrapNotNullUnchecked
(
std
:
:
move
(
aStatement
)
)
;
}
else
{
return
hasResult
?
std
:
:
move
(
aStatement
)
:
nullptr
;
}
}
template
Result
<
SingleStepSuccessType
<
SingleStepResult
:
:
AssertHasResult
>
nsresult
>
ExecuteSingleStep
<
SingleStepResult
:
:
AssertHasResult
>
(
nsCOMPtr
<
mozIStorageStatement
>
&
&
)
;
template
Result
<
SingleStepSuccessType
<
SingleStepResult
:
:
ReturnNullIfNoResult
>
nsresult
>
ExecuteSingleStep
<
SingleStepResult
:
:
ReturnNullIfNoResult
>
(
nsCOMPtr
<
mozIStorageStatement
>
&
&
)
;
template
<
SingleStepResult
ResultHandling
>
Result
<
SingleStepSuccessType
<
ResultHandling
>
nsresult
>
CreateAndExecuteSingleStepStatement
(
mozIStorageConnection
&
aConnection
const
nsACString
&
aStatementString
)
{
QM_TRY_UNWRAP
(
auto
stmt
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCOMPtr
<
mozIStorageStatement
>
aConnection
CreateStatement
aStatementString
)
)
;
return
ExecuteSingleStep
<
ResultHandling
>
(
std
:
:
move
(
stmt
)
)
;
}
template
Result
<
SingleStepSuccessType
<
SingleStepResult
:
:
AssertHasResult
>
nsresult
>
CreateAndExecuteSingleStepStatement
<
SingleStepResult
:
:
AssertHasResult
>
(
mozIStorageConnection
&
aConnection
const
nsACString
&
aStatementString
)
;
template
Result
<
SingleStepSuccessType
<
SingleStepResult
:
:
ReturnNullIfNoResult
>
nsresult
>
CreateAndExecuteSingleStepStatement
<
SingleStepResult
:
:
ReturnNullIfNoResult
>
(
mozIStorageConnection
&
aConnection
const
nsACString
&
aStatementString
)
;
#
ifdef
QM_ENABLE_SCOPED_LOG_EXTRA_INFO
MOZ_THREAD_LOCAL
(
const
nsACString
*
)
ScopedLogExtraInfo
:
:
sQueryValue
;
MOZ_THREAD_LOCAL
(
const
nsACString
*
)
ScopedLogExtraInfo
:
:
sContextValue
;
auto
ScopedLogExtraInfo
:
:
FindSlot
(
const
char
*
aTag
)
{
if
(
aTag
=
=
kTagQuery
)
{
return
&
sQueryValue
;
}
if
(
aTag
=
=
kTagContext
)
{
return
&
sContextValue
;
}
MOZ_CRASH
(
"
Unknown
tag
!
"
)
;
}
ScopedLogExtraInfo
:
:
~
ScopedLogExtraInfo
(
)
{
if
(
mTag
)
{
MOZ_ASSERT
(
&
mCurrentValue
=
=
FindSlot
(
mTag
)
-
>
get
(
)
"
Bad
scoping
of
ScopedLogExtraInfo
must
not
be
interleaved
!
"
)
;
FindSlot
(
mTag
)
-
>
set
(
mPreviousValue
)
;
}
}
ScopedLogExtraInfo
:
:
ScopedLogExtraInfo
(
ScopedLogExtraInfo
&
&
aOther
)
:
mTag
(
aOther
.
mTag
)
mPreviousValue
(
aOther
.
mPreviousValue
)
mCurrentValue
(
std
:
:
move
(
aOther
.
mCurrentValue
)
)
{
aOther
.
mTag
=
nullptr
;
FindSlot
(
mTag
)
-
>
set
(
&
mCurrentValue
)
;
}
ScopedLogExtraInfo
:
:
ScopedLogExtraInfoMap
ScopedLogExtraInfo
:
:
GetExtraInfoMap
(
)
{
ScopedLogExtraInfoMap
map
;
if
(
XRE_IsParentProcess
(
)
)
{
if
(
sQueryValue
.
get
(
)
)
{
map
.
emplace
(
kTagQuery
sQueryValue
.
get
(
)
)
;
}
if
(
sContextValue
.
get
(
)
)
{
map
.
emplace
(
kTagContext
sContextValue
.
get
(
)
)
;
}
}
return
map
;
}
void
ScopedLogExtraInfo
:
:
Initialize
(
)
{
MOZ_ALWAYS_TRUE
(
sQueryValue
.
init
(
)
)
;
MOZ_ALWAYS_TRUE
(
sContextValue
.
init
(
)
)
;
}
void
ScopedLogExtraInfo
:
:
AddInfo
(
)
{
auto
*
slot
=
FindSlot
(
mTag
)
;
MOZ_ASSERT
(
slot
)
;
mPreviousValue
=
slot
-
>
get
(
)
;
slot
-
>
set
(
&
mCurrentValue
)
;
}
#
endif
namespace
detail
{
nsDependentCSubstring
GetSourceTreeBase
(
)
{
static
constexpr
auto
thisSourceFileRelativePath
=
"
/
dom
/
quota
/
QuotaCommon
.
cpp
"
_ns
;
static
constexpr
auto
path
=
nsLiteralCString
(
__FILE__
)
;
MOZ_ASSERT
(
StringEndsWith
(
path
thisSourceFileRelativePath
)
)
;
return
Substring
(
path
0
path
.
Length
(
)
-
thisSourceFileRelativePath
.
Length
(
)
)
;
}
nsDependentCSubstring
MakeSourceFileRelativePath
(
const
nsACString
&
aSourceFilePath
)
{
static
constexpr
auto
error
=
"
ERROR
"
_ns
;
static
const
auto
sourceTreeBase
=
GetSourceTreeBase
(
)
;
if
(
MOZ_LIKELY
(
StringBeginsWith
(
aSourceFilePath
sourceTreeBase
)
)
)
{
return
Substring
(
aSourceFilePath
sourceTreeBase
.
Length
(
)
+
1
)
;
}
nsCString
:
:
const_iterator
begin
end
;
if
(
RFindInReadable
(
"
/
"
_ns
aSourceFilePath
.
BeginReading
(
begin
)
aSourceFilePath
.
EndReading
(
end
)
)
)
{
+
+
begin
;
return
Substring
(
begin
aSourceFilePath
.
EndReading
(
end
)
)
;
}
return
nsDependentCSubstring
{
static_cast
<
mozilla
:
:
Span
<
const
char
>
>
(
static_cast
<
const
nsCString
&
>
(
error
)
)
}
;
}
}
void
LogError
(
const
nsACString
&
aExpr
const
Maybe
<
nsresult
>
aRv
const
nsACString
&
aSourceFilePath
const
int32_t
aSourceFileLine
const
Severity
aSeverity
)
{
#
if
defined
(
EARLY_BETA_OR_EARLIER
)
|
|
defined
(
DEBUG
)
nsAutoCString
extraInfosString
;
nsAutoCString
rvName
;
if
(
aRv
)
{
if
(
NS_ERROR_GET_MODULE
(
*
aRv
)
=
=
NS_ERROR_MODULE_WIN32
)
{
rvName
=
nsPrintfCString
(
"
WIN32
(
0x
%
"
PRIX16
"
)
"
NS_ERROR_GET_CODE
(
*
aRv
)
)
;
}
else
{
rvName
=
mozilla
:
:
GetStaticErrorName
(
*
aRv
)
;
}
extraInfosString
.
AppendPrintf
(
"
failed
with
"
"
result
0x
%
"
PRIX32
"
%
s
%
s
%
s
"
static_cast
<
uint32_t
>
(
*
aRv
)
!
rvName
.
IsEmpty
(
)
?
"
(
"
:
"
"
!
rvName
.
IsEmpty
(
)
?
rvName
.
get
(
)
:
"
"
!
rvName
.
IsEmpty
(
)
?
"
)
"
:
"
"
)
;
}
const
auto
sourceFileRelativePath
=
detail
:
:
MakeSourceFileRelativePath
(
aSourceFilePath
)
;
const
auto
severityString
=
[
&
aSeverity
]
(
)
-
>
nsLiteralCString
{
switch
(
aSeverity
)
{
case
Severity
:
:
Error
:
return
"
ERROR
"
_ns
;
case
Severity
:
:
Warning
:
return
"
WARNING
"
_ns
;
case
Severity
:
:
Note
:
return
"
NOTE
"
_ns
;
}
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Bad
severity
value
!
"
)
;
}
(
)
;
#
endif
#
ifdef
QM_ENABLE_SCOPED_LOG_EXTRA_INFO
const
auto
&
extraInfos
=
ScopedLogExtraInfo
:
:
GetExtraInfoMap
(
)
;
for
(
const
auto
&
item
:
extraInfos
)
{
extraInfosString
.
Append
(
"
"
_ns
+
nsDependentCString
(
item
.
first
)
+
"
=
"
_ns
+
*
item
.
second
)
;
}
#
endif
#
ifdef
DEBUG
NS_DebugBreak
(
NS_DEBUG_WARNING
nsAutoCString
(
"
QM_TRY
failure
(
"
_ns
+
severityString
+
"
)
"
_ns
)
.
get
(
)
(
extraInfosString
.
IsEmpty
(
)
?
nsPromiseFlatCString
(
aExpr
)
:
static_cast
<
const
nsCString
&
>
(
nsAutoCString
(
aExpr
+
extraInfosString
)
)
)
.
get
(
)
nsPromiseFlatCString
(
sourceFileRelativePath
)
.
get
(
)
aSourceFileLine
)
;
#
endif
#
if
defined
(
EARLY_BETA_OR_EARLIER
)
|
|
defined
(
DEBUG
)
nsCOMPtr
<
nsIConsoleService
>
console
=
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
;
if
(
console
)
{
NS_ConvertUTF8toUTF16
message
(
"
QM_TRY
failure
(
"
_ns
+
severityString
+
"
)
"
_ns
+
"
:
'
"
_ns
+
aExpr
+
"
'
at
"
_ns
+
sourceFileRelativePath
+
"
:
"
_ns
+
IntToCString
(
aSourceFileLine
)
+
extraInfosString
)
;
console
-
>
LogStringMessage
(
message
.
get
(
)
)
;
}
#
ifdef
QM_ENABLE_SCOPED_LOG_EXTRA_INFO
if
(
const
auto
contextIt
=
extraInfos
.
find
(
ScopedLogExtraInfo
:
:
kTagContext
)
;
contextIt
!
=
extraInfos
.
cend
(
)
)
{
auto
extra
=
Some
(
[
&
]
{
auto
res
=
CopyableTArray
<
EventExtraEntry
>
{
}
;
res
.
SetCapacity
(
6
)
;
res
.
AppendElement
(
EventExtraEntry
{
"
source_file
"
_ns
nsCString
(
sourceFileRelativePath
)
}
)
;
res
.
AppendElement
(
EventExtraEntry
{
"
source_line
"
_ns
IntToCString
(
aSourceFileLine
)
}
)
;
res
.
AppendElement
(
EventExtraEntry
{
"
context
"
_ns
nsPromiseFlatCString
{
*
contextIt
-
>
second
}
}
)
;
res
.
AppendElement
(
EventExtraEntry
{
"
severity
"
_ns
severityString
}
)
;
if
(
!
rvName
.
IsEmpty
(
)
)
{
res
.
AppendElement
(
EventExtraEntry
{
"
result
"
_ns
nsCString
{
rvName
}
}
)
;
}
static
Atomic
<
int32_t
>
sSequenceNumber
{
0
}
;
res
.
AppendElement
(
EventExtraEntry
{
"
seq
"
_ns
IntToCString
(
+
+
sSequenceNumber
)
}
)
;
return
res
;
}
(
)
)
;
Telemetry
:
:
RecordEvent
(
Telemetry
:
:
EventID
:
:
DomQuotaTry_Error_Step
Nothing
(
)
extra
)
;
}
#
endif
#
endif
}
#
ifdef
DEBUG
Result
<
bool
nsresult
>
WarnIfFileIsUnknown
(
nsIFile
&
aFile
const
char
*
aSourceFilePath
const
int32_t
aSourceFileLine
)
{
nsString
leafName
;
nsresult
rv
=
aFile
.
GetLeafName
(
leafName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
bool
isDirectory
;
rv
=
aFile
.
IsDirectory
(
&
isDirectory
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
if
(
!
isDirectory
)
{
if
(
leafName
.
Equals
(
kDSStoreFileName
)
|
|
leafName
.
Equals
(
kDesktopFileName
)
|
|
leafName
.
Equals
(
kDesktopIniFileName
nsCaseInsensitiveStringComparator
)
|
|
leafName
.
Equals
(
kThumbsDbFileName
nsCaseInsensitiveStringComparator
)
)
{
return
false
;
}
if
(
leafName
.
First
(
)
=
=
char16_t
(
'
.
'
)
)
{
return
false
;
}
}
NS_DebugBreak
(
NS_DEBUG_WARNING
nsPrintfCString
(
"
Something
(
%
s
)
in
the
directory
that
doesn
'
t
belong
!
"
NS_ConvertUTF16toUTF8
(
leafName
)
.
get
(
)
)
.
get
(
)
nullptr
aSourceFilePath
aSourceFileLine
)
;
return
true
;
}
#
endif
}
