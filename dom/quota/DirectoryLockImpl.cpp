#
include
"
DirectoryLockImpl
.
h
"
#
include
"
mozilla
/
ReverseIterator
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
Client
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaManager
.
h
"
namespace
mozilla
:
:
dom
:
:
quota
{
DirectoryLockImpl
:
:
DirectoryLockImpl
(
MovingNotNull
<
RefPtr
<
QuotaManager
>
>
aQuotaManager
const
Nullable
<
PersistenceType
>
&
aPersistenceType
const
nsACString
&
aGroup
const
OriginScope
&
aOriginScope
const
Nullable
<
Client
:
:
Type
>
&
aClientType
const
bool
aExclusive
const
bool
aInternal
const
ShouldUpdateLockIdTableFlag
aShouldUpdateLockIdTableFlag
)
:
mQuotaManager
(
std
:
:
move
(
aQuotaManager
)
)
mPersistenceType
(
aPersistenceType
)
mGroup
(
aGroup
)
mOriginScope
(
aOriginScope
)
mClientType
(
aClientType
)
mId
(
mQuotaManager
-
>
GenerateDirectoryLockId
(
)
)
mExclusive
(
aExclusive
)
mInternal
(
aInternal
)
mShouldUpdateLockIdTable
(
aShouldUpdateLockIdTableFlag
=
=
ShouldUpdateLockIdTableFlag
:
:
Yes
)
mRegistered
(
false
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT_IF
(
aOriginScope
.
IsOrigin
(
)
!
aOriginScope
.
GetOrigin
(
)
.
IsEmpty
(
)
)
;
MOZ_ASSERT_IF
(
!
aInternal
!
aPersistenceType
.
IsNull
(
)
)
;
MOZ_ASSERT_IF
(
!
aInternal
aPersistenceType
.
Value
(
)
!
=
PERSISTENCE_TYPE_INVALID
)
;
MOZ_ASSERT_IF
(
!
aInternal
!
aGroup
.
IsEmpty
(
)
)
;
MOZ_ASSERT_IF
(
!
aInternal
aOriginScope
.
IsOrigin
(
)
)
;
MOZ_ASSERT_IF
(
!
aInternal
!
aClientType
.
IsNull
(
)
)
;
MOZ_ASSERT_IF
(
!
aInternal
aClientType
.
Value
(
)
<
Client
:
:
TypeMax
(
)
)
;
}
DirectoryLockImpl
:
:
~
DirectoryLockImpl
(
)
{
AssertIsOnOwningThread
(
)
;
for
(
NotNull
<
RefPtr
<
DirectoryLockImpl
>
>
blockingLock
:
mBlocking
)
{
blockingLock
-
>
MaybeUnblock
(
*
this
)
;
}
mBlocking
.
Clear
(
)
;
if
(
mRegistered
)
{
mQuotaManager
-
>
UnregisterDirectoryLock
(
*
this
)
;
}
MOZ_ASSERT
(
!
mRegistered
)
;
}
#
ifdef
DEBUG
void
DirectoryLockImpl
:
:
AssertIsOnOwningThread
(
)
const
{
mQuotaManager
-
>
AssertIsOnOwningThread
(
)
;
}
#
endif
bool
DirectoryLockImpl
:
:
Overlaps
(
const
DirectoryLockImpl
&
aLock
)
const
{
AssertIsOnOwningThread
(
)
;
if
(
!
aLock
.
mPersistenceType
.
IsNull
(
)
&
&
!
mPersistenceType
.
IsNull
(
)
&
&
aLock
.
mPersistenceType
.
Value
(
)
!
=
mPersistenceType
.
Value
(
)
)
{
return
false
;
}
bool
match
=
aLock
.
mOriginScope
.
Matches
(
mOriginScope
)
;
if
(
!
match
)
{
return
false
;
}
if
(
!
aLock
.
mClientType
.
IsNull
(
)
&
&
!
mClientType
.
IsNull
(
)
&
&
aLock
.
mClientType
.
Value
(
)
!
=
mClientType
.
Value
(
)
)
{
return
false
;
}
return
true
;
}
bool
DirectoryLockImpl
:
:
MustWaitFor
(
const
DirectoryLockImpl
&
aLock
)
const
{
AssertIsOnOwningThread
(
)
;
if
(
!
aLock
.
mExclusive
&
&
!
mExclusive
)
{
return
false
;
}
return
Overlaps
(
aLock
)
;
}
void
DirectoryLockImpl
:
:
NotifyOpenListener
(
)
{
AssertIsOnOwningThread
(
)
;
if
(
mInvalidated
)
{
(
*
mOpenListener
)
-
>
DirectoryLockFailed
(
)
;
}
else
{
(
*
mOpenListener
)
-
>
DirectoryLockAcquired
(
this
)
;
}
mOpenListener
.
destroy
(
)
;
mQuotaManager
-
>
RemovePendingDirectoryLock
(
*
this
)
;
mPending
.
Flip
(
)
;
}
void
DirectoryLockImpl
:
:
Acquire
(
RefPtr
<
OpenDirectoryListener
>
aOpenListener
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aOpenListener
)
;
mOpenListener
.
init
(
WrapNotNullUnchecked
(
std
:
:
move
(
aOpenListener
)
)
)
;
mQuotaManager
-
>
AddPendingDirectoryLock
(
*
this
)
;
bool
blocked
=
false
;
for
(
DirectoryLockImpl
*
const
existingLock
:
Reversed
(
mQuotaManager
-
>
mDirectoryLocks
)
)
{
if
(
MustWaitFor
(
*
existingLock
)
)
{
existingLock
-
>
AddBlockingLock
(
*
this
)
;
AddBlockedOnLock
(
*
existingLock
)
;
blocked
=
true
;
}
}
mQuotaManager
-
>
RegisterDirectoryLock
(
*
this
)
;
if
(
!
blocked
)
{
NotifyOpenListener
(
)
;
return
;
}
if
(
!
mExclusive
|
|
!
mInternal
)
{
return
;
}
QuotaManager
:
:
DirectoryLockIdTableArray
lockIds
;
lockIds
.
SetLength
(
Client
:
:
TypeMax
(
)
)
;
const
auto
&
blockedOnLocks
=
GetBlockedOnLocks
(
)
;
MOZ_ASSERT
(
!
blockedOnLocks
.
IsEmpty
(
)
)
;
for
(
DirectoryLockImpl
*
blockedOnLock
:
blockedOnLocks
)
{
if
(
!
blockedOnLock
-
>
IsInternal
(
)
)
{
blockedOnLock
-
>
Invalidate
(
)
;
if
(
!
blockedOnLock
-
>
IsPending
(
)
)
{
lockIds
[
blockedOnLock
-
>
ClientType
(
)
]
.
Put
(
blockedOnLock
-
>
Id
(
)
)
;
}
}
}
mQuotaManager
-
>
AbortOperationsForLocks
(
lockIds
)
;
}
void
DirectoryLockImpl
:
:
Acquire
(
)
{
AssertIsOnOwningThread
(
)
;
#
ifdef
DEBUG
for
(
const
DirectoryLockImpl
*
const
existingLock
:
mQuotaManager
-
>
mDirectoryLocks
)
{
MOZ_ASSERT
(
!
MustWaitFor
(
*
existingLock
)
)
;
}
#
endif
mQuotaManager
-
>
RegisterDirectoryLock
(
*
this
)
;
}
RefPtr
<
DirectoryLock
>
DirectoryLockImpl
:
:
Specialize
(
PersistenceType
aPersistenceType
const
quota
:
:
GroupAndOrigin
&
aGroupAndOrigin
Client
:
:
Type
aClientType
)
const
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aPersistenceType
!
=
PERSISTENCE_TYPE_INVALID
)
;
MOZ_ASSERT
(
!
aGroupAndOrigin
.
mGroup
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
aGroupAndOrigin
.
mOrigin
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aClientType
<
Client
:
:
TypeMax
(
)
)
;
MOZ_ASSERT
(
!
mOpenListener
)
;
MOZ_ASSERT
(
mBlockedOn
.
IsEmpty
(
)
)
;
if
(
NS_WARN_IF
(
mExclusive
)
)
{
return
nullptr
;
}
RefPtr
<
DirectoryLockImpl
>
lock
=
Create
(
mQuotaManager
Nullable
<
PersistenceType
>
(
aPersistenceType
)
aGroupAndOrigin
.
mGroup
OriginScope
:
:
FromOrigin
(
aGroupAndOrigin
.
mOrigin
)
Nullable
<
Client
:
:
Type
>
(
aClientType
)
false
mInternal
ShouldUpdateLockIdTableFlag
:
:
Yes
)
;
if
(
NS_WARN_IF
(
!
Overlaps
(
*
lock
)
)
)
{
return
nullptr
;
}
#
ifdef
DEBUG
for
(
DirectoryLockImpl
*
const
existingLock
:
Reversed
(
mQuotaManager
-
>
mDirectoryLocks
)
)
{
if
(
existingLock
!
=
this
&
&
!
existingLock
-
>
MustWaitFor
(
*
this
)
)
{
MOZ_ASSERT
(
!
existingLock
-
>
MustWaitFor
(
*
lock
)
)
;
}
}
#
endif
for
(
const
auto
&
blockedLock
:
mBlocking
)
{
if
(
blockedLock
-
>
MustWaitFor
(
*
lock
)
)
{
lock
-
>
AddBlockingLock
(
*
blockedLock
)
;
blockedLock
-
>
AddBlockedOnLock
(
*
lock
)
;
}
}
mQuotaManager
-
>
RegisterDirectoryLock
(
*
lock
)
;
if
(
mInvalidated
)
{
lock
-
>
Invalidate
(
)
;
}
return
lock
;
}
void
DirectoryLockImpl
:
:
Log
(
)
const
{
AssertIsOnOwningThread
(
)
;
if
(
!
QM_LOG_TEST
(
)
)
{
return
;
}
QM_LOG
(
(
"
DirectoryLockImpl
[
%
p
]
"
this
)
)
;
nsCString
persistenceType
;
if
(
mPersistenceType
.
IsNull
(
)
)
{
persistenceType
.
AssignLiteral
(
"
null
"
)
;
}
else
{
persistenceType
.
Assign
(
PersistenceTypeToString
(
mPersistenceType
.
Value
(
)
)
)
;
}
QM_LOG
(
(
"
mPersistenceType
:
%
s
"
persistenceType
.
get
(
)
)
)
;
QM_LOG
(
(
"
mGroup
:
%
s
"
mGroup
.
get
(
)
)
)
;
nsCString
originScope
;
if
(
mOriginScope
.
IsOrigin
(
)
)
{
originScope
.
AssignLiteral
(
"
origin
:
"
)
;
originScope
.
Append
(
mOriginScope
.
GetOrigin
(
)
)
;
}
else
if
(
mOriginScope
.
IsPrefix
(
)
)
{
originScope
.
AssignLiteral
(
"
prefix
:
"
)
;
originScope
.
Append
(
mOriginScope
.
GetOriginNoSuffix
(
)
)
;
}
else
if
(
mOriginScope
.
IsPattern
(
)
)
{
originScope
.
AssignLiteral
(
"
pattern
:
"
)
;
}
else
{
MOZ_ASSERT
(
mOriginScope
.
IsNull
(
)
)
;
originScope
.
AssignLiteral
(
"
null
"
)
;
}
QM_LOG
(
(
"
mOriginScope
:
%
s
"
originScope
.
get
(
)
)
)
;
const
auto
clientType
=
mClientType
.
IsNull
(
)
?
nsAutoCString
{
"
null
"
_ns
}
:
Client
:
:
TypeToText
(
mClientType
.
Value
(
)
)
;
QM_LOG
(
(
"
mClientType
:
%
s
"
clientType
.
get
(
)
)
)
;
nsCString
blockedOnString
;
for
(
auto
blockedOn
:
mBlockedOn
)
{
blockedOnString
.
Append
(
nsPrintfCString
(
"
[
%
p
]
"
static_cast
<
void
*
>
(
blockedOn
)
)
)
;
}
QM_LOG
(
(
"
mBlockedOn
:
%
s
"
blockedOnString
.
get
(
)
)
)
;
QM_LOG
(
(
"
mExclusive
:
%
d
"
mExclusive
)
)
;
QM_LOG
(
(
"
mInternal
:
%
d
"
mInternal
)
)
;
QM_LOG
(
(
"
mInvalidated
:
%
d
"
static_cast
<
bool
>
(
mInvalidated
)
)
)
;
for
(
auto
blockedOn
:
mBlockedOn
)
{
blockedOn
-
>
Log
(
)
;
}
}
}
