#
include
"
DirectoryLockImpl
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
ReverseIterator
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaCommon
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaManager
.
h
"
namespace
mozilla
:
:
dom
:
:
quota
{
namespace
{
const
uint32_t
kAcquireTimeoutMs
=
30000
;
}
DirectoryLockImpl
:
:
DirectoryLockImpl
(
MovingNotNull
<
RefPtr
<
QuotaManager
>
>
aQuotaManager
const
PersistenceScope
&
aPersistenceScope
const
OriginScope
&
aOriginScope
const
Nullable
<
Client
:
:
Type
>
&
aClientType
const
bool
aExclusive
const
bool
aInternal
const
ShouldUpdateLockIdTableFlag
aShouldUpdateLockIdTableFlag
const
DirectoryLockCategory
aCategory
)
:
mQuotaManager
(
std
:
:
move
(
aQuotaManager
)
)
mPersistenceScope
(
aPersistenceScope
)
mOriginScope
(
aOriginScope
)
mClientType
(
aClientType
)
mId
(
mQuotaManager
-
>
GenerateDirectoryLockId
(
)
)
mExclusive
(
aExclusive
)
mInternal
(
aInternal
)
mShouldUpdateLockIdTable
(
aShouldUpdateLockIdTableFlag
=
=
ShouldUpdateLockIdTableFlag
:
:
Yes
)
mCategory
(
aCategory
)
mRegistered
(
false
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT_IF
(
aOriginScope
.
IsOrigin
(
)
!
aOriginScope
.
GetOrigin
(
)
.
IsEmpty
(
)
)
;
MOZ_ASSERT_IF
(
!
aInternal
aPersistenceScope
.
IsValue
(
)
)
;
MOZ_ASSERT_IF
(
!
aInternal
aPersistenceScope
.
GetValue
(
)
!
=
PERSISTENCE_TYPE_INVALID
)
;
MOZ_ASSERT_IF
(
!
aInternal
aOriginScope
.
IsOrigin
(
)
)
;
MOZ_ASSERT_IF
(
!
aInternal
!
aClientType
.
IsNull
(
)
)
;
MOZ_ASSERT_IF
(
!
aInternal
aClientType
.
Value
(
)
<
Client
:
:
TypeMax
(
)
)
;
}
DirectoryLockImpl
:
:
~
DirectoryLockImpl
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mRegistered
)
;
}
bool
DirectoryLockImpl
:
:
MustWait
(
)
const
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
!
mRegistered
)
;
for
(
const
DirectoryLockImpl
*
const
existingLock
:
mQuotaManager
-
>
mDirectoryLocks
)
{
if
(
MustWaitFor
(
*
existingLock
)
)
{
return
true
;
}
}
return
false
;
}
nsTArray
<
RefPtr
<
DirectoryLockImpl
>
>
DirectoryLockImpl
:
:
LocksMustWaitFor
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
LocksMustWaitForInternal
<
RefPtr
<
DirectoryLockImpl
>
>
(
)
;
}
RefPtr
<
BoolPromise
>
DirectoryLockImpl
:
:
Acquire
(
)
{
AssertIsOnOwningThread
(
)
;
RefPtr
<
BoolPromise
>
result
=
mAcquirePromiseHolder
.
Ensure
(
__func__
)
;
AcquireInternal
(
)
;
return
result
;
}
void
DirectoryLockImpl
:
:
AcquireImmediately
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
!
MustWait
(
)
)
;
mQuotaManager
-
>
RegisterDirectoryLock
(
*
this
)
;
mAcquired
.
Flip
(
)
;
}
#
ifdef
DEBUG
void
DirectoryLockImpl
:
:
AssertIsAcquiredExclusively
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mBlockedOn
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mExclusive
)
;
MOZ_ASSERT
(
mInternal
)
;
MOZ_ASSERT
(
mRegistered
)
;
MOZ_ASSERT
(
!
mInvalidated
)
;
MOZ_ASSERT
(
mAcquired
)
;
bool
found
=
false
;
for
(
const
DirectoryLockImpl
*
const
existingLock
:
mQuotaManager
-
>
mDirectoryLocks
)
{
if
(
existingLock
=
=
this
)
{
MOZ_ASSERT
(
!
found
)
;
found
=
true
;
}
else
if
(
existingLock
-
>
mAcquired
)
{
MOZ_ASSERT
(
false
)
;
}
}
MOZ_ASSERT
(
found
)
;
}
#
endif
RefPtr
<
BoolPromise
>
DirectoryLockImpl
:
:
Drop
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT_IF
(
!
mRegistered
mBlocking
.
IsEmpty
(
)
)
;
mDropped
.
Flip
(
)
;
return
InvokeAsync
(
GetCurrentSerialEventTarget
(
)
__func__
[
self
=
RefPtr
(
this
)
]
(
)
{
if
(
self
-
>
mRegistered
)
{
self
-
>
Unregister
(
)
;
}
return
BoolPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
)
;
}
void
DirectoryLockImpl
:
:
OnInvalidate
(
std
:
:
function
<
void
(
)
>
&
&
aCallback
)
{
mInvalidateCallback
=
std
:
:
move
(
aCallback
)
;
}
void
DirectoryLockImpl
:
:
Log
(
)
const
{
AssertIsOnOwningThread
(
)
;
if
(
!
QM_LOG_TEST
(
)
)
{
return
;
}
QM_LOG
(
(
"
DirectoryLockImpl
[
%
p
]
"
this
)
)
;
nsCString
persistenceScope
;
if
(
mPersistenceScope
.
IsNull
(
)
)
{
persistenceScope
.
AssignLiteral
(
"
null
"
)
;
}
else
if
(
mPersistenceScope
.
IsValue
(
)
)
{
persistenceScope
.
Assign
(
PersistenceTypeToString
(
mPersistenceScope
.
GetValue
(
)
)
)
;
}
else
{
MOZ_ASSERT
(
mPersistenceScope
.
IsSet
(
)
)
;
for
(
auto
persistenceType
:
mPersistenceScope
.
GetSet
(
)
)
{
persistenceScope
.
Append
(
PersistenceTypeToString
(
persistenceType
)
+
"
"
_ns
)
;
}
}
QM_LOG
(
(
"
mPersistenceScope
:
%
s
"
persistenceScope
.
get
(
)
)
)
;
nsCString
originScope
;
if
(
mOriginScope
.
IsOrigin
(
)
)
{
originScope
.
AssignLiteral
(
"
origin
:
"
)
;
originScope
.
Append
(
mOriginScope
.
GetOrigin
(
)
)
;
}
else
if
(
mOriginScope
.
IsPrefix
(
)
)
{
originScope
.
AssignLiteral
(
"
prefix
:
"
)
;
originScope
.
Append
(
mOriginScope
.
GetOriginNoSuffix
(
)
)
;
}
else
if
(
mOriginScope
.
IsPattern
(
)
)
{
originScope
.
AssignLiteral
(
"
pattern
:
"
)
;
}
else
{
MOZ_ASSERT
(
mOriginScope
.
IsNull
(
)
)
;
originScope
.
AssignLiteral
(
"
null
"
)
;
}
QM_LOG
(
(
"
mOriginScope
:
%
s
"
originScope
.
get
(
)
)
)
;
const
auto
clientType
=
mClientType
.
IsNull
(
)
?
nsAutoCString
{
"
null
"
_ns
}
:
Client
:
:
TypeToText
(
mClientType
.
Value
(
)
)
;
QM_LOG
(
(
"
mClientType
:
%
s
"
clientType
.
get
(
)
)
)
;
nsCString
blockedOnString
;
for
(
auto
blockedOn
:
mBlockedOn
)
{
blockedOnString
.
Append
(
nsPrintfCString
(
"
[
%
p
]
"
static_cast
<
void
*
>
(
blockedOn
)
)
)
;
}
QM_LOG
(
(
"
mBlockedOn
:
%
s
"
blockedOnString
.
get
(
)
)
)
;
QM_LOG
(
(
"
mExclusive
:
%
d
"
mExclusive
)
)
;
QM_LOG
(
(
"
mInternal
:
%
d
"
mInternal
)
)
;
QM_LOG
(
(
"
mInvalidated
:
%
d
"
static_cast
<
bool
>
(
mInvalidated
)
)
)
;
for
(
auto
blockedOn
:
mBlockedOn
)
{
blockedOn
-
>
Log
(
)
;
}
}
#
ifdef
DEBUG
void
DirectoryLockImpl
:
:
AssertIsOnOwningThread
(
)
const
{
mQuotaManager
-
>
AssertIsOnOwningThread
(
)
;
}
#
endif
bool
DirectoryLockImpl
:
:
Overlaps
(
const
DirectoryLockImpl
&
aLock
)
const
{
AssertIsOnOwningThread
(
)
;
bool
match
=
aLock
.
mPersistenceScope
.
Matches
(
mPersistenceScope
)
;
if
(
!
match
)
{
return
false
;
}
match
=
aLock
.
mOriginScope
.
Matches
(
mOriginScope
)
;
if
(
!
match
)
{
return
false
;
}
if
(
!
aLock
.
mClientType
.
IsNull
(
)
&
&
!
mClientType
.
IsNull
(
)
&
&
aLock
.
mClientType
.
Value
(
)
!
=
mClientType
.
Value
(
)
)
{
return
false
;
}
return
true
;
}
bool
DirectoryLockImpl
:
:
MustWaitFor
(
const
DirectoryLockImpl
&
aLock
)
const
{
AssertIsOnOwningThread
(
)
;
if
(
!
aLock
.
mExclusive
&
&
!
mExclusive
)
{
return
false
;
}
return
Overlaps
(
aLock
)
;
}
void
DirectoryLockImpl
:
:
NotifyOpenListener
(
)
{
AssertIsOnOwningThread
(
)
;
if
(
mAcquireTimer
)
{
mAcquireTimer
-
>
Cancel
(
)
;
mAcquireTimer
=
nullptr
;
}
if
(
mInvalidated
)
{
mAcquirePromiseHolder
.
Reject
(
NS_ERROR_FAILURE
__func__
)
;
}
else
{
mAcquired
.
Flip
(
)
;
mAcquirePromiseHolder
.
Resolve
(
true
__func__
)
;
}
MOZ_ASSERT
(
mAcquirePromiseHolder
.
IsEmpty
(
)
)
;
mQuotaManager
-
>
RemovePendingDirectoryLock
(
*
this
)
;
mPending
.
Flip
(
)
;
if
(
mInvalidated
)
{
mDropped
.
Flip
(
)
;
Unregister
(
)
;
}
}
template
<
typename
T
>
nsTArray
<
T
>
DirectoryLockImpl
:
:
LocksMustWaitForInternal
(
)
const
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
!
mRegistered
)
;
nsTArray
<
T
>
locks
;
for
(
DirectoryLockImpl
*
const
existingLock
:
Reversed
(
mQuotaManager
-
>
mDirectoryLocks
)
)
{
if
(
MustWaitFor
(
*
existingLock
)
)
{
if
constexpr
(
std
:
:
is_same_v
<
T
NotNull
<
DirectoryLockImpl
*
>
>
)
{
locks
.
AppendElement
(
WrapNotNull
(
existingLock
)
)
;
}
else
{
locks
.
AppendElement
(
existingLock
)
;
}
}
}
return
locks
;
}
void
DirectoryLockImpl
:
:
AcquireInternal
(
)
{
AssertIsOnOwningThread
(
)
;
mQuotaManager
-
>
AddPendingDirectoryLock
(
*
this
)
;
mBlockedOn
=
LocksMustWaitForInternal
<
NotNull
<
DirectoryLockImpl
*
>
>
(
)
;
mQuotaManager
-
>
RegisterDirectoryLock
(
*
this
)
;
if
(
mBlockedOn
.
IsEmpty
(
)
)
{
NotifyOpenListener
(
)
;
return
;
}
for
(
auto
&
blockedOnLock
:
mBlockedOn
)
{
blockedOnLock
-
>
AddBlockingLock
(
*
this
)
;
}
mAcquireTimer
=
NS_NewTimer
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
mAcquireTimer
-
>
InitWithNamedFuncCallback
(
[
]
(
nsITimer
*
aTimer
void
*
aClosure
)
{
if
(
!
QM_LOG_TEST
(
)
)
{
return
;
}
auto
*
const
lock
=
static_cast
<
DirectoryLockImpl
*
>
(
aClosure
)
;
QM_LOG
(
(
"
Directory
lock
[
%
p
]
is
taking
too
long
to
be
acquired
"
lock
)
)
;
lock
-
>
Log
(
)
;
}
this
kAcquireTimeoutMs
nsITimer
:
:
TYPE_ONE_SHOT
"
quota
:
:
DirectoryLockImpl
:
:
AcquireInternal
"
)
)
;
if
(
!
mExclusive
|
|
!
mInternal
)
{
return
;
}
QuotaManager
:
:
DirectoryLockIdTableArray
lockIds
;
lockIds
.
SetLength
(
Client
:
:
TypeMax
(
)
)
;
const
auto
&
blockedOnLocks
=
GetBlockedOnLocks
(
)
;
MOZ_ASSERT
(
!
blockedOnLocks
.
IsEmpty
(
)
)
;
for
(
DirectoryLockImpl
*
blockedOnLock
:
blockedOnLocks
)
{
if
(
!
blockedOnLock
-
>
IsInternal
(
)
)
{
blockedOnLock
-
>
Invalidate
(
)
;
if
(
!
blockedOnLock
-
>
IsPending
(
)
)
{
lockIds
[
blockedOnLock
-
>
ClientType
(
)
]
.
Put
(
blockedOnLock
-
>
Id
(
)
)
;
}
}
}
mQuotaManager
-
>
AbortOperationsForLocks
(
lockIds
)
;
}
void
DirectoryLockImpl
:
:
Invalidate
(
)
{
AssertIsOnOwningThread
(
)
;
mInvalidated
.
EnsureFlipped
(
)
;
if
(
mInvalidateCallback
)
{
MOZ_ALWAYS_SUCCEEDS
(
GetCurrentSerialEventTarget
(
)
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
DirectoryLockImpl
:
:
Invalidate
"
[
invalidateCallback
=
mInvalidateCallback
]
(
)
{
invalidateCallback
(
)
;
}
)
NS_DISPATCH_NORMAL
)
)
;
}
}
void
DirectoryLockImpl
:
:
Unregister
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mRegistered
)
;
mQuotaManager
-
>
UnregisterDirectoryLock
(
*
this
)
;
MOZ_ASSERT
(
!
mRegistered
)
;
for
(
NotNull
<
RefPtr
<
DirectoryLockImpl
>
>
blockingLock
:
mBlocking
)
{
blockingLock
-
>
MaybeUnblock
(
*
this
)
;
}
mBlocking
.
Clear
(
)
;
}
}
