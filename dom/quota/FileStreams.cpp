#
include
"
FileStreams
.
h
"
#
include
"
QuotaCommon
.
h
"
#
include
"
QuotaManager
.
h
"
#
include
"
QuotaObject
.
h
"
#
include
<
utility
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
ResultExtensions
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
prio
.
h
"
namespace
mozilla
:
:
dom
:
:
quota
{
template
<
class
FileStreamBase
>
NS_IMETHODIMP
FileQuotaStream
<
FileStreamBase
>
:
:
SetEOF
(
)
{
QM_TRY
(
MOZ_TO_RESULT
(
FileStreamBase
:
:
SetEOF
(
)
)
)
;
if
(
mQuotaObject
)
{
int64_t
offset
;
QM_TRY
(
MOZ_TO_RESULT
(
FileStreamBase
:
:
Tell
(
&
offset
)
)
)
;
DebugOnly
<
bool
>
res
=
mQuotaObject
-
>
MaybeUpdateSize
(
offset
true
)
;
MOZ_ASSERT
(
res
)
;
}
return
NS_OK
;
}
template
<
class
FileStreamBase
>
NS_IMETHODIMP
FileQuotaStream
<
FileStreamBase
>
:
:
Close
(
)
{
QM_TRY
(
MOZ_TO_RESULT
(
FileStreamBase
:
:
Close
(
)
)
)
;
mQuotaObject
=
nullptr
;
return
NS_OK
;
}
template
<
class
FileStreamBase
>
nsresult
FileQuotaStream
<
FileStreamBase
>
:
:
DoOpen
(
)
{
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_ASSERT
(
quotaManager
"
Shouldn
'
t
be
null
!
"
)
;
MOZ_ASSERT
(
!
mQuotaObject
"
Creating
quota
object
more
than
once
?
"
)
;
mQuotaObject
=
quotaManager
-
>
GetQuotaObject
(
mPersistenceType
mOriginMetadata
mClientType
FileStreamBase
:
:
mOpenParams
.
localFile
)
;
QM_TRY
(
MOZ_TO_RESULT
(
FileStreamBase
:
:
DoOpen
(
)
)
)
;
if
(
mQuotaObject
&
&
(
FileStreamBase
:
:
mOpenParams
.
ioFlags
&
PR_TRUNCATE
)
)
{
DebugOnly
<
bool
>
res
=
mQuotaObject
-
>
MaybeUpdateSize
(
0
true
)
;
MOZ_ASSERT
(
res
)
;
}
return
NS_OK
;
}
template
<
class
FileStreamBase
>
NS_IMETHODIMP
FileQuotaStreamWithWrite
<
FileStreamBase
>
:
:
Write
(
const
char
*
aBuf
uint32_t
aCount
uint32_t
*
_retval
)
{
if
(
FileQuotaStreamWithWrite
:
:
mQuotaObject
)
{
int64_t
offset
;
QM_TRY
(
MOZ_TO_RESULT
(
FileStreamBase
:
:
Tell
(
&
offset
)
)
)
;
MOZ_ASSERT
(
INT64_MAX
-
offset
>
=
int64_t
(
aCount
)
)
;
if
(
!
FileQuotaStreamWithWrite
:
:
mQuotaObject
-
>
MaybeUpdateSize
(
offset
+
int64_t
(
aCount
)
false
)
)
{
return
NS_ERROR_FILE_NO_DEVICE_SPACE
;
}
}
QM_TRY
(
MOZ_TO_RESULT
(
FileStreamBase
:
:
Write
(
aBuf
aCount
_retval
)
)
)
;
return
NS_OK
;
}
Result
<
MovingNotNull
<
nsCOMPtr
<
nsIInputStream
>
>
nsresult
>
CreateFileInputStream
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
Client
:
:
Type
aClientType
nsIFile
*
aFile
int32_t
aIOFlags
int32_t
aPerm
int32_t
aBehaviorFlags
)
{
auto
stream
=
MakeRefPtr
<
FileInputStream
>
(
aPersistenceType
aOriginMetadata
aClientType
)
;
QM_TRY
(
MOZ_TO_RESULT
(
stream
-
>
Init
(
aFile
aIOFlags
aPerm
aBehaviorFlags
)
)
)
;
return
WrapMovingNotNullUnchecked
(
nsCOMPtr
<
nsIInputStream
>
(
std
:
:
move
(
stream
)
)
)
;
}
Result
<
MovingNotNull
<
nsCOMPtr
<
nsIOutputStream
>
>
nsresult
>
CreateFileOutputStream
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
Client
:
:
Type
aClientType
nsIFile
*
aFile
int32_t
aIOFlags
int32_t
aPerm
int32_t
aBehaviorFlags
)
{
auto
stream
=
MakeRefPtr
<
FileOutputStream
>
(
aPersistenceType
aOriginMetadata
aClientType
)
;
QM_TRY
(
MOZ_TO_RESULT
(
stream
-
>
Init
(
aFile
aIOFlags
aPerm
aBehaviorFlags
)
)
)
;
return
WrapMovingNotNullUnchecked
(
nsCOMPtr
<
nsIOutputStream
>
(
std
:
:
move
(
stream
)
)
)
;
}
Result
<
MovingNotNull
<
nsCOMPtr
<
nsIRandomAccessStream
>
>
nsresult
>
CreateFileRandomAccessStream
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
Client
:
:
Type
aClientType
nsIFile
*
aFile
int32_t
aIOFlags
int32_t
aPerm
int32_t
aBehaviorFlags
)
{
auto
stream
=
MakeRefPtr
<
FileRandomAccessStream
>
(
aPersistenceType
aOriginMetadata
aClientType
)
;
QM_TRY
(
MOZ_TO_RESULT
(
stream
-
>
Init
(
aFile
aIOFlags
aPerm
aBehaviorFlags
)
)
)
;
return
WrapMovingNotNullUnchecked
(
nsCOMPtr
<
nsIRandomAccessStream
>
(
std
:
:
move
(
stream
)
)
)
;
}
}
