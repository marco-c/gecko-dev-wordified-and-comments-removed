const
{
TelemetryTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
TelemetryTestUtils
.
jsm
"
)
;
const
telemetry
=
"
QM_FIRST_INITIALIZATION_ATTEMPT
"
;
const
testcases
=
[
{
key
:
"
Storage
"
initFunction
:
init
initArgs
:
[
[
]
]
get
metadataDir
(
)
{
return
getRelativeFile
(
"
storage
/
default
/
https
+
+
+
example
.
com
/
.
metadata
-
v2
"
)
;
}
async
breakInit
(
)
{
this
.
metadataDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
unbreakInit
(
)
{
this
.
metadataDir
.
remove
(
false
)
;
}
expectedResult
:
{
initFailure
:
[
1
0
]
initFailureThenSuccess
:
[
1
1
0
]
}
}
{
key
:
"
TemporaryStorage
"
initFunction
:
initTemporaryStorage
initArgs
:
[
[
]
]
get
metadataDir
(
)
{
return
getRelativeFile
(
"
storage
/
default
/
https
+
+
+
example
.
com
/
.
metadata
-
v2
"
)
;
}
async
breakInit
(
)
{
let
request
=
init
(
)
;
await
requestFinished
(
request
)
;
this
.
metadataDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
unbreakInit
(
)
{
this
.
metadataDir
.
remove
(
false
)
;
}
expectedResult
:
{
initFailure
:
[
1
0
]
initFailureThenSuccess
:
[
1
1
0
]
}
}
{
key
:
"
PersistentOrigin
"
initFunction
:
initStorageAndOrigin
initArgs
:
[
[
getPrincipal
(
"
https
:
/
/
example
.
com
"
)
"
persistent
"
]
[
getPrincipal
(
"
https
:
/
/
example1
.
com
"
)
"
persistent
"
]
[
getPrincipal
(
"
https
:
/
/
example2
.
com
"
)
"
default
"
]
]
get
originFiles
(
)
{
return
[
getRelativeFile
(
"
storage
/
permanent
/
https
+
+
+
example
.
com
"
)
getRelativeFile
(
"
storage
/
permanent
/
https
+
+
+
example1
.
com
"
)
getRelativeFile
(
"
storage
/
default
/
https
+
+
+
example2
.
com
"
)
]
;
}
async
breakInit
(
)
{
let
request
=
initTemporaryStorage
(
)
;
await
requestFinished
(
request
)
;
for
(
let
originFile
of
this
.
originFiles
)
{
originFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
0o666
)
;
}
}
unbreakInit
(
)
{
for
(
let
originFile
of
this
.
originFiles
)
{
originFile
.
remove
(
false
)
;
}
}
expectedResult
:
{
initFailure
:
[
2
0
]
initFailureThenSuccess
:
[
2
2
0
]
}
}
{
key
:
"
TemporaryOrigin
"
initFunction
:
initStorageAndOrigin
initArgs
:
[
[
getPrincipal
(
"
https
:
/
/
example
.
com
"
)
"
temporary
"
]
[
getPrincipal
(
"
https
:
/
/
example
.
com
"
)
"
default
"
]
[
getPrincipal
(
"
https
:
/
/
example1
.
com
"
)
"
default
"
]
[
getPrincipal
(
"
https
:
/
/
example2
.
com
"
)
"
persistent
"
]
]
get
originFiles
(
)
{
return
[
getRelativeFile
(
"
storage
/
temporary
/
https
+
+
+
example
.
com
"
)
getRelativeFile
(
"
storage
/
default
/
https
+
+
+
example
.
com
"
)
getRelativeFile
(
"
storage
/
default
/
https
+
+
+
example1
.
com
"
)
getRelativeFile
(
"
storage
/
permanent
/
https
+
+
+
example2
.
com
"
)
]
;
}
async
breakInit
(
)
{
let
request
=
initTemporaryStorage
(
)
;
await
requestFinished
(
request
)
;
for
(
let
originFile
of
this
.
originFiles
)
{
originFile
.
create
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
0o666
)
;
}
}
unbreakInit
(
)
{
for
(
let
originFile
of
this
.
originFiles
)
{
originFile
.
remove
(
false
)
;
}
}
expectedResult
:
{
initFailure
:
[
2
0
]
initFailureThenSuccess
:
[
2
2
0
]
}
}
{
key
:
"
UpgradeStorageFrom0_0To1_0
"
initFunction
:
init
initArgs
:
[
[
]
]
get
metadataDir
(
)
{
return
getRelativeFile
(
"
storage
/
default
/
https
+
+
+
example
.
com
/
.
metadata
-
v2
"
)
;
}
initSetting
(
)
{
let
db
=
getRelativeFile
(
"
storage
.
sqlite
"
)
;
if
(
db
.
exists
(
)
)
{
db
.
remove
(
false
)
;
}
}
async
breakInit
(
)
{
this
.
metadataDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
unbreakInit
(
)
{
this
.
metadataDir
.
remove
(
false
)
;
}
expectedResult
:
{
initFailure
:
[
1
0
]
initFailureThenSuccess
:
[
1
1
0
]
}
}
{
key
:
"
UpgradeStorageFrom1_0To2_0
"
initFunction
:
init
initArgs
:
[
[
]
]
get
metadataDir
(
)
{
return
getRelativeFile
(
"
storage
/
default
/
https
+
+
+
example
.
com
/
.
metadata
-
v2
"
)
;
}
initSetting
(
)
{
installPackage
(
"
version2_0upgrade_profile
"
)
;
}
async
breakInit
(
)
{
this
.
metadataDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
unbreakInit
(
)
{
this
.
metadataDir
.
remove
(
false
)
;
}
expectedResult
:
{
initFailure
:
[
1
0
]
initFailureThenSuccess
:
[
1
1
0
]
}
}
{
key
:
"
UpgradeStorageFrom2_0To2_1
"
initFunction
:
init
initArgs
:
[
[
]
]
get
metadataDir
(
)
{
return
getRelativeFile
(
"
storage
/
default
/
https
+
+
+
example
.
com
/
.
metadata
-
v2
"
)
;
}
initSetting
(
)
{
installPackage
(
"
version2_1upgrade_profile
"
)
;
}
async
breakInit
(
)
{
this
.
metadataDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
unbreakInit
(
)
{
this
.
metadataDir
.
remove
(
false
)
;
}
expectedResult
:
{
initFailure
:
[
1
0
]
initFailureThenSuccess
:
[
1
1
0
]
}
}
{
key
:
"
UpgradeStorageFrom2_1To2_2
"
initFunction
:
init
initArgs
:
[
[
]
]
get
metadataDir
(
)
{
return
getRelativeFile
(
"
storage
/
default
/
https
+
+
+
example
.
com
/
.
metadata
-
v2
"
)
;
}
initSetting
(
)
{
installPackage
(
"
version2_2upgrade_profile
"
)
;
}
async
breakInit
(
)
{
this
.
metadataDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
unbreakInit
(
)
{
this
.
metadataDir
.
remove
(
false
)
;
}
expectedResult
:
{
initFailure
:
[
1
0
]
initFailureThenSuccess
:
[
1
1
0
]
}
}
{
key
:
"
UpgradeStorageFrom2_2To2_3
"
initFunction
:
init
initArgs
:
[
[
]
]
initSetting
(
)
{
installPackage
(
"
version2_2upgrade_profile
"
)
;
}
async
breakInit
(
)
{
installPackage
(
"
broken2_2_profile
"
)
;
}
unbreakInit
(
)
{
let
db
=
getRelativeFile
(
"
storage
.
sqlite
"
)
;
db
.
remove
(
false
)
;
}
expectedResult
:
{
initFailure
:
[
1
0
]
initFailureThenSuccess
:
[
1
1
0
]
}
}
{
key
:
"
DefaultRepository
"
initFunction
:
initTemporaryStorage
initArgs
:
[
[
]
]
get
metadataDir
(
)
{
return
getRelativeFile
(
"
storage
/
default
/
https
+
+
+
example
.
com
/
.
metadata
-
v2
"
)
;
}
async
initSetting
(
)
{
let
originDir
=
getRelativeFile
(
"
storage
/
default
/
https
+
+
+
example1
.
com
/
"
)
;
if
(
!
originDir
.
exists
(
)
)
{
originDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
}
async
breakInit
(
)
{
let
request
=
init
(
)
;
await
requestFinished
(
request
)
;
this
.
metadataDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
unbreakInit
(
)
{
this
.
metadataDir
.
remove
(
false
)
;
}
expectedResult
:
{
initFailure
:
[
1
0
]
initFailureThenSuccess
:
[
1
1
0
]
}
}
{
key
:
"
TemporaryRepository
"
initFunction
:
initTemporaryStorage
initArgs
:
[
[
]
]
get
metadataDir
(
)
{
return
getRelativeFile
(
"
storage
/
temporary
/
https
+
+
+
example
.
com
/
.
metadata
-
v2
"
)
;
}
async
initSetting
(
)
{
let
originDir
=
getRelativeFile
(
"
storage
/
temporary
/
https
+
+
+
example1
.
com
/
"
)
;
if
(
!
originDir
.
exists
(
)
)
{
originDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
}
async
breakInit
(
)
{
let
request
=
init
(
)
;
await
requestFinished
(
request
)
;
this
.
metadataDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
unbreakInit
(
)
{
this
.
metadataDir
.
remove
(
false
)
;
}
expectedResult
:
{
initFailure
:
[
1
0
]
initFailureThenSuccess
:
[
1
1
0
]
}
}
]
;
function
verifyResult
(
histogram
key
expectedResult
)
{
const
snapshot
=
histogram
.
snapshot
(
)
;
ok
(
key
in
snapshot
The
histogram
{
histogram
.
name
(
)
}
must
contain
{
key
}
)
;
is
(
Object
.
entries
(
snapshot
[
key
]
.
values
)
.
length
expectedResult
.
length
Reported
telemetry
should
have
the
same
size
as
expected
result
(
{
expectedResult
.
length
}
)
)
;
for
(
let
i
=
0
;
i
<
expectedResult
.
length
;
+
+
i
)
{
is
(
snapshot
[
key
]
.
values
[
i
]
expectedResult
[
i
]
Expected
counts
should
match
for
{
histogram
.
name
(
)
}
at
index
{
i
}
)
;
}
}
async
function
testSteps
(
)
{
let
request
;
for
(
let
testcase
of
testcases
)
{
const
key
=
testcase
.
key
;
info
(
"
Verifying
the
telemetry
probe
"
+
telemetry
+
"
for
the
key
"
+
key
)
;
const
histogram
=
TelemetryTestUtils
.
getAndClearKeyedHistogram
(
telemetry
)
;
for
(
let
expectedInitResult
of
[
false
true
]
)
{
info
(
"
Verifying
the
reported
result
on
the
Telemetry
is
expected
when
"
+
"
the
init
"
+
(
expectedInitResult
?
"
succeeds
"
:
"
fails
"
)
)
;
if
(
testcase
.
initSetting
)
{
await
testcase
.
initSetting
(
)
;
}
if
(
!
expectedInitResult
)
{
await
testcase
.
breakInit
(
)
;
}
const
msg
=
"
Should
"
+
(
expectedInitResult
?
"
not
"
:
"
"
)
+
"
have
thrown
"
;
for
(
let
i
=
0
;
i
<
2
;
+
+
i
)
{
for
(
let
initArg
of
testcase
.
initArgs
)
{
request
=
testcase
.
initFunction
(
.
.
.
initArg
)
;
try
{
await
requestFinished
(
request
)
;
ok
(
expectedInitResult
msg
)
;
}
catch
(
ex
)
{
ok
(
!
expectedInitResult
msg
)
;
}
}
}
if
(
!
expectedInitResult
)
{
testcase
.
unbreakInit
(
)
;
}
const
expectedResultForThisRun
=
expectedInitResult
?
testcase
.
expectedResult
.
initFailureThenSuccess
:
testcase
.
expectedResult
.
initFailure
;
verifyResult
(
histogram
key
expectedResultForThisRun
)
;
request
=
reset
(
)
;
await
requestFinished
(
request
)
;
}
request
=
clear
(
)
;
await
requestFinished
(
request
)
;
}
}
