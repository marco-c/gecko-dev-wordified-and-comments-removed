const
{
PrefUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
dom
/
quota
/
test
/
modules
/
PrefUtils
.
sys
.
mjs
"
)
;
const
{
PrincipalUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
dom
/
quota
/
test
/
modules
/
PrincipalUtils
.
sys
.
mjs
"
)
;
const
{
QuotaUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
dom
/
quota
/
test
/
modules
/
QuotaUtils
.
sys
.
mjs
"
)
;
const
{
SimpleDBUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
dom
/
simpledb
/
test
/
modules
/
SimpleDBUtils
.
sys
.
mjs
"
)
;
const
storageSizeKB
=
32
;
async
function
testTemporaryStorageEviction
(
)
{
const
storageSize
=
storageSizeKB
*
1024
;
const
originInfos
=
[
{
url
:
"
https
:
/
/
www
.
alpha
.
com
"
flags
:
[
0
1
1
1
1
]
}
{
url
:
"
https
:
/
/
www
.
beta
.
com
"
flags
:
[
0
1
0
0
0
]
}
{
url
:
"
https
:
/
/
www
.
gamma
.
com
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www
.
delta
.
com
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www
.
epsilon
.
com
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www2
.
alpha
.
com
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www2
.
beta
.
com
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www2
.
gamma
.
com
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www2
.
delta
.
com
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www2
.
epsilon
.
com
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www3
.
alpha
.
com
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www3
.
beta
.
com
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www3
.
gamma
.
com
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www3
.
delta
.
com
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www3
.
epsilon
.
com
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www
.
alpha
.
org
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www
.
beta
.
org
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www
.
gamma
.
org
"
flags
:
[
0
1
1
0
0
]
}
{
url
:
"
https
:
/
/
www
.
delta
.
org
"
flags
:
[
0
1
1
1
0
]
}
{
url
:
"
https
:
/
/
www
.
epsilon
.
org
"
flags
:
[
0
1
1
1
1
]
}
{
url
:
"
https
:
/
/
www
.
zeta
.
org
"
flags
:
[
0
1
1
1
1
]
}
{
url
:
"
https
:
/
/
www
.
eta
.
org
"
flags
:
[
0
1
1
1
1
]
}
{
url
:
"
https
:
/
/
www
.
theta
.
org
"
flags
:
[
0
1
1
1
1
]
}
{
url
:
"
https
:
/
/
www
.
iota
.
org
"
flags
:
[
0
1
1
1
1
]
}
{
url
:
"
https
:
/
/
www
.
kappa
.
org
"
flags
:
[
0
1
1
1
1
]
}
{
url
:
"
https
:
/
/
www
.
lambda
.
org
"
flags
:
[
0
1
1
1
1
]
}
{
url
:
"
https
:
/
/
www
.
mu
.
org
"
flags
:
[
0
1
1
1
1
]
}
{
url
:
"
https
:
/
/
www
.
nu
.
org
"
flags
:
[
0
1
1
1
1
]
}
{
url
:
"
https
:
/
/
www
.
xi
.
org
"
flags
:
[
0
1
1
1
1
]
}
{
url
:
"
https
:
/
/
www
.
omicron
.
org
"
flags
:
[
0
1
1
1
1
]
}
{
url
:
"
https
:
/
/
www
.
pi
.
org
"
flags
:
[
0
1
1
1
1
]
}
{
url
:
"
https
:
/
/
www
.
rho
.
org
"
flags
:
[
0
1
1
1
1
]
}
{
url
:
"
https
:
/
/
www
.
omega
.
org
"
flags
:
[
0
0
1
1
1
]
}
]
;
Assert
.
equal
(
storageSize
%
(
originInfos
.
length
-
1
)
0
"
Correct
storage
size
"
)
;
const
name
=
"
test_temporaryStorageEviction
"
;
const
dataSize
=
storageSize
/
(
originInfos
.
length
-
1
)
;
const
dataBuffer
=
new
ArrayBuffer
(
dataSize
)
;
async
function
checkUsage
(
stage
)
{
for
(
const
originInfo
of
originInfos
)
{
const
url
=
originInfo
.
url
;
info
(
Checking
usage
for
{
url
}
)
;
const
principal
=
PrincipalUtils
.
createPrincipal
(
url
)
;
const
request
=
Services
.
qms
.
getUsageForPrincipal
(
principal
{
}
)
;
const
usageResult
=
await
QuotaUtils
.
requestFinished
(
request
)
;
if
(
originInfo
.
flags
[
stage
-
1
]
)
{
Assert
.
greater
(
usageResult
.
usage
0
"
Correct
usage
"
)
;
}
else
{
Assert
.
equal
(
usageResult
.
usage
0
"
Correct
usage
"
)
;
}
}
}
async
function
createAndOpenConnection
(
url
)
{
const
principal
=
PrincipalUtils
.
createPrincipal
(
url
)
;
const
connection
=
SimpleDBUtils
.
createConnection
(
principal
)
;
const
openRequest
=
connection
.
open
(
name
)
;
await
SimpleDBUtils
.
requestFinished
(
openRequest
)
;
return
connection
;
}
info
(
"
Stage
1
:
Reverse
creation
of
origins
to
test
first
/
last
access
time
updates
"
)
;
info
(
"
Initializing
storage
"
)
;
{
const
request
=
Services
.
qms
.
init
(
)
;
await
QuotaUtils
.
requestFinished
(
request
)
;
}
info
(
"
Initializing
temporary
storage
"
)
;
{
const
request
=
Services
.
qms
.
initTemporaryStorage
(
)
;
await
QuotaUtils
.
requestFinished
(
request
)
;
}
info
(
"
Initializing
temporary
origins
"
)
;
for
(
const
originInfo
of
originInfos
.
toReversed
(
)
)
{
const
principal
=
PrincipalUtils
.
createPrincipal
(
originInfo
.
url
)
;
const
request
=
Services
.
qms
.
initializeTemporaryOrigin
(
"
default
"
principal
true
)
;
await
QuotaUtils
.
requestFinished
(
request
)
;
await
new
Promise
(
function
(
resolve
)
{
do_timeout
(
40
resolve
)
;
}
)
;
}
info
(
"
Checking
usage
"
)
;
await
checkUsage
(
1
)
;
info
(
"
Stage
2
:
All
origins
active
;
eviction
not
possible
last
write
should
fail
"
)
;
const
connections
=
await
(
async
function
(
)
{
let
connections
=
[
]
;
for
(
const
originInfo
of
originInfos
)
{
const
connection
=
await
createAndOpenConnection
(
originInfo
.
url
)
;
connections
.
push
(
connection
)
;
}
return
connections
;
}
)
(
)
;
for
(
const
connection
of
connections
.
slice
(
0
-
1
)
)
{
const
writeRequest
=
connection
.
write
(
dataBuffer
)
;
await
SimpleDBUtils
.
requestFinished
(
writeRequest
)
;
}
{
const
writeRequest
=
connections
.
at
(
-
1
)
.
write
(
dataBuffer
)
;
try
{
await
SimpleDBUtils
.
requestFinished
(
writeRequest
)
;
Assert
.
ok
(
false
"
Should
have
thrown
"
)
;
}
catch
(
e
)
{
Assert
.
ok
(
true
"
Should
have
thrown
"
)
;
Assert
.
strictEqual
(
e
.
resultCode
NS_ERROR_FILE_NO_DEVICE_SPACE
"
Threw
right
result
code
"
)
;
}
}
await
checkUsage
(
2
)
;
info
(
"
Stage
3
:
Inactive
origins
can
be
evicted
;
last
origin
writes
again
"
)
;
for
(
const
connection
of
connections
.
slice
(
1
-
1
)
)
{
const
closeRequest
=
connection
.
close
(
)
;
await
SimpleDBUtils
.
requestFinished
(
closeRequest
)
;
await
new
Promise
(
function
(
resolve
)
{
do_timeout
(
40
resolve
)
;
}
)
;
}
{
const
writeRequest
=
connections
.
at
(
-
1
)
.
write
(
dataBuffer
)
;
await
SimpleDBUtils
.
requestFinished
(
writeRequest
)
;
}
await
checkUsage
(
3
)
;
info
(
"
Stage
4
:
Shrink
quota
by
50
%
;
evict
origins
by
last
access
time
"
)
;
info
(
"
Shutting
down
storage
"
)
;
{
const
request
=
Services
.
qms
.
reset
(
)
;
await
QuotaUtils
.
requestFinished
(
request
)
;
}
info
(
"
Setting
preferences
"
)
;
{
const
prefs
=
[
[
"
dom
.
quotaManager
.
temporaryStorage
.
fixedLimit
"
storageSizeKB
/
2
]
]
;
PrefUtils
.
setPrefs
(
prefs
)
;
}
info
(
"
Initializing
storage
"
)
;
{
const
request
=
Services
.
qms
.
init
(
)
;
await
QuotaUtils
.
requestFinished
(
request
)
;
}
info
(
"
Initializing
temporary
storage
"
)
;
{
const
request
=
Services
.
qms
.
initTemporaryStorage
(
)
;
await
QuotaUtils
.
requestFinished
(
request
)
;
}
await
checkUsage
(
4
)
;
info
(
"
Stage
5
:
Last
origin
writes
more
;
one
more
origin
should
be
evicted
"
)
;
{
const
connection
=
await
createAndOpenConnection
(
originInfos
.
at
(
-
1
)
.
url
)
;
const
seekRequest
=
connection
.
seek
(
dataSize
)
;
await
SimpleDBUtils
.
requestFinished
(
seekRequest
)
;
const
writeRequest
=
connection
.
write
(
dataBuffer
)
;
await
SimpleDBUtils
.
requestFinished
(
writeRequest
)
;
}
await
checkUsage
(
5
)
;
}
async
function
testSteps
(
)
{
add_task
(
{
pref_set
:
[
[
"
dom
.
quotaManager
.
loadQuotaFromCache
"
false
]
[
"
dom
.
quotaManager
.
temporaryStorage
.
fixedLimit
"
storageSizeKB
]
[
"
dom
.
quotaManager
.
temporaryStorage
.
updateOriginAccessTime
"
true
]
]
}
testTemporaryStorageEviction
)
;
}
