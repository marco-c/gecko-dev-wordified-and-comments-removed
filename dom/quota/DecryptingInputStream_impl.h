#
ifndef
mozilla_dom_quota_DecryptingInputStream_impl_h
#
define
mozilla_dom_quota_DecryptingInputStream_impl_h
#
include
"
DecryptingInputStream
.
h
"
#
include
"
CipherStrategy
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsStreamUtils
.
h
"
namespace
mozilla
:
:
dom
:
:
quota
{
template
<
typename
CipherStrategy
>
DecryptingInputStream
<
CipherStrategy
>
:
:
DecryptingInputStream
(
MovingNotNull
<
nsCOMPtr
<
nsIInputStream
>
>
aBaseStream
size_t
aBlockSize
CipherStrategy
aCipherStrategy
typename
CipherStrategy
:
:
KeyType
aKey
)
:
DecryptingInputStreamBase
(
std
:
:
move
(
aBaseStream
)
aBlockSize
)
mCipherStrategy
(
std
:
:
move
(
aCipherStrategy
)
)
mKey
(
aKey
)
{
#
ifdef
DEBUG
bool
baseNonBlocking
;
nsresult
rv
=
(
*
mBaseStream
)
-
>
IsNonBlocking
(
&
baseNonBlocking
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_ASSERT
(
!
baseNonBlocking
)
;
#
endif
}
template
<
typename
CipherStrategy
>
DecryptingInputStream
<
CipherStrategy
>
:
:
~
DecryptingInputStream
(
)
{
Close
(
)
;
}
template
<
typename
CipherStrategy
>
NS_IMETHODIMP
DecryptingInputStream
<
CipherStrategy
>
:
:
Close
(
)
{
if
(
!
mBaseStream
)
{
return
NS_OK
;
}
(
*
mBaseStream
)
-
>
Close
(
)
;
mBaseStream
.
destroy
(
)
;
mPlainBuffer
.
Clear
(
)
;
mEncryptedBlock
.
reset
(
)
;
return
NS_OK
;
}
template
<
typename
CipherStrategy
>
NS_IMETHODIMP
DecryptingInputStream
<
CipherStrategy
>
:
:
Available
(
uint64_t
*
aLengthOut
)
{
if
(
!
mBaseStream
)
{
return
NS_BASE_STREAM_CLOSED
;
}
*
aLengthOut
=
PlainLength
(
)
;
if
(
*
aLengthOut
>
0
)
{
return
NS_OK
;
}
uint32_t
bytesRead
;
do
{
nsresult
rv
=
ParseNextChunk
(
&
bytesRead
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aLengthOut
=
PlainLength
(
)
;
}
while
(
*
aLengthOut
=
=
0
&
&
bytesRead
)
;
return
NS_OK
;
}
template
<
typename
CipherStrategy
>
NS_IMETHODIMP
DecryptingInputStream
<
CipherStrategy
>
:
:
ReadSegments
(
nsWriteSegmentFun
aWriter
void
*
aClosure
uint32_t
aCount
uint32_t
*
aBytesReadOut
)
{
*
aBytesReadOut
=
0
;
if
(
!
mBaseStream
)
{
return
NS_BASE_STREAM_CLOSED
;
}
nsresult
rv
;
while
(
aCount
>
0
)
{
if
(
mPlainBytes
>
0
)
{
MOZ_ASSERT
(
!
mPlainBuffer
.
IsEmpty
(
)
)
;
uint32_t
remaining
=
PlainLength
(
)
;
uint32_t
numToWrite
=
std
:
:
min
(
aCount
remaining
)
;
uint32_t
numWritten
;
rv
=
aWriter
(
this
aClosure
reinterpret_cast
<
const
char
*
>
(
&
mPlainBuffer
[
mNextByte
]
)
*
aBytesReadOut
numToWrite
&
numWritten
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
if
(
numWritten
=
=
0
)
{
return
NS_OK
;
}
*
aBytesReadOut
+
=
numWritten
;
mNextByte
+
=
numWritten
;
MOZ_ASSERT
(
mNextByte
<
=
mPlainBytes
)
;
if
(
mNextByte
=
=
mPlainBytes
)
{
mNextByte
=
0
;
mPlainBytes
=
0
;
}
aCount
-
=
numWritten
;
continue
;
}
uint32_t
bytesRead
;
rv
=
ParseNextChunk
(
&
bytesRead
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
bytesRead
=
=
0
&
&
mPlainBytes
=
=
0
)
{
return
NS_OK
;
}
mPlainBytes
+
=
bytesRead
;
}
return
NS_OK
;
}
template
<
typename
CipherStrategy
>
nsresult
DecryptingInputStream
<
CipherStrategy
>
:
:
ParseNextChunk
(
uint32_t
*
const
aBytesReadOut
)
{
MOZ_ASSERT
(
mPlainBytes
=
=
0
)
;
MOZ_ASSERT
(
mNextByte
=
=
0
)
;
*
aBytesReadOut
=
0
;
if
(
!
EnsureBuffers
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
auto
wholeBlock
=
mEncryptedBlock
-
>
MutableWholeBlock
(
)
;
nsresult
rv
=
ReadAll
(
AsWritableChars
(
wholeBlock
)
.
Elements
(
)
wholeBlock
.
Length
(
)
wholeBlock
.
Length
(
)
aBytesReadOut
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
*
aBytesReadOut
=
=
0
)
{
return
rv
;
}
rv
=
mCipherStrategy
.
Cipher
(
CipherMode
:
:
Decrypt
mKey
mEncryptedBlock
-
>
MutableCipherPrefix
(
)
mEncryptedBlock
-
>
Payload
(
)
AsWritableBytes
(
Span
{
mPlainBuffer
}
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aBytesReadOut
=
mEncryptedBlock
-
>
ActualPayloadLength
(
)
;
return
NS_OK
;
}
template
<
typename
CipherStrategy
>
nsresult
DecryptingInputStream
<
CipherStrategy
>
:
:
ReadAll
(
char
*
aBuf
uint32_t
aCount
uint32_t
aMinValidCount
uint32_t
*
aBytesReadOut
)
{
MOZ_ASSERT
(
aCount
>
=
aMinValidCount
)
;
MOZ_ASSERT
(
mBaseStream
)
;
*
aBytesReadOut
=
0
;
uint32_t
offset
=
0
;
while
(
aCount
>
0
)
{
uint32_t
bytesRead
=
0
;
nsresult
rv
=
(
*
mBaseStream
)
-
>
Read
(
aBuf
+
offset
aCount
&
bytesRead
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
bytesRead
=
=
0
)
{
break
;
}
*
aBytesReadOut
+
=
bytesRead
;
offset
+
=
bytesRead
;
aCount
-
=
bytesRead
;
}
if
(
*
aBytesReadOut
!
=
0
&
&
*
aBytesReadOut
<
aMinValidCount
)
{
return
NS_ERROR_CORRUPTED_CONTENT
;
}
return
NS_OK
;
}
template
<
typename
CipherStrategy
>
bool
DecryptingInputStream
<
CipherStrategy
>
:
:
EnsureBuffers
(
)
{
if
(
!
mEncryptedBlock
)
{
mEncryptedBlock
.
emplace
(
mBlockSize
)
;
MOZ_ASSERT
(
mPlainBuffer
.
IsEmpty
(
)
)
;
if
(
NS_WARN_IF
(
!
mPlainBuffer
.
SetLength
(
mEncryptedBlock
-
>
MaxPayloadLength
(
)
fallible
)
)
)
{
return
false
;
}
}
return
true
;
}
}
#
endif
