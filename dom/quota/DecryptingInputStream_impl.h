#
ifndef
mozilla_dom_quota_DecryptingInputStream_impl_h
#
define
mozilla_dom_quota_DecryptingInputStream_impl_h
#
include
"
DecryptingInputStream
.
h
"
#
include
"
CipherStrategy
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsStreamUtils
.
h
"
namespace
mozilla
:
:
dom
:
:
quota
{
template
<
typename
CipherStrategy
>
DecryptingInputStream
<
CipherStrategy
>
:
:
DecryptingInputStream
(
MovingNotNull
<
nsCOMPtr
<
nsIInputStream
>
>
aBaseStream
size_t
aBlockSize
CipherStrategy
aCipherStrategy
typename
CipherStrategy
:
:
KeyType
aKey
)
:
DecryptingInputStreamBase
(
std
:
:
move
(
aBaseStream
)
aBlockSize
)
mCipherStrategy
(
std
:
:
move
(
aCipherStrategy
)
)
mKey
(
aKey
)
{
#
ifdef
DEBUG
bool
baseNonBlocking
;
nsresult
rv
=
(
*
mBaseStream
)
-
>
IsNonBlocking
(
&
baseNonBlocking
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_ASSERT
(
!
baseNonBlocking
)
;
#
endif
}
template
<
typename
CipherStrategy
>
DecryptingInputStream
<
CipherStrategy
>
:
:
~
DecryptingInputStream
(
)
{
Close
(
)
;
}
template
<
typename
CipherStrategy
>
NS_IMETHODIMP
DecryptingInputStream
<
CipherStrategy
>
:
:
Close
(
)
{
if
(
!
mBaseStream
)
{
return
NS_OK
;
}
(
*
mBaseStream
)
-
>
Close
(
)
;
mBaseStream
.
destroy
(
)
;
mPlainBuffer
.
Clear
(
)
;
mEncryptedBlock
.
reset
(
)
;
return
NS_OK
;
}
template
<
typename
CipherStrategy
>
NS_IMETHODIMP
DecryptingInputStream
<
CipherStrategy
>
:
:
Available
(
uint64_t
*
aLengthOut
)
{
if
(
!
mBaseStream
)
{
return
NS_BASE_STREAM_CLOSED
;
}
*
aLengthOut
=
PlainLength
(
)
;
if
(
*
aLengthOut
>
0
)
{
return
NS_OK
;
}
uint32_t
bytesRead
;
do
{
nsresult
rv
=
ParseNextChunk
(
&
bytesRead
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aLengthOut
=
PlainLength
(
)
;
}
while
(
*
aLengthOut
=
=
0
&
&
bytesRead
)
;
return
NS_OK
;
}
template
<
typename
CipherStrategy
>
NS_IMETHODIMP
DecryptingInputStream
<
CipherStrategy
>
:
:
ReadSegments
(
nsWriteSegmentFun
aWriter
void
*
aClosure
uint32_t
aCount
uint32_t
*
aBytesReadOut
)
{
*
aBytesReadOut
=
0
;
if
(
!
mBaseStream
)
{
return
NS_BASE_STREAM_CLOSED
;
}
nsresult
rv
;
while
(
aCount
>
0
)
{
if
(
mPlainBytes
>
0
)
{
MOZ_ASSERT
(
!
mPlainBuffer
.
IsEmpty
(
)
)
;
uint32_t
remaining
=
PlainLength
(
)
;
uint32_t
numToWrite
=
std
:
:
min
(
aCount
remaining
)
;
uint32_t
numWritten
;
rv
=
aWriter
(
this
aClosure
reinterpret_cast
<
const
char
*
>
(
&
mPlainBuffer
[
mNextByte
]
)
*
aBytesReadOut
numToWrite
&
numWritten
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
if
(
numWritten
=
=
0
)
{
return
NS_OK
;
}
*
aBytesReadOut
+
=
numWritten
;
mNextByte
+
=
numWritten
;
MOZ_ASSERT
(
mNextByte
<
=
mPlainBytes
)
;
if
(
mNextByte
=
=
mPlainBytes
)
{
mNextByte
=
0
;
mLastBlockLength
=
mPlainBytes
;
mPlainBytes
=
0
;
}
aCount
-
=
numWritten
;
continue
;
}
uint32_t
bytesRead
;
rv
=
ParseNextChunk
(
&
bytesRead
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
bytesRead
=
=
0
&
&
mPlainBytes
=
=
0
)
{
return
NS_OK
;
}
mPlainBytes
+
=
bytesRead
;
}
return
NS_OK
;
}
template
<
typename
CipherStrategy
>
nsresult
DecryptingInputStream
<
CipherStrategy
>
:
:
ParseNextChunk
(
uint32_t
*
const
aBytesReadOut
)
{
MOZ_ASSERT
(
mPlainBytes
=
=
0
)
;
MOZ_ASSERT
(
mNextByte
=
=
0
)
;
*
aBytesReadOut
=
0
;
if
(
!
EnsureBuffers
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
auto
wholeBlock
=
mEncryptedBlock
-
>
MutableWholeBlock
(
)
;
nsresult
rv
=
ReadAll
(
AsWritableChars
(
wholeBlock
)
.
Elements
(
)
wholeBlock
.
Length
(
)
wholeBlock
.
Length
(
)
aBytesReadOut
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
*
aBytesReadOut
=
=
0
)
{
return
rv
;
}
rv
=
mCipherStrategy
.
Cipher
(
CipherMode
:
:
Decrypt
mKey
mEncryptedBlock
-
>
MutableCipherPrefix
(
)
mEncryptedBlock
-
>
Payload
(
)
AsWritableBytes
(
Span
{
mPlainBuffer
}
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aBytesReadOut
=
mEncryptedBlock
-
>
ActualPayloadLength
(
)
;
return
NS_OK
;
}
template
<
typename
CipherStrategy
>
nsresult
DecryptingInputStream
<
CipherStrategy
>
:
:
ReadAll
(
char
*
aBuf
uint32_t
aCount
uint32_t
aMinValidCount
uint32_t
*
aBytesReadOut
)
{
MOZ_ASSERT
(
aCount
>
=
aMinValidCount
)
;
MOZ_ASSERT
(
mBaseStream
)
;
*
aBytesReadOut
=
0
;
uint32_t
offset
=
0
;
while
(
aCount
>
0
)
{
uint32_t
bytesRead
=
0
;
nsresult
rv
=
(
*
mBaseStream
)
-
>
Read
(
aBuf
+
offset
aCount
&
bytesRead
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
bytesRead
=
=
0
)
{
break
;
}
*
aBytesReadOut
+
=
bytesRead
;
offset
+
=
bytesRead
;
aCount
-
=
bytesRead
;
}
if
(
*
aBytesReadOut
!
=
0
&
&
*
aBytesReadOut
<
aMinValidCount
)
{
return
NS_ERROR_CORRUPTED_CONTENT
;
}
return
NS_OK
;
}
template
<
typename
CipherStrategy
>
bool
DecryptingInputStream
<
CipherStrategy
>
:
:
EnsureBuffers
(
)
{
if
(
!
mEncryptedBlock
)
{
mEncryptedBlock
.
emplace
(
mBlockSize
)
;
MOZ_ASSERT
(
mPlainBuffer
.
IsEmpty
(
)
)
;
if
(
NS_WARN_IF
(
!
mPlainBuffer
.
SetLength
(
mEncryptedBlock
-
>
MaxPayloadLength
(
)
fallible
)
)
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
CipherStrategy
>
NS_IMETHODIMP
DecryptingInputStream
<
CipherStrategy
>
:
:
Tell
(
int64_t
*
const
aRetval
)
{
MOZ_ASSERT
(
aRetval
)
;
if
(
!
mBaseStream
)
{
return
NS_BASE_STREAM_CLOSED
;
}
int64_t
basePosition
;
nsresult
rv
=
(
*
mBaseSeekableStream
)
-
>
Tell
(
&
basePosition
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
const
auto
fullBlocks
=
basePosition
/
mBlockSize
;
MOZ_ASSERT
(
0
=
=
basePosition
%
mBlockSize
)
;
*
aRetval
=
(
fullBlocks
-
(
(
mPlainBytes
|
|
mLastBlockLength
)
?
1
:
0
)
)
*
mEncryptedBlock
-
>
MaxPayloadLength
(
)
+
mNextByte
+
(
mNextByte
?
0
:
mLastBlockLength
)
;
return
NS_OK
;
}
template
<
typename
CipherStrategy
>
NS_IMETHODIMP
DecryptingInputStream
<
CipherStrategy
>
:
:
Seek
(
const
int32_t
aWhence
int64_t
aOffset
)
{
if
(
!
mBaseStream
)
{
return
NS_BASE_STREAM_CLOSED
;
}
if
(
!
EnsureBuffers
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
int64_t
baseBlocksOffset
;
int64_t
nextByteOffset
;
switch
(
aWhence
)
{
case
NS_SEEK_CUR
:
{
int64_t
current
;
nsresult
rv
=
Tell
(
&
current
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aOffset
+
=
current
;
}
break
;
case
NS_SEEK_SET
:
break
;
case
NS_SEEK_END
:
{
nsresult
rv
=
(
*
mBaseSeekableStream
)
-
>
Seek
(
NS_SEEK_SET
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
uint64_t
baseStreamSize
;
rv
=
(
*
mBaseStream
)
-
>
Available
(
&
baseStreamSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
auto
decryptedStreamSizeOrErr
=
[
baseStreamSize
this
]
(
)
-
>
Result
<
int64_t
nsresult
>
{
if
(
!
baseStreamSize
)
{
return
0
;
}
nsresult
rv
=
(
*
mBaseSeekableStream
)
-
>
Seek
(
NS_SEEK_END
-
static_cast
<
int64_t
>
(
mBlockSize
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
uint32_t
bytesRead
;
rv
=
ParseNextChunk
(
&
bytesRead
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
MOZ_ASSERT
(
bytesRead
)
;
mPlainBytes
=
bytesRead
;
mNextByte
=
bytesRead
;
int64_t
current
;
rv
=
Tell
(
&
current
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
return
current
;
}
(
)
;
if
(
decryptedStreamSizeOrErr
.
isErr
(
)
)
{
return
decryptedStreamSizeOrErr
.
unwrapErr
(
)
;
}
aOffset
+
=
decryptedStreamSizeOrErr
.
unwrap
(
)
;
}
break
;
default
:
return
NS_ERROR_ILLEGAL_VALUE
;
}
baseBlocksOffset
=
aOffset
/
mEncryptedBlock
-
>
MaxPayloadLength
(
)
;
nextByteOffset
=
aOffset
%
mEncryptedBlock
-
>
MaxPayloadLength
(
)
;
nsresult
rv
=
(
*
mBaseSeekableStream
)
-
>
Seek
(
NS_SEEK_SET
baseBlocksOffset
*
mBlockSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mNextByte
=
0
;
mPlainBytes
=
0
;
uint32_t
readBytes
;
rv
=
ParseNextChunk
(
&
readBytes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
readBytes
)
{
if
(
baseBlocksOffset
=
=
0
)
{
return
aOffset
=
=
0
?
NS_OK
:
NS_ERROR_ILLEGAL_VALUE
;
}
nsresult
rv
=
(
*
mBaseSeekableStream
)
-
>
Seek
(
NS_SEEK_CUR
-
mBlockSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
ParseNextChunk
(
&
readBytes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
mPlainBytes
=
readBytes
;
mNextByte
=
nextByteOffset
;
return
NS_OK
;
}
}
#
endif
