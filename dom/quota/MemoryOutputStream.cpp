#
include
"
MemoryOutputStream
.
h
"
#
include
"
nsStreamUtils
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
quota
{
already_AddRefed
<
MemoryOutputStream
>
MemoryOutputStream
:
:
Create
(
uint64_t
aSize
)
{
MOZ_ASSERT
(
aSize
"
Passed
zero
size
!
"
)
;
if
(
NS_WARN_IF
(
aSize
>
UINT32_MAX
)
)
{
return
nullptr
;
}
RefPtr
<
MemoryOutputStream
>
stream
=
new
MemoryOutputStream
(
)
;
char
*
dummy
;
uint32_t
length
=
stream
-
>
mData
.
GetMutableData
(
&
dummy
aSize
fallible
)
;
if
(
NS_WARN_IF
(
length
!
=
aSize
)
)
{
return
nullptr
;
}
return
stream
.
forget
(
)
;
}
NS_IMPL_ISUPPORTS
(
MemoryOutputStream
nsIOutputStream
)
NS_IMETHODIMP
MemoryOutputStream
:
:
Close
(
)
{
mData
.
Truncate
(
mOffset
)
;
return
NS_OK
;
}
NS_IMETHODIMP
MemoryOutputStream
:
:
Write
(
const
char
*
aBuf
uint32_t
aCount
uint32_t
*
_retval
)
{
return
WriteSegments
(
NS_CopySegmentToBuffer
(
char
*
)
aBuf
aCount
_retval
)
;
}
NS_IMETHODIMP
MemoryOutputStream
:
:
Flush
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
MemoryOutputStream
:
:
WriteFrom
(
nsIInputStream
*
aFromStream
uint32_t
aCount
uint32_t
*
_retval
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
MemoryOutputStream
:
:
WriteSegments
(
nsReadSegmentFun
aReader
void
*
aClosure
uint32_t
aCount
uint32_t
*
_retval
)
{
MOZ_ASSERT
(
mData
.
Length
(
)
>
=
mOffset
"
Bad
stream
state
!
"
)
;
uint32_t
maxCount
=
mData
.
Length
(
)
-
mOffset
;
if
(
maxCount
=
=
0
)
{
*
_retval
=
0
;
return
NS_OK
;
}
if
(
aCount
>
maxCount
)
{
aCount
=
maxCount
;
}
nsresult
rv
=
aReader
(
this
aClosure
mData
.
BeginWriting
(
)
+
mOffset
0
aCount
_retval
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_ASSERT
(
*
_retval
<
=
aCount
"
Reader
should
not
read
more
than
we
asked
it
to
read
!
"
)
;
mOffset
+
=
*
_retval
;
}
return
NS_OK
;
}
NS_IMETHODIMP
MemoryOutputStream
:
:
IsNonBlocking
(
bool
*
_retval
)
{
*
_retval
=
false
;
return
NS_OK
;
}
}
}
}
