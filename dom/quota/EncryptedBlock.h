#
ifndef
mozilla_dom_quota_EncryptedBlock_h
#
define
mozilla_dom_quota_EncryptedBlock_h
#
include
<
cstdint
>
#
include
<
cstring
>
#
include
<
limits
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
:
:
dom
:
:
quota
{
template
<
size_t
CipherPrefixLength
size_t
BasicBlockSize
>
class
EncryptedBlock
{
public
:
explicit
EncryptedBlock
(
const
size_t
aOverallSize
)
{
MOZ_RELEASE_ASSERT
(
aOverallSize
>
CipherPrefixOffset
(
)
+
CipherPrefixLength
)
;
MOZ_RELEASE_ASSERT
(
aOverallSize
<
=
std
:
:
numeric_limits
<
uint16_t
>
:
:
max
(
)
)
;
mData
.
SetLength
(
aOverallSize
)
;
std
:
:
fill
(
mData
.
begin
(
)
mData
.
begin
(
)
+
CipherPrefixOffset
(
)
0
)
;
SetActualPayloadLength
(
MaxPayloadLength
(
)
)
;
}
size_t
MaxPayloadLength
(
)
const
{
return
mData
.
Length
(
)
-
CipherPrefixLength
-
CipherPrefixOffset
(
)
;
}
void
SetActualPayloadLength
(
uint16_t
aActualPayloadLength
)
{
memcpy
(
mData
.
Elements
(
)
&
aActualPayloadLength
sizeof
(
uint16_t
)
)
;
}
size_t
ActualPayloadLength
(
)
const
{
return
*
reinterpret_cast
<
const
uint16_t
*
>
(
mData
.
Elements
(
)
)
;
}
using
ConstSpan
=
Span
<
const
uint8_t
>
;
using
MutableSpan
=
Span
<
uint8_t
>
;
ConstSpan
CipherPrefix
(
)
const
{
return
WholeBlock
(
)
.
Subspan
(
CipherPrefixOffset
(
)
CipherPrefixLength
)
;
}
MutableSpan
MutableCipherPrefix
(
)
{
return
MutableWholeBlock
(
)
.
Subspan
(
CipherPrefixOffset
(
)
CipherPrefixLength
)
;
}
ConstSpan
Payload
(
)
const
{
return
WholeBlock
(
)
.
SplitAt
(
CipherPrefixOffset
(
)
+
CipherPrefixLength
)
.
second
.
First
(
RoundedUpToBasicBlockSize
(
ActualPayloadLength
(
)
)
)
;
}
MutableSpan
MutablePayload
(
)
{
return
MutableWholeBlock
(
)
.
SplitAt
(
CipherPrefixOffset
(
)
+
CipherPrefixLength
)
.
second
.
First
(
RoundedUpToBasicBlockSize
(
ActualPayloadLength
(
)
)
)
;
}
ConstSpan
WholeBlock
(
)
const
{
return
mData
;
}
MutableSpan
MutableWholeBlock
(
)
{
return
mData
;
}
private
:
static
constexpr
size_t
CipherPrefixOffset
(
)
{
return
RoundedUpToBasicBlockSize
(
sizeof
(
uint16_t
)
)
;
}
static
constexpr
size_t
RoundedUpToBasicBlockSize
(
const
size_t
aValue
)
{
return
(
aValue
+
BasicBlockSize
-
1
)
/
BasicBlockSize
*
BasicBlockSize
;
}
nsTArray
<
uint8_t
>
mData
;
}
;
}
#
endif
