#
ifndef
DOM_QUOTA_ORIGINOPERATIONBASE_H_
#
define
DOM_QUOTA_ORIGINOPERATIONBASE_H_
#
include
"
ErrorList
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaCommon
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
:
:
dom
:
:
quota
{
class
QuotaManager
;
class
OriginOperationBase
:
public
BackgroundThreadObject
public
Runnable
{
protected
:
nsresult
mResultCode
;
enum
State
{
State_Initial
State_DirectoryOpenPending
State_DirectoryWorkOpen
State_UnblockingOpen
State_Complete
}
;
private
:
State
mState
;
bool
mActorDestroyed
;
protected
:
bool
mNeedsStorageInit
;
public
:
void
NoteActorDestroyed
(
)
{
AssertIsOnOwningThread
(
)
;
mActorDestroyed
=
true
;
}
bool
IsActorDestroyed
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mActorDestroyed
;
}
void
RunImmediately
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
GetState
(
)
=
=
State_Initial
)
;
MOZ_ALWAYS_SUCCEEDS
(
this
-
>
Run
(
)
)
;
}
void
Dispatch
(
)
;
protected
:
explicit
OriginOperationBase
(
nsISerialEventTarget
*
aOwningThread
const
char
*
aRunnableName
)
:
BackgroundThreadObject
(
aOwningThread
)
Runnable
(
aRunnableName
)
mResultCode
(
NS_OK
)
mState
(
State_Initial
)
mActorDestroyed
(
false
)
mNeedsStorageInit
(
false
)
{
}
virtual
~
OriginOperationBase
(
)
{
MOZ_ASSERT
(
mState
=
=
State_Complete
)
;
MOZ_ASSERT
(
mActorDestroyed
)
;
}
#
ifdef
DEBUG
State
GetState
(
)
const
{
return
mState
;
}
#
endif
void
SetState
(
State
aState
)
{
MOZ_ASSERT
(
mState
=
=
State_Initial
)
;
mState
=
aState
;
}
void
AdvanceState
(
)
{
switch
(
mState
)
{
case
State_Initial
:
mState
=
State_DirectoryOpenPending
;
return
;
case
State_DirectoryOpenPending
:
mState
=
State_DirectoryWorkOpen
;
return
;
case
State_DirectoryWorkOpen
:
mState
=
State_UnblockingOpen
;
return
;
case
State_UnblockingOpen
:
mState
=
State_Complete
;
return
;
default
:
MOZ_CRASH
(
"
Bad
state
!
"
)
;
}
}
NS_IMETHOD
Run
(
)
override
;
virtual
nsresult
DoInit
(
QuotaManager
&
aQuotaManager
)
;
virtual
void
Open
(
)
=
0
;
#
ifdef
DEBUG
virtual
nsresult
DirectoryOpen
(
)
;
#
else
nsresult
DirectoryOpen
(
)
;
#
endif
virtual
nsresult
DoDirectoryWork
(
QuotaManager
&
aQuotaManager
)
=
0
;
void
Finish
(
nsresult
aResult
)
;
virtual
void
UnblockOpen
(
)
=
0
;
private
:
nsresult
Init
(
)
;
nsresult
FinishInit
(
)
;
nsresult
DirectoryWork
(
)
;
}
;
}
#
endif
