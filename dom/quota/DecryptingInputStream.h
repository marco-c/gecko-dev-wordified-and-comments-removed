#
ifndef
mozilla_dom_quota_DecryptingInputStream_h
#
define
mozilla_dom_quota_DecryptingInputStream_h
#
include
"
mozilla
/
InitializedOnce
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
EncryptedBlock
.
h
"
namespace
mozilla
:
:
dom
:
:
quota
{
class
DecryptingInputStreamBase
:
public
nsIInputStream
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_IMETHOD
Read
(
char
*
aBuf
uint32_t
aCount
uint32_t
*
_retval
)
final
;
NS_IMETHOD
IsNonBlocking
(
bool
*
_retval
)
final
;
protected
:
DecryptingInputStreamBase
(
MovingNotNull
<
nsCOMPtr
<
nsIInputStream
>
>
aBaseStream
size_t
aBlockSize
)
;
virtual
~
DecryptingInputStreamBase
(
)
=
default
;
size_t
PlainLength
(
)
const
;
size_t
EncryptedBufferLength
(
)
const
;
InitializedOnce
<
const
NotNull
<
nsCOMPtr
<
nsIInputStream
>
>
>
mBaseStream
;
size_t
mPlainBytes
=
0
;
size_t
mNextByte
=
0
;
const
size_t
mBlockSize
;
}
;
template
<
typename
CipherStrategy
>
class
DecryptingInputStream
final
:
public
DecryptingInputStreamBase
{
public
:
DecryptingInputStream
(
MovingNotNull
<
nsCOMPtr
<
nsIInputStream
>
>
aBaseStream
size_t
aBlockSize
CipherStrategy
aCipherStrategy
typename
CipherStrategy
:
:
KeyType
aKey
)
;
NS_IMETHOD
Close
(
)
override
;
NS_IMETHOD
Available
(
uint64_t
*
_retval
)
override
;
NS_IMETHOD
ReadSegments
(
nsWriteSegmentFun
aWriter
void
*
aClosure
uint32_t
aCount
uint32_t
*
_retval
)
override
;
private
:
~
DecryptingInputStream
(
)
;
nsresult
ParseNextChunk
(
uint32_t
*
aBytesReadOut
)
;
nsresult
ReadAll
(
char
*
aBuf
uint32_t
aCount
uint32_t
aMinValidCount
uint32_t
*
aBytesReadOut
)
;
bool
EnsureBuffers
(
)
;
const
CipherStrategy
mCipherStrategy
;
const
typename
CipherStrategy
:
:
KeyType
mKey
;
using
EncryptedBlockType
=
EncryptedBlock
<
CipherStrategy
:
:
BlockPrefixLength
CipherStrategy
:
:
BasicBlockSize
>
;
Maybe
<
EncryptedBlockType
>
mEncryptedBlock
;
nsTArray
<
uint8_t
>
mPlainBuffer
;
}
;
}
#
endif
