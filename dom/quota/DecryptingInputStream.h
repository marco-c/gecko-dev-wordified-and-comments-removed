#
ifndef
mozilla_dom_quota_DecryptingInputStream_h
#
define
mozilla_dom_quota_DecryptingInputStream_h
#
include
"
EncryptedBlock
.
h
"
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
"
ErrorList
.
h
"
#
include
"
mozilla
/
InitializedOnce
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
ipc
/
InputStreamParams
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsICloneableInputStream
.
h
"
#
include
"
nsIIPCSerializableInputStream
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsITellableStream
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nscore
.
h
"
template
<
class
T
>
class
nsCOMPtr
;
namespace
mozilla
:
:
dom
:
:
quota
{
class
DecryptingInputStreamBase
:
public
nsIInputStream
public
nsISeekableStream
public
nsICloneableInputStream
public
nsIIPCSerializableInputStream
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_IMETHOD
Read
(
char
*
aBuf
uint32_t
aCount
uint32_t
*
_retval
)
final
;
NS_IMETHOD
IsNonBlocking
(
bool
*
_retval
)
final
;
NS_IMETHOD
SetEOF
(
)
final
;
using
nsICloneableInputStream
:
:
GetCloneable
;
NS_IMETHOD
GetCloneable
(
bool
*
aCloneable
)
final
;
void
SerializedComplexity
(
uint32_t
aMaxSize
uint32_t
*
aSizeUsed
uint32_t
*
aPipes
uint32_t
*
aTransferables
)
override
;
protected
:
DecryptingInputStreamBase
(
MovingNotNull
<
nsCOMPtr
<
nsIInputStream
>
>
aBaseStream
size_t
aBlockSize
)
;
DecryptingInputStreamBase
(
)
=
default
;
virtual
~
DecryptingInputStreamBase
(
)
=
default
;
void
Init
(
MovingNotNull
<
nsCOMPtr
<
nsIInputStream
>
>
aBaseStream
size_t
aBlockSize
)
;
size_t
PlainLength
(
)
const
;
size_t
EncryptedBufferLength
(
)
const
;
LazyInitializedOnceEarlyDestructible
<
const
NotNull
<
nsCOMPtr
<
nsIInputStream
>
>
>
mBaseStream
;
LazyInitializedOnce
<
const
NotNull
<
nsISeekableStream
*
>
>
mBaseSeekableStream
;
LazyInitializedOnce
<
const
NotNull
<
nsICloneableInputStream
*
>
>
mBaseCloneableInputStream
;
LazyInitializedOnce
<
const
NotNull
<
nsIIPCSerializableInputStream
*
>
>
mBaseIPCSerializableInputStream
;
size_t
mPlainBytes
=
0
;
size_t
mNextByte
=
0
;
LazyInitializedOnceNotNull
<
const
size_t
>
mBlockSize
;
}
;
template
<
typename
CipherStrategy
>
class
DecryptingInputStream
final
:
public
DecryptingInputStreamBase
{
public
:
DecryptingInputStream
(
MovingNotNull
<
nsCOMPtr
<
nsIInputStream
>
>
aBaseStream
size_t
aBlockSize
typename
CipherStrategy
:
:
KeyType
aKey
)
;
explicit
DecryptingInputStream
(
)
;
NS_IMETHOD
Close
(
)
override
;
NS_IMETHOD
Available
(
uint64_t
*
_retval
)
override
;
NS_IMETHOD
StreamStatus
(
)
override
;
NS_IMETHOD
ReadSegments
(
nsWriteSegmentFun
aWriter
void
*
aClosure
uint32_t
aCount
uint32_t
*
_retval
)
override
;
NS_DECL_NSITELLABLESTREAM
NS_IMETHOD
Seek
(
int32_t
aWhence
int64_t
aOffset
)
override
;
NS_IMETHOD
Clone
(
nsIInputStream
*
*
_retval
)
override
;
void
Serialize
(
mozilla
:
:
ipc
:
:
InputStreamParams
&
aParams
uint32_t
aMaxSize
uint32_t
*
aSizeUsed
)
override
;
bool
Deserialize
(
const
mozilla
:
:
ipc
:
:
InputStreamParams
&
aParams
)
override
;
private
:
~
DecryptingInputStream
(
)
;
nsresult
ParseNextChunk
(
uint32_t
*
aBytesReadOut
)
;
nsresult
ReadAll
(
char
*
aBuf
uint32_t
aCount
uint32_t
aMinValidCount
uint32_t
*
aBytesReadOut
)
;
bool
EnsureBuffers
(
)
;
nsresult
EnsureDecryptedStreamSize
(
)
;
CipherStrategy
mCipherStrategy
;
LazyInitializedOnce
<
const
typename
CipherStrategy
:
:
KeyType
>
mKey
;
using
EncryptedBlockType
=
EncryptedBlock
<
CipherStrategy
:
:
BlockPrefixLength
CipherStrategy
:
:
BasicBlockSize
>
;
Maybe
<
EncryptedBlockType
>
mEncryptedBlock
;
nsTArray
<
uint8_t
>
mPlainBuffer
;
LazyInitializedOnce
<
const
int64_t
>
mDecryptedStreamSize
;
}
;
}
#
endif
