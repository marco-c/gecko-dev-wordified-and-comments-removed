#
ifndef
mozilla_dom_quota_quotamanager_h__
#
define
mozilla_dom_quota_quotamanager_h__
#
include
<
cstdint
>
#
include
<
utility
>
#
include
"
Client
.
h
"
#
include
"
ErrorList
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
InitializedOnce
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
CommonMetadata
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
InitializationTypes
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
PersistenceType
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaCommon
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTStringRepr
.
h
"
#
include
"
nscore
.
h
"
#
include
"
prenv
.
h
"
#
define
QUOTA_MANAGER_CONTRACTID
"
mozilla
.
org
/
dom
/
quota
/
manager
;
1
"
class
mozIStorageConnection
;
class
nsIEventTarget
;
class
nsIFile
;
class
nsIPrincipal
;
class
nsIRunnable
;
class
nsIThread
;
class
nsITimer
;
class
nsPIDOMWindowOuter
;
namespace
mozilla
{
class
OriginAttributes
;
class
QMResult
;
namespace
ipc
{
class
PrincipalInfo
;
}
}
namespace
mozilla
:
:
dom
:
:
quota
{
class
ClientUsageArray
;
class
ClientDirectoryLock
;
class
DirectoryLockImpl
;
class
GroupInfo
;
class
GroupInfoPair
;
class
OriginDirectoryLock
;
class
OriginInfo
;
class
OriginScope
;
class
QuotaObject
;
class
UniversalDirectoryLock
;
class
QuotaManager
final
:
public
BackgroundThreadObject
{
friend
class
DirectoryLockImpl
;
friend
class
GroupInfo
;
friend
class
OriginInfo
;
friend
class
QuotaObject
;
using
PrincipalInfo
=
mozilla
:
:
ipc
:
:
PrincipalInfo
;
using
DirectoryLockTable
=
nsClassHashtable
<
nsCStringHashKey
nsTArray
<
NotNull
<
DirectoryLockImpl
*
>
>
>
;
class
Observer
;
public
:
QuotaManager
(
const
nsAString
&
aBasePath
const
nsAString
&
aStorageName
)
;
NS_INLINE_DECL_REFCOUNTING
(
QuotaManager
)
static
nsresult
Initialize
(
)
;
static
bool
IsRunningXPCShellTests
(
)
{
static
bool
kRunningXPCShellTests
=
!
!
PR_GetEnv
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
;
return
kRunningXPCShellTests
;
}
static
bool
IsRunningGTests
(
)
{
static
bool
kRunningGTests
=
!
!
PR_GetEnv
(
"
MOZ_RUN_GTEST
"
)
;
return
kRunningGTests
;
}
static
const
char
kReplaceChars
[
]
;
static
Result
<
MovingNotNull
<
RefPtr
<
QuotaManager
>
>
nsresult
>
GetOrCreate
(
)
;
static
void
GetOrCreate
(
nsIRunnable
*
aCallback
)
;
static
QuotaManager
*
Get
(
)
;
static
QuotaManager
&
GetRef
(
)
;
static
bool
IsShuttingDown
(
)
;
static
void
ShutdownInstance
(
)
;
static
bool
IsOSMetadata
(
const
nsAString
&
aFileName
)
;
static
bool
IsDotFile
(
const
nsAString
&
aFileName
)
;
bool
IsOriginInitialized
(
const
nsACString
&
aOrigin
)
const
{
AssertIsOnIOThread
(
)
;
return
mInitializedOrigins
.
Contains
(
aOrigin
)
;
}
bool
IsTemporaryStorageInitialized
(
)
const
{
AssertIsOnIOThread
(
)
;
return
mTemporaryStorageInitialized
;
}
void
InitQuotaForOrigin
(
const
FullOriginMetadata
&
aFullOriginMetadata
const
ClientUsageArray
&
aClientUsages
uint64_t
aUsageBytes
)
;
void
EnsureQuotaForOrigin
(
const
OriginMetadata
&
aOriginMetadata
)
;
int64_t
NoteOriginDirectoryCreated
(
const
OriginMetadata
&
aOriginMetadata
bool
aPersisted
)
;
void
DecreaseUsageForClient
(
const
ClientMetadata
&
aClientMetadata
int64_t
aSize
)
;
void
ResetUsageForClient
(
const
ClientMetadata
&
aClientMetadata
)
;
UsageInfo
GetUsageForClient
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
Client
:
:
Type
aClientType
)
;
void
UpdateOriginAccessTime
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
)
;
void
RemoveQuota
(
)
;
void
RemoveQuotaForOrigin
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
)
{
MutexAutoLock
lock
(
mQuotaMutex
)
;
LockedRemoveQuotaForOrigin
(
aPersistenceType
aOriginMetadata
)
;
}
nsresult
LoadQuota
(
)
;
void
UnloadQuota
(
)
;
already_AddRefed
<
QuotaObject
>
GetQuotaObject
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
Client
:
:
Type
aClientType
nsIFile
*
aFile
int64_t
aFileSize
=
-
1
int64_t
*
aFileSizeOut
=
nullptr
)
;
already_AddRefed
<
QuotaObject
>
GetQuotaObject
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
Client
:
:
Type
aClientType
const
nsAString
&
aPath
int64_t
aFileSize
=
-
1
int64_t
*
aFileSizeOut
=
nullptr
)
;
already_AddRefed
<
QuotaObject
>
GetQuotaObject
(
const
int64_t
aDirectoryLockId
const
nsAString
&
aPath
)
;
Nullable
<
bool
>
OriginPersisted
(
const
OriginMetadata
&
aOriginMetadata
)
;
void
PersistOrigin
(
const
OriginMetadata
&
aOriginMetadata
)
;
using
DirectoryLockIdTableArray
=
AutoTArray
<
Client
:
:
DirectoryLockIdTable
Client
:
:
TYPE_MAX
>
;
void
AbortOperationsForLocks
(
const
DirectoryLockIdTableArray
&
aLockIds
)
;
void
AbortOperationsForProcess
(
ContentParentId
aContentParentId
)
;
Result
<
nsCOMPtr
<
nsIFile
>
nsresult
>
GetDirectoryForOrigin
(
PersistenceType
aPersistenceType
const
nsACString
&
aASCIIOrigin
)
const
;
nsresult
RestoreDirectoryMetadata2
(
nsIFile
*
aDirectory
)
;
Result
<
FullOriginMetadata
nsresult
>
LoadFullOriginMetadata
(
nsIFile
*
aDirectory
PersistenceType
aPersistenceType
)
;
Result
<
FullOriginMetadata
nsresult
>
LoadFullOriginMetadataWithRestore
(
nsIFile
*
aDirectory
)
;
RefPtr
<
ClientDirectoryLock
>
CreateDirectoryLock
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
Client
:
:
Type
aClientType
bool
aExclusive
)
;
RefPtr
<
UniversalDirectoryLock
>
CreateDirectoryLockInternal
(
const
Nullable
<
PersistenceType
>
&
aPersistenceType
const
OriginScope
&
aOriginScope
const
Nullable
<
Client
:
:
Type
>
&
aClientType
bool
aExclusive
)
;
uint64_t
CollectOriginsForEviction
(
uint64_t
aMinSizeToBeFreed
nsTArray
<
RefPtr
<
OriginDirectoryLock
>
>
&
aLocks
)
;
template
<
typename
P
>
void
CollectPendingOriginsForListing
(
P
aPredicate
)
;
bool
IsStorageInitialized
(
)
const
{
AssertIsOnIOThread
(
)
;
return
static_cast
<
bool
>
(
mStorageConnection
)
;
}
void
AssertStorageIsInitialized
(
)
const
#
ifdef
DEBUG
;
#
else
{
}
#
endif
nsresult
EnsureStorageIsInitialized
(
)
;
Result
<
std
:
:
pair
<
nsCOMPtr
<
nsIFile
>
bool
>
nsresult
>
EnsurePersistentOriginIsInitialized
(
const
OriginMetadata
&
aOriginMetadata
)
;
Result
<
std
:
:
pair
<
nsCOMPtr
<
nsIFile
>
bool
>
nsresult
>
EnsureTemporaryOriginIsInitialized
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
)
;
nsresult
EnsureTemporaryStorageIsInitialized
(
)
;
void
ShutdownStorage
(
)
;
Result
<
bool
nsresult
>
EnsureOriginDirectory
(
nsIFile
&
aDirectory
)
;
nsresult
AboutToClearOrigins
(
const
Nullable
<
PersistenceType
>
&
aPersistenceType
const
OriginScope
&
aOriginScope
const
Nullable
<
Client
:
:
Type
>
&
aClientType
)
;
void
OriginClearCompleted
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
const
Nullable
<
Client
:
:
Type
>
&
aClientType
)
;
void
StartIdleMaintenance
(
)
{
AssertIsOnOwningThread
(
)
;
for
(
const
auto
&
client
:
*
mClients
)
{
client
-
>
StartIdleMaintenance
(
)
;
}
}
void
StopIdleMaintenance
(
)
{
AssertIsOnOwningThread
(
)
;
for
(
const
auto
&
client
:
*
mClients
)
{
client
-
>
StopIdleMaintenance
(
)
;
}
}
void
AssertCurrentThreadOwnsQuotaMutex
(
)
{
mQuotaMutex
.
AssertCurrentThreadOwns
(
)
;
}
nsIThread
*
IOThread
(
)
{
return
mIOThread
-
>
get
(
)
;
}
Client
*
GetClient
(
Client
:
:
Type
aClientType
)
;
const
AutoTArray
<
Client
:
:
Type
Client
:
:
TYPE_MAX
>
&
AllClientTypes
(
)
;
const
nsString
&
GetBasePath
(
)
const
{
return
mBasePath
;
}
const
nsString
&
GetStorageName
(
)
const
{
return
mStorageName
;
}
const
nsString
&
GetStoragePath
(
)
const
{
return
*
mStoragePath
;
}
const
nsString
&
GetStoragePath
(
PersistenceType
aPersistenceType
)
const
{
if
(
aPersistenceType
=
=
PERSISTENCE_TYPE_PERSISTENT
)
{
return
*
mPermanentStoragePath
;
}
if
(
aPersistenceType
=
=
PERSISTENCE_TYPE_TEMPORARY
)
{
return
*
mTemporaryStoragePath
;
}
MOZ_ASSERT
(
aPersistenceType
=
=
PERSISTENCE_TYPE_DEFAULT
)
;
return
*
mDefaultStoragePath
;
}
uint64_t
GetGroupLimit
(
)
const
;
uint64_t
GetGroupUsage
(
const
nsACString
&
aGroup
)
;
uint64_t
GetOriginUsage
(
const
PrincipalMetadata
&
aPrincipalMetadata
)
;
void
NotifyStoragePressure
(
uint64_t
aUsage
)
;
void
MaybeRecordShutdownStep
(
Client
:
:
Type
aClientType
const
nsACString
&
aStepDescription
)
;
void
MaybeRecordQuotaManagerShutdownStep
(
const
nsACString
&
aStepDescription
)
;
static
void
GetStorageId
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
Client
:
:
Type
aClientType
nsACString
&
aDatabaseId
)
;
static
bool
IsPrincipalInfoValid
(
const
PrincipalInfo
&
aPrincipalInfo
)
;
static
PrincipalMetadata
GetInfoFromValidatedPrincipalInfo
(
const
PrincipalInfo
&
aPrincipalInfo
)
;
static
nsAutoCString
GetOriginFromValidatedPrincipalInfo
(
const
PrincipalInfo
&
aPrincipalInfo
)
;
static
Result
<
PrincipalMetadata
nsresult
>
GetInfoFromPrincipal
(
nsIPrincipal
*
aPrincipal
)
;
static
Result
<
nsAutoCString
nsresult
>
GetOriginFromPrincipal
(
nsIPrincipal
*
aPrincipal
)
;
static
Result
<
nsAutoCString
nsresult
>
GetOriginFromWindow
(
nsPIDOMWindowOuter
*
aWindow
)
;
static
nsLiteralCString
GetOriginForChrome
(
)
;
static
PrincipalMetadata
GetInfoForChrome
(
)
;
static
bool
IsOriginInternal
(
const
nsACString
&
aOrigin
)
;
static
bool
AreOriginsEqualOnDisk
(
const
nsACString
&
aOrigin1
const
nsACString
&
aOrigin2
)
;
static
Result
<
PrincipalInfo
nsresult
>
ParseOrigin
(
const
nsACString
&
aOrigin
)
;
static
void
InvalidateQuotaCache
(
)
;
private
:
virtual
~
QuotaManager
(
)
;
nsresult
Init
(
)
;
void
Shutdown
(
)
;
void
RegisterDirectoryLock
(
DirectoryLockImpl
&
aLock
)
;
void
UnregisterDirectoryLock
(
DirectoryLockImpl
&
aLock
)
;
void
AddPendingDirectoryLock
(
DirectoryLockImpl
&
aLock
)
;
void
RemovePendingDirectoryLock
(
DirectoryLockImpl
&
aLock
)
;
uint64_t
LockedCollectOriginsForEviction
(
uint64_t
aMinSizeToBeFreed
nsTArray
<
RefPtr
<
OriginDirectoryLock
>
>
&
aLocks
)
;
void
LockedRemoveQuotaForOrigin
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
)
;
already_AddRefed
<
GroupInfo
>
LockedGetOrCreateGroupInfo
(
PersistenceType
aPersistenceType
const
nsACString
&
aSuffix
const
nsACString
&
aGroup
)
;
already_AddRefed
<
OriginInfo
>
LockedGetOriginInfo
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
)
;
nsresult
UpgradeFromIndexedDBDirectoryToPersistentStorageDirectory
(
nsIFile
*
aIndexedDBDir
)
;
nsresult
UpgradeFromPersistentStorageDirectoryToDefaultStorageDirectory
(
nsIFile
*
aPersistentStorageDir
)
;
nsresult
MaybeUpgradeToDefaultStorageDirectory
(
nsIFile
&
aStorageFile
)
;
template
<
typename
Helper
>
nsresult
UpgradeStorage
(
const
int32_t
aOldVersion
const
int32_t
aNewVersion
mozIStorageConnection
*
aConnection
)
;
nsresult
UpgradeStorageFrom0_0To1_0
(
mozIStorageConnection
*
aConnection
)
;
nsresult
UpgradeStorageFrom1_0To2_0
(
mozIStorageConnection
*
aConnection
)
;
nsresult
UpgradeStorageFrom2_0To2_1
(
mozIStorageConnection
*
aConnection
)
;
nsresult
UpgradeStorageFrom2_1To2_2
(
mozIStorageConnection
*
aConnection
)
;
nsresult
UpgradeStorageFrom2_2To2_3
(
mozIStorageConnection
*
aConnection
)
;
nsresult
MaybeCreateOrUpgradeStorage
(
mozIStorageConnection
&
aConnection
)
;
Result
<
Ok
QMResult
>
MaybeRemoveLocalStorageArchiveTmpFile
(
)
;
nsresult
MaybeRemoveLocalStorageDataAndArchive
(
nsIFile
&
aLsArchiveFile
)
;
nsresult
MaybeRemoveLocalStorageDirectories
(
)
;
Result
<
Ok
nsresult
>
CopyLocalStorageArchiveFromWebAppsStore
(
nsIFile
&
aLsArchiveFile
)
const
;
Result
<
nsCOMPtr
<
mozIStorageConnection
>
nsresult
>
CreateLocalStorageArchiveConnection
(
nsIFile
&
aLsArchiveFile
)
const
;
Result
<
nsCOMPtr
<
mozIStorageConnection
>
nsresult
>
RecopyLocalStorageArchiveFromWebAppsStore
(
nsIFile
&
aLsArchiveFile
)
;
Result
<
nsCOMPtr
<
mozIStorageConnection
>
nsresult
>
DowngradeLocalStorageArchive
(
nsIFile
&
aLsArchiveFile
)
;
Result
<
nsCOMPtr
<
mozIStorageConnection
>
nsresult
>
UpgradeLocalStorageArchiveFromLessThan4To4
(
nsIFile
&
aLsArchiveFile
)
;
Result
<
Ok
nsresult
>
MaybeCreateOrUpgradeLocalStorageArchive
(
nsIFile
&
aLsArchiveFile
)
;
Result
<
Ok
nsresult
>
CreateEmptyLocalStorageArchive
(
nsIFile
&
aLsArchiveFile
)
const
;
nsresult
InitializeRepository
(
PersistenceType
aPersistenceType
)
;
nsresult
InitializeOrigin
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
int64_t
aAccessTime
bool
aPersisted
nsIFile
*
aDirectory
)
;
using
OriginInfosFlatTraversable
=
nsTArray
<
NotNull
<
RefPtr
<
const
OriginInfo
>
>
>
;
using
OriginInfosNestedTraversable
=
nsTArray
<
nsTArray
<
NotNull
<
RefPtr
<
const
OriginInfo
>
>
>
>
;
OriginInfosNestedTraversable
GetOriginInfosExceedingGroupLimit
(
)
const
;
OriginInfosNestedTraversable
GetOriginInfosExceedingGlobalLimit
(
)
const
;
void
ClearOrigins
(
const
OriginInfosNestedTraversable
&
aDoomedOriginInfos
)
;
void
CleanupTemporaryStorage
(
)
;
void
DeleteFilesForOrigin
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
)
;
void
FinalizeOriginEviction
(
nsTArray
<
RefPtr
<
OriginDirectoryLock
>
>
&
&
aLocks
)
;
void
ReleaseIOThreadObjects
(
)
{
AssertIsOnIOThread
(
)
;
for
(
Client
:
:
Type
type
:
AllClientTypes
(
)
)
{
(
*
mClients
)
[
type
]
-
>
ReleaseIOThreadObjects
(
)
;
}
}
DirectoryLockTable
&
GetDirectoryLockTable
(
PersistenceType
aPersistenceType
)
;
bool
IsSanitizedOriginValid
(
const
nsACString
&
aSanitizedOrigin
)
;
int64_t
GenerateDirectoryLockId
(
)
;
void
MaybeRecordShutdownStep
(
Maybe
<
Client
:
:
Type
>
aClientType
const
nsACString
&
aStepDescription
)
;
template
<
typename
Iterator
>
static
void
MaybeInsertNonPersistedOriginInfos
(
Iterator
aDest
const
RefPtr
<
GroupInfo
>
&
aTemporaryGroupInfo
const
RefPtr
<
GroupInfo
>
&
aDefaultGroupInfo
)
;
template
<
typename
Collect
typename
Pred
>
static
OriginInfosFlatTraversable
CollectLRUOriginInfosUntil
(
Collect
&
&
aCollect
Pred
&
&
aPred
)
;
LazyInitializedOnceNotNull
<
const
nsCOMPtr
<
nsIThread
>
>
mIOThread
;
nsCOMPtr
<
mozIStorageConnection
>
mStorageConnection
;
LazyInitializedOnceNotNull
<
const
nsCOMPtr
<
nsITimer
>
>
mShutdownTimer
;
EnumeratedArray
<
Client
:
:
Type
Client
:
:
TYPE_MAX
nsCString
>
mShutdownSteps
;
LazyInitializedOnce
<
const
TimeStamp
>
mShutdownStartedAt
;
Atomic
<
bool
>
mShutdownStarted
;
nsCString
mQuotaManagerShutdownSteps
;
mutable
mozilla
:
:
Mutex
mQuotaMutex
;
nsClassHashtable
<
nsCStringHashKey
GroupInfoPair
>
mGroupInfoPairs
;
nsTArray
<
RefPtr
<
DirectoryLockImpl
>
>
mPendingDirectoryLocks
;
nsTArray
<
NotNull
<
DirectoryLockImpl
*
>
>
mDirectoryLocks
;
nsTHashMap
<
nsUint64HashKey
NotNull
<
DirectoryLockImpl
*
>
>
mDirectoryLockIdTable
;
DirectoryLockTable
mTemporaryDirectoryLockTable
;
DirectoryLockTable
mDefaultDirectoryLockTable
;
nsTArray
<
nsCString
>
mInitializedOrigins
;
nsTHashMap
<
nsCStringHashKey
bool
>
mValidOrigins
;
struct
OriginInitializationInfo
{
bool
mPersistentOriginAttempted
:
1
;
bool
mTemporaryOriginAttempted
:
1
;
}
;
nsTHashMap
<
nsCStringHashKey
OriginInitializationInfo
>
mOriginInitializationInfos
;
LazyInitializedOnce
<
const
AutoTArray
<
RefPtr
<
Client
>
Client
:
:
TYPE_MAX
>
>
mClients
;
using
ClientTypesArray
=
AutoTArray
<
Client
:
:
Type
Client
:
:
TYPE_MAX
>
;
LazyInitializedOnce
<
const
ClientTypesArray
>
mAllClientTypes
;
LazyInitializedOnce
<
const
ClientTypesArray
>
mAllClientTypesExceptLS
;
InitializationInfo
mInitializationInfo
;
const
nsString
mBasePath
;
const
nsString
mStorageName
;
LazyInitializedOnce
<
const
nsString
>
mIndexedDBPath
;
LazyInitializedOnce
<
const
nsString
>
mStoragePath
;
LazyInitializedOnce
<
const
nsString
>
mPermanentStoragePath
;
LazyInitializedOnce
<
const
nsString
>
mTemporaryStoragePath
;
LazyInitializedOnce
<
const
nsString
>
mDefaultStoragePath
;
uint64_t
mTemporaryStorageLimit
;
uint64_t
mTemporaryStorageUsage
;
int64_t
mNextDirectoryLockId
;
bool
mTemporaryStorageInitialized
;
bool
mCacheUsable
;
}
;
}
#
endif
