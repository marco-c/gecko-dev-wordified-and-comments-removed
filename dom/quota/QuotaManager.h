#
ifndef
mozilla_dom_quota_quotamanager_h__
#
define
mozilla_dom_quota_quotamanager_h__
#
include
<
cstdint
>
#
include
<
utility
>
#
include
"
Client
.
h
"
#
include
"
ErrorList
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
InitializationTypes
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
PersistenceType
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaCommon
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaInfo
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTStringRepr
.
h
"
#
include
"
nscore
.
h
"
#
include
"
prenv
.
h
"
#
define
QUOTA_MANAGER_CONTRACTID
"
mozilla
.
org
/
dom
/
quota
/
manager
;
1
"
class
mozIStorageConnection
;
class
nsIEventTarget
;
class
nsIFile
;
class
nsIPrincipal
;
class
nsIRunnable
;
class
nsIThread
;
class
nsITimer
;
class
nsPIDOMWindowOuter
;
namespace
mozilla
{
class
OriginAttributes
;
namespace
ipc
{
class
PrincipalInfo
;
}
}
BEGIN_QUOTA_NAMESPACE
class
ClientUsageArray
;
class
DirectoryLockImpl
;
class
GroupInfo
;
class
GroupInfoPair
;
class
OriginInfo
;
class
OriginScope
;
class
QuotaObject
;
class
NS_NO_VTABLE
RefCountedObject
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
}
;
class
DirectoryLock
:
public
RefCountedObject
{
friend
class
DirectoryLockImpl
;
public
:
int64_t
Id
(
)
const
;
PersistenceType
GetPersistenceType
(
)
const
;
quota
:
:
GroupAndOrigin
GroupAndOrigin
(
)
const
;
const
nsACString
&
Origin
(
)
const
;
Client
:
:
Type
ClientType
(
)
const
;
already_AddRefed
<
DirectoryLock
>
Specialize
(
PersistenceType
aPersistenceType
const
quota
:
:
GroupAndOrigin
&
aGroupAndOrigin
Client
:
:
Type
aClientType
)
const
;
void
Log
(
)
const
;
private
:
DirectoryLock
(
)
=
default
;
~
DirectoryLock
(
)
=
default
;
}
;
class
NS_NO_VTABLE
OpenDirectoryListener
:
public
RefCountedObject
{
public
:
virtual
void
DirectoryLockAcquired
(
DirectoryLock
*
aLock
)
=
0
;
virtual
void
DirectoryLockFailed
(
)
=
0
;
protected
:
virtual
~
OpenDirectoryListener
(
)
=
default
;
}
;
struct
OriginParams
{
OriginParams
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
)
:
mOrigin
(
aOrigin
)
mPersistenceType
(
aPersistenceType
)
{
}
nsCString
mOrigin
;
PersistenceType
mPersistenceType
;
}
;
class
QuotaManager
final
:
public
BackgroundThreadObject
{
friend
class
DirectoryLockImpl
;
friend
class
GroupInfo
;
friend
class
OriginInfo
;
friend
class
QuotaObject
;
typedef
mozilla
:
:
ipc
:
:
PrincipalInfo
PrincipalInfo
;
typedef
nsClassHashtable
<
nsCStringHashKey
nsTArray
<
DirectoryLockImpl
*
>
>
DirectoryLockTable
;
class
Observer
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
QuotaManager
)
static
nsresult
Initialize
(
)
;
static
bool
IsRunningXPCShellTests
(
)
{
static
bool
kRunningXPCShellTests
=
!
!
PR_GetEnv
(
"
XPCSHELL_TEST_PROFILE_DIR
"
)
;
return
kRunningXPCShellTests
;
}
static
bool
IsRunningGTests
(
)
{
static
bool
kRunningGTests
=
!
!
PR_GetEnv
(
"
MOZ_RUN_GTEST
"
)
;
return
kRunningGTests
;
}
static
const
char
kReplaceChars
[
]
;
static
void
GetOrCreate
(
nsIRunnable
*
aCallback
nsIEventTarget
*
aMainEventTarget
=
nullptr
)
;
static
QuotaManager
*
Get
(
)
;
static
bool
IsShuttingDown
(
)
;
static
void
ShutdownInstance
(
)
;
static
bool
IsOSMetadata
(
const
nsAString
&
aFileName
)
;
static
bool
IsDotFile
(
const
nsAString
&
aFileName
)
;
bool
IsOriginInitialized
(
const
nsACString
&
aOrigin
)
const
{
AssertIsOnIOThread
(
)
;
return
mInitializedOrigins
.
Contains
(
aOrigin
)
;
}
bool
IsTemporaryStorageInitialized
(
)
const
{
AssertIsOnIOThread
(
)
;
return
mTemporaryStorageInitialized
;
}
void
InitQuotaForOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
ClientUsageArray
&
aClientUsages
uint64_t
aUsageBytes
int64_t
aAccessTime
bool
aPersisted
)
;
void
EnsureQuotaForOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
)
;
void
NoteOriginDirectoryCreated
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
bool
aPersisted
int64_t
&
aTimestamp
)
;
void
DecreaseUsageForOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
Client
:
:
Type
aClientType
int64_t
aSize
)
;
void
ResetUsageForClient
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
Client
:
:
Type
aClientType
)
;
UsageInfo
GetUsageForClient
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
Client
:
:
Type
aClientType
)
;
void
UpdateOriginAccessTime
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
)
;
void
RemoveQuota
(
)
;
void
RemoveQuotaForOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
)
{
MutexAutoLock
lock
(
mQuotaMutex
)
;
LockedRemoveQuotaForOrigin
(
aPersistenceType
aGroupAndOrigin
)
;
}
nsresult
LoadQuota
(
)
;
void
UnloadQuota
(
)
;
already_AddRefed
<
QuotaObject
>
GetQuotaObject
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
Client
:
:
Type
aClientType
nsIFile
*
aFile
int64_t
aFileSize
=
-
1
int64_t
*
aFileSizeOut
=
nullptr
)
;
already_AddRefed
<
QuotaObject
>
GetQuotaObject
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
Client
:
:
Type
aClientType
const
nsAString
&
aPath
int64_t
aFileSize
=
-
1
int64_t
*
aFileSizeOut
=
nullptr
)
;
already_AddRefed
<
QuotaObject
>
GetQuotaObject
(
const
int64_t
aDirectoryLockId
const
nsAString
&
aPath
)
;
Nullable
<
bool
>
OriginPersisted
(
const
GroupAndOrigin
&
aGroupAndOrigin
)
;
void
PersistOrigin
(
const
GroupAndOrigin
&
aGroupAndOrigin
)
;
void
AbortOperationsForProcess
(
ContentParentId
aContentParentId
)
;
Result
<
nsCOMPtr
<
nsIFile
>
nsresult
>
GetDirectoryForOrigin
(
PersistenceType
aPersistenceType
const
nsACString
&
aASCIIOrigin
)
const
;
nsresult
RestoreDirectoryMetadata2
(
nsIFile
*
aDirectory
bool
aPersistent
)
;
nsresult
GetDirectoryMetadata2
(
nsIFile
*
aDirectory
int64_t
*
aTimestamp
bool
*
aPersisted
QuotaInfo
&
aQuotaInfo
)
;
nsresult
GetDirectoryMetadata2WithRestore
(
nsIFile
*
aDirectory
bool
aPersistent
int64_t
*
aTimestamp
bool
*
aPersisted
QuotaInfo
&
aQuotaInfo
const
bool
aTelemetry
=
false
)
;
nsresult
GetDirectoryMetadata2
(
nsIFile
*
aDirectory
int64_t
*
aTimestamp
bool
*
aPersisted
)
;
nsresult
GetDirectoryMetadata2WithRestore
(
nsIFile
*
aDirectory
bool
aPersistent
int64_t
*
aTimestamp
bool
*
aPersisted
)
;
already_AddRefed
<
DirectoryLock
>
OpenDirectory
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
Client
:
:
Type
aClientType
bool
aExclusive
RefPtr
<
OpenDirectoryListener
>
aOpenListener
)
;
already_AddRefed
<
DirectoryLock
>
OpenDirectoryInternal
(
const
Nullable
<
PersistenceType
>
&
aPersistenceType
const
OriginScope
&
aOriginScope
const
Nullable
<
Client
:
:
Type
>
&
aClientType
bool
aExclusive
OpenDirectoryListener
*
aOpenListener
)
;
uint64_t
CollectOriginsForEviction
(
uint64_t
aMinSizeToBeFreed
nsTArray
<
RefPtr
<
DirectoryLockImpl
>
>
&
aLocks
)
;
template
<
typename
P
>
void
CollectPendingOriginsForListing
(
P
aPredicate
)
;
bool
IsStorageInitialized
(
)
const
{
AssertIsOnIOThread
(
)
;
return
static_cast
<
bool
>
(
mStorageConnection
)
;
}
void
AssertStorageIsInitialized
(
)
const
#
ifdef
DEBUG
;
#
else
{
}
#
endif
nsresult
EnsureStorageIsInitialized
(
)
;
Result
<
std
:
:
pair
<
nsCOMPtr
<
nsIFile
>
bool
>
nsresult
>
EnsurePersistentOriginIsInitialized
(
const
QuotaInfo
&
aQuotaInfo
)
;
Result
<
std
:
:
pair
<
nsCOMPtr
<
nsIFile
>
bool
>
nsresult
>
EnsureTemporaryOriginIsInitialized
(
PersistenceType
aPersistenceType
const
QuotaInfo
&
aQuotaInfo
)
;
nsresult
EnsureTemporaryStorageIsInitialized
(
)
;
void
ShutdownStorage
(
)
;
Result
<
bool
nsresult
>
EnsureOriginDirectory
(
nsIFile
&
aDirectory
)
;
nsresult
AboutToClearOrigins
(
const
Nullable
<
PersistenceType
>
&
aPersistenceType
const
OriginScope
&
aOriginScope
const
Nullable
<
Client
:
:
Type
>
&
aClientType
)
;
void
OriginClearCompleted
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
const
Nullable
<
Client
:
:
Type
>
&
aClientType
)
;
void
StartIdleMaintenance
(
)
{
AssertIsOnOwningThread
(
)
;
for
(
auto
&
client
:
mClients
)
{
client
-
>
StartIdleMaintenance
(
)
;
}
}
void
StopIdleMaintenance
(
)
{
AssertIsOnOwningThread
(
)
;
for
(
auto
&
client
:
mClients
)
{
client
-
>
StopIdleMaintenance
(
)
;
}
}
void
AssertCurrentThreadOwnsQuotaMutex
(
)
{
mQuotaMutex
.
AssertCurrentThreadOwns
(
)
;
}
nsIThread
*
IOThread
(
)
{
NS_ASSERTION
(
mIOThread
"
This
should
never
be
null
!
"
)
;
return
mIOThread
;
}
Client
*
GetClient
(
Client
:
:
Type
aClientType
)
;
const
AutoTArray
<
Client
:
:
Type
Client
:
:
TYPE_MAX
>
&
AllClientTypes
(
)
;
const
nsString
&
GetBasePath
(
)
const
{
return
mBasePath
;
}
const
nsString
&
GetStorageName
(
)
const
{
return
mStorageName
;
}
const
nsString
&
GetStoragePath
(
)
const
{
return
mStoragePath
;
}
const
nsString
&
GetStoragePath
(
PersistenceType
aPersistenceType
)
const
{
if
(
aPersistenceType
=
=
PERSISTENCE_TYPE_PERSISTENT
)
{
return
mPermanentStoragePath
;
}
if
(
aPersistenceType
=
=
PERSISTENCE_TYPE_TEMPORARY
)
{
return
mTemporaryStoragePath
;
}
MOZ_ASSERT
(
aPersistenceType
=
=
PERSISTENCE_TYPE_DEFAULT
)
;
return
mDefaultStoragePath
;
}
uint64_t
GetGroupLimit
(
)
const
;
uint64_t
GetGroupUsage
(
const
nsACString
&
aGroup
)
;
uint64_t
GetOriginUsage
(
const
GroupAndOrigin
&
aGroupAndOrigin
)
;
void
NotifyStoragePressure
(
uint64_t
aUsage
)
;
static
void
GetStorageId
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
Client
:
:
Type
aClientType
nsACString
&
aDatabaseId
)
;
static
bool
IsPrincipalInfoValid
(
const
PrincipalInfo
&
aPrincipalInfo
)
;
static
QuotaInfo
GetInfoFromValidatedPrincipalInfo
(
const
PrincipalInfo
&
aPrincipalInfo
)
;
static
nsAutoCString
GetOriginFromValidatedPrincipalInfo
(
const
PrincipalInfo
&
aPrincipalInfo
)
;
static
Result
<
QuotaInfo
nsresult
>
GetInfoFromPrincipal
(
nsIPrincipal
*
aPrincipal
)
;
static
Result
<
nsAutoCString
nsresult
>
GetOriginFromPrincipal
(
nsIPrincipal
*
aPrincipal
)
;
static
Result
<
nsAutoCString
nsresult
>
GetOriginFromWindow
(
nsPIDOMWindowOuter
*
aWindow
)
;
static
nsLiteralCString
GetOriginForChrome
(
)
;
static
QuotaInfo
GetInfoForChrome
(
)
;
static
bool
IsOriginInternal
(
const
nsACString
&
aOrigin
)
;
static
bool
AreOriginsEqualOnDisk
(
const
nsACString
&
aOrigin1
const
nsACString
&
aOrigin2
)
;
static
bool
ParseOrigin
(
const
nsACString
&
aOrigin
nsCString
&
aSpec
OriginAttributes
*
aAttrs
)
;
static
void
InvalidateQuotaCache
(
)
;
private
:
QuotaManager
(
const
nsAString
&
aBasePath
const
nsAString
&
aStorageName
)
;
virtual
~
QuotaManager
(
)
;
nsresult
Init
(
)
;
void
Shutdown
(
)
;
already_AddRefed
<
DirectoryLockImpl
>
CreateDirectoryLock
(
const
Nullable
<
PersistenceType
>
&
aPersistenceType
const
nsACString
&
aGroup
const
OriginScope
&
aOriginScope
const
Nullable
<
Client
:
:
Type
>
&
aClientType
bool
aExclusive
bool
aInternal
RefPtr
<
OpenDirectoryListener
>
aOpenListener
bool
&
aBlockedOut
)
;
already_AddRefed
<
DirectoryLockImpl
>
CreateDirectoryLockForEviction
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
)
;
void
RegisterDirectoryLock
(
DirectoryLockImpl
&
aLock
)
;
void
UnregisterDirectoryLock
(
DirectoryLockImpl
&
aLock
)
;
void
RemovePendingDirectoryLock
(
DirectoryLockImpl
&
aLock
)
;
uint64_t
LockedCollectOriginsForEviction
(
uint64_t
aMinSizeToBeFreed
nsTArray
<
RefPtr
<
DirectoryLockImpl
>
>
&
aLocks
)
;
void
LockedRemoveQuotaForOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
)
;
already_AddRefed
<
GroupInfo
>
LockedGetOrCreateGroupInfo
(
PersistenceType
aPersistenceType
const
nsACString
&
aGroup
)
;
already_AddRefed
<
OriginInfo
>
LockedGetOriginInfo
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
)
;
nsresult
UpgradeFromIndexedDBDirectoryToPersistentStorageDirectory
(
nsIFile
*
aIndexedDBDir
)
;
nsresult
UpgradeFromPersistentStorageDirectoryToDefaultStorageDirectory
(
nsIFile
*
aPersistentStorageDir
)
;
template
<
typename
Helper
>
nsresult
UpgradeStorage
(
const
int32_t
aOldVersion
const
int32_t
aNewVersion
mozIStorageConnection
*
aConnection
)
;
nsresult
UpgradeStorageFrom0_0To1_0
(
mozIStorageConnection
*
aConnection
)
;
nsresult
UpgradeStorageFrom1_0To2_0
(
mozIStorageConnection
*
aConnection
)
;
nsresult
UpgradeStorageFrom2_0To2_1
(
mozIStorageConnection
*
aConnection
)
;
nsresult
UpgradeStorageFrom2_1To2_2
(
mozIStorageConnection
*
aConnection
)
;
nsresult
UpgradeStorageFrom2_2To2_3
(
mozIStorageConnection
*
aConnection
)
;
nsresult
MaybeRemoveLocalStorageData
(
)
;
nsresult
MaybeRemoveLocalStorageDirectories
(
)
;
nsresult
CreateLocalStorageArchiveConnectionFromWebAppsStore
(
mozIStorageConnection
*
*
aConnection
)
;
Result
<
std
:
:
pair
<
nsCOMPtr
<
mozIStorageConnection
>
bool
>
nsresult
>
CreateLocalStorageArchiveConnection
(
)
;
nsresult
RecreateLocalStorageArchive
(
nsCOMPtr
<
mozIStorageConnection
>
&
aConnection
)
;
nsresult
DowngradeLocalStorageArchive
(
nsCOMPtr
<
mozIStorageConnection
>
&
aConnection
)
;
nsresult
UpgradeLocalStorageArchiveFromLessThan4To4
(
nsCOMPtr
<
mozIStorageConnection
>
&
aConnection
)
;
nsresult
InitializeRepository
(
PersistenceType
aPersistenceType
)
;
nsresult
InitializeOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
int64_t
aAccessTime
bool
aPersisted
nsIFile
*
aDirectory
)
;
void
CheckTemporaryStorageLimits
(
)
;
void
DeleteFilesForOrigin
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
)
;
void
FinalizeOriginEviction
(
nsTArray
<
RefPtr
<
DirectoryLockImpl
>
>
&
&
aLocks
)
;
void
ReleaseIOThreadObjects
(
)
{
AssertIsOnIOThread
(
)
;
for
(
Client
:
:
Type
type
:
AllClientTypes
(
)
)
{
mClients
[
type
]
-
>
ReleaseIOThreadObjects
(
)
;
}
}
DirectoryLockTable
&
GetDirectoryLockTable
(
PersistenceType
aPersistenceType
)
;
bool
IsSanitizedOriginValid
(
const
nsACString
&
aSanitizedOrigin
)
;
int64_t
GenerateDirectoryLockId
(
)
;
static
void
ShutdownTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
nsCOMPtr
<
nsIThread
>
mIOThread
;
nsCOMPtr
<
mozIStorageConnection
>
mStorageConnection
;
nsCOMPtr
<
nsITimer
>
mShutdownTimer
;
mozilla
:
:
Mutex
mQuotaMutex
;
nsClassHashtable
<
nsCStringHashKey
GroupInfoPair
>
mGroupInfoPairs
;
nsTArray
<
RefPtr
<
DirectoryLockImpl
>
>
mPendingDirectoryLocks
;
nsTArray
<
DirectoryLockImpl
*
>
mDirectoryLocks
;
nsDataHashtable
<
nsUint64HashKey
DirectoryLockImpl
*
>
mDirectoryLockIdTable
;
DirectoryLockTable
mTemporaryDirectoryLockTable
;
DirectoryLockTable
mDefaultDirectoryLockTable
;
nsTArray
<
nsCString
>
mInitializedOrigins
;
nsDataHashtable
<
nsCStringHashKey
bool
>
mValidOrigins
;
struct
OriginInitializationInfo
{
bool
mPersistentOriginAttempted
:
1
;
bool
mTemporaryOriginAttempted
:
1
;
}
;
nsDataHashtable
<
nsCStringHashKey
OriginInitializationInfo
>
mOriginInitializationInfos
;
AutoTArray
<
RefPtr
<
Client
>
Client
:
:
TYPE_MAX
>
mClients
;
AutoTArray
<
Client
:
:
Type
Client
:
:
TYPE_MAX
>
mAllClientTypes
;
AutoTArray
<
Client
:
:
Type
Client
:
:
TYPE_MAX
>
mAllClientTypesExceptLS
;
InitializationInfo
mInitializationInfo
;
nsString
mBasePath
;
nsString
mStorageName
;
nsString
mIndexedDBPath
;
nsString
mStoragePath
;
nsString
mPermanentStoragePath
;
nsString
mTemporaryStoragePath
;
nsString
mDefaultStoragePath
;
uint64_t
mTemporaryStorageLimit
;
uint64_t
mTemporaryStorageUsage
;
int64_t
mNextDirectoryLockId
;
bool
mTemporaryStorageInitialized
;
bool
mCacheUsable
;
}
;
END_QUOTA_NAMESPACE
#
endif
