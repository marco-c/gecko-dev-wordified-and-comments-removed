"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
DEBUG
=
Services
.
prefs
.
getBoolPref
(
"
dom
.
presentation
.
tcp_server
.
debug
"
)
;
function
log
(
aMsg
)
{
dump
(
"
-
*
-
LegacyPresentationControlService
.
js
:
"
+
aMsg
+
"
\
n
"
)
;
}
function
LegacyPresentationControlService
(
)
{
DEBUG
&
&
log
(
"
LegacyPresentationControlService
-
ctor
"
)
;
this
.
_id
=
null
;
}
LegacyPresentationControlService
.
prototype
=
{
startServer
:
function
(
)
{
DEBUG
&
&
log
(
"
LegacyPresentationControlService
-
doesn
'
t
support
receiver
mode
"
)
;
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
get
id
(
)
{
return
this
.
_id
;
}
set
id
(
aId
)
{
this
.
_id
=
aId
;
}
get
port
(
)
{
return
0
;
}
get
version
(
)
{
return
0
;
}
set
listener
(
aListener
)
{
DEBUG
&
&
log
(
"
LegacyPresentationControlService
-
doesn
'
t
support
receiver
mode
"
)
;
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
get
listener
(
)
{
return
null
;
}
connect
:
function
(
aDeviceInfo
)
{
if
(
!
this
.
id
)
{
DEBUG
&
&
log
(
"
LegacyPresentationControlService
-
Id
has
not
initialized
;
requestSession
fails
"
)
;
return
null
;
}
DEBUG
&
&
log
(
"
LegacyPresentationControlService
-
requestSession
to
"
+
aDeviceInfo
.
id
)
;
let
sts
=
Cc
[
"
mozilla
.
org
/
network
/
socket
-
transport
-
service
;
1
"
]
.
getService
(
Ci
.
nsISocketTransportService
)
;
let
socketTransport
;
try
{
socketTransport
=
sts
.
createTransport
(
null
0
aDeviceInfo
.
address
aDeviceInfo
.
port
null
)
;
}
catch
(
e
)
{
DEBUG
&
&
log
(
"
LegacyPresentationControlService
-
createTransport
throws
:
"
+
e
)
;
throw
Cr
.
NS_ERROR_FAILURE
;
}
return
new
LegacyTCPControlChannel
(
this
.
id
socketTransport
aDeviceInfo
)
;
}
close
:
function
(
)
{
DEBUG
&
&
log
(
"
LegacyPresentationControlService
-
close
"
)
;
}
classID
:
Components
.
ID
(
"
{
b21816fe
-
8aff
-
4811
-
86d2
-
85a7444c557e
}
"
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIPresentationControlService
]
)
}
;
function
ChannelDescription
(
aInit
)
{
this
.
_type
=
aInit
.
type
;
switch
(
this
.
_type
)
{
case
Ci
.
nsIPresentationChannelDescription
.
TYPE_TCP
:
this
.
_tcpAddresses
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
for
(
let
address
of
aInit
.
tcpAddress
)
{
let
wrapper
=
Cc
[
"
mozilla
.
org
/
supports
-
cstring
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsCString
)
;
wrapper
.
data
=
address
;
this
.
_tcpAddresses
.
appendElement
(
wrapper
false
)
;
}
this
.
_tcpPort
=
aInit
.
tcpPort
;
break
;
case
Ci
.
nsIPresentationChannelDescription
.
TYPE_DATACHANNEL
:
this
.
_dataChannelSDP
=
aInit
.
dataChannelSDP
;
break
;
}
}
ChannelDescription
.
prototype
=
{
_type
:
0
_tcpAddresses
:
null
_tcpPort
:
0
_dataChannelSDP
:
"
"
get
type
(
)
{
return
this
.
_type
;
}
get
tcpAddress
(
)
{
return
this
.
_tcpAddresses
;
}
get
tcpPort
(
)
{
return
this
.
_tcpPort
;
}
get
dataChannelSDP
(
)
{
return
this
.
_dataChannelSDP
;
}
classID
:
Components
.
ID
(
"
{
d69fc81c
-
4f40
-
47a3
-
97e6
-
b4cf5db2294e
}
"
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIPresentationChannelDescription
]
)
}
;
function
discriptionAsJson
(
aDescription
)
{
let
json
=
{
}
;
json
.
type
=
aDescription
.
type
;
switch
(
aDescription
.
type
)
{
case
Ci
.
nsIPresentationChannelDescription
.
TYPE_TCP
:
let
addresses
=
aDescription
.
tcpAddress
.
QueryInterface
(
Ci
.
nsIArray
)
;
json
.
tcpAddress
=
[
]
;
for
(
let
idx
=
0
;
idx
<
addresses
.
length
;
idx
+
+
)
{
let
address
=
addresses
.
queryElementAt
(
idx
Ci
.
nsISupportsCString
)
;
json
.
tcpAddress
.
push
(
address
.
data
)
;
}
json
.
tcpPort
=
aDescription
.
tcpPort
;
break
;
case
Ci
.
nsIPresentationChannelDescription
.
TYPE_DATACHANNEL
:
json
.
dataChannelSDP
=
aDescription
.
dataChannelSDP
;
break
;
}
return
json
;
}
function
LegacyTCPControlChannel
(
id
transport
deviceInfo
)
{
DEBUG
&
&
log
(
"
create
LegacyTCPControlChannel
"
)
;
this
.
_deviceInfo
=
deviceInfo
;
this
.
_transport
=
transport
;
this
.
_id
=
id
;
let
currentThread
=
Services
.
tm
.
currentThread
;
transport
.
setEventSink
(
this
currentThread
)
;
this
.
_input
=
this
.
_transport
.
openInputStream
(
0
0
0
)
.
QueryInterface
(
Ci
.
nsIAsyncInputStream
)
;
this
.
_input
.
asyncWait
(
this
.
QueryInterface
(
Ci
.
nsIStreamListener
)
Ci
.
nsIAsyncInputStream
.
WAIT_CLOSURE_ONLY
0
currentThread
)
;
this
.
_output
=
this
.
_transport
.
openOutputStream
(
Ci
.
nsITransport
.
OPEN_UNBUFFERED
0
0
)
;
}
LegacyTCPControlChannel
.
prototype
=
{
_connected
:
false
_pendingOpen
:
false
_pendingAnswer
:
null
_pendingClose
:
null
_pendingCloseReason
:
null
_sendMessage
:
function
(
aJSONData
aOnThrow
)
{
if
(
!
aOnThrow
)
{
aOnThrow
=
function
(
e
)
{
throw
e
.
result
;
}
;
}
if
(
!
aJSONData
)
{
aOnThrow
(
)
;
return
;
}
if
(
!
this
.
_connected
)
{
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
send
"
+
aJSONData
.
type
+
"
fails
"
)
;
throw
Cr
.
NS_ERROR_FAILURE
;
}
try
{
this
.
_send
(
aJSONData
)
;
}
catch
(
e
)
{
aOnThrow
(
e
)
;
}
}
_sendInit
:
function
(
)
{
let
msg
=
{
type
:
"
requestSession
:
Init
"
presentationId
:
this
.
_presentationId
url
:
this
.
_url
id
:
this
.
_id
}
;
this
.
_sendMessage
(
msg
function
(
e
)
{
this
.
disconnect
(
)
;
this
.
_notifyClosed
(
e
.
result
)
;
}
)
;
}
launch
:
function
(
aPresentationId
aUrl
)
{
this
.
_presentationId
=
aPresentationId
;
this
.
_url
=
aUrl
;
this
.
_sendInit
(
)
;
}
sendOffer
:
function
(
aOffer
)
{
let
msg
=
{
type
:
"
requestSession
:
Offer
"
presentationId
:
this
.
_presentationId
offer
:
discriptionAsJson
(
aOffer
)
}
;
this
.
_sendMessage
(
msg
)
;
}
sendAnswer
:
function
(
aAnswer
)
{
throw
Cr
.
NS_ERROR_NOT_IMPLEMENTED
;
}
sendIceCandidate
:
function
(
aCandidate
)
{
let
msg
=
{
type
:
"
requestSession
:
IceCandidate
"
presentationId
:
this
.
_presentationId
iceCandidate
:
aCandidate
}
;
this
.
_sendMessage
(
msg
)
;
}
_send
:
function
(
aMsg
)
{
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
Send
:
"
+
JSON
.
stringify
(
aMsg
null
2
)
)
;
let
message
=
JSON
.
stringify
(
aMsg
)
.
replace
(
[
"
\
n
"
]
"
"
)
+
"
\
n
"
;
try
{
this
.
_output
.
write
(
message
message
.
length
)
;
}
catch
(
e
)
{
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
Failed
to
send
message
:
"
+
e
.
name
)
;
throw
e
;
}
}
onInputStreamReady
:
function
(
aStream
)
{
try
{
aStream
.
available
(
)
;
}
catch
(
e
)
{
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
onInputStreamReady
error
:
"
+
e
.
name
)
;
this
.
_listener
.
notifyClosed
(
e
.
result
)
;
}
}
onTransportStatus
:
function
(
aTransport
aStatus
aProg
aProgMax
)
{
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
onTransportStatus
:
"
+
aStatus
.
toString
(
16
)
)
;
if
(
aStatus
=
=
=
Ci
.
nsISocketTransport
.
STATUS_CONNECTED_TO
)
{
this
.
_connected
=
true
;
if
(
!
this
.
_pump
)
{
this
.
_createInputStreamPump
(
)
;
}
this
.
_notifyOpened
(
)
;
}
}
onStartRequest
:
function
(
)
{
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
onStartRequest
"
)
;
}
onStopRequest
:
function
(
aRequest
aContext
aStatus
)
{
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
onStopRequest
:
"
+
aStatus
)
;
this
.
disconnect
(
aStatus
)
;
this
.
_notifyClosed
(
aStatus
)
;
}
onDataAvailable
:
function
(
aRequest
aContext
aInputStream
aOffset
aCount
)
{
let
data
=
NetUtil
.
readInputStreamToString
(
aInputStream
aInputStream
.
available
(
)
)
;
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
onDataAvailable
:
"
+
data
)
;
let
jsonArray
=
data
.
split
(
"
\
n
"
)
;
jsonArray
.
pop
(
)
;
for
(
let
json
of
jsonArray
)
{
let
msg
;
try
{
msg
=
JSON
.
parse
(
json
)
;
}
catch
(
e
)
{
DEBUG
&
&
log
(
"
LegacyTCPSignalingChannel
-
error
in
parsing
json
:
"
+
e
)
;
}
this
.
_handleMessage
(
msg
)
;
}
}
_createInputStreamPump
:
function
(
)
{
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
create
pump
"
)
;
this
.
_pump
=
Cc
[
"
mozilla
.
org
/
network
/
input
-
stream
-
pump
;
1
"
]
.
createInstance
(
Ci
.
nsIInputStreamPump
)
;
this
.
_pump
.
init
(
this
.
_input
-
1
-
1
0
0
false
)
;
this
.
_pump
.
asyncRead
(
this
null
)
;
}
_handleMessage
:
function
(
aMsg
)
{
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
handleMessage
from
"
+
JSON
.
stringify
(
this
.
_deviceInfo
)
+
"
:
"
+
JSON
.
stringify
(
aMsg
)
)
;
switch
(
aMsg
.
type
)
{
case
"
requestSession
:
Answer
"
:
{
this
.
_onAnswer
(
aMsg
.
answer
)
;
break
;
}
case
"
requestSession
:
IceCandidate
"
:
{
this
.
_listener
.
onIceCandidate
(
aMsg
.
iceCandidate
)
;
break
;
}
case
"
requestSession
:
CloseReason
"
:
{
this
.
_pendingCloseReason
=
aMsg
.
reason
;
break
;
}
}
}
get
listener
(
)
{
return
this
.
_listener
;
}
set
listener
(
aListener
)
{
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
set
listener
:
"
+
aListener
)
;
if
(
!
aListener
)
{
this
.
_listener
=
null
;
return
;
}
this
.
_listener
=
aListener
;
if
(
this
.
_pendingOpen
)
{
this
.
_pendingOpen
=
false
;
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
notify
pending
opened
"
)
;
this
.
_listener
.
notifyOpened
(
)
;
}
if
(
this
.
_pendingAnswer
)
{
let
answer
=
this
.
_pendingAnswer
;
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
notify
pending
answer
:
"
+
JSON
.
stringify
(
answer
)
)
;
this
.
_listener
.
onAnswer
(
new
ChannelDescription
(
answer
)
)
;
this
.
_pendingAnswer
=
null
;
}
if
(
this
.
_pendingClose
)
{
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
notify
pending
closed
"
)
;
this
.
_notifyClosed
(
this
.
_pendingCloseReason
)
;
this
.
_pendingClose
=
null
;
}
}
_onAnswer
:
function
(
aAnswer
)
{
if
(
!
this
.
_connected
)
{
return
;
}
if
(
!
this
.
_listener
)
{
this
.
_pendingAnswer
=
aAnswer
;
return
;
}
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
notify
answer
:
"
+
JSON
.
stringify
(
aAnswer
)
)
;
this
.
_listener
.
onAnswer
(
new
ChannelDescription
(
aAnswer
)
)
;
}
_notifyOpened
:
function
(
)
{
this
.
_connected
=
true
;
this
.
_pendingClose
=
false
;
this
.
_pendingCloseReason
=
Cr
.
NS_OK
;
if
(
!
this
.
_listener
)
{
this
.
_pendingOpen
=
true
;
return
;
}
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
notify
opened
"
)
;
this
.
_listener
.
notifyOpened
(
)
;
}
_notifyClosed
:
function
(
aReason
)
{
this
.
_connected
=
false
;
this
.
_pendingOpen
=
false
;
this
.
_pendingAnswer
=
null
;
if
(
aReason
=
=
Cr
.
NS_OK
&
&
this
.
_pendingCloseReason
!
=
Cr
.
NS_OK
)
{
aReason
=
this
.
_pendingCloseReason
;
}
if
(
!
this
.
_listener
)
{
this
.
_pendingClose
=
true
;
this
.
_pendingCloseReason
=
aReason
;
return
;
}
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
notify
closed
"
)
;
this
.
_listener
.
notifyClosed
(
aReason
)
;
}
disconnect
:
function
(
aReason
)
{
DEBUG
&
&
log
(
"
LegacyTCPControlChannel
-
close
with
reason
:
"
+
aReason
)
;
if
(
this
.
_connected
)
{
if
(
typeof
aReason
!
=
=
"
undefined
"
&
&
aReason
!
=
=
Cr
.
NS_OK
)
{
let
msg
=
{
type
:
"
requestSession
:
CloseReason
"
presentationId
:
this
.
_presentationId
reason
:
aReason
}
;
this
.
_sendMessage
(
msg
)
;
this
.
_pendingCloseReason
=
aReason
;
}
this
.
_transport
.
setEventSink
(
null
null
)
;
this
.
_pump
=
null
;
this
.
_input
.
close
(
)
;
this
.
_output
.
close
(
)
;
this
.
_connected
=
false
;
}
}
classID
:
Components
.
ID
(
"
{
4027ce3d
-
06e3
-
4d06
-
a235
-
df329cb0d411
}
"
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIPresentationControlChannel
Ci
.
nsIStreamListener
]
)
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
LegacyPresentationControlService
]
)
;
