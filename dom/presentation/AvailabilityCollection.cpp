#
include
"
AvailabilityCollection
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
PresentationAvailability
.
h
"
namespace
mozilla
{
namespace
dom
{
StaticAutoPtr
<
AvailabilityCollection
>
AvailabilityCollection
:
:
sSingleton
;
static
bool
gOnceAliveNowDead
=
false
;
AvailabilityCollection
*
AvailabilityCollection
:
:
GetSingleton
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sSingleton
&
&
!
gOnceAliveNowDead
)
{
sSingleton
=
new
AvailabilityCollection
(
)
;
ClearOnShutdown
(
&
sSingleton
)
;
}
return
sSingleton
;
}
AvailabilityCollection
:
:
AvailabilityCollection
(
)
{
MOZ_COUNT_CTOR
(
AvailabilityCollection
)
;
}
AvailabilityCollection
:
:
~
AvailabilityCollection
(
)
{
MOZ_COUNT_DTOR
(
AvailabilityCollection
)
;
gOnceAliveNowDead
=
true
;
}
void
AvailabilityCollection
:
:
Add
(
PresentationAvailability
*
aAvailability
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
aAvailability
)
{
return
;
}
WeakPtr
<
PresentationAvailability
>
availability
=
aAvailability
;
if
(
mAvailabilities
.
Contains
(
aAvailability
)
)
{
return
;
}
mAvailabilities
.
AppendElement
(
aAvailability
)
;
}
void
AvailabilityCollection
:
:
Remove
(
PresentationAvailability
*
aAvailability
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
aAvailability
)
{
return
;
}
WeakPtr
<
PresentationAvailability
>
availability
=
aAvailability
;
mAvailabilities
.
RemoveElement
(
availability
)
;
}
already_AddRefed
<
PresentationAvailability
>
AvailabilityCollection
:
:
Find
(
const
uint64_t
aWindowId
const
nsTArray
<
nsString
>
&
aUrls
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
int
i
=
mAvailabilities
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
WeakPtr
<
PresentationAvailability
>
availability
=
mAvailabilities
[
i
]
;
if
(
!
availability
)
{
mAvailabilities
.
RemoveElementAt
(
i
)
;
continue
;
}
if
(
availability
-
>
Equals
(
aWindowId
aUrls
)
)
{
RefPtr
<
PresentationAvailability
>
matchedAvailability
=
availability
.
get
(
)
;
return
matchedAvailability
.
forget
(
)
;
}
}
return
nullptr
;
}
}
}
