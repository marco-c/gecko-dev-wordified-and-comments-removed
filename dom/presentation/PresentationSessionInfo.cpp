#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
HTMLIFrameElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIFrameLoader
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
PresentationService
.
h
"
#
include
"
PresentationSessionInfo
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
services
;
NS_IMPL_ISUPPORTS
(
PresentationSessionInfo
nsIPresentationSessionTransportCallback
nsIPresentationControlChannelListener
)
;
nsresult
PresentationSessionInfo
:
:
Init
(
nsIPresentationControlChannel
*
aControlChannel
)
{
SetControlChannel
(
aControlChannel
)
;
return
NS_OK
;
}
void
PresentationSessionInfo
:
:
Shutdown
(
nsresult
aReason
)
{
if
(
mControlChannel
)
{
mControlChannel
-
>
SetListener
(
nullptr
)
;
NS_WARN_IF
(
NS_FAILED
(
mControlChannel
-
>
Close
(
aReason
)
)
)
;
mControlChannel
=
nullptr
;
}
if
(
mTransport
)
{
mTransport
-
>
SetCallback
(
nullptr
)
;
NS_WARN_IF
(
NS_FAILED
(
mTransport
-
>
Close
(
aReason
)
)
)
;
mTransport
=
nullptr
;
}
mIsResponderReady
=
false
;
mIsTransportReady
=
false
;
}
nsresult
PresentationSessionInfo
:
:
SetListener
(
nsIPresentationSessionListener
*
aListener
)
{
mListener
=
aListener
;
if
(
mListener
)
{
uint16_t
state
=
IsSessionReady
(
)
?
nsIPresentationSessionListener
:
:
STATE_CONNECTED
:
nsIPresentationSessionListener
:
:
STATE_DISCONNECTED
;
return
mListener
-
>
NotifyStateChange
(
mSessionId
state
)
;
}
return
NS_OK
;
}
nsresult
PresentationSessionInfo
:
:
Send
(
nsIInputStream
*
aData
)
{
return
NS_OK
;
}
nsresult
PresentationSessionInfo
:
:
Close
(
nsresult
aReason
)
{
return
NS_OK
;
}
nsresult
PresentationSessionInfo
:
:
ReplySuccess
(
)
{
if
(
mListener
)
{
nsresult
rv
=
mListener
-
>
NotifyStateChange
(
mSessionId
nsIPresentationSessionListener
:
:
STATE_CONNECTED
)
;
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
if
(
mCallback
)
{
NS_WARN_IF
(
NS_FAILED
(
mCallback
-
>
NotifySuccess
(
)
)
)
;
SetCallback
(
nullptr
)
;
}
return
NS_OK
;
}
nsresult
PresentationSessionInfo
:
:
ReplyError
(
nsresult
aError
)
{
Shutdown
(
aError
)
;
if
(
mCallback
)
{
NS_WARN_IF
(
NS_FAILED
(
mCallback
-
>
NotifyError
(
aError
)
)
)
;
SetCallback
(
nullptr
)
;
}
nsCOMPtr
<
nsIPresentationService
>
service
=
do_GetService
(
PRESENTATION_SERVICE_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
service
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
static_cast
<
PresentationService
*
>
(
service
.
get
(
)
)
-
>
RemoveSessionInfo
(
mSessionId
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PresentationSessionInfo
:
:
NotifyTransportReady
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mIsTransportReady
=
true
;
if
(
IsSessionReady
(
)
)
{
return
ReplySuccess
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationSessionInfo
:
:
NotifyTransportClosed
(
nsresult
aReason
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mTransport
=
nullptr
;
if
(
!
IsSessionReady
(
)
)
{
return
ReplyError
(
aReason
)
;
}
Shutdown
(
aReason
)
;
if
(
mListener
)
{
uint16_t
state
=
(
NS_WARN_IF
(
NS_FAILED
(
aReason
)
)
)
?
nsIPresentationSessionListener
:
:
STATE_DISCONNECTED
:
nsIPresentationSessionListener
:
:
STATE_TERMINATED
;
return
mListener
-
>
NotifyStateChange
(
mSessionId
state
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationSessionInfo
:
:
NotifyData
(
const
nsACString
&
aData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
PresentationRequesterInfo
PresentationSessionInfo
nsIServerSocketListener
)
nsresult
PresentationRequesterInfo
:
:
Init
(
nsIPresentationControlChannel
*
aControlChannel
)
{
PresentationSessionInfo
:
:
Init
(
aControlChannel
)
;
return
NS_OK
;
}
void
PresentationRequesterInfo
:
:
Shutdown
(
nsresult
aReason
)
{
PresentationSessionInfo
:
:
Shutdown
(
aReason
)
;
if
(
mServerSocket
)
{
NS_WARN_IF
(
NS_FAILED
(
mServerSocket
-
>
Close
(
)
)
)
;
mServerSocket
=
nullptr
;
}
}
NS_IMETHODIMP
PresentationRequesterInfo
:
:
OnOffer
(
nsIPresentationChannelDescription
*
aDescription
)
{
MOZ_ASSERT
(
false
"
Sender
side
should
not
receive
offer
.
"
)
;
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
PresentationRequesterInfo
:
:
OnAnswer
(
nsIPresentationChannelDescription
*
aDescription
)
{
mIsResponderReady
=
true
;
nsresult
rv
=
mControlChannel
-
>
Close
(
NS_OK
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ReplyError
(
rv
)
;
}
if
(
IsSessionReady
(
)
)
{
return
ReplySuccess
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationRequesterInfo
:
:
NotifyOpened
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
PresentationRequesterInfo
:
:
NotifyClosed
(
nsresult
aReason
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
SetControlChannel
(
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aReason
)
)
)
{
return
ReplyError
(
aReason
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationRequesterInfo
:
:
OnSocketAccepted
(
nsIServerSocket
*
aServerSocket
nsISocketTransport
*
aTransport
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mTransport
=
do_CreateInstance
(
PRESENTATION_SESSION_TRANSPORT_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
mTransport
)
)
{
return
ReplyError
(
NS_ERROR_NOT_AVAILABLE
)
;
}
nsresult
rv
=
mTransport
-
>
InitWithSocketTransport
(
aTransport
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationRequesterInfo
:
:
OnStopListening
(
nsIServerSocket
*
aServerSocket
nsresult
aStatus
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Shutdown
(
aStatus
)
;
if
(
!
IsSessionReady
(
)
)
{
return
ReplyError
(
aStatus
)
;
}
if
(
mListener
)
{
return
mListener
-
>
NotifyStateChange
(
mSessionId
nsIPresentationSessionListener
:
:
STATE_DISCONNECTED
)
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
PresentationResponderInfo
PresentationSessionInfo
nsITimerCallback
)
nsresult
PresentationResponderInfo
:
:
Init
(
nsIPresentationControlChannel
*
aControlChannel
)
{
PresentationSessionInfo
:
:
Init
(
aControlChannel
)
;
nsresult
rv
;
int32_t
timeout
=
Preferences
:
:
GetInt
(
"
presentation
.
receiver
.
loading
.
timeout
"
10000
)
;
mTimer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mTimer
-
>
InitWithCallback
(
this
timeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
void
PresentationResponderInfo
:
:
Shutdown
(
nsresult
aReason
)
{
PresentationSessionInfo
:
:
Shutdown
(
aReason
)
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
mLoadingCallback
=
nullptr
;
mRequesterDescription
=
nullptr
;
mPromise
=
nullptr
;
}
nsresult
PresentationResponderInfo
:
:
InitTransportAndSendAnswer
(
)
{
mTransport
=
do_CreateInstance
(
PRESENTATION_SESSION_TRANSPORT_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
mTransport
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
mTransport
-
>
InitWithChannelDescription
(
mRequesterDescription
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
PresentationResponderInfo
:
:
NotifyResponderReady
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
mIsResponderReady
=
true
;
if
(
mRequesterDescription
)
{
nsresult
rv
=
InitTransportAndSendAnswer
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ReplyError
(
rv
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationResponderInfo
:
:
OnOffer
(
nsIPresentationChannelDescription
*
aDescription
)
{
if
(
NS_WARN_IF
(
!
aDescription
)
)
{
return
ReplyError
(
NS_ERROR_INVALID_ARG
)
;
}
mRequesterDescription
=
aDescription
;
if
(
mIsResponderReady
)
{
nsresult
rv
=
InitTransportAndSendAnswer
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ReplyError
(
rv
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationResponderInfo
:
:
OnAnswer
(
nsIPresentationChannelDescription
*
aDescription
)
{
MOZ_ASSERT
(
false
"
Receiver
side
should
not
receive
answer
.
"
)
;
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
PresentationResponderInfo
:
:
NotifyOpened
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
PresentationResponderInfo
:
:
NotifyClosed
(
nsresult
aReason
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
SetControlChannel
(
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aReason
)
)
)
{
return
ReplyError
(
aReason
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationResponderInfo
:
:
Notify
(
nsITimer
*
aTimer
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_WARNING
(
"
The
receiver
page
fails
to
become
ready
before
timeout
.
"
)
;
mTimer
=
nullptr
;
return
ReplyError
(
NS_ERROR_DOM_TIMEOUT_ERR
)
;
}
void
PresentationResponderInfo
:
:
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
!
aValue
.
isObject
(
)
)
)
{
ReplyError
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
&
aValue
.
toObject
(
)
)
;
if
(
NS_WARN_IF
(
!
obj
)
)
{
ReplyError
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
HTMLIFrameElement
*
frame
=
nullptr
;
nsresult
rv
=
UNWRAP_OBJECT
(
HTMLIFrameElement
obj
frame
)
;
if
(
NS_WARN_IF
(
!
frame
)
)
{
ReplyError
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
nsCOMPtr
<
nsIFrameLoaderOwner
>
owner
=
do_QueryInterface
(
(
nsIFrameLoaderOwner
*
)
frame
)
;
if
(
NS_WARN_IF
(
!
owner
)
)
{
ReplyError
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
nsCOMPtr
<
nsIFrameLoader
>
frameLoader
;
rv
=
owner
-
>
GetFrameLoader
(
getter_AddRefs
(
frameLoader
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ReplyError
(
rv
)
;
return
;
}
nsRefPtr
<
TabParent
>
tabParent
=
TabParent
:
:
GetFrom
(
frameLoader
)
;
if
(
tabParent
)
{
nsCOMPtr
<
nsIContentParent
>
cp
=
tabParent
-
>
Manager
(
)
;
NS_WARN_IF
(
!
static_cast
<
ContentParent
*
>
(
cp
.
get
(
)
)
-
>
SendNotifyPresentationReceiverLaunched
(
tabParent
mSessionId
)
)
;
}
else
{
nsCOMPtr
<
nsIDocShell
>
docShell
;
rv
=
frameLoader
-
>
GetDocShell
(
getter_AddRefs
(
docShell
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ReplyError
(
rv
)
;
return
;
}
mLoadingCallback
=
new
PresentationResponderLoadingCallback
(
mSessionId
)
;
rv
=
mLoadingCallback
-
>
Init
(
docShell
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ReplyError
(
rv
)
;
return
;
}
}
}
void
PresentationResponderInfo
:
:
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_WARNING
(
"
The
receiver
page
fails
to
become
ready
before
timeout
.
"
)
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
ReplyError
(
NS_ERROR_DOM_ABORT_ERR
)
;
}
