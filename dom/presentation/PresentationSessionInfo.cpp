#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
HTMLIFrameElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
#
include
"
mozilla
/
Function
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIFrameLoader
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsINetAddr
.
h
"
#
include
"
nsISocketTransport
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
PresentationLog
.
h
"
#
include
"
PresentationService
.
h
"
#
include
"
PresentationSessionInfo
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
nsIPresentationNetworkHelper
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_GONK
#
include
"
nsINetworkInterface
.
h
"
#
include
"
nsINetworkManager
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
services
;
namespace
mozilla
{
namespace
dom
{
#
ifdef
MOZ_WIDGET_ANDROID
namespace
{
class
PresentationNetworkHelper
final
:
public
nsIPresentationNetworkHelperListener
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIPRESENTATIONNETWORKHELPERLISTENER
using
Function
=
nsresult
(
PresentationControllingInfo
:
:
*
)
(
const
nsACString
&
)
;
explicit
PresentationNetworkHelper
(
PresentationControllingInfo
*
aInfo
const
Function
&
aFunc
)
;
nsresult
GetWifiIPAddress
(
)
;
private
:
~
PresentationNetworkHelper
(
)
=
default
;
RefPtr
<
PresentationControllingInfo
>
mInfo
;
Function
mFunc
;
}
;
NS_IMPL_ISUPPORTS
(
PresentationNetworkHelper
nsIPresentationNetworkHelperListener
)
PresentationNetworkHelper
:
:
PresentationNetworkHelper
(
PresentationControllingInfo
*
aInfo
const
Function
&
aFunc
)
:
mInfo
(
aInfo
)
mFunc
(
aFunc
)
{
MOZ_ASSERT
(
aInfo
)
;
MOZ_ASSERT
(
aFunc
)
;
}
nsresult
PresentationNetworkHelper
:
:
GetWifiIPAddress
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIPresentationNetworkHelper
>
networkHelper
=
do_GetService
(
PRESENTATION_NETWORK_HELPER_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
networkHelper
-
>
GetWifiIPAddress
(
this
)
;
}
NS_IMETHODIMP
PresentationNetworkHelper
:
:
OnError
(
const
nsACString
&
aReason
)
{
PRES_ERROR
(
"
PresentationNetworkHelper
:
:
OnError
:
%
s
"
nsPromiseFlatCString
(
aReason
)
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PresentationNetworkHelper
:
:
OnGetWifiIPAddress
(
const
nsACString
&
aIPAddress
)
{
MOZ_ASSERT
(
mInfo
)
;
MOZ_ASSERT
(
mFunc
)
;
NS_DispatchToMainThread
(
NewRunnableMethod
<
nsCString
>
(
mInfo
mFunc
aIPAddress
)
)
;
return
NS_OK
;
}
}
#
endif
class
TCPPresentationChannelDescription
final
:
public
nsIPresentationChannelDescription
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIPRESENTATIONCHANNELDESCRIPTION
TCPPresentationChannelDescription
(
const
nsACString
&
aAddress
uint16_t
aPort
)
:
mAddress
(
aAddress
)
mPort
(
aPort
)
{
}
private
:
~
TCPPresentationChannelDescription
(
)
{
}
nsCString
mAddress
;
uint16_t
mPort
;
}
;
}
}
NS_IMPL_ISUPPORTS
(
TCPPresentationChannelDescription
nsIPresentationChannelDescription
)
NS_IMETHODIMP
TCPPresentationChannelDescription
:
:
GetType
(
uint8_t
*
aRetVal
)
{
if
(
NS_WARN_IF
(
!
aRetVal
)
)
{
return
NS_ERROR_INVALID_POINTER
;
}
*
aRetVal
=
nsIPresentationChannelDescription
:
:
TYPE_TCP
;
return
NS_OK
;
}
NS_IMETHODIMP
TCPPresentationChannelDescription
:
:
GetTcpAddress
(
nsIArray
*
*
aRetVal
)
{
if
(
NS_WARN_IF
(
!
aRetVal
)
)
{
return
NS_ERROR_INVALID_POINTER
;
}
nsCOMPtr
<
nsIMutableArray
>
array
=
do_CreateInstance
(
NS_ARRAY_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
array
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsCOMPtr
<
nsISupportsCString
>
address
=
do_CreateInstance
(
NS_SUPPORTS_CSTRING_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
address
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
address
-
>
SetData
(
mAddress
)
;
array
-
>
AppendElement
(
address
false
)
;
array
.
forget
(
aRetVal
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TCPPresentationChannelDescription
:
:
GetTcpPort
(
uint16_t
*
aRetVal
)
{
if
(
NS_WARN_IF
(
!
aRetVal
)
)
{
return
NS_ERROR_INVALID_POINTER
;
}
*
aRetVal
=
mPort
;
return
NS_OK
;
}
NS_IMETHODIMP
TCPPresentationChannelDescription
:
:
GetDataChannelSDP
(
nsAString
&
aDataChannelSDP
)
{
aDataChannelSDP
.
Truncate
(
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
PresentationSessionInfo
nsIPresentationSessionTransportCallback
nsIPresentationControlChannelListener
nsIPresentationSessionTransportBuilderListener
)
;
nsresult
PresentationSessionInfo
:
:
Init
(
nsIPresentationControlChannel
*
aControlChannel
)
{
SetControlChannel
(
aControlChannel
)
;
return
NS_OK
;
}
void
PresentationSessionInfo
:
:
Shutdown
(
nsresult
aReason
)
{
NS_WARN_IF
(
NS_FAILED
(
aReason
)
)
;
if
(
mControlChannel
)
{
NS_WARN_IF
(
NS_FAILED
(
mControlChannel
-
>
Disconnect
(
aReason
)
)
)
;
}
if
(
mTransport
)
{
NS_WARN_IF
(
NS_FAILED
(
mTransport
-
>
Close
(
aReason
)
)
)
;
}
mIsResponderReady
=
false
;
SetBuilder
(
nullptr
)
;
}
nsresult
PresentationSessionInfo
:
:
SetListener
(
nsIPresentationSessionListener
*
aListener
)
{
mListener
=
aListener
;
if
(
mListener
)
{
if
(
mTransport
)
{
nsresult
rv
=
mTransport
-
>
EnableDataNotification
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
mListener
-
>
NotifyStateChange
(
mSessionId
mState
mReason
)
;
}
return
NS_OK
;
}
nsresult
PresentationSessionInfo
:
:
Send
(
const
nsAString
&
aData
)
{
if
(
NS_WARN_IF
(
!
IsSessionReady
(
)
)
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
if
(
NS_WARN_IF
(
!
mTransport
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
mTransport
-
>
Send
(
aData
)
;
}
nsresult
PresentationSessionInfo
:
:
Close
(
nsresult
aReason
uint32_t
aState
)
{
if
(
NS_WARN_IF
(
!
IsSessionReady
(
)
)
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
SetStateWithReason
(
aState
aReason
)
;
Shutdown
(
aReason
)
;
return
NS_OK
;
}
nsresult
PresentationSessionInfo
:
:
ReplySuccess
(
)
{
SetStateWithReason
(
nsIPresentationSessionListener
:
:
STATE_CONNECTED
NS_OK
)
;
return
NS_OK
;
}
nsresult
PresentationSessionInfo
:
:
ReplyError
(
nsresult
aError
)
{
Shutdown
(
aError
)
;
return
UntrackFromService
(
)
;
}
nsresult
PresentationSessionInfo
:
:
UntrackFromService
(
)
{
nsCOMPtr
<
nsIPresentationService
>
service
=
do_GetService
(
PRESENTATION_SERVICE_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
service
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
static_cast
<
PresentationService
*
>
(
service
.
get
(
)
)
-
>
UntrackSessionInfo
(
mSessionId
mRole
)
;
return
NS_OK
;
}
nsPIDOMWindowInner
*
PresentationSessionInfo
:
:
GetWindow
(
)
{
nsCOMPtr
<
nsIPresentationService
>
service
=
do_GetService
(
PRESENTATION_SERVICE_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
service
)
)
{
return
nullptr
;
}
uint64_t
windowId
=
0
;
if
(
NS_WARN_IF
(
NS_FAILED
(
service
-
>
GetWindowIdBySessionId
(
mSessionId
&
windowId
)
)
)
)
{
return
nullptr
;
}
return
nsGlobalWindow
:
:
GetInnerWindowWithId
(
windowId
)
-
>
AsInner
(
)
;
}
bool
PresentationSessionInfo
:
:
IsAccessible
(
base
:
:
ProcessId
aProcessId
)
{
return
true
;
}
NS_IMETHODIMP
PresentationSessionInfo
:
:
NotifyTransportReady
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mIsTransportReady
=
true
;
if
(
mTransportType
=
=
nsIPresentationChannelDescription
:
:
TYPE_DATACHANNEL
)
{
mIsResponderReady
=
true
;
}
if
(
IsSessionReady
(
)
)
{
return
ReplySuccess
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationSessionInfo
:
:
NotifyTransportClosed
(
nsresult
aReason
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mTransport
=
nullptr
;
if
(
NS_WARN_IF
(
!
IsSessionReady
(
)
)
)
{
return
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
}
mIsTransportReady
=
false
;
if
(
mState
=
=
nsIPresentationSessionListener
:
:
STATE_CONNECTED
)
{
SetStateWithReason
(
nsIPresentationSessionListener
:
:
STATE_CLOSED
aReason
)
;
}
Shutdown
(
aReason
)
;
if
(
mState
=
=
nsIPresentationSessionListener
:
:
STATE_TERMINATED
)
{
return
UntrackFromService
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationSessionInfo
:
:
NotifyData
(
const
nsACString
&
aData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
!
IsSessionReady
(
)
)
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
if
(
NS_WARN_IF
(
!
mListener
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
mListener
-
>
NotifyMessage
(
mSessionId
aData
)
;
}
NS_IMETHODIMP
PresentationSessionInfo
:
:
OnSessionTransport
(
nsIPresentationSessionTransport
*
transport
)
{
SetBuilder
(
nullptr
)
;
if
(
!
transport
)
{
return
NS_OK
;
}
mTransport
=
transport
;
nsresult
rv
=
mTransport
-
>
SetCallback
(
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
mListener
)
{
mTransport
-
>
EnableDataNotification
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationSessionInfo
:
:
OnError
(
nsresult
reason
)
{
SetBuilder
(
nullptr
)
;
return
ReplyError
(
reason
)
;
}
NS_IMETHODIMP
PresentationSessionInfo
:
:
SendOffer
(
nsIPresentationChannelDescription
*
aOffer
)
{
return
mControlChannel
-
>
SendOffer
(
aOffer
)
;
}
NS_IMETHODIMP
PresentationSessionInfo
:
:
SendAnswer
(
nsIPresentationChannelDescription
*
aAnswer
)
{
return
mControlChannel
-
>
SendAnswer
(
aAnswer
)
;
}
NS_IMETHODIMP
PresentationSessionInfo
:
:
SendIceCandidate
(
const
nsAString
&
candidate
)
{
return
mControlChannel
-
>
SendIceCandidate
(
candidate
)
;
}
NS_IMETHODIMP
PresentationSessionInfo
:
:
Close
(
nsresult
reason
)
{
return
mControlChannel
-
>
Disconnect
(
reason
)
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
PresentationControllingInfo
PresentationSessionInfo
nsIServerSocketListener
)
nsresult
PresentationControllingInfo
:
:
Init
(
nsIPresentationControlChannel
*
aControlChannel
)
{
PresentationSessionInfo
:
:
Init
(
aControlChannel
)
;
mServerSocket
=
do_CreateInstance
(
NS_SERVERSOCKET_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
mServerSocket
)
)
{
return
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
}
nsresult
rv
=
mServerSocket
-
>
Init
(
-
1
false
-
1
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mServerSocket
-
>
AsyncListen
(
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
int32_t
port
;
rv
=
mServerSocket
-
>
GetPort
(
&
port
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
PRES_DEBUG
(
"
%
s
:
ServerSocket
created
.
port
[
%
d
]
\
n
"
__func__
port
)
;
}
return
NS_OK
;
}
void
PresentationControllingInfo
:
:
Shutdown
(
nsresult
aReason
)
{
PresentationSessionInfo
:
:
Shutdown
(
aReason
)
;
if
(
mServerSocket
)
{
NS_WARN_IF
(
NS_FAILED
(
mServerSocket
-
>
Close
(
)
)
)
;
mServerSocket
=
nullptr
;
}
}
nsresult
PresentationControllingInfo
:
:
GetAddress
(
)
{
#
if
defined
(
MOZ_WIDGET_GONK
)
nsCOMPtr
<
nsINetworkManager
>
networkManager
=
do_GetService
(
"
mozilla
.
org
/
network
/
manager
;
1
"
)
;
if
(
NS_WARN_IF
(
!
networkManager
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsINetworkInfo
>
activeNetworkInfo
;
networkManager
-
>
GetActiveNetworkInfo
(
getter_AddRefs
(
activeNetworkInfo
)
)
;
if
(
NS_WARN_IF
(
!
activeNetworkInfo
)
)
{
return
NS_ERROR_FAILURE
;
}
char16_t
*
*
ips
=
nullptr
;
uint32_t
*
prefixes
=
nullptr
;
uint32_t
count
=
0
;
activeNetworkInfo
-
>
GetAddresses
(
&
ips
&
prefixes
&
count
)
;
if
(
NS_WARN_IF
(
!
count
)
)
{
NS_Free
(
prefixes
)
;
NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY
(
count
ips
)
;
return
NS_ERROR_FAILURE
;
}
nsAutoString
ip
;
ip
.
Assign
(
ips
[
0
]
)
;
NS_DispatchToMainThread
(
NewRunnableMethod
<
nsCString
>
(
this
&
PresentationControllingInfo
:
:
OnGetAddress
NS_ConvertUTF16toUTF8
(
ip
)
)
)
;
NS_Free
(
prefixes
)
;
NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY
(
count
ips
)
;
#
elif
defined
(
MOZ_WIDGET_ANDROID
)
RefPtr
<
PresentationNetworkHelper
>
networkHelper
=
new
PresentationNetworkHelper
(
this
&
PresentationControllingInfo
:
:
OnGetAddress
)
;
nsresult
rv
=
networkHelper
-
>
GetWifiIPAddress
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
#
elif
defined
(
MOZ_MULET
)
NS_DispatchToMainThread
(
NewRunnableMethod
<
nsCString
>
(
this
&
PresentationControllingInfo
:
:
OnGetAddress
"
127
.
0
.
0
.
1
"
)
)
;
#
else
NS_DispatchToMainThread
(
NewRunnableMethod
<
nsCString
>
(
this
&
PresentationControllingInfo
:
:
OnGetAddress
EmptyCString
(
)
)
)
;
#
endif
return
NS_OK
;
}
nsresult
PresentationControllingInfo
:
:
OnGetAddress
(
const
nsACString
&
aAddress
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
int32_t
port
;
nsresult
rv
=
mServerSocket
-
>
GetPort
(
&
port
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
RefPtr
<
TCPPresentationChannelDescription
>
description
=
new
TCPPresentationChannelDescription
(
aAddress
static_cast
<
uint16_t
>
(
port
)
)
;
return
mControlChannel
-
>
SendOffer
(
description
)
;
}
NS_IMETHODIMP
PresentationControllingInfo
:
:
OnIceCandidate
(
const
nsAString
&
aCandidate
)
{
if
(
mTransportType
!
=
nsIPresentationChannelDescription
:
:
TYPE_DATACHANNEL
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIPresentationDataChannelSessionTransportBuilder
>
builder
=
do_QueryInterface
(
mBuilder
)
;
if
(
NS_WARN_IF
(
!
builder
)
)
{
return
NS_ERROR_FAILURE
;
}
return
builder
-
>
OnIceCandidate
(
aCandidate
)
;
}
NS_IMETHODIMP
PresentationControllingInfo
:
:
OnOffer
(
nsIPresentationChannelDescription
*
aDescription
)
{
MOZ_ASSERT
(
false
"
Sender
side
should
not
receive
offer
.
"
)
;
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
PresentationControllingInfo
:
:
OnAnswer
(
nsIPresentationChannelDescription
*
aDescription
)
{
if
(
mTransportType
=
=
nsIPresentationChannelDescription
:
:
TYPE_DATACHANNEL
)
{
nsCOMPtr
<
nsIPresentationDataChannelSessionTransportBuilder
>
builder
=
do_QueryInterface
(
mBuilder
)
;
if
(
NS_WARN_IF
(
!
builder
)
)
{
return
NS_ERROR_FAILURE
;
}
return
builder
-
>
OnAnswer
(
aDescription
)
;
}
mIsResponderReady
=
true
;
nsresult
rv
=
mControlChannel
-
>
Disconnect
(
NS_OK
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
}
if
(
IsSessionReady
(
)
)
{
return
ReplySuccess
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationControllingInfo
:
:
NotifyOpened
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
mControlChannel
-
>
Launch
(
GetSessionId
(
)
GetUrl
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
Preferences
:
:
GetBool
(
"
dom
.
presentation
.
session_transport
.
data_channel
.
enable
"
)
)
{
return
GetAddress
(
)
;
}
nsPIDOMWindowInner
*
window
=
nullptr
;
if
(
!
mBuilder
)
{
nsCOMPtr
<
nsIPresentationDataChannelSessionTransportBuilder
>
builder
=
do_CreateInstance
(
"
mozilla
.
org
/
presentation
/
datachanneltransportbuilder
;
1
"
)
;
if
(
NS_WARN_IF
(
!
builder
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
SetBuilder
(
builder
)
;
window
=
GetWindow
(
)
;
}
mTransportType
=
nsIPresentationChannelDescription
:
:
TYPE_DATACHANNEL
;
nsCOMPtr
<
nsIPresentationDataChannelSessionTransportBuilder
>
dataChannelBuilder
(
do_QueryInterface
(
mBuilder
)
)
;
if
(
NS_WARN_IF
(
!
dataChannelBuilder
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
rv
=
dataChannelBuilder
-
>
BuildDataChannelTransport
(
nsIPresentationService
:
:
ROLE_CONTROLLER
window
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationControllingInfo
:
:
NotifyClosed
(
nsresult
aReason
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mTransportType
=
=
nsIPresentationChannelDescription
:
:
TYPE_DATACHANNEL
)
{
nsCOMPtr
<
nsIPresentationDataChannelSessionTransportBuilder
>
builder
=
do_QueryInterface
(
mBuilder
)
;
if
(
builder
)
{
NS_WARN_IF
(
NS_FAILED
(
builder
-
>
NotifyClosed
(
aReason
)
)
)
;
}
}
SetControlChannel
(
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aReason
)
|
|
!
mIsResponderReady
)
)
{
SetStateWithReason
(
nsIPresentationSessionListener
:
:
STATE_TERMINATED
aReason
)
;
return
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationControllingInfo
:
:
OnSocketAccepted
(
nsIServerSocket
*
aServerSocket
nsISocketTransport
*
aTransport
)
{
int32_t
port
;
nsresult
rv
=
aTransport
-
>
GetPort
(
&
port
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
PRES_DEBUG
(
"
%
s
:
receive
from
port
[
%
d
]
\
n
"
__func__
port
)
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIPresentationTCPSessionTransportBuilder
>
builder
=
do_CreateInstance
(
PRESENTATION_TCP_SESSION_TRANSPORT_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
builder
)
)
{
return
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
}
mTransportType
=
nsIPresentationChannelDescription
:
:
TYPE_TCP
;
return
builder
-
>
BuildTCPSenderTransport
(
aTransport
this
)
;
}
NS_IMETHODIMP
PresentationControllingInfo
:
:
OnStopListening
(
nsIServerSocket
*
aServerSocket
nsresult
aStatus
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aStatus
=
=
NS_BINDING_ABORTED
)
{
return
NS_OK
;
}
Shutdown
(
aStatus
)
;
if
(
NS_WARN_IF
(
!
IsSessionReady
(
)
)
)
{
return
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
}
SetStateWithReason
(
nsIPresentationSessionListener
:
:
STATE_CLOSED
aStatus
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
PresentationPresentingInfo
PresentationSessionInfo
nsITimerCallback
)
nsresult
PresentationPresentingInfo
:
:
Init
(
nsIPresentationControlChannel
*
aControlChannel
)
{
PresentationSessionInfo
:
:
Init
(
aControlChannel
)
;
nsresult
rv
;
int32_t
timeout
=
Preferences
:
:
GetInt
(
"
presentation
.
receiver
.
loading
.
timeout
"
10000
)
;
mTimer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mTimer
-
>
InitWithCallback
(
this
timeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
void
PresentationPresentingInfo
:
:
Shutdown
(
nsresult
aReason
)
{
PresentationSessionInfo
:
:
Shutdown
(
aReason
)
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
if
(
mDevice
)
{
mDevice
-
>
Disconnect
(
)
;
}
mDevice
=
nullptr
;
mLoadingCallback
=
nullptr
;
mRequesterDescription
=
nullptr
;
mPendingCandidates
.
Clear
(
)
;
mPromise
=
nullptr
;
}
NS_IMETHODIMP
PresentationPresentingInfo
:
:
OnSessionTransport
(
nsIPresentationSessionTransport
*
transport
)
{
nsresult
rv
=
PresentationSessionInfo
:
:
OnSessionTransport
(
transport
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
transport
)
{
return
NS_OK
;
}
if
(
mTransportType
=
=
nsIPresentationChannelDescription
:
:
TYPE_TCP
)
{
nsCOMPtr
<
nsINetAddr
>
selfAddr
;
rv
=
mTransport
-
>
GetSelfAddress
(
getter_AddRefs
(
selfAddr
)
)
;
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
nsCString
address
;
uint16_t
port
=
0
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
selfAddr
-
>
GetAddress
(
address
)
;
selfAddr
-
>
GetPort
(
&
port
)
;
}
nsCOMPtr
<
nsIPresentationChannelDescription
>
description
=
new
TCPPresentationChannelDescription
(
address
port
)
;
return
mControlChannel
-
>
SendAnswer
(
description
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationPresentingInfo
:
:
FlushPendingEvents
(
nsIPresentationDataChannelSessionTransportBuilder
*
builder
)
{
if
(
NS_WARN_IF
(
!
builder
)
)
{
return
NS_ERROR_FAILURE
;
}
mHasFlushPendingEvents
=
true
;
if
(
mRequesterDescription
)
{
builder
-
>
OnOffer
(
mRequesterDescription
)
;
}
mRequesterDescription
=
nullptr
;
for
(
size_t
i
=
0
;
i
<
mPendingCandidates
.
Length
(
)
;
+
+
i
)
{
builder
-
>
OnIceCandidate
(
mPendingCandidates
[
i
]
)
;
}
mPendingCandidates
.
Clear
(
)
;
return
NS_OK
;
}
nsresult
PresentationPresentingInfo
:
:
InitTransportAndSendAnswer
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
uint8_t
type
=
0
;
nsresult
rv
=
mRequesterDescription
-
>
GetType
(
&
type
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
type
=
=
nsIPresentationChannelDescription
:
:
TYPE_TCP
)
{
nsCOMPtr
<
nsIPresentationTCPSessionTransportBuilder
>
builder
=
do_CreateInstance
(
PRESENTATION_TCP_SESSION_TRANSPORT_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
builder
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
SetBuilder
(
builder
)
;
mTransportType
=
nsIPresentationChannelDescription
:
:
TYPE_TCP
;
return
builder
-
>
BuildTCPReceiverTransport
(
mRequesterDescription
this
)
;
}
if
(
type
=
=
nsIPresentationChannelDescription
:
:
TYPE_DATACHANNEL
)
{
if
(
!
Preferences
:
:
GetBool
(
"
dom
.
presentation
.
session_transport
.
data_channel
.
enable
"
)
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsPIDOMWindowInner
*
window
=
nullptr
;
if
(
!
mBuilder
)
{
nsCOMPtr
<
nsIPresentationDataChannelSessionTransportBuilder
>
builder
=
do_CreateInstance
(
"
mozilla
.
org
/
presentation
/
datachanneltransportbuilder
;
1
"
)
;
if
(
NS_WARN_IF
(
!
builder
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
SetBuilder
(
builder
)
;
window
=
GetWindow
(
)
;
}
mTransportType
=
nsIPresentationChannelDescription
:
:
TYPE_DATACHANNEL
;
nsCOMPtr
<
nsIPresentationDataChannelSessionTransportBuilder
>
dataChannelBuilder
(
do_QueryInterface
(
mBuilder
)
)
;
if
(
NS_WARN_IF
(
!
dataChannelBuilder
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
rv
=
dataChannelBuilder
-
>
BuildDataChannelTransport
(
nsIPresentationService
:
:
ROLE_RECEIVER
window
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
this
-
>
FlushPendingEvents
(
dataChannelBuilder
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
MOZ_ASSERT
(
false
"
Unknown
nsIPresentationChannelDescription
type
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsresult
PresentationPresentingInfo
:
:
UntrackFromService
(
)
{
if
(
mContentParent
)
{
NS_WARN_IF
(
!
static_cast
<
ContentParent
*
>
(
mContentParent
.
get
(
)
)
-
>
SendNotifyPresentationReceiverCleanUp
(
mSessionId
)
)
;
}
nsCOMPtr
<
nsIPresentationService
>
service
=
do_GetService
(
PRESENTATION_SERVICE_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
service
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
static_cast
<
PresentationService
*
>
(
service
.
get
(
)
)
-
>
UntrackSessionInfo
(
mSessionId
mRole
)
;
return
NS_OK
;
}
bool
PresentationPresentingInfo
:
:
IsAccessible
(
base
:
:
ProcessId
aProcessId
)
{
return
(
mContentParent
)
?
aProcessId
=
=
static_cast
<
ContentParent
*
>
(
mContentParent
.
get
(
)
)
-
>
OtherPid
(
)
:
false
;
}
nsresult
PresentationPresentingInfo
:
:
NotifyResponderReady
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
mIsResponderReady
=
true
;
if
(
mRequesterDescription
)
{
nsresult
rv
=
InitTransportAndSendAnswer
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationPresentingInfo
:
:
OnOffer
(
nsIPresentationChannelDescription
*
aDescription
)
{
if
(
NS_WARN_IF
(
mHasFlushPendingEvents
)
)
{
return
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
}
if
(
NS_WARN_IF
(
!
aDescription
)
)
{
return
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
}
mRequesterDescription
=
aDescription
;
if
(
mIsResponderReady
)
{
nsresult
rv
=
InitTransportAndSendAnswer
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationPresentingInfo
:
:
OnAnswer
(
nsIPresentationChannelDescription
*
aDescription
)
{
MOZ_ASSERT
(
false
"
Receiver
side
should
not
receive
answer
.
"
)
;
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
PresentationPresentingInfo
:
:
OnIceCandidate
(
const
nsAString
&
aCandidate
)
{
if
(
!
mBuilder
&
&
!
mHasFlushPendingEvents
)
{
mPendingCandidates
.
AppendElement
(
nsString
(
aCandidate
)
)
;
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
mBuilder
&
&
mHasFlushPendingEvents
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIPresentationDataChannelSessionTransportBuilder
>
builder
=
do_QueryInterface
(
mBuilder
)
;
return
builder
-
>
OnIceCandidate
(
aCandidate
)
;
}
NS_IMETHODIMP
PresentationPresentingInfo
:
:
NotifyOpened
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
PresentationPresentingInfo
:
:
NotifyClosed
(
nsresult
aReason
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mTransportType
=
=
nsIPresentationChannelDescription
:
:
TYPE_DATACHANNEL
)
{
nsCOMPtr
<
nsIPresentationDataChannelSessionTransportBuilder
>
builder
=
do_QueryInterface
(
mBuilder
)
;
if
(
builder
)
{
NS_WARN_IF
(
NS_FAILED
(
builder
-
>
NotifyClosed
(
aReason
)
)
)
;
}
}
SetControlChannel
(
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aReason
)
)
)
{
SetStateWithReason
(
nsIPresentationSessionListener
:
:
STATE_TERMINATED
aReason
)
;
return
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresentationPresentingInfo
:
:
Notify
(
nsITimer
*
aTimer
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_WARNING
(
"
The
receiver
page
fails
to
become
ready
before
timeout
.
"
)
;
mTimer
=
nullptr
;
return
ReplyError
(
NS_ERROR_DOM_TIMEOUT_ERR
)
;
}
void
PresentationPresentingInfo
:
:
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
!
aValue
.
isObject
(
)
)
)
{
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
&
aValue
.
toObject
(
)
)
;
if
(
NS_WARN_IF
(
!
obj
)
)
{
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
return
;
}
HTMLIFrameElement
*
frame
=
nullptr
;
nsresult
rv
=
UNWRAP_OBJECT
(
HTMLIFrameElement
obj
frame
)
;
if
(
NS_WARN_IF
(
!
frame
)
)
{
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
return
;
}
nsCOMPtr
<
nsIFrameLoaderOwner
>
owner
=
do_QueryInterface
(
(
nsIFrameLoaderOwner
*
)
frame
)
;
if
(
NS_WARN_IF
(
!
owner
)
)
{
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
return
;
}
nsCOMPtr
<
nsIFrameLoader
>
frameLoader
;
rv
=
owner
-
>
GetFrameLoader
(
getter_AddRefs
(
frameLoader
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
return
;
}
RefPtr
<
TabParent
>
tabParent
=
TabParent
:
:
GetFrom
(
frameLoader
)
;
if
(
tabParent
)
{
mContentParent
=
tabParent
-
>
Manager
(
)
;
NS_WARN_IF
(
!
static_cast
<
ContentParent
*
>
(
mContentParent
.
get
(
)
)
-
>
SendNotifyPresentationReceiverLaunched
(
tabParent
mSessionId
)
)
;
}
else
{
nsCOMPtr
<
nsIDocShell
>
docShell
;
rv
=
frameLoader
-
>
GetDocShell
(
getter_AddRefs
(
docShell
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
return
;
}
mLoadingCallback
=
new
PresentationResponderLoadingCallback
(
mSessionId
)
;
rv
=
mLoadingCallback
-
>
Init
(
docShell
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
return
;
}
}
}
void
PresentationPresentingInfo
:
:
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_WARNING
(
"
Launching
the
receiver
page
has
been
rejected
.
"
)
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
ReplyError
(
NS_ERROR_DOM_OPERATION_ERR
)
;
}
