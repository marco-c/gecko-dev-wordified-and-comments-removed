#
ifndef
mozilla_dom_PresentationSessionTransport_h
#
define
mozilla_dom_PresentationSessionTransport_h
#
include
"
mozilla
/
nsRefPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsIPresentationSessionTransport
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsITransport
.
h
"
class
nsISocketTransport
;
class
nsIInputStreamPump
;
class
nsIScriptableInputStream
;
class
nsIMultiplexInputStream
;
class
nsIAsyncStreamCopier
;
class
nsIInputStream
;
namespace
mozilla
{
namespace
dom
{
class
PresentationSessionTransport
final
:
public
nsIPresentationSessionTransport
public
nsITransportEventSink
public
nsIInputStreamCallback
public
nsIStreamListener
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIPRESENTATIONSESSIONTRANSPORT
NS_DECL_NSITRANSPORTEVENTSINK
NS_DECL_NSIINPUTSTREAMCALLBACK
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
PresentationSessionTransport
(
)
;
void
NotifyCopyComplete
(
nsresult
aStatus
)
;
private
:
~
PresentationSessionTransport
(
)
;
nsresult
CreateStream
(
)
;
nsresult
CreateInputStreamPump
(
)
;
void
EnsureCopying
(
)
;
enum
ReadyState
{
CONNECTING
OPEN
CLOSING
CLOSED
}
;
void
SetReadyState
(
ReadyState
aReadyState
)
;
bool
IsReadyToNotifyData
(
)
{
return
mDataNotificationEnabled
&
&
mReadyState
=
=
OPEN
;
}
ReadyState
mReadyState
;
bool
mAsyncCopierActive
;
nsresult
mCloseStatus
;
bool
mDataNotificationEnabled
;
nsCOMPtr
<
nsISocketTransport
>
mTransport
;
nsCOMPtr
<
nsIInputStream
>
mSocketInputStream
;
nsCOMPtr
<
nsIOutputStream
>
mSocketOutputStream
;
nsCOMPtr
<
nsIInputStreamPump
>
mInputStreamPump
;
nsCOMPtr
<
nsIScriptableInputStream
>
mInputStreamScriptable
;
nsCOMPtr
<
nsIMultiplexInputStream
>
mMultiplexStream
;
nsCOMPtr
<
nsIAsyncStreamCopier
>
mMultiplexStreamCopier
;
nsCOMPtr
<
nsIPresentationSessionTransportCallback
>
mCallback
;
}
;
}
}
#
endif
