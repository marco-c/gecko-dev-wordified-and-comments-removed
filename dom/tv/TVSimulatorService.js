"
use
strict
"
;
function
debug
(
aMsg
)
{
}
const
Cc
=
Components
.
classes
;
const
Cu
=
Components
.
utils
;
const
Ci
=
Components
.
interfaces
;
const
Cr
=
Components
.
returnCode
;
Cu
.
importGlobalProperties
(
[
"
File
"
]
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
TV_SIMULATOR_DUMMY_DIRECTORY
=
"
dummy
"
;
const
TV_SIMULATOR_DUMMY_FILE
=
"
settings
.
json
"
;
const
TV_SOURCE_TYPES
=
[
"
dvb
-
t
"
"
dvb
-
t2
"
"
dvb
-
c
"
"
dvb
-
c2
"
"
dvb
-
s
"
"
dvb
-
s2
"
"
dvb
-
h
"
"
dvb
-
sh
"
"
atsc
"
"
atsc
-
m
/
h
"
"
isdb
-
t
"
"
isdb
-
tb
"
"
isdb
-
s
"
"
isdb
-
c
"
"
1seg
"
"
dtmb
"
"
cmmb
"
"
t
-
dmb
"
"
s
-
dmb
"
]
;
function
containInvalidSourceType
(
aElement
aIndex
aArray
)
{
return
!
TV_SOURCE_TYPES
.
includes
(
aElement
)
;
}
const
TV_CHANNEL_TYPES
=
[
"
tv
"
"
radio
"
"
data
"
]
;
function
TVSimulatorService
(
)
{
this
.
_sourceListeners
=
{
}
;
this
.
_internalTuners
=
null
;
try
{
this
.
initData
(
)
;
}
catch
(
e
)
{
debug
(
"
Error
:
"
+
e
+
"
Cannot
init
the
data
.
"
)
;
}
}
TVSimulatorService
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
94b065ad
-
d45a
-
436a
-
b394
-
6dabc3cf110f
}
"
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsITVSimulatorService
Ci
.
nsITVService
]
)
initData
:
function
(
aMockedData
)
{
let
settingStr
=
aMockedData
;
if
(
!
settingStr
)
{
try
{
settingStr
=
this
.
_getDummyData
(
)
;
}
catch
(
e
)
{
debug
(
"
TV
Simulator
service
failed
to
load
simulation
data
:
"
+
e
)
;
throw
Cr
.
NS_ERROR_FAILURE
;
}
}
let
settingsObj
;
try
{
settingsObj
=
JSON
.
parse
(
settingStr
)
;
}
catch
(
e
)
{
debug
(
"
File
load
error
:
"
+
e
)
;
throw
Cr
.
NS_ERROR_FAILURE
;
}
if
(
!
this
.
_validateSettings
(
settingsObj
)
)
{
debug
(
"
Failed
to
validate
settings
.
"
)
;
throw
Cr
.
NS_ERROR_INVALID_ARG
;
}
this
.
_internalTuners
=
new
Map
(
)
;
for
(
let
tunerData
of
settingsObj
.
tuners
)
{
let
tuner
=
Cc
[
"
mozilla
.
org
/
tv
/
tvtunerdata
;
1
"
]
.
createInstance
(
Ci
.
nsITVTunerData
)
;
tuner
.
id
=
tunerData
.
id
;
tuner
.
streamType
=
tuner
.
TV_STREAM_TYPE_SIMULATOR
;
tuner
.
setSupportedSourceTypes
(
tunerData
.
supportedType
.
length
tunerData
.
supportedType
)
;
let
wrapTunerData
=
{
'
tuner
'
:
tuner
'
channels
'
:
new
Map
(
)
'
sourceType
'
:
undefined
}
;
for
(
let
sourceData
of
tunerData
.
sources
)
{
wrapTunerData
.
sourceType
=
sourceData
.
type
;
for
(
let
channelData
of
sourceData
.
channels
)
{
let
channel
=
Cc
[
"
mozilla
.
org
/
tv
/
tvchanneldata
;
1
"
]
.
createInstance
(
Ci
.
nsITVChannelData
)
;
channel
.
networkId
=
channelData
.
networkId
;
channel
.
transportStreamId
=
channelData
.
transportStreamId
;
channel
.
serviceId
=
channelData
.
serviceId
;
channel
.
type
=
channelData
.
type
;
channel
.
name
=
channelData
.
name
;
channel
.
number
=
channelData
.
number
;
channel
.
isEmergency
=
channelData
.
isEmergency
;
channel
.
isFree
=
channelData
.
isFree
;
let
wrapChannelData
=
{
'
channel
'
:
channel
'
programs
'
:
new
Array
(
)
'
videoFilePath
'
:
channelData
.
videoFilePath
}
;
for
(
let
programData
of
channelData
.
programs
)
{
let
program
=
Cc
[
"
mozilla
.
org
/
tv
/
tvprogramdata
;
1
"
]
.
createInstance
(
Ci
.
nsITVProgramData
)
;
program
.
eventId
=
programData
.
eventId
;
program
.
title
=
programData
.
title
;
program
.
startTime
=
programData
.
startTime
;
program
.
duration
=
programData
.
duration
;
program
.
description
=
programData
.
description
;
program
.
rating
=
programData
.
rating
;
program
.
setAudioLanguages
(
programData
.
audioLanguages
.
length
programData
.
audioLanguages
)
;
program
.
setSubtitleLanguages
(
programData
.
subtitleLanguages
.
length
programData
.
subtitleLanguages
)
;
wrapChannelData
.
programs
.
push
(
program
)
;
}
wrapChannelData
.
programs
.
sort
(
function
(
a
b
)
{
return
a
.
startTime
-
b
.
startTime
;
}
)
;
wrapTunerData
.
channels
.
set
(
channel
.
number
wrapChannelData
)
;
}
wrapTunerData
.
channels
=
new
Map
(
[
.
.
.
wrapTunerData
.
channels
.
entries
(
)
]
.
sort
(
function
(
a
b
)
{
return
a
[
0
]
-
b
[
0
]
;
}
)
)
;
this
.
_internalTuners
.
set
(
this
.
_getTunerMapKey
(
tuner
.
id
sourceData
.
type
)
wrapTunerData
)
;
}
}
}
registerSourceListener
:
function
(
aTunerId
aSourceType
aListener
)
{
let
tunerSourceListeners
=
this
.
_sourceListeners
[
aTunerId
]
;
if
(
!
tunerSourceListeners
)
{
tunerSourceListeners
=
this
.
_sourceListeners
[
aTunerId
]
=
{
}
;
}
let
listeners
=
tunerSourceListeners
[
aSourceType
]
;
if
(
!
listeners
)
{
listeners
=
tunerSourceListeners
[
aSourceType
]
=
[
]
;
}
if
(
listeners
.
indexOf
(
aListener
)
<
0
)
{
listeners
.
push
(
aListener
)
;
}
}
unregisterSourceListener
:
function
(
aTunerId
aSourceType
aListener
)
{
let
tunerSourceListeners
=
this
.
_sourceListeners
[
aTunerId
]
;
if
(
!
tunerSourceListeners
)
{
return
;
}
let
listeners
=
tunerSourceListeners
[
aSourceType
]
;
if
(
!
listeners
)
{
return
;
}
let
index
=
listeners
.
indexOf
(
aListener
)
;
if
(
index
<
0
)
{
return
;
}
listeners
.
splice
(
index
1
)
;
}
_getSourceListeners
:
function
(
aTunerId
aSourceType
)
{
let
tunerSourceListeners
=
this
.
_sourceListeners
[
aTunerId
]
;
if
(
!
tunerSourceListeners
)
{
return
[
]
;
}
let
listeners
=
tunerSourceListeners
[
aSourceType
]
;
if
(
!
listeners
)
{
return
[
]
;
}
return
listeners
;
}
getTuners
:
function
(
aCallback
)
{
if
(
!
aCallback
)
{
debug
(
"
aCallback
is
null
\
n
"
)
;
throw
Cr
.
NS_ERROR_INVALID_ARG
;
}
let
tuners
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
for
(
let
[
k
wrapTunerData
]
of
this
.
_internalTuners
)
{
tuners
.
appendElement
(
wrapTunerData
.
tuner
false
)
;
}
aCallback
.
notifySuccess
(
tuners
)
;
}
setSource
:
function
(
aTunerId
aSourceType
aCallback
)
{
if
(
!
aCallback
)
{
debug
(
"
aCallback
is
null
\
n
"
)
;
throw
NS_ERROR_INVALID_ARG
;
}
let
wrapTunerData
=
this
.
_getWrapTunerData
(
aTunerId
aSourceType
)
;
if
(
!
wrapTunerData
)
{
aCallback
.
notifyError
(
Ci
.
nsITVServiceCallback
.
TV_ERROR_FAILURE
)
;
return
;
}
let
streamHandle
=
Cc
[
"
mozilla
.
org
/
tv
/
tvgonknativehandledata
;
1
"
]
.
createInstance
(
Ci
.
nsITVGonkNativeHandleData
)
;
let
streamHandles
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
streamHandles
.
appendElement
(
streamHandle
false
)
;
aCallback
.
notifySuccess
(
streamHandles
)
;
}
startScanningChannels
:
function
(
aTunerId
aSourceType
aCallback
)
{
if
(
!
aCallback
)
{
debug
(
"
aCallback
is
null
\
n
"
)
;
throw
Cr
.
NS_ERROR_INVALID_ARG
;
}
let
wrapTunerData
=
this
.
_getWrapTunerData
(
aTunerId
aSourceType
)
;
if
(
!
wrapTunerData
|
|
!
wrapTunerData
.
channels
)
{
aCallback
.
notifyError
(
Ci
.
nsITVServiceCallback
.
TV_ERROR_FAILURE
)
;
return
;
}
aCallback
.
notifySuccess
(
null
)
;
}
stopScanningChannels
:
function
(
aTunerId
aSourceType
aCallback
)
{
if
(
!
aCallback
)
{
debug
(
"
aCallback
is
null
\
n
"
)
;
throw
Cr
.
NS_ERROR_INVALID_ARG
;
}
for
(
let
listener
of
this
.
_getSourceListeners
(
aTunerId
aSourceType
)
)
{
listener
.
notifyChannelScanStopped
(
aTunerId
aSourceType
)
;
}
aCallback
.
notifySuccess
(
null
)
;
}
clearScannedChannelsCache
:
function
(
aTunerId
aSourceType
aCallback
)
{
}
setChannel
:
function
(
aTunerId
aSourceType
aChannelNumber
aCallback
)
{
if
(
!
aCallback
)
{
debug
(
"
aCallback
is
null
\
n
"
)
;
throw
Cr
.
NS_ERROR_INVALID_ARG
;
}
let
channel
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
let
wrapTunerData
=
this
.
_getWrapTunerData
(
aTunerId
aSourceType
)
;
if
(
!
wrapTunerData
|
|
!
wrapTunerData
.
channels
)
{
aCallback
.
notifyError
(
Ci
.
nsITVServiceCallback
.
TV_ERROR_FAILURE
)
;
return
;
}
let
wrapChannelData
=
wrapTunerData
.
channels
.
get
(
aChannelNumber
)
;
if
(
!
wrapChannelData
)
{
aCallback
.
notifyError
(
Ci
.
nsITVServiceCallback
.
TV_ERROR_FAILURE
)
;
return
;
}
channel
.
appendElement
(
wrapChannelData
.
channel
false
)
;
aCallback
.
notifySuccess
(
channel
)
;
}
getChannels
:
function
(
aTunerId
aSourceType
aCallback
)
{
if
(
!
aCallback
)
{
debug
(
"
aCallback
is
null
\
n
"
)
;
throw
Cr
.
NS_ERROR_INVALID_ARG
;
}
let
channelArray
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
let
wrapTunerData
=
this
.
_getWrapTunerData
(
aTunerId
aSourceType
)
;
if
(
!
wrapTunerData
|
|
!
wrapTunerData
.
channels
)
{
aCallback
.
notifyError
(
Ci
.
nsITVServiceCallback
.
TV_ERROR_FAILURE
)
;
return
;
}
for
(
let
[
key
wrapChannelData
]
of
wrapTunerData
.
channels
)
{
channelArray
.
appendElement
(
wrapChannelData
.
channel
false
)
;
}
aCallback
.
notifySuccess
(
channelArray
)
;
}
getPrograms
:
function
(
aTunerId
aSourceType
aChannelNumber
aStartTime
aEndTime
aCallback
)
{
if
(
!
aCallback
)
{
debug
(
"
aCallback
is
null
\
n
"
)
;
throw
Cr
.
NS_ERROR_INVALID_ARG
;
}
let
programArray
=
Cc
[
"
mozilla
.
org
/
array
;
1
"
]
.
createInstance
(
Ci
.
nsIMutableArray
)
;
let
wrapTunerData
=
this
.
_getWrapTunerData
(
aTunerId
aSourceType
)
;
if
(
!
wrapTunerData
|
|
!
wrapTunerData
.
channels
)
{
aCallback
.
notifyError
(
Ci
.
nsITVServiceCallback
.
TV_ERROR_FAILURE
)
;
return
;
}
let
wrapChannelData
=
wrapTunerData
.
channels
.
get
(
aChannelNumber
)
;
if
(
!
wrapChannelData
|
|
!
wrapChannelData
.
programs
)
{
throw
Cr
.
NS_ERROR_INVALID_ARG
;
}
for
(
let
program
of
wrapChannelData
.
programs
)
{
programArray
.
appendElement
(
program
false
)
;
}
aCallback
.
notifySuccess
(
programArray
)
;
}
getSimulatorVideoBlobURL
:
function
(
aTunerId
aSourceType
aChannelNumber
aWin
)
{
let
wrapTunerData
=
this
.
_getWrapTunerData
(
aTunerId
aSourceType
)
;
if
(
!
wrapTunerData
|
|
!
wrapTunerData
.
channels
)
{
return
"
"
;
}
let
wrapChannelData
=
wrapTunerData
.
channels
.
get
(
aChannelNumber
)
;
if
(
!
wrapChannelData
|
|
!
wrapChannelData
.
videoFilePath
)
{
return
"
"
;
}
let
videoFile
=
new
File
(
this
.
_getFilePath
(
wrapChannelData
.
videoFilePath
)
)
;
let
videoBlobURL
=
aWin
.
URL
.
createObjectURL
(
videoFile
)
;
return
videoBlobURL
;
}
simulateChannelScanned
:
function
(
aTunerId
aSourceType
)
{
let
wrapTunerData
=
this
.
_getWrapTunerData
(
aTunerId
aSourceType
)
;
if
(
!
wrapTunerData
|
|
!
wrapTunerData
.
channels
)
{
throw
Cr
.
NS_ERROR_INVALID_ARG
;
}
let
listeners
=
this
.
_getSourceListeners
(
aTunerId
aSourceType
)
;
for
(
let
[
key
wrapChannelData
]
of
wrapTunerData
.
channels
)
{
for
(
let
listener
of
listeners
)
{
listener
.
notifyChannelScanned
(
aTunerId
aSourceType
wrapChannelData
.
channel
)
;
}
}
}
simulateChannelScanComplete
:
function
(
aTunerId
aSourceType
)
{
for
(
let
listener
of
this
.
_getSourceListeners
(
aTunerId
aSourceType
)
)
{
listener
.
notifyChannelScanComplete
(
aTunerId
aSourceType
)
;
}
}
simulateChannelScanError
:
function
(
aTunerId
aSourceType
)
{
for
(
let
listener
of
this
.
_getSourceListeners
(
aTunerId
aSourceType
)
)
{
listener
.
notifyChannelScanStopped
(
aTunerId
aSourceType
)
;
}
}
simulateEITBroadcasted
:
function
(
aTunerId
aSourceType
aChannelNumber
)
{
let
wrapTunerData
=
this
.
_getWrapTunerData
(
aTunerId
aSourceType
)
;
if
(
!
wrapTunerData
|
|
!
wrapTunerData
.
channels
)
{
throw
Cr
.
NS_ERROR_INVALID_ARG
;
}
let
wrapChannelData
=
wrapTunerData
.
channels
.
get
(
aChannelNumber
)
;
if
(
!
wrapChannelData
|
|
!
wrapChannelData
.
programs
)
{
throw
Cr
.
NS_ERROR_INVALID_ARG
;
}
for
(
let
listener
of
this
.
_getSourceListeners
(
aTunerId
aSourceType
)
)
{
listener
.
notifyEITBroadcasted
(
aTunerId
aSourceType
wrapChannelData
.
channel
wrapChannelData
.
programs
wrapChannelData
.
programs
.
length
)
;
}
}
_getDummyData
:
function
(
)
{
let
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsILocalFile
)
;
let
fstream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileInputStream
)
;
let
cstream
=
Cc
[
"
mozilla
.
org
/
intl
/
converter
-
input
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIConverterInputStream
)
;
let
settingsStr
=
"
"
;
try
{
file
.
initWithPath
(
this
.
_getFilePath
(
TV_SIMULATOR_DUMMY_FILE
)
)
;
fstream
.
init
(
file
-
1
0
0
)
;
cstream
.
init
(
fstream
"
UTF
-
8
"
1024
Ci
.
nsIConverterInputStream
.
DEFAULT_REPLACEMENT_CHARACTER
)
;
let
str
=
{
}
;
while
(
cstream
.
readString
(
0xffffffff
str
)
!
=
0
)
{
settingsStr
+
=
str
.
value
;
}
}
catch
(
e
)
{
debug
(
"
Catch
the
Exception
when
reading
the
dummy
file
:
"
+
e
)
;
throw
e
;
}
finally
{
cstream
.
close
(
)
;
}
return
settingsStr
;
}
_getTunerMapKey
:
function
(
aTunerId
aSourceType
)
{
return
JSON
.
stringify
(
{
'
tunerId
'
:
aTunerId
'
sourceType
'
:
aSourceType
}
)
;
}
_getWrapTunerData
:
function
(
aTunerId
aSourceType
)
{
if
(
!
this
.
_internalTuners
|
|
this
.
_internalTuners
.
size
<
=
0
)
{
return
null
;
}
return
this
.
_internalTuners
.
get
(
this
.
_getTunerMapKey
(
aTunerId
aSourceType
)
)
;
}
_getFilePath
:
function
(
fileName
)
{
let
dsFile
=
Cc
[
"
mozilla
.
org
/
file
/
directory_service
;
1
"
]
.
getService
(
Ci
.
nsIProperties
)
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
dsFile
.
append
(
TV_SIMULATOR_DUMMY_DIRECTORY
)
;
dsFile
.
append
(
fileName
)
;
return
dsFile
.
path
;
}
_validateSettings
:
function
(
aSettingsObject
)
{
return
this
.
_validateTuners
(
aSettingsObject
.
tuners
)
;
}
_validateTuners
:
function
(
aTunersObject
)
{
let
tunerIds
=
new
Array
(
)
;
for
(
let
tuner
of
aTunersObject
)
{
if
(
!
tuner
.
id
|
|
!
tuner
.
supportedType
|
|
!
tuner
.
supportedType
.
length
|
|
tuner
.
supportedType
.
some
(
containInvalidSourceType
)
|
|
tunerIds
.
includes
(
tuner
.
id
)
)
{
debug
(
"
invalid
tuner
data
.
"
)
;
return
false
;
}
tunerIds
.
push
(
tuner
.
id
)
;
if
(
!
this
.
_validateSources
(
tuner
.
sources
)
)
{
return
false
;
}
}
return
true
;
}
_validateSources
:
function
(
aSourcesObject
)
{
for
(
let
source
of
aSourcesObject
)
{
if
(
!
source
.
type
|
|
!
TV_SOURCE_TYPES
.
includes
(
source
.
type
)
)
{
debug
(
"
invalid
source
data
.
"
)
;
return
false
;
}
if
(
!
this
.
_validateChannels
(
source
.
channels
)
)
{
return
false
;
}
}
return
true
;
}
_validateChannels
:
function
(
aChannelsObject
)
{
let
channelNumbers
=
new
Array
(
)
;
for
(
let
channel
of
aChannelsObject
)
{
if
(
!
channel
.
networkId
|
|
!
channel
.
transportStreamId
|
|
!
channel
.
serviceId
|
|
!
channel
.
type
|
|
!
TV_CHANNEL_TYPES
.
includes
(
channel
.
type
)
|
|
!
channel
.
number
|
|
channelNumbers
.
includes
(
channel
.
number
)
|
|
!
channel
.
name
)
{
debug
(
"
invalid
channel
data
.
"
)
;
return
false
;
}
channelNumbers
.
push
(
channel
.
number
)
;
if
(
!
this
.
_validatePrograms
(
channel
.
programs
)
)
{
return
false
;
}
}
return
true
;
}
_validatePrograms
:
function
(
aProgramsObject
)
{
let
eventIds
=
new
Array
(
)
;
for
(
let
program
of
aProgramsObject
)
{
if
(
!
program
.
eventId
|
|
eventIds
.
includes
(
program
.
eventId
)
|
|
!
program
.
title
|
|
!
program
.
startTime
|
|
!
program
.
duration
)
{
debug
(
"
invalid
program
data
.
"
)
;
return
false
;
}
eventIds
.
push
(
program
.
eventId
)
;
}
return
true
;
}
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
TVSimulatorService
]
)
;
