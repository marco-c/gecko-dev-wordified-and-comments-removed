#
include
"
TemporaryFileBlobImpl
.
h
"
#
include
"
IPCBlobInputStreamThread
.
h
"
#
include
"
nsFileStreams
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
{
namespace
dom
{
namespace
{
const
uint32_t
sTemporaryFileStreamFlags
=
nsIFileInputStream
:
:
REOPEN_ON_REWIND
;
class
TemporaryFileInputStream
final
:
public
nsFileInputStream
{
public
:
static
nsresult
Create
(
nsIFile
*
aFile
nsIInputStream
*
*
aInputStream
)
{
MOZ_ASSERT
(
aFile
)
;
MOZ_ASSERT
(
aInputStream
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
RefPtr
<
TemporaryFileInputStream
>
stream
=
new
TemporaryFileInputStream
(
aFile
)
;
nsresult
rv
=
stream
-
>
Init
(
aFile
-
1
-
1
sTemporaryFileStreamFlags
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
stream
.
forget
(
aInputStream
)
;
return
NS_OK
;
}
void
Serialize
(
InputStreamParams
&
aParams
FileDescriptorArray
&
aFileDescriptors
bool
aDelayedStart
nsIContentChild
*
aManager
)
override
{
MOZ_CRASH
(
"
This
inputStream
cannot
be
serialized
.
"
)
;
}
void
Serialize
(
InputStreamParams
&
aParams
FileDescriptorArray
&
aFileDescriptors
bool
aDelayedStart
PBackgroundChild
*
aManager
)
override
{
MOZ_CRASH
(
"
This
inputStream
cannot
be
serialized
.
"
)
;
}
void
Serialize
(
InputStreamParams
&
aParams
FileDescriptorArray
&
aFileDescriptors
bool
aDelayedStart
nsIContentParent
*
aManager
)
override
{
MOZ_CRASH
(
"
This
inputStream
cannot
be
serialized
.
"
)
;
}
void
Serialize
(
InputStreamParams
&
aParams
FileDescriptorArray
&
aFileDescriptors
bool
aDelayedStart
PBackgroundParent
*
aManager
)
override
{
MOZ_CRASH
(
"
This
inputStream
cannot
be
serialized
.
"
)
;
}
bool
Deserialize
(
const
InputStreamParams
&
aParams
const
FileDescriptorArray
&
aFileDescriptors
)
override
{
MOZ_CRASH
(
"
This
inputStream
cannot
be
deserialized
.
"
)
;
return
false
;
}
private
:
explicit
TemporaryFileInputStream
(
nsIFile
*
aFile
)
:
mFile
(
aFile
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
}
~
TemporaryFileInputStream
(
)
{
RefPtr
<
IPCBlobInputStreamThread
>
thread
=
IPCBlobInputStreamThread
:
:
GetOrCreate
(
)
;
if
(
NS_WARN_IF
(
!
thread
)
)
{
return
;
}
nsCOMPtr
<
nsIFile
>
file
=
std
:
:
move
(
mFile
)
;
thread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
TemporaryFileInputStream
:
:
Runnable
"
[
file
]
(
)
{
file
-
>
Remove
(
false
)
;
}
)
)
;
}
nsCOMPtr
<
nsIFile
>
mFile
;
}
;
}
TemporaryFileBlobImpl
:
:
TemporaryFileBlobImpl
(
nsIFile
*
aFile
const
nsAString
&
aContentType
)
:
FileBlobImpl
(
aFile
EmptyString
(
)
aContentType
NS_LITERAL_STRING
(
"
TemporaryBlobImpl
"
)
)
#
ifdef
DEBUG
mInputStreamCreated
(
false
)
#
endif
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
mIsFile
=
false
;
}
TemporaryFileBlobImpl
:
:
~
TemporaryFileBlobImpl
(
)
{
MOZ_ASSERT
(
mInputStreamCreated
)
;
}
already_AddRefed
<
BlobImpl
>
TemporaryFileBlobImpl
:
:
CreateSlice
(
uint64_t
aStart
uint64_t
aLength
const
nsAString
&
aContentType
ErrorResult
&
aRv
)
{
MOZ_CRASH
(
"
This
BlobImpl
is
not
meant
to
be
sliced
!
"
)
;
return
nullptr
;
}
void
TemporaryFileBlobImpl
:
:
CreateInputStream
(
nsIInputStream
*
*
aStream
ErrorResult
&
aRv
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mInputStreamCreated
)
;
mInputStreamCreated
=
true
;
#
endif
aRv
=
TemporaryFileInputStream
:
:
Create
(
mFile
aStream
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
}
}
}
