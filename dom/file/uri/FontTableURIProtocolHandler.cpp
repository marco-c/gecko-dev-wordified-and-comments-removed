#
include
"
FontTableURIProtocolHandler
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsIUUIDGenerator
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsSimpleURI
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
nsresult
FontTableURIProtocolHandler
:
:
GenerateURIString
(
nsACString
&
aUri
)
{
nsresult
rv
;
nsCOMPtr
<
nsIUUIDGenerator
>
uuidgen
=
do_GetService
(
"
mozilla
.
org
/
uuid
-
generator
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsID
id
;
rv
=
uuidgen
-
>
GenerateUUIDInPlace
(
&
id
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
char
chars
[
NSID_LENGTH
]
;
id
.
ToProvidedString
(
chars
)
;
aUri
=
FONTTABLEURI_SCHEME
;
aUri
.
Append
(
'
:
'
)
;
aUri
+
=
Substring
(
chars
+
1
chars
+
NSID_LENGTH
-
2
)
;
return
NS_OK
;
}
FontTableURIProtocolHandler
:
:
FontTableURIProtocolHandler
(
)
=
default
;
FontTableURIProtocolHandler
:
:
~
FontTableURIProtocolHandler
(
)
=
default
;
NS_IMPL_ISUPPORTS
(
FontTableURIProtocolHandler
nsIProtocolHandler
nsISupportsWeakReference
)
NS_IMETHODIMP
FontTableURIProtocolHandler
:
:
GetDefaultPort
(
int32_t
*
result
)
{
*
result
=
-
1
;
return
NS_OK
;
}
NS_IMETHODIMP
FontTableURIProtocolHandler
:
:
GetProtocolFlags
(
uint32_t
*
result
)
{
*
result
=
URI_NORELATIVE
|
URI_NOAUTH
|
URI_LOADABLE_BY_SUBSUMERS
|
URI_NON_PERSISTABLE
|
URI_IS_LOCAL_RESOURCE
;
return
NS_OK
;
}
NS_IMETHODIMP
FontTableURIProtocolHandler
:
:
GetFlagsForURI
(
nsIURI
*
aURI
uint32_t
*
aResult
)
{
return
FontTableURIProtocolHandler
:
:
GetProtocolFlags
(
aResult
)
;
}
NS_IMETHODIMP
FontTableURIProtocolHandler
:
:
NewChannel2
(
nsIURI
*
uri
nsILoadInfo
*
aLoadInfo
nsIChannel
*
*
result
)
{
return
NS_ERROR_DOM_BAD_URI
;
}
NS_IMETHODIMP
FontTableURIProtocolHandler
:
:
NewChannel
(
nsIURI
*
uri
nsIChannel
*
*
result
)
{
return
NS_ERROR_DOM_BAD_URI
;
}
NS_IMETHODIMP
FontTableURIProtocolHandler
:
:
AllowPort
(
int32_t
port
const
char
*
scheme
bool
*
_retval
)
{
*
_retval
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
FontTableURIProtocolHandler
:
:
GetScheme
(
nsACString
&
result
)
{
result
.
AssignLiteral
(
FONTTABLEURI_SCHEME
)
;
return
NS_OK
;
}
NS_IMETHODIMP
FontTableURIProtocolHandler
:
:
NewURI
(
const
nsACString
&
aSpec
const
char
*
aCharset
nsIURI
*
aBaseURI
nsIURI
*
*
aResult
)
{
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
uri
;
if
(
aSpec
.
Length
(
)
&
&
aSpec
.
CharAt
(
0
)
=
=
'
#
'
)
{
rv
=
NS_MutateURI
(
aBaseURI
)
.
SetRef
(
aSpec
)
.
Finalize
(
uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
NS_MutateURI
(
new
mozilla
:
:
net
:
:
nsSimpleURI
:
:
Mutator
(
)
)
.
SetSpec
(
aSpec
)
.
Finalize
(
uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
bool
schemeIs
;
if
(
NS_FAILED
(
uri
-
>
SchemeIs
(
FONTTABLEURI_SCHEME
&
schemeIs
)
)
|
|
!
schemeIs
)
{
NS_WARNING
(
"
Non
-
fonttable
spec
in
FontTableURIProtocolHandler
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
uri
.
forget
(
aResult
)
;
return
NS_OK
;
}
