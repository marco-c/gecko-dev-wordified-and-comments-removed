#
ifndef
mozilla_dom_MutableBlobStorage_h
#
define
mozilla_dom_MutableBlobStorage_h
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
prio
.
h
"
class
nsIEventTarget
;
class
nsIRunnable
;
namespace
mozilla
{
class
TaskQueue
;
namespace
dom
{
class
Blob
;
class
BlobImpl
;
class
MutableBlobStorage
;
class
TemporaryIPCBlobChild
;
class
TemporaryIPCBlobChildCallback
;
class
MutableBlobStorageCallback
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
virtual
void
BlobStoreCompleted
(
MutableBlobStorage
*
aBlobStorage
BlobImpl
*
aBlob
nsresult
aRv
)
=
0
;
}
;
class
MutableBlobStorage
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
MutableBlobStorage
)
enum
MutableBlobStorageType
{
eOnlyInMemory
eCouldBeInTemporaryFile
}
;
explicit
MutableBlobStorage
(
MutableBlobStorageType
aType
nsIEventTarget
*
aEventTarget
=
nullptr
uint32_t
aMaxMemory
=
0
)
;
nsresult
Append
(
const
void
*
aData
uint32_t
aLength
)
;
void
GetBlobImplWhenReady
(
const
nsACString
&
aContentType
MutableBlobStorageCallback
*
aCallback
)
;
void
TemporaryFileCreated
(
PRFileDesc
*
aFD
)
;
void
AskForBlob
(
TemporaryIPCBlobChildCallback
*
aCallback
const
nsACString
&
aContentType
)
;
void
ErrorPropagated
(
nsresult
aRv
)
;
nsIEventTarget
*
EventTarget
(
)
{
MOZ_ASSERT
(
mEventTarget
)
;
return
mEventTarget
;
}
size_t
SizeOfCurrentMemoryBuffer
(
)
;
PRFileDesc
*
GetFD
(
)
;
void
CloseFD
(
)
;
private
:
~
MutableBlobStorage
(
)
;
bool
ExpandBufferSize
(
const
MutexAutoLock
&
aProofOfLock
uint64_t
aSize
)
;
bool
ShouldBeTemporaryStorage
(
const
MutexAutoLock
&
aProofOfLock
uint64_t
aSize
)
const
;
bool
MaybeCreateTemporaryFile
(
const
MutexAutoLock
&
aProofOfLock
)
;
void
MaybeCreateTemporaryFileOnMainThread
(
const
MutexAutoLock
&
aProofOfLock
)
;
[
[
nodiscard
]
]
nsresult
DispatchToIOThread
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
Mutex
mMutex
MOZ_UNANNOTATED
;
void
*
mData
;
uint64_t
mDataLen
;
uint64_t
mDataBufferLen
;
enum
StorageState
{
eKeepInMemory
eInMemory
eWaitingForTemporaryFile
eInTemporaryFile
eClosed
}
;
StorageState
mStorageState
;
PRFileDesc
*
mFD
;
nsresult
mErrorResult
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
nsCString
mPendingContentType
;
RefPtr
<
MutableBlobStorageCallback
>
mPendingCallback
;
RefPtr
<
TemporaryIPCBlobChild
>
mActor
;
uint32_t
mMaxMemory
;
}
;
}
}
#
endif
