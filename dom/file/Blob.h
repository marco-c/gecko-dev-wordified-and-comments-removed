#
ifndef
mozilla_dom_Blob_h
#
define
mozilla_dom_Blob_h
#
include
"
mozilla
/
dom
/
BodyConsumer
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsWeakReference
.
h
"
class
nsIGlobalObject
;
class
nsIInputStream
;
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
struct
BlobPropertyBag
;
class
BlobImpl
;
class
File
;
class
GlobalObject
;
class
OwningArrayBufferViewOrArrayBufferOrBlobOrUSVString
;
class
Promise
;
#
ifdef
MOZ_DOM_STREAMS
class
ReadableStream
;
#
endif
#
define
NS_DOM_BLOB_IID
\
{
\
0x648c2a83
0xbdb1
0x4a7d
{
\
0xb5
0x0a
0xca
0xcd
0x92
0x87
0x45
0xc2
\
}
\
}
class
Blob
:
public
nsSupportsWeakReference
public
nsWrapperCache
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS_FINAL
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
Blob
)
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_DOM_BLOB_IID
)
using
BlobPart
=
OwningArrayBufferViewOrArrayBufferOrBlobOrUSVString
;
static
Blob
*
Create
(
nsIGlobalObject
*
aGlobal
BlobImpl
*
aImpl
)
;
static
already_AddRefed
<
Blob
>
CreateStringBlob
(
nsIGlobalObject
*
aGlobal
const
nsACString
&
aData
const
nsAString
&
aContentType
)
;
static
already_AddRefed
<
Blob
>
CreateMemoryBlob
(
nsIGlobalObject
*
aGlobal
void
*
aMemoryBuffer
uint64_t
aLength
const
nsAString
&
aContentType
)
;
BlobImpl
*
Impl
(
)
const
{
return
mImpl
;
}
bool
IsFile
(
)
const
;
const
nsTArray
<
RefPtr
<
BlobImpl
>
>
*
GetSubBlobImpls
(
)
const
;
already_AddRefed
<
File
>
ToFile
(
)
;
already_AddRefed
<
File
>
ToFile
(
const
nsAString
&
aName
ErrorResult
&
aRv
)
const
;
already_AddRefed
<
Blob
>
CreateSlice
(
uint64_t
aStart
uint64_t
aLength
const
nsAString
&
aContentType
ErrorResult
&
aRv
)
;
void
CreateInputStream
(
nsIInputStream
*
*
aStream
ErrorResult
&
aRv
)
;
int64_t
GetFileId
(
)
;
static
void
MakeValidBlobType
(
nsAString
&
aType
)
;
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
mGlobal
;
}
bool
IsMemoryFile
(
)
const
;
static
already_AddRefed
<
Blob
>
Constructor
(
const
GlobalObject
&
aGlobal
const
Optional
<
Sequence
<
BlobPart
>
>
&
aData
const
BlobPropertyBag
&
aBag
ErrorResult
&
aRv
)
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
uint64_t
GetSize
(
ErrorResult
&
aRv
)
;
void
GetType
(
nsAString
&
aType
)
;
void
GetBlobImplType
(
nsAString
&
aBlobImplType
)
;
already_AddRefed
<
Blob
>
Slice
(
const
Optional
<
int64_t
>
&
aStart
const
Optional
<
int64_t
>
&
aEnd
const
Optional
<
nsAString
>
&
aContentType
ErrorResult
&
aRv
)
;
size_t
GetAllocationSize
(
)
const
;
nsresult
GetSendInfo
(
nsIInputStream
*
*
aBody
uint64_t
*
aContentLength
nsACString
&
aContentType
nsACString
&
aCharset
)
const
;
#
ifdef
MOZ_DOM_STREAMS
already_AddRefed
<
ReadableStream
>
Stream
(
ErrorResult
&
aRv
)
{
MOZ_CRASH
(
"
MOZ_DOM_STREAMS
:
NYI
"
)
;
}
#
else
void
Stream
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aStream
ErrorResult
&
aRv
)
;
#
endif
already_AddRefed
<
Promise
>
Text
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
ArrayBuffer
(
ErrorResult
&
aRv
)
;
protected
:
Blob
(
nsIGlobalObject
*
aGlobal
BlobImpl
*
aImpl
)
;
virtual
~
Blob
(
)
;
virtual
bool
HasFileInterface
(
)
const
{
return
false
;
}
already_AddRefed
<
Promise
>
ConsumeBody
(
BodyConsumer
:
:
ConsumeType
aConsumeType
ErrorResult
&
aRv
)
;
RefPtr
<
BlobImpl
>
mImpl
;
private
:
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
Blob
NS_DOM_BLOB_IID
)
size_t
BindingJSObjectMallocBytes
(
Blob
*
aBlob
)
;
}
}
inline
nsISupports
*
ToSupports
(
mozilla
:
:
dom
:
:
Blob
*
aBlob
)
{
return
static_cast
<
nsISupportsWeakReference
*
>
(
aBlob
)
;
}
#
endif
