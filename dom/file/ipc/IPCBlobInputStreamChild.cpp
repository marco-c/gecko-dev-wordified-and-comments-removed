#
include
"
IPCBlobInputStreamChild
.
h
"
#
include
"
WorkerHolder
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
class
ShutdownRunnable
final
:
public
CancelableRunnable
{
public
:
explicit
ShutdownRunnable
(
IPCBlobInputStreamChild
*
aActor
)
:
mActor
(
aActor
)
{
}
NS_IMETHOD
Run
(
)
override
{
mActor
-
>
Shutdown
(
)
;
return
NS_OK
;
}
private
:
RefPtr
<
IPCBlobInputStreamChild
>
mActor
;
}
;
class
StreamNeededRunnable
final
:
public
CancelableRunnable
{
public
:
explicit
StreamNeededRunnable
(
IPCBlobInputStreamChild
*
aActor
)
:
mActor
(
aActor
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mActor
-
>
IsAlive
(
)
)
{
mActor
-
>
SendStreamNeeded
(
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
IPCBlobInputStreamChild
>
mActor
;
}
;
class
StreamReadyRunnable
final
:
public
CancelableRunnable
{
public
:
StreamReadyRunnable
(
IPCBlobInputStream
*
aDestinationStream
nsIInputStream
*
aCreatedStream
)
:
mDestinationStream
(
aDestinationStream
)
mCreatedStream
(
aCreatedStream
)
{
MOZ_ASSERT
(
mDestinationStream
)
;
}
NS_IMETHOD
Run
(
)
override
{
mDestinationStream
-
>
StreamReady
(
mCreatedStream
)
;
return
NS_OK
;
}
private
:
RefPtr
<
IPCBlobInputStream
>
mDestinationStream
;
nsCOMPtr
<
nsIInputStream
>
mCreatedStream
;
}
;
class
IPCBlobInputStreamWorkerHolder
final
:
public
WorkerHolder
{
public
:
explicit
IPCBlobInputStreamWorkerHolder
(
IPCBlobInputStreamChild
*
aActor
)
:
mActor
(
aActor
)
{
}
bool
Notify
(
Status
aStatus
)
override
{
if
(
aStatus
>
Running
)
{
mActor
-
>
Shutdown
(
)
;
}
return
true
;
}
private
:
RefPtr
<
IPCBlobInputStreamChild
>
mActor
;
}
;
}
IPCBlobInputStreamChild
:
:
IPCBlobInputStreamChild
(
const
nsID
&
aID
uint64_t
aSize
)
:
mMutex
(
"
IPCBlobInputStreamChild
:
:
mMutex
"
)
mID
(
aID
)
mSize
(
aSize
)
mActorAlive
(
true
)
mOwningThread
(
NS_GetCurrentThread
(
)
)
{
if
(
!
NS_IsMainThread
(
)
)
{
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
if
(
workerPrivate
)
{
UniquePtr
<
WorkerHolder
>
workerHolder
(
new
IPCBlobInputStreamWorkerHolder
(
this
)
)
;
if
(
workerHolder
-
>
HoldWorker
(
workerPrivate
Canceling
)
)
{
mWorkerHolder
.
swap
(
workerHolder
)
;
}
}
}
}
IPCBlobInputStreamChild
:
:
~
IPCBlobInputStreamChild
(
)
{
}
void
IPCBlobInputStreamChild
:
:
Shutdown
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
RefPtr
<
IPCBlobInputStreamChild
>
kungFuDeathGrip
=
this
;
mWorkerHolder
=
nullptr
;
mPendingOperations
.
Clear
(
)
;
if
(
mActorAlive
)
{
SendClose
(
)
;
mActorAlive
=
false
;
}
}
void
IPCBlobInputStreamChild
:
:
ActorDestroy
(
IProtocol
:
:
ActorDestroyReason
aReason
)
{
{
MutexAutoLock
lock
(
mMutex
)
;
mActorAlive
=
false
;
}
Shutdown
(
)
;
}
bool
IPCBlobInputStreamChild
:
:
IsAlive
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mActorAlive
;
}
already_AddRefed
<
nsIInputStream
>
IPCBlobInputStreamChild
:
:
CreateStream
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mActorAlive
)
{
return
nullptr
;
}
RefPtr
<
IPCBlobInputStream
>
stream
=
new
IPCBlobInputStream
(
this
)
;
mStreams
.
AppendElement
(
stream
)
;
return
stream
.
forget
(
)
;
}
void
IPCBlobInputStreamChild
:
:
ForgetStream
(
IPCBlobInputStream
*
aStream
)
{
MOZ_ASSERT
(
aStream
)
;
RefPtr
<
IPCBlobInputStreamChild
>
kungFuDeathGrip
=
this
;
{
MutexAutoLock
lock
(
mMutex
)
;
mStreams
.
RemoveElement
(
aStream
)
;
if
(
!
mStreams
.
IsEmpty
(
)
|
|
!
mActorAlive
)
{
return
;
}
}
if
(
mOwningThread
=
=
NS_GetCurrentThread
(
)
)
{
Shutdown
(
)
;
return
;
}
RefPtr
<
ShutdownRunnable
>
runnable
=
new
ShutdownRunnable
(
this
)
;
mOwningThread
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
void
IPCBlobInputStreamChild
:
:
StreamNeeded
(
IPCBlobInputStream
*
aStream
nsIEventTarget
*
aEventTarget
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mActorAlive
)
{
return
;
}
MOZ_ASSERT
(
mStreams
.
Contains
(
aStream
)
)
;
PendingOperation
*
opt
=
mPendingOperations
.
AppendElement
(
)
;
opt
-
>
mStream
=
aStream
;
opt
-
>
mEventTarget
=
aEventTarget
?
aEventTarget
:
NS_GetCurrentThread
(
)
;
if
(
mOwningThread
=
=
NS_GetCurrentThread
(
)
)
{
SendStreamNeeded
(
)
;
return
;
}
RefPtr
<
StreamNeededRunnable
>
runnable
=
new
StreamNeededRunnable
(
this
)
;
mOwningThread
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
IPCBlobInputStreamChild
:
:
RecvStreamReady
(
const
OptionalIPCStream
&
aStream
)
{
nsCOMPtr
<
nsIInputStream
>
stream
=
DeserializeIPCStream
(
aStream
)
;
RefPtr
<
IPCBlobInputStream
>
pendingStream
;
nsCOMPtr
<
nsIEventTarget
>
eventTarget
;
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
!
mPendingOperations
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mActorAlive
)
;
pendingStream
=
mPendingOperations
[
0
]
.
mStream
;
eventTarget
=
mPendingOperations
[
0
]
.
mEventTarget
;
mPendingOperations
.
RemoveElementAt
(
0
)
;
}
RefPtr
<
StreamReadyRunnable
>
runnable
=
new
StreamReadyRunnable
(
pendingStream
stream
)
;
eventTarget
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
return
IPC_OK
(
)
;
}
}
}
