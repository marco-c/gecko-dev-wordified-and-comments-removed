#
include
"
IPCBlobInputStreamChild
.
h
"
#
include
"
IPCBlobInputStreamThread
.
h
"
#
include
"
mozilla
/
ipc
/
IPCStreamUtils
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRef
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
class
ShutdownRunnable
final
:
public
CancelableRunnable
{
public
:
explicit
ShutdownRunnable
(
IPCBlobInputStreamChild
*
aActor
)
:
CancelableRunnable
(
"
dom
:
:
ShutdownRunnable
"
)
mActor
(
aActor
)
{
}
NS_IMETHOD
Run
(
)
override
{
mActor
-
>
Shutdown
(
)
;
return
NS_OK
;
}
private
:
RefPtr
<
IPCBlobInputStreamChild
>
mActor
;
}
;
class
StreamNeededRunnable
final
:
public
CancelableRunnable
{
public
:
explicit
StreamNeededRunnable
(
IPCBlobInputStreamChild
*
aActor
)
:
CancelableRunnable
(
"
dom
:
:
StreamNeededRunnable
"
)
mActor
(
aActor
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
mActor
-
>
State
(
)
!
=
IPCBlobInputStreamChild
:
:
eActiveMigrating
&
&
mActor
-
>
State
(
)
!
=
IPCBlobInputStreamChild
:
:
eInactiveMigrating
)
;
if
(
mActor
-
>
State
(
)
=
=
IPCBlobInputStreamChild
:
:
eActive
)
{
mActor
-
>
SendStreamNeeded
(
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
IPCBlobInputStreamChild
>
mActor
;
}
;
class
StreamReadyRunnable
final
:
public
CancelableRunnable
{
public
:
StreamReadyRunnable
(
IPCBlobInputStream
*
aDestinationStream
already_AddRefed
<
nsIInputStream
>
aCreatedStream
)
:
CancelableRunnable
(
"
dom
:
:
StreamReadyRunnable
"
)
mDestinationStream
(
aDestinationStream
)
mCreatedStream
(
Move
(
aCreatedStream
)
)
{
MOZ_ASSERT
(
mDestinationStream
)
;
}
NS_IMETHOD
Run
(
)
override
{
mDestinationStream
-
>
StreamReady
(
mCreatedStream
.
forget
(
)
)
;
return
NS_OK
;
}
private
:
RefPtr
<
IPCBlobInputStream
>
mDestinationStream
;
nsCOMPtr
<
nsIInputStream
>
mCreatedStream
;
}
;
class
LengthNeededRunnable
final
:
public
CancelableRunnable
{
public
:
explicit
LengthNeededRunnable
(
IPCBlobInputStreamChild
*
aActor
)
:
CancelableRunnable
(
"
dom
:
:
LengthNeededRunnable
"
)
mActor
(
aActor
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
mActor
-
>
State
(
)
!
=
IPCBlobInputStreamChild
:
:
eActiveMigrating
&
&
mActor
-
>
State
(
)
!
=
IPCBlobInputStreamChild
:
:
eInactiveMigrating
)
;
if
(
mActor
-
>
State
(
)
=
=
IPCBlobInputStreamChild
:
:
eActive
)
{
mActor
-
>
SendLengthNeeded
(
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
IPCBlobInputStreamChild
>
mActor
;
}
;
class
LengthReadyRunnable
final
:
public
CancelableRunnable
{
public
:
LengthReadyRunnable
(
IPCBlobInputStream
*
aDestinationStream
int64_t
aSize
)
:
CancelableRunnable
(
"
dom
:
:
LengthReadyRunnable
"
)
mDestinationStream
(
aDestinationStream
)
mSize
(
aSize
)
{
MOZ_ASSERT
(
mDestinationStream
)
;
}
NS_IMETHOD
Run
(
)
override
{
mDestinationStream
-
>
LengthReady
(
mSize
)
;
return
NS_OK
;
}
private
:
RefPtr
<
IPCBlobInputStream
>
mDestinationStream
;
int64_t
mSize
;
}
;
}
IPCBlobInputStreamChild
:
:
IPCBlobInputStreamChild
(
const
nsID
&
aID
uint64_t
aSize
)
:
mMutex
(
"
IPCBlobInputStreamChild
:
:
mMutex
"
)
mID
(
aID
)
mSize
(
aSize
)
mState
(
eActive
)
mOwningEventTarget
(
GetCurrentThreadSerialEventTarget
(
)
)
{
if
(
!
NS_IsMainThread
(
)
)
{
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
if
(
!
workerPrivate
)
{
return
;
}
RefPtr
<
StrongWorkerRef
>
workerRef
=
StrongWorkerRef
:
:
Create
(
workerPrivate
"
IPCBlobInputStreamChild
"
)
;
if
(
!
workerRef
)
{
return
;
}
mWorkerRef
=
new
ThreadSafeWorkerRef
(
workerRef
)
;
}
}
IPCBlobInputStreamChild
:
:
~
IPCBlobInputStreamChild
(
)
{
}
void
IPCBlobInputStreamChild
:
:
Shutdown
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
RefPtr
<
IPCBlobInputStreamChild
>
kungFuDeathGrip
=
this
;
mWorkerRef
=
nullptr
;
mPendingOperations
.
Clear
(
)
;
if
(
mState
=
=
eActive
)
{
SendClose
(
)
;
mState
=
eInactive
;
}
}
void
IPCBlobInputStreamChild
:
:
ActorDestroy
(
IProtocol
:
:
ActorDestroyReason
aReason
)
{
bool
migrating
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
migrating
=
mState
=
=
eActiveMigrating
;
mState
=
migrating
?
eInactiveMigrating
:
eInactive
;
}
if
(
migrating
)
{
RefPtr
<
IPCBlobInputStreamThread
>
thread
=
IPCBlobInputStreamThread
:
:
GetOrCreate
(
)
;
MOZ_ASSERT
(
thread
"
We
cannot
continue
without
DOMFile
thread
.
"
)
;
ResetManager
(
)
;
thread
-
>
MigrateActor
(
this
)
;
return
;
}
Shutdown
(
)
;
}
IPCBlobInputStreamChild
:
:
ActorState
IPCBlobInputStreamChild
:
:
State
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mState
;
}
already_AddRefed
<
IPCBlobInputStream
>
IPCBlobInputStreamChild
:
:
CreateStream
(
)
{
bool
shouldMigrate
=
false
;
RefPtr
<
IPCBlobInputStream
>
stream
=
new
IPCBlobInputStream
(
this
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mState
=
=
eInactive
)
{
return
nullptr
;
}
if
(
mState
=
=
eActive
&
&
!
IPCBlobInputStreamThread
:
:
IsOnFileEventTarget
(
mOwningEventTarget
)
)
{
MOZ_ASSERT
(
mStreams
.
IsEmpty
(
)
)
;
shouldMigrate
=
true
;
mState
=
eActiveMigrating
;
}
mStreams
.
AppendElement
(
stream
)
;
}
if
(
shouldMigrate
)
{
Send__delete__
(
this
)
;
}
return
stream
.
forget
(
)
;
}
void
IPCBlobInputStreamChild
:
:
ForgetStream
(
IPCBlobInputStream
*
aStream
)
{
MOZ_ASSERT
(
aStream
)
;
RefPtr
<
IPCBlobInputStreamChild
>
kungFuDeathGrip
=
this
;
{
MutexAutoLock
lock
(
mMutex
)
;
mStreams
.
RemoveElement
(
aStream
)
;
if
(
!
mStreams
.
IsEmpty
(
)
|
|
mState
!
=
eActive
)
{
return
;
}
}
if
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
{
Shutdown
(
)
;
return
;
}
RefPtr
<
ShutdownRunnable
>
runnable
=
new
ShutdownRunnable
(
this
)
;
mOwningEventTarget
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
void
IPCBlobInputStreamChild
:
:
StreamNeeded
(
IPCBlobInputStream
*
aStream
nsIEventTarget
*
aEventTarget
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mState
=
=
eInactive
)
{
return
;
}
MOZ_ASSERT
(
mStreams
.
Contains
(
aStream
)
)
;
PendingOperation
*
opt
=
mPendingOperations
.
AppendElement
(
)
;
opt
-
>
mStream
=
aStream
;
opt
-
>
mEventTarget
=
aEventTarget
;
opt
-
>
mOp
=
PendingOperation
:
:
eStreamNeeded
;
if
(
mState
=
=
eActiveMigrating
|
|
mState
=
=
eInactiveMigrating
)
{
return
;
}
MOZ_ASSERT
(
mState
=
=
eActive
)
;
if
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
{
SendStreamNeeded
(
)
;
return
;
}
RefPtr
<
StreamNeededRunnable
>
runnable
=
new
StreamNeededRunnable
(
this
)
;
mOwningEventTarget
-
>
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
IPCBlobInputStreamChild
:
:
RecvStreamReady
(
const
OptionalIPCStream
&
aStream
)
{
nsCOMPtr
<
nsIInputStream
>
stream
=
mozilla
:
:
ipc
:
:
DeserializeIPCStream
(
aStream
)
;
RefPtr
<
IPCBlobInputStream
>
pendingStream
;
nsCOMPtr
<
nsIEventTarget
>
eventTarget
;
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
!
mPendingOperations
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mState
=
=
eActive
)
;
pendingStream
=
mPendingOperations
[
0
]
.
mStream
;
eventTarget
=
mPendingOperations
[
0
]
.
mEventTarget
;
MOZ_ASSERT
(
mPendingOperations
[
0
]
.
mOp
=
=
PendingOperation
:
:
eStreamNeeded
)
;
mPendingOperations
.
RemoveElementAt
(
0
)
;
}
RefPtr
<
StreamReadyRunnable
>
runnable
=
new
StreamReadyRunnable
(
pendingStream
stream
.
forget
(
)
)
;
if
(
eventTarget
)
{
eventTarget
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
else
{
runnable
-
>
Run
(
)
;
}
return
IPC_OK
(
)
;
}
void
IPCBlobInputStreamChild
:
:
LengthNeeded
(
IPCBlobInputStream
*
aStream
nsIEventTarget
*
aEventTarget
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mState
=
=
eInactive
)
{
return
;
}
MOZ_ASSERT
(
mStreams
.
Contains
(
aStream
)
)
;
PendingOperation
*
opt
=
mPendingOperations
.
AppendElement
(
)
;
opt
-
>
mStream
=
aStream
;
opt
-
>
mEventTarget
=
aEventTarget
;
opt
-
>
mOp
=
PendingOperation
:
:
eLengthNeeded
;
if
(
mState
=
=
eActiveMigrating
|
|
mState
=
=
eInactiveMigrating
)
{
return
;
}
MOZ_ASSERT
(
mState
=
=
eActive
)
;
if
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
{
SendLengthNeeded
(
)
;
return
;
}
RefPtr
<
LengthNeededRunnable
>
runnable
=
new
LengthNeededRunnable
(
this
)
;
mOwningEventTarget
-
>
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
IPCBlobInputStreamChild
:
:
RecvLengthReady
(
const
int64_t
&
aLength
)
{
RefPtr
<
IPCBlobInputStream
>
pendingStream
;
nsCOMPtr
<
nsIEventTarget
>
eventTarget
;
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
!
mPendingOperations
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mState
=
=
eActive
)
;
pendingStream
=
mPendingOperations
[
0
]
.
mStream
;
eventTarget
=
mPendingOperations
[
0
]
.
mEventTarget
;
MOZ_ASSERT
(
mPendingOperations
[
0
]
.
mOp
=
=
PendingOperation
:
:
eLengthNeeded
)
;
mPendingOperations
.
RemoveElementAt
(
0
)
;
}
RefPtr
<
LengthReadyRunnable
>
runnable
=
new
LengthReadyRunnable
(
pendingStream
aLength
)
;
MOZ_ASSERT
(
eventTarget
)
;
eventTarget
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
return
IPC_OK
(
)
;
}
void
IPCBlobInputStreamChild
:
:
Migrated
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mState
=
=
eInactiveMigrating
)
;
mWorkerRef
=
nullptr
;
mOwningEventTarget
=
GetCurrentThreadSerialEventTarget
(
)
;
MOZ_ASSERT
(
IPCBlobInputStreamThread
:
:
IsOnFileEventTarget
(
mOwningEventTarget
)
)
;
if
(
mStreams
.
IsEmpty
(
)
)
{
mState
=
eInactive
;
SendClose
(
)
;
return
;
}
mState
=
eActive
;
for
(
uint32_t
i
=
0
;
i
<
mPendingOperations
.
Length
(
)
;
+
+
i
)
{
if
(
mPendingOperations
[
i
]
.
mOp
=
=
PendingOperation
:
:
eStreamNeeded
)
{
SendStreamNeeded
(
)
;
}
else
{
MOZ_ASSERT
(
mPendingOperations
[
i
]
.
mOp
=
=
PendingOperation
:
:
eLengthNeeded
)
;
SendLengthNeeded
(
)
;
}
}
}
}
}
