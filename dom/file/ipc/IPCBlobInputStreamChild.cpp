#
include
"
IPCBlobInputStreamChild
.
h
"
#
include
"
IPCBlobInputStreamThread
.
h
"
#
include
"
mozilla
/
ipc
/
IPCStreamUtils
.
h
"
#
include
"
mozilla
/
dom
/
WorkerHolder
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRunnable
.
h
"
namespace
mozilla
{
namespace
dom
{
using
namespace
workers
;
namespace
{
class
ShutdownRunnable
final
:
public
CancelableRunnable
{
public
:
explicit
ShutdownRunnable
(
IPCBlobInputStreamChild
*
aActor
)
:
CancelableRunnable
(
"
dom
:
:
ShutdownRunnable
"
)
mActor
(
aActor
)
{
}
NS_IMETHOD
Run
(
)
override
{
mActor
-
>
Shutdown
(
)
;
return
NS_OK
;
}
private
:
RefPtr
<
IPCBlobInputStreamChild
>
mActor
;
}
;
class
StreamNeededRunnable
final
:
public
CancelableRunnable
{
public
:
explicit
StreamNeededRunnable
(
IPCBlobInputStreamChild
*
aActor
)
:
CancelableRunnable
(
"
dom
:
:
StreamNeededRunnable
"
)
mActor
(
aActor
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
mActor
-
>
State
(
)
!
=
IPCBlobInputStreamChild
:
:
eActiveMigrating
&
&
mActor
-
>
State
(
)
!
=
IPCBlobInputStreamChild
:
:
eInactiveMigrating
)
;
if
(
mActor
-
>
State
(
)
=
=
IPCBlobInputStreamChild
:
:
eActive
)
{
mActor
-
>
SendStreamNeeded
(
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
IPCBlobInputStreamChild
>
mActor
;
}
;
class
StreamReadyRunnable
final
:
public
CancelableRunnable
{
public
:
StreamReadyRunnable
(
IPCBlobInputStream
*
aDestinationStream
already_AddRefed
<
nsIInputStream
>
aCreatedStream
)
:
CancelableRunnable
(
"
dom
:
:
StreamReadyRunnable
"
)
mDestinationStream
(
aDestinationStream
)
mCreatedStream
(
Move
(
aCreatedStream
)
)
{
MOZ_ASSERT
(
mDestinationStream
)
;
}
NS_IMETHOD
Run
(
)
override
{
mDestinationStream
-
>
StreamReady
(
mCreatedStream
.
forget
(
)
)
;
return
NS_OK
;
}
private
:
RefPtr
<
IPCBlobInputStream
>
mDestinationStream
;
nsCOMPtr
<
nsIInputStream
>
mCreatedStream
;
}
;
class
IPCBlobInputStreamWorkerHolder
final
:
public
WorkerHolder
{
public
:
IPCBlobInputStreamWorkerHolder
(
)
:
WorkerHolder
(
"
IPCBlobInputStreamWorkerHolder
"
)
{
}
bool
Notify
(
WorkerStatus
aStatus
)
override
{
return
true
;
}
}
;
class
ReleaseWorkerHolderRunnable
final
:
public
CancelableRunnable
{
public
:
explicit
ReleaseWorkerHolderRunnable
(
UniquePtr
<
WorkerHolder
>
&
&
aWorkerHolder
)
:
CancelableRunnable
(
"
dom
:
:
ReleaseWorkerHolderRunnable
"
)
mWorkerHolder
(
Move
(
aWorkerHolder
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
mWorkerHolder
=
nullptr
;
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
return
Run
(
)
;
}
private
:
UniquePtr
<
WorkerHolder
>
mWorkerHolder
;
}
;
}
IPCBlobInputStreamChild
:
:
IPCBlobInputStreamChild
(
const
nsID
&
aID
uint64_t
aSize
)
:
mMutex
(
"
IPCBlobInputStreamChild
:
:
mMutex
"
)
mID
(
aID
)
mSize
(
aSize
)
mState
(
eActive
)
mOwningEventTarget
(
GetCurrentThreadSerialEventTarget
(
)
)
{
if
(
!
NS_IsMainThread
(
)
)
{
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
if
(
workerPrivate
)
{
UniquePtr
<
WorkerHolder
>
workerHolder
(
new
IPCBlobInputStreamWorkerHolder
(
)
)
;
if
(
workerHolder
-
>
HoldWorker
(
workerPrivate
Canceling
)
)
{
mWorkerHolder
.
swap
(
workerHolder
)
;
}
}
}
}
IPCBlobInputStreamChild
:
:
~
IPCBlobInputStreamChild
(
)
{
}
void
IPCBlobInputStreamChild
:
:
Shutdown
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
RefPtr
<
IPCBlobInputStreamChild
>
kungFuDeathGrip
=
this
;
mWorkerHolder
=
nullptr
;
mPendingOperations
.
Clear
(
)
;
if
(
mState
=
=
eActive
)
{
SendClose
(
)
;
mState
=
eInactive
;
}
}
void
IPCBlobInputStreamChild
:
:
ActorDestroy
(
IProtocol
:
:
ActorDestroyReason
aReason
)
{
bool
migrating
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
migrating
=
mState
=
=
eActiveMigrating
;
mState
=
migrating
?
eInactiveMigrating
:
eInactive
;
}
if
(
migrating
)
{
RefPtr
<
IPCBlobInputStreamThread
>
thread
=
IPCBlobInputStreamThread
:
:
GetOrCreate
(
)
;
MOZ_ASSERT
(
thread
"
We
cannot
continue
without
DOMFile
thread
.
"
)
;
ResetManager
(
)
;
thread
-
>
MigrateActor
(
this
)
;
return
;
}
Shutdown
(
)
;
}
IPCBlobInputStreamChild
:
:
ActorState
IPCBlobInputStreamChild
:
:
State
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mState
;
}
already_AddRefed
<
IPCBlobInputStream
>
IPCBlobInputStreamChild
:
:
CreateStream
(
)
{
bool
shouldMigrate
=
false
;
RefPtr
<
IPCBlobInputStream
>
stream
=
new
IPCBlobInputStream
(
this
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mState
=
=
eInactive
)
{
return
nullptr
;
}
if
(
mState
=
=
eActive
&
&
!
IPCBlobInputStreamThread
:
:
IsOnFileEventTarget
(
mOwningEventTarget
)
)
{
MOZ_ASSERT
(
mStreams
.
IsEmpty
(
)
)
;
shouldMigrate
=
true
;
mState
=
eActiveMigrating
;
}
mStreams
.
AppendElement
(
stream
)
;
}
if
(
shouldMigrate
)
{
Send__delete__
(
this
)
;
}
return
stream
.
forget
(
)
;
}
void
IPCBlobInputStreamChild
:
:
ForgetStream
(
IPCBlobInputStream
*
aStream
)
{
MOZ_ASSERT
(
aStream
)
;
RefPtr
<
IPCBlobInputStreamChild
>
kungFuDeathGrip
=
this
;
{
MutexAutoLock
lock
(
mMutex
)
;
mStreams
.
RemoveElement
(
aStream
)
;
if
(
!
mStreams
.
IsEmpty
(
)
|
|
mState
!
=
eActive
)
{
return
;
}
}
if
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
{
Shutdown
(
)
;
return
;
}
RefPtr
<
ShutdownRunnable
>
runnable
=
new
ShutdownRunnable
(
this
)
;
mOwningEventTarget
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
void
IPCBlobInputStreamChild
:
:
StreamNeeded
(
IPCBlobInputStream
*
aStream
nsIEventTarget
*
aEventTarget
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mState
=
=
eInactive
)
{
return
;
}
MOZ_ASSERT
(
mStreams
.
Contains
(
aStream
)
)
;
PendingOperation
*
opt
=
mPendingOperations
.
AppendElement
(
)
;
opt
-
>
mStream
=
aStream
;
opt
-
>
mEventTarget
=
aEventTarget
;
if
(
mState
=
=
eActiveMigrating
|
|
mState
=
=
eInactiveMigrating
)
{
return
;
}
MOZ_ASSERT
(
mState
=
=
eActive
)
;
if
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
{
SendStreamNeeded
(
)
;
return
;
}
RefPtr
<
StreamNeededRunnable
>
runnable
=
new
StreamNeededRunnable
(
this
)
;
mOwningEventTarget
-
>
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
IPCBlobInputStreamChild
:
:
RecvStreamReady
(
const
OptionalIPCStream
&
aStream
)
{
nsCOMPtr
<
nsIInputStream
>
stream
=
mozilla
:
:
ipc
:
:
DeserializeIPCStream
(
aStream
)
;
RefPtr
<
IPCBlobInputStream
>
pendingStream
;
nsCOMPtr
<
nsIEventTarget
>
eventTarget
;
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
!
mPendingOperations
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mState
=
=
eActive
)
;
pendingStream
=
mPendingOperations
[
0
]
.
mStream
;
eventTarget
=
mPendingOperations
[
0
]
.
mEventTarget
;
mPendingOperations
.
RemoveElementAt
(
0
)
;
}
RefPtr
<
StreamReadyRunnable
>
runnable
=
new
StreamReadyRunnable
(
pendingStream
stream
.
forget
(
)
)
;
if
(
eventTarget
)
{
eventTarget
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
else
{
runnable
-
>
Run
(
)
;
}
return
IPC_OK
(
)
;
}
void
IPCBlobInputStreamChild
:
:
Migrated
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mState
=
=
eInactiveMigrating
)
;
if
(
mWorkerHolder
)
{
RefPtr
<
ReleaseWorkerHolderRunnable
>
runnable
=
new
ReleaseWorkerHolderRunnable
(
Move
(
mWorkerHolder
)
)
;
mOwningEventTarget
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
mOwningEventTarget
=
GetCurrentThreadSerialEventTarget
(
)
;
MOZ_ASSERT
(
IPCBlobInputStreamThread
:
:
IsOnFileEventTarget
(
mOwningEventTarget
)
)
;
if
(
mStreams
.
IsEmpty
(
)
)
{
mState
=
eInactive
;
SendClose
(
)
;
return
;
}
mState
=
eActive
;
for
(
uint32_t
i
=
0
;
i
<
mPendingOperations
.
Length
(
)
;
+
+
i
)
{
SendStreamNeeded
(
)
;
}
}
}
}
