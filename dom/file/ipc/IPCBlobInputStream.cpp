#
include
"
IPCBlobInputStream
.
h
"
#
include
"
IPCBlobInputStreamChild
.
h
"
#
include
"
IPCBlobInputStreamStorage
.
h
"
#
include
"
mozilla
/
ipc
/
InputStreamParams
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsIStreamTransportService
.
h
"
#
include
"
nsITransport
.
h
"
#
include
"
nsNetCID
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
static
NS_DEFINE_CID
(
kStreamTransportServiceCID
NS_STREAMTRANSPORTSERVICE_CID
)
;
class
InputStreamCallbackRunnable
final
:
public
CancelableRunnable
{
public
:
static
void
Execute
(
nsIInputStreamCallback
*
aCallback
nsIEventTarget
*
aEventTarget
IPCBlobInputStream
*
aStream
)
{
RefPtr
<
InputStreamCallbackRunnable
>
runnable
=
new
InputStreamCallbackRunnable
(
aCallback
aStream
)
;
nsCOMPtr
<
nsIEventTarget
>
target
=
aEventTarget
;
if
(
!
target
)
{
target
=
NS_GetCurrentThread
(
)
;
}
target
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHOD
Run
(
)
override
{
mCallback
-
>
OnInputStreamReady
(
mStream
)
;
mCallback
=
nullptr
;
mStream
=
nullptr
;
return
NS_OK
;
}
private
:
InputStreamCallbackRunnable
(
nsIInputStreamCallback
*
aCallback
IPCBlobInputStream
*
aStream
)
:
CancelableRunnable
(
"
dom
:
:
InputStreamCallbackRunnable
"
)
mCallback
(
aCallback
)
mStream
(
aStream
)
{
MOZ_ASSERT
(
mCallback
)
;
MOZ_ASSERT
(
mStream
)
;
}
nsCOMPtr
<
nsIInputStreamCallback
>
mCallback
;
RefPtr
<
IPCBlobInputStream
>
mStream
;
}
;
class
FileMetadataCallbackRunnable
final
:
public
CancelableRunnable
{
public
:
static
void
Execute
(
nsIFileMetadataCallback
*
aCallback
nsIEventTarget
*
aEventTarget
IPCBlobInputStream
*
aStream
)
{
RefPtr
<
FileMetadataCallbackRunnable
>
runnable
=
new
FileMetadataCallbackRunnable
(
aCallback
aStream
)
;
nsCOMPtr
<
nsIEventTarget
>
target
=
aEventTarget
;
if
(
!
target
)
{
target
=
NS_GetCurrentThread
(
)
;
}
target
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHOD
Run
(
)
override
{
mCallback
-
>
OnFileMetadataReady
(
mStream
)
;
mCallback
=
nullptr
;
mStream
=
nullptr
;
return
NS_OK
;
}
private
:
FileMetadataCallbackRunnable
(
nsIFileMetadataCallback
*
aCallback
IPCBlobInputStream
*
aStream
)
:
CancelableRunnable
(
"
dom
:
:
FileMetadataCallbackRunnable
"
)
mCallback
(
aCallback
)
mStream
(
aStream
)
{
MOZ_ASSERT
(
mCallback
)
;
MOZ_ASSERT
(
mStream
)
;
}
nsCOMPtr
<
nsIFileMetadataCallback
>
mCallback
;
RefPtr
<
IPCBlobInputStream
>
mStream
;
}
;
}
NS_IMPL_ADDREF
(
IPCBlobInputStream
)
;
NS_IMPL_RELEASE
(
IPCBlobInputStream
)
;
NS_INTERFACE_MAP_BEGIN
(
IPCBlobInputStream
)
NS_INTERFACE_MAP_ENTRY
(
nsIInputStream
)
NS_INTERFACE_MAP_ENTRY
(
nsIAsyncInputStream
)
NS_INTERFACE_MAP_ENTRY
(
nsIInputStreamCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsICloneableInputStream
)
NS_INTERFACE_MAP_ENTRY
(
nsIIPCSerializableInputStream
)
NS_INTERFACE_MAP_ENTRY
(
nsIFileMetadata
)
NS_INTERFACE_MAP_ENTRY
(
nsIAsyncFileMetadata
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIInputStream
)
NS_INTERFACE_MAP_END
IPCBlobInputStream
:
:
IPCBlobInputStream
(
IPCBlobInputStreamChild
*
aActor
)
:
mActor
(
aActor
)
mState
(
eInit
)
{
MOZ_ASSERT
(
aActor
)
;
if
(
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsIInputStream
>
stream
;
IPCBlobInputStreamStorage
:
:
Get
(
)
-
>
GetStream
(
mActor
-
>
ID
(
)
getter_AddRefs
(
stream
)
)
;
if
(
stream
)
{
mState
=
eRunning
;
mRemoteStream
=
stream
;
}
}
}
IPCBlobInputStream
:
:
~
IPCBlobInputStream
(
)
{
Close
(
)
;
}
NS_IMETHODIMP
IPCBlobInputStream
:
:
Available
(
uint64_t
*
aLength
)
{
if
(
mState
=
=
eInit
|
|
mState
=
=
ePending
)
{
*
aLength
=
mActor
-
>
Size
(
)
;
return
NS_OK
;
}
if
(
mState
=
=
eRunning
)
{
MOZ_ASSERT
(
mRemoteStream
|
|
mAsyncRemoteStream
)
;
if
(
!
mAsyncRemoteStream
)
{
*
aLength
=
mActor
-
>
Size
(
)
;
return
NS_OK
;
}
nsresult
rv
=
EnsureAsyncRemoteStream
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
mAsyncRemoteStream
)
;
return
mAsyncRemoteStream
-
>
Available
(
aLength
)
;
}
MOZ_ASSERT
(
mState
=
=
eClosed
)
;
return
NS_BASE_STREAM_CLOSED
;
}
NS_IMETHODIMP
IPCBlobInputStream
:
:
Read
(
char
*
aBuffer
uint32_t
aCount
uint32_t
*
aReadCount
)
{
if
(
mState
=
=
eInit
|
|
mState
=
=
ePending
)
{
return
NS_BASE_STREAM_WOULD_BLOCK
;
}
if
(
mState
=
=
eRunning
)
{
MOZ_ASSERT
(
mRemoteStream
|
|
mAsyncRemoteStream
)
;
nsresult
rv
=
EnsureAsyncRemoteStream
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
mAsyncRemoteStream
)
;
return
mAsyncRemoteStream
-
>
Read
(
aBuffer
aCount
aReadCount
)
;
}
MOZ_ASSERT
(
mState
=
=
eClosed
)
;
return
NS_BASE_STREAM_CLOSED
;
}
NS_IMETHODIMP
IPCBlobInputStream
:
:
ReadSegments
(
nsWriteSegmentFun
aWriter
void
*
aClosure
uint32_t
aCount
uint32_t
*
aResult
)
{
if
(
mState
=
=
eInit
|
|
mState
=
=
ePending
)
{
return
NS_BASE_STREAM_WOULD_BLOCK
;
}
if
(
mState
=
=
eRunning
)
{
MOZ_ASSERT
(
mRemoteStream
|
|
mAsyncRemoteStream
)
;
nsresult
rv
=
EnsureAsyncRemoteStream
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
mAsyncRemoteStream
)
;
return
mAsyncRemoteStream
-
>
ReadSegments
(
aWriter
aClosure
aCount
aResult
)
;
}
MOZ_ASSERT
(
mState
=
=
eClosed
)
;
return
NS_BASE_STREAM_CLOSED
;
}
NS_IMETHODIMP
IPCBlobInputStream
:
:
IsNonBlocking
(
bool
*
aNonBlocking
)
{
*
aNonBlocking
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
IPCBlobInputStream
:
:
Close
(
)
{
if
(
mActor
)
{
mActor
-
>
ForgetStream
(
this
)
;
mActor
=
nullptr
;
}
if
(
mAsyncRemoteStream
)
{
mAsyncRemoteStream
-
>
Close
(
)
;
mAsyncRemoteStream
=
nullptr
;
}
if
(
mRemoteStream
)
{
mRemoteStream
-
>
Close
(
)
;
mRemoteStream
=
nullptr
;
}
mInputStreamCallback
=
nullptr
;
mInputStreamCallbackEventTarget
=
nullptr
;
mFileMetadataCallback
=
nullptr
;
mFileMetadataCallbackEventTarget
=
nullptr
;
mState
=
eClosed
;
return
NS_OK
;
}
NS_IMETHODIMP
IPCBlobInputStream
:
:
GetCloneable
(
bool
*
aCloneable
)
{
*
aCloneable
=
mState
!
=
eClosed
;
return
NS_OK
;
}
NS_IMETHODIMP
IPCBlobInputStream
:
:
Clone
(
nsIInputStream
*
*
aResult
)
{
if
(
mState
=
=
eClosed
)
{
return
NS_BASE_STREAM_CLOSED
;
}
MOZ_ASSERT
(
mActor
)
;
nsCOMPtr
<
nsIInputStream
>
stream
=
mActor
-
>
CreateStream
(
)
;
if
(
!
stream
)
{
return
NS_ERROR_FAILURE
;
}
stream
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
IPCBlobInputStream
:
:
CloseWithStatus
(
nsresult
aStatus
)
{
return
Close
(
)
;
}
NS_IMETHODIMP
IPCBlobInputStream
:
:
AsyncWait
(
nsIInputStreamCallback
*
aCallback
uint32_t
aFlags
uint32_t
aRequestedCount
nsIEventTarget
*
aEventTarget
)
{
switch
(
mState
)
{
case
eInit
:
MOZ_ASSERT
(
mActor
)
;
mInputStreamCallback
=
aCallback
;
mInputStreamCallbackEventTarget
=
aEventTarget
;
mState
=
ePending
;
mActor
-
>
StreamNeeded
(
this
aEventTarget
)
;
return
NS_OK
;
case
ePending
:
if
(
mInputStreamCallback
&
&
aCallback
)
{
return
NS_ERROR_FAILURE
;
}
mInputStreamCallback
=
aCallback
;
mInputStreamCallbackEventTarget
=
aEventTarget
;
return
NS_OK
;
case
eRunning
:
return
MaybeExecuteInputStreamCallback
(
aCallback
aEventTarget
)
;
default
:
MOZ_ASSERT
(
mState
=
=
eClosed
)
;
return
NS_BASE_STREAM_CLOSED
;
}
}
void
IPCBlobInputStream
:
:
StreamReady
(
nsIInputStream
*
aInputStream
)
{
if
(
mState
=
=
eClosed
)
{
if
(
aInputStream
)
{
aInputStream
-
>
Close
(
)
;
}
return
;
}
if
(
!
aInputStream
)
{
return
;
}
mRemoteStream
=
aInputStream
;
MOZ_ASSERT
(
mState
=
=
ePending
)
;
mState
=
eRunning
;
nsCOMPtr
<
nsIFileMetadataCallback
>
fileMetadataCallback
;
fileMetadataCallback
.
swap
(
mFileMetadataCallback
)
;
nsCOMPtr
<
nsIEventTarget
>
fileMetadataCallbackEventTarget
;
fileMetadataCallbackEventTarget
.
swap
(
mFileMetadataCallbackEventTarget
)
;
if
(
fileMetadataCallback
)
{
FileMetadataCallbackRunnable
:
:
Execute
(
fileMetadataCallback
fileMetadataCallbackEventTarget
this
)
;
}
nsCOMPtr
<
nsIInputStreamCallback
>
inputStreamCallback
;
inputStreamCallback
.
swap
(
mInputStreamCallback
)
;
nsCOMPtr
<
nsIEventTarget
>
inputStreamCallbackEventTarget
;
inputStreamCallbackEventTarget
.
swap
(
mInputStreamCallbackEventTarget
)
;
if
(
inputStreamCallback
)
{
MaybeExecuteInputStreamCallback
(
inputStreamCallback
inputStreamCallbackEventTarget
)
;
}
}
nsresult
IPCBlobInputStream
:
:
MaybeExecuteInputStreamCallback
(
nsIInputStreamCallback
*
aCallback
nsIEventTarget
*
aCallbackEventTarget
)
{
MOZ_ASSERT
(
mState
=
=
eRunning
)
;
MOZ_ASSERT
(
mRemoteStream
|
|
mAsyncRemoteStream
)
;
if
(
mInputStreamCallback
&
&
aCallback
)
{
return
NS_ERROR_FAILURE
;
}
mInputStreamCallback
=
aCallback
;
mInputStreamCallbackEventTarget
=
aCallbackEventTarget
;
if
(
!
mInputStreamCallback
)
{
return
NS_OK
;
}
nsresult
rv
=
EnsureAsyncRemoteStream
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
mAsyncRemoteStream
)
;
return
mAsyncRemoteStream
-
>
AsyncWait
(
this
0
0
aCallbackEventTarget
)
;
}
NS_IMETHODIMP
IPCBlobInputStream
:
:
OnInputStreamReady
(
nsIAsyncInputStream
*
aStream
)
{
if
(
mState
=
=
eClosed
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mState
=
=
eRunning
)
;
MOZ_ASSERT
(
mAsyncRemoteStream
=
=
aStream
)
;
if
(
!
mInputStreamCallback
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIInputStreamCallback
>
callback
;
callback
.
swap
(
mInputStreamCallback
)
;
nsCOMPtr
<
nsIEventTarget
>
callbackEventTarget
;
callbackEventTarget
.
swap
(
mInputStreamCallbackEventTarget
)
;
InputStreamCallbackRunnable
:
:
Execute
(
callback
callbackEventTarget
this
)
;
return
NS_OK
;
}
void
IPCBlobInputStream
:
:
Serialize
(
mozilla
:
:
ipc
:
:
InputStreamParams
&
aParams
FileDescriptorArray
&
aFileDescriptors
)
{
mozilla
:
:
ipc
:
:
IPCBlobInputStreamParams
params
;
params
.
id
(
)
=
mActor
-
>
ID
(
)
;
aParams
=
params
;
}
bool
IPCBlobInputStream
:
:
Deserialize
(
const
mozilla
:
:
ipc
:
:
InputStreamParams
&
aParams
const
FileDescriptorArray
&
aFileDescriptors
)
{
MOZ_CRASH
(
"
This
should
never
be
called
.
"
)
;
return
false
;
}
mozilla
:
:
Maybe
<
uint64_t
>
IPCBlobInputStream
:
:
ExpectedSerializedLength
(
)
{
return
mozilla
:
:
Nothing
(
)
;
}
NS_IMETHODIMP
IPCBlobInputStream
:
:
AsyncWait
(
nsIFileMetadataCallback
*
aCallback
nsIEventTarget
*
aEventTarget
)
{
switch
(
mState
)
{
case
eInit
:
MOZ_ASSERT
(
mActor
)
;
mFileMetadataCallback
=
aCallback
;
mFileMetadataCallbackEventTarget
=
aEventTarget
;
mState
=
ePending
;
mActor
-
>
StreamNeeded
(
this
aEventTarget
)
;
return
NS_OK
;
case
ePending
:
if
(
mFileMetadataCallback
&
&
aCallback
)
{
return
NS_ERROR_FAILURE
;
}
mFileMetadataCallback
=
aCallback
;
mFileMetadataCallbackEventTarget
=
aEventTarget
;
return
NS_OK
;
case
eRunning
:
FileMetadataCallbackRunnable
:
:
Execute
(
aCallback
aEventTarget
this
)
;
return
NS_OK
;
default
:
MOZ_ASSERT
(
mState
=
=
eClosed
)
;
return
NS_BASE_STREAM_CLOSED
;
}
}
NS_IMETHODIMP
IPCBlobInputStream
:
:
GetSize
(
int64_t
*
aRetval
)
{
nsCOMPtr
<
nsIFileMetadata
>
fileMetadata
=
do_QueryInterface
(
mRemoteStream
)
;
if
(
!
fileMetadata
)
{
return
mState
=
=
eClosed
?
NS_BASE_STREAM_CLOSED
:
NS_ERROR_FAILURE
;
}
return
fileMetadata
-
>
GetSize
(
aRetval
)
;
}
NS_IMETHODIMP
IPCBlobInputStream
:
:
GetLastModified
(
int64_t
*
aRetval
)
{
nsCOMPtr
<
nsIFileMetadata
>
fileMetadata
=
do_QueryInterface
(
mRemoteStream
)
;
if
(
!
fileMetadata
)
{
return
mState
=
=
eClosed
?
NS_BASE_STREAM_CLOSED
:
NS_ERROR_FAILURE
;
}
return
fileMetadata
-
>
GetLastModified
(
aRetval
)
;
}
NS_IMETHODIMP
IPCBlobInputStream
:
:
GetFileDescriptor
(
PRFileDesc
*
*
aRetval
)
{
nsCOMPtr
<
nsIFileMetadata
>
fileMetadata
=
do_QueryInterface
(
mRemoteStream
)
;
if
(
!
fileMetadata
)
{
return
mState
=
=
eClosed
?
NS_BASE_STREAM_CLOSED
:
NS_ERROR_FAILURE
;
}
return
fileMetadata
-
>
GetFileDescriptor
(
aRetval
)
;
}
nsresult
IPCBlobInputStream
:
:
EnsureAsyncRemoteStream
(
)
{
if
(
mAsyncRemoteStream
)
{
return
NS_OK
;
}
if
(
!
mRemoteStream
)
{
return
NS_ERROR_FAILURE
;
}
bool
nonBlocking
=
false
;
nsresult
rv
=
mRemoteStream
-
>
IsNonBlocking
(
&
nonBlocking
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIAsyncInputStream
>
asyncStream
=
do_QueryInterface
(
mRemoteStream
)
;
if
(
!
asyncStream
|
|
!
nonBlocking
)
{
nsCOMPtr
<
nsIStreamTransportService
>
sts
=
do_GetService
(
kStreamTransportServiceCID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsITransport
>
transport
;
rv
=
sts
-
>
CreateInputTransport
(
mRemoteStream
0
-
1
true
getter_AddRefs
(
transport
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIInputStream
>
wrapper
;
rv
=
transport
-
>
OpenInputStream
(
0
0
0
getter_AddRefs
(
wrapper
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
asyncStream
=
do_QueryInterface
(
wrapper
)
;
}
MOZ_ASSERT
(
asyncStream
)
;
mAsyncRemoteStream
=
asyncStream
;
mRemoteStream
=
nullptr
;
return
NS_OK
;
}
}
}
