#
ifndef
mozilla_dom_IPCBlobInputStreamChild_h
#
define
mozilla_dom_IPCBlobInputStreamChild_h
#
include
"
mozilla
/
dom
/
PIPCBlobInputStreamChild
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
dom
{
class
IPCBlobInputStream
;
class
ThreadSafeWorkerRef
;
class
IPCBlobInputStreamChild
final
:
public
PIPCBlobInputStreamChild
{
public
:
enum
ActorState
{
eActive
eInactive
eActiveMigrating
eInactiveMigrating
}
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
IPCBlobInputStreamChild
final
)
IPCBlobInputStreamChild
(
const
nsID
&
aID
uint64_t
aSize
)
;
void
ActorDestroy
(
IProtocol
:
:
ActorDestroyReason
aReason
)
override
;
ActorState
State
(
)
;
already_AddRefed
<
IPCBlobInputStream
>
CreateStream
(
)
;
void
ForgetStream
(
IPCBlobInputStream
*
aStream
)
;
const
nsID
&
ID
(
)
const
{
return
mID
;
}
uint64_t
Size
(
)
const
{
return
mSize
;
}
void
StreamNeeded
(
IPCBlobInputStream
*
aStream
nsIEventTarget
*
aEventTarget
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvStreamReady
(
const
Maybe
<
IPCStream
>
&
aStream
)
;
void
LengthNeeded
(
IPCBlobInputStream
*
aStream
nsIEventTarget
*
aEventTarget
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvLengthReady
(
const
int64_t
&
aLength
)
;
void
Shutdown
(
)
;
void
Migrated
(
)
;
private
:
~
IPCBlobInputStreamChild
(
)
;
nsTArray
<
IPCBlobInputStream
*
>
mStreams
;
Mutex
mMutex
;
const
nsID
mID
;
const
uint64_t
mSize
;
ActorState
mState
;
struct
PendingOperation
{
RefPtr
<
IPCBlobInputStream
>
mStream
;
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
enum
{
eStreamNeeded
eLengthNeeded
}
mOp
;
}
;
nsTArray
<
PendingOperation
>
mPendingOperations
;
nsCOMPtr
<
nsISerialEventTarget
>
mOwningEventTarget
;
RefPtr
<
ThreadSafeWorkerRef
>
mWorkerRef
;
}
;
}
}
#
endif
