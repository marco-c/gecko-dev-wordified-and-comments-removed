#
ifndef
mozilla_dom_ipc_IPCBlobInputStreamChild_h
#
define
mozilla_dom_ipc_IPCBlobInputStreamChild_h
#
include
"
mozilla
/
ipc
/
PIPCBlobInputStreamChild
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
workers
{
class
WorkerHolder
;
}
class
IPCBlobInputStream
;
class
IPCBlobInputStreamChild
final
:
public
mozilla
:
:
ipc
:
:
PIPCBlobInputStreamChild
{
public
:
enum
ActorState
{
eActive
eInactive
eActiveMigrating
eInactiveMigrating
}
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
IPCBlobInputStreamChild
)
IPCBlobInputStreamChild
(
const
nsID
&
aID
uint64_t
aSize
)
;
void
ActorDestroy
(
IProtocol
:
:
ActorDestroyReason
aReason
)
override
;
ActorState
State
(
)
;
already_AddRefed
<
nsIInputStream
>
CreateStream
(
)
;
void
ForgetStream
(
IPCBlobInputStream
*
aStream
)
;
const
nsID
&
ID
(
)
const
{
return
mID
;
}
uint64_t
Size
(
)
const
{
return
mSize
;
}
void
StreamNeeded
(
IPCBlobInputStream
*
aStream
nsIEventTarget
*
aEventTarget
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvStreamReady
(
const
OptionalIPCStream
&
aStream
)
override
;
void
Shutdown
(
)
;
void
Migrated
(
)
;
private
:
~
IPCBlobInputStreamChild
(
)
;
nsTArray
<
IPCBlobInputStream
*
>
mStreams
;
Mutex
mMutex
;
const
nsID
mID
;
const
uint64_t
mSize
;
ActorState
mState
;
struct
PendingOperation
{
RefPtr
<
IPCBlobInputStream
>
mStream
;
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
}
;
nsTArray
<
PendingOperation
>
mPendingOperations
;
nsCOMPtr
<
nsISerialEventTarget
>
mOwningEventTarget
;
UniquePtr
<
workers
:
:
WorkerHolder
>
mWorkerHolder
;
}
;
}
}
#
endif
