#
include
"
FileCreatorHelper
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
FileBinding
.
h
"
#
include
"
mozilla
/
dom
/
FileCreatorChild
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsIFile
.
h
"
#
ifdef
CreateFile
#
undef
CreateFile
#
endif
namespace
mozilla
:
:
dom
{
already_AddRefed
<
Promise
>
FileCreatorHelper
:
:
CreateFile
(
nsIGlobalObject
*
aGlobalObject
nsIFile
*
aFile
const
ChromeFilePropertyBag
&
aBag
bool
aIsFromNsIFile
ErrorResult
&
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
aGlobalObject
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
nsAutoString
path
;
aRv
=
aFile
-
>
GetPath
(
path
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
mozilla
:
:
ipc
:
:
PBackgroundChild
*
actorChild
=
mozilla
:
:
ipc
:
:
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
actorChild
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
Maybe
<
int64_t
>
lastModified
;
if
(
aBag
.
mLastModified
.
WasPassed
(
)
)
{
lastModified
.
emplace
(
aBag
.
mLastModified
.
Value
(
)
)
;
}
PFileCreatorChild
*
actor
=
actorChild
-
>
SendPFileCreatorConstructor
(
path
aBag
.
mType
aBag
.
mName
lastModified
aBag
.
mExistenceCheck
aIsFromNsIFile
)
;
if
(
!
actor
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
static_cast
<
FileCreatorChild
*
>
(
actor
)
-
>
SetPromise
(
promise
)
;
return
promise
.
forget
(
)
;
}
}
