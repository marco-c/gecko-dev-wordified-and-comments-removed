#
ifndef
mozilla_dom_XMLHttpRequestMainThread_h
#
define
mozilla_dom_XMLHttpRequestMainThread_h
#
include
<
bitset
>
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIXMLHttpRequest
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIHttpHeaderVisitor
.
h
"
#
include
"
nsIProgressEventSink
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsISizeOfEventTarget
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
dom
/
XMLHttpRequest
.
h
"
#
include
"
mozilla
/
dom
/
XMLHttpRequestBinding
.
h
"
#
include
"
mozilla
/
dom
/
XMLHttpRequestEventTarget
.
h
"
#
ifdef
Status
#
undef
Status
#
endif
class
nsIJARChannel
;
class
nsILoadGroup
;
class
nsIUnicodeDecoder
;
class
nsIJSID
;
namespace
mozilla
{
namespace
dom
{
class
Blob
;
class
BlobSet
;
class
FormData
;
class
XMLHttpRequestUpload
;
class
ArrayBufferBuilder
{
uint8_t
*
mDataPtr
;
uint32_t
mCapacity
;
uint32_t
mLength
;
void
*
mMapPtr
;
public
:
ArrayBufferBuilder
(
)
;
~
ArrayBufferBuilder
(
)
;
void
reset
(
)
;
bool
setCapacity
(
uint32_t
aNewCap
)
;
bool
append
(
const
uint8_t
*
aNewData
uint32_t
aDataLen
uint32_t
aMaxGrowth
=
0
)
;
uint32_t
length
(
)
{
return
mLength
;
}
uint32_t
capacity
(
)
{
return
mCapacity
;
}
JSObject
*
getArrayBuffer
(
JSContext
*
aCx
)
;
nsresult
mapToFileInPackage
(
const
nsCString
&
aFile
nsIFile
*
aJarFile
)
;
protected
:
static
bool
areOverlappingRegions
(
const
uint8_t
*
aStart1
uint32_t
aLength1
const
uint8_t
*
aStart2
uint32_t
aLength2
)
;
}
;
class
nsXMLHttpRequestXPCOMifier
;
class
XMLHttpRequestMainThread
final
:
public
XMLHttpRequest
public
nsIXMLHttpRequest
public
nsIJSXMLHttpRequest
public
nsIStreamListener
public
nsIChannelEventSink
public
nsIProgressEventSink
public
nsIInterfaceRequestor
public
nsSupportsWeakReference
public
nsITimerCallback
public
nsISizeOfEventTarget
{
friend
class
nsXHRParseEndListener
;
friend
class
nsXMLHttpRequestXPCOMifier
;
public
:
enum
class
ProgressEventType
:
uint8_t
{
loadstart
progress
error
abort
timeout
load
loadend
ENUM_MAX
}
;
XMLHttpRequestMainThread
(
)
;
void
Construct
(
nsIPrincipal
*
aPrincipal
nsIGlobalObject
*
aGlobalObject
nsIURI
*
aBaseURI
=
nullptr
nsILoadGroup
*
aLoadGroup
=
nullptr
)
{
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT_IF
(
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
aGlobalObject
)
win
-
>
IsInnerWindow
(
)
)
;
mPrincipal
=
aPrincipal
;
BindToOwner
(
aGlobalObject
)
;
mBaseURI
=
aBaseURI
;
mLoadGroup
=
aLoadGroup
;
}
void
InitParameters
(
bool
aAnon
bool
aSystem
)
;
void
SetParameters
(
bool
aAnon
bool
aSystem
)
{
mIsAnon
=
aAnon
|
|
aSystem
;
mIsSystem
=
aSystem
;
}
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIXMLHTTPREQUEST
NS_FORWARD_NSIXMLHTTPREQUESTEVENTTARGET
(
XMLHttpRequestEventTarget
:
:
)
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIPROGRESSEVENTSINK
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSITIMERCALLBACK
virtual
size_t
SizeOfEventTargetIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
;
NS_REALLY_FORWARD_NSIDOMEVENTTARGET
(
XMLHttpRequestEventTarget
)
virtual
uint16_t
ReadyState
(
)
const
override
;
virtual
void
Open
(
const
nsACString
&
aMethod
const
nsAString
&
aUrl
ErrorResult
&
aRv
)
override
{
Open
(
aMethod
aUrl
true
Optional
<
nsAString
>
(
)
Optional
<
nsAString
>
(
)
aRv
)
;
}
virtual
void
Open
(
const
nsACString
&
aMethod
const
nsAString
&
aUrl
bool
aAsync
const
Optional
<
nsAString
>
&
aUser
const
Optional
<
nsAString
>
&
aPassword
ErrorResult
&
aRv
)
override
{
aRv
=
Open
(
aMethod
NS_ConvertUTF16toUTF8
(
aUrl
)
aAsync
aUser
aPassword
)
;
}
virtual
void
SetRequestHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
ErrorResult
&
aRv
)
override
{
aRv
=
SetRequestHeader
(
aHeader
aValue
)
;
}
virtual
uint32_t
Timeout
(
)
const
override
{
return
mTimeoutMilliseconds
;
}
virtual
void
SetTimeout
(
uint32_t
aTimeout
ErrorResult
&
aRv
)
override
;
virtual
bool
WithCredentials
(
)
const
override
;
virtual
void
SetWithCredentials
(
bool
aWithCredentials
ErrorResult
&
aRv
)
override
;
virtual
XMLHttpRequestUpload
*
GetUpload
(
ErrorResult
&
aRv
)
override
;
private
:
virtual
~
XMLHttpRequestMainThread
(
)
;
class
RequestBody
{
public
:
RequestBody
(
)
:
mType
(
eUninitialized
)
{
}
explicit
RequestBody
(
const
ArrayBuffer
*
aArrayBuffer
)
:
mType
(
eArrayBuffer
)
{
mValue
.
mArrayBuffer
=
aArrayBuffer
;
}
explicit
RequestBody
(
const
ArrayBufferView
*
aArrayBufferView
)
:
mType
(
eArrayBufferView
)
{
mValue
.
mArrayBufferView
=
aArrayBufferView
;
}
explicit
RequestBody
(
Blob
&
aBlob
)
:
mType
(
eBlob
)
{
mValue
.
mBlob
=
&
aBlob
;
}
explicit
RequestBody
(
nsIDocument
*
aDocument
)
:
mType
(
eDocument
)
{
mValue
.
mDocument
=
aDocument
;
}
explicit
RequestBody
(
const
nsAString
&
aString
)
:
mType
(
eDOMString
)
{
mValue
.
mString
=
&
aString
;
}
explicit
RequestBody
(
FormData
&
aFormData
)
:
mType
(
eFormData
)
{
mValue
.
mFormData
=
&
aFormData
;
}
explicit
RequestBody
(
nsIInputStream
*
aStream
)
:
mType
(
eInputStream
)
{
mValue
.
mStream
=
aStream
;
}
enum
Type
{
eUninitialized
eArrayBuffer
eArrayBufferView
eBlob
eDocument
eDOMString
eFormData
eInputStream
}
;
union
Value
{
const
ArrayBuffer
*
mArrayBuffer
;
const
ArrayBufferView
*
mArrayBufferView
;
Blob
*
mBlob
;
nsIDocument
*
mDocument
;
const
nsAString
*
mString
;
FormData
*
mFormData
;
nsIInputStream
*
mStream
;
}
;
Type
GetType
(
)
const
{
MOZ_ASSERT
(
mType
!
=
eUninitialized
)
;
return
mType
;
}
Value
GetValue
(
)
const
{
MOZ_ASSERT
(
mType
!
=
eUninitialized
)
;
return
mValue
;
}
private
:
Type
mType
;
Value
mValue
;
}
;
static
nsresult
GetRequestBody
(
nsIVariant
*
aVariant
const
Nullable
<
RequestBody
>
&
aBody
nsIInputStream
*
*
aResult
uint64_t
*
aContentLength
nsACString
&
aContentType
nsACString
&
aCharset
)
;
nsresult
Send
(
nsIVariant
*
aVariant
const
Nullable
<
RequestBody
>
&
aBody
)
;
nsresult
Send
(
const
Nullable
<
RequestBody
>
&
aBody
)
{
return
Send
(
nullptr
aBody
)
;
}
nsresult
Send
(
const
RequestBody
&
aBody
)
{
return
Send
(
Nullable
<
RequestBody
>
(
aBody
)
)
;
}
bool
IsCrossSiteCORSRequest
(
)
const
;
bool
IsDeniedCrossSiteCORSRequest
(
)
;
void
PopulateNetworkInterfaceId
(
)
;
public
:
virtual
void
Send
(
JSContext
*
ErrorResult
&
aRv
)
override
{
aRv
=
Send
(
Nullable
<
RequestBody
>
(
)
)
;
}
virtual
void
Send
(
JSContext
*
const
ArrayBuffer
&
aArrayBuffer
ErrorResult
&
aRv
)
override
{
aRv
=
Send
(
RequestBody
(
&
aArrayBuffer
)
)
;
}
virtual
void
Send
(
JSContext
*
const
ArrayBufferView
&
aArrayBufferView
ErrorResult
&
aRv
)
override
{
aRv
=
Send
(
RequestBody
(
&
aArrayBufferView
)
)
;
}
virtual
void
Send
(
JSContext
*
Blob
&
aBlob
ErrorResult
&
aRv
)
override
{
aRv
=
Send
(
RequestBody
(
aBlob
)
)
;
}
virtual
void
Send
(
JSContext
*
nsIDocument
&
aDoc
ErrorResult
&
aRv
)
override
{
aRv
=
Send
(
RequestBody
(
&
aDoc
)
)
;
}
virtual
void
Send
(
JSContext
*
aCx
const
nsAString
&
aString
ErrorResult
&
aRv
)
override
{
if
(
DOMStringIsNull
(
aString
)
)
{
Send
(
aCx
aRv
)
;
}
else
{
aRv
=
Send
(
RequestBody
(
aString
)
)
;
}
}
virtual
void
Send
(
JSContext
*
FormData
&
aFormData
ErrorResult
&
aRv
)
override
{
aRv
=
Send
(
RequestBody
(
aFormData
)
)
;
}
virtual
void
Send
(
JSContext
*
aCx
nsIInputStream
*
aStream
ErrorResult
&
aRv
)
override
{
NS_ASSERTION
(
aStream
"
Null
should
go
to
string
version
"
)
;
nsCOMPtr
<
nsIXPConnectWrappedJS
>
wjs
=
do_QueryInterface
(
aStream
)
;
if
(
wjs
)
{
JSObject
*
data
=
wjs
-
>
GetJSObject
(
)
;
if
(
!
data
)
{
aRv
.
Throw
(
NS_ERROR_DOM_TYPE_ERR
)
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
dataAsValue
(
aCx
JS
:
:
ObjectValue
(
*
data
)
)
;
nsAutoString
dataAsString
;
if
(
ConvertJSValueToString
(
aCx
dataAsValue
eNull
eNull
dataAsString
)
)
{
Send
(
aCx
dataAsString
aRv
)
;
}
else
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
}
return
;
}
aRv
=
Send
(
RequestBody
(
aStream
)
)
;
}
void
Abort
(
)
{
ErrorResult
rv
;
Abort
(
rv
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
)
;
}
virtual
void
Abort
(
ErrorResult
&
aRv
)
override
;
virtual
void
GetResponseURL
(
nsAString
&
aUrl
)
override
;
virtual
uint32_t
GetStatus
(
ErrorResult
&
aRv
)
override
;
virtual
void
GetStatusText
(
nsACString
&
aStatusText
ErrorResult
&
aRv
)
override
;
virtual
void
GetResponseHeader
(
const
nsACString
&
aHeader
nsACString
&
aResult
ErrorResult
&
aRv
)
override
;
void
GetResponseHeader
(
const
nsAString
&
aHeader
nsAString
&
aResult
ErrorResult
&
aRv
)
{
nsAutoCString
result
;
GetResponseHeader
(
NS_ConvertUTF16toUTF8
(
aHeader
)
result
aRv
)
;
if
(
result
.
IsVoid
(
)
)
{
aResult
.
SetIsVoid
(
true
)
;
}
else
{
CopyASCIItoUTF16
(
result
aResult
)
;
}
}
virtual
void
GetAllResponseHeaders
(
nsACString
&
aResponseHeaders
ErrorResult
&
aRv
)
override
;
bool
IsSafeHeader
(
const
nsACString
&
aHeaderName
NotNull
<
nsIHttpChannel
*
>
aHttpChannel
)
const
;
virtual
void
OverrideMimeType
(
const
nsAString
&
aMimeType
ErrorResult
&
aRv
)
override
;
virtual
XMLHttpRequestResponseType
ResponseType
(
)
const
override
{
return
XMLHttpRequestResponseType
(
mResponseType
)
;
}
virtual
void
SetResponseType
(
XMLHttpRequestResponseType
aType
ErrorResult
&
aRv
)
override
;
virtual
void
GetResponse
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResponse
ErrorResult
&
aRv
)
override
;
virtual
void
GetResponseText
(
nsAString
&
aResponseText
ErrorResult
&
aRv
)
override
;
virtual
nsIDocument
*
GetResponseXML
(
ErrorResult
&
aRv
)
override
;
virtual
bool
MozBackgroundRequest
(
)
const
override
;
virtual
void
SetMozBackgroundRequest
(
bool
aMozBackgroundRequest
ErrorResult
&
aRv
)
override
;
virtual
bool
MozAnon
(
)
const
override
;
virtual
bool
MozSystem
(
)
const
override
;
virtual
nsIChannel
*
GetChannel
(
)
const
override
{
return
mChannel
;
}
virtual
void
GetNetworkInterfaceId
(
nsACString
&
aId
)
const
override
{
aId
=
mNetworkInterfaceId
;
}
virtual
void
SetNetworkInterfaceId
(
const
nsACString
&
aId
)
override
{
mNetworkInterfaceId
=
aId
;
}
virtual
void
GetInterface
(
JSContext
*
aCx
nsIJSID
*
aIID
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aRv
)
override
;
nsresult
CreateReadystatechangeEvent
(
nsIDOMEvent
*
*
aDOMEvent
)
;
void
DispatchProgressEvent
(
DOMEventTargetHelper
*
aTarget
const
ProgressEventType
aType
bool
aLengthComputable
int64_t
aLoaded
int64_t
aTotal
)
;
void
MaybeDispatchProgressEvents
(
bool
aFinalProgress
)
;
nsresult
Init
(
)
;
nsresult
init
(
nsIPrincipal
*
principal
nsIScriptContext
*
scriptContext
nsPIDOMWindowInner
*
globalObject
nsIURI
*
baseURI
)
;
void
SetRequestObserver
(
nsIRequestObserver
*
aObserver
)
;
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS_INHERITED
(
XMLHttpRequestMainThread
XMLHttpRequest
)
bool
AllowUploadProgress
(
)
;
void
RootJSResultObjects
(
)
;
virtual
void
DisconnectFromOwner
(
)
override
;
static
void
SetDontWarnAboutSyncXHR
(
bool
aVal
)
{
sDontWarnAboutSyncXHR
=
aVal
;
}
static
bool
DontWarnAboutSyncXHR
(
)
{
return
sDontWarnAboutSyncXHR
;
}
protected
:
enum
class
State
:
uint8_t
{
unsent
opened
headers_received
loading
done
}
;
nsresult
DetectCharset
(
)
;
nsresult
AppendToResponseText
(
const
char
*
aBuffer
uint32_t
aBufferLen
)
;
static
NS_METHOD
StreamReaderFunc
(
nsIInputStream
*
in
void
*
closure
const
char
*
fromRawSegment
uint32_t
toOffset
uint32_t
count
uint32_t
*
writeCount
)
;
nsresult
CreateResponseParsedJSON
(
JSContext
*
aCx
)
;
void
CreatePartialBlob
(
ErrorResult
&
aRv
)
;
bool
CreateDOMBlob
(
nsIRequest
*
request
)
;
nsresult
ChangeState
(
State
aState
bool
aBroadcast
=
true
)
;
already_AddRefed
<
nsILoadGroup
>
GetLoadGroup
(
)
const
;
nsIURI
*
GetBaseURI
(
)
;
already_AddRefed
<
nsIHttpChannel
>
GetCurrentHttpChannel
(
)
;
already_AddRefed
<
nsIJARChannel
>
GetCurrentJARChannel
(
)
;
bool
IsSystemXHR
(
)
const
;
void
ChangeStateToDone
(
)
;
void
StartProgressEventTimer
(
)
;
nsresult
OnRedirectVerifyCallback
(
nsresult
result
)
;
nsresult
Open
(
const
nsACString
&
method
const
nsACString
&
url
bool
async
const
Optional
<
nsAString
>
&
user
const
Optional
<
nsAString
>
&
password
)
;
already_AddRefed
<
nsXMLHttpRequestXPCOMifier
>
EnsureXPCOMifier
(
)
;
nsCOMPtr
<
nsISupports
>
mContext
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsCOMPtr
<
nsIDocument
>
mResponseXML
;
nsTArray
<
nsCString
>
mCORSUnsafeHeaders
;
nsCOMPtr
<
nsIStreamListener
>
mXMLParserStreamListener
;
class
nsHeaderVisitor
:
public
nsIHttpHeaderVisitor
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIHTTPHEADERVISITOR
nsHeaderVisitor
(
const
XMLHttpRequestMainThread
&
aXMLHttpRequest
NotNull
<
nsIHttpChannel
*
>
aHttpChannel
)
:
mXHR
(
aXMLHttpRequest
)
mHttpChannel
(
aHttpChannel
)
{
}
const
nsACString
&
Headers
(
)
{
return
mHeaders
;
}
private
:
virtual
~
nsHeaderVisitor
(
)
{
}
nsCString
mHeaders
;
const
XMLHttpRequestMainThread
&
mXHR
;
NotNull
<
nsCOMPtr
<
nsIHttpChannel
>
>
mHttpChannel
;
}
;
nsCString
mResponseBody
;
nsString
mResponseText
;
uint32_t
mResponseBodyDecodedPos
;
nsCOMPtr
<
nsIUnicodeDecoder
>
mDecoder
;
nsCString
mResponseCharset
;
XMLHttpRequestResponseType
mResponseType
;
RefPtr
<
Blob
>
mResponseBlob
;
RefPtr
<
Blob
>
mDOMBlob
;
nsAutoPtr
<
BlobSet
>
mBlobSet
;
nsString
mOverrideMimeType
;
nsCOMPtr
<
nsIInterfaceRequestor
>
mNotificationCallbacks
;
nsCOMPtr
<
nsIChannelEventSink
>
mChannelEventSink
;
nsCOMPtr
<
nsIProgressEventSink
>
mProgressEventSink
;
nsIRequestObserver
*
mRequestObserver
;
nsCOMPtr
<
nsIURI
>
mBaseURI
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
;
State
mState
;
bool
mFlagSynchronous
;
bool
mFlagAborted
;
bool
mFlagParseBody
;
bool
mFlagSyncLooping
;
bool
mFlagBackgroundRequest
;
bool
mFlagHadUploadListenersOnSend
;
bool
mFlagACwithCredentials
;
bool
mFlagTimedOut
;
bool
mFlagDeleted
;
bool
mFlagSend
;
RefPtr
<
XMLHttpRequestUpload
>
mUpload
;
int64_t
mUploadTransferred
;
int64_t
mUploadTotal
;
bool
mUploadLengthComputable
;
bool
mUploadComplete
;
bool
mProgressSinceLastProgressEvent
;
PRTime
mRequestSentTime
;
uint32_t
mTimeoutMilliseconds
;
nsCOMPtr
<
nsITimer
>
mTimeoutTimer
;
void
StartTimeoutTimer
(
)
;
void
HandleTimeoutCallback
(
)
;
bool
mErrorLoad
;
bool
mWaitingForOnStopRequest
;
bool
mProgressTimerIsActive
;
bool
mIsHtml
;
bool
mWarnAboutMultipartHtml
;
bool
mWarnAboutSyncHtml
;
bool
mLoadLengthComputable
;
int64_t
mLoadTotal
;
uint64_t
mDataAvailable
;
int64_t
mLoadTransferred
;
nsCOMPtr
<
nsITimer
>
mProgressNotifier
;
void
HandleProgressTimerCallback
(
)
;
bool
mIsSystem
;
bool
mIsAnon
;
nsCString
mNetworkInterfaceId
;
void
CloseRequestWithError
(
const
ProgressEventType
aType
)
;
bool
mFirstStartRequestSeen
;
bool
mInLoadProgressEvent
;
nsCOMPtr
<
nsIAsyncVerifyRedirectCallback
>
mRedirectCallback
;
nsCOMPtr
<
nsIChannel
>
mNewRedirectChannel
;
JS
:
:
Heap
<
JS
:
:
Value
>
mResultJSON
;
ArrayBufferBuilder
mArrayBufferBuilder
;
JS
:
:
Heap
<
JSObject
*
>
mResultArrayBuffer
;
bool
mIsMappedArrayBuffer
;
void
ResetResponse
(
)
;
bool
ShouldBlockAuthPrompt
(
)
;
struct
RequestHeader
{
nsCString
header
;
nsCString
value
;
}
;
nsTArray
<
RequestHeader
>
mModifiedRequestHeaders
;
nsTHashtable
<
nsCStringHashKey
>
mAlreadySetHeaders
;
nsXMLHttpRequestXPCOMifier
*
mXPCOMifier
;
static
bool
sDontWarnAboutSyncXHR
;
}
;
class
MOZ_STACK_CLASS
AutoDontWarnAboutSyncXHR
{
public
:
AutoDontWarnAboutSyncXHR
(
)
:
mOldVal
(
XMLHttpRequestMainThread
:
:
DontWarnAboutSyncXHR
(
)
)
{
XMLHttpRequestMainThread
:
:
SetDontWarnAboutSyncXHR
(
true
)
;
}
~
AutoDontWarnAboutSyncXHR
(
)
{
XMLHttpRequestMainThread
:
:
SetDontWarnAboutSyncXHR
(
mOldVal
)
;
}
private
:
bool
mOldVal
;
}
;
class
nsXMLHttpRequestXPCOMifier
final
:
public
nsIStreamListener
public
nsIChannelEventSink
public
nsIAsyncVerifyRedirectCallback
public
nsIProgressEventSink
public
nsIInterfaceRequestor
public
nsITimerCallback
{
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
nsXMLHttpRequestXPCOMifier
nsIStreamListener
)
explicit
nsXMLHttpRequestXPCOMifier
(
XMLHttpRequestMainThread
*
aXHR
)
:
mXHR
(
aXHR
)
{
}
private
:
~
nsXMLHttpRequestXPCOMifier
(
)
{
if
(
mXHR
)
{
mXHR
-
>
mXPCOMifier
=
nullptr
;
}
}
public
:
NS_FORWARD_NSISTREAMLISTENER
(
mXHR
-
>
)
NS_FORWARD_NSIREQUESTOBSERVER
(
mXHR
-
>
)
NS_FORWARD_NSICHANNELEVENTSINK
(
mXHR
-
>
)
NS_FORWARD_NSIASYNCVERIFYREDIRECTCALLBACK
(
mXHR
-
>
)
NS_FORWARD_NSIPROGRESSEVENTSINK
(
mXHR
-
>
)
NS_FORWARD_NSITIMERCALLBACK
(
mXHR
-
>
)
NS_DECL_NSIINTERFACEREQUESTOR
private
:
RefPtr
<
XMLHttpRequestMainThread
>
mXHR
;
}
;
class
nsXHRParseEndListener
:
public
nsIDOMEventListener
{
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
HandleEvent
(
nsIDOMEvent
*
event
)
override
{
nsCOMPtr
<
nsIXMLHttpRequest
>
xhr
=
do_QueryReferent
(
mXHR
)
;
if
(
xhr
)
{
static_cast
<
XMLHttpRequestMainThread
*
>
(
xhr
.
get
(
)
)
-
>
ChangeStateToDone
(
)
;
}
mXHR
=
nullptr
;
return
NS_OK
;
}
explicit
nsXHRParseEndListener
(
nsIXMLHttpRequest
*
aXHR
)
:
mXHR
(
do_GetWeakReference
(
aXHR
)
)
{
}
private
:
virtual
~
nsXHRParseEndListener
(
)
{
}
nsWeakPtr
mXHR
;
}
;
}
}
#
endif
