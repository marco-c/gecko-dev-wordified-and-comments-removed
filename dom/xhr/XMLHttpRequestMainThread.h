#
ifndef
mozilla_dom_XMLHttpRequestMainThread_h
#
define
mozilla_dom_XMLHttpRequestMainThread_h
#
include
<
bitset
>
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIXMLHttpRequest
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIHttpHeaderVisitor
.
h
"
#
include
"
nsIProgressEventSink
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsISizeOfEventTarget
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
dom
/
XMLHttpRequest
.
h
"
#
include
"
mozilla
/
dom
/
XMLHttpRequestBinding
.
h
"
#
include
"
mozilla
/
dom
/
XMLHttpRequestEventTarget
.
h
"
#
include
"
mozilla
/
dom
/
XMLHttpRequestString
.
h
"
#
ifdef
Status
#
undef
Status
#
endif
class
nsIJARChannel
;
class
nsILoadGroup
;
class
nsIUnicodeDecoder
;
class
nsIJSID
;
namespace
mozilla
{
namespace
dom
{
class
Blob
;
class
BlobSet
;
class
FormData
;
class
MutableBlobStorage
;
class
URLSearchParams
;
class
XMLHttpRequestUpload
;
struct
OriginAttributesDictionary
;
class
ArrayBufferBuilder
{
uint8_t
*
mDataPtr
;
uint32_t
mCapacity
;
uint32_t
mLength
;
void
*
mMapPtr
;
public
:
ArrayBufferBuilder
(
)
;
~
ArrayBufferBuilder
(
)
;
void
reset
(
)
;
bool
setCapacity
(
uint32_t
aNewCap
)
;
bool
append
(
const
uint8_t
*
aNewData
uint32_t
aDataLen
uint32_t
aMaxGrowth
=
0
)
;
uint32_t
length
(
)
{
return
mLength
;
}
uint32_t
capacity
(
)
{
return
mCapacity
;
}
JSObject
*
getArrayBuffer
(
JSContext
*
aCx
)
;
nsresult
mapToFileInPackage
(
const
nsCString
&
aFile
nsIFile
*
aJarFile
)
;
protected
:
static
bool
areOverlappingRegions
(
const
uint8_t
*
aStart1
uint32_t
aLength1
const
uint8_t
*
aStart2
uint32_t
aLength2
)
;
}
;
class
nsXMLHttpRequestXPCOMifier
;
class
RequestHeaders
{
struct
RequestHeader
{
nsCString
mName
;
nsCString
mValue
;
}
;
nsTArray
<
RequestHeader
>
mHeaders
;
RequestHeader
*
Find
(
const
nsACString
&
aName
)
;
public
:
class
CharsetIterator
{
bool
mValid
;
int32_t
mCurPos
mCurLen
mCutoff
;
nsACString
&
mSource
;
public
:
explicit
CharsetIterator
(
nsACString
&
aSource
)
;
bool
Equals
(
const
nsACString
&
aOther
const
nsCStringComparator
&
aCmp
)
const
;
void
Replace
(
const
nsACString
&
aReplacement
)
;
bool
Next
(
)
;
}
;
bool
Has
(
const
char
*
aName
)
;
bool
Has
(
const
nsACString
&
aName
)
;
void
Get
(
const
char
*
aName
nsACString
&
aValue
)
;
void
Get
(
const
nsACString
&
aName
nsACString
&
aValue
)
;
void
Set
(
const
char
*
aName
const
nsACString
&
aValue
)
;
void
Set
(
const
nsACString
&
aName
const
nsACString
&
aValue
)
;
void
MergeOrSet
(
const
char
*
aName
const
nsACString
&
aValue
)
;
void
MergeOrSet
(
const
nsACString
&
aName
const
nsACString
&
aValue
)
;
void
Clear
(
)
;
void
ApplyToChannel
(
nsIHttpChannel
*
aChannel
)
const
;
void
GetCORSUnsafeHeaders
(
nsTArray
<
nsCString
>
&
aArray
)
const
;
}
;
class
XMLHttpRequestMainThread
final
:
public
XMLHttpRequest
public
nsIXMLHttpRequest
public
nsIJSXMLHttpRequest
public
nsIStreamListener
public
nsIChannelEventSink
public
nsIProgressEventSink
public
nsIInterfaceRequestor
public
nsSupportsWeakReference
public
nsITimerCallback
public
nsISizeOfEventTarget
{
friend
class
nsXHRParseEndListener
;
friend
class
nsXMLHttpRequestXPCOMifier
;
public
:
enum
class
ProgressEventType
:
uint8_t
{
loadstart
progress
error
abort
timeout
load
loadend
ENUM_MAX
}
;
XMLHttpRequestMainThread
(
)
;
void
Construct
(
nsIPrincipal
*
aPrincipal
nsIGlobalObject
*
aGlobalObject
nsIURI
*
aBaseURI
=
nullptr
nsILoadGroup
*
aLoadGroup
=
nullptr
)
{
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT_IF
(
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
aGlobalObject
)
win
-
>
IsInnerWindow
(
)
)
;
mPrincipal
=
aPrincipal
;
BindToOwner
(
aGlobalObject
)
;
mBaseURI
=
aBaseURI
;
mLoadGroup
=
aLoadGroup
;
}
void
InitParameters
(
bool
aAnon
bool
aSystem
)
;
void
SetParameters
(
bool
aAnon
bool
aSystem
)
{
mIsAnon
=
aAnon
|
|
aSystem
;
mIsSystem
=
aSystem
;
}
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIXMLHTTPREQUEST
NS_FORWARD_NSIXMLHTTPREQUESTEVENTTARGET
(
XMLHttpRequestEventTarget
:
:
)
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIPROGRESSEVENTSINK
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSITIMERCALLBACK
virtual
size_t
SizeOfEventTargetIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
override
;
NS_REALLY_FORWARD_NSIDOMEVENTTARGET
(
XMLHttpRequestEventTarget
)
virtual
uint16_t
ReadyState
(
)
const
override
;
nsresult
CreateChannel
(
)
;
nsresult
InitiateFetch
(
nsIInputStream
*
aUploadStream
int64_t
aUploadLength
nsACString
&
aUploadContentType
)
;
virtual
void
Open
(
const
nsACString
&
aMethod
const
nsAString
&
aUrl
ErrorResult
&
aRv
)
override
;
virtual
void
Open
(
const
nsACString
&
aMethod
const
nsAString
&
aUrl
bool
aAsync
const
nsAString
&
aUsername
const
nsAString
&
aPassword
ErrorResult
&
aRv
)
override
;
nsresult
Open
(
const
nsACString
&
aMethod
const
nsACString
&
aUrl
bool
aAsync
const
nsAString
&
aUsername
const
nsAString
&
aPassword
)
;
virtual
void
SetRequestHeader
(
const
nsACString
&
aName
const
nsACString
&
aValue
ErrorResult
&
aRv
)
override
{
aRv
=
SetRequestHeader
(
aName
aValue
)
;
}
virtual
uint32_t
Timeout
(
)
const
override
{
return
mTimeoutMilliseconds
;
}
virtual
void
SetTimeout
(
uint32_t
aTimeout
ErrorResult
&
aRv
)
override
;
virtual
bool
WithCredentials
(
)
const
override
;
virtual
void
SetWithCredentials
(
bool
aWithCredentials
ErrorResult
&
aRv
)
override
;
virtual
XMLHttpRequestUpload
*
GetUpload
(
ErrorResult
&
aRv
)
override
;
private
:
virtual
~
XMLHttpRequestMainThread
(
)
;
class
RequestBodyBase
{
public
:
virtual
nsresult
GetAsStream
(
nsIInputStream
*
*
aResult
uint64_t
*
aContentLength
nsACString
&
aContentType
nsACString
&
aCharset
)
const
{
NS_ASSERTION
(
false
"
RequestBodyBase
should
not
be
used
directly
.
"
)
;
return
NS_ERROR_FAILURE
;
}
}
;
template
<
typename
Type
>
class
RequestBody
final
:
public
RequestBodyBase
{
Type
*
mBody
;
public
:
explicit
RequestBody
(
Type
*
aBody
)
:
mBody
(
aBody
)
{
}
nsresult
GetAsStream
(
nsIInputStream
*
*
aResult
uint64_t
*
aContentLength
nsACString
&
aContentType
nsACString
&
aCharset
)
const
override
;
}
;
nsresult
SendInternal
(
const
RequestBodyBase
*
aBody
)
;
bool
IsCrossSiteCORSRequest
(
)
const
;
bool
IsDeniedCrossSiteCORSRequest
(
)
;
void
PopulateNetworkInterfaceId
(
)
;
public
:
virtual
void
Send
(
JSContext
*
ErrorResult
&
aRv
)
override
{
aRv
=
SendInternal
(
nullptr
)
;
}
virtual
void
Send
(
JSContext
*
const
ArrayBuffer
&
aArrayBuffer
ErrorResult
&
aRv
)
override
{
RequestBody
<
const
ArrayBuffer
>
body
(
&
aArrayBuffer
)
;
aRv
=
SendInternal
(
&
body
)
;
}
virtual
void
Send
(
JSContext
*
const
ArrayBufferView
&
aArrayBufferView
ErrorResult
&
aRv
)
override
{
RequestBody
<
const
ArrayBufferView
>
body
(
&
aArrayBufferView
)
;
aRv
=
SendInternal
(
&
body
)
;
}
virtual
void
Send
(
JSContext
*
Blob
&
aBlob
ErrorResult
&
aRv
)
override
{
RequestBody
<
Blob
>
body
(
&
aBlob
)
;
aRv
=
SendInternal
(
&
body
)
;
}
virtual
void
Send
(
JSContext
*
URLSearchParams
&
aURLSearchParams
ErrorResult
&
aRv
)
override
{
RequestBody
<
URLSearchParams
>
body
(
&
aURLSearchParams
)
;
aRv
=
SendInternal
(
&
body
)
;
}
virtual
void
Send
(
JSContext
*
nsIDocument
&
aDoc
ErrorResult
&
aRv
)
override
{
RequestBody
<
nsIDocument
>
body
(
&
aDoc
)
;
aRv
=
SendInternal
(
&
body
)
;
}
virtual
void
Send
(
JSContext
*
aCx
const
nsAString
&
aString
ErrorResult
&
aRv
)
override
{
if
(
DOMStringIsNull
(
aString
)
)
{
Send
(
aCx
aRv
)
;
}
else
{
RequestBody
<
const
nsAString
>
body
(
&
aString
)
;
aRv
=
SendInternal
(
&
body
)
;
}
}
virtual
void
Send
(
JSContext
*
FormData
&
aFormData
ErrorResult
&
aRv
)
override
{
RequestBody
<
FormData
>
body
(
&
aFormData
)
;
aRv
=
SendInternal
(
&
body
)
;
}
virtual
void
Send
(
JSContext
*
aCx
nsIInputStream
*
aStream
ErrorResult
&
aRv
)
override
{
NS_ASSERTION
(
aStream
"
Null
should
go
to
string
version
"
)
;
RequestBody
<
nsIInputStream
>
body
(
aStream
)
;
aRv
=
SendInternal
(
&
body
)
;
}
void
Abort
(
)
{
ErrorResult
rv
;
Abort
(
rv
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
)
;
}
virtual
void
Abort
(
ErrorResult
&
aRv
)
override
;
virtual
void
GetResponseURL
(
nsAString
&
aUrl
)
override
;
virtual
uint32_t
GetStatus
(
ErrorResult
&
aRv
)
override
;
virtual
void
GetStatusText
(
nsACString
&
aStatusText
ErrorResult
&
aRv
)
override
;
virtual
void
GetResponseHeader
(
const
nsACString
&
aHeader
nsACString
&
aResult
ErrorResult
&
aRv
)
override
;
void
GetResponseHeader
(
const
nsAString
&
aHeader
nsAString
&
aResult
ErrorResult
&
aRv
)
{
nsAutoCString
result
;
GetResponseHeader
(
NS_ConvertUTF16toUTF8
(
aHeader
)
result
aRv
)
;
if
(
result
.
IsVoid
(
)
)
{
aResult
.
SetIsVoid
(
true
)
;
}
else
{
CopyASCIItoUTF16
(
result
aResult
)
;
}
}
virtual
void
GetAllResponseHeaders
(
nsACString
&
aResponseHeaders
ErrorResult
&
aRv
)
override
;
bool
IsSafeHeader
(
const
nsACString
&
aHeaderName
NotNull
<
nsIHttpChannel
*
>
aHttpChannel
)
const
;
virtual
void
OverrideMimeType
(
const
nsAString
&
aMimeType
ErrorResult
&
aRv
)
override
;
virtual
XMLHttpRequestResponseType
ResponseType
(
)
const
override
{
return
XMLHttpRequestResponseType
(
mResponseType
)
;
}
virtual
void
SetResponseType
(
XMLHttpRequestResponseType
aType
ErrorResult
&
aRv
)
override
;
virtual
void
GetResponse
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResponse
ErrorResult
&
aRv
)
override
;
virtual
void
GetResponseText
(
nsAString
&
aResponseText
ErrorResult
&
aRv
)
override
;
void
GetResponseText
(
XMLHttpRequestStringSnapshot
&
aSnapshot
ErrorResult
&
aRv
)
;
virtual
nsIDocument
*
GetResponseXML
(
ErrorResult
&
aRv
)
override
;
virtual
bool
MozBackgroundRequest
(
)
const
override
;
virtual
void
SetMozBackgroundRequest
(
bool
aMozBackgroundRequest
ErrorResult
&
aRv
)
override
;
virtual
bool
MozAnon
(
)
const
override
;
virtual
bool
MozSystem
(
)
const
override
;
virtual
nsIChannel
*
GetChannel
(
)
const
override
{
return
mChannel
;
}
virtual
void
GetNetworkInterfaceId
(
nsACString
&
aId
)
const
override
{
aId
=
mNetworkInterfaceId
;
}
virtual
void
SetNetworkInterfaceId
(
const
nsACString
&
aId
)
override
{
mNetworkInterfaceId
=
aId
;
}
virtual
void
GetInterface
(
JSContext
*
aCx
nsIJSID
*
aIID
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aRv
)
override
;
nsresult
FireReadystatechangeEvent
(
)
;
void
DispatchProgressEvent
(
DOMEventTargetHelper
*
aTarget
const
ProgressEventType
aType
int64_t
aLoaded
int64_t
aTotal
)
;
nsresult
Init
(
)
;
nsresult
init
(
nsIPrincipal
*
principal
nsPIDOMWindowInner
*
globalObject
nsIURI
*
baseURI
)
;
void
SetRequestObserver
(
nsIRequestObserver
*
aObserver
)
;
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS_INHERITED
(
XMLHttpRequestMainThread
XMLHttpRequest
)
bool
AllowUploadProgress
(
)
;
virtual
void
DisconnectFromOwner
(
)
override
;
static
void
SetDontWarnAboutSyncXHR
(
bool
aVal
)
{
sDontWarnAboutSyncXHR
=
aVal
;
}
static
bool
DontWarnAboutSyncXHR
(
)
{
return
sDontWarnAboutSyncXHR
;
}
virtual
void
SetOriginAttributes
(
const
mozilla
:
:
dom
:
:
OriginAttributesDictionary
&
aAttrs
)
override
;
protected
:
enum
class
State
:
uint8_t
{
unsent
opened
headers_received
loading
done
}
;
nsresult
DetectCharset
(
)
;
nsresult
AppendToResponseText
(
const
char
*
aBuffer
uint32_t
aBufferLen
)
;
static
nsresult
StreamReaderFunc
(
nsIInputStream
*
in
void
*
closure
const
char
*
fromRawSegment
uint32_t
toOffset
uint32_t
count
uint32_t
*
writeCount
)
;
nsresult
CreateResponseParsedJSON
(
JSContext
*
aCx
)
;
void
CreatePartialBlob
(
ErrorResult
&
aRv
)
;
bool
CreateDOMBlob
(
nsIRequest
*
request
)
;
nsresult
ChangeState
(
State
aState
bool
aBroadcast
=
true
)
;
already_AddRefed
<
nsILoadGroup
>
GetLoadGroup
(
)
const
;
nsIURI
*
GetBaseURI
(
)
;
already_AddRefed
<
nsIHttpChannel
>
GetCurrentHttpChannel
(
)
;
already_AddRefed
<
nsIJARChannel
>
GetCurrentJARChannel
(
)
;
void
TruncateResponseText
(
)
;
bool
IsSystemXHR
(
)
const
;
bool
InUploadPhase
(
)
const
;
void
OnBodyParseEnd
(
)
;
void
ChangeStateToDone
(
)
;
void
StartProgressEventTimer
(
)
;
void
StopProgressEventTimer
(
)
;
nsresult
OnRedirectVerifyCallback
(
nsresult
result
)
;
already_AddRefed
<
nsXMLHttpRequestXPCOMifier
>
EnsureXPCOMifier
(
)
;
nsCOMPtr
<
nsISupports
>
mContext
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsCString
mRequestMethod
;
nsCOMPtr
<
nsIURI
>
mRequestURL
;
nsCOMPtr
<
nsIDocument
>
mResponseXML
;
nsCOMPtr
<
nsIStreamListener
>
mXMLParserStreamListener
;
class
nsHeaderVisitor
:
public
nsIHttpHeaderVisitor
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIHTTPHEADERVISITOR
nsHeaderVisitor
(
const
XMLHttpRequestMainThread
&
aXMLHttpRequest
NotNull
<
nsIHttpChannel
*
>
aHttpChannel
)
:
mXHR
(
aXMLHttpRequest
)
mHttpChannel
(
aHttpChannel
)
{
}
const
nsACString
&
Headers
(
)
{
return
mHeaders
;
}
private
:
virtual
~
nsHeaderVisitor
(
)
{
}
nsCString
mHeaders
;
const
XMLHttpRequestMainThread
&
mXHR
;
NotNull
<
nsCOMPtr
<
nsIHttpChannel
>
>
mHttpChannel
;
}
;
nsCString
mResponseBody
;
XMLHttpRequestString
mResponseText
;
uint32_t
mResponseBodyDecodedPos
;
nsCOMPtr
<
nsIUnicodeDecoder
>
mDecoder
;
nsCString
mResponseCharset
;
void
MatchCharsetAndDecoderToResponseDocument
(
)
;
XMLHttpRequestResponseType
mResponseType
;
RefPtr
<
Blob
>
mResponseBlob
;
RefPtr
<
Blob
>
mDOMBlob
;
nsAutoPtr
<
MutableBlobStorage
>
mBlobStorage
;
nsAutoPtr
<
BlobSet
>
mBlobSet
;
nsString
mOverrideMimeType
;
nsCOMPtr
<
nsIInterfaceRequestor
>
mNotificationCallbacks
;
nsCOMPtr
<
nsIChannelEventSink
>
mChannelEventSink
;
nsCOMPtr
<
nsIProgressEventSink
>
mProgressEventSink
;
nsIRequestObserver
*
mRequestObserver
;
nsCOMPtr
<
nsIURI
>
mBaseURI
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
;
State
mState
;
bool
mFlagSynchronous
;
bool
mFlagAborted
;
bool
mFlagParseBody
;
bool
mFlagSyncLooping
;
bool
mFlagBackgroundRequest
;
bool
mFlagHadUploadListenersOnSend
;
bool
mFlagACwithCredentials
;
bool
mFlagTimedOut
;
bool
mFlagDeleted
;
bool
mFlagSend
;
RefPtr
<
XMLHttpRequestUpload
>
mUpload
;
int64_t
mUploadTransferred
;
int64_t
mUploadTotal
;
bool
mUploadComplete
;
bool
mProgressSinceLastProgressEvent
;
PRTime
mRequestSentTime
;
uint32_t
mTimeoutMilliseconds
;
nsCOMPtr
<
nsITimer
>
mTimeoutTimer
;
void
StartTimeoutTimer
(
)
;
void
HandleTimeoutCallback
(
)
;
bool
mErrorLoad
;
bool
mErrorParsingXML
;
bool
mWaitingForOnStopRequest
;
bool
mProgressTimerIsActive
;
bool
mIsHtml
;
bool
mWarnAboutMultipartHtml
;
bool
mWarnAboutSyncHtml
;
int64_t
mLoadTotal
;
uint64_t
mDataAvailable
;
int64_t
mLoadTransferred
;
nsCOMPtr
<
nsITimer
>
mProgressNotifier
;
void
HandleProgressTimerCallback
(
)
;
bool
mIsSystem
;
bool
mIsAnon
;
nsCString
mNetworkInterfaceId
;
void
CloseRequest
(
)
;
void
CloseRequestWithError
(
const
ProgressEventType
aType
)
;
bool
mFirstStartRequestSeen
;
bool
mInLoadProgressEvent
;
nsCOMPtr
<
nsIAsyncVerifyRedirectCallback
>
mRedirectCallback
;
nsCOMPtr
<
nsIChannel
>
mNewRedirectChannel
;
JS
:
:
Heap
<
JS
:
:
Value
>
mResultJSON
;
ArrayBufferBuilder
mArrayBufferBuilder
;
JS
:
:
Heap
<
JSObject
*
>
mResultArrayBuffer
;
bool
mIsMappedArrayBuffer
;
void
ResetResponse
(
)
;
bool
ShouldBlockAuthPrompt
(
)
;
RequestHeaders
mAuthorRequestHeaders
;
nsXMLHttpRequestXPCOMifier
*
mXPCOMifier
;
static
bool
sDontWarnAboutSyncXHR
;
}
;
class
MOZ_STACK_CLASS
AutoDontWarnAboutSyncXHR
{
public
:
AutoDontWarnAboutSyncXHR
(
)
:
mOldVal
(
XMLHttpRequestMainThread
:
:
DontWarnAboutSyncXHR
(
)
)
{
XMLHttpRequestMainThread
:
:
SetDontWarnAboutSyncXHR
(
true
)
;
}
~
AutoDontWarnAboutSyncXHR
(
)
{
XMLHttpRequestMainThread
:
:
SetDontWarnAboutSyncXHR
(
mOldVal
)
;
}
private
:
bool
mOldVal
;
}
;
class
nsXMLHttpRequestXPCOMifier
final
:
public
nsIStreamListener
public
nsIChannelEventSink
public
nsIAsyncVerifyRedirectCallback
public
nsIProgressEventSink
public
nsIInterfaceRequestor
public
nsITimerCallback
{
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
nsXMLHttpRequestXPCOMifier
nsIStreamListener
)
explicit
nsXMLHttpRequestXPCOMifier
(
XMLHttpRequestMainThread
*
aXHR
)
:
mXHR
(
aXHR
)
{
}
private
:
~
nsXMLHttpRequestXPCOMifier
(
)
{
if
(
mXHR
)
{
mXHR
-
>
mXPCOMifier
=
nullptr
;
}
}
public
:
NS_FORWARD_NSISTREAMLISTENER
(
mXHR
-
>
)
NS_FORWARD_NSIREQUESTOBSERVER
(
mXHR
-
>
)
NS_FORWARD_NSICHANNELEVENTSINK
(
mXHR
-
>
)
NS_FORWARD_NSIASYNCVERIFYREDIRECTCALLBACK
(
mXHR
-
>
)
NS_FORWARD_NSIPROGRESSEVENTSINK
(
mXHR
-
>
)
NS_FORWARD_NSITIMERCALLBACK
(
mXHR
-
>
)
NS_DECL_NSIINTERFACEREQUESTOR
private
:
RefPtr
<
XMLHttpRequestMainThread
>
mXHR
;
}
;
class
nsXHRParseEndListener
:
public
nsIDOMEventListener
{
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
HandleEvent
(
nsIDOMEvent
*
event
)
override
{
nsCOMPtr
<
nsIXMLHttpRequest
>
xhr
=
do_QueryReferent
(
mXHR
)
;
if
(
xhr
)
{
static_cast
<
XMLHttpRequestMainThread
*
>
(
xhr
.
get
(
)
)
-
>
OnBodyParseEnd
(
)
;
}
mXHR
=
nullptr
;
return
NS_OK
;
}
explicit
nsXHRParseEndListener
(
nsIXMLHttpRequest
*
aXHR
)
:
mXHR
(
do_GetWeakReference
(
aXHR
)
)
{
}
private
:
virtual
~
nsXHRParseEndListener
(
)
{
}
nsWeakPtr
mXHR
;
}
;
}
}
#
endif
