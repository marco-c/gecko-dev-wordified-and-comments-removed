#
include
"
XMLHttpRequestMainThread
.
h
"
#
ifndef
XP_WIN
#
include
<
unistd
.
h
>
#
endif
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
dom
/
BlobSet
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
FetchUtil
.
h
"
#
include
"
mozilla
/
dom
/
FormData
.
h
"
#
include
"
mozilla
/
dom
/
URLSearchParams
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
mozilla
/
dom
/
ProgressEvent
.
h
"
#
include
"
nsIJARChannel
.
h
"
#
include
"
nsIJARURI
.
h
"
#
include
"
nsLayoutCID
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsIAuthPrompt
.
h
"
#
include
"
nsIAuthPrompt2
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIUploadChannel
.
h
"
#
include
"
nsIUploadChannel2
.
h
"
#
include
"
nsIDOMSerializer
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIStreamConverterService
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIHTMLDocument
.
h
"
#
include
"
nsIStorageStream
.
h
"
#
include
"
nsIPromptFactory
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsAsyncRedirectVerifyHelper
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
nsIFileChannel
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
dom
/
EncodingUtils
.
h
"
#
include
"
nsIUnicodeDecoder
.
h
"
#
include
"
mozilla
/
dom
/
XMLHttpRequestBinding
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsStreamListenerWrapper
.
h
"
#
include
"
xpcjsid
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
nsZipArchive
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
private
/
pprio
.
h
"
#
include
"
XMLHttpRequestUpload
.
h
"
using
namespace
mozilla
:
:
net
;
namespace
mozilla
{
namespace
dom
{
#
define
XML_HTTP_REQUEST_ARRAYBUFFER_MAX_GROWTH
(
32
*
1024
*
1024
)
#
define
XML_HTTP_REQUEST_ARRAYBUFFER_MIN_SIZE
(
32
*
1024
)
#
define
XML_HTTP_REQUEST_MAX_CONTENT_LENGTH_PREALLOCATE
(
1
*
1024
*
1024
*
1024LL
)
namespace
{
const
nsLiteralString
ProgressEventTypeStrings
[
]
=
{
NS_LITERAL_STRING
(
"
loadstart
"
)
NS_LITERAL_STRING
(
"
progress
"
)
NS_LITERAL_STRING
(
"
error
"
)
NS_LITERAL_STRING
(
"
abort
"
)
NS_LITERAL_STRING
(
"
timeout
"
)
NS_LITERAL_STRING
(
"
load
"
)
NS_LITERAL_STRING
(
"
loadend
"
)
}
;
static_assert
(
MOZ_ARRAY_LENGTH
(
ProgressEventTypeStrings
)
=
=
size_t
(
XMLHttpRequestMainThread
:
:
ProgressEventType
:
:
ENUM_MAX
)
"
Mismatched
lengths
for
ProgressEventTypeStrings
and
ProgressEventType
enums
"
)
;
const
nsString
kLiteralString_readystatechange
=
NS_LITERAL_STRING
(
"
readystatechange
"
)
;
const
nsString
kLiteralString_xmlhttprequest
=
NS_LITERAL_STRING
(
"
xmlhttprequest
"
)
;
const
nsString
kLiteralString_DOMContentLoaded
=
NS_LITERAL_STRING
(
"
DOMContentLoaded
"
)
;
}
#
define
NS_BADCERTHANDLER_CONTRACTID
\
"
mozilla
.
org
/
content
/
xmlhttprequest
-
bad
-
cert
-
handler
;
1
"
#
define
NS_PROGRESS_EVENT_INTERVAL
50
NS_IMPL_ISUPPORTS
(
nsXHRParseEndListener
nsIDOMEventListener
)
class
nsResumeTimeoutsEvent
:
public
Runnable
{
public
:
explicit
nsResumeTimeoutsEvent
(
nsPIDOMWindowInner
*
aWindow
)
:
mWindow
(
aWindow
)
{
}
NS_IMETHOD
Run
(
)
{
mWindow
-
>
ResumeTimeouts
(
false
)
;
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsPIDOMWindowInner
>
mWindow
;
}
;
static
void
AddLoadFlags
(
nsIRequest
*
request
nsLoadFlags
newFlags
)
{
nsLoadFlags
flags
;
request
-
>
GetLoadFlags
(
&
flags
)
;
flags
|
=
newFlags
;
request
-
>
SetLoadFlags
(
flags
)
;
}
bool
XMLHttpRequestMainThread
:
:
sDontWarnAboutSyncXHR
=
false
;
XMLHttpRequestMainThread
:
:
XMLHttpRequestMainThread
(
)
:
mResponseBodyDecodedPos
(
0
)
mResponseType
(
XMLHttpRequestResponseType
:
:
_empty
)
mRequestObserver
(
nullptr
)
mState
(
State
:
:
unsent
)
mFlagSynchronous
(
false
)
mFlagAborted
(
false
)
mFlagParseBody
(
false
)
mFlagSyncLooping
(
false
)
mFlagBackgroundRequest
(
false
)
mFlagHadUploadListenersOnSend
(
false
)
mFlagACwithCredentials
(
false
)
mFlagTimedOut
(
false
)
mFlagDeleted
(
false
)
mFlagSend
(
false
)
mUploadTransferred
(
0
)
mUploadTotal
(
0
)
mUploadComplete
(
true
)
mProgressSinceLastProgressEvent
(
false
)
mRequestSentTime
(
0
)
mTimeoutMilliseconds
(
0
)
mErrorLoad
(
false
)
mWaitingForOnStopRequest
(
false
)
mProgressTimerIsActive
(
false
)
mIsHtml
(
false
)
mWarnAboutSyncHtml
(
false
)
mLoadLengthComputable
(
false
)
mLoadTotal
(
0
)
mIsSystem
(
false
)
mIsAnon
(
false
)
mFirstStartRequestSeen
(
false
)
mInLoadProgressEvent
(
false
)
mResultJSON
(
JS
:
:
UndefinedValue
(
)
)
mResultArrayBuffer
(
nullptr
)
mIsMappedArrayBuffer
(
false
)
mXPCOMifier
(
nullptr
)
{
}
XMLHttpRequestMainThread
:
:
~
XMLHttpRequestMainThread
(
)
{
mFlagDeleted
=
true
;
if
(
(
mState
=
=
State
:
:
opened
&
&
mFlagSend
)
|
|
mState
=
=
State
:
:
loading
)
{
Abort
(
)
;
}
MOZ_ASSERT
(
!
mFlagSyncLooping
"
we
rather
crash
than
hang
"
)
;
mFlagSyncLooping
=
false
;
mResultJSON
.
setUndefined
(
)
;
mResultArrayBuffer
=
nullptr
;
mozilla
:
:
DropJSObjects
(
this
)
;
}
void
XMLHttpRequestMainThread
:
:
RootJSResultObjects
(
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
}
nsresult
XMLHttpRequestMainThread
:
:
Init
(
)
{
nsIScriptSecurityManager
*
secMan
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
nsCOMPtr
<
nsIPrincipal
>
subjectPrincipal
;
if
(
secMan
)
{
secMan
-
>
GetSystemPrincipal
(
getter_AddRefs
(
subjectPrincipal
)
)
;
}
NS_ENSURE_STATE
(
subjectPrincipal
)
;
Construct
(
subjectPrincipal
xpc
:
:
NativeGlobal
(
xpc
:
:
PrivilegedJunkScope
(
)
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
Init
(
nsIPrincipal
*
aPrincipal
nsIGlobalObject
*
aGlobalObject
nsIURI
*
aBaseURI
nsILoadGroup
*
aLoadGroup
)
{
NS_ENSURE_ARG_POINTER
(
aPrincipal
)
;
Construct
(
aPrincipal
aGlobalObject
aBaseURI
aLoadGroup
)
;
return
NS_OK
;
}
void
XMLHttpRequestMainThread
:
:
InitParameters
(
bool
aAnon
bool
aSystem
)
{
if
(
!
aAnon
&
&
!
aSystem
)
{
return
;
}
if
(
!
IsSystemXHR
(
)
&
&
aSystem
)
{
nsIGlobalObject
*
global
=
GetOwnerGlobal
(
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
SetParameters
(
aAnon
false
)
;
return
;
}
nsIPrincipal
*
principal
=
global
-
>
PrincipalOrNull
(
)
;
if
(
NS_WARN_IF
(
!
principal
)
)
{
SetParameters
(
aAnon
false
)
;
return
;
}
nsCOMPtr
<
nsIPermissionManager
>
permMgr
=
services
:
:
GetPermissionManager
(
)
;
if
(
NS_WARN_IF
(
!
permMgr
)
)
{
SetParameters
(
aAnon
false
)
;
return
;
}
uint32_t
permission
;
nsresult
rv
=
permMgr
-
>
TestPermissionFromPrincipal
(
principal
"
systemXHR
"
&
permission
)
;
if
(
NS_FAILED
(
rv
)
|
|
permission
!
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
SetParameters
(
aAnon
false
)
;
return
;
}
}
SetParameters
(
aAnon
aSystem
)
;
}
void
XMLHttpRequestMainThread
:
:
ResetResponse
(
)
{
mResponseXML
=
nullptr
;
mResponseBody
.
Truncate
(
)
;
mResponseText
.
Truncate
(
)
;
mResponseBlob
=
nullptr
;
mDOMBlob
=
nullptr
;
mBlobSet
=
nullptr
;
mResultArrayBuffer
=
nullptr
;
mArrayBufferBuilder
.
reset
(
)
;
mResultJSON
.
setUndefined
(
)
;
mDataAvailable
=
0
;
mLoadTransferred
=
0
;
mResponseBodyDecodedPos
=
0
;
}
void
XMLHttpRequestMainThread
:
:
SetRequestObserver
(
nsIRequestObserver
*
aObserver
)
{
mRequestObserver
=
aObserver
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
XMLHttpRequestMainThread
)
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
XMLHttpRequestMainThread
)
bool
isBlack
=
tmp
-
>
IsBlack
(
)
;
if
(
isBlack
|
|
tmp
-
>
mWaitingForOnStopRequest
)
{
if
(
tmp
-
>
mListenerManager
)
{
tmp
-
>
mListenerManager
-
>
MarkForCC
(
)
;
}
if
(
!
isBlack
&
&
tmp
-
>
PreservingWrapper
(
)
)
{
tmp
-
>
GetWrapper
(
)
;
}
return
true
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
XMLHttpRequestMainThread
)
return
tmp
-
>
IsBlackAndDoesNotNeedTracing
(
static_cast
<
DOMEventTargetHelper
*
>
(
tmp
)
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
XMLHttpRequestMainThread
)
return
tmp
-
>
IsBlack
(
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
XMLHttpRequestMainThread
XMLHttpRequestEventTarget
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mContext
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChannel
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResponseXML
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mXMLParserStreamListener
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResponseBlob
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDOMBlob
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mNotificationCallbacks
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChannelEventSink
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mProgressEventSink
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mUpload
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
XMLHttpRequestMainThread
XMLHttpRequestEventTarget
)
tmp
-
>
mResultArrayBuffer
=
nullptr
;
tmp
-
>
mArrayBufferBuilder
.
reset
(
)
;
tmp
-
>
mResultJSON
.
setUndefined
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mContext
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChannel
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mResponseXML
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mXMLParserStreamListener
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mResponseBlob
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDOMBlob
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mNotificationCallbacks
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChannelEventSink
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mProgressEventSink
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mUpload
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
XMLHttpRequestMainThread
XMLHttpRequestEventTarget
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mResultArrayBuffer
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mResultJSON
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
XMLHttpRequestMainThread
)
NS_INTERFACE_MAP_ENTRY
(
nsIXMLHttpRequest
)
NS_INTERFACE_MAP_ENTRY
(
nsIJSXMLHttpRequest
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequestObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIStreamListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIChannelEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsIProgressEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsITimerCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsISizeOfEventTarget
)
NS_INTERFACE_MAP_END_INHERITING
(
XMLHttpRequestEventTarget
)
NS_IMPL_ADDREF_INHERITED
(
XMLHttpRequestMainThread
XMLHttpRequestEventTarget
)
NS_IMPL_RELEASE_INHERITED
(
XMLHttpRequestMainThread
XMLHttpRequestEventTarget
)
NS_IMPL_EVENT_HANDLER
(
XMLHttpRequestMainThread
readystatechange
)
void
XMLHttpRequestMainThread
:
:
DisconnectFromOwner
(
)
{
XMLHttpRequestEventTarget
:
:
DisconnectFromOwner
(
)
;
Abort
(
)
;
}
size_t
XMLHttpRequestMainThread
:
:
SizeOfEventTargetIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mResponseBody
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
n
+
=
mResponseText
.
SizeOfExcludingThisEvenIfShared
(
aMallocSizeOf
)
;
return
n
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetChannel
(
nsIChannel
*
*
aChannel
)
{
NS_ENSURE_ARG_POINTER
(
aChannel
)
;
NS_IF_ADDREF
(
*
aChannel
=
mChannel
)
;
return
NS_OK
;
}
static
void
LogMessage
(
const
char
*
aWarning
nsPIDOMWindowInner
*
aWindow
)
{
nsCOMPtr
<
nsIDocument
>
doc
;
if
(
aWindow
)
{
doc
=
aWindow
-
>
GetExtantDoc
(
)
;
}
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
DOM
"
)
doc
nsContentUtils
:
:
eDOM_PROPERTIES
aWarning
)
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetResponseXML
(
nsIDOMDocument
*
*
aResponseXML
)
{
ErrorResult
rv
;
nsIDocument
*
responseXML
=
GetResponseXML
(
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
rv
.
StealNSResult
(
)
;
}
if
(
!
responseXML
)
{
*
aResponseXML
=
nullptr
;
return
NS_OK
;
}
return
CallQueryInterface
(
responseXML
aResponseXML
)
;
}
nsIDocument
*
XMLHttpRequestMainThread
:
:
GetResponseXML
(
ErrorResult
&
aRv
)
{
if
(
mResponseType
!
=
XMLHttpRequestResponseType
:
:
_empty
&
&
mResponseType
!
=
XMLHttpRequestResponseType
:
:
Document
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
if
(
mWarnAboutSyncHtml
)
{
mWarnAboutSyncHtml
=
false
;
LogMessage
(
"
HTMLSyncXHRWarning
"
GetOwner
(
)
)
;
}
if
(
mState
!
=
State
:
:
done
)
{
return
nullptr
;
}
return
mResponseXML
;
}
nsresult
XMLHttpRequestMainThread
:
:
DetectCharset
(
)
{
mResponseCharset
.
Truncate
(
)
;
mDecoder
=
nullptr
;
if
(
mResponseType
!
=
XMLHttpRequestResponseType
:
:
_empty
&
&
mResponseType
!
=
XMLHttpRequestResponseType
:
:
Text
&
&
mResponseType
!
=
XMLHttpRequestResponseType
:
:
Json
&
&
mResponseType
!
=
XMLHttpRequestResponseType
:
:
Moz_chunked_text
)
{
return
NS_OK
;
}
nsAutoCString
charsetVal
;
bool
ok
=
mChannel
&
&
NS_SUCCEEDED
(
mChannel
-
>
GetContentCharset
(
charsetVal
)
)
&
&
EncodingUtils
:
:
FindEncodingForLabel
(
charsetVal
mResponseCharset
)
;
if
(
!
ok
|
|
mResponseCharset
.
IsEmpty
(
)
)
{
mResponseCharset
.
AssignLiteral
(
"
UTF
-
8
"
)
;
}
if
(
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Json
&
&
!
mResponseCharset
.
EqualsLiteral
(
"
UTF
-
8
"
)
)
{
LogMessage
(
"
JSONCharsetWarning
"
GetOwner
(
)
)
;
mResponseCharset
.
AssignLiteral
(
"
UTF
-
8
"
)
;
}
mDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
mResponseCharset
)
;
return
NS_OK
;
}
nsresult
XMLHttpRequestMainThread
:
:
AppendToResponseText
(
const
char
*
aSrcBuffer
uint32_t
aSrcBufferLen
)
{
NS_ENSURE_STATE
(
mDecoder
)
;
int32_t
destBufferLen
;
nsresult
rv
=
mDecoder
-
>
GetMaxLength
(
aSrcBuffer
aSrcBufferLen
&
destBufferLen
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
size
=
mResponseText
.
Length
(
)
+
destBufferLen
;
if
(
size
<
(
uint32_t
)
destBufferLen
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
!
mResponseText
.
SetCapacity
(
size
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
char16_t
*
destBuffer
=
mResponseText
.
BeginWriting
(
)
+
mResponseText
.
Length
(
)
;
CheckedInt32
totalChars
=
mResponseText
.
Length
(
)
;
int32_t
srclen
=
(
int32_t
)
aSrcBufferLen
;
int32_t
destlen
=
(
int32_t
)
destBufferLen
;
rv
=
mDecoder
-
>
Convert
(
aSrcBuffer
&
srclen
destBuffer
&
destlen
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
totalChars
+
=
destlen
;
if
(
!
totalChars
.
isValid
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mResponseText
.
SetLength
(
totalChars
.
value
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetResponseText
(
nsAString
&
aResponseText
)
{
ErrorResult
rv
;
nsString
responseText
;
GetResponseText
(
responseText
rv
)
;
aResponseText
=
responseText
;
return
rv
.
StealNSResult
(
)
;
}
void
XMLHttpRequestMainThread
:
:
GetResponseText
(
nsAString
&
aResponseText
ErrorResult
&
aRv
)
{
aResponseText
.
Truncate
(
)
;
if
(
mResponseType
!
=
XMLHttpRequestResponseType
:
:
_empty
&
&
mResponseType
!
=
XMLHttpRequestResponseType
:
:
Text
&
&
mResponseType
!
=
XMLHttpRequestResponseType
:
:
Moz_chunked_text
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Moz_chunked_text
&
&
!
mInLoadProgressEvent
)
{
aResponseText
.
SetIsVoid
(
true
)
;
return
;
}
if
(
mState
!
=
State
:
:
loading
&
&
mState
!
=
State
:
:
done
)
{
return
;
}
if
(
!
mResponseXML
|
|
mResponseBodyDecodedPos
=
=
mResponseBody
.
Length
(
)
)
{
aResponseText
=
mResponseText
;
return
;
}
if
(
mResponseCharset
!
=
mResponseXML
-
>
GetDocumentCharacterSet
(
)
)
{
mResponseCharset
=
mResponseXML
-
>
GetDocumentCharacterSet
(
)
;
mResponseText
.
Truncate
(
)
;
mResponseBodyDecodedPos
=
0
;
mDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
mResponseCharset
)
;
}
NS_ASSERTION
(
mResponseBodyDecodedPos
<
mResponseBody
.
Length
(
)
"
Unexpected
mResponseBodyDecodedPos
"
)
;
aRv
=
AppendToResponseText
(
mResponseBody
.
get
(
)
+
mResponseBodyDecodedPos
mResponseBody
.
Length
(
)
-
mResponseBodyDecodedPos
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
mResponseBodyDecodedPos
=
mResponseBody
.
Length
(
)
;
if
(
mState
=
=
State
:
:
done
)
{
mResponseBody
.
Truncate
(
)
;
mResponseBodyDecodedPos
=
0
;
}
aResponseText
=
mResponseText
;
}
nsresult
XMLHttpRequestMainThread
:
:
CreateResponseParsedJSON
(
JSContext
*
aCx
)
{
if
(
!
aCx
)
{
return
NS_ERROR_FAILURE
;
}
RootJSResultObjects
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
JS_ParseJSON
(
aCx
static_cast
<
const
char16_t
*
>
(
mResponseText
.
get
(
)
)
mResponseText
.
Length
(
)
&
value
)
)
{
return
NS_ERROR_FAILURE
;
}
mResultJSON
=
value
;
return
NS_OK
;
}
void
XMLHttpRequestMainThread
:
:
CreatePartialBlob
(
ErrorResult
&
aRv
)
{
if
(
mDOMBlob
)
{
if
(
mLoadTotal
=
=
mLoadTransferred
)
{
mResponseBlob
=
mDOMBlob
;
}
else
{
mResponseBlob
=
mDOMBlob
-
>
CreateSlice
(
0
mDataAvailable
EmptyString
(
)
aRv
)
;
}
return
;
}
if
(
!
mBlobSet
)
{
return
;
}
nsAutoCString
contentType
;
if
(
mLoadTotal
=
=
mLoadTransferred
)
{
mChannel
-
>
GetContentType
(
contentType
)
;
}
mResponseBlob
=
mBlobSet
-
>
GetBlobInternal
(
GetOwner
(
)
contentType
aRv
)
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetResponseType
(
nsAString
&
aResponseType
)
{
MOZ_ASSERT
(
mResponseType
<
XMLHttpRequestResponseType
:
:
EndGuard_
)
;
const
EnumEntry
&
entry
=
XMLHttpRequestResponseTypeValues
:
:
strings
[
static_cast
<
uint32_t
>
(
mResponseType
)
]
;
aResponseType
.
AssignASCII
(
entry
.
value
entry
.
length
)
;
return
NS_OK
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
SetResponseType
(
const
nsAString
&
aResponseType
)
{
uint32_t
i
=
0
;
for
(
const
EnumEntry
*
entry
=
XMLHttpRequestResponseTypeValues
:
:
strings
;
entry
-
>
value
;
+
+
entry
+
+
i
)
{
if
(
aResponseType
.
EqualsASCII
(
entry
-
>
value
entry
-
>
length
)
)
{
ErrorResult
rv
;
SetResponseType
(
static_cast
<
XMLHttpRequestResponseType
>
(
i
)
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
}
return
NS_OK
;
}
void
XMLHttpRequestMainThread
:
:
SetResponseType
(
XMLHttpRequestResponseType
aResponseType
ErrorResult
&
aRv
)
{
if
(
mState
=
=
State
:
:
loading
|
|
mState
=
=
State
:
:
done
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
HasOrHasHadOwner
(
)
&
&
mState
!
=
State
:
:
unsent
&
&
mFlagSynchronous
)
{
LogMessage
(
"
ResponseTypeSyncXHRWarning
"
GetOwner
(
)
)
;
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_ACCESS_ERR
)
;
return
;
}
if
(
mFlagSynchronous
&
&
(
aResponseType
=
=
XMLHttpRequestResponseType
:
:
Moz_chunked_text
|
|
aResponseType
=
=
XMLHttpRequestResponseType
:
:
Moz_chunked_arraybuffer
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
mResponseType
=
aResponseType
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetResponse
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
{
ErrorResult
rv
;
GetResponse
(
aCx
aResult
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
XMLHttpRequestMainThread
:
:
GetResponse
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResponse
ErrorResult
&
aRv
)
{
switch
(
mResponseType
)
{
case
XMLHttpRequestResponseType
:
:
_empty
:
case
XMLHttpRequestResponseType
:
:
Text
:
case
XMLHttpRequestResponseType
:
:
Moz_chunked_text
:
{
nsString
str
;
aRv
=
GetResponseText
(
str
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
!
xpc
:
:
StringToJsval
(
aCx
str
aResponse
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
return
;
}
case
XMLHttpRequestResponseType
:
:
Arraybuffer
:
case
XMLHttpRequestResponseType
:
:
Moz_chunked_arraybuffer
:
{
if
(
!
(
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Arraybuffer
&
&
mState
=
=
State
:
:
done
)
&
&
!
(
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Moz_chunked_arraybuffer
&
&
mInLoadProgressEvent
)
)
{
aResponse
.
setNull
(
)
;
return
;
}
if
(
!
mResultArrayBuffer
)
{
RootJSResultObjects
(
)
;
mResultArrayBuffer
=
mArrayBufferBuilder
.
getArrayBuffer
(
aCx
)
;
if
(
!
mResultArrayBuffer
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
}
JS
:
:
ExposeObjectToActiveJS
(
mResultArrayBuffer
)
;
aResponse
.
setObject
(
*
mResultArrayBuffer
)
;
return
;
}
case
XMLHttpRequestResponseType
:
:
Blob
:
case
XMLHttpRequestResponseType
:
:
Moz_blob
:
{
if
(
mState
!
=
State
:
:
done
)
{
if
(
mResponseType
!
=
XMLHttpRequestResponseType
:
:
Moz_blob
)
{
aResponse
.
setNull
(
)
;
return
;
}
if
(
!
mResponseBlob
)
{
CreatePartialBlob
(
aRv
)
;
}
}
if
(
!
mResponseBlob
)
{
aResponse
.
setNull
(
)
;
return
;
}
GetOrCreateDOMReflector
(
aCx
mResponseBlob
aResponse
)
;
return
;
}
case
XMLHttpRequestResponseType
:
:
Document
:
{
if
(
!
mResponseXML
|
|
mState
!
=
State
:
:
done
)
{
aResponse
.
setNull
(
)
;
return
;
}
aRv
=
nsContentUtils
:
:
WrapNative
(
aCx
mResponseXML
aResponse
)
;
return
;
}
case
XMLHttpRequestResponseType
:
:
Json
:
{
if
(
mState
!
=
State
:
:
done
)
{
aResponse
.
setNull
(
)
;
return
;
}
if
(
mResultJSON
.
isUndefined
(
)
)
{
aRv
=
CreateResponseParsedJSON
(
aCx
)
;
mResponseText
.
Truncate
(
)
;
if
(
aRv
.
Failed
(
)
)
{
aRv
=
NS_OK
;
JS_ClearPendingException
(
aCx
)
;
mResultJSON
.
setNull
(
)
;
}
}
JS
:
:
ExposeValueToActiveJS
(
mResultJSON
)
;
aResponse
.
set
(
mResultJSON
)
;
return
;
}
default
:
NS_ERROR
(
"
Should
not
happen
"
)
;
}
aResponse
.
setNull
(
)
;
}
bool
XMLHttpRequestMainThread
:
:
IsCrossSiteCORSRequest
(
)
const
{
if
(
!
mChannel
)
{
return
false
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
-
>
GetLoadInfo
(
)
;
MOZ_ASSERT
(
loadInfo
)
;
return
loadInfo
-
>
GetTainting
(
)
=
=
LoadTainting
:
:
CORS
;
}
bool
XMLHttpRequestMainThread
:
:
IsDeniedCrossSiteCORSRequest
(
)
{
if
(
IsCrossSiteCORSRequest
(
)
)
{
nsresult
rv
;
mChannel
-
>
GetStatus
(
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
true
;
}
}
return
false
;
}
void
XMLHttpRequestMainThread
:
:
GetResponseURL
(
nsAString
&
aUrl
)
{
aUrl
.
Truncate
(
)
;
uint16_t
readyState
=
ReadyState
(
)
;
if
(
(
readyState
=
=
UNSENT
|
|
readyState
=
=
OPENED
)
|
|
!
mChannel
)
{
return
;
}
if
(
IsDeniedCrossSiteCORSRequest
(
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
responseUrl
;
mChannel
-
>
GetURI
(
getter_AddRefs
(
responseUrl
)
)
;
if
(
!
responseUrl
)
{
return
;
}
nsAutoCString
temp
;
responseUrl
-
>
GetSpecIgnoringRef
(
temp
)
;
CopyUTF8toUTF16
(
temp
aUrl
)
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetStatus
(
uint32_t
*
aStatus
)
{
ErrorResult
rv
;
*
aStatus
=
GetStatus
(
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
uint32_t
XMLHttpRequestMainThread
:
:
GetStatus
(
ErrorResult
&
aRv
)
{
if
(
IsDeniedCrossSiteCORSRequest
(
)
)
{
return
0
;
}
uint16_t
readyState
=
ReadyState
(
)
;
if
(
readyState
=
=
UNSENT
|
|
readyState
=
=
OPENED
)
{
return
0
;
}
if
(
mErrorLoad
)
{
nsCOMPtr
<
nsIJARChannel
>
jarChannel
=
GetCurrentJARChannel
(
)
;
if
(
jarChannel
)
{
nsresult
status
;
mChannel
-
>
GetStatus
(
&
status
)
;
if
(
status
=
=
NS_ERROR_FILE_NOT_FOUND
)
{
return
404
;
}
else
{
return
500
;
}
}
return
0
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
GetCurrentHttpChannel
(
)
;
if
(
!
httpChannel
)
{
return
200
;
}
uint32_t
status
;
nsresult
rv
=
httpChannel
-
>
GetResponseStatus
(
&
status
)
;
if
(
NS_FAILED
(
rv
)
)
{
status
=
0
;
}
return
status
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetStatusText
(
nsACString
&
aOut
)
{
ErrorResult
rv
;
GetStatusText
(
aOut
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
XMLHttpRequestMainThread
:
:
GetStatusText
(
nsACString
&
aStatusText
ErrorResult
&
aRv
)
{
aStatusText
.
Truncate
(
)
;
if
(
IsDeniedCrossSiteCORSRequest
(
)
)
{
return
;
}
uint16_t
readyState
=
ReadyState
(
)
;
if
(
readyState
=
=
UNSENT
|
|
readyState
=
=
OPENED
)
{
return
;
}
if
(
mErrorLoad
)
{
return
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
GetCurrentHttpChannel
(
)
;
if
(
httpChannel
)
{
httpChannel
-
>
GetResponseStatusText
(
aStatusText
)
;
}
else
{
aStatusText
.
AssignLiteral
(
"
OK
"
)
;
}
}
void
XMLHttpRequestMainThread
:
:
CloseRequest
(
)
{
if
(
mChannel
)
{
mChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
if
(
mTimeoutTimer
)
{
mTimeoutTimer
-
>
Cancel
(
)
;
}
}
void
XMLHttpRequestMainThread
:
:
CloseRequestWithError
(
const
ProgressEventType
aType
)
{
CloseRequest
(
)
;
uint32_t
responseLength
=
mResponseBody
.
Length
(
)
;
ResetResponse
(
)
;
if
(
mFlagDeleted
)
{
mFlagSyncLooping
=
false
;
return
;
}
if
(
mState
!
=
State
:
:
unsent
&
&
!
(
mState
=
=
State
:
:
opened
&
&
!
mFlagSend
)
&
&
mState
!
=
State
:
:
done
)
{
ChangeState
(
State
:
:
done
true
)
;
if
(
!
mFlagSyncLooping
)
{
DispatchProgressEvent
(
this
aType
mLoadLengthComputable
responseLength
mLoadTotal
)
;
if
(
mUpload
&
&
!
mUploadComplete
)
{
mUploadComplete
=
true
;
DispatchProgressEvent
(
mUpload
aType
true
mUploadTransferred
mUploadTotal
)
;
}
}
}
if
(
mFlagAborted
)
{
ChangeState
(
State
:
:
unsent
false
)
;
}
mFlagSyncLooping
=
false
;
}
void
XMLHttpRequestMainThread
:
:
Abort
(
ErrorResult
&
arv
)
{
mFlagAborted
=
true
;
CloseRequestWithError
(
ProgressEventType
:
:
abort
)
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
SlowAbort
(
)
{
Abort
(
)
;
return
NS_OK
;
}
bool
XMLHttpRequestMainThread
:
:
IsSafeHeader
(
const
nsACString
&
aHeader
NotNull
<
nsIHttpChannel
*
>
aHttpChannel
)
const
{
if
(
!
IsSystemXHR
(
)
&
&
nsContentUtils
:
:
IsForbiddenResponseHeader
(
aHeader
)
)
{
NS_WARNING
(
"
blocked
access
to
response
header
"
)
;
return
false
;
}
if
(
!
IsCrossSiteCORSRequest
(
)
)
{
return
true
;
}
if
(
mChannel
)
{
nsresult
status
;
mChannel
-
>
GetStatus
(
&
status
)
;
if
(
NS_FAILED
(
status
)
)
{
return
false
;
}
}
const
char
*
kCrossOriginSafeHeaders
[
]
=
{
"
cache
-
control
"
"
content
-
language
"
"
content
-
type
"
"
expires
"
"
last
-
modified
"
"
pragma
"
}
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
kCrossOriginSafeHeaders
)
;
+
+
i
)
{
if
(
aHeader
.
LowerCaseEqualsASCII
(
kCrossOriginSafeHeaders
[
i
]
)
)
{
return
true
;
}
}
nsAutoCString
headerVal
;
aHttpChannel
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
Access
-
Control
-
Expose
-
Headers
"
)
headerVal
)
;
nsCCharSeparatedTokenizer
exposeTokens
(
headerVal
'
'
)
;
bool
isSafe
=
false
;
while
(
exposeTokens
.
hasMoreTokens
(
)
)
{
const
nsDependentCSubstring
&
token
=
exposeTokens
.
nextToken
(
)
;
if
(
token
.
IsEmpty
(
)
)
{
continue
;
}
if
(
!
NS_IsValidHTTPToken
(
token
)
)
{
return
false
;
}
if
(
aHeader
.
Equals
(
token
nsCaseInsensitiveCStringComparator
(
)
)
)
{
isSafe
=
true
;
}
}
return
isSafe
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetAllResponseHeaders
(
nsACString
&
aOut
)
{
ErrorResult
rv
;
GetAllResponseHeaders
(
aOut
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
XMLHttpRequestMainThread
:
:
GetAllResponseHeaders
(
nsACString
&
aResponseHeaders
ErrorResult
&
aRv
)
{
aResponseHeaders
.
Truncate
(
)
;
if
(
mState
=
=
State
:
:
unsent
|
|
mState
=
=
State
:
:
opened
)
{
return
;
}
if
(
mErrorLoad
)
{
return
;
}
if
(
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
GetCurrentHttpChannel
(
)
)
{
RefPtr
<
nsHeaderVisitor
>
visitor
=
new
nsHeaderVisitor
(
*
this
WrapNotNull
(
httpChannel
)
)
;
if
(
NS_SUCCEEDED
(
httpChannel
-
>
VisitResponseHeaders
(
visitor
)
)
)
{
aResponseHeaders
=
visitor
-
>
Headers
(
)
;
}
return
;
}
if
(
!
mChannel
)
{
return
;
}
nsAutoCString
value
;
if
(
NS_SUCCEEDED
(
mChannel
-
>
GetContentType
(
value
)
)
)
{
aResponseHeaders
.
AppendLiteral
(
"
Content
-
Type
:
"
)
;
aResponseHeaders
.
Append
(
value
)
;
if
(
NS_SUCCEEDED
(
mChannel
-
>
GetContentCharset
(
value
)
)
&
&
!
value
.
IsEmpty
(
)
)
{
aResponseHeaders
.
AppendLiteral
(
"
;
charset
=
"
)
;
aResponseHeaders
.
Append
(
value
)
;
}
aResponseHeaders
.
AppendLiteral
(
"
\
r
\
n
"
)
;
}
nsCOMPtr
<
nsIURI
>
uri
;
bool
isDataURI
;
if
(
NS_FAILED
(
mChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
)
|
|
NS_FAILED
(
uri
-
>
SchemeIs
(
"
data
"
&
isDataURI
)
)
|
|
!
isDataURI
)
{
int64_t
length
;
if
(
NS_SUCCEEDED
(
mChannel
-
>
GetContentLength
(
&
length
)
)
)
{
aResponseHeaders
.
AppendLiteral
(
"
Content
-
Length
:
"
)
;
aResponseHeaders
.
AppendInt
(
length
)
;
aResponseHeaders
.
AppendLiteral
(
"
\
r
\
n
"
)
;
}
}
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetResponseHeader
(
const
nsACString
&
aHeader
nsACString
&
aResult
)
{
ErrorResult
rv
;
GetResponseHeader
(
aHeader
aResult
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
XMLHttpRequestMainThread
:
:
GetResponseHeader
(
const
nsACString
&
header
nsACString
&
_retval
ErrorResult
&
aRv
)
{
_retval
.
SetIsVoid
(
true
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
GetCurrentHttpChannel
(
)
;
if
(
!
httpChannel
)
{
if
(
mState
=
=
State
:
:
unsent
|
|
mState
=
=
State
:
:
opened
)
{
return
;
}
nsresult
status
;
if
(
!
mChannel
|
|
NS_FAILED
(
mChannel
-
>
GetStatus
(
&
status
)
)
|
|
NS_FAILED
(
status
)
)
{
return
;
}
if
(
header
.
LowerCaseEqualsASCII
(
"
content
-
type
"
)
)
{
if
(
NS_FAILED
(
mChannel
-
>
GetContentType
(
_retval
)
)
)
{
_retval
.
SetIsVoid
(
true
)
;
return
;
}
nsCString
value
;
if
(
NS_SUCCEEDED
(
mChannel
-
>
GetContentCharset
(
value
)
)
&
&
!
value
.
IsEmpty
(
)
)
{
_retval
.
AppendLiteral
(
"
;
charset
=
"
)
;
_retval
.
Append
(
value
)
;
}
}
else
if
(
header
.
LowerCaseEqualsASCII
(
"
content
-
length
"
)
)
{
int64_t
length
;
if
(
NS_SUCCEEDED
(
mChannel
-
>
GetContentLength
(
&
length
)
)
)
{
_retval
.
AppendInt
(
length
)
;
}
}
return
;
}
if
(
!
IsSafeHeader
(
header
WrapNotNull
(
httpChannel
)
)
)
{
return
;
}
aRv
=
httpChannel
-
>
GetResponseHeader
(
header
_retval
)
;
if
(
aRv
.
ErrorCodeIs
(
NS_ERROR_NOT_AVAILABLE
)
)
{
_retval
.
SetIsVoid
(
true
)
;
aRv
.
SuppressException
(
)
;
}
}
already_AddRefed
<
nsILoadGroup
>
XMLHttpRequestMainThread
:
:
GetLoadGroup
(
)
const
{
if
(
mFlagBackgroundRequest
)
{
return
nullptr
;
}
if
(
mLoadGroup
)
{
nsCOMPtr
<
nsILoadGroup
>
ref
=
mLoadGroup
;
return
ref
.
forget
(
)
;
}
nsIDocument
*
doc
=
GetDocumentIfCurrent
(
)
;
if
(
doc
)
{
return
doc
-
>
GetDocumentLoadGroup
(
)
;
}
return
nullptr
;
}
nsresult
XMLHttpRequestMainThread
:
:
FireReadystatechangeEvent
(
)
{
RefPtr
<
Event
>
event
=
NS_NewDOMEvent
(
this
nullptr
nullptr
)
;
event
-
>
InitEvent
(
kLiteralString_readystatechange
false
false
)
;
event
-
>
SetTrusted
(
true
)
;
DispatchDOMEvent
(
nullptr
event
nullptr
nullptr
)
;
return
NS_OK
;
}
void
XMLHttpRequestMainThread
:
:
DispatchProgressEvent
(
DOMEventTargetHelper
*
aTarget
const
ProgressEventType
aType
bool
aLengthComputable
int64_t
aLoaded
int64_t
aTotal
)
{
NS_ASSERTION
(
aTarget
"
null
target
"
)
;
if
(
NS_FAILED
(
CheckInnerWindowCorrectness
(
)
)
|
|
(
!
AllowUploadProgress
(
)
&
&
aTarget
=
=
mUpload
)
)
{
return
;
}
ProgressEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mLengthComputable
=
aLengthComputable
;
init
.
mLoaded
=
aLoaded
;
init
.
mTotal
=
(
aTotal
=
=
-
1
)
?
0
:
aTotal
;
const
nsAString
&
typeString
=
ProgressEventTypeStrings
[
(
uint8_t
)
aType
]
;
RefPtr
<
ProgressEvent
>
event
=
ProgressEvent
:
:
Constructor
(
aTarget
typeString
init
)
;
event
-
>
SetTrusted
(
true
)
;
aTarget
-
>
DispatchDOMEvent
(
nullptr
event
nullptr
nullptr
)
;
if
(
aType
=
=
ProgressEventType
:
:
load
|
|
aType
=
=
ProgressEventType
:
:
error
|
|
aType
=
=
ProgressEventType
:
:
timeout
|
|
aType
=
=
ProgressEventType
:
:
abort
)
{
DispatchProgressEvent
(
aTarget
ProgressEventType
:
:
loadend
aLengthComputable
aLoaded
aTotal
)
;
}
}
already_AddRefed
<
nsIHttpChannel
>
XMLHttpRequestMainThread
:
:
GetCurrentHttpChannel
(
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
mChannel
)
;
return
httpChannel
.
forget
(
)
;
}
already_AddRefed
<
nsIJARChannel
>
XMLHttpRequestMainThread
:
:
GetCurrentJARChannel
(
)
{
nsCOMPtr
<
nsIJARChannel
>
appChannel
=
do_QueryInterface
(
mChannel
)
;
return
appChannel
.
forget
(
)
;
}
bool
XMLHttpRequestMainThread
:
:
IsSystemXHR
(
)
const
{
return
mIsSystem
|
|
nsContentUtils
:
:
IsSystemPrincipal
(
mPrincipal
)
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
Open
(
const
nsACString
&
aMethod
const
nsACString
&
aUrl
bool
aAsync
const
nsAString
&
aUsername
const
nsAString
&
aPassword
uint8_t
optional_argc
)
{
Optional
<
bool
>
async
;
if
(
!
optional_argc
)
{
async
.
Construct
(
)
=
true
;
}
else
{
async
.
Construct
(
)
=
aAsync
;
}
Optional
<
nsAString
>
username
;
if
(
optional_argc
>
1
)
{
username
=
&
aUsername
;
}
Optional
<
nsAString
>
password
;
if
(
optional_argc
>
2
)
{
password
=
&
aPassword
;
}
return
OpenInternal
(
aMethod
aUrl
async
username
password
)
;
}
void
XMLHttpRequestMainThread
:
:
Open
(
const
nsACString
&
aMethod
const
nsAString
&
aUrl
ErrorResult
&
aRv
)
{
aRv
=
OpenInternal
(
aMethod
NS_ConvertUTF16toUTF8
(
aUrl
)
Optional
<
bool
>
(
true
)
Optional
<
nsAString
>
(
)
Optional
<
nsAString
>
(
)
)
;
}
void
XMLHttpRequestMainThread
:
:
Open
(
const
nsACString
&
aMethod
const
nsAString
&
aUrl
bool
aAsync
const
Optional
<
nsAString
>
&
aUsername
const
Optional
<
nsAString
>
&
aPassword
ErrorResult
&
aRv
)
{
aRv
=
OpenInternal
(
aMethod
NS_ConvertUTF16toUTF8
(
aUrl
)
Optional
<
bool
>
(
aAsync
)
aUsername
aPassword
)
;
}
nsresult
XMLHttpRequestMainThread
:
:
OpenInternal
(
const
nsACString
&
aMethod
const
nsACString
&
aUrl
const
Optional
<
bool
>
&
aAsync
const
Optional
<
nsAString
>
&
aUsername
const
Optional
<
nsAString
>
&
aPassword
)
{
bool
async
=
aAsync
.
WasPassed
(
)
?
aAsync
.
Value
(
)
:
true
;
if
(
!
async
&
&
!
DontWarnAboutSyncXHR
(
)
&
&
GetOwner
(
)
&
&
GetOwner
(
)
-
>
GetExtantDoc
(
)
)
{
GetOwner
(
)
-
>
GetExtantDoc
(
)
-
>
WarnOnceAbout
(
nsIDocument
:
:
eSyncXMLHttpRequest
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
XMLHTTPREQUEST_ASYNC_OR_SYNC
async
?
0
:
1
)
;
nsCOMPtr
<
nsIDocument
>
responsibleDocument
=
GetDocumentIfCurrent
(
)
;
if
(
!
responsibleDocument
)
{
nsresult
rv
=
CheckInnerWindowCorrectness
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
}
NS_ENSURE_TRUE
(
mPrincipal
NS_ERROR_NOT_INITIALIZED
)
;
nsAutoCString
method
;
nsresult
rv
=
FetchUtil
:
:
GetValidRequestMethod
(
aMethod
method
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIURI
>
baseURI
;
if
(
mBaseURI
)
{
baseURI
=
mBaseURI
;
}
else
if
(
responsibleDocument
)
{
baseURI
=
responsibleDocument
-
>
GetBaseURI
(
)
;
}
nsCOMPtr
<
nsIURI
>
parsedURL
;
rv
=
NS_NewURI
(
getter_AddRefs
(
parsedURL
)
aUrl
nullptr
baseURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_MALFORMED_URI
)
{
return
NS_ERROR_DOM_SYNTAX_ERR
;
}
return
rv
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
CheckInnerWindowCorrectness
(
)
)
)
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
if
(
aAsync
.
WasPassed
(
)
)
{
nsAutoCString
host
;
parsedURL
-
>
GetHost
(
host
)
;
if
(
!
host
.
IsEmpty
(
)
)
{
nsAutoCString
userpass
;
if
(
aUsername
.
WasPassed
(
)
)
{
CopyUTF16toUTF8
(
aUsername
.
Value
(
)
userpass
)
;
}
userpass
.
AppendLiteral
(
"
:
"
)
;
if
(
aPassword
.
WasPassed
(
)
)
{
AppendUTF16toUTF8
(
aPassword
.
Value
(
)
userpass
)
;
}
parsedURL
-
>
SetUserPass
(
userpass
)
;
}
}
if
(
!
async
&
&
HasOrHasHadOwner
(
)
&
&
(
mTimeoutMilliseconds
|
|
mResponseType
!
=
XMLHttpRequestResponseType
:
:
_empty
)
)
{
if
(
mTimeoutMilliseconds
)
{
LogMessage
(
"
TimeoutSyncXHRWarning
"
GetOwner
(
)
)
;
}
if
(
mResponseType
!
=
XMLHttpRequestResponseType
:
:
_empty
)
{
LogMessage
(
"
ResponseTypeSyncXHRWarning
"
GetOwner
(
)
)
;
}
return
NS_ERROR_DOM_INVALID_ACCESS_ERR
;
}
CloseRequest
(
)
;
mFlagSend
=
false
;
mRequestMethod
.
Assign
(
method
)
;
mRequestURL
=
parsedURL
;
mFlagSynchronous
=
!
async
;
mAuthorRequestHeaders
.
Clear
(
)
;
ResetResponse
(
)
;
mFlagHadUploadListenersOnSend
=
false
;
mFlagAborted
=
false
;
mFlagTimedOut
=
false
;
rv
=
InitChannel
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mState
!
=
State
:
:
opened
)
{
mState
=
State
:
:
opened
;
FireReadystatechangeEvent
(
)
;
}
return
NS_OK
;
}
void
XMLHttpRequestMainThread
:
:
PopulateNetworkInterfaceId
(
)
{
if
(
mNetworkInterfaceId
.
IsEmpty
(
)
)
{
return
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
channel
(
do_QueryInterface
(
mChannel
)
)
;
if
(
!
channel
)
{
return
;
}
channel
-
>
SetNetworkInterfaceId
(
mNetworkInterfaceId
)
;
}
NS_METHOD
XMLHttpRequestMainThread
:
:
StreamReaderFunc
(
nsIInputStream
*
in
void
*
closure
const
char
*
fromRawSegment
uint32_t
toOffset
uint32_t
count
uint32_t
*
writeCount
)
{
XMLHttpRequestMainThread
*
xmlHttpRequest
=
static_cast
<
XMLHttpRequestMainThread
*
>
(
closure
)
;
if
(
!
xmlHttpRequest
|
|
!
writeCount
)
{
NS_WARNING
(
"
XMLHttpRequest
cannot
read
from
stream
:
no
closure
or
writeCount
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
NS_OK
;
if
(
xmlHttpRequest
-
>
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Blob
|
|
xmlHttpRequest
-
>
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Moz_blob
)
{
if
(
!
xmlHttpRequest
-
>
mDOMBlob
)
{
if
(
!
xmlHttpRequest
-
>
mBlobSet
)
{
xmlHttpRequest
-
>
mBlobSet
=
new
BlobSet
(
)
;
}
rv
=
xmlHttpRequest
-
>
mBlobSet
-
>
AppendVoidPtr
(
fromRawSegment
count
)
;
}
if
(
xmlHttpRequest
-
>
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Moz_blob
)
{
xmlHttpRequest
-
>
mResponseBlob
=
nullptr
;
}
}
else
if
(
(
xmlHttpRequest
-
>
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Arraybuffer
&
&
!
xmlHttpRequest
-
>
mIsMappedArrayBuffer
)
|
|
xmlHttpRequest
-
>
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Moz_chunked_arraybuffer
)
{
if
(
xmlHttpRequest
-
>
mArrayBufferBuilder
.
capacity
(
)
=
=
0
)
xmlHttpRequest
-
>
mArrayBufferBuilder
.
setCapacity
(
PR_MAX
(
count
XML_HTTP_REQUEST_ARRAYBUFFER_MIN_SIZE
)
)
;
xmlHttpRequest
-
>
mArrayBufferBuilder
.
append
(
reinterpret_cast
<
const
uint8_t
*
>
(
fromRawSegment
)
count
XML_HTTP_REQUEST_ARRAYBUFFER_MAX_GROWTH
)
;
}
else
if
(
xmlHttpRequest
-
>
mResponseType
=
=
XMLHttpRequestResponseType
:
:
_empty
&
&
xmlHttpRequest
-
>
mResponseXML
)
{
if
(
!
xmlHttpRequest
-
>
mResponseBody
.
Append
(
fromRawSegment
count
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
else
if
(
xmlHttpRequest
-
>
mResponseType
=
=
XMLHttpRequestResponseType
:
:
_empty
|
|
xmlHttpRequest
-
>
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Text
|
|
xmlHttpRequest
-
>
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Json
|
|
xmlHttpRequest
-
>
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Moz_chunked_text
)
{
NS_ASSERTION
(
!
xmlHttpRequest
-
>
mResponseXML
"
We
shouldn
'
t
be
parsing
a
doc
here
"
)
;
xmlHttpRequest
-
>
AppendToResponseText
(
fromRawSegment
count
)
;
}
if
(
xmlHttpRequest
-
>
mFlagParseBody
)
{
nsCOMPtr
<
nsIInputStream
>
copyStream
;
rv
=
NS_NewByteInputStream
(
getter_AddRefs
(
copyStream
)
fromRawSegment
count
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
xmlHttpRequest
-
>
mXMLParserStreamListener
)
{
NS_ASSERTION
(
copyStream
"
NS_NewByteInputStream
lied
"
)
;
nsresult
parsingResult
=
xmlHttpRequest
-
>
mXMLParserStreamListener
-
>
OnDataAvailable
(
xmlHttpRequest
-
>
mChannel
xmlHttpRequest
-
>
mContext
copyStream
toOffset
count
)
;
if
(
NS_FAILED
(
parsingResult
)
)
{
xmlHttpRequest
-
>
mFlagParseBody
=
false
;
}
}
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
writeCount
=
count
;
}
else
{
*
writeCount
=
0
;
}
return
rv
;
}
bool
XMLHttpRequestMainThread
:
:
CreateDOMBlob
(
nsIRequest
*
request
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsCOMPtr
<
nsIFileChannel
>
fc
=
do_QueryInterface
(
request
)
;
if
(
fc
)
{
fc
-
>
GetFile
(
getter_AddRefs
(
file
)
)
;
}
if
(
!
file
)
return
false
;
nsAutoCString
contentType
;
mChannel
-
>
GetContentType
(
contentType
)
;
mDOMBlob
=
File
:
:
CreateFromFile
(
GetOwner
(
)
file
EmptyString
(
)
NS_ConvertASCIItoUTF16
(
contentType
)
)
;
mBlobSet
=
nullptr
;
NS_ASSERTION
(
mResponseBody
.
IsEmpty
(
)
"
mResponseBody
should
be
empty
"
)
;
return
true
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
OnDataAvailable
(
nsIRequest
*
request
nsISupports
*
ctxt
nsIInputStream
*
inStr
uint64_t
sourceOffset
uint32_t
count
)
{
NS_ENSURE_ARG_POINTER
(
inStr
)
;
MOZ_ASSERT
(
mContext
.
get
(
)
=
=
ctxt
"
start
context
different
from
OnDataAvailable
context
"
)
;
mProgressSinceLastProgressEvent
=
true
;
bool
cancelable
=
false
;
if
(
(
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Blob
|
|
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Moz_blob
)
&
&
!
mDOMBlob
)
{
cancelable
=
CreateDOMBlob
(
request
)
;
}
uint32_t
totalRead
;
nsresult
rv
=
inStr
-
>
ReadSegments
(
XMLHttpRequestMainThread
:
:
StreamReaderFunc
(
void
*
)
this
count
&
totalRead
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cancelable
)
{
ErrorResult
error
;
mDataAvailable
=
mDOMBlob
-
>
GetSize
(
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
ChangeState
(
State
:
:
loading
)
;
return
request
-
>
Cancel
(
NS_OK
)
;
}
mDataAvailable
+
=
totalRead
;
ChangeState
(
State
:
:
loading
)
;
MaybeDispatchProgressEvents
(
false
)
;
return
NS_OK
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
OnStartRequest
(
nsIRequest
*
request
nsISupports
*
ctxt
)
{
PROFILER_LABEL
(
"
XMLHttpRequestMainThread
"
"
OnStartRequest
"
js
:
:
ProfileEntry
:
:
Category
:
:
NETWORK
)
;
nsresult
rv
=
NS_OK
;
if
(
!
mFirstStartRequestSeen
&
&
mRequestObserver
)
{
mFirstStartRequestSeen
=
true
;
mRequestObserver
-
>
OnStartRequest
(
request
ctxt
)
;
}
if
(
request
!
=
mChannel
)
{
return
NS_OK
;
}
if
(
mState
=
=
State
:
:
unsent
)
{
return
NS_OK
;
}
if
(
mFlagAborted
)
{
NS_ERROR
(
"
Ugh
still
getting
data
on
an
aborted
XMLHttpRequest
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
mFlagTimedOut
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
request
)
)
;
NS_ENSURE_TRUE
(
channel
NS_ERROR_UNEXPECTED
)
;
nsresult
status
;
request
-
>
GetStatus
(
&
status
)
;
mErrorLoad
=
mErrorLoad
|
|
NS_FAILED
(
status
)
;
if
(
mUpload
&
&
!
mUploadComplete
&
&
!
mErrorLoad
&
&
!
mFlagSynchronous
)
{
if
(
mProgressTimerIsActive
)
{
mProgressTimerIsActive
=
false
;
mProgressNotifier
-
>
Cancel
(
)
;
}
if
(
mUploadTransferred
<
mUploadTotal
)
{
mUploadTransferred
=
mUploadTotal
;
mProgressSinceLastProgressEvent
=
true
;
mUploadLengthComputable
=
true
;
MaybeDispatchProgressEvents
(
true
)
;
}
mUploadComplete
=
true
;
DispatchProgressEvent
(
mUpload
ProgressEventType
:
:
load
true
mUploadTotal
mUploadTotal
)
;
}
mContext
=
ctxt
;
mFlagParseBody
=
true
;
ChangeState
(
State
:
:
headers_received
)
;
ResetResponse
(
)
;
if
(
!
mOverrideMimeType
.
IsEmpty
(
)
)
{
channel
-
>
SetContentType
(
NS_ConvertUTF16toUTF8
(
mOverrideMimeType
)
)
;
}
DetectCharset
(
)
;
if
(
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Arraybuffer
&
&
NS_SUCCEEDED
(
status
)
)
{
if
(
mIsMappedArrayBuffer
)
{
nsCOMPtr
<
nsIJARChannel
>
jarChannel
=
do_QueryInterface
(
channel
)
;
if
(
jarChannel
)
{
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
file
;
nsAutoCString
scheme
;
uri
-
>
GetScheme
(
scheme
)
;
if
(
scheme
.
LowerCaseEqualsLiteral
(
"
app
"
)
)
{
uri
-
>
GetPath
(
file
)
;
file
.
Trim
(
"
/
"
true
false
false
)
;
}
else
if
(
scheme
.
LowerCaseEqualsLiteral
(
"
jar
"
)
)
{
nsCOMPtr
<
nsIJARURI
>
jarURI
=
do_QueryInterface
(
uri
)
;
if
(
jarURI
)
{
jarURI
-
>
GetJAREntry
(
file
)
;
}
}
nsCOMPtr
<
nsIFile
>
jarFile
;
jarChannel
-
>
GetJarFile
(
getter_AddRefs
(
jarFile
)
)
;
if
(
!
jarFile
)
{
mIsMappedArrayBuffer
=
false
;
}
else
{
rv
=
mArrayBufferBuilder
.
mapToFileInPackage
(
file
jarFile
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mIsMappedArrayBuffer
=
false
;
}
else
{
channel
-
>
SetContentType
(
NS_LITERAL_CSTRING
(
"
application
/
mem
-
mapped
"
)
)
;
}
}
}
}
}
if
(
!
mIsMappedArrayBuffer
)
{
int64_t
contentLength
;
rv
=
channel
-
>
GetContentLength
(
&
contentLength
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
contentLength
>
0
&
&
contentLength
<
XML_HTTP_REQUEST_MAX_CONTENT_LENGTH_PREALLOCATE
)
{
mArrayBufferBuilder
.
setCapacity
(
static_cast
<
int32_t
>
(
contentLength
)
)
;
}
}
}
bool
parseBody
=
mResponseType
=
=
XMLHttpRequestResponseType
:
:
_empty
|
|
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Document
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
mChannel
)
)
;
if
(
parseBody
&
&
httpChannel
)
{
nsAutoCString
method
;
httpChannel
-
>
GetRequestMethod
(
method
)
;
parseBody
=
!
method
.
EqualsLiteral
(
"
HEAD
"
)
;
}
mIsHtml
=
false
;
mWarnAboutSyncHtml
=
false
;
if
(
parseBody
&
&
NS_SUCCEEDED
(
status
)
)
{
nsAutoCString
type
;
channel
-
>
GetContentType
(
type
)
;
if
(
(
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Document
)
&
&
type
.
EqualsLiteral
(
"
text
/
html
"
)
)
{
if
(
mFlagSynchronous
)
{
mWarnAboutSyncHtml
=
true
;
mFlagParseBody
=
false
;
}
else
{
mIsHtml
=
true
;
}
}
else
if
(
!
(
type
.
EqualsLiteral
(
"
text
/
xml
"
)
|
|
type
.
EqualsLiteral
(
"
application
/
xml
"
)
|
|
type
.
RFind
(
"
+
xml
"
true
-
1
4
)
!
=
kNotFound
)
)
{
mFlagParseBody
=
false
;
}
}
else
{
mFlagParseBody
=
false
;
}
if
(
mFlagParseBody
)
{
nsCOMPtr
<
nsIURI
>
baseURI
docURI
;
rv
=
mChannel
-
>
GetURI
(
getter_AddRefs
(
docURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
baseURI
=
docURI
;
nsCOMPtr
<
nsIDocument
>
doc
=
GetDocumentIfCurrent
(
)
;
nsCOMPtr
<
nsIURI
>
chromeXHRDocURI
chromeXHRDocBaseURI
;
if
(
doc
)
{
chromeXHRDocURI
=
doc
-
>
GetDocumentURI
(
)
;
chromeXHRDocBaseURI
=
doc
-
>
GetBaseURI
(
)
;
}
else
{
if
(
NS_WARN_IF
(
NS_FAILED
(
CheckInnerWindowCorrectness
(
)
)
)
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
}
const
nsAString
&
emptyStr
=
EmptyString
(
)
;
nsCOMPtr
<
nsIDOMDocument
>
responseDoc
;
nsIGlobalObject
*
global
=
DOMEventTargetHelper
:
:
GetParentObject
(
)
;
nsCOMPtr
<
nsIPrincipal
>
requestingPrincipal
;
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
channel
getter_AddRefs
(
requestingPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
NS_NewDOMDocument
(
getter_AddRefs
(
responseDoc
)
emptyStr
emptyStr
nullptr
docURI
baseURI
requestingPrincipal
true
global
mIsHtml
?
DocumentFlavorHTML
:
DocumentFlavorLegacyGuess
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mResponseXML
=
do_QueryInterface
(
responseDoc
)
;
mResponseXML
-
>
SetChromeXHRDocURI
(
chromeXHRDocURI
)
;
mResponseXML
-
>
SetChromeXHRDocBaseURI
(
chromeXHRDocBaseURI
)
;
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
mPrincipal
)
)
{
mResponseXML
-
>
ForceEnableXULXBL
(
)
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
-
>
GetLoadInfo
(
)
;
MOZ_ASSERT
(
loadInfo
)
;
bool
isCrossSite
=
loadInfo
-
>
GetTainting
(
)
!
=
LoadTainting
:
:
Basic
;
if
(
isCrossSite
)
{
nsCOMPtr
<
nsIHTMLDocument
>
htmlDoc
=
do_QueryInterface
(
mResponseXML
)
;
if
(
htmlDoc
)
{
htmlDoc
-
>
DisableCookieAccess
(
)
;
}
}
nsCOMPtr
<
nsIStreamListener
>
listener
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
channel
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
rv
=
mResponseXML
-
>
StartDocumentLoad
(
kLoadAsData
channel
loadGroup
nullptr
getter_AddRefs
(
listener
)
!
isCrossSite
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mResponseXML
-
>
SetReferrer
(
NS_LITERAL_CSTRING
(
"
"
)
)
;
mXMLParserStreamListener
=
listener
;
rv
=
mXMLParserStreamListener
-
>
OnStartRequest
(
request
ctxt
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
mFlagSynchronous
&
&
HasListenersFor
(
nsGkAtoms
:
:
onprogress
)
)
{
StartProgressEventTimer
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
OnStopRequest
(
nsIRequest
*
request
nsISupports
*
ctxt
nsresult
status
)
{
PROFILER_LABEL
(
"
XMLHttpRequestMainThread
"
"
OnStopRequest
"
js
:
:
ProfileEntry
:
:
Category
:
:
NETWORK
)
;
if
(
request
!
=
mChannel
)
{
return
NS_OK
;
}
mWaitingForOnStopRequest
=
false
;
if
(
mRequestObserver
)
{
NS_ASSERTION
(
mFirstStartRequestSeen
"
Inconsistent
state
!
"
)
;
mFirstStartRequestSeen
=
false
;
mRequestObserver
-
>
OnStopRequest
(
request
ctxt
status
)
;
}
if
(
mState
=
=
State
:
:
unsent
|
|
mFlagTimedOut
)
{
if
(
mXMLParserStreamListener
)
(
void
)
mXMLParserStreamListener
-
>
OnStopRequest
(
request
ctxt
status
)
;
return
NS_OK
;
}
if
(
mXMLParserStreamListener
&
&
mFlagParseBody
)
{
mXMLParserStreamListener
-
>
OnStopRequest
(
request
ctxt
status
)
;
}
mXMLParserStreamListener
=
nullptr
;
mContext
=
nullptr
;
if
(
!
mIsHtml
)
{
MaybeDispatchProgressEvents
(
true
)
;
}
if
(
NS_SUCCEEDED
(
status
)
&
&
(
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Blob
|
|
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Moz_blob
)
)
{
if
(
!
mDOMBlob
)
{
CreateDOMBlob
(
request
)
;
}
if
(
mDOMBlob
)
{
mResponseBlob
=
mDOMBlob
;
mDOMBlob
=
nullptr
;
}
else
{
if
(
!
mBlobSet
)
{
mBlobSet
=
new
BlobSet
(
)
;
}
nsAutoCString
contentType
;
mChannel
-
>
GetContentType
(
contentType
)
;
ErrorResult
rv
;
mResponseBlob
=
mBlobSet
-
>
GetBlobInternal
(
GetOwner
(
)
contentType
rv
)
;
mBlobSet
=
nullptr
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
}
NS_ASSERTION
(
mResponseBody
.
IsEmpty
(
)
"
mResponseBody
should
be
empty
"
)
;
NS_ASSERTION
(
mResponseText
.
IsEmpty
(
)
"
mResponseText
should
be
empty
"
)
;
}
else
if
(
NS_SUCCEEDED
(
status
)
&
&
(
(
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Arraybuffer
&
&
!
mIsMappedArrayBuffer
)
|
|
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Moz_chunked_arraybuffer
)
)
{
if
(
!
mArrayBufferBuilder
.
setCapacity
(
mArrayBufferBuilder
.
length
(
)
)
)
{
status
=
NS_ERROR_UNEXPECTED
;
}
}
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
request
)
)
;
NS_ENSURE_TRUE
(
channel
NS_ERROR_UNEXPECTED
)
;
channel
-
>
SetNotificationCallbacks
(
nullptr
)
;
mNotificationCallbacks
=
nullptr
;
mChannelEventSink
=
nullptr
;
mProgressEventSink
=
nullptr
;
mFlagSyncLooping
=
false
;
if
(
NS_FAILED
(
status
)
)
{
mErrorLoad
=
true
;
mResponseXML
=
nullptr
;
}
if
(
mState
=
=
State
:
:
unsent
|
|
mState
=
=
State
:
:
done
)
{
return
NS_OK
;
}
if
(
!
mResponseXML
)
{
ChangeStateToDone
(
)
;
return
NS_OK
;
}
if
(
mIsHtml
)
{
NS_ASSERTION
(
!
mFlagSyncLooping
"
We
weren
'
t
supposed
to
support
HTML
parsing
with
XHR
!
"
)
;
nsCOMPtr
<
EventTarget
>
eventTarget
=
do_QueryInterface
(
mResponseXML
)
;
EventListenerManager
*
manager
=
eventTarget
-
>
GetOrCreateListenerManager
(
)
;
manager
-
>
AddEventListenerByType
(
new
nsXHRParseEndListener
(
this
)
kLiteralString_DOMContentLoaded
TrustedEventsAtSystemGroupBubble
(
)
)
;
return
NS_OK
;
}
if
(
!
mResponseXML
-
>
GetRootElement
(
)
)
{
mResponseXML
=
nullptr
;
}
ChangeStateToDone
(
)
;
return
NS_OK
;
}
void
XMLHttpRequestMainThread
:
:
ChangeStateToDone
(
)
{
if
(
mIsHtml
)
{
MaybeDispatchProgressEvents
(
true
)
;
}
ChangeState
(
State
:
:
done
true
)
;
mFlagSend
=
false
;
if
(
mTimeoutTimer
)
{
mTimeoutTimer
-
>
Cancel
(
)
;
}
DispatchProgressEvent
(
this
mErrorLoad
?
ProgressEventType
:
:
error
:
ProgressEventType
:
:
load
!
mErrorLoad
mLoadTransferred
mErrorLoad
?
0
:
mLoadTransferred
)
;
if
(
mErrorLoad
&
&
mUpload
&
&
!
mUploadComplete
)
{
DispatchProgressEvent
(
mUpload
ProgressEventType
:
:
error
true
mUploadTransferred
mUploadTotal
)
;
}
if
(
mErrorLoad
)
{
mChannel
=
nullptr
;
}
}
template
<
>
nsresult
XMLHttpRequestMainThread
:
:
RequestBody
<
nsIDocument
>
:
:
GetAsStream
(
nsIInputStream
*
*
aResult
uint64_t
*
aContentLength
nsACString
&
aContentType
nsACString
&
aCharset
)
const
{
nsCOMPtr
<
nsIDOMDocument
>
domdoc
(
do_QueryInterface
(
mBody
)
)
;
NS_ENSURE_STATE
(
domdoc
)
;
aCharset
.
AssignLiteral
(
"
UTF
-
8
"
)
;
nsresult
rv
;
nsCOMPtr
<
nsIStorageStream
>
storStream
;
rv
=
NS_NewStorageStream
(
4096
UINT32_MAX
getter_AddRefs
(
storStream
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIOutputStream
>
output
;
rv
=
storStream
-
>
GetOutputStream
(
0
getter_AddRefs
(
output
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mBody
-
>
IsHTMLDocument
(
)
)
{
aContentType
.
AssignLiteral
(
"
text
/
html
"
)
;
nsString
serialized
;
if
(
!
nsContentUtils
:
:
SerializeNodeToMarkup
(
mBody
true
serialized
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
NS_ConvertUTF16toUTF8
utf8Serialized
(
serialized
)
;
uint32_t
written
;
rv
=
output
-
>
Write
(
utf8Serialized
.
get
(
)
utf8Serialized
.
Length
(
)
&
written
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
written
=
=
utf8Serialized
.
Length
(
)
)
;
}
else
{
aContentType
.
AssignLiteral
(
"
application
/
xml
"
)
;
nsCOMPtr
<
nsIDOMSerializer
>
serializer
=
do_CreateInstance
(
NS_XMLSERIALIZER_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
serializer
-
>
SerializeToStream
(
domdoc
output
aCharset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
output
-
>
Close
(
)
;
uint32_t
length
;
rv
=
storStream
-
>
GetLength
(
&
length
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aContentLength
=
length
;
rv
=
storStream
-
>
NewInputStream
(
0
aResult
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
template
<
>
nsresult
XMLHttpRequestMainThread
:
:
RequestBody
<
const
nsAString
>
:
:
GetAsStream
(
nsIInputStream
*
*
aResult
uint64_t
*
aContentLength
nsACString
&
aContentType
nsACString
&
aCharset
)
const
{
aContentType
.
AssignLiteral
(
"
text
/
plain
"
)
;
aCharset
.
AssignLiteral
(
"
UTF
-
8
"
)
;
nsCString
converted
=
NS_ConvertUTF16toUTF8
(
*
mBody
)
;
*
aContentLength
=
converted
.
Length
(
)
;
nsresult
rv
=
NS_NewCStringInputStream
(
aResult
converted
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
template
<
>
nsresult
XMLHttpRequestMainThread
:
:
RequestBody
<
nsIInputStream
>
:
:
GetAsStream
(
nsIInputStream
*
*
aResult
uint64_t
*
aContentLength
nsACString
&
aContentType
nsACString
&
aCharset
)
const
{
aContentType
.
AssignLiteral
(
"
text
/
plain
"
)
;
aCharset
.
Truncate
(
)
;
nsresult
rv
=
mBody
-
>
Available
(
aContentLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
stream
(
mBody
)
;
stream
.
forget
(
aResult
)
;
return
NS_OK
;
}
template
<
>
nsresult
XMLHttpRequestMainThread
:
:
RequestBody
<
Blob
>
:
:
GetAsStream
(
nsIInputStream
*
*
aResult
uint64_t
*
aContentLength
nsACString
&
aContentType
nsACString
&
aCharset
)
const
{
return
mBody
-
>
GetSendInfo
(
aResult
aContentLength
aContentType
aCharset
)
;
}
template
<
>
nsresult
XMLHttpRequestMainThread
:
:
RequestBody
<
FormData
>
:
:
GetAsStream
(
nsIInputStream
*
*
aResult
uint64_t
*
aContentLength
nsACString
&
aContentType
nsACString
&
aCharset
)
const
{
return
mBody
-
>
GetSendInfo
(
aResult
aContentLength
aContentType
aCharset
)
;
}
template
<
>
nsresult
XMLHttpRequestMainThread
:
:
RequestBody
<
URLSearchParams
>
:
:
GetAsStream
(
nsIInputStream
*
*
aResult
uint64_t
*
aContentLength
nsACString
&
aContentType
nsACString
&
aCharset
)
const
{
return
mBody
-
>
GetSendInfo
(
aResult
aContentLength
aContentType
aCharset
)
;
}
template
<
>
nsresult
XMLHttpRequestMainThread
:
:
RequestBody
<
nsIXHRSendable
>
:
:
GetAsStream
(
nsIInputStream
*
*
aResult
uint64_t
*
aContentLength
nsACString
&
aContentType
nsACString
&
aCharset
)
const
{
return
mBody
-
>
GetSendInfo
(
aResult
aContentLength
aContentType
aCharset
)
;
}
static
nsresult
GetBufferDataAsStream
(
const
uint8_t
*
aData
uint32_t
aDataLength
nsIInputStream
*
*
aResult
uint64_t
*
aContentLength
nsACString
&
aContentType
nsACString
&
aCharset
)
{
aContentType
.
SetIsVoid
(
true
)
;
aCharset
.
Truncate
(
)
;
*
aContentLength
=
aDataLength
;
const
char
*
data
=
reinterpret_cast
<
const
char
*
>
(
aData
)
;
nsCOMPtr
<
nsIInputStream
>
stream
;
nsresult
rv
=
NS_NewByteInputStream
(
getter_AddRefs
(
stream
)
data
aDataLength
NS_ASSIGNMENT_COPY
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
stream
.
forget
(
aResult
)
;
return
NS_OK
;
}
template
<
>
nsresult
XMLHttpRequestMainThread
:
:
RequestBody
<
const
ArrayBuffer
>
:
:
GetAsStream
(
nsIInputStream
*
*
aResult
uint64_t
*
aContentLength
nsACString
&
aContentType
nsACString
&
aCharset
)
const
{
mBody
-
>
ComputeLengthAndData
(
)
;
return
GetBufferDataAsStream
(
mBody
-
>
Data
(
)
mBody
-
>
Length
(
)
aResult
aContentLength
aContentType
aCharset
)
;
}
template
<
>
nsresult
XMLHttpRequestMainThread
:
:
RequestBody
<
const
ArrayBufferView
>
:
:
GetAsStream
(
nsIInputStream
*
*
aResult
uint64_t
*
aContentLength
nsACString
&
aContentType
nsACString
&
aCharset
)
const
{
mBody
-
>
ComputeLengthAndData
(
)
;
return
GetBufferDataAsStream
(
mBody
-
>
Data
(
)
mBody
-
>
Length
(
)
aResult
aContentLength
aContentType
aCharset
)
;
}
nsresult
XMLHttpRequestMainThread
:
:
InitChannel
(
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
GetLoadGroup
(
)
;
nsSecurityFlags
secFlags
;
nsLoadFlags
loadFlags
=
nsIRequest
:
:
LOAD_BACKGROUND
|
nsIChannel
:
:
LOAD_CLASSIFY_URI
;
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
mPrincipal
)
)
{
secFlags
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
|
nsILoadInfo
:
:
SEC_SANDBOXED
;
}
else
if
(
IsSystemXHR
(
)
)
{
secFlags
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
|
nsILoadInfo
:
:
SEC_FORCE_INHERIT_PRINCIPAL
;
loadFlags
|
=
nsIChannel
:
:
LOAD_BYPASS_SERVICE_WORKER
;
}
else
{
secFlags
=
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
|
nsILoadInfo
:
:
SEC_FORCE_INHERIT_PRINCIPAL
;
}
if
(
mIsAnon
)
{
secFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_OMIT
;
}
nsresult
rv
;
nsCOMPtr
<
nsIDocument
>
responsibleDocument
=
GetDocumentIfCurrent
(
)
;
if
(
responsibleDocument
&
&
responsibleDocument
-
>
NodePrincipal
(
)
=
=
mPrincipal
)
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
mChannel
)
mRequestURL
responsibleDocument
secFlags
nsIContentPolicy
:
:
TYPE_INTERNAL_XMLHTTPREQUEST
loadGroup
nullptr
loadFlags
)
;
}
else
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
mChannel
)
mRequestURL
mPrincipal
secFlags
nsIContentPolicy
:
:
TYPE_INTERNAL_XMLHTTPREQUEST
loadGroup
nullptr
loadFlags
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
mChannel
)
)
;
if
(
httpChannel
)
{
rv
=
httpChannel
-
>
SetRequestMethod
(
mRequestMethod
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsITimedChannel
>
timedChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
timedChannel
)
{
timedChannel
-
>
SetInitiatorType
(
NS_LITERAL_STRING
(
"
xmlhttprequest
"
)
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
Send
(
nsIVariant
*
aVariant
)
{
if
(
!
aVariant
)
{
return
SendInternal
(
nullptr
)
;
}
uint16_t
dataType
;
nsresult
rv
=
aVariant
-
>
GetDataType
(
&
dataType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
dataType
=
=
nsIDataType
:
:
VTYPE_INTERFACE
|
|
dataType
=
=
nsIDataType
:
:
VTYPE_INTERFACE_IS
)
{
nsCOMPtr
<
nsISupports
>
supports
;
nsID
*
iid
;
rv
=
aVariant
-
>
GetAsInterface
(
&
iid
getter_AddRefs
(
supports
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
free
(
iid
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
supports
)
;
if
(
doc
)
{
RequestBody
<
nsIDocument
>
body
(
doc
)
;
return
SendInternal
(
&
body
)
;
}
nsCOMPtr
<
nsISupportsString
>
wstr
=
do_QueryInterface
(
supports
)
;
if
(
wstr
)
{
nsAutoString
string
;
wstr
-
>
GetData
(
string
)
;
RequestBody
<
const
nsAString
>
body
(
&
string
)
;
return
SendInternal
(
&
body
)
;
}
nsCOMPtr
<
nsIInputStream
>
stream
=
do_QueryInterface
(
supports
)
;
if
(
stream
)
{
RequestBody
<
nsIInputStream
>
body
(
stream
)
;
return
SendInternal
(
&
body
)
;
}
nsCOMPtr
<
nsIXHRSendable
>
sendable
=
do_QueryInterface
(
supports
)
;
if
(
sendable
)
{
RequestBody
<
nsIXHRSendable
>
body
(
sendable
)
;
return
SendInternal
(
&
body
)
;
}
JSContext
*
rootingCx
=
nsContentUtils
:
:
RootingCx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
realVal
(
rootingCx
)
;
nsresult
rv
=
aVariant
-
>
GetAsJSVal
(
&
realVal
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
realVal
.
isPrimitive
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
obj
(
rootingCx
realVal
.
toObjectOrNull
(
)
)
;
RootedTypedArray
<
ArrayBuffer
>
buf
(
rootingCx
)
;
if
(
buf
.
Init
(
obj
)
)
{
RequestBody
<
const
ArrayBuffer
>
body
(
&
buf
)
;
return
SendInternal
(
&
body
)
;
}
}
}
else
if
(
dataType
=
=
nsIDataType
:
:
VTYPE_VOID
|
|
dataType
=
=
nsIDataType
:
:
VTYPE_EMPTY
)
{
return
SendInternal
(
nullptr
)
;
}
char16_t
*
data
=
nullptr
;
uint32_t
len
=
0
;
rv
=
aVariant
-
>
GetAsWStringWithSize
(
&
len
&
data
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsString
string
;
string
.
Adopt
(
data
len
)
;
RequestBody
<
const
nsAString
>
body
(
&
string
)
;
return
SendInternal
(
&
body
)
;
}
nsresult
XMLHttpRequestMainThread
:
:
SendInternal
(
const
RequestBodyBase
*
aBody
)
{
NS_ENSURE_TRUE
(
mPrincipal
NS_ERROR_NOT_INITIALIZED
)
;
PopulateNetworkInterfaceId
(
)
;
nsresult
rv
=
CheckInnerWindowCorrectness
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
if
(
mState
!
=
State
:
:
opened
|
|
mFlagSend
|
|
!
mChannel
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
if
(
HasListenersFor
(
nsGkAtoms
:
:
onprogress
)
|
|
(
mUpload
&
&
mUpload
-
>
HasListenersFor
(
nsGkAtoms
:
:
onprogress
)
)
)
{
nsLoadFlags
loadFlags
;
mChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
loadFlags
&
=
~
nsIRequest
:
:
LOAD_BACKGROUND
;
loadFlags
|
=
nsIRequest
:
:
LOAD_NORMAL
;
mChannel
-
>
SetLoadFlags
(
loadFlags
)
;
}
nsAutoCString
method
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
mChannel
)
)
;
if
(
httpChannel
)
{
SetAuthorRequestHeadersOnChannel
(
httpChannel
)
;
httpChannel
-
>
GetRequestMethod
(
method
)
;
if
(
!
IsSystemXHR
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
owner
=
GetOwner
(
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
owner
?
owner
-
>
GetExtantDoc
(
)
:
nullptr
;
nsContentUtils
:
:
SetFetchReferrerURIWithPolicy
(
mPrincipal
doc
httpChannel
mozilla
:
:
net
:
:
RP_Default
)
;
}
nsCOMPtr
<
nsIUploadChannel2
>
uploadChannel2
=
do_QueryInterface
(
httpChannel
)
;
if
(
!
uploadChannel2
)
{
nsCOMPtr
<
nsIConsoleService
>
consoleService
=
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
;
if
(
consoleService
)
{
consoleService
-
>
LogStringMessage
(
NS_LITERAL_STRING
(
"
Http
channel
implementation
doesn
'
t
support
nsIUploadChannel2
.
An
extension
has
supplied
a
non
-
functional
http
protocol
handler
.
This
will
break
behavior
and
in
future
releases
not
work
at
all
.
"
)
.
get
(
)
)
;
}
}
}
mUploadTransferred
=
0
;
mUploadTotal
=
0
;
mUploadComplete
=
true
;
mErrorLoad
=
false
;
mLoadLengthComputable
=
false
;
mLoadTotal
=
0
;
if
(
aBody
&
&
httpChannel
&
&
!
method
.
LowerCaseEqualsLiteral
(
"
get
"
)
&
&
!
method
.
LowerCaseEqualsLiteral
(
"
head
"
)
)
{
nsAutoCString
charset
;
nsAutoCString
defaultContentType
;
nsCOMPtr
<
nsIInputStream
>
postDataStream
;
uint64_t
size_u64
;
rv
=
aBody
-
>
GetAsStream
(
getter_AddRefs
(
postDataStream
)
&
size_u64
defaultContentType
charset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mUploadTotal
=
net
:
:
InScriptableRange
(
size_u64
)
?
static_cast
<
int64_t
>
(
size_u64
)
:
-
1
;
if
(
postDataStream
)
{
nsAutoCString
contentType
;
GetAuthorRequestHeaderValue
(
"
content
-
type
"
contentType
)
;
if
(
contentType
.
IsVoid
(
)
)
{
contentType
=
defaultContentType
;
if
(
!
charset
.
IsEmpty
(
)
)
{
contentType
.
Append
(
NS_LITERAL_CSTRING
(
"
;
charset
=
"
)
)
;
contentType
.
Append
(
charset
)
;
}
}
if
(
!
charset
.
IsEmpty
(
)
)
{
nsAutoCString
specifiedCharset
;
bool
haveCharset
;
int32_t
charsetStart
charsetEnd
;
rv
=
NS_ExtractCharsetFromContentType
(
contentType
specifiedCharset
&
haveCharset
&
charsetStart
&
charsetEnd
)
;
while
(
NS_SUCCEEDED
(
rv
)
&
&
haveCharset
)
{
if
(
specifiedCharset
.
Length
(
)
>
=
2
&
&
specifiedCharset
.
First
(
)
=
=
'
\
'
'
&
&
specifiedCharset
.
Last
(
)
=
=
'
\
'
'
)
{
specifiedCharset
=
Substring
(
specifiedCharset
1
specifiedCharset
.
Length
(
)
-
2
)
;
}
if
(
!
specifiedCharset
.
Equals
(
charset
nsCaseInsensitiveCStringComparator
(
)
)
)
{
int32_t
charIdx
=
Substring
(
contentType
charsetStart
charsetEnd
-
charsetStart
)
.
FindChar
(
'
=
'
)
+
1
;
MOZ_ASSERT
(
charIdx
!
=
-
1
)
;
contentType
.
Replace
(
charsetStart
+
charIdx
charsetEnd
-
charsetStart
-
charIdx
charset
)
;
}
nsDependentCSubstring
interestingSection
=
Substring
(
contentType
0
charsetStart
)
;
rv
=
NS_ExtractCharsetFromContentType
(
interestingSection
specifiedCharset
&
haveCharset
&
charsetStart
&
charsetEnd
)
;
}
}
if
(
!
NS_InputStreamIsBuffered
(
postDataStream
)
)
{
nsCOMPtr
<
nsIInputStream
>
bufferedStream
;
rv
=
NS_NewBufferedInputStream
(
getter_AddRefs
(
bufferedStream
)
postDataStream
4096
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
postDataStream
=
bufferedStream
;
}
mUploadComplete
=
false
;
nsCOMPtr
<
nsIUploadChannel2
>
uploadChannel2
(
do_QueryInterface
(
httpChannel
)
)
;
NS_ASSERTION
(
uploadChannel2
"
http
must
support
nsIUploadChannel2
"
)
;
if
(
uploadChannel2
)
{
uploadChannel2
-
>
ExplicitSetUploadStream
(
postDataStream
contentType
mUploadTotal
method
false
)
;
}
else
{
if
(
contentType
.
IsEmpty
(
)
)
{
contentType
.
AssignLiteral
(
"
application
/
octet
-
stream
"
)
;
}
nsCOMPtr
<
nsIUploadChannel
>
uploadChannel
=
do_QueryInterface
(
httpChannel
)
;
uploadChannel
-
>
SetUploadStream
(
postDataStream
contentType
mUploadTotal
)
;
httpChannel
-
>
SetRequestMethod
(
method
)
;
}
}
}
ResetResponse
(
)
;
if
(
!
IsSystemXHR
(
)
&
&
!
mIsAnon
&
&
mFlagACwithCredentials
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
-
>
GetLoadInfo
(
)
;
static_cast
<
net
:
:
LoadInfo
*
>
(
loadInfo
.
get
(
)
)
-
>
SetIncludeCookiesSecFlag
(
)
;
}
AddLoadFlags
(
mChannel
nsIRequest
:
:
INHIBIT_PIPELINE
)
;
nsCOMPtr
<
nsIClassOfService
>
cos
(
do_QueryInterface
(
mChannel
)
)
;
if
(
cos
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Unblocked
)
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
internalHttpChannel
(
do_QueryInterface
(
mChannel
)
)
;
if
(
internalHttpChannel
)
{
internalHttpChannel
-
>
SetResponseTimeoutEnabled
(
false
)
;
}
if
(
!
mIsAnon
)
{
AddLoadFlags
(
mChannel
nsIChannel
:
:
LOAD_EXPLICIT_CREDENTIALS
)
;
}
if
(
method
.
EqualsLiteral
(
"
POST
"
)
)
{
AddLoadFlags
(
mChannel
nsICachingChannel
:
:
LOAD_BYPASS_LOCAL_CACHE
|
nsIRequest
:
:
INHIBIT_CACHING
)
;
}
else
{
AddLoadFlags
(
mChannel
nsICachingChannel
:
:
LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
)
;
}
nsAutoCString
contentType
;
if
(
NS_FAILED
(
mChannel
-
>
GetContentType
(
contentType
)
)
|
|
contentType
.
IsEmpty
(
)
|
|
contentType
.
Equals
(
UNKNOWN_CONTENT_TYPE
)
)
{
mChannel
-
>
SetContentType
(
NS_LITERAL_CSTRING
(
"
application
/
xml
"
)
)
;
}
mRequestSentTime
=
PR_Now
(
)
;
StartTimeoutTimer
(
)
;
if
(
mUpload
&
&
mUpload
-
>
HasListeners
(
)
)
{
mFlagHadUploadListenersOnSend
=
true
;
}
if
(
!
IsSystemXHR
(
)
)
{
nsTArray
<
nsCString
>
CORSUnsafeHeaders
;
const
char
*
kCrossOriginSafeHeaders
[
]
=
{
"
accept
"
"
accept
-
language
"
"
content
-
language
"
"
content
-
type
"
"
last
-
event
-
id
"
}
;
for
(
RequestHeader
&
header
:
mAuthorRequestHeaders
)
{
bool
safe
=
false
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
kCrossOriginSafeHeaders
)
;
+
+
i
)
{
if
(
header
.
name
.
EqualsASCII
(
kCrossOriginSafeHeaders
[
i
]
)
)
{
safe
=
true
;
break
;
}
}
if
(
!
safe
)
{
CORSUnsafeHeaders
.
AppendElement
(
header
.
name
)
;
}
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
-
>
GetLoadInfo
(
)
;
loadInfo
-
>
SetCorsPreflightInfo
(
CORSUnsafeHeaders
mFlagHadUploadListenersOnSend
)
;
}
mIsMappedArrayBuffer
=
false
;
if
(
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Arraybuffer
&
&
Preferences
:
:
GetBool
(
"
dom
.
mapped_arraybuffer
.
enabled
"
true
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsAutoCString
scheme
;
rv
=
mChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
uri
-
>
GetScheme
(
scheme
)
;
if
(
scheme
.
LowerCaseEqualsLiteral
(
"
app
"
)
|
|
scheme
.
LowerCaseEqualsLiteral
(
"
jar
"
)
)
{
mIsMappedArrayBuffer
=
true
;
}
}
}
mChannel
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
mNotificationCallbacks
)
)
;
mChannel
-
>
SetNotificationCallbacks
(
this
)
;
if
(
internalHttpChannel
)
{
internalHttpChannel
-
>
SetBlockAuthPrompt
(
ShouldBlockAuthPrompt
(
)
)
;
}
nsCOMPtr
<
nsIStreamListener
>
listener
=
new
net
:
:
nsStreamListenerWrapper
(
this
)
;
rv
=
mChannel
-
>
AsyncOpen2
(
listener
)
;
listener
=
nullptr
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mChannel
-
>
SetNotificationCallbacks
(
mNotificationCallbacks
)
;
mChannel
=
nullptr
;
return
rv
;
}
mWaitingForOnStopRequest
=
true
;
mFlagSend
=
true
;
if
(
mFlagSynchronous
)
{
mFlagSyncLooping
=
true
;
nsCOMPtr
<
nsIDocument
>
suspendedDoc
;
nsCOMPtr
<
nsIRunnable
>
resumeTimeoutRunnable
;
if
(
GetOwner
(
)
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
topWindow
=
GetOwner
(
)
-
>
GetOuterWindow
(
)
-
>
GetTop
(
)
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
topInner
=
topWindow
-
>
GetCurrentInnerWindow
(
)
)
{
suspendedDoc
=
topWindow
-
>
GetExtantDoc
(
)
;
if
(
suspendedDoc
)
{
suspendedDoc
-
>
SuppressEventHandling
(
nsIDocument
:
:
eEvents
)
;
}
topWindow
-
>
SuspendTimeouts
(
1
false
)
;
resumeTimeoutRunnable
=
new
nsResumeTimeoutsEvent
(
topInner
)
;
}
}
}
if
(
mProgressNotifier
)
{
mProgressTimerIsActive
=
false
;
mProgressNotifier
-
>
Cancel
(
)
;
}
{
nsAutoSyncOperation
sync
(
suspendedDoc
)
;
nsIThread
*
thread
=
NS_GetCurrentThread
(
)
;
while
(
mFlagSyncLooping
)
{
if
(
!
NS_ProcessNextEvent
(
thread
)
)
{
rv
=
NS_ERROR_UNEXPECTED
;
break
;
}
}
}
if
(
suspendedDoc
)
{
suspendedDoc
-
>
UnsuppressEventHandlingAndFireEvents
(
nsIDocument
:
:
eEvents
true
)
;
}
if
(
resumeTimeoutRunnable
)
{
NS_DispatchToCurrentThread
(
resumeTimeoutRunnable
)
;
}
}
else
{
if
(
mProgressNotifier
)
{
mProgressTimerIsActive
=
false
;
mProgressNotifier
-
>
Cancel
(
)
;
}
if
(
mUpload
&
&
mUpload
-
>
HasListenersFor
(
nsGkAtoms
:
:
onprogress
)
)
{
StartProgressEventTimer
(
)
;
}
DispatchProgressEvent
(
this
ProgressEventType
:
:
loadstart
false
0
0
)
;
if
(
mUpload
&
&
!
mUploadComplete
)
{
DispatchProgressEvent
(
mUpload
ProgressEventType
:
:
loadstart
true
0
mUploadTotal
)
;
}
}
if
(
!
mChannel
)
{
return
NS_ERROR_FAILURE
;
}
return
rv
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
SetRequestHeader
(
const
nsACString
&
aName
const
nsACString
&
aValue
)
{
if
(
mState
!
=
State
:
:
opened
|
|
mFlagSend
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
nsAutoCString
value
(
aValue
)
;
static
const
char
kHTTPWhitespace
[
]
=
"
\
n
\
t
\
r
"
;
value
.
Trim
(
kHTTPWhitespace
)
;
if
(
!
NS_IsValidHTTPToken
(
aName
)
|
|
!
NS_IsReasonableHTTPHeaderValue
(
value
)
)
{
return
NS_ERROR_DOM_SYNTAX_ERR
;
}
bool
isPrivilegedCaller
=
IsSystemXHR
(
)
;
bool
isForbiddenHeader
=
nsContentUtils
:
:
IsForbiddenRequestHeader
(
aName
)
;
if
(
!
isPrivilegedCaller
&
&
isForbiddenHeader
)
{
NS_WARNING
(
"
refusing
to
set
request
header
"
)
;
return
NS_OK
;
}
nsAutoCString
lowercaseName
;
nsContentUtils
:
:
ASCIIToLower
(
aName
lowercaseName
)
;
bool
notAlreadySet
=
true
;
for
(
RequestHeader
&
header
:
mAuthorRequestHeaders
)
{
if
(
header
.
name
.
Equals
(
lowercaseName
)
)
{
if
(
isPrivilegedCaller
&
&
isForbiddenHeader
)
{
header
.
value
.
Assign
(
value
)
;
}
else
{
header
.
value
.
AppendLiteral
(
"
"
)
;
header
.
value
.
Append
(
value
)
;
}
notAlreadySet
=
false
;
break
;
}
}
if
(
notAlreadySet
)
{
RequestHeader
newHeader
=
{
nsCString
(
lowercaseName
)
nsCString
(
value
)
}
;
mAuthorRequestHeaders
.
AppendElement
(
newHeader
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetTimeout
(
uint32_t
*
aTimeout
)
{
*
aTimeout
=
Timeout
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
SetTimeout
(
uint32_t
aTimeout
)
{
ErrorResult
rv
;
SetTimeout
(
aTimeout
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
XMLHttpRequestMainThread
:
:
SetTimeout
(
uint32_t
aTimeout
ErrorResult
&
aRv
)
{
if
(
mFlagSynchronous
&
&
mState
!
=
State
:
:
unsent
&
&
HasOrHasHadOwner
(
)
)
{
LogMessage
(
"
TimeoutSyncXHRWarning
"
GetOwner
(
)
)
;
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_ACCESS_ERR
)
;
return
;
}
mTimeoutMilliseconds
=
aTimeout
;
if
(
mRequestSentTime
)
{
StartTimeoutTimer
(
)
;
}
}
void
XMLHttpRequestMainThread
:
:
StartTimeoutTimer
(
)
{
MOZ_ASSERT
(
mRequestSentTime
"
StartTimeoutTimer
mustn
'
t
be
called
before
the
request
was
sent
!
"
)
;
if
(
mState
=
=
State
:
:
done
)
{
return
;
}
if
(
mTimeoutTimer
)
{
mTimeoutTimer
-
>
Cancel
(
)
;
}
if
(
!
mTimeoutMilliseconds
)
{
return
;
}
if
(
!
mTimeoutTimer
)
{
mTimeoutTimer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
)
;
}
uint32_t
elapsed
=
(
uint32_t
)
(
(
PR_Now
(
)
-
mRequestSentTime
)
/
PR_USEC_PER_MSEC
)
;
mTimeoutTimer
-
>
InitWithCallback
(
this
mTimeoutMilliseconds
>
elapsed
?
mTimeoutMilliseconds
-
elapsed
:
0
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetReadyState
(
uint16_t
*
aState
)
{
*
aState
=
ReadyState
(
)
;
return
NS_OK
;
}
uint16_t
XMLHttpRequestMainThread
:
:
ReadyState
(
)
const
{
switch
(
mState
)
{
case
State
:
:
unsent
:
return
UNSENT
;
case
State
:
:
opened
:
return
OPENED
;
case
State
:
:
headers_received
:
return
HEADERS_RECEIVED
;
case
State
:
:
loading
:
return
LOADING
;
case
State
:
:
done
:
return
DONE
;
default
:
MOZ_CRASH
(
"
Unknown
state
"
)
;
}
return
0
;
}
void
XMLHttpRequestMainThread
:
:
OverrideMimeType
(
const
nsAString
&
aMimeType
ErrorResult
&
aRv
)
{
if
(
mState
=
=
State
:
:
loading
|
|
mState
=
=
State
:
:
done
)
{
ResetResponse
(
)
;
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
mOverrideMimeType
=
aMimeType
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
SlowOverrideMimeType
(
const
nsAString
&
aMimeType
)
{
ErrorResult
aRv
;
OverrideMimeType
(
aMimeType
aRv
)
;
return
aRv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetMozBackgroundRequest
(
bool
*
_retval
)
{
*
_retval
=
MozBackgroundRequest
(
)
;
return
NS_OK
;
}
bool
XMLHttpRequestMainThread
:
:
MozBackgroundRequest
(
)
const
{
return
mFlagBackgroundRequest
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
SetMozBackgroundRequest
(
bool
aMozBackgroundRequest
)
{
if
(
!
IsSystemXHR
(
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
if
(
mState
!
=
State
:
:
unsent
)
{
return
NS_ERROR_IN_PROGRESS
;
}
mFlagBackgroundRequest
=
aMozBackgroundRequest
;
return
NS_OK
;
}
void
XMLHttpRequestMainThread
:
:
SetMozBackgroundRequest
(
bool
aMozBackgroundRequest
ErrorResult
&
aRv
)
{
SetMozBackgroundRequest
(
aMozBackgroundRequest
)
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetWithCredentials
(
bool
*
_retval
)
{
*
_retval
=
WithCredentials
(
)
;
return
NS_OK
;
}
bool
XMLHttpRequestMainThread
:
:
WithCredentials
(
)
const
{
return
mFlagACwithCredentials
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
SetWithCredentials
(
bool
aWithCredentials
)
{
ErrorResult
rv
;
SetWithCredentials
(
aWithCredentials
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
XMLHttpRequestMainThread
:
:
SetWithCredentials
(
bool
aWithCredentials
ErrorResult
&
aRv
)
{
if
(
(
mState
!
=
State
:
:
unsent
&
&
mState
!
=
State
:
:
opened
)
|
|
mFlagSend
|
|
mIsAnon
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
mFlagACwithCredentials
=
aWithCredentials
;
}
nsresult
XMLHttpRequestMainThread
:
:
ChangeState
(
State
aState
bool
aBroadcast
)
{
mState
=
aState
;
nsresult
rv
=
NS_OK
;
if
(
mProgressNotifier
&
&
aState
!
=
State
:
:
headers_received
&
&
aState
!
=
State
:
:
loading
)
{
mProgressTimerIsActive
=
false
;
mProgressNotifier
-
>
Cancel
(
)
;
}
if
(
aBroadcast
&
&
(
!
mFlagSynchronous
|
|
aState
=
=
State
:
:
opened
|
|
aState
=
=
State
:
:
done
)
)
{
rv
=
FireReadystatechangeEvent
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
callback
)
{
NS_PRECONDITION
(
aNewChannel
"
Redirect
without
a
channel
?
"
)
;
mRedirectCallback
=
callback
;
mNewRedirectChannel
=
aNewChannel
;
if
(
mChannelEventSink
)
{
nsCOMPtr
<
nsIAsyncVerifyRedirectCallback
>
fwd
=
EnsureXPCOMifier
(
)
;
nsresult
rv
=
mChannelEventSink
-
>
AsyncOnChannelRedirect
(
aOldChannel
aNewChannel
aFlags
fwd
)
;
if
(
NS_FAILED
(
rv
)
)
{
mRedirectCallback
=
nullptr
;
mNewRedirectChannel
=
nullptr
;
}
return
rv
;
}
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
void
XMLHttpRequestMainThread
:
:
GetAuthorRequestHeaderValue
(
const
char
*
aName
nsACString
&
outValue
)
{
for
(
RequestHeader
&
header
:
mAuthorRequestHeaders
)
{
if
(
header
.
name
.
Equals
(
aName
)
)
{
outValue
.
Assign
(
header
.
value
)
;
return
;
}
}
outValue
.
SetIsVoid
(
true
)
;
}
void
XMLHttpRequestMainThread
:
:
SetAuthorRequestHeadersOnChannel
(
nsCOMPtr
<
nsIHttpChannel
>
aHttpChannel
)
{
for
(
RequestHeader
&
header
:
mAuthorRequestHeaders
)
{
if
(
header
.
value
.
IsEmpty
(
)
)
{
aHttpChannel
-
>
SetEmptyRequestHeader
(
header
.
name
)
;
}
else
{
aHttpChannel
-
>
SetRequestHeader
(
header
.
name
header
.
value
false
)
;
}
}
}
nsresult
XMLHttpRequestMainThread
:
:
OnRedirectVerifyCallback
(
nsresult
result
)
{
NS_ASSERTION
(
mRedirectCallback
"
mRedirectCallback
not
set
in
callback
"
)
;
NS_ASSERTION
(
mNewRedirectChannel
"
mNewRedirectChannel
not
set
in
callback
"
)
;
if
(
NS_SUCCEEDED
(
result
)
)
{
mChannel
=
mNewRedirectChannel
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
mChannel
)
)
;
if
(
httpChannel
)
{
SetAuthorRequestHeadersOnChannel
(
httpChannel
)
;
}
}
else
{
mErrorLoad
=
true
;
}
mNewRedirectChannel
=
nullptr
;
mRedirectCallback
-
>
OnRedirectVerifyCallback
(
result
)
;
mRedirectCallback
=
nullptr
;
return
result
;
}
void
XMLHttpRequestMainThread
:
:
MaybeDispatchProgressEvents
(
bool
aFinalProgress
)
{
if
(
aFinalProgress
&
&
mProgressTimerIsActive
)
{
mProgressTimerIsActive
=
false
;
mProgressNotifier
-
>
Cancel
(
)
;
}
if
(
mProgressTimerIsActive
|
|
!
mProgressSinceLastProgressEvent
|
|
mErrorLoad
|
|
mFlagSynchronous
)
{
return
;
}
if
(
!
aFinalProgress
)
{
StartProgressEventTimer
(
)
;
}
if
(
mState
=
=
State
:
:
opened
)
{
if
(
mUpload
&
&
!
mUploadComplete
)
{
DispatchProgressEvent
(
mUpload
ProgressEventType
:
:
progress
mUploadLengthComputable
mUploadTransferred
mUploadTotal
)
;
}
}
else
{
if
(
aFinalProgress
)
{
mLoadTotal
=
mLoadTransferred
;
}
mInLoadProgressEvent
=
true
;
DispatchProgressEvent
(
this
ProgressEventType
:
:
progress
mLoadLengthComputable
mLoadTransferred
mLoadTotal
)
;
mInLoadProgressEvent
=
false
;
if
(
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Moz_chunked_text
|
|
mResponseType
=
=
XMLHttpRequestResponseType
:
:
Moz_chunked_arraybuffer
)
{
mResponseBody
.
Truncate
(
)
;
mResponseText
.
Truncate
(
)
;
mResultArrayBuffer
=
nullptr
;
mArrayBufferBuilder
.
reset
(
)
;
}
}
mProgressSinceLastProgressEvent
=
false
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
OnProgress
(
nsIRequest
*
aRequest
nsISupports
*
aContext
int64_t
aProgress
int64_t
aProgressMax
)
{
bool
upload
=
mState
=
=
State
:
:
opened
;
bool
lengthComputable
=
(
aProgressMax
!
=
-
1
)
;
if
(
upload
)
{
int64_t
loaded
=
aProgress
;
if
(
lengthComputable
)
{
int64_t
headerSize
=
aProgressMax
-
mUploadTotal
;
loaded
-
=
headerSize
;
}
mUploadLengthComputable
=
lengthComputable
;
mUploadTransferred
=
loaded
;
mProgressSinceLastProgressEvent
=
true
;
MaybeDispatchProgressEvents
(
(
mUploadTransferred
=
=
mUploadTotal
)
)
;
}
else
{
mLoadLengthComputable
=
lengthComputable
;
mLoadTotal
=
lengthComputable
?
aProgressMax
:
0
;
mLoadTransferred
=
aProgress
;
}
if
(
mProgressEventSink
)
{
mProgressEventSink
-
>
OnProgress
(
aRequest
aContext
aProgress
aProgressMax
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
OnStatus
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatus
const
char16_t
*
aStatusArg
)
{
if
(
mProgressEventSink
)
{
mProgressEventSink
-
>
OnStatus
(
aRequest
aContext
aStatus
aStatusArg
)
;
}
return
NS_OK
;
}
bool
XMLHttpRequestMainThread
:
:
AllowUploadProgress
(
)
{
return
!
IsCrossSiteCORSRequest
(
)
|
|
mFlagHadUploadListenersOnSend
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
nsresult
rv
;
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIChannelEventSink
)
)
)
{
mChannelEventSink
=
do_GetInterface
(
mNotificationCallbacks
)
;
*
aResult
=
static_cast
<
nsIChannelEventSink
*
>
(
EnsureXPCOMifier
(
)
.
take
(
)
)
;
return
NS_OK
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIProgressEventSink
)
)
)
{
mProgressEventSink
=
do_GetInterface
(
mNotificationCallbacks
)
;
*
aResult
=
static_cast
<
nsIProgressEventSink
*
>
(
EnsureXPCOMifier
(
)
.
take
(
)
)
;
return
NS_OK
;
}
if
(
mNotificationCallbacks
)
{
rv
=
mNotificationCallbacks
-
>
GetInterface
(
aIID
aResult
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
NS_ASSERTION
(
*
aResult
"
Lying
nsIInterfaceRequestor
implementation
!
"
)
;
return
rv
;
}
}
if
(
mFlagBackgroundRequest
)
{
nsCOMPtr
<
nsIInterfaceRequestor
>
badCertHandler
(
do_CreateInstance
(
NS_BADCERTHANDLER_CONTRACTID
&
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
badCertHandler
-
>
GetInterface
(
aIID
aResult
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
return
rv
;
}
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPrompt
)
)
|
|
aIID
.
Equals
(
NS_GET_IID
(
nsIAuthPrompt2
)
)
)
{
nsCOMPtr
<
nsIPromptFactory
>
wwatch
=
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
;
if
(
GetOwner
(
)
)
{
window
=
GetOwner
(
)
-
>
GetOuterWindow
(
)
;
}
return
wwatch
-
>
GetPrompt
(
window
aIID
reinterpret_cast
<
void
*
*
>
(
aResult
)
)
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIStreamListener
)
)
)
{
*
aResult
=
static_cast
<
nsIStreamListener
*
>
(
EnsureXPCOMifier
(
)
.
take
(
)
)
;
return
NS_OK
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIRequestObserver
)
)
)
{
*
aResult
=
static_cast
<
nsIRequestObserver
*
>
(
EnsureXPCOMifier
(
)
.
take
(
)
)
;
return
NS_OK
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsITimerCallback
)
)
)
{
*
aResult
=
static_cast
<
nsITimerCallback
*
>
(
EnsureXPCOMifier
(
)
.
take
(
)
)
;
return
NS_OK
;
}
return
QueryInterface
(
aIID
aResult
)
;
}
void
XMLHttpRequestMainThread
:
:
GetInterface
(
JSContext
*
aCx
nsIJSID
*
aIID
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aRv
)
{
dom
:
:
GetInterface
(
aCx
this
aIID
aRetval
aRv
)
;
}
XMLHttpRequestUpload
*
XMLHttpRequestMainThread
:
:
GetUpload
(
ErrorResult
&
aRv
)
{
if
(
!
mUpload
)
{
mUpload
=
new
XMLHttpRequestUpload
(
this
)
;
}
return
mUpload
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetUpload
(
nsIXMLHttpRequestUpload
*
*
aUpload
)
{
ErrorResult
rv
;
RefPtr
<
XMLHttpRequestUpload
>
upload
=
GetUpload
(
rv
)
;
upload
.
forget
(
aUpload
)
;
return
rv
.
StealNSResult
(
)
;
}
bool
XMLHttpRequestMainThread
:
:
MozAnon
(
)
const
{
return
mIsAnon
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetMozAnon
(
bool
*
aAnon
)
{
*
aAnon
=
MozAnon
(
)
;
return
NS_OK
;
}
bool
XMLHttpRequestMainThread
:
:
MozSystem
(
)
const
{
return
IsSystemXHR
(
)
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
GetMozSystem
(
bool
*
aSystem
)
{
*
aSystem
=
MozSystem
(
)
;
return
NS_OK
;
}
void
XMLHttpRequestMainThread
:
:
HandleTimeoutCallback
(
)
{
if
(
mState
=
=
State
:
:
done
)
{
NS_NOTREACHED
(
"
XMLHttpRequestMainThread
:
:
HandleTimeoutCallback
with
completed
request
"
)
;
return
;
}
mFlagTimedOut
=
true
;
CloseRequestWithError
(
ProgressEventType
:
:
timeout
)
;
}
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
Notify
(
nsITimer
*
aTimer
)
{
if
(
mProgressNotifier
=
=
aTimer
)
{
HandleProgressTimerCallback
(
)
;
return
NS_OK
;
}
if
(
mTimeoutTimer
=
=
aTimer
)
{
HandleTimeoutCallback
(
)
;
return
NS_OK
;
}
NS_WARNING
(
"
Unexpected
timer
!
"
)
;
return
NS_ERROR_INVALID_POINTER
;
}
void
XMLHttpRequestMainThread
:
:
HandleProgressTimerCallback
(
)
{
mProgressTimerIsActive
=
false
;
MaybeDispatchProgressEvents
(
false
)
;
}
void
XMLHttpRequestMainThread
:
:
StartProgressEventTimer
(
)
{
if
(
!
mProgressNotifier
)
{
mProgressNotifier
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
)
;
}
if
(
mProgressNotifier
)
{
mProgressTimerIsActive
=
true
;
mProgressNotifier
-
>
Cancel
(
)
;
mProgressNotifier
-
>
InitWithCallback
(
this
NS_PROGRESS_EVENT_INTERVAL
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
}
already_AddRefed
<
nsXMLHttpRequestXPCOMifier
>
XMLHttpRequestMainThread
:
:
EnsureXPCOMifier
(
)
{
if
(
!
mXPCOMifier
)
{
mXPCOMifier
=
new
nsXMLHttpRequestXPCOMifier
(
this
)
;
}
RefPtr
<
nsXMLHttpRequestXPCOMifier
>
newRef
(
mXPCOMifier
)
;
return
newRef
.
forget
(
)
;
}
bool
XMLHttpRequestMainThread
:
:
ShouldBlockAuthPrompt
(
)
{
for
(
RequestHeader
&
requestHeader
:
mAuthorRequestHeaders
)
{
if
(
requestHeader
.
name
.
EqualsLiteral
(
"
authorization
"
)
)
{
return
true
;
}
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
mChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
nsCString
username
;
rv
=
uri
-
>
GetUsername
(
username
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
nsCString
password
;
rv
=
uri
-
>
GetPassword
(
password
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
if
(
!
username
.
IsEmpty
(
)
|
|
!
password
.
IsEmpty
(
)
)
{
return
true
;
}
return
false
;
}
NS_IMPL_ISUPPORTS
(
XMLHttpRequestMainThread
:
:
nsHeaderVisitor
nsIHttpHeaderVisitor
)
NS_IMETHODIMP
XMLHttpRequestMainThread
:
:
nsHeaderVisitor
:
:
VisitHeader
(
const
nsACString
&
header
const
nsACString
&
value
)
{
if
(
mXHR
.
IsSafeHeader
(
header
mHttpChannel
)
)
{
mHeaders
.
Append
(
header
)
;
mHeaders
.
AppendLiteral
(
"
:
"
)
;
mHeaders
.
Append
(
value
)
;
mHeaders
.
AppendLiteral
(
"
\
r
\
n
"
)
;
}
return
NS_OK
;
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsXMLHttpRequestXPCOMifier
)
NS_INTERFACE_MAP_ENTRY
(
nsIStreamListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequestObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIChannelEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsIAsyncVerifyRedirectCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsIProgressEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsITimerCallback
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIStreamListener
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsXMLHttpRequestXPCOMifier
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsXMLHttpRequestXPCOMifier
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsXMLHttpRequestXPCOMifier
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsXMLHttpRequestXPCOMifier
)
if
(
tmp
-
>
mXHR
)
{
tmp
-
>
mXHR
-
>
mXPCOMifier
=
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mXHR
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsXMLHttpRequestXPCOMifier
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mXHR
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMETHODIMP
nsXMLHttpRequestXPCOMifier
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
if
(
!
aIID
.
Equals
(
NS_GET_IID
(
nsIInterfaceRequestor
)
)
)
{
nsresult
rv
=
QueryInterface
(
aIID
aResult
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
rv
;
}
}
return
mXHR
-
>
GetInterface
(
aIID
aResult
)
;
}
ArrayBufferBuilder
:
:
ArrayBufferBuilder
(
)
:
mDataPtr
(
nullptr
)
mCapacity
(
0
)
mLength
(
0
)
mMapPtr
(
nullptr
)
{
}
ArrayBufferBuilder
:
:
~
ArrayBufferBuilder
(
)
{
reset
(
)
;
}
void
ArrayBufferBuilder
:
:
reset
(
)
{
if
(
mDataPtr
)
{
JS_free
(
nullptr
mDataPtr
)
;
}
if
(
mMapPtr
)
{
JS_ReleaseMappedArrayBufferContents
(
mMapPtr
mLength
)
;
mMapPtr
=
nullptr
;
}
mDataPtr
=
nullptr
;
mCapacity
=
mLength
=
0
;
}
bool
ArrayBufferBuilder
:
:
setCapacity
(
uint32_t
aNewCap
)
{
MOZ_ASSERT
(
!
mMapPtr
)
;
uint8_t
*
newdata
=
(
uint8_t
*
)
js_realloc
(
mDataPtr
aNewCap
?
aNewCap
:
1
)
;
if
(
!
newdata
)
{
return
false
;
}
if
(
aNewCap
>
mCapacity
)
{
memset
(
newdata
+
mCapacity
0
aNewCap
-
mCapacity
)
;
}
mDataPtr
=
newdata
;
mCapacity
=
aNewCap
;
if
(
mLength
>
aNewCap
)
{
mLength
=
aNewCap
;
}
return
true
;
}
bool
ArrayBufferBuilder
:
:
append
(
const
uint8_t
*
aNewData
uint32_t
aDataLen
uint32_t
aMaxGrowth
)
{
MOZ_ASSERT
(
!
mMapPtr
)
;
CheckedUint32
neededCapacity
=
mLength
;
neededCapacity
+
=
aDataLen
;
if
(
!
neededCapacity
.
isValid
(
)
)
{
return
false
;
}
if
(
mLength
+
aDataLen
>
mCapacity
)
{
CheckedUint32
newcap
=
mCapacity
;
if
(
!
aMaxGrowth
|
|
mCapacity
<
aMaxGrowth
)
{
newcap
*
=
2
;
}
else
{
newcap
+
=
aMaxGrowth
;
}
if
(
!
newcap
.
isValid
(
)
)
{
return
false
;
}
if
(
newcap
.
value
(
)
<
neededCapacity
.
value
(
)
)
{
newcap
=
neededCapacity
;
}
if
(
!
setCapacity
(
newcap
.
value
(
)
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
!
areOverlappingRegions
(
aNewData
aDataLen
mDataPtr
+
mLength
aDataLen
)
)
;
memcpy
(
mDataPtr
+
mLength
aNewData
aDataLen
)
;
mLength
+
=
aDataLen
;
return
true
;
}
JSObject
*
ArrayBufferBuilder
:
:
getArrayBuffer
(
JSContext
*
aCx
)
{
if
(
mMapPtr
)
{
JSObject
*
obj
=
JS_NewMappedArrayBufferWithContents
(
aCx
mLength
mMapPtr
)
;
if
(
!
obj
)
{
JS_ReleaseMappedArrayBufferContents
(
mMapPtr
mLength
)
;
}
mMapPtr
=
nullptr
;
return
obj
;
}
if
(
mCapacity
>
mLength
|
|
mLength
=
=
0
)
{
if
(
!
setCapacity
(
mLength
)
)
{
return
nullptr
;
}
}
JSObject
*
obj
=
JS_NewArrayBufferWithContents
(
aCx
mLength
mDataPtr
)
;
mLength
=
mCapacity
=
0
;
if
(
!
obj
)
{
js_free
(
mDataPtr
)
;
}
mDataPtr
=
nullptr
;
return
obj
;
}
nsresult
ArrayBufferBuilder
:
:
mapToFileInPackage
(
const
nsCString
&
aFile
nsIFile
*
aJarFile
)
{
nsresult
rv
;
RefPtr
<
nsZipArchive
>
zip
=
new
nsZipArchive
(
)
;
rv
=
zip
-
>
OpenArchive
(
aJarFile
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsZipItem
*
zipItem
=
zip
-
>
GetItem
(
aFile
.
get
(
)
)
;
if
(
!
zipItem
)
{
return
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
;
}
if
(
!
zipItem
-
>
Compression
(
)
)
{
uint32_t
offset
=
zip
-
>
GetDataOffset
(
zipItem
)
;
uint32_t
size
=
zipItem
-
>
RealSize
(
)
;
mozilla
:
:
AutoFDClose
pr_fd
;
rv
=
aJarFile
-
>
OpenNSPRFileDesc
(
PR_RDONLY
0
&
pr_fd
.
rwget
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mMapPtr
=
JS_CreateMappedArrayBufferContents
(
PR_FileDesc2NativeHandle
(
pr_fd
)
offset
size
)
;
if
(
mMapPtr
)
{
mLength
=
size
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
bool
ArrayBufferBuilder
:
:
areOverlappingRegions
(
const
uint8_t
*
aStart1
uint32_t
aLength1
const
uint8_t
*
aStart2
uint32_t
aLength2
)
{
const
uint8_t
*
end1
=
aStart1
+
aLength1
;
const
uint8_t
*
end2
=
aStart2
+
aLength2
;
const
uint8_t
*
max_start
=
aStart1
>
aStart2
?
aStart1
:
aStart2
;
const
uint8_t
*
min_end
=
end1
<
end2
?
end1
:
end2
;
return
max_start
<
min_end
;
}
}
}
