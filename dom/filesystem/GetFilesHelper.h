#
ifndef
mozilla_dom_GetFilesHelper_h
#
define
mozilla_dom_GetFilesHelper_h
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsCycleCollectionTraversalCallback
.
h
"
#
include
"
nsTArray
.
h
"
class
nsIGlobalObject
;
namespace
mozilla
{
namespace
dom
{
class
BlobImpl
;
class
ContentParent
;
class
File
;
class
GetFilesHelperParent
;
class
OwningFileOrDirectory
;
class
Promise
;
class
GetFilesCallback
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
GetFilesCallback
)
;
virtual
void
Callback
(
nsresult
aStatus
const
Sequence
<
RefPtr
<
File
>
>
&
aFiles
)
=
0
;
protected
:
virtual
~
GetFilesCallback
(
)
{
}
}
;
class
GetFilesHelper
:
public
Runnable
{
friend
class
GetFilesHelperParent
;
public
:
static
already_AddRefed
<
GetFilesHelper
>
Create
(
nsIGlobalObject
*
aGlobal
const
nsTArray
<
OwningFileOrDirectory
>
&
aFilesOrDirectory
bool
aRecursiveFlag
ErrorResult
&
aRv
)
;
void
AddPromise
(
Promise
*
aPromise
)
;
void
AddCallback
(
GetFilesCallback
*
aCallback
)
;
void
Unlink
(
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
&
cb
)
;
protected
:
GetFilesHelper
(
nsIGlobalObject
*
aGlobal
bool
aRecursiveFlag
)
;
virtual
~
GetFilesHelper
(
)
{
}
void
SetDirectoryPath
(
const
nsAString
&
aDirectoryPath
)
{
mDirectoryPath
=
aDirectoryPath
;
}
bool
IsCanceled
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
mCanceled
;
}
virtual
void
Work
(
ErrorResult
&
aRv
)
;
virtual
void
Cancel
(
)
{
}
;
NS_IMETHOD
Run
(
)
override
;
void
RunIO
(
)
;
void
RunMainThread
(
)
;
void
OperationCompleted
(
)
;
nsresult
ExploreDirectory
(
const
nsAString
&
aDOMPath
nsIFile
*
aFile
)
;
void
ResolveOrRejectPromise
(
Promise
*
aPromise
)
;
void
RunCallback
(
GetFilesCallback
*
aCallback
)
;
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
bool
mRecursiveFlag
;
bool
mListingCompleted
;
nsString
mDirectoryPath
;
struct
FileData
{
nsString
mDomPath
;
nsString
mRealPath
;
}
;
FallibleTArray
<
FileData
>
mTargetPathArray
;
Sequence
<
RefPtr
<
File
>
>
mFiles
;
nsresult
mErrorResult
;
nsTArray
<
RefPtr
<
Promise
>
>
mPromises
;
nsTArray
<
RefPtr
<
GetFilesCallback
>
>
mCallbacks
;
Mutex
mMutex
;
bool
mCanceled
;
}
;
class
GetFilesHelperChild
final
:
public
GetFilesHelper
{
public
:
GetFilesHelperChild
(
nsIGlobalObject
*
aGlobal
bool
aRecursiveFlag
)
:
GetFilesHelper
(
aGlobal
aRecursiveFlag
)
mPendingOperation
(
false
)
{
}
virtual
void
Work
(
ErrorResult
&
aRv
)
override
;
virtual
void
Cancel
(
)
override
;
bool
AppendBlobImpl
(
BlobImpl
*
aBlobImpl
)
;
void
Finished
(
nsresult
aResult
)
;
private
:
nsID
mUUID
;
bool
mPendingOperation
;
}
;
class
GetFilesHelperParentCallback
;
class
GetFilesHelperParent
final
:
public
GetFilesHelper
{
friend
class
GetFilesHelperParentCallback
;
public
:
static
already_AddRefed
<
GetFilesHelperParent
>
Create
(
const
nsID
&
aUUID
const
nsAString
&
aDirectoryPath
bool
aRecursiveFlag
ContentParent
*
aContentParent
ErrorResult
&
aRv
)
;
private
:
GetFilesHelperParent
(
const
nsID
&
aUUID
ContentParent
*
aContentParent
bool
aRecursiveFlag
)
;
RefPtr
<
ContentParent
>
mContentParent
;
nsID
mUUID
;
}
;
}
}
#
endif
