#
include
"
mozilla
/
dom
/
FileSystemTaskBase
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
FileSystemBase
.
h
"
#
include
"
mozilla
/
dom
/
FileSystemRequestParent
.
h
"
#
include
"
mozilla
/
dom
/
FileSystemUtils
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsProxyRelease
.
h
"
namespace
mozilla
:
:
dom
{
namespace
{
nsresult
FileSystemErrorFromNsError
(
const
nsresult
&
aErrorValue
)
{
uint16_t
module
=
NS_ERROR_GET_MODULE
(
aErrorValue
)
;
if
(
module
=
=
NS_ERROR_MODULE_DOM_FILESYSTEM
|
|
module
=
=
NS_ERROR_MODULE_DOM_FILE
|
|
module
=
=
NS_ERROR_MODULE_DOM
)
{
return
aErrorValue
;
}
switch
(
aErrorValue
)
{
case
NS_OK
:
return
NS_OK
;
case
NS_ERROR_FILE_INVALID_PATH
:
case
NS_ERROR_FILE_UNRECOGNIZED_PATH
:
return
NS_ERROR_DOM_FILESYSTEM_INVALID_PATH_ERR
;
case
NS_ERROR_FILE_DESTINATION_NOT_DIR
:
return
NS_ERROR_DOM_FILESYSTEM_INVALID_MODIFICATION_ERR
;
case
NS_ERROR_FILE_ACCESS_DENIED
:
case
NS_ERROR_FILE_DIR_NOT_EMPTY
:
return
NS_ERROR_DOM_FILESYSTEM_NO_MODIFICATION_ALLOWED_ERR
;
case
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
:
case
NS_ERROR_NOT_AVAILABLE
:
return
NS_ERROR_DOM_FILE_NOT_FOUND_ERR
;
case
NS_ERROR_FILE_ALREADY_EXISTS
:
return
NS_ERROR_DOM_FILESYSTEM_PATH_EXISTS_ERR
;
case
NS_ERROR_FILE_NOT_DIRECTORY
:
return
NS_ERROR_DOM_FILESYSTEM_TYPE_MISMATCH_ERR
;
case
NS_ERROR_UNEXPECTED
:
default
:
return
NS_ERROR_DOM_FILESYSTEM_UNKNOWN_ERR
;
}
}
nsresult
DispatchToIOThread
(
nsIRunnable
*
aRunnable
)
{
MOZ_ASSERT
(
aRunnable
)
;
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
)
;
MOZ_ASSERT
(
target
)
;
return
target
-
>
Dispatch
(
aRunnable
NS_DISPATCH_NORMAL
)
;
}
}
FileSystemTaskChildBase
:
:
FileSystemTaskChildBase
(
nsIGlobalObject
*
aGlobalObject
FileSystemBase
*
aFileSystem
)
:
mErrorValue
(
NS_OK
)
mFileSystem
(
aFileSystem
)
mGlobalObject
(
aGlobalObject
)
{
MOZ_ASSERT
(
aFileSystem
"
aFileSystem
should
not
be
null
.
"
)
;
aFileSystem
-
>
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aGlobalObject
)
;
}
FileSystemTaskChildBase
:
:
~
FileSystemTaskChildBase
(
)
{
mFileSystem
-
>
AssertIsOnOwningThread
(
)
;
}
FileSystemBase
*
FileSystemTaskChildBase
:
:
GetFileSystem
(
)
const
{
mFileSystem
-
>
AssertIsOnOwningThread
(
)
;
return
mFileSystem
.
get
(
)
;
}
void
FileSystemTaskChildBase
:
:
Start
(
)
{
mFileSystem
-
>
AssertIsOnOwningThread
(
)
;
mozilla
:
:
ipc
:
:
PBackgroundChild
*
actor
=
mozilla
:
:
ipc
:
:
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
actor
)
)
{
return
;
}
nsAutoString
serialization
;
mFileSystem
-
>
SerializeDOMPath
(
serialization
)
;
ErrorResult
rv
;
FileSystemParams
params
=
GetRequestParams
(
serialization
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
rv
.
SuppressException
(
)
;
return
;
}
if
(
NS_IsMainThread
(
)
)
{
nsISerialEventTarget
*
target
=
mGlobalObject
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
;
MOZ_ASSERT
(
target
)
;
actor
-
>
SetEventTargetForActor
(
this
target
)
;
}
actor
-
>
SendPFileSystemRequestConstructor
(
this
params
)
;
}
void
FileSystemTaskChildBase
:
:
SetRequestResult
(
const
FileSystemResponseValue
&
aValue
)
{
mFileSystem
-
>
AssertIsOnOwningThread
(
)
;
if
(
aValue
.
type
(
)
=
=
FileSystemResponseValue
:
:
TFileSystemErrorResponse
)
{
FileSystemErrorResponse
r
=
aValue
;
mErrorValue
=
r
.
error
(
)
;
}
else
{
ErrorResult
rv
;
SetSuccessRequestResult
(
aValue
rv
)
;
mErrorValue
=
rv
.
StealNSResult
(
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
FileSystemTaskChildBase
:
:
Recv__delete__
(
const
FileSystemResponseValue
&
aValue
)
{
mFileSystem
-
>
AssertIsOnOwningThread
(
)
;
SetRequestResult
(
aValue
)
;
HandlerCallback
(
)
;
return
IPC_OK
(
)
;
}
void
FileSystemTaskChildBase
:
:
SetError
(
const
nsresult
&
aErrorValue
)
{
mErrorValue
=
FileSystemErrorFromNsError
(
aErrorValue
)
;
}
FileSystemTaskParentBase
:
:
FileSystemTaskParentBase
(
FileSystemBase
*
aFileSystem
const
FileSystemParams
&
aParam
FileSystemRequestParent
*
aParent
)
:
Runnable
(
"
dom
:
:
FileSystemTaskParentBase
"
)
mErrorValue
(
NS_OK
)
mFileSystem
(
aFileSystem
)
mRequestParent
(
aParent
)
mBackgroundEventTarget
(
GetCurrentEventTarget
(
)
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Only
call
from
parent
process
!
"
)
;
MOZ_ASSERT
(
aFileSystem
"
aFileSystem
should
not
be
null
.
"
)
;
MOZ_ASSERT
(
aParent
)
;
MOZ_ASSERT
(
mBackgroundEventTarget
)
;
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
}
FileSystemTaskParentBase
:
:
~
FileSystemTaskParentBase
(
)
{
NS_ProxyRelease
(
"
FileSystemTaskParentBase
:
:
mFileSystem
"
mBackgroundEventTarget
mFileSystem
.
forget
(
)
)
;
NS_ProxyRelease
(
"
FileSystemTaskParentBase
:
:
mRequestParent
"
mBackgroundEventTarget
mRequestParent
.
forget
(
)
)
;
}
void
FileSystemTaskParentBase
:
:
Start
(
)
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
mFileSystem
-
>
AssertIsOnOwningThread
(
)
;
DebugOnly
<
nsresult
>
rv
=
DispatchToIOThread
(
this
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DispatchToIOThread
failed
"
)
;
}
void
FileSystemTaskParentBase
:
:
HandleResult
(
)
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
mFileSystem
-
>
AssertIsOnOwningThread
(
)
;
if
(
mFileSystem
-
>
IsShutdown
(
)
)
{
return
;
}
MOZ_ASSERT
(
mRequestParent
)
;
Unused
<
<
mRequestParent
-
>
Send__delete__
(
mRequestParent
GetRequestResult
(
)
)
;
}
FileSystemResponseValue
FileSystemTaskParentBase
:
:
GetRequestResult
(
)
const
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
mFileSystem
-
>
AssertIsOnOwningThread
(
)
;
if
(
HasError
(
)
)
{
return
FileSystemErrorResponse
(
mErrorValue
)
;
}
ErrorResult
rv
;
FileSystemResponseValue
value
=
GetSuccessRequestResult
(
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
FileSystemErrorResponse
(
rv
.
StealNSResult
(
)
)
;
}
return
value
;
}
void
FileSystemTaskParentBase
:
:
SetError
(
const
nsresult
&
aErrorValue
)
{
mErrorValue
=
FileSystemErrorFromNsError
(
aErrorValue
)
;
}
NS_IMETHODIMP
FileSystemTaskParentBase
:
:
Run
(
)
{
if
(
!
mozilla
:
:
ipc
:
:
IsOnBackgroundThread
(
)
)
{
nsresult
rv
=
IOWork
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
SetError
(
rv
)
;
}
rv
=
mBackgroundEventTarget
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
HandleResult
(
)
;
return
NS_OK
;
}
}
