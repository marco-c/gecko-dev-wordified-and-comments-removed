#
ifndef
mozilla_dom_Directory_h
#
define
mozilla_dom_Directory_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
ifdef
CreateDirectory
#
undef
CreateDirectory
#
endif
#
ifdef
CreateFile
#
undef
CreateFile
#
endif
namespace
mozilla
{
namespace
dom
{
struct
CreateFileOptions
;
class
FileSystemBase
;
class
Promise
;
class
StringOrFileOrDirectory
;
class
Directory
final
:
public
nsISupports
public
nsWrapperCache
{
public
:
struct
FileOrDirectoryPath
{
nsString
mPath
;
enum
{
eFilePath
eDirectoryPath
}
mType
;
}
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
Directory
)
static
bool
DeviceStorageEnabled
(
JSContext
*
aCx
JSObject
*
aObj
)
;
static
bool
WebkitBlinkDirectoryPickerEnabled
(
JSContext
*
aCx
JSObject
*
aObj
)
;
static
already_AddRefed
<
Promise
>
GetRoot
(
FileSystemBase
*
aFileSystem
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Directory
>
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aRealPath
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Directory
>
Create
(
nsISupports
*
aParent
nsIFile
*
aDirectory
FileSystemBase
*
aFileSystem
=
0
)
;
nsISupports
*
GetParentObject
(
)
const
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
void
GetName
(
nsAString
&
aRetval
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
CreateFile
(
const
nsAString
&
aPath
const
CreateFileOptions
&
aOptions
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
CreateDirectory
(
const
nsAString
&
aPath
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
Get
(
const
nsAString
&
aPath
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
Remove
(
const
StringOrFileOrDirectory
&
aPath
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
RemoveDeep
(
const
StringOrFileOrDirectory
&
aPath
ErrorResult
&
aRv
)
;
void
GetPath
(
nsAString
&
aRetval
ErrorResult
&
aRv
)
;
nsresult
GetFullRealPath
(
nsAString
&
aPath
)
;
already_AddRefed
<
Promise
>
GetFilesAndDirectories
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
GetFiles
(
bool
aRecursiveFlag
ErrorResult
&
aRv
)
;
void
SetContentFilters
(
const
nsAString
&
aFilters
)
;
FileSystemBase
*
GetFileSystem
(
ErrorResult
&
aRv
)
;
bool
ClonableToDifferentThreadOrProcess
(
)
const
;
private
:
Directory
(
nsISupports
*
aParent
nsIFile
*
aFile
FileSystemBase
*
aFileSystem
=
nullptr
)
;
~
Directory
(
)
;
nsresult
DOMPathToRealPath
(
const
nsAString
&
aPath
nsIFile
*
*
aFile
)
const
;
already_AddRefed
<
Promise
>
RemoveInternal
(
const
StringOrFileOrDirectory
&
aPath
bool
aRecursive
ErrorResult
&
aRv
)
;
nsCOMPtr
<
nsISupports
>
mParent
;
RefPtr
<
FileSystemBase
>
mFileSystem
;
nsCOMPtr
<
nsIFile
>
mFile
;
nsString
mFilters
;
nsString
mPath
;
}
;
}
}
#
endif
