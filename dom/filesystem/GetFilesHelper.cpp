#
include
"
GetFilesHelper
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
nsProxyRelease
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
class
ReleaseRunnable
final
:
public
Runnable
{
public
:
static
void
MaybeReleaseOnMainThread
(
nsTArray
<
RefPtr
<
Promise
>
>
&
aPromises
nsTArray
<
RefPtr
<
GetFilesCallback
>
>
&
aCallbacks
Sequence
<
RefPtr
<
File
>
>
&
aFiles
already_AddRefed
<
nsIGlobalObject
>
aGlobal
)
{
if
(
NS_IsMainThread
(
)
)
{
return
;
}
RefPtr
<
ReleaseRunnable
>
runnable
=
new
ReleaseRunnable
(
aPromises
aCallbacks
aFiles
Move
(
aGlobal
)
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mPromises
.
Clear
(
)
;
mCallbacks
.
Clear
(
)
;
mFiles
.
Clear
(
)
;
mGlobal
=
nullptr
;
return
NS_OK
;
}
private
:
ReleaseRunnable
(
nsTArray
<
RefPtr
<
Promise
>
>
&
aPromises
nsTArray
<
RefPtr
<
GetFilesCallback
>
>
&
aCallbacks
Sequence
<
RefPtr
<
File
>
>
&
aFiles
already_AddRefed
<
nsIGlobalObject
>
aGlobal
)
{
mPromises
.
SwapElements
(
aPromises
)
;
mCallbacks
.
SwapElements
(
aCallbacks
)
;
mFiles
.
SwapElements
(
aFiles
)
;
mGlobal
=
aGlobal
;
}
nsTArray
<
RefPtr
<
Promise
>
>
mPromises
;
nsTArray
<
RefPtr
<
GetFilesCallback
>
>
mCallbacks
;
Sequence
<
RefPtr
<
File
>
>
mFiles
;
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
}
;
}
already_AddRefed
<
GetFilesHelper
>
GetFilesHelper
:
:
Create
(
nsIGlobalObject
*
aGlobal
const
nsTArray
<
OwningFileOrDirectory
>
&
aFilesOrDirectory
bool
aRecursiveFlag
ErrorResult
&
aRv
)
{
RefPtr
<
GetFilesHelper
>
helper
;
if
(
XRE_IsParentProcess
(
)
)
{
helper
=
new
GetFilesHelper
(
aGlobal
aRecursiveFlag
)
;
}
else
{
helper
=
new
GetFilesHelperChild
(
aGlobal
aRecursiveFlag
)
;
}
nsAutoString
directoryPath
;
for
(
uint32_t
i
=
0
;
i
<
aFilesOrDirectory
.
Length
(
)
;
+
+
i
)
{
const
OwningFileOrDirectory
&
data
=
aFilesOrDirectory
[
i
]
;
if
(
data
.
IsFile
(
)
)
{
if
(
!
helper
-
>
mFiles
.
AppendElement
(
data
.
GetAsFile
(
)
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
nullptr
;
}
}
else
{
MOZ_ASSERT
(
data
.
IsDirectory
(
)
)
;
MOZ_ASSERT
(
directoryPath
.
IsEmpty
(
)
)
;
RefPtr
<
Directory
>
directory
=
data
.
GetAsDirectory
(
)
;
MOZ_ASSERT
(
directory
)
;
aRv
=
directory
-
>
GetFullRealPath
(
directoryPath
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
}
}
if
(
directoryPath
.
IsEmpty
(
)
)
{
helper
-
>
mListingCompleted
=
true
;
return
helper
.
forget
(
)
;
}
MOZ_ASSERT
(
helper
-
>
mFiles
.
IsEmpty
(
)
)
;
helper
-
>
SetDirectoryPath
(
directoryPath
)
;
helper
-
>
Work
(
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
return
helper
.
forget
(
)
;
}
GetFilesHelper
:
:
GetFilesHelper
(
nsIGlobalObject
*
aGlobal
bool
aRecursiveFlag
)
:
GetFilesHelperBase
(
aRecursiveFlag
)
mGlobal
(
aGlobal
)
mListingCompleted
(
false
)
mErrorResult
(
NS_OK
)
mMutex
(
"
GetFilesHelper
:
:
mMutex
"
)
mCanceled
(
false
)
{
}
GetFilesHelper
:
:
~
GetFilesHelper
(
)
{
ReleaseRunnable
:
:
MaybeReleaseOnMainThread
(
mPromises
mCallbacks
mFiles
mGlobal
.
forget
(
)
)
;
}
void
GetFilesHelper
:
:
AddPromise
(
Promise
*
aPromise
)
{
MOZ_ASSERT
(
aPromise
)
;
if
(
!
mListingCompleted
)
{
mPromises
.
AppendElement
(
aPromise
)
;
return
;
}
MOZ_ASSERT
(
mPromises
.
IsEmpty
(
)
)
;
ResolveOrRejectPromise
(
aPromise
)
;
}
void
GetFilesHelper
:
:
AddCallback
(
GetFilesCallback
*
aCallback
)
{
MOZ_ASSERT
(
aCallback
)
;
if
(
!
mListingCompleted
)
{
mCallbacks
.
AppendElement
(
aCallback
)
;
return
;
}
MOZ_ASSERT
(
mCallbacks
.
IsEmpty
(
)
)
;
RunCallback
(
aCallback
)
;
}
void
GetFilesHelper
:
:
Unlink
(
)
{
mGlobal
=
nullptr
;
mFiles
.
Clear
(
)
;
mPromises
.
Clear
(
)
;
mCallbacks
.
Clear
(
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
mCanceled
=
true
;
}
Cancel
(
)
;
}
void
GetFilesHelper
:
:
Traverse
(
nsCycleCollectionTraversalCallback
&
cb
)
{
GetFilesHelper
*
tmp
=
this
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mGlobal
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFiles
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPromises
)
;
}
void
GetFilesHelper
:
:
Work
(
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
)
;
MOZ_ASSERT
(
target
)
;
aRv
=
target
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
GetFilesHelper
:
:
Run
(
)
{
MOZ_ASSERT
(
!
mDirectoryPath
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
mListingCompleted
)
;
if
(
!
NS_IsMainThread
(
)
)
{
RunIO
(
)
;
if
(
IsCanceled
(
)
)
{
return
NS_OK
;
}
return
NS_DispatchToMainThread
(
this
)
;
}
if
(
IsCanceled
(
)
)
{
return
NS_OK
;
}
RunMainThread
(
)
;
OperationCompleted
(
)
;
return
NS_OK
;
}
void
GetFilesHelper
:
:
OperationCompleted
(
)
{
mListingCompleted
=
true
;
nsTArray
<
RefPtr
<
Promise
>
>
promises
;
promises
.
SwapElements
(
mPromises
)
;
for
(
uint32_t
i
=
0
;
i
<
promises
.
Length
(
)
;
+
+
i
)
{
ResolveOrRejectPromise
(
promises
[
i
]
)
;
}
nsTArray
<
RefPtr
<
GetFilesCallback
>
>
callbacks
;
callbacks
.
SwapElements
(
mCallbacks
)
;
for
(
uint32_t
i
=
0
;
i
<
callbacks
.
Length
(
)
;
+
+
i
)
{
RunCallback
(
callbacks
[
i
]
)
;
}
}
void
GetFilesHelper
:
:
RunIO
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mDirectoryPath
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
mListingCompleted
)
;
nsCOMPtr
<
nsIFile
>
file
;
mErrorResult
=
NS_NewLocalFile
(
mDirectoryPath
true
getter_AddRefs
(
file
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
mErrorResult
)
)
)
{
return
;
}
nsAutoString
path
;
mErrorResult
=
file
-
>
GetLeafName
(
path
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
mErrorResult
)
)
)
{
return
;
}
if
(
path
.
IsEmpty
(
)
)
{
path
.
AppendLiteral
(
FILESYSTEM_DOM_PATH_SEPARATOR_LITERAL
)
;
}
mErrorResult
=
ExploreDirectory
(
path
file
)
;
}
void
GetFilesHelper
:
:
RunMainThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mDirectoryPath
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
mListingCompleted
)
;
if
(
NS_FAILED
(
mErrorResult
)
)
{
return
;
}
for
(
uint32_t
i
=
0
;
i
<
mTargetPathArray
.
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
nsIFile
>
file
;
mErrorResult
=
NS_NewLocalFile
(
mTargetPathArray
[
i
]
.
mRealPath
true
getter_AddRefs
(
file
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
mErrorResult
)
)
)
{
mFiles
.
Clear
(
)
;
return
;
}
RefPtr
<
File
>
domFile
=
File
:
:
CreateFromFile
(
mGlobal
file
)
;
MOZ_ASSERT
(
domFile
)
;
domFile
-
>
SetPath
(
mTargetPathArray
[
i
]
.
mDomPath
)
;
if
(
!
mFiles
.
AppendElement
(
domFile
fallible
)
)
{
mErrorResult
=
NS_ERROR_OUT_OF_MEMORY
;
mFiles
.
Clear
(
)
;
return
;
}
}
}
nsresult
GetFilesHelperBase
:
:
ExploreDirectory
(
const
nsAString
&
aDOMPath
nsIFile
*
aFile
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aFile
)
;
if
(
IsCanceled
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
AddExploredDirectory
(
aFile
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsISimpleEnumerator
>
entries
;
rv
=
aFile
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
;
;
)
{
bool
hasMore
=
false
;
if
(
NS_WARN_IF
(
NS_FAILED
(
entries
-
>
HasMoreElements
(
&
hasMore
)
)
)
|
|
!
hasMore
)
{
break
;
}
nsCOMPtr
<
nsISupports
>
supp
;
if
(
NS_WARN_IF
(
NS_FAILED
(
entries
-
>
GetNext
(
getter_AddRefs
(
supp
)
)
)
)
)
{
break
;
}
nsCOMPtr
<
nsIFile
>
currFile
=
do_QueryInterface
(
supp
)
;
MOZ_ASSERT
(
currFile
)
;
bool
isLink
isSpecial
isFile
isDir
;
if
(
NS_WARN_IF
(
NS_FAILED
(
currFile
-
>
IsSymlink
(
&
isLink
)
)
|
|
NS_FAILED
(
currFile
-
>
IsSpecial
(
&
isSpecial
)
)
)
|
|
isSpecial
)
{
continue
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
currFile
-
>
IsFile
(
&
isFile
)
)
|
|
NS_FAILED
(
currFile
-
>
IsDirectory
(
&
isDir
)
)
)
|
|
!
(
isFile
|
|
isDir
)
)
{
continue
;
}
if
(
isDir
&
&
isLink
&
&
!
ShouldFollowSymLink
(
currFile
)
)
{
continue
;
}
nsAutoString
domPath
;
domPath
.
Assign
(
aDOMPath
)
;
if
(
!
aDOMPath
.
EqualsLiteral
(
FILESYSTEM_DOM_PATH_SEPARATOR_LITERAL
)
)
{
domPath
.
AppendLiteral
(
FILESYSTEM_DOM_PATH_SEPARATOR_LITERAL
)
;
}
nsAutoString
leafName
;
if
(
NS_WARN_IF
(
NS_FAILED
(
currFile
-
>
GetLeafName
(
leafName
)
)
)
)
{
continue
;
}
domPath
.
Append
(
leafName
)
;
if
(
isFile
)
{
FileData
*
data
=
mTargetPathArray
.
AppendElement
(
fallible
)
;
if
(
!
data
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
currFile
-
>
GetPath
(
data
-
>
mRealPath
)
)
)
)
{
continue
;
}
data
-
>
mDomPath
=
domPath
;
continue
;
}
MOZ_ASSERT
(
isDir
)
;
if
(
!
mRecursiveFlag
)
{
continue
;
}
rv
=
ExploreDirectory
(
domPath
currFile
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
GetFilesHelperBase
:
:
AddExploredDirectory
(
nsIFile
*
aDir
)
{
nsresult
rv
;
#
ifdef
DEBUG
bool
isDir
;
rv
=
aDir
-
>
IsDirectory
(
&
isDir
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
isDir
"
Why
are
we
here
?
"
)
;
#
endif
bool
isLink
;
rv
=
aDir
-
>
IsSymlink
(
&
isLink
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAutoString
path
;
if
(
!
isLink
)
{
rv
=
aDir
-
>
GetPath
(
path
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
aDir
-
>
GetTarget
(
path
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
mExploredDirectories
.
PutEntry
(
path
)
;
return
NS_OK
;
}
bool
GetFilesHelperBase
:
:
ShouldFollowSymLink
(
nsIFile
*
aDir
)
{
#
ifdef
DEBUG
bool
isLink
isDir
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aDir
-
>
IsSymlink
(
&
isLink
)
)
|
|
NS_FAILED
(
aDir
-
>
IsDirectory
(
&
isDir
)
)
)
)
{
return
false
;
}
MOZ_ASSERT
(
isLink
&
&
isDir
"
Why
are
we
here
?
"
)
;
#
endif
nsAutoString
targetPath
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aDir
-
>
GetTarget
(
targetPath
)
)
)
)
{
return
false
;
}
return
!
mExploredDirectories
.
Contains
(
targetPath
)
;
}
void
GetFilesHelper
:
:
ResolveOrRejectPromise
(
Promise
*
aPromise
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mListingCompleted
)
;
MOZ_ASSERT
(
aPromise
)
;
if
(
NS_FAILED
(
mErrorResult
)
)
{
aPromise
-
>
MaybeReject
(
mErrorResult
)
;
return
;
}
aPromise
-
>
MaybeResolve
(
mFiles
)
;
}
void
GetFilesHelper
:
:
RunCallback
(
GetFilesCallback
*
aCallback
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mListingCompleted
)
;
MOZ_ASSERT
(
aCallback
)
;
aCallback
-
>
Callback
(
mErrorResult
mFiles
)
;
}
void
GetFilesHelperChild
:
:
Work
(
ErrorResult
&
aRv
)
{
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
if
(
NS_WARN_IF
(
!
cc
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aRv
=
nsContentUtils
:
:
GenerateUUIDInPlace
(
mUUID
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
mPendingOperation
=
true
;
cc
-
>
CreateGetFilesRequest
(
mDirectoryPath
mRecursiveFlag
mUUID
this
)
;
}
void
GetFilesHelperChild
:
:
Cancel
(
)
{
if
(
!
mPendingOperation
)
{
return
;
}
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
if
(
NS_WARN_IF
(
!
cc
)
)
{
return
;
}
mPendingOperation
=
false
;
cc
-
>
DeleteGetFilesRequest
(
mUUID
this
)
;
}
bool
GetFilesHelperChild
:
:
AppendBlobImpl
(
BlobImpl
*
aBlobImpl
)
{
MOZ_ASSERT
(
mPendingOperation
)
;
MOZ_ASSERT
(
aBlobImpl
)
;
MOZ_ASSERT
(
aBlobImpl
-
>
IsFile
(
)
)
;
RefPtr
<
File
>
file
=
File
:
:
Create
(
mGlobal
aBlobImpl
)
;
MOZ_ASSERT
(
file
)
;
return
mFiles
.
AppendElement
(
file
fallible
)
;
}
void
GetFilesHelperChild
:
:
Finished
(
nsresult
aError
)
{
MOZ_ASSERT
(
mPendingOperation
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
mErrorResult
)
)
;
mPendingOperation
=
false
;
mErrorResult
=
aError
;
OperationCompleted
(
)
;
}
class
GetFilesHelperParentCallback
final
:
public
GetFilesCallback
{
public
:
explicit
GetFilesHelperParentCallback
(
GetFilesHelperParent
*
aParent
)
:
mParent
(
aParent
)
{
MOZ_ASSERT
(
aParent
)
;
}
void
Callback
(
nsresult
aStatus
const
Sequence
<
RefPtr
<
File
>
>
&
aFiles
)
override
{
if
(
NS_FAILED
(
aStatus
)
)
{
mParent
-
>
mContentParent
-
>
SendGetFilesResponseAndForget
(
mParent
-
>
mUUID
GetFilesResponseFailure
(
aStatus
)
)
;
return
;
}
GetFilesResponseSuccess
success
;
nsTArray
<
PBlobParent
*
>
&
blobsParent
=
success
.
blobsParent
(
)
;
blobsParent
.
SetLength
(
aFiles
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aFiles
.
Length
(
)
;
+
+
i
)
{
blobsParent
[
i
]
=
mParent
-
>
mContentParent
-
>
GetOrCreateActorForBlob
(
aFiles
[
i
]
)
;
if
(
!
blobsParent
[
i
]
)
{
mParent
-
>
mContentParent
-
>
SendGetFilesResponseAndForget
(
mParent
-
>
mUUID
GetFilesResponseFailure
(
NS_ERROR_OUT_OF_MEMORY
)
)
;
return
;
}
}
mParent
-
>
mContentParent
-
>
SendGetFilesResponseAndForget
(
mParent
-
>
mUUID
success
)
;
}
private
:
GetFilesHelperParent
*
mParent
;
}
;
GetFilesHelperParent
:
:
GetFilesHelperParent
(
const
nsID
&
aUUID
ContentParent
*
aContentParent
bool
aRecursiveFlag
)
:
GetFilesHelper
(
nullptr
aRecursiveFlag
)
mContentParent
(
aContentParent
)
mUUID
(
aUUID
)
{
}
GetFilesHelperParent
:
:
~
GetFilesHelperParent
(
)
{
NS_ReleaseOnMainThread
(
mContentParent
.
forget
(
)
)
;
}
already_AddRefed
<
GetFilesHelperParent
>
GetFilesHelperParent
:
:
Create
(
const
nsID
&
aUUID
const
nsAString
&
aDirectoryPath
bool
aRecursiveFlag
ContentParent
*
aContentParent
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aContentParent
)
;
RefPtr
<
GetFilesHelperParent
>
helper
=
new
GetFilesHelperParent
(
aUUID
aContentParent
aRecursiveFlag
)
;
helper
-
>
SetDirectoryPath
(
aDirectoryPath
)
;
helper
-
>
Work
(
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
RefPtr
<
GetFilesHelperParentCallback
>
callback
=
new
GetFilesHelperParentCallback
(
helper
)
;
helper
-
>
AddCallback
(
callback
)
;
return
helper
.
forget
(
)
;
}
}
}
