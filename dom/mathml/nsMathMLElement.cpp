#
include
"
nsMathMLElement
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsITableCellLayout
.
h
"
#
include
"
nsLayoutStylesheetCache
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
MappedDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
ElementBinding
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
NS_IMPL_ISUPPORTS_INHERITED
(
nsMathMLElement
nsMathMLElementBase
Link
)
static
nsresult
WarnDeprecated
(
const
char16_t
*
aDeprecatedAttribute
const
char16_t
*
aFavoredAttribute
nsIDocument
*
aDocument
)
{
const
char16_t
*
argv
[
]
=
{
aDeprecatedAttribute
aFavoredAttribute
}
;
return
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
MathML
"
)
aDocument
nsContentUtils
:
:
eMATHML_PROPERTIES
"
DeprecatedSupersededBy
"
argv
2
)
;
}
static
nsresult
ReportLengthParseError
(
const
nsString
&
aValue
nsIDocument
*
aDocument
)
{
const
char16_t
*
arg
=
aValue
.
get
(
)
;
return
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
NS_LITERAL_CSTRING
(
"
MathML
"
)
aDocument
nsContentUtils
:
:
eMATHML_PROPERTIES
"
LengthParsingError
"
&
arg
1
)
;
}
static
nsresult
ReportParseErrorNoTag
(
const
nsString
&
aValue
nsAtom
*
aAtom
nsIDocument
*
aDocument
)
{
const
char16_t
*
argv
[
]
=
{
aValue
.
get
(
)
aAtom
-
>
GetUTF16String
(
)
}
;
return
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
NS_LITERAL_CSTRING
(
"
MathML
"
)
aDocument
nsContentUtils
:
:
eMATHML_PROPERTIES
"
AttributeParsingErrorNoTag
"
argv
2
)
;
}
nsMathMLElement
:
:
nsMathMLElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
:
nsMathMLElementBase
(
aNodeInfo
)
ALLOW_THIS_IN_INITIALIZER_LIST
(
Link
(
this
)
)
mIncrementScriptLevel
(
false
)
{
}
nsMathMLElement
:
:
nsMathMLElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
nsMathMLElementBase
(
aNodeInfo
)
ALLOW_THIS_IN_INITIALIZER_LIST
(
Link
(
this
)
)
mIncrementScriptLevel
(
false
)
{
}
nsresult
nsMathMLElement
:
:
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
{
Link
:
:
ResetLinkState
(
false
Link
:
:
ElementHasHref
(
)
)
;
nsresult
rv
=
nsMathMLElementBase
:
:
BindToTree
(
aDocument
aParent
aBindingParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aDocument
)
{
aDocument
-
>
RegisterPendingLinkUpdate
(
this
)
;
}
if
(
nsIDocument
*
doc
=
GetComposedDoc
(
)
)
{
doc
-
>
SetMathMLEnabled
(
)
;
}
return
rv
;
}
void
nsMathMLElement
:
:
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
{
Link
:
:
ResetLinkState
(
false
Link
:
:
ElementHasHref
(
)
)
;
nsMathMLElementBase
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
}
bool
nsMathMLElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
MOZ_ASSERT
(
IsMathMLElement
(
)
)
;
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
mNodeInfo
-
>
Equals
(
nsGkAtoms
:
:
math
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
mode
)
{
WarnDeprecated
(
nsGkAtoms
:
:
mode
-
>
GetUTF16String
(
)
nsGkAtoms
:
:
display
-
>
GetUTF16String
(
)
OwnerDoc
(
)
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
color
)
{
WarnDeprecated
(
nsGkAtoms
:
:
color
-
>
GetUTF16String
(
)
nsGkAtoms
:
:
mathcolor_
-
>
GetUTF16String
(
)
OwnerDoc
(
)
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
color
|
|
aAttribute
=
=
nsGkAtoms
:
:
mathcolor_
|
|
aAttribute
=
=
nsGkAtoms
:
:
background
|
|
aAttribute
=
=
nsGkAtoms
:
:
mathbackground_
)
{
return
aResult
.
ParseColor
(
aValue
)
;
}
if
(
mNodeInfo
-
>
Equals
(
nsGkAtoms
:
:
mtd_
)
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
columnspan_
)
{
aResult
.
ParseClampedNonNegativeInt
(
aValue
1
1
MAX_COLSPAN
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
rowspan
)
{
aResult
.
ParseClampedNonNegativeInt
(
aValue
1
0
MAX_ROWSPAN
)
;
return
true
;
}
}
}
return
nsMathMLElementBase
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
static
Element
:
:
MappedAttributeEntry
sMtableStyles
[
]
=
{
{
&
nsGkAtoms
:
:
width
}
{
nullptr
}
}
;
static
Element
:
:
MappedAttributeEntry
sTokenStyles
[
]
=
{
{
&
nsGkAtoms
:
:
mathsize_
}
{
&
nsGkAtoms
:
:
fontsize_
}
{
&
nsGkAtoms
:
:
color
}
{
&
nsGkAtoms
:
:
fontfamily_
}
{
&
nsGkAtoms
:
:
fontstyle_
}
{
&
nsGkAtoms
:
:
fontweight_
}
{
&
nsGkAtoms
:
:
mathvariant_
}
{
nullptr
}
}
;
static
Element
:
:
MappedAttributeEntry
sEnvironmentStyles
[
]
=
{
{
&
nsGkAtoms
:
:
scriptlevel_
}
{
&
nsGkAtoms
:
:
scriptminsize_
}
{
&
nsGkAtoms
:
:
scriptsizemultiplier_
}
{
&
nsGkAtoms
:
:
background
}
{
nullptr
}
}
;
static
Element
:
:
MappedAttributeEntry
sCommonPresStyles
[
]
=
{
{
&
nsGkAtoms
:
:
mathcolor_
}
{
&
nsGkAtoms
:
:
mathbackground_
}
{
nullptr
}
}
;
static
Element
:
:
MappedAttributeEntry
sDirStyles
[
]
=
{
{
&
nsGkAtoms
:
:
dir
}
{
nullptr
}
}
;
bool
nsMathMLElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
MOZ_ASSERT
(
IsMathMLElement
(
)
)
;
static
const
MappedAttributeEntry
*
const
mtableMap
[
]
=
{
sMtableStyles
sCommonPresStyles
}
;
static
const
MappedAttributeEntry
*
const
tokenMap
[
]
=
{
sTokenStyles
sCommonPresStyles
sDirStyles
}
;
static
const
MappedAttributeEntry
*
const
mstyleMap
[
]
=
{
sTokenStyles
sEnvironmentStyles
sCommonPresStyles
sDirStyles
}
;
static
const
MappedAttributeEntry
*
const
commonPresMap
[
]
=
{
sCommonPresStyles
}
;
static
const
MappedAttributeEntry
*
const
mrowMap
[
]
=
{
sCommonPresStyles
sDirStyles
}
;
if
(
IsAnyOfMathMLElements
(
nsGkAtoms
:
:
ms_
nsGkAtoms
:
:
mi_
nsGkAtoms
:
:
mn_
nsGkAtoms
:
:
mo_
nsGkAtoms
:
:
mtext_
nsGkAtoms
:
:
mspace_
)
)
return
FindAttributeDependence
(
aAttribute
tokenMap
)
;
if
(
IsAnyOfMathMLElements
(
nsGkAtoms
:
:
mstyle_
nsGkAtoms
:
:
math
)
)
return
FindAttributeDependence
(
aAttribute
mstyleMap
)
;
if
(
mNodeInfo
-
>
Equals
(
nsGkAtoms
:
:
mtable_
)
)
return
FindAttributeDependence
(
aAttribute
mtableMap
)
;
if
(
mNodeInfo
-
>
Equals
(
nsGkAtoms
:
:
mrow_
)
)
return
FindAttributeDependence
(
aAttribute
mrowMap
)
;
if
(
IsAnyOfMathMLElements
(
nsGkAtoms
:
:
maction_
nsGkAtoms
:
:
maligngroup_
nsGkAtoms
:
:
malignmark_
nsGkAtoms
:
:
menclose_
nsGkAtoms
:
:
merror_
nsGkAtoms
:
:
mfenced_
nsGkAtoms
:
:
mfrac_
nsGkAtoms
:
:
mover_
nsGkAtoms
:
:
mpadded_
nsGkAtoms
:
:
mphantom_
nsGkAtoms
:
:
mprescripts_
nsGkAtoms
:
:
mroot_
nsGkAtoms
:
:
msqrt_
nsGkAtoms
:
:
msub_
nsGkAtoms
:
:
msubsup_
nsGkAtoms
:
:
msup_
nsGkAtoms
:
:
mtd_
nsGkAtoms
:
:
mtr_
nsGkAtoms
:
:
munder_
nsGkAtoms
:
:
munderover_
nsGkAtoms
:
:
none
)
)
{
return
FindAttributeDependence
(
aAttribute
commonPresMap
)
;
}
return
false
;
}
nsMapRuleToAttributesFunc
nsMathMLElement
:
:
GetAttributeMappingFunction
(
)
const
{
return
&
MapMathMLAttributesInto
;
}
bool
nsMathMLElement
:
:
ParseNamedSpaceValue
(
const
nsString
&
aString
nsCSSValue
&
aCSSValue
uint32_t
aFlags
)
{
int32_t
i
=
0
;
if
(
aString
.
EqualsLiteral
(
"
veryverythinmathspace
"
)
)
{
i
=
1
;
}
else
if
(
aString
.
EqualsLiteral
(
"
verythinmathspace
"
)
)
{
i
=
2
;
}
else
if
(
aString
.
EqualsLiteral
(
"
thinmathspace
"
)
)
{
i
=
3
;
}
else
if
(
aString
.
EqualsLiteral
(
"
mediummathspace
"
)
)
{
i
=
4
;
}
else
if
(
aString
.
EqualsLiteral
(
"
thickmathspace
"
)
)
{
i
=
5
;
}
else
if
(
aString
.
EqualsLiteral
(
"
verythickmathspace
"
)
)
{
i
=
6
;
}
else
if
(
aString
.
EqualsLiteral
(
"
veryverythickmathspace
"
)
)
{
i
=
7
;
}
else
if
(
aFlags
&
PARSE_ALLOW_NEGATIVE
)
{
if
(
aString
.
EqualsLiteral
(
"
negativeveryverythinmathspace
"
)
)
{
i
=
-
1
;
}
else
if
(
aString
.
EqualsLiteral
(
"
negativeverythinmathspace
"
)
)
{
i
=
-
2
;
}
else
if
(
aString
.
EqualsLiteral
(
"
negativethinmathspace
"
)
)
{
i
=
-
3
;
}
else
if
(
aString
.
EqualsLiteral
(
"
negativemediummathspace
"
)
)
{
i
=
-
4
;
}
else
if
(
aString
.
EqualsLiteral
(
"
negativethickmathspace
"
)
)
{
i
=
-
5
;
}
else
if
(
aString
.
EqualsLiteral
(
"
negativeverythickmathspace
"
)
)
{
i
=
-
6
;
}
else
if
(
aString
.
EqualsLiteral
(
"
negativeveryverythickmathspace
"
)
)
{
i
=
-
7
;
}
}
if
(
0
!
=
i
)
{
aCSSValue
.
SetFloatValue
(
float
(
i
)
/
float
(
18
)
eCSSUnit_EM
)
;
return
true
;
}
return
false
;
}
bool
nsMathMLElement
:
:
ParseNumericValue
(
const
nsString
&
aString
nsCSSValue
&
aCSSValue
uint32_t
aFlags
nsIDocument
*
aDocument
)
{
nsAutoString
str
(
aString
)
;
str
.
CompressWhitespace
(
)
;
int32_t
stringLength
=
str
.
Length
(
)
;
if
(
!
stringLength
)
{
if
(
!
(
aFlags
&
PARSE_SUPPRESS_WARNINGS
)
)
{
ReportLengthParseError
(
aString
aDocument
)
;
}
return
false
;
}
if
(
ParseNamedSpaceValue
(
str
aCSSValue
aFlags
)
)
{
return
true
;
}
nsAutoString
number
unit
;
int32_t
i
=
0
;
char16_t
c
=
str
[
0
]
;
if
(
c
=
=
'
-
'
)
{
number
.
Append
(
c
)
;
i
+
+
;
}
bool
gotDot
=
false
;
for
(
;
i
<
stringLength
;
i
+
+
)
{
c
=
str
[
i
]
;
if
(
gotDot
&
&
c
=
=
'
.
'
)
{
if
(
!
(
aFlags
&
PARSE_SUPPRESS_WARNINGS
)
)
{
ReportLengthParseError
(
aString
aDocument
)
;
}
return
false
;
}
else
if
(
c
=
=
'
.
'
)
gotDot
=
true
;
else
if
(
!
IsAsciiDigit
(
c
)
)
{
str
.
Right
(
unit
stringLength
-
i
)
;
break
;
}
number
.
Append
(
c
)
;
}
nsresult
errorCode
;
float
floatValue
=
number
.
ToFloat
(
&
errorCode
)
;
if
(
NS_FAILED
(
errorCode
)
)
{
if
(
!
(
aFlags
&
PARSE_SUPPRESS_WARNINGS
)
)
{
ReportLengthParseError
(
aString
aDocument
)
;
}
return
false
;
}
if
(
floatValue
<
0
&
&
!
(
aFlags
&
PARSE_ALLOW_NEGATIVE
)
)
{
if
(
!
(
aFlags
&
PARSE_SUPPRESS_WARNINGS
)
)
{
ReportLengthParseError
(
aString
aDocument
)
;
}
return
false
;
}
nsCSSUnit
cssUnit
;
if
(
unit
.
IsEmpty
(
)
)
{
if
(
aFlags
&
PARSE_ALLOW_UNITLESS
)
{
if
(
!
(
aFlags
&
PARSE_SUPPRESS_WARNINGS
)
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
MathML
"
)
aDocument
nsContentUtils
:
:
eMATHML_PROPERTIES
"
UnitlessValuesAreDeprecated
"
)
;
}
if
(
aFlags
&
CONVERT_UNITLESS_TO_PERCENT
)
{
aCSSValue
.
SetPercentValue
(
floatValue
)
;
return
true
;
}
else
cssUnit
=
eCSSUnit_Number
;
}
else
{
if
(
floatValue
!
=
0
.
0
)
{
if
(
!
(
aFlags
&
PARSE_SUPPRESS_WARNINGS
)
)
{
ReportLengthParseError
(
aString
aDocument
)
;
}
return
false
;
}
cssUnit
=
eCSSUnit_Pixel
;
}
}
else
if
(
unit
.
EqualsLiteral
(
"
%
"
)
)
{
aCSSValue
.
SetPercentValue
(
floatValue
/
100
.
0f
)
;
return
true
;
}
else
if
(
unit
.
EqualsLiteral
(
"
em
"
)
)
cssUnit
=
eCSSUnit_EM
;
else
if
(
unit
.
EqualsLiteral
(
"
ex
"
)
)
cssUnit
=
eCSSUnit_XHeight
;
else
if
(
unit
.
EqualsLiteral
(
"
px
"
)
)
cssUnit
=
eCSSUnit_Pixel
;
else
if
(
unit
.
EqualsLiteral
(
"
in
"
)
)
cssUnit
=
eCSSUnit_Inch
;
else
if
(
unit
.
EqualsLiteral
(
"
cm
"
)
)
cssUnit
=
eCSSUnit_Centimeter
;
else
if
(
unit
.
EqualsLiteral
(
"
mm
"
)
)
cssUnit
=
eCSSUnit_Millimeter
;
else
if
(
unit
.
EqualsLiteral
(
"
pt
"
)
)
cssUnit
=
eCSSUnit_Point
;
else
if
(
unit
.
EqualsLiteral
(
"
pc
"
)
)
cssUnit
=
eCSSUnit_Pica
;
else
if
(
unit
.
EqualsLiteral
(
"
q
"
)
)
cssUnit
=
eCSSUnit_Quarter
;
else
{
if
(
!
(
aFlags
&
PARSE_SUPPRESS_WARNINGS
)
)
{
ReportLengthParseError
(
aString
aDocument
)
;
}
return
false
;
}
aCSSValue
.
SetFloatValue
(
floatValue
cssUnit
)
;
return
true
;
}
void
nsMathMLElement
:
:
MapMathMLAttributesInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
scriptsizemultiplier_
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty__moz_script_size_multiplier
)
)
{
nsAutoString
str
(
value
-
>
GetStringValue
(
)
)
;
str
.
CompressWhitespace
(
)
;
if
(
str
.
Length
(
)
>
0
&
&
str
.
CharAt
(
0
)
!
=
'
+
'
)
{
nsresult
errorCode
;
float
floatValue
=
str
.
ToFloat
(
&
errorCode
)
;
if
(
NS_SUCCEEDED
(
errorCode
)
&
&
floatValue
>
=
0
.
0f
)
{
aDecls
.
SetNumberValue
(
eCSSProperty__moz_script_size_multiplier
floatValue
)
;
}
else
{
ReportParseErrorNoTag
(
str
nsGkAtoms
:
:
scriptsizemultiplier_
aDecls
.
Document
(
)
)
;
}
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
scriptminsize_
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty__moz_script_min_size
)
)
{
nsCSSValue
scriptMinSize
;
ParseNumericValue
(
value
-
>
GetStringValue
(
)
scriptMinSize
PARSE_ALLOW_UNITLESS
|
CONVERT_UNITLESS_TO_PERCENT
aDecls
.
Document
(
)
)
;
if
(
scriptMinSize
.
GetUnit
(
)
=
=
eCSSUnit_Percent
)
{
scriptMinSize
.
SetFloatValue
(
8
.
0
*
scriptMinSize
.
GetPercentValue
(
)
eCSSUnit_Point
)
;
}
if
(
scriptMinSize
.
GetUnit
(
)
!
=
eCSSUnit_Null
)
{
aDecls
.
SetLengthValue
(
eCSSProperty__moz_script_min_size
scriptMinSize
)
;
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
scriptlevel_
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty__moz_script_level
)
)
{
nsAutoString
str
(
value
-
>
GetStringValue
(
)
)
;
str
.
CompressWhitespace
(
)
;
if
(
str
.
Length
(
)
>
0
)
{
nsresult
errorCode
;
int32_t
intValue
=
str
.
ToInteger
(
&
errorCode
)
;
if
(
NS_SUCCEEDED
(
errorCode
)
)
{
char16_t
ch
=
str
.
CharAt
(
0
)
;
if
(
ch
=
=
'
+
'
|
|
ch
=
=
'
-
'
)
{
aDecls
.
SetIntValue
(
eCSSProperty__moz_script_level
intValue
)
;
}
else
{
aDecls
.
SetNumberValue
(
eCSSProperty__moz_script_level
intValue
)
;
}
}
else
{
ReportParseErrorNoTag
(
str
nsGkAtoms
:
:
scriptlevel_
aDecls
.
Document
(
)
)
;
}
}
}
bool
parseSizeKeywords
=
true
;
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
mathsize_
)
;
if
(
!
value
)
{
parseSizeKeywords
=
false
;
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
fontsize_
)
;
if
(
value
)
{
WarnDeprecated
(
nsGkAtoms
:
:
fontsize_
-
>
GetUTF16String
(
)
nsGkAtoms
:
:
mathsize_
-
>
GetUTF16String
(
)
aDecls
.
Document
(
)
)
;
}
}
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty_font_size
)
)
{
nsAutoString
str
(
value
-
>
GetStringValue
(
)
)
;
nsCSSValue
fontSize
;
if
(
!
ParseNumericValue
(
str
fontSize
PARSE_SUPPRESS_WARNINGS
|
PARSE_ALLOW_UNITLESS
|
CONVERT_UNITLESS_TO_PERCENT
nullptr
)
&
&
parseSizeKeywords
)
{
static
const
char
sizes
[
3
]
[
7
]
=
{
"
small
"
"
normal
"
"
big
"
}
;
static
const
int32_t
values
[
MOZ_ARRAY_LENGTH
(
sizes
)
]
=
{
NS_STYLE_FONT_SIZE_SMALL
NS_STYLE_FONT_SIZE_MEDIUM
NS_STYLE_FONT_SIZE_LARGE
}
;
str
.
CompressWhitespace
(
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
sizes
)
;
+
+
i
)
{
if
(
str
.
EqualsASCII
(
sizes
[
i
]
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_font_size
values
[
i
]
)
;
break
;
}
}
}
else
if
(
fontSize
.
GetUnit
(
)
=
=
eCSSUnit_Percent
)
{
aDecls
.
SetPercentValue
(
eCSSProperty_font_size
fontSize
.
GetPercentValue
(
)
)
;
}
else
if
(
fontSize
.
GetUnit
(
)
!
=
eCSSUnit_Null
)
{
aDecls
.
SetLengthValue
(
eCSSProperty_font_size
fontSize
)
;
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
fontfamily_
)
;
if
(
value
)
{
WarnDeprecated
(
nsGkAtoms
:
:
fontfamily_
-
>
GetUTF16String
(
)
nsGkAtoms
:
:
mathvariant_
-
>
GetUTF16String
(
)
aDecls
.
Document
(
)
)
;
}
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty_font_family
)
)
{
aDecls
.
SetFontFamily
(
value
-
>
GetStringValue
(
)
)
;
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
fontstyle_
)
;
if
(
value
)
{
WarnDeprecated
(
nsGkAtoms
:
:
fontstyle_
-
>
GetUTF16String
(
)
nsGkAtoms
:
:
mathvariant_
-
>
GetUTF16String
(
)
aDecls
.
Document
(
)
)
;
if
(
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty_font_style
)
)
{
nsAutoString
str
(
value
-
>
GetStringValue
(
)
)
;
str
.
CompressWhitespace
(
)
;
if
(
str
.
EqualsASCII
(
"
normal
"
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_font_style
NS_FONT_STYLE_NORMAL
)
;
}
else
if
(
str
.
EqualsASCII
(
"
italic
"
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_font_style
NS_FONT_STYLE_ITALIC
)
;
}
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
fontweight_
)
;
if
(
value
)
{
WarnDeprecated
(
nsGkAtoms
:
:
fontweight_
-
>
GetUTF16String
(
)
nsGkAtoms
:
:
mathvariant_
-
>
GetUTF16String
(
)
aDecls
.
Document
(
)
)
;
if
(
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty_font_weight
)
)
{
nsAutoString
str
(
value
-
>
GetStringValue
(
)
)
;
str
.
CompressWhitespace
(
)
;
if
(
str
.
EqualsASCII
(
"
normal
"
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_font_weight
FontWeight
:
:
Normal
(
)
.
ToFloat
(
)
)
;
}
else
if
(
str
.
EqualsASCII
(
"
bold
"
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_font_weight
FontWeight
:
:
Bold
(
)
.
ToFloat
(
)
)
;
}
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
mathvariant_
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty__moz_math_variant
)
)
{
nsAutoString
str
(
value
-
>
GetStringValue
(
)
)
;
str
.
CompressWhitespace
(
)
;
static
const
char
sizes
[
19
]
[
23
]
=
{
"
normal
"
"
bold
"
"
italic
"
"
bold
-
italic
"
"
script
"
"
bold
-
script
"
"
fraktur
"
"
double
-
struck
"
"
bold
-
fraktur
"
"
sans
-
serif
"
"
bold
-
sans
-
serif
"
"
sans
-
serif
-
italic
"
"
sans
-
serif
-
bold
-
italic
"
"
monospace
"
"
initial
"
"
tailed
"
"
looped
"
"
stretched
"
}
;
static
const
int32_t
values
[
MOZ_ARRAY_LENGTH
(
sizes
)
]
=
{
NS_MATHML_MATHVARIANT_NORMAL
NS_MATHML_MATHVARIANT_BOLD
NS_MATHML_MATHVARIANT_ITALIC
NS_MATHML_MATHVARIANT_BOLD_ITALIC
NS_MATHML_MATHVARIANT_SCRIPT
NS_MATHML_MATHVARIANT_BOLD_SCRIPT
NS_MATHML_MATHVARIANT_FRAKTUR
NS_MATHML_MATHVARIANT_DOUBLE_STRUCK
NS_MATHML_MATHVARIANT_BOLD_FRAKTUR
NS_MATHML_MATHVARIANT_SANS_SERIF
NS_MATHML_MATHVARIANT_BOLD_SANS_SERIF
NS_MATHML_MATHVARIANT_SANS_SERIF_ITALIC
NS_MATHML_MATHVARIANT_SANS_SERIF_BOLD_ITALIC
NS_MATHML_MATHVARIANT_MONOSPACE
NS_MATHML_MATHVARIANT_INITIAL
NS_MATHML_MATHVARIANT_TAILED
NS_MATHML_MATHVARIANT_LOOPED
NS_MATHML_MATHVARIANT_STRETCHED
}
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
sizes
)
;
+
+
i
)
{
if
(
str
.
EqualsASCII
(
sizes
[
i
]
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty__moz_math_variant
values
[
i
]
)
;
break
;
}
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
mathbackground_
)
;
if
(
!
value
)
{
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
background
)
;
if
(
value
)
{
WarnDeprecated
(
nsGkAtoms
:
:
background
-
>
GetUTF16String
(
)
nsGkAtoms
:
:
mathbackground_
-
>
GetUTF16String
(
)
aDecls
.
Document
(
)
)
;
}
}
if
(
value
)
{
nscolor
color
;
if
(
value
-
>
GetColorValue
(
color
)
)
{
aDecls
.
SetColorValueIfUnset
(
eCSSProperty_background_color
color
)
;
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
mathcolor_
)
;
if
(
!
value
)
{
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
color
)
;
if
(
value
)
{
WarnDeprecated
(
nsGkAtoms
:
:
color
-
>
GetUTF16String
(
)
nsGkAtoms
:
:
mathcolor_
-
>
GetUTF16String
(
)
aDecls
.
Document
(
)
)
;
}
}
nscolor
color
;
if
(
value
&
&
value
-
>
GetColorValue
(
color
)
)
{
aDecls
.
SetColorValueIfUnset
(
eCSSProperty_color
color
)
;
}
if
(
!
aDecls
.
PropertyIsSet
(
eCSSProperty_width
)
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
width
)
;
nsCSSValue
width
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
)
{
ParseNumericValue
(
value
-
>
GetStringValue
(
)
width
0
aDecls
.
Document
(
)
)
;
if
(
width
.
GetUnit
(
)
=
=
eCSSUnit_Percent
)
{
aDecls
.
SetPercentValue
(
eCSSProperty_width
width
.
GetPercentValue
(
)
)
;
}
else
if
(
width
.
GetUnit
(
)
!
=
eCSSUnit_Null
)
{
aDecls
.
SetLengthValue
(
eCSSProperty_width
width
)
;
}
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
dir
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty_direction
)
)
{
nsAutoString
str
(
value
-
>
GetStringValue
(
)
)
;
static
const
char
dirs
[
]
[
4
]
=
{
"
ltr
"
"
rtl
"
}
;
static
const
int32_t
dirValues
[
MOZ_ARRAY_LENGTH
(
dirs
)
]
=
{
NS_STYLE_DIRECTION_LTR
NS_STYLE_DIRECTION_RTL
}
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
dirs
)
;
+
+
i
)
{
if
(
str
.
EqualsASCII
(
dirs
[
i
]
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_direction
dirValues
[
i
]
)
;
break
;
}
}
}
}
void
nsMathMLElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
Element
:
:
GetEventTargetParent
(
aVisitor
)
;
GetEventTargetParentForLinks
(
aVisitor
)
;
}
nsresult
nsMathMLElement
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
return
PostHandleEventForLinks
(
aVisitor
)
;
}
NS_IMPL_ELEMENT_CLONE
(
nsMathMLElement
)
EventStates
nsMathMLElement
:
:
IntrinsicState
(
)
const
{
return
Link
:
:
LinkState
(
)
|
nsMathMLElementBase
:
:
IntrinsicState
(
)
|
(
mIncrementScriptLevel
?
NS_EVENT_STATE_INCREMENT_SCRIPT_LEVEL
:
EventStates
(
)
)
;
}
bool
nsMathMLElement
:
:
IsNodeOfType
(
uint32_t
aFlags
)
const
{
return
false
;
}
void
nsMathMLElement
:
:
SetIncrementScriptLevel
(
bool
aIncrementScriptLevel
bool
aNotify
)
{
if
(
aIncrementScriptLevel
=
=
mIncrementScriptLevel
)
return
;
mIncrementScriptLevel
=
aIncrementScriptLevel
;
NS_ASSERTION
(
aNotify
"
We
always
notify
!
"
)
;
UpdateState
(
true
)
;
}
bool
nsMathMLElement
:
:
IsFocusableInternal
(
int32_t
*
aTabIndex
bool
aWithMouse
)
{
nsCOMPtr
<
nsIURI
>
uri
;
if
(
IsLink
(
getter_AddRefs
(
uri
)
)
)
{
if
(
aTabIndex
)
{
*
aTabIndex
=
(
(
sTabFocusModel
&
eTabFocus_linksMask
)
=
=
0
?
-
1
:
0
)
;
}
return
true
;
}
if
(
aTabIndex
)
{
*
aTabIndex
=
-
1
;
}
return
false
;
}
bool
nsMathMLElement
:
:
IsLink
(
nsIURI
*
*
aURI
)
const
{
if
(
IsAnyOfMathMLElements
(
nsGkAtoms
:
:
mprescripts_
nsGkAtoms
:
:
none
nsGkAtoms
:
:
malignmark_
nsGkAtoms
:
:
maligngroup_
)
)
{
*
aURI
=
nullptr
;
return
false
;
}
bool
hasHref
=
false
;
const
nsAttrValue
*
href
=
mAttrsAndChildren
.
GetAttr
(
nsGkAtoms
:
:
href
kNameSpaceID_None
)
;
if
(
href
)
{
hasHref
=
true
;
}
else
{
static
Element
:
:
AttrValuesArray
sTypeVals
[
]
=
{
&
nsGkAtoms
:
:
_empty
&
nsGkAtoms
:
:
simple
nullptr
}
;
static
Element
:
:
AttrValuesArray
sShowVals
[
]
=
{
&
nsGkAtoms
:
:
_empty
&
nsGkAtoms
:
:
_new
&
nsGkAtoms
:
:
replace
nullptr
}
;
static
Element
:
:
AttrValuesArray
sActuateVals
[
]
=
{
&
nsGkAtoms
:
:
_empty
&
nsGkAtoms
:
:
onRequest
nullptr
}
;
href
=
mAttrsAndChildren
.
GetAttr
(
nsGkAtoms
:
:
href
kNameSpaceID_XLink
)
;
if
(
href
&
&
FindAttrValueIn
(
kNameSpaceID_XLink
nsGkAtoms
:
:
type
sTypeVals
eCaseMatters
)
!
=
Element
:
:
ATTR_VALUE_NO_MATCH
&
&
FindAttrValueIn
(
kNameSpaceID_XLink
nsGkAtoms
:
:
show
sShowVals
eCaseMatters
)
!
=
Element
:
:
ATTR_VALUE_NO_MATCH
&
&
FindAttrValueIn
(
kNameSpaceID_XLink
nsGkAtoms
:
:
actuate
sActuateVals
eCaseMatters
)
!
=
Element
:
:
ATTR_VALUE_NO_MATCH
)
{
hasHref
=
true
;
}
}
if
(
hasHref
)
{
nsCOMPtr
<
nsIURI
>
baseURI
=
GetBaseURI
(
)
;
nsAutoString
hrefStr
;
href
-
>
ToString
(
hrefStr
)
;
nsContentUtils
:
:
NewURIWithDocumentCharset
(
aURI
hrefStr
OwnerDoc
(
)
baseURI
)
;
return
!
!
*
aURI
;
}
*
aURI
=
nullptr
;
return
false
;
}
void
nsMathMLElement
:
:
GetLinkTarget
(
nsAString
&
aTarget
)
{
const
nsAttrValue
*
target
=
mAttrsAndChildren
.
GetAttr
(
nsGkAtoms
:
:
target
kNameSpaceID_XLink
)
;
if
(
target
)
{
target
-
>
ToString
(
aTarget
)
;
}
if
(
aTarget
.
IsEmpty
(
)
)
{
static
Element
:
:
AttrValuesArray
sShowVals
[
]
=
{
&
nsGkAtoms
:
:
_new
&
nsGkAtoms
:
:
replace
nullptr
}
;
switch
(
FindAttrValueIn
(
kNameSpaceID_XLink
nsGkAtoms
:
:
show
sShowVals
eCaseMatters
)
)
{
case
0
:
aTarget
.
AssignLiteral
(
"
_blank
"
)
;
return
;
case
1
:
return
;
}
OwnerDoc
(
)
-
>
GetBaseTarget
(
aTarget
)
;
}
}
already_AddRefed
<
nsIURI
>
nsMathMLElement
:
:
GetHrefURI
(
)
const
{
nsCOMPtr
<
nsIURI
>
hrefURI
;
return
IsLink
(
getter_AddRefs
(
hrefURI
)
)
?
hrefURI
.
forget
(
)
:
nullptr
;
}
nsresult
nsMathMLElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
if
(
aName
=
=
nsGkAtoms
:
:
href
&
&
(
aNameSpaceID
=
=
kNameSpaceID_None
|
|
aNameSpaceID
=
=
kNameSpaceID_XLink
)
)
{
if
(
aValue
&
&
aNameSpaceID
=
=
kNameSpaceID_XLink
)
{
WarnDeprecated
(
u
"
xlink
:
href
"
u
"
href
"
OwnerDoc
(
)
)
;
}
Link
:
:
ResetLinkState
(
aNotify
aValue
|
|
Link
:
:
ElementHasHref
(
)
)
;
}
return
nsMathMLElementBase
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aSubjectPrincipal
aNotify
)
;
}
JSObject
*
nsMathMLElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
Element_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
