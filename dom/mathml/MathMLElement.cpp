#
include
"
mozilla
/
dom
/
MathMLElement
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
mozilla
/
dom
/
BindContext
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
StaticPrefs_mathml
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsITableCellLayout
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
MappedDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
MathMLElementBinding
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
NS_IMPL_ISUPPORTS_INHERITED
(
MathMLElement
MathMLElementBase
Link
)
static
nsresult
ReportLengthParseError
(
const
nsString
&
aValue
Document
*
aDocument
)
{
AutoTArray
<
nsString
1
>
arg
=
{
aValue
}
;
return
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
"
MathML
"
_ns
aDocument
nsContentUtils
:
:
eMATHML_PROPERTIES
"
LengthParsingError
"
arg
)
;
}
static
nsresult
ReportParseErrorNoTag
(
const
nsString
&
aValue
nsAtom
*
aAtom
Document
*
aDocument
)
{
AutoTArray
<
nsString
2
>
argv
=
{
aValue
nsDependentAtomString
(
aAtom
)
}
;
return
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
"
MathML
"
_ns
aDocument
nsContentUtils
:
:
eMATHML_PROPERTIES
"
AttributeParsingErrorNoTag
"
argv
)
;
}
MathMLElement
:
:
MathMLElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
:
MathMLElementBase
(
std
:
:
move
(
aNodeInfo
)
)
ALLOW_THIS_IN_INITIALIZER_LIST
(
Link
(
this
)
)
mIncrementScriptLevel
(
false
)
{
}
MathMLElement
:
:
MathMLElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
MathMLElementBase
(
std
:
:
move
(
aNodeInfo
)
)
ALLOW_THIS_IN_INITIALIZER_LIST
(
Link
(
this
)
)
mIncrementScriptLevel
(
false
)
{
}
nsresult
MathMLElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
Link
:
:
ResetLinkState
(
false
Link
:
:
ElementHasHref
(
)
)
;
nsresult
rv
=
MathMLElementBase
:
:
BindToTree
(
aContext
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
Document
*
doc
=
aContext
.
GetUncomposedDoc
(
)
)
{
doc
-
>
RegisterPendingLinkUpdate
(
this
)
;
}
if
(
Document
*
doc
=
aContext
.
GetComposedDoc
(
)
)
{
doc
-
>
SetMathMLEnabled
(
)
;
}
return
rv
;
}
void
MathMLElement
:
:
UnbindFromTree
(
bool
aNullParent
)
{
Link
:
:
ResetLinkState
(
false
Link
:
:
ElementHasHref
(
)
)
;
MathMLElementBase
:
:
UnbindFromTree
(
aNullParent
)
;
}
bool
MathMLElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
MOZ_ASSERT
(
IsMathMLElement
(
)
)
;
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
color
|
|
aAttribute
=
=
nsGkAtoms
:
:
mathcolor_
|
|
aAttribute
=
=
nsGkAtoms
:
:
background
|
|
aAttribute
=
=
nsGkAtoms
:
:
mathbackground_
)
{
return
aResult
.
ParseColor
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
tabindex
)
{
return
aResult
.
ParseIntValue
(
aValue
)
;
}
if
(
mNodeInfo
-
>
Equals
(
nsGkAtoms
:
:
mtd_
)
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
columnspan_
)
{
aResult
.
ParseClampedNonNegativeInt
(
aValue
1
1
MAX_COLSPAN
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
rowspan
)
{
aResult
.
ParseClampedNonNegativeInt
(
aValue
1
0
MAX_ROWSPAN
)
;
return
true
;
}
}
}
return
MathMLElementBase
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
static
Element
:
:
MappedAttributeEntry
sGlobalAttributes
[
]
=
{
{
nsGkAtoms
:
:
dir
}
{
nsGkAtoms
:
:
mathbackground_
}
{
nsGkAtoms
:
:
mathcolor_
}
{
nsGkAtoms
:
:
mathsize_
}
{
nsGkAtoms
:
:
mathvariant_
}
{
nsGkAtoms
:
:
scriptlevel_
}
{
nsGkAtoms
:
:
displaystyle_
}
{
nullptr
}
}
;
static
Element
:
:
MappedAttributeEntry
sDeprecatedStyleAttributes
[
]
=
{
{
nsGkAtoms
:
:
background
}
{
nsGkAtoms
:
:
color
}
{
nsGkAtoms
:
:
fontfamily_
}
{
nsGkAtoms
:
:
fontsize_
}
{
nsGkAtoms
:
:
fontstyle_
}
{
nsGkAtoms
:
:
fontweight_
}
{
nullptr
}
}
;
bool
MathMLElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
MOZ_ASSERT
(
IsMathMLElement
(
)
)
;
static
const
MappedAttributeEntry
*
const
globalMap
[
]
=
{
sGlobalAttributes
}
;
static
const
MappedAttributeEntry
*
const
styleMap
[
]
=
{
sDeprecatedStyleAttributes
}
;
return
FindAttributeDependence
(
aAttribute
globalMap
)
|
|
(
!
StaticPrefs
:
:
mathml_deprecated_style_attributes_disabled
(
)
&
&
FindAttributeDependence
(
aAttribute
styleMap
)
)
|
|
(
!
StaticPrefs
:
:
mathml_scriptminsize_attribute_disabled
(
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
scriptminsize_
)
|
|
(
!
StaticPrefs
:
:
mathml_scriptsizemultiplier_attribute_disabled
(
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
scriptsizemultiplier_
)
|
|
(
mNodeInfo
-
>
Equals
(
nsGkAtoms
:
:
mtable_
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
width
)
;
}
nsMapRuleToAttributesFunc
MathMLElement
:
:
GetAttributeMappingFunction
(
)
const
{
return
&
MapMathMLAttributesInto
;
}
bool
MathMLElement
:
:
ParseNamedSpaceValue
(
const
nsString
&
aString
nsCSSValue
&
aCSSValue
uint32_t
aFlags
const
Document
&
aDocument
)
{
if
(
StaticPrefs
:
:
mathml_mathspace_names_disabled
(
)
)
{
return
false
;
}
int32_t
i
=
0
;
if
(
aString
.
EqualsLiteral
(
"
veryverythinmathspace
"
)
)
{
i
=
1
;
}
else
if
(
aString
.
EqualsLiteral
(
"
verythinmathspace
"
)
)
{
i
=
2
;
}
else
if
(
aString
.
EqualsLiteral
(
"
thinmathspace
"
)
)
{
i
=
3
;
}
else
if
(
aString
.
EqualsLiteral
(
"
mediummathspace
"
)
)
{
i
=
4
;
}
else
if
(
aString
.
EqualsLiteral
(
"
thickmathspace
"
)
)
{
i
=
5
;
}
else
if
(
aString
.
EqualsLiteral
(
"
verythickmathspace
"
)
)
{
i
=
6
;
}
else
if
(
aString
.
EqualsLiteral
(
"
veryverythickmathspace
"
)
)
{
i
=
7
;
}
else
if
(
aFlags
&
PARSE_ALLOW_NEGATIVE
)
{
if
(
aString
.
EqualsLiteral
(
"
negativeveryverythinmathspace
"
)
)
{
i
=
-
1
;
}
else
if
(
aString
.
EqualsLiteral
(
"
negativeverythinmathspace
"
)
)
{
i
=
-
2
;
}
else
if
(
aString
.
EqualsLiteral
(
"
negativethinmathspace
"
)
)
{
i
=
-
3
;
}
else
if
(
aString
.
EqualsLiteral
(
"
negativemediummathspace
"
)
)
{
i
=
-
4
;
}
else
if
(
aString
.
EqualsLiteral
(
"
negativethickmathspace
"
)
)
{
i
=
-
5
;
}
else
if
(
aString
.
EqualsLiteral
(
"
negativeverythickmathspace
"
)
)
{
i
=
-
6
;
}
else
if
(
aString
.
EqualsLiteral
(
"
negativeveryverythickmathspace
"
)
)
{
i
=
-
7
;
}
}
if
(
0
!
=
i
)
{
aDocument
.
WarnOnceAbout
(
dom
:
:
Document
:
:
eMathML_DeprecatedMathSpaceValue
)
;
aCSSValue
.
SetFloatValue
(
float
(
i
)
/
float
(
18
)
eCSSUnit_EM
)
;
return
true
;
}
return
false
;
}
bool
MathMLElement
:
:
ParseNumericValue
(
const
nsString
&
aString
nsCSSValue
&
aCSSValue
uint32_t
aFlags
Document
*
aDocument
)
{
nsAutoString
str
(
aString
)
;
str
.
CompressWhitespace
(
)
;
int32_t
stringLength
=
str
.
Length
(
)
;
if
(
!
stringLength
)
{
if
(
!
(
aFlags
&
PARSE_SUPPRESS_WARNINGS
)
)
{
ReportLengthParseError
(
aString
aDocument
)
;
}
return
false
;
}
if
(
aDocument
&
&
ParseNamedSpaceValue
(
str
aCSSValue
aFlags
*
aDocument
)
)
{
return
true
;
}
nsAutoString
number
unit
;
int32_t
i
=
0
;
char16_t
c
=
str
[
0
]
;
if
(
c
=
=
'
-
'
)
{
number
.
Append
(
c
)
;
i
+
+
;
}
bool
gotDot
=
false
;
for
(
;
i
<
stringLength
;
i
+
+
)
{
c
=
str
[
i
]
;
if
(
gotDot
&
&
c
=
=
'
.
'
)
{
if
(
!
(
aFlags
&
PARSE_SUPPRESS_WARNINGS
)
)
{
ReportLengthParseError
(
aString
aDocument
)
;
}
return
false
;
}
else
if
(
c
=
=
'
.
'
)
gotDot
=
true
;
else
if
(
!
IsAsciiDigit
(
c
)
)
{
str
.
Right
(
unit
stringLength
-
i
)
;
break
;
}
number
.
Append
(
c
)
;
}
if
(
gotDot
&
&
str
[
i
-
1
]
=
=
'
.
'
)
{
if
(
!
(
aFlags
&
PARSE_SUPPRESS_WARNINGS
)
)
{
ReportLengthParseError
(
aString
aDocument
)
;
}
return
false
;
}
nsresult
errorCode
;
float
floatValue
=
number
.
ToFloat
(
&
errorCode
)
;
if
(
NS_FAILED
(
errorCode
)
)
{
if
(
!
(
aFlags
&
PARSE_SUPPRESS_WARNINGS
)
)
{
ReportLengthParseError
(
aString
aDocument
)
;
}
return
false
;
}
if
(
floatValue
<
0
&
&
!
(
aFlags
&
PARSE_ALLOW_NEGATIVE
)
)
{
if
(
!
(
aFlags
&
PARSE_SUPPRESS_WARNINGS
)
)
{
ReportLengthParseError
(
aString
aDocument
)
;
}
return
false
;
}
nsCSSUnit
cssUnit
;
if
(
unit
.
IsEmpty
(
)
)
{
if
(
floatValue
!
=
0
.
0
)
{
if
(
!
(
aFlags
&
PARSE_SUPPRESS_WARNINGS
)
)
{
ReportLengthParseError
(
aString
aDocument
)
;
}
return
false
;
}
cssUnit
=
eCSSUnit_Pixel
;
}
else
if
(
unit
.
EqualsLiteral
(
"
%
"
)
)
{
aCSSValue
.
SetPercentValue
(
floatValue
/
100
.
0f
)
;
return
true
;
}
else
if
(
unit
.
LowerCaseEqualsLiteral
(
"
em
"
)
)
cssUnit
=
eCSSUnit_EM
;
else
if
(
unit
.
LowerCaseEqualsLiteral
(
"
ex
"
)
)
cssUnit
=
eCSSUnit_XHeight
;
else
if
(
unit
.
LowerCaseEqualsLiteral
(
"
px
"
)
)
cssUnit
=
eCSSUnit_Pixel
;
else
if
(
unit
.
LowerCaseEqualsLiteral
(
"
in
"
)
)
cssUnit
=
eCSSUnit_Inch
;
else
if
(
unit
.
LowerCaseEqualsLiteral
(
"
cm
"
)
)
cssUnit
=
eCSSUnit_Centimeter
;
else
if
(
unit
.
LowerCaseEqualsLiteral
(
"
mm
"
)
)
cssUnit
=
eCSSUnit_Millimeter
;
else
if
(
unit
.
LowerCaseEqualsLiteral
(
"
pt
"
)
)
cssUnit
=
eCSSUnit_Point
;
else
if
(
unit
.
LowerCaseEqualsLiteral
(
"
pc
"
)
)
cssUnit
=
eCSSUnit_Pica
;
else
if
(
unit
.
LowerCaseEqualsLiteral
(
"
q
"
)
)
cssUnit
=
eCSSUnit_Quarter
;
else
{
if
(
!
(
aFlags
&
PARSE_SUPPRESS_WARNINGS
)
)
{
ReportLengthParseError
(
aString
aDocument
)
;
}
return
false
;
}
aCSSValue
.
SetFloatValue
(
floatValue
cssUnit
)
;
return
true
;
}
void
MathMLElement
:
:
MapMathMLAttributesInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
scriptsizemultiplier_
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty__moz_script_size_multiplier
)
)
{
aDecls
.
Document
(
)
-
>
WarnOnceAbout
(
dom
:
:
Document
:
:
eMathML_DeprecatedScriptsizemultiplierAttribute
)
;
auto
str
=
value
-
>
GetStringValue
(
)
;
str
.
CompressWhitespace
(
)
;
if
(
str
.
Length
(
)
>
0
&
&
str
.
CharAt
(
0
)
!
=
'
+
'
)
{
nsresult
errorCode
;
float
floatValue
=
str
.
ToFloat
(
&
errorCode
)
;
if
(
NS_SUCCEEDED
(
errorCode
)
&
&
floatValue
>
=
0
.
0f
)
{
aDecls
.
SetNumberValue
(
eCSSProperty__moz_script_size_multiplier
floatValue
)
;
}
else
{
ReportParseErrorNoTag
(
str
nsGkAtoms
:
:
scriptsizemultiplier_
aDecls
.
Document
(
)
)
;
}
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
scriptminsize_
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty__moz_script_min_size
)
)
{
aDecls
.
Document
(
)
-
>
WarnOnceAbout
(
dom
:
:
Document
:
:
eMathML_DeprecatedScriptminsizeAttribute
)
;
nsCSSValue
scriptMinSize
;
ParseNumericValue
(
value
-
>
GetStringValue
(
)
scriptMinSize
PARSE_ALLOW_UNITLESS
|
CONVERT_UNITLESS_TO_PERCENT
aDecls
.
Document
(
)
)
;
if
(
scriptMinSize
.
GetUnit
(
)
=
=
eCSSUnit_Percent
)
{
scriptMinSize
.
SetFloatValue
(
8
.
0
*
scriptMinSize
.
GetPercentValue
(
)
eCSSUnit_Point
)
;
}
if
(
scriptMinSize
.
GetUnit
(
)
!
=
eCSSUnit_Null
)
{
aDecls
.
SetLengthValue
(
eCSSProperty__moz_script_min_size
scriptMinSize
)
;
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
scriptlevel_
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty_math_depth
)
)
{
auto
str
=
value
-
>
GetStringValue
(
)
;
str
.
CompressWhitespace
(
)
;
if
(
str
.
Length
(
)
>
0
)
{
nsresult
errorCode
;
int32_t
intValue
=
str
.
ToInteger
(
&
errorCode
)
;
if
(
NS_SUCCEEDED
(
errorCode
)
)
{
char16_t
ch
=
str
.
CharAt
(
0
)
;
bool
isRelativeScriptLevel
=
(
ch
=
=
'
+
'
|
|
ch
=
=
'
-
'
)
;
aDecls
.
SetMathDepthValue
(
intValue
isRelativeScriptLevel
)
;
}
else
{
ReportParseErrorNoTag
(
str
nsGkAtoms
:
:
scriptlevel_
aDecls
.
Document
(
)
)
;
}
}
}
bool
parseSizeKeywords
=
!
StaticPrefs
:
:
mathml_mathsize_names_disabled
(
)
;
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
mathsize_
)
;
if
(
!
value
)
{
parseSizeKeywords
=
false
;
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
fontsize_
)
;
if
(
value
)
{
aDecls
.
Document
(
)
-
>
WarnOnceAbout
(
dom
:
:
Document
:
:
eMathML_DeprecatedStyleAttribute
)
;
}
}
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty_font_size
)
)
{
auto
str
=
value
-
>
GetStringValue
(
)
;
nsCSSValue
fontSize
;
uint32_t
flags
=
PARSE_ALLOW_UNITLESS
|
CONVERT_UNITLESS_TO_PERCENT
;
if
(
parseSizeKeywords
)
{
flags
|
=
PARSE_SUPPRESS_WARNINGS
;
}
if
(
!
ParseNumericValue
(
str
fontSize
flags
nullptr
)
&
&
parseSizeKeywords
)
{
static
const
char
sizes
[
3
]
[
7
]
=
{
"
small
"
"
normal
"
"
big
"
}
;
static
const
StyleFontSizeKeyword
values
[
MOZ_ARRAY_LENGTH
(
sizes
)
]
=
{
StyleFontSizeKeyword
:
:
Small
StyleFontSizeKeyword
:
:
Medium
StyleFontSizeKeyword
:
:
Large
}
;
str
.
CompressWhitespace
(
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
sizes
)
;
+
+
i
)
{
if
(
str
.
EqualsASCII
(
sizes
[
i
]
)
)
{
aDecls
.
Document
(
)
-
>
WarnOnceAbout
(
dom
:
:
Document
:
:
eMathML_DeprecatedMathSizeValue
)
;
aDecls
.
SetKeywordValue
(
eCSSProperty_font_size
values
[
i
]
)
;
break
;
}
}
}
else
if
(
fontSize
.
GetUnit
(
)
=
=
eCSSUnit_Percent
)
{
aDecls
.
SetPercentValue
(
eCSSProperty_font_size
fontSize
.
GetPercentValue
(
)
)
;
}
else
if
(
fontSize
.
GetUnit
(
)
!
=
eCSSUnit_Null
)
{
aDecls
.
SetLengthValue
(
eCSSProperty_font_size
fontSize
)
;
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
fontfamily_
)
;
if
(
value
)
{
aDecls
.
Document
(
)
-
>
WarnOnceAbout
(
dom
:
:
Document
:
:
eMathML_DeprecatedStyleAttribute
)
;
}
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty_font_family
)
)
{
aDecls
.
SetFontFamily
(
value
-
>
GetStringValue
(
)
)
;
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
fontstyle_
)
;
if
(
value
)
{
aDecls
.
Document
(
)
-
>
WarnOnceAbout
(
dom
:
:
Document
:
:
eMathML_DeprecatedStyleAttribute
)
;
if
(
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty_font_style
)
)
{
auto
str
=
value
-
>
GetStringValue
(
)
;
str
.
CompressWhitespace
(
)
;
if
(
str
.
EqualsASCII
(
"
normal
"
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_font_style
NS_FONT_STYLE_NORMAL
)
;
}
else
if
(
str
.
EqualsASCII
(
"
italic
"
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_font_style
NS_FONT_STYLE_ITALIC
)
;
}
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
fontweight_
)
;
if
(
value
)
{
aDecls
.
Document
(
)
-
>
WarnOnceAbout
(
dom
:
:
Document
:
:
eMathML_DeprecatedStyleAttribute
)
;
if
(
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty_font_weight
)
)
{
auto
str
=
value
-
>
GetStringValue
(
)
;
str
.
CompressWhitespace
(
)
;
if
(
str
.
EqualsASCII
(
"
normal
"
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_font_weight
FontWeight
:
:
Normal
(
)
.
ToFloat
(
)
)
;
}
else
if
(
str
.
EqualsASCII
(
"
bold
"
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_font_weight
FontWeight
:
:
Bold
(
)
.
ToFloat
(
)
)
;
}
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
mathvariant_
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty__moz_math_variant
)
)
{
auto
str
=
value
-
>
GetStringValue
(
)
;
str
.
CompressWhitespace
(
)
;
static
const
char
sizes
[
19
]
[
23
]
=
{
"
normal
"
"
bold
"
"
italic
"
"
bold
-
italic
"
"
script
"
"
bold
-
script
"
"
fraktur
"
"
double
-
struck
"
"
bold
-
fraktur
"
"
sans
-
serif
"
"
bold
-
sans
-
serif
"
"
sans
-
serif
-
italic
"
"
sans
-
serif
-
bold
-
italic
"
"
monospace
"
"
initial
"
"
tailed
"
"
looped
"
"
stretched
"
}
;
static
const
int32_t
values
[
MOZ_ARRAY_LENGTH
(
sizes
)
]
=
{
NS_MATHML_MATHVARIANT_NORMAL
NS_MATHML_MATHVARIANT_BOLD
NS_MATHML_MATHVARIANT_ITALIC
NS_MATHML_MATHVARIANT_BOLD_ITALIC
NS_MATHML_MATHVARIANT_SCRIPT
NS_MATHML_MATHVARIANT_BOLD_SCRIPT
NS_MATHML_MATHVARIANT_FRAKTUR
NS_MATHML_MATHVARIANT_DOUBLE_STRUCK
NS_MATHML_MATHVARIANT_BOLD_FRAKTUR
NS_MATHML_MATHVARIANT_SANS_SERIF
NS_MATHML_MATHVARIANT_BOLD_SANS_SERIF
NS_MATHML_MATHVARIANT_SANS_SERIF_ITALIC
NS_MATHML_MATHVARIANT_SANS_SERIF_BOLD_ITALIC
NS_MATHML_MATHVARIANT_MONOSPACE
NS_MATHML_MATHVARIANT_INITIAL
NS_MATHML_MATHVARIANT_TAILED
NS_MATHML_MATHVARIANT_LOOPED
NS_MATHML_MATHVARIANT_STRETCHED
}
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
sizes
)
;
+
+
i
)
{
if
(
str
.
LowerCaseEqualsASCII
(
sizes
[
i
]
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty__moz_math_variant
values
[
i
]
)
;
break
;
}
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
mathbackground_
)
;
if
(
!
value
)
{
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
background
)
;
if
(
value
)
{
aDecls
.
Document
(
)
-
>
WarnOnceAbout
(
dom
:
:
Document
:
:
eMathML_DeprecatedStyleAttribute
)
;
}
}
if
(
value
)
{
nscolor
color
;
if
(
value
-
>
GetColorValue
(
color
)
)
{
aDecls
.
SetColorValueIfUnset
(
eCSSProperty_background_color
color
)
;
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
mathcolor_
)
;
if
(
!
value
)
{
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
color
)
;
if
(
value
)
{
aDecls
.
Document
(
)
-
>
WarnOnceAbout
(
dom
:
:
Document
:
:
eMathML_DeprecatedStyleAttribute
)
;
}
}
nscolor
color
;
if
(
value
&
&
value
-
>
GetColorValue
(
color
)
)
{
aDecls
.
SetColorValueIfUnset
(
eCSSProperty_color
color
)
;
}
if
(
!
aDecls
.
PropertyIsSet
(
eCSSProperty_width
)
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
width
)
;
nsCSSValue
width
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
)
{
ParseNumericValue
(
value
-
>
GetStringValue
(
)
width
0
aDecls
.
Document
(
)
)
;
if
(
width
.
GetUnit
(
)
=
=
eCSSUnit_Percent
)
{
aDecls
.
SetPercentValue
(
eCSSProperty_width
width
.
GetPercentValue
(
)
)
;
}
else
if
(
width
.
GetUnit
(
)
!
=
eCSSUnit_Null
)
{
aDecls
.
SetLengthValue
(
eCSSProperty_width
width
)
;
}
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
dir
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty_direction
)
)
{
auto
str
=
value
-
>
GetStringValue
(
)
;
static
const
char
dirs
[
]
[
4
]
=
{
"
ltr
"
"
rtl
"
}
;
static
const
StyleDirection
dirValues
[
MOZ_ARRAY_LENGTH
(
dirs
)
]
=
{
StyleDirection
:
:
Ltr
StyleDirection
:
:
Rtl
}
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
dirs
)
;
+
+
i
)
{
if
(
str
.
LowerCaseEqualsASCII
(
dirs
[
i
]
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_direction
dirValues
[
i
]
)
;
break
;
}
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
displaystyle_
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty_math_style
)
)
{
auto
str
=
value
-
>
GetStringValue
(
)
;
static
const
char
displaystyles
[
]
[
6
]
=
{
"
false
"
"
true
"
}
;
static
const
uint8_t
mathStyle
[
MOZ_ARRAY_LENGTH
(
displaystyles
)
]
=
{
NS_STYLE_MATH_STYLE_COMPACT
NS_STYLE_MATH_STYLE_NORMAL
}
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
displaystyles
)
;
+
+
i
)
{
if
(
str
.
LowerCaseEqualsASCII
(
displaystyles
[
i
]
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_math_style
mathStyle
[
i
]
)
;
break
;
}
}
}
}
void
MathMLElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
Element
:
:
GetEventTargetParent
(
aVisitor
)
;
GetEventTargetParentForLinks
(
aVisitor
)
;
}
nsresult
MathMLElement
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
return
PostHandleEventForLinks
(
aVisitor
)
;
}
NS_IMPL_ELEMENT_CLONE
(
MathMLElement
)
EventStates
MathMLElement
:
:
IntrinsicState
(
)
const
{
return
Link
:
:
LinkState
(
)
|
MathMLElementBase
:
:
IntrinsicState
(
)
|
(
mIncrementScriptLevel
?
NS_EVENT_STATE_INCREMENT_SCRIPT_LEVEL
:
EventStates
(
)
)
;
}
bool
MathMLElement
:
:
IsNodeOfType
(
uint32_t
aFlags
)
const
{
return
false
;
}
void
MathMLElement
:
:
SetIncrementScriptLevel
(
bool
aIncrementScriptLevel
bool
aNotify
)
{
if
(
aIncrementScriptLevel
=
=
mIncrementScriptLevel
)
return
;
mIncrementScriptLevel
=
aIncrementScriptLevel
;
NS_ASSERTION
(
aNotify
"
We
always
notify
!
"
)
;
UpdateState
(
true
)
;
}
int32_t
MathMLElement
:
:
TabIndexDefault
(
)
{
nsCOMPtr
<
nsIURI
>
uri
;
return
IsLink
(
getter_AddRefs
(
uri
)
)
?
0
:
-
1
;
}
bool
MathMLElement
:
:
IsFocusableInternal
(
int32_t
*
aTabIndex
bool
aWithMouse
)
{
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
!
doc
|
|
doc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
if
(
aTabIndex
)
{
*
aTabIndex
=
-
1
;
}
return
false
;
}
int32_t
tabIndex
=
TabIndex
(
)
;
if
(
aTabIndex
)
{
*
aTabIndex
=
tabIndex
;
}
nsCOMPtr
<
nsIURI
>
uri
;
if
(
!
IsLink
(
getter_AddRefs
(
uri
)
)
)
{
return
GetTabIndexAttrValue
(
)
.
isSome
(
)
;
}
if
(
!
OwnerDoc
(
)
-
>
LinkHandlingEnabled
(
)
)
{
return
false
;
}
if
(
nsContentUtils
:
:
IsNodeInEditableRegion
(
this
)
)
{
if
(
aTabIndex
)
{
*
aTabIndex
=
-
1
;
}
return
false
;
}
if
(
aTabIndex
&
&
(
sTabFocusModel
&
eTabFocus_linksMask
)
=
=
0
)
{
*
aTabIndex
=
-
1
;
}
return
true
;
}
bool
MathMLElement
:
:
IsLink
(
nsIURI
*
*
aURI
)
const
{
bool
hasHref
=
false
;
const
nsAttrValue
*
href
=
mAttrs
.
GetAttr
(
nsGkAtoms
:
:
href
kNameSpaceID_None
)
;
if
(
href
)
{
hasHref
=
true
;
}
else
if
(
!
StaticPrefs
:
:
mathml_xlink_disabled
(
)
)
{
static
Element
:
:
AttrValuesArray
sTypeVals
[
]
=
{
nsGkAtoms
:
:
_empty
nsGkAtoms
:
:
simple
nullptr
}
;
static
Element
:
:
AttrValuesArray
sShowVals
[
]
=
{
nsGkAtoms
:
:
_empty
nsGkAtoms
:
:
_new
nsGkAtoms
:
:
replace
nullptr
}
;
static
Element
:
:
AttrValuesArray
sActuateVals
[
]
=
{
nsGkAtoms
:
:
_empty
nsGkAtoms
:
:
onRequest
nullptr
}
;
href
=
mAttrs
.
GetAttr
(
nsGkAtoms
:
:
href
kNameSpaceID_XLink
)
;
if
(
href
&
&
FindAttrValueIn
(
kNameSpaceID_XLink
nsGkAtoms
:
:
type
sTypeVals
eCaseMatters
)
!
=
Element
:
:
ATTR_VALUE_NO_MATCH
&
&
FindAttrValueIn
(
kNameSpaceID_XLink
nsGkAtoms
:
:
show
sShowVals
eCaseMatters
)
!
=
Element
:
:
ATTR_VALUE_NO_MATCH
&
&
FindAttrValueIn
(
kNameSpaceID_XLink
nsGkAtoms
:
:
actuate
sActuateVals
eCaseMatters
)
!
=
Element
:
:
ATTR_VALUE_NO_MATCH
)
{
OwnerDoc
(
)
-
>
WarnOnceAbout
(
dom
:
:
Document
:
:
eMathML_DeprecatedXLinkAttribute
)
;
hasHref
=
true
;
}
}
if
(
hasHref
)
{
nsAutoString
hrefStr
;
href
-
>
ToString
(
hrefStr
)
;
nsContentUtils
:
:
NewURIWithDocumentCharset
(
aURI
hrefStr
OwnerDoc
(
)
GetBaseURI
(
)
)
;
return
!
!
*
aURI
;
}
*
aURI
=
nullptr
;
return
false
;
}
void
MathMLElement
:
:
GetLinkTarget
(
nsAString
&
aTarget
)
{
if
(
StaticPrefs
:
:
mathml_xlink_disabled
(
)
)
{
MathMLElementBase
:
:
GetLinkTarget
(
aTarget
)
;
return
;
}
const
nsAttrValue
*
target
=
mAttrs
.
GetAttr
(
nsGkAtoms
:
:
target
kNameSpaceID_XLink
)
;
if
(
target
)
{
OwnerDoc
(
)
-
>
WarnOnceAbout
(
dom
:
:
Document
:
:
eMathML_DeprecatedXLinkAttribute
)
;
target
-
>
ToString
(
aTarget
)
;
}
if
(
aTarget
.
IsEmpty
(
)
)
{
static
Element
:
:
AttrValuesArray
sShowVals
[
]
=
{
nsGkAtoms
:
:
_new
nsGkAtoms
:
:
replace
nullptr
}
;
bool
hasDeprecatedShowAttribute
=
true
;
switch
(
FindAttrValueIn
(
kNameSpaceID_XLink
nsGkAtoms
:
:
show
sShowVals
eCaseMatters
)
)
{
case
ATTR_MISSING
:
hasDeprecatedShowAttribute
=
false
;
break
;
case
0
:
aTarget
.
AssignLiteral
(
"
_blank
"
)
;
return
;
case
1
:
return
;
}
if
(
hasDeprecatedShowAttribute
)
{
OwnerDoc
(
)
-
>
WarnOnceAbout
(
dom
:
:
Document
:
:
eMathML_DeprecatedXLinkAttribute
)
;
}
OwnerDoc
(
)
-
>
GetBaseTarget
(
aTarget
)
;
}
}
already_AddRefed
<
nsIURI
>
MathMLElement
:
:
GetHrefURI
(
)
const
{
nsCOMPtr
<
nsIURI
>
hrefURI
;
return
IsLink
(
getter_AddRefs
(
hrefURI
)
)
?
hrefURI
.
forget
(
)
:
nullptr
;
}
void
MathMLElement
:
:
RecompileScriptEventListeners
(
)
{
int32_t
i
count
=
mAttrs
.
AttrCount
(
)
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
const
nsAttrName
*
name
=
mAttrs
.
AttrNameAt
(
i
)
;
if
(
!
name
-
>
IsAtom
(
)
)
{
continue
;
}
nsAtom
*
attr
=
name
-
>
Atom
(
)
;
if
(
!
IsEventAttributeName
(
attr
)
)
{
continue
;
}
nsAutoString
value
;
GetAttr
(
kNameSpaceID_None
attr
value
)
;
SetEventHandler
(
GetEventNameForAttr
(
attr
)
value
true
)
;
}
}
bool
MathMLElement
:
:
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
{
return
nsContentUtils
:
:
IsEventAttributeName
(
aName
EventNameType_HTML
)
;
}
nsresult
MathMLElement
:
:
BeforeSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
!
aValue
&
&
IsEventAttributeName
(
aName
)
)
{
if
(
EventListenerManager
*
manager
=
GetExistingListenerManager
(
)
)
{
manager
-
>
RemoveEventHandler
(
GetEventNameForAttr
(
aName
)
)
;
}
}
}
return
MathMLElementBase
:
:
BeforeSetAttr
(
aNamespaceID
aName
aValue
aNotify
)
;
}
nsresult
MathMLElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
if
(
aName
=
=
nsGkAtoms
:
:
href
&
&
(
aNameSpaceID
=
=
kNameSpaceID_None
|
|
(
!
StaticPrefs
:
:
mathml_xlink_disabled
(
)
&
&
aNameSpaceID
=
=
kNameSpaceID_XLink
)
)
)
{
if
(
aValue
&
&
aNameSpaceID
=
=
kNameSpaceID_XLink
)
{
OwnerDoc
(
)
-
>
WarnOnceAbout
(
dom
:
:
Document
:
:
eMathML_DeprecatedXLinkAttribute
)
;
}
Link
:
:
ResetLinkState
(
aNotify
aValue
|
|
Link
:
:
ElementHasHref
(
)
)
;
}
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
IsEventAttributeName
(
aName
)
&
&
aValue
)
{
MOZ_ASSERT
(
aValue
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
"
Expected
string
value
for
script
body
"
)
;
SetEventHandler
(
GetEventNameForAttr
(
aName
)
aValue
-
>
GetStringValue
(
)
)
;
}
}
return
MathMLElementBase
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aSubjectPrincipal
aNotify
)
;
}
JSObject
*
MathMLElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MathMLElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
