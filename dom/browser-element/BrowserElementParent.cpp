#
include
"
TabParent
.
h
"
#
ifdef
CreateEvent
#
undef
CreateEvent
#
endif
#
include
"
BrowserElementParent
.
h
"
#
include
"
BrowserElementAudioChannel
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
dom
/
HTMLIFrameElement
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
mozilla
/
dom
/
BrowserElementDictionariesBinding
.
h
"
#
include
"
mozilla
/
dom
/
CustomEvent
.
h
"
#
include
"
mozilla
/
layout
/
RenderFrameParent
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
layout
;
namespace
{
using
mozilla
:
:
BrowserElementParent
;
already_AddRefed
<
HTMLIFrameElement
>
CreateIframe
(
Element
*
aOpenerFrameElement
const
nsAString
&
aName
bool
aRemote
)
{
nsNodeInfoManager
*
nodeInfoManager
=
aOpenerFrameElement
-
>
OwnerDoc
(
)
-
>
NodeInfoManager
(
)
;
RefPtr
<
NodeInfo
>
nodeInfo
=
nodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
iframe
nullptr
kNameSpaceID_XHTML
nsIDOMNode
:
:
ELEMENT_NODE
)
;
RefPtr
<
HTMLIFrameElement
>
popupFrameElement
=
static_cast
<
HTMLIFrameElement
*
>
(
NS_NewHTMLIFrameElement
(
nodeInfo
.
forget
(
)
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
)
)
;
popupFrameElement
-
>
SetMozbrowser
(
true
)
;
if
(
aOpenerFrameElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozapp
)
)
{
nsAutoString
mozapp
;
aOpenerFrameElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozapp
mozapp
)
;
popupFrameElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozapp
mozapp
false
)
;
}
if
(
aOpenerFrameElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
parentapp
)
)
{
nsAutoString
parentApp
;
aOpenerFrameElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
parentapp
parentApp
)
;
popupFrameElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
parentapp
parentApp
false
)
;
}
popupFrameElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
aName
false
)
;
popupFrameElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
Remote
aRemote
?
NS_LITERAL_STRING
(
"
true
"
)
:
NS_LITERAL_STRING
(
"
false
"
)
false
)
;
nsAutoString
mozprivatebrowsing
;
if
(
aOpenerFrameElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozprivatebrowsing
mozprivatebrowsing
)
)
{
popupFrameElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozprivatebrowsing
mozprivatebrowsing
false
)
;
}
return
popupFrameElement
.
forget
(
)
;
}
bool
DispatchCustomDOMEvent
(
Element
*
aFrameElement
const
nsAString
&
aEventName
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
aDetailValue
nsEventStatus
*
aStatus
)
{
NS_ENSURE_TRUE
(
aFrameElement
false
)
;
nsIPresShell
*
shell
=
aFrameElement
-
>
OwnerDoc
(
)
-
>
GetShell
(
)
;
RefPtr
<
nsPresContext
>
presContext
;
if
(
shell
)
{
presContext
=
shell
-
>
GetPresContext
(
)
;
}
RefPtr
<
CustomEvent
>
event
=
NS_NewDOMCustomEvent
(
aFrameElement
presContext
nullptr
)
;
ErrorResult
res
;
event
-
>
InitCustomEvent
(
cx
aEventName
true
true
aDetailValue
res
)
;
if
(
res
.
Failed
(
)
)
{
return
false
;
}
event
-
>
SetTrusted
(
true
)
;
nsresult
rv
=
EventDispatcher
:
:
DispatchDOMEvent
(
aFrameElement
nullptr
event
presContext
aStatus
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
}
namespace
mozilla
{
BrowserElementParent
:
:
OpenWindowResult
BrowserElementParent
:
:
DispatchOpenWindowEvent
(
Element
*
aOpenerFrameElement
Element
*
aPopupFrameElement
const
nsAString
&
aURL
const
nsAString
&
aName
const
nsAString
&
aFeatures
)
{
OpenWindowEventDetail
detail
;
if
(
aURL
.
IsEmpty
(
)
)
{
detail
.
mUrl
=
NS_LITERAL_STRING
(
"
about
:
blank
"
)
;
}
else
{
detail
.
mUrl
=
aURL
;
}
detail
.
mName
=
aName
;
detail
.
mFeatures
=
aFeatures
;
detail
.
mFrameElement
=
aPopupFrameElement
;
AutoJSContext
cx
;
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
cx
)
;
nsIGlobalObject
*
sgo
=
aPopupFrameElement
-
>
OwnerDoc
(
)
-
>
GetScopeObject
(
)
;
if
(
!
sgo
)
{
return
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
;
}
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
sgo
-
>
GetGlobalJSObject
(
)
)
;
JSAutoCompartment
ac
(
cx
global
)
;
if
(
!
ToJSValue
(
cx
detail
&
val
)
)
{
MOZ_CRASH
(
"
Failed
to
convert
dictionary
to
JS
:
:
Value
due
to
OOM
.
"
)
;
return
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
bool
dispatchSucceeded
=
DispatchCustomDOMEvent
(
aOpenerFrameElement
NS_LITERAL_STRING
(
"
mozbrowseropenwindow
"
)
cx
val
&
status
)
;
if
(
dispatchSucceeded
)
{
if
(
aPopupFrameElement
-
>
IsInUncomposedDoc
(
)
)
{
return
BrowserElementParent
:
:
OPEN_WINDOW_ADDED
;
}
else
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
BrowserElementParent
:
:
OPEN_WINDOW_CANCELLED
;
}
}
return
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
;
}
BrowserElementParent
:
:
OpenWindowResult
BrowserElementParent
:
:
OpenWindowOOP
(
TabParent
*
aOpenerTabParent
TabParent
*
aPopupTabParent
PRenderFrameParent
*
aRenderFrame
const
nsAString
&
aURL
const
nsAString
&
aName
const
nsAString
&
aFeatures
TextureFactoryIdentifier
*
aTextureFactoryIdentifier
uint64_t
*
aLayersId
)
{
nsCOMPtr
<
Element
>
openerFrameElement
=
aOpenerTabParent
-
>
GetOwnerElement
(
)
;
NS_ENSURE_TRUE
(
openerFrameElement
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
)
;
RefPtr
<
HTMLIFrameElement
>
popupFrameElement
=
CreateIframe
(
openerFrameElement
aName
true
)
;
popupFrameElement
-
>
DisallowCreateFrameLoader
(
)
;
OpenWindowResult
opened
=
DispatchOpenWindowEvent
(
openerFrameElement
popupFrameElement
aURL
aName
aFeatures
)
;
if
(
opened
!
=
BrowserElementParent
:
:
OPEN_WINDOW_ADDED
)
{
return
opened
;
}
aPopupTabParent
-
>
SetOwnerElement
(
popupFrameElement
)
;
popupFrameElement
-
>
AllowCreateFrameLoader
(
)
;
popupFrameElement
-
>
CreateRemoteFrameLoader
(
aPopupTabParent
)
;
RenderFrameParent
*
rfp
=
static_cast
<
RenderFrameParent
*
>
(
aRenderFrame
)
;
if
(
!
aPopupTabParent
-
>
SetRenderFrame
(
rfp
)
|
|
!
aPopupTabParent
-
>
GetRenderFrameInfo
(
aTextureFactoryIdentifier
aLayersId
)
)
{
return
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
;
}
return
opened
;
}
BrowserElementParent
:
:
OpenWindowResult
BrowserElementParent
:
:
OpenWindowInProcess
(
nsPIDOMWindowOuter
*
aOpenerWindow
nsIURI
*
aURI
const
nsAString
&
aName
const
nsACString
&
aFeatures
mozIDOMWindowProxy
*
*
aReturnWindow
)
{
*
aReturnWindow
=
nullptr
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
aOpenerWindow
-
>
GetScriptableTop
(
)
;
nsCOMPtr
<
Element
>
openerFrameElement
=
win
-
>
GetFrameElementInternal
(
)
;
NS_ENSURE_TRUE
(
openerFrameElement
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
)
;
RefPtr
<
HTMLIFrameElement
>
popupFrameElement
=
CreateIframe
(
openerFrameElement
aName
false
)
;
NS_ENSURE_TRUE
(
popupFrameElement
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
)
;
nsAutoCString
spec
;
if
(
aURI
)
{
aURI
-
>
GetSpec
(
spec
)
;
}
ErrorResult
res
;
popupFrameElement
-
>
PresetOpenerWindow
(
aOpenerWindow
res
)
;
MOZ_ASSERT
(
!
res
.
Failed
(
)
)
;
OpenWindowResult
opened
=
DispatchOpenWindowEvent
(
openerFrameElement
popupFrameElement
NS_ConvertUTF8toUTF16
(
spec
)
aName
NS_ConvertUTF8toUTF16
(
aFeatures
)
)
;
if
(
opened
!
=
BrowserElementParent
:
:
OPEN_WINDOW_ADDED
)
{
return
opened
;
}
RefPtr
<
nsFrameLoader
>
frameLoader
=
popupFrameElement
-
>
GetFrameLoader
(
)
;
NS_ENSURE_TRUE
(
frameLoader
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
)
;
nsCOMPtr
<
nsIDocShell
>
docshell
;
frameLoader
-
>
GetDocShell
(
getter_AddRefs
(
docshell
)
)
;
NS_ENSURE_TRUE
(
docshell
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
docshell
-
>
GetWindow
(
)
;
window
.
forget
(
aReturnWindow
)
;
return
!
!
*
aReturnWindow
?
opened
:
BrowserElementParent
:
:
OPEN_WINDOW_CANCELLED
;
}
}
