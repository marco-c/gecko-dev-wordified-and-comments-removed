#
include
"
BrowserParent
.
h
"
#
ifdef
CreateEvent
#
undef
CreateEvent
#
endif
#
include
"
BrowserElementParent
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
HTMLIFrameElement
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
mozilla
/
dom
/
WindowProxyHolder
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
mozilla
/
dom
/
BrowserElementDictionariesBinding
.
h
"
#
include
"
mozilla
/
dom
/
CustomEvent
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
layout
;
namespace
{
using
mozilla
:
:
BrowserElementParent
;
already_AddRefed
<
HTMLIFrameElement
>
CreateIframe
(
Element
*
aOpenerFrameElement
const
nsAString
&
aName
bool
aRemote
)
{
nsNodeInfoManager
*
nodeInfoManager
=
aOpenerFrameElement
-
>
OwnerDoc
(
)
-
>
NodeInfoManager
(
)
;
RefPtr
<
NodeInfo
>
nodeInfo
=
nodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
iframe
nullptr
kNameSpaceID_XHTML
nsINode
:
:
ELEMENT_NODE
)
;
RefPtr
<
HTMLIFrameElement
>
popupFrameElement
=
static_cast
<
HTMLIFrameElement
*
>
(
NS_NewHTMLIFrameElement
(
nodeInfo
.
forget
(
)
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
)
)
;
popupFrameElement
-
>
SetMozbrowser
(
true
)
;
popupFrameElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
aName
false
)
;
popupFrameElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
remote
aRemote
?
NS_LITERAL_STRING
(
"
true
"
)
:
NS_LITERAL_STRING
(
"
false
"
)
false
)
;
nsAutoString
mozprivatebrowsing
;
if
(
aOpenerFrameElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozprivatebrowsing
mozprivatebrowsing
)
)
{
popupFrameElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozprivatebrowsing
mozprivatebrowsing
false
)
;
}
return
popupFrameElement
.
forget
(
)
;
}
bool
DispatchCustomDOMEvent
(
Element
*
aFrameElement
const
nsAString
&
aEventName
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
aDetailValue
nsEventStatus
*
aStatus
)
{
NS_ENSURE_TRUE
(
aFrameElement
false
)
;
RefPtr
<
nsPresContext
>
presContext
=
aFrameElement
-
>
OwnerDoc
(
)
-
>
GetPresContext
(
)
;
RefPtr
<
CustomEvent
>
event
=
NS_NewDOMCustomEvent
(
aFrameElement
presContext
nullptr
)
;
event
-
>
InitCustomEvent
(
cx
aEventName
true
true
aDetailValue
)
;
event
-
>
SetTrusted
(
true
)
;
nsresult
rv
=
EventDispatcher
:
:
DispatchDOMEvent
(
aFrameElement
nullptr
event
presContext
aStatus
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
}
namespace
mozilla
{
BrowserElementParent
:
:
OpenWindowResult
BrowserElementParent
:
:
DispatchOpenWindowEvent
(
Element
*
aOpenerFrameElement
Element
*
aPopupFrameElement
const
nsAString
&
aURL
const
nsAString
&
aName
bool
aForceNoReferrer
const
nsAString
&
aFeatures
)
{
OpenWindowEventDetail
detail
;
if
(
aURL
.
IsEmpty
(
)
)
{
detail
.
mUrl
=
NS_LITERAL_STRING
(
"
about
:
blank
"
)
;
}
else
{
detail
.
mUrl
=
aURL
;
}
detail
.
mName
=
aName
;
detail
.
mFeatures
=
aFeatures
;
detail
.
mFrameElement
=
aPopupFrameElement
;
detail
.
mForceNoReferrer
=
aForceNoReferrer
;
nsIGlobalObject
*
sgo
=
aPopupFrameElement
-
>
OwnerDoc
(
)
-
>
GetScopeObject
(
)
;
if
(
!
sgo
)
{
return
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
;
}
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
sgo
)
)
{
return
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
cx
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
sgo
-
>
GetGlobalJSObject
(
)
)
;
JSAutoRealm
ar
(
cx
global
)
;
if
(
!
ToJSValue
(
cx
detail
&
val
)
)
{
MOZ_CRASH
(
"
Failed
to
convert
dictionary
to
JS
:
:
Value
due
to
OOM
.
"
)
;
return
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
bool
dispatchSucceeded
=
DispatchCustomDOMEvent
(
aOpenerFrameElement
NS_LITERAL_STRING
(
"
mozbrowseropenwindow
"
)
cx
val
&
status
)
;
if
(
dispatchSucceeded
)
{
if
(
aPopupFrameElement
-
>
IsInComposedDoc
(
)
)
{
return
BrowserElementParent
:
:
OPEN_WINDOW_ADDED
;
}
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
BrowserElementParent
:
:
OPEN_WINDOW_CANCELLED
;
}
}
return
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
;
}
BrowserElementParent
:
:
OpenWindowResult
BrowserElementParent
:
:
OpenWindowOOP
(
BrowserParent
*
aOpenerBrowserParent
BrowserParent
*
aPopupBrowserParent
const
nsAString
&
aURL
const
nsAString
&
aName
bool
aForceNoReferrer
const
nsAString
&
aFeatures
)
{
nsCOMPtr
<
Element
>
openerFrameElement
=
aOpenerBrowserParent
-
>
GetOwnerElement
(
)
;
NS_ENSURE_TRUE
(
openerFrameElement
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
)
;
RefPtr
<
HTMLIFrameElement
>
popupFrameElement
=
CreateIframe
(
openerFrameElement
aName
true
)
;
popupFrameElement
-
>
DisallowCreateFrameLoader
(
)
;
OpenWindowResult
opened
=
DispatchOpenWindowEvent
(
openerFrameElement
popupFrameElement
aURL
aName
aForceNoReferrer
aFeatures
)
;
if
(
opened
!
=
BrowserElementParent
:
:
OPEN_WINDOW_ADDED
)
{
return
opened
;
}
aPopupBrowserParent
-
>
SetOwnerElement
(
popupFrameElement
)
;
popupFrameElement
-
>
AllowCreateFrameLoader
(
)
;
popupFrameElement
-
>
CreateRemoteFrameLoader
(
aPopupBrowserParent
)
;
return
opened
;
}
BrowserElementParent
:
:
OpenWindowResult
BrowserElementParent
:
:
OpenWindowInProcess
(
BrowsingContext
*
aOpenerWindow
nsIURI
*
aURI
const
nsAString
&
aName
const
nsACString
&
aFeatures
bool
aForceNoOpener
mozIDOMWindowProxy
*
*
aReturnWindow
)
{
*
aReturnWindow
=
nullptr
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
aOpenerWindow
-
>
GetDOMWindow
(
)
-
>
GetInProcessScriptableTop
(
)
;
nsCOMPtr
<
Element
>
openerFrameElement
=
win
-
>
GetFrameElementInternal
(
)
;
NS_ENSURE_TRUE
(
openerFrameElement
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
)
;
RefPtr
<
HTMLIFrameElement
>
popupFrameElement
=
CreateIframe
(
openerFrameElement
aName
false
)
;
NS_ENSURE_TRUE
(
popupFrameElement
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
)
;
nsAutoCString
spec
;
if
(
aURI
)
{
aURI
-
>
GetSpec
(
spec
)
;
}
if
(
!
aForceNoOpener
)
{
ErrorResult
res
;
popupFrameElement
-
>
PresetOpenerWindow
(
WindowProxyHolder
(
aOpenerWindow
)
res
)
;
MOZ_ASSERT
(
!
res
.
Failed
(
)
)
;
}
OpenWindowResult
opened
=
DispatchOpenWindowEvent
(
openerFrameElement
popupFrameElement
NS_ConvertUTF8toUTF16
(
spec
)
aName
false
NS_ConvertUTF8toUTF16
(
aFeatures
)
)
;
if
(
opened
!
=
BrowserElementParent
:
:
OPEN_WINDOW_ADDED
)
{
return
opened
;
}
RefPtr
<
nsFrameLoader
>
frameLoader
=
popupFrameElement
-
>
GetFrameLoader
(
)
;
NS_ENSURE_TRUE
(
frameLoader
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
)
;
nsCOMPtr
<
nsIDocShell
>
docshell
=
frameLoader
-
>
GetDocShell
(
IgnoreErrors
(
)
)
;
NS_ENSURE_TRUE
(
docshell
BrowserElementParent
:
:
OPEN_WINDOW_IGNORED
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
docshell
-
>
GetWindow
(
)
;
window
.
forget
(
aReturnWindow
)
;
return
!
!
*
aReturnWindow
?
opened
:
BrowserElementParent
:
:
OPEN_WINDOW_CANCELLED
;
}
}
