"
use
strict
"
;
function
debug
(
msg
)
{
}
debug
(
"
loaded
"
)
;
var
BrowserElementIsReady
;
var
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
utils
:
Cu
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
BrowserElementPromptService
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ExtensionContent
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
acs
"
"
mozilla
.
org
/
audiochannel
/
service
;
1
"
"
nsIAudioChannelService
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ManifestFinder
"
"
resource
:
/
/
gre
/
modules
/
ManifestFinder
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ManifestObtainer
"
"
resource
:
/
/
gre
/
modules
/
ManifestObtainer
.
jsm
"
)
;
var
kLongestReturnedString
=
128
;
const
Timer
=
Components
.
Constructor
(
"
mozilla
.
org
/
timer
;
1
"
"
nsITimer
"
"
initWithCallback
"
)
;
function
sendAsyncMsg
(
msg
data
)
{
if
(
!
BrowserElementIsReady
)
{
return
;
}
if
(
!
data
)
{
data
=
{
}
;
}
data
.
msg_name
=
msg
;
sendAsyncMessage
(
'
browser
-
element
-
api
:
call
'
data
)
;
}
function
sendSyncMsg
(
msg
data
)
{
if
(
!
BrowserElementIsReady
)
{
return
;
}
if
(
!
data
)
{
data
=
{
}
;
}
data
.
msg_name
=
msg
;
return
sendSyncMessage
(
'
browser
-
element
-
api
:
call
'
data
)
;
}
var
CERTIFICATE_ERROR_PAGE_PREF
=
'
security
.
alternate_certificate_error_page
'
;
const
OBSERVED_EVENTS
=
[
'
xpcom
-
shutdown
'
'
audio
-
playback
'
'
activity
-
done
'
'
invalid
-
widget
'
'
will
-
launch
-
app
'
]
;
var
global
=
this
;
function
BrowserElementProxyForwarder
(
)
{
}
BrowserElementProxyForwarder
.
prototype
=
{
init
:
function
(
)
{
Services
.
obs
.
addObserver
(
this
"
browser
-
element
-
api
:
proxy
-
call
"
false
)
;
addMessageListener
(
"
browser
-
element
-
api
:
proxy
"
this
)
;
}
uninit
:
function
(
)
{
Services
.
obs
.
removeObserver
(
this
"
browser
-
element
-
api
:
proxy
-
call
"
false
)
;
removeMessageListener
(
"
browser
-
element
-
api
:
proxy
"
this
)
;
}
observe
:
function
(
subject
topic
stringifedData
)
{
if
(
subject
!
=
=
content
)
{
return
;
}
sendAsyncMessage
(
topic
JSON
.
parse
(
stringifedData
)
)
;
}
receiveMessage
:
function
(
mmMsg
)
{
Services
.
obs
.
notifyObservers
(
content
mmMsg
.
name
JSON
.
stringify
(
mmMsg
.
json
)
)
;
}
}
;
function
BrowserElementChild
(
)
{
this
.
_windowIDDict
=
{
}
;
this
.
_forcedVisible
=
true
;
this
.
_ownerVisible
=
true
;
this
.
_nextPaintHandler
=
null
;
this
.
_isContentWindowCreated
=
false
;
this
.
_pendingSetInputMethodActive
=
[
]
;
this
.
forwarder
=
new
BrowserElementProxyForwarder
(
)
;
this
.
_init
(
)
;
}
;
BrowserElementChild
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
]
)
_init
:
function
(
)
{
debug
(
"
Starting
up
.
"
)
;
BrowserElementPromptService
.
mapWindowToBrowserElementChild
(
content
this
)
;
docShell
.
QueryInterface
(
Ci
.
nsIWebProgress
)
.
addProgressListener
(
this
.
_progressListener
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
|
Ci
.
nsIWebProgress
.
NOTIFY_SECURITY
|
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
)
;
let
webNavigation
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
if
(
!
webNavigation
.
sessionHistory
)
{
webNavigation
.
sessionHistory
=
Cc
[
"
mozilla
.
org
/
browser
/
shistory
;
1
"
]
.
createInstance
(
Ci
.
nsISHistory
)
;
}
var
securityUI
=
Cc
[
'
mozilla
.
org
/
secure_browser_ui
;
1
'
]
.
createInstance
(
Ci
.
nsISecureBrowserUI
)
;
securityUI
.
init
(
content
)
;
this
.
_ctxHandlers
=
{
}
;
this
.
_ctxCounter
=
0
;
this
.
_shuttingDown
=
false
;
addEventListener
(
'
DOMTitleChanged
'
this
.
_titleChangedHandler
.
bind
(
this
)
true
false
)
;
addEventListener
(
'
DOMLinkAdded
'
this
.
_linkAddedHandler
.
bind
(
this
)
true
false
)
;
addEventListener
(
'
MozScrolledAreaChanged
'
this
.
_mozScrollAreaChanged
.
bind
(
this
)
true
false
)
;
addEventListener
(
"
MozDOMFullscreen
:
Request
"
this
.
_mozRequestedDOMFullscreen
.
bind
(
this
)
true
false
)
;
addEventListener
(
"
MozDOMFullscreen
:
NewOrigin
"
this
.
_mozFullscreenOriginChange
.
bind
(
this
)
true
false
)
;
addEventListener
(
"
MozDOMFullscreen
:
Exit
"
this
.
_mozExitDomFullscreen
.
bind
(
this
)
true
false
)
;
addEventListener
(
'
DOMMetaAdded
'
this
.
_metaChangedHandler
.
bind
(
this
)
true
false
)
;
addEventListener
(
'
DOMMetaChanged
'
this
.
_metaChangedHandler
.
bind
(
this
)
true
false
)
;
addEventListener
(
'
DOMMetaRemoved
'
this
.
_metaChangedHandler
.
bind
(
this
)
true
false
)
;
addEventListener
(
'
scrollviewchange
'
this
.
_ScrollViewChangeHandler
.
bind
(
this
)
true
false
)
;
addEventListener
(
'
click
'
this
.
_ClickHandler
.
bind
(
this
)
false
false
)
;
addEventListener
(
'
unload
'
this
.
_unloadHandler
.
bind
(
this
)
false
false
)
;
this
.
_addMozAfterPaintHandler
(
function
(
)
{
sendAsyncMsg
(
'
firstpaint
'
)
;
}
)
;
let
self
=
this
;
let
mmCalls
=
{
"
purge
-
history
"
:
this
.
_recvPurgeHistory
"
get
-
screenshot
"
:
this
.
_recvGetScreenshot
"
get
-
contentdimensions
"
:
this
.
_recvGetContentDimensions
"
set
-
visible
"
:
this
.
_recvSetVisible
"
get
-
visible
"
:
this
.
_recvVisible
"
send
-
mouse
-
event
"
:
this
.
_recvSendMouseEvent
"
send
-
touch
-
event
"
:
this
.
_recvSendTouchEvent
"
get
-
can
-
go
-
back
"
:
this
.
_recvCanGoBack
"
get
-
can
-
go
-
forward
"
:
this
.
_recvCanGoForward
"
mute
"
:
this
.
_recvMute
.
bind
(
this
)
"
unmute
"
:
this
.
_recvUnmute
.
bind
(
this
)
"
get
-
muted
"
:
this
.
_recvGetMuted
.
bind
(
this
)
"
set
-
volume
"
:
this
.
_recvSetVolume
.
bind
(
this
)
"
get
-
volume
"
:
this
.
_recvGetVolume
.
bind
(
this
)
"
go
-
back
"
:
this
.
_recvGoBack
"
go
-
forward
"
:
this
.
_recvGoForward
"
reload
"
:
this
.
_recvReload
"
stop
"
:
this
.
_recvStop
"
zoom
"
:
this
.
_recvZoom
"
unblock
-
modal
-
prompt
"
:
this
.
_recvStopWaiting
"
fire
-
ctx
-
callback
"
:
this
.
_recvFireCtxCallback
"
owner
-
visibility
-
change
"
:
this
.
_recvOwnerVisibilityChange
"
entered
-
fullscreen
"
:
this
.
_recvEnteredFullscreen
"
exit
-
fullscreen
"
:
this
.
_recvExitFullscreen
.
bind
(
this
)
"
activate
-
next
-
paint
-
listener
"
:
this
.
_activateNextPaintListener
.
bind
(
this
)
"
set
-
input
-
method
-
active
"
:
this
.
_recvSetInputMethodActive
.
bind
(
this
)
"
deactivate
-
next
-
paint
-
listener
"
:
this
.
_deactivateNextPaintListener
.
bind
(
this
)
"
find
-
all
"
:
this
.
_recvFindAll
.
bind
(
this
)
"
find
-
next
"
:
this
.
_recvFindNext
.
bind
(
this
)
"
clear
-
match
"
:
this
.
_recvClearMatch
.
bind
(
this
)
"
execute
-
script
"
:
this
.
_recvExecuteScript
"
get
-
audio
-
channel
-
volume
"
:
this
.
_recvGetAudioChannelVolume
"
set
-
audio
-
channel
-
volume
"
:
this
.
_recvSetAudioChannelVolume
"
get
-
audio
-
channel
-
muted
"
:
this
.
_recvGetAudioChannelMuted
"
set
-
audio
-
channel
-
muted
"
:
this
.
_recvSetAudioChannelMuted
"
get
-
is
-
audio
-
channel
-
active
"
:
this
.
_recvIsAudioChannelActive
"
get
-
web
-
manifest
"
:
this
.
_recvGetWebManifest
}
addMessageListener
(
"
browser
-
element
-
api
:
call
"
function
(
aMessage
)
{
if
(
aMessage
.
data
.
msg_name
in
mmCalls
)
{
return
mmCalls
[
aMessage
.
data
.
msg_name
]
.
apply
(
self
arguments
)
;
}
}
)
;
let
els
=
Cc
[
"
mozilla
.
org
/
eventlistenerservice
;
1
"
]
.
getService
(
Ci
.
nsIEventListenerService
)
;
els
.
addSystemEventListener
(
global
'
DOMWindowClose
'
this
.
_windowCloseHandler
.
bind
(
this
)
false
)
;
els
.
addSystemEventListener
(
global
'
DOMWindowCreated
'
this
.
_windowCreatedHandler
.
bind
(
this
)
true
)
;
els
.
addSystemEventListener
(
global
'
DOMWindowResize
'
this
.
_windowResizeHandler
.
bind
(
this
)
false
)
;
els
.
addSystemEventListener
(
global
'
contextmenu
'
this
.
_contextmenuHandler
.
bind
(
this
)
false
)
;
els
.
addSystemEventListener
(
global
'
scroll
'
this
.
_scrollEventHandler
.
bind
(
this
)
false
)
;
OBSERVED_EVENTS
.
forEach
(
(
aTopic
)
=
>
{
Services
.
obs
.
addObserver
(
this
aTopic
false
)
;
}
)
;
this
.
forwarder
.
init
(
)
;
}
_paintFrozenTimer
:
null
observe
:
function
(
subject
topic
data
)
{
if
(
topic
!
=
=
'
activity
-
done
'
&
&
topic
!
=
=
'
audio
-
playback
'
&
&
topic
!
=
=
'
will
-
launch
-
app
'
&
&
(
!
content
|
|
subject
!
=
=
content
.
document
)
)
{
return
;
}
if
(
topic
=
=
'
activity
-
done
'
&
&
docShell
!
=
=
subject
)
return
;
switch
(
topic
)
{
case
'
activity
-
done
'
:
sendAsyncMsg
(
'
activitydone
'
{
success
:
(
data
=
=
'
activity
-
success
'
)
}
)
;
break
;
case
'
audio
-
playback
'
:
if
(
subject
=
=
=
content
)
{
sendAsyncMsg
(
'
audioplaybackchange
'
{
_payload_
:
data
}
)
;
}
break
;
case
'
xpcom
-
shutdown
'
:
this
.
_shuttingDown
=
true
;
break
;
case
'
invalid
-
widget
'
:
sendAsyncMsg
(
'
error
'
{
type
:
'
invalid
-
widget
'
}
)
;
break
;
case
'
will
-
launch
-
app
'
:
if
(
!
docShell
.
isActive
)
{
return
;
}
if
(
Services
.
appinfo
.
processType
!
=
Services
.
appinfo
.
PROCESS_TYPE_CONTENT
)
{
return
;
}
docShell
.
contentViewer
.
pausePainting
(
)
;
this
.
_paintFrozenTimer
&
&
this
.
_paintFrozenTimer
.
cancel
(
)
;
this
.
_paintFrozenTimer
=
new
Timer
(
this
3000
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
break
;
}
}
notify
:
function
(
timer
)
{
docShell
.
contentViewer
.
resumePainting
(
)
;
this
.
_paintFrozenTimer
.
cancel
(
)
;
this
.
_paintFrozenTimer
=
null
;
}
_unloadHandler
:
function
(
)
{
this
.
_shuttingDown
=
true
;
OBSERVED_EVENTS
.
forEach
(
(
aTopic
)
=
>
{
Services
.
obs
.
removeObserver
(
this
aTopic
)
;
}
)
;
this
.
forwarder
.
uninit
(
)
;
this
.
forwarder
=
null
;
}
get
_windowUtils
(
)
{
return
content
.
document
.
defaultView
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
}
_tryGetInnerWindowID
:
function
(
win
)
{
let
utils
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
try
{
return
utils
.
currentInnerWindowID
;
}
catch
(
e
)
{
return
null
;
}
}
showModalPrompt
:
function
(
win
args
)
{
let
utils
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
args
.
windowID
=
{
outer
:
utils
.
outerWindowID
inner
:
this
.
_tryGetInnerWindowID
(
win
)
}
;
sendAsyncMsg
(
'
showmodalprompt
'
args
)
;
let
returnValue
=
this
.
_waitForResult
(
win
)
;
Services
.
obs
.
notifyObservers
(
null
'
BEC
:
ShownModalPrompt
'
null
)
;
if
(
args
.
promptType
=
=
'
prompt
'
|
|
args
.
promptType
=
=
'
confirm
'
|
|
args
.
promptType
=
=
'
custom
-
prompt
'
)
{
return
returnValue
;
}
}
_waitForResult
:
function
(
win
)
{
debug
(
"
_waitForResult
(
"
+
win
+
"
)
"
)
;
let
utils
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
let
outerWindowID
=
utils
.
outerWindowID
;
let
innerWindowID
=
this
.
_tryGetInnerWindowID
(
win
)
;
if
(
innerWindowID
=
=
=
null
)
{
debug
(
"
_waitForResult
:
No
inner
window
.
Bailing
.
"
)
;
return
;
}
this
.
_windowIDDict
[
outerWindowID
]
=
Cu
.
getWeakReference
(
win
)
;
debug
(
"
Entering
modal
state
(
outerWindowID
=
"
+
outerWindowID
+
"
"
+
"
innerWindowID
=
"
+
innerWindowID
+
"
)
"
)
;
utils
.
enterModalState
(
)
;
if
(
!
win
.
modalDepth
)
{
win
.
modalDepth
=
0
;
}
win
.
modalDepth
+
+
;
let
origModalDepth
=
win
.
modalDepth
;
let
thread
=
Services
.
tm
.
currentThread
;
debug
(
"
Nested
event
loop
-
begin
"
)
;
while
(
win
.
modalDepth
=
=
origModalDepth
&
&
!
this
.
_shuttingDown
)
{
if
(
this
.
_tryGetInnerWindowID
(
win
)
!
=
=
innerWindowID
)
{
debug
(
"
_waitForResult
:
Inner
window
ID
changed
"
+
"
while
in
nested
event
loop
.
"
)
;
break
;
}
thread
.
processNextEvent
(
true
)
;
}
debug
(
"
Nested
event
loop
-
finish
"
)
;
if
(
win
.
modalDepth
=
=
0
)
{
delete
this
.
_windowIDDict
[
outerWindowID
]
;
}
if
(
innerWindowID
!
=
=
this
.
_tryGetInnerWindowID
(
win
)
)
{
throw
Components
.
Exception
(
"
Modal
state
aborted
by
navigation
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
let
returnValue
=
win
.
modalReturnValue
;
delete
win
.
modalReturnValue
;
if
(
!
this
.
_shuttingDown
)
{
utils
.
leaveModalState
(
)
;
}
debug
(
"
Leaving
modal
state
(
outerID
=
"
+
outerWindowID
+
"
"
+
"
innerID
=
"
+
innerWindowID
+
"
)
"
)
;
return
returnValue
;
}
_recvStopWaiting
:
function
(
msg
)
{
let
outerID
=
msg
.
json
.
windowID
.
outer
;
let
innerID
=
msg
.
json
.
windowID
.
inner
;
let
returnValue
=
msg
.
json
.
returnValue
;
debug
(
"
recvStopWaiting
(
outer
=
"
+
outerID
+
"
inner
=
"
+
innerID
+
"
returnValue
=
"
+
returnValue
+
"
)
"
)
;
if
(
!
this
.
_windowIDDict
[
outerID
]
)
{
debug
(
"
recvStopWaiting
:
No
record
of
outer
window
ID
"
+
outerID
)
;
return
;
}
let
win
=
this
.
_windowIDDict
[
outerID
]
.
get
(
)
;
if
(
!
win
)
{
debug
(
"
recvStopWaiting
but
window
is
gone
\
n
"
)
;
return
;
}
if
(
innerID
!
=
=
this
.
_tryGetInnerWindowID
(
win
)
)
{
debug
(
"
recvStopWaiting
but
inner
ID
has
changed
\
n
"
)
;
return
;
}
debug
(
"
recvStopWaiting
"
+
win
)
;
win
.
modalReturnValue
=
returnValue
;
win
.
modalDepth
-
-
;
}
_recvEnteredFullscreen
:
function
(
)
{
if
(
!
this
.
_windowUtils
.
handleFullscreenRequests
(
)
&
&
!
content
.
document
.
fullscreenElement
)
{
sendAsyncMsg
(
"
exit
-
dom
-
fullscreen
"
)
;
}
}
_recvExitFullscreen
:
function
(
)
{
this
.
_windowUtils
.
exitFullscreen
(
)
;
}
_titleChangedHandler
:
function
(
e
)
{
debug
(
"
Got
titlechanged
:
(
"
+
e
.
target
.
title
+
"
)
"
)
;
var
win
=
e
.
target
.
defaultView
;
if
(
win
=
=
content
)
{
sendAsyncMsg
(
'
titlechange
'
{
_payload_
:
e
.
target
.
title
}
)
;
}
else
{
debug
(
"
Not
top
level
!
"
)
;
}
}
_maybeCopyAttribute
:
function
(
src
target
attribute
)
{
if
(
src
.
getAttribute
(
attribute
)
)
{
target
[
attribute
]
=
src
.
getAttribute
(
attribute
)
;
}
}
_iconChangedHandler
:
function
(
e
)
{
debug
(
'
Got
iconchanged
:
(
'
+
e
.
target
.
href
+
'
)
'
)
;
let
icon
=
{
href
:
e
.
target
.
href
}
;
this
.
_maybeCopyAttribute
(
e
.
target
icon
'
sizes
'
)
;
this
.
_maybeCopyAttribute
(
e
.
target
icon
'
rel
'
)
;
sendAsyncMsg
(
'
iconchange
'
icon
)
;
}
_openSearchHandler
:
function
(
e
)
{
debug
(
'
Got
opensearch
:
(
'
+
e
.
target
.
href
+
'
)
'
)
;
if
(
e
.
target
.
type
!
=
=
"
application
/
opensearchdescription
+
xml
"
)
{
return
;
}
sendAsyncMsg
(
'
opensearch
'
{
title
:
e
.
target
.
title
href
:
e
.
target
.
href
}
)
;
}
_manifestChangedHandler
:
function
(
e
)
{
debug
(
'
Got
manifestchanged
:
(
'
+
e
.
target
.
href
+
'
)
'
)
;
let
manifest
=
{
href
:
e
.
target
.
href
}
;
sendAsyncMsg
(
'
manifestchange
'
manifest
)
;
}
_linkAddedHandler
:
function
(
e
)
{
let
win
=
e
.
target
.
ownerDocument
.
defaultView
;
if
(
win
!
=
content
)
{
debug
(
'
Not
top
level
!
'
)
;
return
;
}
let
handlers
=
{
'
icon
'
:
this
.
_iconChangedHandler
.
bind
(
this
)
'
apple
-
touch
-
icon
'
:
this
.
_iconChangedHandler
.
bind
(
this
)
'
apple
-
touch
-
icon
-
precomposed
'
:
this
.
_iconChangedHandler
.
bind
(
this
)
'
search
'
:
this
.
_openSearchHandler
'
manifest
'
:
this
.
_manifestChangedHandler
}
;
debug
(
'
Got
linkAdded
:
(
'
+
e
.
target
.
href
+
'
)
'
+
e
.
target
.
rel
)
;
e
.
target
.
rel
.
split
(
'
'
)
.
forEach
(
function
(
x
)
{
let
token
=
x
.
toLowerCase
(
)
;
if
(
handlers
[
token
]
)
{
handlers
[
token
]
(
e
)
;
}
}
this
)
;
}
_metaChangedHandler
:
function
(
e
)
{
let
win
=
e
.
target
.
ownerDocument
.
defaultView
;
if
(
win
!
=
content
)
{
debug
(
'
Not
top
level
!
'
)
;
return
;
}
var
name
=
e
.
target
.
name
;
var
property
=
e
.
target
.
getAttributeNS
(
null
"
property
"
)
;
if
(
!
name
&
&
!
property
)
{
return
;
}
debug
(
'
Got
metaChanged
:
(
'
+
(
name
|
|
property
)
+
'
)
'
+
e
.
target
.
content
)
;
let
handlers
=
{
'
viewmode
'
:
this
.
_genericMetaHandler
'
theme
-
color
'
:
this
.
_genericMetaHandler
'
theme
-
group
'
:
this
.
_genericMetaHandler
'
application
-
name
'
:
this
.
_applicationNameChangedHandler
}
;
let
handler
=
handlers
[
name
]
;
if
(
(
property
|
|
name
)
.
match
(
/
^
og
:
/
)
)
{
name
=
property
|
|
name
;
handler
=
this
.
_genericMetaHandler
;
}
if
(
handler
)
{
handler
(
name
e
.
type
e
.
target
)
;
}
}
_applicationNameChangedHandler
:
function
(
name
eventType
target
)
{
if
(
eventType
!
=
=
'
DOMMetaAdded
'
)
{
return
;
}
let
meta
=
{
name
:
name
content
:
target
.
content
}
;
let
lang
;
let
elm
;
for
(
elm
=
target
;
!
lang
&
&
elm
&
&
elm
.
nodeType
=
=
target
.
ELEMENT_NODE
;
elm
=
elm
.
parentNode
)
{
if
(
elm
.
hasAttribute
(
'
lang
'
)
)
{
lang
=
elm
.
getAttribute
(
'
lang
'
)
;
continue
;
}
if
(
elm
.
hasAttributeNS
(
'
http
:
/
/
www
.
w3
.
org
/
XML
/
1998
/
namespace
'
'
lang
'
)
)
{
lang
=
elm
.
getAttributeNS
(
'
http
:
/
/
www
.
w3
.
org
/
XML
/
1998
/
namespace
'
'
lang
'
)
;
continue
;
}
}
if
(
!
lang
&
&
elm
.
nodeType
=
=
target
.
DOCUMENT_NODE
)
{
lang
=
elm
.
contentLanguage
;
}
if
(
lang
)
{
meta
.
lang
=
lang
;
}
sendAsyncMsg
(
'
metachange
'
meta
)
;
}
_ScrollViewChangeHandler
:
function
(
e
)
{
e
.
stopPropagation
(
)
;
let
detail
=
{
state
:
e
.
state
}
;
sendAsyncMsg
(
'
scrollviewchange
'
detail
)
;
}
_ClickHandler
:
function
(
e
)
{
let
isHTMLLink
=
node
=
>
(
(
node
instanceof
Ci
.
nsIDOMHTMLAnchorElement
&
&
node
.
href
)
|
|
(
node
instanceof
Ci
.
nsIDOMHTMLAreaElement
&
&
node
.
href
)
|
|
node
instanceof
Ci
.
nsIDOMHTMLLinkElement
)
;
if
(
(
Services
.
appinfo
.
OS
=
=
'
Darwin
'
&
&
e
.
metaKey
)
|
|
(
Services
.
appinfo
.
OS
!
=
'
Darwin
'
&
&
e
.
ctrlKey
)
|
|
e
.
button
=
=
1
)
{
let
node
=
e
.
target
;
while
(
node
&
&
!
isHTMLLink
(
node
)
)
{
node
=
node
.
parentNode
;
}
if
(
node
)
{
sendAsyncMsg
(
'
opentab
'
{
url
:
node
.
href
}
)
;
}
}
}
_genericMetaHandler
:
function
(
name
eventType
target
)
{
let
meta
=
{
name
:
name
content
:
target
.
content
type
:
eventType
.
replace
(
'
DOMMeta
'
'
'
)
.
toLowerCase
(
)
}
;
sendAsyncMsg
(
'
metachange
'
meta
)
;
}
_addMozAfterPaintHandler
:
function
(
callback
)
{
function
onMozAfterPaint
(
)
{
let
uri
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
currentURI
;
if
(
uri
.
spec
!
=
"
about
:
blank
"
)
{
debug
(
"
Got
afterpaint
event
:
"
+
uri
.
spec
)
;
removeEventListener
(
'
MozAfterPaint
'
onMozAfterPaint
true
)
;
callback
(
)
;
}
}
addEventListener
(
'
MozAfterPaint
'
onMozAfterPaint
true
)
;
return
onMozAfterPaint
;
}
_removeMozAfterPaintHandler
:
function
(
listener
)
{
removeEventListener
(
'
MozAfterPaint
'
listener
true
)
;
}
_activateNextPaintListener
:
function
(
e
)
{
if
(
!
this
.
_nextPaintHandler
)
{
this
.
_nextPaintHandler
=
this
.
_addMozAfterPaintHandler
(
function
(
)
{
this
.
_nextPaintHandler
=
null
;
sendAsyncMsg
(
'
nextpaint
'
)
;
}
.
bind
(
this
)
)
;
}
}
_deactivateNextPaintListener
:
function
(
e
)
{
if
(
this
.
_nextPaintHandler
)
{
this
.
_removeMozAfterPaintHandler
(
this
.
_nextPaintHandler
)
;
this
.
_nextPaintHandler
=
null
;
}
}
_windowCloseHandler
:
function
(
e
)
{
let
win
=
e
.
target
;
if
(
win
!
=
content
|
|
e
.
defaultPrevented
)
{
return
;
}
debug
(
"
Closing
window
"
+
win
)
;
sendAsyncMsg
(
'
close
'
)
;
e
.
preventDefault
(
)
;
}
_windowCreatedHandler
:
function
(
e
)
{
let
targetDocShell
=
e
.
target
.
defaultView
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
;
if
(
targetDocShell
!
=
docShell
)
{
return
;
}
let
uri
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
currentURI
;
debug
(
"
Window
created
:
"
+
uri
.
spec
)
;
if
(
uri
.
spec
!
=
"
about
:
blank
"
)
{
this
.
_addMozAfterPaintHandler
(
function
(
)
{
sendAsyncMsg
(
'
documentfirstpaint
'
)
;
}
)
;
this
.
_isContentWindowCreated
=
true
;
while
(
this
.
_pendingSetInputMethodActive
.
length
>
0
)
{
this
.
_recvSetInputMethodActive
(
this
.
_pendingSetInputMethodActive
.
shift
(
)
)
;
}
}
}
_windowResizeHandler
:
function
(
e
)
{
let
win
=
e
.
target
;
if
(
win
!
=
content
|
|
e
.
defaultPrevented
)
{
return
;
}
debug
(
"
resizing
window
"
+
win
)
;
sendAsyncMsg
(
'
resize
'
{
width
:
e
.
detail
.
width
height
:
e
.
detail
.
height
}
)
;
e
.
preventDefault
(
)
;
}
_contextmenuHandler
:
function
(
e
)
{
debug
(
"
Got
contextmenu
"
)
;
if
(
e
.
defaultPrevented
)
{
return
;
}
this
.
_ctxCounter
+
+
;
this
.
_ctxHandlers
=
{
}
;
var
elem
=
e
.
target
;
var
menuData
=
{
systemTargets
:
[
]
contextmenu
:
null
}
;
var
ctxMenuId
=
null
;
var
clipboardPlainTextOnly
=
Services
.
prefs
.
getBoolPref
(
'
clipboard
.
plainTextOnly
'
)
;
var
copyableElements
=
{
image
:
false
link
:
false
hasElements
:
function
(
)
{
return
this
.
image
|
|
this
.
link
;
}
}
;
docShell
.
contentViewer
.
QueryInterface
(
Ci
.
nsIContentViewerEdit
)
.
setCommandNode
(
elem
)
;
while
(
elem
&
&
elem
.
parentNode
)
{
var
ctxData
=
this
.
_getSystemCtxMenuData
(
elem
)
;
if
(
ctxData
)
{
menuData
.
systemTargets
.
push
(
{
nodeName
:
elem
.
nodeName
data
:
ctxData
}
)
;
}
if
(
!
ctxMenuId
&
&
'
hasAttribute
'
in
elem
&
&
elem
.
hasAttribute
(
'
contextmenu
'
)
)
{
ctxMenuId
=
elem
.
getAttribute
(
'
contextmenu
'
)
;
}
if
(
elem
.
nodeName
=
=
'
IMG
'
)
{
copyableElements
.
image
=
!
clipboardPlainTextOnly
;
}
else
if
(
elem
.
nodeName
=
=
'
A
'
)
{
copyableElements
.
link
=
true
;
}
elem
=
elem
.
parentNode
;
}
if
(
ctxMenuId
|
|
copyableElements
.
hasElements
(
)
)
{
var
menu
=
null
;
if
(
ctxMenuId
)
{
menu
=
e
.
target
.
ownerDocument
.
getElementById
(
ctxMenuId
)
;
}
menuData
.
contextmenu
=
this
.
_buildMenuObj
(
menu
'
'
copyableElements
)
;
}
menuData
.
clientX
=
e
.
clientX
;
menuData
.
clientY
=
e
.
clientY
;
menuData
.
screenX
=
e
.
screenX
;
menuData
.
screenY
=
e
.
screenY
;
if
(
sendSyncMsg
(
'
contextmenu
'
menuData
)
[
0
]
)
{
e
.
preventDefault
(
)
;
}
else
{
this
.
_ctxHandlers
=
{
}
;
}
}
_getSystemCtxMenuData
:
function
(
elem
)
{
let
documentURI
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
currentURI
.
spec
;
if
(
(
elem
instanceof
Ci
.
nsIDOMHTMLAnchorElement
&
&
elem
.
href
)
|
|
(
elem
instanceof
Ci
.
nsIDOMHTMLAreaElement
&
&
elem
.
href
)
)
{
return
{
uri
:
elem
.
href
documentURI
:
documentURI
text
:
elem
.
textContent
.
substring
(
0
kLongestReturnedString
)
}
;
}
if
(
elem
instanceof
Ci
.
nsIImageLoadingContent
&
&
elem
.
currentURI
)
{
return
{
uri
:
elem
.
currentURI
.
spec
documentURI
:
documentURI
}
;
}
if
(
elem
instanceof
Ci
.
nsIDOMHTMLImageElement
)
{
return
{
uri
:
elem
.
src
documentURI
:
documentURI
}
;
}
if
(
elem
instanceof
Ci
.
nsIDOMHTMLMediaElement
)
{
let
hasVideo
=
!
(
elem
.
readyState
>
=
elem
.
HAVE_METADATA
&
&
(
elem
.
videoWidth
=
=
0
|
|
elem
.
videoHeight
=
=
0
)
)
;
return
{
uri
:
elem
.
currentSrc
|
|
elem
.
src
hasVideo
:
hasVideo
documentURI
:
documentURI
}
;
}
if
(
elem
instanceof
Ci
.
nsIDOMHTMLInputElement
&
&
elem
.
hasAttribute
(
"
name
"
)
)
{
let
parent
=
elem
.
parentNode
;
while
(
parent
)
{
if
(
parent
instanceof
Ci
.
nsIDOMHTMLFormElement
&
&
parent
.
hasAttribute
(
"
action
"
)
)
{
let
actionHref
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
currentURI
.
resolve
(
parent
.
getAttribute
(
"
action
"
)
)
;
let
method
=
parent
.
hasAttribute
(
"
method
"
)
?
parent
.
getAttribute
(
"
method
"
)
.
toLowerCase
(
)
:
"
get
"
;
return
{
documentURI
:
documentURI
action
:
actionHref
method
:
method
name
:
elem
.
getAttribute
(
"
name
"
)
}
}
parent
=
parent
.
parentNode
;
}
}
return
false
;
}
_scrollEventHandler
:
function
(
e
)
{
let
win
=
e
.
target
.
defaultView
;
if
(
win
!
=
content
)
{
return
;
}
debug
(
"
scroll
event
"
+
win
)
;
sendAsyncMsg
(
"
scroll
"
{
top
:
win
.
scrollY
left
:
win
.
scrollX
}
)
;
}
_recvPurgeHistory
:
function
(
data
)
{
debug
(
"
Received
purgeHistory
message
:
(
"
+
data
.
json
.
id
+
"
)
"
)
;
let
history
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
sessionHistory
;
try
{
if
(
history
&
&
history
.
count
)
{
history
.
PurgeHistory
(
history
.
count
)
;
}
}
catch
(
e
)
{
}
sendAsyncMsg
(
'
got
-
purge
-
history
'
{
id
:
data
.
json
.
id
successRv
:
true
}
)
;
}
_recvGetScreenshot
:
function
(
data
)
{
debug
(
"
Received
getScreenshot
message
:
(
"
+
data
.
json
.
id
+
"
)
"
)
;
let
self
=
this
;
let
maxWidth
=
data
.
json
.
args
.
width
;
let
maxHeight
=
data
.
json
.
args
.
height
;
let
mimeType
=
data
.
json
.
args
.
mimeType
;
let
domRequestID
=
data
.
json
.
id
;
let
takeScreenshotClosure
=
function
(
)
{
self
.
_takeScreenshot
(
maxWidth
maxHeight
mimeType
domRequestID
)
;
}
;
let
maxDelayMS
=
2000
;
try
{
maxDelayMS
=
Services
.
prefs
.
getIntPref
(
'
dom
.
browserElement
.
maxScreenshotDelayMS
'
)
;
}
catch
(
e
)
{
}
Cc
[
'
mozilla
.
org
/
message
-
loop
;
1
'
]
.
getService
(
Ci
.
nsIMessageLoop
)
.
postIdleTask
(
takeScreenshotClosure
maxDelayMS
)
;
}
_recvExecuteScript
:
function
(
data
)
{
debug
(
"
Received
executeScript
message
:
(
"
+
data
.
json
.
id
+
"
)
"
)
;
let
domRequestID
=
data
.
json
.
id
;
let
sendError
=
errorMsg
=
>
sendAsyncMsg
(
"
execute
-
script
-
done
"
{
errorMsg
id
:
domRequestID
}
)
;
let
sendSuccess
=
successRv
=
>
sendAsyncMsg
(
"
execute
-
script
-
done
"
{
successRv
id
:
domRequestID
}
)
;
let
isJSON
=
obj
=
>
{
try
{
JSON
.
stringify
(
obj
)
;
}
catch
(
e
)
{
return
false
;
}
return
true
;
}
let
expectedOrigin
=
data
.
json
.
args
.
options
.
origin
;
let
expectedUrl
=
data
.
json
.
args
.
options
.
url
;
if
(
expectedOrigin
)
{
if
(
expectedOrigin
!
=
content
.
location
.
origin
)
{
sendError
(
"
Origin
mismatches
"
)
;
return
;
}
}
if
(
expectedUrl
)
{
let
expectedURI
try
{
expectedURI
=
Services
.
io
.
newURI
(
expectedUrl
null
null
)
;
}
catch
(
e
)
{
sendError
(
"
Malformed
URL
"
)
;
return
;
}
let
currentURI
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
currentURI
;
if
(
!
currentURI
.
equalsExceptRef
(
expectedURI
)
)
{
sendError
(
"
URL
mismatches
"
)
;
return
;
}
}
let
sandbox
=
new
Cu
.
Sandbox
(
[
content
]
{
sandboxPrototype
:
content
sandboxName
:
"
browser
-
api
-
execute
-
script
"
allowWaivers
:
false
sameZoneAs
:
content
}
)
;
try
{
let
sandboxRv
=
Cu
.
evalInSandbox
(
data
.
json
.
args
.
script
sandbox
"
1
.
8
"
)
;
if
(
sandboxRv
instanceof
sandbox
.
Promise
)
{
sandboxRv
.
then
(
rv
=
>
{
if
(
isJSON
(
rv
)
)
{
sendSuccess
(
rv
)
;
}
else
{
sendError
(
"
Value
returned
(
resolve
)
by
promise
is
not
a
valid
JSON
object
"
)
;
}
}
error
=
>
{
if
(
isJSON
(
error
)
)
{
sendError
(
error
)
;
}
else
{
sendError
(
"
Value
returned
(
reject
)
by
promise
is
not
a
valid
JSON
object
"
)
;
}
}
)
;
}
else
{
if
(
isJSON
(
sandboxRv
)
)
{
sendSuccess
(
sandboxRv
)
;
}
else
{
sendError
(
"
Script
last
expression
must
be
a
promise
or
a
JSON
object
"
)
;
}
}
}
catch
(
e
)
{
sendError
(
e
.
toString
(
)
)
;
}
}
_recvGetContentDimensions
:
function
(
data
)
{
debug
(
"
Received
getContentDimensions
message
:
(
"
+
data
.
json
.
id
+
"
)
"
)
;
sendAsyncMsg
(
'
got
-
contentdimensions
'
{
id
:
data
.
json
.
id
successRv
:
this
.
_getContentDimensions
(
)
}
)
;
}
_mozScrollAreaChanged
:
function
(
e
)
{
sendAsyncMsg
(
'
scrollareachanged
'
{
width
:
e
.
width
height
:
e
.
height
}
)
;
}
_mozRequestedDOMFullscreen
:
function
(
e
)
{
sendAsyncMsg
(
"
requested
-
dom
-
fullscreen
"
)
;
}
_mozFullscreenOriginChange
:
function
(
e
)
{
sendAsyncMsg
(
"
fullscreen
-
origin
-
change
"
{
originNoSuffix
:
e
.
target
.
nodePrincipal
.
originNoSuffix
}
)
;
}
_mozExitDomFullscreen
:
function
(
e
)
{
sendAsyncMsg
(
"
exit
-
dom
-
fullscreen
"
)
;
}
_getContentDimensions
:
function
(
)
{
return
{
width
:
content
.
document
.
body
.
scrollWidth
height
:
content
.
document
.
body
.
scrollHeight
}
}
_takeScreenshot
:
function
(
maxWidth
maxHeight
mimeType
domRequestID
)
{
debug
(
"
Taking
a
screenshot
:
maxWidth
=
"
+
maxWidth
+
"
maxHeight
=
"
+
maxHeight
+
"
mimeType
=
"
+
mimeType
+
"
domRequestID
=
"
+
domRequestID
+
"
.
"
)
;
if
(
!
content
)
{
debug
(
"
No
content
yet
!
"
)
;
return
;
}
let
devicePixelRatio
=
content
.
devicePixelRatio
;
let
maxPixelWidth
=
Math
.
round
(
maxWidth
*
devicePixelRatio
)
;
let
maxPixelHeight
=
Math
.
round
(
maxHeight
*
devicePixelRatio
)
;
let
contentPixelWidth
=
content
.
innerWidth
*
devicePixelRatio
;
let
contentPixelHeight
=
content
.
innerHeight
*
devicePixelRatio
;
let
scaleWidth
=
Math
.
min
(
1
maxPixelWidth
/
contentPixelWidth
)
;
let
scaleHeight
=
Math
.
min
(
1
maxPixelHeight
/
contentPixelHeight
)
;
let
scale
=
Math
.
max
(
scaleWidth
scaleHeight
)
;
let
canvasWidth
=
Math
.
min
(
maxPixelWidth
Math
.
round
(
contentPixelWidth
*
scale
)
)
;
let
canvasHeight
=
Math
.
min
(
maxPixelHeight
Math
.
round
(
contentPixelHeight
*
scale
)
)
;
let
transparent
=
(
mimeType
!
=
=
'
image
/
jpeg
'
)
;
var
canvas
=
content
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
canvas
"
)
;
if
(
!
transparent
)
canvas
.
mozOpaque
=
true
;
canvas
.
width
=
canvasWidth
;
canvas
.
height
=
canvasHeight
;
let
ctx
=
canvas
.
getContext
(
"
2d
"
{
willReadFrequently
:
true
}
)
;
ctx
.
scale
(
scale
*
devicePixelRatio
scale
*
devicePixelRatio
)
;
let
flags
=
ctx
.
DRAWWINDOW_DRAW_VIEW
|
ctx
.
DRAWWINDOW_USE_WIDGET_LAYERS
|
ctx
.
DRAWWINDOW_DO_NOT_FLUSH
|
ctx
.
DRAWWINDOW_ASYNC_DECODE_IMAGES
;
ctx
.
drawWindow
(
content
0
0
content
.
innerWidth
content
.
innerHeight
transparent
?
"
rgba
(
255
255
255
0
)
"
:
"
rgb
(
255
255
255
)
"
flags
)
;
canvas
.
toBlob
(
function
(
blob
)
{
sendAsyncMsg
(
'
got
-
screenshot
'
{
id
:
domRequestID
successRv
:
blob
}
)
;
}
mimeType
)
;
}
_recvFireCtxCallback
:
function
(
data
)
{
debug
(
"
Received
fireCtxCallback
message
:
(
"
+
data
.
json
.
menuitem
+
"
)
"
)
;
let
doCommandIfEnabled
=
(
command
)
=
>
{
if
(
docShell
.
isCommandEnabled
(
command
)
)
{
docShell
.
doCommand
(
command
)
;
}
}
;
if
(
data
.
json
.
menuitem
=
=
'
copy
-
image
'
)
{
doCommandIfEnabled
(
'
cmd_copyImage
'
)
;
}
else
if
(
data
.
json
.
menuitem
=
=
'
copy
-
link
'
)
{
doCommandIfEnabled
(
'
cmd_copyLink
'
)
;
}
else
if
(
data
.
json
.
menuitem
in
this
.
_ctxHandlers
)
{
this
.
_ctxHandlers
[
data
.
json
.
menuitem
]
.
click
(
)
;
this
.
_ctxHandlers
=
{
}
;
}
else
{
debug
(
"
Ignored
invalid
contextmenu
invocation
"
)
;
}
}
_buildMenuObj
:
function
(
menu
idPrefix
copyableElements
)
{
var
menuObj
=
{
type
:
'
menu
'
customized
:
false
items
:
[
]
}
;
if
(
menu
)
{
this
.
_maybeCopyAttribute
(
menu
menuObj
'
label
'
)
;
for
(
var
i
=
0
child
;
child
=
menu
.
children
[
i
+
+
]
;
)
{
if
(
child
.
nodeName
=
=
=
'
MENU
'
)
{
menuObj
.
items
.
push
(
this
.
_buildMenuObj
(
child
idPrefix
+
i
+
'
_
'
false
)
)
;
}
else
if
(
child
.
nodeName
=
=
=
'
MENUITEM
'
)
{
var
id
=
this
.
_ctxCounter
+
'
_
'
+
idPrefix
+
i
;
var
menuitem
=
{
id
:
id
type
:
'
menuitem
'
}
;
this
.
_maybeCopyAttribute
(
child
menuitem
'
label
'
)
;
this
.
_maybeCopyAttribute
(
child
menuitem
'
icon
'
)
;
this
.
_ctxHandlers
[
id
]
=
child
;
menuObj
.
items
.
push
(
menuitem
)
;
}
}
if
(
menuObj
.
items
.
length
>
0
)
{
menuObj
.
customized
=
true
;
}
}
if
(
copyableElements
.
link
)
{
menuObj
.
items
.
push
(
{
id
:
'
copy
-
link
'
}
)
;
}
if
(
copyableElements
.
image
)
{
menuObj
.
items
.
push
(
{
id
:
'
copy
-
image
'
}
)
;
}
return
menuObj
;
}
_recvSetVisible
:
function
(
data
)
{
debug
(
"
Received
setVisible
message
:
(
"
+
data
.
json
.
visible
+
"
)
"
)
;
if
(
this
.
_forcedVisible
=
=
data
.
json
.
visible
)
{
return
;
}
this
.
_forcedVisible
=
data
.
json
.
visible
;
this
.
_updateVisibility
(
)
;
}
_recvVisible
:
function
(
data
)
{
sendAsyncMsg
(
'
got
-
visible
'
{
id
:
data
.
json
.
id
successRv
:
docShell
.
isActive
}
)
;
}
_recvOwnerVisibilityChange
:
function
(
data
)
{
debug
(
"
Received
ownerVisibilityChange
:
(
"
+
data
.
json
.
visible
+
"
)
"
)
;
this
.
_ownerVisible
=
data
.
json
.
visible
;
this
.
_updateVisibility
(
)
;
}
_updateVisibility
:
function
(
)
{
var
visible
=
this
.
_forcedVisible
&
&
this
.
_ownerVisible
;
if
(
docShell
&
&
docShell
.
isActive
!
=
=
visible
)
{
docShell
.
isActive
=
visible
;
sendAsyncMsg
(
'
visibilitychange
'
{
visible
:
visible
}
)
;
if
(
visible
&
&
this
.
_paintFrozenTimer
)
{
this
.
notify
(
)
;
}
}
}
_recvSendMouseEvent
:
function
(
data
)
{
let
json
=
data
.
json
;
let
utils
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
utils
.
sendMouseEventToWindow
(
json
.
type
json
.
x
json
.
y
json
.
button
json
.
clickCount
json
.
modifiers
)
;
}
_recvSendTouchEvent
:
function
(
data
)
{
let
json
=
data
.
json
;
let
utils
=
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
utils
.
sendTouchEventToWindow
(
json
.
type
json
.
identifiers
json
.
touchesX
json
.
touchesY
json
.
radiisX
json
.
radiisY
json
.
rotationAngles
json
.
forces
json
.
count
json
.
modifiers
)
;
}
_recvCanGoBack
:
function
(
data
)
{
var
webNav
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
sendAsyncMsg
(
'
got
-
can
-
go
-
back
'
{
id
:
data
.
json
.
id
successRv
:
webNav
.
canGoBack
}
)
;
}
_recvCanGoForward
:
function
(
data
)
{
var
webNav
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
sendAsyncMsg
(
'
got
-
can
-
go
-
forward
'
{
id
:
data
.
json
.
id
successRv
:
webNav
.
canGoForward
}
)
;
}
_recvMute
:
function
(
data
)
{
this
.
_windowUtils
.
audioMuted
=
true
;
}
_recvUnmute
:
function
(
data
)
{
this
.
_windowUtils
.
audioMuted
=
false
;
}
_recvGetMuted
:
function
(
data
)
{
sendAsyncMsg
(
'
got
-
muted
'
{
id
:
data
.
json
.
id
successRv
:
this
.
_windowUtils
.
audioMuted
}
)
;
}
_recvSetVolume
:
function
(
data
)
{
this
.
_windowUtils
.
audioVolume
=
data
.
json
.
volume
;
}
_recvGetVolume
:
function
(
data
)
{
sendAsyncMsg
(
'
got
-
volume
'
{
id
:
data
.
json
.
id
successRv
:
this
.
_windowUtils
.
audioVolume
}
)
;
}
_recvGoBack
:
function
(
data
)
{
try
{
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
goBack
(
)
;
}
catch
(
e
)
{
}
}
_recvGoForward
:
function
(
data
)
{
try
{
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
.
goForward
(
)
;
}
catch
(
e
)
{
}
}
_recvReload
:
function
(
data
)
{
let
webNav
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
let
reloadFlags
=
data
.
json
.
hardReload
?
webNav
.
LOAD_FLAGS_BYPASS_PROXY
|
webNav
.
LOAD_FLAGS_BYPASS_CACHE
:
webNav
.
LOAD_FLAGS_NONE
;
try
{
webNav
.
reload
(
reloadFlags
)
;
}
catch
(
e
)
{
}
}
_recvStop
:
function
(
data
)
{
let
webNav
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
webNav
.
stop
(
webNav
.
STOP_NETWORK
)
;
}
_recvZoom
:
function
(
data
)
{
docShell
.
contentViewer
.
fullZoom
=
data
.
json
.
zoom
;
}
_recvGetAudioChannelVolume
:
function
(
data
)
{
debug
(
"
Received
getAudioChannelVolume
message
:
(
"
+
data
.
json
.
id
+
"
)
"
)
;
let
volume
=
acs
.
getAudioChannelVolume
(
content
data
.
json
.
args
.
audioChannel
)
;
sendAsyncMsg
(
'
got
-
audio
-
channel
-
volume
'
{
id
:
data
.
json
.
id
successRv
:
volume
}
)
;
}
_recvSetAudioChannelVolume
:
function
(
data
)
{
debug
(
"
Received
setAudioChannelVolume
message
:
(
"
+
data
.
json
.
id
+
"
)
"
)
;
acs
.
setAudioChannelVolume
(
content
data
.
json
.
args
.
audioChannel
data
.
json
.
args
.
volume
)
;
sendAsyncMsg
(
'
got
-
set
-
audio
-
channel
-
volume
'
{
id
:
data
.
json
.
id
successRv
:
true
}
)
;
}
_recvGetAudioChannelMuted
:
function
(
data
)
{
debug
(
"
Received
getAudioChannelMuted
message
:
(
"
+
data
.
json
.
id
+
"
)
"
)
;
let
muted
=
acs
.
getAudioChannelMuted
(
content
data
.
json
.
args
.
audioChannel
)
;
sendAsyncMsg
(
'
got
-
audio
-
channel
-
muted
'
{
id
:
data
.
json
.
id
successRv
:
muted
}
)
;
}
_recvSetAudioChannelMuted
:
function
(
data
)
{
debug
(
"
Received
setAudioChannelMuted
message
:
(
"
+
data
.
json
.
id
+
"
)
"
)
;
acs
.
setAudioChannelMuted
(
content
data
.
json
.
args
.
audioChannel
data
.
json
.
args
.
muted
)
;
sendAsyncMsg
(
'
got
-
set
-
audio
-
channel
-
muted
'
{
id
:
data
.
json
.
id
successRv
:
true
}
)
;
}
_recvIsAudioChannelActive
:
function
(
data
)
{
debug
(
"
Received
isAudioChannelActive
message
:
(
"
+
data
.
json
.
id
+
"
)
"
)
;
let
active
=
acs
.
isAudioChannelActive
(
content
data
.
json
.
args
.
audioChannel
)
;
sendAsyncMsg
(
'
got
-
is
-
audio
-
channel
-
active
'
{
id
:
data
.
json
.
id
successRv
:
active
}
)
;
}
_recvGetWebManifest
:
Task
.
async
(
function
*
(
data
)
{
debug
(
Received
GetWebManifest
message
:
(
{
data
.
json
.
id
}
)
)
;
let
manifest
=
null
;
let
hasManifest
=
ManifestFinder
.
contentHasManifestLink
(
content
)
;
if
(
hasManifest
)
{
try
{
manifest
=
yield
ManifestObtainer
.
contentObtainManifest
(
content
)
;
}
catch
(
e
)
{
sendAsyncMsg
(
'
got
-
web
-
manifest
'
{
id
:
data
.
json
.
id
errorMsg
:
Error
fetching
web
manifest
:
{
e
}
.
}
)
;
return
;
}
}
sendAsyncMsg
(
'
got
-
web
-
manifest
'
{
id
:
data
.
json
.
id
successRv
:
manifest
}
)
;
}
)
_initFinder
:
function
(
)
{
if
(
!
this
.
_finder
)
{
try
{
this
.
_findLimit
=
Services
.
prefs
.
getIntPref
(
"
accessibility
.
typeaheadfind
.
matchesCountLimit
"
)
;
}
catch
(
e
)
{
this
.
_findLimit
=
0
;
}
let
{
Finder
}
=
Components
.
utils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Finder
.
jsm
"
{
}
)
;
this
.
_finder
=
new
Finder
(
docShell
)
;
this
.
_finder
.
addResultListener
(
{
onMatchesCountResult
:
(
data
)
=
>
{
sendAsyncMsg
(
'
findchange
'
{
active
:
true
searchString
:
this
.
_finder
.
searchString
searchLimit
:
this
.
_findLimit
activeMatchOrdinal
:
data
.
current
numberOfMatches
:
data
.
total
}
)
;
}
}
)
;
}
}
_recvFindAll
:
function
(
data
)
{
this
.
_initFinder
(
)
;
let
searchString
=
data
.
json
.
searchString
;
this
.
_finder
.
caseSensitive
=
data
.
json
.
caseSensitive
;
this
.
_finder
.
fastFind
(
searchString
false
false
)
;
this
.
_finder
.
requestMatchesCount
(
searchString
this
.
_findLimit
false
)
;
}
_recvFindNext
:
function
(
data
)
{
if
(
!
this
.
_finder
)
{
debug
(
"
findNext
(
)
called
before
findAll
(
)
"
)
;
return
;
}
this
.
_finder
.
findAgain
(
data
.
json
.
backward
false
false
)
;
this
.
_finder
.
requestMatchesCount
(
this
.
_finder
.
searchString
this
.
_findLimit
false
)
;
}
_recvClearMatch
:
function
(
data
)
{
if
(
!
this
.
_finder
)
{
debug
(
"
clearMach
(
)
called
before
findAll
(
)
"
)
;
return
;
}
this
.
_finder
.
removeSelection
(
)
;
sendAsyncMsg
(
'
findchange
'
{
active
:
false
}
)
;
}
_recvSetInputMethodActive
:
function
(
data
)
{
let
msgData
=
{
id
:
data
.
json
.
id
}
;
if
(
!
this
.
_isContentWindowCreated
)
{
if
(
data
.
json
.
args
.
isActive
)
{
this
.
_pendingSetInputMethodActive
.
push
(
data
)
;
return
;
}
msgData
.
successRv
=
null
;
sendAsyncMsg
(
'
got
-
set
-
input
-
method
-
active
'
msgData
)
;
return
;
}
let
nav
=
XPCNativeWrapper
.
unwrap
(
content
.
document
.
defaultView
.
navigator
)
;
if
(
nav
.
mozInputMethod
)
{
new
XPCNativeWrapper
(
nav
.
mozInputMethod
)
.
setActive
(
data
.
json
.
args
.
isActive
)
;
msgData
.
successRv
=
null
;
}
else
{
msgData
.
errorMsg
=
'
Cannot
access
mozInputMethod
.
'
;
}
sendAsyncMsg
(
'
got
-
set
-
input
-
method
-
active
'
msgData
)
;
}
_progressListener
:
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
_seenLoadStart
:
false
onLocationChange
:
function
(
webProgress
request
location
flags
)
{
if
(
webProgress
!
=
docShell
)
{
return
;
}
if
(
!
this
.
_seenLoadStart
)
{
return
;
}
location
=
Cc
[
"
mozilla
.
org
/
docshell
/
urifixup
;
1
"
]
.
getService
(
Ci
.
nsIURIFixup
)
.
createExposableURI
(
location
)
;
var
webNav
=
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
sendAsyncMsg
(
'
locationchange
'
{
url
:
location
.
spec
canGoBack
:
webNav
.
canGoBack
canGoForward
:
webNav
.
canGoForward
}
)
;
}
onStateChange
:
function
(
webProgress
request
stateFlags
status
)
{
if
(
webProgress
!
=
docShell
)
{
return
;
}
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_START
)
{
this
.
_seenLoadStart
=
true
;
sendAsyncMsg
(
'
loadstart
'
)
;
}
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
)
{
let
bgColor
=
'
transparent
'
;
try
{
bgColor
=
content
.
getComputedStyle
(
content
.
document
.
body
)
.
getPropertyValue
(
'
background
-
color
'
)
;
}
catch
(
e
)
{
}
sendAsyncMsg
(
'
loadend
'
{
backgroundColor
:
bgColor
}
)
;
switch
(
status
)
{
case
Cr
.
NS_OK
:
case
Cr
.
NS_BINDING_ABORTED
:
case
Cr
.
NS_ERROR_PARSED_DATA_CACHED
:
return
;
case
Cr
.
NS_ERROR_UNKNOWN_PROTOCOL
:
sendAsyncMsg
(
'
error
'
{
type
:
'
unknownProtocolFound
'
}
)
;
return
;
case
Cr
.
NS_ERROR_FILE_NOT_FOUND
:
sendAsyncMsg
(
'
error
'
{
type
:
'
fileNotFound
'
}
)
;
return
;
case
Cr
.
NS_ERROR_UNKNOWN_HOST
:
sendAsyncMsg
(
'
error
'
{
type
:
'
dnsNotFound
'
}
)
;
return
;
case
Cr
.
NS_ERROR_CONNECTION_REFUSED
:
sendAsyncMsg
(
'
error
'
{
type
:
'
connectionFailure
'
}
)
;
return
;
case
Cr
.
NS_ERROR_NET_INTERRUPT
:
sendAsyncMsg
(
'
error
'
{
type
:
'
netInterrupt
'
}
)
;
return
;
case
Cr
.
NS_ERROR_NET_TIMEOUT
:
sendAsyncMsg
(
'
error
'
{
type
:
'
netTimeout
'
}
)
;
return
;
case
Cr
.
NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION
:
sendAsyncMsg
(
'
error
'
{
type
:
'
cspBlocked
'
}
)
;
return
;
case
Cr
.
NS_ERROR_PHISHING_URI
:
sendAsyncMsg
(
'
error
'
{
type
:
'
deceptiveBlocked
'
}
)
;
return
;
case
Cr
.
NS_ERROR_MALWARE_URI
:
sendAsyncMsg
(
'
error
'
{
type
:
'
malwareBlocked
'
}
)
;
return
;
case
Cr
.
NS_ERROR_UNWANTED_URI
:
sendAsyncMsg
(
'
error
'
{
type
:
'
unwantedBlocked
'
}
)
;
return
;
case
Cr
.
NS_ERROR_FORBIDDEN_URI
:
sendAsyncMsg
(
'
error
'
{
type
:
'
forbiddenBlocked
'
}
)
;
return
;
case
Cr
.
NS_ERROR_OFFLINE
:
sendAsyncMsg
(
'
error
'
{
type
:
'
offline
'
}
)
;
return
;
case
Cr
.
NS_ERROR_MALFORMED_URI
:
sendAsyncMsg
(
'
error
'
{
type
:
'
malformedURI
'
}
)
;
return
;
case
Cr
.
NS_ERROR_REDIRECT_LOOP
:
sendAsyncMsg
(
'
error
'
{
type
:
'
redirectLoop
'
}
)
;
return
;
case
Cr
.
NS_ERROR_UNKNOWN_SOCKET_TYPE
:
sendAsyncMsg
(
'
error
'
{
type
:
'
unknownSocketType
'
}
)
;
return
;
case
Cr
.
NS_ERROR_NET_RESET
:
sendAsyncMsg
(
'
error
'
{
type
:
'
netReset
'
}
)
;
return
;
case
Cr
.
NS_ERROR_DOCUMENT_NOT_CACHED
:
sendAsyncMsg
(
'
error
'
{
type
:
'
notCached
'
}
)
;
return
;
case
Cr
.
NS_ERROR_DOCUMENT_IS_PRINTMODE
:
sendAsyncMsg
(
'
error
'
{
type
:
'
isprinting
'
}
)
;
return
;
case
Cr
.
NS_ERROR_PORT_ACCESS_NOT_ALLOWED
:
sendAsyncMsg
(
'
error
'
{
type
:
'
deniedPortAccess
'
}
)
;
return
;
case
Cr
.
NS_ERROR_UNKNOWN_PROXY_HOST
:
sendAsyncMsg
(
'
error
'
{
type
:
'
proxyResolveFailure
'
}
)
;
return
;
case
Cr
.
NS_ERROR_PROXY_CONNECTION_REFUSED
:
sendAsyncMsg
(
'
error
'
{
type
:
'
proxyConnectFailure
'
}
)
;
return
;
case
Cr
.
NS_ERROR_INVALID_CONTENT_ENCODING
:
sendAsyncMsg
(
'
error
'
{
type
:
'
contentEncodingFailure
'
}
)
;
return
;
case
Cr
.
NS_ERROR_REMOTE_XUL
:
sendAsyncMsg
(
'
error
'
{
type
:
'
remoteXUL
'
}
)
;
return
;
case
Cr
.
NS_ERROR_UNSAFE_CONTENT_TYPE
:
sendAsyncMsg
(
'
error
'
{
type
:
'
unsafeContentType
'
}
)
;
return
;
case
Cr
.
NS_ERROR_CORRUPTED_CONTENT
:
sendAsyncMsg
(
'
error
'
{
type
:
'
corruptedContentErrorv2
'
}
)
;
return
;
default
:
try
{
let
nssErrorsService
=
Cc
[
'
mozilla
.
org
/
nss_errors_service
;
1
'
]
.
getService
(
Ci
.
nsINSSErrorsService
)
;
if
(
nssErrorsService
.
getErrorClass
(
status
)
=
=
Ci
.
nsINSSErrorsService
.
ERROR_CLASS_BAD_CERT
)
{
let
errorPage
=
null
;
try
{
errorPage
=
Services
.
prefs
.
getCharPref
(
CERTIFICATE_ERROR_PAGE_PREF
)
;
}
catch
(
e
)
{
}
if
(
errorPage
=
=
'
certerror
'
)
{
sendAsyncMsg
(
'
error
'
{
type
:
'
certerror
'
}
)
;
return
;
}
}
}
catch
(
e
)
{
}
sendAsyncMsg
(
'
error
'
{
type
:
'
other
'
}
)
;
return
;
}
}
}
onSecurityChange
:
function
(
webProgress
request
state
)
{
if
(
webProgress
!
=
docShell
)
{
return
;
}
var
securityStateDesc
;
if
(
state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_SECURE
)
{
securityStateDesc
=
'
secure
'
;
}
else
if
(
state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_BROKEN
)
{
securityStateDesc
=
'
broken
'
;
}
else
if
(
state
&
Ci
.
nsIWebProgressListener
.
STATE_IS_INSECURE
)
{
securityStateDesc
=
'
insecure
'
;
}
else
{
debug
(
"
Unexpected
securitychange
state
!
"
)
;
securityStateDesc
=
'
?
?
?
'
;
}
var
trackingStateDesc
;
if
(
state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_TRACKING_CONTENT
)
{
trackingStateDesc
=
'
loaded_tracking_content
'
;
}
else
if
(
state
&
Ci
.
nsIWebProgressListener
.
STATE_BLOCKED_TRACKING_CONTENT
)
{
trackingStateDesc
=
'
blocked_tracking_content
'
;
}
var
mixedStateDesc
;
if
(
state
&
Ci
.
nsIWebProgressListener
.
STATE_BLOCKED_MIXED_ACTIVE_CONTENT
)
{
mixedStateDesc
=
'
blocked_mixed_active_content
'
;
}
else
if
(
state
&
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
{
mixedStateDesc
=
'
loaded_mixed_active_content
'
;
}
var
isEV
=
!
!
(
state
&
Ci
.
nsIWebProgressListener
.
STATE_IDENTITY_EV_TOPLEVEL
)
;
var
isTrackingContent
=
!
!
(
state
&
(
Ci
.
nsIWebProgressListener
.
STATE_BLOCKED_TRACKING_CONTENT
|
Ci
.
nsIWebProgressListener
.
STATE_LOADED_TRACKING_CONTENT
)
)
;
var
isMixedContent
=
!
!
(
state
&
(
Ci
.
nsIWebProgressListener
.
STATE_BLOCKED_MIXED_ACTIVE_CONTENT
|
Ci
.
nsIWebProgressListener
.
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
)
;
sendAsyncMsg
(
'
securitychange
'
{
state
:
securityStateDesc
trackingState
:
trackingStateDesc
mixedState
:
mixedStateDesc
extendedValidation
:
isEV
trackingContent
:
isTrackingContent
mixedContent
:
isMixedContent
}
)
;
}
onStatusChange
:
function
(
webProgress
request
status
message
)
{
}
onProgressChange
:
function
(
webProgress
request
curSelfProgress
maxSelfProgress
curTotalProgress
maxTotalProgress
)
{
}
}
_messageManagerPublic
:
{
sendAsyncMessage
:
global
.
sendAsyncMessage
.
bind
(
global
)
sendSyncMessage
:
global
.
sendSyncMessage
.
bind
(
global
)
addMessageListener
:
global
.
addMessageListener
.
bind
(
global
)
removeMessageListener
:
global
.
removeMessageListener
.
bind
(
global
)
}
get
messageManager
(
)
{
return
this
.
_messageManagerPublic
;
}
}
;
var
api
=
null
;
if
(
'
DoPreloadPostfork
'
in
this
&
&
typeof
this
.
DoPreloadPostfork
=
=
=
'
function
'
)
{
this
.
DoPreloadPostfork
(
function
(
)
{
api
=
new
BrowserElementChild
(
)
;
}
)
;
}
else
{
api
=
new
BrowserElementChild
(
)
;
}
