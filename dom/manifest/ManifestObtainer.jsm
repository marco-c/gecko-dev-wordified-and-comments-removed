"
use
strict
"
;
const
{
utils
:
Cu
classes
:
Cc
interfaces
:
Ci
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PromiseMessage
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ManifestProcessor
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
BrowserUtils
"
"
resource
:
/
/
gre
/
modules
/
BrowserUtils
.
jsm
"
)
;
this
.
ManifestObtainer
=
{
browserObtainManifest
:
Task
.
async
(
function
*
(
aBrowser
)
{
const
msgKey
=
"
DOM
:
ManifestObtainer
:
Obtain
"
;
if
(
!
isXULBrowser
(
aBrowser
)
)
{
throw
new
TypeError
(
"
Invalid
input
.
Expected
XUL
browser
.
"
)
;
}
const
mm
=
aBrowser
.
messageManager
;
const
{
data
:
{
success
result
}
}
=
yield
PromiseMessage
.
send
(
mm
msgKey
)
;
if
(
!
success
)
{
const
error
=
toError
(
result
)
;
throw
error
;
}
return
result
;
}
)
contentObtainManifest
:
Task
.
async
(
function
*
(
aContent
)
{
if
(
!
aContent
|
|
isXULBrowser
(
aContent
)
)
{
throw
new
TypeError
(
"
Invalid
input
.
Expected
a
DOM
Window
.
"
)
;
}
let
manifest
;
try
{
manifest
=
yield
fetchManifest
(
aContent
)
;
}
catch
(
err
)
{
throw
err
;
}
return
manifest
;
}
)
}
;
function
toError
(
aErrorClone
)
{
let
error
;
switch
(
aErrorClone
.
name
)
{
case
"
TypeError
"
:
error
=
new
TypeError
(
)
;
break
;
default
:
error
=
new
Error
(
)
;
}
Object
.
getOwnPropertyNames
(
aErrorClone
)
.
forEach
(
name
=
>
error
[
name
]
=
aErrorClone
[
name
]
)
;
return
error
;
}
function
isXULBrowser
(
aBrowser
)
{
if
(
!
aBrowser
|
|
!
aBrowser
.
namespaceURI
|
|
!
aBrowser
.
localName
)
{
return
false
;
}
const
XUL
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
return
(
aBrowser
.
namespaceURI
=
=
=
XUL
&
&
aBrowser
.
localName
=
=
=
"
browser
"
)
;
}
const
processResponse
=
Task
.
async
(
function
*
(
aResp
aContentWindow
)
{
const
badStatus
=
aResp
.
status
<
200
|
|
aResp
.
status
>
=
300
;
if
(
aResp
.
type
=
=
=
"
error
"
|
|
badStatus
)
{
const
msg
=
Fetch
error
:
{
aResp
.
status
}
-
{
aResp
.
statusText
}
at
{
aResp
.
url
}
;
throw
new
Error
(
msg
)
;
}
const
text
=
yield
aResp
.
text
(
)
;
const
args
=
{
jsonText
:
text
manifestURL
:
aResp
.
url
docURL
:
aContentWindow
.
location
.
href
}
;
const
manifest
=
ManifestProcessor
.
process
(
args
)
;
return
manifest
;
}
)
;
const
fetchManifest
=
Task
.
async
(
function
*
(
aWindow
)
{
if
(
!
aWindow
|
|
aWindow
.
top
!
=
=
aWindow
)
{
let
msg
=
"
Window
must
be
a
top
-
level
browsing
context
.
"
;
throw
new
Error
(
msg
)
;
}
const
elem
=
aWindow
.
document
.
querySelector
(
"
link
[
rel
~
=
'
manifest
'
]
"
)
;
if
(
!
elem
|
|
!
elem
.
getAttribute
(
"
href
"
)
)
{
let
msg
=
No
manifest
to
fetch
at
{
aWindow
.
location
}
;
throw
new
Error
(
msg
)
;
}
const
manifestURL
=
new
aWindow
.
URL
(
elem
.
href
elem
.
baseURI
)
;
const
reqInit
=
{
mode
:
"
cors
"
}
;
if
(
elem
.
crossOrigin
=
=
=
"
use
-
credentials
"
)
{
reqInit
.
credentials
=
"
include
"
;
}
const
request
=
new
aWindow
.
Request
(
manifestURL
reqInit
)
;
request
.
overrideContentPolicyType
(
Ci
.
nsIContentPolicy
.
TYPE_WEB_MANIFEST
)
;
let
response
;
try
{
response
=
yield
aWindow
.
fetch
(
request
)
;
}
catch
(
err
)
{
throw
err
;
}
const
manifest
=
yield
processResponse
(
response
aWindow
)
;
return
manifest
;
}
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
ManifestObtainer
"
]
;
