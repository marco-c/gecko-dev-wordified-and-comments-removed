#
include
"
mozilla
/
dom
/
SVGAElement
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
dom
/
BindContext
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
SVGAElementBinding
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIURI
.
h
"
NS_IMPL_NS_NEW_SVG_ELEMENT
(
A
)
namespace
mozilla
:
:
dom
{
JSObject
*
SVGAElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
SVGAElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
SVGElement
:
:
StringInfo
SVGAElement
:
:
sStringInfo
[
3
]
=
{
{
nsGkAtoms
:
:
href
kNameSpaceID_None
true
}
{
nsGkAtoms
:
:
href
kNameSpaceID_XLink
true
}
{
nsGkAtoms
:
:
target
kNameSpaceID_None
true
}
}
;
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
SVGAElement
)
NS_INTERFACE_MAP_ENTRY
(
Link
)
NS_INTERFACE_MAP_END_INHERITING
(
SVGAElementBase
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
SVGAElement
SVGAElementBase
mRelList
)
NS_IMPL_ADDREF_INHERITED
(
SVGAElement
SVGAElementBase
)
NS_IMPL_RELEASE_INHERITED
(
SVGAElement
SVGAElementBase
)
SVGAElement
:
:
SVGAElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
SVGAElementBase
(
std
:
:
move
(
aNodeInfo
)
)
Link
(
this
)
{
}
already_AddRefed
<
DOMSVGAnimatedString
>
SVGAElement
:
:
Href
(
)
{
return
mStringAttributes
[
HREF
]
.
IsExplicitlySet
(
)
?
mStringAttributes
[
HREF
]
.
ToDOMAnimatedString
(
this
)
:
mStringAttributes
[
XLINK_HREF
]
.
ToDOMAnimatedString
(
this
)
;
}
void
SVGAElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
Element
:
:
GetEventTargetParent
(
aVisitor
)
;
GetEventTargetParentForLinks
(
aVisitor
)
;
}
nsresult
SVGAElement
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
return
PostHandleEventForLinks
(
aVisitor
)
;
}
NS_IMPL_ELEMENT_CLONE_WITH_INIT
(
SVGAElement
)
already_AddRefed
<
DOMSVGAnimatedString
>
SVGAElement
:
:
Target
(
)
{
return
mStringAttributes
[
TARGET
]
.
ToDOMAnimatedString
(
this
)
;
}
void
SVGAElement
:
:
GetDownload
(
nsAString
&
aDownload
)
{
GetAttr
(
nsGkAtoms
:
:
download
aDownload
)
;
}
void
SVGAElement
:
:
SetDownload
(
const
nsAString
&
aDownload
ErrorResult
&
rv
)
{
SetAttr
(
nsGkAtoms
:
:
download
aDownload
rv
)
;
}
void
SVGAElement
:
:
GetPing
(
nsAString
&
aPing
)
{
GetAttr
(
nsGkAtoms
:
:
ping
aPing
)
;
}
void
SVGAElement
:
:
SetPing
(
const
nsAString
&
aPing
ErrorResult
&
rv
)
{
SetAttr
(
nsGkAtoms
:
:
ping
aPing
rv
)
;
}
void
SVGAElement
:
:
GetRel
(
nsAString
&
aRel
)
{
GetAttr
(
nsGkAtoms
:
:
rel
aRel
)
;
}
void
SVGAElement
:
:
SetRel
(
const
nsAString
&
aRel
ErrorResult
&
rv
)
{
SetAttr
(
nsGkAtoms
:
:
rel
aRel
rv
)
;
}
void
SVGAElement
:
:
GetReferrerPolicy
(
nsAString
&
aPolicy
)
{
GetEnumAttr
(
nsGkAtoms
:
:
referrerpolicy
"
"
aPolicy
)
;
}
void
SVGAElement
:
:
SetReferrerPolicy
(
const
nsAString
&
aPolicy
mozilla
:
:
ErrorResult
&
rv
)
{
SetAttr
(
nsGkAtoms
:
:
referrerpolicy
aPolicy
rv
)
;
}
nsDOMTokenList
*
SVGAElement
:
:
RelList
(
)
{
if
(
!
mRelList
)
{
mRelList
=
new
nsDOMTokenList
(
this
nsGkAtoms
:
:
rel
sSupportedRelValues
)
;
}
return
mRelList
;
}
void
SVGAElement
:
:
GetHreflang
(
nsAString
&
aHreflang
)
{
GetAttr
(
nsGkAtoms
:
:
hreflang
aHreflang
)
;
}
void
SVGAElement
:
:
SetHreflang
(
const
nsAString
&
aHreflang
mozilla
:
:
ErrorResult
&
rv
)
{
SetAttr
(
nsGkAtoms
:
:
hreflang
aHreflang
rv
)
;
}
void
SVGAElement
:
:
GetType
(
nsAString
&
aType
)
{
GetAttr
(
nsGkAtoms
:
:
type
aType
)
;
}
void
SVGAElement
:
:
SetType
(
const
nsAString
&
aType
mozilla
:
:
ErrorResult
&
rv
)
{
SetAttr
(
nsGkAtoms
:
:
type
aType
rv
)
;
}
void
SVGAElement
:
:
GetText
(
nsAString
&
aText
mozilla
:
:
ErrorResult
&
rv
)
const
{
if
(
NS_WARN_IF
(
!
nsContentUtils
:
:
GetNodeTextContent
(
this
true
aText
fallible
)
)
)
{
rv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
}
void
SVGAElement
:
:
SetText
(
const
nsAString
&
aText
mozilla
:
:
ErrorResult
&
rv
)
{
rv
=
nsContentUtils
:
:
SetNodeTextContent
(
this
aText
false
)
;
}
nsresult
SVGAElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
Link
:
:
ResetLinkState
(
false
Link
:
:
ElementHasHref
(
)
)
;
nsresult
rv
=
SVGAElementBase
:
:
BindToTree
(
aContext
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
Document
*
doc
=
aContext
.
GetComposedDoc
(
)
)
{
doc
-
>
RegisterPendingLinkUpdate
(
this
)
;
}
return
NS_OK
;
}
void
SVGAElement
:
:
UnbindFromTree
(
bool
aNullParent
)
{
Link
:
:
ResetLinkState
(
false
Link
:
:
ElementHasHref
(
)
)
;
SVGAElementBase
:
:
UnbindFromTree
(
aNullParent
)
;
}
int32_t
SVGAElement
:
:
TabIndexDefault
(
)
{
return
0
;
}
bool
SVGAElement
:
:
IsFocusableInternal
(
int32_t
*
aTabIndex
bool
aWithMouse
)
{
bool
isFocusable
=
false
;
if
(
IsSVGFocusable
(
&
isFocusable
aTabIndex
)
)
{
return
isFocusable
;
}
if
(
!
OwnerDoc
(
)
-
>
LinkHandlingEnabled
(
)
)
{
return
false
;
}
if
(
nsContentUtils
:
:
IsNodeInEditableRegion
(
this
)
)
{
if
(
aTabIndex
)
{
*
aTabIndex
=
-
1
;
}
return
false
;
}
if
(
GetTabIndexAttrValue
(
)
.
isNothing
(
)
)
{
if
(
!
IsLink
(
)
)
{
if
(
aTabIndex
)
{
*
aTabIndex
=
-
1
;
}
return
false
;
}
}
if
(
aTabIndex
&
&
(
sTabFocusModel
&
eTabFocus_linksMask
)
=
=
0
)
{
*
aTabIndex
=
-
1
;
}
return
true
;
}
bool
SVGAElement
:
:
HasHref
(
)
const
{
return
mStringAttributes
[
HREF
]
.
IsExplicitlySet
(
)
|
|
mStringAttributes
[
XLINK_HREF
]
.
IsExplicitlySet
(
)
;
}
already_AddRefed
<
nsIURI
>
SVGAElement
:
:
GetHrefURI
(
)
const
{
bool
useBareHref
=
mStringAttributes
[
HREF
]
.
IsExplicitlySet
(
)
;
if
(
useBareHref
|
|
mStringAttributes
[
XLINK_HREF
]
.
IsExplicitlySet
(
)
)
{
nsAutoString
str
;
const
uint8_t
idx
=
useBareHref
?
HREF
:
XLINK_HREF
;
mStringAttributes
[
idx
]
.
GetAnimValue
(
str
this
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
uri
)
str
OwnerDoc
(
)
GetBaseURI
(
)
)
;
return
uri
.
forget
(
)
;
}
return
nullptr
;
}
void
SVGAElement
:
:
GetLinkTarget
(
nsAString
&
aTarget
)
{
mStringAttributes
[
TARGET
]
.
GetAnimValue
(
aTarget
this
)
;
if
(
aTarget
.
IsEmpty
(
)
)
{
static
Element
:
:
AttrValuesArray
sShowVals
[
]
=
{
nsGkAtoms
:
:
_new
nsGkAtoms
:
:
replace
nullptr
}
;
switch
(
FindAttrValueIn
(
kNameSpaceID_XLink
nsGkAtoms
:
:
show
sShowVals
eCaseMatters
)
)
{
case
0
:
aTarget
.
AssignLiteral
(
"
_blank
"
)
;
return
;
case
1
:
return
;
}
Document
*
ownerDoc
=
OwnerDoc
(
)
;
if
(
ownerDoc
)
{
ownerDoc
-
>
GetBaseTarget
(
aTarget
)
;
}
}
}
ElementState
SVGAElement
:
:
IntrinsicState
(
)
const
{
return
Link
:
:
LinkState
(
)
|
SVGAElementBase
:
:
IntrinsicState
(
)
;
}
void
SVGAElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
if
(
aName
=
=
nsGkAtoms
:
:
href
&
&
(
aNameSpaceID
=
=
kNameSpaceID_XLink
|
|
aNameSpaceID
=
=
kNameSpaceID_None
)
)
{
Link
:
:
ResetLinkState
(
aNotify
aValue
|
|
Link
:
:
ElementHasHref
(
)
)
;
}
return
SVGAElementBase
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aMaybeScriptedPrincipal
aNotify
)
;
}
SVGElement
:
:
StringAttributesInfo
SVGAElement
:
:
GetStringInfo
(
)
{
return
StringAttributesInfo
(
mStringAttributes
sStringInfo
ArrayLength
(
sStringInfo
)
)
;
}
}
