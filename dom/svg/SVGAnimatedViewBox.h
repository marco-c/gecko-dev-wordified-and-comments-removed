#
ifndef
DOM_SVG_SVGANIMATEDVIEWBOX_H_
#
define
DOM_SVG_SVGANIMATEDVIEWBOX_H_
#
include
"
SVGAttrTearoffTable
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
SMILAttr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
SVGAnimatedRect
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsError
.
h
"
namespace
mozilla
{
class
SMILValue
;
namespace
dom
{
class
SVGRect
;
class
SVGAnimationElement
;
class
SVGElement
;
}
struct
SVGViewBox
{
float
x
y
;
float
width
height
;
bool
none
;
SVGViewBox
(
)
:
x
(
0
.
0
)
y
(
0
.
0
)
width
(
0
.
0
)
height
(
0
.
0
)
none
(
true
)
{
}
SVGViewBox
(
float
aX
float
aY
float
aWidth
float
aHeight
)
:
x
(
aX
)
y
(
aY
)
width
(
aWidth
)
height
(
aHeight
)
none
(
false
)
{
}
bool
operator
=
=
(
const
SVGViewBox
&
aOther
)
const
;
SVGViewBox
operator
*
(
const
float
m
)
const
{
return
SVGViewBox
(
x
*
m
y
*
m
width
*
m
height
*
m
)
;
}
bool
IsFinite
(
)
const
{
if
(
none
)
{
return
true
;
}
return
std
:
:
isfinite
(
x
)
&
&
std
:
:
isfinite
(
y
)
&
&
std
:
:
isfinite
(
width
)
&
&
std
:
:
isfinite
(
height
)
;
}
bool
IsEmpty
(
)
const
{
return
!
none
&
&
(
width
<
=
.
0f
|
|
height
<
=
.
0f
)
;
}
bool
IsValid
(
)
const
{
return
IsFinite
(
)
&
&
!
IsEmpty
(
)
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
stream
const
SVGViewBox
&
aViewBox
)
{
if
(
aViewBox
.
none
)
{
return
stream
<
<
"
(
none
)
"
;
}
return
stream
<
<
"
(
x
=
"
<
<
aViewBox
.
x
<
<
"
y
=
"
<
<
aViewBox
.
y
<
<
"
w
=
"
<
<
aViewBox
.
width
<
<
"
h
=
"
<
<
aViewBox
.
height
<
<
'
)
'
;
}
static
nsresult
FromString
(
const
nsAString
&
aStr
SVGViewBox
*
aViewBox
)
;
}
;
class
SVGAnimatedViewBox
{
public
:
friend
class
AutoChangeViewBoxNotifier
;
using
SVGElement
=
dom
:
:
SVGElement
;
SVGAnimatedViewBox
&
operator
=
(
const
SVGAnimatedViewBox
&
aOther
)
{
mBaseVal
=
aOther
.
mBaseVal
;
if
(
aOther
.
mAnimVal
)
{
mAnimVal
=
MakeUnique
<
SVGViewBox
>
(
*
aOther
.
mAnimVal
)
;
}
mHasBaseVal
=
aOther
.
mHasBaseVal
;
return
*
this
;
}
void
Init
(
)
;
bool
HasRect
(
)
const
;
bool
IsExplicitlySet
(
)
const
{
if
(
mAnimVal
|
|
mHasBaseVal
)
{
return
GetAnimValue
(
)
.
IsValid
(
)
;
}
return
false
;
}
const
SVGViewBox
&
GetBaseValue
(
)
const
{
return
mBaseVal
;
}
void
SetBaseValue
(
const
SVGViewBox
&
aRect
SVGElement
*
aSVGElement
)
;
const
SVGViewBox
&
GetAnimValue
(
)
const
{
return
mAnimVal
?
*
mAnimVal
:
mBaseVal
;
}
void
SetAnimValue
(
const
SVGViewBox
&
aRect
SVGElement
*
aSVGElement
)
;
nsresult
SetBaseValueString
(
const
nsAString
&
aValue
SVGElement
*
aSVGElement
bool
aDoSetAttr
)
;
void
GetBaseValueString
(
nsAString
&
aValue
)
const
;
already_AddRefed
<
dom
:
:
SVGAnimatedRect
>
ToSVGAnimatedRect
(
SVGElement
*
aSVGElement
)
;
already_AddRefed
<
dom
:
:
SVGRect
>
ToDOMBaseVal
(
SVGElement
*
aSVGElement
)
;
already_AddRefed
<
dom
:
:
SVGRect
>
ToDOMAnimVal
(
SVGElement
*
aSVGElement
)
;
UniquePtr
<
SMILAttr
>
ToSMILAttr
(
SVGElement
*
aSVGElement
)
;
private
:
SVGViewBox
mBaseVal
;
UniquePtr
<
SVGViewBox
>
mAnimVal
;
bool
mHasBaseVal
;
public
:
struct
SMILViewBox
:
public
SMILAttr
{
public
:
SMILViewBox
(
SVGAnimatedViewBox
*
aVal
SVGElement
*
aSVGElement
)
:
mVal
(
aVal
)
mSVGElement
(
aSVGElement
)
{
}
SVGAnimatedViewBox
*
mVal
;
SVGElement
*
mSVGElement
;
nsresult
ValueFromString
(
const
nsAString
&
aStr
const
dom
:
:
SVGAnimationElement
*
aSrcElement
SMILValue
&
aValue
bool
&
aPreventCachingOfSandwich
)
const
override
;
SMILValue
GetBaseValue
(
)
const
override
;
void
ClearAnimValue
(
)
override
;
nsresult
SetAnimValue
(
const
SMILValue
&
aValue
)
override
;
}
;
static
SVGAttrTearoffTable
<
SVGAnimatedViewBox
dom
:
:
SVGAnimatedRect
>
sSVGAnimatedRectTearoffTable
;
}
;
}
#
endif
