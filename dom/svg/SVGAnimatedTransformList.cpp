#
include
"
SVGAnimatedTransformList
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
SVGAnimationElement
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
SMILValue
.
h
"
#
include
"
mozilla
/
SVGContentUtils
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
DOMSVGAnimatedTransformList
.
h
"
#
include
"
SVGTransform
.
h
"
#
include
"
SVGTransformListSMILType
.
h
"
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
dom
:
:
SVGTransform_Binding
;
namespace
mozilla
{
nsresult
SVGAnimatedTransformList
:
:
SetBaseValueString
(
const
nsAString
&
aValue
SVGElement
*
aSVGElement
)
{
SVGTransformList
newBaseValue
;
nsresult
rv
=
newBaseValue
.
SetValueFromString
(
aValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
SetBaseValue
(
newBaseValue
aSVGElement
)
;
}
nsresult
SVGAnimatedTransformList
:
:
SetBaseValue
(
const
SVGTransformList
&
aValue
SVGElement
*
aSVGElement
)
{
DOMSVGAnimatedTransformList
*
domWrapper
=
DOMSVGAnimatedTransformList
:
:
GetDOMWrapperIfExists
(
this
)
;
if
(
domWrapper
)
{
domWrapper
-
>
InternalBaseValListWillChangeLengthTo
(
aValue
.
Length
(
)
)
;
}
bool
hadTransform
=
HasTransform
(
)
;
nsresult
rv
=
mBaseVal
.
CopyFrom
(
aValue
)
;
if
(
NS_FAILED
(
rv
)
&
&
domWrapper
)
{
domWrapper
-
>
InternalBaseValListWillChangeLengthTo
(
mBaseVal
.
Length
(
)
)
;
}
else
{
mIsAttrSet
=
true
;
mRequiresFrameReconstruction
=
aSVGElement
-
>
GetPrimaryFrame
(
)
&
&
!
hadTransform
;
}
return
rv
;
}
void
SVGAnimatedTransformList
:
:
ClearBaseValue
(
)
{
mRequiresFrameReconstruction
=
!
HasTransform
(
)
;
DOMSVGAnimatedTransformList
*
domWrapper
=
DOMSVGAnimatedTransformList
:
:
GetDOMWrapperIfExists
(
this
)
;
if
(
domWrapper
)
{
domWrapper
-
>
InternalBaseValListWillChangeLengthTo
(
0
)
;
}
mBaseVal
.
Clear
(
)
;
mIsAttrSet
=
false
;
}
nsresult
SVGAnimatedTransformList
:
:
SetAnimValue
(
const
SVGTransformList
&
aValue
SVGElement
*
aElement
)
{
bool
prevSet
=
HasTransform
(
)
|
|
aElement
-
>
GetAnimateMotionTransform
(
)
;
DOMSVGAnimatedTransformList
*
domWrapper
=
DOMSVGAnimatedTransformList
:
:
GetDOMWrapperIfExists
(
this
)
;
if
(
domWrapper
)
{
domWrapper
-
>
InternalAnimValListWillChangeLengthTo
(
aValue
.
Length
(
)
)
;
}
if
(
!
mAnimVal
)
{
mAnimVal
=
new
SVGTransformList
(
)
;
}
nsresult
rv
=
mAnimVal
-
>
CopyFrom
(
aValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
ClearAnimValue
(
aElement
)
;
return
rv
;
}
int32_t
modType
;
if
(
prevSet
)
{
modType
=
MutationEvent_Binding
:
:
MODIFICATION
;
}
else
{
modType
=
MutationEvent_Binding
:
:
ADDITION
;
}
aElement
-
>
DidAnimateTransformList
(
modType
)
;
return
NS_OK
;
}
void
SVGAnimatedTransformList
:
:
ClearAnimValue
(
SVGElement
*
aElement
)
{
DOMSVGAnimatedTransformList
*
domWrapper
=
DOMSVGAnimatedTransformList
:
:
GetDOMWrapperIfExists
(
this
)
;
if
(
domWrapper
)
{
domWrapper
-
>
InternalAnimValListWillChangeLengthTo
(
mBaseVal
.
Length
(
)
)
;
}
mAnimVal
=
nullptr
;
int32_t
modType
;
if
(
HasTransform
(
)
|
|
aElement
-
>
GetAnimateMotionTransform
(
)
)
{
modType
=
MutationEvent_Binding
:
:
MODIFICATION
;
}
else
{
modType
=
MutationEvent_Binding
:
:
REMOVAL
;
}
aElement
-
>
DidAnimateTransformList
(
modType
)
;
}
bool
SVGAnimatedTransformList
:
:
IsExplicitlySet
(
)
const
{
return
mIsAttrSet
|
|
!
mBaseVal
.
IsEmpty
(
)
|
|
mAnimVal
;
}
UniquePtr
<
nsISMILAttr
>
SVGAnimatedTransformList
:
:
ToSMILAttr
(
SVGElement
*
aSVGElement
)
{
return
MakeUnique
<
SMILAnimatedTransformList
>
(
this
aSVGElement
)
;
}
nsresult
SVGAnimatedTransformList
:
:
SMILAnimatedTransformList
:
:
ValueFromString
(
const
nsAString
&
aStr
const
dom
:
:
SVGAnimationElement
*
aSrcElement
SMILValue
&
aValue
bool
&
aPreventCachingOfSandwich
)
const
{
NS_ENSURE_TRUE
(
aSrcElement
NS_ERROR_FAILURE
)
;
MOZ_ASSERT
(
aValue
.
IsNull
(
)
"
aValue
should
have
been
cleared
before
calling
ValueFromString
"
)
;
const
nsAttrValue
*
typeAttr
=
aSrcElement
-
>
GetParsedAttr
(
nsGkAtoms
:
:
type
)
;
const
nsAtom
*
transformType
=
nsGkAtoms
:
:
translate
;
if
(
typeAttr
)
{
if
(
typeAttr
-
>
Type
(
)
!
=
nsAttrValue
:
:
eAtom
)
{
return
NS_ERROR_FAILURE
;
}
transformType
=
typeAttr
-
>
GetAtomValue
(
)
;
}
ParseValue
(
aStr
transformType
aValue
)
;
aPreventCachingOfSandwich
=
false
;
return
aValue
.
IsNull
(
)
?
NS_ERROR_FAILURE
:
NS_OK
;
}
void
SVGAnimatedTransformList
:
:
SMILAnimatedTransformList
:
:
ParseValue
(
const
nsAString
&
aSpec
const
nsAtom
*
aTransformType
SMILValue
&
aResult
)
{
MOZ_ASSERT
(
aResult
.
IsNull
(
)
"
Unexpected
type
for
SMIL
value
"
)
;
static_assert
(
SVGTransformSMILData
:
:
NUM_SIMPLE_PARAMS
=
=
3
"
nsSVGSMILTransform
constructor
should
be
expecting
array
"
"
with
3
params
"
)
;
float
params
[
3
]
=
{
0
.
f
}
;
int32_t
numParsed
=
ParseParameterList
(
aSpec
params
3
)
;
uint16_t
transformType
;
if
(
aTransformType
=
=
nsGkAtoms
:
:
translate
)
{
if
(
numParsed
!
=
1
&
&
numParsed
!
=
2
)
return
;
transformType
=
SVG_TRANSFORM_TRANSLATE
;
}
else
if
(
aTransformType
=
=
nsGkAtoms
:
:
scale
)
{
if
(
numParsed
!
=
1
&
&
numParsed
!
=
2
)
return
;
if
(
numParsed
=
=
1
)
{
params
[
1
]
=
params
[
0
]
;
}
transformType
=
SVG_TRANSFORM_SCALE
;
}
else
if
(
aTransformType
=
=
nsGkAtoms
:
:
rotate
)
{
if
(
numParsed
!
=
1
&
&
numParsed
!
=
3
)
return
;
transformType
=
SVG_TRANSFORM_ROTATE
;
}
else
if
(
aTransformType
=
=
nsGkAtoms
:
:
skewX
)
{
if
(
numParsed
!
=
1
)
return
;
transformType
=
SVG_TRANSFORM_SKEWX
;
}
else
if
(
aTransformType
=
=
nsGkAtoms
:
:
skewY
)
{
if
(
numParsed
!
=
1
)
return
;
transformType
=
SVG_TRANSFORM_SKEWY
;
}
else
{
return
;
}
SMILValue
val
(
SVGTransformListSMILType
:
:
Singleton
(
)
)
;
SVGTransformSMILData
transform
(
transformType
params
)
;
if
(
NS_FAILED
(
SVGTransformListSMILType
:
:
AppendTransform
(
transform
val
)
)
)
{
return
;
}
aResult
=
std
:
:
move
(
val
)
;
}
int32_t
SVGAnimatedTransformList
:
:
SMILAnimatedTransformList
:
:
ParseParameterList
(
const
nsAString
&
aSpec
float
*
aVars
int32_t
aNVars
)
{
nsCharSeparatedTokenizerTemplate
<
nsContentUtils
:
:
IsHTMLWhitespace
>
tokenizer
(
aSpec
'
'
nsCharSeparatedTokenizer
:
:
SEPARATOR_OPTIONAL
)
;
int
numArgsFound
=
0
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
float
f
;
if
(
!
SVGContentUtils
:
:
ParseNumber
(
tokenizer
.
nextToken
(
)
f
)
)
{
return
-
1
;
}
if
(
numArgsFound
<
aNVars
)
{
aVars
[
numArgsFound
]
=
f
;
}
numArgsFound
+
+
;
}
return
numArgsFound
;
}
SMILValue
SVGAnimatedTransformList
:
:
SMILAnimatedTransformList
:
:
GetBaseValue
(
)
const
{
SMILValue
val
(
SVGTransformListSMILType
:
:
Singleton
(
)
)
;
if
(
!
SVGTransformListSMILType
:
:
AppendTransforms
(
mVal
-
>
mBaseVal
val
)
)
{
val
=
SMILValue
(
)
;
}
return
val
;
}
nsresult
SVGAnimatedTransformList
:
:
SMILAnimatedTransformList
:
:
SetAnimValue
(
const
SMILValue
&
aNewAnimValue
)
{
MOZ_ASSERT
(
aNewAnimValue
.
mType
=
=
SVGTransformListSMILType
:
:
Singleton
(
)
"
Unexpected
type
to
assign
animated
value
"
)
;
SVGTransformList
animVal
;
if
(
!
SVGTransformListSMILType
:
:
GetTransforms
(
aNewAnimValue
animVal
.
mItems
)
)
{
return
NS_ERROR_FAILURE
;
}
return
mVal
-
>
SetAnimValue
(
animVal
mElement
)
;
}
void
SVGAnimatedTransformList
:
:
SMILAnimatedTransformList
:
:
ClearAnimValue
(
)
{
if
(
mVal
-
>
mAnimVal
)
{
mVal
-
>
ClearAnimValue
(
mElement
)
;
}
}
}
