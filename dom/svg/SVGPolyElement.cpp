#
include
"
SVGPolyElement
.
h
"
#
include
"
DOMSVGPointList
.
h
"
#
include
"
SVGContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
SVGAnimatedLength
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
:
:
dom
{
SVGPolyElement
:
:
SVGPolyElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
SVGPolyElementBase
(
std
:
:
move
(
aNodeInfo
)
)
{
}
already_AddRefed
<
DOMSVGPointList
>
SVGPolyElement
:
:
Points
(
)
{
return
DOMSVGPointList
:
:
GetDOMWrapper
(
mPoints
.
GetBaseValKey
(
)
this
)
;
}
already_AddRefed
<
DOMSVGPointList
>
SVGPolyElement
:
:
AnimatedPoints
(
)
{
return
DOMSVGPointList
:
:
GetDOMWrapper
(
mPoints
.
GetAnimValKey
(
)
this
)
;
}
bool
SVGPolyElement
:
:
HasValidDimensions
(
)
const
{
return
!
mPoints
.
GetAnimValue
(
)
.
IsEmpty
(
)
;
}
bool
SVGPolyElement
:
:
AttributeDefinesGeometry
(
const
nsAtom
*
aName
)
{
return
aName
=
=
nsGkAtoms
:
:
points
|
|
aName
=
=
nsGkAtoms
:
:
pathLength
;
}
void
SVGPolyElement
:
:
GetMarkPoints
(
nsTArray
<
SVGMark
>
*
aMarks
)
{
const
SVGPointList
&
points
=
mPoints
.
GetAnimValue
(
)
;
if
(
points
.
IsEmpty
(
)
)
{
return
;
}
float
zoom
=
UserSpaceMetrics
:
:
GetZoom
(
this
)
;
float
px
=
points
[
0
]
.
mX
*
zoom
py
=
points
[
0
]
.
mY
*
zoom
prevAngle
=
0
.
0f
;
if
(
!
(
std
:
:
isfinite
(
px
)
&
&
std
:
:
isfinite
(
py
)
)
)
{
return
;
}
aMarks
-
>
AppendElement
(
SVGMark
(
px
py
0
SVGMark
:
:
eStart
)
)
;
for
(
uint32_t
i
=
1
;
i
<
points
.
Length
(
)
;
+
+
i
)
{
float
x
=
points
[
i
]
.
mX
*
zoom
;
float
y
=
points
[
i
]
.
mY
*
zoom
;
if
(
!
(
std
:
:
isfinite
(
x
)
&
&
std
:
:
isfinite
(
y
)
)
)
{
aMarks
-
>
Clear
(
)
;
return
;
}
float
angle
=
std
:
:
atan2
(
y
-
py
x
-
px
)
;
if
(
i
=
=
1
)
{
aMarks
-
>
ElementAt
(
0
)
.
angle
=
angle
;
}
else
{
aMarks
-
>
LastElement
(
)
.
angle
=
SVGContentUtils
:
:
AngleBisect
(
prevAngle
angle
)
;
}
aMarks
-
>
AppendElement
(
SVGMark
(
x
y
0
SVGMark
:
:
eMid
)
)
;
prevAngle
=
angle
;
px
=
x
;
py
=
y
;
}
aMarks
-
>
LastElement
(
)
.
angle
=
prevAngle
;
aMarks
-
>
LastElement
(
)
.
type
=
SVGMark
:
:
eEnd
;
}
bool
SVGPolyElement
:
:
GetGeometryBounds
(
Rect
*
aBounds
const
StrokeOptions
&
aStrokeOptions
const
Matrix
&
aToBoundsSpace
const
Matrix
*
aToNonScalingStrokeSpace
)
{
const
SVGPointList
&
points
=
mPoints
.
GetAnimValue
(
)
;
if
(
points
.
IsEmpty
(
)
)
{
aBounds
-
>
SetEmpty
(
)
;
return
true
;
}
if
(
aStrokeOptions
.
mLineWidth
>
0
|
|
aToNonScalingStrokeSpace
)
{
return
false
;
}
float
zoom
=
UserSpaceMetrics
:
:
GetZoom
(
this
)
;
if
(
aToBoundsSpace
.
IsRectilinear
(
)
)
{
Rect
bounds
(
Point
(
points
[
0
]
)
*
zoom
Size
(
)
)
;
for
(
uint32_t
i
=
1
;
i
<
points
.
Length
(
)
;
+
+
i
)
{
bounds
.
ExpandToEnclose
(
Point
(
points
[
i
]
)
*
zoom
)
;
}
*
aBounds
=
aToBoundsSpace
.
TransformBounds
(
bounds
)
;
}
else
{
*
aBounds
=
Rect
(
aToBoundsSpace
.
TransformPoint
(
Point
(
points
[
0
]
)
*
zoom
)
Size
(
)
)
;
for
(
uint32_t
i
=
1
;
i
<
points
.
Length
(
)
;
+
+
i
)
{
aBounds
-
>
ExpandToEnclose
(
aToBoundsSpace
.
TransformPoint
(
Point
(
points
[
i
]
)
*
zoom
)
)
;
}
}
return
aBounds
-
>
IsFinite
(
)
;
}
}
