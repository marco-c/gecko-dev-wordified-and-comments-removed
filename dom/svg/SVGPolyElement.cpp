#
include
"
SVGPolyElement
.
h
"
#
include
"
DOMSVGPointList
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
SVGContentUtils
.
h
"
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
dom
{
SVGPolyElement
:
:
SVGPolyElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
SVGPolyElementBase
(
std
:
:
move
(
aNodeInfo
)
)
{
}
SVGPolyElement
:
:
~
SVGPolyElement
(
)
{
}
already_AddRefed
<
DOMSVGPointList
>
SVGPolyElement
:
:
Points
(
)
{
void
*
key
=
mPoints
.
GetBaseValKey
(
)
;
RefPtr
<
DOMSVGPointList
>
points
=
DOMSVGPointList
:
:
GetDOMWrapper
(
key
this
false
)
;
return
points
.
forget
(
)
;
}
already_AddRefed
<
DOMSVGPointList
>
SVGPolyElement
:
:
AnimatedPoints
(
)
{
void
*
key
=
mPoints
.
GetAnimValKey
(
)
;
RefPtr
<
DOMSVGPointList
>
points
=
DOMSVGPointList
:
:
GetDOMWrapper
(
key
this
true
)
;
return
points
.
forget
(
)
;
}
NS_IMETHODIMP_
(
bool
)
SVGPolyElement
:
:
IsAttributeMapped
(
const
nsAtom
*
name
)
const
{
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
sMarkersMap
}
;
return
FindAttributeDependence
(
name
map
)
|
|
SVGPolyElementBase
:
:
IsAttributeMapped
(
name
)
;
}
bool
SVGPolyElement
:
:
HasValidDimensions
(
)
const
{
return
!
mPoints
.
GetAnimValue
(
)
.
IsEmpty
(
)
;
}
bool
SVGPolyElement
:
:
AttributeDefinesGeometry
(
const
nsAtom
*
aName
)
{
if
(
aName
=
=
nsGkAtoms
:
:
points
)
return
true
;
return
false
;
}
void
SVGPolyElement
:
:
GetMarkPoints
(
nsTArray
<
SVGMark
>
*
aMarks
)
{
const
SVGPointList
&
points
=
mPoints
.
GetAnimValue
(
)
;
if
(
!
points
.
Length
(
)
)
return
;
float
px
=
points
[
0
]
.
mX
py
=
points
[
0
]
.
mY
prevAngle
=
0
.
0
;
aMarks
-
>
AppendElement
(
SVGMark
(
px
py
0
SVGMark
:
:
eStart
)
)
;
for
(
uint32_t
i
=
1
;
i
<
points
.
Length
(
)
;
+
+
i
)
{
float
x
=
points
[
i
]
.
mX
;
float
y
=
points
[
i
]
.
mY
;
float
angle
=
atan2
(
y
-
py
x
-
px
)
;
if
(
i
=
=
1
)
{
aMarks
-
>
ElementAt
(
0
)
.
angle
=
angle
;
}
else
{
aMarks
-
>
ElementAt
(
aMarks
-
>
Length
(
)
-
1
)
.
angle
=
SVGContentUtils
:
:
AngleBisect
(
prevAngle
angle
)
;
}
aMarks
-
>
AppendElement
(
SVGMark
(
x
y
0
SVGMark
:
:
eMid
)
)
;
prevAngle
=
angle
;
px
=
x
;
py
=
y
;
}
aMarks
-
>
LastElement
(
)
.
angle
=
prevAngle
;
aMarks
-
>
LastElement
(
)
.
type
=
SVGMark
:
:
eEnd
;
}
bool
SVGPolyElement
:
:
GetGeometryBounds
(
Rect
*
aBounds
const
StrokeOptions
&
aStrokeOptions
const
Matrix
&
aToBoundsSpace
const
Matrix
*
aToNonScalingStrokeSpace
)
{
const
SVGPointList
&
points
=
mPoints
.
GetAnimValue
(
)
;
if
(
!
points
.
Length
(
)
)
{
aBounds
-
>
SetEmpty
(
)
;
return
true
;
}
if
(
aStrokeOptions
.
mLineWidth
>
0
|
|
aToNonScalingStrokeSpace
)
{
return
false
;
}
if
(
aToBoundsSpace
.
IsRectilinear
(
)
)
{
Rect
bounds
(
points
[
0
]
Size
(
)
)
;
for
(
uint32_t
i
=
1
;
i
<
points
.
Length
(
)
;
+
+
i
)
{
bounds
.
ExpandToEnclose
(
points
[
i
]
)
;
}
*
aBounds
=
aToBoundsSpace
.
TransformBounds
(
bounds
)
;
}
else
{
*
aBounds
=
Rect
(
aToBoundsSpace
.
TransformPoint
(
points
[
0
]
)
Size
(
)
)
;
for
(
uint32_t
i
=
1
;
i
<
points
.
Length
(
)
;
+
+
i
)
{
aBounds
-
>
ExpandToEnclose
(
aToBoundsSpace
.
TransformPoint
(
points
[
i
]
)
)
;
}
}
return
true
;
}
}
}
