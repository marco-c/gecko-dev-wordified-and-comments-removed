#
ifndef
DOM_SVG_DOMSVGPATHSEGLIST_H_
#
define
DOM_SVG_DOMSVGPATHSEGLIST_H_
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
SVGPathData
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
SVGElement
.
h
"
namespace
mozilla
{
class
ErrorResult
;
class
SVGAnimatedPathSegList
;
namespace
dom
{
class
DOMSVGPathSeg
;
template
<
class
T
>
class
MOZ_RAII
AutoChangePathSegListNotifier
:
public
mozAutoDocUpdate
{
public
:
explicit
AutoChangePathSegListNotifier
(
T
*
aValue
)
:
mozAutoDocUpdate
(
aValue
-
>
Element
(
)
-
>
GetComposedDoc
(
)
true
)
mValue
(
aValue
)
{
MOZ_ASSERT
(
mValue
"
Expecting
non
-
null
value
"
)
;
mEmptyOrOldValue
=
mValue
-
>
Element
(
)
-
>
WillChangePathSegList
(
*
this
)
;
}
~
AutoChangePathSegListNotifier
(
)
{
mValue
-
>
Element
(
)
-
>
DidChangePathSegList
(
mEmptyOrOldValue
*
this
)
;
if
(
mValue
-
>
AttrIsAnimating
(
)
)
{
mValue
-
>
Element
(
)
-
>
AnimationNeedsResample
(
)
;
}
}
private
:
T
*
const
mValue
;
nsAttrValue
mEmptyOrOldValue
;
}
;
class
DOMSVGPathSegList
final
:
public
nsISupports
public
nsWrapperCache
{
template
<
class
T
>
friend
class
AutoChangePathSegListNotifier
;
friend
class
DOMSVGPathSeg
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
DOMSVGPathSegList
)
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
nsISupports
*
GetParentObject
(
)
{
return
static_cast
<
nsIContent
*
>
(
mElement
)
;
}
static
already_AddRefed
<
DOMSVGPathSegList
>
GetDOMWrapper
(
void
*
aList
dom
:
:
SVGElement
*
aElement
bool
aIsAnimValList
)
;
static
DOMSVGPathSegList
*
GetDOMWrapperIfExists
(
void
*
aList
)
;
uint32_t
LengthNoFlush
(
)
const
{
MOZ_ASSERT
(
mItems
.
Length
(
)
=
=
0
|
|
mItems
.
Length
(
)
=
=
InternalList
(
)
.
CountItems
(
)
"
DOM
wrapper
'
s
list
length
is
out
of
sync
"
)
;
return
mItems
.
Length
(
)
;
}
void
InternalListWillChangeTo
(
const
SVGPathData
&
aNewValue
)
;
bool
AttrIsAnimating
(
)
const
;
bool
AnimListMirrorsBaseList
(
)
const
;
uint32_t
NumberOfItems
(
)
const
{
if
(
IsAnimValList
(
)
)
{
Element
(
)
-
>
FlushAnimations
(
)
;
}
return
LengthNoFlush
(
)
;
}
void
Clear
(
ErrorResult
&
aError
)
;
already_AddRefed
<
DOMSVGPathSeg
>
Initialize
(
DOMSVGPathSeg
&
aNewItem
ErrorResult
&
aError
)
;
already_AddRefed
<
DOMSVGPathSeg
>
GetItem
(
uint32_t
index
ErrorResult
&
error
)
;
already_AddRefed
<
DOMSVGPathSeg
>
IndexedGetter
(
uint32_t
index
bool
&
found
ErrorResult
&
error
)
;
already_AddRefed
<
DOMSVGPathSeg
>
InsertItemBefore
(
DOMSVGPathSeg
&
aNewItem
uint32_t
aIndex
ErrorResult
&
aError
)
;
already_AddRefed
<
DOMSVGPathSeg
>
ReplaceItem
(
DOMSVGPathSeg
&
aNewItem
uint32_t
aIndex
ErrorResult
&
aError
)
;
already_AddRefed
<
DOMSVGPathSeg
>
RemoveItem
(
uint32_t
aIndex
ErrorResult
&
aError
)
;
already_AddRefed
<
DOMSVGPathSeg
>
AppendItem
(
DOMSVGPathSeg
&
aNewItem
ErrorResult
&
aError
)
{
return
InsertItemBefore
(
aNewItem
LengthNoFlush
(
)
aError
)
;
}
uint32_t
Length
(
)
const
{
return
NumberOfItems
(
)
;
}
private
:
DOMSVGPathSegList
(
dom
:
:
SVGElement
*
aElement
bool
aIsAnimValList
)
:
mElement
(
aElement
)
mIsAnimValList
(
aIsAnimValList
)
{
InternalListWillChangeTo
(
InternalList
(
)
)
;
}
~
DOMSVGPathSegList
(
)
;
dom
:
:
SVGElement
*
Element
(
)
const
{
return
mElement
.
get
(
)
;
}
bool
IsAnimValList
(
)
const
{
return
mIsAnimValList
;
}
SVGPathData
&
InternalList
(
)
const
;
SVGAnimatedPathSegList
&
InternalAList
(
)
const
;
already_AddRefed
<
DOMSVGPathSeg
>
GetItemAt
(
uint32_t
aIndex
)
;
void
MaybeInsertNullInAnimValListAt
(
uint32_t
aIndex
uint32_t
aInternalIndex
uint32_t
aArgCountForItem
)
;
void
MaybeRemoveItemFromAnimValListAt
(
uint32_t
aIndex
int32_t
aArgCountForItem
)
;
void
UpdateListIndicesFromIndex
(
uint32_t
aStartingIndex
int32_t
aInternalDataIndexDelta
)
;
DOMSVGPathSeg
*
&
ItemAt
(
uint32_t
aIndex
)
{
return
mItems
[
aIndex
]
.
mItem
;
}
void
RemoveFromTearoffTable
(
)
;
struct
ItemProxy
{
ItemProxy
(
)
:
mItem
(
nullptr
)
mInternalDataIndex
(
0
)
{
}
ItemProxy
(
DOMSVGPathSeg
*
aItem
uint32_t
aInternalDataIndex
)
:
mItem
(
aItem
)
mInternalDataIndex
(
aInternalDataIndex
)
{
}
DOMSVGPathSeg
*
mItem
;
uint32_t
mInternalDataIndex
;
}
;
FallibleTArray
<
ItemProxy
>
mItems
;
RefPtr
<
dom
:
:
SVGElement
>
mElement
;
bool
mIsAnimValList
;
}
;
}
}
#
endif
