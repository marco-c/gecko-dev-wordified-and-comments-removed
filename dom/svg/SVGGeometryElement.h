#
ifndef
mozilla_dom_SVGGeometryElement_h
#
define
mozilla_dom_SVGGeometryElement_h
#
include
"
mozilla
/
dom
/
SVGGraphicsElement
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
SVGAnimatedNumber
.
h
"
#
include
"
nsISVGPoint
.
h
"
namespace
mozilla
{
struct
SVGMark
{
enum
Type
{
eStart
eMid
eEnd
eTypeCount
}
;
float
x
y
angle
;
Type
type
;
SVGMark
(
float
aX
float
aY
float
aAngle
Type
aType
)
:
x
(
aX
)
y
(
aY
)
angle
(
aAngle
)
type
(
aType
)
{
}
}
;
namespace
dom
{
class
DOMSVGAnimatedNumber
;
typedef
mozilla
:
:
dom
:
:
SVGGraphicsElement
SVGGeometryElementBase
;
class
SVGGeometryElement
:
public
SVGGeometryElementBase
{
protected
:
typedef
mozilla
:
:
gfx
:
:
CapStyle
CapStyle
;
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
FillRule
FillRule
;
typedef
mozilla
:
:
gfx
:
:
Float
Float
;
typedef
mozilla
:
:
gfx
:
:
Matrix
Matrix
;
typedef
mozilla
:
:
gfx
:
:
Path
Path
;
typedef
mozilla
:
:
gfx
:
:
Point
Point
;
typedef
mozilla
:
:
gfx
:
:
PathBuilder
PathBuilder
;
typedef
mozilla
:
:
gfx
:
:
Rect
Rect
;
typedef
mozilla
:
:
gfx
:
:
StrokeOptions
StrokeOptions
;
public
:
explicit
SVGGeometryElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
;
virtual
nsresult
AfterSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
override
;
bool
IsNodeOfType
(
uint32_t
aFlags
)
const
override
;
void
ClearAnyCachedPath
(
)
final
{
mCachedPath
=
nullptr
;
}
virtual
bool
AttributeDefinesGeometry
(
const
nsAtom
*
aName
)
;
bool
GeometryDependsOnCoordCtx
(
)
;
virtual
bool
IsMarkable
(
)
;
virtual
void
GetMarkPoints
(
nsTArray
<
SVGMark
>
*
aMarks
)
;
virtual
bool
GetGeometryBounds
(
Rect
*
aBounds
const
StrokeOptions
&
aStrokeOptions
const
Matrix
&
aToBoundsSpace
const
Matrix
*
aToNonScalingStrokeSpace
=
nullptr
)
{
return
false
;
}
class
SimplePath
{
public
:
SimplePath
(
)
:
mX
(
0
.
0
)
mY
(
0
.
0
)
mWidthOrX2
(
0
.
0
)
mHeightOrY2
(
0
.
0
)
mType
(
NONE
)
{
}
bool
IsPath
(
)
const
{
return
mType
!
=
NONE
;
}
void
SetRect
(
Float
x
Float
y
Float
width
Float
height
)
{
mX
=
x
;
mY
=
y
;
mWidthOrX2
=
width
;
mHeightOrY2
=
height
;
mType
=
RECT
;
}
Rect
AsRect
(
)
const
{
MOZ_ASSERT
(
mType
=
=
RECT
)
;
return
Rect
(
mX
mY
mWidthOrX2
mHeightOrY2
)
;
}
bool
IsRect
(
)
const
{
return
mType
=
=
RECT
;
}
void
SetLine
(
Float
x1
Float
y1
Float
x2
Float
y2
)
{
mX
=
x1
;
mY
=
y1
;
mWidthOrX2
=
x2
;
mHeightOrY2
=
y2
;
mType
=
LINE
;
}
Point
Point1
(
)
const
{
MOZ_ASSERT
(
mType
=
=
LINE
)
;
return
Point
(
mX
mY
)
;
}
Point
Point2
(
)
const
{
MOZ_ASSERT
(
mType
=
=
LINE
)
;
return
Point
(
mWidthOrX2
mHeightOrY2
)
;
}
bool
IsLine
(
)
const
{
return
mType
=
=
LINE
;
}
void
Reset
(
)
{
mType
=
NONE
;
}
private
:
enum
Type
{
NONE
RECT
LINE
}
;
Float
mX
mY
mWidthOrX2
mHeightOrY2
;
Type
mType
;
}
;
virtual
void
GetAsSimplePath
(
SimplePath
*
aSimplePath
)
{
aSimplePath
-
>
Reset
(
)
;
}
virtual
already_AddRefed
<
Path
>
GetOrBuildPath
(
const
DrawTarget
*
aDrawTarget
FillRule
fillRule
)
;
virtual
already_AddRefed
<
Path
>
BuildPath
(
PathBuilder
*
aBuilder
)
=
0
;
virtual
already_AddRefed
<
Path
>
GetOrBuildPathForMeasuring
(
)
;
bool
IsGeometryChangedViaCSS
(
ComputedStyle
const
&
aNewStyle
ComputedStyle
const
&
aOldStyle
)
const
;
FillRule
GetFillRule
(
)
;
enum
PathLengthScaleForType
{
eForTextPath
eForStroking
}
;
float
GetPathLengthScale
(
PathLengthScaleForType
aFor
)
;
already_AddRefed
<
DOMSVGAnimatedNumber
>
PathLength
(
)
;
float
GetTotalLength
(
)
;
already_AddRefed
<
nsISVGPoint
>
GetPointAtLength
(
float
distance
ErrorResult
&
rv
)
;
protected
:
virtual
NumberAttributesInfo
GetNumberInfo
(
)
override
;
SVGAnimatedNumber
mPathLength
;
static
NumberInfo
sNumberInfo
;
mutable
RefPtr
<
Path
>
mCachedPath
;
}
;
}
}
#
endif
