#
ifndef
mozilla_dom_SVGGeometryProperty_SVGGeometryProperty_h
#
define
mozilla_dom_SVGGeometryProperty_SVGGeometryProperty_h
#
include
"
mozilla
/
dom
/
SVGElement
.
h
"
#
include
"
ComputedStyle
.
h
"
#
include
"
SVGAnimatedLength
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsSVGImageFrame
.
h
"
#
include
<
type_traits
>
namespace
mozilla
{
namespace
dom
{
namespace
SVGGeometryProperty
{
namespace
ResolverTypes
{
struct
LengthPercentNoAuto
{
}
;
struct
LengthPercentRXY
{
}
;
struct
LengthPercentWidthHeight
{
}
;
}
namespace
Tags
{
#
define
SVGGEOMETRYPROPERTY_GENERATETAG
(
tagName
resolver
direction
\
styleStruct
)
\
struct
tagName
{
\
using
ResolverType
=
ResolverTypes
:
:
resolver
;
\
constexpr
static
auto
CtxDirection
=
SVGContentUtils
:
:
direction
;
\
constexpr
static
auto
Getter
=
&
styleStruct
:
:
m
#
#
tagName
;
\
}
SVGGEOMETRYPROPERTY_GENERATETAG
(
X
LengthPercentNoAuto
X
nsStyleSVGReset
)
;
SVGGEOMETRYPROPERTY_GENERATETAG
(
Y
LengthPercentNoAuto
Y
nsStyleSVGReset
)
;
SVGGEOMETRYPROPERTY_GENERATETAG
(
Cx
LengthPercentNoAuto
X
nsStyleSVGReset
)
;
SVGGEOMETRYPROPERTY_GENERATETAG
(
Cy
LengthPercentNoAuto
Y
nsStyleSVGReset
)
;
SVGGEOMETRYPROPERTY_GENERATETAG
(
R
LengthPercentNoAuto
XY
nsStyleSVGReset
)
;
#
undef
SVGGEOMETRYPROPERTY_GENERATETAG
struct
Height
;
struct
Width
{
using
ResolverType
=
ResolverTypes
:
:
LengthPercentWidthHeight
;
constexpr
static
auto
CtxDirection
=
SVGContentUtils
:
:
X
;
constexpr
static
auto
Getter
=
&
nsStylePosition
:
:
mWidth
;
constexpr
static
auto
SizeGetter
=
&
gfx
:
:
Size
:
:
width
;
using
CounterPart
=
Height
;
}
;
struct
Height
{
using
ResolverType
=
ResolverTypes
:
:
LengthPercentWidthHeight
;
constexpr
static
auto
CtxDirection
=
SVGContentUtils
:
:
Y
;
constexpr
static
auto
Getter
=
&
nsStylePosition
:
:
mHeight
;
constexpr
static
auto
SizeGetter
=
&
gfx
:
:
Size
:
:
height
;
using
CounterPart
=
Width
;
}
;
struct
Ry
;
struct
Rx
{
using
ResolverType
=
ResolverTypes
:
:
LengthPercentRXY
;
constexpr
static
auto
CtxDirection
=
SVGContentUtils
:
:
X
;
constexpr
static
auto
Getter
=
&
nsStyleSVGReset
:
:
mRx
;
using
CounterPart
=
Ry
;
}
;
struct
Ry
{
using
ResolverType
=
ResolverTypes
:
:
LengthPercentRXY
;
constexpr
static
auto
CtxDirection
=
SVGContentUtils
:
:
Y
;
constexpr
static
auto
Getter
=
&
nsStyleSVGReset
:
:
mRy
;
using
CounterPart
=
Rx
;
}
;
}
namespace
details
{
template
<
class
T
>
using
AlwaysFloat
=
float
;
using
dummy
=
int
[
]
;
using
CtxDirectionType
=
decltype
(
SVGContentUtils
:
:
X
)
;
template
<
CtxDirectionType
CTD
>
float
ResolvePureLengthPercentage
(
SVGElement
*
aElement
const
LengthPercentage
&
aLP
)
{
return
aLP
.
ResolveToCSSPixelsWith
(
[
&
]
{
return
CSSCoord
{
SVGElementMetrics
(
aElement
)
.
GetAxisLength
(
CTD
)
}
;
}
)
;
}
template
<
class
Tag
>
float
ResolveImpl
(
ComputedStyle
const
&
aStyle
SVGElement
*
aElement
ResolverTypes
:
:
LengthPercentNoAuto
)
{
auto
const
&
value
=
aStyle
.
StyleSVGReset
(
)
-
>
*
Tag
:
:
Getter
;
return
ResolvePureLengthPercentage
<
Tag
:
:
CtxDirection
>
(
aElement
value
)
;
}
template
<
class
Tag
>
float
ResolveImpl
(
ComputedStyle
const
&
aStyle
SVGElement
*
aElement
ResolverTypes
:
:
LengthPercentWidthHeight
)
{
static_assert
(
std
:
:
is_same
<
Tag
Tags
:
:
Width
>
{
}
|
|
std
:
:
is_same
<
Tag
Tags
:
:
Height
>
{
}
"
Wrong
tag
"
)
;
auto
const
&
value
=
aStyle
.
StylePosition
(
)
-
>
*
Tag
:
:
Getter
;
if
(
value
.
IsLengthPercentage
(
)
)
{
return
ResolvePureLengthPercentage
<
Tag
:
:
CtxDirection
>
(
aElement
value
.
AsLengthPercentage
(
)
)
;
}
if
(
aElement
-
>
IsSVGElement
(
nsGkAtoms
:
:
image
)
)
{
auto
*
f
=
aElement
-
>
GetPrimaryFrame
(
)
;
MOZ_ASSERT
(
f
&
&
f
-
>
IsSVGImageFrame
(
)
)
;
auto
*
imgf
=
static_cast
<
nsSVGImageFrame
const
*
>
(
f
)
;
using
Other
=
typename
Tag
:
:
CounterPart
;
auto
const
&
valueOther
=
aStyle
.
StylePosition
(
)
-
>
*
Other
:
:
Getter
;
gfx
:
:
Size
intrinsicImageSize
;
if
(
!
imgf
-
>
GetIntrinsicImageSize
(
intrinsicImageSize
)
)
{
return
0
.
f
;
}
if
(
valueOther
.
IsLengthPercentage
(
)
)
{
float
intrinsicLengthOther
=
intrinsicImageSize
.
*
Other
:
:
SizeGetter
;
if
(
!
intrinsicLengthOther
)
{
return
0
.
f
;
}
float
intrinsicLength
=
intrinsicImageSize
.
*
Tag
:
:
SizeGetter
lengthOther
=
ResolvePureLengthPercentage
<
Other
:
:
CtxDirection
>
(
aElement
valueOther
.
AsLengthPercentage
(
)
)
;
return
intrinsicLength
*
lengthOther
/
intrinsicLengthOther
;
}
return
intrinsicImageSize
.
*
Tag
:
:
SizeGetter
;
}
return
0
.
f
;
}
template
<
class
Tag
>
float
ResolveImpl
(
ComputedStyle
const
&
aStyle
SVGElement
*
aElement
ResolverTypes
:
:
LengthPercentRXY
)
{
static_assert
(
std
:
:
is_same
<
Tag
Tags
:
:
Rx
>
{
}
|
|
std
:
:
is_same
<
Tag
Tags
:
:
Ry
>
{
}
"
Wrong
tag
"
)
;
auto
const
&
value
=
aStyle
.
StyleSVGReset
(
)
-
>
*
Tag
:
:
Getter
;
if
(
value
.
IsLengthPercentage
(
)
)
{
return
ResolvePureLengthPercentage
<
Tag
:
:
CtxDirection
>
(
aElement
value
.
AsLengthPercentage
(
)
)
;
}
MOZ_ASSERT
(
value
.
IsAuto
(
)
)
;
using
Rother
=
typename
Tag
:
:
CounterPart
;
auto
const
&
valueOther
=
aStyle
.
StyleSVGReset
(
)
-
>
*
Rother
:
:
Getter
;
if
(
valueOther
.
IsAuto
(
)
)
{
return
0
.
f
;
}
return
ResolvePureLengthPercentage
<
Rother
:
:
CtxDirection
>
(
aElement
valueOther
.
AsLengthPercentage
(
)
)
;
}
}
template
<
class
Tag
>
float
ResolveWith
(
const
ComputedStyle
&
aStyle
const
SVGElement
*
aElement
)
{
return
details
:
:
ResolveImpl
<
Tag
>
(
aStyle
const_cast
<
SVGElement
*
>
(
aElement
)
typename
Tag
:
:
ResolverType
{
}
)
;
}
template
<
class
Func
>
bool
DoForComputedStyle
(
SVGElement
*
aElement
Func
aFunc
)
{
if
(
const
nsIFrame
*
f
=
aElement
-
>
GetPrimaryFrame
(
)
)
{
aFunc
(
f
-
>
Style
(
)
)
;
return
true
;
}
if
(
RefPtr
<
ComputedStyle
>
computedStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
aElement
nullptr
)
)
{
aFunc
(
computedStyle
.
get
(
)
)
;
return
true
;
}
return
false
;
}
#
define
SVGGEOMETRYPROPERTY_EVAL_ALL
(
expr
)
\
(
void
)
details
:
:
dummy
{
0
(
static_cast
<
void
>
(
expr
)
0
)
.
.
.
}
template
<
class
.
.
.
Tags
>
bool
ResolveAll
(
const
SVGElement
*
aElement
details
:
:
AlwaysFloat
<
Tags
>
*
.
.
.
aRes
)
{
if
(
nsIFrame
const
*
f
=
aElement
-
>
GetPrimaryFrame
(
)
)
{
SVGGEOMETRYPROPERTY_EVAL_ALL
(
*
aRes
=
ResolveWith
<
Tags
>
(
*
f
-
>
Style
(
)
aElement
)
)
;
return
true
;
}
return
false
;
}
template
<
class
.
.
.
Tags
>
bool
ResolveAllAllowFallback
(
SVGElement
*
aElement
details
:
:
AlwaysFloat
<
Tags
>
*
.
.
.
aRes
)
{
bool
res
=
DoForComputedStyle
(
aElement
[
&
]
(
auto
const
*
style
)
{
SVGGEOMETRYPROPERTY_EVAL_ALL
(
*
aRes
=
ResolveWith
<
Tags
>
(
*
style
aElement
)
)
;
}
)
;
if
(
res
)
{
return
true
;
}
SVGGEOMETRYPROPERTY_EVAL_ALL
(
*
aRes
=
0
)
;
return
false
;
}
#
undef
SVGGEOMETRYPROPERTY_EVAL_ALL
nsCSSUnit
SpecifiedUnitTypeToCSSUnit
(
uint8_t
aSpecifiedUnit
)
;
nsCSSPropertyID
AttrEnumToCSSPropId
(
const
SVGElement
*
aElement
uint8_t
aAttrEnum
)
;
bool
IsNonNegativeGeometryProperty
(
nsCSSPropertyID
aProp
)
;
bool
ElementMapsLengthsToStyle
(
SVGElement
const
*
aElement
)
;
}
}
}
#
endif
